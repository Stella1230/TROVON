static void devm_phy_release(struct device *dev, void *res)\r\n{\r\nstruct phy *phy = *(struct phy **)res;\r\nphy_put(phy);\r\n}\r\nstatic void devm_phy_provider_release(struct device *dev, void *res)\r\n{\r\nstruct phy_provider *phy_provider = *(struct phy_provider **)res;\r\nof_phy_provider_unregister(phy_provider);\r\n}\r\nstatic void devm_phy_consume(struct device *dev, void *res)\r\n{\r\nstruct phy *phy = *(struct phy **)res;\r\nphy_destroy(phy);\r\n}\r\nstatic int devm_phy_match(struct device *dev, void *res, void *match_data)\r\n{\r\nstruct phy **phy = res;\r\nreturn *phy == match_data;\r\n}\r\nint phy_create_lookup(struct phy *phy, const char *con_id, const char *dev_id)\r\n{\r\nstruct phy_lookup *pl;\r\nif (!phy || !dev_id || !con_id)\r\nreturn -EINVAL;\r\npl = kzalloc(sizeof(*pl), GFP_KERNEL);\r\nif (!pl)\r\nreturn -ENOMEM;\r\npl->dev_id = dev_id;\r\npl->con_id = con_id;\r\npl->phy = phy;\r\nmutex_lock(&phy_provider_mutex);\r\nlist_add_tail(&pl->node, &phys);\r\nmutex_unlock(&phy_provider_mutex);\r\nreturn 0;\r\n}\r\nvoid phy_remove_lookup(struct phy *phy, const char *con_id, const char *dev_id)\r\n{\r\nstruct phy_lookup *pl;\r\nif (!phy || !dev_id || !con_id)\r\nreturn;\r\nmutex_lock(&phy_provider_mutex);\r\nlist_for_each_entry(pl, &phys, node)\r\nif (pl->phy == phy && !strcmp(pl->dev_id, dev_id) &&\r\n!strcmp(pl->con_id, con_id)) {\r\nlist_del(&pl->node);\r\nkfree(pl);\r\nbreak;\r\n}\r\nmutex_unlock(&phy_provider_mutex);\r\n}\r\nstatic struct phy *phy_find(struct device *dev, const char *con_id)\r\n{\r\nconst char *dev_id = dev_name(dev);\r\nstruct phy_lookup *p, *pl = NULL;\r\nmutex_lock(&phy_provider_mutex);\r\nlist_for_each_entry(p, &phys, node)\r\nif (!strcmp(p->dev_id, dev_id) && !strcmp(p->con_id, con_id)) {\r\npl = p;\r\nbreak;\r\n}\r\nmutex_unlock(&phy_provider_mutex);\r\nreturn pl ? pl->phy : ERR_PTR(-ENODEV);\r\n}\r\nstatic struct phy_provider *of_phy_provider_lookup(struct device_node *node)\r\n{\r\nstruct phy_provider *phy_provider;\r\nstruct device_node *child;\r\nlist_for_each_entry(phy_provider, &phy_provider_list, list) {\r\nif (phy_provider->dev->of_node == node)\r\nreturn phy_provider;\r\nfor_each_child_of_node(phy_provider->dev->of_node, child)\r\nif (child == node)\r\nreturn phy_provider;\r\n}\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\nint phy_pm_runtime_get(struct phy *phy)\r\n{\r\nint ret;\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn -ENOTSUPP;\r\nret = pm_runtime_get(&phy->dev);\r\nif (ret < 0 && ret != -EINPROGRESS)\r\npm_runtime_put_noidle(&phy->dev);\r\nreturn ret;\r\n}\r\nint phy_pm_runtime_get_sync(struct phy *phy)\r\n{\r\nint ret;\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn -ENOTSUPP;\r\nret = pm_runtime_get_sync(&phy->dev);\r\nif (ret < 0)\r\npm_runtime_put_sync(&phy->dev);\r\nreturn ret;\r\n}\r\nint phy_pm_runtime_put(struct phy *phy)\r\n{\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn -ENOTSUPP;\r\nreturn pm_runtime_put(&phy->dev);\r\n}\r\nint phy_pm_runtime_put_sync(struct phy *phy)\r\n{\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn -ENOTSUPP;\r\nreturn pm_runtime_put_sync(&phy->dev);\r\n}\r\nvoid phy_pm_runtime_allow(struct phy *phy)\r\n{\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn;\r\npm_runtime_allow(&phy->dev);\r\n}\r\nvoid phy_pm_runtime_forbid(struct phy *phy)\r\n{\r\nif (!pm_runtime_enabled(&phy->dev))\r\nreturn;\r\npm_runtime_forbid(&phy->dev);\r\n}\r\nint phy_init(struct phy *phy)\r\n{\r\nint ret;\r\nif (!phy)\r\nreturn 0;\r\nret = phy_pm_runtime_get_sync(phy);\r\nif (ret < 0 && ret != -ENOTSUPP)\r\nreturn ret;\r\nret = 0;\r\nmutex_lock(&phy->mutex);\r\nif (phy->init_count == 0 && phy->ops->init) {\r\nret = phy->ops->init(phy);\r\nif (ret < 0) {\r\ndev_err(&phy->dev, "phy init failed --> %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\n++phy->init_count;\r\nout:\r\nmutex_unlock(&phy->mutex);\r\nphy_pm_runtime_put(phy);\r\nreturn ret;\r\n}\r\nint phy_exit(struct phy *phy)\r\n{\r\nint ret;\r\nif (!phy)\r\nreturn 0;\r\nret = phy_pm_runtime_get_sync(phy);\r\nif (ret < 0 && ret != -ENOTSUPP)\r\nreturn ret;\r\nret = 0;\r\nmutex_lock(&phy->mutex);\r\nif (phy->init_count == 1 && phy->ops->exit) {\r\nret = phy->ops->exit(phy);\r\nif (ret < 0) {\r\ndev_err(&phy->dev, "phy exit failed --> %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\n--phy->init_count;\r\nout:\r\nmutex_unlock(&phy->mutex);\r\nphy_pm_runtime_put(phy);\r\nreturn ret;\r\n}\r\nint phy_power_on(struct phy *phy)\r\n{\r\nint ret;\r\nif (!phy)\r\nreturn 0;\r\nif (phy->pwr) {\r\nret = regulator_enable(phy->pwr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = phy_pm_runtime_get_sync(phy);\r\nif (ret < 0 && ret != -ENOTSUPP)\r\nreturn ret;\r\nret = 0;\r\nmutex_lock(&phy->mutex);\r\nif (phy->power_count == 0 && phy->ops->power_on) {\r\nret = phy->ops->power_on(phy);\r\nif (ret < 0) {\r\ndev_err(&phy->dev, "phy poweron failed --> %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\n++phy->power_count;\r\nmutex_unlock(&phy->mutex);\r\nreturn 0;\r\nout:\r\nmutex_unlock(&phy->mutex);\r\nphy_pm_runtime_put_sync(phy);\r\nif (phy->pwr)\r\nregulator_disable(phy->pwr);\r\nreturn ret;\r\n}\r\nint phy_power_off(struct phy *phy)\r\n{\r\nint ret;\r\nif (!phy)\r\nreturn 0;\r\nmutex_lock(&phy->mutex);\r\nif (phy->power_count == 1 && phy->ops->power_off) {\r\nret = phy->ops->power_off(phy);\r\nif (ret < 0) {\r\ndev_err(&phy->dev, "phy poweroff failed --> %d\n", ret);\r\nmutex_unlock(&phy->mutex);\r\nreturn ret;\r\n}\r\n}\r\n--phy->power_count;\r\nmutex_unlock(&phy->mutex);\r\nphy_pm_runtime_put(phy);\r\nif (phy->pwr)\r\nregulator_disable(phy->pwr);\r\nreturn 0;\r\n}\r\nstatic struct phy *_of_phy_get(struct device_node *np, int index)\r\n{\r\nint ret;\r\nstruct phy_provider *phy_provider;\r\nstruct phy *phy = NULL;\r\nstruct of_phandle_args args;\r\nret = of_parse_phandle_with_args(np, "phys", "#phy-cells",\r\nindex, &args);\r\nif (ret)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&phy_provider_mutex);\r\nphy_provider = of_phy_provider_lookup(args.np);\r\nif (IS_ERR(phy_provider) || !try_module_get(phy_provider->owner)) {\r\nphy = ERR_PTR(-EPROBE_DEFER);\r\ngoto out_unlock;\r\n}\r\nif (!of_device_is_available(args.np)) {\r\ndev_warn(phy_provider->dev, "Requested PHY is disabled\n");\r\nphy = ERR_PTR(-ENODEV);\r\ngoto out_put_module;\r\n}\r\nphy = phy_provider->of_xlate(phy_provider->dev, &args);\r\nout_put_module:\r\nmodule_put(phy_provider->owner);\r\nout_unlock:\r\nmutex_unlock(&phy_provider_mutex);\r\nof_node_put(args.np);\r\nreturn phy;\r\n}\r\nstruct phy *of_phy_get(struct device_node *np, const char *con_id)\r\n{\r\nstruct phy *phy = NULL;\r\nint index = 0;\r\nif (con_id)\r\nindex = of_property_match_string(np, "phy-names", con_id);\r\nphy = _of_phy_get(np, index);\r\nif (IS_ERR(phy))\r\nreturn phy;\r\nif (!try_module_get(phy->ops->owner))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nget_device(&phy->dev);\r\nreturn phy;\r\n}\r\nvoid phy_put(struct phy *phy)\r\n{\r\nif (!phy || IS_ERR(phy))\r\nreturn;\r\nmodule_put(phy->ops->owner);\r\nput_device(&phy->dev);\r\n}\r\nvoid devm_phy_put(struct device *dev, struct phy *phy)\r\n{\r\nint r;\r\nif (!phy)\r\nreturn;\r\nr = devres_destroy(dev, devm_phy_release, devm_phy_match, phy);\r\ndev_WARN_ONCE(dev, r, "couldn't find PHY resource\n");\r\n}\r\nstruct phy *of_phy_simple_xlate(struct device *dev, struct of_phandle_args\r\n*args)\r\n{\r\nstruct phy *phy;\r\nstruct class_dev_iter iter;\r\nclass_dev_iter_init(&iter, phy_class, NULL, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nphy = to_phy(dev);\r\nif (args->np != phy->dev.of_node)\r\ncontinue;\r\nclass_dev_iter_exit(&iter);\r\nreturn phy;\r\n}\r\nclass_dev_iter_exit(&iter);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstruct phy *phy_get(struct device *dev, const char *string)\r\n{\r\nint index = 0;\r\nstruct phy *phy;\r\nif (string == NULL) {\r\ndev_WARN(dev, "missing string\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (dev->of_node) {\r\nindex = of_property_match_string(dev->of_node, "phy-names",\r\nstring);\r\nphy = _of_phy_get(dev->of_node, index);\r\n} else {\r\nphy = phy_find(dev, string);\r\n}\r\nif (IS_ERR(phy))\r\nreturn phy;\r\nif (!try_module_get(phy->ops->owner))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nget_device(&phy->dev);\r\nreturn phy;\r\n}\r\nstruct phy *phy_optional_get(struct device *dev, const char *string)\r\n{\r\nstruct phy *phy = phy_get(dev, string);\r\nif (IS_ERR(phy) && (PTR_ERR(phy) == -ENODEV))\r\nphy = NULL;\r\nreturn phy;\r\n}\r\nstruct phy *devm_phy_get(struct device *dev, const char *string)\r\n{\r\nstruct phy **ptr, *phy;\r\nptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nphy = phy_get(dev, string);\r\nif (!IS_ERR(phy)) {\r\n*ptr = phy;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn phy;\r\n}\r\nstruct phy *devm_phy_optional_get(struct device *dev, const char *string)\r\n{\r\nstruct phy *phy = devm_phy_get(dev, string);\r\nif (IS_ERR(phy) && (PTR_ERR(phy) == -ENODEV))\r\nphy = NULL;\r\nreturn phy;\r\n}\r\nstruct phy *devm_of_phy_get(struct device *dev, struct device_node *np,\r\nconst char *con_id)\r\n{\r\nstruct phy **ptr, *phy;\r\nptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nphy = of_phy_get(np, con_id);\r\nif (!IS_ERR(phy)) {\r\n*ptr = phy;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn phy;\r\n}\r\nstruct phy *devm_of_phy_get_by_index(struct device *dev, struct device_node *np,\r\nint index)\r\n{\r\nstruct phy **ptr, *phy;\r\nptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nphy = _of_phy_get(np, index);\r\nif (!IS_ERR(phy)) {\r\n*ptr = phy;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn phy;\r\n}\r\nstruct phy *phy_create(struct device *dev, struct device_node *node,\r\nconst struct phy_ops *ops)\r\n{\r\nint ret;\r\nint id;\r\nstruct phy *phy;\r\nif (WARN_ON(!dev))\r\nreturn ERR_PTR(-EINVAL);\r\nphy = kzalloc(sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn ERR_PTR(-ENOMEM);\r\nid = ida_simple_get(&phy_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\ndev_err(dev, "unable to get id\n");\r\nret = id;\r\ngoto free_phy;\r\n}\r\ndevice_initialize(&phy->dev);\r\nmutex_init(&phy->mutex);\r\nphy->dev.class = phy_class;\r\nphy->dev.parent = dev;\r\nphy->dev.of_node = node ?: dev->of_node;\r\nphy->id = id;\r\nphy->ops = ops;\r\nret = dev_set_name(&phy->dev, "phy-%s.%d", dev_name(dev), id);\r\nif (ret)\r\ngoto put_dev;\r\nphy->pwr = regulator_get_optional(&phy->dev, "phy");\r\nif (IS_ERR(phy->pwr)) {\r\nret = PTR_ERR(phy->pwr);\r\nif (ret == -EPROBE_DEFER)\r\ngoto put_dev;\r\nphy->pwr = NULL;\r\n}\r\nret = device_add(&phy->dev);\r\nif (ret)\r\ngoto put_dev;\r\nif (pm_runtime_enabled(dev)) {\r\npm_runtime_enable(&phy->dev);\r\npm_runtime_no_callbacks(&phy->dev);\r\n}\r\nreturn phy;\r\nput_dev:\r\nput_device(&phy->dev);\r\nreturn ERR_PTR(ret);\r\nfree_phy:\r\nkfree(phy);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct phy *devm_phy_create(struct device *dev, struct device_node *node,\r\nconst struct phy_ops *ops)\r\n{\r\nstruct phy **ptr, *phy;\r\nptr = devres_alloc(devm_phy_consume, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nphy = phy_create(dev, node, ops);\r\nif (!IS_ERR(phy)) {\r\n*ptr = phy;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn phy;\r\n}\r\nvoid phy_destroy(struct phy *phy)\r\n{\r\npm_runtime_disable(&phy->dev);\r\ndevice_unregister(&phy->dev);\r\n}\r\nvoid devm_phy_destroy(struct device *dev, struct phy *phy)\r\n{\r\nint r;\r\nr = devres_destroy(dev, devm_phy_consume, devm_phy_match, phy);\r\ndev_WARN_ONCE(dev, r, "couldn't find PHY resource\n");\r\n}\r\nvoid of_phy_provider_unregister(struct phy_provider *phy_provider)\r\n{\r\nif (IS_ERR(phy_provider))\r\nreturn;\r\nmutex_lock(&phy_provider_mutex);\r\nlist_del(&phy_provider->list);\r\nkfree(phy_provider);\r\nmutex_unlock(&phy_provider_mutex);\r\n}\r\nvoid devm_of_phy_provider_unregister(struct device *dev,\r\nstruct phy_provider *phy_provider) {\r\nint r;\r\nr = devres_destroy(dev, devm_phy_provider_release, devm_phy_match,\r\nphy_provider);\r\ndev_WARN_ONCE(dev, r, "couldn't find PHY provider device resource\n");\r\n}\r\nstatic void phy_release(struct device *dev)\r\n{\r\nstruct phy *phy;\r\nphy = to_phy(dev);\r\ndev_vdbg(dev, "releasing '%s'\n", dev_name(dev));\r\nregulator_put(phy->pwr);\r\nida_simple_remove(&phy_ida, phy->id);\r\nkfree(phy);\r\n}\r\nstatic int __init phy_core_init(void)\r\n{\r\nphy_class = class_create(THIS_MODULE, "phy");\r\nif (IS_ERR(phy_class)) {\r\npr_err("failed to create phy class --> %ld\n",\r\nPTR_ERR(phy_class));\r\nreturn PTR_ERR(phy_class);\r\n}\r\nphy_class->dev_release = phy_release;\r\nreturn 0;\r\n}\r\nstatic void __exit phy_core_exit(void)\r\n{\r\nclass_destroy(phy_class);\r\n}
