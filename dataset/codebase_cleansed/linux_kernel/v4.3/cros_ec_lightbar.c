static ssize_t interval_msec_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long msec = lb_interval_jiffies * 1000 / HZ;\r\nreturn scnprintf(buf, PAGE_SIZE, "%lu\n", msec);\r\n}\r\nstatic ssize_t interval_msec_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long msec;\r\nif (kstrtoul(buf, 0, &msec))\r\nreturn -EINVAL;\r\nlb_interval_jiffies = msec * HZ / 1000;\r\nreturn count;\r\n}\r\nstatic int lb_throttle(void)\r\n{\r\nstatic unsigned long last_access;\r\nunsigned long now, next_timeslot;\r\nlong delay;\r\nint ret = 0;\r\nmutex_lock(&lb_mutex);\r\nnow = jiffies;\r\nnext_timeslot = last_access + lb_interval_jiffies;\r\nif (time_before(now, next_timeslot)) {\r\ndelay = (long)(next_timeslot) - (long)now;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (schedule_timeout(delay) > 0) {\r\nret = -EINTR;\r\ngoto out;\r\n}\r\nnow = jiffies;\r\n}\r\nlast_access = now;\r\nout:\r\nmutex_unlock(&lb_mutex);\r\nreturn ret;\r\n}\r\nstatic struct cros_ec_command *alloc_lightbar_cmd_msg(struct cros_ec_dev *ec)\r\n{\r\nstruct cros_ec_command *msg;\r\nint len;\r\nlen = max(sizeof(struct ec_params_lightbar),\r\nsizeof(struct ec_response_lightbar));\r\nmsg = kmalloc(sizeof(*msg) + len, GFP_KERNEL);\r\nif (!msg)\r\nreturn NULL;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_LIGHTBAR_CMD + ec->cmd_offset;\r\nmsg->outsize = sizeof(struct ec_params_lightbar);\r\nmsg->insize = sizeof(struct ec_response_lightbar);\r\nreturn msg;\r\n}\r\nstatic int get_lightbar_version(struct cros_ec_dev *ec,\r\nuint32_t *ver_ptr, uint32_t *flg_ptr)\r\n{\r\nstruct ec_params_lightbar *param;\r\nstruct ec_response_lightbar *resp;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nmsg = alloc_lightbar_cmd_msg(ec);\r\nif (!msg)\r\nreturn 0;\r\nparam = (struct ec_params_lightbar *)msg->data;\r\nparam->cmd = LIGHTBAR_CMD_VERSION;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0) {\r\nret = 0;\r\ngoto exit;\r\n}\r\nswitch (msg->result) {\r\ncase EC_RES_INVALID_PARAM:\r\nif (ver_ptr)\r\n*ver_ptr = 0;\r\nif (flg_ptr)\r\n*flg_ptr = 0;\r\nret = 1;\r\ngoto exit;\r\ncase EC_RES_SUCCESS:\r\nresp = (struct ec_response_lightbar *)msg->data;\r\nif (ver_ptr)\r\n*ver_ptr = resp->version.num;\r\nif (flg_ptr)\r\n*flg_ptr = resp->version.flags;\r\nret = 1;\r\ngoto exit;\r\n}\r\nret = 0;\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic ssize_t version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nuint32_t version = 0, flags = 0;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nint ret;\r\nret = lb_throttle();\r\nif (ret)\r\nreturn ret;\r\nif (!get_lightbar_version(ec, &version, &flags))\r\nreturn -EIO;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d %d\n", version, flags);\r\n}\r\nstatic ssize_t brightness_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ec_params_lightbar *param;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nunsigned int val;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nif (kstrtouint(buf, 0, &val))\r\nreturn -EINVAL;\r\nmsg = alloc_lightbar_cmd_msg(ec);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nparam = (struct ec_params_lightbar *)msg->data;\r\nparam->cmd = LIGHTBAR_CMD_SET_BRIGHTNESS;\r\nparam->set_brightness.num = val;\r\nret = lb_throttle();\r\nif (ret)\r\ngoto exit;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nret = count;\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic ssize_t led_rgb_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ec_params_lightbar *param;\r\nstruct cros_ec_command *msg;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nunsigned int val[4];\r\nint ret, i = 0, j = 0, ok = 0;\r\nmsg = alloc_lightbar_cmd_msg(ec);\r\nif (!msg)\r\nreturn -ENOMEM;\r\ndo {\r\nwhile (*buf && isspace(*buf))\r\nbuf++;\r\nif (!*buf)\r\nbreak;\r\nret = sscanf(buf, "%i", &val[i++]);\r\nif (ret == 0)\r\nreturn -EINVAL;\r\nif (i == 4) {\r\nparam = (struct ec_params_lightbar *)msg->data;\r\nparam->cmd = LIGHTBAR_CMD_SET_RGB;\r\nparam->set_rgb.led = val[0];\r\nparam->set_rgb.red = val[1];\r\nparam->set_rgb.green = val[2];\r\nparam->set_rgb.blue = val[3];\r\nif ((j++ % 4) == 0) {\r\nret = lb_throttle();\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ni = 0;\r\nok = 1;\r\n}\r\nwhile (*buf && !isspace(*buf))\r\nbuf++;\r\n} while (*buf);\r\nexit:\r\nkfree(msg);\r\nreturn (ok && i == 0) ? count : -EINVAL;\r\n}\r\nstatic ssize_t sequence_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ec_params_lightbar *param;\r\nstruct ec_response_lightbar *resp;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nmsg = alloc_lightbar_cmd_msg(ec);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nparam = (struct ec_params_lightbar *)msg->data;\r\nparam->cmd = LIGHTBAR_CMD_GET_SEQ;\r\nret = lb_throttle();\r\nif (ret)\r\ngoto exit;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nret = scnprintf(buf, PAGE_SIZE,\r\n"ERROR: EC returned %d\n", msg->result);\r\ngoto exit;\r\n}\r\nresp = (struct ec_response_lightbar *)msg->data;\r\nif (resp->get_seq.num >= ARRAY_SIZE(seqname))\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", resp->get_seq.num);\r\nelse\r\nret = scnprintf(buf, PAGE_SIZE, "%s\n",\r\nseqname[resp->get_seq.num]);\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic ssize_t sequence_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ec_params_lightbar *param;\r\nstruct cros_ec_command *msg;\r\nunsigned int num;\r\nint ret, len;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nmsg = alloc_lightbar_cmd_msg(ec);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nfor (len = 0; len < count; len++)\r\nif (!isalnum(buf[len]))\r\nbreak;\r\nfor (num = 0; num < ARRAY_SIZE(seqname); num++)\r\nif (!strncasecmp(seqname[num], buf, len))\r\nbreak;\r\nif (num >= ARRAY_SIZE(seqname)) {\r\nret = kstrtouint(buf, 0, &num);\r\nif (ret)\r\nreturn ret;\r\n}\r\nparam = (struct ec_params_lightbar *)msg->data;\r\nparam->cmd = LIGHTBAR_CMD_SEQ;\r\nparam->seq.num = num;\r\nret = lb_throttle();\r\nif (ret)\r\nreturn ret;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (msg->result != EC_RES_SUCCESS)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic umode_t cros_ec_lightbar_attrs_are_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nstruct platform_device *pdev = container_of(ec->dev,\r\nstruct platform_device, dev);\r\nif (pdev->id != 0)\r\nreturn 0;\r\nif (get_lightbar_version(ec, NULL, NULL))\r\nreturn a->mode;\r\nelse\r\nreturn 0;\r\n}
