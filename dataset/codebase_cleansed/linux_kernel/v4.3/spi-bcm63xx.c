static inline u8 bcm_spi_readb(struct bcm63xx_spi *bs,\r\nunsigned int offset)\r\n{\r\nreturn bcm_readb(bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline u16 bcm_spi_readw(struct bcm63xx_spi *bs,\r\nunsigned int offset)\r\n{\r\nreturn bcm_readw(bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline void bcm_spi_writeb(struct bcm63xx_spi *bs,\r\nu8 value, unsigned int offset)\r\n{\r\nbcm_writeb(value, bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline void bcm_spi_writew(struct bcm63xx_spi *bs,\r\nu16 value, unsigned int offset)\r\n{\r\nbcm_writew(value, bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic void bcm63xx_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);\r\nu8 clk_cfg, reg;\r\nint i;\r\nfor (i = 0; i < SPI_CLK_MASK; i++) {\r\nif (t->speed_hz >= bcm63xx_spi_freq_table[i][0]) {\r\nclk_cfg = bcm63xx_spi_freq_table[i][1];\r\nbreak;\r\n}\r\n}\r\nif (i == SPI_CLK_MASK)\r\nclk_cfg = SPI_CLK_0_391MHZ;\r\nreg = bcm_spi_readb(bs, SPI_CLK_CFG);\r\nreg &= ~SPI_CLK_MASK;\r\nreg |= clk_cfg;\r\nbcm_spi_writeb(bs, reg, SPI_CLK_CFG);\r\ndev_dbg(&spi->dev, "Setting clock register to %02x (hz %d)\n",\r\nclk_cfg, t->speed_hz);\r\n}\r\nstatic int bcm63xx_txrx_bufs(struct spi_device *spi, struct spi_transfer *first,\r\nunsigned int num_transfers)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);\r\nu16 msg_ctl;\r\nu16 cmd;\r\nu8 rx_tail;\r\nunsigned int i, timeout = 0, prepend_len = 0, len = 0;\r\nstruct spi_transfer *t = first;\r\nbool do_rx = false;\r\nbool do_tx = false;\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\ndev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",\r\nt->tx_buf, t->rx_buf, t->len);\r\nif (num_transfers > 1 && t->tx_buf && t->len <= BCM63XX_SPI_MAX_PREPEND)\r\nprepend_len = t->len;\r\nfor (i = 0; i < num_transfers; i++) {\r\nif (t->tx_buf) {\r\ndo_tx = true;\r\nmemcpy_toio(bs->tx_io + len, t->tx_buf, t->len);\r\nif (t != first)\r\nprepend_len = 0;\r\n}\r\nif (t->rx_buf) {\r\ndo_rx = true;\r\nif (t == first)\r\nprepend_len = 0;\r\n}\r\nlen += t->len;\r\nt = list_entry(t->transfer_list.next, struct spi_transfer,\r\ntransfer_list);\r\n}\r\nreinit_completion(&bs->done);\r\nmsg_ctl = (len << SPI_BYTE_CNT_SHIFT);\r\nif (do_rx && do_tx && prepend_len == 0)\r\nmsg_ctl |= (SPI_FD_RW << bs->msg_type_shift);\r\nelse if (do_rx)\r\nmsg_ctl |= (SPI_HD_R << bs->msg_type_shift);\r\nelse if (do_tx)\r\nmsg_ctl |= (SPI_HD_W << bs->msg_type_shift);\r\nswitch (bs->msg_ctl_width) {\r\ncase 8:\r\nbcm_spi_writeb(bs, msg_ctl, SPI_MSG_CTL);\r\nbreak;\r\ncase 16:\r\nbcm_spi_writew(bs, msg_ctl, SPI_MSG_CTL);\r\nbreak;\r\n}\r\ncmd = SPI_CMD_START_IMMEDIATE;\r\ncmd |= (prepend_len << SPI_CMD_PREPEND_BYTE_CNT_SHIFT);\r\ncmd |= (spi->chip_select << SPI_CMD_DEVICE_ID_SHIFT);\r\nbcm_spi_writew(bs, cmd, SPI_CMD);\r\nbcm_spi_writeb(bs, SPI_INTR_CMD_DONE, SPI_INT_MASK);\r\ntimeout = wait_for_completion_timeout(&bs->done, HZ);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nif (!do_rx)\r\nreturn 0;\r\nlen = 0;\r\nt = first;\r\nfor (i = 0; i < num_transfers; i++) {\r\nif (t->rx_buf)\r\nmemcpy_fromio(t->rx_buf, bs->rx_io + len, t->len);\r\nif (t != first || prepend_len == 0)\r\nlen += t->len;\r\nt = list_entry(t->transfer_list.next, struct spi_transfer,\r\ntransfer_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nstruct spi_transfer *t, *first = NULL;\r\nstruct spi_device *spi = m->spi;\r\nint status = 0;\r\nunsigned int n_transfers = 0, total_len = 0;\r\nbool can_use_prepend = false;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (!first)\r\nfirst = t;\r\nn_transfers++;\r\ntotal_len += t->len;\r\nif (n_transfers == 2 && !first->rx_buf && !t->tx_buf &&\r\nfirst->len <= BCM63XX_SPI_MAX_PREPEND)\r\ncan_use_prepend = true;\r\nelse if (can_use_prepend && t->tx_buf)\r\ncan_use_prepend = false;\r\nif ((can_use_prepend &&\r\ntotal_len > (bs->fifo_size + BCM63XX_SPI_MAX_PREPEND)) ||\r\n(!can_use_prepend && total_len > bs->fifo_size)) {\r\ndev_err(&spi->dev, "unable to do transfers larger than FIFO size (%i > %i)\n",\r\ntotal_len, bs->fifo_size);\r\nstatus = -EINVAL;\r\ngoto exit;\r\n}\r\nif (t->speed_hz != first->speed_hz) {\r\ndev_err(&spi->dev, "unable to change speed between transfers\n");\r\nstatus = -EINVAL;\r\ngoto exit;\r\n}\r\nif (t->delay_usecs) {\r\ndev_err(&spi->dev, "unable to keep CS asserted after transfer\n");\r\nstatus = -EINVAL;\r\ngoto exit;\r\n}\r\nif (t->cs_change ||\r\nlist_is_last(&t->transfer_list, &m->transfers)) {\r\nbcm63xx_spi_setup_transfer(spi, first);\r\nstatus = bcm63xx_txrx_bufs(spi, first, n_transfers);\r\nif (status)\r\ngoto exit;\r\nm->actual_length += total_len;\r\nfirst = NULL;\r\nn_transfers = 0;\r\ntotal_len = 0;\r\ncan_use_prepend = false;\r\n}\r\n}\r\nexit:\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bcm63xx_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = (struct spi_master *)dev_id;\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nu8 intr;\r\nintr = bcm_spi_readb(bs, SPI_INT_STATUS);\r\nbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\nif (intr & SPI_INTR_CMD_DONE)\r\ncomplete(&bs->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm63xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm63xx_spi_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nint irq;\r\nstruct spi_master *master;\r\nstruct clk *clk;\r\nstruct bcm63xx_spi *bs;\r\nint ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -ENXIO;\r\n}\r\nclk = devm_clk_get(dev, "spi");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "no clock for device\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(*bs));\r\nif (!master) {\r\ndev_err(dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nbs = spi_master_get_devdata(master);\r\ninit_completion(&bs->done);\r\nplatform_set_drvdata(pdev, master);\r\nbs->pdev = pdev;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbs->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(bs->regs)) {\r\nret = PTR_ERR(bs->regs);\r\ngoto out_err;\r\n}\r\nbs->irq = irq;\r\nbs->clk = clk;\r\nbs->fifo_size = pdata->fifo_size;\r\nret = devm_request_irq(&pdev->dev, irq, bcm63xx_spi_interrupt, 0,\r\npdev->name, master);\r\nif (ret) {\r\ndev_err(dev, "unable to request irq\n");\r\ngoto out_err;\r\n}\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmaster->transfer_one_message = bcm63xx_spi_transfer_one;\r\nmaster->mode_bits = MODEBITS;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->auto_runtime_pm = true;\r\nbs->msg_type_shift = pdata->msg_type_shift;\r\nbs->msg_ctl_width = pdata->msg_ctl_width;\r\nbs->tx_io = (u8 *)(bs->regs + bcm63xx_spireg(SPI_MSG_DATA));\r\nbs->rx_io = (const u8 *)(bs->regs + bcm63xx_spireg(SPI_RX_DATA));\r\nswitch (bs->msg_ctl_width) {\r\ncase 8:\r\ncase 16:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported MSG_CTL width: %d\n",\r\nbs->msg_ctl_width);\r\ngoto out_err;\r\n}\r\nret = clk_prepare_enable(bs->clk);\r\nif (ret)\r\ngoto out_err;\r\nbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret) {\r\ndev_err(dev, "spi register failed\n");\r\ngoto out_clk_disable;\r\n}\r\ndev_info(dev, "at 0x%08x (irq %d, FIFOs size %d)\n",\r\nr->start, irq, bs->fifo_size);\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable_unprepare(clk);\r\nout_err:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int bcm63xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\nclk_disable_unprepare(bs->clk);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable_unprepare(bs->clk);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(bs->clk);\r\nif (ret)\r\nreturn ret;\r\nspi_master_resume(master);\r\nreturn 0;\r\n}
