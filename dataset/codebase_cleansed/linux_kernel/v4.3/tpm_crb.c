static u8 crb_status(struct tpm_chip *chip)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nu8 sts = 0;\r\nif ((le32_to_cpu(ioread32(&priv->cca->start)) & CRB_START_INVOKE) !=\r\nCRB_START_INVOKE)\r\nsts |= CRB_STS_COMPLETE;\r\nreturn sts;\r\n}\r\nstatic int crb_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nunsigned int expected;\r\nif (count < 6)\r\nreturn -EIO;\r\nif (le32_to_cpu(ioread32(&priv->cca->sts)) & CRB_CA_STS_ERROR)\r\nreturn -EIO;\r\nmemcpy_fromio(buf, priv->rsp, 6);\r\nexpected = be32_to_cpup((__be32 *) &buf[2]);\r\nif (expected > count)\r\nreturn -EIO;\r\nmemcpy_fromio(&buf[6], &priv->rsp[6], expected - 6);\r\nreturn expected;\r\n}\r\nstatic int crb_do_acpi_start(struct tpm_chip *chip)\r\n{\r\nunion acpi_object *obj;\r\nint rc;\r\nobj = acpi_evaluate_dsm(chip->acpi_dev_handle,\r\nCRB_ACPI_START_UUID,\r\nCRB_ACPI_START_REVISION_ID,\r\nCRB_ACPI_START_INDEX,\r\nNULL);\r\nif (!obj)\r\nreturn -ENXIO;\r\nrc = obj->integer.value == 0 ? 0 : -ENXIO;\r\nACPI_FREE(obj);\r\nreturn rc;\r\n}\r\nstatic int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nint rc = 0;\r\nif (len > le32_to_cpu(ioread32(&priv->cca->cmd_size))) {\r\ndev_err(&chip->dev,\r\n"invalid command count value %x %zx\n",\r\n(unsigned int) len,\r\n(size_t) le32_to_cpu(ioread32(&priv->cca->cmd_size)));\r\nreturn -E2BIG;\r\n}\r\nmemcpy_toio(priv->cmd, buf, len);\r\nwmb();\r\nif (priv->flags & CRB_FL_CRB_START)\r\niowrite32(cpu_to_le32(CRB_START_INVOKE), &priv->cca->start);\r\nif (priv->flags & CRB_FL_ACPI_START)\r\nrc = crb_do_acpi_start(chip);\r\nreturn rc;\r\n}\r\nstatic void crb_cancel(struct tpm_chip *chip)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\niowrite32(cpu_to_le32(CRB_CANCEL_INVOKE), &priv->cca->cancel);\r\nwmb();\r\nif ((priv->flags & CRB_FL_ACPI_START) && crb_do_acpi_start(chip))\r\ndev_err(&chip->dev, "ACPI Start failed\n");\r\niowrite32(0, &priv->cca->cancel);\r\n}\r\nstatic bool crb_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nu32 cancel = le32_to_cpu(ioread32(&priv->cca->cancel));\r\nreturn (cancel & CRB_CANCEL_INVOKE) == CRB_CANCEL_INVOKE;\r\n}\r\nstatic int crb_acpi_add(struct acpi_device *device)\r\n{\r\nstruct tpm_chip *chip;\r\nstruct acpi_tpm2 *buf;\r\nstruct crb_priv *priv;\r\nstruct device *dev = &device->dev;\r\nacpi_status status;\r\nu32 sm;\r\nu64 pa;\r\nint rc;\r\nchip = tpmm_chip_alloc(dev, &tpm_crb);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\nchip->flags = TPM_CHIP_FLAG_TPM2;\r\nstatus = acpi_get_table(ACPI_SIG_TPM2, 1,\r\n(struct acpi_table_header **) &buf);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(dev, "failed to get TPM2 ACPI table\n");\r\nreturn -ENODEV;\r\n}\r\nif (!buf->control_area_pa) {\r\ndev_err(dev, "TPM2 ACPI table has a zero address for the control area\n");\r\nreturn -EINVAL;\r\n}\r\nif (buf->hdr.length < sizeof(struct acpi_tpm2)) {\r\ndev_err(dev, "TPM2 ACPI table has wrong size");\r\nreturn -EINVAL;\r\n}\r\npriv = (struct crb_priv *) devm_kzalloc(dev, sizeof(struct crb_priv),\r\nGFP_KERNEL);\r\nif (!priv) {\r\ndev_err(dev, "failed to devm_kzalloc for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nsm = le32_to_cpu(buf->start_method);\r\nif (sm == CRB_SM_CRB || sm == CRB_SM_CRB_WITH_ACPI_START ||\r\n!strcmp(acpi_device_hid(device), "MSFT0101"))\r\npriv->flags |= CRB_FL_CRB_START;\r\nif (sm == CRB_SM_ACPI_START || sm == CRB_SM_CRB_WITH_ACPI_START)\r\npriv->flags |= CRB_FL_ACPI_START;\r\npriv->cca = (struct crb_control_area __iomem *)\r\ndevm_ioremap_nocache(dev, buf->control_area_pa, 0x1000);\r\nif (!priv->cca) {\r\ndev_err(dev, "ioremap of the control area failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy_fromio(&pa, &priv->cca->cmd_pa, 8);\r\npa = le64_to_cpu(pa);\r\npriv->cmd = devm_ioremap_nocache(dev, pa,\r\nioread32(&priv->cca->cmd_size));\r\nif (!priv->cmd) {\r\ndev_err(dev, "ioremap of the command buffer failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy_fromio(&pa, &priv->cca->rsp_pa, 8);\r\npa = le64_to_cpu(pa);\r\npriv->rsp = devm_ioremap_nocache(dev, pa,\r\nioread32(&priv->cca->rsp_size));\r\nif (!priv->rsp) {\r\ndev_err(dev, "ioremap of the response buffer failed\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->vendor.priv = priv;\r\nchip->vendor.timeout_a = msecs_to_jiffies(TPM2_TIMEOUT_A);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TPM2_TIMEOUT_B);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TPM2_TIMEOUT_C);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TPM2_TIMEOUT_D);\r\nchip->vendor.duration[TPM_SHORT] =\r\nmsecs_to_jiffies(TPM2_DURATION_SHORT);\r\nchip->vendor.duration[TPM_MEDIUM] =\r\nmsecs_to_jiffies(TPM2_DURATION_MEDIUM);\r\nchip->vendor.duration[TPM_LONG] =\r\nmsecs_to_jiffies(TPM2_DURATION_LONG);\r\nchip->acpi_dev_handle = device->handle;\r\nrc = tpm2_do_selftest(chip);\r\nif (rc)\r\nreturn rc;\r\nreturn tpm_chip_register(chip);\r\n}\r\nstatic int crb_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct device *dev = &device->dev;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_shutdown(chip, TPM2_SU_CLEAR);\r\nreturn 0;\r\n}
