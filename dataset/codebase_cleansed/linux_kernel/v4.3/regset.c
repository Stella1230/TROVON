int regset_fpregs_active(struct task_struct *target, const struct user_regset *regset)\r\n{\r\nstruct fpu *target_fpu = &target->thread.fpu;\r\nreturn target_fpu->fpstate_active ? regset->n : 0;\r\n}\r\nint regset_xregset_fpregs_active(struct task_struct *target, const struct user_regset *regset)\r\n{\r\nstruct fpu *target_fpu = &target->thread.fpu;\r\nreturn (cpu_has_fxsr && target_fpu->fpstate_active) ? regset->n : 0;\r\n}\r\nint xfpregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nif (!cpu_has_fxsr)\r\nreturn -ENODEV;\r\nfpu__activate_fpstate_read(fpu);\r\nfpstate_sanitize_xstate(fpu);\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&fpu->state.fxsave, 0, -1);\r\n}\r\nint xfpregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nint ret;\r\nif (!cpu_has_fxsr)\r\nreturn -ENODEV;\r\nfpu__activate_fpstate_write(fpu);\r\nfpstate_sanitize_xstate(fpu);\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&fpu->state.fxsave, 0, -1);\r\nfpu->state.fxsave.mxcsr &= mxcsr_feature_mask;\r\nif (cpu_has_xsave)\r\nfpu->state.xsave.header.xfeatures |= XSTATE_FPSSE;\r\nreturn ret;\r\n}\r\nint xstateregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nstruct xregs_state *xsave;\r\nint ret;\r\nif (!cpu_has_xsave)\r\nreturn -ENODEV;\r\nfpu__activate_fpstate_read(fpu);\r\nxsave = &fpu->state.xsave;\r\nmemcpy(&xsave->i387.sw_reserved,\r\nxstate_fx_sw_bytes, sizeof(xstate_fx_sw_bytes));\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\r\nreturn ret;\r\n}\r\nint xstateregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nstruct xregs_state *xsave;\r\nint ret;\r\nif (!cpu_has_xsave)\r\nreturn -ENODEV;\r\nfpu__activate_fpstate_write(fpu);\r\nxsave = &fpu->state.xsave;\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\r\nxsave->i387.mxcsr &= mxcsr_feature_mask;\r\nxsave->header.xfeatures &= xfeatures_mask;\r\nmemset(&xsave->header.reserved, 0, 48);\r\nreturn ret;\r\n}\r\nstatic inline unsigned short twd_i387_to_fxsr(unsigned short twd)\r\n{\r\nunsigned int tmp;\r\ntmp = ~twd;\r\ntmp = (tmp | (tmp>>1)) & 0x5555;\r\ntmp = (tmp | (tmp >> 1)) & 0x3333;\r\ntmp = (tmp | (tmp >> 2)) & 0x0f0f;\r\ntmp = (tmp | (tmp >> 4)) & 0x00ff;\r\nreturn tmp;\r\n}\r\nstatic inline u32 twd_fxsr_to_i387(struct fxregs_state *fxsave)\r\n{\r\nstruct _fpxreg *st;\r\nu32 tos = (fxsave->swd >> 11) & 7;\r\nu32 twd = (unsigned long) fxsave->twd;\r\nu32 tag;\r\nu32 ret = 0xffff0000u;\r\nint i;\r\nfor (i = 0; i < 8; i++, twd >>= 1) {\r\nif (twd & 0x1) {\r\nst = FPREG_ADDR(fxsave, (i - tos) & 7);\r\nswitch (st->exponent & 0x7fff) {\r\ncase 0x7fff:\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\ncase 0x0000:\r\nif (!st->significand[0] &&\r\n!st->significand[1] &&\r\n!st->significand[2] &&\r\n!st->significand[3])\r\ntag = FP_EXP_TAG_ZERO;\r\nelse\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\ndefault:\r\nif (st->significand[3] & 0x8000)\r\ntag = FP_EXP_TAG_VALID;\r\nelse\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\n}\r\n} else {\r\ntag = FP_EXP_TAG_EMPTY;\r\n}\r\nret |= tag << (2 * i);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nconvert_from_fxsr(struct user_i387_ia32_struct *env, struct task_struct *tsk)\r\n{\r\nstruct fxregs_state *fxsave = &tsk->thread.fpu.state.fxsave;\r\nstruct _fpreg *to = (struct _fpreg *) &env->st_space[0];\r\nstruct _fpxreg *from = (struct _fpxreg *) &fxsave->st_space[0];\r\nint i;\r\nenv->cwd = fxsave->cwd | 0xffff0000u;\r\nenv->swd = fxsave->swd | 0xffff0000u;\r\nenv->twd = twd_fxsr_to_i387(fxsave);\r\n#ifdef CONFIG_X86_64\r\nenv->fip = fxsave->rip;\r\nenv->foo = fxsave->rdp;\r\nenv->fcs = task_pt_regs(tsk)->cs;\r\nif (tsk == current) {\r\nsavesegment(ds, env->fos);\r\n} else {\r\nenv->fos = tsk->thread.ds;\r\n}\r\nenv->fos |= 0xffff0000;\r\n#else\r\nenv->fip = fxsave->fip;\r\nenv->fcs = (u16) fxsave->fcs | ((u32) fxsave->fop << 16);\r\nenv->foo = fxsave->foo;\r\nenv->fos = fxsave->fos;\r\n#endif\r\nfor (i = 0; i < 8; ++i)\r\nmemcpy(&to[i], &from[i], sizeof(to[0]));\r\n}\r\nvoid convert_to_fxsr(struct task_struct *tsk,\r\nconst struct user_i387_ia32_struct *env)\r\n{\r\nstruct fxregs_state *fxsave = &tsk->thread.fpu.state.fxsave;\r\nstruct _fpreg *from = (struct _fpreg *) &env->st_space[0];\r\nstruct _fpxreg *to = (struct _fpxreg *) &fxsave->st_space[0];\r\nint i;\r\nfxsave->cwd = env->cwd;\r\nfxsave->swd = env->swd;\r\nfxsave->twd = twd_i387_to_fxsr(env->twd);\r\nfxsave->fop = (u16) ((u32) env->fcs >> 16);\r\n#ifdef CONFIG_X86_64\r\nfxsave->rip = env->fip;\r\nfxsave->rdp = env->foo;\r\n#else\r\nfxsave->fip = env->fip;\r\nfxsave->fcs = (env->fcs & 0xffff);\r\nfxsave->foo = env->foo;\r\nfxsave->fos = env->fos;\r\n#endif\r\nfor (i = 0; i < 8; ++i)\r\nmemcpy(&to[i], &from[i], sizeof(from[0]));\r\n}\r\nint fpregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nstruct user_i387_ia32_struct env;\r\nfpu__activate_fpstate_read(fpu);\r\nif (!static_cpu_has(X86_FEATURE_FPU))\r\nreturn fpregs_soft_get(target, regset, pos, count, kbuf, ubuf);\r\nif (!cpu_has_fxsr)\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&fpu->state.fsave, 0,\r\n-1);\r\nfpstate_sanitize_xstate(fpu);\r\nif (kbuf && pos == 0 && count == sizeof(env)) {\r\nconvert_from_fxsr(kbuf, target);\r\nreturn 0;\r\n}\r\nconvert_from_fxsr(&env, target);\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, &env, 0, -1);\r\n}\r\nint fpregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct fpu *fpu = &target->thread.fpu;\r\nstruct user_i387_ia32_struct env;\r\nint ret;\r\nfpu__activate_fpstate_write(fpu);\r\nfpstate_sanitize_xstate(fpu);\r\nif (!static_cpu_has(X86_FEATURE_FPU))\r\nreturn fpregs_soft_set(target, regset, pos, count, kbuf, ubuf);\r\nif (!cpu_has_fxsr)\r\nreturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&fpu->state.fsave, 0,\r\n-1);\r\nif (pos > 0 || count < sizeof(env))\r\nconvert_from_fxsr(&env, target);\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &env, 0, -1);\r\nif (!ret)\r\nconvert_to_fxsr(target, &env);\r\nif (cpu_has_xsave)\r\nfpu->state.xsave.header.xfeatures |= XSTATE_FP;\r\nreturn ret;\r\n}\r\nint dump_fpu(struct pt_regs *regs, struct user_i387_struct *ufpu)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct fpu *fpu = &tsk->thread.fpu;\r\nint fpvalid;\r\nfpvalid = fpu->fpstate_active;\r\nif (fpvalid)\r\nfpvalid = !fpregs_get(tsk, NULL,\r\n0, sizeof(struct user_i387_ia32_struct),\r\nufpu, NULL);\r\nreturn fpvalid;\r\n}
