static struct dmaengine_pcm *soc_platform_to_pcm(struct snd_soc_platform *p)\r\n{\r\nreturn container_of(p, struct dmaengine_pcm, platform);\r\n}\r\nstatic struct device *dmaengine_dma_dev(struct dmaengine_pcm *pcm,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nif (!pcm->chan[substream->stream])\r\nreturn NULL;\r\nreturn pcm->chan[substream->stream]->device->dev;\r\n}\r\nint snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\r\nif (ret)\r\nreturn ret;\r\nsnd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,\r\nslave_config);\r\nreturn 0;\r\n}\r\nstatic int dmaengine_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);\r\nint (*prepare_slave_config)(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct dma_slave_config *slave_config);\r\nstruct dma_slave_config slave_config;\r\nint ret;\r\nmemset(&slave_config, 0, sizeof(slave_config));\r\nif (!pcm->config)\r\nprepare_slave_config = snd_dmaengine_pcm_prepare_slave_config;\r\nelse\r\nprepare_slave_config = pcm->config->prepare_slave_config;\r\nif (prepare_slave_config) {\r\nret = prepare_slave_config(substream, params, &slave_config);\r\nif (ret)\r\nreturn ret;\r\nret = dmaengine_slave_config(chan, &slave_config);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\n}\r\nstatic int dmaengine_pcm_set_runtime_hwparams(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct device *dma_dev = dmaengine_dma_dev(pcm, substream);\r\nstruct dma_chan *chan = pcm->chan[substream->stream];\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nstruct dma_slave_caps dma_caps;\r\nstruct snd_pcm_hardware hw;\r\nu32 addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\r\nBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\r\nBIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\nint i, ret;\r\nif (pcm->config && pcm->config->pcm_hardware)\r\nreturn snd_soc_set_runtime_hwparams(substream,\r\npcm->config->pcm_hardware);\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nmemset(&hw, 0, sizeof(hw));\r\nhw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_INTERLEAVED;\r\nhw.periods_min = 2;\r\nhw.periods_max = UINT_MAX;\r\nhw.period_bytes_min = 256;\r\nhw.period_bytes_max = dma_get_max_seg_size(dma_dev);\r\nhw.buffer_bytes_max = SIZE_MAX;\r\nhw.fifo_size = dma_data->fifo_size;\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)\r\nhw.info |= SNDRV_PCM_INFO_BATCH;\r\nret = dma_get_slave_caps(chan, &dma_caps);\r\nif (ret == 0) {\r\nif (dma_caps.cmd_pause)\r\nhw.info |= SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME;\r\nif (dma_caps.residue_granularity <= DMA_RESIDUE_GRANULARITY_SEGMENT)\r\nhw.info |= SNDRV_PCM_INFO_BATCH;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naddr_widths = dma_caps.dst_addr_widths;\r\nelse\r\naddr_widths = dma_caps.src_addr_widths;\r\n}\r\nfor (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {\r\nint bits = snd_pcm_format_physical_width(i);\r\nswitch (bits) {\r\ncase 8:\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\ncase 64:\r\nif (addr_widths & (1 << (bits / 8)))\r\nhw.formats |= (1LL << i);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn snd_soc_set_runtime_hwparams(substream, &hw);\r\n}\r\nstatic int dmaengine_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct dma_chan *chan = pcm->chan[substream->stream];\r\nint ret;\r\nret = dmaengine_pcm_set_runtime_hwparams(substream);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_dmaengine_pcm_open(substream, chan);\r\n}\r\nstatic struct dma_chan *dmaengine_pcm_compat_request_channel(\r\nstruct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\ndma_filter_fn fn = NULL;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])\r\nreturn pcm->chan[0];\r\nif (pcm->config && pcm->config->compat_request_channel)\r\nreturn pcm->config->compat_request_channel(rtd, substream);\r\nif (pcm->config)\r\nfn = pcm->config->compat_filter_fn;\r\nreturn snd_dmaengine_pcm_request_channel(fn, dma_data->filter_data);\r\n}\r\nstatic bool dmaengine_pcm_can_report_residue(struct device *dev,\r\nstruct dma_chan *chan)\r\n{\r\nstruct dma_slave_caps dma_caps;\r\nint ret;\r\nret = dma_get_slave_caps(chan, &dma_caps);\r\nif (ret != 0) {\r\ndev_warn(dev, "Failed to get DMA channel capabilities, falling back to period counting: %d\n",\r\nret);\r\nreturn false;\r\n}\r\nif (dma_caps.residue_granularity == DMA_RESIDUE_GRANULARITY_DESCRIPTOR)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int dmaengine_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nconst struct snd_dmaengine_pcm_config *config = pcm->config;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nstruct snd_pcm_substream *substream;\r\nsize_t prealloc_buffer_size;\r\nsize_t max_buffer_size;\r\nunsigned int i;\r\nint ret;\r\nif (config && config->prealloc_buffer_size) {\r\nprealloc_buffer_size = config->prealloc_buffer_size;\r\nmax_buffer_size = config->pcm_hardware->buffer_bytes_max;\r\n} else {\r\nprealloc_buffer_size = 512 * 1024;\r\nmax_buffer_size = SIZE_MAX;\r\n}\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {\r\nsubstream = rtd->pcm->streams[i].substream;\r\nif (!substream)\r\ncontinue;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (!pcm->chan[i] &&\r\n(pcm->flags & SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME))\r\npcm->chan[i] = dma_request_slave_channel(dev,\r\ndma_data->chan_name);\r\nif (!pcm->chan[i] && (pcm->flags & SND_DMAENGINE_PCM_FLAG_COMPAT)) {\r\npcm->chan[i] = dmaengine_pcm_compat_request_channel(rtd,\r\nsubstream);\r\n}\r\nif (!pcm->chan[i]) {\r\ndev_err(rtd->platform->dev,\r\n"Missing dma channel for stream: %d\n", i);\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV_IRAM,\r\ndmaengine_dma_dev(pcm, substream),\r\nprealloc_buffer_size,\r\nmax_buffer_size);\r\nif (ret)\r\nreturn ret;\r\nif (!dmaengine_pcm_can_report_residue(dev, pcm->chan[i]))\r\npcm->flags |= SND_DMAENGINE_PCM_FLAG_NO_RESIDUE;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t dmaengine_pcm_pointer(\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)\r\nreturn snd_dmaengine_pcm_pointer_no_residue(substream);\r\nelse\r\nreturn snd_dmaengine_pcm_pointer(substream);\r\n}\r\nstatic int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,\r\nstruct device *dev, const struct snd_dmaengine_pcm_config *config)\r\n{\r\nunsigned int i;\r\nconst char *name;\r\nstruct dma_chan *chan;\r\nif ((pcm->flags & (SND_DMAENGINE_PCM_FLAG_NO_DT |\r\nSND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME)) ||\r\n!dev->of_node)\r\nreturn 0;\r\nif (config && config->dma_dev) {\r\ndev_warn(dev, "DMA channels sourced from device %s",\r\ndev_name(config->dma_dev));\r\ndev = config->dma_dev;\r\n}\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE;\r\ni++) {\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\r\nname = "rx-tx";\r\nelse\r\nname = dmaengine_pcm_dma_channel_names[i];\r\nif (config && config->chan_names[i])\r\nname = config->chan_names[i];\r\nchan = dma_request_slave_channel_reason(dev, name);\r\nif (IS_ERR(chan)) {\r\nif (PTR_ERR(chan) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\npcm->chan[i] = NULL;\r\n} else {\r\npcm->chan[i] = chan;\r\n}\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\r\nbreak;\r\n}\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\r\npcm->chan[1] = pcm->chan[0];\r\nreturn 0;\r\n}\r\nstatic void dmaengine_pcm_release_chan(struct dmaengine_pcm *pcm)\r\n{\r\nunsigned int i;\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE;\r\ni++) {\r\nif (!pcm->chan[i])\r\ncontinue;\r\ndma_release_channel(pcm->chan[i]);\r\nif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\r\nbreak;\r\n}\r\n}\r\nint snd_dmaengine_pcm_register(struct device *dev,\r\nconst struct snd_dmaengine_pcm_config *config, unsigned int flags)\r\n{\r\nstruct dmaengine_pcm *pcm;\r\nint ret;\r\npcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn -ENOMEM;\r\npcm->config = config;\r\npcm->flags = flags;\r\nret = dmaengine_pcm_request_chan_of(pcm, dev, config);\r\nif (ret)\r\ngoto err_free_dma;\r\nret = snd_soc_add_platform(dev, &pcm->platform,\r\n&dmaengine_pcm_platform);\r\nif (ret)\r\ngoto err_free_dma;\r\nreturn 0;\r\nerr_free_dma:\r\ndmaengine_pcm_release_chan(pcm);\r\nkfree(pcm);\r\nreturn ret;\r\n}\r\nvoid snd_dmaengine_pcm_unregister(struct device *dev)\r\n{\r\nstruct snd_soc_platform *platform;\r\nstruct dmaengine_pcm *pcm;\r\nplatform = snd_soc_lookup_platform(dev);\r\nif (!platform)\r\nreturn;\r\npcm = soc_platform_to_pcm(platform);\r\nsnd_soc_remove_platform(platform);\r\ndmaengine_pcm_release_chan(pcm);\r\nkfree(pcm);\r\n}
