static unsigned int mc13xxx_max_brightness(int id)\r\n{\r\nif (id >= MC13783_LED_MD && id <= MC13783_LED_KP)\r\nreturn 0x0f;\r\nelse if (id >= MC13783_LED_R1 && id <= MC13783_LED_B3)\r\nreturn 0x1f;\r\nreturn 0x3f;\r\n}\r\nstatic void mc13xxx_led_work(struct work_struct *work)\r\n{\r\nstruct mc13xxx_led *led = container_of(work, struct mc13xxx_led, work);\r\nstruct mc13xxx_leds *leds = led->leds;\r\nunsigned int reg, bank, off, shift;\r\nswitch (led->id) {\r\ncase MC13783_LED_MD:\r\ncase MC13783_LED_AD:\r\ncase MC13783_LED_KP:\r\nreg = 2;\r\nshift = 9 + (led->id - MC13783_LED_MD) * 4;\r\nbreak;\r\ncase MC13783_LED_R1:\r\ncase MC13783_LED_G1:\r\ncase MC13783_LED_B1:\r\ncase MC13783_LED_R2:\r\ncase MC13783_LED_G2:\r\ncase MC13783_LED_B2:\r\ncase MC13783_LED_R3:\r\ncase MC13783_LED_G3:\r\ncase MC13783_LED_B3:\r\noff = led->id - MC13783_LED_R1;\r\nbank = off / 3;\r\nreg = 3 + bank;\r\nshift = (off - bank * 3) * 5 + 6;\r\nbreak;\r\ncase MC13892_LED_MD:\r\ncase MC13892_LED_AD:\r\ncase MC13892_LED_KP:\r\nreg = (led->id - MC13892_LED_MD) / 2;\r\nshift = 3 + (led->id - MC13892_LED_MD) * 12;\r\nbreak;\r\ncase MC13892_LED_R:\r\ncase MC13892_LED_G:\r\ncase MC13892_LED_B:\r\noff = led->id - MC13892_LED_R;\r\nbank = off / 2;\r\nreg = 2 + bank;\r\nshift = (off - bank * 2) * 12 + 3;\r\nbreak;\r\ncase MC34708_LED_R:\r\ncase MC34708_LED_G:\r\nreg = 0;\r\nshift = 3 + (led->id - MC34708_LED_R) * 12;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmc13xxx_reg_rmw(leds->master, leds->devtype->ledctrl_base + reg,\r\nmc13xxx_max_brightness(led->id) << shift,\r\nled->new_brightness << shift);\r\n}\r\nstatic void mc13xxx_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct mc13xxx_led *led =\r\ncontainer_of(led_cdev, struct mc13xxx_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic struct mc13xxx_leds_platform_data __init *mc13xxx_led_probe_dt(\r\nstruct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds *leds = platform_get_drvdata(pdev);\r\nstruct mc13xxx_leds_platform_data *pdata;\r\nstruct device_node *parent, *child;\r\nstruct device *dev = &pdev->dev;\r\nint i = 0, ret = -ENODATA;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nparent = of_get_child_by_name(dev->parent->of_node, "leds");\r\nif (!parent)\r\ngoto out_node_put;\r\nret = of_property_read_u32_array(parent, "led-control",\r\npdata->led_control,\r\nleds->devtype->num_regs);\r\nif (ret)\r\ngoto out_node_put;\r\npdata->num_leds = of_get_child_count(parent);\r\npdata->led = devm_kzalloc(dev, pdata->num_leds * sizeof(*pdata->led),\r\nGFP_KERNEL);\r\nif (!pdata->led) {\r\nret = -ENOMEM;\r\ngoto out_node_put;\r\n}\r\nfor_each_child_of_node(parent, child) {\r\nconst char *str;\r\nu32 tmp;\r\nif (of_property_read_u32(child, "reg", &tmp))\r\ncontinue;\r\npdata->led[i].id = leds->devtype->led_min + tmp;\r\nif (!of_property_read_string(child, "label", &str))\r\npdata->led[i].name = str;\r\nif (!of_property_read_string(child, "linux,default-trigger",\r\n&str))\r\npdata->led[i].default_trigger = str;\r\ni++;\r\n}\r\npdata->num_leds = i;\r\nret = i > 0 ? 0 : -ENODATA;\r\nout_node_put:\r\nof_node_put(parent);\r\nreturn ret ? ERR_PTR(ret) : pdata;\r\n}\r\nstatic inline struct mc13xxx_leds_platform_data __init *mc13xxx_led_probe_dt(\r\nstruct platform_device *pdev)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int __init mc13xxx_led_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mc13xxx_leds_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mc13xxx *mcdev = dev_get_drvdata(dev->parent);\r\nstruct mc13xxx_led_devtype *devtype =\r\n(struct mc13xxx_led_devtype *)pdev->id_entry->driver_data;\r\nstruct mc13xxx_leds *leds;\r\nint i, id, ret = -ENODATA;\r\nu32 init_led = 0;\r\nleds = devm_kzalloc(dev, sizeof(*leds), GFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nleds->devtype = devtype;\r\nleds->master = mcdev;\r\nplatform_set_drvdata(pdev, leds);\r\nif (dev->parent->of_node) {\r\npdata = mc13xxx_led_probe_dt(pdev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n} else if (!pdata)\r\nreturn -ENODATA;\r\nleds->num_leds = pdata->num_leds;\r\nif ((leds->num_leds < 1) ||\r\n(leds->num_leds > (devtype->led_max - devtype->led_min + 1))) {\r\ndev_err(dev, "Invalid LED count %d\n", leds->num_leds);\r\nreturn -EINVAL;\r\n}\r\nleds->led = devm_kzalloc(dev, leds->num_leds * sizeof(*leds->led),\r\nGFP_KERNEL);\r\nif (!leds->led)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < devtype->num_regs; i++) {\r\nret = mc13xxx_reg_write(mcdev, leds->devtype->ledctrl_base + i,\r\npdata->led_control[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < leds->num_leds; i++) {\r\nconst char *name, *trig;\r\nret = -EINVAL;\r\nid = pdata->led[i].id;\r\nname = pdata->led[i].name;\r\ntrig = pdata->led[i].default_trigger;\r\nif ((id > devtype->led_max) || (id < devtype->led_min)) {\r\ndev_err(dev, "Invalid ID %i\n", id);\r\nbreak;\r\n}\r\nif (init_led & (1 << id)) {\r\ndev_warn(dev, "LED %i already initialized\n", id);\r\nbreak;\r\n}\r\ninit_led |= 1 << id;\r\nleds->led[i].id = id;\r\nleds->led[i].leds = leds;\r\nleds->led[i].cdev.name = name;\r\nleds->led[i].cdev.default_trigger = trig;\r\nleds->led[i].cdev.flags = LED_CORE_SUSPENDRESUME;\r\nleds->led[i].cdev.brightness_set = mc13xxx_led_set;\r\nleds->led[i].cdev.max_brightness = mc13xxx_max_brightness(id);\r\nINIT_WORK(&leds->led[i].work, mc13xxx_led_work);\r\nret = led_classdev_register(dev->parent, &leds->led[i].cdev);\r\nif (ret) {\r\ndev_err(dev, "Failed to register LED %i\n", id);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nwhile (--i >= 0) {\r\nled_classdev_unregister(&leds->led[i].cdev);\r\ncancel_work_sync(&leds->led[i].work);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mc13xxx_led_remove(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds *leds = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < leds->num_leds; i++) {\r\nled_classdev_unregister(&leds->led[i].cdev);\r\ncancel_work_sync(&leds->led[i].work);\r\n}\r\nreturn 0;\r\n}
