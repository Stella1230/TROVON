static inline unsigned int serial_in(struct uart_port *port, int offset)\r\n{\r\nreturn readl_relaxed(port->membase + offset);\r\n}\r\nstatic inline void serial_out(struct uart_port *port, int offset, int value)\r\n{\r\nwritel_relaxed(value, port->membase + offset);\r\n}\r\nstatic unsigned int sprd_tx_empty(struct uart_port *port)\r\n{\r\nif (serial_in(port, SPRD_STS1) & 0xff00)\r\nreturn 0;\r\nelse\r\nreturn TIOCSER_TEMT;\r\n}\r\nstatic unsigned int sprd_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void sprd_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void sprd_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int ien, iclr;\r\niclr = serial_in(port, SPRD_ICLR);\r\nien = serial_in(port, SPRD_IEN);\r\niclr |= SPRD_IEN_TX_EMPTY;\r\nien &= ~SPRD_IEN_TX_EMPTY;\r\nserial_out(port, SPRD_ICLR, iclr);\r\nserial_out(port, SPRD_IEN, ien);\r\n}\r\nstatic void sprd_start_tx(struct uart_port *port)\r\n{\r\nunsigned int ien;\r\nien = serial_in(port, SPRD_IEN);\r\nif (!(ien & SPRD_IEN_TX_EMPTY)) {\r\nien |= SPRD_IEN_TX_EMPTY;\r\nserial_out(port, SPRD_IEN, ien);\r\n}\r\n}\r\nstatic void sprd_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int ien, iclr;\r\niclr = serial_in(port, SPRD_ICLR);\r\nien = serial_in(port, SPRD_IEN);\r\nien &= ~(SPRD_IEN_RX_FULL | SPRD_IEN_BREAK_DETECT);\r\niclr |= SPRD_IEN_RX_FULL | SPRD_IEN_BREAK_DETECT;\r\nserial_out(port, SPRD_IEN, ien);\r\nserial_out(port, SPRD_ICLR, iclr);\r\n}\r\nstatic void sprd_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int handle_lsr_errors(struct uart_port *port,\r\nunsigned int *flag,\r\nunsigned int *lsr)\r\n{\r\nint ret = 0;\r\nif (*lsr & SPRD_LSR_BI) {\r\n*lsr &= ~(SPRD_LSR_FE | SPRD_LSR_PE);\r\nport->icount.brk++;\r\nret = uart_handle_break(port);\r\nif (ret)\r\nreturn ret;\r\n} else if (*lsr & SPRD_LSR_PE)\r\nport->icount.parity++;\r\nelse if (*lsr & SPRD_LSR_FE)\r\nport->icount.frame++;\r\nif (*lsr & SPRD_LSR_OE)\r\nport->icount.overrun++;\r\n*lsr &= port->read_status_mask;\r\nif (*lsr & SPRD_LSR_BI)\r\n*flag = TTY_BREAK;\r\nelse if (*lsr & SPRD_LSR_PE)\r\n*flag = TTY_PARITY;\r\nelse if (*lsr & SPRD_LSR_FE)\r\n*flag = TTY_FRAME;\r\nreturn ret;\r\n}\r\nstatic inline void sprd_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tty = &port->state->port;\r\nunsigned int ch, flag, lsr, max_count = SPRD_TIMEOUT;\r\nwhile ((serial_in(port, SPRD_STS1) & 0x00ff) && max_count--) {\r\nlsr = serial_in(port, SPRD_LSR);\r\nch = serial_in(port, SPRD_RXD);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (lsr & (SPRD_LSR_BI | SPRD_LSR_PE |\r\nSPRD_LSR_FE | SPRD_LSR_OE))\r\nif (handle_lsr_errors(port, &lsr, &flag))\r\ncontinue;\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nuart_insert_char(port, lsr, SPRD_LSR_OE, ch, flag);\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic inline void sprd_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint count;\r\nif (port->x_char) {\r\nserial_out(port, SPRD_TXD, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nsprd_stop_tx(port);\r\nreturn;\r\n}\r\ncount = THLD_TX_EMPTY;\r\ndo {\r\nserial_out(port, SPRD_TXD, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nsprd_stop_tx(port);\r\n}\r\nstatic irqreturn_t sprd_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned int ims;\r\nspin_lock(&port->lock);\r\nims = serial_in(port, SPRD_IMSR);\r\nif (!ims) {\r\nspin_unlock(&port->lock);\r\nreturn IRQ_NONE;\r\n}\r\nserial_out(port, SPRD_ICLR, ~0);\r\nif (ims & (SPRD_IMSR_RX_FIFO_FULL |\r\nSPRD_IMSR_BREAK_DETECT | SPRD_IMSR_TIMEOUT))\r\nsprd_rx(port);\r\nif (ims & SPRD_IMSR_TX_FIFO_EMPTY)\r\nsprd_tx(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sprd_startup(struct uart_port *port)\r\n{\r\nint ret = 0;\r\nunsigned int ien, fc;\r\nunsigned int timeout;\r\nstruct sprd_uart_port *sp;\r\nunsigned long flags;\r\nserial_out(port, SPRD_CTL2, ((THLD_TX_EMPTY << 8) | THLD_RX_FULL));\r\ntimeout = SPRD_TIMEOUT;\r\nwhile (timeout-- && serial_in(port, SPRD_STS1) & 0x00ff)\r\nserial_in(port, SPRD_RXD);\r\ntimeout = SPRD_TIMEOUT;\r\nwhile (timeout-- && serial_in(port, SPRD_STS1) & 0xff00)\r\ncpu_relax();\r\nserial_out(port, SPRD_IEN, 0);\r\nserial_out(port, SPRD_ICLR, ~0);\r\nsp = container_of(port, struct sprd_uart_port, port);\r\nsnprintf(sp->name, sizeof(sp->name), "sprd_serial%d", port->line);\r\nret = devm_request_irq(port->dev, port->irq, sprd_handle_irq,\r\nIRQF_SHARED, sp->name, port);\r\nif (ret) {\r\ndev_err(port->dev, "fail to request serial irq %d, ret=%d\n",\r\nport->irq, ret);\r\nreturn ret;\r\n}\r\nfc = serial_in(port, SPRD_CTL1);\r\nfc |= RX_TOUT_THLD_DEF | RX_HFC_THLD_DEF;\r\nserial_out(port, SPRD_CTL1, fc);\r\nspin_lock_irqsave(&port->lock, flags);\r\nien = serial_in(port, SPRD_IEN);\r\nien |= SPRD_IEN_RX_FULL | SPRD_IEN_BREAK_DETECT | SPRD_IEN_TIMEOUT;\r\nserial_out(port, SPRD_IEN, ien);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sprd_shutdown(struct uart_port *port)\r\n{\r\nserial_out(port, SPRD_IEN, 0);\r\nserial_out(port, SPRD_ICLR, ~0);\r\ndevm_free_irq(port->dev, port->irq, port);\r\n}\r\nstatic void sprd_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud, quot;\r\nunsigned int lcr = 0, fc;\r\nunsigned long flags;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, SPRD_BAUD_IO_LIMIT);\r\nquot = (unsigned int)((port->uartclk + baud / 2) / baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr |= SPRD_LCR_DATA_LEN5;\r\nbreak;\r\ncase CS6:\r\nlcr |= SPRD_LCR_DATA_LEN6;\r\nbreak;\r\ncase CS7:\r\nlcr |= SPRD_LCR_DATA_LEN7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr |= SPRD_LCR_DATA_LEN8;\r\nbreak;\r\n}\r\nlcr &= ~(SPRD_LCR_STOP_1BIT | SPRD_LCR_STOP_2BIT);\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= SPRD_LCR_STOP_2BIT;\r\nelse\r\nlcr |= SPRD_LCR_STOP_1BIT;\r\nlcr &= ~SPRD_LCR_PARITY;\r\ntermios->c_cflag &= ~CMSPAR;\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= SPRD_LCR_PARITY_EN;\r\nif (termios->c_cflag & PARODD)\r\nlcr |= SPRD_LCR_ODD_PAR;\r\nelse\r\nlcr |= SPRD_LCR_EVEN_PAR;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = SPRD_LSR_OE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= SPRD_LSR_FE | SPRD_LSR_PE;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= SPRD_LSR_BI;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= SPRD_LSR_PE | SPRD_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= SPRD_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= SPRD_LSR_OE;\r\n}\r\nfc = serial_in(port, SPRD_CTL1);\r\nfc &= ~(RX_HW_FLOW_CTL_THLD | RX_HW_FLOW_CTL_EN | TX_HW_FLOW_CTL_EN);\r\nif (termios->c_cflag & CRTSCTS) {\r\nfc |= RX_HW_FLOW_CTL_THLD;\r\nfc |= RX_HW_FLOW_CTL_EN;\r\nfc |= TX_HW_FLOW_CTL_EN;\r\n}\r\nserial_out(port, SPRD_CLKD0, quot & 0xffff);\r\nserial_out(port, SPRD_CLKD1, (quot & 0x1f0000) >> 16);\r\nserial_out(port, SPRD_LCR, lcr);\r\nfc |= RX_TOUT_THLD_DEF | RX_HFC_THLD_DEF;\r\nserial_out(port, SPRD_CTL1, fc);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nstatic const char *sprd_type(struct uart_port *port)\r\n{\r\nreturn "SPX";\r\n}\r\nstatic void sprd_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sprd_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sprd_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_SPRD;\r\n}\r\nstatic int sprd_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_SPRD)\r\nreturn -EINVAL;\r\nif (port->irq != ser->irq)\r\nreturn -EINVAL;\r\nif (port->iotype != ser->io_type)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_port *port)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = serial_in(port, SPRD_STS1);\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (status & 0xff00);\r\n}\r\nstatic void sprd_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwait_for_xmitr(port);\r\nserial_out(port, SPRD_TXD, ch);\r\n}\r\nstatic void sprd_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &sprd_port[co->index]->port;\r\nint locked = 1;\r\nunsigned long flags;\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_console_write(port, s, count, sprd_console_putchar);\r\nwait_for_xmitr(port);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int __init sprd_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= UART_NR_MAX || co->index < 0)\r\nco->index = 0;\r\nport = &sprd_port[co->index]->port;\r\nif (port == NULL) {\r\npr_info("serial port %d not yet initialized\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void sprd_putc(struct uart_port *port, int c)\r\n{\r\nunsigned int timeout = SPRD_TIMEOUT;\r\nwhile (timeout-- &&\r\n!(readl(port->membase + SPRD_LSR) & SPRD_LSR_TX_OVER))\r\ncpu_relax();\r\nwriteb(c, port->membase + SPRD_TXD);\r\n}\r\nstatic void sprd_early_write(struct console *con, const char *s,\r\nunsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, sprd_putc);\r\n}\r\nstatic int __init sprd_early_console_setup(\r\nstruct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = sprd_early_write;\r\nreturn 0;\r\n}\r\nstatic int sprd_probe_dt_alias(int index, struct device *dev)\r\n{\r\nstruct device_node *np;\r\nint ret = index;\r\nif (!IS_ENABLED(CONFIG_OF))\r\nreturn ret;\r\nnp = dev->of_node;\r\nif (!np)\r\nreturn ret;\r\nret = of_alias_get_id(np, "serial");\r\nif (IS_ERR_VALUE(ret))\r\nret = index;\r\nelse if (ret >= ARRAY_SIZE(sprd_port) || sprd_port[ret] != NULL) {\r\ndev_warn(dev, "requested serial port %d not available.\n", ret);\r\nret = index;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sprd_remove(struct platform_device *dev)\r\n{\r\nstruct sprd_uart_port *sup = platform_get_drvdata(dev);\r\nif (sup) {\r\nuart_remove_one_port(&sprd_uart_driver, &sup->port);\r\nsprd_port[sup->port.line] = NULL;\r\nsprd_ports_num--;\r\n}\r\nif (!sprd_ports_num)\r\nuart_unregister_driver(&sprd_uart_driver);\r\nreturn 0;\r\n}\r\nstatic int sprd_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct uart_port *up;\r\nstruct clk *clk;\r\nint irq;\r\nint index;\r\nint ret;\r\nfor (index = 0; index < ARRAY_SIZE(sprd_port); index++)\r\nif (sprd_port[index] == NULL)\r\nbreak;\r\nif (index == ARRAY_SIZE(sprd_port))\r\nreturn -EBUSY;\r\nindex = sprd_probe_dt_alias(index, &pdev->dev);\r\nsprd_port[index] = devm_kzalloc(&pdev->dev,\r\nsizeof(*sprd_port[index]), GFP_KERNEL);\r\nif (!sprd_port[index])\r\nreturn -ENOMEM;\r\nup = &sprd_port[index]->port;\r\nup->dev = &pdev->dev;\r\nup->line = index;\r\nup->type = PORT_SPRD;\r\nup->iotype = UPIO_MEM;\r\nup->uartclk = SPRD_DEF_RATE;\r\nup->fifosize = SPRD_FIFO_SIZE;\r\nup->ops = &serial_sprd_ops;\r\nup->flags = UPF_BOOT_AUTOCONF;\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR_OR_NULL(clk))\r\nup->uartclk = clk_get_rate(clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "not provide mem resource\n");\r\nreturn -ENODEV;\r\n}\r\nup->mapbase = res->start;\r\nup->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(up->membase))\r\nreturn PTR_ERR(up->membase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "not provide irq resource\n");\r\nreturn -ENODEV;\r\n}\r\nup->irq = irq;\r\nif (!sprd_ports_num) {\r\nret = uart_register_driver(&sprd_uart_driver);\r\nif (ret < 0) {\r\npr_err("Failed to register SPRD-UART driver\n");\r\nreturn ret;\r\n}\r\n}\r\nsprd_ports_num++;\r\nret = uart_add_one_port(&sprd_uart_driver, up);\r\nif (ret) {\r\nsprd_port[index] = NULL;\r\nsprd_remove(pdev);\r\n}\r\nplatform_set_drvdata(pdev, up);\r\nreturn ret;\r\n}\r\nstatic int sprd_suspend(struct device *dev)\r\n{\r\nstruct sprd_uart_port *sup = dev_get_drvdata(dev);\r\nuart_suspend_port(&sprd_uart_driver, &sup->port);\r\nreturn 0;\r\n}\r\nstatic int sprd_resume(struct device *dev)\r\n{\r\nstruct sprd_uart_port *sup = dev_get_drvdata(dev);\r\nuart_resume_port(&sprd_uart_driver, &sup->port);\r\nreturn 0;\r\n}
