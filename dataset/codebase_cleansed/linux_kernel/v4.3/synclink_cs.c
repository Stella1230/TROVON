static void irq_disable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)\r\n{\r\nif (channel == CHA) {\r\ninfo->imra_value |= mask;\r\nwrite_reg16(info, CHA + IMR, info->imra_value);\r\n} else {\r\ninfo->imrb_value |= mask;\r\nwrite_reg16(info, CHB + IMR, info->imrb_value);\r\n}\r\n}\r\nstatic void irq_enable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)\r\n{\r\nif (channel == CHA) {\r\ninfo->imra_value &= ~mask;\r\nwrite_reg16(info, CHA + IMR, info->imra_value);\r\n} else {\r\ninfo->imrb_value &= ~mask;\r\nwrite_reg16(info, CHB + IMR, info->imrb_value);\r\n}\r\n}\r\nstatic void* mgslpc_get_text_ptr(void)\r\n{\r\nreturn mgslpc_get_text_ptr;\r\n}\r\nstatic void ldisc_receive_buf(struct tty_struct *tty,\r\nconst __u8 *data, char *flags, int count)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (!tty)\r\nreturn;\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->receive_buf)\r\nld->ops->receive_buf(tty, data, flags, count);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nstatic int mgslpc_probe(struct pcmcia_device *link)\r\n{\r\nMGSLPC_INFO *info;\r\nint ret;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("mgslpc_attach\n");\r\ninfo = kzalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);\r\nif (!info) {\r\nprintk("Error can't allocate device instance data\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->magic = MGSLPC_MAGIC;\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &mgslpc_port_ops;\r\nINIT_WORK(&info->task, bh_handler);\r\ninfo->max_frame_size = 4096;\r\ninfo->port.close_delay = 5*HZ/10;\r\ninfo->port.closing_wait = 30*HZ;\r\ninit_waitqueue_head(&info->status_event_wait_q);\r\ninit_waitqueue_head(&info->event_wait_q);\r\nspin_lock_init(&info->lock);\r\nspin_lock_init(&info->netlock);\r\nmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\r\ninfo->idle_mode = HDLC_TXIDLE_FLAGS;\r\ninfo->imra_value = 0xffff;\r\ninfo->imrb_value = 0xffff;\r\ninfo->pim_value = 0xff;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nret = mgslpc_config(link);\r\nif (ret != 0)\r\ngoto failed;\r\nret = mgslpc_add_device(info);\r\nif (ret != 0)\r\ngoto failed_release;\r\nreturn 0;\r\nfailed_release:\r\nmgslpc_release((u_long)link);\r\nfailed:\r\ntty_port_destroy(&info->port);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int mgslpc_ioprobe(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int mgslpc_config(struct pcmcia_device *link)\r\n{\r\nMGSLPC_INFO *info = link->priv;\r\nint ret;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("mgslpc_config(0x%p)\n", link);\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, mgslpc_ioprobe, NULL);\r\nif (ret != 0)\r\ngoto failed;\r\nlink->config_index = 8;\r\nlink->config_regs = PRESENT_OPTION;\r\nret = pcmcia_request_irq(link, mgslpc_isr);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ninfo->io_base = link->resource[0]->start;\r\ninfo->irq_level = link->irq;\r\nreturn 0;\r\nfailed:\r\nmgslpc_release((u_long)link);\r\nreturn -ENODEV;\r\n}\r\nstatic void mgslpc_release(u_long arg)\r\n{\r\nstruct pcmcia_device *link = (struct pcmcia_device *)arg;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("mgslpc_release(0x%p)\n", link);\r\npcmcia_disable_device(link);\r\n}\r\nstatic void mgslpc_detach(struct pcmcia_device *link)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("mgslpc_detach(0x%p)\n", link);\r\n((MGSLPC_INFO *)link->priv)->stop = 1;\r\nmgslpc_release((u_long)link);\r\nmgslpc_remove_device((MGSLPC_INFO *)link->priv);\r\n}\r\nstatic int mgslpc_suspend(struct pcmcia_device *link)\r\n{\r\nMGSLPC_INFO *info = link->priv;\r\ninfo->stop = 1;\r\nreturn 0;\r\n}\r\nstatic int mgslpc_resume(struct pcmcia_device *link)\r\n{\r\nMGSLPC_INFO *info = link->priv;\r\ninfo->stop = 0;\r\nreturn 0;\r\n}\r\nstatic inline bool mgslpc_paranoia_check(MGSLPC_INFO *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef MGSLPC_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for mgsl struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null mgslpc_info for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn true;\r\n}\r\nif (info->magic != MGSLPC_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn true;\r\n}\r\n#else\r\nif (!info)\r\nreturn true;\r\n#endif\r\nreturn false;\r\n}\r\nstatic bool wait_command_complete(MGSLPC_INFO *info, unsigned char channel)\r\n{\r\nint i = 0;\r\nwhile (read_reg(info, (unsigned char)(channel+STAR)) & BIT2) {\r\nudelay(1);\r\nif (i++ == 1000)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void issue_command(MGSLPC_INFO *info, unsigned char channel, unsigned char cmd)\r\n{\r\nwait_command_complete(info, channel);\r\nwrite_reg(info, (unsigned char) (channel + CMDR), cmd);\r\n}\r\nstatic void tx_pause(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (mgslpc_paranoia_check(info, tty->name, "tx_pause"))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("tx_pause(%s)\n", info->device_name);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->tx_enabled)\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic void tx_release(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (mgslpc_paranoia_check(info, tty->name, "tx_release"))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("tx_release(%s)\n", info->device_name);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_enabled)\r\ntx_start(info, tty);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic int bh_action(MGSLPC_INFO *info)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->pending_bh & BH_RECEIVE) {\r\ninfo->pending_bh &= ~BH_RECEIVE;\r\nrc = BH_RECEIVE;\r\n} else if (info->pending_bh & BH_TRANSMIT) {\r\ninfo->pending_bh &= ~BH_TRANSMIT;\r\nrc = BH_TRANSMIT;\r\n} else if (info->pending_bh & BH_STATUS) {\r\ninfo->pending_bh &= ~BH_STATUS;\r\nrc = BH_STATUS;\r\n}\r\nif (!rc) {\r\ninfo->bh_running = false;\r\ninfo->bh_requested = false;\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void bh_handler(struct work_struct *work)\r\n{\r\nMGSLPC_INFO *info = container_of(work, MGSLPC_INFO, task);\r\nstruct tty_struct *tty;\r\nint action;\r\nif (debug_level >= DEBUG_LEVEL_BH)\r\nprintk("%s(%d):bh_handler(%s) entry\n",\r\n__FILE__,__LINE__,info->device_name);\r\ninfo->bh_running = true;\r\ntty = tty_port_tty_get(&info->port);\r\nwhile((action = bh_action(info)) != 0) {\r\nif (debug_level >= DEBUG_LEVEL_BH)\r\nprintk("%s(%d):bh_handler() work item action=%d\n",\r\n__FILE__,__LINE__,action);\r\nswitch (action) {\r\ncase BH_RECEIVE:\r\nwhile(rx_get_frame(info, tty));\r\nbreak;\r\ncase BH_TRANSMIT:\r\nbh_transmit(info, tty);\r\nbreak;\r\ncase BH_STATUS:\r\nbh_status(info);\r\nbreak;\r\ndefault:\r\nprintk("Unknown work item ID=%08X!\n", action);\r\nbreak;\r\n}\r\n}\r\ntty_kref_put(tty);\r\nif (debug_level >= DEBUG_LEVEL_BH)\r\nprintk("%s(%d):bh_handler(%s) exit\n",\r\n__FILE__,__LINE__,info->device_name);\r\n}\r\nstatic void bh_transmit(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_BH)\r\nprintk("bh_transmit() entry on %s\n", info->device_name);\r\nif (tty)\r\ntty_wakeup(tty);\r\n}\r\nstatic void bh_status(MGSLPC_INFO *info)\r\n{\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\n}\r\nstatic void rx_ready_hdlc(MGSLPC_INFO *info, int eom)\r\n{\r\nunsigned char data[2];\r\nunsigned char fifo_count, read_count, i;\r\nRXBUF *buf = (RXBUF*)(info->rx_buf + (info->rx_put * info->rx_buf_size));\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):rx_ready_hdlc(eom=%d)\n", __FILE__, __LINE__, eom);\r\nif (!info->rx_enabled)\r\nreturn;\r\nif (info->rx_frame_count >= info->rx_buf_count) {\r\nissue_command(info, CHA, CMD_RXRESET);\r\ninfo->pending_bh |= BH_RECEIVE;\r\ninfo->rx_overflow = true;\r\ninfo->icount.buf_overrun++;\r\nreturn;\r\n}\r\nif (eom) {\r\nfifo_count = (unsigned char)(read_reg(info, CHA+RBCL) & 0x1f);\r\nif (fifo_count == 0)\r\nfifo_count = 32;\r\n} else\r\nfifo_count = 32;\r\ndo {\r\nif (fifo_count == 1) {\r\nread_count = 1;\r\ndata[0] = read_reg(info, CHA + RXFIFO);\r\n} else {\r\nread_count = 2;\r\n*((unsigned short *) data) = read_reg16(info, CHA + RXFIFO);\r\n}\r\nfifo_count -= read_count;\r\nif (!fifo_count && eom)\r\nbuf->status = data[--read_count];\r\nfor (i = 0; i < read_count; i++) {\r\nif (buf->count >= info->max_frame_size) {\r\nissue_command(info, CHA, CMD_RXRESET);\r\nbuf->count = 0;\r\nreturn;\r\n}\r\n*(buf->data + buf->count) = data[i];\r\nbuf->count++;\r\n}\r\n} while (fifo_count);\r\nif (eom) {\r\ninfo->pending_bh |= BH_RECEIVE;\r\ninfo->rx_frame_count++;\r\ninfo->rx_put++;\r\nif (info->rx_put >= info->rx_buf_count)\r\ninfo->rx_put = 0;\r\n}\r\nissue_command(info, CHA, CMD_RXFIFO);\r\n}\r\nstatic void rx_ready_async(MGSLPC_INFO *info, int tcd)\r\n{\r\nstruct tty_port *port = &info->port;\r\nunsigned char data, status, flag;\r\nint fifo_count;\r\nint work = 0;\r\nstruct mgsl_icount *icount = &info->icount;\r\nif (tcd) {\r\nfifo_count = (unsigned char)(read_reg(info, CHA+RBCL) & 0x1f);\r\nif (!fifo_count && (read_reg(info,CHA+STAR) & BIT5))\r\nfifo_count = 32;\r\n} else\r\nfifo_count = 32;\r\ntty_buffer_request_room(port, fifo_count);\r\nwhile (fifo_count) {\r\ndata = read_reg(info, CHA + RXFIFO);\r\nstatus = read_reg(info, CHA + RXFIFO);\r\nfifo_count -= 2;\r\nicount->rx++;\r\nflag = TTY_NORMAL;\r\nif (status & (BIT7 + BIT6)) {\r\nif (status & BIT7)\r\nicount->parity++;\r\nelse\r\nicount->frame++;\r\nif (status & info->ignore_status_mask)\r\ncontinue;\r\nstatus &= info->read_status_mask;\r\nif (status & BIT7)\r\nflag = TTY_PARITY;\r\nelse if (status & BIT6)\r\nflag = TTY_FRAME;\r\n}\r\nwork += tty_insert_flip_char(port, data, flag);\r\n}\r\nissue_command(info, CHA, CMD_RXFIFO);\r\nif (debug_level >= DEBUG_LEVEL_ISR) {\r\nprintk("%s(%d):rx_ready_async",\r\n__FILE__,__LINE__);\r\nprintk("%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d\n",\r\n__FILE__,__LINE__,icount->rx,icount->brk,\r\nicount->parity,icount->frame,icount->overrun);\r\n}\r\nif (work)\r\ntty_flip_buffer_push(port);\r\n}\r\nstatic void tx_done(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nif (!info->tx_active)\r\nreturn;\r\ninfo->tx_active = false;\r\ninfo->tx_aborting = false;\r\nif (info->params.mode == MGSL_MODE_ASYNC)\r\nreturn;\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\ndel_timer(&info->tx_timer);\r\nif (info->drop_rts_on_tx_done) {\r\nget_signals(info);\r\nif (info->serial_signals & SerialSignal_RTS) {\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nset_signals(info);\r\n}\r\ninfo->drop_rts_on_tx_done = false;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\n{\r\nif (tty && (tty->stopped || tty->hw_stopped)) {\r\ntx_stop(info);\r\nreturn;\r\n}\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\nstatic void tx_ready(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nunsigned char fifo_count = 32;\r\nint c;\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):tx_ready(%s)\n", __FILE__, __LINE__, info->device_name);\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nif (!info->tx_active)\r\nreturn;\r\n} else {\r\nif (tty && (tty->stopped || tty->hw_stopped)) {\r\ntx_stop(info);\r\nreturn;\r\n}\r\nif (!info->tx_count)\r\ninfo->tx_active = false;\r\n}\r\nif (!info->tx_count)\r\nreturn;\r\nwhile (info->tx_count && fifo_count) {\r\nc = min(2, min_t(int, fifo_count, min(info->tx_count, TXBUFSIZE - info->tx_get)));\r\nif (c == 1) {\r\nwrite_reg(info, CHA + TXFIFO, *(info->tx_buf + info->tx_get));\r\n} else {\r\nwrite_reg16(info, CHA + TXFIFO,\r\n*((unsigned short*)(info->tx_buf + info->tx_get)));\r\n}\r\ninfo->tx_count -= c;\r\ninfo->tx_get = (info->tx_get + c) & (TXBUFSIZE - 1);\r\nfifo_count -= c;\r\n}\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nif (info->tx_count < WAKEUP_CHARS)\r\ninfo->pending_bh |= BH_TRANSMIT;\r\nissue_command(info, CHA, CMD_TXFIFO);\r\n} else {\r\nif (info->tx_count)\r\nissue_command(info, CHA, CMD_TXFIFO);\r\nelse\r\nissue_command(info, CHA, CMD_TXFIFO + CMD_TXEOM);\r\n}\r\n}\r\nstatic void cts_change(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nget_signals(info);\r\nif ((info->cts_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nirq_disable(info, CHB, IRQ_CTS);\r\ninfo->icount.cts++;\r\nif (info->serial_signals & SerialSignal_CTS)\r\ninfo->input_signal_events.cts_up++;\r\nelse\r\ninfo->input_signal_events.cts_down++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\nif (tty && tty_port_cts_enabled(&info->port)) {\r\nif (tty->hw_stopped) {\r\nif (info->serial_signals & SerialSignal_CTS) {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("CTS tx start...");\r\ntty->hw_stopped = 0;\r\ntx_start(info, tty);\r\ninfo->pending_bh |= BH_TRANSMIT;\r\nreturn;\r\n}\r\n} else {\r\nif (!(info->serial_signals & SerialSignal_CTS)) {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("CTS tx stop...");\r\ntty->hw_stopped = 1;\r\ntx_stop(info);\r\n}\r\n}\r\n}\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic void dcd_change(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nget_signals(info);\r\nif ((info->dcd_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nirq_disable(info, CHB, IRQ_DCD);\r\ninfo->icount.dcd++;\r\nif (info->serial_signals & SerialSignal_DCD) {\r\ninfo->input_signal_events.dcd_up++;\r\n}\r\nelse\r\ninfo->input_signal_events.dcd_down++;\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount) {\r\nif (info->serial_signals & SerialSignal_DCD)\r\nnetif_carrier_on(info->netdev);\r\nelse\r\nnetif_carrier_off(info->netdev);\r\n}\r\n#endif\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\nif (info->port.flags & ASYNC_CHECK_CD) {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s CD now %s...", info->device_name,\r\n(info->serial_signals & SerialSignal_DCD) ? "on" : "off");\r\nif (info->serial_signals & SerialSignal_DCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("doing serial hangup...");\r\nif (tty)\r\ntty_hangup(tty);\r\n}\r\n}\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic void dsr_change(MGSLPC_INFO *info)\r\n{\r\nget_signals(info);\r\nif ((info->dsr_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nport_irq_disable(info, PVR_DSR);\r\ninfo->icount.dsr++;\r\nif (info->serial_signals & SerialSignal_DSR)\r\ninfo->input_signal_events.dsr_up++;\r\nelse\r\ninfo->input_signal_events.dsr_down++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic void ri_change(MGSLPC_INFO *info)\r\n{\r\nget_signals(info);\r\nif ((info->ri_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nport_irq_disable(info, PVR_RI);\r\ninfo->icount.rng++;\r\nif (info->serial_signals & SerialSignal_RI)\r\ninfo->input_signal_events.ri_up++;\r\nelse\r\ninfo->input_signal_events.ri_down++;\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic irqreturn_t mgslpc_isr(int dummy, void *dev_id)\r\n{\r\nMGSLPC_INFO *info = dev_id;\r\nstruct tty_struct *tty;\r\nunsigned short isr;\r\nunsigned char gis, pis;\r\nint count=0;\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("mgslpc_isr(%d) entry.\n", info->irq_level);\r\nif (!(info->p_dev->_locked))\r\nreturn IRQ_HANDLED;\r\ntty = tty_port_tty_get(&info->port);\r\nspin_lock(&info->lock);\r\nwhile ((gis = read_reg(info, CHA + GIS))) {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("mgslpc_isr %s gis=%04X\n", info->device_name,gis);\r\nif ((gis & 0x70) || count > 1000) {\r\nprintk("synclink_cs:hardware failed or ejected\n");\r\nbreak;\r\n}\r\ncount++;\r\nif (gis & (BIT1 | BIT0)) {\r\nisr = read_reg16(info, CHB + ISR);\r\nif (isr & IRQ_DCD)\r\ndcd_change(info, tty);\r\nif (isr & IRQ_CTS)\r\ncts_change(info, tty);\r\n}\r\nif (gis & (BIT3 | BIT2))\r\n{\r\nisr = read_reg16(info, CHA + ISR);\r\nif (isr & IRQ_TIMER) {\r\ninfo->irq_occurred = true;\r\nirq_disable(info, CHA, IRQ_TIMER);\r\n}\r\nif (isr & IRQ_EXITHUNT) {\r\ninfo->icount.exithunt++;\r\nwake_up_interruptible(&info->event_wait_q);\r\n}\r\nif (isr & IRQ_BREAK_ON) {\r\ninfo->icount.brk++;\r\nif (info->port.flags & ASYNC_SAK)\r\ndo_SAK(tty);\r\n}\r\nif (isr & IRQ_RXTIME) {\r\nissue_command(info, CHA, CMD_RXFIFO_READ);\r\n}\r\nif (isr & (IRQ_RXEOM | IRQ_RXFIFO)) {\r\nif (info->params.mode == MGSL_MODE_HDLC)\r\nrx_ready_hdlc(info, isr & IRQ_RXEOM);\r\nelse\r\nrx_ready_async(info, isr & IRQ_RXEOM);\r\n}\r\nif (isr & IRQ_UNDERRUN) {\r\nif (info->tx_aborting)\r\ninfo->icount.txabort++;\r\nelse\r\ninfo->icount.txunder++;\r\ntx_done(info, tty);\r\n}\r\nelse if (isr & IRQ_ALLSENT) {\r\ninfo->icount.txok++;\r\ntx_done(info, tty);\r\n}\r\nelse if (isr & IRQ_TXFIFO)\r\ntx_ready(info, tty);\r\n}\r\nif (gis & BIT7) {\r\npis = read_reg(info, CHA + PIS);\r\nif (pis & BIT1)\r\ndsr_change(info);\r\nif (pis & BIT2)\r\nri_change(info);\r\n}\r\n}\r\nif (info->pending_bh && !info->bh_running && !info->bh_requested) {\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):%s queueing bh task.\n",\r\n__FILE__,__LINE__,info->device_name);\r\nschedule_work(&info->task);\r\ninfo->bh_requested = true;\r\n}\r\nspin_unlock(&info->lock);\r\ntty_kref_put(tty);\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):mgslpc_isr(%d)exit.\n",\r\n__FILE__, __LINE__, info->irq_level);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(MGSLPC_INFO * info, struct tty_struct *tty)\r\n{\r\nint retval = 0;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):startup(%s)\n", __FILE__, __LINE__, info->device_name);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\nreturn 0;\r\nif (!info->tx_buf) {\r\ninfo->tx_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);\r\nif (!info->tx_buf) {\r\nprintk(KERN_ERR"%s(%d):%s can't allocate transmit buffer\n",\r\n__FILE__, __LINE__, info->device_name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninfo->pending_bh = 0;\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\nsetup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);\r\nretval = claim_resources(info);\r\nif (!retval)\r\nretval = adapter_test(info);\r\nif (retval) {\r\nif (capable(CAP_SYS_ADMIN) && tty)\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nrelease_resources(info);\r\nreturn retval;\r\n}\r\nmgslpc_change_params(info, tty);\r\nif (tty)\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->port.flags |= ASYNC_INITIALIZED;\r\nreturn 0;\r\n}\r\nstatic void shutdown(MGSLPC_INFO * info, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_shutdown(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ndel_timer_sync(&info->tx_timer);\r\nif (info->tx_buf) {\r\nfree_page((unsigned long) info->tx_buf);\r\ninfo->tx_buf = NULL;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nrx_stop(info);\r\ntx_stop(info);\r\nreset_device(info);\r\nif (!tty || tty->termios.c_cflag & HUPCL) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nrelease_resources(info);\r\nif (tty)\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->port.flags &= ~ASYNC_INITIALIZED;\r\n}\r\nstatic void mgslpc_program_hw(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nrx_stop(info);\r\ntx_stop(info);\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\nif (info->params.mode == MGSL_MODE_HDLC || info->netcount)\r\nhdlc_mode(info);\r\nelse\r\nasync_mode(info);\r\nset_signals(info);\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\nirq_enable(info, CHB, IRQ_DCD | IRQ_CTS);\r\nport_irq_enable(info, (unsigned char) PVR_DSR | PVR_RI);\r\nget_signals(info);\r\nif (info->netcount || (tty && (tty->termios.c_cflag & CREAD)))\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic void mgslpc_change_params(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nunsigned cflag;\r\nint bits_per_char;\r\nif (!tty)\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_change_params(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\ncflag = tty->termios.c_cflag;\r\nif (cflag & CBAUD)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nswitch (cflag & CSIZE) {\r\ncase CS5: info->params.data_bits = 5; break;\r\ncase CS6: info->params.data_bits = 6; break;\r\ncase CS7: info->params.data_bits = 7; break;\r\ncase CS8: info->params.data_bits = 8; break;\r\ndefault: info->params.data_bits = 7; break;\r\n}\r\nif (cflag & CSTOPB)\r\ninfo->params.stop_bits = 2;\r\nelse\r\ninfo->params.stop_bits = 1;\r\ninfo->params.parity = ASYNC_PARITY_NONE;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\ninfo->params.parity = ASYNC_PARITY_ODD;\r\nelse\r\ninfo->params.parity = ASYNC_PARITY_EVEN;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ninfo->params.parity = ASYNC_PARITY_SPACE;\r\n#endif\r\n}\r\nbits_per_char = info->params.data_bits +\r\ninfo->params.stop_bits + 1;\r\nif (info->params.data_rate <= 460800) {\r\ninfo->params.data_rate = tty_get_baud_rate(tty);\r\n}\r\nif (info->params.data_rate) {\r\ninfo->timeout = (32*HZ*bits_per_char) /\r\ninfo->params.data_rate;\r\n}\r\ninfo->timeout += HZ/50;\r\nif (cflag & CRTSCTS)\r\ninfo->port.flags |= ASYNC_CTS_FLOW;\r\nelse\r\ninfo->port.flags &= ~ASYNC_CTS_FLOW;\r\nif (cflag & CLOCAL)\r\ninfo->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\ninfo->port.flags |= ASYNC_CHECK_CD;\r\ninfo->read_status_mask = 0;\r\nif (I_INPCK(tty))\r\ninfo->read_status_mask |= BIT7 | BIT6;\r\nif (I_IGNPAR(tty))\r\ninfo->ignore_status_mask |= BIT7 | BIT6;\r\nmgslpc_program_hw(info, tty);\r\n}\r\nstatic int mgslpc_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO) {\r\nprintk("%s(%d):mgslpc_put_char(%d) on %s\n",\r\n__FILE__, __LINE__, ch, info->device_name);\r\n}\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_put_char"))\r\nreturn 0;\r\nif (!info->tx_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->params.mode == MGSL_MODE_ASYNC || !info->tx_active) {\r\nif (info->tx_count < TXBUFSIZE - 1) {\r\ninfo->tx_buf[info->tx_put++] = ch;\r\ninfo->tx_put &= TXBUFSIZE-1;\r\ninfo->tx_count++;\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 1;\r\n}\r\nstatic void mgslpc_flush_chars(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_flush_chars() entry on %s tx_count=%d\n",\r\n__FILE__, __LINE__, info->device_name, info->tx_count);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_flush_chars"))\r\nreturn;\r\nif (info->tx_count <= 0 || tty->stopped ||\r\ntty->hw_stopped || !info->tx_buf)\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_flush_chars() entry on %s starting transmitter\n",\r\n__FILE__, __LINE__, info->device_name);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_active)\r\ntx_start(info, tty);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic int mgslpc_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_write(%s) count=%d\n",\r\n__FILE__, __LINE__, info->device_name, count);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_write") ||\r\n!info->tx_buf)\r\ngoto cleanup;\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nif (count > TXBUFSIZE) {\r\nret = -EIO;\r\ngoto cleanup;\r\n}\r\nif (info->tx_active)\r\ngoto cleanup;\r\nelse if (info->tx_count)\r\ngoto start;\r\n}\r\nfor (;;) {\r\nc = min(count,\r\nmin(TXBUFSIZE - info->tx_count - 1,\r\nTXBUFSIZE - info->tx_put));\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->tx_buf + info->tx_put, buf, c);\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->tx_put = (info->tx_put + c) & (TXBUFSIZE-1);\r\ninfo->tx_count += c;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nstart:\r\nif (info->tx_count && !tty->stopped && !tty->hw_stopped) {\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_active)\r\ntx_start(info, tty);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\ncleanup:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_write(%s) returning=%d\n",\r\n__FILE__, __LINE__, info->device_name, ret);\r\nreturn ret;\r\n}\r\nstatic int mgslpc_write_room(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nint ret;\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_write_room"))\r\nreturn 0;\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nif (info->tx_active)\r\nreturn 0;\r\nelse\r\nreturn HDLC_MAX_FRAME_SIZE;\r\n} else {\r\nret = TXBUFSIZE - info->tx_count - 1;\r\nif (ret < 0)\r\nret = 0;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_write_room(%s)=%d\n",\r\n__FILE__, __LINE__, info->device_name, ret);\r\nreturn ret;\r\n}\r\nstatic int mgslpc_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nint rc;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_chars_in_buffer(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_chars_in_buffer"))\r\nreturn 0;\r\nif (info->params.mode == MGSL_MODE_HDLC)\r\nrc = info->tx_active ? info->max_frame_size : 0;\r\nelse\r\nrc = info->tx_count;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_chars_in_buffer(%s)=%d\n",\r\n__FILE__, __LINE__, info->device_name, rc);\r\nreturn rc;\r\n}\r\nstatic void mgslpc_flush_buffer(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_flush_buffer(%s) entry\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_flush_buffer"))\r\nreturn;\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\ndel_timer(&info->tx_timer);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nwake_up_interruptible(&tty->write_wait);\r\ntty_wakeup(tty);\r\n}\r\nstatic void mgslpc_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_send_xchar(%s,%d)\n",\r\n__FILE__, __LINE__, info->device_name, ch);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_send_xchar"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_enabled)\r\ntx_start(info, tty);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\n}\r\nstatic void mgslpc_throttle(struct tty_struct * tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_throttle(%s) entry\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nmgslpc_send_xchar(tty, STOP_CHAR(tty));\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\n}\r\nstatic void mgslpc_unthrottle(struct tty_struct * tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_unthrottle(%s) entry\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nmgslpc_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\n}\r\nstatic int get_stats(MGSLPC_INFO * info, struct mgsl_icount __user *user_icount)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("get_params(%s)\n", info->device_name);\r\nif (!user_icount) {\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\n} else {\r\nCOPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));\r\nif (err)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_params(MGSLPC_INFO * info, MGSL_PARAMS __user *user_params)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("get_params(%s)\n", info->device_name);\r\nCOPY_TO_USER(err,user_params, &info->params, sizeof(MGSL_PARAMS));\r\nif (err)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_params(MGSLPC_INFO * info, MGSL_PARAMS __user *new_params, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nMGSL_PARAMS tmp_params;\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):set_params %s\n", __FILE__,__LINE__,\r\ninfo->device_name);\r\nCOPY_FROM_USER(err,&tmp_params, new_params, sizeof(MGSL_PARAMS));\r\nif (err) {\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):set_params(%s) user buffer copy failed\n",\r\n__FILE__, __LINE__, info->device_name);\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nmemcpy(&info->params,&tmp_params,sizeof(MGSL_PARAMS));\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nmgslpc_change_params(info, tty);\r\nreturn 0;\r\n}\r\nstatic int get_txidle(MGSLPC_INFO * info, int __user *idle_mode)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("get_txidle(%s)=%d\n", info->device_name, info->idle_mode);\r\nCOPY_TO_USER(err,idle_mode, &info->idle_mode, sizeof(int));\r\nif (err)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_txidle(MGSLPC_INFO * info, int idle_mode)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("set_txidle(%s,%d)\n", info->device_name, idle_mode);\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->idle_mode = idle_mode;\r\ntx_set_idle(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int get_interface(MGSLPC_INFO * info, int __user *if_mode)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("get_interface(%s)=%d\n", info->device_name, info->if_mode);\r\nCOPY_TO_USER(err,if_mode, &info->if_mode, sizeof(int));\r\nif (err)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_interface(MGSLPC_INFO * info, int if_mode)\r\n{\r\nunsigned long flags;\r\nunsigned char val;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("set_interface(%s,%d)\n", info->device_name, if_mode);\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->if_mode = if_mode;\r\nval = read_reg(info, PVR) & 0x0f;\r\nswitch (info->if_mode)\r\n{\r\ncase MGSL_INTERFACE_RS232: val |= PVR_RS232; break;\r\ncase MGSL_INTERFACE_V35: val |= PVR_V35; break;\r\ncase MGSL_INTERFACE_RS422: val |= PVR_RS422; break;\r\n}\r\nwrite_reg(info, PVR, val);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int set_txenable(MGSLPC_INFO * info, int enable, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("set_txenable(%s,%d)\n", info->device_name, enable);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (enable) {\r\nif (!info->tx_enabled)\r\ntx_start(info, tty);\r\n} else {\r\nif (info->tx_enabled)\r\ntx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int tx_abort(MGSLPC_INFO * info)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("tx_abort(%s)\n", info->device_name);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->tx_active && info->tx_count &&\r\ninfo->params.mode == MGSL_MODE_HDLC) {\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\ninfo->tx_aborting = true;\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int set_rxenable(MGSLPC_INFO * info, int enable)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("set_rxenable(%s,%d)\n", info->device_name, enable);\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (enable) {\r\nif (!info->rx_enabled)\r\nrx_start(info);\r\n} else {\r\nif (info->rx_enabled)\r\nrx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wait_events(MGSLPC_INFO * info, int __user *mask_ptr)\r\n{\r\nunsigned long flags;\r\nint s;\r\nint rc=0;\r\nstruct mgsl_icount cprev, cnow;\r\nint events;\r\nint mask;\r\nstruct _input_signal_events oldsigs, newsigs;\r\nDECLARE_WAITQUEUE(wait, current);\r\nCOPY_FROM_USER(rc,&mask, mask_ptr, sizeof(int));\r\nif (rc)\r\nreturn -EFAULT;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("wait_events(%s,%d)\n", info->device_name, mask);\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\ns = info->serial_signals;\r\nevents = mask &\r\n( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +\r\n((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +\r\n((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +\r\n((s & SerialSignal_RI) ? MgslEvent_RiActive :MgslEvent_RiInactive) );\r\nif (events) {\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ngoto exit;\r\n}\r\ncprev = info->icount;\r\noldsigs = info->input_signal_events;\r\nif ((info->params.mode == MGSL_MODE_HDLC) &&\r\n(mask & MgslEvent_ExitHuntMode))\r\nirq_enable(info, CHA, IRQ_EXITHUNT);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&info->event_wait_q, &wait);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\ncnow = info->icount;\r\nnewsigs = info->input_signal_events;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (newsigs.dsr_up == oldsigs.dsr_up &&\r\nnewsigs.dsr_down == oldsigs.dsr_down &&\r\nnewsigs.dcd_up == oldsigs.dcd_up &&\r\nnewsigs.dcd_down == oldsigs.dcd_down &&\r\nnewsigs.cts_up == oldsigs.cts_up &&\r\nnewsigs.cts_down == oldsigs.cts_down &&\r\nnewsigs.ri_up == oldsigs.ri_up &&\r\nnewsigs.ri_down == oldsigs.ri_down &&\r\ncnow.exithunt == cprev.exithunt &&\r\ncnow.rxidle == cprev.rxidle) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nevents = mask &\r\n( (newsigs.dsr_up != oldsigs.dsr_up ? MgslEvent_DsrActive:0) +\r\n(newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +\r\n(newsigs.dcd_up != oldsigs.dcd_up ? MgslEvent_DcdActive:0) +\r\n(newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +\r\n(newsigs.cts_up != oldsigs.cts_up ? MgslEvent_CtsActive:0) +\r\n(newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +\r\n(newsigs.ri_up != oldsigs.ri_up ? MgslEvent_RiActive:0) +\r\n(newsigs.ri_down != oldsigs.ri_down ? MgslEvent_RiInactive:0) +\r\n(cnow.exithunt != cprev.exithunt ? MgslEvent_ExitHuntMode:0) +\r\n(cnow.rxidle != cprev.rxidle ? MgslEvent_IdleReceived:0) );\r\nif (events)\r\nbreak;\r\ncprev = cnow;\r\noldsigs = newsigs;\r\n}\r\nremove_wait_queue(&info->event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (mask & MgslEvent_ExitHuntMode) {\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!waitqueue_active(&info->event_wait_q))\r\nirq_disable(info, CHA, IRQ_EXITHUNT);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nexit:\r\nif (rc == 0)\r\nPUT_USER(rc, events, mask_ptr);\r\nreturn rc;\r\n}\r\nstatic int modem_input_wait(MGSLPC_INFO *info,int arg)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nstruct mgsl_icount cprev, cnow;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irqsave(&info->lock, flags);\r\ncprev = info->icount;\r\nadd_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\ncnow = info->icount;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||\r\n(arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||\r\n(arg & TIOCM_CD && cnow.dcd != cprev.dcd) ||\r\n(arg & TIOCM_CTS && cnow.cts != cprev.cts)) {\r\nrc = 0;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\nremove_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn rc;\r\n}\r\nstatic int tiocmget(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nresult = ((info->serial_signals & SerialSignal_RTS) ? TIOCM_RTS:0) +\r\n((info->serial_signals & SerialSignal_DTR) ? TIOCM_DTR:0) +\r\n((info->serial_signals & SerialSignal_DCD) ? TIOCM_CAR:0) +\r\n((info->serial_signals & SerialSignal_RI) ? TIOCM_RNG:0) +\r\n((info->serial_signals & SerialSignal_DSR) ? TIOCM_DSR:0) +\r\n((info->serial_signals & SerialSignal_CTS) ? TIOCM_CTS:0);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmget() value=%08X\n",\r\n__FILE__, __LINE__, info->device_name, result);\r\nreturn result;\r\n}\r\nstatic int tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmset(%x,%x)\n",\r\n__FILE__, __LINE__, info->device_name, set, clear);\r\nif (set & TIOCM_RTS)\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->serial_signals &= ~SerialSignal_DTR;\r\nspin_lock_irqsave(&info->lock, flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mgslpc_break(struct tty_struct *tty, int break_state)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_break(%s,%d)\n",\r\n__FILE__, __LINE__, info->device_name, break_state);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_break"))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (break_state == -1)\r\nset_reg_bits(info, CHA+DAFO, BIT6);\r\nelse\r\nclear_reg_bits(info, CHA+DAFO, BIT6);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mgslpc_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nstruct mgsl_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int mgslpc_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_ioctl %s cmd=%08X\n", __FILE__, __LINE__,\r\ninfo->device_name, cmd);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase MGSL_IOCGPARAMS:\r\nreturn get_params(info, argp);\r\ncase MGSL_IOCSPARAMS:\r\nreturn set_params(info, argp, tty);\r\ncase MGSL_IOCGTXIDLE:\r\nreturn get_txidle(info, argp);\r\ncase MGSL_IOCSTXIDLE:\r\nreturn set_txidle(info, (int)arg);\r\ncase MGSL_IOCGIF:\r\nreturn get_interface(info, argp);\r\ncase MGSL_IOCSIF:\r\nreturn set_interface(info,(int)arg);\r\ncase MGSL_IOCTXENABLE:\r\nreturn set_txenable(info,(int)arg, tty);\r\ncase MGSL_IOCRXENABLE:\r\nreturn set_rxenable(info,(int)arg);\r\ncase MGSL_IOCTXABORT:\r\nreturn tx_abort(info);\r\ncase MGSL_IOCGSTATS:\r\nreturn get_stats(info, argp);\r\ncase MGSL_IOCWAITEVENT:\r\nreturn wait_events(info, argp);\r\ncase TIOCMIWAIT:\r\nreturn modem_input_wait(info,(int)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgslpc_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_set_termios %s\n", __FILE__, __LINE__,\r\ntty->driver->name);\r\nif ((tty->termios.c_cflag == old_termios->c_cflag)\r\n&& (RELEVANT_IFLAG(tty->termios.c_iflag)\r\n== RELEVANT_IFLAG(old_termios->c_iflag)))\r\nreturn;\r\nmgslpc_change_params(info, tty);\r\nif (old_termios->c_cflag & CBAUD &&\r\n!(tty->termios.c_cflag & CBAUD)) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nspin_lock_irqsave(&info->lock, flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\ntty->termios.c_cflag & CBAUD) {\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (!(tty->termios.c_cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags)) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nif (old_termios->c_cflag & CRTSCTS &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\ntx_release(tty);\r\n}\r\n}\r\nstatic void mgslpc_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nstruct tty_port *port = &info->port;\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_close"))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_close(%s) entry, count=%d\n",\r\n__FILE__, __LINE__, info->device_name, port->count);\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\ngoto cleanup;\r\nif (port->flags & ASYNC_INITIALIZED)\r\nmgslpc_wait_until_sent(tty, info->timeout);\r\nmgslpc_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nshutdown(info, tty);\r\ntty_port_close_end(port, tty);\r\ntty_port_tty_set(port, NULL);\r\ncleanup:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_close(%s) exit, count=%d\n", __FILE__, __LINE__,\r\ntty->driver->name, port->count);\r\n}\r\nstatic void mgslpc_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nif (!info)\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_wait_until_sent(%s) entry\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_wait_until_sent"))\r\nreturn;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\ngoto exit;\r\norig_jiffies = jiffies;\r\nif (info->params.data_rate) {\r\nchar_time = info->timeout/(32 * 5);\r\nif (!char_time)\r\nchar_time++;\r\n} else\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nwhile (info->tx_active) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n} else {\r\nwhile ((info->tx_count || info->tx_active) &&\r\ninfo->tx_enabled) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n}\r\nexit:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_wait_until_sent(%s) exit\n",\r\n__FILE__, __LINE__, info->device_name);\r\n}\r\nstatic void mgslpc_hangup(struct tty_struct *tty)\r\n{\r\nMGSLPC_INFO * info = (MGSLPC_INFO *)tty->driver_data;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_hangup(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_hangup"))\r\nreturn;\r\nmgslpc_flush_buffer(tty);\r\nshutdown(info, tty);\r\ntty_port_hangup(&info->port);\r\n}\r\nstatic int carrier_raised(struct tty_port *port)\r\n{\r\nMGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (info->serial_signals & SerialSignal_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dtr_rts(struct tty_port *port, int onoff)\r\n{\r\nMGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (onoff)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic int mgslpc_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nMGSLPC_INFO *info;\r\nstruct tty_port *port;\r\nint retval, line;\r\nunsigned long flags;\r\nline = tty->index;\r\nif (line >= mgslpc_device_count) {\r\nprintk("%s(%d):mgslpc_open with invalid line #%d.\n",\r\n__FILE__, __LINE__, line);\r\nreturn -ENODEV;\r\n}\r\ninfo = mgslpc_device_list;\r\nwhile(info && info->line != line)\r\ninfo = info->next_device;\r\nif (mgslpc_paranoia_check(info, tty->name, "mgslpc_open"))\r\nreturn -ENODEV;\r\nport = &info->port;\r\ntty->driver_data = info;\r\ntty_port_tty_set(port, tty);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_open(%s), old ref count = %d\n",\r\n__FILE__, __LINE__, tty->driver->name, port->count);\r\nif (port->flags & ASYNC_CLOSING){\r\nwait_event_interruptible_tty(tty, port->close_wait,\r\n!(port->flags & ASYNC_CLOSING));\r\nretval = ((port->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\ngoto cleanup;\r\n}\r\nport->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->netcount) {\r\nretval = -EBUSY;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\ngoto cleanup;\r\n}\r\nspin_lock(&port->lock);\r\nport->count++;\r\nspin_unlock(&port->lock);\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif (port->count == 1) {\r\nretval = startup(info, tty);\r\nif (retval < 0)\r\ngoto cleanup;\r\n}\r\nretval = tty_port_block_til_ready(&info->port, tty, filp);\r\nif (retval) {\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready(%s) returned %d\n",\r\n__FILE__, __LINE__, info->device_name, retval);\r\ngoto cleanup;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgslpc_open(%s) success\n",\r\n__FILE__, __LINE__, info->device_name);\r\nretval = 0;\r\ncleanup:\r\nreturn retval;\r\n}\r\nstatic inline void line_info(struct seq_file *m, MGSLPC_INFO *info)\r\n{\r\nchar stat_buf[30];\r\nunsigned long flags;\r\nseq_printf(m, "%s:io:%04X irq:%d",\r\ninfo->device_name, info->io_base, info->irq_level);\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif (info->serial_signals & SerialSignal_RTS)\r\nstrcat(stat_buf, "|RTS");\r\nif (info->serial_signals & SerialSignal_CTS)\r\nstrcat(stat_buf, "|CTS");\r\nif (info->serial_signals & SerialSignal_DTR)\r\nstrcat(stat_buf, "|DTR");\r\nif (info->serial_signals & SerialSignal_DSR)\r\nstrcat(stat_buf, "|DSR");\r\nif (info->serial_signals & SerialSignal_DCD)\r\nstrcat(stat_buf, "|CD");\r\nif (info->serial_signals & SerialSignal_RI)\r\nstrcat(stat_buf, "|RI");\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nseq_printf(m, " HDLC txok:%d rxok:%d",\r\ninfo->icount.txok, info->icount.rxok);\r\nif (info->icount.txunder)\r\nseq_printf(m, " txunder:%d", info->icount.txunder);\r\nif (info->icount.txabort)\r\nseq_printf(m, " txabort:%d", info->icount.txabort);\r\nif (info->icount.rxshort)\r\nseq_printf(m, " rxshort:%d", info->icount.rxshort);\r\nif (info->icount.rxlong)\r\nseq_printf(m, " rxlong:%d", info->icount.rxlong);\r\nif (info->icount.rxover)\r\nseq_printf(m, " rxover:%d", info->icount.rxover);\r\nif (info->icount.rxcrc)\r\nseq_printf(m, " rxcrc:%d", info->icount.rxcrc);\r\n} else {\r\nseq_printf(m, " ASYNC tx:%d rx:%d",\r\ninfo->icount.tx, info->icount.rx);\r\nif (info->icount.frame)\r\nseq_printf(m, " fe:%d", info->icount.frame);\r\nif (info->icount.parity)\r\nseq_printf(m, " pe:%d", info->icount.parity);\r\nif (info->icount.brk)\r\nseq_printf(m, " brk:%d", info->icount.brk);\r\nif (info->icount.overrun)\r\nseq_printf(m, " oe:%d", info->icount.overrun);\r\n}\r\nseq_printf(m, " %s\n", stat_buf+1);\r\nseq_printf(m, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",\r\ninfo->tx_active,info->bh_requested,info->bh_running,\r\ninfo->pending_bh);\r\n}\r\nstatic int mgslpc_proc_show(struct seq_file *m, void *v)\r\n{\r\nMGSLPC_INFO *info;\r\nseq_printf(m, "synclink driver:%s\n", driver_version);\r\ninfo = mgslpc_device_list;\r\nwhile (info) {\r\nline_info(m, info);\r\ninfo = info->next_device;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgslpc_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mgslpc_proc_show, NULL);\r\n}\r\nstatic int rx_alloc_buffers(MGSLPC_INFO *info)\r\n{\r\ninfo->rx_buf_size = sizeof(RXBUF) + info->max_frame_size;\r\ninfo->rx_buf_total_size = info->rx_buf_size * 8;\r\nif (info->rx_buf_total_size > 0x10000)\r\ninfo->rx_buf_total_size = 0x10000;\r\ninfo->rx_buf_count = info->rx_buf_total_size / info->rx_buf_size;\r\ninfo->rx_buf = kmalloc(info->rx_buf_total_size, GFP_KERNEL);\r\nif (info->rx_buf == NULL)\r\nreturn -ENOMEM;\r\ninfo->flag_buf = kzalloc(info->max_frame_size, GFP_KERNEL);\r\nif (!info->flag_buf) {\r\nkfree(info->rx_buf);\r\ninfo->rx_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nrx_reset_buffers(info);\r\nreturn 0;\r\n}\r\nstatic void rx_free_buffers(MGSLPC_INFO *info)\r\n{\r\nkfree(info->rx_buf);\r\ninfo->rx_buf = NULL;\r\nkfree(info->flag_buf);\r\ninfo->flag_buf = NULL;\r\n}\r\nstatic int claim_resources(MGSLPC_INFO *info)\r\n{\r\nif (rx_alloc_buffers(info) < 0) {\r\nprintk("Can't allocate rx buffer %s\n", info->device_name);\r\nrelease_resources(info);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_resources(MGSLPC_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("release_resources(%s)\n", info->device_name);\r\nrx_free_buffers(info);\r\n}\r\nstatic int mgslpc_add_device(MGSLPC_INFO *info)\r\n{\r\nMGSLPC_INFO *current_dev = NULL;\r\nstruct device *tty_dev;\r\nint ret;\r\ninfo->next_device = NULL;\r\ninfo->line = mgslpc_device_count;\r\nsprintf(info->device_name,"ttySLP%d",info->line);\r\nif (info->line < MAX_DEVICE_COUNT) {\r\nif (maxframe[info->line])\r\ninfo->max_frame_size = maxframe[info->line];\r\n}\r\nmgslpc_device_count++;\r\nif (!mgslpc_device_list)\r\nmgslpc_device_list = info;\r\nelse {\r\ncurrent_dev = mgslpc_device_list;\r\nwhile (current_dev->next_device)\r\ncurrent_dev = current_dev->next_device;\r\ncurrent_dev->next_device = info;\r\n}\r\nif (info->max_frame_size < 4096)\r\ninfo->max_frame_size = 4096;\r\nelse if (info->max_frame_size > 65535)\r\ninfo->max_frame_size = 65535;\r\nprintk("SyncLink PC Card %s:IO=%04X IRQ=%d\n",\r\ninfo->device_name, info->io_base, info->irq_level);\r\n#if SYNCLINK_GENERIC_HDLC\r\nret = hdlcdev_init(info);\r\nif (ret != 0)\r\ngoto failed;\r\n#endif\r\ntty_dev = tty_port_register_device(&info->port, serial_driver, info->line,\r\n&info->p_dev->dev);\r\nif (IS_ERR(tty_dev)) {\r\nret = PTR_ERR(tty_dev);\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_exit(info);\r\n#endif\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nif (current_dev)\r\ncurrent_dev->next_device = NULL;\r\nelse\r\nmgslpc_device_list = NULL;\r\nmgslpc_device_count--;\r\nreturn ret;\r\n}\r\nstatic void mgslpc_remove_device(MGSLPC_INFO *remove_info)\r\n{\r\nMGSLPC_INFO *info = mgslpc_device_list;\r\nMGSLPC_INFO *last = NULL;\r\nwhile(info) {\r\nif (info == remove_info) {\r\nif (last)\r\nlast->next_device = info->next_device;\r\nelse\r\nmgslpc_device_list = info->next_device;\r\ntty_unregister_device(serial_driver, info->line);\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_exit(info);\r\n#endif\r\nrelease_resources(info);\r\ntty_port_destroy(&info->port);\r\nkfree(info);\r\nmgslpc_device_count--;\r\nreturn;\r\n}\r\nlast = info;\r\ninfo = info->next_device;\r\n}\r\n}\r\nstatic int __init synclink_cs_init(void)\r\n{\r\nint rc;\r\nif (break_on_load) {\r\nmgslpc_get_text_ptr();\r\nBREAKPOINT();\r\n}\r\nserial_driver = tty_alloc_driver(MAX_DEVICE_COUNT,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV);\r\nif (IS_ERR(serial_driver)) {\r\nrc = PTR_ERR(serial_driver);\r\ngoto err;\r\n}\r\nserial_driver->driver_name = "synclink_cs";\r\nserial_driver->name = "ttySLP";\r\nserial_driver->major = ttymajor;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\ntty_set_operations(serial_driver, &mgslpc_ops);\r\nrc = tty_register_driver(serial_driver);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%s(%d):Couldn't register serial driver\n",\r\n__FILE__, __LINE__);\r\ngoto err_put_tty;\r\n}\r\nrc = pcmcia_register_driver(&mgslpc_driver);\r\nif (rc < 0)\r\ngoto err_unreg_tty;\r\nprintk(KERN_INFO "%s %s, tty major#%d\n", driver_name, driver_version,\r\nserial_driver->major);\r\nreturn 0;\r\nerr_unreg_tty:\r\ntty_unregister_driver(serial_driver);\r\nerr_put_tty:\r\nput_tty_driver(serial_driver);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void __exit synclink_cs_exit(void)\r\n{\r\npcmcia_unregister_driver(&mgslpc_driver);\r\ntty_unregister_driver(serial_driver);\r\nput_tty_driver(serial_driver);\r\n}\r\nstatic void mgslpc_set_rate(MGSLPC_INFO *info, unsigned char channel, unsigned int rate)\r\n{\r\nunsigned int M, N;\r\nunsigned char val;\r\nif (rate) {\r\nN = 3686400 / rate;\r\nif (!N)\r\nN = 1;\r\nN >>= 1;\r\nfor (M = 1; N > 64 && M < 16; M++)\r\nN >>= 1;\r\nN--;\r\nwrite_reg(info, (unsigned char) (channel + BGR),\r\n(unsigned char) ((M << 6) + N));\r\nval = read_reg(info, (unsigned char) (channel + CCR2)) & 0x3f;\r\nval |= ((M << 4) & 0xc0);\r\nwrite_reg(info, (unsigned char) (channel + CCR2), val);\r\n}\r\n}\r\nstatic void enable_auxclk(MGSLPC_INFO *info)\r\n{\r\nunsigned char val;\r\nval = 0x82;\r\nif (info->params.mode == MGSL_MODE_HDLC && info->params.clock_speed)\r\nval |= BIT2;\r\nwrite_reg(info, CHB + MODE, val);\r\nwrite_reg(info, CHB + CCR0, 0xc0);\r\nwrite_reg(info, CHB + CCR1, 0x17);\r\nif (info->params.mode == MGSL_MODE_HDLC && info->params.clock_speed)\r\nwrite_reg(info, CHB + CCR2, 0x38);\r\nelse\r\nwrite_reg(info, CHB + CCR2, 0x30);\r\nwrite_reg(info, CHB + CCR4, 0x50);\r\nif (info->params.mode == MGSL_MODE_HDLC && info->params.clock_speed)\r\nmgslpc_set_rate(info, CHB, info->params.clock_speed);\r\nelse\r\nmgslpc_set_rate(info, CHB, 921600);\r\n}\r\nstatic void loopback_enable(MGSLPC_INFO *info)\r\n{\r\nunsigned char val;\r\nval = read_reg(info, CHA + CCR1) | (BIT2 | BIT1 | BIT0);\r\nwrite_reg(info, CHA + CCR1, val);\r\nval = read_reg(info, CHA + CCR2) | (BIT4 | BIT5);\r\nwrite_reg(info, CHA + CCR2, val);\r\nif (info->params.clock_speed)\r\nmgslpc_set_rate(info, CHA, info->params.clock_speed);\r\nelse\r\nmgslpc_set_rate(info, CHA, 1843200);\r\nval = read_reg(info, CHA + MODE) | BIT0;\r\nwrite_reg(info, CHA + MODE, val);\r\n}\r\nstatic void hdlc_mode(MGSLPC_INFO *info)\r\n{\r\nunsigned char val;\r\nunsigned char clkmode, clksubmode;\r\nirq_disable(info, CHA, 0xffff);\r\nirq_disable(info, CHB, 0xffff);\r\nport_irq_disable(info, 0xff);\r\nclkmode = clksubmode = 0;\r\nif (info->params.flags & HDLC_FLAG_RXC_DPLL\r\n&& info->params.flags & HDLC_FLAG_TXC_DPLL) {\r\nclkmode = 7;\r\n} else if (info->params.flags & HDLC_FLAG_RXC_BRG\r\n&& info->params.flags & HDLC_FLAG_TXC_BRG) {\r\nclkmode = 7;\r\nclksubmode = 1;\r\n} else if (info->params.flags & HDLC_FLAG_RXC_DPLL) {\r\nif (info->params.flags & HDLC_FLAG_TXC_BRG) {\r\nclkmode = 6;\r\nclksubmode = 1;\r\n} else {\r\nclkmode = 6;\r\n}\r\n} else if (info->params.flags & HDLC_FLAG_TXC_BRG) {\r\nclksubmode = 1;\r\n}\r\nval = 0x82;\r\nif (info->params.loopback)\r\nval |= BIT0;\r\nif (info->serial_signals & SerialSignal_RTS)\r\nval |= BIT2;\r\nwrite_reg(info, CHA + MODE, val);\r\nval = 0xc0;\r\nswitch (info->params.encoding)\r\n{\r\ncase HDLC_ENCODING_NRZI:\r\nval |= BIT3;\r\nbreak;\r\ncase HDLC_ENCODING_BIPHASE_SPACE:\r\nval |= BIT4;\r\nbreak;\r\ncase HDLC_ENCODING_BIPHASE_MARK:\r\nval |= BIT4 | BIT2;\r\nbreak;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL:\r\nval |= BIT4 | BIT3;\r\nbreak;\r\n}\r\nwrite_reg(info, CHA + CCR0, val);\r\nval = 0x10 + clkmode;\r\nwrite_reg(info, CHA + CCR1, val);\r\nval = 0x00;\r\nif (clkmode == 2 || clkmode == 3 || clkmode == 6\r\n|| clkmode == 7 || (clkmode == 0 && clksubmode == 1))\r\nval |= BIT5;\r\nif (clksubmode)\r\nval |= BIT4;\r\nif (info->params.crc_type == HDLC_CRC_32_CCITT)\r\nval |= BIT1;\r\nif (info->params.encoding == HDLC_ENCODING_NRZB)\r\nval |= BIT0;\r\nwrite_reg(info, CHA + CCR2, val);\r\nval = 0x00;\r\nif (info->params.crc_type == HDLC_CRC_NONE)\r\nval |= BIT2 | BIT1;\r\nif (info->params.preamble != HDLC_PREAMBLE_PATTERN_NONE)\r\nval |= BIT5;\r\nswitch (info->params.preamble_length)\r\n{\r\ncase HDLC_PREAMBLE_LENGTH_16BITS:\r\nval |= BIT6;\r\nbreak;\r\ncase HDLC_PREAMBLE_LENGTH_32BITS:\r\nval |= BIT6;\r\nbreak;\r\ncase HDLC_PREAMBLE_LENGTH_64BITS:\r\nval |= BIT7 | BIT6;\r\nbreak;\r\n}\r\nwrite_reg(info, CHA + CCR3, val);\r\nval = 0;\r\nswitch (info->params.preamble)\r\n{\r\ncase HDLC_PREAMBLE_PATTERN_FLAGS: val = 0x7e; break;\r\ncase HDLC_PREAMBLE_PATTERN_10: val = 0xaa; break;\r\ncase HDLC_PREAMBLE_PATTERN_01: val = 0x55; break;\r\ncase HDLC_PREAMBLE_PATTERN_ONES: val = 0xff; break;\r\n}\r\nwrite_reg(info, CHA + PRE, val);\r\nval = 0x50;\r\nwrite_reg(info, CHA + CCR4, val);\r\nif (info->params.flags & HDLC_FLAG_RXC_DPLL)\r\nmgslpc_set_rate(info, CHA, info->params.clock_speed * 16);\r\nelse\r\nmgslpc_set_rate(info, CHA, info->params.clock_speed);\r\nwrite_reg(info, CHA + RLCR, 0);\r\nval = 0x00;\r\nif (info->params.flags & HDLC_FLAG_AUTO_DCD)\r\nval |= BIT5;\r\nwrite_reg(info, CHA + XBCH, val);\r\nenable_auxclk(info);\r\nif (info->params.loopback || info->testing_irq)\r\nloopback_enable(info);\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS)\r\n{\r\nirq_enable(info, CHB, IRQ_CTS);\r\nset_reg_bits(info, CHA + PVR, BIT3);\r\n} else\r\nclear_reg_bits(info, CHA + PVR, BIT3);\r\nirq_enable(info, CHA,\r\nIRQ_RXEOM | IRQ_RXFIFO | IRQ_ALLSENT |\r\nIRQ_UNDERRUN | IRQ_TXFIFO);\r\nissue_command(info, CHA, CMD_TXRESET + CMD_RXRESET);\r\nwait_command_complete(info, CHA);\r\nread_reg16(info, CHA + ISR);\r\nif (!info->testing_irq)\r\nclear_reg_bits(info, CHA + CCR0, BIT6);\r\ntx_set_idle(info);\r\ntx_stop(info);\r\nrx_stop(info);\r\n}\r\nstatic void rx_stop(MGSLPC_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):rx_stop(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nclear_reg_bits(info, CHA + MODE, BIT3);\r\ninfo->rx_enabled = false;\r\ninfo->rx_overflow = false;\r\n}\r\nstatic void rx_start(MGSLPC_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):rx_start(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nrx_reset_buffers(info);\r\ninfo->rx_enabled = false;\r\ninfo->rx_overflow = false;\r\nset_reg_bits(info, CHA + MODE, BIT3);\r\ninfo->rx_enabled = true;\r\n}\r\nstatic void tx_start(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):tx_start(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (info->tx_count) {\r\ninfo->drop_rts_on_tx_done = false;\r\nif (info->params.flags & HDLC_FLAG_AUTO_RTS) {\r\nget_signals(info);\r\nif (!(info->serial_signals & SerialSignal_RTS)) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nset_signals(info);\r\ninfo->drop_rts_on_tx_done = true;\r\n}\r\n}\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nif (!info->tx_active) {\r\ninfo->tx_active = true;\r\ntx_ready(info, tty);\r\n}\r\n} else {\r\ninfo->tx_active = true;\r\ntx_ready(info, tty);\r\nmod_timer(&info->tx_timer, jiffies +\r\nmsecs_to_jiffies(5000));\r\n}\r\n}\r\nif (!info->tx_enabled)\r\ninfo->tx_enabled = true;\r\n}\r\nstatic void tx_stop(MGSLPC_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):tx_stop(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\ndel_timer(&info->tx_timer);\r\ninfo->tx_enabled = false;\r\ninfo->tx_active = false;\r\n}\r\nstatic void reset_device(MGSLPC_INFO *info)\r\n{\r\nwrite_reg(info, CHA + CCR0, 0x80);\r\nwrite_reg(info, CHB + CCR0, 0x80);\r\nwrite_reg(info, CHA + MODE, 0);\r\nwrite_reg(info, CHB + MODE, 0);\r\nirq_disable(info, CHA, 0xffff);\r\nirq_disable(info, CHB, 0xffff);\r\nport_irq_disable(info, 0xff);\r\nwrite_reg(info, PCR, 0x06);\r\nwrite_reg(info, IPC, 0x05);\r\n}\r\nstatic void async_mode(MGSLPC_INFO *info)\r\n{\r\nunsigned char val;\r\nirq_disable(info, CHA, 0xffff);\r\nirq_disable(info, CHB, 0xffff);\r\nport_irq_disable(info, 0xff);\r\nval = 0x06;\r\nif (info->params.loopback)\r\nval |= BIT0;\r\nif (!(info->serial_signals & SerialSignal_RTS))\r\nval |= BIT6;\r\nwrite_reg(info, CHA + MODE, val);\r\nwrite_reg(info, CHA + CCR0, 0x83);\r\nwrite_reg(info, CHA + CCR1, 0x1f);\r\nwrite_reg(info, CHA + CCR2, 0x10);\r\nwrite_reg(info, CHA + CCR3, 0);\r\nwrite_reg(info, CHA + CCR4, 0x50);\r\nmgslpc_set_rate(info, CHA, info->params.data_rate * 16);\r\nval = 0x00;\r\nif (info->params.data_bits != 8)\r\nval |= BIT0;\r\nif (info->params.stop_bits != 1)\r\nval |= BIT5;\r\nif (info->params.parity != ASYNC_PARITY_NONE)\r\n{\r\nval |= BIT2;\r\nif (info->params.parity == ASYNC_PARITY_ODD)\r\nval |= BIT3;\r\nelse\r\nval |= BIT4;\r\n}\r\nwrite_reg(info, CHA + DAFO, val);\r\nwrite_reg(info, CHA + RFC, 0x5c);\r\nwrite_reg(info, CHA + RLCR, 0);\r\nval = 0x00;\r\nif (info->params.flags & HDLC_FLAG_AUTO_DCD)\r\nval |= BIT5;\r\nwrite_reg(info, CHA + XBCH, val);\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS)\r\nirq_enable(info, CHA, IRQ_CTS);\r\nset_reg_bits(info, CHA + MODE, BIT3);\r\nenable_auxclk(info);\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS) {\r\nirq_enable(info, CHB, IRQ_CTS);\r\nset_reg_bits(info, CHA + PVR, BIT3);\r\n} else\r\nclear_reg_bits(info, CHA + PVR, BIT3);\r\nirq_enable(info, CHA,\r\nIRQ_RXEOM | IRQ_RXFIFO | IRQ_BREAK_ON | IRQ_RXTIME |\r\nIRQ_ALLSENT | IRQ_TXFIFO);\r\nissue_command(info, CHA, CMD_TXRESET + CMD_RXRESET);\r\nwait_command_complete(info, CHA);\r\nread_reg16(info, CHA + ISR);\r\n}\r\nstatic void tx_set_idle(MGSLPC_INFO *info)\r\n{\r\nif (info->idle_mode == HDLC_TXIDLE_FLAGS)\r\nset_reg_bits(info, CHA + CCR1, BIT3);\r\nelse\r\nclear_reg_bits(info, CHA + CCR1, BIT3);\r\n}\r\nstatic void get_signals(MGSLPC_INFO *info)\r\n{\r\nunsigned char status = 0;\r\ninfo->serial_signals &= SerialSignal_RTS | SerialSignal_DTR;\r\nif (read_reg(info, CHB + VSTR) & BIT7)\r\ninfo->serial_signals |= SerialSignal_DCD;\r\nif (read_reg(info, CHB + STAR) & BIT1)\r\ninfo->serial_signals |= SerialSignal_CTS;\r\nstatus = read_reg(info, CHA + PVR);\r\nif (!(status & PVR_RI))\r\ninfo->serial_signals |= SerialSignal_RI;\r\nif (!(status & PVR_DSR))\r\ninfo->serial_signals |= SerialSignal_DSR;\r\n}\r\nstatic void set_signals(MGSLPC_INFO *info)\r\n{\r\nunsigned char val;\r\nval = read_reg(info, CHA + MODE);\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nif (info->serial_signals & SerialSignal_RTS)\r\nval &= ~BIT6;\r\nelse\r\nval |= BIT6;\r\n} else {\r\nif (info->serial_signals & SerialSignal_RTS)\r\nval |= BIT2;\r\nelse\r\nval &= ~BIT2;\r\n}\r\nwrite_reg(info, CHA + MODE, val);\r\nif (info->serial_signals & SerialSignal_DTR)\r\nclear_reg_bits(info, CHA + PVR, PVR_DTR);\r\nelse\r\nset_reg_bits(info, CHA + PVR, PVR_DTR);\r\n}\r\nstatic void rx_reset_buffers(MGSLPC_INFO *info)\r\n{\r\nRXBUF *buf;\r\nint i;\r\ninfo->rx_put = 0;\r\ninfo->rx_get = 0;\r\ninfo->rx_frame_count = 0;\r\nfor (i=0 ; i < info->rx_buf_count ; i++) {\r\nbuf = (RXBUF*)(info->rx_buf + (i * info->rx_buf_size));\r\nbuf->status = buf->count = 0;\r\n}\r\n}\r\nstatic bool rx_get_frame(MGSLPC_INFO *info, struct tty_struct *tty)\r\n{\r\nunsigned short status;\r\nRXBUF *buf;\r\nunsigned int framesize = 0;\r\nunsigned long flags;\r\nbool return_frame = false;\r\nif (info->rx_frame_count == 0)\r\nreturn false;\r\nbuf = (RXBUF*)(info->rx_buf + (info->rx_get * info->rx_buf_size));\r\nstatus = buf->status;\r\nif ((status & 0xf0) != 0xA0) {\r\nif (!(status & BIT7) || (status & BIT4))\r\ninfo->icount.rxabort++;\r\nelse if (status & BIT6)\r\ninfo->icount.rxover++;\r\nelse if (!(status & BIT5)) {\r\ninfo->icount.rxcrc++;\r\nif (info->params.crc_type & HDLC_CRC_RETURN_EX)\r\nreturn_frame = true;\r\n}\r\nframesize = 0;\r\n#if SYNCLINK_GENERIC_HDLC\r\n{\r\ninfo->netdev->stats.rx_errors++;\r\ninfo->netdev->stats.rx_frame_errors++;\r\n}\r\n#endif\r\n} else\r\nreturn_frame = true;\r\nif (return_frame)\r\nframesize = buf->count;\r\nif (debug_level >= DEBUG_LEVEL_BH)\r\nprintk("%s(%d):rx_get_frame(%s) status=%04X size=%d\n",\r\n__FILE__, __LINE__, info->device_name, status, framesize);\r\nif (debug_level >= DEBUG_LEVEL_DATA)\r\ntrace_block(info, buf->data, framesize, 0);\r\nif (framesize) {\r\nif ((info->params.crc_type & HDLC_CRC_RETURN_EX &&\r\nframesize+1 > info->max_frame_size) ||\r\nframesize > info->max_frame_size)\r\ninfo->icount.rxlong++;\r\nelse {\r\nif (status & BIT5)\r\ninfo->icount.rxok++;\r\nif (info->params.crc_type & HDLC_CRC_RETURN_EX) {\r\n*(buf->data + framesize) = status & BIT5 ? RX_OK:RX_CRC_ERROR;\r\n++framesize;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_rx(info, buf->data, framesize);\r\nelse\r\n#endif\r\nldisc_receive_buf(tty, buf->data, info->flag_buf, framesize);\r\n}\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nbuf->status = buf->count = 0;\r\ninfo->rx_frame_count--;\r\ninfo->rx_get++;\r\nif (info->rx_get >= info->rx_buf_count)\r\ninfo->rx_get = 0;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn true;\r\n}\r\nstatic bool register_test(MGSLPC_INFO *info)\r\n{\r\nstatic unsigned char patterns[] =\r\n{ 0x00, 0xff, 0xaa, 0x55, 0x69, 0x96, 0x0f };\r\nstatic unsigned int count = ARRAY_SIZE(patterns);\r\nunsigned int i;\r\nbool rc = true;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nreset_device(info);\r\nfor (i = 0; i < count; i++) {\r\nwrite_reg(info, XAD1, patterns[i]);\r\nwrite_reg(info, XAD2, patterns[(i + 1) % count]);\r\nif ((read_reg(info, XAD1) != patterns[i]) ||\r\n(read_reg(info, XAD2) != patterns[(i + 1) % count])) {\r\nrc = false;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn rc;\r\n}\r\nstatic bool irq_test(MGSLPC_INFO *info)\r\n{\r\nunsigned long end_time;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock, flags);\r\nreset_device(info);\r\ninfo->testing_irq = true;\r\nhdlc_mode(info);\r\ninfo->irq_occurred = false;\r\nirq_enable(info, CHA, IRQ_TIMER);\r\nwrite_reg(info, CHA + TIMR, 0);\r\nissue_command(info, CHA, CMD_START_TIMER);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nend_time=100;\r\nwhile(end_time-- && !info->irq_occurred) {\r\nmsleep_interruptible(10);\r\n}\r\ninfo->testing_irq = false;\r\nspin_lock_irqsave(&info->lock, flags);\r\nreset_device(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn info->irq_occurred;\r\n}\r\nstatic int adapter_test(MGSLPC_INFO *info)\r\n{\r\nif (!register_test(info)) {\r\ninfo->init_error = DiagStatus_AddressFailure;\r\nprintk("%s(%d):Register test failure for device %s Addr=%04X\n",\r\n__FILE__, __LINE__, info->device_name, (unsigned short)(info->io_base));\r\nreturn -ENODEV;\r\n}\r\nif (!irq_test(info)) {\r\ninfo->init_error = DiagStatus_IrqFailure;\r\nprintk("%s(%d):Interrupt test failure for device %s IRQ=%d\n",\r\n__FILE__, __LINE__, info->device_name, (unsigned short)(info->irq_level));\r\nreturn -ENODEV;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):device %s passed diagnostics\n",\r\n__FILE__, __LINE__, info->device_name);\r\nreturn 0;\r\n}\r\nstatic void trace_block(MGSLPC_INFO *info,const char* data, int count, int xmit)\r\n{\r\nint i;\r\nint linecount;\r\nif (xmit)\r\nprintk("%s tx data:\n", info->device_name);\r\nelse\r\nprintk("%s rx data:\n", info->device_name);\r\nwhile(count) {\r\nif (count > 16)\r\nlinecount = 16;\r\nelse\r\nlinecount = count;\r\nfor(i=0;i<linecount;i++)\r\nprintk("%02X ", (unsigned char)data[i]);\r\nfor(;i<17;i++)\r\nprintk(" ");\r\nfor(i=0;i<linecount;i++) {\r\nif (data[i]>=040 && data[i]<=0176)\r\nprintk("%c", data[i]);\r\nelse\r\nprintk(".");\r\n}\r\nprintk("\n");\r\ndata += linecount;\r\ncount -= linecount;\r\n}\r\n}\r\nstatic void tx_timeout(unsigned long context)\r\n{\r\nMGSLPC_INFO *info = (MGSLPC_INFO*)context;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):tx_timeout(%s)\n",\r\n__FILE__, __LINE__, info->device_name);\r\nif (info->tx_active &&\r\ninfo->params.mode == MGSL_MODE_HDLC) {\r\ninfo->icount.txtimeout++;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\ninfo->tx_active = false;\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&info->port);\r\nbh_transmit(info, tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic int hdlcdev_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nstruct tty_struct *tty;\r\nunsigned char new_encoding;\r\nunsigned short new_crctype;\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nswitch (encoding)\r\n{\r\ncase ENCODING_NRZ: new_encoding = HDLC_ENCODING_NRZ; break;\r\ncase ENCODING_NRZI: new_encoding = HDLC_ENCODING_NRZI_SPACE; break;\r\ncase ENCODING_FM_MARK: new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;\r\ncase ENCODING_FM_SPACE: new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;\r\ncase ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (parity)\r\n{\r\ncase PARITY_NONE: new_crctype = HDLC_CRC_NONE; break;\r\ncase PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;\r\ncase PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;\r\ndefault: return -EINVAL;\r\n}\r\ninfo->params.encoding = new_encoding;\r\ninfo->params.crc_type = new_crctype;\r\nif (info->netcount) {\r\ntty = tty_port_tty_get(&info->port);\r\nmgslpc_program_hw(info, tty);\r\ntty_kref_put(tty);\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk(KERN_INFO "%s:hdlc_xmit(%s)\n", __FILE__, dev->name);\r\nnetif_stop_queue(dev);\r\nskb_copy_from_linear_data(skb, info->tx_buf, skb->len);\r\ninfo->tx_get = 0;\r\ninfo->tx_put = info->tx_count = skb->len;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\ndev->trans_start = jiffies;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (!info->tx_active) {\r\nstruct tty_struct *tty = tty_port_tty_get(&info->port);\r\ntx_start(info, tty);\r\ntty_kref_put(tty);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hdlcdev_open(struct net_device *dev)\r\n{\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nstruct tty_struct *tty;\r\nint rc;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_open(%s)\n", __FILE__, dev->name);\r\nrc = hdlc_open(dev);\r\nif (rc != 0)\r\nreturn rc;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->port.count != 0 || info->netcount != 0) {\r\nprintk(KERN_WARNING "%s: hdlc_open returning busy\n", dev->name);\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn -EBUSY;\r\n}\r\ninfo->netcount=1;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\ntty = tty_port_tty_get(&info->port);\r\nrc = startup(info, tty);\r\nif (rc != 0) {\r\ntty_kref_put(tty);\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn rc;\r\n}\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nmgslpc_program_hw(info, tty);\r\ntty_kref_put(tty);\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (info->serial_signals & SerialSignal_DCD)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_close(struct net_device *dev)\r\n{\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nstruct tty_struct *tty = tty_port_tty_get(&info->port);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_close(%s)\n", __FILE__, dev->name);\r\nnetif_stop_queue(dev);\r\nshutdown(info, tty);\r\ntty_kref_put(tty);\r\nhdlc_close(dev);\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nunsigned int flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_ioctl(%s)\n", __FILE__, dev->name);\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nmemset(&new_line, 0, size);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nflags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\nswitch (flags){\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;\r\ncase (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_INT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_TXINT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;\r\ndefault: new_line.clock_type = CLOCK_DEFAULT;\r\n}\r\nnew_line.clock_rate = info->params.clock_speed;\r\nnew_line.loopback = info->params.loopback ? 1:0;\r\nif (copy_to_user(line, &new_line, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nswitch (new_line.clock_type)\r\n{\r\ncase CLOCK_EXT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;\r\ncase CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;\r\ncase CLOCK_INT: flags = HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_TXINT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_DEFAULT: flags = info->params.flags &\r\n(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN); break;\r\ndefault: return -EINVAL;\r\n}\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\ninfo->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\ninfo->params.flags |= flags;\r\ninfo->params.loopback = new_line.loopback;\r\nif (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))\r\ninfo->params.clock_speed = new_line.clock_rate;\r\nelse\r\ninfo->params.clock_speed = 0;\r\nif (info->netcount) {\r\nstruct tty_struct *tty = tty_port_tty_get(&info->port);\r\nmgslpc_program_hw(info, tty);\r\ntty_kref_put(tty);\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void hdlcdev_tx_timeout(struct net_device *dev)\r\n{\r\nMGSLPC_INFO *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_tx_timeout(%s)\n", dev->name);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nspin_lock_irqsave(&info->lock, flags);\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void hdlcdev_tx_done(MGSLPC_INFO *info)\r\n{\r\nif (netif_queue_stopped(info->netdev))\r\nnetif_wake_queue(info->netdev);\r\n}\r\nstatic void hdlcdev_rx(MGSLPC_INFO *info, char *buf, int size)\r\n{\r\nstruct sk_buff *skb = dev_alloc_skb(size);\r\nstruct net_device *dev = info->netdev;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_rx(%s)\n", dev->name);\r\nif (skb == NULL) {\r\nprintk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, size), buf, size);\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += size;\r\nnetif_rx(skb);\r\n}\r\nstatic int hdlcdev_init(MGSLPC_INFO *info)\r\n{\r\nint rc;\r\nstruct net_device *dev;\r\nhdlc_device *hdlc;\r\ndev = alloc_hdlcdev(info);\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "%s:hdlc device allocation failure\n", __FILE__);\r\nreturn -ENOMEM;\r\n}\r\ndev->base_addr = info->io_base;\r\ndev->irq = info->irq_level;\r\ndev->netdev_ops = &hdlcdev_ops;\r\ndev->watchdog_timeo = 10 * HZ;\r\ndev->tx_queue_len = 50;\r\nhdlc = dev_to_hdlc(dev);\r\nhdlc->attach = hdlcdev_attach;\r\nhdlc->xmit = hdlcdev_xmit;\r\nrc = register_hdlc_device(dev);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s:unable to register hdlc device\n", __FILE__);\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\ninfo->netdev = dev;\r\nreturn 0;\r\n}\r\nstatic void hdlcdev_exit(MGSLPC_INFO *info)\r\n{\r\nunregister_hdlc_device(info->netdev);\r\nfree_netdev(info->netdev);\r\ninfo->netdev = NULL;\r\n}
