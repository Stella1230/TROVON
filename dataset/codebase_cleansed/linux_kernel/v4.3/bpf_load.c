static int populate_prog_array(const char *event, int prog_fd)\r\n{\r\nint ind = atoi(event), err;\r\nerr = bpf_update_elem(prog_array_fd, &ind, &prog_fd, BPF_ANY);\r\nif (err < 0) {\r\nprintf("failed to store prog_fd in prog_array\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_and_attach(const char *event, struct bpf_insn *prog, int size)\r\n{\r\nbool is_socket = strncmp(event, "socket", 6) == 0;\r\nbool is_kprobe = strncmp(event, "kprobe/", 7) == 0;\r\nbool is_kretprobe = strncmp(event, "kretprobe/", 10) == 0;\r\nenum bpf_prog_type prog_type;\r\nchar buf[256];\r\nint fd, efd, err, id;\r\nstruct perf_event_attr attr = {};\r\nattr.type = PERF_TYPE_TRACEPOINT;\r\nattr.sample_type = PERF_SAMPLE_RAW;\r\nattr.sample_period = 1;\r\nattr.wakeup_events = 1;\r\nif (is_socket) {\r\nprog_type = BPF_PROG_TYPE_SOCKET_FILTER;\r\n} else if (is_kprobe || is_kretprobe) {\r\nprog_type = BPF_PROG_TYPE_KPROBE;\r\n} else {\r\nprintf("Unknown event '%s'\n", event);\r\nreturn -1;\r\n}\r\nfd = bpf_prog_load(prog_type, prog, size, license, kern_version);\r\nif (fd < 0) {\r\nprintf("bpf_prog_load() err=%d\n%s", errno, bpf_log_buf);\r\nreturn -1;\r\n}\r\nprog_fd[prog_cnt++] = fd;\r\nif (is_socket) {\r\nevent += 6;\r\nif (*event != '/')\r\nreturn 0;\r\nevent++;\r\nif (!isdigit(*event)) {\r\nprintf("invalid prog number\n");\r\nreturn -1;\r\n}\r\nreturn populate_prog_array(event, fd);\r\n}\r\nif (is_kprobe || is_kretprobe) {\r\nif (is_kprobe)\r\nevent += 7;\r\nelse\r\nevent += 10;\r\nif (*event == 0) {\r\nprintf("event name cannot be empty\n");\r\nreturn -1;\r\n}\r\nif (isdigit(*event))\r\nreturn populate_prog_array(event, fd);\r\nsnprintf(buf, sizeof(buf),\r\n"echo '%c:%s %s' >> /sys/kernel/debug/tracing/kprobe_events",\r\nis_kprobe ? 'p' : 'r', event, event);\r\nerr = system(buf);\r\nif (err < 0) {\r\nprintf("failed to create kprobe '%s' error '%s'\n",\r\nevent, strerror(errno));\r\nreturn -1;\r\n}\r\n}\r\nstrcpy(buf, DEBUGFS);\r\nstrcat(buf, "events/kprobes/");\r\nstrcat(buf, event);\r\nstrcat(buf, "/id");\r\nefd = open(buf, O_RDONLY, 0);\r\nif (efd < 0) {\r\nprintf("failed to open event %s\n", event);\r\nreturn -1;\r\n}\r\nerr = read(efd, buf, sizeof(buf));\r\nif (err < 0 || err >= sizeof(buf)) {\r\nprintf("read from '%s' failed '%s'\n", event, strerror(errno));\r\nreturn -1;\r\n}\r\nclose(efd);\r\nbuf[err] = 0;\r\nid = atoi(buf);\r\nattr.config = id;\r\nefd = perf_event_open(&attr, -1, 0, -1, 0);\r\nif (efd < 0) {\r\nprintf("event %d fd %d err %s\n", id, efd, strerror(errno));\r\nreturn -1;\r\n}\r\nevent_fd[prog_cnt - 1] = efd;\r\nioctl(efd, PERF_EVENT_IOC_ENABLE, 0);\r\nioctl(efd, PERF_EVENT_IOC_SET_BPF, fd);\r\nreturn 0;\r\n}\r\nstatic int load_maps(struct bpf_map_def *maps, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len / sizeof(struct bpf_map_def); i++) {\r\nmap_fd[i] = bpf_create_map(maps[i].type,\r\nmaps[i].key_size,\r\nmaps[i].value_size,\r\nmaps[i].max_entries);\r\nif (map_fd[i] < 0)\r\nreturn 1;\r\nif (maps[i].type == BPF_MAP_TYPE_PROG_ARRAY)\r\nprog_array_fd = map_fd[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_sec(Elf *elf, int i, GElf_Ehdr *ehdr, char **shname,\r\nGElf_Shdr *shdr, Elf_Data **data)\r\n{\r\nElf_Scn *scn;\r\nscn = elf_getscn(elf, i);\r\nif (!scn)\r\nreturn 1;\r\nif (gelf_getshdr(scn, shdr) != shdr)\r\nreturn 2;\r\n*shname = elf_strptr(elf, ehdr->e_shstrndx, shdr->sh_name);\r\nif (!*shname || !shdr->sh_size)\r\nreturn 3;\r\n*data = elf_getdata(scn, 0);\r\nif (!*data || elf_getdata(scn, *data) != NULL)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int parse_relo_and_apply(Elf_Data *data, Elf_Data *symbols,\r\nGElf_Shdr *shdr, struct bpf_insn *insn)\r\n{\r\nint i, nrels;\r\nnrels = shdr->sh_size / shdr->sh_entsize;\r\nfor (i = 0; i < nrels; i++) {\r\nGElf_Sym sym;\r\nGElf_Rel rel;\r\nunsigned int insn_idx;\r\ngelf_getrel(data, i, &rel);\r\ninsn_idx = rel.r_offset / sizeof(struct bpf_insn);\r\ngelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym);\r\nif (insn[insn_idx].code != (BPF_LD | BPF_IMM | BPF_DW)) {\r\nprintf("invalid relo for insn[%d].code 0x%x\n",\r\ninsn_idx, insn[insn_idx].code);\r\nreturn 1;\r\n}\r\ninsn[insn_idx].src_reg = BPF_PSEUDO_MAP_FD;\r\ninsn[insn_idx].imm = map_fd[sym.st_value / sizeof(struct bpf_map_def)];\r\n}\r\nreturn 0;\r\n}\r\nint load_bpf_file(char *path)\r\n{\r\nint fd, i;\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr, shdr_prog;\r\nElf_Data *data, *data_prog, *symbols = NULL;\r\nchar *shname, *shname_prog;\r\nif (elf_version(EV_CURRENT) == EV_NONE)\r\nreturn 1;\r\nfd = open(path, O_RDONLY, 0);\r\nif (fd < 0)\r\nreturn 1;\r\nelf = elf_begin(fd, ELF_C_READ, NULL);\r\nif (!elf)\r\nreturn 1;\r\nif (gelf_getehdr(elf, &ehdr) != &ehdr)\r\nreturn 1;\r\ni = system("echo \"\" > /sys/kernel/debug/tracing/kprobe_events");\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (0)\r\nprintf("section %d:%s data %p size %zd link %d flags %d\n",\r\ni, shname, data->d_buf, data->d_size,\r\nshdr.sh_link, (int) shdr.sh_flags);\r\nif (strcmp(shname, "license") == 0) {\r\nprocessed_sec[i] = true;\r\nmemcpy(license, data->d_buf, data->d_size);\r\n} else if (strcmp(shname, "version") == 0) {\r\nprocessed_sec[i] = true;\r\nif (data->d_size != sizeof(int)) {\r\nprintf("invalid size of version section %zd\n",\r\ndata->d_size);\r\nreturn 1;\r\n}\r\nmemcpy(&kern_version, data->d_buf, sizeof(int));\r\n} else if (strcmp(shname, "maps") == 0) {\r\nprocessed_sec[i] = true;\r\nif (load_maps(data->d_buf, data->d_size))\r\nreturn 1;\r\n} else if (shdr.sh_type == SHT_SYMTAB) {\r\nsymbols = data;\r\n}\r\n}\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (shdr.sh_type == SHT_REL) {\r\nstruct bpf_insn *insns;\r\nif (get_sec(elf, shdr.sh_info, &ehdr, &shname_prog,\r\n&shdr_prog, &data_prog))\r\ncontinue;\r\ninsns = (struct bpf_insn *) data_prog->d_buf;\r\nprocessed_sec[shdr.sh_info] = true;\r\nprocessed_sec[i] = true;\r\nif (parse_relo_and_apply(data, symbols, &shdr, insns))\r\ncontinue;\r\nif (memcmp(shname_prog, "kprobe/", 7) == 0 ||\r\nmemcmp(shname_prog, "kretprobe/", 10) == 0 ||\r\nmemcmp(shname_prog, "socket", 6) == 0)\r\nload_and_attach(shname_prog, insns, data_prog->d_size);\r\n}\r\n}\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (processed_sec[i])\r\ncontinue;\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (memcmp(shname, "kprobe/", 7) == 0 ||\r\nmemcmp(shname, "kretprobe/", 10) == 0 ||\r\nmemcmp(shname, "socket", 6) == 0)\r\nload_and_attach(shname, data->d_buf, data->d_size);\r\n}\r\nclose(fd);\r\nreturn 0;\r\n}\r\nvoid read_trace_pipe(void)\r\n{\r\nint trace_fd;\r\ntrace_fd = open(DEBUGFS "trace_pipe", O_RDONLY, 0);\r\nif (trace_fd < 0)\r\nreturn;\r\nwhile (1) {\r\nstatic char buf[4096];\r\nssize_t sz;\r\nsz = read(trace_fd, buf, sizeof(buf));\r\nif (sz > 0) {\r\nbuf[sz] = 0;\r\nputs(buf);\r\n}\r\n}\r\n}
