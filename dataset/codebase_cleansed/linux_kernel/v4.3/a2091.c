static irqreturn_t a2091_intr(int irq, void *data)\r\n{\r\nstruct Scsi_Host *instance = data;\r\nstruct a2091_hostdata *hdata = shost_priv(instance);\r\nunsigned int status = hdata->regs->ISTR;\r\nunsigned long flags;\r\nif (!(status & (ISTR_INT_F | ISTR_INT_P)) || !(status & ISTR_INTS))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nwd33c93_intr(instance);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct a2091_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct a2091_scsiregs *regs = hdata->regs;\r\nunsigned short cntr = CNTR_PDMD | CNTR_INTEN;\r\nunsigned long addr = virt_to_bus(cmd->SCp.ptr);\r\nif (addr & A2091_XFER_MASK) {\r\nwh->dma_bounce_len = (cmd->SCp.this_residual + 511) & ~0x1ff;\r\nwh->dma_bounce_buffer = kmalloc(wh->dma_bounce_len,\r\nGFP_KERNEL);\r\nif (!wh->dma_bounce_buffer) {\r\nwh->dma_bounce_len = 0;\r\nreturn 1;\r\n}\r\naddr = virt_to_bus(wh->dma_bounce_buffer);\r\nif (addr & A2091_XFER_MASK) {\r\nkfree(wh->dma_bounce_buffer);\r\nwh->dma_bounce_buffer = NULL;\r\nwh->dma_bounce_len = 0;\r\nreturn 1;\r\n}\r\nif (!dir_in) {\r\nmemcpy(wh->dma_bounce_buffer, cmd->SCp.ptr,\r\ncmd->SCp.this_residual);\r\n}\r\n}\r\nif (!dir_in)\r\ncntr |= CNTR_DDIR;\r\nwh->dma_dir = dir_in;\r\nregs->CNTR = cntr;\r\nregs->ACR = addr;\r\nif (dir_in) {\r\ncache_clear(addr, cmd->SCp.this_residual);\r\n} else {\r\ncache_push(addr, cmd->SCp.this_residual);\r\n}\r\nregs->ST_DMA = 1;\r\nreturn 0;\r\n}\r\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\r\nint status)\r\n{\r\nstruct a2091_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct a2091_scsiregs *regs = hdata->regs;\r\nunsigned short cntr = CNTR_PDMD;\r\nif (!wh->dma_dir)\r\ncntr |= CNTR_DDIR;\r\nregs->CNTR = cntr;\r\nif (wh->dma_dir) {\r\nregs->FLUSH = 1;\r\nwhile (!(regs->ISTR & ISTR_FE_FLG))\r\n;\r\n}\r\nregs->CINT = 1;\r\nregs->SP_DMA = 1;\r\nregs->CNTR = CNTR_PDMD | CNTR_INTEN;\r\nif (status && wh->dma_bounce_buffer) {\r\nif (wh->dma_dir)\r\nmemcpy(SCpnt->SCp.ptr, wh->dma_bounce_buffer,\r\nSCpnt->SCp.this_residual);\r\nkfree(wh->dma_bounce_buffer);\r\nwh->dma_bounce_buffer = NULL;\r\nwh->dma_bounce_len = 0;\r\n}\r\n}\r\nstatic int a2091_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nspin_lock_irq(instance->host_lock);\r\nwd33c93_host_reset(cmd);\r\nspin_unlock_irq(instance->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int a2091_probe(struct zorro_dev *z, const struct zorro_device_id *ent)\r\n{\r\nstruct Scsi_Host *instance;\r\nint error;\r\nstruct a2091_scsiregs *regs;\r\nwd33c93_regs wdregs;\r\nstruct a2091_hostdata *hdata;\r\nif (!request_mem_region(z->resource.start, 256, "wd33c93"))\r\nreturn -EBUSY;\r\ninstance = scsi_host_alloc(&a2091_scsi_template,\r\nsizeof(struct a2091_hostdata));\r\nif (!instance) {\r\nerror = -ENOMEM;\r\ngoto fail_alloc;\r\n}\r\ninstance->irq = IRQ_AMIGA_PORTS;\r\ninstance->unique_id = z->slotaddr;\r\nregs = ZTWO_VADDR(z->resource.start);\r\nregs->DAWR = DAWR_A2091;\r\nwdregs.SASR = &regs->SASR;\r\nwdregs.SCMD = &regs->SCMD;\r\nhdata = shost_priv(instance);\r\nhdata->wh.no_sync = 0xff;\r\nhdata->wh.fast = 0;\r\nhdata->wh.dma_mode = CTRL_DMA;\r\nhdata->regs = regs;\r\nwd33c93_init(instance, wdregs, dma_setup, dma_stop, WD33C93_FS_8_10);\r\nerror = request_irq(IRQ_AMIGA_PORTS, a2091_intr, IRQF_SHARED,\r\n"A2091 SCSI", instance);\r\nif (error)\r\ngoto fail_irq;\r\nregs->CNTR = CNTR_PDMD | CNTR_INTEN;\r\nerror = scsi_add_host(instance, NULL);\r\nif (error)\r\ngoto fail_host;\r\nzorro_set_drvdata(z, instance);\r\nscsi_scan_host(instance);\r\nreturn 0;\r\nfail_host:\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nfail_irq:\r\nscsi_host_put(instance);\r\nfail_alloc:\r\nrelease_mem_region(z->resource.start, 256);\r\nreturn error;\r\n}\r\nstatic void a2091_remove(struct zorro_dev *z)\r\n{\r\nstruct Scsi_Host *instance = zorro_get_drvdata(z);\r\nstruct a2091_hostdata *hdata = shost_priv(instance);\r\nhdata->regs->CNTR = 0;\r\nscsi_remove_host(instance);\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nscsi_host_put(instance);\r\nrelease_mem_region(z->resource.start, 256);\r\n}\r\nstatic int __init a2091_init(void)\r\n{\r\nreturn zorro_register_driver(&a2091_driver);\r\n}\r\nstatic void __exit a2091_exit(void)\r\n{\r\nzorro_unregister_driver(&a2091_driver);\r\n}
