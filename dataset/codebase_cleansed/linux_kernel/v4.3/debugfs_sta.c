static ssize_t sta_flags_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[121];\r\nstruct sta_info *sta = file->private_data;\r\n#define TEST(flg) \\r\ntest_sta_flag(sta, WLAN_STA_##flg) ? #flg "\n" : ""\r\nint res = scnprintf(buf, sizeof(buf),\r\n"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",\r\nTEST(AUTH), TEST(ASSOC), TEST(PS_STA),\r\nTEST(PS_DRIVER), TEST(AUTHORIZED),\r\nTEST(SHORT_PREAMBLE),\r\nsta->sta.wme ? "WME\n" : "",\r\nTEST(WDS), TEST(CLEAR_PS_FILT),\r\nTEST(MFP), TEST(BLOCK_BA), TEST(PSPOLL),\r\nTEST(UAPSD), TEST(SP), TEST(TDLS_PEER),\r\nTEST(TDLS_PEER_AUTH), TEST(TDLS_INITIATOR),\r\nTEST(TDLS_CHAN_SWITCH), TEST(TDLS_OFF_CHANNEL),\r\nTEST(4ADDR_EVENT), TEST(INSERTED),\r\nTEST(RATE_CONTROL), TEST(TOFFSET_KNOWN),\r\nTEST(MPSP_OWNER), TEST(MPSP_RECIPIENT));\r\n#undef TEST\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, res);\r\n}\r\nstatic ssize_t sta_num_ps_buf_frames_read(struct file *file,\r\nchar __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sta_info *sta = file->private_data;\r\nchar buf[17*IEEE80211_NUM_ACS], *p = buf;\r\nint ac;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\np += scnprintf(p, sizeof(buf)+buf-p, "AC%d: %d\n", ac,\r\nskb_queue_len(&sta->ps_tx_buf[ac]) +\r\nskb_queue_len(&sta->tx_filtered[ac]));\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_last_seq_ctrl_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[15*IEEE80211_NUM_TIDS], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\r\np += scnprintf(p, sizeof(buf)+buf-p, "%x ",\r\nle16_to_cpu(sta->last_seq_ctrl[i]));\r\np += scnprintf(p, sizeof(buf)+buf-p, "\n");\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[71 + IEEE80211_NUM_TIDS * 40], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nstruct tid_ampdu_rx *tid_rx;\r\nstruct tid_ampdu_tx *tid_tx;\r\nrcu_read_lock();\r\np += scnprintf(p, sizeof(buf) + buf - p, "next dialog_token: %#02x\n",\r\nsta->ampdu_mlme.dialog_token_allocator + 1);\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"TID\t\tRX\tDTKN\tSSN\t\tTX\tDTKN\tpending\n");\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\ntid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[i]);\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[i]);\r\np += scnprintf(p, sizeof(buf) + buf - p, "%02d", i);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x", !!tid_rx);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",\r\ntid_rx ? tid_rx->dialog_token : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.3x",\r\ntid_rx ? tid_rx->ssn : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x", !!tid_tx);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",\r\ntid_tx ? tid_tx->dialog_token : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%03d",\r\ntid_tx ? skb_queue_len(&tid_tx->pending) : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\n");\r\n}\r\nrcu_read_unlock();\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_agg_status_write(struct file *file, const char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar _buf[12] = {}, *buf = _buf;\r\nstruct sta_info *sta = file->private_data;\r\nbool start, tx;\r\nunsigned long tid;\r\nint ret;\r\nif (count > sizeof(_buf))\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, userbuf, count))\r\nreturn -EFAULT;\r\nbuf[sizeof(_buf) - 1] = '\0';\r\nif (strncmp(buf, "tx ", 3) == 0) {\r\nbuf += 3;\r\ntx = true;\r\n} else if (strncmp(buf, "rx ", 3) == 0) {\r\nbuf += 3;\r\ntx = false;\r\n} else\r\nreturn -EINVAL;\r\nif (strncmp(buf, "start ", 6) == 0) {\r\nbuf += 6;\r\nstart = true;\r\nif (!tx)\r\nreturn -EINVAL;\r\n} else if (strncmp(buf, "stop ", 5) == 0) {\r\nbuf += 5;\r\nstart = false;\r\n} else\r\nreturn -EINVAL;\r\nret = kstrtoul(buf, 0, &tid);\r\nif (ret)\r\nreturn ret;\r\nif (tid >= IEEE80211_NUM_TIDS)\r\nreturn -EINVAL;\r\nif (tx) {\r\nif (start)\r\nret = ieee80211_start_tx_ba_session(&sta->sta, tid, 5000);\r\nelse\r\nret = ieee80211_stop_tx_ba_session(&sta->sta, tid);\r\n} else {\r\n__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,\r\n3, true);\r\nret = 0;\r\n}\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t sta_ht_capa_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\n#define PRINT_HT_CAP(_cond, _str) \\r\ndo { \\r\nif (_cond) \\r\np += scnprintf(p, sizeof(buf)+buf-p, "\t" _str "\n"); \\r\n} while (0)\r\nchar buf[512], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nstruct ieee80211_sta_ht_cap *htc = &sta->sta.ht_cap;\r\np += scnprintf(p, sizeof(buf) + buf - p, "ht %ssupported\n",\r\nhtc->ht_supported ? "" : "not ");\r\nif (htc->ht_supported) {\r\np += scnprintf(p, sizeof(buf)+buf-p, "cap: %#.4x\n", htc->cap);\r\nPRINT_HT_CAP((htc->cap & BIT(0)), "RX LDPC");\r\nPRINT_HT_CAP((htc->cap & BIT(1)), "HT20/HT40");\r\nPRINT_HT_CAP(!(htc->cap & BIT(1)), "HT20");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 0, "Static SM Power Save");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 1, "Dynamic SM Power Save");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 3, "SM Power Save disabled");\r\nPRINT_HT_CAP((htc->cap & BIT(4)), "RX Greenfield");\r\nPRINT_HT_CAP((htc->cap & BIT(5)), "RX HT20 SGI");\r\nPRINT_HT_CAP((htc->cap & BIT(6)), "RX HT40 SGI");\r\nPRINT_HT_CAP((htc->cap & BIT(7)), "TX STBC");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 0, "No RX STBC");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 1, "RX STBC 1-stream");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 2, "RX STBC 2-streams");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 3, "RX STBC 3-streams");\r\nPRINT_HT_CAP((htc->cap & BIT(10)), "HT Delayed Block Ack");\r\nPRINT_HT_CAP(!(htc->cap & BIT(11)), "Max AMSDU length: "\r\n"3839 bytes");\r\nPRINT_HT_CAP((htc->cap & BIT(11)), "Max AMSDU length: "\r\n"7935 bytes");\r\nPRINT_HT_CAP((htc->cap & BIT(12)), "DSSS/CCK HT40");\r\nPRINT_HT_CAP(!(htc->cap & BIT(12)), "No DSSS/CCK HT40");\r\nPRINT_HT_CAP((htc->cap & BIT(14)), "40 MHz Intolerant");\r\nPRINT_HT_CAP((htc->cap & BIT(15)), "L-SIG TXOP protection");\r\np += scnprintf(p, sizeof(buf)+buf-p, "ampdu factor/density: %d/%d\n",\r\nhtc->ampdu_factor, htc->ampdu_density);\r\np += scnprintf(p, sizeof(buf)+buf-p, "MCS mask:");\r\nfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\r\np += scnprintf(p, sizeof(buf)+buf-p, " %.2x",\r\nhtc->mcs.rx_mask[i]);\r\np += scnprintf(p, sizeof(buf)+buf-p, "\n");\r\nif (le16_to_cpu(htc->mcs.rx_highest)) {\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS rx highest: %d Mbps\n",\r\nle16_to_cpu(htc->mcs.rx_highest));\r\n}\r\np += scnprintf(p, sizeof(buf)+buf-p, "MCS tx params: %x\n",\r\nhtc->mcs.tx_params);\r\n}\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_vht_capa_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[128], *p = buf;\r\nstruct sta_info *sta = file->private_data;\r\nstruct ieee80211_sta_vht_cap *vhtc = &sta->sta.vht_cap;\r\np += scnprintf(p, sizeof(buf) + buf - p, "VHT %ssupported\n",\r\nvhtc->vht_supported ? "" : "not ");\r\nif (vhtc->vht_supported) {\r\np += scnprintf(p, sizeof(buf)+buf-p, "cap: %#.8x\n", vhtc->cap);\r\np += scnprintf(p, sizeof(buf)+buf-p, "RX MCS: %.4x\n",\r\nle16_to_cpu(vhtc->vht_mcs.rx_mcs_map));\r\nif (vhtc->vht_mcs.rx_highest)\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS RX highest: %d Mbps\n",\r\nle16_to_cpu(vhtc->vht_mcs.rx_highest));\r\np += scnprintf(p, sizeof(buf)+buf-p, "TX MCS: %.4x\n",\r\nle16_to_cpu(vhtc->vht_mcs.tx_mcs_map));\r\nif (vhtc->vht_mcs.tx_highest)\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS TX highest: %d Mbps\n",\r\nle16_to_cpu(vhtc->vht_mcs.tx_highest));\r\n}\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nvoid ieee80211_sta_debugfs_add(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct dentry *stations_dir = sta->sdata->debugfs.subdir_stations;\r\nu8 mac[3*ETH_ALEN];\r\nsta->debugfs.add_has_run = true;\r\nif (!stations_dir)\r\nreturn;\r\nsnprintf(mac, sizeof(mac), "%pM", sta->sta.addr);\r\nsta->debugfs.dir = debugfs_create_dir(mac, stations_dir);\r\nif (!sta->debugfs.dir)\r\nreturn;\r\nDEBUGFS_ADD(flags);\r\nDEBUGFS_ADD(num_ps_buf_frames);\r\nDEBUGFS_ADD(last_seq_ctrl);\r\nDEBUGFS_ADD(agg_status);\r\nDEBUGFS_ADD(ht_capa);\r\nDEBUGFS_ADD(vht_capa);\r\nDEBUGFS_ADD(last_ack_signal);\r\nDEBUGFS_ADD_COUNTER(rx_duplicates, num_duplicates);\r\nDEBUGFS_ADD_COUNTER(rx_fragments, rx_fragments);\r\nDEBUGFS_ADD_COUNTER(tx_filtered, tx_filtered_count);\r\nif (sizeof(sta->driver_buffered_tids) == sizeof(u32))\r\ndebugfs_create_x32("driver_buffered_tids", 0400,\r\nsta->debugfs.dir,\r\n(u32 *)&sta->driver_buffered_tids);\r\nelse\r\ndebugfs_create_x64("driver_buffered_tids", 0400,\r\nsta->debugfs.dir,\r\n(u64 *)&sta->driver_buffered_tids);\r\ndrv_sta_add_debugfs(local, sdata, &sta->sta, sta->debugfs.dir);\r\n}\r\nvoid ieee80211_sta_debugfs_remove(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\ndrv_sta_remove_debugfs(local, sdata, &sta->sta, sta->debugfs.dir);\r\ndebugfs_remove_recursive(sta->debugfs.dir);\r\nsta->debugfs.dir = NULL;\r\n}
