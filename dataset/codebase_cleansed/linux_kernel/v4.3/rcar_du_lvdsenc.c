static void rcar_lvds_write(struct rcar_du_lvdsenc *lvds, u32 reg, u32 data)\r\n{\r\niowrite32(data, lvds->mmio + reg);\r\n}\r\nstatic int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,\r\nstruct rcar_du_crtc *rcrtc)\r\n{\r\nconst struct drm_display_mode *mode = &rcrtc->crtc.mode;\r\nunsigned int freq = mode->clock;\r\nu32 lvdcr0;\r\nu32 lvdhcr;\r\nu32 pllcr;\r\nint ret;\r\nif (lvds->enabled)\r\nreturn 0;\r\nret = clk_prepare_enable(lvds->clock);\r\nif (ret < 0)\r\nreturn ret;\r\nif (freq <= 38000)\r\npllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_38M;\r\nelse if (freq <= 60000)\r\npllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_60M;\r\nelse if (freq <= 121000)\r\npllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_121M;\r\nelse\r\npllcr = LVDPLLCR_PLLDLYCNT_150M;\r\nrcar_lvds_write(lvds, LVDPLLCR, pllcr);\r\nrcar_lvds_write(lvds, LVDCTRCR, LVDCTRCR_CTR3SEL_ZERO |\r\nLVDCTRCR_CTR2SEL_DISP | LVDCTRCR_CTR1SEL_VSYNC |\r\nLVDCTRCR_CTR0SEL_HSYNC);\r\nif (rcar_du_needs(lvds->dev, RCAR_DU_QUIRK_LVDS_LANES))\r\nlvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 3)\r\n| LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 1);\r\nelse\r\nlvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 1)\r\n| LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 3);\r\nrcar_lvds_write(lvds, LVDCHCR, lvdhcr);\r\nlvdcr0 = LVDCR0_BEN | LVDCR0_LVEN;\r\nif (rcrtc->index == 2)\r\nlvdcr0 |= LVDCR0_DUSEL;\r\nrcar_lvds_write(lvds, LVDCR0, lvdcr0);\r\nrcar_lvds_write(lvds, LVDCR1, LVDCR1_CHSTBY(3) | LVDCR1_CHSTBY(2) |\r\nLVDCR1_CHSTBY(1) | LVDCR1_CHSTBY(0) | LVDCR1_CLKSTBY);\r\nlvdcr0 |= LVDCR0_PLLEN;\r\nrcar_lvds_write(lvds, LVDCR0, lvdcr0);\r\nusleep_range(100, 150);\r\nlvdcr0 |= LVDCR0_LVRES;\r\nrcar_lvds_write(lvds, LVDCR0, lvdcr0);\r\nlvds->enabled = true;\r\nreturn 0;\r\n}\r\nstatic void rcar_du_lvdsenc_stop(struct rcar_du_lvdsenc *lvds)\r\n{\r\nif (!lvds->enabled)\r\nreturn;\r\nrcar_lvds_write(lvds, LVDCR0, 0);\r\nrcar_lvds_write(lvds, LVDCR1, 0);\r\nclk_disable_unprepare(lvds->clock);\r\nlvds->enabled = false;\r\n}\r\nint rcar_du_lvdsenc_enable(struct rcar_du_lvdsenc *lvds, struct drm_crtc *crtc,\r\nbool enable)\r\n{\r\nif (!enable) {\r\nrcar_du_lvdsenc_stop(lvds);\r\nreturn 0;\r\n} else if (crtc) {\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nreturn rcar_du_lvdsenc_start(lvds, rcrtc);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int rcar_du_lvdsenc_get_resources(struct rcar_du_lvdsenc *lvds,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nchar name[7];\r\nsprintf(name, "lvds.%u", lvds->index);\r\nmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nlvds->mmio = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(lvds->mmio))\r\nreturn PTR_ERR(lvds->mmio);\r\nlvds->clock = devm_clk_get(&pdev->dev, name);\r\nif (IS_ERR(lvds->clock)) {\r\ndev_err(&pdev->dev, "failed to get clock for %s\n", name);\r\nreturn PTR_ERR(lvds->clock);\r\n}\r\nreturn 0;\r\n}\r\nint rcar_du_lvdsenc_init(struct rcar_du_device *rcdu)\r\n{\r\nstruct platform_device *pdev = to_platform_device(rcdu->dev);\r\nstruct rcar_du_lvdsenc *lvds;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < rcdu->info->num_lvds; ++i) {\r\nlvds = devm_kzalloc(&pdev->dev, sizeof(*lvds), GFP_KERNEL);\r\nif (lvds == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nlvds->dev = rcdu;\r\nlvds->index = i;\r\nlvds->input = i ? RCAR_LVDS_INPUT_DU1 : RCAR_LVDS_INPUT_DU0;\r\nlvds->enabled = false;\r\nret = rcar_du_lvdsenc_get_resources(lvds, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nrcdu->lvds[i] = lvds;\r\n}\r\nreturn 0;\r\n}
