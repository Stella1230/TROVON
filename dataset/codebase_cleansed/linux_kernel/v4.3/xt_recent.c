static inline struct recent_net *recent_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, recent_net_id);\r\n}\r\nstatic inline unsigned int recent_entry_hash4(const union nf_inet_addr *addr)\r\n{\r\nreturn jhash_1word((__force u32)addr->ip, hash_rnd) &\r\n(ip_list_hash_size - 1);\r\n}\r\nstatic inline unsigned int recent_entry_hash6(const union nf_inet_addr *addr)\r\n{\r\nreturn jhash2((u32 *)addr->ip6, ARRAY_SIZE(addr->ip6), hash_rnd) &\r\n(ip_list_hash_size - 1);\r\n}\r\nstatic struct recent_entry *\r\nrecent_entry_lookup(const struct recent_table *table,\r\nconst union nf_inet_addr *addrp, u_int16_t family,\r\nu_int8_t ttl)\r\n{\r\nstruct recent_entry *e;\r\nunsigned int h;\r\nif (family == NFPROTO_IPV4)\r\nh = recent_entry_hash4(addrp);\r\nelse\r\nh = recent_entry_hash6(addrp);\r\nlist_for_each_entry(e, &table->iphash[h], list)\r\nif (e->family == family &&\r\nmemcmp(&e->addr, addrp, sizeof(e->addr)) == 0 &&\r\n(ttl == e->ttl || ttl == 0 || e->ttl == 0))\r\nreturn e;\r\nreturn NULL;\r\n}\r\nstatic void recent_entry_remove(struct recent_table *t, struct recent_entry *e)\r\n{\r\nlist_del(&e->list);\r\nlist_del(&e->lru_list);\r\nkfree(e);\r\nt->entries--;\r\n}\r\nstatic void recent_entry_reap(struct recent_table *t, unsigned long time)\r\n{\r\nstruct recent_entry *e;\r\ne = list_entry(t->lru_list.next, struct recent_entry, lru_list);\r\nif (time_after(time, e->stamps[e->index-1]))\r\nrecent_entry_remove(t, e);\r\n}\r\nstatic struct recent_entry *\r\nrecent_entry_init(struct recent_table *t, const union nf_inet_addr *addr,\r\nu_int16_t family, u_int8_t ttl)\r\n{\r\nstruct recent_entry *e;\r\nunsigned int nstamps_max = t->nstamps_max_mask;\r\nif (t->entries >= ip_list_tot) {\r\ne = list_entry(t->lru_list.next, struct recent_entry, lru_list);\r\nrecent_entry_remove(t, e);\r\n}\r\nnstamps_max += 1;\r\ne = kmalloc(sizeof(*e) + sizeof(e->stamps[0]) * nstamps_max,\r\nGFP_ATOMIC);\r\nif (e == NULL)\r\nreturn NULL;\r\nmemcpy(&e->addr, addr, sizeof(e->addr));\r\ne->ttl = ttl;\r\ne->stamps[0] = jiffies;\r\ne->nstamps = 1;\r\ne->index = 1;\r\ne->family = family;\r\nif (family == NFPROTO_IPV4)\r\nlist_add_tail(&e->list, &t->iphash[recent_entry_hash4(addr)]);\r\nelse\r\nlist_add_tail(&e->list, &t->iphash[recent_entry_hash6(addr)]);\r\nlist_add_tail(&e->lru_list, &t->lru_list);\r\nt->entries++;\r\nreturn e;\r\n}\r\nstatic void recent_entry_update(struct recent_table *t, struct recent_entry *e)\r\n{\r\ne->index &= t->nstamps_max_mask;\r\ne->stamps[e->index++] = jiffies;\r\nif (e->index > e->nstamps)\r\ne->nstamps = e->index;\r\nlist_move_tail(&e->lru_list, &t->lru_list);\r\n}\r\nstatic struct recent_table *recent_table_lookup(struct recent_net *recent_net,\r\nconst char *name)\r\n{\r\nstruct recent_table *t;\r\nlist_for_each_entry(t, &recent_net->tables, list)\r\nif (!strcmp(t->name, name))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic void recent_table_flush(struct recent_table *t)\r\n{\r\nstruct recent_entry *e, *next;\r\nunsigned int i;\r\nfor (i = 0; i < ip_list_hash_size; i++)\r\nlist_for_each_entry_safe(e, next, &t->iphash[i], list)\r\nrecent_entry_remove(t, e);\r\n}\r\nstatic bool\r\nrecent_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct net *net = dev_net(par->in ? par->in : par->out);\r\nstruct recent_net *recent_net = recent_pernet(net);\r\nconst struct xt_recent_mtinfo_v1 *info = par->matchinfo;\r\nstruct recent_table *t;\r\nstruct recent_entry *e;\r\nunion nf_inet_addr addr = {}, addr_mask;\r\nu_int8_t ttl;\r\nbool ret = info->invert;\r\nif (par->family == NFPROTO_IPV4) {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nif (info->side == XT_RECENT_DEST)\r\naddr.ip = iph->daddr;\r\nelse\r\naddr.ip = iph->saddr;\r\nttl = iph->ttl;\r\n} else {\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nif (info->side == XT_RECENT_DEST)\r\nmemcpy(&addr.in6, &iph->daddr, sizeof(addr.in6));\r\nelse\r\nmemcpy(&addr.in6, &iph->saddr, sizeof(addr.in6));\r\nttl = iph->hop_limit;\r\n}\r\nif (par->out != NULL && skb->sk == NULL)\r\nttl++;\r\nspin_lock_bh(&recent_lock);\r\nt = recent_table_lookup(recent_net, info->name);\r\nnf_inet_addr_mask(&addr, &addr_mask, &t->mask);\r\ne = recent_entry_lookup(t, &addr_mask, par->family,\r\n(info->check_set & XT_RECENT_TTL) ? ttl : 0);\r\nif (e == NULL) {\r\nif (!(info->check_set & XT_RECENT_SET))\r\ngoto out;\r\ne = recent_entry_init(t, &addr_mask, par->family, ttl);\r\nif (e == NULL)\r\npar->hotdrop = true;\r\nret = !ret;\r\ngoto out;\r\n}\r\nif (info->check_set & XT_RECENT_SET)\r\nret = !ret;\r\nelse if (info->check_set & XT_RECENT_REMOVE) {\r\nrecent_entry_remove(t, e);\r\nret = !ret;\r\n} else if (info->check_set & (XT_RECENT_CHECK | XT_RECENT_UPDATE)) {\r\nunsigned long time = jiffies - info->seconds * HZ;\r\nunsigned int i, hits = 0;\r\nfor (i = 0; i < e->nstamps; i++) {\r\nif (info->seconds && time_after(time, e->stamps[i]))\r\ncontinue;\r\nif (!info->hit_count || ++hits >= info->hit_count) {\r\nret = !ret;\r\nbreak;\r\n}\r\n}\r\nif (info->check_set & XT_RECENT_REAP)\r\nrecent_entry_reap(t, time);\r\n}\r\nif (info->check_set & XT_RECENT_SET ||\r\n(info->check_set & XT_RECENT_UPDATE && ret)) {\r\nrecent_entry_update(t, e);\r\ne->ttl = ttl;\r\n}\r\nout:\r\nspin_unlock_bh(&recent_lock);\r\nreturn ret;\r\n}\r\nstatic void recent_table_free(void *addr)\r\n{\r\nkvfree(addr);\r\n}\r\nstatic int recent_mt_check(const struct xt_mtchk_param *par,\r\nconst struct xt_recent_mtinfo_v1 *info)\r\n{\r\nstruct recent_net *recent_net = recent_pernet(par->net);\r\nstruct recent_table *t;\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *pde;\r\nkuid_t uid;\r\nkgid_t gid;\r\n#endif\r\nunsigned int nstamp_mask;\r\nunsigned int i;\r\nint ret = -EINVAL;\r\nsize_t sz;\r\nif (unlikely(!hash_rnd_inited)) {\r\nget_random_bytes(&hash_rnd, sizeof(hash_rnd));\r\nhash_rnd_inited = true;\r\n}\r\nif (info->check_set & ~XT_RECENT_VALID_FLAGS) {\r\npr_info("Unsupported user space flags (%08x)\n",\r\ninfo->check_set);\r\nreturn -EINVAL;\r\n}\r\nif (hweight8(info->check_set &\r\n(XT_RECENT_SET | XT_RECENT_REMOVE |\r\nXT_RECENT_CHECK | XT_RECENT_UPDATE)) != 1)\r\nreturn -EINVAL;\r\nif ((info->check_set & (XT_RECENT_SET | XT_RECENT_REMOVE)) &&\r\n(info->seconds || info->hit_count ||\r\n(info->check_set & XT_RECENT_MODIFIERS)))\r\nreturn -EINVAL;\r\nif ((info->check_set & XT_RECENT_REAP) && !info->seconds)\r\nreturn -EINVAL;\r\nif (info->hit_count >= XT_RECENT_MAX_NSTAMPS) {\r\npr_info("hitcount (%u) is larger than allowed maximum (%u)\n",\r\ninfo->hit_count, XT_RECENT_MAX_NSTAMPS - 1);\r\nreturn -EINVAL;\r\n}\r\nif (info->name[0] == '\0' ||\r\nstrnlen(info->name, XT_RECENT_NAME_LEN) == XT_RECENT_NAME_LEN)\r\nreturn -EINVAL;\r\nif (ip_pkt_list_tot && info->hit_count < ip_pkt_list_tot)\r\nnstamp_mask = roundup_pow_of_two(ip_pkt_list_tot) - 1;\r\nelse if (info->hit_count)\r\nnstamp_mask = roundup_pow_of_two(info->hit_count) - 1;\r\nelse\r\nnstamp_mask = 32 - 1;\r\nmutex_lock(&recent_mutex);\r\nt = recent_table_lookup(recent_net, info->name);\r\nif (t != NULL) {\r\nif (nstamp_mask > t->nstamps_max_mask) {\r\nspin_lock_bh(&recent_lock);\r\nrecent_table_flush(t);\r\nt->nstamps_max_mask = nstamp_mask;\r\nspin_unlock_bh(&recent_lock);\r\n}\r\nt->refcnt++;\r\nret = 0;\r\ngoto out;\r\n}\r\nsz = sizeof(*t) + sizeof(t->iphash[0]) * ip_list_hash_size;\r\nif (sz <= PAGE_SIZE)\r\nt = kzalloc(sz, GFP_KERNEL);\r\nelse\r\nt = vzalloc(sz);\r\nif (t == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nt->refcnt = 1;\r\nt->nstamps_max_mask = nstamp_mask;\r\nmemcpy(&t->mask, &info->mask, sizeof(t->mask));\r\nstrcpy(t->name, info->name);\r\nINIT_LIST_HEAD(&t->lru_list);\r\nfor (i = 0; i < ip_list_hash_size; i++)\r\nINIT_LIST_HEAD(&t->iphash[i]);\r\n#ifdef CONFIG_PROC_FS\r\nuid = make_kuid(&init_user_ns, ip_list_uid);\r\ngid = make_kgid(&init_user_ns, ip_list_gid);\r\nif (!uid_valid(uid) || !gid_valid(gid)) {\r\nrecent_table_free(t);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npde = proc_create_data(t->name, ip_list_perms, recent_net->xt_recent,\r\n&recent_mt_fops, t);\r\nif (pde == NULL) {\r\nrecent_table_free(t);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nproc_set_user(pde, uid, gid);\r\n#endif\r\nspin_lock_bh(&recent_lock);\r\nlist_add_tail(&t->list, &recent_net->tables);\r\nspin_unlock_bh(&recent_lock);\r\nret = 0;\r\nout:\r\nmutex_unlock(&recent_mutex);\r\nreturn ret;\r\n}\r\nstatic int recent_mt_check_v0(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_recent_mtinfo_v0 *info_v0 = par->matchinfo;\r\nstruct xt_recent_mtinfo_v1 info_v1;\r\nmemcpy(&info_v1, info_v0, sizeof(struct xt_recent_mtinfo));\r\nmemset(info_v1.mask.all, 0xFF, sizeof(info_v1.mask.all));\r\nreturn recent_mt_check(par, &info_v1);\r\n}\r\nstatic int recent_mt_check_v1(const struct xt_mtchk_param *par)\r\n{\r\nreturn recent_mt_check(par, par->matchinfo);\r\n}\r\nstatic void recent_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nstruct recent_net *recent_net = recent_pernet(par->net);\r\nconst struct xt_recent_mtinfo_v1 *info = par->matchinfo;\r\nstruct recent_table *t;\r\nmutex_lock(&recent_mutex);\r\nt = recent_table_lookup(recent_net, info->name);\r\nif (--t->refcnt == 0) {\r\nspin_lock_bh(&recent_lock);\r\nlist_del(&t->list);\r\nspin_unlock_bh(&recent_lock);\r\n#ifdef CONFIG_PROC_FS\r\nif (recent_net->xt_recent != NULL)\r\nremove_proc_entry(t->name, recent_net->xt_recent);\r\n#endif\r\nrecent_table_flush(t);\r\nrecent_table_free(t);\r\n}\r\nmutex_unlock(&recent_mutex);\r\n}\r\nstatic void *recent_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(recent_lock)\r\n{\r\nstruct recent_iter_state *st = seq->private;\r\nconst struct recent_table *t = st->table;\r\nstruct recent_entry *e;\r\nloff_t p = *pos;\r\nspin_lock_bh(&recent_lock);\r\nfor (st->bucket = 0; st->bucket < ip_list_hash_size; st->bucket++)\r\nlist_for_each_entry(e, &t->iphash[st->bucket], list)\r\nif (p-- == 0)\r\nreturn e;\r\nreturn NULL;\r\n}\r\nstatic void *recent_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct recent_iter_state *st = seq->private;\r\nconst struct recent_table *t = st->table;\r\nconst struct recent_entry *e = v;\r\nconst struct list_head *head = e->list.next;\r\nwhile (head == &t->iphash[st->bucket]) {\r\nif (++st->bucket >= ip_list_hash_size)\r\nreturn NULL;\r\nhead = t->iphash[st->bucket].next;\r\n}\r\n(*pos)++;\r\nreturn list_entry(head, struct recent_entry, list);\r\n}\r\nstatic void recent_seq_stop(struct seq_file *s, void *v)\r\n__releases(recent_lock)\r\n{\r\nspin_unlock_bh(&recent_lock);\r\n}\r\nstatic int recent_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct recent_entry *e = v;\r\nstruct recent_iter_state *st = seq->private;\r\nconst struct recent_table *t = st->table;\r\nunsigned int i;\r\ni = (e->index - 1) & t->nstamps_max_mask;\r\nif (e->family == NFPROTO_IPV4)\r\nseq_printf(seq, "src=%pI4 ttl: %u last_seen: %lu oldest_pkt: %u",\r\n&e->addr.ip, e->ttl, e->stamps[i], e->index);\r\nelse\r\nseq_printf(seq, "src=%pI6 ttl: %u last_seen: %lu oldest_pkt: %u",\r\n&e->addr.in6, e->ttl, e->stamps[i], e->index);\r\nfor (i = 0; i < e->nstamps; i++)\r\nseq_printf(seq, "%s %lu", i ? "," : "", e->stamps[i]);\r\nseq_printf(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int recent_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct recent_iter_state *st;\r\nst = __seq_open_private(file, &recent_seq_ops, sizeof(*st));\r\nif (st == NULL)\r\nreturn -ENOMEM;\r\nst->table = PDE_DATA(inode);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nrecent_mt_proc_write(struct file *file, const char __user *input,\r\nsize_t size, loff_t *loff)\r\n{\r\nstruct recent_table *t = PDE_DATA(file_inode(file));\r\nstruct recent_entry *e;\r\nchar buf[sizeof("+b335:1d35:1e55:dead:c0de:1715:5afe:c0de")];\r\nconst char *c = buf;\r\nunion nf_inet_addr addr = {};\r\nu_int16_t family;\r\nbool add, succ;\r\nif (size == 0)\r\nreturn 0;\r\nif (size > sizeof(buf))\r\nsize = sizeof(buf);\r\nif (copy_from_user(buf, input, size) != 0)\r\nreturn -EFAULT;\r\nif (*loff != 0)\r\nreturn -ESPIPE;\r\nswitch (*c) {\r\ncase '/':\r\nspin_lock_bh(&recent_lock);\r\nrecent_table_flush(t);\r\nspin_unlock_bh(&recent_lock);\r\nreturn size;\r\ncase '-':\r\nadd = false;\r\nbreak;\r\ncase '+':\r\nadd = true;\r\nbreak;\r\ndefault:\r\npr_info("Need \"+ip\", \"-ip\" or \"/\"\n");\r\nreturn -EINVAL;\r\n}\r\n++c;\r\n--size;\r\nif (strnchr(c, size, ':') != NULL) {\r\nfamily = NFPROTO_IPV6;\r\nsucc = in6_pton(c, size, (void *)&addr, '\n', NULL);\r\n} else {\r\nfamily = NFPROTO_IPV4;\r\nsucc = in4_pton(c, size, (void *)&addr, '\n', NULL);\r\n}\r\nif (!succ) {\r\npr_info("illegal address written to procfs\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&recent_lock);\r\ne = recent_entry_lookup(t, &addr, family, 0);\r\nif (e == NULL) {\r\nif (add)\r\nrecent_entry_init(t, &addr, family, 0);\r\n} else {\r\nif (add)\r\nrecent_entry_update(t, e);\r\nelse\r\nrecent_entry_remove(t, e);\r\n}\r\nspin_unlock_bh(&recent_lock);\r\n*loff += size + 1;\r\nreturn size + 1;\r\n}\r\nstatic int __net_init recent_proc_net_init(struct net *net)\r\n{\r\nstruct recent_net *recent_net = recent_pernet(net);\r\nrecent_net->xt_recent = proc_mkdir("xt_recent", net->proc_net);\r\nif (!recent_net->xt_recent)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit recent_proc_net_exit(struct net *net)\r\n{\r\nstruct recent_net *recent_net = recent_pernet(net);\r\nstruct recent_table *t;\r\nspin_lock_bh(&recent_lock);\r\nlist_for_each_entry(t, &recent_net->tables, list)\r\nremove_proc_entry(t->name, recent_net->xt_recent);\r\nrecent_net->xt_recent = NULL;\r\nspin_unlock_bh(&recent_lock);\r\nremove_proc_entry("xt_recent", net->proc_net);\r\n}\r\nstatic inline int recent_proc_net_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void recent_proc_net_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init recent_net_init(struct net *net)\r\n{\r\nstruct recent_net *recent_net = recent_pernet(net);\r\nINIT_LIST_HEAD(&recent_net->tables);\r\nreturn recent_proc_net_init(net);\r\n}\r\nstatic void __net_exit recent_net_exit(struct net *net)\r\n{\r\nrecent_proc_net_exit(net);\r\n}\r\nstatic int __init recent_mt_init(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XT_RECENT_MAX_NSTAMPS);\r\nif (!ip_list_tot || ip_pkt_list_tot >= XT_RECENT_MAX_NSTAMPS)\r\nreturn -EINVAL;\r\nip_list_hash_size = 1 << fls(ip_list_tot);\r\nerr = register_pernet_subsys(&recent_net_ops);\r\nif (err)\r\nreturn err;\r\nerr = xt_register_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));\r\nif (err)\r\nunregister_pernet_subsys(&recent_net_ops);\r\nreturn err;\r\n}\r\nstatic void __exit recent_mt_exit(void)\r\n{\r\nxt_unregister_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));\r\nunregister_pernet_subsys(&recent_net_ops);\r\n}
