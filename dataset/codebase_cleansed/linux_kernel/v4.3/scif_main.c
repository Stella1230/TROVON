static void scif_intr_bh_handler(struct work_struct *work)\r\n{\r\nstruct scif_dev *scifdev =\r\ncontainer_of(work, struct scif_dev, intr_bh);\r\nif (scifdev_self(scifdev))\r\nscif_loopb_msg_handler(scifdev, scifdev->qpairs);\r\nelse\r\nscif_nodeqp_intrhandler(scifdev, scifdev->qpairs);\r\n}\r\nint scif_setup_intr_wq(struct scif_dev *scifdev)\r\n{\r\nif (!scifdev->intr_wq) {\r\nsnprintf(scifdev->intr_wqname, sizeof(scifdev->intr_wqname),\r\n"SCIF INTR %d", scifdev->node);\r\nscifdev->intr_wq =\r\nalloc_ordered_workqueue(scifdev->intr_wqname, 0);\r\nif (!scifdev->intr_wq)\r\nreturn -ENOMEM;\r\nINIT_WORK(&scifdev->intr_bh, scif_intr_bh_handler);\r\n}\r\nreturn 0;\r\n}\r\nvoid scif_destroy_intr_wq(struct scif_dev *scifdev)\r\n{\r\nif (scifdev->intr_wq) {\r\ndestroy_workqueue(scifdev->intr_wq);\r\nscifdev->intr_wq = NULL;\r\n}\r\n}\r\nirqreturn_t scif_intr_handler(int irq, void *data)\r\n{\r\nstruct scif_dev *scifdev = data;\r\nstruct scif_hw_dev *sdev = scifdev->sdev;\r\nsdev->hw_ops->ack_interrupt(sdev, scifdev->db);\r\nqueue_work(scifdev->intr_wq, &scifdev->intr_bh);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int scif_peer_probe(struct scif_peer_dev *spdev)\r\n{\r\nstruct scif_dev *scifdev = &scif_dev[spdev->dnode];\r\nmutex_lock(&scif_info.conflock);\r\nscif_info.total++;\r\nscif_info.maxid = max_t(u32, spdev->dnode, scif_info.maxid);\r\nmutex_unlock(&scif_info.conflock);\r\nrcu_assign_pointer(scifdev->spdev, spdev);\r\nreturn 0;\r\n}\r\nstatic void scif_peer_remove(struct scif_peer_dev *spdev)\r\n{\r\nstruct scif_dev *scifdev = &scif_dev[spdev->dnode];\r\nspdev = rcu_dereference(scifdev->spdev);\r\nif (spdev)\r\nRCU_INIT_POINTER(scifdev->spdev, NULL);\r\nsynchronize_rcu();\r\nmutex_lock(&scif_info.conflock);\r\nscif_info.total--;\r\nmutex_unlock(&scif_info.conflock);\r\n}\r\nstatic void scif_qp_setup_handler(struct work_struct *work)\r\n{\r\nstruct scif_dev *scifdev = container_of(work, struct scif_dev,\r\nqp_dwork.work);\r\nstruct scif_hw_dev *sdev = scifdev->sdev;\r\ndma_addr_t da = 0;\r\nint err;\r\nif (scif_is_mgmt_node()) {\r\nstruct mic_bootparam *bp = sdev->dp;\r\nda = bp->scif_card_dma_addr;\r\nscifdev->rdb = bp->h2c_scif_db;\r\n} else {\r\nstruct mic_bootparam __iomem *bp = sdev->rdp;\r\nda = readq(&bp->scif_host_dma_addr);\r\nscifdev->rdb = ioread8(&bp->c2h_scif_db);\r\n}\r\nif (da) {\r\nerr = scif_qp_response(da, scifdev);\r\nif (err)\r\ndev_err(&scifdev->sdev->dev,\r\n"scif_qp_response err %d\n", err);\r\n} else {\r\nschedule_delayed_work(&scifdev->qp_dwork,\r\nmsecs_to_jiffies(1000));\r\n}\r\n}\r\nstatic int scif_setup_scifdev(struct scif_hw_dev *sdev)\r\n{\r\nint i;\r\nu8 num_nodes;\r\nif (sdev->snode) {\r\nstruct mic_bootparam __iomem *bp = sdev->rdp;\r\nnum_nodes = ioread8(&bp->tot_nodes);\r\n} else {\r\nstruct mic_bootparam *bp = sdev->dp;\r\nnum_nodes = bp->tot_nodes;\r\n}\r\nscif_dev = kcalloc(num_nodes, sizeof(*scif_dev), GFP_KERNEL);\r\nif (!scif_dev)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_nodes; i++) {\r\nstruct scif_dev *scifdev = &scif_dev[i];\r\nscifdev->node = i;\r\nscifdev->exit = OP_IDLE;\r\ninit_waitqueue_head(&scifdev->disconn_wq);\r\nmutex_init(&scifdev->lock);\r\nINIT_WORK(&scifdev->init_msg_work, scif_qp_response_ack);\r\nINIT_DELAYED_WORK(&scifdev->p2p_dwork,\r\nscif_poll_qp_state);\r\nINIT_DELAYED_WORK(&scifdev->qp_dwork,\r\nscif_qp_setup_handler);\r\nINIT_LIST_HEAD(&scifdev->p2p);\r\nRCU_INIT_POINTER(scifdev->spdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void scif_destroy_scifdev(void)\r\n{\r\nkfree(scif_dev);\r\n}\r\nstatic int scif_probe(struct scif_hw_dev *sdev)\r\n{\r\nstruct scif_dev *scifdev;\r\nint rc;\r\ndev_set_drvdata(&sdev->dev, sdev);\r\nif (1 == atomic_add_return(1, &g_loopb_cnt)) {\r\nstruct scif_dev *loopb_dev;\r\nrc = scif_setup_scifdev(sdev);\r\nif (rc)\r\ngoto exit;\r\nscifdev = &scif_dev[sdev->dnode];\r\nscifdev->sdev = sdev;\r\nloopb_dev = &scif_dev[sdev->snode];\r\nloopb_dev->sdev = sdev;\r\nrc = scif_setup_loopback_qp(loopb_dev);\r\nif (rc)\r\ngoto free_sdev;\r\n} else {\r\nscifdev = &scif_dev[sdev->dnode];\r\nscifdev->sdev = sdev;\r\n}\r\nrc = scif_setup_intr_wq(scifdev);\r\nif (rc)\r\ngoto destroy_loopb;\r\nrc = scif_setup_qp(scifdev);\r\nif (rc)\r\ngoto destroy_intr;\r\nscifdev->db = sdev->hw_ops->next_db(sdev);\r\nscifdev->cookie = sdev->hw_ops->request_irq(sdev, scif_intr_handler,\r\n"SCIF_INTR", scifdev,\r\nscifdev->db);\r\nif (IS_ERR(scifdev->cookie)) {\r\nrc = PTR_ERR(scifdev->cookie);\r\ngoto free_qp;\r\n}\r\nif (scif_is_mgmt_node()) {\r\nstruct mic_bootparam *bp = sdev->dp;\r\nbp->c2h_scif_db = scifdev->db;\r\nbp->scif_host_dma_addr = scifdev->qp_dma_addr;\r\n} else {\r\nstruct mic_bootparam __iomem *bp = sdev->rdp;\r\niowrite8(scifdev->db, &bp->h2c_scif_db);\r\nwriteq(scifdev->qp_dma_addr, &bp->scif_card_dma_addr);\r\n}\r\nschedule_delayed_work(&scifdev->qp_dwork,\r\nmsecs_to_jiffies(1000));\r\nreturn rc;\r\nfree_qp:\r\nscif_free_qp(scifdev);\r\ndestroy_intr:\r\nscif_destroy_intr_wq(scifdev);\r\ndestroy_loopb:\r\nif (atomic_dec_and_test(&g_loopb_cnt))\r\nscif_destroy_loopback_qp(&scif_dev[sdev->snode]);\r\nfree_sdev:\r\nscif_destroy_scifdev();\r\nexit:\r\nreturn rc;\r\n}\r\nvoid scif_stop(struct scif_dev *scifdev)\r\n{\r\nstruct scif_dev *dev;\r\nint i;\r\nfor (i = scif_info.maxid; i >= 0; i--) {\r\ndev = &scif_dev[i];\r\nif (scifdev_self(dev))\r\ncontinue;\r\nscif_handle_remove_node(i);\r\n}\r\n}\r\nstatic void scif_remove(struct scif_hw_dev *sdev)\r\n{\r\nstruct scif_dev *scifdev = &scif_dev[sdev->dnode];\r\nif (scif_is_mgmt_node()) {\r\nstruct mic_bootparam *bp = sdev->dp;\r\nbp->c2h_scif_db = -1;\r\nbp->scif_host_dma_addr = 0x0;\r\n} else {\r\nstruct mic_bootparam __iomem *bp = sdev->rdp;\r\niowrite8(-1, &bp->h2c_scif_db);\r\nwriteq(0x0, &bp->scif_card_dma_addr);\r\n}\r\nif (scif_is_mgmt_node()) {\r\nscif_disconnect_node(scifdev->node, true);\r\n} else {\r\nscif_info.card_initiated_exit = true;\r\nscif_stop(scifdev);\r\n}\r\nif (atomic_dec_and_test(&g_loopb_cnt))\r\nscif_destroy_loopback_qp(&scif_dev[sdev->snode]);\r\nif (scifdev->cookie) {\r\nsdev->hw_ops->free_irq(sdev, scifdev->cookie, scifdev);\r\nscifdev->cookie = NULL;\r\n}\r\nscif_destroy_intr_wq(scifdev);\r\ncancel_delayed_work(&scifdev->qp_dwork);\r\nscif_free_qp(scifdev);\r\nscifdev->rdb = -1;\r\nscifdev->sdev = NULL;\r\n}\r\nstatic int _scif_init(void)\r\n{\r\nspin_lock_init(&scif_info.eplock);\r\nspin_lock_init(&scif_info.nb_connect_lock);\r\nspin_lock_init(&scif_info.port_lock);\r\nmutex_init(&scif_info.conflock);\r\nmutex_init(&scif_info.connlock);\r\nINIT_LIST_HEAD(&scif_info.uaccept);\r\nINIT_LIST_HEAD(&scif_info.listen);\r\nINIT_LIST_HEAD(&scif_info.zombie);\r\nINIT_LIST_HEAD(&scif_info.connected);\r\nINIT_LIST_HEAD(&scif_info.disconnected);\r\nINIT_LIST_HEAD(&scif_info.nb_connect_list);\r\ninit_waitqueue_head(&scif_info.exitwq);\r\nscif_info.en_msg_log = 0;\r\nscif_info.p2p_enable = 1;\r\nINIT_WORK(&scif_info.misc_work, scif_misc_handler);\r\nINIT_WORK(&scif_info.conn_work, scif_conn_handler);\r\nidr_init(&scif_ports);\r\nreturn 0;\r\n}\r\nstatic void _scif_exit(void)\r\n{\r\nidr_destroy(&scif_ports);\r\nscif_destroy_scifdev();\r\n}\r\nstatic int __init scif_init(void)\r\n{\r\nstruct miscdevice *mdev = &scif_info.mdev;\r\nint rc;\r\n_scif_init();\r\nrc = scif_peer_bus_init();\r\nif (rc)\r\ngoto exit;\r\nrc = scif_peer_register_driver(&scif_peer_driver);\r\nif (rc)\r\ngoto peer_bus_exit;\r\nrc = scif_register_driver(&scif_driver);\r\nif (rc)\r\ngoto unreg_scif_peer;\r\nrc = misc_register(mdev);\r\nif (rc)\r\ngoto unreg_scif;\r\nscif_init_debugfs();\r\nreturn 0;\r\nunreg_scif:\r\nscif_unregister_driver(&scif_driver);\r\nunreg_scif_peer:\r\nscif_peer_unregister_driver(&scif_peer_driver);\r\npeer_bus_exit:\r\nscif_peer_bus_exit();\r\nexit:\r\n_scif_exit();\r\nreturn rc;\r\n}\r\nstatic void __exit scif_exit(void)\r\n{\r\nscif_exit_debugfs();\r\nmisc_deregister(&scif_info.mdev);\r\nscif_unregister_driver(&scif_driver);\r\nscif_peer_unregister_driver(&scif_peer_driver);\r\nscif_peer_bus_exit();\r\n_scif_exit();\r\n}
