static inline unsigned IOConfigReg(unsigned pfi_channel)\r\n{\r\nunsigned reg = NI660X_IO_CFG_0_1 + pfi_channel / 2;\r\nBUG_ON(reg > NI660X_IO_CFG_38_39);\r\nreturn reg;\r\n}\r\nstatic inline unsigned NI_660X_GPCT_SUBDEV(unsigned index)\r\n{\r\nreturn NI_660X_GPCT_SUBDEV_0 + index;\r\n}\r\nstatic inline unsigned ioconfig_bitshift(unsigned pfi_channel)\r\n{\r\nreturn (pfi_channel % 2) ? 0 : 8;\r\n}\r\nstatic inline unsigned pfi_output_select_mask(unsigned pfi_channel)\r\n{\r\nreturn 0x3 << ioconfig_bitshift(pfi_channel);\r\n}\r\nstatic inline unsigned pfi_output_select_bits(unsigned pfi_channel,\r\nunsigned output_select)\r\n{\r\nreturn (output_select & 0x3) << ioconfig_bitshift(pfi_channel);\r\n}\r\nstatic inline unsigned pfi_input_select_mask(unsigned pfi_channel)\r\n{\r\nreturn 0x7 << (4 + ioconfig_bitshift(pfi_channel));\r\n}\r\nstatic inline unsigned pfi_input_select_bits(unsigned pfi_channel,\r\nunsigned input_select)\r\n{\r\nreturn (input_select & 0x7) << (4 + ioconfig_bitshift(pfi_channel));\r\n}\r\nstatic inline unsigned dma_select_mask(unsigned dma_channel)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn 0x1f << (8 * dma_channel);\r\n}\r\nstatic inline unsigned dma_select_bits(unsigned dma_channel, unsigned selection)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn (selection << (8 * dma_channel)) & dma_select_mask(dma_channel);\r\n}\r\nstatic inline unsigned dma_reset_bit(unsigned dma_channel)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn 0x80 << (8 * dma_channel);\r\n}\r\nstatic inline unsigned ni_660x_num_counters(struct comedi_device *dev)\r\n{\r\nconst struct ni_660x_board *board = dev->board_ptr;\r\nreturn board->n_chips * counters_per_chip;\r\n}\r\nstatic enum ni_660x_register ni_gpct_to_660x_register(enum ni_gpct_register reg)\r\n{\r\nswitch (reg) {\r\ncase NITIO_G0_AUTO_INC:\r\nreturn NI660X_G0_AUTO_INC;\r\ncase NITIO_G1_AUTO_INC:\r\nreturn NI660X_G1_AUTO_INC;\r\ncase NITIO_G2_AUTO_INC:\r\nreturn NI660X_G2_AUTO_INC;\r\ncase NITIO_G3_AUTO_INC:\r\nreturn NI660X_G3_AUTO_INC;\r\ncase NITIO_G0_CMD:\r\nreturn NI660X_G0_CMD;\r\ncase NITIO_G1_CMD:\r\nreturn NI660X_G1_CMD;\r\ncase NITIO_G2_CMD:\r\nreturn NI660X_G2_CMD;\r\ncase NITIO_G3_CMD:\r\nreturn NI660X_G3_CMD;\r\ncase NITIO_G0_HW_SAVE:\r\nreturn NI660X_G0_HW_SAVE;\r\ncase NITIO_G1_HW_SAVE:\r\nreturn NI660X_G1_HW_SAVE;\r\ncase NITIO_G2_HW_SAVE:\r\nreturn NI660X_G2_HW_SAVE;\r\ncase NITIO_G3_HW_SAVE:\r\nreturn NI660X_G3_HW_SAVE;\r\ncase NITIO_G0_SW_SAVE:\r\nreturn NI660X_G0_SW_SAVE;\r\ncase NITIO_G1_SW_SAVE:\r\nreturn NI660X_G1_SW_SAVE;\r\ncase NITIO_G2_SW_SAVE:\r\nreturn NI660X_G2_SW_SAVE;\r\ncase NITIO_G3_SW_SAVE:\r\nreturn NI660X_G3_SW_SAVE;\r\ncase NITIO_G0_MODE:\r\nreturn NI660X_G0_MODE;\r\ncase NITIO_G1_MODE:\r\nreturn NI660X_G1_MODE;\r\ncase NITIO_G2_MODE:\r\nreturn NI660X_G2_MODE;\r\ncase NITIO_G3_MODE:\r\nreturn NI660X_G3_MODE;\r\ncase NITIO_G0_LOADA:\r\nreturn NI660X_G0_LOADA;\r\ncase NITIO_G1_LOADA:\r\nreturn NI660X_G1_LOADA;\r\ncase NITIO_G2_LOADA:\r\nreturn NI660X_G2_LOADA;\r\ncase NITIO_G3_LOADA:\r\nreturn NI660X_G3_LOADA;\r\ncase NITIO_G0_LOADB:\r\nreturn NI660X_G0_LOADB;\r\ncase NITIO_G1_LOADB:\r\nreturn NI660X_G1_LOADB;\r\ncase NITIO_G2_LOADB:\r\nreturn NI660X_G2_LOADB;\r\ncase NITIO_G3_LOADB:\r\nreturn NI660X_G3_LOADB;\r\ncase NITIO_G0_INPUT_SEL:\r\nreturn NI660X_G0_INPUT_SEL;\r\ncase NITIO_G1_INPUT_SEL:\r\nreturn NI660X_G1_INPUT_SEL;\r\ncase NITIO_G2_INPUT_SEL:\r\nreturn NI660X_G2_INPUT_SEL;\r\ncase NITIO_G3_INPUT_SEL:\r\nreturn NI660X_G3_INPUT_SEL;\r\ncase NITIO_G01_STATUS:\r\nreturn NI660X_G01_STATUS;\r\ncase NITIO_G23_STATUS:\r\nreturn NI660X_G23_STATUS;\r\ncase NITIO_G01_RESET:\r\nreturn NI660X_G01_RESET;\r\ncase NITIO_G23_RESET:\r\nreturn NI660X_G23_RESET;\r\ncase NITIO_G01_STATUS1:\r\nreturn NI660X_G01_STATUS1;\r\ncase NITIO_G23_STATUS1:\r\nreturn NI660X_G23_STATUS1;\r\ncase NITIO_G01_STATUS2:\r\nreturn NI660X_G01_STATUS2;\r\ncase NITIO_G23_STATUS2:\r\nreturn NI660X_G23_STATUS2;\r\ncase NITIO_G0_CNT_MODE:\r\nreturn NI660X_G0_CNT_MODE;\r\ncase NITIO_G1_CNT_MODE:\r\nreturn NI660X_G1_CNT_MODE;\r\ncase NITIO_G2_CNT_MODE:\r\nreturn NI660X_G2_CNT_MODE;\r\ncase NITIO_G3_CNT_MODE:\r\nreturn NI660X_G3_CNT_MODE;\r\ncase NITIO_G0_GATE2:\r\nreturn NI660X_G0_GATE2;\r\ncase NITIO_G1_GATE2:\r\nreturn NI660X_G1_GATE2;\r\ncase NITIO_G2_GATE2:\r\nreturn NI660X_G2_GATE2;\r\ncase NITIO_G3_GATE2:\r\nreturn NI660X_G3_GATE2;\r\ncase NITIO_G0_DMA_CFG:\r\nreturn NI660X_G0_DMA_CFG;\r\ncase NITIO_G0_DMA_STATUS:\r\nreturn NI660X_G0_DMA_STATUS;\r\ncase NITIO_G1_DMA_CFG:\r\nreturn NI660X_G1_DMA_CFG;\r\ncase NITIO_G1_DMA_STATUS:\r\nreturn NI660X_G1_DMA_STATUS;\r\ncase NITIO_G2_DMA_CFG:\r\nreturn NI660X_G2_DMA_CFG;\r\ncase NITIO_G2_DMA_STATUS:\r\nreturn NI660X_G2_DMA_STATUS;\r\ncase NITIO_G3_DMA_CFG:\r\nreturn NI660X_G3_DMA_CFG;\r\ncase NITIO_G3_DMA_STATUS:\r\nreturn NI660X_G3_DMA_STATUS;\r\ncase NITIO_G0_INT_ACK:\r\nreturn NI660X_G0_INT_ACK;\r\ncase NITIO_G1_INT_ACK:\r\nreturn NI660X_G1_INT_ACK;\r\ncase NITIO_G2_INT_ACK:\r\nreturn NI660X_G2_INT_ACK;\r\ncase NITIO_G3_INT_ACK:\r\nreturn NI660X_G3_INT_ACK;\r\ncase NITIO_G0_STATUS:\r\nreturn NI660X_G0_STATUS;\r\ncase NITIO_G1_STATUS:\r\nreturn NI660X_G1_STATUS;\r\ncase NITIO_G2_STATUS:\r\nreturn NI660X_G2_STATUS;\r\ncase NITIO_G3_STATUS:\r\nreturn NI660X_G3_STATUS;\r\ncase NITIO_G0_INT_ENA:\r\nreturn NI660X_G0_INT_ENA;\r\ncase NITIO_G1_INT_ENA:\r\nreturn NI660X_G1_INT_ENA;\r\ncase NITIO_G2_INT_ENA:\r\nreturn NI660X_G2_INT_ENA;\r\ncase NITIO_G3_INT_ENA:\r\nreturn NI660X_G3_INT_ENA;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void ni_660x_write_register(struct comedi_device *dev,\r\nunsigned chip, unsigned bits,\r\nenum ni_660x_register reg)\r\n{\r\nunsigned int addr = GPCT_OFFSET[chip] + registerData[reg].offset;\r\nswitch (registerData[reg].size) {\r\ncase DATA_2B:\r\nwritew(bits, dev->mmio + addr);\r\nbreak;\r\ncase DATA_4B:\r\nwritel(bits, dev->mmio + addr);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic inline unsigned ni_660x_read_register(struct comedi_device *dev,\r\nunsigned chip,\r\nenum ni_660x_register reg)\r\n{\r\nunsigned int addr = GPCT_OFFSET[chip] + registerData[reg].offset;\r\nswitch (registerData[reg].size) {\r\ncase DATA_2B:\r\nreturn readw(dev->mmio + addr);\r\ncase DATA_4B:\r\nreturn readl(dev->mmio + addr);\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nenum ni_660x_register ni_660x_register = ni_gpct_to_660x_register(reg);\r\nunsigned chip = counter->chip_index;\r\nni_660x_write_register(dev, chip, bits, ni_660x_register);\r\n}\r\nstatic unsigned ni_gpct_read_register(struct ni_gpct *counter,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nenum ni_660x_register ni_660x_register = ni_gpct_to_660x_register(reg);\r\nunsigned chip = counter->chip_index;\r\nreturn ni_660x_read_register(dev, chip, ni_660x_register);\r\n}\r\nstatic inline struct mite_dma_descriptor_ring *mite_ring(struct ni_660x_private\r\n*priv,\r\nstruct ni_gpct\r\n*counter)\r\n{\r\nunsigned chip = counter->chip_index;\r\nreturn priv->mite_rings[chip][counter->counter_index];\r\n}\r\nstatic inline void ni_660x_set_dma_channel(struct comedi_device *dev,\r\nunsigned mite_channel,\r\nstruct ni_gpct *counter)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned chip = counter->chip_index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\r\ndevpriv->dma_configuration_soft_copies[chip] &=\r\n~dma_select_mask(mite_channel);\r\ndevpriv->dma_configuration_soft_copies[chip] |=\r\ndma_select_bits(mite_channel, counter->counter_index);\r\nni_660x_write_register(dev, chip,\r\ndevpriv->dma_configuration_soft_copies[chip] |\r\ndma_reset_bit(mite_channel), NI660X_DMA_CFG);\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\r\n}\r\nstatic inline void ni_660x_unset_dma_channel(struct comedi_device *dev,\r\nunsigned mite_channel,\r\nstruct ni_gpct *counter)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned chip = counter->chip_index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\r\ndevpriv->dma_configuration_soft_copies[chip] &=\r\n~dma_select_mask(mite_channel);\r\ndevpriv->dma_configuration_soft_copies[chip] |=\r\ndma_select_bits(mite_channel, dma_selection_none);\r\nni_660x_write_register(dev, chip,\r\ndevpriv->dma_configuration_soft_copies[chip],\r\nNI660X_DMA_CFG);\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\r\n}\r\nstatic int ni_660x_request_mite_channel(struct comedi_device *dev,\r\nstruct ni_gpct *counter,\r\nenum comedi_io_direction direction)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned long flags;\r\nstruct mite_channel *mite_chan;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(counter->mite_chan);\r\nmite_chan = mite_request_channel(devpriv->mite,\r\nmite_ring(devpriv, counter));\r\nif (!mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev,\r\n"failed to reserve mite dma channel for counter\n");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = direction;\r\nni_tio_set_mite_channel(counter, mite_chan);\r\nni_660x_set_dma_channel(dev, mite_chan->channel, counter);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ni_660x_release_mite_channel(struct comedi_device *dev,\r\nstruct ni_gpct *counter)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (counter->mite_chan) {\r\nstruct mite_channel *mite_chan = counter->mite_chan;\r\nni_660x_unset_dma_channel(dev, mite_chan->channel, counter);\r\nni_tio_set_mite_channel(counter, NULL);\r\nmite_release_channel(mite_chan);\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic int ni_660x_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nint retval;\r\nretval = ni_660x_request_mite_channel(dev, counter, COMEDI_INPUT);\r\nif (retval) {\r\ndev_err(dev->class_dev,\r\n"no dma channel available for use by counter\n");\r\nreturn retval;\r\n}\r\nni_tio_acknowledge(counter);\r\nreturn ni_tio_cmd(dev, s);\r\n}\r\nstatic int ni_660x_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nint retval;\r\nretval = ni_tio_cancel(counter);\r\nni_660x_release_mite_channel(dev, counter);\r\nreturn retval;\r\n}\r\nstatic void set_tio_counterswap(struct comedi_device *dev, int chip)\r\n{\r\nunsigned bits = 0;\r\nif (chip)\r\nbits = CounterSwap;\r\nni_660x_write_register(dev, chip, bits, NI660X_CLK_CFG);\r\n}\r\nstatic void ni_660x_handle_gpct_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nni_tio_handle_interrupt(counter, s);\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic irqreturn_t ni_660x_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct ni_660x_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nunsigned i;\r\nunsigned long flags;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&devpriv->interrupt_lock, flags);\r\nsmp_mb();\r\nfor (i = 0; i < ni_660x_num_counters(dev); ++i) {\r\ns = &dev->subdevices[NI_660X_GPCT_SUBDEV(i)];\r\nni_660x_handle_gpct_interrupt(dev, s);\r\n}\r\nspin_unlock_irqrestore(&devpriv->interrupt_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ni_660x_input_poll(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nstruct ni_gpct *counter = s->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->interrupt_lock, flags);\r\nmite_sync_input_dma(counter->mite_chan, s);\r\nspin_unlock_irqrestore(&devpriv->interrupt_lock, flags);\r\nreturn comedi_buf_read_n_available(s);\r\n}\r\nstatic int ni_660x_buf_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nstruct ni_gpct *counter = s->private;\r\nint ret;\r\nret = mite_buf_change(mite_ring(devpriv, counter), s);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_allocate_private(struct comedi_device *dev)\r\n{\r\nstruct ni_660x_private *devpriv;\r\nunsigned i;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->mite_channel_lock);\r\nspin_lock_init(&devpriv->interrupt_lock);\r\nspin_lock_init(&devpriv->soft_reg_copy_lock);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i)\r\ndevpriv->pfi_output_selects[i] = pfi_output_select_counter;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_alloc_mite_rings(struct comedi_device *dev)\r\n{\r\nconst struct ni_660x_board *board = dev->board_ptr;\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned i;\r\nunsigned j;\r\nfor (i = 0; i < board->n_chips; ++i) {\r\nfor (j = 0; j < counters_per_chip; ++j) {\r\ndevpriv->mite_rings[i][j] =\r\nmite_alloc_ring(devpriv->mite);\r\nif (!devpriv->mite_rings[i][j])\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_660x_free_mite_rings(struct comedi_device *dev)\r\n{\r\nconst struct ni_660x_board *board = dev->board_ptr;\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned i;\r\nunsigned j;\r\nfor (i = 0; i < board->n_chips; ++i) {\r\nfor (j = 0; j < counters_per_chip; ++j)\r\nmite_free_ring(devpriv->mite_rings[i][j]);\r\n}\r\n}\r\nstatic void init_tio_chip(struct comedi_device *dev, int chipset)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned i;\r\ndevpriv->dma_configuration_soft_copies[chipset] = 0;\r\nfor (i = 0; i < MAX_DMA_CHANNEL; ++i) {\r\ndevpriv->dma_configuration_soft_copies[chipset] |=\r\ndma_select_bits(i, dma_selection_none) & dma_select_mask(i);\r\n}\r\nni_660x_write_register(dev, chipset,\r\ndevpriv->dma_configuration_soft_copies[chipset],\r\nNI660X_DMA_CFG);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i)\r\nni_660x_write_register(dev, chipset, 0, IOConfigReg(i));\r\n}\r\nstatic int ni_660x_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned base_bitfield_channel = CR_CHAN(insn->chanspec);\r\nif (data[0]) {\r\ns->state &= ~(data[0] << base_bitfield_channel);\r\ns->state |= (data[0] & data[1]) << base_bitfield_channel;\r\nni_660x_write_register(dev, 0, s->state, NI660X_DIO32_OUTPUT);\r\n}\r\ndata[1] = (ni_660x_read_register(dev, 0, NI660X_DIO32_INPUT) >>\r\nbase_bitfield_channel);\r\nreturn insn->n;\r\n}\r\nstatic void ni_660x_select_pfi_output(struct comedi_device *dev,\r\nunsigned pfi_channel,\r\nunsigned output_select)\r\n{\r\nconst struct ni_660x_board *board = dev->board_ptr;\r\nstatic const unsigned counter_4_7_first_pfi = 8;\r\nstatic const unsigned counter_4_7_last_pfi = 23;\r\nunsigned active_chipset = 0;\r\nunsigned idle_chipset = 0;\r\nunsigned active_bits;\r\nunsigned idle_bits;\r\nif (board->n_chips > 1) {\r\nif (output_select == pfi_output_select_counter &&\r\npfi_channel >= counter_4_7_first_pfi &&\r\npfi_channel <= counter_4_7_last_pfi) {\r\nactive_chipset = 1;\r\nidle_chipset = 0;\r\n} else {\r\nactive_chipset = 0;\r\nidle_chipset = 1;\r\n}\r\n}\r\nif (idle_chipset != active_chipset) {\r\nidle_bits =\r\nni_660x_read_register(dev, idle_chipset,\r\nIOConfigReg(pfi_channel));\r\nidle_bits &= ~pfi_output_select_mask(pfi_channel);\r\nidle_bits |=\r\npfi_output_select_bits(pfi_channel,\r\npfi_output_select_high_Z);\r\nni_660x_write_register(dev, idle_chipset, idle_bits,\r\nIOConfigReg(pfi_channel));\r\n}\r\nactive_bits =\r\nni_660x_read_register(dev, active_chipset,\r\nIOConfigReg(pfi_channel));\r\nactive_bits &= ~pfi_output_select_mask(pfi_channel);\r\nactive_bits |= pfi_output_select_bits(pfi_channel, output_select);\r\nni_660x_write_register(dev, active_chipset, active_bits,\r\nIOConfigReg(pfi_channel));\r\n}\r\nstatic int ni_660x_set_pfi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nif (source > num_pfi_output_selects)\r\nreturn -EINVAL;\r\nif (source == pfi_output_select_high_Z)\r\nreturn -EINVAL;\r\nif (chan < min_counter_pfi_chan) {\r\nif (source == pfi_output_select_counter)\r\nreturn -EINVAL;\r\n} else if (chan > max_dio_pfi_chan) {\r\nif (source == pfi_output_select_do)\r\nreturn -EINVAL;\r\n}\r\ndevpriv->pfi_output_selects[chan] = source;\r\nif (devpriv->pfi_direction_bits & (((uint64_t) 1) << chan))\r\nni_660x_select_pfi_output(dev, chan,\r\ndevpriv->pfi_output_selects[chan]);\r\nreturn 0;\r\n}\r\nstatic int ni_660x_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nuint64_t bit = 1ULL << chan;\r\nunsigned int val;\r\nint ret;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ndevpriv->pfi_direction_bits |= bit;\r\nni_660x_select_pfi_output(dev, chan,\r\ndevpriv->pfi_output_selects[chan]);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ndevpriv->pfi_direction_bits &= ~bit;\r\nni_660x_select_pfi_output(dev, chan, pfi_output_select_high_Z);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] = (devpriv->pfi_direction_bits & bit) ? COMEDI_OUTPUT\r\n: COMEDI_INPUT;\r\nbreak;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nret = ni_660x_set_pfi_routing(dev, chan, data[1]);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = devpriv->pfi_output_selects[chan];\r\nbreak;\r\ncase INSN_CONFIG_FILTER:\r\nval = ni_660x_read_register(dev, 0, IOConfigReg(chan));\r\nval &= ~pfi_input_select_mask(chan);\r\nval |= pfi_input_select_bits(chan, data[1]);\r\nni_660x_write_register(dev, 0, val, IOConfigReg(chan));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_660x_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct ni_660x_board *board = NULL;\r\nstruct ni_660x_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned i;\r\nunsigned global_interrupt_config_bits;\r\nif (context < ARRAY_SIZE(ni_660x_boards))\r\nboard = &ni_660x_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni_660x_allocate_private(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv = dev->private;\r\ndevpriv->mite = mite_alloc(pcidev);\r\nif (!devpriv->mite)\r\nreturn -ENOMEM;\r\nret = mite_setup2(dev, devpriv->mite, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ni_660x_alloc_mite_rings(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, 2 + NI_660X_MAX_NUM_COUNTERS);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = &dev->subdevices[NI_660X_DIO_SUBDEV];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = NUM_PFI_CHANNELS;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_660x_dio_insn_bits;\r\ns->insn_config = ni_660x_dio_insn_config;\r\nni_660x_write_register(dev, 0, 0, NI660X_STC_DIO_CONTROL);\r\ndevpriv->counter_dev = ni_gpct_device_construct(dev,\r\n&ni_gpct_write_register,\r\n&ni_gpct_read_register,\r\nni_gpct_variant_660x,\r\nni_660x_num_counters\r\n(dev));\r\nif (!devpriv->counter_dev)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NI_660X_MAX_NUM_COUNTERS; ++i) {\r\ns = &dev->subdevices[NI_660X_GPCT_SUBDEV(i)];\r\nif (i < ni_660x_num_counters(dev)) {\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE |\r\nSDF_LSAMPL | SDF_CMD_READ;\r\ns->n_chan = 3;\r\ns->maxdata = 0xffffffff;\r\ns->insn_read = ni_tio_insn_read;\r\ns->insn_write = ni_tio_insn_write;\r\ns->insn_config = ni_tio_insn_config;\r\ns->do_cmd = &ni_660x_cmd;\r\ns->len_chanlist = 1;\r\ns->do_cmdtest = ni_tio_cmdtest;\r\ns->cancel = &ni_660x_cancel;\r\ns->poll = &ni_660x_input_poll;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\ns->buf_change = &ni_660x_buf_change;\r\ns->private = &devpriv->counter_dev->counters[i];\r\ndevpriv->counter_dev->counters[i].chip_index =\r\ni / counters_per_chip;\r\ndevpriv->counter_dev->counters[i].counter_index =\r\ni % counters_per_chip;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\n}\r\nfor (i = 0; i < board->n_chips; ++i)\r\ninit_tio_chip(dev, i);\r\nfor (i = 0; i < ni_660x_num_counters(dev); ++i)\r\nni_tio_init_counter(&devpriv->counter_dev->counters[i]);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i) {\r\nif (i < min_counter_pfi_chan)\r\nni_660x_set_pfi_routing(dev, i, pfi_output_select_do);\r\nelse\r\nni_660x_set_pfi_routing(dev, i,\r\npfi_output_select_counter);\r\nni_660x_select_pfi_output(dev, i, pfi_output_select_high_Z);\r\n}\r\nfor (i = 0; i < board->n_chips; ++i)\r\nset_tio_counterswap(dev, i);\r\nret = request_irq(pcidev->irq, ni_660x_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret < 0) {\r\ndev_warn(dev->class_dev, " irq not available\n");\r\nreturn ret;\r\n}\r\ndev->irq = pcidev->irq;\r\nglobal_interrupt_config_bits = Global_Int_Enable_Bit;\r\nif (board->n_chips > 1)\r\nglobal_interrupt_config_bits |= Cascade_Int_Enable_Bit;\r\nni_660x_write_register(dev, 0, global_interrupt_config_bits,\r\nNI660X_GLOBAL_INT_CFG);\r\nreturn 0;\r\n}\r\nstatic void ni_660x_detach(struct comedi_device *dev)\r\n{\r\nstruct ni_660x_private *devpriv = dev->private;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->counter_dev)\r\nni_gpct_device_destroy(devpriv->counter_dev);\r\nni_660x_free_mite_rings(dev);\r\nmite_detach(devpriv->mite);\r\n}\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int ni_660x_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &ni_660x_driver, id->driver_data);\r\n}
