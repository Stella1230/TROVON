static int mixart_set_pipe_state(struct mixart_mgr *mgr,\r\nstruct mixart_pipe *pipe, int start)\r\n{\r\nstruct mixart_group_state_req group_state;\r\nstruct mixart_group_state_resp group_state_resp;\r\nstruct mixart_msg request;\r\nint err;\r\nu32 system_msg_uid;\r\nswitch(pipe->status) {\r\ncase PIPE_RUNNING:\r\ncase PIPE_CLOCK_SET:\r\nif(start) return 0;\r\nbreak;\r\ncase PIPE_STOPPED:\r\nif(!start) return 0;\r\nbreak;\r\ndefault:\r\ndev_err(&mgr->pci->dev,\r\n"error mixart_set_pipe_state called with wrong pipe->status!\n");\r\nreturn -EINVAL;\r\n}\r\nsystem_msg_uid = 0x12345678;\r\nrequest.message_id = MSG_SYSTEM_WAIT_SYNCHRO_CMD;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &system_msg_uid;\r\nrequest.size = sizeof(system_msg_uid);\r\nerr = snd_mixart_send_msg_wait_notif(mgr, &request, system_msg_uid);\r\nif(err) {\r\ndev_err(&mgr->pci->dev,\r\n"error : MSG_SYSTEM_WAIT_SYNCHRO_CMD was not notified !\n");\r\nreturn err;\r\n}\r\nmemset(&group_state, 0, sizeof(group_state));\r\ngroup_state.pipe_count = 1;\r\ngroup_state.pipe_uid[0] = pipe->group_uid;\r\nif(start)\r\nrequest.message_id = MSG_STREAM_START_STREAM_GRP_PACKET;\r\nelse\r\nrequest.message_id = MSG_STREAM_STOP_STREAM_GRP_PACKET;\r\nrequest.uid = pipe->group_uid;\r\nrequest.data = &group_state;\r\nrequest.size = sizeof(group_state);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(group_state_resp), &group_state_resp);\r\nif (err < 0 || group_state_resp.txx_status != 0) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_STREAM_ST***_STREAM_GRP_PACKET err=%x stat=%x !\n",\r\nerr, group_state_resp.txx_status);\r\nreturn -EINVAL;\r\n}\r\nif(start) {\r\nu32 stat;\r\ngroup_state.pipe_count = 0;\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(group_state_resp), &group_state_resp);\r\nif (err < 0 || group_state_resp.txx_status != 0) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_STREAM_START_STREAM_GRP_PACKET err=%x stat=%x !\n",\r\nerr, group_state_resp.txx_status);\r\nreturn -EINVAL;\r\n}\r\nrequest.message_id = MSG_SYSTEM_SEND_SYNCHRO_CMD;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = NULL;\r\nrequest.size = 0;\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(stat), &stat);\r\nif (err < 0 || stat != 0) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_SYSTEM_SEND_SYNCHRO_CMD err=%x stat=%x !\n",\r\nerr, stat);\r\nreturn -EINVAL;\r\n}\r\npipe->status = PIPE_RUNNING;\r\n}\r\nelse\r\npipe->status = PIPE_STOPPED;\r\nreturn 0;\r\n}\r\nstatic int mixart_set_clock(struct mixart_mgr *mgr,\r\nstruct mixart_pipe *pipe, unsigned int rate)\r\n{\r\nstruct mixart_msg request;\r\nstruct mixart_clock_properties clock_properties;\r\nstruct mixart_clock_properties_resp clock_prop_resp;\r\nint err;\r\nswitch(pipe->status) {\r\ncase PIPE_CLOCK_SET:\r\nbreak;\r\ncase PIPE_RUNNING:\r\nif(rate != 0)\r\nbreak;\r\ndefault:\r\nif(rate == 0)\r\nreturn 0;\r\nelse {\r\ndev_err(&mgr->pci->dev,\r\n"error mixart_set_clock(%d) called with wrong pipe->status !\n",\r\nrate);\r\nreturn -EINVAL;\r\n}\r\n}\r\nmemset(&clock_properties, 0, sizeof(clock_properties));\r\nclock_properties.clock_generic_type = (rate != 0) ? CGT_INTERNAL_CLOCK : CGT_NO_CLOCK;\r\nclock_properties.clock_mode = CM_STANDALONE;\r\nclock_properties.frequency = rate;\r\nclock_properties.nb_callers = 1;\r\nclock_properties.uid_caller[0] = pipe->group_uid;\r\ndev_dbg(&mgr->pci->dev, "mixart_set_clock to %d kHz\n", rate);\r\nrequest.message_id = MSG_CLOCK_SET_PROPERTIES;\r\nrequest.uid = mgr->uid_console_manager;\r\nrequest.data = &clock_properties;\r\nrequest.size = sizeof(clock_properties);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(clock_prop_resp), &clock_prop_resp);\r\nif (err < 0 || clock_prop_resp.status != 0 || clock_prop_resp.clock_mode != CM_STANDALONE) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_CLOCK_SET_PROPERTIES err=%x stat=%x mod=%x !\n",\r\nerr, clock_prop_resp.status, clock_prop_resp.clock_mode);\r\nreturn -EINVAL;\r\n}\r\nif(rate) pipe->status = PIPE_CLOCK_SET;\r\nelse pipe->status = PIPE_RUNNING;\r\nreturn 0;\r\n}\r\nstruct mixart_pipe *\r\nsnd_mixart_add_ref_pipe(struct snd_mixart *chip, int pcm_number, int capture,\r\nint monitoring)\r\n{\r\nint stream_count;\r\nstruct mixart_pipe *pipe;\r\nstruct mixart_msg request;\r\nif(capture) {\r\nif (pcm_number == MIXART_PCM_ANALOG) {\r\npipe = &(chip->pipe_in_ana);\r\n} else {\r\npipe = &(chip->pipe_in_dig);\r\n}\r\nrequest.message_id = MSG_STREAM_ADD_OUTPUT_GROUP;\r\nstream_count = MIXART_CAPTURE_STREAMS;\r\n} else {\r\nif (pcm_number == MIXART_PCM_ANALOG) {\r\npipe = &(chip->pipe_out_ana);\r\n} else {\r\npipe = &(chip->pipe_out_dig);\r\n}\r\nrequest.message_id = MSG_STREAM_ADD_INPUT_GROUP;\r\nstream_count = MIXART_PLAYBACK_STREAMS;\r\n}\r\nif( (monitoring == 0) && (pipe->references >= stream_count) ) {\r\nreturn NULL;\r\n}\r\nif( pipe->status == PIPE_UNDEFINED ) {\r\nint err, i;\r\nstruct {\r\nstruct mixart_streaming_group_req sgroup_req;\r\nstruct mixart_streaming_group sgroup_resp;\r\n} *buf;\r\ndev_dbg(chip->card->dev,\r\n"add_ref_pipe audio chip(%d) pcm(%d)\n",\r\nchip->chip_idx, pcm_number);\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &buf->sgroup_req;\r\nrequest.size = sizeof(buf->sgroup_req);\r\nmemset(&buf->sgroup_req, 0, sizeof(buf->sgroup_req));\r\nbuf->sgroup_req.stream_count = stream_count;\r\nbuf->sgroup_req.channel_count = 2;\r\nbuf->sgroup_req.latency = 256;\r\nbuf->sgroup_req.connector = pipe->uid_left_connector;\r\nfor (i=0; i<stream_count; i++) {\r\nint j;\r\nstruct mixart_flowinfo *flowinfo;\r\nstruct mixart_bufferinfo *bufferinfo;\r\nbuf->sgroup_req.stream_info[i].size_max_byte_frame = 1024;\r\nbuf->sgroup_req.stream_info[i].size_max_sample_frame = 256;\r\nbuf->sgroup_req.stream_info[i].nb_bytes_max_per_sample = MIXART_FLOAT_P__4_0_TO_HEX;\r\nj = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (pcm_number * (MIXART_PLAYBACK_STREAMS + MIXART_CAPTURE_STREAMS)) + i;\r\nif(capture) j += MIXART_PLAYBACK_STREAMS;\r\nbuf->sgroup_req.flow_entry[i] = j;\r\nflowinfo = (struct mixart_flowinfo *)chip->mgr->flowinfo.area;\r\nflowinfo[j].bufferinfo_array_phy_address = (u32)chip->mgr->bufferinfo.addr + (j * sizeof(struct mixart_bufferinfo));\r\nflowinfo[j].bufferinfo_count = 1;\r\nbufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;\r\nbufferinfo[j].buffer_address = 0;\r\nbufferinfo[j].available_length = 0;\r\nbufferinfo[j].buffer_id = (chip->chip_idx << MIXART_NOTIFY_CARD_OFFSET) + (pcm_number << MIXART_NOTIFY_PCM_OFFSET ) + i;\r\nif(capture) {\r\nbufferinfo[j].buffer_id |= MIXART_NOTIFY_CAPT_MASK;\r\n}\r\n}\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(buf->sgroup_resp), &buf->sgroup_resp);\r\nif((err < 0) || (buf->sgroup_resp.status != 0)) {\r\ndev_err(chip->card->dev,\r\n"error MSG_STREAM_ADD_**PUT_GROUP err=%x stat=%x !\n",\r\nerr, buf->sgroup_resp.status);\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\npipe->group_uid = buf->sgroup_resp.group;\r\npipe->stream_count = buf->sgroup_resp.stream_count;\r\npipe->status = PIPE_STOPPED;\r\nkfree(buf);\r\n}\r\nif(monitoring) pipe->monitoring = 1;\r\nelse pipe->references++;\r\nreturn pipe;\r\n}\r\nint snd_mixart_kill_ref_pipe(struct mixart_mgr *mgr,\r\nstruct mixart_pipe *pipe, int monitoring)\r\n{\r\nint err = 0;\r\nif(pipe->status == PIPE_UNDEFINED)\r\nreturn 0;\r\nif(monitoring)\r\npipe->monitoring = 0;\r\nelse\r\npipe->references--;\r\nif((pipe->references <= 0) && (pipe->monitoring == 0)) {\r\nstruct mixart_msg request;\r\nstruct mixart_delete_group_resp delete_resp;\r\nerr = mixart_set_clock( mgr, pipe, 0);\r\nif( err < 0 ) {\r\ndev_err(&mgr->pci->dev,\r\n"mixart_set_clock(0) return error!\n");\r\n}\r\nerr = mixart_set_pipe_state(mgr, pipe, 0);\r\nif( err < 0 ) {\r\ndev_err(&mgr->pci->dev, "error stopping pipe!\n");\r\n}\r\nrequest.message_id = MSG_STREAM_DELETE_GROUP;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &pipe->group_uid;\r\nrequest.size = sizeof(pipe->group_uid);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(delete_resp), &delete_resp);\r\nif ((err < 0) || (delete_resp.status != 0)) {\r\ndev_err(&mgr->pci->dev,\r\n"error MSG_STREAM_DELETE_GROUP err(%x), status(%x)\n",\r\nerr, delete_resp.status);\r\n}\r\npipe->group_uid = (struct mixart_uid){0,0};\r\npipe->stream_count = 0;\r\npipe->status = PIPE_UNDEFINED;\r\n}\r\nreturn err;\r\n}\r\nstatic int mixart_set_stream_state(struct mixart_stream *stream, int start)\r\n{\r\nstruct snd_mixart *chip;\r\nstruct mixart_stream_state_req stream_state_req;\r\nstruct mixart_msg request;\r\nif(!stream->substream)\r\nreturn -EINVAL;\r\nmemset(&stream_state_req, 0, sizeof(stream_state_req));\r\nstream_state_req.stream_count = 1;\r\nstream_state_req.stream_info.stream_desc.uid_pipe = stream->pipe->group_uid;\r\nstream_state_req.stream_info.stream_desc.stream_idx = stream->substream->number;\r\nif (stream->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nrequest.message_id = start ? MSG_STREAM_START_INPUT_STAGE_PACKET : MSG_STREAM_STOP_INPUT_STAGE_PACKET;\r\nelse\r\nrequest.message_id = start ? MSG_STREAM_START_OUTPUT_STAGE_PACKET : MSG_STREAM_STOP_OUTPUT_STAGE_PACKET;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &stream_state_req;\r\nrequest.size = sizeof(stream_state_req);\r\nstream->abs_period_elapsed = 0;\r\nstream->buf_periods = 0;\r\nstream->buf_period_frag = 0;\r\nchip = snd_pcm_substream_chip(stream->substream);\r\nreturn snd_mixart_send_msg_nonblock(chip->mgr, &request);\r\n}\r\nstatic int snd_mixart_trigger(struct snd_pcm_substream *subs, int cmd)\r\n{\r\nstruct mixart_stream *stream = subs->runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndev_dbg(subs->pcm->card->dev, "SNDRV_PCM_TRIGGER_START\n");\r\nif( mixart_set_stream_state(stream, 1) )\r\nreturn -EINVAL;\r\nstream->status = MIXART_STREAM_STATUS_RUNNING;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif( mixart_set_stream_state(stream, 0) )\r\nreturn -EINVAL;\r\nstream->status = MIXART_STREAM_STATUS_OPEN;\r\ndev_dbg(subs->pcm->card->dev, "SNDRV_PCM_TRIGGER_STOP\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nstream->status = MIXART_STREAM_STATUS_PAUSE;\r\ndev_dbg(subs->pcm->card->dev, "SNDRV_PCM_PAUSE_PUSH\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nstream->status = MIXART_STREAM_STATUS_RUNNING;\r\ndev_dbg(subs->pcm->card->dev, "SNDRV_PCM_PAUSE_RELEASE\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_sync_nonblock_events(struct mixart_mgr *mgr)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nwhile (atomic_read(&mgr->msg_processed) > 0) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&mgr->pci->dev,\r\n"mixart: cannot process nonblock events!\n");\r\nreturn -EBUSY;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nstruct mixart_stream *stream = subs->runtime->private_data;\r\ndev_dbg(chip->card->dev, "snd_mixart_prepare\n");\r\nmixart_sync_nonblock_events(chip->mgr);\r\nif(chip->mgr->ref_count_rate == 1)\r\nchip->mgr->sample_rate = subs->runtime->rate;\r\nif(stream->pipe->references == 1) {\r\nif( mixart_set_clock(chip->mgr, stream->pipe, subs->runtime->rate) )\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_set_format(struct mixart_stream *stream, snd_pcm_format_t format)\r\n{\r\nint err;\r\nstruct snd_mixart *chip;\r\nstruct mixart_msg request;\r\nstruct mixart_stream_param_desc stream_param;\r\nstruct mixart_return_uid resp;\r\nchip = snd_pcm_substream_chip(stream->substream);\r\nmemset(&stream_param, 0, sizeof(stream_param));\r\nstream_param.coding_type = CT_LINEAR;\r\nstream_param.number_of_channel = stream->channels;\r\nstream_param.sampling_freq = chip->mgr->sample_rate;\r\nif(stream_param.sampling_freq == 0)\r\nstream_param.sampling_freq = 44100;\r\nswitch(format){\r\ncase SNDRV_PCM_FORMAT_U8:\r\nstream_param.sample_type = ST_INTEGER_8;\r\nstream_param.sample_size = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nstream_param.sample_type = ST_INTEGER_16LE;\r\nstream_param.sample_size = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nstream_param.sample_type = ST_INTEGER_16BE;\r\nstream_param.sample_size = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\nstream_param.sample_type = ST_INTEGER_24LE;\r\nstream_param.sample_size = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_3BE:\r\nstream_param.sample_type = ST_INTEGER_24BE;\r\nstream_param.sample_size = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_FLOAT_LE:\r\nstream_param.sample_type = ST_FLOATING_POINT_32LE;\r\nstream_param.sample_size = 32;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_FLOAT_BE:\r\nstream_param.sample_type = ST_FLOATING_POINT_32BE;\r\nstream_param.sample_size = 32;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"error mixart_set_format() : unknown format\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"set SNDRV_PCM_FORMAT sample_type(%d) sample_size(%d) freq(%d) channels(%d)\n",\r\nstream_param.sample_type, stream_param.sample_size, stream_param.sampling_freq, stream->channels);\r\nstream_param.pipe_count = 1;\r\nstream_param.stream_count = 1;\r\nstream_param.stream_desc[0].uid_pipe = stream->pipe->group_uid;\r\nstream_param.stream_desc[0].stream_idx = stream->substream->number;\r\nrequest.message_id = MSG_STREAM_SET_INPUT_STAGE_PARAM;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &stream_param;\r\nrequest.size = sizeof(stream_param);\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\r\nif((err < 0) || resp.error_code) {\r\ndev_err(chip->card->dev,\r\n"MSG_STREAM_SET_INPUT_STAGE_PARAM err=%x; resp=%x\n",\r\nerr, resp.error_code);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_hw_params(struct snd_pcm_substream *subs,\r\nstruct snd_pcm_hw_params *hw)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nstruct mixart_mgr *mgr = chip->mgr;\r\nstruct mixart_stream *stream = subs->runtime->private_data;\r\nsnd_pcm_format_t format;\r\nint err;\r\nint channels;\r\nchannels = params_channels(hw);\r\nformat = params_format(hw);\r\nmutex_lock(&mgr->setup_mutex);\r\nif( stream->pcm_number <= MIXART_PCM_DIGITAL ) {\r\nint is_aes = stream->pcm_number > MIXART_PCM_ANALOG;\r\nif( subs->stream == SNDRV_PCM_STREAM_PLAYBACK )\r\nmixart_update_playback_stream_level(chip, is_aes, subs->number);\r\nelse\r\nmixart_update_capture_stream_level( chip, is_aes);\r\n}\r\nstream->channels = channels;\r\nerr = mixart_set_format(stream, format);\r\nif(err < 0) {\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nerr = snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw));\r\nif (err > 0) {\r\nstruct mixart_bufferinfo *bufferinfo;\r\nint i = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (stream->pcm_number * (MIXART_PLAYBACK_STREAMS+MIXART_CAPTURE_STREAMS)) + subs->number;\r\nif( subs->stream == SNDRV_PCM_STREAM_CAPTURE ) {\r\ni += MIXART_PLAYBACK_STREAMS;\r\n}\r\nbufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;\r\nbufferinfo[i].buffer_address = subs->runtime->dma_addr;\r\nbufferinfo[i].available_length = subs->runtime->dma_bytes;\r\ndev_dbg(chip->card->dev,\r\n"snd_mixart_hw_params(pcm %d) : dma_addr(%x) dma_bytes(%x) subs-number(%d)\n",\r\ni, bufferinfo[i].buffer_address,\r\nbufferinfo[i].available_length,\r\nsubs->number);\r\n}\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_mixart_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nsnd_pcm_lib_free_pages(subs);\r\nmixart_sync_nonblock_events(chip->mgr);\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_playback_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nstruct mixart_mgr *mgr = chip->mgr;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct snd_pcm *pcm = subs->pcm;\r\nstruct mixart_stream *stream;\r\nstruct mixart_pipe *pipe;\r\nint err = 0;\r\nint pcm_number;\r\nmutex_lock(&mgr->setup_mutex);\r\nif ( pcm == chip->pcm ) {\r\npcm_number = MIXART_PCM_ANALOG;\r\nruntime->hw = snd_mixart_analog_caps;\r\n} else {\r\nsnd_BUG_ON(pcm != chip->pcm_dig);\r\npcm_number = MIXART_PCM_DIGITAL;\r\nruntime->hw = snd_mixart_digital_caps;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"snd_mixart_playback_open C%d/P%d/Sub%d\n",\r\nchip->chip_idx, pcm_number, subs->number);\r\nstream = &(chip->playback_stream[pcm_number][subs->number]);\r\nif (stream->status != MIXART_STREAM_STATUS_FREE){\r\ndev_err(chip->card->dev,\r\n"snd_mixart_playback_open C%d/P%d/Sub%d in use\n",\r\nchip->chip_idx, pcm_number, subs->number);\r\nerr = -EBUSY;\r\ngoto _exit_open;\r\n}\r\npipe = snd_mixart_add_ref_pipe(chip, pcm_number, 0, 0);\r\nif (pipe == NULL) {\r\nerr = -EINVAL;\r\ngoto _exit_open;\r\n}\r\nerr = mixart_set_pipe_state(chip->mgr, pipe, 1);\r\nif( err < 0 ) {\r\ndev_err(chip->card->dev, "error starting pipe!\n");\r\nsnd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);\r\nerr = -EINVAL;\r\ngoto _exit_open;\r\n}\r\nstream->pipe = pipe;\r\nstream->pcm_number = pcm_number;\r\nstream->status = MIXART_STREAM_STATUS_OPEN;\r\nstream->substream = subs;\r\nstream->channels = 0;\r\nruntime->private_data = stream;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 64);\r\nif(mgr->ref_count_rate++) {\r\nif(mgr->sample_rate) {\r\nruntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\r\n}\r\n}\r\n_exit_open:\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_mixart_capture_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nstruct mixart_mgr *mgr = chip->mgr;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct snd_pcm *pcm = subs->pcm;\r\nstruct mixart_stream *stream;\r\nstruct mixart_pipe *pipe;\r\nint err = 0;\r\nint pcm_number;\r\nmutex_lock(&mgr->setup_mutex);\r\nif ( pcm == chip->pcm ) {\r\npcm_number = MIXART_PCM_ANALOG;\r\nruntime->hw = snd_mixart_analog_caps;\r\n} else {\r\nsnd_BUG_ON(pcm != chip->pcm_dig);\r\npcm_number = MIXART_PCM_DIGITAL;\r\nruntime->hw = snd_mixart_digital_caps;\r\n}\r\nruntime->hw.channels_min = 2;\r\ndev_dbg(chip->card->dev, "snd_mixart_capture_open C%d/P%d/Sub%d\n",\r\nchip->chip_idx, pcm_number, subs->number);\r\nstream = &(chip->capture_stream[pcm_number]);\r\nif (stream->status != MIXART_STREAM_STATUS_FREE){\r\ndev_err(chip->card->dev,\r\n"snd_mixart_capture_open C%d/P%d/Sub%d in use\n",\r\nchip->chip_idx, pcm_number, subs->number);\r\nerr = -EBUSY;\r\ngoto _exit_open;\r\n}\r\npipe = snd_mixart_add_ref_pipe(chip, pcm_number, 1, 0);\r\nif (pipe == NULL) {\r\nerr = -EINVAL;\r\ngoto _exit_open;\r\n}\r\nerr = mixart_set_pipe_state(chip->mgr, pipe, 1);\r\nif( err < 0 ) {\r\ndev_err(chip->card->dev, "error starting pipe!\n");\r\nsnd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);\r\nerr = -EINVAL;\r\ngoto _exit_open;\r\n}\r\nstream->pipe = pipe;\r\nstream->pcm_number = pcm_number;\r\nstream->status = MIXART_STREAM_STATUS_OPEN;\r\nstream->substream = subs;\r\nstream->channels = 0;\r\nruntime->private_data = stream;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 64);\r\nif(mgr->ref_count_rate++) {\r\nif(mgr->sample_rate) {\r\nruntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\r\n}\r\n}\r\n_exit_open:\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_mixart_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\r\nstruct mixart_mgr *mgr = chip->mgr;\r\nstruct mixart_stream *stream = subs->runtime->private_data;\r\nmutex_lock(&mgr->setup_mutex);\r\ndev_dbg(chip->card->dev, "snd_mixart_close C%d/P%d/Sub%d\n",\r\nchip->chip_idx, stream->pcm_number, subs->number);\r\nif(--mgr->ref_count_rate == 0) {\r\nmgr->sample_rate = 0;\r\n}\r\nif (snd_mixart_kill_ref_pipe(mgr, stream->pipe, 0 ) < 0) {\r\ndev_err(chip->card->dev,\r\n"error snd_mixart_kill_ref_pipe C%dP%d\n",\r\nchip->chip_idx, stream->pcm_number);\r\n}\r\nstream->pipe = NULL;\r\nstream->status = MIXART_STREAM_STATUS_FREE;\r\nstream->substream = NULL;\r\nmutex_unlock(&mgr->setup_mutex);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_mixart_stream_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct mixart_stream *stream = runtime->private_data;\r\nreturn (snd_pcm_uframes_t)((stream->buf_periods * runtime->period_size) + stream->buf_period_frag);\r\n}\r\nstatic void preallocate_buffers(struct snd_mixart *chip, struct snd_pcm *pcm)\r\n{\r\n#if 0\r\nstruct snd_pcm_substream *subs;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nint idx = 0;\r\nfor (subs = pcm->streams[stream].substream; subs; subs = subs->next, idx++)\r\nsubs->dma_device.id = subs->pcm->device << 16 |\r\nsubs->stream << 8 | (subs->number + 1) |\r\n(chip->chip_idx + 1) << 24;\r\n}\r\n#endif\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->mgr->pci), 32*1024, 32*1024);\r\n}\r\nstatic int snd_mixart_pcm_analog(struct snd_mixart *chip)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nchar name[32];\r\nsprintf(name, "miXart analog %d", chip->chip_idx);\r\nif ((err = snd_pcm_new(chip->card, name, MIXART_PCM_ANALOG,\r\nMIXART_PLAYBACK_STREAMS,\r\nMIXART_CAPTURE_STREAMS, &pcm)) < 0) {\r\ndev_err(chip->card->dev,\r\n"cannot create the analog pcm %d\n", chip->chip_idx);\r\nreturn err;\r\n}\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_mixart_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_mixart_capture_ops);\r\npcm->info_flags = 0;\r\npcm->nonatomic = true;\r\nstrcpy(pcm->name, name);\r\npreallocate_buffers(chip, pcm);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_pcm_digital(struct snd_mixart *chip)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nchar name[32];\r\nsprintf(name, "miXart AES/EBU %d", chip->chip_idx);\r\nif ((err = snd_pcm_new(chip->card, name, MIXART_PCM_DIGITAL,\r\nMIXART_PLAYBACK_STREAMS,\r\nMIXART_CAPTURE_STREAMS, &pcm)) < 0) {\r\ndev_err(chip->card->dev,\r\n"cannot create the digital pcm %d\n", chip->chip_idx);\r\nreturn err;\r\n}\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_mixart_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_mixart_capture_ops);\r\npcm->info_flags = 0;\r\npcm->nonatomic = true;\r\nstrcpy(pcm->name, name);\r\npreallocate_buffers(chip, pcm);\r\nchip->pcm_dig = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_chip_free(struct snd_mixart *chip)\r\n{\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_mixart_chip_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_mixart *chip = device->device_data;\r\nreturn snd_mixart_chip_free(chip);\r\n}\r\nstatic int snd_mixart_create(struct mixart_mgr *mgr, struct snd_card *card, int idx)\r\n{\r\nint err;\r\nstruct snd_mixart *chip;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_mixart_chip_dev_free,\r\n};\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (! chip) {\r\ndev_err(card->dev, "cannot allocate chip\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->chip_idx = idx;\r\nchip->mgr = mgr;\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_mixart_chip_free(chip);\r\nreturn err;\r\n}\r\nmgr->chip[idx] = chip;\r\nreturn 0;\r\n}\r\nint snd_mixart_create_pcm(struct snd_mixart* chip)\r\n{\r\nint err;\r\nerr = snd_mixart_pcm_analog(chip);\r\nif (err < 0)\r\nreturn err;\r\nif(chip->mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\r\nerr = snd_mixart_pcm_digital(chip);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_mixart_free(struct mixart_mgr *mgr)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nif (mgr->chip[i])\r\nsnd_card_free(mgr->chip[i]->card);\r\n}\r\nsnd_mixart_exit_mailbox(mgr);\r\nif (mgr->irq >= 0)\r\nfree_irq(mgr->irq, mgr);\r\nif(mgr->dsp_loaded) {\r\nsnd_mixart_reset_board(mgr);\r\ndev_dbg(&mgr->pci->dev, "reset miXart !\n");\r\n}\r\nfor (i = 0; i < 2; ++i)\r\niounmap(mgr->mem[i].virt);\r\npci_release_regions(mgr->pci);\r\nif(mgr->flowinfo.area) {\r\nsnd_dma_free_pages(&mgr->flowinfo);\r\nmgr->flowinfo.area = NULL;\r\n}\r\nif(mgr->bufferinfo.area) {\r\nsnd_dma_free_pages(&mgr->bufferinfo);\r\nmgr->bufferinfo.area = NULL;\r\n}\r\npci_disable_device(mgr->pci);\r\nkfree(mgr);\r\nreturn 0;\r\n}\r\nstatic ssize_t snd_mixart_BA0_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct mixart_mgr *mgr = entry->private_data;\r\ncount = count & ~3;\r\nif (copy_to_user_fromio(buf, MIXART_MEM(mgr, pos), count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic ssize_t snd_mixart_BA1_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct mixart_mgr *mgr = entry->private_data;\r\ncount = count & ~3;\r\nif (copy_to_user_fromio(buf, MIXART_REG(mgr, pos), count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic void snd_mixart_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_mixart *chip = entry->private_data;\r\nu32 ref;\r\nsnd_iprintf(buffer, "Digigram miXart (alsa card %d)\n\n", chip->chip_idx);\r\nif (chip->mgr->dsp_loaded & ( 1 << MIXART_MOTHERBOARD_ELF_INDEX)) {\r\nsnd_iprintf(buffer, "- hardware -\n");\r\nswitch (chip->mgr->board_type ) {\r\ncase MIXART_DAUGHTER_TYPE_NONE : snd_iprintf(buffer, "\tmiXart8 (no daughter board)\n\n"); break;\r\ncase MIXART_DAUGHTER_TYPE_AES : snd_iprintf(buffer, "\tmiXart8 AES/EBU\n\n"); break;\r\ncase MIXART_DAUGHTER_TYPE_COBRANET : snd_iprintf(buffer, "\tmiXart8 Cobranet\n\n"); break;\r\ndefault: snd_iprintf(buffer, "\tUNKNOWN!\n\n"); break;\r\n}\r\nsnd_iprintf(buffer, "- system load -\n");\r\nref = readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_SYSTEM_LOAD_OFFSET));\r\nif (ref) {\r\nu32 mailbox = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_MAILBX_LOAD_OFFSET)) / ref;\r\nu32 streaming = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_STREAM_LOAD_OFFSET)) / ref;\r\nu32 interr = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_INTERR_LOAD_OFFSET)) / ref;\r\nsnd_iprintf(buffer, "\tstreaming : %d\n", streaming);\r\nsnd_iprintf(buffer, "\tmailbox : %d\n", mailbox);\r\nsnd_iprintf(buffer, "\tinterrupts handling : %d\n\n", interr);\r\n}\r\n}\r\n}\r\nstatic void snd_mixart_proc_init(struct snd_mixart *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "board_info", &entry)) {\r\nentry->private_data = chip;\r\nentry->c.text.read = snd_mixart_proc_read;\r\n}\r\nif (! snd_card_proc_new(chip->card, "mixart_BA0", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = chip->mgr;\r\nentry->c.ops = &snd_mixart_proc_ops_BA0;\r\nentry->size = MIXART_BA0_SIZE;\r\n}\r\nif (! snd_card_proc_new(chip->card, "mixart_BA1", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = chip->mgr;\r\nentry->c.ops = &snd_mixart_proc_ops_BA1;\r\nentry->size = MIXART_BA1_SIZE;\r\n}\r\n}\r\nstatic int snd_mixart_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct mixart_mgr *mgr;\r\nunsigned int i;\r\nint err;\r\nsize_t size;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (! enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\npci_set_master(pci);\r\nif (dma_set_mask(&pci->dev, DMA_BIT_MASK(32)) < 0) {\r\ndev_err(&pci->dev,\r\n"architecture does not support 32bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\r\nif (! mgr) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nmgr->pci = pci;\r\nmgr->irq = -1;\r\nif ((err = pci_request_regions(pci, CARD_NAME)) < 0) {\r\nkfree(mgr);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nmgr->mem[i].phys = pci_resource_start(pci, i);\r\nmgr->mem[i].virt = pci_ioremap_bar(pci, i);\r\nif (!mgr->mem[i].virt) {\r\ndev_err(&pci->dev, "unable to remap resource 0x%lx\n",\r\nmgr->mem[i].phys);\r\nsnd_mixart_free(mgr);\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (request_threaded_irq(pci->irq, snd_mixart_interrupt,\r\nsnd_mixart_threaded_irq, IRQF_SHARED,\r\nKBUILD_MODNAME, mgr)) {\r\ndev_err(&pci->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_mixart_free(mgr);\r\nreturn -EBUSY;\r\n}\r\nmgr->irq = pci->irq;\r\nsprintf(mgr->shortname, "Digigram miXart");\r\nsprintf(mgr->longname, "%s at 0x%lx & 0x%lx, irq %i", mgr->shortname, mgr->mem[0].phys, mgr->mem[1].phys, mgr->irq);\r\nmgr->msg_fifo_readptr = 0;\r\nmgr->msg_fifo_writeptr = 0;\r\nmutex_init(&mgr->lock);\r\nmutex_init(&mgr->msg_lock);\r\ninit_waitqueue_head(&mgr->msg_sleep);\r\natomic_set(&mgr->msg_processed, 0);\r\nmutex_init(&mgr->setup_mutex);\r\nmgr->num_cards = MIXART_MAX_CARDS;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nstruct snd_card *card;\r\nchar tmpid[16];\r\nint idx;\r\nif (index[dev] < 0)\r\nidx = index[dev];\r\nelse\r\nidx = index[dev] + i;\r\nsnprintf(tmpid, sizeof(tmpid), "%s-%d", id[dev] ? id[dev] : "MIXART", i);\r\nerr = snd_card_new(&pci->dev, idx, tmpid, THIS_MODULE,\r\n0, &card);\r\nif (err < 0) {\r\ndev_err(&pci->dev, "cannot allocate the card %d\n", i);\r\nsnd_mixart_free(mgr);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, CARD_NAME);\r\nsprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);\r\nsprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);\r\nif ((err = snd_mixart_create(mgr, card, i)) < 0) {\r\nsnd_card_free(card);\r\nsnd_mixart_free(mgr);\r\nreturn err;\r\n}\r\nif(i==0) {\r\nsnd_mixart_proc_init(mgr->chip[i]);\r\n}\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_mixart_free(mgr);\r\nreturn err;\r\n}\r\n}\r\nmgr->board_type = MIXART_DAUGHTER_TYPE_NONE;\r\nsize = PAGE_ALIGN( (MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS *\r\nsizeof(struct mixart_flowinfo)) );\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nsize, &mgr->flowinfo) < 0) {\r\nsnd_mixart_free(mgr);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mgr->flowinfo.area, 0, size);\r\nsize = PAGE_ALIGN( (MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS *\r\nsizeof(struct mixart_bufferinfo)) );\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nsize, &mgr->bufferinfo) < 0) {\r\nsnd_mixart_free(mgr);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mgr->bufferinfo.area, 0, size);\r\nerr = snd_mixart_setup_firmware(mgr);\r\nif (err < 0) {\r\nsnd_mixart_free(mgr);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, mgr);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_mixart_remove(struct pci_dev *pci)\r\n{\r\nsnd_mixart_free(pci_get_drvdata(pci));\r\n}
