static inline void venc_write_reg(int idx, u32 val)\r\n{\r\n__raw_writel(val, venc.base + idx);\r\n}\r\nstatic inline u32 venc_read_reg(int idx)\r\n{\r\nu32 l = __raw_readl(venc.base + idx);\r\nreturn l;\r\n}\r\nstatic void venc_write_config(const struct venc_config *config)\r\n{\r\nDSSDBG("write venc conf\n");\r\nvenc_write_reg(VENC_LLEN, config->llen);\r\nvenc_write_reg(VENC_FLENS, config->flens);\r\nvenc_write_reg(VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);\r\nvenc_write_reg(VENC_C_PHASE, config->c_phase);\r\nvenc_write_reg(VENC_GAIN_U, config->gain_u);\r\nvenc_write_reg(VENC_GAIN_V, config->gain_v);\r\nvenc_write_reg(VENC_GAIN_Y, config->gain_y);\r\nvenc_write_reg(VENC_BLACK_LEVEL, config->black_level);\r\nvenc_write_reg(VENC_BLANK_LEVEL, config->blank_level);\r\nvenc_write_reg(VENC_M_CONTROL, config->m_control);\r\nvenc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |\r\nvenc.wss_data);\r\nvenc_write_reg(VENC_S_CARR, config->s_carr);\r\nvenc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);\r\nvenc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);\r\nvenc_write_reg(VENC_FLEN__FAL, config->flen__fal);\r\nvenc_write_reg(VENC_LAL__PHASE_RESET, config->lal__phase_reset);\r\nvenc_write_reg(VENC_HS_INT_START_STOP_X, config->hs_int_start_stop_x);\r\nvenc_write_reg(VENC_HS_EXT_START_STOP_X, config->hs_ext_start_stop_x);\r\nvenc_write_reg(VENC_VS_INT_START_X, config->vs_int_start_x);\r\nvenc_write_reg(VENC_VS_INT_STOP_X__VS_INT_START_Y,\r\nconfig->vs_int_stop_x__vs_int_start_y);\r\nvenc_write_reg(VENC_VS_INT_STOP_Y__VS_EXT_START_X,\r\nconfig->vs_int_stop_y__vs_ext_start_x);\r\nvenc_write_reg(VENC_VS_EXT_STOP_X__VS_EXT_START_Y,\r\nconfig->vs_ext_stop_x__vs_ext_start_y);\r\nvenc_write_reg(VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);\r\nvenc_write_reg(VENC_AVID_START_STOP_X, config->avid_start_stop_x);\r\nvenc_write_reg(VENC_AVID_START_STOP_Y, config->avid_start_stop_y);\r\nvenc_write_reg(VENC_FID_INT_START_X__FID_INT_START_Y,\r\nconfig->fid_int_start_x__fid_int_start_y);\r\nvenc_write_reg(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,\r\nconfig->fid_int_offset_y__fid_ext_start_x);\r\nvenc_write_reg(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,\r\nconfig->fid_ext_start_y__fid_ext_offset_y);\r\nvenc_write_reg(VENC_DAC_B__DAC_C, venc_read_reg(VENC_DAC_B__DAC_C));\r\nvenc_write_reg(VENC_VIDOUT_CTRL, config->vidout_ctrl);\r\nvenc_write_reg(VENC_HFLTR_CTRL, config->hfltr_ctrl);\r\nvenc_write_reg(VENC_X_COLOR, config->x_color);\r\nvenc_write_reg(VENC_LINE21, config->line21);\r\nvenc_write_reg(VENC_LN_SEL, config->ln_sel);\r\nvenc_write_reg(VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);\r\nvenc_write_reg(VENC_TVDETGP_INT_START_STOP_X,\r\nconfig->tvdetgp_int_start_stop_x);\r\nvenc_write_reg(VENC_TVDETGP_INT_START_STOP_Y,\r\nconfig->tvdetgp_int_start_stop_y);\r\nvenc_write_reg(VENC_GEN_CTRL, config->gen_ctrl);\r\nvenc_write_reg(VENC_F_CONTROL, config->f_control);\r\nvenc_write_reg(VENC_SYNC_CTRL, config->sync_ctrl);\r\n}\r\nstatic void venc_reset(void)\r\n{\r\nint t = 1000;\r\nvenc_write_reg(VENC_F_CONTROL, 1<<8);\r\nwhile (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {\r\nif (--t == 0) {\r\nDSSERR("Failed to reset venc\n");\r\nreturn;\r\n}\r\n}\r\n#ifdef CONFIG_OMAP2_DSS_SLEEP_AFTER_VENC_RESET\r\nmsleep(20);\r\n#endif\r\n}\r\nstatic int venc_runtime_get(void)\r\n{\r\nint r;\r\nDSSDBG("venc_runtime_get\n");\r\nr = pm_runtime_get_sync(&venc.pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nstatic void venc_runtime_put(void)\r\n{\r\nint r;\r\nDSSDBG("venc_runtime_put\n");\r\nr = pm_runtime_put_sync(&venc.pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS);\r\n}\r\nstatic const struct venc_config *venc_timings_to_config(\r\nstruct omap_video_timings *timings)\r\n{\r\nif (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)\r\nreturn &venc_config_pal_trm;\r\nif (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)\r\nreturn &venc_config_ntsc_trm;\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic int venc_power_on(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = venc.output.manager;\r\nu32 l;\r\nint r;\r\nr = venc_runtime_get();\r\nif (r)\r\ngoto err0;\r\nvenc_reset();\r\nvenc_write_config(venc_timings_to_config(&venc.timings));\r\ndss_set_venc_output(venc.type);\r\ndss_set_dac_pwrdn_bgz(1);\r\nl = 0;\r\nif (venc.type == OMAP_DSS_VENC_TYPE_COMPOSITE)\r\nl |= 1 << 1;\r\nelse\r\nl |= (1 << 0) | (1 << 2);\r\nif (venc.invert_polarity == false)\r\nl |= 1 << 3;\r\nvenc_write_reg(VENC_OUTPUT_CONTROL, l);\r\ndss_mgr_set_timings(mgr, &venc.timings);\r\nr = regulator_enable(venc.vdda_dac_reg);\r\nif (r)\r\ngoto err1;\r\nr = dss_mgr_enable(mgr);\r\nif (r)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nregulator_disable(venc.vdda_dac_reg);\r\nerr1:\r\nvenc_write_reg(VENC_OUTPUT_CONTROL, 0);\r\ndss_set_dac_pwrdn_bgz(0);\r\nvenc_runtime_put();\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void venc_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = venc.output.manager;\r\nvenc_write_reg(VENC_OUTPUT_CONTROL, 0);\r\ndss_set_dac_pwrdn_bgz(0);\r\ndss_mgr_disable(mgr);\r\nregulator_disable(venc.vdda_dac_reg);\r\nvenc_runtime_put();\r\n}\r\nstatic int venc_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &venc.output;\r\nint r;\r\nDSSDBG("venc_display_enable\n");\r\nmutex_lock(&venc.venc_lock);\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("Failed to enable display: no output/manager\n");\r\nr = -ENODEV;\r\ngoto err0;\r\n}\r\nr = venc_power_on(dssdev);\r\nif (r)\r\ngoto err0;\r\nvenc.wss_data = 0;\r\nmutex_unlock(&venc.venc_lock);\r\nreturn 0;\r\nerr0:\r\nmutex_unlock(&venc.venc_lock);\r\nreturn r;\r\n}\r\nstatic void venc_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nDSSDBG("venc_display_disable\n");\r\nmutex_lock(&venc.venc_lock);\r\nvenc_power_off(dssdev);\r\nmutex_unlock(&venc.venc_lock);\r\n}\r\nstatic void venc_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nDSSDBG("venc_set_timings\n");\r\nmutex_lock(&venc.venc_lock);\r\nif (memcmp(&venc.timings, timings, sizeof(*timings)))\r\nvenc.wss_data = 0;\r\nvenc.timings = *timings;\r\ndispc_set_tv_pclk(13500000);\r\nmutex_unlock(&venc.venc_lock);\r\n}\r\nstatic int venc_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nDSSDBG("venc_check_timings\n");\r\nif (memcmp(&omap_dss_pal_timings, timings, sizeof(*timings)) == 0)\r\nreturn 0;\r\nif (memcmp(&omap_dss_ntsc_timings, timings, sizeof(*timings)) == 0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void venc_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nmutex_lock(&venc.venc_lock);\r\n*timings = venc.timings;\r\nmutex_unlock(&venc.venc_lock);\r\n}\r\nstatic u32 venc_get_wss(struct omap_dss_device *dssdev)\r\n{\r\nreturn (venc.wss_data >> 8) ^ 0xfffff;\r\n}\r\nstatic int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)\r\n{\r\nconst struct venc_config *config;\r\nint r;\r\nDSSDBG("venc_set_wss\n");\r\nmutex_lock(&venc.venc_lock);\r\nconfig = venc_timings_to_config(&venc.timings);\r\nvenc.wss_data = (wss ^ 0xfffff) << 8;\r\nr = venc_runtime_get();\r\nif (r)\r\ngoto err;\r\nvenc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |\r\nvenc.wss_data);\r\nvenc_runtime_put();\r\nerr:\r\nmutex_unlock(&venc.venc_lock);\r\nreturn r;\r\n}\r\nstatic void venc_set_type(struct omap_dss_device *dssdev,\r\nenum omap_dss_venc_type type)\r\n{\r\nmutex_lock(&venc.venc_lock);\r\nvenc.type = type;\r\nmutex_unlock(&venc.venc_lock);\r\n}\r\nstatic void venc_invert_vid_out_polarity(struct omap_dss_device *dssdev,\r\nbool invert_polarity)\r\n{\r\nmutex_lock(&venc.venc_lock);\r\nvenc.invert_polarity = invert_polarity;\r\nmutex_unlock(&venc.venc_lock);\r\n}\r\nstatic int venc_init_regulator(void)\r\n{\r\nstruct regulator *vdda_dac;\r\nif (venc.vdda_dac_reg != NULL)\r\nreturn 0;\r\nif (venc.pdev->dev.of_node)\r\nvdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");\r\nelse\r\nvdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda_dac");\r\nif (IS_ERR(vdda_dac)) {\r\nif (PTR_ERR(vdda_dac) != -EPROBE_DEFER)\r\nDSSERR("can't get VDDA_DAC regulator\n");\r\nreturn PTR_ERR(vdda_dac);\r\n}\r\nvenc.vdda_dac_reg = vdda_dac;\r\nreturn 0;\r\n}\r\nstatic void venc_dump_regs(struct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(r))\r\nif (venc_runtime_get())\r\nreturn;\r\nDUMPREG(VENC_F_CONTROL);\r\nDUMPREG(VENC_VIDOUT_CTRL);\r\nDUMPREG(VENC_SYNC_CTRL);\r\nDUMPREG(VENC_LLEN);\r\nDUMPREG(VENC_FLENS);\r\nDUMPREG(VENC_HFLTR_CTRL);\r\nDUMPREG(VENC_CC_CARR_WSS_CARR);\r\nDUMPREG(VENC_C_PHASE);\r\nDUMPREG(VENC_GAIN_U);\r\nDUMPREG(VENC_GAIN_V);\r\nDUMPREG(VENC_GAIN_Y);\r\nDUMPREG(VENC_BLACK_LEVEL);\r\nDUMPREG(VENC_BLANK_LEVEL);\r\nDUMPREG(VENC_X_COLOR);\r\nDUMPREG(VENC_M_CONTROL);\r\nDUMPREG(VENC_BSTAMP_WSS_DATA);\r\nDUMPREG(VENC_S_CARR);\r\nDUMPREG(VENC_LINE21);\r\nDUMPREG(VENC_LN_SEL);\r\nDUMPREG(VENC_L21__WC_CTL);\r\nDUMPREG(VENC_HTRIGGER_VTRIGGER);\r\nDUMPREG(VENC_SAVID__EAVID);\r\nDUMPREG(VENC_FLEN__FAL);\r\nDUMPREG(VENC_LAL__PHASE_RESET);\r\nDUMPREG(VENC_HS_INT_START_STOP_X);\r\nDUMPREG(VENC_HS_EXT_START_STOP_X);\r\nDUMPREG(VENC_VS_INT_START_X);\r\nDUMPREG(VENC_VS_INT_STOP_X__VS_INT_START_Y);\r\nDUMPREG(VENC_VS_INT_STOP_Y__VS_EXT_START_X);\r\nDUMPREG(VENC_VS_EXT_STOP_X__VS_EXT_START_Y);\r\nDUMPREG(VENC_VS_EXT_STOP_Y);\r\nDUMPREG(VENC_AVID_START_STOP_X);\r\nDUMPREG(VENC_AVID_START_STOP_Y);\r\nDUMPREG(VENC_FID_INT_START_X__FID_INT_START_Y);\r\nDUMPREG(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);\r\nDUMPREG(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);\r\nDUMPREG(VENC_TVDETGP_INT_START_STOP_X);\r\nDUMPREG(VENC_TVDETGP_INT_START_STOP_Y);\r\nDUMPREG(VENC_GEN_CTRL);\r\nDUMPREG(VENC_OUTPUT_CONTROL);\r\nDUMPREG(VENC_OUTPUT_TEST);\r\nvenc_runtime_put();\r\n#undef DUMPREG\r\n}\r\nstatic int venc_get_clocks(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nif (dss_has_feature(FEAT_VENC_REQUIRES_TV_DAC_CLK)) {\r\nclk = devm_clk_get(&pdev->dev, "tv_dac_clk");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get tv_dac_clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\n} else {\r\nclk = NULL;\r\n}\r\nvenc.tv_dac_clk = clk;\r\nreturn 0;\r\n}\r\nstatic int venc_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nstruct omap_overlay_manager *mgr;\r\nint r;\r\nr = venc_init_regulator();\r\nif (r)\r\nreturn r;\r\nmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\r\nif (!mgr)\r\nreturn -ENODEV;\r\nr = dss_mgr_connect(mgr, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndst->name);\r\ndss_mgr_disconnect(mgr, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void venc_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\nif (dssdev->manager)\r\ndss_mgr_disconnect(dssdev->manager, dssdev);\r\n}\r\nstatic void venc_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &venc.output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_VENC;\r\nout->output_type = OMAP_DISPLAY_TYPE_VENC;\r\nout->name = "venc.0";\r\nout->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;\r\nout->ops.atv = &venc_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void venc_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &venc.output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int venc_probe_of(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *ep;\r\nu32 channels;\r\nint r;\r\nep = omapdss_of_get_first_endpoint(node);\r\nif (!ep)\r\nreturn 0;\r\nvenc.invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");\r\nr = of_property_read_u32(ep, "ti,channels", &channels);\r\nif (r) {\r\ndev_err(&pdev->dev,\r\n"failed to read property 'ti,channels': %d\n", r);\r\ngoto err;\r\n}\r\nswitch (channels) {\r\ncase 1:\r\nvenc.type = OMAP_DSS_VENC_TYPE_COMPOSITE;\r\nbreak;\r\ncase 2:\r\nvenc.type = OMAP_DSS_VENC_TYPE_SVIDEO;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "bad channel propert '%d'\n", channels);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nof_node_put(ep);\r\nreturn 0;\r\nerr:\r\nof_node_put(ep);\r\nreturn 0;\r\n}\r\nstatic int venc_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nu8 rev_id;\r\nstruct resource *venc_mem;\r\nint r;\r\nvenc.pdev = pdev;\r\nmutex_init(&venc.venc_lock);\r\nvenc.wss_data = 0;\r\nvenc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);\r\nif (!venc_mem) {\r\nDSSERR("can't get IORESOURCE_MEM VENC\n");\r\nreturn -EINVAL;\r\n}\r\nvenc.base = devm_ioremap(&pdev->dev, venc_mem->start,\r\nresource_size(venc_mem));\r\nif (!venc.base) {\r\nDSSERR("can't ioremap VENC\n");\r\nreturn -ENOMEM;\r\n}\r\nr = venc_get_clocks(pdev);\r\nif (r)\r\nreturn r;\r\npm_runtime_enable(&pdev->dev);\r\nr = venc_runtime_get();\r\nif (r)\r\ngoto err_runtime_get;\r\nrev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);\r\ndev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);\r\nvenc_runtime_put();\r\nif (pdev->dev.of_node) {\r\nr = venc_probe_of(pdev);\r\nif (r) {\r\nDSSERR("Invalid DT data\n");\r\ngoto err_probe_of;\r\n}\r\n}\r\ndss_debugfs_create_file("venc", venc_dump_regs);\r\nvenc_init_output(pdev);\r\nreturn 0;\r\nerr_probe_of:\r\nerr_runtime_get:\r\npm_runtime_disable(&pdev->dev);\r\nreturn r;\r\n}\r\nstatic void venc_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nvenc_uninit_output(pdev);\r\npm_runtime_disable(&pdev->dev);\r\n}\r\nstatic int venc_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &venc_component_ops);\r\n}\r\nstatic int venc_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &venc_component_ops);\r\nreturn 0;\r\n}\r\nstatic int venc_runtime_suspend(struct device *dev)\r\n{\r\nif (venc.tv_dac_clk)\r\nclk_disable_unprepare(venc.tv_dac_clk);\r\ndispc_runtime_put();\r\nreturn 0;\r\n}\r\nstatic int venc_runtime_resume(struct device *dev)\r\n{\r\nint r;\r\nr = dispc_runtime_get();\r\nif (r < 0)\r\nreturn r;\r\nif (venc.tv_dac_clk)\r\nclk_prepare_enable(venc.tv_dac_clk);\r\nreturn 0;\r\n}\r\nint __init venc_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_venchw_driver);\r\n}\r\nvoid venc_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_venchw_driver);\r\n}
