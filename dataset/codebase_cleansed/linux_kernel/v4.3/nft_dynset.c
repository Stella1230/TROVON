static void *nft_dynset_new(struct nft_set *set, const struct nft_expr *expr,\r\nstruct nft_regs *regs)\r\n{\r\nconst struct nft_dynset *priv = nft_expr_priv(expr);\r\nstruct nft_set_ext *ext;\r\nu64 timeout;\r\nvoid *elem;\r\nif (set->size && !atomic_add_unless(&set->nelems, 1, set->size))\r\nreturn NULL;\r\ntimeout = priv->timeout ? : set->timeout;\r\nelem = nft_set_elem_init(set, &priv->tmpl,\r\n&regs->data[priv->sreg_key],\r\n&regs->data[priv->sreg_data],\r\ntimeout, GFP_ATOMIC);\r\nif (elem == NULL) {\r\nif (set->size)\r\natomic_dec(&set->nelems);\r\nreturn NULL;\r\n}\r\next = nft_set_elem_ext(set, elem);\r\nif (priv->expr != NULL)\r\nnft_expr_clone(nft_set_ext_expr(ext), priv->expr);\r\nreturn elem;\r\n}\r\nstatic void nft_dynset_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_dynset *priv = nft_expr_priv(expr);\r\nstruct nft_set *set = priv->set;\r\nconst struct nft_set_ext *ext;\r\nconst struct nft_expr *sexpr;\r\nu64 timeout;\r\nif (set->ops->update(set, &regs->data[priv->sreg_key], nft_dynset_new,\r\nexpr, regs, &ext)) {\r\nsexpr = NULL;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPR))\r\nsexpr = nft_set_ext_expr(ext);\r\nif (priv->op == NFT_DYNSET_OP_UPDATE &&\r\nnft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\r\ntimeout = priv->timeout ? : set->timeout;\r\n*nft_set_ext_expiration(ext) = jiffies + timeout;\r\n} else if (sexpr == NULL)\r\ngoto out;\r\nif (sexpr != NULL)\r\nsexpr->ops->eval(sexpr, regs, pkt);\r\nreturn;\r\n}\r\nout:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_dynset_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_dynset *priv = nft_expr_priv(expr);\r\nstruct nft_set *set;\r\nu64 timeout;\r\nint err;\r\nif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\r\ntb[NFTA_DYNSET_OP] == NULL ||\r\ntb[NFTA_DYNSET_SREG_KEY] == NULL)\r\nreturn -EINVAL;\r\nset = nf_tables_set_lookup(ctx->table, tb[NFTA_DYNSET_SET_NAME]);\r\nif (IS_ERR(set)) {\r\nif (tb[NFTA_DYNSET_SET_ID])\r\nset = nf_tables_set_lookup_byid(ctx->net,\r\ntb[NFTA_DYNSET_SET_ID]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\n}\r\nif (set->flags & NFT_SET_CONSTANT)\r\nreturn -EBUSY;\r\npriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\r\nswitch (priv->op) {\r\ncase NFT_DYNSET_OP_ADD:\r\nbreak;\r\ncase NFT_DYNSET_OP_UPDATE:\r\nif (!(set->flags & NFT_SET_TIMEOUT))\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\ntimeout = 0;\r\nif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\r\nif (!(set->flags & NFT_SET_TIMEOUT))\r\nreturn -EINVAL;\r\ntimeout = be64_to_cpu(nla_get_be64(tb[NFTA_DYNSET_TIMEOUT]));\r\n}\r\npriv->sreg_key = nft_parse_register(tb[NFTA_DYNSET_SREG_KEY]);\r\nerr = nft_validate_register_load(priv->sreg_key, set->klen);;\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\r\nif (!(set->flags & NFT_SET_MAP))\r\nreturn -EINVAL;\r\nif (set->dtype == NFT_DATA_VERDICT)\r\nreturn -EOPNOTSUPP;\r\npriv->sreg_data = nft_parse_register(tb[NFTA_DYNSET_SREG_DATA]);\r\nerr = nft_validate_register_load(priv->sreg_data, set->dlen);\r\nif (err < 0)\r\nreturn err;\r\n} else if (set->flags & NFT_SET_MAP)\r\nreturn -EINVAL;\r\nif (tb[NFTA_DYNSET_EXPR] != NULL) {\r\nif (!(set->flags & NFT_SET_EVAL))\r\nreturn -EINVAL;\r\nif (!(set->flags & NFT_SET_ANONYMOUS))\r\nreturn -EOPNOTSUPP;\r\npriv->expr = nft_expr_init(ctx, tb[NFTA_DYNSET_EXPR]);\r\nif (IS_ERR(priv->expr))\r\nreturn PTR_ERR(priv->expr);\r\nerr = -EOPNOTSUPP;\r\nif (!(priv->expr->ops->type->flags & NFT_EXPR_STATEFUL))\r\ngoto err1;\r\n} else if (set->flags & NFT_SET_EVAL)\r\nreturn -EINVAL;\r\nnft_set_ext_prepare(&priv->tmpl);\r\nnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\r\nif (set->flags & NFT_SET_MAP)\r\nnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\r\nif (priv->expr != NULL)\r\nnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_EXPR,\r\npriv->expr->ops->size);\r\nif (set->flags & NFT_SET_TIMEOUT) {\r\nif (timeout || set->timeout)\r\nnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\r\n}\r\npriv->timeout = timeout;\r\nerr = nf_tables_bind_set(ctx, set, &priv->binding);\r\nif (err < 0)\r\ngoto err1;\r\npriv->set = set;\r\nreturn 0;\r\nerr1:\r\nif (priv->expr != NULL)\r\nnft_expr_destroy(ctx, priv->expr);\r\nreturn err;\r\n}\r\nstatic void nft_dynset_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_dynset *priv = nft_expr_priv(expr);\r\nnf_tables_unbind_set(ctx, priv->set, &priv->binding);\r\nif (priv->expr != NULL)\r\nnft_expr_destroy(ctx, priv->expr);\r\n}\r\nstatic int nft_dynset_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_dynset *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_DYNSET_SREG_KEY, priv->sreg_key))\r\ngoto nla_put_failure;\r\nif (priv->set->flags & NFT_SET_MAP &&\r\nnft_dump_register(skb, NFTA_DYNSET_SREG_DATA, priv->sreg_data))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_DYNSET_OP, htonl(priv->op)))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT, cpu_to_be64(priv->timeout)))\r\ngoto nla_put_failure;\r\nif (priv->expr && nft_expr_dump(skb, NFTA_DYNSET_EXPR, priv->expr))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint __init nft_dynset_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_dynset_type);\r\n}\r\nvoid nft_dynset_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_dynset_type);\r\n}
