static void rtw_2g_channels_init(struct ieee80211_channel *channels)\r\n{\r\nmemcpy((void *)channels, (void *)rtw_2ghz_channels,\r\nsizeof(struct ieee80211_channel) * RTW_2G_CHANNELS_NUM);\r\n}\r\nstatic void rtw_5g_channels_init(struct ieee80211_channel *channels)\r\n{\r\nmemcpy((void *)channels, (void *)rtw_5ghz_a_channels,\r\nsizeof(struct ieee80211_channel) * RTW_5G_CHANNELS_NUM);\r\n}\r\nstatic void rtw_2g_rates_init(struct ieee80211_rate *rates)\r\n{\r\nmemcpy(rates, rtw_g_rates,\r\nsizeof(struct ieee80211_rate) * RTW_G_RATES_NUM);\r\n}\r\nstatic void rtw_5g_rates_init(struct ieee80211_rate *rates)\r\n{\r\nmemcpy(rates, rtw_a_rates,\r\nsizeof(struct ieee80211_rate) * RTW_A_RATES_NUM);\r\n}\r\nstatic struct ieee80211_supported_band *\r\nrtw_spt_band_alloc(enum ieee80211_band band)\r\n{\r\nstruct ieee80211_supported_band *spt_band = NULL;\r\nint n_channels, n_bitrates;\r\nif (band == IEEE80211_BAND_2GHZ) {\r\nn_channels = RTW_2G_CHANNELS_NUM;\r\nn_bitrates = RTW_G_RATES_NUM;\r\n} else if (band == IEEE80211_BAND_5GHZ) {\r\nn_channels = RTW_5G_CHANNELS_NUM;\r\nn_bitrates = RTW_A_RATES_NUM;\r\n} else {\r\ngoto exit;\r\n}\r\nspt_band = kzalloc(sizeof(struct ieee80211_supported_band) +\r\nsizeof(struct ieee80211_channel) * n_channels +\r\nsizeof(struct ieee80211_rate) * n_bitrates,\r\nGFP_KERNEL);\r\nif (!spt_band)\r\ngoto exit;\r\nspt_band->channels =\r\n(struct ieee80211_channel *)(((u8 *) spt_band) +\r\nsizeof(struct\r\nieee80211_supported_band));\r\nspt_band->bitrates =\r\n(struct ieee80211_rate *)(((u8 *) spt_band->channels) +\r\nsizeof(struct ieee80211_channel) *\r\nn_channels);\r\nspt_band->band = band;\r\nspt_band->n_channels = n_channels;\r\nspt_band->n_bitrates = n_bitrates;\r\nif (band == IEEE80211_BAND_2GHZ) {\r\nrtw_2g_channels_init(spt_band->channels);\r\nrtw_2g_rates_init(spt_band->bitrates);\r\n} else if (band == IEEE80211_BAND_5GHZ) {\r\nrtw_5g_channels_init(spt_band->channels);\r\nrtw_5g_rates_init(spt_band->bitrates);\r\n}\r\nexit:\r\nreturn spt_band;\r\n}\r\nstatic int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter,\r\nstruct wlan_network *pnetwork)\r\n{\r\nint ret = 0;\r\nstruct ieee80211_channel *notify_channel;\r\nstruct cfg80211_bss *bss;\r\nu16 channel;\r\nu32 freq;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nstruct wireless_dev *wdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nchannel = pnetwork->network.DSConfig;\r\nif (channel <= RTW_CH_MAX_2G_CHANNEL)\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_2GHZ);\r\nelse\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_5GHZ);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_ie = pnetwork->network.IEs;\r\nnotify_ielen = pnetwork->network.IELength;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) &&\r\nis_same_network23a(&pmlmepriv->cur_network.network,\r\n&pnetwork->network)) {\r\nnotify_signal = 100 * translate_percentage_to_dbm(padapter->recvpriv.signal_strength);\r\n} else {\r\nnotify_signal = 100 * translate_percentage_to_dbm(\r\npnetwork->network.SignalStrength);\r\n}\r\nbss = cfg80211_inform_bss(wiphy, notify_channel,\r\nCFG80211_BSS_FTYPE_UNKNOWN,\r\npnetwork->network.MacAddress,\r\npnetwork->network.tsf,\r\npnetwork->network.capability,\r\npnetwork->network.beacon_interval,\r\nnotify_ie, notify_ielen,\r\nnotify_signal, GFP_ATOMIC);\r\nif (unlikely(!bss)) {\r\nDBG_8723A("rtw_cfg80211_inform_bss error\n");\r\nreturn -EINVAL;\r\n}\r\ncfg80211_put_bss(wiphy, bss);\r\nreturn ret;\r\n}\r\nvoid rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nDBG_8723A("%s(padapter =%p)\n", __func__, padapter);\r\nif (pwdev->iftype != NL80211_IFTYPE_STATION &&\r\npwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\r\nreturn;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nreturn;\r\nif (padapter->mlmepriv.to_roaming > 0) {\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nstruct ieee80211_channel *notify_channel;\r\nu32 freq;\r\nu16 channel = cur_network->network.DSConfig;\r\nif (channel <= RTW_CH_MAX_2G_CHANNEL)\r\nfreq =\r\nieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_2GHZ);\r\nelse\r\nfreq =\r\nieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_5GHZ);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nDBG_8723A("%s call cfg80211_roamed\n", __func__);\r\ncfg80211_roamed(padapter->pnetdev, notify_channel,\r\ncur_network->network.MacAddress,\r\npmlmepriv->assoc_req +\r\nsizeof(struct ieee80211_hdr_3addr) + 2,\r\npmlmepriv->assoc_req_len -\r\nsizeof(struct ieee80211_hdr_3addr) - 2,\r\npmlmepriv->assoc_rsp +\r\nsizeof(struct ieee80211_hdr_3addr) + 6,\r\npmlmepriv->assoc_rsp_len -\r\nsizeof(struct ieee80211_hdr_3addr) - 6,\r\nGFP_ATOMIC);\r\n} else {\r\ncfg80211_connect_result(padapter->pnetdev,\r\ncur_network->network.MacAddress,\r\npmlmepriv->assoc_req +\r\nsizeof(struct ieee80211_hdr_3addr) + 2,\r\npmlmepriv->assoc_req_len -\r\nsizeof(struct ieee80211_hdr_3addr) - 2,\r\npmlmepriv->assoc_rsp +\r\nsizeof(struct ieee80211_hdr_3addr) + 6,\r\npmlmepriv->assoc_rsp_len -\r\nsizeof(struct ieee80211_hdr_3addr) - 6,\r\nWLAN_STATUS_SUCCESS, GFP_ATOMIC);\r\n}\r\n}\r\nvoid rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nDBG_8723A("%s(padapter =%p)\n", __func__, padapter);\r\nif (pwdev->iftype != NL80211_IFTYPE_STATION &&\r\npwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\r\nreturn;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nreturn;\r\nif (!padapter->mlmepriv.not_indic_disco) {\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING)) {\r\ncfg80211_connect_result(padapter->pnetdev, NULL, NULL,\r\n0, NULL, 0,\r\nWLAN_STATUS_UNSPECIFIED_FAILURE,\r\nGFP_ATOMIC);\r\n} else {\r\ncfg80211_disconnected(padapter->pnetdev, 0, NULL,\r\n0, false, GFP_ATOMIC);\r\n}\r\n}\r\n}\r\nstatic int set_pairwise_key(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct set_stakey_parm *psetstakey_para;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nint res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_para = kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);\r\nif (psetstakey_para == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\r\npsetstakey_para->algorithm = psta->dot118021XPrivacy;\r\nether_addr_copy(psetstakey_para->addr, psta->hwaddr);\r\nmemcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);\r\nres = rtw_enqueue_cmd23a(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int set_group_key(struct rtw_adapter *padapter, struct key_params *parms,\r\nu32 alg, u8 keyid)\r\n{\r\nstruct cmd_obj *pcmd;\r\nstruct setkey_parm *psetkeyparm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nint res = _SUCCESS;\r\nDBG_8723A("%s\n", __func__);\r\nif (keyid >= 4) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (!pcmd) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetkeyparm = kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);\r\nif (!psetkeyparm) {\r\nkfree(pcmd);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetkeyparm->keyid = keyid;\r\nif (is_wep_enc(alg))\r\npadapter->mlmepriv.key_mask |= BIT(psetkeyparm->keyid);\r\npsetkeyparm->algorithm = alg;\r\npsetkeyparm->set_tx = 1;\r\nmemcpy(&psetkeyparm->key, parms->key, parms->key_len);\r\npcmd->cmdcode = _SetKey_CMD_;\r\npcmd->parmbuf = (u8 *) psetkeyparm;\r\npcmd->cmdsz = (sizeof(struct setkey_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nres = rtw_enqueue_cmd23a(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int rtw_cfg80211_ap_set_encryption(struct net_device *dev, u8 key_index,\r\nint set_tx, const u8 *sta_addr,\r\nstruct key_params *keyparms)\r\n{\r\nint key_len;\r\nstruct sta_info *psta = NULL, *pbcmc_sta = NULL;\r\nstruct rtw_adapter *padapter = netdev_priv(dev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_8723A("%s\n", __func__);\r\nif (!is_broadcast_ether_addr(sta_addr)) {\r\npsta = rtw_get_stainfo23a(pstapriv, sta_addr);\r\nif (!psta) {\r\nDBG_8723A("rtw_set_encryption(), sta has already "\r\n"been removed or never been added\n");\r\ngoto exit;\r\n}\r\n}\r\nkey_len = keyparms->key_len;\r\nif (!psta && (keyparms->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkeyparms->cipher == WLAN_CIPHER_SUITE_WEP104)) {\r\nDBG_8723A("r871x_set_encryption, crypt.alg = WEP\n");\r\nDBG_8723A("r871x_set_encryption, wep_key_idx =%d, len =%d\n",\r\nkey_index, key_len);\r\nif (psecuritypriv->bWepDefaultKeyIdxSet == 0) {\r\npsecuritypriv->ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;\r\npsecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;\r\npsecuritypriv->dot11PrivacyKeyIndex = key_index;\r\n}\r\nmemcpy(&psecuritypriv->wep_key[key_index].key,\r\nkeyparms->key, key_len);\r\npsecuritypriv->wep_key[key_index].keylen = key_len;\r\nset_group_key(padapter, keyparms, keyparms->cipher, key_index);\r\ngoto exit;\r\n}\r\nif (!psta) {\r\nif (set_tx == 0) {\r\nif (keyparms->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkeyparms->cipher == WLAN_CIPHER_SUITE_WEP104) {\r\nDBG_8723A("%s, set group_key, WEP\n", __func__);\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key, key_len);\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nkeyparms->cipher;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_TKIP) {\r\nDBG_8723A("%s, set group_key, TKIP\n",\r\n__func__);\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_TKIP;\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\nmemcpy(psecuritypriv->\r\ndot118021XGrptxmickey[key_index].skey,\r\n&keyparms->key[16], 8);\r\nmemcpy(psecuritypriv->\r\ndot118021XGrprxmickey[key_index].skey,\r\n&keyparms->key[24], 8);\r\npsecuritypriv->busetkipkey = 1;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_CCMP) {\r\nDBG_8723A("%s, set group_key, CCMP\n",\r\n__func__);\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_CCMP;\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\n} else {\r\nDBG_8723A("%s, set group_key, none\n",\r\n__func__);\r\npsecuritypriv->dot118021XGrpPrivacy = 0;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = key_index;\r\npsecuritypriv->binstallGrpkey = 1;\r\npsecuritypriv->dot11PrivacyAlgrthm =\r\npsecuritypriv->dot118021XGrpPrivacy;\r\nset_group_key(padapter, keyparms,\r\npsecuritypriv->dot118021XGrpPrivacy,\r\nkey_index);\r\npbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);\r\nif (pbcmc_sta) {\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy =\r\npsecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\ngoto exit;\r\n}\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) {\r\nif (set_tx == 1) {\r\nmemcpy(psta->dot118021x_UncstKey.skey,\r\nkeyparms->key, (key_len > 16 ? 16 : key_len));\r\nif (keyparms->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkeyparms->cipher == WLAN_CIPHER_SUITE_WEP104) {\r\nDBG_8723A("%s, set pairwise key, WEP\n",\r\n__func__);\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nkeyparms->cipher;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_TKIP) {\r\nDBG_8723A("%s, set pairwise key, TKIP\n",\r\n__func__);\r\npsta->dot118021XPrivacy =\r\nWLAN_CIPHER_SUITE_TKIP;\r\nmemcpy(psta->dot11tkiptxmickey.skey,\r\n&keyparms->key[16], 8);\r\nmemcpy(psta->dot11tkiprxmickey.skey,\r\n&keyparms->key[24], 8);\r\npsecuritypriv->busetkipkey = 1;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_CCMP) {\r\nDBG_8723A("%s, set pairwise key, CCMP\n",\r\n__func__);\r\npsta->dot118021XPrivacy =\r\nWLAN_CIPHER_SUITE_CCMP;\r\n} else {\r\nDBG_8723A("%s, set pairwise key, none\n",\r\n__func__);\r\npsta->dot118021XPrivacy = 0;\r\n}\r\nset_pairwise_key(padapter, psta);\r\npsta->ieee8021x_blocked = false;\r\npsta->bpairwise_key_installed = true;\r\n} else {\r\nif (keyparms->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkeyparms->cipher == WLAN_CIPHER_SUITE_WEP104) {\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key, key_len);\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nkeyparms->cipher;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_TKIP) {\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_TKIP;\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\nmemcpy(psecuritypriv->\r\ndot118021XGrptxmickey[key_index].skey,\r\n&keyparms->key[16], 8);\r\nmemcpy(psecuritypriv->\r\ndot118021XGrprxmickey[key_index].skey,\r\n&keyparms->key[24], 8);\r\npsecuritypriv->busetkipkey = 1;\r\n} else if (keyparms->cipher == WLAN_CIPHER_SUITE_CCMP) {\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_CCMP;\r\nmemcpy(psecuritypriv->\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\n} else {\r\npsecuritypriv->dot118021XGrpPrivacy = 0;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = key_index;\r\npsecuritypriv->binstallGrpkey = 1;\r\npsecuritypriv->dot11PrivacyAlgrthm =\r\npsecuritypriv->dot118021XGrpPrivacy;\r\nset_group_key(padapter, keyparms,\r\npsecuritypriv->dot118021XGrpPrivacy,\r\nkey_index);\r\npbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);\r\nif (pbcmc_sta) {\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy =\r\npsecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\n}\r\nexit:\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_encryption(struct net_device *dev, u8 key_index,\r\nint set_tx, const u8 *sta_addr,\r\nstruct key_params *keyparms)\r\n{\r\nint ret = 0;\r\nint key_len;\r\nstruct rtw_adapter *padapter = netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s\n", __func__);\r\nkey_len = keyparms->key_len;\r\nif (keyparms->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkeyparms->cipher == WLAN_CIPHER_SUITE_WEP104) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,\r\n"wpa_set_encryption, crypt.alg = WEP\n");\r\nDBG_8723A("wpa_set_encryption, crypt.alg = WEP\n");\r\nif (psecuritypriv->bWepDefaultKeyIdxSet == 0) {\r\npsecuritypriv->ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;\r\npsecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;\r\npsecuritypriv->dot11PrivacyKeyIndex = key_index;\r\n}\r\nmemcpy(&psecuritypriv->wep_key[key_index].key,\r\nkeyparms->key, key_len);\r\npsecuritypriv->wep_key[key_index].keylen = key_len;\r\nrtw_set_key23a(padapter, psecuritypriv, key_index, 0);\r\ngoto exit;\r\n}\r\nif (padapter->securitypriv.dot11AuthAlgrthm ==\r\ndot11AuthAlgrthm_8021X) {\r\nstruct sta_info *psta, *pbcmc_sta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (check_fwstate(pmlmepriv,\r\nWIFI_STATION_STATE | WIFI_MP_STATE)) {\r\npsta = rtw_get_stainfo23a(pstapriv, get_bssid(pmlmepriv));\r\nif (psta == NULL) {\r\nDBG_8723A("%s, : Obtain Sta_info fail\n",\r\n__func__);\r\n} else {\r\nif (keyparms->cipher != IW_AUTH_CIPHER_NONE &&\r\nkeyparms->cipher != 0)\r\npsta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption3Enabled)) {\r\npsta->dot118021XPrivacy =\r\npadapter->securitypriv.\r\ndot11PrivacyAlgrthm;\r\n}\r\nif (set_tx == 1) {\r\nDBG_8723A("%s, : set_tx == 1\n",\r\n__func__);\r\nmemcpy(psta->dot118021x_UncstKey.skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\nif (keyparms->cipher ==\r\nWLAN_CIPHER_SUITE_TKIP) {\r\nmemcpy(psta->dot11tkiptxmickey.\r\nskey,\r\n&keyparms->key[16], 8);\r\nmemcpy(psta->dot11tkiprxmickey.\r\nskey,\r\n&keyparms->key[24], 8);\r\npadapter->securitypriv.\r\nbusetkipkey = 0;\r\n}\r\nDBG_8723A(" ~~~~set sta key:unicastkey\n");\r\nrtw_setstakey_cmd23a(padapter,\r\n(unsigned char *)psta,\r\ntrue);\r\n} else {\r\nmemcpy(padapter->securitypriv.\r\ndot118021XGrpKey[key_index].skey,\r\nkeyparms->key,\r\n(key_len > 16 ? 16 : key_len));\r\nmemcpy(padapter->securitypriv.\r\ndot118021XGrptxmickey[key_index].\r\nskey, &keyparms->key[16], 8);\r\nmemcpy(padapter->securitypriv.\r\ndot118021XGrprxmickey[key_index].\r\nskey, &keyparms->key[24], 8);\r\npadapter->securitypriv.binstallGrpkey =\r\n1;\r\nDBG_8723A\r\n(" ~~~~set sta key:groupkey\n");\r\npadapter->securitypriv.\r\ndot118021XGrpKeyid = key_index;\r\nrtw_set_key23a(padapter,\r\n&padapter->securitypriv,\r\nkey_index, 1);\r\n}\r\n}\r\npbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);\r\nif (pbcmc_sta) {\r\nif (keyparms->cipher != IW_AUTH_CIPHER_NONE &&\r\nkeyparms->cipher != 0)\r\npbcmc_sta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption3Enabled)) {\r\npbcmc_sta->dot118021XPrivacy =\r\npadapter->securitypriv.\r\ndot11PrivacyAlgrthm;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nDBG_8723A("%s, ret =%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr, struct key_params *params)\r\n{\r\nint set_tx, ret = 0;\r\nstruct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 sta_addr[ETH_ALEN];\r\nDBG_8723A("%s(%s): adding key for %pM\n", __func__, ndev->name,\r\nmac_addr);\r\nDBG_8723A("cipher = 0x%x\n", params->cipher);\r\nDBG_8723A("key_len = 0x%x\n", params->key_len);\r\nDBG_8723A("seq_len = 0x%x\n", params->seq_len);\r\nDBG_8723A("key_index =%d\n", key_index);\r\nDBG_8723A("pairwise =%d\n", pairwise);\r\nswitch (params->cipher) {\r\ncase IW_AUTH_CIPHER_NONE:\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nif (params->key_len != WLAN_KEY_LEN_WEP40) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nif (params->key_len != WLAN_KEY_LEN_WEP104) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\nif (key_index >= WEP_KEYS || params->key_len < 0) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\neth_broadcast_addr(sta_addr);\r\nif (!mac_addr || is_broadcast_ether_addr(mac_addr))\r\nset_tx = 0;\r\nelse\r\nset_tx = 1;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nret = rtw_cfg80211_set_encryption(ndev, key_index, set_tx,\r\nsta_addr, params);\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nif (mac_addr)\r\nether_addr_copy(sta_addr, mac_addr);\r\nret = rtw_cfg80211_ap_set_encryption(ndev, key_index, set_tx,\r\nsta_addr, params);\r\n#endif\r\n} else {\r\nDBG_8723A("error! fw_state = 0x%x, iftype =%d\n",\r\npmlmepriv->fw_state, rtw_wdev->iftype);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int\r\ncfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr,\r\nvoid *cookie,\r\nvoid (*callback) (void *cookie, struct key_params *))\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr)\r\n{\r\nstruct rtw_adapter *padapter = netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s(%s): key_index =%d\n", __func__, ndev->name, key_index);\r\nif (key_index == psecuritypriv->dot11PrivacyKeyIndex) {\r\npsecuritypriv->bWepDefaultKeyIdxSet = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_default_key(struct wiphy *wiphy,\r\nstruct net_device *ndev, u8 key_index,\r\nbool unicast, bool multicast)\r\n{\r\nstruct rtw_adapter *padapter = netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s(%s): key_index =%d, unicast =%d, multicast =%d.\n",\r\n__func__, ndev->name, key_index, unicast, multicast);\r\nif (key_index < NUM_WEP_KEYS &&\r\n(psecuritypriv->dot11PrivacyAlgrthm == WLAN_CIPHER_SUITE_WEP40 ||\r\npsecuritypriv->dot11PrivacyAlgrthm == WLAN_CIPHER_SUITE_WEP104)) {\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyKeyIndex = key_index;\r\npsecuritypriv->dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_WEP40;\r\npsecuritypriv->dot118021XGrpPrivacy = WLAN_CIPHER_SUITE_WEP40;\r\nif (psecuritypriv->wep_key[key_index].keylen == 13) {\r\npsecuritypriv->dot11PrivacyAlgrthm =\r\nWLAN_CIPHER_SUITE_WEP104;\r\npsecuritypriv->dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_WEP104;\r\n}\r\npsecuritypriv->bWepDefaultKeyIdxSet = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 rtw_get_cur_max_rate(struct rtw_adapter *adapter)\r\n{\r\nint i = 0;\r\nconst u8 *p;\r\nu16 rate = 0, max_rate = 0;\r\nstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nstruct ieee80211_ht_cap *pht_capie;\r\nu8 rf_type = 0;\r\nu8 bw_40MHz = 0, short_GI_20 = 0, short_GI_40 = 0;\r\nu16 mcs_rate = 0;\r\np = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY,\r\npcur_bss->IEs, pcur_bss->IELength);\r\nif (p && p[1] > 0) {\r\npht_capie = (struct ieee80211_ht_cap *)(p + 2);\r\nmemcpy(&mcs_rate, &pht_capie->mcs, 2);\r\nbw_40MHz = (pmlmeext->cur_bwmode &&\r\n(pmlmeinfo->HT_info.ht_param &\r\nIEEE80211_HT_PARAM_CHAN_WIDTH_ANY)) ? 1:0;\r\nshort_GI_20 = (pmlmeinfo->ht_cap.cap_info &\r\ncpu_to_le16(IEEE80211_HT_CAP_SGI_20)) ? 1:0;\r\nshort_GI_40 = (pmlmeinfo->ht_cap.cap_info &\r\ncpu_to_le16(IEEE80211_HT_CAP_SGI_40)) ? 1:0;\r\nrf_type = rtl8723a_get_rf_type(adapter);\r\nmax_rate = rtw_mcs_rate23a(rf_type, bw_40MHz &\r\npregistrypriv->cbw40_enable,\r\nshort_GI_20, short_GI_40,\r\n&pmlmeinfo->ht_cap.mcs);\r\n} else {\r\nwhile (pcur_bss->SupportedRates[i] != 0 &&\r\npcur_bss->SupportedRates[i] != 0xFF) {\r\nrate = pcur_bss->SupportedRates[i] & 0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\ni++;\r\n}\r\nmax_rate = max_rate * 10 / 2;\r\n}\r\nreturn max_rate;\r\n}\r\nstatic int cfg80211_rtw_get_station(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nconst u8 *mac, struct station_info *sinfo)\r\n{\r\nint ret = 0;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nsinfo->filled = 0;\r\nif (!mac) {\r\nDBG_8723A("%s(%s): mac ==%p\n", __func__, ndev->name, mac);\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\npsta = rtw_get_stainfo23a(pstapriv, mac);\r\nif (psta == NULL) {\r\nDBG_8723A("%s, sta_info is null\n", __func__);\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\nDBG_8723A("%s(%s): mac=%pM\n", __func__, ndev->name, mac);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) &&\r\ncheck_fwstate(pmlmepriv, _FW_LINKED)) {\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nif (!ether_addr_equal(mac, cur_network->network.MacAddress)) {\r\nDBG_8723A("%s, mismatch bssid=%pM\n",\r\n__func__, cur_network->network.MacAddress);\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\r\nsinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.\r\nsignal_strength);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\r\nsinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\r\nsinfo->rx_packets = sta_rx_data_pkts(psta);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\r\nsinfo->tx_packets = psta->sta_stats.tx_pkts;\r\n}\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_AP_STATE)) &&\r\ncheck_fwstate(pmlmepriv, _FW_LINKED)\r\n) {\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_infrastructure_mode(struct rtw_adapter *padapter,\r\nenum nl80211_iftype ifmode)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nenum nl80211_iftype old_mode;\r\nold_mode = cur_network->network.ifmode;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,\r\n"+%s: old =%d new =%d fw_state = 0x%08x\n", __func__,\r\nold_mode, ifmode, get_fwstate(pmlmepriv));\r\nif (old_mode != ifmode) {\r\nspin_lock_bh(&pmlmepriv->lock);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"change mode!\n");\r\nif (old_mode == NL80211_IFTYPE_AP ||\r\nold_mode == NL80211_IFTYPE_P2P_GO) {\r\ncur_network->join_res = -1;\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nstop_ap_mode23a(padapter);\r\n#endif\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) ||\r\nold_mode == NL80211_IFTYPE_ADHOC)\r\nrtw_disassoc_cmd23a(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE))\r\nrtw_free_assoc_resources23a(padapter, 1);\r\nif (old_mode == NL80211_IFTYPE_STATION ||\r\nold_mode == NL80211_IFTYPE_P2P_CLIENT ||\r\nold_mode == NL80211_IFTYPE_ADHOC) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nrtw_indicate_disconnect23a(padapter);\r\n}\r\n}\r\ncur_network->network.ifmode = ifmode;\r\n_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);\r\nswitch (ifmode) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_STATION:\r\nset_fwstate(pmlmepriv, WIFI_STATION_STATE);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP:\r\nset_fwstate(pmlmepriv, WIFI_AP_STATE);\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nstart_ap_mode23a(padapter);\r\n#endif\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic int cfg80211_rtw_change_iface(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nenum nl80211_iftype old_type;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);\r\nint ret = 0;\r\nDBG_8723A("%s(%s): call netdev_open23a\n", __func__, ndev->name);\r\nold_type = rtw_wdev->iftype;\r\nDBG_8723A("%s(%s): old_iftype =%d, new_iftype =%d\n",\r\n__func__, ndev->name, old_type, type);\r\nif (old_type != type) {\r\npmlmeext->action_public_rxseq = 0xffff;\r\npmlmeext->action_public_dialog_token = 0xff;\r\n}\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nrtw_wdev->iftype = type;\r\nif (cfg80211_infrastructure_mode(padapter, type) != _SUCCESS) {\r\nrtw_wdev->iftype = old_type;\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nrtw_setopmode_cmd23a(padapter, type);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv,\r\nbool aborted)\r\n{\r\nspin_lock_bh(&pwdev_priv->scan_req_lock);\r\nif (pwdev_priv->scan_request != NULL) {\r\nDBG_8723A("%s with scan req\n", __func__);\r\nif (pwdev_priv->scan_request->wiphy !=\r\npwdev_priv->rtw_wdev->wiphy)\r\nDBG_8723A("error wiphy compare\n");\r\nelse\r\ncfg80211_scan_done(pwdev_priv->scan_request, aborted);\r\npwdev_priv->scan_request = NULL;\r\n} else {\r\nDBG_8723A("%s without scan req\n", __func__);\r\n}\r\nspin_unlock_bh(&pwdev_priv->scan_req_lock);\r\n}\r\nvoid rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter)\r\n{\r\nstruct list_head *plist, *phead, *ptmp;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct rtw_queue *queue = &pmlmepriv->scanned_queue;\r\nstruct wlan_network *pnetwork;\r\nspin_lock_bh(&pmlmepriv->scanned_queue.lock);\r\nphead = get_list_head(queue);\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nif (rtw_ch_set_search_ch23a\r\n(padapter->mlmeextpriv.channel_set,\r\npnetwork->network.DSConfig) >= 0)\r\nrtw_cfg80211_inform_bss(padapter, pnetwork);\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\nrtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev),\r\nfalse);\r\n}\r\nstatic int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter,\r\nchar *buf, int len)\r\n{\r\nint ret = 0;\r\nconst u8 *wps_ie;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nDBG_8723A("%s, ielen =%d\n", __func__, len);\r\nif (len > 0) {\r\nwps_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPS,\r\nbuf, len);\r\nif (wps_ie) {\r\nDBG_8723A("probe_req_wps_ielen =%d\n", wps_ie[1]);\r\nif (pmlmepriv->wps_probe_req_ie) {\r\npmlmepriv->wps_probe_req_ie_len = 0;\r\nkfree(pmlmepriv->wps_probe_req_ie);\r\npmlmepriv->wps_probe_req_ie = NULL;\r\n}\r\npmlmepriv->wps_probe_req_ie = kmemdup(wps_ie, wps_ie[1],\r\nGFP_KERNEL);\r\nif (pmlmepriv->wps_probe_req_ie == NULL) {\r\nDBG_8723A("%s()-%d: kmalloc() ERROR!\n",\r\n__func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\npmlmepriv->wps_probe_req_ie_len = wps_ie[1];\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_scan(struct wiphy *wiphy,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nint i;\r\nu8 _status = false;\r\nint ret = 0;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct cfg80211_ssid ssid[RTW_SSID_SCAN_AMOUNT];\r\nstruct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];\r\nstruct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);\r\nstruct cfg80211_ssid *ssids = request->ssids;\r\nbool need_indicate_scan_done = false;\r\nDBG_8723A("%s(%s)\n", __func__, padapter->pnetdev->name);\r\nspin_lock_bh(&pwdev_priv->scan_req_lock);\r\npwdev_priv->scan_request = request;\r\nspin_unlock_bh(&pwdev_priv->scan_req_lock);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nDBG_8723A("%s under WIFI_AP_STATE\n", __func__);\r\n}\r\nif (rtw_pwr_wakeup(padapter) == _FAIL) {\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nif (request->ie && request->ie_len > 0) {\r\nrtw_cfg80211_set_probe_req_wpsp2pie(padapter,\r\n(u8 *) request->ie,\r\nrequest->ie_len);\r\n}\r\nif (pmlmepriv->LinkDetectInfo.bBusyTraffic == true) {\r\nDBG_8723A("%s, bBusyTraffic == true\n", __func__);\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nif (rtw_is_scan_deny(padapter)) {\r\nDBG_8723A("%s(%s): scan deny\n", __func__,\r\npadapter->pnetdev->name);\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING) ==\r\ntrue) {\r\nDBG_8723A("%s, fwstate = 0x%x\n", __func__, pmlmepriv->fw_state);\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nmemset(ssid, 0, sizeof(struct cfg80211_ssid) * RTW_SSID_SCAN_AMOUNT);\r\nfor (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {\r\nDBG_8723A("ssid =%s, len =%d\n", ssids[i].ssid,\r\nssids[i].ssid_len);\r\nmemcpy(ssid[i].ssid, ssids[i].ssid, ssids[i].ssid_len);\r\nssid[i].ssid_len = ssids[i].ssid_len;\r\n}\r\nmemset(ch, 0,\r\nsizeof(struct rtw_ieee80211_channel) * RTW_CHANNEL_SCAN_AMOUNT);\r\nif (request->n_channels == 1) {\r\nfor (i = 0; i < request->n_channels &&\r\ni < RTW_CHANNEL_SCAN_AMOUNT; i++) {\r\nDBG_8723A("%s:(%s):" CHAN_FMT "\n",\r\n__func__, padapter->pnetdev->name,\r\nCHAN_ARG(request->channels[i]));\r\nch[i].hw_value = request->channels[i]->hw_value;\r\nch[i].flags = request->channels[i]->flags;\r\n}\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (request->n_channels == 1) {\r\nmemcpy(&ch[1], &ch[0], sizeof(struct rtw_ieee80211_channel));\r\nmemcpy(&ch[2], &ch[0], sizeof(struct rtw_ieee80211_channel));\r\n_status = rtw_sitesurvey_cmd23a(padapter, ssid,\r\nRTW_SSID_SCAN_AMOUNT, ch, 3);\r\n} else {\r\n_status = rtw_sitesurvey_cmd23a(padapter, ssid,\r\nRTW_SSID_SCAN_AMOUNT, NULL, 0);\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nif (_status == false)\r\nret = -1;\r\ncheck_need_indicate_scan_done:\r\nif (need_indicate_scan_done)\r\nrtw_cfg80211_surveydone_event_callback(padapter);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv,\r\nu32 wpa_version)\r\n{\r\nDBG_8723A("%s, wpa_version =%d\n", __func__, wpa_version);\r\nif (!wpa_version) {\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\r\nreturn 0;\r\n}\r\nif (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,\r\nenum nl80211_auth_type sme_auth_type)\r\n{\r\nDBG_8723A("%s, nl80211_auth_type =%d\n", __func__, sme_auth_type);\r\nswitch (sme_auth_type) {\r\ncase NL80211_AUTHTYPE_AUTOMATIC:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\r\nbreak;\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\nif (psecuritypriv->ndisauthtype > Ndis802_11AuthModeWPA)\r\npsecuritypriv->dot11AuthAlgrthm =\r\ndot11AuthAlgrthm_8021X;\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ndefault:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv,\r\nu32 cipher, bool ucast)\r\n{\r\nu32 ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nu32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :\r\n&psecuritypriv->dot118021XGrpPrivacy;\r\nDBG_8723A("%s, ucast =%d, cipher = 0x%x\n", __func__, ucast, cipher);\r\nif (!cipher) {\r\n*profile_cipher = 0;\r\npsecuritypriv->ndisencryptstatus = ndisencryptstatus;\r\nreturn 0;\r\n}\r\nswitch (cipher) {\r\ncase IW_AUTH_CIPHER_NONE:\r\n*profile_cipher = 0;\r\nndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\n*profile_cipher = WLAN_CIPHER_SUITE_WEP40;\r\nndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\n*profile_cipher = WLAN_CIPHER_SUITE_WEP104;\r\nndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\n*profile_cipher = WLAN_CIPHER_SUITE_TKIP;\r\nndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\n*profile_cipher = WLAN_CIPHER_SUITE_CCMP;\r\nndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ndefault:\r\nDBG_8723A("Unsupported cipher: 0x%x\n", cipher);\r\nreturn -ENOTSUPP;\r\n}\r\nif (ucast)\r\npsecuritypriv->ndisencryptstatus = ndisencryptstatus;\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv,\r\nu32 key_mgt)\r\n{\r\nDBG_8723A("%s, key_mgt = 0x%x\n", __func__, key_mgt);\r\nif (key_mgt == WLAN_AKM_SUITE_8021X)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nelse if (key_mgt == WLAN_AKM_SUITE_PSK)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nelse\r\nDBG_8723A("Invalid key mgt: 0x%x\n", key_mgt);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter, const u8 *pie,\r\nsize_t ielen)\r\n{\r\nconst u8 *wps_ie;\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nint ret = 0;\r\nconst u8 *pwpa, *pwpa2;\r\nint i;\r\nif (!pie || !ielen) {\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\ngoto exit;\r\n}\r\nif (ielen > MAX_WPA_IE_LEN + MAX_WPS_IE_LEN + MAX_P2P_IE_LEN) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nDBG_8723A("set wpa_ie(length:%zu):\n", ielen);\r\nfor (i = 0; i < ielen; i = i + 8)\r\nDBG_8723A("0x%.2x 0x%.2x 0x%.2x 0x%.2x "\r\n"0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",\r\npie[i], pie[i + 1], pie[i + 2], pie[i + 3],\r\npie[i + 4], pie[i + 5], pie[i + 6], pie[i + 7]);\r\nif (ielen < RSN_HEADER_LEN) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,\r\n"Ie len too short %d\n", (int)ielen);\r\nret = -1;\r\ngoto exit;\r\n}\r\npwpa = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPA,\r\npie, ielen);\r\nif (pwpa && pwpa[1] > 0) {\r\nif (rtw_parse_wpa_ie23a(pwpa, pwpa[1] + 2, &group_cipher,\r\n&pairwise_cipher, NULL) == _SUCCESS) {\r\npadapter->securitypriv.dot11AuthAlgrthm =\r\ndot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPAPSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, pwpa,\r\npwpa[1] + 2);\r\nDBG_8723A("got wpa_ie, wpa_ielen:%u\n", pwpa[1]);\r\n}\r\n}\r\npwpa2 = cfg80211_find_ie(WLAN_EID_RSN, pie, ielen);\r\nif (pwpa2 && pwpa2[1] > 0) {\r\nif (rtw_parse_wpa2_ie23a (pwpa2, pwpa2[1] + 2, &group_cipher,\r\n&pairwise_cipher, NULL) == _SUCCESS) {\r\npadapter->securitypriv.dot11AuthAlgrthm =\r\ndot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPA2PSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, pwpa2,\r\npwpa2[1] + 2);\r\nDBG_8723A("got wpa2_ie, wpa2_ielen:%u\n", pwpa2[1]);\r\n}\r\n}\r\nif (group_cipher == 0) {\r\ngroup_cipher = WPA_CIPHER_NONE;\r\n}\r\nif (pairwise_cipher == 0) {\r\npairwise_cipher = WPA_CIPHER_NONE;\r\n}\r\nswitch (group_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot118021XGrpPrivacy = 0;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot118021XGrpPrivacy = WLAN_CIPHER_SUITE_WEP40;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = WLAN_CIPHER_SUITE_TKIP;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = WLAN_CIPHER_SUITE_CCMP;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot118021XGrpPrivacy = WLAN_CIPHER_SUITE_WEP104;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\nswitch (pairwise_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = 0;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_WEP40;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_TKIP;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_CCMP;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_WEP104;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\nwps_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPS,\r\npie, ielen);\r\nif (wps_ie && wps_ie[1] > 0) {\r\nDBG_8723A("got wps_ie, wps_ielen:%u\n", wps_ie[1]);\r\npadapter->securitypriv.wps_ie_len = wps_ie[1];\r\nmemcpy(padapter->securitypriv.wps_ie, wps_ie,\r\npadapter->securitypriv.wps_ie_len);\r\nset_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\n} else {\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\n}\r\nif (padapter->securitypriv.dot11PrivacyAlgrthm ==\r\nWLAN_CIPHER_SUITE_TKIP ||\r\npadapter->securitypriv.dot11PrivacyAlgrthm ==\r\nWLAN_CIPHER_SUITE_CCMP)\r\nrtl8723a_off_rcr_am(padapter);\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n"rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",\r\npairwise_cipher,\r\npadapter->securitypriv.ndisencryptstatus,\r\npadapter->securitypriv.ndisauthtype);\r\nexit:\r\nif (ret)\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\nreturn ret;\r\n}\r\nstatic int rtw_cfg80211_add_wep(struct rtw_adapter *padapter,\r\nstruct rtw_wep_key *wep, u8 keyid)\r\n{\r\nint res;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nif (keyid >= NUM_WEP_KEYS) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n"%s:keyid>4 =>fail\n", __func__);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nswitch (wep->keylen) {\r\ncase WLAN_KEY_LEN_WEP40:\r\npsecuritypriv->dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_WEP40;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"%s:wep->KeyLength = 5\n", __func__);\r\nbreak;\r\ncase WLAN_KEY_LEN_WEP104:\r\npsecuritypriv->dot11PrivacyAlgrthm = WLAN_CIPHER_SUITE_WEP104;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"%s:wep->KeyLength = 13\n", __func__);\r\nbreak;\r\ndefault:\r\npsecuritypriv->dot11PrivacyAlgrthm = 0;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"%s:wep->KeyLength!= 5 or 13\n", __func__);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"%s:before memcpy, wep->KeyLength = 0x%x keyid =%x\n",\r\n__func__, wep->keylen, keyid);\r\nmemcpy(&psecuritypriv->wep_key[keyid], wep, sizeof(struct rtw_wep_key));\r\npsecuritypriv->dot11PrivacyKeyIndex = keyid;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"%s:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",\r\n__func__,\r\npsecuritypriv->wep_key[keyid].key[0],\r\npsecuritypriv->wep_key[keyid].key[1],\r\npsecuritypriv->wep_key[keyid].key[2],\r\npsecuritypriv->wep_key[keyid].key[3],\r\npsecuritypriv->wep_key[keyid].key[4],\r\npsecuritypriv->wep_key[keyid].key[5],\r\npsecuritypriv->wep_key[keyid].key[6],\r\npsecuritypriv->wep_key[keyid].key[7],\r\npsecuritypriv->wep_key[keyid].key[8],\r\npsecuritypriv->wep_key[keyid].key[9],\r\npsecuritypriv->wep_key[keyid].key[10],\r\npsecuritypriv->wep_key[keyid].key[11],\r\npsecuritypriv->wep_key[keyid].key[12]);\r\nres = rtw_set_key23a(padapter, psecuritypriv, keyid, 1);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int rtw_set_ssid(struct rtw_adapter *padapter,\r\nstruct wlan_network *newnetwork)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *pnetwork = &pmlmepriv->cur_network;\r\nint status = _SUCCESS;\r\nu32 cur_time = 0;\r\nDBG_8723A_LEVEL(_drv_always_, "set ssid [%s] fw_state = 0x%08x\n",\r\nnewnetwork->network.Ssid.ssid, get_fwstate(pmlmepriv));\r\nif (padapter->hw_init_completed == false) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n"set_ssid: hw_init_completed == false =>exit!!!\n");\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nDBG_8723A("Set SSID under fw_state = 0x%08x\n", get_fwstate(pmlmepriv));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\r\ngoto handle_tkip_countermeasure;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n");\r\nif (pmlmepriv->assoc_ssid.ssid_len ==\r\nnewnetwork->network.Ssid.ssid_len &&\r\n!memcmp(&pmlmepriv->assoc_ssid.ssid,\r\nnewnetwork->network.Ssid.ssid,\r\nnewnetwork->network.Ssid.ssid_len)) {\r\nif (!check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_,\r\n_drv_err_,\r\n"New SSID is same SSID, fw_state = 0x%08x\n",\r\nget_fwstate(pmlmepriv));\r\nif (rtw_is_same_ibss23a(padapter, pnetwork)) {\r\ngoto release_mlme_lock;\r\n}\r\nrtw_disassoc_cmd23a(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED))\r\nrtw_indicate_disconnect23a(padapter);\r\nrtw_free_assoc_resources23a(padapter, 1);\r\nif (check_fwstate(pmlmepriv,\r\nWIFI_ADHOC_MASTER_STATE)) {\r\n_clr_fwstate_(pmlmepriv,\r\nWIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv,\r\nWIFI_ADHOC_STATE);\r\n}\r\n} else {\r\nrtw_lps_ctrl_wk_cmd23a(padapter,\r\nLPS_CTRL_JOINBSS, 1);\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"Set SSID not the same ssid\n");\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"set_ssid =[%s] len = 0x%x\n",\r\nnewnetwork->network.Ssid.ssid,\r\nnewnetwork->network.Ssid.ssid_len);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n"assoc_ssid =[%s] len = 0x%x\n",\r\npmlmepriv->assoc_ssid.ssid,\r\npmlmepriv->assoc_ssid.ssid_len);\r\nrtw_disassoc_cmd23a(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED))\r\nrtw_indicate_disconnect23a(padapter);\r\nrtw_free_assoc_resources23a(padapter, 1);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n}\r\n}\r\nhandle_tkip_countermeasure:\r\nif (padapter->securitypriv.btkip_countermeasure == true) {\r\ncur_time = jiffies;\r\nif ((cur_time -\r\npadapter->securitypriv.btkip_countermeasure_time) >\r\n60 * HZ) {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\npadapter->securitypriv.btkip_countermeasure_time = 0;\r\n} else {\r\nstatus = _FAIL;\r\ngoto release_mlme_lock;\r\n}\r\n}\r\nmemcpy(&pmlmepriv->assoc_ssid, &newnetwork->network.Ssid,\r\nsizeof(struct cfg80211_ssid));\r\npmlmepriv->assoc_by_bssid = false;\r\npmlmepriv->to_join = true;\r\nif (!check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\r\npmlmepriv->cur_network.join_res = -2;\r\nstatus = rtw_do_join_network(padapter, newnetwork);\r\nif (status == _SUCCESS) {\r\npmlmepriv->to_join = false;\r\n} else {\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\nstatus = rtw_do_join_adhoc(padapter);\r\nif (status != _SUCCESS)\r\ngoto release_mlme_lock;\r\n} else {\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nstatus = _FAIL;\r\npmlmepriv->to_join = false;\r\n}\r\n}\r\n}\r\nrelease_mlme_lock:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nexit:\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n"-%s: status =%d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nint ret = 0;\r\nstruct list_head *phead, *plist, *ptmp;\r\nstruct wlan_network *pnetwork = NULL;\r\nu8 matched = false;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct rtw_queue *queue = &pmlmepriv->scanned_queue;\r\nDBG_8723A("=>" "%s(%s)\n", __func__, ndev->name);\r\nDBG_8723A("privacy =%d, key =%p, key_len =%d, key_idx =%d\n",\r\nsme->privacy, sme->key, sme->key_len, sme->key_idx);\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (!sme->ssid || !sme->ssid_len ||\r\nsme->ssid_len > IEEE80211_MAX_SSID_LEN) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nDBG_8723A("ssid =%s, len =%zu\n", sme->ssid, sme->ssid_len);\r\nif (sme->bssid)\r\nDBG_8723A("bssid=%pM\n", sme->bssid);\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\r\nret = -EBUSY;\r\nDBG_8723A("%s, fw_state = 0x%x, goto exit\n", __func__,\r\npmlmepriv->fw_state);\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\r\nrtw_scan_abort23a(padapter);\r\n}\r\nspin_lock_bh(&queue->lock);\r\nphead = get_list_head(queue);\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nif (sme->bssid) {\r\nif (!ether_addr_equal(pnetwork->network.MacAddress,\r\nsme->bssid))\r\ncontinue;\r\n}\r\nif (sme->ssid && sme->ssid_len) {\r\nif (pnetwork->network.Ssid.ssid_len != sme->ssid_len ||\r\nmemcmp(pnetwork->network.Ssid.ssid, sme->ssid,\r\nsme->ssid_len))\r\ncontinue;\r\n}\r\nif (sme->bssid) {\r\nif (ether_addr_equal(pnetwork->network.MacAddress,\r\nsme->bssid)) {\r\nDBG_8723A("matched by bssid\n");\r\nmatched = true;\r\nbreak;\r\n}\r\n} else if (sme->ssid && sme->ssid_len) {\r\nif (!memcmp(pnetwork->network.Ssid.ssid,\r\nsme->ssid, sme->ssid_len) &&\r\npnetwork->network.Ssid.ssid_len == sme->ssid_len) {\r\nDBG_8723A("matched by ssid\n");\r\nmatched = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nif (!matched || !pnetwork) {\r\nret = -ENOENT;\r\nDBG_8723A("connect, matched == false, goto exit\n");\r\ngoto exit;\r\n}\r\nif (cfg80211_infrastructure_mode(\r\npadapter, pnetwork->network.ifmode) != _SUCCESS) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\npsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = 0;\r\npsecuritypriv->dot118021XGrpPrivacy = 0;\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\r\nret = rtw_cfg80211_set_wpa_version(psecuritypriv,\r\nsme->crypto.wpa_versions);\r\nif (ret < 0)\r\ngoto exit;\r\nret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);\r\nif (ret < 0)\r\ngoto exit;\r\nDBG_8723A("%s, ie_len =%zu\n", __func__, sme->ie_len);\r\nret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);\r\nif (ret < 0)\r\ngoto exit;\r\nif (sme->crypto.n_ciphers_pairwise) {\r\nret = rtw_cfg80211_set_cipher(psecuritypriv,\r\nsme->crypto.ciphers_pairwise[0],\r\ntrue);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared ||\r\npsecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) &&\r\nsme->key) {\r\nstruct rtw_wep_key wep_key;\r\nu8 wep_key_idx, wep_key_len;\r\nDBG_8723A("%s(): Shared/Auto WEP\n", __func__);\r\nwep_key_idx = sme->key_idx;\r\nwep_key_len = sme->key_len;\r\nif (wep_key_idx > WEP_KEYS || !wep_key_len ||\r\nwep_key_len > WLAN_KEY_LEN_WEP104) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\nmemset(&wep_key, 0, sizeof(struct rtw_wep_key));\r\nwep_key.keylen = wep_key_len;\r\nif (wep_key_len == 13) {\r\npadapter->securitypriv.dot11PrivacyAlgrthm =\r\nWLAN_CIPHER_SUITE_WEP104;\r\npadapter->securitypriv.dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_WEP104;\r\n} else {\r\npadapter->securitypriv.dot11PrivacyAlgrthm =\r\nWLAN_CIPHER_SUITE_WEP40;\r\npadapter->securitypriv.dot118021XGrpPrivacy =\r\nWLAN_CIPHER_SUITE_WEP40;\r\n}\r\nmemcpy(wep_key.key, (void *)sme->key, wep_key.keylen);\r\nif (rtw_cfg80211_add_wep(padapter, &wep_key, wep_key_idx) !=\r\n_SUCCESS)\r\nret = -EOPNOTSUPP;\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nret = rtw_cfg80211_set_cipher(psecuritypriv,\r\nsme->crypto.cipher_group, false);\r\nif (ret < 0)\r\ngoto exit;\r\nif (sme->crypto.n_akm_suites) {\r\nret = rtw_cfg80211_set_key_mgt(psecuritypriv,\r\nsme->crypto.akm_suites[0]);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (psecuritypriv->ndisauthtype > 3)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nif (rtw_set_auth23a(padapter, psecuritypriv) != _SUCCESS) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nif (rtw_set_ssid(padapter, pnetwork) != _SUCCESS) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nDBG_8723A("set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, "\r\n"dot118021XGrpPrivacy =%d\n", psecuritypriv->dot11AuthAlgrthm,\r\npsecuritypriv->dot11PrivacyAlgrthm,\r\npsecuritypriv->dot118021XGrpPrivacy);\r\nexit:\r\nDBG_8723A("<=%s, ret %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,\r\nu16 reason_code)\r\n{\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nrtw_set_roaming(padapter, 0);\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\nrtw_scan_abort23a(padapter);\r\nLeaveAllPowerSaveMode23a(padapter);\r\nrtw_disassoc_cmd23a(padapter, 500, false);\r\nDBG_8723A("%s...call rtw_indicate_disconnect23a\n", __func__);\r\npadapter->mlmepriv.not_indic_disco = true;\r\nrtw_indicate_disconnect23a(padapter);\r\npadapter->mlmepriv.not_indic_disco = false;\r\nrtw_free_assoc_resources23a(padapter, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type, int mbm)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_get_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev, int *dbm)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n*dbm = (12);\r\nreturn 0;\r\n}\r\ninline bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter *adapter)\r\n{\r\nstruct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(adapter->rtw_wdev);\r\nreturn rtw_wdev_priv->power_mgmt;\r\n}\r\nstatic int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nbool enabled, int timeout)\r\n{\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(padapter->rtw_wdev);\r\nDBG_8723A("%s(%s): enabled:%u, timeout:%d\n",\r\n__func__, ndev->name, enabled, timeout);\r\nrtw_wdev_priv->power_mgmt = enabled;\r\nif (!enabled)\r\nLPS_Leave23a(padapter);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,\r\nstruct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nu8 index, blInserted = false;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s(%s)\n", __func__, netdev->name);\r\nif (is_zero_ether_addr(pmksa->bssid))\r\nreturn -EINVAL;\r\nblInserted = false;\r\nfor (index = 0; index < NUM_PMKID_CACHE; index++) {\r\nif (ether_addr_equal(psecuritypriv->PMKIDList[index].Bssid,\r\npmksa->bssid)) {\r\nDBG_8723A("%s(%s): BSSID exists in the PMKList.\n",\r\n__func__, netdev->name);\r\nmemcpy(psecuritypriv->PMKIDList[index].PMKID,\r\npmksa->pmkid, WLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[index].bUsed = true;\r\npsecuritypriv->PMKIDIndex = index + 1;\r\nblInserted = true;\r\nbreak;\r\n}\r\n}\r\nif (!blInserted) {\r\nDBG_8723A("%s(%s): Use new entry index = %d for this PMKID\n",\r\n__func__, netdev->name, psecuritypriv->PMKIDIndex);\r\nether_addr_copy(\r\npsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].\r\nBssid, pmksa->bssid);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].\r\nPMKID, pmksa->pmkid, WLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed =\r\ntrue;\r\npsecuritypriv->PMKIDIndex++;\r\nif (psecuritypriv->PMKIDIndex == 16) {\r\npsecuritypriv->PMKIDIndex = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,\r\nstruct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nu8 index, bMatched = false;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s(%s)\n", __func__, netdev->name);\r\nfor (index = 0; index < NUM_PMKID_CACHE; index++) {\r\nif (ether_addr_equal(psecuritypriv->PMKIDList[index].Bssid,\r\npmksa->bssid)) {\r\neth_zero_addr(psecuritypriv->PMKIDList[index].Bssid);\r\nmemset(psecuritypriv->PMKIDList[index].PMKID, 0x00,\r\nWLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[index].bUsed = false;\r\nbMatched = true;\r\nbreak;\r\n}\r\n}\r\nif (false == bMatched) {\r\nDBG_8723A("%s(%s): do not have matched BSSID\n", __func__,\r\nnetdev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,\r\nstruct net_device *netdev)\r\n{\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8723A("%s(%s)\n", __func__, netdev->name);\r\nmemset(&psecuritypriv->PMKIDList[0], 0x00,\r\nsizeof(struct rt_pmkid_list) * NUM_PMKID_CACHE);\r\npsecuritypriv->PMKIDIndex = 0;\r\nreturn 0;\r\n}\r\nvoid rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter,\r\nu8 *pmgmt_frame, uint frame_len)\r\n{\r\ns32 freq;\r\nint channel;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct net_device *ndev = padapter->pnetdev;\r\nDBG_8723A("%s(padapter =%p,%s)\n", __func__, padapter, ndev->name);\r\n#if defined(RTW_USE_CFG80211_STA_EVENT)\r\n{\r\nstruct station_info sinfo;\r\nu8 ie_offset;\r\nif (ieee80211_is_assoc_req(hdr->frame_control))\r\nie_offset = offsetof(struct ieee80211_mgmt,\r\nu.assoc_req.variable);\r\nelse\r\nie_offset = offsetof(struct ieee80211_mgmt,\r\nu.reassoc_req.variable);\r\nsinfo.filled = 0;\r\nsinfo.assoc_req_ies = pmgmt_frame + ie_offset;\r\nsinfo.assoc_req_ies_len = frame_len - ie_offset;\r\ncfg80211_new_sta(ndev, hdr->addr2, &sinfo, GFP_ATOMIC);\r\n}\r\n#else\r\nchannel = pmlmeext->cur_channel;\r\nif (channel <= RTW_CH_MAX_2G_CHANNEL)\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_2GHZ);\r\nelse\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_5GHZ);\r\ncfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, pmgmt_frame, frame_len,\r\n0);\r\n#endif\r\n}\r\nvoid rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter,\r\nunsigned char *da,\r\nunsigned short reason)\r\n{\r\ns32 freq;\r\nint channel;\r\nuint frame_len;\r\nstruct ieee80211_mgmt mgmt;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct net_device *ndev = padapter->pnetdev;\r\nDBG_8723A("%s(padapter =%p,%s)\n", __func__, padapter, ndev->name);\r\nmemset(&mgmt, 0, sizeof(struct ieee80211_mgmt));\r\n#if defined(RTW_USE_CFG80211_STA_EVENT)\r\ncfg80211_del_sta(ndev, da, GFP_ATOMIC);\r\n#else\r\nchannel = pmlmeext->cur_channel;\r\nif (channel <= RTW_CH_MAX_2G_CHANNEL)\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_2GHZ);\r\nelse\r\nfreq = ieee80211_channel_to_frequency(channel,\r\nIEEE80211_BAND_5GHZ);\r\nmgmt.frame_control =\r\ncpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH);\r\nether_addr_copy(mgmt.da, myid(&padapter->eeprompriv));\r\nether_addr_copy(mgmt.sa, da);\r\nether_addr_copy(mgmt.bssid, get_my_bssid23a(&pmlmeinfo->network));\r\nmgmt.seq_ctrl = cpu_to_le16(IEEE80211_SN_TO_SEQ(pmlmeext->mgnt_seq));\r\npmlmeext->mgnt_seq++;\r\nmgmt.u.disassoc.reason_code = cpu_to_le16(reason);\r\nframe_len = sizeof(struct ieee80211_hdr_3addr) + 2;\r\ncfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 *)&mgmt, frame_len,\r\n0);\r\n#endif\r\n}\r\nstatic int rtw_cfg80211_monitor_if_open(struct net_device *ndev)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_monitor_if_close(struct net_device *ndev)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nint ret = 0;\r\nint rtap_len;\r\nint qos_len = 0;\r\nint dot11_hdr_len = 24;\r\nint snap_len = 6;\r\nunsigned char *pdata;\r\nunsigned char src_mac_addr[6];\r\nunsigned char dst_mac_addr[6];\r\nstruct ieee80211_hdr *dot11_hdr;\r\nstruct ieee80211_radiotap_header *rtap_hdr;\r\nstruct rtw_adapter *padapter = netdev_priv(ndev);\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\r\ngoto fail;\r\nrtap_hdr = (struct ieee80211_radiotap_header *)skb->data;\r\nif (unlikely(rtap_hdr->it_version))\r\ngoto fail;\r\nrtap_len = ieee80211_get_radiotap_len(skb->data);\r\nif (unlikely(skb->len < rtap_len))\r\ngoto fail;\r\nif (rtap_len != 14) {\r\nDBG_8723A("radiotap len (should be 14): %d\n", rtap_len);\r\ngoto fail;\r\n}\r\nskb_pull(skb, rtap_len);\r\ndot11_hdr = (struct ieee80211_hdr *)skb->data;\r\nif (ieee80211_is_data(dot11_hdr->frame_control)) {\r\nif (ieee80211_is_data_qos(dot11_hdr->frame_control))\r\nqos_len = IEEE80211_QOS_CTL_LEN;\r\nif (ieee80211_has_a4(dot11_hdr->frame_control))\r\ndot11_hdr_len += 6;\r\nmemcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));\r\nmemcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));\r\nskb_pull(skb, dot11_hdr_len + qos_len + snap_len -\r\nETH_ALEN * 2);\r\npdata = (unsigned char *)skb->data;\r\nether_addr_copy(pdata, dst_mac_addr);\r\nether_addr_copy(pdata + ETH_ALEN, src_mac_addr);\r\nDBG_8723A("should be eapol packet\n");\r\nret = rtw_xmit23a_entry23a(skb, padapter->pnetdev);\r\nreturn ret;\r\n} else if (ieee80211_is_action(dot11_hdr->frame_control)) {\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nu32 len = skb->len;\r\nu8 category, action;\r\nmgmt = (struct ieee80211_mgmt *)dot11_hdr;\r\nDBG_8723A("RTW_Tx:da=%pM via %s(%s)\n",\r\nmgmt->da, __func__, ndev->name);\r\ncategory = mgmt->u.action.category;\r\naction = mgmt->u.action.u.wme_action.action_code;\r\nDBG_8723A("RTW_Tx:category(%u), action(%u)\n",\r\ncategory, action);\r\npmgntframe = alloc_mgtxmitframe23a(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto fail;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib23a(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\nmemcpy(pframe, skb->data, len);\r\npattrib->pktlen = len;\r\npmlmeext->mgnt_seq = le16_to_cpu(dot11_hdr->seq_ctrl) >> 4;\r\npattrib->seqnum = pmlmeext->mgnt_seq;\r\npmlmeext->mgnt_seq++;\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe23a(padapter, pmgntframe);\r\n}\r\nfail:\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int\r\nrtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_add_monitor_if(struct rtw_adapter *padapter, char *name,\r\nunsigned char name_assign_type,\r\nstruct net_device **ndev)\r\n{\r\nint ret = 0;\r\nstruct net_device *mon_ndev = NULL;\r\nstruct wireless_dev *mon_wdev = NULL;\r\nstruct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);\r\nif (!name) {\r\nDBG_8723A("%s(%s): without specific name\n",\r\n__func__, padapter->pnetdev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (pwdev_priv->pmon_ndev) {\r\nDBG_8723A("%s(%s): monitor interface exist: %s\n", __func__,\r\npadapter->pnetdev->name, pwdev_priv->pmon_ndev->name);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmon_ndev = alloc_etherdev(sizeof(struct rtw_adapter));\r\nif (!mon_ndev) {\r\nDBG_8723A("%s(%s): allocate ndev fail\n", __func__,\r\npadapter->pnetdev->name);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;\r\nstrncpy(mon_ndev->name, name, IFNAMSIZ);\r\nmon_ndev->name[IFNAMSIZ - 1] = 0;\r\nmon_ndev->name_assign_type = name_assign_type;\r\nmon_ndev->destructor = rtw_ndev_destructor;\r\nmon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;\r\nmon_wdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);\r\nif (!mon_wdev) {\r\nDBG_8723A("%s(%s): allocate mon_wdev fail\n", __func__,\r\npadapter->pnetdev->name);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmon_wdev->wiphy = padapter->rtw_wdev->wiphy;\r\nmon_wdev->netdev = mon_ndev;\r\nmon_wdev->iftype = NL80211_IFTYPE_MONITOR;\r\nmon_ndev->ieee80211_ptr = mon_wdev;\r\nret = register_netdevice(mon_ndev);\r\nif (ret) {\r\ngoto out;\r\n}\r\n*ndev = pwdev_priv->pmon_ndev = mon_ndev;\r\nmemcpy(pwdev_priv->ifname_mon, name, IFNAMSIZ + 1);\r\nout:\r\nif (ret) {\r\nkfree(mon_wdev);\r\nmon_wdev = NULL;\r\n}\r\nif (ret && mon_ndev) {\r\nfree_netdev(mon_ndev);\r\n*ndev = mon_ndev = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct wireless_dev *\r\ncfg80211_rtw_add_virtual_intf(struct wiphy *wiphy, const char *name,\r\nunsigned char name_assign_type,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nint ret = 0;\r\nstruct net_device *ndev = NULL;\r\nstruct rtw_adapter *padapter = wiphy_to_adapter(wiphy);\r\nDBG_8723A("%s(%s): wiphy:%s, name:%s, type:%d\n", __func__,\r\npadapter->pnetdev->name, wiphy_name(wiphy), name, type);\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nret = -ENODEV;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\nret =\r\nrtw_cfg80211_add_monitor_if(padapter, (char *)name,\r\nname_assign_type, &ndev);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_STATION:\r\nret = -ENODEV;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP:\r\nret = -ENODEV;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nDBG_8723A("Unsupported interface type\n");\r\nbreak;\r\n}\r\nDBG_8723A("%s(%s): ndev:%p, ret:%d\n", __func__,\r\npadapter->pnetdev->name,\r\nndev, ret);\r\nreturn ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);\r\n}\r\nstatic int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev)\r\n{\r\nstruct rtw_wdev_priv *pwdev_priv =\r\n(struct rtw_wdev_priv *)wiphy_priv(wiphy);\r\nstruct net_device *ndev;\r\nndev = wdev ? wdev->netdev : NULL;\r\nif (!ndev)\r\ngoto exit;\r\nunregister_netdevice(ndev);\r\nif (ndev == pwdev_priv->pmon_ndev) {\r\npwdev_priv->pmon_ndev = NULL;\r\npwdev_priv->ifname_mon[0] = '\0';\r\nDBG_8723A("%s(%s): remove monitor interface\n",\r\n__func__, ndev->name);\r\n}\r\nexit:\r\nreturn 0;\r\n}\r\nstatic int rtw_add_beacon(struct rtw_adapter *adapter, const u8 *head,\r\nsize_t head_len, const u8 *tail, size_t tail_len)\r\n{\r\nint ret = 0;\r\nu8 *pbuf;\r\nuint len, ielen, wps_ielen = 0;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct wlan_bssid_ex *bss = &pmlmepriv->cur_network.network;\r\nconst struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)head;\r\nstruct ieee80211_mgmt *tmpmgmt;\r\nDBG_8723A("%s beacon_head_len =%zu, beacon_tail_len =%zu\n",\r\n__func__, head_len, tail_len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nif (head_len < offsetof(struct ieee80211_mgmt, u.beacon.variable))\r\nreturn -EINVAL;\r\npbuf = kzalloc(head_len + tail_len, GFP_KERNEL);\r\nif (!pbuf)\r\nreturn -ENOMEM;\r\ntmpmgmt = (struct ieee80211_mgmt *)pbuf;\r\nbss->beacon_interval = get_unaligned_le16(&mgmt->u.beacon.beacon_int);\r\nbss->capability = get_unaligned_le16(&mgmt->u.beacon.capab_info);\r\nbss->tsf = get_unaligned_le64(&mgmt->u.beacon.timestamp);\r\nmemcpy(pbuf, (void *)head, head_len);\r\nmemcpy(pbuf + head_len, (void *)tail, tail_len);\r\nlen = head_len + tail_len;\r\nielen = len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPS,\r\ntmpmgmt->u.beacon.variable, ielen))\r\nDBG_8723A("add bcn, wps_ielen =%d\n", wps_ielen);\r\nrtw_ies_remove_ie23a(tmpmgmt->u.beacon.variable, &ielen, 0,\r\nWLAN_EID_VENDOR_SPECIFIC, P2P_OUI23A, 4);\r\nrtw_ies_remove_ie23a(tmpmgmt->u.beacon.variable, &ielen, 0,\r\nWLAN_EID_VENDOR_SPECIFIC, WFD_OUI23A, 4);\r\nlen = ielen + offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nif (rtw_check_beacon_data23a(adapter, tmpmgmt, len) == _SUCCESS) {\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nkfree(pbuf);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ap_settings *settings)\r\n{\r\nint ret = 0;\r\nstruct rtw_adapter *adapter = wiphy_to_adapter(wiphy);\r\nDBG_8723A("%s(%s): hidden_ssid:%d, auth_type:%d\n",\r\n__func__, ndev->name, settings->hidden_ssid,\r\nsettings->auth_type);\r\nret = rtw_add_beacon(adapter, settings->beacon.head,\r\nsettings->beacon.head_len, settings->beacon.tail,\r\nsettings->beacon.tail_len);\r\nadapter->mlmeextpriv.mlmext_info.hidden_ssid_mode =\r\nsettings->hidden_ssid;\r\nif (settings->ssid && settings->ssid_len) {\r\nstruct wlan_bssid_ex *pbss_network =\r\n&adapter->mlmepriv.cur_network.network;\r\nstruct wlan_bssid_ex *pbss_network_ext =\r\n&adapter->mlmeextpriv.mlmext_info.network;\r\nmemcpy(pbss_network->Ssid.ssid, (void *)settings->ssid,\r\nsettings->ssid_len);\r\npbss_network->Ssid.ssid_len = settings->ssid_len;\r\nmemcpy(pbss_network_ext->Ssid.ssid, (void *)settings->ssid,\r\nsettings->ssid_len);\r\npbss_network_ext->Ssid.ssid_len = settings->ssid_len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_beacon(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nstruct cfg80211_beacon_data *info)\r\n{\r\nint ret = 0;\r\nstruct rtw_adapter *adapter = wiphy_to_adapter(wiphy);\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail,\r\ninfo->tail_len);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_add_station(struct wiphy *wiphy,\r\nstruct net_device *ndev, const u8 *mac,\r\nstruct station_parameters *params)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_station(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nstruct station_del_parameters *params)\r\n{\r\nconst u8 *mac = params->mac;\r\nint ret = 0;\r\nstruct list_head *phead, *plist, *ptmp;\r\nu8 updated = 0;\r\nstruct sta_info *psta;\r\nstruct rtw_adapter *padapter = netdev_priv(ndev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_8723A("+%s(%s)\n", __func__, ndev->name);\r\nif (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE)) != true) {\r\nDBG_8723A("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (!mac) {\r\nDBG_8723A("flush all sta, and cam_entry\n");\r\nflush_all_cam_entry23a(padapter);\r\nret = rtw_sta_flush23a(padapter);\r\nreturn ret;\r\n}\r\nDBG_8723A("free sta macaddr=%pM\n", mac);\r\nif (is_broadcast_ether_addr(mac))\r\nreturn -EINVAL;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nif (ether_addr_equal(mac, psta->hwaddr)) {\r\nif (psta->dot8021xalg == 1 &&\r\npsta->bpairwise_key_installed == false) {\r\nDBG_8723A("%s, sta's dot8021xalg = 1 and "\r\n"key_installed = false\n", __func__);\r\n} else {\r\nDBG_8723A("free psta =%p, aid =%d\n", psta,\r\npsta->aid);\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated =\r\nap_free_sta23a(padapter, psta, true,\r\nWLAN_REASON_DEAUTH_LEAVING);\r\npsta = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nassociated_clients_update23a(padapter, updated);\r\nDBG_8723A("-%s(%s)\n", __func__, ndev->name);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_station(struct wiphy *wiphy,\r\nstruct net_device *ndev, const u8 *mac,\r\nstruct station_parameters *params)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_dump_station(struct wiphy *wiphy,\r\nstruct net_device *ndev, int idx, u8 *mac,\r\nstruct station_info *sinfo)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn -ENOENT;\r\n}\r\nstatic int cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct bss_parameters *params)\r\n{\r\nDBG_8723A("%s(%s)\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter, u8 tx_ch,\r\nconst u8 *buf, size_t len)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nint ret = _FAIL;\r\nstruct ieee80211_hdr *pwlanhdr;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EFAULT;\r\ngoto exit;\r\n}\r\nrtw_set_scan_deny(padapter, 1000);\r\nrtw_scan_abort23a(padapter);\r\nif (tx_ch != rtw_get_oper_ch23a(padapter)) {\r\nif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))\r\npmlmeext->cur_channel = tx_ch;\r\nset_channel_bwmode23a(padapter, tx_ch,\r\nHAL_PRIME_CHNL_OFFSET_DONT_CARE,\r\nHT_CHANNEL_WIDTH_20);\r\n}\r\npmgntframe = alloc_mgtxmitframe23a(pxmitpriv);\r\nif (!pmgntframe) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib23a(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;\r\nmemcpy(pframe, (void *)buf, len);\r\npattrib->pktlen = len;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npmlmeext->mgnt_seq = le16_to_cpu(pwlanhdr->seq_ctrl) >> 4;\r\npattrib->seqnum = pmlmeext->mgnt_seq;\r\npmlmeext->mgnt_seq++;\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);\r\nif (ret != _SUCCESS)\r\nDBG_8723A("%s, ack == false\n", __func__);\r\nelse\r\nDBG_8723A("%s, ack == true\n", __func__);\r\nexit:\r\nDBG_8723A("%s, ret =%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct cfg80211_mgmt_tx_params *params,\r\nu64 *cookie)\r\n{\r\nstruct rtw_adapter *padapter =\r\n(struct rtw_adapter *)wiphy_to_adapter(wiphy);\r\nint ret = 0;\r\nint tx_ret;\r\nu32 dump_limit = RTW_MAX_MGMT_TX_CNT;\r\nu32 dump_cnt = 0;\r\nbool ack = true;\r\nu8 category, action;\r\nunsigned long start = jiffies;\r\nsize_t len = params->len;\r\nstruct ieee80211_channel *chan = params->chan;\r\nconst u8 *buf = params->buf;\r\nstruct ieee80211_mgmt *hdr = (struct ieee80211_mgmt *)buf;\r\nu8 tx_ch = (u8) ieee80211_frequency_to_channel(chan->center_freq);\r\nif (!ieee80211_is_action(hdr->frame_control))\r\nreturn -EINVAL;\r\n*cookie = (unsigned long)buf;\r\nDBG_8723A("%s(%s): len =%zu, ch =%d\n", __func__,\r\npadapter->pnetdev->name, len, tx_ch);\r\ncfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, ack,\r\nGFP_KERNEL);\r\nDBG_8723A("RTW_Tx:tx_ch =%d, da =%pM\n", tx_ch, hdr->da);\r\ncategory = hdr->u.action.category;\r\naction = hdr->u.action.u.wme_action.action_code;\r\nDBG_8723A("RTW_Tx:category(%u), action(%u)\n", category, action);\r\ndo {\r\ndump_cnt++;\r\ntx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);\r\n} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);\r\nif (tx_ret != _SUCCESS || dump_cnt > 1) {\r\nDBG_8723A("%s(%s): %s (%d/%d) in %d ms\n",\r\n__func__, padapter->pnetdev->name,\r\ntx_ret == _SUCCESS ? "OK" : "FAIL", dump_cnt,\r\ndump_limit, jiffies_to_msecs(jiffies - start));\r\n}\r\nreturn ret;\r\n}\r\nstatic void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu16 frame_type, bool reg)\r\n{\r\nif (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))\r\nreturn;\r\nreturn;\r\n}\r\nstatic void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap,\r\nenum ieee80211_band band, u8 rf_type)\r\n{\r\n#define MAX_BIT_RATE_40MHZ_MCS15 300\r\n#define MAX_BIT_RATE_40MHZ_MCS7 150\r\nht_cap->ht_supported = true;\r\nht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\r\nIEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;\r\nht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\r\nht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nif (rf_type == RF_1T1R) {\r\nht_cap->mcs.rx_mask[0] = 0xFF;\r\nht_cap->mcs.rx_mask[1] = 0x00;\r\nht_cap->mcs.rx_mask[4] = 0x01;\r\nht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS7);\r\n} else if ((rf_type == RF_1T2R) || (rf_type == RF_2T2R)) {\r\nht_cap->mcs.rx_mask[0] = 0xFF;\r\nht_cap->mcs.rx_mask[1] = 0xFF;\r\nht_cap->mcs.rx_mask[4] = 0x01;\r\nht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS15);\r\n} else {\r\nDBG_8723A("%s, error rf_type =%d\n", __func__, rf_type);\r\n}\r\n}\r\nvoid rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter)\r\n{\r\nu8 rf_type;\r\nstruct ieee80211_supported_band *bands;\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nrf_type = rtl8723a_get_rf_type(padapter);\r\nDBG_8723A("%s:rf_type =%d\n", __func__, rf_type);\r\n{\r\nbands = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (bands)\r\nrtw_cfg80211_init_ht_capab(&bands->ht_cap,\r\nIEEE80211_BAND_2GHZ,\r\nrf_type);\r\n}\r\n{\r\nbands = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nif (bands)\r\nrtw_cfg80211_init_ht_capab(&bands->ht_cap,\r\nIEEE80211_BAND_5GHZ,\r\nrf_type);\r\n}\r\n}\r\nstatic void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter,\r\nstruct wiphy *wiphy)\r\n{\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;\r\nwiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\r\nwiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;\r\nwiphy->max_remain_on_channel_duration =\r\nRTW_MAX_REMAIN_ON_CHANNEL_DURATION;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nBIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_MONITOR) |\r\n#endif\r\n0;\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nwiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;\r\n#endif\r\nwiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);\r\nwiphy->cipher_suites = rtw_cipher_suites;\r\nwiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);\r\nwiphy->bands[IEEE80211_BAND_2GHZ] =\r\nrtw_spt_band_alloc(IEEE80211_BAND_2GHZ);\r\nwiphy->bands[IEEE80211_BAND_5GHZ] =\r\nrtw_spt_band_alloc(IEEE80211_BAND_5GHZ);\r\nwiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\r\nwiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;\r\nif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\r\nwiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nelse\r\nwiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\n}\r\nint rtw_wdev_alloc(struct rtw_adapter *padapter, struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct wiphy *wiphy;\r\nstruct wireless_dev *wdev;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nstruct net_device *pnetdev = padapter->pnetdev;\r\nDBG_8723A("%s(padapter =%p)\n", __func__, padapter);\r\nwiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct rtw_wdev_priv));\r\nif (!wiphy) {\r\nDBG_8723A("Couldn't allocate wiphy device\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nwdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);\r\nif (!wdev) {\r\nDBG_8723A("Couldn't allocate wireless device\n");\r\nret = -ENOMEM;\r\ngoto free_wiphy;\r\n}\r\nset_wiphy_dev(wiphy, dev);\r\nrtw_cfg80211_preinit_wiphy(padapter, wiphy);\r\nret = wiphy_register(wiphy);\r\nif (ret < 0) {\r\nDBG_8723A("Couldn't register wiphy device\n");\r\ngoto free_wdev;\r\n}\r\nwdev->wiphy = wiphy;\r\nwdev->netdev = pnetdev;\r\nwdev->iftype = NL80211_IFTYPE_MONITOR;\r\npadapter->rtw_wdev = wdev;\r\npnetdev->ieee80211_ptr = wdev;\r\npwdev_priv = wdev_to_priv(wdev);\r\npwdev_priv->rtw_wdev = wdev;\r\npwdev_priv->pmon_ndev = NULL;\r\npwdev_priv->ifname_mon[0] = '\0';\r\npwdev_priv->padapter = padapter;\r\npwdev_priv->scan_request = NULL;\r\nspin_lock_init(&pwdev_priv->scan_req_lock);\r\npwdev_priv->p2p_enabled = false;\r\nif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\r\npwdev_priv->power_mgmt = true;\r\nelse\r\npwdev_priv->power_mgmt = false;\r\nreturn ret;\r\nfree_wdev:\r\nkfree(wdev);\r\nfree_wiphy:\r\nwiphy_free(wiphy);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_wdev_free(struct wireless_dev *wdev)\r\n{\r\nDBG_8723A("%s(wdev =%p)\n", __func__, wdev);\r\nif (!wdev)\r\nreturn;\r\nkfree(wdev->wiphy->bands[IEEE80211_BAND_2GHZ]);\r\nkfree(wdev->wiphy->bands[IEEE80211_BAND_5GHZ]);\r\nwiphy_free(wdev->wiphy);\r\nkfree(wdev);\r\n}\r\nvoid rtw_wdev_unregister(struct wireless_dev *wdev)\r\n{\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nDBG_8723A("%s(wdev =%p)\n", __func__, wdev);\r\nif (!wdev)\r\nreturn;\r\npwdev_priv = wdev_to_priv(wdev);\r\nrtw_cfg80211_indicate_scan_done(pwdev_priv, true);\r\nif (pwdev_priv->pmon_ndev) {\r\nDBG_8723A("%s, unregister monitor interface\n", __func__);\r\nunregister_netdev(pwdev_priv->pmon_ndev);\r\n}\r\nwiphy_unregister(wdev->wiphy);\r\n}
