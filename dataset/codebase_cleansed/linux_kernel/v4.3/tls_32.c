int do_set_thread_area(struct user_desc *info)\r\n{\r\nint ret;\r\nu32 cpu;\r\ncpu = get_cpu();\r\nret = os_set_thread_area(info, userspace_pid[cpu]);\r\nput_cpu();\r\nif (ret)\r\nprintk(KERN_ERR "PTRACE_SET_THREAD_AREA failed, err = %d, "\r\n"index = %d\n", ret, info->entry_number);\r\nreturn ret;\r\n}\r\nint do_get_thread_area(struct user_desc *info)\r\n{\r\nint ret;\r\nu32 cpu;\r\ncpu = get_cpu();\r\nret = os_get_thread_area(info, userspace_pid[cpu]);\r\nput_cpu();\r\nif (ret)\r\nprintk(KERN_ERR "PTRACE_GET_THREAD_AREA failed, err = %d, "\r\n"index = %d\n", ret, info->entry_number);\r\nreturn ret;\r\n}\r\nstatic int get_free_idx(struct task_struct* task)\r\n{\r\nstruct thread_struct *t = &task->thread;\r\nint idx;\r\nif (!t->arch.tls_array)\r\nreturn GDT_ENTRY_TLS_MIN;\r\nfor (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)\r\nif (!t->arch.tls_array[idx].present)\r\nreturn idx + GDT_ENTRY_TLS_MIN;\r\nreturn -ESRCH;\r\n}\r\nstatic inline void clear_user_desc(struct user_desc* info)\r\n{\r\nmemset(info, 0, sizeof(*info));\r\ninfo->read_exec_only = 1;\r\ninfo->seg_not_present = 1;\r\n}\r\nstatic int load_TLS(int flags, struct task_struct *to)\r\n{\r\nint ret = 0;\r\nint idx;\r\nfor (idx = GDT_ENTRY_TLS_MIN; idx < GDT_ENTRY_TLS_MAX; idx++) {\r\nstruct uml_tls_struct* curr =\r\n&to->thread.arch.tls_array[idx - GDT_ENTRY_TLS_MIN];\r\nif (!curr->present) {\r\nif (!curr->flushed) {\r\nclear_user_desc(&curr->tls);\r\ncurr->tls.entry_number = idx;\r\n} else {\r\nWARN_ON(!LDT_empty(&curr->tls));\r\ncontinue;\r\n}\r\n}\r\nif (!(flags & O_FORCE) && curr->flushed)\r\ncontinue;\r\nret = do_set_thread_area(&curr->tls);\r\nif (ret)\r\ngoto out;\r\ncurr->flushed = 1;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int needs_TLS_update(struct task_struct *task)\r\n{\r\nint i;\r\nint ret = 0;\r\nfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\r\nstruct uml_tls_struct* curr =\r\n&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\r\nif (curr->flushed)\r\ncontinue;\r\nret = 1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid clear_flushed_tls(struct task_struct *task)\r\n{\r\nint i;\r\nfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\r\nstruct uml_tls_struct* curr =\r\n&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\r\nif (!curr->present)\r\ncontinue;\r\ncurr->flushed = 0;\r\n}\r\n}\r\nint arch_switch_tls(struct task_struct *to)\r\n{\r\nif (!host_supports_tls)\r\nreturn 0;\r\nif (likely(to->mm))\r\nreturn load_TLS(O_FORCE, to);\r\nreturn 0;\r\n}\r\nstatic int set_tls_entry(struct task_struct* task, struct user_desc *info,\r\nint idx, int flushed)\r\n{\r\nstruct thread_struct *t = &task->thread;\r\nif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\r\nreturn -EINVAL;\r\nt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].tls = *info;\r\nt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].present = 1;\r\nt->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed = flushed;\r\nreturn 0;\r\n}\r\nint arch_copy_tls(struct task_struct *new)\r\n{\r\nstruct user_desc info;\r\nint idx, ret = -EFAULT;\r\nif (copy_from_user(&info,\r\n(void __user *) UPT_SI(&new->thread.regs.regs),\r\nsizeof(info)))\r\ngoto out;\r\nret = -EINVAL;\r\nif (LDT_empty(&info))\r\ngoto out;\r\nidx = info.entry_number;\r\nret = set_tls_entry(new, &info, idx, 0);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int get_tls_entry(struct task_struct *task, struct user_desc *info,\r\nint idx)\r\n{\r\nstruct thread_struct *t = &task->thread;\r\nif (!t->arch.tls_array)\r\ngoto clear;\r\nif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\r\nreturn -EINVAL;\r\nif (!t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].present)\r\ngoto clear;\r\n*info = t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].tls;\r\nout:\r\nif (unlikely(task == current &&\r\n!t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed)) {\r\nprintk(KERN_ERR "get_tls_entry: task with pid %d got here "\r\n"without flushed TLS.", current->pid);\r\n}\r\nreturn 0;\r\nclear:\r\nclear_user_desc(info);\r\ninfo->entry_number = idx;\r\ngoto out;\r\n}\r\nint ptrace_set_thread_area(struct task_struct *child, int idx,\r\nstruct user_desc __user *user_desc)\r\n{\r\nstruct user_desc info;\r\nif (!host_supports_tls)\r\nreturn -EIO;\r\nif (copy_from_user(&info, user_desc, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn set_tls_entry(child, &info, idx, 0);\r\n}\r\nint ptrace_get_thread_area(struct task_struct *child, int idx,\r\nstruct user_desc __user *user_desc)\r\n{\r\nstruct user_desc info;\r\nint ret;\r\nif (!host_supports_tls)\r\nreturn -EIO;\r\nret = get_tls_entry(child, &info, idx);\r\nif (ret < 0)\r\ngoto out;\r\nif (copy_to_user(user_desc, &info, sizeof(info)))\r\nret = -EFAULT;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init __setup_host_supports_tls(void)\r\n{\r\ncheck_host_supports_tls(&host_supports_tls, &host_gdt_entry_tls_min);\r\nif (host_supports_tls) {\r\nprintk(KERN_INFO "Host TLS support detected\n");\r\nprintk(KERN_INFO "Detected host type: ");\r\nswitch (host_gdt_entry_tls_min) {\r\ncase GDT_ENTRY_TLS_MIN_I386:\r\nprintk(KERN_CONT "i386");\r\nbreak;\r\ncase GDT_ENTRY_TLS_MIN_X86_64:\r\nprintk(KERN_CONT "x86_64");\r\nbreak;\r\n}\r\nprintk(KERN_CONT " (GDT indexes %d to %d)\n",\r\nhost_gdt_entry_tls_min,\r\nhost_gdt_entry_tls_min + GDT_ENTRY_TLS_ENTRIES);\r\n} else\r\nprintk(KERN_ERR " Host TLS support NOT detected! "\r\n"TLS support inside UML will not work\n");\r\nreturn 0;\r\n}
