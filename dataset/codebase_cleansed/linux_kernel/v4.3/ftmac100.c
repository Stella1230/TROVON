static void ftmac100_enable_all_int(struct ftmac100 *priv)\r\n{\r\niowrite32(INT_MASK_ALL_ENABLED, priv->base + FTMAC100_OFFSET_IMR);\r\n}\r\nstatic void ftmac100_disable_all_int(struct ftmac100 *priv)\r\n{\r\niowrite32(INT_MASK_ALL_DISABLED, priv->base + FTMAC100_OFFSET_IMR);\r\n}\r\nstatic void ftmac100_set_rx_ring_base(struct ftmac100 *priv, dma_addr_t addr)\r\n{\r\niowrite32(addr, priv->base + FTMAC100_OFFSET_RXR_BADR);\r\n}\r\nstatic void ftmac100_set_tx_ring_base(struct ftmac100 *priv, dma_addr_t addr)\r\n{\r\niowrite32(addr, priv->base + FTMAC100_OFFSET_TXR_BADR);\r\n}\r\nstatic void ftmac100_txdma_start_polling(struct ftmac100 *priv)\r\n{\r\niowrite32(1, priv->base + FTMAC100_OFFSET_TXPD);\r\n}\r\nstatic int ftmac100_reset(struct ftmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nint i;\r\niowrite32(FTMAC100_MACCR_SW_RST, priv->base + FTMAC100_OFFSET_MACCR);\r\nfor (i = 0; i < 5; i++) {\r\nunsigned int maccr;\r\nmaccr = ioread32(priv->base + FTMAC100_OFFSET_MACCR);\r\nif (!(maccr & FTMAC100_MACCR_SW_RST)) {\r\nudelay(500);\r\nreturn 0;\r\n}\r\nudelay(1000);\r\n}\r\nnetdev_err(netdev, "software reset failed\n");\r\nreturn -EIO;\r\n}\r\nstatic void ftmac100_set_mac(struct ftmac100 *priv, const unsigned char *mac)\r\n{\r\nunsigned int maddr = mac[0] << 8 | mac[1];\r\nunsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];\r\niowrite32(maddr, priv->base + FTMAC100_OFFSET_MAC_MADR);\r\niowrite32(laddr, priv->base + FTMAC100_OFFSET_MAC_LADR);\r\n}\r\nstatic int ftmac100_start_hw(struct ftmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nif (ftmac100_reset(priv))\r\nreturn -EIO;\r\nftmac100_set_rx_ring_base(priv,\r\npriv->descs_dma_addr +\r\noffsetof(struct ftmac100_descs, rxdes));\r\nftmac100_set_tx_ring_base(priv,\r\npriv->descs_dma_addr +\r\noffsetof(struct ftmac100_descs, txdes));\r\niowrite32(FTMAC100_APTC_RXPOLL_CNT(1), priv->base + FTMAC100_OFFSET_APTC);\r\nftmac100_set_mac(priv, netdev->dev_addr);\r\niowrite32(MACCR_ENABLE_ALL, priv->base + FTMAC100_OFFSET_MACCR);\r\nreturn 0;\r\n}\r\nstatic void ftmac100_stop_hw(struct ftmac100 *priv)\r\n{\r\niowrite32(0, priv->base + FTMAC100_OFFSET_MACCR);\r\n}\r\nstatic bool ftmac100_rxdes_first_segment(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_FRS);\r\n}\r\nstatic bool ftmac100_rxdes_last_segment(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_LRS);\r\n}\r\nstatic bool ftmac100_rxdes_owned_by_dma(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RXDMA_OWN);\r\n}\r\nstatic void ftmac100_rxdes_set_dma_own(struct ftmac100_rxdes *rxdes)\r\n{\r\nrxdes->rxdes0 = cpu_to_le32(FTMAC100_RXDES0_RXDMA_OWN);\r\n}\r\nstatic bool ftmac100_rxdes_rx_error(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RX_ERR);\r\n}\r\nstatic bool ftmac100_rxdes_crc_error(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_CRC_ERR);\r\n}\r\nstatic bool ftmac100_rxdes_frame_too_long(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_FTL);\r\n}\r\nstatic bool ftmac100_rxdes_runt(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RUNT);\r\n}\r\nstatic bool ftmac100_rxdes_odd_nibble(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_RX_ODD_NB);\r\n}\r\nstatic unsigned int ftmac100_rxdes_frame_length(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn le32_to_cpu(rxdes->rxdes0) & FTMAC100_RXDES0_RFL;\r\n}\r\nstatic bool ftmac100_rxdes_multicast(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTMAC100_RXDES0_MULTICAST);\r\n}\r\nstatic void ftmac100_rxdes_set_buffer_size(struct ftmac100_rxdes *rxdes,\r\nunsigned int size)\r\n{\r\nrxdes->rxdes1 &= cpu_to_le32(FTMAC100_RXDES1_EDORR);\r\nrxdes->rxdes1 |= cpu_to_le32(FTMAC100_RXDES1_RXBUF_SIZE(size));\r\n}\r\nstatic void ftmac100_rxdes_set_end_of_ring(struct ftmac100_rxdes *rxdes)\r\n{\r\nrxdes->rxdes1 |= cpu_to_le32(FTMAC100_RXDES1_EDORR);\r\n}\r\nstatic void ftmac100_rxdes_set_dma_addr(struct ftmac100_rxdes *rxdes,\r\ndma_addr_t addr)\r\n{\r\nrxdes->rxdes2 = cpu_to_le32(addr);\r\n}\r\nstatic dma_addr_t ftmac100_rxdes_get_dma_addr(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn le32_to_cpu(rxdes->rxdes2);\r\n}\r\nstatic void ftmac100_rxdes_set_page(struct ftmac100_rxdes *rxdes, struct page *page)\r\n{\r\nrxdes->rxdes3 = (unsigned int)page;\r\n}\r\nstatic struct page *ftmac100_rxdes_get_page(struct ftmac100_rxdes *rxdes)\r\n{\r\nreturn (struct page *)rxdes->rxdes3;\r\n}\r\nstatic int ftmac100_next_rx_pointer(int pointer)\r\n{\r\nreturn (pointer + 1) & (RX_QUEUE_ENTRIES - 1);\r\n}\r\nstatic void ftmac100_rx_pointer_advance(struct ftmac100 *priv)\r\n{\r\npriv->rx_pointer = ftmac100_next_rx_pointer(priv->rx_pointer);\r\n}\r\nstatic struct ftmac100_rxdes *ftmac100_current_rxdes(struct ftmac100 *priv)\r\n{\r\nreturn &priv->descs->rxdes[priv->rx_pointer];\r\n}\r\nstatic struct ftmac100_rxdes *\r\nftmac100_rx_locate_first_segment(struct ftmac100 *priv)\r\n{\r\nstruct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);\r\nwhile (!ftmac100_rxdes_owned_by_dma(rxdes)) {\r\nif (ftmac100_rxdes_first_segment(rxdes))\r\nreturn rxdes;\r\nftmac100_rxdes_set_dma_own(rxdes);\r\nftmac100_rx_pointer_advance(priv);\r\nrxdes = ftmac100_current_rxdes(priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool ftmac100_rx_packet_error(struct ftmac100 *priv,\r\nstruct ftmac100_rxdes *rxdes)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nbool error = false;\r\nif (unlikely(ftmac100_rxdes_rx_error(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx err\n");\r\nnetdev->stats.rx_errors++;\r\nerror = true;\r\n}\r\nif (unlikely(ftmac100_rxdes_crc_error(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx crc err\n");\r\nnetdev->stats.rx_crc_errors++;\r\nerror = true;\r\n}\r\nif (unlikely(ftmac100_rxdes_frame_too_long(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx frame too long\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n} else if (unlikely(ftmac100_rxdes_runt(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx runt\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n} else if (unlikely(ftmac100_rxdes_odd_nibble(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx odd nibble\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n}\r\nreturn error;\r\n}\r\nstatic void ftmac100_rx_drop_packet(struct ftmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);\r\nbool done = false;\r\nif (net_ratelimit())\r\nnetdev_dbg(netdev, "drop packet %p\n", rxdes);\r\ndo {\r\nif (ftmac100_rxdes_last_segment(rxdes))\r\ndone = true;\r\nftmac100_rxdes_set_dma_own(rxdes);\r\nftmac100_rx_pointer_advance(priv);\r\nrxdes = ftmac100_current_rxdes(priv);\r\n} while (!done && !ftmac100_rxdes_owned_by_dma(rxdes));\r\nnetdev->stats.rx_dropped++;\r\n}\r\nstatic bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftmac100_rxdes *rxdes;\r\nstruct sk_buff *skb;\r\nstruct page *page;\r\ndma_addr_t map;\r\nint length;\r\nrxdes = ftmac100_rx_locate_first_segment(priv);\r\nif (!rxdes)\r\nreturn false;\r\nif (unlikely(ftmac100_rx_packet_error(priv, rxdes))) {\r\nftmac100_rx_drop_packet(priv);\r\nreturn true;\r\n}\r\nif (unlikely(!ftmac100_rxdes_last_segment(rxdes)))\r\nBUG();\r\nskb = netdev_alloc_skb_ip_align(netdev, 128);\r\nif (unlikely(!skb)) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "rx skb alloc failed\n");\r\nftmac100_rx_drop_packet(priv);\r\nreturn true;\r\n}\r\nif (unlikely(ftmac100_rxdes_multicast(rxdes)))\r\nnetdev->stats.multicast++;\r\nmap = ftmac100_rxdes_get_dma_addr(rxdes);\r\ndma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\nlength = ftmac100_rxdes_frame_length(rxdes);\r\npage = ftmac100_rxdes_get_page(rxdes);\r\nskb_fill_page_desc(skb, 0, page, 0, length);\r\nskb->len += length;\r\nskb->data_len += length;\r\nif (length > 128) {\r\nskb->truesize += PAGE_SIZE;\r\n__pskb_pull_tail(skb, ETH_HLEN);\r\n} else {\r\n__pskb_pull_tail(skb, length);\r\n}\r\nftmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);\r\nftmac100_rx_pointer_advance(priv);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += skb->len;\r\nnetif_receive_skb(skb);\r\n(*processed)++;\r\nreturn true;\r\n}\r\nstatic void ftmac100_txdes_reset(struct ftmac100_txdes *txdes)\r\n{\r\ntxdes->txdes0 = 0;\r\ntxdes->txdes1 &= cpu_to_le32(FTMAC100_TXDES1_EDOTR);\r\ntxdes->txdes2 = 0;\r\ntxdes->txdes3 = 0;\r\n}\r\nstatic bool ftmac100_txdes_owned_by_dma(struct ftmac100_txdes *txdes)\r\n{\r\nreturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXDMA_OWN);\r\n}\r\nstatic void ftmac100_txdes_set_dma_own(struct ftmac100_txdes *txdes)\r\n{\r\nwmb();\r\ntxdes->txdes0 |= cpu_to_le32(FTMAC100_TXDES0_TXDMA_OWN);\r\n}\r\nstatic bool ftmac100_txdes_excessive_collision(struct ftmac100_txdes *txdes)\r\n{\r\nreturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXPKT_EXSCOL);\r\n}\r\nstatic bool ftmac100_txdes_late_collision(struct ftmac100_txdes *txdes)\r\n{\r\nreturn txdes->txdes0 & cpu_to_le32(FTMAC100_TXDES0_TXPKT_LATECOL);\r\n}\r\nstatic void ftmac100_txdes_set_end_of_ring(struct ftmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_EDOTR);\r\n}\r\nstatic void ftmac100_txdes_set_first_segment(struct ftmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_FTS);\r\n}\r\nstatic void ftmac100_txdes_set_last_segment(struct ftmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_LTS);\r\n}\r\nstatic void ftmac100_txdes_set_txint(struct ftmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_TXIC);\r\n}\r\nstatic void ftmac100_txdes_set_buffer_size(struct ftmac100_txdes *txdes,\r\nunsigned int len)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTMAC100_TXDES1_TXBUF_SIZE(len));\r\n}\r\nstatic void ftmac100_txdes_set_dma_addr(struct ftmac100_txdes *txdes,\r\ndma_addr_t addr)\r\n{\r\ntxdes->txdes2 = cpu_to_le32(addr);\r\n}\r\nstatic dma_addr_t ftmac100_txdes_get_dma_addr(struct ftmac100_txdes *txdes)\r\n{\r\nreturn le32_to_cpu(txdes->txdes2);\r\n}\r\nstatic void ftmac100_txdes_set_skb(struct ftmac100_txdes *txdes, struct sk_buff *skb)\r\n{\r\ntxdes->txdes3 = (unsigned int)skb;\r\n}\r\nstatic struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100_txdes *txdes)\r\n{\r\nreturn (struct sk_buff *)txdes->txdes3;\r\n}\r\nstatic int ftmac100_next_tx_pointer(int pointer)\r\n{\r\nreturn (pointer + 1) & (TX_QUEUE_ENTRIES - 1);\r\n}\r\nstatic void ftmac100_tx_pointer_advance(struct ftmac100 *priv)\r\n{\r\npriv->tx_pointer = ftmac100_next_tx_pointer(priv->tx_pointer);\r\n}\r\nstatic void ftmac100_tx_clean_pointer_advance(struct ftmac100 *priv)\r\n{\r\npriv->tx_clean_pointer = ftmac100_next_tx_pointer(priv->tx_clean_pointer);\r\n}\r\nstatic struct ftmac100_txdes *ftmac100_current_txdes(struct ftmac100 *priv)\r\n{\r\nreturn &priv->descs->txdes[priv->tx_pointer];\r\n}\r\nstatic struct ftmac100_txdes *ftmac100_current_clean_txdes(struct ftmac100 *priv)\r\n{\r\nreturn &priv->descs->txdes[priv->tx_clean_pointer];\r\n}\r\nstatic bool ftmac100_tx_complete_packet(struct ftmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftmac100_txdes *txdes;\r\nstruct sk_buff *skb;\r\ndma_addr_t map;\r\nif (priv->tx_pending == 0)\r\nreturn false;\r\ntxdes = ftmac100_current_clean_txdes(priv);\r\nif (ftmac100_txdes_owned_by_dma(txdes))\r\nreturn false;\r\nskb = ftmac100_txdes_get_skb(txdes);\r\nmap = ftmac100_txdes_get_dma_addr(txdes);\r\nif (unlikely(ftmac100_txdes_excessive_collision(txdes) ||\r\nftmac100_txdes_late_collision(txdes))) {\r\nnetdev->stats.tx_aborted_errors++;\r\n} else {\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\n}\r\ndma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\nftmac100_txdes_reset(txdes);\r\nftmac100_tx_clean_pointer_advance(priv);\r\nspin_lock(&priv->tx_lock);\r\npriv->tx_pending--;\r\nspin_unlock(&priv->tx_lock);\r\nnetif_wake_queue(netdev);\r\nreturn true;\r\n}\r\nstatic void ftmac100_tx_complete(struct ftmac100 *priv)\r\n{\r\nwhile (ftmac100_tx_complete_packet(priv))\r\n;\r\n}\r\nstatic int ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,\r\ndma_addr_t map)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftmac100_txdes *txdes;\r\nunsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\r\ntxdes = ftmac100_current_txdes(priv);\r\nftmac100_tx_pointer_advance(priv);\r\nftmac100_txdes_set_skb(txdes, skb);\r\nftmac100_txdes_set_dma_addr(txdes, map);\r\nftmac100_txdes_set_first_segment(txdes);\r\nftmac100_txdes_set_last_segment(txdes);\r\nftmac100_txdes_set_txint(txdes);\r\nftmac100_txdes_set_buffer_size(txdes, len);\r\nspin_lock(&priv->tx_lock);\r\npriv->tx_pending++;\r\nif (priv->tx_pending == TX_QUEUE_ENTRIES)\r\nnetif_stop_queue(netdev);\r\nftmac100_txdes_set_dma_own(txdes);\r\nspin_unlock(&priv->tx_lock);\r\nftmac100_txdma_start_polling(priv);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ftmac100_alloc_rx_page(struct ftmac100 *priv,\r\nstruct ftmac100_rxdes *rxdes, gfp_t gfp)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct page *page;\r\ndma_addr_t map;\r\npage = alloc_page(gfp);\r\nif (!page) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "failed to allocate rx page\n");\r\nreturn -ENOMEM;\r\n}\r\nmap = dma_map_page(priv->dev, page, 0, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(priv->dev, map))) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "failed to map rx page\n");\r\n__free_page(page);\r\nreturn -ENOMEM;\r\n}\r\nftmac100_rxdes_set_page(rxdes, page);\r\nftmac100_rxdes_set_dma_addr(rxdes, map);\r\nftmac100_rxdes_set_buffer_size(rxdes, RX_BUF_SIZE);\r\nftmac100_rxdes_set_dma_own(rxdes);\r\nreturn 0;\r\n}\r\nstatic void ftmac100_free_buffers(struct ftmac100 *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\r\nstruct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];\r\nstruct page *page = ftmac100_rxdes_get_page(rxdes);\r\ndma_addr_t map = ftmac100_rxdes_get_dma_addr(rxdes);\r\nif (!page)\r\ncontinue;\r\ndma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\n__free_page(page);\r\n}\r\nfor (i = 0; i < TX_QUEUE_ENTRIES; i++) {\r\nstruct ftmac100_txdes *txdes = &priv->descs->txdes[i];\r\nstruct sk_buff *skb = ftmac100_txdes_get_skb(txdes);\r\ndma_addr_t map = ftmac100_txdes_get_dma_addr(txdes);\r\nif (!skb)\r\ncontinue;\r\ndma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\n}\r\ndma_free_coherent(priv->dev, sizeof(struct ftmac100_descs),\r\npriv->descs, priv->descs_dma_addr);\r\n}\r\nstatic int ftmac100_alloc_buffers(struct ftmac100 *priv)\r\n{\r\nint i;\r\npriv->descs = dma_zalloc_coherent(priv->dev,\r\nsizeof(struct ftmac100_descs),\r\n&priv->descs_dma_addr,\r\nGFP_KERNEL);\r\nif (!priv->descs)\r\nreturn -ENOMEM;\r\nftmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);\r\nfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\r\nstruct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];\r\nif (ftmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))\r\ngoto err;\r\n}\r\nftmac100_txdes_set_end_of_ring(&priv->descs->txdes[TX_QUEUE_ENTRIES - 1]);\r\nreturn 0;\r\nerr:\r\nftmac100_free_buffers(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int ftmac100_mdio_read(struct net_device *netdev, int phy_id, int reg)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nunsigned int phycr;\r\nint i;\r\nphycr = FTMAC100_PHYCR_PHYAD(phy_id) |\r\nFTMAC100_PHYCR_REGAD(reg) |\r\nFTMAC100_PHYCR_MIIRD;\r\niowrite32(phycr, priv->base + FTMAC100_OFFSET_PHYCR);\r\nfor (i = 0; i < 10; i++) {\r\nphycr = ioread32(priv->base + FTMAC100_OFFSET_PHYCR);\r\nif ((phycr & FTMAC100_PHYCR_MIIRD) == 0)\r\nreturn phycr & FTMAC100_PHYCR_MIIRDATA;\r\nudelay(100);\r\n}\r\nnetdev_err(netdev, "mdio read timed out\n");\r\nreturn 0;\r\n}\r\nstatic void ftmac100_mdio_write(struct net_device *netdev, int phy_id, int reg,\r\nint data)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nunsigned int phycr;\r\nint i;\r\nphycr = FTMAC100_PHYCR_PHYAD(phy_id) |\r\nFTMAC100_PHYCR_REGAD(reg) |\r\nFTMAC100_PHYCR_MIIWR;\r\ndata = FTMAC100_PHYWDATA_MIIWDATA(data);\r\niowrite32(data, priv->base + FTMAC100_OFFSET_PHYWDATA);\r\niowrite32(phycr, priv->base + FTMAC100_OFFSET_PHYCR);\r\nfor (i = 0; i < 10; i++) {\r\nphycr = ioread32(priv->base + FTMAC100_OFFSET_PHYCR);\r\nif ((phycr & FTMAC100_PHYCR_MIIWR) == 0)\r\nreturn;\r\nudelay(100);\r\n}\r\nnetdev_err(netdev, "mdio write timed out\n");\r\n}\r\nstatic void ftmac100_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(&netdev->dev), sizeof(info->bus_info));\r\n}\r\nstatic int ftmac100_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nreturn mii_ethtool_gset(&priv->mii, cmd);\r\n}\r\nstatic int ftmac100_set_settings(struct net_device *netdev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nreturn mii_ethtool_sset(&priv->mii, cmd);\r\n}\r\nstatic int ftmac100_nway_reset(struct net_device *netdev)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nreturn mii_nway_restart(&priv->mii);\r\n}\r\nstatic u32 ftmac100_get_link(struct net_device *netdev)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nreturn mii_link_ok(&priv->mii);\r\n}\r\nstatic irqreturn_t ftmac100_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *netdev = dev_id;\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nif (likely(netif_running(netdev))) {\r\nftmac100_disable_all_int(priv);\r\nnapi_schedule(&priv->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ftmac100_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ftmac100 *priv = container_of(napi, struct ftmac100, napi);\r\nstruct net_device *netdev = priv->netdev;\r\nunsigned int status;\r\nbool completed = true;\r\nint rx = 0;\r\nstatus = ioread32(priv->base + FTMAC100_OFFSET_ISR);\r\nif (status & (FTMAC100_INT_RPKT_FINISH | FTMAC100_INT_NORXBUF)) {\r\nbool retry;\r\ndo {\r\nretry = ftmac100_rx_packet(priv, &rx);\r\n} while (retry && rx < budget);\r\nif (retry && rx == budget)\r\ncompleted = false;\r\n}\r\nif (status & (FTMAC100_INT_XPKT_OK | FTMAC100_INT_XPKT_LOST)) {\r\nftmac100_tx_complete(priv);\r\n}\r\nif (status & (FTMAC100_INT_NORXBUF | FTMAC100_INT_RPKT_LOST |\r\nFTMAC100_INT_AHB_ERR | FTMAC100_INT_PHYSTS_CHG)) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "[ISR] = 0x%x: %s%s%s%s\n", status,\r\nstatus & FTMAC100_INT_NORXBUF ? "NORXBUF " : "",\r\nstatus & FTMAC100_INT_RPKT_LOST ? "RPKT_LOST " : "",\r\nstatus & FTMAC100_INT_AHB_ERR ? "AHB_ERR " : "",\r\nstatus & FTMAC100_INT_PHYSTS_CHG ? "PHYSTS_CHG" : "");\r\nif (status & FTMAC100_INT_NORXBUF) {\r\nnetdev->stats.rx_over_errors++;\r\n}\r\nif (status & FTMAC100_INT_RPKT_LOST) {\r\nnetdev->stats.rx_fifo_errors++;\r\n}\r\nif (status & FTMAC100_INT_PHYSTS_CHG) {\r\nmii_check_link(&priv->mii);\r\n}\r\n}\r\nif (completed) {\r\nnapi_complete(napi);\r\nftmac100_enable_all_int(priv);\r\n}\r\nreturn rx;\r\n}\r\nstatic int ftmac100_open(struct net_device *netdev)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nint err;\r\nerr = ftmac100_alloc_buffers(priv);\r\nif (err) {\r\nnetdev_err(netdev, "failed to allocate buffers\n");\r\ngoto err_alloc;\r\n}\r\nerr = request_irq(priv->irq, ftmac100_interrupt, 0, netdev->name, netdev);\r\nif (err) {\r\nnetdev_err(netdev, "failed to request irq %d\n", priv->irq);\r\ngoto err_irq;\r\n}\r\npriv->rx_pointer = 0;\r\npriv->tx_clean_pointer = 0;\r\npriv->tx_pointer = 0;\r\npriv->tx_pending = 0;\r\nerr = ftmac100_start_hw(priv);\r\nif (err)\r\ngoto err_hw;\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(netdev);\r\nftmac100_enable_all_int(priv);\r\nreturn 0;\r\nerr_hw:\r\nfree_irq(priv->irq, netdev);\r\nerr_irq:\r\nftmac100_free_buffers(priv);\r\nerr_alloc:\r\nreturn err;\r\n}\r\nstatic int ftmac100_stop(struct net_device *netdev)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nftmac100_disable_all_int(priv);\r\nnetif_stop_queue(netdev);\r\nnapi_disable(&priv->napi);\r\nftmac100_stop_hw(priv);\r\nfree_irq(priv->irq, netdev);\r\nftmac100_free_buffers(priv);\r\nreturn 0;\r\n}\r\nstatic int ftmac100_hard_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\ndma_addr_t map;\r\nif (unlikely(skb->len > MAX_PKT_SIZE)) {\r\nif (net_ratelimit())\r\nnetdev_dbg(netdev, "tx packet too big\n");\r\nnetdev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nmap = dma_map_single(priv->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(priv->dev, map))) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "map socket buffer failed\n");\r\nnetdev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nreturn ftmac100_xmit(priv, skb, map);\r\n}\r\nstatic int ftmac100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct ftmac100 *priv = netdev_priv(netdev);\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nreturn generic_mii_ioctl(&priv->mii, data, cmd, NULL);\r\n}\r\nstatic int ftmac100_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint irq;\r\nstruct net_device *netdev;\r\nstruct ftmac100 *priv;\r\nint err;\r\nif (!pdev)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nnetdev = alloc_etherdev(sizeof(*priv));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_etherdev;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nnetdev->ethtool_ops = &ftmac100_ethtool_ops;\r\nnetdev->netdev_ops = &ftmac100_netdev_ops;\r\nplatform_set_drvdata(pdev, netdev);\r\npriv = netdev_priv(netdev);\r\npriv->netdev = netdev;\r\npriv->dev = &pdev->dev;\r\nspin_lock_init(&priv->tx_lock);\r\nnetif_napi_add(netdev, &priv->napi, ftmac100_poll, 64);\r\npriv->res = request_mem_region(res->start, resource_size(res),\r\ndev_name(&pdev->dev));\r\nif (!priv->res) {\r\ndev_err(&pdev->dev, "Could not reserve memory region\n");\r\nerr = -ENOMEM;\r\ngoto err_req_mem;\r\n}\r\npriv->base = ioremap(res->start, resource_size(res));\r\nif (!priv->base) {\r\ndev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\npriv->irq = irq;\r\npriv->mii.phy_id = 0;\r\npriv->mii.phy_id_mask = 0x1f;\r\npriv->mii.reg_num_mask = 0x1f;\r\npriv->mii.dev = netdev;\r\npriv->mii.mdio_read = ftmac100_mdio_read;\r\npriv->mii.mdio_write = ftmac100_mdio_write;\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register netdev\n");\r\ngoto err_register_netdev;\r\n}\r\nnetdev_info(netdev, "irq %d, mapped at %p\n", priv->irq, priv->base);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\neth_hw_addr_random(netdev);\r\nnetdev_info(netdev, "generated random MAC address %pM\n",\r\nnetdev->dev_addr);\r\n}\r\nreturn 0;\r\nerr_register_netdev:\r\niounmap(priv->base);\r\nerr_ioremap:\r\nrelease_resource(priv->res);\r\nerr_req_mem:\r\nnetif_napi_del(&priv->napi);\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\nreturn err;\r\n}\r\nstatic int __exit ftmac100_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev;\r\nstruct ftmac100 *priv;\r\nnetdev = platform_get_drvdata(pdev);\r\npriv = netdev_priv(netdev);\r\nunregister_netdev(netdev);\r\niounmap(priv->base);\r\nrelease_resource(priv->res);\r\nnetif_napi_del(&priv->napi);\r\nfree_netdev(netdev);\r\nreturn 0;\r\n}\r\nstatic int __init ftmac100_init(void)\r\n{\r\npr_info("Loading version " DRV_VERSION " ...\n");\r\nreturn platform_driver_register(&ftmac100_driver);\r\n}\r\nstatic void __exit ftmac100_exit(void)\r\n{\r\nplatform_driver_unregister(&ftmac100_driver);\r\n}
