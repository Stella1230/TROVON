static int synaptics_send_cmd(struct psmouse *psmouse, unsigned char c,\r\nunsigned char *param)\r\n{\r\nif (psmouse_sliced_command(psmouse, c) ||\r\nps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npsmouse_err(psmouse, "%s query 0x%02x failed.\n", __func__, c);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elantech_send_cmd(struct psmouse *psmouse, unsigned char c,\r\nunsigned char *param)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nps2_command(ps2dev, NULL, c) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npsmouse_err(psmouse, "%s query 0x%02x failed.\n", __func__, c);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elantech_ps2_command(struct psmouse *psmouse,\r\nunsigned char *param, int command)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nint rc;\r\nint tries = ETP_PS2_COMMAND_TRIES;\r\ndo {\r\nrc = ps2_command(ps2dev, param, command);\r\nif (rc == 0)\r\nbreak;\r\ntries--;\r\nelantech_debug("retrying ps2 command 0x%02x (%d).\n",\r\ncommand, tries);\r\nmsleep(ETP_PS2_COMMAND_DELAY);\r\n} while (tries > 0);\r\nif (rc)\r\npsmouse_err(psmouse, "ps2 command 0x%02x failed.\n", command);\r\nreturn rc;\r\n}\r\nstatic int elantech_read_reg(struct psmouse *psmouse, unsigned char reg,\r\nunsigned char *val)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char param[3];\r\nint rc = 0;\r\nif (reg < 0x07 || reg > 0x26)\r\nreturn -1;\r\nif (reg > 0x11 && reg < 0x20)\r\nreturn -1;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (psmouse_sliced_command(psmouse, ETP_REGISTER_READ) ||\r\npsmouse_sliced_command(psmouse, reg) ||\r\nps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READ) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 3 ... 4:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\r\nrc = -1;\r\n}\r\nbreak;\r\n}\r\nif (rc)\r\npsmouse_err(psmouse, "failed to read register 0x%02x.\n", reg);\r\nelse if (etd->hw_version != 4)\r\n*val = param[0];\r\nelse\r\n*val = param[1];\r\nreturn rc;\r\n}\r\nstatic int elantech_write_reg(struct psmouse *psmouse, unsigned char reg,\r\nunsigned char val)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nint rc = 0;\r\nif (reg < 0x07 || reg > 0x26)\r\nreturn -1;\r\nif (reg > 0x11 && reg < 0x20)\r\nreturn -1;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (psmouse_sliced_command(psmouse, ETP_REGISTER_WRITE) ||\r\npsmouse_sliced_command(psmouse, reg) ||\r\npsmouse_sliced_command(psmouse, val) ||\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_WRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, val) ||\r\nelantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 3:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, val) ||\r\nelantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 4:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, val) ||\r\nelantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\n}\r\nif (rc)\r\npsmouse_err(psmouse,\r\n"failed to write register 0x%02x with value 0x%02x.\n",\r\nreg, val);\r\nreturn rc;\r\n}\r\nstatic void elantech_packet_dump(struct psmouse *psmouse)\r\n{\r\nint i;\r\npsmouse_printk(KERN_DEBUG, psmouse, "PS/2 packet [");\r\nfor (i = 0; i < psmouse->pktsize; i++)\r\nprintk("%s0x%02x ", i ? ", " : " ", psmouse->packet[i]);\r\nprintk("]\n");\r\n}\r\nstatic void elantech_report_absolute_v1(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nint fingers;\r\nif (etd->fw_version < 0x020000) {\r\nfingers = ((packet[1] & 0x80) >> 7) +\r\n((packet[1] & 0x30) >> 4);\r\n} else {\r\nfingers = (packet[0] & 0xc0) >> 6;\r\n}\r\nif (etd->jumpy_cursor) {\r\nif (fingers != 1) {\r\netd->single_finger_reports = 0;\r\n} else if (etd->single_finger_reports < 2) {\r\netd->single_finger_reports++;\r\nelantech_debug("discarding packet\n");\r\nreturn;\r\n}\r\n}\r\ninput_report_key(dev, BTN_TOUCH, fingers != 0);\r\nif (fingers) {\r\ninput_report_abs(dev, ABS_X,\r\n((packet[1] & 0x0c) << 6) | packet[2]);\r\ninput_report_abs(dev, ABS_Y,\r\netd->y_max - (((packet[1] & 0x03) << 8) | packet[3]));\r\n}\r\ninput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\nif (etd->fw_version < 0x020000 &&\r\n(etd->capabilities[0] & ETP_CAP_HAS_ROCKER)) {\r\ninput_report_key(dev, BTN_FORWARD, packet[0] & 0x40);\r\ninput_report_key(dev, BTN_BACK, packet[0] & 0x80);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void elantech_set_slot(struct input_dev *dev, int slot, bool active,\r\nunsigned int x, unsigned int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\nstatic void elantech_report_semi_mt_data(struct input_dev *dev,\r\nunsigned int num_fingers,\r\nunsigned int x1, unsigned int y1,\r\nunsigned int x2, unsigned int y2)\r\n{\r\nelantech_set_slot(dev, 0, num_fingers != 0, x1, y1);\r\nelantech_set_slot(dev, 1, num_fingers >= 2, x2, y2);\r\n}\r\nstatic void elantech_report_absolute_v2(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned int fingers, x1 = 0, y1 = 0, x2 = 0, y2 = 0;\r\nunsigned int width = 0, pres = 0;\r\nfingers = (packet[0] & 0xc0) >> 6;\r\nswitch (fingers) {\r\ncase 3:\r\nif (packet[3] & 0x80)\r\nfingers = 4;\r\ncase 1:\r\nx1 = ((packet[1] & 0x0f) << 8) | packet[2];\r\ny1 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\r\npres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\r\nwidth = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);\r\nbreak;\r\ncase 2:\r\nx1 = (((packet[0] & 0x10) << 4) | packet[1]) << 2;\r\ny1 = etd->y_max -\r\n((((packet[0] & 0x20) << 3) | packet[2]) << 2);\r\nx2 = (((packet[3] & 0x10) << 4) | packet[4]) << 2;\r\ny2 = etd->y_max -\r\n((((packet[3] & 0x20) << 3) | packet[5]) << 2);\r\npres = 127;\r\nwidth = 7;\r\nbreak;\r\n}\r\ninput_report_key(dev, BTN_TOUCH, fingers != 0);\r\nif (fingers != 0) {\r\ninput_report_abs(dev, ABS_X, x1);\r\ninput_report_abs(dev, ABS_Y, y1);\r\n}\r\nelantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\r\ninput_report_key(dev, BTN_TOOL_QUADTAP, fingers == 4);\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\nif (etd->reports_pressure) {\r\ninput_report_abs(dev, ABS_PRESSURE, pres);\r\ninput_report_abs(dev, ABS_TOOL_WIDTH, width);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void elantech_report_trackpoint(struct psmouse *psmouse,\r\nint packet_type)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct input_dev *tp_dev = etd->tp_dev;\r\nunsigned char *packet = psmouse->packet;\r\nint x, y;\r\nu32 t;\r\nt = get_unaligned_le32(&packet[0]);\r\nswitch (t & ~7U) {\r\ncase 0x06000030U:\r\ncase 0x16008020U:\r\ncase 0x26800010U:\r\ncase 0x36808000U:\r\nx = packet[4] - (int)((packet[1]^0x80) << 1);\r\ny = (int)((packet[2]^0x80) << 1) - packet[5];\r\ninput_report_key(tp_dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(tp_dev, BTN_RIGHT, packet[0] & 0x02);\r\ninput_report_key(tp_dev, BTN_MIDDLE, packet[0] & 0x04);\r\ninput_report_rel(tp_dev, REL_X, x);\r\ninput_report_rel(tp_dev, REL_Y, y);\r\ninput_sync(tp_dev);\r\nbreak;\r\ndefault:\r\nif (etd->debug == 1)\r\nelantech_packet_dump(psmouse);\r\nbreak;\r\n}\r\n}\r\nstatic void elantech_report_absolute_v3(struct psmouse *psmouse,\r\nint packet_type)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned int fingers = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0;\r\nunsigned int width = 0, pres = 0;\r\nfingers = (packet[0] & 0xc0) >> 6;\r\nswitch (fingers) {\r\ncase 3:\r\ncase 1:\r\nx1 = ((packet[1] & 0x0f) << 8) | packet[2];\r\ny1 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\r\nbreak;\r\ncase 2:\r\nif (packet_type == PACKET_V3_HEAD) {\r\netd->mt[0].x = ((packet[1] & 0x0f) << 8) | packet[2];\r\netd->mt[0].y = etd->y_max -\r\n(((packet[4] & 0x0f) << 8) | packet[5]);\r\nreturn;\r\n}\r\nx1 = etd->mt[0].x;\r\ny1 = etd->mt[0].y;\r\nx2 = ((packet[1] & 0x0f) << 8) | packet[2];\r\ny2 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\r\nbreak;\r\n}\r\npres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\r\nwidth = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);\r\ninput_report_key(dev, BTN_TOUCH, fingers != 0);\r\nif (fingers != 0) {\r\ninput_report_abs(dev, ABS_X, x1);\r\ninput_report_abs(dev, ABS_Y, y1);\r\n}\r\nelantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\r\nif (etd->fw_version & 0x001000) {\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x03);\r\n} else {\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, pres);\r\ninput_report_abs(dev, ABS_TOOL_WIDTH, width);\r\ninput_sync(dev);\r\n}\r\nstatic void elantech_input_sync_v4(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nif (etd->fw_version & 0x001000) {\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x03);\r\n} else {\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\ninput_report_key(dev, BTN_MIDDLE, packet[0] & 0x04);\r\n}\r\ninput_mt_report_pointer_emulation(dev, true);\r\ninput_sync(dev);\r\n}\r\nstatic void process_packet_status_v4(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned fingers;\r\nint i;\r\nfingers = packet[1] & 0x1f;\r\nfor (i = 0; i < ETP_MAX_FINGERS; i++) {\r\nif ((fingers & (1 << i)) == 0) {\r\ninput_mt_slot(dev, i);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, false);\r\n}\r\n}\r\nelantech_input_sync_v4(psmouse);\r\n}\r\nstatic void process_packet_head_v4(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nint id = ((packet[3] & 0xe0) >> 5) - 1;\r\nint pres, traces;\r\nif (id < 0)\r\nreturn;\r\netd->mt[id].x = ((packet[1] & 0x0f) << 8) | packet[2];\r\netd->mt[id].y = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\r\npres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\r\ntraces = (packet[0] & 0xf0) >> 4;\r\ninput_mt_slot(dev, id);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, true);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[id].x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[id].y);\r\ninput_report_abs(dev, ABS_MT_PRESSURE, pres);\r\ninput_report_abs(dev, ABS_MT_TOUCH_MAJOR, traces * etd->width);\r\ninput_report_abs(dev, ABS_TOOL_WIDTH, traces);\r\nelantech_input_sync_v4(psmouse);\r\n}\r\nstatic void process_packet_motion_v4(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nint weight, delta_x1 = 0, delta_y1 = 0, delta_x2 = 0, delta_y2 = 0;\r\nint id, sid;\r\nid = ((packet[0] & 0xe0) >> 5) - 1;\r\nif (id < 0)\r\nreturn;\r\nsid = ((packet[3] & 0xe0) >> 5) - 1;\r\nweight = (packet[0] & 0x10) ? ETP_WEIGHT_VALUE : 1;\r\ndelta_x1 = (signed char)packet[1];\r\ndelta_y1 = (signed char)packet[2];\r\ndelta_x2 = (signed char)packet[4];\r\ndelta_y2 = (signed char)packet[5];\r\netd->mt[id].x += delta_x1 * weight;\r\netd->mt[id].y -= delta_y1 * weight;\r\ninput_mt_slot(dev, id);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[id].x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[id].y);\r\nif (sid >= 0) {\r\netd->mt[sid].x += delta_x2 * weight;\r\netd->mt[sid].y -= delta_y2 * weight;\r\ninput_mt_slot(dev, sid);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[sid].x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[sid].y);\r\n}\r\nelantech_input_sync_v4(psmouse);\r\n}\r\nstatic void elantech_report_absolute_v4(struct psmouse *psmouse,\r\nint packet_type)\r\n{\r\nswitch (packet_type) {\r\ncase PACKET_V4_STATUS:\r\nprocess_packet_status_v4(psmouse);\r\nbreak;\r\ncase PACKET_V4_HEAD:\r\nprocess_packet_head_v4(psmouse);\r\nbreak;\r\ncase PACKET_V4_MOTION:\r\nprocess_packet_motion_v4(psmouse);\r\nbreak;\r\ncase PACKET_UNKNOWN:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int elantech_packet_check_v1(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned char p1, p2, p3;\r\nif (etd->fw_version < 0x020000) {\r\np1 = (packet[0] & 0x20) >> 5;\r\np2 = (packet[0] & 0x10) >> 4;\r\n} else {\r\np1 = (packet[0] & 0x10) >> 4;\r\np2 = (packet[0] & 0x20) >> 5;\r\n}\r\np3 = (packet[0] & 0x04) >> 2;\r\nreturn etd->parity[packet[1]] == p1 &&\r\netd->parity[packet[2]] == p2 &&\r\netd->parity[packet[3]] == p3;\r\n}\r\nstatic int elantech_debounce_check_v2(struct psmouse *psmouse)\r\n{\r\nconst u8 debounce_packet[] = { 0x84, 0xff, 0xff, 0x02, 0xff, 0xff };\r\nunsigned char *packet = psmouse->packet;\r\nreturn !memcmp(packet, debounce_packet, sizeof(debounce_packet));\r\n}\r\nstatic int elantech_packet_check_v2(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nif (etd->reports_pressure)\r\nreturn (packet[0] & 0x0c) == 0x04 &&\r\n(packet[3] & 0x0f) == 0x02;\r\nif ((packet[0] & 0xc0) == 0x80)\r\nreturn (packet[0] & 0x0c) == 0x0c &&\r\n(packet[3] & 0x0e) == 0x08;\r\nreturn (packet[0] & 0x3c) == 0x3c &&\r\n(packet[1] & 0xf0) == 0x00 &&\r\n(packet[3] & 0x3e) == 0x38 &&\r\n(packet[4] & 0xf0) == 0x00;\r\n}\r\nstatic int elantech_packet_check_v3(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nconst u8 debounce_packet[] = { 0xc4, 0xff, 0xff, 0x02, 0xff, 0xff };\r\nunsigned char *packet = psmouse->packet;\r\nif (!memcmp(packet, debounce_packet, sizeof(debounce_packet)))\r\nreturn PACKET_DEBOUNCE;\r\nif (etd->crc_enabled) {\r\nif ((packet[3] & 0x09) == 0x08)\r\nreturn PACKET_V3_HEAD;\r\nif ((packet[3] & 0x09) == 0x09)\r\nreturn PACKET_V3_TAIL;\r\n} else {\r\nif ((packet[0] & 0x0c) == 0x04 && (packet[3] & 0xcf) == 0x02)\r\nreturn PACKET_V3_HEAD;\r\nif ((packet[0] & 0x0c) == 0x0c && (packet[3] & 0xce) == 0x0c)\r\nreturn PACKET_V3_TAIL;\r\nif ((packet[3] & 0x0f) == 0x06)\r\nreturn PACKET_TRACKPOINT;\r\n}\r\nreturn PACKET_UNKNOWN;\r\n}\r\nstatic int elantech_packet_check_v4(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned char packet_type = packet[3] & 0x03;\r\nunsigned int ic_version;\r\nbool sanity_check;\r\nif (etd->tp_dev && (packet[3] & 0x0f) == 0x06)\r\nreturn PACKET_TRACKPOINT;\r\nic_version = (etd->fw_version & 0x0f0000) >> 16;\r\nif (etd->crc_enabled)\r\nsanity_check = ((packet[3] & 0x08) == 0x00);\r\nelse if (ic_version == 7 && etd->samples[1] == 0x2A)\r\nsanity_check = ((packet[3] & 0x1c) == 0x10);\r\nelse\r\nsanity_check = ((packet[0] & 0x0c) == 0x04 &&\r\n(packet[3] & 0x1c) == 0x10);\r\nif (!sanity_check)\r\nreturn PACKET_UNKNOWN;\r\nswitch (packet_type) {\r\ncase 0:\r\nreturn PACKET_V4_STATUS;\r\ncase 1:\r\nreturn PACKET_V4_HEAD;\r\ncase 2:\r\nreturn PACKET_V4_MOTION;\r\n}\r\nreturn PACKET_UNKNOWN;\r\n}\r\nstatic psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nint packet_type;\r\nif (psmouse->pktcnt < psmouse->pktsize)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (etd->debug > 1)\r\nelantech_packet_dump(psmouse);\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (etd->paritycheck && !elantech_packet_check_v1(psmouse))\r\nreturn PSMOUSE_BAD_DATA;\r\nelantech_report_absolute_v1(psmouse);\r\nbreak;\r\ncase 2:\r\nif (elantech_debounce_check_v2(psmouse))\r\nreturn PSMOUSE_FULL_PACKET;\r\nif (etd->paritycheck && !elantech_packet_check_v2(psmouse))\r\nreturn PSMOUSE_BAD_DATA;\r\nelantech_report_absolute_v2(psmouse);\r\nbreak;\r\ncase 3:\r\npacket_type = elantech_packet_check_v3(psmouse);\r\nswitch (packet_type) {\r\ncase PACKET_UNKNOWN:\r\nreturn PSMOUSE_BAD_DATA;\r\ncase PACKET_DEBOUNCE:\r\nbreak;\r\ncase PACKET_TRACKPOINT:\r\nelantech_report_trackpoint(psmouse, packet_type);\r\nbreak;\r\ndefault:\r\nelantech_report_absolute_v3(psmouse, packet_type);\r\nbreak;\r\n}\r\nbreak;\r\ncase 4:\r\npacket_type = elantech_packet_check_v4(psmouse);\r\nswitch (packet_type) {\r\ncase PACKET_UNKNOWN:\r\nreturn PSMOUSE_BAD_DATA;\r\ncase PACKET_TRACKPOINT:\r\nelantech_report_trackpoint(psmouse, packet_type);\r\nbreak;\r\ndefault:\r\nelantech_report_absolute_v4(psmouse, packet_type);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,\r\nunsigned int rate)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\netd->original_set_rate(psmouse, rate);\r\nif (elantech_write_reg(psmouse, 0x07, etd->reg_07))\r\npsmouse_err(psmouse, "restoring reg_07 failed\n");\r\n}\r\nstatic int elantech_set_absolute_mode(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char val;\r\nint tries = ETP_READ_BACK_TRIES;\r\nint rc = 0;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\netd->reg_10 = 0x16;\r\netd->reg_11 = 0x8f;\r\nif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\r\nelantech_write_reg(psmouse, 0x11, etd->reg_11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\netd->reg_10 = 0x54;\r\netd->reg_11 = 0x88;\r\netd->reg_21 = 0x60;\r\nif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\r\nelantech_write_reg(psmouse, 0x11, etd->reg_11) ||\r\nelantech_write_reg(psmouse, 0x21, etd->reg_21)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 3:\r\nif (etd->set_hw_resolution)\r\netd->reg_10 = 0x0b;\r\nelse\r\netd->reg_10 = 0x01;\r\nif (elantech_write_reg(psmouse, 0x10, etd->reg_10))\r\nrc = -1;\r\nbreak;\r\ncase 4:\r\netd->reg_07 = 0x01;\r\nif (elantech_write_reg(psmouse, 0x07, etd->reg_07))\r\nrc = -1;\r\ngoto skip_readback_reg_10;\r\n}\r\nif (rc == 0) {\r\ndo {\r\nrc = elantech_read_reg(psmouse, 0x10, &val);\r\nif (rc == 0)\r\nbreak;\r\ntries--;\r\nelantech_debug("retrying read (%d).\n", tries);\r\nmsleep(ETP_READ_BACK_DELAY);\r\n} while (tries > 0);\r\nif (rc) {\r\npsmouse_err(psmouse,\r\n"failed to read back register 0x10.\n");\r\n} else if (etd->hw_version == 1 &&\r\n!(val & ETP_R10_ABSOLUTE_MODE)) {\r\npsmouse_err(psmouse,\r\n"touchpad refuses to switch to absolute mode.\n");\r\nrc = -1;\r\n}\r\n}\r\nskip_readback_reg_10:\r\nif (rc)\r\npsmouse_err(psmouse, "failed to initialise registers.\n");\r\nreturn rc;\r\n}\r\nstatic int elantech_set_range(struct psmouse *psmouse,\r\nunsigned int *x_min, unsigned int *y_min,\r\nunsigned int *x_max, unsigned int *y_max,\r\nunsigned int *width)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char param[3];\r\nunsigned char traces;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\n*x_min = ETP_XMIN_V1;\r\n*y_min = ETP_YMIN_V1;\r\n*x_max = ETP_XMAX_V1;\r\n*y_max = ETP_YMAX_V1;\r\nbreak;\r\ncase 2:\r\nif (etd->fw_version == 0x020800 ||\r\netd->fw_version == 0x020b00 ||\r\netd->fw_version == 0x020030) {\r\n*x_min = ETP_XMIN_V2;\r\n*y_min = ETP_YMIN_V2;\r\n*x_max = ETP_XMAX_V2;\r\n*y_max = ETP_YMAX_V2;\r\n} else {\r\nint i;\r\nint fixed_dpi;\r\ni = (etd->fw_version > 0x020800 &&\r\netd->fw_version < 0x020900) ? 1 : 2;\r\nif (etd->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\r\nreturn -1;\r\nfixed_dpi = param[1] & 0x10;\r\nif (((etd->fw_version >> 16) == 0x14) && fixed_dpi) {\r\nif (etd->send_cmd(psmouse, ETP_SAMPLE_QUERY, param))\r\nreturn -1;\r\n*x_max = (etd->capabilities[1] - i) * param[1] / 2;\r\n*y_max = (etd->capabilities[2] - i) * param[2] / 2;\r\n} else if (etd->fw_version == 0x040216) {\r\n*x_max = 819;\r\n*y_max = 405;\r\n} else if (etd->fw_version == 0x040219 || etd->fw_version == 0x040215) {\r\n*x_max = 900;\r\n*y_max = 500;\r\n} else {\r\n*x_max = (etd->capabilities[1] - i) * 64;\r\n*y_max = (etd->capabilities[2] - i) * 64;\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\nif (etd->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\r\nreturn -1;\r\n*x_max = (0x0f & param[0]) << 8 | param[1];\r\n*y_max = (0xf0 & param[0]) << 4 | param[2];\r\nbreak;\r\ncase 4:\r\nif (etd->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\r\nreturn -1;\r\n*x_max = (0x0f & param[0]) << 8 | param[1];\r\n*y_max = (0xf0 & param[0]) << 4 | param[2];\r\ntraces = etd->capabilities[1];\r\nif ((traces < 2) || (traces > *x_max))\r\nreturn -1;\r\n*width = *x_max / (traces - 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int elantech_convert_res(unsigned int val)\r\n{\r\nreturn (val * 10 + 790) * 10 / 254;\r\n}\r\nstatic int elantech_get_resolution_v4(struct psmouse *psmouse,\r\nunsigned int *x_res,\r\nunsigned int *y_res)\r\n{\r\nunsigned char param[3];\r\nif (elantech_send_cmd(psmouse, ETP_RESOLUTION_QUERY, param))\r\nreturn -1;\r\n*x_res = elantech_convert_res(param[1] & 0x0f);\r\n*y_res = elantech_convert_res((param[1] & 0xf0) >> 4);\r\nreturn 0;\r\n}\r\nstatic void elantech_set_buttonpad_prop(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nif (etd->fw_version & 0x001000) {\r\n__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);\r\n__clear_bit(BTN_RIGHT, dev->keybit);\r\n}\r\n}\r\nstatic int elantech_set_input_params(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned int x_min = 0, y_min = 0, x_max = 0, y_max = 0, width = 0;\r\nunsigned int x_res = 31, y_res = 31;\r\nif (elantech_set_range(psmouse, &x_min, &y_min, &x_max, &y_max, &width))\r\nreturn -1;\r\n__set_bit(INPUT_PROP_POINTER, dev->propbit);\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(EV_ABS, dev->evbit);\r\n__clear_bit(EV_REL, dev->evbit);\r\n__set_bit(BTN_LEFT, dev->keybit);\r\nif (dmi_check_system(elantech_dmi_has_middle_button))\r\n__set_bit(BTN_MIDDLE, dev->keybit);\r\n__set_bit(BTN_RIGHT, dev->keybit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (etd->fw_version < 0x020000 &&\r\n(etd->capabilities[0] & ETP_CAP_HAS_ROCKER)) {\r\n__set_bit(BTN_FORWARD, dev->keybit);\r\n__set_bit(BTN_BACK, dev->keybit);\r\n}\r\ninput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\r\nbreak;\r\ncase 2:\r\n__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\r\n__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\r\ncase 3:\r\nif (etd->hw_version == 3)\r\nelantech_set_buttonpad_prop(psmouse);\r\ninput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\r\nif (etd->reports_pressure) {\r\ninput_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2,\r\nETP_PMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,\r\nETP_WMAX_V2, 0, 0);\r\n}\r\ninput_mt_init_slots(dev, 2, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);\r\nbreak;\r\ncase 4:\r\nif (elantech_get_resolution_v4(psmouse, &x_res, &y_res)) {\r\npsmouse_warn(psmouse, "couldn't query resolution data.\n");\r\n}\r\nelantech_set_buttonpad_prop(psmouse);\r\n__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\r\ninput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2,\r\nETP_PMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,\r\nETP_WMAX_V2, 0, 0);\r\ninput_mt_init_slots(dev, ETP_MAX_FINGERS, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_PRESSURE, ETP_PMIN_V2,\r\nETP_PMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_TOUCH_MAJOR, 0,\r\nETP_WMAX_V2 * width, 0, 0);\r\nbreak;\r\n}\r\ninput_abs_set_res(dev, ABS_X, x_res);\r\ninput_abs_set_res(dev, ABS_Y, y_res);\r\nif (etd->hw_version > 1) {\r\ninput_abs_set_res(dev, ABS_MT_POSITION_X, x_res);\r\ninput_abs_set_res(dev, ABS_MT_POSITION_Y, y_res);\r\n}\r\netd->y_max = y_max;\r\netd->width = width;\r\nreturn 0;\r\n}\r\nstatic ssize_t elantech_show_int_attr(struct psmouse *psmouse, void *data,\r\nchar *buf)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct elantech_attr_data *attr = data;\r\nunsigned char *reg = (unsigned char *) etd + attr->field_offset;\r\nint rc = 0;\r\nif (attr->reg)\r\nrc = elantech_read_reg(psmouse, attr->reg, reg);\r\nreturn sprintf(buf, "0x%02x\n", (attr->reg && rc) ? -1 : *reg);\r\n}\r\nstatic ssize_t elantech_set_int_attr(struct psmouse *psmouse,\r\nvoid *data, const char *buf, size_t count)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct elantech_attr_data *attr = data;\r\nunsigned char *reg = (unsigned char *) etd + attr->field_offset;\r\nunsigned char value;\r\nint err;\r\nerr = kstrtou8(buf, 16, &value);\r\nif (err)\r\nreturn err;\r\nif (etd->hw_version == 1) {\r\nif (attr->reg == 0x10)\r\nvalue |= ETP_R10_ABSOLUTE_MODE;\r\nelse if (attr->reg == 0x11)\r\nvalue |= ETP_R11_4_BYTE_MODE;\r\n}\r\nif (!attr->reg || elantech_write_reg(psmouse, attr->reg, value) == 0)\r\n*reg = value;\r\nreturn count;\r\n}\r\nstatic bool elantech_is_signature_valid(const unsigned char *param)\r\n{\r\nstatic const unsigned char rates[] = { 200, 100, 80, 60, 40, 20, 10 };\r\nint i;\r\nif (param[0] == 0)\r\nreturn false;\r\nif (param[1] == 0)\r\nreturn true;\r\nif ((param[0] & 0x0f) >= 0x06 && (param[1] & 0xaf) == 0x0f &&\r\nparam[2] < 40)\r\nreturn true;\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++)\r\nif (param[2] == rates[i])\r\nreturn false;\r\nreturn true;\r\n}\r\nint elantech_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[3];\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npsmouse_dbg(psmouse, "sending Elantech magic knock failed.\n");\r\nreturn -1;\r\n}\r\nif (param[0] != 0x3c || param[1] != 0x03 ||\r\n(param[2] != 0xc8 && param[2] != 0x00)) {\r\npsmouse_dbg(psmouse,\r\n"unexpected magic knock result 0x%02x, 0x%02x, 0x%02x.\n",\r\nparam[0], param[1], param[2]);\r\nreturn -1;\r\n}\r\nif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\r\npsmouse_dbg(psmouse, "failed to query firmware version.\n");\r\nreturn -1;\r\n}\r\npsmouse_dbg(psmouse,\r\n"Elantech version query result 0x%02x, 0x%02x, 0x%02x.\n",\r\nparam[0], param[1], param[2]);\r\nif (!elantech_is_signature_valid(param)) {\r\npsmouse_dbg(psmouse,\r\n"Probably not a real Elantech touchpad. Aborting.\n");\r\nreturn -1;\r\n}\r\nif (set_properties) {\r\npsmouse->vendor = "Elantech";\r\npsmouse->name = "Touchpad";\r\n}\r\nreturn 0;\r\n}\r\nstatic void elantech_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nif (etd->tp_dev)\r\ninput_unregister_device(etd->tp_dev);\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&elantech_attr_group);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\nstatic int elantech_reconnect(struct psmouse *psmouse)\r\n{\r\npsmouse_reset(psmouse);\r\nif (elantech_detect(psmouse, 0))\r\nreturn -1;\r\nif (elantech_set_absolute_mode(psmouse)) {\r\npsmouse_err(psmouse,\r\n"failed to put touchpad back into absolute mode.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elantech_set_properties(struct elantech_data *etd)\r\n{\r\nint ver = (etd->fw_version & 0x0f0000) >> 16;\r\nif (etd->fw_version < 0x020030 || etd->fw_version == 0x020600)\r\netd->hw_version = 1;\r\nelse {\r\nswitch (ver) {\r\ncase 2:\r\ncase 4:\r\netd->hw_version = 2;\r\nbreak;\r\ncase 5:\r\netd->hw_version = 3;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\ncase 9:\r\ncase 10:\r\ncase 13:\r\ncase 14:\r\netd->hw_version = 4;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\netd->send_cmd = etd->hw_version >= 3 ? elantech_send_cmd :\r\nsynaptics_send_cmd;\r\netd->paritycheck = 1;\r\netd->jumpy_cursor =\r\n(etd->fw_version == 0x020022 || etd->fw_version == 0x020600);\r\nif (etd->hw_version > 1) {\r\netd->debug = 1;\r\nif (etd->fw_version >= 0x020800)\r\netd->reports_pressure = true;\r\n}\r\netd->crc_enabled = (etd->fw_version & 0x4000) == 0x4000 ||\r\ndmi_check_system(elantech_dmi_force_crc_enabled);\r\netd->set_hw_resolution = !dmi_check_system(no_hw_res_dmi_table);\r\nreturn 0;\r\n}\r\nint elantech_init(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd;\r\nint i;\r\nint error = -EINVAL;\r\nunsigned char param[3];\r\nstruct input_dev *tp_dev;\r\npsmouse->private = etd = kzalloc(sizeof(struct elantech_data), GFP_KERNEL);\r\nif (!etd)\r\nreturn -ENOMEM;\r\npsmouse_reset(psmouse);\r\netd->parity[0] = 1;\r\nfor (i = 1; i < 256; i++)\r\netd->parity[i] = etd->parity[i & (i - 1)] ^ 1;\r\nif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\r\npsmouse_err(psmouse, "failed to query firmware version.\n");\r\ngoto init_fail;\r\n}\r\netd->fw_version = (param[0] << 16) | (param[1] << 8) | param[2];\r\nif (elantech_set_properties(etd)) {\r\npsmouse_err(psmouse, "unknown hardware version, aborting...\n");\r\ngoto init_fail;\r\n}\r\npsmouse_info(psmouse,\r\n"assuming hardware version %d (with firmware version 0x%02x%02x%02x)\n",\r\netd->hw_version, param[0], param[1], param[2]);\r\nif (etd->send_cmd(psmouse, ETP_CAPABILITIES_QUERY,\r\netd->capabilities)) {\r\npsmouse_err(psmouse, "failed to query capabilities.\n");\r\ngoto init_fail;\r\n}\r\npsmouse_info(psmouse,\r\n"Synaptics capabilities query result 0x%02x, 0x%02x, 0x%02x.\n",\r\netd->capabilities[0], etd->capabilities[1],\r\netd->capabilities[2]);\r\nif (etd->hw_version != 1) {\r\nif (etd->send_cmd(psmouse, ETP_SAMPLE_QUERY, etd->samples)) {\r\npsmouse_err(psmouse, "failed to query sample data\n");\r\ngoto init_fail;\r\n}\r\npsmouse_info(psmouse,\r\n"Elan sample query result %02x, %02x, %02x\n",\r\netd->samples[0], etd->samples[1], etd->samples[2]);\r\n}\r\nif (elantech_set_absolute_mode(psmouse)) {\r\npsmouse_err(psmouse,\r\n"failed to put touchpad into absolute mode.\n");\r\ngoto init_fail;\r\n}\r\nif (etd->fw_version == 0x381f17) {\r\netd->original_set_rate = psmouse->set_rate;\r\npsmouse->set_rate = elantech_set_rate_restore_reg_07;\r\n}\r\nif (elantech_set_input_params(psmouse)) {\r\npsmouse_err(psmouse, "failed to query touchpad range.\n");\r\ngoto init_fail;\r\n}\r\nerror = sysfs_create_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&elantech_attr_group);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"failed to create sysfs attributes, error: %d.\n",\r\nerror);\r\ngoto init_fail;\r\n}\r\nif ((etd->capabilities[0] & 0x80) == 0x80) {\r\ntp_dev = input_allocate_device();\r\nif (!tp_dev) {\r\nerror = -ENOMEM;\r\ngoto init_fail_tp_alloc;\r\n}\r\netd->tp_dev = tp_dev;\r\nsnprintf(etd->tp_phys, sizeof(etd->tp_phys), "%s/input1",\r\npsmouse->ps2dev.serio->phys);\r\ntp_dev->phys = etd->tp_phys;\r\ntp_dev->name = "Elantech PS/2 TrackPoint";\r\ntp_dev->id.bustype = BUS_I8042;\r\ntp_dev->id.vendor = 0x0002;\r\ntp_dev->id.product = PSMOUSE_ELANTECH;\r\ntp_dev->id.version = 0x0000;\r\ntp_dev->dev.parent = &psmouse->ps2dev.serio->dev;\r\ntp_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ntp_dev->relbit[BIT_WORD(REL_X)] =\r\nBIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ntp_dev->keybit[BIT_WORD(BTN_LEFT)] =\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) |\r\nBIT_MASK(BTN_RIGHT);\r\n__set_bit(INPUT_PROP_POINTER, tp_dev->propbit);\r\n__set_bit(INPUT_PROP_POINTING_STICK, tp_dev->propbit);\r\nerror = input_register_device(etd->tp_dev);\r\nif (error < 0)\r\ngoto init_fail_tp_reg;\r\n}\r\npsmouse->protocol_handler = elantech_process_byte;\r\npsmouse->disconnect = elantech_disconnect;\r\npsmouse->reconnect = elantech_reconnect;\r\npsmouse->pktsize = etd->hw_version > 1 ? 6 : 4;\r\nreturn 0;\r\ninit_fail_tp_reg:\r\ninput_free_device(tp_dev);\r\ninit_fail_tp_alloc:\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&elantech_attr_group);\r\ninit_fail:\r\npsmouse_reset(psmouse);\r\nkfree(etd);\r\nreturn error;\r\n}
