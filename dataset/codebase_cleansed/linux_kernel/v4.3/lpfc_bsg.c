static void\r\nlpfc_free_bsg_buffers(struct lpfc_hba *phba, struct lpfc_dmabuf *mlist)\r\n{\r\nstruct lpfc_dmabuf *mlast, *next_mlast;\r\nif (mlist) {\r\nlist_for_each_entry_safe(mlast, next_mlast, &mlist->list,\r\nlist) {\r\nlpfc_mbuf_free(phba, mlast->virt, mlast->phys);\r\nlist_del(&mlast->list);\r\nkfree(mlast);\r\n}\r\nlpfc_mbuf_free(phba, mlist->virt, mlist->phys);\r\nkfree(mlist);\r\n}\r\nreturn;\r\n}\r\nstatic struct lpfc_dmabuf *\r\nlpfc_alloc_bsg_buffers(struct lpfc_hba *phba, unsigned int size,\r\nint outbound_buffers, struct ulp_bde64 *bpl,\r\nint *bpl_entries)\r\n{\r\nstruct lpfc_dmabuf *mlist = NULL;\r\nstruct lpfc_dmabuf *mp;\r\nunsigned int bytes_left = size;\r\nif (!size || (size > (*bpl_entries * LPFC_BPL_SIZE)))\r\nreturn NULL;\r\n*bpl_entries = (size % LPFC_BPL_SIZE ? size/LPFC_BPL_SIZE + 1 :\r\nsize/LPFC_BPL_SIZE);\r\nwhile (bytes_left) {\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nif (mlist)\r\nlpfc_free_bsg_buffers(phba, mlist);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\r\nif (!mp->virt) {\r\nkfree(mp);\r\nif (mlist)\r\nlpfc_free_bsg_buffers(phba, mlist);\r\nreturn NULL;\r\n}\r\nif (!mlist)\r\nmlist = mp;\r\nelse\r\nlist_add_tail(&mp->list, &mlist->list);\r\nif (outbound_buffers)\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nelse\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys));\r\nbpl->tus.f.bdeSize = (uint16_t)\r\n(bytes_left >= LPFC_BPL_SIZE ? LPFC_BPL_SIZE :\r\nbytes_left);\r\nbytes_left -= bpl->tus.f.bdeSize;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl++;\r\n}\r\nreturn mlist;\r\n}\r\nstatic unsigned int\r\nlpfc_bsg_copy_data(struct lpfc_dmabuf *dma_buffers,\r\nstruct fc_bsg_buffer *bsg_buffers,\r\nunsigned int bytes_to_transfer, int to_buffers)\r\n{\r\nstruct lpfc_dmabuf *mp;\r\nunsigned int transfer_bytes, bytes_copied = 0;\r\nunsigned int sg_offset, dma_offset;\r\nunsigned char *dma_address, *sg_address;\r\nLIST_HEAD(temp_list);\r\nstruct sg_mapping_iter miter;\r\nunsigned long flags;\r\nunsigned int sg_flags = SG_MITER_ATOMIC;\r\nbool sg_valid;\r\nlist_splice_init(&dma_buffers->list, &temp_list);\r\nlist_add(&dma_buffers->list, &temp_list);\r\nsg_offset = 0;\r\nif (to_buffers)\r\nsg_flags |= SG_MITER_FROM_SG;\r\nelse\r\nsg_flags |= SG_MITER_TO_SG;\r\nsg_miter_start(&miter, bsg_buffers->sg_list, bsg_buffers->sg_cnt,\r\nsg_flags);\r\nlocal_irq_save(flags);\r\nsg_valid = sg_miter_next(&miter);\r\nlist_for_each_entry(mp, &temp_list, list) {\r\ndma_offset = 0;\r\nwhile (bytes_to_transfer && sg_valid &&\r\n(dma_offset < LPFC_BPL_SIZE)) {\r\ndma_address = mp->virt + dma_offset;\r\nif (sg_offset) {\r\nsg_address = miter.addr + sg_offset;\r\ntransfer_bytes = miter.length - sg_offset;\r\n} else {\r\nsg_address = miter.addr;\r\ntransfer_bytes = miter.length;\r\n}\r\nif (bytes_to_transfer < transfer_bytes)\r\ntransfer_bytes = bytes_to_transfer;\r\nif (transfer_bytes > (LPFC_BPL_SIZE - dma_offset))\r\ntransfer_bytes = LPFC_BPL_SIZE - dma_offset;\r\nif (to_buffers)\r\nmemcpy(dma_address, sg_address, transfer_bytes);\r\nelse\r\nmemcpy(sg_address, dma_address, transfer_bytes);\r\ndma_offset += transfer_bytes;\r\nsg_offset += transfer_bytes;\r\nbytes_to_transfer -= transfer_bytes;\r\nbytes_copied += transfer_bytes;\r\nif (sg_offset >= miter.length) {\r\nsg_offset = 0;\r\nsg_valid = sg_miter_next(&miter);\r\n}\r\n}\r\n}\r\nsg_miter_stop(&miter);\r\nlocal_irq_restore(flags);\r\nlist_del_init(&dma_buffers->list);\r\nlist_splice(&temp_list, &dma_buffers->list);\r\nreturn bytes_copied;\r\n}\r\nstatic void\r\nlpfc_bsg_send_mgmt_cmd_cmp(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbq,\r\nstruct lpfc_iocbq *rspiocbq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nIOCB_t *rsp;\r\nstruct lpfc_dmabuf *bmp, *cmp, *rmp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_bsg_iocb *iocb;\r\nunsigned long flags;\r\nunsigned int rsp_size;\r\nint rc = 0;\r\ndd_data = cmdiocbq->context1;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\ncmdiocbq->iocb_flag &= ~LPFC_IO_CMD_OUTSTANDING;\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\niocb = &dd_data->context_un.iocb;\r\nndlp = iocb->ndlp;\r\nrmp = iocb->rmp;\r\ncmp = cmdiocbq->context2;\r\nbmp = cmdiocbq->context3;\r\nrsp = &rspiocbq->iocb;\r\nif (job) {\r\nif (rsp->ulpStatus) {\r\nif (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch (rsp->un.ulpWord[4] & IOERR_PARAM_MASK) {\r\ncase IOERR_SEQUENCE_TIMEOUT:\r\nrc = -ETIMEDOUT;\r\nbreak;\r\ncase IOERR_INVALID_RPI:\r\nrc = -EFAULT;\r\nbreak;\r\ndefault:\r\nrc = -EACCES;\r\nbreak;\r\n}\r\n} else {\r\nrc = -EACCES;\r\n}\r\n} else {\r\nrsp_size = rsp->un.genreq64.bdl.bdeSize;\r\njob->reply->reply_payload_rcv_len =\r\nlpfc_bsg_copy_data(rmp, &job->reply_payload,\r\nrsp_size, 0);\r\n}\r\n}\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nlpfc_free_bsg_buffers(phba, rmp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nlpfc_nlp_put(ndlp);\r\nkfree(dd_data);\r\nif (job) {\r\njob->reply->result = rc;\r\njob->job_done(job);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_bsg_send_mgmt_cmd(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_rport_data *rdata = job->rport->dd_data;\r\nstruct lpfc_nodelist *ndlp = rdata->pnode;\r\nstruct ulp_bde64 *bpl = NULL;\r\nuint32_t timeout;\r\nstruct lpfc_iocbq *cmdiocbq = NULL;\r\nIOCB_t *cmd;\r\nstruct lpfc_dmabuf *bmp = NULL, *cmp = NULL, *rmp = NULL;\r\nint request_nseg;\r\nint reply_nseg;\r\nstruct bsg_job_data *dd_data;\r\nunsigned long flags;\r\nuint32_t creg_val;\r\nint rc = 0;\r\nint iocb_stat;\r\njob->reply->reply_payload_rcv_len = 0;\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2733 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto no_dd_data;\r\n}\r\nif (!lpfc_nlp_get(ndlp)) {\r\nrc = -ENODEV;\r\ngoto no_ndlp;\r\n}\r\nif (ndlp->nlp_flag & NLP_ELS_SND_MASK) {\r\nrc = -ENODEV;\r\ngoto free_ndlp;\r\n}\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nif (!cmdiocbq) {\r\nrc = -ENOMEM;\r\ngoto free_ndlp;\r\n}\r\ncmd = &cmdiocbq->iocb;\r\nbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp) {\r\nrc = -ENOMEM;\r\ngoto free_cmdiocbq;\r\n}\r\nbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\r\nif (!bmp->virt) {\r\nrc = -ENOMEM;\r\ngoto free_bmp;\r\n}\r\nINIT_LIST_HEAD(&bmp->list);\r\nbpl = (struct ulp_bde64 *) bmp->virt;\r\nrequest_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64);\r\ncmp = lpfc_alloc_bsg_buffers(phba, job->request_payload.payload_len,\r\n1, bpl, &request_nseg);\r\nif (!cmp) {\r\nrc = -ENOMEM;\r\ngoto free_bmp;\r\n}\r\nlpfc_bsg_copy_data(cmp, &job->request_payload,\r\njob->request_payload.payload_len, 1);\r\nbpl += request_nseg;\r\nreply_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64) - request_nseg;\r\nrmp = lpfc_alloc_bsg_buffers(phba, job->reply_payload.payload_len, 0,\r\nbpl, &reply_nseg);\r\nif (!rmp) {\r\nrc = -ENOMEM;\r\ngoto free_cmp;\r\n}\r\ncmd->un.genreq64.bdl.ulpIoTag32 = 0;\r\ncmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);\r\ncmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);\r\ncmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\ncmd->un.genreq64.bdl.bdeSize =\r\n(request_nseg + reply_nseg) * sizeof(struct ulp_bde64);\r\ncmd->ulpCommand = CMD_GEN_REQUEST64_CR;\r\ncmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);\r\ncmd->un.genreq64.w5.hcsw.Dfctl = 0;\r\ncmd->un.genreq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;\r\ncmd->un.genreq64.w5.hcsw.Type = FC_TYPE_CT;\r\ncmd->ulpBdeCount = 1;\r\ncmd->ulpLe = 1;\r\ncmd->ulpClass = CLASS3;\r\ncmd->ulpContext = ndlp->nlp_rpi;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\ncmd->ulpContext = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\r\ncmd->ulpOwner = OWN_CHIP;\r\ncmdiocbq->vport = phba->pport;\r\ncmdiocbq->context3 = bmp;\r\ncmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\r\ntimeout = phba->fc_ratov * 2;\r\ncmd->ulpTimeout = timeout;\r\ncmdiocbq->iocb_cmpl = lpfc_bsg_send_mgmt_cmd_cmp;\r\ncmdiocbq->context1 = dd_data;\r\ncmdiocbq->context2 = cmp;\r\ncmdiocbq->context3 = bmp;\r\ncmdiocbq->context_un.ndlp = ndlp;\r\ndd_data->type = TYPE_IOCB;\r\ndd_data->set_job = job;\r\ndd_data->context_un.iocb.cmdiocbq = cmdiocbq;\r\ndd_data->context_un.iocb.ndlp = ndlp;\r\ndd_data->context_un.iocb.rmp = rmp;\r\njob->dd_data = dd_data;\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\r\nif (lpfc_readl(phba->HCregaddr, &creg_val)) {\r\nrc = -EIO ;\r\ngoto free_rmp;\r\n}\r\ncreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\r\nwritel(creg_val, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\n}\r\niocb_stat = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);\r\nif (iocb_stat == IOCB_SUCCESS) {\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (cmdiocbq->iocb_flag & LPFC_IO_LIBDFC) {\r\ncmdiocbq->iocb_flag |= LPFC_IO_CMD_OUTSTANDING;\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn 0;\r\n} else if (iocb_stat == IOCB_BUSY) {\r\nrc = -EAGAIN;\r\n} else {\r\nrc = -EIO;\r\n}\r\njob->dd_data = NULL;\r\nfree_rmp:\r\nlpfc_free_bsg_buffers(phba, rmp);\r\nfree_cmp:\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nfree_bmp:\r\nif (bmp->virt)\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nfree_cmdiocbq:\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nfree_ndlp:\r\nlpfc_nlp_put(ndlp);\r\nno_ndlp:\r\nkfree(dd_data);\r\nno_dd_data:\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_bsg_rport_els_cmp(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbq,\r\nstruct lpfc_iocbq *rspiocbq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nIOCB_t *rsp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_dmabuf *pcmd = NULL, *prsp = NULL;\r\nstruct fc_bsg_ctels_reply *els_reply;\r\nuint8_t *rjt_data;\r\nunsigned long flags;\r\nunsigned int rsp_size;\r\nint rc = 0;\r\ndd_data = cmdiocbq->context1;\r\nndlp = dd_data->context_un.iocb.ndlp;\r\ncmdiocbq->context1 = ndlp;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\ncmdiocbq->iocb_flag &= ~LPFC_IO_CMD_OUTSTANDING;\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nrsp = &rspiocbq->iocb;\r\npcmd = (struct lpfc_dmabuf *)cmdiocbq->context2;\r\nprsp = (struct lpfc_dmabuf *)pcmd->list.next;\r\nif (job) {\r\nif (rsp->ulpStatus == IOSTAT_SUCCESS) {\r\nrsp_size = rsp->un.elsreq64.bdl.bdeSize;\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\nprsp->virt,\r\nrsp_size);\r\n} else if (rsp->ulpStatus == IOSTAT_LS_RJT) {\r\njob->reply->reply_payload_rcv_len =\r\nsizeof(struct fc_bsg_ctels_reply);\r\nrjt_data = (uint8_t *)&rsp->un.ulpWord[4];\r\nels_reply = &job->reply->reply_data.ctels_reply;\r\nels_reply->status = FC_CTELS_STATUS_REJECT;\r\nels_reply->rjt_data.action = rjt_data[3];\r\nels_reply->rjt_data.reason_code = rjt_data[2];\r\nels_reply->rjt_data.reason_explanation = rjt_data[1];\r\nels_reply->rjt_data.vendor_unique = rjt_data[0];\r\n} else {\r\nrc = -EIO;\r\n}\r\n}\r\nlpfc_nlp_put(ndlp);\r\nlpfc_els_free_iocb(phba, cmdiocbq);\r\nkfree(dd_data);\r\nif (job) {\r\njob->reply->result = rc;\r\njob->job_done(job);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_bsg_rport_els(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_rport_data *rdata = job->rport->dd_data;\r\nstruct lpfc_nodelist *ndlp = rdata->pnode;\r\nuint32_t elscmd;\r\nuint32_t cmdsize;\r\nstruct lpfc_iocbq *cmdiocbq;\r\nuint16_t rpi = 0;\r\nstruct bsg_job_data *dd_data;\r\nunsigned long flags;\r\nuint32_t creg_val;\r\nint rc = 0;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_payload.payload_len > FCELSSIZE) {\r\nrc = -EINVAL;\r\ngoto no_dd_data;\r\n}\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2735 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto no_dd_data;\r\n}\r\nelscmd = job->request->rqst_data.r_els.els_code;\r\ncmdsize = job->request_payload.payload_len;\r\nif (!lpfc_nlp_get(ndlp)) {\r\nrc = -ENODEV;\r\ngoto free_dd_data;\r\n}\r\ncmdiocbq = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp,\r\nndlp->nlp_DID, elscmd);\r\nif (!cmdiocbq) {\r\nrc = -EIO;\r\ngoto release_ndlp;\r\n}\r\nrpi = ndlp->nlp_rpi;\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\n((struct lpfc_dmabuf *)cmdiocbq->context2)->virt,\r\ncmdsize);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\ncmdiocbq->iocb.ulpContext = phba->sli4_hba.rpi_ids[rpi];\r\nelse\r\ncmdiocbq->iocb.ulpContext = rpi;\r\ncmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\r\ncmdiocbq->context1 = dd_data;\r\ncmdiocbq->context_un.ndlp = ndlp;\r\ncmdiocbq->iocb_cmpl = lpfc_bsg_rport_els_cmp;\r\ndd_data->type = TYPE_IOCB;\r\ndd_data->set_job = job;\r\ndd_data->context_un.iocb.cmdiocbq = cmdiocbq;\r\ndd_data->context_un.iocb.ndlp = ndlp;\r\ndd_data->context_un.iocb.rmp = NULL;\r\njob->dd_data = dd_data;\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\r\nif (lpfc_readl(phba->HCregaddr, &creg_val)) {\r\nrc = -EIO;\r\ngoto linkdown_err;\r\n}\r\ncreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\r\nwritel(creg_val, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\n}\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);\r\nif (rc == IOCB_SUCCESS) {\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (cmdiocbq->iocb_flag & LPFC_IO_LIBDFC) {\r\ncmdiocbq->iocb_flag |= LPFC_IO_CMD_OUTSTANDING;\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn 0;\r\n} else if (rc == IOCB_BUSY) {\r\nrc = -EAGAIN;\r\n} else {\r\nrc = -EIO;\r\n}\r\njob->dd_data = NULL;\r\nlinkdown_err:\r\ncmdiocbq->context1 = ndlp;\r\nlpfc_els_free_iocb(phba, cmdiocbq);\r\nrelease_ndlp:\r\nlpfc_nlp_put(ndlp);\r\nfree_dd_data:\r\nkfree(dd_data);\r\nno_dd_data:\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_bsg_event_free(struct kref *kref)\r\n{\r\nstruct lpfc_bsg_event *evt = container_of(kref, struct lpfc_bsg_event,\r\nkref);\r\nstruct event_data *ed;\r\nlist_del(&evt->node);\r\nwhile (!list_empty(&evt->events_to_get)) {\r\ned = list_entry(evt->events_to_get.next, typeof(*ed), node);\r\nlist_del(&ed->node);\r\nkfree(ed->data);\r\nkfree(ed);\r\n}\r\nwhile (!list_empty(&evt->events_to_see)) {\r\ned = list_entry(evt->events_to_see.next, typeof(*ed), node);\r\nlist_del(&ed->node);\r\nkfree(ed->data);\r\nkfree(ed);\r\n}\r\nkfree(evt->dd_data);\r\nkfree(evt);\r\n}\r\nstatic inline void\r\nlpfc_bsg_event_ref(struct lpfc_bsg_event *evt)\r\n{\r\nkref_get(&evt->kref);\r\n}\r\nstatic inline void\r\nlpfc_bsg_event_unref(struct lpfc_bsg_event *evt)\r\n{\r\nkref_put(&evt->kref, lpfc_bsg_event_free);\r\n}\r\nstatic struct lpfc_bsg_event *\r\nlpfc_bsg_event_new(uint32_t ev_mask, int ev_reg_id, uint32_t ev_req_id)\r\n{\r\nstruct lpfc_bsg_event *evt = kzalloc(sizeof(*evt), GFP_KERNEL);\r\nif (!evt)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&evt->events_to_get);\r\nINIT_LIST_HEAD(&evt->events_to_see);\r\nevt->type_mask = ev_mask;\r\nevt->req_id = ev_req_id;\r\nevt->reg_id = ev_reg_id;\r\nevt->wait_time_stamp = jiffies;\r\nevt->dd_data = NULL;\r\ninit_waitqueue_head(&evt->wq);\r\nkref_init(&evt->kref);\r\nreturn evt;\r\n}\r\nstatic int\r\ndiag_cmd_data_free(struct lpfc_hba *phba, struct lpfc_dmabufext *mlist)\r\n{\r\nstruct lpfc_dmabufext *mlast;\r\nstruct pci_dev *pcidev;\r\nstruct list_head head, *curr, *next;\r\nif ((!mlist) || (!lpfc_is_link_up(phba) &&\r\n(phba->link_flag & LS_LOOPBACK_MODE))) {\r\nreturn 0;\r\n}\r\npcidev = phba->pcidev;\r\nlist_add_tail(&head, &mlist->dma.list);\r\nlist_for_each_safe(curr, next, &head) {\r\nmlast = list_entry(curr, struct lpfc_dmabufext , dma.list);\r\nif (mlast->dma.virt)\r\ndma_free_coherent(&pcidev->dev,\r\nmlast->size,\r\nmlast->dma.virt,\r\nmlast->dma.phys);\r\nkfree(mlast);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_bsg_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\r\nstruct lpfc_iocbq *piocbq)\r\n{\r\nuint32_t evt_req_id = 0;\r\nuint32_t cmd;\r\nuint32_t len;\r\nstruct lpfc_dmabuf *dmabuf = NULL;\r\nstruct lpfc_bsg_event *evt;\r\nstruct event_data *evt_dat = NULL;\r\nstruct lpfc_iocbq *iocbq;\r\nsize_t offset = 0;\r\nstruct list_head head;\r\nstruct ulp_bde64 *bde;\r\ndma_addr_t dma_addr;\r\nint i;\r\nstruct lpfc_dmabuf *bdeBuf1 = piocbq->context2;\r\nstruct lpfc_dmabuf *bdeBuf2 = piocbq->context3;\r\nstruct lpfc_hbq_entry *hbqe;\r\nstruct lpfc_sli_ct_request *ct_req;\r\nstruct fc_bsg_job *job = NULL;\r\nstruct bsg_job_data *dd_data = NULL;\r\nunsigned long flags;\r\nint size = 0;\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &piocbq->list);\r\nif (piocbq->iocb.ulpBdeCount == 0 ||\r\npiocbq->iocb.un.cont64[0].tus.f.bdeSize == 0)\r\ngoto error_ct_unsol_exit;\r\nif (phba->link_state == LPFC_HBA_ERROR ||\r\n(!(phba->sli.sli_flag & LPFC_SLI_ACTIVE)))\r\ngoto error_ct_unsol_exit;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED)\r\ndmabuf = bdeBuf1;\r\nelse {\r\ndma_addr = getPaddr(piocbq->iocb.un.cont64[0].addrHigh,\r\npiocbq->iocb.un.cont64[0].addrLow);\r\ndmabuf = lpfc_sli_ringpostbuf_get(phba, pring, dma_addr);\r\n}\r\nif (dmabuf == NULL)\r\ngoto error_ct_unsol_exit;\r\nct_req = (struct lpfc_sli_ct_request *)dmabuf->virt;\r\nevt_req_id = ct_req->FsType;\r\ncmd = ct_req->CommandResponse.bits.CmdRsp;\r\nlen = ct_req->CommandResponse.bits.Size;\r\nif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\r\nlpfc_sli_ringpostbuf_put(phba, pring, dmabuf);\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_for_each_entry(evt, &phba->ct_ev_waiters, node) {\r\nif (!(evt->type_mask & FC_REG_CT_EVENT) ||\r\nevt->req_id != evt_req_id)\r\ncontinue;\r\nlpfc_bsg_event_ref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nevt_dat = kzalloc(sizeof(*evt_dat), GFP_KERNEL);\r\nif (evt_dat == NULL) {\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlpfc_bsg_event_unref(evt);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2614 Memory allocation failed for "\r\n"CT event\n");\r\nbreak;\r\n}\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\niocbq = list_entry(head.prev, typeof(*iocbq), list);\r\nevt_dat->len = iocbq->iocb.unsli3.rcvsli3.acc_len;\r\n} else {\r\nlist_for_each_entry(iocbq, &head, list) {\r\nfor (i = 0; i < iocbq->iocb.ulpBdeCount; i++)\r\nevt_dat->len +=\r\niocbq->iocb.un.cont64[i].tus.f.bdeSize;\r\n}\r\n}\r\nevt_dat->data = kzalloc(evt_dat->len, GFP_KERNEL);\r\nif (evt_dat->data == NULL) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2615 Memory allocation failed for "\r\n"CT event data, size %d\n",\r\nevt_dat->len);\r\nkfree(evt_dat);\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlpfc_bsg_event_unref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\ngoto error_ct_unsol_exit;\r\n}\r\nlist_for_each_entry(iocbq, &head, list) {\r\nsize = 0;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\nbdeBuf1 = iocbq->context2;\r\nbdeBuf2 = iocbq->context3;\r\n}\r\nfor (i = 0; i < iocbq->iocb.ulpBdeCount; i++) {\r\nif (phba->sli3_options &\r\nLPFC_SLI3_HBQ_ENABLED) {\r\nif (i == 0) {\r\nhbqe = (struct lpfc_hbq_entry *)\r\n&iocbq->iocb.un.ulpWord[0];\r\nsize = hbqe->bde.tus.f.bdeSize;\r\ndmabuf = bdeBuf1;\r\n} else if (i == 1) {\r\nhbqe = (struct lpfc_hbq_entry *)\r\n&iocbq->iocb.unsli3.\r\nsli3Words[4];\r\nsize = hbqe->bde.tus.f.bdeSize;\r\ndmabuf = bdeBuf2;\r\n}\r\nif ((offset + size) > evt_dat->len)\r\nsize = evt_dat->len - offset;\r\n} else {\r\nsize = iocbq->iocb.un.cont64[i].\r\ntus.f.bdeSize;\r\nbde = &iocbq->iocb.un.cont64[i];\r\ndma_addr = getPaddr(bde->addrHigh,\r\nbde->addrLow);\r\ndmabuf = lpfc_sli_ringpostbuf_get(phba,\r\npring, dma_addr);\r\n}\r\nif (!dmabuf) {\r\nlpfc_printf_log(phba, KERN_ERR,\r\nLOG_LIBDFC, "2616 No dmabuf "\r\n"found for iocbq 0x%p\n",\r\niocbq);\r\nkfree(evt_dat->data);\r\nkfree(evt_dat);\r\nspin_lock_irqsave(&phba->ct_ev_lock,\r\nflags);\r\nlpfc_bsg_event_unref(evt);\r\nspin_unlock_irqrestore(\r\n&phba->ct_ev_lock, flags);\r\ngoto error_ct_unsol_exit;\r\n}\r\nmemcpy((char *)(evt_dat->data) + offset,\r\ndmabuf->virt, size);\r\noffset += size;\r\nif (evt_req_id != SLI_CT_ELX_LOOPBACK &&\r\n!(phba->sli3_options &\r\nLPFC_SLI3_HBQ_ENABLED)) {\r\nlpfc_sli_ringpostbuf_put(phba, pring,\r\ndmabuf);\r\n} else {\r\nswitch (cmd) {\r\ncase ELX_LOOPBACK_DATA:\r\nif (phba->sli_rev <\r\nLPFC_SLI_REV4)\r\ndiag_cmd_data_free(phba,\r\n(struct lpfc_dmabufext\r\n*)dmabuf);\r\nbreak;\r\ncase ELX_LOOPBACK_XRI_SETUP:\r\nif ((phba->sli_rev ==\r\nLPFC_SLI_REV2) ||\r\n(phba->sli3_options &\r\nLPFC_SLI3_HBQ_ENABLED\r\n)) {\r\nlpfc_in_buf_free(phba,\r\ndmabuf);\r\n} else {\r\nlpfc_post_buffer(phba,\r\npring,\r\n1);\r\n}\r\nbreak;\r\ndefault:\r\nif (!(phba->sli3_options &\r\nLPFC_SLI3_HBQ_ENABLED))\r\nlpfc_post_buffer(phba,\r\npring,\r\n1);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nevt_dat->immed_dat = phba->ctx_idx;\r\nphba->ctx_idx = (phba->ctx_idx + 1) % LPFC_CT_CTX_MAX;\r\nif (phba->ct_ctx[evt_dat->immed_dat].valid ==\r\nUNSOL_VALID)\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_ELS,\r\n"2717 CT context array entry "\r\n"[%d] over-run: oxid:x%x, "\r\n"sid:x%x\n", phba->ctx_idx,\r\nphba->ct_ctx[\r\nevt_dat->immed_dat].oxid,\r\nphba->ct_ctx[\r\nevt_dat->immed_dat].SID);\r\nphba->ct_ctx[evt_dat->immed_dat].rxid =\r\npiocbq->iocb.ulpContext;\r\nphba->ct_ctx[evt_dat->immed_dat].oxid =\r\npiocbq->iocb.unsli3.rcvsli3.ox_id;\r\nphba->ct_ctx[evt_dat->immed_dat].SID =\r\npiocbq->iocb.un.rcvels.remoteID;\r\nphba->ct_ctx[evt_dat->immed_dat].valid = UNSOL_VALID;\r\n} else\r\nevt_dat->immed_dat = piocbq->iocb.ulpContext;\r\nevt_dat->type = FC_REG_CT_EVENT;\r\nlist_add(&evt_dat->node, &evt->events_to_see);\r\nif (evt_req_id == SLI_CT_ELX_LOOPBACK) {\r\nwake_up_interruptible(&evt->wq);\r\nlpfc_bsg_event_unref(evt);\r\nbreak;\r\n}\r\nlist_move(evt->events_to_see.prev, &evt->events_to_get);\r\ndd_data = (struct bsg_job_data *)evt->dd_data;\r\njob = dd_data->set_job;\r\ndd_data->set_job = NULL;\r\nlpfc_bsg_event_unref(evt);\r\nif (job) {\r\njob->reply->reply_payload_rcv_len = size;\r\njob->reply->result = 0;\r\njob->dd_data = NULL;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\njob->job_done(job);\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nerror_ct_unsol_exit:\r\nif (!list_empty(&head))\r\nlist_del(&head);\r\nif ((phba->sli_rev < LPFC_SLI_REV4) &&\r\n(evt_req_id == SLI_CT_ELX_LOOPBACK))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\nlpfc_bsg_ct_unsol_abort(struct lpfc_hba *phba, struct hbq_dmabuf *dmabuf)\r\n{\r\nstruct fc_frame_header fc_hdr;\r\nstruct fc_frame_header *fc_hdr_ptr = &fc_hdr;\r\nint ctx_idx, handled = 0;\r\nuint16_t oxid, rxid;\r\nuint32_t sid;\r\nmemcpy(fc_hdr_ptr, dmabuf->hbuf.virt, sizeof(struct fc_frame_header));\r\nsid = sli4_sid_from_fc_hdr(fc_hdr_ptr);\r\noxid = be16_to_cpu(fc_hdr_ptr->fh_ox_id);\r\nrxid = be16_to_cpu(fc_hdr_ptr->fh_rx_id);\r\nfor (ctx_idx = 0; ctx_idx < LPFC_CT_CTX_MAX; ctx_idx++) {\r\nif (phba->ct_ctx[ctx_idx].valid != UNSOL_VALID)\r\ncontinue;\r\nif (phba->ct_ctx[ctx_idx].rxid != rxid)\r\ncontinue;\r\nif (phba->ct_ctx[ctx_idx].oxid != oxid)\r\ncontinue;\r\nif (phba->ct_ctx[ctx_idx].SID != sid)\r\ncontinue;\r\nphba->ct_ctx[ctx_idx].valid = UNSOL_INVALID;\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic int\r\nlpfc_bsg_hba_set_event(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct set_ct_event *event_req;\r\nstruct lpfc_bsg_event *evt;\r\nint rc = 0;\r\nstruct bsg_job_data *dd_data = NULL;\r\nuint32_t ev_mask;\r\nunsigned long flags;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct set_ct_event)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2612 Received SET_CT_EVENT below minimum "\r\n"size\n");\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nevent_req = (struct set_ct_event *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nev_mask = ((uint32_t)(unsigned long)event_req->type_mask &\r\nFC_REG_EVENT_MASK);\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_for_each_entry(evt, &phba->ct_ev_waiters, node) {\r\nif (evt->reg_id == event_req->ev_reg_id) {\r\nlpfc_bsg_event_ref(evt);\r\nevt->wait_time_stamp = jiffies;\r\ndd_data = (struct bsg_job_data *)evt->dd_data;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif (&evt->node == &phba->ct_ev_waiters) {\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (dd_data == NULL) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2734 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\nevt = lpfc_bsg_event_new(ev_mask, event_req->ev_reg_id,\r\nevent_req->ev_req_id);\r\nif (!evt) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2617 Failed allocation of event "\r\n"waiter\n");\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\ndd_data->type = TYPE_EVT;\r\ndd_data->set_job = NULL;\r\ndd_data->context_un.evt = evt;\r\nevt->dd_data = (void *)dd_data;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_add(&evt->node, &phba->ct_ev_waiters);\r\nlpfc_bsg_event_ref(evt);\r\nevt->wait_time_stamp = jiffies;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\n}\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nevt->waiting = 1;\r\ndd_data->set_job = job;\r\njob->dd_data = dd_data;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nreturn 0;\r\njob_error:\r\nif (dd_data != NULL)\r\nkfree(dd_data);\r\njob->dd_data = NULL;\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_hba_get_event(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct get_ct_event *event_req;\r\nstruct get_ct_event_reply *event_reply;\r\nstruct lpfc_bsg_event *evt, *evt_next;\r\nstruct event_data *evt_dat = NULL;\r\nunsigned long flags;\r\nuint32_t rc = 0;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct get_ct_event)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2613 Received GET_CT_EVENT request below "\r\n"minimum size\n");\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nevent_req = (struct get_ct_event *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nevent_reply = (struct get_ct_event_reply *)\r\njob->reply->reply_data.vendor_reply.vendor_rsp;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_for_each_entry_safe(evt, evt_next, &phba->ct_ev_waiters, node) {\r\nif (evt->reg_id == event_req->ev_reg_id) {\r\nif (list_empty(&evt->events_to_get))\r\nbreak;\r\nlpfc_bsg_event_ref(evt);\r\nevt->wait_time_stamp = jiffies;\r\nevt_dat = list_entry(evt->events_to_get.prev,\r\nstruct event_data, node);\r\nlist_del(&evt_dat->node);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif (evt_dat == NULL) {\r\njob->reply->reply_payload_rcv_len = 0;\r\nrc = -ENOENT;\r\ngoto job_error;\r\n}\r\nif (evt_dat->len > job->request_payload.payload_len) {\r\nevt_dat->len = job->request_payload.payload_len;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2618 Truncated event data at %d "\r\n"bytes\n",\r\njob->request_payload.payload_len);\r\n}\r\nevent_reply->type = evt_dat->type;\r\nevent_reply->immed_data = evt_dat->immed_dat;\r\nif (evt_dat->len > 0)\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nevt_dat->data, evt_dat->len);\r\nelse\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (evt_dat) {\r\nkfree(evt_dat->data);\r\nkfree(evt_dat);\r\n}\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlpfc_bsg_event_unref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\njob->dd_data = NULL;\r\njob->reply->result = 0;\r\njob->job_done(job);\r\nreturn 0;\r\njob_error:\r\njob->dd_data = NULL;\r\njob->reply->result = rc;\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_issue_ct_rsp_cmp(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbq,\r\nstruct lpfc_iocbq *rspiocbq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nIOCB_t *rsp;\r\nstruct lpfc_dmabuf *bmp, *cmp;\r\nstruct lpfc_nodelist *ndlp;\r\nunsigned long flags;\r\nint rc = 0;\r\ndd_data = cmdiocbq->context1;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\ncmdiocbq->iocb_flag &= ~LPFC_IO_CMD_OUTSTANDING;\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nndlp = dd_data->context_un.iocb.ndlp;\r\ncmp = cmdiocbq->context2;\r\nbmp = cmdiocbq->context3;\r\nrsp = &rspiocbq->iocb;\r\nif (job) {\r\nif (rsp->ulpStatus) {\r\nif (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch (rsp->un.ulpWord[4] & IOERR_PARAM_MASK) {\r\ncase IOERR_SEQUENCE_TIMEOUT:\r\nrc = -ETIMEDOUT;\r\nbreak;\r\ncase IOERR_INVALID_RPI:\r\nrc = -EFAULT;\r\nbreak;\r\ndefault:\r\nrc = -EACCES;\r\nbreak;\r\n}\r\n} else {\r\nrc = -EACCES;\r\n}\r\n} else {\r\njob->reply->reply_payload_rcv_len = 0;\r\n}\r\n}\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nlpfc_nlp_put(ndlp);\r\nkfree(dd_data);\r\nif (job) {\r\njob->reply->result = rc;\r\njob->job_done(job);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_issue_ct_rsp(struct lpfc_hba *phba, struct fc_bsg_job *job, uint32_t tag,\r\nstruct lpfc_dmabuf *cmp, struct lpfc_dmabuf *bmp,\r\nint num_entry)\r\n{\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *ctiocb = NULL;\r\nint rc = 0;\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nstruct bsg_job_data *dd_data;\r\nunsigned long flags;\r\nuint32_t creg_val;\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2736 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto no_dd_data;\r\n}\r\nctiocb = lpfc_sli_get_iocbq(phba);\r\nif (!ctiocb) {\r\nrc = -ENOMEM;\r\ngoto no_ctiocb;\r\n}\r\nicmd = &ctiocb->iocb;\r\nicmd->un.xseq64.bdl.ulpIoTag32 = 0;\r\nicmd->un.xseq64.bdl.addrHigh = putPaddrHigh(bmp->phys);\r\nicmd->un.xseq64.bdl.addrLow = putPaddrLow(bmp->phys);\r\nicmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\nicmd->un.xseq64.bdl.bdeSize = (num_entry * sizeof(struct ulp_bde64));\r\nicmd->un.xseq64.w5.hcsw.Fctl = (LS | LA);\r\nicmd->un.xseq64.w5.hcsw.Dfctl = 0;\r\nicmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_SOL_CTL;\r\nicmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;\r\nicmd->ulpCommand = CMD_XMIT_SEQUENCE64_CX;\r\nicmd->ulpBdeCount = 1;\r\nicmd->ulpLe = 1;\r\nicmd->ulpClass = CLASS3;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nif (phba->ct_ctx[tag].valid != UNSOL_VALID) {\r\nrc = IOCB_ERROR;\r\ngoto issue_ct_rsp_exit;\r\n}\r\nicmd->ulpContext = phba->ct_ctx[tag].rxid;\r\nicmd->unsli3.rcvsli3.ox_id = phba->ct_ctx[tag].oxid;\r\nndlp = lpfc_findnode_did(phba->pport, phba->ct_ctx[tag].SID);\r\nif (!ndlp) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_ELS,\r\n"2721 ndlp null for oxid %x SID %x\n",\r\nicmd->ulpContext,\r\nphba->ct_ctx[tag].SID);\r\nrc = IOCB_ERROR;\r\ngoto issue_ct_rsp_exit;\r\n}\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {\r\nrc = IOCB_ERROR;\r\ngoto issue_ct_rsp_exit;\r\n}\r\nif (!lpfc_nlp_get(ndlp)) {\r\nrc = IOCB_ERROR;\r\ngoto issue_ct_rsp_exit;\r\n}\r\nicmd->un.ulpWord[3] =\r\nphba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\r\nphba->ct_ctx[tag].valid = UNSOL_INVALID;\r\n} else\r\nicmd->ulpContext = (ushort) tag;\r\nicmd->ulpTimeout = phba->fc_ratov * 2;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\r\n"2722 Xmit CT response on exchange x%x Data: x%x x%x x%x\n",\r\nicmd->ulpContext, icmd->ulpIoTag, tag, phba->link_state);\r\nctiocb->iocb_cmpl = NULL;\r\nctiocb->iocb_flag |= LPFC_IO_LIBDFC;\r\nctiocb->vport = phba->pport;\r\nctiocb->context1 = dd_data;\r\nctiocb->context2 = cmp;\r\nctiocb->context3 = bmp;\r\nctiocb->context_un.ndlp = ndlp;\r\nctiocb->iocb_cmpl = lpfc_issue_ct_rsp_cmp;\r\ndd_data->type = TYPE_IOCB;\r\ndd_data->set_job = job;\r\ndd_data->context_un.iocb.cmdiocbq = ctiocb;\r\ndd_data->context_un.iocb.ndlp = ndlp;\r\ndd_data->context_un.iocb.rmp = NULL;\r\njob->dd_data = dd_data;\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\r\nif (lpfc_readl(phba->HCregaddr, &creg_val)) {\r\nrc = -IOCB_ERROR;\r\ngoto issue_ct_rsp_exit;\r\n}\r\ncreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\r\nwritel(creg_val, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\n}\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, ctiocb, 0);\r\nif (rc == IOCB_SUCCESS) {\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (ctiocb->iocb_flag & LPFC_IO_LIBDFC) {\r\nctiocb->iocb_flag |= LPFC_IO_CMD_OUTSTANDING;\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn 0;\r\n}\r\njob->dd_data = NULL;\r\nissue_ct_rsp_exit:\r\nlpfc_sli_release_iocbq(phba, ctiocb);\r\nno_ctiocb:\r\nkfree(dd_data);\r\nno_dd_data:\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_send_mgmt_rsp(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct send_mgmt_resp *mgmt_resp = (struct send_mgmt_resp *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nstruct ulp_bde64 *bpl;\r\nstruct lpfc_dmabuf *bmp = NULL, *cmp = NULL;\r\nint bpl_entries;\r\nuint32_t tag = mgmt_resp->tag;\r\nunsigned long reqbfrcnt =\r\n(unsigned long)job->request_payload.payload_len;\r\nint rc = 0;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (!reqbfrcnt || (reqbfrcnt > (80 * BUF_SZ_4K))) {\r\nrc = -ERANGE;\r\ngoto send_mgmt_rsp_exit;\r\n}\r\nbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp) {\r\nrc = -ENOMEM;\r\ngoto send_mgmt_rsp_exit;\r\n}\r\nbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\r\nif (!bmp->virt) {\r\nrc = -ENOMEM;\r\ngoto send_mgmt_rsp_free_bmp;\r\n}\r\nINIT_LIST_HEAD(&bmp->list);\r\nbpl = (struct ulp_bde64 *) bmp->virt;\r\nbpl_entries = (LPFC_BPL_SIZE/sizeof(struct ulp_bde64));\r\ncmp = lpfc_alloc_bsg_buffers(phba, job->request_payload.payload_len,\r\n1, bpl, &bpl_entries);\r\nif (!cmp) {\r\nrc = -ENOMEM;\r\ngoto send_mgmt_rsp_free_bmp;\r\n}\r\nlpfc_bsg_copy_data(cmp, &job->request_payload,\r\njob->request_payload.payload_len, 1);\r\nrc = lpfc_issue_ct_rsp(phba, job, tag, cmp, bmp, bpl_entries);\r\nif (rc == IOCB_SUCCESS)\r\nreturn 0;\r\nrc = -EACCES;\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nsend_mgmt_rsp_free_bmp:\r\nif (bmp->virt)\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nsend_mgmt_rsp_exit:\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_diag_mode_enter(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_sli *psli;\r\nstruct lpfc_sli_ring *pring;\r\nint i = 0;\r\npsli = &phba->sli;\r\nif (!psli)\r\nreturn -ENODEV;\r\npring = &psli->ring[LPFC_FCP_RING];\r\nif (!pring)\r\nreturn -ENODEV;\r\nif ((phba->link_state == LPFC_HBA_ERROR) ||\r\n(psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||\r\n(!(psli->sli_flag & LPFC_SLI_ACTIVE)))\r\nreturn -EACCES;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports) {\r\nfor (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nscsi_block_requests(shost);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n} else {\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nscsi_block_requests(shost);\r\n}\r\nwhile (!list_empty(&pring->txcmplq)) {\r\nif (i++ > 500)\r\nbreak;\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_bsg_diag_mode_exit(struct lpfc_hba *phba)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_vport **vports;\r\nint i;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports) {\r\nfor (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nscsi_unblock_requests(shost);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n} else {\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nscsi_unblock_requests(shost);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli3_bsg_diag_loopback_mode(struct lpfc_hba *phba, struct fc_bsg_job *job)\r\n{\r\nstruct diag_mode_set *loopback_mode;\r\nuint32_t link_flags;\r\nuint32_t timeout;\r\nLPFC_MBOXQ_t *pmboxq = NULL;\r\nint mbxstatus = MBX_SUCCESS;\r\nint i = 0;\r\nint rc = 0;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_len < sizeof(struct fc_bsg_request) +\r\nsizeof(struct diag_mode_set)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2738 Received DIAG MODE request size:%d "\r\n"below the minimum size:%d\n",\r\njob->request_len,\r\n(int)(sizeof(struct fc_bsg_request) +\r\nsizeof(struct diag_mode_set)));\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nrc = lpfc_bsg_diag_mode_enter(phba);\r\nif (rc)\r\ngoto job_error;\r\nloopback_mode = (struct diag_mode_set *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nlink_flags = loopback_mode->type;\r\ntimeout = loopback_mode->timeout * 100;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto loopback_mode_exit;\r\n}\r\nmemset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;\r\npmboxq->u.mb.mbxOwner = OWN_HOST;\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\r\nif ((mbxstatus == MBX_SUCCESS) && (pmboxq->u.mb.mbxStatus == 0)) {\r\ni = 0;\r\nwhile (phba->link_state != LPFC_LINK_DOWN) {\r\nif (i++ > timeout) {\r\nrc = -ETIMEDOUT;\r\ngoto loopback_mode_exit;\r\n}\r\nmsleep(10);\r\n}\r\nmemset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\nif (link_flags == INTERNAL_LOOP_BACK)\r\npmboxq->u.mb.un.varInitLnk.link_flags = FLAGS_LOCAL_LB;\r\nelse\r\npmboxq->u.mb.un.varInitLnk.link_flags =\r\nFLAGS_TOPOLOGY_MODE_LOOP;\r\npmboxq->u.mb.mbxCommand = MBX_INIT_LINK;\r\npmboxq->u.mb.mbxOwner = OWN_HOST;\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,\r\nLPFC_MBOX_TMO);\r\nif ((mbxstatus != MBX_SUCCESS) || (pmboxq->u.mb.mbxStatus))\r\nrc = -ENODEV;\r\nelse {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag |= LS_LOOPBACK_MODE;\r\nspin_unlock_irq(&phba->hbalock);\r\nmsleep(100);\r\ni = 0;\r\nwhile (phba->link_state != LPFC_HBA_READY) {\r\nif (i++ > timeout) {\r\nrc = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\n} else\r\nrc = -ENODEV;\r\nloopback_mode_exit:\r\nlpfc_bsg_diag_mode_exit(phba);\r\nif (pmboxq && mbxstatus != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\njob_error:\r\njob->reply->result = rc;\r\nif (rc == 0)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_bsg_set_link_diag_state(struct lpfc_hba *phba, uint32_t diag)\r\n{\r\nLPFC_MBOXQ_t *pmboxq;\r\nstruct lpfc_mbx_set_link_diag_state *link_diag_state;\r\nuint32_t req_len, alloc_len;\r\nint mbxstatus = MBX_SUCCESS, rc;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn -ENOMEM;\r\nreq_len = (sizeof(struct lpfc_mbx_set_link_diag_state) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nalloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\r\nLPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE,\r\nreq_len, LPFC_SLI4_MBX_EMBED);\r\nif (alloc_len != req_len) {\r\nrc = -ENOMEM;\r\ngoto link_diag_state_set_out;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3128 Set link to diagnostic state:x%x (x%x/x%x)\n",\r\ndiag, phba->sli4_hba.lnk_info.lnk_tp,\r\nphba->sli4_hba.lnk_info.lnk_no);\r\nlink_diag_state = &pmboxq->u.mqe.un.link_diag_state;\r\nbf_set(lpfc_mbx_set_diag_state_diag_bit_valid, &link_diag_state->u.req,\r\nLPFC_DIAG_STATE_DIAG_BIT_VALID_CHANGE);\r\nbf_set(lpfc_mbx_set_diag_state_link_num, &link_diag_state->u.req,\r\nphba->sli4_hba.lnk_info.lnk_no);\r\nbf_set(lpfc_mbx_set_diag_state_link_type, &link_diag_state->u.req,\r\nphba->sli4_hba.lnk_info.lnk_tp);\r\nif (diag)\r\nbf_set(lpfc_mbx_set_diag_state_diag,\r\n&link_diag_state->u.req, 1);\r\nelse\r\nbf_set(lpfc_mbx_set_diag_state_diag,\r\n&link_diag_state->u.req, 0);\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\r\nif ((mbxstatus == MBX_SUCCESS) && (pmboxq->u.mb.mbxStatus == 0))\r\nrc = 0;\r\nelse\r\nrc = -ENODEV;\r\nlink_diag_state_set_out:\r\nif (pmboxq && (mbxstatus != MBX_TIMEOUT))\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_bsg_set_internal_loopback(struct lpfc_hba *phba)\r\n{\r\nLPFC_MBOXQ_t *pmboxq;\r\nuint32_t req_len, alloc_len;\r\nstruct lpfc_mbx_set_link_diag_loopback *link_diag_loopback;\r\nint mbxstatus = MBX_SUCCESS, rc = 0;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn -ENOMEM;\r\nreq_len = (sizeof(struct lpfc_mbx_set_link_diag_loopback) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nalloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\r\nLPFC_MBOX_OPCODE_FCOE_LINK_DIAG_LOOPBACK,\r\nreq_len, LPFC_SLI4_MBX_EMBED);\r\nif (alloc_len != req_len) {\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn -ENOMEM;\r\n}\r\nlink_diag_loopback = &pmboxq->u.mqe.un.link_diag_loopback;\r\nbf_set(lpfc_mbx_set_diag_state_link_num,\r\n&link_diag_loopback->u.req, phba->sli4_hba.lnk_info.lnk_no);\r\nbf_set(lpfc_mbx_set_diag_state_link_type,\r\n&link_diag_loopback->u.req, phba->sli4_hba.lnk_info.lnk_tp);\r\nbf_set(lpfc_mbx_set_diag_lpbk_type, &link_diag_loopback->u.req,\r\nLPFC_DIAG_LOOPBACK_TYPE_INTERNAL);\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\r\nif ((mbxstatus != MBX_SUCCESS) || (pmboxq->u.mb.mbxStatus)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3127 Failed setup loopback mode mailbox "\r\n"command, rc:x%x, status:x%x\n", mbxstatus,\r\npmboxq->u.mb.mbxStatus);\r\nrc = -ENODEV;\r\n}\r\nif (pmboxq && (mbxstatus != MBX_TIMEOUT))\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_diag_fcport_reg_setup(struct lpfc_hba *phba)\r\n{\r\nint rc;\r\nif (phba->pport->fc_flag & FC_VFI_REGISTERED) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3136 Port still had vfi registered: "\r\n"mydid:x%x, fcfi:%d, vfi:%d, vpi:%d\n",\r\nphba->pport->fc_myDID, phba->fcf.fcfi,\r\nphba->sli4_hba.vfi_ids[phba->pport->vfi],\r\nphba->vpi_ids[phba->pport->vpi]);\r\nreturn -EINVAL;\r\n}\r\nrc = lpfc_issue_reg_vfi(phba->pport);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_bsg_diag_loopback_mode(struct lpfc_hba *phba, struct fc_bsg_job *job)\r\n{\r\nstruct diag_mode_set *loopback_mode;\r\nuint32_t link_flags, timeout;\r\nint i, rc = 0;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_len < sizeof(struct fc_bsg_request) +\r\nsizeof(struct diag_mode_set)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3011 Received DIAG MODE request size:%d "\r\n"below the minimum size:%d\n",\r\njob->request_len,\r\n(int)(sizeof(struct fc_bsg_request) +\r\nsizeof(struct diag_mode_set)));\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nrc = lpfc_bsg_diag_mode_enter(phba);\r\nif (rc)\r\ngoto job_error;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag |= LS_LOOPBACK_MODE;\r\nspin_unlock_irq(&phba->hbalock);\r\nrc = lpfc_selective_reset(phba);\r\nif (rc)\r\ngoto job_error;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3129 Bring link to diagnostic state.\n");\r\nloopback_mode = (struct diag_mode_set *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nlink_flags = loopback_mode->type;\r\ntimeout = loopback_mode->timeout * 100;\r\nrc = lpfc_sli4_bsg_set_link_diag_state(phba, 1);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3130 Failed to bring link to diagnostic "\r\n"state, rc:x%x\n", rc);\r\ngoto loopback_mode_exit;\r\n}\r\ni = 0;\r\nwhile (phba->link_state != LPFC_LINK_DOWN) {\r\nif (i++ > timeout) {\r\nrc = -ETIMEDOUT;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3131 Timeout waiting for link to "\r\n"diagnostic mode, timeout:%d ms\n",\r\ntimeout * 10);\r\ngoto loopback_mode_exit;\r\n}\r\nmsleep(10);\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3132 Set up loopback mode:x%x\n", link_flags);\r\nif (link_flags == INTERNAL_LOOP_BACK)\r\nrc = lpfc_sli4_bsg_set_internal_loopback(phba);\r\nelse if (link_flags == EXTERNAL_LOOP_BACK)\r\nrc = lpfc_hba_init_link_fc_topology(phba,\r\nFLAGS_TOPOLOGY_MODE_PT_PT,\r\nMBX_NOWAIT);\r\nelse {\r\nrc = -EINVAL;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"3141 Loopback mode:x%x not supported\n",\r\nlink_flags);\r\ngoto loopback_mode_exit;\r\n}\r\nif (!rc) {\r\nmsleep(100);\r\ni = 0;\r\nwhile (phba->link_state < LPFC_LINK_UP) {\r\nif (i++ > timeout) {\r\nrc = -ETIMEDOUT;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3137 Timeout waiting for link up "\r\n"in loopback mode, timeout:%d ms\n",\r\ntimeout * 10);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nif (!rc) {\r\nphba->pport->fc_myDID = 1;\r\nrc = lpfc_sli4_diag_fcport_reg_setup(phba);\r\n} else\r\ngoto loopback_mode_exit;\r\nif (!rc) {\r\nmsleep(100);\r\ni = 0;\r\nwhile (phba->link_state != LPFC_HBA_READY) {\r\nif (i++ > timeout) {\r\nrc = -ETIMEDOUT;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3133 Timeout waiting for port "\r\n"loopback mode ready, timeout:%d ms\n",\r\ntimeout * 10);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nloopback_mode_exit:\r\nif (rc) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag &= ~LS_LOOPBACK_MODE;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nlpfc_bsg_diag_mode_exit(phba);\r\njob_error:\r\njob->reply->result = rc;\r\nif (rc == 0)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_diag_loopback_mode(struct fc_bsg_job *job)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_hba *phba;\r\nint rc;\r\nshost = job->shost;\r\nif (!shost)\r\nreturn -ENODEV;\r\nvport = (struct lpfc_vport *)job->shost->hostdata;\r\nif (!vport)\r\nreturn -ENODEV;\r\nphba = vport->phba;\r\nif (!phba)\r\nreturn -ENODEV;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nrc = lpfc_sli3_bsg_diag_loopback_mode(phba, job);\r\nelse if (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\r\nLPFC_SLI_INTF_IF_TYPE_2)\r\nrc = lpfc_sli4_bsg_diag_loopback_mode(phba, job);\r\nelse\r\nrc = -ENODEV;\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_bsg_diag_mode_end(struct fc_bsg_job *job)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_hba *phba;\r\nstruct diag_mode_set *loopback_mode_end_cmd;\r\nuint32_t timeout;\r\nint rc, i;\r\nshost = job->shost;\r\nif (!shost)\r\nreturn -ENODEV;\r\nvport = (struct lpfc_vport *)job->shost->hostdata;\r\nif (!vport)\r\nreturn -ENODEV;\r\nphba = vport->phba;\r\nif (!phba)\r\nreturn -ENODEV;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nreturn -ENODEV;\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2)\r\nreturn -ENODEV;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag &= ~LS_LOOPBACK_MODE;\r\nspin_unlock_irq(&phba->hbalock);\r\nloopback_mode_end_cmd = (struct diag_mode_set *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\ntimeout = loopback_mode_end_cmd->timeout * 100;\r\nrc = lpfc_sli4_bsg_set_link_diag_state(phba, 0);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3139 Failed to bring link to diagnostic "\r\n"state, rc:x%x\n", rc);\r\ngoto loopback_mode_end_exit;\r\n}\r\ni = 0;\r\nwhile (phba->link_state != LPFC_LINK_DOWN) {\r\nif (i++ > timeout) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3140 Timeout waiting for link to "\r\n"diagnostic mode_end, timeout:%d ms\n",\r\ntimeout * 10);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nrc = lpfc_selective_reset(phba);\r\nphba->pport->fc_myDID = 0;\r\nloopback_mode_end_exit:\r\njob->reply->result = rc;\r\nif (rc == 0)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_bsg_link_diag_test(struct fc_bsg_job *job)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_hba *phba;\r\nLPFC_MBOXQ_t *pmboxq;\r\nstruct sli4_link_diag *link_diag_test_cmd;\r\nuint32_t req_len, alloc_len;\r\nstruct lpfc_mbx_run_link_diag_test *run_link_diag_test;\r\nunion lpfc_sli4_cfg_shdr *shdr;\r\nuint32_t shdr_status, shdr_add_status;\r\nstruct diag_status *diag_status_reply;\r\nint mbxstatus, rc = 0;\r\nshost = job->shost;\r\nif (!shost) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\nvport = (struct lpfc_vport *)job->shost->hostdata;\r\nif (!vport) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\nphba = vport->phba;\r\nif (!phba) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\nif (phba->sli_rev < LPFC_SLI_REV4) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\nif (job->request_len < sizeof(struct fc_bsg_request) +\r\nsizeof(struct sli4_link_diag)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3013 Received LINK DIAG TEST request "\r\n" size:%d below the minimum size:%d\n",\r\njob->request_len,\r\n(int)(sizeof(struct fc_bsg_request) +\r\nsizeof(struct sli4_link_diag)));\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nrc = lpfc_bsg_diag_mode_enter(phba);\r\nif (rc)\r\ngoto job_error;\r\nlink_diag_test_cmd = (struct sli4_link_diag *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nrc = lpfc_sli4_bsg_set_link_diag_state(phba, 1);\r\nif (rc)\r\ngoto job_error;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto link_diag_test_exit;\r\n}\r\nreq_len = (sizeof(struct lpfc_mbx_set_link_diag_state) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nalloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\r\nLPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE,\r\nreq_len, LPFC_SLI4_MBX_EMBED);\r\nif (alloc_len != req_len) {\r\nrc = -ENOMEM;\r\ngoto link_diag_test_exit;\r\n}\r\nrun_link_diag_test = &pmboxq->u.mqe.un.link_diag_test;\r\nbf_set(lpfc_mbx_run_diag_test_link_num, &run_link_diag_test->u.req,\r\nphba->sli4_hba.lnk_info.lnk_no);\r\nbf_set(lpfc_mbx_run_diag_test_link_type, &run_link_diag_test->u.req,\r\nphba->sli4_hba.lnk_info.lnk_tp);\r\nbf_set(lpfc_mbx_run_diag_test_test_id, &run_link_diag_test->u.req,\r\nlink_diag_test_cmd->test_id);\r\nbf_set(lpfc_mbx_run_diag_test_loops, &run_link_diag_test->u.req,\r\nlink_diag_test_cmd->loops);\r\nbf_set(lpfc_mbx_run_diag_test_test_ver, &run_link_diag_test->u.req,\r\nlink_diag_test_cmd->test_version);\r\nbf_set(lpfc_mbx_run_diag_test_err_act, &run_link_diag_test->u.req,\r\nlink_diag_test_cmd->error_action);\r\nmbxstatus = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nshdr = (union lpfc_sli4_cfg_shdr *)\r\n&pmboxq->u.mqe.un.sli4_config.header.cfg_shdr;\r\nshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\r\nshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\r\nif (shdr_status || shdr_add_status || mbxstatus) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"3010 Run link diag test mailbox failed with "\r\n"mbx_status x%x status x%x, add_status x%x\n",\r\nmbxstatus, shdr_status, shdr_add_status);\r\n}\r\ndiag_status_reply = (struct diag_status *)\r\njob->reply->reply_data.vendor_reply.vendor_rsp;\r\nif (job->reply_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct diag_status)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"3012 Received Run link diag test reply "\r\n"below minimum size (%d): reply_len:%d\n",\r\n(int)(sizeof(struct fc_bsg_request) +\r\nsizeof(struct diag_status)),\r\njob->reply_len);\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\ndiag_status_reply->mbox_status = mbxstatus;\r\ndiag_status_reply->shdr_status = shdr_status;\r\ndiag_status_reply->shdr_add_status = shdr_add_status;\r\nlink_diag_test_exit:\r\nrc = lpfc_sli4_bsg_set_link_diag_state(phba, 0);\r\nif (pmboxq)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nlpfc_bsg_diag_mode_exit(phba);\r\njob_error:\r\njob->reply->result = rc;\r\nif (rc == 0)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic int lpfcdiag_loop_self_reg(struct lpfc_hba *phba, uint16_t *rpi)\r\n{\r\nLPFC_MBOXQ_t *mbox;\r\nstruct lpfc_dmabuf *dmabuff;\r\nint status;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox)\r\nreturn -ENOMEM;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nstatus = lpfc_reg_rpi(phba, 0, phba->pport->fc_myDID,\r\n(uint8_t *)&phba->pport->fc_sparam,\r\nmbox, *rpi);\r\nelse {\r\n*rpi = lpfc_sli4_alloc_rpi(phba);\r\nstatus = lpfc_reg_rpi(phba, phba->pport->vpi,\r\nphba->pport->fc_myDID,\r\n(uint8_t *)&phba->pport->fc_sparam,\r\nmbox, *rpi);\r\n}\r\nif (status) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_free_rpi(phba, *rpi);\r\nreturn -ENOMEM;\r\n}\r\ndmabuff = (struct lpfc_dmabuf *) mbox->context1;\r\nmbox->context1 = NULL;\r\nmbox->context2 = NULL;\r\nstatus = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\r\nif ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {\r\nlpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);\r\nkfree(dmabuff);\r\nif (status != MBX_TIMEOUT)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_free_rpi(phba, *rpi);\r\nreturn -ENODEV;\r\n}\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\n*rpi = mbox->u.mb.un.varWords[0];\r\nlpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);\r\nkfree(dmabuff);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn 0;\r\n}\r\nstatic int lpfcdiag_loop_self_unreg(struct lpfc_hba *phba, uint16_t rpi)\r\n{\r\nLPFC_MBOXQ_t *mbox;\r\nint status;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (mbox == NULL)\r\nreturn -ENOMEM;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nlpfc_unreg_login(phba, 0, rpi, mbox);\r\nelse\r\nlpfc_unreg_login(phba, phba->pport->vpi,\r\nphba->sli4_hba.rpi_ids[rpi], mbox);\r\nstatus = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\r\nif ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {\r\nif (status != MBX_TIMEOUT)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_free_rpi(phba, rpi);\r\nreturn 0;\r\n}\r\nstatic int lpfcdiag_loop_get_xri(struct lpfc_hba *phba, uint16_t rpi,\r\nuint16_t *txxri, uint16_t * rxxri)\r\n{\r\nstruct lpfc_bsg_event *evt;\r\nstruct lpfc_iocbq *cmdiocbq, *rspiocbq;\r\nIOCB_t *cmd, *rsp;\r\nstruct lpfc_dmabuf *dmabuf;\r\nstruct ulp_bde64 *bpl = NULL;\r\nstruct lpfc_sli_ct_request *ctreq = NULL;\r\nint ret_val = 0;\r\nint time_left;\r\nint iocb_stat = IOCB_SUCCESS;\r\nunsigned long flags;\r\n*txxri = 0;\r\n*rxxri = 0;\r\nevt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,\r\nSLI_CT_ELX_LOOPBACK);\r\nif (!evt)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_add(&evt->node, &phba->ct_ev_waiters);\r\nlpfc_bsg_event_ref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nrspiocbq = lpfc_sli_get_iocbq(phba);\r\ndmabuf = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (dmabuf) {\r\ndmabuf->virt = lpfc_mbuf_alloc(phba, 0, &dmabuf->phys);\r\nif (dmabuf->virt) {\r\nINIT_LIST_HEAD(&dmabuf->list);\r\nbpl = (struct ulp_bde64 *) dmabuf->virt;\r\nmemset(bpl, 0, sizeof(*bpl));\r\nctreq = (struct lpfc_sli_ct_request *)(bpl + 1);\r\nbpl->addrHigh =\r\nle32_to_cpu(putPaddrHigh(dmabuf->phys +\r\nsizeof(*bpl)));\r\nbpl->addrLow =\r\nle32_to_cpu(putPaddrLow(dmabuf->phys +\r\nsizeof(*bpl)));\r\nbpl->tus.f.bdeFlags = 0;\r\nbpl->tus.f.bdeSize = ELX_LOOPBACK_HEADER_SZ;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\n}\r\n}\r\nif (cmdiocbq == NULL || rspiocbq == NULL ||\r\ndmabuf == NULL || bpl == NULL || ctreq == NULL ||\r\ndmabuf->virt == NULL) {\r\nret_val = -ENOMEM;\r\ngoto err_get_xri_exit;\r\n}\r\ncmd = &cmdiocbq->iocb;\r\nrsp = &rspiocbq->iocb;\r\nmemset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);\r\nctreq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nctreq->RevisionId.bits.InId = 0;\r\nctreq->FsType = SLI_CT_ELX_LOOPBACK;\r\nctreq->FsSubType = 0;\r\nctreq->CommandResponse.bits.CmdRsp = ELX_LOOPBACK_XRI_SETUP;\r\nctreq->CommandResponse.bits.Size = 0;\r\ncmd->un.xseq64.bdl.addrHigh = putPaddrHigh(dmabuf->phys);\r\ncmd->un.xseq64.bdl.addrLow = putPaddrLow(dmabuf->phys);\r\ncmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\ncmd->un.xseq64.bdl.bdeSize = sizeof(*bpl);\r\ncmd->un.xseq64.w5.hcsw.Fctl = LA;\r\ncmd->un.xseq64.w5.hcsw.Dfctl = 0;\r\ncmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;\r\ncmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;\r\ncmd->ulpCommand = CMD_XMIT_SEQUENCE64_CR;\r\ncmd->ulpBdeCount = 1;\r\ncmd->ulpLe = 1;\r\ncmd->ulpClass = CLASS3;\r\ncmd->ulpContext = rpi;\r\ncmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\r\ncmdiocbq->vport = phba->pport;\r\ncmdiocbq->iocb_cmpl = NULL;\r\niocb_stat = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,\r\nrspiocbq,\r\n(phba->fc_ratov * 2)\r\n+ LPFC_DRVR_TIMEOUT);\r\nif ((iocb_stat != IOCB_SUCCESS) || (rsp->ulpStatus != IOSTAT_SUCCESS)) {\r\nret_val = -EIO;\r\ngoto err_get_xri_exit;\r\n}\r\n*txxri = rsp->ulpContext;\r\nevt->waiting = 1;\r\nevt->wait_time_stamp = jiffies;\r\ntime_left = wait_event_interruptible_timeout(\r\nevt->wq, !list_empty(&evt->events_to_see),\r\nmsecs_to_jiffies(1000 *\r\n((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT)));\r\nif (list_empty(&evt->events_to_see))\r\nret_val = (time_left) ? -EINTR : -ETIMEDOUT;\r\nelse {\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_move(evt->events_to_see.prev, &evt->events_to_get);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\n*rxxri = (list_entry(evt->events_to_get.prev,\r\ntypeof(struct event_data),\r\nnode))->immed_dat;\r\n}\r\nevt->waiting = 0;\r\nerr_get_xri_exit:\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlpfc_bsg_event_unref(evt);\r\nlpfc_bsg_event_unref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif (dmabuf) {\r\nif (dmabuf->virt)\r\nlpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);\r\nkfree(dmabuf);\r\n}\r\nif (cmdiocbq && (iocb_stat != IOCB_TIMEDOUT))\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nif (rspiocbq)\r\nlpfc_sli_release_iocbq(phba, rspiocbq);\r\nreturn ret_val;\r\n}\r\nstatic struct lpfc_dmabuf *\r\nlpfc_bsg_dma_page_alloc(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_dmabuf *dmabuf;\r\nstruct pci_dev *pcidev = phba->pcidev;\r\ndmabuf = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&dmabuf->list);\r\ndmabuf->virt = dma_zalloc_coherent(&pcidev->dev, BSG_MBOX_SIZE,\r\n&(dmabuf->phys), GFP_KERNEL);\r\nif (!dmabuf->virt) {\r\nkfree(dmabuf);\r\nreturn NULL;\r\n}\r\nreturn dmabuf;\r\n}\r\nstatic void\r\nlpfc_bsg_dma_page_free(struct lpfc_hba *phba, struct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct pci_dev *pcidev = phba->pcidev;\r\nif (!dmabuf)\r\nreturn;\r\nif (dmabuf->virt)\r\ndma_free_coherent(&pcidev->dev, BSG_MBOX_SIZE,\r\ndmabuf->virt, dmabuf->phys);\r\nkfree(dmabuf);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_bsg_dma_page_list_free(struct lpfc_hba *phba,\r\nstruct list_head *dmabuf_list)\r\n{\r\nstruct lpfc_dmabuf *dmabuf, *next_dmabuf;\r\nif (list_empty(dmabuf_list))\r\nreturn;\r\nlist_for_each_entry_safe(dmabuf, next_dmabuf, dmabuf_list, list) {\r\nlist_del_init(&dmabuf->list);\r\nlpfc_bsg_dma_page_free(phba, dmabuf);\r\n}\r\nreturn;\r\n}\r\nstatic struct lpfc_dmabufext *\r\ndiag_cmd_data_alloc(struct lpfc_hba *phba,\r\nstruct ulp_bde64 *bpl, uint32_t size,\r\nint nocopydata)\r\n{\r\nstruct lpfc_dmabufext *mlist = NULL;\r\nstruct lpfc_dmabufext *dmp;\r\nint cnt, offset = 0, i = 0;\r\nstruct pci_dev *pcidev;\r\npcidev = phba->pcidev;\r\nwhile (size) {\r\nif (size > BUF_SZ_4K)\r\ncnt = BUF_SZ_4K;\r\nelse\r\ncnt = size;\r\ndmp = kmalloc(sizeof(struct lpfc_dmabufext), GFP_KERNEL);\r\nif (!dmp)\r\ngoto out;\r\nINIT_LIST_HEAD(&dmp->dma.list);\r\nif (mlist)\r\nlist_add_tail(&dmp->dma.list, &mlist->dma.list);\r\nelse\r\nmlist = dmp;\r\ndmp->dma.virt = dma_alloc_coherent(&pcidev->dev,\r\ncnt,\r\n&(dmp->dma.phys),\r\nGFP_KERNEL);\r\nif (!dmp->dma.virt)\r\ngoto out;\r\ndmp->size = cnt;\r\nif (nocopydata) {\r\nbpl->tus.f.bdeFlags = 0;\r\npci_dma_sync_single_for_device(phba->pcidev,\r\ndmp->dma.phys, LPFC_BPL_SIZE, PCI_DMA_TODEVICE);\r\n} else {\r\nmemset((uint8_t *)dmp->dma.virt, 0, cnt);\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\n}\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(dmp->dma.phys));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(dmp->dma.phys));\r\nbpl->tus.f.bdeSize = (ushort) cnt;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl++;\r\ni++;\r\noffset += cnt;\r\nsize -= cnt;\r\n}\r\nif (mlist) {\r\nmlist->flag = i;\r\nreturn mlist;\r\n}\r\nout:\r\ndiag_cmd_data_free(phba, mlist);\r\nreturn NULL;\r\n}\r\nstatic int lpfcdiag_loop_post_rxbufs(struct lpfc_hba *phba, uint16_t rxxri,\r\nsize_t len)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring = &psli->ring[LPFC_ELS_RING];\r\nstruct lpfc_iocbq *cmdiocbq;\r\nIOCB_t *cmd = NULL;\r\nstruct list_head head, *curr, *next;\r\nstruct lpfc_dmabuf *rxbmp;\r\nstruct lpfc_dmabuf *dmp;\r\nstruct lpfc_dmabuf *mp[2] = {NULL, NULL};\r\nstruct ulp_bde64 *rxbpl = NULL;\r\nuint32_t num_bde;\r\nstruct lpfc_dmabufext *rxbuffer = NULL;\r\nint ret_val = 0;\r\nint iocb_stat;\r\nint i = 0;\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nrxbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (rxbmp != NULL) {\r\nrxbmp->virt = lpfc_mbuf_alloc(phba, 0, &rxbmp->phys);\r\nif (rxbmp->virt) {\r\nINIT_LIST_HEAD(&rxbmp->list);\r\nrxbpl = (struct ulp_bde64 *) rxbmp->virt;\r\nrxbuffer = diag_cmd_data_alloc(phba, rxbpl, len, 0);\r\n}\r\n}\r\nif (!cmdiocbq || !rxbmp || !rxbpl || !rxbuffer) {\r\nret_val = -ENOMEM;\r\ngoto err_post_rxbufs_exit;\r\n}\r\nnum_bde = (uint32_t)rxbuffer->flag;\r\ndmp = &rxbuffer->dma;\r\ncmd = &cmdiocbq->iocb;\r\ni = 0;\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &dmp->list);\r\nlist_for_each_safe(curr, next, &head) {\r\nmp[i] = list_entry(curr, struct lpfc_dmabuf, list);\r\nlist_del(curr);\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\nmp[i]->buffer_tag = lpfc_sli_get_buffer_tag(phba);\r\ncmd->un.quexri64cx.buff.bde.addrHigh =\r\nputPaddrHigh(mp[i]->phys);\r\ncmd->un.quexri64cx.buff.bde.addrLow =\r\nputPaddrLow(mp[i]->phys);\r\ncmd->un.quexri64cx.buff.bde.tus.f.bdeSize =\r\n((struct lpfc_dmabufext *)mp[i])->size;\r\ncmd->un.quexri64cx.buff.buffer_tag = mp[i]->buffer_tag;\r\ncmd->ulpCommand = CMD_QUE_XRI64_CX;\r\ncmd->ulpPU = 0;\r\ncmd->ulpLe = 1;\r\ncmd->ulpBdeCount = 1;\r\ncmd->unsli3.que_xri64cx_ext_words.ebde_count = 0;\r\n} else {\r\ncmd->un.cont64[i].addrHigh = putPaddrHigh(mp[i]->phys);\r\ncmd->un.cont64[i].addrLow = putPaddrLow(mp[i]->phys);\r\ncmd->un.cont64[i].tus.f.bdeSize =\r\n((struct lpfc_dmabufext *)mp[i])->size;\r\ncmd->ulpBdeCount = ++i;\r\nif ((--num_bde > 0) && (i < 2))\r\ncontinue;\r\ncmd->ulpCommand = CMD_QUE_XRI_BUF64_CX;\r\ncmd->ulpLe = 1;\r\n}\r\ncmd->ulpClass = CLASS3;\r\ncmd->ulpContext = rxxri;\r\niocb_stat = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq,\r\n0);\r\nif (iocb_stat == IOCB_ERROR) {\r\ndiag_cmd_data_free(phba,\r\n(struct lpfc_dmabufext *)mp[0]);\r\nif (mp[1])\r\ndiag_cmd_data_free(phba,\r\n(struct lpfc_dmabufext *)mp[1]);\r\ndmp = list_entry(next, struct lpfc_dmabuf, list);\r\nret_val = -EIO;\r\ngoto err_post_rxbufs_exit;\r\n}\r\nlpfc_sli_ringpostbuf_put(phba, pring, mp[0]);\r\nif (mp[1]) {\r\nlpfc_sli_ringpostbuf_put(phba, pring, mp[1]);\r\nmp[1] = NULL;\r\n}\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nif (!cmdiocbq) {\r\ndmp = list_entry(next, struct lpfc_dmabuf, list);\r\nret_val = -EIO;\r\ngoto err_post_rxbufs_exit;\r\n}\r\ncmd = &cmdiocbq->iocb;\r\ni = 0;\r\n}\r\nlist_del(&head);\r\nerr_post_rxbufs_exit:\r\nif (rxbmp) {\r\nif (rxbmp->virt)\r\nlpfc_mbuf_free(phba, rxbmp->virt, rxbmp->phys);\r\nkfree(rxbmp);\r\n}\r\nif (cmdiocbq)\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nreturn ret_val;\r\n}\r\nstatic int\r\nlpfc_bsg_diag_loopback_run(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct diag_mode_test *diag_mode;\r\nstruct lpfc_bsg_event *evt;\r\nstruct event_data *evdat;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nuint32_t size;\r\nuint32_t full_size;\r\nsize_t segment_len = 0, segment_offset = 0, current_offset = 0;\r\nuint16_t rpi = 0;\r\nstruct lpfc_iocbq *cmdiocbq, *rspiocbq = NULL;\r\nIOCB_t *cmd, *rsp = NULL;\r\nstruct lpfc_sli_ct_request *ctreq;\r\nstruct lpfc_dmabuf *txbmp;\r\nstruct ulp_bde64 *txbpl = NULL;\r\nstruct lpfc_dmabufext *txbuffer = NULL;\r\nstruct list_head head;\r\nstruct lpfc_dmabuf *curr;\r\nuint16_t txxri = 0, rxxri;\r\nuint32_t num_bde;\r\nuint8_t *ptr = NULL, *rx_databuf = NULL;\r\nint rc = 0;\r\nint time_left;\r\nint iocb_stat = IOCB_SUCCESS;\r\nunsigned long flags;\r\nvoid *dataout = NULL;\r\nuint32_t total_mem;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct diag_mode_test)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2739 Received DIAG TEST request below minimum "\r\n"size\n");\r\nrc = -EINVAL;\r\ngoto loopback_test_exit;\r\n}\r\nif (job->request_payload.payload_len !=\r\njob->reply_payload.payload_len) {\r\nrc = -EINVAL;\r\ngoto loopback_test_exit;\r\n}\r\ndiag_mode = (struct diag_mode_test *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nif ((phba->link_state == LPFC_HBA_ERROR) ||\r\n(psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||\r\n(!(psli->sli_flag & LPFC_SLI_ACTIVE))) {\r\nrc = -EACCES;\r\ngoto loopback_test_exit;\r\n}\r\nif (!lpfc_is_link_up(phba) || !(phba->link_flag & LS_LOOPBACK_MODE)) {\r\nrc = -EACCES;\r\ngoto loopback_test_exit;\r\n}\r\nsize = job->request_payload.payload_len;\r\nfull_size = size + ELX_LOOPBACK_HEADER_SZ;\r\nif ((size == 0) || (size > 80 * BUF_SZ_4K)) {\r\nrc = -ERANGE;\r\ngoto loopback_test_exit;\r\n}\r\nif (full_size >= BUF_SZ_4K) {\r\nif (size <= (64 * 1024))\r\ntotal_mem = full_size;\r\nelse\r\ntotal_mem = 64 * 1024;\r\n} else\r\ntotal_mem = BUF_SZ_4K;\r\ndataout = kmalloc(total_mem, GFP_KERNEL);\r\nif (dataout == NULL) {\r\nrc = -ENOMEM;\r\ngoto loopback_test_exit;\r\n}\r\nptr = dataout;\r\nptr += ELX_LOOPBACK_HEADER_SZ;\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nptr, size);\r\nrc = lpfcdiag_loop_self_reg(phba, &rpi);\r\nif (rc)\r\ngoto loopback_test_exit;\r\nif (phba->sli_rev < LPFC_SLI_REV4) {\r\nrc = lpfcdiag_loop_get_xri(phba, rpi, &txxri, &rxxri);\r\nif (rc) {\r\nlpfcdiag_loop_self_unreg(phba, rpi);\r\ngoto loopback_test_exit;\r\n}\r\nrc = lpfcdiag_loop_post_rxbufs(phba, rxxri, full_size);\r\nif (rc) {\r\nlpfcdiag_loop_self_unreg(phba, rpi);\r\ngoto loopback_test_exit;\r\n}\r\n}\r\nevt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,\r\nSLI_CT_ELX_LOOPBACK);\r\nif (!evt) {\r\nlpfcdiag_loop_self_unreg(phba, rpi);\r\nrc = -ENOMEM;\r\ngoto loopback_test_exit;\r\n}\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_add(&evt->node, &phba->ct_ev_waiters);\r\nlpfc_bsg_event_ref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nrspiocbq = lpfc_sli_get_iocbq(phba);\r\ntxbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (txbmp) {\r\ntxbmp->virt = lpfc_mbuf_alloc(phba, 0, &txbmp->phys);\r\nif (txbmp->virt) {\r\nINIT_LIST_HEAD(&txbmp->list);\r\ntxbpl = (struct ulp_bde64 *) txbmp->virt;\r\ntxbuffer = diag_cmd_data_alloc(phba,\r\ntxbpl, full_size, 0);\r\n}\r\n}\r\nif (!cmdiocbq || !txbmp || !txbpl || !txbuffer || !txbmp->virt) {\r\nrc = -ENOMEM;\r\ngoto err_loopback_test_exit;\r\n}\r\nif ((phba->sli_rev < LPFC_SLI_REV4) && !rspiocbq) {\r\nrc = -ENOMEM;\r\ngoto err_loopback_test_exit;\r\n}\r\ncmd = &cmdiocbq->iocb;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nrsp = &rspiocbq->iocb;\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &txbuffer->dma.list);\r\nlist_for_each_entry(curr, &head, list) {\r\nsegment_len = ((struct lpfc_dmabufext *)curr)->size;\r\nif (current_offset == 0) {\r\nctreq = curr->virt;\r\nmemset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);\r\nctreq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nctreq->RevisionId.bits.InId = 0;\r\nctreq->FsType = SLI_CT_ELX_LOOPBACK;\r\nctreq->FsSubType = 0;\r\nctreq->CommandResponse.bits.CmdRsp = ELX_LOOPBACK_DATA;\r\nctreq->CommandResponse.bits.Size = size;\r\nsegment_offset = ELX_LOOPBACK_HEADER_SZ;\r\n} else\r\nsegment_offset = 0;\r\nBUG_ON(segment_offset >= segment_len);\r\nmemcpy(curr->virt + segment_offset,\r\nptr + current_offset,\r\nsegment_len - segment_offset);\r\ncurrent_offset += segment_len - segment_offset;\r\nBUG_ON(current_offset > size);\r\n}\r\nlist_del(&head);\r\nnum_bde = (uint32_t)txbuffer->flag;\r\ncmd->un.xseq64.bdl.addrHigh = putPaddrHigh(txbmp->phys);\r\ncmd->un.xseq64.bdl.addrLow = putPaddrLow(txbmp->phys);\r\ncmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\ncmd->un.xseq64.bdl.bdeSize = (num_bde * sizeof(struct ulp_bde64));\r\ncmd->un.xseq64.w5.hcsw.Fctl = (LS | LA);\r\ncmd->un.xseq64.w5.hcsw.Dfctl = 0;\r\ncmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;\r\ncmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;\r\ncmd->ulpCommand = CMD_XMIT_SEQUENCE64_CX;\r\ncmd->ulpBdeCount = 1;\r\ncmd->ulpLe = 1;\r\ncmd->ulpClass = CLASS3;\r\nif (phba->sli_rev < LPFC_SLI_REV4) {\r\ncmd->ulpContext = txxri;\r\n} else {\r\ncmd->un.xseq64.bdl.ulpIoTag32 = 0;\r\ncmd->un.ulpWord[3] = phba->sli4_hba.rpi_ids[rpi];\r\ncmdiocbq->context3 = txbmp;\r\ncmdiocbq->sli4_xritag = NO_XRI;\r\ncmd->unsli3.rcvsli3.ox_id = 0xffff;\r\n}\r\ncmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\r\ncmdiocbq->iocb_flag |= LPFC_IO_LOOPBACK;\r\ncmdiocbq->vport = phba->pport;\r\ncmdiocbq->iocb_cmpl = NULL;\r\niocb_stat = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,\r\nrspiocbq, (phba->fc_ratov * 2) +\r\nLPFC_DRVR_TIMEOUT);\r\nif ((iocb_stat != IOCB_SUCCESS) ||\r\n((phba->sli_rev < LPFC_SLI_REV4) &&\r\n(rsp->ulpStatus != IOSTAT_SUCCESS))) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"3126 Failed loopback test issue iocb: "\r\n"iocb_stat:x%x\n", iocb_stat);\r\nrc = -EIO;\r\ngoto err_loopback_test_exit;\r\n}\r\nevt->waiting = 1;\r\ntime_left = wait_event_interruptible_timeout(\r\nevt->wq, !list_empty(&evt->events_to_see),\r\nmsecs_to_jiffies(1000 *\r\n((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT)));\r\nevt->waiting = 0;\r\nif (list_empty(&evt->events_to_see)) {\r\nrc = (time_left) ? -EINTR : -ETIMEDOUT;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"3125 Not receiving unsolicited event, "\r\n"rc:x%x\n", rc);\r\n} else {\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlist_move(evt->events_to_see.prev, &evt->events_to_get);\r\nevdat = list_entry(evt->events_to_get.prev,\r\ntypeof(*evdat), node);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nrx_databuf = evdat->data;\r\nif (evdat->len != full_size) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"1603 Loopback test did not receive expected "\r\n"data length. actual length 0x%x expected "\r\n"length 0x%x\n",\r\nevdat->len, full_size);\r\nrc = -EIO;\r\n} else if (rx_databuf == NULL)\r\nrc = -EIO;\r\nelse {\r\nrc = IOCB_SUCCESS;\r\nrx_databuf += ELX_LOOPBACK_HEADER_SZ;\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\nrx_databuf, size);\r\njob->reply->reply_payload_rcv_len = size;\r\n}\r\n}\r\nerr_loopback_test_exit:\r\nlpfcdiag_loop_self_unreg(phba, rpi);\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\nlpfc_bsg_event_unref(evt);\r\nlpfc_bsg_event_unref(evt);\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif ((cmdiocbq != NULL) && (iocb_stat != IOCB_TIMEDOUT))\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nif (rspiocbq != NULL)\r\nlpfc_sli_release_iocbq(phba, rspiocbq);\r\nif (txbmp != NULL) {\r\nif (txbpl != NULL) {\r\nif (txbuffer != NULL)\r\ndiag_cmd_data_free(phba, txbuffer);\r\nlpfc_mbuf_free(phba, txbmp->virt, txbmp->phys);\r\n}\r\nkfree(txbmp);\r\n}\r\nloopback_test_exit:\r\nkfree(dataout);\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\nif (rc == IOCB_SUCCESS)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_get_dfc_rev(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct get_mgmt_rev *event_req;\r\nstruct get_mgmt_rev_reply *event_reply;\r\nint rc = 0;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct get_mgmt_rev)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2740 Received GET_DFC_REV request below "\r\n"minimum size\n");\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nevent_req = (struct get_mgmt_rev *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nevent_reply = (struct get_mgmt_rev_reply *)\r\njob->reply->reply_data.vendor_reply.vendor_rsp;\r\nif (job->reply_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct get_mgmt_rev_reply)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2741 Received GET_DFC_REV reply below "\r\n"minimum size\n");\r\nrc = -EINVAL;\r\ngoto job_error;\r\n}\r\nevent_reply->info.a_Major = MANAGEMENT_MAJOR_REV;\r\nevent_reply->info.a_Minor = MANAGEMENT_MINOR_REV;\r\njob_error:\r\njob->reply->result = rc;\r\nif (rc == 0)\r\njob->job_done(job);\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_bsg_issue_mbox_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nuint32_t size;\r\nunsigned long flags;\r\nuint8_t *pmb, *pmb_buf;\r\ndd_data = pmboxq->context1;\r\npmb = (uint8_t *)&pmboxq->u.mb;\r\npmb_buf = (uint8_t *)dd_data->context_un.mbox.mb;\r\nmemcpy(pmb_buf, pmb, sizeof(MAILBOX_t));\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif (job) {\r\nsize = job->reply_payload.payload_len;\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\npmb_buf, size);\r\n}\r\ndd_data->set_job = NULL;\r\nmempool_free(dd_data->context_un.mbox.pmboxq, phba->mbox_mem_pool);\r\nlpfc_bsg_dma_page_free(phba, dd_data->context_un.mbox.dmabuffers);\r\nkfree(dd_data);\r\nif (job) {\r\njob->reply->result = 0;\r\njob->job_done(job);\r\n}\r\nreturn;\r\n}\r\nstatic int lpfc_bsg_check_cmd_access(struct lpfc_hba *phba,\r\nMAILBOX_t *mb, struct lpfc_vport *vport)\r\n{\r\nswitch (mb->mbxCommand) {\r\ncase MBX_INIT_LINK:\r\ncase MBX_DOWN_LINK:\r\ncase MBX_CONFIG_LINK:\r\ncase MBX_CONFIG_RING:\r\ncase MBX_RESET_RING:\r\ncase MBX_UNREG_LOGIN:\r\ncase MBX_CLEAR_LA:\r\ncase MBX_DUMP_CONTEXT:\r\ncase MBX_RUN_DIAGS:\r\ncase MBX_RESTART:\r\ncase MBX_SET_MASK:\r\nif (!(vport->fc_flag & FC_OFFLINE_MODE)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2743 Command 0x%x is illegal in on-line "\r\n"state\n",\r\nmb->mbxCommand);\r\nreturn -EPERM;\r\n}\r\ncase MBX_WRITE_NV:\r\ncase MBX_WRITE_VPARMS:\r\ncase MBX_LOAD_SM:\r\ncase MBX_READ_NV:\r\ncase MBX_READ_CONFIG:\r\ncase MBX_READ_RCONFIG:\r\ncase MBX_READ_STATUS:\r\ncase MBX_READ_XRI:\r\ncase MBX_READ_REV:\r\ncase MBX_READ_LNK_STAT:\r\ncase MBX_DUMP_MEMORY:\r\ncase MBX_DOWN_LOAD:\r\ncase MBX_UPDATE_CFG:\r\ncase MBX_KILL_BOARD:\r\ncase MBX_READ_TOPOLOGY:\r\ncase MBX_LOAD_AREA:\r\ncase MBX_LOAD_EXP_ROM:\r\ncase MBX_BEACON:\r\ncase MBX_DEL_LD_ENTRY:\r\ncase MBX_SET_DEBUG:\r\ncase MBX_WRITE_WWN:\r\ncase MBX_SLI4_CONFIG:\r\ncase MBX_READ_EVENT_LOG:\r\ncase MBX_READ_EVENT_LOG_STATUS:\r\ncase MBX_WRITE_EVENT_LOG:\r\ncase MBX_PORT_CAPABILITIES:\r\ncase MBX_PORT_IOV_CONTROL:\r\ncase MBX_RUN_BIU_DIAG64:\r\nbreak;\r\ncase MBX_SET_VARIABLE:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"1226 mbox: set_variable 0x%x, 0x%x\n",\r\nmb->un.varWords[0],\r\nmb->un.varWords[1]);\r\nif ((mb->un.varWords[0] == SETVAR_MLOMNT)\r\n&& (mb->un.varWords[1] == 1)) {\r\nphba->wait_4_mlo_maint_flg = 1;\r\n} else if (mb->un.varWords[0] == SETVAR_MLORST) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag &= ~LS_LOOPBACK_MODE;\r\nspin_unlock_irq(&phba->hbalock);\r\nphba->fc_topology = LPFC_TOPOLOGY_PT_PT;\r\n}\r\nbreak;\r\ncase MBX_READ_SPARM64:\r\ncase MBX_REG_LOGIN:\r\ncase MBX_REG_LOGIN64:\r\ncase MBX_CONFIG_PORT:\r\ncase MBX_RUN_BIU_DIAG:\r\ndefault:\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2742 Unknown Command 0x%x\n",\r\nmb->mbxCommand);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_bsg_mbox_ext_session_reset(struct lpfc_hba *phba)\r\n{\r\nif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_IDLE)\r\nreturn;\r\nlpfc_bsg_dma_page_list_free(phba,\r\n&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\nlpfc_bsg_dma_page_free(phba, phba->mbox_ext_buf_ctx.mbx_dmabuf);\r\nmemset((char *)&phba->mbox_ext_buf_ctx, 0,\r\nsizeof(struct lpfc_mbox_ext_buf_ctx));\r\nINIT_LIST_HEAD(&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\nreturn;\r\n}\r\nstatic struct fc_bsg_job *\r\nlpfc_bsg_issue_mbox_ext_handle_job(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nuint8_t *pmb, *pmb_buf;\r\nunsigned long flags;\r\nuint32_t size;\r\nint rc = 0;\r\nstruct lpfc_dmabuf *dmabuf;\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nuint8_t *pmbx;\r\ndd_data = pmboxq->context1;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\npmb = (uint8_t *)&pmboxq->u.mb;\r\npmb_buf = (uint8_t *)dd_data->context_un.mbox.mb;\r\nmemcpy(pmb_buf, pmb, sizeof(MAILBOX_t));\r\ndmabuf = phba->mbox_ext_buf_ctx.mbx_dmabuf;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\r\nif (!bsg_bf_get(lpfc_mbox_hdr_emb,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) {\r\npmbx = (uint8_t *)dmabuf->virt;\r\nlpfc_sli_pcimem_bcopy(&pmbx[sizeof(MAILBOX_t)],\r\n&pmbx[sizeof(MAILBOX_t)],\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.mse[0].buf_len);\r\n}\r\nif (job) {\r\nsize = job->reply_payload.payload_len;\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\npmb_buf, size);\r\njob->reply->result = 0;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2937 SLI_CONFIG ext-buffer maibox command "\r\n"(x%x/x%x) complete bsg job done, bsize:%d\n",\r\nphba->mbox_ext_buf_ctx.nembType,\r\nphba->mbox_ext_buf_ctx.mboxType, size);\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba,\r\nphba->mbox_ext_buf_ctx.nembType,\r\nphba->mbox_ext_buf_ctx.mboxType,\r\ndma_ebuf, sta_pos_addr,\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf, 0);\r\n} else {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2938 SLI_CONFIG ext-buffer maibox "\r\n"command (x%x/x%x) failure, rc:x%x\n",\r\nphba->mbox_ext_buf_ctx.nembType,\r\nphba->mbox_ext_buf_ctx.mboxType, rc);\r\n}\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_DONE;\r\nkfree(dd_data);\r\nreturn job;\r\n}\r\nstatic void\r\nlpfc_bsg_issue_read_mbox_ext_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\r\n{\r\nstruct fc_bsg_job *job;\r\njob = lpfc_bsg_issue_mbox_ext_handle_job(phba, pmboxq);\r\nif (!job)\r\npmboxq->u.mb.mbxStatus = MBXERR_ERROR;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2939 SLI_CONFIG ext-buffer rd maibox command "\r\n"complete, ctxState:x%x, mbxStatus:x%x\n",\r\nphba->mbox_ext_buf_ctx.state, pmboxq->u.mb.mbxStatus);\r\nif (pmboxq->u.mb.mbxStatus || phba->mbox_ext_buf_ctx.numBuf == 1)\r\nlpfc_bsg_mbox_ext_session_reset(phba);\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nif (job)\r\njob->job_done(job);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_bsg_issue_write_mbox_ext_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\r\n{\r\nstruct fc_bsg_job *job;\r\njob = lpfc_bsg_issue_mbox_ext_handle_job(phba, pmboxq);\r\nif (!job)\r\npmboxq->u.mb.mbxStatus = MBXERR_ERROR;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2940 SLI_CONFIG ext-buffer wr maibox command "\r\n"complete, ctxState:x%x, mbxStatus:x%x\n",\r\nphba->mbox_ext_buf_ctx.state, pmboxq->u.mb.mbxStatus);\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nlpfc_bsg_mbox_ext_session_reset(phba);\r\nif (job)\r\njob->job_done(job);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_bsg_sli_cfg_dma_desc_setup(struct lpfc_hba *phba, enum nemb_type nemb_tp,\r\nuint32_t index, struct lpfc_dmabuf *mbx_dmabuf,\r\nstruct lpfc_dmabuf *ext_dmabuf)\r\n{\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)mbx_dmabuf->virt;\r\nif (nemb_tp == nemb_mse) {\r\nif (index == 0) {\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_hi =\r\nputPaddrHigh(mbx_dmabuf->phys +\r\nsizeof(MAILBOX_t));\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_lo =\r\nputPaddrLow(mbx_dmabuf->phys +\r\nsizeof(MAILBOX_t));\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2943 SLI_CONFIG(mse)[%d], "\r\n"bufLen:%d, addrHi:x%x, addrLo:x%x\n",\r\nindex,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].buf_len,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_hi,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_lo);\r\n} else {\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_hi =\r\nputPaddrHigh(ext_dmabuf->phys);\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_lo =\r\nputPaddrLow(ext_dmabuf->phys);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2944 SLI_CONFIG(mse)[%d], "\r\n"bufLen:%d, addrHi:x%x, addrLo:x%x\n",\r\nindex,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].buf_len,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_hi,\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[index].pa_lo);\r\n}\r\n} else {\r\nif (index == 0) {\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_hi =\r\nputPaddrHigh(mbx_dmabuf->phys +\r\nsizeof(MAILBOX_t));\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_lo =\r\nputPaddrLow(mbx_dmabuf->phys +\r\nsizeof(MAILBOX_t));\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3007 SLI_CONFIG(hbd)[%d], "\r\n"bufLen:%d, addrHi:x%x, addrLo:x%x\n",\r\nindex,\r\nbsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\r\n&sli_cfg_mbx->un.\r\nsli_config_emb1_subsys.hbd[index]),\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_hi,\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_lo);\r\n} else {\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_hi =\r\nputPaddrHigh(ext_dmabuf->phys);\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_lo =\r\nputPaddrLow(ext_dmabuf->phys);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3008 SLI_CONFIG(hbd)[%d], "\r\n"bufLen:%d, addrHi:x%x, addrLo:x%x\n",\r\nindex,\r\nbsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\r\n&sli_cfg_mbx->un.\r\nsli_config_emb1_subsys.hbd[index]),\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_hi,\r\nsli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[index].pa_lo);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_bsg_sli_cfg_read_cmd_ext(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nenum nemb_type nemb_tp,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nstruct dfc_mbox_req *mbox_req;\r\nstruct lpfc_dmabuf *curr_dmabuf, *next_dmabuf;\r\nuint32_t ext_buf_cnt, ext_buf_index;\r\nstruct lpfc_dmabuf *ext_dmabuf = NULL;\r\nstruct bsg_job_data *dd_data = NULL;\r\nLPFC_MBOXQ_t *pmboxq = NULL;\r\nMAILBOX_t *pmb;\r\nuint8_t *pmbx;\r\nint rc, i;\r\nmbox_req =\r\n(struct dfc_mbox_req *)job->request->rqst_data.h_vendor.vendor_cmd;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\r\nif (nemb_tp == nemb_mse) {\r\next_buf_cnt = bsg_bf_get(lpfc_mbox_hdr_mse_cnt,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr);\r\nif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_MSE) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2945 Handled SLI_CONFIG(mse) rd, "\r\n"ext_buf_cnt(%d) out of range(%d)\n",\r\next_buf_cnt,\r\nLPFC_MBX_SLI_CONFIG_MAX_MSE);\r\nrc = -ERANGE;\r\ngoto job_error;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2941 Handled SLI_CONFIG(mse) rd, "\r\n"ext_buf_cnt:%d\n", ext_buf_cnt);\r\n} else {\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2) {\r\nrc = -ENODEV;\r\ngoto job_error;\r\n}\r\next_buf_cnt = sli_cfg_mbx->un.sli_config_emb1_subsys.hbd_count;\r\nif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_HBD) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2946 Handled SLI_CONFIG(hbd) rd, "\r\n"ext_buf_cnt(%d) out of range(%d)\n",\r\next_buf_cnt,\r\nLPFC_MBX_SLI_CONFIG_MAX_HBD);\r\nrc = -ERANGE;\r\ngoto job_error;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2942 Handled SLI_CONFIG(hbd) rd, "\r\n"ext_buf_cnt:%d\n", ext_buf_cnt);\r\n}\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_rd, dma_mbox,\r\nsta_pre_addr, dmabuf, ext_buf_cnt);\r\nif (ext_buf_cnt == 0) {\r\nrc = -EPERM;\r\ngoto job_error;\r\n} else if (ext_buf_cnt > 1) {\r\nfor (i = 1; i < ext_buf_cnt; i++) {\r\next_dmabuf = lpfc_bsg_dma_page_alloc(phba);\r\nif (!ext_dmabuf) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\nlist_add_tail(&ext_dmabuf->list,\r\n&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\n}\r\n}\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\nlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, 0, dmabuf, dmabuf);\r\nif (ext_buf_cnt > 1) {\r\next_buf_index = 1;\r\nlist_for_each_entry_safe(curr_dmabuf, next_dmabuf,\r\n&phba->mbox_ext_buf_ctx.ext_dmabuf_list, list) {\r\nlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp,\r\next_buf_index, dmabuf,\r\ncurr_dmabuf);\r\next_buf_index++;\r\n}\r\n}\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_rd, dma_mbox,\r\nsta_pos_addr, dmabuf, ext_buf_cnt);\r\npmb = &pmboxq->u.mb;\r\npmbx = (uint8_t *)dmabuf->virt;\r\nmemcpy(pmb, pmbx, sizeof(*pmb));\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->vport = phba->pport;\r\nphba->mbox_ext_buf_ctx.nembType = nemb_tp;\r\nphba->mbox_ext_buf_ctx.mboxType = mbox_rd;\r\nphba->mbox_ext_buf_ctx.numBuf = ext_buf_cnt;\r\nphba->mbox_ext_buf_ctx.mbxTag = mbox_req->extMboxTag;\r\nphba->mbox_ext_buf_ctx.seqNum = mbox_req->extSeqNum;\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf = dmabuf;\r\npmboxq->mbox_cmpl = lpfc_bsg_issue_read_mbox_ext_cmpl;\r\npmboxq->context1 = dd_data;\r\ndd_data->type = TYPE_MBOX;\r\ndd_data->set_job = job;\r\ndd_data->context_un.mbox.pmboxq = pmboxq;\r\ndd_data->context_un.mbox.mb = (MAILBOX_t *)pmbx;\r\njob->dd_data = dd_data;\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\r\nif ((!bsg_bf_get(lpfc_mbox_hdr_emb,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) &&\r\n(nemb_tp == nemb_mse))\r\nlpfc_sli_pcimem_bcopy(&pmbx[sizeof(MAILBOX_t)],\r\n&pmbx[sizeof(MAILBOX_t)],\r\nsli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[0].buf_len);\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\r\nif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2947 Issued SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nreturn SLI_CONFIG_HANDLED;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2948 Failed to issue SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nrc = -EPIPE;\r\njob_error:\r\nif (pmboxq)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nlpfc_bsg_dma_page_list_free(phba,\r\n&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\nkfree(dd_data);\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_IDLE;\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_sli_cfg_write_cmd_ext(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nenum nemb_type nemb_tp,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct dfc_mbox_req *mbox_req;\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nuint32_t ext_buf_cnt;\r\nstruct bsg_job_data *dd_data = NULL;\r\nLPFC_MBOXQ_t *pmboxq = NULL;\r\nMAILBOX_t *pmb;\r\nuint8_t *mbx;\r\nint rc = SLI_CONFIG_NOT_HANDLED, i;\r\nmbox_req =\r\n(struct dfc_mbox_req *)job->request->rqst_data.h_vendor.vendor_cmd;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\r\nif (nemb_tp == nemb_mse) {\r\next_buf_cnt = bsg_bf_get(lpfc_mbox_hdr_mse_cnt,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr);\r\nif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_MSE) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2953 Failed SLI_CONFIG(mse) wr, "\r\n"ext_buf_cnt(%d) out of range(%d)\n",\r\next_buf_cnt,\r\nLPFC_MBX_SLI_CONFIG_MAX_MSE);\r\nreturn -ERANGE;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2949 Handled SLI_CONFIG(mse) wr, "\r\n"ext_buf_cnt:%d\n", ext_buf_cnt);\r\n} else {\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2)\r\nreturn -ENODEV;\r\next_buf_cnt = sli_cfg_mbx->un.sli_config_emb1_subsys.hbd_count;\r\nif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_HBD) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2954 Failed SLI_CONFIG(hbd) wr, "\r\n"ext_buf_cnt(%d) out of range(%d)\n",\r\next_buf_cnt,\r\nLPFC_MBX_SLI_CONFIG_MAX_HBD);\r\nreturn -ERANGE;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2950 Handled SLI_CONFIG(hbd) wr, "\r\n"ext_buf_cnt:%d\n", ext_buf_cnt);\r\n}\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_wr, dma_mbox,\r\nsta_pre_addr, dmabuf, ext_buf_cnt);\r\nif (ext_buf_cnt == 0)\r\nreturn -EPERM;\r\nlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, 0, dmabuf, dmabuf);\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_wr, dma_mbox,\r\nsta_pos_addr, dmabuf, ext_buf_cnt);\r\nfor (i = 1; i < ext_buf_cnt; i++) {\r\nif (nemb_tp == nemb_mse)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2951 SLI_CONFIG(mse), buf[%d]-length:%d\n",\r\ni, sli_cfg_mbx->un.sli_config_emb0_subsys.\r\nmse[i].buf_len);\r\nelse\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2952 SLI_CONFIG(hbd), buf[%d]-length:%d\n",\r\ni, bsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\r\n&sli_cfg_mbx->un.sli_config_emb1_subsys.\r\nhbd[i]));\r\n}\r\nphba->mbox_ext_buf_ctx.nembType = nemb_tp;\r\nphba->mbox_ext_buf_ctx.mboxType = mbox_wr;\r\nphba->mbox_ext_buf_ctx.numBuf = ext_buf_cnt;\r\nphba->mbox_ext_buf_ctx.mbxTag = mbox_req->extMboxTag;\r\nphba->mbox_ext_buf_ctx.seqNum = mbox_req->extSeqNum;\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf = dmabuf;\r\nif (ext_buf_cnt == 1) {\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npmb = &pmboxq->u.mb;\r\nmbx = (uint8_t *)dmabuf->virt;\r\nmemcpy(pmb, mbx, sizeof(*pmb));\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->vport = phba->pport;\r\npmboxq->mbox_cmpl = lpfc_bsg_issue_write_mbox_ext_cmpl;\r\npmboxq->context1 = dd_data;\r\ndd_data->type = TYPE_MBOX;\r\ndd_data->set_job = job;\r\ndd_data->context_un.mbox.pmboxq = pmboxq;\r\ndd_data->context_un.mbox.mb = (MAILBOX_t *)mbx;\r\njob->dd_data = dd_data;\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\r\nif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2955 Issued SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nreturn SLI_CONFIG_HANDLED;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2956 Failed to issue SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nrc = -EPIPE;\r\ngoto job_error;\r\n}\r\njob->reply->result = 0;\r\njob->job_done(job);\r\nreturn SLI_CONFIG_HANDLED;\r\njob_error:\r\nif (pmboxq)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nkfree(dd_data);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_handle_sli_cfg_mbox(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nuint32_t subsys;\r\nuint32_t opcode;\r\nint rc = SLI_CONFIG_NOT_HANDLED;\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_HOST;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\r\nif (!bsg_bf_get(lpfc_mbox_hdr_emb,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) {\r\nsubsys = bsg_bf_get(lpfc_emb0_subcmnd_subsys,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys);\r\nopcode = bsg_bf_get(lpfc_emb0_subcmnd_opcode,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys);\r\nif (subsys == SLI_CONFIG_SUBSYS_FCOE) {\r\nswitch (opcode) {\r\ncase FCOE_OPCODE_READ_FCF:\r\ncase FCOE_OPCODE_GET_DPORT_RESULTS:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2957 Handled SLI_CONFIG "\r\n"subsys_fcoe, opcode:x%x\n",\r\nopcode);\r\nrc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\r\nnemb_mse, dmabuf);\r\nbreak;\r\ncase FCOE_OPCODE_ADD_FCF:\r\ncase FCOE_OPCODE_SET_DPORT_MODE:\r\ncase LPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2958 Handled SLI_CONFIG "\r\n"subsys_fcoe, opcode:x%x\n",\r\nopcode);\r\nrc = lpfc_bsg_sli_cfg_write_cmd_ext(phba, job,\r\nnemb_mse, dmabuf);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2959 Reject SLI_CONFIG "\r\n"subsys_fcoe, opcode:x%x\n",\r\nopcode);\r\nrc = -EPERM;\r\nbreak;\r\n}\r\n} else if (subsys == SLI_CONFIG_SUBSYS_COMN) {\r\nswitch (opcode) {\r\ncase COMN_OPCODE_GET_CNTL_ADDL_ATTRIBUTES:\r\ncase COMN_OPCODE_GET_CNTL_ATTRIBUTES:\r\ncase COMN_OPCODE_GET_PROFILE_CONFIG:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3106 Handled SLI_CONFIG "\r\n"subsys_comn, opcode:x%x\n",\r\nopcode);\r\nrc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\r\nnemb_mse, dmabuf);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"3107 Reject SLI_CONFIG "\r\n"subsys_comn, opcode:x%x\n",\r\nopcode);\r\nrc = -EPERM;\r\nbreak;\r\n}\r\n} else {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2977 Reject SLI_CONFIG "\r\n"subsys:x%d, opcode:x%x\n",\r\nsubsys, opcode);\r\nrc = -EPERM;\r\n}\r\n} else {\r\nsubsys = bsg_bf_get(lpfc_emb1_subcmnd_subsys,\r\n&sli_cfg_mbx->un.sli_config_emb1_subsys);\r\nopcode = bsg_bf_get(lpfc_emb1_subcmnd_opcode,\r\n&sli_cfg_mbx->un.sli_config_emb1_subsys);\r\nif (subsys == SLI_CONFIG_SUBSYS_COMN) {\r\nswitch (opcode) {\r\ncase COMN_OPCODE_READ_OBJECT:\r\ncase COMN_OPCODE_READ_OBJECT_LIST:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2960 Handled SLI_CONFIG "\r\n"subsys_comn, opcode:x%x\n",\r\nopcode);\r\nrc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\r\nnemb_hbd, dmabuf);\r\nbreak;\r\ncase COMN_OPCODE_WRITE_OBJECT:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2961 Handled SLI_CONFIG "\r\n"subsys_comn, opcode:x%x\n",\r\nopcode);\r\nrc = lpfc_bsg_sli_cfg_write_cmd_ext(phba, job,\r\nnemb_hbd, dmabuf);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2962 Not handled SLI_CONFIG "\r\n"subsys_comn, opcode:x%x\n",\r\nopcode);\r\nrc = SLI_CONFIG_NOT_HANDLED;\r\nbreak;\r\n}\r\n} else {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2978 Not handled SLI_CONFIG "\r\n"subsys:x%d, opcode:x%x\n",\r\nsubsys, opcode);\r\nrc = SLI_CONFIG_NOT_HANDLED;\r\n}\r\n}\r\nif (rc != SLI_CONFIG_HANDLED)\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_IDLE;\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_bsg_mbox_ext_abort(struct lpfc_hba *phba)\r\n{\r\nif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_PORT)\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_ABTS;\r\nelse\r\nlpfc_bsg_mbox_ext_session_reset(phba);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_bsg_read_ebuf_get(struct lpfc_hba *phba, struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nstruct lpfc_dmabuf *dmabuf;\r\nuint8_t *pbuf;\r\nuint32_t size;\r\nuint32_t index;\r\nindex = phba->mbox_ext_buf_ctx.seqNum;\r\nphba->mbox_ext_buf_ctx.seqNum++;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf->virt;\r\nif (phba->mbox_ext_buf_ctx.nembType == nemb_mse) {\r\nsize = bsg_bf_get(lpfc_mbox_sli_config_mse_len,\r\n&sli_cfg_mbx->un.sli_config_emb0_subsys.mse[index]);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2963 SLI_CONFIG (mse) ext-buffer rd get "\r\n"buffer[%d], size:%d\n", index, size);\r\n} else {\r\nsize = bsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\r\n&sli_cfg_mbx->un.sli_config_emb1_subsys.hbd[index]);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2964 SLI_CONFIG (hbd) ext-buffer rd get "\r\n"buffer[%d], size:%d\n", index, size);\r\n}\r\nif (list_empty(&phba->mbox_ext_buf_ctx.ext_dmabuf_list))\r\nreturn -EPIPE;\r\ndmabuf = list_first_entry(&phba->mbox_ext_buf_ctx.ext_dmabuf_list,\r\nstruct lpfc_dmabuf, list);\r\nlist_del_init(&dmabuf->list);\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, phba->mbox_ext_buf_ctx.nembType,\r\nmbox_rd, dma_ebuf, sta_pos_addr,\r\ndmabuf, index);\r\npbuf = (uint8_t *)dmabuf->virt;\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\npbuf, size);\r\nlpfc_bsg_dma_page_free(phba, dmabuf);\r\nif (phba->mbox_ext_buf_ctx.seqNum == phba->mbox_ext_buf_ctx.numBuf) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2965 SLI_CONFIG (hbd) ext-buffer rd mbox "\r\n"command session done\n");\r\nlpfc_bsg_mbox_ext_session_reset(phba);\r\n}\r\njob->reply->result = 0;\r\njob->job_done(job);\r\nreturn SLI_CONFIG_HANDLED;\r\n}\r\nstatic int\r\nlpfc_bsg_write_ebuf_set(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct lpfc_sli_config_mbox *sli_cfg_mbx;\r\nstruct bsg_job_data *dd_data = NULL;\r\nLPFC_MBOXQ_t *pmboxq = NULL;\r\nMAILBOX_t *pmb;\r\nenum nemb_type nemb_tp;\r\nuint8_t *pbuf;\r\nuint32_t size;\r\nuint32_t index;\r\nint rc;\r\nindex = phba->mbox_ext_buf_ctx.seqNum;\r\nphba->mbox_ext_buf_ctx.seqNum++;\r\nnemb_tp = phba->mbox_ext_buf_ctx.nembType;\r\nsli_cfg_mbx = (struct lpfc_sli_config_mbox *)\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf->virt;\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\npbuf = (uint8_t *)dmabuf->virt;\r\nsize = job->request_payload.payload_len;\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\npbuf, size);\r\nif (phba->mbox_ext_buf_ctx.nembType == nemb_mse) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2966 SLI_CONFIG (mse) ext-buffer wr set "\r\n"buffer[%d], size:%d\n",\r\nphba->mbox_ext_buf_ctx.seqNum, size);\r\n} else {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2967 SLI_CONFIG (hbd) ext-buffer wr set "\r\n"buffer[%d], size:%d\n",\r\nphba->mbox_ext_buf_ctx.seqNum, size);\r\n}\r\nlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, index,\r\nphba->mbox_ext_buf_ctx.mbx_dmabuf,\r\ndmabuf);\r\nlist_add_tail(&dmabuf->list, &phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\nlpfc_idiag_mbxacc_dump_bsg_mbox(phba, phba->mbox_ext_buf_ctx.nembType,\r\nmbox_wr, dma_ebuf, sta_pos_addr,\r\ndmabuf, index);\r\nif (phba->mbox_ext_buf_ctx.seqNum == phba->mbox_ext_buf_ctx.numBuf) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2968 SLI_CONFIG ext-buffer wr all %d "\r\n"ebuffers received\n",\r\nphba->mbox_ext_buf_ctx.numBuf);\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto job_error;\r\n}\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npbuf = (uint8_t *)phba->mbox_ext_buf_ctx.mbx_dmabuf->virt;\r\npmb = &pmboxq->u.mb;\r\nmemcpy(pmb, pbuf, sizeof(*pmb));\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->vport = phba->pport;\r\npmboxq->mbox_cmpl = lpfc_bsg_issue_write_mbox_ext_cmpl;\r\npmboxq->context1 = dd_data;\r\ndd_data->type = TYPE_MBOX;\r\ndd_data->set_job = job;\r\ndd_data->context_un.mbox.pmboxq = pmboxq;\r\ndd_data->context_un.mbox.mb = (MAILBOX_t *)pbuf;\r\njob->dd_data = dd_data;\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\r\nif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2969 Issued SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nreturn SLI_CONFIG_HANDLED;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2970 Failed to issue SLI_CONFIG ext-buffer "\r\n"maibox command, rc:x%x\n", rc);\r\nrc = -EPIPE;\r\ngoto job_error;\r\n}\r\njob->reply->result = 0;\r\njob->job_done(job);\r\nreturn SLI_CONFIG_HANDLED;\r\njob_error:\r\nlpfc_bsg_dma_page_free(phba, dmabuf);\r\nkfree(dd_data);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_handle_sli_cfg_ebuf(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nint rc;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2971 SLI_CONFIG buffer (type:x%x)\n",\r\nphba->mbox_ext_buf_ctx.mboxType);\r\nif (phba->mbox_ext_buf_ctx.mboxType == mbox_rd) {\r\nif (phba->mbox_ext_buf_ctx.state != LPFC_BSG_MBOX_DONE) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2972 SLI_CONFIG rd buffer state "\r\n"mismatch:x%x\n",\r\nphba->mbox_ext_buf_ctx.state);\r\nlpfc_bsg_mbox_ext_abort(phba);\r\nreturn -EPIPE;\r\n}\r\nrc = lpfc_bsg_read_ebuf_get(phba, job);\r\nif (rc == SLI_CONFIG_HANDLED)\r\nlpfc_bsg_dma_page_free(phba, dmabuf);\r\n} else {\r\nif (phba->mbox_ext_buf_ctx.state != LPFC_BSG_MBOX_HOST) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2973 SLI_CONFIG wr buffer state "\r\n"mismatch:x%x\n",\r\nphba->mbox_ext_buf_ctx.state);\r\nlpfc_bsg_mbox_ext_abort(phba);\r\nreturn -EPIPE;\r\n}\r\nrc = lpfc_bsg_write_ebuf_set(phba, job, dmabuf);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_handle_sli_cfg_ext(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nstruct lpfc_dmabuf *dmabuf)\r\n{\r\nstruct dfc_mbox_req *mbox_req;\r\nint rc = SLI_CONFIG_NOT_HANDLED;\r\nmbox_req =\r\n(struct dfc_mbox_req *)job->request->rqst_data.h_vendor.vendor_cmd;\r\nif (mbox_req->extMboxTag == 0 && mbox_req->extSeqNum == 0)\r\nreturn rc;\r\nif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_IDLE) {\r\nif (mbox_req->extSeqNum == 1) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2974 SLI_CONFIG mailbox: tag:%d, "\r\n"seq:%d\n", mbox_req->extMboxTag,\r\nmbox_req->extSeqNum);\r\nrc = lpfc_bsg_handle_sli_cfg_mbox(phba, job, dmabuf);\r\nreturn rc;\r\n} else\r\ngoto sli_cfg_ext_error;\r\n}\r\nif (mbox_req->extMboxTag != phba->mbox_ext_buf_ctx.mbxTag)\r\ngoto sli_cfg_ext_error;\r\nif (mbox_req->extSeqNum > phba->mbox_ext_buf_ctx.numBuf)\r\ngoto sli_cfg_ext_error;\r\nif (mbox_req->extSeqNum != phba->mbox_ext_buf_ctx.seqNum + 1)\r\ngoto sli_cfg_ext_error;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2975 SLI_CONFIG mailbox external buffer: "\r\n"extSta:x%x, tag:%d, seq:%d\n",\r\nphba->mbox_ext_buf_ctx.state, mbox_req->extMboxTag,\r\nmbox_req->extSeqNum);\r\nrc = lpfc_bsg_handle_sli_cfg_ebuf(phba, job, dmabuf);\r\nreturn rc;\r\nsli_cfg_ext_error:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\r\n"2976 SLI_CONFIG mailbox broken pipe: "\r\n"ctxSta:x%x, ctxNumBuf:%d "\r\n"ctxTag:%d, ctxSeq:%d, tag:%d, seq:%d\n",\r\nphba->mbox_ext_buf_ctx.state,\r\nphba->mbox_ext_buf_ctx.numBuf,\r\nphba->mbox_ext_buf_ctx.mbxTag,\r\nphba->mbox_ext_buf_ctx.seqNum,\r\nmbox_req->extMboxTag, mbox_req->extSeqNum);\r\nlpfc_bsg_mbox_ext_session_reset(phba);\r\nreturn -EPIPE;\r\n}\r\nstatic int\r\nlpfc_bsg_issue_mbox(struct lpfc_hba *phba, struct fc_bsg_job *job,\r\nstruct lpfc_vport *vport)\r\n{\r\nLPFC_MBOXQ_t *pmboxq = NULL;\r\nMAILBOX_t *pmb;\r\nuint8_t *pmbx = NULL;\r\nstruct bsg_job_data *dd_data = NULL;\r\nstruct lpfc_dmabuf *dmabuf = NULL;\r\nstruct dfc_mbox_req *mbox_req;\r\nstruct READ_EVENT_LOG_VAR *rdEventLog;\r\nuint32_t transmit_length, receive_length, mode;\r\nstruct lpfc_mbx_sli4_config *sli4_config;\r\nstruct lpfc_mbx_nembed_cmd *nembed_sge;\r\nstruct mbox_header *header;\r\nstruct ulp_bde64 *bde;\r\nuint8_t *ext = NULL;\r\nint rc = 0;\r\nuint8_t *from;\r\nuint32_t size;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->reply_payload.payload_len > BSG_MBOX_SIZE ||\r\njob->request_payload.payload_len > BSG_MBOX_SIZE) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\nif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) {\r\nrc = -EAGAIN;\r\ngoto job_done;\r\n}\r\nmbox_req =\r\n(struct dfc_mbox_req *)job->request->rqst_data.h_vendor.vendor_cmd;\r\nif ((mbox_req->inExtWLen > BSG_MBOX_SIZE/sizeof(uint32_t)) ||\r\n(mbox_req->outExtWLen > BSG_MBOX_SIZE/sizeof(uint32_t))) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\ndmabuf = lpfc_bsg_dma_page_alloc(phba);\r\nif (!dmabuf || !dmabuf->virt) {\r\nrc = -ENOMEM;\r\ngoto job_done;\r\n}\r\npmbx = (uint8_t *)dmabuf->virt;\r\nsize = job->request_payload.payload_len;\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt, pmbx, size);\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nrc = lpfc_bsg_handle_sli_cfg_ext(phba, job, dmabuf);\r\nif (rc == SLI_CONFIG_HANDLED)\r\ngoto job_cont;\r\nif (rc)\r\ngoto job_done;\r\n}\r\nrc = lpfc_bsg_check_cmd_access(phba, (MAILBOX_t *)pmbx, vport);\r\nif (rc != 0)\r\ngoto job_done;\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2727 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto job_done;\r\n}\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq) {\r\nrc = -ENOMEM;\r\ngoto job_done;\r\n}\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npmb = &pmboxq->u.mb;\r\nmemcpy(pmb, pmbx, sizeof(*pmb));\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->vport = vport;\r\nif (phba->pport->stopped &&\r\npmb->mbxCommand != MBX_DUMP_MEMORY &&\r\npmb->mbxCommand != MBX_RESTART &&\r\npmb->mbxCommand != MBX_WRITE_VPARMS &&\r\npmb->mbxCommand != MBX_WRITE_WWN)\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\r\n"2797 mbox: Issued mailbox cmd "\r\n"0x%x while in stopped state.\n",\r\npmb->mbxCommand);\r\nif (mbox_req->inExtWLen || mbox_req->outExtWLen) {\r\nfrom = pmbx;\r\next = from + sizeof(MAILBOX_t);\r\npmboxq->context2 = ext;\r\npmboxq->in_ext_byte_len =\r\nmbox_req->inExtWLen * sizeof(uint32_t);\r\npmboxq->out_ext_byte_len =\r\nmbox_req->outExtWLen * sizeof(uint32_t);\r\npmboxq->mbox_offset_word = mbox_req->mbOffset;\r\n}\r\nif (pmb->mbxCommand == MBX_RUN_BIU_DIAG64) {\r\ntransmit_length = pmb->un.varWords[1];\r\nreceive_length = pmb->un.varWords[4];\r\nif ((transmit_length > receive_length) ||\r\n(transmit_length > BSG_MBOX_SIZE - sizeof(MAILBOX_t))) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\npmb->un.varBIUdiag.un.s2.xmit_bde64.addrHigh =\r\nputPaddrHigh(dmabuf->phys + sizeof(MAILBOX_t));\r\npmb->un.varBIUdiag.un.s2.xmit_bde64.addrLow =\r\nputPaddrLow(dmabuf->phys + sizeof(MAILBOX_t));\r\npmb->un.varBIUdiag.un.s2.rcv_bde64.addrHigh =\r\nputPaddrHigh(dmabuf->phys + sizeof(MAILBOX_t)\r\n+ pmb->un.varBIUdiag.un.s2.xmit_bde64.tus.f.bdeSize);\r\npmb->un.varBIUdiag.un.s2.rcv_bde64.addrLow =\r\nputPaddrLow(dmabuf->phys + sizeof(MAILBOX_t)\r\n+ pmb->un.varBIUdiag.un.s2.xmit_bde64.tus.f.bdeSize);\r\n} else if (pmb->mbxCommand == MBX_READ_EVENT_LOG) {\r\nrdEventLog = &pmb->un.varRdEventLog;\r\nreceive_length = rdEventLog->rcv_bde64.tus.f.bdeSize;\r\nmode = bf_get(lpfc_event_log, rdEventLog);\r\nif (receive_length > BSG_MBOX_SIZE - sizeof(MAILBOX_t)) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\nif (mode == 0) {\r\npmb->un.varWords[3] = putPaddrLow(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\npmb->un.varWords[4] = putPaddrHigh(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\n}\r\n} else if (phba->sli_rev == LPFC_SLI_REV4) {\r\nif ((pmb->mbxCommand == MBX_DUMP_MEMORY) &&\r\n(pmb->un.varDmp.type != DMP_WELL_KNOWN)) {\r\nreceive_length = pmb->un.varWords[2];\r\nif (receive_length == 0) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\npmb->un.varWords[3] = putPaddrLow(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\npmb->un.varWords[4] = putPaddrHigh(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\n} else if ((pmb->mbxCommand == MBX_UPDATE_CFG) &&\r\npmb->un.varUpdateCfg.co) {\r\nbde = (struct ulp_bde64 *)&pmb->un.varWords[4];\r\nif (bde->tus.f.bdeSize >\r\nBSG_MBOX_SIZE - sizeof(MAILBOX_t)) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\nbde->addrHigh = putPaddrHigh(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\nbde->addrLow = putPaddrLow(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\n} else if (pmb->mbxCommand == MBX_SLI4_CONFIG) {\r\nsli4_config = &pmboxq->u.mqe.un.sli4_config;\r\nif (!bf_get(lpfc_mbox_hdr_emb,\r\n&sli4_config->header.cfg_mhdr)) {\r\nheader = (struct mbox_header *)\r\n&pmb->un.varWords[0];\r\nnembed_sge = (struct lpfc_mbx_nembed_cmd *)\r\n&pmb->un.varWords[0];\r\nreceive_length = nembed_sge->sge[0].length;\r\nif ((receive_length == 0) ||\r\n(receive_length >\r\nBSG_MBOX_SIZE - sizeof(MAILBOX_t))) {\r\nrc = -ERANGE;\r\ngoto job_done;\r\n}\r\nnembed_sge->sge[0].pa_hi =\r\nputPaddrHigh(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\nnembed_sge->sge[0].pa_lo =\r\nputPaddrLow(dmabuf->phys\r\n+ sizeof(MAILBOX_t));\r\n}\r\n}\r\n}\r\ndd_data->context_un.mbox.dmabuffers = dmabuf;\r\npmboxq->mbox_cmpl = lpfc_bsg_issue_mbox_cmpl;\r\npmboxq->context1 = dd_data;\r\ndd_data->type = TYPE_MBOX;\r\ndd_data->set_job = job;\r\ndd_data->context_un.mbox.pmboxq = pmboxq;\r\ndd_data->context_un.mbox.mb = (MAILBOX_t *)pmbx;\r\ndd_data->context_un.mbox.ext = ext;\r\ndd_data->context_un.mbox.mbOffset = mbox_req->mbOffset;\r\ndd_data->context_un.mbox.inExtWLen = mbox_req->inExtWLen;\r\ndd_data->context_un.mbox.outExtWLen = mbox_req->outExtWLen;\r\njob->dd_data = dd_data;\r\nif ((vport->fc_flag & FC_OFFLINE_MODE) ||\r\n(!(phba->sli.sli_flag & LPFC_SLI_ACTIVE))) {\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nrc = (rc == MBX_TIMEOUT) ? -ETIME : -ENODEV;\r\ngoto job_done;\r\n}\r\nmemcpy(pmbx, pmb, sizeof(*pmb));\r\njob->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt,\r\npmbx, size);\r\nrc = 0;\r\ngoto job_done;\r\n}\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\r\nif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY))\r\nreturn 1;\r\njob_done:\r\nif (pmboxq)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nlpfc_bsg_dma_page_free(phba, dmabuf);\r\nkfree(dd_data);\r\njob_cont:\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_mbox_cmd(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct dfc_mbox_req *mbox_req;\r\nint rc = 0;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct dfc_mbox_req)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\r\n"2737 Mix-and-match backward compatibility "\r\n"between MBOX_REQ old size:%d and "\r\n"new request size:%d\n",\r\n(int)(job->request_len -\r\nsizeof(struct fc_bsg_request)),\r\n(int)sizeof(struct dfc_mbox_req));\r\nmbox_req = (struct dfc_mbox_req *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nmbox_req->extMboxTag = 0;\r\nmbox_req->extSeqNum = 0;\r\n}\r\nrc = lpfc_bsg_issue_mbox(phba, job, vport);\r\nif (rc == 0) {\r\njob->reply->result = 0;\r\njob->dd_data = NULL;\r\njob->job_done(job);\r\n} else if (rc == 1)\r\nrc = 0;\r\nelse {\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_bsg_menlo_cmd_cmp(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbq,\r\nstruct lpfc_iocbq *rspiocbq)\r\n{\r\nstruct bsg_job_data *dd_data;\r\nstruct fc_bsg_job *job;\r\nIOCB_t *rsp;\r\nstruct lpfc_dmabuf *bmp, *cmp, *rmp;\r\nstruct lpfc_bsg_menlo *menlo;\r\nunsigned long flags;\r\nstruct menlo_response *menlo_resp;\r\nunsigned int rsp_size;\r\nint rc = 0;\r\ndd_data = cmdiocbq->context1;\r\ncmp = cmdiocbq->context2;\r\nbmp = cmdiocbq->context3;\r\nmenlo = &dd_data->context_un.menlo;\r\nrmp = menlo->rmp;\r\nrsp = &rspiocbq->iocb;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\njob = dd_data->set_job;\r\nif (job) {\r\njob->dd_data = NULL;\r\n}\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nif (job) {\r\nmenlo_resp = (struct menlo_response *)\r\njob->reply->reply_data.vendor_reply.vendor_rsp;\r\nmenlo_resp->xri = rsp->ulpContext;\r\nif (rsp->ulpStatus) {\r\nif (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch (rsp->un.ulpWord[4] & IOERR_PARAM_MASK) {\r\ncase IOERR_SEQUENCE_TIMEOUT:\r\nrc = -ETIMEDOUT;\r\nbreak;\r\ncase IOERR_INVALID_RPI:\r\nrc = -EFAULT;\r\nbreak;\r\ndefault:\r\nrc = -EACCES;\r\nbreak;\r\n}\r\n} else {\r\nrc = -EACCES;\r\n}\r\n} else {\r\nrsp_size = rsp->un.genreq64.bdl.bdeSize;\r\njob->reply->reply_payload_rcv_len =\r\nlpfc_bsg_copy_data(rmp, &job->reply_payload,\r\nrsp_size, 0);\r\n}\r\n}\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nlpfc_free_bsg_buffers(phba, rmp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nkfree(dd_data);\r\nif (job) {\r\njob->reply->result = rc;\r\njob->job_done(job);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_menlo_cmd(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocbq;\r\nIOCB_t *cmd;\r\nint rc = 0;\r\nstruct menlo_command *menlo_cmd;\r\nstruct menlo_response *menlo_resp;\r\nstruct lpfc_dmabuf *bmp = NULL, *cmp = NULL, *rmp = NULL;\r\nint request_nseg;\r\nint reply_nseg;\r\nstruct bsg_job_data *dd_data;\r\nstruct ulp_bde64 *bpl = NULL;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (job->request_len <\r\nsizeof(struct fc_bsg_request) +\r\nsizeof(struct menlo_command)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2784 Received MENLO_CMD request below "\r\n"minimum size\n");\r\nrc = -ERANGE;\r\ngoto no_dd_data;\r\n}\r\nif (job->reply_len <\r\nsizeof(struct fc_bsg_request) + sizeof(struct menlo_response)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2785 Received MENLO_CMD reply below "\r\n"minimum size\n");\r\nrc = -ERANGE;\r\ngoto no_dd_data;\r\n}\r\nif (!(phba->menlo_flag & HBA_MENLO_SUPPORT)) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2786 Adapter does not support menlo "\r\n"commands\n");\r\nrc = -EPERM;\r\ngoto no_dd_data;\r\n}\r\nmenlo_cmd = (struct menlo_command *)\r\njob->request->rqst_data.h_vendor.vendor_cmd;\r\nmenlo_resp = (struct menlo_response *)\r\njob->reply->reply_data.vendor_reply.vendor_rsp;\r\ndd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\r\nif (!dd_data) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\r\n"2787 Failed allocation of dd_data\n");\r\nrc = -ENOMEM;\r\ngoto no_dd_data;\r\n}\r\nbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp) {\r\nrc = -ENOMEM;\r\ngoto free_dd;\r\n}\r\nbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\r\nif (!bmp->virt) {\r\nrc = -ENOMEM;\r\ngoto free_bmp;\r\n}\r\nINIT_LIST_HEAD(&bmp->list);\r\nbpl = (struct ulp_bde64 *)bmp->virt;\r\nrequest_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64);\r\ncmp = lpfc_alloc_bsg_buffers(phba, job->request_payload.payload_len,\r\n1, bpl, &request_nseg);\r\nif (!cmp) {\r\nrc = -ENOMEM;\r\ngoto free_bmp;\r\n}\r\nlpfc_bsg_copy_data(cmp, &job->request_payload,\r\njob->request_payload.payload_len, 1);\r\nbpl += request_nseg;\r\nreply_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64) - request_nseg;\r\nrmp = lpfc_alloc_bsg_buffers(phba, job->reply_payload.payload_len, 0,\r\nbpl, &reply_nseg);\r\nif (!rmp) {\r\nrc = -ENOMEM;\r\ngoto free_cmp;\r\n}\r\ncmdiocbq = lpfc_sli_get_iocbq(phba);\r\nif (!cmdiocbq) {\r\nrc = -ENOMEM;\r\ngoto free_rmp;\r\n}\r\ncmd = &cmdiocbq->iocb;\r\ncmd->un.genreq64.bdl.ulpIoTag32 = 0;\r\ncmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);\r\ncmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);\r\ncmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\ncmd->un.genreq64.bdl.bdeSize =\r\n(request_nseg + reply_nseg) * sizeof(struct ulp_bde64);\r\ncmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);\r\ncmd->un.genreq64.w5.hcsw.Dfctl = 0;\r\ncmd->un.genreq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CMD;\r\ncmd->un.genreq64.w5.hcsw.Type = MENLO_TRANSPORT_TYPE;\r\ncmd->ulpBdeCount = 1;\r\ncmd->ulpClass = CLASS3;\r\ncmd->ulpOwner = OWN_CHIP;\r\ncmd->ulpLe = 1;\r\ncmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;\r\ncmdiocbq->vport = phba->pport;\r\ncmd->ulpTimeout = MENLO_TIMEOUT - 5;\r\ncmdiocbq->iocb_cmpl = lpfc_bsg_menlo_cmd_cmp;\r\ncmdiocbq->context1 = dd_data;\r\ncmdiocbq->context2 = cmp;\r\ncmdiocbq->context3 = bmp;\r\nif (menlo_cmd->cmd == LPFC_BSG_VENDOR_MENLO_CMD) {\r\ncmd->ulpCommand = CMD_GEN_REQUEST64_CR;\r\ncmd->ulpPU = MENLO_PU;\r\ncmd->un.ulpWord[4] = MENLO_DID;\r\ncmd->ulpContext = MENLO_CONTEXT;\r\n} else {\r\ncmd->ulpCommand = CMD_GEN_REQUEST64_CX;\r\ncmd->ulpPU = 1;\r\ncmd->un.ulpWord[4] = 0;\r\ncmd->ulpContext = menlo_cmd->xri;\r\n}\r\ndd_data->type = TYPE_MENLO;\r\ndd_data->set_job = job;\r\ndd_data->context_un.menlo.cmdiocbq = cmdiocbq;\r\ndd_data->context_un.menlo.rmp = rmp;\r\njob->dd_data = dd_data;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq,\r\nMENLO_TIMEOUT - 5);\r\nif (rc == IOCB_SUCCESS)\r\nreturn 0;\r\nlpfc_sli_release_iocbq(phba, cmdiocbq);\r\nfree_rmp:\r\nlpfc_free_bsg_buffers(phba, rmp);\r\nfree_cmp:\r\nlpfc_free_bsg_buffers(phba, cmp);\r\nfree_bmp:\r\nif (bmp->virt)\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nkfree(bmp);\r\nfree_dd:\r\nkfree(dd_data);\r\nno_dd_data:\r\njob->reply->result = rc;\r\njob->dd_data = NULL;\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_bsg_hst_vendor(struct fc_bsg_job *job)\r\n{\r\nint command = job->request->rqst_data.h_vendor.vendor_cmd[0];\r\nint rc;\r\nswitch (command) {\r\ncase LPFC_BSG_VENDOR_SET_CT_EVENT:\r\nrc = lpfc_bsg_hba_set_event(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_GET_CT_EVENT:\r\nrc = lpfc_bsg_hba_get_event(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_SEND_MGMT_RESP:\r\nrc = lpfc_bsg_send_mgmt_rsp(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_DIAG_MODE:\r\nrc = lpfc_bsg_diag_loopback_mode(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_DIAG_MODE_END:\r\nrc = lpfc_sli4_bsg_diag_mode_end(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_DIAG_RUN_LOOPBACK:\r\nrc = lpfc_bsg_diag_loopback_run(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_LINK_DIAG_TEST:\r\nrc = lpfc_sli4_bsg_link_diag_test(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_GET_MGMT_REV:\r\nrc = lpfc_bsg_get_dfc_rev(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_MBOX:\r\nrc = lpfc_bsg_mbox_cmd(job);\r\nbreak;\r\ncase LPFC_BSG_VENDOR_MENLO_CMD:\r\ncase LPFC_BSG_VENDOR_MENLO_DATA:\r\nrc = lpfc_menlo_cmd(job);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\njob->reply->reply_payload_rcv_len = 0;\r\njob->reply->result = rc;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nlpfc_bsg_request(struct fc_bsg_job *job)\r\n{\r\nuint32_t msgcode;\r\nint rc;\r\nmsgcode = job->request->msgcode;\r\nswitch (msgcode) {\r\ncase FC_BSG_HST_VENDOR:\r\nrc = lpfc_bsg_hst_vendor(job);\r\nbreak;\r\ncase FC_BSG_RPT_ELS:\r\nrc = lpfc_bsg_rport_els(job);\r\nbreak;\r\ncase FC_BSG_RPT_CT:\r\nrc = lpfc_bsg_send_mgmt_cmd(job);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\njob->reply->reply_payload_rcv_len = 0;\r\njob->reply->result = rc;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nlpfc_bsg_timeout(struct fc_bsg_job *job)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *cmdiocb;\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nstruct bsg_job_data *dd_data;\r\nunsigned long flags;\r\nint rc = 0;\r\nLIST_HEAD(completions);\r\nstruct lpfc_iocbq *check_iocb, *next_iocb;\r\nspin_lock_irqsave(&phba->ct_ev_lock, flags);\r\ndd_data = (struct bsg_job_data *)job->dd_data;\r\nif (dd_data) {\r\ndd_data->set_job = NULL;\r\njob->dd_data = NULL;\r\n} else {\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nswitch (dd_data->type) {\r\ncase TYPE_IOCB:\r\ncmdiocb = dd_data->context_un.iocb.cmdiocbq;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (!(cmdiocb->iocb_flag & LPFC_IO_CMD_OUTSTANDING)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn -EAGAIN;\r\n}\r\nlist_for_each_entry_safe(check_iocb, next_iocb, &pring->txq,\r\nlist) {\r\nif (check_iocb == cmdiocb) {\r\nlist_move_tail(&check_iocb->list, &completions);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&completions))\r\nlpfc_sli_issue_abort_iotag(phba, pring, cmdiocb);\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nif (!list_empty(&completions)) {\r\nlpfc_sli_cancel_iocbs(phba, &completions,\r\nIOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\n}\r\nbreak;\r\ncase TYPE_EVT:\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nbreak;\r\ncase TYPE_MBOX:\r\nif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_PORT)\r\nphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_ABTS;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nbreak;\r\ncase TYPE_MENLO:\r\ncmdiocb = dd_data->context_un.menlo.cmdiocbq;\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlist_for_each_entry_safe(check_iocb, next_iocb, &pring->txq,\r\nlist) {\r\nif (check_iocb == cmdiocb) {\r\nlist_move_tail(&check_iocb->list, &completions);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&completions))\r\nlpfc_sli_issue_abort_iotag(phba, pring, cmdiocb);\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nif (!list_empty(&completions)) {\r\nlpfc_sli_cancel_iocbs(phba, &completions,\r\nIOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\n}\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\r\nbreak;\r\n}\r\nreturn rc;\r\n}
