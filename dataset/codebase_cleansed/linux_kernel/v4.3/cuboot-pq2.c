static void update_cs_ranges(void)\r\n{\r\nvoid *bus_node, *parent_node;\r\nu32 *ctrl_addr;\r\nunsigned long ctrl_size;\r\nu32 naddr, nsize;\r\nint len;\r\nint i;\r\nbus_node = finddevice("/localbus");\r\nif (!bus_node || !dt_is_compatible(bus_node, "fsl,pq2-localbus"))\r\nreturn;\r\ndt_get_reg_format(bus_node, &naddr, &nsize);\r\nif (naddr != 2 || nsize != 1)\r\ngoto err;\r\nparent_node = get_parent(bus_node);\r\nif (!parent_node)\r\ngoto err;\r\ndt_get_reg_format(parent_node, &naddr, &nsize);\r\nif (naddr != 1 || nsize != 1)\r\ngoto err;\r\nif (!dt_xlate_reg(bus_node, 0, (unsigned long *)&ctrl_addr,\r\n&ctrl_size))\r\ngoto err;\r\nlen = getprop(bus_node, "ranges", cs_ranges_buf, sizeof(cs_ranges_buf));\r\nfor (i = 0; i < len / sizeof(struct cs_range); i++) {\r\nu32 base, option;\r\nint cs = cs_ranges_buf[i].csnum;\r\nif (cs >= ctrl_size / 8)\r\ngoto err;\r\nif (cs_ranges_buf[i].base != 0)\r\ngoto err;\r\nbase = in_be32(&ctrl_addr[cs * 2]);\r\nif (base & 1) {\r\nbase &= 0x7fff;\r\noption = in_be32(&ctrl_addr[cs * 2 + 1]) & 0x7fff;\r\n} else {\r\nbase = 0x1801;\r\noption = 0x10;\r\n}\r\nout_be32(&ctrl_addr[cs * 2], 0);\r\nout_be32(&ctrl_addr[cs * 2 + 1],\r\noption | ~(cs_ranges_buf[i].size - 1));\r\nout_be32(&ctrl_addr[cs * 2], base | cs_ranges_buf[i].addr);\r\n}\r\nreturn;\r\nerr:\r\nprintf("Bad /localbus node\r\n");\r\n}\r\nstatic void fixup_pci(void)\r\n{\r\nstruct pci_range *mem = NULL, *mmio = NULL,\r\n*io = NULL, *mem_base = NULL;\r\nu32 *pci_regs[3];\r\nu8 *soc_regs;\r\nint i, len;\r\nvoid *node, *parent_node;\r\nu32 naddr, nsize, mem_pow2, mem_mask;\r\nnode = finddevice("/pci");\r\nif (!node || !dt_is_compatible(node, "fsl,pq2-pci"))\r\nreturn;\r\nfor (i = 0; i < 3; i++)\r\nif (!dt_xlate_reg(node, i,\r\n(unsigned long *)&pci_regs[i], NULL))\r\ngoto err;\r\nsoc_regs = (u8 *)fsl_get_immr();\r\nif (!soc_regs)\r\ngoto unhandled;\r\ndt_get_reg_format(node, &naddr, &nsize);\r\nif (naddr != 3 || nsize != 2)\r\ngoto err;\r\nparent_node = get_parent(node);\r\nif (!parent_node)\r\ngoto err;\r\ndt_get_reg_format(parent_node, &naddr, &nsize);\r\nif (naddr != 1 || nsize != 1)\r\ngoto unhandled;\r\nlen = getprop(node, "ranges", pci_ranges_buf,\r\nsizeof(pci_ranges_buf));\r\nfor (i = 0; i < len / sizeof(struct pci_range); i++) {\r\nu32 flags = pci_ranges_buf[i].flags & 0x43000000;\r\nif (flags == 0x42000000)\r\nmem = &pci_ranges_buf[i];\r\nelse if (flags == 0x02000000)\r\nmmio = &pci_ranges_buf[i];\r\nelse if (flags == 0x01000000)\r\nio = &pci_ranges_buf[i];\r\n}\r\nif (!mem || !mmio || !io)\r\ngoto unhandled;\r\nif (mem->size[1] != mmio->size[1])\r\ngoto unhandled;\r\nif (mem->size[1] & (mem->size[1] - 1))\r\ngoto unhandled;\r\nif (io->size[1] & (io->size[1] - 1))\r\ngoto unhandled;\r\nif (mem->phys_addr + mem->size[1] == mmio->phys_addr)\r\nmem_base = mem;\r\nelse if (mmio->phys_addr + mmio->size[1] == mem->phys_addr)\r\nmem_base = mmio;\r\nelse\r\ngoto unhandled;\r\nout_be32(&pci_regs[1][0], mem_base->phys_addr | 1);\r\nout_be32(&pci_regs[2][0], ~(mem->size[1] + mmio->size[1] - 1));\r\nout_be32(&pci_regs[1][1], io->phys_addr | 1);\r\nout_be32(&pci_regs[2][1], ~(io->size[1] - 1));\r\nout_le32(&pci_regs[0][0], mem->pci_addr[1] >> 12);\r\nout_le32(&pci_regs[0][2], mem->phys_addr >> 12);\r\nout_le32(&pci_regs[0][4], (~(mem->size[1] - 1) >> 12) | 0xa0000000);\r\nout_le32(&pci_regs[0][6], mmio->pci_addr[1] >> 12);\r\nout_le32(&pci_regs[0][8], mmio->phys_addr >> 12);\r\nout_le32(&pci_regs[0][10], (~(mmio->size[1] - 1) >> 12) | 0x80000000);\r\nout_le32(&pci_regs[0][12], io->pci_addr[1] >> 12);\r\nout_le32(&pci_regs[0][14], io->phys_addr >> 12);\r\nout_le32(&pci_regs[0][16], (~(io->size[1] - 1) >> 12) | 0xc0000000);\r\nout_le32(&pci_regs[0][58], 0);\r\nout_le32(&pci_regs[0][60], 0);\r\nmem_pow2 = 1 << (__ilog2_u32(bd.bi_memsize - 1) + 1);\r\nmem_mask = ~(mem_pow2 - 1) >> 12;\r\nout_le32(&pci_regs[0][62], 0xa0000000 | mem_mask);\r\nif (!(in_le32(&pci_regs[0][32]) & 1)) {\r\nudelay(100000);\r\nout_le32(&pci_regs[0][32], 1);\r\nudelay(1020000);\r\n}\r\nout_le32(&pci_regs[0][64], 0x80000004);\r\nout_le32(&pci_regs[0][65], in_le32(&pci_regs[0][65]) | 6);\r\nout_8(&soc_regs[0x10028], 3);\r\nout_be32((u32 *)&soc_regs[0x1002c], 0x01236745);\r\nreturn;\r\nerr:\r\nprintf("Bad PCI node -- using existing firmware setup.\r\n");\r\nreturn;\r\nunhandled:\r\nprintf("Unsupported PCI node -- using existing firmware setup.\r\n");\r\n}\r\nstatic void pq2_platform_fixups(void)\r\n{\r\nvoid *node;\r\ndt_fixup_memory(bd.bi_memstart, bd.bi_memsize);\r\ndt_fixup_mac_addresses(bd.bi_enetaddr, bd.bi_enet1addr);\r\ndt_fixup_cpu_clocks(bd.bi_intfreq, bd.bi_busfreq / 4, bd.bi_busfreq);\r\nnode = finddevice("/soc/cpm");\r\nif (node)\r\nsetprop(node, "clock-frequency", &bd.bi_cpmfreq, 4);\r\nnode = finddevice("/soc/cpm/brg");\r\nif (node)\r\nsetprop(node, "clock-frequency", &bd.bi_brgfreq, 4);\r\nupdate_cs_ranges();\r\nfixup_pci();\r\n}\r\nvoid platform_init(unsigned long r3, unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7)\r\n{\r\nCUBOOT_INIT();\r\nfdt_init(_dtb_start);\r\nserial_console_init();\r\nplatform_ops.fixups = pq2_platform_fixups;\r\n}
