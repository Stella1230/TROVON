static void dbg_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct dbg_led *led = container_of(cdev, struct dbg_led, cdev);\r\nu16 reg;\r\nreg = readw_relaxed(&fpga->leds);\r\nif (b != LED_OFF)\r\nreg |= led->mask;\r\nelse\r\nreg &= ~led->mask;\r\nwritew_relaxed(reg, &fpga->leds);\r\n}\r\nstatic enum led_brightness dbg_led_get(struct led_classdev *cdev)\r\n{\r\nstruct dbg_led *led = container_of(cdev, struct dbg_led, cdev);\r\nu16 reg;\r\nreg = readw_relaxed(&fpga->leds);\r\nreturn (reg & led->mask) ? LED_FULL : LED_OFF;\r\n}\r\nstatic int fpga_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *iomem;\r\nint i;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem)\r\nreturn -ENODEV;\r\nfpga = ioremap(iomem->start, resource_size(iomem));\r\nwritew_relaxed(0xff, &fpga->leds);\r\nfor (i = 0; i < ARRAY_SIZE(dbg_leds); i++) {\r\nstruct dbg_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = dbg_leds[i].name;\r\nled->cdev.brightness_set = dbg_led_set;\r\nled->cdev.brightness_get = dbg_led_get;\r\nled->cdev.default_trigger = dbg_leds[i].trigger;\r\nled->mask = BIT(i);\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_suspend_noirq(struct device *dev)\r\n{\r\nfpga_led_state = readw_relaxed(&fpga->leds);\r\nwritew_relaxed(0xff, &fpga->leds);\r\nreturn 0;\r\n}\r\nstatic int fpga_resume_noirq(struct device *dev)\r\n{\r\nwritew_relaxed(~fpga_led_state, &fpga->leds);\r\nreturn 0;\r\n}\r\nstatic int __init fpga_init(void)\r\n{\r\nif (machine_is_omap_h4()\r\n|| machine_is_omap_h3()\r\n|| machine_is_omap_h2()\r\n|| machine_is_omap_perseus2()\r\n)\r\nreturn platform_driver_register(&led_driver);\r\nreturn 0;\r\n}
