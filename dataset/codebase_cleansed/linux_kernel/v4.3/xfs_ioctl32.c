STATIC int\r\nxfs_compat_flock64_copyin(\r\nxfs_flock64_t *bf,\r\ncompat_xfs_flock64_t __user *arg32)\r\n{\r\nif (get_user(bf->l_type, &arg32->l_type) ||\r\nget_user(bf->l_whence, &arg32->l_whence) ||\r\nget_user(bf->l_start, &arg32->l_start) ||\r\nget_user(bf->l_len, &arg32->l_len) ||\r\nget_user(bf->l_sysid, &arg32->l_sysid) ||\r\nget_user(bf->l_pid, &arg32->l_pid) ||\r\ncopy_from_user(bf->l_pad, &arg32->l_pad, 4*sizeof(u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_compat_ioc_fsgeometry_v1(\r\nstruct xfs_mount *mp,\r\ncompat_xfs_fsop_geom_v1_t __user *arg32)\r\n{\r\nxfs_fsop_geom_t fsgeo;\r\nint error;\r\nerror = xfs_fs_geometry(mp, &fsgeo, 3);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_compat_growfs_data_copyin(\r\nstruct xfs_growfs_data *in,\r\ncompat_xfs_growfs_data_t __user *arg32)\r\n{\r\nif (get_user(in->newblocks, &arg32->newblocks) ||\r\nget_user(in->imaxpct, &arg32->imaxpct))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_compat_growfs_rt_copyin(\r\nstruct xfs_growfs_rt *in,\r\ncompat_xfs_growfs_rt_t __user *arg32)\r\n{\r\nif (get_user(in->newblocks, &arg32->newblocks) ||\r\nget_user(in->extsize, &arg32->extsize))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_inumbers_fmt_compat(\r\nvoid __user *ubuffer,\r\nconst struct xfs_inogrp *buffer,\r\nlong count,\r\nlong *written)\r\n{\r\ncompat_xfs_inogrp_t __user *p32 = ubuffer;\r\nlong i;\r\nfor (i = 0; i < count; i++) {\r\nif (put_user(buffer[i].xi_startino, &p32[i].xi_startino) ||\r\nput_user(buffer[i].xi_alloccount, &p32[i].xi_alloccount) ||\r\nput_user(buffer[i].xi_allocmask, &p32[i].xi_allocmask))\r\nreturn -EFAULT;\r\n}\r\n*written = count * sizeof(*p32);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioctl32_bstime_copyin(\r\nxfs_bstime_t *bstime,\r\ncompat_xfs_bstime_t __user *bstime32)\r\n{\r\ncompat_time_t sec32;\r\nif (get_user(sec32, &bstime32->tv_sec) ||\r\nget_user(bstime->tv_nsec, &bstime32->tv_nsec))\r\nreturn -EFAULT;\r\nbstime->tv_sec = sec32;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioctl32_bstat_copyin(\r\nxfs_bstat_t *bstat,\r\ncompat_xfs_bstat_t __user *bstat32)\r\n{\r\nif (get_user(bstat->bs_ino, &bstat32->bs_ino) ||\r\nget_user(bstat->bs_mode, &bstat32->bs_mode) ||\r\nget_user(bstat->bs_nlink, &bstat32->bs_nlink) ||\r\nget_user(bstat->bs_uid, &bstat32->bs_uid) ||\r\nget_user(bstat->bs_gid, &bstat32->bs_gid) ||\r\nget_user(bstat->bs_rdev, &bstat32->bs_rdev) ||\r\nget_user(bstat->bs_blksize, &bstat32->bs_blksize) ||\r\nget_user(bstat->bs_size, &bstat32->bs_size) ||\r\nxfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\r\nxfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\r\nxfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\r\nget_user(bstat->bs_blocks, &bstat32->bs_size) ||\r\nget_user(bstat->bs_xflags, &bstat32->bs_size) ||\r\nget_user(bstat->bs_extsize, &bstat32->bs_extsize) ||\r\nget_user(bstat->bs_extents, &bstat32->bs_extents) ||\r\nget_user(bstat->bs_gen, &bstat32->bs_gen) ||\r\nget_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\r\nget_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\r\nget_user(bstat->bs_forkoff, &bstat32->bs_forkoff) ||\r\nget_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask) ||\r\nget_user(bstat->bs_dmstate, &bstat32->bs_dmstate) ||\r\nget_user(bstat->bs_aextents, &bstat32->bs_aextents))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_bstime_store_compat(\r\ncompat_xfs_bstime_t __user *p32,\r\nconst xfs_bstime_t *p)\r\n{\r\n__s32 sec32;\r\nsec32 = p->tv_sec;\r\nif (put_user(sec32, &p32->tv_sec) ||\r\nput_user(p->tv_nsec, &p32->tv_nsec))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_bulkstat_one_fmt_compat(\r\nvoid __user *ubuffer,\r\nint ubsize,\r\nint *ubused,\r\nconst xfs_bstat_t *buffer)\r\n{\r\ncompat_xfs_bstat_t __user *p32 = ubuffer;\r\nif (ubsize < sizeof(*p32))\r\nreturn -ENOMEM;\r\nif (put_user(buffer->bs_ino, &p32->bs_ino) ||\r\nput_user(buffer->bs_mode, &p32->bs_mode) ||\r\nput_user(buffer->bs_nlink, &p32->bs_nlink) ||\r\nput_user(buffer->bs_uid, &p32->bs_uid) ||\r\nput_user(buffer->bs_gid, &p32->bs_gid) ||\r\nput_user(buffer->bs_rdev, &p32->bs_rdev) ||\r\nput_user(buffer->bs_blksize, &p32->bs_blksize) ||\r\nput_user(buffer->bs_size, &p32->bs_size) ||\r\nxfs_bstime_store_compat(&p32->bs_atime, &buffer->bs_atime) ||\r\nxfs_bstime_store_compat(&p32->bs_mtime, &buffer->bs_mtime) ||\r\nxfs_bstime_store_compat(&p32->bs_ctime, &buffer->bs_ctime) ||\r\nput_user(buffer->bs_blocks, &p32->bs_blocks) ||\r\nput_user(buffer->bs_xflags, &p32->bs_xflags) ||\r\nput_user(buffer->bs_extsize, &p32->bs_extsize) ||\r\nput_user(buffer->bs_extents, &p32->bs_extents) ||\r\nput_user(buffer->bs_gen, &p32->bs_gen) ||\r\nput_user(buffer->bs_projid, &p32->bs_projid) ||\r\nput_user(buffer->bs_projid_hi, &p32->bs_projid_hi) ||\r\nput_user(buffer->bs_forkoff, &p32->bs_forkoff) ||\r\nput_user(buffer->bs_dmevmask, &p32->bs_dmevmask) ||\r\nput_user(buffer->bs_dmstate, &p32->bs_dmstate) ||\r\nput_user(buffer->bs_aextents, &p32->bs_aextents))\r\nreturn -EFAULT;\r\nif (ubused)\r\n*ubused = sizeof(*p32);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_bulkstat_one_compat(\r\nxfs_mount_t *mp,\r\nxfs_ino_t ino,\r\nvoid __user *buffer,\r\nint ubsize,\r\nint *ubused,\r\nint *stat)\r\n{\r\nreturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\r\nxfs_bulkstat_one_fmt_compat,\r\nubused, stat);\r\n}\r\nSTATIC int\r\nxfs_compat_ioc_bulkstat(\r\nxfs_mount_t *mp,\r\nunsigned int cmd,\r\ncompat_xfs_fsop_bulkreq_t __user *p32)\r\n{\r\nu32 addr;\r\nxfs_fsop_bulkreq_t bulkreq;\r\nint count;\r\nxfs_ino_t inlast;\r\nint done;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nif (get_user(addr, &p32->lastip))\r\nreturn -EFAULT;\r\nbulkreq.lastip = compat_ptr(addr);\r\nif (get_user(bulkreq.icount, &p32->icount) ||\r\nget_user(addr, &p32->ubuffer))\r\nreturn -EFAULT;\r\nbulkreq.ubuffer = compat_ptr(addr);\r\nif (get_user(addr, &p32->ocount))\r\nreturn -EFAULT;\r\nbulkreq.ocount = compat_ptr(addr);\r\nif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\r\nreturn -EFAULT;\r\nif ((count = bulkreq.icount) <= 0)\r\nreturn -EINVAL;\r\nif (bulkreq.ubuffer == NULL)\r\nreturn -EINVAL;\r\nif (cmd == XFS_IOC_FSINUMBERS_32) {\r\nerror = xfs_inumbers(mp, &inlast, &count,\r\nbulkreq.ubuffer, xfs_inumbers_fmt_compat);\r\n} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\r\nint res;\r\nerror = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,\r\nsizeof(compat_xfs_bstat_t), NULL, &res);\r\n} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\r\nerror = xfs_bulkstat(mp, &inlast, &count,\r\nxfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),\r\nbulkreq.ubuffer, &done);\r\n} else\r\nerror = -EINVAL;\r\nif (error)\r\nreturn error;\r\nif (bulkreq.ocount != NULL) {\r\nif (copy_to_user(bulkreq.lastip, &inlast,\r\nsizeof(xfs_ino_t)))\r\nreturn -EFAULT;\r\nif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_compat_handlereq_copyin(\r\nxfs_fsop_handlereq_t *hreq,\r\ncompat_xfs_fsop_handlereq_t __user *arg32)\r\n{\r\ncompat_xfs_fsop_handlereq_t hreq32;\r\nif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\r\nreturn -EFAULT;\r\nhreq->fd = hreq32.fd;\r\nhreq->path = compat_ptr(hreq32.path);\r\nhreq->oflags = hreq32.oflags;\r\nhreq->ihandle = compat_ptr(hreq32.ihandle);\r\nhreq->ihandlen = hreq32.ihandlen;\r\nhreq->ohandle = compat_ptr(hreq32.ohandle);\r\nhreq->ohandlen = compat_ptr(hreq32.ohandlen);\r\nreturn 0;\r\n}\r\nSTATIC struct dentry *\r\nxfs_compat_handlereq_to_dentry(\r\nstruct file *parfilp,\r\ncompat_xfs_fsop_handlereq_t *hreq)\r\n{\r\nreturn xfs_handle_to_dentry(parfilp,\r\ncompat_ptr(hreq->ihandle), hreq->ihandlen);\r\n}\r\nSTATIC int\r\nxfs_compat_attrlist_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error;\r\nattrlist_cursor_kern_t *cursor;\r\ncompat_xfs_fsop_attrlist_handlereq_t al_hreq;\r\nstruct dentry *dentry;\r\nchar *kbuf;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&al_hreq, arg,\r\nsizeof(compat_xfs_fsop_attrlist_handlereq_t)))\r\nreturn -EFAULT;\r\nif (al_hreq.buflen < sizeof(struct attrlist) ||\r\nal_hreq.buflen > XATTR_LIST_MAX)\r\nreturn -EINVAL;\r\nif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\r\nreturn -EINVAL;\r\ndentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nerror = -ENOMEM;\r\nkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\r\nif (!kbuf)\r\ngoto out_dput;\r\ncursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\r\nerror = xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,\r\nal_hreq.flags, cursor);\r\nif (error)\r\ngoto out_kfree;\r\nif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\r\nerror = -EFAULT;\r\nout_kfree:\r\nkmem_free(kbuf);\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_compat_attrmulti_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error;\r\ncompat_xfs_attr_multiop_t *ops;\r\ncompat_xfs_fsop_attrmulti_handlereq_t am_hreq;\r\nstruct dentry *dentry;\r\nunsigned int i, size;\r\nunsigned char *attr_name;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&am_hreq, arg,\r\nsizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\r\nreturn -EFAULT;\r\nif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\r\nreturn -E2BIG;\r\ndentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nerror = -E2BIG;\r\nsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\r\nif (!size || size > 16 * PAGE_SIZE)\r\ngoto out_dput;\r\nops = memdup_user(compat_ptr(am_hreq.ops), size);\r\nif (IS_ERR(ops)) {\r\nerror = PTR_ERR(ops);\r\ngoto out_dput;\r\n}\r\nerror = -ENOMEM;\r\nattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\r\nif (!attr_name)\r\ngoto out_kfree_ops;\r\nerror = 0;\r\nfor (i = 0; i < am_hreq.opcount; i++) {\r\nops[i].am_error = strncpy_from_user((char *)attr_name,\r\ncompat_ptr(ops[i].am_attrname),\r\nMAXNAMELEN);\r\nif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\r\nerror = -ERANGE;\r\nif (ops[i].am_error < 0)\r\nbreak;\r\nswitch (ops[i].am_opcode) {\r\ncase ATTR_OP_GET:\r\nops[i].am_error = xfs_attrmulti_attr_get(\r\nd_inode(dentry), attr_name,\r\ncompat_ptr(ops[i].am_attrvalue),\r\n&ops[i].am_length, ops[i].am_flags);\r\nbreak;\r\ncase ATTR_OP_SET:\r\nops[i].am_error = mnt_want_write_file(parfilp);\r\nif (ops[i].am_error)\r\nbreak;\r\nops[i].am_error = xfs_attrmulti_attr_set(\r\nd_inode(dentry), attr_name,\r\ncompat_ptr(ops[i].am_attrvalue),\r\nops[i].am_length, ops[i].am_flags);\r\nmnt_drop_write_file(parfilp);\r\nbreak;\r\ncase ATTR_OP_REMOVE:\r\nops[i].am_error = mnt_want_write_file(parfilp);\r\nif (ops[i].am_error)\r\nbreak;\r\nops[i].am_error = xfs_attrmulti_attr_remove(\r\nd_inode(dentry), attr_name,\r\nops[i].am_flags);\r\nmnt_drop_write_file(parfilp);\r\nbreak;\r\ndefault:\r\nops[i].am_error = -EINVAL;\r\n}\r\n}\r\nif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\r\nerror = -EFAULT;\r\nkfree(attr_name);\r\nout_kfree_ops:\r\nkfree(ops);\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_compat_fssetdm_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error;\r\nstruct fsdmidata fsd;\r\ncompat_xfs_fsop_setdm_handlereq_t dmhreq;\r\nstruct dentry *dentry;\r\nif (!capable(CAP_MKNOD))\r\nreturn -EPERM;\r\nif (copy_from_user(&dmhreq, arg,\r\nsizeof(compat_xfs_fsop_setdm_handlereq_t)))\r\nreturn -EFAULT;\r\ndentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nif (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {\r\nerror = -EPERM;\r\ngoto out;\r\n}\r\nif (copy_from_user(&fsd, compat_ptr(dmhreq.data), sizeof(fsd))) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\nerror = xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,\r\nfsd.fsd_dmstate);\r\nout:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nlong\r\nxfs_file_compat_ioctl(\r\nstruct file *filp,\r\nunsigned cmd,\r\nunsigned long p)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nvoid __user *arg = (void __user *)p;\r\nint ioflags = 0;\r\nint error;\r\nif (filp->f_mode & FMODE_NOCMTIME)\r\nioflags |= XFS_IO_INVIS;\r\ntrace_xfs_file_compat_ioctl(ip);\r\nswitch (cmd) {\r\ncase XFS_IOC_DIOINFO:\r\ncase XFS_IOC_FSGEOMETRY:\r\ncase XFS_IOC_FSGETXATTR:\r\ncase XFS_IOC_FSSETXATTR:\r\ncase XFS_IOC_FSGETXATTRA:\r\ncase XFS_IOC_FSSETDM:\r\ncase XFS_IOC_GETBMAP:\r\ncase XFS_IOC_GETBMAPA:\r\ncase XFS_IOC_GETBMAPX:\r\ncase XFS_IOC_FSCOUNTS:\r\ncase XFS_IOC_SET_RESBLKS:\r\ncase XFS_IOC_GET_RESBLKS:\r\ncase XFS_IOC_FSGROWFSLOG:\r\ncase XFS_IOC_GOINGDOWN:\r\ncase XFS_IOC_ERROR_INJECTION:\r\ncase XFS_IOC_ERROR_CLEARALL:\r\nreturn xfs_file_ioctl(filp, cmd, p);\r\n#ifndef BROKEN_X86_ALIGNMENT\r\ncase XFS_IOC_ALLOCSP:\r\ncase XFS_IOC_FREESP:\r\ncase XFS_IOC_RESVSP:\r\ncase XFS_IOC_UNRESVSP:\r\ncase XFS_IOC_ALLOCSP64:\r\ncase XFS_IOC_FREESP64:\r\ncase XFS_IOC_RESVSP64:\r\ncase XFS_IOC_UNRESVSP64:\r\ncase XFS_IOC_FSGEOMETRY_V1:\r\ncase XFS_IOC_FSGROWFSDATA:\r\ncase XFS_IOC_FSGROWFSRT:\r\ncase XFS_IOC_ZERO_RANGE:\r\nreturn xfs_file_ioctl(filp, cmd, p);\r\n#else\r\ncase XFS_IOC_ALLOCSP_32:\r\ncase XFS_IOC_FREESP_32:\r\ncase XFS_IOC_ALLOCSP64_32:\r\ncase XFS_IOC_FREESP64_32:\r\ncase XFS_IOC_RESVSP_32:\r\ncase XFS_IOC_UNRESVSP_32:\r\ncase XFS_IOC_RESVSP64_32:\r\ncase XFS_IOC_UNRESVSP64_32:\r\ncase XFS_IOC_ZERO_RANGE_32: {\r\nstruct xfs_flock64 bf;\r\nif (xfs_compat_flock64_copyin(&bf, arg))\r\nreturn -EFAULT;\r\ncmd = _NATIVE_IOC(cmd, struct xfs_flock64);\r\nreturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\r\n}\r\ncase XFS_IOC_FSGEOMETRY_V1_32:\r\nreturn xfs_compat_ioc_fsgeometry_v1(mp, arg);\r\ncase XFS_IOC_FSGROWFSDATA_32: {\r\nstruct xfs_growfs_data in;\r\nif (xfs_compat_growfs_data_copyin(&in, arg))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_growfs_data(mp, &in);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_FSGROWFSRT_32: {\r\nstruct xfs_growfs_rt in;\r\nif (xfs_compat_growfs_rt_copyin(&in, arg))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_growfs_rt(mp, &in);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\n#endif\r\ncase XFS_IOC_GETXFLAGS_32:\r\ncase XFS_IOC_SETXFLAGS_32:\r\ncase XFS_IOC_GETVERSION_32:\r\ncmd = _NATIVE_IOC(cmd, long);\r\nreturn xfs_file_ioctl(filp, cmd, p);\r\ncase XFS_IOC_SWAPEXT_32: {\r\nstruct xfs_swapext sxp;\r\nstruct compat_xfs_swapext __user *sxu = arg;\r\nif (copy_from_user(&sxp, sxu,\r\noffsetof(struct xfs_swapext, sx_stat)) ||\r\nxfs_ioctl32_bstat_copyin(&sxp.sx_stat, &sxu->sx_stat))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_ioc_swapext(&sxp);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_FSBULKSTAT_32:\r\ncase XFS_IOC_FSBULKSTAT_SINGLE_32:\r\ncase XFS_IOC_FSINUMBERS_32:\r\nreturn xfs_compat_ioc_bulkstat(mp, cmd, arg);\r\ncase XFS_IOC_FD_TO_HANDLE_32:\r\ncase XFS_IOC_PATH_TO_HANDLE_32:\r\ncase XFS_IOC_PATH_TO_FSHANDLE_32: {\r\nstruct xfs_fsop_handlereq hreq;\r\nif (xfs_compat_handlereq_copyin(&hreq, arg))\r\nreturn -EFAULT;\r\ncmd = _NATIVE_IOC(cmd, struct xfs_fsop_handlereq);\r\nreturn xfs_find_handle(cmd, &hreq);\r\n}\r\ncase XFS_IOC_OPEN_BY_HANDLE_32: {\r\nstruct xfs_fsop_handlereq hreq;\r\nif (xfs_compat_handlereq_copyin(&hreq, arg))\r\nreturn -EFAULT;\r\nreturn xfs_open_by_handle(filp, &hreq);\r\n}\r\ncase XFS_IOC_READLINK_BY_HANDLE_32: {\r\nstruct xfs_fsop_handlereq hreq;\r\nif (xfs_compat_handlereq_copyin(&hreq, arg))\r\nreturn -EFAULT;\r\nreturn xfs_readlink_by_handle(filp, &hreq);\r\n}\r\ncase XFS_IOC_ATTRLIST_BY_HANDLE_32:\r\nreturn xfs_compat_attrlist_by_handle(filp, arg);\r\ncase XFS_IOC_ATTRMULTI_BY_HANDLE_32:\r\nreturn xfs_compat_attrmulti_by_handle(filp, arg);\r\ncase XFS_IOC_FSSETDM_BY_HANDLE_32:\r\nreturn xfs_compat_fssetdm_by_handle(filp, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}
