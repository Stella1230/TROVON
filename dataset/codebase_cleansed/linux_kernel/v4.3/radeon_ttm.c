static struct radeon_device *radeon_get_rdev(struct ttm_bo_device *bdev)\r\n{\r\nstruct radeon_mman *mman;\r\nstruct radeon_device *rdev;\r\nmman = container_of(bdev, struct radeon_mman, bdev);\r\nrdev = container_of(mman, struct radeon_device, mman);\r\nreturn rdev;\r\n}\r\nstatic int radeon_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void radeon_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nstatic int radeon_ttm_global_init(struct radeon_device *rdev)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint r;\r\nrdev->mman.mem_global_referenced = false;\r\nglobal_ref = &rdev->mman.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &radeon_ttm_mem_global_init;\r\nglobal_ref->release = &radeon_ttm_mem_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM memory accounting "\r\n"subsystem.\n");\r\nreturn r;\r\n}\r\nrdev->mman.bo_global_ref.mem_glob =\r\nrdev->mman.mem_global_ref.object;\r\nglobal_ref = &rdev->mman.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem.\n");\r\ndrm_global_item_unref(&rdev->mman.mem_global_ref);\r\nreturn r;\r\n}\r\nrdev->mman.mem_global_referenced = true;\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_global_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->mman.mem_global_referenced) {\r\ndrm_global_item_unref(&rdev->mman.bo_global_ref.ref);\r\ndrm_global_item_unref(&rdev->mman.mem_global_ref);\r\nrdev->mman.mem_global_referenced = false;\r\n}\r\n}\r\nstatic int radeon_invalidate_caches(struct ttm_bo_device *bdev, uint32_t flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radeon_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,\r\nstruct ttm_mem_type_manager *man)\r\n{\r\nstruct radeon_device *rdev;\r\nrdev = radeon_get_rdev(bdev);\r\nswitch (type) {\r\ncase TTM_PL_SYSTEM:\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ncase TTM_PL_TT:\r\nman->func = &ttm_bo_manager_func;\r\nman->gpu_offset = rdev->mc.gtt_start;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE | TTM_MEMTYPE_FLAG_CMA;\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nif (!rdev->ddev->agp) {\r\nDRM_ERROR("AGP is not enabled for memory type %u\n",\r\n(unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nif (!rdev->ddev->agp->cant_use_aperture)\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\n}\r\n#endif\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nman->func = &ttm_bo_manager_func;\r\nman->gpu_offset = rdev->mc.vram_start;\r\nman->flags = TTM_MEMTYPE_FLAG_FIXED |\r\nTTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported memory type %u\n", (unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_evict_flags(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement)\r\n{\r\nstatic struct ttm_place placements = {\r\n.fpfn = 0,\r\n.lpfn = 0,\r\n.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM\r\n};\r\nstruct radeon_bo *rbo;\r\nif (!radeon_ttm_bo_is_radeon_bo(bo)) {\r\nplacement->placement = &placements;\r\nplacement->busy_placement = &placements;\r\nplacement->num_placement = 1;\r\nplacement->num_busy_placement = 1;\r\nreturn;\r\n}\r\nrbo = container_of(bo, struct radeon_bo, tbo);\r\nswitch (bo->mem.mem_type) {\r\ncase TTM_PL_VRAM:\r\nif (rbo->rdev->ring[radeon_copy_ring_index(rbo->rdev)].ready == false)\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_CPU);\r\nelse if (rbo->rdev->mc.visible_vram_size < rbo->rdev->mc.real_vram_size &&\r\nbo->mem.start < (rbo->rdev->mc.visible_vram_size >> PAGE_SHIFT)) {\r\nunsigned fpfn = rbo->rdev->mc.visible_vram_size >> PAGE_SHIFT;\r\nint i;\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_VRAM |\r\nRADEON_GEM_DOMAIN_GTT);\r\nrbo->placement.num_busy_placement = 0;\r\nfor (i = 0; i < rbo->placement.num_placement; i++) {\r\nif (rbo->placements[i].flags & TTM_PL_FLAG_VRAM) {\r\nif (rbo->placements[0].fpfn < fpfn)\r\nrbo->placements[0].fpfn = fpfn;\r\n} else {\r\nrbo->placement.busy_placement =\r\n&rbo->placements[i];\r\nrbo->placement.num_busy_placement = 1;\r\n}\r\n}\r\n} else\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_GTT);\r\nbreak;\r\ncase TTM_PL_TT:\r\ndefault:\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_CPU);\r\n}\r\n*placement = rbo->placement;\r\n}\r\nstatic int radeon_verify_access(struct ttm_buffer_object *bo, struct file *filp)\r\n{\r\nstruct radeon_bo *rbo = container_of(bo, struct radeon_bo, tbo);\r\nreturn drm_vma_node_verify_access(&rbo->gem_base.vma_node, filp);\r\n}\r\nstatic void radeon_move_null(struct ttm_buffer_object *bo,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nBUG_ON(old_mem->mm_node != NULL);\r\n*old_mem = *new_mem;\r\nnew_mem->mm_node = NULL;\r\n}\r\nstatic int radeon_move_blit(struct ttm_buffer_object *bo,\r\nbool evict, bool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem,\r\nstruct ttm_mem_reg *old_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nuint64_t old_start, new_start;\r\nstruct radeon_fence *fence;\r\nunsigned num_pages;\r\nint r, ridx;\r\nrdev = radeon_get_rdev(bo->bdev);\r\nridx = radeon_copy_ring_index(rdev);\r\nold_start = old_mem->start << PAGE_SHIFT;\r\nnew_start = new_mem->start << PAGE_SHIFT;\r\nswitch (old_mem->mem_type) {\r\ncase TTM_PL_VRAM:\r\nold_start += rdev->mc.vram_start;\r\nbreak;\r\ncase TTM_PL_TT:\r\nold_start += rdev->mc.gtt_start;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown placement %d\n", old_mem->mem_type);\r\nreturn -EINVAL;\r\n}\r\nswitch (new_mem->mem_type) {\r\ncase TTM_PL_VRAM:\r\nnew_start += rdev->mc.vram_start;\r\nbreak;\r\ncase TTM_PL_TT:\r\nnew_start += rdev->mc.gtt_start;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown placement %d\n", old_mem->mem_type);\r\nreturn -EINVAL;\r\n}\r\nif (!rdev->ring[ridx].ready) {\r\nDRM_ERROR("Trying to move memory with ring turned off.\n");\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON((PAGE_SIZE % RADEON_GPU_PAGE_SIZE) != 0);\r\nnum_pages = new_mem->num_pages * (PAGE_SIZE / RADEON_GPU_PAGE_SIZE);\r\nfence = radeon_copy(rdev, old_start, new_start, num_pages, bo->resv);\r\nif (IS_ERR(fence))\r\nreturn PTR_ERR(fence);\r\nr = ttm_bo_move_accel_cleanup(bo, &fence->base,\r\nevict, no_wait_gpu, new_mem);\r\nradeon_fence_unref(&fence);\r\nreturn r;\r\n}\r\nstatic int radeon_move_vram_ram(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nstruct ttm_mem_reg tmp_mem;\r\nstruct ttm_place placements;\r\nstruct ttm_placement placement;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\ntmp_mem = *new_mem;\r\ntmp_mem.mm_node = NULL;\r\nplacement.num_placement = 1;\r\nplacement.placement = &placements;\r\nplacement.num_busy_placement = 1;\r\nplacement.busy_placement = &placements;\r\nplacements.fpfn = 0;\r\nplacements.lpfn = 0;\r\nplacements.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;\r\nr = ttm_bo_mem_space(bo, &placement, &tmp_mem,\r\ninterruptible, no_wait_gpu);\r\nif (unlikely(r)) {\r\nreturn r;\r\n}\r\nr = ttm_tt_set_placement_caching(bo->ttm, tmp_mem.placement);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = ttm_tt_bind(bo->ttm, &tmp_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = radeon_move_blit(bo, true, no_wait_gpu, &tmp_mem, old_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = ttm_bo_move_ttm(bo, true, no_wait_gpu, new_mem);\r\nout_cleanup:\r\nttm_bo_mem_put(bo, &tmp_mem);\r\nreturn r;\r\n}\r\nstatic int radeon_move_ram_vram(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nstruct ttm_mem_reg tmp_mem;\r\nstruct ttm_placement placement;\r\nstruct ttm_place placements;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\ntmp_mem = *new_mem;\r\ntmp_mem.mm_node = NULL;\r\nplacement.num_placement = 1;\r\nplacement.placement = &placements;\r\nplacement.num_busy_placement = 1;\r\nplacement.busy_placement = &placements;\r\nplacements.fpfn = 0;\r\nplacements.lpfn = 0;\r\nplacements.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;\r\nr = ttm_bo_mem_space(bo, &placement, &tmp_mem,\r\ninterruptible, no_wait_gpu);\r\nif (unlikely(r)) {\r\nreturn r;\r\n}\r\nr = ttm_bo_move_ttm(bo, true, no_wait_gpu, &tmp_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = radeon_move_blit(bo, true, no_wait_gpu, new_mem, old_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nout_cleanup:\r\nttm_bo_mem_put(bo, &tmp_mem);\r\nreturn r;\r\n}\r\nstatic int radeon_bo_move(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\nif (old_mem->mem_type == TTM_PL_SYSTEM && bo->ttm == NULL) {\r\nradeon_move_null(bo, new_mem);\r\nreturn 0;\r\n}\r\nif ((old_mem->mem_type == TTM_PL_TT &&\r\nnew_mem->mem_type == TTM_PL_SYSTEM) ||\r\n(old_mem->mem_type == TTM_PL_SYSTEM &&\r\nnew_mem->mem_type == TTM_PL_TT)) {\r\nradeon_move_null(bo, new_mem);\r\nreturn 0;\r\n}\r\nif (!rdev->ring[radeon_copy_ring_index(rdev)].ready ||\r\nrdev->asic->copy.copy == NULL) {\r\ngoto memcpy;\r\n}\r\nif (old_mem->mem_type == TTM_PL_VRAM &&\r\nnew_mem->mem_type == TTM_PL_SYSTEM) {\r\nr = radeon_move_vram_ram(bo, evict, interruptible,\r\nno_wait_gpu, new_mem);\r\n} else if (old_mem->mem_type == TTM_PL_SYSTEM &&\r\nnew_mem->mem_type == TTM_PL_VRAM) {\r\nr = radeon_move_ram_vram(bo, evict, interruptible,\r\nno_wait_gpu, new_mem);\r\n} else {\r\nr = radeon_move_blit(bo, evict, no_wait_gpu, new_mem, old_mem);\r\n}\r\nif (r) {\r\nmemcpy:\r\nr = ttm_bo_move_memcpy(bo, evict, no_wait_gpu, new_mem);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\natomic64_add((u64)bo->num_pages << PAGE_SHIFT, &rdev->num_bytes_moved);\r\nreturn 0;\r\n}\r\nstatic int radeon_ttm_io_mem_reserve(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nstruct radeon_device *rdev = radeon_get_rdev(bdev);\r\nmem->bus.addr = NULL;\r\nmem->bus.offset = 0;\r\nmem->bus.size = mem->num_pages << PAGE_SHIFT;\r\nmem->bus.base = 0;\r\nmem->bus.is_iomem = false;\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))\r\nreturn -EINVAL;\r\nswitch (mem->mem_type) {\r\ncase TTM_PL_SYSTEM:\r\nreturn 0;\r\ncase TTM_PL_TT:\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nmem->bus.base = rdev->mc.agp_base;\r\nmem->bus.is_iomem = !rdev->ddev->agp->cant_use_aperture;\r\n}\r\n#endif\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nif ((mem->bus.offset + mem->bus.size) > rdev->mc.visible_vram_size)\r\nreturn -EINVAL;\r\nmem->bus.base = rdev->mc.aper_base;\r\nmem->bus.is_iomem = true;\r\n#ifdef __alpha__\r\nif (mem->placement & TTM_PL_FLAG_WC)\r\nmem->bus.addr =\r\nioremap_wc(mem->bus.base + mem->bus.offset,\r\nmem->bus.size);\r\nelse\r\nmem->bus.addr =\r\nioremap_nocache(mem->bus.base + mem->bus.offset,\r\nmem->bus.size);\r\nmem->bus.base = (mem->bus.base & 0x0ffffffffUL) +\r\nrdev->ddev->hose->dense_mem_base;\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_io_mem_free(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)\r\n{\r\n}\r\nstatic int radeon_ttm_tt_pin_userptr(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_device *rdev = radeon_get_rdev(ttm->bdev);\r\nstruct radeon_ttm_tt *gtt = (void *)ttm;\r\nunsigned pinned = 0, nents;\r\nint r;\r\nint write = !(gtt->userflags & RADEON_GEM_USERPTR_READONLY);\r\nenum dma_data_direction direction = write ?\r\nDMA_BIDIRECTIONAL : DMA_TO_DEVICE;\r\nif (current->mm != gtt->usermm)\r\nreturn -EPERM;\r\nif (gtt->userflags & RADEON_GEM_USERPTR_ANONONLY) {\r\nunsigned long end = gtt->userptr + ttm->num_pages * PAGE_SIZE;\r\nstruct vm_area_struct *vma;\r\nvma = find_vma(gtt->usermm, gtt->userptr);\r\nif (!vma || vma->vm_file || vma->vm_end < end)\r\nreturn -EPERM;\r\n}\r\ndo {\r\nunsigned num_pages = ttm->num_pages - pinned;\r\nuint64_t userptr = gtt->userptr + pinned * PAGE_SIZE;\r\nstruct page **pages = ttm->pages + pinned;\r\nr = get_user_pages(current, current->mm, userptr, num_pages,\r\nwrite, 0, pages, NULL);\r\nif (r < 0)\r\ngoto release_pages;\r\npinned += r;\r\n} while (pinned < ttm->num_pages);\r\nr = sg_alloc_table_from_pages(ttm->sg, ttm->pages, ttm->num_pages, 0,\r\nttm->num_pages << PAGE_SHIFT,\r\nGFP_KERNEL);\r\nif (r)\r\ngoto release_sg;\r\nr = -ENOMEM;\r\nnents = dma_map_sg(rdev->dev, ttm->sg->sgl, ttm->sg->nents, direction);\r\nif (nents != ttm->sg->nents)\r\ngoto release_sg;\r\ndrm_prime_sg_to_page_addr_arrays(ttm->sg, ttm->pages,\r\ngtt->ttm.dma_address, ttm->num_pages);\r\nreturn 0;\r\nrelease_sg:\r\nkfree(ttm->sg);\r\nrelease_pages:\r\nrelease_pages(ttm->pages, pinned, 0);\r\nreturn r;\r\n}\r\nstatic void radeon_ttm_tt_unpin_userptr(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_device *rdev = radeon_get_rdev(ttm->bdev);\r\nstruct radeon_ttm_tt *gtt = (void *)ttm;\r\nstruct sg_page_iter sg_iter;\r\nint write = !(gtt->userflags & RADEON_GEM_USERPTR_READONLY);\r\nenum dma_data_direction direction = write ?\r\nDMA_BIDIRECTIONAL : DMA_TO_DEVICE;\r\nif (!ttm->sg->sgl)\r\nreturn;\r\ndma_unmap_sg(rdev->dev, ttm->sg->sgl, ttm->sg->nents, direction);\r\nfor_each_sg_page(ttm->sg->sgl, &sg_iter, ttm->sg->nents, 0) {\r\nstruct page *page = sg_page_iter_page(&sg_iter);\r\nif (!(gtt->userflags & RADEON_GEM_USERPTR_READONLY))\r\nset_page_dirty(page);\r\nmark_page_accessed(page);\r\npage_cache_release(page);\r\n}\r\nsg_free_table(ttm->sg);\r\n}\r\nstatic int radeon_ttm_backend_bind(struct ttm_tt *ttm,\r\nstruct ttm_mem_reg *bo_mem)\r\n{\r\nstruct radeon_ttm_tt *gtt = (void*)ttm;\r\nuint32_t flags = RADEON_GART_PAGE_VALID | RADEON_GART_PAGE_READ |\r\nRADEON_GART_PAGE_WRITE;\r\nint r;\r\nif (gtt->userptr) {\r\nradeon_ttm_tt_pin_userptr(ttm);\r\nflags &= ~RADEON_GART_PAGE_WRITE;\r\n}\r\ngtt->offset = (unsigned long)(bo_mem->start << PAGE_SHIFT);\r\nif (!ttm->num_pages) {\r\nWARN(1, "nothing to bind %lu pages for mreg %p back %p!\n",\r\nttm->num_pages, bo_mem, ttm);\r\n}\r\nif (ttm->caching_state == tt_cached)\r\nflags |= RADEON_GART_PAGE_SNOOP;\r\nr = radeon_gart_bind(gtt->rdev, gtt->offset, ttm->num_pages,\r\nttm->pages, gtt->ttm.dma_address, flags);\r\nif (r) {\r\nDRM_ERROR("failed to bind %lu pages at 0x%08X\n",\r\nttm->num_pages, (unsigned)gtt->offset);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_ttm_backend_unbind(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_ttm_tt *gtt = (void *)ttm;\r\nradeon_gart_unbind(gtt->rdev, gtt->offset, ttm->num_pages);\r\nif (gtt->userptr)\r\nradeon_ttm_tt_unpin_userptr(ttm);\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_backend_destroy(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_ttm_tt *gtt = (void *)ttm;\r\nttm_dma_tt_fini(&gtt->ttm);\r\nkfree(gtt);\r\n}\r\nstatic struct ttm_tt *radeon_ttm_tt_create(struct ttm_bo_device *bdev,\r\nunsigned long size, uint32_t page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct radeon_ttm_tt *gtt;\r\nrdev = radeon_get_rdev(bdev);\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nreturn ttm_agp_tt_create(bdev, rdev->ddev->agp->bridge,\r\nsize, page_flags, dummy_read_page);\r\n}\r\n#endif\r\ngtt = kzalloc(sizeof(struct radeon_ttm_tt), GFP_KERNEL);\r\nif (gtt == NULL) {\r\nreturn NULL;\r\n}\r\ngtt->ttm.ttm.func = &radeon_backend_func;\r\ngtt->rdev = rdev;\r\nif (ttm_dma_tt_init(&gtt->ttm, bdev, size, page_flags, dummy_read_page)) {\r\nkfree(gtt);\r\nreturn NULL;\r\n}\r\nreturn &gtt->ttm.ttm;\r\n}\r\nstatic struct radeon_ttm_tt *radeon_ttm_tt_to_gtt(struct ttm_tt *ttm)\r\n{\r\nif (!ttm || ttm->func != &radeon_backend_func)\r\nreturn NULL;\r\nreturn (struct radeon_ttm_tt *)ttm;\r\n}\r\nstatic int radeon_ttm_tt_populate(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_ttm_tt *gtt = radeon_ttm_tt_to_gtt(ttm);\r\nstruct radeon_device *rdev;\r\nunsigned i;\r\nint r;\r\nbool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);\r\nif (ttm->state != tt_unpopulated)\r\nreturn 0;\r\nif (gtt && gtt->userptr) {\r\nttm->sg = kzalloc(sizeof(struct sg_table), GFP_KERNEL);\r\nif (!ttm->sg)\r\nreturn -ENOMEM;\r\nttm->page_flags |= TTM_PAGE_FLAG_SG;\r\nttm->state = tt_unbound;\r\nreturn 0;\r\n}\r\nif (slave && ttm->sg) {\r\ndrm_prime_sg_to_page_addr_arrays(ttm->sg, ttm->pages,\r\ngtt->ttm.dma_address, ttm->num_pages);\r\nttm->state = tt_unbound;\r\nreturn 0;\r\n}\r\nrdev = radeon_get_rdev(ttm->bdev);\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nreturn ttm_agp_tt_populate(ttm);\r\n}\r\n#endif\r\n#ifdef CONFIG_SWIOTLB\r\nif (swiotlb_nr_tbl()) {\r\nreturn ttm_dma_populate(&gtt->ttm, rdev->dev);\r\n}\r\n#endif\r\nr = ttm_pool_populate(ttm);\r\nif (r) {\r\nreturn r;\r\n}\r\nfor (i = 0; i < ttm->num_pages; i++) {\r\ngtt->ttm.dma_address[i] = pci_map_page(rdev->pdev, ttm->pages[i],\r\n0, PAGE_SIZE,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(rdev->pdev, gtt->ttm.dma_address[i])) {\r\nwhile (--i) {\r\npci_unmap_page(rdev->pdev, gtt->ttm.dma_address[i],\r\nPAGE_SIZE, PCI_DMA_BIDIRECTIONAL);\r\ngtt->ttm.dma_address[i] = 0;\r\n}\r\nttm_pool_unpopulate(ttm);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_tt_unpopulate(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct radeon_ttm_tt *gtt = radeon_ttm_tt_to_gtt(ttm);\r\nunsigned i;\r\nbool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);\r\nif (gtt && gtt->userptr) {\r\nkfree(ttm->sg);\r\nttm->page_flags &= ~TTM_PAGE_FLAG_SG;\r\nreturn;\r\n}\r\nif (slave)\r\nreturn;\r\nrdev = radeon_get_rdev(ttm->bdev);\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nttm_agp_tt_unpopulate(ttm);\r\nreturn;\r\n}\r\n#endif\r\n#ifdef CONFIG_SWIOTLB\r\nif (swiotlb_nr_tbl()) {\r\nttm_dma_unpopulate(&gtt->ttm, rdev->dev);\r\nreturn;\r\n}\r\n#endif\r\nfor (i = 0; i < ttm->num_pages; i++) {\r\nif (gtt->ttm.dma_address[i]) {\r\npci_unmap_page(rdev->pdev, gtt->ttm.dma_address[i],\r\nPAGE_SIZE, PCI_DMA_BIDIRECTIONAL);\r\n}\r\n}\r\nttm_pool_unpopulate(ttm);\r\n}\r\nint radeon_ttm_tt_set_userptr(struct ttm_tt *ttm, uint64_t addr,\r\nuint32_t flags)\r\n{\r\nstruct radeon_ttm_tt *gtt = radeon_ttm_tt_to_gtt(ttm);\r\nif (gtt == NULL)\r\nreturn -EINVAL;\r\ngtt->userptr = addr;\r\ngtt->usermm = current->mm;\r\ngtt->userflags = flags;\r\nreturn 0;\r\n}\r\nbool radeon_ttm_tt_has_userptr(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_ttm_tt *gtt = radeon_ttm_tt_to_gtt(ttm);\r\nif (gtt == NULL)\r\nreturn false;\r\nreturn !!gtt->userptr;\r\n}\r\nbool radeon_ttm_tt_is_readonly(struct ttm_tt *ttm)\r\n{\r\nstruct radeon_ttm_tt *gtt = radeon_ttm_tt_to_gtt(ttm);\r\nif (gtt == NULL)\r\nreturn false;\r\nreturn !!(gtt->userflags & RADEON_GEM_USERPTR_READONLY);\r\n}\r\nint radeon_ttm_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr = radeon_ttm_global_init(rdev);\r\nif (r) {\r\nreturn r;\r\n}\r\nr = ttm_bo_device_init(&rdev->mman.bdev,\r\nrdev->mman.bo_global_ref.ref.object,\r\n&radeon_bo_driver,\r\nrdev->ddev->anon_inode->i_mapping,\r\nDRM_FILE_PAGE_OFFSET,\r\nrdev->need_dma32);\r\nif (r) {\r\nDRM_ERROR("failed initializing buffer object driver(%d).\n", r);\r\nreturn r;\r\n}\r\nrdev->mman.initialized = true;\r\nr = ttm_bo_init_mm(&rdev->mman.bdev, TTM_PL_VRAM,\r\nrdev->mc.real_vram_size >> PAGE_SHIFT);\r\nif (r) {\r\nDRM_ERROR("Failed initializing VRAM heap.\n");\r\nreturn r;\r\n}\r\nradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\r\nr = radeon_bo_create(rdev, 256 * 1024, PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_VRAM, 0, NULL,\r\nNULL, &rdev->stollen_vga_memory);\r\nif (r) {\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve(rdev->stollen_vga_memory, false);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_pin(rdev->stollen_vga_memory, RADEON_GEM_DOMAIN_VRAM, NULL);\r\nradeon_bo_unreserve(rdev->stollen_vga_memory);\r\nif (r) {\r\nradeon_bo_unref(&rdev->stollen_vga_memory);\r\nreturn r;\r\n}\r\nDRM_INFO("radeon: %uM of VRAM memory ready\n",\r\n(unsigned) (rdev->mc.real_vram_size / (1024 * 1024)));\r\nr = ttm_bo_init_mm(&rdev->mman.bdev, TTM_PL_TT,\r\nrdev->mc.gtt_size >> PAGE_SHIFT);\r\nif (r) {\r\nDRM_ERROR("Failed initializing GTT heap.\n");\r\nreturn r;\r\n}\r\nDRM_INFO("radeon: %uM of GTT memory ready.\n",\r\n(unsigned)(rdev->mc.gtt_size / (1024 * 1024)));\r\nr = radeon_ttm_debugfs_init(rdev);\r\nif (r) {\r\nDRM_ERROR("Failed to init debugfs\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_ttm_fini(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (!rdev->mman.initialized)\r\nreturn;\r\nradeon_ttm_debugfs_fini(rdev);\r\nif (rdev->stollen_vga_memory) {\r\nr = radeon_bo_reserve(rdev->stollen_vga_memory, false);\r\nif (r == 0) {\r\nradeon_bo_unpin(rdev->stollen_vga_memory);\r\nradeon_bo_unreserve(rdev->stollen_vga_memory);\r\n}\r\nradeon_bo_unref(&rdev->stollen_vga_memory);\r\n}\r\nttm_bo_clean_mm(&rdev->mman.bdev, TTM_PL_VRAM);\r\nttm_bo_clean_mm(&rdev->mman.bdev, TTM_PL_TT);\r\nttm_bo_device_release(&rdev->mman.bdev);\r\nradeon_gart_fini(rdev);\r\nradeon_ttm_global_fini(rdev);\r\nrdev->mman.initialized = false;\r\nDRM_INFO("radeon: ttm finalized\n");\r\n}\r\nvoid radeon_ttm_set_active_vram_size(struct radeon_device *rdev, u64 size)\r\n{\r\nstruct ttm_mem_type_manager *man;\r\nif (!rdev->mman.initialized)\r\nreturn;\r\nman = &rdev->mman.bdev.man[TTM_PL_VRAM];\r\nman->size = size >> PAGE_SHIFT;\r\n}\r\nstatic int radeon_ttm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct ttm_buffer_object *bo;\r\nstruct radeon_device *rdev;\r\nint r;\r\nbo = (struct ttm_buffer_object *)vma->vm_private_data;\r\nif (bo == NULL) {\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nrdev = radeon_get_rdev(bo->bdev);\r\ndown_read(&rdev->pm.mclk_lock);\r\nr = ttm_vm_ops->fault(vma, vmf);\r\nup_read(&rdev->pm.mclk_lock);\r\nreturn r;\r\n}\r\nint radeon_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct radeon_device *rdev;\r\nint r;\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET)) {\r\nreturn -EINVAL;\r\n}\r\nfile_priv = filp->private_data;\r\nrdev = file_priv->minor->dev->dev_private;\r\nif (rdev == NULL) {\r\nreturn -EINVAL;\r\n}\r\nr = ttm_bo_mmap(filp, vma, &rdev->mman.bdev);\r\nif (unlikely(r != 0)) {\r\nreturn r;\r\n}\r\nif (unlikely(ttm_vm_ops == NULL)) {\r\nttm_vm_ops = vma->vm_ops;\r\nradeon_ttm_vm_ops = *ttm_vm_ops;\r\nradeon_ttm_vm_ops.fault = &radeon_ttm_fault;\r\n}\r\nvma->vm_ops = &radeon_ttm_vm_ops;\r\nreturn 0;\r\n}\r\nstatic int radeon_mm_dump_table(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nunsigned ttm_pl = *(int *)node->info_ent->data;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_mm *mm = (struct drm_mm *)rdev->mman.bdev.man[ttm_pl].priv;\r\nint ret;\r\nstruct ttm_bo_global *glob = rdev->mman.bdev.glob;\r\nspin_lock(&glob->lru_lock);\r\nret = drm_mm_dump_table(m, mm);\r\nspin_unlock(&glob->lru_lock);\r\nreturn ret;\r\n}\r\nstatic int radeon_ttm_vram_open(struct inode *inode, struct file *filep)\r\n{\r\nstruct radeon_device *rdev = inode->i_private;\r\ni_size_write(inode, rdev->mc.mc_vram_size);\r\nfilep->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t radeon_ttm_vram_read(struct file *f, char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nstruct radeon_device *rdev = f->private_data;\r\nssize_t result = 0;\r\nint r;\r\nif (size & 0x3 || *pos & 0x3)\r\nreturn -EINVAL;\r\nwhile (size) {\r\nunsigned long flags;\r\nuint32_t value;\r\nif (*pos >= rdev->mc.mc_vram_size)\r\nreturn result;\r\nspin_lock_irqsave(&rdev->mmio_idx_lock, flags);\r\nWREG32(RADEON_MM_INDEX, ((uint32_t)*pos) | 0x80000000);\r\nif (rdev->family >= CHIP_CEDAR)\r\nWREG32(EVERGREEN_MM_INDEX_HI, *pos >> 31);\r\nvalue = RREG32(RADEON_MM_DATA);\r\nspin_unlock_irqrestore(&rdev->mmio_idx_lock, flags);\r\nr = put_user(value, (uint32_t *)buf);\r\nif (r)\r\nreturn r;\r\nresult += 4;\r\nbuf += 4;\r\n*pos += 4;\r\nsize -= 4;\r\n}\r\nreturn result;\r\n}\r\nstatic int radeon_ttm_gtt_open(struct inode *inode, struct file *filep)\r\n{\r\nstruct radeon_device *rdev = inode->i_private;\r\ni_size_write(inode, rdev->mc.gtt_size);\r\nfilep->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t radeon_ttm_gtt_read(struct file *f, char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nstruct radeon_device *rdev = f->private_data;\r\nssize_t result = 0;\r\nint r;\r\nwhile (size) {\r\nloff_t p = *pos / PAGE_SIZE;\r\nunsigned off = *pos & ~PAGE_MASK;\r\nsize_t cur_size = min_t(size_t, size, PAGE_SIZE - off);\r\nstruct page *page;\r\nvoid *ptr;\r\nif (p >= rdev->gart.num_cpu_pages)\r\nreturn result;\r\npage = rdev->gart.pages[p];\r\nif (page) {\r\nptr = kmap(page);\r\nptr += off;\r\nr = copy_to_user(buf, ptr, cur_size);\r\nkunmap(rdev->gart.pages[p]);\r\n} else\r\nr = clear_user(buf, cur_size);\r\nif (r)\r\nreturn -EFAULT;\r\nresult += cur_size;\r\nbuf += cur_size;\r\n*pos += cur_size;\r\nsize -= cur_size;\r\n}\r\nreturn result;\r\n}\r\nstatic int radeon_ttm_debugfs_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nunsigned count;\r\nstruct drm_minor *minor = rdev->ddev->primary;\r\nstruct dentry *ent, *root = minor->debugfs_root;\r\nent = debugfs_create_file("radeon_vram", S_IFREG | S_IRUGO, root,\r\nrdev, &radeon_ttm_vram_fops);\r\nif (IS_ERR(ent))\r\nreturn PTR_ERR(ent);\r\nrdev->mman.vram = ent;\r\nent = debugfs_create_file("radeon_gtt", S_IFREG | S_IRUGO, root,\r\nrdev, &radeon_ttm_gtt_fops);\r\nif (IS_ERR(ent))\r\nreturn PTR_ERR(ent);\r\nrdev->mman.gtt = ent;\r\ncount = ARRAY_SIZE(radeon_ttm_debugfs_list);\r\n#ifdef CONFIG_SWIOTLB\r\nif (!swiotlb_nr_tbl())\r\n--count;\r\n#endif\r\nreturn radeon_debugfs_add_files(rdev, radeon_ttm_debugfs_list, count);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void radeon_ttm_debugfs_fini(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\ndebugfs_remove(rdev->mman.vram);\r\nrdev->mman.vram = NULL;\r\ndebugfs_remove(rdev->mman.gtt);\r\nrdev->mman.gtt = NULL;\r\n#endif\r\n}
