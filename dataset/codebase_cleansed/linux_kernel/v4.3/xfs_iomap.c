STATIC int\r\nxfs_iomap_eof_align_last_fsb(\r\nxfs_mount_t *mp,\r\nxfs_inode_t *ip,\r\nxfs_extlen_t extsize,\r\nxfs_fileoff_t *last_fsb)\r\n{\r\nxfs_extlen_t align = 0;\r\nint eof, error;\r\nif (!XFS_IS_REALTIME_INODE(ip)) {\r\nif (mp->m_swidth && (mp->m_flags & XFS_MOUNT_SWALLOC))\r\nalign = mp->m_swidth;\r\nelse if (mp->m_dalign)\r\nalign = mp->m_dalign;\r\nif (align && XFS_ISIZE(ip) < XFS_FSB_TO_B(mp, align))\r\nalign = 0;\r\n}\r\nif (extsize) {\r\nif (align)\r\nalign = roundup_64(align, extsize);\r\nelse\r\nalign = extsize;\r\n}\r\nif (align) {\r\nxfs_fileoff_t new_last_fsb = roundup_64(*last_fsb, align);\r\nerror = xfs_bmap_eof(ip, new_last_fsb, XFS_DATA_FORK, &eof);\r\nif (error)\r\nreturn error;\r\nif (eof)\r\n*last_fsb = new_last_fsb;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_alert_fsblock_zero(\r\nxfs_inode_t *ip,\r\nxfs_bmbt_irec_t *imap)\r\n{\r\nxfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\r\n"Access to block zero in inode %llu "\r\n"start_block: %llx start_off: %llx "\r\n"blkcnt: %llx extent-state: %x",\r\n(unsigned long long)ip->i_ino,\r\n(unsigned long long)imap->br_startblock,\r\n(unsigned long long)imap->br_startoff,\r\n(unsigned long long)imap->br_blockcount,\r\nimap->br_state);\r\nreturn -EFSCORRUPTED;\r\n}\r\nint\r\nxfs_iomap_write_direct(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nsize_t count,\r\nxfs_bmbt_irec_t *imap,\r\nint nmaps)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_fileoff_t offset_fsb;\r\nxfs_fileoff_t last_fsb;\r\nxfs_filblks_t count_fsb, resaligned;\r\nxfs_fsblock_t firstfsb;\r\nxfs_extlen_t extsz, temp;\r\nint nimaps;\r\nint quota_flag;\r\nint rt;\r\nxfs_trans_t *tp;\r\nxfs_bmap_free_t free_list;\r\nuint qblocks, resblks, resrtextents;\r\nint committed;\r\nint error;\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\nrt = XFS_IS_REALTIME_INODE(ip);\r\nextsz = xfs_get_extsz_hint(ip);\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\r\nif ((offset + count) > XFS_ISIZE(ip)) {\r\nerror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\r\nif (error)\r\nreturn error;\r\n} else {\r\nif (nmaps && (imap->br_startblock == HOLESTARTBLOCK))\r\nlast_fsb = MIN(last_fsb, (xfs_fileoff_t)\r\nimap->br_blockcount +\r\nimap->br_startoff);\r\n}\r\ncount_fsb = last_fsb - offset_fsb;\r\nASSERT(count_fsb > 0);\r\nresaligned = count_fsb;\r\nif (unlikely(extsz)) {\r\nif ((temp = do_mod(offset_fsb, extsz)))\r\nresaligned += temp;\r\nif ((temp = do_mod(resaligned, extsz)))\r\nresaligned += extsz - temp;\r\n}\r\nif (unlikely(rt)) {\r\nresrtextents = qblocks = resaligned;\r\nresrtextents /= mp->m_sb.sb_rextsize;\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\r\nquota_flag = XFS_QMOPT_RES_RTBLKS;\r\n} else {\r\nresrtextents = 0;\r\nresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resaligned);\r\nquota_flag = XFS_QMOPT_RES_REGBLKS;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\r\nresblks, resrtextents);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks, 0, quota_flag);\r\nif (error)\r\ngoto out_trans_cancel;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nnimaps = 1;\r\nerror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\r\nXFS_BMAPI_PREALLOC, &firstfsb, 0,\r\nimap, &nimaps, &free_list);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_trans_commit(tp);\r\nif (error)\r\ngoto out_unlock;\r\nif (nimaps == 0) {\r\nerror = -ENOSPC;\r\ngoto out_unlock;\r\n}\r\nif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\r\nerror = xfs_alert_fsblock_zero(ip, imap);\r\nout_unlock:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\nout_bmap_cancel:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp);\r\ngoto out_unlock;\r\n}\r\nSTATIC int\r\nxfs_iomap_eof_want_preallocate(\r\nxfs_mount_t *mp,\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nsize_t count,\r\nxfs_bmbt_irec_t *imap,\r\nint nimaps,\r\nint *prealloc)\r\n{\r\nxfs_fileoff_t start_fsb;\r\nxfs_filblks_t count_fsb;\r\nint n, error, imaps;\r\nint found_delalloc = 0;\r\n*prealloc = 0;\r\nif (offset + count <= XFS_ISIZE(ip))\r\nreturn 0;\r\nif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE) &&\r\nXFS_ISIZE(ip) < XFS_FSB_TO_B(mp, mp->m_writeio_blocks))\r\nreturn 0;\r\nstart_fsb = XFS_B_TO_FSBT(mp, ((xfs_ufsize_t)(offset + count - 1)));\r\ncount_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\nwhile (count_fsb > 0) {\r\nimaps = nimaps;\r\nerror = xfs_bmapi_read(ip, start_fsb, count_fsb, imap, &imaps,\r\n0);\r\nif (error)\r\nreturn error;\r\nfor (n = 0; n < imaps; n++) {\r\nif ((imap[n].br_startblock != HOLESTARTBLOCK) &&\r\n(imap[n].br_startblock != DELAYSTARTBLOCK))\r\nreturn 0;\r\nstart_fsb += imap[n].br_blockcount;\r\ncount_fsb -= imap[n].br_blockcount;\r\nif (imap[n].br_startblock == DELAYSTARTBLOCK)\r\nfound_delalloc = 1;\r\n}\r\n}\r\nif (!found_delalloc)\r\n*prealloc = 1;\r\nreturn 0;\r\n}\r\nSTATIC xfs_fsblock_t\r\nxfs_iomap_eof_prealloc_initial_size(\r\nstruct xfs_mount *mp,\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nxfs_bmbt_irec_t *imap,\r\nint nimaps)\r\n{\r\nxfs_fileoff_t start_fsb;\r\nint imaps = 1;\r\nint error;\r\nASSERT(nimaps >= imaps);\r\nif (mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)\r\nreturn 0;\r\nif (XFS_ISIZE(ip) < XFS_FSB_TO_B(mp, mp->m_dalign))\r\nreturn 0;\r\nstart_fsb = XFS_B_TO_FSB(mp, offset);\r\nif (start_fsb)\r\nstart_fsb--;\r\nerror = xfs_bmapi_read(ip, start_fsb, 1, imap, &imaps, XFS_BMAPI_ENTIRE);\r\nif (error)\r\nreturn 0;\r\nASSERT(imaps == 1);\r\nif (imap[0].br_startblock == HOLESTARTBLOCK)\r\nreturn 0;\r\nif (imap[0].br_blockcount <= (MAXEXTLEN >> 1))\r\nreturn imap[0].br_blockcount << 1;\r\nreturn XFS_B_TO_FSB(mp, offset);\r\n}\r\nSTATIC bool\r\nxfs_quota_need_throttle(\r\nstruct xfs_inode *ip,\r\nint type,\r\nxfs_fsblock_t alloc_blocks)\r\n{\r\nstruct xfs_dquot *dq = xfs_inode_dquot(ip, type);\r\nif (!dq || !xfs_this_quota_on(ip->i_mount, type))\r\nreturn false;\r\nif (!dq->q_prealloc_hi_wmark)\r\nreturn false;\r\nif (dq->q_res_bcount + alloc_blocks < dq->q_prealloc_lo_wmark)\r\nreturn false;\r\nreturn true;\r\n}\r\nSTATIC void\r\nxfs_quota_calc_throttle(\r\nstruct xfs_inode *ip,\r\nint type,\r\nxfs_fsblock_t *qblocks,\r\nint *qshift,\r\nint64_t *qfreesp)\r\n{\r\nint64_t freesp;\r\nint shift = 0;\r\nstruct xfs_dquot *dq = xfs_inode_dquot(ip, type);\r\nif (!dq || dq->q_res_bcount >= dq->q_prealloc_hi_wmark) {\r\n*qblocks = 0;\r\n*qfreesp = 0;\r\nreturn;\r\n}\r\nfreesp = dq->q_prealloc_hi_wmark - dq->q_res_bcount;\r\nif (freesp < dq->q_low_space[XFS_QLOWSP_5_PCNT]) {\r\nshift = 2;\r\nif (freesp < dq->q_low_space[XFS_QLOWSP_3_PCNT])\r\nshift += 2;\r\nif (freesp < dq->q_low_space[XFS_QLOWSP_1_PCNT])\r\nshift += 2;\r\n}\r\nif (freesp < *qfreesp)\r\n*qfreesp = freesp;\r\nif ((freesp >> shift) < (*qblocks >> *qshift)) {\r\n*qblocks = freesp;\r\n*qshift = shift;\r\n}\r\n}\r\nSTATIC xfs_fsblock_t\r\nxfs_iomap_prealloc_size(\r\nstruct xfs_mount *mp,\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nstruct xfs_bmbt_irec *imap,\r\nint nimaps)\r\n{\r\nxfs_fsblock_t alloc_blocks = 0;\r\nint shift = 0;\r\nint64_t freesp;\r\nxfs_fsblock_t qblocks;\r\nint qshift = 0;\r\nalloc_blocks = xfs_iomap_eof_prealloc_initial_size(mp, ip, offset,\r\nimap, nimaps);\r\nif (!alloc_blocks)\r\ngoto check_writeio;\r\nqblocks = alloc_blocks;\r\nalloc_blocks = XFS_FILEOFF_MIN(roundup_pow_of_two(MAXEXTLEN),\r\nalloc_blocks);\r\nfreesp = percpu_counter_read_positive(&mp->m_fdblocks);\r\nif (freesp < mp->m_low_space[XFS_LOWSP_5_PCNT]) {\r\nshift = 2;\r\nif (freesp < mp->m_low_space[XFS_LOWSP_4_PCNT])\r\nshift++;\r\nif (freesp < mp->m_low_space[XFS_LOWSP_3_PCNT])\r\nshift++;\r\nif (freesp < mp->m_low_space[XFS_LOWSP_2_PCNT])\r\nshift++;\r\nif (freesp < mp->m_low_space[XFS_LOWSP_1_PCNT])\r\nshift++;\r\n}\r\nif (xfs_quota_need_throttle(ip, XFS_DQ_USER, alloc_blocks))\r\nxfs_quota_calc_throttle(ip, XFS_DQ_USER, &qblocks, &qshift,\r\n&freesp);\r\nif (xfs_quota_need_throttle(ip, XFS_DQ_GROUP, alloc_blocks))\r\nxfs_quota_calc_throttle(ip, XFS_DQ_GROUP, &qblocks, &qshift,\r\n&freesp);\r\nif (xfs_quota_need_throttle(ip, XFS_DQ_PROJ, alloc_blocks))\r\nxfs_quota_calc_throttle(ip, XFS_DQ_PROJ, &qblocks, &qshift,\r\n&freesp);\r\nalloc_blocks = MIN(alloc_blocks, qblocks);\r\nshift = MAX(shift, qshift);\r\nif (shift)\r\nalloc_blocks >>= shift;\r\nif (alloc_blocks)\r\nalloc_blocks = rounddown_pow_of_two(alloc_blocks);\r\nif (alloc_blocks > MAXEXTLEN)\r\nalloc_blocks = MAXEXTLEN;\r\nwhile (alloc_blocks && alloc_blocks >= freesp)\r\nalloc_blocks >>= 4;\r\ncheck_writeio:\r\nif (alloc_blocks < mp->m_writeio_blocks)\r\nalloc_blocks = mp->m_writeio_blocks;\r\ntrace_xfs_iomap_prealloc_size(ip, alloc_blocks, shift,\r\nmp->m_writeio_blocks);\r\nreturn alloc_blocks;\r\n}\r\nint\r\nxfs_iomap_write_delay(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nsize_t count,\r\nxfs_bmbt_irec_t *ret_imap)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_fileoff_t offset_fsb;\r\nxfs_fileoff_t last_fsb;\r\nxfs_off_t aligned_offset;\r\nxfs_fileoff_t ioalign;\r\nxfs_extlen_t extsz;\r\nint nimaps;\r\nxfs_bmbt_irec_t imap[XFS_WRITE_IMAPS];\r\nint prealloc;\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nerror = xfs_qm_dqattach_locked(ip, 0);\r\nif (error)\r\nreturn error;\r\nextsz = xfs_get_extsz_hint(ip);\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nerror = xfs_iomap_eof_want_preallocate(mp, ip, offset, count,\r\nimap, XFS_WRITE_IMAPS, &prealloc);\r\nif (error)\r\nreturn error;\r\nretry:\r\nif (prealloc) {\r\nxfs_fsblock_t alloc_blocks;\r\nalloc_blocks = xfs_iomap_prealloc_size(mp, ip, offset, imap,\r\nXFS_WRITE_IMAPS);\r\naligned_offset = XFS_WRITEIO_ALIGN(mp, (offset + count - 1));\r\nioalign = XFS_B_TO_FSBT(mp, aligned_offset);\r\nlast_fsb = ioalign + alloc_blocks;\r\n} else {\r\nlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\r\n}\r\nif (prealloc || extsz) {\r\nerror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\r\nif (error)\r\nreturn error;\r\n}\r\nif (last_fsb > XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes))\r\nlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\nASSERT(last_fsb > offset_fsb);\r\nnimaps = XFS_WRITE_IMAPS;\r\nerror = xfs_bmapi_delay(ip, offset_fsb, last_fsb - offset_fsb,\r\nimap, &nimaps, XFS_BMAPI_ENTIRE);\r\nswitch (error) {\r\ncase 0:\r\ncase -ENOSPC:\r\ncase -EDQUOT:\r\nbreak;\r\ndefault:\r\nreturn error;\r\n}\r\nif (nimaps == 0) {\r\ntrace_xfs_delalloc_enospc(ip, offset, count);\r\nif (prealloc) {\r\nprealloc = 0;\r\nerror = 0;\r\ngoto retry;\r\n}\r\nreturn error ? error : -ENOSPC;\r\n}\r\nif (!(imap[0].br_startblock || XFS_IS_REALTIME_INODE(ip)))\r\nreturn xfs_alert_fsblock_zero(ip, &imap[0]);\r\nif (prealloc)\r\nxfs_inode_set_eofblocks_tag(ip);\r\n*ret_imap = imap[0];\r\nreturn 0;\r\n}\r\nint\r\nxfs_iomap_write_allocate(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nxfs_bmbt_irec_t *imap)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_fileoff_t offset_fsb, last_block;\r\nxfs_fileoff_t end_fsb, map_start_fsb;\r\nxfs_fsblock_t first_block;\r\nxfs_bmap_free_t free_list;\r\nxfs_filblks_t count_fsb;\r\nxfs_trans_t *tp;\r\nint nimaps, committed;\r\nint error = 0;\r\nint nres;\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\ncount_fsb = imap->br_blockcount;\r\nmap_start_fsb = imap->br_startoff;\r\nXFS_STATS_ADD(xs_xstrat_bytes, XFS_FSB_TO_B(mp, count_fsb));\r\nwhile (count_fsb != 0) {\r\nnimaps = 0;\r\nwhile (nimaps == 0) {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE);\r\ntp->t_flags |= XFS_TRANS_RESERVE;\r\nnres = XFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\r\nnres, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &first_block);\r\nnimaps = 1;\r\nend_fsb = XFS_B_TO_FSB(mp, XFS_ISIZE(ip));\r\nerror = xfs_bmap_last_offset(ip, &last_block,\r\nXFS_DATA_FORK);\r\nif (error)\r\ngoto trans_cancel;\r\nlast_block = XFS_FILEOFF_MAX(last_block, end_fsb);\r\nif ((map_start_fsb + count_fsb) > last_block) {\r\ncount_fsb = last_block - map_start_fsb;\r\nif (count_fsb == 0) {\r\nerror = -EAGAIN;\r\ngoto trans_cancel;\r\n}\r\n}\r\nerror = xfs_bmapi_write(tp, ip, map_start_fsb,\r\ncount_fsb, 0,\r\n&first_block, 1,\r\nimap, &nimaps, &free_list);\r\nif (error)\r\ngoto trans_cancel;\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto trans_cancel;\r\nerror = xfs_trans_commit(tp);\r\nif (error)\r\ngoto error0;\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\n}\r\nif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\r\nreturn xfs_alert_fsblock_zero(ip, imap);\r\nif ((offset_fsb >= imap->br_startoff) &&\r\n(offset_fsb < (imap->br_startoff +\r\nimap->br_blockcount))) {\r\nXFS_STATS_INC(xs_xstrat_quick);\r\nreturn 0;\r\n}\r\ncount_fsb -= imap->br_blockcount;\r\nmap_start_fsb = imap->br_startoff + imap->br_blockcount;\r\n}\r\ntrans_cancel:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_cancel(tp);\r\nerror0:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nint\r\nxfs_iomap_write_unwritten(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nxfs_off_t count)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_fileoff_t offset_fsb;\r\nxfs_filblks_t count_fsb;\r\nxfs_filblks_t numblks_fsb;\r\nxfs_fsblock_t firstfsb;\r\nint nimaps;\r\nxfs_trans_t *tp;\r\nxfs_bmbt_irec_t imap;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsize_t i_size;\r\nuint resblks;\r\nint committed;\r\nint error;\r\ntrace_xfs_unwritten_convert(ip, offset, count);\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\ncount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\r\ncount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\r\ndo {\r\nsb_start_intwrite(mp->m_super);\r\ntp = _xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE, KM_NOFS);\r\ntp->t_flags |= XFS_TRANS_RESERVE | XFS_TRANS_FREEZE_PROT;\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\r\nresblks, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nnimaps = 1;\r\nerror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\r\nXFS_BMAPI_CONVERT, &firstfsb,\r\n1, &imap, &nimaps, &free_list);\r\nif (error)\r\ngoto error_on_bmapi_transaction;\r\ni_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\r\nif (i_size > offset + count)\r\ni_size = offset + count;\r\ni_size = xfs_new_eof(ip, i_size);\r\nif (i_size) {\r\nip->i_d.di_size = i_size;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto error_on_bmapi_transaction;\r\nerror = xfs_trans_commit(tp);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nif (error)\r\nreturn error;\r\nif (!(imap.br_startblock || XFS_IS_REALTIME_INODE(ip)))\r\nreturn xfs_alert_fsblock_zero(ip, &imap);\r\nif ((numblks_fsb = imap.br_blockcount) == 0) {\r\nASSERT(imap.br_blockcount);\r\nbreak;\r\n}\r\noffset_fsb += numblks_fsb;\r\ncount_fsb -= numblks_fsb;\r\n} while (count_fsb > 0);\r\nreturn 0;\r\nerror_on_bmapi_transaction:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_cancel(tp);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}
