int\r\nxfs_find_handle(\r\nunsigned int cmd,\r\nxfs_fsop_handlereq_t *hreq)\r\n{\r\nint hsize;\r\nxfs_handle_t handle;\r\nstruct inode *inode;\r\nstruct fd f = {NULL};\r\nstruct path path;\r\nint error;\r\nstruct xfs_inode *ip;\r\nif (cmd == XFS_IOC_FD_TO_HANDLE) {\r\nf = fdget(hreq->fd);\r\nif (!f.file)\r\nreturn -EBADF;\r\ninode = file_inode(f.file);\r\n} else {\r\nerror = user_lpath((const char __user *)hreq->path, &path);\r\nif (error)\r\nreturn error;\r\ninode = d_inode(path.dentry);\r\n}\r\nip = XFS_I(inode);\r\nerror = -EINVAL;\r\nif (inode->i_sb->s_magic != XFS_SB_MAGIC)\r\ngoto out_put;\r\nerror = -EBADF;\r\nif (!S_ISREG(inode->i_mode) &&\r\n!S_ISDIR(inode->i_mode) &&\r\n!S_ISLNK(inode->i_mode))\r\ngoto out_put;\r\nmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\r\nif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\r\nmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\r\nhsize = sizeof(xfs_fsid_t);\r\n} else {\r\nhandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\r\nsizeof(handle.ha_fid.fid_len);\r\nhandle.ha_fid.fid_pad = 0;\r\nhandle.ha_fid.fid_gen = ip->i_d.di_gen;\r\nhandle.ha_fid.fid_ino = ip->i_ino;\r\nhsize = XFS_HSIZE(handle);\r\n}\r\nerror = -EFAULT;\r\nif (copy_to_user(hreq->ohandle, &handle, hsize) ||\r\ncopy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\r\ngoto out_put;\r\nerror = 0;\r\nout_put:\r\nif (cmd == XFS_IOC_FD_TO_HANDLE)\r\nfdput(f);\r\nelse\r\npath_put(&path);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_handle_acceptable(\r\nvoid *context,\r\nstruct dentry *dentry)\r\n{\r\nreturn 1;\r\n}\r\nstruct dentry *\r\nxfs_handle_to_dentry(\r\nstruct file *parfilp,\r\nvoid __user *uhandle,\r\nu32 hlen)\r\n{\r\nxfs_handle_t handle;\r\nstruct xfs_fid64 fid;\r\nif (!S_ISDIR(file_inode(parfilp)->i_mode))\r\nreturn ERR_PTR(-ENOTDIR);\r\nif (hlen != sizeof(xfs_handle_t))\r\nreturn ERR_PTR(-EINVAL);\r\nif (copy_from_user(&handle, uhandle, hlen))\r\nreturn ERR_PTR(-EFAULT);\r\nif (handle.ha_fid.fid_len !=\r\nsizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\r\nreturn ERR_PTR(-EINVAL);\r\nmemset(&fid, 0, sizeof(struct fid));\r\nfid.ino = handle.ha_fid.fid_ino;\r\nfid.gen = handle.ha_fid.fid_gen;\r\nreturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\r\nFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\r\nxfs_handle_acceptable, NULL);\r\n}\r\nSTATIC struct dentry *\r\nxfs_handlereq_to_dentry(\r\nstruct file *parfilp,\r\nxfs_fsop_handlereq_t *hreq)\r\n{\r\nreturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\r\n}\r\nint\r\nxfs_open_by_handle(\r\nstruct file *parfilp,\r\nxfs_fsop_handlereq_t *hreq)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint error;\r\nint fd;\r\nint permflag;\r\nstruct file *filp;\r\nstruct inode *inode;\r\nstruct dentry *dentry;\r\nfmode_t fmode;\r\nstruct path path;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ndentry = xfs_handlereq_to_dentry(parfilp, hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\ninode = d_inode(dentry);\r\nif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\r\nerror = -EPERM;\r\ngoto out_dput;\r\n}\r\n#if BITS_PER_LONG != 32\r\nhreq->oflags |= O_LARGEFILE;\r\n#endif\r\npermflag = hreq->oflags;\r\nfmode = OPEN_FMODE(permflag);\r\nif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\r\n(fmode & FMODE_WRITE) && IS_APPEND(inode)) {\r\nerror = -EPERM;\r\ngoto out_dput;\r\n}\r\nif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\r\nerror = -EACCES;\r\ngoto out_dput;\r\n}\r\nif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\r\nerror = -EISDIR;\r\ngoto out_dput;\r\n}\r\nfd = get_unused_fd_flags(0);\r\nif (fd < 0) {\r\nerror = fd;\r\ngoto out_dput;\r\n}\r\npath.mnt = parfilp->f_path.mnt;\r\npath.dentry = dentry;\r\nfilp = dentry_open(&path, hreq->oflags, cred);\r\ndput(dentry);\r\nif (IS_ERR(filp)) {\r\nput_unused_fd(fd);\r\nreturn PTR_ERR(filp);\r\n}\r\nif (S_ISREG(inode->i_mode)) {\r\nfilp->f_flags |= O_NOATIME;\r\nfilp->f_mode |= FMODE_NOCMTIME;\r\n}\r\nfd_install(fd, filp);\r\nreturn fd;\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nint\r\nxfs_readlink_by_handle(\r\nstruct file *parfilp,\r\nxfs_fsop_handlereq_t *hreq)\r\n{\r\nstruct dentry *dentry;\r\n__u32 olen;\r\nvoid *link;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ndentry = xfs_handlereq_to_dentry(parfilp, hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nif (!d_is_symlink(dentry)) {\r\nerror = -EINVAL;\r\ngoto out_dput;\r\n}\r\nif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\r\nerror = -EFAULT;\r\ngoto out_dput;\r\n}\r\nlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\r\nif (!link) {\r\nerror = -ENOMEM;\r\ngoto out_dput;\r\n}\r\nerror = xfs_readlink(XFS_I(d_inode(dentry)), link);\r\nif (error)\r\ngoto out_kfree;\r\nerror = readlink_copy(hreq->ohandle, olen, link);\r\nif (error)\r\ngoto out_kfree;\r\nout_kfree:\r\nkfree(link);\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nint\r\nxfs_set_dmattrs(\r\nxfs_inode_t *ip,\r\nu_int evmask,\r\nu_int16_t state)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_trans_t *tp;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nip->i_d.di_dmevmask = evmask;\r\nip->i_d.di_dmstate = state;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(tp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_fssetdm_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error;\r\nstruct fsdmidata fsd;\r\nxfs_fsop_setdm_handlereq_t dmhreq;\r\nstruct dentry *dentry;\r\nif (!capable(CAP_MKNOD))\r\nreturn -EPERM;\r\nif (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(parfilp);\r\nif (error)\r\nreturn error;\r\ndentry = xfs_handlereq_to_dentry(parfilp, &dmhreq.hreq);\r\nif (IS_ERR(dentry)) {\r\nmnt_drop_write_file(parfilp);\r\nreturn PTR_ERR(dentry);\r\n}\r\nif (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {\r\nerror = -EPERM;\r\ngoto out;\r\n}\r\nif (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\nerror = xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,\r\nfsd.fsd_dmstate);\r\nout:\r\nmnt_drop_write_file(parfilp);\r\ndput(dentry);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attrlist_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error = -ENOMEM;\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_fsop_attrlist_handlereq_t al_hreq;\r\nstruct dentry *dentry;\r\nchar *kbuf;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\r\nreturn -EFAULT;\r\nif (al_hreq.buflen < sizeof(struct attrlist) ||\r\nal_hreq.buflen > XATTR_LIST_MAX)\r\nreturn -EINVAL;\r\nif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\r\nreturn -EINVAL;\r\ndentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\r\nif (!kbuf)\r\ngoto out_dput;\r\ncursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\r\nerror = xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,\r\nal_hreq.flags, cursor);\r\nif (error)\r\ngoto out_kfree;\r\nif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\r\nerror = -EFAULT;\r\nout_kfree:\r\nkmem_free(kbuf);\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nint\r\nxfs_attrmulti_attr_get(\r\nstruct inode *inode,\r\nunsigned char *name,\r\nunsigned char __user *ubuf,\r\n__uint32_t *len,\r\n__uint32_t flags)\r\n{\r\nunsigned char *kbuf;\r\nint error = -EFAULT;\r\nif (*len > XATTR_SIZE_MAX)\r\nreturn -EINVAL;\r\nkbuf = kmem_zalloc_large(*len, KM_SLEEP);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nerror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\r\nif (error)\r\ngoto out_kfree;\r\nif (copy_to_user(ubuf, kbuf, *len))\r\nerror = -EFAULT;\r\nout_kfree:\r\nkmem_free(kbuf);\r\nreturn error;\r\n}\r\nint\r\nxfs_attrmulti_attr_set(\r\nstruct inode *inode,\r\nunsigned char *name,\r\nconst unsigned char __user *ubuf,\r\n__uint32_t len,\r\n__uint32_t flags)\r\n{\r\nunsigned char *kbuf;\r\nif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\r\nreturn -EPERM;\r\nif (len > XATTR_SIZE_MAX)\r\nreturn -EINVAL;\r\nkbuf = memdup_user(ubuf, len);\r\nif (IS_ERR(kbuf))\r\nreturn PTR_ERR(kbuf);\r\nreturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\r\n}\r\nint\r\nxfs_attrmulti_attr_remove(\r\nstruct inode *inode,\r\nunsigned char *name,\r\n__uint32_t flags)\r\n{\r\nif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\r\nreturn -EPERM;\r\nreturn xfs_attr_remove(XFS_I(inode), name, flags);\r\n}\r\nSTATIC int\r\nxfs_attrmulti_by_handle(\r\nstruct file *parfilp,\r\nvoid __user *arg)\r\n{\r\nint error;\r\nxfs_attr_multiop_t *ops;\r\nxfs_fsop_attrmulti_handlereq_t am_hreq;\r\nstruct dentry *dentry;\r\nunsigned int i, size;\r\nunsigned char *attr_name;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\r\nreturn -EFAULT;\r\nif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\r\nreturn -E2BIG;\r\ndentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nerror = -E2BIG;\r\nsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\r\nif (!size || size > 16 * PAGE_SIZE)\r\ngoto out_dput;\r\nops = memdup_user(am_hreq.ops, size);\r\nif (IS_ERR(ops)) {\r\nerror = PTR_ERR(ops);\r\ngoto out_dput;\r\n}\r\nerror = -ENOMEM;\r\nattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\r\nif (!attr_name)\r\ngoto out_kfree_ops;\r\nerror = 0;\r\nfor (i = 0; i < am_hreq.opcount; i++) {\r\nops[i].am_error = strncpy_from_user((char *)attr_name,\r\nops[i].am_attrname, MAXNAMELEN);\r\nif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\r\nerror = -ERANGE;\r\nif (ops[i].am_error < 0)\r\nbreak;\r\nswitch (ops[i].am_opcode) {\r\ncase ATTR_OP_GET:\r\nops[i].am_error = xfs_attrmulti_attr_get(\r\nd_inode(dentry), attr_name,\r\nops[i].am_attrvalue, &ops[i].am_length,\r\nops[i].am_flags);\r\nbreak;\r\ncase ATTR_OP_SET:\r\nops[i].am_error = mnt_want_write_file(parfilp);\r\nif (ops[i].am_error)\r\nbreak;\r\nops[i].am_error = xfs_attrmulti_attr_set(\r\nd_inode(dentry), attr_name,\r\nops[i].am_attrvalue, ops[i].am_length,\r\nops[i].am_flags);\r\nmnt_drop_write_file(parfilp);\r\nbreak;\r\ncase ATTR_OP_REMOVE:\r\nops[i].am_error = mnt_want_write_file(parfilp);\r\nif (ops[i].am_error)\r\nbreak;\r\nops[i].am_error = xfs_attrmulti_attr_remove(\r\nd_inode(dentry), attr_name,\r\nops[i].am_flags);\r\nmnt_drop_write_file(parfilp);\r\nbreak;\r\ndefault:\r\nops[i].am_error = -EINVAL;\r\n}\r\n}\r\nif (copy_to_user(am_hreq.ops, ops, size))\r\nerror = -EFAULT;\r\nkfree(attr_name);\r\nout_kfree_ops:\r\nkfree(ops);\r\nout_dput:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nint\r\nxfs_ioc_space(\r\nstruct xfs_inode *ip,\r\nstruct inode *inode,\r\nstruct file *filp,\r\nint ioflags,\r\nunsigned int cmd,\r\nxfs_flock64_t *bf)\r\n{\r\nstruct iattr iattr;\r\nenum xfs_prealloc_flags flags = 0;\r\nuint iolock = XFS_IOLOCK_EXCL;\r\nint error;\r\nif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\r\n!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\r\nreturn -EPERM;\r\nif (!(filp->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EINVAL;\r\nif (filp->f_flags & O_DSYNC)\r\nflags |= XFS_PREALLOC_SYNC;\r\nif (ioflags & XFS_IO_INVIS)\r\nflags |= XFS_PREALLOC_INVISIBLE;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, iolock);\r\nerror = xfs_break_layouts(inode, &iolock, false);\r\nif (error)\r\ngoto out_unlock;\r\nxfs_ilock(ip, XFS_MMAPLOCK_EXCL);\r\niolock |= XFS_MMAPLOCK_EXCL;\r\nswitch (bf->l_whence) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nbf->l_start += filp->f_pos;\r\nbreak;\r\ncase 2:\r\nbf->l_start += XFS_ISIZE(ip);\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nswitch (cmd) {\r\ncase XFS_IOC_ZERO_RANGE:\r\ncase XFS_IOC_RESVSP:\r\ncase XFS_IOC_RESVSP64:\r\ncase XFS_IOC_UNRESVSP:\r\ncase XFS_IOC_UNRESVSP64:\r\nif (bf->l_len <= 0) {\r\nerror = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nbreak;\r\ndefault:\r\nbf->l_len = 0;\r\nbreak;\r\n}\r\nif (bf->l_start < 0 ||\r\nbf->l_start > inode->i_sb->s_maxbytes ||\r\nbf->l_start + bf->l_len < 0 ||\r\nbf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\r\nerror = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nswitch (cmd) {\r\ncase XFS_IOC_ZERO_RANGE:\r\nflags |= XFS_PREALLOC_SET;\r\nerror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\r\nbreak;\r\ncase XFS_IOC_RESVSP:\r\ncase XFS_IOC_RESVSP64:\r\nflags |= XFS_PREALLOC_SET;\r\nerror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\r\nXFS_BMAPI_PREALLOC);\r\nbreak;\r\ncase XFS_IOC_UNRESVSP:\r\ncase XFS_IOC_UNRESVSP64:\r\nerror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\r\nbreak;\r\ncase XFS_IOC_ALLOCSP:\r\ncase XFS_IOC_ALLOCSP64:\r\ncase XFS_IOC_FREESP:\r\ncase XFS_IOC_FREESP64:\r\nflags |= XFS_PREALLOC_CLEAR;\r\nif (bf->l_start > XFS_ISIZE(ip)) {\r\nerror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\r\nbf->l_start - XFS_ISIZE(ip), 0);\r\nif (error)\r\ngoto out_unlock;\r\n}\r\niattr.ia_valid = ATTR_SIZE;\r\niattr.ia_size = bf->l_start;\r\nerror = xfs_setattr_size(ip, &iattr);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nerror = -EINVAL;\r\n}\r\nif (error)\r\ngoto out_unlock;\r\nerror = xfs_update_prealloc_flags(ip, flags);\r\nout_unlock:\r\nxfs_iunlock(ip, iolock);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_ioc_bulkstat(\r\nxfs_mount_t *mp,\r\nunsigned int cmd,\r\nvoid __user *arg)\r\n{\r\nxfs_fsop_bulkreq_t bulkreq;\r\nint count;\r\nxfs_ino_t inlast;\r\nint done;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nif (copy_from_user(&bulkreq, arg, sizeof(xfs_fsop_bulkreq_t)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\r\nreturn -EFAULT;\r\nif ((count = bulkreq.icount) <= 0)\r\nreturn -EINVAL;\r\nif (bulkreq.ubuffer == NULL)\r\nreturn -EINVAL;\r\nif (cmd == XFS_IOC_FSINUMBERS)\r\nerror = xfs_inumbers(mp, &inlast, &count,\r\nbulkreq.ubuffer, xfs_inumbers_fmt);\r\nelse if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)\r\nerror = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,\r\nsizeof(xfs_bstat_t), NULL, &done);\r\nelse\r\nerror = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,\r\nsizeof(xfs_bstat_t), bulkreq.ubuffer,\r\n&done);\r\nif (error)\r\nreturn error;\r\nif (bulkreq.ocount != NULL) {\r\nif (copy_to_user(bulkreq.lastip, &inlast,\r\nsizeof(xfs_ino_t)))\r\nreturn -EFAULT;\r\nif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioc_fsgeometry_v1(\r\nxfs_mount_t *mp,\r\nvoid __user *arg)\r\n{\r\nxfs_fsop_geom_t fsgeo;\r\nint error;\r\nerror = xfs_fs_geometry(mp, &fsgeo, 3);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioc_fsgeometry(\r\nxfs_mount_t *mp,\r\nvoid __user *arg)\r\n{\r\nxfs_fsop_geom_t fsgeo;\r\nint error;\r\nerror = xfs_fs_geometry(mp, &fsgeo, 4);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC unsigned int\r\nxfs_merge_ioc_xflags(\r\nunsigned int flags,\r\nunsigned int start)\r\n{\r\nunsigned int xflags = start;\r\nif (flags & FS_IMMUTABLE_FL)\r\nxflags |= XFS_XFLAG_IMMUTABLE;\r\nelse\r\nxflags &= ~XFS_XFLAG_IMMUTABLE;\r\nif (flags & FS_APPEND_FL)\r\nxflags |= XFS_XFLAG_APPEND;\r\nelse\r\nxflags &= ~XFS_XFLAG_APPEND;\r\nif (flags & FS_SYNC_FL)\r\nxflags |= XFS_XFLAG_SYNC;\r\nelse\r\nxflags &= ~XFS_XFLAG_SYNC;\r\nif (flags & FS_NOATIME_FL)\r\nxflags |= XFS_XFLAG_NOATIME;\r\nelse\r\nxflags &= ~XFS_XFLAG_NOATIME;\r\nif (flags & FS_NODUMP_FL)\r\nxflags |= XFS_XFLAG_NODUMP;\r\nelse\r\nxflags &= ~XFS_XFLAG_NODUMP;\r\nreturn xflags;\r\n}\r\nSTATIC unsigned int\r\nxfs_di2lxflags(\r\n__uint16_t di_flags)\r\n{\r\nunsigned int flags = 0;\r\nif (di_flags & XFS_DIFLAG_IMMUTABLE)\r\nflags |= FS_IMMUTABLE_FL;\r\nif (di_flags & XFS_DIFLAG_APPEND)\r\nflags |= FS_APPEND_FL;\r\nif (di_flags & XFS_DIFLAG_SYNC)\r\nflags |= FS_SYNC_FL;\r\nif (di_flags & XFS_DIFLAG_NOATIME)\r\nflags |= FS_NOATIME_FL;\r\nif (di_flags & XFS_DIFLAG_NODUMP)\r\nflags |= FS_NODUMP_FL;\r\nreturn flags;\r\n}\r\nSTATIC int\r\nxfs_ioc_fsgetxattr(\r\nxfs_inode_t *ip,\r\nint attr,\r\nvoid __user *arg)\r\n{\r\nstruct fsxattr fa;\r\nmemset(&fa, 0, sizeof(struct fsxattr));\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\nfa.fsx_xflags = xfs_ip2xflags(ip);\r\nfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\r\nfa.fsx_projid = xfs_get_projid(ip);\r\nif (attr) {\r\nif (ip->i_afp) {\r\nif (ip->i_afp->if_flags & XFS_IFEXTENTS)\r\nfa.fsx_nextents = ip->i_afp->if_bytes /\r\nsizeof(xfs_bmbt_rec_t);\r\nelse\r\nfa.fsx_nextents = ip->i_d.di_anextents;\r\n} else\r\nfa.fsx_nextents = 0;\r\n} else {\r\nif (ip->i_df.if_flags & XFS_IFEXTENTS)\r\nfa.fsx_nextents = ip->i_df.if_bytes /\r\nsizeof(xfs_bmbt_rec_t);\r\nelse\r\nfa.fsx_nextents = ip->i_d.di_nextents;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nif (copy_to_user(arg, &fa, sizeof(fa)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_set_diflags(\r\nstruct xfs_inode *ip,\r\nunsigned int xflags)\r\n{\r\nunsigned int di_flags;\r\ndi_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);\r\nif (xflags & XFS_XFLAG_IMMUTABLE)\r\ndi_flags |= XFS_DIFLAG_IMMUTABLE;\r\nif (xflags & XFS_XFLAG_APPEND)\r\ndi_flags |= XFS_DIFLAG_APPEND;\r\nif (xflags & XFS_XFLAG_SYNC)\r\ndi_flags |= XFS_DIFLAG_SYNC;\r\nif (xflags & XFS_XFLAG_NOATIME)\r\ndi_flags |= XFS_DIFLAG_NOATIME;\r\nif (xflags & XFS_XFLAG_NODUMP)\r\ndi_flags |= XFS_DIFLAG_NODUMP;\r\nif (xflags & XFS_XFLAG_NODEFRAG)\r\ndi_flags |= XFS_DIFLAG_NODEFRAG;\r\nif (xflags & XFS_XFLAG_FILESTREAM)\r\ndi_flags |= XFS_DIFLAG_FILESTREAM;\r\nif (S_ISDIR(ip->i_d.di_mode)) {\r\nif (xflags & XFS_XFLAG_RTINHERIT)\r\ndi_flags |= XFS_DIFLAG_RTINHERIT;\r\nif (xflags & XFS_XFLAG_NOSYMLINKS)\r\ndi_flags |= XFS_DIFLAG_NOSYMLINKS;\r\nif (xflags & XFS_XFLAG_EXTSZINHERIT)\r\ndi_flags |= XFS_DIFLAG_EXTSZINHERIT;\r\nif (xflags & XFS_XFLAG_PROJINHERIT)\r\ndi_flags |= XFS_DIFLAG_PROJINHERIT;\r\n} else if (S_ISREG(ip->i_d.di_mode)) {\r\nif (xflags & XFS_XFLAG_REALTIME)\r\ndi_flags |= XFS_DIFLAG_REALTIME;\r\nif (xflags & XFS_XFLAG_EXTSIZE)\r\ndi_flags |= XFS_DIFLAG_EXTSIZE;\r\n}\r\nip->i_d.di_flags = di_flags;\r\n}\r\nSTATIC void\r\nxfs_diflags_to_linux(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct inode *inode = VFS_I(ip);\r\nunsigned int xflags = xfs_ip2xflags(ip);\r\nif (xflags & XFS_XFLAG_IMMUTABLE)\r\ninode->i_flags |= S_IMMUTABLE;\r\nelse\r\ninode->i_flags &= ~S_IMMUTABLE;\r\nif (xflags & XFS_XFLAG_APPEND)\r\ninode->i_flags |= S_APPEND;\r\nelse\r\ninode->i_flags &= ~S_APPEND;\r\nif (xflags & XFS_XFLAG_SYNC)\r\ninode->i_flags |= S_SYNC;\r\nelse\r\ninode->i_flags &= ~S_SYNC;\r\nif (xflags & XFS_XFLAG_NOATIME)\r\ninode->i_flags |= S_NOATIME;\r\nelse\r\ninode->i_flags &= ~S_NOATIME;\r\n}\r\nstatic int\r\nxfs_ioctl_setattr_xflags(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *ip,\r\nstruct fsxattr *fa)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\r\nXFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\r\nreturn -EINVAL;\r\nif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\r\nif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\r\n(ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\r\nreturn -EINVAL;\r\n}\r\nif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\r\n(fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\r\n!capable(CAP_LINUX_IMMUTABLE))\r\nreturn -EPERM;\r\nxfs_set_diflags(ip, fa->fsx_xflags);\r\nxfs_diflags_to_linux(ip);\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nXFS_STATS_INC(xs_ig_attrchg);\r\nreturn 0;\r\n}\r\nstatic struct xfs_trans *\r\nxfs_ioctl_setattr_get_trans(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nint error;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn ERR_PTR(-EROFS);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn ERR_PTR(-EIO);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\r\nif (error)\r\ngoto out_cancel;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nif (!inode_owner_or_capable(VFS_I(ip))) {\r\nerror = -EPERM;\r\ngoto out_cancel;\r\n}\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nreturn tp;\r\nout_cancel:\r\nxfs_trans_cancel(tp);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int\r\nxfs_ioctl_setattr_check_extsize(\r\nstruct xfs_inode *ip,\r\nstruct fsxattr *fa)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nif ((fa->fsx_xflags & XFS_XFLAG_EXTSIZE) && !S_ISREG(ip->i_d.di_mode))\r\nreturn -EINVAL;\r\nif ((fa->fsx_xflags & XFS_XFLAG_EXTSZINHERIT) &&\r\n!S_ISDIR(ip->i_d.di_mode))\r\nreturn -EINVAL;\r\nif (S_ISREG(ip->i_d.di_mode) && ip->i_d.di_nextents &&\r\n((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))\r\nreturn -EINVAL;\r\nif (fa->fsx_extsize != 0) {\r\nxfs_extlen_t size;\r\nxfs_fsblock_t extsize_fsb;\r\nextsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\r\nif (extsize_fsb > MAXEXTLEN)\r\nreturn -EINVAL;\r\nif (XFS_IS_REALTIME_INODE(ip) ||\r\n(fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\r\nsize = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\r\n} else {\r\nsize = mp->m_sb.sb_blocksize;\r\nif (extsize_fsb > mp->m_sb.sb_agblocks / 2)\r\nreturn -EINVAL;\r\n}\r\nif (fa->fsx_extsize % size)\r\nreturn -EINVAL;\r\n} else\r\nfa->fsx_xflags &= ~(XFS_XFLAG_EXTSIZE | XFS_XFLAG_EXTSZINHERIT);\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_ioctl_setattr_check_projid(\r\nstruct xfs_inode *ip,\r\nstruct fsxattr *fa)\r\n{\r\nif (fa->fsx_projid > (__uint16_t)-1 &&\r\n!xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\r\nreturn -EINVAL;\r\nif (current_user_ns() == &init_user_ns)\r\nreturn 0;\r\nif (xfs_get_projid(ip) != fa->fsx_projid)\r\nreturn -EINVAL;\r\nif ((fa->fsx_xflags & XFS_XFLAG_PROJINHERIT) !=\r\n(ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioctl_setattr(\r\nxfs_inode_t *ip,\r\nstruct fsxattr *fa)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nstruct xfs_dquot *udqp = NULL;\r\nstruct xfs_dquot *pdqp = NULL;\r\nstruct xfs_dquot *olddquot = NULL;\r\nint code;\r\ntrace_xfs_ioctl_setattr(ip);\r\ncode = xfs_ioctl_setattr_check_projid(ip, fa);\r\nif (code)\r\nreturn code;\r\nif (XFS_IS_QUOTA_ON(mp)) {\r\ncode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\r\nip->i_d.di_gid, fa->fsx_projid,\r\nXFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\r\nif (code)\r\nreturn code;\r\n}\r\ntp = xfs_ioctl_setattr_get_trans(ip);\r\nif (IS_ERR(tp)) {\r\ncode = PTR_ERR(tp);\r\ngoto error_free_dquots;\r\n}\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&\r\nxfs_get_projid(ip) != fa->fsx_projid) {\r\ncode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,\r\ncapable(CAP_FOWNER) ? XFS_QMOPT_FORCE_RES : 0);\r\nif (code)\r\ngoto error_trans_cancel;\r\n}\r\ncode = xfs_ioctl_setattr_check_extsize(ip, fa);\r\nif (code)\r\ngoto error_trans_cancel;\r\ncode = xfs_ioctl_setattr_xflags(tp, ip, fa);\r\nif (code)\r\ngoto error_trans_cancel;\r\nif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\r\n!capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\r\nip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\r\nif (xfs_get_projid(ip) != fa->fsx_projid) {\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\r\nolddquot = xfs_qm_vop_chown(tp, ip,\r\n&ip->i_pdquot, pdqp);\r\n}\r\nASSERT(ip->i_d.di_version > 1);\r\nxfs_set_projid(ip, fa->fsx_projid);\r\n}\r\nif (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\r\nip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\r\nelse\r\nip->i_d.di_extsize = 0;\r\ncode = xfs_trans_commit(tp);\r\nxfs_qm_dqrele(olddquot);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(pdqp);\r\nreturn code;\r\nerror_trans_cancel:\r\nxfs_trans_cancel(tp);\r\nerror_free_dquots:\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(pdqp);\r\nreturn code;\r\n}\r\nSTATIC int\r\nxfs_ioc_fssetxattr(\r\nxfs_inode_t *ip,\r\nstruct file *filp,\r\nvoid __user *arg)\r\n{\r\nstruct fsxattr fa;\r\nint error;\r\nif (copy_from_user(&fa, arg, sizeof(fa)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_ioctl_setattr(ip, &fa);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_ioc_getxflags(\r\nxfs_inode_t *ip,\r\nvoid __user *arg)\r\n{\r\nunsigned int flags;\r\nflags = xfs_di2lxflags(ip->i_d.di_flags);\r\nif (copy_to_user(arg, &flags, sizeof(flags)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioc_setxflags(\r\nstruct xfs_inode *ip,\r\nstruct file *filp,\r\nvoid __user *arg)\r\n{\r\nstruct xfs_trans *tp;\r\nstruct fsxattr fa;\r\nunsigned int flags;\r\nint error;\r\nif (copy_from_user(&flags, arg, sizeof(flags)))\r\nreturn -EFAULT;\r\nif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\r\nFS_NOATIME_FL | FS_NODUMP_FL | \\r\nFS_SYNC_FL))\r\nreturn -EOPNOTSUPP;\r\nfa.fsx_xflags = xfs_merge_ioc_xflags(flags, xfs_ip2xflags(ip));\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\ntp = xfs_ioctl_setattr_get_trans(ip);\r\nif (IS_ERR(tp)) {\r\nerror = PTR_ERR(tp);\r\ngoto out_drop_write;\r\n}\r\nerror = xfs_ioctl_setattr_xflags(tp, ip, &fa);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\ngoto out_drop_write;\r\n}\r\nerror = xfs_trans_commit(tp);\r\nout_drop_write:\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_getbmap_format(void **ap, struct getbmapx *bmv, int *full)\r\n{\r\nstruct getbmap __user *base = (struct getbmap __user *)*ap;\r\nif (copy_to_user(base, bmv, sizeof(struct getbmap)))\r\nreturn -EFAULT;\r\n*ap += sizeof(struct getbmap);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioc_getbmap(\r\nstruct xfs_inode *ip,\r\nint ioflags,\r\nunsigned int cmd,\r\nvoid __user *arg)\r\n{\r\nstruct getbmapx bmx;\r\nint error;\r\nif (copy_from_user(&bmx, arg, sizeof(struct getbmapx)))\r\nreturn -EFAULT;\r\nif (bmx.bmv_count < 2)\r\nreturn -EINVAL;\r\nbmx.bmv_iflags = (cmd == XFS_IOC_GETBMAPA ? BMV_IF_ATTRFORK : 0);\r\nif (ioflags & XFS_IO_INVIS)\r\nbmx.bmv_iflags |= BMV_IF_NO_DMAPI_READ;\r\nerror = xfs_getbmap(ip, &bmx, xfs_getbmap_format,\r\n(__force struct getbmap *)arg+1);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &bmx, sizeof(struct getbmap)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_getbmapx_format(void **ap, struct getbmapx *bmv, int *full)\r\n{\r\nstruct getbmapx __user *base = (struct getbmapx __user *)*ap;\r\nif (copy_to_user(base, bmv, sizeof(struct getbmapx)))\r\nreturn -EFAULT;\r\n*ap += sizeof(struct getbmapx);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_ioc_getbmapx(\r\nstruct xfs_inode *ip,\r\nvoid __user *arg)\r\n{\r\nstruct getbmapx bmx;\r\nint error;\r\nif (copy_from_user(&bmx, arg, sizeof(bmx)))\r\nreturn -EFAULT;\r\nif (bmx.bmv_count < 2)\r\nreturn -EINVAL;\r\nif (bmx.bmv_iflags & (~BMV_IF_VALID))\r\nreturn -EINVAL;\r\nerror = xfs_getbmap(ip, &bmx, xfs_getbmapx_format,\r\n(__force struct getbmapx *)arg+1);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &bmx, sizeof(struct getbmapx)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint\r\nxfs_ioc_swapext(\r\nxfs_swapext_t *sxp)\r\n{\r\nxfs_inode_t *ip, *tip;\r\nstruct fd f, tmp;\r\nint error = 0;\r\nf = fdget((int)sxp->sx_fdtarget);\r\nif (!f.file) {\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nif (!(f.file->f_mode & FMODE_WRITE) ||\r\n!(f.file->f_mode & FMODE_READ) ||\r\n(f.file->f_flags & O_APPEND)) {\r\nerror = -EBADF;\r\ngoto out_put_file;\r\n}\r\ntmp = fdget((int)sxp->sx_fdtmp);\r\nif (!tmp.file) {\r\nerror = -EINVAL;\r\ngoto out_put_file;\r\n}\r\nif (!(tmp.file->f_mode & FMODE_WRITE) ||\r\n!(tmp.file->f_mode & FMODE_READ) ||\r\n(tmp.file->f_flags & O_APPEND)) {\r\nerror = -EBADF;\r\ngoto out_put_tmp_file;\r\n}\r\nif (IS_SWAPFILE(file_inode(f.file)) ||\r\nIS_SWAPFILE(file_inode(tmp.file))) {\r\nerror = -EINVAL;\r\ngoto out_put_tmp_file;\r\n}\r\nip = XFS_I(file_inode(f.file));\r\ntip = XFS_I(file_inode(tmp.file));\r\nif (ip->i_mount != tip->i_mount) {\r\nerror = -EINVAL;\r\ngoto out_put_tmp_file;\r\n}\r\nif (ip->i_ino == tip->i_ino) {\r\nerror = -EINVAL;\r\ngoto out_put_tmp_file;\r\n}\r\nif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\r\nerror = -EIO;\r\ngoto out_put_tmp_file;\r\n}\r\nerror = xfs_swap_extents(ip, tip, sxp);\r\nout_put_tmp_file:\r\nfdput(tmp);\r\nout_put_file:\r\nfdput(f);\r\nout:\r\nreturn error;\r\n}\r\nlong\r\nxfs_file_ioctl(\r\nstruct file *filp,\r\nunsigned int cmd,\r\nunsigned long p)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nvoid __user *arg = (void __user *)p;\r\nint ioflags = 0;\r\nint error;\r\nif (filp->f_mode & FMODE_NOCMTIME)\r\nioflags |= XFS_IO_INVIS;\r\ntrace_xfs_file_ioctl(ip);\r\nswitch (cmd) {\r\ncase FITRIM:\r\nreturn xfs_ioc_trim(mp, arg);\r\ncase XFS_IOC_ALLOCSP:\r\ncase XFS_IOC_FREESP:\r\ncase XFS_IOC_RESVSP:\r\ncase XFS_IOC_UNRESVSP:\r\ncase XFS_IOC_ALLOCSP64:\r\ncase XFS_IOC_FREESP64:\r\ncase XFS_IOC_RESVSP64:\r\ncase XFS_IOC_UNRESVSP64:\r\ncase XFS_IOC_ZERO_RANGE: {\r\nxfs_flock64_t bf;\r\nif (copy_from_user(&bf, arg, sizeof(bf)))\r\nreturn -EFAULT;\r\nreturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\r\n}\r\ncase XFS_IOC_DIOINFO: {\r\nstruct dioattr da;\r\nxfs_buftarg_t *target =\r\nXFS_IS_REALTIME_INODE(ip) ?\r\nmp->m_rtdev_targp : mp->m_ddev_targp;\r\nda.d_mem = da.d_miniosz = target->bt_logical_sectorsize;\r\nda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\r\nif (copy_to_user(arg, &da, sizeof(da)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase XFS_IOC_FSBULKSTAT_SINGLE:\r\ncase XFS_IOC_FSBULKSTAT:\r\ncase XFS_IOC_FSINUMBERS:\r\nreturn xfs_ioc_bulkstat(mp, cmd, arg);\r\ncase XFS_IOC_FSGEOMETRY_V1:\r\nreturn xfs_ioc_fsgeometry_v1(mp, arg);\r\ncase XFS_IOC_FSGEOMETRY:\r\nreturn xfs_ioc_fsgeometry(mp, arg);\r\ncase XFS_IOC_GETVERSION:\r\nreturn put_user(inode->i_generation, (int __user *)arg);\r\ncase XFS_IOC_FSGETXATTR:\r\nreturn xfs_ioc_fsgetxattr(ip, 0, arg);\r\ncase XFS_IOC_FSGETXATTRA:\r\nreturn xfs_ioc_fsgetxattr(ip, 1, arg);\r\ncase XFS_IOC_FSSETXATTR:\r\nreturn xfs_ioc_fssetxattr(ip, filp, arg);\r\ncase XFS_IOC_GETXFLAGS:\r\nreturn xfs_ioc_getxflags(ip, arg);\r\ncase XFS_IOC_SETXFLAGS:\r\nreturn xfs_ioc_setxflags(ip, filp, arg);\r\ncase XFS_IOC_FSSETDM: {\r\nstruct fsdmidata dmi;\r\nif (copy_from_user(&dmi, arg, sizeof(dmi)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_set_dmattrs(ip, dmi.fsd_dmevmask,\r\ndmi.fsd_dmstate);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_GETBMAP:\r\ncase XFS_IOC_GETBMAPA:\r\nreturn xfs_ioc_getbmap(ip, ioflags, cmd, arg);\r\ncase XFS_IOC_GETBMAPX:\r\nreturn xfs_ioc_getbmapx(ip, arg);\r\ncase XFS_IOC_FD_TO_HANDLE:\r\ncase XFS_IOC_PATH_TO_HANDLE:\r\ncase XFS_IOC_PATH_TO_FSHANDLE: {\r\nxfs_fsop_handlereq_t hreq;\r\nif (copy_from_user(&hreq, arg, sizeof(hreq)))\r\nreturn -EFAULT;\r\nreturn xfs_find_handle(cmd, &hreq);\r\n}\r\ncase XFS_IOC_OPEN_BY_HANDLE: {\r\nxfs_fsop_handlereq_t hreq;\r\nif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\r\nreturn -EFAULT;\r\nreturn xfs_open_by_handle(filp, &hreq);\r\n}\r\ncase XFS_IOC_FSSETDM_BY_HANDLE:\r\nreturn xfs_fssetdm_by_handle(filp, arg);\r\ncase XFS_IOC_READLINK_BY_HANDLE: {\r\nxfs_fsop_handlereq_t hreq;\r\nif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\r\nreturn -EFAULT;\r\nreturn xfs_readlink_by_handle(filp, &hreq);\r\n}\r\ncase XFS_IOC_ATTRLIST_BY_HANDLE:\r\nreturn xfs_attrlist_by_handle(filp, arg);\r\ncase XFS_IOC_ATTRMULTI_BY_HANDLE:\r\nreturn xfs_attrmulti_by_handle(filp, arg);\r\ncase XFS_IOC_SWAPEXT: {\r\nstruct xfs_swapext sxp;\r\nif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_ioc_swapext(&sxp);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_FSCOUNTS: {\r\nxfs_fsop_counts_t out;\r\nerror = xfs_fs_counts(mp, &out);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &out, sizeof(out)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase XFS_IOC_SET_RESBLKS: {\r\nxfs_fsop_resblks_t inout;\r\n__uint64_t in;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn -EROFS;\r\nif (copy_from_user(&inout, arg, sizeof(inout)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nin = inout.resblks;\r\nerror = xfs_reserve_blocks(mp, &in, &inout);\r\nmnt_drop_write_file(filp);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &inout, sizeof(inout)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase XFS_IOC_GET_RESBLKS: {\r\nxfs_fsop_resblks_t out;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerror = xfs_reserve_blocks(mp, NULL, &out);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &out, sizeof(out)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase XFS_IOC_FSGROWFSDATA: {\r\nxfs_growfs_data_t in;\r\nif (copy_from_user(&in, arg, sizeof(in)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_growfs_data(mp, &in);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_FSGROWFSLOG: {\r\nxfs_growfs_log_t in;\r\nif (copy_from_user(&in, arg, sizeof(in)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_growfs_log(mp, &in);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_FSGROWFSRT: {\r\nxfs_growfs_rt_t in;\r\nif (copy_from_user(&in, arg, sizeof(in)))\r\nreturn -EFAULT;\r\nerror = mnt_want_write_file(filp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_growfs_rt(mp, &in);\r\nmnt_drop_write_file(filp);\r\nreturn error;\r\n}\r\ncase XFS_IOC_GOINGDOWN: {\r\n__uint32_t in;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(in, (__uint32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn xfs_fs_goingdown(mp, in);\r\n}\r\ncase XFS_IOC_ERROR_INJECTION: {\r\nxfs_error_injection_t in;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&in, arg, sizeof(in)))\r\nreturn -EFAULT;\r\nreturn xfs_errortag_add(in.errtag, mp);\r\n}\r\ncase XFS_IOC_ERROR_CLEARALL:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn xfs_errortag_clearall(mp, 1);\r\ncase XFS_IOC_FREE_EOFBLOCKS: {\r\nstruct xfs_fs_eofblocks eofb;\r\nstruct xfs_eofblocks keofb;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn -EROFS;\r\nif (copy_from_user(&eofb, arg, sizeof(eofb)))\r\nreturn -EFAULT;\r\nerror = xfs_fs_eofblocks_from_user(&eofb, &keofb);\r\nif (error)\r\nreturn error;\r\nreturn xfs_icache_free_eofblocks(mp, &keofb);\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}
