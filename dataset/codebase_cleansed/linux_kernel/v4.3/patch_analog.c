static int create_beep_ctls(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nconst struct snd_kcontrol_new *knew;\r\nif (!spec->beep_amp)\r\nreturn 0;\r\nfor (knew = ad_beep_mixer ; knew->name; knew++) {\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(knew, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = spec->beep_amp;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ad198x_power_eapd_write(struct hda_codec *codec, hda_nid_t front,\r\nhda_nid_t hp)\r\n{\r\nif (snd_hda_query_pin_caps(codec, front) & AC_PINCAP_EAPD)\r\nsnd_hda_codec_write(codec, front, 0, AC_VERB_SET_EAPD_BTLENABLE,\r\n!codec->inv_eapd ? 0x00 : 0x02);\r\nif (snd_hda_query_pin_caps(codec, hp) & AC_PINCAP_EAPD)\r\nsnd_hda_codec_write(codec, hp, 0, AC_VERB_SET_EAPD_BTLENABLE,\r\n!codec->inv_eapd ? 0x00 : 0x02);\r\n}\r\nstatic void ad198x_power_eapd(struct hda_codec *codec)\r\n{\r\nswitch (codec->core.vendor_id) {\r\ncase 0x11d41882:\r\ncase 0x11d4882a:\r\ncase 0x11d41884:\r\ncase 0x11d41984:\r\ncase 0x11d41883:\r\ncase 0x11d4184a:\r\ncase 0x11d4194a:\r\ncase 0x11d4194b:\r\ncase 0x11d41988:\r\ncase 0x11d4198b:\r\ncase 0x11d4989a:\r\ncase 0x11d4989b:\r\nad198x_power_eapd_write(codec, 0x12, 0x11);\r\nbreak;\r\ncase 0x11d41981:\r\ncase 0x11d41983:\r\nad198x_power_eapd_write(codec, 0x05, 0x06);\r\nbreak;\r\ncase 0x11d41986:\r\nad198x_power_eapd_write(codec, 0x1b, 0x1a);\r\nbreak;\r\n}\r\n}\r\nstatic void ad198x_shutup(struct hda_codec *codec)\r\n{\r\nsnd_hda_shutup_pins(codec);\r\nad198x_power_eapd(codec);\r\n}\r\nstatic int ad198x_suspend(struct hda_codec *codec)\r\n{\r\nad198x_shutup(codec);\r\nreturn 0;\r\n}\r\nstatic void ad_vmaster_eapd_hook(void *private_data, int enabled)\r\n{\r\nstruct hda_codec *codec = private_data;\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (!spec->eapd_nid)\r\nreturn;\r\nif (codec->inv_eapd)\r\nenabled = !enabled;\r\nsnd_hda_codec_update_cache(codec, spec->eapd_nid, 0,\r\nAC_VERB_SET_EAPD_BTLENABLE,\r\nenabled ? 0x02 : 0x00);\r\n}\r\nstatic int ad198x_auto_build_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_beep_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ad198x_parse_auto_config(struct hda_codec *codec, bool indep_hp)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nint err;\r\ncodec->spdif_status_reset = 1;\r\ncodec->no_trigger_sense = 1;\r\ncodec->no_sticky_stream = 1;\r\nspec->gen.indep_hp = indep_hp;\r\nif (!spec->gen.add_stereo_mix_input)\r\nspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\r\nerr = snd_hda_parse_pin_defcfg(codec, cfg, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_gen_parse_auto_config(codec, cfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int alloc_ad_spec(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\ncodec->patch_ops = ad198x_auto_patch_ops;\r\nreturn 0;\r\n}\r\nstatic void ad_fixup_inv_jack_detect(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\ncodec->inv_jack_detect = 1;\r\nspec->gen.keep_eapd_on = 1;\r\nspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\r\nspec->eapd_nid = 0x1b;\r\n}\r\n}\r\nstatic void ad1986a_fixup_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\ncodec->inv_eapd = 0;\r\nspec->gen.keep_eapd_on = 1;\r\nspec->eapd_nid = 0x1b;\r\n}\r\n}\r\nstatic void ad1986a_fixup_eapd_mix_in(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nad1986a_fixup_eapd(codec, fix, action);\r\nspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_ENABLE;\r\n}\r\n}\r\nstatic int patch_ad1986a(struct hda_codec *codec)\r\n{\r\nint err;\r\nstruct ad198x_spec *spec;\r\nstatic hda_nid_t preferred_pairs[] = {\r\n0x1a, 0x03,\r\n0x1b, 0x03,\r\n0x1c, 0x04,\r\n0x1d, 0x05,\r\n0x1e, 0x03,\r\n0\r\n};\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\ncodec->inv_eapd = 1;\r\nspec->gen.mixer_nid = 0x07;\r\nspec->gen.beep_nid = 0x19;\r\nset_beep_amp(spec, 0x18, 0, HDA_OUTPUT);\r\nspec->gen.multiout.no_share_stream = 1;\r\nspec->gen.preferred_dacs = preferred_pairs;\r\nspec->gen.auto_mute_via_amp = 1;\r\nsnd_hda_pick_fixup(codec, ad1986a_fixup_models, ad1986a_fixup_tbl,\r\nad1986a_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = ad198x_parse_auto_config(codec, false);\r\nif (err < 0) {\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int ad1983_auto_smux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ad198x_spec *spec = codec->spec;\r\nstatic const char * const texts2[] = { "PCM", "ADC" };\r\nstatic const char * const texts3[] = { "PCM", "ADC1", "ADC2" };\r\nhda_nid_t dig_out = spec->gen.multiout.dig_out_nid;\r\nint num_conns = snd_hda_get_num_conns(codec, dig_out);\r\nif (num_conns == 2)\r\nreturn snd_hda_enum_helper_info(kcontrol, uinfo, 2, texts2);\r\nelse if (num_conns == 3)\r\nreturn snd_hda_enum_helper_info(kcontrol, uinfo, 3, texts3);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int ad1983_auto_smux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ad198x_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->cur_smux;\r\nreturn 0;\r\n}\r\nstatic int ad1983_auto_smux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ad198x_spec *spec = codec->spec;\r\nunsigned int val = ucontrol->value.enumerated.item[0];\r\nhda_nid_t dig_out = spec->gen.multiout.dig_out_nid;\r\nint num_conns = snd_hda_get_num_conns(codec, dig_out);\r\nif (val >= num_conns)\r\nreturn -EINVAL;\r\nif (spec->cur_smux == val)\r\nreturn 0;\r\nspec->cur_smux = val;\r\nsnd_hda_codec_write_cache(codec, dig_out, 0,\r\nAC_VERB_SET_CONNECT_SEL, val);\r\nreturn 1;\r\n}\r\nstatic int ad1983_add_spdif_mux_ctl(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nhda_nid_t dig_out = spec->gen.multiout.dig_out_nid;\r\nint num_conns;\r\nif (!dig_out)\r\nreturn 0;\r\nnum_conns = snd_hda_get_num_conns(codec, dig_out);\r\nif (num_conns != 2 && num_conns != 3)\r\nreturn 0;\r\nif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &ad1983_auto_smux_mixer))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int patch_ad1983(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nstatic hda_nid_t conn_0c[] = { 0x08 };\r\nstatic hda_nid_t conn_0d[] = { 0x09 };\r\nint err;\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->gen.mixer_nid = 0x0e;\r\nspec->gen.beep_nid = 0x10;\r\nset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\r\nsnd_hda_override_conn_list(codec, 0x0c, ARRAY_SIZE(conn_0c), conn_0c);\r\nsnd_hda_override_conn_list(codec, 0x0d, ARRAY_SIZE(conn_0d), conn_0d);\r\nerr = ad198x_parse_auto_config(codec, false);\r\nif (err < 0)\r\ngoto error;\r\nerr = ad1983_add_spdif_mux_ctl(codec);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}\r\nstatic void ad1981_fixup_hp_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\r\nspec->eapd_nid = 0x05;\r\n}\r\n}\r\nstatic void ad1981_fixup_amp_override(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nsnd_hda_override_amp_caps(codec, 0x11, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic int patch_ad1981(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nint err;\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn -ENOMEM;\r\nspec = codec->spec;\r\nspec->gen.mixer_nid = 0x0e;\r\nspec->gen.beep_nid = 0x10;\r\nset_beep_amp(spec, 0x0d, 0, HDA_OUTPUT);\r\nsnd_hda_pick_fixup(codec, NULL, ad1981_fixup_tbl, ad1981_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = ad198x_parse_auto_config(codec, false);\r\nif (err < 0)\r\ngoto error;\r\nerr = ad1983_add_spdif_mux_ctl(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}\r\nstatic int ad1988_auto_smux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstatic const char * const texts[] = {\r\n"PCM", "ADC1", "ADC2", "ADC3",\r\n};\r\nint num_conns = snd_hda_get_num_conns(codec, 0x0b) + 1;\r\nif (num_conns > 4)\r\nnum_conns = 4;\r\nreturn snd_hda_enum_helper_info(kcontrol, uinfo, num_conns, texts);\r\n}\r\nstatic int ad1988_auto_smux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ad198x_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->cur_smux;\r\nreturn 0;\r\n}\r\nstatic int ad1988_auto_smux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ad198x_spec *spec = codec->spec;\r\nunsigned int val = ucontrol->value.enumerated.item[0];\r\nstruct nid_path *path;\r\nint num_conns = snd_hda_get_num_conns(codec, 0x0b) + 1;\r\nif (val >= num_conns)\r\nreturn -EINVAL;\r\nif (spec->cur_smux == val)\r\nreturn 0;\r\nmutex_lock(&codec->control_mutex);\r\npath = snd_hda_get_path_from_idx(codec,\r\nspec->smux_paths[spec->cur_smux]);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, false, true);\r\npath = snd_hda_get_path_from_idx(codec, spec->smux_paths[val]);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, true, true);\r\nspec->cur_smux = val;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn 1;\r\n}\r\nstatic int ad1988_auto_init(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nint i, err;\r\nerr = snd_hda_gen_init(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (!spec->gen.autocfg.dig_outs)\r\nreturn 0;\r\nfor (i = 0; i < 4; i++) {\r\nstruct nid_path *path;\r\npath = snd_hda_get_path_from_idx(codec, spec->smux_paths[i]);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, path->active, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad1988_add_spdif_mux_ctl(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nint i, num_conns;\r\nstatic struct nid_path fake_paths[4] = {\r\n{\r\n.depth = 3,\r\n.path = { 0x02, 0x1d, 0x1b },\r\n.idx = { 0, 0, 0 },\r\n.multi = { 0, 0, 0 },\r\n},\r\n{\r\n.depth = 4,\r\n.path = { 0x08, 0x0b, 0x1d, 0x1b },\r\n.idx = { 0, 0, 1, 0 },\r\n.multi = { 0, 1, 0, 0 },\r\n},\r\n{\r\n.depth = 4,\r\n.path = { 0x09, 0x0b, 0x1d, 0x1b },\r\n.idx = { 0, 1, 1, 0 },\r\n.multi = { 0, 1, 0, 0 },\r\n},\r\n{\r\n.depth = 4,\r\n.path = { 0x0f, 0x0b, 0x1d, 0x1b },\r\n.idx = { 0, 2, 1, 0 },\r\n.multi = { 0, 1, 0, 0 },\r\n},\r\n};\r\nif (!spec->gen.autocfg.dig_outs ||\r\nget_wcaps_type(get_wcaps(codec, 0x1d)) != AC_WID_AUD_MIX)\r\nreturn 0;\r\nnum_conns = snd_hda_get_num_conns(codec, 0x0b) + 1;\r\nif (num_conns != 3 && num_conns != 4)\r\nreturn 0;\r\nfor (i = 0; i < num_conns; i++) {\r\nstruct nid_path *path = snd_array_new(&spec->gen.paths);\r\nif (!path)\r\nreturn -ENOMEM;\r\n*path = fake_paths[i];\r\nif (!i)\r\npath->active = 1;\r\nspec->smux_paths[i] = snd_hda_get_path_idx(codec, path);\r\n}\r\nif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &ad1988_auto_smux_mixer))\r\nreturn -ENOMEM;\r\ncodec->patch_ops.init = ad1988_auto_init;\r\nreturn 0;\r\n}\r\nstatic int patch_ad1988(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nint err;\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->gen.mixer_nid = 0x20;\r\nspec->gen.mixer_merge_nid = 0x21;\r\nspec->gen.beep_nid = 0x10;\r\nset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\r\nsnd_hda_pick_fixup(codec, ad1988_fixup_models, NULL, ad1988_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = ad198x_parse_auto_config(codec, true);\r\nif (err < 0)\r\ngoto error;\r\nerr = ad1988_add_spdif_mux_ctl(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}\r\nstatic void ad1884_fixup_amp_override(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nsnd_hda_override_amp_caps(codec, 0x20, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void ad1884_vmaster_hp_gpio_hook(void *private_data, int enabled)\r\n{\r\nstruct hda_codec *codec = private_data;\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (spec->eapd_nid)\r\nad_vmaster_eapd_hook(private_data, enabled);\r\nsnd_hda_codec_update_cache(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_DATA,\r\nenabled ? 0x00 : 0x02);\r\n}\r\nstatic void ad1884_fixup_hp_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nswitch (action) {\r\ncase HDA_FIXUP_ACT_PRE_PROBE:\r\nspec->gen.vmaster_mute.hook = ad1884_vmaster_hp_gpio_hook;\r\nspec->gen.own_eapd_ctl = 1;\r\nsnd_hda_codec_write_cache(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_MASK, 0x02);\r\nsnd_hda_codec_write_cache(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_DIRECTION, 0x02);\r\nsnd_hda_codec_write_cache(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_DATA, 0x02);\r\nbreak;\r\ncase HDA_FIXUP_ACT_PROBE:\r\nif (spec->gen.autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\r\nspec->eapd_nid = spec->gen.autocfg.line_out_pins[0];\r\nelse\r\nspec->eapd_nid = spec->gen.autocfg.speaker_pins[0];\r\nbreak;\r\n}\r\n}\r\nstatic void ad1884_fixup_thinkpad(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct ad198x_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->gen.keep_eapd_on = 1;\r\nspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\r\nspec->eapd_nid = 0x12;\r\nspec->beep_amp = HDA_COMPOSE_AMP_VAL(0x20, 3, 3, HDA_INPUT);\r\nspec->gen.beep_nid = 0;\r\n}\r\n}\r\nstatic int patch_ad1884(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nint err;\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->gen.mixer_nid = 0x20;\r\nspec->gen.mixer_merge_nid = 0x21;\r\nspec->gen.beep_nid = 0x10;\r\nset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\r\nsnd_hda_pick_fixup(codec, NULL, ad1884_fixup_tbl, ad1884_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = ad198x_parse_auto_config(codec, true);\r\nif (err < 0)\r\ngoto error;\r\nerr = ad1983_add_spdif_mux_ctl(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}\r\nstatic int patch_ad1882(struct hda_codec *codec)\r\n{\r\nstruct ad198x_spec *spec;\r\nint err;\r\nerr = alloc_ad_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->gen.mixer_nid = 0x20;\r\nspec->gen.mixer_merge_nid = 0x21;\r\nspec->gen.beep_nid = 0x10;\r\nset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\r\nerr = ad198x_parse_auto_config(codec, true);\r\nif (err < 0)\r\ngoto error;\r\nerr = ad1988_add_spdif_mux_ctl(codec);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}
