static void __init reset_early_page_tables(void)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < PTRS_PER_PGD-1; i++)\r\nearly_level4_pgt[i].pgd = 0;\r\nnext_early_pgt = 0;\r\nwrite_cr3(__pa_nodebug(early_level4_pgt));\r\n}\r\nint __init early_make_pgtable(unsigned long address)\r\n{\r\nunsigned long physaddr = address - __PAGE_OFFSET;\r\nunsigned long i;\r\npgdval_t pgd, *pgd_p;\r\npudval_t pud, *pud_p;\r\npmdval_t pmd, *pmd_p;\r\nif (physaddr >= MAXMEM || read_cr3() != __pa_nodebug(early_level4_pgt))\r\nreturn -1;\r\nagain:\r\npgd_p = &early_level4_pgt[pgd_index(address)].pgd;\r\npgd = *pgd_p;\r\nif (pgd)\r\npud_p = (pudval_t *)((pgd & PTE_PFN_MASK) + __START_KERNEL_map - phys_base);\r\nelse {\r\nif (next_early_pgt >= EARLY_DYNAMIC_PAGE_TABLES) {\r\nreset_early_page_tables();\r\ngoto again;\r\n}\r\npud_p = (pudval_t *)early_dynamic_pgts[next_early_pgt++];\r\nfor (i = 0; i < PTRS_PER_PUD; i++)\r\npud_p[i] = 0;\r\n*pgd_p = (pgdval_t)pud_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;\r\n}\r\npud_p += pud_index(address);\r\npud = *pud_p;\r\nif (pud)\r\npmd_p = (pmdval_t *)((pud & PTE_PFN_MASK) + __START_KERNEL_map - phys_base);\r\nelse {\r\nif (next_early_pgt >= EARLY_DYNAMIC_PAGE_TABLES) {\r\nreset_early_page_tables();\r\ngoto again;\r\n}\r\npmd_p = (pmdval_t *)early_dynamic_pgts[next_early_pgt++];\r\nfor (i = 0; i < PTRS_PER_PMD; i++)\r\npmd_p[i] = 0;\r\n*pud_p = (pudval_t)pmd_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;\r\n}\r\npmd = (physaddr & PMD_MASK) + early_pmd_flags;\r\npmd_p[pmd_index(address)] = pmd;\r\nreturn 0;\r\n}\r\nstatic void __init clear_bss(void)\r\n{\r\nmemset(__bss_start, 0,\r\n(unsigned long) __bss_stop - (unsigned long) __bss_start);\r\n}\r\nstatic unsigned long get_cmd_line_ptr(void)\r\n{\r\nunsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;\r\ncmd_line_ptr |= (u64)boot_params.ext_cmd_line_ptr << 32;\r\nreturn cmd_line_ptr;\r\n}\r\nstatic void __init copy_bootdata(char *real_mode_data)\r\n{\r\nchar * command_line;\r\nunsigned long cmd_line_ptr;\r\nmemcpy(&boot_params, real_mode_data, sizeof boot_params);\r\nsanitize_boot_params(&boot_params);\r\ncmd_line_ptr = get_cmd_line_ptr();\r\nif (cmd_line_ptr) {\r\ncommand_line = __va(cmd_line_ptr);\r\nmemcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);\r\n}\r\n}\r\nasmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)\r\n{\r\nint i;\r\nBUILD_BUG_ON(MODULES_VADDR < __START_KERNEL_map);\r\nBUILD_BUG_ON(MODULES_VADDR - __START_KERNEL_map < KERNEL_IMAGE_SIZE);\r\nBUILD_BUG_ON(MODULES_LEN + KERNEL_IMAGE_SIZE > 2*PUD_SIZE);\r\nBUILD_BUG_ON((__START_KERNEL_map & ~PMD_MASK) != 0);\r\nBUILD_BUG_ON((MODULES_VADDR & ~PMD_MASK) != 0);\r\nBUILD_BUG_ON(!(MODULES_VADDR > __START_KERNEL));\r\nBUILD_BUG_ON(!(((MODULES_END - 1) & PGDIR_MASK) ==\r\n(__START_KERNEL & PGDIR_MASK)));\r\nBUILD_BUG_ON(__fix_to_virt(__end_of_fixed_addresses) <= MODULES_END);\r\ncr4_init_shadow();\r\nreset_early_page_tables();\r\nclear_bss();\r\nclear_page(init_level4_pgt);\r\nkasan_early_init();\r\nfor (i = 0; i < NUM_EXCEPTION_VECTORS; i++)\r\nset_intr_gate(i, early_idt_handler_array[i]);\r\nload_idt((const struct desc_ptr *)&idt_descr);\r\ncopy_bootdata(__va(real_mode_data));\r\nload_ucode_bsp();\r\ninit_level4_pgt[511] = early_level4_pgt[511];\r\nx86_64_start_reservations(real_mode_data);\r\n}\r\nvoid __init x86_64_start_reservations(char *real_mode_data)\r\n{\r\nif (!boot_params.hdr.version)\r\ncopy_bootdata(__va(real_mode_data));\r\nreserve_ebda_region();\r\nstart_kernel();\r\n}
