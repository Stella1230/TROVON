int\r\nlnet_acceptor_port(void)\r\n{\r\nreturn accept_port;\r\n}\r\nstatic inline int\r\nlnet_accept_magic(__u32 magic, __u32 constant)\r\n{\r\nreturn (magic == constant ||\r\nmagic == __swab32(constant));\r\n}\r\nstatic int\r\nlnet_acceptor_get_tunables(void)\r\n{\r\naccept_type = accept;\r\nreturn 0;\r\n}\r\nint\r\nlnet_acceptor_timeout(void)\r\n{\r\nreturn accept_timeout;\r\n}\r\nvoid\r\nlnet_connect_console_error(int rc, lnet_nid_t peer_nid,\r\n__u32 peer_ip, int peer_port)\r\n{\r\nswitch (rc) {\r\ncase -ECONNREFUSED:\r\nCNETERR("Connection to %s at host %pI4h on port %d was refused: check that Lustre is running on that node.\n",\r\nlibcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port);\r\nbreak;\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\nCNETERR("Connection to %s at host %pI4h was unreachable: the network or that node may be down, or Lustre may be misconfigured.\n",\r\nlibcfs_nid2str(peer_nid), &peer_ip);\r\nbreak;\r\ncase -ETIMEDOUT:\r\nCNETERR("Connection to %s at host %pI4h on port %d took too long: that node may be hung or experiencing high load.\n",\r\nlibcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port);\r\nbreak;\r\ncase -ECONNRESET:\r\nLCONSOLE_ERROR_MSG(0x11b, "Connection to %s at host %pI4h on port %d was reset: is it running a compatible version of Lustre and is %s one of its NIDs?\n",\r\nlibcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port,\r\nlibcfs_nid2str(peer_nid));\r\nbreak;\r\ncase -EPROTO:\r\nLCONSOLE_ERROR_MSG(0x11c, "Protocol error connecting to %s at host %pI4h on port %d: is it running a compatible version of Lustre?\n",\r\nlibcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port);\r\nbreak;\r\ncase -EADDRINUSE:\r\nLCONSOLE_ERROR_MSG(0x11d, "No privileged ports available to connect to %s at host %pI4h on port %d\n",\r\nlibcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port);\r\nbreak;\r\ndefault:\r\nLCONSOLE_ERROR_MSG(0x11e, "Unexpected error %d connecting to %s at host %pI4h on port %d\n",\r\nrc, libcfs_nid2str(peer_nid),\r\n&peer_ip, peer_port);\r\nbreak;\r\n}\r\n}\r\nint\r\nlnet_connect(struct socket **sockp, lnet_nid_t peer_nid,\r\n__u32 local_ip, __u32 peer_ip, int peer_port)\r\n{\r\nlnet_acceptor_connreq_t cr;\r\nstruct socket *sock;\r\nint rc;\r\nint port;\r\nint fatal;\r\nCLASSERT(sizeof(cr) <= 16);\r\nfor (port = LNET_ACCEPTOR_MAX_RESERVED_PORT;\r\nport >= LNET_ACCEPTOR_MIN_RESERVED_PORT;\r\n--port) {\r\nrc = lnet_sock_connect(&sock, &fatal, local_ip, port, peer_ip,\r\npeer_port);\r\nif (rc != 0) {\r\nif (fatal)\r\ngoto failed;\r\ncontinue;\r\n}\r\nCLASSERT(LNET_PROTO_ACCEPTOR_VERSION == 1);\r\ncr.acr_magic = LNET_PROTO_ACCEPTOR_MAGIC;\r\ncr.acr_version = LNET_PROTO_ACCEPTOR_VERSION;\r\ncr.acr_nid = peer_nid;\r\nif (the_lnet.ln_testprotocompat != 0) {\r\nlnet_net_lock(LNET_LOCK_EX);\r\nif ((the_lnet.ln_testprotocompat & 4) != 0) {\r\ncr.acr_version++;\r\nthe_lnet.ln_testprotocompat &= ~4;\r\n}\r\nif ((the_lnet.ln_testprotocompat & 8) != 0) {\r\ncr.acr_magic = LNET_PROTO_MAGIC;\r\nthe_lnet.ln_testprotocompat &= ~8;\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nrc = lnet_sock_write(sock, &cr, sizeof(cr), accept_timeout);\r\nif (rc != 0)\r\ngoto failed_sock;\r\n*sockp = sock;\r\nreturn 0;\r\n}\r\nrc = -EADDRINUSE;\r\ngoto failed;\r\nfailed_sock:\r\nsock_release(sock);\r\nfailed:\r\nlnet_connect_console_error(rc, peer_nid, peer_ip, peer_port);\r\nreturn rc;\r\n}\r\nstatic int\r\nlnet_accept(struct socket *sock, __u32 magic)\r\n{\r\nlnet_acceptor_connreq_t cr;\r\n__u32 peer_ip;\r\nint peer_port;\r\nint rc;\r\nint flip;\r\nlnet_ni_t *ni;\r\nchar *str;\r\nLASSERT(sizeof(cr) <= 16);\r\nrc = lnet_sock_getaddr(sock, 1, &peer_ip, &peer_port);\r\nLASSERT(rc == 0);\r\nif (!lnet_accept_magic(magic, LNET_PROTO_ACCEPTOR_MAGIC)) {\r\nif (lnet_accept_magic(magic, LNET_PROTO_MAGIC)) {\r\nmemset(&cr, 0, sizeof(cr));\r\ncr.acr_magic = LNET_PROTO_ACCEPTOR_MAGIC;\r\ncr.acr_version = LNET_PROTO_ACCEPTOR_VERSION;\r\nrc = lnet_sock_write(sock, &cr, sizeof(cr),\r\naccept_timeout);\r\nif (rc != 0)\r\nCERROR("Error sending magic+version in response to LNET magic from %pI4h: %d\n",\r\n&peer_ip, rc);\r\nreturn -EPROTO;\r\n}\r\nif (magic == le32_to_cpu(LNET_PROTO_TCP_MAGIC))\r\nstr = "'old' socknal/tcpnal";\r\nelse\r\nstr = "unrecognised";\r\nLCONSOLE_ERROR_MSG(0x11f, "Refusing connection from %pI4h magic %08x: %s acceptor protocol\n",\r\n&peer_ip, magic, str);\r\nreturn -EPROTO;\r\n}\r\nflip = (magic != LNET_PROTO_ACCEPTOR_MAGIC);\r\nrc = lnet_sock_read(sock, &cr.acr_version, sizeof(cr.acr_version),\r\naccept_timeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading connection request version from %pI4h\n",\r\nrc, &peer_ip);\r\nreturn -EIO;\r\n}\r\nif (flip)\r\n__swab32s(&cr.acr_version);\r\nif (cr.acr_version != LNET_PROTO_ACCEPTOR_VERSION) {\r\nint peer_version = cr.acr_version;\r\nmemset(&cr, 0, sizeof(cr));\r\ncr.acr_magic = LNET_PROTO_ACCEPTOR_MAGIC;\r\ncr.acr_version = LNET_PROTO_ACCEPTOR_VERSION;\r\nrc = lnet_sock_write(sock, &cr, sizeof(cr), accept_timeout);\r\nif (rc != 0)\r\nCERROR("Error sending magic+version in response to version %d from %pI4h: %d\n",\r\npeer_version, &peer_ip, rc);\r\nreturn -EPROTO;\r\n}\r\nrc = lnet_sock_read(sock, &cr.acr_nid,\r\nsizeof(cr) -\r\noffsetof(lnet_acceptor_connreq_t, acr_nid),\r\naccept_timeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading connection request from %pI4h\n",\r\nrc, &peer_ip);\r\nreturn -EIO;\r\n}\r\nif (flip)\r\n__swab64s(&cr.acr_nid);\r\nni = lnet_net2ni(LNET_NIDNET(cr.acr_nid));\r\nif (ni == NULL ||\r\nni->ni_nid != cr.acr_nid) {\r\nif (ni != NULL)\r\nlnet_ni_decref(ni);\r\nLCONSOLE_ERROR_MSG(0x120, "Refusing connection from %pI4h for %s: No matching NI\n",\r\n&peer_ip, libcfs_nid2str(cr.acr_nid));\r\nreturn -EPERM;\r\n}\r\nif (ni->ni_lnd->lnd_accept == NULL) {\r\nlnet_ni_decref(ni);\r\nLCONSOLE_ERROR_MSG(0x121, "Refusing connection from %pI4h for %s: NI doesn not accept IP connections\n",\r\n&peer_ip, libcfs_nid2str(cr.acr_nid));\r\nreturn -EPERM;\r\n}\r\nCDEBUG(D_NET, "Accept %s from %pI4h\n",\r\nlibcfs_nid2str(cr.acr_nid), &peer_ip);\r\nrc = ni->ni_lnd->lnd_accept(ni, sock);\r\nlnet_ni_decref(ni);\r\nreturn rc;\r\n}\r\nstatic int\r\nlnet_acceptor(void *arg)\r\n{\r\nstruct socket *newsock;\r\nint rc;\r\n__u32 magic;\r\n__u32 peer_ip;\r\nint peer_port;\r\nint secure = (int)((long_ptr_t)arg);\r\nLASSERT(lnet_acceptor_state.pta_sock == NULL);\r\ncfs_block_allsigs();\r\nrc = lnet_sock_listen(&lnet_acceptor_state.pta_sock, 0, accept_port,\r\naccept_backlog);\r\nif (rc != 0) {\r\nif (rc == -EADDRINUSE)\r\nLCONSOLE_ERROR_MSG(0x122, "Can't start acceptor on port %d: port already in use\n",\r\naccept_port);\r\nelse\r\nLCONSOLE_ERROR_MSG(0x123, "Can't start acceptor on port %d: unexpected error %d\n",\r\naccept_port, rc);\r\nlnet_acceptor_state.pta_sock = NULL;\r\n} else {\r\nLCONSOLE(0, "Accept %s, port %d\n", accept_type, accept_port);\r\n}\r\nlnet_acceptor_state.pta_shutdown = rc;\r\ncomplete(&lnet_acceptor_state.pta_signal);\r\nif (rc != 0)\r\nreturn rc;\r\nwhile (!lnet_acceptor_state.pta_shutdown) {\r\nrc = lnet_sock_accept(&newsock, lnet_acceptor_state.pta_sock);\r\nif (rc != 0) {\r\nif (rc != -EAGAIN) {\r\nCWARN("Accept error %d: pausing...\n", rc);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\n}\r\ncontinue;\r\n}\r\nif (lnet_acceptor_state.pta_shutdown) {\r\nsock_release(newsock);\r\nbreak;\r\n}\r\nrc = lnet_sock_getaddr(newsock, 1, &peer_ip, &peer_port);\r\nif (rc != 0) {\r\nCERROR("Can't determine new connection's address\n");\r\ngoto failed;\r\n}\r\nif (secure && peer_port > LNET_ACCEPTOR_MAX_RESERVED_PORT) {\r\nCERROR("Refusing connection from %pI4h: insecure port %d\n",\r\n&peer_ip, peer_port);\r\ngoto failed;\r\n}\r\nrc = lnet_sock_read(newsock, &magic, sizeof(magic),\r\naccept_timeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading connection request from %pI4h\n",\r\nrc, &peer_ip);\r\ngoto failed;\r\n}\r\nrc = lnet_accept(newsock, magic);\r\nif (rc != 0)\r\ngoto failed;\r\ncontinue;\r\nfailed:\r\nsock_release(newsock);\r\n}\r\nsock_release(lnet_acceptor_state.pta_sock);\r\nlnet_acceptor_state.pta_sock = NULL;\r\nCDEBUG(D_NET, "Acceptor stopping\n");\r\ncomplete(&lnet_acceptor_state.pta_signal);\r\nreturn 0;\r\n}\r\nstatic inline int\r\naccept2secure(const char *acc, long *sec)\r\n{\r\nif (!strcmp(acc, "secure")) {\r\n*sec = 1;\r\nreturn 1;\r\n} else if (!strcmp(acc, "all")) {\r\n*sec = 0;\r\nreturn 1;\r\n} else if (!strcmp(acc, "none")) {\r\nreturn 0;\r\n}\r\nLCONSOLE_ERROR_MSG(0x124, "Can't parse 'accept=\"%s\"'\n",\r\nacc);\r\nreturn -EINVAL;\r\n}\r\nint\r\nlnet_acceptor_start(void)\r\n{\r\nint rc;\r\nlong rc2;\r\nlong secure;\r\nLASSERT(lnet_acceptor_state.pta_sock == NULL);\r\nrc = lnet_acceptor_get_tunables();\r\nif (rc != 0)\r\nreturn rc;\r\ninit_completion(&lnet_acceptor_state.pta_signal);\r\nrc = accept2secure(accept_type, &secure);\r\nif (rc <= 0)\r\nreturn rc;\r\nif (lnet_count_acceptor_nis() == 0)\r\nreturn 0;\r\nrc2 = PTR_ERR(kthread_run(lnet_acceptor,\r\n(void *)(ulong_ptr_t)secure,\r\n"acceptor_%03ld", secure));\r\nif (IS_ERR_VALUE(rc2)) {\r\nCERROR("Can't start acceptor thread: %ld\n", rc2);\r\nreturn -ESRCH;\r\n}\r\nwait_for_completion(&lnet_acceptor_state.pta_signal);\r\nif (!lnet_acceptor_state.pta_shutdown) {\r\nLASSERT(lnet_acceptor_state.pta_sock != NULL);\r\nreturn 0;\r\n}\r\nLASSERT(lnet_acceptor_state.pta_sock == NULL);\r\nreturn -ENETDOWN;\r\n}\r\nvoid\r\nlnet_acceptor_stop(void)\r\n{\r\nif (lnet_acceptor_state.pta_sock == NULL)\r\nreturn;\r\nlnet_acceptor_state.pta_shutdown = 1;\r\nwake_up_all(sk_sleep(lnet_acceptor_state.pta_sock->sk));\r\nwait_for_completion(&lnet_acceptor_state.pta_signal);\r\n}
