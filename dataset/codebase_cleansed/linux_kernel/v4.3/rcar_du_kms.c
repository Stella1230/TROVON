const struct rcar_du_format_info *rcar_du_format_info(u32 fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(rcar_du_format_infos); ++i) {\r\nif (rcar_du_format_infos[i].fourcc == fourcc)\r\nreturn &rcar_du_format_infos[i];\r\n}\r\nreturn NULL;\r\n}\r\nint rcar_du_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nunsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nunsigned int align;\r\nif (rcar_du_needs(rcdu, RCAR_DU_QUIRK_ALIGN_128B))\r\nalign = 128;\r\nelse\r\nalign = 16 * args->bpp / 8;\r\nargs->pitch = roundup(min_pitch, align);\r\nreturn drm_gem_cma_dumb_create_internal(file, dev, args);\r\n}\r\nstatic struct drm_framebuffer *\r\nrcar_du_fb_create(struct drm_device *dev, struct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nconst struct rcar_du_format_info *format;\r\nunsigned int max_pitch;\r\nunsigned int align;\r\nunsigned int bpp;\r\nformat = rcar_du_format_info(mode_cmd->pixel_format);\r\nif (format == NULL) {\r\ndev_dbg(dev->dev, "unsupported pixel format %08x\n",\r\nmode_cmd->pixel_format);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbpp = format->planes == 2 ? 1 : format->bpp / 8;\r\nmax_pitch = 4096 * bpp;\r\nif (rcar_du_needs(rcdu, RCAR_DU_QUIRK_ALIGN_128B))\r\nalign = 128;\r\nelse\r\nalign = 16 * bpp;\r\nif (mode_cmd->pitches[0] & (align - 1) ||\r\nmode_cmd->pitches[0] >= max_pitch) {\r\ndev_dbg(dev->dev, "invalid pitch value %u\n",\r\nmode_cmd->pitches[0]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (format->planes == 2) {\r\nif (mode_cmd->pitches[1] != mode_cmd->pitches[0]) {\r\ndev_dbg(dev->dev,\r\n"luma and chroma pitches do not match\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nreturn drm_fb_cma_create(dev, file_priv, mode_cmd);\r\n}\r\nstatic void rcar_du_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\ndrm_fbdev_cma_hotplug_event(rcdu->fbdev);\r\n}\r\nstatic bool rcar_du_plane_needs_realloc(struct rcar_du_plane *plane,\r\nstruct rcar_du_plane_state *state)\r\n{\r\nconst struct rcar_du_format_info *cur_format;\r\ncur_format = to_rcar_plane_state(plane->plane.state)->format;\r\nreturn !cur_format || cur_format->planes != state->format->planes;\r\n}\r\nstatic unsigned int rcar_du_plane_hwmask(struct rcar_du_plane_state *state)\r\n{\r\nunsigned int mask;\r\nif (state->hwindex == -1)\r\nreturn 0;\r\nmask = 1 << state->hwindex;\r\nif (state->format->planes == 2)\r\nmask |= 1 << ((state->hwindex + 1) % 8);\r\nreturn mask;\r\n}\r\nstatic int rcar_du_plane_hwalloc(unsigned int num_planes, unsigned int free)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < RCAR_DU_NUM_HW_PLANES; ++i) {\r\nif (!(free & (1 << i)))\r\ncontinue;\r\nif (num_planes == 1 || free & (1 << ((i + 1) % 8)))\r\nbreak;\r\n}\r\nreturn i == RCAR_DU_NUM_HW_PLANES ? -EBUSY : i;\r\n}\r\nstatic int rcar_du_atomic_check(struct drm_device *dev,\r\nstruct drm_atomic_state *state)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nunsigned int group_freed_planes[RCAR_DU_MAX_GROUPS] = { 0, };\r\nunsigned int group_free_planes[RCAR_DU_MAX_GROUPS] = { 0, };\r\nbool needs_realloc = false;\r\nunsigned int groups = 0;\r\nunsigned int i;\r\nint ret;\r\nret = drm_atomic_helper_check(dev, state);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < dev->mode_config.num_total_plane; ++i) {\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct rcar_du_plane *plane;\r\nunsigned int index;\r\nif (!state->planes[i])\r\ncontinue;\r\nplane = to_rcar_plane(state->planes[i]);\r\nplane_state = to_rcar_plane_state(state->plane_states[i]);\r\ndev_dbg(rcdu->dev, "%s: checking plane (%u,%u)\n", __func__,\r\nplane->group->index, plane - plane->group->planes);\r\nif (!plane_state->format) {\r\ndev_dbg(rcdu->dev, "%s: plane is being disabled\n",\r\n__func__);\r\nindex = plane - plane->group->planes;\r\ngroup_freed_planes[plane->group->index] |= 1 << index;\r\nplane_state->hwindex = -1;\r\ncontinue;\r\n}\r\nif (rcar_du_plane_needs_realloc(plane, plane_state)) {\r\ndev_dbg(rcdu->dev, "%s: plane needs reallocation\n",\r\n__func__);\r\ngroups |= 1 << plane->group->index;\r\nneeds_realloc = true;\r\nindex = plane - plane->group->planes;\r\ngroup_freed_planes[plane->group->index] |= 1 << index;\r\nplane_state->hwindex = -1;\r\n}\r\n}\r\nif (!needs_realloc)\r\nreturn 0;\r\nwhile (groups) {\r\nunsigned int index = ffs(groups) - 1;\r\nstruct rcar_du_group *group = &rcdu->groups[index];\r\nunsigned int used_planes = 0;\r\ndev_dbg(rcdu->dev, "%s: finding free planes for group %u\n",\r\n__func__, index);\r\nfor (i = 0; i < group->num_planes; ++i) {\r\nstruct rcar_du_plane *plane = &group->planes[i];\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct drm_plane_state *s;\r\ns = drm_atomic_get_plane_state(state, &plane->plane);\r\nif (IS_ERR(s))\r\nreturn PTR_ERR(s);\r\nif (group_freed_planes[index] & (1 << i)) {\r\ndev_dbg(rcdu->dev,\r\n"%s: plane (%u,%u) has been freed, skipping\n",\r\n__func__, plane->group->index,\r\nplane - plane->group->planes);\r\ncontinue;\r\n}\r\nplane_state = to_rcar_plane_state(plane->plane.state);\r\nused_planes |= rcar_du_plane_hwmask(plane_state);\r\ndev_dbg(rcdu->dev,\r\n"%s: plane (%u,%u) uses %u hwplanes (index %d)\n",\r\n__func__, plane->group->index,\r\nplane - plane->group->planes,\r\nplane_state->format ?\r\nplane_state->format->planes : 0,\r\nplane_state->hwindex);\r\n}\r\ngroup_free_planes[index] = 0xff & ~used_planes;\r\ngroups &= ~(1 << index);\r\ndev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",\r\n__func__, index, group_free_planes[index]);\r\n}\r\nfor (i = 0; i < dev->mode_config.num_total_plane; ++i) {\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct rcar_du_plane *plane;\r\nunsigned int crtc_planes;\r\nunsigned int free;\r\nint idx;\r\nif (!state->planes[i])\r\ncontinue;\r\nplane = to_rcar_plane(state->planes[i]);\r\nplane_state = to_rcar_plane_state(state->plane_states[i]);\r\ndev_dbg(rcdu->dev, "%s: allocating plane (%u,%u)\n", __func__,\r\nplane->group->index, plane - plane->group->planes);\r\nif (!plane_state->format ||\r\n!rcar_du_plane_needs_realloc(plane, plane_state))\r\ncontinue;\r\ncrtc_planes = to_rcar_crtc(plane_state->state.crtc)->index % 2\r\n? plane->group->dptsr_planes\r\n: ~plane->group->dptsr_planes;\r\nfree = group_free_planes[plane->group->index];\r\nidx = rcar_du_plane_hwalloc(plane_state->format->planes,\r\nfree & crtc_planes);\r\nif (idx < 0)\r\nidx = rcar_du_plane_hwalloc(plane_state->format->planes,\r\nfree);\r\nif (idx < 0) {\r\ndev_dbg(rcdu->dev, "%s: no available hardware plane\n",\r\n__func__);\r\nreturn idx;\r\n}\r\ndev_dbg(rcdu->dev, "%s: allocated %u hwplanes (index %u)\n",\r\n__func__, plane_state->format->planes, idx);\r\nplane_state->hwindex = idx;\r\ngroup_free_planes[plane->group->index] &=\r\n~rcar_du_plane_hwmask(plane_state);\r\ndev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",\r\n__func__, plane->group->index,\r\ngroup_free_planes[plane->group->index]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_du_atomic_complete(struct rcar_du_commit *commit)\r\n{\r\nstruct drm_device *dev = commit->dev;\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nstruct drm_atomic_state *old_state = commit->state;\r\ndrm_atomic_helper_commit_modeset_disables(dev, old_state);\r\ndrm_atomic_helper_commit_modeset_enables(dev, old_state);\r\ndrm_atomic_helper_commit_planes(dev, old_state);\r\ndrm_atomic_helper_wait_for_vblanks(dev, old_state);\r\ndrm_atomic_helper_cleanup_planes(dev, old_state);\r\ndrm_atomic_state_free(old_state);\r\nspin_lock(&rcdu->commit.wait.lock);\r\nrcdu->commit.pending &= ~commit->crtcs;\r\nwake_up_all_locked(&rcdu->commit.wait);\r\nspin_unlock(&rcdu->commit.wait.lock);\r\nkfree(commit);\r\n}\r\nstatic void rcar_du_atomic_work(struct work_struct *work)\r\n{\r\nstruct rcar_du_commit *commit =\r\ncontainer_of(work, struct rcar_du_commit, work);\r\nrcar_du_atomic_complete(commit);\r\n}\r\nstatic int rcar_du_atomic_commit(struct drm_device *dev,\r\nstruct drm_atomic_state *state, bool async)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nstruct rcar_du_commit *commit;\r\nunsigned int i;\r\nint ret;\r\nret = drm_atomic_helper_prepare_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\ncommit = kzalloc(sizeof(*commit), GFP_KERNEL);\r\nif (commit == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nINIT_WORK(&commit->work, rcar_du_atomic_work);\r\ncommit->dev = dev;\r\ncommit->state = state;\r\nfor (i = 0; i < dev->mode_config.num_crtc; ++i) {\r\nif (state->crtcs[i])\r\ncommit->crtcs |= 1 << drm_crtc_index(state->crtcs[i]);\r\n}\r\nspin_lock(&rcdu->commit.wait.lock);\r\nret = wait_event_interruptible_locked(rcdu->commit.wait,\r\n!(rcdu->commit.pending & commit->crtcs));\r\nif (ret == 0)\r\nrcdu->commit.pending |= commit->crtcs;\r\nspin_unlock(&rcdu->commit.wait.lock);\r\nif (ret) {\r\nkfree(commit);\r\ngoto error;\r\n}\r\ndrm_atomic_helper_swap_state(dev, state);\r\nif (async)\r\nschedule_work(&commit->work);\r\nelse\r\nrcar_du_atomic_complete(commit);\r\nreturn 0;\r\nerror:\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nreturn ret;\r\n}\r\nstatic int rcar_du_encoders_init_one(struct rcar_du_device *rcdu,\r\nenum rcar_du_output output,\r\nstruct of_endpoint *ep)\r\n{\r\nstatic const struct {\r\nconst char *compatible;\r\nenum rcar_du_encoder_type type;\r\n} encoders[] = {\r\n{ "adi,adv7123", RCAR_DU_ENCODER_VGA },\r\n{ "adi,adv7511w", RCAR_DU_ENCODER_HDMI },\r\n{ "thine,thc63lvdm83d", RCAR_DU_ENCODER_LVDS },\r\n};\r\nenum rcar_du_encoder_type enc_type = RCAR_DU_ENCODER_NONE;\r\nstruct device_node *connector = NULL;\r\nstruct device_node *encoder = NULL;\r\nstruct device_node *ep_node = NULL;\r\nstruct device_node *entity_ep_node;\r\nstruct device_node *entity;\r\nint ret;\r\nentity = of_graph_get_remote_port_parent(ep->local_node);\r\nif (!entity) {\r\ndev_dbg(rcdu->dev, "unconnected endpoint %s, skipping\n",\r\nep->local_node->full_name);\r\nreturn -ENODEV;\r\n}\r\nentity_ep_node = of_parse_phandle(ep->local_node, "remote-endpoint", 0);\r\nfor_each_endpoint_of_node(entity, ep_node) {\r\nif (ep_node == entity_ep_node)\r\ncontinue;\r\nencoder = entity;\r\nconnector = of_graph_get_remote_port_parent(ep_node);\r\nof_node_put(ep_node);\r\nif (!connector) {\r\ndev_warn(rcdu->dev,\r\n"no connector for encoder %s, skipping\n",\r\nencoder->full_name);\r\nof_node_put(entity_ep_node);\r\nof_node_put(encoder);\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\n}\r\nof_node_put(entity_ep_node);\r\nif (encoder) {\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(encoders); ++i) {\r\nif (of_device_is_compatible(encoder,\r\nencoders[i].compatible)) {\r\nenc_type = encoders[i].type;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(encoders)) {\r\ndev_warn(rcdu->dev,\r\n"unknown encoder type for %s, skipping\n",\r\nencoder->full_name);\r\nof_node_put(encoder);\r\nof_node_put(connector);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nconnector = entity;\r\n}\r\nret = rcar_du_encoder_init(rcdu, enc_type, output, encoder, connector);\r\nof_node_put(encoder);\r\nof_node_put(connector);\r\nif (ret && ret != -EPROBE_DEFER)\r\ndev_warn(rcdu->dev,\r\n"failed to initialize encoder %s (%d), skipping\n",\r\nencoder->full_name, ret);\r\nreturn ret;\r\n}\r\nstatic int rcar_du_encoders_init(struct rcar_du_device *rcdu)\r\n{\r\nstruct device_node *np = rcdu->dev->of_node;\r\nstruct device_node *ep_node;\r\nunsigned int num_encoders = 0;\r\nfor_each_endpoint_of_node(np, ep_node) {\r\nenum rcar_du_output output;\r\nstruct of_endpoint ep;\r\nunsigned int i;\r\nint ret;\r\nret = of_graph_parse_endpoint(ep_node, &ep);\r\nif (ret < 0) {\r\nof_node_put(ep_node);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < RCAR_DU_OUTPUT_MAX; ++i) {\r\nif (rcdu->info->routes[i].possible_crtcs &&\r\nrcdu->info->routes[i].port == ep.port) {\r\noutput = i;\r\nbreak;\r\n}\r\n}\r\nif (i == RCAR_DU_OUTPUT_MAX) {\r\ndev_warn(rcdu->dev,\r\n"port %u references unexisting output, skipping\n",\r\nep.port);\r\ncontinue;\r\n}\r\nret = rcar_du_encoders_init_one(rcdu, output, &ep);\r\nif (ret < 0) {\r\nif (ret == -EPROBE_DEFER) {\r\nof_node_put(ep_node);\r\nreturn ret;\r\n}\r\ncontinue;\r\n}\r\nnum_encoders++;\r\n}\r\nreturn num_encoders;\r\n}\r\nstatic int rcar_du_properties_init(struct rcar_du_device *rcdu)\r\n{\r\nrcdu->props.alpha =\r\ndrm_property_create_range(rcdu->ddev, 0, "alpha", 0, 255);\r\nif (rcdu->props.alpha == NULL)\r\nreturn -ENOMEM;\r\nrcdu->props.colorkey =\r\ndrm_property_create_range(rcdu->ddev, 0, "colorkey",\r\n0, 0x01ffffff);\r\nif (rcdu->props.colorkey == NULL)\r\nreturn -ENOMEM;\r\nrcdu->props.zpos =\r\ndrm_property_create_range(rcdu->ddev, 0, "zpos", 1, 7);\r\nif (rcdu->props.zpos == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint rcar_du_modeset_init(struct rcar_du_device *rcdu)\r\n{\r\nstatic const unsigned int mmio_offsets[] = {\r\nDU0_REG_OFFSET, DU2_REG_OFFSET\r\n};\r\nstruct drm_device *dev = rcdu->ddev;\r\nstruct drm_encoder *encoder;\r\nstruct drm_fbdev_cma *fbdev;\r\nunsigned int num_encoders;\r\nunsigned int num_groups;\r\nunsigned int i;\r\nint ret;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.max_width = 4095;\r\ndev->mode_config.max_height = 2047;\r\ndev->mode_config.funcs = &rcar_du_mode_config_funcs;\r\nrcdu->num_crtcs = rcdu->info->num_crtcs;\r\nret = rcar_du_properties_init(rcdu);\r\nif (ret < 0)\r\nreturn ret;\r\nnum_groups = DIV_ROUND_UP(rcdu->num_crtcs, 2);\r\nfor (i = 0; i < num_groups; ++i) {\r\nstruct rcar_du_group *rgrp = &rcdu->groups[i];\r\nmutex_init(&rgrp->lock);\r\nrgrp->dev = rcdu;\r\nrgrp->mmio_offset = mmio_offsets[i];\r\nrgrp->index = i;\r\nrgrp->num_crtcs = min(rcdu->num_crtcs - 2 * i, 2U);\r\nrgrp->dptsr_planes = rgrp->num_crtcs > 1 ? 0xf0 : 0;\r\nret = rcar_du_planes_init(rgrp);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < rcdu->num_crtcs; ++i) {\r\nstruct rcar_du_group *rgrp = &rcdu->groups[i / 2];\r\nret = rcar_du_crtc_create(rgrp, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = rcar_du_lvdsenc_init(rcdu);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rcar_du_encoders_init(rcdu);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0) {\r\ndev_err(rcdu->dev, "error: no encoder could be initialized\n");\r\nreturn -EINVAL;\r\n}\r\nnum_encoders = ret;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nconst struct rcar_du_output_routing *route =\r\n&rcdu->info->routes[renc->output];\r\nencoder->possible_crtcs = route->possible_crtcs;\r\nencoder->possible_clones = (1 << num_encoders) - 1;\r\n}\r\ndrm_mode_config_reset(dev);\r\ndrm_kms_helper_poll_init(dev);\r\nif (dev->mode_config.num_connector) {\r\nfbdev = drm_fbdev_cma_init(dev, 32, dev->mode_config.num_crtc,\r\ndev->mode_config.num_connector);\r\nif (IS_ERR(fbdev))\r\nreturn PTR_ERR(fbdev);\r\nrcdu->fbdev = fbdev;\r\n} else {\r\ndev_info(rcdu->dev,\r\n"no connector found, disabling fbdev emulation\n");\r\n}\r\nreturn 0;\r\n}
