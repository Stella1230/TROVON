void kfd_process_create_wq(void)\r\n{\r\nif (!kfd_process_wq)\r\nkfd_process_wq = create_workqueue("kfd_process_wq");\r\n}\r\nvoid kfd_process_destroy_wq(void)\r\n{\r\nif (kfd_process_wq) {\r\nflush_workqueue(kfd_process_wq);\r\ndestroy_workqueue(kfd_process_wq);\r\nkfd_process_wq = NULL;\r\n}\r\n}\r\nstruct kfd_process *kfd_create_process(const struct task_struct *thread)\r\n{\r\nstruct kfd_process *process;\r\nBUG_ON(!kfd_process_wq);\r\nif (thread->mm == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (thread->group_leader->mm != thread->mm)\r\nreturn ERR_PTR(-EINVAL);\r\ndown_write(&thread->mm->mmap_sem);\r\nmutex_lock(&kfd_processes_mutex);\r\nprocess = find_process(thread);\r\nif (process)\r\npr_debug("kfd: process already found\n");\r\nif (!process)\r\nprocess = create_process(thread);\r\nmutex_unlock(&kfd_processes_mutex);\r\nup_write(&thread->mm->mmap_sem);\r\nreturn process;\r\n}\r\nstruct kfd_process *kfd_get_process(const struct task_struct *thread)\r\n{\r\nstruct kfd_process *process;\r\nif (thread->mm == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (thread->group_leader->mm != thread->mm)\r\nreturn ERR_PTR(-EINVAL);\r\nprocess = find_process(thread);\r\nreturn process;\r\n}\r\nstatic struct kfd_process *find_process_by_mm(const struct mm_struct *mm)\r\n{\r\nstruct kfd_process *process;\r\nhash_for_each_possible_rcu(kfd_processes_table, process,\r\nkfd_processes, (uintptr_t)mm)\r\nif (process->mm == mm)\r\nreturn process;\r\nreturn NULL;\r\n}\r\nstatic struct kfd_process *find_process(const struct task_struct *thread)\r\n{\r\nstruct kfd_process *p;\r\nint idx;\r\nidx = srcu_read_lock(&kfd_processes_srcu);\r\np = find_process_by_mm(thread->mm);\r\nsrcu_read_unlock(&kfd_processes_srcu, idx);\r\nreturn p;\r\n}\r\nstatic void kfd_process_wq_release(struct work_struct *work)\r\n{\r\nstruct kfd_process_release_work *my_work;\r\nstruct kfd_process_device *pdd, *temp;\r\nstruct kfd_process *p;\r\nmy_work = (struct kfd_process_release_work *) work;\r\np = my_work->p;\r\npr_debug("Releasing process (pasid %d) in workqueue\n",\r\np->pasid);\r\nmutex_lock(&p->mutex);\r\nlist_for_each_entry_safe(pdd, temp, &p->per_device_data,\r\nper_device_list) {\r\npr_debug("Releasing pdd (topology id %d) for process (pasid %d) in workqueue\n",\r\npdd->dev->id, p->pasid);\r\nif (pdd->reset_wavefronts)\r\ndbgdev_wave_reset_wavefronts(pdd->dev, p);\r\namd_iommu_unbind_pasid(pdd->dev->pdev, p->pasid);\r\nlist_del(&pdd->per_device_list);\r\nkfree(pdd);\r\n}\r\nkfd_event_free_process(p);\r\nkfd_pasid_free(p->pasid);\r\nmutex_unlock(&p->mutex);\r\nmutex_destroy(&p->mutex);\r\nkfree(p->queues);\r\nkfree(p);\r\nkfree((void *)work);\r\n}\r\nstatic void kfd_process_destroy_delayed(struct rcu_head *rcu)\r\n{\r\nstruct kfd_process_release_work *work;\r\nstruct kfd_process *p;\r\nBUG_ON(!kfd_process_wq);\r\np = container_of(rcu, struct kfd_process, rcu);\r\nBUG_ON(atomic_read(&p->mm->mm_count) <= 0);\r\nmmdrop(p->mm);\r\nwork = kmalloc(sizeof(struct kfd_process_release_work), GFP_ATOMIC);\r\nif (work) {\r\nINIT_WORK((struct work_struct *) work, kfd_process_wq_release);\r\nwork->p = p;\r\nqueue_work(kfd_process_wq, (struct work_struct *) work);\r\n}\r\n}\r\nstatic void kfd_process_notifier_release(struct mmu_notifier *mn,\r\nstruct mm_struct *mm)\r\n{\r\nstruct kfd_process *p;\r\nstruct kfd_process_device *pdd = NULL;\r\np = container_of(mn, struct kfd_process, mmu_notifier);\r\nBUG_ON(p->mm != mm);\r\nmutex_lock(&kfd_processes_mutex);\r\nhash_del_rcu(&p->kfd_processes);\r\nmutex_unlock(&kfd_processes_mutex);\r\nsynchronize_srcu(&kfd_processes_srcu);\r\nmutex_lock(&p->mutex);\r\npqm_uninit(&p->pqm);\r\nlist_for_each_entry(pdd, &p->per_device_data, per_device_list)\r\nif (pdd->reset_wavefronts) {\r\npr_warn("amdkfd: Resetting all wave fronts\n");\r\ndbgdev_wave_reset_wavefronts(pdd->dev, p);\r\npdd->reset_wavefronts = false;\r\n}\r\nmutex_unlock(&p->mutex);\r\natomic_inc(&p->mm->mm_count);\r\nmmu_notifier_unregister_no_release(&p->mmu_notifier, p->mm);\r\nmmu_notifier_call_srcu(&p->rcu, &kfd_process_destroy_delayed);\r\n}\r\nstatic struct kfd_process *create_process(const struct task_struct *thread)\r\n{\r\nstruct kfd_process *process;\r\nint err = -ENOMEM;\r\nprocess = kzalloc(sizeof(*process), GFP_KERNEL);\r\nif (!process)\r\ngoto err_alloc_process;\r\nprocess->queues = kmalloc_array(INITIAL_QUEUE_ARRAY_SIZE,\r\nsizeof(process->queues[0]), GFP_KERNEL);\r\nif (!process->queues)\r\ngoto err_alloc_queues;\r\nprocess->pasid = kfd_pasid_alloc();\r\nif (process->pasid == 0)\r\ngoto err_alloc_pasid;\r\nmutex_init(&process->mutex);\r\nprocess->mm = thread->mm;\r\nprocess->mmu_notifier.ops = &kfd_process_mmu_notifier_ops;\r\nerr = __mmu_notifier_register(&process->mmu_notifier, process->mm);\r\nif (err)\r\ngoto err_mmu_notifier;\r\nhash_add_rcu(kfd_processes_table, &process->kfd_processes,\r\n(uintptr_t)process->mm);\r\nprocess->lead_thread = thread->group_leader;\r\nprocess->queue_array_size = INITIAL_QUEUE_ARRAY_SIZE;\r\nINIT_LIST_HEAD(&process->per_device_data);\r\nkfd_event_init_process(process);\r\nerr = pqm_init(&process->pqm, process);\r\nif (err != 0)\r\ngoto err_process_pqm_init;\r\nprocess->is_32bit_user_mode = is_compat_task();\r\nif (kfd_init_apertures(process) != 0)\r\ngoto err_init_apretures;\r\nreturn process;\r\nerr_init_apretures:\r\npqm_uninit(&process->pqm);\r\nerr_process_pqm_init:\r\nhash_del_rcu(&process->kfd_processes);\r\nsynchronize_rcu();\r\nmmu_notifier_unregister_no_release(&process->mmu_notifier, process->mm);\r\nerr_mmu_notifier:\r\nkfd_pasid_free(process->pasid);\r\nerr_alloc_pasid:\r\nkfree(process->queues);\r\nerr_alloc_queues:\r\nkfree(process);\r\nerr_alloc_process:\r\nreturn ERR_PTR(err);\r\n}\r\nstruct kfd_process_device *kfd_get_process_device_data(struct kfd_dev *dev,\r\nstruct kfd_process *p)\r\n{\r\nstruct kfd_process_device *pdd = NULL;\r\nlist_for_each_entry(pdd, &p->per_device_data, per_device_list)\r\nif (pdd->dev == dev)\r\nbreak;\r\nreturn pdd;\r\n}\r\nstruct kfd_process_device *kfd_create_process_device_data(struct kfd_dev *dev,\r\nstruct kfd_process *p)\r\n{\r\nstruct kfd_process_device *pdd = NULL;\r\npdd = kzalloc(sizeof(*pdd), GFP_KERNEL);\r\nif (pdd != NULL) {\r\npdd->dev = dev;\r\nINIT_LIST_HEAD(&pdd->qpd.queues_list);\r\nINIT_LIST_HEAD(&pdd->qpd.priv_queue_list);\r\npdd->qpd.dqm = dev->dqm;\r\npdd->reset_wavefronts = false;\r\nlist_add(&pdd->per_device_list, &p->per_device_data);\r\n}\r\nreturn pdd;\r\n}\r\nstruct kfd_process_device *kfd_bind_process_to_device(struct kfd_dev *dev,\r\nstruct kfd_process *p)\r\n{\r\nstruct kfd_process_device *pdd;\r\nint err;\r\npdd = kfd_get_process_device_data(dev, p);\r\nif (!pdd) {\r\npr_err("Process device data doesn't exist\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (pdd->bound)\r\nreturn pdd;\r\nerr = amd_iommu_bind_pasid(dev->pdev, p->pasid, p->lead_thread);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\npdd->bound = true;\r\nreturn pdd;\r\n}\r\nvoid kfd_unbind_process_from_device(struct kfd_dev *dev, unsigned int pasid)\r\n{\r\nstruct kfd_process *p;\r\nstruct kfd_process_device *pdd;\r\nint idx, i;\r\nBUG_ON(dev == NULL);\r\nidx = srcu_read_lock(&kfd_processes_srcu);\r\nhash_for_each_rcu(kfd_processes_table, i, p, kfd_processes)\r\nif (p->pasid == pasid)\r\nbreak;\r\nsrcu_read_unlock(&kfd_processes_srcu, idx);\r\nBUG_ON(p->pasid != pasid);\r\nmutex_lock(&p->mutex);\r\nif ((dev->dbgmgr) && (dev->dbgmgr->pasid == p->pasid))\r\nkfd_dbgmgr_destroy(dev->dbgmgr);\r\npqm_uninit(&p->pqm);\r\npdd = kfd_get_process_device_data(dev, p);\r\nif (!pdd) {\r\nmutex_unlock(&p->mutex);\r\nreturn;\r\n}\r\nif (pdd->reset_wavefronts) {\r\ndbgdev_wave_reset_wavefronts(pdd->dev, p);\r\npdd->reset_wavefronts = false;\r\n}\r\npdd->bound = false;\r\nmutex_unlock(&p->mutex);\r\n}\r\nstruct kfd_process_device *kfd_get_first_process_device_data(struct kfd_process *p)\r\n{\r\nreturn list_first_entry(&p->per_device_data,\r\nstruct kfd_process_device,\r\nper_device_list);\r\n}\r\nstruct kfd_process_device *kfd_get_next_process_device_data(struct kfd_process *p,\r\nstruct kfd_process_device *pdd)\r\n{\r\nif (list_is_last(&pdd->per_device_list, &p->per_device_data))\r\nreturn NULL;\r\nreturn list_next_entry(pdd, per_device_list);\r\n}\r\nbool kfd_has_process_device_data(struct kfd_process *p)\r\n{\r\nreturn !(list_empty(&p->per_device_data));\r\n}\r\nstruct kfd_process *kfd_lookup_process_by_pasid(unsigned int pasid)\r\n{\r\nstruct kfd_process *p;\r\nunsigned int temp;\r\nint idx = srcu_read_lock(&kfd_processes_srcu);\r\nhash_for_each_rcu(kfd_processes_table, temp, p, kfd_processes) {\r\nif (p->pasid == pasid) {\r\nmutex_lock(&p->mutex);\r\nbreak;\r\n}\r\n}\r\nsrcu_read_unlock(&kfd_processes_srcu, idx);\r\nreturn p;\r\n}
