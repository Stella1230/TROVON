static unsigned find_nextpc(struct pt_regs *regs, int *flags)\r\n{\r\nunsigned size;\r\ns8 x8;\r\ns16 x16;\r\ns32 x32;\r\nu8 opc, *pc, *sp, *next;\r\nnext = 0;\r\n*flags = SINGLESTEP_PCREL;\r\npc = (u8 *) regs->pc;\r\nsp = (u8 *) (regs + 1);\r\nopc = *pc;\r\nsize = mn10300_insn_sizes[opc];\r\nif (size > 0) {\r\nnext = pc + size;\r\n} else {\r\nswitch (opc) {\r\ncase 0xc0 ... 0xca:\r\nx8 = 2;\r\nif (cond_table[regs->epsw & 0xf] & (1 << (opc & 0xf)))\r\nx8 = (s8)pc[1];\r\nnext = pc + x8;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xcc:\r\ncase 0xcd:\r\nREAD_WORD16(pc + 1, &x16);\r\nnext = pc + x16;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xdc:\r\ncase 0xdd:\r\nREAD_WORD32(pc + 1, &x32);\r\nnext = pc + x32;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xde:\r\nnext = (u8 *)regs->mdr;\r\n*flags &= ~SINGLESTEP_PCREL;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xdf:\r\nsp += pc[2];\r\nREAD_WORD32(sp, &x32);\r\nnext = (u8 *)x32;\r\n*flags &= ~SINGLESTEP_PCREL;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xf0:\r\nnext = pc + 2;\r\nopc = pc[1];\r\nif (opc >= 0xf0 && opc <= 0xf7) {\r\nswitch (opc & 3) {\r\ncase 0:\r\nnext = (u8 *)regs->a0;\r\nbreak;\r\ncase 1:\r\nnext = (u8 *)regs->a1;\r\nbreak;\r\ncase 2:\r\nnext = (u8 *)regs->a2;\r\nbreak;\r\ncase 3:\r\nnext = (u8 *)regs->a3;\r\nbreak;\r\n}\r\n*flags &= ~SINGLESTEP_PCREL;\r\n*flags |= SINGLESTEP_BRANCH;\r\n} else if (opc == 0xfc) {\r\nREAD_WORD32(sp, &x32);\r\nnext = (u8 *)x32;\r\n*flags &= ~SINGLESTEP_PCREL;\r\n*flags |= SINGLESTEP_BRANCH;\r\n} else if (opc == 0xfd) {\r\nREAD_WORD32(sp + 4, &x32);\r\nnext = (u8 *)x32;\r\n*flags &= ~SINGLESTEP_PCREL;\r\n*flags |= SINGLESTEP_BRANCH;\r\n}\r\nbreak;\r\ncase 0xf8:\r\nnext = pc + 3;\r\nopc = pc[1];\r\nif (opc >= 0xe8 && opc <= 0xeb &&\r\n(cond_table[regs->epsw & 0xf] &\r\n(1 << ((opc & 0xf) + 3)))\r\n) {\r\nREAD_BYTE(pc+2, &x8);\r\nnext = pc + x8;\r\n*flags |= SINGLESTEP_BRANCH;\r\n}\r\nbreak;\r\ncase 0xfa:\r\nif (pc[1] == 0xff) {\r\nREAD_WORD16(pc + 2, &x16);\r\nnext = pc + x16;\r\n} else\r\nnext = pc + 4;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xfc:\r\nx32 = 6;\r\nif (pc[1] == 0xff) {\r\nREAD_WORD32(pc + 2, &x32);\r\n}\r\nnext = pc + x32;\r\n*flags |= SINGLESTEP_BRANCH;\r\nbreak;\r\ncase 0xd0 ... 0xda:\r\ncase 0xdb:\r\npanic("Can't singlestep Lxx/SETLB\n");\r\nbreak;\r\n}\r\n}\r\nreturn (unsigned)next;\r\n}\r\nstatic unsigned __kprobes singlestep_branch_setup(struct pt_regs *regs)\r\n{\r\nu8 opc, *pc, *sp, *next;\r\nnext = NULL;\r\npc = (u8 *) regs->pc;\r\nsp = (u8 *) (regs + 1);\r\nswitch (pc[0]) {\r\ncase 0xc0 ... 0xca:\r\ncase 0xcc:\r\ncase 0xdc:\r\ncase 0xf8:\r\nnext = pc;\r\nbreak;\r\ncase 0xcd:\r\npc[1] = 5;\r\npc[2] = 0;\r\nnext = pc + 5;\r\nbreak;\r\ncase 0xdd:\r\npc[1] = 7;\r\npc[2] = 0;\r\npc[3] = 0;\r\npc[4] = 0;\r\nnext = pc + 7;\r\nbreak;\r\ncase 0xde:\r\nnext = pc + 3;\r\nregs->mdr = (unsigned) next;\r\nbreak;\r\ncase 0xdf:\r\nsp += pc[2];\r\nnext = pc + 3;\r\n*(unsigned *)sp = (unsigned) next;\r\nbreak;\r\ncase 0xf0:\r\nnext = pc + 2;\r\nopc = pc[1];\r\nif (opc >= 0xf0 && opc <= 0xf3) {\r\npc[0] = 0xfa;\r\npc[1] = 0xff;\r\npc[2] = 4;\r\npc[3] = 0;\r\nnext = pc + 4;\r\n} else if (opc >= 0xf4 && opc <= 0xf7) {\r\nnext = pc;\r\n} else if (opc == 0xfc) {\r\nnext = pc + 2;\r\n*(unsigned *) sp = (unsigned) next;\r\n} else if (opc == 0xfd) {\r\nnext = pc + 2;\r\n*(unsigned *)(sp + 4) = (unsigned) next;\r\n}\r\nbreak;\r\ncase 0xfa:\r\npc[2] = 4;\r\npc[3] = 0;\r\nnext = pc + 4;\r\nbreak;\r\ncase 0xfc:\r\npc[2] = 6;\r\npc[3] = 0;\r\npc[4] = 0;\r\npc[5] = 0;\r\nnext = pc + 6;\r\nbreak;\r\ncase 0xd0 ... 0xda:\r\ncase 0xdb:\r\npanic("Can't singlestep Lxx/SETLB\n");\r\n}\r\nreturn (unsigned) next;\r\n}\r\nint __kprobes arch_prepare_kprobe(struct kprobe *p)\r\n{\r\nreturn 0;\r\n}\r\nvoid __kprobes arch_copy_kprobe(struct kprobe *p)\r\n{\r\nmemcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE);\r\n}\r\nvoid __kprobes arch_arm_kprobe(struct kprobe *p)\r\n{\r\n*p->addr = BREAKPOINT_INSTRUCTION;\r\nflush_icache_range((unsigned long) p->addr,\r\n(unsigned long) p->addr + sizeof(kprobe_opcode_t));\r\n}\r\nvoid __kprobes arch_disarm_kprobe(struct kprobe *p)\r\n{\r\n#ifndef CONFIG_MN10300_CACHE_SNOOP\r\nmn10300_dcache_flush();\r\nmn10300_icache_inv();\r\n#endif\r\n}\r\nvoid arch_remove_kprobe(struct kprobe *p)\r\n{\r\n}\r\nstatic inline\r\nvoid __kprobes disarm_kprobe(struct kprobe *p, struct pt_regs *regs)\r\n{\r\n*p->addr = p->opcode;\r\nregs->pc = (unsigned long) p->addr;\r\n#ifndef CONFIG_MN10300_CACHE_SNOOP\r\nmn10300_dcache_flush();\r\nmn10300_icache_inv();\r\n#endif\r\n}\r\nstatic inline\r\nvoid __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nunsigned long nextpc;\r\ncur_kprobe_orig_pc = regs->pc;\r\nmemcpy(cur_kprobe_ss_buf, &p->ainsn.insn[0], MAX_INSN_SIZE);\r\nregs->pc = (unsigned long) cur_kprobe_ss_buf;\r\nnextpc = find_nextpc(regs, &cur_kprobe_ss_flags);\r\nif (cur_kprobe_ss_flags & SINGLESTEP_PCREL)\r\ncur_kprobe_next_pc = cur_kprobe_orig_pc + (nextpc - regs->pc);\r\nelse\r\ncur_kprobe_next_pc = nextpc;\r\nif (cur_kprobe_ss_flags & SINGLESTEP_BRANCH)\r\nnextpc = singlestep_branch_setup(regs);\r\ncur_kprobe_bp_addr = nextpc;\r\n*(u8 *) nextpc = BREAKPOINT_INSTRUCTION;\r\nmn10300_dcache_flush_range2((unsigned) cur_kprobe_ss_buf,\r\nsizeof(cur_kprobe_ss_buf));\r\nmn10300_icache_inv();\r\n}\r\nstatic inline int __kprobes kprobe_handler(struct pt_regs *regs)\r\n{\r\nstruct kprobe *p;\r\nint ret = 0;\r\nunsigned int *addr = (unsigned int *) regs->pc;\r\npreempt_disable();\r\nif (kprobe_running()) {\r\np = get_kprobe(addr);\r\nif (p) {\r\ndisarm_kprobe(p, regs);\r\nret = 1;\r\n} else {\r\np = cur_kprobe;\r\nif (p->break_handler && p->break_handler(p, regs))\r\ngoto ss_probe;\r\n}\r\ngoto no_kprobe;\r\n}\r\np = get_kprobe(addr);\r\nif (!p) {\r\nif (*addr != BREAKPOINT_INSTRUCTION) {\r\nret = 1;\r\n}\r\ngoto no_kprobe;\r\n}\r\nkprobe_status = KPROBE_HIT_ACTIVE;\r\ncur_kprobe = p;\r\nif (p->pre_handler(p, regs)) {\r\nreturn 1;\r\n}\r\nss_probe:\r\nprepare_singlestep(p, regs);\r\nkprobe_status = KPROBE_HIT_SS;\r\nreturn 1;\r\nno_kprobe:\r\npreempt_enable_no_resched();\r\nreturn ret;\r\n}\r\nstatic void __kprobes resume_execution(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nif (cur_kprobe_ss_flags & SINGLESTEP_BRANCH) {\r\nregs->pc = cur_kprobe_orig_pc;\r\nswitch (p->ainsn.insn[0]) {\r\ncase 0xcd:\r\n*(unsigned *) regs->sp = regs->mdr = regs->pc + 5;\r\nbreak;\r\ncase 0xdd:\r\n*(unsigned *) regs->sp = regs->mdr = regs->pc + 7;\r\nbreak;\r\ncase 0xf0:\r\nif (p->ainsn.insn[1] >= 0xf0 &&\r\np->ainsn.insn[1] <= 0xf3) {\r\nregs->mdr = regs->pc + 2;\r\n*(unsigned *) regs->sp = regs->mdr;\r\n}\r\nbreak;\r\ncase 0xfa:\r\n*(unsigned *) regs->sp = regs->mdr = regs->pc + 4;\r\nbreak;\r\ncase 0xfc:\r\n*(unsigned *) regs->sp = regs->mdr = regs->pc + 6;\r\nbreak;\r\n}\r\n}\r\nregs->pc = cur_kprobe_next_pc;\r\ncur_kprobe_bp_addr = 0;\r\n}\r\nstatic inline int __kprobes post_kprobe_handler(struct pt_regs *regs)\r\n{\r\nif (!kprobe_running())\r\nreturn 0;\r\nif (cur_kprobe->post_handler)\r\ncur_kprobe->post_handler(cur_kprobe, regs, 0);\r\nresume_execution(cur_kprobe, regs);\r\nreset_current_kprobe();\r\npreempt_enable_no_resched();\r\nreturn 1;\r\n}\r\nstatic inline\r\nint __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)\r\n{\r\nif (cur_kprobe->fault_handler &&\r\ncur_kprobe->fault_handler(cur_kprobe, regs, trapnr))\r\nreturn 1;\r\nif (kprobe_status & KPROBE_HIT_SS) {\r\nresume_execution(cur_kprobe, regs);\r\nreset_current_kprobe();\r\npreempt_enable_no_resched();\r\n}\r\nreturn 0;\r\n}\r\nint __kprobes kprobe_exceptions_notify(struct notifier_block *self,\r\nunsigned long val, void *data)\r\n{\r\nstruct die_args *args = data;\r\nswitch (val) {\r\ncase DIE_BREAKPOINT:\r\nif (cur_kprobe_bp_addr != args->regs->pc) {\r\nif (kprobe_handler(args->regs))\r\nreturn NOTIFY_STOP;\r\n} else {\r\nif (post_kprobe_handler(args->regs))\r\nreturn NOTIFY_STOP;\r\n}\r\nbreak;\r\ncase DIE_GPF:\r\nif (kprobe_running() &&\r\nkprobe_fault_handler(args->regs, args->trapnr))\r\nreturn NOTIFY_STOP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nint __kprobes setjmp_pre_handler(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nstruct jprobe *jp = container_of(p, struct jprobe, kp);\r\njprobe_saved_regs_location = regs;\r\nmemcpy(&jprobe_saved_regs, regs, sizeof(struct pt_regs));\r\nmemcpy(&jprobe_saved_stack, regs + 1, sizeof(jprobe_saved_stack));\r\nregs->pc = (unsigned long) jp->entry;\r\nreturn 1;\r\n}\r\nvoid __kprobes jprobe_return(void)\r\n{\r\nvoid *orig_sp = jprobe_saved_regs_location + 1;\r\npreempt_enable_no_resched();\r\nasm volatile(" mov %0,sp\n"\r\n".globl jprobe_return_bp_addr\n"\r\n"jprobe_return_bp_addr:\n\t"\r\n" .byte 0xff\n"\r\n: : "d" (orig_sp));\r\n}\r\nint __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nu8 *addr = (u8 *) regs->pc;\r\nif (addr == (u8 *) jprobe_return_bp_addr) {\r\nif (jprobe_saved_regs_location != regs) {\r\nprintk(KERN_ERR"JPROBE:"\r\n" Current regs (%p) does not match saved regs"\r\n" (%p).\n",\r\nregs, jprobe_saved_regs_location);\r\nBUG();\r\n}\r\nmemcpy(regs, &jprobe_saved_regs, sizeof(struct pt_regs));\r\nmemcpy(regs + 1, &jprobe_saved_stack,\r\nsizeof(jprobe_saved_stack));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint __init arch_init_kprobes(void)\r\n{\r\nreturn 0;\r\n}
