static void user_reader_timeout(unsigned long ptr)\r\n{\r\nstruct file_priv *priv = (struct file_priv *)ptr;\r\nschedule_work(&priv->work);\r\n}\r\nstatic void timeout_work(struct work_struct *work)\r\n{\r\nstruct file_priv *priv = container_of(work, struct file_priv, work);\r\nmutex_lock(&priv->buffer_mutex);\r\natomic_set(&priv->data_pending, 0);\r\nmemset(priv->data_buffer, 0, sizeof(priv->data_buffer));\r\nmutex_unlock(&priv->buffer_mutex);\r\n}\r\nstatic int tpm_open(struct inode *inode, struct file *file)\r\n{\r\nstruct tpm_chip *chip =\r\ncontainer_of(inode->i_cdev, struct tpm_chip, cdev);\r\nstruct file_priv *priv;\r\nif (test_and_set_bit(0, &chip->is_open)) {\r\ndev_dbg(chip->pdev, "Another process owns this TPM\n");\r\nreturn -EBUSY;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\nclear_bit(0, &chip->is_open);\r\nreturn -ENOMEM;\r\n}\r\npriv->chip = chip;\r\natomic_set(&priv->data_pending, 0);\r\nmutex_init(&priv->buffer_mutex);\r\nsetup_timer(&priv->user_read_timer, user_reader_timeout,\r\n(unsigned long)priv);\r\nINIT_WORK(&priv->work, timeout_work);\r\nfile->private_data = priv;\r\nget_device(chip->pdev);\r\nreturn 0;\r\n}\r\nstatic ssize_t tpm_read(struct file *file, char __user *buf,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct file_priv *priv = file->private_data;\r\nssize_t ret_size;\r\nint rc;\r\ndel_singleshot_timer_sync(&priv->user_read_timer);\r\nflush_work(&priv->work);\r\nret_size = atomic_read(&priv->data_pending);\r\nif (ret_size > 0) {\r\nssize_t orig_ret_size = ret_size;\r\nif (size < ret_size)\r\nret_size = size;\r\nmutex_lock(&priv->buffer_mutex);\r\nrc = copy_to_user(buf, priv->data_buffer, ret_size);\r\nmemset(priv->data_buffer, 0, orig_ret_size);\r\nif (rc)\r\nret_size = -EFAULT;\r\nmutex_unlock(&priv->buffer_mutex);\r\n}\r\natomic_set(&priv->data_pending, 0);\r\nreturn ret_size;\r\n}\r\nstatic ssize_t tpm_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct file_priv *priv = file->private_data;\r\nsize_t in_size = size;\r\nssize_t out_size;\r\nif (atomic_read(&priv->data_pending) != 0)\r\nreturn -EBUSY;\r\nif (in_size > TPM_BUFSIZE)\r\nreturn -E2BIG;\r\nmutex_lock(&priv->buffer_mutex);\r\nif (copy_from_user\r\n(priv->data_buffer, (void __user *) buf, in_size)) {\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn -EFAULT;\r\n}\r\nout_size = tpm_transmit(priv->chip, priv->data_buffer,\r\nsizeof(priv->data_buffer));\r\nif (out_size < 0) {\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn out_size;\r\n}\r\natomic_set(&priv->data_pending, out_size);\r\nmutex_unlock(&priv->buffer_mutex);\r\nmod_timer(&priv->user_read_timer, jiffies + (60 * HZ));\r\nreturn in_size;\r\n}\r\nstatic int tpm_release(struct inode *inode, struct file *file)\r\n{\r\nstruct file_priv *priv = file->private_data;\r\ndel_singleshot_timer_sync(&priv->user_read_timer);\r\nflush_work(&priv->work);\r\nfile->private_data = NULL;\r\natomic_set(&priv->data_pending, 0);\r\nclear_bit(0, &priv->chip->is_open);\r\nput_device(priv->chip->pdev);\r\nkfree(priv);\r\nreturn 0;\r\n}
