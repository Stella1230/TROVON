static inline int xgpio_index(struct xgpio_instance *chip, int gpio)\r\n{\r\nif (gpio >= chip->gpio_width[0])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int xgpio_regoffset(struct xgpio_instance *chip, int gpio)\r\n{\r\nif (xgpio_index(chip, gpio))\r\nreturn XGPIO_CHANNEL_OFFSET;\r\nreturn 0;\r\n}\r\nstatic inline int xgpio_offset(struct xgpio_instance *chip, int gpio)\r\n{\r\nif (xgpio_index(chip, gpio))\r\nreturn gpio - chip->gpio_width[0];\r\nreturn gpio;\r\n}\r\nstatic int xgpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nu32 val;\r\nval = xgpio_readreg(mm_gc->regs + XGPIO_DATA_OFFSET +\r\nxgpio_regoffset(chip, gpio));\r\nreturn !!(val & BIT(xgpio_offset(chip, gpio)));\r\n}\r\nstatic void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nint index = xgpio_index(chip, gpio);\r\nint offset = xgpio_offset(chip, gpio);\r\nspin_lock_irqsave(&chip->gpio_lock[index], flags);\r\nif (val)\r\nchip->gpio_state[index] |= BIT(offset);\r\nelse\r\nchip->gpio_state[index] &= ~BIT(offset);\r\nxgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET +\r\nxgpio_regoffset(chip, gpio), chip->gpio_state[index]);\r\nspin_unlock_irqrestore(&chip->gpio_lock[index], flags);\r\n}\r\nstatic int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nint index = xgpio_index(chip, gpio);\r\nint offset = xgpio_offset(chip, gpio);\r\nspin_lock_irqsave(&chip->gpio_lock[index], flags);\r\nchip->gpio_dir[index] |= BIT(offset);\r\nxgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET +\r\nxgpio_regoffset(chip, gpio), chip->gpio_dir[index]);\r\nspin_unlock_irqrestore(&chip->gpio_lock[index], flags);\r\nreturn 0;\r\n}\r\nstatic int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nint index = xgpio_index(chip, gpio);\r\nint offset = xgpio_offset(chip, gpio);\r\nspin_lock_irqsave(&chip->gpio_lock[index], flags);\r\nif (val)\r\nchip->gpio_state[index] |= BIT(offset);\r\nelse\r\nchip->gpio_state[index] &= ~BIT(offset);\r\nxgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET +\r\nxgpio_regoffset(chip, gpio), chip->gpio_state[index]);\r\nchip->gpio_dir[index] &= ~BIT(offset);\r\nxgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET +\r\nxgpio_regoffset(chip, gpio), chip->gpio_dir[index]);\r\nspin_unlock_irqrestore(&chip->gpio_lock[index], flags);\r\nreturn 0;\r\n}\r\nstatic void xgpio_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nxgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state[0]);\r\nxgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir[0]);\r\nif (!chip->gpio_width[1])\r\nreturn;\r\nxgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET + XGPIO_CHANNEL_OFFSET,\r\nchip->gpio_state[1]);\r\nxgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET + XGPIO_CHANNEL_OFFSET,\r\nchip->gpio_dir[1]);\r\n}\r\nstatic int xgpio_remove(struct platform_device *pdev)\r\n{\r\nstruct xgpio_instance *chip = platform_get_drvdata(pdev);\r\nof_mm_gpiochip_remove(&chip->mmchip);\r\nreturn 0;\r\n}\r\nstatic int xgpio_probe(struct platform_device *pdev)\r\n{\r\nstruct xgpio_instance *chip;\r\nint status = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 is_dual;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, chip);\r\nof_property_read_u32(np, "xlnx,dout-default", &chip->gpio_state[0]);\r\nif (of_property_read_u32(np, "xlnx,tri-default", &chip->gpio_dir[0]))\r\nchip->gpio_dir[0] = 0xFFFFFFFF;\r\nif (of_property_read_u32(np, "xlnx,gpio-width", &chip->gpio_width[0]))\r\nchip->gpio_width[0] = 32;\r\nspin_lock_init(&chip->gpio_lock[0]);\r\nif (of_property_read_u32(np, "xlnx,is-dual", &is_dual))\r\nis_dual = 0;\r\nif (is_dual) {\r\nof_property_read_u32(np, "xlnx,dout-default-2",\r\n&chip->gpio_state[1]);\r\nif (of_property_read_u32(np, "xlnx,tri-default-2",\r\n&chip->gpio_dir[1]))\r\nchip->gpio_dir[1] = 0xFFFFFFFF;\r\nif (of_property_read_u32(np, "xlnx,gpio2-width",\r\n&chip->gpio_width[1]))\r\nchip->gpio_width[1] = 32;\r\nspin_lock_init(&chip->gpio_lock[1]);\r\n}\r\nchip->mmchip.gc.ngpio = chip->gpio_width[0] + chip->gpio_width[1];\r\nchip->mmchip.gc.dev = &pdev->dev;\r\nchip->mmchip.gc.direction_input = xgpio_dir_in;\r\nchip->mmchip.gc.direction_output = xgpio_dir_out;\r\nchip->mmchip.gc.get = xgpio_get;\r\nchip->mmchip.gc.set = xgpio_set;\r\nchip->mmchip.save_regs = xgpio_save_regs;\r\nstatus = of_mm_gpiochip_add(np, &chip->mmchip);\r\nif (status) {\r\npr_err("%s: error in probe function with status %d\n",\r\nnp->full_name, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xgpio_init(void)\r\n{\r\nreturn platform_driver_register(&xgpio_plat_driver);\r\n}\r\nstatic void __exit xgpio_exit(void)\r\n{\r\nplatform_driver_unregister(&xgpio_plat_driver);\r\n}
