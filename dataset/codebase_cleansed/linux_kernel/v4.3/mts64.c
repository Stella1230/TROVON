static int snd_mts64_free(struct mts64 *mts)\r\n{\r\nkfree(mts);\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_create(struct snd_card *card,\r\nstruct pardevice *pardev,\r\nstruct mts64 **rchip)\r\n{\r\nstruct mts64 *mts;\r\n*rchip = NULL;\r\nmts = kzalloc(sizeof(struct mts64), GFP_KERNEL);\r\nif (mts == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&mts->lock);\r\nmts->card = card;\r\nmts->pardev = pardev;\r\nmts->current_midi_output_port = -1;\r\nmts->current_midi_input_port = -1;\r\n*rchip = mts;\r\nreturn 0;\r\n}\r\nstatic void mts64_enable_readout(struct parport *p)\r\n{\r\nu8 c;\r\nc = parport_read_control(p);\r\nc |= MTS64_CTL_READOUT;\r\nparport_write_control(p, c);\r\n}\r\nstatic void mts64_disable_readout(struct parport *p)\r\n{\r\nu8 c;\r\nc = parport_read_control(p);\r\nc &= ~MTS64_CTL_READOUT;\r\nparport_write_control(p, c);\r\n}\r\nstatic int mts64_device_ready(struct parport *p)\r\n{\r\nint i;\r\nu8 c;\r\nfor (i = 0; i < 0xffff; ++i) {\r\nc = parport_read_status(p);\r\nc &= MTS64_STAT_BSY;\r\nif (c != 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mts64_device_init(struct parport *p)\r\n{\r\nint i;\r\nmts64_write_command(p, MTS64_CMD_RESET);\r\nfor (i = 0; i < 64; ++i) {\r\nmsleep(100);\r\nif (mts64_probe(p) == 0) {\r\nmts64_disable_readout(p);\r\nreturn 0;\r\n}\r\n}\r\nmts64_disable_readout(p);\r\nreturn -EIO;\r\n}\r\nstatic int mts64_device_open(struct mts64 *mts)\r\n{\r\nint i;\r\nstruct parport *p = mts->pardev->port;\r\nfor (i = 0; i < 5; ++i)\r\nmts64_write_command(p, MTS64_CMD_COM_OPEN);\r\nreturn 0;\r\n}\r\nstatic int mts64_device_close(struct mts64 *mts)\r\n{\r\nint i;\r\nstruct parport *p = mts->pardev->port;\r\nfor (i = 0; i < 5; ++i) {\r\nmts64_write_command(p, MTS64_CMD_COM_CLOSE1);\r\nmts64_write_command(p, MTS64_CMD_COM_CLOSE2);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 mts64_map_midi_input(u8 c)\r\n{\r\nstatic u8 map[] = { 0, 1, 4, 2, 3 };\r\nreturn map[c];\r\n}\r\nstatic int mts64_probe(struct parport *p)\r\n{\r\nu8 c;\r\nmts64_smpte_stop(p);\r\nmts64_write_command(p, MTS64_CMD_PROBE);\r\nmsleep(50);\r\nc = mts64_read(p);\r\nc &= 0x00ff;\r\nif (c != MTS64_CMD_PROBE)\r\nreturn -ENODEV;\r\nelse\r\nreturn 0;\r\n}\r\nstatic u16 mts64_read(struct parport *p)\r\n{\r\nu8 data, status;\r\nmts64_device_ready(p);\r\nmts64_enable_readout(p);\r\nstatus = parport_read_status(p);\r\ndata = mts64_read_char(p);\r\nmts64_disable_readout(p);\r\nreturn (status << 8) | data;\r\n}\r\nstatic u8 mts64_read_char(struct parport *p)\r\n{\r\nu8 c = 0;\r\nu8 status;\r\nu8 i;\r\nfor (i = 0; i < 8; ++i) {\r\nparport_write_data(p, i);\r\nc >>= 1;\r\nstatus = parport_read_status(p);\r\nif (status & MTS64_STAT_BIT_SET)\r\nc |= 0x80;\r\n}\r\nreturn c;\r\n}\r\nstatic void mts64_smpte_start(struct parport *p,\r\nu8 hours, u8 minutes,\r\nu8 seconds, u8 frames,\r\nu8 idx)\r\n{\r\nstatic u8 fps[5] = { MTS64_CMD_SMPTE_FPS_24,\r\nMTS64_CMD_SMPTE_FPS_25,\r\nMTS64_CMD_SMPTE_FPS_2997,\r\nMTS64_CMD_SMPTE_FPS_30D,\r\nMTS64_CMD_SMPTE_FPS_30 };\r\nmts64_write_command(p, MTS64_CMD_SMPTE_SET_TIME);\r\nmts64_write_command(p, frames);\r\nmts64_write_command(p, seconds);\r\nmts64_write_command(p, minutes);\r\nmts64_write_command(p, hours);\r\nmts64_write_command(p, MTS64_CMD_SMPTE_SET_FPS);\r\nmts64_write_command(p, fps[idx]);\r\n}\r\nstatic void mts64_smpte_stop(struct parport *p)\r\n{\r\nmts64_write_command(p, MTS64_CMD_SMPTE_STOP);\r\n}\r\nstatic void mts64_write_command(struct parport *p, u8 c)\r\n{\r\nmts64_device_ready(p);\r\nparport_write_data(p, c);\r\nparport_write_control(p, MTS64_CTL_WRITE_CMD);\r\nparport_write_control(p, MTS64_CTL_WRITE_CMD | MTS64_CTL_STROBE);\r\nparport_write_control(p, MTS64_CTL_WRITE_CMD);\r\n}\r\nstatic void mts64_write_data(struct parport *p, u8 c)\r\n{\r\nmts64_device_ready(p);\r\nparport_write_data(p, c);\r\nparport_write_control(p, MTS64_CTL_WRITE_DATA);\r\nparport_write_control(p, MTS64_CTL_WRITE_DATA | MTS64_CTL_STROBE);\r\nparport_write_control(p, MTS64_CTL_WRITE_DATA);\r\n}\r\nstatic void mts64_write_midi(struct mts64 *mts, u8 c,\r\nint midiport)\r\n{\r\nstruct parport *p = mts->pardev->port;\r\nif (mts->current_midi_output_port != midiport)\r\nmts64_write_command(p, midiport);\r\nmts64_write_data(p, c);\r\n}\r\nstatic int snd_mts64_ctl_smpte_switch_get(struct snd_kcontrol* kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nspin_lock_irq(&mts->lock);\r\nuctl->value.integer.value[0] = mts->smpte_switch;\r\nspin_unlock_irq(&mts->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_switch_put(struct snd_kcontrol* kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nint changed = 0;\r\nint val = !!uctl->value.integer.value[0];\r\nspin_lock_irq(&mts->lock);\r\nif (mts->smpte_switch == val)\r\ngoto __out;\r\nchanged = 1;\r\nmts->smpte_switch = val;\r\nif (mts->smpte_switch) {\r\nmts64_smpte_start(mts->pardev->port,\r\nmts->time[0], mts->time[1],\r\nmts->time[2], mts->time[3],\r\nmts->fps);\r\n} else {\r\nmts64_smpte_stop(mts->pardev->port);\r\n}\r\n__out:\r\nspin_unlock_irq(&mts->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_mts64_ctl_smpte_time_h_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 23;\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_time_f_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 99;\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_time_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 59;\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_time_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nint idx = kctl->private_value;\r\nspin_lock_irq(&mts->lock);\r\nuctl->value.integer.value[0] = mts->time[idx];\r\nspin_unlock_irq(&mts->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_time_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nint idx = kctl->private_value;\r\nunsigned int time = uctl->value.integer.value[0] % 60;\r\nint changed = 0;\r\nspin_lock_irq(&mts->lock);\r\nif (mts->time[idx] != time) {\r\nchanged = 1;\r\nmts->time[idx] = time;\r\n}\r\nspin_unlock_irq(&mts->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_mts64_ctl_smpte_fps_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[5] = {\r\n"24", "25", "29.97", "30D", "30"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 5, texts);\r\n}\r\nstatic int snd_mts64_ctl_smpte_fps_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nspin_lock_irq(&mts->lock);\r\nuctl->value.enumerated.item[0] = mts->fps;\r\nspin_unlock_irq(&mts->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_ctl_smpte_fps_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct mts64 *mts = snd_kcontrol_chip(kctl);\r\nint changed = 0;\r\nif (uctl->value.enumerated.item[0] >= 5)\r\nreturn -EINVAL;\r\nspin_lock_irq(&mts->lock);\r\nif (mts->fps != uctl->value.enumerated.item[0]) {\r\nchanged = 1;\r\nmts->fps = uctl->value.enumerated.item[0];\r\n}\r\nspin_unlock_irq(&mts->lock);\r\nreturn changed;\r\n}\r\nstatic int snd_mts64_ctl_create(struct snd_card *card,\r\nstruct mts64 *mts)\r\n{\r\nint err, i;\r\nstatic struct snd_kcontrol_new *control[] = {\r\n&mts64_ctl_smpte_switch,\r\n&mts64_ctl_smpte_time_hours,\r\n&mts64_ctl_smpte_time_minutes,\r\n&mts64_ctl_smpte_time_seconds,\r\n&mts64_ctl_smpte_time_frames,\r\n&mts64_ctl_smpte_fps,\r\nNULL };\r\nfor (i = 0; control[i]; ++i) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(control[i], mts));\r\nif (err < 0) {\r\nsnd_printd("Cannot create control: %s\n",\r\ncontrol[i]->name);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_rawmidi_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mts64 *mts = substream->rmidi->private_data;\r\nif (mts->open_count == 0) {\r\nmts64_device_open(mts);\r\nmsleep(50);\r\n}\r\n++(mts->open_count);\r\nreturn 0;\r\n}\r\nstatic int snd_mts64_rawmidi_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct mts64 *mts = substream->rmidi->private_data;\r\nunsigned long flags;\r\n--(mts->open_count);\r\nif (mts->open_count == 0) {\r\nspin_lock_irqsave(&mts->lock, flags);\r\nmts64_device_close(mts);\r\nspin_unlock_irqrestore(&mts->lock, flags);\r\nmsleep(500);\r\n} else if (mts->open_count < 0)\r\nmts->open_count = 0;\r\nreturn 0;\r\n}\r\nstatic void snd_mts64_rawmidi_output_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct mts64 *mts = substream->rmidi->private_data;\r\nu8 data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mts->lock, flags);\r\nwhile (snd_rawmidi_transmit_peek(substream, &data, 1) == 1) {\r\nmts64_write_midi(mts, data, substream->number+1);\r\nsnd_rawmidi_transmit_ack(substream, 1);\r\n}\r\nspin_unlock_irqrestore(&mts->lock, flags);\r\n}\r\nstatic void snd_mts64_rawmidi_input_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct mts64 *mts = substream->rmidi->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mts->lock, flags);\r\nif (up)\r\nmts->mode[substream->number] |= MTS64_MODE_INPUT_TRIGGERED;\r\nelse\r\nmts->mode[substream->number] &= ~MTS64_MODE_INPUT_TRIGGERED;\r\nspin_unlock_irqrestore(&mts->lock, flags);\r\n}\r\nstatic int snd_mts64_rawmidi_create(struct snd_card *card)\r\n{\r\nstruct mts64 *mts = card->private_data;\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_rawmidi_substream *substream;\r\nstruct list_head *list;\r\nint err;\r\nerr = snd_rawmidi_new(card, CARD_NAME, 0,\r\nMTS64_NUM_OUTPUT_PORTS,\r\nMTS64_NUM_INPUT_PORTS,\r\n&rmidi);\r\nif (err < 0)\r\nreturn err;\r\nrmidi->private_data = mts;\r\nstrcpy(rmidi->name, CARD_NAME);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nmts->rmidi = rmidi;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&snd_mts64_rawmidi_output_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_mts64_rawmidi_input_ops);\r\nlist_for_each(list,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {\r\nsubstream = list_entry(list, struct snd_rawmidi_substream, list);\r\nsprintf(substream->name,\r\n"Miditerminal %d", substream->number+1);\r\n}\r\nlist_for_each(list,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {\r\nsubstream = list_entry(list, struct snd_rawmidi_substream, list);\r\nmts->midi_input_substream[substream->number] = substream;\r\nswitch(substream->number) {\r\ncase MTS64_SMPTE_SUBSTREAM:\r\nstrcpy(substream->name, "Miditerminal SMPTE");\r\nbreak;\r\ndefault:\r\nsprintf(substream->name,\r\n"Miditerminal %d", substream->number+1);\r\n}\r\n}\r\nerr = snd_mts64_ctl_create(card, mts);\r\nreturn err;\r\n}\r\nstatic void snd_mts64_interrupt(void *private)\r\n{\r\nstruct mts64 *mts = ((struct snd_card*)private)->private_data;\r\nu16 ret;\r\nu8 status, data;\r\nstruct snd_rawmidi_substream *substream;\r\nspin_lock(&mts->lock);\r\nret = mts64_read(mts->pardev->port);\r\ndata = ret & 0x00ff;\r\nstatus = ret >> 8;\r\nif (status & MTS64_STAT_PORT) {\r\nmts->current_midi_input_port = mts64_map_midi_input(data);\r\n} else {\r\nif (mts->current_midi_input_port == -1)\r\ngoto __out;\r\nsubstream = mts->midi_input_substream[mts->current_midi_input_port];\r\nif (mts->mode[substream->number] & MTS64_MODE_INPUT_TRIGGERED)\r\nsnd_rawmidi_receive(substream, &data, 1);\r\n}\r\n__out:\r\nspin_unlock(&mts->lock);\r\n}\r\nstatic int snd_mts64_probe_port(struct parport *p)\r\n{\r\nstruct pardevice *pardev;\r\nint res;\r\npardev = parport_register_device(p, DRIVER_NAME,\r\nNULL, NULL, NULL,\r\n0, NULL);\r\nif (!pardev)\r\nreturn -EIO;\r\nif (parport_claim(pardev)) {\r\nparport_unregister_device(pardev);\r\nreturn -EIO;\r\n}\r\nres = mts64_probe(p);\r\nparport_release(pardev);\r\nparport_unregister_device(pardev);\r\nreturn res;\r\n}\r\nstatic void snd_mts64_attach(struct parport *p)\r\n{\r\nstruct platform_device *device;\r\ndevice = platform_device_alloc(PLATFORM_DRIVER, device_count);\r\nif (!device)\r\nreturn;\r\nplatform_set_drvdata(device, p);\r\nif (platform_device_add(device) < 0) {\r\nplatform_device_put(device);\r\nreturn;\r\n}\r\nif (!platform_get_drvdata(device)) {\r\nplatform_device_unregister(device);\r\nreturn;\r\n}\r\nplatform_devices[device_count] = device;\r\ndevice_count++;\r\n}\r\nstatic void snd_mts64_detach(struct parport *p)\r\n{\r\n}\r\nstatic void snd_mts64_card_private_free(struct snd_card *card)\r\n{\r\nstruct mts64 *mts = card->private_data;\r\nstruct pardevice *pardev = mts->pardev;\r\nif (pardev) {\r\nif (mts->pardev_claimed)\r\nparport_release(pardev);\r\nparport_unregister_device(pardev);\r\n}\r\nsnd_mts64_free(mts);\r\n}\r\nstatic int snd_mts64_probe(struct platform_device *pdev)\r\n{\r\nstruct pardevice *pardev;\r\nstruct parport *p;\r\nint dev = pdev->id;\r\nstruct snd_card *card = NULL;\r\nstruct mts64 *mts = NULL;\r\nint err;\r\np = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev])\r\nreturn -ENOENT;\r\nif ((err = snd_mts64_probe_port(p)) < 0)\r\nreturn err;\r\nerr = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0) {\r\nsnd_printd("Cannot create card\n");\r\nreturn err;\r\n}\r\nstrcpy(card->driver, DRIVER_NAME);\r\nstrcpy(card->shortname, "ESI " CARD_NAME);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, p->base, p->irq);\r\npardev = parport_register_device(p,\r\nDRIVER_NAME,\r\nNULL,\r\nNULL,\r\nsnd_mts64_interrupt,\r\nPARPORT_DEV_EXCL,\r\n(void *)card);\r\nif (pardev == NULL) {\r\nsnd_printd("Cannot register pardevice\n");\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nif ((err = snd_mts64_create(card, pardev, &mts)) < 0) {\r\nsnd_printd("Cannot create main component\n");\r\nparport_unregister_device(pardev);\r\ngoto __err;\r\n}\r\ncard->private_data = mts;\r\ncard->private_free = snd_mts64_card_private_free;\r\nif ((err = snd_mts64_rawmidi_create(card)) < 0) {\r\nsnd_printd("Creating Rawmidi component failed\n");\r\ngoto __err;\r\n}\r\nif (parport_claim(pardev)) {\r\nsnd_printd("Cannot claim parport 0x%lx\n", pardev->port->base);\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nmts->pardev_claimed = 1;\r\nif ((err = mts64_device_init(p)) < 0)\r\ngoto __err;\r\nplatform_set_drvdata(pdev, card);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_printd("Cannot register card\n");\r\ngoto __err;\r\n}\r\nsnd_printk(KERN_INFO "ESI Miditerminal 4140 on 0x%lx\n", p->base);\r\nreturn 0;\r\n__err:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_mts64_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nif (card)\r\nsnd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic void snd_mts64_unregister_all(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SNDRV_CARDS; ++i) {\r\nif (platform_devices[i]) {\r\nplatform_device_unregister(platform_devices[i]);\r\nplatform_devices[i] = NULL;\r\n}\r\n}\r\nplatform_driver_unregister(&snd_mts64_driver);\r\nparport_unregister_driver(&mts64_parport_driver);\r\n}\r\nstatic int __init snd_mts64_module_init(void)\r\n{\r\nint err;\r\nif ((err = platform_driver_register(&snd_mts64_driver)) < 0)\r\nreturn err;\r\nif (parport_register_driver(&mts64_parport_driver) != 0) {\r\nplatform_driver_unregister(&snd_mts64_driver);\r\nreturn -EIO;\r\n}\r\nif (device_count == 0) {\r\nsnd_mts64_unregister_all();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit snd_mts64_module_exit(void)\r\n{\r\nsnd_mts64_unregister_all();\r\n}
