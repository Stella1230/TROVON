static int build_key(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_card_ir *ir = dev->remote;\r\nu32 gpio, data;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_GOTVIEW_7135:\r\nsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x80);\r\nsaa_clearb(SAA7134_GPIO_GPSTATUS1, 0x80);\r\nbreak;\r\n}\r\nsaa_clearb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3,SAA7134_GPIO_GPRESCAN);\r\ngpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nif (ir->polling) {\r\nif (ir->last_gpio == gpio)\r\nreturn 0;\r\nir->last_gpio = gpio;\r\n}\r\ndata = ir_extract_bits(gpio, ir->mask_keycode);\r\ninput_dbg("build_key gpio=0x%x mask=0x%x data=%d\n",\r\ngpio, ir->mask_keycode, data);\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_KWORLD_PLUS_TV_ANALOG:\r\nif (data == ir->mask_keycode)\r\nrc_keyup(ir->dev);\r\nelse\r\nrc_keydown_notimeout(ir->dev, RC_TYPE_UNKNOWN, data, 0);\r\nreturn 0;\r\n}\r\nif (ir->polling) {\r\nif ((ir->mask_keydown && (0 != (gpio & ir->mask_keydown))) ||\r\n(ir->mask_keyup && (0 == (gpio & ir->mask_keyup)))) {\r\nrc_keydown_notimeout(ir->dev, RC_TYPE_UNKNOWN, data, 0);\r\n} else {\r\nrc_keyup(ir->dev);\r\n}\r\n}\r\nelse {\r\nif ((ir->mask_keydown && (0 != (gpio & ir->mask_keydown))) ||\r\n(ir->mask_keyup && (0 == (gpio & ir->mask_keyup)))) {\r\nrc_keydown_notimeout(ir->dev, RC_TYPE_UNKNOWN, data, 0);\r\nrc_keyup(ir->dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_key_flydvb_trio(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nint gpio;\r\nint attempt = 0;\r\nunsigned char b;\r\nstruct saa7134_dev *dev = ir->c->adapter->algo_data;\r\nif (dev == NULL) {\r\nir_dbg(ir, "get_key_flydvb_trio: "\r\n"ir->c->adapter->algo_data is NULL!\n");\r\nreturn -EIO;\r\n}\r\nsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\ngpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nif (0x40000 & ~gpio)\r\nreturn 0;\r\nb = 0;\r\nwhile (1 != i2c_master_send(ir->c, &b, 1)) {\r\nif ((attempt++) < 10) {\r\nmsleep(10);\r\ncontinue;\r\n}\r\nir_dbg(ir, "send wake up byte to pic16C505 (IR chip)"\r\n"failed %dx\n", attempt);\r\nreturn -EIO;\r\n}\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_msi_tvanywhere_plus(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char b;\r\nint gpio;\r\nstruct saa7134_dev *dev = ir->c->adapter->algo_data;\r\nif (dev == NULL) {\r\nir_dbg(ir, "get_key_msi_tvanywhere_plus: "\r\n"ir->c->adapter->algo_data is NULL!\n");\r\nreturn -EIO;\r\n}\r\nsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\ngpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nif (gpio & 0x40)\r\nreturn 0;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (b == 0xff)\r\nreturn 0;\r\ninput_dbg("get_key_msi_tvanywhere_plus: Key = 0x%02X\n", b);\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_kworld_pc150u(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char b;\r\nunsigned int gpio;\r\nstruct saa7134_dev *dev = ir->c->adapter->algo_data;\r\nif (dev == NULL) {\r\nir_dbg(ir, "get_key_kworld_pc150u: "\r\n"ir->c->adapter->algo_data is NULL!\n");\r\nreturn -EIO;\r\n}\r\nsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\ngpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nif (gpio & 0x100)\r\nreturn 0;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (b == 0xff)\r\nreturn 0;\r\ninput_dbg("get_key_kworld_pc150u: Key = 0x%02X\n", b);\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_purpletv(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char b;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (b==0)\r\nreturn 0;\r\nif (b & 0x80)\r\nreturn 1;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_hvr1110(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char buf[5];\r\nif (5 != i2c_master_recv(ir->c, buf, 5))\r\nreturn -EIO;\r\nif (!(buf[0] & 0x80))\r\nreturn 0;\r\n*protocol = RC_TYPE_RC5;\r\n*scancode = RC_SCANCODE_RC5(buf[3] & 0x1f, buf[4] >> 2);\r\n*toggle = !!(buf[3] & 0x40);\r\nreturn 1;\r\n}\r\nstatic int get_key_beholdm6xx(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char data[12];\r\nu32 gpio;\r\nstruct saa7134_dev *dev = ir->c->adapter->algo_data;\r\nsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\ngpio = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nif (0x400000 & ~gpio)\r\nreturn 0;\r\nir->c->addr = 0x5a >> 1;\r\nif (12 != i2c_master_recv(ir->c, data, 12)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (data[9] != (unsigned char)(~data[8]))\r\nreturn 0;\r\n*protocol = RC_TYPE_NEC;\r\n*scancode = RC_SCANCODE_NECX(data[11] << 8 | data[10], data[9]);\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_pinnacle(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle, int parity_offset,\r\nint marker, int code_modulo)\r\n{\r\nunsigned char b[4];\r\nunsigned int start = 0,parity = 0,code = 0;\r\nif (4 != i2c_master_recv(ir->c, b, 4)) {\r\nir_dbg(ir, "read error\n");\r\nreturn -EIO;\r\n}\r\nfor (start = 0; start < ARRAY_SIZE(b); start++) {\r\nif (b[start] == marker) {\r\ncode=b[(start+parity_offset + 1) % 4];\r\nparity=b[(start+parity_offset) % 4];\r\n}\r\n}\r\nif (parity == 0)\r\nreturn 0;\r\nif (ir->old == parity)\r\nreturn 0;\r\nir->old = parity;\r\nif (marker == 0xfe && (code & 0x40))\r\nreturn 0;\r\ncode %= code_modulo;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = code;\r\n*toggle = 0;\r\nir_dbg(ir, "Pinnacle PCTV key %02x\n", code);\r\nreturn 1;\r\n}\r\nstatic int get_key_pinnacle_grey(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nreturn get_key_pinnacle(ir, protocol, scancode, toggle, 1, 0xfe, 0xff);\r\n}\r\nstatic int get_key_pinnacle_color(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nreturn get_key_pinnacle(ir, protocol, scancode, toggle, 2, 0x80, 0x88);\r\n}\r\nvoid saa7134_input_irq(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_card_ir *ir;\r\nif (!dev || !dev->remote)\r\nreturn;\r\nir = dev->remote;\r\nif (!ir->running)\r\nreturn;\r\nif (!ir->polling && !ir->raw_decode) {\r\nbuild_key(dev);\r\n} else if (ir->raw_decode) {\r\nsaa7134_raw_decode_irq(dev);\r\n}\r\n}\r\nstatic void saa7134_input_timer(unsigned long data)\r\n{\r\nstruct saa7134_dev *dev = (struct saa7134_dev *)data;\r\nstruct saa7134_card_ir *ir = dev->remote;\r\nbuild_key(dev);\r\nmod_timer(&ir->timer, jiffies + msecs_to_jiffies(ir->polling));\r\n}\r\nstatic void ir_raw_decode_timer_end(unsigned long data)\r\n{\r\nstruct saa7134_dev *dev = (struct saa7134_dev *)data;\r\nir_raw_event_handle(dev->remote->dev);\r\n}\r\nstatic int __saa7134_ir_start(void *priv)\r\n{\r\nstruct saa7134_dev *dev = priv;\r\nstruct saa7134_card_ir *ir;\r\nif (!dev || !dev->remote)\r\nreturn -EINVAL;\r\nir = dev->remote;\r\nif (ir->running)\r\nreturn 0;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_MD2819:\r\ncase SAA7134_BOARD_KWORLD_VSTREAM_XPERT:\r\ncase SAA7134_BOARD_AVERMEDIA_305:\r\ncase SAA7134_BOARD_AVERMEDIA_307:\r\ncase SAA7134_BOARD_AVERMEDIA_505:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_305:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_505:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_307:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_507:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_507UA:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM:\r\ncase SAA7134_BOARD_AVERMEDIA_M102:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM_PLUS:\r\nsaa_setb(SAA7134_GPIO_GPMODE0, 0x4);\r\nsaa_setb(SAA7134_GPIO_GPSTATUS0, 0x4);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_777:\r\ncase SAA7134_BOARD_AVERMEDIA_A16AR:\r\nsaa_setb(SAA7134_GPIO_GPMODE1, 0x1);\r\nsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x1);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A16D:\r\nsaa_setb(SAA7134_GPIO_GPMODE1, 0x1);\r\nsaa_setb(SAA7134_GPIO_GPSTATUS1, 0x1);\r\nbreak;\r\ncase SAA7134_BOARD_GOTVIEW_7135:\r\nsaa_setb(SAA7134_GPIO_GPMODE1, 0x80);\r\nbreak;\r\n}\r\nir->running = true;\r\nif (ir->polling) {\r\nsetup_timer(&ir->timer, saa7134_input_timer,\r\n(unsigned long)dev);\r\nir->timer.expires = jiffies + HZ;\r\nadd_timer(&ir->timer);\r\n} else if (ir->raw_decode) {\r\nsetup_timer(&ir->timer, ir_raw_decode_timer_end,\r\n(unsigned long)dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __saa7134_ir_stop(void *priv)\r\n{\r\nstruct saa7134_dev *dev = priv;\r\nstruct saa7134_card_ir *ir;\r\nif (!dev || !dev->remote)\r\nreturn;\r\nir = dev->remote;\r\nif (!ir->running)\r\nreturn;\r\nif (ir->polling || ir->raw_decode)\r\ndel_timer_sync(&ir->timer);\r\nir->running = false;\r\nreturn;\r\n}\r\nint saa7134_ir_start(struct saa7134_dev *dev)\r\n{\r\nif (dev->remote->users)\r\nreturn __saa7134_ir_start(dev);\r\nreturn 0;\r\n}\r\nvoid saa7134_ir_stop(struct saa7134_dev *dev)\r\n{\r\nif (dev->remote->users)\r\n__saa7134_ir_stop(dev);\r\n}\r\nstatic int saa7134_ir_open(struct rc_dev *rc)\r\n{\r\nstruct saa7134_dev *dev = rc->priv;\r\ndev->remote->users++;\r\nreturn __saa7134_ir_start(dev);\r\n}\r\nstatic void saa7134_ir_close(struct rc_dev *rc)\r\n{\r\nstruct saa7134_dev *dev = rc->priv;\r\ndev->remote->users--;\r\nif (!dev->remote->users)\r\n__saa7134_ir_stop(dev);\r\n}\r\nint saa7134_input_init1(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_card_ir *ir;\r\nstruct rc_dev *rc;\r\nchar *ir_codes = NULL;\r\nu32 mask_keycode = 0;\r\nu32 mask_keydown = 0;\r\nu32 mask_keyup = 0;\r\nunsigned polling = 0;\r\nbool raw_decode = false;\r\nint err;\r\nif (dev->has_remote != SAA7134_REMOTE_GPIO)\r\nreturn -ENODEV;\r\nif (disable_ir)\r\nreturn -ENODEV;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_FLYVIDEO2000:\r\ncase SAA7134_BOARD_FLYVIDEO3000:\r\ncase SAA7134_BOARD_FLYTVPLATINUM_FM:\r\ncase SAA7134_BOARD_FLYTVPLATINUM_MINI2:\r\ncase SAA7134_BOARD_ROVERMEDIA_LINK_PRO_FM:\r\nir_codes = RC_MAP_FLYVIDEO;\r\nmask_keycode = 0xEC00000;\r\nmask_keydown = 0x0040000;\r\nbreak;\r\ncase SAA7134_BOARD_CINERGY400:\r\ncase SAA7134_BOARD_CINERGY600:\r\ncase SAA7134_BOARD_CINERGY600_MK3:\r\nir_codes = RC_MAP_CINERGY;\r\nmask_keycode = 0x00003f;\r\nmask_keyup = 0x040000;\r\nbreak;\r\ncase SAA7134_BOARD_ECS_TVP3XP:\r\ncase SAA7134_BOARD_ECS_TVP3XP_4CB5:\r\nir_codes = RC_MAP_EZTV;\r\nmask_keycode = 0x00017c;\r\nmask_keyup = 0x000002;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_XPERT:\r\ncase SAA7134_BOARD_AVACSSMARTTV:\r\nir_codes = RC_MAP_PIXELVIEW;\r\nmask_keycode = 0x00001F;\r\nmask_keyup = 0x000020;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_MD2819:\r\ncase SAA7134_BOARD_KWORLD_VSTREAM_XPERT:\r\ncase SAA7134_BOARD_AVERMEDIA_305:\r\ncase SAA7134_BOARD_AVERMEDIA_307:\r\ncase SAA7134_BOARD_AVERMEDIA_505:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_305:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_505:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_307:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_507:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_507UA:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM:\r\ncase SAA7134_BOARD_AVERMEDIA_M102:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM_PLUS:\r\nir_codes = RC_MAP_AVERMEDIA;\r\nmask_keycode = 0x0007C8;\r\nmask_keydown = 0x000010;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_M135A:\r\nir_codes = RC_MAP_AVERMEDIA_M135A;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_M733A:\r\nir_codes = RC_MAP_AVERMEDIA_M733A_RM_K6;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_777:\r\ncase SAA7134_BOARD_AVERMEDIA_A16AR:\r\nir_codes = RC_MAP_AVERMEDIA;\r\nmask_keycode = 0x02F200;\r\nmask_keydown = 0x000400;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A16D:\r\nir_codes = RC_MAP_AVERMEDIA_A16D;\r\nmask_keycode = 0x02F200;\r\nmask_keydown = 0x000400;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_TERMINATOR:\r\nir_codes = RC_MAP_PIXELVIEW;\r\nmask_keycode = 0x00001f;\r\nmask_keyup = 0x000060;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_MANLI_MTV001:\r\ncase SAA7134_BOARD_MANLI_MTV002:\r\nir_codes = RC_MAP_MANLI;\r\nmask_keycode = 0x001f00;\r\nmask_keyup = 0x004000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_BEHOLD_409FM:\r\ncase SAA7134_BOARD_BEHOLD_401:\r\ncase SAA7134_BOARD_BEHOLD_403:\r\ncase SAA7134_BOARD_BEHOLD_403FM:\r\ncase SAA7134_BOARD_BEHOLD_405:\r\ncase SAA7134_BOARD_BEHOLD_405FM:\r\ncase SAA7134_BOARD_BEHOLD_407:\r\ncase SAA7134_BOARD_BEHOLD_407FM:\r\ncase SAA7134_BOARD_BEHOLD_409:\r\ncase SAA7134_BOARD_BEHOLD_505FM:\r\ncase SAA7134_BOARD_BEHOLD_505RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_505RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_507_9FM:\r\ncase SAA7134_BOARD_BEHOLD_507RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_507RDS_MK5:\r\nir_codes = RC_MAP_MANLI;\r\nmask_keycode = 0x003f00;\r\nmask_keyup = 0x004000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_BEHOLD_COLUMBUS_TVFM:\r\nir_codes = RC_MAP_BEHOLD_COLUMBUS;\r\nmask_keycode = 0x003f00;\r\nmask_keyup = 0x004000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_SEDNA_PC_TV_CARDBUS:\r\nir_codes = RC_MAP_PCTV_SEDNA;\r\nmask_keycode = 0x001f00;\r\nmask_keyup = 0x004000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_GOTVIEW_7135:\r\nir_codes = RC_MAP_GOTVIEW7135;\r\nmask_keycode = 0x0003CC;\r\nmask_keydown = 0x000010;\r\npolling = 5;\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_TV_PVR:\r\ncase SAA7134_BOARD_VIDEOMATE_GOLD_PLUS:\r\ncase SAA7134_BOARD_VIDEOMATE_TV_GOLD_PLUSII:\r\nir_codes = RC_MAP_VIDEOMATE_TV_PVR;\r\nmask_keycode = 0x00003F;\r\nmask_keyup = 0x400000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_PROTEUS_2309:\r\nir_codes = RC_MAP_PROTEUS_2309;\r\nmask_keycode = 0x00007F;\r\nmask_keyup = 0x000080;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_300:\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_200:\r\nir_codes = RC_MAP_VIDEOMATE_TV_PVR;\r\nmask_keycode = 0x003F00;\r\nmask_keyup = 0x040000;\r\nbreak;\r\ncase SAA7134_BOARD_FLYDVBS_LR300:\r\ncase SAA7134_BOARD_FLYDVBT_LR301:\r\ncase SAA7134_BOARD_FLYDVBTDUO:\r\nir_codes = RC_MAP_FLYDVB;\r\nmask_keycode = 0x0001F00;\r\nmask_keydown = 0x0040000;\r\nbreak;\r\ncase SAA7134_BOARD_ASUSTeK_P7131_DUAL:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_HYBRID_LNA:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_ANALOG:\r\nir_codes = RC_MAP_ASUS_PC39;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\ncase SAA7134_BOARD_ASUSTeK_PS3_100:\r\nir_codes = RC_MAP_ASUS_PS3_100;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\ncase SAA7134_BOARD_ENCORE_ENLTV:\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM:\r\nir_codes = RC_MAP_ENCORE_ENLTV;\r\nmask_keycode = 0x00007f;\r\nmask_keyup = 0x040000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM53:\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM3:\r\nir_codes = RC_MAP_ENCORE_ENLTV_FM53;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\ncase SAA7134_BOARD_10MOONSTVMASTER3:\r\nir_codes = RC_MAP_ENCORE_ENLTV;\r\nmask_keycode = 0x5f80000;\r\nmask_keyup = 0x8000000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_GENIUS_TVGO_A11MCE:\r\nir_codes = RC_MAP_GENIUS_TVGO_A11MCE;\r\nmask_keycode = 0xff;\r\nmask_keydown = 0xf00000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_REAL_ANGEL_220:\r\nir_codes = RC_MAP_REAL_AUDIO_220_32_KEYS;\r\nmask_keycode = 0x3f00;\r\nmask_keyup = 0x4000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_PLUS_TV_ANALOG:\r\nir_codes = RC_MAP_KWORLD_PLUS_TV_ANALOG;\r\nmask_keycode = 0x7f;\r\npolling = 40;\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_S350:\r\nir_codes = RC_MAP_VIDEOMATE_S350;\r\nmask_keycode = 0x003f00;\r\nmask_keydown = 0x040000;\r\nbreak;\r\ncase SAA7134_BOARD_LEADTEK_WINFAST_DTV1000S:\r\nir_codes = RC_MAP_WINFAST;\r\nmask_keycode = 0x5f00;\r\nmask_keyup = 0x020000;\r\npolling = 50;\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_M1F:\r\nir_codes = RC_MAP_VIDEOMATE_K100;\r\nmask_keycode = 0x0ff00;\r\nmask_keyup = 0x040000;\r\nbreak;\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1150:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1120:\r\nir_codes = RC_MAP_HAUPPAUGE;\r\nmask_keydown = 0x0040000;\r\nmask_keyup = 0x0040000;\r\nmask_keycode = 0xffff;\r\nraw_decode = true;\r\nbreak;\r\n}\r\nif (NULL == ir_codes) {\r\npr_err("Oops: IR config error [card=%d]\n", dev->board);\r\nreturn -ENODEV;\r\n}\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\nrc = rc_allocate_device();\r\nif (!ir || !rc) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nir->dev = rc;\r\ndev->remote = ir;\r\nir->mask_keycode = mask_keycode;\r\nir->mask_keydown = mask_keydown;\r\nir->mask_keyup = mask_keyup;\r\nir->polling = polling;\r\nir->raw_decode = raw_decode;\r\nsnprintf(ir->name, sizeof(ir->name), "saa7134 IR (%s)",\r\nsaa7134_boards[dev->board].name);\r\nsnprintf(ir->phys, sizeof(ir->phys), "pci-%s/ir0",\r\npci_name(dev->pci));\r\nrc->priv = dev;\r\nrc->open = saa7134_ir_open;\r\nrc->close = saa7134_ir_close;\r\nif (raw_decode)\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nrc->input_id.bustype = BUS_PCI;\r\nrc->input_id.version = 1;\r\nif (dev->pci->subsystem_vendor) {\r\nrc->input_id.vendor = dev->pci->subsystem_vendor;\r\nrc->input_id.product = dev->pci->subsystem_device;\r\n} else {\r\nrc->input_id.vendor = dev->pci->vendor;\r\nrc->input_id.product = dev->pci->device;\r\n}\r\nrc->dev.parent = &dev->pci->dev;\r\nrc->map_name = ir_codes;\r\nrc->driver_name = MODULE_NAME;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto err_out_free;\r\nreturn 0;\r\nerr_out_free:\r\nrc_free_device(rc);\r\ndev->remote = NULL;\r\nkfree(ir);\r\nreturn err;\r\n}\r\nvoid saa7134_input_fini(struct saa7134_dev *dev)\r\n{\r\nif (NULL == dev->remote)\r\nreturn;\r\nsaa7134_ir_stop(dev);\r\nrc_unregister_device(dev->remote->dev);\r\nkfree(dev->remote);\r\ndev->remote = NULL;\r\n}\r\nvoid saa7134_probe_i2c_ir(struct saa7134_dev *dev)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_msg msg_msi = {\r\n.addr = 0x50,\r\n.flags = I2C_M_RD,\r\n.len = 0,\r\n.buf = NULL,\r\n};\r\nint rc;\r\nif (disable_ir) {\r\ninput_dbg("IR has been disabled, not probing for i2c remote\n");\r\nreturn;\r\n}\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nmemset(&dev->init_data, 0, sizeof(dev->init_data));\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_PINNACLE_PCTV_110i:\r\ncase SAA7134_BOARD_PINNACLE_PCTV_310i:\r\ndev->init_data.name = "Pinnacle PCTV";\r\nif (pinnacle_remote == 0) {\r\ndev->init_data.get_key = get_key_pinnacle_color;\r\ndev->init_data.ir_codes = RC_MAP_PINNACLE_COLOR;\r\ninfo.addr = 0x47;\r\n} else {\r\ndev->init_data.get_key = get_key_pinnacle_grey;\r\ndev->init_data.ir_codes = RC_MAP_PINNACLE_GREY;\r\ninfo.addr = 0x47;\r\n}\r\nbreak;\r\ncase SAA7134_BOARD_UPMOST_PURPLE_TV:\r\ndev->init_data.name = "Purple TV";\r\ndev->init_data.get_key = get_key_purpletv;\r\ndev->init_data.ir_codes = RC_MAP_PURPLETV;\r\ninfo.addr = 0x7a;\r\nbreak;\r\ncase SAA7134_BOARD_MSI_TVATANYWHERE_PLUS:\r\ndev->init_data.name = "MSI TV@nywhere Plus";\r\ndev->init_data.get_key = get_key_msi_tvanywhere_plus;\r\ndev->init_data.ir_codes = RC_MAP_MSI_TVANYWHERE_PLUS;\r\ndev->init_data.polling_interval = 50;\r\ninfo.addr = 0x30;\r\nrc = i2c_transfer(&dev->i2c_adap, &msg_msi, 1);\r\ninput_dbg("probe 0x%02x @ %s: %s\n",\r\nmsg_msi.addr, dev->i2c_adap.name,\r\n(1 == rc) ? "yes" : "no");\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_PC150U:\r\ndev->init_data.name = "Kworld PC150-U";\r\ndev->init_data.get_key = get_key_kworld_pc150u;\r\ndev->init_data.ir_codes = RC_MAP_KWORLD_PC150U;\r\ninfo.addr = 0x30;\r\nrc = i2c_transfer(&dev->i2c_adap, &msg_msi, 1);\r\ninput_dbg("probe 0x%02x @ %s: %s\n",\r\nmsg_msi.addr, dev->i2c_adap.name,\r\n(1 == rc) ? "yes" : "no");\r\nbreak;\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1110:\r\ndev->init_data.name = "HVR 1110";\r\ndev->init_data.get_key = get_key_hvr1110;\r\ndev->init_data.ir_codes = RC_MAP_HAUPPAUGE;\r\ninfo.addr = 0x71;\r\nbreak;\r\ncase SAA7134_BOARD_BEHOLD_607FM_MK3:\r\ncase SAA7134_BOARD_BEHOLD_607FM_MK5:\r\ncase SAA7134_BOARD_BEHOLD_609FM_MK3:\r\ncase SAA7134_BOARD_BEHOLD_609FM_MK5:\r\ncase SAA7134_BOARD_BEHOLD_607RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_607RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_609RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_609RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_M6:\r\ncase SAA7134_BOARD_BEHOLD_M63:\r\ncase SAA7134_BOARD_BEHOLD_M6_EXTRA:\r\ncase SAA7134_BOARD_BEHOLD_H6:\r\ncase SAA7134_BOARD_BEHOLD_X7:\r\ncase SAA7134_BOARD_BEHOLD_H7:\r\ncase SAA7134_BOARD_BEHOLD_A7:\r\ndev->init_data.name = "BeholdTV";\r\ndev->init_data.get_key = get_key_beholdm6xx;\r\ndev->init_data.ir_codes = RC_MAP_BEHOLD;\r\ndev->init_data.type = RC_BIT_NEC;\r\ninfo.addr = 0x2d;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_501:\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_506:\r\ninfo.addr = 0x40;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A706:\r\ninfo.addr = 0x41;\r\nbreak;\r\ncase SAA7134_BOARD_FLYDVB_TRIO:\r\ndev->init_data.name = "FlyDVB Trio";\r\ndev->init_data.get_key = get_key_flydvb_trio;\r\ndev->init_data.ir_codes = RC_MAP_FLYDVB;\r\ninfo.addr = 0x0b;\r\nbreak;\r\ndefault:\r\ninput_dbg("No I2C IR support for board %x\n", dev->board);\r\nreturn;\r\n}\r\nif (dev->init_data.name)\r\ninfo.platform_data = &dev->init_data;\r\ni2c_new_device(&dev->i2c_adap, &info);\r\n}\r\nstatic int saa7134_raw_decode_irq(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_card_ir *ir = dev->remote;\r\nunsigned long timeout;\r\nint space;\r\nsaa_clearb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nsaa_setb(SAA7134_GPIO_GPMODE3, SAA7134_GPIO_GPRESCAN);\r\nspace = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2) & ir->mask_keydown;\r\nir_raw_event_store_edge(dev->remote->dev, space ? IR_SPACE : IR_PULSE);\r\nsmp_mb();\r\nif (!timer_pending(&ir->timer)) {\r\ntimeout = jiffies + msecs_to_jiffies(15);\r\nmod_timer(&ir->timer, timeout);\r\n}\r\nreturn 1;\r\n}
