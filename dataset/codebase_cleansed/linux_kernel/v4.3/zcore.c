int memcpy_hsa(void *dest, unsigned long src, size_t count, int mode)\r\n{\r\nint offs, blk_num;\r\nstatic char buf[PAGE_SIZE] __attribute__((__aligned__(PAGE_SIZE)));\r\nif (!hsa_available)\r\nreturn -ENODATA;\r\nif (count == 0)\r\nreturn 0;\r\noffs = 0;\r\nif ((src % PAGE_SIZE) != 0) {\r\nblk_num = src / PAGE_SIZE + 2;\r\nif (sclp_sdias_copy(buf, blk_num, 1)) {\r\nTRACE("sclp_sdias_copy() failed\n");\r\nreturn -EIO;\r\n}\r\noffs = min((PAGE_SIZE - (src % PAGE_SIZE)), count);\r\nif (mode == TO_USER) {\r\nif (copy_to_user((__force __user void*) dest,\r\nbuf + (src % PAGE_SIZE), offs))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(dest, buf + (src % PAGE_SIZE), offs);\r\n}\r\nif (offs == count)\r\ngoto out;\r\nfor (; (offs + PAGE_SIZE) <= count; offs += PAGE_SIZE) {\r\nblk_num = (src + offs) / PAGE_SIZE + 2;\r\nif (sclp_sdias_copy(buf, blk_num, 1)) {\r\nTRACE("sclp_sdias_copy() failed\n");\r\nreturn -EIO;\r\n}\r\nif (mode == TO_USER) {\r\nif (copy_to_user((__force __user void*) dest + offs,\r\nbuf, PAGE_SIZE))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(dest + offs, buf, PAGE_SIZE);\r\n}\r\nif (offs == count)\r\ngoto out;\r\nblk_num = (src + offs) / PAGE_SIZE + 2;\r\nif (sclp_sdias_copy(buf, blk_num, 1)) {\r\nTRACE("sclp_sdias_copy() failed\n");\r\nreturn -EIO;\r\n}\r\nif (mode == TO_USER) {\r\nif (copy_to_user((__force __user void*) dest + offs, buf,\r\ncount - offs))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(dest + offs, buf, count - offs);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int memcpy_hsa_user(void __user *dest, unsigned long src, size_t count)\r\n{\r\nreturn memcpy_hsa((void __force *) dest, src, count, TO_USER);\r\n}\r\nstatic int memcpy_hsa_kernel(void *dest, unsigned long src, size_t count)\r\n{\r\nreturn memcpy_hsa(dest, src, count, TO_KERNEL);\r\n}\r\nstatic int __init init_cpu_info(enum arch_id arch)\r\n{\r\nstruct save_area_ext *sa_ext;\r\nsa_ext = dump_save_areas.areas[0];\r\nif (!sa_ext)\r\nreturn -ENOMEM;\r\nif (memcpy_hsa_kernel(&sa_ext->sa, sys_info.sa_base,\r\nsys_info.sa_size) < 0) {\r\nTRACE("could not copy from HSA\n");\r\nkfree(sa_ext);\r\nreturn -EIO;\r\n}\r\nif (MACHINE_HAS_VX)\r\nsave_vx_regs_safe(sa_ext->vx_regs);\r\nreturn 0;\r\n}\r\nstatic int copy_lc(void __user *buf, void *sa, int sa_off, int len)\r\n{\r\nint i;\r\nchar *lc_mask = (char*)&sys_info.lc_mask;\r\nfor (i = 0; i < len; i++) {\r\nif (!lc_mask[i + sa_off])\r\ncontinue;\r\nif (copy_to_user(buf + i, sa + sa_off + i, 1))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zcore_add_lc(char __user *buf, unsigned long start, size_t count)\r\n{\r\nunsigned long end;\r\nint i;\r\nif (count == 0)\r\nreturn 0;\r\nend = start + count;\r\nfor (i = 0; i < dump_save_areas.count; i++) {\r\nunsigned long cp_start, cp_end;\r\nunsigned long sa_start, sa_end;\r\nunsigned long prefix;\r\nunsigned long sa_off, len, buf_off;\r\nstruct save_area *save_area = &dump_save_areas.areas[i]->sa;\r\nprefix = save_area->pref_reg;\r\nsa_start = prefix + sys_info.sa_base;\r\nsa_end = prefix + sys_info.sa_base + sys_info.sa_size;\r\nif ((end < sa_start) || (start > sa_end))\r\ncontinue;\r\ncp_start = max(start, sa_start);\r\ncp_end = min(end, sa_end);\r\nbuf_off = cp_start - start;\r\nsa_off = cp_start - sa_start;\r\nlen = cp_end - cp_start;\r\nTRACE("copy_lc for: %lx\n", start);\r\nif (copy_lc(buf + buf_off, save_area, sa_off, len))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_hsa(void)\r\n{\r\ndiag308(DIAG308_REL_HSA, NULL);\r\nhsa_available = 0;\r\n}\r\nstatic ssize_t zcore_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned long mem_start;\r\nsize_t mem_offs;\r\nsize_t hdr_count;\r\nsize_t size;\r\nint rc;\r\nmutex_lock(&zcore_mutex);\r\nif (*ppos > (sys_info.mem_size + HEADER_SIZE)) {\r\nrc = -EINVAL;\r\ngoto fail;\r\n}\r\ncount = min(count, (size_t) (sys_info.mem_size + HEADER_SIZE - *ppos));\r\nif (*ppos < HEADER_SIZE) {\r\nsize = min(count, (size_t) (HEADER_SIZE - *ppos));\r\nif (copy_to_user(buf, &zcore_header + *ppos, size)) {\r\nrc = -EFAULT;\r\ngoto fail;\r\n}\r\nhdr_count = size;\r\nmem_start = 0;\r\n} else {\r\nhdr_count = 0;\r\nmem_start = *ppos - HEADER_SIZE;\r\n}\r\nmem_offs = 0;\r\nif (*ppos < sclp.hsa_size + HEADER_SIZE) {\r\nsize = min((count - hdr_count),\r\n(size_t) (sclp.hsa_size - mem_start));\r\nrc = memcpy_hsa_user(buf + hdr_count, mem_start, size);\r\nif (rc)\r\ngoto fail;\r\nmem_offs += size;\r\n}\r\nsize = count - mem_offs - hdr_count;\r\nrc = copy_to_user_real(buf + hdr_count + mem_offs,\r\n(void *) mem_start + mem_offs, size);\r\nif (rc)\r\ngoto fail;\r\nif (zcore_add_lc(buf + hdr_count, mem_start, count - hdr_count)) {\r\nrc = -EFAULT;\r\ngoto fail;\r\n}\r\n*ppos += count;\r\nfail:\r\nmutex_unlock(&zcore_mutex);\r\nreturn (rc < 0) ? rc : count;\r\n}\r\nstatic int zcore_open(struct inode *inode, struct file *filp)\r\n{\r\nif (!hsa_available)\r\nreturn -ENODATA;\r\nelse\r\nreturn capable(CAP_SYS_RAWIO) ? 0 : -EPERM;\r\n}\r\nstatic int zcore_release(struct inode *inode, struct file *filep)\r\n{\r\nif (hsa_available)\r\nrelease_hsa();\r\nreturn 0;\r\n}\r\nstatic loff_t zcore_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nloff_t rc;\r\nmutex_lock(&zcore_mutex);\r\nswitch (orig) {\r\ncase 0:\r\nfile->f_pos = offset;\r\nrc = file->f_pos;\r\nbreak;\r\ncase 1:\r\nfile->f_pos += offset;\r\nrc = file->f_pos;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nmutex_unlock(&zcore_mutex);\r\nreturn rc;\r\n}\r\nstatic ssize_t zcore_memmap_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, count, ppos, filp->private_data,\r\nmemblock.memory.cnt * CHUNK_INFO_SIZE);\r\n}\r\nstatic int zcore_memmap_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct memblock_region *reg;\r\nchar *buf;\r\nint i = 0;\r\nbuf = kzalloc(memblock.memory.cnt * CHUNK_INFO_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\nreturn -ENOMEM;\r\n}\r\nfor_each_memblock(memory, reg) {\r\nsprintf(buf + (i++ * CHUNK_INFO_SIZE), "%016llx %016llx ",\r\n(unsigned long long) reg->base,\r\n(unsigned long long) reg->size);\r\n}\r\nfilp->private_data = buf;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcore_memmap_release(struct inode *inode, struct file *filp)\r\n{\r\nkfree(filp->private_data);\r\nreturn 0;\r\n}\r\nstatic ssize_t zcore_reipl_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (ipl_block) {\r\ndiag308(DIAG308_SET, ipl_block);\r\ndiag308(DIAG308_IPL, NULL);\r\n}\r\nreturn count;\r\n}\r\nstatic int zcore_reipl_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcore_reipl_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t zcore_hsa_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstatic char str[18];\r\nif (hsa_available)\r\nsnprintf(str, sizeof(str), "%lx\n", sclp.hsa_size);\r\nelse\r\nsnprintf(str, sizeof(str), "0\n");\r\nreturn simple_read_from_buffer(buf, count, ppos, str, strlen(str));\r\n}\r\nstatic ssize_t zcore_hsa_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar value;\r\nif (*ppos != 0)\r\nreturn -EPIPE;\r\nif (copy_from_user(&value, buf, 1))\r\nreturn -EFAULT;\r\nif (value != '0')\r\nreturn -EINVAL;\r\nrelease_hsa();\r\nreturn count;\r\n}\r\nstatic void __init set_lc_mask(struct save_area *map)\r\n{\r\nmemset(&map->fp_regs, 0xff, sizeof(map->fp_regs));\r\nmemset(&map->gp_regs, 0xff, sizeof(map->gp_regs));\r\nmemset(&map->psw, 0xff, sizeof(map->psw));\r\nmemset(&map->pref_reg, 0xff, sizeof(map->pref_reg));\r\nmemset(&map->fp_ctrl_reg, 0xff, sizeof(map->fp_ctrl_reg));\r\nmemset(&map->tod_reg, 0xff, sizeof(map->tod_reg));\r\nmemset(&map->timer, 0xff, sizeof(map->timer));\r\nmemset(&map->clk_cmp, 0xff, sizeof(map->clk_cmp));\r\nmemset(&map->acc_regs, 0xff, sizeof(map->acc_regs));\r\nmemset(&map->ctrl_regs, 0xff, sizeof(map->ctrl_regs));\r\n}\r\nstatic int __init sys_info_init(enum arch_id arch, unsigned long mem_end)\r\n{\r\nint rc;\r\nswitch (arch) {\r\ncase ARCH_S390X:\r\npr_alert("DETECTED 'S390X (64 bit) OS'\n");\r\nbreak;\r\ncase ARCH_S390:\r\npr_alert("DETECTED 'S390 (32 bit) OS'\n");\r\nbreak;\r\ndefault:\r\npr_alert("0x%x is an unknown architecture.\n",arch);\r\nreturn -EINVAL;\r\n}\r\nsys_info.sa_base = SAVE_AREA_BASE;\r\nsys_info.sa_size = sizeof(struct save_area);\r\nsys_info.arch = arch;\r\nset_lc_mask(&sys_info.lc_mask);\r\nrc = init_cpu_info(arch);\r\nif (rc)\r\nreturn rc;\r\nsys_info.mem_size = mem_end;\r\nreturn 0;\r\n}\r\nstatic int __init check_sdias(void)\r\n{\r\nif (!sclp.hsa_size) {\r\nTRACE("Could not determine HSA size\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init get_mem_info(unsigned long *mem, unsigned long *end)\r\n{\r\nstruct memblock_region *reg;\r\nfor_each_memblock(memory, reg) {\r\n*mem += reg->size;\r\n*end = max_t(unsigned long, *end, reg->base + reg->size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init zcore_header_init(int arch, struct zcore_header *hdr,\r\nunsigned long mem_size)\r\n{\r\nu32 prefix;\r\nint i;\r\nif (arch == ARCH_S390X)\r\nhdr->arch_id = DUMP_ARCH_S390X;\r\nelse\r\nhdr->arch_id = DUMP_ARCH_S390;\r\nhdr->mem_size = mem_size;\r\nhdr->rmem_size = mem_size;\r\nhdr->mem_end = sys_info.mem_size;\r\nhdr->num_pages = mem_size / PAGE_SIZE;\r\nhdr->tod = get_tod_clock();\r\nget_cpu_id(&hdr->cpu_id);\r\nfor (i = 0; i < dump_save_areas.count; i++) {\r\nprefix = dump_save_areas.areas[i]->sa.pref_reg;\r\nhdr->real_cpu_cnt++;\r\nif (!prefix)\r\ncontinue;\r\nhdr->lc_vec[hdr->cpu_cnt] = prefix;\r\nhdr->cpu_cnt++;\r\n}\r\n}\r\nstatic int __init zcore_reipl_init(void)\r\n{\r\nstruct ipib_info ipib_info;\r\nint rc;\r\nrc = memcpy_hsa_kernel(&ipib_info, __LC_DUMP_REIPL, sizeof(ipib_info));\r\nif (rc)\r\nreturn rc;\r\nif (ipib_info.ipib == 0)\r\nreturn 0;\r\nipl_block = (void *) __get_free_page(GFP_KERNEL);\r\nif (!ipl_block)\r\nreturn -ENOMEM;\r\nif (ipib_info.ipib < sclp.hsa_size)\r\nrc = memcpy_hsa_kernel(ipl_block, ipib_info.ipib, PAGE_SIZE);\r\nelse\r\nrc = memcpy_real(ipl_block, (void *) ipib_info.ipib, PAGE_SIZE);\r\nif (rc || csum_partial(ipl_block, ipl_block->hdr.len, 0) !=\r\nipib_info.checksum) {\r\nTRACE("Checksum does not match\n");\r\nfree_page((unsigned long) ipl_block);\r\nipl_block = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init zcore_init(void)\r\n{\r\nunsigned long mem_size, mem_end;\r\nunsigned char arch;\r\nint rc;\r\nmem_size = mem_end = 0;\r\nif (ipl_info.type != IPL_TYPE_FCP_DUMP)\r\nreturn -ENODATA;\r\nif (OLDMEM_BASE)\r\nreturn -ENODATA;\r\nzcore_dbf = debug_register("zcore", 4, 1, 4 * sizeof(long));\r\ndebug_register_view(zcore_dbf, &debug_sprintf_view);\r\ndebug_set_level(zcore_dbf, 6);\r\nTRACE("devno: %x\n", ipl_info.data.fcp.dev_id.devno);\r\nTRACE("wwpn: %llx\n", (unsigned long long) ipl_info.data.fcp.wwpn);\r\nTRACE("lun: %llx\n", (unsigned long long) ipl_info.data.fcp.lun);\r\nrc = sclp_sdias_init();\r\nif (rc)\r\ngoto fail;\r\nrc = check_sdias();\r\nif (rc)\r\ngoto fail;\r\nhsa_available = 1;\r\nrc = memcpy_hsa_kernel(&arch, __LC_AR_MODE_ID, 1);\r\nif (rc)\r\ngoto fail;\r\nif (arch == ARCH_S390) {\r\npr_alert("The 64-bit dump tool cannot be used for a "\r\n"32-bit system\n");\r\nrc = -EINVAL;\r\ngoto fail;\r\n}\r\nrc = get_mem_info(&mem_size, &mem_end);\r\nif (rc)\r\ngoto fail;\r\nrc = sys_info_init(arch, mem_end);\r\nif (rc)\r\ngoto fail;\r\nzcore_header_init(arch, &zcore_header, mem_size);\r\nrc = zcore_reipl_init();\r\nif (rc)\r\ngoto fail;\r\nzcore_dir = debugfs_create_dir("zcore" , NULL);\r\nif (!zcore_dir) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nzcore_file = debugfs_create_file("mem", S_IRUSR, zcore_dir, NULL,\r\n&zcore_fops);\r\nif (!zcore_file) {\r\nrc = -ENOMEM;\r\ngoto fail_dir;\r\n}\r\nzcore_memmap_file = debugfs_create_file("memmap", S_IRUSR, zcore_dir,\r\nNULL, &zcore_memmap_fops);\r\nif (!zcore_memmap_file) {\r\nrc = -ENOMEM;\r\ngoto fail_file;\r\n}\r\nzcore_reipl_file = debugfs_create_file("reipl", S_IRUSR, zcore_dir,\r\nNULL, &zcore_reipl_fops);\r\nif (!zcore_reipl_file) {\r\nrc = -ENOMEM;\r\ngoto fail_memmap_file;\r\n}\r\nzcore_hsa_file = debugfs_create_file("hsa", S_IRUSR|S_IWUSR, zcore_dir,\r\nNULL, &zcore_hsa_fops);\r\nif (!zcore_hsa_file) {\r\nrc = -ENOMEM;\r\ngoto fail_reipl_file;\r\n}\r\nreturn 0;\r\nfail_reipl_file:\r\ndebugfs_remove(zcore_reipl_file);\r\nfail_memmap_file:\r\ndebugfs_remove(zcore_memmap_file);\r\nfail_file:\r\ndebugfs_remove(zcore_file);\r\nfail_dir:\r\ndebugfs_remove(zcore_dir);\r\nfail:\r\ndiag308(DIAG308_REL_HSA, NULL);\r\nreturn rc;\r\n}\r\nstatic void __exit zcore_exit(void)\r\n{\r\ndebug_unregister(zcore_dbf);\r\nsclp_sdias_exit();\r\nfree_page((unsigned long) ipl_block);\r\ndebugfs_remove(zcore_hsa_file);\r\ndebugfs_remove(zcore_reipl_file);\r\ndebugfs_remove(zcore_memmap_file);\r\ndebugfs_remove(zcore_file);\r\ndebugfs_remove(zcore_dir);\r\ndiag308(DIAG308_REL_HSA, NULL);\r\n}
