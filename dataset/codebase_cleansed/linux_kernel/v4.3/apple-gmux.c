static u8 gmux_pio_read8(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nreturn inb(gmux_data->iostart + port);\r\n}\r\nstatic void gmux_pio_write8(struct apple_gmux_data *gmux_data, int port,\r\nu8 val)\r\n{\r\noutb(val, gmux_data->iostart + port);\r\n}\r\nstatic u32 gmux_pio_read32(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nreturn inl(gmux_data->iostart + port);\r\n}\r\nstatic void gmux_pio_write32(struct apple_gmux_data *gmux_data, int port,\r\nu32 val)\r\n{\r\nint i;\r\nu8 tmpval;\r\nfor (i = 0; i < 4; i++) {\r\ntmpval = (val >> (i * 8)) & 0xff;\r\noutb(tmpval, gmux_data->iostart + port + i);\r\n}\r\n}\r\nstatic int gmux_index_wait_ready(struct apple_gmux_data *gmux_data)\r\n{\r\nint i = 200;\r\nu8 gwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\r\nwhile (i && (gwr & 0x01)) {\r\ninb(gmux_data->iostart + GMUX_PORT_READ);\r\ngwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\r\nudelay(100);\r\ni--;\r\n}\r\nreturn !!i;\r\n}\r\nstatic int gmux_index_wait_complete(struct apple_gmux_data *gmux_data)\r\n{\r\nint i = 200;\r\nu8 gwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\r\nwhile (i && !(gwr & 0x01)) {\r\ngwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\r\nudelay(100);\r\ni--;\r\n}\r\nif (gwr & 0x01)\r\ninb(gmux_data->iostart + GMUX_PORT_READ);\r\nreturn !!i;\r\n}\r\nstatic u8 gmux_index_read8(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nu8 val;\r\nmutex_lock(&gmux_data->index_lock);\r\ngmux_index_wait_ready(gmux_data);\r\noutb((port & 0xff), gmux_data->iostart + GMUX_PORT_READ);\r\ngmux_index_wait_complete(gmux_data);\r\nval = inb(gmux_data->iostart + GMUX_PORT_VALUE);\r\nmutex_unlock(&gmux_data->index_lock);\r\nreturn val;\r\n}\r\nstatic void gmux_index_write8(struct apple_gmux_data *gmux_data, int port,\r\nu8 val)\r\n{\r\nmutex_lock(&gmux_data->index_lock);\r\noutb(val, gmux_data->iostart + GMUX_PORT_VALUE);\r\ngmux_index_wait_ready(gmux_data);\r\noutb(port & 0xff, gmux_data->iostart + GMUX_PORT_WRITE);\r\ngmux_index_wait_complete(gmux_data);\r\nmutex_unlock(&gmux_data->index_lock);\r\n}\r\nstatic u32 gmux_index_read32(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nu32 val;\r\nmutex_lock(&gmux_data->index_lock);\r\ngmux_index_wait_ready(gmux_data);\r\noutb((port & 0xff), gmux_data->iostart + GMUX_PORT_READ);\r\ngmux_index_wait_complete(gmux_data);\r\nval = inl(gmux_data->iostart + GMUX_PORT_VALUE);\r\nmutex_unlock(&gmux_data->index_lock);\r\nreturn val;\r\n}\r\nstatic void gmux_index_write32(struct apple_gmux_data *gmux_data, int port,\r\nu32 val)\r\n{\r\nint i;\r\nu8 tmpval;\r\nmutex_lock(&gmux_data->index_lock);\r\nfor (i = 0; i < 4; i++) {\r\ntmpval = (val >> (i * 8)) & 0xff;\r\noutb(tmpval, gmux_data->iostart + GMUX_PORT_VALUE + i);\r\n}\r\ngmux_index_wait_ready(gmux_data);\r\noutb(port & 0xff, gmux_data->iostart + GMUX_PORT_WRITE);\r\ngmux_index_wait_complete(gmux_data);\r\nmutex_unlock(&gmux_data->index_lock);\r\n}\r\nstatic u8 gmux_read8(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nif (gmux_data->indexed)\r\nreturn gmux_index_read8(gmux_data, port);\r\nelse\r\nreturn gmux_pio_read8(gmux_data, port);\r\n}\r\nstatic void gmux_write8(struct apple_gmux_data *gmux_data, int port, u8 val)\r\n{\r\nif (gmux_data->indexed)\r\ngmux_index_write8(gmux_data, port, val);\r\nelse\r\ngmux_pio_write8(gmux_data, port, val);\r\n}\r\nstatic u32 gmux_read32(struct apple_gmux_data *gmux_data, int port)\r\n{\r\nif (gmux_data->indexed)\r\nreturn gmux_index_read32(gmux_data, port);\r\nelse\r\nreturn gmux_pio_read32(gmux_data, port);\r\n}\r\nstatic void gmux_write32(struct apple_gmux_data *gmux_data, int port,\r\nu32 val)\r\n{\r\nif (gmux_data->indexed)\r\ngmux_index_write32(gmux_data, port, val);\r\nelse\r\ngmux_pio_write32(gmux_data, port, val);\r\n}\r\nstatic bool gmux_is_indexed(struct apple_gmux_data *gmux_data)\r\n{\r\nu16 val;\r\noutb(0xaa, gmux_data->iostart + 0xcc);\r\noutb(0x55, gmux_data->iostart + 0xcd);\r\noutb(0x00, gmux_data->iostart + 0xce);\r\nval = inb(gmux_data->iostart + 0xcc) |\r\n(inb(gmux_data->iostart + 0xcd) << 8);\r\nif (val == 0x55aa)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int gmux_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct apple_gmux_data *gmux_data = bl_get_data(bd);\r\nreturn gmux_read32(gmux_data, GMUX_PORT_BRIGHTNESS) &\r\nGMUX_BRIGHTNESS_MASK;\r\n}\r\nstatic int gmux_update_status(struct backlight_device *bd)\r\n{\r\nstruct apple_gmux_data *gmux_data = bl_get_data(bd);\r\nu32 brightness = bd->props.brightness;\r\nif (bd->props.state & BL_CORE_SUSPENDED)\r\nreturn 0;\r\ngmux_write32(gmux_data, GMUX_PORT_BRIGHTNESS, brightness);\r\nreturn 0;\r\n}\r\nstatic int gmux_switchto(enum vga_switcheroo_client_id id)\r\n{\r\nif (id == VGA_SWITCHEROO_IGD) {\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DDC, 1);\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DISPLAY, 2);\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 2);\r\n} else {\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DDC, 2);\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DISPLAY, 3);\r\ngmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 3);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmux_set_discrete_state(struct apple_gmux_data *gmux_data,\r\nenum vga_switcheroo_state state)\r\n{\r\nreinit_completion(&gmux_data->powerchange_done);\r\nif (state == VGA_SWITCHEROO_ON) {\r\ngmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 1);\r\ngmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 3);\r\npr_debug("Discrete card powered up\n");\r\n} else {\r\ngmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 1);\r\ngmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 0);\r\npr_debug("Discrete card powered down\n");\r\n}\r\ngmux_data->power_state = state;\r\nif (gmux_data->gpe >= 0 &&\r\n!wait_for_completion_interruptible_timeout(&gmux_data->powerchange_done,\r\nmsecs_to_jiffies(200)))\r\npr_warn("Timeout waiting for gmux switch to complete\n");\r\nreturn 0;\r\n}\r\nstatic int gmux_set_power_state(enum vga_switcheroo_client_id id,\r\nenum vga_switcheroo_state state)\r\n{\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn 0;\r\nreturn gmux_set_discrete_state(apple_gmux_data, state);\r\n}\r\nstatic int gmux_get_client_id(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL)\r\nreturn VGA_SWITCHEROO_IGD;\r\nelse if (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&\r\npdev->device == 0x0863)\r\nreturn VGA_SWITCHEROO_IGD;\r\nelse\r\nreturn VGA_SWITCHEROO_DIS;\r\n}\r\nstatic enum vga_switcheroo_client_id\r\ngmux_active_client(struct apple_gmux_data *gmux_data)\r\n{\r\nif (gmux_read8(gmux_data, GMUX_PORT_SWITCH_DISPLAY) == 2)\r\nreturn VGA_SWITCHEROO_IGD;\r\nreturn VGA_SWITCHEROO_DIS;\r\n}\r\nstatic inline void gmux_disable_interrupts(struct apple_gmux_data *gmux_data)\r\n{\r\ngmux_write8(gmux_data, GMUX_PORT_INTERRUPT_ENABLE,\r\nGMUX_INTERRUPT_DISABLE);\r\n}\r\nstatic inline void gmux_enable_interrupts(struct apple_gmux_data *gmux_data)\r\n{\r\ngmux_write8(gmux_data, GMUX_PORT_INTERRUPT_ENABLE,\r\nGMUX_INTERRUPT_ENABLE);\r\n}\r\nstatic inline u8 gmux_interrupt_get_status(struct apple_gmux_data *gmux_data)\r\n{\r\nreturn gmux_read8(gmux_data, GMUX_PORT_INTERRUPT_STATUS);\r\n}\r\nstatic void gmux_clear_interrupts(struct apple_gmux_data *gmux_data)\r\n{\r\nu8 status;\r\nstatus = gmux_interrupt_get_status(gmux_data);\r\ngmux_write8(gmux_data, GMUX_PORT_INTERRUPT_STATUS, status);\r\n}\r\nstatic void gmux_notify_handler(acpi_handle device, u32 value, void *context)\r\n{\r\nu8 status;\r\nstruct pnp_dev *pnp = (struct pnp_dev *)context;\r\nstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\r\nstatus = gmux_interrupt_get_status(gmux_data);\r\ngmux_disable_interrupts(gmux_data);\r\npr_debug("Notify handler called: status %d\n", status);\r\ngmux_clear_interrupts(gmux_data);\r\ngmux_enable_interrupts(gmux_data);\r\nif (status & GMUX_INTERRUPT_STATUS_POWER)\r\ncomplete(&gmux_data->powerchange_done);\r\n}\r\nstatic int gmux_suspend(struct device *dev)\r\n{\r\nstruct pnp_dev *pnp = to_pnp_dev(dev);\r\nstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\r\ngmux_data->resume_client_id = gmux_active_client(gmux_data);\r\ngmux_disable_interrupts(gmux_data);\r\nreturn 0;\r\n}\r\nstatic int gmux_resume(struct device *dev)\r\n{\r\nstruct pnp_dev *pnp = to_pnp_dev(dev);\r\nstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\r\ngmux_enable_interrupts(gmux_data);\r\ngmux_switchto(gmux_data->resume_client_id);\r\nif (gmux_data->power_state == VGA_SWITCHEROO_OFF)\r\ngmux_set_discrete_state(gmux_data, gmux_data->power_state);\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *gmux_get_io_pdev(void)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev))) {\r\nu16 cmd;\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif (!(cmd & PCI_COMMAND_IO))\r\ncontinue;\r\nreturn pdev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)\r\n{\r\nstruct apple_gmux_data *gmux_data;\r\nstruct resource *res;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bdev;\r\nu8 ver_major, ver_minor, ver_release;\r\nint ret = -ENXIO;\r\nacpi_status status;\r\nunsigned long long gpe;\r\nstruct pci_dev *pdev = NULL;\r\nif (apple_gmux_data)\r\nreturn -EBUSY;\r\ngmux_data = kzalloc(sizeof(*gmux_data), GFP_KERNEL);\r\nif (!gmux_data)\r\nreturn -ENOMEM;\r\npnp_set_drvdata(pnp, gmux_data);\r\nres = pnp_get_resource(pnp, IORESOURCE_IO, 0);\r\nif (!res) {\r\npr_err("Failed to find gmux I/O resource\n");\r\ngoto err_free;\r\n}\r\ngmux_data->iostart = res->start;\r\ngmux_data->iolen = res->end - res->start;\r\nif (gmux_data->iolen < GMUX_MIN_IO_LEN) {\r\npr_err("gmux I/O region too small (%lu < %u)\n",\r\ngmux_data->iolen, GMUX_MIN_IO_LEN);\r\ngoto err_free;\r\n}\r\nif (!request_region(gmux_data->iostart, gmux_data->iolen,\r\n"Apple gmux")) {\r\npr_err("gmux I/O already in use\n");\r\ngoto err_free;\r\n}\r\nver_major = gmux_read8(gmux_data, GMUX_PORT_VERSION_MAJOR);\r\nver_minor = gmux_read8(gmux_data, GMUX_PORT_VERSION_MINOR);\r\nver_release = gmux_read8(gmux_data, GMUX_PORT_VERSION_RELEASE);\r\nif (ver_major == 0xff && ver_minor == 0xff && ver_release == 0xff) {\r\nif (gmux_is_indexed(gmux_data)) {\r\nu32 version;\r\nmutex_init(&gmux_data->index_lock);\r\ngmux_data->indexed = true;\r\nversion = gmux_read32(gmux_data,\r\nGMUX_PORT_VERSION_MAJOR);\r\nver_major = (version >> 24) & 0xff;\r\nver_minor = (version >> 16) & 0xff;\r\nver_release = (version >> 8) & 0xff;\r\n} else {\r\npr_info("gmux device not present or IO disabled\n");\r\nret = -ENODEV;\r\ngoto err_release;\r\n}\r\n}\r\npr_info("Found gmux version %d.%d.%d [%s]\n", ver_major, ver_minor,\r\nver_release, (gmux_data->indexed ? "indexed" : "classic"));\r\npdev = gmux_get_io_pdev();\r\nif (pdev && vga_tryget(pdev,\r\nVGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM)) {\r\npr_err("IO+MEM vgaarb-locking for PCI:%s failed\n",\r\npci_name(pdev));\r\nret = -EBUSY;\r\ngoto err_release;\r\n} else if (pdev)\r\npr_info("locked IO for PCI:%s\n", pci_name(pdev));\r\ngmux_data->pdev = pdev;\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = gmux_read32(gmux_data, GMUX_PORT_MAX_BRIGHTNESS);\r\nif (WARN_ON(props.max_brightness > GMUX_MAX_BRIGHTNESS))\r\nprops.max_brightness = GMUX_MAX_BRIGHTNESS;\r\nbdev = backlight_device_register("gmux_backlight", &pnp->dev,\r\ngmux_data, &gmux_bl_ops, &props);\r\nif (IS_ERR(bdev)) {\r\nret = PTR_ERR(bdev);\r\ngoto err_release;\r\n}\r\ngmux_data->bdev = bdev;\r\nbdev->props.brightness = gmux_get_brightness(bdev);\r\nbacklight_update_status(bdev);\r\nacpi_video_set_dmi_backlight_type(acpi_backlight_vendor);\r\napple_bl_unregister();\r\ngmux_data->power_state = VGA_SWITCHEROO_ON;\r\ngmux_data->dhandle = ACPI_HANDLE(&pnp->dev);\r\nif (!gmux_data->dhandle) {\r\npr_err("Cannot find acpi handle for pnp device %s\n",\r\ndev_name(&pnp->dev));\r\nret = -ENODEV;\r\ngoto err_notify;\r\n}\r\nstatus = acpi_evaluate_integer(gmux_data->dhandle, "GMGP", NULL, &gpe);\r\nif (ACPI_SUCCESS(status)) {\r\ngmux_data->gpe = (int)gpe;\r\nstatus = acpi_install_notify_handler(gmux_data->dhandle,\r\nACPI_DEVICE_NOTIFY,\r\n&gmux_notify_handler, pnp);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Install notify handler failed: %s\n",\r\nacpi_format_exception(status));\r\nret = -ENODEV;\r\ngoto err_notify;\r\n}\r\nstatus = acpi_enable_gpe(NULL, gmux_data->gpe);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Cannot enable gpe: %s\n",\r\nacpi_format_exception(status));\r\ngoto err_enable_gpe;\r\n}\r\n} else {\r\npr_warn("No GPE found for gmux\n");\r\ngmux_data->gpe = -1;\r\n}\r\nif (vga_switcheroo_register_handler(&gmux_handler)) {\r\nret = -ENODEV;\r\ngoto err_register_handler;\r\n}\r\ninit_completion(&gmux_data->powerchange_done);\r\napple_gmux_data = gmux_data;\r\ngmux_enable_interrupts(gmux_data);\r\nreturn 0;\r\nerr_register_handler:\r\nif (gmux_data->gpe >= 0)\r\nacpi_disable_gpe(NULL, gmux_data->gpe);\r\nerr_enable_gpe:\r\nif (gmux_data->gpe >= 0)\r\nacpi_remove_notify_handler(gmux_data->dhandle,\r\nACPI_DEVICE_NOTIFY,\r\n&gmux_notify_handler);\r\nerr_notify:\r\nbacklight_device_unregister(bdev);\r\nerr_release:\r\nif (gmux_data->pdev)\r\nvga_put(gmux_data->pdev,\r\nVGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM);\r\npci_dev_put(pdev);\r\nrelease_region(gmux_data->iostart, gmux_data->iolen);\r\nerr_free:\r\nkfree(gmux_data);\r\nreturn ret;\r\n}\r\nstatic void gmux_remove(struct pnp_dev *pnp)\r\n{\r\nstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\r\nvga_switcheroo_unregister_handler();\r\ngmux_disable_interrupts(gmux_data);\r\nif (gmux_data->gpe >= 0) {\r\nacpi_disable_gpe(NULL, gmux_data->gpe);\r\nacpi_remove_notify_handler(gmux_data->dhandle,\r\nACPI_DEVICE_NOTIFY,\r\n&gmux_notify_handler);\r\n}\r\nif (gmux_data->pdev) {\r\nvga_put(gmux_data->pdev,\r\nVGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM);\r\npci_dev_put(gmux_data->pdev);\r\n}\r\nbacklight_device_unregister(gmux_data->bdev);\r\nrelease_region(gmux_data->iostart, gmux_data->iolen);\r\napple_gmux_data = NULL;\r\nkfree(gmux_data);\r\nacpi_video_register();\r\napple_bl_register();\r\n}
