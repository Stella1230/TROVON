static void\r\nsnic_wq_cmpl_frame_send(struct vnic_wq *wq,\r\nstruct cq_desc *cq_desc,\r\nstruct vnic_wq_buf *buf,\r\nvoid *opaque)\r\n{\r\nstruct snic *snic = svnic_dev_priv(wq->vdev);\r\nSNIC_BUG_ON(buf->os_buf == NULL);\r\nif (snic_log_level & SNIC_DESC_LOGGING)\r\nSNIC_HOST_INFO(snic->shost,\r\n"Ack received for snic_host_req %p.\n",\r\nbuf->os_buf);\r\nSNIC_TRC(snic->shost->host_no, 0, 0,\r\n((ulong)(buf->os_buf) - sizeof(struct snic_req_info)), 0, 0,\r\n0);\r\npci_unmap_single(snic->pdev, buf->dma_addr, buf->len, PCI_DMA_TODEVICE);\r\nbuf->os_buf = NULL;\r\n}\r\nstatic int\r\nsnic_wq_cmpl_handler_cont(struct vnic_dev *vdev,\r\nstruct cq_desc *cq_desc,\r\nu8 type,\r\nu16 q_num,\r\nu16 cmpl_idx,\r\nvoid *opaque)\r\n{\r\nstruct snic *snic = svnic_dev_priv(vdev);\r\nunsigned long flags;\r\nSNIC_BUG_ON(q_num != 0);\r\nspin_lock_irqsave(&snic->wq_lock[q_num], flags);\r\nsvnic_wq_service(&snic->wq[q_num],\r\ncq_desc,\r\ncmpl_idx,\r\nsnic_wq_cmpl_frame_send,\r\nNULL);\r\nspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\r\nreturn 0;\r\n}\r\nint\r\nsnic_wq_cmpl_handler(struct snic *snic, int work_to_do)\r\n{\r\nunsigned int work_done = 0;\r\nunsigned int i;\r\nsnic->s_stats.misc.last_ack_time = jiffies;\r\nfor (i = 0; i < snic->wq_count; i++) {\r\nwork_done += svnic_cq_service(&snic->cq[i],\r\nwork_to_do,\r\nsnic_wq_cmpl_handler_cont,\r\nNULL);\r\n}\r\nreturn work_done;\r\n}\r\nvoid\r\nsnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf)\r\n{\r\nstruct snic_host_req *req = buf->os_buf;\r\nstruct snic *snic = svnic_dev_priv(wq->vdev);\r\nstruct snic_req_info *rqi = NULL;\r\nunsigned long flags;\r\npci_unmap_single(snic->pdev, buf->dma_addr, buf->len, PCI_DMA_TODEVICE);\r\nrqi = req_to_rqi(req);\r\nspin_lock_irqsave(&snic->spl_cmd_lock, flags);\r\nif (list_empty(&rqi->list)) {\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\ngoto end;\r\n}\r\nSNIC_BUG_ON(rqi->list.next == NULL);\r\nlist_del_init(&rqi->list);\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\nif (rqi->sge_va) {\r\nsnic_pci_unmap_rsp_buf(snic, rqi);\r\nkfree((void *)rqi->sge_va);\r\nrqi->sge_va = 0;\r\n}\r\nsnic_req_free(snic, rqi);\r\nSNIC_HOST_INFO(snic->shost, "snic_free_wq_buf .. freed.\n");\r\nend:\r\nreturn;\r\n}\r\nstatic int\r\nsnic_select_wq(struct snic *snic)\r\n{\r\nBUILD_BUG_ON(SNIC_WQ_MAX > 1);\r\nreturn 0;\r\n}\r\nint\r\nsnic_queue_wq_desc(struct snic *snic, void *os_buf, u16 len)\r\n{\r\ndma_addr_t pa = 0;\r\nunsigned long flags;\r\nstruct snic_fw_stats *fwstats = &snic->s_stats.fw;\r\nlong act_reqs;\r\nint q_num = 0;\r\nsnic_print_desc(__func__, os_buf, len);\r\npa = pci_map_single(snic->pdev, os_buf, len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(snic->pdev, pa)) {\r\nSNIC_HOST_ERR(snic->shost, "qdesc: PCI DMA Mapping Fail.\n");\r\nreturn -ENOMEM;\r\n}\r\nq_num = snic_select_wq(snic);\r\nspin_lock_irqsave(&snic->wq_lock[q_num], flags);\r\nif (!svnic_wq_desc_avail(snic->wq)) {\r\npci_unmap_single(snic->pdev, pa, len, PCI_DMA_TODEVICE);\r\nspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\r\natomic64_inc(&snic->s_stats.misc.wq_alloc_fail);\r\nSNIC_DBG("host = %d, WQ is Full\n", snic->shost->host_no);\r\nreturn -ENOMEM;\r\n}\r\nsnic_queue_wq_eth_desc(&snic->wq[q_num], os_buf, pa, len, 0, 0, 1);\r\nspin_unlock_irqrestore(&snic->wq_lock[q_num], flags);\r\nact_reqs = atomic64_inc_return(&fwstats->actv_reqs);\r\nif (act_reqs > atomic64_read(&fwstats->max_actv_reqs))\r\natomic64_set(&fwstats->max_actv_reqs, act_reqs);\r\nreturn 0;\r\n}\r\nvoid\r\nsnic_handle_untagged_req(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&rqi->list);\r\nspin_lock_irqsave(&snic->spl_cmd_lock, flags);\r\nlist_add_tail(&rqi->list, &snic->spl_cmd_list);\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\n}\r\nstruct snic_req_info *\r\nsnic_req_init(struct snic *snic, int sg_cnt)\r\n{\r\nu8 typ;\r\nstruct snic_req_info *rqi = NULL;\r\ntyp = (sg_cnt <= SNIC_REQ_CACHE_DFLT_SGL) ?\r\nSNIC_REQ_CACHE_DFLT_SGL : SNIC_REQ_CACHE_MAX_SGL;\r\nrqi = mempool_alloc(snic->req_pool[typ], GFP_ATOMIC);\r\nif (!rqi) {\r\natomic64_inc(&snic->s_stats.io.alloc_fail);\r\nSNIC_HOST_ERR(snic->shost,\r\n"Failed to allocate memory from snic req pool id = %d\n",\r\ntyp);\r\nreturn rqi;\r\n}\r\nmemset(rqi, 0, sizeof(*rqi));\r\nrqi->rq_pool_type = typ;\r\nrqi->start_time = jiffies;\r\nrqi->req = (struct snic_host_req *) (rqi + 1);\r\nrqi->req_len = sizeof(struct snic_host_req);\r\nrqi->snic = snic;\r\nrqi->req = (struct snic_host_req *)(rqi + 1);\r\nif (sg_cnt == 0)\r\ngoto end;\r\nrqi->req_len += (sg_cnt * sizeof(struct snic_sg_desc));\r\nif (sg_cnt > atomic64_read(&snic->s_stats.io.max_sgl))\r\natomic64_set(&snic->s_stats.io.max_sgl, sg_cnt);\r\nSNIC_BUG_ON(sg_cnt > SNIC_MAX_SG_DESC_CNT);\r\natomic64_inc(&snic->s_stats.io.sgl_cnt[sg_cnt - 1]);\r\nend:\r\nmemset(rqi->req, 0, rqi->req_len);\r\nrqi->req->hdr.init_ctx = (ulong) rqi;\r\nSNIC_SCSI_DBG(snic->shost, "Req_alloc:rqi = %p allocatd.\n", rqi);\r\nreturn rqi;\r\n}\r\nstruct snic_host_req *\r\nsnic_abort_req_init(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nstruct snic_host_req *req = NULL;\r\nSNIC_BUG_ON(!rqi);\r\nif (rqi->abort_req)\r\nreturn rqi->abort_req;\r\nreq = mempool_alloc(snic->req_pool[SNIC_REQ_TM_CACHE], GFP_ATOMIC);\r\nif (!req) {\r\nSNIC_HOST_ERR(snic->shost, "abts:Failed to alloc tm req.\n");\r\nWARN_ON_ONCE(1);\r\nreturn NULL;\r\n}\r\nrqi->abort_req = req;\r\nmemset(req, 0, sizeof(struct snic_host_req));\r\nreq->hdr.init_ctx = (ulong) rqi;\r\nreturn req;\r\n}\r\nstruct snic_host_req *\r\nsnic_dr_req_init(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nstruct snic_host_req *req = NULL;\r\nSNIC_BUG_ON(!rqi);\r\nreq = mempool_alloc(snic->req_pool[SNIC_REQ_TM_CACHE], GFP_ATOMIC);\r\nif (!req) {\r\nSNIC_HOST_ERR(snic->shost, "dr:Failed to alloc tm req.\n");\r\nWARN_ON_ONCE(1);\r\nreturn NULL;\r\n}\r\nSNIC_BUG_ON(rqi->dr_req != NULL);\r\nrqi->dr_req = req;\r\nmemset(req, 0, sizeof(struct snic_host_req));\r\nreq->hdr.init_ctx = (ulong) rqi;\r\nreturn req;\r\n}\r\nvoid\r\nsnic_req_free(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nSNIC_BUG_ON(rqi->req == rqi->abort_req);\r\nSNIC_BUG_ON(rqi->req == rqi->dr_req);\r\nSNIC_BUG_ON(rqi->sge_va != 0);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Req_free:rqi %p:ioreq %p:abt %p:dr %p\n",\r\nrqi, rqi->req, rqi->abort_req, rqi->dr_req);\r\nif (rqi->abort_req)\r\nmempool_free(rqi->abort_req, snic->req_pool[SNIC_REQ_TM_CACHE]);\r\nif (rqi->dr_req)\r\nmempool_free(rqi->dr_req, snic->req_pool[SNIC_REQ_TM_CACHE]);\r\nmempool_free(rqi, snic->req_pool[rqi->rq_pool_type]);\r\n}\r\nvoid\r\nsnic_pci_unmap_rsp_buf(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nstruct snic_sg_desc *sgd;\r\nsgd = req_to_sgl(rqi_to_req(rqi));\r\nSNIC_BUG_ON(sgd[0].addr == 0);\r\npci_unmap_single(snic->pdev,\r\nle64_to_cpu(sgd[0].addr),\r\nle32_to_cpu(sgd[0].len),\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nvoid\r\nsnic_free_all_untagged_reqs(struct snic *snic)\r\n{\r\nstruct snic_req_info *rqi;\r\nstruct list_head *cur, *nxt;\r\nunsigned long flags;\r\nspin_lock_irqsave(&snic->spl_cmd_lock, flags);\r\nlist_for_each_safe(cur, nxt, &snic->spl_cmd_list) {\r\nrqi = list_entry(cur, struct snic_req_info, list);\r\nlist_del_init(&rqi->list);\r\nif (rqi->sge_va) {\r\nsnic_pci_unmap_rsp_buf(snic, rqi);\r\nkfree((void *)rqi->sge_va);\r\nrqi->sge_va = 0;\r\n}\r\nsnic_req_free(snic, rqi);\r\n}\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\n}\r\nvoid\r\nsnic_release_untagged_req(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nif (snic->in_remove) {\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\ngoto end;\r\n}\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nspin_lock_irqsave(&snic->spl_cmd_lock, flags);\r\nif (list_empty(&rqi->list)) {\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\ngoto end;\r\n}\r\nlist_del_init(&rqi->list);\r\nspin_unlock_irqrestore(&snic->spl_cmd_lock, flags);\r\nsnic_req_free(snic, rqi);\r\nend:\r\nreturn;\r\n}\r\nvoid\r\nsnic_hex_dump(char *pfx, char *data, int len)\r\n{\r\nSNIC_INFO("%s Dumping Data of Len = %d\n", pfx, len);\r\nprint_hex_dump_bytes(pfx, DUMP_PREFIX_NONE, data, len);\r\n}\r\nstatic void\r\nsnic_dump_desc(const char *fn, char *os_buf, int len)\r\n{\r\nstruct snic_host_req *req = (struct snic_host_req *) os_buf;\r\nstruct snic_fw_req *fwreq = (struct snic_fw_req *) os_buf;\r\nstruct snic_req_info *rqi = NULL;\r\nchar line[LINE_BUFSZ] = { '\0' };\r\nchar *cmd_str = NULL;\r\nif (req->hdr.type >= SNIC_RSP_REPORT_TGTS_CMPL)\r\nrqi = (struct snic_req_info *) fwreq->hdr.init_ctx;\r\nelse\r\nrqi = (struct snic_req_info *) req->hdr.init_ctx;\r\nSNIC_BUG_ON(rqi == NULL || rqi->req == NULL);\r\nswitch (req->hdr.type) {\r\ncase SNIC_REQ_REPORT_TGTS:\r\ncmd_str = "report-tgt : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_REQ_REPORT_TGTS :");\r\nbreak;\r\ncase SNIC_REQ_ICMND:\r\ncmd_str = "icmnd : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_REQ_ICMND : 0x%x :",\r\nreq->u.icmnd.cdb[0]);\r\nbreak;\r\ncase SNIC_REQ_ITMF:\r\ncmd_str = "itmf : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_REQ_ITMF :");\r\nbreak;\r\ncase SNIC_REQ_HBA_RESET:\r\ncmd_str = "hba reset :";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_REQ_HBA_RESET :");\r\nbreak;\r\ncase SNIC_REQ_EXCH_VER:\r\ncmd_str = "exch ver : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_REQ_EXCH_VER :");\r\nbreak;\r\ncase SNIC_REQ_TGT_INFO:\r\ncmd_str = "tgt info : ";\r\nbreak;\r\ncase SNIC_RSP_REPORT_TGTS_CMPL:\r\ncmd_str = "report tgt cmpl : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_RSP_REPORT_TGTS_CMPL :");\r\nbreak;\r\ncase SNIC_RSP_ICMND_CMPL:\r\ncmd_str = "icmnd_cmpl : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_RSP_ICMND_CMPL : 0x%x :",\r\nrqi->req->u.icmnd.cdb[0]);\r\nbreak;\r\ncase SNIC_RSP_ITMF_CMPL:\r\ncmd_str = "itmf_cmpl : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_RSP_ITMF_CMPL :");\r\nbreak;\r\ncase SNIC_RSP_HBA_RESET_CMPL:\r\ncmd_str = "hba_reset_cmpl : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_RSP_HBA_RESET_CMPL :");\r\nbreak;\r\ncase SNIC_RSP_EXCH_VER_CMPL:\r\ncmd_str = "exch_ver_cmpl : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_RSP_EXCH_VER_CMPL :");\r\nbreak;\r\ncase SNIC_MSG_ACK:\r\ncmd_str = "msg ack : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_MSG_ACK :");\r\nbreak;\r\ncase SNIC_MSG_ASYNC_EVNOTIFY:\r\ncmd_str = "async notify : ";\r\nsnprintf(line, LINE_BUFSZ, "SNIC_MSG_ASYNC_EVNOTIFY :");\r\nbreak;\r\ndefault:\r\ncmd_str = "unknown : ";\r\nSNIC_BUG_ON(1);\r\nbreak;\r\n}\r\nSNIC_INFO("%s:%s >>cmndid=%x:sg_cnt = %x:status = %x:ctx = %lx.\n",\r\nfn, line, req->hdr.cmnd_id, req->hdr.sg_cnt, req->hdr.status,\r\nreq->hdr.init_ctx);\r\nif (snic_log_level & 0x20)\r\nsnic_hex_dump(cmd_str, os_buf, len);\r\n}\r\nvoid\r\nsnic_print_desc(const char *fn, char *os_buf, int len)\r\n{\r\nif (snic_log_level & SNIC_DESC_LOGGING)\r\nsnic_dump_desc(fn, os_buf, len);\r\n}\r\nvoid\r\nsnic_calc_io_process_time(struct snic *snic, struct snic_req_info *rqi)\r\n{\r\nu64 duration;\r\nduration = jiffies - rqi->start_time;\r\nif (duration > atomic64_read(&snic->s_stats.io.max_time))\r\natomic64_set(&snic->s_stats.io.max_time, duration);\r\n}
