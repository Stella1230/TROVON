static inline void i2c_writel(struct rk3x_i2c *i2c, u32 value,\r\nunsigned int offset)\r\n{\r\nwritel(value, i2c->regs + offset);\r\n}\r\nstatic inline u32 i2c_readl(struct rk3x_i2c *i2c, unsigned int offset)\r\n{\r\nreturn readl(i2c->regs + offset);\r\n}\r\nstatic inline void rk3x_i2c_clean_ipd(struct rk3x_i2c *i2c)\r\n{\r\ni2c_writel(i2c, REG_INT_ALL, REG_IPD);\r\n}\r\nstatic void rk3x_i2c_start(struct rk3x_i2c *i2c)\r\n{\r\nu32 val;\r\nrk3x_i2c_clean_ipd(i2c);\r\ni2c_writel(i2c, REG_INT_START, REG_IEN);\r\nval = REG_CON_EN | REG_CON_MOD(i2c->mode) | REG_CON_START;\r\nif (!(i2c->msg->flags & I2C_M_IGNORE_NAK))\r\nval |= REG_CON_ACTACK;\r\ni2c_writel(i2c, val, REG_CON);\r\n}\r\nstatic void rk3x_i2c_stop(struct rk3x_i2c *i2c, int error)\r\n{\r\nunsigned int ctrl;\r\ni2c->processed = 0;\r\ni2c->msg = NULL;\r\ni2c->error = error;\r\nif (i2c->is_last_msg) {\r\ni2c_writel(i2c, REG_INT_STOP, REG_IEN);\r\ni2c->state = STATE_STOP;\r\nctrl = i2c_readl(i2c, REG_CON);\r\nctrl |= REG_CON_STOP;\r\ni2c_writel(i2c, ctrl, REG_CON);\r\n} else {\r\ni2c->busy = false;\r\ni2c->state = STATE_IDLE;\r\ni2c_writel(i2c, 0, REG_CON);\r\nwake_up(&i2c->wait);\r\n}\r\n}\r\nstatic void rk3x_i2c_prepare_read(struct rk3x_i2c *i2c)\r\n{\r\nunsigned int len = i2c->msg->len - i2c->processed;\r\nu32 con;\r\ncon = i2c_readl(i2c, REG_CON);\r\nif (len > 32) {\r\nlen = 32;\r\ncon &= ~REG_CON_LASTACK;\r\n} else {\r\ncon |= REG_CON_LASTACK;\r\n}\r\nif (i2c->processed != 0) {\r\ncon &= ~REG_CON_MOD_MASK;\r\ncon |= REG_CON_MOD(REG_CON_MOD_RX);\r\n}\r\ni2c_writel(i2c, con, REG_CON);\r\ni2c_writel(i2c, len, REG_MRXCNT);\r\n}\r\nstatic void rk3x_i2c_fill_transmit_buf(struct rk3x_i2c *i2c)\r\n{\r\nunsigned int i, j;\r\nu32 cnt = 0;\r\nu32 val;\r\nu8 byte;\r\nfor (i = 0; i < 8; ++i) {\r\nval = 0;\r\nfor (j = 0; j < 4; ++j) {\r\nif ((i2c->processed == i2c->msg->len) && (cnt != 0))\r\nbreak;\r\nif (i2c->processed == 0 && cnt == 0)\r\nbyte = (i2c->addr & 0x7f) << 1;\r\nelse\r\nbyte = i2c->msg->buf[i2c->processed++];\r\nval |= byte << (j * 8);\r\ncnt++;\r\n}\r\ni2c_writel(i2c, val, TXBUFFER_BASE + 4 * i);\r\nif (i2c->processed == i2c->msg->len)\r\nbreak;\r\n}\r\ni2c_writel(i2c, cnt, REG_MTXCNT);\r\n}\r\nstatic void rk3x_i2c_handle_start(struct rk3x_i2c *i2c, unsigned int ipd)\r\n{\r\nif (!(ipd & REG_INT_START)) {\r\nrk3x_i2c_stop(i2c, -EIO);\r\ndev_warn(i2c->dev, "unexpected irq in START: 0x%x\n", ipd);\r\nrk3x_i2c_clean_ipd(i2c);\r\nreturn;\r\n}\r\ni2c_writel(i2c, REG_INT_START, REG_IPD);\r\ni2c_writel(i2c, i2c_readl(i2c, REG_CON) & ~REG_CON_START, REG_CON);\r\nif (i2c->mode == REG_CON_MOD_TX) {\r\ni2c_writel(i2c, REG_INT_MBTF | REG_INT_NAKRCV, REG_IEN);\r\ni2c->state = STATE_WRITE;\r\nrk3x_i2c_fill_transmit_buf(i2c);\r\n} else {\r\ni2c_writel(i2c, REG_INT_MBRF | REG_INT_NAKRCV, REG_IEN);\r\ni2c->state = STATE_READ;\r\nrk3x_i2c_prepare_read(i2c);\r\n}\r\n}\r\nstatic void rk3x_i2c_handle_write(struct rk3x_i2c *i2c, unsigned int ipd)\r\n{\r\nif (!(ipd & REG_INT_MBTF)) {\r\nrk3x_i2c_stop(i2c, -EIO);\r\ndev_err(i2c->dev, "unexpected irq in WRITE: 0x%x\n", ipd);\r\nrk3x_i2c_clean_ipd(i2c);\r\nreturn;\r\n}\r\ni2c_writel(i2c, REG_INT_MBTF, REG_IPD);\r\nif (i2c->processed == i2c->msg->len)\r\nrk3x_i2c_stop(i2c, i2c->error);\r\nelse\r\nrk3x_i2c_fill_transmit_buf(i2c);\r\n}\r\nstatic void rk3x_i2c_handle_read(struct rk3x_i2c *i2c, unsigned int ipd)\r\n{\r\nunsigned int i;\r\nunsigned int len = i2c->msg->len - i2c->processed;\r\nu32 uninitialized_var(val);\r\nu8 byte;\r\nif (!(ipd & REG_INT_MBRF))\r\nreturn;\r\ni2c_writel(i2c, REG_INT_MBRF, REG_IPD);\r\nif (len > 32)\r\nlen = 32;\r\nfor (i = 0; i < len; ++i) {\r\nif (i % 4 == 0)\r\nval = i2c_readl(i2c, RXBUFFER_BASE + (i / 4) * 4);\r\nbyte = (val >> ((i % 4) * 8)) & 0xff;\r\ni2c->msg->buf[i2c->processed++] = byte;\r\n}\r\nif (i2c->processed == i2c->msg->len)\r\nrk3x_i2c_stop(i2c, i2c->error);\r\nelse\r\nrk3x_i2c_prepare_read(i2c);\r\n}\r\nstatic void rk3x_i2c_handle_stop(struct rk3x_i2c *i2c, unsigned int ipd)\r\n{\r\nunsigned int con;\r\nif (!(ipd & REG_INT_STOP)) {\r\nrk3x_i2c_stop(i2c, -EIO);\r\ndev_err(i2c->dev, "unexpected irq in STOP: 0x%x\n", ipd);\r\nrk3x_i2c_clean_ipd(i2c);\r\nreturn;\r\n}\r\ni2c_writel(i2c, REG_INT_STOP, REG_IPD);\r\ncon = i2c_readl(i2c, REG_CON);\r\ncon &= ~REG_CON_STOP;\r\ni2c_writel(i2c, con, REG_CON);\r\ni2c->busy = false;\r\ni2c->state = STATE_IDLE;\r\nwake_up(&i2c->wait);\r\n}\r\nstatic irqreturn_t rk3x_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct rk3x_i2c *i2c = dev_id;\r\nunsigned int ipd;\r\nspin_lock(&i2c->lock);\r\nipd = i2c_readl(i2c, REG_IPD);\r\nif (i2c->state == STATE_IDLE) {\r\ndev_warn(i2c->dev, "irq in STATE_IDLE, ipd = 0x%x\n", ipd);\r\nrk3x_i2c_clean_ipd(i2c);\r\ngoto out;\r\n}\r\ndev_dbg(i2c->dev, "IRQ: state %d, ipd: %x\n", i2c->state, ipd);\r\nipd &= ~(REG_INT_BRF | REG_INT_BTF);\r\nif (ipd & REG_INT_NAKRCV) {\r\ni2c_writel(i2c, REG_INT_NAKRCV, REG_IPD);\r\nipd &= ~REG_INT_NAKRCV;\r\nif (!(i2c->msg->flags & I2C_M_IGNORE_NAK))\r\nrk3x_i2c_stop(i2c, -ENXIO);\r\n}\r\nif ((ipd & REG_INT_ALL) == 0)\r\ngoto out;\r\nswitch (i2c->state) {\r\ncase STATE_START:\r\nrk3x_i2c_handle_start(i2c, ipd);\r\nbreak;\r\ncase STATE_WRITE:\r\nrk3x_i2c_handle_write(i2c, ipd);\r\nbreak;\r\ncase STATE_READ:\r\nrk3x_i2c_handle_read(i2c, ipd);\r\nbreak;\r\ncase STATE_STOP:\r\nrk3x_i2c_handle_stop(i2c, ipd);\r\nbreak;\r\ncase STATE_IDLE:\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&i2c->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rk3x_i2c_calc_divs(unsigned long clk_rate, unsigned long scl_rate,\r\nunsigned long scl_rise_ns,\r\nunsigned long scl_fall_ns,\r\nunsigned long sda_fall_ns,\r\nunsigned long *div_low, unsigned long *div_high)\r\n{\r\nunsigned long spec_min_low_ns, spec_min_high_ns;\r\nunsigned long spec_setup_start, spec_max_data_hold_ns;\r\nunsigned long data_hold_buffer_ns;\r\nunsigned long min_low_ns, min_high_ns;\r\nunsigned long max_low_ns, min_total_ns;\r\nunsigned long clk_rate_khz, scl_rate_khz;\r\nunsigned long min_low_div, min_high_div;\r\nunsigned long max_low_div;\r\nunsigned long min_div_for_hold, min_total_div;\r\nunsigned long extra_div, extra_low_div, ideal_low_div;\r\nint ret = 0;\r\nif (WARN_ON(scl_rate > 400000))\r\nscl_rate = 400000;\r\nif (WARN_ON(scl_rate < 1000))\r\nscl_rate = 1000;\r\nif (scl_rate <= 100000) {\r\nspec_min_low_ns = 4700;\r\nspec_setup_start = 4700;\r\nspec_min_high_ns = 4000;\r\nspec_max_data_hold_ns = 3450;\r\ndata_hold_buffer_ns = 50;\r\n} else {\r\nspec_min_low_ns = 1300;\r\nspec_setup_start = 600;\r\nspec_min_high_ns = 600;\r\nspec_max_data_hold_ns = 900;\r\ndata_hold_buffer_ns = 50;\r\n}\r\nmin_high_ns = scl_rise_ns + spec_min_high_ns;\r\nmin_high_ns = max(min_high_ns,\r\nDIV_ROUND_UP((scl_rise_ns + spec_setup_start) * 1000, 875));\r\nmin_high_ns = max(min_high_ns,\r\nDIV_ROUND_UP((scl_rise_ns + spec_setup_start +\r\nsda_fall_ns + spec_min_high_ns), 2));\r\nmin_low_ns = scl_fall_ns + spec_min_low_ns;\r\nmax_low_ns = spec_max_data_hold_ns * 2 - data_hold_buffer_ns;\r\nmin_total_ns = min_low_ns + min_high_ns;\r\nclk_rate_khz = DIV_ROUND_UP(clk_rate, 1000);\r\nscl_rate_khz = scl_rate / 1000;\r\nmin_total_div = DIV_ROUND_UP(clk_rate_khz, scl_rate_khz * 8);\r\nmin_low_div = DIV_ROUND_UP(clk_rate_khz * min_low_ns, 8 * 1000000);\r\nmin_high_div = DIV_ROUND_UP(clk_rate_khz * min_high_ns, 8 * 1000000);\r\nmin_div_for_hold = (min_low_div + min_high_div);\r\nmax_low_div = clk_rate_khz * max_low_ns / (8 * 1000000);\r\nif (min_low_div > max_low_div) {\r\nWARN_ONCE(true,\r\n"Conflicting, min_low_div %lu, max_low_div %lu\n",\r\nmin_low_div, max_low_div);\r\nmax_low_div = min_low_div;\r\n}\r\nif (min_div_for_hold > min_total_div) {\r\n*div_low = min_low_div;\r\n*div_high = min_high_div;\r\n} else {\r\nextra_div = min_total_div - min_div_for_hold;\r\nideal_low_div = DIV_ROUND_UP(clk_rate_khz * min_low_ns,\r\nscl_rate_khz * 8 * min_total_ns);\r\nif (ideal_low_div > max_low_div)\r\nideal_low_div = max_low_div;\r\nif (ideal_low_div > min_low_div + extra_div)\r\nideal_low_div = min_low_div + extra_div;\r\nextra_low_div = ideal_low_div - min_low_div;\r\n*div_low = ideal_low_div;\r\n*div_high = min_high_div + (extra_div - extra_low_div);\r\n}\r\n*div_low = *div_low - 1;\r\n*div_high = *div_high - 1;\r\nif (*div_low > 0xffff) {\r\n*div_low = 0xffff;\r\nret = -EINVAL;\r\n}\r\nif (*div_high > 0xffff) {\r\n*div_high = 0xffff;\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rk3x_i2c_adapt_div(struct rk3x_i2c *i2c, unsigned long clk_rate)\r\n{\r\nunsigned long div_low, div_high;\r\nu64 t_low_ns, t_high_ns;\r\nint ret;\r\nret = rk3x_i2c_calc_divs(clk_rate, i2c->scl_frequency, i2c->scl_rise_ns,\r\ni2c->scl_fall_ns, i2c->sda_fall_ns,\r\n&div_low, &div_high);\r\nWARN_ONCE(ret != 0, "Could not reach SCL freq %u", i2c->scl_frequency);\r\nclk_enable(i2c->clk);\r\ni2c_writel(i2c, (div_high << 16) | (div_low & 0xffff), REG_CLKDIV);\r\nclk_disable(i2c->clk);\r\nt_low_ns = div_u64(((u64)div_low + 1) * 8 * 1000000000, clk_rate);\r\nt_high_ns = div_u64(((u64)div_high + 1) * 8 * 1000000000, clk_rate);\r\ndev_dbg(i2c->dev,\r\n"CLK %lukhz, Req %uns, Act low %lluns high %lluns\n",\r\nclk_rate / 1000,\r\n1000000000 / i2c->scl_frequency,\r\nt_low_ns, t_high_ns);\r\n}\r\nstatic int rk3x_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long\r\nevent, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct rk3x_i2c *i2c = container_of(nb, struct rk3x_i2c, clk_rate_nb);\r\nunsigned long div_low, div_high;\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\nif (rk3x_i2c_calc_divs(ndata->new_rate, i2c->scl_frequency,\r\ni2c->scl_rise_ns, i2c->scl_fall_ns,\r\ni2c->sda_fall_ns,\r\n&div_low, &div_high) != 0)\r\nreturn NOTIFY_STOP;\r\nif (ndata->new_rate > ndata->old_rate)\r\nrk3x_i2c_adapt_div(i2c, ndata->new_rate);\r\nreturn NOTIFY_OK;\r\ncase POST_RATE_CHANGE:\r\nif (ndata->new_rate < ndata->old_rate)\r\nrk3x_i2c_adapt_div(i2c, ndata->new_rate);\r\nreturn NOTIFY_OK;\r\ncase ABORT_RATE_CHANGE:\r\nif (ndata->new_rate > ndata->old_rate)\r\nrk3x_i2c_adapt_div(i2c, ndata->old_rate);\r\nreturn NOTIFY_OK;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int rk3x_i2c_setup(struct rk3x_i2c *i2c, struct i2c_msg *msgs, int num)\r\n{\r\nu32 addr = (msgs[0].addr & 0x7f) << 1;\r\nint ret = 0;\r\nif (num >= 2 && msgs[0].len < 4 &&\r\n!(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\r\nu32 reg_addr = 0;\r\nint i;\r\ndev_dbg(i2c->dev, "Combined write/read from addr 0x%x\n",\r\naddr >> 1);\r\nfor (i = 0; i < msgs[0].len; ++i) {\r\nreg_addr |= msgs[0].buf[i] << (i * 8);\r\nreg_addr |= REG_MRXADDR_VALID(i);\r\n}\r\ni2c->msg = &msgs[1];\r\ni2c->mode = REG_CON_MOD_REGISTER_TX;\r\ni2c_writel(i2c, addr | REG_MRXADDR_VALID(0), REG_MRXADDR);\r\ni2c_writel(i2c, reg_addr, REG_MRXRADDR);\r\nret = 2;\r\n} else {\r\nif (msgs[0].flags & I2C_M_RD) {\r\naddr |= 1;\r\ni2c->mode = REG_CON_MOD_REGISTER_TX;\r\ni2c_writel(i2c, addr | REG_MRXADDR_VALID(0),\r\nREG_MRXADDR);\r\ni2c_writel(i2c, 0, REG_MRXRADDR);\r\n} else {\r\ni2c->mode = REG_CON_MOD_TX;\r\n}\r\ni2c->msg = &msgs[0];\r\nret = 1;\r\n}\r\ni2c->addr = msgs[0].addr;\r\ni2c->busy = true;\r\ni2c->state = STATE_START;\r\ni2c->processed = 0;\r\ni2c->error = 0;\r\nrk3x_i2c_clean_ipd(i2c);\r\nreturn ret;\r\n}\r\nstatic int rk3x_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct rk3x_i2c *i2c = (struct rk3x_i2c *)adap->algo_data;\r\nunsigned long timeout, flags;\r\nint ret = 0;\r\nint i;\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nclk_enable(i2c->clk);\r\ni2c->is_last_msg = false;\r\nfor (i = 0; i < num; i += ret) {\r\nret = rk3x_i2c_setup(i2c, msgs + i, num - i);\r\nif (ret < 0) {\r\ndev_err(i2c->dev, "rk3x_i2c_setup() failed\n");\r\nbreak;\r\n}\r\nif (i + ret >= num)\r\ni2c->is_last_msg = true;\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\nrk3x_i2c_start(i2c);\r\ntimeout = wait_event_timeout(i2c->wait, !i2c->busy,\r\nmsecs_to_jiffies(WAIT_TIMEOUT));\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nif (timeout == 0) {\r\ndev_err(i2c->dev, "timeout, ipd: 0x%02x, state: %d\n",\r\ni2c_readl(i2c, REG_IPD), i2c->state);\r\ni2c_writel(i2c, 0, REG_IEN);\r\ni2c_writel(i2c, REG_CON_EN | REG_CON_STOP, REG_CON);\r\ni2c->state = STATE_IDLE;\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (i2c->error) {\r\nret = i2c->error;\r\nbreak;\r\n}\r\n}\r\nclk_disable(i2c->clk);\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\nreturn ret < 0 ? ret : num;\r\n}\r\nstatic u32 rk3x_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int rk3x_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct rk3x_i2c *i2c;\r\nstruct resource *mem;\r\nint ret = 0;\r\nint bus_nr;\r\nu32 value;\r\nint irq;\r\nunsigned long clk_rate;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct rk3x_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(rk3x_i2c_match, np);\r\ni2c->soc_data = (struct rk3x_i2c_soc_data *)match->data;\r\nif (of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&i2c->scl_frequency)) {\r\ndev_info(&pdev->dev, "using default SCL frequency: %d\n",\r\nDEFAULT_SCL_RATE);\r\ni2c->scl_frequency = DEFAULT_SCL_RATE;\r\n}\r\nif (i2c->scl_frequency == 0 || i2c->scl_frequency > 400 * 1000) {\r\ndev_warn(&pdev->dev, "invalid SCL frequency specified.\n");\r\ndev_warn(&pdev->dev, "using default SCL frequency: %d\n",\r\nDEFAULT_SCL_RATE);\r\ni2c->scl_frequency = DEFAULT_SCL_RATE;\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "i2c-scl-rising-time-ns",\r\n&i2c->scl_rise_ns)) {\r\nif (i2c->scl_frequency <= 100000)\r\ni2c->scl_rise_ns = 1000;\r\nelse\r\ni2c->scl_rise_ns = 300;\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "i2c-scl-falling-time-ns",\r\n&i2c->scl_fall_ns))\r\ni2c->scl_fall_ns = 300;\r\nif (of_property_read_u32(pdev->dev.of_node, "i2c-sda-falling-time-ns",\r\n&i2c->scl_fall_ns))\r\ni2c->sda_fall_ns = i2c->scl_fall_ns;\r\nstrlcpy(i2c->adap.name, "rk3x-i2c", sizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &rk3x_i2c_algorithm;\r\ni2c->adap.retries = 3;\r\ni2c->adap.dev.of_node = np;\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->dev = &pdev->dev;\r\nspin_lock_init(&i2c->lock);\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(i2c->clk);\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(i2c->regs))\r\nreturn PTR_ERR(i2c->regs);\r\nbus_nr = of_alias_get_id(np, "i2c");\r\nif (i2c->soc_data->grf_offset >= 0) {\r\nstruct regmap *grf;\r\ngrf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(grf)) {\r\ndev_err(&pdev->dev,\r\n"rk3x-i2c needs 'rockchip,grf' property\n");\r\nreturn PTR_ERR(grf);\r\n}\r\nif (bus_nr < 0) {\r\ndev_err(&pdev->dev, "rk3x-i2c needs i2cX alias");\r\nreturn -EINVAL;\r\n}\r\nvalue = BIT(27 + bus_nr) | BIT(11 + bus_nr);\r\nret = regmap_write(grf, i2c->soc_data->grf_offset, value);\r\nif (ret != 0) {\r\ndev_err(i2c->dev, "Could not write to GRF: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "cannot find rk3x IRQ\n");\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, rk3x_i2c_irq,\r\n0, dev_name(&pdev->dev), i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot request IRQ\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\nret = clk_prepare(i2c->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not prepare clock\n");\r\nreturn ret;\r\n}\r\ni2c->clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;\r\nret = clk_notifier_register(i2c->clk, &i2c->clk_rate_nb);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Unable to register clock notifier\n");\r\ngoto err_clk;\r\n}\r\nclk_rate = clk_get_rate(i2c->clk);\r\nrk3x_i2c_adapt_div(i2c, clk_rate);\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not register adapter\n");\r\ngoto err_clk_notifier;\r\n}\r\ndev_info(&pdev->dev, "Initialized RK3xxx I2C bus at %p\n", i2c->regs);\r\nreturn 0;\r\nerr_clk_notifier:\r\nclk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);\r\nerr_clk:\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nstatic int rk3x_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct rk3x_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);\r\nclk_unprepare(i2c->clk);\r\nreturn 0;\r\n}
