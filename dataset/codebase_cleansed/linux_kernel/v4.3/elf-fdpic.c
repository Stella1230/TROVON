void elf_fdpic_arch_lay_out_mm(struct elf_fdpic_params *exec_params,\r\nstruct elf_fdpic_params *interp_params,\r\nunsigned long *start_stack,\r\nunsigned long *start_brk)\r\n{\r\n*start_stack = 0x02200000UL;\r\nif (!(interp_params->flags & ELF_FDPIC_FLAG_PRESENT) &&\r\nexec_params->hdr.e_type != ET_EXEC\r\n) {\r\nexec_params->load_addr = PAGE_SIZE;\r\n*start_brk = 0x80000000UL;\r\n}\r\nelse {\r\nexec_params->load_addr = 0x02200000UL;\r\nif ((exec_params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\r\nELF_FDPIC_FLAG_INDEPENDENT\r\n) {\r\nexec_params->flags &= ~ELF_FDPIC_FLAG_ARRANGEMENT;\r\nexec_params->flags |= ELF_FDPIC_FLAG_CONSTDISP;\r\n}\r\n}\r\n}\r\nunsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len,\r\nunsigned long pgoff, unsigned long flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct vm_unmapped_area_info info;\r\nif (len > TASK_SIZE)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(current->mm, addr);\r\nif (TASK_SIZE - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\ngoto success;\r\n}\r\ninfo.flags = 0;\r\ninfo.length = len;\r\ninfo.low_limit = PAGE_SIZE;\r\ninfo.high_limit = (current->mm->start_stack - 0x00200000);\r\ninfo.align_mask = 0;\r\ninfo.align_offset = 0;\r\naddr = vm_unmapped_area(&info);\r\nif (!(addr & ~PAGE_MASK))\r\ngoto success;\r\nVM_BUG_ON(addr != -ENOMEM);\r\ninfo.low_limit = PAGE_ALIGN(0x80000000);\r\ninfo.high_limit = TASK_SIZE;\r\naddr = vm_unmapped_area(&info);\r\nif (!(addr & ~PAGE_MASK))\r\ngoto success;\r\nVM_BUG_ON(addr != -ENOMEM);\r\n#if 0\r\nprintk("[area] l=%lx (ENOMEM) f='%s'\n",\r\nlen, filp ? filp->f_path.dentry->d_name.name : "");\r\n#endif\r\nreturn -ENOMEM;\r\nsuccess:\r\n#if 0\r\nprintk("[area] l=%lx ad=%lx f='%s'\n",\r\nlen, addr, filp ? filp->f_path.dentry->d_name.name : "");\r\n#endif\r\nreturn addr;\r\n}
