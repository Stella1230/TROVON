static void gpio_led_work(struct work_struct *work)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(work, struct gpio_led_data, work);\r\nif (led_dat->blinking) {\r\nled_dat->platform_gpio_blink_set(led_dat->gpiod,\r\nled_dat->new_level, NULL, NULL);\r\nled_dat->blinking = 0;\r\n} else\r\ngpiod_set_value_cansleep(led_dat->gpiod, led_dat->new_level);\r\n}\r\nstatic void gpio_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(led_cdev, struct gpio_led_data, cdev);\r\nint level;\r\nif (value == LED_OFF)\r\nlevel = 0;\r\nelse\r\nlevel = 1;\r\nif (led_dat->can_sleep) {\r\nled_dat->new_level = level;\r\nschedule_work(&led_dat->work);\r\n} else {\r\nif (led_dat->blinking) {\r\nled_dat->platform_gpio_blink_set(led_dat->gpiod, level,\r\nNULL, NULL);\r\nled_dat->blinking = 0;\r\n} else\r\ngpiod_set_value(led_dat->gpiod, level);\r\n}\r\n}\r\nstatic int gpio_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(led_cdev, struct gpio_led_data, cdev);\r\nled_dat->blinking = 1;\r\nreturn led_dat->platform_gpio_blink_set(led_dat->gpiod, GPIO_LED_BLINK,\r\ndelay_on, delay_off);\r\n}\r\nstatic int create_gpio_led(const struct gpio_led *template,\r\nstruct gpio_led_data *led_dat, struct device *parent,\r\nint (*blink_set)(struct gpio_desc *, int, unsigned long *,\r\nunsigned long *))\r\n{\r\nint ret, state;\r\nled_dat->gpiod = template->gpiod;\r\nif (!led_dat->gpiod) {\r\nunsigned long flags = 0;\r\nif (!gpio_is_valid(template->gpio)) {\r\ndev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",\r\ntemplate->gpio, template->name);\r\nreturn 0;\r\n}\r\nif (template->active_low)\r\nflags |= GPIOF_ACTIVE_LOW;\r\nret = devm_gpio_request_one(parent, template->gpio, flags,\r\ntemplate->name);\r\nif (ret < 0)\r\nreturn ret;\r\nled_dat->gpiod = gpio_to_desc(template->gpio);\r\nif (IS_ERR(led_dat->gpiod))\r\nreturn PTR_ERR(led_dat->gpiod);\r\n}\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);\r\nled_dat->blinking = 0;\r\nif (blink_set) {\r\nled_dat->platform_gpio_blink_set = blink_set;\r\nled_dat->cdev.blink_set = gpio_blink_set;\r\n}\r\nled_dat->cdev.brightness_set = gpio_led_set;\r\nif (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)\r\nstate = !!gpiod_get_value_cansleep(led_dat->gpiod);\r\nelse\r\nstate = (template->default_state == LEDS_GPIO_DEFSTATE_ON);\r\nled_dat->cdev.brightness = state ? LED_FULL : LED_OFF;\r\nif (!template->retain_state_suspended)\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nret = gpiod_direction_output(led_dat->gpiod, state);\r\nif (ret < 0)\r\nreturn ret;\r\nINIT_WORK(&led_dat->work, gpio_led_work);\r\nreturn led_classdev_register(parent, &led_dat->cdev);\r\n}\r\nstatic void delete_gpio_led(struct gpio_led_data *led)\r\n{\r\nled_classdev_unregister(&led->cdev);\r\ncancel_work_sync(&led->work);\r\n}\r\nstatic inline int sizeof_gpio_leds_priv(int num_leds)\r\n{\r\nreturn sizeof(struct gpio_leds_priv) +\r\n(sizeof(struct gpio_led_data) * num_leds);\r\n}\r\nstatic struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fwnode_handle *child;\r\nstruct gpio_leds_priv *priv;\r\nint count, ret;\r\nstruct device_node *np;\r\ncount = device_get_child_node_count(dev);\r\nif (!count)\r\nreturn ERR_PTR(-ENODEV);\r\npriv = devm_kzalloc(dev, sizeof_gpio_leds_priv(count), GFP_KERNEL);\r\nif (!priv)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevice_for_each_child_node(dev, child) {\r\nstruct gpio_led led = {};\r\nconst char *state = NULL;\r\nled.gpiod = devm_get_gpiod_from_child(dev, NULL, child);\r\nif (IS_ERR(led.gpiod)) {\r\nfwnode_handle_put(child);\r\nret = PTR_ERR(led.gpiod);\r\ngoto err;\r\n}\r\nnp = to_of_node(child);\r\nif (fwnode_property_present(child, "label")) {\r\nfwnode_property_read_string(child, "label", &led.name);\r\n} else {\r\nif (IS_ENABLED(CONFIG_OF) && !led.name && np)\r\nled.name = np->name;\r\nif (!led.name) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nfwnode_property_read_string(child, "linux,default-trigger",\r\n&led.default_trigger);\r\nif (!fwnode_property_read_string(child, "default-state",\r\n&state)) {\r\nif (!strcmp(state, "keep"))\r\nled.default_state = LEDS_GPIO_DEFSTATE_KEEP;\r\nelse if (!strcmp(state, "on"))\r\nled.default_state = LEDS_GPIO_DEFSTATE_ON;\r\nelse\r\nled.default_state = LEDS_GPIO_DEFSTATE_OFF;\r\n}\r\nif (fwnode_property_present(child, "retain-state-suspended"))\r\nled.retain_state_suspended = 1;\r\nret = create_gpio_led(&led, &priv->leds[priv->num_leds],\r\ndev, NULL);\r\nif (ret < 0) {\r\nfwnode_handle_put(child);\r\ngoto err;\r\n}\r\npriv->num_leds++;\r\n}\r\nreturn priv;\r\nerr:\r\nfor (count = priv->num_leds - 1; count >= 0; count--)\r\ndelete_gpio_led(&priv->leds[count]);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int gpio_led_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct gpio_leds_priv *priv;\r\nint i, ret = 0;\r\nif (pdata && pdata->num_leds) {\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof_gpio_leds_priv(pdata->num_leds),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->num_leds = pdata->num_leds;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nret = create_gpio_led(&pdata->leds[i],\r\n&priv->leds[i],\r\n&pdev->dev, pdata->gpio_blink_set);\r\nif (ret < 0) {\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_gpio_led(&priv->leds[i]);\r\nreturn ret;\r\n}\r\n}\r\n} else {\r\npriv = gpio_leds_create(pdev);\r\nif (IS_ERR(priv))\r\nreturn PTR_ERR(priv);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int gpio_led_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_leds_priv *priv = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < priv->num_leds; i++)\r\ndelete_gpio_led(&priv->leds[i]);\r\nreturn 0;\r\n}
