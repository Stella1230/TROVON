static int aac_alloc_comm(struct aac_dev *dev, void **commaddr, unsigned long commsize, unsigned long commalign)\r\n{\r\nunsigned char *base;\r\nunsigned long size, align;\r\nconst unsigned long fibsize = dev->max_fib_size;\r\nconst unsigned long printfbufsiz = 256;\r\nunsigned long host_rrq_size = 0;\r\nstruct aac_init *init;\r\ndma_addr_t phys;\r\nunsigned long aac_max_hostphysmempages;\r\nif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE1 ||\r\ndev->comm_interface == AAC_COMM_MESSAGE_TYPE2)\r\nhost_rrq_size = (dev->scsi_host_ptr->can_queue\r\n+ AAC_NUM_MGT_FIB) * sizeof(u32);\r\nsize = fibsize + sizeof(struct aac_init) + commsize +\r\ncommalign + printfbufsiz + host_rrq_size;\r\nbase = pci_alloc_consistent(dev->pdev, size, &phys);\r\nif(base == NULL)\r\n{\r\nprintk(KERN_ERR "aacraid: unable to create mapping.\n");\r\nreturn 0;\r\n}\r\ndev->comm_addr = (void *)base;\r\ndev->comm_phys = phys;\r\ndev->comm_size = size;\r\nif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE1 ||\r\ndev->comm_interface == AAC_COMM_MESSAGE_TYPE2) {\r\ndev->host_rrq = (u32 *)(base + fibsize);\r\ndev->host_rrq_pa = phys + fibsize;\r\nmemset(dev->host_rrq, 0, host_rrq_size);\r\n}\r\ndev->init = (struct aac_init *)(base + fibsize + host_rrq_size);\r\ndev->init_pa = phys + fibsize + host_rrq_size;\r\ninit = dev->init;\r\ninit->InitStructRevision = cpu_to_le32(ADAPTER_INIT_STRUCT_REVISION);\r\nif (dev->max_fib_size != sizeof(struct hw_fib))\r\ninit->InitStructRevision = cpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_4);\r\ninit->Sa_MSIXVectors = cpu_to_le32(Sa_MINIPORT_REVISION);\r\ninit->fsrev = cpu_to_le32(dev->fsrev);\r\ndev->aif_base_va = (struct hw_fib *)base;\r\ninit->AdapterFibsVirtualAddress = 0;\r\ninit->AdapterFibsPhysicalAddress = cpu_to_le32((u32)phys);\r\ninit->AdapterFibsSize = cpu_to_le32(fibsize);\r\ninit->AdapterFibAlign = cpu_to_le32(sizeof(struct hw_fib));\r\naac_max_hostphysmempages = dma_get_required_mask(&dev->pdev->dev) >> 12;\r\nif (aac_max_hostphysmempages < AAC_MAX_HOSTPHYSMEMPAGES)\r\ninit->HostPhysMemPages = cpu_to_le32(aac_max_hostphysmempages);\r\nelse\r\ninit->HostPhysMemPages = cpu_to_le32(AAC_MAX_HOSTPHYSMEMPAGES);\r\ninit->InitFlags = cpu_to_le32(INITFLAGS_DRIVER_USES_UTC_TIME |\r\nINITFLAGS_DRIVER_SUPPORTS_PM);\r\ninit->MaxIoCommands = cpu_to_le32(dev->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB);\r\ninit->MaxIoSize = cpu_to_le32(dev->scsi_host_ptr->max_sectors << 9);\r\ninit->MaxFibSize = cpu_to_le32(dev->max_fib_size);\r\ninit->MaxNumAif = cpu_to_le32(dev->max_num_aif);\r\nif (dev->comm_interface == AAC_COMM_MESSAGE) {\r\ninit->InitFlags |= cpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED);\r\ndprintk((KERN_WARNING"aacraid: New Comm Interface enabled\n"));\r\n} else if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE1) {\r\ninit->InitStructRevision = cpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_6);\r\ninit->InitFlags |= cpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED |\r\nINITFLAGS_NEW_COMM_TYPE1_SUPPORTED | INITFLAGS_FAST_JBOD_SUPPORTED);\r\ninit->HostRRQ_AddrHigh = cpu_to_le32((u32)((u64)dev->host_rrq_pa >> 32));\r\ninit->HostRRQ_AddrLow = cpu_to_le32((u32)(dev->host_rrq_pa & 0xffffffff));\r\ndprintk((KERN_WARNING"aacraid: New Comm Interface type1 enabled\n"));\r\n} else if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) {\r\ninit->InitStructRevision = cpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_7);\r\ninit->InitFlags |= cpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED |\r\nINITFLAGS_NEW_COMM_TYPE2_SUPPORTED | INITFLAGS_FAST_JBOD_SUPPORTED);\r\ninit->HostRRQ_AddrHigh = cpu_to_le32((u32)((u64)dev->host_rrq_pa >> 32));\r\ninit->HostRRQ_AddrLow = cpu_to_le32((u32)(dev->host_rrq_pa & 0xffffffff));\r\ninit->Sa_MSIXVectors = cpu_to_le32(dev->max_msix);\r\ndprintk((KERN_WARNING"aacraid: New Comm Interface type2 enabled\n"));\r\n}\r\nbase = base + fibsize + host_rrq_size + sizeof(struct aac_init);\r\nphys = (dma_addr_t)((ulong)phys + fibsize + host_rrq_size +\r\nsizeof(struct aac_init));\r\nalign = (commalign - ((uintptr_t)(base) & (commalign - 1)));\r\nbase = base + align;\r\nphys = phys + align;\r\n*commaddr = base;\r\ninit->CommHeaderAddress = cpu_to_le32((u32)phys);\r\nbase = base + commsize;\r\nphys = phys + commsize;\r\ndev->printfbuf = (void *)base;\r\ninit->printfbuf = cpu_to_le32(phys);\r\ninit->printfbufsiz = cpu_to_le32(printfbufsiz);\r\nmemset(base, 0, printfbufsiz);\r\nreturn 1;\r\n}\r\nstatic void aac_queue_init(struct aac_dev * dev, struct aac_queue * q, u32 *mem, int qsize)\r\n{\r\natomic_set(&q->numpending, 0);\r\nq->dev = dev;\r\ninit_waitqueue_head(&q->cmdready);\r\nINIT_LIST_HEAD(&q->cmdq);\r\ninit_waitqueue_head(&q->qfull);\r\nspin_lock_init(&q->lockdata);\r\nq->lock = &q->lockdata;\r\nq->headers.producer = (__le32 *)mem;\r\nq->headers.consumer = (__le32 *)(mem+1);\r\n*(q->headers.producer) = cpu_to_le32(qsize);\r\n*(q->headers.consumer) = cpu_to_le32(qsize);\r\nq->entries = qsize;\r\n}\r\nint aac_send_shutdown(struct aac_dev * dev)\r\n{\r\nstruct fib * fibctx;\r\nstruct aac_close *cmd;\r\nint status;\r\nfibctx = aac_fib_alloc(dev);\r\nif (!fibctx)\r\nreturn -ENOMEM;\r\naac_fib_init(fibctx);\r\ncmd = (struct aac_close *) fib_data(fibctx);\r\ncmd->command = cpu_to_le32(VM_CloseAll);\r\ncmd->cid = cpu_to_le32(0xfffffffe);\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibctx,\r\nsizeof(struct aac_close),\r\nFsaNormal,\r\n-2 , 1,\r\nNULL, NULL);\r\nif (status >= 0)\r\naac_fib_complete(fibctx);\r\nif (status != -ERESTARTSYS)\r\naac_fib_free(fibctx);\r\ndev->adapter_shutdown = 1;\r\nif ((dev->pdev->device == PMC_DEVICE_S7 ||\r\ndev->pdev->device == PMC_DEVICE_S8 ||\r\ndev->pdev->device == PMC_DEVICE_S9) &&\r\ndev->msi_enabled)\r\naac_src_access_devreg(dev, AAC_ENABLE_INTX);\r\nreturn status;\r\n}\r\nstatic int aac_comm_init(struct aac_dev * dev)\r\n{\r\nunsigned long hdrsize = (sizeof(u32) * NUMBER_OF_COMM_QUEUES) * 2;\r\nunsigned long queuesize = sizeof(struct aac_entry) * TOTAL_QUEUE_ENTRIES;\r\nu32 *headers;\r\nstruct aac_entry * queues;\r\nunsigned long size;\r\nstruct aac_queue_block * comm = dev->queues;\r\nspin_lock_init(&dev->fib_lock);\r\nsize = hdrsize + queuesize;\r\nif (!aac_alloc_comm(dev, (void * *)&headers, size, QUEUE_ALIGNMENT))\r\nreturn -ENOMEM;\r\nqueues = (struct aac_entry *)(((ulong)headers) + hdrsize);\r\ncomm->queue[HostNormCmdQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[HostNormCmdQueue], headers, HOST_NORM_CMD_ENTRIES);\r\nqueues += HOST_NORM_CMD_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[HostHighCmdQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[HostHighCmdQueue], headers, HOST_HIGH_CMD_ENTRIES);\r\nqueues += HOST_HIGH_CMD_ENTRIES;\r\nheaders +=2;\r\ncomm->queue[AdapNormCmdQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[AdapNormCmdQueue], headers, ADAP_NORM_CMD_ENTRIES);\r\nqueues += ADAP_NORM_CMD_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[AdapHighCmdQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[AdapHighCmdQueue], headers, ADAP_HIGH_CMD_ENTRIES);\r\nqueues += ADAP_HIGH_CMD_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[HostNormRespQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[HostNormRespQueue], headers, HOST_NORM_RESP_ENTRIES);\r\nqueues += HOST_NORM_RESP_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[HostHighRespQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[HostHighRespQueue], headers, HOST_HIGH_RESP_ENTRIES);\r\nqueues += HOST_HIGH_RESP_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[AdapNormRespQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[AdapNormRespQueue], headers, ADAP_NORM_RESP_ENTRIES);\r\nqueues += ADAP_NORM_RESP_ENTRIES;\r\nheaders += 2;\r\ncomm->queue[AdapHighRespQueue].base = queues;\r\naac_queue_init(dev, &comm->queue[AdapHighRespQueue], headers, ADAP_HIGH_RESP_ENTRIES);\r\ncomm->queue[AdapNormCmdQueue].lock = comm->queue[HostNormRespQueue].lock;\r\ncomm->queue[AdapHighCmdQueue].lock = comm->queue[HostHighRespQueue].lock;\r\ncomm->queue[AdapNormRespQueue].lock = comm->queue[HostNormCmdQueue].lock;\r\ncomm->queue[AdapHighRespQueue].lock = comm->queue[HostHighCmdQueue].lock;\r\nreturn 0;\r\n}\r\nstruct aac_dev *aac_init_adapter(struct aac_dev *dev)\r\n{\r\nu32 status[5];\r\nstruct Scsi_Host * host = dev->scsi_host_ptr;\r\nextern int aac_sync_mode;\r\ndev->management_fib_count = 0;\r\nspin_lock_init(&dev->manage_lock);\r\nspin_lock_init(&dev->sync_lock);\r\ndev->max_fib_size = sizeof(struct hw_fib);\r\ndev->sg_tablesize = host->sg_tablesize = (dev->max_fib_size\r\n- sizeof(struct aac_fibhdr)\r\n- sizeof(struct aac_write) + sizeof(struct sgentry))\r\n/ sizeof(struct sgentry);\r\ndev->comm_interface = AAC_COMM_PRODUCER;\r\ndev->raw_io_interface = dev->raw_io_64 = 0;\r\nif ((!aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES,\r\n0, 0, 0, 0, 0, 0,\r\nstatus+0, status+1, status+2, status+3, NULL)) &&\r\n(status[0] == 0x00000001)) {\r\ndev->doorbell_mask = status[3];\r\nif (status[1] & le32_to_cpu(AAC_OPT_NEW_COMM_64))\r\ndev->raw_io_64 = 1;\r\ndev->sync_mode = aac_sync_mode;\r\nif (dev->a_ops.adapter_comm &&\r\n(status[1] & le32_to_cpu(AAC_OPT_NEW_COMM))) {\r\ndev->comm_interface = AAC_COMM_MESSAGE;\r\ndev->raw_io_interface = 1;\r\nif ((status[1] & le32_to_cpu(AAC_OPT_NEW_COMM_TYPE1))) {\r\ndev->comm_interface = AAC_COMM_MESSAGE_TYPE1;\r\n} else if ((status[1] & le32_to_cpu(AAC_OPT_NEW_COMM_TYPE2))) {\r\ndev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\r\n} else if ((status[1] & le32_to_cpu(AAC_OPT_NEW_COMM_TYPE4)) ||\r\n(status[1] & le32_to_cpu(AAC_OPT_NEW_COMM_TYPE3))) {\r\ndev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\r\ndev->sync_mode = 1;\r\n}\r\n}\r\nif ((dev->comm_interface == AAC_COMM_MESSAGE) &&\r\n(status[2] > dev->base_size)) {\r\naac_adapter_ioremap(dev, 0);\r\ndev->base_size = status[2];\r\nif (aac_adapter_ioremap(dev, status[2])) {\r\ndev->comm_interface = AAC_COMM_PRODUCER;\r\nif (aac_adapter_ioremap(dev, AAC_MIN_FOOTPRINT_SIZE)) {\r\nprintk(KERN_WARNING\r\n"aacraid: unable to map adapter.\n");\r\nreturn NULL;\r\n}\r\n}\r\n}\r\n}\r\ndev->max_msix = 0;\r\ndev->msi_enabled = 0;\r\ndev->adapter_shutdown = 0;\r\nif ((!aac_adapter_sync_cmd(dev, GET_COMM_PREFERRED_SETTINGS,\r\n0, 0, 0, 0, 0, 0,\r\nstatus+0, status+1, status+2, status+3, status+4))\r\n&& (status[0] == 0x00000001)) {\r\nhost->max_sectors = (status[1] >> 16) << 1;\r\ndev->max_fib_size = status[1] & 0xFFE0;\r\nhost->sg_tablesize = status[2] >> 16;\r\ndev->sg_tablesize = status[2] & 0xFFFF;\r\nif (dev->pdev->device == PMC_DEVICE_S7 ||\r\ndev->pdev->device == PMC_DEVICE_S8 ||\r\ndev->pdev->device == PMC_DEVICE_S9)\r\nhost->can_queue = ((status[3] >> 16) ? (status[3] >> 16) :\r\n(status[3] & 0xFFFF)) - AAC_NUM_MGT_FIB;\r\nelse\r\nhost->can_queue = (status[3] & 0xFFFF) - AAC_NUM_MGT_FIB;\r\ndev->max_num_aif = status[4] & 0xFFFF;\r\nif (acbsize == 512) {\r\nhost->max_sectors = AAC_MAX_32BIT_SGBCOUNT;\r\ndev->max_fib_size = 512;\r\ndev->sg_tablesize = host->sg_tablesize\r\n= (512 - sizeof(struct aac_fibhdr)\r\n- sizeof(struct aac_write) + sizeof(struct sgentry))\r\n/ sizeof(struct sgentry);\r\nhost->can_queue = AAC_NUM_IO_FIB;\r\n} else if (acbsize == 2048) {\r\nhost->max_sectors = 512;\r\ndev->max_fib_size = 2048;\r\nhost->sg_tablesize = 65;\r\ndev->sg_tablesize = 81;\r\nhost->can_queue = 512 - AAC_NUM_MGT_FIB;\r\n} else if (acbsize == 4096) {\r\nhost->max_sectors = 1024;\r\ndev->max_fib_size = 4096;\r\nhost->sg_tablesize = 129;\r\ndev->sg_tablesize = 166;\r\nhost->can_queue = 256 - AAC_NUM_MGT_FIB;\r\n} else if (acbsize == 8192) {\r\nhost->max_sectors = 2048;\r\ndev->max_fib_size = 8192;\r\nhost->sg_tablesize = 257;\r\ndev->sg_tablesize = 337;\r\nhost->can_queue = 128 - AAC_NUM_MGT_FIB;\r\n} else if (acbsize > 0) {\r\nprintk("Illegal acbsize=%d ignored\n", acbsize);\r\n}\r\n}\r\n{\r\nif (numacb > 0) {\r\nif (numacb < host->can_queue)\r\nhost->can_queue = numacb;\r\nelse\r\nprintk("numacb=%d ignored\n", numacb);\r\n}\r\n}\r\nif (host->can_queue > AAC_NUM_IO_FIB)\r\nhost->can_queue = AAC_NUM_IO_FIB;\r\nif (dev->pdev->device == PMC_DEVICE_S6 ||\r\ndev->pdev->device == PMC_DEVICE_S7 ||\r\ndev->pdev->device == PMC_DEVICE_S8 ||\r\ndev->pdev->device == PMC_DEVICE_S9)\r\naac_define_int_mode(dev);\r\ndev->queues = kzalloc(sizeof(struct aac_queue_block), GFP_KERNEL);\r\nif (dev->queues == NULL) {\r\nprintk(KERN_ERR "Error could not allocate comm region.\n");\r\nreturn NULL;\r\n}\r\nif (aac_comm_init(dev)<0){\r\nkfree(dev->queues);\r\nreturn NULL;\r\n}\r\nif (aac_fib_setup(dev) < 0) {\r\nkfree(dev->queues);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&dev->fib_list);\r\nINIT_LIST_HEAD(&dev->sync_fib_list);\r\nreturn dev;\r\n}\r\nstatic void aac_define_int_mode(struct aac_dev *dev)\r\n{\r\nint i, msi_count;\r\nmsi_count = i = 0;\r\nif (dev->max_msix == 0 ||\r\ndev->pdev->device == PMC_DEVICE_S6 ||\r\ndev->sync_mode) {\r\ndev->max_msix = 1;\r\ndev->vector_cap =\r\ndev->scsi_host_ptr->can_queue +\r\nAAC_NUM_MGT_FIB;\r\nreturn;\r\n}\r\nmsi_count = min(dev->max_msix,\r\n(unsigned int)num_online_cpus());\r\ndev->max_msix = msi_count;\r\nif (msi_count > AAC_MAX_MSIX)\r\nmsi_count = AAC_MAX_MSIX;\r\nfor (i = 0; i < msi_count; i++)\r\ndev->msixentry[i].entry = i;\r\nif (msi_count > 1 &&\r\npci_find_capability(dev->pdev, PCI_CAP_ID_MSIX)) {\r\ni = pci_enable_msix(dev->pdev,\r\ndev->msixentry,\r\nmsi_count);\r\nif (i >= 0) {\r\ndev->msi_enabled = 1;\r\nif (i) {\r\nmsi_count = i;\r\nif (pci_enable_msix(dev->pdev,\r\ndev->msixentry,\r\nmsi_count)) {\r\ndev->msi_enabled = 0;\r\nprintk(KERN_ERR "%s%d: MSIX not supported!! Will try MSI 0x%x.\n",\r\ndev->name, dev->id, i);\r\n}\r\n}\r\n} else {\r\ndev->msi_enabled = 0;\r\nprintk(KERN_ERR "%s%d: MSIX not supported!! Will try MSI 0x%x.\n",\r\ndev->name, dev->id, i);\r\n}\r\n}\r\nif (!dev->msi_enabled) {\r\nmsi_count = 1;\r\ni = pci_enable_msi(dev->pdev);\r\nif (!i) {\r\ndev->msi_enabled = 1;\r\ndev->msi = 1;\r\n} else {\r\nprintk(KERN_ERR "%s%d: MSI not supported!! Will try INTx 0x%x.\n",\r\ndev->name, dev->id, i);\r\n}\r\n}\r\nif (!dev->msi_enabled)\r\ndev->max_msix = msi_count = 1;\r\nelse {\r\nif (dev->max_msix > msi_count)\r\ndev->max_msix = msi_count;\r\n}\r\ndev->vector_cap =\r\n(dev->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB) /\r\nmsi_count;\r\n}
