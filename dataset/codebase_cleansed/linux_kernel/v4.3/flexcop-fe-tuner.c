static int flexcop_fe_request_firmware(struct dvb_frontend *fe,\r\nconst struct firmware **fw, char *name)\r\n{\r\nstruct flexcop_device *fc = fe->dvb->priv;\r\nreturn request_firmware(fw, name, fc->dev);\r\n}\r\nstatic int flexcop_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct flexcop_device *fc = fe->dvb->priv;\r\nflexcop_ibi_value v;\r\ndeb_tuner("polarity/voltage = %u\n", voltage);\r\nv = fc->read_ibi_reg(fc, misc_204);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_OFF:\r\nv.misc_204.ACPI1_sig = 1;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\nv.misc_204.ACPI1_sig = 0;\r\nv.misc_204.LNB_L_H_sig = 0;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nv.misc_204.ACPI1_sig = 0;\r\nv.misc_204.LNB_L_H_sig = 1;\r\nbreak;\r\ndefault:\r\nerr("unknown SEC_VOLTAGE value");\r\nreturn -EINVAL;\r\n}\r\nreturn fc->write_ibi_reg(fc, misc_204, v);\r\n}\r\nstatic int flexcop_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct flexcop_device *fc = fe->dvb->priv;\r\nif (fc->fe_sleep)\r\nreturn fc->fe_sleep(fe);\r\nreturn 0;\r\n}\r\nstatic int flexcop_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\r\n{\r\nstruct flexcop_device *fc = fe->dvb->priv;\r\nflexcop_ibi_value v;\r\nu16 ax;\r\nv.raw = 0;\r\ndeb_tuner("tone = %u\n",tone);\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nax = 0x01ff;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nax = 0;\r\nbreak;\r\ndefault:\r\nerr("unknown SEC_TONE value");\r\nreturn -EINVAL;\r\n}\r\nv.lnb_switch_freq_200.LNB_CTLPrescaler_sig = 1;\r\nv.lnb_switch_freq_200.LNB_CTLHighCount_sig = ax;\r\nv.lnb_switch_freq_200.LNB_CTLLowCount_sig = ax == 0 ? 0x1ff : ax;\r\nreturn fc->write_ibi_reg(fc,lnb_switch_freq_200,v);\r\n}\r\nstatic void flexcop_diseqc_send_bit(struct dvb_frontend* fe, int data)\r\n{\r\nflexcop_set_tone(fe, SEC_TONE_ON);\r\nudelay(data ? 500 : 1000);\r\nflexcop_set_tone(fe, SEC_TONE_OFF);\r\nudelay(data ? 1000 : 500);\r\n}\r\nstatic void flexcop_diseqc_send_byte(struct dvb_frontend* fe, int data)\r\n{\r\nint i, par = 1, d;\r\nfor (i = 7; i >= 0; i--) {\r\nd = (data >> i) & 1;\r\npar ^= d;\r\nflexcop_diseqc_send_bit(fe, d);\r\n}\r\nflexcop_diseqc_send_bit(fe, par);\r\n}\r\nstatic int flexcop_send_diseqc_msg(struct dvb_frontend *fe,\r\nint len, u8 *msg, unsigned long burst)\r\n{\r\nint i;\r\nflexcop_set_tone(fe, SEC_TONE_OFF);\r\nmdelay(16);\r\nfor (i = 0; i < len; i++)\r\nflexcop_diseqc_send_byte(fe,msg[i]);\r\nmdelay(16);\r\nif (burst != -1) {\r\nif (burst)\r\nflexcop_diseqc_send_byte(fe, 0xff);\r\nelse {\r\nflexcop_set_tone(fe, SEC_TONE_ON);\r\nmdelay(12);\r\nudelay(500);\r\nflexcop_set_tone(fe, SEC_TONE_OFF);\r\n}\r\nmsleep(20);\r\n}\r\nreturn 0;\r\n}\r\nstatic int flexcop_diseqc_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nreturn flexcop_send_diseqc_msg(fe, cmd->msg_len, cmd->msg, 0);\r\n}\r\nstatic int flexcop_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd minicmd)\r\n{\r\nreturn flexcop_send_diseqc_msg(fe, 0, NULL, minicmd);\r\n}\r\nstatic int skystar2_rev23_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct dvb_frontend_ops *ops;\r\nfc->fe = dvb_attach(mt312_attach, &skystar23_samsung_tbdu18132_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61, i2c,\r\nDVB_PLL_SAMSUNG_TBDU18132))\r\nreturn 0;\r\nops = &fc->fe->ops;\r\nops->diseqc_send_master_cmd = flexcop_diseqc_send_master_cmd;\r\nops->diseqc_send_burst = flexcop_diseqc_send_burst;\r\nops->set_tone = flexcop_set_tone;\r\nops->set_voltage = flexcop_set_voltage;\r\nfc->fe_sleep = ops->sleep;\r\nops->sleep = flexcop_sleep;\r\nreturn 1;\r\n}\r\nstatic int samsung_tbmu24112_set_symbol_rate(struct dvb_frontend *fe,\r\nu32 srate, u32 ratio)\r\n{\r\nu8 aclk = 0;\r\nu8 bclk = 0;\r\nif (srate < 1500000) {\r\naclk = 0xb7; bclk = 0x47;\r\n} else if (srate < 3000000) {\r\naclk = 0xb7; bclk = 0x4b;\r\n} else if (srate < 7000000) {\r\naclk = 0xb7; bclk = 0x4f;\r\n} else if (srate < 14000000) {\r\naclk = 0xb7; bclk = 0x53;\r\n} else if (srate < 30000000) {\r\naclk = 0xb6; bclk = 0x53;\r\n} else if (srate < 45000000) {\r\naclk = 0xb4; bclk = 0x51;\r\n}\r\nstv0299_writereg(fe, 0x13, aclk);\r\nstv0299_writereg(fe, 0x14, bclk);\r\nstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, 0x21, ratio & 0xf0);\r\nreturn 0;\r\n}\r\nstatic int skystar2_rev26_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(stv0299_attach, &samsung_tbmu24112_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61, i2c,\r\nDVB_PLL_SAMSUNG_TBMU24112))\r\nreturn 0;\r\nfc->fe->ops.set_voltage = flexcop_set_voltage;\r\nfc->fe_sleep = fc->fe->ops.sleep;\r\nfc->fe->ops.sleep = flexcop_sleep;\r\nreturn 1;\r\n}\r\nstatic int skystar2_rev27_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nflexcop_ibi_value r108;\r\nstruct i2c_adapter *i2c_tuner;\r\nfc->fc_i2c_adap[0].no_base_addr = 1;\r\nfc->fe = dvb_attach(s5h1420_attach, &skystar2_rev2_7_s5h1420_config,\r\ni2c);\r\nif (!fc->fe)\r\ngoto fail;\r\ni2c_tuner = s5h1420_get_tuner_i2c_adapter(fc->fe);\r\nif (!i2c_tuner)\r\ngoto fail;\r\nfc->fe_sleep = fc->fe->ops.sleep;\r\nfc->fe->ops.sleep = flexcop_sleep;\r\nfc->fc_i2c_adap[2].no_base_addr = 1;\r\nif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\r\n0x08, 1, 1, false)) {\r\nerr("ISL6421 could NOT be attached");\r\ngoto fail_isl;\r\n}\r\ninfo("ISL6421 successfully attached");\r\nr108.raw = 0x00000506;\r\nfc->write_ibi_reg(fc, tw_sm_c_108, r108);\r\nif (!dvb_attach(itd1000_attach, fc->fe, i2c_tuner,\r\n&skystar2_rev2_7_itd1000_config)) {\r\nerr("ITD1000 could NOT be attached");\r\ngoto fail_isl;\r\n}\r\ninfo("ITD1000 successfully attached");\r\nreturn 1;\r\nfail_isl:\r\nfc->fc_i2c_adap[2].no_base_addr = 0;\r\nfail:\r\nfc->fc_i2c_adap[0].no_base_addr = 0;\r\nreturn 0;\r\n}\r\nstatic int skystar2_rev28_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct i2c_adapter *i2c_tuner;\r\nfc->fe = dvb_attach(cx24123_attach, &skystar2_rev2_8_cx24123_config,\r\ni2c);\r\nif (!fc->fe)\r\nreturn 0;\r\ni2c_tuner = cx24123_get_tuner_i2c_adapter(fc->fe);\r\nif (!i2c_tuner)\r\nreturn 0;\r\nif (!dvb_attach(cx24113_attach, fc->fe, &skystar2_rev2_8_cx24113_config,\r\ni2c_tuner)) {\r\nerr("CX24113 could NOT be attached");\r\nreturn 0;\r\n}\r\ninfo("CX24113 successfully attached");\r\nfc->fc_i2c_adap[2].no_base_addr = 1;\r\nif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\r\n0x08, 0, 0, false)) {\r\nerr("ISL6421 could NOT be attached");\r\nfc->fc_i2c_adap[2].no_base_addr = 0;\r\nreturn 0;\r\n}\r\ninfo("ISL6421 successfully attached");\r\nreturn 1;\r\n}\r\nstatic int samsung_tdtc9251dh0_demod_init(struct dvb_frontend *fe)\r\n{\r\nstatic u8 mt352_clock_config[] = { 0x89, 0x18, 0x2d };\r\nstatic u8 mt352_reset[] = { 0x50, 0x80 };\r\nstatic u8 mt352_adc_ctl_1_cfg[] = { 0x8E, 0x40 };\r\nstatic u8 mt352_agc_cfg[] = { 0x67, 0x28, 0xa1 };\r\nstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\r\nmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\r\nudelay(2000);\r\nmt352_write(fe, mt352_reset, sizeof(mt352_reset));\r\nmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\r\nmt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));\r\nmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int airstar_dvbt_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(mt352_attach, &samsung_tdtc9251dh0_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nreturn !!dvb_attach(dvb_pll_attach, fc->fe, 0x61, NULL,\r\nDVB_PLL_SAMSUNG_TDTC9251DH0);\r\n}\r\nstatic int airstar_atsc1_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(bcm3510_attach, &air2pc_atsc_first_gen_config, i2c);\r\nreturn fc->fe != NULL;\r\n}\r\nstatic int airstar_atsc2_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(nxt200x_attach, &samsung_tbmv_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nreturn !!dvb_attach(dvb_pll_attach, fc->fe, 0x61, NULL,\r\nDVB_PLL_SAMSUNG_TBMV);\r\n}\r\nstatic int airstar_atsc3_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(lgdt330x_attach, &air2pc_atsc_hd5000_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nreturn !!dvb_attach(simple_tuner_attach, fc->fe, i2c, 0x61,\r\nTUNER_LG_TDVS_H06XF);\r\n}\r\nstatic int cablestar2_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fc_i2c_adap[0].no_base_addr = 1;\r\nfc->fe = dvb_attach(stv0297_attach, &alps_tdee4_stv0297_config, i2c);\r\nif (!fc->fe)\r\ngoto fail;\r\nif (fc->fe->ops.i2c_gate_ctrl)\r\nfc->fe->ops.i2c_gate_ctrl(fc->fe, 0);\r\nfc->fe->ops.i2c_gate_ctrl = NULL;\r\nif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61,\r\n&fc->fc_i2c_adap[2].i2c_adap, DVB_PLL_TDEE4))\r\ngoto fail;\r\nreturn 1;\r\nfail:\r\nfc->fc_i2c_adap[0].no_base_addr = 0;\r\nreturn 0;\r\n}\r\nstatic int skystarS2_rev33_attach(struct flexcop_device *fc,\r\nstruct i2c_adapter *i2c)\r\n{\r\nfc->fe = dvb_attach(cx24120_attach,\r\n&skystar2_rev3_3_cx24120_config, i2c);\r\nif (!fc->fe)\r\nreturn 0;\r\nfc->dev_type = FC_SKYS2_REV33;\r\nfc->fc_i2c_adap[2].no_base_addr = 1;\r\nif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\r\n0x08, 0, 0, false)) {\r\nerr("ISL6421 could NOT be attached!");\r\nfc->fc_i2c_adap[2].no_base_addr = 0;\r\nreturn 0;\r\n}\r\ninfo("ISL6421 successfully attached.");\r\nif (fc->has_32_hw_pid_filter)\r\nfc->skip_6_hw_pid_filter = 1;\r\nreturn 1;\r\n}\r\nint flexcop_frontend_init(struct flexcop_device *fc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(flexcop_frontends); i++) {\r\nif (!flexcop_frontends[i].attach)\r\ncontinue;\r\nfc->dev_type = flexcop_frontends[i].type;\r\nif (flexcop_frontends[i].attach(fc, &fc->fc_i2c_adap[0].i2c_adap))\r\ngoto fe_found;\r\nif (fc->fe) {\r\ndvb_frontend_detach(fc->fe);\r\nfc->fe = NULL;\r\n}\r\n}\r\nfc->dev_type = FC_UNK;\r\nerr("no frontend driver found for this B2C2/FlexCop adapter");\r\nreturn -ENODEV;\r\nfe_found:\r\ninfo("found '%s' .", fc->fe->ops.info.name);\r\nif (dvb_register_frontend(&fc->dvb_adapter, fc->fe)) {\r\nerr("frontend registration failed!");\r\ndvb_frontend_detach(fc->fe);\r\nfc->fe = NULL;\r\nreturn -EINVAL;\r\n}\r\nfc->init_state |= FC_STATE_FE_INIT;\r\nreturn 0;\r\n}\r\nvoid flexcop_frontend_exit(struct flexcop_device *fc)\r\n{\r\nif (fc->init_state & FC_STATE_FE_INIT) {\r\ndvb_unregister_frontend(fc->fe);\r\ndvb_frontend_detach(fc->fe);\r\n}\r\nfc->init_state &= ~FC_STATE_FE_INIT;\r\n}
