static int db_export__deferred(struct db_export *dbe)\r\n{\r\nstruct deferred_export *de;\r\nint err;\r\nwhile (!list_empty(&dbe->deferred)) {\r\nde = list_entry(dbe->deferred.next, struct deferred_export,\r\nnode);\r\nerr = dbe->export_comm(dbe, de->comm);\r\nlist_del(&de->node);\r\nfree(de);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void db_export__free_deferred(struct db_export *dbe)\r\n{\r\nstruct deferred_export *de;\r\nwhile (!list_empty(&dbe->deferred)) {\r\nde = list_entry(dbe->deferred.next, struct deferred_export,\r\nnode);\r\nlist_del(&de->node);\r\nfree(de);\r\n}\r\n}\r\nstatic int db_export__defer_comm(struct db_export *dbe, struct comm *comm)\r\n{\r\nstruct deferred_export *de;\r\nde = zalloc(sizeof(struct deferred_export));\r\nif (!de)\r\nreturn -ENOMEM;\r\nde->comm = comm;\r\nlist_add_tail(&de->node, &dbe->deferred);\r\nreturn 0;\r\n}\r\nint db_export__init(struct db_export *dbe)\r\n{\r\nmemset(dbe, 0, sizeof(struct db_export));\r\nINIT_LIST_HEAD(&dbe->deferred);\r\nreturn 0;\r\n}\r\nint db_export__flush(struct db_export *dbe)\r\n{\r\nreturn db_export__deferred(dbe);\r\n}\r\nvoid db_export__exit(struct db_export *dbe)\r\n{\r\ndb_export__free_deferred(dbe);\r\ncall_return_processor__free(dbe->crp);\r\ndbe->crp = NULL;\r\n}\r\nint db_export__evsel(struct db_export *dbe, struct perf_evsel *evsel)\r\n{\r\nif (evsel->db_id)\r\nreturn 0;\r\nevsel->db_id = ++dbe->evsel_last_db_id;\r\nif (dbe->export_evsel)\r\nreturn dbe->export_evsel(dbe, evsel);\r\nreturn 0;\r\n}\r\nint db_export__machine(struct db_export *dbe, struct machine *machine)\r\n{\r\nif (machine->db_id)\r\nreturn 0;\r\nmachine->db_id = ++dbe->machine_last_db_id;\r\nif (dbe->export_machine)\r\nreturn dbe->export_machine(dbe, machine);\r\nreturn 0;\r\n}\r\nint db_export__thread(struct db_export *dbe, struct thread *thread,\r\nstruct machine *machine, struct comm *comm)\r\n{\r\nstruct thread *main_thread;\r\nu64 main_thread_db_id = 0;\r\nint err;\r\nif (thread->db_id)\r\nreturn 0;\r\nthread->db_id = ++dbe->thread_last_db_id;\r\nif (thread->pid_ != -1) {\r\nif (thread->pid_ == thread->tid) {\r\nmain_thread = thread;\r\n} else {\r\nmain_thread = machine__findnew_thread(machine,\r\nthread->pid_,\r\nthread->pid_);\r\nif (!main_thread)\r\nreturn -ENOMEM;\r\nerr = db_export__thread(dbe, main_thread, machine,\r\ncomm);\r\nif (err)\r\ngoto out_put;\r\nif (comm) {\r\nerr = db_export__comm_thread(dbe, comm, thread);\r\nif (err)\r\ngoto out_put;\r\n}\r\n}\r\nmain_thread_db_id = main_thread->db_id;\r\nif (main_thread != thread)\r\nthread__put(main_thread);\r\n}\r\nif (dbe->export_thread)\r\nreturn dbe->export_thread(dbe, thread, main_thread_db_id,\r\nmachine);\r\nreturn 0;\r\nout_put:\r\nthread__put(main_thread);\r\nreturn err;\r\n}\r\nint db_export__comm(struct db_export *dbe, struct comm *comm,\r\nstruct thread *main_thread)\r\n{\r\nint err;\r\nif (comm->db_id)\r\nreturn 0;\r\ncomm->db_id = ++dbe->comm_last_db_id;\r\nif (dbe->export_comm) {\r\nif (main_thread->comm_set)\r\nerr = dbe->export_comm(dbe, comm);\r\nelse\r\nerr = db_export__defer_comm(dbe, comm);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn db_export__comm_thread(dbe, comm, main_thread);\r\n}\r\nint db_export__comm_thread(struct db_export *dbe, struct comm *comm,\r\nstruct thread *thread)\r\n{\r\nu64 db_id;\r\ndb_id = ++dbe->comm_thread_last_db_id;\r\nif (dbe->export_comm_thread)\r\nreturn dbe->export_comm_thread(dbe, db_id, comm, thread);\r\nreturn 0;\r\n}\r\nint db_export__dso(struct db_export *dbe, struct dso *dso,\r\nstruct machine *machine)\r\n{\r\nif (dso->db_id)\r\nreturn 0;\r\ndso->db_id = ++dbe->dso_last_db_id;\r\nif (dbe->export_dso)\r\nreturn dbe->export_dso(dbe, dso, machine);\r\nreturn 0;\r\n}\r\nint db_export__symbol(struct db_export *dbe, struct symbol *sym,\r\nstruct dso *dso)\r\n{\r\nu64 *sym_db_id = symbol__priv(sym);\r\nif (*sym_db_id)\r\nreturn 0;\r\n*sym_db_id = ++dbe->symbol_last_db_id;\r\nif (dbe->export_symbol)\r\nreturn dbe->export_symbol(dbe, sym, dso);\r\nreturn 0;\r\n}\r\nstatic struct thread *get_main_thread(struct machine *machine, struct thread *thread)\r\n{\r\nif (thread->pid_ == thread->tid)\r\nreturn thread__get(thread);\r\nif (thread->pid_ == -1)\r\nreturn NULL;\r\nreturn machine__find_thread(machine, thread->pid_, thread->pid_);\r\n}\r\nstatic int db_ids_from_al(struct db_export *dbe, struct addr_location *al,\r\nu64 *dso_db_id, u64 *sym_db_id, u64 *offset)\r\n{\r\nint err;\r\nif (al->map) {\r\nstruct dso *dso = al->map->dso;\r\nerr = db_export__dso(dbe, dso, al->machine);\r\nif (err)\r\nreturn err;\r\n*dso_db_id = dso->db_id;\r\nif (!al->sym) {\r\nal->sym = symbol__new(al->addr, 0, 0, "unknown");\r\nif (al->sym)\r\nsymbols__insert(&dso->symbols[al->map->type],\r\nal->sym);\r\n}\r\nif (al->sym) {\r\nu64 *db_id = symbol__priv(al->sym);\r\nerr = db_export__symbol(dbe, al->sym, dso);\r\nif (err)\r\nreturn err;\r\n*sym_db_id = *db_id;\r\n*offset = al->addr - al->sym->start;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint db_export__branch_type(struct db_export *dbe, u32 branch_type,\r\nconst char *name)\r\n{\r\nif (dbe->export_branch_type)\r\nreturn dbe->export_branch_type(dbe, branch_type, name);\r\nreturn 0;\r\n}\r\nint db_export__sample(struct db_export *dbe, union perf_event *event,\r\nstruct perf_sample *sample, struct perf_evsel *evsel,\r\nstruct addr_location *al)\r\n{\r\nstruct thread* thread = al->thread;\r\nstruct export_sample es = {\r\n.event = event,\r\n.sample = sample,\r\n.evsel = evsel,\r\n.al = al,\r\n};\r\nstruct thread *main_thread;\r\nstruct comm *comm = NULL;\r\nint err;\r\nerr = db_export__evsel(dbe, evsel);\r\nif (err)\r\nreturn err;\r\nerr = db_export__machine(dbe, al->machine);\r\nif (err)\r\nreturn err;\r\nmain_thread = get_main_thread(al->machine, thread);\r\nif (main_thread)\r\ncomm = machine__thread_exec_comm(al->machine, main_thread);\r\nerr = db_export__thread(dbe, thread, al->machine, comm);\r\nif (err)\r\ngoto out_put;\r\nif (comm) {\r\nerr = db_export__comm(dbe, comm, main_thread);\r\nif (err)\r\ngoto out_put;\r\nes.comm_db_id = comm->db_id;\r\n}\r\nes.db_id = ++dbe->sample_last_db_id;\r\nerr = db_ids_from_al(dbe, al, &es.dso_db_id, &es.sym_db_id, &es.offset);\r\nif (err)\r\ngoto out_put;\r\nif ((evsel->attr.sample_type & PERF_SAMPLE_ADDR) &&\r\nsample_addr_correlates_sym(&evsel->attr)) {\r\nstruct addr_location addr_al;\r\nperf_event__preprocess_sample_addr(event, sample, thread, &addr_al);\r\nerr = db_ids_from_al(dbe, &addr_al, &es.addr_dso_db_id,\r\n&es.addr_sym_db_id, &es.addr_offset);\r\nif (err)\r\ngoto out_put;\r\nif (dbe->crp) {\r\nerr = thread_stack__process(thread, comm, sample, al,\r\n&addr_al, es.db_id,\r\ndbe->crp);\r\nif (err)\r\ngoto out_put;\r\n}\r\n}\r\nif (dbe->export_sample)\r\nerr = dbe->export_sample(dbe, &es);\r\nout_put:\r\nthread__put(main_thread);\r\nreturn err;\r\n}\r\nint db_export__branch_types(struct db_export *dbe)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; branch_types[i].name ; i++) {\r\nerr = db_export__branch_type(dbe, branch_types[i].branch_type,\r\nbranch_types[i].name);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint db_export__call_path(struct db_export *dbe, struct call_path *cp)\r\n{\r\nint err;\r\nif (cp->db_id)\r\nreturn 0;\r\nif (cp->parent) {\r\nerr = db_export__call_path(dbe, cp->parent);\r\nif (err)\r\nreturn err;\r\n}\r\ncp->db_id = ++dbe->call_path_last_db_id;\r\nif (dbe->export_call_path)\r\nreturn dbe->export_call_path(dbe, cp);\r\nreturn 0;\r\n}\r\nint db_export__call_return(struct db_export *dbe, struct call_return *cr)\r\n{\r\nint err;\r\nif (cr->db_id)\r\nreturn 0;\r\nerr = db_export__call_path(dbe, cr->cp);\r\nif (err)\r\nreturn err;\r\ncr->db_id = ++dbe->call_return_last_db_id;\r\nif (dbe->export_call_return)\r\nreturn dbe->export_call_return(dbe, cr);\r\nreturn 0;\r\n}
