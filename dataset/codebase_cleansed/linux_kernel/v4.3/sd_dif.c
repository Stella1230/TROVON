void sd_dif_config_host(struct scsi_disk *sdkp)\r\n{\r\nstruct scsi_device *sdp = sdkp->device;\r\nstruct gendisk *disk = sdkp->disk;\r\nu8 type = sdkp->protection_type;\r\nint dif, dix;\r\ndif = scsi_host_dif_capable(sdp->host, type);\r\ndix = scsi_host_dix_capable(sdp->host, type);\r\nif (!dix && scsi_host_dix_capable(sdp->host, 0)) {\r\ndif = 0; dix = 1;\r\n}\r\nif (!dix)\r\nreturn;\r\nif (scsi_host_get_guard(sdkp->device->host) & SHOST_DIX_GUARD_IP) {\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\nblk_integrity_register(disk, &t10_pi_type3_ip);\r\nelse\r\nblk_integrity_register(disk, &t10_pi_type1_ip);\r\ndisk->integrity->flags |= BLK_INTEGRITY_IP_CHECKSUM;\r\n} else\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\nblk_integrity_register(disk, &t10_pi_type3_crc);\r\nelse\r\nblk_integrity_register(disk, &t10_pi_type1_crc);\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Enabling DIX %s protection\n", disk->integrity->name);\r\nif (dif && type) {\r\ndisk->integrity->flags |= BLK_INTEGRITY_DEVICE_CAPABLE;\r\nif (!sdkp->ATO)\r\nreturn;\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\ndisk->integrity->tag_size = sizeof(u16) + sizeof(u32);\r\nelse\r\ndisk->integrity->tag_size = sizeof(u16);\r\nsd_printk(KERN_NOTICE, sdkp, "DIF application tag size %u\n",\r\ndisk->integrity->tag_size);\r\n}\r\n}\r\nvoid sd_dif_prepare(struct scsi_cmnd *scmd)\r\n{\r\nconst int tuple_sz = sizeof(struct t10_pi_tuple);\r\nstruct bio *bio;\r\nstruct scsi_disk *sdkp;\r\nstruct t10_pi_tuple *pi;\r\nu32 phys, virt;\r\nsdkp = scsi_disk(scmd->request->rq_disk);\r\nif (sdkp->protection_type == SD_DIF_TYPE3_PROTECTION)\r\nreturn;\r\nphys = scsi_prot_ref_tag(scmd);\r\n__rq_for_each_bio(bio, scmd->request) {\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct bio_vec iv;\r\nstruct bvec_iter iter;\r\nunsigned int j;\r\nif (bip->bip_flags & BIP_MAPPED_INTEGRITY)\r\nbreak;\r\nvirt = bip_get_seed(bip) & 0xffffffff;\r\nbip_for_each_vec(iv, bip, iter) {\r\npi = kmap_atomic(iv.bv_page) + iv.bv_offset;\r\nfor (j = 0; j < iv.bv_len; j += tuple_sz, pi++) {\r\nif (be32_to_cpu(pi->ref_tag) == virt)\r\npi->ref_tag = cpu_to_be32(phys);\r\nvirt++;\r\nphys++;\r\n}\r\nkunmap_atomic(pi);\r\n}\r\nbip->bip_flags |= BIP_MAPPED_INTEGRITY;\r\n}\r\n}\r\nvoid sd_dif_complete(struct scsi_cmnd *scmd, unsigned int good_bytes)\r\n{\r\nconst int tuple_sz = sizeof(struct t10_pi_tuple);\r\nstruct scsi_disk *sdkp;\r\nstruct bio *bio;\r\nstruct t10_pi_tuple *pi;\r\nunsigned int j, intervals;\r\nu32 phys, virt;\r\nsdkp = scsi_disk(scmd->request->rq_disk);\r\nif (sdkp->protection_type == SD_DIF_TYPE3_PROTECTION || good_bytes == 0)\r\nreturn;\r\nintervals = good_bytes / scsi_prot_interval(scmd);\r\nphys = scsi_prot_ref_tag(scmd);\r\n__rq_for_each_bio(bio, scmd->request) {\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct bio_vec iv;\r\nstruct bvec_iter iter;\r\nvirt = bip_get_seed(bip) & 0xffffffff;\r\nbip_for_each_vec(iv, bip, iter) {\r\npi = kmap_atomic(iv.bv_page) + iv.bv_offset;\r\nfor (j = 0; j < iv.bv_len; j += tuple_sz, pi++) {\r\nif (intervals == 0) {\r\nkunmap_atomic(pi);\r\nreturn;\r\n}\r\nif (be32_to_cpu(pi->ref_tag) == phys)\r\npi->ref_tag = cpu_to_be32(virt);\r\nvirt++;\r\nphys++;\r\nintervals--;\r\n}\r\nkunmap_atomic(pi);\r\n}\r\n}\r\n}
