u8 ap_is_valid_header(struct acpi_table_header *table)\r\n{\r\nif (!ACPI_VALIDATE_RSDP_SIG(table->signature)) {\r\nif (!acpi_ut_valid_acpi_name(table->signature)) {\r\nacpi_log_error("Table signature (0x%8.8X) is invalid\n",\r\n*(u32 *)table->signature);\r\nreturn (FALSE);\r\n}\r\nif (table->length < sizeof(struct acpi_table_header)) {\r\nacpi_log_error("Table length (0x%8.8X) is invalid\n",\r\ntable->length);\r\nreturn (FALSE);\r\n}\r\n}\r\nreturn (TRUE);\r\n}\r\nu8 ap_is_valid_checksum(struct acpi_table_header *table)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_rsdp *rsdp;\r\nif (ACPI_VALIDATE_RSDP_SIG(table->signature)) {\r\nrsdp = ACPI_CAST_PTR(struct acpi_table_rsdp, table);\r\nstatus = acpi_tb_validate_rsdp(rsdp);\r\n} else {\r\nstatus = acpi_tb_verify_checksum(table, table->length);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nacpi_log_error("%4.4s: Warning: wrong checksum in table\n",\r\ntable->signature);\r\n}\r\nreturn (AE_OK);\r\n}\r\nu32 ap_get_table_length(struct acpi_table_header *table)\r\n{\r\nstruct acpi_table_rsdp *rsdp;\r\nif (!ap_is_valid_header(table)) {\r\nreturn (0);\r\n}\r\nif (ACPI_VALIDATE_RSDP_SIG(table->signature)) {\r\nrsdp = ACPI_CAST_PTR(struct acpi_table_rsdp, table);\r\nreturn (acpi_tb_get_rsdp_length(rsdp));\r\n}\r\nreturn (table->length);\r\n}\r\nstatic int\r\nap_dump_table_buffer(struct acpi_table_header *table,\r\nu32 instance, acpi_physical_address address)\r\n{\r\nu32 table_length;\r\ntable_length = ap_get_table_length(table);\r\nif (gbl_summary_mode) {\r\nacpi_tb_print_table_header(address, table);\r\nreturn (0);\r\n}\r\nif (gbl_binary_mode) {\r\nreturn (ap_write_to_binary_file(table, instance));\r\n}\r\nacpi_ut_file_printf(gbl_output_file, "%4.4s @ 0x%8.8X%8.8X\n",\r\ntable->signature, ACPI_FORMAT_UINT64(address));\r\nacpi_ut_dump_buffer_to_file(gbl_output_file,\r\nACPI_CAST_PTR(u8, table), table_length,\r\nDB_BYTE_DISPLAY, 0);\r\nacpi_ut_file_printf(gbl_output_file, "\n");\r\nreturn (0);\r\n}\r\nint ap_dump_all_tables(void)\r\n{\r\nstruct acpi_table_header *table;\r\nu32 instance = 0;\r\nacpi_physical_address address;\r\nacpi_status status;\r\nint table_status;\r\nu32 i;\r\nfor (i = 0; i < AP_MAX_ACPI_FILES; i++) {\r\nstatus =\r\nacpi_os_get_table_by_index(i, &table, &instance, &address);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_LIMIT) {\r\nreturn (0);\r\n} else if (i == 0) {\r\nacpi_log_error\r\n("Could not get ACPI tables, %s\n",\r\nacpi_format_exception(status));\r\nreturn (-1);\r\n} else {\r\nacpi_log_error\r\n("Could not get ACPI table at index %u, %s\n",\r\ni, acpi_format_exception(status));\r\ncontinue;\r\n}\r\n}\r\ntable_status = ap_dump_table_buffer(table, instance, address);\r\nACPI_FREE(table);\r\nif (table_status) {\r\nbreak;\r\n}\r\n}\r\nreturn (-1);\r\n}\r\nint ap_dump_table_by_address(char *ascii_address)\r\n{\r\nacpi_physical_address address;\r\nstruct acpi_table_header *table;\r\nacpi_status status;\r\nint table_status;\r\nu64 long_address;\r\nstatus = acpi_ut_strtoul64(ascii_address, 0, &long_address);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_log_error("%s: Could not convert to a physical address\n",\r\nascii_address);\r\nreturn (-1);\r\n}\r\naddress = (acpi_physical_address) long_address;\r\nstatus = acpi_os_get_table_by_address(address, &table);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_log_error("Could not get table at 0x%8.8X%8.8X, %s\n",\r\nACPI_FORMAT_UINT64(address),\r\nacpi_format_exception(status));\r\nreturn (-1);\r\n}\r\ntable_status = ap_dump_table_buffer(table, 0, address);\r\nACPI_FREE(table);\r\nreturn (table_status);\r\n}\r\nint ap_dump_table_by_name(char *signature)\r\n{\r\nchar local_signature[ACPI_NAME_SIZE + 1];\r\nu32 instance;\r\nstruct acpi_table_header *table;\r\nacpi_physical_address address;\r\nacpi_status status;\r\nint table_status;\r\nif (strlen(signature) != ACPI_NAME_SIZE) {\r\nacpi_log_error\r\n("Invalid table signature [%s]: must be exactly 4 characters\n",\r\nsignature);\r\nreturn (-1);\r\n}\r\nstrcpy(local_signature, signature);\r\nacpi_ut_strupr(local_signature);\r\nif (ACPI_COMPARE_NAME(local_signature, "FADT")) {\r\nstrcpy(local_signature, ACPI_SIG_FADT);\r\n} else if (ACPI_COMPARE_NAME(local_signature, "MADT")) {\r\nstrcpy(local_signature, ACPI_SIG_MADT);\r\n}\r\nfor (instance = 0; instance < AP_MAX_ACPI_FILES; instance++) {\r\nstatus = acpi_os_get_table_by_name(local_signature, instance,\r\n&table, &address);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_LIMIT) {\r\nreturn (0);\r\n}\r\nacpi_log_error\r\n("Could not get ACPI table with signature [%s], %s\n",\r\nlocal_signature, acpi_format_exception(status));\r\nreturn (-1);\r\n}\r\ntable_status = ap_dump_table_buffer(table, instance, address);\r\nACPI_FREE(table);\r\nif (table_status) {\r\nbreak;\r\n}\r\n}\r\nreturn (-1);\r\n}\r\nint ap_dump_table_from_file(char *pathname)\r\n{\r\nstruct acpi_table_header *table;\r\nu32 file_size = 0;\r\nint table_status = -1;\r\ntable = ap_get_table_from_file(pathname, &file_size);\r\nif (!table) {\r\nreturn (-1);\r\n}\r\nif (table->length > file_size) {\r\nacpi_log_error\r\n("Table length (0x%X) is too large for input file (0x%X) %s\n",\r\ntable->length, file_size, pathname);\r\ngoto exit;\r\n}\r\nif (gbl_verbose_mode) {\r\nacpi_log_error\r\n("Input file: %s contains table [%4.4s], 0x%X (%u) bytes\n",\r\npathname, table->signature, file_size, file_size);\r\n}\r\ntable_status = ap_dump_table_buffer(table, 0, 0);\r\nexit:\r\nACPI_FREE(table);\r\nreturn (table_status);\r\n}
