void soc_pcmcia_debug(struct soc_pcmcia_socket *skt, const char *func,\r\nint lvl, const char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nif (pc_debug > lvl) {\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nprintk(KERN_DEBUG "skt%u: %s: %pV", skt->nr, func, &vaf);\r\nva_end(args);\r\n}\r\n}\r\nstatic unsigned short\r\ncalc_speed(unsigned short *spds, int num, unsigned short dflt)\r\n{\r\nunsigned short speed = 0;\r\nint i;\r\nfor (i = 0; i < num; i++)\r\nif (speed < spds[i])\r\nspeed = spds[i];\r\nif (speed == 0)\r\nspeed = dflt;\r\nreturn speed;\r\n}\r\nvoid soc_common_pcmcia_get_timing(struct soc_pcmcia_socket *skt,\r\nstruct soc_pcmcia_timing *timing)\r\n{\r\ntiming->io =\r\ncalc_speed(skt->spd_io, MAX_IO_WIN, SOC_PCMCIA_IO_ACCESS);\r\ntiming->mem =\r\ncalc_speed(skt->spd_mem, MAX_WIN, SOC_PCMCIA_3V_MEM_ACCESS);\r\ntiming->attr =\r\ncalc_speed(skt->spd_attr, MAX_WIN, SOC_PCMCIA_3V_MEM_ACCESS);\r\n}\r\nstatic void __soc_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt,\r\nunsigned int nr)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nr; i++) {\r\nif (skt->stat[i].irq)\r\nfree_irq(skt->stat[i].irq, skt);\r\nif (gpio_is_valid(skt->stat[i].gpio))\r\ngpio_free(skt->stat[i].gpio);\r\n}\r\nif (skt->ops->hw_shutdown)\r\nskt->ops->hw_shutdown(skt);\r\nclk_disable_unprepare(skt->clk);\r\n}\r\nstatic void soc_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)\r\n{\r\n__soc_pcmcia_hw_shutdown(skt, ARRAY_SIZE(skt->stat));\r\n}\r\nstatic int soc_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\r\n{\r\nint ret = 0, i;\r\nclk_prepare_enable(skt->clk);\r\nif (skt->ops->hw_init) {\r\nret = skt->ops->hw_init(skt);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(skt->stat); i++) {\r\nif (gpio_is_valid(skt->stat[i].gpio)) {\r\nint irq;\r\nret = gpio_request_one(skt->stat[i].gpio, GPIOF_IN,\r\nskt->stat[i].name);\r\nif (ret) {\r\n__soc_pcmcia_hw_shutdown(skt, i);\r\nreturn ret;\r\n}\r\nirq = gpio_to_irq(skt->stat[i].gpio);\r\nif (i == SOC_STAT_RDY)\r\nskt->socket.pci_irq = irq;\r\nelse\r\nskt->stat[i].irq = irq;\r\n}\r\nif (skt->stat[i].irq) {\r\nret = request_irq(skt->stat[i].irq,\r\nsoc_common_pcmcia_interrupt,\r\nIRQF_TRIGGER_NONE,\r\nskt->stat[i].name, skt);\r\nif (ret) {\r\nif (gpio_is_valid(skt->stat[i].gpio))\r\ngpio_free(skt->stat[i].gpio);\r\n__soc_pcmcia_hw_shutdown(skt, i);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void soc_pcmcia_hw_enable(struct soc_pcmcia_socket *skt)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\r\nif (skt->stat[i].irq) {\r\nirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_EDGE_BOTH);\r\n}\r\n}\r\nstatic void soc_pcmcia_hw_disable(struct soc_pcmcia_socket *skt)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\r\nif (skt->stat[i].irq)\r\nirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_NONE);\r\n}\r\nstatic unsigned int soc_common_pcmcia_skt_state(struct soc_pcmcia_socket *skt)\r\n{\r\nstruct pcmcia_state state;\r\nunsigned int stat;\r\nmemset(&state, 0, sizeof(struct pcmcia_state));\r\nstate.bvd1 = 1;\r\nstate.bvd2 = 1;\r\nif (gpio_is_valid(skt->stat[SOC_STAT_CD].gpio))\r\nstate.detect = !gpio_get_value(skt->stat[SOC_STAT_CD].gpio);\r\nif (gpio_is_valid(skt->stat[SOC_STAT_RDY].gpio))\r\nstate.ready = !!gpio_get_value(skt->stat[SOC_STAT_RDY].gpio);\r\nif (gpio_is_valid(skt->stat[SOC_STAT_BVD1].gpio))\r\nstate.bvd1 = !!gpio_get_value(skt->stat[SOC_STAT_BVD1].gpio);\r\nif (gpio_is_valid(skt->stat[SOC_STAT_BVD2].gpio))\r\nstate.bvd2 = !!gpio_get_value(skt->stat[SOC_STAT_BVD2].gpio);\r\nskt->ops->socket_state(skt, &state);\r\nstat = state.detect ? SS_DETECT : 0;\r\nstat |= state.ready ? SS_READY : 0;\r\nstat |= state.wrprot ? SS_WRPROT : 0;\r\nstat |= state.vs_3v ? SS_3VCARD : 0;\r\nstat |= state.vs_Xv ? SS_XVCARD : 0;\r\nstat |= skt->cs_state.Vcc ? SS_POWERON : 0;\r\nif (skt->cs_state.flags & SS_IOCARD)\r\nstat |= state.bvd1 ? SS_STSCHG : 0;\r\nelse {\r\nif (state.bvd1 == 0)\r\nstat |= SS_BATDEAD;\r\nelse if (state.bvd2 == 0)\r\nstat |= SS_BATWARN;\r\n}\r\nreturn stat;\r\n}\r\nstatic int soc_common_pcmcia_config_skt(\r\nstruct soc_pcmcia_socket *skt, socket_state_t *state)\r\n{\r\nint ret;\r\nret = skt->ops->configure_socket(skt, state);\r\nif (ret == 0) {\r\nif (skt->irq_state != 1 && state->io_irq) {\r\nskt->irq_state = 1;\r\nirq_set_irq_type(skt->socket.pci_irq,\r\nIRQ_TYPE_EDGE_FALLING);\r\n} else if (skt->irq_state == 1 && state->io_irq == 0) {\r\nskt->irq_state = 0;\r\nirq_set_irq_type(skt->socket.pci_irq, IRQ_TYPE_NONE);\r\n}\r\nskt->cs_state = *state;\r\n}\r\nif (ret < 0)\r\nprintk(KERN_ERR "soc_common_pcmcia: unable to configure "\r\n"socket %d\n", skt->nr);\r\nreturn ret;\r\n}\r\nstatic int soc_common_pcmcia_sock_init(struct pcmcia_socket *sock)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\ndebug(skt, 2, "initializing socket\n");\r\nif (skt->ops->socket_init)\r\nskt->ops->socket_init(skt);\r\nsoc_pcmcia_hw_enable(skt);\r\nreturn 0;\r\n}\r\nstatic int soc_common_pcmcia_suspend(struct pcmcia_socket *sock)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\ndebug(skt, 2, "suspending socket\n");\r\nsoc_pcmcia_hw_disable(skt);\r\nif (skt->ops->socket_suspend)\r\nskt->ops->socket_suspend(skt);\r\nreturn 0;\r\n}\r\nstatic void soc_common_check_status(struct soc_pcmcia_socket *skt)\r\n{\r\nunsigned int events;\r\ndebug(skt, 4, "entering PCMCIA monitoring thread\n");\r\ndo {\r\nunsigned int status;\r\nunsigned long flags;\r\nstatus = soc_common_pcmcia_skt_state(skt);\r\nspin_lock_irqsave(&status_lock, flags);\r\nevents = (status ^ skt->status) & skt->cs_state.csc_mask;\r\nskt->status = status;\r\nspin_unlock_irqrestore(&status_lock, flags);\r\ndebug(skt, 4, "events: %s%s%s%s%s%s\n",\r\nevents == 0 ? "<NONE>" : "",\r\nevents & SS_DETECT ? "DETECT " : "",\r\nevents & SS_READY ? "READY " : "",\r\nevents & SS_BATDEAD ? "BATDEAD " : "",\r\nevents & SS_BATWARN ? "BATWARN " : "",\r\nevents & SS_STSCHG ? "STSCHG " : "");\r\nif (events)\r\npcmcia_parse_events(&skt->socket, events);\r\n} while (events);\r\n}\r\nstatic void soc_common_pcmcia_poll_event(unsigned long dummy)\r\n{\r\nstruct soc_pcmcia_socket *skt = (struct soc_pcmcia_socket *)dummy;\r\ndebug(skt, 4, "polling for events\n");\r\nmod_timer(&skt->poll_timer, jiffies + SOC_PCMCIA_POLL_PERIOD);\r\nsoc_common_check_status(skt);\r\n}\r\nstatic irqreturn_t soc_common_pcmcia_interrupt(int irq, void *dev)\r\n{\r\nstruct soc_pcmcia_socket *skt = dev;\r\ndebug(skt, 3, "servicing IRQ %d\n", irq);\r\nsoc_common_check_status(skt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsoc_common_pcmcia_get_status(struct pcmcia_socket *sock, unsigned int *status)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\nskt->status = soc_common_pcmcia_skt_state(skt);\r\n*status = skt->status;\r\nreturn 0;\r\n}\r\nstatic int soc_common_pcmcia_set_socket(\r\nstruct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\ndebug(skt, 2, "mask: %s%s%s%s%s%s flags: %s%s%s%s%s%s Vcc %d Vpp %d irq %d\n",\r\n(state->csc_mask == 0) ? "<NONE> " : "",\r\n(state->csc_mask & SS_DETECT) ? "DETECT " : "",\r\n(state->csc_mask & SS_READY) ? "READY " : "",\r\n(state->csc_mask & SS_BATDEAD) ? "BATDEAD " : "",\r\n(state->csc_mask & SS_BATWARN) ? "BATWARN " : "",\r\n(state->csc_mask & SS_STSCHG) ? "STSCHG " : "",\r\n(state->flags == 0) ? "<NONE> " : "",\r\n(state->flags & SS_PWR_AUTO) ? "PWR_AUTO " : "",\r\n(state->flags & SS_IOCARD) ? "IOCARD " : "",\r\n(state->flags & SS_RESET) ? "RESET " : "",\r\n(state->flags & SS_SPKR_ENA) ? "SPKR_ENA " : "",\r\n(state->flags & SS_OUTPUT_ENA) ? "OUTPUT_ENA " : "",\r\nstate->Vcc, state->Vpp, state->io_irq);\r\nreturn soc_common_pcmcia_config_skt(skt, state);\r\n}\r\nstatic int soc_common_pcmcia_set_io_map(\r\nstruct pcmcia_socket *sock, struct pccard_io_map *map)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\nunsigned short speed = map->speed;\r\ndebug(skt, 2, "map %u speed %u start 0x%08llx stop 0x%08llx\n",\r\nmap->map, map->speed, (unsigned long long)map->start,\r\n(unsigned long long)map->stop);\r\ndebug(skt, 2, "flags: %s%s%s%s%s%s%s%s\n",\r\n(map->flags == 0) ? "<NONE>" : "",\r\n(map->flags & MAP_ACTIVE) ? "ACTIVE " : "",\r\n(map->flags & MAP_16BIT) ? "16BIT " : "",\r\n(map->flags & MAP_AUTOSZ) ? "AUTOSZ " : "",\r\n(map->flags & MAP_0WS) ? "0WS " : "",\r\n(map->flags & MAP_WRPROT) ? "WRPROT " : "",\r\n(map->flags & MAP_USE_WAIT) ? "USE_WAIT " : "",\r\n(map->flags & MAP_PREFETCH) ? "PREFETCH " : "");\r\nif (map->map >= MAX_IO_WIN) {\r\nprintk(KERN_ERR "%s(): map (%d) out of range\n", __func__,\r\nmap->map);\r\nreturn -1;\r\n}\r\nif (map->flags & MAP_ACTIVE) {\r\nif (speed == 0)\r\nspeed = SOC_PCMCIA_IO_ACCESS;\r\n} else {\r\nspeed = 0;\r\n}\r\nskt->spd_io[map->map] = speed;\r\nskt->ops->set_timing(skt);\r\nif (map->stop == 1)\r\nmap->stop = PAGE_SIZE-1;\r\nmap->stop -= map->start;\r\nmap->stop += skt->socket.io_offset;\r\nmap->start = skt->socket.io_offset;\r\nreturn 0;\r\n}\r\nstatic int soc_common_pcmcia_set_mem_map(\r\nstruct pcmcia_socket *sock, struct pccard_mem_map *map)\r\n{\r\nstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\r\nstruct resource *res;\r\nunsigned short speed = map->speed;\r\ndebug(skt, 2, "map %u speed %u card_start %08x\n",\r\nmap->map, map->speed, map->card_start);\r\ndebug(skt, 2, "flags: %s%s%s%s%s%s%s%s\n",\r\n(map->flags == 0) ? "<NONE>" : "",\r\n(map->flags & MAP_ACTIVE) ? "ACTIVE " : "",\r\n(map->flags & MAP_16BIT) ? "16BIT " : "",\r\n(map->flags & MAP_AUTOSZ) ? "AUTOSZ " : "",\r\n(map->flags & MAP_0WS) ? "0WS " : "",\r\n(map->flags & MAP_WRPROT) ? "WRPROT " : "",\r\n(map->flags & MAP_ATTRIB) ? "ATTRIB " : "",\r\n(map->flags & MAP_USE_WAIT) ? "USE_WAIT " : "");\r\nif (map->map >= MAX_WIN)\r\nreturn -EINVAL;\r\nif (map->flags & MAP_ACTIVE) {\r\nif (speed == 0)\r\nspeed = 300;\r\n} else {\r\nspeed = 0;\r\n}\r\nif (map->flags & MAP_ATTRIB) {\r\nres = &skt->res_attr;\r\nskt->spd_attr[map->map] = speed;\r\nskt->spd_mem[map->map] = 0;\r\n} else {\r\nres = &skt->res_mem;\r\nskt->spd_attr[map->map] = 0;\r\nskt->spd_mem[map->map] = speed;\r\n}\r\nskt->ops->set_timing(skt);\r\nmap->static_start = res->start + map->card_start;\r\nreturn 0;\r\n}\r\nstatic void dump_bits(char **p, const char *prefix,\r\nunsigned int val, struct bittbl *bits, int sz)\r\n{\r\nchar *b = *p;\r\nint i;\r\nb += sprintf(b, "%-9s:", prefix);\r\nfor (i = 0; i < sz; i++)\r\nif (val & bits[i].mask)\r\nb += sprintf(b, " %s", bits[i].name);\r\n*b++ = '\n';\r\n*p = b;\r\n}\r\nstatic ssize_t show_status(\r\nstruct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct soc_pcmcia_socket *skt =\r\ncontainer_of(dev, struct soc_pcmcia_socket, socket.dev);\r\nchar *p = buf;\r\np += sprintf(p, "slot : %d\n", skt->nr);\r\ndump_bits(&p, "status", skt->status,\r\nstatus_bits, ARRAY_SIZE(status_bits));\r\ndump_bits(&p, "csc_mask", skt->cs_state.csc_mask,\r\nstatus_bits, ARRAY_SIZE(status_bits));\r\ndump_bits(&p, "cs_flags", skt->cs_state.flags,\r\nconf_bits, ARRAY_SIZE(conf_bits));\r\np += sprintf(p, "Vcc : %d\n", skt->cs_state.Vcc);\r\np += sprintf(p, "Vpp : %d\n", skt->cs_state.Vpp);\r\np += sprintf(p, "IRQ : %d (%d)\n", skt->cs_state.io_irq,\r\nskt->socket.pci_irq);\r\nif (skt->ops->show_timing)\r\np += skt->ops->show_timing(skt, p);\r\nreturn p-buf;\r\n}\r\nstatic int\r\nsoc_pcmcia_notifier(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct soc_pcmcia_socket *skt;\r\nstruct cpufreq_freqs *freqs = data;\r\nint ret = 0;\r\nmutex_lock(&soc_pcmcia_sockets_lock);\r\nlist_for_each_entry(skt, &soc_pcmcia_sockets, node)\r\nif (skt->ops->frequency_change)\r\nret += skt->ops->frequency_change(skt, val, freqs);\r\nmutex_unlock(&soc_pcmcia_sockets_lock);\r\nreturn ret;\r\n}\r\nstatic int soc_pcmcia_cpufreq_register(void)\r\n{\r\nint ret;\r\nret = cpufreq_register_notifier(&soc_pcmcia_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (ret < 0)\r\nprintk(KERN_ERR "Unable to register CPU frequency change "\r\n"notifier for PCMCIA (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void soc_pcmcia_cpufreq_unregister(void)\r\n{\r\ncpufreq_unregister_notifier(&soc_pcmcia_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nvoid soc_pcmcia_init_one(struct soc_pcmcia_socket *skt,\r\nstruct pcmcia_low_level *ops, struct device *dev)\r\n{\r\nint i;\r\nskt->ops = ops;\r\nskt->socket.owner = ops->owner;\r\nskt->socket.dev.parent = dev;\r\nskt->socket.pci_irq = NO_IRQ;\r\nfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\r\nskt->stat[i].gpio = -EINVAL;\r\n}\r\nvoid soc_pcmcia_remove_one(struct soc_pcmcia_socket *skt)\r\n{\r\nmutex_lock(&soc_pcmcia_sockets_lock);\r\ndel_timer_sync(&skt->poll_timer);\r\npcmcia_unregister_socket(&skt->socket);\r\nsoc_pcmcia_hw_shutdown(skt);\r\nsoc_common_pcmcia_config_skt(skt, &dead_socket);\r\nlist_del(&skt->node);\r\nmutex_unlock(&soc_pcmcia_sockets_lock);\r\niounmap(skt->virt_io);\r\nskt->virt_io = NULL;\r\nrelease_resource(&skt->res_attr);\r\nrelease_resource(&skt->res_mem);\r\nrelease_resource(&skt->res_io);\r\nrelease_resource(&skt->res_skt);\r\n}\r\nint soc_pcmcia_add_one(struct soc_pcmcia_socket *skt)\r\n{\r\nint ret;\r\nsetup_timer(&skt->poll_timer, soc_common_pcmcia_poll_event,\r\n(unsigned long)skt);\r\nskt->poll_timer.expires = jiffies + SOC_PCMCIA_POLL_PERIOD;\r\nret = request_resource(&iomem_resource, &skt->res_skt);\r\nif (ret)\r\ngoto out_err_1;\r\nret = request_resource(&skt->res_skt, &skt->res_io);\r\nif (ret)\r\ngoto out_err_2;\r\nret = request_resource(&skt->res_skt, &skt->res_mem);\r\nif (ret)\r\ngoto out_err_3;\r\nret = request_resource(&skt->res_skt, &skt->res_attr);\r\nif (ret)\r\ngoto out_err_4;\r\nskt->virt_io = ioremap(skt->res_io.start, 0x10000);\r\nif (skt->virt_io == NULL) {\r\nret = -ENOMEM;\r\ngoto out_err_5;\r\n}\r\nmutex_lock(&soc_pcmcia_sockets_lock);\r\nlist_add(&skt->node, &soc_pcmcia_sockets);\r\nskt->ops->set_timing(skt);\r\nret = soc_pcmcia_hw_init(skt);\r\nif (ret)\r\ngoto out_err_6;\r\nskt->socket.ops = &soc_common_pcmcia_operations;\r\nskt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;\r\nskt->socket.resource_ops = &pccard_static_ops;\r\nskt->socket.irq_mask = 0;\r\nskt->socket.map_size = PAGE_SIZE;\r\nskt->socket.io_offset = (unsigned long)skt->virt_io;\r\nskt->status = soc_common_pcmcia_skt_state(skt);\r\nret = pcmcia_register_socket(&skt->socket);\r\nif (ret)\r\ngoto out_err_7;\r\nadd_timer(&skt->poll_timer);\r\nmutex_unlock(&soc_pcmcia_sockets_lock);\r\nret = device_create_file(&skt->socket.dev, &dev_attr_status);\r\nif (ret)\r\ngoto out_err_8;\r\nreturn ret;\r\nout_err_8:\r\nmutex_lock(&soc_pcmcia_sockets_lock);\r\ndel_timer_sync(&skt->poll_timer);\r\npcmcia_unregister_socket(&skt->socket);\r\nout_err_7:\r\nsoc_pcmcia_hw_shutdown(skt);\r\nout_err_6:\r\nlist_del(&skt->node);\r\nmutex_unlock(&soc_pcmcia_sockets_lock);\r\niounmap(skt->virt_io);\r\nout_err_5:\r\nrelease_resource(&skt->res_attr);\r\nout_err_4:\r\nrelease_resource(&skt->res_mem);\r\nout_err_3:\r\nrelease_resource(&skt->res_io);\r\nout_err_2:\r\nrelease_resource(&skt->res_skt);\r\nout_err_1:\r\nreturn ret;\r\n}
