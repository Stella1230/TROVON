static int __hidpp_send_report(struct hid_device *hdev,\r\nstruct hidpp_report *hidpp_report)\r\n{\r\nint fields_count, ret;\r\nswitch (hidpp_report->report_id) {\r\ncase REPORT_ID_HIDPP_SHORT:\r\nfields_count = HIDPP_REPORT_SHORT_LENGTH;\r\nbreak;\r\ncase REPORT_ID_HIDPP_LONG:\r\nfields_count = HIDPP_REPORT_LONG_LENGTH;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nhidpp_report->device_index = 0xff;\r\nret = hid_hw_raw_request(hdev, hidpp_report->report_id,\r\n(u8 *)hidpp_report, fields_count, HID_OUTPUT_REPORT,\r\nHID_REQ_SET_REPORT);\r\nreturn ret == fields_count ? 0 : -1;\r\n}\r\nstatic int hidpp_send_message_sync(struct hidpp_device *hidpp,\r\nstruct hidpp_report *message,\r\nstruct hidpp_report *response)\r\n{\r\nint ret;\r\nmutex_lock(&hidpp->send_mutex);\r\nhidpp->send_receive_buf = response;\r\nhidpp->answer_available = false;\r\n*response = *message;\r\nret = __hidpp_send_report(hidpp->hid_dev, message);\r\nif (ret) {\r\ndbg_hid("__hidpp_send_report returned err: %d\n", ret);\r\nmemset(response, 0, sizeof(struct hidpp_report));\r\ngoto exit;\r\n}\r\nif (!wait_event_timeout(hidpp->wait, hidpp->answer_available,\r\n5*HZ)) {\r\ndbg_hid("%s:timeout waiting for response\n", __func__);\r\nmemset(response, 0, sizeof(struct hidpp_report));\r\nret = -ETIMEDOUT;\r\n}\r\nif (response->report_id == REPORT_ID_HIDPP_SHORT &&\r\nresponse->rap.sub_id == HIDPP_ERROR) {\r\nret = response->rap.params[1];\r\ndbg_hid("%s:got hidpp error %02X\n", __func__, ret);\r\ngoto exit;\r\n}\r\nif (response->report_id == REPORT_ID_HIDPP_LONG &&\r\nresponse->fap.feature_index == HIDPP20_ERROR) {\r\nret = response->fap.params[1];\r\ndbg_hid("%s:got hidpp 2.0 error %02X\n", __func__, ret);\r\ngoto exit;\r\n}\r\nexit:\r\nmutex_unlock(&hidpp->send_mutex);\r\nreturn ret;\r\n}\r\nstatic int hidpp_send_fap_command_sync(struct hidpp_device *hidpp,\r\nu8 feat_index, u8 funcindex_clientid, u8 *params, int param_count,\r\nstruct hidpp_report *response)\r\n{\r\nstruct hidpp_report *message;\r\nint ret;\r\nif (param_count > sizeof(message->fap.params))\r\nreturn -EINVAL;\r\nmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\r\nif (!message)\r\nreturn -ENOMEM;\r\nmessage->report_id = REPORT_ID_HIDPP_LONG;\r\nmessage->fap.feature_index = feat_index;\r\nmessage->fap.funcindex_clientid = funcindex_clientid;\r\nmemcpy(&message->fap.params, params, param_count);\r\nret = hidpp_send_message_sync(hidpp, message, response);\r\nkfree(message);\r\nreturn ret;\r\n}\r\nstatic int hidpp_send_rap_command_sync(struct hidpp_device *hidpp_dev,\r\nu8 report_id, u8 sub_id, u8 reg_address, u8 *params, int param_count,\r\nstruct hidpp_report *response)\r\n{\r\nstruct hidpp_report *message;\r\nint ret;\r\nif ((report_id != REPORT_ID_HIDPP_SHORT) &&\r\n(report_id != REPORT_ID_HIDPP_LONG))\r\nreturn -EINVAL;\r\nif (param_count > sizeof(message->rap.params))\r\nreturn -EINVAL;\r\nmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\r\nif (!message)\r\nreturn -ENOMEM;\r\nmessage->report_id = report_id;\r\nmessage->rap.sub_id = sub_id;\r\nmessage->rap.reg_address = reg_address;\r\nmemcpy(&message->rap.params, params, param_count);\r\nret = hidpp_send_message_sync(hidpp_dev, message, response);\r\nkfree(message);\r\nreturn ret;\r\n}\r\nstatic void delayed_work_cb(struct work_struct *work)\r\n{\r\nstruct hidpp_device *hidpp = container_of(work, struct hidpp_device,\r\nwork);\r\nhidpp_connect_event(hidpp);\r\n}\r\nstatic inline bool hidpp_match_answer(struct hidpp_report *question,\r\nstruct hidpp_report *answer)\r\n{\r\nreturn (answer->fap.feature_index == question->fap.feature_index) &&\r\n(answer->fap.funcindex_clientid == question->fap.funcindex_clientid);\r\n}\r\nstatic inline bool hidpp_match_error(struct hidpp_report *question,\r\nstruct hidpp_report *answer)\r\n{\r\nreturn ((answer->rap.sub_id == HIDPP_ERROR) ||\r\n(answer->fap.feature_index == HIDPP20_ERROR)) &&\r\n(answer->fap.funcindex_clientid == question->fap.feature_index) &&\r\n(answer->fap.params[0] == question->fap.funcindex_clientid);\r\n}\r\nstatic inline bool hidpp_report_is_connect_event(struct hidpp_report *report)\r\n{\r\nreturn (report->report_id == REPORT_ID_HIDPP_SHORT) &&\r\n(report->rap.sub_id == 0x41);\r\n}\r\nstatic void hidpp_prefix_name(char **name, int name_length)\r\n{\r\n#define PREFIX_LENGTH 9\r\nint new_length;\r\nchar *new_name;\r\nif (name_length > PREFIX_LENGTH &&\r\nstrncmp(*name, "Logitech ", PREFIX_LENGTH) == 0)\r\nreturn;\r\nnew_length = PREFIX_LENGTH + name_length;\r\nnew_name = kzalloc(new_length, GFP_KERNEL);\r\nif (!new_name)\r\nreturn;\r\nsnprintf(new_name, new_length, "Logitech %s", *name);\r\nkfree(*name);\r\n*name = new_name;\r\n}\r\nstatic char *hidpp_get_unifying_name(struct hidpp_device *hidpp_dev)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 params[1] = { DEVICE_NAME };\r\nchar *name;\r\nint len;\r\nret = hidpp_send_rap_command_sync(hidpp_dev,\r\nREPORT_ID_HIDPP_SHORT,\r\nHIDPP_GET_LONG_REGISTER,\r\nHIDPP_REG_PAIRING_INFORMATION,\r\nparams, 1, &response);\r\nif (ret)\r\nreturn NULL;\r\nlen = response.rap.params[1];\r\nif (2 + len > sizeof(response.rap.params))\r\nreturn NULL;\r\nname = kzalloc(len + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn NULL;\r\nmemcpy(name, &response.rap.params[2], len);\r\nhidpp_prefix_name(&name, len + 1);\r\nreturn name;\r\n}\r\nstatic int hidpp_root_get_feature(struct hidpp_device *hidpp, u16 feature,\r\nu8 *feature_index, u8 *feature_type)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 params[2] = { feature >> 8, feature & 0x00FF };\r\nret = hidpp_send_fap_command_sync(hidpp,\r\nHIDPP_PAGE_ROOT_IDX,\r\nCMD_ROOT_GET_FEATURE,\r\nparams, 2, &response);\r\nif (ret)\r\nreturn ret;\r\n*feature_index = response.fap.params[0];\r\n*feature_type = response.fap.params[1];\r\nreturn ret;\r\n}\r\nstatic int hidpp_root_get_protocol_version(struct hidpp_device *hidpp)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nret = hidpp_send_fap_command_sync(hidpp,\r\nHIDPP_PAGE_ROOT_IDX,\r\nCMD_ROOT_GET_PROTOCOL_VERSION,\r\nNULL, 0, &response);\r\nif (ret == HIDPP_ERROR_INVALID_SUBID) {\r\nhidpp->protocol_major = 1;\r\nhidpp->protocol_minor = 0;\r\nreturn 0;\r\n}\r\nif (ret == HIDPP_ERROR_RESOURCE_ERROR)\r\nreturn -EIO;\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nhidpp->protocol_major = response.fap.params[0];\r\nhidpp->protocol_minor = response.fap.params[1];\r\nreturn ret;\r\n}\r\nstatic bool hidpp_is_connected(struct hidpp_device *hidpp)\r\n{\r\nint ret;\r\nret = hidpp_root_get_protocol_version(hidpp);\r\nif (!ret)\r\nhid_dbg(hidpp->hid_dev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\nreturn ret == 0;\r\n}\r\nstatic int hidpp_devicenametype_get_count(struct hidpp_device *hidpp,\r\nu8 feature_index, u8 *nameLength)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_GET_DEVICE_NAME_TYPE_GET_COUNT, NULL, 0, &response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\n*nameLength = response.fap.params[0];\r\nreturn ret;\r\n}\r\nstatic int hidpp_devicenametype_get_device_name(struct hidpp_device *hidpp,\r\nu8 feature_index, u8 char_index, char *device_name, int len_buf)\r\n{\r\nstruct hidpp_report response;\r\nint ret, i;\r\nint count;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_GET_DEVICE_NAME_TYPE_GET_DEVICE_NAME, &char_index, 1,\r\n&response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (response.report_id == REPORT_ID_HIDPP_LONG)\r\ncount = HIDPP_REPORT_LONG_LENGTH - 4;\r\nelse\r\ncount = HIDPP_REPORT_SHORT_LENGTH - 4;\r\nif (len_buf < count)\r\ncount = len_buf;\r\nfor (i = 0; i < count; i++)\r\ndevice_name[i] = response.fap.params[i];\r\nreturn count;\r\n}\r\nstatic char *hidpp_get_device_name(struct hidpp_device *hidpp)\r\n{\r\nu8 feature_type;\r\nu8 feature_index;\r\nu8 __name_length;\r\nchar *name;\r\nunsigned index = 0;\r\nint ret;\r\nret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_GET_DEVICE_NAME_TYPE,\r\n&feature_index, &feature_type);\r\nif (ret)\r\nreturn NULL;\r\nret = hidpp_devicenametype_get_count(hidpp, feature_index,\r\n&__name_length);\r\nif (ret)\r\nreturn NULL;\r\nname = kzalloc(__name_length + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn NULL;\r\nwhile (index < __name_length) {\r\nret = hidpp_devicenametype_get_device_name(hidpp,\r\nfeature_index, index, name + index,\r\n__name_length - index);\r\nif (ret <= 0) {\r\nkfree(name);\r\nreturn NULL;\r\n}\r\nindex += ret;\r\n}\r\nhidpp_prefix_name(&name, __name_length + 1);\r\nreturn name;\r\n}\r\nstatic int hidpp_touchpad_get_raw_info(struct hidpp_device *hidpp,\r\nu8 feature_index, struct hidpp_touchpad_raw_info *raw_info)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 *params = (u8 *)response.fap.params;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_TOUCHPAD_GET_RAW_INFO, NULL, 0, &response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nraw_info->x_size = get_unaligned_be16(&params[0]);\r\nraw_info->y_size = get_unaligned_be16(&params[2]);\r\nraw_info->z_range = params[4];\r\nraw_info->area_range = params[5];\r\nraw_info->maxcontacts = params[7];\r\nraw_info->origin = params[8];\r\nraw_info->res = get_unaligned_be16(&params[13]) * 2 / 51;\r\nreturn ret;\r\n}\r\nstatic int hidpp_touchpad_set_raw_report_state(struct hidpp_device *hidpp_dev,\r\nu8 feature_index, bool send_raw_reports,\r\nbool sensor_enhanced_settings)\r\n{\r\nstruct hidpp_report response;\r\nu8 params = send_raw_reports | (sensor_enhanced_settings << 2);\r\nreturn hidpp_send_fap_command_sync(hidpp_dev, feature_index,\r\nCMD_TOUCHPAD_SET_RAW_REPORT_STATE, &params, 1, &response);\r\n}\r\nstatic void hidpp_touchpad_touch_event(u8 *data,\r\nstruct hidpp_touchpad_raw_xy_finger *finger)\r\n{\r\nu8 x_m = data[0] << 2;\r\nu8 y_m = data[2] << 2;\r\nfinger->x = x_m << 6 | data[1];\r\nfinger->y = y_m << 6 | data[3];\r\nfinger->contact_type = data[0] >> 6;\r\nfinger->contact_status = data[2] >> 6;\r\nfinger->z = data[4];\r\nfinger->area = data[5];\r\nfinger->finger_id = data[6] >> 4;\r\n}\r\nstatic void hidpp_touchpad_raw_xy_event(struct hidpp_device *hidpp_dev,\r\nu8 *data, struct hidpp_touchpad_raw_xy *raw_xy)\r\n{\r\nmemset(raw_xy, 0, sizeof(struct hidpp_touchpad_raw_xy));\r\nraw_xy->end_of_frame = data[8] & 0x01;\r\nraw_xy->spurious_flag = (data[8] >> 1) & 0x01;\r\nraw_xy->finger_count = data[15] & 0x0f;\r\nraw_xy->button = (data[8] >> 2) & 0x01;\r\nif (raw_xy->finger_count) {\r\nhidpp_touchpad_touch_event(&data[2], &raw_xy->fingers[0]);\r\nhidpp_touchpad_touch_event(&data[9], &raw_xy->fingers[1]);\r\n}\r\n}\r\nstatic int wtp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nreturn -1;\r\n}\r\nstatic void wtp_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input_dev, bool origin_is_hid_core)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__clear_bit(EV_REL, input_dev->evbit);\r\n__clear_bit(EV_LED, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, wd->x_size, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_X, wd->resolution);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, wd->y_size, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_Y, wd->resolution);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 50, 0, 0);\r\ninput_set_capability(input_dev, EV_KEY, BTN_LEFT);\r\nif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS)\r\ninput_set_capability(input_dev, EV_KEY, BTN_RIGHT);\r\nelse\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\ninput_mt_init_slots(input_dev, wd->maxcontacts, INPUT_MT_POINTER |\r\nINPUT_MT_DROP_UNUSED);\r\nwd->input = input_dev;\r\n}\r\nstatic void wtp_touch_event(struct wtp_data *wd,\r\nstruct hidpp_touchpad_raw_xy_finger *touch_report)\r\n{\r\nint slot;\r\nif (!touch_report->finger_id || touch_report->contact_type)\r\nreturn;\r\nslot = input_mt_get_slot_by_key(wd->input, touch_report->finger_id);\r\ninput_mt_slot(wd->input, slot);\r\ninput_mt_report_slot_state(wd->input, MT_TOOL_FINGER,\r\ntouch_report->contact_status);\r\nif (touch_report->contact_status) {\r\ninput_event(wd->input, EV_ABS, ABS_MT_POSITION_X,\r\ntouch_report->x);\r\ninput_event(wd->input, EV_ABS, ABS_MT_POSITION_Y,\r\nwd->flip_y ? wd->y_size - touch_report->y :\r\ntouch_report->y);\r\ninput_event(wd->input, EV_ABS, ABS_MT_PRESSURE,\r\ntouch_report->area);\r\n}\r\n}\r\nstatic void wtp_send_raw_xy_event(struct hidpp_device *hidpp,\r\nstruct hidpp_touchpad_raw_xy *raw)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nwtp_touch_event(wd, &(raw->fingers[i]));\r\nif (raw->end_of_frame &&\r\n!(hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS))\r\ninput_event(wd->input, EV_KEY, BTN_LEFT, raw->button);\r\nif (raw->end_of_frame || raw->finger_count <= 2) {\r\ninput_mt_sync_frame(wd->input);\r\ninput_sync(wd->input);\r\n}\r\n}\r\nstatic int wtp_mouse_raw_xy_event(struct hidpp_device *hidpp, u8 *data)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nu8 c1_area = ((data[7] & 0xf) * (data[7] & 0xf) +\r\n(data[7] >> 4) * (data[7] >> 4)) / 2;\r\nu8 c2_area = ((data[13] & 0xf) * (data[13] & 0xf) +\r\n(data[13] >> 4) * (data[13] >> 4)) / 2;\r\nstruct hidpp_touchpad_raw_xy raw = {\r\n.timestamp = data[1],\r\n.fingers = {\r\n{\r\n.contact_type = 0,\r\n.contact_status = !!data[7],\r\n.x = get_unaligned_le16(&data[3]),\r\n.y = get_unaligned_le16(&data[5]),\r\n.z = c1_area,\r\n.area = c1_area,\r\n.finger_id = data[2],\r\n}, {\r\n.contact_type = 0,\r\n.contact_status = !!data[13],\r\n.x = get_unaligned_le16(&data[9]),\r\n.y = get_unaligned_le16(&data[11]),\r\n.z = c2_area,\r\n.area = c2_area,\r\n.finger_id = data[8],\r\n}\r\n},\r\n.finger_count = wd->maxcontacts,\r\n.spurious_flag = 0,\r\n.end_of_frame = (data[0] >> 7) == 0,\r\n.button = data[0] & 0x01,\r\n};\r\nwtp_send_raw_xy_event(hidpp, &raw);\r\nreturn 1;\r\n}\r\nstatic int wtp_raw_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd = hidpp->private_data;\r\nstruct hidpp_report *report = (struct hidpp_report *)data;\r\nstruct hidpp_touchpad_raw_xy raw;\r\nif (!wd || !wd->input)\r\nreturn 1;\r\nswitch (data[0]) {\r\ncase 0x02:\r\nif (size < 2) {\r\nhid_err(hdev, "Received HID report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS) {\r\ninput_event(wd->input, EV_KEY, BTN_LEFT,\r\n!!(data[1] & 0x01));\r\ninput_event(wd->input, EV_KEY, BTN_RIGHT,\r\n!!(data[1] & 0x02));\r\ninput_sync(wd->input);\r\nreturn 0;\r\n} else {\r\nif (size < 21)\r\nreturn 1;\r\nreturn wtp_mouse_raw_xy_event(hidpp, &data[7]);\r\n}\r\ncase REPORT_ID_HIDPP_LONG:\r\nif ((report->fap.feature_index != wd->mt_feature_index) ||\r\n(report->fap.funcindex_clientid != EVENT_TOUCHPAD_RAW_XY))\r\nreturn 1;\r\nhidpp_touchpad_raw_xy_event(hidpp, data + 4, &raw);\r\nwtp_send_raw_xy_event(hidpp, &raw);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wtp_get_config(struct hidpp_device *hidpp)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nstruct hidpp_touchpad_raw_info raw_info = {0};\r\nu8 feature_type;\r\nint ret;\r\nret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_TOUCHPAD_RAW_XY,\r\n&wd->mt_feature_index, &feature_type);\r\nif (ret)\r\nreturn ret;\r\nret = hidpp_touchpad_get_raw_info(hidpp, wd->mt_feature_index,\r\n&raw_info);\r\nif (ret)\r\nreturn ret;\r\nwd->x_size = raw_info.x_size;\r\nwd->y_size = raw_info.y_size;\r\nwd->maxcontacts = raw_info.maxcontacts;\r\nwd->flip_y = raw_info.origin == TOUCHPAD_RAW_XY_ORIGIN_LOWER_LEFT;\r\nwd->resolution = raw_info.res;\r\nif (!wd->resolution)\r\nwd->resolution = WTP_MANUAL_RESOLUTION;\r\nreturn 0;\r\n}\r\nstatic int wtp_allocate(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd;\r\nwd = devm_kzalloc(&hdev->dev, sizeof(struct wtp_data),\r\nGFP_KERNEL);\r\nif (!wd)\r\nreturn -ENOMEM;\r\nhidpp->private_data = wd;\r\nreturn 0;\r\n}\r\nstatic int wtp_connect(struct hid_device *hdev, bool connected)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd = hidpp->private_data;\r\nint ret;\r\nif (!connected)\r\nreturn 0;\r\nif (!wd->x_size) {\r\nret = wtp_get_config(hidpp);\r\nif (ret) {\r\nhid_err(hdev, "Can not get wtp config: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn hidpp_touchpad_set_raw_report_state(hidpp, wd->mt_feature_index,\r\ntrue, true);\r\n}\r\nstatic int m560_send_config_command(struct hid_device *hdev, bool connected)\r\n{\r\nstruct hidpp_report response;\r\nstruct hidpp_device *hidpp_dev;\r\nhidpp_dev = hid_get_drvdata(hdev);\r\nif (!connected)\r\nreturn -ENODEV;\r\nreturn hidpp_send_rap_command_sync(\r\nhidpp_dev,\r\nREPORT_ID_HIDPP_SHORT,\r\nM560_SUB_ID,\r\nM560_BUTTON_MODE_REGISTER,\r\n(u8 *)m560_config_parameter,\r\nsizeof(m560_config_parameter),\r\n&response\r\n);\r\n}\r\nstatic int m560_allocate(struct hid_device *hdev)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct m560_private_data *d;\r\nd = devm_kzalloc(&hdev->dev, sizeof(struct m560_private_data),\r\nGFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nhidpp->private_data = d;\r\nreturn 0;\r\n}\r\nstatic int m560_raw_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct m560_private_data *mydata = hidpp->private_data;\r\nif (!mydata || !mydata->input) {\r\nhid_err(hdev, "error in parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (size < 7) {\r\nhid_err(hdev, "error in report\n");\r\nreturn 0;\r\n}\r\nif (data[0] == REPORT_ID_HIDPP_LONG &&\r\ndata[2] == M560_SUB_ID && data[6] == 0x00) {\r\nswitch (data[5]) {\r\ncase 0xaf:\r\ninput_report_key(mydata->input, BTN_MIDDLE, 1);\r\nbreak;\r\ncase 0xb0:\r\ninput_report_key(mydata->input, BTN_FORWARD, 1);\r\nbreak;\r\ncase 0xae:\r\ninput_report_key(mydata->input, BTN_BACK, 1);\r\nbreak;\r\ncase 0x00:\r\ninput_report_key(mydata->input, BTN_BACK, 0);\r\ninput_report_key(mydata->input, BTN_FORWARD, 0);\r\ninput_report_key(mydata->input, BTN_MIDDLE, 0);\r\nbreak;\r\ndefault:\r\nhid_err(hdev, "error in report\n");\r\nreturn 0;\r\n}\r\ninput_sync(mydata->input);\r\n} else if (data[0] == 0x02) {\r\nint v;\r\ninput_report_key(mydata->input, BTN_LEFT,\r\n!!(data[1] & M560_MOUSE_BTN_LEFT));\r\ninput_report_key(mydata->input, BTN_RIGHT,\r\n!!(data[1] & M560_MOUSE_BTN_RIGHT));\r\nif (data[1] & M560_MOUSE_BTN_WHEEL_LEFT)\r\ninput_report_rel(mydata->input, REL_HWHEEL, -1);\r\nelse if (data[1] & M560_MOUSE_BTN_WHEEL_RIGHT)\r\ninput_report_rel(mydata->input, REL_HWHEEL, 1);\r\nv = hid_snto32(hid_field_extract(hdev, data+3, 0, 12), 12);\r\ninput_report_rel(mydata->input, REL_X, v);\r\nv = hid_snto32(hid_field_extract(hdev, data+3, 12, 12), 12);\r\ninput_report_rel(mydata->input, REL_Y, v);\r\nv = hid_snto32(data[6], 8);\r\ninput_report_rel(mydata->input, REL_WHEEL, v);\r\ninput_sync(mydata->input);\r\n}\r\nreturn 1;\r\n}\r\nstatic void m560_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input_dev, bool origin_is_hid_core)\r\n{\r\nstruct m560_private_data *mydata = hidpp->private_data;\r\nmydata->input = input_dev;\r\n__set_bit(EV_KEY, mydata->input->evbit);\r\n__set_bit(BTN_MIDDLE, mydata->input->keybit);\r\n__set_bit(BTN_RIGHT, mydata->input->keybit);\r\n__set_bit(BTN_LEFT, mydata->input->keybit);\r\n__set_bit(BTN_BACK, mydata->input->keybit);\r\n__set_bit(BTN_FORWARD, mydata->input->keybit);\r\n__set_bit(EV_REL, mydata->input->evbit);\r\n__set_bit(REL_X, mydata->input->relbit);\r\n__set_bit(REL_Y, mydata->input->relbit);\r\n__set_bit(REL_WHEEL, mydata->input->relbit);\r\n__set_bit(REL_HWHEEL, mydata->input->relbit);\r\n}\r\nstatic int m560_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nreturn -1;\r\n}\r\nstatic int hidpp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nreturn wtp_input_mapping(hdev, hi, field, usage, bit, max);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560 &&\r\nfield->application != HID_GD_MOUSE)\r\nreturn m560_input_mapping(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic void hidpp_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input, bool origin_is_hid_core)\r\n{\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nwtp_populate_input(hidpp, input, origin_is_hid_core);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\r\nm560_populate_input(hidpp, input, origin_is_hid_core);\r\n}\r\nstatic void hidpp_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct input_dev *input = hidinput->input;\r\nhidpp_populate_input(hidpp, input, true);\r\n}\r\nstatic int hidpp_raw_hidpp_event(struct hidpp_device *hidpp, u8 *data,\r\nint size)\r\n{\r\nstruct hidpp_report *question = hidpp->send_receive_buf;\r\nstruct hidpp_report *answer = hidpp->send_receive_buf;\r\nstruct hidpp_report *report = (struct hidpp_report *)data;\r\nif (unlikely(mutex_is_locked(&hidpp->send_mutex))) {\r\nif (hidpp_match_answer(question, report) ||\r\nhidpp_match_error(question, report)) {\r\n*answer = *report;\r\nhidpp->answer_available = true;\r\nwake_up(&hidpp->wait);\r\nreturn 1;\r\n}\r\n}\r\nif (unlikely(hidpp_report_is_connect_event(report))) {\r\natomic_set(&hidpp->connected,\r\n!(report->rap.params[0] & (1 << 6)));\r\nif ((hidpp->quirks & HIDPP_QUIRK_DELAYED_INIT) &&\r\n(schedule_work(&hidpp->work) == 0))\r\ndbg_hid("%s: connect event already queued\n", __func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hidpp_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nint ret = 0;\r\nswitch (data[0]) {\r\ncase REPORT_ID_HIDPP_LONG:\r\nif (size != HIDPP_REPORT_LONG_LENGTH) {\r\nhid_err(hdev, "received hid++ report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nret = hidpp_raw_hidpp_event(hidpp, data, size);\r\nbreak;\r\ncase REPORT_ID_HIDPP_SHORT:\r\nif (size != HIDPP_REPORT_SHORT_LENGTH) {\r\nhid_err(hdev, "received hid++ report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nret = hidpp_raw_hidpp_event(hidpp, data, size);\r\nbreak;\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nreturn wtp_raw_event(hdev, data, size);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\r\nreturn m560_raw_event(hdev, data, size);\r\nreturn 0;\r\n}\r\nstatic void hidpp_overwrite_name(struct hid_device *hdev, bool use_unifying)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nchar *name;\r\nif (use_unifying)\r\nname = hidpp_get_unifying_name(hidpp);\r\nelse\r\nname = hidpp_get_device_name(hidpp);\r\nif (!name)\r\nhid_err(hdev, "unable to retrieve the name of the device");\r\nelse\r\nsnprintf(hdev->name, sizeof(hdev->name), "%s", name);\r\nkfree(name);\r\n}\r\nstatic int hidpp_input_open(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nreturn hid_hw_open(hid);\r\n}\r\nstatic void hidpp_input_close(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nhid_hw_close(hid);\r\n}\r\nstatic struct input_dev *hidpp_allocate_input(struct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev = devm_input_allocate_device(&hdev->dev);\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (!input_dev)\r\nreturn NULL;\r\ninput_set_drvdata(input_dev, hdev);\r\ninput_dev->open = hidpp_input_open;\r\ninput_dev->close = hidpp_input_close;\r\ninput_dev->name = hidpp->name;\r\ninput_dev->phys = hdev->phys;\r\ninput_dev->uniq = hdev->uniq;\r\ninput_dev->id.bustype = hdev->bus;\r\ninput_dev->id.vendor = hdev->vendor;\r\ninput_dev->id.product = hdev->product;\r\ninput_dev->id.version = hdev->version;\r\ninput_dev->dev.parent = &hdev->dev;\r\nreturn input_dev;\r\n}\r\nstatic void hidpp_connect_event(struct hidpp_device *hidpp)\r\n{\r\nstruct hid_device *hdev = hidpp->hid_dev;\r\nint ret = 0;\r\nbool connected = atomic_read(&hidpp->connected);\r\nstruct input_dev *input;\r\nchar *name, *devm_name;\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\r\nret = wtp_connect(hdev, connected);\r\nif (ret)\r\nreturn;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560) {\r\nret = m560_send_config_command(hdev, connected);\r\nif (ret)\r\nreturn;\r\n}\r\nif (!connected || hidpp->delayed_input)\r\nreturn;\r\nif (!hidpp->protocol_major) {\r\nret = !hidpp_is_connected(hidpp);\r\nif (ret) {\r\nhid_err(hdev, "Can not get the protocol version.\n");\r\nreturn;\r\n}\r\n}\r\nhid_info(hdev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\nif (!hidpp->name || hidpp->name == hdev->name) {\r\nname = hidpp_get_device_name(hidpp);\r\nif (!name) {\r\nhid_err(hdev,\r\n"unable to retrieve the name of the device");\r\nreturn;\r\n}\r\ndevm_name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s", name);\r\nkfree(name);\r\nif (!devm_name)\r\nreturn;\r\nhidpp->name = devm_name;\r\n}\r\ninput = hidpp_allocate_input(hdev);\r\nif (!input) {\r\nhid_err(hdev, "cannot allocate new input device: %d\n", ret);\r\nreturn;\r\n}\r\nhidpp_populate_input(hidpp, input, false);\r\nret = input_register_device(input);\r\nif (ret)\r\ninput_free_device(input);\r\nhidpp->delayed_input = input;\r\n}\r\nstatic int hidpp_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct hidpp_device *hidpp;\r\nint ret;\r\nbool connected;\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nhidpp = devm_kzalloc(&hdev->dev, sizeof(struct hidpp_device),\r\nGFP_KERNEL);\r\nif (!hidpp)\r\nreturn -ENOMEM;\r\nhidpp->hid_dev = hdev;\r\nhidpp->name = hdev->name;\r\nhid_set_drvdata(hdev, hidpp);\r\nhidpp->quirks = id->driver_data;\r\nif (disable_raw_mode) {\r\nhidpp->quirks &= ~HIDPP_QUIRK_CLASS_WTP;\r\nhidpp->quirks &= ~HIDPP_QUIRK_DELAYED_INIT;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\r\nret = wtp_allocate(hdev, id);\r\nif (ret)\r\ngoto allocate_fail;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560) {\r\nret = m560_allocate(hdev);\r\nif (ret)\r\ngoto allocate_fail;\r\n}\r\nINIT_WORK(&hidpp->work, delayed_work_cb);\r\nmutex_init(&hidpp->send_mutex);\r\ninit_waitqueue_head(&hidpp->wait);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "%s:parse failed\n", __func__);\r\ngoto hid_parse_fail;\r\n}\r\nhid_device_io_start(hdev);\r\nconnected = hidpp_is_connected(hidpp);\r\nif (id->group != HID_GROUP_LOGITECH_DJ_DEVICE) {\r\nif (!connected) {\r\nret = -ENODEV;\r\nhid_err(hdev, "Device not connected");\r\nhid_device_io_stop(hdev);\r\ngoto hid_parse_fail;\r\n}\r\nhid_info(hdev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\n}\r\nhidpp_overwrite_name(hdev, id->group == HID_GROUP_LOGITECH_DJ_DEVICE);\r\natomic_set(&hidpp->connected, connected);\r\nif (connected && (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)) {\r\nret = wtp_get_config(hidpp);\r\nif (ret)\r\ngoto hid_parse_fail;\r\n}\r\nhid_device_io_stop(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_DELAYED_INIT)\r\nconnect_mask &= ~HID_CONNECT_HIDINPUT;\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "%s:hid_hw_start returned error\n", __func__);\r\ngoto hid_hw_start_fail;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_DELAYED_INIT) {\r\nhid_device_io_start(hdev);\r\nhidpp_connect_event(hidpp);\r\n}\r\nreturn ret;\r\nhid_hw_start_fail:\r\nhid_parse_fail:\r\ncancel_work_sync(&hidpp->work);\r\nmutex_destroy(&hidpp->send_mutex);\r\nallocate_fail:\r\nhid_set_drvdata(hdev, NULL);\r\nreturn ret;\r\n}\r\nstatic void hidpp_remove(struct hid_device *hdev)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\ncancel_work_sync(&hidpp->work);\r\nmutex_destroy(&hidpp->send_mutex);\r\nhid_hw_stop(hdev);\r\n}
