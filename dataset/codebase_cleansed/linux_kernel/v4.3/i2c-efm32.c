static u32 efm32_i2c_read32(struct efm32_i2c_ddata *ddata, unsigned offset)\r\n{\r\nreturn readl(ddata->base + offset);\r\n}\r\nstatic void efm32_i2c_write32(struct efm32_i2c_ddata *ddata,\r\nunsigned offset, u32 value)\r\n{\r\nwritel(value, ddata->base + offset);\r\n}\r\nstatic void efm32_i2c_send_next_msg(struct efm32_i2c_ddata *ddata)\r\n{\r\nstruct i2c_msg *cur_msg = &ddata->msgs[ddata->current_msg];\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_START);\r\nefm32_i2c_write32(ddata, REG_TXDATA, cur_msg->addr << 1 |\r\n(cur_msg->flags & I2C_M_RD ? 1 : 0));\r\n}\r\nstatic void efm32_i2c_send_next_byte(struct efm32_i2c_ddata *ddata)\r\n{\r\nstruct i2c_msg *cur_msg = &ddata->msgs[ddata->current_msg];\r\nif (ddata->current_word >= cur_msg->len) {\r\nddata->current_word = 0;\r\nddata->current_msg += 1;\r\nif (ddata->current_msg >= ddata->num_msgs) {\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_STOP);\r\ncomplete(&ddata->done);\r\n} else {\r\nefm32_i2c_send_next_msg(ddata);\r\n}\r\n} else {\r\nefm32_i2c_write32(ddata, REG_TXDATA,\r\ncur_msg->buf[ddata->current_word++]);\r\n}\r\n}\r\nstatic void efm32_i2c_recv_next_byte(struct efm32_i2c_ddata *ddata)\r\n{\r\nstruct i2c_msg *cur_msg = &ddata->msgs[ddata->current_msg];\r\ncur_msg->buf[ddata->current_word] = efm32_i2c_read32(ddata, REG_RXDATA);\r\nddata->current_word += 1;\r\nif (ddata->current_word >= cur_msg->len) {\r\nddata->current_word = 0;\r\nddata->current_msg += 1;\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_NACK);\r\nif (ddata->current_msg >= ddata->num_msgs) {\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_STOP);\r\ncomplete(&ddata->done);\r\n} else {\r\nefm32_i2c_send_next_msg(ddata);\r\n}\r\n} else {\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_ACK);\r\n}\r\n}\r\nstatic irqreturn_t efm32_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct efm32_i2c_ddata *ddata = dev_id;\r\nstruct i2c_msg *cur_msg = &ddata->msgs[ddata->current_msg];\r\nu32 irqflag = efm32_i2c_read32(ddata, REG_IF);\r\nu32 state = efm32_i2c_read32(ddata, REG_STATE);\r\nefm32_i2c_write32(ddata, REG_IFC, irqflag & REG_IFC__MASK);\r\nswitch (state & REG_STATE_STATE__MASK) {\r\ncase REG_STATE_STATE_IDLE:\r\nddata->retval = -EAGAIN;\r\ncomplete(&ddata->done);\r\nbreak;\r\ncase REG_STATE_STATE_WAIT:\r\nddata->retval = -EIO;\r\nefm32_i2c_write32(ddata, REG_CMD,\r\nREG_CMD_STOP | REG_CMD_ABORT |\r\nREG_CMD_CLEARTX | REG_CMD_CLEARPC);\r\ncomplete(&ddata->done);\r\nbreak;\r\ncase REG_STATE_STATE_START:\r\nbreak;\r\ncase REG_STATE_STATE_ADDR:\r\nbreak;\r\ncase REG_STATE_STATE_ADDRACK:\r\nif (state & REG_STATE_NACKED) {\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_STOP);\r\nddata->retval = -ENXIO;\r\ncomplete(&ddata->done);\r\n} else if (cur_msg->flags & I2C_M_RD) {\r\n} else {\r\nefm32_i2c_send_next_byte(ddata);\r\n}\r\nbreak;\r\ncase REG_STATE_STATE_DATA:\r\nif (cur_msg->flags & I2C_M_RD) {\r\nefm32_i2c_recv_next_byte(ddata);\r\n} else {\r\n}\r\nbreak;\r\ncase REG_STATE_STATE_DATAACK:\r\nif (state & REG_STATE_NACKED) {\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_STOP);\r\ncomplete(&ddata->done);\r\n} else {\r\nefm32_i2c_send_next_byte(ddata);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int efm32_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct efm32_i2c_ddata *ddata = i2c_get_adapdata(adap);\r\nint ret;\r\nif (ddata->msgs)\r\nreturn -EBUSY;\r\nddata->msgs = msgs;\r\nddata->num_msgs = num;\r\nddata->current_word = 0;\r\nddata->current_msg = 0;\r\nddata->retval = -EIO;\r\nreinit_completion(&ddata->done);\r\ndev_dbg(&ddata->adapter.dev, "state: %08x, status: %08x\n",\r\nefm32_i2c_read32(ddata, REG_STATE),\r\nefm32_i2c_read32(ddata, REG_STATUS));\r\nefm32_i2c_send_next_msg(ddata);\r\nwait_for_completion(&ddata->done);\r\nif (ddata->current_msg >= ddata->num_msgs)\r\nret = ddata->num_msgs;\r\nelse\r\nret = ddata->retval;\r\nreturn ret;\r\n}\r\nstatic u32 efm32_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic u32 efm32_i2c_get_configured_location(struct efm32_i2c_ddata *ddata)\r\n{\r\nu32 reg = efm32_i2c_read32(ddata, REG_ROUTE);\r\nreturn (reg & REG_ROUTE_LOCATION__MASK) >>\r\n__ffs(REG_ROUTE_LOCATION__MASK);\r\n}\r\nstatic int efm32_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct efm32_i2c_ddata *ddata;\r\nstruct resource *res;\r\nunsigned long rate;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 location, frequency;\r\nint ret;\r\nu32 clkdiv;\r\nif (!np)\r\nreturn -EINVAL;\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ddata);\r\ninit_completion(&ddata->done);\r\nstrlcpy(ddata->adapter.name, pdev->name, sizeof(ddata->adapter.name));\r\nddata->adapter.owner = THIS_MODULE;\r\nddata->adapter.algo = &efm32_i2c_algo;\r\nddata->adapter.dev.parent = &pdev->dev;\r\nddata->adapter.dev.of_node = pdev->dev.of_node;\r\ni2c_set_adapdata(&ddata->adapter, ddata);\r\nddata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ddata->clk)) {\r\nret = PTR_ERR(ddata->clk);\r\ndev_err(&pdev->dev, "failed to get clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to determine base address\n");\r\nreturn -ENODEV;\r\n}\r\nif (resource_size(res) < 0x42) {\r\ndev_err(&pdev->dev, "memory resource too small\n");\r\nreturn -EINVAL;\r\n}\r\nddata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ddata->base))\r\nreturn PTR_ERR(ddata->base);\r\nret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "failed to get irq (%d)\n", ret);\r\nif (!ret)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nddata->irq = ret;\r\nret = clk_prepare_enable(ddata->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable clock (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "energymicro,location", &location);\r\nif (ret)\r\nret = of_property_read_u32(np, "efm32,location", &location);\r\nif (!ret) {\r\ndev_dbg(&pdev->dev, "using location %u\n", location);\r\n} else {\r\nlocation = efm32_i2c_get_configured_location(ddata);\r\ndev_info(&pdev->dev, "fall back to location %u\n", location);\r\n}\r\nddata->location = location;\r\nret = of_property_read_u32(np, "clock-frequency", &frequency);\r\nif (!ret) {\r\ndev_dbg(&pdev->dev, "using frequency %u\n", frequency);\r\n} else {\r\nfrequency = 100000;\r\ndev_info(&pdev->dev, "defaulting to 100 kHz\n");\r\n}\r\nddata->frequency = frequency;\r\nrate = clk_get_rate(ddata->clk);\r\nif (!rate) {\r\ndev_err(&pdev->dev, "there is no input clock available\n");\r\nret = -EINVAL;\r\ngoto err_disable_clk;\r\n}\r\nclkdiv = DIV_ROUND_UP(rate, 8 * ddata->frequency) - 1;\r\nif (clkdiv >= 0x200) {\r\ndev_err(&pdev->dev,\r\n"input clock too fast (%lu) to divide down to bus freq (%lu)",\r\nrate, ddata->frequency);\r\nret = -EINVAL;\r\ngoto err_disable_clk;\r\n}\r\ndev_dbg(&pdev->dev, "input clock = %lu, bus freq = %lu, clkdiv = %lu\n",\r\nrate, ddata->frequency, (unsigned long)clkdiv);\r\nefm32_i2c_write32(ddata, REG_CLKDIV, REG_CLKDIV_DIV(clkdiv));\r\nefm32_i2c_write32(ddata, REG_ROUTE, REG_ROUTE_SDAPEN |\r\nREG_ROUTE_SCLPEN |\r\nREG_ROUTE_LOCATION(ddata->location));\r\nefm32_i2c_write32(ddata, REG_CTRL, REG_CTRL_EN |\r\nREG_CTRL_BITO_160PCC | 0 * REG_CTRL_GIBITO);\r\nefm32_i2c_write32(ddata, REG_IFC, REG_IFC__MASK);\r\nefm32_i2c_write32(ddata, REG_IEN, REG_IF_TXC | REG_IF_ACK | REG_IF_NACK\r\n| REG_IF_ARBLOST | REG_IF_BUSERR | REG_IF_RXDATAV);\r\nefm32_i2c_write32(ddata, REG_CMD, REG_CMD_ABORT);\r\nret = request_irq(ddata->irq, efm32_i2c_irq, 0, DRIVER_NAME, ddata);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request irq (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = i2c_add_adapter(&ddata->adapter);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add i2c adapter (%d)\n", ret);\r\nfree_irq(ddata->irq, ddata);\r\nerr_disable_clk:\r\nclk_disable_unprepare(ddata->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int efm32_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct efm32_i2c_ddata *ddata = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&ddata->adapter);\r\nfree_irq(ddata->irq, ddata);\r\nclk_disable_unprepare(ddata->clk);\r\nreturn 0;\r\n}
