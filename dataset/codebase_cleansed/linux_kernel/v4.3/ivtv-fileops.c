int ivtv_claim_stream(struct ivtv_open_id *id, int type)\r\n{\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[type];\r\nstruct ivtv_stream *s_vbi;\r\nint vbi_type;\r\nif (test_and_set_bit(IVTV_F_S_CLAIMED, &s->s_flags)) {\r\nif (s->fh == &id->fh) {\r\nreturn 0;\r\n}\r\nif (s->fh == NULL && (type == IVTV_DEC_STREAM_TYPE_VBI ||\r\ntype == IVTV_ENC_STREAM_TYPE_VBI)) {\r\ns->fh = &id->fh;\r\nIVTV_DEBUG_INFO("Start Read VBI\n");\r\nreturn 0;\r\n}\r\nIVTV_DEBUG_INFO("Stream %d is busy\n", type);\r\nreturn -EBUSY;\r\n}\r\ns->fh = &id->fh;\r\nif (type == IVTV_DEC_STREAM_TYPE_VBI) {\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\r\n}\r\nif (type == IVTV_DEC_STREAM_TYPE_MPG) {\r\nvbi_type = IVTV_DEC_STREAM_TYPE_VBI;\r\n} else if (type == IVTV_ENC_STREAM_TYPE_MPG &&\r\nitv->vbi.insert_mpeg && !ivtv_raw_vbi(itv)) {\r\nvbi_type = IVTV_ENC_STREAM_TYPE_VBI;\r\n} else {\r\nreturn 0;\r\n}\r\ns_vbi = &itv->streams[vbi_type];\r\nif (!test_and_set_bit(IVTV_F_S_CLAIMED, &s_vbi->s_flags)) {\r\nif (vbi_type == IVTV_DEC_STREAM_TYPE_VBI)\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\r\n}\r\nset_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags);\r\nreturn 0;\r\n}\r\nvoid ivtv_release_stream(struct ivtv_stream *s)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nstruct ivtv_stream *s_vbi;\r\ns->fh = NULL;\r\nif ((s->type == IVTV_DEC_STREAM_TYPE_VBI || s->type == IVTV_ENC_STREAM_TYPE_VBI) &&\r\ntest_bit(IVTV_F_S_INTERNAL_USE, &s->s_flags)) {\r\nreturn;\r\n}\r\nif (!test_and_clear_bit(IVTV_F_S_CLAIMED, &s->s_flags)) {\r\nIVTV_DEBUG_WARN("Release stream %s not in use!\n", s->name);\r\nreturn;\r\n}\r\nivtv_flush_queues(s);\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VBI)\r\nivtv_set_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\r\nif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\r\ns_vbi = &itv->streams[IVTV_DEC_STREAM_TYPE_VBI];\r\nelse if (s->type == IVTV_ENC_STREAM_TYPE_MPG)\r\ns_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\r\nelse\r\nreturn;\r\nif (!test_and_clear_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags)) {\r\nreturn;\r\n}\r\nif (s_vbi->fh) {\r\nreturn;\r\n}\r\nif (s_vbi->type == IVTV_DEC_STREAM_TYPE_VBI)\r\nivtv_set_irq_mask(itv, IVTV_IRQ_DEC_VBI_RE_INSERT);\r\nclear_bit(IVTV_F_S_CLAIMED, &s_vbi->s_flags);\r\nivtv_flush_queues(s_vbi);\r\n}\r\nstatic void ivtv_dualwatch(struct ivtv *itv)\r\n{\r\nstruct v4l2_tuner vt;\r\nu32 new_stereo_mode;\r\nconst u32 dual = 0x02;\r\nnew_stereo_mode = v4l2_ctrl_g_ctrl(itv->cxhdl.audio_mode);\r\nmemset(&vt, 0, sizeof(vt));\r\nivtv_call_all(itv, tuner, g_tuner, &vt);\r\nif (vt.audmode == V4L2_TUNER_MODE_LANG1_LANG2 && (vt.rxsubchans & V4L2_TUNER_SUB_LANG2))\r\nnew_stereo_mode = dual;\r\nif (new_stereo_mode == itv->dualwatch_stereo_mode)\r\nreturn;\r\nIVTV_DEBUG_INFO("dualwatch: change stereo flag from 0x%x to 0x%x.\n",\r\nitv->dualwatch_stereo_mode, new_stereo_mode);\r\nif (v4l2_ctrl_s_ctrl(itv->cxhdl.audio_mode, new_stereo_mode))\r\nIVTV_DEBUG_INFO("dualwatch: changing stereo flag failed\n");\r\n}\r\nstatic void ivtv_update_pgm_info(struct ivtv *itv)\r\n{\r\nu32 wr_idx = (read_enc(itv->pgm_info_offset) - itv->pgm_info_offset - 4) / 24;\r\nint cnt;\r\nint i = 0;\r\nif (wr_idx >= itv->pgm_info_num) {\r\nIVTV_DEBUG_WARN("Invalid PGM index %d (>= %d)\n", wr_idx, itv->pgm_info_num);\r\nreturn;\r\n}\r\ncnt = (wr_idx + itv->pgm_info_num - itv->pgm_info_write_idx) % itv->pgm_info_num;\r\nwhile (i < cnt) {\r\nint idx = (itv->pgm_info_write_idx + i) % itv->pgm_info_num;\r\nstruct v4l2_enc_idx_entry *e = itv->pgm_info + idx;\r\nu32 addr = itv->pgm_info_offset + 4 + idx * 24;\r\nconst int mapping[8] = { -1, V4L2_ENC_IDX_FRAME_I, V4L2_ENC_IDX_FRAME_P, -1,\r\nV4L2_ENC_IDX_FRAME_B, -1, -1, -1 };\r\ne->offset = read_enc(addr + 4) + ((u64)read_enc(addr + 8) << 32);\r\nif (e->offset > itv->mpg_data_received) {\r\nbreak;\r\n}\r\ne->offset += itv->vbi_data_inserted;\r\ne->length = read_enc(addr);\r\ne->pts = read_enc(addr + 16) + ((u64)(read_enc(addr + 20) & 1) << 32);\r\ne->flags = mapping[read_enc(addr + 12) & 7];\r\ni++;\r\n}\r\nitv->pgm_info_write_idx = (itv->pgm_info_write_idx + i) % itv->pgm_info_num;\r\n}\r\nstatic struct ivtv_buffer *ivtv_get_buffer(struct ivtv_stream *s, int non_block, int *err)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nstruct ivtv_stream *s_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\r\nstruct ivtv_buffer *buf;\r\nDEFINE_WAIT(wait);\r\n*err = 0;\r\nwhile (1) {\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG) {\r\nivtv_update_pgm_info(itv);\r\nif (time_after(jiffies,\r\nitv->dualwatch_jiffies +\r\nmsecs_to_jiffies(1000))) {\r\nitv->dualwatch_jiffies = jiffies;\r\nivtv_dualwatch(itv);\r\n}\r\nif (test_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\r\n!test_bit(IVTV_F_S_APPL_IO, &s_vbi->s_flags)) {\r\nwhile ((buf = ivtv_dequeue(s_vbi, &s_vbi->q_full))) {\r\nivtv_process_vbi_data(itv, buf, s_vbi->dma_pts, s_vbi->type);\r\nivtv_enqueue(s_vbi, buf, &s_vbi->q_free);\r\n}\r\n}\r\nbuf = &itv->vbi.sliced_mpeg_buf;\r\nif (buf->readpos != buf->bytesused) {\r\nreturn buf;\r\n}\r\n}\r\nbuf = ivtv_dequeue(s, &s->q_io);\r\nif (buf)\r\nreturn buf;\r\nbuf = ivtv_dequeue(s, &s->q_full);\r\nif (buf) {\r\nif ((buf->b_flags & IVTV_F_B_NEED_BUF_SWAP) == 0)\r\nreturn buf;\r\nbuf->b_flags &= ~IVTV_F_B_NEED_BUF_SWAP;\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG)\r\nivtv_buf_swap(buf);\r\nelse if (s->type != IVTV_DEC_STREAM_TYPE_VBI) {\r\nivtv_process_vbi_data(itv, buf, s->dma_pts, s->type);\r\n}\r\nreturn buf;\r\n}\r\nif (s->type != IVTV_DEC_STREAM_TYPE_VBI && !test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\r\nIVTV_DEBUG_INFO("EOS %s\n", s->name);\r\nreturn NULL;\r\n}\r\nif (non_block) {\r\n*err = -EAGAIN;\r\nreturn NULL;\r\n}\r\nmutex_unlock(&itv->serialize_lock);\r\nprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\r\nif (!s->q_full.buffers)\r\nschedule();\r\nfinish_wait(&s->waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (signal_pending(current)) {\r\nIVTV_DEBUG_INFO("User stopped %s\n", s->name);\r\n*err = -EINTR;\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nstatic void ivtv_setup_sliced_vbi_buf(struct ivtv *itv)\r\n{\r\nint idx = itv->vbi.inserted_frame % IVTV_VBI_FRAMES;\r\nitv->vbi.sliced_mpeg_buf.buf = itv->vbi.sliced_mpeg_data[idx];\r\nitv->vbi.sliced_mpeg_buf.bytesused = itv->vbi.sliced_mpeg_size[idx];\r\nitv->vbi.sliced_mpeg_buf.readpos = 0;\r\n}\r\nstatic size_t ivtv_copy_buf_to_user(struct ivtv_stream *s, struct ivtv_buffer *buf,\r\nchar __user *ubuf, size_t ucount)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nsize_t len = buf->bytesused - buf->readpos;\r\nif (len > ucount) len = ucount;\r\nif (itv->vbi.insert_mpeg && s->type == IVTV_ENC_STREAM_TYPE_MPG &&\r\n!ivtv_raw_vbi(itv) && buf != &itv->vbi.sliced_mpeg_buf) {\r\nconst char *start = buf->buf + buf->readpos;\r\nconst char *p = start + 1;\r\nconst u8 *q;\r\nu8 ch = itv->search_pack_header ? 0xba : 0xe0;\r\nint stuffing, i;\r\nwhile (start + len > p && (q = memchr(p, 0, start + len - p))) {\r\np = q + 1;\r\nif ((char *)q + 15 >= buf->buf + buf->bytesused ||\r\nq[1] != 0 || q[2] != 1 || q[3] != ch) {\r\ncontinue;\r\n}\r\nif (!itv->search_pack_header) {\r\nif ((q[6] & 0xc0) != 0x80)\r\ncontinue;\r\nif (((q[7] & 0xc0) == 0x80 && (q[9] & 0xf0) == 0x20) ||\r\n((q[7] & 0xc0) == 0xc0 && (q[9] & 0xf0) == 0x30)) {\r\nch = 0xba;\r\nitv->search_pack_header = 1;\r\np = q + 9;\r\n}\r\ncontinue;\r\n}\r\nstuffing = q[13] & 7;\r\nfor (i = 0; i < stuffing; i++)\r\nif (q[14 + i] != 0xff)\r\nbreak;\r\nif (i == stuffing && (q[4] & 0xc4) == 0x44 && (q[12] & 3) == 3 &&\r\nq[14 + stuffing] == 0 && q[15 + stuffing] == 0 &&\r\nq[16 + stuffing] == 1) {\r\nitv->search_pack_header = 0;\r\nlen = (char *)q - start;\r\nivtv_setup_sliced_vbi_buf(itv);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (copy_to_user(ubuf, (u8 *)buf->buf + buf->readpos, len)) {\r\nIVTV_DEBUG_WARN("copy %zd bytes to user failed for %s\n", len, s->name);\r\nreturn -EFAULT;\r\n}\r\nbuf->readpos += len;\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG && buf != &itv->vbi.sliced_mpeg_buf)\r\nitv->mpg_data_received += len;\r\nreturn len;\r\n}\r\nstatic ssize_t ivtv_read(struct ivtv_stream *s, char __user *ubuf, size_t tot_count, int non_block)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nsize_t tot_written = 0;\r\nint single_frame = 0;\r\nif (atomic_read(&itv->capturing) == 0 && s->fh == NULL) {\r\nIVTV_DEBUG_WARN("Stream %s not initialized before read\n", s->name);\r\nreturn -EIO;\r\n}\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VBI ||\r\n(s->type == IVTV_ENC_STREAM_TYPE_VBI && !ivtv_raw_vbi(itv)))\r\nsingle_frame = 1;\r\nfor (;;) {\r\nstruct ivtv_buffer *buf;\r\nint rc;\r\nbuf = ivtv_get_buffer(s, non_block, &rc);\r\nif (buf == NULL) {\r\nif (tot_written)\r\nbreak;\r\nif (rc == 0) {\r\nclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nivtv_release_stream(s);\r\n}\r\nreturn rc;\r\n}\r\nrc = ivtv_copy_buf_to_user(s, buf, ubuf + tot_written, tot_count - tot_written);\r\nif (buf != &itv->vbi.sliced_mpeg_buf) {\r\nivtv_enqueue(s, buf, (buf->readpos == buf->bytesused) ? &s->q_free : &s->q_io);\r\n}\r\nelse if (buf->readpos == buf->bytesused) {\r\nint idx = itv->vbi.inserted_frame % IVTV_VBI_FRAMES;\r\nitv->vbi.sliced_mpeg_size[idx] = 0;\r\nitv->vbi.inserted_frame++;\r\nitv->vbi_data_inserted += buf->bytesused;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\ntot_written += rc;\r\nif (tot_written == tot_count || single_frame)\r\nbreak;\r\n}\r\nreturn tot_written;\r\n}\r\nstatic ssize_t ivtv_read_pos(struct ivtv_stream *s, char __user *ubuf, size_t count,\r\nloff_t *pos, int non_block)\r\n{\r\nssize_t rc = count ? ivtv_read(s, ubuf, count, non_block) : 0;\r\nstruct ivtv *itv = s->itv;\r\nIVTV_DEBUG_HI_FILE("read %zd from %s, got %zd\n", count, s->name, rc);\r\nif (rc > 0)\r\npos += rc;\r\nreturn rc;\r\n}\r\nint ivtv_start_capture(struct ivtv_open_id *id)\r\n{\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nstruct ivtv_stream *s_vbi;\r\nif (s->type == IVTV_ENC_STREAM_TYPE_RAD ||\r\ns->type == IVTV_DEC_STREAM_TYPE_MPG ||\r\ns->type == IVTV_DEC_STREAM_TYPE_YUV ||\r\ns->type == IVTV_DEC_STREAM_TYPE_VOUT) {\r\nreturn -EINVAL;\r\n}\r\nif (ivtv_claim_stream(id, s->type))\r\nreturn -EBUSY;\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VBI) {\r\nset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nreturn 0;\r\n}\r\nif (test_bit(IVTV_F_S_STREAMOFF, &s->s_flags) || test_and_set_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\r\nset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nreturn 0;\r\n}\r\ns_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG &&\r\ntest_bit(IVTV_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\r\n!test_and_set_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags)) {\r\nif (ivtv_start_v4l2_encode_stream(s_vbi)) {\r\nIVTV_DEBUG_WARN("VBI capture start failed\n");\r\nclear_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags);\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nivtv_release_stream(s);\r\nreturn -EIO;\r\n}\r\nIVTV_DEBUG_INFO("VBI insertion started\n");\r\n}\r\nif (!ivtv_start_v4l2_encode_stream(s)) {\r\nset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nif (test_and_clear_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\r\nivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 1);\r\nreturn 0;\r\n}\r\nIVTV_DEBUG_WARN("Failed to start capturing for stream %s\n", s->name);\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG &&\r\ntest_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags)) {\r\nivtv_stop_v4l2_encode_stream(s_vbi, 0);\r\nclear_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags);\r\n}\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nivtv_release_stream(s);\r\nreturn -EIO;\r\n}\r\nssize_t ivtv_v4l2_read(struct file * filp, char __user *buf, size_t count, loff_t * pos)\r\n{\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nssize_t rc;\r\nIVTV_DEBUG_HI_FILE("read %zd bytes from %s\n", count, s->name);\r\nif (mutex_lock_interruptible(&itv->serialize_lock))\r\nreturn -ERESTARTSYS;\r\nrc = ivtv_start_capture(id);\r\nif (!rc)\r\nrc = ivtv_read_pos(s, buf, count, pos, filp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&itv->serialize_lock);\r\nreturn rc;\r\n}\r\nint ivtv_start_decoding(struct ivtv_open_id *id, int speed)\r\n{\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nint rc;\r\nif (atomic_read(&itv->decoding) == 0) {\r\nif (ivtv_claim_stream(id, s->type)) {\r\nIVTV_DEBUG_WARN("start decode, stream already claimed\n");\r\nreturn -EBUSY;\r\n}\r\nrc = ivtv_start_v4l2_decode_stream(s, 0);\r\nif (rc < 0) {\r\nif (rc == -EAGAIN)\r\nrc = ivtv_start_v4l2_decode_stream(s, 0);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\n}\r\nif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\r\nreturn ivtv_set_speed(itv, speed);\r\nreturn 0;\r\n}\r\nstatic ssize_t ivtv_write(struct file *filp, const char __user *user_buf, size_t count, loff_t *pos)\r\n{\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nstruct ivtv_buffer *buf;\r\nstruct ivtv_queue q;\r\nint bytes_written = 0;\r\nint mode;\r\nint rc;\r\nDEFINE_WAIT(wait);\r\nIVTV_DEBUG_HI_FILE("write %zd bytes to %s\n", count, s->name);\r\nif (s->type != IVTV_DEC_STREAM_TYPE_MPG &&\r\ns->type != IVTV_DEC_STREAM_TYPE_YUV &&\r\ns->type != IVTV_DEC_STREAM_TYPE_VOUT)\r\nreturn -EINVAL;\r\nif (ivtv_claim_stream(id, s->type))\r\nreturn -EBUSY;\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VOUT) {\r\nint elems = count / sizeof(struct v4l2_sliced_vbi_data);\r\nset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nreturn ivtv_write_vbi_from_user(itv,\r\n(const struct v4l2_sliced_vbi_data __user *)user_buf, elems);\r\n}\r\nmode = s->type == IVTV_DEC_STREAM_TYPE_MPG ? OUT_MPG : OUT_YUV;\r\nif (ivtv_set_output_mode(itv, mode) != mode) {\r\nivtv_release_stream(s);\r\nreturn -EBUSY;\r\n}\r\nivtv_queue_init(&q);\r\nset_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nrc = ivtv_start_decoding(id, itv->speed);\r\nif (rc) {\r\nIVTV_DEBUG_WARN("Failed start decode stream %s\n", s->name);\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nreturn rc;\r\n}\r\nretry:\r\nif (mode == OUT_YUV && s->q_full.length == 0 && itv->dma_data_req_size) {\r\nwhile (count >= itv->dma_data_req_size) {\r\nrc = ivtv_yuv_udma_stream_frame(itv, (void __user *)user_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nbytes_written += itv->dma_data_req_size;\r\nuser_buf += itv->dma_data_req_size;\r\ncount -= itv->dma_data_req_size;\r\n}\r\nif (count == 0) {\r\nIVTV_DEBUG_HI_FILE("Wrote %d bytes to %s (%d)\n", bytes_written, s->name, s->q_full.bytesused);\r\nreturn bytes_written;\r\n}\r\n}\r\nfor (;;) {\r\nwhile (q.length - q.bytesused < count && (buf = ivtv_dequeue(s, &s->q_io)))\r\nivtv_enqueue(s, buf, &q);\r\nwhile (q.length - q.bytesused < count && (buf = ivtv_dequeue(s, &s->q_free))) {\r\nivtv_enqueue(s, buf, &q);\r\n}\r\nif (q.buffers)\r\nbreak;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nmutex_unlock(&itv->serialize_lock);\r\nprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\r\nif (!s->q_free.buffers)\r\nschedule();\r\nfinish_wait(&s->waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (signal_pending(current)) {\r\nIVTV_DEBUG_INFO("User stopped %s\n", s->name);\r\nreturn -EINTR;\r\n}\r\n}\r\nwhile ((buf = ivtv_dequeue(s, &q))) {\r\nif (s->type == IVTV_DEC_STREAM_TYPE_YUV &&\r\nyi->stream_size + count > itv->dma_data_req_size)\r\nrc = ivtv_buf_copy_from_user(s, buf, user_buf,\r\nitv->dma_data_req_size - yi->stream_size);\r\nelse\r\nrc = ivtv_buf_copy_from_user(s, buf, user_buf, count);\r\nif (rc < 0) {\r\nivtv_queue_move(s, &q, NULL, &s->q_free, 0);\r\nreturn rc;\r\n}\r\nuser_buf += rc;\r\ncount -= rc;\r\nbytes_written += rc;\r\nif (s->type == IVTV_DEC_STREAM_TYPE_YUV) {\r\nyi->stream_size += rc;\r\nif (yi->stream_size == itv->dma_data_req_size) {\r\nivtv_enqueue(s, buf, &s->q_full);\r\nyi->stream_size = 0;\r\nbreak;\r\n}\r\n}\r\nif (buf->bytesused != s->buf_size) {\r\nivtv_enqueue(s, buf, &s->q_io);\r\nbreak;\r\n}\r\nif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\r\nivtv_buf_swap(buf);\r\nivtv_enqueue(s, buf, &s->q_full);\r\n}\r\nif (test_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags)) {\r\nif (s->q_full.length >= itv->dma_data_req_size) {\r\nint got_sig;\r\nif (mode == OUT_YUV)\r\nivtv_yuv_setup_stream_frame(itv);\r\nmutex_unlock(&itv->serialize_lock);\r\nprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\r\nwhile (!(got_sig = signal_pending(current)) &&\r\ntest_bit(IVTV_F_S_DMA_PENDING, &s->s_flags)) {\r\nschedule();\r\n}\r\nfinish_wait(&itv->dma_waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (got_sig) {\r\nIVTV_DEBUG_INFO("User interrupted %s\n", s->name);\r\nreturn -EINTR;\r\n}\r\nclear_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags);\r\nivtv_queue_move(s, &s->q_full, NULL, &s->q_predma, itv->dma_data_req_size);\r\nivtv_dma_stream_dec_prepare(s, itv->dma_data_req_offset + IVTV_DECODER_OFFSET, 1);\r\n}\r\n}\r\nif (count && !(filp->f_flags & O_NONBLOCK))\r\ngoto retry;\r\nIVTV_DEBUG_HI_FILE("Wrote %d bytes to %s (%d)\n", bytes_written, s->name, s->q_full.bytesused);\r\nreturn bytes_written;\r\n}\r\nssize_t ivtv_v4l2_write(struct file *filp, const char __user *user_buf, size_t count, loff_t *pos)\r\n{\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nssize_t res;\r\nif (mutex_lock_interruptible(&itv->serialize_lock))\r\nreturn -ERESTARTSYS;\r\nres = ivtv_write(filp, user_buf, count, pos);\r\nmutex_unlock(&itv->serialize_lock);\r\nreturn res;\r\n}\r\nunsigned int ivtv_v4l2_dec_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nint res = 0;\r\nIVTV_DEBUG_HI_FILE("Decoder poll\n");\r\nif (!list_empty(&id->fh.subscribed)) {\r\npoll_wait(filp, &id->fh.wait, wait);\r\nclear_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);\r\nif (v4l2_event_pending(&id->fh))\r\nres = POLLPRI;\r\n} else {\r\npoll_wait(filp, &s->waitq, wait);\r\nset_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);\r\nif (test_bit(IVTV_F_I_EV_VSYNC, &itv->i_flags) ||\r\ntest_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))\r\nres = POLLPRI;\r\n}\r\nif (s->q_free.buffers)\r\nres |= POLLOUT | POLLWRNORM;\r\nreturn res;\r\n}\r\nunsigned int ivtv_v4l2_enc_poll(struct file *filp, poll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nint eof = test_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nunsigned res = 0;\r\nif (!eof && !test_bit(IVTV_F_S_STREAMING, &s->s_flags) &&\r\ns->type != IVTV_ENC_STREAM_TYPE_RAD &&\r\n(req_events & (POLLIN | POLLRDNORM))) {\r\nint rc;\r\nmutex_lock(&itv->serialize_lock);\r\nrc = ivtv_start_capture(id);\r\nmutex_unlock(&itv->serialize_lock);\r\nif (rc) {\r\nIVTV_DEBUG_INFO("Could not start capture for %s (%d)\n",\r\ns->name, rc);\r\nreturn POLLERR;\r\n}\r\nIVTV_DEBUG_FILE("Encoder poll started capture\n");\r\n}\r\nIVTV_DEBUG_HI_FILE("Encoder poll\n");\r\npoll_wait(filp, &s->waitq, wait);\r\nif (v4l2_event_pending(&id->fh))\r\nres |= POLLPRI;\r\nelse\r\npoll_wait(filp, &id->fh.wait, wait);\r\nif (s->q_full.length || s->q_io.length)\r\nreturn res | POLLIN | POLLRDNORM;\r\nif (eof)\r\nreturn res | POLLHUP;\r\nreturn res;\r\n}\r\nvoid ivtv_stop_capture(struct ivtv_open_id *id, int gop_end)\r\n{\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nIVTV_DEBUG_FILE("close() of %s\n", s->name);\r\nif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\r\nstruct ivtv_stream *s_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];\r\nIVTV_DEBUG_INFO("close stopping capture\n");\r\nif (id->type == IVTV_ENC_STREAM_TYPE_MPG &&\r\ntest_bit(IVTV_F_S_STREAMING, &s_vbi->s_flags) &&\r\n!test_bit(IVTV_F_S_APPL_IO, &s_vbi->s_flags)) {\r\nIVTV_DEBUG_INFO("close stopping embedded VBI capture\n");\r\nivtv_stop_v4l2_encode_stream(s_vbi, 0);\r\n}\r\nif ((id->type == IVTV_DEC_STREAM_TYPE_VBI ||\r\nid->type == IVTV_ENC_STREAM_TYPE_VBI) &&\r\ntest_bit(IVTV_F_S_INTERNAL_USE, &s->s_flags)) {\r\ns->fh = NULL;\r\n}\r\nelse {\r\nivtv_stop_v4l2_encode_stream(s, gop_end);\r\n}\r\n}\r\nif (!gop_end) {\r\nclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nivtv_release_stream(s);\r\n}\r\n}\r\nstatic void ivtv_stop_decoding(struct ivtv_open_id *id, int flags, u64 pts)\r\n{\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nIVTV_DEBUG_FILE("close() of %s\n", s->name);\r\nif (id->type == IVTV_DEC_STREAM_TYPE_YUV &&\r\ntest_bit(IVTV_F_I_DECODING_YUV, &itv->i_flags)) {\r\nivtv_yuv_close(itv);\r\n}\r\nif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\r\nIVTV_DEBUG_INFO("close stopping decode\n");\r\nivtv_stop_v4l2_decode_stream(s, flags, pts);\r\nitv->output_mode = OUT_NONE;\r\n}\r\nclear_bit(IVTV_F_S_APPL_IO, &s->s_flags);\r\nclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nif (itv->output_mode == OUT_UDMA_YUV && id->yuv_frames)\r\nitv->output_mode = OUT_NONE;\r\nitv->speed = 0;\r\nclear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags);\r\nivtv_release_stream(s);\r\n}\r\nint ivtv_v4l2_close(struct file *filp)\r\n{\r\nstruct v4l2_fh *fh = filp->private_data;\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nIVTV_DEBUG_FILE("close %s\n", s->name);\r\nmutex_lock(&itv->serialize_lock);\r\nif (id->type == IVTV_ENC_STREAM_TYPE_RAD &&\r\nv4l2_fh_is_singular_file(filp)) {\r\nivtv_mute(itv);\r\nclear_bit(IVTV_F_I_RADIO_USER, &itv->i_flags);\r\nivtv_call_all(itv, video, s_std, itv->std);\r\nivtv_audio_set_io(itv);\r\nif (itv->hw_flags & IVTV_HW_SAA711X) {\r\nivtv_call_hw(itv, IVTV_HW_SAA711X, video, s_crystal_freq,\r\nSAA7115_FREQ_32_11_MHZ, 0);\r\n}\r\nif (atomic_read(&itv->capturing) > 0) {\r\nivtv_vapi(itv, CX2341X_ENC_MUTE_VIDEO, 1,\r\nv4l2_ctrl_g_ctrl(itv->cxhdl.video_mute) |\r\n(v4l2_ctrl_g_ctrl(itv->cxhdl.video_mute_yuv) << 8));\r\n}\r\nivtv_unmute(itv);\r\n}\r\nv4l2_fh_del(fh);\r\nv4l2_fh_exit(fh);\r\nif (s->fh != &id->fh)\r\ngoto close_done;\r\nif (s->type >= IVTV_DEC_STREAM_TYPE_MPG) {\r\nstruct ivtv_stream *s_vout = &itv->streams[IVTV_DEC_STREAM_TYPE_VOUT];\r\nivtv_stop_decoding(id, V4L2_DEC_CMD_STOP_TO_BLACK | V4L2_DEC_CMD_STOP_IMMEDIATELY, 0);\r\nif (itv->output_mode == OUT_NONE && !test_bit(IVTV_F_S_APPL_IO, &s_vout->s_flags)) {\r\nivtv_disable_cc(itv);\r\n}\r\n} else {\r\nivtv_stop_capture(id, 0);\r\n}\r\nclose_done:\r\nkfree(id);\r\nmutex_unlock(&itv->serialize_lock);\r\nreturn 0;\r\n}\r\nint ivtv_v4l2_open(struct file *filp)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint res;\r\nif (mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nres = ivtv_open(filp);\r\nmutex_unlock(vdev->lock);\r\nreturn res;\r\n}\r\nvoid ivtv_mute(struct ivtv *itv)\r\n{\r\nif (atomic_read(&itv->capturing))\r\nivtv_vapi(itv, CX2341X_ENC_MUTE_AUDIO, 1, 1);\r\nIVTV_DEBUG_INFO("Mute\n");\r\n}\r\nvoid ivtv_unmute(struct ivtv *itv)\r\n{\r\nif (atomic_read(&itv->capturing)) {\r\nivtv_msleep_timeout(100, 0);\r\nivtv_vapi(itv, CX2341X_ENC_MISC, 1, 12);\r\nivtv_vapi(itv, CX2341X_ENC_MUTE_AUDIO, 1, 0);\r\n}\r\nIVTV_DEBUG_INFO("Unmute\n");\r\n}
