static int sr_read_tochdr(struct cdrom_device_info *cdi,\r\nstruct cdrom_tochdr *tochdr)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nint result;\r\nunsigned char *buffer;\r\nbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.timeout = IOCTL_TIMEOUT;\r\ncgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\r\ncgc.cmd[8] = 12;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 12;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\nresult = sr_do_ioctl(cd, &cgc);\r\ntochdr->cdth_trk0 = buffer[2];\r\ntochdr->cdth_trk1 = buffer[3];\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int sr_read_tocentry(struct cdrom_device_info *cdi,\r\nstruct cdrom_tocentry *tocentry)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nint result;\r\nunsigned char *buffer;\r\nbuffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.timeout = IOCTL_TIMEOUT;\r\ncgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\r\ncgc.cmd[1] |= (tocentry->cdte_format == CDROM_MSF) ? 0x02 : 0;\r\ncgc.cmd[6] = tocentry->cdte_track;\r\ncgc.cmd[8] = 12;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 12;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\nresult = sr_do_ioctl(cd, &cgc);\r\ntocentry->cdte_ctrl = buffer[5] & 0xf;\r\ntocentry->cdte_adr = buffer[5] >> 4;\r\ntocentry->cdte_datamode = (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\r\nif (tocentry->cdte_format == CDROM_MSF) {\r\ntocentry->cdte_addr.msf.minute = buffer[9];\r\ntocentry->cdte_addr.msf.second = buffer[10];\r\ntocentry->cdte_addr.msf.frame = buffer[11];\r\n} else\r\ntocentry->cdte_addr.lba = (((((buffer[8] << 8) + buffer[9]) << 8)\r\n+ buffer[10]) << 8) + buffer[11];\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int sr_fake_playtrkind(struct cdrom_device_info *cdi, struct cdrom_ti *ti)\r\n{\r\nstruct cdrom_tocentry trk0_te, trk1_te;\r\nstruct cdrom_tochdr tochdr;\r\nstruct packet_command cgc;\r\nint ntracks, ret;\r\nret = sr_read_tochdr(cdi, &tochdr);\r\nif (ret)\r\nreturn ret;\r\nntracks = tochdr.cdth_trk1 - tochdr.cdth_trk0 + 1;\r\nif (ti->cdti_trk1 == ntracks)\r\nti->cdti_trk1 = CDROM_LEADOUT;\r\nelse if (ti->cdti_trk1 != CDROM_LEADOUT)\r\nti->cdti_trk1 ++;\r\ntrk0_te.cdte_track = ti->cdti_trk0;\r\ntrk0_te.cdte_format = CDROM_MSF;\r\ntrk1_te.cdte_track = ti->cdti_trk1;\r\ntrk1_te.cdte_format = CDROM_MSF;\r\nret = sr_read_tocentry(cdi, &trk0_te);\r\nif (ret)\r\nreturn ret;\r\nret = sr_read_tocentry(cdi, &trk1_te);\r\nif (ret)\r\nreturn ret;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_PLAY_AUDIO_MSF;\r\ncgc.cmd[3] = trk0_te.cdte_addr.msf.minute;\r\ncgc.cmd[4] = trk0_te.cdte_addr.msf.second;\r\ncgc.cmd[5] = trk0_te.cdte_addr.msf.frame;\r\ncgc.cmd[6] = trk1_te.cdte_addr.msf.minute;\r\ncgc.cmd[7] = trk1_te.cdte_addr.msf.second;\r\ncgc.cmd[8] = trk1_te.cdte_addr.msf.frame;\r\ncgc.data_direction = DMA_NONE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nreturn sr_do_ioctl(cdi->handle, &cgc);\r\n}\r\nstatic int sr_play_trkind(struct cdrom_device_info *cdi,\r\nstruct cdrom_ti *ti)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nint result;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.timeout = IOCTL_TIMEOUT;\r\ncgc.cmd[0] = GPCMD_PLAYAUDIO_TI;\r\ncgc.cmd[4] = ti->cdti_trk0;\r\ncgc.cmd[5] = ti->cdti_ind0;\r\ncgc.cmd[7] = ti->cdti_trk1;\r\ncgc.cmd[8] = ti->cdti_ind1;\r\ncgc.data_direction = DMA_NONE;\r\nresult = sr_do_ioctl(cd, &cgc);\r\nif (result == -EDRIVE_CANT_DO_THIS)\r\nresult = sr_fake_playtrkind(cdi, ti);\r\nreturn result;\r\n}\r\nint sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\r\n{\r\nstruct scsi_device *SDev;\r\nstruct scsi_sense_hdr sshdr;\r\nint result, err = 0, retries = 0;\r\nstruct request_sense *sense = cgc->sense;\r\nSDev = cd->device;\r\nif (!sense) {\r\nsense = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nif (!sense) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nretry:\r\nif (!scsi_block_when_processing_errors(SDev)) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nmemset(sense, 0, sizeof(*sense));\r\nresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\r\ncgc->buffer, cgc->buflen, (char *)sense,\r\ncgc->timeout, IOCTL_RETRIES, 0, NULL);\r\nscsi_normalize_sense((char *)sense, sizeof(*sense), &sshdr);\r\nif (driver_byte(result) != 0) {\r\nswitch (sshdr.sense_key) {\r\ncase UNIT_ATTENTION:\r\nSDev->changed = 1;\r\nif (!cgc->quiet)\r\nsr_printk(KERN_INFO, cd,\r\n"disc change detected.\n");\r\nif (retries++ < 10)\r\ngoto retry;\r\nerr = -ENOMEDIUM;\r\nbreak;\r\ncase NOT_READY:\r\nif (sshdr.asc == 0x04 &&\r\nsshdr.ascq == 0x01) {\r\nif (!cgc->quiet)\r\nsr_printk(KERN_INFO, cd,\r\n"CDROM not ready yet.\n");\r\nif (retries++ < 10) {\r\nssleep(2);\r\ngoto retry;\r\n} else {\r\nerr = -ENOMEDIUM;\r\nbreak;\r\n}\r\n}\r\nif (!cgc->quiet)\r\nsr_printk(KERN_INFO, cd,\r\n"CDROM not ready. Make sure there "\r\n"is a disc in the drive.\n");\r\nerr = -ENOMEDIUM;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nerr = -EIO;\r\nif (sshdr.asc == 0x20 &&\r\nsshdr.ascq == 0x00)\r\nerr = -EDRIVE_CANT_DO_THIS;\r\nbreak;\r\ndefault:\r\nerr = -EIO;\r\n}\r\n}\r\nout:\r\nif (!cgc->sense)\r\nkfree(sense);\r\ncgc->stat = err;\r\nreturn err;\r\n}\r\nint sr_tray_move(struct cdrom_device_info *cdi, int pos)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_START_STOP_UNIT;\r\ncgc.cmd[4] = (pos == 0) ? 0x03 : 0x02 ;\r\ncgc.data_direction = DMA_NONE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nreturn sr_do_ioctl(cd, &cgc);\r\n}\r\nint sr_lock_door(struct cdrom_device_info *cdi, int lock)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nreturn scsi_set_medium_removal(cd->device, lock ?\r\nSCSI_REMOVAL_PREVENT : SCSI_REMOVAL_ALLOW);\r\n}\r\nint sr_drive_status(struct cdrom_device_info *cdi, int slot)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct scsi_sense_hdr sshdr;\r\nstruct media_event_desc med;\r\nif (CDSL_CURRENT != slot) {\r\nreturn -EINVAL;\r\n}\r\nif (!scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\r\nreturn CDS_DISC_OK;\r\nif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\r\n&& sshdr.asc == 0x04 && sshdr.ascq == 0x01)\r\nreturn CDS_DRIVE_NOT_READY;\r\nif (!cdrom_get_media_event(cdi, &med)) {\r\nif (med.media_present)\r\nreturn CDS_DISC_OK;\r\nelse if (med.door_open)\r\nreturn CDS_TRAY_OPEN;\r\nelse\r\nreturn CDS_NO_DISC;\r\n}\r\nif (scsi_sense_valid(&sshdr) && sshdr.sense_key == NOT_READY\r\n&& sshdr.asc == 0x04 && sshdr.ascq == 0x02)\r\nreturn CDS_TRAY_OPEN;\r\nif (sshdr.sense_key == NOT_READY && sshdr.asc == 0x04)\r\nreturn CDS_DISC_OK;\r\nif (scsi_sense_valid(&sshdr) &&\r\nsshdr.asc == 0x3a)\r\nreturn CDS_NO_DISC;\r\nelse\r\nreturn CDS_TRAY_OPEN;\r\nreturn CDS_DRIVE_NOT_READY;\r\n}\r\nint sr_disk_status(struct cdrom_device_info *cdi)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nstruct cdrom_tochdr toc_h;\r\nstruct cdrom_tocentry toc_e;\r\nint i, rc, have_datatracks = 0;\r\nrc = sr_read_tochdr(cdi, &toc_h);\r\nif (rc)\r\nreturn (rc == -ENOMEDIUM) ? CDS_NO_DISC : CDS_NO_INFO;\r\nfor (i = toc_h.cdth_trk0; i <= toc_h.cdth_trk1; i++) {\r\ntoc_e.cdte_track = i;\r\ntoc_e.cdte_format = CDROM_LBA;\r\nif (sr_read_tocentry(cdi, &toc_e))\r\nreturn CDS_NO_INFO;\r\nif (toc_e.cdte_ctrl & CDROM_DATA_TRACK) {\r\nhave_datatracks = 1;\r\nbreak;\r\n}\r\n}\r\nif (!have_datatracks)\r\nreturn CDS_AUDIO;\r\nif (cd->xa_flag)\r\nreturn CDS_XA_2_1;\r\nelse\r\nreturn CDS_DATA_1;\r\n}\r\nint sr_get_last_session(struct cdrom_device_info *cdi,\r\nstruct cdrom_multisession *ms_info)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nms_info->addr.lba = cd->ms_offset;\r\nms_info->xa_flag = cd->xa_flag || cd->ms_offset > 0;\r\nreturn 0;\r\n}\r\nint sr_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nchar *buffer = kmalloc(32, GFP_KERNEL | SR_GFP_DMA(cd));\r\nint result;\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\r\ncgc.cmd[2] = 0x40;\r\ncgc.cmd[3] = 0x02;\r\ncgc.cmd[8] = 24;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 24;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nresult = sr_do_ioctl(cd, &cgc);\r\nmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\r\nmcn->medium_catalog_number[13] = 0;\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nint sr_reset(struct cdrom_device_info *cdi)\r\n{\r\nreturn 0;\r\n}\r\nint sr_select_speed(struct cdrom_device_info *cdi, int speed)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nstruct packet_command cgc;\r\nif (speed == 0)\r\nspeed = 0xffff;\r\nelse\r\nspeed *= 177;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_SET_SPEED;\r\ncgc.cmd[2] = (speed >> 8) & 0xff;\r\ncgc.cmd[3] = speed & 0xff;\r\ncgc.data_direction = DMA_NONE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nif (sr_do_ioctl(cd, &cgc))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint sr_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase CDROMREADTOCHDR:\r\nreturn sr_read_tochdr(cdi, arg);\r\ncase CDROMREADTOCENTRY:\r\nreturn sr_read_tocentry(cdi, arg);\r\ncase CDROMPLAYTRKIND:\r\nreturn sr_play_trkind(cdi, arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int sr_read_cd(Scsi_CD *cd, unsigned char *dest, int lba, int format, int blksize)\r\n{\r\nstruct packet_command cgc;\r\n#ifdef DEBUG\r\nsr_printk(KERN_INFO, cd, "sr_read_cd lba=%d format=%d blksize=%d\n",\r\nlba, format, blksize);\r\n#endif\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_READ_CD;\r\ncgc.cmd[1] = ((format & 7) << 2);\r\ncgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\r\ncgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\r\ncgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\r\ncgc.cmd[5] = (unsigned char) lba & 0xff;\r\ncgc.cmd[8] = 1;\r\nswitch (blksize) {\r\ncase 2336:\r\ncgc.cmd[9] = 0x58;\r\nbreak;\r\ncase 2340:\r\ncgc.cmd[9] = 0x78;\r\nbreak;\r\ncase 2352:\r\ncgc.cmd[9] = 0xf8;\r\nbreak;\r\ndefault:\r\ncgc.cmd[9] = 0x10;\r\nbreak;\r\n}\r\ncgc.buffer = dest;\r\ncgc.buflen = blksize;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nreturn sr_do_ioctl(cd, &cgc);\r\n}\r\nstatic int sr_read_sector(Scsi_CD *cd, int lba, int blksize, unsigned char *dest)\r\n{\r\nstruct packet_command cgc;\r\nint rc;\r\nif (cd->readcd_known) {\r\nrc = sr_read_cd(cd, dest, lba, 0, blksize);\r\nif (-EDRIVE_CANT_DO_THIS != rc)\r\nreturn rc;\r\ncd->readcd_known = 0;\r\nsr_printk(KERN_INFO, cd,\r\n"CDROM does'nt support READ CD (0xbe) command\n");\r\n}\r\nif (blksize != cd->device->sector_size) {\r\nif (0 != (rc = sr_set_blocklength(cd, blksize)))\r\nreturn rc;\r\n}\r\n#ifdef DEBUG\r\nsr_printk(KERN_INFO, cd, "sr_read_sector lba=%d blksize=%d\n",\r\nlba, blksize);\r\n#endif\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = GPCMD_READ_10;\r\ncgc.cmd[2] = (unsigned char) (lba >> 24) & 0xff;\r\ncgc.cmd[3] = (unsigned char) (lba >> 16) & 0xff;\r\ncgc.cmd[4] = (unsigned char) (lba >> 8) & 0xff;\r\ncgc.cmd[5] = (unsigned char) lba & 0xff;\r\ncgc.cmd[8] = 1;\r\ncgc.buffer = dest;\r\ncgc.buflen = blksize;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = IOCTL_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nreturn rc;\r\n}\r\nint sr_is_xa(Scsi_CD *cd)\r\n{\r\nunsigned char *raw_sector;\r\nint is_xa;\r\nif (!xa_test)\r\nreturn 0;\r\nraw_sector = kmalloc(2048, GFP_KERNEL | SR_GFP_DMA(cd));\r\nif (!raw_sector)\r\nreturn -ENOMEM;\r\nif (0 == sr_read_sector(cd, cd->ms_offset + 16,\r\nCD_FRAMESIZE_RAW1, raw_sector)) {\r\nis_xa = (raw_sector[3] == 0x02) ? 1 : 0;\r\n} else {\r\nis_xa = -1;\r\n}\r\nkfree(raw_sector);\r\n#ifdef DEBUG\r\nsr_printk(KERN_INFO, cd, "sr_is_xa: %d\n", is_xa);\r\n#endif\r\nreturn is_xa;\r\n}
