static unsigned int\r\nip6t_mangle_out(struct sk_buff *skb, const struct nf_hook_state *state)\r\n{\r\nunsigned int ret;\r\nstruct in6_addr saddr, daddr;\r\nu_int8_t hop_limit;\r\nu_int32_t flowlabel, mark;\r\nint err;\r\n#if 0\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr)) {\r\nnet_warn_ratelimited("ip6t_hook: happy cracking\n");\r\nreturn NF_ACCEPT;\r\n}\r\n#endif\r\nmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\r\nmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\r\nmark = skb->mark;\r\nhop_limit = ipv6_hdr(skb)->hop_limit;\r\nflowlabel = *((u_int32_t *)ipv6_hdr(skb));\r\nret = ip6t_do_table(skb, NF_INET_LOCAL_OUT, state,\r\ndev_net(state->out)->ipv6.ip6table_mangle);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(!ipv6_addr_equal(&ipv6_hdr(skb)->saddr, &saddr) ||\r\n!ipv6_addr_equal(&ipv6_hdr(skb)->daddr, &daddr) ||\r\nskb->mark != mark ||\r\nipv6_hdr(skb)->hop_limit != hop_limit ||\r\nflowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {\r\nerr = ip6_route_me_harder(skb);\r\nif (err < 0)\r\nret = NF_DROP_ERR(err);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nip6table_mangle_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nif (ops->hooknum == NF_INET_LOCAL_OUT)\r\nreturn ip6t_mangle_out(skb, state);\r\nif (ops->hooknum == NF_INET_POST_ROUTING)\r\nreturn ip6t_do_table(skb, ops->hooknum, state,\r\ndev_net(state->out)->ipv6.ip6table_mangle);\r\nreturn ip6t_do_table(skb, ops->hooknum, state,\r\ndev_net(state->in)->ipv6.ip6table_mangle);\r\n}\r\nstatic int __net_init ip6table_mangle_net_init(struct net *net)\r\n{\r\nstruct ip6t_replace *repl;\r\nrepl = ip6t_alloc_initial_table(&packet_mangler);\r\nif (repl == NULL)\r\nreturn -ENOMEM;\r\nnet->ipv6.ip6table_mangle =\r\nip6t_register_table(net, &packet_mangler, repl);\r\nkfree(repl);\r\nreturn PTR_ERR_OR_ZERO(net->ipv6.ip6table_mangle);\r\n}\r\nstatic void __net_exit ip6table_mangle_net_exit(struct net *net)\r\n{\r\nip6t_unregister_table(net, net->ipv6.ip6table_mangle);\r\n}\r\nstatic int __init ip6table_mangle_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&ip6table_mangle_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nmangle_ops = xt_hook_link(&packet_mangler, ip6table_mangle_hook);\r\nif (IS_ERR(mangle_ops)) {\r\nret = PTR_ERR(mangle_ops);\r\ngoto cleanup_table;\r\n}\r\nreturn ret;\r\ncleanup_table:\r\nunregister_pernet_subsys(&ip6table_mangle_net_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit ip6table_mangle_fini(void)\r\n{\r\nxt_hook_unlink(&packet_mangler, mangle_ops);\r\nunregister_pernet_subsys(&ip6table_mangle_net_ops);\r\n}
