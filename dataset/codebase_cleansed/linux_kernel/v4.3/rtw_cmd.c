int rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)\r\n{\r\nsema_init(&(pcmdpriv->cmd_queue_sema), 0);\r\nsema_init(&(pcmdpriv->terminate_cmdthread_sema), 0);\r\n_rtw_init_queue(&(pcmdpriv->cmd_queue));\r\nreturn _SUCCESS;\r\n}\r\nstatic int _rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj)\r\n{\r\nunsigned long irqL;\r\nif (obj == NULL)\r\ngoto exit;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nlist_add_tail(&obj->list, &queue->queue);\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nexit:\r\nreturn _SUCCESS;\r\n}\r\nstruct cmd_obj *rtw_dequeue_cmd(struct __queue *queue)\r\n{\r\nunsigned long irqL;\r\nstruct cmd_obj *obj;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nif (list_empty(&(queue->queue))) {\r\nobj = NULL;\r\n} else {\r\nobj = container_of((&queue->queue)->next, struct cmd_obj, list);\r\nlist_del_init(&obj->list);\r\n}\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nreturn obj;\r\n}\r\nstatic int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)\r\n{\r\nu8 bAllow = false;\r\nif ((pcmdpriv->padapter->pwrctrlpriv.bHWPwrPindetect) &&\r\n(!pcmdpriv->padapter->registrypriv.usbss_enable)) {\r\nif (cmd_obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)cmd_obj->parmbuf;\r\nif (pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)\r\nbAllow = true;\r\n}\r\n}\r\nif (cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))\r\nbAllow = true;\r\nif ((!pcmdpriv->padapter->hw_init_completed && !bAllow) ||\r\n!pcmdpriv->cmdthd_running)\r\nreturn _FAIL;\r\nreturn _SUCCESS;\r\n}\r\nu32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)\r\n{\r\nint res = _FAIL;\r\nstruct adapter *padapter = pcmdpriv->padapter;\r\nif (cmd_obj == NULL)\r\ngoto exit;\r\ncmd_obj->padapter = padapter;\r\nres = rtw_cmd_filter(pcmdpriv, cmd_obj);\r\nif (_FAIL == res) {\r\nrtw_free_cmd_obj(cmd_obj);\r\ngoto exit;\r\n}\r\nres = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);\r\nif (res == _SUCCESS)\r\nup(&pcmdpriv->cmd_queue_sema);\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_free_cmd_obj(struct cmd_obj *pcmd)\r\n{\r\nif ((pcmd->cmdcode != _JoinBss_CMD_) && (pcmd->cmdcode != _CreateBss_CMD_)) {\r\nkfree(pcmd->parmbuf);\r\n}\r\nif (pcmd->rsp != NULL) {\r\nif (pcmd->rspsz != 0) {\r\nkfree(pcmd->rsp);\r\n}\r\n}\r\nkfree(pcmd);\r\n}\r\nint rtw_cmd_thread(void *context)\r\n{\r\nu8 ret;\r\nstruct cmd_obj *pcmd;\r\nu8 (*cmd_hdl)(struct adapter *padapter, u8 *pbuf);\r\nvoid (*pcmd_callback)(struct adapter *dev, struct cmd_obj *pcmd);\r\nstruct adapter *padapter = context;\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nallow_signal(SIGTERM);\r\npcmdpriv->cmdthd_running = true;\r\nup(&pcmdpriv->terminate_cmdthread_sema);\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));\r\nwhile (1) {\r\nif (_rtw_down_sema(&pcmdpriv->cmd_queue_sema) == _FAIL)\r\nbreak;\r\nif (padapter->bDriverStopped ||\r\npadapter->bSurpriseRemoved) {\r\nDBG_88E("%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",\r\n__func__, padapter->bDriverStopped, padapter->bSurpriseRemoved, __LINE__);\r\nbreak;\r\n}\r\n_next:\r\nif (padapter->bDriverStopped ||\r\npadapter->bSurpriseRemoved) {\r\nDBG_88E("%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",\r\n__func__, padapter->bDriverStopped, padapter->bSurpriseRemoved, __LINE__);\r\nbreak;\r\n}\r\npcmd = rtw_dequeue_cmd(&pcmdpriv->cmd_queue);\r\nif (!pcmd)\r\ncontinue;\r\nif (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {\r\npcmd->res = H2C_DROPPED;\r\ngoto post_process;\r\n}\r\nif (pcmd->cmdcode < ARRAY_SIZE(wlancmds)) {\r\ncmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;\r\nif (cmd_hdl) {\r\nret = cmd_hdl(pcmd->padapter, pcmd->parmbuf);\r\npcmd->res = ret;\r\n}\r\n} else {\r\npcmd->res = H2C_PARAMETERS_ERROR;\r\n}\r\ncmd_hdl = NULL;\r\npost_process:\r\nif (pcmd->cmdcode < ARRAY_SIZE(rtw_cmd_callback)) {\r\npcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;\r\nif (pcmd_callback == NULL) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback, pcmd->cmdcode));\r\nrtw_free_cmd_obj(pcmd);\r\n} else {\r\npcmd_callback(pcmd->padapter, pcmd);\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("%s: cmdcode = 0x%x callback not defined!\n", __func__, pcmd->cmdcode));\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ngoto _next;\r\n}\r\npcmdpriv->cmdthd_running = false;\r\ndo {\r\npcmd = rtw_dequeue_cmd(&pcmdpriv->cmd_queue);\r\nif (pcmd == NULL)\r\nbreak;\r\nrtw_free_cmd_obj(pcmd);\r\n} while (1);\r\nup(&pcmdpriv->terminate_cmdthread_sema);\r\ncomplete_and_exit(NULL, 0);\r\n}\r\nu8 rtw_sitesurvey_cmd(struct adapter *padapter, struct ndis_802_11_ssid *ssid, int ssid_num,\r\nstruct rtw_ieee80211_channel *ch, int ch_num)\r\n{\r\nu8 res = _FAIL;\r\nstruct cmd_obj *ph2c;\r\nstruct sitesurvey_parm *psurveyPara;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ph2c == NULL)\r\nreturn _FAIL;\r\npsurveyPara = kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);\r\nif (psurveyPara == NULL) {\r\nkfree(ph2c);\r\nreturn _FAIL;\r\n}\r\nrtw_free_network_queue(padapter, false);\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("%s: flush network queue\n", __func__));\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));\r\npsurveyPara->scan_mode = pmlmepriv->scan_mode;\r\nif (ssid) {\r\nint i;\r\nfor (i = 0; i < ssid_num && i < RTW_SSID_SCAN_AMOUNT; i++) {\r\nif (ssid[i].SsidLength) {\r\nmemcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(struct ndis_802_11_ssid));\r\npsurveyPara->ssid_num++;\r\n}\r\n}\r\n}\r\nif (ch) {\r\nint i;\r\nfor (i = 0; i < ch_num && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {\r\nif (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {\r\nmemcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));\r\npsurveyPara->ch_num++;\r\n}\r\n}\r\n}\r\nset_fwstate(pmlmepriv, _FW_UNDER_SURVEY);\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nif (res == _SUCCESS) {\r\npmlmepriv->scan_start_time = jiffies;\r\nmod_timer(&pmlmepriv->scan_to_timer,\r\njiffies + msecs_to_jiffies(SCANNING_TIMEOUT));\r\nrtw_led_control(padapter, LED_CTL_SITE_SURVEY);\r\npmlmepriv->scan_interval = SCAN_INTERVAL;\r\n} else {\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\n}\r\nreturn res;\r\n}\r\nvoid rtw_readtssi_cmdrsp_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nkfree(pcmd->parmbuf);\r\nkfree(pcmd);\r\n}\r\nu8 rtw_createbss_cmd(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *pcmd;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;\r\nu8 res = _SUCCESS;\r\nrtw_led_control(padapter, LED_CTL_START_TO_LINK);\r\nif (pmlmepriv->assoc_ssid.SsidLength == 0)\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for Any SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));\r\nelse\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (pcmd == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nINIT_LIST_HEAD(&pcmd->list);\r\npcmd->cmdcode = _CreateBss_CMD_;\r\npcmd->parmbuf = (unsigned char *)pdev_network;\r\npcmd->cmdsz = get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\npdev_network->Length = pcmd->cmdsz;\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_joinbss_cmd(struct adapter *padapter, struct wlan_network *pnetwork)\r\n{\r\nu8 res = _SUCCESS;\r\nuint t_len = 0;\r\nstruct wlan_bssid_ex *psecnetwork;\r\nstruct cmd_obj *pcmd;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nenum ndis_802_11_network_infra ndis_network_mode = pnetwork->network.InfrastructureMode;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nrtw_led_control(padapter, LED_CTL_START_TO_LINK);\r\nif (pmlmepriv->assoc_ssid.SsidLength == 0)\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));\r\nelse\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid =[%s]\n", pmlmepriv->assoc_ssid.Ssid));\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (pcmd == NULL) {\r\nres = _FAIL;\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));\r\ngoto exit;\r\n}\r\nt_len = sizeof(struct wlan_bssid_ex);\r\nif (!check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE)) {\r\nswitch (ndis_network_mode) {\r\ncase Ndis802_11IBSS:\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\nbreak;\r\ncase Ndis802_11Infrastructure:\r\nset_fwstate(pmlmepriv, WIFI_STATION_STATE);\r\nbreak;\r\ncase Ndis802_11APMode:\r\ncase Ndis802_11AutoUnknown:\r\ncase Ndis802_11InfrastructureMax:\r\nbreak;\r\n}\r\n}\r\npsecnetwork = (struct wlan_bssid_ex *)&psecuritypriv->sec_bss;\r\nif (psecnetwork == NULL) {\r\nkfree(pcmd);\r\nres = _FAIL;\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));\r\ngoto exit;\r\n}\r\nmemset(psecnetwork, 0, t_len);\r\nmemcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));\r\npsecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;\r\nif ((psecnetwork->IELength-12) < (256-1))\r\nmemcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);\r\nelse\r\nmemcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));\r\npsecnetwork->IELength = 0;\r\nif (!pmlmepriv->assoc_by_bssid)\r\nmemcpy(&pmlmepriv->assoc_bssid[0], &pnetwork->network.MacAddress[0], ETH_ALEN);\r\npsecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);\r\npqospriv->qos_option = 0;\r\nif (pregistrypriv->wmm_enable) {\r\nu32 tmp_len;\r\ntmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);\r\nif (psecnetwork->IELength != tmp_len) {\r\npsecnetwork->IELength = tmp_len;\r\npqospriv->qos_option = 1;\r\n} else {\r\npqospriv->qos_option = 0;\r\n}\r\n}\r\nphtpriv->ht_option = false;\r\nif (pregistrypriv->ht_enable) {\r\nif ((padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_) &&\r\n(padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_) &&\r\n(padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_)) {\r\nrtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],\r\npnetwork->network.IELength, &psecnetwork->IELength);\r\n}\r\n}\r\npmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);\r\nif (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_TENDA)\r\npadapter->pwrctrlpriv.smart_ps = 0;\r\nelse\r\npadapter->pwrctrlpriv.smart_ps = padapter->registrypriv.smart_ps;\r\nDBG_88E("%s: smart_ps =%d\n", __func__, padapter->pwrctrlpriv.smart_ps);\r\npcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);\r\nINIT_LIST_HEAD(&pcmd->list);\r\npcmd->cmdcode = _JoinBss_CMD_;\r\npcmd->parmbuf = (unsigned char *)psecnetwork;\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_disassoc_cmd(struct adapter *padapter, u32 deauth_timeout_ms, bool enqueue)\r\n{\r\nstruct cmd_obj *cmdobj = NULL;\r\nstruct disconnect_parm *param = NULL;\r\nstruct cmd_priv *cmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));\r\nparam = kzalloc(sizeof(*param), GFP_KERNEL);\r\nif (param == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nparam->deauth_timeout_ms = deauth_timeout_ms;\r\nif (enqueue) {\r\ncmdobj = kzalloc(sizeof(*cmdobj), GFP_KERNEL);\r\nif (cmdobj == NULL) {\r\nres = _FAIL;\r\nkfree(param);\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DisConnect_CMD_);\r\nres = rtw_enqueue_cmd(cmdpriv, cmdobj);\r\n} else {\r\nif (H2C_SUCCESS != disconnect_hdl(padapter, (u8 *)param))\r\nres = _FAIL;\r\nkfree(param);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_setopmode_cmd(struct adapter *padapter, enum ndis_802_11_network_infra networktype)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct setopmode_parm *psetop;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = false;\r\ngoto exit;\r\n}\r\npsetop = kzalloc(sizeof(struct setopmode_parm), GFP_KERNEL);\r\nif (psetop == NULL) {\r\nkfree(ph2c);\r\nres = false;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);\r\npsetop->mode = (u8)networktype;\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_setstakey_cmd(struct adapter *padapter, u8 *psta, u8 unicast_key)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct set_stakey_parm *psetstakey_para;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct set_stakey_rsp *psetstakey_rsp = NULL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct sta_info *sta = (struct sta_info *)psta;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_para = kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);\r\nif (psetstakey_para == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_rsp = kzalloc(sizeof(struct set_stakey_rsp), GFP_KERNEL);\r\nif (psetstakey_rsp == NULL) {\r\nkfree(ph2c);\r\nkfree(psetstakey_para);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\r\nph2c->rsp = (u8 *)psetstakey_rsp;\r\nph2c->rspsz = sizeof(struct set_stakey_rsp);\r\nether_addr_copy(psetstakey_para->addr, sta->hwaddr);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\npsetstakey_para->algorithm = (unsigned char)psecuritypriv->dot11PrivacyAlgrthm;\r\nelse\r\nGET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);\r\nif (unicast_key)\r\nmemcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);\r\nelse\r\nmemcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);\r\npadapter->securitypriv.busetkipkey = true;\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_clearstakey_cmd(struct adapter *padapter, u8 *psta, u8 entry, u8 enqueue)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct set_stakey_parm *psetstakey_para;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct set_stakey_rsp *psetstakey_rsp = NULL;\r\nstruct sta_info *sta = (struct sta_info *)psta;\r\nu8 res = _SUCCESS;\r\nif (!enqueue) {\r\nclear_cam_entry(padapter, entry);\r\n} else {\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_para = kzalloc(sizeof(struct set_stakey_parm), GFP_ATOMIC);\r\nif (psetstakey_para == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_rsp = kzalloc(sizeof(struct set_stakey_rsp), GFP_ATOMIC);\r\nif (psetstakey_rsp == NULL) {\r\nkfree(ph2c);\r\nkfree(psetstakey_para);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\r\nph2c->rsp = (u8 *)psetstakey_rsp;\r\nph2c->rspsz = sizeof(struct set_stakey_rsp);\r\nether_addr_copy(psetstakey_para->addr, sta->hwaddr);\r\npsetstakey_para->algorithm = _NO_PRIVACY_;\r\npsetstakey_para->id = entry;\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_addbareq_cmd(struct adapter *padapter, u8 tid, u8 *addr)\r\n{\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nstruct cmd_obj *ph2c;\r\nstruct addBaReq_parm *paddbareq_parm;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npaddbareq_parm = kzalloc(sizeof(struct addBaReq_parm), GFP_KERNEL);\r\nif (paddbareq_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npaddbareq_parm->tid = tid;\r\nmemcpy(paddbareq_parm->addr, addr, ETH_ALEN);\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_dynamic_chk_wk_cmd(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = DYNAMIC_CHK_WK_CID;\r\npdrvextra_cmd_parm->type_size = 0;\r\npdrvextra_cmd_parm->pbuf = (u8 *)padapter;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_set_chplan_cmd(struct adapter *padapter, u8 chplan, u8 enqueue)\r\n{\r\nstruct cmd_obj *pcmdobj;\r\nstruct SetChannelPlan_param *setChannelPlan_param;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_chplan_cmd\n"));\r\nif (!rtw_is_channel_plan_valid(chplan)) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nsetChannelPlan_param = kzalloc(sizeof(struct SetChannelPlan_param), GFP_KERNEL);\r\nif (setChannelPlan_param == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nsetChannelPlan_param->channel_plan = chplan;\r\nif (enqueue) {\r\npcmdobj = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (pcmdobj == NULL) {\r\nkfree(setChannelPlan_param);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelPlan_param, GEN_CMD_CODE(_SetChannelPlan));\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmdobj);\r\n} else {\r\nif (H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param))\r\nres = _FAIL;\r\nkfree(setChannelPlan_param);\r\n}\r\nif (res == _SUCCESS)\r\npadapter->mlmepriv.ChannelPlan = chplan;\r\nexit:\r\nreturn res;\r\n}\r\nstatic void traffic_status_watchdog(struct adapter *padapter)\r\n{\r\nu8 bEnterPS;\r\nu8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;\r\nu8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||\r\npmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100) {\r\nbBusyTraffic = true;\r\nif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)\r\nbRxBusyTraffic = true;\r\nelse\r\nbTxBusyTraffic = true;\r\n}\r\nif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||\r\npmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000) {\r\nbHigherBusyTraffic = true;\r\nif (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)\r\nbHigherBusyRxTraffic = true;\r\nelse\r\nbHigherBusyTxTraffic = true;\r\n}\r\nif (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||\r\n(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))\r\nbEnterPS = false;\r\nelse\r\nbEnterPS = true;\r\nif (bEnterPS)\r\nLPS_Enter(padapter);\r\nelse\r\nLPS_Leave(padapter);\r\n} else {\r\nLPS_Leave(padapter);\r\n}\r\npmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0;\r\npmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0;\r\npmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;\r\npmlmepriv->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\r\npmlmepriv->LinkDetectInfo.bTxBusyTraffic = bTxBusyTraffic;\r\npmlmepriv->LinkDetectInfo.bRxBusyTraffic = bRxBusyTraffic;\r\npmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;\r\npmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;\r\npmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;\r\n}\r\nstatic void dynamic_chk_wk_hdl(struct adapter *padapter, u8 *pbuf, int sz)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\npadapter = (struct adapter *)pbuf;\r\npmlmepriv = &(padapter->mlmepriv);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\nexpire_timeout_chk(padapter);\r\n#endif\r\nlinked_status_chk(padapter);\r\ntraffic_status_watchdog(padapter);\r\nrtw_hal_dm_watchdog(padapter);\r\n}\r\nstatic void lps_ctrl_wk_hdl(struct adapter *padapter, u8 lps_ctrl_type)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nu8 mstatus;\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))\r\nreturn;\r\nswitch (lps_ctrl_type) {\r\ncase LPS_CTRL_SCAN:\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\r\nLPS_Leave(padapter);\r\n}\r\nbreak;\r\ncase LPS_CTRL_JOINBSS:\r\nLPS_Leave(padapter);\r\nbreak;\r\ncase LPS_CTRL_CONNECT:\r\nmstatus = 1;\r\npadapter->pwrctrlpriv.LpsIdleCount = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));\r\nbreak;\r\ncase LPS_CTRL_DISCONNECT:\r\nmstatus = 0;\r\nLPS_Leave(padapter);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));\r\nbreak;\r\ncase LPS_CTRL_SPECIAL_PACKET:\r\npwrpriv->DelayLPSLastTimeStamp = jiffies;\r\nLPS_Leave(padapter);\r\nbreak;\r\ncase LPS_CTRL_LEAVE:\r\nLPS_Leave(padapter);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nu8 rtw_lps_ctrl_wk_cmd(struct adapter *padapter, u8 lps_ctrl_type, u8 enqueue)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nif (enqueue) {\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = LPS_CTRL_WK_CID;\r\npdrvextra_cmd_parm->type_size = lps_ctrl_type;\r\npdrvextra_cmd_parm->pbuf = NULL;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\n} else {\r\nlps_ctrl_wk_hdl(padapter, lps_ctrl_type);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nstatic void rpt_timer_setting_wk_hdl(struct adapter *padapter, u16 min_time)\r\n{\r\nrtw_hal_set_hwreg(padapter, HW_VAR_RPT_TIMER_SETTING, (u8 *)(&min_time));\r\n}\r\nu8 rtw_rpt_timer_cfg_cmd(struct adapter *padapter, u16 min_time)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = RTP_TIMER_CFG_WK_CID;\r\npdrvextra_cmd_parm->type_size = min_time;\r\npdrvextra_cmd_parm->pbuf = NULL;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nstatic void antenna_select_wk_hdl(struct adapter *padapter, u8 antenna)\r\n{\r\nrtw_hal_set_hwreg(padapter, HW_VAR_ANTENNA_DIVERSITY_SELECT, (u8 *)(&antenna));\r\n}\r\nu8 rtw_antenna_select_cmd(struct adapter *padapter, u8 antenna, u8 enqueue)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 support_ant_div;\r\nu8 res = _SUCCESS;\r\nrtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &support_ant_div);\r\nif (!support_ant_div)\r\nreturn res;\r\nif (enqueue) {\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_KERNEL);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = ANT_SELECT_WK_CID;\r\npdrvextra_cmd_parm->type_size = antenna;\r\npdrvextra_cmd_parm->pbuf = NULL;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\n} else {\r\nantenna_select_wk_hdl(padapter, antenna);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_ps_cmd(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *ppscmd;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nppscmd = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);\r\nif (ppscmd == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ppscmd);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;\r\npdrvextra_cmd_parm->pbuf = NULL;\r\ninit_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ppscmd);\r\nexit:\r\nreturn res;\r\n}\r\nstatic void rtw_chk_hi_queue_hdl(struct adapter *padapter)\r\n{\r\nint cnt = 0;\r\nstruct sta_info *psta_bmc;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta_bmc = rtw_get_bcmc_stainfo(padapter);\r\nif (!psta_bmc)\r\nreturn;\r\nif (psta_bmc->sleepq_len == 0) {\r\nu8 val = 0;\r\nrtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);\r\nwhile (!val) {\r\nmsleep(100);\r\ncnt++;\r\nif (cnt > 10)\r\nbreak;\r\nrtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);\r\n}\r\nif (cnt <= 10) {\r\npstapriv->tim_bitmap &= ~BIT(0);\r\npstapriv->sta_dz_bitmap &= ~BIT(0);\r\nupdate_beacon(padapter, _TIM_IE_, NULL, false);\r\n} else {\r\nrtw_chk_hi_queue_cmd(padapter);\r\n}\r\n}\r\n}\r\nu8 rtw_chk_hi_queue_cmd(struct adapter *padapter)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct drvextra_cmd_parm *pdrvextra_cmd_parm;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm = kzalloc(sizeof(struct drvextra_cmd_parm), GFP_KERNEL);\r\nif (pdrvextra_cmd_parm == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;\r\npdrvextra_cmd_parm->type_size = 0;\r\npdrvextra_cmd_parm->pbuf = NULL;\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_drvextra_cmd_hdl(struct adapter *padapter, unsigned char *pbuf)\r\n{\r\nstruct drvextra_cmd_parm *pdrvextra_cmd;\r\nif (!pbuf)\r\nreturn H2C_PARAMETERS_ERROR;\r\npdrvextra_cmd = (struct drvextra_cmd_parm *)pbuf;\r\nswitch (pdrvextra_cmd->ec_id) {\r\ncase DYNAMIC_CHK_WK_CID:\r\ndynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);\r\nbreak;\r\ncase POWER_SAVING_CTRL_WK_CID:\r\nrtw_ps_processor(padapter);\r\nbreak;\r\ncase LPS_CTRL_WK_CID:\r\nlps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);\r\nbreak;\r\ncase RTP_TIMER_CFG_WK_CID:\r\nrpt_timer_setting_wk_hdl(padapter, pdrvextra_cmd->type_size);\r\nbreak;\r\ncase ANT_SELECT_WK_CID:\r\nantenna_select_wk_hdl(padapter, pdrvextra_cmd->type_size);\r\nbreak;\r\n#ifdef CONFIG_88EU_AP_MODE\r\ncase CHECK_HIQ_WK_CID:\r\nrtw_chk_hi_queue_hdl(padapter);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nif (pdrvextra_cmd->pbuf && pdrvextra_cmd->type_size > 0)\r\nkfree(pdrvextra_cmd->pbuf);\r\nreturn H2C_SUCCESS;\r\n}\r\nvoid rtw_survey_cmd_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (pcmd->res == H2C_DROPPED) {\r\nmod_timer(&pmlmepriv->scan_to_timer,\r\njiffies + msecs_to_jiffies(1));\r\n} else if (pcmd->res != H2C_SUCCESS) {\r\nmod_timer(&pmlmepriv->scan_to_timer,\r\njiffies + msecs_to_jiffies(1));\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));\r\n}\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nvoid rtw_disassoc_cmd_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (pcmd->res != H2C_SUCCESS) {\r\nspin_lock_bh(&pmlmepriv->lock);\r\nset_fwstate(pmlmepriv, _FW_LINKED);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));\r\nreturn;\r\n}\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nvoid rtw_joinbss_cmd_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (pcmd->res == H2C_DROPPED) {\r\nmod_timer(&pmlmepriv->assoc_timer,\r\njiffies + msecs_to_jiffies(1));\r\n} else if (pcmd->res != H2C_SUCCESS) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("********Error:rtw_select_and_join_from_scanned_queue Wait Sema Fail ************\n"));\r\nmod_timer(&pmlmepriv->assoc_timer,\r\njiffies + msecs_to_jiffies(1));\r\n}\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nvoid rtw_createbss_cmd_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;\r\nstruct wlan_network *tgt_network = &(pmlmepriv->cur_network);\r\nif (pcmd->res != H2C_SUCCESS) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: rtw_createbss_cmd_callback Fail ************\n\n."));\r\nmod_timer(&pmlmepriv->assoc_timer,\r\njiffies + msecs_to_jiffies(1));\r\n}\r\ndel_timer_sync(&pmlmepriv->assoc_timer);\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\npsta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);\r\nif (!psta) {\r\npsta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nCan't alloc sta_info when createbss_cmd_callback\n"));\r\ngoto createbss_cmd_fail;\r\n}\r\n}\r\nrtw_indicate_connect(padapter);\r\n} else {\r\npwlan = _rtw_alloc_network(pmlmepriv);\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nif (pwlan == NULL) {\r\npwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);\r\nif (pwlan == NULL) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n Error: can't get pwlan in rtw_joinbss_event_callback\n"));\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\ngoto createbss_cmd_fail;\r\n}\r\npwlan->last_scanned = jiffies;\r\n} else {\r\nlist_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);\r\n}\r\npnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);\r\nmemcpy(&(pwlan->network), pnetwork, pnetwork->Length);\r\nmemcpy(&tgt_network->network, pnetwork, (get_wlan_bssid_ex_sz(pnetwork)));\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\n}\r\ncreatebss_cmd_fail:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nvoid rtw_setstaKey_cmdrsp_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);\r\nstruct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));\r\ngoto exit;\r\n}\r\nexit:\r\nrtw_free_cmd_obj(pcmd);\r\n}\r\nvoid rtw_setassocsta_cmdrsp_callback(struct adapter *padapter, struct cmd_obj *pcmd)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct set_assocsta_parm *passocsta_parm = (struct set_assocsta_parm *)(pcmd->parmbuf);\r\nstruct set_assocsta_rsp *passocsta_rsp = (struct set_assocsta_rsp *)(pcmd->rsp);\r\nstruct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));\r\ngoto exit;\r\n}\r\npsta->aid = passocsta_rsp->cam_id;\r\npsta->mac_id = passocsta_rsp->cam_id;\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nset_fwstate(pmlmepriv, _FW_LINKED);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nexit:\r\nrtw_free_cmd_obj(pcmd);\r\n}
