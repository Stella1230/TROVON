acpi_status\r\nacpi_ns_complex_repairs(struct acpi_evaluate_info *info,\r\nstruct acpi_namespace_node *node,\r\nacpi_status validate_status,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nconst struct acpi_repair_info *predefined;\r\nacpi_status status;\r\npredefined = acpi_ns_match_complex_repair(node);\r\nif (!predefined) {\r\nreturn (validate_status);\r\n}\r\nstatus = predefined->repair_function(info, return_object_ptr);\r\nreturn (status);\r\n}\r\nstatic const struct acpi_repair_info *acpi_ns_match_complex_repair(struct\r\nacpi_namespace_node\r\n*node)\r\n{\r\nconst struct acpi_repair_info *this_name;\r\nthis_name = acpi_ns_repairable_names;\r\nwhile (this_name->repair_function) {\r\nif (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {\r\nreturn (this_name);\r\n}\r\nthis_name++;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_ALR(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status;\r\nstatus = acpi_ns_check_sorted_list(info, return_object, 0, 2, 1,\r\nACPI_SORT_ASCENDING,\r\n"AmbientIlluminance");\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_FDE(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object *buffer_object;\r\nu8 *byte_buffer;\r\nu32 *dword_buffer;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_repair_FDE);\r\nswitch (return_object->common.type) {\r\ncase ACPI_TYPE_BUFFER:\r\nif (return_object->buffer.length >= ACPI_FDE_DWORD_BUFFER_SIZE) {\r\nreturn (AE_OK);\r\n}\r\nif (return_object->buffer.length != ACPI_FDE_BYTE_BUFFER_SIZE) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Incorrect return buffer length %u, expected %u",\r\nreturn_object->buffer.length,\r\nACPI_FDE_DWORD_BUFFER_SIZE));\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nbuffer_object =\r\nacpi_ut_create_buffer_object(ACPI_FDE_DWORD_BUFFER_SIZE);\r\nif (!buffer_object) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nbyte_buffer = return_object->buffer.pointer;\r\ndword_buffer =\r\nACPI_CAST_PTR(u32, buffer_object->buffer.pointer);\r\nfor (i = 0; i < ACPI_FDE_FIELD_COUNT; i++) {\r\n*dword_buffer = (u32) *byte_buffer;\r\ndword_buffer++;\r\nbyte_buffer++;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s Expanded Byte Buffer to expected DWord Buffer\n",\r\ninfo->full_pathname));\r\nbreak;\r\ndefault:\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nacpi_ut_remove_reference(return_object);\r\n*return_object_ptr = buffer_object;\r\ninfo->return_flags |= ACPI_OBJECT_REPAIRED;\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_CID(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nacpi_status status;\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object **element_ptr;\r\nunion acpi_operand_object *original_element;\r\nu16 original_ref_count;\r\nu32 i;\r\nif (return_object->common.type == ACPI_TYPE_STRING) {\r\nstatus = acpi_ns_repair_HID(info, return_object_ptr);\r\nreturn (status);\r\n}\r\nif (return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_OK);\r\n}\r\nelement_ptr = return_object->package.elements;\r\nfor (i = 0; i < return_object->package.count; i++) {\r\noriginal_element = *element_ptr;\r\noriginal_ref_count = original_element->common.reference_count;\r\nstatus = acpi_ns_repair_HID(info, element_ptr);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (original_element != *element_ptr) {\r\n(*element_ptr)->common.reference_count =\r\noriginal_ref_count;\r\nacpi_ut_remove_reference(original_element);\r\n}\r\nelement_ptr++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_CST(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object **outer_elements;\r\nu32 outer_element_count;\r\nunion acpi_operand_object *obj_desc;\r\nacpi_status status;\r\nu8 removing;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_repair_CST);\r\nouter_element_count = return_object->package.count - 1;\r\ni = 0;\r\nwhile (i < outer_element_count) {\r\nouter_elements = &return_object->package.elements[i + 1];\r\nremoving = FALSE;\r\nif ((*outer_elements)->package.count == 0) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"SubPackage[%u] - removing entry due to zero count",\r\ni));\r\nremoving = TRUE;\r\ngoto remove_element;\r\n}\r\nobj_desc = (*outer_elements)->package.elements[1];\r\nif ((u32)obj_desc->integer.value == 0) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"SubPackage[%u] - removing entry due to invalid Type(0)",\r\ni));\r\nremoving = TRUE;\r\n}\r\nremove_element:\r\nif (removing) {\r\nacpi_ns_remove_element(return_object, i + 1);\r\nouter_element_count--;\r\n} else {\r\ni++;\r\n}\r\n}\r\nobj_desc = return_object->package.elements[0];\r\nobj_desc->integer.value = outer_element_count;\r\nstatus = acpi_ns_check_sorted_list(info, return_object, 1, 4, 1,\r\nACPI_SORT_ASCENDING, "C-State Type");\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_HID(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object *new_string;\r\nchar *source;\r\nchar *dest;\r\nACPI_FUNCTION_NAME(ns_repair_HID);\r\nif (return_object->common.type != ACPI_TYPE_STRING) {\r\nreturn (AE_OK);\r\n}\r\nif (return_object->string.length == 0) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"Invalid zero-length _HID or _CID string"));\r\ninfo->return_flags |= ACPI_OBJECT_REPAIRED;\r\nreturn (AE_OK);\r\n}\r\nnew_string = acpi_ut_create_string_object(return_object->string.length);\r\nif (!new_string) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nsource = return_object->string.pointer;\r\nif (*source == '*') {\r\nsource++;\r\nnew_string->string.length--;\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Removed invalid leading asterisk\n",\r\ninfo->full_pathname));\r\n}\r\nfor (dest = new_string->string.pointer; *source; dest++, source++) {\r\n*dest = (char)toupper((int)*source);\r\n}\r\nacpi_ut_remove_reference(return_object);\r\n*return_object_ptr = new_string;\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_PRT(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *package_object = *return_object_ptr;\r\nunion acpi_operand_object **top_object_list;\r\nunion acpi_operand_object **sub_object_list;\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *sub_package;\r\nu32 element_count;\r\nu32 index;\r\ntop_object_list = package_object->package.elements;\r\nelement_count = package_object->package.count;\r\nfor (index = 0; index < element_count; index++, top_object_list++) {\r\nsub_package = *top_object_list;\r\nsub_object_list = sub_package->package.elements;\r\nif (sub_package->package.count < 4) {\r\ncontinue;\r\n}\r\nobj_desc = sub_object_list[3];\r\nif (!obj_desc || (obj_desc->common.type != ACPI_TYPE_INTEGER)) {\r\nsub_object_list[3] = sub_object_list[2];\r\nsub_object_list[2] = obj_desc;\r\ninfo->return_flags |= ACPI_OBJECT_REPAIRED;\r\nACPI_WARN_PREDEFINED((AE_INFO,\r\ninfo->full_pathname,\r\ninfo->node_flags,\r\n"PRT[%X]: Fixed reversed SourceName and SourceIndex",\r\nindex));\r\n}\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_PSS(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object **outer_elements;\r\nu32 outer_element_count;\r\nunion acpi_operand_object **elements;\r\nunion acpi_operand_object *obj_desc;\r\nu32 previous_value;\r\nacpi_status status;\r\nu32 i;\r\nstatus = acpi_ns_check_sorted_list(info, return_object, 0, 6, 0,\r\nACPI_SORT_DESCENDING,\r\n"CpuFrequency");\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nprevious_value = ACPI_UINT32_MAX;\r\nouter_elements = return_object->package.elements;\r\nouter_element_count = return_object->package.count;\r\nfor (i = 0; i < outer_element_count; i++) {\r\nelements = (*outer_elements)->package.elements;\r\nobj_desc = elements[1];\r\nif ((u32) obj_desc->integer.value > previous_value) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\ninfo->node_flags,\r\n"SubPackage[%u,%u] - suspicious power dissipation values",\r\ni - 1, i));\r\n}\r\nprevious_value = (u32) obj_desc->integer.value;\r\nouter_elements++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_TSS(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nstatus = acpi_ns_get_node(info->node, "^_PSS",\r\nACPI_NS_NO_UPSEARCH, &node);\r\nif (ACPI_SUCCESS(status)) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_ns_check_sorted_list(info, return_object, 0, 5, 1,\r\nACPI_SORT_DESCENDING,\r\n"PowerDissipation");\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_sorted_list(struct acpi_evaluate_info *info,\r\nunion acpi_operand_object *return_object,\r\nu32 start_index,\r\nu32 expected_count,\r\nu32 sort_index,\r\nu8 sort_direction, char *sort_key_name)\r\n{\r\nu32 outer_element_count;\r\nunion acpi_operand_object **outer_elements;\r\nunion acpi_operand_object **elements;\r\nunion acpi_operand_object *obj_desc;\r\nu32 i;\r\nu32 previous_value;\r\nACPI_FUNCTION_NAME(ns_check_sorted_list);\r\nif (return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nouter_element_count = return_object->package.count;\r\nif (!outer_element_count || start_index >= outer_element_count) {\r\nreturn (AE_AML_PACKAGE_LIMIT);\r\n}\r\nouter_elements = &return_object->package.elements[start_index];\r\nouter_element_count -= start_index;\r\nprevious_value = 0;\r\nif (sort_direction == ACPI_SORT_DESCENDING) {\r\nprevious_value = ACPI_UINT32_MAX;\r\n}\r\nfor (i = 0; i < outer_element_count; i++) {\r\nif ((*outer_elements)->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nif ((*outer_elements)->package.count < expected_count) {\r\nreturn (AE_AML_PACKAGE_LIMIT);\r\n}\r\nelements = (*outer_elements)->package.elements;\r\nobj_desc = elements[sort_index];\r\nif (obj_desc->common.type != ACPI_TYPE_INTEGER) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nif (((sort_direction == ACPI_SORT_ASCENDING) &&\r\n(obj_desc->integer.value < previous_value)) ||\r\n((sort_direction == ACPI_SORT_DESCENDING) &&\r\n(obj_desc->integer.value > previous_value))) {\r\nacpi_ns_sort_list(&return_object->package.\r\nelements[start_index],\r\nouter_element_count, sort_index,\r\nsort_direction);\r\ninfo->return_flags |= ACPI_OBJECT_REPAIRED;\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Repaired unsorted list - now sorted by %s\n",\r\ninfo->full_pathname, sort_key_name));\r\nreturn (AE_OK);\r\n}\r\nprevious_value = (u32) obj_desc->integer.value;\r\nouter_elements++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic void\r\nacpi_ns_sort_list(union acpi_operand_object **elements,\r\nu32 count, u32 index, u8 sort_direction)\r\n{\r\nunion acpi_operand_object *obj_desc1;\r\nunion acpi_operand_object *obj_desc2;\r\nunion acpi_operand_object *temp_obj;\r\nu32 i;\r\nu32 j;\r\nfor (i = 1; i < count; i++) {\r\nfor (j = (count - 1); j >= i; j--) {\r\nobj_desc1 = elements[j - 1]->package.elements[index];\r\nobj_desc2 = elements[j]->package.elements[index];\r\nif (((sort_direction == ACPI_SORT_ASCENDING) &&\r\n(obj_desc1->integer.value >\r\nobj_desc2->integer.value))\r\n|| ((sort_direction == ACPI_SORT_DESCENDING)\r\n&& (obj_desc1->integer.value <\r\nobj_desc2->integer.value))) {\r\ntemp_obj = elements[j - 1];\r\nelements[j - 1] = elements[j];\r\nelements[j] = temp_obj;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nacpi_ns_remove_element(union acpi_operand_object *obj_desc, u32 index)\r\n{\r\nunion acpi_operand_object **source;\r\nunion acpi_operand_object **dest;\r\nu32 count;\r\nu32 new_count;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_remove_element);\r\ncount = obj_desc->package.count;\r\nnew_count = count - 1;\r\nsource = obj_desc->package.elements;\r\ndest = source;\r\nfor (i = 0; i < count; i++) {\r\nif (i == index) {\r\nacpi_ut_remove_reference(*source);\r\nacpi_ut_remove_reference(*source);\r\n} else {\r\n*dest = *source;\r\ndest++;\r\n}\r\nsource++;\r\n}\r\n*dest = NULL;\r\nobj_desc->package.count = new_count;\r\n}
