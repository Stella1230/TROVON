int snd_aw2_saa7146_free(struct snd_aw2_saa7146 *chip)\r\n{\r\nWRITEREG(0, IER);\r\nWRITEREG((MRST_N << 16), MC1);\r\nchip->base_addr = NULL;\r\nreturn 0;\r\n}\r\nvoid snd_aw2_saa7146_setup(struct snd_aw2_saa7146 *chip,\r\nvoid __iomem *pci_base_addr)\r\n{\r\nunsigned int acon2;\r\nunsigned int acon1 = 0;\r\nint i;\r\nchip->base_addr = pci_base_addr;\r\nWRITEREG(0, IER);\r\nWRITEREG((MRST_N << 16), MC1);\r\n#ifdef __BIG_ENDIAN\r\nacon1 |= A1_SWAP;\r\nacon1 |= A2_SWAP;\r\n#endif\r\nacon1 |= 0 * WS1_CTRL;\r\nacon1 |= 0 * WS2_CTRL;\r\nacon1 |= 3 * WS4_CTRL;\r\nacon1 |= 2 * WS3_CTRL;\r\nacon1 |= 3 * AUDIO_MODE;\r\nWRITEREG(acon1, ACON1);\r\nWRITEREG(3 * (BurstA1_in) + 3 * (ThreshA1_in) +\r\n3 * (BurstA1_out) + 3 * (ThreshA1_out) +\r\n3 * (BurstA2_out) + 3 * (ThreshA2_out), PCI_BT_A);\r\nWRITEREG((EAP << 16) | EAP, MC1);\r\nWRITEREG((EI2C << 16) | EI2C, MC1);\r\nWRITEREG(A1_out | A2_out | A1_in | IIC_S | IIC_E, IER);\r\nacon2 = A2_CLKSRC | BCLK1_OEN;\r\nWRITEREG(acon2, ACON2);\r\nsnd_aw2_saa7146_use_digital_input(chip, 0);\r\nfor (i = 0; i < 8; ++i) {\r\nWRITEREG(tsl1[i], TSL1 + (i * 4));\r\nWRITEREG(tsl2[i], TSL2 + (i * 4));\r\n}\r\n}\r\nvoid snd_aw2_saa7146_pcm_init_playback(struct snd_aw2_saa7146 *chip,\r\nint stream_number,\r\nunsigned long dma_addr,\r\nunsigned long period_size,\r\nunsigned long buffer_size)\r\n{\r\nunsigned long dw_page, dw_limit;\r\ndw_page = (0L << 11);\r\ndw_limit = snd_aw2_saa7146_get_limit(period_size);\r\ndw_page |= (dw_limit << 4);\r\nif (stream_number == 0) {\r\nWRITEREG(dw_page, PageA2_out);\r\nWRITEREG(dma_addr, BaseA2_out);\r\nWRITEREG(dma_addr + buffer_size, ProtA2_out);\r\n} else if (stream_number == 1) {\r\nWRITEREG(dw_page, PageA1_out);\r\nWRITEREG(dma_addr, BaseA1_out);\r\nWRITEREG(dma_addr + buffer_size, ProtA1_out);\r\n} else {\r\npr_err("aw2: snd_aw2_saa7146_pcm_init_playback: "\r\n"Substream number is not 0 or 1 -> not managed\n");\r\n}\r\n}\r\nvoid snd_aw2_saa7146_pcm_init_capture(struct snd_aw2_saa7146 *chip,\r\nint stream_number, unsigned long dma_addr,\r\nunsigned long period_size,\r\nunsigned long buffer_size)\r\n{\r\nunsigned long dw_page, dw_limit;\r\ndw_page = (0L << 11);\r\ndw_limit = snd_aw2_saa7146_get_limit(period_size);\r\ndw_page |= (dw_limit << 4);\r\nif (stream_number == 0) {\r\nWRITEREG(dw_page, PageA1_in);\r\nWRITEREG(dma_addr, BaseA1_in);\r\nWRITEREG(dma_addr + buffer_size, ProtA1_in);\r\n} else {\r\npr_err("aw2: snd_aw2_saa7146_pcm_init_capture: "\r\n"Substream number is not 0 -> not managed\n");\r\n}\r\n}\r\nvoid snd_aw2_saa7146_define_it_playback_callback(unsigned int stream_number,\r\nsnd_aw2_saa7146_it_cb\r\np_it_callback,\r\nvoid *p_callback_param)\r\n{\r\nif (stream_number < NB_STREAM_PLAYBACK) {\r\narr_substream_it_playback_cb[stream_number].p_it_callback =\r\n(snd_aw2_saa7146_it_cb) p_it_callback;\r\narr_substream_it_playback_cb[stream_number].p_callback_param =\r\n(void *)p_callback_param;\r\n}\r\n}\r\nvoid snd_aw2_saa7146_define_it_capture_callback(unsigned int stream_number,\r\nsnd_aw2_saa7146_it_cb\r\np_it_callback,\r\nvoid *p_callback_param)\r\n{\r\nif (stream_number < NB_STREAM_CAPTURE) {\r\narr_substream_it_capture_cb[stream_number].p_it_callback =\r\n(snd_aw2_saa7146_it_cb) p_it_callback;\r\narr_substream_it_capture_cb[stream_number].p_callback_param =\r\n(void *)p_callback_param;\r\n}\r\n}\r\nvoid snd_aw2_saa7146_pcm_trigger_start_playback(struct snd_aw2_saa7146 *chip,\r\nint stream_number)\r\n{\r\nunsigned int acon1 = 0;\r\nacon1 = READREG(ACON1);\r\nif (stream_number == 0) {\r\nWRITEREG((TR_E_A2_OUT << 16) | TR_E_A2_OUT, MC1);\r\nacon1 |= 2 * WS2_CTRL;\r\nWRITEREG(acon1, ACON1);\r\n} else if (stream_number == 1) {\r\nWRITEREG((TR_E_A1_OUT << 16) | TR_E_A1_OUT, MC1);\r\nacon1 |= 1 * WS1_CTRL;\r\nWRITEREG(acon1, ACON1);\r\n}\r\n}\r\nvoid snd_aw2_saa7146_pcm_trigger_stop_playback(struct snd_aw2_saa7146 *chip,\r\nint stream_number)\r\n{\r\nunsigned int acon1 = 0;\r\nacon1 = READREG(ACON1);\r\nif (stream_number == 0) {\r\nacon1 &= ~(3 * WS2_CTRL);\r\nWRITEREG(acon1, ACON1);\r\nWRITEREG((TR_E_A2_OUT << 16), MC1);\r\n} else if (stream_number == 1) {\r\nacon1 &= ~(3 * WS1_CTRL);\r\nWRITEREG(acon1, ACON1);\r\nWRITEREG((TR_E_A1_OUT << 16), MC1);\r\n}\r\n}\r\nvoid snd_aw2_saa7146_pcm_trigger_start_capture(struct snd_aw2_saa7146 *chip,\r\nint stream_number)\r\n{\r\nif (stream_number == 0)\r\nWRITEREG((TR_E_A1_IN << 16) | TR_E_A1_IN, MC1);\r\n}\r\nvoid snd_aw2_saa7146_pcm_trigger_stop_capture(struct snd_aw2_saa7146 *chip,\r\nint stream_number)\r\n{\r\nif (stream_number == 0)\r\nWRITEREG((TR_E_A1_IN << 16), MC1);\r\n}\r\nirqreturn_t snd_aw2_saa7146_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned int isr;\r\nunsigned int iicsta;\r\nstruct snd_aw2_saa7146 *chip = dev_id;\r\nisr = READREG(ISR);\r\nif (!isr)\r\nreturn IRQ_NONE;\r\nWRITEREG(isr, ISR);\r\nif (isr & (IIC_S | IIC_E)) {\r\niicsta = READREG(IICSTA);\r\nWRITEREG(0x100, IICSTA);\r\n}\r\nif (isr & A1_out) {\r\nif (arr_substream_it_playback_cb[1].p_it_callback != NULL) {\r\narr_substream_it_playback_cb[1].\r\np_it_callback(arr_substream_it_playback_cb[1].\r\np_callback_param);\r\n}\r\n}\r\nif (isr & A2_out) {\r\nif (arr_substream_it_playback_cb[0].p_it_callback != NULL) {\r\narr_substream_it_playback_cb[0].\r\np_it_callback(arr_substream_it_playback_cb[0].\r\np_callback_param);\r\n}\r\n}\r\nif (isr & A1_in) {\r\nif (arr_substream_it_capture_cb[0].p_it_callback != NULL) {\r\narr_substream_it_capture_cb[0].\r\np_it_callback(arr_substream_it_capture_cb[0].\r\np_callback_param);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nunsigned int snd_aw2_saa7146_get_hw_ptr_playback(struct snd_aw2_saa7146 *chip,\r\nint stream_number,\r\nunsigned char *start_addr,\r\nunsigned int buffer_size)\r\n{\r\nlong pci_adp = 0;\r\nsize_t ptr = 0;\r\nif (stream_number == 0) {\r\npci_adp = READREG(PCI_ADP3);\r\nptr = pci_adp - (long)start_addr;\r\nif (ptr == buffer_size)\r\nptr = 0;\r\n}\r\nif (stream_number == 1) {\r\npci_adp = READREG(PCI_ADP1);\r\nptr = pci_adp - (size_t) start_addr;\r\nif (ptr == buffer_size)\r\nptr = 0;\r\n}\r\nreturn ptr;\r\n}\r\nunsigned int snd_aw2_saa7146_get_hw_ptr_capture(struct snd_aw2_saa7146 *chip,\r\nint stream_number,\r\nunsigned char *start_addr,\r\nunsigned int buffer_size)\r\n{\r\nsize_t pci_adp = 0;\r\nsize_t ptr = 0;\r\nif (stream_number == 0) {\r\npci_adp = READREG(PCI_ADP2);\r\nptr = pci_adp - (size_t) start_addr;\r\nif (ptr == buffer_size)\r\nptr = 0;\r\n}\r\nreturn ptr;\r\n}\r\nvoid snd_aw2_saa7146_use_digital_input(struct snd_aw2_saa7146 *chip,\r\nint use_digital)\r\n{\r\nif (use_digital)\r\nWRITEREG(0x40, GPIO_CTRL);\r\nelse\r\nWRITEREG(0x50, GPIO_CTRL);\r\n}\r\nint snd_aw2_saa7146_is_using_digital_input(struct snd_aw2_saa7146 *chip)\r\n{\r\nunsigned int reg_val = READREG(GPIO_CTRL);\r\nif ((reg_val & 0xFF) == 0x40)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int snd_aw2_saa7146_get_limit(int size)\r\n{\r\nint limitsize = 32;\r\nint limit = 0;\r\nwhile (limitsize < size) {\r\nlimitsize *= 2;\r\nlimit++;\r\n}\r\nreturn limit;\r\n}
