u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nif (phr->type != HPI_TYPE_RESPONSE) {\r\nHPI_DEBUG_LOG(ERROR, "header type %d invalid\n", phr->type);\r\nreturn HPI_ERROR_INVALID_RESPONSE;\r\n}\r\nif (phr->object != phm->object) {\r\nHPI_DEBUG_LOG(ERROR, "header object %d invalid\n",\r\nphr->object);\r\nreturn HPI_ERROR_INVALID_RESPONSE;\r\n}\r\nif (phr->function != phm->function) {\r\nHPI_DEBUG_LOG(ERROR, "header function %d invalid\n",\r\nphr->function);\r\nreturn HPI_ERROR_INVALID_RESPONSE;\r\n}\r\nreturn 0;\r\n}\r\nu16 hpi_add_adapter(struct hpi_adapter_obj *pao)\r\n{\r\nu16 retval = 0;\r\nhpios_alistlock_lock(&adapters);\r\nif (pao->index >= HPI_MAX_ADAPTERS) {\r\nretval = HPI_ERROR_BAD_ADAPTER_NUMBER;\r\ngoto unlock;\r\n}\r\nif (adapters.adapter[pao->index].type) {\r\nint a;\r\nfor (a = HPI_MAX_ADAPTERS - 1; a >= 0; a--) {\r\nif (!adapters.adapter[a].type) {\r\nHPI_DEBUG_LOG(WARNING,\r\n"ASI%X duplicate index %d moved to %d\n",\r\npao->type, pao->index, a);\r\npao->index = a;\r\nbreak;\r\n}\r\n}\r\nif (a < 0) {\r\nretval = HPI_ERROR_DUPLICATE_ADAPTER_NUMBER;\r\ngoto unlock;\r\n}\r\n}\r\nadapters.adapter[pao->index] = *pao;\r\nhpios_dsplock_init(&adapters.adapter[pao->index]);\r\nadapters.gw_num_adapters++;\r\nunlock:\r\nhpios_alistlock_unlock(&adapters);\r\nreturn retval;\r\n}\r\nvoid hpi_delete_adapter(struct hpi_adapter_obj *pao)\r\n{\r\nif (!pao->type) {\r\nHPI_DEBUG_LOG(ERROR, "removing null adapter?\n");\r\nreturn;\r\n}\r\nhpios_alistlock_lock(&adapters);\r\nif (adapters.adapter[pao->index].type)\r\nadapters.gw_num_adapters--;\r\nmemset(&adapters.adapter[pao->index], 0, sizeof(adapters.adapter[0]));\r\nhpios_alistlock_unlock(&adapters);\r\n}\r\nstruct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)\r\n{\r\nstruct hpi_adapter_obj *pao = NULL;\r\nif (adapter_index >= HPI_MAX_ADAPTERS) {\r\nHPI_DEBUG_LOG(VERBOSE, "find_adapter invalid index %d\n",\r\nadapter_index);\r\nreturn NULL;\r\n}\r\npao = &adapters.adapter[adapter_index];\r\nif (pao->type != 0) {\r\nreturn pao;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic void wipe_adapter_list(void)\r\n{\r\nmemset(&adapters, 0, sizeof(adapters));\r\n}\r\nstatic void subsys_get_adapter(struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nint count = phm->obj_index;\r\nu16 index = 0;\r\nfor (index = 0; index < HPI_MAX_ADAPTERS; index++) {\r\nif (adapters.adapter[index].type) {\r\nif (!count)\r\nbreak;\r\ncount--;\r\n}\r\n}\r\nif (index < HPI_MAX_ADAPTERS) {\r\nphr->u.s.adapter_index = adapters.adapter[index].index;\r\nphr->u.s.adapter_type = adapters.adapter[index].type;\r\n} else {\r\nphr->u.s.adapter_index = 0;\r\nphr->u.s.adapter_type = 0;\r\nphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\r\n}\r\n}\r\nstatic unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)\r\n{\r\nunsigned int i;\r\nint cached = 0;\r\nif (!pC)\r\nreturn 0;\r\nif (pC->init)\r\nreturn pC->init;\r\nif (!pC->p_cache)\r\nreturn 0;\r\nif (pC->control_count && pC->cache_size_in_bytes) {\r\nchar *p_master_cache;\r\nunsigned int byte_count = 0;\r\np_master_cache = (char *)pC->p_cache;\r\nHPI_DEBUG_LOG(DEBUG, "check %d controls\n",\r\npC->control_count);\r\nfor (i = 0; i < pC->control_count; i++) {\r\nstruct hpi_control_cache_info *info =\r\n(struct hpi_control_cache_info *)\r\n&p_master_cache[byte_count];\r\nu16 control_index = info->control_index;\r\nif (control_index >= pC->control_count) {\r\nHPI_DEBUG_LOG(INFO,\r\n"adap %d control index %d out of range, cache not ready?\n",\r\npC->adap_idx, control_index);\r\nreturn 0;\r\n}\r\nif (!info->size_in32bit_words) {\r\nif (!i) {\r\nHPI_DEBUG_LOG(INFO,\r\n"adap %d cache not ready?\n",\r\npC->adap_idx);\r\nreturn 0;\r\n}\r\nHPI_DEBUG_LOG(ERROR,\r\n"adap %d zero size cache entry %d\n",\r\npC->adap_idx, i);\r\nbreak;\r\n}\r\nif (info->control_type) {\r\npC->p_info[control_index] = info;\r\ncached++;\r\n} else {\r\npC->p_info[control_index] = NULL;\r\n}\r\nbyte_count += info->size_in32bit_words * 4;\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"cached %d, pinfo %p index %d type %d size %d\n",\r\ncached, pC->p_info[info->control_index],\r\ninfo->control_index, info->control_type,\r\ninfo->size_in32bit_words);\r\nif (byte_count >= pC->cache_size_in_bytes)\r\nbreak;\r\nif (info->control_index == pC->control_count - 1)\r\nbreak;\r\n}\r\nif (byte_count != pC->cache_size_in_bytes)\r\nHPI_DEBUG_LOG(WARNING,\r\n"adap %d bytecount %d != cache size %d\n",\r\npC->adap_idx, byte_count,\r\npC->cache_size_in_bytes);\r\nelse\r\nHPI_DEBUG_LOG(DEBUG,\r\n"adap %d cache good, bytecount == cache size = %d\n",\r\npC->adap_idx, byte_count);\r\npC->init = (u16)cached;\r\n}\r\nreturn pC->init;\r\n}\r\nstatic short find_control(u16 control_index,\r\nstruct hpi_control_cache *p_cache, struct hpi_control_cache_info **pI)\r\n{\r\nif (!control_cache_alloc_check(p_cache)) {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"control_cache_alloc_check() failed %d\n",\r\ncontrol_index);\r\nreturn 0;\r\n}\r\n*pI = p_cache->p_info[control_index];\r\nif (!*pI) {\r\nHPI_DEBUG_LOG(VERBOSE, "Uncached Control %d\n",\r\ncontrol_index);\r\nreturn 0;\r\n} else {\r\nHPI_DEBUG_LOG(VERBOSE, "find_control() type %d\n",\r\n(*pI)->control_type);\r\n}\r\nreturn 1;\r\n}\r\nshort hpi_check_control_cache_single(struct hpi_control_cache_single *pC,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nsize_t response_size;\r\nshort found = 1;\r\nresponse_size =\r\nsizeof(struct hpi_response_header) +\r\nsizeof(struct hpi_control_res);\r\nswitch (pC->u.i.control_type) {\r\ncase HPI_CONTROL_METER:\r\nif (phm->u.c.attribute == HPI_METER_PEAK) {\r\nphr->u.c.an_log_value[0] = pC->u.meter.an_log_peak[0];\r\nphr->u.c.an_log_value[1] = pC->u.meter.an_log_peak[1];\r\n} else if (phm->u.c.attribute == HPI_METER_RMS) {\r\nif (pC->u.meter.an_logRMS[0] ==\r\nHPI_CACHE_INVALID_SHORT) {\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\nphr->u.c.an_log_value[0] = HPI_METER_MINIMUM;\r\nphr->u.c.an_log_value[1] = HPI_METER_MINIMUM;\r\n} else {\r\nphr->u.c.an_log_value[0] =\r\npC->u.meter.an_logRMS[0];\r\nphr->u.c.an_log_value[1] =\r\npC->u.meter.an_logRMS[1];\r\n}\r\n} else\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_VOLUME:\r\nif (phm->u.c.attribute == HPI_VOLUME_GAIN) {\r\nphr->u.c.an_log_value[0] = pC->u.vol.an_log[0];\r\nphr->u.c.an_log_value[1] = pC->u.vol.an_log[1];\r\n} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {\r\nif (pC->u.vol.flags & HPI_VOLUME_FLAG_HAS_MUTE) {\r\nif (pC->u.vol.flags & HPI_VOLUME_FLAG_MUTED)\r\nphr->u.c.param1 =\r\nHPI_BITMASK_ALL_CHANNELS;\r\nelse\r\nphr->u.c.param1 = 0;\r\n} else {\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\nphr->u.c.param1 = 0;\r\n}\r\n} else {\r\nfound = 0;\r\n}\r\nbreak;\r\ncase HPI_CONTROL_MULTIPLEXER:\r\nif (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {\r\nphr->u.c.param1 = pC->u.mux.source_node_type;\r\nphr->u.c.param2 = pC->u.mux.source_node_index;\r\n} else {\r\nfound = 0;\r\n}\r\nbreak;\r\ncase HPI_CONTROL_CHANNEL_MODE:\r\nif (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)\r\nphr->u.c.param1 = pC->u.mode.mode;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_LEVEL:\r\nif (phm->u.c.attribute == HPI_LEVEL_GAIN) {\r\nphr->u.c.an_log_value[0] = pC->u.level.an_log[0];\r\nphr->u.c.an_log_value[1] = pC->u.level.an_log[1];\r\n} else\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_TUNER:\r\nif (phm->u.c.attribute == HPI_TUNER_FREQ)\r\nphr->u.c.param1 = pC->u.tuner.freq_ink_hz;\r\nelse if (phm->u.c.attribute == HPI_TUNER_BAND)\r\nphr->u.c.param1 = pC->u.tuner.band;\r\nelse if (phm->u.c.attribute == HPI_TUNER_LEVEL_AVG)\r\nif (pC->u.tuner.s_level_avg ==\r\nHPI_CACHE_INVALID_SHORT) {\r\nphr->u.cu.tuner.s_level = 0;\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\n} else\r\nphr->u.cu.tuner.s_level =\r\npC->u.tuner.s_level_avg;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_RECEIVER:\r\nif (phm->u.c.attribute == HPI_AESEBURX_ERRORSTATUS)\r\nphr->u.c.param1 = pC->u.aes3rx.error_status;\r\nelse if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)\r\nphr->u.c.param1 = pC->u.aes3rx.format;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_TRANSMITTER:\r\nif (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)\r\nphr->u.c.param1 = pC->u.aes3tx.format;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_TONEDETECTOR:\r\nif (phm->u.c.attribute == HPI_TONEDETECTOR_STATE)\r\nphr->u.c.param1 = pC->u.tone.state;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_SILENCEDETECTOR:\r\nif (phm->u.c.attribute == HPI_SILENCEDETECTOR_STATE) {\r\nphr->u.c.param1 = pC->u.silence.state;\r\n} else\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_MICROPHONE:\r\nif (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)\r\nphr->u.c.param1 = pC->u.microphone.phantom_state;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_SAMPLECLOCK:\r\nif (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)\r\nphr->u.c.param1 = pC->u.clk.source;\r\nelse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX) {\r\nif (pC->u.clk.source_index ==\r\nHPI_CACHE_INVALID_UINT16) {\r\nphr->u.c.param1 = 0;\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\n} else\r\nphr->u.c.param1 = pC->u.clk.source_index;\r\n} else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)\r\nphr->u.c.param1 = pC->u.clk.sample_rate;\r\nelse\r\nfound = 0;\r\nbreak;\r\ncase HPI_CONTROL_PAD:{\r\nstruct hpi_control_cache_pad *p_pad;\r\np_pad = (struct hpi_control_cache_pad *)pC;\r\nif (!(p_pad->field_valid_flags & (1 <<\r\nHPI_CTL_ATTR_INDEX(phm->u.c.\r\nattribute)))) {\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\nbreak;\r\n}\r\nif (phm->u.c.attribute == HPI_PAD_PROGRAM_ID)\r\nphr->u.c.param1 = p_pad->pI;\r\nelse if (phm->u.c.attribute == HPI_PAD_PROGRAM_TYPE)\r\nphr->u.c.param1 = p_pad->pTY;\r\nelse {\r\nunsigned int index =\r\nHPI_CTL_ATTR_INDEX(phm->u.c.\r\nattribute) - 1;\r\nunsigned int offset = phm->u.c.param1;\r\nunsigned int pad_string_len, field_size;\r\nchar *pad_string;\r\nunsigned int tocopy;\r\nif (index > ARRAY_SIZE(pad_desc) - 1) {\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\r\nbreak;\r\n}\r\npad_string =\r\n((char *)p_pad) +\r\npad_desc[index].offset;\r\nfield_size = pad_desc[index].field_size;\r\npad_string[field_size - 1] = 0;\r\npad_string_len = strlen(pad_string) + 1;\r\nif (offset > pad_string_len) {\r\nphr->error =\r\nHPI_ERROR_INVALID_CONTROL_VALUE;\r\nbreak;\r\n}\r\ntocopy = pad_string_len - offset;\r\nif (tocopy > sizeof(phr->u.cu.chars8.sz_data))\r\ntocopy = sizeof(phr->u.cu.chars8.\r\nsz_data);\r\nmemcpy(phr->u.cu.chars8.sz_data,\r\n&pad_string[offset], tocopy);\r\nphr->u.cu.chars8.remaining_chars =\r\npad_string_len - offset - tocopy;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nfound = 0;\r\nbreak;\r\n}\r\nHPI_DEBUG_LOG(VERBOSE, "%s Adap %d, Ctl %d, Type %d, Attr %d\n",\r\nfound ? "Cached" : "Uncached", phm->adapter_index,\r\npC->u.i.control_index, pC->u.i.control_type,\r\nphm->u.c.attribute);\r\nif (found) {\r\nphr->size = (u16)response_size;\r\nphr->type = HPI_TYPE_RESPONSE;\r\nphr->object = phm->object;\r\nphr->function = phm->function;\r\n}\r\nreturn found;\r\n}\r\nshort hpi_check_control_cache(struct hpi_control_cache *p_cache,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_control_cache_info *pI;\r\nif (!find_control(phm->obj_index, p_cache, &pI)) {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"HPICMN find_control() failed for adap %d\n",\r\nphm->adapter_index);\r\nreturn 0;\r\n}\r\nphr->error = 0;\r\nphr->specific_error = 0;\r\nphr->version = 0;\r\nreturn hpi_check_control_cache_single((struct hpi_control_cache_single\r\n*)pI, phm, phr);\r\n}\r\nvoid hpi_cmn_control_cache_sync_to_msg_single(struct hpi_control_cache_single\r\n*pC, struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (pC->u.i.control_type) {\r\ncase HPI_CONTROL_VOLUME:\r\nif (phm->u.c.attribute == HPI_VOLUME_GAIN) {\r\npC->u.vol.an_log[0] = phr->u.c.an_log_value[0];\r\npC->u.vol.an_log[1] = phr->u.c.an_log_value[1];\r\n} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {\r\nif (phm->u.c.param1)\r\npC->u.vol.flags |= HPI_VOLUME_FLAG_MUTED;\r\nelse\r\npC->u.vol.flags &= ~HPI_VOLUME_FLAG_MUTED;\r\n}\r\nbreak;\r\ncase HPI_CONTROL_MULTIPLEXER:\r\nif (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {\r\npC->u.mux.source_node_type = (u16)phm->u.c.param1;\r\npC->u.mux.source_node_index = (u16)phm->u.c.param2;\r\n}\r\nbreak;\r\ncase HPI_CONTROL_CHANNEL_MODE:\r\nif (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)\r\npC->u.mode.mode = (u16)phm->u.c.param1;\r\nbreak;\r\ncase HPI_CONTROL_LEVEL:\r\nif (phm->u.c.attribute == HPI_LEVEL_GAIN) {\r\npC->u.vol.an_log[0] = phr->u.c.an_log_value[0];\r\npC->u.vol.an_log[1] = phr->u.c.an_log_value[1];\r\n}\r\nbreak;\r\ncase HPI_CONTROL_MICROPHONE:\r\nif (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)\r\npC->u.microphone.phantom_state = (u16)phm->u.c.param1;\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_TRANSMITTER:\r\nif (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)\r\npC->u.aes3tx.format = phm->u.c.param1;\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_RECEIVER:\r\nif (phm->u.c.attribute == HPI_AESEBURX_FORMAT)\r\npC->u.aes3rx.format = phm->u.c.param1;\r\nbreak;\r\ncase HPI_CONTROL_SAMPLECLOCK:\r\nif (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)\r\npC->u.clk.source = (u16)phm->u.c.param1;\r\nelse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX)\r\npC->u.clk.source_index = (u16)phm->u.c.param1;\r\nelse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)\r\npC->u.clk.sample_rate = phm->u.c.param1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_control_cache_single *pC;\r\nstruct hpi_control_cache_info *pI;\r\nif (phr->error)\r\nreturn;\r\nif (!find_control(phm->obj_index, p_cache, &pI)) {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"HPICMN find_control() failed for adap %d\n",\r\nphm->adapter_index);\r\nreturn;\r\n}\r\npC = (struct hpi_control_cache_single *)pI;\r\nhpi_cmn_control_cache_sync_to_msg_single(pC, phm, phr);\r\n}\r\nstruct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,\r\nconst u32 size_in_bytes, u8 *p_dsp_control_buffer)\r\n{\r\nstruct hpi_control_cache *p_cache =\r\nkmalloc(sizeof(*p_cache), GFP_KERNEL);\r\nif (!p_cache)\r\nreturn NULL;\r\np_cache->p_info =\r\nkcalloc(control_count, sizeof(*p_cache->p_info), GFP_KERNEL);\r\nif (!p_cache->p_info) {\r\nkfree(p_cache);\r\nreturn NULL;\r\n}\r\np_cache->cache_size_in_bytes = size_in_bytes;\r\np_cache->control_count = control_count;\r\np_cache->p_cache = p_dsp_control_buffer;\r\np_cache->init = 0;\r\nreturn p_cache;\r\n}\r\nvoid hpi_free_control_cache(struct hpi_control_cache *p_cache)\r\n{\r\nif (p_cache) {\r\nkfree(p_cache->p_info);\r\nkfree(p_cache);\r\n}\r\n}\r\nstatic void subsys_message(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function, 0);\r\nswitch (phm->function) {\r\ncase HPI_SUBSYS_OPEN:\r\ncase HPI_SUBSYS_CLOSE:\r\ncase HPI_SUBSYS_DRIVER_UNLOAD:\r\nbreak;\r\ncase HPI_SUBSYS_DRIVER_LOAD:\r\nwipe_adapter_list();\r\nhpios_alistlock_init(&adapters);\r\nbreak;\r\ncase HPI_SUBSYS_GET_ADAPTER:\r\nsubsys_get_adapter(phm, phr);\r\nbreak;\r\ncase HPI_SUBSYS_GET_NUM_ADAPTERS:\r\nphr->u.s.num_adapters = adapters.gw_num_adapters;\r\nbreak;\r\ncase HPI_SUBSYS_CREATE_ADAPTER:\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\n}\r\n}\r\nvoid HPI_COMMON(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->type) {\r\ncase HPI_TYPE_REQUEST:\r\nswitch (phm->object) {\r\ncase HPI_OBJ_SUBSYSTEM:\r\nsubsys_message(phm, phr);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_TYPE;\r\nbreak;\r\n}\r\n}
