static int bd6107_write(struct bd6107 *bd, u8 reg, u8 data)\r\n{\r\nreturn i2c_smbus_write_byte_data(bd->client, reg, data);\r\n}\r\nstatic int bd6107_backlight_update_status(struct backlight_device *backlight)\r\n{\r\nstruct bd6107 *bd = bl_get_data(backlight);\r\nint brightness = backlight->props.brightness;\r\nif (backlight->props.power != FB_BLANK_UNBLANK ||\r\nbacklight->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbacklight->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nif (brightness) {\r\nbd6107_write(bd, BD6107_PORTSEL, BD6107_PORTSEL_LEDM(2) |\r\nBD6107_PORTSEL_LEDM(1) | BD6107_PORTSEL_LEDM(0));\r\nbd6107_write(bd, BD6107_MAINCNT1, brightness);\r\nbd6107_write(bd, BD6107_LEDCNT1, BD6107_LEDCNT1_LEDONOFF1);\r\n} else {\r\ngpio_set_value(bd->pdata->reset, 0);\r\nmsleep(24);\r\ngpio_set_value(bd->pdata->reset, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bd6107_backlight_check_fb(struct backlight_device *backlight,\r\nstruct fb_info *info)\r\n{\r\nstruct bd6107 *bd = bl_get_data(backlight);\r\nreturn bd->pdata->fbdev == NULL || bd->pdata->fbdev == info->dev;\r\n}\r\nstatic int bd6107_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bd6107_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct backlight_device *backlight;\r\nstruct backlight_properties props;\r\nstruct bd6107 *bd;\r\nint ret;\r\nif (pdata == NULL || !pdata->reset) {\r\ndev_err(&client->dev, "No reset GPIO in platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&client->dev,\r\n"I2C adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");\r\nreturn -EIO;\r\n}\r\nbd = devm_kzalloc(&client->dev, sizeof(*bd), GFP_KERNEL);\r\nif (!bd)\r\nreturn -ENOMEM;\r\nbd->client = client;\r\nbd->pdata = pdata;\r\nret = devm_gpio_request_one(&client->dev, pdata->reset,\r\nGPIOF_DIR_OUT | GPIOF_INIT_LOW, "reset");\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to request reset GPIO\n");\r\nreturn ret;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 128;\r\nprops.brightness = clamp_t(unsigned int, pdata->def_value, 0,\r\nprops.max_brightness);\r\nbacklight = devm_backlight_device_register(&client->dev,\r\ndev_name(&client->dev),\r\n&bd->client->dev, bd,\r\n&bd6107_backlight_ops, &props);\r\nif (IS_ERR(backlight)) {\r\ndev_err(&client->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(backlight);\r\n}\r\nbacklight_update_status(backlight);\r\ni2c_set_clientdata(client, backlight);\r\nreturn 0;\r\n}\r\nstatic int bd6107_remove(struct i2c_client *client)\r\n{\r\nstruct backlight_device *backlight = i2c_get_clientdata(client);\r\nbacklight->props.brightness = 0;\r\nbacklight_update_status(backlight);\r\nreturn 0;\r\n}
