void __init btrfs_props_init(void)\r\n{\r\nstruct prop_handler *p;\r\nhash_init(prop_handlers_ht);\r\nfor (p = &prop_handlers[0]; p->xattr_name; p++) {\r\nu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\r\nhash_add(prop_handlers_ht, &p->node, h);\r\n}\r\n}\r\nstatic const struct hlist_head *find_prop_handlers_by_hash(const u64 hash)\r\n{\r\nstruct hlist_head *h;\r\nh = &prop_handlers_ht[hash_min(hash, BTRFS_PROP_HANDLERS_HT_BITS)];\r\nif (hlist_empty(h))\r\nreturn NULL;\r\nreturn h;\r\n}\r\nstatic const struct prop_handler *\r\nfind_prop_handler(const char *name,\r\nconst struct hlist_head *handlers)\r\n{\r\nstruct prop_handler *h;\r\nif (!handlers) {\r\nu64 hash = btrfs_name_hash(name, strlen(name));\r\nhandlers = find_prop_handlers_by_hash(hash);\r\nif (!handlers)\r\nreturn NULL;\r\n}\r\nhlist_for_each_entry(h, handlers, node)\r\nif (!strcmp(h->xattr_name, name))\r\nreturn h;\r\nreturn NULL;\r\n}\r\nstatic int __btrfs_set_prop(struct btrfs_trans_handle *trans,\r\nstruct inode *inode,\r\nconst char *name,\r\nconst char *value,\r\nsize_t value_len,\r\nint flags)\r\n{\r\nconst struct prop_handler *handler;\r\nint ret;\r\nif (strlen(name) <= XATTR_BTRFS_PREFIX_LEN)\r\nreturn -EINVAL;\r\nhandler = find_prop_handler(name, NULL);\r\nif (!handler)\r\nreturn -EINVAL;\r\nif (value_len == 0) {\r\nret = __btrfs_setxattr(trans, inode, handler->xattr_name,\r\nNULL, 0, flags);\r\nif (ret)\r\nreturn ret;\r\nret = handler->apply(inode, NULL, 0);\r\nASSERT(ret == 0);\r\nreturn ret;\r\n}\r\nret = handler->validate(value, value_len);\r\nif (ret)\r\nreturn ret;\r\nret = __btrfs_setxattr(trans, inode, handler->xattr_name,\r\nvalue, value_len, flags);\r\nif (ret)\r\nreturn ret;\r\nret = handler->apply(inode, value, value_len);\r\nif (ret) {\r\n__btrfs_setxattr(trans, inode, handler->xattr_name,\r\nNULL, 0, flags);\r\nreturn ret;\r\n}\r\nset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\r\nreturn 0;\r\n}\r\nint btrfs_set_prop(struct inode *inode,\r\nconst char *name,\r\nconst char *value,\r\nsize_t value_len,\r\nint flags)\r\n{\r\nreturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\r\n}\r\nstatic int iterate_object_props(struct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nu64 objectid,\r\nvoid (*iterator)(void *,\r\nconst struct prop_handler *,\r\nconst char *,\r\nsize_t),\r\nvoid *ctx)\r\n{\r\nint ret;\r\nchar *name_buf = NULL;\r\nchar *value_buf = NULL;\r\nint name_buf_len = 0;\r\nint value_buf_len = 0;\r\nwhile (1) {\r\nstruct btrfs_key key;\r\nstruct btrfs_dir_item *di;\r\nstruct extent_buffer *leaf;\r\nu32 total_len, cur, this_len;\r\nint slot;\r\nconst struct hlist_head *handlers;\r\nslot = path->slots[0];\r\nleaf = path->nodes[0];\r\nif (slot >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret < 0)\r\ngoto out;\r\nelse if (ret > 0)\r\nbreak;\r\ncontinue;\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, slot);\r\nif (key.objectid != objectid)\r\nbreak;\r\nif (key.type != BTRFS_XATTR_ITEM_KEY)\r\nbreak;\r\nhandlers = find_prop_handlers_by_hash(key.offset);\r\nif (!handlers)\r\ngoto next_slot;\r\ndi = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);\r\ncur = 0;\r\ntotal_len = btrfs_item_size_nr(leaf, slot);\r\nwhile (cur < total_len) {\r\nu32 name_len = btrfs_dir_name_len(leaf, di);\r\nu32 data_len = btrfs_dir_data_len(leaf, di);\r\nunsigned long name_ptr, data_ptr;\r\nconst struct prop_handler *handler;\r\nthis_len = sizeof(*di) + name_len + data_len;\r\nname_ptr = (unsigned long)(di + 1);\r\ndata_ptr = name_ptr + name_len;\r\nif (name_len <= XATTR_BTRFS_PREFIX_LEN ||\r\nmemcmp_extent_buffer(leaf, XATTR_BTRFS_PREFIX,\r\nname_ptr,\r\nXATTR_BTRFS_PREFIX_LEN))\r\ngoto next_dir_item;\r\nif (name_len >= name_buf_len) {\r\nkfree(name_buf);\r\nname_buf_len = name_len + 1;\r\nname_buf = kmalloc(name_buf_len, GFP_NOFS);\r\nif (!name_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nread_extent_buffer(leaf, name_buf, name_ptr, name_len);\r\nname_buf[name_len] = '\0';\r\nhandler = find_prop_handler(name_buf, handlers);\r\nif (!handler)\r\ngoto next_dir_item;\r\nif (data_len > value_buf_len) {\r\nkfree(value_buf);\r\nvalue_buf_len = data_len;\r\nvalue_buf = kmalloc(data_len, GFP_NOFS);\r\nif (!value_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nread_extent_buffer(leaf, value_buf, data_ptr, data_len);\r\niterator(ctx, handler, value_buf, data_len);\r\nnext_dir_item:\r\ncur += this_len;\r\ndi = (struct btrfs_dir_item *)((char *) di + this_len);\r\n}\r\nnext_slot:\r\npath->slots[0]++;\r\n}\r\nret = 0;\r\nout:\r\nbtrfs_release_path(path);\r\nkfree(name_buf);\r\nkfree(value_buf);\r\nreturn ret;\r\n}\r\nstatic void inode_prop_iterator(void *ctx,\r\nconst struct prop_handler *handler,\r\nconst char *value,\r\nsize_t len)\r\n{\r\nstruct inode *inode = ctx;\r\nstruct btrfs_root *root = BTRFS_I(inode)->root;\r\nint ret;\r\nret = handler->apply(inode, value, len);\r\nif (unlikely(ret))\r\nbtrfs_warn(root->fs_info,\r\n"error applying prop %s to ino %llu (root %llu): %d",\r\nhandler->xattr_name, btrfs_ino(inode),\r\nroot->root_key.objectid, ret);\r\nelse\r\nset_bit(BTRFS_INODE_HAS_PROPS, &BTRFS_I(inode)->runtime_flags);\r\n}\r\nint btrfs_load_inode_props(struct inode *inode, struct btrfs_path *path)\r\n{\r\nstruct btrfs_root *root = BTRFS_I(inode)->root;\r\nu64 ino = btrfs_ino(inode);\r\nint ret;\r\nret = iterate_object_props(root, path, ino, inode_prop_iterator, inode);\r\nreturn ret;\r\n}\r\nstatic int inherit_props(struct btrfs_trans_handle *trans,\r\nstruct inode *inode,\r\nstruct inode *parent)\r\n{\r\nconst struct prop_handler *h;\r\nstruct btrfs_root *root = BTRFS_I(inode)->root;\r\nint ret;\r\nif (!test_bit(BTRFS_INODE_HAS_PROPS,\r\n&BTRFS_I(parent)->runtime_flags))\r\nreturn 0;\r\nfor (h = &prop_handlers[0]; h->xattr_name; h++) {\r\nconst char *value;\r\nu64 num_bytes;\r\nif (!h->inheritable)\r\ncontinue;\r\nvalue = h->extract(parent);\r\nif (!value)\r\ncontinue;\r\nnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\r\nret = btrfs_block_rsv_add(root, trans->block_rsv,\r\nnum_bytes, BTRFS_RESERVE_NO_FLUSH);\r\nif (ret)\r\ngoto out;\r\nret = __btrfs_set_prop(trans, inode, h->xattr_name,\r\nvalue, strlen(value), 0);\r\nbtrfs_block_rsv_release(root, trans->block_rsv, num_bytes);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nint btrfs_inode_inherit_props(struct btrfs_trans_handle *trans,\r\nstruct inode *inode,\r\nstruct inode *dir)\r\n{\r\nif (!dir)\r\nreturn 0;\r\nreturn inherit_props(trans, inode, dir);\r\n}\r\nint btrfs_subvol_inherit_props(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_root *parent_root)\r\n{\r\nstruct btrfs_key key;\r\nstruct inode *parent_inode, *child_inode;\r\nint ret;\r\nkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\r\nkey.type = BTRFS_INODE_ITEM_KEY;\r\nkey.offset = 0;\r\nparent_inode = btrfs_iget(parent_root->fs_info->sb, &key,\r\nparent_root, NULL);\r\nif (IS_ERR(parent_inode))\r\nreturn PTR_ERR(parent_inode);\r\nchild_inode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\r\nif (IS_ERR(child_inode)) {\r\niput(parent_inode);\r\nreturn PTR_ERR(child_inode);\r\n}\r\nret = inherit_props(trans, child_inode, parent_inode);\r\niput(child_inode);\r\niput(parent_inode);\r\nreturn ret;\r\n}\r\nstatic int prop_compression_validate(const char *value, size_t len)\r\n{\r\nif (!strncmp("lzo", value, len))\r\nreturn 0;\r\nelse if (!strncmp("zlib", value, len))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int prop_compression_apply(struct inode *inode,\r\nconst char *value,\r\nsize_t len)\r\n{\r\nint type;\r\nif (len == 0) {\r\nBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\r\nBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\r\nBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\r\nreturn 0;\r\n}\r\nif (!strncmp("lzo", value, len))\r\ntype = BTRFS_COMPRESS_LZO;\r\nelse if (!strncmp("zlib", value, len))\r\ntype = BTRFS_COMPRESS_ZLIB;\r\nelse\r\nreturn -EINVAL;\r\nBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\r\nBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\r\nBTRFS_I(inode)->force_compress = type;\r\nreturn 0;\r\n}\r\nstatic const char *prop_compression_extract(struct inode *inode)\r\n{\r\nswitch (BTRFS_I(inode)->force_compress) {\r\ncase BTRFS_COMPRESS_ZLIB:\r\nreturn "zlib";\r\ncase BTRFS_COMPRESS_LZO:\r\nreturn "lzo";\r\n}\r\nreturn NULL;\r\n}
