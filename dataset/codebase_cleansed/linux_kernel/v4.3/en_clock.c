static cycle_t mlx4_en_read_clock(const struct cyclecounter *tc)\r\n{\r\nstruct mlx4_en_dev *mdev =\r\ncontainer_of(tc, struct mlx4_en_dev, cycles);\r\nstruct mlx4_dev *dev = mdev->dev;\r\nreturn mlx4_read_clock(dev) & tc->mask;\r\n}\r\nu64 mlx4_en_get_cqe_ts(struct mlx4_cqe *cqe)\r\n{\r\nu64 hi, lo;\r\nstruct mlx4_ts_cqe *ts_cqe = (struct mlx4_ts_cqe *)cqe;\r\nlo = (u64)be16_to_cpu(ts_cqe->timestamp_lo);\r\nhi = ((u64)be32_to_cpu(ts_cqe->timestamp_hi) + !lo) << 16;\r\nreturn hi | lo;\r\n}\r\nvoid mlx4_en_fill_hwtstamps(struct mlx4_en_dev *mdev,\r\nstruct skb_shared_hwtstamps *hwts,\r\nu64 timestamp)\r\n{\r\nunsigned long flags;\r\nu64 nsec;\r\nread_lock_irqsave(&mdev->clock_lock, flags);\r\nnsec = timecounter_cyc2time(&mdev->clock, timestamp);\r\nread_unlock_irqrestore(&mdev->clock_lock, flags);\r\nmemset(hwts, 0, sizeof(struct skb_shared_hwtstamps));\r\nhwts->hwtstamp = ns_to_ktime(nsec);\r\n}\r\nvoid mlx4_en_remove_timestamp(struct mlx4_en_dev *mdev)\r\n{\r\nif (mdev->ptp_clock) {\r\nptp_clock_unregister(mdev->ptp_clock);\r\nmdev->ptp_clock = NULL;\r\nmlx4_info(mdev, "removed PHC\n");\r\n}\r\n}\r\nvoid mlx4_en_ptp_overflow_check(struct mlx4_en_dev *mdev)\r\n{\r\nbool timeout = time_is_before_jiffies(mdev->last_overflow_check +\r\nmdev->overflow_period);\r\nunsigned long flags;\r\nif (timeout) {\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_read(&mdev->clock);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nmdev->last_overflow_check = jiffies;\r\n}\r\n}\r\nstatic int mlx4_en_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nu64 adj;\r\nu32 diff, mult;\r\nint neg_adj = 0;\r\nunsigned long flags;\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nif (delta < 0) {\r\nneg_adj = 1;\r\ndelta = -delta;\r\n}\r\nmult = mdev->nominal_c_mult;\r\nadj = mult;\r\nadj *= delta;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_read(&mdev->clock);\r\nmdev->cycles.mult = neg_adj ? mult - diff : mult + diff;\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_adjtime(&mdev->clock, delta);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_gettime(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 ns;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\nns = timecounter_read(&mdev->clock);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\r\nptp_clock_info);\r\nu64 ns = timespec64_to_ns(ts);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_init(&mdev->clock, &mdev->cycles, ns);\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_phc_enable(struct ptp_clock_info __always_unused *ptp,\r\nstruct ptp_clock_request __always_unused *request,\r\nint __always_unused on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)\r\n{\r\nstruct mlx4_dev *dev = mdev->dev;\r\nunsigned long flags;\r\nu64 ns, zero = 0;\r\nrwlock_init(&mdev->clock_lock);\r\nmemset(&mdev->cycles, 0, sizeof(mdev->cycles));\r\nmdev->cycles.read = mlx4_en_read_clock;\r\nmdev->cycles.mask = CLOCKSOURCE_MASK(48);\r\nmdev->cycles.shift = 14;\r\nmdev->cycles.mult =\r\nclocksource_khz2mult(1000 * dev->caps.hca_core_clock, mdev->cycles.shift);\r\nmdev->nominal_c_mult = mdev->cycles.mult;\r\nwrite_lock_irqsave(&mdev->clock_lock, flags);\r\ntimecounter_init(&mdev->clock, &mdev->cycles,\r\nktime_to_ns(ktime_get_real()));\r\nwrite_unlock_irqrestore(&mdev->clock_lock, flags);\r\nns = cyclecounter_cyc2ns(&mdev->cycles, mdev->cycles.mask, zero, &zero);\r\ndo_div(ns, NSEC_PER_SEC / 2 / HZ);\r\nmdev->overflow_period = ns;\r\nmdev->ptp_clock_info = mlx4_en_ptp_clock_info;\r\nsnprintf(mdev->ptp_clock_info.name, 16, "mlx4 ptp");\r\nmdev->ptp_clock = ptp_clock_register(&mdev->ptp_clock_info,\r\n&mdev->pdev->dev);\r\nif (IS_ERR(mdev->ptp_clock)) {\r\nmdev->ptp_clock = NULL;\r\nmlx4_err(mdev, "ptp_clock_register failed\n");\r\n} else {\r\nmlx4_info(mdev, "registered PHC clock\n");\r\n}\r\n}
