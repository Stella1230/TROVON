static int cdc_mbim_manage_power(struct usbnet *dev, int on)\r\n{\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nint rv = 0;\r\ndev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__, atomic_read(&info->pmcount), on);\r\nif ((on && atomic_add_return(1, &info->pmcount) == 1) || (!on && atomic_dec_and_test(&info->pmcount))) {\r\nrv = usb_autopm_get_interface(dev->intf);\r\ndev->intf->needs_remote_wakeup = on;\r\nif (!rv)\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_wdm_manage_power(struct usb_interface *intf, int status)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nreturn cdc_mbim_manage_power(dev, status);\r\n}\r\nstatic int cdc_mbim_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nif (vid == MBIM_IPS0_VID)\r\ninfo->flags |= FLAG_IPS0_VLAN;\r\nelse\r\nif (vid >= 512)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nif (vid == MBIM_IPS0_VID)\r\ninfo->flags &= ~FLAG_IPS0_VLAN;\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_set_ctrlalt(struct usbnet *dev, struct usb_interface *intf, u8 alt)\r\n{\r\nstruct usb_driver *driver = to_usb_driver(intf->dev.driver);\r\nconst struct usb_device_id *id;\r\nstruct driver_info *info;\r\nint ret;\r\nret = usb_set_interface(dev->udev,\r\nintf->cur_altsetting->desc.bInterfaceNumber,\r\nalt);\r\nif (ret)\r\nreturn ret;\r\nid = usb_match_id(intf, driver->id_table);\r\nif (!id)\r\nreturn -ENODEV;\r\ninfo = (struct driver_info *)id->driver_info;\r\nif (info != dev->driver_info) {\r\ndev_dbg(&intf->dev, "driver_info updated to '%s'\n",\r\ninfo->description);\r\ndev->driver_info = info;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_driver *subdriver = ERR_PTR(-ENODEV);\r\nint ret = -ENODEV;\r\nu8 data_altsetting = 1;\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nif (cdc_ncm_select_altsetting(intf) == CDC_NCM_COMM_ALTSETTING_MBIM) {\r\ndata_altsetting = CDC_NCM_DATA_ALTSETTING_MBIM;\r\nret = cdc_mbim_set_ctrlalt(dev, intf, CDC_NCM_COMM_ALTSETTING_MBIM);\r\nif (ret)\r\ngoto err;\r\nret = -ENODEV;\r\n}\r\nif (!cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))\r\ngoto err;\r\nret = cdc_ncm_bind_common(dev, intf, data_altsetting, 0);\r\nif (ret)\r\ngoto err;\r\nctx = info->ctx;\r\nif (ctx->mbim_desc && dev->status)\r\nsubdriver = usb_cdc_wdm_register(ctx->control,\r\n&dev->status->desc,\r\nle16_to_cpu(ctx->mbim_desc->wMaxControlMessage),\r\ncdc_mbim_wdm_manage_power);\r\nif (IS_ERR(subdriver)) {\r\nret = PTR_ERR(subdriver);\r\ncdc_ncm_unbind(dev, intf);\r\ngoto err;\r\n}\r\ndev->status = NULL;\r\ninfo->subdriver = subdriver;\r\ndev->net->flags |= IFF_NOARP;\r\ndev->net->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_FILTER;\r\ndev->net->netdev_ops = &cdc_mbim_netdev_ops;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void cdc_mbim_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nif (info->subdriver && info->subdriver->disconnect)\r\ninfo->subdriver->disconnect(ctx->control);\r\ninfo->subdriver = NULL;\r\ncdc_ncm_unbind(dev, intf);\r\n}\r\nstatic bool is_ip_proto(__be16 proto)\r\n{\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\ncase htons(ETH_P_IPV6):\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct sk_buff *cdc_mbim_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\n__le32 sign = cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN);\r\nu16 tci = 0;\r\nbool is_ip;\r\nu8 *c;\r\nif (!ctx)\r\ngoto error;\r\nif (skb) {\r\nif (skb->len <= ETH_HLEN)\r\ngoto error;\r\nskb_reset_mac_header(skb);\r\nif (vlan_get_tag(skb, &tci) < 0 && skb->len > VLAN_ETH_HLEN &&\r\n__vlan_get_tag(skb, &tci) == 0) {\r\nis_ip = is_ip_proto(vlan_eth_hdr(skb)->h_vlan_encapsulated_proto);\r\nskb_pull(skb, VLAN_ETH_HLEN);\r\n} else {\r\nis_ip = is_ip_proto(eth_hdr(skb)->h_proto);\r\nskb_pull(skb, ETH_HLEN);\r\n}\r\nif (info->flags & FLAG_IPS0_VLAN) {\r\nif (!tci)\r\ngoto error;\r\nif (tci == MBIM_IPS0_VID)\r\ntci = 0;\r\n}\r\nswitch (tci & 0x0f00) {\r\ncase 0x0000:\r\nif (!is_ip)\r\ngoto error;\r\nc = (u8 *)&sign;\r\nc[3] = tci;\r\nbreak;\r\ncase 0x0100:\r\nif (is_ip)\r\ngoto error;\r\nsign = cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN);\r\nc = (u8 *)&sign;\r\nc[3] = tci;\r\nbreak;\r\ndefault:\r\nnetif_err(dev, tx_err, dev->net,\r\n"unsupported tci=0x%04x\n", tci);\r\ngoto error;\r\n}\r\n}\r\nspin_lock_bh(&ctx->mtx);\r\nskb_out = cdc_ncm_fill_tx_frame(dev, skb, sign);\r\nspin_unlock_bh(&ctx->mtx);\r\nreturn skb_out;\r\nerror:\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic void do_neigh_solicit(struct usbnet *dev, u8 *buf, u16 tci)\r\n{\r\nstruct ipv6hdr *iph = (void *)buf;\r\nstruct nd_msg *msg = (void *)(iph + 1);\r\nstruct net_device *netdev;\r\nstruct inet6_dev *in6_dev;\r\nbool is_router;\r\nif (!ipv6_addr_is_solict_mult(&iph->daddr) ||\r\n!(ipv6_addr_type(&iph->saddr) & IPV6_ADDR_UNICAST))\r\nreturn;\r\nrcu_read_lock();\r\nif (tci) {\r\nnetdev = __vlan_find_dev_deep_rcu(dev->net, htons(ETH_P_8021Q),\r\ntci);\r\nif (!netdev) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\n} else {\r\nnetdev = dev->net;\r\n}\r\ndev_hold(netdev);\r\nrcu_read_unlock();\r\nin6_dev = in6_dev_get(netdev);\r\nif (!in6_dev)\r\ngoto out;\r\nis_router = !!in6_dev->cnf.forwarding;\r\nin6_dev_put(in6_dev);\r\nipv6_stub->ndisc_send_na(netdev, NULL, &iph->saddr, &msg->target,\r\nis_router ,\r\ntrue ,\r\nfalse ,\r\ntrue );\r\nout:\r\ndev_put(netdev);\r\n}\r\nstatic bool is_neigh_solicit(u8 *buf, size_t len)\r\n{\r\nstruct ipv6hdr *iph = (void *)buf;\r\nstruct nd_msg *msg = (void *)(iph + 1);\r\nreturn (len >= sizeof(struct ipv6hdr) + sizeof(struct nd_msg) &&\r\niph->nexthdr == IPPROTO_ICMPV6 &&\r\nmsg->icmph.icmp6_code == 0 &&\r\nmsg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION);\r\n}\r\nstatic struct sk_buff *cdc_mbim_process_dgram(struct usbnet *dev, u8 *buf, size_t len, u16 tci)\r\n{\r\n__be16 proto = htons(ETH_P_802_3);\r\nstruct sk_buff *skb = NULL;\r\nif (tci < 256 || tci == MBIM_IPS0_VID) {\r\nif (len < sizeof(struct iphdr))\r\ngoto err;\r\nswitch (*buf & 0xf0) {\r\ncase 0x40:\r\nproto = htons(ETH_P_IP);\r\nbreak;\r\ncase 0x60:\r\nif (is_neigh_solicit(buf, len))\r\ndo_neigh_solicit(dev, buf, tci);\r\nproto = htons(ETH_P_IPV6);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\nskb = netdev_alloc_skb_ip_align(dev->net, len + ETH_HLEN);\r\nif (!skb)\r\ngoto err;\r\nskb_put(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\neth_hdr(skb)->h_proto = proto;\r\neth_zero_addr(eth_hdr(skb)->h_source);\r\nmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nmemcpy(skb_put(skb, len), buf, len);\r\nif (tci)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tci);\r\nerr:\r\nreturn skb;\r\n}\r\nstatic int cdc_mbim_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nint len;\r\nint nframes;\r\nint x;\r\nint offset;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct usb_cdc_ncm_dpe16 *dpe16;\r\nint ndpoffset;\r\nint loopcount = 50;\r\nu32 payload = 0;\r\nu8 *c;\r\nu16 tci;\r\nndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\r\nif (ndpoffset < 0)\r\ngoto error;\r\nnext_ndp:\r\nnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\r\nif (nframes < 0)\r\ngoto error;\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nswitch (ndp16->dwSignature & cpu_to_le32(0x00ffffff)) {\r\ncase cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN):\r\nc = (u8 *)&ndp16->dwSignature;\r\ntci = c[3];\r\nif (!tci && info->flags & FLAG_IPS0_VLAN)\r\ntci = MBIM_IPS0_VID;\r\nbreak;\r\ncase cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN):\r\nc = (u8 *)&ndp16->dwSignature;\r\ntci = c[3] + 256;\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"unsupported NDP signature <0x%08x>\n",\r\nle32_to_cpu(ndp16->dwSignature));\r\ngoto err_ndp;\r\n}\r\ndpe16 = ndp16->dpe16;\r\nfor (x = 0; x < nframes; x++, dpe16++) {\r\noffset = le16_to_cpu(dpe16->wDatagramIndex);\r\nlen = le16_to_cpu(dpe16->wDatagramLength);\r\nif ((offset == 0) || (len == 0)) {\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n}\r\nif (((offset + len) > skb_in->len) || (len > ctx->rx_max)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\n",\r\nx, offset, len, skb_in);\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n} else {\r\nskb = cdc_mbim_process_dgram(dev, skb_in->data + offset, len, tci);\r\nif (!skb)\r\ngoto error;\r\nusbnet_skb_return(dev, skb);\r\npayload += len;\r\n}\r\n}\r\nerr_ndp:\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\nif (ndpoffset && loopcount--)\r\ngoto next_ndp;\r\nctx->rx_overhead += skb_in->len - payload;\r\nctx->rx_ntbs++;\r\nreturn 1;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic int cdc_mbim_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nint ret = -ENODEV;\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nif (!ctx)\r\ngoto error;\r\nret = usbnet_suspend(intf, message);\r\nif (ret < 0)\r\ngoto error;\r\nif (intf == ctx->control && info->subdriver && info->subdriver->suspend)\r\nret = info->subdriver->suspend(intf, message);\r\nif (ret < 0)\r\nusbnet_resume(intf);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int cdc_mbim_resume(struct usb_interface *intf)\r\n{\r\nint ret = 0;\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct cdc_mbim_state *info = (void *)&dev->data;\r\nstruct cdc_ncm_ctx *ctx = info->ctx;\r\nbool callsub = (intf == ctx->control && info->subdriver && info->subdriver->resume);\r\nif (callsub)\r\nret = info->subdriver->resume(intf);\r\nif (ret < 0)\r\ngoto err;\r\nret = usbnet_resume(intf);\r\nif (ret < 0 && callsub)\r\ninfo->subdriver->suspend(intf, PMSG_SUSPEND);\r\nerr:\r\nreturn ret;\r\n}
