static int nct7904_bank_lock(struct nct7904_data *data, unsigned bank)\r\n{\r\nint ret;\r\nmutex_lock(&data->bank_lock);\r\nif (data->bank_sel == bank)\r\nreturn 0;\r\nret = i2c_smbus_write_byte_data(data->client, BANK_SEL_REG, bank);\r\nif (ret == 0)\r\ndata->bank_sel = bank;\r\nelse\r\ndata->bank_sel = -1;\r\nreturn ret;\r\n}\r\nstatic inline void nct7904_bank_release(struct nct7904_data *data)\r\n{\r\nmutex_unlock(&data->bank_lock);\r\n}\r\nstatic int nct7904_read_reg(struct nct7904_data *data,\r\nunsigned bank, unsigned reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0)\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic int nct7904_read_reg16(struct nct7904_data *data,\r\nunsigned bank, unsigned reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret, hi;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0) {\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret >= 0) {\r\nhi = ret;\r\nret = i2c_smbus_read_byte_data(client, reg + 1);\r\nif (ret >= 0)\r\nret |= hi << 8;\r\n}\r\n}\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic int nct7904_write_reg(struct nct7904_data *data,\r\nunsigned bank, unsigned reg, u8 val)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0)\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_fan(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nunsigned cnt, rpm;\r\nret = nct7904_read_reg16(data, BANK_0, FANIN1_HV_REG + index * 2);\r\nif (ret < 0)\r\nreturn ret;\r\ncnt = ((ret & 0xff00) >> 3) | (ret & 0x1f);\r\nif (cnt == 0x1fff)\r\nrpm = 0;\r\nelse\r\nrpm = 1350000 / cnt;\r\nreturn sprintf(buf, "%u\n", rpm);\r\n}\r\nstatic umode_t nct7904_fanin_is_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nif (data->fanin_mask & (1 << n))\r\nreturn a->mode;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_voltage(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nint volt;\r\nret = nct7904_read_reg16(data, BANK_0, VSEN1_HV_REG + index * 2);\r\nif (ret < 0)\r\nreturn ret;\r\nvolt = ((ret & 0xff00) >> 5) | (ret & 0x7);\r\nif (index < 14)\r\nvolt *= 2;\r\nelse\r\nvolt *= 6;\r\nreturn sprintf(buf, "%d\n", volt);\r\n}\r\nstatic ssize_t show_ltemp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nint temp;\r\nret = nct7904_read_reg16(data, BANK_0, LTD_HV_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = ((ret & 0xff00) >> 5) | (ret & 0x7);\r\ntemp = sign_extend32(temp, 10) * 125;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic umode_t nct7904_vsen_is_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nif (data->vsen_mask & (1 << n))\r\nreturn a->mode;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_tcpu(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nint temp;\r\nret = nct7904_read_reg16(data, BANK_0, T_CPU1_HV_REG + index * 2);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = ((ret & 0xff00) >> 5) | (ret & 0x7);\r\ntemp = sign_extend32(temp, 10) * 125;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic umode_t nct7904_tcpu_is_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nif (data->tcpu_mask & (1 << n))\r\nreturn a->mode;\r\nreturn 0;\r\n}\r\nstatic ssize_t store_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nret = nct7904_write_reg(data, BANK_3, FANCTL1_OUT_REG + index, val);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint val;\r\nval = nct7904_read_reg(data, BANK_3, FANCTL1_OUT_REG + index);\r\nif (val < 0)\r\nreturn val;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t store_enable(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (val < 1 || val > 2 || (val == 2 && !data->fan_mode[index]))\r\nreturn -EINVAL;\r\nret = nct7904_write_reg(data, BANK_3, FANCTL1_FMR_REG + index,\r\nval == 2 ? data->fan_mode[index] : 0);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t show_enable(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint val;\r\nval = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + index);\r\nif (val < 0)\r\nreturn val;\r\nreturn sprintf(buf, "%d\n", val ? 2 : 1);\r\n}\r\nstatic int nct7904_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nif (!i2c_check_functionality(adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, VENDOR_ID_REG) != NUVOTON_ID ||\r\ni2c_smbus_read_byte_data(client, CHIP_ID_REG) != NCT7904_ID ||\r\n(i2c_smbus_read_byte_data(client, DEVICE_ID_REG) & 0xf0) != 0x50 ||\r\n(i2c_smbus_read_byte_data(client, BANK_SEL_REG) & 0xf8) != 0x00)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "nct7904", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int nct7904_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct nct7904_data *data;\r\nstruct device *hwmon_dev;\r\nstruct device *dev = &client->dev;\r\nint ret, i;\r\nu32 mask;\r\ndata = devm_kzalloc(dev, sizeof(struct nct7904_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->bank_lock);\r\ndata->bank_sel = -1;\r\nret = nct7904_read_reg16(data, BANK_0, FANIN_CTRL0_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->fanin_mask = (ret >> 8) | ((ret & 0xff) << 8);\r\nmask = 0;\r\nret = nct7904_read_reg16(data, BANK_0, VT_ADC_CTRL0_REG);\r\nif (ret >= 0)\r\nmask = (ret >> 8) | ((ret & 0xff) << 8);\r\nret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL2_REG);\r\nif (ret >= 0)\r\nmask |= (ret << 16);\r\ndata->vsen_mask = mask;\r\nret = nct7904_read_reg16(data, BANK_0, DTS_T_CTRL0_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->tcpu_mask = ((ret >> 8) & 0xf) | ((ret & 0xf) << 4);\r\nfor (i = 0; i < FANCTL_MAX; i++) {\r\nret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + i);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->fan_mode[i] = ret;\r\n}\r\nhwmon_dev =\r\ndevm_hwmon_device_register_with_groups(dev, client->name, data,\r\nnct7904_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
