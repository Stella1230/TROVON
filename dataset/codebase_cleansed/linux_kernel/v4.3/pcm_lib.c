void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t frames, ofs, transfer;\r\nif (runtime->silence_size < runtime->boundary) {\r\nsnd_pcm_sframes_t noise_dist, n;\r\nif (runtime->silence_start != runtime->control->appl_ptr) {\r\nn = runtime->control->appl_ptr - runtime->silence_start;\r\nif (n < 0)\r\nn += runtime->boundary;\r\nif ((snd_pcm_uframes_t)n < runtime->silence_filled)\r\nruntime->silence_filled -= n;\r\nelse\r\nruntime->silence_filled = 0;\r\nruntime->silence_start = runtime->control->appl_ptr;\r\n}\r\nif (runtime->silence_filled >= runtime->buffer_size)\r\nreturn;\r\nnoise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;\r\nif (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)\r\nreturn;\r\nframes = runtime->silence_threshold - noise_dist;\r\nif (frames > runtime->silence_size)\r\nframes = runtime->silence_size;\r\n} else {\r\nif (new_hw_ptr == ULONG_MAX) {\r\nsnd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);\r\nif (avail > runtime->buffer_size)\r\navail = runtime->buffer_size;\r\nruntime->silence_filled = avail > 0 ? avail : 0;\r\nruntime->silence_start = (runtime->status->hw_ptr +\r\nruntime->silence_filled) %\r\nruntime->boundary;\r\n} else {\r\nofs = runtime->status->hw_ptr;\r\nframes = new_hw_ptr - ofs;\r\nif ((snd_pcm_sframes_t)frames < 0)\r\nframes += runtime->boundary;\r\nruntime->silence_filled -= frames;\r\nif ((snd_pcm_sframes_t)runtime->silence_filled < 0) {\r\nruntime->silence_filled = 0;\r\nruntime->silence_start = new_hw_ptr;\r\n} else {\r\nruntime->silence_start = ofs;\r\n}\r\n}\r\nframes = runtime->buffer_size - runtime->silence_filled;\r\n}\r\nif (snd_BUG_ON(frames > runtime->buffer_size))\r\nreturn;\r\nif (frames == 0)\r\nreturn;\r\nofs = runtime->silence_start % runtime->buffer_size;\r\nwhile (frames > 0) {\r\ntransfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;\r\nif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\r\nruntime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {\r\nif (substream->ops->silence) {\r\nint err;\r\nerr = substream->ops->silence(substream, -1, ofs, transfer);\r\nsnd_BUG_ON(err < 0);\r\n} else {\r\nchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);\r\nsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);\r\n}\r\n} else {\r\nunsigned int c;\r\nunsigned int channels = runtime->channels;\r\nif (substream->ops->silence) {\r\nfor (c = 0; c < channels; ++c) {\r\nint err;\r\nerr = substream->ops->silence(substream, c, ofs, transfer);\r\nsnd_BUG_ON(err < 0);\r\n}\r\n} else {\r\nsize_t dma_csize = runtime->dma_bytes / channels;\r\nfor (c = 0; c < channels; ++c) {\r\nchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);\r\nsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer);\r\n}\r\n}\r\n}\r\nruntime->silence_filled += transfer;\r\nframes -= transfer;\r\nofs = 0;\r\n}\r\n}\r\nvoid snd_pcm_debug_name(struct snd_pcm_substream *substream,\r\nchar *name, size_t len)\r\n{\r\nsnprintf(name, len, "pcmC%dD%d%c:%d",\r\nsubstream->pcm->card->number,\r\nsubstream->pcm->device,\r\nsubstream->stream ? 'c' : 'p',\r\nsubstream->number);\r\n}\r\nstatic void xrun(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\ntrace_xrun(substream);\r\nif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)\r\nsnd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\npcm_warn(substream->pcm, "XRUN: %s\n", name);\r\ndump_stack_on_xrun(substream);\r\n}\r\n}\r\nint snd_pcm_update_state(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nsnd_pcm_uframes_t avail;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\navail = snd_pcm_playback_avail(runtime);\r\nelse\r\navail = snd_pcm_capture_avail(runtime);\r\nif (avail > runtime->avail_max)\r\nruntime->avail_max = avail;\r\nif (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {\r\nif (avail >= runtime->buffer_size) {\r\nsnd_pcm_drain_done(substream);\r\nreturn -EPIPE;\r\n}\r\n} else {\r\nif (avail >= runtime->stop_threshold) {\r\nxrun(substream);\r\nreturn -EPIPE;\r\n}\r\n}\r\nif (runtime->twake) {\r\nif (avail >= runtime->twake)\r\nwake_up(&runtime->tsleep);\r\n} else if (avail >= runtime->control->avail_min)\r\nwake_up(&runtime->sleep);\r\nreturn 0;\r\n}\r\nstatic void update_audio_tstamp(struct snd_pcm_substream *substream,\r\nstruct timespec *curr_tstamp,\r\nstruct timespec *audio_tstamp)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu64 audio_frames, audio_nsecs;\r\nstruct timespec driver_tstamp;\r\nif (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)\r\nreturn;\r\nif (!(substream->ops->get_time_info) ||\r\n(runtime->audio_tstamp_report.actual_type ==\r\nSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\r\naudio_frames = runtime->hw_ptr_wrap + runtime->status->hw_ptr;\r\nif (runtime->audio_tstamp_config.report_delay) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naudio_frames -= runtime->delay;\r\nelse\r\naudio_frames += runtime->delay;\r\n}\r\naudio_nsecs = div_u64(audio_frames * 1000000000LL,\r\nruntime->rate);\r\n*audio_tstamp = ns_to_timespec(audio_nsecs);\r\n}\r\nruntime->status->audio_tstamp = *audio_tstamp;\r\nruntime->status->tstamp = *curr_tstamp;\r\nsnd_pcm_gettime(substream->runtime, (struct timespec *)&driver_tstamp);\r\nruntime->driver_tstamp = driver_tstamp;\r\n}\r\nstatic int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,\r\nunsigned int in_interrupt)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t pos;\r\nsnd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;\r\nsnd_pcm_sframes_t hdelta, delta;\r\nunsigned long jdelta;\r\nunsigned long curr_jiffies;\r\nstruct timespec curr_tstamp;\r\nstruct timespec audio_tstamp;\r\nint crossed_boundary = 0;\r\nold_hw_ptr = runtime->status->hw_ptr;\r\npos = substream->ops->pointer(substream);\r\ncurr_jiffies = jiffies;\r\nif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\r\nif ((substream->ops->get_time_info) &&\r\n(runtime->audio_tstamp_config.type_requested != SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\r\nsubstream->ops->get_time_info(substream, &curr_tstamp,\r\n&audio_tstamp,\r\n&runtime->audio_tstamp_config,\r\n&runtime->audio_tstamp_report);\r\nif (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)\r\nsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\r\n} else\r\nsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\r\n}\r\nif (pos == SNDRV_PCM_POS_XRUN) {\r\nxrun(substream);\r\nreturn -EPIPE;\r\n}\r\nif (pos >= runtime->buffer_size) {\r\nif (printk_ratelimit()) {\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\npcm_err(substream->pcm,\r\n"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",\r\nname, pos, runtime->buffer_size,\r\nruntime->period_size);\r\n}\r\npos = 0;\r\n}\r\npos -= pos % runtime->min_align;\r\ntrace_hwptr(substream, pos, in_interrupt);\r\nhw_base = runtime->hw_ptr_base;\r\nnew_hw_ptr = hw_base + pos;\r\nif (in_interrupt) {\r\ndelta = runtime->hw_ptr_interrupt + runtime->period_size;\r\nif (delta > new_hw_ptr) {\r\nhdelta = curr_jiffies - runtime->hw_ptr_jiffies;\r\nif (hdelta > runtime->hw_ptr_buffer_jiffies/2 + 1) {\r\nhw_base += runtime->buffer_size;\r\nif (hw_base >= runtime->boundary) {\r\nhw_base = 0;\r\ncrossed_boundary++;\r\n}\r\nnew_hw_ptr = hw_base + pos;\r\ngoto __delta;\r\n}\r\n}\r\n}\r\nif (new_hw_ptr < old_hw_ptr) {\r\nhw_base += runtime->buffer_size;\r\nif (hw_base >= runtime->boundary) {\r\nhw_base = 0;\r\ncrossed_boundary++;\r\n}\r\nnew_hw_ptr = hw_base + pos;\r\n}\r\n__delta:\r\ndelta = new_hw_ptr - old_hw_ptr;\r\nif (delta < 0)\r\ndelta += runtime->boundary;\r\nif (runtime->no_period_wakeup) {\r\nsnd_pcm_sframes_t xrun_threshold;\r\njdelta = curr_jiffies - runtime->hw_ptr_jiffies;\r\nif (jdelta < runtime->hw_ptr_buffer_jiffies / 2)\r\ngoto no_delta_check;\r\nhdelta = jdelta - delta * HZ / runtime->rate;\r\nxrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;\r\nwhile (hdelta > xrun_threshold) {\r\ndelta += runtime->buffer_size;\r\nhw_base += runtime->buffer_size;\r\nif (hw_base >= runtime->boundary) {\r\nhw_base = 0;\r\ncrossed_boundary++;\r\n}\r\nnew_hw_ptr = hw_base + pos;\r\nhdelta -= runtime->hw_ptr_buffer_jiffies;\r\n}\r\ngoto no_delta_check;\r\n}\r\nif (delta >= runtime->buffer_size + runtime->period_size) {\r\nhw_ptr_error(substream, in_interrupt, "Unexpected hw_ptr",\r\n"(stream=%i, pos=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\n",\r\nsubstream->stream, (long)pos,\r\n(long)new_hw_ptr, (long)old_hw_ptr);\r\nreturn 0;\r\n}\r\nif (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))\r\ngoto no_jiffies_check;\r\nif (runtime->hw.info & SNDRV_PCM_INFO_BATCH)\r\ngoto no_jiffies_check;\r\nhdelta = delta;\r\nif (hdelta < runtime->delay)\r\ngoto no_jiffies_check;\r\nhdelta -= runtime->delay;\r\njdelta = curr_jiffies - runtime->hw_ptr_jiffies;\r\nif (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {\r\ndelta = jdelta /\r\n(((runtime->period_size * HZ) / runtime->rate)\r\n+ HZ/100);\r\nnew_hw_ptr = old_hw_ptr;\r\nhw_base = delta;\r\nwhile (delta > 0) {\r\nnew_hw_ptr += runtime->period_size;\r\nif (new_hw_ptr >= runtime->boundary) {\r\nnew_hw_ptr -= runtime->boundary;\r\ncrossed_boundary--;\r\n}\r\ndelta--;\r\n}\r\nhw_ptr_error(substream, in_interrupt, "hw_ptr skipping",\r\n"(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\n",\r\n(long)pos, (long)hdelta,\r\n(long)runtime->period_size, jdelta,\r\n((hdelta * HZ) / runtime->rate), hw_base,\r\n(unsigned long)old_hw_ptr,\r\n(unsigned long)new_hw_ptr);\r\ndelta = 0;\r\nhw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);\r\n}\r\nno_jiffies_check:\r\nif (delta > runtime->period_size + runtime->period_size / 2) {\r\nhw_ptr_error(substream, in_interrupt,\r\n"Lost interrupts?",\r\n"(stream=%i, delta=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\n",\r\nsubstream->stream, (long)delta,\r\n(long)new_hw_ptr,\r\n(long)old_hw_ptr);\r\n}\r\nno_delta_check:\r\nif (runtime->status->hw_ptr == new_hw_ptr) {\r\nupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\r\nreturn 0;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nruntime->silence_size > 0)\r\nsnd_pcm_playback_silence(substream, new_hw_ptr);\r\nif (in_interrupt) {\r\ndelta = new_hw_ptr - runtime->hw_ptr_interrupt;\r\nif (delta < 0)\r\ndelta += runtime->boundary;\r\ndelta -= (snd_pcm_uframes_t)delta % runtime->period_size;\r\nruntime->hw_ptr_interrupt += delta;\r\nif (runtime->hw_ptr_interrupt >= runtime->boundary)\r\nruntime->hw_ptr_interrupt -= runtime->boundary;\r\n}\r\nruntime->hw_ptr_base = hw_base;\r\nruntime->status->hw_ptr = new_hw_ptr;\r\nruntime->hw_ptr_jiffies = curr_jiffies;\r\nif (crossed_boundary) {\r\nsnd_BUG_ON(crossed_boundary != 1);\r\nruntime->hw_ptr_wrap += runtime->boundary;\r\n}\r\nupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\r\nreturn snd_pcm_update_state(substream, runtime);\r\n}\r\nint snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_update_hw_ptr0(substream, 0);\r\n}\r\nvoid snd_pcm_set_ops(struct snd_pcm *pcm, int direction,\r\nconst struct snd_pcm_ops *ops)\r\n{\r\nstruct snd_pcm_str *stream = &pcm->streams[direction];\r\nstruct snd_pcm_substream *substream;\r\nfor (substream = stream->substream; substream != NULL; substream = substream->next)\r\nsubstream->ops = ops;\r\n}\r\nvoid snd_pcm_set_sync(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->sync.id32[0] = substream->pcm->card->number;\r\nruntime->sync.id32[1] = -1;\r\nruntime->sync.id32[2] = -1;\r\nruntime->sync.id32[3] = -1;\r\n}\r\nstatic inline unsigned int div32(unsigned int a, unsigned int b,\r\nunsigned int *r)\r\n{\r\nif (b == 0) {\r\n*r = 0;\r\nreturn UINT_MAX;\r\n}\r\n*r = a % b;\r\nreturn a / b;\r\n}\r\nstatic inline unsigned int div_down(unsigned int a, unsigned int b)\r\n{\r\nif (b == 0)\r\nreturn UINT_MAX;\r\nreturn a / b;\r\n}\r\nstatic inline unsigned int div_up(unsigned int a, unsigned int b)\r\n{\r\nunsigned int r;\r\nunsigned int q;\r\nif (b == 0)\r\nreturn UINT_MAX;\r\nq = div32(a, b, &r);\r\nif (r)\r\n++q;\r\nreturn q;\r\n}\r\nstatic inline unsigned int mul(unsigned int a, unsigned int b)\r\n{\r\nif (a == 0)\r\nreturn 0;\r\nif (div_down(UINT_MAX, a) < b)\r\nreturn UINT_MAX;\r\nreturn a * b;\r\n}\r\nstatic inline unsigned int muldiv32(unsigned int a, unsigned int b,\r\nunsigned int c, unsigned int *r)\r\n{\r\nu_int64_t n = (u_int64_t) a * b;\r\nif (c == 0) {\r\nsnd_BUG_ON(!n);\r\n*r = 0;\r\nreturn UINT_MAX;\r\n}\r\nn = div_u64_rem(n, c, r);\r\nif (n >= UINT_MAX) {\r\n*r = 0;\r\nreturn UINT_MAX;\r\n}\r\nreturn n;\r\n}\r\nint snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)\r\n{\r\nint changed = 0;\r\nif (snd_BUG_ON(snd_interval_empty(i)))\r\nreturn -EINVAL;\r\nif (i->min < v->min) {\r\ni->min = v->min;\r\ni->openmin = v->openmin;\r\nchanged = 1;\r\n} else if (i->min == v->min && !i->openmin && v->openmin) {\r\ni->openmin = 1;\r\nchanged = 1;\r\n}\r\nif (i->max > v->max) {\r\ni->max = v->max;\r\ni->openmax = v->openmax;\r\nchanged = 1;\r\n} else if (i->max == v->max && !i->openmax && v->openmax) {\r\ni->openmax = 1;\r\nchanged = 1;\r\n}\r\nif (!i->integer && v->integer) {\r\ni->integer = 1;\r\nchanged = 1;\r\n}\r\nif (i->integer) {\r\nif (i->openmin) {\r\ni->min++;\r\ni->openmin = 0;\r\n}\r\nif (i->openmax) {\r\ni->max--;\r\ni->openmax = 0;\r\n}\r\n} else if (!i->openmin && !i->openmax && i->min == i->max)\r\ni->integer = 1;\r\nif (snd_interval_checkempty(i)) {\r\nsnd_interval_none(i);\r\nreturn -EINVAL;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_interval_refine_first(struct snd_interval *i)\r\n{\r\nif (snd_BUG_ON(snd_interval_empty(i)))\r\nreturn -EINVAL;\r\nif (snd_interval_single(i))\r\nreturn 0;\r\ni->max = i->min;\r\ni->openmax = i->openmin;\r\nif (i->openmax)\r\ni->max++;\r\nreturn 1;\r\n}\r\nstatic int snd_interval_refine_last(struct snd_interval *i)\r\n{\r\nif (snd_BUG_ON(snd_interval_empty(i)))\r\nreturn -EINVAL;\r\nif (snd_interval_single(i))\r\nreturn 0;\r\ni->min = i->max;\r\ni->openmin = i->openmax;\r\nif (i->openmin)\r\ni->min--;\r\nreturn 1;\r\n}\r\nvoid snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\r\n{\r\nif (a->empty || b->empty) {\r\nsnd_interval_none(c);\r\nreturn;\r\n}\r\nc->empty = 0;\r\nc->min = mul(a->min, b->min);\r\nc->openmin = (a->openmin || b->openmin);\r\nc->max = mul(a->max, b->max);\r\nc->openmax = (a->openmax || b->openmax);\r\nc->integer = (a->integer && b->integer);\r\n}\r\nvoid snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\r\n{\r\nunsigned int r;\r\nif (a->empty || b->empty) {\r\nsnd_interval_none(c);\r\nreturn;\r\n}\r\nc->empty = 0;\r\nc->min = div32(a->min, b->max, &r);\r\nc->openmin = (r || a->openmin || b->openmax);\r\nif (b->min > 0) {\r\nc->max = div32(a->max, b->min, &r);\r\nif (r) {\r\nc->max++;\r\nc->openmax = 1;\r\n} else\r\nc->openmax = (a->openmax || b->openmin);\r\n} else {\r\nc->max = UINT_MAX;\r\nc->openmax = 0;\r\n}\r\nc->integer = 0;\r\n}\r\nvoid snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,\r\nunsigned int k, struct snd_interval *c)\r\n{\r\nunsigned int r;\r\nif (a->empty || b->empty) {\r\nsnd_interval_none(c);\r\nreturn;\r\n}\r\nc->empty = 0;\r\nc->min = muldiv32(a->min, b->min, k, &r);\r\nc->openmin = (r || a->openmin || b->openmin);\r\nc->max = muldiv32(a->max, b->max, k, &r);\r\nif (r) {\r\nc->max++;\r\nc->openmax = 1;\r\n} else\r\nc->openmax = (a->openmax || b->openmax);\r\nc->integer = 0;\r\n}\r\nvoid snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,\r\nconst struct snd_interval *b, struct snd_interval *c)\r\n{\r\nunsigned int r;\r\nif (a->empty || b->empty) {\r\nsnd_interval_none(c);\r\nreturn;\r\n}\r\nc->empty = 0;\r\nc->min = muldiv32(a->min, k, b->max, &r);\r\nc->openmin = (r || a->openmin || b->openmax);\r\nif (b->min > 0) {\r\nc->max = muldiv32(a->max, k, b->min, &r);\r\nif (r) {\r\nc->max++;\r\nc->openmax = 1;\r\n} else\r\nc->openmax = (a->openmax || b->openmin);\r\n} else {\r\nc->max = UINT_MAX;\r\nc->openmax = 0;\r\n}\r\nc->integer = 0;\r\n}\r\nint snd_interval_ratnum(struct snd_interval *i,\r\nunsigned int rats_count, struct snd_ratnum *rats,\r\nunsigned int *nump, unsigned int *denp)\r\n{\r\nunsigned int best_num, best_den;\r\nint best_diff;\r\nunsigned int k;\r\nstruct snd_interval t;\r\nint err;\r\nunsigned int result_num, result_den;\r\nint result_diff;\r\nbest_num = best_den = best_diff = 0;\r\nfor (k = 0; k < rats_count; ++k) {\r\nunsigned int num = rats[k].num;\r\nunsigned int den;\r\nunsigned int q = i->min;\r\nint diff;\r\nif (q == 0)\r\nq = 1;\r\nden = div_up(num, q);\r\nif (den < rats[k].den_min)\r\ncontinue;\r\nif (den > rats[k].den_max)\r\nden = rats[k].den_max;\r\nelse {\r\nunsigned int r;\r\nr = (den - rats[k].den_min) % rats[k].den_step;\r\nif (r != 0)\r\nden -= r;\r\n}\r\ndiff = num - q * den;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (best_num == 0 ||\r\ndiff * best_den < best_diff * den) {\r\nbest_diff = diff;\r\nbest_den = den;\r\nbest_num = num;\r\n}\r\n}\r\nif (best_den == 0) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nt.min = div_down(best_num, best_den);\r\nt.openmin = !!(best_num % best_den);\r\nresult_num = best_num;\r\nresult_diff = best_diff;\r\nresult_den = best_den;\r\nbest_num = best_den = best_diff = 0;\r\nfor (k = 0; k < rats_count; ++k) {\r\nunsigned int num = rats[k].num;\r\nunsigned int den;\r\nunsigned int q = i->max;\r\nint diff;\r\nif (q == 0) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nden = div_down(num, q);\r\nif (den > rats[k].den_max)\r\ncontinue;\r\nif (den < rats[k].den_min)\r\nden = rats[k].den_min;\r\nelse {\r\nunsigned int r;\r\nr = (den - rats[k].den_min) % rats[k].den_step;\r\nif (r != 0)\r\nden += rats[k].den_step - r;\r\n}\r\ndiff = q * den - num;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (best_num == 0 ||\r\ndiff * best_den < best_diff * den) {\r\nbest_diff = diff;\r\nbest_den = den;\r\nbest_num = num;\r\n}\r\n}\r\nif (best_den == 0) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nt.max = div_up(best_num, best_den);\r\nt.openmax = !!(best_num % best_den);\r\nt.integer = 0;\r\nerr = snd_interval_refine(i, &t);\r\nif (err < 0)\r\nreturn err;\r\nif (snd_interval_single(i)) {\r\nif (best_diff * result_den < result_diff * best_den) {\r\nresult_num = best_num;\r\nresult_den = best_den;\r\n}\r\nif (nump)\r\n*nump = result_num;\r\nif (denp)\r\n*denp = result_den;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_interval_ratden(struct snd_interval *i,\r\nunsigned int rats_count, struct snd_ratden *rats,\r\nunsigned int *nump, unsigned int *denp)\r\n{\r\nunsigned int best_num, best_diff, best_den;\r\nunsigned int k;\r\nstruct snd_interval t;\r\nint err;\r\nbest_num = best_den = best_diff = 0;\r\nfor (k = 0; k < rats_count; ++k) {\r\nunsigned int num;\r\nunsigned int den = rats[k].den;\r\nunsigned int q = i->min;\r\nint diff;\r\nnum = mul(q, den);\r\nif (num > rats[k].num_max)\r\ncontinue;\r\nif (num < rats[k].num_min)\r\nnum = rats[k].num_max;\r\nelse {\r\nunsigned int r;\r\nr = (num - rats[k].num_min) % rats[k].num_step;\r\nif (r != 0)\r\nnum += rats[k].num_step - r;\r\n}\r\ndiff = num - q * den;\r\nif (best_num == 0 ||\r\ndiff * best_den < best_diff * den) {\r\nbest_diff = diff;\r\nbest_den = den;\r\nbest_num = num;\r\n}\r\n}\r\nif (best_den == 0) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nt.min = div_down(best_num, best_den);\r\nt.openmin = !!(best_num % best_den);\r\nbest_num = best_den = best_diff = 0;\r\nfor (k = 0; k < rats_count; ++k) {\r\nunsigned int num;\r\nunsigned int den = rats[k].den;\r\nunsigned int q = i->max;\r\nint diff;\r\nnum = mul(q, den);\r\nif (num < rats[k].num_min)\r\ncontinue;\r\nif (num > rats[k].num_max)\r\nnum = rats[k].num_max;\r\nelse {\r\nunsigned int r;\r\nr = (num - rats[k].num_min) % rats[k].num_step;\r\nif (r != 0)\r\nnum -= r;\r\n}\r\ndiff = q * den - num;\r\nif (best_num == 0 ||\r\ndiff * best_den < best_diff * den) {\r\nbest_diff = diff;\r\nbest_den = den;\r\nbest_num = num;\r\n}\r\n}\r\nif (best_den == 0) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nt.max = div_up(best_num, best_den);\r\nt.openmax = !!(best_num % best_den);\r\nt.integer = 0;\r\nerr = snd_interval_refine(i, &t);\r\nif (err < 0)\r\nreturn err;\r\nif (snd_interval_single(i)) {\r\nif (nump)\r\n*nump = best_num;\r\nif (denp)\r\n*denp = best_den;\r\n}\r\nreturn err;\r\n}\r\nint snd_interval_list(struct snd_interval *i, unsigned int count,\r\nconst unsigned int *list, unsigned int mask)\r\n{\r\nunsigned int k;\r\nstruct snd_interval list_range;\r\nif (!count) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nsnd_interval_any(&list_range);\r\nlist_range.min = UINT_MAX;\r\nlist_range.max = 0;\r\nfor (k = 0; k < count; k++) {\r\nif (mask && !(mask & (1 << k)))\r\ncontinue;\r\nif (!snd_interval_test(i, list[k]))\r\ncontinue;\r\nlist_range.min = min(list_range.min, list[k]);\r\nlist_range.max = max(list_range.max, list[k]);\r\n}\r\nreturn snd_interval_refine(i, &list_range);\r\n}\r\nint snd_interval_ranges(struct snd_interval *i, unsigned int count,\r\nconst struct snd_interval *ranges, unsigned int mask)\r\n{\r\nunsigned int k;\r\nstruct snd_interval range_union;\r\nstruct snd_interval range;\r\nif (!count) {\r\nsnd_interval_none(i);\r\nreturn -EINVAL;\r\n}\r\nsnd_interval_any(&range_union);\r\nrange_union.min = UINT_MAX;\r\nrange_union.max = 0;\r\nfor (k = 0; k < count; k++) {\r\nif (mask && !(mask & (1 << k)))\r\ncontinue;\r\nsnd_interval_copy(&range, &ranges[k]);\r\nif (snd_interval_refine(&range, i) < 0)\r\ncontinue;\r\nif (snd_interval_empty(&range))\r\ncontinue;\r\nif (range.min < range_union.min) {\r\nrange_union.min = range.min;\r\nrange_union.openmin = 1;\r\n}\r\nif (range.min == range_union.min && !range.openmin)\r\nrange_union.openmin = 0;\r\nif (range.max > range_union.max) {\r\nrange_union.max = range.max;\r\nrange_union.openmax = 1;\r\n}\r\nif (range.max == range_union.max && !range.openmax)\r\nrange_union.openmax = 0;\r\n}\r\nreturn snd_interval_refine(i, &range_union);\r\n}\r\nstatic int snd_interval_step(struct snd_interval *i, unsigned int step)\r\n{\r\nunsigned int n;\r\nint changed = 0;\r\nn = i->min % step;\r\nif (n != 0 || i->openmin) {\r\ni->min += step - n;\r\ni->openmin = 0;\r\nchanged = 1;\r\n}\r\nn = i->max % step;\r\nif (n != 0 || i->openmax) {\r\ni->max -= n;\r\ni->openmax = 0;\r\nchanged = 1;\r\n}\r\nif (snd_interval_checkempty(i)) {\r\ni->empty = 1;\r\nreturn -EINVAL;\r\n}\r\nreturn changed;\r\n}\r\nint snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,\r\nint var,\r\nsnd_pcm_hw_rule_func_t func, void *private,\r\nint dep, ...)\r\n{\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nstruct snd_pcm_hw_rule *c;\r\nunsigned int k;\r\nva_list args;\r\nva_start(args, dep);\r\nif (constrs->rules_num >= constrs->rules_all) {\r\nstruct snd_pcm_hw_rule *new;\r\nunsigned int new_rules = constrs->rules_all + 16;\r\nnew = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);\r\nif (!new) {\r\nva_end(args);\r\nreturn -ENOMEM;\r\n}\r\nif (constrs->rules) {\r\nmemcpy(new, constrs->rules,\r\nconstrs->rules_num * sizeof(*c));\r\nkfree(constrs->rules);\r\n}\r\nconstrs->rules = new;\r\nconstrs->rules_all = new_rules;\r\n}\r\nc = &constrs->rules[constrs->rules_num];\r\nc->cond = cond;\r\nc->func = func;\r\nc->var = var;\r\nc->private = private;\r\nk = 0;\r\nwhile (1) {\r\nif (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {\r\nva_end(args);\r\nreturn -EINVAL;\r\n}\r\nc->deps[k++] = dep;\r\nif (dep < 0)\r\nbreak;\r\ndep = va_arg(args, int);\r\n}\r\nconstrs->rules_num++;\r\nva_end(args);\r\nreturn 0;\r\n}\r\nint snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\r\nu_int32_t mask)\r\n{\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nstruct snd_mask *maskp = constrs_mask(constrs, var);\r\n*maskp->bits &= mask;\r\nmemset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8);\r\nif (*maskp->bits == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\r\nu_int64_t mask)\r\n{\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nstruct snd_mask *maskp = constrs_mask(constrs, var);\r\nmaskp->bits[0] &= (u_int32_t)mask;\r\nmaskp->bits[1] &= (u_int32_t)(mask >> 32);\r\nmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8);\r\nif (! maskp->bits[0] && ! maskp->bits[1])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)\r\n{\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nreturn snd_interval_setinteger(constrs_interval(constrs, var));\r\n}\r\nint snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\r\nunsigned int min, unsigned int max)\r\n{\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nstruct snd_interval t;\r\nt.min = min;\r\nt.max = max;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 0;\r\nreturn snd_interval_refine(constrs_interval(constrs, var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hw_constraint_list *list = rule->private;\r\nreturn snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);\r\n}\r\nint snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var,\r\nconst struct snd_pcm_hw_constraint_list *l)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_list, (void *)l,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hw_constraint_ranges *r = rule->private;\r\nreturn snd_interval_ranges(hw_param_interval(params, rule->var),\r\nr->count, r->ranges, r->mask);\r\n}\r\nint snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var,\r\nconst struct snd_pcm_hw_constraint_ranges *r)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_ranges, (void *)r,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hw_constraint_ratnums *r = rule->private;\r\nunsigned int num = 0, den = 0;\r\nint err;\r\nerr = snd_interval_ratnum(hw_param_interval(params, rule->var),\r\nr->nrats, r->rats, &num, &den);\r\nif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\r\nparams->rate_num = num;\r\nparams->rate_den = den;\r\n}\r\nreturn err;\r\n}\r\nint snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var,\r\nstruct snd_pcm_hw_constraint_ratnums *r)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_ratnums, r,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hw_constraint_ratdens *r = rule->private;\r\nunsigned int num = 0, den = 0;\r\nint err = snd_interval_ratden(hw_param_interval(params, rule->var),\r\nr->nrats, r->rats, &num, &den);\r\nif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\r\nparams->rate_num = num;\r\nparams->rate_den = den;\r\n}\r\nreturn err;\r\n}\r\nint snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var,\r\nstruct snd_pcm_hw_constraint_ratdens *r)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_ratdens, r,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int l = (unsigned long) rule->private;\r\nint width = l & 0xffff;\r\nunsigned int msbits = l >> 16;\r\nstruct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\r\nif (!snd_interval_single(i))\r\nreturn 0;\r\nif ((snd_interval_value(i) == width) ||\r\n(width == 0 && snd_interval_value(i) > msbits))\r\nparams->msbits = min_not_zero(params->msbits, msbits);\r\nreturn 0;\r\n}\r\nint snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nunsigned int width,\r\nunsigned int msbits)\r\n{\r\nunsigned long l = (msbits << 16) | width;\r\nreturn snd_pcm_hw_rule_add(runtime, cond, -1,\r\nsnd_pcm_hw_rule_msbits,\r\n(void*) l,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned long step = (unsigned long) rule->private;\r\nreturn snd_interval_step(hw_param_interval(params, rule->var), step);\r\n}\r\nint snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var,\r\nunsigned long step)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_step, (void *) step,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\r\n{\r\nstatic unsigned int pow2_sizes[] = {\r\n1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,\r\n1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,\r\n1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,\r\n1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30\r\n};\r\nreturn snd_interval_list(hw_param_interval(params, rule->var),\r\nARRAY_SIZE(pow2_sizes), pow2_sizes, 0);\r\n}\r\nint snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,\r\nunsigned int cond,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, cond, var,\r\nsnd_pcm_hw_rule_pow2, NULL,\r\nvar, -1);\r\n}\r\nstatic int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int base_rate = (unsigned int)(uintptr_t)rule->private;\r\nstruct snd_interval *rate;\r\nrate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn snd_interval_list(rate, 1, &base_rate, 0);\r\n}\r\nint snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,\r\nunsigned int base_rate)\r\n{\r\nreturn snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nsnd_pcm_hw_rule_noresample_func,\r\n(void *)(uintptr_t)base_rate,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\n}\r\nstatic void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nif (hw_is_mask(var)) {\r\nsnd_mask_any(hw_param_mask(params, var));\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\nreturn;\r\n}\r\nif (hw_is_interval(var)) {\r\nsnd_interval_any(hw_param_interval(params, var));\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\nreturn;\r\n}\r\nsnd_BUG();\r\n}\r\nvoid _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)\r\n{\r\nunsigned int k;\r\nmemset(params, 0, sizeof(*params));\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)\r\n_snd_pcm_hw_param_any(params, k);\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\r\n_snd_pcm_hw_param_any(params, k);\r\nparams->info = ~0U;\r\n}\r\nint snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, int *dir)\r\n{\r\nif (hw_is_mask(var)) {\r\nconst struct snd_mask *mask = hw_param_mask_c(params, var);\r\nif (!snd_mask_single(mask))\r\nreturn -EINVAL;\r\nif (dir)\r\n*dir = 0;\r\nreturn snd_mask_value(mask);\r\n}\r\nif (hw_is_interval(var)) {\r\nconst struct snd_interval *i = hw_param_interval_c(params, var);\r\nif (!snd_interval_single(i))\r\nreturn -EINVAL;\r\nif (dir)\r\n*dir = i->openmin;\r\nreturn snd_interval_value(i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nif (hw_is_mask(var)) {\r\nsnd_mask_none(hw_param_mask(params, var));\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n} else if (hw_is_interval(var)) {\r\nsnd_interval_none(hw_param_interval(params, var));\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n} else {\r\nsnd_BUG();\r\n}\r\n}\r\nstatic int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nint changed;\r\nif (hw_is_mask(var))\r\nchanged = snd_mask_refine_first(hw_param_mask(params, var));\r\nelse if (hw_is_interval(var))\r\nchanged = snd_interval_refine_first(hw_param_interval(params, var));\r\nelse\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nint snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, int *dir)\r\n{\r\nint changed = _snd_pcm_hw_param_first(params, var);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (snd_BUG_ON(err < 0))\r\nreturn err;\r\n}\r\nreturn snd_pcm_hw_param_value(params, var, dir);\r\n}\r\nstatic int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nint changed;\r\nif (hw_is_mask(var))\r\nchanged = snd_mask_refine_last(hw_param_mask(params, var));\r\nelse if (hw_is_interval(var))\r\nchanged = snd_interval_refine_last(hw_param_interval(params, var));\r\nelse\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nint snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, int *dir)\r\n{\r\nint changed = _snd_pcm_hw_param_last(params, var);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (snd_BUG_ON(err < 0))\r\nreturn err;\r\n}\r\nreturn snd_pcm_hw_param_value(params, var, dir);\r\n}\r\nint snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstatic int vars[] = {\r\nSNDRV_PCM_HW_PARAM_ACCESS,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nSNDRV_PCM_HW_PARAM_SUBFORMAT,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nSNDRV_PCM_HW_PARAM_TICK_TIME,\r\n-1\r\n};\r\nint err, *v;\r\nfor (v = vars; *v != -1; v++) {\r\nif (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)\r\nerr = snd_pcm_hw_param_first(pcm, params, *v, NULL);\r\nelse\r\nerr = snd_pcm_hw_param_last(pcm, params, *v, NULL);\r\nif (snd_BUG_ON(err < 0))\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,\r\nvoid *arg)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long flags;\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\nif (snd_pcm_running(substream) &&\r\nsnd_pcm_update_hw_ptr(substream) >= 0)\r\nruntime->status->hw_ptr %= runtime->buffer_size;\r\nelse {\r\nruntime->status->hw_ptr = 0;\r\nruntime->hw_ptr_wrap = 0;\r\n}\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,\r\nvoid *arg)\r\n{\r\nstruct snd_pcm_channel_info *info = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint width;\r\nif (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {\r\ninfo->offset = -1;\r\nreturn 0;\r\n}\r\nwidth = snd_pcm_format_physical_width(runtime->format);\r\nif (width < 0)\r\nreturn width;\r\ninfo->offset = 0;\r\nswitch (runtime->access) {\r\ncase SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:\r\ncase SNDRV_PCM_ACCESS_RW_INTERLEAVED:\r\ninfo->first = info->channel * width;\r\ninfo->step = runtime->channels * width;\r\nbreak;\r\ncase SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:\r\ncase SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:\r\n{\r\nsize_t size = runtime->dma_bytes / runtime->channels;\r\ninfo->first = info->channel * size * 8;\r\ninfo->step = width;\r\nbreak;\r\n}\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,\r\nvoid *arg)\r\n{\r\nstruct snd_pcm_hw_params *params = arg;\r\nsnd_pcm_format_t format;\r\nint channels;\r\nssize_t frame_size;\r\nparams->fifo_size = substream->runtime->hw.fifo_size;\r\nif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {\r\nformat = params_format(params);\r\nchannels = params_channels(params);\r\nframe_size = snd_pcm_format_size(format, channels);\r\nif (frame_size > 0)\r\nparams->fifo_size /= (unsigned)frame_size;\r\n}\r\nreturn 0;\r\n}\r\nint snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL1_INFO:\r\nreturn 0;\r\ncase SNDRV_PCM_IOCTL1_RESET:\r\nreturn snd_pcm_lib_ioctl_reset(substream, arg);\r\ncase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\r\nreturn snd_pcm_lib_ioctl_channel_info(substream, arg);\r\ncase SNDRV_PCM_IOCTL1_FIFO_SIZE:\r\nreturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\r\n}\r\nreturn -ENXIO;\r\n}\r\nvoid snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long flags;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn;\r\nruntime = substream->runtime;\r\nif (runtime->transfer_ack_begin)\r\nruntime->transfer_ack_begin(substream);\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\nif (!snd_pcm_running(substream) ||\r\nsnd_pcm_update_hw_ptr0(substream, 1) < 0)\r\ngoto _end;\r\nif (substream->timer_running)\r\nsnd_timer_interrupt(substream->timer, 1);\r\n_end:\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nif (runtime->transfer_ack_end)\r\nruntime->transfer_ack_end(substream);\r\nkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\r\n}\r\nstatic int wait_for_avail(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t *availp)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nwait_queue_t wait;\r\nint err = 0;\r\nsnd_pcm_uframes_t avail = 0;\r\nlong wait_time, tout;\r\ninit_waitqueue_entry(&wait, current);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&runtime->tsleep, &wait);\r\nif (runtime->no_period_wakeup)\r\nwait_time = MAX_SCHEDULE_TIMEOUT;\r\nelse {\r\nwait_time = 10;\r\nif (runtime->rate) {\r\nlong t = runtime->period_size * 2 / runtime->rate;\r\nwait_time = max(t, wait_time);\r\n}\r\nwait_time = msecs_to_jiffies(wait_time * 1000);\r\n}\r\nfor (;;) {\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (is_playback)\r\navail = snd_pcm_playback_avail(runtime);\r\nelse\r\navail = snd_pcm_capture_avail(runtime);\r\nif (avail >= runtime->twake)\r\nbreak;\r\nsnd_pcm_stream_unlock_irq(substream);\r\ntout = schedule_timeout(wait_time);\r\nsnd_pcm_stream_lock_irq(substream);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = -ESTRPIPE;\r\ngoto _endloop;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\ngoto _endloop;\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nif (is_playback)\r\nerr = -EPIPE;\r\nelse\r\navail = 0;\r\ngoto _endloop;\r\ncase SNDRV_PCM_STATE_OPEN:\r\ncase SNDRV_PCM_STATE_SETUP:\r\ncase SNDRV_PCM_STATE_DISCONNECTED:\r\nerr = -EBADFD;\r\ngoto _endloop;\r\ncase SNDRV_PCM_STATE_PAUSED:\r\ncontinue;\r\n}\r\nif (!tout) {\r\npcm_dbg(substream->pcm,\r\n"%s write error (DMA or IRQ trouble?)\n",\r\nis_playback ? "playback" : "capture");\r\nerr = -EIO;\r\nbreak;\r\n}\r\n}\r\n_endloop:\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&runtime->tsleep, &wait);\r\n*availp = avail;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,\r\nunsigned int hwoff,\r\nunsigned long data, unsigned int off,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\r\nif (substream->ops->copy) {\r\nif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\r\nreturn err;\r\n} else {\r\nchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\r\nif (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,\r\nunsigned long data,\r\nsnd_pcm_uframes_t size,\r\nint nonblock,\r\ntransfer_f transfer)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t xfer = 0;\r\nsnd_pcm_uframes_t offset = 0;\r\nsnd_pcm_uframes_t avail;\r\nint err = 0;\r\nif (size == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\ngoto _end_unlock;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = -ESTRPIPE;\r\ngoto _end_unlock;\r\ndefault:\r\nerr = -EBADFD;\r\ngoto _end_unlock;\r\n}\r\nruntime->twake = runtime->control->avail_min ? : 1;\r\nif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\r\nsnd_pcm_update_hw_ptr(substream);\r\navail = snd_pcm_playback_avail(runtime);\r\nwhile (size > 0) {\r\nsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\r\nsnd_pcm_uframes_t cont;\r\nif (!avail) {\r\nif (nonblock) {\r\nerr = -EAGAIN;\r\ngoto _end_unlock;\r\n}\r\nruntime->twake = min_t(snd_pcm_uframes_t, size,\r\nruntime->control->avail_min ? : 1);\r\nerr = wait_for_avail(substream, &avail);\r\nif (err < 0)\r\ngoto _end_unlock;\r\n}\r\nframes = size > avail ? avail : size;\r\ncont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\r\nif (frames > cont)\r\nframes = cont;\r\nif (snd_BUG_ON(!frames)) {\r\nruntime->twake = 0;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EINVAL;\r\n}\r\nappl_ptr = runtime->control->appl_ptr;\r\nappl_ofs = appl_ptr % runtime->buffer_size;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nerr = transfer(substream, appl_ofs, data, offset, frames);\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (err < 0)\r\ngoto _end_unlock;\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\ngoto _end_unlock;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = -ESTRPIPE;\r\ngoto _end_unlock;\r\ndefault:\r\nbreak;\r\n}\r\nappl_ptr += frames;\r\nif (appl_ptr >= runtime->boundary)\r\nappl_ptr -= runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nif (substream->ops->ack)\r\nsubstream->ops->ack(substream);\r\noffset += frames;\r\nsize -= frames;\r\nxfer += frames;\r\navail -= frames;\r\nif (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&\r\nsnd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {\r\nerr = snd_pcm_start(substream);\r\nif (err < 0)\r\ngoto _end_unlock;\r\n}\r\n}\r\n_end_unlock:\r\nruntime->twake = 0;\r\nif (xfer > 0 && err >= 0)\r\nsnd_pcm_update_state(substream, runtime);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\r\n}\r\nstatic int pcm_sanity_check(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))\r\nreturn -EINVAL;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nreturn 0;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint nonblock;\r\nint err;\r\nerr = pcm_sanity_check(substream);\r\nif (err < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nnonblock = !!(substream->f_flags & O_NONBLOCK);\r\nif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&\r\nruntime->channels > 1)\r\nreturn -EINVAL;\r\nreturn snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,\r\nsnd_pcm_lib_write_transfer);\r\n}\r\nstatic int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,\r\nunsigned int hwoff,\r\nunsigned long data, unsigned int off,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nvoid __user **bufs = (void __user **)data;\r\nint channels = runtime->channels;\r\nint c;\r\nif (substream->ops->copy) {\r\nif (snd_BUG_ON(!substream->ops->silence))\r\nreturn -EINVAL;\r\nfor (c = 0; c < channels; ++c, ++bufs) {\r\nif (*bufs == NULL) {\r\nif ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)\r\nreturn err;\r\n} else {\r\nchar __user *buf = *bufs + samples_to_bytes(runtime, off);\r\nif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\r\nreturn err;\r\n}\r\n}\r\n} else {\r\nsize_t dma_csize = runtime->dma_bytes / channels;\r\nfor (c = 0; c < channels; ++c, ++bufs) {\r\nchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\r\nif (*bufs == NULL) {\r\nsnd_pcm_format_set_silence(runtime->format, hwbuf, frames);\r\n} else {\r\nchar __user *buf = *bufs + samples_to_bytes(runtime, off);\r\nif (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\r\nvoid __user **bufs,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint nonblock;\r\nint err;\r\nerr = pcm_sanity_check(substream);\r\nif (err < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nnonblock = !!(substream->f_flags & O_NONBLOCK);\r\nif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\r\nreturn -EINVAL;\r\nreturn snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,\r\nnonblock, snd_pcm_lib_writev_transfer);\r\n}\r\nstatic int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,\r\nunsigned int hwoff,\r\nunsigned long data, unsigned int off,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\r\nif (substream->ops->copy) {\r\nif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\r\nreturn err;\r\n} else {\r\nchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\r\nif (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,\r\nunsigned long data,\r\nsnd_pcm_uframes_t size,\r\nint nonblock,\r\ntransfer_f transfer)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t xfer = 0;\r\nsnd_pcm_uframes_t offset = 0;\r\nsnd_pcm_uframes_t avail;\r\nint err = 0;\r\nif (size == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nif (size >= runtime->start_threshold) {\r\nerr = snd_pcm_start(substream);\r\nif (err < 0)\r\ngoto _end_unlock;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_STATE_DRAINING:\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\ngoto _end_unlock;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = -ESTRPIPE;\r\ngoto _end_unlock;\r\ndefault:\r\nerr = -EBADFD;\r\ngoto _end_unlock;\r\n}\r\nruntime->twake = runtime->control->avail_min ? : 1;\r\nif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\r\nsnd_pcm_update_hw_ptr(substream);\r\navail = snd_pcm_capture_avail(runtime);\r\nwhile (size > 0) {\r\nsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\r\nsnd_pcm_uframes_t cont;\r\nif (!avail) {\r\nif (runtime->status->state ==\r\nSNDRV_PCM_STATE_DRAINING) {\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\r\ngoto _end_unlock;\r\n}\r\nif (nonblock) {\r\nerr = -EAGAIN;\r\ngoto _end_unlock;\r\n}\r\nruntime->twake = min_t(snd_pcm_uframes_t, size,\r\nruntime->control->avail_min ? : 1);\r\nerr = wait_for_avail(substream, &avail);\r\nif (err < 0)\r\ngoto _end_unlock;\r\nif (!avail)\r\ncontinue;\r\n}\r\nframes = size > avail ? avail : size;\r\ncont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\r\nif (frames > cont)\r\nframes = cont;\r\nif (snd_BUG_ON(!frames)) {\r\nruntime->twake = 0;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EINVAL;\r\n}\r\nappl_ptr = runtime->control->appl_ptr;\r\nappl_ofs = appl_ptr % runtime->buffer_size;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nerr = transfer(substream, appl_ofs, data, offset, frames);\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (err < 0)\r\ngoto _end_unlock;\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\ngoto _end_unlock;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = -ESTRPIPE;\r\ngoto _end_unlock;\r\ndefault:\r\nbreak;\r\n}\r\nappl_ptr += frames;\r\nif (appl_ptr >= runtime->boundary)\r\nappl_ptr -= runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nif (substream->ops->ack)\r\nsubstream->ops->ack(substream);\r\noffset += frames;\r\nsize -= frames;\r\nxfer += frames;\r\navail -= frames;\r\n}\r\n_end_unlock:\r\nruntime->twake = 0;\r\nif (xfer > 0 && err >= 0)\r\nsnd_pcm_update_state(substream, runtime);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint nonblock;\r\nint err;\r\nerr = pcm_sanity_check(substream);\r\nif (err < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nnonblock = !!(substream->f_flags & O_NONBLOCK);\r\nif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)\r\nreturn -EINVAL;\r\nreturn snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);\r\n}\r\nstatic int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,\r\nunsigned int hwoff,\r\nunsigned long data, unsigned int off,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nvoid __user **bufs = (void __user **)data;\r\nint channels = runtime->channels;\r\nint c;\r\nif (substream->ops->copy) {\r\nfor (c = 0; c < channels; ++c, ++bufs) {\r\nchar __user *buf;\r\nif (*bufs == NULL)\r\ncontinue;\r\nbuf = *bufs + samples_to_bytes(runtime, off);\r\nif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\r\nreturn err;\r\n}\r\n} else {\r\nsnd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;\r\nfor (c = 0; c < channels; ++c, ++bufs) {\r\nchar *hwbuf;\r\nchar __user *buf;\r\nif (*bufs == NULL)\r\ncontinue;\r\nhwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\r\nbuf = *bufs + samples_to_bytes(runtime, off);\r\nif (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,\r\nvoid __user **bufs,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint nonblock;\r\nint err;\r\nerr = pcm_sanity_check(substream);\r\nif (err < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nnonblock = !!(substream->f_flags & O_NONBLOCK);\r\nif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\r\nreturn -EINVAL;\r\nreturn snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);\r\n}\r\nstatic bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)\r\n{\r\nif (ch > info->max_channels)\r\nreturn false;\r\nreturn !info->channel_mask || (info->channel_mask & (1U << ch));\r\n}\r\nstatic int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 0;\r\nuinfo->count = info->max_channels;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_CHMAP_LAST;\r\nreturn 0;\r\n}\r\nstatic int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nstruct snd_pcm_substream *substream;\r\nconst struct snd_pcm_chmap_elem *map;\r\nif (snd_BUG_ON(!info->chmap))\r\nreturn -EINVAL;\r\nsubstream = snd_pcm_chmap_substream(info, idx);\r\nif (!substream)\r\nreturn -ENODEV;\r\nmemset(ucontrol->value.integer.value, 0,\r\nsizeof(ucontrol->value.integer.value));\r\nif (!substream->runtime)\r\nreturn 0;\r\nfor (map = info->chmap; map->channels; map++) {\r\nint i;\r\nif (map->channels == substream->runtime->channels &&\r\nvalid_chmap_channels(info, map->channels)) {\r\nfor (i = 0; i < map->channels; i++)\r\nucontrol->value.integer.value[i] = map->map[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nconst struct snd_pcm_chmap_elem *map;\r\nunsigned int __user *dst;\r\nint c, count = 0;\r\nif (snd_BUG_ON(!info->chmap))\r\nreturn -EINVAL;\r\nif (size < 8)\r\nreturn -ENOMEM;\r\nif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\r\nreturn -EFAULT;\r\nsize -= 8;\r\ndst = tlv + 2;\r\nfor (map = info->chmap; map->channels; map++) {\r\nint chs_bytes = map->channels * 4;\r\nif (!valid_chmap_channels(info, map->channels))\r\ncontinue;\r\nif (size < 8)\r\nreturn -ENOMEM;\r\nif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\r\nput_user(chs_bytes, dst + 1))\r\nreturn -EFAULT;\r\ndst += 2;\r\nsize -= 8;\r\ncount += 8;\r\nif (size < chs_bytes)\r\nreturn -ENOMEM;\r\nsize -= chs_bytes;\r\ncount += chs_bytes;\r\nfor (c = 0; c < map->channels; c++) {\r\nif (put_user(map->map[c], dst))\r\nreturn -EFAULT;\r\ndst++;\r\n}\r\n}\r\nif (put_user(count, tlv + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\ninfo->pcm->streams[info->stream].chmap_kctl = NULL;\r\nkfree(info);\r\n}\r\nint snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,\r\nconst struct snd_pcm_chmap_elem *chmap,\r\nint max_channels,\r\nunsigned long private_value,\r\nstruct snd_pcm_chmap **info_ret)\r\n{\r\nstruct snd_pcm_chmap *info;\r\nstruct snd_kcontrol_new knew = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_PCM,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\r\n.info = pcm_chmap_ctl_info,\r\n.get = pcm_chmap_ctl_get,\r\n.tlv.c = pcm_chmap_ctl_tlv,\r\n};\r\nint err;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pcm = pcm;\r\ninfo->stream = stream;\r\ninfo->chmap = chmap;\r\ninfo->max_channels = max_channels;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nknew.name = "Playback Channel Map";\r\nelse\r\nknew.name = "Capture Channel Map";\r\nknew.device = pcm->device;\r\nknew.count = pcm->streams[stream].substream_count;\r\nknew.private_value = private_value;\r\ninfo->kctl = snd_ctl_new1(&knew, info);\r\nif (!info->kctl) {\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\ninfo->kctl->private_free = pcm_chmap_ctl_private_free;\r\nerr = snd_ctl_add(pcm->card, info->kctl);\r\nif (err < 0)\r\nreturn err;\r\npcm->streams[stream].chmap_kctl = info->kctl;\r\nif (info_ret)\r\n*info_ret = info;\r\nreturn 0;\r\n}
