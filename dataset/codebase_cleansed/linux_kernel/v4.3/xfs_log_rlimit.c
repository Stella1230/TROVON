STATIC int\r\nxfs_log_calc_max_attrsetm_res(\r\nstruct xfs_mount *mp)\r\n{\r\nint size;\r\nint nblks;\r\nsize = xfs_attr_leaf_entsize_local_max(mp->m_attr_geo->blksize) -\r\nMAXNAMELEN - 1;\r\nnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\r\nnblks += XFS_B_TO_FSB(mp, size);\r\nnblks += XFS_NEXTENTADD_SPACE_RES(mp, size, XFS_ATTR_FORK);\r\nreturn M_RES(mp)->tr_attrsetm.tr_logres +\r\nM_RES(mp)->tr_attrsetrt.tr_logres * nblks;\r\n}\r\nSTATIC void\r\nxfs_log_get_max_trans_res(\r\nstruct xfs_mount *mp,\r\nstruct xfs_trans_res *max_resp)\r\n{\r\nstruct xfs_trans_res *resp;\r\nstruct xfs_trans_res *end_resp;\r\nint log_space = 0;\r\nint attr_space;\r\nattr_space = xfs_log_calc_max_attrsetm_res(mp);\r\nresp = (struct xfs_trans_res *)M_RES(mp);\r\nend_resp = (struct xfs_trans_res *)(M_RES(mp) + 1);\r\nfor (; resp < end_resp; resp++) {\r\nint tmp = resp->tr_logcount > 1 ?\r\nresp->tr_logres * resp->tr_logcount :\r\nresp->tr_logres;\r\nif (log_space < tmp) {\r\nlog_space = tmp;\r\n*max_resp = *resp;\r\n}\r\n}\r\nif (attr_space > log_space) {\r\n*max_resp = M_RES(mp)->tr_attrsetm;\r\nmax_resp->tr_logres = attr_space;\r\n}\r\n}\r\nint\r\nxfs_log_calc_minimum_size(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_trans_res tres = {0};\r\nint max_logres;\r\nint min_logblks = 0;\r\nint lsunit = 0;\r\nxfs_log_get_max_trans_res(mp, &tres);\r\nmax_logres = xfs_log_calc_unit_res(mp, tres.tr_logres);\r\nif (tres.tr_logcount > 1)\r\nmax_logres *= tres.tr_logcount;\r\nif (xfs_sb_version_haslogv2(&mp->m_sb) && mp->m_sb.sb_logsunit > 1)\r\nlsunit = BTOBB(mp->m_sb.sb_logsunit);\r\nif (lsunit) {\r\nmin_logblks = roundup_64(BTOBB(max_logres), lsunit) +\r\n2 * lsunit;\r\n} else\r\nmin_logblks = BTOBB(max_logres) + 2 * BBSIZE;\r\nmin_logblks *= XFS_MIN_LOG_FACTOR;\r\nreturn XFS_BB_TO_FSB(mp, min_logblks);\r\n}
