__iomem void *plat_of_remap_node(const char *node)\r\n{\r\nstruct resource res;\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, node);\r\nif (!np)\r\npanic("Failed to find %s node", node);\r\nif (of_address_to_resource(np, 0, &res))\r\npanic("Failed to get resource for %s", node);\r\nif ((request_mem_region(res.start,\r\nresource_size(&res),\r\nres.name) < 0))\r\npanic("Failed to request resources for %s", node);\r\nreturn ioremap_nocache(res.start, resource_size(&res));\r\n}\r\nvoid __init device_tree_init(void)\r\n{\r\nunflatten_and_copy_device_tree();\r\n}\r\nstatic int __init early_init_dt_find_memory(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nif (depth == 1 && !strcmp(uname, "memory@0"))\r\nmemory_dtb = 1;\r\nreturn 0;\r\n}\r\nvoid __init plat_mem_setup(void)\r\n{\r\nset_io_port_base(KSEG1);\r\n__dt_setup_arch(__dtb_start);\r\nstrlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);\r\nof_scan_flat_dt(early_init_dt_find_memory, NULL);\r\nif (memory_dtb)\r\nof_scan_flat_dt(early_init_dt_scan_memory, NULL);\r\nelse if (soc_info.mem_size)\r\nadd_memory_region(soc_info.mem_base, soc_info.mem_size * SZ_1M,\r\nBOOT_MEM_RAM);\r\nelse\r\ndetect_memory_region(soc_info.mem_base,\r\nsoc_info.mem_size_min * SZ_1M,\r\nsoc_info.mem_size_max * SZ_1M);\r\n}\r\nstatic int __init plat_of_setup(void)\r\n{\r\n__dt_register_buses(soc_info.compatible, "palmbus");\r\nralink_rst_init();\r\nreturn 0;\r\n}
