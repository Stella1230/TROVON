int lio_cn6xxx_soft_reset(struct octeon_device *oct)\r\n{\r\nocteon_write_csr64(oct, CN6XXX_WIN_WR_MASK_REG, 0xFF);\r\ndev_dbg(&oct->pci_dev->dev, "BIST enabled for soft reset\n");\r\nlio_pci_writeq(oct, 1, CN6XXX_CIU_SOFT_BIST);\r\nocteon_write_csr64(oct, CN6XXX_SLI_SCRATCH1, 0x1234ULL);\r\nlio_pci_readq(oct, CN6XXX_CIU_SOFT_RST);\r\nlio_pci_writeq(oct, 1, CN6XXX_CIU_SOFT_RST);\r\nmmiowb();\r\nmdelay(100);\r\nif (octeon_read_csr64(oct, CN6XXX_SLI_SCRATCH1) == 0x1234ULL) {\r\ndev_err(&oct->pci_dev->dev, "Soft reset failed\n");\r\nreturn 1;\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "Reset completed\n");\r\nocteon_write_csr64(oct, CN6XXX_WIN_WR_MASK_REG, 0xFF);\r\nreturn 0;\r\n}\r\nvoid lio_cn6xxx_enable_error_reporting(struct octeon_device *oct)\r\n{\r\nu32 val;\r\npci_read_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, &val);\r\nif (val & 0x000f0000) {\r\ndev_err(&oct->pci_dev->dev, "PCI-E Link error detected: 0x%08x\n",\r\nval & 0x000f0000);\r\n}\r\nval |= 0xf;\r\ndev_dbg(&oct->pci_dev->dev, "Enabling PCI-E error reporting..\n");\r\npci_write_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, val);\r\n}\r\nvoid lio_cn6xxx_setup_pcie_mps(struct octeon_device *oct,\r\nenum octeon_pcie_mps mps)\r\n{\r\nu32 val;\r\nu64 r64;\r\npci_read_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, &val);\r\nif (mps == PCIE_MPS_DEFAULT) {\r\nmps = ((val & (0x7 << 5)) >> 5);\r\n} else {\r\nval &= ~(0x7 << 5);\r\nval |= (mps << 5);\r\npci_write_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, val);\r\n}\r\nr64 = lio_pci_readq(oct, CN6XXX_DPI_SLI_PRTX_CFG(oct->pcie_port));\r\nr64 |= (mps << 4);\r\nlio_pci_writeq(oct, r64, CN6XXX_DPI_SLI_PRTX_CFG(oct->pcie_port));\r\n}\r\nvoid lio_cn6xxx_setup_pcie_mrrs(struct octeon_device *oct,\r\nenum octeon_pcie_mrrs mrrs)\r\n{\r\nu32 val;\r\nu64 r64;\r\npci_read_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, &val);\r\nif (mrrs == PCIE_MRRS_DEFAULT) {\r\nmrrs = ((val & (0x7 << 12)) >> 12);\r\n} else {\r\nval &= ~(0x7 << 12);\r\nval |= (mrrs << 12);\r\npci_write_config_dword(oct->pci_dev, CN6XXX_PCIE_DEVCTL, val);\r\n}\r\nr64 = octeon_read_csr64(oct, CN6XXX_SLI_S2M_PORTX_CTL(oct->pcie_port));\r\nr64 |= mrrs;\r\nocteon_write_csr64(oct, CN6XXX_SLI_S2M_PORTX_CTL(oct->pcie_port), r64);\r\nr64 = lio_pci_readq(oct, CN6XXX_DPI_SLI_PRTX_CFG(oct->pcie_port));\r\nr64 |= mrrs;\r\nlio_pci_writeq(oct, r64, CN6XXX_DPI_SLI_PRTX_CFG(oct->pcie_port));\r\n}\r\nu32 lio_cn6xxx_coprocessor_clock(struct octeon_device *oct)\r\n{\r\nreturn ((lio_pci_readq(oct, CN6XXX_MIO_RST_BOOT) >> 24) & 0x3f) * 50;\r\n}\r\nu32 lio_cn6xxx_get_oq_ticks(struct octeon_device *oct,\r\nu32 time_intr_in_us)\r\n{\r\nu32 oqticks_per_us = lio_cn6xxx_coprocessor_clock(oct);\r\noqticks_per_us *= 1000;\r\noqticks_per_us /= 1024;\r\noqticks_per_us *= time_intr_in_us;\r\noqticks_per_us /= 1000;\r\nreturn oqticks_per_us;\r\n}\r\nvoid lio_cn6xxx_setup_global_input_regs(struct octeon_device *oct)\r\n{\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_INPUT_CONTROL,\r\nCN6XXX_INPUT_CTL_MASK);\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_INSTR_RD_SIZE,\r\n0xFFFFFFFFFFFFFFFFULL);\r\nocteon_write_csr64(oct, CN6XXX_SLI_IN_PCIE_PORT,\r\n(oct->pcie_port * 0x5555555555555555ULL));\r\n}\r\nstatic void lio_cn66xx_setup_pkt_ctl_regs(struct octeon_device *oct)\r\n{\r\nu64 pktctl;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\npktctl = octeon_read_csr64(oct, CN6XXX_SLI_PKT_CTL);\r\nif (CFG_GET_OQ_MAX_Q(cn6xxx->conf) <= 4)\r\npktctl &= ~(1 << 4);\r\nelse\r\npktctl |= (1 << 4);\r\nif (CFG_GET_IS_SLI_BP_ON(cn6xxx->conf))\r\npktctl |= 0xF;\r\nelse\r\npktctl &= ~0xF;\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_CTL, pktctl);\r\n}\r\nvoid lio_cn6xxx_setup_global_output_regs(struct octeon_device *oct)\r\n{\r\nu32 time_threshold;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_PCIE_PORT64,\r\n(oct->pcie_port * 0x5555555555555555ULL));\r\nif (CFG_GET_IS_SLI_BP_ON(cn6xxx->conf)) {\r\nocteon_write_csr64(oct, CN6XXX_SLI_OQ_WMARK, 32);\r\n} else {\r\nocteon_write_csr64(oct, CN6XXX_SLI_OQ_WMARK, 0);\r\n}\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_IPTR, 0xFFFFFFFF);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_BMODE, 0);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_DPADDR, 0xFFFFFFFF);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_SLIST_ROR, 0);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_SLIST_NS, 0);\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_SLIST_ES64,\r\n0x5555555555555555ULL);\r\n#else\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_SLIST_ES64, 0ULL);\r\n#endif\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_DATA_OUT_ROR, 0);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_DATA_OUT_NS, 0);\r\nocteon_write_csr64(oct, CN6XXX_SLI_PKT_DATA_OUT_ES64,\r\n0x5555555555555555ULL);\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_INT_LEVEL_PKTS,\r\n(u32)CFG_GET_OQ_INTR_PKT(cn6xxx->conf));\r\ntime_threshold =\r\nlio_cn6xxx_get_oq_ticks(oct, (u32)\r\nCFG_GET_OQ_INTR_TIME(cn6xxx->conf));\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_INT_LEVEL_TIME, time_threshold);\r\n}\r\nstatic int lio_cn6xxx_setup_device_regs(struct octeon_device *oct)\r\n{\r\nlio_cn6xxx_setup_pcie_mps(oct, PCIE_MPS_DEFAULT);\r\nlio_cn6xxx_setup_pcie_mrrs(oct, PCIE_MRRS_512B);\r\nlio_cn6xxx_enable_error_reporting(oct);\r\nlio_cn6xxx_setup_global_input_regs(oct);\r\nlio_cn66xx_setup_pkt_ctl_regs(oct);\r\nlio_cn6xxx_setup_global_output_regs(oct);\r\nocteon_write_csr64(oct, CN6XXX_SLI_WINDOW_CTL, 0x200000ULL);\r\nreturn 0;\r\n}\r\nvoid lio_cn6xxx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)\r\n{\r\nstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\r\nocteon_write_csr64(oct, CN6XXX_SLI_IQ_PKT_INSTR_HDR64(iq_no), 0);\r\nocteon_write_csr64(oct, CN6XXX_SLI_IQ_BASE_ADDR64(iq_no),\r\niq->base_addr_dma);\r\nocteon_write_csr(oct, CN6XXX_SLI_IQ_SIZE(iq_no), iq->max_count);\r\niq->doorbell_reg = oct->mmio[0].hw_addr + CN6XXX_SLI_IQ_DOORBELL(iq_no);\r\niq->inst_cnt_reg = oct->mmio[0].hw_addr\r\n+ CN6XXX_SLI_IQ_INSTR_COUNT(iq_no);\r\ndev_dbg(&oct->pci_dev->dev, "InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\n",\r\niq_no, iq->doorbell_reg, iq->inst_cnt_reg);\r\niq->reset_instr_cnt = readl(iq->inst_cnt_reg);\r\n}\r\nstatic void lio_cn66xx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)\r\n{\r\nlio_cn6xxx_setup_iq_regs(oct, iq_no);\r\nocteon_write_csr64(oct, CN66XX_SLI_IQ_BP64(iq_no),\r\n(0xFFFFFFFFULL << 32));\r\n}\r\nvoid lio_cn6xxx_setup_oq_regs(struct octeon_device *oct, u32 oq_no)\r\n{\r\nu32 intr;\r\nstruct octeon_droq *droq = oct->droq[oq_no];\r\nocteon_write_csr64(oct, CN6XXX_SLI_OQ_BASE_ADDR64(oq_no),\r\ndroq->desc_ring_dma);\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_SIZE(oq_no), droq->max_count);\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_BUFF_INFO_SIZE(oq_no),\r\n(droq->buffer_size | (OCT_RH_SIZE << 16)));\r\ndroq->pkts_sent_reg =\r\noct->mmio[0].hw_addr + CN6XXX_SLI_OQ_PKTS_SENT(oq_no);\r\ndroq->pkts_credit_reg =\r\noct->mmio[0].hw_addr + CN6XXX_SLI_OQ_PKTS_CREDIT(oq_no);\r\nintr = octeon_read_csr(oct, CN6XXX_SLI_PKT_TIME_INT_ENB);\r\nintr |= (1 << oq_no);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_TIME_INT_ENB, intr);\r\nintr = octeon_read_csr(oct, CN6XXX_SLI_PKT_CNT_INT_ENB);\r\nintr |= (1 << oq_no);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_CNT_INT_ENB, intr);\r\n}\r\nvoid lio_cn6xxx_enable_io_queues(struct octeon_device *oct)\r\n{\r\nu32 mask;\r\nmask = octeon_read_csr(oct, CN6XXX_SLI_PKT_INSTR_SIZE);\r\nmask |= oct->io_qmask.iq64B;\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_INSTR_SIZE, mask);\r\nmask = octeon_read_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB);\r\nmask |= oct->io_qmask.iq;\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB, mask);\r\nmask = octeon_read_csr(oct, CN6XXX_SLI_PKT_OUT_ENB);\r\nmask |= oct->io_qmask.oq;\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, mask);\r\n}\r\nvoid lio_cn6xxx_disable_io_queues(struct octeon_device *oct)\r\n{\r\nu32 mask, i, loop = HZ;\r\nu32 d32;\r\nmask = octeon_read_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB);\r\nmask ^= oct->io_qmask.iq;\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB, mask);\r\nmask = oct->io_qmask.iq;\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PORT_IN_RST_IQ);\r\nwhile (((d32 & mask) != mask) && loop--) {\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PORT_IN_RST_IQ);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES; i++) {\r\nif (!(oct->io_qmask.iq & (1UL << i)))\r\ncontinue;\r\nocteon_write_csr(oct, CN6XXX_SLI_IQ_DOORBELL(i), 0xFFFFFFFF);\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_IQ_DOORBELL(i));\r\n}\r\nmask = octeon_read_csr(oct, CN6XXX_SLI_PKT_OUT_ENB);\r\nmask ^= oct->io_qmask.oq;\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, mask);\r\nloop = HZ;\r\nmask = oct->io_qmask.oq;\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PORT_IN_RST_OQ);\r\nwhile (((d32 & mask) != mask) && loop--) {\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PORT_IN_RST_OQ);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n;\r\nfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES; i++) {\r\nif (!(oct->io_qmask.oq & (1UL << i)))\r\ncontinue;\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_PKTS_CREDIT(i), 0xFFFFFFFF);\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_OQ_PKTS_CREDIT(i));\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_OQ_PKTS_SENT(i));\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_PKTS_SENT(i), d32);\r\n}\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PKT_CNT_INT);\r\nif (d32)\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_CNT_INT, d32);\r\nd32 = octeon_read_csr(oct, CN6XXX_SLI_PKT_TIME_INT);\r\nif (d32)\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_TIME_INT, d32);\r\n}\r\nvoid lio_cn6xxx_reinit_regs(struct octeon_device *oct)\r\n{\r\nu32 i;\r\nfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES; i++) {\r\nif (!(oct->io_qmask.iq & (1UL << i)))\r\ncontinue;\r\noct->fn_list.setup_iq_regs(oct, i);\r\n}\r\nfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES; i++) {\r\nif (!(oct->io_qmask.oq & (1UL << i)))\r\ncontinue;\r\noct->fn_list.setup_oq_regs(oct, i);\r\n}\r\noct->fn_list.setup_device_regs(oct);\r\noct->fn_list.enable_interrupt(oct->chip);\r\noct->fn_list.enable_io_queues(oct);\r\nfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES; i++) {\r\nif (!(oct->io_qmask.oq & (1UL << i)))\r\ncontinue;\r\nwritel(oct->droq[i]->max_count, oct->droq[i]->pkts_credit_reg);\r\n}\r\n}\r\nvoid\r\nlio_cn6xxx_bar1_idx_setup(struct octeon_device *oct,\r\nu64 core_addr,\r\nu32 idx,\r\nint valid)\r\n{\r\nu64 bar1;\r\nif (valid == 0) {\r\nbar1 = lio_pci_readq(oct, CN6XXX_BAR1_REG(idx, oct->pcie_port));\r\nlio_pci_writeq(oct, (bar1 & 0xFFFFFFFEULL),\r\nCN6XXX_BAR1_REG(idx, oct->pcie_port));\r\nbar1 = lio_pci_readq(oct, CN6XXX_BAR1_REG(idx, oct->pcie_port));\r\nreturn;\r\n}\r\nlio_pci_writeq(oct, (((core_addr >> 22) << 4) | PCI_BAR1_MASK),\r\nCN6XXX_BAR1_REG(idx, oct->pcie_port));\r\nbar1 = lio_pci_readq(oct, CN6XXX_BAR1_REG(idx, oct->pcie_port));\r\n}\r\nvoid lio_cn6xxx_bar1_idx_write(struct octeon_device *oct,\r\nu32 idx,\r\nu32 mask)\r\n{\r\nlio_pci_writeq(oct, mask, CN6XXX_BAR1_REG(idx, oct->pcie_port));\r\n}\r\nu32 lio_cn6xxx_bar1_idx_read(struct octeon_device *oct, u32 idx)\r\n{\r\nreturn (u32)lio_pci_readq(oct, CN6XXX_BAR1_REG(idx, oct->pcie_port));\r\n}\r\nvoid lio_cn6xxx_enable_interrupt(void *chip)\r\n{\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;\r\nu64 mask = cn6xxx->intr_mask64 | CN6XXX_INTR_DMA0_FORCE;\r\nwriteq(mask, cn6xxx->intr_enb_reg64);\r\n}\r\nvoid lio_cn6xxx_disable_interrupt(void *chip)\r\n{\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;\r\nwriteq(0, cn6xxx->intr_enb_reg64);\r\nmmiowb();\r\n}\r\nstatic void lio_cn6xxx_get_pcie_qlmport(struct octeon_device *oct)\r\n{\r\noct->pcie_port = octeon_read_csr(oct, CN6XXX_SLI_MAC_NUMBER) & 0xff;\r\ndev_dbg(&oct->pci_dev->dev, "Using PCIE Port %d\n", oct->pcie_port);\r\n}\r\nvoid\r\nlio_cn6xxx_process_pcie_error_intr(struct octeon_device *oct, u64 intr64)\r\n{\r\ndev_err(&oct->pci_dev->dev, "Error Intr: 0x%016llx\n",\r\nCVM_CAST64(intr64));\r\n}\r\nint lio_cn6xxx_process_droq_intr_regs(struct octeon_device *oct)\r\n{\r\nstruct octeon_droq *droq;\r\nu32 oq_no, pkt_count, droq_time_mask, droq_mask, droq_int_enb;\r\nu32 droq_cnt_enb, droq_cnt_mask;\r\ndroq_cnt_enb = octeon_read_csr(oct, CN6XXX_SLI_PKT_CNT_INT_ENB);\r\ndroq_cnt_mask = octeon_read_csr(oct, CN6XXX_SLI_PKT_CNT_INT);\r\ndroq_mask = droq_cnt_mask & droq_cnt_enb;\r\ndroq_time_mask = octeon_read_csr(oct, CN6XXX_SLI_PKT_TIME_INT);\r\ndroq_int_enb = octeon_read_csr(oct, CN6XXX_SLI_PKT_TIME_INT_ENB);\r\ndroq_mask |= (droq_time_mask & droq_int_enb);\r\ndroq_mask &= oct->io_qmask.oq;\r\noct->droq_intr = 0;\r\nfor (oq_no = 0; oq_no < MAX_OCTEON_OUTPUT_QUEUES; oq_no++) {\r\nif (!(droq_mask & (1 << oq_no)))\r\ncontinue;\r\ndroq = oct->droq[oq_no];\r\npkt_count = octeon_droq_check_hw_for_pkts(oct, droq);\r\nif (pkt_count) {\r\noct->droq_intr |= (1ULL << oq_no);\r\nif (droq->ops.poll_mode) {\r\nu32 value;\r\nu32 reg;\r\nstruct octeon_cn6xxx *cn6xxx =\r\n(struct octeon_cn6xxx *)oct->chip;\r\nspin_lock\r\n(&cn6xxx->lock_for_droq_int_enb_reg);\r\nreg = CN6XXX_SLI_PKT_TIME_INT_ENB;\r\nvalue = octeon_read_csr(oct, reg);\r\nvalue &= ~(1 << oq_no);\r\nocteon_write_csr(oct, reg, value);\r\nreg = CN6XXX_SLI_PKT_CNT_INT_ENB;\r\nvalue = octeon_read_csr(oct, reg);\r\nvalue &= ~(1 << oq_no);\r\nocteon_write_csr(oct, reg, value);\r\nmmiowb();\r\nspin_unlock(&cn6xxx->lock_for_droq_int_enb_reg);\r\n}\r\n}\r\n}\r\ndroq_time_mask &= oct->io_qmask.oq;\r\ndroq_cnt_mask &= oct->io_qmask.oq;\r\nif (droq_time_mask)\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_TIME_INT, droq_time_mask);\r\nif (droq_cnt_mask)\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_CNT_INT, droq_cnt_mask);\r\nreturn 0;\r\n}\r\nirqreturn_t lio_cn6xxx_process_interrupt_regs(void *dev)\r\n{\r\nstruct octeon_device *oct = (struct octeon_device *)dev;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nu64 intr64;\r\nintr64 = readq(cn6xxx->intr_sum_reg64);\r\nif (!intr64 || (intr64 == 0xFFFFFFFFFFFFFFFFULL))\r\nreturn IRQ_NONE;\r\noct->int_status = 0;\r\nif (intr64 & CN6XXX_INTR_ERR)\r\nlio_cn6xxx_process_pcie_error_intr(oct, intr64);\r\nif (intr64 & CN6XXX_INTR_PKT_DATA) {\r\nlio_cn6xxx_process_droq_intr_regs(oct);\r\noct->int_status |= OCT_DEV_INTR_PKT_DATA;\r\n}\r\nif (intr64 & CN6XXX_INTR_DMA0_FORCE)\r\noct->int_status |= OCT_DEV_INTR_DMA0_FORCE;\r\nif (intr64 & CN6XXX_INTR_DMA1_FORCE)\r\noct->int_status |= OCT_DEV_INTR_DMA1_FORCE;\r\nwriteq(intr64, cn6xxx->intr_sum_reg64);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid lio_cn6xxx_setup_reg_address(struct octeon_device *oct,\r\nvoid *chip,\r\nstruct octeon_reg_list *reg_list)\r\n{\r\nu8 __iomem *bar0_pciaddr = oct->mmio[0].hw_addr;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;\r\nreg_list->pci_win_wr_addr_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_ADDR_HI);\r\nreg_list->pci_win_wr_addr_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_ADDR_LO);\r\nreg_list->pci_win_wr_addr =\r\n(u64 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_ADDR64);\r\nreg_list->pci_win_rd_addr_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_ADDR_HI);\r\nreg_list->pci_win_rd_addr_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_ADDR_LO);\r\nreg_list->pci_win_rd_addr =\r\n(u64 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_ADDR64);\r\nreg_list->pci_win_wr_data_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_DATA_HI);\r\nreg_list->pci_win_wr_data_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_DATA_LO);\r\nreg_list->pci_win_wr_data =\r\n(u64 __iomem *)(bar0_pciaddr + CN6XXX_WIN_WR_DATA64);\r\nreg_list->pci_win_rd_data_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_DATA_HI);\r\nreg_list->pci_win_rd_data_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_DATA_LO);\r\nreg_list->pci_win_rd_data =\r\n(u64 __iomem *)(bar0_pciaddr + CN6XXX_WIN_RD_DATA64);\r\nlio_cn6xxx_get_pcie_qlmport(oct);\r\ncn6xxx->intr_sum_reg64 = bar0_pciaddr + CN6XXX_SLI_INT_SUM64;\r\ncn6xxx->intr_mask64 = CN6XXX_INTR_MASK;\r\ncn6xxx->intr_enb_reg64 =\r\nbar0_pciaddr + CN6XXX_SLI_INT_ENB64(oct->pcie_port);\r\n}\r\nint lio_setup_cn66xx_octeon_device(struct octeon_device *oct)\r\n{\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nif (octeon_map_pci_barx(oct, 0, 0))\r\nreturn 1;\r\nif (octeon_map_pci_barx(oct, 1, MAX_BAR1_IOREMAP_SIZE)) {\r\ndev_err(&oct->pci_dev->dev, "%s CN66XX BAR1 map failed\n",\r\n__func__);\r\nocteon_unmap_pci_barx(oct, 0);\r\nreturn 1;\r\n}\r\nspin_lock_init(&cn6xxx->lock_for_droq_int_enb_reg);\r\noct->fn_list.setup_iq_regs = lio_cn66xx_setup_iq_regs;\r\noct->fn_list.setup_oq_regs = lio_cn6xxx_setup_oq_regs;\r\noct->fn_list.soft_reset = lio_cn6xxx_soft_reset;\r\noct->fn_list.setup_device_regs = lio_cn6xxx_setup_device_regs;\r\noct->fn_list.reinit_regs = lio_cn6xxx_reinit_regs;\r\noct->fn_list.update_iq_read_idx = lio_cn6xxx_update_read_index;\r\noct->fn_list.bar1_idx_setup = lio_cn6xxx_bar1_idx_setup;\r\noct->fn_list.bar1_idx_write = lio_cn6xxx_bar1_idx_write;\r\noct->fn_list.bar1_idx_read = lio_cn6xxx_bar1_idx_read;\r\noct->fn_list.process_interrupt_regs = lio_cn6xxx_process_interrupt_regs;\r\noct->fn_list.enable_interrupt = lio_cn6xxx_enable_interrupt;\r\noct->fn_list.disable_interrupt = lio_cn6xxx_disable_interrupt;\r\noct->fn_list.enable_io_queues = lio_cn6xxx_enable_io_queues;\r\noct->fn_list.disable_io_queues = lio_cn6xxx_disable_io_queues;\r\nlio_cn6xxx_setup_reg_address(oct, oct->chip, &oct->reg_list);\r\ncn6xxx->conf = (struct octeon_config *)\r\noct_get_config_info(oct, LIO_210SV);\r\nif (!cn6xxx->conf) {\r\ndev_err(&oct->pci_dev->dev, "%s No Config found for CN66XX\n",\r\n__func__);\r\nocteon_unmap_pci_barx(oct, 0);\r\nocteon_unmap_pci_barx(oct, 1);\r\nreturn 1;\r\n}\r\noct->coproc_clock_rate = 1000000ULL * lio_cn6xxx_coprocessor_clock(oct);\r\nreturn 0;\r\n}\r\nint lio_validate_cn6xxx_config_info(struct octeon_device *oct,\r\nstruct octeon_config *conf6xxx)\r\n{\r\nif (CFG_GET_IQ_MAX_Q(conf6xxx) > CN6XXX_MAX_INPUT_QUEUES) {\r\ndev_err(&oct->pci_dev->dev, "%s: Num IQ (%d) exceeds Max (%d)\n",\r\n__func__, CFG_GET_IQ_MAX_Q(conf6xxx),\r\nCN6XXX_MAX_INPUT_QUEUES);\r\nreturn 1;\r\n}\r\nif (CFG_GET_OQ_MAX_Q(conf6xxx) > CN6XXX_MAX_OUTPUT_QUEUES) {\r\ndev_err(&oct->pci_dev->dev, "%s: Num OQ (%d) exceeds Max (%d)\n",\r\n__func__, CFG_GET_OQ_MAX_Q(conf6xxx),\r\nCN6XXX_MAX_OUTPUT_QUEUES);\r\nreturn 1;\r\n}\r\nif (CFG_GET_IQ_INSTR_TYPE(conf6xxx) != OCTEON_32BYTE_INSTR &&\r\nCFG_GET_IQ_INSTR_TYPE(conf6xxx) != OCTEON_64BYTE_INSTR) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid instr type for IQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (!(CFG_GET_OQ_INFO_PTR(conf6xxx)) ||\r\n!(CFG_GET_OQ_REFILL_THRESHOLD(conf6xxx))) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid parameter for OQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (!(CFG_GET_OQ_INTR_TIME(conf6xxx))) {\r\ndev_err(&oct->pci_dev->dev, "%s: No Time Interrupt for OQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
