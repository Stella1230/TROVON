static void request_module_async(struct work_struct *work)\r\n{\r\nstruct ivtv *dev = container_of(work, struct ivtv, request_module_wk);\r\nrequest_module("ivtv-alsa");\r\nif (ivtv_ext_init != NULL)\r\nivtv_ext_init(dev);\r\n}\r\nstatic void request_modules(struct ivtv *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct ivtv *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nvoid ivtv_clear_irq_mask(struct ivtv *itv, u32 mask)\r\n{\r\nitv->irqmask &= ~mask;\r\nwrite_reg_sync(itv->irqmask, IVTV_REG_IRQMASK);\r\n}\r\nvoid ivtv_set_irq_mask(struct ivtv *itv, u32 mask)\r\n{\r\nitv->irqmask |= mask;\r\nwrite_reg_sync(itv->irqmask, IVTV_REG_IRQMASK);\r\n}\r\nint ivtv_set_output_mode(struct ivtv *itv, int mode)\r\n{\r\nint old_mode;\r\nspin_lock(&itv->lock);\r\nold_mode = itv->output_mode;\r\nif (old_mode == 0)\r\nitv->output_mode = old_mode = mode;\r\nspin_unlock(&itv->lock);\r\nreturn old_mode;\r\n}\r\nstruct ivtv_stream *ivtv_get_output_stream(struct ivtv *itv)\r\n{\r\nswitch (itv->output_mode) {\r\ncase OUT_MPG:\r\nreturn &itv->streams[IVTV_DEC_STREAM_TYPE_MPG];\r\ncase OUT_YUV:\r\nreturn &itv->streams[IVTV_DEC_STREAM_TYPE_YUV];\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nint ivtv_waitq(wait_queue_head_t *waitq)\r\n{\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait(waitq, &wait, TASK_INTERRUPTIBLE);\r\nschedule();\r\nfinish_wait(waitq, &wait);\r\nreturn signal_pending(current) ? -EINTR : 0;\r\n}\r\nint ivtv_msleep_timeout(unsigned int msecs, int intr)\r\n{\r\nint timeout = msecs_to_jiffies(msecs);\r\ndo {\r\nset_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\r\ntimeout = schedule_timeout(timeout);\r\nif (intr) {\r\nint ret = signal_pending(current);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} while (timeout);\r\nreturn 0;\r\n}\r\nstatic void ivtv_iounmap(struct ivtv *itv)\r\n{\r\nif (itv == NULL)\r\nreturn;\r\nif (itv->reg_mem != NULL) {\r\nIVTV_DEBUG_INFO("releasing reg_mem\n");\r\niounmap(itv->reg_mem);\r\nitv->reg_mem = NULL;\r\n}\r\nif (itv->has_cx23415 && itv->dec_mem != NULL) {\r\nIVTV_DEBUG_INFO("releasing dec_mem\n");\r\niounmap(itv->dec_mem);\r\n}\r\nitv->dec_mem = NULL;\r\nif (itv->enc_mem != NULL) {\r\nIVTV_DEBUG_INFO("releasing enc_mem\n");\r\niounmap(itv->enc_mem);\r\nitv->enc_mem = NULL;\r\n}\r\n}\r\nvoid ivtv_read_eeprom(struct ivtv *itv, struct tveeprom *tv)\r\n{\r\nu8 eedata[256];\r\nitv->i2c_client.addr = 0xA0 >> 1;\r\ntveeprom_read(&itv->i2c_client, eedata, sizeof(eedata));\r\ntveeprom_hauppauge_analog(&itv->i2c_client, tv, eedata);\r\n}\r\nstatic void ivtv_process_eeprom(struct ivtv *itv)\r\n{\r\nstruct tveeprom tv;\r\nint pci_slot = PCI_SLOT(itv->pdev->devfn);\r\nivtv_read_eeprom(itv, &tv);\r\nswitch (tv.model) {\r\ncase 30012 ... 30039:\r\ncase 32000 ... 32999:\r\ncase 48000 ... 48099:\r\ncase 48400 ... 48599:\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_250);\r\nbreak;\r\ncase 48100 ... 48399:\r\ncase 48600 ... 48999:\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_350);\r\nbreak;\r\ncase 23000 ... 23999:\r\ncase 25000 ... 25999:\r\ncase 26000 ... 26999:\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_150);\r\nbreak;\r\ncase 0:\r\nIVTV_ERR("Invalid EEPROM\n");\r\nreturn;\r\ndefault:\r\nIVTV_ERR("Unknown model %d, defaulting to PVR-150\n", tv.model);\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_150);\r\nbreak;\r\n}\r\nswitch (tv.model) {\r\ncase 48254:\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_350_V1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nitv->v4l2_cap = itv->card->v4l2_capabilities;\r\nitv->card_name = itv->card->name;\r\nitv->card_i2c = itv->card->i2c;\r\nif (tv.model / 1000 == 23) {\r\nstatic const struct ivtv_card_tuner_i2c ivtv_i2c_radio = {\r\n.radio = { 0x60, I2C_CLIENT_END },\r\n.demod = { 0x43, I2C_CLIENT_END },\r\n.tv = { 0x61, I2C_CLIENT_END },\r\n};\r\nitv->card_name = "WinTV PVR 500";\r\nitv->card_i2c = &ivtv_i2c_radio;\r\nif (pci_slot == 8 || pci_slot == 9) {\r\nint is_first = (pci_slot & 1) == 0;\r\nitv->card_name = is_first ? "WinTV PVR 500 (unit #1)" :\r\n"WinTV PVR 500 (unit #2)";\r\nif (!is_first) {\r\nIVTV_INFO("Correcting tveeprom data: no radio present on second unit\n");\r\ntv.has_radio = 0;\r\n}\r\n}\r\n}\r\nIVTV_INFO("Autodetected %s\n", itv->card_name);\r\nswitch (tv.tuner_hauppauge_model) {\r\ncase 85:\r\ncase 99:\r\ncase 112:\r\nitv->pvr150_workaround = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (tv.tuner_type == TUNER_ABSENT)\r\nIVTV_ERR("tveeprom cannot autodetect tuner!\n");\r\nif (itv->options.tuner == -1)\r\nitv->options.tuner = tv.tuner_type;\r\nif (itv->options.radio == -1)\r\nitv->options.radio = (tv.has_radio != 0);\r\nif (itv->options.newi2c == -1 && tv.has_ir) {\r\nitv->options.newi2c = (tv.has_ir & 4) ? 1 : 0;\r\nif (itv->options.newi2c) {\r\nIVTV_INFO("Reopen i2c bus for IR-blaster support\n");\r\nexit_ivtv_i2c(itv);\r\ninit_ivtv_i2c(itv);\r\n}\r\n}\r\nif (itv->std != 0)\r\nreturn;\r\nif (tv.tuner_formats & V4L2_STD_PAL) {\r\nIVTV_DEBUG_INFO("PAL tuner detected\n");\r\nitv->std |= V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\r\n} else if (tv.tuner_formats & V4L2_STD_NTSC) {\r\nIVTV_DEBUG_INFO("NTSC tuner detected\n");\r\nitv->std |= V4L2_STD_NTSC_M;\r\n} else if (tv.tuner_formats & V4L2_STD_SECAM) {\r\nIVTV_DEBUG_INFO("SECAM tuner detected\n");\r\nitv->std |= V4L2_STD_SECAM_L;\r\n} else {\r\nIVTV_INFO("No tuner detected, default to NTSC-M\n");\r\nitv->std |= V4L2_STD_NTSC_M;\r\n}\r\n}\r\nstatic v4l2_std_id ivtv_parse_std(struct ivtv *itv)\r\n{\r\nswitch (pal[0]) {\r\ncase '6':\r\ntunertype = 0;\r\nreturn V4L2_STD_PAL_60;\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\ncase 'h':\r\ncase 'H':\r\ntunertype = 0;\r\nreturn V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\r\ncase 'n':\r\ncase 'N':\r\ntunertype = 1;\r\nif (pal[1] == 'c' || pal[1] == 'C')\r\nreturn V4L2_STD_PAL_Nc;\r\nreturn V4L2_STD_PAL_N;\r\ncase 'i':\r\ncase 'I':\r\ntunertype = 0;\r\nreturn V4L2_STD_PAL_I;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\ntunertype = 0;\r\nreturn V4L2_STD_PAL_DK;\r\ncase 'M':\r\ncase 'm':\r\ntunertype = 1;\r\nreturn V4L2_STD_PAL_M;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nIVTV_WARN("pal= argument not recognised\n");\r\nreturn 0;\r\n}\r\nswitch (secam[0]) {\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\ncase 'h':\r\ncase 'H':\r\ntunertype = 0;\r\nreturn V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\ntunertype = 0;\r\nreturn V4L2_STD_SECAM_DK;\r\ncase 'l':\r\ncase 'L':\r\ntunertype = 0;\r\nif (secam[1] == 'C' || secam[1] == 'c')\r\nreturn V4L2_STD_SECAM_LC;\r\nreturn V4L2_STD_SECAM_L;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nIVTV_WARN("secam= argument not recognised\n");\r\nreturn 0;\r\n}\r\nswitch (ntsc[0]) {\r\ncase 'm':\r\ncase 'M':\r\ntunertype = 1;\r\nreturn V4L2_STD_NTSC_M;\r\ncase 'j':\r\ncase 'J':\r\ntunertype = 1;\r\nreturn V4L2_STD_NTSC_M_JP;\r\ncase 'k':\r\ncase 'K':\r\ntunertype = 1;\r\nreturn V4L2_STD_NTSC_M_KR;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nIVTV_WARN("ntsc= argument not recognised\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ivtv_process_options(struct ivtv *itv)\r\n{\r\nconst char *chipname;\r\nint i, j;\r\nitv->options.kilobytes[IVTV_ENC_STREAM_TYPE_MPG] = enc_mpg_buffers * 1024;\r\nitv->options.kilobytes[IVTV_ENC_STREAM_TYPE_YUV] = enc_yuv_buffers * 1024;\r\nitv->options.kilobytes[IVTV_ENC_STREAM_TYPE_VBI] = enc_vbi_buffers * 1024;\r\nitv->options.kilobytes[IVTV_ENC_STREAM_TYPE_PCM] = enc_pcm_buffers;\r\nitv->options.kilobytes[IVTV_DEC_STREAM_TYPE_MPG] = dec_mpg_buffers * 1024;\r\nitv->options.kilobytes[IVTV_DEC_STREAM_TYPE_YUV] = dec_yuv_buffers * 1024;\r\nitv->options.kilobytes[IVTV_DEC_STREAM_TYPE_VBI] = dec_vbi_buffers;\r\nitv->options.cardtype = cardtype[itv->instance];\r\nitv->options.tuner = tuner[itv->instance];\r\nitv->options.radio = radio[itv->instance];\r\nitv->options.i2c_clock_period = i2c_clock_period[itv->instance];\r\nif (itv->options.i2c_clock_period == -1)\r\nitv->options.i2c_clock_period = IVTV_DEFAULT_I2C_CLOCK_PERIOD;\r\nelse if (itv->options.i2c_clock_period < 10)\r\nitv->options.i2c_clock_period = 10;\r\nelse if (itv->options.i2c_clock_period > 4500)\r\nitv->options.i2c_clock_period = 4500;\r\nitv->options.newi2c = newi2c;\r\nif (tunertype < -1 || tunertype > 1) {\r\nIVTV_WARN("Invalid tunertype argument, will autodetect instead\n");\r\ntunertype = -1;\r\n}\r\nitv->std = ivtv_parse_std(itv);\r\nif (itv->std == 0 && tunertype >= 0)\r\nitv->std = tunertype ? V4L2_STD_MN : (V4L2_STD_ALL & ~V4L2_STD_MN);\r\nitv->has_cx23415 = (itv->pdev->device == PCI_DEVICE_ID_IVTV15);\r\nchipname = itv->has_cx23415 ? "cx23415" : "cx23416";\r\nif (itv->options.cardtype == -1) {\r\nIVTV_INFO("Ignore card (detected %s based chip)\n", chipname);\r\nreturn;\r\n}\r\nif ((itv->card = ivtv_get_card(itv->options.cardtype - 1))) {\r\nIVTV_INFO("User specified %s card (detected %s based chip)\n",\r\nitv->card->name, chipname);\r\n} else if (itv->options.cardtype != 0) {\r\nIVTV_ERR("Unknown user specified type, trying to autodetect card\n");\r\n}\r\nif (itv->card == NULL) {\r\nif (itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE ||\r\nitv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT1 ||\r\nitv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT2) {\r\nitv->card = ivtv_get_card(itv->has_cx23415 ? IVTV_CARD_PVR_350 : IVTV_CARD_PVR_150);\r\nIVTV_INFO("Autodetected Hauppauge card (%s based)\n",\r\nchipname);\r\n}\r\n}\r\nif (itv->card == NULL) {\r\nfor (i = 0; (itv->card = ivtv_get_card(i)); i++) {\r\nif (itv->card->pci_list == NULL)\r\ncontinue;\r\nfor (j = 0; itv->card->pci_list[j].device; j++) {\r\nif (itv->pdev->device !=\r\nitv->card->pci_list[j].device)\r\ncontinue;\r\nif (itv->pdev->subsystem_vendor !=\r\nitv->card->pci_list[j].subsystem_vendor)\r\ncontinue;\r\nif (itv->pdev->subsystem_device !=\r\nitv->card->pci_list[j].subsystem_device)\r\ncontinue;\r\nIVTV_INFO("Autodetected %s card (%s based)\n",\r\nitv->card->name, chipname);\r\ngoto done;\r\n}\r\n}\r\n}\r\ndone:\r\nif (itv->card == NULL) {\r\nitv->card = ivtv_get_card(IVTV_CARD_PVR_150);\r\nIVTV_ERR("Unknown card: vendor/device: [%04x:%04x]\n",\r\nitv->pdev->vendor, itv->pdev->device);\r\nIVTV_ERR(" subsystem vendor/device: [%04x:%04x]\n",\r\nitv->pdev->subsystem_vendor, itv->pdev->subsystem_device);\r\nIVTV_ERR(" %s based\n", chipname);\r\nIVTV_ERR("Defaulting to %s card\n", itv->card->name);\r\nIVTV_ERR("Please mail the vendor/device and subsystem vendor/device IDs and what kind of\n");\r\nIVTV_ERR("card you have to the ivtv-devel mailinglist (www.ivtvdriver.org)\n");\r\nIVTV_ERR("Prefix your subject line with [UNKNOWN IVTV CARD].\n");\r\n}\r\nitv->v4l2_cap = itv->card->v4l2_capabilities;\r\nitv->card_name = itv->card->name;\r\nitv->card_i2c = itv->card->i2c;\r\n}\r\nstatic int ivtv_init_struct1(struct ivtv *itv)\r\n{\r\nstruct sched_param param = { .sched_priority = 99 };\r\nitv->base_addr = pci_resource_start(itv->pdev, 0);\r\nitv->enc_mbox.max_mbox = 2;\r\nitv->dec_mbox.max_mbox = 1;\r\nmutex_init(&itv->serialize_lock);\r\nmutex_init(&itv->i2c_bus_lock);\r\nmutex_init(&itv->udma.lock);\r\nspin_lock_init(&itv->lock);\r\nspin_lock_init(&itv->dma_reg_lock);\r\ninit_kthread_worker(&itv->irq_worker);\r\nitv->irq_worker_task = kthread_run(kthread_worker_fn, &itv->irq_worker,\r\n"%s", itv->v4l2_dev.name);\r\nif (IS_ERR(itv->irq_worker_task)) {\r\nIVTV_ERR("Could not create ivtv task\n");\r\nreturn -1;\r\n}\r\nsched_setscheduler(itv->irq_worker_task, SCHED_FIFO, &param);\r\ninit_kthread_work(&itv->irq_work, ivtv_irq_work_handler);\r\nitv->cxhdl.port = CX2341X_PORT_MEMORY;\r\nitv->cxhdl.capabilities = CX2341X_CAP_HAS_SLICED_VBI;\r\ninit_waitqueue_head(&itv->eos_waitq);\r\ninit_waitqueue_head(&itv->event_waitq);\r\ninit_waitqueue_head(&itv->vsync_waitq);\r\ninit_waitqueue_head(&itv->dma_waitq);\r\ninit_timer(&itv->dma_timer);\r\nitv->dma_timer.function = ivtv_unfinished_dma;\r\nitv->dma_timer.data = (unsigned long)itv;\r\nitv->cur_dma_stream = -1;\r\nitv->cur_pio_stream = -1;\r\nitv->speed = 1000;\r\nitv->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nitv->vbi.sliced_in = &itv->vbi.in.fmt.sliced;\r\nsg_init_table(itv->udma.SGlist, IVTV_DMA_SG_OSD_ENT);\r\nitv->osd_global_alpha_state = 1;\r\nitv->osd_global_alpha = 255;\r\natomic_set(&itv->yuv_info.next_dma_frame, -1);\r\nitv->yuv_info.lace_mode = ivtv_yuv_mode;\r\nitv->yuv_info.lace_threshold = ivtv_yuv_threshold;\r\nitv->yuv_info.max_frames_buffered = 3;\r\nitv->yuv_info.track_osd = 1;\r\nreturn 0;\r\n}\r\nstatic void ivtv_init_struct2(struct ivtv *itv)\r\n{\r\nint i;\r\nfor (i = 0; i < IVTV_CARD_MAX_VIDEO_INPUTS - 1; i++)\r\nif (itv->card->video_inputs[i].video_type == 0)\r\nbreak;\r\nitv->nof_inputs = i;\r\nfor (i = 0; i < IVTV_CARD_MAX_AUDIO_INPUTS - 1; i++)\r\nif (itv->card->audio_inputs[i].audio_type == 0)\r\nbreak;\r\nitv->nof_audio_inputs = i;\r\nif (itv->card->hw_all & IVTV_HW_CX25840) {\r\nitv->vbi.sliced_size = 288;\r\n} else {\r\nitv->vbi.sliced_size = 64;\r\n}\r\nfor (i = 0; i < itv->nof_inputs; i++) {\r\nif (itv->card->video_inputs[i].video_type ==\r\nIVTV_CARD_INPUT_VID_TUNER)\r\nbreak;\r\n}\r\nif (i == itv->nof_inputs)\r\ni = 0;\r\nitv->active_input = i;\r\nitv->audio_input = itv->card->video_inputs[i].audio_index;\r\n}\r\nstatic int ivtv_setup_pci(struct ivtv *itv, struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nu16 cmd;\r\nunsigned char pci_latency;\r\nIVTV_DEBUG_INFO("Enabling pci device\n");\r\nif (pci_enable_device(pdev)) {\r\nIVTV_ERR("Can't enable device!\n");\r\nreturn -EIO;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nIVTV_ERR("No suitable DMA available.\n");\r\nreturn -EIO;\r\n}\r\nif (!request_mem_region(itv->base_addr, IVTV_ENCODER_SIZE, "ivtv encoder")) {\r\nIVTV_ERR("Cannot request encoder memory region.\n");\r\nreturn -EIO;\r\n}\r\nif (!request_mem_region(itv->base_addr + IVTV_REG_OFFSET,\r\nIVTV_REG_SIZE, "ivtv registers")) {\r\nIVTV_ERR("Cannot request register memory region.\n");\r\nrelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\r\nreturn -EIO;\r\n}\r\nif (itv->has_cx23415 &&\r\n!request_mem_region(itv->base_addr + IVTV_DECODER_OFFSET,\r\nIVTV_DECODER_SIZE, "ivtv decoder")) {\r\nIVTV_ERR("Cannot request decoder memory region.\n");\r\nrelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\r\nrelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\r\nreturn -EIO;\r\n}\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif (!(cmd & PCI_COMMAND_MASTER)) {\r\nIVTV_DEBUG_INFO("Attempting to enable Bus Mastering\n");\r\npci_set_master(pdev);\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif (!(cmd & PCI_COMMAND_MASTER)) {\r\nIVTV_ERR("Bus Mastering is not enabled\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nIVTV_DEBUG_INFO("Bus Mastering Enabled.\n");\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\r\nif (pci_latency < 64 && ivtv_pci_latency) {\r\nIVTV_INFO("Unreasonably low latency timer, "\r\n"setting to 64 (was %d)\n", pci_latency);\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 64);\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\r\n}\r\npci_write_config_dword(pdev, 0x40, 0xffff);\r\nIVTV_DEBUG_INFO("%d (rev %d) at %02x:%02x.%x, "\r\n"irq: %d, latency: %d, memory: 0x%llx\n",\r\npdev->device, pdev->revision, pdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\r\npdev->irq, pci_latency, (u64)itv->base_addr);\r\nreturn 0;\r\n}\r\nstatic void ivtv_load_and_init_modules(struct ivtv *itv)\r\n{\r\nu32 hw = itv->card->hw_all;\r\nunsigned i;\r\nfor (i = 0; i < 32; i++) {\r\nu32 device = 1 << i;\r\nif (!(device & hw))\r\ncontinue;\r\nif (device == IVTV_HW_GPIO || device == IVTV_HW_TVEEPROM) {\r\nitv->hw_flags |= device;\r\ncontinue;\r\n}\r\nif (ivtv_i2c_register(itv, i) == 0)\r\nitv->hw_flags |= device;\r\n}\r\nif ((itv->hw_flags & IVTV_HW_IR_ANY) == 0)\r\nivtv_i2c_new_ir_legacy(itv);\r\nif (itv->card->hw_all & IVTV_HW_CX25840)\r\nitv->sd_video = ivtv_find_hw(itv, IVTV_HW_CX25840);\r\nelse if (itv->card->hw_all & IVTV_HW_SAA717X)\r\nitv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA717X);\r\nelse if (itv->card->hw_all & IVTV_HW_SAA7114)\r\nitv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA7114);\r\nelse\r\nitv->sd_video = ivtv_find_hw(itv, IVTV_HW_SAA7115);\r\nitv->sd_audio = ivtv_find_hw(itv, itv->card->hw_audio_ctrl);\r\nitv->sd_muxer = ivtv_find_hw(itv, itv->card->hw_muxer);\r\nhw = itv->hw_flags;\r\nif (itv->card->type == IVTV_CARD_CX23416GYC) {\r\nif ((hw & (IVTV_HW_UPD64031A | IVTV_HW_UPD6408X)) == 0)\r\nitv->card = ivtv_get_card(IVTV_CARD_CX23416GYC_NOGRYCS);\r\nelse if ((hw & IVTV_HW_UPD64031A) == 0)\r\nitv->card = ivtv_get_card(IVTV_CARD_CX23416GYC_NOGR);\r\n}\r\nelse if (itv->card->type == IVTV_CARD_GV_MVPRX ||\r\nitv->card->type == IVTV_CARD_GV_MVPRX2E) {\r\nv4l2_subdev_call(itv->sd_video, video, s_crystal_freq,\r\nSAA7115_FREQ_24_576_MHZ, SAA7115_FREQ_FL_UCGC);\r\n}\r\nif (hw & IVTV_HW_CX25840) {\r\nitv->vbi.raw_decoder_line_size = 1444;\r\nitv->vbi.raw_decoder_sav_odd_field = 0x20;\r\nitv->vbi.raw_decoder_sav_even_field = 0x60;\r\nitv->vbi.sliced_decoder_line_size = 272;\r\nitv->vbi.sliced_decoder_sav_odd_field = 0xB0;\r\nitv->vbi.sliced_decoder_sav_even_field = 0xF0;\r\n}\r\nif (hw & IVTV_HW_SAA711X) {\r\nitv->hw_flags &= ~IVTV_HW_SAA711X;\r\nif (strstr(itv->sd_video->name, "saa7114")) {\r\nitv->hw_flags |= IVTV_HW_SAA7114;\r\nitv->v4l2_cap &= ~(V4L2_CAP_SLICED_VBI_CAPTURE|V4L2_CAP_VBI_CAPTURE);\r\n} else {\r\nitv->hw_flags |= IVTV_HW_SAA7115;\r\n}\r\nitv->vbi.raw_decoder_line_size = 1443;\r\nitv->vbi.raw_decoder_sav_odd_field = 0x25;\r\nitv->vbi.raw_decoder_sav_even_field = 0x62;\r\nitv->vbi.sliced_decoder_line_size = 51;\r\nitv->vbi.sliced_decoder_sav_odd_field = 0xAB;\r\nitv->vbi.sliced_decoder_sav_even_field = 0xEC;\r\n}\r\nif (hw & IVTV_HW_SAA717X) {\r\nitv->vbi.raw_decoder_line_size = 1443;\r\nitv->vbi.raw_decoder_sav_odd_field = 0x25;\r\nitv->vbi.raw_decoder_sav_even_field = 0x62;\r\nitv->vbi.sliced_decoder_line_size = 51;\r\nitv->vbi.sliced_decoder_sav_odd_field = 0xAB;\r\nitv->vbi.sliced_decoder_sav_even_field = 0xEC;\r\n}\r\n}\r\nstatic int ivtv_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)\r\n{\r\nint retval = 0;\r\nint vbi_buf_size;\r\nstruct ivtv *itv;\r\nitv = kzalloc(sizeof(struct ivtv), GFP_ATOMIC);\r\nif (itv == NULL)\r\nreturn -ENOMEM;\r\nitv->pdev = pdev;\r\nitv->instance = v4l2_device_set_name(&itv->v4l2_dev, "ivtv",\r\n&ivtv_instance);\r\nretval = v4l2_device_register(&pdev->dev, &itv->v4l2_dev);\r\nif (retval) {\r\nkfree(itv);\r\nreturn retval;\r\n}\r\nIVTV_INFO("Initializing card %d\n", itv->instance);\r\nivtv_process_options(itv);\r\nif (itv->options.cardtype == -1) {\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\nif (ivtv_init_struct1(itv)) {\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nretval = cx2341x_handler_init(&itv->cxhdl, 50);\r\nif (retval)\r\ngoto err;\r\nitv->v4l2_dev.ctrl_handler = &itv->cxhdl.hdl;\r\nitv->cxhdl.ops = &ivtv_cxhdl_ops;\r\nitv->cxhdl.priv = itv;\r\nitv->cxhdl.func = ivtv_api_func;\r\nIVTV_DEBUG_INFO("base addr: 0x%llx\n", (u64)itv->base_addr);\r\nretval = ivtv_setup_pci(itv, pdev, pci_id);\r\nif (retval == -EIO)\r\ngoto free_worker;\r\nif (retval == -ENXIO)\r\ngoto free_mem;\r\nIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\n",\r\n(u64)itv->base_addr + IVTV_ENCODER_OFFSET, IVTV_ENCODER_SIZE);\r\nitv->enc_mem = ioremap_nocache(itv->base_addr + IVTV_ENCODER_OFFSET,\r\nIVTV_ENCODER_SIZE);\r\nif (!itv->enc_mem) {\r\nIVTV_ERR("ioremap failed. Can't get a window into CX23415/6 "\r\n"encoder memory\n");\r\nIVTV_ERR("Each capture card with a CX23415/6 needs 8 MB of "\r\n"vmalloc address space for this window\n");\r\nIVTV_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\n");\r\nIVTV_ERR("Use the vmalloc= kernel command line option to set "\r\n"VmallocTotal to a larger value\n");\r\nretval = -ENOMEM;\r\ngoto free_mem;\r\n}\r\nif (itv->has_cx23415) {\r\nIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\n",\r\n(u64)itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\r\nitv->dec_mem = ioremap_nocache(itv->base_addr + IVTV_DECODER_OFFSET,\r\nIVTV_DECODER_SIZE);\r\nif (!itv->dec_mem) {\r\nIVTV_ERR("ioremap failed. Can't get a window into "\r\n"CX23415 decoder memory\n");\r\nIVTV_ERR("Each capture card with a CX23415 needs 8 MB "\r\n"of vmalloc address space for this window\n");\r\nIVTV_ERR("Check the output of 'grep Vmalloc "\r\n"/proc/meminfo'\n");\r\nIVTV_ERR("Use the vmalloc= kernel command line option "\r\n"to set VmallocTotal to a larger value\n");\r\nretval = -ENOMEM;\r\ngoto free_mem;\r\n}\r\n}\r\nelse {\r\nitv->dec_mem = itv->enc_mem;\r\n}\r\nIVTV_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\n",\r\n(u64)itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\r\nitv->reg_mem =\r\nioremap_nocache(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\r\nif (!itv->reg_mem) {\r\nIVTV_ERR("ioremap failed. Can't get a window into CX23415/6 "\r\n"register space\n");\r\nIVTV_ERR("Each capture card with a CX23415/6 needs 64 kB of "\r\n"vmalloc address space for this window\n");\r\nIVTV_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\n");\r\nIVTV_ERR("Use the vmalloc= kernel command line option to set "\r\n"VmallocTotal to a larger value\n");\r\nretval = -ENOMEM;\r\ngoto free_io;\r\n}\r\nretval = ivtv_gpio_init(itv);\r\nif (retval)\r\ngoto free_io;\r\nIVTV_DEBUG_INFO("activating i2c...\n");\r\nif (init_ivtv_i2c(itv)) {\r\nIVTV_ERR("Could not initialize i2c\n");\r\ngoto free_io;\r\n}\r\nif (itv->card->hw_all & IVTV_HW_TVEEPROM) {\r\nivtv_process_eeprom(itv);\r\n}\r\nif (itv->card->comment)\r\nIVTV_INFO("%s", itv->card->comment);\r\nif (itv->card->v4l2_capabilities == 0) {\r\nretval = -ENODEV;\r\ngoto free_i2c;\r\n}\r\nif (itv->std == 0) {\r\nitv->std = V4L2_STD_NTSC_M;\r\n}\r\nif (itv->options.tuner == -1) {\r\nint i;\r\nfor (i = 0; i < IVTV_CARD_MAX_TUNERS; i++) {\r\nif ((itv->std & itv->card->tuners[i].std) == 0)\r\ncontinue;\r\nitv->options.tuner = itv->card->tuners[i].tuner;\r\nbreak;\r\n}\r\n}\r\nif (itv->options.tuner == -1 && itv->card->tuners[0].std) {\r\nitv->std = itv->card->tuners[0].std;\r\nif (itv->std & V4L2_STD_PAL)\r\nitv->std = V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\r\nelse if (itv->std & V4L2_STD_NTSC)\r\nitv->std = V4L2_STD_NTSC_M;\r\nelse if (itv->std & V4L2_STD_SECAM)\r\nitv->std = V4L2_STD_SECAM_L;\r\nitv->options.tuner = itv->card->tuners[0].tuner;\r\n}\r\nif (itv->options.radio == -1)\r\nitv->options.radio = (itv->card->radio_input.audio_type != 0);\r\nivtv_init_struct2(itv);\r\nivtv_load_and_init_modules(itv);\r\nif (itv->std & V4L2_STD_525_60) {\r\nitv->is_60hz = 1;\r\nitv->is_out_60hz = 1;\r\n} else {\r\nitv->is_50hz = 1;\r\nitv->is_out_50hz = 1;\r\n}\r\nitv->yuv_info.osd_full_w = 720;\r\nitv->yuv_info.osd_full_h = itv->is_out_50hz ? 576 : 480;\r\nitv->yuv_info.v4l2_src_w = itv->yuv_info.osd_full_w;\r\nitv->yuv_info.v4l2_src_h = itv->yuv_info.osd_full_h;\r\ncx2341x_handler_set_50hz(&itv->cxhdl, itv->is_50hz);\r\nitv->stream_buf_size[IVTV_ENC_STREAM_TYPE_MPG] = 0x08000;\r\nitv->stream_buf_size[IVTV_ENC_STREAM_TYPE_PCM] = 0x01200;\r\nitv->stream_buf_size[IVTV_DEC_STREAM_TYPE_MPG] = 0x10000;\r\nitv->stream_buf_size[IVTV_DEC_STREAM_TYPE_YUV] = 0x10000;\r\nitv->stream_buf_size[IVTV_ENC_STREAM_TYPE_YUV] = 0x08000;\r\nitv->vbi.raw_size = 1456;\r\nvbi_buf_size = itv->vbi.raw_size * (itv->is_60hz ? 24 : 36) / 2;\r\nitv->stream_buf_size[IVTV_ENC_STREAM_TYPE_VBI] = vbi_buf_size;\r\nitv->stream_buf_size[IVTV_DEC_STREAM_TYPE_VBI] = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nif (itv->options.radio > 0)\r\nitv->v4l2_cap |= V4L2_CAP_RADIO;\r\nif (itv->options.tuner > -1) {\r\nstruct tuner_setup setup;\r\nsetup.addr = ADDR_UNSET;\r\nsetup.type = itv->options.tuner;\r\nsetup.mode_mask = T_ANALOG_TV;\r\nif (itv->options.radio > 0)\r\nsetup.mode_mask |= T_RADIO;\r\nsetup.tuner_callback = (setup.type == TUNER_XC2028) ?\r\nivtv_reset_tuner_gpio : NULL;\r\nivtv_call_all(itv, tuner, s_type_addr, &setup);\r\nif (setup.type == TUNER_XC2028) {\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = itv->options.tuner,\r\n.priv = &ctrl,\r\n};\r\nivtv_call_all(itv, tuner, s_config, &cfg);\r\n}\r\n}\r\nitv->tuner_std = itv->std;\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\r\nstruct v4l2_ctrl_handler *hdl = itv->v4l2_dev.ctrl_handler;\r\nitv->ctrl_pts = v4l2_ctrl_new_std(hdl, &ivtv_hdl_out_ops,\r\nV4L2_CID_MPEG_VIDEO_DEC_PTS, 0, 0, 0, 0);\r\nitv->ctrl_frame = v4l2_ctrl_new_std(hdl, &ivtv_hdl_out_ops,\r\nV4L2_CID_MPEG_VIDEO_DEC_FRAME, 0, 0, 0, 0);\r\nitv->ctrl_audio_playback =\r\nv4l2_ctrl_new_std_menu(hdl, &ivtv_hdl_out_ops,\r\nV4L2_CID_MPEG_AUDIO_DEC_PLAYBACK,\r\nV4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO,\r\n1 << V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO,\r\nV4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO);\r\nitv->ctrl_audio_multilingual_playback =\r\nv4l2_ctrl_new_std_menu(hdl, &ivtv_hdl_out_ops,\r\nV4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK,\r\nV4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO,\r\n1 << V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO,\r\nV4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT);\r\nif (hdl->error) {\r\nretval = hdl->error;\r\ngoto free_i2c;\r\n}\r\nv4l2_ctrl_cluster(2, &itv->ctrl_pts);\r\nv4l2_ctrl_cluster(2, &itv->ctrl_audio_playback);\r\nivtv_call_all(itv, video, s_std_output, itv->std);\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\r\n}\r\nivtv_set_irq_mask(itv, 0xffffffff);\r\nretval = request_irq(itv->pdev->irq, ivtv_irq_handler,\r\nIRQF_SHARED, itv->v4l2_dev.name, (void *)itv);\r\nif (retval) {\r\nIVTV_ERR("Failed to register irq %d\n", retval);\r\ngoto free_i2c;\r\n}\r\nretval = ivtv_streams_setup(itv);\r\nif (retval) {\r\nIVTV_ERR("Error %d setting up streams\n", retval);\r\ngoto free_irq;\r\n}\r\nretval = ivtv_streams_register(itv);\r\nif (retval) {\r\nIVTV_ERR("Error %d registering devices\n", retval);\r\ngoto free_streams;\r\n}\r\nIVTV_INFO("Initialized card: %s\n", itv->card_name);\r\nrequest_modules(itv);\r\nreturn 0;\r\nfree_streams:\r\nivtv_streams_cleanup(itv);\r\nfree_irq:\r\nfree_irq(itv->pdev->irq, (void *)itv);\r\nfree_i2c:\r\nv4l2_ctrl_handler_free(&itv->cxhdl.hdl);\r\nexit_ivtv_i2c(itv);\r\nfree_io:\r\nivtv_iounmap(itv);\r\nfree_mem:\r\nrelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\r\nrelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\r\nif (itv->has_cx23415)\r\nrelease_mem_region(itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\r\nfree_worker:\r\nkthread_stop(itv->irq_worker_task);\r\nerr:\r\nif (retval == 0)\r\nretval = -ENODEV;\r\nIVTV_ERR("Error %d on initialization\n", retval);\r\nv4l2_device_unregister(&itv->v4l2_dev);\r\nkfree(itv);\r\nreturn retval;\r\n}\r\nint ivtv_init_on_first_open(struct ivtv *itv)\r\n{\r\nstruct v4l2_frequency vf;\r\nstruct ivtv_open_id fh;\r\nint fw_retry_count = 3;\r\nint video_input;\r\nfh.itv = itv;\r\nfh.type = IVTV_ENC_STREAM_TYPE_MPG;\r\nif (test_bit(IVTV_F_I_FAILED, &itv->i_flags))\r\nreturn -ENXIO;\r\nif (test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags))\r\nreturn 0;\r\nwhile (--fw_retry_count > 0) {\r\nif (ivtv_firmware_init(itv) == 0)\r\nbreak;\r\nif (fw_retry_count > 1)\r\nIVTV_WARN("Retry loading firmware\n");\r\n}\r\nif (fw_retry_count == 0) {\r\nset_bit(IVTV_F_I_FAILED, &itv->i_flags);\r\nreturn -ENXIO;\r\n}\r\nIVTV_DEBUG_INFO("Getting firmware version..\n");\r\nivtv_firmware_versions(itv);\r\nif (itv->card->hw_all & IVTV_HW_CX25840)\r\nv4l2_subdev_call(itv->sd_video, core, load_fw);\r\nvf.tuner = 0;\r\nvf.type = V4L2_TUNER_ANALOG_TV;\r\nvf.frequency = 6400;\r\nif (itv->std == V4L2_STD_NTSC_M_JP) {\r\nvf.frequency = 1460;\r\n}\r\nelse if (itv->std & V4L2_STD_NTSC_M) {\r\nvf.frequency = 1076;\r\n}\r\nvideo_input = itv->active_input;\r\nitv->active_input++;\r\nivtv_s_input(NULL, &fh, video_input);\r\nitv->std++;\r\nitv->std_out = itv->std;\r\nivtv_s_frequency(NULL, &fh, &vf);\r\nif (itv->card->v4l2_capabilities & V4L2_CAP_VIDEO_OUTPUT) {\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\r\nivtv_init_mpeg_decoder(itv);\r\n}\r\nif (!itv->has_cx23415)\r\nwrite_reg_sync(0x03, IVTV_REG_DMACONTROL);\r\nivtv_s_std_enc(itv, itv->tuner_std);\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_INIT | IVTV_IRQ_DEC_VSYNC);\r\nivtv_set_osd_alpha(itv);\r\nivtv_s_std_dec(itv, itv->tuner_std);\r\n} else {\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_INIT);\r\n}\r\ncx2341x_handler_setup(&itv->cxhdl);\r\nreturn 0;\r\n}\r\nstatic void ivtv_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);\r\nstruct ivtv *itv = to_ivtv(v4l2_dev);\r\nint i;\r\nIVTV_DEBUG_INFO("Removing card\n");\r\nflush_request_modules(itv);\r\nif (test_bit(IVTV_F_I_INITED, &itv->i_flags)) {\r\nIVTV_DEBUG_INFO("Stopping all streams\n");\r\nif (atomic_read(&itv->capturing) > 0)\r\nivtv_stop_all_captures(itv);\r\nIVTV_DEBUG_INFO("Stopping decoding\n");\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\r\nif (atomic_read(&itv->decoding) > 0) {\r\nint type;\r\nif (test_bit(IVTV_F_I_DEC_YUV, &itv->i_flags))\r\ntype = IVTV_DEC_STREAM_TYPE_YUV;\r\nelse\r\ntype = IVTV_DEC_STREAM_TYPE_MPG;\r\nivtv_stop_v4l2_decode_stream(&itv->streams[type],\r\nV4L2_DEC_CMD_STOP_TO_BLACK | V4L2_DEC_CMD_STOP_IMMEDIATELY, 0);\r\n}\r\nivtv_halt_firmware(itv);\r\n}\r\nivtv_set_irq_mask(itv, 0xffffffff);\r\ndel_timer_sync(&itv->dma_timer);\r\nflush_kthread_worker(&itv->irq_worker);\r\nkthread_stop(itv->irq_worker_task);\r\nivtv_streams_cleanup(itv);\r\nivtv_udma_free(itv);\r\nv4l2_ctrl_handler_free(&itv->cxhdl.hdl);\r\nexit_ivtv_i2c(itv);\r\nfree_irq(itv->pdev->irq, (void *)itv);\r\nivtv_iounmap(itv);\r\nrelease_mem_region(itv->base_addr, IVTV_ENCODER_SIZE);\r\nrelease_mem_region(itv->base_addr + IVTV_REG_OFFSET, IVTV_REG_SIZE);\r\nif (itv->has_cx23415)\r\nrelease_mem_region(itv->base_addr + IVTV_DECODER_OFFSET, IVTV_DECODER_SIZE);\r\npci_disable_device(itv->pdev);\r\nfor (i = 0; i < IVTV_VBI_FRAMES; i++)\r\nkfree(itv->vbi.sliced_mpeg_data[i]);\r\nprintk(KERN_INFO "ivtv: Removed %s\n", itv->card_name);\r\nv4l2_device_unregister(&itv->v4l2_dev);\r\nkfree(itv);\r\n}\r\nstatic int __init module_start(void)\r\n{\r\nprintk(KERN_INFO "ivtv: Start initialization, version %s\n", IVTV_VERSION);\r\nif (ivtv_first_minor < 0 || ivtv_first_minor >= IVTV_MAX_CARDS) {\r\nprintk(KERN_ERR "ivtv: Exiting, ivtv_first_minor must be between 0 and %d\n",\r\nIVTV_MAX_CARDS - 1);\r\nreturn -1;\r\n}\r\nif (ivtv_debug < 0 || ivtv_debug > 2047) {\r\nivtv_debug = 0;\r\nprintk(KERN_INFO "ivtv: Debug value must be >= 0 and <= 2047\n");\r\n}\r\nif (pci_register_driver(&ivtv_pci_driver)) {\r\nprintk(KERN_ERR "ivtv: Error detecting PCI card\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "ivtv: End initialization\n");\r\nreturn 0;\r\n}\r\nstatic void __exit module_cleanup(void)\r\n{\r\npci_unregister_driver(&ivtv_pci_driver);\r\n}
