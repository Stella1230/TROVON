int it_disposition(struct lookup_intent *it, int flag)\r\n{\r\nreturn it->d.lustre.it_disposition & flag;\r\n}\r\nvoid it_set_disposition(struct lookup_intent *it, int flag)\r\n{\r\nit->d.lustre.it_disposition |= flag;\r\n}\r\nvoid it_clear_disposition(struct lookup_intent *it, int flag)\r\n{\r\nit->d.lustre.it_disposition &= ~flag;\r\n}\r\nint it_open_error(int phase, struct lookup_intent *it)\r\n{\r\nif (it_disposition(it, DISP_OPEN_LEASE)) {\r\nif (phase >= DISP_OPEN_LEASE)\r\nreturn it->d.lustre.it_status;\r\nelse\r\nreturn 0;\r\n}\r\nif (it_disposition(it, DISP_OPEN_OPEN)) {\r\nif (phase >= DISP_OPEN_OPEN)\r\nreturn it->d.lustre.it_status;\r\nelse\r\nreturn 0;\r\n}\r\nif (it_disposition(it, DISP_OPEN_CREATE)) {\r\nif (phase >= DISP_OPEN_CREATE)\r\nreturn it->d.lustre.it_status;\r\nelse\r\nreturn 0;\r\n}\r\nif (it_disposition(it, DISP_LOOKUP_EXECD)) {\r\nif (phase >= DISP_LOOKUP_EXECD)\r\nreturn it->d.lustre.it_status;\r\nelse\r\nreturn 0;\r\n}\r\nif (it_disposition(it, DISP_IT_EXECD)) {\r\nif (phase >= DISP_IT_EXECD)\r\nreturn it->d.lustre.it_status;\r\nelse\r\nreturn 0;\r\n}\r\nCERROR("it disp: %X, status: %d\n", it->d.lustre.it_disposition,\r\nit->d.lustre.it_status);\r\nLBUG();\r\nreturn 0;\r\n}\r\nint mdc_set_lock_data(struct obd_export *exp, __u64 *lockh, void *data,\r\n__u64 *bits)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct inode *new_inode = data;\r\nif (bits)\r\n*bits = 0;\r\nif (!*lockh)\r\nreturn 0;\r\nlock = ldlm_handle2lock((struct lustre_handle *)lockh);\r\nLASSERT(lock != NULL);\r\nlock_res_and_lock(lock);\r\nif (lock->l_resource->lr_lvb_inode &&\r\nlock->l_resource->lr_lvb_inode != data) {\r\nstruct inode *old_inode = lock->l_resource->lr_lvb_inode;\r\nLASSERTF(old_inode->i_state & I_FREEING,\r\n"Found existing inode %p/%lu/%u state %lu in lock: setting data to %p/%lu/%u\n",\r\nold_inode, old_inode->i_ino, old_inode->i_generation,\r\nold_inode->i_state, new_inode, new_inode->i_ino,\r\nnew_inode->i_generation);\r\n}\r\nlock->l_resource->lr_lvb_inode = new_inode;\r\nif (bits)\r\n*bits = lock->l_policy_data.l_inodebits.bits;\r\nunlock_res_and_lock(lock);\r\nLDLM_LOCK_PUT(lock);\r\nreturn 0;\r\n}\r\nldlm_mode_t mdc_lock_match(struct obd_export *exp, __u64 flags,\r\nconst struct lu_fid *fid, ldlm_type_t type,\r\nldlm_policy_data_t *policy, ldlm_mode_t mode,\r\nstruct lustre_handle *lockh)\r\n{\r\nstruct ldlm_res_id res_id;\r\nldlm_mode_t rc;\r\nfid_build_reg_res_name(fid, &res_id);\r\npolicy->l_inodebits.bits &= exp_connect_ibits(exp);\r\nrc = ldlm_lock_match(class_exp2obd(exp)->obd_namespace, flags,\r\n&res_id, type, policy, mode, lockh, 0);\r\nreturn rc;\r\n}\r\nint mdc_cancel_unused(struct obd_export *exp,\r\nconst struct lu_fid *fid,\r\nldlm_policy_data_t *policy,\r\nldlm_mode_t mode,\r\nldlm_cancel_flags_t flags,\r\nvoid *opaque)\r\n{\r\nstruct ldlm_res_id res_id;\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nint rc;\r\nfid_build_reg_res_name(fid, &res_id);\r\nrc = ldlm_cli_cancel_unused_resource(obd->obd_namespace, &res_id,\r\npolicy, mode, flags, opaque);\r\nreturn rc;\r\n}\r\nint mdc_null_inode(struct obd_export *exp,\r\nconst struct lu_fid *fid)\r\n{\r\nstruct ldlm_res_id res_id;\r\nstruct ldlm_resource *res;\r\nstruct ldlm_namespace *ns = class_exp2obd(exp)->obd_namespace;\r\nLASSERTF(ns != NULL, "no namespace passed\n");\r\nfid_build_reg_res_name(fid, &res_id);\r\nres = ldlm_resource_get(ns, NULL, &res_id, 0, 0);\r\nif (res == NULL)\r\nreturn 0;\r\nlock_res(res);\r\nres->lr_lvb_inode = NULL;\r\nunlock_res(res);\r\nldlm_resource_putref(res);\r\nreturn 0;\r\n}\r\nint mdc_find_cbdata(struct obd_export *exp,\r\nconst struct lu_fid *fid,\r\nldlm_iterator_t it, void *data)\r\n{\r\nstruct ldlm_res_id res_id;\r\nint rc = 0;\r\nfid_build_reg_res_name((struct lu_fid *)fid, &res_id);\r\nrc = ldlm_resource_iterate(class_exp2obd(exp)->obd_namespace, &res_id,\r\nit, data);\r\nif (rc == LDLM_ITER_STOP)\r\nreturn 1;\r\nelse if (rc == LDLM_ITER_CONTINUE)\r\nreturn 0;\r\nreturn rc;\r\n}\r\nstatic inline void mdc_clear_replay_flag(struct ptlrpc_request *req, int rc)\r\n{\r\nif (req->rq_replay) {\r\nspin_lock(&req->rq_lock);\r\nreq->rq_replay = 0;\r\nspin_unlock(&req->rq_lock);\r\n}\r\nif (rc && req->rq_transno != 0) {\r\nDEBUG_REQ(D_ERROR, req, "transno returned on error rc %d", rc);\r\nLBUG();\r\n}\r\n}\r\nstatic void mdc_realloc_openmsg(struct ptlrpc_request *req,\r\nstruct mdt_body *body)\r\n{\r\nint rc;\r\nrc = sptlrpc_cli_enlarge_reqbuf(req, DLM_INTENT_REC_OFF + 4,\r\nbody->eadatasize);\r\nif (rc) {\r\nCERROR("Can't enlarge segment %d size to %d\n",\r\nDLM_INTENT_REC_OFF + 4, body->eadatasize);\r\nbody->valid &= ~OBD_MD_FLEASIZE;\r\nbody->eadatasize = 0;\r\n}\r\n}\r\nstatic struct ptlrpc_request *mdc_intent_open_pack(struct obd_export *exp,\r\nstruct lookup_intent *it,\r\nstruct md_op_data *op_data,\r\nvoid *lmm, int lmmsize,\r\nvoid *cb_data)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct ldlm_intent *lit;\r\nLIST_HEAD(cancels);\r\nint count = 0;\r\nint mode;\r\nint rc;\r\nit->it_create_mode = (it->it_create_mode & ~S_IFMT) | S_IFREG;\r\nif (fid_is_sane(&op_data->op_fid2)) {\r\nif (it->it_flags & MDS_OPEN_LEASE) {\r\nif (it->it_flags & FMODE_WRITE)\r\nmode = LCK_EX;\r\nelse\r\nmode = LCK_PR;\r\n} else {\r\nif (it->it_flags & (FMODE_WRITE|MDS_OPEN_TRUNC))\r\nmode = LCK_CW;\r\nelse if (it->it_flags & __FMODE_EXEC)\r\nmode = LCK_PR;\r\nelse\r\nmode = LCK_CR;\r\n}\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid2,\r\n&cancels, mode,\r\nMDS_INODELOCK_OPEN);\r\n}\r\nif (it->it_op & IT_CREAT)\r\nmode = LCK_EX;\r\nelse\r\nmode = LCK_CR;\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, mode,\r\nMDS_INODELOCK_UPDATE);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_INTENT_OPEN);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_set_capa_size(req, &RMF_CAPA2, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT,\r\nmax(lmmsize, obddev->u.cli.cl_default_mds_easize));\r\nrc = ldlm_prep_enqueue_req(exp, req, &cancels, count);\r\nif (rc < 0) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nspin_lock(&req->rq_lock);\r\nreq->rq_replay = req->rq_import->imp_replayable;\r\nspin_unlock(&req->rq_lock);\r\nlit = req_capsule_client_get(&req->rq_pill, &RMF_LDLM_INTENT);\r\nlit->opc = (__u64)it->it_op;\r\nmdc_open_pack(req, op_data, it->it_create_mode, 0, it->it_flags, lmm,\r\nlmmsize);\r\nif (client_is_remote(exp))\r\nreq_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,\r\nsizeof(struct mdt_remote_perm));\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic struct ptlrpc_request *\r\nmdc_intent_getxattr_pack(struct obd_export *exp,\r\nstruct lookup_intent *it,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ldlm_intent *lit;\r\nint rc, count = 0, maxdata;\r\nLIST_HEAD(cancels);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_INTENT_GETXATTR);\r\nif (req == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ldlm_prep_enqueue_req(exp, req, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nlit = req_capsule_client_get(&req->rq_pill, &RMF_LDLM_INTENT);\r\nlit->opc = IT_GETXATTR;\r\nmaxdata = class_exp2cliimp(exp)->imp_connect_data.ocd_max_easize;\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nop_data->op_valid, maxdata, -1, 0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA,\r\nRCL_SERVER, maxdata);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EAVALS,\r\nRCL_SERVER, maxdata);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EAVALS_LENS,\r\nRCL_SERVER, maxdata);\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic struct ptlrpc_request *mdc_intent_unlink_pack(struct obd_export *exp,\r\nstruct lookup_intent *it,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct ldlm_intent *lit;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_INTENT_UNLINK);\r\nif (req == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = ldlm_prep_enqueue_req(exp, req, NULL, 0);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nlit = req_capsule_client_get(&req->rq_pill, &RMF_LDLM_INTENT);\r\nlit->opc = (__u64)it->it_op;\r\nmdc_unlink_pack(req, op_data);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobddev->u.cli.cl_default_mds_easize);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,\r\nobddev->u.cli.cl_default_mds_cookiesize);\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic struct ptlrpc_request *mdc_intent_getattr_pack(struct obd_export *exp,\r\nstruct lookup_intent *it,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nu64 valid = OBD_MD_FLGETATTR | OBD_MD_FLEASIZE |\r\nOBD_MD_FLMODEASIZE | OBD_MD_FLDIREA |\r\nOBD_MD_FLMDSCAPA | OBD_MD_MEA |\r\n(client_is_remote(exp) ?\r\nOBD_MD_FLRMTPERM : OBD_MD_FLACL);\r\nstruct ldlm_intent *lit;\r\nint rc;\r\nint easize;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_INTENT_GETATTR);\r\nif (req == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = ldlm_prep_enqueue_req(exp, req, NULL, 0);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nlit = req_capsule_client_get(&req->rq_pill, &RMF_LDLM_INTENT);\r\nlit->opc = (__u64)it->it_op;\r\nif (obddev->u.cli.cl_default_mds_easize > 0)\r\neasize = obddev->u.cli.cl_default_mds_easize;\r\nelse\r\neasize = obddev->u.cli.cl_max_mds_easize;\r\nmdc_getattr_pack(req, valid, it->it_flags, op_data, easize);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER, easize);\r\nif (client_is_remote(exp))\r\nreq_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,\r\nsizeof(struct mdt_remote_perm));\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic struct ptlrpc_request *mdc_intent_layout_pack(struct obd_export *exp,\r\nstruct lookup_intent *it,\r\nstruct md_op_data *unused)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nstruct ldlm_intent *lit;\r\nstruct layout_intent *layout;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_INTENT_LAYOUT);\r\nif (req == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT, 0);\r\nrc = ldlm_prep_enqueue_req(exp, req, NULL, 0);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nlit = req_capsule_client_get(&req->rq_pill, &RMF_LDLM_INTENT);\r\nlit->opc = (__u64)it->it_op;\r\nlayout = req_capsule_client_get(&req->rq_pill, &RMF_LAYOUT_INTENT);\r\nlayout->li_opc = LAYOUT_INTENT_ACCESS;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_DLM_LVB, RCL_SERVER,\r\nobd->u.cli.cl_default_mds_easize);\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic struct ptlrpc_request *\r\nmdc_enqueue_pack(struct obd_export *exp, int lvb_len)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_LDLM_ENQUEUE);\r\nif (req == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = ldlm_prep_enqueue_req(exp, req, NULL, 0);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_DLM_LVB, RCL_SERVER, lvb_len);\r\nptlrpc_request_set_replen(req);\r\nreturn req;\r\n}\r\nstatic int mdc_finish_enqueue(struct obd_export *exp,\r\nstruct ptlrpc_request *req,\r\nstruct ldlm_enqueue_info *einfo,\r\nstruct lookup_intent *it,\r\nstruct lustre_handle *lockh,\r\nint rc)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct ldlm_request *lockreq;\r\nstruct ldlm_reply *lockrep;\r\nstruct lustre_intent_data *intent = &it->d.lustre;\r\nstruct ldlm_lock *lock;\r\nvoid *lvb_data = NULL;\r\nint lvb_len = 0;\r\nLASSERT(rc >= 0);\r\nif (req->rq_transno || req->rq_replay) {\r\nlockreq = req_capsule_client_get(pill, &RMF_DLM_REQ);\r\nlockreq->lock_flags |= ldlm_flags_to_wire(LDLM_FL_INTENT_ONLY);\r\n}\r\nif (rc == ELDLM_LOCK_ABORTED) {\r\neinfo->ei_mode = 0;\r\nmemset(lockh, 0, sizeof(*lockh));\r\nrc = 0;\r\n} else {\r\nlock = ldlm_handle2lock(lockh);\r\nLASSERT(lock != NULL);\r\nif (lock->l_req_mode != einfo->ei_mode) {\r\nldlm_lock_addref(lockh, lock->l_req_mode);\r\nldlm_lock_decref(lockh, einfo->ei_mode);\r\neinfo->ei_mode = lock->l_req_mode;\r\n}\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nlockrep = req_capsule_server_get(pill, &RMF_DLM_REP);\r\nLASSERT(lockrep != NULL);\r\nintent->it_disposition = (int)lockrep->lock_policy_res1;\r\nintent->it_status = (int)lockrep->lock_policy_res2;\r\nintent->it_lock_mode = einfo->ei_mode;\r\nintent->it_lock_handle = lockh->cookie;\r\nintent->it_data = req;\r\nif ((!req->rq_transno || intent->it_status < 0) && req->rq_replay)\r\nmdc_clear_replay_flag(req, intent->it_status);\r\nif (it->it_op & IT_OPEN && req->rq_replay &&\r\n(!it_disposition(it, DISP_OPEN_OPEN) || intent->it_status != 0))\r\nmdc_clear_replay_flag(req, intent->it_status);\r\nDEBUG_REQ(D_RPCTRACE, req, "op: %d disposition: %x, status: %d",\r\nit->it_op, intent->it_disposition, intent->it_status);\r\nif (it->it_op & (IT_OPEN | IT_UNLINK | IT_LOOKUP | IT_GETATTR)) {\r\nstruct mdt_body *body;\r\nbody = req_capsule_server_get(pill, &RMF_MDT_BODY);\r\nif (body == NULL) {\r\nCERROR("Can't swab mdt_body\n");\r\nreturn -EPROTO;\r\n}\r\nif (it_disposition(it, DISP_OPEN_OPEN) &&\r\n!it_open_error(DISP_OPEN_OPEN, it)) {\r\nmdc_set_open_replay_data(NULL, NULL, it);\r\n}\r\nif ((body->valid & (OBD_MD_FLDIREA | OBD_MD_FLEASIZE)) != 0) {\r\nvoid *eadata;\r\nmdc_update_max_ea_from_body(exp, body);\r\neadata = req_capsule_server_sized_get(pill, &RMF_MDT_MD,\r\nbody->eadatasize);\r\nif (eadata == NULL)\r\nreturn -EPROTO;\r\nlvb_data = eadata;\r\nlvb_len = body->eadatasize;\r\nif ((it->it_op & IT_OPEN) && req->rq_replay) {\r\nvoid *lmm;\r\nif (req_capsule_get_size(pill, &RMF_EADATA,\r\nRCL_CLIENT) <\r\nbody->eadatasize)\r\nmdc_realloc_openmsg(req, body);\r\nelse\r\nreq_capsule_shrink(pill, &RMF_EADATA,\r\nbody->eadatasize,\r\nRCL_CLIENT);\r\nreq_capsule_set_size(pill, &RMF_EADATA,\r\nRCL_CLIENT,\r\nbody->eadatasize);\r\nlmm = req_capsule_client_get(pill, &RMF_EADATA);\r\nif (lmm)\r\nmemcpy(lmm, eadata, body->eadatasize);\r\n}\r\n}\r\nif (body->valid & OBD_MD_FLRMTPERM) {\r\nstruct mdt_remote_perm *perm;\r\nLASSERT(client_is_remote(exp));\r\nperm = req_capsule_server_swab_get(pill, &RMF_ACL,\r\nlustre_swab_mdt_remote_perm);\r\nif (perm == NULL)\r\nreturn -EPROTO;\r\n}\r\nif (body->valid & OBD_MD_FLMDSCAPA) {\r\nstruct lustre_capa *capa, *p;\r\ncapa = req_capsule_server_get(pill, &RMF_CAPA1);\r\nif (capa == NULL)\r\nreturn -EPROTO;\r\nif (it->it_op & IT_OPEN) {\r\np = req_capsule_client_get(pill, &RMF_CAPA2);\r\nLASSERT(p);\r\n*p = *capa;\r\n}\r\n}\r\nif (body->valid & OBD_MD_FLOSSCAPA) {\r\nstruct lustre_capa *capa;\r\ncapa = req_capsule_server_get(pill, &RMF_CAPA2);\r\nif (capa == NULL)\r\nreturn -EPROTO;\r\n}\r\n} else if (it->it_op & IT_LAYOUT) {\r\nlvb_len = req_capsule_get_size(pill, &RMF_DLM_LVB, RCL_SERVER);\r\nif (lvb_len > 0) {\r\nlvb_data = req_capsule_server_sized_get(pill,\r\n&RMF_DLM_LVB, lvb_len);\r\nif (lvb_data == NULL)\r\nreturn -EPROTO;\r\n}\r\n}\r\nlock = ldlm_handle2lock(lockh);\r\nif (lock != NULL && ldlm_has_layout(lock) && lvb_data != NULL) {\r\nvoid *lmm;\r\nLDLM_DEBUG(lock, "layout lock returned by: %s, lvb_len: %d\n",\r\nldlm_it2str(it->it_op), lvb_len);\r\nlmm = libcfs_kvzalloc(lvb_len, GFP_NOFS);\r\nif (lmm == NULL) {\r\nLDLM_LOCK_PUT(lock);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(lmm, lvb_data, lvb_len);\r\nlock_res_and_lock(lock);\r\nif (lock->l_lvb_data == NULL) {\r\nlock->l_lvb_type = LVB_T_LAYOUT;\r\nlock->l_lvb_data = lmm;\r\nlock->l_lvb_len = lvb_len;\r\nlmm = NULL;\r\n}\r\nunlock_res_and_lock(lock);\r\nif (lmm != NULL)\r\nkvfree(lmm);\r\n}\r\nif (lock != NULL)\r\nLDLM_LOCK_PUT(lock);\r\nreturn rc;\r\n}\r\nint mdc_enqueue(struct obd_export *exp, struct ldlm_enqueue_info *einfo,\r\nstruct lookup_intent *it, struct md_op_data *op_data,\r\nstruct lustre_handle *lockh, void *lmm, int lmmsize,\r\nstruct ptlrpc_request **reqp, u64 extra_lock_flags)\r\n{\r\nstatic const ldlm_policy_data_t lookup_policy = {\r\n.l_inodebits = { MDS_INODELOCK_LOOKUP }\r\n};\r\nstatic const ldlm_policy_data_t update_policy = {\r\n.l_inodebits = { MDS_INODELOCK_UPDATE }\r\n};\r\nstatic const ldlm_policy_data_t layout_policy = {\r\n.l_inodebits = { MDS_INODELOCK_LAYOUT }\r\n};\r\nstatic const ldlm_policy_data_t getxattr_policy = {\r\n.l_inodebits = { MDS_INODELOCK_XATTR }\r\n};\r\nldlm_policy_data_t const *policy = &lookup_policy;\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nu64 flags, saved_flags = extra_lock_flags;\r\nstruct ldlm_res_id res_id;\r\nint generation, resends = 0;\r\nstruct ldlm_reply *lockrep;\r\nenum lvb_type lvb_type = LVB_T_NONE;\r\nint rc;\r\nLASSERTF(!it || einfo->ei_type == LDLM_IBITS, "lock type %d\n",\r\neinfo->ei_type);\r\nfid_build_reg_res_name(&op_data->op_fid1, &res_id);\r\nif (it) {\r\nsaved_flags |= LDLM_FL_HAS_INTENT;\r\nif (it->it_op & (IT_UNLINK | IT_GETATTR | IT_READDIR))\r\npolicy = &update_policy;\r\nelse if (it->it_op & IT_LAYOUT)\r\npolicy = &layout_policy;\r\nelse if (it->it_op & (IT_GETXATTR | IT_SETXATTR))\r\npolicy = &getxattr_policy;\r\n}\r\nLASSERT(reqp == NULL);\r\ngeneration = obddev->u.cli.cl_import->imp_generation;\r\nresend:\r\nflags = saved_flags;\r\nif (!it) {\r\nLASSERT(lmm && lmmsize == 0);\r\nLASSERTF(einfo->ei_type == LDLM_FLOCK, "lock type %d\n",\r\neinfo->ei_type);\r\npolicy = (ldlm_policy_data_t *)lmm;\r\nres_id.name[3] = LDLM_FLOCK;\r\nreq = NULL;\r\n} else if (it->it_op & IT_OPEN) {\r\nreq = mdc_intent_open_pack(exp, it, op_data, lmm, lmmsize,\r\neinfo->ei_cbdata);\r\npolicy = &update_policy;\r\neinfo->ei_cbdata = NULL;\r\nlmm = NULL;\r\n} else if (it->it_op & IT_UNLINK) {\r\nreq = mdc_intent_unlink_pack(exp, it, op_data);\r\n} else if (it->it_op & (IT_GETATTR | IT_LOOKUP)) {\r\nreq = mdc_intent_getattr_pack(exp, it, op_data);\r\n} else if (it->it_op & IT_READDIR) {\r\nreq = mdc_enqueue_pack(exp, 0);\r\n} else if (it->it_op & IT_LAYOUT) {\r\nif (!imp_connect_lvb_type(class_exp2cliimp(exp)))\r\nreturn -EOPNOTSUPP;\r\nreq = mdc_intent_layout_pack(exp, it, op_data);\r\nlvb_type = LVB_T_LAYOUT;\r\n} else if (it->it_op & IT_GETXATTR) {\r\nreq = mdc_intent_getxattr_pack(exp, it, op_data);\r\n} else {\r\nLBUG();\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(req))\r\nreturn PTR_ERR(req);\r\nif (req != NULL && it && it->it_op & IT_CREAT)\r\nreq->rq_no_retry_einprogress = 1;\r\nif (resends) {\r\nreq->rq_generation_set = 1;\r\nreq->rq_import_generation = generation;\r\nreq->rq_sent = get_seconds() + resends;\r\n}\r\nif (it) {\r\nmdc_get_rpc_lock(obddev->u.cli.cl_rpc_lock, it);\r\nrc = mdc_enter_request(&obddev->u.cli);\r\nif (rc != 0) {\r\nmdc_put_rpc_lock(obddev->u.cli.cl_rpc_lock, it);\r\nmdc_clear_replay_flag(req, 0);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\n}\r\nrc = ldlm_cli_enqueue(exp, &req, einfo, &res_id, policy, &flags, NULL,\r\n0, lvb_type, lockh, 0);\r\nif (!it) {\r\nif ((rc == -EINTR) || (rc == -ETIMEDOUT))\r\ngoto resend;\r\nreturn rc;\r\n}\r\nmdc_exit_request(&obddev->u.cli);\r\nmdc_put_rpc_lock(obddev->u.cli.cl_rpc_lock, it);\r\nif (rc < 0) {\r\nCDEBUG_LIMIT((rc == -EACCES || rc == -EIDRM) ? D_INFO : D_ERROR,\r\n"%s: ldlm_cli_enqueue failed: rc = %d\n",\r\nobddev->obd_name, rc);\r\nmdc_clear_replay_flag(req, rc);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nlockrep = req_capsule_server_get(&req->rq_pill, &RMF_DLM_REP);\r\nLASSERT(lockrep != NULL);\r\nlockrep->lock_policy_res2 =\r\nptlrpc_status_ntoh(lockrep->lock_policy_res2);\r\nif (it && it->it_op & IT_CREAT &&\r\n(int)lockrep->lock_policy_res2 == -EINPROGRESS) {\r\nmdc_clear_replay_flag(req, rc);\r\nptlrpc_req_finished(req);\r\nresends++;\r\nCDEBUG(D_HA, "%s: resend:%d op:%d "DFID"/"DFID"\n",\r\nobddev->obd_name, resends, it->it_op,\r\nPFID(&op_data->op_fid1), PFID(&op_data->op_fid2));\r\nif (generation == obddev->u.cli.cl_import->imp_generation) {\r\ngoto resend;\r\n} else {\r\nCDEBUG(D_HA, "resend cross eviction\n");\r\nreturn -EIO;\r\n}\r\n}\r\nrc = mdc_finish_enqueue(exp, req, einfo, it, lockh, rc);\r\nif (rc < 0) {\r\nif (lustre_handle_is_used(lockh)) {\r\nldlm_lock_decref(lockh, einfo->ei_mode);\r\nmemset(lockh, 0, sizeof(*lockh));\r\n}\r\nptlrpc_req_finished(req);\r\nit->d.lustre.it_lock_handle = 0;\r\nit->d.lustre.it_lock_mode = 0;\r\nit->d.lustre.it_data = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mdc_finish_intent_lock(struct obd_export *exp,\r\nstruct ptlrpc_request *request,\r\nstruct md_op_data *op_data,\r\nstruct lookup_intent *it,\r\nstruct lustre_handle *lockh)\r\n{\r\nstruct lustre_handle old_lock;\r\nstruct mdt_body *mdt_body;\r\nstruct ldlm_lock *lock;\r\nint rc;\r\nLASSERT(request != NULL);\r\nLASSERT(request != LP_POISON);\r\nLASSERT(request->rq_repmsg != LP_POISON);\r\nif (!it_disposition(it, DISP_IT_EXECD)) {\r\nLASSERT(it->d.lustre.it_status != 0);\r\nreturn it->d.lustre.it_status;\r\n}\r\nrc = it_open_error(DISP_IT_EXECD, it);\r\nif (rc)\r\nreturn rc;\r\nmdt_body = req_capsule_server_get(&request->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(mdt_body != NULL);\r\nif (fid_is_sane(&op_data->op_fid2) &&\r\nit->it_create_mode & M_CHECK_STALE &&\r\nit->it_op != IT_GETATTR) {\r\nif ((!lu_fid_eq(&op_data->op_fid2, &mdt_body->fid1)) &&\r\n(!lu_fid_eq(&op_data->op_fid3, &mdt_body->fid1))) {\r\nCDEBUG(D_DENTRY, "Found stale data "DFID"("DFID")/"DFID\r\n"\n", PFID(&op_data->op_fid2),\r\nPFID(&op_data->op_fid2), PFID(&mdt_body->fid1));\r\nreturn -ESTALE;\r\n}\r\n}\r\nrc = it_open_error(DISP_LOOKUP_EXECD, it);\r\nif (rc)\r\nreturn rc;\r\nif (!it_disposition(it, DISP_ENQ_CREATE_REF) &&\r\nit_disposition(it, DISP_OPEN_CREATE) &&\r\n!it_open_error(DISP_OPEN_CREATE, it)) {\r\nit_set_disposition(it, DISP_ENQ_CREATE_REF);\r\nptlrpc_request_addref(request);\r\n}\r\nif (!it_disposition(it, DISP_ENQ_OPEN_REF) &&\r\nit_disposition(it, DISP_OPEN_OPEN) &&\r\n!it_open_error(DISP_OPEN_OPEN, it)) {\r\nit_set_disposition(it, DISP_ENQ_OPEN_REF);\r\nptlrpc_request_addref(request);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_MDC_ENQUEUE_PAUSE, obd_timeout);\r\n}\r\nif (it->it_op & IT_CREAT) {\r\n} else if (it->it_op == IT_OPEN) {\r\nLASSERT(!it_disposition(it, DISP_OPEN_CREATE));\r\n} else {\r\nLASSERT(it->it_op & (IT_GETATTR | IT_LOOKUP | IT_LAYOUT));\r\n}\r\nlock = ldlm_handle2lock(lockh);\r\nif (lock) {\r\nldlm_policy_data_t policy = lock->l_policy_data;\r\nLDLM_DEBUG(lock, "matching against this");\r\nLASSERTF(fid_res_name_eq(&mdt_body->fid1,\r\n&lock->l_resource->lr_name),\r\n"Lock res_id: "DLDLMRES", fid: "DFID"\n",\r\nPLDLMRES(lock->l_resource), PFID(&mdt_body->fid1));\r\nLDLM_LOCK_PUT(lock);\r\nmemcpy(&old_lock, lockh, sizeof(*lockh));\r\nif (ldlm_lock_match(NULL, LDLM_FL_BLOCK_GRANTED, NULL,\r\nLDLM_IBITS, &policy, LCK_NL,\r\n&old_lock, 0)) {\r\nldlm_lock_decref_and_cancel(lockh,\r\nit->d.lustre.it_lock_mode);\r\nmemcpy(lockh, &old_lock, sizeof(old_lock));\r\nit->d.lustre.it_lock_handle = lockh->cookie;\r\n}\r\n}\r\nCDEBUG(D_DENTRY,\r\n"D_IT dentry %.*s intent: %s status %d disp %x rc %d\n",\r\nop_data->op_namelen, op_data->op_name, ldlm_it2str(it->it_op),\r\nit->d.lustre.it_status, it->d.lustre.it_disposition, rc);\r\nreturn rc;\r\n}\r\nint mdc_revalidate_lock(struct obd_export *exp, struct lookup_intent *it,\r\nstruct lu_fid *fid, __u64 *bits)\r\n{\r\nstruct ldlm_res_id res_id;\r\nstruct lustre_handle lockh;\r\nldlm_policy_data_t policy;\r\nldlm_mode_t mode;\r\nif (it->d.lustre.it_lock_handle) {\r\nlockh.cookie = it->d.lustre.it_lock_handle;\r\nmode = ldlm_revalidate_lock_handle(&lockh, bits);\r\n} else {\r\nfid_build_reg_res_name(fid, &res_id);\r\nswitch (it->it_op) {\r\ncase IT_GETATTR:\r\npolicy.l_inodebits.bits = MDS_INODELOCK_UPDATE |\r\nMDS_INODELOCK_LOOKUP |\r\nMDS_INODELOCK_PERM;\r\nbreak;\r\ncase IT_LAYOUT:\r\npolicy.l_inodebits.bits = MDS_INODELOCK_LAYOUT;\r\nbreak;\r\ndefault:\r\npolicy.l_inodebits.bits = MDS_INODELOCK_LOOKUP;\r\nbreak;\r\n}\r\nmode = mdc_lock_match(exp, LDLM_FL_BLOCK_GRANTED, fid,\r\nLDLM_IBITS, &policy,\r\nLCK_CR | LCK_CW | LCK_PR | LCK_PW,\r\n&lockh);\r\n}\r\nif (mode) {\r\nit->d.lustre.it_lock_handle = lockh.cookie;\r\nit->d.lustre.it_lock_mode = mode;\r\n} else {\r\nit->d.lustre.it_lock_handle = 0;\r\nit->d.lustre.it_lock_mode = 0;\r\n}\r\nreturn !!mode;\r\n}\r\nint mdc_intent_lock(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *lmm, int lmmsize, struct lookup_intent *it,\r\nint lookup_flags, struct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct ldlm_enqueue_info einfo = {\r\n.ei_type = LDLM_IBITS,\r\n.ei_mode = it_to_lock_mode(it),\r\n.ei_cb_bl = cb_blocking,\r\n.ei_cb_cp = ldlm_completion_ast,\r\n};\r\nstruct lustre_handle lockh;\r\nint rc = 0;\r\nLASSERT(it);\r\nCDEBUG(D_DLMTRACE, "(name: %.*s,"DFID") in obj "DFID\r\n", intent: %s flags %#Lo\n", op_data->op_namelen,\r\nop_data->op_name, PFID(&op_data->op_fid2),\r\nPFID(&op_data->op_fid1), ldlm_it2str(it->it_op),\r\nit->it_flags);\r\nlockh.cookie = 0;\r\nif (fid_is_sane(&op_data->op_fid2) &&\r\n(it->it_op & (IT_LOOKUP | IT_GETATTR))) {\r\nit->d.lustre.it_lock_handle = 0;\r\nrc = mdc_revalidate_lock(exp, it, &op_data->op_fid2, NULL);\r\nif (rc || op_data->op_namelen != 0)\r\nreturn rc;\r\n}\r\nif (!fid_is_sane(&op_data->op_fid2) && it->it_op & IT_CREAT) {\r\nrc = mdc_fid_alloc(exp, &op_data->op_fid2, op_data);\r\nif (rc < 0) {\r\nCERROR("Can't alloc new fid, rc %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = mdc_enqueue(exp, &einfo, it, op_data, &lockh, lmm, lmmsize, NULL,\r\nextra_lock_flags);\r\nif (rc < 0)\r\nreturn rc;\r\n*reqp = it->d.lustre.it_data;\r\nrc = mdc_finish_intent_lock(exp, *reqp, op_data, it, &lockh);\r\nreturn rc;\r\n}\r\nstatic int mdc_intent_getattr_async_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nvoid *args, int rc)\r\n{\r\nstruct mdc_getattr_args *ga = args;\r\nstruct obd_export *exp = ga->ga_exp;\r\nstruct md_enqueue_info *minfo = ga->ga_minfo;\r\nstruct ldlm_enqueue_info *einfo = ga->ga_einfo;\r\nstruct lookup_intent *it;\r\nstruct lustre_handle *lockh;\r\nstruct obd_device *obddev;\r\nstruct ldlm_reply *lockrep;\r\n__u64 flags = LDLM_FL_HAS_INTENT;\r\nit = &minfo->mi_it;\r\nlockh = &minfo->mi_lockh;\r\nobddev = class_exp2obd(exp);\r\nmdc_exit_request(&obddev->u.cli);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_MDC_GETATTR_ENQUEUE))\r\nrc = -ETIMEDOUT;\r\nrc = ldlm_cli_enqueue_fini(exp, req, einfo->ei_type, 1, einfo->ei_mode,\r\n&flags, NULL, 0, lockh, rc);\r\nif (rc < 0) {\r\nCERROR("ldlm_cli_enqueue_fini: %d\n", rc);\r\nmdc_clear_replay_flag(req, rc);\r\ngoto out;\r\n}\r\nlockrep = req_capsule_server_get(&req->rq_pill, &RMF_DLM_REP);\r\nLASSERT(lockrep != NULL);\r\nlockrep->lock_policy_res2 =\r\nptlrpc_status_ntoh(lockrep->lock_policy_res2);\r\nrc = mdc_finish_enqueue(exp, req, einfo, it, lockh, rc);\r\nif (rc)\r\ngoto out;\r\nrc = mdc_finish_intent_lock(exp, req, &minfo->mi_data, it, lockh);\r\nout:\r\nkfree(einfo);\r\nminfo->mi_cb(req, minfo, rc);\r\nreturn 0;\r\n}\r\nint mdc_intent_getattr_async(struct obd_export *exp,\r\nstruct md_enqueue_info *minfo,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\nstruct md_op_data *op_data = &minfo->mi_data;\r\nstruct lookup_intent *it = &minfo->mi_it;\r\nstruct ptlrpc_request *req;\r\nstruct mdc_getattr_args *ga;\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct ldlm_res_id res_id;\r\nldlm_policy_data_t policy = {\r\n.l_inodebits = { MDS_INODELOCK_LOOKUP |\r\nMDS_INODELOCK_UPDATE }\r\n};\r\nint rc = 0;\r\n__u64 flags = LDLM_FL_HAS_INTENT;\r\nCDEBUG(D_DLMTRACE,\r\n"name: %.*s in inode "DFID", intent: %s flags %#Lo\n",\r\nop_data->op_namelen, op_data->op_name, PFID(&op_data->op_fid1),\r\nldlm_it2str(it->it_op), it->it_flags);\r\nfid_build_reg_res_name(&op_data->op_fid1, &res_id);\r\nreq = mdc_intent_getattr_pack(exp, it, op_data);\r\nif (IS_ERR(req))\r\nreturn PTR_ERR(req);\r\nrc = mdc_enter_request(&obddev->u.cli);\r\nif (rc != 0) {\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nrc = ldlm_cli_enqueue(exp, &req, einfo, &res_id, &policy, &flags, NULL,\r\n0, LVB_T_NONE, &minfo->mi_lockh, 1);\r\nif (rc < 0) {\r\nmdc_exit_request(&obddev->u.cli);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nCLASSERT(sizeof(*ga) <= sizeof(req->rq_async_args));\r\nga = ptlrpc_req_async_args(req);\r\nga->ga_exp = exp;\r\nga->ga_minfo = minfo;\r\nga->ga_einfo = einfo;\r\nreq->rq_interpret_reply = mdc_intent_getattr_async_interpret;\r\nptlrpcd_add_req(req, PDL_POLICY_LOCAL, -1);\r\nreturn 0;\r\n}
