static __be32 *\r\ndecode_fh(__be32 *p, struct svc_fh *fhp)\r\n{\r\nfh_init(fhp, NFS_FHSIZE);\r\nmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\r\nfhp->fh_handle.fh_size = NFS_FHSIZE;\r\nreturn p + (NFS_FHSIZE >> 2);\r\n}\r\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\r\n{\r\nreturn decode_fh(p, fhp);\r\n}\r\nstatic __be32 *\r\nencode_fh(__be32 *p, struct svc_fh *fhp)\r\n{\r\nmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\r\nreturn p + (NFS_FHSIZE>> 2);\r\n}\r\nstatic __be32 *\r\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\r\n{\r\nchar *name;\r\nunsigned int i;\r\nif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\r\nfor (i = 0, name = *namp; i < *lenp; i++, name++) {\r\nif (*name == '\0' || *name == '/')\r\nreturn NULL;\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *\r\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\r\n{\r\nchar *name;\r\nunsigned int i;\r\nif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\r\nfor (i = 0, name = *namp; i < *lenp; i++, name++) {\r\nif (*name == '\0')\r\nreturn NULL;\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *\r\ndecode_sattr(__be32 *p, struct iattr *iap)\r\n{\r\nu32 tmp, tmp1;\r\niap->ia_valid = 0;\r\nif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\r\niap->ia_valid |= ATTR_MODE;\r\niap->ia_mode = tmp;\r\n}\r\nif ((tmp = ntohl(*p++)) != (u32)-1) {\r\niap->ia_uid = make_kuid(&init_user_ns, tmp);\r\nif (uid_valid(iap->ia_uid))\r\niap->ia_valid |= ATTR_UID;\r\n}\r\nif ((tmp = ntohl(*p++)) != (u32)-1) {\r\niap->ia_gid = make_kgid(&init_user_ns, tmp);\r\nif (gid_valid(iap->ia_gid))\r\niap->ia_valid |= ATTR_GID;\r\n}\r\nif ((tmp = ntohl(*p++)) != (u32)-1) {\r\niap->ia_valid |= ATTR_SIZE;\r\niap->ia_size = tmp;\r\n}\r\ntmp = ntohl(*p++); tmp1 = ntohl(*p++);\r\nif (tmp != (u32)-1 && tmp1 != (u32)-1) {\r\niap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\r\niap->ia_atime.tv_sec = tmp;\r\niap->ia_atime.tv_nsec = tmp1 * 1000;\r\n}\r\ntmp = ntohl(*p++); tmp1 = ntohl(*p++);\r\nif (tmp != (u32)-1 && tmp1 != (u32)-1) {\r\niap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\r\niap->ia_mtime.tv_sec = tmp;\r\niap->ia_mtime.tv_nsec = tmp1 * 1000;\r\nif (tmp1 == 1000000)\r\niap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nencode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\r\nstruct kstat *stat)\r\n{\r\nstruct dentry *dentry = fhp->fh_dentry;\r\nint type;\r\nstruct timespec time;\r\nu32 f;\r\ntype = (stat->mode & S_IFMT);\r\n*p++ = htonl(nfs_ftypes[type >> 12]);\r\n*p++ = htonl((u32) stat->mode);\r\n*p++ = htonl((u32) stat->nlink);\r\n*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\r\n*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\r\nif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN) {\r\n*p++ = htonl(NFS_MAXPATHLEN);\r\n} else {\r\n*p++ = htonl((u32) stat->size);\r\n}\r\n*p++ = htonl((u32) stat->blksize);\r\nif (S_ISCHR(type) || S_ISBLK(type))\r\n*p++ = htonl(new_encode_dev(stat->rdev));\r\nelse\r\n*p++ = htonl(0xffffffff);\r\n*p++ = htonl((u32) stat->blocks);\r\nswitch (fsid_source(fhp)) {\r\ndefault:\r\ncase FSIDSOURCE_DEV:\r\n*p++ = htonl(new_encode_dev(stat->dev));\r\nbreak;\r\ncase FSIDSOURCE_FSID:\r\n*p++ = htonl((u32) fhp->fh_export->ex_fsid);\r\nbreak;\r\ncase FSIDSOURCE_UUID:\r\nf = ((u32*)fhp->fh_export->ex_uuid)[0];\r\nf ^= ((u32*)fhp->fh_export->ex_uuid)[1];\r\nf ^= ((u32*)fhp->fh_export->ex_uuid)[2];\r\nf ^= ((u32*)fhp->fh_export->ex_uuid)[3];\r\n*p++ = htonl(f);\r\nbreak;\r\n}\r\n*p++ = htonl((u32) stat->ino);\r\n*p++ = htonl((u32) stat->atime.tv_sec);\r\n*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);\r\nlease_get_mtime(d_inode(dentry), &time);\r\n*p++ = htonl((u32) time.tv_sec);\r\n*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0);\r\n*p++ = htonl((u32) stat->ctime.tv_sec);\r\n*p++ = htonl(stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0);\r\nreturn p;\r\n}\r\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\r\n{\r\nreturn encode_fattr(rqstp, p, fhp, stat);\r\n}\r\nint\r\nnfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\r\n{\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_sattrargs *args)\r\n{\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\np = decode_sattr(p, &args->attrs);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_diropargs *args)\r\n{\r\nif (!(p = decode_fh(p, &args->fh))\r\n|| !(p = decode_filename(p, &args->name, &args->len)))\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_readargs *args)\r\n{\r\nunsigned int len;\r\nint v;\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nargs->offset = ntohl(*p++);\r\nlen = args->count = ntohl(*p++);\r\np++;\r\nlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\r\nv=0;\r\nwhile (len > 0) {\r\nstruct page *p = *(rqstp->rq_next_page++);\r\nrqstp->rq_vec[v].iov_base = page_address(p);\r\nrqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\r\nlen -= rqstp->rq_vec[v].iov_len;\r\nv++;\r\n}\r\nargs->vlen = v;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_writeargs *args)\r\n{\r\nunsigned int len, hdr, dlen;\r\nint v;\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\np++;\r\nargs->offset = ntohl(*p++);\r\np++;\r\nlen = args->len = ntohl(*p++);\r\nif (len > NFSSVC_MAXBLKSIZE_V2)\r\nreturn 0;\r\nhdr = (void*)p - rqstp->rq_arg.head[0].iov_base;\r\ndlen = rqstp->rq_arg.head[0].iov_len + rqstp->rq_arg.page_len\r\n- hdr;\r\nif (dlen < XDR_QUADLEN(len)*4)\r\nreturn 0;\r\nrqstp->rq_vec[0].iov_base = (void*)p;\r\nrqstp->rq_vec[0].iov_len = rqstp->rq_arg.head[0].iov_len - hdr;\r\nv = 0;\r\nwhile (len > rqstp->rq_vec[v].iov_len) {\r\nlen -= rqstp->rq_vec[v].iov_len;\r\nv++;\r\nrqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\r\nrqstp->rq_vec[v].iov_len = PAGE_SIZE;\r\n}\r\nrqstp->rq_vec[v].iov_len = len;\r\nargs->vlen = v + 1;\r\nreturn 1;\r\n}\r\nint\r\nnfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_createargs *args)\r\n{\r\nif ( !(p = decode_fh(p, &args->fh))\r\n|| !(p = decode_filename(p, &args->name, &args->len)))\r\nreturn 0;\r\np = decode_sattr(p, &args->attrs);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_renameargs *args)\r\n{\r\nif (!(p = decode_fh(p, &args->ffh))\r\n|| !(p = decode_filename(p, &args->fname, &args->flen))\r\n|| !(p = decode_fh(p, &args->tfh))\r\n|| !(p = decode_filename(p, &args->tname, &args->tlen)))\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)\r\n{\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nargs->buffer = page_address(*(rqstp->rq_next_page++));\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_linkargs *args)\r\n{\r\nif (!(p = decode_fh(p, &args->ffh))\r\n|| !(p = decode_fh(p, &args->tfh))\r\n|| !(p = decode_filename(p, &args->tname, &args->tlen)))\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_symlinkargs *args)\r\n{\r\nif ( !(p = decode_fh(p, &args->ffh))\r\n|| !(p = decode_filename(p, &args->fname, &args->flen))\r\n|| !(p = decode_pathname(p, &args->tname, &args->tlen)))\r\nreturn 0;\r\np = decode_sattr(p, &args->attrs);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_readdirargs *args)\r\n{\r\np = decode_fh(p, &args->fh);\r\nif (!p)\r\nreturn 0;\r\nargs->cookie = ntohl(*p++);\r\nargs->count = ntohl(*p++);\r\nargs->count = min_t(u32, args->count, PAGE_SIZE);\r\nargs->buffer = page_address(*(rqstp->rq_next_page++));\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_attrstat *resp)\r\n{\r\np = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_diropres *resp)\r\n{\r\np = encode_fh(p, &resp->fh);\r\np = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_readlinkres *resp)\r\n{\r\n*p++ = htonl(resp->len);\r\nxdr_ressize_check(rqstp, p);\r\nrqstp->rq_res.page_len = resp->len;\r\nif (resp->len & 3) {\r\nrqstp->rq_res.tail[0].iov_base = p;\r\n*p = 0;\r\nrqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\r\n}\r\nreturn 1;\r\n}\r\nint\r\nnfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_readres *resp)\r\n{\r\np = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\r\n*p++ = htonl(resp->count);\r\nxdr_ressize_check(rqstp, p);\r\nrqstp->rq_res.page_len = resp->count;\r\nif (resp->count & 3) {\r\nrqstp->rq_res.tail[0].iov_base = p;\r\n*p = 0;\r\nrqstp->rq_res.tail[0].iov_len = 4 - (resp->count&3);\r\n}\r\nreturn 1;\r\n}\r\nint\r\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_readdirres *resp)\r\n{\r\nxdr_ressize_check(rqstp, p);\r\np = resp->buffer;\r\n*p++ = 0;\r\n*p++ = htonl((resp->common.err == nfserr_eof));\r\nrqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\r\nreturn 1;\r\n}\r\nint\r\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_statfsres *resp)\r\n{\r\nstruct kstatfs *stat = &resp->stats;\r\n*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);\r\n*p++ = htonl(stat->f_bsize);\r\n*p++ = htonl(stat->f_blocks);\r\n*p++ = htonl(stat->f_bfree);\r\n*p++ = htonl(stat->f_bavail);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nint\r\nnfssvc_encode_entry(void *ccdv, const char *name,\r\nint namlen, loff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct readdir_cd *ccd = ccdv;\r\nstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\r\n__be32 *p = cd->buffer;\r\nint buflen, slen;\r\nif (offset > ~((u32) 0)) {\r\ncd->common.err = nfserr_fbig;\r\nreturn -EINVAL;\r\n}\r\nif (cd->offset)\r\n*cd->offset = htonl(offset);\r\nnamlen = min(namlen, NFS2_MAXNAMLEN);\r\nslen = XDR_QUADLEN(namlen);\r\nif ((buflen = cd->buflen - slen - 4) < 0) {\r\ncd->common.err = nfserr_toosmall;\r\nreturn -EINVAL;\r\n}\r\nif (ino > ~((u32) 0)) {\r\ncd->common.err = nfserr_fbig;\r\nreturn -EINVAL;\r\n}\r\n*p++ = xdr_one;\r\n*p++ = htonl((u32) ino);\r\np = xdr_encode_array(p, name, namlen);\r\ncd->offset = p;\r\n*p++ = htonl(~0U);\r\ncd->buflen = buflen;\r\ncd->buffer = p;\r\ncd->common.err = nfs_ok;\r\nreturn 0;\r\n}\r\nint\r\nnfssvc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_fhandle *resp)\r\n{\r\nfh_put(&resp->fh);\r\nreturn 1;\r\n}
