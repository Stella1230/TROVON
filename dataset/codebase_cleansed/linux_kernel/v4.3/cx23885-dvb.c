static int queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct cx23885_tsport *port = q->drv_priv;\r\nport->ts_packet_size = 188 * 4;\r\nport->ts_packet_count = 32;\r\n*num_planes = 1;\r\nsizes[0] = port->ts_packet_size * port->ts_packet_count;\r\nalloc_ctxs[0] = port->dev->alloc_ctx;\r\n*num_buffers = 32;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf =\r\ncontainer_of(vb, struct cx23885_buffer, vb);\r\nreturn cx23885_buf_prepare(buf, port);\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\ncx23885_free_buffer(dev, buf);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\ncx23885_buf_queue(port, buf);\r\n}\r\nstatic void cx23885_dvb_gate_ctrl(struct cx23885_tsport *port, int open)\r\n{\r\nstruct vb2_dvb_frontends *f;\r\nstruct vb2_dvb_frontend *fe;\r\nf = &port->frontends;\r\nif (f->gate <= 1)\r\nfe = vb2_dvb_get_frontend(f, 1);\r\nelse\r\nfe = vb2_dvb_get_frontend(f, f->gate);\r\nif (fe && fe->dvb.frontend && fe->dvb.frontend->ops.i2c_gate_ctrl)\r\nfe->dvb.frontend->ops.i2c_gate_ctrl(fe->dvb.frontend, open);\r\n}\r\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cx23885_tsport *port = q->drv_priv;\r\nstruct cx23885_dmaqueue *dmaq = &port->mpegq;\r\nstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx23885_buffer, queue);\r\ncx23885_start_dma(port, dmaq, buf);\r\nreturn 0;\r\n}\r\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cx23885_tsport *port = q->drv_priv;\r\ncx23885_cancel_buffers(port);\r\n}\r\nstatic int p8000_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx23885_tsport *port = fe->dvb->priv;\r\nstruct cx23885_dev *dev = port->dev;\r\nif (voltage == SEC_VOLTAGE_18)\r\ncx_write(MC417_RWD, 0x00001e00);\r\nelse if (voltage == SEC_VOLTAGE_13)\r\ncx_write(MC417_RWD, 0x00001a00);\r\nelse\r\ncx_write(MC417_RWD, 0x00001800);\r\nreturn 0;\r\n}\r\nstatic int dvbsky_t9580_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx23885_tsport *port = fe->dvb->priv;\r\nstruct cx23885_dev *dev = port->dev;\r\ncx23885_gpio_enable(dev, GPIO_0 | GPIO_1, 1);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\ncx23885_gpio_set(dev, GPIO_1);\r\ncx23885_gpio_clear(dev, GPIO_0);\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ncx23885_gpio_set(dev, GPIO_1);\r\ncx23885_gpio_set(dev, GPIO_0);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\ncx23885_gpio_clear(dev, GPIO_1);\r\ncx23885_gpio_clear(dev, GPIO_0);\r\nbreak;\r\n}\r\nport->fe_set_voltage(fe, voltage);\r\nreturn 0;\r\n}\r\nstatic int dvbsky_s952_portc_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx23885_tsport *port = fe->dvb->priv;\r\nstruct cx23885_dev *dev = port->dev;\r\ncx23885_gpio_enable(dev, GPIO_12 | GPIO_13, 1);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\ncx23885_gpio_set(dev, GPIO_13);\r\ncx23885_gpio_clear(dev, GPIO_12);\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ncx23885_gpio_set(dev, GPIO_13);\r\ncx23885_gpio_set(dev, GPIO_12);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\ncx23885_gpio_clear(dev, GPIO_13);\r\ncx23885_gpio_clear(dev, GPIO_12);\r\nbreak;\r\n}\r\nreturn port->fe_set_voltage(fe, voltage);\r\n}\r\nstatic int cx23885_sp2_ci_ctrl(void *priv, u8 read, int addr,\r\nu8 data, int *mem)\r\n{\r\n#define SP2_DATA 0x000000ff\r\n#define SP2_WR 0x00008000\r\n#define SP2_RD 0x00004000\r\n#define SP2_ACK 0x00001000\r\n#define SP2_ADHI 0x00000800\r\n#define SP2_ADLO 0x00000400\r\n#define SP2_CS1 0x00000200\r\n#define SP2_CS0 0x00000100\r\n#define SP2_EN_ALL 0x00001000\r\n#define SP2_CTRL_OFF (SP2_CS1 | SP2_CS0 | SP2_WR | SP2_RD)\r\nstruct cx23885_tsport *port = priv;\r\nstruct cx23885_dev *dev = port->dev;\r\nint ret;\r\nint tmp = 0;\r\nunsigned long timeout;\r\nmutex_lock(&dev->gpio_lock);\r\ncx_write(MC417_OEN, SP2_EN_ALL);\r\ncx_write(MC417_RWD, SP2_CTRL_OFF |\r\nSP2_ADLO | (0xff & addr));\r\ncx_clear(MC417_RWD, SP2_ADLO);\r\ncx_write(MC417_RWD, SP2_CTRL_OFF |\r\nSP2_ADHI | (0xff & (addr >> 8)));\r\ncx_clear(MC417_RWD, SP2_ADHI);\r\nif (read)\r\ncx_write(MC417_OEN, SP2_EN_ALL | SP2_DATA);\r\nelse\r\ncx_write(MC417_RWD, SP2_CTRL_OFF | data);\r\ncx_clear(MC417_RWD, SP2_CS0);\r\ncx_clear(MC417_RWD, (read) ? SP2_RD : SP2_WR);\r\ntimeout = jiffies + msecs_to_jiffies(1);\r\nwhile (!time_after(jiffies, timeout)) {\r\ntmp = cx_read(MC417_RWD);\r\nif ((tmp & SP2_ACK) == 0)\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\ncx_set(MC417_RWD, SP2_CTRL_OFF);\r\n*mem = tmp & 0xff;\r\nmutex_unlock(&dev->gpio_lock);\r\nif (!read) {\r\nif (*mem < 0) {\r\nret = -EREMOTEIO;\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cx23885_dvb_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cx23885_tsport *port = fe->dvb->priv;\r\nstruct cx23885_dev *dev = port->dev;\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1275:\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\ncx23885_gpio_clear(dev, GPIO_5);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\ndefault:\r\ncx23885_gpio_set(dev, GPIO_5);\r\nbreak;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_MYGICA_X8506:\r\ncase CX23885_BOARD_MYGICA_X8507:\r\ncase CX23885_BOARD_MAGICPRO_PROHDTVE2:\r\ncx23885_gpio_set(dev, GPIO_0);\r\nbreak;\r\n}\r\nif (port->set_frontend)\r\nreturn port->set_frontend(fe);\r\nreturn 0;\r\n}\r\nstatic void cx23885_set_frontend_hook(struct cx23885_tsport *port,\r\nstruct dvb_frontend *fe)\r\n{\r\nport->set_frontend = fe->ops.set_frontend;\r\nfe->ops.set_frontend = cx23885_dvb_set_frontend;\r\n}\r\nstatic int netup_altera_fpga_rw(void *device, int flag, int data, int read)\r\n{\r\nstruct cx23885_dev *dev = (struct cx23885_dev *)device;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nuint32_t mem = 0;\r\nmem = cx_read(MC417_RWD);\r\nif (read)\r\ncx_set(MC417_OEN, ALT_DATA);\r\nelse {\r\ncx_clear(MC417_OEN, ALT_DATA);\r\nmem &= ~ALT_DATA;\r\nmem |= (data & ALT_DATA);\r\n}\r\nif (flag)\r\nmem |= ALT_AD_RG;\r\nelse\r\nmem &= ~ALT_AD_RG;\r\nmem &= ~ALT_CS;\r\nif (read)\r\nmem = (mem & ~ALT_RD) | ALT_WR;\r\nelse\r\nmem = (mem & ~ALT_WR) | ALT_RD;\r\ncx_write(MC417_RWD, mem);\r\nfor (;;) {\r\nmem = cx_read(MC417_RWD);\r\nif ((mem & ALT_RDY) == 0)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nudelay(1);\r\n}\r\ncx_set(MC417_RWD, ALT_RD | ALT_WR | ALT_CS);\r\nif (read)\r\nreturn mem & ALT_DATA;\r\nreturn 0;\r\n}\r\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib7000p_ops *dib7000p_ops = fe->sec_priv;\r\nreturn dib7000p_ops->set_gpio(fe, 8, 0, !onoff);\r\n}\r\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dvb_register_ci_mac(struct cx23885_tsport *port)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct i2c_client *client_ci = NULL;\r\nstruct vb2_dvb_frontend *fe0;\r\nfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\r\nif (!fe0)\r\nreturn -EINVAL;\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_NETUP_DUAL_DVBS2_CI: {\r\nstatic struct netup_card_info cinfo;\r\nnetup_get_card_info(&dev->i2c_bus[0].i2c_adap, &cinfo);\r\nmemcpy(port->frontends.adapter.proposed_mac,\r\ncinfo.port[port->nr - 1].mac, 6);\r\nprintk(KERN_INFO "NetUP Dual DVB-S2 CI card port%d MAC=%pM\n",\r\nport->nr, port->frontends.adapter.proposed_mac);\r\nnetup_ci_init(port);\r\nreturn 0;\r\n}\r\ncase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF: {\r\nstruct altera_ci_config netup_ci_cfg = {\r\n.dev = dev,\r\n.adapter = &port->frontends.adapter,\r\n.demux = &fe0->dvb.demux,\r\n.fpga_rw = netup_altera_fpga_rw,\r\n};\r\naltera_ci_init(&netup_ci_cfg, port->nr);\r\nreturn 0;\r\n}\r\ncase CX23885_BOARD_TEVII_S470: {\r\nu8 eeprom[256];\r\nif (port->nr != 1)\r\nreturn 0;\r\ndev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\r\ntveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));\r\nprintk(KERN_INFO "TeVii S470 MAC= %pM\n", eeprom + 0xa0);\r\nmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xa0, 6);\r\nreturn 0;\r\n}\r\ncase CX23885_BOARD_DVBSKY_T9580:\r\ncase CX23885_BOARD_DVBSKY_S950:\r\ncase CX23885_BOARD_DVBSKY_S952:\r\ncase CX23885_BOARD_DVBSKY_T982: {\r\nu8 eeprom[256];\r\nif (port->nr > 2)\r\nreturn 0;\r\ndev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\r\ntveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,\r\nsizeof(eeprom));\r\nprintk(KERN_INFO "%s port %d MAC address: %pM\n",\r\ncx23885_boards[dev->board].name, port->nr,\r\neeprom + 0xc0 + (port->nr-1) * 8);\r\nmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 +\r\n(port->nr-1) * 8, 6);\r\nreturn 0;\r\n}\r\ncase CX23885_BOARD_DVBSKY_S950C:\r\ncase CX23885_BOARD_DVBSKY_T980C:\r\ncase CX23885_BOARD_TT_CT2_4500_CI: {\r\nu8 eeprom[256];\r\nstruct sp2_config sp2_config;\r\nstruct i2c_board_info info;\r\nstruct cx23885_i2c *i2c_bus2 = &dev->i2c_bus[1];\r\nmemset(&sp2_config, 0, sizeof(sp2_config));\r\nsp2_config.dvb_adap = &port->frontends.adapter;\r\nsp2_config.priv = port;\r\nsp2_config.ci_control = cx23885_sp2_ci_ctrl;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "sp2", I2C_NAME_SIZE);\r\ninfo.addr = 0x40;\r\ninfo.platform_data = &sp2_config;\r\nrequest_module(info.type);\r\nclient_ci = i2c_new_device(&i2c_bus2->i2c_adap, &info);\r\nif (client_ci == NULL || client_ci->dev.driver == NULL)\r\nreturn -ENODEV;\r\nif (!try_module_get(client_ci->dev.driver->owner)) {\r\ni2c_unregister_device(client_ci);\r\nreturn -ENODEV;\r\n}\r\nport->i2c_client_ci = client_ci;\r\nif (port->nr != 1)\r\nreturn 0;\r\ndev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\r\ntveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,\r\nsizeof(eeprom));\r\nprintk(KERN_INFO "%s MAC address: %pM\n",\r\ncx23885_boards[dev->board].name, eeprom + 0xc0);\r\nmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0, 6);\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_register(struct cx23885_tsport *port)\r\n{\r\nstruct dib7000p_ops dib7000p_ops;\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_i2c *i2c_bus = NULL, *i2c_bus2 = NULL;\r\nstruct vb2_dvb_frontend *fe0, *fe1 = NULL;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nstruct ts2020_config ts2020_config;\r\nstruct i2c_board_info info;\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client_demod = NULL, *client_tuner = NULL;\r\nstruct i2c_client *client_sec = NULL;\r\nconst struct m88ds3103_config *p_m88ds3103_config = NULL;\r\nint (*p_set_voltage)(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage) = NULL;\r\nint mfe_shared = 0;\r\nint ret;\r\nfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\r\nif (!fe0)\r\nreturn -EINVAL;\r\nfe0->dvb.name = dev->name;\r\nport->frontends.gate = 0;\r\nport->gate_ctrl = cx23885_dvb_gate_ctrl;\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1250:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(s5h1409_attach,\r\n&hauppauge_generic_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(mt2131_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&hauppauge_generic_tunerconfig, 0);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1270:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1275:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(lgdt3305_attach,\r\n&hauppauge_lgdt3305_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_hvr127x_config);\r\nif (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1275)\r\ncx23885_set_frontend_hook(port, fe0->dvb.frontend);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255_22111:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(s5h1411_attach,\r\n&hcw_s5h1411_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_tda18271_config);\r\ntda18271_attach(&dev->ts1.analog_fe,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_tda18271_config);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1800:\r\ni2c_bus = &dev->i2c_bus[0];\r\nswitch (alt_tuner) {\r\ncase 1:\r\nfe0->dvb.frontend =\r\ndvb_attach(s5h1409_attach,\r\n&hauppauge_ezqam_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda829x_attach, fe0->dvb.frontend,\r\n&dev->i2c_bus[1].i2c_adap, 0x42,\r\n&tda829x_no_probe);\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_tda18271_config);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nfe0->dvb.frontend =\r\ndvb_attach(s5h1409_attach,\r\n&hauppauge_generic_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(mt2131_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&hauppauge_generic_tunerconfig, 0);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1800lp:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(s5h1409_attach,\r\n&hauppauge_hvr1800lp_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(mt2131_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&hauppauge_generic_tunerconfig, 0);\r\nbreak;\r\ncase CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(lgdt330x_attach,\r\n&fusionhdtv_5_express,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(simple_tuner_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap, 0x61,\r\nTUNER_LG_TDVS_H06XF);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1500Q:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(s5h1409_attach,\r\n&hauppauge_hvr1500q_config,\r\n&dev->i2c_bus[0].i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&hauppauge_hvr1500q_tunerconfig);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1500:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(s5h1409_attach,\r\n&hauppauge_hvr1500_config,\r\n&dev->i2c_bus[0].i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &i2c_bus->i2c_adap,\r\n.i2c_addr = 0x61,\r\n};\r\nstatic struct xc2028_ctrl ctl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_OREN538,\r\n};\r\nfe = dvb_attach(xc2028_attach,\r\nfe0->dvb.frontend, &cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctl);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1200:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1700:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(tda10048_attach,\r\n&hauppauge_hvr1200_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda829x_attach, fe0->dvb.frontend,\r\n&dev->i2c_bus[1].i2c_adap, 0x42,\r\n&tda829x_no_probe);\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_hvr1200_tuner_config);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1210:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(tda10048_attach,\r\n&hauppauge_hvr1210_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_hvr1210_tuner_config);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1400:\r\ni2c_bus = &dev->i2c_bus[0];\r\nif (!dvb_attach(dib7000p_attach, &dib7000p_ops))\r\nreturn -ENODEV;\r\nfe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap,\r\n0x12, &hauppauge_hvr1400_dib7000_config);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &dev->i2c_bus[1].i2c_adap,\r\n.i2c_addr = 0x64,\r\n};\r\nstatic struct xc2028_ctrl ctl = {\r\n.fname = XC3028L_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_DIBCOM52,\r\n.type = XC2028_D2633,\r\n};\r\nfe = dvb_attach(xc2028_attach,\r\nfe0->dvb.frontend, &cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctl);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP:\r\ni2c_bus = &dev->i2c_bus[port->nr - 1];\r\nfe0->dvb.frontend = dvb_attach(s5h1409_attach,\r\n&dvico_s5h1409_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nfe0->dvb.frontend = dvb_attach(s5h1411_attach,\r\n&dvico_s5h1411_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL)\r\ndvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&dvico_xc5000_tunerconfig);\r\nbreak;\r\ncase CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP: {\r\ni2c_bus = &dev->i2c_bus[port->nr - 1];\r\nfe0->dvb.frontend = dvb_attach(zl10353_attach,\r\n&dvico_fusionhdtv_xc3028,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &i2c_bus->i2c_adap,\r\n.i2c_addr = 0x61,\r\n};\r\nstatic struct xc2028_ctrl ctl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n};\r\nfe = dvb_attach(xc2028_attach, fe0->dvb.frontend,\r\n&cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctl);\r\n}\r\nbreak;\r\n}\r\ncase CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2: {\r\ni2c_bus = &dev->i2c_bus[port->nr - 1];\r\nif (!dvb_attach(dib7000p_attach, &dib7000p_ops))\r\nreturn -ENODEV;\r\nif (dib7000p_ops.i2c_enumeration(&i2c_bus->i2c_adap, 1, 0x12, &dib7070p_dib7000p_config) < 0) {\r\nprintk(KERN_WARNING "Unable to enumerate dib7000p\n");\r\nreturn -ENODEV;\r\n}\r\nfe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap, 0x80, &dib7070p_dib7000p_config);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct i2c_adapter *tun_i2c;\r\nfe0->dvb.frontend->sec_priv = kmalloc(sizeof(dib7000p_ops), GFP_KERNEL);\r\nmemcpy(fe0->dvb.frontend->sec_priv, &dib7000p_ops, sizeof(dib7000p_ops));\r\ntun_i2c = dib7000p_ops.get_i2c_master(fe0->dvb.frontend, DIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (!dvb_attach(dib0070_attach, fe0->dvb.frontend, tun_i2c, &dib7070p_dib0070_config))\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\n}\r\ncase CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:\r\ncase CX23885_BOARD_COMPRO_VIDEOMATE_E650F:\r\ncase CX23885_BOARD_COMPRO_VIDEOMATE_E800:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(zl10353_attach,\r\n&dvico_fusionhdtv_xc3028,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &dev->i2c_bus[1].i2c_adap,\r\n.i2c_addr = 0x61,\r\n};\r\nstatic struct xc2028_ctrl ctl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n};\r\nfe = dvb_attach(xc2028_attach, fe0->dvb.frontend,\r\n&cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctl);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(zl10353_attach,\r\n&dvico_fusionhdtv_xc3028,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc4000_config cfg = {\r\n.i2c_address = 0x61,\r\n.default_pm = 0,\r\n.dvb_amplitude = 134,\r\n.set_smoothedcvbs = 1,\r\n.if_khz = 4560\r\n};\r\nfe = dvb_attach(xc4000_attach, fe0->dvb.frontend,\r\n&dev->i2c_bus[1].i2c_adap, &cfg);\r\nif (!fe) {\r\nprintk(KERN_ERR "%s/2: xc4000 attach failed\n",\r\ndev->name);\r\ngoto frontend_detach;\r\n}\r\n}\r\nbreak;\r\ncase CX23885_BOARD_TBS_6920:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(cx24116_attach,\r\n&tbs_cx24116_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL)\r\nfe0->dvb.frontend->ops.set_voltage = f300_set_voltage;\r\nbreak;\r\ncase CX23885_BOARD_TBS_6980:\r\ncase CX23885_BOARD_TBS_6981:\r\ni2c_bus = &dev->i2c_bus[1];\r\nswitch (port->nr) {\r\ncase 1:\r\nfe0->dvb.frontend = dvb_attach(cx24117_attach,\r\n&tbs_cx24117_config,\r\n&i2c_bus->i2c_adap);\r\nbreak;\r\ncase 2:\r\nfe0->dvb.frontend = dvb_attach(cx24117_attach,\r\n&tbs_cx24117_config,\r\n&i2c_bus->i2c_adap);\r\nbreak;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_TEVII_S470:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(ds3000_attach,\r\n&tevii_ds3000_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend != NULL) {\r\ndvb_attach(ts2020_attach, fe0->dvb.frontend,\r\n&tevii_ts2020_config, &i2c_bus->i2c_adap);\r\nfe0->dvb.frontend->ops.set_voltage = f300_set_voltage;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_DVBWORLD_2005:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(cx24116_attach,\r\n&dvbworld_cx24116_config,\r\n&i2c_bus->i2c_adap);\r\nbreak;\r\ncase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\r\ni2c_bus = &dev->i2c_bus[0];\r\nswitch (port->nr) {\r\ncase 1:\r\nfe0->dvb.frontend = dvb_attach(stv0900_attach,\r\n&netup_stv0900_config,\r\n&i2c_bus->i2c_adap, 0);\r\nif (fe0->dvb.frontend != NULL) {\r\nif (dvb_attach(stv6110_attach,\r\nfe0->dvb.frontend,\r\n&netup_stv6110_tunerconfig_a,\r\n&i2c_bus->i2c_adap)) {\r\nif (!dvb_attach(lnbh24_attach,\r\nfe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\nLNBH24_PCL | LNBH24_TTX,\r\nLNBH24_TEN, 0x09))\r\nprintk(KERN_ERR\r\n"No LNBH24 found!\n");\r\n}\r\n}\r\nbreak;\r\ncase 2:\r\nfe0->dvb.frontend = dvb_attach(stv0900_attach,\r\n&netup_stv0900_config,\r\n&i2c_bus->i2c_adap, 1);\r\nif (fe0->dvb.frontend != NULL) {\r\nif (dvb_attach(stv6110_attach,\r\nfe0->dvb.frontend,\r\n&netup_stv6110_tunerconfig_b,\r\n&i2c_bus->i2c_adap)) {\r\nif (!dvb_attach(lnbh24_attach,\r\nfe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\nLNBH24_PCL | LNBH24_TTX,\r\nLNBH24_TEN, 0x0a))\r\nprintk(KERN_ERR\r\n"No LNBH24 found!\n");\r\n}\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_MYGICA_X8506:\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(lgs8gxx_attach,\r\n&mygica_x8506_lgs8gl5_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus2->i2c_adap, &mygica_x8506_xc5000_config);\r\ncx23885_set_frontend_hook(port, fe0->dvb.frontend);\r\nbreak;\r\ncase CX23885_BOARD_MYGICA_X8507:\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(mb86a20s_attach,\r\n&mygica_x8507_mb86a20s_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus2->i2c_adap,\r\n&mygica_x8507_xc5000_config);\r\ncx23885_set_frontend_hook(port, fe0->dvb.frontend);\r\nbreak;\r\ncase CX23885_BOARD_MAGICPRO_PROHDTVE2:\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(lgs8gxx_attach,\r\n&magicpro_prohdtve2_lgs8g75_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus2->i2c_adap,\r\n&magicpro_prohdtve2_xc5000_config);\r\ncx23885_set_frontend_hook(port, fe0->dvb.frontend);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1850:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(s5h1411_attach,\r\n&hcw_s5h1411_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[0].i2c_adap,\r\n&hauppauge_tda18271_config);\r\ntda18271_attach(&dev->ts1.analog_fe,\r\n0x60, &dev->i2c_bus[1].i2c_adap,\r\n&hauppauge_tda18271_config);\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1290:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(s5h1411_attach,\r\n&hcw_s5h1411_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(tda18271_attach, fe0->dvb.frontend,\r\n0x60, &dev->i2c_bus[0].i2c_adap,\r\n&hauppauge_tda18271_config);\r\nbreak;\r\ncase CX23885_BOARD_MYGICA_X8558PRO:\r\nswitch (port->nr) {\r\ncase 1:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(atbm8830_attach,\r\n&mygica_x8558pro_atbm8830_cfg1,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(max2165_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&mygic_x8558pro_max2165_cfg1);\r\nbreak;\r\ncase 2:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(atbm8830_attach,\r\n&mygica_x8558pro_atbm8830_cfg2,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(max2165_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&mygic_x8558pro_max2165_cfg2);\r\n}\r\nbreak;\r\ncase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\r\ni2c_bus = &dev->i2c_bus[0];\r\nmfe_shared = 1;\r\nport->frontends.gate = 0;\r\nfe0->dvb.frontend = dvb_attach(stv0367ter_attach,\r\n&netup_stv0367_config[port->nr - 1],\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nif (NULL == dvb_attach(xc5000_attach, fe0->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&netup_xc5000_config[port->nr - 1]))\r\ngoto frontend_detach;\r\nfe0->dvb.frontend->ops.tuner_ops.init(fe0->dvb.frontend);\r\nfe1 = vb2_dvb_get_frontend(&port->frontends, 2);\r\nif (fe1 == NULL)\r\ngoto frontend_detach;\r\nfe1->dvb.frontend = dvb_attach(stv0367cab_attach,\r\n&netup_stv0367_config[port->nr - 1],\r\n&i2c_bus->i2c_adap);\r\nif (fe1->dvb.frontend == NULL)\r\nbreak;\r\nfe1->dvb.frontend->id = 1;\r\nif (NULL == dvb_attach(xc5000_attach,\r\nfe1->dvb.frontend,\r\n&i2c_bus->i2c_adap,\r\n&netup_xc5000_config[port->nr - 1]))\r\ngoto frontend_detach;\r\nbreak;\r\ncase CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nswitch (port->nr) {\r\ncase 1:\r\nfe0->dvb.frontend = dvb_attach(drxk_attach,\r\n&terratec_drxk_config[0],\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nif (!dvb_attach(mt2063_attach,\r\nfe0->dvb.frontend,\r\n&terratec_mt2063_config[0],\r\n&i2c_bus2->i2c_adap))\r\ngoto frontend_detach;\r\nbreak;\r\ncase 2:\r\nfe0->dvb.frontend = dvb_attach(drxk_attach,\r\n&terratec_drxk_config[1],\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nif (!dvb_attach(mt2063_attach,\r\nfe0->dvb.frontend,\r\n&terratec_mt2063_config[1],\r\n&i2c_bus2->i2c_adap))\r\ngoto frontend_detach;\r\nbreak;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_TEVII_S471:\r\ni2c_bus = &dev->i2c_bus[1];\r\nfe0->dvb.frontend = dvb_attach(ds3000_attach,\r\n&tevii_ds3000_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\ndvb_attach(ts2020_attach, fe0->dvb.frontend,\r\n&tevii_ts2020_config, &i2c_bus->i2c_adap);\r\nbreak;\r\ncase CX23885_BOARD_PROF_8000:\r\ni2c_bus = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(stv090x_attach,\r\n&prof_8000_stv090x_config,\r\n&i2c_bus->i2c_adap,\r\nSTV090x_DEMODULATOR_0);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nif (!dvb_attach(stb6100_attach,\r\nfe0->dvb.frontend,\r\n&prof_8000_stb6100_config,\r\n&i2c_bus->i2c_adap))\r\ngoto frontend_detach;\r\nfe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR4400: {\r\nstruct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;\r\nstruct a8293_platform_data a8293_pdata = {};\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nswitch (port->nr) {\r\ncase 1:\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, "tda10071_cx24118", I2C_NAME_SIZE);\r\ninfo.addr = 0x05;\r\ninfo.platform_data = &tda10071_pdata;\r\nrequest_module("tda10071");\r\nclient_demod = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (!client_demod || !client_demod->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);\r\nport->i2c_client_demod = client_demod;\r\na8293_pdata.dvb_frontend = fe0->dvb.frontend;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, "a8293", I2C_NAME_SIZE);\r\ninfo.addr = 0x0b;\r\ninfo.platform_data = &a8293_pdata;\r\nrequest_module("a8293");\r\nclient_sec = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (!client_sec || !client_sec->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_sec->dev.driver->owner)) {\r\ni2c_unregister_device(client_sec);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_sec = client_sec;\r\nbreak;\r\ncase 2:\r\nfe0->dvb.frontend = dvb_attach(si2165_attach,\r\n&hauppauge_hvr4400_si2165_config,\r\n&i2c_bus->i2c_adap);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nfe0->dvb.frontend->ops.i2c_gate_ctrl = NULL;\r\nif (!dvb_attach(tda18271_attach,\r\nfe0->dvb.frontend,\r\n0x60, &i2c_bus2->i2c_adap,\r\n&hauppauge_hvr4400_tuner_config))\r\ngoto frontend_detach;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase CX23885_BOARD_HAUPPAUGE_STARBURST: {\r\nstruct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;\r\nstruct a8293_platform_data a8293_pdata = {};\r\ni2c_bus = &dev->i2c_bus[0];\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, "tda10071_cx24118", I2C_NAME_SIZE);\r\ninfo.addr = 0x05;\r\ninfo.platform_data = &tda10071_pdata;\r\nrequest_module("tda10071");\r\nclient_demod = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (!client_demod || !client_demod->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);\r\nport->i2c_client_demod = client_demod;\r\na8293_pdata.dvb_frontend = fe0->dvb.frontend;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, "a8293", I2C_NAME_SIZE);\r\ninfo.addr = 0x0b;\r\ninfo.platform_data = &a8293_pdata;\r\nrequest_module("a8293");\r\nclient_sec = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (!client_sec || !client_sec->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_sec->dev.driver->owner)) {\r\ni2c_unregister_device(client_sec);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_sec = client_sec;\r\nbreak;\r\n}\r\ncase CX23885_BOARD_DVBSKY_T9580:\r\ncase CX23885_BOARD_DVBSKY_S950:\r\ni2c_bus = &dev->i2c_bus[0];\r\ni2c_bus2 = &dev->i2c_bus[1];\r\nswitch (port->nr) {\r\ncase 1:\r\nfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\r\n&dvbsky_t9580_m88ds3103_config,\r\n&i2c_bus2->i2c_adap, &adapter);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nmemset(&ts2020_config, 0, sizeof(ts2020_config));\r\nts2020_config.fe = fe0->dvb.frontend;\r\nts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ts2020", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend->ops.read_signal_strength =\r\nfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\r\nport->fe_set_voltage =\r\nfe0->dvb.frontend->ops.set_voltage;\r\nfe0->dvb.frontend->ops.set_voltage =\r\ndvbsky_t9580_set_voltage;\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\ncase 2:\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &fe0->dvb.frontend;\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient_demod = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (client_demod == NULL ||\r\nclient_demod->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_demod = client_demod;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = fe0->dvb.frontend;\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\n}\r\nbreak;\r\ncase CX23885_BOARD_DVBSKY_T980C:\r\ncase CX23885_BOARD_TT_CT2_4500_CI:\r\ni2c_bus = &dev->i2c_bus[1];\r\ni2c_bus2 = &dev->i2c_bus[0];\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &fe0->dvb.frontend;\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient_demod = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (client_demod == NULL || client_demod->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_demod = client_demod;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = fe0->dvb.frontend;\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\ncase CX23885_BOARD_DVBSKY_S950C:\r\ni2c_bus = &dev->i2c_bus[1];\r\ni2c_bus2 = &dev->i2c_bus[0];\r\nfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\r\n&dvbsky_s950c_m88ds3103_config,\r\n&i2c_bus->i2c_adap, &adapter);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nmemset(&ts2020_config, 0, sizeof(ts2020_config));\r\nts2020_config.fe = fe0->dvb.frontend;\r\nts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ts2020", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL || client_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend->ops.read_signal_strength =\r\nfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\ncase CX23885_BOARD_DVBSKY_S952:\r\nswitch (port->nr) {\r\ncase 1:\r\ni2c_bus = &dev->i2c_bus[1];\r\np_m88ds3103_config = &dvbsky_t9580_m88ds3103_config;\r\np_set_voltage = dvbsky_t9580_set_voltage;\r\nbreak;\r\ncase 2:\r\ni2c_bus = &dev->i2c_bus[0];\r\np_m88ds3103_config = &dvbsky_s952_portc_m88ds3103_config;\r\np_set_voltage = dvbsky_s952_portc_set_voltage;\r\nbreak;\r\n}\r\nfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\r\np_m88ds3103_config,\r\n&i2c_bus->i2c_adap, &adapter);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\nmemset(&ts2020_config, 0, sizeof(ts2020_config));\r\nts2020_config.fe = fe0->dvb.frontend;\r\nts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ts2020", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL || client_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend->ops.read_signal_strength =\r\nfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\r\nport->fe_set_voltage =\r\nfe0->dvb.frontend->ops.set_voltage;\r\nfe0->dvb.frontend->ops.set_voltage = p_set_voltage;\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\ncase CX23885_BOARD_DVBSKY_T982:\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nswitch (port->nr) {\r\ncase 1:\r\ni2c_bus = &dev->i2c_bus[1];\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nbreak;\r\ncase 2:\r\ni2c_bus = &dev->i2c_bus[0];\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nbreak;\r\n}\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &fe0->dvb.frontend;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient_demod = i2c_new_device(&i2c_bus->i2c_adap, &info);\r\nif (client_demod == NULL || client_demod->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_demod = client_demod;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = fe0->dvb.frontend;\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\ncase CX23885_BOARD_HAUPPAUGE_HVR5525:\r\nswitch (port->nr) {\r\nstruct m88rs6000t_config m88rs6000t_config;\r\nstruct a8293_platform_data a8293_pdata = {};\r\ncase 1:\r\nfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\r\n&hauppauge_hvr5525_m88ds3103_config,\r\n&dev->i2c_bus[0].i2c_adap, &adapter);\r\nif (fe0->dvb.frontend == NULL)\r\nbreak;\r\na8293_pdata.dvb_frontend = fe0->dvb.frontend;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, "a8293", I2C_NAME_SIZE);\r\ninfo.addr = 0x0b;\r\ninfo.platform_data = &a8293_pdata;\r\nrequest_module("a8293");\r\nclient_sec = i2c_new_device(&dev->i2c_bus[0].i2c_adap, &info);\r\nif (!client_sec || !client_sec->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_sec->dev.driver->owner)) {\r\ni2c_unregister_device(client_sec);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_sec = client_sec;\r\nmemset(&m88rs6000t_config, 0, sizeof(m88rs6000t_config));\r\nm88rs6000t_config.fe = fe0->dvb.frontend;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "m88rs6000t", I2C_NAME_SIZE);\r\ninfo.addr = 0x21;\r\ninfo.platform_data = &m88rs6000t_config;\r\nrequest_module("%s", info.type);\r\nclient_tuner = i2c_new_device(adapter, &info);\r\nif (!client_tuner || !client_tuner->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nfe0->dvb.frontend->ops.read_signal_strength =\r\nfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\r\nbreak;\r\ncase 2:\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &fe0->dvb.frontend;\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module("%s", info.type);\r\nclient_demod = i2c_new_device(&dev->i2c_bus[0].i2c_adap, &info);\r\nif (!client_demod || !client_demod->dev.driver)\r\ngoto frontend_detach;\r\nif (!try_module_get(client_demod->dev.driver->owner)) {\r\ni2c_unregister_device(client_demod);\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_demod = client_demod;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = fe0->dvb.frontend;\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module("%s", info.type);\r\nclient_tuner = i2c_new_device(&dev->i2c_bus[1].i2c_adap, &info);\r\nif (!client_tuner || !client_tuner->dev.driver) {\r\nmodule_put(client_demod->dev.driver->owner);\r\ni2c_unregister_device(client_demod);\r\nport->i2c_client_demod = NULL;\r\ngoto frontend_detach;\r\n}\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\ni2c_unregister_device(client_tuner);\r\nmodule_put(client_demod->dev.driver->owner);\r\ni2c_unregister_device(client_demod);\r\nport->i2c_client_demod = NULL;\r\ngoto frontend_detach;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: The frontend of your DVB/ATSC card "\r\n" isn't supported yet\n",\r\ndev->name);\r\nbreak;\r\n}\r\nif ((NULL == fe0->dvb.frontend) || (fe1 && NULL == fe1->dvb.frontend)) {\r\nprintk(KERN_ERR "%s: frontend initialization failed\n",\r\ndev->name);\r\ngoto frontend_detach;\r\n}\r\nfe0->dvb.frontend->callback = cx23885_tuner_callback;\r\nif (fe1)\r\nfe1->dvb.frontend->callback = cx23885_tuner_callback;\r\n#if 0\r\nfe0->dvb.frontend->ops.ts_bus_ctrl = cx23885_dvb_bus_ctrl;\r\nif (fe1)\r\nfe1->dvb.frontend->ops.ts_bus_ctrl = cx23885_dvb_bus_ctrl;\r\n#endif\r\ncall_all(dev, core, s_power, 0);\r\nif (fe0->dvb.frontend->ops.analog_ops.standby)\r\nfe0->dvb.frontend->ops.analog_ops.standby(fe0->dvb.frontend);\r\nret = vb2_dvb_register_bus(&port->frontends, THIS_MODULE, port,\r\n&dev->pci->dev, adapter_nr, mfe_shared);\r\nif (ret)\r\ngoto frontend_detach;\r\nret = dvb_register_ci_mac(port);\r\nif (ret)\r\ngoto frontend_detach;\r\nreturn 0;\r\nfrontend_detach:\r\nclient_sec = port->i2c_client_sec;\r\nif (client_sec) {\r\nmodule_put(client_sec->dev.driver->owner);\r\ni2c_unregister_device(client_sec);\r\nport->i2c_client_sec = NULL;\r\n}\r\nclient_tuner = port->i2c_client_tuner;\r\nif (client_tuner) {\r\nmodule_put(client_tuner->dev.driver->owner);\r\ni2c_unregister_device(client_tuner);\r\nport->i2c_client_tuner = NULL;\r\n}\r\nclient_demod = port->i2c_client_demod;\r\nif (client_demod) {\r\nmodule_put(client_demod->dev.driver->owner);\r\ni2c_unregister_device(client_demod);\r\nport->i2c_client_demod = NULL;\r\n}\r\nport->gate_ctrl = NULL;\r\nvb2_dvb_dealloc_frontends(&port->frontends);\r\nreturn -EINVAL;\r\n}\r\nint cx23885_dvb_register(struct cx23885_tsport *port)\r\n{\r\nstruct vb2_dvb_frontend *fe0;\r\nstruct cx23885_dev *dev = port->dev;\r\nint err, i;\r\nprintk(KERN_INFO "%s() allocating %d frontend(s)\n", __func__,\r\nport->num_frontends);\r\nfor (i = 1; i <= port->num_frontends; i++) {\r\nstruct vb2_queue *q;\r\nif (vb2_dvb_alloc_frontend(\r\n&port->frontends, i) == NULL) {\r\nprintk(KERN_ERR "%s() failed to alloc\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nfe0 = vb2_dvb_get_frontend(&port->frontends, i);\r\nif (!fe0)\r\nreturn -EINVAL;\r\ndprintk(1, "%s\n", __func__);\r\ndprintk(1, " ->probed by Card=%d Name=%s, PCI %02x:%02x\n",\r\ndev->board,\r\ndev->name,\r\ndev->pci_bus,\r\ndev->pci_slot);\r\nerr = -ENODEV;\r\nprintk(KERN_INFO "%s: cx23885 based dvb card\n", dev->name);\r\nq = &fe0->dvb.dvbq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = port;\r\nq->buf_struct_size = sizeof(struct cx23885_buffer);\r\nq->ops = &dvb_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = dvb_register(port);\r\nif (err != 0)\r\nprintk(KERN_ERR "%s() dvb_register failed err = %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nint cx23885_dvb_unregister(struct cx23885_tsport *port)\r\n{\r\nstruct vb2_dvb_frontend *fe0;\r\nstruct i2c_client *client;\r\nclient = port->i2c_client_ci;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = port->i2c_client_sec;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = port->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = port->i2c_client_demod;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\r\nif (fe0 && fe0->dvb.frontend)\r\nvb2_dvb_unregister_bus(&port->frontends);\r\nswitch (port->dev->board) {\r\ncase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\r\nnetup_ci_exit(port);\r\nbreak;\r\ncase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\r\naltera_ci_release(port->dev, port->nr);\r\nbreak;\r\n}\r\nport->gate_ctrl = NULL;\r\nreturn 0;\r\n}
