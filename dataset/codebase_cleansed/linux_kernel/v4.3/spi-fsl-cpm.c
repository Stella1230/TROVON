void fsl_spi_cpm_reinit_txrx(struct mpc8xxx_spi *mspi)\r\n{\r\nif (mspi->flags & SPI_QE) {\r\nqe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,\r\nQE_CR_PROTOCOL_UNSPECIFIED, 0);\r\n} else {\r\nif (mspi->flags & SPI_CPM1) {\r\nout_be32(&mspi->pram->rstate, 0);\r\nout_be16(&mspi->pram->rbptr,\r\nin_be16(&mspi->pram->rbase));\r\nout_be32(&mspi->pram->tstate, 0);\r\nout_be16(&mspi->pram->tbptr,\r\nin_be16(&mspi->pram->tbase));\r\n} else {\r\ncpm_command(CPM_SPI_CMD, CPM_CR_INIT_TRX);\r\n}\r\n}\r\n}\r\nstatic void fsl_spi_cpm_bufs_start(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;\r\nstruct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;\r\nunsigned int xfer_len = min(mspi->count, SPI_MRBLR);\r\nunsigned int xfer_ofs;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nxfer_ofs = mspi->xfer_in_progress->len - mspi->count;\r\nif (mspi->rx_dma == mspi->dma_dummy_rx)\r\nout_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);\r\nelse\r\nout_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);\r\nout_be16(&rx_bd->cbd_datlen, 0);\r\nout_be16(&rx_bd->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT | BD_SC_WRAP);\r\nif (mspi->tx_dma == mspi->dma_dummy_tx)\r\nout_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);\r\nelse\r\nout_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);\r\nout_be16(&tx_bd->cbd_datlen, xfer_len);\r\nout_be16(&tx_bd->cbd_sc, BD_SC_READY | BD_SC_INTRPT | BD_SC_WRAP |\r\nBD_SC_LAST);\r\nmpc8xxx_spi_write_reg(&reg_base->command, SPCOM_STR);\r\n}\r\nint fsl_spi_cpm_bufs(struct mpc8xxx_spi *mspi,\r\nstruct spi_transfer *t, bool is_dma_mapped)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nif (is_dma_mapped) {\r\nmspi->map_tx_dma = 0;\r\nmspi->map_rx_dma = 0;\r\n} else {\r\nmspi->map_tx_dma = 1;\r\nmspi->map_rx_dma = 1;\r\n}\r\nif (!t->tx_buf) {\r\nmspi->tx_dma = mspi->dma_dummy_tx;\r\nmspi->map_tx_dma = 0;\r\n}\r\nif (!t->rx_buf) {\r\nmspi->rx_dma = mspi->dma_dummy_rx;\r\nmspi->map_rx_dma = 0;\r\n}\r\nif (mspi->map_tx_dma) {\r\nvoid *nonconst_tx = (void *)mspi->tx;\r\nmspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, mspi->tx_dma)) {\r\ndev_err(dev, "unable to map tx dma\n");\r\nreturn -ENOMEM;\r\n}\r\n} else if (t->tx_buf) {\r\nmspi->tx_dma = t->tx_dma;\r\n}\r\nif (mspi->map_rx_dma) {\r\nmspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, mspi->rx_dma)) {\r\ndev_err(dev, "unable to map rx dma\n");\r\ngoto err_rx_dma;\r\n}\r\n} else if (t->rx_buf) {\r\nmspi->rx_dma = t->rx_dma;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->mask, SPIE_RXB);\r\nmspi->xfer_in_progress = t;\r\nmspi->count = t->len;\r\nfsl_spi_cpm_bufs_start(mspi);\r\nreturn 0;\r\nerr_rx_dma:\r\nif (mspi->map_tx_dma)\r\ndma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nvoid fsl_spi_cpm_bufs_complete(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct spi_transfer *t = mspi->xfer_in_progress;\r\nif (mspi->map_tx_dma)\r\ndma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);\r\nif (mspi->map_rx_dma)\r\ndma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);\r\nmspi->xfer_in_progress = NULL;\r\n}\r\nvoid fsl_spi_cpm_irq(struct mpc8xxx_spi *mspi, u32 events)\r\n{\r\nu16 len;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\ndev_dbg(mspi->dev, "%s: bd datlen %d, count %d\n", __func__,\r\nin_be16(&mspi->rx_bd->cbd_datlen), mspi->count);\r\nlen = in_be16(&mspi->rx_bd->cbd_datlen);\r\nif (len > mspi->count) {\r\nWARN_ON(1);\r\nlen = mspi->count;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->event, events);\r\nmspi->count -= len;\r\nif (mspi->count)\r\nfsl_spi_cpm_bufs_start(mspi);\r\nelse\r\ncomplete(&mspi->done);\r\n}\r\nstatic void *fsl_spi_alloc_dummy_rx(void)\r\n{\r\nmutex_lock(&fsl_dummy_rx_lock);\r\nif (!fsl_dummy_rx)\r\nfsl_dummy_rx = kmalloc(SPI_MRBLR, GFP_KERNEL);\r\nif (fsl_dummy_rx)\r\nfsl_dummy_rx_refcnt++;\r\nmutex_unlock(&fsl_dummy_rx_lock);\r\nreturn fsl_dummy_rx;\r\n}\r\nstatic void fsl_spi_free_dummy_rx(void)\r\n{\r\nmutex_lock(&fsl_dummy_rx_lock);\r\nswitch (fsl_dummy_rx_refcnt) {\r\ncase 0:\r\nWARN_ON(1);\r\nbreak;\r\ncase 1:\r\nkfree(fsl_dummy_rx);\r\nfsl_dummy_rx = NULL;\r\ndefault:\r\nfsl_dummy_rx_refcnt--;\r\nbreak;\r\n}\r\nmutex_unlock(&fsl_dummy_rx_lock);\r\n}\r\nstatic unsigned long fsl_spi_cpm_get_pram(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst u32 *iprop;\r\nint size;\r\nvoid __iomem *spi_base;\r\nunsigned long pram_ofs = -ENOMEM;\r\niprop = of_get_property(np, "reg", &size);\r\nif (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)\r\nreturn cpm_muram_alloc_fixed(iprop[2], SPI_PRAM_SIZE);\r\nif (mspi->flags & SPI_QE) {\r\npram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\r\nqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,\r\nQE_CR_PROTOCOL_UNSPECIFIED, pram_ofs);\r\nreturn pram_ofs;\r\n}\r\nspi_base = of_iomap(np, 1);\r\nif (spi_base == NULL)\r\nreturn -EINVAL;\r\nif (mspi->flags & SPI_CPM2) {\r\npram_ofs = cpm_muram_alloc(SPI_PRAM_SIZE, 64);\r\nout_be16(spi_base, pram_ofs);\r\n}\r\niounmap(spi_base);\r\nreturn pram_ofs;\r\n}\r\nint fsl_spi_cpm_init(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst u32 *iprop;\r\nint size;\r\nunsigned long bds_ofs;\r\nif (!(mspi->flags & SPI_CPM_MODE))\r\nreturn 0;\r\nif (!fsl_spi_alloc_dummy_rx())\r\nreturn -ENOMEM;\r\nif (mspi->flags & SPI_QE) {\r\niprop = of_get_property(np, "cell-index", &size);\r\nif (iprop && size == sizeof(*iprop))\r\nmspi->subblock = *iprop;\r\nswitch (mspi->subblock) {\r\ndefault:\r\ndev_warn(dev, "cell-index unspecified, assuming SPI1\n");\r\ncase 0:\r\nmspi->subblock = QE_CR_SUBBLOCK_SPI1;\r\nbreak;\r\ncase 1:\r\nmspi->subblock = QE_CR_SUBBLOCK_SPI2;\r\nbreak;\r\n}\r\n}\r\nif (mspi->flags & SPI_CPM1) {\r\nstruct resource *res;\r\nvoid *pram;\r\nres = platform_get_resource(to_platform_device(dev),\r\nIORESOURCE_MEM, 1);\r\npram = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pram))\r\nmspi->pram = NULL;\r\nelse\r\nmspi->pram = pram;\r\n} else {\r\nunsigned long pram_ofs = fsl_spi_cpm_get_pram(mspi);\r\nif (IS_ERR_VALUE(pram_ofs))\r\nmspi->pram = NULL;\r\nelse\r\nmspi->pram = cpm_muram_addr(pram_ofs);\r\n}\r\nif (mspi->pram == NULL) {\r\ndev_err(dev, "can't allocate spi parameter ram\n");\r\ngoto err_pram;\r\n}\r\nbds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +\r\nsizeof(*mspi->rx_bd), 8);\r\nif (IS_ERR_VALUE(bds_ofs)) {\r\ndev_err(dev, "can't allocate bds\n");\r\ngoto err_bds;\r\n}\r\nmspi->dma_dummy_tx = dma_map_single(dev, empty_zero_page, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, mspi->dma_dummy_tx)) {\r\ndev_err(dev, "unable to map dummy tx buffer\n");\r\ngoto err_dummy_tx;\r\n}\r\nmspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, mspi->dma_dummy_rx)) {\r\ndev_err(dev, "unable to map dummy rx buffer\n");\r\ngoto err_dummy_rx;\r\n}\r\nmspi->tx_bd = cpm_muram_addr(bds_ofs);\r\nmspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));\r\nout_be16(&mspi->pram->tbase, cpm_muram_offset(mspi->tx_bd));\r\nout_be16(&mspi->pram->rbase, cpm_muram_offset(mspi->rx_bd));\r\nout_8(&mspi->pram->tfcr, CPMFCR_EB | CPMFCR_GBL);\r\nout_8(&mspi->pram->rfcr, CPMFCR_EB | CPMFCR_GBL);\r\nout_be16(&mspi->pram->mrblr, SPI_MRBLR);\r\nout_be32(&mspi->pram->rstate, 0);\r\nout_be32(&mspi->pram->rdp, 0);\r\nout_be16(&mspi->pram->rbptr, 0);\r\nout_be16(&mspi->pram->rbc, 0);\r\nout_be32(&mspi->pram->rxtmp, 0);\r\nout_be32(&mspi->pram->tstate, 0);\r\nout_be32(&mspi->pram->tdp, 0);\r\nout_be16(&mspi->pram->tbptr, 0);\r\nout_be16(&mspi->pram->tbc, 0);\r\nout_be32(&mspi->pram->txtmp, 0);\r\nreturn 0;\r\nerr_dummy_rx:\r\ndma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\r\nerr_dummy_tx:\r\ncpm_muram_free(bds_ofs);\r\nerr_bds:\r\nif (!(mspi->flags & SPI_CPM1))\r\ncpm_muram_free(cpm_muram_offset(mspi->pram));\r\nerr_pram:\r\nfsl_spi_free_dummy_rx();\r\nreturn -ENOMEM;\r\n}\r\nvoid fsl_spi_cpm_free(struct mpc8xxx_spi *mspi)\r\n{\r\nstruct device *dev = mspi->dev;\r\nif (!(mspi->flags & SPI_CPM_MODE))\r\nreturn;\r\ndma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);\r\ndma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);\r\ncpm_muram_free(cpm_muram_offset(mspi->tx_bd));\r\ncpm_muram_free(cpm_muram_offset(mspi->pram));\r\nfsl_spi_free_dummy_rx();\r\n}
