static inline struct channel_data* dev_to_chan(struct net_device *dev)\r\n{\r\nreturn (struct channel_data *)dev_to_hdlc(dev)->priv;\r\n}\r\nstatic int __init cosa_init(void)\r\n{\r\nint i, err = 0;\r\nif (cosa_major > 0) {\r\nif (register_chrdev(cosa_major, "cosa", &cosa_fops)) {\r\npr_warn("unable to get major %d\n", cosa_major);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n} else {\r\nif (!(cosa_major=register_chrdev(0, "cosa", &cosa_fops))) {\r\npr_warn("unable to register chardev\n");\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n}\r\nfor (i=0; i<MAX_CARDS; i++)\r\ncosa_cards[i].num = -1;\r\nfor (i=0; io[i] != 0 && i < MAX_CARDS; i++)\r\ncosa_probe(io[i], irq[i], dma[i]);\r\nif (!nr_cards) {\r\npr_warn("no devices found\n");\r\nunregister_chrdev(cosa_major, "cosa");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ncosa_class = class_create(THIS_MODULE, "cosa");\r\nif (IS_ERR(cosa_class)) {\r\nerr = PTR_ERR(cosa_class);\r\ngoto out_chrdev;\r\n}\r\nfor (i = 0; i < nr_cards; i++)\r\ndevice_create(cosa_class, NULL, MKDEV(cosa_major, i), NULL,\r\n"cosa%d", i);\r\nerr = 0;\r\ngoto out;\r\nout_chrdev:\r\nunregister_chrdev(cosa_major, "cosa");\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit cosa_exit(void)\r\n{\r\nstruct cosa_data *cosa;\r\nint i;\r\nfor (i = 0; i < nr_cards; i++)\r\ndevice_destroy(cosa_class, MKDEV(cosa_major, i));\r\nclass_destroy(cosa_class);\r\nfor (cosa = cosa_cards; nr_cards--; cosa++) {\r\nfor (i = 0; i < cosa->nchannels; i++) {\r\nunregister_hdlc_device(cosa->chan[i].netdev);\r\nfree_netdev(cosa->chan[i].netdev);\r\n}\r\nkfree(cosa->chan);\r\nkfree(cosa->bouncebuf);\r\nfree_irq(cosa->irq, cosa);\r\nfree_dma(cosa->dma);\r\nrelease_region(cosa->datareg, is_8bit(cosa) ? 2 : 4);\r\n}\r\nunregister_chrdev(cosa_major, "cosa");\r\n}\r\nstatic int cosa_probe(int base, int irq, int dma)\r\n{\r\nstruct cosa_data *cosa = cosa_cards+nr_cards;\r\nint i, err = 0;\r\nmemset(cosa, 0, sizeof(struct cosa_data));\r\nif ((irq >= 0 && irq < 2) || irq > 15 || (irq < 10 && irq > 7)) {\r\npr_info("invalid IRQ %d\n", irq);\r\nreturn -1;\r\n}\r\nif (base < 0x100 || base > 0x3ff || base & 0x7) {\r\npr_info("invalid I/O address 0x%x\n", base);\r\nreturn -1;\r\n}\r\nif (dma < 0 || dma == 4 || dma > 7) {\r\npr_info("invalid DMA %d\n", dma);\r\nreturn -1;\r\n}\r\nif (((base & 0x8) && dma < 4) || (!(base & 0x8) && dma > 3)) {\r\npr_info("8/16 bit base and DMA mismatch (base=0x%x, dma=%d)\n",\r\nbase, dma);\r\nreturn -1;\r\n}\r\ncosa->dma = dma;\r\ncosa->datareg = base;\r\ncosa->statusreg = is_8bit(cosa)?base+1:base+2;\r\nspin_lock_init(&cosa->lock);\r\nif (!request_region(base, is_8bit(cosa)?2:4,"cosa"))\r\nreturn -1;\r\nif (cosa_reset_and_read_id(cosa, cosa->id_string) < 0) {\r\nprintk(KERN_DEBUG "probe at 0x%x failed.\n", base);\r\nerr = -1;\r\ngoto err_out;\r\n}\r\nif (!strncmp(cosa->id_string, "SRP", 3))\r\ncosa->type = "srp";\r\nelse if (!strncmp(cosa->id_string, "COSA", 4))\r\ncosa->type = is_8bit(cosa)? "cosa8": "cosa16";\r\nelse {\r\n#ifndef COSA_ISA_AUTOPROBE\r\npr_info("valid signature not found at 0x%x\n", base);\r\n#endif\r\nerr = -1;\r\ngoto err_out;\r\n}\r\nrelease_region(base, is_8bit(cosa)?2:4);\r\nif (!request_region(base, is_8bit(cosa)?2:4, cosa->type)) {\r\nprintk(KERN_DEBUG "changing name at 0x%x failed.\n", base);\r\nreturn -1;\r\n}\r\nif (irq < 0) {\r\nunsigned long irqs;\r\nirqs = probe_irq_on();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ncosa_putstatus(cosa, SR_TX_INT_ENA);\r\nschedule_timeout(msecs_to_jiffies(300));\r\nirq = probe_irq_off(irqs);\r\ncosa_putstatus(cosa, 0);\r\ncosa_getdata8(cosa);\r\nif (irq < 0) {\r\npr_info("multiple interrupts obtained (%d, board at 0x%x)\n",\r\nirq, cosa->datareg);\r\nerr = -1;\r\ngoto err_out;\r\n}\r\nif (irq == 0) {\r\npr_info("no interrupt obtained (board at 0x%x)\n",\r\ncosa->datareg);\r\n}\r\n}\r\ncosa->irq = irq;\r\ncosa->num = nr_cards;\r\ncosa->usage = 0;\r\ncosa->nchannels = 2;\r\nif (request_irq(cosa->irq, cosa_interrupt, 0, cosa->type, cosa)) {\r\nerr = -1;\r\ngoto err_out;\r\n}\r\nif (request_dma(cosa->dma, cosa->type)) {\r\nerr = -1;\r\ngoto err_out1;\r\n}\r\ncosa->bouncebuf = kmalloc(COSA_MTU, GFP_KERNEL|GFP_DMA);\r\nif (!cosa->bouncebuf) {\r\nerr = -ENOMEM;\r\ngoto err_out2;\r\n}\r\nsprintf(cosa->name, "cosa%d", cosa->num);\r\ncosa->chan = kcalloc(cosa->nchannels, sizeof(struct channel_data), GFP_KERNEL);\r\nif (!cosa->chan) {\r\nerr = -ENOMEM;\r\ngoto err_out3;\r\n}\r\nfor (i = 0; i < cosa->nchannels; i++) {\r\nstruct channel_data *chan = &cosa->chan[i];\r\nchan->cosa = cosa;\r\nchan->num = i;\r\nsprintf(chan->name, "cosa%dc%d", chan->cosa->num, i);\r\nmutex_init(&chan->rlock);\r\nsema_init(&chan->wsem, 1);\r\nif (!(chan->netdev = alloc_hdlcdev(chan))) {\r\npr_warn("%s: alloc_hdlcdev failed\n", chan->name);\r\nerr = -ENOMEM;\r\ngoto err_hdlcdev;\r\n}\r\ndev_to_hdlc(chan->netdev)->attach = cosa_net_attach;\r\ndev_to_hdlc(chan->netdev)->xmit = cosa_net_tx;\r\nchan->netdev->netdev_ops = &cosa_ops;\r\nchan->netdev->watchdog_timeo = TX_TIMEOUT;\r\nchan->netdev->base_addr = chan->cosa->datareg;\r\nchan->netdev->irq = chan->cosa->irq;\r\nchan->netdev->dma = chan->cosa->dma;\r\nerr = register_hdlc_device(chan->netdev);\r\nif (err) {\r\nnetdev_warn(chan->netdev,\r\n"register_hdlc_device() failed\n");\r\nfree_netdev(chan->netdev);\r\ngoto err_hdlcdev;\r\n}\r\n}\r\npr_info("cosa%d: %s (%s at 0x%x irq %d dma %d), %d channels\n",\r\ncosa->num, cosa->id_string, cosa->type,\r\ncosa->datareg, cosa->irq, cosa->dma, cosa->nchannels);\r\nreturn nr_cards++;\r\nerr_hdlcdev:\r\nwhile (i-- > 0) {\r\nunregister_hdlc_device(cosa->chan[i].netdev);\r\nfree_netdev(cosa->chan[i].netdev);\r\n}\r\nkfree(cosa->chan);\r\nerr_out3:\r\nkfree(cosa->bouncebuf);\r\nerr_out2:\r\nfree_dma(cosa->dma);\r\nerr_out1:\r\nfree_irq(cosa->irq, cosa);\r\nerr_out:\r\nrelease_region(cosa->datareg,is_8bit(cosa)?2:4);\r\npr_notice("cosa%d: allocating resources failed\n", cosa->num);\r\nreturn err;\r\n}\r\nstatic int cosa_net_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nif (encoding == ENCODING_NRZ && parity == PARITY_CRC16_PR1_CCITT)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int cosa_net_open(struct net_device *dev)\r\n{\r\nstruct channel_data *chan = dev_to_chan(dev);\r\nint err;\r\nunsigned long flags;\r\nif (!(chan->cosa->firmware_status & COSA_FW_START)) {\r\npr_notice("%s: start the firmware first (status %d)\n",\r\nchan->cosa->name, chan->cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\nspin_lock_irqsave(&chan->cosa->lock, flags);\r\nif (chan->usage != 0) {\r\npr_warn("%s: cosa_net_open called with usage count %d\n",\r\nchan->name, chan->usage);\r\nspin_unlock_irqrestore(&chan->cosa->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nchan->setup_rx = cosa_net_setup_rx;\r\nchan->tx_done = cosa_net_tx_done;\r\nchan->rx_done = cosa_net_rx_done;\r\nchan->usage = -1;\r\nchan->cosa->usage++;\r\nspin_unlock_irqrestore(&chan->cosa->lock, flags);\r\nerr = hdlc_open(dev);\r\nif (err) {\r\nspin_lock_irqsave(&chan->cosa->lock, flags);\r\nchan->usage = 0;\r\nchan->cosa->usage--;\r\nspin_unlock_irqrestore(&chan->cosa->lock, flags);\r\nreturn err;\r\n}\r\nnetif_start_queue(dev);\r\ncosa_enable_rx(chan);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t cosa_net_tx(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct channel_data *chan = dev_to_chan(dev);\r\nnetif_stop_queue(dev);\r\nchan->tx_skb = skb;\r\ncosa_start_tx(chan, skb->data, skb->len);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void cosa_net_timeout(struct net_device *dev)\r\n{\r\nstruct channel_data *chan = dev_to_chan(dev);\r\nif (test_bit(RXBIT, &chan->cosa->rxtx)) {\r\nchan->netdev->stats.rx_errors++;\r\nchan->netdev->stats.rx_missed_errors++;\r\n} else {\r\nchan->netdev->stats.tx_errors++;\r\nchan->netdev->stats.tx_aborted_errors++;\r\n}\r\ncosa_kick(chan->cosa);\r\nif (chan->tx_skb) {\r\ndev_kfree_skb(chan->tx_skb);\r\nchan->tx_skb = NULL;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int cosa_net_close(struct net_device *dev)\r\n{\r\nstruct channel_data *chan = dev_to_chan(dev);\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nhdlc_close(dev);\r\ncosa_disable_rx(chan);\r\nspin_lock_irqsave(&chan->cosa->lock, flags);\r\nif (chan->rx_skb) {\r\nkfree_skb(chan->rx_skb);\r\nchan->rx_skb = NULL;\r\n}\r\nif (chan->tx_skb) {\r\nkfree_skb(chan->tx_skb);\r\nchan->tx_skb = NULL;\r\n}\r\nchan->usage = 0;\r\nchan->cosa->usage--;\r\nspin_unlock_irqrestore(&chan->cosa->lock, flags);\r\nreturn 0;\r\n}\r\nstatic char *cosa_net_setup_rx(struct channel_data *chan, int size)\r\n{\r\nkfree_skb(chan->rx_skb);\r\nchan->rx_skb = dev_alloc_skb(size);\r\nif (chan->rx_skb == NULL) {\r\npr_notice("%s: Memory squeeze, dropping packet\n", chan->name);\r\nchan->netdev->stats.rx_dropped++;\r\nreturn NULL;\r\n}\r\nchan->netdev->trans_start = jiffies;\r\nreturn skb_put(chan->rx_skb, size);\r\n}\r\nstatic int cosa_net_rx_done(struct channel_data *chan)\r\n{\r\nif (!chan->rx_skb) {\r\npr_warn("%s: rx_done with empty skb!\n", chan->name);\r\nchan->netdev->stats.rx_errors++;\r\nchan->netdev->stats.rx_frame_errors++;\r\nreturn 0;\r\n}\r\nchan->rx_skb->protocol = hdlc_type_trans(chan->rx_skb, chan->netdev);\r\nchan->rx_skb->dev = chan->netdev;\r\nskb_reset_mac_header(chan->rx_skb);\r\nchan->netdev->stats.rx_packets++;\r\nchan->netdev->stats.rx_bytes += chan->cosa->rxsize;\r\nnetif_rx(chan->rx_skb);\r\nchan->rx_skb = NULL;\r\nreturn 0;\r\n}\r\nstatic int cosa_net_tx_done(struct channel_data *chan, int size)\r\n{\r\nif (!chan->tx_skb) {\r\npr_warn("%s: tx_done with empty skb!\n", chan->name);\r\nchan->netdev->stats.tx_errors++;\r\nchan->netdev->stats.tx_aborted_errors++;\r\nreturn 1;\r\n}\r\ndev_kfree_skb_irq(chan->tx_skb);\r\nchan->tx_skb = NULL;\r\nchan->netdev->stats.tx_packets++;\r\nchan->netdev->stats.tx_bytes += size;\r\nnetif_wake_queue(chan->netdev);\r\nreturn 1;\r\n}\r\nstatic ssize_t cosa_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *ppos)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nstruct channel_data *chan = file->private_data;\r\nstruct cosa_data *cosa = chan->cosa;\r\nchar *kbuf;\r\nif (!(cosa->firmware_status & COSA_FW_START)) {\r\npr_notice("%s: start the firmware first (status %d)\n",\r\ncosa->name, cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\nif (mutex_lock_interruptible(&chan->rlock))\r\nreturn -ERESTARTSYS;\r\nchan->rxdata = kmalloc(COSA_MTU, GFP_DMA|GFP_KERNEL);\r\nif (chan->rxdata == NULL) {\r\nmutex_unlock(&chan->rlock);\r\nreturn -ENOMEM;\r\n}\r\nchan->rx_status = 0;\r\ncosa_enable_rx(chan);\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nadd_wait_queue(&chan->rxwaitq, &wait);\r\nwhile (!chan->rx_status) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nif (signal_pending(current) && chan->rx_status == 0) {\r\nchan->rx_status = 1;\r\nremove_wait_queue(&chan->rxwaitq, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nmutex_unlock(&chan->rlock);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nremove_wait_queue(&chan->rxwaitq, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nkbuf = chan->rxdata;\r\ncount = chan->rxsize;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nmutex_unlock(&chan->rlock);\r\nif (copy_to_user(buf, kbuf, count)) {\r\nkfree(kbuf);\r\nreturn -EFAULT;\r\n}\r\nkfree(kbuf);\r\nreturn count;\r\n}\r\nstatic char *chrdev_setup_rx(struct channel_data *chan, int size)\r\n{\r\nchan->rxsize = size;\r\nreturn chan->rxdata;\r\n}\r\nstatic int chrdev_rx_done(struct channel_data *chan)\r\n{\r\nif (chan->rx_status) {\r\nkfree(chan->rxdata);\r\nup(&chan->wsem);\r\n}\r\nchan->rx_status = 1;\r\nwake_up_interruptible(&chan->rxwaitq);\r\nreturn 1;\r\n}\r\nstatic ssize_t cosa_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct channel_data *chan = file->private_data;\r\nstruct cosa_data *cosa = chan->cosa;\r\nunsigned long flags;\r\nchar *kbuf;\r\nif (!(cosa->firmware_status & COSA_FW_START)) {\r\npr_notice("%s: start the firmware first (status %d)\n",\r\ncosa->name, cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\nif (down_interruptible(&chan->wsem))\r\nreturn -ERESTARTSYS;\r\nif (count > COSA_MTU)\r\ncount = COSA_MTU;\r\nkbuf = kmalloc(count, GFP_KERNEL|GFP_DMA);\r\nif (kbuf == NULL) {\r\nup(&chan->wsem);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(kbuf, buf, count)) {\r\nup(&chan->wsem);\r\nkfree(kbuf);\r\nreturn -EFAULT;\r\n}\r\nchan->tx_status=0;\r\ncosa_start_tx(chan, kbuf, count);\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nadd_wait_queue(&chan->txwaitq, &wait);\r\nwhile (!chan->tx_status) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nif (signal_pending(current) && chan->tx_status == 0) {\r\nchan->tx_status = 1;\r\nremove_wait_queue(&chan->txwaitq, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nchan->tx_status = 1;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nup(&chan->wsem);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nremove_wait_queue(&chan->txwaitq, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nup(&chan->wsem);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nkfree(kbuf);\r\nreturn count;\r\n}\r\nstatic int chrdev_tx_done(struct channel_data *chan, int size)\r\n{\r\nif (chan->tx_status) {\r\nkfree(chan->txbuf);\r\nup(&chan->wsem);\r\n}\r\nchan->tx_status = 1;\r\nwake_up_interruptible(&chan->txwaitq);\r\nreturn 1;\r\n}\r\nstatic unsigned int cosa_poll(struct file *file, poll_table *poll)\r\n{\r\npr_info("cosa_poll is here\n");\r\nreturn 0;\r\n}\r\nstatic int cosa_open(struct inode *inode, struct file *file)\r\n{\r\nstruct cosa_data *cosa;\r\nstruct channel_data *chan;\r\nunsigned long flags;\r\nint n;\r\nint ret = 0;\r\nmutex_lock(&cosa_chardev_mutex);\r\nif ((n=iminor(file_inode(file))>>CARD_MINOR_BITS)\r\n>= nr_cards) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ncosa = cosa_cards+n;\r\nif ((n=iminor(file_inode(file))\r\n& ((1<<CARD_MINOR_BITS)-1)) >= cosa->nchannels) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nchan = cosa->chan + n;\r\nfile->private_data = chan;\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nif (chan->usage < 0) {\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncosa->usage++;\r\nchan->usage++;\r\nchan->tx_done = chrdev_tx_done;\r\nchan->setup_rx = chrdev_setup_rx;\r\nchan->rx_done = chrdev_rx_done;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nout:\r\nmutex_unlock(&cosa_chardev_mutex);\r\nreturn ret;\r\n}\r\nstatic int cosa_release(struct inode *inode, struct file *file)\r\n{\r\nstruct channel_data *channel = file->private_data;\r\nstruct cosa_data *cosa;\r\nunsigned long flags;\r\ncosa = channel->cosa;\r\nspin_lock_irqsave(&cosa->lock, flags);\r\ncosa->usage--;\r\nchannel->usage--;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cosa_fasync(struct inode *inode, struct file *file, int on)\r\n{\r\nint port = iminor(inode);\r\nreturn fasync_helper(inode, file, on, &fasync[port]);\r\n}\r\nstatic inline int cosa_reset(struct cosa_data *cosa)\r\n{\r\nchar idstring[COSA_MAX_ID_STRING];\r\nif (cosa->usage > 1)\r\npr_info("cosa%d: WARNING: reset requested with cosa->usage > 1 (%d). Odd things may happen.\n",\r\ncosa->num, cosa->usage);\r\ncosa->firmware_status &= ~(COSA_FW_RESET|COSA_FW_START);\r\nif (cosa_reset_and_read_id(cosa, idstring) < 0) {\r\npr_notice("cosa%d: reset failed\n", cosa->num);\r\nreturn -EIO;\r\n}\r\npr_info("cosa%d: resetting device: %s\n", cosa->num, idstring);\r\ncosa->firmware_status |= COSA_FW_RESET;\r\nreturn 0;\r\n}\r\nstatic inline int cosa_download(struct cosa_data *cosa, void __user *arg)\r\n{\r\nstruct cosa_download d;\r\nint i;\r\nif (cosa->usage > 1)\r\npr_info("%s: WARNING: download of microcode requested with cosa->usage > 1 (%d). Odd things may happen.\n",\r\ncosa->name, cosa->usage);\r\nif (!(cosa->firmware_status & COSA_FW_RESET)) {\r\npr_notice("%s: reset the card first (status %d)\n",\r\ncosa->name, cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\nif (copy_from_user(&d, arg, sizeof(d)))\r\nreturn -EFAULT;\r\nif (d.addr < 0 || d.addr > COSA_MAX_FIRMWARE_SIZE)\r\nreturn -EINVAL;\r\nif (d.len < 0 || d.len > COSA_MAX_FIRMWARE_SIZE)\r\nreturn -EINVAL;\r\ncosa->firmware_status &= ~(COSA_FW_RESET|COSA_FW_DOWNLOAD);\r\ni = download(cosa, d.code, d.len, d.addr);\r\nif (i < 0) {\r\npr_notice("cosa%d: microcode download failed: %d\n",\r\ncosa->num, i);\r\nreturn -EIO;\r\n}\r\npr_info("cosa%d: downloading microcode - 0x%04x bytes at 0x%04x\n",\r\ncosa->num, d.len, d.addr);\r\ncosa->firmware_status |= COSA_FW_RESET|COSA_FW_DOWNLOAD;\r\nreturn 0;\r\n}\r\nstatic inline int cosa_readmem(struct cosa_data *cosa, void __user *arg)\r\n{\r\nstruct cosa_download d;\r\nint i;\r\nif (cosa->usage > 1)\r\npr_info("cosa%d: WARNING: readmem requested with cosa->usage > 1 (%d). Odd things may happen.\n",\r\ncosa->num, cosa->usage);\r\nif (!(cosa->firmware_status & COSA_FW_RESET)) {\r\npr_notice("%s: reset the card first (status %d)\n",\r\ncosa->name, cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\nif (copy_from_user(&d, arg, sizeof(d)))\r\nreturn -EFAULT;\r\ncosa->firmware_status &= ~COSA_FW_RESET;\r\ni = readmem(cosa, d.code, d.len, d.addr);\r\nif (i < 0) {\r\npr_notice("cosa%d: reading memory failed: %d\n", cosa->num, i);\r\nreturn -EIO;\r\n}\r\npr_info("cosa%d: reading card memory - 0x%04x bytes at 0x%04x\n",\r\ncosa->num, d.len, d.addr);\r\ncosa->firmware_status |= COSA_FW_RESET;\r\nreturn 0;\r\n}\r\nstatic inline int cosa_start(struct cosa_data *cosa, int address)\r\n{\r\nint i;\r\nif (cosa->usage > 1)\r\npr_info("cosa%d: WARNING: start microcode requested with cosa->usage > 1 (%d). Odd things may happen.\n",\r\ncosa->num, cosa->usage);\r\nif ((cosa->firmware_status & (COSA_FW_RESET|COSA_FW_DOWNLOAD))\r\n!= (COSA_FW_RESET|COSA_FW_DOWNLOAD)) {\r\npr_notice("%s: download the microcode and/or reset the card first (status %d)\n",\r\ncosa->name, cosa->firmware_status);\r\nreturn -EPERM;\r\n}\r\ncosa->firmware_status &= ~COSA_FW_RESET;\r\nif ((i=startmicrocode(cosa, address)) < 0) {\r\npr_notice("cosa%d: start microcode at 0x%04x failed: %d\n",\r\ncosa->num, address, i);\r\nreturn -EIO;\r\n}\r\npr_info("cosa%d: starting microcode at 0x%04x\n", cosa->num, address);\r\ncosa->startaddr = address;\r\ncosa->firmware_status |= COSA_FW_START;\r\nreturn 0;\r\n}\r\nstatic inline int cosa_getidstr(struct cosa_data *cosa, char __user *string)\r\n{\r\nint l = strlen(cosa->id_string)+1;\r\nif (copy_to_user(string, cosa->id_string, l))\r\nreturn -EFAULT;\r\nreturn l;\r\n}\r\nstatic inline int cosa_gettype(struct cosa_data *cosa, char __user *string)\r\n{\r\nint l = strlen(cosa->type)+1;\r\nif (copy_to_user(string, cosa->type, l))\r\nreturn -EFAULT;\r\nreturn l;\r\n}\r\nstatic int cosa_ioctl_common(struct cosa_data *cosa,\r\nstruct channel_data *channel, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase COSAIORSET:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nreturn cosa_reset(cosa);\r\ncase COSAIOSTRT:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn cosa_start(cosa, arg);\r\ncase COSAIODOWNLD:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn cosa_download(cosa, argp);\r\ncase COSAIORMEM:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn cosa_readmem(cosa, argp);\r\ncase COSAIORTYPE:\r\nreturn cosa_gettype(cosa, argp);\r\ncase COSAIORIDSTR:\r\nreturn cosa_getidstr(cosa, argp);\r\ncase COSAIONRCARDS:\r\nreturn nr_cards;\r\ncase COSAIONRCHANS:\r\nreturn cosa->nchannels;\r\ncase COSAIOBMSET:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nif (is_8bit(cosa))\r\nreturn -EINVAL;\r\nif (arg != COSA_BM_OFF && arg != COSA_BM_ON)\r\nreturn -EINVAL;\r\ncosa->busmaster = arg;\r\nreturn 0;\r\ncase COSAIOBMGET:\r\nreturn cosa->busmaster;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int cosa_net_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint rv;\r\nstruct channel_data *chan = dev_to_chan(dev);\r\nrv = cosa_ioctl_common(chan->cosa, chan, cmd,\r\n(unsigned long)ifr->ifr_data);\r\nif (rv != -ENOIOCTLCMD)\r\nreturn rv;\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\nstatic long cosa_chardev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct channel_data *channel = file->private_data;\r\nstruct cosa_data *cosa;\r\nlong ret;\r\nmutex_lock(&cosa_chardev_mutex);\r\ncosa = channel->cosa;\r\nret = cosa_ioctl_common(cosa, channel, cmd, arg);\r\nmutex_unlock(&cosa_chardev_mutex);\r\nreturn ret;\r\n}\r\nstatic void cosa_enable_rx(struct channel_data *chan)\r\n{\r\nstruct cosa_data *cosa = chan->cosa;\r\nif (!test_and_set_bit(chan->num, &cosa->rxbitmap))\r\nput_driver_status(cosa);\r\n}\r\nstatic void cosa_disable_rx(struct channel_data *chan)\r\n{\r\nstruct cosa_data *cosa = chan->cosa;\r\nif (test_and_clear_bit(chan->num, &cosa->rxbitmap))\r\nput_driver_status(cosa);\r\n}\r\nstatic int cosa_start_tx(struct channel_data *chan, char *buf, int len)\r\n{\r\nstruct cosa_data *cosa = chan->cosa;\r\nunsigned long flags;\r\n#ifdef DEBUG_DATA\r\nint i;\r\npr_info("cosa%dc%d: starting tx(0x%x)",\r\nchan->cosa->num, chan->num, len);\r\nfor (i=0; i<len; i++)\r\npr_cont(" %02x", buf[i]&0xff);\r\npr_cont("\n");\r\n#endif\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nchan->txbuf = buf;\r\nchan->txsize = len;\r\nif (len > COSA_MTU)\r\nchan->txsize = COSA_MTU;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nset_bit(chan->num, &cosa->txbitmap);\r\nput_driver_status(cosa);\r\nreturn 0;\r\n}\r\nstatic void put_driver_status(struct cosa_data *cosa)\r\n{\r\nunsigned long flags;\r\nint status;\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nstatus = (cosa->rxbitmap ? DRIVER_RX_READY : 0)\r\n| (cosa->txbitmap ? DRIVER_TX_READY : 0)\r\n| (cosa->txbitmap? ~(cosa->txbitmap<<DRIVER_TXMAP_SHIFT)\r\n&DRIVER_TXMAP_MASK : 0);\r\nif (!cosa->rxtx) {\r\nif (cosa->rxbitmap|cosa->txbitmap) {\r\nif (!cosa->enabled) {\r\ncosa_putstatus(cosa, SR_RX_INT_ENA);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_RX_INT_ENA);\r\n#endif\r\ncosa->enabled = 1;\r\n}\r\n} else if (cosa->enabled) {\r\ncosa->enabled = 0;\r\ncosa_putstatus(cosa, 0);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, 0);\r\n#endif\r\n}\r\ncosa_putdata8(cosa, status);\r\n#ifdef DEBUG_IO\r\ndebug_data_cmd(cosa, status);\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\n}\r\nstatic void put_driver_status_nolock(struct cosa_data *cosa)\r\n{\r\nint status;\r\nstatus = (cosa->rxbitmap ? DRIVER_RX_READY : 0)\r\n| (cosa->txbitmap ? DRIVER_TX_READY : 0)\r\n| (cosa->txbitmap? ~(cosa->txbitmap<<DRIVER_TXMAP_SHIFT)\r\n&DRIVER_TXMAP_MASK : 0);\r\nif (cosa->rxbitmap|cosa->txbitmap) {\r\ncosa_putstatus(cosa, SR_RX_INT_ENA);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_RX_INT_ENA);\r\n#endif\r\ncosa->enabled = 1;\r\n} else {\r\ncosa_putstatus(cosa, 0);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, 0);\r\n#endif\r\ncosa->enabled = 0;\r\n}\r\ncosa_putdata8(cosa, status);\r\n#ifdef DEBUG_IO\r\ndebug_data_cmd(cosa, status);\r\n#endif\r\n}\r\nstatic void cosa_kick(struct cosa_data *cosa)\r\n{\r\nunsigned long flags, flags1;\r\nchar *s = "(probably) IRQ";\r\nif (test_bit(RXBIT, &cosa->rxtx))\r\ns = "RX DMA";\r\nif (test_bit(TXBIT, &cosa->rxtx))\r\ns = "TX DMA";\r\npr_info("%s: %s timeout - restarting\n", cosa->name, s);\r\nspin_lock_irqsave(&cosa->lock, flags);\r\ncosa->rxtx = 0;\r\nflags1 = claim_dma_lock();\r\ndisable_dma(cosa->dma);\r\nclear_dma_ff(cosa->dma);\r\nrelease_dma_lock(flags1);\r\nudelay(100);\r\ncosa_putstatus(cosa, 0);\r\nudelay(100);\r\n(void) cosa_getdata8(cosa);\r\nudelay(100);\r\ncosa_putdata8(cosa, 0);\r\nudelay(100);\r\nput_driver_status_nolock(cosa);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\n}\r\nstatic int cosa_dma_able(struct channel_data *chan, char *buf, int len)\r\n{\r\nstatic int count;\r\nunsigned long b = (unsigned long)buf;\r\nif (b+len >= MAX_DMA_ADDRESS)\r\nreturn 0;\r\nif ((b^ (b+len)) & 0x10000) {\r\nif (count++ < 5)\r\npr_info("%s: packet spanning a 64k boundary\n",\r\nchan->name);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int download(struct cosa_data *cosa, const char __user *microcode, int length, int address)\r\n{\r\nint i;\r\nif (put_wait_data(cosa, 'w') == -1) return -1;\r\nif ((i=get_wait_data(cosa)) != 'w') { printk("dnld: 0x%04x\n",i); return -2;}\r\nif (get_wait_data(cosa) != '=') return -3;\r\nif (puthexnumber(cosa, address) < 0) return -4;\r\nif (put_wait_data(cosa, ' ') == -1) return -10;\r\nif (get_wait_data(cosa) != ' ') return -11;\r\nif (get_wait_data(cosa) != '=') return -12;\r\nif (puthexnumber(cosa, address+length-1) < 0) return -13;\r\nif (put_wait_data(cosa, ' ') == -1) return -18;\r\nif (get_wait_data(cosa) != ' ') return -19;\r\nwhile (length--) {\r\nchar c;\r\n#ifndef SRP_DOWNLOAD_AT_BOOT\r\nif (get_user(c, microcode))\r\nreturn -23;\r\n#else\r\nc = *microcode;\r\n#endif\r\nif (put_wait_data(cosa, c) == -1)\r\nreturn -20;\r\nmicrocode++;\r\n}\r\nif (get_wait_data(cosa) != '\r') return -21;\r\nif (get_wait_data(cosa) != '\n') return -22;\r\nif (get_wait_data(cosa) != '.') return -23;\r\n#if 0\r\nprintk(KERN_DEBUG "cosa%d: download completed.\n", cosa->num);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int startmicrocode(struct cosa_data *cosa, int address)\r\n{\r\nif (put_wait_data(cosa, 'g') == -1) return -1;\r\nif (get_wait_data(cosa) != 'g') return -2;\r\nif (get_wait_data(cosa) != '=') return -3;\r\nif (puthexnumber(cosa, address) < 0) return -4;\r\nif (put_wait_data(cosa, '\r') == -1) return -5;\r\nif (get_wait_data(cosa) != '\r') return -6;\r\nif (get_wait_data(cosa) != '\r') return -7;\r\nif (get_wait_data(cosa) != '\n') return -8;\r\nif (get_wait_data(cosa) != '\r') return -9;\r\nif (get_wait_data(cosa) != '\n') return -10;\r\n#if 0\r\nprintk(KERN_DEBUG "cosa%d: microcode started\n", cosa->num);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int readmem(struct cosa_data *cosa, char __user *microcode, int length, int address)\r\n{\r\nif (put_wait_data(cosa, 'r') == -1) return -1;\r\nif ((get_wait_data(cosa)) != 'r') return -2;\r\nif ((get_wait_data(cosa)) != '=') return -3;\r\nif (puthexnumber(cosa, address) < 0) return -4;\r\nif (put_wait_data(cosa, ' ') == -1) return -5;\r\nif (get_wait_data(cosa) != ' ') return -6;\r\nif (get_wait_data(cosa) != '=') return -7;\r\nif (puthexnumber(cosa, address+length-1) < 0) return -8;\r\nif (put_wait_data(cosa, ' ') == -1) return -9;\r\nif (get_wait_data(cosa) != ' ') return -10;\r\nwhile (length--) {\r\nchar c;\r\nint i;\r\nif ((i=get_wait_data(cosa)) == -1) {\r\npr_info("0x%04x bytes remaining\n", length);\r\nreturn -11;\r\n}\r\nc=i;\r\n#if 1\r\nif (put_user(c, microcode))\r\nreturn -23;\r\n#else\r\n*microcode = c;\r\n#endif\r\nmicrocode++;\r\n}\r\nif (get_wait_data(cosa) != '\r') return -21;\r\nif (get_wait_data(cosa) != '\n') return -22;\r\nif (get_wait_data(cosa) != '.') return -23;\r\n#if 0\r\nprintk(KERN_DEBUG "cosa%d: readmem completed.\n", cosa->num);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cosa_reset_and_read_id(struct cosa_data *cosa, char *idstring)\r\n{\r\nint i=0, id=0, prev=0, curr=0;\r\ncosa_putstatus(cosa, 0);\r\ncosa_getdata8(cosa);\r\ncosa_putstatus(cosa, SR_RST);\r\nmsleep(500);\r\ncosa_putstatus(cosa, 0);\r\nfor (i=0; i<COSA_MAX_ID_STRING-1; i++, prev=curr) {\r\nif ((curr = get_wait_data(cosa)) == -1) {\r\nreturn -1;\r\n}\r\ncurr &= 0xff;\r\nif (curr != '\r' && curr != '\n' && curr != 0x2e)\r\nidstring[id++] = curr;\r\nif (curr == 0x2e && prev == '\n')\r\nbreak;\r\n}\r\nidstring[id] = '\0';\r\nreturn id;\r\n}\r\nstatic int get_wait_data(struct cosa_data *cosa)\r\n{\r\nint retries = 1000;\r\nwhile (--retries) {\r\nif (cosa_getstatus(cosa) & SR_RX_RDY) {\r\nshort r;\r\nr = cosa_getdata8(cosa);\r\n#if 0\r\npr_info("get_wait_data returning after %d retries\n",\r\n999-retries);\r\n#endif\r\nreturn r;\r\n}\r\nschedule_timeout_interruptible(1);\r\n}\r\npr_info("timeout in get_wait_data (status 0x%x)\n",\r\ncosa_getstatus(cosa));\r\nreturn -1;\r\n}\r\nstatic int put_wait_data(struct cosa_data *cosa, int data)\r\n{\r\nint retries = 1000;\r\nwhile (--retries) {\r\nif (cosa_getstatus(cosa) & SR_TX_RDY) {\r\ncosa_putdata8(cosa, data);\r\n#if 0\r\npr_info("Putdata: %d retries\n", 999-retries);\r\n#endif\r\nreturn 0;\r\n}\r\n#if 0\r\nschedule_timeout_interruptible(1);\r\n#endif\r\n}\r\npr_info("cosa%d: timeout in put_wait_data (status 0x%x)\n",\r\ncosa->num, cosa_getstatus(cosa));\r\nreturn -1;\r\n}\r\nstatic int puthexnumber(struct cosa_data *cosa, int number)\r\n{\r\nchar temp[5];\r\nint i;\r\nsprintf(temp, "%04X", number);\r\nfor (i=0; i<4; i++) {\r\nif (put_wait_data(cosa, temp[i]) == -1) {\r\npr_notice("cosa%d: puthexnumber failed to write byte %d\n",\r\ncosa->num, i);\r\nreturn -1-2*i;\r\n}\r\nif (get_wait_data(cosa) != temp[i]) {\r\npr_notice("cosa%d: puthexhumber failed to read echo of byte %d\n",\r\ncosa->num, i);\r\nreturn -2-2*i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void tx_interrupt(struct cosa_data *cosa, int status)\r\n{\r\nunsigned long flags, flags1;\r\n#ifdef DEBUG_IRQS\r\npr_info("cosa%d: SR_DOWN_REQUEST status=0x%04x\n", cosa->num, status);\r\n#endif\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nset_bit(TXBIT, &cosa->rxtx);\r\nif (!test_bit(IRQBIT, &cosa->rxtx)) {\r\nint i=0;\r\nif (!cosa->txbitmap) {\r\npr_warn("%s: No channel wants data in TX IRQ. Expect DMA timeout.\n",\r\ncosa->name);\r\nput_driver_status_nolock(cosa);\r\nclear_bit(TXBIT, &cosa->rxtx);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nreturn;\r\n}\r\nwhile (1) {\r\ncosa->txchan++;\r\ni++;\r\nif (cosa->txchan >= cosa->nchannels)\r\ncosa->txchan = 0;\r\nif (!(cosa->txbitmap & (1<<cosa->txchan)))\r\ncontinue;\r\nif (~status & (1 << (cosa->txchan+DRIVER_TXMAP_SHIFT)))\r\nbreak;\r\nif (i > cosa->nchannels) {\r\n#ifdef DEBUG_IRQS\r\nprintk(KERN_DEBUG "%s: Forcing TX "\r\n"to not-ready channel %d\n",\r\ncosa->name, cosa->txchan);\r\n#endif\r\nbreak;\r\n}\r\n}\r\ncosa->txsize = cosa->chan[cosa->txchan].txsize;\r\nif (cosa_dma_able(cosa->chan+cosa->txchan,\r\ncosa->chan[cosa->txchan].txbuf, cosa->txsize)) {\r\ncosa->txbuf = cosa->chan[cosa->txchan].txbuf;\r\n} else {\r\nmemcpy(cosa->bouncebuf, cosa->chan[cosa->txchan].txbuf,\r\ncosa->txsize);\r\ncosa->txbuf = cosa->bouncebuf;\r\n}\r\n}\r\nif (is_8bit(cosa)) {\r\nif (!test_bit(IRQBIT, &cosa->rxtx)) {\r\ncosa_putstatus(cosa, SR_TX_INT_ENA);\r\ncosa_putdata8(cosa, ((cosa->txchan << 5) & 0xe0)|\r\n((cosa->txsize >> 8) & 0x1f));\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_TX_INT_ENA);\r\ndebug_data_out(cosa, ((cosa->txchan << 5) & 0xe0)|\r\n((cosa->txsize >> 8) & 0x1f));\r\ndebug_data_in(cosa, cosa_getdata8(cosa));\r\n#else\r\ncosa_getdata8(cosa);\r\n#endif\r\nset_bit(IRQBIT, &cosa->rxtx);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nreturn;\r\n} else {\r\nclear_bit(IRQBIT, &cosa->rxtx);\r\ncosa_putstatus(cosa, 0);\r\ncosa_putdata8(cosa, cosa->txsize&0xff);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, 0);\r\ndebug_data_out(cosa, cosa->txsize&0xff);\r\n#endif\r\n}\r\n} else {\r\ncosa_putstatus(cosa, SR_TX_INT_ENA);\r\ncosa_putdata16(cosa, ((cosa->txchan<<13) & 0xe000)\r\n| (cosa->txsize & 0x1fff));\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_TX_INT_ENA);\r\ndebug_data_out(cosa, ((cosa->txchan<<13) & 0xe000)\r\n| (cosa->txsize & 0x1fff));\r\ndebug_data_in(cosa, cosa_getdata8(cosa));\r\ndebug_status_out(cosa, 0);\r\n#else\r\ncosa_getdata8(cosa);\r\n#endif\r\ncosa_putstatus(cosa, 0);\r\n}\r\nif (cosa->busmaster) {\r\nunsigned long addr = virt_to_bus(cosa->txbuf);\r\nint count=0;\r\npr_info("busmaster IRQ\n");\r\nwhile (!(cosa_getstatus(cosa)&SR_TX_RDY)) {\r\ncount++;\r\nudelay(10);\r\nif (count > 1000) break;\r\n}\r\npr_info("status %x\n", cosa_getstatus(cosa));\r\npr_info("ready after %d loops\n", count);\r\ncosa_putdata16(cosa, (addr >> 16)&0xffff);\r\ncount = 0;\r\nwhile (!(cosa_getstatus(cosa)&SR_TX_RDY)) {\r\ncount++;\r\nif (count > 1000) break;\r\nudelay(10);\r\n}\r\npr_info("ready after %d loops\n", count);\r\ncosa_putdata16(cosa, addr &0xffff);\r\nflags1 = claim_dma_lock();\r\nset_dma_mode(cosa->dma, DMA_MODE_CASCADE);\r\nenable_dma(cosa->dma);\r\nrelease_dma_lock(flags1);\r\n} else {\r\nflags1 = claim_dma_lock();\r\ndisable_dma(cosa->dma);\r\nclear_dma_ff(cosa->dma);\r\nset_dma_mode(cosa->dma, DMA_MODE_WRITE);\r\nset_dma_addr(cosa->dma, virt_to_bus(cosa->txbuf));\r\nset_dma_count(cosa->dma, cosa->txsize);\r\nenable_dma(cosa->dma);\r\nrelease_dma_lock(flags1);\r\n}\r\ncosa_putstatus(cosa, SR_TX_DMA_ENA|SR_USR_INT_ENA);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_TX_DMA_ENA|SR_USR_INT_ENA);\r\n#endif\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\n}\r\nstatic inline void rx_interrupt(struct cosa_data *cosa, int status)\r\n{\r\nunsigned long flags;\r\n#ifdef DEBUG_IRQS\r\npr_info("cosa%d: SR_UP_REQUEST\n", cosa->num);\r\n#endif\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nset_bit(RXBIT, &cosa->rxtx);\r\nif (is_8bit(cosa)) {\r\nif (!test_bit(IRQBIT, &cosa->rxtx)) {\r\nset_bit(IRQBIT, &cosa->rxtx);\r\nput_driver_status_nolock(cosa);\r\ncosa->rxsize = cosa_getdata8(cosa) <<8;\r\n#ifdef DEBUG_IO\r\ndebug_data_in(cosa, cosa->rxsize >> 8);\r\n#endif\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\nreturn;\r\n} else {\r\nclear_bit(IRQBIT, &cosa->rxtx);\r\ncosa->rxsize |= cosa_getdata8(cosa) & 0xff;\r\n#ifdef DEBUG_IO\r\ndebug_data_in(cosa, cosa->rxsize & 0xff);\r\n#endif\r\n#if 0\r\npr_info("cosa%d: receive rxsize = (0x%04x)\n",\r\ncosa->num, cosa->rxsize);\r\n#endif\r\n}\r\n} else {\r\ncosa->rxsize = cosa_getdata16(cosa);\r\n#ifdef DEBUG_IO\r\ndebug_data_in(cosa, cosa->rxsize);\r\n#endif\r\n#if 0\r\npr_info("cosa%d: receive rxsize = (0x%04x)\n",\r\ncosa->num, cosa->rxsize);\r\n#endif\r\n}\r\nif (((cosa->rxsize & 0xe000) >> 13) >= cosa->nchannels) {\r\npr_warn("%s: rx for unknown channel (0x%04x)\n",\r\ncosa->name, cosa->rxsize);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\ngoto reject;\r\n}\r\ncosa->rxchan = cosa->chan + ((cosa->rxsize & 0xe000) >> 13);\r\ncosa->rxsize &= 0x1fff;\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\ncosa->rxbuf = NULL;\r\nif (cosa->rxchan->setup_rx)\r\ncosa->rxbuf = cosa->rxchan->setup_rx(cosa->rxchan, cosa->rxsize);\r\nif (!cosa->rxbuf) {\r\nreject:\r\npr_info("cosa%d: rejecting packet on channel %d\n",\r\ncosa->num, cosa->rxchan->num);\r\ncosa->rxbuf = cosa->bouncebuf;\r\n}\r\nflags = claim_dma_lock();\r\ndisable_dma(cosa->dma);\r\nclear_dma_ff(cosa->dma);\r\nset_dma_mode(cosa->dma, DMA_MODE_READ);\r\nif (cosa_dma_able(cosa->rxchan, cosa->rxbuf, cosa->rxsize & 0x1fff)) {\r\nset_dma_addr(cosa->dma, virt_to_bus(cosa->rxbuf));\r\n} else {\r\nset_dma_addr(cosa->dma, virt_to_bus(cosa->bouncebuf));\r\n}\r\nset_dma_count(cosa->dma, (cosa->rxsize&0x1fff));\r\nenable_dma(cosa->dma);\r\nrelease_dma_lock(flags);\r\nspin_lock_irqsave(&cosa->lock, flags);\r\ncosa_putstatus(cosa, SR_RX_DMA_ENA|SR_USR_INT_ENA);\r\nif (!is_8bit(cosa) && (status & SR_TX_RDY))\r\ncosa_putdata8(cosa, DRIVER_RX_READY);\r\n#ifdef DEBUG_IO\r\ndebug_status_out(cosa, SR_RX_DMA_ENA|SR_USR_INT_ENA);\r\nif (!is_8bit(cosa) && (status & SR_TX_RDY))\r\ndebug_data_cmd(cosa, DRIVER_RX_READY);\r\n#endif\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\n}\r\nstatic inline void eot_interrupt(struct cosa_data *cosa, int status)\r\n{\r\nunsigned long flags, flags1;\r\nspin_lock_irqsave(&cosa->lock, flags);\r\nflags1 = claim_dma_lock();\r\ndisable_dma(cosa->dma);\r\nclear_dma_ff(cosa->dma);\r\nrelease_dma_lock(flags1);\r\nif (test_bit(TXBIT, &cosa->rxtx)) {\r\nstruct channel_data *chan = cosa->chan+cosa->txchan;\r\nif (chan->tx_done)\r\nif (chan->tx_done(chan, cosa->txsize))\r\nclear_bit(chan->num, &cosa->txbitmap);\r\n} else if (test_bit(RXBIT, &cosa->rxtx)) {\r\n#ifdef DEBUG_DATA\r\n{\r\nint i;\r\npr_info("cosa%dc%d: done rx(0x%x)",\r\ncosa->num, cosa->rxchan->num, cosa->rxsize);\r\nfor (i=0; i<cosa->rxsize; i++)\r\npr_cont(" %02x", cosa->rxbuf[i]&0xff);\r\npr_cont("\n");\r\n}\r\n#endif\r\nif (cosa->rxbuf == cosa->bouncebuf)\r\ngoto out;\r\nif (!cosa_dma_able(cosa->rxchan, cosa->rxbuf, cosa->rxsize))\r\nmemcpy(cosa->rxbuf, cosa->bouncebuf, cosa->rxsize);\r\nif (cosa->rxchan->rx_done)\r\nif (cosa->rxchan->rx_done(cosa->rxchan))\r\nclear_bit(cosa->rxchan->num, &cosa->rxbitmap);\r\n} else {\r\npr_notice("cosa%d: unexpected EOT interrupt\n", cosa->num);\r\n}\r\nout:\r\ncosa->rxtx = 0;\r\nput_driver_status_nolock(cosa);\r\nspin_unlock_irqrestore(&cosa->lock, flags);\r\n}\r\nstatic irqreturn_t cosa_interrupt(int irq, void *cosa_)\r\n{\r\nunsigned status;\r\nint count = 0;\r\nstruct cosa_data *cosa = cosa_;\r\nagain:\r\nstatus = cosa_getstatus(cosa);\r\n#ifdef DEBUG_IRQS\r\npr_info("cosa%d: got IRQ, status 0x%02x\n", cosa->num, status & 0xff);\r\n#endif\r\n#ifdef DEBUG_IO\r\ndebug_status_in(cosa, status);\r\n#endif\r\nswitch (status & SR_CMD_FROM_SRP_MASK) {\r\ncase SR_DOWN_REQUEST:\r\ntx_interrupt(cosa, status);\r\nbreak;\r\ncase SR_UP_REQUEST:\r\nrx_interrupt(cosa, status);\r\nbreak;\r\ncase SR_END_OF_TRANSFER:\r\neot_interrupt(cosa, status);\r\nbreak;\r\ndefault:\r\nif (count++ < 100) {\r\nudelay(100);\r\ngoto again;\r\n}\r\npr_info("cosa%d: unknown status 0x%02x in IRQ after %d retries\n",\r\ncosa->num, status & 0xff, count);\r\n}\r\n#ifdef DEBUG_IRQS\r\nif (count)\r\npr_info("%s: %d-times got unknown status in IRQ\n",\r\ncosa->name, count);\r\nelse\r\npr_info("%s: returning from IRQ\n", cosa->name);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void debug_status_in(struct cosa_data *cosa, int status)\r\n{\r\nchar *s;\r\nswitch (status & SR_CMD_FROM_SRP_MASK) {\r\ncase SR_UP_REQUEST:\r\ns = "RX_REQ";\r\nbreak;\r\ncase SR_DOWN_REQUEST:\r\ns = "TX_REQ";\r\nbreak;\r\ncase SR_END_OF_TRANSFER:\r\ns = "ET_REQ";\r\nbreak;\r\ndefault:\r\ns = "NO_REQ";\r\nbreak;\r\n}\r\npr_info("%s: IO: status -> 0x%02x (%s%s%s%s)\n",\r\ncosa->name,\r\nstatus,\r\nstatus & SR_USR_RQ ? "USR_RQ|" : "",\r\nstatus & SR_TX_RDY ? "TX_RDY|" : "",\r\nstatus & SR_RX_RDY ? "RX_RDY|" : "",\r\ns);\r\n}\r\nstatic void debug_status_out(struct cosa_data *cosa, int status)\r\n{\r\npr_info("%s: IO: status <- 0x%02x (%s%s%s%s%s%s)\n",\r\ncosa->name,\r\nstatus,\r\nstatus & SR_RX_DMA_ENA ? "RXDMA|" : "!rxdma|",\r\nstatus & SR_TX_DMA_ENA ? "TXDMA|" : "!txdma|",\r\nstatus & SR_RST ? "RESET|" : "",\r\nstatus & SR_USR_INT_ENA ? "USRINT|" : "!usrint|",\r\nstatus & SR_TX_INT_ENA ? "TXINT|" : "!txint|",\r\nstatus & SR_RX_INT_ENA ? "RXINT" : "!rxint");\r\n}\r\nstatic void debug_data_in(struct cosa_data *cosa, int data)\r\n{\r\npr_info("%s: IO: data -> 0x%04x\n", cosa->name, data);\r\n}\r\nstatic void debug_data_out(struct cosa_data *cosa, int data)\r\n{\r\npr_info("%s: IO: data <- 0x%04x\n", cosa->name, data);\r\n}\r\nstatic void debug_data_cmd(struct cosa_data *cosa, int data)\r\n{\r\npr_info("%s: IO: data <- 0x%04x (%s|%s)\n",\r\ncosa->name, data,\r\ndata & SR_RDY_RCV ? "RX_RDY" : "!rx_rdy",\r\ndata & SR_RDY_SND ? "TX_RDY" : "!tx_rdy");\r\n}
