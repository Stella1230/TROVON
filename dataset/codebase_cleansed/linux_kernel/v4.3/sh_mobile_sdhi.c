static void sh_mobile_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)\r\n{\r\nu32 val;\r\nswitch (sd_ctrl_read16(host, CTL_VERSION)) {\r\ncase 0x490C:\r\nval = (width == 32) ? 0x0001 : 0x0000;\r\nbreak;\r\ncase 0xCB0D:\r\nval = (width == 32) ? 0x0000 : 0x0001;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsd_ctrl_write16(host, EXT_ACC, val);\r\n}\r\nstatic int sh_mobile_sdhi_clk_enable(struct platform_device *pdev, unsigned int *f)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nint ret = clk_prepare_enable(priv->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n*f = clk_get_rate(priv->clk);\r\nsh_mobile_sdhi_sdbuf_width(host, 16);\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_sdhi_clk_disable(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nstatic int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)\r\n{\r\nint timeout = 1000;\r\nwhile (--timeout && !(sd_ctrl_read16(host, CTL_STATUS2) & (1 << 13)))\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(&host->pdev->dev, "timeout waiting for SD bus idle\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)\r\n{\r\nswitch (addr)\r\n{\r\ncase CTL_SD_CMD:\r\ncase CTL_STOP_INTERNAL_ACTION:\r\ncase CTL_XFER_BLK_COUNT:\r\ncase CTL_SD_CARD_CLK_CTL:\r\ncase CTL_SD_XFER_LEN:\r\ncase CTL_SD_MEM_CARD_OPT:\r\ncase CTL_TRANSACTION_CTL:\r\ncase CTL_DMA_ENABLE:\r\nreturn sh_mobile_sdhi_wait_idle(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_multi_io_quirk(struct mmc_card *card,\r\nunsigned int direction, int blk_size)\r\n{\r\nif ((direction == MMC_DATA_READ) &&\r\nblk_size == 2)\r\nreturn 1;\r\nreturn blk_size;\r\n}\r\nstatic void sh_mobile_sdhi_enable_dma(struct tmio_mmc_host *host, bool enable)\r\n{\r\nsd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? 2 : 0);\r\nsh_mobile_sdhi_sdbuf_width(host, enable ? 32 : 16);\r\n}\r\nstatic int sh_mobile_sdhi_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(sh_mobile_sdhi_of_match, &pdev->dev);\r\nstruct sh_mobile_sdhi *priv;\r\nstruct tmio_mmc_data *mmc_data;\r\nstruct tmio_mmc_data *mmd = pdev->dev.platform_data;\r\nstruct tmio_mmc_host *host;\r\nstruct resource *res;\r\nint irq, ret, i = 0;\r\nbool multiplexed_isr = true;\r\nstruct tmio_mmc_dma *dma_priv;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct sh_mobile_sdhi), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev, "kzalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmmc_data = &priv->mmc_data;\r\ndma_priv = &priv->dma_priv;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ndev_err(&pdev->dev, "cannot get clock: %d\n", ret);\r\ngoto eprobe;\r\n}\r\nhost = tmio_mmc_host_alloc(pdev);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto eprobe;\r\n}\r\nhost->dma = dma_priv;\r\nhost->write16_hook = sh_mobile_sdhi_write16_hook;\r\nhost->clk_enable = sh_mobile_sdhi_clk_enable;\r\nhost->clk_disable = sh_mobile_sdhi_clk_disable;\r\nhost->multi_io_quirk = sh_mobile_sdhi_multi_io_quirk;\r\nif (resource_size(res) > 0x100)\r\nhost->bus_shift = 1;\r\nelse\r\nhost->bus_shift = 0;\r\nif (mmd)\r\n*mmc_data = *mmd;\r\ndma_priv->filter = shdma_chan_filter;\r\ndma_priv->enable = sh_mobile_sdhi_enable_dma;\r\nmmc_data->alignment_shift = 1;\r\nmmc_data->capabilities |= MMC_CAP_MMC_HIGHSPEED;\r\nmmc_data->flags |= TMIO_MMC_BLKSZ_2BYTES;\r\nmmc_data->flags |= TMIO_MMC_SDIO_IRQ;\r\nmmc_data->flags |= TMIO_MMC_HAVE_CMD12_CTRL;\r\nmmc_data->flags |= TMIO_MMC_SDIO_STATUS_QUIRK;\r\nif (of_id && of_id->data) {\r\nconst struct sh_mobile_sdhi_of_data *of_data = of_id->data;\r\nmmc_data->flags |= of_data->tmio_flags;\r\nmmc_data->capabilities |= of_data->capabilities;\r\nmmc_data->capabilities2 |= of_data->capabilities2;\r\nmmc_data->dma_rx_offset = of_data->dma_rx_offset;\r\ndma_priv->dma_buswidth = of_data->dma_buswidth;\r\n}\r\nret = tmio_mmc_host_probe(host, mmc_data);\r\nif (ret < 0)\r\ngoto efree;\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_CARD_DETECT);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_card_detect_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDIO);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdio_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDCARD);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdcard_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n} else if (!multiplexed_isr) {\r\ndev_err(&pdev->dev,\r\n"Principal SD-card IRQ is missing among named interrupts\n");\r\nret = irq;\r\ngoto eirq;\r\n}\r\nif (multiplexed_isr) {\r\nwhile (1) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\nbreak;\r\ni++;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nif (!i) {\r\nret = irq;\r\ngoto eirq;\r\n}\r\n}\r\ndev_info(&pdev->dev, "%s base at 0x%08lx clock rate %u MHz\n",\r\nmmc_hostname(host->mmc), (unsigned long)\r\n(platform_get_resource(pdev, IORESOURCE_MEM, 0)->start),\r\nhost->mmc->f_max / 1000000);\r\nreturn ret;\r\neirq:\r\ntmio_mmc_host_remove(host);\r\nefree:\r\ntmio_mmc_host_free(host);\r\neprobe:\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_sdhi_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\ntmio_mmc_host_remove(host);\r\nreturn 0;\r\n}
