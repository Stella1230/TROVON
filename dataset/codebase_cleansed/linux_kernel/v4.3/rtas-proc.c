static int sensors_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_sensors_show, NULL);\r\n}\r\nstatic int poweron_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_poweron_show, NULL);\r\n}\r\nstatic int progress_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_progress_show, NULL);\r\n}\r\nstatic int clock_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_clock_show, NULL);\r\n}\r\nstatic int tone_freq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_tone_freq_show, NULL);\r\n}\r\nstatic int tone_volume_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_tone_volume_show, NULL);\r\n}\r\nstatic int rmo_buf_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ppc_rtas_rmo_buf_show, NULL);\r\n}\r\nstatic int __init proc_rtas_init(void)\r\n{\r\nif (!machine_is(pseries))\r\nreturn -ENODEV;\r\nrtas_node = of_find_node_by_name(NULL, "rtas");\r\nif (rtas_node == NULL)\r\nreturn -ENODEV;\r\nproc_create("powerpc/rtas/progress", S_IRUGO|S_IWUSR, NULL,\r\n&ppc_rtas_progress_operations);\r\nproc_create("powerpc/rtas/clock", S_IRUGO|S_IWUSR, NULL,\r\n&ppc_rtas_clock_operations);\r\nproc_create("powerpc/rtas/poweron", S_IWUSR|S_IRUGO, NULL,\r\n&ppc_rtas_poweron_operations);\r\nproc_create("powerpc/rtas/sensors", S_IRUGO, NULL,\r\n&ppc_rtas_sensors_operations);\r\nproc_create("powerpc/rtas/frequency", S_IWUSR|S_IRUGO, NULL,\r\n&ppc_rtas_tone_freq_operations);\r\nproc_create("powerpc/rtas/volume", S_IWUSR|S_IRUGO, NULL,\r\n&ppc_rtas_tone_volume_operations);\r\nproc_create("powerpc/rtas/rmo_buffer", S_IRUSR, NULL,\r\n&ppc_rtas_rmo_buf_ops);\r\nreturn 0;\r\n}\r\nstatic int parse_number(const char __user *p, size_t count, unsigned long *val)\r\n{\r\nchar buf[40];\r\nchar *end;\r\nif (count > 39)\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, p, count))\r\nreturn -EFAULT;\r\nbuf[count] = 0;\r\n*val = simple_strtoul(buf, &end, 10);\r\nif (*end && *end != '\n')\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct rtc_time tm;\r\nunsigned long nowtime;\r\nint error = parse_number(buf, count, &nowtime);\r\nif (error)\r\nreturn error;\r\npower_on_time = nowtime;\r\nto_tm(nowtime, &tm);\r\nerror = rtas_call(rtas_token("set-time-for-power-on"), 7, 1, NULL,\r\ntm.tm_year, tm.tm_mon, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec, 0 );\r\nif (error)\r\nprintk(KERN_WARNING "error: setting poweron time returned: %s\n",\r\nppc_rtas_process_error(error));\r\nreturn count;\r\n}\r\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v)\r\n{\r\nif (power_on_time == 0)\r\nseq_printf(m, "Power on time not set\n");\r\nelse\r\nseq_printf(m, "%lu\n",power_on_time);\r\nreturn 0;\r\n}\r\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long hex;\r\nif (count >= MAX_LINELENGTH)\r\ncount = MAX_LINELENGTH -1;\r\nif (copy_from_user(progress_led, buf, count)) {\r\nreturn -EFAULT;\r\n}\r\nprogress_led[count] = 0;\r\nhex = simple_strtoul(progress_led, NULL, 10);\r\nrtas_progress ((char *)progress_led, hex);\r\nreturn count;\r\n}\r\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v)\r\n{\r\nif (progress_led[0])\r\nseq_printf(m, "%s\n", progress_led);\r\nreturn 0;\r\n}\r\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct rtc_time tm;\r\nunsigned long nowtime;\r\nint error = parse_number(buf, count, &nowtime);\r\nif (error)\r\nreturn error;\r\nto_tm(nowtime, &tm);\r\nerror = rtas_call(rtas_token("set-time-of-day"), 7, 1, NULL,\r\ntm.tm_year, tm.tm_mon, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec, 0);\r\nif (error)\r\nprintk(KERN_WARNING "error: setting the clock returned: %s\n",\r\nppc_rtas_process_error(error));\r\nreturn count;\r\n}\r\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v)\r\n{\r\nint ret[8];\r\nint error = rtas_call(rtas_token("get-time-of-day"), 0, 8, ret);\r\nif (error) {\r\nprintk(KERN_WARNING "error: reading the clock returned: %s\n",\r\nppc_rtas_process_error(error));\r\nseq_printf(m, "0");\r\n} else {\r\nunsigned int year, mon, day, hour, min, sec;\r\nyear = ret[0]; mon = ret[1]; day = ret[2];\r\nhour = ret[3]; min = ret[4]; sec = ret[5];\r\nseq_printf(m, "%lu\n",\r\nmktime(year, mon, day, hour, min, sec));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v)\r\n{\r\nint i,j;\r\nint state, error;\r\nint get_sensor_state = rtas_token("get-sensor-state");\r\nseq_printf(m, "RTAS (RunTime Abstraction Services) Sensor Information\n");\r\nseq_printf(m, "Sensor\t\tValue\t\tCondition\tLocation\n");\r\nseq_printf(m, "********************************************************\n");\r\nif (ppc_rtas_find_all_sensors() != 0) {\r\nseq_printf(m, "\nNo sensors are available\n");\r\nreturn 0;\r\n}\r\nfor (i=0; i<sensors.quant; i++) {\r\nstruct individual_sensor *p = &sensors.sensor[i];\r\nchar rstr[64];\r\nconst char *loc;\r\nint llen, offs;\r\nsprintf (rstr, SENSOR_PREFIX"%04d", p->token);\r\nloc = of_get_property(rtas_node, rstr, &llen);\r\nfor (j = 0, offs = 0; j <= p->quant; j++) {\r\nerror = rtas_call(get_sensor_state, 2, 2, &state,\r\np->token, j);\r\nppc_rtas_process_sensor(m, p, state, error, loc);\r\nseq_putc(m, '\n');\r\nif (loc) {\r\noffs += strlen(loc) + 1;\r\nloc += strlen(loc) + 1;\r\nif (offs >= llen)\r\nloc = NULL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ppc_rtas_find_all_sensors(void)\r\n{\r\nconst unsigned int *utmp;\r\nint len, i;\r\nutmp = of_get_property(rtas_node, "rtas-sensors", &len);\r\nif (utmp == NULL) {\r\nprintk (KERN_ERR "error: could not get rtas-sensors\n");\r\nreturn 1;\r\n}\r\nsensors.quant = len / 8;\r\nfor (i=0; i<sensors.quant; i++) {\r\nsensors.sensor[i].token = *utmp++;\r\nsensors.sensor[i].quant = *utmp++;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *ppc_rtas_process_error(int error)\r\n{\r\nswitch (error) {\r\ncase SENSOR_CRITICAL_HIGH:\r\nreturn "(critical high)";\r\ncase SENSOR_WARNING_HIGH:\r\nreturn "(warning high)";\r\ncase SENSOR_NORMAL:\r\nreturn "(normal)";\r\ncase SENSOR_WARNING_LOW:\r\nreturn "(warning low)";\r\ncase SENSOR_CRITICAL_LOW:\r\nreturn "(critical low)";\r\ncase SENSOR_SUCCESS:\r\nreturn "(read ok)";\r\ncase SENSOR_HW_ERROR:\r\nreturn "(hardware error)";\r\ncase SENSOR_BUSY:\r\nreturn "(busy)";\r\ncase SENSOR_NOT_EXIST:\r\nreturn "(non existent)";\r\ncase SENSOR_DR_ENTITY:\r\nreturn "(dr entity removed)";\r\ndefault:\r\nreturn "(UNKNOWN)";\r\n}\r\n}\r\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\r\nstruct individual_sensor *s, int state, int error, const char *loc)\r\n{\r\nconst char * key_switch[] = { "Off\t", "Normal\t", "Secure\t",\r\n"Maintenance" };\r\nconst char * enclosure_switch[] = { "Closed", "Open" };\r\nconst char * lid_status[] = { " ", "Open", "Closed" };\r\nconst char * power_source[] = { "AC\t", "Battery",\r\n"AC & Battery" };\r\nconst char * battery_remaining[] = { "Very Low", "Low", "Mid", "High" };\r\nconst char * epow_sensor[] = {\r\n"EPOW Reset", "Cooling warning", "Power warning",\r\n"System shutdown", "System halt", "EPOW main enclosure",\r\n"EPOW power off" };\r\nconst char * battery_cyclestate[] = { "None", "In progress",\r\n"Requested" };\r\nconst char * battery_charging[] = { "Charging", "Discharching",\r\n"No current flow" };\r\nconst char * ibm_drconnector[] = { "Empty", "Present", "Unusable",\r\n"Exchange" };\r\nint have_strings = 0;\r\nint num_states = 0;\r\nint temperature = 0;\r\nint unknown = 0;\r\nswitch (s->token) {\r\ncase KEY_SWITCH:\r\nseq_printf(m, "Key switch:\t");\r\nnum_states = sizeof(key_switch) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t", key_switch[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase ENCLOSURE_SWITCH:\r\nseq_printf(m, "Enclosure switch:\t");\r\nnum_states = sizeof(enclosure_switch) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t",\r\nenclosure_switch[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase THERMAL_SENSOR:\r\nseq_printf(m, "Temp. (C/F):\t");\r\ntemperature = 1;\r\nbreak;\r\ncase LID_STATUS:\r\nseq_printf(m, "Lid status:\t");\r\nnum_states = sizeof(lid_status) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t", lid_status[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase POWER_SOURCE:\r\nseq_printf(m, "Power source:\t");\r\nnum_states = sizeof(power_source) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t",\r\npower_source[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase BATTERY_VOLTAGE:\r\nseq_printf(m, "Battery voltage:\t");\r\nbreak;\r\ncase BATTERY_REMAINING:\r\nseq_printf(m, "Battery remaining:\t");\r\nnum_states = sizeof(battery_remaining) / sizeof(char *);\r\nif (state < num_states)\r\n{\r\nseq_printf(m, "%s\t",\r\nbattery_remaining[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase BATTERY_PERCENTAGE:\r\nseq_printf(m, "Battery percentage:\t");\r\nbreak;\r\ncase EPOW_SENSOR:\r\nseq_printf(m, "EPOW Sensor:\t");\r\nnum_states = sizeof(epow_sensor) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t", epow_sensor[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase BATTERY_CYCLESTATE:\r\nseq_printf(m, "Battery cyclestate:\t");\r\nnum_states = sizeof(battery_cyclestate) /\r\nsizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t",\r\nbattery_cyclestate[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase BATTERY_CHARGING:\r\nseq_printf(m, "Battery Charging:\t");\r\nnum_states = sizeof(battery_charging) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t",\r\nbattery_charging[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase IBM_SURVEILLANCE:\r\nseq_printf(m, "Surveillance:\t");\r\nbreak;\r\ncase IBM_FANRPM:\r\nseq_printf(m, "Fan (rpm):\t");\r\nbreak;\r\ncase IBM_VOLTAGE:\r\nseq_printf(m, "Voltage (mv):\t");\r\nbreak;\r\ncase IBM_DRCONNECTOR:\r\nseq_printf(m, "DR connector:\t");\r\nnum_states = sizeof(ibm_drconnector) / sizeof(char *);\r\nif (state < num_states) {\r\nseq_printf(m, "%s\t",\r\nibm_drconnector[state]);\r\nhave_strings = 1;\r\n}\r\nbreak;\r\ncase IBM_POWERSUPPLY:\r\nseq_printf(m, "Powersupply:\t");\r\nbreak;\r\ndefault:\r\nseq_printf(m, "Unknown sensor (type %d), ignoring it\n",\r\ns->token);\r\nunknown = 1;\r\nhave_strings = 1;\r\nbreak;\r\n}\r\nif (have_strings == 0) {\r\nif (temperature) {\r\nseq_printf(m, "%4d /%4d\t", state, cel_to_fahr(state));\r\n} else\r\nseq_printf(m, "%10d\t", state);\r\n}\r\nif (unknown == 0) {\r\nseq_printf(m, "%s\t", ppc_rtas_process_error(error));\r\nget_location_code(m, s, loc);\r\n}\r\n}\r\nstatic void check_location(struct seq_file *m, const char *c)\r\n{\r\nswitch (c[0]) {\r\ncase LOC_PLANAR:\r\nseq_printf(m, "Planar #%c", c[1]);\r\nbreak;\r\ncase LOC_CPU:\r\nseq_printf(m, "CPU #%c", c[1]);\r\nbreak;\r\ncase LOC_FAN:\r\nseq_printf(m, "Fan #%c", c[1]);\r\nbreak;\r\ncase LOC_RACKMOUNTED:\r\nseq_printf(m, "Rack #%c", c[1]);\r\nbreak;\r\ncase LOC_VOLTAGE:\r\nseq_printf(m, "Voltage #%c", c[1]);\r\nbreak;\r\ncase LOC_LCD:\r\nseq_printf(m, "LCD #%c", c[1]);\r\nbreak;\r\ncase '.':\r\nseq_printf(m, "- %c", c[1]);\r\nbreak;\r\ndefault:\r\nseq_printf(m, "Unknown location");\r\nbreak;\r\n}\r\n}\r\nstatic void check_location_string(struct seq_file *m, const char *c)\r\n{\r\nwhile (*c) {\r\nif (isalpha(*c) || *c == '.')\r\ncheck_location(m, c);\r\nelse if (*c == '/' || *c == '-')\r\nseq_printf(m, " at ");\r\nc++;\r\n}\r\n}\r\nstatic void get_location_code(struct seq_file *m, struct individual_sensor *s,\r\nconst char *loc)\r\n{\r\nif (!loc || !*loc) {\r\nseq_printf(m, "---");\r\n} else {\r\ncheck_location_string(m, loc);\r\n}\r\nseq_putc(m, ' ');\r\n}\r\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long freq;\r\nint error = parse_number(buf, count, &freq);\r\nif (error)\r\nreturn error;\r\nrtas_tone_frequency = freq;\r\nerror = rtas_call(rtas_token("set-indicator"), 3, 1, NULL,\r\nTONE_FREQUENCY, 0, freq);\r\nif (error)\r\nprintk(KERN_WARNING "error: setting tone frequency returned: %s\n",\r\nppc_rtas_process_error(error));\r\nreturn count;\r\n}\r\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%lu\n", rtas_tone_frequency);\r\nreturn 0;\r\n}\r\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long volume;\r\nint error = parse_number(buf, count, &volume);\r\nif (error)\r\nreturn error;\r\nif (volume > 100)\r\nvolume = 100;\r\nrtas_tone_volume = volume;\r\nerror = rtas_call(rtas_token("set-indicator"), 3, 1, NULL,\r\nTONE_VOLUME, 0, volume);\r\nif (error)\r\nprintk(KERN_WARNING "error: setting tone volume returned: %s\n",\r\nppc_rtas_process_error(error));\r\nreturn count;\r\n}\r\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%lu\n", rtas_tone_volume);\r\nreturn 0;\r\n}\r\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%016lx %x\n", rtas_rmo_buf, RTAS_RMOBUF_MAX);\r\nreturn 0;\r\n}
