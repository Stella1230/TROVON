void beiscsi_ue_detect(struct beiscsi_hba *phba)\r\n{\r\nuint32_t ue_hi = 0, ue_lo = 0;\r\nuint32_t ue_mask_hi = 0, ue_mask_lo = 0;\r\nuint8_t i = 0;\r\nif (phba->ue_detected)\r\nreturn;\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_LOW, &ue_lo);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_MASK_LOW,\r\n&ue_mask_lo);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_HIGH,\r\n&ue_hi);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_MASK_HI,\r\n&ue_mask_hi);\r\nue_lo = (ue_lo & ~ue_mask_lo);\r\nue_hi = (ue_hi & ~ue_mask_hi);\r\nif (ue_lo || ue_hi) {\r\nphba->ue_detected = true;\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : Error detected on the adapter\n");\r\n}\r\nif (ue_lo) {\r\nfor (i = 0; ue_lo; ue_lo >>= 1, i++) {\r\nif (ue_lo & 1)\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG,\r\n"BG_%d : UE_LOW %s bit set\n",\r\ndesc_ue_status_low[i]);\r\n}\r\n}\r\nif (ue_hi) {\r\nfor (i = 0; ue_hi; ue_hi >>= 1, i++) {\r\nif (ue_hi & 1)\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG,\r\n"BG_%d : UE_HIGH %s bit set\n",\r\ndesc_ue_status_hi[i]);\r\n}\r\n}\r\n}\r\nint be_cmd_modify_eq_delay(struct beiscsi_hba *phba,\r\nstruct be_set_eqd *set_eqd, int num)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_modify_eq_delay *req;\r\nunsigned int tag = 0;\r\nint i;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req));\r\nreq->num_eq = cpu_to_le32(num);\r\nfor (i = 0; i < num; i++) {\r\nreq->delay[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);\r\nreq->delay[i].phase = 0;\r\nreq->delay[i].delay_multiplier =\r\ncpu_to_le32(set_eqd[i].delay_multiplier);\r\n}\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_reopen_session(struct beiscsi_hba *phba,\r\nunsigned int reopen_type,\r\nunsigned int sess_handle)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_reopen_session_req *req;\r\nunsigned int tag = 0;\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : In bescsi_get_boot_target\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_REOPEN_ALL_SESSIONS,\r\nsizeof(struct be_cmd_reopen_session_resp));\r\nreq->reopen_type = reopen_type;\r\nreq->session_handle = sess_handle;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_get_boot_target(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_get_boot_target_req *req;\r\nunsigned int tag = 0;\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : In bescsi_get_boot_target\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,\r\nsizeof(struct be_cmd_get_boot_target_resp));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_get_session_info(struct beiscsi_hba *phba,\r\nu32 boot_session_handle,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag = 0;\r\nstruct be_cmd_get_session_req *req;\r\nstruct be_cmd_get_session_resp *resp;\r\nstruct be_sge *sge;\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : In beiscsi_get_session_info\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nnonemb_cmd->size = sizeof(*resp);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_GET_A_SESSION,\r\nsizeof(*resp));\r\nreq->session_handle = boot_session_handle;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_get_fw_config(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_fw_cfg *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG,\r\nEMBED_MBX_MAX_PAYLOAD_SIZE);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nuint8_t ulp_num = 0;\r\nstruct be_fw_cfg *pfw_cfg;\r\npfw_cfg = req;\r\nif (!is_chip_be2_be3r(phba)) {\r\nphba->fw_config.eqid_count = pfw_cfg->eqid_count;\r\nphba->fw_config.cqid_count = pfw_cfg->cqid_count;\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_INIT,\r\n"BG_%d : EQ_Count : %d CQ_Count : %d\n",\r\nphba->fw_config.eqid_count,\r\nphba->fw_config.cqid_count);\r\n}\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\r\nif (pfw_cfg->ulp[ulp_num].ulp_mode &\r\nBEISCSI_ULP_ISCSI_INI_MODE)\r\nset_bit(ulp_num,\r\n&phba->fw_config.ulp_supported);\r\nphba->fw_config.phys_port = pfw_cfg->phys_port;\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {\r\nphba->fw_config.iscsi_cid_start[ulp_num] =\r\npfw_cfg->ulp[ulp_num].sq_base;\r\nphba->fw_config.iscsi_cid_count[ulp_num] =\r\npfw_cfg->ulp[ulp_num].sq_count;\r\nphba->fw_config.iscsi_icd_start[ulp_num] =\r\npfw_cfg->ulp[ulp_num].icd_base;\r\nphba->fw_config.iscsi_icd_count[ulp_num] =\r\npfw_cfg->ulp[ulp_num].icd_count;\r\nphba->fw_config.iscsi_chain_start[ulp_num] =\r\npfw_cfg->chain_icd[ulp_num].chain_base;\r\nphba->fw_config.iscsi_chain_count[ulp_num] =\r\npfw_cfg->chain_icd[ulp_num].chain_count;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : Function loaded on ULP : %d\n"\r\n"\tiscsi_cid_count : %d\n"\r\n"\tiscsi_cid_start : %d\n"\r\n"\t iscsi_icd_count : %d\n"\r\n"\t iscsi_icd_start : %d\n",\r\nulp_num,\r\nphba->fw_config.\r\niscsi_cid_count[ulp_num],\r\nphba->fw_config.\r\niscsi_cid_start[ulp_num],\r\nphba->fw_config.\r\niscsi_icd_count[ulp_num],\r\nphba->fw_config.\r\niscsi_icd_start[ulp_num]);\r\n}\r\n}\r\nphba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &\r\nBEISCSI_FUNC_DUA_MODE);\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : DUA Mode : 0x%x\n",\r\nphba->fw_config.dual_ulp_aware);\r\n} else {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : Failed in mgmt_get_fw_config\n");\r\nstatus = -EINVAL;\r\n}\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint mgmt_check_supported_fw(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_mgmt_controller_attributes *req;\r\nstruct be_sge *sge = nonembedded_sgl(wrb);\r\nint status = 0;\r\nnonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,\r\nsizeof(struct be_mgmt_controller_attributes),\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : Failed to allocate memory for "\r\n"mgmt_check_supported_fw\n");\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);\r\nreq = nonemb_cmd.va;\r\nmemset(req, 0, sizeof(*req));\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd.size);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : Firmware Version of CMD : %s\n"\r\n"Firmware Version is : %s\n"\r\n"Developer Build, not performing version check...\n",\r\nresp->params.hba_attribs\r\n.flashrom_version_string,\r\nresp->params.hba_attribs.\r\nfirmware_version_string);\r\nphba->fw_config.iscsi_features =\r\nresp->params.hba_attribs.iscsi_features;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BM_%d : phba->fw_config.iscsi_features = %d\n",\r\nphba->fw_config.iscsi_features);\r\nmemcpy(phba->fw_ver_str, resp->params.hba_attribs.\r\nfirmware_version_string, BEISCSI_VER_STRLEN);\r\n} else\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : Failed in mgmt_check_supported_fw\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nif (nonemb_cmd.va)\r\npci_free_consistent(ctrl->pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn status;\r\n}\r\nunsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba,\r\nstruct bsg_job *job,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_cmd_resp_hdr *resp;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *mcc_sge;\r\nunsigned int tag = 0;\r\nstruct iscsi_bsg_request *bsg_req = job->request;\r\nstruct be_bsg_vendor_cmd *req = nonemb_cmd->va;\r\nunsigned short region, sector_size, sector, offset;\r\nnonemb_cmd->size = job->request_payload.payload_len;\r\nmemset(nonemb_cmd->va, 0, nonemb_cmd->size);\r\nresp = nonemb_cmd->va;\r\nregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nsector_size = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nsector = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[4];\r\nreq->region = region;\r\nreq->sector = sector;\r\nreq->offset = offset;\r\nspin_lock(&ctrl->mbox_lock);\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase BEISCSI_WRITE_FLASH:\r\noffset = sector * sector_size + offset;\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_WRITE_FLASH, sizeof(*req));\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nnonemb_cmd->va + offset, job->request_len);\r\nbreak;\r\ncase BEISCSI_READ_FLASH:\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_READ_FLASH, sizeof(*req));\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Unsupported cmd = 0x%x\n\n",\r\nbsg_req->rqst_data.h_vendor.vendor_cmd[0]);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn -ENOSYS;\r\n}\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nmcc_sge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false,\r\njob->request_payload.sg_cnt);\r\nmcc_sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nmcc_sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nmcc_sge->len = cpu_to_le32(nonemb_cmd->size);\r\nwrb->tag0 |= tag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short ulp_num)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mccq(phba);\r\nstruct iscsi_cleanup_req *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));\r\nreq->chute = (1 << ulp_num);\r\nreq->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba, ulp_num));\r\nreq->data_ring_id = cpu_to_le16(HWI_GET_DEF_BUFQ_ID(phba, ulp_num));\r\nstatus = be_mcc_notify_wait(phba);\r\nif (status)\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\r\n"BG_%d : mgmt_epfw_cleanup , FAILED\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nunsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba,\r\nstruct invalidate_command_table *inv_tbl,\r\nunsigned int num_invalidate, unsigned int cid,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nstruct invalidate_commands_params_in *req;\r\nunsigned int i, tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_ERROR_RECOVERY_INVALIDATE_COMMANDS,\r\nsizeof(*req));\r\nreq->ref_handle = 0;\r\nreq->cleanup_type = CMD_ISCSI_COMMAND_INVALIDATE;\r\nfor (i = 0; i < num_invalidate; i++) {\r\nreq->table[i].icd = inv_tbl->icd;\r\nreq->table[i].cid = inv_tbl->cid;\r\nreq->icd_count++;\r\ninv_tbl++;\r\n}\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nunsigned short cid,\r\nunsigned short issue_reset,\r\nunsigned short savecfg_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct iscsi_invalidate_connection_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nwrb->tag0 |= tag;\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,\r\nsizeof(*req));\r\nreq->session_handle = beiscsi_ep->fw_handle;\r\nreq->cid = cid;\r\nif (issue_reset)\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_ISSUE_TCP_RST;\r\nelse\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_INVALIDATE;\r\nreq->save_cfg = savecfg_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_upload_connection(struct beiscsi_hba *phba,\r\nunsigned short cid, unsigned int upload_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_upload_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,\r\nOPCODE_COMMON_TCP_UPLOAD, sizeof(*req));\r\nreq->id = (unsigned short)cid;\r\nreq->upload_type = (unsigned char)upload_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_open_connection(struct beiscsi_hba *phba,\r\nstruct sockaddr *dst_addr,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_context_memory *phwi_context;\r\nstruct sockaddr_in *daddr_in = (struct sockaddr_in *)dst_addr;\r\nstruct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)dst_addr;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_connect_and_offload_in_v1 *req;\r\nunsigned short def_hdr_id;\r\nunsigned short def_data_id;\r\nstruct phys_addr template_address = { 0, 0 };\r\nstruct phys_addr *ptemplate_address;\r\nunsigned int tag = 0;\r\nunsigned int i, ulp_num;\r\nunsigned short cid = beiscsi_ep->ep_cid;\r\nstruct be_sge *sge;\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\nphwi_context = phwi_ctrlr->phwi_ctxt;\r\nulp_num = phwi_ctrlr->wrb_context[BE_GET_CRI_FROM_CID(cid)].ulp_num;\r\ndef_hdr_id = (unsigned short)HWI_GET_DEF_HDRQ_ID(phba, ulp_num);\r\ndef_data_id = (unsigned short)HWI_GET_DEF_BUFQ_ID(phba, ulp_num);\r\nptemplate_address = &template_address;\r\nISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_TCP_CONNECT_AND_OFFLOAD,\r\nnonemb_cmd->size);\r\nif (dst_addr->sa_family == PF_INET) {\r\n__be32 s_addr = daddr_in->sin_addr.s_addr;\r\nreq->ip_address.ip_type = BE2_IPV4;\r\nreq->ip_address.addr[0] = s_addr & 0x000000ff;\r\nreq->ip_address.addr[1] = (s_addr & 0x0000ff00) >> 8;\r\nreq->ip_address.addr[2] = (s_addr & 0x00ff0000) >> 16;\r\nreq->ip_address.addr[3] = (s_addr & 0xff000000) >> 24;\r\nreq->tcp_port = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->dst_addr = daddr_in->sin_addr.s_addr;\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->ip_type = BE2_IPV4;\r\n} else if (dst_addr->sa_family == PF_INET6) {\r\nreq->ip_address.ip_type = BE2_IPV6;\r\nmemcpy(&req->ip_address.addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nreq->tcp_port = ntohs(daddr_in6->sin6_port);\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in6->sin6_port);\r\nmemcpy(&beiscsi_ep->dst6_addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nbeiscsi_ep->ip_type = BE2_IPV6;\r\n} else{\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BG_%d : unknown addr family %d\n",\r\ndst_addr->sa_family);\r\nspin_unlock(&ctrl->mbox_lock);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nreturn -EINVAL;\r\n}\r\nreq->cid = cid;\r\ni = phba->nxt_cqid++;\r\nif (phba->nxt_cqid == phba->num_cpus)\r\nphba->nxt_cqid = 0;\r\nreq->cq_id = phwi_context->be_cq[i].id;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BG_%d : i=%d cq_id=%d\n", i, req->cq_id);\r\nreq->defq_id = def_hdr_id;\r\nreq->hdr_ring_id = def_hdr_id;\r\nreq->data_ring_id = def_data_id;\r\nreq->do_offload = 1;\r\nreq->dataout_template_pa.lo = ptemplate_address->lo;\r\nreq->dataout_template_pa.hi = ptemplate_address->hi;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nif (!is_chip_be2_be3r(phba)) {\r\nreq->hdr.version = MBX_CMD_VER1;\r\nreq->tcp_window_size = 0;\r\nreq->tcp_window_scale_count = 2;\r\n}\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_cmd_get_all_if_id_req *req = embedded_payload(wrb);\r\nstruct be_cmd_get_all_if_id_req *pbe_allid = req;\r\nint status = 0;\r\nmemset(wrb, 0, sizeof(*wrb));\r\nspin_lock(&ctrl->mbox_lock);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,\r\nsizeof(*req));\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status)\r\nphba->interface_handle = pbe_allid->if_hndl_list[0];\r\nelse {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed in mgmt_get_all_if_id\n");\r\n}\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nstatic int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,\r\nstruct be_dma_mem *nonemb_cmd, void *resp_buf,\r\nint resp_buf_len)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nunsigned int tag;\r\nint rc = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nrc = -ENOMEM;\r\ngoto free_cmd;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nwrb->tag0 |= tag;\r\nsge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd->dma));\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nrc = beiscsi_mccq_compl(phba, tag, NULL, nonemb_cmd);\r\nif (resp_buf)\r\nmemcpy(resp_buf, nonemb_cmd->va, resp_buf_len);\r\nif (rc) {\r\nif (rc == -EAGAIN)\r\nreturn rc;\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : mgmt_exec_nonemb_cmd Failed status\n");\r\nif (rc != -EBUSY)\r\ngoto free_cmd;\r\nelse\r\nreturn rc;\r\n}\r\nfree_cmd:\r\npci_free_consistent(ctrl->pdev, nonemb_cmd->size,\r\nnonemb_cmd->va, nonemb_cmd->dma);\r\nreturn rc;\r\n}\r\nstatic int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,\r\nint iscsi_cmd, int size)\r\n{\r\ncmd->va = pci_zalloc_consistent(phba->ctrl.pdev, size, &cmd->dma);\r\nif (!cmd->va) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to allocate memory for if info\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->size = size;\r\nbe_cmd_hdr_prepare(cmd->va, CMD_SUBSYSTEM_ISCSI, iscsi_cmd, size);\r\nreturn 0;\r\n}\r\nstatic int\r\nmgmt_static_ip_modify(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_if_info_resp *if_info,\r\nstruct iscsi_iface_param_info *ip_param,\r\nstruct iscsi_iface_param_info *subnet_param,\r\nuint32_t ip_action)\r\n{\r\nstruct be_cmd_set_ip_addr_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint32_t ip_type;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\r\nsizeof(*req));\r\nif (rc)\r\nreturn rc;\r\nip_type = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nBE2_IPV6 : BE2_IPV4 ;\r\nreq = nonemb_cmd.va;\r\nreq->ip_params.record_entry_count = 1;\r\nreq->ip_params.ip_record.action = ip_action;\r\nreq->ip_params.ip_record.interface_hndl =\r\nphba->interface_handle;\r\nreq->ip_params.ip_record.ip_addr.size_of_structure =\r\nsizeof(struct be_ip_addr_subnet_format);\r\nreq->ip_params.ip_record.ip_addr.ip_type = ip_type;\r\nif (ip_action == IP_ACTION_ADD) {\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr, ip_param->value,\r\nsizeof(req->ip_params.ip_record.ip_addr.addr));\r\nif (subnet_param)\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nsubnet_param->value,\r\nsizeof(req->ip_params.ip_record.ip_addr.subnet_mask));\r\n} else {\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr,\r\nif_info->ip_addr.addr,\r\nsizeof(req->ip_params.ip_record.ip_addr.addr));\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nif_info->ip_addr.subnet_mask,\r\nsizeof(req->ip_params.ip_record.ip_addr.subnet_mask));\r\n}\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0)\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Modify existing IP Address\n");\r\nreturn rc;\r\n}\r\nstatic int mgmt_modify_gateway(struct beiscsi_hba *phba, uint8_t *gt_addr,\r\nuint32_t gtway_action, uint32_t param_len)\r\n{\r\nstruct be_cmd_set_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rt_val;\r\nrt_val = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,\r\nsizeof(*req));\r\nif (rt_val)\r\nreturn rt_val;\r\nreq = nonemb_cmd.va;\r\nreq->action = gtway_action;\r\nreq->ip_addr.ip_type = BE2_IPV4;\r\nmemcpy(req->ip_addr.addr, gt_addr, sizeof(req->ip_addr.addr));\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\n}\r\nint mgmt_set_ip(struct beiscsi_hba *phba,\r\nstruct iscsi_iface_param_info *ip_param,\r\nstruct iscsi_iface_param_info *subnet_param,\r\nuint32_t boot_proto)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gtway_addr_set;\r\nstruct be_cmd_get_if_info_resp *if_info;\r\nstruct be_cmd_set_dhcp_req *dhcpreq;\r\nstruct be_cmd_rel_dhcp_req *reldhcp;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint8_t *gtway_addr;\r\nuint32_t ip_type;\r\nint rc;\r\nif (mgmt_get_all_if_id(phba))\r\nreturn -EIO;\r\nip_type = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nBE2_IPV6 : BE2_IPV4 ;\r\nrc = mgmt_get_if_info(phba, ip_type, &if_info);\r\nif (rc)\r\nreturn rc;\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nif (if_info->dhcp_state) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : DHCP Already Enabled\n");\r\ngoto exit;\r\n}\r\nip_param->len = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nIP_V6_LEN : IP_V4_LEN;\r\n} else {\r\nif (if_info->dhcp_state) {\r\nmemset(if_info, 0, sizeof(*if_info));\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR,\r\nsizeof(*reldhcp));\r\nif (rc)\r\ngoto exit;\r\nreldhcp = nonemb_cmd.va;\r\nreldhcp->interface_hndl = phba->interface_handle;\r\nreldhcp->ip_type = ip_type;\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0) {\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Delete existing dhcp\n");\r\ngoto exit;\r\n}\r\n}\r\n}\r\nif (if_info->ip_addr.addr[0]) {\r\nrc = mgmt_static_ip_modify(phba, if_info, ip_param, NULL,\r\nIP_ACTION_DEL);\r\nif (rc)\r\ngoto exit;\r\n}\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nmemset(&gtway_addr_set, 0, sizeof(gtway_addr_set));\r\nrc = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Get Gateway Addr\n");\r\ngoto exit;\r\n}\r\nif (gtway_addr_set.ip_addr.addr[0]) {\r\ngtway_addr = (uint8_t *)&gtway_addr_set.ip_addr.addr;\r\nrc = mgmt_modify_gateway(phba, gtway_addr,\r\nIP_ACTION_DEL, IP_V4_LEN);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to clear Gateway Addr Set\n");\r\ngoto exit;\r\n}\r\n}\r\n}\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR,\r\nsizeof(*dhcpreq));\r\nif (rc)\r\ngoto exit;\r\ndhcpreq = nonemb_cmd.va;\r\ndhcpreq->flags = BLOCKING;\r\ndhcpreq->retry_count = 1;\r\ndhcpreq->interface_hndl = phba->interface_handle;\r\ndhcpreq->ip_type = BE2_DHCP_V4;\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\n} else {\r\nrc = mgmt_static_ip_modify(phba, if_info, ip_param,\r\nsubnet_param, IP_ACTION_ADD);\r\n}\r\nexit:\r\nkfree(if_info);\r\nreturn rc;\r\n}\r\nint mgmt_set_gateway(struct beiscsi_hba *phba,\r\nstruct iscsi_iface_param_info *gateway_param)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gtway_addr_set;\r\nuint8_t *gtway_addr;\r\nint rt_val;\r\nmemset(&gtway_addr_set, 0, sizeof(gtway_addr_set));\r\nrt_val = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);\r\nif (rt_val) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Get Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nif (gtway_addr_set.ip_addr.addr[0]) {\r\ngtway_addr = (uint8_t *)&gtway_addr_set.ip_addr.addr;\r\nrt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_DEL,\r\ngateway_param->len);\r\nif (rt_val) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to clear Gateway Addr Set\n");\r\nreturn rt_val;\r\n}\r\n}\r\ngtway_addr = (uint8_t *)&gateway_param->value;\r\nrt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_ADD,\r\ngateway_param->len);\r\nif (rt_val)\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Set Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nint mgmt_get_gateway(struct beiscsi_hba *phba, int ip_type,\r\nstruct be_cmd_get_def_gateway_resp *gateway)\r\n{\r\nstruct be_cmd_get_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,\r\nsizeof(*gateway));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->ip_type = ip_type;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, gateway,\r\nsizeof(*gateway));\r\n}\r\nint mgmt_get_if_info(struct beiscsi_hba *phba, int ip_type,\r\nstruct be_cmd_get_if_info_resp **if_info)\r\n{\r\nstruct be_cmd_get_if_info_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint32_t ioctl_size = sizeof(struct be_cmd_get_if_info_resp);\r\nint rc;\r\nif (mgmt_get_all_if_id(phba))\r\nreturn -EIO;\r\ndo {\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_IF_INFO,\r\nioctl_size);\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->interface_hndl = phba->interface_handle;\r\nreq->ip_type = ip_type;\r\n*if_info = kzalloc(ioctl_size, GFP_KERNEL);\r\nif (!*if_info) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : Memory Allocation Failure\n");\r\npci_free_consistent(phba->ctrl.pdev,\r\nnonemb_cmd.size,\r\nnonemb_cmd.va,\r\nnonemb_cmd.dma);\r\nreturn -ENOMEM;\r\n}\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, *if_info,\r\nioctl_size);\r\nif (rc == -EAGAIN) {\r\nioctl_size = ((struct be_cmd_resp_hdr *)\r\nnonemb_cmd.va)->actual_resp_len;\r\nioctl_size += sizeof(struct be_cmd_req_hdr);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va,\r\nnonemb_cmd.dma);\r\nkfree(*if_info);\r\n} else\r\nbreak;\r\n} while (true);\r\nreturn rc;\r\n}\r\nint mgmt_get_nic_conf(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_nic_conf_resp *nic)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,\r\nsizeof(*nic));\r\nif (rc)\r\nreturn rc;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, nic, sizeof(*nic));\r\n}\r\nunsigned int be_cmd_get_initname(struct beiscsi_hba *phba)\r\n{\r\nunsigned int tag = 0;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_hba_name *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_CFG_GET_HBA_NAME,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba)\r\n{\r\nunsigned int tag = 0;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_ntwk_link_status_req *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_LINK_STATUS_QUERY,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,\r\nunsigned int *s_handle)\r\n{\r\nstruct be_cmd_get_boot_target_resp *boot_resp;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag;\r\nuint8_t boot_retry = 3;\r\nint rc;\r\ndo {\r\ntag = mgmt_get_boot_target(phba);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,\r\n"BG_%d : Getting Boot Target Info Failed\n");\r\nreturn -EAGAIN;\r\n}\r\nrc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : MBX CMD get_boot_target Failed\n");\r\nreturn -EBUSY;\r\n}\r\nboot_resp = embedded_payload(wrb);\r\nif (!boot_resp->boot_session_count) {\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d ;No boot targets configured\n");\r\nreturn -ENXIO;\r\n}\r\nif (boot_resp->boot_session_handle != INVALID_SESS_HANDLE) {\r\n*s_handle = boot_resp->boot_session_handle;\r\nreturn 0;\r\n}\r\ntag = mgmt_reopen_session(phba, BE_REOPEN_BOOT_SESSIONS,\r\nINVALID_SESS_HANDLE);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : mgmt_reopen_session Failed\n");\r\nreturn -EAGAIN;\r\n}\r\nrc = beiscsi_mccq_compl(phba, tag, NULL, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : mgmt_reopen_session Failed");\r\nreturn rc;\r\n}\r\n} while (--boot_retry);\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : Login to Boot Target Failed\n");\r\nreturn -ENXIO;\r\n}\r\nint mgmt_set_vlan(struct beiscsi_hba *phba,\r\nuint16_t vlan_tag)\r\n{\r\nint rc;\r\nunsigned int tag;\r\ntag = be_cmd_set_vlan(phba, vlan_tag);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR,\r\n(BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\r\n"BG_%d : VLAN Setting Failed\n");\r\nreturn -EBUSY;\r\n}\r\nrc = beiscsi_mccq_compl(phba, tag, NULL, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\n(BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\r\n"BS_%d : VLAN MBX Cmd Failed\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nssize_t\r\nbeiscsi_drvr_ver_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, BE_NAME "\n");\r\n}\r\nssize_t\r\nbeiscsi_fw_ver_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", phba->fw_ver_str);\r\n}\r\nssize_t\r\nbeiscsi_active_session_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nuint16_t avlbl_cids = 0, ulp_num, len = 0, total_cids = 0;\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\r\navlbl_cids = BEISCSI_ULP_AVLBL_CID(phba, ulp_num);\r\ntotal_cids = BEISCSI_GET_CID_COUNT(phba, ulp_num);\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num,\r\n(total_cids - avlbl_cids));\r\n} else\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num, 0);\r\n}\r\nreturn len;\r\n}\r\nssize_t\r\nbeiscsi_free_session_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nuint16_t ulp_num, len = 0;\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported))\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num,\r\nBEISCSI_ULP_AVLBL_CID(phba, ulp_num));\r\nelse\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num, 0);\r\n}\r\nreturn len;\r\n}\r\nssize_t\r\nbeiscsi_adap_family_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nuint16_t dev_id = 0;\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\ndev_id = phba->pcidev->device;\r\nswitch (dev_id) {\r\ncase BE_DEVICE_ID1:\r\ncase OC_DEVICE_ID1:\r\ncase OC_DEVICE_ID2:\r\nreturn snprintf(buf, PAGE_SIZE, "BE2 Adapter Family\n");\r\nbreak;\r\ncase BE_DEVICE_ID2:\r\ncase OC_DEVICE_ID3:\r\nreturn snprintf(buf, PAGE_SIZE, "BE3-R Adapter Family\n");\r\nbreak;\r\ncase OC_SKH_ID1:\r\nreturn snprintf(buf, PAGE_SIZE, "Skyhawk-R Adapter Family\n");\r\nbreak;\r\ndefault:\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"Unknown Adapter Family: 0x%x\n", dev_id);\r\nbreak;\r\n}\r\n}\r\nssize_t\r\nbeiscsi_phys_port_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "Port Identifier : %d\n",\r\nphba->fw_config.phys_port);\r\n}\r\nvoid beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params,\r\nstruct wrb_handle *pwrb_handle,\r\nstruct be_mem_descriptor *mem_descr)\r\n{\r\nstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\r\nmemset(pwrb, 0, sizeof(*pwrb));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nmax_send_data_segment_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, type, pwrb,\r\nBE_TGT_CTX_UPDT_CMD);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nfirst_burst_length,\r\npwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nfirst_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, erl, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nerl) / 32] & OFFLD_PARAMS_ERL));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, dde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndde) / 32] & OFFLD_PARAMS_DDE) >> 2);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, hde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nhde) / 32] & OFFLD_PARAMS_HDE) >> 3);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ir2t, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, imd, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nimd) / 32] & OFFLD_PARAMS_IMD) >> 5);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, stat_sn,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nexp_statsn) / 32] + 1));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, wrb_idx,\r\npwrb, pwrb_handle->wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nmax_burst_length, pwrb, params->dw[offsetof\r\n(struct amap_beiscsi_offload_params,\r\nmax_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ptr2nextwrb,\r\npwrb, pwrb_handle->nxt_wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nsession_state, pwrb, 0);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, compltonack,\r\npwrb, 1);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, notpredblq,\r\npwrb, 0);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, mode, pwrb,\r\n0);\r\nmem_descr += ISCSI_MEM_GLOBAL_HEADER;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\npad_buffer_addr_hi, pwrb,\r\nmem_descr->mem_array[0].bus_address.u.a32.address_hi);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\npad_buffer_addr_lo, pwrb,\r\nmem_descr->mem_array[0].bus_address.u.a32.address_lo);\r\n}\r\nvoid beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params,\r\nstruct wrb_handle *pwrb_handle)\r\n{\r\nstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\r\nmemset(pwrb, 0, sizeof(*pwrb));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_burst_length, pwrb, params->dw[offsetof\r\n(struct amap_beiscsi_offload_params,\r\nmax_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\ntype, pwrb,\r\nBE_TGT_CTX_UPDT_CMD);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nptr2nextwrb,\r\npwrb, pwrb_handle->nxt_wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, wrb_idx,\r\npwrb, pwrb_handle->wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_send_data_segment_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nfirst_burst_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nfirst_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_recv_dataseg_len, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_recv_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_cxns, pwrb, BEISCSI_MAX_CXNS);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, erl, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nerl) / 32] & OFFLD_PARAMS_ERL));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, dde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndde) / 32] & OFFLD_PARAMS_DDE) >> 2);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, hde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nhde) / 32] & OFFLD_PARAMS_HDE) >> 3);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nir2t, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, imd, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nimd) / 32] & OFFLD_PARAMS_IMD) >> 5);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\ndata_seq_inorder,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndata_seq_inorder) / 32] &\r\nOFFLD_PARAMS_DATA_SEQ_INORDER) >> 6);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\npdu_seq_inorder,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\npdu_seq_inorder) / 32] &\r\nOFFLD_PARAMS_PDU_SEQ_INORDER) >> 7);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, max_r2t,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_r2t) / 32] &\r\nOFFLD_PARAMS_MAX_R2T) >> 8);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, stat_sn,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nexp_statsn) / 32] + 1));\r\n}\r\nint beiscsi_logout_fw_sess(struct beiscsi_hba *phba,\r\nuint32_t fw_sess_handle)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_logout_fw_sess *req;\r\nstruct be_cmd_resp_logout_fw_sess *resp;\r\nunsigned int tag;\r\nint rc;\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : In bescsi_logout_fwboot_sess\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nbeiscsi_log(phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : MBX Tag Failure\n");\r\nreturn -EINVAL;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_LOGOUT_TARGET,\r\nsizeof(struct be_cmd_req_logout_fw_sess));\r\nreq->session_handle = fw_sess_handle;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nrc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : MBX CMD FW_SESSION_LOGOUT_TARGET Failed\n");\r\nreturn -EBUSY;\r\n}\r\nresp = embedded_payload(wrb);\r\nif (resp->session_status !=\r\nBEISCSI_MGMT_SESSION_CLOSE) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : FW_SESSION_LOGOUT_TARGET resp : 0x%x\n",\r\nresp->session_status);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}
