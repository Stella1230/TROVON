static inline void i2c_gate_ctrl(struct au0828_dev *dev, int val)\r\n{\r\nif (dev->dvb.frontend && dev->dvb.frontend->ops.analog_ops.i2c_gate_ctrl)\r\ndev->dvb.frontend->ops.analog_ops.i2c_gate_ctrl(dev->dvb.frontend, val);\r\n}\r\nstatic inline void print_err_status(struct au0828_dev *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\nau0828_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\nau0828_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic int check_dev(struct au0828_dev *dev)\r\n{\r\nif (dev->dev_state & DEV_DISCONNECTED) {\r\npr_info("v4l2 ioctl: device not present\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->dev_state & DEV_MISCONFIGURED) {\r\npr_info("v4l2 ioctl: device is misconfigured; "\r\n"close and open it again\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void au0828_irq_callback(struct urb *urb)\r\n{\r\nstruct au0828_dmaqueue *dma_q = urb->context;\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\r\nunsigned long flags = 0;\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nau0828_isocdbg("au0828_irq_callback called: status kill\n");\r\nreturn;\r\ndefault:\r\nau0828_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dev->slock, flags);\r\ndev->isoc_ctl.isoc_copy(dev, urb);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = 0;\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\nau0828_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\ndev->stream_state = STREAM_ON;\r\n}\r\nstatic void au0828_uninit_isoc(struct au0828_dev *dev)\r\n{\r\nstruct urb *urb;\r\nint i;\r\nau0828_isocdbg("au0828: called au0828_uninit_isoc\n");\r\ndev->isoc_ctl.nfields = -1;\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = dev->isoc_ctl.urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (dev->isoc_ctl.transfer_buffer[i]) {\r\nusb_free_coherent(dev->usbdev,\r\nurb->transfer_buffer_length,\r\ndev->isoc_ctl.transfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\ndev->isoc_ctl.urb[i] = NULL;\r\n}\r\ndev->isoc_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->isoc_ctl.urb);\r\nkfree(dev->isoc_ctl.transfer_buffer);\r\ndev->isoc_ctl.urb = NULL;\r\ndev->isoc_ctl.transfer_buffer = NULL;\r\ndev->isoc_ctl.num_bufs = 0;\r\ndev->stream_state = STREAM_OFF;\r\n}\r\nstatic int au0828_init_isoc(struct au0828_dev *dev, int max_packets,\r\nint num_bufs, int max_pkt_size,\r\nint (*isoc_copy) (struct au0828_dev *dev, struct urb *urb))\r\n{\r\nstruct au0828_dmaqueue *dma_q = &dev->vidq;\r\nint i;\r\nint sb_size, pipe;\r\nstruct urb *urb;\r\nint j, k;\r\nint rc;\r\nau0828_isocdbg("au0828: called au0828_prepare_isoc\n");\r\ndev->isoc_ctl.isoc_copy = isoc_copy;\r\ndev->isoc_ctl.num_bufs = num_bufs;\r\ndev->isoc_ctl.urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!dev->isoc_ctl.urb) {\r\nau0828_isocdbg("cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.transfer_buffer = kzalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!dev->isoc_ctl.transfer_buffer) {\r\nau0828_isocdbg("cannot allocate memory for usb transfer\n");\r\nkfree(dev->isoc_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.max_pkt_size = max_pkt_size;\r\ndev->isoc_ctl.buf = NULL;\r\nsb_size = max_packets * dev->isoc_ctl.max_pkt_size;\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = usb_alloc_urb(max_packets, GFP_KERNEL);\r\nif (!urb) {\r\nau0828_isocdbg("cannot alloc isoc_ctl.urb %i\n", i);\r\nau0828_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.urb[i] = urb;\r\ndev->isoc_ctl.transfer_buffer[i] = usb_alloc_coherent(dev->usbdev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\nif (!dev->isoc_ctl.transfer_buffer[i]) {\r\nprintk("unable to allocate %i bytes for transfer"\r\n" buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\nau0828_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->isoc_ctl.transfer_buffer[i], 0, sb_size);\r\npipe = usb_rcvisocpipe(dev->usbdev,\r\ndev->isoc_in_endpointaddr),\r\nusb_fill_int_urb(urb, dev->usbdev, pipe,\r\ndev->isoc_ctl.transfer_buffer[i], sb_size,\r\nau0828_irq_callback, dma_q, 1);\r\nurb->number_of_packets = max_packets;\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nk = 0;\r\nfor (j = 0; j < max_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\ndev->isoc_ctl.max_pkt_size;\r\nk += dev->isoc_ctl.max_pkt_size;\r\n}\r\n}\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\r\nif (rc) {\r\nau0828_isocdbg("submit of urb %i failed (error=%i)\n",\r\ni, rc);\r\nau0828_uninit_isoc(dev);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void buffer_filled(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf)\r\n{\r\nstruct vb2_buffer *vb = &buf->vb;\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nau0828_isocdbg("[%p/%d] wakeup\n", buf, buf->top_field);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nvb->v4l2_buf.sequence = dev->frame_count++;\r\nelse\r\nvb->v4l2_buf.sequence = dev->vbi_frame_count++;\r\nvb->v4l2_buf.field = V4L2_FIELD_INTERLACED;\r\nv4l2_get_timestamp(&vb->v4l2_buf.timestamp);\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\n}\r\nstatic void au0828_copy_video(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nvoid *fieldstart, *startwrite, *startread;\r\nint linesdone, currlinedone, offset, lencopy, remain;\r\nint bytesperline = dev->width << 1;\r\nif (len == 0)\r\nreturn;\r\nif (dma_q->pos + len > buf->length)\r\nlen = buf->length - dma_q->pos;\r\nstartread = p;\r\nremain = len;\r\nif (buf->top_field)\r\nfieldstart = outp;\r\nelse\r\nfieldstart = outp + bytesperline;\r\nlinesdone = dma_q->pos / bytesperline;\r\ncurrlinedone = dma_q->pos % bytesperline;\r\noffset = linesdone * bytesperline * 2 + currlinedone;\r\nstartwrite = fieldstart + offset;\r\nlencopy = bytesperline - currlinedone;\r\nlencopy = lencopy > remain ? remain : lencopy;\r\nif ((char *)startwrite + lencopy > (char *)outp + buf->length) {\r\nau0828_isocdbg("Overflow of %zi bytes past buffer end (1)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->length));\r\nremain = (char *)outp + buf->length - (char *)startwrite;\r\nlencopy = remain;\r\n}\r\nif (lencopy <= 0)\r\nreturn;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\nwhile (remain > 0) {\r\nstartwrite += lencopy + bytesperline;\r\nstartread += lencopy;\r\nif (bytesperline > remain)\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline;\r\nif ((char *)startwrite + lencopy > (char *)outp +\r\nbuf->length) {\r\nau0828_isocdbg("Overflow %zi bytes past buf end (2)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->length));\r\nlencopy = remain = (char *)outp + buf->length -\r\n(char *)startwrite;\r\n}\r\nif (lencopy <= 0)\r\nbreak;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\n}\r\nif (offset > 1440) {\r\nif (outp[0] < 0x60 && outp[1440] < 0x60)\r\ndev->greenscreen_detected = 1;\r\n}\r\ndma_q->pos += len;\r\n}\r\nstatic inline void get_next_buf(struct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer **buf)\r\n{\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\r\nif (list_empty(&dma_q->active)) {\r\nau0828_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct au0828_buffer, list);\r\nlist_del(&(*buf)->list);\r\ndma_q->pos = 0;\r\n(*buf)->vb_buf = (*buf)->mem;\r\ndev->isoc_ctl.buf = *buf;\r\nreturn;\r\n}\r\nstatic void au0828_copy_vbi(struct au0828_dev *dev,\r\nstruct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nunsigned char *startwrite, *startread;\r\nint bytesperline;\r\nint i, j = 0;\r\nif (dev == NULL) {\r\nau0828_isocdbg("dev is null\n");\r\nreturn;\r\n}\r\nif (dma_q == NULL) {\r\nau0828_isocdbg("dma_q is null\n");\r\nreturn;\r\n}\r\nif (buf == NULL)\r\nreturn;\r\nif (p == NULL) {\r\nau0828_isocdbg("p is null\n");\r\nreturn;\r\n}\r\nif (outp == NULL) {\r\nau0828_isocdbg("outp is null\n");\r\nreturn;\r\n}\r\nbytesperline = dev->vbi_width;\r\nif (dma_q->pos + len > buf->length)\r\nlen = buf->length - dma_q->pos;\r\nstartread = p;\r\nstartwrite = outp + (dma_q->pos / 2);\r\nif (buf->top_field == 0)\r\nstartwrite += bytesperline * dev->vbi_height;\r\nfor (i = 0; i < len; i += 2)\r\nstartwrite[j++] = startread[i+1];\r\ndma_q->pos += len;\r\n}\r\nstatic inline void vbi_get_next_buf(struct au0828_dmaqueue *dma_q,\r\nstruct au0828_buffer **buf)\r\n{\r\nstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vbiq);\r\nif (list_empty(&dma_q->active)) {\r\nau0828_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.vbi_buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct au0828_buffer, list);\r\nlist_del(&(*buf)->list);\r\ndma_q->pos = 0;\r\n(*buf)->vb_buf = (*buf)->mem;\r\ndev->isoc_ctl.vbi_buf = *buf;\r\nreturn;\r\n}\r\nstatic inline int au0828_isoc_copy(struct au0828_dev *dev, struct urb *urb)\r\n{\r\nstruct au0828_buffer *buf;\r\nstruct au0828_buffer *vbi_buf;\r\nstruct au0828_dmaqueue *dma_q = urb->context;\r\nstruct au0828_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nunsigned char *outp = NULL;\r\nunsigned char *vbioutp = NULL;\r\nint i, len = 0, rc = 1;\r\nunsigned char *p;\r\nunsigned char fbyte;\r\nunsigned int vbi_field_size;\r\nunsigned int remain, lencopy;\r\nif (!dev)\r\nreturn 0;\r\nif ((dev->dev_state & DEV_DISCONNECTED) ||\r\n(dev->dev_state & DEV_MISCONFIGURED))\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nbuf = dev->isoc_ctl.buf;\r\nif (buf != NULL)\r\noutp = vb2_plane_vaddr(&buf->vb, 0);\r\nvbi_buf = dev->isoc_ctl.vbi_buf;\r\nif (vbi_buf != NULL)\r\nvbioutp = vb2_plane_vaddr(&vbi_buf->vb, 0);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length <= 0)\r\ncontinue;\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->max_pkt_size) {\r\nau0828_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nfbyte = p[0];\r\nlen = urb->iso_frame_desc[i].actual_length - 4;\r\np += 4;\r\nif (fbyte & 0x80) {\r\nlen -= 4;\r\np += 4;\r\nau0828_isocdbg("Video frame %s\n",\r\n(fbyte & 0x40) ? "odd" : "even");\r\nif (fbyte & 0x40) {\r\nif (vbi_buf != NULL)\r\nbuffer_filled(dev, vbi_dma_q, vbi_buf);\r\nvbi_get_next_buf(vbi_dma_q, &vbi_buf);\r\nif (vbi_buf == NULL)\r\nvbioutp = NULL;\r\nelse\r\nvbioutp = vb2_plane_vaddr(\r\n&vbi_buf->vb, 0);\r\nif (buf != NULL)\r\nbuffer_filled(dev, dma_q, buf);\r\nget_next_buf(dma_q, &buf);\r\nif (buf == NULL)\r\noutp = NULL;\r\nelse\r\noutp = vb2_plane_vaddr(&buf->vb, 0);\r\nif (dev->vid_timeout_running)\r\nmod_timer(&dev->vid_timeout,\r\njiffies + (HZ / 10));\r\nif (dev->vbi_timeout_running)\r\nmod_timer(&dev->vbi_timeout,\r\njiffies + (HZ / 10));\r\n}\r\nif (buf != NULL) {\r\nif (fbyte & 0x40)\r\nbuf->top_field = 1;\r\nelse\r\nbuf->top_field = 0;\r\n}\r\nif (vbi_buf != NULL) {\r\nif (fbyte & 0x40)\r\nvbi_buf->top_field = 1;\r\nelse\r\nvbi_buf->top_field = 0;\r\n}\r\ndev->vbi_read = 0;\r\nvbi_dma_q->pos = 0;\r\ndma_q->pos = 0;\r\n}\r\nvbi_field_size = dev->vbi_width * dev->vbi_height * 2;\r\nif (dev->vbi_read < vbi_field_size) {\r\nremain = vbi_field_size - dev->vbi_read;\r\nif (len < remain)\r\nlencopy = len;\r\nelse\r\nlencopy = remain;\r\nif (vbi_buf != NULL)\r\nau0828_copy_vbi(dev, vbi_dma_q, vbi_buf, p,\r\nvbioutp, len);\r\nlen -= lencopy;\r\np += lencopy;\r\ndev->vbi_read += lencopy;\r\n}\r\nif (dev->vbi_read >= vbi_field_size && buf != NULL)\r\nau0828_copy_video(dev, dma_q, buf, p, outp, len);\r\n}\r\nreturn rc;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vq);\r\nunsigned long img_size = dev->height * dev->bytesperline;\r\nunsigned long size;\r\nsize = fmt ? fmt->fmt.pix.sizeimage : img_size;\r\nif (size < img_size)\r\nreturn -EINVAL;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct au0828_buffer *buf = container_of(vb, struct au0828_buffer, vb);\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nbuf->length = dev->height * dev->bytesperline;\r\nif (vb2_plane_size(vb, 0) < buf->length) {\r\npr_err("%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), buf->length);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb, 0, buf->length);\r\nreturn 0;\r\n}\r\nstatic void\r\nbuffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct au0828_buffer *buf = container_of(vb,\r\nstruct au0828_buffer,\r\nvb);\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct au0828_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nlist_add_tail(&buf->list, &vidq->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int au0828_i2s_init(struct au0828_dev *dev)\r\n{\r\nau0828_writereg(dev, AU0828_AUDIOCTRL_50C, 0x01);\r\nreturn 0;\r\n}\r\nstatic int au0828_analog_stream_enable(struct au0828_dev *d)\r\n{\r\nstruct usb_interface *iface;\r\nint ret, h, w;\r\ndprintk(1, "au0828_analog_stream_enable called\n");\r\niface = usb_ifnum_to_if(d->usbdev, 0);\r\nif (iface && iface->cur_altsetting->desc.bAlternateSetting != 5) {\r\ndprintk(1, "Changing intf#0 to alt 5\n");\r\nret = usb_set_interface(d->usbdev, 0, 5);\r\nif (ret < 0) {\r\npr_info("Au0828 can't set alt setting to 5!\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nh = d->height / 2 + 2;\r\nw = d->width * 2;\r\nau0828_writereg(d, AU0828_SENSORCTRL_VBI_103, 0x00);\r\nau0828_writereg(d, 0x106, 0x00);\r\nau0828_writereg(d, 0x110, 0x00);\r\nau0828_writereg(d, 0x111, 0x00);\r\nau0828_writereg(d, 0x114, w & 0xff);\r\nau0828_writereg(d, 0x115, w >> 8);\r\nau0828_writereg(d, 0x112, 0x00);\r\nau0828_writereg(d, 0x113, 0x00);\r\nau0828_writereg(d, 0x116, h & 0xff);\r\nau0828_writereg(d, 0x117, h >> 8);\r\nau0828_writereg(d, AU0828_SENSORCTRL_100, 0xb3);\r\nreturn 0;\r\n}\r\nstatic int au0828_analog_stream_disable(struct au0828_dev *d)\r\n{\r\ndprintk(1, "au0828_analog_stream_disable called\n");\r\nau0828_writereg(d, AU0828_SENSORCTRL_100, 0x0);\r\nreturn 0;\r\n}\r\nstatic void au0828_analog_stream_reset(struct au0828_dev *dev)\r\n{\r\ndprintk(1, "au0828_analog_stream_reset called\n");\r\nau0828_writereg(dev, AU0828_SENSORCTRL_100, 0x0);\r\nmdelay(30);\r\nau0828_writereg(dev, AU0828_SENSORCTRL_100, 0xb3);\r\n}\r\nstatic int au0828_stream_interrupt(struct au0828_dev *dev)\r\n{\r\nint ret = 0;\r\ndev->stream_state = STREAM_INTERRUPT;\r\nif (dev->dev_state == DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nelse if (ret) {\r\ndev->dev_state = DEV_MISCONFIGURED;\r\ndprintk(1, "%s device is misconfigured!\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint au0828_start_analog_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vq);\r\nint rc = 0;\r\ndprintk(1, "au0828_start_analog_streaming called %d\n",\r\ndev->streaming_users);\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ndev->frame_count = 0;\r\nelse\r\ndev->vbi_frame_count = 0;\r\nif (dev->streaming_users == 0) {\r\nau0828_i2s_init(dev);\r\nrc = au0828_init_isoc(dev, AU0828_ISO_PACKETS_PER_URB,\r\nAU0828_MAX_ISO_BUFS, dev->max_pkt_size,\r\nau0828_isoc_copy);\r\nif (rc < 0) {\r\npr_info("au0828_init_isoc failed\n");\r\nreturn rc;\r\n}\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video,\r\ns_stream, 1);\r\ndev->vid_timeout_running = 1;\r\nmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\r\n} else if (vq->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\ndev->vbi_timeout_running = 1;\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\n}\r\n}\r\ndev->streaming_users++;\r\nreturn rc;\r\n}\r\nstatic void au0828_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vq);\r\nstruct au0828_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\ndprintk(1, "au0828_stop_streaming called %d\n", dev->streaming_users);\r\nif (dev->streaming_users-- == 1)\r\nau0828_uninit_isoc(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\r\ndev->vid_timeout_running = 0;\r\ndel_timer_sync(&dev->vid_timeout);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->isoc_ctl.buf != NULL) {\r\nvb2_buffer_done(&dev->isoc_ctl.buf->vb, VB2_BUF_STATE_ERROR);\r\ndev->isoc_ctl.buf = NULL;\r\n}\r\nwhile (!list_empty(&vidq->active)) {\r\nstruct au0828_buffer *buf;\r\nbuf = list_entry(vidq->active.next, struct au0828_buffer, list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nlist_del(&buf->list);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nvoid au0828_stop_vbi_streaming(struct vb2_queue *vq)\r\n{\r\nstruct au0828_dev *dev = vb2_get_drv_priv(vq);\r\nstruct au0828_dmaqueue *vbiq = &dev->vbiq;\r\nunsigned long flags = 0;\r\ndprintk(1, "au0828_stop_vbi_streaming called %d\n",\r\ndev->streaming_users);\r\nif (dev->streaming_users-- == 1)\r\nau0828_uninit_isoc(dev);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->isoc_ctl.vbi_buf != NULL) {\r\nvb2_buffer_done(&dev->isoc_ctl.vbi_buf->vb,\r\nVB2_BUF_STATE_ERROR);\r\ndev->isoc_ctl.vbi_buf = NULL;\r\n}\r\nwhile (!list_empty(&vbiq->active)) {\r\nstruct au0828_buffer *buf;\r\nbuf = list_entry(vbiq->active.next, struct au0828_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ndev->vbi_timeout_running = 0;\r\ndel_timer_sync(&dev->vbi_timeout);\r\n}\r\nvoid au0828_analog_unregister(struct au0828_dev *dev)\r\n{\r\ndprintk(1, "au0828_analog_unregister called\n");\r\nmutex_lock(&au0828_sysfs_lock);\r\nvideo_unregister_device(&dev->vdev);\r\nvideo_unregister_device(&dev->vbi_dev);\r\nmutex_unlock(&au0828_sysfs_lock);\r\n}\r\nstatic void au0828_vid_buffer_timeout(unsigned long data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) data;\r\nstruct au0828_dmaqueue *dma_q = &dev->vidq;\r\nstruct au0828_buffer *buf;\r\nunsigned char *vid_data;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf = dev->isoc_ctl.buf;\r\nif (buf != NULL) {\r\nvid_data = vb2_plane_vaddr(&buf->vb, 0);\r\nmemset(vid_data, 0x00, buf->length);\r\nbuffer_filled(dev, dma_q, buf);\r\n}\r\nget_next_buf(dma_q, &buf);\r\nif (dev->vid_timeout_running == 1)\r\nmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic void au0828_vbi_buffer_timeout(unsigned long data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) data;\r\nstruct au0828_dmaqueue *dma_q = &dev->vbiq;\r\nstruct au0828_buffer *buf;\r\nunsigned char *vbi_data;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf = dev->isoc_ctl.vbi_buf;\r\nif (buf != NULL) {\r\nvbi_data = vb2_plane_vaddr(&buf->vb, 0);\r\nmemset(vbi_data, 0x00, buf->length);\r\nbuffer_filled(dev, dma_q, buf);\r\n}\r\nvbi_get_next_buf(dma_q, &buf);\r\nif (dev->vbi_timeout_running == 1)\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int au0828_v4l2_open(struct file *filp)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(filp);\r\nint ret;\r\ndprintk(1,\r\n"%s called std_set %d dev_state %d stream users %d users %d\n",\r\n__func__, dev->std_set_in_tuner_core, dev->dev_state,\r\ndev->streaming_users, dev->users);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(filp);\r\nif (ret) {\r\nau0828_isocdbg("%s: v4l2_fh_open() returned error %d\n",\r\n__func__, ret);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nif (dev->users == 0) {\r\nau0828_analog_stream_enable(dev);\r\nau0828_analog_stream_reset(dev);\r\ndev->stream_state = STREAM_OFF;\r\ndev->dev_state |= DEV_INITIALIZED;\r\n}\r\ndev->users++;\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int au0828_v4l2_close(struct file *filp)\r\n{\r\nint ret;\r\nstruct au0828_dev *dev = video_drvdata(filp);\r\nstruct video_device *vdev = video_devdata(filp);\r\ndprintk(1,\r\n"%s called std_set %d dev_state %d stream users %d users %d\n",\r\n__func__, dev->std_set_in_tuner_core, dev->dev_state,\r\ndev->streaming_users, dev->users);\r\nmutex_lock(&dev->lock);\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER && dev->vid_timeout_running) {\r\ndev->vid_timeout_running = 0;\r\ndel_timer_sync(&dev->vid_timeout);\r\n} else if (vdev->vfl_type == VFL_TYPE_VBI &&\r\ndev->vbi_timeout_running) {\r\ndev->vbi_timeout_running = 0;\r\ndel_timer_sync(&dev->vbi_timeout);\r\n}\r\nif (dev->dev_state == DEV_DISCONNECTED)\r\ngoto end;\r\nif (dev->users == 1) {\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_power, 0);\r\ndev->std_set_in_tuner_core = 0;\r\nret = usb_set_interface(dev->usbdev, 0, 0);\r\nif (ret < 0)\r\npr_info("Au0828 can't set alternate to 0!\n");\r\n}\r\nend:\r\n_vb2_fop_release(filp, NULL);\r\ndev->users--;\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic void au0828_init_tuner(struct au0828_dev *dev)\r\n{\r\nstruct v4l2_frequency f = {\r\n.frequency = dev->ctrl_freq,\r\n.type = V4L2_TUNER_ANALOG_TV,\r\n};\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nif (dev->std_set_in_tuner_core)\r\nreturn;\r\ndev->std_set_in_tuner_core = 1;\r\ni2c_gate_ctrl(dev, 1);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std, dev->std);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, &f);\r\ni2c_gate_ctrl(dev, 0);\r\n}\r\nstatic int au0828_set_format(struct au0828_dev *dev, unsigned int cmd,\r\nstruct v4l2_format *format)\r\n{\r\nint ret;\r\nint width = format->fmt.pix.width;\r\nint height = format->fmt.pix.height;\r\nif (format->fmt.pix.pixelformat != V4L2_PIX_FMT_UYVY)\r\nreturn -EINVAL;\r\nif (width != 720)\r\nwidth = 720;\r\nif (height != 480)\r\nheight = 480;\r\nformat->fmt.pix.width = width;\r\nformat->fmt.pix.height = height;\r\nformat->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nformat->fmt.pix.bytesperline = width * 2;\r\nformat->fmt.pix.sizeimage = width * height * 2;\r\nformat->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nformat->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nformat->fmt.pix.priv = 0;\r\nif (cmd == VIDIOC_TRY_FMT)\r\nreturn 0;\r\ndev->width = width;\r\ndev->height = height;\r\ndev->frame_size = width * height * 2;\r\ndev->field_size = width * height;\r\ndev->bytesperline = width * 2;\r\nif (dev->stream_state == STREAM_ON) {\r\ndprintk(1, "VIDIOC_SET_FMT: interrupting stream!\n");\r\nret = au0828_stream_interrupt(dev);\r\nif (ret != 0) {\r\ndprintk(1, "error interrupting video stream!\n");\r\nreturn ret;\r\n}\r\n}\r\nau0828_analog_stream_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nstrlcpy(cap->driver, "au0828", sizeof(cap->driver));\r\nstrlcpy(cap->card, dev->board.name, sizeof(cap->card));\r\nusb_make_path(dev->usbdev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_TUNER;\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER)\r\ncap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\r\nelse\r\ncap->device_caps |= V4L2_CAP_VBI_CAPTURE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |\r\nV4L2_CAP_VBI_CAPTURE | V4L2_CAP_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called\n", __func__);\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(f->description, "Packed YUV2");\r\nf->flags = 0;\r\nf->pixelformat = V4L2_PIX_FMT_UYVY;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nf->fmt.pix.bytesperline = dev->bytesperline;\r\nf->fmt.pix.sizeimage = dev->frame_size;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nreturn au0828_set_format(dev, VIDIOC_TRY_FMT, f);\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nint rc;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (vb2_is_busy(&dev->vb_vidq)) {\r\npr_info("%s queue busy\n", __func__);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nrc = au0828_set_format(dev, VIDIOC_S_FMT, f);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nif (norm == dev->std)\r\nreturn 0;\r\nif (dev->streaming_users > 0)\r\nreturn -EBUSY;\r\ndev->std = norm;\r\nau0828_init_tuner(dev);\r\ni2c_gate_ctrl(dev, 1);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std, norm);\r\ni2c_gate_ctrl(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\n*norm = dev->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nunsigned int tmp;\r\nstatic const char *inames[] = {\r\n[AU0828_VMUX_UNDEFINED] = "Undefined",\r\n[AU0828_VMUX_COMPOSITE] = "Composite",\r\n[AU0828_VMUX_SVIDEO] = "S-Video",\r\n[AU0828_VMUX_CABLE] = "Cable TV",\r\n[AU0828_VMUX_TELEVISION] = "Television",\r\n[AU0828_VMUX_DVB] = "DVB",\r\n[AU0828_VMUX_DEBUG] = "tv debug"\r\n};\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\ntmp = input->index;\r\nif (tmp >= AU0828_MAX_INPUT)\r\nreturn -EINVAL;\r\nif (AUVI_INPUT(tmp).type == 0)\r\nreturn -EINVAL;\r\ninput->index = tmp;\r\nstrcpy(input->name, inames[AUVI_INPUT(tmp).type]);\r\nif ((AUVI_INPUT(tmp).type == AU0828_VMUX_TELEVISION) ||\r\n(AUVI_INPUT(tmp).type == AU0828_VMUX_CABLE)) {\r\ninput->type |= V4L2_INPUT_TYPE_TUNER;\r\ninput->audioset = 1;\r\n} else {\r\ninput->type |= V4L2_INPUT_TYPE_CAMERA;\r\ninput->audioset = 2;\r\n}\r\ninput->std = dev->vdev.tvnorms;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\n*i = dev->ctrl_input;\r\nreturn 0;\r\n}\r\nstatic void au0828_s_input(struct au0828_dev *dev, int index)\r\n{\r\nint i;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nswitch (AUVI_INPUT(index).type) {\r\ncase AU0828_VMUX_SVIDEO:\r\ndev->input_type = AU0828_VMUX_SVIDEO;\r\ndev->ctrl_ainput = 1;\r\nbreak;\r\ncase AU0828_VMUX_COMPOSITE:\r\ndev->input_type = AU0828_VMUX_COMPOSITE;\r\ndev->ctrl_ainput = 1;\r\nbreak;\r\ncase AU0828_VMUX_TELEVISION:\r\ndev->input_type = AU0828_VMUX_TELEVISION;\r\ndev->ctrl_ainput = 0;\r\nbreak;\r\ndefault:\r\ndprintk(1, "unknown input type set [%d]\n",\r\nAUVI_INPUT(index).type);\r\nbreak;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\r\nAUVI_INPUT(index).vmux, 0, 0);\r\nfor (i = 0; i < AU0828_MAX_INPUT; i++) {\r\nint enable = 0;\r\nif (AUVI_INPUT(i).audio_setup == NULL)\r\ncontinue;\r\nif (i == index)\r\nenable = 1;\r\nelse\r\nenable = 0;\r\nif (enable) {\r\n(AUVI_INPUT(i).audio_setup)(dev, enable);\r\n} else {\r\nif ((AUVI_INPUT(i).audio_setup) !=\r\n((AUVI_INPUT(index).audio_setup))) {\r\n(AUVI_INPUT(i).audio_setup)(dev, enable);\r\n}\r\n}\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, audio, s_routing,\r\nAUVI_INPUT(index).amux, 0, 0);\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "VIDIOC_S_INPUT in function %s, input=%d\n", __func__,\r\nindex);\r\nif (index >= AU0828_MAX_INPUT)\r\nreturn -EINVAL;\r\nif (AUVI_INPUT(index).type == 0)\r\nreturn -EINVAL;\r\ndev->ctrl_input = index;\r\nau0828_s_input(dev, index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enumaudio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nif (a->index > 1)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called\n", __func__);\r\nif (a->index == 0)\r\nstrcpy(a->name, "Television");\r\nelse\r\nstrcpy(a->name, "Line in");\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\na->index = dev->ctrl_ainput;\r\nif (a->index == 0)\r\nstrcpy(a->name, "Television");\r\nelse\r\nstrcpy(a->name, "Line in");\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *a)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nif (a->index != dev->ctrl_ainput)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nstrcpy(t->name, "Auvitek tuner");\r\nau0828_init_tuner(dev);\r\ni2c_gate_ctrl(dev, 1);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\ni2c_gate_ctrl(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nau0828_init_tuner(dev);\r\ni2c_gate_ctrl(dev, 1);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\ni2c_gate_ctrl(dev, 0);\r\ndprintk(1, "VIDIOC_S_TUNER: signal = %x, afc = %x\n", t->signal,\r\nt->afc);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nif (freq->tuner != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nfreq->frequency = dev->ctrl_freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *freq)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nstruct v4l2_frequency new_freq = *freq;\r\nif (freq->tuner != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nau0828_init_tuner(dev);\r\ni2c_gate_ctrl(dev, 1);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, freq);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_frequency, &new_freq);\r\ndev->ctrl_freq = new_freq.frequency;\r\ni2c_gate_ctrl(dev, 0);\r\nau0828_analog_stream_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nformat->fmt.vbi.samples_per_line = dev->vbi_width;\r\nformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nformat->fmt.vbi.offset = 0;\r\nformat->fmt.vbi.flags = 0;\r\nformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\r\nformat->fmt.vbi.count[0] = dev->vbi_height;\r\nformat->fmt.vbi.count[1] = dev->vbi_height;\r\nformat->fmt.vbi.start[0] = 21;\r\nformat->fmt.vbi.start[1] = 284;\r\nmemset(format->fmt.vbi.reserved, 0, sizeof(format->fmt.vbi.reserved));\r\nreturn 0;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cc)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\ncc->bounds.left = 0;\r\ncc->bounds.top = 0;\r\ncc->bounds.width = dev->width;\r\ncc->bounds.height = dev->height;\r\ncc->defrect = cc->bounds;\r\ncc->pixelaspect.numerator = 54;\r\ncc->pixelaspect.denominator = 59;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nreg->val = au0828_read(dev, reg->reg);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct au0828_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s called std_set %d dev_state %d\n", __func__,\r\ndev->std_set_in_tuner_core, dev->dev_state);\r\nreturn au0828_writereg(dev, reg->reg, reg->val);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *fh)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\ndprintk(1, "%s called\n", __func__);\r\nv4l2_ctrl_log_status(file, fh);\r\nv4l2_device_call_all(vdev->v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nvoid au0828_v4l2_suspend(struct au0828_dev *dev)\r\n{\r\nstruct urb *urb;\r\nint i;\r\npr_info("stopping V4L2\n");\r\nif (dev->stream_state == STREAM_ON) {\r\npr_info("stopping V4L2 active URBs\n");\r\nau0828_analog_stream_disable(dev);\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = dev->isoc_ctl.urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\n}\r\n}\r\n}\r\nif (dev->vid_timeout_running)\r\ndel_timer_sync(&dev->vid_timeout);\r\nif (dev->vbi_timeout_running)\r\ndel_timer_sync(&dev->vbi_timeout);\r\n}\r\nvoid au0828_v4l2_resume(struct au0828_dev *dev)\r\n{\r\nint i, rc;\r\npr_info("restarting V4L2\n");\r\nif (dev->stream_state == STREAM_ON) {\r\nau0828_stream_interrupt(dev);\r\nau0828_init_tuner(dev);\r\n}\r\nif (dev->vid_timeout_running)\r\nmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\r\nif (dev->vbi_timeout_running)\r\nmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\r\nau0828_i2s_init(dev);\r\nau0828_analog_stream_enable(dev);\r\nif (!(dev->stream_state == STREAM_ON)) {\r\nau0828_analog_stream_reset(dev);\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\r\nif (rc) {\r\nau0828_isocdbg("submit of urb %i failed (error=%i)\n",\r\ni, rc);\r\nau0828_uninit_isoc(dev);\r\n}\r\n}\r\n}\r\n}\r\nstatic int au0828_vb2_setup(struct au0828_dev *dev)\r\n{\r\nint rc;\r\nstruct vb2_queue *q;\r\nq = &dev->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct au0828_buffer);\r\nq->ops = &au0828_video_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nrc = vb2_queue_init(q);\r\nif (rc < 0)\r\nreturn rc;\r\nq = &dev->vb_vbiq;\r\nq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct au0828_buffer);\r\nq->ops = &au0828_vbi_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nrc = vb2_queue_init(q);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nint au0828_analog_register(struct au0828_dev *dev,\r\nstruct usb_interface *interface)\r\n{\r\nint retval = -ENOMEM;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i, ret;\r\ndprintk(1, "au0828_analog_register called for intf#%d!\n",\r\ninterface->cur_altsetting->desc.bInterfaceNumber);\r\nretval = usb_set_interface(dev->usbdev,\r\ninterface->cur_altsetting->desc.bInterfaceNumber, 5);\r\nif (retval != 0) {\r\npr_info("Failure setting usb interface0 to as5\n");\r\nreturn retval;\r\n}\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\r\n== USB_DIR_IN) &&\r\n((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_ISOC)) {\r\nu16 tmp = le16_to_cpu(endpoint->wMaxPacketSize);\r\ndev->max_pkt_size = (tmp & 0x07ff) *\r\n(((tmp & 0x1800) >> 11) + 1);\r\ndev->isoc_in_endpointaddr = endpoint->bEndpointAddress;\r\ndprintk(1,\r\n"Found isoc endpoint 0x%02x, max size = %d\n",\r\ndev->isoc_in_endpointaddr, dev->max_pkt_size);\r\n}\r\n}\r\nif (!(dev->isoc_in_endpointaddr)) {\r\npr_info("Could not locate isoc endpoint\n");\r\nreturn -ENODEV;\r\n}\r\ninit_waitqueue_head(&dev->open);\r\nspin_lock_init(&dev->slock);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nsetup_timer(&dev->vid_timeout, au0828_vid_buffer_timeout,\r\n(unsigned long)dev);\r\nsetup_timer(&dev->vbi_timeout, au0828_vbi_buffer_timeout,\r\n(unsigned long)dev);\r\ndev->width = NTSC_STD_W;\r\ndev->height = NTSC_STD_H;\r\ndev->field_size = dev->width * dev->height;\r\ndev->frame_size = dev->field_size << 1;\r\ndev->bytesperline = dev->width << 1;\r\ndev->vbi_width = 720;\r\ndev->vbi_height = 1;\r\ndev->ctrl_ainput = 0;\r\ndev->ctrl_freq = 960;\r\ndev->std = V4L2_STD_NTSC_M;\r\nau0828_s_input(dev, 0);\r\nmutex_init(&dev->vb_queue_lock);\r\nmutex_init(&dev->vb_vbi_queue_lock);\r\ndev->vdev = au0828_video_template;\r\ndev->vdev.v4l2_dev = &dev->v4l2_dev;\r\ndev->vdev.lock = &dev->lock;\r\ndev->vdev.queue = &dev->vb_vidq;\r\ndev->vdev.queue->lock = &dev->vb_queue_lock;\r\nstrcpy(dev->vdev.name, "au0828a video");\r\ndev->vbi_dev = au0828_video_template;\r\ndev->vbi_dev.v4l2_dev = &dev->v4l2_dev;\r\ndev->vbi_dev.lock = &dev->lock;\r\ndev->vbi_dev.queue = &dev->vb_vbiq;\r\ndev->vbi_dev.queue->lock = &dev->vb_vbi_queue_lock;\r\nstrcpy(dev->vbi_dev.name, "au0828a vbi");\r\nretval = au0828_vb2_setup(dev);\r\nif (retval != 0) {\r\ndprintk(1, "unable to setup videobuf2 queues (error = %d).\n",\r\nretval);\r\nreturn -ENODEV;\r\n}\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nretval = video_register_device(&dev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (retval != 0) {\r\ndprintk(1, "unable to register video device (error = %d).\n",\r\nretval);\r\nret = -ENODEV;\r\ngoto err_reg_vdev;\r\n}\r\nvideo_set_drvdata(&dev->vbi_dev, dev);\r\nretval = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI, -1);\r\nif (retval != 0) {\r\ndprintk(1, "unable to register vbi device (error = %d).\n",\r\nretval);\r\nret = -ENODEV;\r\ngoto err_reg_vbi_dev;\r\n}\r\ndprintk(1, "%s completed!\n", __func__);\r\nreturn 0;\r\nerr_reg_vbi_dev:\r\nvideo_unregister_device(&dev->vdev);\r\nerr_reg_vdev:\r\nvb2_queue_release(&dev->vb_vidq);\r\nvb2_queue_release(&dev->vb_vbiq);\r\nreturn ret;\r\n}
