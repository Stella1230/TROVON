static inline void sleep(unsigned sec)\r\n{\r\nschedule_timeout_interruptible(sec * HZ);\r\n}\r\nstatic int me_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 16)\r\nmask = 0x0000ffff;\r\nelse\r\nmask = 0xffff0000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\nif (s->io_bits & 0x0000ffff)\r\ndevpriv->control_2 |= ENABLE_PORT_A;\r\nelse\r\ndevpriv->control_2 &= ~ENABLE_PORT_A;\r\nif (s->io_bits & 0xffff0000)\r\ndevpriv->control_2 |= ENABLE_PORT_B;\r\nelse\r\ndevpriv->control_2 &= ~ENABLE_PORT_B;\r\nwritew(devpriv->control_2, dev->mmio + ME_CONTROL_2);\r\nreturn insn->n;\r\n}\r\nstatic int me_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nvoid __iomem *mmio_porta = dev->mmio + ME_DIO_PORT_A;\r\nvoid __iomem *mmio_portb = dev->mmio + ME_DIO_PORT_B;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0x0000ffff)\r\nwritew((s->state & 0xffff), mmio_porta);\r\nif (mask & 0xffff0000)\r\nwritew(((s->state >> 16) & 0xffff), mmio_portb);\r\n}\r\nif (s->io_bits & 0x0000ffff)\r\nval = s->state & 0xffff;\r\nelse\r\nval = readw(mmio_porta);\r\nif (s->io_bits & 0xffff0000)\r\nval |= (s->state & 0xffff0000);\r\nelse\r\nval |= (readw(mmio_portb) << 16);\r\ndata[1] = val;\r\nreturn insn->n;\r\n}\r\nstatic int me_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readw(dev->mmio + ME_STATUS);\r\nif ((status & 0x0004) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int me_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *dev_private = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int rang = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned short val;\r\nint ret;\r\ndev_private->control_1 &= 0xFFFC;\r\nwritew(dev_private->control_1, dev->mmio + ME_CONTROL_1);\r\ndev_private->control_2 &= ~(ENABLE_ADFIFO | ENABLE_CHANLIST);\r\nwritew(dev_private->control_2, dev->mmio + ME_CONTROL_2);\r\nwritew(0x00, dev->mmio + ME_RESET_INTERRUPT);\r\ndev_private->control_2 |= (ENABLE_ADFIFO | ENABLE_CHANLIST);\r\nwritew(dev_private->control_2, dev->mmio + ME_CONTROL_2);\r\nval = chan & 0x0f;\r\nval |= (rang & 0x03) << 4;\r\nval |= (rang & 0x04) << 4;\r\nval |= ((aref & AREF_DIFF) ? 0x80 : 0);\r\nwritew(val & 0xff, dev->mmio + ME_CHANNEL_LIST);\r\ndev_private->control_1 |= SOFTWARE_TRIGGERED_ADC;\r\nwritew(dev_private->control_1, dev->mmio + ME_CONTROL_1);\r\nreadw(dev->mmio + ME_ADC_START);\r\nret = comedi_timeout(dev, s, insn, me_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nval = readw(dev->mmio + ME_READ_AD_FIFO);\r\nval = (val ^ 0x800) & 0x0fff;\r\ndata[0] = val;\r\ndev_private->control_1 &= 0xFFFC;\r\nwritew(dev_private->control_1, dev->mmio + ME_CONTROL_1);\r\nreturn 1;\r\n}\r\nstatic int me_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *dev_private = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int rang = CR_RANGE(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\ndev_private->control_2 |= ENABLE_DAC;\r\nwritew(dev_private->control_2, dev->mmio + ME_CONTROL_2);\r\ndev_private->control_2 |= BUFFERED_DAC;\r\nwritew(dev_private->control_2, dev->mmio + ME_CONTROL_2);\r\nfor (i = 0; i < insn->n; i++) {\r\ndev_private->dac_control &= ~(0x0880 >> chan);\r\nif (rang == 0)\r\ndev_private->dac_control |=\r\n((DAC_BIPOLAR_A | DAC_GAIN_1_A) >> chan);\r\nelse if (rang == 1)\r\ndev_private->dac_control |=\r\n((DAC_BIPOLAR_A | DAC_GAIN_0_A) >> chan);\r\n}\r\nwritew(dev_private->dac_control, dev->mmio + ME_DAC_CONTROL);\r\nreadw(dev->mmio + ME_DAC_CONTROL_UPDATE);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\nwritew(val, dev->mmio + ME_DAC_DATA_A + (chan << 1));\r\n}\r\ns->readback[chan] = val;\r\nreadw(dev->mmio + ME_DAC_UPDATE);\r\nreturn insn->n;\r\n}\r\nstatic int me2600_xilinx_download(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct me_private_data *dev_private = dev->private;\r\nunsigned int value;\r\nunsigned int file_length;\r\nunsigned int i;\r\nwritel(0x00, dev_private->plx_regbase + PLX9052_INTCSR);\r\nvalue = readw(dev->mmio + XILINX_DOWNLOAD_RESET);\r\nsleep(1);\r\nwriteb(0x00, dev->mmio + 0x0);\r\nsleep(1);\r\nif (size < 16)\r\nreturn -EINVAL;\r\nfile_length = (((unsigned int)data[0] & 0xff) << 24) +\r\n(((unsigned int)data[1] & 0xff) << 16) +\r\n(((unsigned int)data[2] & 0xff) << 8) +\r\n((unsigned int)data[3] & 0xff);\r\nfor (i = 0; i < file_length; i++)\r\nwriteb((data[16 + i] & 0xff), dev->mmio + 0x0);\r\nfor (i = 0; i < 5; i++)\r\nwriteb(0x00, dev->mmio + 0x0);\r\nvalue = readl(dev_private->plx_regbase + PLX9052_INTCSR);\r\nif (value & PLX9052_INTCSR_LI2STAT) {\r\nwritel(0x00, dev_private->plx_regbase + PLX9052_INTCSR);\r\ndev_err(dev->class_dev, "Xilinx download failed\n");\r\nreturn -EIO;\r\n}\r\nsleep(1);\r\nwritel(PLX9052_INTCSR_LI1ENAB |\r\nPLX9052_INTCSR_LI1POL |\r\nPLX9052_INTCSR_PCIENAB,\r\ndev_private->plx_regbase + PLX9052_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int me_reset(struct comedi_device *dev)\r\n{\r\nstruct me_private_data *dev_private = dev->private;\r\nwritew(0x00, dev->mmio + ME_CONTROL_1);\r\nwritew(0x00, dev->mmio + ME_CONTROL_2);\r\nwritew(0x00, dev->mmio + ME_RESET_INTERRUPT);\r\nwritew(0x00, dev->mmio + ME_DAC_CONTROL);\r\ndev_private->dac_control = 0;\r\ndev_private->control_1 = 0;\r\ndev_private->control_2 = 0;\r\nreturn 0;\r\n}\r\nstatic int me_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct me_board *board = NULL;\r\nstruct me_private_data *dev_private;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nif (context < ARRAY_SIZE(me_boards))\r\nboard = &me_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndev_private = comedi_alloc_devpriv(dev, sizeof(*dev_private));\r\nif (!dev_private)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev_private->plx_regbase = pci_ioremap_bar(pcidev, 0);\r\nif (!dev_private->plx_regbase)\r\nreturn -ENOMEM;\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nif (board->needs_firmware) {\r\nret = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\r\nME2600_FIRMWARE,\r\nme2600_xilinx_download, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nme_reset(dev);\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON;\r\ns->n_chan = 16;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 16;\r\ns->range_table = &me_ai_range;\r\ns->insn_read = me_ai_insn_read;\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_COMMON;\r\ns->n_chan = 4;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 4;\r\ns->range_table = &me_ao_range;\r\ns->insn_write = me_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 32;\r\ns->maxdata = 1;\r\ns->len_chanlist = 32;\r\ns->range_table = &range_digital;\r\ns->insn_bits = me_dio_insn_bits;\r\ns->insn_config = me_dio_insn_config;\r\nreturn 0;\r\n}\r\nstatic void me_detach(struct comedi_device *dev)\r\n{\r\nstruct me_private_data *dev_private = dev->private;\r\nif (dev_private) {\r\nif (dev->mmio)\r\nme_reset(dev);\r\nif (dev_private->plx_regbase)\r\niounmap(dev_private->plx_regbase);\r\n}\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int me_daq_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &me_daq_driver, id->driver_data);\r\n}
