static inline int _check_irq(int irq, int flags)\r\n{\r\nif (request_irq(irq, i365_count_irq, flags, "x", i365_count_irq) != 0)\r\nreturn -1;\r\nfree_irq(irq, i365_count_irq);\r\nreturn 0;\r\n}\r\nstatic u_char i365_get(u_short sock, u_short reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&bus_lock,flags);\r\n{\r\nunsigned int port = socket[sock].ioaddr;\r\nu_char val;\r\nreg = I365_REG(socket[sock].psock, reg);\r\noutb(reg, port); val = inb(port+1);\r\nspin_unlock_irqrestore(&bus_lock,flags);\r\nreturn val;\r\n}\r\n}\r\nstatic void i365_set(u_short sock, u_short reg, u_char data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&bus_lock,flags);\r\n{\r\nunsigned int port = socket[sock].ioaddr;\r\nu_char val = I365_REG(socket[sock].psock, reg);\r\noutb(val, port); outb(data, port+1);\r\nspin_unlock_irqrestore(&bus_lock,flags);\r\n}\r\n}\r\nstatic void i365_bset(u_short sock, u_short reg, u_char mask)\r\n{\r\nu_char d = i365_get(sock, reg);\r\nd |= mask;\r\ni365_set(sock, reg, d);\r\n}\r\nstatic void i365_bclr(u_short sock, u_short reg, u_char mask)\r\n{\r\nu_char d = i365_get(sock, reg);\r\nd &= ~mask;\r\ni365_set(sock, reg, d);\r\n}\r\nstatic void i365_bflip(u_short sock, u_short reg, u_char mask, int b)\r\n{\r\nu_char d = i365_get(sock, reg);\r\nif (b)\r\nd |= mask;\r\nelse\r\nd &= ~mask;\r\ni365_set(sock, reg, d);\r\n}\r\nstatic u_short i365_get_pair(u_short sock, u_short reg)\r\n{\r\nu_short a, b;\r\na = i365_get(sock, reg);\r\nb = i365_get(sock, reg+1);\r\nreturn (a + (b<<8));\r\n}\r\nstatic void i365_set_pair(u_short sock, u_short reg, u_short data)\r\n{\r\ni365_set(sock, reg, data & 0xff);\r\ni365_set(sock, reg+1, data >> 8);\r\n}\r\nstatic void cirrus_get_state(u_short s)\r\n{\r\nint i;\r\nstruct cirrus_state *p = &socket[s].state.cirrus;\r\np->misc1 = i365_get(s, PD67_MISC_CTL_1);\r\np->misc1 &= (PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);\r\np->misc2 = i365_get(s, PD67_MISC_CTL_2);\r\nfor (i = 0; i < 6; i++)\r\np->timer[i] = i365_get(s, PD67_TIME_SETUP(0)+i);\r\n}\r\nstatic void cirrus_set_state(u_short s)\r\n{\r\nint i;\r\nu_char misc;\r\nstruct cirrus_state *p = &socket[s].state.cirrus;\r\nmisc = i365_get(s, PD67_MISC_CTL_2);\r\ni365_set(s, PD67_MISC_CTL_2, p->misc2);\r\nif (misc & PD67_MC2_SUSPEND) mdelay(50);\r\nmisc = i365_get(s, PD67_MISC_CTL_1);\r\nmisc &= ~(PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);\r\ni365_set(s, PD67_MISC_CTL_1, misc | p->misc1);\r\nfor (i = 0; i < 6; i++)\r\ni365_set(s, PD67_TIME_SETUP(0)+i, p->timer[i]);\r\n}\r\nstatic u_int __init cirrus_set_opts(u_short s, char *buf)\r\n{\r\nstruct i82365_socket *t = &socket[s];\r\nstruct cirrus_state *p = &socket[s].state.cirrus;\r\nu_int mask = 0xffff;\r\nif (has_ring == -1) has_ring = 1;\r\nflip(p->misc2, PD67_MC2_IRQ15_RI, has_ring);\r\nflip(p->misc2, PD67_MC2_DYNAMIC_MODE, dynamic_mode);\r\nflip(p->misc2, PD67_MC2_FREQ_BYPASS, freq_bypass);\r\nif (p->misc2 & PD67_MC2_IRQ15_RI)\r\nstrcat(buf, " [ring]");\r\nif (p->misc2 & PD67_MC2_DYNAMIC_MODE)\r\nstrcat(buf, " [dyn mode]");\r\nif (p->misc2 & PD67_MC2_FREQ_BYPASS)\r\nstrcat(buf, " [freq bypass]");\r\nif (p->misc1 & PD67_MC1_INPACK_ENA)\r\nstrcat(buf, " [inpack]");\r\nif (p->misc2 & PD67_MC2_IRQ15_RI)\r\nmask &= ~0x8000;\r\nif (has_led > 0) {\r\nstrcat(buf, " [led]");\r\nmask &= ~0x1000;\r\n}\r\nif (has_dma > 0) {\r\nstrcat(buf, " [dma]");\r\nmask &= ~0x0600;\r\n}\r\nif (!(t->flags & IS_VIA)) {\r\nif (setup_time >= 0)\r\np->timer[0] = p->timer[3] = setup_time;\r\nif (cmd_time > 0) {\r\np->timer[1] = cmd_time;\r\np->timer[4] = cmd_time*2+4;\r\n}\r\nif (p->timer[1] == 0) {\r\np->timer[1] = 6; p->timer[4] = 16;\r\nif (p->timer[0] == 0)\r\np->timer[0] = p->timer[3] = 1;\r\n}\r\nif (recov_time >= 0)\r\np->timer[2] = p->timer[5] = recov_time;\r\nbuf += strlen(buf);\r\nsprintf(buf, " [%d/%d/%d] [%d/%d/%d]", p->timer[0], p->timer[1],\r\np->timer[2], p->timer[3], p->timer[4], p->timer[5]);\r\n}\r\nreturn mask;\r\n}\r\nstatic void vg46x_get_state(u_short s)\r\n{\r\nstruct vg46x_state *p = &socket[s].state.vg46x;\r\np->ctl = i365_get(s, VG468_CTL);\r\nif (socket[s].type == IS_VG469)\r\np->ema = i365_get(s, VG469_EXT_MODE);\r\n}\r\nstatic void vg46x_set_state(u_short s)\r\n{\r\nstruct vg46x_state *p = &socket[s].state.vg46x;\r\ni365_set(s, VG468_CTL, p->ctl);\r\nif (socket[s].type == IS_VG469)\r\ni365_set(s, VG469_EXT_MODE, p->ema);\r\n}\r\nstatic u_int __init vg46x_set_opts(u_short s, char *buf)\r\n{\r\nstruct vg46x_state *p = &socket[s].state.vg46x;\r\nflip(p->ctl, VG468_CTL_ASYNC, async_clock);\r\nflip(p->ema, VG469_MODE_CABLE, cable_mode);\r\nif (p->ctl & VG468_CTL_ASYNC)\r\nstrcat(buf, " [async]");\r\nif (p->ctl & VG468_CTL_INPACK)\r\nstrcat(buf, " [inpack]");\r\nif (socket[s].type == IS_VG469) {\r\nu_char vsel = i365_get(s, VG469_VSELECT);\r\nif (vsel & VG469_VSEL_EXT_STAT) {\r\nstrcat(buf, " [ext mode]");\r\nif (vsel & VG469_VSEL_EXT_BUS)\r\nstrcat(buf, " [isa buf]");\r\n}\r\nif (p->ema & VG469_MODE_CABLE)\r\nstrcat(buf, " [cable]");\r\nif (p->ema & VG469_MODE_COMPAT)\r\nstrcat(buf, " [c step]");\r\n}\r\nreturn 0xffff;\r\n}\r\nstatic void get_bridge_state(u_short s)\r\n{\r\nstruct i82365_socket *t = &socket[s];\r\nif (t->flags & IS_CIRRUS)\r\ncirrus_get_state(s);\r\nelse if (t->flags & IS_VADEM)\r\nvg46x_get_state(s);\r\n}\r\nstatic void set_bridge_state(u_short s)\r\n{\r\nstruct i82365_socket *t = &socket[s];\r\nif (t->flags & IS_CIRRUS)\r\ncirrus_set_state(s);\r\nelse {\r\ni365_set(s, I365_GBLCTL, 0x00);\r\ni365_set(s, I365_GENCTL, 0x00);\r\n}\r\ni365_bflip(s, I365_INTCTL, I365_INTR_ENA, t->intr);\r\nif (t->flags & IS_VADEM)\r\nvg46x_set_state(s);\r\n}\r\nstatic u_int __init set_bridge_opts(u_short s, u_short ns)\r\n{\r\nu_short i;\r\nu_int m = 0xffff;\r\nchar buf[128];\r\nfor (i = s; i < s+ns; i++) {\r\nif (socket[i].flags & IS_ALIVE) {\r\nprintk(KERN_INFO " host opts [%d]: already alive!\n", i);\r\ncontinue;\r\n}\r\nbuf[0] = '\0';\r\nget_bridge_state(i);\r\nif (socket[i].flags & IS_CIRRUS)\r\nm = cirrus_set_opts(i, buf);\r\nelse if (socket[i].flags & IS_VADEM)\r\nm = vg46x_set_opts(i, buf);\r\nset_bridge_state(i);\r\nprintk(KERN_INFO " host opts [%d]:%s\n", i,\r\n(*buf) ? buf : " none");\r\n}\r\nreturn m;\r\n}\r\nstatic irqreturn_t i365_count_irq(int irq, void *dev)\r\n{\r\ni365_get(irq_sock, I365_CSC);\r\nirq_hits++;\r\npr_debug("i82365: -> hit on irq %d\n", irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u_int __init test_irq(u_short sock, int irq)\r\n{\r\npr_debug("i82365: testing ISA irq %d\n", irq);\r\nif (request_irq(irq, i365_count_irq, IRQF_PROBE_SHARED, "scan",\r\ni365_count_irq) != 0)\r\nreturn 1;\r\nirq_hits = 0; irq_sock = sock;\r\nmsleep(10);\r\nif (irq_hits) {\r\nfree_irq(irq, i365_count_irq);\r\npr_debug("i82365: spurious hit!\n");\r\nreturn 1;\r\n}\r\ni365_set(sock, I365_CSCINT, I365_CSC_DETECT | (irq << 4));\r\ni365_bset(sock, I365_GENCTL, I365_CTL_SW_IRQ);\r\nudelay(1000);\r\nfree_irq(irq, i365_count_irq);\r\ni365_set(sock, I365_CSCINT, 0);\r\npr_debug("i82365: hits = %d\n", irq_hits);\r\nreturn (irq_hits != 1);\r\n}\r\nstatic u_int __init isa_scan(u_short sock, u_int mask0)\r\n{\r\nu_int mask1 = 0;\r\nint i;\r\n#ifdef __alpha__\r\n#define PIC 0x4d0\r\nmask0 &= ~(inb(PIC) | (inb(PIC+1) << 8));\r\n#endif\r\nif (do_scan) {\r\nset_bridge_state(sock);\r\ni365_set(sock, I365_CSCINT, 0);\r\nfor (i = 0; i < 16; i++)\r\nif ((mask0 & (1 << i)) && (test_irq(sock, i) == 0))\r\nmask1 |= (1 << i);\r\nfor (i = 0; i < 16; i++)\r\nif ((mask1 & (1 << i)) && (test_irq(sock, i) != 0))\r\nmask1 ^= (1 << i);\r\n}\r\nprintk(KERN_INFO " ISA irqs (");\r\nif (mask1) {\r\nprintk("scanned");\r\n} else {\r\nfor (i = 0; i < 16; i++)\r\nif ((mask0 & (1 << i)) && (_check_irq(i, IRQF_PROBE_SHARED) == 0))\r\nmask1 |= (1 << i);\r\nprintk("default");\r\nif (!cs_irq && (poll_interval == 0)) poll_interval = HZ;\r\n}\r\nprintk(") = ");\r\nfor (i = 0; i < 16; i++)\r\nif (mask1 & (1<<i))\r\nprintk("%s%d", ((mask1 & ((1<<i)-1)) ? "," : ""), i);\r\nif (mask1 == 0) printk("none!");\r\nreturn mask1;\r\n}\r\nstatic int to_cycles(int ns)\r\n{\r\nreturn ns/cycle_time;\r\n}\r\nstatic int __init identify(unsigned int port, u_short sock)\r\n{\r\nu_char val;\r\nint type = -1;\r\nsocket[sockets].ioaddr = port;\r\nsocket[sockets].psock = sock;\r\nif (wakeup) {\r\ni365_bclr(sockets, PD67_MISC_CTL_2, PD67_MC2_SUSPEND);\r\nmdelay(50);\r\n}\r\nif ((val = i365_get(sockets, I365_IDENT)) & 0x70)\r\nreturn -1;\r\nswitch (val) {\r\ncase 0x82:\r\ntype = IS_I82365A; break;\r\ncase 0x83:\r\ntype = IS_I82365B; break;\r\ncase 0x84:\r\ntype = IS_I82365DF; break;\r\ncase 0x88: case 0x89: case 0x8a:\r\ntype = IS_IBM; break;\r\n}\r\noutb(0x0e, port);\r\noutb(0x37, port);\r\ni365_bset(sockets, VG468_MISC, VG468_MISC_VADEMREV);\r\nval = i365_get(sockets, I365_IDENT);\r\nif (val & I365_IDENT_VADEM) {\r\ni365_bclr(sockets, VG468_MISC, VG468_MISC_VADEMREV);\r\ntype = ((val & 7) >= 4) ? IS_VG469 : IS_VG468;\r\n}\r\nval = i365_get(sockets, RF5C_CHIP_ID);\r\nif ((val == RF5C_CHIP_RF5C296) || (val == RF5C_CHIP_RF5C396))\r\ntype = IS_RF5Cx96;\r\ni365_set(sockets, PD67_CHIP_INFO, 0);\r\nval = i365_get(sockets, PD67_CHIP_INFO);\r\nif ((val & PD67_INFO_CHIP_ID) == PD67_INFO_CHIP_ID) {\r\nval = i365_get(sockets, PD67_CHIP_INFO);\r\nif ((val & PD67_INFO_CHIP_ID) == 0) {\r\ntype = (val & PD67_INFO_SLOTS) ? IS_PD672X : IS_PD6710;\r\ni365_set(sockets, PD67_EXT_INDEX, 0xe5);\r\nif (i365_get(sockets, PD67_EXT_INDEX) != 0xe5)\r\ntype = IS_VT83C469;\r\n}\r\n}\r\nreturn type;\r\n}\r\nstatic int __init is_alive(u_short sock)\r\n{\r\nu_char stat;\r\nunsigned int start, stop;\r\nstat = i365_get(sock, I365_STATUS);\r\nstart = i365_get_pair(sock, I365_IO(0)+I365_W_START);\r\nstop = i365_get_pair(sock, I365_IO(0)+I365_W_STOP);\r\nif ((stat & I365_CS_DETECT) && (stat & I365_CS_POWERON) &&\r\n(i365_get(sock, I365_INTCTL) & I365_PC_IOCARD) &&\r\n(i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(0)) &&\r\n((start & 0xfeef) != 0x02e8)) {\r\nif (!request_region(start, stop-start+1, "i82365"))\r\nreturn 1;\r\nrelease_region(start, stop-start+1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init add_socket(unsigned int port, int psock, int type)\r\n{\r\nsocket[sockets].ioaddr = port;\r\nsocket[sockets].psock = psock;\r\nsocket[sockets].type = type;\r\nsocket[sockets].flags = pcic[type].flags;\r\nif (is_alive(sockets))\r\nsocket[sockets].flags |= IS_ALIVE;\r\nsockets++;\r\n}\r\nstatic void __init add_pcic(int ns, int type)\r\n{\r\nu_int mask = 0, i, base;\r\nint isa_irq = 0;\r\nstruct i82365_socket *t = &socket[sockets-ns];\r\nbase = sockets-ns;\r\nif (base == 0) printk("\n");\r\nprintk(KERN_INFO " %s", pcic[type].name);\r\nprintk(" ISA-to-PCMCIA at port %#x ofs 0x%02x",\r\nt->ioaddr, t->psock*0x40);\r\nprintk(", %d socket%s\n", ns, ((ns > 1) ? "s" : ""));\r\nif (irq_list_count == 0)\r\nmask = irq_mask;\r\nelse\r\nfor (i = mask = 0; i < irq_list_count; i++)\r\nmask |= (1<<irq_list[i]);\r\nmask &= I365_MASK & set_bridge_opts(base, ns);\r\nmask = isa_scan(base, mask);\r\nif (!poll_interval) {\r\nu_int tmp = (mask & 0xff20);\r\ntmp = tmp & (tmp-1);\r\nif ((tmp & (tmp-1)) == 0)\r\npoll_interval = HZ;\r\n}\r\nif (!grab_irq && (cs_irq || !poll_interval)) {\r\nu_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));\r\nfor (cs_irq = 15; cs_irq > 0; cs_irq--)\r\nif ((cs_mask & (1 << cs_irq)) &&\r\n(_check_irq(cs_irq, IRQF_PROBE_SHARED) == 0))\r\nbreak;\r\nif (cs_irq) {\r\ngrab_irq = 1;\r\nisa_irq = cs_irq;\r\nprintk(" status change on irq %d\n", cs_irq);\r\n}\r\n}\r\nif (!isa_irq) {\r\nif (poll_interval == 0)\r\npoll_interval = HZ;\r\nprintk(" polling interval = %d ms\n",\r\npoll_interval * 1000 / HZ);\r\n}\r\nfor (i = 0; i < ns; i++) {\r\nt[i].socket.features |= SS_CAP_PCCARD;\r\nt[i].socket.map_size = 0x1000;\r\nt[i].socket.irq_mask = mask;\r\nt[i].cs_irq = isa_irq;\r\n}\r\n}\r\nstatic void __init isa_probe(void)\r\n{\r\nint i, j, sock, k, ns, id;\r\nunsigned int port;\r\n#ifdef CONFIG_PNP\r\nstruct isapnp_device_id *devid;\r\nstruct pnp_dev *dev;\r\nfor (devid = id_table; devid->vendor; devid++) {\r\nif ((dev = pnp_find_dev(NULL, devid->vendor, devid->function, NULL))) {\r\nif (pnp_device_attach(dev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(dev) < 0) {\r\nprintk("activate failed\n");\r\npnp_device_detach(dev);\r\nbreak;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\nprintk("invalid resources ?\n");\r\npnp_device_detach(dev);\r\nbreak;\r\n}\r\ni365_base = pnp_port_start(dev, 0);\r\ni82365_pnpdev = dev;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (!request_region(i365_base, 2, "i82365")) {\r\nif (sockets == 0)\r\nprintk("port conflict at %#lx\n", i365_base);\r\nreturn;\r\n}\r\nid = identify(i365_base, 0);\r\nif ((id == IS_I82365DF) && (identify(i365_base, 1) != id)) {\r\nfor (i = 0; i < 4; i++) {\r\nif (i == ignore) continue;\r\nport = i365_base + ((i & 1) << 2) + ((i & 2) << 1);\r\nsock = (i & 1) << 1;\r\nif (identify(port, sock) == IS_I82365DF) {\r\nadd_socket(port, sock, IS_VLSI);\r\nadd_pcic(1, IS_VLSI);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < 8; i += 2) {\r\nif (sockets && !extra_sockets && (i == 4))\r\nbreak;\r\nport = i365_base + 2*(i>>2);\r\nsock = (i & 3);\r\nid = identify(port, sock);\r\nif (id < 0) continue;\r\nfor (j = ns = 0; j < 2; j++) {\r\nif ((ignore == i+j) || (identify(port, sock+j) < 0))\r\ncontinue;\r\nfor (k = 0; k <= sockets; k++)\r\ni365_set(k, I365_MEM(0)+I365_W_OFF, k);\r\nfor (k = 0; k <= sockets; k++)\r\nif (i365_get(k, I365_MEM(0)+I365_W_OFF) != k)\r\nbreak;\r\nif (k <= sockets) break;\r\nadd_socket(port, sock+j, id); ns++;\r\n}\r\nif (ns != 0) add_pcic(ns, id);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t pcic_interrupt(int irq, void *dev)\r\n{\r\nint i, j, csc;\r\nu_int events, active;\r\nu_long flags = 0;\r\nint handled = 0;\r\npr_debug("pcic_interrupt(%d)\n", irq);\r\nfor (j = 0; j < 20; j++) {\r\nactive = 0;\r\nfor (i = 0; i < sockets; i++) {\r\nif (socket[i].cs_irq != irq)\r\ncontinue;\r\nhandled = 1;\r\nISA_LOCK(i, flags);\r\ncsc = i365_get(i, I365_CSC);\r\nif ((csc == 0) || (i365_get(i, I365_IDENT) & 0x70)) {\r\nISA_UNLOCK(i, flags);\r\ncontinue;\r\n}\r\nevents = (csc & I365_CSC_DETECT) ? SS_DETECT : 0;\r\nif (i365_get(i, I365_INTCTL) & I365_PC_IOCARD)\r\nevents |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;\r\nelse {\r\nevents |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;\r\nevents |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;\r\nevents |= (csc & I365_CSC_READY) ? SS_READY : 0;\r\n}\r\nISA_UNLOCK(i, flags);\r\npr_debug("socket %d event 0x%02x\n", i, events);\r\nif (events)\r\npcmcia_parse_events(&socket[i].socket, events);\r\nactive |= events;\r\n}\r\nif (!active) break;\r\n}\r\nif (j == 20)\r\nprintk(KERN_NOTICE "i82365: infinite loop in interrupt handler\n");\r\npr_debug("pcic_interrupt done\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pcic_interrupt_wrapper(u_long data)\r\n{\r\npcic_interrupt(0, NULL);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nstatic int i365_get_status(u_short sock, u_int *value)\r\n{\r\nu_int status;\r\nstatus = i365_get(sock, I365_STATUS);\r\n*value = ((status & I365_CS_DETECT) == I365_CS_DETECT)\r\n? SS_DETECT : 0;\r\nif (i365_get(sock, I365_INTCTL) & I365_PC_IOCARD)\r\n*value |= (status & I365_CS_STSCHG) ? 0 : SS_STSCHG;\r\nelse {\r\n*value |= (status & I365_CS_BVD1) ? 0 : SS_BATDEAD;\r\n*value |= (status & I365_CS_BVD2) ? 0 : SS_BATWARN;\r\n}\r\n*value |= (status & I365_CS_WRPROT) ? SS_WRPROT : 0;\r\n*value |= (status & I365_CS_READY) ? SS_READY : 0;\r\n*value |= (status & I365_CS_POWERON) ? SS_POWERON : 0;\r\nif (socket[sock].type == IS_VG469) {\r\nstatus = i365_get(sock, VG469_VSENSE);\r\nif (socket[sock].psock & 1) {\r\n*value |= (status & VG469_VSENSE_B_VS1) ? 0 : SS_3VCARD;\r\n*value |= (status & VG469_VSENSE_B_VS2) ? 0 : SS_XVCARD;\r\n} else {\r\n*value |= (status & VG469_VSENSE_A_VS1) ? 0 : SS_3VCARD;\r\n*value |= (status & VG469_VSENSE_A_VS2) ? 0 : SS_XVCARD;\r\n}\r\n}\r\npr_debug("GetStatus(%d) = %#4.4x\n", sock, *value);\r\nreturn 0;\r\n}\r\nstatic int i365_set_socket(u_short sock, socket_state_t *state)\r\n{\r\nstruct i82365_socket *t = &socket[sock];\r\nu_char reg;\r\npr_debug("SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "\r\n"io_irq %d, csc_mask %#2.2x)\n", sock, state->flags,\r\nstate->Vcc, state->Vpp, state->io_irq, state->csc_mask);\r\nset_bridge_state(sock);\r\nreg = t->intr;\r\nreg |= state->io_irq;\r\nreg |= (state->flags & SS_RESET) ? 0 : I365_PC_RESET;\r\nreg |= (state->flags & SS_IOCARD) ? I365_PC_IOCARD : 0;\r\ni365_set(sock, I365_INTCTL, reg);\r\nreg = I365_PWR_NORESET;\r\nif (state->flags & SS_PWR_AUTO) reg |= I365_PWR_AUTO;\r\nif (state->flags & SS_OUTPUT_ENA) reg |= I365_PWR_OUT;\r\nif (t->flags & IS_CIRRUS) {\r\nif (state->Vpp != 0) {\r\nif (state->Vpp == 120)\r\nreg |= I365_VPP1_12V;\r\nelse if (state->Vpp == state->Vcc)\r\nreg |= I365_VPP1_5V;\r\nelse return -EINVAL;\r\n}\r\nif (state->Vcc != 0) {\r\nreg |= I365_VCC_5V;\r\nif (state->Vcc == 33)\r\ni365_bset(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\r\nelse if (state->Vcc == 50)\r\ni365_bclr(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\r\nelse return -EINVAL;\r\n}\r\n} else if (t->flags & IS_VG_PWR) {\r\nif (state->Vpp != 0) {\r\nif (state->Vpp == 120)\r\nreg |= I365_VPP1_12V;\r\nelse if (state->Vpp == state->Vcc)\r\nreg |= I365_VPP1_5V;\r\nelse return -EINVAL;\r\n}\r\nif (state->Vcc != 0) {\r\nreg |= I365_VCC_5V;\r\nif (state->Vcc == 33)\r\ni365_bset(sock, VG469_VSELECT, VG469_VSEL_VCC);\r\nelse if (state->Vcc == 50)\r\ni365_bclr(sock, VG469_VSELECT, VG469_VSEL_VCC);\r\nelse return -EINVAL;\r\n}\r\n} else if (t->flags & IS_DF_PWR) {\r\nswitch (state->Vcc) {\r\ncase 0: break;\r\ncase 33: reg |= I365_VCC_3V; break;\r\ncase 50: reg |= I365_VCC_5V; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (state->Vpp) {\r\ncase 0: break;\r\ncase 50: reg |= I365_VPP1_5V; break;\r\ncase 120: reg |= I365_VPP1_12V; break;\r\ndefault: return -EINVAL;\r\n}\r\n} else {\r\nswitch (state->Vcc) {\r\ncase 0: break;\r\ncase 50: reg |= I365_VCC_5V; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (state->Vpp) {\r\ncase 0: break;\r\ncase 50: reg |= I365_VPP1_5V | I365_VPP2_5V; break;\r\ncase 120: reg |= I365_VPP1_12V | I365_VPP2_12V; break;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nif (reg != i365_get(sock, I365_POWER))\r\ni365_set(sock, I365_POWER, reg);\r\nif (t->flags & IS_CIRRUS) {\r\ni365_bflip(sock, PD67_MISC_CTL_1, PD67_MC1_SPKR_ENA,\r\nstate->flags & SS_SPKR_ENA);\r\n}\r\nreg = t->cs_irq << 4;\r\nif (state->csc_mask & SS_DETECT) reg |= I365_CSC_DETECT;\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG) reg |= I365_CSC_STSCHG;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD) reg |= I365_CSC_BVD1;\r\nif (state->csc_mask & SS_BATWARN) reg |= I365_CSC_BVD2;\r\nif (state->csc_mask & SS_READY) reg |= I365_CSC_READY;\r\n}\r\ni365_set(sock, I365_CSCINT, reg);\r\ni365_get(sock, I365_CSC);\r\nreturn 0;\r\n}\r\nstatic int i365_set_io_map(u_short sock, struct pccard_io_map *io)\r\n{\r\nu_char map, ioctl;\r\npr_debug("SetIOMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx-%#llx)\n", sock, io->map, io->flags, io->speed,\r\n(unsigned long long)io->start, (unsigned long long)io->stop);\r\nmap = io->map;\r\nif ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||\r\n(io->stop < io->start)) return -EINVAL;\r\nif (i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(map))\r\ni365_bclr(sock, I365_ADDRWIN, I365_ENA_IO(map));\r\ni365_set_pair(sock, I365_IO(map)+I365_W_START, io->start);\r\ni365_set_pair(sock, I365_IO(map)+I365_W_STOP, io->stop);\r\nioctl = i365_get(sock, I365_IOCTL) & ~I365_IOCTL_MASK(map);\r\nif (io->speed) ioctl |= I365_IOCTL_WAIT(map);\r\nif (io->flags & MAP_0WS) ioctl |= I365_IOCTL_0WS(map);\r\nif (io->flags & MAP_16BIT) ioctl |= I365_IOCTL_16BIT(map);\r\nif (io->flags & MAP_AUTOSZ) ioctl |= I365_IOCTL_IOCS16(map);\r\ni365_set(sock, I365_IOCTL, ioctl);\r\nif (io->flags & MAP_ACTIVE)\r\ni365_bset(sock, I365_ADDRWIN, I365_ENA_IO(map));\r\nreturn 0;\r\n}\r\nstatic int i365_set_mem_map(u_short sock, struct pccard_mem_map *mem)\r\n{\r\nu_short base, i;\r\nu_char map;\r\npr_debug("SetMemMap(%d, %d, %#2.2x, %d ns, %#llx-%#llx, "\r\n"%#x)\n", sock, mem->map, mem->flags, mem->speed,\r\n(unsigned long long)mem->res->start,\r\n(unsigned long long)mem->res->end, mem->card_start);\r\nmap = mem->map;\r\nif ((map > 4) || (mem->card_start > 0x3ffffff) ||\r\n(mem->res->start > mem->res->end) || (mem->speed > 1000))\r\nreturn -EINVAL;\r\nif ((mem->res->start > 0xffffff) || (mem->res->end > 0xffffff))\r\nreturn -EINVAL;\r\nif (i365_get(sock, I365_ADDRWIN) & I365_ENA_MEM(map))\r\ni365_bclr(sock, I365_ADDRWIN, I365_ENA_MEM(map));\r\nbase = I365_MEM(map);\r\ni = (mem->res->start >> 12) & 0x0fff;\r\nif (mem->flags & MAP_16BIT) i |= I365_MEM_16BIT;\r\nif (mem->flags & MAP_0WS) i |= I365_MEM_0WS;\r\ni365_set_pair(sock, base+I365_W_START, i);\r\ni = (mem->res->end >> 12) & 0x0fff;\r\nswitch (to_cycles(mem->speed)) {\r\ncase 0: break;\r\ncase 1: i |= I365_MEM_WS0; break;\r\ncase 2: i |= I365_MEM_WS1; break;\r\ndefault: i |= I365_MEM_WS1 | I365_MEM_WS0; break;\r\n}\r\ni365_set_pair(sock, base+I365_W_STOP, i);\r\ni = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;\r\nif (mem->flags & MAP_WRPROT) i |= I365_MEM_WRPROT;\r\nif (mem->flags & MAP_ATTRIB) i |= I365_MEM_REG;\r\ni365_set_pair(sock, base+I365_W_OFF, i);\r\nif (mem->flags & MAP_ACTIVE)\r\ni365_bset(sock, I365_ADDRWIN, I365_ENA_MEM(map));\r\nreturn 0;\r\n}\r\nstatic int pcic_get_status(struct pcmcia_socket *s, u_int *value)\r\n{\r\nunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\n*value = 0;\r\nreturn -EINVAL;\r\n}\r\nLOCKED(i365_get_status(sock, value));\r\n}\r\nstatic int pcic_set_socket(struct pcmcia_socket *s, socket_state_t *state)\r\n{\r\nunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(i365_set_socket(sock, state));\r\n}\r\nstatic int pcic_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\r\n{\r\nunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(i365_set_io_map(sock, io));\r\n}\r\nstatic int pcic_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)\r\n{\r\nunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(i365_set_mem_map(sock, mem));\r\n}\r\nstatic int pcic_init(struct pcmcia_socket *s)\r\n{\r\nint i;\r\nstruct resource res = { .start = 0, .end = 0x1000 };\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { .res = &res, };\r\nfor (i = 0; i < 2; i++) {\r\nio.map = i;\r\npcic_set_io_map(s, &io);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmem.map = i;\r\npcic_set_mem_map(s, &mem);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init init_i82365(void)\r\n{\r\nint i, ret;\r\nret = platform_driver_register(&i82365_driver);\r\nif (ret)\r\ngoto err_out;\r\ni82365_device = platform_device_alloc("i82365", 0);\r\nif (i82365_device) {\r\nret = platform_device_add(i82365_device);\r\nif (ret)\r\nplatform_device_put(i82365_device);\r\n} else\r\nret = -ENOMEM;\r\nif (ret)\r\ngoto err_driver_unregister;\r\nprintk(KERN_INFO "Intel ISA PCIC probe: ");\r\nsockets = 0;\r\nisa_probe();\r\nif (sockets == 0) {\r\nprintk("not found.\n");\r\nret = -ENODEV;\r\ngoto err_dev_unregister;\r\n}\r\nif (grab_irq != 0)\r\nret = request_irq(cs_irq, pcic_interrupt, 0, "i82365", pcic_interrupt);\r\nif (ret)\r\ngoto err_socket_release;\r\nfor (i = 0; i < sockets; i++) {\r\nsocket[i].socket.dev.parent = &i82365_device->dev;\r\nsocket[i].socket.ops = &pcic_operations;\r\nsocket[i].socket.resource_ops = &pccard_nonstatic_ops;\r\nsocket[i].socket.owner = THIS_MODULE;\r\nsocket[i].number = i;\r\nret = pcmcia_register_socket(&socket[i].socket);\r\nif (!ret)\r\nsocket[i].flags |= IS_REGISTERED;\r\n}\r\nif (poll_interval != 0) {\r\npoll_timer.function = pcic_interrupt_wrapper;\r\npoll_timer.data = 0;\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nreturn 0;\r\nerr_socket_release:\r\nfor (i = 0; i < sockets; i++) {\r\ni365_set(i, I365_CSCINT, 0);\r\nrelease_region(socket[i].ioaddr, 2);\r\n}\r\nerr_dev_unregister:\r\nplatform_device_unregister(i82365_device);\r\nrelease_region(i365_base, 2);\r\n#ifdef CONFIG_PNP\r\nif (i82365_pnpdev)\r\npnp_disable_dev(i82365_pnpdev);\r\n#endif\r\nerr_driver_unregister:\r\nplatform_driver_unregister(&i82365_driver);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit exit_i82365(void)\r\n{\r\nint i;\r\nfor (i = 0; i < sockets; i++) {\r\nif (socket[i].flags & IS_REGISTERED)\r\npcmcia_unregister_socket(&socket[i].socket);\r\n}\r\nplatform_device_unregister(i82365_device);\r\nif (poll_interval != 0)\r\ndel_timer_sync(&poll_timer);\r\nif (grab_irq != 0)\r\nfree_irq(cs_irq, pcic_interrupt);\r\nfor (i = 0; i < sockets; i++) {\r\ni365_set(i, I365_CSCINT, 0);\r\nrelease_region(socket[i].ioaddr, 2);\r\n}\r\nrelease_region(i365_base, 2);\r\n#ifdef CONFIG_PNP\r\nif (i82365_pnpdev)\r\npnp_disable_dev(i82365_pnpdev);\r\n#endif\r\nplatform_driver_unregister(&i82365_driver);\r\n}
