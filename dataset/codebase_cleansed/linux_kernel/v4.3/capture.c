static int submit_audio_in_urb(struct snd_line6_pcm *line6pcm)\r\n{\r\nint index;\r\nint i, urb_size;\r\nint ret;\r\nstruct urb *urb_in;\r\nindex =\r\nfind_first_zero_bit(&line6pcm->in.active_urbs, LINE6_ISO_BUFFERS);\r\nif (index < 0 || index >= LINE6_ISO_BUFFERS) {\r\ndev_err(line6pcm->line6->ifcdev, "no free URB found\n");\r\nreturn -EINVAL;\r\n}\r\nurb_in = line6pcm->in.urbs[index];\r\nurb_size = 0;\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nstruct usb_iso_packet_descriptor *fin =\r\n&urb_in->iso_frame_desc[i];\r\nfin->offset = urb_size;\r\nfin->length = line6pcm->max_packet_size;\r\nurb_size += line6pcm->max_packet_size;\r\n}\r\nurb_in->transfer_buffer =\r\nline6pcm->in.buffer +\r\nindex * LINE6_ISO_PACKETS * line6pcm->max_packet_size;\r\nurb_in->transfer_buffer_length = urb_size;\r\nurb_in->context = line6pcm;\r\nret = usb_submit_urb(urb_in, GFP_ATOMIC);\r\nif (ret == 0)\r\nset_bit(index, &line6pcm->in.active_urbs);\r\nelse\r\ndev_err(line6pcm->line6->ifcdev,\r\n"URB in #%d submission failed (%d)\n", index, ret);\r\nreturn 0;\r\n}\r\nint line6_submit_audio_in_all_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint ret = 0, i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nret = submit_audio_in_urb(line6pcm);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid line6_capture_copy(struct snd_line6_pcm *line6pcm, char *fbuf, int fsize)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nconst int bytes_per_frame = line6pcm->properties->bytes_per_frame;\r\nint frames = fsize / bytes_per_frame;\r\nif (runtime == NULL)\r\nreturn;\r\nif (line6pcm->in.pos_done + frames > runtime->buffer_size) {\r\nint len;\r\nlen = runtime->buffer_size - line6pcm->in.pos_done;\r\nif (len > 0) {\r\nmemcpy(runtime->dma_area +\r\nline6pcm->in.pos_done * bytes_per_frame, fbuf,\r\nlen * bytes_per_frame);\r\nmemcpy(runtime->dma_area, fbuf + len * bytes_per_frame,\r\n(frames - len) * bytes_per_frame);\r\n} else {\r\ndev_err(line6pcm->line6->ifcdev,\r\n"driver bug: len = %d\n", len);\r\n}\r\n} else {\r\nmemcpy(runtime->dma_area +\r\nline6pcm->in.pos_done * bytes_per_frame, fbuf, fsize);\r\n}\r\nline6pcm->in.pos_done += frames;\r\nif (line6pcm->in.pos_done >= runtime->buffer_size)\r\nline6pcm->in.pos_done -= runtime->buffer_size;\r\n}\r\nvoid line6_capture_check_period(struct snd_line6_pcm *line6pcm, int length)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\r\nline6pcm->in.bytes += length;\r\nif (line6pcm->in.bytes >= line6pcm->in.period) {\r\nline6pcm->in.bytes %= line6pcm->in.period;\r\nspin_unlock(&line6pcm->in.lock);\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&line6pcm->in.lock);\r\n}\r\n}\r\nstatic void audio_in_callback(struct urb *urb)\r\n{\r\nint i, index, length = 0, shutdown = 0;\r\nunsigned long flags;\r\nstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\r\nline6pcm->in.last_frame = urb->start_frame;\r\nfor (index = 0; index < LINE6_ISO_BUFFERS; ++index)\r\nif (urb == line6pcm->in.urbs[index])\r\nbreak;\r\nspin_lock_irqsave(&line6pcm->in.lock, flags);\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nchar *fbuf;\r\nint fsize;\r\nstruct usb_iso_packet_descriptor *fin = &urb->iso_frame_desc[i];\r\nif (fin->status == -EXDEV) {\r\nshutdown = 1;\r\nbreak;\r\n}\r\nfbuf = urb->transfer_buffer + fin->offset;\r\nfsize = fin->actual_length;\r\nif (fsize > line6pcm->max_packet_size) {\r\ndev_err(line6pcm->line6->ifcdev,\r\n"driver and/or device bug: packet too large (%d > %d)\n",\r\nfsize, line6pcm->max_packet_size);\r\n}\r\nlength += fsize;\r\nline6pcm->prev_fbuf = fbuf;\r\nline6pcm->prev_fsize = fsize;\r\nif (!test_bit(LINE6_STREAM_IMPULSE, &line6pcm->in.running) &&\r\ntest_bit(LINE6_STREAM_PCM, &line6pcm->in.running) &&\r\nfsize > 0)\r\nline6_capture_copy(line6pcm, fbuf, fsize);\r\n}\r\nclear_bit(index, &line6pcm->in.active_urbs);\r\nif (test_and_clear_bit(index, &line6pcm->in.unlink_urbs))\r\nshutdown = 1;\r\nif (!shutdown) {\r\nsubmit_audio_in_urb(line6pcm);\r\nif (!test_bit(LINE6_STREAM_IMPULSE, &line6pcm->in.running) &&\r\ntest_bit(LINE6_STREAM_PCM, &line6pcm->in.running))\r\nline6_capture_check_period(line6pcm, length);\r\n}\r\nspin_unlock_irqrestore(&line6pcm->in.lock, flags);\r\n}\r\nstatic int snd_line6_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nerr = snd_pcm_hw_constraint_ratdens(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&line6pcm->properties->rates);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw = line6pcm->properties->capture_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nint line6_create_audio_in_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nstruct usb_line6 *line6 = line6pcm->line6;\r\nint i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nstruct urb *urb;\r\nurb = line6pcm->in.urbs[i] =\r\nusb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\r\nif (urb == NULL)\r\nreturn -ENOMEM;\r\nurb->dev = line6->usbdev;\r\nurb->pipe =\r\nusb_rcvisocpipe(line6->usbdev,\r\nline6->properties->ep_audio_r &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->start_frame = -1;\r\nurb->number_of_packets = LINE6_ISO_PACKETS;\r\nurb->interval = LINE6_ISO_INTERVAL;\r\nurb->error_count = 0;\r\nurb->complete = audio_in_callback;\r\n}\r\nreturn 0;\r\n}
