static u32 ccp_addr_lo(struct ccp_dma_info *info)\r\n{\r\nreturn lower_32_bits(info->address + info->offset);\r\n}\r\nstatic u32 ccp_addr_hi(struct ccp_dma_info *info)\r\n{\r\nreturn upper_32_bits(info->address + info->offset) & 0x0000ffff;\r\n}\r\nstatic int ccp_do_cmd(struct ccp_op *op, u32 *cr, unsigned int cr_count)\r\n{\r\nstruct ccp_cmd_queue *cmd_q = op->cmd_q;\r\nstruct ccp_device *ccp = cmd_q->ccp;\r\nvoid __iomem *cr_addr;\r\nu32 cr0, cmd;\r\nunsigned int i;\r\nint ret = 0;\r\ncmd_q->free_slots--;\r\ncr0 = (cmd_q->id << REQ0_CMD_Q_SHIFT)\r\n| (op->jobid << REQ0_JOBID_SHIFT)\r\n| REQ0_WAIT_FOR_WRITE;\r\nif (op->soc)\r\ncr0 |= REQ0_STOP_ON_COMPLETE\r\n| REQ0_INT_ON_COMPLETE;\r\nif (op->ioc || !cmd_q->free_slots)\r\ncr0 |= REQ0_INT_ON_COMPLETE;\r\ncr_addr = ccp->io_regs + CMD_REQ0 + CMD_REQ_INCR;\r\nmutex_lock(&ccp->req_mutex);\r\nfor (i = 0; i < cr_count; i++, cr_addr += CMD_REQ_INCR)\r\niowrite32(*(cr + i), cr_addr);\r\nwmb();\r\niowrite32(cr0, ccp->io_regs + CMD_REQ0);\r\nmutex_unlock(&ccp->req_mutex);\r\nif (cr0 & REQ0_INT_ON_COMPLETE) {\r\nret = wait_event_interruptible(cmd_q->int_queue,\r\ncmd_q->int_rcvd);\r\nif (ret || cmd_q->cmd_error) {\r\ncmd = (cmd_q->id << DEL_Q_ID_SHIFT)\r\n| op->jobid;\r\niowrite32(cmd, ccp->io_regs + DEL_CMD_Q_JOB);\r\nif (!ret)\r\nret = -EIO;\r\n} else if (op->soc) {\r\ncmd = DEL_Q_ACTIVE\r\n| (cmd_q->id << DEL_Q_ID_SHIFT)\r\n| op->jobid;\r\niowrite32(cmd, ccp->io_regs + DEL_CMD_Q_JOB);\r\n}\r\ncmd_q->free_slots = CMD_Q_DEPTH(cmd_q->q_status);\r\ncmd_q->int_rcvd = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ccp_perform_aes(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = (CCP_ENGINE_AES << REQ1_ENGINE_SHIFT)\r\n| (op->u.aes.type << REQ1_AES_TYPE_SHIFT)\r\n| (op->u.aes.mode << REQ1_AES_MODE_SHIFT)\r\n| (op->u.aes.action << REQ1_AES_ACTION_SHIFT)\r\n| (op->ksb_key << REQ1_KEY_KSB_SHIFT);\r\ncr[1] = op->src.u.dma.length - 1;\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (op->ksb_ctx << REQ4_KSB_SHIFT)\r\n| (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\ncr[4] = ccp_addr_lo(&op->dst.u.dma);\r\ncr[5] = (CCP_MEMTYPE_SYSTEM << REQ6_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->dst.u.dma);\r\nif (op->u.aes.mode == CCP_AES_MODE_CFB)\r\ncr[0] |= ((0x7f) << REQ1_AES_CFB_SIZE_SHIFT);\r\nif (op->eom)\r\ncr[0] |= REQ1_EOM;\r\nif (op->init)\r\ncr[0] |= REQ1_INIT;\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic int ccp_perform_xts_aes(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = (CCP_ENGINE_XTS_AES_128 << REQ1_ENGINE_SHIFT)\r\n| (op->u.xts.action << REQ1_AES_ACTION_SHIFT)\r\n| (op->u.xts.unit_size << REQ1_XTS_AES_SIZE_SHIFT)\r\n| (op->ksb_key << REQ1_KEY_KSB_SHIFT);\r\ncr[1] = op->src.u.dma.length - 1;\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (op->ksb_ctx << REQ4_KSB_SHIFT)\r\n| (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\ncr[4] = ccp_addr_lo(&op->dst.u.dma);\r\ncr[5] = (CCP_MEMTYPE_SYSTEM << REQ6_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->dst.u.dma);\r\nif (op->eom)\r\ncr[0] |= REQ1_EOM;\r\nif (op->init)\r\ncr[0] |= REQ1_INIT;\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic int ccp_perform_sha(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = (CCP_ENGINE_SHA << REQ1_ENGINE_SHIFT)\r\n| (op->u.sha.type << REQ1_SHA_TYPE_SHIFT)\r\n| REQ1_INIT;\r\ncr[1] = op->src.u.dma.length - 1;\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (op->ksb_ctx << REQ4_KSB_SHIFT)\r\n| (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\nif (op->eom) {\r\ncr[0] |= REQ1_EOM;\r\ncr[4] = lower_32_bits(op->u.sha.msg_bits);\r\ncr[5] = upper_32_bits(op->u.sha.msg_bits);\r\n} else {\r\ncr[4] = 0;\r\ncr[5] = 0;\r\n}\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic int ccp_perform_rsa(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = (CCP_ENGINE_RSA << REQ1_ENGINE_SHIFT)\r\n| (op->u.rsa.mod_size << REQ1_RSA_MOD_SIZE_SHIFT)\r\n| (op->ksb_key << REQ1_KEY_KSB_SHIFT)\r\n| REQ1_EOM;\r\ncr[1] = op->u.rsa.input_len - 1;\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (op->ksb_ctx << REQ4_KSB_SHIFT)\r\n| (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\ncr[4] = ccp_addr_lo(&op->dst.u.dma);\r\ncr[5] = (CCP_MEMTYPE_SYSTEM << REQ6_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->dst.u.dma);\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic int ccp_perform_passthru(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = (CCP_ENGINE_PASSTHRU << REQ1_ENGINE_SHIFT)\r\n| (op->u.passthru.bit_mod << REQ1_PT_BW_SHIFT)\r\n| (op->u.passthru.byte_swap << REQ1_PT_BS_SHIFT);\r\nif (op->src.type == CCP_MEMTYPE_SYSTEM)\r\ncr[1] = op->src.u.dma.length - 1;\r\nelse\r\ncr[1] = op->dst.u.dma.length - 1;\r\nif (op->src.type == CCP_MEMTYPE_SYSTEM) {\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\nif (op->u.passthru.bit_mod != CCP_PASSTHRU_BITWISE_NOOP)\r\ncr[3] |= (op->ksb_key << REQ4_KSB_SHIFT);\r\n} else {\r\ncr[2] = op->src.u.ksb * CCP_KSB_BYTES;\r\ncr[3] = (CCP_MEMTYPE_KSB << REQ4_MEMTYPE_SHIFT);\r\n}\r\nif (op->dst.type == CCP_MEMTYPE_SYSTEM) {\r\ncr[4] = ccp_addr_lo(&op->dst.u.dma);\r\ncr[5] = (CCP_MEMTYPE_SYSTEM << REQ6_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->dst.u.dma);\r\n} else {\r\ncr[4] = op->dst.u.ksb * CCP_KSB_BYTES;\r\ncr[5] = (CCP_MEMTYPE_KSB << REQ6_MEMTYPE_SHIFT);\r\n}\r\nif (op->eom)\r\ncr[0] |= REQ1_EOM;\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic int ccp_perform_ecc(struct ccp_op *op)\r\n{\r\nu32 cr[6];\r\ncr[0] = REQ1_ECC_AFFINE_CONVERT\r\n| (CCP_ENGINE_ECC << REQ1_ENGINE_SHIFT)\r\n| (op->u.ecc.function << REQ1_ECC_FUNCTION_SHIFT)\r\n| REQ1_EOM;\r\ncr[1] = op->src.u.dma.length - 1;\r\ncr[2] = ccp_addr_lo(&op->src.u.dma);\r\ncr[3] = (CCP_MEMTYPE_SYSTEM << REQ4_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->src.u.dma);\r\ncr[4] = ccp_addr_lo(&op->dst.u.dma);\r\ncr[5] = (CCP_MEMTYPE_SYSTEM << REQ6_MEMTYPE_SHIFT)\r\n| ccp_addr_hi(&op->dst.u.dma);\r\nreturn ccp_do_cmd(op, cr, ARRAY_SIZE(cr));\r\n}\r\nstatic u32 ccp_alloc_ksb(struct ccp_device *ccp, unsigned int count)\r\n{\r\nint start;\r\nfor (;;) {\r\nmutex_lock(&ccp->ksb_mutex);\r\nstart = (u32)bitmap_find_next_zero_area(ccp->ksb,\r\nccp->ksb_count,\r\nccp->ksb_start,\r\ncount, 0);\r\nif (start <= ccp->ksb_count) {\r\nbitmap_set(ccp->ksb, start, count);\r\nmutex_unlock(&ccp->ksb_mutex);\r\nbreak;\r\n}\r\nccp->ksb_avail = 0;\r\nmutex_unlock(&ccp->ksb_mutex);\r\nif (wait_event_interruptible(ccp->ksb_queue, ccp->ksb_avail))\r\nreturn 0;\r\n}\r\nreturn KSB_START + start;\r\n}\r\nstatic void ccp_free_ksb(struct ccp_device *ccp, unsigned int start,\r\nunsigned int count)\r\n{\r\nif (!start)\r\nreturn;\r\nmutex_lock(&ccp->ksb_mutex);\r\nbitmap_clear(ccp->ksb, start - KSB_START, count);\r\nccp->ksb_avail = 1;\r\nmutex_unlock(&ccp->ksb_mutex);\r\nwake_up_interruptible_all(&ccp->ksb_queue);\r\n}\r\nstatic u32 ccp_gen_jobid(struct ccp_device *ccp)\r\n{\r\nreturn atomic_inc_return(&ccp->current_id) & CCP_JOBID_MASK;\r\n}\r\nstatic void ccp_sg_free(struct ccp_sg_workarea *wa)\r\n{\r\nif (wa->dma_count)\r\ndma_unmap_sg(wa->dma_dev, wa->dma_sg, wa->nents, wa->dma_dir);\r\nwa->dma_count = 0;\r\n}\r\nstatic int ccp_init_sg_workarea(struct ccp_sg_workarea *wa, struct device *dev,\r\nstruct scatterlist *sg, u64 len,\r\nenum dma_data_direction dma_dir)\r\n{\r\nmemset(wa, 0, sizeof(*wa));\r\nwa->sg = sg;\r\nif (!sg)\r\nreturn 0;\r\nwa->nents = sg_nents_for_len(sg, len);\r\nif (wa->nents < 0)\r\nreturn wa->nents;\r\nwa->bytes_left = len;\r\nwa->sg_used = 0;\r\nif (len == 0)\r\nreturn 0;\r\nif (dma_dir == DMA_NONE)\r\nreturn 0;\r\nwa->dma_sg = sg;\r\nwa->dma_dev = dev;\r\nwa->dma_dir = dma_dir;\r\nwa->dma_count = dma_map_sg(dev, sg, wa->nents, dma_dir);\r\nif (!wa->dma_count)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ccp_update_sg_workarea(struct ccp_sg_workarea *wa, unsigned int len)\r\n{\r\nunsigned int nbytes = min_t(u64, len, wa->bytes_left);\r\nif (!wa->sg)\r\nreturn;\r\nwa->sg_used += nbytes;\r\nwa->bytes_left -= nbytes;\r\nif (wa->sg_used == wa->sg->length) {\r\nwa->sg = sg_next(wa->sg);\r\nwa->sg_used = 0;\r\n}\r\n}\r\nstatic void ccp_dm_free(struct ccp_dm_workarea *wa)\r\n{\r\nif (wa->length <= CCP_DMAPOOL_MAX_SIZE) {\r\nif (wa->address)\r\ndma_pool_free(wa->dma_pool, wa->address,\r\nwa->dma.address);\r\n} else {\r\nif (wa->dma.address)\r\ndma_unmap_single(wa->dev, wa->dma.address, wa->length,\r\nwa->dma.dir);\r\nkfree(wa->address);\r\n}\r\nwa->address = NULL;\r\nwa->dma.address = 0;\r\n}\r\nstatic int ccp_init_dm_workarea(struct ccp_dm_workarea *wa,\r\nstruct ccp_cmd_queue *cmd_q,\r\nunsigned int len,\r\nenum dma_data_direction dir)\r\n{\r\nmemset(wa, 0, sizeof(*wa));\r\nif (!len)\r\nreturn 0;\r\nwa->dev = cmd_q->ccp->dev;\r\nwa->length = len;\r\nif (len <= CCP_DMAPOOL_MAX_SIZE) {\r\nwa->dma_pool = cmd_q->dma_pool;\r\nwa->address = dma_pool_alloc(wa->dma_pool, GFP_KERNEL,\r\n&wa->dma.address);\r\nif (!wa->address)\r\nreturn -ENOMEM;\r\nwa->dma.length = CCP_DMAPOOL_MAX_SIZE;\r\nmemset(wa->address, 0, CCP_DMAPOOL_MAX_SIZE);\r\n} else {\r\nwa->address = kzalloc(len, GFP_KERNEL);\r\nif (!wa->address)\r\nreturn -ENOMEM;\r\nwa->dma.address = dma_map_single(wa->dev, wa->address, len,\r\ndir);\r\nif (!wa->dma.address)\r\nreturn -ENOMEM;\r\nwa->dma.length = len;\r\n}\r\nwa->dma.dir = dir;\r\nreturn 0;\r\n}\r\nstatic void ccp_set_dm_area(struct ccp_dm_workarea *wa, unsigned int wa_offset,\r\nstruct scatterlist *sg, unsigned int sg_offset,\r\nunsigned int len)\r\n{\r\nWARN_ON(!wa->address);\r\nscatterwalk_map_and_copy(wa->address + wa_offset, sg, sg_offset, len,\r\n0);\r\n}\r\nstatic void ccp_get_dm_area(struct ccp_dm_workarea *wa, unsigned int wa_offset,\r\nstruct scatterlist *sg, unsigned int sg_offset,\r\nunsigned int len)\r\n{\r\nWARN_ON(!wa->address);\r\nscatterwalk_map_and_copy(wa->address + wa_offset, sg, sg_offset, len,\r\n1);\r\n}\r\nstatic void ccp_reverse_set_dm_area(struct ccp_dm_workarea *wa,\r\nstruct scatterlist *sg,\r\nunsigned int len, unsigned int se_len,\r\nbool sign_extend)\r\n{\r\nunsigned int nbytes, sg_offset, dm_offset, ksb_len, i;\r\nu8 buffer[CCP_REVERSE_BUF_SIZE];\r\nBUG_ON(se_len > sizeof(buffer));\r\nsg_offset = len;\r\ndm_offset = 0;\r\nnbytes = len;\r\nwhile (nbytes) {\r\nksb_len = min_t(unsigned int, nbytes, se_len);\r\nsg_offset -= ksb_len;\r\nscatterwalk_map_and_copy(buffer, sg, sg_offset, ksb_len, 0);\r\nfor (i = 0; i < ksb_len; i++)\r\nwa->address[dm_offset + i] = buffer[ksb_len - i - 1];\r\ndm_offset += ksb_len;\r\nnbytes -= ksb_len;\r\nif ((ksb_len != se_len) && sign_extend) {\r\nif (wa->address[dm_offset - 1] & 0x80)\r\nmemset(wa->address + dm_offset, 0xff,\r\nse_len - ksb_len);\r\n}\r\n}\r\n}\r\nstatic void ccp_reverse_get_dm_area(struct ccp_dm_workarea *wa,\r\nstruct scatterlist *sg,\r\nunsigned int len)\r\n{\r\nunsigned int nbytes, sg_offset, dm_offset, ksb_len, i;\r\nu8 buffer[CCP_REVERSE_BUF_SIZE];\r\nsg_offset = 0;\r\ndm_offset = len;\r\nnbytes = len;\r\nwhile (nbytes) {\r\nksb_len = min_t(unsigned int, nbytes, sizeof(buffer));\r\ndm_offset -= ksb_len;\r\nfor (i = 0; i < ksb_len; i++)\r\nbuffer[ksb_len - i - 1] = wa->address[dm_offset + i];\r\nscatterwalk_map_and_copy(buffer, sg, sg_offset, ksb_len, 1);\r\nsg_offset += ksb_len;\r\nnbytes -= ksb_len;\r\n}\r\n}\r\nstatic void ccp_free_data(struct ccp_data *data, struct ccp_cmd_queue *cmd_q)\r\n{\r\nccp_dm_free(&data->dm_wa);\r\nccp_sg_free(&data->sg_wa);\r\n}\r\nstatic int ccp_init_data(struct ccp_data *data, struct ccp_cmd_queue *cmd_q,\r\nstruct scatterlist *sg, u64 sg_len,\r\nunsigned int dm_len,\r\nenum dma_data_direction dir)\r\n{\r\nint ret;\r\nmemset(data, 0, sizeof(*data));\r\nret = ccp_init_sg_workarea(&data->sg_wa, cmd_q->ccp->dev, sg, sg_len,\r\ndir);\r\nif (ret)\r\ngoto e_err;\r\nret = ccp_init_dm_workarea(&data->dm_wa, cmd_q, dm_len, dir);\r\nif (ret)\r\ngoto e_err;\r\nreturn 0;\r\ne_err:\r\nccp_free_data(data, cmd_q);\r\nreturn ret;\r\n}\r\nstatic unsigned int ccp_queue_buf(struct ccp_data *data, unsigned int from)\r\n{\r\nstruct ccp_sg_workarea *sg_wa = &data->sg_wa;\r\nstruct ccp_dm_workarea *dm_wa = &data->dm_wa;\r\nunsigned int buf_count, nbytes;\r\nif (!from)\r\nmemset(dm_wa->address, 0, dm_wa->length);\r\nif (!sg_wa->sg)\r\nreturn 0;\r\nnbytes = min_t(u64, sg_wa->bytes_left, dm_wa->length);\r\nscatterwalk_map_and_copy(dm_wa->address, sg_wa->sg, sg_wa->sg_used,\r\nnbytes, from);\r\nbuf_count = 0;\r\nwhile (sg_wa->bytes_left && (buf_count < dm_wa->length)) {\r\nnbytes = min(sg_wa->sg->length - sg_wa->sg_used,\r\ndm_wa->length - buf_count);\r\nnbytes = min_t(u64, sg_wa->bytes_left, nbytes);\r\nbuf_count += nbytes;\r\nccp_update_sg_workarea(sg_wa, nbytes);\r\n}\r\nreturn buf_count;\r\n}\r\nstatic unsigned int ccp_fill_queue_buf(struct ccp_data *data)\r\n{\r\nreturn ccp_queue_buf(data, 0);\r\n}\r\nstatic unsigned int ccp_empty_queue_buf(struct ccp_data *data)\r\n{\r\nreturn ccp_queue_buf(data, 1);\r\n}\r\nstatic void ccp_prepare_data(struct ccp_data *src, struct ccp_data *dst,\r\nstruct ccp_op *op, unsigned int block_size,\r\nbool blocksize_op)\r\n{\r\nunsigned int sg_src_len, sg_dst_len, op_len;\r\nsg_src_len = sg_dma_len(src->sg_wa.sg) - src->sg_wa.sg_used;\r\nsg_src_len = min_t(u64, src->sg_wa.bytes_left, sg_src_len);\r\nif (dst) {\r\nsg_dst_len = sg_dma_len(dst->sg_wa.sg) - dst->sg_wa.sg_used;\r\nsg_dst_len = min_t(u64, src->sg_wa.bytes_left, sg_dst_len);\r\nop_len = min(sg_src_len, sg_dst_len);\r\n} else {\r\nop_len = sg_src_len;\r\n}\r\nop_len = max(op_len, block_size);\r\nop->soc = 0;\r\nif (sg_src_len < block_size) {\r\nint cp_len = ccp_fill_queue_buf(src);\r\nop->soc = 1;\r\nop->src.u.dma.address = src->dm_wa.dma.address;\r\nop->src.u.dma.offset = 0;\r\nop->src.u.dma.length = (blocksize_op) ? block_size : cp_len;\r\n} else {\r\nop->src.u.dma.address = sg_dma_address(src->sg_wa.sg);\r\nop->src.u.dma.offset = src->sg_wa.sg_used;\r\nop->src.u.dma.length = op_len & ~(block_size - 1);\r\nccp_update_sg_workarea(&src->sg_wa, op->src.u.dma.length);\r\n}\r\nif (dst) {\r\nif (sg_dst_len < block_size) {\r\nop->soc = 1;\r\nop->dst.u.dma.address = dst->dm_wa.dma.address;\r\nop->dst.u.dma.offset = 0;\r\nop->dst.u.dma.length = op->src.u.dma.length;\r\n} else {\r\nop->dst.u.dma.address = sg_dma_address(dst->sg_wa.sg);\r\nop->dst.u.dma.offset = dst->sg_wa.sg_used;\r\nop->dst.u.dma.length = op->src.u.dma.length;\r\n}\r\n}\r\n}\r\nstatic void ccp_process_data(struct ccp_data *src, struct ccp_data *dst,\r\nstruct ccp_op *op)\r\n{\r\nop->init = 0;\r\nif (dst) {\r\nif (op->dst.u.dma.address == dst->dm_wa.dma.address)\r\nccp_empty_queue_buf(dst);\r\nelse\r\nccp_update_sg_workarea(&dst->sg_wa,\r\nop->dst.u.dma.length);\r\n}\r\n}\r\nstatic int ccp_copy_to_from_ksb(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_dm_workarea *wa, u32 jobid, u32 ksb,\r\nu32 byte_swap, bool from)\r\n{\r\nstruct ccp_op op;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = jobid;\r\nop.eom = 1;\r\nif (from) {\r\nop.soc = 1;\r\nop.src.type = CCP_MEMTYPE_KSB;\r\nop.src.u.ksb = ksb;\r\nop.dst.type = CCP_MEMTYPE_SYSTEM;\r\nop.dst.u.dma.address = wa->dma.address;\r\nop.dst.u.dma.length = wa->length;\r\n} else {\r\nop.src.type = CCP_MEMTYPE_SYSTEM;\r\nop.src.u.dma.address = wa->dma.address;\r\nop.src.u.dma.length = wa->length;\r\nop.dst.type = CCP_MEMTYPE_KSB;\r\nop.dst.u.ksb = ksb;\r\n}\r\nop.u.passthru.byte_swap = byte_swap;\r\nreturn ccp_perform_passthru(&op);\r\n}\r\nstatic int ccp_copy_to_ksb(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_dm_workarea *wa, u32 jobid, u32 ksb,\r\nu32 byte_swap)\r\n{\r\nreturn ccp_copy_to_from_ksb(cmd_q, wa, jobid, ksb, byte_swap, false);\r\n}\r\nstatic int ccp_copy_from_ksb(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_dm_workarea *wa, u32 jobid, u32 ksb,\r\nu32 byte_swap)\r\n{\r\nreturn ccp_copy_to_from_ksb(cmd_q, wa, jobid, ksb, byte_swap, true);\r\n}\r\nstatic int ccp_run_aes_cmac_cmd(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_cmd *cmd)\r\n{\r\nstruct ccp_aes_engine *aes = &cmd->u.aes;\r\nstruct ccp_dm_workarea key, ctx;\r\nstruct ccp_data src;\r\nstruct ccp_op op;\r\nunsigned int dm_offset;\r\nint ret;\r\nif (!((aes->key_len == AES_KEYSIZE_128) ||\r\n(aes->key_len == AES_KEYSIZE_192) ||\r\n(aes->key_len == AES_KEYSIZE_256)))\r\nreturn -EINVAL;\r\nif (aes->src_len & (AES_BLOCK_SIZE - 1))\r\nreturn -EINVAL;\r\nif (aes->iv_len != AES_BLOCK_SIZE)\r\nreturn -EINVAL;\r\nif (!aes->key || !aes->iv || !aes->src)\r\nreturn -EINVAL;\r\nif (aes->cmac_final) {\r\nif (aes->cmac_key_len != AES_BLOCK_SIZE)\r\nreturn -EINVAL;\r\nif (!aes->cmac_key)\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON(CCP_AES_KEY_KSB_COUNT != 1);\r\nBUILD_BUG_ON(CCP_AES_CTX_KSB_COUNT != 1);\r\nret = -EIO;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nop.ksb_key = cmd_q->ksb_key;\r\nop.ksb_ctx = cmd_q->ksb_ctx;\r\nop.init = 1;\r\nop.u.aes.type = aes->type;\r\nop.u.aes.mode = aes->mode;\r\nop.u.aes.action = aes->action;\r\nret = ccp_init_dm_workarea(&key, cmd_q,\r\nCCP_AES_KEY_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ndm_offset = CCP_KSB_BYTES - aes->key_len;\r\nccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len);\r\nret = ccp_copy_to_ksb(cmd_q, &key, op.jobid, op.ksb_key,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_key;\r\n}\r\nret = ccp_init_dm_workarea(&ctx, cmd_q,\r\nCCP_AES_CTX_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_BIDIRECTIONAL);\r\nif (ret)\r\ngoto e_key;\r\ndm_offset = CCP_KSB_BYTES - AES_BLOCK_SIZE;\r\nccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\r\nret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_ctx;\r\n}\r\nret = ccp_init_data(&src, cmd_q, aes->src, aes->src_len,\r\nAES_BLOCK_SIZE, DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_ctx;\r\nwhile (src.sg_wa.bytes_left) {\r\nccp_prepare_data(&src, NULL, &op, AES_BLOCK_SIZE, true);\r\nif (aes->cmac_final && !src.sg_wa.bytes_left) {\r\nop.eom = 1;\r\nret = ccp_copy_from_ksb(cmd_q, &ctx, op.jobid,\r\nop.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_src;\r\n}\r\nccp_set_dm_area(&ctx, 0, aes->cmac_key, 0,\r\naes->cmac_key_len);\r\nret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_src;\r\n}\r\n}\r\nret = ccp_perform_aes(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_src;\r\n}\r\nccp_process_data(&src, NULL, &op);\r\n}\r\nret = ccp_copy_from_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_src;\r\n}\r\ndm_offset = CCP_KSB_BYTES - AES_BLOCK_SIZE;\r\nccp_get_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\r\ne_src:\r\nccp_free_data(&src, cmd_q);\r\ne_ctx:\r\nccp_dm_free(&ctx);\r\ne_key:\r\nccp_dm_free(&key);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_aes_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_aes_engine *aes = &cmd->u.aes;\r\nstruct ccp_dm_workarea key, ctx;\r\nstruct ccp_data src, dst;\r\nstruct ccp_op op;\r\nunsigned int dm_offset;\r\nbool in_place = false;\r\nint ret;\r\nif (aes->mode == CCP_AES_MODE_CMAC)\r\nreturn ccp_run_aes_cmac_cmd(cmd_q, cmd);\r\nif (!((aes->key_len == AES_KEYSIZE_128) ||\r\n(aes->key_len == AES_KEYSIZE_192) ||\r\n(aes->key_len == AES_KEYSIZE_256)))\r\nreturn -EINVAL;\r\nif (((aes->mode == CCP_AES_MODE_ECB) ||\r\n(aes->mode == CCP_AES_MODE_CBC) ||\r\n(aes->mode == CCP_AES_MODE_CFB)) &&\r\n(aes->src_len & (AES_BLOCK_SIZE - 1)))\r\nreturn -EINVAL;\r\nif (!aes->key || !aes->src || !aes->dst)\r\nreturn -EINVAL;\r\nif (aes->mode != CCP_AES_MODE_ECB) {\r\nif (aes->iv_len != AES_BLOCK_SIZE)\r\nreturn -EINVAL;\r\nif (!aes->iv)\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON(CCP_AES_KEY_KSB_COUNT != 1);\r\nBUILD_BUG_ON(CCP_AES_CTX_KSB_COUNT != 1);\r\nret = -EIO;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nop.ksb_key = cmd_q->ksb_key;\r\nop.ksb_ctx = cmd_q->ksb_ctx;\r\nop.init = (aes->mode == CCP_AES_MODE_ECB) ? 0 : 1;\r\nop.u.aes.type = aes->type;\r\nop.u.aes.mode = aes->mode;\r\nop.u.aes.action = aes->action;\r\nret = ccp_init_dm_workarea(&key, cmd_q,\r\nCCP_AES_KEY_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ndm_offset = CCP_KSB_BYTES - aes->key_len;\r\nccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len);\r\nret = ccp_copy_to_ksb(cmd_q, &key, op.jobid, op.ksb_key,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_key;\r\n}\r\nret = ccp_init_dm_workarea(&ctx, cmd_q,\r\nCCP_AES_CTX_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_BIDIRECTIONAL);\r\nif (ret)\r\ngoto e_key;\r\nif (aes->mode != CCP_AES_MODE_ECB) {\r\ndm_offset = CCP_KSB_BYTES - AES_BLOCK_SIZE;\r\nccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\r\nret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_ctx;\r\n}\r\n}\r\nif (sg_virt(aes->src) == sg_virt(aes->dst))\r\nin_place = true;\r\nret = ccp_init_data(&src, cmd_q, aes->src, aes->src_len,\r\nAES_BLOCK_SIZE,\r\nin_place ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_ctx;\r\nif (in_place) {\r\ndst = src;\r\n} else {\r\nret = ccp_init_data(&dst, cmd_q, aes->dst, aes->src_len,\r\nAES_BLOCK_SIZE, DMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\n}\r\nwhile (src.sg_wa.bytes_left) {\r\nccp_prepare_data(&src, &dst, &op, AES_BLOCK_SIZE, true);\r\nif (!src.sg_wa.bytes_left) {\r\nop.eom = 1;\r\nif (aes->mode == CCP_AES_MODE_ECB)\r\nop.soc = 1;\r\n}\r\nret = ccp_perform_aes(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\nccp_process_data(&src, &dst, &op);\r\n}\r\nif (aes->mode != CCP_AES_MODE_ECB) {\r\nret = ccp_copy_from_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\ndm_offset = CCP_KSB_BYTES - AES_BLOCK_SIZE;\r\nccp_get_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\r\n}\r\ne_dst:\r\nif (!in_place)\r\nccp_free_data(&dst, cmd_q);\r\ne_src:\r\nccp_free_data(&src, cmd_q);\r\ne_ctx:\r\nccp_dm_free(&ctx);\r\ne_key:\r\nccp_dm_free(&key);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_xts_aes_cmd(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_cmd *cmd)\r\n{\r\nstruct ccp_xts_aes_engine *xts = &cmd->u.xts;\r\nstruct ccp_dm_workarea key, ctx;\r\nstruct ccp_data src, dst;\r\nstruct ccp_op op;\r\nunsigned int unit_size, dm_offset;\r\nbool in_place = false;\r\nint ret;\r\nswitch (xts->unit_size) {\r\ncase CCP_XTS_AES_UNIT_SIZE_16:\r\nunit_size = 16;\r\nbreak;\r\ncase CCP_XTS_AES_UNIT_SIZE_512:\r\nunit_size = 512;\r\nbreak;\r\ncase CCP_XTS_AES_UNIT_SIZE_1024:\r\nunit_size = 1024;\r\nbreak;\r\ncase CCP_XTS_AES_UNIT_SIZE_2048:\r\nunit_size = 2048;\r\nbreak;\r\ncase CCP_XTS_AES_UNIT_SIZE_4096:\r\nunit_size = 4096;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (xts->key_len != AES_KEYSIZE_128)\r\nreturn -EINVAL;\r\nif (!xts->final && (xts->src_len & (AES_BLOCK_SIZE - 1)))\r\nreturn -EINVAL;\r\nif (xts->iv_len != AES_BLOCK_SIZE)\r\nreturn -EINVAL;\r\nif (!xts->key || !xts->iv || !xts->src || !xts->dst)\r\nreturn -EINVAL;\r\nBUILD_BUG_ON(CCP_XTS_AES_KEY_KSB_COUNT != 1);\r\nBUILD_BUG_ON(CCP_XTS_AES_CTX_KSB_COUNT != 1);\r\nret = -EIO;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nop.ksb_key = cmd_q->ksb_key;\r\nop.ksb_ctx = cmd_q->ksb_ctx;\r\nop.init = 1;\r\nop.u.xts.action = xts->action;\r\nop.u.xts.unit_size = xts->unit_size;\r\nret = ccp_init_dm_workarea(&key, cmd_q,\r\nCCP_XTS_AES_KEY_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ndm_offset = CCP_KSB_BYTES - AES_KEYSIZE_128;\r\nccp_set_dm_area(&key, dm_offset, xts->key, 0, xts->key_len);\r\nccp_set_dm_area(&key, 0, xts->key, dm_offset, xts->key_len);\r\nret = ccp_copy_to_ksb(cmd_q, &key, op.jobid, op.ksb_key,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_key;\r\n}\r\nret = ccp_init_dm_workarea(&ctx, cmd_q,\r\nCCP_XTS_AES_CTX_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_BIDIRECTIONAL);\r\nif (ret)\r\ngoto e_key;\r\nccp_set_dm_area(&ctx, 0, xts->iv, 0, xts->iv_len);\r\nret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_NOOP);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_ctx;\r\n}\r\nif (sg_virt(xts->src) == sg_virt(xts->dst))\r\nin_place = true;\r\nret = ccp_init_data(&src, cmd_q, xts->src, xts->src_len,\r\nunit_size,\r\nin_place ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_ctx;\r\nif (in_place) {\r\ndst = src;\r\n} else {\r\nret = ccp_init_data(&dst, cmd_q, xts->dst, xts->src_len,\r\nunit_size, DMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\n}\r\nwhile (src.sg_wa.bytes_left) {\r\nccp_prepare_data(&src, &dst, &op, unit_size, true);\r\nif (!src.sg_wa.bytes_left)\r\nop.eom = 1;\r\nret = ccp_perform_xts_aes(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\nccp_process_data(&src, &dst, &op);\r\n}\r\nret = ccp_copy_from_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\ndm_offset = CCP_KSB_BYTES - AES_BLOCK_SIZE;\r\nccp_get_dm_area(&ctx, dm_offset, xts->iv, 0, xts->iv_len);\r\ne_dst:\r\nif (!in_place)\r\nccp_free_data(&dst, cmd_q);\r\ne_src:\r\nccp_free_data(&src, cmd_q);\r\ne_ctx:\r\nccp_dm_free(&ctx);\r\ne_key:\r\nccp_dm_free(&key);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_sha_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_sha_engine *sha = &cmd->u.sha;\r\nstruct ccp_dm_workarea ctx;\r\nstruct ccp_data src;\r\nstruct ccp_op op;\r\nint ret;\r\nif (sha->ctx_len != CCP_SHA_CTXSIZE)\r\nreturn -EINVAL;\r\nif (!sha->ctx)\r\nreturn -EINVAL;\r\nif (!sha->final && (sha->src_len & (CCP_SHA_BLOCKSIZE - 1)))\r\nreturn -EINVAL;\r\nif (!sha->src_len) {\r\nconst u8 *sha_zero;\r\nif (!sha->final)\r\nreturn 0;\r\nif (sha->msg_bits)\r\nreturn -EINVAL;\r\nswitch (sha->type) {\r\ncase CCP_SHA_TYPE_1:\r\nsha_zero = ccp_sha1_zero;\r\nbreak;\r\ncase CCP_SHA_TYPE_224:\r\nsha_zero = ccp_sha224_zero;\r\nbreak;\r\ncase CCP_SHA_TYPE_256:\r\nsha_zero = ccp_sha256_zero;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nscatterwalk_map_and_copy((void *)sha_zero, sha->ctx, 0,\r\nsha->ctx_len, 1);\r\nreturn 0;\r\n}\r\nif (!sha->src)\r\nreturn -EINVAL;\r\nBUILD_BUG_ON(CCP_SHA_KSB_COUNT != 1);\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nop.ksb_ctx = cmd_q->ksb_ctx;\r\nop.u.sha.type = sha->type;\r\nop.u.sha.msg_bits = sha->msg_bits;\r\nret = ccp_init_dm_workarea(&ctx, cmd_q,\r\nCCP_SHA_KSB_COUNT * CCP_KSB_BYTES,\r\nDMA_BIDIRECTIONAL);\r\nif (ret)\r\nreturn ret;\r\nif (sha->first) {\r\nconst __be32 *init;\r\nswitch (sha->type) {\r\ncase CCP_SHA_TYPE_1:\r\ninit = ccp_sha1_init;\r\nbreak;\r\ncase CCP_SHA_TYPE_224:\r\ninit = ccp_sha224_init;\r\nbreak;\r\ncase CCP_SHA_TYPE_256:\r\ninit = ccp_sha256_init;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto e_ctx;\r\n}\r\nmemcpy(ctx.address, init, CCP_SHA_CTXSIZE);\r\n} else {\r\nccp_set_dm_area(&ctx, 0, sha->ctx, 0, sha->ctx_len);\r\n}\r\nret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_ctx;\r\n}\r\nret = ccp_init_data(&src, cmd_q, sha->src, sha->src_len,\r\nCCP_SHA_BLOCKSIZE, DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_ctx;\r\nwhile (src.sg_wa.bytes_left) {\r\nccp_prepare_data(&src, NULL, &op, CCP_SHA_BLOCKSIZE, false);\r\nif (sha->final && !src.sg_wa.bytes_left)\r\nop.eom = 1;\r\nret = ccp_perform_sha(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_data;\r\n}\r\nccp_process_data(&src, NULL, &op);\r\n}\r\nret = ccp_copy_from_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,\r\nCCP_PASSTHRU_BYTESWAP_256BIT);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_data;\r\n}\r\nccp_get_dm_area(&ctx, 0, sha->ctx, 0, sha->ctx_len);\r\nif (sha->final && sha->opad) {\r\nstruct ccp_cmd hmac_cmd;\r\nstruct scatterlist sg;\r\nu64 block_size, digest_size;\r\nu8 *hmac_buf;\r\nswitch (sha->type) {\r\ncase CCP_SHA_TYPE_1:\r\nblock_size = SHA1_BLOCK_SIZE;\r\ndigest_size = SHA1_DIGEST_SIZE;\r\nbreak;\r\ncase CCP_SHA_TYPE_224:\r\nblock_size = SHA224_BLOCK_SIZE;\r\ndigest_size = SHA224_DIGEST_SIZE;\r\nbreak;\r\ncase CCP_SHA_TYPE_256:\r\nblock_size = SHA256_BLOCK_SIZE;\r\ndigest_size = SHA256_DIGEST_SIZE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto e_data;\r\n}\r\nif (sha->opad_len != block_size) {\r\nret = -EINVAL;\r\ngoto e_data;\r\n}\r\nhmac_buf = kmalloc(block_size + digest_size, GFP_KERNEL);\r\nif (!hmac_buf) {\r\nret = -ENOMEM;\r\ngoto e_data;\r\n}\r\nsg_init_one(&sg, hmac_buf, block_size + digest_size);\r\nscatterwalk_map_and_copy(hmac_buf, sha->opad, 0, block_size, 0);\r\nmemcpy(hmac_buf + block_size, ctx.address, digest_size);\r\nmemset(&hmac_cmd, 0, sizeof(hmac_cmd));\r\nhmac_cmd.engine = CCP_ENGINE_SHA;\r\nhmac_cmd.u.sha.type = sha->type;\r\nhmac_cmd.u.sha.ctx = sha->ctx;\r\nhmac_cmd.u.sha.ctx_len = sha->ctx_len;\r\nhmac_cmd.u.sha.src = &sg;\r\nhmac_cmd.u.sha.src_len = block_size + digest_size;\r\nhmac_cmd.u.sha.opad = NULL;\r\nhmac_cmd.u.sha.opad_len = 0;\r\nhmac_cmd.u.sha.first = 1;\r\nhmac_cmd.u.sha.final = 1;\r\nhmac_cmd.u.sha.msg_bits = (block_size + digest_size) << 3;\r\nret = ccp_run_sha_cmd(cmd_q, &hmac_cmd);\r\nif (ret)\r\ncmd->engine_error = hmac_cmd.engine_error;\r\nkfree(hmac_buf);\r\n}\r\ne_data:\r\nccp_free_data(&src, cmd_q);\r\ne_ctx:\r\nccp_dm_free(&ctx);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_rsa_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_rsa_engine *rsa = &cmd->u.rsa;\r\nstruct ccp_dm_workarea exp, src;\r\nstruct ccp_data dst;\r\nstruct ccp_op op;\r\nunsigned int ksb_count, i_len, o_len;\r\nint ret;\r\nif (rsa->key_size > CCP_RSA_MAX_WIDTH)\r\nreturn -EINVAL;\r\nif (!rsa->exp || !rsa->mod || !rsa->src || !rsa->dst)\r\nreturn -EINVAL;\r\no_len = ((rsa->key_size + 255) / 256) * 32;\r\ni_len = o_len * 2;\r\nksb_count = o_len / CCP_KSB_BYTES;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nop.ksb_key = ccp_alloc_ksb(cmd_q->ccp, ksb_count);\r\nif (!op.ksb_key)\r\nreturn -EIO;\r\nret = ccp_init_dm_workarea(&exp, cmd_q, o_len, DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_ksb;\r\nccp_reverse_set_dm_area(&exp, rsa->exp, rsa->exp_len, CCP_KSB_BYTES,\r\nfalse);\r\nret = ccp_copy_to_ksb(cmd_q, &exp, op.jobid, op.ksb_key,\r\nCCP_PASSTHRU_BYTESWAP_NOOP);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_exp;\r\n}\r\nret = ccp_init_dm_workarea(&src, cmd_q, i_len, DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_exp;\r\nccp_reverse_set_dm_area(&src, rsa->mod, rsa->mod_len, CCP_KSB_BYTES,\r\nfalse);\r\nsrc.address += o_len;\r\nccp_reverse_set_dm_area(&src, rsa->src, rsa->src_len, CCP_KSB_BYTES,\r\nfalse);\r\nsrc.address -= o_len;\r\nret = ccp_init_data(&dst, cmd_q, rsa->dst, rsa->mod_len,\r\no_len, DMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\nop.soc = 1;\r\nop.src.u.dma.address = src.dma.address;\r\nop.src.u.dma.offset = 0;\r\nop.src.u.dma.length = i_len;\r\nop.dst.u.dma.address = dst.dm_wa.dma.address;\r\nop.dst.u.dma.offset = 0;\r\nop.dst.u.dma.length = o_len;\r\nop.u.rsa.mod_size = rsa->key_size;\r\nop.u.rsa.input_len = i_len;\r\nret = ccp_perform_rsa(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\nccp_reverse_get_dm_area(&dst.dm_wa, rsa->dst, rsa->mod_len);\r\ne_dst:\r\nccp_free_data(&dst, cmd_q);\r\ne_src:\r\nccp_dm_free(&src);\r\ne_exp:\r\nccp_dm_free(&exp);\r\ne_ksb:\r\nccp_free_ksb(cmd_q->ccp, op.ksb_key, ksb_count);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_passthru_cmd(struct ccp_cmd_queue *cmd_q,\r\nstruct ccp_cmd *cmd)\r\n{\r\nstruct ccp_passthru_engine *pt = &cmd->u.passthru;\r\nstruct ccp_dm_workarea mask;\r\nstruct ccp_data src, dst;\r\nstruct ccp_op op;\r\nbool in_place = false;\r\nunsigned int i;\r\nint ret;\r\nif (!pt->final && (pt->src_len & (CCP_PASSTHRU_BLOCKSIZE - 1)))\r\nreturn -EINVAL;\r\nif (!pt->src || !pt->dst)\r\nreturn -EINVAL;\r\nif (pt->bit_mod != CCP_PASSTHRU_BITWISE_NOOP) {\r\nif (pt->mask_len != CCP_PASSTHRU_MASKSIZE)\r\nreturn -EINVAL;\r\nif (!pt->mask)\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON(CCP_PASSTHRU_KSB_COUNT != 1);\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nif (pt->bit_mod != CCP_PASSTHRU_BITWISE_NOOP) {\r\nop.ksb_key = cmd_q->ksb_key;\r\nret = ccp_init_dm_workarea(&mask, cmd_q,\r\nCCP_PASSTHRU_KSB_COUNT *\r\nCCP_KSB_BYTES,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\nccp_set_dm_area(&mask, 0, pt->mask, 0, pt->mask_len);\r\nret = ccp_copy_to_ksb(cmd_q, &mask, op.jobid, op.ksb_key,\r\nCCP_PASSTHRU_BYTESWAP_NOOP);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_mask;\r\n}\r\n}\r\nif (sg_virt(pt->src) == sg_virt(pt->dst))\r\nin_place = true;\r\nret = ccp_init_data(&src, cmd_q, pt->src, pt->src_len,\r\nCCP_PASSTHRU_MASKSIZE,\r\nin_place ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\r\nif (ret)\r\ngoto e_mask;\r\nif (in_place) {\r\ndst = src;\r\n} else {\r\nret = ccp_init_data(&dst, cmd_q, pt->dst, pt->src_len,\r\nCCP_PASSTHRU_MASKSIZE, DMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\n}\r\ndst.sg_wa.sg_used = 0;\r\nfor (i = 1; i <= src.sg_wa.dma_count; i++) {\r\nif (!dst.sg_wa.sg ||\r\n(dst.sg_wa.sg->length < src.sg_wa.sg->length)) {\r\nret = -EINVAL;\r\ngoto e_dst;\r\n}\r\nif (i == src.sg_wa.dma_count) {\r\nop.eom = 1;\r\nop.soc = 1;\r\n}\r\nop.src.type = CCP_MEMTYPE_SYSTEM;\r\nop.src.u.dma.address = sg_dma_address(src.sg_wa.sg);\r\nop.src.u.dma.offset = 0;\r\nop.src.u.dma.length = sg_dma_len(src.sg_wa.sg);\r\nop.dst.type = CCP_MEMTYPE_SYSTEM;\r\nop.dst.u.dma.address = sg_dma_address(dst.sg_wa.sg);\r\nop.dst.u.dma.offset = dst.sg_wa.sg_used;\r\nop.dst.u.dma.length = op.src.u.dma.length;\r\nret = ccp_perform_passthru(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\ndst.sg_wa.sg_used += src.sg_wa.sg->length;\r\nif (dst.sg_wa.sg_used == dst.sg_wa.sg->length) {\r\ndst.sg_wa.sg = sg_next(dst.sg_wa.sg);\r\ndst.sg_wa.sg_used = 0;\r\n}\r\nsrc.sg_wa.sg = sg_next(src.sg_wa.sg);\r\n}\r\ne_dst:\r\nif (!in_place)\r\nccp_free_data(&dst, cmd_q);\r\ne_src:\r\nccp_free_data(&src, cmd_q);\r\ne_mask:\r\nif (pt->bit_mod != CCP_PASSTHRU_BITWISE_NOOP)\r\nccp_dm_free(&mask);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_ecc_mm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_ecc_engine *ecc = &cmd->u.ecc;\r\nstruct ccp_dm_workarea src, dst;\r\nstruct ccp_op op;\r\nint ret;\r\nu8 *save;\r\nif (!ecc->u.mm.operand_1 ||\r\n(ecc->u.mm.operand_1_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nif (ecc->function != CCP_ECC_FUNCTION_MINV_384BIT)\r\nif (!ecc->u.mm.operand_2 ||\r\n(ecc->u.mm.operand_2_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nif (!ecc->u.mm.result ||\r\n(ecc->u.mm.result_len < CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nret = ccp_init_dm_workarea(&src, cmd_q, CCP_ECC_SRC_BUF_SIZE,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\nsave = src.address;\r\nccp_reverse_set_dm_area(&src, ecc->mod, ecc->mod_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nccp_reverse_set_dm_area(&src, ecc->u.mm.operand_1,\r\necc->u.mm.operand_1_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nif (ecc->function != CCP_ECC_FUNCTION_MINV_384BIT) {\r\nccp_reverse_set_dm_area(&src, ecc->u.mm.operand_2,\r\necc->u.mm.operand_2_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\n}\r\nsrc.address = save;\r\nret = ccp_init_dm_workarea(&dst, cmd_q, CCP_ECC_DST_BUF_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\nop.soc = 1;\r\nop.src.u.dma.address = src.dma.address;\r\nop.src.u.dma.offset = 0;\r\nop.src.u.dma.length = src.length;\r\nop.dst.u.dma.address = dst.dma.address;\r\nop.dst.u.dma.offset = 0;\r\nop.dst.u.dma.length = dst.length;\r\nop.u.ecc.function = cmd->u.ecc.function;\r\nret = ccp_perform_ecc(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\necc->ecc_result = le16_to_cpup(\r\n(const __le16 *)(dst.address + CCP_ECC_RESULT_OFFSET));\r\nif (!(ecc->ecc_result & CCP_ECC_RESULT_SUCCESS)) {\r\nret = -EIO;\r\ngoto e_dst;\r\n}\r\nccp_reverse_get_dm_area(&dst, ecc->u.mm.result, CCP_ECC_MODULUS_BYTES);\r\ne_dst:\r\nccp_dm_free(&dst);\r\ne_src:\r\nccp_dm_free(&src);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_ecc_pm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_ecc_engine *ecc = &cmd->u.ecc;\r\nstruct ccp_dm_workarea src, dst;\r\nstruct ccp_op op;\r\nint ret;\r\nu8 *save;\r\nif (!ecc->u.pm.point_1.x ||\r\n(ecc->u.pm.point_1.x_len > CCP_ECC_MODULUS_BYTES) ||\r\n!ecc->u.pm.point_1.y ||\r\n(ecc->u.pm.point_1.y_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nif (ecc->function == CCP_ECC_FUNCTION_PADD_384BIT) {\r\nif (!ecc->u.pm.point_2.x ||\r\n(ecc->u.pm.point_2.x_len > CCP_ECC_MODULUS_BYTES) ||\r\n!ecc->u.pm.point_2.y ||\r\n(ecc->u.pm.point_2.y_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\n} else {\r\nif (!ecc->u.pm.domain_a ||\r\n(ecc->u.pm.domain_a_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nif (ecc->function == CCP_ECC_FUNCTION_PMUL_384BIT)\r\nif (!ecc->u.pm.scalar ||\r\n(ecc->u.pm.scalar_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\n}\r\nif (!ecc->u.pm.result.x ||\r\n(ecc->u.pm.result.x_len < CCP_ECC_MODULUS_BYTES) ||\r\n!ecc->u.pm.result.y ||\r\n(ecc->u.pm.result.y_len < CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nmemset(&op, 0, sizeof(op));\r\nop.cmd_q = cmd_q;\r\nop.jobid = ccp_gen_jobid(cmd_q->ccp);\r\nret = ccp_init_dm_workarea(&src, cmd_q, CCP_ECC_SRC_BUF_SIZE,\r\nDMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\nsave = src.address;\r\nccp_reverse_set_dm_area(&src, ecc->mod, ecc->mod_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.point_1.x,\r\necc->u.pm.point_1.x_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.point_1.y,\r\necc->u.pm.point_1.y_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\n*src.address = 0x01;\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nif (ecc->function == CCP_ECC_FUNCTION_PADD_384BIT) {\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.point_2.x,\r\necc->u.pm.point_2.x_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.point_2.y,\r\necc->u.pm.point_2.y_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\n*src.address = 0x01;\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\n} else {\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.domain_a,\r\necc->u.pm.domain_a_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\nif (ecc->function == CCP_ECC_FUNCTION_PMUL_384BIT) {\r\nccp_reverse_set_dm_area(&src, ecc->u.pm.scalar,\r\necc->u.pm.scalar_len,\r\nCCP_ECC_OPERAND_SIZE, false);\r\nsrc.address += CCP_ECC_OPERAND_SIZE;\r\n}\r\n}\r\nsrc.address = save;\r\nret = ccp_init_dm_workarea(&dst, cmd_q, CCP_ECC_DST_BUF_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (ret)\r\ngoto e_src;\r\nop.soc = 1;\r\nop.src.u.dma.address = src.dma.address;\r\nop.src.u.dma.offset = 0;\r\nop.src.u.dma.length = src.length;\r\nop.dst.u.dma.address = dst.dma.address;\r\nop.dst.u.dma.offset = 0;\r\nop.dst.u.dma.length = dst.length;\r\nop.u.ecc.function = cmd->u.ecc.function;\r\nret = ccp_perform_ecc(&op);\r\nif (ret) {\r\ncmd->engine_error = cmd_q->cmd_error;\r\ngoto e_dst;\r\n}\r\necc->ecc_result = le16_to_cpup(\r\n(const __le16 *)(dst.address + CCP_ECC_RESULT_OFFSET));\r\nif (!(ecc->ecc_result & CCP_ECC_RESULT_SUCCESS)) {\r\nret = -EIO;\r\ngoto e_dst;\r\n}\r\nsave = dst.address;\r\nccp_reverse_get_dm_area(&dst, ecc->u.pm.result.x,\r\nCCP_ECC_MODULUS_BYTES);\r\ndst.address += CCP_ECC_OUTPUT_SIZE;\r\nccp_reverse_get_dm_area(&dst, ecc->u.pm.result.y,\r\nCCP_ECC_MODULUS_BYTES);\r\ndst.address += CCP_ECC_OUTPUT_SIZE;\r\ndst.address = save;\r\ne_dst:\r\nccp_dm_free(&dst);\r\ne_src:\r\nccp_dm_free(&src);\r\nreturn ret;\r\n}\r\nstatic int ccp_run_ecc_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nstruct ccp_ecc_engine *ecc = &cmd->u.ecc;\r\necc->ecc_result = 0;\r\nif (!ecc->mod ||\r\n(ecc->mod_len > CCP_ECC_MODULUS_BYTES))\r\nreturn -EINVAL;\r\nswitch (ecc->function) {\r\ncase CCP_ECC_FUNCTION_MMUL_384BIT:\r\ncase CCP_ECC_FUNCTION_MADD_384BIT:\r\ncase CCP_ECC_FUNCTION_MINV_384BIT:\r\nreturn ccp_run_ecc_mm_cmd(cmd_q, cmd);\r\ncase CCP_ECC_FUNCTION_PADD_384BIT:\r\ncase CCP_ECC_FUNCTION_PMUL_384BIT:\r\ncase CCP_ECC_FUNCTION_PDBL_384BIT:\r\nreturn ccp_run_ecc_pm_cmd(cmd_q, cmd);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint ccp_run_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\r\n{\r\nint ret;\r\ncmd->engine_error = 0;\r\ncmd_q->cmd_error = 0;\r\ncmd_q->int_rcvd = 0;\r\ncmd_q->free_slots = CMD_Q_DEPTH(ioread32(cmd_q->reg_status));\r\nswitch (cmd->engine) {\r\ncase CCP_ENGINE_AES:\r\nret = ccp_run_aes_cmd(cmd_q, cmd);\r\nbreak;\r\ncase CCP_ENGINE_XTS_AES_128:\r\nret = ccp_run_xts_aes_cmd(cmd_q, cmd);\r\nbreak;\r\ncase CCP_ENGINE_SHA:\r\nret = ccp_run_sha_cmd(cmd_q, cmd);\r\nbreak;\r\ncase CCP_ENGINE_RSA:\r\nret = ccp_run_rsa_cmd(cmd_q, cmd);\r\nbreak;\r\ncase CCP_ENGINE_PASSTHRU:\r\nret = ccp_run_passthru_cmd(cmd_q, cmd);\r\nbreak;\r\ncase CCP_ENGINE_ECC:\r\nret = ccp_run_ecc_cmd(cmd_q, cmd);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}
