static inline u32 ipu_di_read(struct ipu_di *di, unsigned offset)\r\n{\r\nreturn readl(di->base + offset);\r\n}\r\nstatic inline void ipu_di_write(struct ipu_di *di, u32 value, unsigned offset)\r\n{\r\nwritel(value, di->base + offset);\r\n}\r\nstatic void ipu_di_data_wave_config(struct ipu_di *di,\r\nint wave_gen,\r\nint access_size, int component_size)\r\n{\r\nu32 reg;\r\nreg = (access_size << DI_DW_GEN_ACCESS_SIZE_OFFSET) |\r\n(component_size << DI_DW_GEN_COMPONENT_SIZE_OFFSET);\r\nipu_di_write(di, reg, DI_DW_GEN(wave_gen));\r\n}\r\nstatic void ipu_di_data_pin_config(struct ipu_di *di, int wave_gen, int di_pin,\r\nint set, int up, int down)\r\n{\r\nu32 reg;\r\nreg = ipu_di_read(di, DI_DW_GEN(wave_gen));\r\nreg &= ~(0x3 << (di_pin * 2));\r\nreg |= set << (di_pin * 2);\r\nipu_di_write(di, reg, DI_DW_GEN(wave_gen));\r\nipu_di_write(di, (down << 16) | up, DI_DW_SET(wave_gen, set));\r\n}\r\nstatic void ipu_di_sync_config(struct ipu_di *di, struct di_sync_config *config,\r\nint start, int count)\r\n{\r\nu32 reg;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nstruct di_sync_config *c = &config[i];\r\nint wave_gen = start + i + 1;\r\nif ((c->run_count >= 0x1000) || (c->offset_count >= 0x1000) ||\r\n(c->repeat_count >= 0x1000) ||\r\n(c->cnt_up >= 0x400) ||\r\n(c->cnt_down >= 0x400)) {\r\ndev_err(di->ipu->dev, "DI%d counters out of range.\n",\r\ndi->id);\r\nreturn;\r\n}\r\nreg = DI_SW_GEN0_RUN_COUNT(c->run_count) |\r\nDI_SW_GEN0_RUN_SRC(c->run_src) |\r\nDI_SW_GEN0_OFFSET_COUNT(c->offset_count) |\r\nDI_SW_GEN0_OFFSET_SRC(c->offset_src);\r\nipu_di_write(di, reg, DI_SW_GEN0(wave_gen));\r\nreg = DI_SW_GEN1_CNT_POL_GEN_EN(c->cnt_polarity_gen_en) |\r\nDI_SW_GEN1_CNT_CLR_SRC(c->cnt_clr_src) |\r\nDI_SW_GEN1_CNT_POL_TRIGGER_SRC(\r\nc->cnt_polarity_trigger_src) |\r\nDI_SW_GEN1_CNT_POL_CLR_SRC(c->cnt_polarity_clr_src) |\r\nDI_SW_GEN1_CNT_DOWN(c->cnt_down) |\r\nDI_SW_GEN1_CNT_UP(c->cnt_up);\r\nif (c->repeat_count == 0)\r\nreg |= DI_SW_GEN1_AUTO_RELOAD;\r\nipu_di_write(di, reg, DI_SW_GEN1(wave_gen));\r\nreg = ipu_di_read(di, DI_STP_REP(wave_gen));\r\nreg &= ~(0xffff << (16 * ((wave_gen - 1) & 0x1)));\r\nreg |= c->repeat_count << (16 * ((wave_gen - 1) & 0x1));\r\nipu_di_write(di, reg, DI_STP_REP(wave_gen));\r\n}\r\n}\r\nstatic void ipu_di_sync_config_interlaced(struct ipu_di *di,\r\nstruct ipu_di_signal_cfg *sig)\r\n{\r\nu32 h_total = sig->mode.hactive + sig->mode.hsync_len +\r\nsig->mode.hback_porch + sig->mode.hfront_porch;\r\nu32 v_total = sig->mode.vactive + sig->mode.vsync_len +\r\nsig->mode.vback_porch + sig->mode.vfront_porch;\r\nu32 reg;\r\nstruct di_sync_config cfg[] = {\r\n{\r\n.run_count = h_total / 2 - 1,\r\n.run_src = DI_SYNC_CLK,\r\n}, {\r\n.run_count = h_total - 11,\r\n.run_src = DI_SYNC_CLK,\r\n.cnt_down = 4,\r\n}, {\r\n.run_count = v_total * 2 - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.offset_count = 1,\r\n.offset_src = DI_SYNC_INT_HSYNC,\r\n.cnt_down = 4,\r\n}, {\r\n.run_count = v_total / 2 - 1,\r\n.run_src = DI_SYNC_HSYNC,\r\n.offset_count = sig->mode.vback_porch,\r\n.offset_src = DI_SYNC_HSYNC,\r\n.repeat_count = 2,\r\n.cnt_clr_src = DI_SYNC_VSYNC,\r\n}, {\r\n.run_src = DI_SYNC_HSYNC,\r\n.repeat_count = sig->mode.vactive / 2,\r\n.cnt_clr_src = 4,\r\n}, {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_HSYNC,\r\n}, {\r\n.run_count = v_total / 2 - 1,\r\n.run_src = DI_SYNC_HSYNC,\r\n.offset_count = 9,\r\n.offset_src = DI_SYNC_HSYNC,\r\n.repeat_count = 2,\r\n.cnt_clr_src = DI_SYNC_VSYNC,\r\n}, {\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = sig->mode.hback_porch,\r\n.offset_src = DI_SYNC_CLK,\r\n.repeat_count = sig->mode.hactive,\r\n.cnt_clr_src = 5,\r\n}, {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.offset_count = v_total / 2,\r\n.offset_src = DI_SYNC_INT_HSYNC,\r\n.cnt_clr_src = DI_SYNC_HSYNC,\r\n.cnt_down = 4,\r\n}\r\n};\r\nipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));\r\nreg = ipu_di_read(di, DI_SW_GEN1(9));\r\nreg &= 0x1FFFFFFF;\r\nreg |= (3 - 1) << 29 | 0x00008000;\r\nipu_di_write(di, reg, DI_SW_GEN1(9));\r\nipu_di_write(di, v_total / 2 - 1, DI_SCR_CONF);\r\n}\r\nstatic void ipu_di_sync_config_noninterlaced(struct ipu_di *di,\r\nstruct ipu_di_signal_cfg *sig, int div)\r\n{\r\nu32 h_total = sig->mode.hactive + sig->mode.hsync_len +\r\nsig->mode.hback_porch + sig->mode.hfront_porch;\r\nu32 v_total = sig->mode.vactive + sig->mode.vsync_len +\r\nsig->mode.vback_porch + sig->mode.vfront_porch;\r\nstruct di_sync_config cfg[] = {\r\n{\r\n.run_count = h_total - 1,\r\n.run_src = DI_SYNC_CLK,\r\n} , {\r\n.run_count = h_total - 1,\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = div * sig->v_to_h_sync,\r\n.offset_src = DI_SYNC_CLK,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_CLK,\r\n.cnt_down = sig->mode.hsync_len * 2,\r\n} , {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\r\n.cnt_down = sig->mode.vsync_len * 2,\r\n} , {\r\n.run_src = DI_SYNC_HSYNC,\r\n.offset_count = sig->mode.vsync_len +\r\nsig->mode.vback_porch,\r\n.offset_src = DI_SYNC_HSYNC,\r\n.repeat_count = sig->mode.vactive,\r\n.cnt_clr_src = DI_SYNC_VSYNC,\r\n} , {\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = sig->mode.hsync_len +\r\nsig->mode.hback_porch,\r\n.offset_src = DI_SYNC_CLK,\r\n.repeat_count = sig->mode.hactive,\r\n.cnt_clr_src = 5,\r\n} , {\r\n} , {\r\n} , {\r\n} , {\r\n},\r\n};\r\nstruct di_sync_config cfg_vga[] = {\r\n{\r\n.run_count = h_total - 1,\r\n.run_src = DI_SYNC_CLK,\r\n} , {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n} , {\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.offset_count = sig->mode.vsync_len +\r\nsig->mode.vback_porch,\r\n.offset_src = DI_SYNC_INT_HSYNC,\r\n.repeat_count = sig->mode.vactive,\r\n.cnt_clr_src = 3 ,\r\n} , {\r\n.run_count = h_total - 1,\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = div * sig->v_to_h_sync + 18,\r\n.offset_src = DI_SYNC_CLK,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_CLK,\r\n.cnt_down = sig->mode.hsync_len * 2,\r\n} , {\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = sig->mode.hsync_len +\r\nsig->mode.hback_porch,\r\n.offset_src = DI_SYNC_CLK,\r\n.repeat_count = sig->mode.hactive,\r\n.cnt_clr_src = 4,\r\n} , {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.offset_count = 1,\r\n.offset_src = DI_SYNC_INT_HSYNC,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\r\n.cnt_down = sig->mode.vsync_len * 2,\r\n} , {\r\n.run_count = h_total - 1,\r\n.run_src = DI_SYNC_CLK,\r\n.offset_count = div * sig->v_to_h_sync + 18,\r\n.offset_src = DI_SYNC_CLK,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_CLK,\r\n.cnt_down = sig->mode.hsync_len * 2,\r\n} , {\r\n.run_count = v_total - 1,\r\n.run_src = DI_SYNC_INT_HSYNC,\r\n.offset_count = 1,\r\n.offset_src = DI_SYNC_INT_HSYNC,\r\n.cnt_polarity_gen_en = 1,\r\n.cnt_polarity_trigger_src = DI_SYNC_INT_HSYNC,\r\n.cnt_down = sig->mode.vsync_len * 2,\r\n} , {\r\n},\r\n};\r\nipu_di_write(di, v_total - 1, DI_SCR_CONF);\r\nif (sig->hsync_pin == 2 && sig->vsync_pin == 3)\r\nipu_di_sync_config(di, cfg, 0, ARRAY_SIZE(cfg));\r\nelse\r\nipu_di_sync_config(di, cfg_vga, 0, ARRAY_SIZE(cfg_vga));\r\n}\r\nstatic void ipu_di_config_clock(struct ipu_di *di,\r\nconst struct ipu_di_signal_cfg *sig)\r\n{\r\nstruct clk *clk;\r\nunsigned clkgen0;\r\nuint32_t val;\r\nif (sig->clkflags & IPU_DI_CLKMODE_EXT) {\r\nclk = di->clk_di;\r\nif (sig->clkflags & IPU_DI_CLKMODE_SYNC) {\r\nclkgen0 = 1 << 4;\r\n} else {\r\nunsigned long in_rate;\r\nunsigned div;\r\nclk_set_rate(clk, sig->mode.pixelclock);\r\nin_rate = clk_get_rate(clk);\r\ndiv = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);\r\ndiv = clamp(div, 1U, 255U);\r\nclkgen0 = div << 4;\r\n}\r\n} else {\r\nunsigned long rate, clkrate;\r\nunsigned div, error;\r\nclkrate = clk_get_rate(di->clk_ipu);\r\ndiv = DIV_ROUND_CLOSEST(clkrate, sig->mode.pixelclock);\r\ndiv = clamp(div, 1U, 255U);\r\nrate = clkrate / div;\r\nerror = rate / (sig->mode.pixelclock / 1000);\r\ndev_dbg(di->ipu->dev, " IPU clock can give %lu with divider %u, error %d.%u%%\n",\r\nrate, div, (signed)(error - 1000) / 10, error % 10);\r\nif (error < 1010 && error >= 990) {\r\nclk = di->clk_ipu;\r\nclkgen0 = div << 4;\r\n} else {\r\nunsigned long in_rate;\r\nunsigned div;\r\nclk = di->clk_di;\r\nclk_set_rate(clk, sig->mode.pixelclock);\r\nin_rate = clk_get_rate(clk);\r\ndiv = DIV_ROUND_CLOSEST(in_rate, sig->mode.pixelclock);\r\ndiv = clamp(div, 1U, 255U);\r\nclkgen0 = div << 4;\r\n}\r\n}\r\ndi->clk_di_pixel = clk;\r\nipu_di_write(di, clkgen0, DI_BS_CLKGEN0);\r\nipu_di_write(di, (clkgen0 >> 4) << 16, DI_BS_CLKGEN1);\r\nval = ipu_di_read(di, DI_GENERAL) & ~DI_GEN_DI_CLK_EXT;\r\nif (clk == di->clk_di)\r\nval |= DI_GEN_DI_CLK_EXT;\r\nipu_di_write(di, val, DI_GENERAL);\r\ndev_dbg(di->ipu->dev, "Want %luHz IPU %luHz DI %luHz using %s, %luHz\n",\r\nsig->mode.pixelclock,\r\nclk_get_rate(di->clk_ipu),\r\nclk_get_rate(di->clk_di),\r\nclk == di->clk_di ? "DI" : "IPU",\r\nclk_get_rate(di->clk_di_pixel) / (clkgen0 >> 4));\r\n}\r\nint ipu_di_adjust_videomode(struct ipu_di *di, struct videomode *mode)\r\n{\r\nu32 diff;\r\nif (mode->vfront_porch >= 2)\r\nreturn 0;\r\ndiff = 2 - mode->vfront_porch;\r\nif (mode->vback_porch >= diff) {\r\nmode->vfront_porch = 2;\r\nmode->vback_porch -= diff;\r\n} else if (mode->vsync_len > diff) {\r\nmode->vfront_porch = 2;\r\nmode->vsync_len = mode->vsync_len - diff;\r\n} else {\r\ndev_warn(di->ipu->dev, "failed to adjust videomode\n");\r\nreturn -EINVAL;\r\n}\r\ndev_warn(di->ipu->dev, "videomode adapted for IPU restrictions\n");\r\nreturn 0;\r\n}\r\nint ipu_di_init_sync_panel(struct ipu_di *di, struct ipu_di_signal_cfg *sig)\r\n{\r\nu32 reg;\r\nu32 di_gen, vsync_cnt;\r\nu32 div;\r\ndev_dbg(di->ipu->dev, "disp %d: panel size = %d x %d\n",\r\ndi->id, sig->mode.hactive, sig->mode.vactive);\r\nif ((sig->mode.vsync_len == 0) || (sig->mode.hsync_len == 0))\r\nreturn -EINVAL;\r\ndev_dbg(di->ipu->dev, "Clocks: IPU %luHz DI %luHz Needed %luHz\n",\r\nclk_get_rate(di->clk_ipu),\r\nclk_get_rate(di->clk_di),\r\nsig->mode.pixelclock);\r\nmutex_lock(&di_mutex);\r\nipu_di_config_clock(di, sig);\r\ndiv = ipu_di_read(di, DI_BS_CLKGEN0) & 0xfff;\r\ndiv = div / 16;\r\nipu_di_write(di, (div << 16), DI_BS_CLKGEN1);\r\nipu_di_data_wave_config(di, SYNC_WAVE, div - 1, div - 1);\r\nipu_di_data_pin_config(di, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);\r\ndi_gen = ipu_di_read(di, DI_GENERAL) & DI_GEN_DI_CLK_EXT;\r\ndi_gen |= DI_GEN_DI_VSYNC_EXT;\r\nif (sig->mode.flags & DISPLAY_FLAGS_INTERLACED) {\r\nipu_di_sync_config_interlaced(di, sig);\r\ndi_gen |= 0x10000000;\r\ndi_gen |= DI_GEN_POLARITY_5;\r\ndi_gen |= DI_GEN_POLARITY_8;\r\nvsync_cnt = 7;\r\nif (sig->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\ndi_gen |= DI_GEN_POLARITY_3;\r\nif (sig->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\ndi_gen |= DI_GEN_POLARITY_2;\r\n} else {\r\nipu_di_sync_config_noninterlaced(di, sig, div);\r\nvsync_cnt = 3;\r\nif (di->id == 1)\r\nif (!(sig->hsync_pin == 2 && sig->vsync_pin == 3))\r\nvsync_cnt = 6;\r\nif (sig->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH) {\r\nif (sig->hsync_pin == 2)\r\ndi_gen |= DI_GEN_POLARITY_2;\r\nelse if (sig->hsync_pin == 4)\r\ndi_gen |= DI_GEN_POLARITY_4;\r\nelse if (sig->hsync_pin == 7)\r\ndi_gen |= DI_GEN_POLARITY_7;\r\n}\r\nif (sig->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH) {\r\nif (sig->vsync_pin == 3)\r\ndi_gen |= DI_GEN_POLARITY_3;\r\nelse if (sig->vsync_pin == 6)\r\ndi_gen |= DI_GEN_POLARITY_6;\r\nelse if (sig->vsync_pin == 8)\r\ndi_gen |= DI_GEN_POLARITY_8;\r\n}\r\n}\r\nif (sig->clk_pol)\r\ndi_gen |= DI_GEN_POLARITY_DISP_CLK;\r\nipu_di_write(di, di_gen, DI_GENERAL);\r\nipu_di_write(di, (--vsync_cnt << DI_VSYNC_SEL_OFFSET) | 0x00000002,\r\nDI_SYNC_AS_GEN);\r\nreg = ipu_di_read(di, DI_POL);\r\nreg &= ~(DI_POL_DRDY_DATA_POLARITY | DI_POL_DRDY_POLARITY_15);\r\nif (sig->enable_pol)\r\nreg |= DI_POL_DRDY_POLARITY_15;\r\nif (sig->data_pol)\r\nreg |= DI_POL_DRDY_DATA_POLARITY;\r\nipu_di_write(di, reg, DI_POL);\r\nmutex_unlock(&di_mutex);\r\nreturn 0;\r\n}\r\nint ipu_di_enable(struct ipu_di *di)\r\n{\r\nint ret;\r\nWARN_ON(IS_ERR(di->clk_di_pixel));\r\nret = clk_prepare_enable(di->clk_di_pixel);\r\nif (ret)\r\nreturn ret;\r\nipu_module_enable(di->ipu, di->module);\r\nreturn 0;\r\n}\r\nint ipu_di_disable(struct ipu_di *di)\r\n{\r\nWARN_ON(IS_ERR(di->clk_di_pixel));\r\nipu_module_disable(di->ipu, di->module);\r\nclk_disable_unprepare(di->clk_di_pixel);\r\nreturn 0;\r\n}\r\nint ipu_di_get_num(struct ipu_di *di)\r\n{\r\nreturn di->id;\r\n}\r\nstruct ipu_di *ipu_di_get(struct ipu_soc *ipu, int disp)\r\n{\r\nstruct ipu_di *di;\r\nif (disp > 1)\r\nreturn ERR_PTR(-EINVAL);\r\ndi = ipu->di_priv[disp];\r\nmutex_lock(&ipu_di_lock);\r\nif (di->inuse) {\r\ndi = ERR_PTR(-EBUSY);\r\ngoto out;\r\n}\r\ndi->inuse = true;\r\nout:\r\nmutex_unlock(&ipu_di_lock);\r\nreturn di;\r\n}\r\nvoid ipu_di_put(struct ipu_di *di)\r\n{\r\nmutex_lock(&ipu_di_lock);\r\ndi->inuse = false;\r\nmutex_unlock(&ipu_di_lock);\r\n}\r\nint ipu_di_init(struct ipu_soc *ipu, struct device *dev, int id,\r\nunsigned long base,\r\nu32 module, struct clk *clk_ipu)\r\n{\r\nstruct ipu_di *di;\r\nif (id > 1)\r\nreturn -ENODEV;\r\ndi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\r\nif (!di)\r\nreturn -ENOMEM;\r\nipu->di_priv[id] = di;\r\ndi->clk_di = devm_clk_get(dev, id ? "di1" : "di0");\r\nif (IS_ERR(di->clk_di))\r\nreturn PTR_ERR(di->clk_di);\r\ndi->module = module;\r\ndi->id = id;\r\ndi->clk_ipu = clk_ipu;\r\ndi->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!di->base)\r\nreturn -ENOMEM;\r\nipu_di_write(di, 0x10, DI_BS_CLKGEN0);\r\ndev_dbg(dev, "DI%d base: 0x%08lx remapped to %p\n",\r\nid, base, di->base);\r\ndi->inuse = false;\r\ndi->ipu = ipu;\r\nreturn 0;\r\n}\r\nvoid ipu_di_exit(struct ipu_soc *ipu, int id)\r\n{\r\n}
