unsigned long mmu_read_first_level_page(unsigned long vaddr)\r\n{\r\nunsigned int cpu = hard_processor_id();\r\nunsigned long offset, linear_base, linear_limit;\r\nunsigned int phys0;\r\npgd_t *pgd, entry;\r\nif (is_global_space(vaddr))\r\nvaddr &= ~0x80000000;\r\noffset = vaddr >> PGDIR_SHIFT;\r\nphys0 = metag_in32(mmu_phys0_addr(cpu));\r\nlinear_base = (phys0 >> PGDIR_SHIFT) & 0x1ff;\r\nlinear_limit = 1 << ((phys0 >> 8) & 0xf);\r\nlinear_limit += linear_base;\r\nif (offset < linear_base || offset > linear_limit)\r\nreturn 0;\r\noffset -= linear_base;\r\npgd = (pgd_t *)mmu_get_base();\r\nentry = pgd[offset];\r\nreturn pgd_val(entry);\r\n}\r\nunsigned long mmu_read_second_level_page(unsigned long vaddr)\r\n{\r\nreturn __builtin_meta2_cacherd((void *)(vaddr & PAGE_MASK));\r\n}\r\nunsigned long mmu_get_base(void)\r\n{\r\nunsigned int cpu = hard_processor_id();\r\nunsigned long stride;\r\nstride = cpu * LINSYSMEMTnX_STRIDE;\r\nstride += (metag_in32(mmu_phys1_addr(cpu)) & 0x7fffc);\r\nif (is_global_space(PAGE_OFFSET))\r\nstride += LINSYSMEMTXG_OFFSET;\r\nreturn LINSYSMEMT0L_BASE + stride;\r\n}\r\nstatic void repriv_mmu_tables(void)\r\n{\r\nunsigned long phys0_addr;\r\nunsigned int g;\r\nphys0_addr = MMCU_T0LOCAL_TABLE_PHYS0;\r\nfor (g = 0; g < 2; ++g) {\r\nunsigned int t, phys0;\r\nunsigned long flags;\r\nfor (t = 0; t < 4; ++t) {\r\n__global_lock2(flags);\r\nphys0 = metag_in32(phys0_addr);\r\nif ((phys0 & _PAGE_PRESENT) && !(phys0 & _PAGE_PRIV)) {\r\npr_warn("Fixing priv protection on T%d %s MMU table region\n",\r\nt,\r\ng ? "global" : "local");\r\nphys0 |= _PAGE_PRIV;\r\nmetag_out32(phys0, phys0_addr);\r\n}\r\n__global_unlock2(flags);\r\nphys0_addr += MMCU_TnX_TABLE_PHYSX_STRIDE;\r\n}\r\nphys0_addr += MMCU_TXG_TABLE_PHYSX_OFFSET\r\n- 4*MMCU_TnX_TABLE_PHYSX_STRIDE;\r\n}\r\n}\r\nstatic void mmu_resume(void)\r\n{\r\nrepriv_mmu_tables();\r\n}\r\nvoid __init mmu_init(unsigned long mem_end)\r\n{\r\nunsigned long entry, addr;\r\npgd_t *p_swapper_pg_dir;\r\n#ifdef CONFIG_KERNEL_4M_PAGES\r\nunsigned long mem_size = mem_end - PAGE_OFFSET;\r\nunsigned int pages = DIV_ROUND_UP(mem_size, 1 << 22);\r\nunsigned int second_level_entry = 0;\r\nunsigned long *second_level_table;\r\n#endif\r\naddr = META_MEMORY_BASE;\r\nentry = pgd_index(META_MEMORY_BASE);\r\np_swapper_pg_dir = pgd_offset_k(0) + entry;\r\nwhile (entry < (PTRS_PER_PGD - pgd_index(META_MEMORY_BASE))) {\r\nunsigned long pgd_entry;\r\npgd_entry = mmu_read_first_level_page(addr);\r\npgd_val(*p_swapper_pg_dir) = pgd_entry;\r\np_swapper_pg_dir++;\r\naddr += PGDIR_SIZE;\r\nentry++;\r\n}\r\n#ifdef CONFIG_KERNEL_4M_PAGES\r\nsecond_level_table = alloc_bootmem_pages(SECOND_LEVEL_ALIGN * pages);\r\naddr = PAGE_OFFSET;\r\nentry = pgd_index(PAGE_OFFSET);\r\np_swapper_pg_dir = pgd_offset_k(0) + entry;\r\nwhile (pages > 0) {\r\nunsigned long phys_addr, second_level_phys;\r\npte_t *pte = (pte_t *)&second_level_table[second_level_entry];\r\nphys_addr = __pa(addr);\r\nsecond_level_phys = __pa(pte);\r\npgd_val(*p_swapper_pg_dir) = ((second_level_phys &\r\nFIRST_LEVEL_MASK) |\r\n_PAGE_SZ_4M |\r\n_PAGE_PRESENT);\r\npte_val(*pte) = ((phys_addr & SECOND_LEVEL_MASK) |\r\n_PAGE_PRESENT | _PAGE_DIRTY |\r\n_PAGE_ACCESSED | _PAGE_WRITE |\r\n_PAGE_CACHEABLE | _PAGE_KERNEL);\r\np_swapper_pg_dir++;\r\naddr += PGDIR_SIZE;\r\nsecond_level_entry += (SECOND_LEVEL_ALIGN /\r\nsizeof(unsigned long));\r\npages--;\r\n}\r\nload_pgd(swapper_pg_dir, hard_processor_id());\r\nflush_tlb_all();\r\n#endif\r\nrepriv_mmu_tables();\r\nregister_syscore_ops(&mmu_syscore_ops);\r\n}
