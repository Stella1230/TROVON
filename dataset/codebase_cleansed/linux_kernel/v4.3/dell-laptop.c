static int __init dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic void clear_buffer(void)\r\n{\r\nmemset(buffer, 0, sizeof(struct calling_interface_buffer));\r\n}\r\nstatic void get_buffer(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\nclear_buffer();\r\n}\r\nstatic void release_buffer(void)\r\n{\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nstatic void __init parse_da_table(const struct dmi_header *dm)\r\n{\r\nint tokens = (dm->length-11)/sizeof(struct calling_interface_token)-1;\r\nstruct calling_interface_token *new_da_tokens;\r\nstruct calling_interface_structure *table =\r\ncontainer_of(dm, struct calling_interface_structure, header);\r\nif (dm->length < 17)\r\nreturn;\r\nda_command_address = table->cmdIOAddress;\r\nda_command_code = table->cmdIOCode;\r\nnew_da_tokens = krealloc(da_tokens, (da_num_tokens + tokens) *\r\nsizeof(struct calling_interface_token),\r\nGFP_KERNEL);\r\nif (!new_da_tokens)\r\nreturn;\r\nda_tokens = new_da_tokens;\r\nmemcpy(da_tokens+da_num_tokens, table->tokens,\r\nsizeof(struct calling_interface_token) * tokens);\r\nda_num_tokens += tokens;\r\n}\r\nstatic void __init find_tokens(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch (dm->type) {\r\ncase 0xd4:\r\ncase 0xd5:\r\ncase 0xd6:\r\nbreak;\r\ncase 0xda:\r\nparse_da_table(dm);\r\nbreak;\r\n}\r\n}\r\nstatic int find_token_id(int tokenid)\r\n{\r\nint i;\r\nfor (i = 0; i < da_num_tokens; i++) {\r\nif (da_tokens[i].tokenID == tokenid)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int find_token_location(int tokenid)\r\n{\r\nint id;\r\nid = find_token_id(tokenid);\r\nif (id == -1)\r\nreturn -1;\r\nreturn da_tokens[id].location;\r\n}\r\nstatic struct calling_interface_buffer *\r\ndell_send_request(struct calling_interface_buffer *buffer, int class,\r\nint select)\r\n{\r\nstruct smi_cmd command;\r\ncommand.magic = SMI_CMD_MAGIC;\r\ncommand.command_address = da_command_address;\r\ncommand.command_code = da_command_code;\r\ncommand.ebx = virt_to_phys(buffer);\r\ncommand.ecx = 0x42534931;\r\nbuffer->class = class;\r\nbuffer->select = select;\r\ndcdbas_smi_request(&command);\r\nreturn buffer;\r\n}\r\nstatic inline int dell_smi_error(int value)\r\n{\r\nswitch (value) {\r\ncase 0:\r\nreturn 0;\r\ncase -1:\r\nreturn -EIO;\r\ncase -2:\r\nreturn -ENXIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dell_rfkill_set(void *data, bool blocked)\r\n{\r\nint disable = blocked ? 1 : 0;\r\nunsigned long radio = (unsigned long)data;\r\nint hwswitch_bit = (unsigned long)data - 1;\r\nint hwswitch;\r\nint status;\r\nint ret;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nstatus = buffer->output[1];\r\nif (ret != 0)\r\ngoto out;\r\nclear_buffer();\r\nbuffer->input[0] = 0x2;\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nhwswitch = buffer->output[1];\r\nif (ret == 0 && (hwswitch & BIT(hwswitch_bit)) &&\r\n(status & BIT(0)) && !(status & BIT(16)))\r\ndisable = 1;\r\nclear_buffer();\r\nbuffer->input[0] = (1 | (radio<<8) | (disable << 16));\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nout:\r\nrelease_buffer();\r\nreturn dell_smi_error(ret);\r\n}\r\nstatic void dell_rfkill_update_sw_state(struct rfkill *rfkill, int radio,\r\nint status)\r\n{\r\nif (status & BIT(0)) {\r\nint block = rfkill_blocked(rfkill);\r\nclear_buffer();\r\nbuffer->input[0] = (1 | (radio << 8) | (block << 16));\r\ndell_send_request(buffer, 17, 11);\r\n} else {\r\nrfkill_set_sw_state(rfkill, !!(status & BIT(radio + 16)));\r\n}\r\n}\r\nstatic void dell_rfkill_update_hw_state(struct rfkill *rfkill, int radio,\r\nint status, int hwswitch)\r\n{\r\nif (hwswitch & (BIT(radio - 1)))\r\nrfkill_set_hw_state(rfkill, !(status & BIT(16)));\r\n}\r\nstatic void dell_rfkill_query(struct rfkill *rfkill, void *data)\r\n{\r\nint radio = ((unsigned long)data & 0xF);\r\nint hwswitch;\r\nint status;\r\nint ret;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nstatus = buffer->output[1];\r\nif (ret != 0 || !(status & BIT(0))) {\r\nrelease_buffer();\r\nreturn;\r\n}\r\nclear_buffer();\r\nbuffer->input[0] = 0x2;\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nhwswitch = buffer->output[1];\r\nrelease_buffer();\r\nif (ret != 0)\r\nreturn;\r\ndell_rfkill_update_hw_state(rfkill, radio, status, hwswitch);\r\n}\r\nstatic int dell_debugfs_show(struct seq_file *s, void *data)\r\n{\r\nint hwswitch_state;\r\nint hwswitch_ret;\r\nint status;\r\nint ret;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nstatus = buffer->output[1];\r\nclear_buffer();\r\nbuffer->input[0] = 0x2;\r\ndell_send_request(buffer, 17, 11);\r\nhwswitch_ret = buffer->output[0];\r\nhwswitch_state = buffer->output[1];\r\nrelease_buffer();\r\nseq_printf(s, "return:\t%d\n", ret);\r\nseq_printf(s, "status:\t0x%X\n", status);\r\nseq_printf(s, "Bit 0 : Hardware switch supported: %lu\n",\r\nstatus & BIT(0));\r\nseq_printf(s, "Bit 1 : Wifi locator supported: %lu\n",\r\n(status & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : Wifi is supported: %lu\n",\r\n(status & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 3 : Bluetooth is supported: %lu\n",\r\n(status & BIT(3)) >> 3);\r\nseq_printf(s, "Bit 4 : WWAN is supported: %lu\n",\r\n(status & BIT(4)) >> 4);\r\nseq_printf(s, "Bit 5 : Wireless keyboard supported: %lu\n",\r\n(status & BIT(5)) >> 5);\r\nseq_printf(s, "Bit 6 : UWB supported: %lu\n",\r\n(status & BIT(6)) >> 6);\r\nseq_printf(s, "Bit 7 : WiGig supported: %lu\n",\r\n(status & BIT(7)) >> 7);\r\nseq_printf(s, "Bit 8 : Wifi is installed: %lu\n",\r\n(status & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 9 : Bluetooth is installed: %lu\n",\r\n(status & BIT(9)) >> 9);\r\nseq_printf(s, "Bit 10: WWAN is installed: %lu\n",\r\n(status & BIT(10)) >> 10);\r\nseq_printf(s, "Bit 11: UWB installed: %lu\n",\r\n(status & BIT(11)) >> 11);\r\nseq_printf(s, "Bit 12: WiGig installed: %lu\n",\r\n(status & BIT(12)) >> 12);\r\nseq_printf(s, "Bit 16: Hardware switch is on: %lu\n",\r\n(status & BIT(16)) >> 16);\r\nseq_printf(s, "Bit 17: Wifi is blocked: %lu\n",\r\n(status & BIT(17)) >> 17);\r\nseq_printf(s, "Bit 18: Bluetooth is blocked: %lu\n",\r\n(status & BIT(18)) >> 18);\r\nseq_printf(s, "Bit 19: WWAN is blocked: %lu\n",\r\n(status & BIT(19)) >> 19);\r\nseq_printf(s, "Bit 20: UWB is blocked: %lu\n",\r\n(status & BIT(20)) >> 20);\r\nseq_printf(s, "Bit 21: WiGig is blocked: %lu\n",\r\n(status & BIT(21)) >> 21);\r\nseq_printf(s, "\nhwswitch_return:\t%d\n", hwswitch_ret);\r\nseq_printf(s, "hwswitch_state:\t0x%X\n", hwswitch_state);\r\nseq_printf(s, "Bit 0 : Wifi controlled by switch: %lu\n",\r\nhwswitch_state & BIT(0));\r\nseq_printf(s, "Bit 1 : Bluetooth controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : WWAN controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 3 : UWB controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(3)) >> 3);\r\nseq_printf(s, "Bit 4 : WiGig controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(4)) >> 4);\r\nseq_printf(s, "Bit 7 : Wireless switch config locked: %lu\n",\r\n(hwswitch_state & BIT(7)) >> 7);\r\nseq_printf(s, "Bit 8 : Wifi locator enabled: %lu\n",\r\n(hwswitch_state & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 15: Wifi locator setting locked: %lu\n",\r\n(hwswitch_state & BIT(15)) >> 15);\r\nreturn 0;\r\n}\r\nstatic int dell_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dell_debugfs_show, inode->i_private);\r\n}\r\nstatic void dell_update_rfkill(struct work_struct *ignored)\r\n{\r\nint hwswitch = 0;\r\nint status;\r\nint ret;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nstatus = buffer->output[1];\r\nif (ret != 0)\r\ngoto out;\r\nclear_buffer();\r\nbuffer->input[0] = 0x2;\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nif (ret == 0 && (status & BIT(0)))\r\nhwswitch = buffer->output[1];\r\nif (wifi_rfkill) {\r\ndell_rfkill_update_hw_state(wifi_rfkill, 1, status, hwswitch);\r\ndell_rfkill_update_sw_state(wifi_rfkill, 1, status);\r\n}\r\nif (bluetooth_rfkill) {\r\ndell_rfkill_update_hw_state(bluetooth_rfkill, 2, status,\r\nhwswitch);\r\ndell_rfkill_update_sw_state(bluetooth_rfkill, 2, status);\r\n}\r\nif (wwan_rfkill) {\r\ndell_rfkill_update_hw_state(wwan_rfkill, 3, status, hwswitch);\r\ndell_rfkill_update_sw_state(wwan_rfkill, 3, status);\r\n}\r\nout:\r\nrelease_buffer();\r\n}\r\nstatic bool dell_laptop_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nstatic bool extended;\r\nif (str & I8042_STR_AUXDATA)\r\nreturn false;\r\nif (unlikely(data == 0xe0)) {\r\nextended = true;\r\nreturn false;\r\n} else if (unlikely(extended)) {\r\nswitch (data) {\r\ncase 0x8:\r\nschedule_delayed_work(&dell_rfkill_work,\r\nround_jiffies_relative(HZ / 4));\r\nbreak;\r\n}\r\nextended = false;\r\n}\r\nreturn false;\r\n}\r\nstatic int dell_laptop_rbtn_notifier_call(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nschedule_delayed_work(&dell_rfkill_work, 0);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init dell_setup_rfkill(void)\r\n{\r\nint status, ret, whitelisted;\r\nconst char *product;\r\nwhitelisted = 0;\r\nproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\r\nif (product && (strncmp(product, "Latitude", 8) == 0 ||\r\nstrncmp(product, "Precision", 9) == 0))\r\nwhitelisted = 1;\r\nif (!force_rfkill && !whitelisted)\r\nreturn 0;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nret = buffer->output[0];\r\nstatus = buffer->output[1];\r\nrelease_buffer();\r\nif (ret != 0)\r\nreturn 0;\r\nif (!(status & BIT(0)) && !force_rfkill)\r\nreturn 0;\r\nif ((status & (1<<2|1<<8)) == (1<<2|1<<8)) {\r\nwifi_rfkill = rfkill_alloc("dell-wifi", &platform_device->dev,\r\nRFKILL_TYPE_WLAN,\r\n&dell_rfkill_ops, (void *) 1);\r\nif (!wifi_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_wifi;\r\n}\r\nret = rfkill_register(wifi_rfkill);\r\nif (ret)\r\ngoto err_wifi;\r\n}\r\nif ((status & (1<<3|1<<9)) == (1<<3|1<<9)) {\r\nbluetooth_rfkill = rfkill_alloc("dell-bluetooth",\r\n&platform_device->dev,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&dell_rfkill_ops, (void *) 2);\r\nif (!bluetooth_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_bluetooth;\r\n}\r\nret = rfkill_register(bluetooth_rfkill);\r\nif (ret)\r\ngoto err_bluetooth;\r\n}\r\nif ((status & (1<<4|1<<10)) == (1<<4|1<<10)) {\r\nwwan_rfkill = rfkill_alloc("dell-wwan",\r\n&platform_device->dev,\r\nRFKILL_TYPE_WWAN,\r\n&dell_rfkill_ops, (void *) 3);\r\nif (!wwan_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_wwan;\r\n}\r\nret = rfkill_register(wwan_rfkill);\r\nif (ret)\r\ngoto err_wwan;\r\n}\r\ndell_rbtn_notifier_register_func =\r\nsymbol_request(dell_rbtn_notifier_register);\r\nif (dell_rbtn_notifier_register_func) {\r\ndell_rbtn_notifier_unregister_func =\r\nsymbol_request(dell_rbtn_notifier_unregister);\r\nif (!dell_rbtn_notifier_unregister_func) {\r\nsymbol_put(dell_rbtn_notifier_register);\r\ndell_rbtn_notifier_register_func = NULL;\r\n}\r\n}\r\nif (dell_rbtn_notifier_register_func) {\r\nret = dell_rbtn_notifier_register_func(\r\n&dell_laptop_rbtn_notifier);\r\nsymbol_put(dell_rbtn_notifier_register);\r\ndell_rbtn_notifier_register_func = NULL;\r\nif (ret != 0) {\r\nsymbol_put(dell_rbtn_notifier_unregister);\r\ndell_rbtn_notifier_unregister_func = NULL;\r\n}\r\n} else {\r\npr_info("Symbols from dell-rbtn acpi driver are not available\n");\r\nret = -ENODEV;\r\n}\r\nif (ret == 0) {\r\npr_info("Using dell-rbtn acpi driver for receiving events\n");\r\n} else if (ret != -ENODEV) {\r\npr_warn("Unable to register dell rbtn notifier\n");\r\ngoto err_filter;\r\n} else {\r\nret = i8042_install_filter(dell_laptop_i8042_filter);\r\nif (ret) {\r\npr_warn("Unable to install key filter\n");\r\ngoto err_filter;\r\n}\r\npr_info("Using i8042 filter function for receiving events\n");\r\n}\r\nreturn 0;\r\nerr_filter:\r\nif (wwan_rfkill)\r\nrfkill_unregister(wwan_rfkill);\r\nerr_wwan:\r\nrfkill_destroy(wwan_rfkill);\r\nif (bluetooth_rfkill)\r\nrfkill_unregister(bluetooth_rfkill);\r\nerr_bluetooth:\r\nrfkill_destroy(bluetooth_rfkill);\r\nif (wifi_rfkill)\r\nrfkill_unregister(wifi_rfkill);\r\nerr_wifi:\r\nrfkill_destroy(wifi_rfkill);\r\nreturn ret;\r\n}\r\nstatic void dell_cleanup_rfkill(void)\r\n{\r\nif (dell_rbtn_notifier_unregister_func) {\r\ndell_rbtn_notifier_unregister_func(&dell_laptop_rbtn_notifier);\r\nsymbol_put(dell_rbtn_notifier_unregister);\r\ndell_rbtn_notifier_unregister_func = NULL;\r\n} else {\r\ni8042_remove_filter(dell_laptop_i8042_filter);\r\n}\r\ncancel_delayed_work_sync(&dell_rfkill_work);\r\nif (wifi_rfkill) {\r\nrfkill_unregister(wifi_rfkill);\r\nrfkill_destroy(wifi_rfkill);\r\n}\r\nif (bluetooth_rfkill) {\r\nrfkill_unregister(bluetooth_rfkill);\r\nrfkill_destroy(bluetooth_rfkill);\r\n}\r\nif (wwan_rfkill) {\r\nrfkill_unregister(wwan_rfkill);\r\nrfkill_destroy(wwan_rfkill);\r\n}\r\n}\r\nstatic int dell_send_intensity(struct backlight_device *bd)\r\n{\r\nint token;\r\nint ret;\r\ntoken = find_token_location(BRIGHTNESS_TOKEN);\r\nif (token == -1)\r\nreturn -ENODEV;\r\nget_buffer();\r\nbuffer->input[0] = token;\r\nbuffer->input[1] = bd->props.brightness;\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 1, 2);\r\nelse\r\ndell_send_request(buffer, 1, 1);\r\nret = dell_smi_error(buffer->output[0]);\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic int dell_get_intensity(struct backlight_device *bd)\r\n{\r\nint token;\r\nint ret;\r\ntoken = find_token_location(BRIGHTNESS_TOKEN);\r\nif (token == -1)\r\nreturn -ENODEV;\r\nget_buffer();\r\nbuffer->input[0] = token;\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 0, 2);\r\nelse\r\ndell_send_request(buffer, 0, 1);\r\nif (buffer->output[0])\r\nret = dell_smi_error(buffer->output[0]);\r\nelse\r\nret = buffer->output[1];\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic void touchpad_led_on(void)\r\n{\r\nint command = 0x97;\r\nchar data = 1;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_off(void)\r\n{\r\nint command = 0x97;\r\nchar data = 2;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nif (value > 0)\r\ntouchpad_led_on();\r\nelse\r\ntouchpad_led_off();\r\n}\r\nstatic int __init touchpad_led_init(struct device *dev)\r\n{\r\nreturn led_classdev_register(dev, &touchpad_led);\r\n}\r\nstatic void touchpad_led_exit(void)\r\n{\r\nled_classdev_unregister(&touchpad_led);\r\n}\r\nstatic int kbd_get_info(struct kbd_info *info)\r\n{\r\nu8 units;\r\nint ret;\r\nget_buffer();\r\nbuffer->input[0] = 0x0;\r\ndell_send_request(buffer, 4, 11);\r\nret = buffer->output[0];\r\nif (ret) {\r\nret = dell_smi_error(ret);\r\ngoto out;\r\n}\r\ninfo->modes = buffer->output[1] & 0xFFFF;\r\ninfo->type = (buffer->output[1] >> 24) & 0xFF;\r\ninfo->triggers = buffer->output[2] & 0xFF;\r\nunits = (buffer->output[2] >> 8) & 0xFF;\r\ninfo->levels = (buffer->output[2] >> 16) & 0xFF;\r\nif (units & BIT(0))\r\ninfo->seconds = (buffer->output[3] >> 0) & 0xFF;\r\nif (units & BIT(1))\r\ninfo->minutes = (buffer->output[3] >> 8) & 0xFF;\r\nif (units & BIT(2))\r\ninfo->hours = (buffer->output[3] >> 16) & 0xFF;\r\nif (units & BIT(3))\r\ninfo->days = (buffer->output[3] >> 24) & 0xFF;\r\nout:\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic unsigned int kbd_get_max_level(void)\r\n{\r\nif (kbd_info.levels != 0)\r\nreturn kbd_info.levels;\r\nif (kbd_mode_levels_count > 0)\r\nreturn kbd_mode_levels_count - 1;\r\nreturn 0;\r\n}\r\nstatic int kbd_get_level(struct kbd_state *state)\r\n{\r\nint i;\r\nif (kbd_info.levels != 0)\r\nreturn state->level;\r\nif (kbd_mode_levels_count > 0) {\r\nfor (i = 0; i < kbd_mode_levels_count; ++i)\r\nif (kbd_mode_levels[i] == state->mode_bit)\r\nreturn i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kbd_set_level(struct kbd_state *state, u8 level)\r\n{\r\nif (kbd_info.levels != 0) {\r\nif (level != 0)\r\nkbd_previous_level = level;\r\nif (state->level == level)\r\nreturn 0;\r\nstate->level = level;\r\nif (level != 0 && state->mode_bit == KBD_MODE_BIT_OFF)\r\nstate->mode_bit = kbd_previous_mode_bit;\r\nelse if (level == 0 && state->mode_bit != KBD_MODE_BIT_OFF) {\r\nkbd_previous_mode_bit = state->mode_bit;\r\nstate->mode_bit = KBD_MODE_BIT_OFF;\r\n}\r\nreturn 0;\r\n}\r\nif (kbd_mode_levels_count > 0 && level < kbd_mode_levels_count) {\r\nif (level != 0)\r\nkbd_previous_level = level;\r\nstate->mode_bit = kbd_mode_levels[level];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kbd_get_state(struct kbd_state *state)\r\n{\r\nint ret;\r\nget_buffer();\r\nbuffer->input[0] = 0x1;\r\ndell_send_request(buffer, 4, 11);\r\nret = buffer->output[0];\r\nif (ret) {\r\nret = dell_smi_error(ret);\r\ngoto out;\r\n}\r\nstate->mode_bit = ffs(buffer->output[1] & 0xFFFF);\r\nif (state->mode_bit != 0)\r\nstate->mode_bit--;\r\nstate->triggers = (buffer->output[1] >> 16) & 0xFF;\r\nstate->timeout_value = (buffer->output[1] >> 24) & 0x3F;\r\nstate->timeout_unit = (buffer->output[1] >> 30) & 0x3;\r\nstate->als_setting = buffer->output[2] & 0xFF;\r\nstate->als_value = (buffer->output[2] >> 8) & 0xFF;\r\nstate->level = (buffer->output[2] >> 16) & 0xFF;\r\nout:\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic int kbd_set_state(struct kbd_state *state)\r\n{\r\nint ret;\r\nget_buffer();\r\nbuffer->input[0] = 0x2;\r\nbuffer->input[1] = BIT(state->mode_bit) & 0xFFFF;\r\nbuffer->input[1] |= (state->triggers & 0xFF) << 16;\r\nbuffer->input[1] |= (state->timeout_value & 0x3F) << 24;\r\nbuffer->input[1] |= (state->timeout_unit & 0x3) << 30;\r\nbuffer->input[2] = state->als_setting & 0xFF;\r\nbuffer->input[2] |= (state->level & 0xFF) << 16;\r\ndell_send_request(buffer, 4, 11);\r\nret = buffer->output[0];\r\nrelease_buffer();\r\nreturn dell_smi_error(ret);\r\n}\r\nstatic int kbd_set_state_safe(struct kbd_state *state, struct kbd_state *old)\r\n{\r\nint ret;\r\nret = kbd_set_state(state);\r\nif (ret == 0)\r\nreturn 0;\r\nif (kbd_set_state(old))\r\npr_err("Setting old previous keyboard state failed\n");\r\nreturn ret;\r\n}\r\nstatic int kbd_set_token_bit(u8 bit)\r\n{\r\nint id;\r\nint ret;\r\nif (bit >= ARRAY_SIZE(kbd_tokens))\r\nreturn -EINVAL;\r\nid = find_token_id(kbd_tokens[bit]);\r\nif (id == -1)\r\nreturn -EINVAL;\r\nget_buffer();\r\nbuffer->input[0] = da_tokens[id].location;\r\nbuffer->input[1] = da_tokens[id].value;\r\ndell_send_request(buffer, 1, 0);\r\nret = buffer->output[0];\r\nrelease_buffer();\r\nreturn dell_smi_error(ret);\r\n}\r\nstatic int kbd_get_token_bit(u8 bit)\r\n{\r\nint id;\r\nint ret;\r\nint val;\r\nif (bit >= ARRAY_SIZE(kbd_tokens))\r\nreturn -EINVAL;\r\nid = find_token_id(kbd_tokens[bit]);\r\nif (id == -1)\r\nreturn -EINVAL;\r\nget_buffer();\r\nbuffer->input[0] = da_tokens[id].location;\r\ndell_send_request(buffer, 0, 0);\r\nret = buffer->output[0];\r\nval = buffer->output[1];\r\nrelease_buffer();\r\nif (ret)\r\nreturn dell_smi_error(ret);\r\nreturn (val == da_tokens[id].value);\r\n}\r\nstatic int kbd_get_first_active_token_bit(void)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(kbd_tokens); ++i) {\r\nret = kbd_get_token_bit(i);\r\nif (ret == 1)\r\nreturn i;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kbd_get_valid_token_counts(void)\r\n{\r\nreturn hweight16(kbd_token_bits);\r\n}\r\nstatic inline int kbd_init_info(void)\r\n{\r\nstruct kbd_state state;\r\nint ret;\r\nint i;\r\nret = kbd_get_info(&kbd_info);\r\nif (ret)\r\nreturn ret;\r\nkbd_get_state(&state);\r\nif (kbd_info.seconds > 63)\r\nkbd_info.seconds = 63;\r\nif (kbd_info.minutes > 63)\r\nkbd_info.minutes = 63;\r\nif (kbd_info.hours > 63)\r\nkbd_info.hours = 63;\r\nif (kbd_info.days > 63)\r\nkbd_info.days = 63;\r\nkbd_info.modes &= ~BIT(KBD_MODE_BIT_ON);\r\nkbd_previous_level = kbd_get_level(&state);\r\nkbd_previous_mode_bit = state.mode_bit;\r\nif (kbd_previous_level == 0 && kbd_get_max_level() != 0)\r\nkbd_previous_level = 1;\r\nif (kbd_previous_mode_bit == KBD_MODE_BIT_OFF) {\r\nkbd_previous_mode_bit =\r\nffs(kbd_info.modes & ~BIT(KBD_MODE_BIT_OFF));\r\nif (kbd_previous_mode_bit != 0)\r\nkbd_previous_mode_bit--;\r\n}\r\nif (kbd_info.modes & (BIT(KBD_MODE_BIT_ALS) |\r\nBIT(KBD_MODE_BIT_TRIGGER_ALS)))\r\nkbd_als_supported = true;\r\nif (kbd_info.modes & (\r\nBIT(KBD_MODE_BIT_TRIGGER_ALS) | BIT(KBD_MODE_BIT_TRIGGER) |\r\nBIT(KBD_MODE_BIT_TRIGGER_25) | BIT(KBD_MODE_BIT_TRIGGER_50) |\r\nBIT(KBD_MODE_BIT_TRIGGER_75) | BIT(KBD_MODE_BIT_TRIGGER_100)\r\n))\r\nkbd_triggers_supported = true;\r\nfor (i = 0; i < 16; ++i)\r\nif (kbd_is_level_mode_bit(i) && (BIT(i) & kbd_info.modes))\r\nkbd_mode_levels[1 + kbd_mode_levels_count++] = i;\r\nif (kbd_mode_levels_count > 0) {\r\nfor (i = 0; i < 16; ++i) {\r\nif (BIT(i) & kbd_info.modes) {\r\nkbd_mode_levels[0] = i;\r\nbreak;\r\n}\r\n}\r\nkbd_mode_levels_count++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void kbd_init_tokens(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kbd_tokens); ++i)\r\nif (find_token_id(kbd_tokens[i]) != -1)\r\nkbd_token_bits |= BIT(i);\r\n}\r\nstatic void kbd_init(void)\r\n{\r\nint ret;\r\nret = kbd_init_info();\r\nkbd_init_tokens();\r\nif (kbd_token_bits != 0 || ret == 0)\r\nkbd_led_present = true;\r\n}\r\nstatic ssize_t kbd_led_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct kbd_state new_state;\r\nstruct kbd_state state;\r\nbool convert;\r\nint value;\r\nint ret;\r\nchar ch;\r\nu8 unit;\r\nint i;\r\nret = sscanf(buf, "%d %c", &value, &ch);\r\nif (ret < 1)\r\nreturn -EINVAL;\r\nelse if (ret == 1)\r\nch = 's';\r\nif (value < 0)\r\nreturn -EINVAL;\r\nconvert = false;\r\nswitch (ch) {\r\ncase 's':\r\nif (value > kbd_info.seconds)\r\nconvert = true;\r\nunit = KBD_TIMEOUT_SECONDS;\r\nbreak;\r\ncase 'm':\r\nif (value > kbd_info.minutes)\r\nconvert = true;\r\nunit = KBD_TIMEOUT_MINUTES;\r\nbreak;\r\ncase 'h':\r\nif (value > kbd_info.hours)\r\nconvert = true;\r\nunit = KBD_TIMEOUT_HOURS;\r\nbreak;\r\ncase 'd':\r\nif (value > kbd_info.days)\r\nconvert = true;\r\nunit = KBD_TIMEOUT_DAYS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (quirks && quirks->needs_kbd_timeouts)\r\nconvert = true;\r\nif (convert) {\r\nswitch (unit) {\r\ncase KBD_TIMEOUT_DAYS:\r\nvalue *= 24;\r\ncase KBD_TIMEOUT_HOURS:\r\nvalue *= 60;\r\ncase KBD_TIMEOUT_MINUTES:\r\nvalue *= 60;\r\nunit = KBD_TIMEOUT_SECONDS;\r\n}\r\nif (quirks && quirks->needs_kbd_timeouts) {\r\nfor (i = 0; quirks->kbd_timeouts[i] != -1; i++) {\r\nif (value <= quirks->kbd_timeouts[i]) {\r\nvalue = quirks->kbd_timeouts[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (value <= kbd_info.seconds && kbd_info.seconds) {\r\nunit = KBD_TIMEOUT_SECONDS;\r\n} else if (value / 60 <= kbd_info.minutes && kbd_info.minutes) {\r\nvalue /= 60;\r\nunit = KBD_TIMEOUT_MINUTES;\r\n} else if (value / (60 * 60) <= kbd_info.hours && kbd_info.hours) {\r\nvalue /= (60 * 60);\r\nunit = KBD_TIMEOUT_HOURS;\r\n} else if (value / (60 * 60 * 24) <= kbd_info.days && kbd_info.days) {\r\nvalue /= (60 * 60 * 24);\r\nunit = KBD_TIMEOUT_DAYS;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nnew_state = state;\r\nnew_state.timeout_value = value;\r\nnew_state.timeout_unit = unit;\r\nret = kbd_set_state_safe(&new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_led_timeout_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kbd_state state;\r\nint ret;\r\nint len;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nlen = sprintf(buf, "%d", state.timeout_value);\r\nswitch (state.timeout_unit) {\r\ncase KBD_TIMEOUT_SECONDS:\r\nreturn len + sprintf(buf+len, "s\n");\r\ncase KBD_TIMEOUT_MINUTES:\r\nreturn len + sprintf(buf+len, "m\n");\r\ncase KBD_TIMEOUT_HOURS:\r\nreturn len + sprintf(buf+len, "h\n");\r\ncase KBD_TIMEOUT_DAYS:\r\nreturn len + sprintf(buf+len, "d\n");\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t kbd_led_triggers_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct kbd_state new_state;\r\nstruct kbd_state state;\r\nbool triggers_enabled = false;\r\nint trigger_bit = -1;\r\nchar trigger[21];\r\nint i, ret;\r\nret = sscanf(buf, "%20s", trigger);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (trigger[0] != '+' && trigger[0] != '-')\r\nreturn -EINVAL;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nif (kbd_triggers_supported)\r\ntriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\r\nif (kbd_triggers_supported) {\r\nfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); ++i) {\r\nif (!(kbd_info.triggers & BIT(i)))\r\ncontinue;\r\nif (!kbd_led_triggers[i])\r\ncontinue;\r\nif (strcmp(trigger+1, kbd_led_triggers[i]) != 0)\r\ncontinue;\r\nif (trigger[0] == '+' &&\r\ntriggers_enabled && (state.triggers & BIT(i)))\r\nreturn count;\r\nif (trigger[0] == '-' &&\r\n(!triggers_enabled || !(state.triggers & BIT(i))))\r\nreturn count;\r\ntrigger_bit = i;\r\nbreak;\r\n}\r\n}\r\nif (trigger_bit != -1) {\r\nnew_state = state;\r\nif (trigger[0] == '+')\r\nnew_state.triggers |= BIT(trigger_bit);\r\nelse {\r\nnew_state.triggers &= ~BIT(trigger_bit);\r\nif (trigger_bit == 1)\r\nnew_state.triggers &= ~BIT(2);\r\n}\r\nif ((kbd_info.triggers & new_state.triggers) !=\r\nnew_state.triggers)\r\nreturn -EINVAL;\r\nif (new_state.triggers && !triggers_enabled) {\r\nnew_state.mode_bit = KBD_MODE_BIT_TRIGGER;\r\nkbd_set_level(&new_state, kbd_previous_level);\r\n} else if (new_state.triggers == 0) {\r\nkbd_set_level(&new_state, 0);\r\n}\r\nif (!(kbd_info.modes & BIT(new_state.mode_bit)))\r\nreturn -EINVAL;\r\nret = kbd_set_state_safe(&new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nif (new_state.mode_bit != KBD_MODE_BIT_OFF)\r\nkbd_previous_mode_bit = new_state.mode_bit;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t kbd_led_triggers_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct kbd_state state;\r\nbool triggers_enabled;\r\nint level, i, ret;\r\nint len = 0;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nlen = 0;\r\nif (kbd_triggers_supported) {\r\ntriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\r\nlevel = kbd_get_level(&state);\r\nfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); ++i) {\r\nif (!(kbd_info.triggers & BIT(i)))\r\ncontinue;\r\nif (!kbd_led_triggers[i])\r\ncontinue;\r\nif ((triggers_enabled || level <= 0) &&\r\n(state.triggers & BIT(i)))\r\nbuf[len++] = '+';\r\nelse\r\nbuf[len++] = '-';\r\nlen += sprintf(buf+len, "%s ", kbd_led_triggers[i]);\r\n}\r\n}\r\nif (len)\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t kbd_led_als_enabled_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct kbd_state new_state;\r\nstruct kbd_state state;\r\nbool triggers_enabled = false;\r\nint enable;\r\nint ret;\r\nret = kstrtoint(buf, 0, &enable);\r\nif (ret)\r\nreturn ret;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nif (enable == kbd_is_als_mode_bit(state.mode_bit))\r\nreturn count;\r\nnew_state = state;\r\nif (kbd_triggers_supported)\r\ntriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\r\nif (enable) {\r\nif (triggers_enabled)\r\nnew_state.mode_bit = KBD_MODE_BIT_TRIGGER_ALS;\r\nelse\r\nnew_state.mode_bit = KBD_MODE_BIT_ALS;\r\n} else {\r\nif (triggers_enabled) {\r\nnew_state.mode_bit = KBD_MODE_BIT_TRIGGER;\r\nkbd_set_level(&new_state, kbd_previous_level);\r\n} else {\r\nnew_state.mode_bit = KBD_MODE_BIT_ON;\r\n}\r\n}\r\nif (!(kbd_info.modes & BIT(new_state.mode_bit)))\r\nreturn -EINVAL;\r\nret = kbd_set_state_safe(&new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nkbd_previous_mode_bit = new_state.mode_bit;\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_led_als_enabled_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct kbd_state state;\r\nbool enabled = false;\r\nint ret;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nenabled = kbd_is_als_mode_bit(state.mode_bit);\r\nreturn sprintf(buf, "%d\n", enabled ? 1 : 0);\r\n}\r\nstatic ssize_t kbd_led_als_setting_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct kbd_state state;\r\nstruct kbd_state new_state;\r\nu8 setting;\r\nint ret;\r\nret = kstrtou8(buf, 10, &setting);\r\nif (ret)\r\nreturn ret;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nnew_state = state;\r\nnew_state.als_setting = setting;\r\nret = kbd_set_state_safe(&new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_led_als_setting_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct kbd_state state;\r\nint ret;\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", state.als_setting);\r\n}\r\nstatic enum led_brightness kbd_led_level_get(struct led_classdev *led_cdev)\r\n{\r\nint ret;\r\nu16 num;\r\nstruct kbd_state state;\r\nif (kbd_get_max_level()) {\r\nret = kbd_get_state(&state);\r\nif (ret)\r\nreturn 0;\r\nret = kbd_get_level(&state);\r\nif (ret < 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nif (kbd_get_valid_token_counts()) {\r\nret = kbd_get_first_active_token_bit();\r\nif (ret < 0)\r\nreturn 0;\r\nfor (num = kbd_token_bits; num != 0 && ret > 0; --ret)\r\nnum &= num - 1;\r\nif (num == 0)\r\nreturn 0;\r\nreturn ffs(num) - 1;\r\n}\r\npr_warn("Keyboard brightness level control not supported\n");\r\nreturn 0;\r\n}\r\nstatic void kbd_led_level_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct kbd_state state;\r\nstruct kbd_state new_state;\r\nu16 num;\r\nif (kbd_get_max_level()) {\r\nif (kbd_get_state(&state))\r\nreturn;\r\nnew_state = state;\r\nif (kbd_set_level(&new_state, value))\r\nreturn;\r\nkbd_set_state_safe(&new_state, &state);\r\nreturn;\r\n}\r\nif (kbd_get_valid_token_counts()) {\r\nfor (num = kbd_token_bits; num != 0 && value > 0; --value)\r\nnum &= num - 1;\r\nif (num == 0)\r\nreturn;\r\nkbd_set_token_bit(ffs(num) - 1);\r\nreturn;\r\n}\r\npr_warn("Keyboard brightness level control not supported\n");\r\n}\r\nstatic int __init kbd_led_init(struct device *dev)\r\n{\r\nkbd_init();\r\nif (!kbd_led_present)\r\nreturn -ENODEV;\r\nif (!kbd_als_supported)\r\nkbd_led_groups[1] = NULL;\r\nkbd_led.max_brightness = kbd_get_max_level();\r\nif (!kbd_led.max_brightness) {\r\nkbd_led.max_brightness = kbd_get_valid_token_counts();\r\nif (kbd_led.max_brightness)\r\nkbd_led.max_brightness--;\r\n}\r\nreturn led_classdev_register(dev, &kbd_led);\r\n}\r\nstatic void brightness_set_exit(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\n}\r\nstatic void kbd_led_exit(void)\r\n{\r\nif (!kbd_led_present)\r\nreturn;\r\nkbd_led.brightness_set = brightness_set_exit;\r\nled_classdev_unregister(&kbd_led);\r\n}\r\nstatic int __init dell_init(void)\r\n{\r\nint max_intensity = 0;\r\nint token;\r\nint ret;\r\nif (!dmi_check_system(dell_device_table))\r\nreturn -ENODEV;\r\nquirks = NULL;\r\ndmi_check_system(dell_quirks);\r\ndmi_walk(find_tokens, NULL);\r\nif (!da_tokens) {\r\npr_info("Unable to find dmi tokens\n");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&platform_driver);\r\nif (ret)\r\ngoto fail_platform_driver;\r\nplatform_device = platform_device_alloc("dell-laptop", -1);\r\nif (!platform_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_device1;\r\n}\r\nret = platform_device_add(platform_device);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nbuffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto fail_buffer;\r\n}\r\nret = dell_setup_rfkill();\r\nif (ret) {\r\npr_warn("Unable to setup rfkill\n");\r\ngoto fail_rfkill;\r\n}\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_init(&platform_device->dev);\r\nkbd_led_init(&platform_device->dev);\r\ndell_laptop_dir = debugfs_create_dir("dell_laptop", NULL);\r\nif (dell_laptop_dir != NULL)\r\ndebugfs_create_file("rfkill", 0444, dell_laptop_dir, NULL,\r\n&dell_debugfs_fops);\r\nif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\r\nreturn 0;\r\ntoken = find_token_location(BRIGHTNESS_TOKEN);\r\nif (token != -1) {\r\nget_buffer();\r\nbuffer->input[0] = token;\r\ndell_send_request(buffer, 0, 2);\r\nif (buffer->output[0] == 0)\r\nmax_intensity = buffer->output[3];\r\nrelease_buffer();\r\n}\r\nif (max_intensity) {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_intensity;\r\ndell_backlight_device = backlight_device_register("dell_backlight",\r\n&platform_device->dev,\r\nNULL,\r\n&dell_ops,\r\n&props);\r\nif (IS_ERR(dell_backlight_device)) {\r\nret = PTR_ERR(dell_backlight_device);\r\ndell_backlight_device = NULL;\r\ngoto fail_backlight;\r\n}\r\ndell_backlight_device->props.brightness =\r\ndell_get_intensity(dell_backlight_device);\r\nbacklight_update_status(dell_backlight_device);\r\n}\r\nreturn 0;\r\nfail_backlight:\r\ndell_cleanup_rfkill();\r\nfail_rfkill:\r\nfree_page((unsigned long)buffer);\r\nfail_buffer:\r\nplatform_device_del(platform_device);\r\nfail_platform_device2:\r\nplatform_device_put(platform_device);\r\nfail_platform_device1:\r\nplatform_driver_unregister(&platform_driver);\r\nfail_platform_driver:\r\nkfree(da_tokens);\r\nreturn ret;\r\n}\r\nstatic void __exit dell_exit(void)\r\n{\r\ndebugfs_remove_recursive(dell_laptop_dir);\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_exit();\r\nkbd_led_exit();\r\nbacklight_device_unregister(dell_backlight_device);\r\ndell_cleanup_rfkill();\r\nif (platform_device) {\r\nplatform_device_unregister(platform_device);\r\nplatform_driver_unregister(&platform_driver);\r\n}\r\nkfree(da_tokens);\r\nfree_page((unsigned long)buffer);\r\n}
