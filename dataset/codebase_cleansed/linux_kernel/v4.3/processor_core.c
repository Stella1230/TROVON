static struct acpi_table_madt *get_madt_table(void)\r\n{\r\nstatic struct acpi_table_madt *madt;\r\nstatic int read_madt;\r\nif (!read_madt) {\r\nif (ACPI_FAILURE(acpi_get_table(ACPI_SIG_MADT, 0,\r\n(struct acpi_table_header **)&madt)))\r\nmadt = NULL;\r\nread_madt++;\r\n}\r\nreturn madt;\r\n}\r\nstatic int map_lapic_id(struct acpi_subtable_header *entry,\r\nu32 acpi_id, phys_cpuid_t *apic_id)\r\n{\r\nstruct acpi_madt_local_apic *lapic =\r\ncontainer_of(entry, struct acpi_madt_local_apic, header);\r\nif (!(lapic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn -ENODEV;\r\nif (lapic->processor_id != acpi_id)\r\nreturn -EINVAL;\r\n*apic_id = lapic->id;\r\nreturn 0;\r\n}\r\nstatic int map_x2apic_id(struct acpi_subtable_header *entry,\r\nint device_declaration, u32 acpi_id, phys_cpuid_t *apic_id)\r\n{\r\nstruct acpi_madt_local_x2apic *apic =\r\ncontainer_of(entry, struct acpi_madt_local_x2apic, header);\r\nif (!(apic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn -ENODEV;\r\nif (device_declaration && (apic->uid == acpi_id)) {\r\n*apic_id = apic->local_apic_id;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int map_lsapic_id(struct acpi_subtable_header *entry,\r\nint device_declaration, u32 acpi_id, phys_cpuid_t *apic_id)\r\n{\r\nstruct acpi_madt_local_sapic *lsapic =\r\ncontainer_of(entry, struct acpi_madt_local_sapic, header);\r\nif (!(lsapic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn -ENODEV;\r\nif (device_declaration) {\r\nif ((entry->length < 16) || (lsapic->uid != acpi_id))\r\nreturn -EINVAL;\r\n} else if (lsapic->processor_id != acpi_id)\r\nreturn -EINVAL;\r\n*apic_id = (lsapic->id << 8) | lsapic->eid;\r\nreturn 0;\r\n}\r\nstatic int map_gicc_mpidr(struct acpi_subtable_header *entry,\r\nint device_declaration, u32 acpi_id, phys_cpuid_t *mpidr)\r\n{\r\nstruct acpi_madt_generic_interrupt *gicc =\r\ncontainer_of(entry, struct acpi_madt_generic_interrupt, header);\r\nif (!(gicc->flags & ACPI_MADT_ENABLED))\r\nreturn -ENODEV;\r\nif (device_declaration && (gicc->uid == acpi_id)) {\r\n*mpidr = gicc->arm_mpidr;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic phys_cpuid_t map_madt_entry(int type, u32 acpi_id)\r\n{\r\nunsigned long madt_end, entry;\r\nphys_cpuid_t phys_id = PHYS_CPUID_INVALID;\r\nstruct acpi_table_madt *madt;\r\nmadt = get_madt_table();\r\nif (!madt)\r\nreturn phys_id;\r\nentry = (unsigned long)madt;\r\nmadt_end = entry + madt->header.length;\r\nentry += sizeof(struct acpi_table_madt);\r\nwhile (entry + sizeof(struct acpi_subtable_header) < madt_end) {\r\nstruct acpi_subtable_header *header =\r\n(struct acpi_subtable_header *)entry;\r\nif (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {\r\nif (!map_lapic_id(header, acpi_id, &phys_id))\r\nbreak;\r\n} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {\r\nif (!map_x2apic_id(header, type, acpi_id, &phys_id))\r\nbreak;\r\n} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {\r\nif (!map_lsapic_id(header, type, acpi_id, &phys_id))\r\nbreak;\r\n} else if (header->type == ACPI_MADT_TYPE_GENERIC_INTERRUPT) {\r\nif (!map_gicc_mpidr(header, type, acpi_id, &phys_id))\r\nbreak;\r\n}\r\nentry += header->length;\r\n}\r\nreturn phys_id;\r\n}\r\nstatic phys_cpuid_t map_mat_entry(acpi_handle handle, int type, u32 acpi_id)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nstruct acpi_subtable_header *header;\r\nphys_cpuid_t phys_id = PHYS_CPUID_INVALID;\r\nif (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))\r\ngoto exit;\r\nif (!buffer.length || !buffer.pointer)\r\ngoto exit;\r\nobj = buffer.pointer;\r\nif (obj->type != ACPI_TYPE_BUFFER ||\r\nobj->buffer.length < sizeof(struct acpi_subtable_header)) {\r\ngoto exit;\r\n}\r\nheader = (struct acpi_subtable_header *)obj->buffer.pointer;\r\nif (header->type == ACPI_MADT_TYPE_LOCAL_APIC)\r\nmap_lapic_id(header, acpi_id, &phys_id);\r\nelse if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC)\r\nmap_lsapic_id(header, type, acpi_id, &phys_id);\r\nelse if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC)\r\nmap_x2apic_id(header, type, acpi_id, &phys_id);\r\nelse if (header->type == ACPI_MADT_TYPE_GENERIC_INTERRUPT)\r\nmap_gicc_mpidr(header, type, acpi_id, &phys_id);\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn phys_id;\r\n}\r\nphys_cpuid_t acpi_get_phys_id(acpi_handle handle, int type, u32 acpi_id)\r\n{\r\nphys_cpuid_t phys_id;\r\nphys_id = map_mat_entry(handle, type, acpi_id);\r\nif (invalid_phys_cpuid(phys_id))\r\nphys_id = map_madt_entry(type, acpi_id);\r\nreturn phys_id;\r\n}\r\nint acpi_map_cpuid(phys_cpuid_t phys_id, u32 acpi_id)\r\n{\r\n#ifdef CONFIG_SMP\r\nint i;\r\n#endif\r\nif (invalid_phys_cpuid(phys_id)) {\r\nif (nr_cpu_ids <= 1 && acpi_id == 0)\r\nreturn acpi_id;\r\nelse\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_SMP\r\nfor_each_possible_cpu(i) {\r\nif (cpu_physical_id(i) == phys_id)\r\nreturn i;\r\n}\r\n#else\r\nif (phys_id == 0)\r\nreturn phys_id;\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nint acpi_get_cpuid(acpi_handle handle, int type, u32 acpi_id)\r\n{\r\nphys_cpuid_t phys_id;\r\nphys_id = acpi_get_phys_id(handle, type, acpi_id);\r\nreturn acpi_map_cpuid(phys_id, acpi_id);\r\n}\r\nstatic int get_ioapic_id(struct acpi_subtable_header *entry, u32 gsi_base,\r\nu64 *phys_addr, int *ioapic_id)\r\n{\r\nstruct acpi_madt_io_apic *ioapic = (struct acpi_madt_io_apic *)entry;\r\nif (ioapic->global_irq_base != gsi_base)\r\nreturn 0;\r\n*phys_addr = ioapic->address;\r\n*ioapic_id = ioapic->id;\r\nreturn 1;\r\n}\r\nstatic int parse_madt_ioapic_entry(u32 gsi_base, u64 *phys_addr)\r\n{\r\nstruct acpi_subtable_header *hdr;\r\nunsigned long madt_end, entry;\r\nstruct acpi_table_madt *madt;\r\nint apic_id = -1;\r\nmadt = get_madt_table();\r\nif (!madt)\r\nreturn apic_id;\r\nentry = (unsigned long)madt;\r\nmadt_end = entry + madt->header.length;\r\nentry += sizeof(struct acpi_table_madt);\r\nwhile (entry + sizeof(struct acpi_subtable_header) < madt_end) {\r\nhdr = (struct acpi_subtable_header *)entry;\r\nif (hdr->type == ACPI_MADT_TYPE_IO_APIC &&\r\nget_ioapic_id(hdr, gsi_base, phys_addr, &apic_id))\r\nbreak;\r\nelse\r\nentry += hdr->length;\r\n}\r\nreturn apic_id;\r\n}\r\nstatic int parse_mat_ioapic_entry(acpi_handle handle, u32 gsi_base,\r\nu64 *phys_addr)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_subtable_header *header;\r\nunion acpi_object *obj;\r\nint apic_id = -1;\r\nif (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))\r\ngoto exit;\r\nif (!buffer.length || !buffer.pointer)\r\ngoto exit;\r\nobj = buffer.pointer;\r\nif (obj->type != ACPI_TYPE_BUFFER ||\r\nobj->buffer.length < sizeof(struct acpi_subtable_header))\r\ngoto exit;\r\nheader = (struct acpi_subtable_header *)obj->buffer.pointer;\r\nif (header->type == ACPI_MADT_TYPE_IO_APIC)\r\nget_ioapic_id(header, gsi_base, phys_addr, &apic_id);\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn apic_id;\r\n}\r\nint acpi_get_ioapic_id(acpi_handle handle, u32 gsi_base, u64 *phys_addr)\r\n{\r\nint apic_id;\r\napic_id = parse_mat_ioapic_entry(handle, gsi_base, phys_addr);\r\nif (apic_id == -1)\r\napic_id = parse_madt_ioapic_entry(gsi_base, phys_addr);\r\nreturn apic_id;\r\n}
