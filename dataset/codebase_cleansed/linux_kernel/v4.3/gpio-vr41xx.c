static inline u16 giu_set(u16 offset, u16 set)\r\n{\r\nu16 data;\r\ndata = giu_read(offset);\r\ndata |= set;\r\ngiu_write(offset, data);\r\nreturn data;\r\n}\r\nstatic inline u16 giu_clear(u16 offset, u16 clear)\r\n{\r\nu16 data;\r\ndata = giu_read(offset);\r\ndata &= ~clear;\r\ngiu_write(offset, data);\r\nreturn data;\r\n}\r\nstatic void ack_giuint_low(struct irq_data *d)\r\n{\r\ngiu_write(GIUINTSTATL, 1 << GPIO_PIN_OF_IRQ(d->irq));\r\n}\r\nstatic void mask_giuint_low(struct irq_data *d)\r\n{\r\ngiu_clear(GIUINTENL, 1 << GPIO_PIN_OF_IRQ(d->irq));\r\n}\r\nstatic void mask_ack_giuint_low(struct irq_data *d)\r\n{\r\nunsigned int pin;\r\npin = GPIO_PIN_OF_IRQ(d->irq);\r\ngiu_clear(GIUINTENL, 1 << pin);\r\ngiu_write(GIUINTSTATL, 1 << pin);\r\n}\r\nstatic void unmask_giuint_low(struct irq_data *d)\r\n{\r\ngiu_set(GIUINTENL, 1 << GPIO_PIN_OF_IRQ(d->irq));\r\n}\r\nstatic unsigned int startup_giuint(struct irq_data *data)\r\n{\r\nif (gpiochip_lock_as_irq(&vr41xx_gpio_chip, data->hwirq))\r\ndev_err(vr41xx_gpio_chip.dev,\r\n"unable to lock HW IRQ %lu for IRQ\n",\r\ndata->hwirq);\r\nunmask_giuint_low(data);\r\nreturn 0;\r\n}\r\nstatic void shutdown_giuint(struct irq_data *data)\r\n{\r\nmask_giuint_low(data);\r\ngpiochip_unlock_as_irq(&vr41xx_gpio_chip, data->hwirq);\r\n}\r\nstatic void ack_giuint_high(struct irq_data *d)\r\n{\r\ngiu_write(GIUINTSTATH,\r\n1 << (GPIO_PIN_OF_IRQ(d->irq) - GIUINT_HIGH_OFFSET));\r\n}\r\nstatic void mask_giuint_high(struct irq_data *d)\r\n{\r\ngiu_clear(GIUINTENH, 1 << (GPIO_PIN_OF_IRQ(d->irq) - GIUINT_HIGH_OFFSET));\r\n}\r\nstatic void mask_ack_giuint_high(struct irq_data *d)\r\n{\r\nunsigned int pin;\r\npin = GPIO_PIN_OF_IRQ(d->irq) - GIUINT_HIGH_OFFSET;\r\ngiu_clear(GIUINTENH, 1 << pin);\r\ngiu_write(GIUINTSTATH, 1 << pin);\r\n}\r\nstatic void unmask_giuint_high(struct irq_data *d)\r\n{\r\ngiu_set(GIUINTENH, 1 << (GPIO_PIN_OF_IRQ(d->irq) - GIUINT_HIGH_OFFSET));\r\n}\r\nstatic int giu_get_irq(unsigned int irq)\r\n{\r\nu16 pendl, pendh, maskl, maskh;\r\nint i;\r\npendl = giu_read(GIUINTSTATL);\r\npendh = giu_read(GIUINTSTATH);\r\nmaskl = giu_read(GIUINTENL);\r\nmaskh = giu_read(GIUINTENH);\r\nmaskl &= pendl;\r\nmaskh &= pendh;\r\nif (maskl) {\r\nfor (i = 0; i < 16; i++) {\r\nif (maskl & (1 << i))\r\nreturn GIU_IRQ(i);\r\n}\r\n} else if (maskh) {\r\nfor (i = 0; i < 16; i++) {\r\nif (maskh & (1 << i))\r\nreturn GIU_IRQ(i + GIUINT_HIGH_OFFSET);\r\n}\r\n}\r\nprintk(KERN_ERR "spurious GIU interrupt: %04x(%04x),%04x(%04x)\n",\r\nmaskl, pendl, maskh, pendh);\r\natomic_inc(&irq_err_count);\r\nreturn -EINVAL;\r\n}\r\nvoid vr41xx_set_irq_trigger(unsigned int pin, irq_trigger_t trigger,\r\nirq_signal_t signal)\r\n{\r\nu16 mask;\r\nif (pin < GIUINT_HIGH_OFFSET) {\r\nmask = 1 << pin;\r\nif (trigger != IRQ_TRIGGER_LEVEL) {\r\ngiu_set(GIUINTTYPL, mask);\r\nif (signal == IRQ_SIGNAL_HOLD)\r\ngiu_set(GIUINTHTSELL, mask);\r\nelse\r\ngiu_clear(GIUINTHTSELL, mask);\r\nif (giu_flags & GPIO_HAS_INTERRUPT_EDGE_SELECT) {\r\nswitch (trigger) {\r\ncase IRQ_TRIGGER_EDGE_FALLING:\r\ngiu_set(GIUFEDGEINHL, mask);\r\ngiu_clear(GIUREDGEINHL, mask);\r\nbreak;\r\ncase IRQ_TRIGGER_EDGE_RISING:\r\ngiu_clear(GIUFEDGEINHL, mask);\r\ngiu_set(GIUREDGEINHL, mask);\r\nbreak;\r\ndefault:\r\ngiu_set(GIUFEDGEINHL, mask);\r\ngiu_set(GIUREDGEINHL, mask);\r\nbreak;\r\n}\r\n}\r\nirq_set_chip_and_handler(GIU_IRQ(pin),\r\n&giuint_low_irq_chip,\r\nhandle_edge_irq);\r\n} else {\r\ngiu_clear(GIUINTTYPL, mask);\r\ngiu_clear(GIUINTHTSELL, mask);\r\nirq_set_chip_and_handler(GIU_IRQ(pin),\r\n&giuint_low_irq_chip,\r\nhandle_level_irq);\r\n}\r\ngiu_write(GIUINTSTATL, mask);\r\n} else if (pin < GIUINT_HIGH_MAX) {\r\nmask = 1 << (pin - GIUINT_HIGH_OFFSET);\r\nif (trigger != IRQ_TRIGGER_LEVEL) {\r\ngiu_set(GIUINTTYPH, mask);\r\nif (signal == IRQ_SIGNAL_HOLD)\r\ngiu_set(GIUINTHTSELH, mask);\r\nelse\r\ngiu_clear(GIUINTHTSELH, mask);\r\nif (giu_flags & GPIO_HAS_INTERRUPT_EDGE_SELECT) {\r\nswitch (trigger) {\r\ncase IRQ_TRIGGER_EDGE_FALLING:\r\ngiu_set(GIUFEDGEINHH, mask);\r\ngiu_clear(GIUREDGEINHH, mask);\r\nbreak;\r\ncase IRQ_TRIGGER_EDGE_RISING:\r\ngiu_clear(GIUFEDGEINHH, mask);\r\ngiu_set(GIUREDGEINHH, mask);\r\nbreak;\r\ndefault:\r\ngiu_set(GIUFEDGEINHH, mask);\r\ngiu_set(GIUREDGEINHH, mask);\r\nbreak;\r\n}\r\n}\r\nirq_set_chip_and_handler(GIU_IRQ(pin),\r\n&giuint_high_irq_chip,\r\nhandle_edge_irq);\r\n} else {\r\ngiu_clear(GIUINTTYPH, mask);\r\ngiu_clear(GIUINTHTSELH, mask);\r\nirq_set_chip_and_handler(GIU_IRQ(pin),\r\n&giuint_high_irq_chip,\r\nhandle_level_irq);\r\n}\r\ngiu_write(GIUINTSTATH, mask);\r\n}\r\n}\r\nvoid vr41xx_set_irq_level(unsigned int pin, irq_level_t level)\r\n{\r\nu16 mask;\r\nif (pin < GIUINT_HIGH_OFFSET) {\r\nmask = 1 << pin;\r\nif (level == IRQ_LEVEL_HIGH)\r\ngiu_set(GIUINTALSELL, mask);\r\nelse\r\ngiu_clear(GIUINTALSELL, mask);\r\ngiu_write(GIUINTSTATL, mask);\r\n} else if (pin < GIUINT_HIGH_MAX) {\r\nmask = 1 << (pin - GIUINT_HIGH_OFFSET);\r\nif (level == IRQ_LEVEL_HIGH)\r\ngiu_set(GIUINTALSELH, mask);\r\nelse\r\ngiu_clear(GIUINTALSELH, mask);\r\ngiu_write(GIUINTSTATH, mask);\r\n}\r\n}\r\nstatic int giu_set_direction(struct gpio_chip *chip, unsigned pin, int dir)\r\n{\r\nu16 offset, mask, reg;\r\nunsigned long flags;\r\nif (pin >= chip->ngpio)\r\nreturn -EINVAL;\r\nif (pin < 16) {\r\noffset = GIUIOSELL;\r\nmask = 1 << pin;\r\n} else if (pin < 32) {\r\noffset = GIUIOSELH;\r\nmask = 1 << (pin - 16);\r\n} else {\r\nif (giu_flags & GPIO_HAS_OUTPUT_ENABLE) {\r\noffset = GIUPODATEN;\r\nmask = 1 << (pin - 32);\r\n} else {\r\nswitch (pin) {\r\ncase 48:\r\noffset = GIUPODATH;\r\nmask = PIOEN0;\r\nbreak;\r\ncase 49:\r\noffset = GIUPODATH;\r\nmask = PIOEN1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&giu_lock, flags);\r\nreg = giu_read(offset);\r\nif (dir == GPIO_OUTPUT)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\ngiu_write(offset, reg);\r\nspin_unlock_irqrestore(&giu_lock, flags);\r\nreturn 0;\r\n}\r\nint vr41xx_gpio_pullupdown(unsigned int pin, gpio_pull_t pull)\r\n{\r\nu16 reg, mask;\r\nunsigned long flags;\r\nif ((giu_flags & GPIO_HAS_PULLUPDOWN_IO) != GPIO_HAS_PULLUPDOWN_IO)\r\nreturn -EPERM;\r\nif (pin >= 15)\r\nreturn -EINVAL;\r\nmask = 1 << pin;\r\nspin_lock_irqsave(&giu_lock, flags);\r\nif (pull == GPIO_PULL_UP || pull == GPIO_PULL_DOWN) {\r\nreg = giu_read(GIUTERMUPDN);\r\nif (pull == GPIO_PULL_UP)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\ngiu_write(GIUTERMUPDN, reg);\r\nreg = giu_read(GIUUSEUPDN);\r\nreg |= mask;\r\ngiu_write(GIUUSEUPDN, reg);\r\n} else {\r\nreg = giu_read(GIUUSEUPDN);\r\nreg &= ~mask;\r\ngiu_write(GIUUSEUPDN, reg);\r\n}\r\nspin_unlock_irqrestore(&giu_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vr41xx_gpio_get(struct gpio_chip *chip, unsigned pin)\r\n{\r\nu16 reg, mask;\r\nif (pin >= chip->ngpio)\r\nreturn -EINVAL;\r\nif (pin < 16) {\r\nreg = giu_read(GIUPIODL);\r\nmask = 1 << pin;\r\n} else if (pin < 32) {\r\nreg = giu_read(GIUPIODH);\r\nmask = 1 << (pin - 16);\r\n} else if (pin < 48) {\r\nreg = giu_read(GIUPODATL);\r\nmask = 1 << (pin - 32);\r\n} else {\r\nreg = giu_read(GIUPODATH);\r\nmask = 1 << (pin - 48);\r\n}\r\nif (reg & mask)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void vr41xx_gpio_set(struct gpio_chip *chip, unsigned pin,\r\nint value)\r\n{\r\nu16 offset, mask, reg;\r\nunsigned long flags;\r\nif (pin >= chip->ngpio)\r\nreturn;\r\nif (pin < 16) {\r\noffset = GIUPIODL;\r\nmask = 1 << pin;\r\n} else if (pin < 32) {\r\noffset = GIUPIODH;\r\nmask = 1 << (pin - 16);\r\n} else if (pin < 48) {\r\noffset = GIUPODATL;\r\nmask = 1 << (pin - 32);\r\n} else {\r\noffset = GIUPODATH;\r\nmask = 1 << (pin - 48);\r\n}\r\nspin_lock_irqsave(&giu_lock, flags);\r\nreg = giu_read(offset);\r\nif (value)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\ngiu_write(offset, reg);\r\nspin_unlock_irqrestore(&giu_lock, flags);\r\n}\r\nstatic int vr41xx_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn giu_set_direction(chip, offset, GPIO_INPUT);\r\n}\r\nstatic int vr41xx_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nvr41xx_gpio_set(chip, offset, value);\r\nreturn giu_set_direction(chip, offset, GPIO_OUTPUT);\r\n}\r\nstatic int vr41xx_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nif (offset >= chip->ngpio)\r\nreturn -EINVAL;\r\nreturn GIU_IRQ_BASE + offset;\r\n}\r\nstatic int giu_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nunsigned int trigger, i, pin;\r\nstruct irq_chip *chip;\r\nint irq, ret;\r\nswitch (pdev->id) {\r\ncase GPIO_50PINS_PULLUPDOWN:\r\ngiu_flags = GPIO_HAS_PULLUPDOWN_IO;\r\nvr41xx_gpio_chip.ngpio = 50;\r\nbreak;\r\ncase GPIO_36PINS:\r\nvr41xx_gpio_chip.ngpio = 36;\r\nbreak;\r\ncase GPIO_48PINS_EDGE_SELECT:\r\ngiu_flags = GPIO_HAS_INTERRUPT_EDGE_SELECT;\r\nvr41xx_gpio_chip.ngpio = 48;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "GIU: unknown ID %d\n", pdev->id);\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EBUSY;\r\ngiu_base = ioremap(res->start, resource_size(res));\r\nif (!giu_base)\r\nreturn -ENOMEM;\r\nvr41xx_gpio_chip.dev = &pdev->dev;\r\nret = gpiochip_add(&vr41xx_gpio_chip);\r\nif (!ret) {\r\niounmap(giu_base);\r\nreturn -ENODEV;\r\n}\r\ngiu_write(GIUINTENL, 0);\r\ngiu_write(GIUINTENH, 0);\r\ntrigger = giu_read(GIUINTTYPH) << 16;\r\ntrigger |= giu_read(GIUINTTYPL);\r\nfor (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {\r\npin = GPIO_PIN_OF_IRQ(i);\r\nif (pin < GIUINT_HIGH_OFFSET)\r\nchip = &giuint_low_irq_chip;\r\nelse\r\nchip = &giuint_high_irq_chip;\r\nif (trigger & (1 << pin))\r\nirq_set_chip_and_handler(i, chip, handle_edge_irq);\r\nelse\r\nirq_set_chip_and_handler(i, chip, handle_level_irq);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0 || irq >= nr_irqs)\r\nreturn -EBUSY;\r\nreturn cascade_irq(irq, giu_get_irq);\r\n}\r\nstatic int giu_remove(struct platform_device *pdev)\r\n{\r\nif (giu_base) {\r\niounmap(giu_base);\r\ngiu_base = NULL;\r\n}\r\nreturn 0;\r\n}
