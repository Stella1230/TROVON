static int ad7303_write(struct ad7303_state *st, unsigned int chan,\r\nuint8_t val)\r\n{\r\nst->data = cpu_to_be16(AD7303_CMD_UPDATE_DAC |\r\n(chan << AD7303_CFG_ADDR_OFFSET) |\r\nst->config | val);\r\nreturn spi_write(st->spi, &st->data, sizeof(st->data));\r\n}\r\nstatic ssize_t ad7303_read_dac_powerdown(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan, char *buf)\r\n{\r\nstruct ad7303_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", (bool)(st->config &\r\nAD7303_CFG_POWER_DOWN(chan->channel)));\r\n}\r\nstatic ssize_t ad7303_write_dac_powerdown(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan, const char *buf,\r\nsize_t len)\r\n{\r\nstruct ad7303_state *st = iio_priv(indio_dev);\r\nbool pwr_down;\r\nint ret;\r\nret = strtobool(buf, &pwr_down);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&indio_dev->mlock);\r\nif (pwr_down)\r\nst->config |= AD7303_CFG_POWER_DOWN(chan->channel);\r\nelse\r\nst->config &= ~AD7303_CFG_POWER_DOWN(chan->channel);\r\nad7303_write(st, chan->channel, st->dac_cache[chan->channel]);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn len;\r\n}\r\nstatic int ad7303_get_vref(struct ad7303_state *st,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint ret;\r\nif (st->config & AD7303_CFG_EXTERNAL_VREF)\r\nreturn regulator_get_voltage(st->vref_reg);\r\nret = regulator_get_voltage(st->vdd_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret / 2;\r\n}\r\nstatic int ad7303_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long info)\r\n{\r\nstruct ad7303_state *st = iio_priv(indio_dev);\r\nint vref_uv;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\n*val = st->dac_cache[chan->channel];\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nvref_uv = ad7303_get_vref(st, chan);\r\nif (vref_uv < 0)\r\nreturn vref_uv;\r\n*val = 2 * vref_uv / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad7303_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nstruct ad7303_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= (1 << chan->scan_type.realbits) || val < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad7303_write(st, chan->address, val);\r\nif (ret == 0)\r\nst->dac_cache[chan->channel] = val;\r\nmutex_unlock(&indio_dev->mlock);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ad7303_probe(struct spi_device *spi)\r\n{\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct iio_dev *indio_dev;\r\nstruct ad7303_state *st;\r\nbool ext_ref;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nst->vdd_reg = devm_regulator_get(&spi->dev, "Vdd");\r\nif (IS_ERR(st->vdd_reg))\r\nreturn PTR_ERR(st->vdd_reg);\r\nret = regulator_enable(st->vdd_reg);\r\nif (ret)\r\nreturn ret;\r\nif (spi->dev.of_node) {\r\next_ref = of_property_read_bool(spi->dev.of_node,\r\n"REF-supply");\r\n} else {\r\nstruct ad7303_platform_data *pdata = spi->dev.platform_data;\r\nif (pdata && pdata->use_external_ref)\r\next_ref = true;\r\nelse\r\next_ref = false;\r\n}\r\nif (ext_ref) {\r\nst->vref_reg = devm_regulator_get(&spi->dev, "REF");\r\nif (IS_ERR(st->vref_reg)) {\r\nret = PTR_ERR(st->vref_reg);\r\ngoto err_disable_vdd_reg;\r\n}\r\nret = regulator_enable(st->vref_reg);\r\nif (ret)\r\ngoto err_disable_vdd_reg;\r\nst->config |= AD7303_CFG_EXTERNAL_VREF;\r\n}\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->info = &ad7303_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = ad7303_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad7303_channels);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto err_disable_vref_reg;\r\nreturn 0;\r\nerr_disable_vref_reg:\r\nif (st->vref_reg)\r\nregulator_disable(st->vref_reg);\r\nerr_disable_vdd_reg:\r\nregulator_disable(st->vdd_reg);\r\nreturn ret;\r\n}\r\nstatic int ad7303_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad7303_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (st->vref_reg)\r\nregulator_disable(st->vref_reg);\r\nregulator_disable(st->vdd_reg);\r\nreturn 0;\r\n}
