static void meson_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int meson_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS;\r\n}\r\nstatic unsigned int meson_uart_tx_empty(struct uart_port *port)\r\n{\r\nu32 val;\r\nval = readl(port->membase + AML_UART_STATUS);\r\nreturn (val & AML_UART_TX_EMPTY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void meson_uart_stop_tx(struct uart_port *port)\r\n{\r\nu32 val;\r\nval = readl(port->membase + AML_UART_CONTROL);\r\nval &= ~AML_UART_TX_EN;\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\n}\r\nstatic void meson_uart_stop_rx(struct uart_port *port)\r\n{\r\nu32 val;\r\nval = readl(port->membase + AML_UART_CONTROL);\r\nval &= ~AML_UART_RX_EN;\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\n}\r\nstatic void meson_uart_shutdown(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nfree_irq(port->irq, port);\r\nspin_lock_irqsave(&port->lock, flags);\r\nval = readl(port->membase + AML_UART_CONTROL);\r\nval &= ~(AML_UART_RX_EN | AML_UART_TX_EN);\r\nval &= ~(AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void meson_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int ch;\r\nif (uart_tx_stopped(port)) {\r\nmeson_uart_stop_tx(port);\r\nreturn;\r\n}\r\nwhile (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)) {\r\nif (port->x_char) {\r\nwritel(port->x_char, port->membase + AML_UART_WFIFO);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\ncontinue;\r\n}\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nch = xmit->buf[xmit->tail];\r\nwritel(ch, port->membase + AML_UART_WFIFO);\r\nxmit->tail = (xmit->tail+1) & (SERIAL_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void meson_receive_chars(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nchar flag;\r\nu32 status, ch, mode;\r\ndo {\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nstatus = readl(port->membase + AML_UART_STATUS);\r\nif (status & AML_UART_ERR) {\r\nif (status & AML_UART_TX_FIFO_WERR)\r\nport->icount.overrun++;\r\nelse if (status & AML_UART_FRAME_ERR)\r\nport->icount.frame++;\r\nelse if (status & AML_UART_PARITY_ERR)\r\nport->icount.frame++;\r\nmode = readl(port->membase + AML_UART_CONTROL);\r\nmode |= AML_UART_CLEAR_ERR;\r\nwritel(mode, port->membase + AML_UART_CONTROL);\r\nmode &= ~AML_UART_CLEAR_ERR;\r\nwritel(mode, port->membase + AML_UART_CONTROL);\r\nstatus &= port->read_status_mask;\r\nif (status & AML_UART_FRAME_ERR)\r\nflag = TTY_FRAME;\r\nelse if (status & AML_UART_PARITY_ERR)\r\nflag = TTY_PARITY;\r\n}\r\nch = readl(port->membase + AML_UART_RFIFO);\r\nch &= 0xff;\r\nif ((status & port->ignore_status_mask) == 0)\r\ntty_insert_flip_char(tport, ch, flag);\r\nif (status & AML_UART_TX_FIFO_WERR)\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\n} while (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY));\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\n}\r\nstatic irqreturn_t meson_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = (struct uart_port *)dev_id;\r\nspin_lock(&port->lock);\r\nif (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY))\r\nmeson_receive_chars(port);\r\nif (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL))\r\nmeson_uart_start_tx(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const char *meson_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_MESON) ? "meson_uart" : NULL;\r\n}\r\nstatic int meson_uart_startup(struct uart_port *port)\r\n{\r\nu32 val;\r\nint ret = 0;\r\nval = readl(port->membase + AML_UART_CONTROL);\r\nval |= (AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLR_ERR);\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nval &= ~(AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLR_ERR);\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nval |= (AML_UART_RX_EN | AML_UART_TX_EN);\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nval |= (AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nval = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));\r\nwritel(val, port->membase + AML_UART_MISC);\r\nret = request_irq(port->irq, meson_uart_interrupt, 0,\r\nmeson_uart_type(port), port);\r\nreturn ret;\r\n}\r\nstatic void meson_uart_change_speed(struct uart_port *port, unsigned long baud)\r\n{\r\nu32 val;\r\nwhile (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_EMPTY))\r\ncpu_relax();\r\nval = readl(port->membase + AML_UART_REG5);\r\nval &= ~AML_UART_BAUD_MASK;\r\nval = ((port->uartclk * 10 / (baud * 4) + 5) / 10) - 1;\r\nval |= AML_UART_BAUD_USE;\r\nwritel(val, port->membase + AML_UART_REG5);\r\n}\r\nstatic void meson_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int cflags, iflags, baud;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&port->lock, flags);\r\ncflags = termios->c_cflag;\r\niflags = termios->c_iflag;\r\nval = readl(port->membase + AML_UART_CONTROL);\r\nval &= ~AML_UART_DATA_LEN_MASK;\r\nswitch (cflags & CSIZE) {\r\ncase CS8:\r\nval |= AML_UART_DATA_LEN_8BIT;\r\nbreak;\r\ncase CS7:\r\nval |= AML_UART_DATA_LEN_7BIT;\r\nbreak;\r\ncase CS6:\r\nval |= AML_UART_DATA_LEN_6BIT;\r\nbreak;\r\ncase CS5:\r\nval |= AML_UART_DATA_LEN_5BIT;\r\nbreak;\r\n}\r\nif (cflags & PARENB)\r\nval |= AML_UART_PARITY_EN;\r\nelse\r\nval &= ~AML_UART_PARITY_EN;\r\nif (cflags & PARODD)\r\nval |= AML_UART_PARITY_TYPE;\r\nelse\r\nval &= ~AML_UART_PARITY_TYPE;\r\nval &= ~AML_UART_STOP_BIN_LEN_MASK;\r\nif (cflags & CSTOPB)\r\nval |= AML_UART_STOP_BIN_2SB;\r\nelse\r\nval &= ~AML_UART_STOP_BIN_1SB;\r\nif (cflags & CRTSCTS)\r\nval &= ~AML_UART_TWO_WIRE_EN;\r\nelse\r\nval |= AML_UART_TWO_WIRE_EN;\r\nwritel(val, port->membase + AML_UART_CONTROL);\r\nbaud = uart_get_baud_rate(port, termios, old, 9600, 115200);\r\nmeson_uart_change_speed(port, baud);\r\nport->read_status_mask = AML_UART_TX_FIFO_WERR;\r\nif (iflags & INPCK)\r\nport->read_status_mask |= AML_UART_PARITY_ERR |\r\nAML_UART_FRAME_ERR;\r\nport->ignore_status_mask = 0;\r\nif (iflags & IGNPAR)\r\nport->ignore_status_mask |= AML_UART_PARITY_ERR |\r\nAML_UART_FRAME_ERR;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int meson_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (port->type != PORT_MESON)\r\nret = -EINVAL;\r\nif (port->irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void meson_uart_release_port(struct uart_port *port)\r\n{\r\nif (port->flags & UPF_IOREMAP) {\r\ndevm_iounmap(port->dev, port->membase);\r\nport->membase = NULL;\r\n}\r\n}\r\nstatic int meson_uart_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *res;\r\nint size;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot obtain I/O memory region");\r\nreturn -ENODEV;\r\n}\r\nsize = resource_size(res);\r\nif (!devm_request_mem_region(port->dev, port->mapbase, size,\r\ndev_name(port->dev))) {\r\ndev_err(port->dev, "Memory region busy\n");\r\nreturn -EBUSY;\r\n}\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = devm_ioremap_nocache(port->dev,\r\nport->mapbase,\r\nsize);\r\nif (port->membase == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void meson_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_MESON;\r\nmeson_uart_request_port(port);\r\n}\r\n}\r\nstatic void meson_console_putchar(struct uart_port *port, int ch)\r\n{\r\nif (!port->membase)\r\nreturn;\r\nwhile (readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)\r\ncpu_relax();\r\nwritel(ch, port->membase + AML_UART_WFIFO);\r\n}\r\nstatic void meson_serial_console_write(struct console *co, const char *s,\r\nu_int count)\r\n{\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nint locked;\r\nport = meson_ports[co->index];\r\nif (!port)\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (port->sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&port->lock);\r\n} else {\r\nspin_lock(&port->lock);\r\nlocked = 1;\r\n}\r\nuart_console_write(port, s, count, meson_console_putchar);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int meson_serial_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= AML_UART_PORT_NUM)\r\nreturn -EINVAL;\r\nport = meson_ports[co->index];\r\nif (!port || !port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init meson_serial_console_init(void)\r\n{\r\nregister_console(&meson_serial_console);\r\nreturn 0;\r\n}\r\nstatic int meson_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_mem, *res_irq;\r\nstruct uart_port *port;\r\nstruct clk *clk;\r\nint ret = 0;\r\nif (pdev->dev.of_node)\r\npdev->id = of_alias_get_id(pdev->dev.of_node, "serial");\r\nif (pdev->id < 0 || pdev->id >= AML_UART_PORT_NUM)\r\nreturn -EINVAL;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem)\r\nreturn -ENODEV;\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res_irq)\r\nreturn -ENODEV;\r\nif (meson_ports[pdev->id]) {\r\ndev_err(&pdev->dev, "port %d already allocated\n", pdev->id);\r\nreturn -EBUSY;\r\n}\r\nport = devm_kzalloc(&pdev->dev, sizeof(struct uart_port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nport->uartclk = clk_get_rate(clk);\r\nport->iotype = UPIO_MEM;\r\nport->mapbase = res_mem->start;\r\nport->irq = res_irq->start;\r\nport->flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_LOW_LATENCY;\r\nport->dev = &pdev->dev;\r\nport->line = pdev->id;\r\nport->type = PORT_MESON;\r\nport->x_char = 0;\r\nport->ops = &meson_uart_ops;\r\nport->fifosize = 64;\r\nmeson_ports[pdev->id] = port;\r\nplatform_set_drvdata(pdev, port);\r\nret = uart_add_one_port(&meson_uart_driver, port);\r\nif (ret)\r\nmeson_ports[pdev->id] = NULL;\r\nreturn ret;\r\n}\r\nstatic int meson_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nport = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&meson_uart_driver, port);\r\nmeson_ports[pdev->id] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init meson_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&meson_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&meson_uart_platform_driver);\r\nif (ret)\r\nuart_unregister_driver(&meson_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit meson_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&meson_uart_platform_driver);\r\nuart_unregister_driver(&meson_uart_driver);\r\n}
