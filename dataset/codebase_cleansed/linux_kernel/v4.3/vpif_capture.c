static inline struct vpif_cap_buffer *to_vpif_buffer(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct vpif_cap_buffer, vb);\r\n}\r\nstatic int vpif_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct channel_obj *ch = vb2_get_drv_priv(q);\r\nstruct common_obj *common;\r\nunsigned long addr;\r\nvpif_dbg(2, debug, "vpif_buffer_prepare\n");\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvb2_set_plane_payload(vb, 0, common->fmt.fmt.pix.sizeimage);\r\nif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\nreturn -EINVAL;\r\nvb->v4l2_buf.field = common->fmt.fmt.pix.field;\r\naddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (!IS_ALIGNED((addr + common->ytop_off), 8) ||\r\n!IS_ALIGNED((addr + common->ybtm_off), 8) ||\r\n!IS_ALIGNED((addr + common->ctop_off), 8) ||\r\n!IS_ALIGNED((addr + common->cbtm_off), 8)) {\r\nvpif_dbg(1, debug, "offset is not aligned\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_buffer_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_buffer_setup\n");\r\nif (fmt && fmt->fmt.pix.sizeimage < common->fmt.fmt.pix.sizeimage)\r\nreturn -EINVAL;\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = fmt ? fmt->fmt.pix.sizeimage : common->fmt.fmt.pix.sizeimage;\r\nalloc_ctxs[0] = common->alloc_ctx;\r\nvpif_calculate_offsets(ch);\r\nreturn 0;\r\n}\r\nstatic void vpif_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpif_cap_buffer *buf = to_vpif_buffer(vb);\r\nstruct common_obj *common;\r\nunsigned long flags;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_buffer_queue\n");\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nlist_add_tail(&buf->list, &common->dma_queue);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic int vpif_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpif_capture_config *vpif_config_data =\r\nvpif_dev->platform_data;\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpif = &ch->vpifparams;\r\nstruct vpif_cap_buffer *buf, *tmp;\r\nunsigned long addr, flags;\r\nint ret;\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nch->field_id = 0;\r\nif (vpif_config_data->setup_input_channel_mode) {\r\nret = vpif_config_data->\r\nsetup_input_channel_mode(vpif->std_info.ycmux_mode);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "can't set vpif channel mode\n");\r\ngoto err;\r\n}\r\n}\r\nret = v4l2_subdev_call(ch->sd, video, s_stream, 1);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV) {\r\nvpif_dbg(1, debug, "stream on failed in subdev\n");\r\ngoto err;\r\n}\r\nret = vpif_set_video_params(vpif, ch->channel_id);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "can't set video params\n");\r\ngoto err;\r\n}\r\nycmux_mode = ret;\r\nvpif_config_addr(ch, ret);\r\ncommon->cur_frm = common->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_cap_buffer, list);\r\nlist_del(&common->cur_frm->list);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\naddr = vb2_dma_contig_plane_dma_addr(&common->cur_frm->vb, 0);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\nchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\r\nif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\r\nchannel0_intr_assert();\r\nchannel0_intr_enable(1);\r\nenable_channel0(1);\r\n}\r\nif (VPIF_CHANNEL1_VIDEO == ch->channel_id ||\r\nycmux_mode == 2) {\r\nchannel1_intr_assert();\r\nchannel1_intr_enable(1);\r\nenable_channel1(1);\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(buf, tmp, &common->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\nreturn ret;\r\n}\r\nstatic void vpif_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common;\r\nunsigned long flags;\r\nint ret;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\r\nenable_channel0(0);\r\nchannel0_intr_enable(0);\r\n}\r\nif (VPIF_CHANNEL1_VIDEO == ch->channel_id ||\r\nycmux_mode == 2) {\r\nenable_channel1(0);\r\nchannel1_intr_enable(0);\r\n}\r\nycmux_mode = 0;\r\nret = v4l2_subdev_call(ch->sd, video, s_stream, 0);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nvpif_dbg(1, debug, "stream off failed in subdev\n");\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nif (common->cur_frm == common->next_frm) {\r\nvb2_buffer_done(&common->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\n} else {\r\nif (common->cur_frm != NULL)\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\nif (common->next_frm != NULL)\r\nvb2_buffer_done(&common->next_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&common->dma_queue)) {\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_cap_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nvb2_buffer_done(&common->next_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic void vpif_process_buffer_complete(struct common_obj *common)\r\n{\r\nv4l2_get_timestamp(&common->cur_frm->vb.v4l2_buf.timestamp);\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_DONE);\r\ncommon->cur_frm = common->next_frm;\r\n}\r\nstatic void vpif_schedule_next_buffer(struct common_obj *common)\r\n{\r\nunsigned long addr = 0;\r\nspin_lock(&common->irqlock);\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_cap_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nspin_unlock(&common->irqlock);\r\naddr = vb2_dma_contig_plane_dma_addr(&common->next_frm->vb, 0);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\n}\r\nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\r\n{\r\nstruct vpif_device *dev = &vpif_obj;\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint channel_id = 0;\r\nint fid = -1, i;\r\nchannel_id = *(int *)(dev_id);\r\nif (!vpif_intr_status(channel_id))\r\nreturn IRQ_NONE;\r\nch = dev->dev[channel_id];\r\nfor (i = 0; i < VPIF_NUMBER_OF_OBJECTS; i++) {\r\ncommon = &ch->common[i];\r\nif (1 == ch->vpifparams.std_info.frm_fmt) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue)) {\r\nspin_unlock(&common->irqlock);\r\ncontinue;\r\n}\r\nspin_unlock(&common->irqlock);\r\nif (!channel_first_int[i][channel_id])\r\nvpif_process_buffer_complete(common);\r\nchannel_first_int[i][channel_id] = 0;\r\nvpif_schedule_next_buffer(common);\r\nchannel_first_int[i][channel_id] = 0;\r\n} else {\r\nif (channel_first_int[i][channel_id]) {\r\nchannel_first_int[i][channel_id] = 0;\r\ncontinue;\r\n}\r\nif (0 == i) {\r\nch->field_id ^= 1;\r\nfid = vpif_channel_getfid(ch->channel_id);\r\nif (fid != ch->field_id) {\r\nif (0 == fid)\r\nch->field_id = fid;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (0 == fid) {\r\nif (common->cur_frm == common->next_frm)\r\ncontinue;\r\nvpif_process_buffer_complete(common);\r\n} else if (1 == fid) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue) ||\r\n(common->cur_frm != common->next_frm)) {\r\nspin_unlock(&common->irqlock);\r\ncontinue;\r\n}\r\nspin_unlock(&common->irqlock);\r\nvpif_schedule_next_buffer(common);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpif_update_std_info(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nconst struct vpif_channel_config_params *config;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nint index;\r\nvpif_dbg(2, debug, "vpif_update_std_info\n");\r\nfor (index = 0; index < vpif_ch_params_count; index++) {\r\nconfig = &vpif_ch_params[index];\r\nif (config->hd_sd == 0) {\r\nvpif_dbg(2, debug, "SD format\n");\r\nif (config->stdid & vid_ch->stdid) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n} else {\r\nvpif_dbg(2, debug, "HD format\n");\r\nif (!memcmp(&config->dv_timings, &vid_ch->dv_timings,\r\nsizeof(vid_ch->dv_timings))) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (index == vpif_ch_params_count)\r\nreturn -EINVAL;\r\ncommon->fmt.fmt.pix.width = std_info->width;\r\ncommon->width = std_info->width;\r\ncommon->fmt.fmt.pix.height = std_info->height;\r\ncommon->height = std_info->height;\r\ncommon->fmt.fmt.pix.sizeimage = common->height * common->width * 2;\r\ncommon->fmt.fmt.pix.bytesperline = std_info->width;\r\nvpifparams->video_params.hpitch = std_info->width;\r\nvpifparams->video_params.storage_mode = std_info->frm_fmt;\r\nif (vid_ch->stdid)\r\ncommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\ncommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nif (ch->vpifparams.std_info.frm_fmt)\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER)\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;\r\nelse\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\r\ncommon->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic void vpif_calculate_offsets(struct channel_obj *ch)\r\n{\r\nunsigned int hpitch, sizeimage;\r\nstruct video_obj *vid_ch = &(ch->video);\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nenum v4l2_field field = common->fmt.fmt.pix.field;\r\nvpif_dbg(2, debug, "vpif_calculate_offsets\n");\r\nif (V4L2_FIELD_ANY == field) {\r\nif (vpifparams->std_info.frm_fmt)\r\nvid_ch->buf_field = V4L2_FIELD_NONE;\r\nelse\r\nvid_ch->buf_field = V4L2_FIELD_INTERLACED;\r\n} else\r\nvid_ch->buf_field = common->fmt.fmt.pix.field;\r\nsizeimage = common->fmt.fmt.pix.sizeimage;\r\nhpitch = common->fmt.fmt.pix.bytesperline;\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = hpitch;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = sizeimage / 2 + hpitch;\r\n} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = sizeimage / 4;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = common->ctop_off + sizeimage / 4;\r\n} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\r\ncommon->ybtm_off = 0;\r\ncommon->ytop_off = sizeimage / 4;\r\ncommon->cbtm_off = sizeimage / 2;\r\ncommon->ctop_off = common->cbtm_off + sizeimage / 4;\r\n}\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field))\r\nvpifparams->video_params.storage_mode = 1;\r\nelse\r\nvpifparams->video_params.storage_mode = 0;\r\nif (1 == vpifparams->std_info.frm_fmt)\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\nelse {\r\nif ((field == V4L2_FIELD_ANY)\r\n|| (field == V4L2_FIELD_INTERLACED))\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline * 2;\r\nelse\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n}\r\nch->vpifparams.video_params.stdid = vpifparams->std_info.stdid;\r\n}\r\nstatic inline enum v4l2_field vpif_get_default_field(\r\nstruct vpif_interface *iface)\r\n{\r\nreturn (iface->if_type == VPIF_IF_RAW_BAYER) ? V4L2_FIELD_NONE :\r\nV4L2_FIELD_INTERLACED;\r\n}\r\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\r\n{\r\nstruct common_obj *common;\r\nvpif_dbg(2, debug, "vpif_config_addr\n");\r\ncommon = &(ch->common[VPIF_VIDEO_INDEX]);\r\nif (VPIF_CHANNEL1_VIDEO == ch->channel_id)\r\ncommon->set_addr = ch1_set_videobuf_addr;\r\nelse if (2 == muxmode)\r\ncommon->set_addr = ch0_set_videobuf_addr_yc_nmux;\r\nelse\r\ncommon->set_addr = ch0_set_videobuf_addr;\r\n}\r\nstatic int vpif_input_to_subdev(\r\nstruct vpif_capture_config *vpif_cfg,\r\nstruct vpif_capture_chan_config *chan_cfg,\r\nint input_index)\r\n{\r\nstruct vpif_subdev_info *subdev_info;\r\nconst char *subdev_name;\r\nint i;\r\nvpif_dbg(2, debug, "vpif_input_to_subdev\n");\r\nsubdev_name = chan_cfg->inputs[input_index].subdev_name;\r\nif (subdev_name == NULL)\r\nreturn -1;\r\nfor (i = 0; i < vpif_cfg->subdev_count; i++) {\r\nsubdev_info = &vpif_cfg->subdev_info[i];\r\nif (!strcmp(subdev_info->name, subdev_name))\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vpif_set_input(\r\nstruct vpif_capture_config *vpif_cfg,\r\nstruct channel_obj *ch,\r\nint index)\r\n{\r\nstruct vpif_capture_chan_config *chan_cfg =\r\n&vpif_cfg->chan_config[ch->channel_id];\r\nstruct vpif_subdev_info *subdev_info = NULL;\r\nstruct v4l2_subdev *sd = NULL;\r\nu32 input = 0, output = 0;\r\nint sd_index;\r\nint ret;\r\nsd_index = vpif_input_to_subdev(vpif_cfg, chan_cfg, index);\r\nif (sd_index >= 0) {\r\nsd = vpif_obj.sd[sd_index];\r\nsubdev_info = &vpif_cfg->subdev_info[sd_index];\r\n}\r\nif (sd && vpif_cfg->setup_input_path) {\r\nret = vpif_cfg->setup_input_path(ch->channel_id,\r\nsubdev_info->name);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "couldn't setup input path for the" \\r\n" sub device %s, for input index %d\n",\r\nsubdev_info->name, index);\r\nreturn ret;\r\n}\r\n}\r\nif (sd) {\r\ninput = chan_cfg->inputs[index].input_route;\r\noutput = chan_cfg->inputs[index].output_route;\r\nret = v4l2_subdev_call(sd, video, s_routing,\r\ninput, output, 0);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nvpif_dbg(1, debug, "Failed to set input\n");\r\nreturn ret;\r\n}\r\n}\r\nch->input_idx = index;\r\nch->sd = sd;\r\nch->vpifparams.iface = chan_cfg->vpif_if;\r\nch->video_dev.tvnorms = chan_cfg->inputs[index].input.std;\r\nreturn 0;\r\n}\r\nstatic int vpif_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nint ret = 0;\r\nvpif_dbg(2, debug, "vpif_querystd\n");\r\nret = v4l2_subdev_call(ch->sd, video, querystd, std_id);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nreturn -ENODATA;\r\nif (ret) {\r\nvpif_dbg(1, debug, "Failed to query standard for sub devices\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nvpif_dbg(2, debug, "vpif_g_std\n");\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_STD)\r\nreturn -ENODATA;\r\n*std = ch->video.stdid;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nint ret;\r\nvpif_dbg(2, debug, "vpif_s_std\n");\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_STD)\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nch->video.stdid = std_id;\r\nmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\r\nif (vpif_update_std_info(ch)) {\r\nvpif_err("Error getting the standard info\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_subdev_call(ch->sd, video, s_std, std_id);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV) {\r\nvpif_dbg(1, debug, "Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (input->index >= chan_cfg->input_count)\r\nreturn -EINVAL;\r\nmemcpy(input, &chan_cfg->inputs[input->index].input,\r\nsizeof(*input));\r\nreturn 0;\r\n}\r\nstatic int vpif_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\n*index = ch->input_idx;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (index >= chan_cfg->input_count)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nreturn vpif_set_input(config, ch, index);\r\n}\r\nstatic int vpif_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nif (fmt->index != 0) {\r\nvpif_dbg(1, debug, "Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER) {\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(fmt->description, "Raw Mode -Bayer Pattern GrRBGb");\r\nfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n} else {\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(fmt->description, "YCbCr4:2:2 YC Planar");\r\nfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\r\nstruct vpif_params *vpif_params = &ch->vpifparams;\r\nif (vpif_params->iface.if_type == VPIF_IF_RAW_BAYER) {\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_SBGGR8)\r\npixfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n} else {\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)\r\npixfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\n}\r\ncommon->fmt.fmt.pix.pixelformat = pixfmt->pixelformat;\r\nvpif_update_std_info(ch);\r\npixfmt->field = common->fmt.fmt.pix.field;\r\npixfmt->colorspace = common->fmt.fmt.pix.colorspace;\r\npixfmt->bytesperline = common->fmt.fmt.pix.width;\r\npixfmt->width = common->fmt.fmt.pix.width;\r\npixfmt->height = common->fmt.fmt.pix.height;\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height * 2;\r\npixfmt->priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != fmt->type)\r\nreturn -EINVAL;\r\n*fmt = common->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret;\r\nvpif_dbg(2, debug, "%s\n", __func__);\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nret = vpif_try_fmt_vid_cap(file, priv, fmt);\r\nif (ret)\r\nreturn ret;\r\ncommon->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nstrlcpy(cap->driver, VPIF_DRIVER_NAME, sizeof(cap->driver));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(vpif_dev));\r\nstrlcpy(cap->card, config->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int\r\nvpif_enum_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\ntimings->pad = 0;\r\nret = v4l2_subdev_call(ch->sd, pad, enum_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int\r\nvpif_query_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\nret = v4l2_subdev_call(ch->sd, video, query_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nreturn -ENODATA;\r\nreturn ret;\r\n}\r\nstatic int vpif_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->dv_timings.bt;\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\nif (timings->type != V4L2_DV_BT_656_1120) {\r\nvpif_dbg(2, debug, "Timing type not defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nret = v4l2_subdev_call(ch->sd, video, s_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nret = 0;\r\nif (ret < 0) {\r\nvpif_dbg(2, debug, "Error setting custom DV timings\n");\r\nreturn ret;\r\n}\r\nif (!(timings->bt.width && timings->bt.height &&\r\n(timings->bt.hbackporch ||\r\ntimings->bt.hfrontporch ||\r\ntimings->bt.hsync) &&\r\ntimings->bt.vfrontporch &&\r\n(timings->bt.vbackporch ||\r\ntimings->bt.vsync))) {\r\nvpif_dbg(2, debug, "Timings for width, height, "\r\n"horizontal back porch, horizontal sync, "\r\n"horizontal front porch, vertical back porch, "\r\n"vertical sync and vertical back porch "\r\n"must be defined\n");\r\nreturn -EINVAL;\r\n}\r\nvid_ch->dv_timings = *timings;\r\nstd_info->eav2sav = V4L2_DV_BT_BLANKING_WIDTH(bt) - 8;\r\nstd_info->sav2eav = bt->width;\r\nstd_info->l1 = 1;\r\nstd_info->l3 = bt->vsync + bt->vbackporch + 1;\r\nstd_info->vsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nif (bt->interlaced) {\r\nif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\r\nstd_info->l5 = std_info->vsize/2 -\r\n(bt->vfrontporch - 1);\r\nstd_info->l7 = std_info->vsize/2 + 1;\r\nstd_info->l9 = std_info->l7 + bt->il_vsync +\r\nbt->il_vbackporch + 1;\r\nstd_info->l11 = std_info->vsize -\r\n(bt->il_vfrontporch - 1);\r\n} else {\r\nvpif_dbg(2, debug, "Required timing values for "\r\n"interlaced BT format missing\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\r\n}\r\nstrncpy(std_info->name, "Custom timings BT656/1120", VPIF_MAX_NAME);\r\nstd_info->width = bt->width;\r\nstd_info->height = bt->height;\r\nstd_info->frm_fmt = bt->interlaced ? 0 : 1;\r\nstd_info->ycmux_mode = 0;\r\nstd_info->capture_format = 0;\r\nstd_info->vbi_supported = 0;\r\nstd_info->hd_sd = 1;\r\nstd_info->stdid = 0;\r\nvid_ch->stdid = 0;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct v4l2_input input;\r\nif (config->chan_config[ch->channel_id].inputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\ninput = chan_cfg->inputs[ch->input_idx].input;\r\nif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\n*timings = vid_ch->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int vpif_log_status(struct file *filep, void *priv)\r\n{\r\nv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int initialize_vpif(void)\r\n{\r\nint err, i, j;\r\nint free_channel_objects_index;\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nvpif_obj.dev[i] =\r\nkzalloc(sizeof(*vpif_obj.dev[i]), GFP_KERNEL);\r\nif (!vpif_obj.dev[i]) {\r\nfree_channel_objects_index = i;\r\nerr = -ENOMEM;\r\ngoto vpif_init_free_channel_objects;\r\n}\r\n}\r\nreturn 0;\r\nvpif_init_free_channel_objects:\r\nfor (j = 0; j < free_channel_objects_index; j++)\r\nkfree(vpif_obj.dev[j]);\r\nreturn err;\r\n}\r\nstatic int vpif_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nint i;\r\nfor (i = 0; i < vpif_obj.config->subdev_count; i++)\r\nif (!strcmp(vpif_obj.config->subdev_info[i].name,\r\nsubdev->name)) {\r\nvpif_obj.sd[i] = subdev;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_probe_complete(void)\r\n{\r\nstruct common_obj *common;\r\nstruct video_device *vdev;\r\nstruct channel_obj *ch;\r\nstruct vb2_queue *q;\r\nint j, err, k;\r\nfor (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\nch->channel_id = j;\r\ncommon = &(ch->common[VPIF_VIDEO_INDEX]);\r\nspin_lock_init(&common->irqlock);\r\nmutex_init(&common->lock);\r\nerr = vpif_set_input(vpif_obj.config, ch, 0);\r\nif (err)\r\ngoto probe_out;\r\nch->video.stdid = V4L2_STD_525_60;\r\nmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\r\nvpif_update_std_info(ch);\r\nq = &common->buffer_queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->drv_priv = ch;\r\nq->ops = &video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpif_cap_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 1;\r\nq->lock = &common->lock;\r\nerr = vb2_queue_init(q);\r\nif (err) {\r\nvpif_err("vpif_capture: vb2_queue_init() failed\n");\r\ngoto probe_out;\r\n}\r\ncommon->alloc_ctx = vb2_dma_contig_init_ctx(vpif_dev);\r\nif (IS_ERR(common->alloc_ctx)) {\r\nvpif_err("Failed to get the context\n");\r\nerr = PTR_ERR(common->alloc_ctx);\r\ngoto probe_out;\r\n}\r\nINIT_LIST_HEAD(&common->dma_queue);\r\nvdev = &ch->video_dev;\r\nstrlcpy(vdev->name, VPIF_DRIVER_NAME, sizeof(vdev->name));\r\nvdev->release = video_device_release_empty;\r\nvdev->fops = &vpif_fops;\r\nvdev->ioctl_ops = &vpif_ioctl_ops;\r\nvdev->v4l2_dev = &vpif_obj.v4l2_dev;\r\nvdev->vfl_dir = VFL_DIR_RX;\r\nvdev->queue = q;\r\nvdev->lock = &common->lock;\r\nvideo_set_drvdata(&ch->video_dev, ch);\r\nerr = video_register_device(vdev,\r\nVFL_TYPE_GRABBER, (j ? 1 : 0));\r\nif (err)\r\ngoto probe_out;\r\n}\r\nv4l2_info(&vpif_obj.v4l2_dev, "VPIF capture driver initialized\n");\r\nreturn 0;\r\nprobe_out:\r\nfor (k = 0; k < j; k++) {\r\nch = vpif_obj.dev[k];\r\ncommon = &ch->common[k];\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\nvideo_unregister_device(&ch->video_dev);\r\n}\r\nkfree(vpif_obj.sd);\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nreturn err;\r\n}\r\nstatic int vpif_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nreturn vpif_probe_complete();\r\n}\r\nstatic __init int vpif_probe(struct platform_device *pdev)\r\n{\r\nstruct vpif_subdev_info *subdevdata;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct resource *res;\r\nint subdev_count;\r\nint res_idx = 0;\r\nint i, err;\r\nvpif_dev = &pdev->dev;\r\nerr = initialize_vpif();\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error initializing vpif\n");\r\nreturn err;\r\n}\r\nerr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");\r\nreturn err;\r\n}\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, res_idx))) {\r\nerr = devm_request_irq(&pdev->dev, res->start, vpif_channel_isr,\r\nIRQF_SHARED, VPIF_DRIVER_NAME,\r\n(void *)(&vpif_obj.dev[res_idx]->\r\nchannel_id));\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto vpif_unregister;\r\n}\r\nres_idx++;\r\n}\r\nvpif_obj.config = pdev->dev.platform_data;\r\nsubdev_count = vpif_obj.config->subdev_count;\r\nvpif_obj.sd = kzalloc(sizeof(struct v4l2_subdev *) * subdev_count,\r\nGFP_KERNEL);\r\nif (vpif_obj.sd == NULL) {\r\nvpif_err("unable to allocate memory for subdevice pointers\n");\r\nerr = -ENOMEM;\r\ngoto vpif_unregister;\r\n}\r\nif (!vpif_obj.config->asd_sizes) {\r\ni2c_adap = i2c_get_adapter(1);\r\nfor (i = 0; i < subdev_count; i++) {\r\nsubdevdata = &vpif_obj.config->subdev_info[i];\r\nvpif_obj.sd[i] =\r\nv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\r\ni2c_adap,\r\n&subdevdata->\r\nboard_info,\r\nNULL);\r\nif (!vpif_obj.sd[i]) {\r\nvpif_err("Error registering v4l2 subdevice\n");\r\nerr = -ENODEV;\r\ngoto probe_subdev_out;\r\n}\r\nv4l2_info(&vpif_obj.v4l2_dev,\r\n"registered sub device %s\n",\r\nsubdevdata->name);\r\n}\r\nvpif_probe_complete();\r\n} else {\r\nvpif_obj.notifier.subdevs = vpif_obj.config->asd;\r\nvpif_obj.notifier.num_subdevs = vpif_obj.config->asd_sizes[0];\r\nvpif_obj.notifier.bound = vpif_async_bound;\r\nvpif_obj.notifier.complete = vpif_async_complete;\r\nerr = v4l2_async_notifier_register(&vpif_obj.v4l2_dev,\r\n&vpif_obj.notifier);\r\nif (err) {\r\nvpif_err("Error registering async notifier\n");\r\nerr = -EINVAL;\r\ngoto probe_subdev_out;\r\n}\r\n}\r\nreturn 0;\r\nprobe_subdev_out:\r\nkfree(vpif_obj.sd);\r\nvpif_unregister:\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nreturn err;\r\n}\r\nstatic int vpif_remove(struct platform_device *device)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nkfree(vpif_obj.sd);\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\nvideo_unregister_device(&ch->video_dev);\r\nkfree(vpif_obj.dev[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_suspend(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (!vb2_start_streaming_called(&common->buffer_queue))\r\ncontinue;\r\nmutex_lock(&common->lock);\r\nif (ch->channel_id == VPIF_CHANNEL0_VIDEO) {\r\nenable_channel0(0);\r\nchannel0_intr_enable(0);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL1_VIDEO ||\r\nycmux_mode == 2) {\r\nenable_channel1(0);\r\nchannel1_intr_enable(0);\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_resume(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (!vb2_start_streaming_called(&common->buffer_queue))\r\ncontinue;\r\nmutex_lock(&common->lock);\r\nif (ch->channel_id == VPIF_CHANNEL0_VIDEO) {\r\nenable_channel0(1);\r\nchannel0_intr_enable(1);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL1_VIDEO ||\r\nycmux_mode == 2) {\r\nenable_channel1(1);\r\nchannel1_intr_enable(1);\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}
