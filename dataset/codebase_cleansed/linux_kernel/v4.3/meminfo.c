static int meminfo_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct sysinfo i;\r\nunsigned long committed;\r\nstruct vmalloc_info vmi;\r\nlong cached;\r\nlong available;\r\nunsigned long pagecache;\r\nunsigned long wmark_low = 0;\r\nunsigned long pages[NR_LRU_LISTS];\r\nstruct zone *zone;\r\nint lru;\r\n#define K(x) ((x) << (PAGE_SHIFT - 10))\r\nsi_meminfo(&i);\r\nsi_swapinfo(&i);\r\ncommitted = percpu_counter_read_positive(&vm_committed_as);\r\ncached = global_page_state(NR_FILE_PAGES) -\r\ntotal_swapcache_pages() - i.bufferram;\r\nif (cached < 0)\r\ncached = 0;\r\nget_vmalloc_info(&vmi);\r\nfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\r\npages[lru] = global_page_state(NR_LRU_BASE + lru);\r\nfor_each_zone(zone)\r\nwmark_low += zone->watermark[WMARK_LOW];\r\navailable = i.freeram - wmark_low;\r\npagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\r\npagecache -= min(pagecache / 2, wmark_low);\r\navailable += pagecache;\r\navailable += global_page_state(NR_SLAB_RECLAIMABLE) -\r\nmin(global_page_state(NR_SLAB_RECLAIMABLE) / 2, wmark_low);\r\nif (available < 0)\r\navailable = 0;\r\nseq_printf(m,\r\n"MemTotal: %8lu kB\n"\r\n"MemFree: %8lu kB\n"\r\n"MemAvailable: %8lu kB\n"\r\n"Buffers: %8lu kB\n"\r\n"Cached: %8lu kB\n"\r\n"SwapCached: %8lu kB\n"\r\n"Active: %8lu kB\n"\r\n"Inactive: %8lu kB\n"\r\n"Active(anon): %8lu kB\n"\r\n"Inactive(anon): %8lu kB\n"\r\n"Active(file): %8lu kB\n"\r\n"Inactive(file): %8lu kB\n"\r\n"Unevictable: %8lu kB\n"\r\n"Mlocked: %8lu kB\n"\r\n#ifdef CONFIG_HIGHMEM\r\n"HighTotal: %8lu kB\n"\r\n"HighFree: %8lu kB\n"\r\n"LowTotal: %8lu kB\n"\r\n"LowFree: %8lu kB\n"\r\n#endif\r\n#ifndef CONFIG_MMU\r\n"MmapCopy: %8lu kB\n"\r\n#endif\r\n"SwapTotal: %8lu kB\n"\r\n"SwapFree: %8lu kB\n"\r\n"Dirty: %8lu kB\n"\r\n"Writeback: %8lu kB\n"\r\n"AnonPages: %8lu kB\n"\r\n"Mapped: %8lu kB\n"\r\n"Shmem: %8lu kB\n"\r\n"Slab: %8lu kB\n"\r\n"SReclaimable: %8lu kB\n"\r\n"SUnreclaim: %8lu kB\n"\r\n"KernelStack: %8lu kB\n"\r\n"PageTables: %8lu kB\n"\r\n#ifdef CONFIG_QUICKLIST\r\n"Quicklists: %8lu kB\n"\r\n#endif\r\n"NFS_Unstable: %8lu kB\n"\r\n"Bounce: %8lu kB\n"\r\n"WritebackTmp: %8lu kB\n"\r\n"CommitLimit: %8lu kB\n"\r\n"Committed_AS: %8lu kB\n"\r\n"VmallocTotal: %8lu kB\n"\r\n"VmallocUsed: %8lu kB\n"\r\n"VmallocChunk: %8lu kB\n"\r\n#ifdef CONFIG_MEMORY_FAILURE\r\n"HardwareCorrupted: %5lu kB\n"\r\n#endif\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\n"AnonHugePages: %8lu kB\n"\r\n#endif\r\n#ifdef CONFIG_CMA\r\n"CmaTotal: %8lu kB\n"\r\n"CmaFree: %8lu kB\n"\r\n#endif\r\n,\r\nK(i.totalram),\r\nK(i.freeram),\r\nK(available),\r\nK(i.bufferram),\r\nK(cached),\r\nK(total_swapcache_pages()),\r\nK(pages[LRU_ACTIVE_ANON] + pages[LRU_ACTIVE_FILE]),\r\nK(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),\r\nK(pages[LRU_ACTIVE_ANON]),\r\nK(pages[LRU_INACTIVE_ANON]),\r\nK(pages[LRU_ACTIVE_FILE]),\r\nK(pages[LRU_INACTIVE_FILE]),\r\nK(pages[LRU_UNEVICTABLE]),\r\nK(global_page_state(NR_MLOCK)),\r\n#ifdef CONFIG_HIGHMEM\r\nK(i.totalhigh),\r\nK(i.freehigh),\r\nK(i.totalram-i.totalhigh),\r\nK(i.freeram-i.freehigh),\r\n#endif\r\n#ifndef CONFIG_MMU\r\nK((unsigned long) atomic_long_read(&mmap_pages_allocated)),\r\n#endif\r\nK(i.totalswap),\r\nK(i.freeswap),\r\nK(global_page_state(NR_FILE_DIRTY)),\r\nK(global_page_state(NR_WRITEBACK)),\r\nK(global_page_state(NR_ANON_PAGES)),\r\nK(global_page_state(NR_FILE_MAPPED)),\r\nK(i.sharedram),\r\nK(global_page_state(NR_SLAB_RECLAIMABLE) +\r\nglobal_page_state(NR_SLAB_UNRECLAIMABLE)),\r\nK(global_page_state(NR_SLAB_RECLAIMABLE)),\r\nK(global_page_state(NR_SLAB_UNRECLAIMABLE)),\r\nglobal_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,\r\nK(global_page_state(NR_PAGETABLE)),\r\n#ifdef CONFIG_QUICKLIST\r\nK(quicklist_total_size()),\r\n#endif\r\nK(global_page_state(NR_UNSTABLE_NFS)),\r\nK(global_page_state(NR_BOUNCE)),\r\nK(global_page_state(NR_WRITEBACK_TEMP)),\r\nK(vm_commit_limit()),\r\nK(committed),\r\n(unsigned long)VMALLOC_TOTAL >> 10,\r\nvmi.used >> 10,\r\nvmi.largest_chunk >> 10\r\n#ifdef CONFIG_MEMORY_FAILURE\r\n, atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10)\r\n#endif\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\n, K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *\r\nHPAGE_PMD_NR)\r\n#endif\r\n#ifdef CONFIG_CMA\r\n, K(totalcma_pages)\r\n, K(global_page_state(NR_FREE_CMA_PAGES))\r\n#endif\r\n);\r\nhugetlb_report_meminfo(m);\r\narch_report_meminfo(m);\r\nreturn 0;\r\n#undef K\r\n}\r\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, meminfo_proc_show, NULL);\r\n}\r\nstatic int __init proc_meminfo_init(void)\r\n{\r\nproc_create("meminfo", 0, NULL, &meminfo_proc_fops);\r\nreturn 0;\r\n}
