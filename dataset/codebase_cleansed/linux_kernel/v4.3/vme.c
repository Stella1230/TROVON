static struct vme_dev *dev_to_vme_dev(struct device *dev)\r\n{\r\nreturn container_of(dev, struct vme_dev, dev);\r\n}\r\nstatic struct vme_bridge *find_bridge(struct vme_resource *resource)\r\n{\r\nswitch (resource->type) {\r\ncase VME_MASTER:\r\nreturn list_entry(resource->entry, struct vme_master_resource,\r\nlist)->parent;\r\nbreak;\r\ncase VME_SLAVE:\r\nreturn list_entry(resource->entry, struct vme_slave_resource,\r\nlist)->parent;\r\nbreak;\r\ncase VME_DMA:\r\nreturn list_entry(resource->entry, struct vme_dma_resource,\r\nlist)->parent;\r\nbreak;\r\ncase VME_LM:\r\nreturn list_entry(resource->entry, struct vme_lm_resource,\r\nlist)->parent;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown resource type\n");\r\nreturn NULL;\r\nbreak;\r\n}\r\n}\r\nvoid *vme_alloc_consistent(struct vme_resource *resource, size_t size,\r\ndma_addr_t *dma)\r\n{\r\nstruct vme_bridge *bridge;\r\nif (resource == NULL) {\r\nprintk(KERN_ERR "No resource\n");\r\nreturn NULL;\r\n}\r\nbridge = find_bridge(resource);\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find bridge\n");\r\nreturn NULL;\r\n}\r\nif (bridge->parent == NULL) {\r\nprintk(KERN_ERR "Dev entry NULL for bridge %s\n", bridge->name);\r\nreturn NULL;\r\n}\r\nif (bridge->alloc_consistent == NULL) {\r\nprintk(KERN_ERR "alloc_consistent not supported by bridge %s\n",\r\nbridge->name);\r\nreturn NULL;\r\n}\r\nreturn bridge->alloc_consistent(bridge->parent, size, dma);\r\n}\r\nvoid vme_free_consistent(struct vme_resource *resource, size_t size,\r\nvoid *vaddr, dma_addr_t dma)\r\n{\r\nstruct vme_bridge *bridge;\r\nif (resource == NULL) {\r\nprintk(KERN_ERR "No resource\n");\r\nreturn;\r\n}\r\nbridge = find_bridge(resource);\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find bridge\n");\r\nreturn;\r\n}\r\nif (bridge->parent == NULL) {\r\nprintk(KERN_ERR "Dev entry NULL for bridge %s\n", bridge->name);\r\nreturn;\r\n}\r\nif (bridge->free_consistent == NULL) {\r\nprintk(KERN_ERR "free_consistent not supported by bridge %s\n",\r\nbridge->name);\r\nreturn;\r\n}\r\nbridge->free_consistent(bridge->parent, size, vaddr, dma);\r\n}\r\nsize_t vme_get_size(struct vme_resource *resource)\r\n{\r\nint enabled, retval;\r\nunsigned long long base, size;\r\ndma_addr_t buf_base;\r\nu32 aspace, cycle, dwidth;\r\nswitch (resource->type) {\r\ncase VME_MASTER:\r\nretval = vme_master_get(resource, &enabled, &base, &size,\r\n&aspace, &cycle, &dwidth);\r\nreturn size;\r\nbreak;\r\ncase VME_SLAVE:\r\nretval = vme_slave_get(resource, &enabled, &base, &size,\r\n&buf_base, &aspace, &cycle);\r\nreturn size;\r\nbreak;\r\ncase VME_DMA:\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown resource type\n");\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nint vme_check_window(u32 aspace, unsigned long long vme_base,\r\nunsigned long long size)\r\n{\r\nint retval = 0;\r\nswitch (aspace) {\r\ncase VME_A16:\r\nif (((vme_base + size) > VME_A16_MAX) ||\r\n(vme_base > VME_A16_MAX))\r\nretval = -EFAULT;\r\nbreak;\r\ncase VME_A24:\r\nif (((vme_base + size) > VME_A24_MAX) ||\r\n(vme_base > VME_A24_MAX))\r\nretval = -EFAULT;\r\nbreak;\r\ncase VME_A32:\r\nif (((vme_base + size) > VME_A32_MAX) ||\r\n(vme_base > VME_A32_MAX))\r\nretval = -EFAULT;\r\nbreak;\r\ncase VME_A64:\r\nif ((size != 0) && (vme_base > U64_MAX + 1 - size))\r\nretval = -EFAULT;\r\nbreak;\r\ncase VME_CRCSR:\r\nif (((vme_base + size) > VME_CRCSR_MAX) ||\r\n(vme_base > VME_CRCSR_MAX))\r\nretval = -EFAULT;\r\nbreak;\r\ncase VME_USER1:\r\ncase VME_USER2:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Invalid address space\n");\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstruct vme_resource *vme_slave_request(struct vme_dev *vdev, u32 address,\r\nu32 cycle)\r\n{\r\nstruct vme_bridge *bridge;\r\nstruct list_head *slave_pos = NULL;\r\nstruct vme_slave_resource *allocated_image = NULL;\r\nstruct vme_slave_resource *slave_image = NULL;\r\nstruct vme_resource *resource = NULL;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\ngoto err_bus;\r\n}\r\nlist_for_each(slave_pos, &bridge->slave_resources) {\r\nslave_image = list_entry(slave_pos,\r\nstruct vme_slave_resource, list);\r\nif (slave_image == NULL) {\r\nprintk(KERN_ERR "Registered NULL Slave resource\n");\r\ncontinue;\r\n}\r\nmutex_lock(&slave_image->mtx);\r\nif (((slave_image->address_attr & address) == address) &&\r\n((slave_image->cycle_attr & cycle) == cycle) &&\r\n(slave_image->locked == 0)) {\r\nslave_image->locked = 1;\r\nmutex_unlock(&slave_image->mtx);\r\nallocated_image = slave_image;\r\nbreak;\r\n}\r\nmutex_unlock(&slave_image->mtx);\r\n}\r\nif (allocated_image == NULL)\r\ngoto err_image;\r\nresource = kmalloc(sizeof(struct vme_resource), GFP_KERNEL);\r\nif (resource == NULL) {\r\nprintk(KERN_WARNING "Unable to allocate resource structure\n");\r\ngoto err_alloc;\r\n}\r\nresource->type = VME_SLAVE;\r\nresource->entry = &allocated_image->list;\r\nreturn resource;\r\nerr_alloc:\r\nmutex_lock(&slave_image->mtx);\r\nslave_image->locked = 0;\r\nmutex_unlock(&slave_image->mtx);\r\nerr_image:\r\nerr_bus:\r\nreturn NULL;\r\n}\r\nint vme_slave_set(struct vme_resource *resource, int enabled,\r\nunsigned long long vme_base, unsigned long long size,\r\ndma_addr_t buf_base, u32 aspace, u32 cycle)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_slave_resource *image;\r\nint retval;\r\nif (resource->type != VME_SLAVE) {\r\nprintk(KERN_ERR "Not a slave resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_slave_resource, list);\r\nif (bridge->slave_set == NULL) {\r\nprintk(KERN_ERR "Function not supported\n");\r\nreturn -ENOSYS;\r\n}\r\nif (!(((image->address_attr & aspace) == aspace) &&\r\n((image->cycle_attr & cycle) == cycle))) {\r\nprintk(KERN_ERR "Invalid attributes\n");\r\nreturn -EINVAL;\r\n}\r\nretval = vme_check_window(aspace, vme_base, size);\r\nif (retval)\r\nreturn retval;\r\nreturn bridge->slave_set(image, enabled, vme_base, size, buf_base,\r\naspace, cycle);\r\n}\r\nint vme_slave_get(struct vme_resource *resource, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\ndma_addr_t *buf_base, u32 *aspace, u32 *cycle)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_slave_resource *image;\r\nif (resource->type != VME_SLAVE) {\r\nprintk(KERN_ERR "Not a slave resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_slave_resource, list);\r\nif (bridge->slave_get == NULL) {\r\nprintk(KERN_ERR "vme_slave_get not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->slave_get(image, enabled, vme_base, size, buf_base,\r\naspace, cycle);\r\n}\r\nvoid vme_slave_free(struct vme_resource *resource)\r\n{\r\nstruct vme_slave_resource *slave_image;\r\nif (resource->type != VME_SLAVE) {\r\nprintk(KERN_ERR "Not a slave resource\n");\r\nreturn;\r\n}\r\nslave_image = list_entry(resource->entry, struct vme_slave_resource,\r\nlist);\r\nif (slave_image == NULL) {\r\nprintk(KERN_ERR "Can't find slave resource\n");\r\nreturn;\r\n}\r\nmutex_lock(&slave_image->mtx);\r\nif (slave_image->locked == 0)\r\nprintk(KERN_ERR "Image is already free\n");\r\nslave_image->locked = 0;\r\nmutex_unlock(&slave_image->mtx);\r\nkfree(resource);\r\n}\r\nstruct vme_resource *vme_master_request(struct vme_dev *vdev, u32 address,\r\nu32 cycle, u32 dwidth)\r\n{\r\nstruct vme_bridge *bridge;\r\nstruct list_head *master_pos = NULL;\r\nstruct vme_master_resource *allocated_image = NULL;\r\nstruct vme_master_resource *master_image = NULL;\r\nstruct vme_resource *resource = NULL;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\ngoto err_bus;\r\n}\r\nlist_for_each(master_pos, &bridge->master_resources) {\r\nmaster_image = list_entry(master_pos,\r\nstruct vme_master_resource, list);\r\nif (master_image == NULL) {\r\nprintk(KERN_WARNING "Registered NULL master resource\n");\r\ncontinue;\r\n}\r\nspin_lock(&master_image->lock);\r\nif (((master_image->address_attr & address) == address) &&\r\n((master_image->cycle_attr & cycle) == cycle) &&\r\n((master_image->width_attr & dwidth) == dwidth) &&\r\n(master_image->locked == 0)) {\r\nmaster_image->locked = 1;\r\nspin_unlock(&master_image->lock);\r\nallocated_image = master_image;\r\nbreak;\r\n}\r\nspin_unlock(&master_image->lock);\r\n}\r\nif (allocated_image == NULL) {\r\nprintk(KERN_ERR "Can't find a suitable resource\n");\r\ngoto err_image;\r\n}\r\nresource = kmalloc(sizeof(struct vme_resource), GFP_KERNEL);\r\nif (resource == NULL) {\r\nprintk(KERN_ERR "Unable to allocate resource structure\n");\r\ngoto err_alloc;\r\n}\r\nresource->type = VME_MASTER;\r\nresource->entry = &allocated_image->list;\r\nreturn resource;\r\nerr_alloc:\r\nspin_lock(&master_image->lock);\r\nmaster_image->locked = 0;\r\nspin_unlock(&master_image->lock);\r\nerr_image:\r\nerr_bus:\r\nreturn NULL;\r\n}\r\nint vme_master_set(struct vme_resource *resource, int enabled,\r\nunsigned long long vme_base, unsigned long long size, u32 aspace,\r\nu32 cycle, u32 dwidth)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_master_resource *image;\r\nint retval;\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nif (bridge->master_set == NULL) {\r\nprintk(KERN_WARNING "vme_master_set not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(((image->address_attr & aspace) == aspace) &&\r\n((image->cycle_attr & cycle) == cycle) &&\r\n((image->width_attr & dwidth) == dwidth))) {\r\nprintk(KERN_WARNING "Invalid attributes\n");\r\nreturn -EINVAL;\r\n}\r\nretval = vme_check_window(aspace, vme_base, size);\r\nif (retval)\r\nreturn retval;\r\nreturn bridge->master_set(image, enabled, vme_base, size, aspace,\r\ncycle, dwidth);\r\n}\r\nint vme_master_get(struct vme_resource *resource, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\r\nu32 *cycle, u32 *dwidth)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_master_resource *image;\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nif (bridge->master_get == NULL) {\r\nprintk(KERN_WARNING "%s not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->master_get(image, enabled, vme_base, size, aspace,\r\ncycle, dwidth);\r\n}\r\nssize_t vme_master_read(struct vme_resource *resource, void *buf, size_t count,\r\nloff_t offset)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_master_resource *image;\r\nsize_t length;\r\nif (bridge->master_read == NULL) {\r\nprintk(KERN_WARNING "Reading from resource not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nlength = vme_get_size(resource);\r\nif (offset > length) {\r\nprintk(KERN_WARNING "Invalid Offset\n");\r\nreturn -EFAULT;\r\n}\r\nif ((offset + count) > length)\r\ncount = length - offset;\r\nreturn bridge->master_read(image, buf, count, offset);\r\n}\r\nssize_t vme_master_write(struct vme_resource *resource, void *buf,\r\nsize_t count, loff_t offset)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_master_resource *image;\r\nsize_t length;\r\nif (bridge->master_write == NULL) {\r\nprintk(KERN_WARNING "Writing to resource not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nlength = vme_get_size(resource);\r\nif (offset > length) {\r\nprintk(KERN_WARNING "Invalid Offset\n");\r\nreturn -EFAULT;\r\n}\r\nif ((offset + count) > length)\r\ncount = length - offset;\r\nreturn bridge->master_write(image, buf, count, offset);\r\n}\r\nunsigned int vme_master_rmw(struct vme_resource *resource, unsigned int mask,\r\nunsigned int compare, unsigned int swap, loff_t offset)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_master_resource *image;\r\nif (bridge->master_rmw == NULL) {\r\nprintk(KERN_WARNING "Writing to resource not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nreturn bridge->master_rmw(image, mask, compare, swap, offset);\r\n}\r\nint vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma)\r\n{\r\nstruct vme_master_resource *image;\r\nphys_addr_t phys_addr;\r\nunsigned long vma_size;\r\nif (resource->type != VME_MASTER) {\r\npr_err("Not a master resource\n");\r\nreturn -EINVAL;\r\n}\r\nimage = list_entry(resource->entry, struct vme_master_resource, list);\r\nphys_addr = image->bus_resource.start + (vma->vm_pgoff << PAGE_SHIFT);\r\nvma_size = vma->vm_end - vma->vm_start;\r\nif (phys_addr + vma_size > image->bus_resource.end + 1) {\r\npr_err("Map size cannot exceed the window size\n");\r\nreturn -EFAULT;\r\n}\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn vm_iomap_memory(vma, phys_addr, vma->vm_end - vma->vm_start);\r\n}\r\nvoid vme_master_free(struct vme_resource *resource)\r\n{\r\nstruct vme_master_resource *master_image;\r\nif (resource->type != VME_MASTER) {\r\nprintk(KERN_ERR "Not a master resource\n");\r\nreturn;\r\n}\r\nmaster_image = list_entry(resource->entry, struct vme_master_resource,\r\nlist);\r\nif (master_image == NULL) {\r\nprintk(KERN_ERR "Can't find master resource\n");\r\nreturn;\r\n}\r\nspin_lock(&master_image->lock);\r\nif (master_image->locked == 0)\r\nprintk(KERN_ERR "Image is already free\n");\r\nmaster_image->locked = 0;\r\nspin_unlock(&master_image->lock);\r\nkfree(resource);\r\n}\r\nstruct vme_resource *vme_dma_request(struct vme_dev *vdev, u32 route)\r\n{\r\nstruct vme_bridge *bridge;\r\nstruct list_head *dma_pos = NULL;\r\nstruct vme_dma_resource *allocated_ctrlr = NULL;\r\nstruct vme_dma_resource *dma_ctrlr = NULL;\r\nstruct vme_resource *resource = NULL;\r\nprintk(KERN_ERR "No VME resource Attribute tests done\n");\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\ngoto err_bus;\r\n}\r\nlist_for_each(dma_pos, &bridge->dma_resources) {\r\ndma_ctrlr = list_entry(dma_pos,\r\nstruct vme_dma_resource, list);\r\nif (dma_ctrlr == NULL) {\r\nprintk(KERN_ERR "Registered NULL DMA resource\n");\r\ncontinue;\r\n}\r\nmutex_lock(&dma_ctrlr->mtx);\r\nif (((dma_ctrlr->route_attr & route) == route) &&\r\n(dma_ctrlr->locked == 0)) {\r\ndma_ctrlr->locked = 1;\r\nmutex_unlock(&dma_ctrlr->mtx);\r\nallocated_ctrlr = dma_ctrlr;\r\nbreak;\r\n}\r\nmutex_unlock(&dma_ctrlr->mtx);\r\n}\r\nif (allocated_ctrlr == NULL)\r\ngoto err_ctrlr;\r\nresource = kmalloc(sizeof(struct vme_resource), GFP_KERNEL);\r\nif (resource == NULL) {\r\nprintk(KERN_WARNING "Unable to allocate resource structure\n");\r\ngoto err_alloc;\r\n}\r\nresource->type = VME_DMA;\r\nresource->entry = &allocated_ctrlr->list;\r\nreturn resource;\r\nerr_alloc:\r\nmutex_lock(&dma_ctrlr->mtx);\r\ndma_ctrlr->locked = 0;\r\nmutex_unlock(&dma_ctrlr->mtx);\r\nerr_ctrlr:\r\nerr_bus:\r\nreturn NULL;\r\n}\r\nstruct vme_dma_list *vme_new_dma_list(struct vme_resource *resource)\r\n{\r\nstruct vme_dma_resource *ctrlr;\r\nstruct vme_dma_list *dma_list;\r\nif (resource->type != VME_DMA) {\r\nprintk(KERN_ERR "Not a DMA resource\n");\r\nreturn NULL;\r\n}\r\nctrlr = list_entry(resource->entry, struct vme_dma_resource, list);\r\ndma_list = kmalloc(sizeof(struct vme_dma_list), GFP_KERNEL);\r\nif (dma_list == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for new dma list\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&dma_list->entries);\r\ndma_list->parent = ctrlr;\r\nmutex_init(&dma_list->mtx);\r\nreturn dma_list;\r\n}\r\nstruct vme_dma_attr *vme_dma_pattern_attribute(u32 pattern, u32 type)\r\n{\r\nstruct vme_dma_attr *attributes;\r\nstruct vme_dma_pattern *pattern_attr;\r\nattributes = kmalloc(sizeof(struct vme_dma_attr), GFP_KERNEL);\r\nif (attributes == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for attributes structure\n");\r\ngoto err_attr;\r\n}\r\npattern_attr = kmalloc(sizeof(struct vme_dma_pattern), GFP_KERNEL);\r\nif (pattern_attr == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for pattern attributes\n");\r\ngoto err_pat;\r\n}\r\nattributes->type = VME_DMA_PATTERN;\r\nattributes->private = (void *)pattern_attr;\r\npattern_attr->pattern = pattern;\r\npattern_attr->type = type;\r\nreturn attributes;\r\nerr_pat:\r\nkfree(attributes);\r\nerr_attr:\r\nreturn NULL;\r\n}\r\nstruct vme_dma_attr *vme_dma_pci_attribute(dma_addr_t address)\r\n{\r\nstruct vme_dma_attr *attributes;\r\nstruct vme_dma_pci *pci_attr;\r\nattributes = kmalloc(sizeof(struct vme_dma_attr), GFP_KERNEL);\r\nif (attributes == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for attributes structure\n");\r\ngoto err_attr;\r\n}\r\npci_attr = kmalloc(sizeof(struct vme_dma_pci), GFP_KERNEL);\r\nif (pci_attr == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for pci attributes\n");\r\ngoto err_pci;\r\n}\r\nattributes->type = VME_DMA_PCI;\r\nattributes->private = (void *)pci_attr;\r\npci_attr->address = address;\r\nreturn attributes;\r\nerr_pci:\r\nkfree(attributes);\r\nerr_attr:\r\nreturn NULL;\r\n}\r\nstruct vme_dma_attr *vme_dma_vme_attribute(unsigned long long address,\r\nu32 aspace, u32 cycle, u32 dwidth)\r\n{\r\nstruct vme_dma_attr *attributes;\r\nstruct vme_dma_vme *vme_attr;\r\nattributes = kmalloc(\r\nsizeof(struct vme_dma_attr), GFP_KERNEL);\r\nif (attributes == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for attributes structure\n");\r\ngoto err_attr;\r\n}\r\nvme_attr = kmalloc(sizeof(struct vme_dma_vme), GFP_KERNEL);\r\nif (vme_attr == NULL) {\r\nprintk(KERN_ERR "Unable to allocate memory for vme attributes\n");\r\ngoto err_vme;\r\n}\r\nattributes->type = VME_DMA_VME;\r\nattributes->private = (void *)vme_attr;\r\nvme_attr->address = address;\r\nvme_attr->aspace = aspace;\r\nvme_attr->cycle = cycle;\r\nvme_attr->dwidth = dwidth;\r\nreturn attributes;\r\nerr_vme:\r\nkfree(attributes);\r\nerr_attr:\r\nreturn NULL;\r\n}\r\nvoid vme_dma_free_attribute(struct vme_dma_attr *attributes)\r\n{\r\nkfree(attributes->private);\r\nkfree(attributes);\r\n}\r\nint vme_dma_list_add(struct vme_dma_list *list, struct vme_dma_attr *src,\r\nstruct vme_dma_attr *dest, size_t count)\r\n{\r\nstruct vme_bridge *bridge = list->parent->parent;\r\nint retval;\r\nif (bridge->dma_list_add == NULL) {\r\nprintk(KERN_WARNING "Link List DMA generation not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!mutex_trylock(&list->mtx)) {\r\nprintk(KERN_ERR "Link List already submitted\n");\r\nreturn -EINVAL;\r\n}\r\nretval = bridge->dma_list_add(list, src, dest, count);\r\nmutex_unlock(&list->mtx);\r\nreturn retval;\r\n}\r\nint vme_dma_list_exec(struct vme_dma_list *list)\r\n{\r\nstruct vme_bridge *bridge = list->parent->parent;\r\nint retval;\r\nif (bridge->dma_list_exec == NULL) {\r\nprintk(KERN_ERR "Link List DMA execution not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&list->mtx);\r\nretval = bridge->dma_list_exec(list);\r\nmutex_unlock(&list->mtx);\r\nreturn retval;\r\n}\r\nint vme_dma_list_free(struct vme_dma_list *list)\r\n{\r\nstruct vme_bridge *bridge = list->parent->parent;\r\nint retval;\r\nif (bridge->dma_list_empty == NULL) {\r\nprintk(KERN_WARNING "Emptying of Link Lists not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!mutex_trylock(&list->mtx)) {\r\nprintk(KERN_ERR "Link List in use\n");\r\nreturn -EINVAL;\r\n}\r\nretval = bridge->dma_list_empty(list);\r\nif (retval) {\r\nprintk(KERN_ERR "Unable to empty link-list entries\n");\r\nmutex_unlock(&list->mtx);\r\nreturn retval;\r\n}\r\nmutex_unlock(&list->mtx);\r\nkfree(list);\r\nreturn retval;\r\n}\r\nint vme_dma_free(struct vme_resource *resource)\r\n{\r\nstruct vme_dma_resource *ctrlr;\r\nif (resource->type != VME_DMA) {\r\nprintk(KERN_ERR "Not a DMA resource\n");\r\nreturn -EINVAL;\r\n}\r\nctrlr = list_entry(resource->entry, struct vme_dma_resource, list);\r\nif (!mutex_trylock(&ctrlr->mtx)) {\r\nprintk(KERN_ERR "Resource busy, can't free\n");\r\nreturn -EBUSY;\r\n}\r\nif (!(list_empty(&ctrlr->pending) && list_empty(&ctrlr->running))) {\r\nprintk(KERN_WARNING "Resource still processing transfers\n");\r\nmutex_unlock(&ctrlr->mtx);\r\nreturn -EBUSY;\r\n}\r\nctrlr->locked = 0;\r\nmutex_unlock(&ctrlr->mtx);\r\nkfree(resource);\r\nreturn 0;\r\n}\r\nvoid vme_irq_handler(struct vme_bridge *bridge, int level, int statid)\r\n{\r\nvoid (*call)(int, int, void *);\r\nvoid *priv_data;\r\ncall = bridge->irq[level - 1].callback[statid].func;\r\npriv_data = bridge->irq[level - 1].callback[statid].priv_data;\r\nif (call != NULL)\r\ncall(level, statid, priv_data);\r\nelse\r\nprintk(KERN_WARNING "Spurilous VME interrupt, level:%x, vector:%x\n",\r\nlevel, statid);\r\n}\r\nint vme_irq_request(struct vme_dev *vdev, int level, int statid,\r\nvoid (*callback)(int, int, void *),\r\nvoid *priv_data)\r\n{\r\nstruct vme_bridge *bridge;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\nreturn -EINVAL;\r\n}\r\nif ((level < 1) || (level > 7)) {\r\nprintk(KERN_ERR "Invalid interrupt level\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->irq_set == NULL) {\r\nprintk(KERN_ERR "Configuring interrupts not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&bridge->irq_mtx);\r\nif (bridge->irq[level - 1].callback[statid].func) {\r\nmutex_unlock(&bridge->irq_mtx);\r\nprintk(KERN_WARNING "VME Interrupt already taken\n");\r\nreturn -EBUSY;\r\n}\r\nbridge->irq[level - 1].count++;\r\nbridge->irq[level - 1].callback[statid].priv_data = priv_data;\r\nbridge->irq[level - 1].callback[statid].func = callback;\r\nbridge->irq_set(bridge, level, 1, 1);\r\nmutex_unlock(&bridge->irq_mtx);\r\nreturn 0;\r\n}\r\nvoid vme_irq_free(struct vme_dev *vdev, int level, int statid)\r\n{\r\nstruct vme_bridge *bridge;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\nreturn;\r\n}\r\nif ((level < 1) || (level > 7)) {\r\nprintk(KERN_ERR "Invalid interrupt level\n");\r\nreturn;\r\n}\r\nif (bridge->irq_set == NULL) {\r\nprintk(KERN_ERR "Configuring interrupts not supported\n");\r\nreturn;\r\n}\r\nmutex_lock(&bridge->irq_mtx);\r\nbridge->irq[level - 1].count--;\r\nif (bridge->irq[level - 1].count == 0)\r\nbridge->irq_set(bridge, level, 0, 1);\r\nbridge->irq[level - 1].callback[statid].func = NULL;\r\nbridge->irq[level - 1].callback[statid].priv_data = NULL;\r\nmutex_unlock(&bridge->irq_mtx);\r\n}\r\nint vme_irq_generate(struct vme_dev *vdev, int level, int statid)\r\n{\r\nstruct vme_bridge *bridge;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\nreturn -EINVAL;\r\n}\r\nif ((level < 1) || (level > 7)) {\r\nprintk(KERN_WARNING "Invalid interrupt level\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->irq_generate == NULL) {\r\nprintk(KERN_WARNING "Interrupt generation not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->irq_generate(bridge, level, statid);\r\n}\r\nstruct vme_resource *vme_lm_request(struct vme_dev *vdev)\r\n{\r\nstruct vme_bridge *bridge;\r\nstruct list_head *lm_pos = NULL;\r\nstruct vme_lm_resource *allocated_lm = NULL;\r\nstruct vme_lm_resource *lm = NULL;\r\nstruct vme_resource *resource = NULL;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\ngoto err_bus;\r\n}\r\nlist_for_each(lm_pos, &bridge->lm_resources) {\r\nlm = list_entry(lm_pos,\r\nstruct vme_lm_resource, list);\r\nif (lm == NULL) {\r\nprintk(KERN_ERR "Registered NULL Location Monitor resource\n");\r\ncontinue;\r\n}\r\nmutex_lock(&lm->mtx);\r\nif (lm->locked == 0) {\r\nlm->locked = 1;\r\nmutex_unlock(&lm->mtx);\r\nallocated_lm = lm;\r\nbreak;\r\n}\r\nmutex_unlock(&lm->mtx);\r\n}\r\nif (allocated_lm == NULL)\r\ngoto err_lm;\r\nresource = kmalloc(sizeof(struct vme_resource), GFP_KERNEL);\r\nif (resource == NULL) {\r\nprintk(KERN_ERR "Unable to allocate resource structure\n");\r\ngoto err_alloc;\r\n}\r\nresource->type = VME_LM;\r\nresource->entry = &allocated_lm->list;\r\nreturn resource;\r\nerr_alloc:\r\nmutex_lock(&lm->mtx);\r\nlm->locked = 0;\r\nmutex_unlock(&lm->mtx);\r\nerr_lm:\r\nerr_bus:\r\nreturn NULL;\r\n}\r\nint vme_lm_count(struct vme_resource *resource)\r\n{\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn -EINVAL;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nreturn lm->monitors;\r\n}\r\nint vme_lm_set(struct vme_resource *resource, unsigned long long lm_base,\r\nu32 aspace, u32 cycle)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn -EINVAL;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nif (bridge->lm_set == NULL) {\r\nprintk(KERN_ERR "vme_lm_set not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->lm_set(lm, lm_base, aspace, cycle);\r\n}\r\nint vme_lm_get(struct vme_resource *resource, unsigned long long *lm_base,\r\nu32 *aspace, u32 *cycle)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn -EINVAL;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nif (bridge->lm_get == NULL) {\r\nprintk(KERN_ERR "vme_lm_get not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->lm_get(lm, lm_base, aspace, cycle);\r\n}\r\nint vme_lm_attach(struct vme_resource *resource, int monitor,\r\nvoid (*callback)(int))\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn -EINVAL;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nif (bridge->lm_attach == NULL) {\r\nprintk(KERN_ERR "vme_lm_attach not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->lm_attach(lm, monitor, callback);\r\n}\r\nint vme_lm_detach(struct vme_resource *resource, int monitor)\r\n{\r\nstruct vme_bridge *bridge = find_bridge(resource);\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn -EINVAL;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nif (bridge->lm_detach == NULL) {\r\nprintk(KERN_ERR "vme_lm_detach not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->lm_detach(lm, monitor);\r\n}\r\nvoid vme_lm_free(struct vme_resource *resource)\r\n{\r\nstruct vme_lm_resource *lm;\r\nif (resource->type != VME_LM) {\r\nprintk(KERN_ERR "Not a Location Monitor resource\n");\r\nreturn;\r\n}\r\nlm = list_entry(resource->entry, struct vme_lm_resource, list);\r\nmutex_lock(&lm->mtx);\r\nlm->locked = 0;\r\nmutex_unlock(&lm->mtx);\r\nkfree(resource);\r\n}\r\nint vme_slot_num(struct vme_dev *vdev)\r\n{\r\nstruct vme_bridge *bridge;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\nprintk(KERN_ERR "Can't find VME bus\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->slot_get == NULL) {\r\nprintk(KERN_WARNING "vme_slot_num not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->slot_get(bridge);\r\n}\r\nint vme_bus_num(struct vme_dev *vdev)\r\n{\r\nstruct vme_bridge *bridge;\r\nbridge = vdev->bridge;\r\nif (bridge == NULL) {\r\npr_err("Can't find VME bus\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bridge->num;\r\n}\r\nstatic void vme_dev_release(struct device *dev)\r\n{\r\nkfree(dev_to_vme_dev(dev));\r\n}\r\nint vme_register_bridge(struct vme_bridge *bridge)\r\n{\r\nint i;\r\nint ret = -1;\r\nmutex_lock(&vme_buses_lock);\r\nfor (i = 0; i < sizeof(vme_bus_numbers) * 8; i++) {\r\nif ((vme_bus_numbers & (1 << i)) == 0) {\r\nvme_bus_numbers |= (1 << i);\r\nbridge->num = i;\r\nINIT_LIST_HEAD(&bridge->devices);\r\nlist_add_tail(&bridge->bus_list, &vme_bus_list);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vme_buses_lock);\r\nreturn ret;\r\n}\r\nvoid vme_unregister_bridge(struct vme_bridge *bridge)\r\n{\r\nstruct vme_dev *vdev;\r\nstruct vme_dev *tmp;\r\nmutex_lock(&vme_buses_lock);\r\nvme_bus_numbers &= ~(1 << bridge->num);\r\nlist_for_each_entry_safe(vdev, tmp, &bridge->devices, bridge_list) {\r\nlist_del(&vdev->drv_list);\r\nlist_del(&vdev->bridge_list);\r\ndevice_unregister(&vdev->dev);\r\n}\r\nlist_del(&bridge->bus_list);\r\nmutex_unlock(&vme_buses_lock);\r\n}\r\nstatic int __vme_register_driver_bus(struct vme_driver *drv,\r\nstruct vme_bridge *bridge, unsigned int ndevs)\r\n{\r\nint err;\r\nunsigned int i;\r\nstruct vme_dev *vdev;\r\nstruct vme_dev *tmp;\r\nfor (i = 0; i < ndevs; i++) {\r\nvdev = kzalloc(sizeof(struct vme_dev), GFP_KERNEL);\r\nif (!vdev) {\r\nerr = -ENOMEM;\r\ngoto err_devalloc;\r\n}\r\nvdev->num = i;\r\nvdev->bridge = bridge;\r\nvdev->dev.platform_data = drv;\r\nvdev->dev.release = vme_dev_release;\r\nvdev->dev.parent = bridge->parent;\r\nvdev->dev.bus = &vme_bus_type;\r\ndev_set_name(&vdev->dev, "%s.%u-%u", drv->name, bridge->num,\r\nvdev->num);\r\nerr = device_register(&vdev->dev);\r\nif (err)\r\ngoto err_reg;\r\nif (vdev->dev.platform_data) {\r\nlist_add_tail(&vdev->drv_list, &drv->devices);\r\nlist_add_tail(&vdev->bridge_list, &bridge->devices);\r\n} else\r\ndevice_unregister(&vdev->dev);\r\n}\r\nreturn 0;\r\nerr_reg:\r\nput_device(&vdev->dev);\r\nkfree(vdev);\r\nerr_devalloc:\r\nlist_for_each_entry_safe(vdev, tmp, &drv->devices, drv_list) {\r\nlist_del(&vdev->drv_list);\r\nlist_del(&vdev->bridge_list);\r\ndevice_unregister(&vdev->dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int __vme_register_driver(struct vme_driver *drv, unsigned int ndevs)\r\n{\r\nstruct vme_bridge *bridge;\r\nint err = 0;\r\nmutex_lock(&vme_buses_lock);\r\nlist_for_each_entry(bridge, &vme_bus_list, bus_list) {\r\nerr = __vme_register_driver_bus(drv, bridge, ndevs);\r\nif (err)\r\nbreak;\r\n}\r\nmutex_unlock(&vme_buses_lock);\r\nreturn err;\r\n}\r\nint vme_register_driver(struct vme_driver *drv, unsigned int ndevs)\r\n{\r\nint err;\r\ndrv->driver.name = drv->name;\r\ndrv->driver.bus = &vme_bus_type;\r\nINIT_LIST_HEAD(&drv->devices);\r\nerr = driver_register(&drv->driver);\r\nif (err)\r\nreturn err;\r\nerr = __vme_register_driver(drv, ndevs);\r\nif (err)\r\ndriver_unregister(&drv->driver);\r\nreturn err;\r\n}\r\nvoid vme_unregister_driver(struct vme_driver *drv)\r\n{\r\nstruct vme_dev *dev, *dev_tmp;\r\nmutex_lock(&vme_buses_lock);\r\nlist_for_each_entry_safe(dev, dev_tmp, &drv->devices, drv_list) {\r\nlist_del(&dev->drv_list);\r\nlist_del(&dev->bridge_list);\r\ndevice_unregister(&dev->dev);\r\n}\r\nmutex_unlock(&vme_buses_lock);\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int vme_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct vme_driver *vme_drv;\r\nvme_drv = container_of(drv, struct vme_driver, driver);\r\nif (dev->platform_data == vme_drv) {\r\nstruct vme_dev *vdev = dev_to_vme_dev(dev);\r\nif (vme_drv->match && vme_drv->match(vdev))\r\nreturn 1;\r\ndev->platform_data = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vme_bus_probe(struct device *dev)\r\n{\r\nint retval = -ENODEV;\r\nstruct vme_driver *driver;\r\nstruct vme_dev *vdev = dev_to_vme_dev(dev);\r\ndriver = dev->platform_data;\r\nif (driver->probe != NULL)\r\nretval = driver->probe(vdev);\r\nreturn retval;\r\n}\r\nstatic int vme_bus_remove(struct device *dev)\r\n{\r\nint retval = -ENODEV;\r\nstruct vme_driver *driver;\r\nstruct vme_dev *vdev = dev_to_vme_dev(dev);\r\ndriver = dev->platform_data;\r\nif (driver->remove != NULL)\r\nretval = driver->remove(vdev);\r\nreturn retval;\r\n}\r\nstatic int __init vme_init(void)\r\n{\r\nreturn bus_register(&vme_bus_type);\r\n}\r\nstatic void __exit vme_exit(void)\r\n{\r\nbus_unregister(&vme_bus_type);\r\n}
