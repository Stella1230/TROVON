int pmu_probe(void)\r\n{\r\nif (macintosh_config->adb_type == MAC_ADB_PB1) {\r\npmu_kind = PMU_68K_V1;\r\n} else if (macintosh_config->adb_type == MAC_ADB_PB2) {\r\npmu_kind = PMU_68K_V2;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\npmu_state = idle;\r\nreturn 0;\r\n}\r\nstatic int\r\npmu_init(void)\r\n{\r\nint timeout;\r\nvolatile struct adb_request req;\r\nvia2[B] |= TREQ;\r\nvia2[DIRB] = (via2[DIRB] | TREQ) & ~TACK;\r\npmu_request((struct adb_request *) &req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB);\r\ntimeout = 100000;\r\nwhile (!req.complete) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "pmu_init: no response from PMU\n");\r\nreturn -EAGAIN;\r\n}\r\nudelay(10);\r\npmu_poll();\r\n}\r\ntimeout = 100000;\r\ninterrupt_data[0] = 1;\r\nwhile (interrupt_data[0] || pmu_state != idle) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "pmu_init: timed out acking intrs\n");\r\nreturn -EAGAIN;\r\n}\r\nif (pmu_state == idle) {\r\nadb_int_pending = 1;\r\npmu_interrupt(0, NULL);\r\n}\r\npmu_poll();\r\nudelay(10);\r\n}\r\npmu_request((struct adb_request *) &req, NULL, 2, PMU_SET_INTR_MASK,\r\nPMU_INT_ADB_AUTO|PMU_INT_SNDBRT|PMU_INT_ADB);\r\ntimeout = 100000;\r\nwhile (!req.complete) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "pmu_init: no response from PMU\n");\r\nreturn -EAGAIN;\r\n}\r\nudelay(10);\r\npmu_poll();\r\n}\r\nbright_req_1.complete = 1;\r\nbright_req_2.complete = 1;\r\nbright_req_3.complete = 1;\r\nif (request_irq(IRQ_MAC_ADB_SR, pmu_interrupt, 0, "pmu-shift",\r\npmu_interrupt)) {\r\nprintk(KERN_ERR "pmu_init: can't get irq %d\n",\r\nIRQ_MAC_ADB_SR);\r\nreturn -EAGAIN;\r\n}\r\nif (request_irq(IRQ_MAC_ADB_CL, pmu_interrupt, 0, "pmu-clock",\r\npmu_interrupt)) {\r\nprintk(KERN_ERR "pmu_init: can't get irq %d\n",\r\nIRQ_MAC_ADB_CL);\r\nfree_irq(IRQ_MAC_ADB_SR, pmu_interrupt);\r\nreturn -EAGAIN;\r\n}\r\npmu_fully_inited = 1;\r\npmu_enable_backlight(1);\r\nprintk("adb: PMU 68K driver v0.5 for Unified ADB.\n");\r\nreturn 0;\r\n}\r\nint\r\npmu_get_model(void)\r\n{\r\nreturn pmu_kind;\r\n}\r\nstatic int\r\npmu_send_request(struct adb_request *req, int sync)\r\n{\r\nint i, ret;\r\nif (!pmu_fully_inited)\r\n{\r\nreq->complete = 1;\r\nreturn -ENXIO;\r\n}\r\nret = -EINVAL;\r\nswitch (req->data[0]) {\r\ncase PMU_PACKET:\r\nfor (i = 0; i < req->nbytes - 1; ++i)\r\nreq->data[i] = req->data[i+1];\r\n--req->nbytes;\r\nif (pmu_data_len[req->data[0]][1] != 0) {\r\nreq->reply[0] = ADB_RET_OK;\r\nreq->reply_len = 1;\r\n} else\r\nreq->reply_len = 0;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_PACKET:\r\nswitch (req->data[1]) {\r\ncase CUDA_GET_TIME:\r\nif (req->nbytes != 2)\r\nbreak;\r\nreq->data[0] = PMU_READ_RTC;\r\nreq->nbytes = 1;\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_GET_TIME;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_SET_TIME:\r\nif (req->nbytes != 6)\r\nbreak;\r\nreq->data[0] = PMU_SET_RTC;\r\nreq->nbytes = 5;\r\nfor (i = 1; i <= 4; ++i)\r\nreq->data[i] = req->data[i+1];\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_SET_TIME;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_GET_PRAM:\r\nif (req->nbytes != 4)\r\nbreak;\r\nreq->data[0] = PMU_READ_NVRAM;\r\nreq->data[1] = req->data[2];\r\nreq->data[2] = req->data[3];\r\nreq->nbytes = 3;\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_GET_PRAM;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_SET_PRAM:\r\nif (req->nbytes != 5)\r\nbreak;\r\nreq->data[0] = PMU_WRITE_NVRAM;\r\nreq->data[1] = req->data[2];\r\nreq->data[2] = req->data[3];\r\nreq->data[3] = req->data[4];\r\nreq->nbytes = 4;\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_SET_PRAM;\r\nret = pmu_queue_request(req);\r\nbreak;\r\n}\r\nbreak;\r\ncase ADB_PACKET:\r\nfor (i = req->nbytes - 1; i > 1; --i)\r\nreq->data[i+2] = req->data[i];\r\nreq->data[3] = req->nbytes - 2;\r\nreq->data[2] = pmu_adb_flags;\r\nreq->data[0] = PMU_ADB_CMD;\r\nreq->nbytes += 2;\r\nreq->reply_expected = 1;\r\nreq->reply_len = 0;\r\nret = pmu_queue_request(req);\r\nbreak;\r\n}\r\nif (ret)\r\n{\r\nreq->complete = 1;\r\nreturn ret;\r\n}\r\nif (sync) {\r\nwhile (!req->complete)\r\npmu_poll();\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npmu_autopoll(int devs)\r\n{\r\nstruct adb_request req;\r\nif (!pmu_fully_inited) return -ENXIO;\r\nif (devs) {\r\nadb_dev_map = devs;\r\npmu_request(&req, NULL, 5, PMU_ADB_CMD, 0, 0x86,\r\nadb_dev_map >> 8, adb_dev_map);\r\npmu_adb_flags = 2;\r\n} else {\r\npmu_request(&req, NULL, 1, PMU_ADB_POLL_OFF);\r\npmu_adb_flags = 0;\r\n}\r\nwhile (!req.complete)\r\npmu_poll();\r\nreturn 0;\r\n}\r\nstatic int\r\npmu_reset_bus(void)\r\n{\r\nstruct adb_request req;\r\nlong timeout;\r\nint save_autopoll = adb_dev_map;\r\nif (!pmu_fully_inited) return -ENXIO;\r\npmu_autopoll(0);\r\nreq.nbytes = 5;\r\nreq.done = NULL;\r\nreq.data[0] = PMU_ADB_CMD;\r\nreq.data[1] = 0;\r\nreq.data[2] = 3;\r\nreq.data[3] = 0;\r\nreq.data[4] = 0;\r\nreq.reply_len = 0;\r\nreq.reply_expected = 1;\r\nif (pmu_queue_request(&req) != 0)\r\n{\r\nprintk(KERN_ERR "pmu_adb_reset_bus: pmu_queue_request failed\n");\r\nreturn -EIO;\r\n}\r\nwhile (!req.complete)\r\npmu_poll();\r\ntimeout = 100000;\r\nwhile (!req.complete) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "pmu_adb_reset_bus (reset): no response from PMU\n");\r\nreturn -EIO;\r\n}\r\nudelay(10);\r\npmu_poll();\r\n}\r\nif (save_autopoll != 0)\r\npmu_autopoll(save_autopoll);\r\nreturn 0;\r\n}\r\nint\r\npmu_request(struct adb_request *req, void (*done)(struct adb_request *),\r\nint nbytes, ...)\r\n{\r\nva_list list;\r\nint i;\r\nif (nbytes < 0 || nbytes > 32) {\r\nprintk(KERN_ERR "pmu_request: bad nbytes (%d)\n", nbytes);\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->nbytes = nbytes;\r\nreq->done = done;\r\nva_start(list, nbytes);\r\nfor (i = 0; i < nbytes; ++i)\r\nreq->data[i] = va_arg(list, int);\r\nva_end(list);\r\nif (pmu_data_len[req->data[0]][1] != 0) {\r\nreq->reply[0] = ADB_RET_OK;\r\nreq->reply_len = 1;\r\n} else\r\nreq->reply_len = 0;\r\nreq->reply_expected = 0;\r\nreturn pmu_queue_request(req);\r\n}\r\nint\r\npmu_queue_request(struct adb_request *req)\r\n{\r\nunsigned long flags;\r\nint nsend;\r\nif (req->nbytes <= 0) {\r\nreq->complete = 1;\r\nreturn 0;\r\n}\r\nnsend = pmu_data_len[req->data[0]][0];\r\nif (nsend >= 0 && req->nbytes != nsend + 1) {\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->next = NULL;\r\nreq->sent = 0;\r\nreq->complete = 0;\r\nlocal_irq_save(flags);\r\nif (current_req != 0) {\r\nlast_req->next = req;\r\nlast_req = req;\r\n} else {\r\ncurrent_req = req;\r\nlast_req = req;\r\nif (pmu_state == idle)\r\npmu_start();\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nsend_byte(int x)\r\n{\r\nvia1[ACR] |= SR_CTRL;\r\nvia1[SR] = x;\r\nvia2[B] &= ~TREQ;\r\n}\r\nstatic void\r\nrecv_byte(void)\r\n{\r\nchar c;\r\nvia1[ACR] = (via1[ACR] | SR_EXT) & ~SR_OUT;\r\nc = via1[SR];\r\nvia2[B] &= ~TREQ;\r\n}\r\nstatic void\r\npmu_start(void)\r\n{\r\nunsigned long flags;\r\nstruct adb_request *req;\r\nlocal_irq_save(flags);\r\nreq = current_req;\r\nif (req == 0 || pmu_state != idle\r\n|| (req->reply_expected && req_awaiting_reply))\r\ngoto out;\r\npmu_state = sending;\r\ndata_index = 1;\r\ndata_len = pmu_data_len[req->data[0]][0];\r\nsend_byte(req->data[0]);\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nvoid\r\npmu_poll(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (via1[IFR] & SR_INT) {\r\nvia1[IFR] = SR_INT;\r\npmu_interrupt(IRQ_MAC_ADB_SR, NULL);\r\n}\r\nif (via1[IFR] & CB1_INT) {\r\nvia1[IFR] = CB1_INT;\r\npmu_interrupt(IRQ_MAC_ADB_CL, NULL);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic irqreturn_t\r\npmu_interrupt(int irq, void *dev_id)\r\n{\r\nstruct adb_request *req;\r\nint timeout, bite = 0;\r\n#if 0\r\nprintk("pmu_interrupt: irq %d state %d acr %02X, b %02X data_index %d/%d adb_int_pending %d\n",\r\nirq, pmu_state, (uint) via1[ACR], (uint) via2[B], data_index, data_len, adb_int_pending);\r\n#endif\r\nif (irq == IRQ_MAC_ADB_CL) {\r\nadb_int_pending = 1;\r\n} else if (irq == IRQ_MAC_ADB_SR) {\r\nif (via2[B] & TACK) {\r\nprintk(KERN_DEBUG "PMU: SR_INT but ack still high! (%x)\n", via2[B]);\r\n}\r\nif ((via1[ACR] & SR_OUT) == 0) bite = via1[SR];\r\nvia2[B] |= TREQ;\r\ntimeout = 3200;\r\nwhile (!(via2[B] & TACK)) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "PMU not responding (!ack)\n");\r\ngoto finish;\r\n}\r\nudelay(10);\r\n}\r\nswitch (pmu_state) {\r\ncase sending:\r\nreq = current_req;\r\nif (data_len < 0) {\r\ndata_len = req->nbytes - 1;\r\nsend_byte(data_len);\r\nbreak;\r\n}\r\nif (data_index <= data_len) {\r\nsend_byte(req->data[data_index++]);\r\nbreak;\r\n}\r\nreq->sent = 1;\r\ndata_len = pmu_data_len[req->data[0]][1];\r\nif (data_len == 0) {\r\npmu_state = idle;\r\ncurrent_req = req->next;\r\nif (req->reply_expected)\r\nreq_awaiting_reply = req;\r\nelse\r\npmu_done(req);\r\n} else {\r\npmu_state = reading;\r\ndata_index = 0;\r\nreply_ptr = req->reply + req->reply_len;\r\nrecv_byte();\r\n}\r\nbreak;\r\ncase intack:\r\ndata_index = 0;\r\ndata_len = -1;\r\npmu_state = reading_intr;\r\nreply_ptr = interrupt_data;\r\nrecv_byte();\r\nbreak;\r\ncase reading:\r\ncase reading_intr:\r\nif (data_len == -1) {\r\ndata_len = bite;\r\nif (bite > 32)\r\nprintk(KERN_ERR "PMU: bad reply len %d\n",\r\nbite);\r\n} else {\r\nreply_ptr[data_index++] = bite;\r\n}\r\nif (data_index < data_len) {\r\nrecv_byte();\r\nbreak;\r\n}\r\nif (pmu_state == reading_intr) {\r\npmu_handle_data(interrupt_data, data_index);\r\n} else {\r\nreq = current_req;\r\ncurrent_req = req->next;\r\nreq->reply_len += data_index;\r\npmu_done(req);\r\n}\r\npmu_state = idle;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "pmu_interrupt: unknown state %d?\n",\r\npmu_state);\r\n}\r\n}\r\nfinish:\r\nif (pmu_state == idle) {\r\nif (adb_int_pending) {\r\npmu_state = intack;\r\nsend_byte(PMU_INT_ACK);\r\nadb_int_pending = 0;\r\n} else if (current_req) {\r\npmu_start();\r\n}\r\n}\r\n#if 0\r\nprintk("pmu_interrupt: exit state %d acr %02X, b %02X data_index %d/%d adb_int_pending %d\n",\r\npmu_state, (uint) via1[ACR], (uint) via2[B], data_index, data_len, adb_int_pending);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\npmu_done(struct adb_request *req)\r\n{\r\nreq->complete = 1;\r\nif (req->done)\r\n(*req->done)(req);\r\n}\r\nstatic void\r\npmu_handle_data(unsigned char *data, int len)\r\n{\r\nstatic int show_pmu_ints = 1;\r\nasleep = 0;\r\nif (len < 1) {\r\nadb_int_pending = 0;\r\nreturn;\r\n}\r\nif (data[0] & PMU_INT_ADB) {\r\nif ((data[0] & PMU_INT_ADB_AUTO) == 0) {\r\nstruct adb_request *req = req_awaiting_reply;\r\nif (req == 0) {\r\nprintk(KERN_ERR "PMU: extra ADB reply\n");\r\nreturn;\r\n}\r\nreq_awaiting_reply = NULL;\r\nif (len <= 2)\r\nreq->reply_len = 0;\r\nelse {\r\nmemcpy(req->reply, data + 1, len - 1);\r\nreq->reply_len = len - 1;\r\n}\r\npmu_done(req);\r\n} else {\r\nadb_input(data+1, len-1, 1);\r\n}\r\n} else {\r\nif (data[0] == 0x08 && len == 3) {\r\npmu_set_brightness(data[1] >> 3);\r\nset_volume(data[2]);\r\n} else if (show_pmu_ints\r\n&& !(data[0] == PMU_INT_TICK && len == 1)) {\r\nint i;\r\nprintk(KERN_DEBUG "pmu intr");\r\nfor (i = 0; i < len; ++i)\r\nprintk(" %.2x", data[i]);\r\nprintk("\n");\r\n}\r\n}\r\n}\r\nstatic void\r\npmu_enable_backlight(int on)\r\n{\r\nstruct adb_request req;\r\nif (on) {\r\nif (backlight_level < 0) {\r\nswitch(pmu_kind) {\r\ncase PMU_68K_V1:\r\ncase PMU_68K_V2:\r\npmu_request(&req, NULL, 3, PMU_READ_NVRAM, 0x14, 0xe);\r\nwhile (!req.complete)\r\npmu_poll();\r\nprintk(KERN_DEBUG "pmu: nvram returned bright: %d\n", (int)req.reply[1]);\r\nbacklight_level = req.reply[1];\r\nbreak;\r\ndefault:\r\nbacklight_enabled = 0;\r\nreturn;\r\n}\r\n}\r\npmu_request(&req, NULL, 2, PMU_BACKLIGHT_BRIGHT,\r\nLEVEL_TO_BRIGHT(backlight_level));\r\nwhile (!req.complete)\r\npmu_poll();\r\n}\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_BACKLIGHT | (on ? PMU_POW_ON : PMU_POW_OFF));\r\nwhile (!req.complete)\r\npmu_poll();\r\nbacklight_enabled = on;\r\n}\r\nstatic void\r\npmu_set_brightness(int level)\r\n{\r\nint bright;\r\nbacklight_level = level;\r\nbright = LEVEL_TO_BRIGHT(level);\r\nif (!backlight_enabled)\r\nreturn;\r\nif (bright_req_1.complete)\r\npmu_request(&bright_req_1, NULL, 2, PMU_BACKLIGHT_BRIGHT,\r\nbright);\r\nif (bright_req_2.complete)\r\npmu_request(&bright_req_2, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_BACKLIGHT | (bright < 0x7f ? PMU_POW_ON : PMU_POW_OFF));\r\n}\r\nvoid\r\npmu_enable_irled(int on)\r\n{\r\nstruct adb_request req;\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL, PMU_POW_IRLED |\r\n(on ? PMU_POW_ON : PMU_POW_OFF));\r\nwhile (!req.complete)\r\npmu_poll();\r\n}\r\nstatic void\r\nset_volume(int level)\r\n{\r\n}\r\nint\r\npmu_present(void)\r\n{\r\nreturn (pmu_kind != PMU_UNKNOWN);\r\n}
