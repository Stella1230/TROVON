static __u8 *uclogic_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\r\n__u8 iface_num = iface->cur_altsetting->desc.bInterfaceNumber;\r\nstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_PF1209:\r\nif (*rsize == PF1209_RDESC_ORIG_SIZE) {\r\nrdesc = pf1209_rdesc_fixed;\r\n*rsize = sizeof(pf1209_rdesc_fixed);\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U:\r\nif (*rsize == WPXXXXU_RDESC_ORIG_SIZE) {\r\nrdesc = wp4030u_rdesc_fixed;\r\n*rsize = sizeof(wp4030u_rdesc_fixed);\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U:\r\nif (*rsize == WPXXXXU_RDESC_ORIG_SIZE) {\r\nrdesc = wp5540u_rdesc_fixed;\r\n*rsize = sizeof(wp5540u_rdesc_fixed);\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U:\r\nif (*rsize == WPXXXXU_RDESC_ORIG_SIZE) {\r\nrdesc = wp8060u_rdesc_fixed;\r\n*rsize = sizeof(wp8060u_rdesc_fixed);\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_WP1062:\r\nif (*rsize == WP1062_RDESC_ORIG_SIZE) {\r\nrdesc = wp1062_rdesc_fixed;\r\n*rsize = sizeof(wp1062_rdesc_fixed);\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850:\r\nswitch (iface_num) {\r\ncase 0:\r\nif (*rsize == TWHL850_RDESC_ORIG_SIZE0) {\r\nrdesc = twhl850_rdesc_fixed0;\r\n*rsize = sizeof(twhl850_rdesc_fixed0);\r\n}\r\nbreak;\r\ncase 1:\r\nif (*rsize == TWHL850_RDESC_ORIG_SIZE1) {\r\nrdesc = twhl850_rdesc_fixed1;\r\n*rsize = sizeof(twhl850_rdesc_fixed1);\r\n}\r\nbreak;\r\ncase 2:\r\nif (*rsize == TWHL850_RDESC_ORIG_SIZE2) {\r\nrdesc = twhl850_rdesc_fixed2;\r\n*rsize = sizeof(twhl850_rdesc_fixed2);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60:\r\nswitch (iface_num) {\r\ncase 0:\r\nif (*rsize == TWHA60_RDESC_ORIG_SIZE0) {\r\nrdesc = twha60_rdesc_fixed0;\r\n*rsize = sizeof(twha60_rdesc_fixed0);\r\n}\r\nbreak;\r\ncase 1:\r\nif (*rsize == TWHA60_RDESC_ORIG_SIZE1) {\r\nrdesc = twha60_rdesc_fixed1;\r\n*rsize = sizeof(twha60_rdesc_fixed1);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nif (drvdata->rdesc != NULL) {\r\nrdesc = drvdata->rdesc;\r\n*rsize = drvdata->rsize;\r\n}\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int uclogic_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif ((drvdata->ignore_pen_usage) &&\r\n(field->application == HID_DG_PEN))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void uclogic_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hi)\r\n{\r\nchar *name;\r\nconst char *suffix = NULL;\r\nstruct hid_field *field;\r\nsize_t len;\r\nif (!hi->report)\r\nreturn;\r\nfield = hi->report->field[0];\r\nswitch (field->application) {\r\ncase HID_GD_KEYBOARD:\r\nsuffix = "Keyboard";\r\nbreak;\r\ncase HID_GD_MOUSE:\r\nsuffix = "Mouse";\r\nbreak;\r\ncase HID_GD_KEYPAD:\r\nsuffix = "Pad";\r\nbreak;\r\ncase HID_DG_PEN:\r\nsuffix = "Pen";\r\nbreak;\r\ncase HID_CP_CONSUMER_CONTROL:\r\nsuffix = "Consumer Control";\r\nbreak;\r\ncase HID_GD_SYSTEM_CONTROL:\r\nsuffix = "System Control";\r\nbreak;\r\n}\r\nif (suffix) {\r\nlen = strlen(hdev->name) + 2 + strlen(suffix);\r\nname = devm_kzalloc(&hi->input->dev, len, GFP_KERNEL);\r\nif (name) {\r\nsnprintf(name, len, "%s %s", hdev->name, suffix);\r\nhi->input->name = name;\r\n}\r\n}\r\n}\r\nstatic int uclogic_tablet_enable(struct hid_device *hdev)\r\n{\r\nint rc;\r\nstruct usb_device *usb_dev = hid_to_usb_dev(hdev);\r\nstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\r\n__le16 *buf = NULL;\r\nsize_t len;\r\ns32 params[UCLOGIC_PH_ID_NUM];\r\ns32 resolution;\r\n__u8 *p;\r\ns32 v;\r\nlen = UCLOGIC_PRM_NUM * sizeof(*buf);\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (buf == NULL) {\r\nhid_err(hdev, "failed to allocate parameter buffer\n");\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nrc = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\nUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\r\n(USB_DT_STRING << 8) + 0x64,\r\n0x0409, buf, len,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (rc == -EPIPE) {\r\nhid_err(hdev, "device parameters not found\n");\r\nrc = -ENODEV;\r\ngoto cleanup;\r\n} else if (rc < 0) {\r\nhid_err(hdev, "failed to get device parameters: %d\n", rc);\r\nrc = -ENODEV;\r\ngoto cleanup;\r\n} else if (rc != len) {\r\nhid_err(hdev, "invalid device parameters\n");\r\nrc = -ENODEV;\r\ngoto cleanup;\r\n}\r\nparams[UCLOGIC_PH_ID_X_LM] = le16_to_cpu(buf[UCLOGIC_PRM_X_LM]);\r\nparams[UCLOGIC_PH_ID_Y_LM] = le16_to_cpu(buf[UCLOGIC_PRM_Y_LM]);\r\nparams[UCLOGIC_PH_ID_PRESSURE_LM] =\r\nle16_to_cpu(buf[UCLOGIC_PRM_PRESSURE_LM]);\r\nresolution = le16_to_cpu(buf[UCLOGIC_PRM_RESOLUTION]);\r\nif (resolution == 0) {\r\nparams[UCLOGIC_PH_ID_X_PM] = 0;\r\nparams[UCLOGIC_PH_ID_Y_PM] = 0;\r\n} else {\r\nparams[UCLOGIC_PH_ID_X_PM] = params[UCLOGIC_PH_ID_X_LM] *\r\n1000 / resolution;\r\nparams[UCLOGIC_PH_ID_Y_PM] = params[UCLOGIC_PH_ID_Y_LM] *\r\n1000 / resolution;\r\n}\r\ndrvdata->rdesc = devm_kzalloc(&hdev->dev,\r\nsizeof(uclogic_tablet_rdesc_template),\r\nGFP_KERNEL);\r\nif (drvdata->rdesc == NULL) {\r\nhid_err(hdev, "failed to allocate fixed rdesc\n");\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ndrvdata->rsize = sizeof(uclogic_tablet_rdesc_template);\r\nmemcpy(drvdata->rdesc, uclogic_tablet_rdesc_template,\r\ndrvdata->rsize);\r\nfor (p = drvdata->rdesc;\r\np <= drvdata->rdesc + drvdata->rsize - 4;) {\r\nif (p[0] == 0xFE && p[1] == 0xED && p[2] == 0x1D &&\r\np[3] < ARRAY_SIZE(params)) {\r\nv = params[p[3]];\r\nput_unaligned(cpu_to_le32(v), (s32 *)p);\r\np += 4;\r\n} else {\r\np++;\r\n}\r\n}\r\nrc = 0;\r\ncleanup:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int uclogic_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint rc;\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct uclogic_drvdata *drvdata;\r\nhdev->quirks |= HID_QUIRK_MULTI_INPUT;\r\nhdev->quirks |= HID_QUIRK_NO_EMPTY_INPUT;\r\ndrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (drvdata == NULL)\r\nreturn -ENOMEM;\r\nhid_set_drvdata(hdev, drvdata);\r\nswitch (id->product) {\r\ncase USB_DEVICE_ID_HUION_TABLET:\r\nif (intf->cur_altsetting->desc.bInterfaceNumber == 0) {\r\nrc = uclogic_tablet_enable(hdev);\r\nif (rc) {\r\nhid_err(hdev, "tablet enabling failed\n");\r\nreturn rc;\r\n}\r\ndrvdata->invert_pen_inrange = true;\r\n} else {\r\ndrvdata->ignore_pen_usage = true;\r\n}\r\nbreak;\r\n}\r\nrc = hid_parse(hdev);\r\nif (rc) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn rc;\r\n}\r\nrc = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (rc) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uclogic_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif ((drvdata->invert_pen_inrange) &&\r\n(report->type == HID_INPUT_REPORT) &&\r\n(report->id == UCLOGIC_PEN_REPORT_ID) &&\r\n(size >= 2))\r\ndata[1] ^= 0x40;\r\nreturn 0;\r\n}
