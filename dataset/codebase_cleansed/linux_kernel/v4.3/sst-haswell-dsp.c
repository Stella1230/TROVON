static int hsw_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,\r\nstruct fw_module_header *module)\r\n{\r\nstruct dma_block_info *block;\r\nstruct sst_module *mod;\r\nstruct sst_module_template template;\r\nint count, ret;\r\nvoid __iomem *ram;\r\nif (module->type != SST_HSW_MODULE_BASE_FW\r\n&& module->type != SST_HSW_MODULE_PCM_SYSTEM\r\n&& module->type != SST_HSW_MODULE_PCM\r\n&& module->type != SST_HSW_MODULE_PCM_REFERENCE\r\n&& module->type != SST_HSW_MODULE_PCM_CAPTURE\r\n&& module->type != SST_HSW_MODULE_WAVES\r\n&& module->type != SST_HSW_MODULE_LPAL)\r\nreturn 0;\r\ndev_dbg(dsp->dev, "new module sign 0x%s size 0x%x blocks 0x%x type 0x%x\n",\r\nmodule->signature, module->mod_size,\r\nmodule->blocks, module->type);\r\ndev_dbg(dsp->dev, " entrypoint 0x%x\n", module->entry_point);\r\ndev_dbg(dsp->dev, " persistent 0x%x scratch 0x%x\n",\r\nmodule->info.persistent_size, module->info.scratch_size);\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.id = module->type;\r\ntemplate.entry = module->entry_point - 4;\r\ntemplate.persistent_size = module->info.persistent_size;\r\ntemplate.scratch_size = module->info.scratch_size;\r\nmod = sst_module_new(fw, &template, NULL);\r\nif (mod == NULL)\r\nreturn -ENOMEM;\r\nblock = (void *)module + sizeof(*module);\r\nfor (count = 0; count < module->blocks; count++) {\r\nif (block->size <= 0) {\r\ndev_err(dsp->dev,\r\n"error: block %d size invalid\n", count);\r\nsst_module_free(mod);\r\nreturn -EINVAL;\r\n}\r\nswitch (block->type) {\r\ncase SST_HSW_IRAM:\r\nram = dsp->addr.lpe;\r\nmod->offset =\r\nblock->ram_offset + dsp->addr.iram_offset;\r\nmod->type = SST_MEM_IRAM;\r\nbreak;\r\ncase SST_HSW_DRAM:\r\ncase SST_HSW_REGS:\r\nram = dsp->addr.lpe;\r\nmod->offset = block->ram_offset;\r\nmod->type = SST_MEM_DRAM;\r\nbreak;\r\ndefault:\r\ndev_err(dsp->dev, "error: bad type 0x%x for block 0x%x\n",\r\nblock->type, count);\r\nsst_module_free(mod);\r\nreturn -EINVAL;\r\n}\r\nmod->size = block->size;\r\nmod->data = (void *)block + sizeof(*block);\r\nmod->data_offset = mod->data - fw->dma_buf;\r\ndev_dbg(dsp->dev, "module block %d type 0x%x "\r\n"size 0x%x ==> ram %p offset 0x%x\n",\r\ncount, mod->type, block->size, ram,\r\nblock->ram_offset);\r\nret = sst_module_alloc_blocks(mod);\r\nif (ret < 0) {\r\ndev_err(dsp->dev, "error: could not allocate blocks for module %d\n",\r\ncount);\r\nsst_module_free(mod);\r\nreturn ret;\r\n}\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nmod->state = SST_MODULE_STATE_LOADED;\r\nreturn 0;\r\n}\r\nstatic int hsw_parse_fw_image(struct sst_fw *sst_fw)\r\n{\r\nstruct fw_header *header;\r\nstruct fw_module_header *module;\r\nstruct sst_dsp *dsp = sst_fw->dsp;\r\nint ret, count;\r\nheader = (struct fw_header *)sst_fw->dma_buf;\r\nif ((strncmp(header->signature, SST_HSW_FW_SIGN, 4) != 0) ||\r\n(sst_fw->size != header->file_size + sizeof(*header))) {\r\ndev_err(dsp->dev, "error: invalid fw sign/filesize mismatch\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dsp->dev, "header size=0x%x modules=0x%x fmt=0x%x size=%zu\n",\r\nheader->file_size, header->modules,\r\nheader->file_format, sizeof(*header));\r\nmodule = (void *)sst_fw->dma_buf + sizeof(*header);\r\nfor (count = 0; count < header->modules; count++) {\r\nret = hsw_parse_module(dsp, sst_fw, module);\r\nif (ret < 0) {\r\ndev_err(dsp->dev, "error: invalid module %d\n", count);\r\nreturn ret;\r\n}\r\nmodule = (void *)module + sizeof(*module) + module->mod_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hsw_irq(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nu32 isr;\r\nint ret = IRQ_NONE;\r\nspin_lock(&sst->spinlock);\r\nisr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);\r\nif (isr & SST_ISRX_DONE) {\r\ntrace_sst_irq_done(isr,\r\nsst_dsp_shim_read_unlocked(sst, SST_IMRX));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_DONE, SST_IMRX_DONE);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nif (isr & SST_ISRX_BUSY) {\r\ntrace_sst_irq_busy(isr,\r\nsst_dsp_shim_read_unlocked(sst, SST_IMRX));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_BUSY, SST_IMRX_BUSY);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nspin_unlock(&sst->spinlock);\r\nreturn ret;\r\n}\r\nstatic void hsw_set_dsp_D3(struct sst_dsp *sst)\r\n{\r\nu32 val;\r\nu32 reg;\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nval |= SST_VDRTCL0_DSRAMPGE_MASK |\r\nSST_VDRTCL0_ISRAMPGE_MASK;\r\nval &= ~(SST_VDRTCL0_D3PGD | SST_VDRTCL0_D3SRAMPGD);\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval |= SST_VDRTCL2_APLLSE_MASK;\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,\r\nSST_CLKCTL_MASK, 0);\r\nval = readl(sst->addr.pci_cfg + SST_PMCS);\r\nval |= SST_PMCS_PS_MASK;\r\nwritel(val, sst->addr.pci_cfg + SST_PMCS);\r\nudelay(50);\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nudelay(50);\r\n}\r\nstatic void hsw_reset(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_RST | SST_CSR_STALL,\r\nSST_CSR_RST | SST_CSR_STALL);\r\nmdelay(10);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_RST | SST_CSR_STALL, SST_CSR_STALL);\r\n}\r\nstatic int hsw_set_dsp_D0(struct sst_dsp *sst)\r\n{\r\nint tries = 10;\r\nu32 reg, fw_dump_bit;\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreg |= SST_VDRTCL0_D3PGD;\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreg = readl(sst->addr.pci_cfg + SST_PMCS);\r\nreg &= ~SST_PMCS_PS_MASK;\r\nwritel(reg, sst->addr.pci_cfg + SST_PMCS);\r\nwhile (tries--) {\r\nreg = readl(sst->addr.pci_cfg + SST_PMCS) & SST_PMCS_PS_MASK;\r\nif (reg == 0)\r\ngoto finish;\r\nmsleep(1);\r\n}\r\nreturn -ENODEV;\r\nfinish:\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR,\r\nSST_CSR_S1IOCS | SST_CSR_SBCS1 | SST_CSR_LPCS, 0x0);\r\nsst_dsp_shim_update_bits_unlocked(sst,\r\nSST_CSR, SST_CSR_STALL | SST_CSR_DCS_MASK,\r\nSST_CSR_STALL | SST_CSR_DCS(4));\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,\r\nSST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0,\r\nSST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0);\r\nhsw_reset(sst);\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nudelay(50);\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg &= ~SST_VDRTCL2_APLLSE_MASK;\r\nwritel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nreg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreg |= SST_VDRTCL0_DSRAMPGE_MASK | SST_VDRTCL0_ISRAMPGE_MASK;\r\nfw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;\r\nwritel(reg & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR2, SST_CSR2_SDFD_SSP1,\r\nSST_CSR2_SDFD_SSP1);\r\nsst_dsp_shim_update_bits(sst, SST_HMDC,\r\nSST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH,\r\nSST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH);\r\nsst_dsp_shim_update_bits(sst, SST_IMRX, (SST_IMRX_BUSY | SST_IMRX_DONE),\r\n0x0);\r\nsst_dsp_shim_update_bits(sst, SST_IMRD, (SST_IMRD_DONE | SST_IMRD_BUSY |\r\nSST_IMRD_SSP0 | SST_IMRD_DMAC), 0x0);\r\nsst_dsp_shim_write(sst, SST_IPCX, 0x0);\r\nsst_dsp_shim_write(sst, SST_IPCD, 0x0);\r\nsst_dsp_shim_write(sst, 0x80, 0x6);\r\nsst_dsp_shim_write(sst, 0xe0, 0x300a);\r\nreturn 0;\r\n}\r\nstatic void hsw_boot(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits(sst, SST_HMDC,\r\nSST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH, 0);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_CSR, SST_CSR_STALL, 0x0);\r\n}\r\nstatic void hsw_stall(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits(sst, SST_CSR,\r\nSST_CSR_24MHZ_LPCS | SST_CSR_STALL,\r\nSST_CSR_STALL | SST_CSR_24MHZ_LPCS);\r\n}\r\nstatic void hsw_sleep(struct sst_dsp *sst)\r\n{\r\ndev_dbg(sst->dev, "HSW_PM dsp runtime suspend\n");\r\nsst_dsp_shim_update_bits(sst, SST_CSR,\r\nSST_CSR_24MHZ_LPCS | SST_CSR_RST | SST_CSR_STALL,\r\nSST_CSR_RST | SST_CSR_STALL | SST_CSR_24MHZ_LPCS);\r\nhsw_set_dsp_D3(sst);\r\ndev_dbg(sst->dev, "HSW_PM dsp runtime suspend exit\n");\r\n}\r\nstatic int hsw_wake(struct sst_dsp *sst)\r\n{\r\nint ret;\r\ndev_dbg(sst->dev, "HSW_PM dsp runtime resume\n");\r\nret = hsw_set_dsp_D0(sst);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(sst->dev, "HSW_PM dsp runtime resume exit\n");\r\nreturn 0;\r\n}\r\nstatic int hsw_acpi_resource_map(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nsst->addr.lpe_base = pdata->lpe_base;\r\nsst->addr.lpe = ioremap(pdata->lpe_base, pdata->lpe_size);\r\nif (!sst->addr.lpe)\r\nreturn -ENODEV;\r\nsst->addr.pci_cfg = ioremap(pdata->pcicfg_base, pdata->pcicfg_size);\r\nif (!sst->addr.pci_cfg) {\r\niounmap(sst->addr.lpe);\r\nreturn -ENODEV;\r\n}\r\nsst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;\r\nreturn 0;\r\n}\r\nstatic u32 hsw_block_get_bit(struct sst_mem_block *block)\r\n{\r\nu32 bit = 0, shift = 0, index;\r\nstruct sst_dsp *sst = block->dsp;\r\nfor (index = 0; index < ARRAY_SIZE(sram_shift); index++) {\r\nif (sram_shift[index].dev_id == sst->id)\r\nbreak;\r\n}\r\nif (index < ARRAY_SIZE(sram_shift)) {\r\nswitch (block->type) {\r\ncase SST_MEM_DRAM:\r\nshift = sram_shift[index].dram_shift;\r\nbreak;\r\ncase SST_MEM_IRAM:\r\nshift = sram_shift[index].iram_shift;\r\nbreak;\r\ndefault:\r\nshift = 0;\r\n}\r\n} else\r\nshift = 0;\r\nbit = 1 << (block->index + shift);\r\nreturn bit;\r\n}\r\nstatic void sst_mem_block_dummy_read(struct sst_mem_block *block)\r\n{\r\nu32 size;\r\nu8 tmp_buf[4];\r\nstruct sst_dsp *sst = block->dsp;\r\nsize = block->size > 4 ? 4 : block->size;\r\nmemcpy_fromio(tmp_buf, sst->addr.lpe + block->offset, size);\r\n}\r\nstatic int hsw_block_enable(struct sst_mem_block *block)\r\n{\r\nstruct sst_dsp *sst = block->dsp;\r\nu32 bit, val;\r\nif (block->users++ > 0)\r\nreturn 0;\r\ndev_dbg(block->dsp->dev, " enabled block %d:%d at offset 0x%x\n",\r\nblock->type, block->index, block->offset);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval &= ~SST_VDRTCL2_DCLCGE;\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nbit = hsw_block_get_bit(block);\r\nwritel(val & ~bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nudelay(10);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval |= SST_VDRTCL2_DCLCGE;\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nudelay(50);\r\nsst_mem_block_dummy_read(block);\r\nreturn 0;\r\n}\r\nstatic int hsw_block_disable(struct sst_mem_block *block)\r\n{\r\nstruct sst_dsp *sst = block->dsp;\r\nu32 bit, val;\r\nif (--block->users > 0)\r\nreturn 0;\r\ndev_dbg(block->dsp->dev, " disabled block %d:%d at offset 0x%x\n",\r\nblock->type, block->index, block->offset);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval &= ~SST_VDRTCL2_DCLCGE;\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL0);\r\nbit = hsw_block_get_bit(block);\r\nif (bit != (1 << SST_VDRTCL0_DSRAMPGE_SHIFT))\r\nwritel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nudelay(10);\r\nval = readl(sst->addr.pci_cfg + SST_VDRTCTL2);\r\nval |= SST_VDRTCL2_DCLCGE;\r\nwritel(val, sst->addr.pci_cfg + SST_VDRTCTL2);\r\nudelay(50);\r\nreturn 0;\r\n}\r\nstatic int hsw_init(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nconst struct sst_adsp_memregion *region;\r\nstruct device *dev;\r\nint ret = -ENODEV, i, j, region_count;\r\nu32 offset, size, fw_dump_bit;\r\ndev = sst->dma_dev;\r\nswitch (sst->id) {\r\ncase SST_DEV_ID_LYNX_POINT:\r\nregion = lp_region;\r\nregion_count = ARRAY_SIZE(lp_region);\r\nsst->addr.iram_offset = SST_LP_IRAM_OFFSET;\r\nsst->addr.dsp_iram_offset = SST_LPT_DSP_IRAM_OFFSET;\r\nsst->addr.dsp_dram_offset = SST_LPT_DSP_DRAM_OFFSET;\r\nsst->addr.shim_offset = SST_LP_SHIM_OFFSET;\r\nbreak;\r\ncase SST_DEV_ID_WILDCAT_POINT:\r\nregion = wpt_region;\r\nregion_count = ARRAY_SIZE(wpt_region);\r\nsst->addr.iram_offset = SST_WPT_IRAM_OFFSET;\r\nsst->addr.dsp_iram_offset = SST_WPT_DSP_IRAM_OFFSET;\r\nsst->addr.dsp_dram_offset = SST_WPT_DSP_DRAM_OFFSET;\r\nsst->addr.shim_offset = SST_WPT_SHIM_OFFSET;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "error: failed to get mem resources\n");\r\nreturn ret;\r\n}\r\nret = hsw_acpi_resource_map(sst, pdata);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to map resources\n");\r\nreturn ret;\r\n}\r\nret = hsw_set_dsp_D0(sst);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to set DSP D0 and reset SHIM\n");\r\nreturn ret;\r\n}\r\nret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(31));\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < region_count; i++) {\r\noffset = region[i].start;\r\nsize = (region[i].end - region[i].start) / region[i].blocks;\r\nfor (j = 0; j < region[i].blocks; j++) {\r\nsst_mem_block_register(sst, offset, size,\r\nregion[i].type, &sst_hsw_ops, j, sst);\r\noffset += size;\r\n}\r\n}\r\nfw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;\r\nwritel(0xffffffff & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);\r\nreturn 0;\r\n}\r\nstatic void hsw_free(struct sst_dsp *sst)\r\n{\r\nsst_mem_block_unregister_all(sst);\r\niounmap(sst->addr.lpe);\r\niounmap(sst->addr.pci_cfg);\r\n}
