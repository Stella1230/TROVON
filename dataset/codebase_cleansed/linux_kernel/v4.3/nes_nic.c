static int nes_netdev_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct nes_vnic *nesvnic = container_of(napi, struct nes_vnic, napi);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_nic_cq *nescq = &nesvnic->nic_cq;\r\nnesvnic->budget = budget;\r\nnescq->cqes_pending = 0;\r\nnescq->rx_cqes_completed = 0;\r\nnescq->cqe_allocs_pending = 0;\r\nnescq->rx_pkts_indicated = 0;\r\nnes_nic_ce_handler(nesdev, nescq);\r\nif (nescq->cqes_pending == 0) {\r\nnapi_complete(napi);\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\nnescq->cq_number | (nescq->cqe_allocs_pending << 16));\r\nnes_read32(nesdev->regs+NES_CQE_ALLOC);\r\n} else {\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC,\r\nnescq->cq_number | (nescq->cqe_allocs_pending << 16));\r\nnes_debug(NES_DBG_NETDEV, "%s: exiting with work pending\n",\r\nnesvnic->netdev->name);\r\n}\r\nreturn nescq->rx_pkts_indicated;\r\n}\r\nstatic int nes_netdev_open(struct net_device *netdev)\r\n{\r\nu32 macaddr_low;\r\nu16 macaddr_high;\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nint ret;\r\nint i;\r\nstruct nes_vnic *first_nesvnic = NULL;\r\nu32 nic_active_bit;\r\nu32 nic_active;\r\nstruct list_head *list_pos, *list_temp;\r\nunsigned long flags;\r\nassert(nesdev != NULL);\r\nif (nesvnic->netdev_open == 1)\r\nreturn 0;\r\nif (netif_msg_ifup(nesvnic))\r\nprintk(KERN_INFO PFX "%s: enabling interface\n", netdev->name);\r\nret = nes_init_nic_qp(nesdev, netdev);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\nif ((!nesvnic->of_device_registered) && (nesvnic->rdma_enabled)) {\r\nnesvnic->nesibdev = nes_init_ofa_device(netdev);\r\nif (nesvnic->nesibdev == NULL) {\r\nprintk(KERN_ERR PFX "%s: nesvnic->nesibdev alloc failed", netdev->name);\r\n} else {\r\nnesvnic->nesibdev->nesvnic = nesvnic;\r\nret = nes_register_ofa_device(nesvnic->nesibdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "%s: Unable to register RDMA device, ret = %d\n",\r\nnetdev->name, ret);\r\n}\r\n}\r\n}\r\nnic_active_bit = 1 << nesvnic->nic_index;\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_ACTIVE);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_ACTIVE, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ENABLE);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ENABLE, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_BROADCAST_ON);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_BROADCAST_ON, nic_active);\r\nmacaddr_high = ((u16)netdev->dev_addr[0]) << 8;\r\nmacaddr_high += (u16)netdev->dev_addr[1];\r\nmacaddr_low = ((u32)netdev->dev_addr[2]) << 24;\r\nmacaddr_low += ((u32)netdev->dev_addr[3]) << 16;\r\nmacaddr_low += ((u32)netdev->dev_addr[4]) << 8;\r\nmacaddr_low += (u32)netdev->dev_addr[5];\r\nfor (i = 0; i < NES_MAX_PORT_COUNT; i++) {\r\nif (nesvnic->qp_nic_index[i] == 0xf) {\r\nbreak;\r\n}\r\nnes_debug(NES_DBG_NETDEV, "i=%d, perfect filter table index= %d, PERF FILTER LOW"\r\n" (Addr:%08X) = %08X, HIGH = %08X.\n",\r\ni, nesvnic->qp_nic_index[i],\r\nNES_IDX_PERFECT_FILTER_LOW+\r\n(nesvnic->qp_nic_index[i] * 8),\r\nmacaddr_low,\r\n(u32)macaddr_high | NES_MAC_ADDR_VALID |\r\n((((u32)nesvnic->nic_index) << 16)));\r\nnes_write_indexed(nesdev,\r\nNES_IDX_PERFECT_FILTER_LOW + (nesvnic->qp_nic_index[i] * 8),\r\nmacaddr_low);\r\nnes_write_indexed(nesdev,\r\nNES_IDX_PERFECT_FILTER_HIGH + (nesvnic->qp_nic_index[i] * 8),\r\n(u32)macaddr_high | NES_MAC_ADDR_VALID |\r\n((((u32)nesvnic->nic_index) << 16)));\r\n}\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\nnesvnic->nic_cq.cq_number);\r\nnes_read32(nesdev->regs+NES_CQE_ALLOC);\r\nlist_for_each_safe(list_pos, list_temp, &nesdev->nesadapter->nesvnic_list[nesdev->mac_index]) {\r\nfirst_nesvnic = container_of(list_pos, struct nes_vnic, list);\r\nif (first_nesvnic->netdev_open == 1)\r\nbreak;\r\n}\r\nif (first_nesvnic->netdev_open == 0) {\r\nnes_debug(NES_DBG_INIT, "Setting up MAC interrupt mask.\n");\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_MASK + (0x200 * nesdev->mac_index),\r\n~(NES_MAC_INT_LINK_STAT_CHG | NES_MAC_INT_XGMII_EXT |\r\nNES_MAC_INT_TX_UNDERFLOW | NES_MAC_INT_TX_ERROR));\r\nfirst_nesvnic = nesvnic;\r\n}\r\nif (first_nesvnic->linkup) {\r\nnesvnic->linkup = 1;\r\nnetif_start_queue(netdev);\r\nnetif_carrier_on(netdev);\r\n}\r\nspin_lock_irqsave(&nesdev->nesadapter->phy_lock, flags);\r\nif (nesdev->nesadapter->phy_type[nesdev->mac_index] == NES_PHY_TYPE_SFP_D) {\r\nnesdev->link_recheck = 1;\r\nmod_delayed_work(system_wq, &nesdev->work,\r\nNES_LINK_RECHECK_DELAY);\r\n}\r\nspin_unlock_irqrestore(&nesdev->nesadapter->phy_lock, flags);\r\nspin_lock_irqsave(&nesvnic->port_ibevent_lock, flags);\r\nif (nesvnic->of_device_registered) {\r\nnesdev->nesadapter->send_term_ok = 1;\r\nif (nesvnic->linkup == 1) {\r\nif (nesdev->iw_status == 0) {\r\nnesdev->iw_status = 1;\r\nnes_port_ibevent(nesvnic);\r\n}\r\n} else {\r\nnesdev->iw_status = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&nesvnic->port_ibevent_lock, flags);\r\nnapi_enable(&nesvnic->napi);\r\nnesvnic->netdev_open = 1;\r\nreturn 0;\r\n}\r\nstatic int nes_netdev_stop(struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu32 nic_active_mask;\r\nu32 nic_active;\r\nstruct nes_vnic *first_nesvnic = NULL;\r\nstruct list_head *list_pos, *list_temp;\r\nunsigned long flags;\r\nnes_debug(NES_DBG_SHUTDOWN, "nesvnic=%p, nesdev=%p, netdev=%p %s\n",\r\nnesvnic, nesdev, netdev, netdev->name);\r\nif (nesvnic->netdev_open == 0)\r\nreturn 0;\r\nif (netif_msg_ifdown(nesvnic))\r\nprintk(KERN_INFO PFX "%s: disabling interface\n", netdev->name);\r\nnetif_carrier_off(netdev);\r\nnapi_disable(&nesvnic->napi);\r\nnetif_stop_queue(netdev);\r\nlist_for_each_safe(list_pos, list_temp, &nesdev->nesadapter->nesvnic_list[nesdev->mac_index]) {\r\nfirst_nesvnic = container_of(list_pos, struct nes_vnic, list);\r\nif ((first_nesvnic->netdev_open == 1) && (first_nesvnic != nesvnic))\r\nbreak;\r\n}\r\nif ((first_nesvnic->netdev_open == 1) && (first_nesvnic != nesvnic) &&\r\n(PCI_FUNC(first_nesvnic->nesdev->pcidev->devfn) !=\r\nPCI_FUNC(nesvnic->nesdev->pcidev->devfn))) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_MASK+\r\n(0x200*nesdev->mac_index), 0xffffffff);\r\nnes_write_indexed(first_nesvnic->nesdev,\r\nNES_IDX_MAC_INT_MASK+\r\n(0x200*first_nesvnic->nesdev->mac_index),\r\n~(NES_MAC_INT_LINK_STAT_CHG | NES_MAC_INT_XGMII_EXT |\r\nNES_MAC_INT_TX_UNDERFLOW | NES_MAC_INT_TX_ERROR));\r\n} else {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_MASK+(0x200*nesdev->mac_index), 0xffffffff);\r\n}\r\nnic_active_mask = ~((u32)(1 << nesvnic->nic_index));\r\nnes_write_indexed(nesdev, NES_IDX_PERFECT_FILTER_HIGH+\r\n(nesvnic->perfect_filter_index*8), 0);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_ACTIVE);\r\nnic_active &= nic_active_mask;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_ACTIVE, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL);\r\nnic_active &= nic_active_mask;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ENABLE);\r\nnic_active &= nic_active_mask;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ENABLE, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL);\r\nnic_active &= nic_active_mask;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_BROADCAST_ON);\r\nnic_active &= nic_active_mask;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_BROADCAST_ON, nic_active);\r\nspin_lock_irqsave(&nesvnic->port_ibevent_lock, flags);\r\nif (nesvnic->of_device_registered) {\r\nnesdev->nesadapter->send_term_ok = 0;\r\nnesdev->iw_status = 0;\r\nif (nesvnic->linkup == 1)\r\nnes_port_ibevent(nesvnic);\r\n}\r\ndel_timer_sync(&nesvnic->event_timer);\r\nnesvnic->event_timer.function = NULL;\r\nspin_unlock_irqrestore(&nesvnic->port_ibevent_lock, flags);\r\nnes_destroy_nic_qp(nesvnic);\r\nnesvnic->netdev_open = 0;\r\nreturn 0;\r\n}\r\nstatic int nes_nic_send(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_nic *nesnic = &nesvnic->nic;\r\nstruct nes_hw_nic_sq_wqe *nic_sqe;\r\nstruct tcphdr *tcph;\r\n__le16 *wqe_fragment_length;\r\nu32 wqe_misc;\r\nu16 wqe_fragment_index = 1;\r\nu16 skb_fragment_index;\r\ndma_addr_t bus_address;\r\nnic_sqe = &nesnic->sq_vbase[nesnic->sq_head];\r\nwqe_fragment_length = (__le16 *)&nic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_0_TAG_IDX];\r\nif (skb_vlan_tag_present(skb)) {\r\nnes_debug(NES_DBG_NIC_TX, "%s: VLAN packet to send... VLAN = %08X\n",\r\nnetdev->name, skb_vlan_tag_get(skb));\r\nwqe_misc = NES_NIC_SQ_WQE_TAGVALUE_ENABLE;\r\nwqe_fragment_length[0] = (__force __le16) skb_vlan_tag_get(skb);\r\n} else\r\nwqe_misc = 0;\r\nwqe_fragment_length++;\r\nwqe_misc |= NES_NIC_SQ_WQE_COMPLETION;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nif (skb_is_gso(skb)) {\r\ntcph = tcp_hdr(skb);\r\nwqe_misc |= NES_NIC_SQ_WQE_LSO_ENABLE | (u16)skb_shinfo(skb)->gso_size;\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_LSO_INFO_IDX,\r\n((u32)tcph->doff) |\r\n(((u32)(((unsigned char *)tcph) - skb->data)) << 4));\r\n}\r\n} else {\r\nwqe_misc |= NES_NIC_SQ_WQE_DISABLE_CHKSUM;\r\n}\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_TOTAL_LENGTH_IDX,\r\nskb->len);\r\nmemcpy(&nesnic->first_frag_vbase[nesnic->sq_head].buffer,\r\nskb->data, min(((unsigned int)NES_FIRST_FRAG_SIZE), skb_headlen(skb)));\r\nwqe_fragment_length[0] = cpu_to_le16(min(((unsigned int)NES_FIRST_FRAG_SIZE),\r\nskb_headlen(skb)));\r\nwqe_fragment_length[1] = 0;\r\nif (skb_headlen(skb) > NES_FIRST_FRAG_SIZE) {\r\nif ((skb_shinfo(skb)->nr_frags + 1) > 4) {\r\nnes_debug(NES_DBG_NIC_TX, "%s: Packet with %u fragments not sent, skb_headlen=%u\n",\r\nnetdev->name, skb_shinfo(skb)->nr_frags + 2, skb_headlen(skb));\r\nkfree_skb(skb);\r\nnesvnic->tx_sw_dropped++;\r\nreturn NETDEV_TX_LOCKED;\r\n}\r\nset_bit(nesnic->sq_head, nesnic->first_frag_overflow);\r\nbus_address = pci_map_single(nesdev->pcidev, skb->data + NES_FIRST_FRAG_SIZE,\r\nskb_headlen(skb) - NES_FIRST_FRAG_SIZE, PCI_DMA_TODEVICE);\r\nwqe_fragment_length[wqe_fragment_index++] =\r\ncpu_to_le16(skb_headlen(skb) - NES_FIRST_FRAG_SIZE);\r\nwqe_fragment_length[wqe_fragment_index] = 0;\r\nset_wqe_64bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_FRAG1_LOW_IDX,\r\n((u64)(bus_address)));\r\nnesnic->tx_skb[nesnic->sq_head] = skb;\r\n}\r\nif (skb_headlen(skb) == skb->len) {\r\nif (skb_headlen(skb) <= NES_FIRST_FRAG_SIZE) {\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_2_1_IDX] = 0;\r\nnesnic->tx_skb[nesnic->sq_head] = skb;\r\n}\r\n} else {\r\nnesnic->tx_skb[nesnic->sq_head] = skb;\r\nfor (skb_fragment_index = 0; skb_fragment_index < skb_shinfo(skb)->nr_frags;\r\nskb_fragment_index++) {\r\nskb_frag_t *frag =\r\n&skb_shinfo(skb)->frags[skb_fragment_index];\r\nbus_address = skb_frag_dma_map(&nesdev->pcidev->dev,\r\nfrag, 0, skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\nwqe_fragment_length[wqe_fragment_index] =\r\ncpu_to_le16(skb_frag_size(&skb_shinfo(skb)->frags[skb_fragment_index]));\r\nset_wqe_64bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_FRAG0_LOW_IDX+(2*wqe_fragment_index),\r\nbus_address);\r\nwqe_fragment_index++;\r\nif (wqe_fragment_index < 5)\r\nwqe_fragment_length[wqe_fragment_index] = 0;\r\n}\r\n}\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_MISC_IDX, wqe_misc);\r\nnesnic->sq_head++;\r\nnesnic->sq_head &= nesnic->sq_size - 1;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int nes_netdev_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_nic *nesnic = &nesvnic->nic;\r\nstruct nes_hw_nic_sq_wqe *nic_sqe;\r\nstruct tcphdr *tcph;\r\n#define NES_MAX_TSO_FRAGS MAX_SKB_FRAGS\r\ndma_addr_t tso_bus_address[NES_MAX_TSO_FRAGS];\r\ndma_addr_t bus_address;\r\nu32 tso_frag_index;\r\nu32 tso_frag_count;\r\nu32 tso_wqe_length;\r\nu32 curr_tcp_seq;\r\nu32 wqe_count=1;\r\nu32 send_rc;\r\nstruct iphdr *iph;\r\n__le16 *wqe_fragment_length;\r\nu32 nr_frags;\r\nu32 original_first_length;\r\nu16 wqe_fragment_index=1;\r\nu16 hoffset;\r\nu16 nhoffset;\r\nu16 wqes_needed;\r\nu16 wqes_available;\r\nu32 wqe_misc;\r\nif (!netif_carrier_ok(netdev))\r\nreturn NETDEV_TX_OK;\r\nif (netif_queue_stopped(netdev))\r\nreturn NETDEV_TX_BUSY;\r\nif ((((nesnic->sq_tail+(nesnic->sq_size*2))-nesnic->sq_head) & (nesnic->sq_size - 1)) == 1) {\r\nif (!netif_queue_stopped(netdev)) {\r\nnetif_stop_queue(netdev);\r\nbarrier();\r\nif ((((((volatile u16)nesnic->sq_tail)+(nesnic->sq_size*2))-nesnic->sq_head) & (nesnic->sq_size - 1)) != 1) {\r\nnetif_start_queue(netdev);\r\ngoto sq_no_longer_full;\r\n}\r\n}\r\nnesvnic->sq_full++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nsq_no_longer_full:\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nif (skb_headlen(skb) > NES_FIRST_FRAG_SIZE) {\r\nnr_frags++;\r\n}\r\nif (unlikely((nr_frags > 4))) {\r\nif (skb_is_gso(skb)) {\r\nnesvnic->segmented_tso_requests++;\r\nnesvnic->tso_requests++;\r\nwqes_needed = nr_frags >> 2;\r\nwqes_needed += (nr_frags&3)?1:0;\r\nwqes_available = (((nesnic->sq_tail+nesnic->sq_size)-nesnic->sq_head) - 1) &\r\n(nesnic->sq_size - 1);\r\nif (unlikely(wqes_needed > wqes_available)) {\r\nif (!netif_queue_stopped(netdev)) {\r\nnetif_stop_queue(netdev);\r\nbarrier();\r\nwqes_available = (((((volatile u16)nesnic->sq_tail)+nesnic->sq_size)-nesnic->sq_head) - 1) &\r\n(nesnic->sq_size - 1);\r\nif (wqes_needed <= wqes_available) {\r\nnetif_start_queue(netdev);\r\ngoto tso_sq_no_longer_full;\r\n}\r\n}\r\nnesvnic->sq_full++;\r\nnes_debug(NES_DBG_NIC_TX, "%s: HNIC SQ full- TSO request has too many frags!\n",\r\nnetdev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntso_sq_no_longer_full:\r\nfor (tso_frag_count=0; tso_frag_count < skb_shinfo(skb)->nr_frags;\r\ntso_frag_count++) {\r\nskb_frag_t *frag =\r\n&skb_shinfo(skb)->frags[tso_frag_count];\r\ntso_bus_address[tso_frag_count] =\r\nskb_frag_dma_map(&nesdev->pcidev->dev,\r\nfrag, 0, skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\n}\r\ntso_frag_index = 0;\r\ncurr_tcp_seq = ntohl(tcp_hdr(skb)->seq);\r\nhoffset = skb_transport_header(skb) - skb->data;\r\nnhoffset = skb_network_header(skb) - skb->data;\r\noriginal_first_length = hoffset + ((((struct tcphdr *)skb_transport_header(skb))->doff)<<2);\r\nfor (wqe_count=0; wqe_count<((u32)wqes_needed); wqe_count++) {\r\ntso_wqe_length = 0;\r\nnic_sqe = &nesnic->sq_vbase[nesnic->sq_head];\r\nwqe_fragment_length =\r\n(__le16 *)&nic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_0_TAG_IDX];\r\nif (skb_vlan_tag_present(skb)) {\r\nnes_debug(NES_DBG_NIC_TX, "%s: VLAN packet to send... VLAN = %08X\n",\r\nnetdev->name,\r\nskb_vlan_tag_get(skb));\r\nwqe_misc = NES_NIC_SQ_WQE_TAGVALUE_ENABLE;\r\nwqe_fragment_length[0] = (__force __le16) skb_vlan_tag_get(skb);\r\n} else\r\nwqe_misc = 0;\r\nwqe_fragment_length++;\r\nif (original_first_length > NES_FIRST_FRAG_SIZE) {\r\nnes_debug(NES_DBG_NIC_TX, "ERROR: SKB header too big, headlen=%u, FIRST_FRAG_SIZE=%u\n",\r\noriginal_first_length, NES_FIRST_FRAG_SIZE);\r\nnes_debug(NES_DBG_NIC_TX, "%s Request to tx NIC packet length %u, headlen %u,"\r\n" (%u frags), is_gso = %u tso_size=%u\n",\r\nnetdev->name,\r\nskb->len, skb_headlen(skb),\r\nskb_shinfo(skb)->nr_frags, skb_is_gso(skb), skb_shinfo(skb)->gso_size);\r\n}\r\nmemcpy(&nesnic->first_frag_vbase[nesnic->sq_head].buffer,\r\nskb->data, min(((unsigned int)NES_FIRST_FRAG_SIZE),\r\noriginal_first_length));\r\niph = (struct iphdr *)\r\n(&nesnic->first_frag_vbase[nesnic->sq_head].buffer[nhoffset]);\r\ntcph = (struct tcphdr *)\r\n(&nesnic->first_frag_vbase[nesnic->sq_head].buffer[hoffset]);\r\nif ((wqe_count+1)!=(u32)wqes_needed) {\r\ntcph->fin = 0;\r\ntcph->psh = 0;\r\ntcph->rst = 0;\r\ntcph->urg = 0;\r\n}\r\nif (wqe_count) {\r\ntcph->syn = 0;\r\n}\r\ntcph->seq = htonl(curr_tcp_seq);\r\nwqe_fragment_length[0] = cpu_to_le16(min(((unsigned int)NES_FIRST_FRAG_SIZE),\r\noriginal_first_length));\r\nwqe_fragment_index = 1;\r\nif ((wqe_count==0) && (skb_headlen(skb) > original_first_length)) {\r\nset_bit(nesnic->sq_head, nesnic->first_frag_overflow);\r\nbus_address = pci_map_single(nesdev->pcidev, skb->data + original_first_length,\r\nskb_headlen(skb) - original_first_length, PCI_DMA_TODEVICE);\r\nwqe_fragment_length[wqe_fragment_index++] =\r\ncpu_to_le16(skb_headlen(skb) - original_first_length);\r\nwqe_fragment_length[wqe_fragment_index] = 0;\r\nset_wqe_64bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_FRAG1_LOW_IDX,\r\nbus_address);\r\ntso_wqe_length += skb_headlen(skb) -\r\noriginal_first_length;\r\n}\r\nwhile (wqe_fragment_index < 5) {\r\nwqe_fragment_length[wqe_fragment_index] =\r\ncpu_to_le16(skb_frag_size(&skb_shinfo(skb)->frags[tso_frag_index]));\r\nset_wqe_64bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_FRAG0_LOW_IDX+(2*wqe_fragment_index),\r\n(u64)tso_bus_address[tso_frag_index]);\r\nwqe_fragment_index++;\r\ntso_wqe_length += skb_frag_size(&skb_shinfo(skb)->frags[tso_frag_index++]);\r\nif (wqe_fragment_index < 5)\r\nwqe_fragment_length[wqe_fragment_index] = 0;\r\nif (tso_frag_index == tso_frag_count)\r\nbreak;\r\n}\r\nif ((wqe_count+1) == (u32)wqes_needed) {\r\nnesnic->tx_skb[nesnic->sq_head] = skb;\r\n} else {\r\nnesnic->tx_skb[nesnic->sq_head] = NULL;\r\n}\r\nwqe_misc |= NES_NIC_SQ_WQE_COMPLETION | (u16)skb_shinfo(skb)->gso_size;\r\nif ((tso_wqe_length + original_first_length) > skb_shinfo(skb)->gso_size) {\r\nwqe_misc |= NES_NIC_SQ_WQE_LSO_ENABLE;\r\n} else {\r\niph->tot_len = htons(tso_wqe_length + original_first_length - nhoffset);\r\n}\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_MISC_IDX,\r\nwqe_misc);\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_LSO_INFO_IDX,\r\n((u32)tcph->doff) | (((u32)hoffset) << 4));\r\nset_wqe_32bit_value(nic_sqe->wqe_words, NES_NIC_SQ_WQE_TOTAL_LENGTH_IDX,\r\ntso_wqe_length + original_first_length);\r\ncurr_tcp_seq += tso_wqe_length;\r\nnesnic->sq_head++;\r\nnesnic->sq_head &= nesnic->sq_size-1;\r\n}\r\n} else {\r\nnesvnic->linearized_skbs++;\r\nhoffset = skb_transport_header(skb) - skb->data;\r\nnhoffset = skb_network_header(skb) - skb->data;\r\nskb_linearize(skb);\r\nskb_set_transport_header(skb, hoffset);\r\nskb_set_network_header(skb, nhoffset);\r\nsend_rc = nes_nic_send(skb, netdev);\r\nif (send_rc != NETDEV_TX_OK)\r\nreturn NETDEV_TX_OK;\r\n}\r\n} else {\r\nsend_rc = nes_nic_send(skb, netdev);\r\nif (send_rc != NETDEV_TX_OK)\r\nreturn NETDEV_TX_OK;\r\n}\r\nbarrier();\r\nif (wqe_count)\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC,\r\n(wqe_count << 24) | (1 << 23) | nesvnic->nic.qp_id);\r\nnetdev->trans_start = jiffies;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *nes_netdev_get_stats(struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu64 u64temp;\r\nu32 u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_DISCARD + (nesvnic->nic_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->endnode_nstat_rx_discard += u32temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_OCTETS_LO + (nesvnic->nic_index*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_OCTETS_HI + (nesvnic->nic_index*0x200))) << 32;\r\nnesvnic->endnode_nstat_rx_octets += u64temp;\r\nnesvnic->netstats.rx_bytes += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_FRAMES_LO + (nesvnic->nic_index*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_FRAMES_HI + (nesvnic->nic_index*0x200))) << 32;\r\nnesvnic->endnode_nstat_rx_frames += u64temp;\r\nnesvnic->netstats.rx_packets += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_OCTETS_LO + (nesvnic->nic_index*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_OCTETS_HI + (nesvnic->nic_index*0x200))) << 32;\r\nnesvnic->endnode_nstat_tx_octets += u64temp;\r\nnesvnic->netstats.tx_bytes += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_FRAMES_LO + (nesvnic->nic_index*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_FRAMES_HI + (nesvnic->nic_index*0x200))) << 32;\r\nnesvnic->endnode_nstat_tx_frames += u64temp;\r\nnesvnic->netstats.tx_packets += u64temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_SHORT_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_short_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_OVERSIZED_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_oversized_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_JABBER_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_jabber_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_SYMBOL_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_symbol_err_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_LENGTH_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_length_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_CRC_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_crc_errors += u32temp;\r\nnesvnic->netstats.rx_crc_errors += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_TX_ERRORS + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_tx_errors += u32temp;\r\nnesvnic->netstats.tx_errors += u32temp;\r\nreturn &nesvnic->netstats;\r\n}\r\nstatic void nes_netdev_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nif (netif_msg_timer(nesvnic))\r\nnes_debug(NES_DBG_NIC_TX, "%s: tx timeout\n", netdev->name);\r\n}\r\nstatic int nes_netdev_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct sockaddr *mac_addr = p;\r\nint i;\r\nu32 macaddr_low;\r\nu16 macaddr_high;\r\nif (!is_valid_ether_addr(mac_addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(netdev->dev_addr, mac_addr->sa_data, netdev->addr_len);\r\nprintk(PFX "%s: Address length = %d, Address = %pM\n",\r\n__func__, netdev->addr_len, mac_addr->sa_data);\r\nmacaddr_high = ((u16)netdev->dev_addr[0]) << 8;\r\nmacaddr_high += (u16)netdev->dev_addr[1];\r\nmacaddr_low = ((u32)netdev->dev_addr[2]) << 24;\r\nmacaddr_low += ((u32)netdev->dev_addr[3]) << 16;\r\nmacaddr_low += ((u32)netdev->dev_addr[4]) << 8;\r\nmacaddr_low += (u32)netdev->dev_addr[5];\r\nfor (i = 0; i < NES_MAX_PORT_COUNT; i++) {\r\nif (nesvnic->qp_nic_index[i] == 0xf) {\r\nbreak;\r\n}\r\nnes_write_indexed(nesdev,\r\nNES_IDX_PERFECT_FILTER_LOW + (nesvnic->qp_nic_index[i] * 8),\r\nmacaddr_low);\r\nnes_write_indexed(nesdev,\r\nNES_IDX_PERFECT_FILTER_HIGH + (nesvnic->qp_nic_index[i] * 8),\r\n(u32)macaddr_high | NES_MAC_ADDR_VALID |\r\n((((u32)nesvnic->nic_index) << 16)));\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_allmulti(struct nes_device *nesdev, u32 nic_active_bit)\r\n{\r\nu32 nic_active;\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL);\r\nnic_active &= ~nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);\r\n}\r\nstatic void nes_netdev_set_multicast_list(struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesvnic->nesdev->nesadapter;\r\nu32 nic_active_bit;\r\nu32 nic_active;\r\nu32 perfect_filter_register_address;\r\nu32 macaddr_low;\r\nu16 macaddr_high;\r\nu8 mc_all_on = 0;\r\nu8 mc_index;\r\nint mc_nic_index = -1;\r\nu8 pft_entries_preallocated = max(nesadapter->adapter_fcn_count *\r\nnics_per_function, 4);\r\nu8 max_pft_entries_avaiable = NES_PFT_SIZE - pft_entries_preallocated;\r\nunsigned long flags;\r\nint mc_count = netdev_mc_count(netdev);\r\nspin_lock_irqsave(&nesadapter->resource_lock, flags);\r\nnic_active_bit = 1 << nesvnic->nic_index;\r\nif (netdev->flags & IFF_PROMISC) {\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL);\r\nnic_active |= nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);\r\nmc_all_on = 1;\r\n} else if ((netdev->flags & IFF_ALLMULTI) ||\r\n(nesvnic->nic_index > 3)) {\r\nset_allmulti(nesdev, nic_active_bit);\r\nmc_all_on = 1;\r\n} else {\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL);\r\nnic_active &= ~nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL, nic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL);\r\nnic_active &= ~nic_active_bit;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);\r\n}\r\nnes_debug(NES_DBG_NIC_RX, "Number of MC entries = %d, Promiscuous = %d, All Multicast = %d.\n",\r\nmc_count, !!(netdev->flags & IFF_PROMISC),\r\n!!(netdev->flags & IFF_ALLMULTI));\r\nif (!mc_all_on) {\r\nchar *addrs;\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\naddrs = kmalloc(ETH_ALEN * mc_count, GFP_ATOMIC);\r\nif (!addrs) {\r\nset_allmulti(nesdev, nic_active_bit);\r\ngoto unlock;\r\n}\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nmemcpy(get_addr(addrs, i++), ha->addr, ETH_ALEN);\r\nperfect_filter_register_address = NES_IDX_PERFECT_FILTER_LOW +\r\npft_entries_preallocated * 0x8;\r\nfor (i = 0, mc_index = 0; mc_index < max_pft_entries_avaiable;\r\nmc_index++) {\r\nwhile (i < mc_count && nesvnic->mcrq_mcast_filter &&\r\n((mc_nic_index = nesvnic->mcrq_mcast_filter(nesvnic,\r\nget_addr(addrs, i++))) == 0));\r\nif (mc_nic_index < 0)\r\nmc_nic_index = nesvnic->nic_index;\r\nwhile (nesadapter->pft_mcast_map[mc_index] < 16 &&\r\nnesadapter->pft_mcast_map[mc_index] !=\r\nnesvnic->nic_index &&\r\nmc_index < max_pft_entries_avaiable) {\r\nnes_debug(NES_DBG_NIC_RX,\r\n"mc_index=%d skipping nic_index=%d, "\r\n"used for=%d \n", mc_index,\r\nnesvnic->nic_index,\r\nnesadapter->pft_mcast_map[mc_index]);\r\nmc_index++;\r\n}\r\nif (mc_index >= max_pft_entries_avaiable)\r\nbreak;\r\nif (i < mc_count) {\r\nchar *addr = get_addr(addrs, i++);\r\nnes_debug(NES_DBG_NIC_RX, "Assigning MC Address %pM to register 0x%04X nic_idx=%d\n",\r\naddr,\r\nperfect_filter_register_address+(mc_index * 8),\r\nmc_nic_index);\r\nmacaddr_high = ((u8) addr[0]) << 8;\r\nmacaddr_high += (u8) addr[1];\r\nmacaddr_low = ((u8) addr[2]) << 24;\r\nmacaddr_low += ((u8) addr[3]) << 16;\r\nmacaddr_low += ((u8) addr[4]) << 8;\r\nmacaddr_low += (u8) addr[5];\r\nnes_write_indexed(nesdev,\r\nperfect_filter_register_address+(mc_index * 8),\r\nmacaddr_low);\r\nnes_write_indexed(nesdev,\r\nperfect_filter_register_address+4+(mc_index * 8),\r\n(u32)macaddr_high | NES_MAC_ADDR_VALID |\r\n((((u32)(1<<mc_nic_index)) << 16)));\r\nnesadapter->pft_mcast_map[mc_index] =\r\nnesvnic->nic_index;\r\n} else {\r\nnes_debug(NES_DBG_NIC_RX, "Clearing MC Address at register 0x%04X\n",\r\nperfect_filter_register_address+(mc_index * 8));\r\nnes_write_indexed(nesdev,\r\nperfect_filter_register_address+4+(mc_index * 8),\r\n0);\r\nnesadapter->pft_mcast_map[mc_index] = 255;\r\n}\r\n}\r\nkfree(addrs);\r\nif (i < mc_count)\r\nset_allmulti(nesdev, nic_active_bit);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&nesadapter->resource_lock, flags);\r\n}\r\nstatic int nes_netdev_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nint ret = 0;\r\nu8 jumbomode = 0;\r\nu32 nic_active;\r\nu32 nic_active_bit;\r\nu32 uc_all_active;\r\nu32 mc_all_active;\r\nif ((new_mtu < ETH_ZLEN) || (new_mtu > max_mtu))\r\nreturn -EINVAL;\r\nnetdev->mtu = new_mtu;\r\nnesvnic->max_frame_size = new_mtu + VLAN_ETH_HLEN;\r\nif (netdev->mtu > 1500) {\r\njumbomode=1;\r\n}\r\nnes_nic_init_timer_defaults(nesdev, jumbomode);\r\nif (netif_running(netdev)) {\r\nnic_active_bit = 1 << nesvnic->nic_index;\r\nmc_all_active = nes_read_indexed(nesdev,\r\nNES_IDX_NIC_MULTICAST_ALL) & nic_active_bit;\r\nuc_all_active = nes_read_indexed(nesdev,\r\nNES_IDX_NIC_UNICAST_ALL) & nic_active_bit;\r\nnes_netdev_stop(netdev);\r\nnes_netdev_open(netdev);\r\nnic_active = nes_read_indexed(nesdev,\r\nNES_IDX_NIC_MULTICAST_ALL);\r\nnic_active |= mc_all_active;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_MULTICAST_ALL,\r\nnic_active);\r\nnic_active = nes_read_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL);\r\nnic_active |= uc_all_active;\r\nnes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nes_netdev_get_sset_count(struct net_device *netdev, int stringset)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nreturn NES_ETHTOOL_STAT_COUNT;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void nes_netdev_get_strings(struct net_device *netdev, u32 stringset,\r\nu8 *ethtool_strings)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nmemcpy(ethtool_strings,\r\n&nes_ethtool_stringset,\r\nsizeof(nes_ethtool_stringset));\r\n}\r\nstatic void nes_netdev_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *target_ethtool_stats, u64 *target_stat_values)\r\n{\r\nu64 u64temp;\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 nic_count;\r\nu32 u32temp;\r\nu32 index = 0;\r\ntarget_ethtool_stats->n_stats = NES_ETHTOOL_STAT_COUNT;\r\ntarget_stat_values[index] = nesvnic->nesdev->link_status_interrupts;\r\ntarget_stat_values[++index] = nesvnic->linearized_skbs;\r\ntarget_stat_values[++index] = nesvnic->tso_requests;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_TX_PAUSE_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_pause_frames_sent += u32temp;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_pause_frames_sent;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_PAUSE_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_pause_frames_received += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_PORT_RX_DISCARDS + (nesvnic->nesdev->mac_index*0x40));\r\nnesvnic->nesdev->port_rx_discards += u32temp;\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_PORT_TX_DISCARDS + (nesvnic->nesdev->mac_index*0x40));\r\nnesvnic->nesdev->port_tx_discards += u32temp;\r\nnesvnic->netstats.tx_dropped += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_SHORT_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_short_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_OVERSIZED_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_oversized_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_JABBER_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_jabber_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_SYMBOL_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_symbol_err_frames += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_LENGTH_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->netstats.rx_length_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_RX_CRC_ERR_FRAMES + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_rx_errors += u32temp;\r\nnesvnic->nesdev->mac_rx_crc_errors += u32temp;\r\nnesvnic->netstats.rx_crc_errors += u32temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_TX_ERRORS + (nesvnic->nesdev->mac_index*0x200));\r\nnesvnic->nesdev->mac_tx_errors += u32temp;\r\nnesvnic->netstats.tx_errors += u32temp;\r\nfor (nic_count = 0; nic_count < NES_MAX_PORT_COUNT; nic_count++) {\r\nif (nesvnic->qp_nic_index[nic_count] == 0xf)\r\nbreak;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_DISCARD +\r\n(nesvnic->qp_nic_index[nic_count]*0x200));\r\nnesvnic->netstats.rx_dropped += u32temp;\r\nnesvnic->endnode_nstat_rx_discard += u32temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_OCTETS_LO +\r\n(nesvnic->qp_nic_index[nic_count]*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_OCTETS_HI +\r\n(nesvnic->qp_nic_index[nic_count]*0x200))) << 32;\r\nnesvnic->endnode_nstat_rx_octets += u64temp;\r\nnesvnic->netstats.rx_bytes += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_FRAMES_LO +\r\n(nesvnic->qp_nic_index[nic_count]*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_RX_FRAMES_HI +\r\n(nesvnic->qp_nic_index[nic_count]*0x200))) << 32;\r\nnesvnic->endnode_nstat_rx_frames += u64temp;\r\nnesvnic->netstats.rx_packets += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_OCTETS_LO +\r\n(nesvnic->qp_nic_index[nic_count]*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_OCTETS_HI +\r\n(nesvnic->qp_nic_index[nic_count]*0x200))) << 32;\r\nnesvnic->endnode_nstat_tx_octets += u64temp;\r\nnesvnic->netstats.tx_bytes += u64temp;\r\nu64temp = (u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_FRAMES_LO +\r\n(nesvnic->qp_nic_index[nic_count]*0x200));\r\nu64temp += ((u64)nes_read_indexed(nesdev,\r\nNES_IDX_ENDNODE0_NSTAT_TX_FRAMES_HI +\r\n(nesvnic->qp_nic_index[nic_count]*0x200))) << 32;\r\nnesvnic->endnode_nstat_tx_frames += u64temp;\r\nnesvnic->netstats.tx_packets += u64temp;\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_IPV4_TCP_REXMITS + (nesvnic->qp_nic_index[nic_count]*0x200));\r\nnesvnic->endnode_ipv4_tcp_retransmits += u32temp;\r\n}\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_pause_frames_received;\r\ntarget_stat_values[++index] = nesdev->nesadapter->nic_rx_eth_route_err;\r\ntarget_stat_values[++index] = nesvnic->tx_sw_dropped;\r\ntarget_stat_values[++index] = nesvnic->sq_full;\r\ntarget_stat_values[++index] = nesvnic->segmented_tso_requests;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_rx_symbol_err_frames;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_rx_jabber_frames;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_rx_oversized_frames;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_rx_short_frames;\r\ntarget_stat_values[++index] = nesvnic->netstats.rx_length_errors;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_rx_crc_errors;\r\ntarget_stat_values[++index] = nesvnic->nesdev->port_rx_discards;\r\ntarget_stat_values[++index] = nesvnic->endnode_nstat_rx_discard;\r\ntarget_stat_values[++index] = nesvnic->endnode_nstat_rx_octets;\r\ntarget_stat_values[++index] = nesvnic->endnode_nstat_rx_frames;\r\ntarget_stat_values[++index] = nesvnic->endnode_nstat_tx_octets;\r\ntarget_stat_values[++index] = nesvnic->endnode_nstat_tx_frames;\r\ntarget_stat_values[++index] = nesvnic->nesdev->mac_tx_errors;\r\ntarget_stat_values[++index] = mh_detected;\r\ntarget_stat_values[++index] = mh_pauses_sent;\r\ntarget_stat_values[++index] = nesvnic->endnode_ipv4_tcp_retransmits;\r\ntarget_stat_values[++index] = atomic_read(&cm_connects);\r\ntarget_stat_values[++index] = atomic_read(&cm_accepts);\r\ntarget_stat_values[++index] = atomic_read(&cm_disconnects);\r\ntarget_stat_values[++index] = atomic_read(&cm_connecteds);\r\ntarget_stat_values[++index] = atomic_read(&cm_connect_reqs);\r\ntarget_stat_values[++index] = atomic_read(&cm_rejects);\r\ntarget_stat_values[++index] = atomic_read(&mod_qp_timouts);\r\ntarget_stat_values[++index] = atomic_read(&qps_created);\r\ntarget_stat_values[++index] = atomic_read(&sw_qps_destroyed);\r\ntarget_stat_values[++index] = atomic_read(&qps_destroyed);\r\ntarget_stat_values[++index] = atomic_read(&cm_closes);\r\ntarget_stat_values[++index] = cm_packets_sent;\r\ntarget_stat_values[++index] = cm_packets_bounced;\r\ntarget_stat_values[++index] = cm_packets_created;\r\ntarget_stat_values[++index] = cm_packets_received;\r\ntarget_stat_values[++index] = cm_packets_dropped;\r\ntarget_stat_values[++index] = cm_packets_retrans;\r\ntarget_stat_values[++index] = atomic_read(&cm_listens_created);\r\ntarget_stat_values[++index] = atomic_read(&cm_listens_destroyed);\r\ntarget_stat_values[++index] = cm_backlog_drops;\r\ntarget_stat_values[++index] = atomic_read(&cm_loopbacks);\r\ntarget_stat_values[++index] = atomic_read(&cm_nodes_created);\r\ntarget_stat_values[++index] = atomic_read(&cm_nodes_destroyed);\r\ntarget_stat_values[++index] = atomic_read(&cm_accel_dropped_pkts);\r\ntarget_stat_values[++index] = atomic_read(&cm_resets_recvd);\r\ntarget_stat_values[++index] = nesadapter->free_4kpbl;\r\ntarget_stat_values[++index] = nesadapter->free_256pbl;\r\ntarget_stat_values[++index] = int_mod_timer_init;\r\ntarget_stat_values[++index] = nesvnic->lro_mgr.stats.aggregated;\r\ntarget_stat_values[++index] = nesvnic->lro_mgr.stats.flushed;\r\ntarget_stat_values[++index] = nesvnic->lro_mgr.stats.no_desc;\r\ntarget_stat_values[++index] = atomic_read(&pau_qps_created);\r\ntarget_stat_values[++index] = atomic_read(&pau_qps_destroyed);\r\n}\r\nstatic void nes_netdev_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_adapter *nesadapter = nesvnic->nesdev->nesadapter;\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->bus_info, pci_name(nesvnic->nesdev->pcidev),\r\nsizeof(drvinfo->bus_info));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%u.%u", nesadapter->firmware_version >> 16,\r\nnesadapter->firmware_version & 0x000000ff);\r\nstrlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\r\ndrvinfo->testinfo_len = 0;\r\ndrvinfo->eedump_len = 0;\r\ndrvinfo->regdump_len = 0;\r\n}\r\nstatic int nes_netdev_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *et_coalesce)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);\r\nif (et_coalesce->rx_max_coalesced_frames_low) {\r\nshared_timer->threshold_low = et_coalesce->rx_max_coalesced_frames_low;\r\n}\r\nif (et_coalesce->rx_max_coalesced_frames_irq) {\r\nshared_timer->threshold_target = et_coalesce->rx_max_coalesced_frames_irq;\r\n}\r\nif (et_coalesce->rx_max_coalesced_frames_high) {\r\nshared_timer->threshold_high = et_coalesce->rx_max_coalesced_frames_high;\r\n}\r\nif (et_coalesce->rx_coalesce_usecs_low) {\r\nshared_timer->timer_in_use_min = et_coalesce->rx_coalesce_usecs_low;\r\n}\r\nif (et_coalesce->rx_coalesce_usecs_high) {\r\nshared_timer->timer_in_use_max = et_coalesce->rx_coalesce_usecs_high;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\nnesadapter->et_rx_coalesce_usecs_irq = et_coalesce->rx_coalesce_usecs_irq;\r\nif (et_coalesce->use_adaptive_rx_coalesce) {\r\nnesadapter->et_use_adaptive_rx_coalesce = 1;\r\nnesadapter->timer_int_limit = NES_TIMER_INT_LIMIT_DYNAMIC;\r\nnesadapter->et_rx_coalesce_usecs_irq = 0;\r\nif (et_coalesce->pkt_rate_low) {\r\nnesadapter->et_pkt_rate_low = et_coalesce->pkt_rate_low;\r\n}\r\n} else {\r\nnesadapter->et_use_adaptive_rx_coalesce = 0;\r\nnesadapter->timer_int_limit = NES_TIMER_INT_LIMIT;\r\nif (nesadapter->et_rx_coalesce_usecs_irq) {\r\nnes_write32(nesdev->regs+NES_PERIODIC_CONTROL,\r\n0x80000000 | ((u32)(nesadapter->et_rx_coalesce_usecs_irq*8)));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nes_netdev_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *et_coalesce)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct ethtool_coalesce temp_et_coalesce;\r\nstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;\r\nunsigned long flags;\r\nmemset(&temp_et_coalesce, 0, sizeof(temp_et_coalesce));\r\ntemp_et_coalesce.rx_coalesce_usecs_irq = nesadapter->et_rx_coalesce_usecs_irq;\r\ntemp_et_coalesce.use_adaptive_rx_coalesce = nesadapter->et_use_adaptive_rx_coalesce;\r\ntemp_et_coalesce.rate_sample_interval = nesadapter->et_rate_sample_interval;\r\ntemp_et_coalesce.pkt_rate_low = nesadapter->et_pkt_rate_low;\r\nspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);\r\ntemp_et_coalesce.rx_max_coalesced_frames_low = shared_timer->threshold_low;\r\ntemp_et_coalesce.rx_max_coalesced_frames_irq = shared_timer->threshold_target;\r\ntemp_et_coalesce.rx_max_coalesced_frames_high = shared_timer->threshold_high;\r\ntemp_et_coalesce.rx_coalesce_usecs_low = shared_timer->timer_in_use_min;\r\ntemp_et_coalesce.rx_coalesce_usecs_high = shared_timer->timer_in_use_max;\r\nif (nesadapter->et_use_adaptive_rx_coalesce) {\r\ntemp_et_coalesce.rx_coalesce_usecs_irq = shared_timer->timer_in_use;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\nmemcpy(et_coalesce, &temp_et_coalesce, sizeof(*et_coalesce));\r\nreturn 0;\r\n}\r\nstatic void nes_netdev_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *et_pauseparam)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\net_pauseparam->autoneg = 0;\r\net_pauseparam->rx_pause = (nesvnic->nesdev->disable_rx_flow_control == 0) ? 1:0;\r\net_pauseparam->tx_pause = (nesvnic->nesdev->disable_tx_flow_control == 0) ? 1:0;\r\n}\r\nstatic int nes_netdev_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *et_pauseparam)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu32 u32temp;\r\nif (et_pauseparam->autoneg) {\r\nreturn 0;\r\n}\r\nif ((et_pauseparam->tx_pause == 1) && (nesdev->disable_tx_flow_control == 1)) {\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_TX_CONFIG + (nesdev->mac_index*0x200));\r\nu32temp |= NES_IDX_MAC_TX_CONFIG_ENABLE_PAUSE;\r\nnes_write_indexed(nesdev,\r\nNES_IDX_MAC_TX_CONFIG + (nesdev->mac_index*0x200), u32temp);\r\nnesdev->disable_tx_flow_control = 0;\r\n} else if ((et_pauseparam->tx_pause == 0) && (nesdev->disable_tx_flow_control == 0)) {\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MAC_TX_CONFIG + (nesdev->mac_index*0x200));\r\nu32temp &= ~NES_IDX_MAC_TX_CONFIG_ENABLE_PAUSE;\r\nnes_write_indexed(nesdev,\r\nNES_IDX_MAC_TX_CONFIG + (nesdev->mac_index*0x200), u32temp);\r\nnesdev->disable_tx_flow_control = 1;\r\n}\r\nif ((et_pauseparam->rx_pause == 1) && (nesdev->disable_rx_flow_control == 1)) {\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MPP_DEBUG + (nesdev->mac_index*0x40));\r\nu32temp &= ~NES_IDX_MPP_DEBUG_PORT_DISABLE_PAUSE;\r\nnes_write_indexed(nesdev,\r\nNES_IDX_MPP_DEBUG + (nesdev->mac_index*0x40), u32temp);\r\nnesdev->disable_rx_flow_control = 0;\r\n} else if ((et_pauseparam->rx_pause == 0) && (nesdev->disable_rx_flow_control == 0)) {\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_MPP_DEBUG + (nesdev->mac_index*0x40));\r\nu32temp |= NES_IDX_MPP_DEBUG_PORT_DISABLE_PAUSE;\r\nnes_write_indexed(nesdev,\r\nNES_IDX_MPP_DEBUG + (nesdev->mac_index*0x40), u32temp);\r\nnesdev->disable_rx_flow_control = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nes_netdev_get_settings(struct net_device *netdev, struct ethtool_cmd *et_cmd)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 mac_index = nesdev->mac_index;\r\nu8 phy_type = nesadapter->phy_type[mac_index];\r\nu8 phy_index = nesadapter->phy_index[mac_index];\r\nu16 phy_data;\r\net_cmd->duplex = DUPLEX_FULL;\r\net_cmd->port = PORT_MII;\r\net_cmd->maxtxpkt = 511;\r\net_cmd->maxrxpkt = 511;\r\nif (nesadapter->OneG_Mode) {\r\nethtool_cmd_speed_set(et_cmd, SPEED_1000);\r\nif (phy_type == NES_PHY_TYPE_PUMA_1G) {\r\net_cmd->supported = SUPPORTED_1000baseT_Full;\r\net_cmd->advertising = ADVERTISED_1000baseT_Full;\r\net_cmd->autoneg = AUTONEG_DISABLE;\r\net_cmd->transceiver = XCVR_INTERNAL;\r\net_cmd->phy_address = mac_index;\r\n} else {\r\nunsigned long flags;\r\net_cmd->supported = SUPPORTED_1000baseT_Full\r\n| SUPPORTED_Autoneg;\r\net_cmd->advertising = ADVERTISED_1000baseT_Full\r\n| ADVERTISED_Autoneg;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nnes_read_1G_phy_reg(nesdev, 0, phy_index, &phy_data);\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\nif (phy_data & 0x1000)\r\net_cmd->autoneg = AUTONEG_ENABLE;\r\nelse\r\net_cmd->autoneg = AUTONEG_DISABLE;\r\net_cmd->transceiver = XCVR_EXTERNAL;\r\net_cmd->phy_address = phy_index;\r\n}\r\nreturn 0;\r\n}\r\nif ((phy_type == NES_PHY_TYPE_ARGUS) ||\r\n(phy_type == NES_PHY_TYPE_SFP_D) ||\r\n(phy_type == NES_PHY_TYPE_KR)) {\r\net_cmd->transceiver = XCVR_EXTERNAL;\r\net_cmd->port = PORT_FIBRE;\r\net_cmd->supported = SUPPORTED_FIBRE;\r\net_cmd->advertising = ADVERTISED_FIBRE;\r\net_cmd->phy_address = phy_index;\r\n} else {\r\net_cmd->transceiver = XCVR_INTERNAL;\r\net_cmd->supported = SUPPORTED_10000baseT_Full;\r\net_cmd->advertising = ADVERTISED_10000baseT_Full;\r\net_cmd->phy_address = mac_index;\r\n}\r\nethtool_cmd_speed_set(et_cmd, SPEED_10000);\r\net_cmd->autoneg = AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int nes_netdev_set_settings(struct net_device *netdev, struct ethtool_cmd *et_cmd)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nif ((nesadapter->OneG_Mode) &&\r\n(nesadapter->phy_type[nesdev->mac_index] != NES_PHY_TYPE_PUMA_1G)) {\r\nunsigned long flags;\r\nu16 phy_data;\r\nu8 phy_index = nesadapter->phy_index[nesdev->mac_index];\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nnes_read_1G_phy_reg(nesdev, 0, phy_index, &phy_data);\r\nif (et_cmd->autoneg) {\r\nphy_data |= 0x1300;\r\n} else {\r\nphy_data &= ~0x1000;\r\n}\r\nnes_write_1G_phy_reg(nesdev, 0, phy_index, phy_data);\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nes_vlan_mode(struct net_device *netdev, struct nes_device *nesdev, netdev_features_t features)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 u32temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nnes_debug(NES_DBG_NETDEV, "%s: %s\n", __func__, netdev->name);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_PCIX_DIAG);\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nu32temp &= 0xfdffffff;\r\nelse\r\nu32temp |= 0x02000000;\r\nnes_write_indexed(nesdev, NES_IDX_PCIX_DIAG, u32temp);\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\n}\r\nstatic netdev_features_t nes_fix_features(struct net_device *netdev, netdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nreturn features;\r\n}\r\nstatic int nes_set_features(struct net_device *netdev, netdev_features_t features)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu32 changed = netdev->features ^ features;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\nnes_vlan_mode(netdev, nesdev, features);\r\nreturn 0;\r\n}\r\nstruct net_device *nes_netdev_init(struct nes_device *nesdev,\r\nvoid __iomem *mmio_addr)\r\n{\r\nu64 u64temp;\r\nstruct nes_vnic *nesvnic;\r\nstruct net_device *netdev;\r\nstruct nic_qp_map *curr_qp_map;\r\nu8 phy_type = nesdev->nesadapter->phy_type[nesdev->mac_index];\r\nnetdev = alloc_etherdev(sizeof(struct nes_vnic));\r\nif (!netdev) {\r\nprintk(KERN_ERR PFX "nesvnic etherdev alloc failed");\r\nreturn NULL;\r\n}\r\nnesvnic = netdev_priv(netdev);\r\nnes_debug(NES_DBG_INIT, "netdev = %p, %s\n", netdev, netdev->name);\r\nSET_NETDEV_DEV(netdev, &nesdev->pcidev->dev);\r\nnetdev->watchdog_timeo = NES_TX_TIMEOUT;\r\nnetdev->irq = nesdev->pcidev->irq;\r\nnetdev->mtu = ETH_DATA_LEN;\r\nnetdev->hard_header_len = ETH_HLEN;\r\nnetdev->addr_len = ETH_ALEN;\r\nnetdev->type = ARPHRD_ETHER;\r\nnetdev->netdev_ops = &nes_netdev_ops;\r\nnetdev->ethtool_ops = &nes_ethtool_ops;\r\nnetif_napi_add(netdev, &nesvnic->napi, nes_netdev_poll, 128);\r\nnes_debug(NES_DBG_INIT, "Enabling VLAN Insert/Delete.\n");\r\nnesvnic->netdev = netdev;\r\nnesvnic->nesdev = nesdev;\r\nnesvnic->msg_enable = netif_msg_init(debug, default_msg);\r\nnesvnic->netdev_index = nesdev->netdev_count;\r\nnesvnic->perfect_filter_index = nesdev->nesadapter->netdev_count;\r\nnesvnic->max_frame_size = netdev->mtu + netdev->hard_header_len + VLAN_HLEN;\r\ncurr_qp_map = nic_qp_mapping_per_function[PCI_FUNC(nesdev->pcidev->devfn)];\r\nnesvnic->nic.qp_id = curr_qp_map[nesdev->netdev_count].qpid;\r\nnesvnic->nic_index = curr_qp_map[nesdev->netdev_count].nic_index;\r\nnesvnic->logical_port = curr_qp_map[nesdev->netdev_count].logical_port;\r\nu64temp = (u64)nesdev->nesadapter->mac_addr_low;\r\nu64temp += ((u64)nesdev->nesadapter->mac_addr_high) << 32;\r\nu64temp += nesvnic->nic_index;\r\nnetdev->dev_addr[0] = (u8)(u64temp>>40);\r\nnetdev->dev_addr[1] = (u8)(u64temp>>32);\r\nnetdev->dev_addr[2] = (u8)(u64temp>>24);\r\nnetdev->dev_addr[3] = (u8)(u64temp>>16);\r\nnetdev->dev_addr[4] = (u8)(u64temp>>8);\r\nnetdev->dev_addr[5] = (u8)u64temp;\r\nnetdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_RX;\r\nif ((nesvnic->logical_port < 2) || (nesdev->nesadapter->hw_rev != NE020_REV))\r\nnetdev->hw_features |= NETIF_F_TSO;\r\nnetdev->features = netdev->hw_features | NETIF_F_HIGHDMA | NETIF_F_HW_VLAN_CTAG_TX;\r\nnetdev->hw_features |= NETIF_F_LRO;\r\nnes_debug(NES_DBG_INIT, "nesvnic = %p, reported features = 0x%lX, QPid = %d,"\r\n" nic_index = %d, logical_port = %d, mac_index = %d.\n",\r\nnesvnic, (unsigned long)netdev->features, nesvnic->nic.qp_id,\r\nnesvnic->nic_index, nesvnic->logical_port, nesdev->mac_index);\r\nif (nesvnic->nesdev->nesadapter->port_count == 1 &&\r\nnesvnic->nesdev->nesadapter->adapter_fcn_count == 1) {\r\nnesvnic->qp_nic_index[0] = nesvnic->nic_index;\r\nnesvnic->qp_nic_index[1] = nesvnic->nic_index + 1;\r\nif (nes_drv_opt & NES_DRV_OPT_DUAL_LOGICAL_PORT) {\r\nnesvnic->qp_nic_index[2] = 0xf;\r\nnesvnic->qp_nic_index[3] = 0xf;\r\n} else {\r\nnesvnic->qp_nic_index[2] = nesvnic->nic_index + 2;\r\nnesvnic->qp_nic_index[3] = nesvnic->nic_index + 3;\r\n}\r\n} else {\r\nif (nesvnic->nesdev->nesadapter->port_count == 2 ||\r\n(nesvnic->nesdev->nesadapter->port_count == 1 &&\r\nnesvnic->nesdev->nesadapter->adapter_fcn_count == 2)) {\r\nnesvnic->qp_nic_index[0] = nesvnic->nic_index;\r\nnesvnic->qp_nic_index[1] = nesvnic->nic_index\r\n+ 2;\r\nnesvnic->qp_nic_index[2] = 0xf;\r\nnesvnic->qp_nic_index[3] = 0xf;\r\n} else {\r\nnesvnic->qp_nic_index[0] = nesvnic->nic_index;\r\nnesvnic->qp_nic_index[1] = 0xf;\r\nnesvnic->qp_nic_index[2] = 0xf;\r\nnesvnic->qp_nic_index[3] = 0xf;\r\n}\r\n}\r\nnesvnic->next_qp_nic_index = 0;\r\nif (nesdev->netdev_count == 0) {\r\nnesvnic->rdma_enabled = 1;\r\n} else {\r\nnesvnic->rdma_enabled = 0;\r\n}\r\nnesvnic->nic_cq.cq_number = nesvnic->nic.qp_id;\r\ninit_timer(&nesvnic->event_timer);\r\nnesvnic->event_timer.function = NULL;\r\nspin_lock_init(&nesvnic->tx_lock);\r\nspin_lock_init(&nesvnic->port_ibevent_lock);\r\nnesdev->netdev[nesdev->netdev_count] = netdev;\r\nnes_debug(NES_DBG_INIT, "Adding nesvnic (%p) to the adapters nesvnic_list for MAC%d.\n",\r\nnesvnic, nesdev->mac_index);\r\nlist_add_tail(&nesvnic->list, &nesdev->nesadapter->nesvnic_list[nesdev->mac_index]);\r\nif ((nesdev->netdev_count == 0) &&\r\n((PCI_FUNC(nesdev->pcidev->devfn) == nesdev->mac_index) ||\r\n((phy_type == NES_PHY_TYPE_PUMA_1G) &&\r\n(((PCI_FUNC(nesdev->pcidev->devfn) == 1) && (nesdev->mac_index == 2)) ||\r\n((PCI_FUNC(nesdev->pcidev->devfn) == 2) && (nesdev->mac_index == 1)))))) {\r\nu32 u32temp;\r\nu32 link_mask = 0;\r\nu32 link_val = 0;\r\nu16 temp_phy_data;\r\nu16 phy_data = 0;\r\nunsigned long flags;\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0 +\r\n(0x200 * (nesdev->mac_index & 1)));\r\nif (phy_type != NES_PHY_TYPE_PUMA_1G) {\r\nu32temp |= 0x00200000;\r\nnes_write_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0 +\r\n(0x200 * (nesdev->mac_index & 1)), u32temp);\r\n}\r\nswitch (phy_type) {\r\ncase NES_PHY_TYPE_PUMA_1G:\r\nif (nesdev->mac_index < 2) {\r\nlink_mask = 0x01010000;\r\nlink_val = 0x01010000;\r\n} else {\r\nlink_mask = 0x02020000;\r\nlink_val = 0x02020000;\r\n}\r\nbreak;\r\ncase NES_PHY_TYPE_SFP_D:\r\nspin_lock_irqsave(&nesdev->nesadapter->phy_lock, flags);\r\nnes_read_10G_phy_reg(nesdev,\r\nnesdev->nesadapter->phy_index[nesdev->mac_index],\r\n1, 0x9003);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev,\r\nnesdev->nesadapter->phy_index[nesdev->mac_index],\r\n3, 0x0021);\r\nnes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev,\r\nnesdev->nesadapter->phy_index[nesdev->mac_index],\r\n3, 0x0021);\r\nphy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nspin_unlock_irqrestore(&nesdev->nesadapter->phy_lock, flags);\r\nphy_data = (!temp_phy_data && (phy_data == 0x8000)) ? 0x4 : 0x0;\r\nbreak;\r\ndefault:\r\nlink_mask = 0x0f1f0000;\r\nlink_val = 0x0f0f0000;\r\nbreak;\r\n}\r\nu32temp = nes_read_indexed(nesdev,\r\nNES_IDX_PHY_PCS_CONTROL_STATUS0 +\r\n(0x200 * (nesdev->mac_index & 1)));\r\nif (phy_type == NES_PHY_TYPE_SFP_D) {\r\nif (phy_data & 0x0004)\r\nnesvnic->linkup = 1;\r\n} else {\r\nif ((u32temp & link_mask) == link_val)\r\nnesvnic->linkup = 1;\r\n}\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS + (0x200 * nesdev->mac_index));\r\nnes_debug(NES_DBG_INIT, "Phy interrupt status = 0x%X.\n", u32temp);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS + (0x200 * nesdev->mac_index), u32temp);\r\nnes_init_phy(nesdev);\r\n}\r\nnes_vlan_mode(netdev, nesdev, netdev->features);\r\nreturn netdev;\r\n}\r\nvoid nes_netdev_destroy(struct net_device *netdev)\r\n{\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nlist_del(&nesvnic->list);\r\nif (nesvnic->of_device_registered) {\r\nnes_destroy_ofa_device(nesvnic->nesibdev);\r\n}\r\nfree_netdev(netdev);\r\n}\r\nint nes_nic_cm_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nint ret;\r\nskb->dev = netdev;\r\nret = dev_queue_xmit(skb);\r\nif (ret) {\r\nnes_debug(NES_DBG_CM, "Bad return code from dev_queue_xmit %d\n", ret);\r\n}\r\nreturn ret;\r\n}
