static struct omap_mbox *mbox_chan_to_omap_mbox(struct mbox_chan *chan)\r\n{\r\nif (!chan || !chan->con_priv)\r\nreturn NULL;\r\nreturn (struct omap_mbox *)chan->con_priv;\r\n}\r\nstatic inline\r\nunsigned int mbox_read_reg(struct omap_mbox_device *mdev, size_t ofs)\r\n{\r\nreturn __raw_readl(mdev->mbox_base + ofs);\r\n}\r\nstatic inline\r\nvoid mbox_write_reg(struct omap_mbox_device *mdev, u32 val, size_t ofs)\r\n{\r\n__raw_writel(val, mdev->mbox_base + ofs);\r\n}\r\nstatic mbox_msg_t mbox_fifo_read(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox_fifo *fifo = &mbox->rx_fifo;\r\nreturn (mbox_msg_t) mbox_read_reg(mbox->parent, fifo->msg);\r\n}\r\nstatic void mbox_fifo_write(struct omap_mbox *mbox, mbox_msg_t msg)\r\n{\r\nstruct omap_mbox_fifo *fifo = &mbox->tx_fifo;\r\nmbox_write_reg(mbox->parent, msg, fifo->msg);\r\n}\r\nstatic int mbox_fifo_empty(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox_fifo *fifo = &mbox->rx_fifo;\r\nreturn (mbox_read_reg(mbox->parent, fifo->msg_stat) == 0);\r\n}\r\nstatic int mbox_fifo_full(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox_fifo *fifo = &mbox->tx_fifo;\r\nreturn mbox_read_reg(mbox->parent, fifo->fifo_stat);\r\n}\r\nstatic void ack_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\r\n&mbox->tx_fifo : &mbox->rx_fifo;\r\nu32 bit = fifo->intr_bit;\r\nu32 irqstatus = fifo->irqstatus;\r\nmbox_write_reg(mbox->parent, bit, irqstatus);\r\nmbox_read_reg(mbox->parent, irqstatus);\r\n}\r\nstatic int is_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\r\n&mbox->tx_fifo : &mbox->rx_fifo;\r\nu32 bit = fifo->intr_bit;\r\nu32 irqenable = fifo->irqenable;\r\nu32 irqstatus = fifo->irqstatus;\r\nu32 enable = mbox_read_reg(mbox->parent, irqenable);\r\nu32 status = mbox_read_reg(mbox->parent, irqstatus);\r\nreturn (int)(enable & status & bit);\r\n}\r\nvoid omap_mbox_save_ctx(struct mbox_chan *chan)\r\n{\r\nint i;\r\nint nr_regs;\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nif (WARN_ON(!mbox))\r\nreturn;\r\nif (mbox->intr_type)\r\nnr_regs = OMAP4_MBOX_NR_REGS;\r\nelse\r\nnr_regs = MBOX_NR_REGS;\r\nfor (i = 0; i < nr_regs; i++) {\r\nmbox->ctx[i] = mbox_read_reg(mbox->parent, i * sizeof(u32));\r\ndev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,\r\ni, mbox->ctx[i]);\r\n}\r\n}\r\nvoid omap_mbox_restore_ctx(struct mbox_chan *chan)\r\n{\r\nint i;\r\nint nr_regs;\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nif (WARN_ON(!mbox))\r\nreturn;\r\nif (mbox->intr_type)\r\nnr_regs = OMAP4_MBOX_NR_REGS;\r\nelse\r\nnr_regs = MBOX_NR_REGS;\r\nfor (i = 0; i < nr_regs; i++) {\r\nmbox_write_reg(mbox->parent, mbox->ctx[i], i * sizeof(u32));\r\ndev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,\r\ni, mbox->ctx[i]);\r\n}\r\n}\r\nstatic void _omap_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nu32 l;\r\nstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\r\n&mbox->tx_fifo : &mbox->rx_fifo;\r\nu32 bit = fifo->intr_bit;\r\nu32 irqenable = fifo->irqenable;\r\nl = mbox_read_reg(mbox->parent, irqenable);\r\nl |= bit;\r\nmbox_write_reg(mbox->parent, l, irqenable);\r\n}\r\nstatic void _omap_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox_fifo *fifo = (irq == IRQ_TX) ?\r\n&mbox->tx_fifo : &mbox->rx_fifo;\r\nu32 bit = fifo->intr_bit;\r\nu32 irqdisable = fifo->irqdisable;\r\nif (!mbox->intr_type)\r\nbit = mbox_read_reg(mbox->parent, irqdisable) & ~bit;\r\nmbox_write_reg(mbox->parent, bit, irqdisable);\r\n}\r\nvoid omap_mbox_enable_irq(struct mbox_chan *chan, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nif (WARN_ON(!mbox))\r\nreturn;\r\n_omap_mbox_enable_irq(mbox, irq);\r\n}\r\nvoid omap_mbox_disable_irq(struct mbox_chan *chan, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nif (WARN_ON(!mbox))\r\nreturn;\r\n_omap_mbox_disable_irq(mbox, irq);\r\n}\r\nstatic void mbox_rx_work(struct work_struct *work)\r\n{\r\nstruct omap_mbox_queue *mq =\r\ncontainer_of(work, struct omap_mbox_queue, work);\r\nmbox_msg_t msg;\r\nint len;\r\nwhile (kfifo_len(&mq->fifo) >= sizeof(msg)) {\r\nlen = kfifo_out(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\r\nWARN_ON(len != sizeof(msg));\r\nmbox_chan_received_data(mq->mbox->chan, (void *)msg);\r\nspin_lock_irq(&mq->lock);\r\nif (mq->full) {\r\nmq->full = false;\r\n_omap_mbox_enable_irq(mq->mbox, IRQ_RX);\r\n}\r\nspin_unlock_irq(&mq->lock);\r\n}\r\n}\r\nstatic void __mbox_tx_interrupt(struct omap_mbox *mbox)\r\n{\r\n_omap_mbox_disable_irq(mbox, IRQ_TX);\r\nack_mbox_irq(mbox, IRQ_TX);\r\nmbox_chan_txdone(mbox->chan, 0);\r\n}\r\nstatic void __mbox_rx_interrupt(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox_queue *mq = mbox->rxq;\r\nmbox_msg_t msg;\r\nint len;\r\nwhile (!mbox_fifo_empty(mbox)) {\r\nif (unlikely(kfifo_avail(&mq->fifo) < sizeof(msg))) {\r\n_omap_mbox_disable_irq(mbox, IRQ_RX);\r\nmq->full = true;\r\ngoto nomem;\r\n}\r\nmsg = mbox_fifo_read(mbox);\r\nlen = kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));\r\nWARN_ON(len != sizeof(msg));\r\n}\r\nack_mbox_irq(mbox, IRQ_RX);\r\nnomem:\r\nschedule_work(&mbox->rxq->work);\r\n}\r\nstatic irqreturn_t mbox_interrupt(int irq, void *p)\r\n{\r\nstruct omap_mbox *mbox = p;\r\nif (is_mbox_irq(mbox, IRQ_TX))\r\n__mbox_tx_interrupt(mbox);\r\nif (is_mbox_irq(mbox, IRQ_RX))\r\n__mbox_rx_interrupt(mbox);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct omap_mbox_queue *mbox_queue_alloc(struct omap_mbox *mbox,\r\nvoid (*work)(struct work_struct *))\r\n{\r\nstruct omap_mbox_queue *mq;\r\nif (!work)\r\nreturn NULL;\r\nmq = kzalloc(sizeof(struct omap_mbox_queue), GFP_KERNEL);\r\nif (!mq)\r\nreturn NULL;\r\nspin_lock_init(&mq->lock);\r\nif (kfifo_alloc(&mq->fifo, mbox_kfifo_size, GFP_KERNEL))\r\ngoto error;\r\nINIT_WORK(&mq->work, work);\r\nreturn mq;\r\nerror:\r\nkfree(mq);\r\nreturn NULL;\r\n}\r\nstatic void mbox_queue_free(struct omap_mbox_queue *q)\r\n{\r\nkfifo_free(&q->fifo);\r\nkfree(q);\r\n}\r\nstatic int omap_mbox_startup(struct omap_mbox *mbox)\r\n{\r\nint ret = 0;\r\nstruct omap_mbox_queue *mq;\r\nmq = mbox_queue_alloc(mbox, mbox_rx_work);\r\nif (!mq)\r\nreturn -ENOMEM;\r\nmbox->rxq = mq;\r\nmq->mbox = mbox;\r\nret = request_irq(mbox->irq, mbox_interrupt, IRQF_SHARED,\r\nmbox->name, mbox);\r\nif (unlikely(ret)) {\r\npr_err("failed to register mailbox interrupt:%d\n", ret);\r\ngoto fail_request_irq;\r\n}\r\n_omap_mbox_enable_irq(mbox, IRQ_RX);\r\nreturn 0;\r\nfail_request_irq:\r\nmbox_queue_free(mbox->rxq);\r\nreturn ret;\r\n}\r\nstatic void omap_mbox_fini(struct omap_mbox *mbox)\r\n{\r\n_omap_mbox_disable_irq(mbox, IRQ_RX);\r\nfree_irq(mbox->irq, mbox);\r\nflush_work(&mbox->rxq->work);\r\nmbox_queue_free(mbox->rxq);\r\n}\r\nstatic struct omap_mbox *omap_mbox_device_find(struct omap_mbox_device *mdev,\r\nconst char *mbox_name)\r\n{\r\nstruct omap_mbox *_mbox, *mbox = NULL;\r\nstruct omap_mbox **mboxes = mdev->mboxes;\r\nint i;\r\nif (!mboxes)\r\nreturn NULL;\r\nfor (i = 0; (_mbox = mboxes[i]); i++) {\r\nif (!strcmp(_mbox->name, mbox_name)) {\r\nmbox = _mbox;\r\nbreak;\r\n}\r\n}\r\nreturn mbox;\r\n}\r\nstruct mbox_chan *omap_mbox_request_channel(struct mbox_client *cl,\r\nconst char *chan_name)\r\n{\r\nstruct device *dev = cl->dev;\r\nstruct omap_mbox *mbox = NULL;\r\nstruct omap_mbox_device *mdev;\r\nstruct mbox_chan *chan;\r\nunsigned long flags;\r\nint ret;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (dev->of_node) {\r\npr_err("%s: please use mbox_request_channel(), this API is supported only for OMAP non-DT usage\n",\r\n__func__);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nmutex_lock(&omap_mbox_devices_lock);\r\nlist_for_each_entry(mdev, &omap_mbox_devices, elem) {\r\nmbox = omap_mbox_device_find(mdev, chan_name);\r\nif (mbox)\r\nbreak;\r\n}\r\nmutex_unlock(&omap_mbox_devices_lock);\r\nif (!mbox || !mbox->chan)\r\nreturn ERR_PTR(-ENOENT);\r\nchan = mbox->chan;\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->msg_free = 0;\r\nchan->msg_count = 0;\r\nchan->active_req = NULL;\r\nchan->cl = cl;\r\ninit_completion(&chan->tx_complete);\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nret = chan->mbox->ops->startup(chan);\r\nif (ret) {\r\npr_err("Unable to startup the chan (%d)\n", ret);\r\nmbox_free_channel(chan);\r\nchan = ERR_PTR(ret);\r\n}\r\nreturn chan;\r\n}\r\nstatic int omap_mbox_register(struct omap_mbox_device *mdev)\r\n{\r\nint ret;\r\nint i;\r\nstruct omap_mbox **mboxes;\r\nif (!mdev || !mdev->mboxes)\r\nreturn -EINVAL;\r\nmboxes = mdev->mboxes;\r\nfor (i = 0; mboxes[i]; i++) {\r\nstruct omap_mbox *mbox = mboxes[i];\r\nmbox->dev = device_create(&omap_mbox_class, mdev->dev,\r\n0, mbox, "%s", mbox->name);\r\nif (IS_ERR(mbox->dev)) {\r\nret = PTR_ERR(mbox->dev);\r\ngoto err_out;\r\n}\r\n}\r\nmutex_lock(&omap_mbox_devices_lock);\r\nlist_add(&mdev->elem, &omap_mbox_devices);\r\nmutex_unlock(&omap_mbox_devices_lock);\r\nret = mbox_controller_register(&mdev->controller);\r\nerr_out:\r\nif (ret) {\r\nwhile (i--)\r\ndevice_unregister(mboxes[i]->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_mbox_unregister(struct omap_mbox_device *mdev)\r\n{\r\nint i;\r\nstruct omap_mbox **mboxes;\r\nif (!mdev || !mdev->mboxes)\r\nreturn -EINVAL;\r\nmutex_lock(&omap_mbox_devices_lock);\r\nlist_del(&mdev->elem);\r\nmutex_unlock(&omap_mbox_devices_lock);\r\nmbox_controller_unregister(&mdev->controller);\r\nmboxes = mdev->mboxes;\r\nfor (i = 0; mboxes[i]; i++)\r\ndevice_unregister(mboxes[i]->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_mbox_chan_startup(struct mbox_chan *chan)\r\n{\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nstruct omap_mbox_device *mdev = mbox->parent;\r\nint ret = 0;\r\nmutex_lock(&mdev->cfg_lock);\r\npm_runtime_get_sync(mdev->dev);\r\nret = omap_mbox_startup(mbox);\r\nif (ret)\r\npm_runtime_put_sync(mdev->dev);\r\nmutex_unlock(&mdev->cfg_lock);\r\nreturn ret;\r\n}\r\nstatic void omap_mbox_chan_shutdown(struct mbox_chan *chan)\r\n{\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nstruct omap_mbox_device *mdev = mbox->parent;\r\nmutex_lock(&mdev->cfg_lock);\r\nomap_mbox_fini(mbox);\r\npm_runtime_put_sync(mdev->dev);\r\nmutex_unlock(&mdev->cfg_lock);\r\n}\r\nstatic int omap_mbox_chan_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct omap_mbox *mbox = mbox_chan_to_omap_mbox(chan);\r\nint ret = -EBUSY;\r\nif (!mbox)\r\nreturn -EINVAL;\r\nif (!mbox_fifo_full(mbox)) {\r\nmbox_fifo_write(mbox, (mbox_msg_t)data);\r\nret = 0;\r\n}\r\n_omap_mbox_enable_irq(mbox, IRQ_TX);\r\nreturn ret;\r\n}\r\nstatic struct mbox_chan *omap_mbox_of_xlate(struct mbox_controller *controller,\r\nconst struct of_phandle_args *sp)\r\n{\r\nphandle phandle = sp->args[0];\r\nstruct device_node *node;\r\nstruct omap_mbox_device *mdev;\r\nstruct omap_mbox *mbox;\r\nmdev = container_of(controller, struct omap_mbox_device, controller);\r\nif (WARN_ON(!mdev))\r\nreturn ERR_PTR(-EINVAL);\r\nnode = of_find_node_by_phandle(phandle);\r\nif (!node) {\r\npr_err("%s: could not find node phandle 0x%x\n",\r\n__func__, phandle);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nmbox = omap_mbox_device_find(mdev, node->name);\r\nof_node_put(node);\r\nreturn mbox ? mbox->chan : ERR_PTR(-ENOENT);\r\n}\r\nstatic int omap_mbox_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint ret;\r\nstruct mbox_chan *chnls;\r\nstruct omap_mbox **list, *mbox, *mboxblk;\r\nstruct omap_mbox_pdata *pdata = pdev->dev.platform_data;\r\nstruct omap_mbox_dev_info *info = NULL;\r\nstruct omap_mbox_fifo_info *finfo, *finfoblk;\r\nstruct omap_mbox_device *mdev;\r\nstruct omap_mbox_fifo *fifo;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *child;\r\nconst struct of_device_id *match;\r\nu32 intr_type, info_count;\r\nu32 num_users, num_fifos;\r\nu32 tmp[3];\r\nu32 l;\r\nint i;\r\nif (!node && (!pdata || !pdata->info_cnt || !pdata->info)) {\r\npr_err("%s: platform not supported\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (node) {\r\nmatch = of_match_device(omap_mailbox_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nintr_type = (u32)match->data;\r\nif (of_property_read_u32(node, "ti,mbox-num-users",\r\n&num_users))\r\nreturn -ENODEV;\r\nif (of_property_read_u32(node, "ti,mbox-num-fifos",\r\n&num_fifos))\r\nreturn -ENODEV;\r\ninfo_count = of_get_available_child_count(node);\r\nif (!info_count) {\r\ndev_err(&pdev->dev, "no available mbox devices found\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\ninfo_count = pdata->info_cnt;\r\ninfo = pdata->info;\r\nintr_type = pdata->intr_type;\r\nnum_users = pdata->num_users;\r\nnum_fifos = pdata->num_fifos;\r\n}\r\nfinfoblk = devm_kzalloc(&pdev->dev, info_count * sizeof(*finfoblk),\r\nGFP_KERNEL);\r\nif (!finfoblk)\r\nreturn -ENOMEM;\r\nfinfo = finfoblk;\r\nchild = NULL;\r\nfor (i = 0; i < info_count; i++, finfo++) {\r\nif (node) {\r\nchild = of_get_next_available_child(node, child);\r\nret = of_property_read_u32_array(child, "ti,mbox-tx",\r\ntmp, ARRAY_SIZE(tmp));\r\nif (ret)\r\nreturn ret;\r\nfinfo->tx_id = tmp[0];\r\nfinfo->tx_irq = tmp[1];\r\nfinfo->tx_usr = tmp[2];\r\nret = of_property_read_u32_array(child, "ti,mbox-rx",\r\ntmp, ARRAY_SIZE(tmp));\r\nif (ret)\r\nreturn ret;\r\nfinfo->rx_id = tmp[0];\r\nfinfo->rx_irq = tmp[1];\r\nfinfo->rx_usr = tmp[2];\r\nfinfo->name = child->name;\r\n} else {\r\nfinfo->tx_id = info->tx_id;\r\nfinfo->rx_id = info->rx_id;\r\nfinfo->tx_usr = info->usr_id;\r\nfinfo->tx_irq = info->irq_id;\r\nfinfo->rx_usr = info->usr_id;\r\nfinfo->rx_irq = info->irq_id;\r\nfinfo->name = info->name;\r\ninfo++;\r\n}\r\nif (finfo->tx_id >= num_fifos || finfo->rx_id >= num_fifos ||\r\nfinfo->tx_usr >= num_users || finfo->rx_usr >= num_users)\r\nreturn -EINVAL;\r\n}\r\nmdev = devm_kzalloc(&pdev->dev, sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmdev->mbox_base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(mdev->mbox_base))\r\nreturn PTR_ERR(mdev->mbox_base);\r\nlist = devm_kzalloc(&pdev->dev, (info_count + 1) * sizeof(*list),\r\nGFP_KERNEL);\r\nif (!list)\r\nreturn -ENOMEM;\r\nchnls = devm_kzalloc(&pdev->dev, (info_count + 1) * sizeof(*chnls),\r\nGFP_KERNEL);\r\nif (!chnls)\r\nreturn -ENOMEM;\r\nmboxblk = devm_kzalloc(&pdev->dev, info_count * sizeof(*mbox),\r\nGFP_KERNEL);\r\nif (!mboxblk)\r\nreturn -ENOMEM;\r\nmbox = mboxblk;\r\nfinfo = finfoblk;\r\nfor (i = 0; i < info_count; i++, finfo++) {\r\nfifo = &mbox->tx_fifo;\r\nfifo->msg = MAILBOX_MESSAGE(finfo->tx_id);\r\nfifo->fifo_stat = MAILBOX_FIFOSTATUS(finfo->tx_id);\r\nfifo->intr_bit = MAILBOX_IRQ_NOTFULL(finfo->tx_id);\r\nfifo->irqenable = MAILBOX_IRQENABLE(intr_type, finfo->tx_usr);\r\nfifo->irqstatus = MAILBOX_IRQSTATUS(intr_type, finfo->tx_usr);\r\nfifo->irqdisable = MAILBOX_IRQDISABLE(intr_type, finfo->tx_usr);\r\nfifo = &mbox->rx_fifo;\r\nfifo->msg = MAILBOX_MESSAGE(finfo->rx_id);\r\nfifo->msg_stat = MAILBOX_MSGSTATUS(finfo->rx_id);\r\nfifo->intr_bit = MAILBOX_IRQ_NEWMSG(finfo->rx_id);\r\nfifo->irqenable = MAILBOX_IRQENABLE(intr_type, finfo->rx_usr);\r\nfifo->irqstatus = MAILBOX_IRQSTATUS(intr_type, finfo->rx_usr);\r\nfifo->irqdisable = MAILBOX_IRQDISABLE(intr_type, finfo->rx_usr);\r\nmbox->intr_type = intr_type;\r\nmbox->parent = mdev;\r\nmbox->name = finfo->name;\r\nmbox->irq = platform_get_irq(pdev, finfo->tx_irq);\r\nif (mbox->irq < 0)\r\nreturn mbox->irq;\r\nmbox->chan = &chnls[i];\r\nchnls[i].con_priv = mbox;\r\nlist[i] = mbox++;\r\n}\r\nmutex_init(&mdev->cfg_lock);\r\nmdev->dev = &pdev->dev;\r\nmdev->num_users = num_users;\r\nmdev->num_fifos = num_fifos;\r\nmdev->mboxes = list;\r\nmdev->controller.txdone_irq = true;\r\nmdev->controller.dev = mdev->dev;\r\nmdev->controller.ops = &omap_mbox_chan_ops;\r\nmdev->controller.chans = chnls;\r\nmdev->controller.num_chans = info_count;\r\nmdev->controller.of_xlate = omap_mbox_of_xlate;\r\nret = omap_mbox_register(mdev);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, mdev);\r\npm_runtime_enable(mdev->dev);\r\nret = pm_runtime_get_sync(mdev->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(mdev->dev);\r\ngoto unregister;\r\n}\r\nl = mbox_read_reg(mdev, MAILBOX_REVISION);\r\ndev_info(mdev->dev, "omap mailbox rev 0x%x\n", l);\r\nret = pm_runtime_put_sync(mdev->dev);\r\nif (ret < 0)\r\ngoto unregister;\r\ndevm_kfree(&pdev->dev, finfoblk);\r\nreturn 0;\r\nunregister:\r\npm_runtime_disable(mdev->dev);\r\nomap_mbox_unregister(mdev);\r\nreturn ret;\r\n}\r\nstatic int omap_mbox_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_mbox_device *mdev = platform_get_drvdata(pdev);\r\npm_runtime_disable(mdev->dev);\r\nomap_mbox_unregister(mdev);\r\nreturn 0;\r\n}\r\nstatic int __init omap_mbox_init(void)\r\n{\r\nint err;\r\nerr = class_register(&omap_mbox_class);\r\nif (err)\r\nreturn err;\r\nmbox_kfifo_size = ALIGN(mbox_kfifo_size, sizeof(mbox_msg_t));\r\nmbox_kfifo_size = max_t(unsigned int, mbox_kfifo_size,\r\nsizeof(mbox_msg_t));\r\nreturn platform_driver_register(&omap_mbox_driver);\r\n}\r\nstatic void __exit omap_mbox_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_mbox_driver);\r\nclass_unregister(&omap_mbox_class);\r\n}
