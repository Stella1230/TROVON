static u8 rsi_determine_min_weight_queue(struct rsi_common *common)\r\n{\r\nstruct wmm_qinfo *tx_qinfo = common->tx_qinfo;\r\nu32 q_len = 0;\r\nu8 ii = 0;\r\nfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\r\nq_len = skb_queue_len(&common->tx_queue[ii]);\r\nif ((tx_qinfo[ii].pkt_contended) && q_len) {\r\ncommon->min_weight = tx_qinfo[ii].weight;\r\nbreak;\r\n}\r\n}\r\nreturn ii;\r\n}\r\nstatic bool rsi_recalculate_weights(struct rsi_common *common)\r\n{\r\nstruct wmm_qinfo *tx_qinfo = common->tx_qinfo;\r\nbool recontend_queue = false;\r\nu8 ii = 0;\r\nu32 q_len = 0;\r\nfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\r\nq_len = skb_queue_len(&common->tx_queue[ii]);\r\nif (q_len) {\r\nif (tx_qinfo[ii].pkt_contended) {\r\ntx_qinfo[ii].weight =\r\n((tx_qinfo[ii].weight > common->min_weight) ?\r\ntx_qinfo[ii].weight - common->min_weight : 0);\r\n} else {\r\ntx_qinfo[ii].pkt_contended = 1;\r\ntx_qinfo[ii].weight = tx_qinfo[ii].wme_params;\r\nrecontend_queue = true;\r\n}\r\n} else {\r\ntx_qinfo[ii].weight = 0;\r\ntx_qinfo[ii].pkt_contended = 0;\r\n}\r\n}\r\nreturn recontend_queue;\r\n}\r\nstatic u32 rsi_get_num_pkts_dequeue(struct rsi_common *common, u8 q_num)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct sk_buff *skb;\r\nu32 pkt_cnt = 0;\r\ns16 txop = common->tx_qinfo[q_num].txop * 32;\r\n__le16 r_txop;\r\nstruct ieee80211_rate rate;\r\nrate.bitrate = RSI_RATE_MCS0 * 5 * 10;\r\nif (q_num == VI_Q)\r\ntxop = ((txop << 5) / 80);\r\nif (skb_queue_len(&common->tx_queue[q_num]))\r\nskb = skb_peek(&common->tx_queue[q_num]);\r\nelse\r\nreturn 0;\r\ndo {\r\nr_txop = ieee80211_generic_frame_duration(adapter->hw,\r\nadapter->vifs[0],\r\ncommon->band,\r\nskb->len, &rate);\r\ntxop -= le16_to_cpu(r_txop);\r\npkt_cnt += 1;\r\nif (skb_queue_len(&common->tx_queue[q_num]) - pkt_cnt)\r\nskb = skb->next;\r\nelse\r\nbreak;\r\n} while (txop > 0);\r\nreturn pkt_cnt;\r\n}\r\nstatic u8 rsi_core_determine_hal_queue(struct rsi_common *common)\r\n{\r\nbool recontend_queue = false;\r\nu32 q_len = 0;\r\nu8 q_num = INVALID_QUEUE;\r\nu8 ii = 0;\r\nif (skb_queue_len(&common->tx_queue[MGMT_SOFT_Q])) {\r\nif (!common->mgmt_q_block)\r\nq_num = MGMT_SOFT_Q;\r\nreturn q_num;\r\n}\r\nif (common->hw_data_qs_blocked)\r\nreturn q_num;\r\nif (common->pkt_cnt != 0) {\r\n--common->pkt_cnt;\r\nreturn common->selected_qnum;\r\n}\r\nget_queue_num:\r\nrecontend_queue = false;\r\nq_num = rsi_determine_min_weight_queue(common);\r\nii = q_num;\r\nfor (; ii < NUM_EDCA_QUEUES; ii++) {\r\nq_len = skb_queue_len(&common->tx_queue[ii]);\r\nif (((common->tx_qinfo[ii].pkt_contended) &&\r\n(common->tx_qinfo[ii].weight < common->min_weight)) &&\r\nq_len) {\r\ncommon->min_weight = common->tx_qinfo[ii].weight;\r\nq_num = ii;\r\n}\r\n}\r\nif (q_num < NUM_EDCA_QUEUES)\r\ncommon->tx_qinfo[q_num].pkt_contended = 0;\r\nrecontend_queue = rsi_recalculate_weights(common);\r\nq_len = skb_queue_len(&common->tx_queue[q_num]);\r\nif (!q_len) {\r\nif (recontend_queue)\r\ngoto get_queue_num;\r\nq_num = INVALID_QUEUE;\r\nreturn q_num;\r\n}\r\ncommon->selected_qnum = q_num;\r\nq_len = skb_queue_len(&common->tx_queue[q_num]);\r\nif (q_num == VO_Q || q_num == VI_Q) {\r\ncommon->pkt_cnt = rsi_get_num_pkts_dequeue(common, q_num);\r\ncommon->pkt_cnt -= 1;\r\n}\r\nreturn q_num;\r\n}\r\nstatic void rsi_core_queue_pkt(struct rsi_common *common,\r\nstruct sk_buff *skb)\r\n{\r\nu8 q_num = skb->priority;\r\nif (q_num >= NUM_SOFT_QUEUES) {\r\nrsi_dbg(ERR_ZONE, "%s: Invalid Queue Number: q_num = %d\n",\r\n__func__, q_num);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nskb_queue_tail(&common->tx_queue[q_num], skb);\r\n}\r\nstatic struct sk_buff *rsi_core_dequeue_pkt(struct rsi_common *common,\r\nu8 q_num)\r\n{\r\nif (q_num >= NUM_SOFT_QUEUES) {\r\nrsi_dbg(ERR_ZONE, "%s: Invalid Queue Number: q_num = %d\n",\r\n__func__, q_num);\r\nreturn NULL;\r\n}\r\nreturn skb_dequeue(&common->tx_queue[q_num]);\r\n}\r\nvoid rsi_core_qos_processor(struct rsi_common *common)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct sk_buff *skb;\r\nunsigned long tstamp_1, tstamp_2;\r\nu8 q_num;\r\nint status;\r\ntstamp_1 = jiffies;\r\nwhile (1) {\r\nq_num = rsi_core_determine_hal_queue(common);\r\nrsi_dbg(DATA_TX_ZONE,\r\n"%s: Queue number = %d\n", __func__, q_num);\r\nif (q_num == INVALID_QUEUE) {\r\nrsi_dbg(DATA_TX_ZONE, "%s: No More Pkt\n", __func__);\r\nbreak;\r\n}\r\nmutex_lock(&common->tx_rxlock);\r\nstatus = adapter->check_hw_queue_status(adapter, q_num);\r\nif ((status <= 0)) {\r\nmutex_unlock(&common->tx_rxlock);\r\nbreak;\r\n}\r\nif ((q_num < MGMT_SOFT_Q) &&\r\n((skb_queue_len(&common->tx_queue[q_num])) <=\r\nMIN_DATA_QUEUE_WATER_MARK)) {\r\nif (ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))\r\nieee80211_wake_queue(adapter->hw,\r\nWME_AC(q_num));\r\n}\r\nskb = rsi_core_dequeue_pkt(common, q_num);\r\nif (skb == NULL) {\r\nrsi_dbg(ERR_ZONE, "skb null\n");\r\nmutex_unlock(&common->tx_rxlock);\r\nbreak;\r\n}\r\nif (q_num == MGMT_SOFT_Q)\r\nstatus = rsi_send_mgmt_pkt(common, skb);\r\nelse\r\nstatus = rsi_send_data_pkt(common, skb);\r\nif (status) {\r\nmutex_unlock(&common->tx_rxlock);\r\nbreak;\r\n}\r\ncommon->tx_stats.total_tx_pkt_send[q_num]++;\r\ntstamp_2 = jiffies;\r\nmutex_unlock(&common->tx_rxlock);\r\nif (tstamp_2 > tstamp_1 + (300 * HZ / 1000))\r\nschedule();\r\n}\r\n}\r\nvoid rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct ieee80211_tx_info *info;\r\nstruct skb_info *tx_params;\r\nstruct ieee80211_hdr *tmp_hdr = NULL;\r\nu8 q_num, tid = 0;\r\nif ((!skb) || (!skb->len)) {\r\nrsi_dbg(ERR_ZONE, "%s: Null skb/zero Length packet\n",\r\n__func__);\r\ngoto xmit_fail;\r\n}\r\ninfo = IEEE80211_SKB_CB(skb);\r\ntx_params = (struct skb_info *)info->driver_data;\r\ntmp_hdr = (struct ieee80211_hdr *)&skb->data[0];\r\nif (common->fsm_state != FSM_MAC_INIT_DONE) {\r\nrsi_dbg(ERR_ZONE, "%s: FSM state not open\n", __func__);\r\ngoto xmit_fail;\r\n}\r\nif ((ieee80211_is_mgmt(tmp_hdr->frame_control)) ||\r\n(ieee80211_is_ctl(tmp_hdr->frame_control)) ||\r\n(ieee80211_is_qos_nullfunc(tmp_hdr->frame_control))) {\r\nq_num = MGMT_SOFT_Q;\r\nskb->priority = q_num;\r\n} else {\r\nif (ieee80211_is_data_qos(tmp_hdr->frame_control)) {\r\ntid = (skb->data[24] & IEEE80211_QOS_TID);\r\nskb->priority = TID_TO_WME_AC(tid);\r\n} else {\r\ntid = IEEE80211_NONQOS_TID;\r\nskb->priority = BE_Q;\r\n}\r\nq_num = skb->priority;\r\ntx_params->tid = tid;\r\ntx_params->sta_id = 0;\r\n}\r\nif ((q_num != MGMT_SOFT_Q) &&\r\n((skb_queue_len(&common->tx_queue[q_num]) + 1) >=\r\nDATA_QUEUE_WATER_MARK)) {\r\nrsi_dbg(ERR_ZONE, "%s: sw queue full\n", __func__);\r\nif (!ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))\r\nieee80211_stop_queue(adapter->hw, WME_AC(q_num));\r\nrsi_set_event(&common->tx_thread.event);\r\ngoto xmit_fail;\r\n}\r\nrsi_core_queue_pkt(common, skb);\r\nrsi_dbg(DATA_TX_ZONE, "%s: ===> Scheduling TX thead <===\n", __func__);\r\nrsi_set_event(&common->tx_thread.event);\r\nreturn;\r\nxmit_fail:\r\nrsi_dbg(ERR_ZONE, "%s: Failed to queue packet\n", __func__);\r\nieee80211_free_txskb(common->priv->hw, skb);\r\n}
