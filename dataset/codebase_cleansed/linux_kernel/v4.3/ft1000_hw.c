static inline u16 ft1000_read_fifo_len(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\nreturn (ft1000_read_reg(dev, FT1000_REG_UFIFO_STAT) - 16);\r\nelse\r\nreturn (ft1000_read_reg(dev, FT1000_REG_MAG_UFSR) - 16);\r\n}\r\nu16 ft1000_read_dpram(struct net_device *dev, int offset)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nu16 data;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\ndata = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void ft1000_write_dpram(struct net_device *dev,\r\nint offset, u16 value)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, value);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\n}\r\nu16 ft1000_read_dpram_mag_16(struct net_device *dev, int offset, int Index)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nu16 data;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\nif (Index)\r\ndata = ft1000_read_reg(dev, FT1000_REG_MAG_DPDATAL);\r\nelse\r\ndata = ft1000_read_reg(dev, FT1000_REG_MAG_DPDATAH);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void ft1000_write_dpram_mag_16(struct net_device *dev,\r\nint offset, u16 value, int Index)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\nif (Index)\r\nft1000_write_reg(dev, FT1000_REG_MAG_DPDATAL, value);\r\nelse\r\nft1000_write_reg(dev, FT1000_REG_MAG_DPDATAH, value);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\n}\r\nu32 ft1000_read_dpram_mag_32(struct net_device *dev, int offset)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nu32 data;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\ndata = inl(dev->base_addr + FT1000_REG_MAG_DPDATAL);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nreturn data;\r\n}\r\nvoid ft1000_write_dpram_mag_32(struct net_device *dev, int offset, u32 value)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, offset);\r\noutl(value, dev->base_addr + FT1000_REG_MAG_DPDATAL);\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\n}\r\nstatic void ft1000_enable_interrupts(struct net_device *dev)\r\n{\r\nu16 tempword;\r\nft1000_write_reg(dev, FT1000_REG_SUP_IMASK, ISR_DEFAULT_MASK);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_IMASK);\r\npr_debug("current interrupt enable mask = 0x%x\n", tempword);\r\n}\r\nstatic void ft1000_disable_interrupts(struct net_device *dev)\r\n{\r\nu16 tempword;\r\nft1000_write_reg(dev, FT1000_REG_SUP_IMASK, ISR_MASK_ALL);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_IMASK);\r\npr_debug("current interrupt enable mask = 0x%x\n", tempword);\r\n}\r\nstatic void ft1000_read_dsp_timer(struct net_device *dev,\r\nstruct ft1000_info *info)\r\n{\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ninfo->DSP_TIME[0] = ft1000_read_dpram(dev, FT1000_DSP_TIMER0);\r\ninfo->DSP_TIME[1] = ft1000_read_dpram(dev, FT1000_DSP_TIMER1);\r\ninfo->DSP_TIME[2] = ft1000_read_dpram(dev, FT1000_DSP_TIMER2);\r\ninfo->DSP_TIME[3] = ft1000_read_dpram(dev, FT1000_DSP_TIMER3);\r\n} else {\r\ninfo->DSP_TIME[0] =\r\nft1000_read_dpram_mag_16(dev, FT1000_MAG_DSP_TIMER0,\r\nFT1000_MAG_DSP_TIMER0_INDX);\r\ninfo->DSP_TIME[1] =\r\nft1000_read_dpram_mag_16(dev, FT1000_MAG_DSP_TIMER1,\r\nFT1000_MAG_DSP_TIMER1_INDX);\r\ninfo->DSP_TIME[2] =\r\nft1000_read_dpram_mag_16(dev, FT1000_MAG_DSP_TIMER2,\r\nFT1000_MAG_DSP_TIMER2_INDX);\r\ninfo->DSP_TIME[3] =\r\nft1000_read_dpram_mag_16(dev, FT1000_MAG_DSP_TIMER3,\r\nFT1000_MAG_DSP_TIMER3_INDX);\r\n}\r\n}\r\nstatic void ft1000_reset_asic(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nstruct ft1000_pcmcia *pcmcia = info->priv;\r\nu16 tempword;\r\n(*info->ft1000_reset) (pcmcia->link);\r\nif (info->AsicID == MAGNEMITE_ID) {\r\nft1000_write_reg(dev, FT1000_REG_RESET,\r\nDSP_RESET_BIT | ASIC_RESET_BIT);\r\n}\r\nmdelay(1);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_WATERMARK, 0xffff);\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_MAG_WATERMARK, 0xffff);\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);\r\npr_debug("interrupt status register = 0x%x\n", tempword);\r\nft1000_write_reg(dev, FT1000_REG_SUP_ISR, tempword);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);\r\npr_debug("interrupt status register = 0x%x\n", tempword);\r\n}\r\nstatic int ft1000_reset_card(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 tempword;\r\nint i;\r\nunsigned long flags;\r\nstruct prov_record *ptr;\r\nstruct prov_record *tmp;\r\ninfo->CardReady = 0;\r\ninfo->ProgConStat = 0;\r\ninfo->squeseqnum = 0;\r\nft1000_disable_interrupts(dev);\r\nlist_for_each_entry_safe(ptr, tmp, &info->prov_list, list) {\r\npr_debug("deleting provisioning record\n");\r\nlist_del(&ptr->list);\r\nkfree(ptr->pprov_data);\r\nkfree(ptr);\r\n}\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\npr_debug("resetting DSP\n");\r\nft1000_write_reg(dev, FT1000_REG_RESET, DSP_RESET_BIT);\r\n} else {\r\npr_debug("resetting ASIC and DSP\n");\r\nft1000_write_reg(dev, FT1000_REG_RESET,\r\nDSP_RESET_BIT | ASIC_RESET_BIT);\r\n}\r\nif (ft1000_card_present == 1) {\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_RX_BASE);\r\nfor (i = 0; i < MAX_DSP_SESS_REC; i++) {\r\ninfo->DSPSess.Rec[i] =\r\nft1000_read_reg(dev,\r\nFT1000_REG_DPRAM_DATA);\r\n}\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_RX_BASE);\r\nfor (i = 0; i < MAX_DSP_SESS_REC / 2; i++) {\r\ninfo->DSPSess.MagRec[i] =\r\ninl(dev->base_addr\r\n+ FT1000_REG_MAG_DPDATA);\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\n}\r\npr_debug("resetting ASIC\n");\r\nmdelay(10);\r\nft1000_reset_asic(dev);\r\npr_debug("downloading dsp image\n");\r\nif (info->AsicID == MAGNEMITE_ID) {\r\npr_debug("Put DSP in reset and take ASIC out of reset\n");\r\nft1000_write_reg(dev, FT1000_REG_RESET, DSP_RESET_BIT);\r\nft1000_write_reg(dev, FT1000_REG_SUP_CTRL, HOST_INTF_BE);\r\ncard_bootload(dev);\r\nft1000_write_reg(dev, FT1000_REG_RESET, 0);\r\nmdelay(10);\r\npr_debug("Take DSP out of reset\n");\r\nfor (i = 0; i < 50; i++) {\r\ntempword = ft1000_read_dpram_mag_16(dev,\r\nFT1000_MAG_DPRAM_FEFE,\r\nFT1000_MAG_DPRAM_FEFE_INDX);\r\nif (tempword == 0xfefe)\r\nbreak;\r\nmdelay(20);\r\n}\r\nif (i == 50) {\r\npr_debug("No FEFE detected from DSP\n");\r\nreturn false;\r\n}\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_RESET, ~DSP_RESET_BIT);\r\nmdelay(10);\r\n}\r\nif (card_download(dev, fw_entry->data, fw_entry->size)) {\r\npr_debug("card download unsuccessful\n");\r\nreturn false;\r\n}\r\npr_debug("card download successful\n");\r\nmdelay(10);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ninfo->fifo_cnt = 0;\r\nft1000_write_dpram(dev, FT1000_FIFO_LEN, info->fifo_cnt);\r\nft1000_write_dpram(dev, FT1000_HI_HO, ho);\r\ntempword = ft1000_read_dpram(dev, FT1000_HI_HO);\r\npr_debug("hi_ho value = 0x%x\n", tempword);\r\n} else {\r\nft1000_write_dpram_mag_16(dev, FT1000_MAG_HI_HO, ho_mag,\r\nFT1000_MAG_HI_HO_INDX);\r\ntempword =\r\nft1000_read_dpram_mag_16(dev, FT1000_MAG_HI_HO,\r\nFT1000_MAG_HI_HO_INDX);\r\npr_debug("hi_ho value = 0x%x\n", tempword);\r\n}\r\ninfo->CardReady = 1;\r\nft1000_enable_interrupts(dev);\r\nreturn true;\r\n}\r\nstatic int ft1000_chkcard(struct net_device *dev)\r\n{\r\nu16 tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_IMASK);\r\nif (tempword == 0) {\r\npr_debug("IMASK = 0 Card not detected\n");\r\nreturn false;\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_ASIC_ID);\r\nif (tempword == 0xffff) {\r\npr_debug("Version = 0xffff Card not detected\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void ft1000_hbchk(u_long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct ft1000_info *info;\r\nu16 tempword;\r\ninfo = netdev_priv(dev);\r\nif (info->CardReady == 1) {\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword = ft1000_read_dpram(dev, FT1000_HI_HO);\r\n} else {\r\ntempword =\r\nntohs(ft1000_read_dpram_mag_16\r\n(dev, FT1000_MAG_HI_HO,\r\nFT1000_MAG_HI_HO_INDX));\r\n}\r\npr_debug("hi_ho value = 0x%x\n", tempword);\r\nif (tempword != ho) {\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\ntempword = ft1000_read_dpram(dev, FT1000_HI_HO);\r\nelse\r\ntempword = ntohs(ft1000_read_dpram_mag_16(dev,\r\nFT1000_MAG_HI_HO,\r\nFT1000_MAG_HI_HO_INDX));\r\n}\r\nif (tempword != ho) {\r\npr_info("heartbeat failed - no ho detected\n");\r\nft1000_read_dsp_timer(dev, info);\r\ninfo->DrvErrNum = DSP_HB_INFO;\r\nif (ft1000_reset_card(dev) == 0) {\r\npr_info("Hardware Failure Detected - PC Card disabled\n");\r\ninfo->ProgConStat = 0xff;\r\nreturn;\r\n}\r\npoll_timer.expires = jiffies + (2*HZ);\r\npoll_timer.data = (u_long)dev;\r\nadd_timer(&poll_timer);\r\nreturn;\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_HB)\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_HB) {\r\npr_info("heartbeat doorbell not clear by firmware\n");\r\nft1000_read_dsp_timer(dev, info);\r\ninfo->DrvErrNum = DSP_HB_INFO;\r\nif (ft1000_reset_card(dev) == 0) {\r\npr_info("Hardware Failure Detected - PC Card disabled\n");\r\ninfo->ProgConStat = 0xff;\r\nreturn;\r\n}\r\npoll_timer.expires = jiffies + (2*HZ);\r\npoll_timer.data = (u_long)dev;\r\nadd_timer(&poll_timer);\r\nreturn;\r\n}\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_dpram(dev, FT1000_HI_HO, hi);\r\n} else {\r\nft1000_write_dpram_mag_16(dev, FT1000_MAG_HI_HO, hi_mag,\r\nFT1000_MAG_HI_HO_INDX);\r\n}\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword = ft1000_read_dpram(dev, FT1000_HI_HO);\r\n} else {\r\ntempword =\r\nntohs(ft1000_read_dpram_mag_16\r\n(dev, FT1000_MAG_HI_HO,\r\nFT1000_MAG_HI_HO_INDX));\r\n}\r\nif (tempword != hi) {\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\nft1000_write_dpram(dev, FT1000_HI_HO, hi);\r\nelse\r\nft1000_write_dpram_mag_16(dev, FT1000_MAG_HI_HO,\r\nhi_mag, FT1000_MAG_HI_HO_INDX);\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\ntempword = ft1000_read_dpram(dev, FT1000_HI_HO);\r\nelse\r\ntempword = ntohs(ft1000_read_dpram_mag_16(dev,\r\nFT1000_MAG_HI_HO,\r\nFT1000_MAG_HI_HO_INDX));\r\n}\r\nif (tempword != hi) {\r\npr_info("heartbeat failed - cannot write hi into DPRAM\n");\r\nft1000_read_dsp_timer(dev, info);\r\ninfo->DrvErrNum = DSP_HB_INFO;\r\nif (ft1000_reset_card(dev) == 0) {\r\npr_info("Hardware Failure Detected - PC Card disabled\n");\r\ninfo->ProgConStat = 0xff;\r\nreturn;\r\n}\r\npoll_timer.expires = jiffies + (2*HZ);\r\npoll_timer.data = (u_long)dev;\r\nadd_timer(&poll_timer);\r\nreturn;\r\n}\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL, FT1000_DB_HB);\r\n}\r\npoll_timer.expires = jiffies + (2 * HZ);\r\npoll_timer.data = (u_long)dev;\r\nadd_timer(&poll_timer);\r\n}\r\nstatic void ft1000_send_cmd(struct net_device *dev, u16 *ptempbuffer, int size,\r\nu16 qtype)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nint i;\r\nu16 tempword;\r\nunsigned long flags;\r\nsize += sizeof(struct pseudo_hdr);\r\nif ((size & 0x0001))\r\nsize++;\r\npr_debug("total length = %d\n", size);\r\npr_debug("length = %d\n", ntohs(*ptempbuffer));\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\ni = 0;\r\nwhile (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(10);\r\ni++;\r\nif (i == 10) {\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nreturn;\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\n}\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_TX_BASE);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, size);\r\nfor (i = 0; i < (size >> 1); i++) {\r\npr_debug("data %d = 0x%x\n", i, *ptempbuffer);\r\ntempword = htons(*ptempbuffer++);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, tempword);\r\n}\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_TX_BASE);\r\nft1000_write_reg(dev, FT1000_REG_MAG_DPDATAH, htons(size));\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_TX_BASE + 1);\r\nfor (i = 0; i < (size >> 2); i++) {\r\npr_debug("data = 0x%x\n", *ptempbuffer);\r\noutw(*ptempbuffer++,\r\ndev->base_addr + FT1000_REG_MAG_DPDATAL);\r\npr_debug("data = 0x%x\n", *ptempbuffer);\r\noutw(*ptempbuffer++,\r\ndev->base_addr + FT1000_REG_MAG_DPDATAH);\r\n}\r\npr_debug("data = 0x%x\n", *ptempbuffer);\r\noutw(*ptempbuffer++, dev->base_addr + FT1000_REG_MAG_DPDATAL);\r\npr_debug("data = 0x%x\n", *ptempbuffer);\r\noutw(*ptempbuffer++, dev->base_addr + FT1000_REG_MAG_DPDATAH);\r\n}\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL, FT1000_DB_DPRAM_TX);\r\n}\r\nstatic bool ft1000_receive_cmd(struct net_device *dev, u16 *pbuffer,\r\nint maxsz, u16 *pnxtph)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 size;\r\nu16 *ppseudohdr;\r\nint i;\r\nu16 tempword;\r\nunsigned long flags;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nsize = ft1000_read_dpram(dev, *pnxtph)\r\n+ sizeof(struct pseudo_hdr);\r\n} else {\r\nsize = ntohs(ft1000_read_dpram_mag_16(dev, FT1000_MAG_PH_LEN,\r\nFT1000_MAG_PH_LEN_INDX))\r\n+ sizeof(struct pseudo_hdr);\r\n}\r\nif (size > maxsz) {\r\npr_debug("Invalid command length = %d\n", size);\r\nreturn false;\r\n}\r\nppseudohdr = (u16 *)pbuffer;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_RX_BASE + 2);\r\nfor (i = 0; i <= (size >> 1); i++) {\r\ntempword =\r\nft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\n*pbuffer++ = ntohs(tempword);\r\n}\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_RX_BASE);\r\n*pbuffer = inw(dev->base_addr + FT1000_REG_MAG_DPDATAH);\r\npr_debug("received data = 0x%x\n", *pbuffer);\r\npbuffer++;\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_RX_BASE + 1);\r\nfor (i = 0; i <= (size >> 2); i++) {\r\n*pbuffer =\r\ninw(dev->base_addr +\r\nFT1000_REG_MAG_DPDATAL);\r\npbuffer++;\r\n*pbuffer =\r\ninw(dev->base_addr +\r\nFT1000_REG_MAG_DPDATAH);\r\npbuffer++;\r\n}\r\n*pbuffer = inw(dev->base_addr + FT1000_REG_MAG_DPDATAL);\r\npr_debug("received data = 0x%x\n", *pbuffer);\r\npbuffer++;\r\n*pbuffer = inw(dev->base_addr + FT1000_REG_MAG_DPDATAH);\r\npr_debug("received data = 0x%x\n", *pbuffer);\r\npbuffer++;\r\n}\r\nif (size & 0x0001) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\n*pbuffer = ntohs(tempword);\r\n}\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\ntempword = *ppseudohdr++;\r\nfor (i = 1; i < 7; i++)\r\ntempword ^= *ppseudohdr++;\r\nif (tempword != *ppseudohdr) {\r\npr_debug("Pseudo header checksum mismatch\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void ft1000_proc_drvmsg(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 msgtype;\r\nu16 tempword;\r\nstruct media_msg *pmediamsg;\r\nstruct dsp_init_msg *pdspinitmsg;\r\nstruct drv_msg *pdrvmsg;\r\nu16 len;\r\nu16 i;\r\nstruct prov_record *ptr;\r\nstruct pseudo_hdr *ppseudo_hdr;\r\nu16 *pmsg;\r\nstruct timeval tv;\r\nunion {\r\nu8 byte[2];\r\nu16 wrd;\r\n} convert;\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\ntempword = FT1000_DPRAM_RX_BASE+2;\r\nelse\r\ntempword = FT1000_DPRAM_MAG_RX_BASE;\r\nif (ft1000_receive_cmd(dev, &cmdbuffer[0], MAX_CMD_SQSIZE, &tempword)) {\r\npdrvmsg = (struct drv_msg *)&cmdbuffer[0];\r\nmsgtype = ntohs(pdrvmsg->type);\r\npr_debug("Command message type = 0x%x\n", msgtype);\r\nswitch (msgtype) {\r\ncase DSP_PROVISION:\r\npr_debug("Got a provisioning request message from DSP\n");\r\nmdelay(25);\r\nwhile (list_empty(&info->prov_list) == 0) {\r\npr_debug("Sending a provisioning message\n");\r\ntempword = ft1000_read_reg(dev,\r\nFT1000_REG_DOORBELL);\r\ni = 0;\r\nwhile (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(5);\r\ni++;\r\nif (i == 10)\r\nbreak;\r\n}\r\nptr = list_entry(info->prov_list.next,\r\nstruct prov_record, list);\r\nlen = *(u16 *)ptr->pprov_data;\r\nlen = htons(len);\r\npmsg = (u16 *)ptr->pprov_data;\r\nppseudo_hdr = (struct pseudo_hdr *)pmsg;\r\nppseudo_hdr->seq_num = info->squeseqnum++;\r\nppseudo_hdr->portsrc = 0;\r\nppseudo_hdr->checksum = *pmsg++;\r\npr_debug("checksum = 0x%x\n",\r\nppseudo_hdr->checksum);\r\nfor (i = 1; i < 7; i++) {\r\nppseudo_hdr->checksum ^= *pmsg++;\r\npr_debug("checksum = 0x%x\n",\r\nppseudo_hdr->checksum);\r\n}\r\nft1000_send_cmd(dev, (u16 *)ptr->pprov_data,\r\nlen, SLOWQ_TYPE);\r\nlist_del(&ptr->list);\r\nkfree(ptr->pprov_data);\r\nkfree(ptr);\r\n}\r\ninfo->CardReady = 1;\r\nbreak;\r\ncase MEDIA_STATE:\r\npmediamsg = (struct media_msg *)&cmdbuffer[0];\r\nif (info->ProgConStat != 0xFF) {\r\nif (pmediamsg->state) {\r\npr_debug("Media is up\n");\r\nif (info->mediastate == 0) {\r\nnetif_carrier_on(dev);\r\nnetif_wake_queue(dev);\r\ninfo->mediastate = 1;\r\ndo_gettimeofday(&tv);\r\ninfo->ConTm = tv.tv_sec;\r\n}\r\n} else {\r\npr_debug("Media is down\n");\r\nif (info->mediastate == 1) {\r\ninfo->mediastate = 0;\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\ninfo->ConTm = 0;\r\n}\r\n}\r\n} else {\r\npr_debug("Media is down\n");\r\nif (info->mediastate == 1) {\r\ninfo->mediastate = 0;\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\ninfo->ConTm = 0;\r\n}\r\n}\r\nbreak;\r\ncase DSP_INIT_MSG:\r\npdspinitmsg = (struct dsp_init_msg *)&cmdbuffer[0];\r\nmemcpy(info->DspVer, pdspinitmsg->DspVer, DSPVERSZ);\r\npr_debug("DSPVER = 0x%2x 0x%2x 0x%2x 0x%2x\n",\r\ninfo->DspVer[0], info->DspVer[1],\r\ninfo->DspVer[2], info->DspVer[3]);\r\nmemcpy(info->HwSerNum, pdspinitmsg->HwSerNum,\r\nHWSERNUMSZ);\r\nmemcpy(info->Sku, pdspinitmsg->Sku, SKUSZ);\r\nmemcpy(info->eui64, pdspinitmsg->eui64, EUISZ);\r\ndev->dev_addr[0] = info->eui64[0];\r\ndev->dev_addr[1] = info->eui64[1];\r\ndev->dev_addr[2] = info->eui64[2];\r\ndev->dev_addr[3] = info->eui64[5];\r\ndev->dev_addr[4] = info->eui64[6];\r\ndev->dev_addr[5] = info->eui64[7];\r\nif (ntohs(pdspinitmsg->length) ==\r\n(sizeof(struct dsp_init_msg) - 20)) {\r\nmemcpy(info->ProductMode,\r\npdspinitmsg->ProductMode, MODESZ);\r\nmemcpy(info->RfCalVer, pdspinitmsg->RfCalVer,\r\nCALVERSZ);\r\nmemcpy(info->RfCalDate, pdspinitmsg->RfCalDate,\r\nCALDATESZ);\r\npr_debug("RFCalVer = 0x%2x 0x%2x\n",\r\ninfo->RfCalVer[0], info->RfCalVer[1]);\r\n}\r\nbreak;\r\ncase DSP_STORE_INFO:\r\npr_debug("Got DSP_STORE_INFO\n");\r\ntempword = ntohs(pdrvmsg->length);\r\ninfo->DSPInfoBlklen = tempword;\r\nif (tempword < (MAX_DSP_SESS_REC - 4)) {\r\npmsg = (u16 *)&pdrvmsg->data[0];\r\nfor (i = 0; i < ((tempword + 1) / 2); i++) {\r\npr_debug("dsp info data = 0x%x\n",\r\n*pmsg);\r\ninfo->DSPInfoBlk[i + 10] = *pmsg++;\r\n}\r\n}\r\nbreak;\r\ncase DSP_GET_INFO:\r\npr_debug("Got DSP_GET_INFO\n");\r\nmdelay(10);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(10);\r\ntempword = ft1000_read_reg(dev,\r\nFT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX)\r\nmdelay(10);\r\n}\r\nif ((tempword & FT1000_DB_DPRAM_TX) == 0) {\r\npmsg = (u16 *)info->DSPInfoBlk;\r\nppseudo_hdr = (struct pseudo_hdr *)pmsg;\r\nppseudo_hdr->length =\r\nhtons(info->DSPInfoBlklen + 4);\r\nppseudo_hdr->source = 0x10;\r\nppseudo_hdr->destination = 0x20;\r\nppseudo_hdr->portdest = 0;\r\nppseudo_hdr->portsrc = 0;\r\nppseudo_hdr->sh_str_id = 0;\r\nppseudo_hdr->control = 0;\r\nppseudo_hdr->rsvd1 = 0;\r\nppseudo_hdr->rsvd2 = 0;\r\nppseudo_hdr->qos_class = 0;\r\nppseudo_hdr->seq_num = info->squeseqnum++;\r\nppseudo_hdr->portsrc = 0;\r\nppseudo_hdr->checksum = *pmsg++;\r\nfor (i = 1; i < 7; i++)\r\nppseudo_hdr->checksum ^= *pmsg++;\r\ninfo->DSPInfoBlk[8] = 0x7200;\r\ninfo->DSPInfoBlk[9] =\r\nhtons(info->DSPInfoBlklen);\r\nft1000_send_cmd(dev, info->DSPInfoBlk,\r\n(u16)(info->DSPInfoBlklen+4),\r\n0);\r\n}\r\nbreak;\r\ncase GET_DRV_ERR_RPT_MSG:\r\npr_debug("Got GET_DRV_ERR_RPT_MSG\n");\r\nmdelay(10);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX) {\r\nmdelay(10);\r\ntempword = ft1000_read_reg(dev,\r\nFT1000_REG_DOORBELL);\r\nif (tempword & FT1000_DB_DPRAM_TX)\r\nmdelay(10);\r\n}\r\nif ((tempword & FT1000_DB_DPRAM_TX) == 0) {\r\npmsg = (u16 *)&tempbuffer[0];\r\nppseudo_hdr = (struct pseudo_hdr *)pmsg;\r\nppseudo_hdr->length = htons(0x0012);\r\nppseudo_hdr->source = 0x10;\r\nppseudo_hdr->destination = 0x20;\r\nppseudo_hdr->portdest = 0;\r\nppseudo_hdr->portsrc = 0;\r\nppseudo_hdr->sh_str_id = 0;\r\nppseudo_hdr->control = 0;\r\nppseudo_hdr->rsvd1 = 0;\r\nppseudo_hdr->rsvd2 = 0;\r\nppseudo_hdr->qos_class = 0;\r\nppseudo_hdr->seq_num = info->squeseqnum++;\r\nppseudo_hdr->portsrc = 0;\r\nppseudo_hdr->checksum = *pmsg++;\r\nfor (i = 1; i < 7; i++)\r\nppseudo_hdr->checksum ^= *pmsg++;\r\npmsg = (u16 *)&tempbuffer[16];\r\n*pmsg++ = htons(RSP_DRV_ERR_RPT_MSG);\r\n*pmsg++ = htons(0x000e);\r\n*pmsg++ = htons(info->DSP_TIME[0]);\r\n*pmsg++ = htons(info->DSP_TIME[1]);\r\n*pmsg++ = htons(info->DSP_TIME[2]);\r\n*pmsg++ = htons(info->DSP_TIME[3]);\r\nconvert.byte[0] = info->DspVer[0];\r\nconvert.byte[1] = info->DspVer[1];\r\n*pmsg++ = convert.wrd;\r\nconvert.byte[0] = info->DspVer[2];\r\nconvert.byte[1] = info->DspVer[3];\r\n*pmsg++ = convert.wrd;\r\n*pmsg++ = htons(info->DrvErrNum);\r\nft1000_send_cmd(dev, (u16 *)&tempbuffer[0],\r\n(u16)(0x0012), 0);\r\ninfo->DrvErrNum = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int ft1000_parse_dpram_msg(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 doorbell;\r\nu16 portid;\r\nu16 nxtph;\r\nu16 total_len;\r\nint i = 0;\r\nunsigned long flags;\r\ndoorbell = ft1000_read_reg(dev, FT1000_REG_DOORBELL);\r\npr_debug("Doorbell = 0x%x\n", doorbell);\r\nif (doorbell & FT1000_ASIC_RESET_REQ) {\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_RX_BASE);\r\nfor (i = 0; i < MAX_DSP_SESS_REC; i++) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA,\r\ninfo->DSPSess.Rec[i]);\r\n}\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nFT1000_DPRAM_MAG_RX_BASE);\r\nfor (i = 0; i < MAX_DSP_SESS_REC / 2; i++) {\r\noutl(info->DSPSess.MagRec[i],\r\ndev->base_addr + FT1000_REG_MAG_DPDATA);\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL,\r\nFT1000_ASIC_RESET_REQ);\r\npr_debug("Got an ASIC RESET Request\n");\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL,\r\nFT1000_ASIC_RESET_DSP);\r\nif (info->AsicID == MAGNEMITE_ID) {\r\nft1000_write_reg(dev, FT1000_REG_SUP_CTRL,\r\nHOST_INTF_BE);\r\n}\r\n}\r\nif (doorbell & FT1000_DSP_ASIC_RESET) {\r\npr_debug("Got a dsp ASIC reset message\n");\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL,\r\nFT1000_DSP_ASIC_RESET);\r\nudelay(200);\r\nreturn SUCCESS;\r\n}\r\nif (doorbell & FT1000_DB_DPRAM_RX) {\r\npr_debug("Got a slow queue message\n");\r\nnxtph = FT1000_DPRAM_RX_BASE + 2;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntotal_len =\r\nft1000_read_dpram(dev, FT1000_DPRAM_RX_BASE);\r\n} else {\r\ntotal_len =\r\nntohs(ft1000_read_dpram_mag_16\r\n(dev, FT1000_MAG_TOTAL_LEN,\r\nFT1000_MAG_TOTAL_LEN_INDX));\r\n}\r\npr_debug("total length = %d\n", total_len);\r\nif ((total_len < MAX_CMD_SQSIZE)\r\n&& (total_len > sizeof(struct pseudo_hdr))) {\r\ntotal_len += nxtph;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nportid = (ft1000_read_dpram(dev, DSP_QID_OFFSET\r\n+ FT1000_DPRAM_RX_BASE + 2)\r\n>> 8) & 0xff;\r\n} else {\r\nportid =\r\nft1000_read_dpram_mag_16\r\n(dev, FT1000_MAG_PORT_ID,\r\nFT1000_MAG_PORT_ID_INDX) & 0xff;\r\n}\r\npr_debug("DSP_QID = 0x%x\n", portid);\r\nif (portid == DRIVERID) {\r\nft1000_proc_drvmsg(dev);\r\n}\r\n}\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL, FT1000_DB_DPRAM_RX);\r\n}\r\nif (doorbell & FT1000_DB_COND_RESET) {\r\nft1000_read_dsp_timer(dev, info);\r\ninfo->DrvErrNum = DSP_CONDRESET_INFO;\r\npr_debug("DSP conditional reset requested\n");\r\nft1000_reset_card(dev);\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL,\r\nFT1000_DB_COND_RESET);\r\n}\r\ndoorbell =\r\ndoorbell & ~(FT1000_DB_DPRAM_RX | FT1000_ASIC_RESET_REQ |\r\nFT1000_DB_COND_RESET | 0xff00);\r\nif (doorbell) {\r\npr_debug("Clearing unexpected doorbell = 0x%x\n", doorbell);\r\nft1000_write_reg(dev, FT1000_REG_DOORBELL, doorbell);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic void ft1000_flush_fifo(struct net_device *dev, u16 DrvErrNum)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nstruct ft1000_pcmcia *pcmcia = info->priv;\r\nu16 i;\r\nu32 templong;\r\nu16 tempword;\r\nif (pcmcia->PktIntfErr > MAX_PH_ERR) {\r\nft1000_read_dsp_timer(dev, info);\r\ninfo->DrvErrNum = DrvErrNum;\r\nft1000_reset_card(dev);\r\nreturn;\r\n}\r\ni = 0;\r\ndo {\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword =\r\nft1000_read_reg(dev, FT1000_REG_DFIFO);\r\ntempword =\r\nft1000_read_reg(dev, FT1000_REG_DFIFO_STAT);\r\n} else {\r\ntemplong =\r\ninl(dev->base_addr + FT1000_REG_MAG_DFR);\r\ntempword =\r\ninw(dev->base_addr + FT1000_REG_MAG_DFSR);\r\n}\r\ni++;\r\nif ((i > 2048) || (tempword == 0)) {\r\nft1000_read_dsp_timer(dev, info);\r\nif (tempword == 0) {\r\ntempword =\r\ninw(dev->base_addr +\r\nFT1000_REG_SUP_IMASK);\r\nif (tempword == 0) {\r\ninfo->DrvErrNum = FIFO_FLUSH_BADCNT;\r\n} else {\r\npcmcia->PktIntfErr++;\r\nreturn;\r\n}\r\n} else {\r\ninfo->DrvErrNum = FIFO_FLUSH_MAXLIMIT;\r\n}\r\nreturn;\r\n}\r\ntempword = inw(dev->base_addr + FT1000_REG_SUP_STAT);\r\n} while ((tempword & 0x03) != 0x03);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ni++;\r\npr_debug("Flushing FIFO complete = %x\n", tempword);\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\ni = i * 2;\r\npr_debug("Flush Data byte count to dsp = %d\n", i);\r\ninfo->fifo_cnt += i;\r\nft1000_write_dpram(dev, FT1000_FIFO_LEN,\r\ninfo->fifo_cnt);\r\n} else {\r\npr_debug("Flushing FIFO complete = %x\n", tempword);\r\ntemplong = inl(dev->base_addr + FT1000_REG_MAG_DFR);\r\ntempword = inw(dev->base_addr + FT1000_REG_SUP_STAT);\r\npr_debug("FT1000_REG_SUP_STAT = 0x%x\n", tempword);\r\ntempword = inw(dev->base_addr + FT1000_REG_MAG_DFSR);\r\npr_debug("FT1000_REG_MAG_DFSR = 0x%x\n", tempword);\r\n}\r\nif (DrvErrNum)\r\npcmcia->PktIntfErr++;\r\n}\r\nstatic int ft1000_copy_up_pkt(struct net_device *dev)\r\n{\r\nu16 tempword;\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 len;\r\nstruct sk_buff *skb;\r\nu16 i;\r\nu8 *pbuffer = NULL;\r\nu8 *ptemp = NULL;\r\nu16 chksum;\r\nu32 *ptemplong;\r\nu32 templong;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\nlen = tempword;\r\n} else {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRL);\r\nlen = ntohs(tempword);\r\n}\r\nchksum = tempword;\r\npr_debug("Number of Bytes in FIFO = %d\n", len);\r\nif (len > ENET_MAX_SIZE) {\r\npr_debug("size of ethernet packet invalid\n");\r\nif (info->AsicID == MAGNEMITE_ID) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\n}\r\nft1000_flush_fifo(dev, DSP_PKTLEN_INFO);\r\ninfo->stats.rx_errors++;\r\nreturn FAILURE;\r\n}\r\nskb = dev_alloc_skb(len + 12 + 2);\r\nif (skb == NULL) {\r\nif (info->AsicID == MAGNEMITE_ID)\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\nft1000_flush_fifo(dev, 0);\r\ninfo->stats.rx_errors++;\r\nreturn FAILURE;\r\n}\r\npbuffer = (u8 *)skb_put(skb, len + 12);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nfor (i = 1; i < 7; i++) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\nchksum ^= tempword;\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\n} else {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRL);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRL);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRL);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\nchksum ^= tempword;\r\ntempword = ft1000_read_reg(dev, FT1000_REG_MAG_DFRH);\r\npr_debug("Pseudo = 0x%x\n", tempword);\r\n}\r\nif (chksum != tempword) {\r\npr_debug("Packet checksum mismatch 0x%x 0x%x\n",\r\nchksum, tempword);\r\nft1000_flush_fifo(dev, DSP_PKTPHCKSUM_INFO);\r\ninfo->stats.rx_errors++;\r\nkfree_skb(skb);\r\nreturn FAILURE;\r\n}\r\nptemp = pbuffer;\r\n*pbuffer++ = dev->dev_addr[0];\r\n*pbuffer++ = dev->dev_addr[1];\r\n*pbuffer++ = dev->dev_addr[2];\r\n*pbuffer++ = dev->dev_addr[3];\r\n*pbuffer++ = dev->dev_addr[4];\r\n*pbuffer++ = dev->dev_addr[5];\r\n*pbuffer++ = 0x00;\r\n*pbuffer++ = 0x07;\r\n*pbuffer++ = 0x35;\r\n*pbuffer++ = 0xff;\r\n*pbuffer++ = 0xff;\r\n*pbuffer++ = 0xfe;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nfor (i = 0; i < len / 2; i++) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\n*pbuffer++ = (u8) (tempword >> 8);\r\n*pbuffer++ = (u8)tempword;\r\nif (ft1000_chkcard(dev) == false) {\r\nkfree_skb(skb);\r\nreturn FAILURE;\r\n}\r\n}\r\nif (len & 0x0001) {\r\ntempword = ft1000_read_reg(dev, FT1000_REG_DFIFO);\r\n*pbuffer++ = (u8) (tempword >> 8);\r\n}\r\n} else {\r\nptemplong = (u32 *)pbuffer;\r\nfor (i = 0; i < len / 4; i++) {\r\ntemplong = inl(dev->base_addr + FT1000_REG_MAG_DFR);\r\npr_debug("Data = 0x%8x\n", templong);\r\n*ptemplong++ = templong;\r\n}\r\nif (len & 0x0003) {\r\ntemplong = inl(dev->base_addr + FT1000_REG_MAG_DFR);\r\npr_debug("Data = 0x%8x\n", templong);\r\n*ptemplong++ = templong;\r\n}\r\n}\r\npr_debug("Data passed to Protocol layer:\n");\r\nfor (i = 0; i < len + 12; i++)\r\npr_debug("Protocol Data: 0x%x\n", *ptemp++);\r\nskb->dev = dev;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_rx(skb);\r\ninfo->stats.rx_packets++;\r\ninfo->stats.rx_bytes += (len + 12);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword = len + 16;\r\nif (tempword & 0x01)\r\ntempword++;\r\ninfo->fifo_cnt += tempword;\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, FT1000_FIFO_LEN);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, info->fifo_cnt);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int ft1000_copy_down_pkt(struct net_device *dev, u16 *packet, u16 len)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nstruct ft1000_pcmcia *pcmcia = info->priv;\r\nunion {\r\nstruct pseudo_hdr blk;\r\nu16 buff[sizeof(struct pseudo_hdr) >> 1];\r\nu8 buffc[sizeof(struct pseudo_hdr)];\r\n} pseudo;\r\nint i;\r\nu32 *plong;\r\nif (len > ft1000_read_fifo_len(dev)) {\r\nudelay(10);\r\nif (len > ft1000_read_fifo_len(dev))\r\nudelay(20);\r\nif (len > ft1000_read_fifo_len(dev))\r\nudelay(20);\r\nif (len > ft1000_read_fifo_len(dev))\r\nudelay(20);\r\nif (len > ft1000_read_fifo_len(dev))\r\nudelay(20);\r\nif (len > ft1000_read_fifo_len(dev))\r\nudelay(20);\r\nif (len > ft1000_read_fifo_len(dev)) {\r\npr_debug("Transmit FIFO is full - pkt drop\n");\r\ninfo->stats.tx_errors++;\r\nreturn SUCCESS;\r\n}\r\n}\r\nif (info->AsicID == ELECTRABUZZ_ID)\r\npseudo.blk.length = len;\r\nelse\r\npseudo.blk.length = ntohs(len);\r\npseudo.blk.source = DSPID;\r\npseudo.blk.destination = HOSTID;\r\npseudo.blk.portdest = NETWORKID;\r\npseudo.blk.portsrc = DSPAIRID;\r\npseudo.blk.sh_str_id = 0;\r\npseudo.blk.control = 0;\r\npseudo.blk.rsvd1 = 0;\r\npseudo.blk.seq_num = 0;\r\npseudo.blk.rsvd2 = pcmcia->packetseqnum++;\r\npseudo.blk.qos_class = 0;\r\npseudo.blk.checksum = pseudo.buff[0];\r\nfor (i = 1; i < 7; i++)\r\npseudo.blk.checksum ^= pseudo.buff[i];\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_BEG, pseudo.buff[0]);\r\npr_debug("data 0 BEG = 0x%04x\n", pseudo.buff[0]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[1]);\r\npr_debug("data 1 MID = 0x%04x\n", pseudo.buff[1]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[2]);\r\npr_debug("data 2 MID = 0x%04x\n", pseudo.buff[2]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[3]);\r\npr_debug("data 3 MID = 0x%04x\n", pseudo.buff[3]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[4]);\r\npr_debug("data 4 MID = 0x%04x\n", pseudo.buff[4]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[5]);\r\npr_debug("data 5 MID = 0x%04x\n", pseudo.buff[5]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[6]);\r\npr_debug("data 6 MID = 0x%04x\n", pseudo.buff[6]);\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID, pseudo.buff[7]);\r\npr_debug("data 7 MID = 0x%04x\n", pseudo.buff[7]);\r\nfor (i = 0; i < (len >> 1) - 1; i++) {\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID,\r\nhtons(*packet));\r\npr_debug("data %d MID = 0x%04x\n",\r\ni + 8, htons(*packet));\r\npacket++;\r\n}\r\nif (len & 0x0001) {\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_MID,\r\nhtons(*packet));\r\npr_debug("data MID = 0x%04x\n", htons(*packet));\r\npacket++;\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_END,\r\nhtons(*packet));\r\npr_debug("data %d MID = 0x%04x\n",\r\ni + 8, htons(*packet));\r\n} else {\r\nft1000_write_reg(dev, FT1000_REG_UFIFO_END,\r\nhtons(*packet));\r\npr_debug("data %d MID = 0x%04x\n",\r\ni + 8, htons(*packet));\r\n}\r\n} else {\r\noutl(*(u32 *)&pseudo.buff[0],\r\ndev->base_addr + FT1000_REG_MAG_UFDR);\r\npr_debug("Pseudo = 0x%8x\n", *(u32 *)&pseudo.buff[0]);\r\noutl(*(u32 *)&pseudo.buff[2],\r\ndev->base_addr + FT1000_REG_MAG_UFDR);\r\npr_debug("Pseudo = 0x%8x\n", *(u32 *)&pseudo.buff[2]);\r\noutl(*(u32 *)&pseudo.buff[4],\r\ndev->base_addr + FT1000_REG_MAG_UFDR);\r\npr_debug("Pseudo = 0x%8x\n", *(u32 *)&pseudo.buff[4]);\r\noutl(*(u32 *)&pseudo.buff[6],\r\ndev->base_addr + FT1000_REG_MAG_UFDR);\r\npr_debug("Pseudo = 0x%8x\n", *(u32 *)&pseudo.buff[6]);\r\nplong = (u32 *)packet;\r\nfor (i = 0; i < (len >> 2); i++)\r\noutl(*plong++, dev->base_addr + FT1000_REG_MAG_UFDR);\r\nif (len & 0x0003) {\r\npr_debug("data = 0x%8x\n", *plong);\r\noutl(*plong++, dev->base_addr + FT1000_REG_MAG_UFDR);\r\n}\r\noutl(1, dev->base_addr + FT1000_REG_MAG_UFER);\r\n}\r\ninfo->stats.tx_packets++;\r\ninfo->stats.tx_bytes += (len + 14);\r\nreturn SUCCESS;\r\n}\r\nstatic struct net_device_stats *ft1000_stats(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nreturn &info->stats;\r\n}\r\nstatic int ft1000_open(struct net_device *dev)\r\n{\r\nft1000_reset_card(dev);\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + (2 * HZ);\r\npoll_timer.data = (u_long)dev;\r\nadd_timer(&poll_timer);\r\nreturn 0;\r\n}\r\nstatic int ft1000_close(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\ninfo->CardReady = 0;\r\ndel_timer(&poll_timer);\r\nif (ft1000_card_present == 1) {\r\npr_debug("Media is down\n");\r\nnetif_stop_queue(dev);\r\nft1000_disable_interrupts(dev);\r\nft1000_write_reg(dev, FT1000_REG_RESET, DSP_RESET_BIT);\r\nft1000_reset_asic(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ft1000_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu8 *pdata;\r\nif (skb == NULL) {\r\npr_debug("skb == NULL!!!\n");\r\nreturn 0;\r\n}\r\npr_debug("length of packet = %d\n", skb->len);\r\npdata = (u8 *)skb->data;\r\nif (info->mediastate == 0) {\r\npr_debug("mediastate is down\n");\r\nreturn SUCCESS;\r\n}\r\nif ((skb->len < ENET_HEADER_SIZE) || (skb->len > ENET_MAX_SIZE)) {\r\npr_debug("invalid ethernet length\n");\r\nreturn SUCCESS;\r\n}\r\nft1000_copy_down_pkt(dev, (u16 *) (pdata + ENET_HEADER_SIZE - 2),\r\nskb->len - ENET_HEADER_SIZE + 2);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ft1000_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 tempword;\r\nu16 inttype;\r\nint cnt;\r\nif (info->CardReady == 0) {\r\nft1000_disable_interrupts(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (ft1000_chkcard(dev) == false) {\r\nft1000_disable_interrupts(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nft1000_disable_interrupts(dev);\r\ninttype = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);\r\nwhile (inttype) {\r\nif (inttype & ISR_DOORBELL_PEND)\r\nft1000_parse_dpram_msg(dev);\r\nif (inttype & ISR_RCV) {\r\npr_debug("Data in FIFO\n");\r\ncnt = 0;\r\ndo {\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\ntempword = ft1000_read_reg(dev,\r\nFT1000_REG_DFIFO_STAT);\r\n} else {\r\ntempword = ft1000_read_reg(dev,\r\nFT1000_REG_MAG_DFSR);\r\n}\r\nif (!(tempword & 0x1f))\r\nbreak;\r\nft1000_copy_up_pkt(dev);\r\ncnt++;\r\n} while (cnt < MAX_RCV_LOOP);\r\n}\r\ntempword = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);\r\npr_debug("interrupt status register = 0x%x\n", tempword);\r\nft1000_write_reg(dev, FT1000_REG_SUP_ISR, tempword);\r\ninttype = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);\r\npr_debug("interrupt status register after clear = 0x%x\n",\r\ninttype);\r\n}\r\nft1000_enable_interrupts(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid stop_ft1000_card(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nstruct prov_record *ptr;\r\nstruct prov_record *tmp;\r\ninfo->CardReady = 0;\r\nft1000_card_present = 0;\r\nnetif_stop_queue(dev);\r\nft1000_disable_interrupts(dev);\r\nlist_for_each_entry_safe(ptr, tmp, &info->prov_list, list) {\r\nlist_del(&ptr->list);\r\nkfree(ptr->pprov_data);\r\nkfree(ptr);\r\n}\r\nkfree(info->priv);\r\nif (info->registered) {\r\nunregister_netdev(dev);\r\ninfo->registered = 0;\r\n}\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, 256);\r\nrelease_firmware(fw_entry);\r\nflarion_ft1000_cnt--;\r\n}\r\nstatic void ft1000_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ft1000_info *ft_info;\r\nft_info = netdev_priv(dev);\r\nstrlcpy(info->driver, "ft1000", sizeof(info->driver));\r\nsnprintf(info->bus_info, sizeof(info->bus_info), "PCMCIA 0x%lx",\r\ndev->base_addr);\r\nsnprintf(info->fw_version, sizeof(info->fw_version), "%d.%d.%d.%d",\r\nft_info->DspVer[0], ft_info->DspVer[1], ft_info->DspVer[2],\r\nft_info->DspVer[3]);\r\n}\r\nstatic u32 ft1000_get_link(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info;\r\ninfo = netdev_priv(dev);\r\nreturn info->mediastate;\r\n}\r\nstruct net_device *init_ft1000_card(struct pcmcia_device *link,\r\nvoid *ft1000_reset)\r\n{\r\nstruct ft1000_info *info;\r\nstruct ft1000_pcmcia *pcmcia;\r\nstruct net_device *dev;\r\nstatic const struct net_device_ops ft1000ops = {\r\n.ndo_open = &ft1000_open,\r\n.ndo_stop = &ft1000_close,\r\n.ndo_start_xmit = &ft1000_start_xmit,\r\n.ndo_get_stats = &ft1000_stats,\r\n};\r\npr_debug("irq = %d, port = 0x%04llx\n",\r\nlink->irq, (unsigned long long)link->resource[0]->start);\r\nflarion_ft1000_cnt++;\r\nif (flarion_ft1000_cnt > 1) {\r\nflarion_ft1000_cnt--;\r\ndev_info(&link->dev,\r\n"This driver can not support more than one instance\n");\r\nreturn NULL;\r\n}\r\ndev = alloc_etherdev(sizeof(struct ft1000_info));\r\nif (!dev) {\r\ndev_err(&link->dev, "Failed to allocate etherdev\n");\r\nreturn NULL;\r\n}\r\nSET_NETDEV_DEV(dev, &link->dev);\r\ninfo = netdev_priv(dev);\r\nmemset(info, 0, sizeof(struct ft1000_info));\r\npr_debug("address of dev = 0x%p\n", dev);\r\npr_debug("address of dev info = 0x%p\n", info);\r\npr_debug("device name = %s\n", dev->name);\r\nmemset(&info->stats, 0, sizeof(struct net_device_stats));\r\ninfo->priv = kzalloc(sizeof(struct ft1000_pcmcia), GFP_KERNEL);\r\npcmcia = info->priv;\r\npcmcia->link = link;\r\nspin_lock_init(&info->dpram_lock);\r\ninfo->DrvErrNum = 0;\r\ninfo->registered = 1;\r\ninfo->ft1000_reset = ft1000_reset;\r\ninfo->mediastate = 0;\r\ninfo->fifo_cnt = 0;\r\ninfo->CardReady = 0;\r\ninfo->DSP_TIME[0] = 0;\r\ninfo->DSP_TIME[1] = 0;\r\ninfo->DSP_TIME[2] = 0;\r\ninfo->DSP_TIME[3] = 0;\r\nflarion_ft1000_cnt = 0;\r\nINIT_LIST_HEAD(&info->prov_list);\r\ninfo->squeseqnum = 0;\r\ndev->netdev_ops = &ft1000ops;\r\npr_debug("device name = %s\n", dev->name);\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nif (pcmcia_get_mac_from_cis(link, dev)) {\r\nnetdev_err(dev, "Could not read mac address\n");\r\ngoto err_dev;\r\n}\r\nif (request_irq(dev->irq, ft1000_interrupt, IRQF_SHARED, dev->name,\r\ndev)) {\r\nnetdev_err(dev, "Could not request_irq\n");\r\ngoto err_dev;\r\n}\r\nif (request_region(dev->base_addr, 256, dev->name) == NULL) {\r\nnetdev_err(dev, "Could not request_region\n");\r\ngoto err_irq;\r\n}\r\nif (register_netdev(dev)) {\r\npr_debug("Could not register netdev\n");\r\ngoto err_reg;\r\n}\r\ninfo->AsicID = ft1000_read_reg(dev, FT1000_REG_ASIC_ID);\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\npr_debug("ELECTRABUZZ ASIC\n");\r\nif (request_firmware(&fw_entry, "ft1000.img",\r\n&link->dev) != 0) {\r\npr_info("Could not open ft1000.img\n");\r\ngoto err_unreg;\r\n}\r\n} else {\r\npr_debug("MAGNEMITE ASIC\n");\r\nif (request_firmware(&fw_entry, "ft2000.img",\r\n&link->dev) != 0) {\r\npr_info("Could not open ft2000.img\n");\r\ngoto err_unreg;\r\n}\r\n}\r\nft1000_enable_interrupts(dev);\r\nft1000_card_present = 1;\r\ndev->ethtool_ops = &ops;\r\npr_info("%s: addr 0x%04lx irq %d, MAC addr %pM\n",\r\ndev->name, dev->base_addr, dev->irq, dev->dev_addr);\r\nreturn dev;\r\nerr_unreg:\r\nunregister_netdev(dev);\r\nerr_reg:\r\nrelease_region(dev->base_addr, 256);\r\nerr_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_dev:\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}
