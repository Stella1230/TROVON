static ssize_t ft_parse_wwn(const char *name, u64 *wwn, int strict)\r\n{\r\nconst char *cp;\r\nchar c;\r\nu32 byte = 0;\r\nu32 pos = 0;\r\nu32 err;\r\nint val;\r\n*wwn = 0;\r\nfor (cp = name; cp < &name[FT_NAMELEN - 1]; cp++) {\r\nc = *cp;\r\nif (c == '\n' && cp[1] == '\0')\r\ncontinue;\r\nif (strict && pos++ == 2 && byte++ < 7) {\r\npos = 0;\r\nif (c == ':')\r\ncontinue;\r\nerr = 1;\r\ngoto fail;\r\n}\r\nif (c == '\0') {\r\nerr = 2;\r\nif (strict && byte != 8)\r\ngoto fail;\r\nreturn cp - name;\r\n}\r\nerr = 3;\r\nval = hex_to_bin(c);\r\nif (val < 0 || (strict && isupper(c)))\r\ngoto fail;\r\n*wwn = (*wwn << 4) | val;\r\n}\r\nerr = 4;\r\nfail:\r\npr_debug("err %u len %zu pos %u byte %u\n",\r\nerr, cp - name, pos, byte);\r\nreturn -1;\r\n}\r\nssize_t ft_format_wwn(char *buf, size_t len, u64 wwn)\r\n{\r\nu8 b[8];\r\nput_unaligned_be64(wwn, b);\r\nreturn snprintf(buf, len,\r\n"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",\r\nb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\n}\r\nstatic ssize_t ft_wwn_show(void *arg, char *buf)\r\n{\r\nu64 *wwn = arg;\r\nssize_t len;\r\nlen = ft_format_wwn(buf, PAGE_SIZE - 2, *wwn);\r\nbuf[len++] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t ft_wwn_store(void *arg, const char *buf, size_t len)\r\n{\r\nssize_t ret;\r\nu64 wwn;\r\nret = ft_parse_wwn(buf, &wwn, 0);\r\nif (ret > 0)\r\n*(u64 *)arg = wwn;\r\nreturn ret;\r\n}\r\nstatic ssize_t ft_nacl_show_port_name(\r\nstruct se_node_acl *se_nacl,\r\nchar *page)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_show(&acl->node_auth.port_name, page);\r\n}\r\nstatic ssize_t ft_nacl_store_port_name(\r\nstruct se_node_acl *se_nacl,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_store(&acl->node_auth.port_name, page, count);\r\n}\r\nstatic ssize_t ft_nacl_show_node_name(\r\nstruct se_node_acl *se_nacl,\r\nchar *page)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_show(&acl->node_auth.node_name, page);\r\n}\r\nstatic ssize_t ft_nacl_store_node_name(\r\nstruct se_node_acl *se_nacl,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_store(&acl->node_auth.node_name, page, count);\r\n}\r\nstatic int ft_init_nodeacl(struct se_node_acl *nacl, const char *name)\r\n{\r\nstruct ft_node_acl *acl =\r\ncontainer_of(nacl, struct ft_node_acl, se_node_acl);\r\nu64 wwpn;\r\nif (ft_parse_wwn(name, &wwpn, 1) < 0)\r\nreturn -EINVAL;\r\nacl->node_auth.port_name = wwpn;\r\nreturn 0;\r\n}\r\nstruct ft_node_acl *ft_acl_get(struct ft_tpg *tpg, struct fc_rport_priv *rdata)\r\n{\r\nstruct ft_node_acl *found = NULL;\r\nstruct ft_node_acl *acl;\r\nstruct se_portal_group *se_tpg = &tpg->se_tpg;\r\nstruct se_node_acl *se_acl;\r\nmutex_lock(&se_tpg->acl_node_mutex);\r\nlist_for_each_entry(se_acl, &se_tpg->acl_node_list, acl_list) {\r\nacl = container_of(se_acl, struct ft_node_acl, se_node_acl);\r\npr_debug("acl %p port_name %llx\n",\r\nacl, (unsigned long long)acl->node_auth.port_name);\r\nif (acl->node_auth.port_name == rdata->ids.port_name ||\r\nacl->node_auth.node_name == rdata->ids.node_name) {\r\npr_debug("acl %p port_name %llx matched\n", acl,\r\n(unsigned long long)rdata->ids.port_name);\r\nfound = acl;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&se_tpg->acl_node_mutex);\r\nreturn found;\r\n}\r\nstatic struct se_portal_group *ft_add_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ft_lport_wwn *ft_wwn;\r\nstruct ft_tpg *tpg;\r\nstruct workqueue_struct *wq;\r\nunsigned long index;\r\nint ret;\r\npr_debug("tcm_fc: add tpg %s\n", name);\r\nif (strstr(name, "tpgt_") != name)\r\nreturn NULL;\r\nret = kstrtoul(name + 5, 10, &index);\r\nif (ret)\r\nreturn NULL;\r\nif (index > UINT_MAX)\r\nreturn NULL;\r\nif ((index != 1)) {\r\npr_err("Error, a single TPG=1 is used for HW port mappings\n");\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nft_wwn = container_of(wwn, struct ft_lport_wwn, se_wwn);\r\ntpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\r\nif (!tpg)\r\nreturn NULL;\r\ntpg->index = index;\r\ntpg->lport_wwn = ft_wwn;\r\nINIT_LIST_HEAD(&tpg->lun_list);\r\nwq = alloc_workqueue("tcm_fc", 0, 1);\r\nif (!wq) {\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\r\nif (ret < 0) {\r\ndestroy_workqueue(wq);\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\ntpg->workqueue = wq;\r\nmutex_lock(&ft_lport_lock);\r\nft_wwn->tpg = tpg;\r\nmutex_unlock(&ft_lport_lock);\r\nreturn &tpg->se_tpg;\r\n}\r\nstatic void ft_del_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_tpg *tpg = container_of(se_tpg, struct ft_tpg, se_tpg);\r\nstruct ft_lport_wwn *ft_wwn = tpg->lport_wwn;\r\npr_debug("del tpg %s\n",\r\nconfig_item_name(&tpg->se_tpg.tpg_group.cg_item));\r\ndestroy_workqueue(tpg->workqueue);\r\nsynchronize_rcu();\r\nmutex_lock(&ft_lport_lock);\r\nft_wwn->tpg = NULL;\r\nif (tpg->tport) {\r\ntpg->tport->tpg = NULL;\r\ntpg->tport = NULL;\r\n}\r\nmutex_unlock(&ft_lport_lock);\r\ncore_tpg_deregister(se_tpg);\r\nkfree(tpg);\r\n}\r\nstruct ft_tpg *ft_lport_find_tpg(struct fc_lport *lport)\r\n{\r\nstruct ft_lport_wwn *ft_wwn;\r\nlist_for_each_entry(ft_wwn, &ft_wwn_list, ft_wwn_node) {\r\nif (ft_wwn->wwpn == lport->wwpn)\r\nreturn ft_wwn->tpg;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct se_wwn *ft_add_wwn(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ft_lport_wwn *ft_wwn;\r\nstruct ft_lport_wwn *old_ft_wwn;\r\nu64 wwpn;\r\npr_debug("add wwn %s\n", name);\r\nif (ft_parse_wwn(name, &wwpn, 1) < 0)\r\nreturn NULL;\r\nft_wwn = kzalloc(sizeof(*ft_wwn), GFP_KERNEL);\r\nif (!ft_wwn)\r\nreturn NULL;\r\nft_wwn->wwpn = wwpn;\r\nmutex_lock(&ft_lport_lock);\r\nlist_for_each_entry(old_ft_wwn, &ft_wwn_list, ft_wwn_node) {\r\nif (old_ft_wwn->wwpn == wwpn) {\r\nmutex_unlock(&ft_lport_lock);\r\nkfree(ft_wwn);\r\nreturn NULL;\r\n}\r\n}\r\nlist_add_tail(&ft_wwn->ft_wwn_node, &ft_wwn_list);\r\nft_format_wwn(ft_wwn->name, sizeof(ft_wwn->name), wwpn);\r\nmutex_unlock(&ft_lport_lock);\r\nreturn &ft_wwn->se_wwn;\r\n}\r\nstatic void ft_del_wwn(struct se_wwn *wwn)\r\n{\r\nstruct ft_lport_wwn *ft_wwn = container_of(wwn,\r\nstruct ft_lport_wwn, se_wwn);\r\npr_debug("del wwn %s\n", ft_wwn->name);\r\nmutex_lock(&ft_lport_lock);\r\nlist_del(&ft_wwn->ft_wwn_node);\r\nmutex_unlock(&ft_lport_lock);\r\nkfree(ft_wwn);\r\n}\r\nstatic ssize_t ft_wwn_show_attr_version(\r\nstruct target_fabric_configfs *tf,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "TCM FC " FT_VERSION " on %s/%s on "\r\n""UTS_RELEASE"\n", utsname()->sysname, utsname()->machine);\r\n}\r\nstatic inline struct ft_tpg *ft_tpg(struct se_portal_group *se_tpg)\r\n{\r\nreturn container_of(se_tpg, struct ft_tpg, se_tpg);\r\n}\r\nstatic char *ft_get_fabric_name(void)\r\n{\r\nreturn "fc";\r\n}\r\nstatic char *ft_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nreturn ft_tpg(se_tpg)->lport_wwn->name;\r\n}\r\nstatic u16 ft_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nreturn ft_tpg(se_tpg)->index;\r\n}\r\nstatic int ft_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ft_set_default_node_attr(struct se_node_acl *se_nacl)\r\n{\r\n}\r\nstatic u32 ft_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn ft_tpg(se_tpg)->index;\r\n}\r\nstatic int __init ft_init(void)\r\n{\r\nint ret;\r\nret = target_register_template(&ft_fabric_ops);\r\nif (ret)\r\ngoto out;\r\nret = fc_fc4_register_provider(FC_TYPE_FCP, &ft_prov);\r\nif (ret)\r\ngoto out_unregister_template;\r\nblocking_notifier_chain_register(&fc_lport_notifier_head, &ft_notifier);\r\nfc_lport_iterate(ft_lport_add, NULL);\r\nreturn 0;\r\nout_unregister_template:\r\ntarget_unregister_template(&ft_fabric_ops);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit ft_exit(void)\r\n{\r\nblocking_notifier_chain_unregister(&fc_lport_notifier_head,\r\n&ft_notifier);\r\nfc_fc4_deregister_provider(FC_TYPE_FCP, &ft_prov);\r\nfc_lport_iterate(ft_lport_del, NULL);\r\ntarget_unregister_template(&ft_fabric_ops);\r\nsynchronize_rcu();\r\n}
