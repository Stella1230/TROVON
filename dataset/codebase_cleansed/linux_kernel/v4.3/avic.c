static int avic_set_irq_fiq(unsigned int irq, unsigned int type)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nunsigned int irqt;\r\nirq = d->hwirq;\r\nif (irq >= AVIC_NUM_IRQS)\r\nreturn -EINVAL;\r\nif (irq < AVIC_NUM_IRQS / 2) {\r\nirqt = __raw_readl(avic_base + AVIC_INTTYPEL) & ~(1 << irq);\r\n__raw_writel(irqt | (!!type << irq), avic_base + AVIC_INTTYPEL);\r\n} else {\r\nirq -= AVIC_NUM_IRQS / 2;\r\nirqt = __raw_readl(avic_base + AVIC_INTTYPEH) & ~(1 << irq);\r\n__raw_writel(irqt | (!!type << irq), avic_base + AVIC_INTTYPEH);\r\n}\r\nreturn 0;\r\n}\r\nstatic void avic_irq_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nint idx = d->hwirq >> 5;\r\navic_saved_mask_reg[idx] = __raw_readl(avic_base + ct->regs.mask);\r\n__raw_writel(gc->wake_active, avic_base + ct->regs.mask);\r\n}\r\nstatic void avic_irq_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nint idx = d->hwirq >> 5;\r\n__raw_writel(avic_saved_mask_reg[idx], avic_base + ct->regs.mask);\r\n}\r\nstatic __init void avic_init_gc(int idx, unsigned int irq_start)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("mxc-avic", 1, irq_start, avic_base,\r\nhandle_level_irq);\r\ngc->private = &avic_extra_irq;\r\ngc->wake_enabled = IRQ_MSK(32);\r\nct = gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_ack = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\nct->chip.irq_suspend = avic_irq_suspend;\r\nct->chip.irq_resume = avic_irq_resume;\r\nct->regs.mask = !idx ? AVIC_INTENABLEL : AVIC_INTENABLEH;\r\nct->regs.ack = ct->regs.mask;\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, IRQ_NOREQUEST, 0);\r\n}\r\nstatic void __exception_irq_entry avic_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 nivector;\r\ndo {\r\nnivector = __raw_readl(avic_base + AVIC_NIVECSR) >> 16;\r\nif (nivector == 0xffff)\r\nbreak;\r\nhandle_domain_irq(domain, nivector, regs);\r\n} while (1);\r\n}\r\nvoid __init mxc_init_irq(void __iomem *irqbase)\r\n{\r\nstruct device_node *np;\r\nint irq_base;\r\nint i;\r\navic_base = irqbase;\r\n__raw_writel(0, avic_base + AVIC_INTCNTL);\r\n__raw_writel(0x1f, avic_base + AVIC_NIMASK);\r\n__raw_writel(0, avic_base + AVIC_INTENABLEH);\r\n__raw_writel(0, avic_base + AVIC_INTENABLEL);\r\n__raw_writel(0, avic_base + AVIC_INTTYPEH);\r\n__raw_writel(0, avic_base + AVIC_INTTYPEL);\r\nirq_base = irq_alloc_descs(-1, 0, AVIC_NUM_IRQS, numa_node_id());\r\nWARN_ON(irq_base < 0);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,avic");\r\ndomain = irq_domain_add_legacy(np, AVIC_NUM_IRQS, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nWARN_ON(!domain);\r\nfor (i = 0; i < AVIC_NUM_IRQS / 32; i++, irq_base += 32)\r\navic_init_gc(i, irq_base);\r\nfor (i = 0; i < 8; i++)\r\n__raw_writel(0, avic_base + AVIC_NIPRIORITY(i));\r\nset_handle_irq(avic_handle_irq);\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\nprintk(KERN_INFO "MXC IRQ initialized\n");\r\n}
