static u32 rsnd_adg_ssi_ws_timing_gen2(struct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_mod *mod = rsnd_io_to_mod_ssi(io);\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nint id = rsnd_mod_id(mod);\r\nint ws = id;\r\nif (rsnd_ssi_is_pin_sharing(rsnd_ssi_mod_get(priv, id))) {\r\nswitch (id) {\r\ncase 1:\r\ncase 2:\r\nws = 0;\r\nbreak;\r\ncase 4:\r\nws = 3;\r\nbreak;\r\ncase 8:\r\nws = 7;\r\nbreak;\r\n}\r\n}\r\nreturn (0x6 + ws) << 8;\r\n}\r\nint rsnd_adg_set_cmd_timsel_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nint id = rsnd_mod_id(mod);\r\nint shift = (id % 2) ? 16 : 0;\r\nu32 mask, val;\r\nval = rsnd_adg_ssi_ws_timing_gen2(io);\r\nval = val << shift;\r\nmask = 0xffff << shift;\r\nrsnd_mod_bset(mod, CMDOUT_TIMSEL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int rsnd_adg_set_src_timsel_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nu32 timsel)\r\n{\r\nint is_play = rsnd_io_is_play(io);\r\nint id = rsnd_mod_id(mod);\r\nint shift = (id % 2) ? 16 : 0;\r\nu32 mask, ws;\r\nu32 in, out;\r\nws = rsnd_adg_ssi_ws_timing_gen2(io);\r\nin = (is_play) ? timsel : ws;\r\nout = (is_play) ? ws : timsel;\r\nin = in << shift;\r\nout = out << shift;\r\nmask = 0xffff << shift;\r\nswitch (id / 2) {\r\ncase 0:\r\nrsnd_mod_bset(mod, SRCIN_TIMSEL0, mask, in);\r\nrsnd_mod_bset(mod, SRCOUT_TIMSEL0, mask, out);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(mod, SRCIN_TIMSEL1, mask, in);\r\nrsnd_mod_bset(mod, SRCOUT_TIMSEL1, mask, out);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(mod, SRCIN_TIMSEL2, mask, in);\r\nrsnd_mod_bset(mod, SRCOUT_TIMSEL2, mask, out);\r\nbreak;\r\ncase 3:\r\nrsnd_mod_bset(mod, SRCIN_TIMSEL3, mask, in);\r\nrsnd_mod_bset(mod, SRCOUT_TIMSEL3, mask, out);\r\nbreak;\r\ncase 4:\r\nrsnd_mod_bset(mod, SRCIN_TIMSEL4, mask, in);\r\nrsnd_mod_bset(mod, SRCOUT_TIMSEL4, mask, out);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint rsnd_adg_set_convert_clk_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nunsigned int src_rate,\r\nunsigned int dst_rate)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint idx, sel, div, step, ret;\r\nu32 val, en;\r\nunsigned int min, diff;\r\nunsigned int sel_rate [] = {\r\nclk_get_rate(adg->clk[CLKA]),\r\nclk_get_rate(adg->clk[CLKB]),\r\nclk_get_rate(adg->clk[CLKC]),\r\nadg->rbga_rate_for_441khz_div_6,\r\nadg->rbgb_rate_for_48khz_div_6,\r\n};\r\nmin = ~0;\r\nval = 0;\r\nen = 0;\r\nfor (sel = 0; sel < ARRAY_SIZE(sel_rate); sel++) {\r\nidx = 0;\r\nstep = 2;\r\nif (!sel_rate[sel])\r\ncontinue;\r\nfor (div = 2; div <= 98304; div += step) {\r\ndiff = abs(src_rate - sel_rate[sel] / div);\r\nif (min > diff) {\r\nval = (sel << 8) | idx;\r\nmin = diff;\r\nen = 1 << (sel + 1);\r\n}\r\nif ((idx > 2) && (idx % 2))\r\nstep *= 2;\r\nif (idx == 0x1c) {\r\ndiv += step;\r\nstep *= 2;\r\n}\r\nidx++;\r\n}\r\n}\r\nif (min == ~0) {\r\ndev_err(dev, "no Input clock\n");\r\nreturn -EIO;\r\n}\r\nret = rsnd_adg_set_src_timsel_gen2(mod, io, val);\r\nif (ret < 0) {\r\ndev_err(dev, "timsel error\n");\r\nreturn ret;\r\n}\r\nrsnd_mod_bset(mod, DIV_EN, en, en);\r\ndev_dbg(dev, "convert rate %d <-> %d\n", src_rate, dst_rate);\r\nreturn 0;\r\n}\r\nint rsnd_adg_set_convert_timing_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nu32 val = rsnd_adg_ssi_ws_timing_gen2(io);\r\nreturn rsnd_adg_set_src_timsel_gen2(mod, io, val);\r\n}\r\nint rsnd_adg_set_convert_clk_gen1(struct rsnd_priv *priv,\r\nstruct rsnd_mod *mod,\r\nunsigned int src_rate,\r\nunsigned int dst_rate)\r\n{\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint idx, sel, div, shift;\r\nu32 mask, val;\r\nint id = rsnd_mod_id(mod);\r\nunsigned int sel_rate [] = {\r\nclk_get_rate(adg->clk[CLKA]),\r\nclk_get_rate(adg->clk[CLKB]),\r\nclk_get_rate(adg->clk[CLKC]),\r\n0,\r\nadg->rbga_rate_for_441khz_div_6,\r\nadg->rbgb_rate_for_48khz_div_6,\r\n};\r\nfor (sel = 0; sel < ARRAY_SIZE(sel_rate); sel++) {\r\nfor (div = 128, idx = 0;\r\ndiv <= 2048;\r\ndiv *= 2, idx++) {\r\nif (src_rate == sel_rate[sel] / div) {\r\nval = (idx << 4) | sel;\r\ngoto find_rate;\r\n}\r\n}\r\n}\r\ndev_err(dev, "can't find convert src clk\n");\r\nreturn -EINVAL;\r\nfind_rate:\r\nshift = (id % 4) * 8;\r\nmask = 0xFF << shift;\r\nval = val << shift;\r\ndev_dbg(dev, "adg convert src clk = %02x\n", val);\r\nswitch (id / 4) {\r\ncase 0:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL3, mask, val);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL4, mask, val);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL5, mask, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rsnd_adg_set_ssi_clk(struct rsnd_mod *mod, u32 val)\r\n{\r\nint id = rsnd_mod_id(mod);\r\nint shift = (id % 4) * 8;\r\nu32 mask = 0xFF << shift;\r\nval = val << shift;\r\nif (id == 8)\r\nreturn;\r\nswitch (id / 4) {\r\ncase 0:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL0, mask, val);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL1, mask, val);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(mod, AUDIO_CLK_SEL2, mask, val);\r\nbreak;\r\n}\r\n}\r\nint rsnd_adg_ssi_clk_stop(struct rsnd_mod *mod)\r\n{\r\nrsnd_adg_set_ssi_clk(mod, 0);\r\nreturn 0;\r\n}\r\nint rsnd_adg_ssi_clk_try_start(struct rsnd_mod *mod, unsigned int rate)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct clk *clk;\r\nint i;\r\nu32 data;\r\nint sel_table[] = {\r\n[CLKA] = 0x1,\r\n[CLKB] = 0x2,\r\n[CLKC] = 0x3,\r\n[CLKI] = 0x0,\r\n};\r\ndev_dbg(dev, "request clock = %d\n", rate);\r\ndata = 0;\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nif (rate == clk_get_rate(clk)) {\r\ndata = sel_table[i];\r\ngoto found_clock;\r\n}\r\n}\r\nif (rate == adg->rbga_rate_for_441khz_div_6) {\r\ndata = 0x10;\r\ngoto found_clock;\r\n}\r\nif (rate == adg->rbgb_rate_for_48khz_div_6) {\r\ndata = 0x20;\r\ngoto found_clock;\r\n}\r\nreturn -EIO;\r\nfound_clock:\r\nrsnd_mod_bset(mod, SSICKR, 0x00FF0000, adg->ckr);\r\nrsnd_mod_write(mod, BRRA, 0x00000002);\r\nrsnd_mod_write(mod, BRRB, 0x00000002);\r\nrsnd_adg_set_ssi_clk(mod, data);\r\ndev_dbg(dev, "ADG: ssi%d selects clk%d = %d",\r\nrsnd_mod_id(mod), i, rate);\r\nreturn 0;\r\n}\r\nstatic void rsnd_adg_ssi_clk_init(struct rsnd_priv *priv, struct rsnd_adg *adg)\r\n{\r\nstruct clk *clk;\r\nunsigned long rate;\r\nu32 ckr;\r\nint i;\r\nint brg_table[] = {\r\n[CLKA] = 0x0,\r\n[CLKB] = 0x1,\r\n[CLKC] = 0x4,\r\n[CLKI] = 0x2,\r\n};\r\nckr = 0;\r\nadg->rbga_rate_for_441khz_div_6 = 0;\r\nadg->rbgb_rate_for_48khz_div_6 = 0;\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nrate = clk_get_rate(clk);\r\nif (0 == rate)\r\ncontinue;\r\nif (!adg->rbga_rate_for_441khz_div_6 && (0 == rate % 44100)) {\r\nadg->rbga_rate_for_441khz_div_6 = rate / 6;\r\nckr |= brg_table[i] << 20;\r\n}\r\nif (!adg->rbgb_rate_for_48khz_div_6 && (0 == rate % 48000)) {\r\nadg->rbgb_rate_for_48khz_div_6 = rate / 6;\r\nckr |= brg_table[i] << 16;\r\n}\r\n}\r\nadg->ckr = ckr;\r\n}\r\nint rsnd_adg_probe(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_adg *adg;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct clk *clk;\r\nint i;\r\nadg = devm_kzalloc(dev, sizeof(*adg), GFP_KERNEL);\r\nif (!adg) {\r\ndev_err(dev, "ADG allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\nadg->clk[CLKA] = devm_clk_get(dev, "clk_a");\r\nadg->clk[CLKB] = devm_clk_get(dev, "clk_b");\r\nadg->clk[CLKC] = devm_clk_get(dev, "clk_c");\r\nadg->clk[CLKI] = devm_clk_get(dev, "clk_i");\r\nfor_each_rsnd_clk(clk, adg, i)\r\ndev_dbg(dev, "clk %d : %p : %ld\n", i, clk, clk_get_rate(clk));\r\nrsnd_adg_ssi_clk_init(priv, adg);\r\npriv->adg = adg;\r\nreturn 0;\r\n}
