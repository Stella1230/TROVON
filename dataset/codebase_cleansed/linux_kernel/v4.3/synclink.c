static void* mgsl_get_text_ptr(void)\r\n{\r\nreturn mgsl_get_text_ptr;\r\n}\r\nstatic inline int mgsl_paranoia_check(struct mgsl_struct *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef MGSL_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for mgsl struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null mgsl_struct for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != MGSL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#else\r\nif (!info)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ldisc_receive_buf(struct tty_struct *tty,\r\nconst __u8 *data, char *flags, int count)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (!tty)\r\nreturn;\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->receive_buf)\r\nld->ops->receive_buf(tty, data, flags, count);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nstatic void mgsl_stop(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_stop"))\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("mgsl_stop(%s)\n",info->device_name);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (info->tx_enabled)\r\nusc_stop_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic void mgsl_start(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_start"))\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("mgsl_start(%s)\n",info->device_name);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!info->tx_enabled)\r\nusc_start_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic int mgsl_bh_action(struct mgsl_struct *info)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (info->pending_bh & BH_RECEIVE) {\r\ninfo->pending_bh &= ~BH_RECEIVE;\r\nrc = BH_RECEIVE;\r\n} else if (info->pending_bh & BH_TRANSMIT) {\r\ninfo->pending_bh &= ~BH_TRANSMIT;\r\nrc = BH_TRANSMIT;\r\n} else if (info->pending_bh & BH_STATUS) {\r\ninfo->pending_bh &= ~BH_STATUS;\r\nrc = BH_STATUS;\r\n}\r\nif (!rc) {\r\ninfo->bh_running = false;\r\ninfo->bh_requested = false;\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn rc;\r\n}\r\nstatic void mgsl_bh_handler(struct work_struct *work)\r\n{\r\nstruct mgsl_struct *info =\r\ncontainer_of(work, struct mgsl_struct, task);\r\nint action;\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_handler(%s) entry\n",\r\n__FILE__,__LINE__,info->device_name);\r\ninfo->bh_running = true;\r\nwhile((action = mgsl_bh_action(info)) != 0) {\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_handler() work item action=%d\n",\r\n__FILE__,__LINE__,action);\r\nswitch (action) {\r\ncase BH_RECEIVE:\r\nmgsl_bh_receive(info);\r\nbreak;\r\ncase BH_TRANSMIT:\r\nmgsl_bh_transmit(info);\r\nbreak;\r\ncase BH_STATUS:\r\nmgsl_bh_status(info);\r\nbreak;\r\ndefault:\r\nprintk("Unknown work item ID=%08X!\n", action);\r\nbreak;\r\n}\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_handler(%s) exit\n",\r\n__FILE__,__LINE__,info->device_name);\r\n}\r\nstatic void mgsl_bh_receive(struct mgsl_struct *info)\r\n{\r\nbool (*get_rx_frame)(struct mgsl_struct *info) =\r\n(info->params.mode == MGSL_MODE_HDLC ? mgsl_get_rx_frame : mgsl_get_raw_rx_frame);\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_receive(%s)\n",\r\n__FILE__,__LINE__,info->device_name);\r\ndo\r\n{\r\nif (info->rx_rcc_underrun) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_start_receiver(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn;\r\n}\r\n} while(get_rx_frame(info));\r\n}\r\nstatic void mgsl_bh_transmit(struct mgsl_struct *info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_transmit() entry on %s\n",\r\n__FILE__,__LINE__,info->device_name);\r\nif (tty)\r\ntty_wakeup(tty);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif ( !info->tx_active && info->loopmode_send_done_requested )\r\nusc_loopmode_send_done( info );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic void mgsl_bh_status(struct mgsl_struct *info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):mgsl_bh_status() entry on %s\n",\r\n__FILE__,__LINE__,info->device_name);\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\n}\r\nstatic void mgsl_isr_receive_status( struct mgsl_struct *info )\r\n{\r\nu16 status = usc_InReg( info, RCSR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_receive_status status=%04X\n",\r\n__FILE__,__LINE__,status);\r\nif ( (status & RXSTATUS_ABORT_RECEIVED) &&\r\ninfo->loopmode_insert_requested &&\r\nusc_loopmode_active(info) )\r\n{\r\n++info->icount.rxabort;\r\ninfo->loopmode_insert_requested = false;\r\ninfo->cmr_value &= ~BIT13;\r\nusc_OutReg(info, CMR, info->cmr_value);\r\nusc_OutReg(info, RICR,\r\n(usc_InReg(info, RICR) & ~RXSTATUS_ABORT_RECEIVED));\r\n}\r\nif (status & (RXSTATUS_EXITED_HUNT | RXSTATUS_IDLE_RECEIVED)) {\r\nif (status & RXSTATUS_EXITED_HUNT)\r\ninfo->icount.exithunt++;\r\nif (status & RXSTATUS_IDLE_RECEIVED)\r\ninfo->icount.rxidle++;\r\nwake_up_interruptible(&info->event_wait_q);\r\n}\r\nif (status & RXSTATUS_OVERRUN){\r\ninfo->icount.rxover++;\r\nusc_process_rxoverrun_sync( info );\r\n}\r\nusc_ClearIrqPendingBits( info, RECEIVE_STATUS );\r\nusc_UnlatchRxstatusBits( info, status );\r\n}\r\nstatic void mgsl_isr_transmit_status( struct mgsl_struct *info )\r\n{\r\nu16 status = usc_InReg( info, TCSR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_transmit_status status=%04X\n",\r\n__FILE__,__LINE__,status);\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS );\r\nusc_UnlatchTxstatusBits( info, status );\r\nif ( status & (TXSTATUS_UNDERRUN | TXSTATUS_ABORT_SENT) )\r\n{\r\nusc_DmaCmd( info, DmaCmd_ResetTxChannel );\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\n}\r\nif ( status & TXSTATUS_EOF_SENT )\r\ninfo->icount.txok++;\r\nelse if ( status & TXSTATUS_UNDERRUN )\r\ninfo->icount.txunder++;\r\nelse if ( status & TXSTATUS_ABORT_SENT )\r\ninfo->icount.txabort++;\r\nelse\r\ninfo->icount.txunder++;\r\ninfo->tx_active = false;\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\ndel_timer(&info->tx_timer);\r\nif ( info->drop_rts_on_tx_done ) {\r\nusc_get_serial_signals( info );\r\nif ( info->serial_signals & SerialSignal_RTS ) {\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nusc_set_serial_signals( info );\r\n}\r\ninfo->drop_rts_on_tx_done = false;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\n{\r\nif (info->port.tty->stopped || info->port.tty->hw_stopped) {\r\nusc_stop_transmitter(info);\r\nreturn;\r\n}\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\nstatic void mgsl_isr_io_pin( struct mgsl_struct *info )\r\n{\r\nstruct mgsl_icount *icount;\r\nu16 status = usc_InReg( info, MISR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_io_pin status=%04X\n",\r\n__FILE__,__LINE__,status);\r\nusc_ClearIrqPendingBits( info, IO_PIN );\r\nusc_UnlatchIostatusBits( info, status );\r\nif (status & (MISCSTATUS_CTS_LATCHED | MISCSTATUS_DCD_LATCHED |\r\nMISCSTATUS_DSR_LATCHED | MISCSTATUS_RI_LATCHED) ) {\r\nicount = &info->icount;\r\nif (status & MISCSTATUS_RI_LATCHED) {\r\nif ((info->ri_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nusc_DisablestatusIrqs(info,SICR_RI);\r\nicount->rng++;\r\nif ( status & MISCSTATUS_RI )\r\ninfo->input_signal_events.ri_up++;\r\nelse\r\ninfo->input_signal_events.ri_down++;\r\n}\r\nif (status & MISCSTATUS_DSR_LATCHED) {\r\nif ((info->dsr_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nusc_DisablestatusIrqs(info,SICR_DSR);\r\nicount->dsr++;\r\nif ( status & MISCSTATUS_DSR )\r\ninfo->input_signal_events.dsr_up++;\r\nelse\r\ninfo->input_signal_events.dsr_down++;\r\n}\r\nif (status & MISCSTATUS_DCD_LATCHED) {\r\nif ((info->dcd_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nusc_DisablestatusIrqs(info,SICR_DCD);\r\nicount->dcd++;\r\nif (status & MISCSTATUS_DCD) {\r\ninfo->input_signal_events.dcd_up++;\r\n} else\r\ninfo->input_signal_events.dcd_down++;\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount) {\r\nif (status & MISCSTATUS_DCD)\r\nnetif_carrier_on(info->netdev);\r\nelse\r\nnetif_carrier_off(info->netdev);\r\n}\r\n#endif\r\n}\r\nif (status & MISCSTATUS_CTS_LATCHED)\r\n{\r\nif ((info->cts_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT)\r\nusc_DisablestatusIrqs(info,SICR_CTS);\r\nicount->cts++;\r\nif ( status & MISCSTATUS_CTS )\r\ninfo->input_signal_events.cts_up++;\r\nelse\r\ninfo->input_signal_events.cts_down++;\r\n}\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\nif ( (info->port.flags & ASYNC_CHECK_CD) &&\r\n(status & MISCSTATUS_DCD_LATCHED) ) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s CD now %s...", info->device_name,\r\n(status & MISCSTATUS_DCD) ? "on" : "off");\r\nif (status & MISCSTATUS_DCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("doing serial hangup...");\r\nif (info->port.tty)\r\ntty_hangup(info->port.tty);\r\n}\r\n}\r\nif (tty_port_cts_enabled(&info->port) &&\r\n(status & MISCSTATUS_CTS_LATCHED) ) {\r\nif (info->port.tty->hw_stopped) {\r\nif (status & MISCSTATUS_CTS) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("CTS tx start...");\r\nif (info->port.tty)\r\ninfo->port.tty->hw_stopped = 0;\r\nusc_start_transmitter(info);\r\ninfo->pending_bh |= BH_TRANSMIT;\r\nreturn;\r\n}\r\n} else {\r\nif (!(status & MISCSTATUS_CTS)) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("CTS tx stop...");\r\nif (info->port.tty)\r\ninfo->port.tty->hw_stopped = 1;\r\nusc_stop_transmitter(info);\r\n}\r\n}\r\n}\r\n}\r\ninfo->pending_bh |= BH_STATUS;\r\nif ( status & MISCSTATUS_TXC_LATCHED ){\r\nusc_OutReg( info, SICR,\r\n(unsigned short)(usc_InReg(info,SICR) & ~(SICR_TXC_ACTIVE+SICR_TXC_INACTIVE)) );\r\nusc_UnlatchIostatusBits( info, MISCSTATUS_TXC_LATCHED );\r\ninfo->irq_occurred = true;\r\n}\r\n}\r\nstatic void mgsl_isr_transmit_data( struct mgsl_struct *info )\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_transmit_data xmit_cnt=%d\n",\r\n__FILE__,__LINE__,info->xmit_cnt);\r\nusc_ClearIrqPendingBits( info, TRANSMIT_DATA );\r\nif (info->port.tty->stopped || info->port.tty->hw_stopped) {\r\nusc_stop_transmitter(info);\r\nreturn;\r\n}\r\nif ( info->xmit_cnt )\r\nusc_load_txfifo( info );\r\nelse\r\ninfo->tx_active = false;\r\nif (info->xmit_cnt < WAKEUP_CHARS)\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\nstatic void mgsl_isr_receive_data( struct mgsl_struct *info )\r\n{\r\nint Fifocount;\r\nu16 status;\r\nint work = 0;\r\nunsigned char DataByte;\r\nstruct mgsl_icount *icount = &info->icount;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_receive_data\n",\r\n__FILE__,__LINE__);\r\nusc_ClearIrqPendingBits( info, RECEIVE_DATA );\r\nusc_RCmd( info, RCmd_SelectRicrRxFifostatus );\r\nusc_OutReg( info, RICR+LSBONLY, (u16)(usc_InReg(info, RICR+LSBONLY) & ~BIT3 ));\r\nwhile( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {\r\nint flag;\r\noutw( (inw(info->io_base + CCAR) & 0x0780) | (RDR+LSBONLY),\r\ninfo->io_base + CCAR );\r\nDataByte = inb( info->io_base + CCAR );\r\nstatus = usc_InReg(info, RCSR);\r\nif ( status & (RXSTATUS_FRAMING_ERROR | RXSTATUS_PARITY_ERROR |\r\nRXSTATUS_OVERRUN | RXSTATUS_BREAK_RECEIVED) )\r\nusc_UnlatchRxstatusBits(info,RXSTATUS_ALL);\r\nicount->rx++;\r\nflag = 0;\r\nif ( status & (RXSTATUS_FRAMING_ERROR | RXSTATUS_PARITY_ERROR |\r\nRXSTATUS_OVERRUN | RXSTATUS_BREAK_RECEIVED) ) {\r\nprintk("rxerr=%04X\n",status);\r\nif ( status & RXSTATUS_BREAK_RECEIVED ) {\r\nstatus &= ~(RXSTATUS_FRAMING_ERROR | RXSTATUS_PARITY_ERROR);\r\nicount->brk++;\r\n} else if (status & RXSTATUS_PARITY_ERROR)\r\nicount->parity++;\r\nelse if (status & RXSTATUS_FRAMING_ERROR)\r\nicount->frame++;\r\nelse if (status & RXSTATUS_OVERRUN) {\r\nusc_RTCmd(info,RTCmd_PurgeRxFifo);\r\nicount->overrun++;\r\n}\r\nif (status & info->ignore_status_mask)\r\ncontinue;\r\nstatus &= info->read_status_mask;\r\nif (status & RXSTATUS_BREAK_RECEIVED) {\r\nflag = TTY_BREAK;\r\nif (info->port.flags & ASYNC_SAK)\r\ndo_SAK(info->port.tty);\r\n} else if (status & RXSTATUS_PARITY_ERROR)\r\nflag = TTY_PARITY;\r\nelse if (status & RXSTATUS_FRAMING_ERROR)\r\nflag = TTY_FRAME;\r\n}\r\ntty_insert_flip_char(&info->port, DataByte, flag);\r\nif (status & RXSTATUS_OVERRUN) {\r\nwork += tty_insert_flip_char(&info->port, 0, TTY_OVERRUN);\r\n}\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_ISR ) {\r\nprintk("%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d\n",\r\n__FILE__,__LINE__,icount->rx,icount->brk,\r\nicount->parity,icount->frame,icount->overrun);\r\n}\r\nif(work)\r\ntty_flip_buffer_push(&info->port);\r\n}\r\nstatic void mgsl_isr_misc( struct mgsl_struct *info )\r\n{\r\nu16 status = usc_InReg( info, MISR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_misc status=%04X\n",\r\n__FILE__,__LINE__,status);\r\nif ((status & MISCSTATUS_RCC_UNDERRUN) &&\r\n(info->params.mode == MGSL_MODE_HDLC)) {\r\nusc_EnableReceiver(info,DISABLE_UNCONDITIONAL);\r\nusc_DmaCmd(info, DmaCmd_ResetRxChannel);\r\nusc_UnlatchRxstatusBits(info, RXSTATUS_ALL);\r\nusc_ClearIrqPendingBits(info, RECEIVE_DATA | RECEIVE_STATUS);\r\nusc_DisableInterrupts(info, RECEIVE_DATA | RECEIVE_STATUS);\r\ninfo->pending_bh |= BH_RECEIVE;\r\ninfo->rx_rcc_underrun = true;\r\n}\r\nusc_ClearIrqPendingBits( info, MISC );\r\nusc_UnlatchMiscstatusBits( info, status );\r\n}\r\nstatic void mgsl_isr_null( struct mgsl_struct *info )\r\n{\r\n}\r\nstatic void mgsl_isr_receive_dma( struct mgsl_struct *info )\r\n{\r\nu16 status;\r\nusc_OutDmaReg( info, CDIR, BIT9 | BIT1 );\r\nstatus = usc_InDmaReg( info, RDMR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_receive_dma(%s) status=%04X\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\ninfo->pending_bh |= BH_RECEIVE;\r\nif ( status & BIT3 ) {\r\ninfo->rx_overflow = true;\r\ninfo->icount.buf_overrun++;\r\n}\r\n}\r\nstatic void mgsl_isr_transmit_dma( struct mgsl_struct *info )\r\n{\r\nu16 status;\r\nusc_OutDmaReg(info, CDIR, BIT8 | BIT0 );\r\nstatus = usc_InDmaReg( info, TDMR );\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):mgsl_isr_transmit_dma(%s) status=%04X\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\nif ( status & BIT2 ) {\r\n--info->tx_dma_buffers_used;\r\nif ( load_next_tx_holding_buffer(info) ) {\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t mgsl_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct mgsl_struct *info = dev_id;\r\nu16 UscVector;\r\nu16 DmaVector;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk(KERN_DEBUG "%s(%d):mgsl_interrupt(%d)entry.\n",\r\n__FILE__, __LINE__, info->irq_level);\r\nspin_lock(&info->irq_spinlock);\r\nfor(;;) {\r\nUscVector = usc_InReg(info, IVR) >> 9;\r\nDmaVector = usc_InDmaReg(info, DIVR);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s UscVector=%08X DmaVector=%08X\n",\r\n__FILE__,__LINE__,info->device_name,UscVector,DmaVector);\r\nif ( !UscVector && !DmaVector )\r\nbreak;\r\nif ( UscVector )\r\n(*UscIsrTable[UscVector])(info);\r\nelse if ( (DmaVector&(BIT10|BIT9)) == BIT10)\r\nmgsl_isr_transmit_dma(info);\r\nelse\r\nmgsl_isr_receive_dma(info);\r\nif ( info->isr_overflow ) {\r\nprintk(KERN_ERR "%s(%d):%s isr overflow irq=%d\n",\r\n__FILE__, __LINE__, info->device_name, info->irq_level);\r\nusc_DisableMasterIrqBit(info);\r\nusc_DisableDmaInterrupts(info,DICR_MASTER);\r\nbreak;\r\n}\r\n}\r\nif ( info->pending_bh && !info->bh_running && !info->bh_requested ) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s queueing bh task.\n",\r\n__FILE__,__LINE__,info->device_name);\r\nschedule_work(&info->task);\r\ninfo->bh_requested = true;\r\n}\r\nspin_unlock(&info->irq_spinlock);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk(KERN_DEBUG "%s(%d):mgsl_interrupt(%d)exit.\n",\r\n__FILE__, __LINE__, info->irq_level);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(struct mgsl_struct * info)\r\n{\r\nint retval = 0;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):mgsl_startup(%s)\n",__FILE__,__LINE__,info->device_name);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\nreturn 0;\r\nif (!info->xmit_buf) {\r\ninfo->xmit_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);\r\nif (!info->xmit_buf) {\r\nprintk(KERN_ERR"%s(%d):%s can't allocate transmit buffer\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninfo->pending_bh = 0;\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\nsetup_timer(&info->tx_timer, mgsl_tx_timeout, (unsigned long)info);\r\nretval = mgsl_claim_resources(info);\r\nif ( !retval )\r\nretval = mgsl_adapter_test(info);\r\nif ( retval ) {\r\nif (capable(CAP_SYS_ADMIN) && info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\nmgsl_release_resources(info);\r\nreturn retval;\r\n}\r\nmgsl_change_params(info);\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->port.flags |= ASYNC_INITIALIZED;\r\nreturn 0;\r\n}\r\nstatic void shutdown(struct mgsl_struct * info)\r\n{\r\nunsigned long flags;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_shutdown(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ndel_timer_sync(&info->tx_timer);\r\nif (info->xmit_buf) {\r\nfree_page((unsigned long) info->xmit_buf);\r\ninfo->xmit_buf = NULL;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_DisableMasterIrqBit(info);\r\nusc_stop_receiver(info);\r\nusc_stop_transmitter(info);\r\nusc_DisableInterrupts(info,RECEIVE_DATA | RECEIVE_STATUS |\r\nTRANSMIT_DATA | TRANSMIT_STATUS | IO_PIN | MISC );\r\nusc_DisableDmaInterrupts(info,DICR_MASTER + DICR_TRANSMIT + DICR_RECEIVE);\r\nusc_OutReg(info, PCR, (u16)((usc_InReg(info, PCR) | BIT15) | BIT14));\r\nusc_OutReg(info, PCR, (u16)((usc_InReg(info, PCR) | BIT13) | BIT12));\r\nif (!info->port.tty || info->port.tty->termios.c_cflag & HUPCL) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nusc_set_serial_signals(info);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nmgsl_release_resources(info);\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->port.flags &= ~ASYNC_INITIALIZED;\r\n}\r\nstatic void mgsl_program_hw(struct mgsl_struct *info)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_stop_receiver(info);\r\nusc_stop_transmitter(info);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nif (info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ||\r\ninfo->netcount)\r\nusc_set_sync_mode(info);\r\nelse\r\nusc_set_async_mode(info);\r\nusc_set_serial_signals(info);\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\nusc_EnableStatusIrqs(info,SICR_CTS+SICR_DSR+SICR_DCD+SICR_RI);\r\nusc_EnableInterrupts(info, IO_PIN);\r\nusc_get_serial_signals(info);\r\nif (info->netcount || info->port.tty->termios.c_cflag & CREAD)\r\nusc_start_receiver(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic void mgsl_change_params(struct mgsl_struct *info)\r\n{\r\nunsigned cflag;\r\nint bits_per_char;\r\nif (!info->port.tty)\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_change_params(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\ncflag = info->port.tty->termios.c_cflag;\r\nif (cflag & CBAUD)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nswitch (cflag & CSIZE) {\r\ncase CS5: info->params.data_bits = 5; break;\r\ncase CS6: info->params.data_bits = 6; break;\r\ncase CS7: info->params.data_bits = 7; break;\r\ncase CS8: info->params.data_bits = 8; break;\r\ndefault: info->params.data_bits = 7; break;\r\n}\r\nif (cflag & CSTOPB)\r\ninfo->params.stop_bits = 2;\r\nelse\r\ninfo->params.stop_bits = 1;\r\ninfo->params.parity = ASYNC_PARITY_NONE;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\ninfo->params.parity = ASYNC_PARITY_ODD;\r\nelse\r\ninfo->params.parity = ASYNC_PARITY_EVEN;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ninfo->params.parity = ASYNC_PARITY_SPACE;\r\n#endif\r\n}\r\nbits_per_char = info->params.data_bits +\r\ninfo->params.stop_bits + 1;\r\nif (info->params.data_rate <= 460800)\r\ninfo->params.data_rate = tty_get_baud_rate(info->port.tty);\r\nif ( info->params.data_rate ) {\r\ninfo->timeout = (32*HZ*bits_per_char) /\r\ninfo->params.data_rate;\r\n}\r\ninfo->timeout += HZ/50;\r\nif (cflag & CRTSCTS)\r\ninfo->port.flags |= ASYNC_CTS_FLOW;\r\nelse\r\ninfo->port.flags &= ~ASYNC_CTS_FLOW;\r\nif (cflag & CLOCAL)\r\ninfo->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\ninfo->port.flags |= ASYNC_CHECK_CD;\r\ninfo->read_status_mask = RXSTATUS_OVERRUN;\r\nif (I_INPCK(info->port.tty))\r\ninfo->read_status_mask |= RXSTATUS_PARITY_ERROR | RXSTATUS_FRAMING_ERROR;\r\nif (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))\r\ninfo->read_status_mask |= RXSTATUS_BREAK_RECEIVED;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= RXSTATUS_PARITY_ERROR | RXSTATUS_FRAMING_ERROR;\r\nif (I_IGNBRK(info->port.tty)) {\r\ninfo->ignore_status_mask |= RXSTATUS_BREAK_RECEIVED;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= RXSTATUS_OVERRUN;\r\n}\r\nmgsl_program_hw(info);\r\n}\r\nstatic int mgsl_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (debug_level >= DEBUG_LEVEL_INFO) {\r\nprintk(KERN_DEBUG "%s(%d):mgsl_put_char(%d) on %s\n",\r\n__FILE__, __LINE__, ch, info->device_name);\r\n}\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_put_char"))\r\nreturn 0;\r\nif (!info->xmit_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->irq_spinlock, flags);\r\nif ((info->params.mode == MGSL_MODE_ASYNC ) || !info->tx_active) {\r\nif (info->xmit_cnt < SERIAL_XMIT_SIZE - 1) {\r\ninfo->xmit_buf[info->xmit_head++] = ch;\r\ninfo->xmit_head &= SERIAL_XMIT_SIZE-1;\r\ninfo->xmit_cnt++;\r\nret = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic void mgsl_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_flush_chars() entry on %s xmit_cnt=%d\n",\r\n__FILE__,__LINE__,info->device_name,info->xmit_cnt);\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_flush_chars"))\r\nreturn;\r\nif (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||\r\n!info->xmit_buf)\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_flush_chars() entry on %s starting transmitter\n",\r\n__FILE__,__LINE__,info->device_name );\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!info->tx_active) {\r\nif ( (info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW) && info->xmit_cnt ) {\r\nmgsl_load_tx_dma_buffer(info,\r\ninfo->xmit_buf,info->xmit_cnt);\r\n}\r\nusc_start_transmitter(info);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic int mgsl_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_write(%s) count=%d\n",\r\n__FILE__,__LINE__,info->device_name,count);\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_write"))\r\ngoto cleanup;\r\nif (!info->xmit_buf)\r\ngoto cleanup;\r\nif ( info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nif (info->tx_active) {\r\nif ( info->params.mode == MGSL_MODE_HDLC ) {\r\nret = 0;\r\ngoto cleanup;\r\n}\r\nif (info->tx_holding_count >= info->num_tx_holding_buffers ) {\r\nret = 0;\r\ngoto cleanup;\r\n}\r\nret = count;\r\nsave_tx_buffer_request(info,buf,count);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nload_next_tx_holding_buffer(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\ngoto cleanup;\r\n}\r\nif ( (info->params.flags & HDLC_FLAG_HDLC_LOOPMODE) &&\r\n!usc_loopmode_active(info) )\r\n{\r\nret = 0;\r\ngoto cleanup;\r\n}\r\nif ( info->xmit_cnt ) {\r\nret = 0;\r\nmgsl_load_tx_dma_buffer(info,\r\ninfo->xmit_buf,info->xmit_cnt);\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_write(%s) sync xmit_cnt flushing\n",\r\n__FILE__,__LINE__,info->device_name);\r\n} else {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_write(%s) sync transmit accepted\n",\r\n__FILE__,__LINE__,info->device_name);\r\nret = count;\r\ninfo->xmit_cnt = count;\r\nmgsl_load_tx_dma_buffer(info,buf,count);\r\n}\r\n} else {\r\nwhile (1) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nc = min_t(int, count,\r\nmin(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,\r\nSERIAL_XMIT_SIZE - info->xmit_head));\r\nif (c <= 0) {\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nbreak;\r\n}\r\nmemcpy(info->xmit_buf + info->xmit_head, buf, c);\r\ninfo->xmit_head = ((info->xmit_head + c) &\r\n(SERIAL_XMIT_SIZE-1));\r\ninfo->xmit_cnt += c;\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\n}\r\nif (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!info->tx_active)\r\nusc_start_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\ncleanup:\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_write(%s) returning=%d\n",\r\n__FILE__,__LINE__,info->device_name,ret);\r\nreturn ret;\r\n}\r\nstatic int mgsl_write_room(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nint ret;\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_write_room"))\r\nreturn 0;\r\nret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;\r\nif (ret < 0)\r\nret = 0;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_write_room(%s)=%d\n",\r\n__FILE__,__LINE__, info->device_name,ret );\r\nif ( info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nif ( info->tx_active )\r\nreturn 0;\r\nelse\r\nreturn HDLC_MAX_FRAME_SIZE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mgsl_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_chars_in_buffer(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_chars_in_buffer"))\r\nreturn 0;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_chars_in_buffer(%s)=%d\n",\r\n__FILE__,__LINE__, info->device_name,info->xmit_cnt );\r\nif ( info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nif ( info->tx_active )\r\nreturn info->max_frame_size;\r\nelse\r\nreturn 0;\r\n}\r\nreturn info->xmit_cnt;\r\n}\r\nstatic void mgsl_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_flush_buffer(%s) entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_flush_buffer"))\r\nreturn;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\ndel_timer(&info->tx_timer);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void mgsl_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_send_xchar(%s,%d)\n",\r\n__FILE__,__LINE__, info->device_name, ch );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_send_xchar"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!info->tx_enabled)\r\nusc_start_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nstatic void mgsl_throttle(struct tty_struct * tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_throttle(%s) entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nmgsl_send_xchar(tty, STOP_CHAR(tty));\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nstatic void mgsl_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_unthrottle(%s) entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nmgsl_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nstatic int mgsl_get_stats(struct mgsl_struct * info, struct mgsl_icount __user *user_icount)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_get_params(%s)\n",\r\n__FILE__,__LINE__, info->device_name);\r\nif (!user_icount) {\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\n} else {\r\nmutex_lock(&info->port.mutex);\r\nCOPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));\r\nmutex_unlock(&info->port.mutex);\r\nif (err)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgsl_get_params(struct mgsl_struct * info, MGSL_PARAMS __user *user_params)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_get_params(%s)\n",\r\n__FILE__,__LINE__, info->device_name);\r\nmutex_lock(&info->port.mutex);\r\nCOPY_TO_USER(err,user_params, &info->params, sizeof(MGSL_PARAMS));\r\nmutex_unlock(&info->port.mutex);\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_get_params(%s) user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgsl_set_params(struct mgsl_struct * info, MGSL_PARAMS __user *new_params)\r\n{\r\nunsigned long flags;\r\nMGSL_PARAMS tmp_params;\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_set_params %s\n", __FILE__,__LINE__,\r\ninfo->device_name );\r\nCOPY_FROM_USER(err,&tmp_params, new_params, sizeof(MGSL_PARAMS));\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_set_params(%s) user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&info->port.mutex);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nmemcpy(&info->params,&tmp_params,sizeof(MGSL_PARAMS));\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nmgsl_change_params(info);\r\nmutex_unlock(&info->port.mutex);\r\nreturn 0;\r\n}\r\nstatic int mgsl_get_txidle(struct mgsl_struct * info, int __user *idle_mode)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_get_txidle(%s)=%d\n",\r\n__FILE__,__LINE__, info->device_name, info->idle_mode);\r\nCOPY_TO_USER(err,idle_mode, &info->idle_mode, sizeof(int));\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_get_txidle(%s) user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgsl_set_txidle(struct mgsl_struct * info, int idle_mode)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_set_txidle(%s,%d)\n", __FILE__,__LINE__,\r\ninfo->device_name, idle_mode );\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ninfo->idle_mode = idle_mode;\r\nusc_set_txidle( info );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int mgsl_txenable(struct mgsl_struct * info, int enable)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_txenable(%s,%d)\n", __FILE__,__LINE__,\r\ninfo->device_name, enable);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif ( enable ) {\r\nif ( !info->tx_enabled ) {\r\nusc_start_transmitter(info);\r\nif ( info->params.flags & HDLC_FLAG_HDLC_LOOPMODE )\r\nusc_loopmode_insert_request( info );\r\n}\r\n} else {\r\nif ( info->tx_enabled )\r\nusc_stop_transmitter(info);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int mgsl_txabort(struct mgsl_struct * info)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_txabort(%s)\n", __FILE__,__LINE__,\r\ninfo->device_name);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif ( info->tx_active && info->params.mode == MGSL_MODE_HDLC )\r\n{\r\nif ( info->params.flags & HDLC_FLAG_HDLC_LOOPMODE )\r\nusc_loopmode_cancel_transmit( info );\r\nelse\r\nusc_TCmd(info,TCmd_SendAbort);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int mgsl_rxenable(struct mgsl_struct * info, int enable)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_rxenable(%s,%d)\n", __FILE__,__LINE__,\r\ninfo->device_name, enable);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif ( enable ) {\r\nif ( !info->rx_enabled )\r\nusc_start_receiver(info);\r\n} else {\r\nif ( info->rx_enabled )\r\nusc_stop_receiver(info);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int mgsl_wait_event(struct mgsl_struct * info, int __user * mask_ptr)\r\n{\r\nunsigned long flags;\r\nint s;\r\nint rc=0;\r\nstruct mgsl_icount cprev, cnow;\r\nint events;\r\nint mask;\r\nstruct _input_signal_events oldsigs, newsigs;\r\nDECLARE_WAITQUEUE(wait, current);\r\nCOPY_FROM_USER(rc,&mask, mask_ptr, sizeof(int));\r\nif (rc) {\r\nreturn -EFAULT;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_wait_event(%s,%d)\n", __FILE__,__LINE__,\r\ninfo->device_name, mask);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_get_serial_signals(info);\r\ns = info->serial_signals;\r\nevents = mask &\r\n( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +\r\n((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +\r\n((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +\r\n((s & SerialSignal_RI) ? MgslEvent_RiActive :MgslEvent_RiInactive) );\r\nif (events) {\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\ngoto exit;\r\n}\r\ncprev = info->icount;\r\noldsigs = info->input_signal_events;\r\nif (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {\r\nu16 oldreg = usc_InReg(info,RICR);\r\nu16 newreg = oldreg +\r\n(mask & MgslEvent_ExitHuntMode ? RXSTATUS_EXITED_HUNT:0) +\r\n(mask & MgslEvent_IdleReceived ? RXSTATUS_IDLE_RECEIVED:0);\r\nif (oldreg != newreg)\r\nusc_OutReg(info, RICR, newreg);\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&info->event_wait_q, &wait);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ncnow = info->icount;\r\nnewsigs = info->input_signal_events;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nif (newsigs.dsr_up == oldsigs.dsr_up &&\r\nnewsigs.dsr_down == oldsigs.dsr_down &&\r\nnewsigs.dcd_up == oldsigs.dcd_up &&\r\nnewsigs.dcd_down == oldsigs.dcd_down &&\r\nnewsigs.cts_up == oldsigs.cts_up &&\r\nnewsigs.cts_down == oldsigs.cts_down &&\r\nnewsigs.ri_up == oldsigs.ri_up &&\r\nnewsigs.ri_down == oldsigs.ri_down &&\r\ncnow.exithunt == cprev.exithunt &&\r\ncnow.rxidle == cprev.rxidle) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nevents = mask &\r\n( (newsigs.dsr_up != oldsigs.dsr_up ? MgslEvent_DsrActive:0) +\r\n(newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +\r\n(newsigs.dcd_up != oldsigs.dcd_up ? MgslEvent_DcdActive:0) +\r\n(newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +\r\n(newsigs.cts_up != oldsigs.cts_up ? MgslEvent_CtsActive:0) +\r\n(newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +\r\n(newsigs.ri_up != oldsigs.ri_up ? MgslEvent_RiActive:0) +\r\n(newsigs.ri_down != oldsigs.ri_down ? MgslEvent_RiInactive:0) +\r\n(cnow.exithunt != cprev.exithunt ? MgslEvent_ExitHuntMode:0) +\r\n(cnow.rxidle != cprev.rxidle ? MgslEvent_IdleReceived:0) );\r\nif (events)\r\nbreak;\r\ncprev = cnow;\r\noldsigs = newsigs;\r\n}\r\nremove_wait_queue(&info->event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!waitqueue_active(&info->event_wait_q)) {\r\nusc_OutReg(info, RICR, usc_InReg(info,RICR) &\r\n~(RXSTATUS_EXITED_HUNT | RXSTATUS_IDLE_RECEIVED));\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nexit:\r\nif ( rc == 0 )\r\nPUT_USER(rc, events, mask_ptr);\r\nreturn rc;\r\n}\r\nstatic int modem_input_wait(struct mgsl_struct *info,int arg)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nstruct mgsl_icount cprev, cnow;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ncprev = info->icount;\r\nadd_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ncnow = info->icount;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||\r\n(arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||\r\n(arg & TIOCM_CD && cnow.dcd != cprev.dcd) ||\r\n(arg & TIOCM_CTS && cnow.cts != cprev.cts)) {\r\nrc = 0;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\nremove_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn rc;\r\n}\r\nstatic int tiocmget(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_get_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nresult = ((info->serial_signals & SerialSignal_RTS) ? TIOCM_RTS:0) +\r\n((info->serial_signals & SerialSignal_DTR) ? TIOCM_DTR:0) +\r\n((info->serial_signals & SerialSignal_DCD) ? TIOCM_CAR:0) +\r\n((info->serial_signals & SerialSignal_RI) ? TIOCM_RNG:0) +\r\n((info->serial_signals & SerialSignal_DSR) ? TIOCM_DSR:0) +\r\n((info->serial_signals & SerialSignal_CTS) ? TIOCM_CTS:0);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmget() value=%08X\n",\r\n__FILE__,__LINE__, info->device_name, result );\r\nreturn result;\r\n}\r\nstatic int tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmset(%x,%x)\n",\r\n__FILE__,__LINE__,info->device_name, set, clear);\r\nif (set & TIOCM_RTS)\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->serial_signals &= ~SerialSignal_DTR;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int mgsl_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_break(%s,%d)\n",\r\n__FILE__,__LINE__, info->device_name, break_state);\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_break"))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (break_state == -1)\r\nusc_OutReg(info,IOCR,(u16)(usc_InReg(info,IOCR) | BIT7));\r\nelse\r\nusc_OutReg(info,IOCR,(u16)(usc_InReg(info,IOCR) & ~BIT7));\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic int msgl_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nstruct mgsl_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int mgsl_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_ioctl %s cmd=%08X\n", __FILE__,__LINE__,\r\ninfo->device_name, cmd );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nreturn mgsl_ioctl_common(info, cmd, arg);\r\n}\r\nstatic int mgsl_ioctl_common(struct mgsl_struct *info, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase MGSL_IOCGPARAMS:\r\nreturn mgsl_get_params(info, argp);\r\ncase MGSL_IOCSPARAMS:\r\nreturn mgsl_set_params(info, argp);\r\ncase MGSL_IOCGTXIDLE:\r\nreturn mgsl_get_txidle(info, argp);\r\ncase MGSL_IOCSTXIDLE:\r\nreturn mgsl_set_txidle(info,(int)arg);\r\ncase MGSL_IOCTXENABLE:\r\nreturn mgsl_txenable(info,(int)arg);\r\ncase MGSL_IOCRXENABLE:\r\nreturn mgsl_rxenable(info,(int)arg);\r\ncase MGSL_IOCTXABORT:\r\nreturn mgsl_txabort(info);\r\ncase MGSL_IOCGSTATS:\r\nreturn mgsl_get_stats(info, argp);\r\ncase MGSL_IOCWAITEVENT:\r\nreturn mgsl_wait_event(info, argp);\r\ncase MGSL_IOCLOOPTXDONE:\r\nreturn mgsl_loopmode_send_done(info);\r\ncase TIOCMIWAIT:\r\nreturn modem_input_wait(info,(int)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgsl_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_set_termios %s\n", __FILE__,__LINE__,\r\ntty->driver->name );\r\nmgsl_change_params(info);\r\nif (old_termios->c_cflag & CBAUD &&\r\n!(tty->termios.c_cflag & CBAUD)) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\ntty->termios.c_cflag & CBAUD) {\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (!(tty->termios.c_cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags)) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nif (old_termios->c_cflag & CRTSCTS &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nmgsl_start(tty);\r\n}\r\n}\r\nstatic void mgsl_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_close"))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_close(%s) entry, count=%d\n",\r\n__FILE__,__LINE__, info->device_name, info->port.count);\r\nif (tty_port_close_start(&info->port, tty, filp) == 0)\r\ngoto cleanup;\r\nmutex_lock(&info->port.mutex);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\nmgsl_wait_until_sent(tty, info->timeout);\r\nmgsl_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nshutdown(info);\r\nmutex_unlock(&info->port.mutex);\r\ntty_port_close_end(&info->port, tty);\r\ninfo->port.tty = NULL;\r\ncleanup:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_close(%s) exit, count=%d\n", __FILE__,__LINE__,\r\ntty->driver->name, info->port.count);\r\n}\r\nstatic void mgsl_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nif (!info )\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_wait_until_sent(%s) entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_wait_until_sent"))\r\nreturn;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\ngoto exit;\r\norig_jiffies = jiffies;\r\nif ( info->params.data_rate ) {\r\nchar_time = info->timeout/(32 * 5);\r\nif (!char_time)\r\nchar_time++;\r\n} else\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nif ( info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nwhile (info->tx_active) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n} else {\r\nwhile (!(usc_InReg(info,TCSR) & TXSTATUS_ALL_SENT) &&\r\ninfo->tx_enabled) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n}\r\nexit:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_wait_until_sent(%s) exit\n",\r\n__FILE__,__LINE__, info->device_name );\r\n}\r\nstatic void mgsl_hangup(struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct * info = tty->driver_data;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_hangup(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_hangup"))\r\nreturn;\r\nmgsl_flush_buffer(tty);\r\nshutdown(info);\r\ninfo->port.count = 0;\r\ninfo->port.flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->port.tty = NULL;\r\nwake_up_interruptible(&info->port.open_wait);\r\n}\r\nstatic int carrier_raised(struct tty_port *port)\r\n{\r\nunsigned long flags;\r\nstruct mgsl_struct *info = container_of(port, struct mgsl_struct, port);\r\nspin_lock_irqsave(&info->irq_spinlock, flags);\r\nusc_get_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock, flags);\r\nreturn (info->serial_signals & SerialSignal_DCD) ? 1 : 0;\r\n}\r\nstatic void dtr_rts(struct tty_port *port, int on)\r\n{\r\nstruct mgsl_struct *info = container_of(port, struct mgsl_struct, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (on)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nusc_set_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic int block_til_ready(struct tty_struct *tty, struct file * filp,\r\nstruct mgsl_struct *info)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint retval;\r\nbool do_clocal = false;\r\nunsigned long flags;\r\nint dcd;\r\nstruct tty_port *port = &info->port;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready on %s\n",\r\n__FILE__,__LINE__, tty->driver->name );\r\nif (filp->f_flags & O_NONBLOCK || tty->flags & (1 << TTY_IO_ERROR)){\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (tty->termios.c_cflag & CLOCAL)\r\ndo_clocal = true;\r\nretval = 0;\r\nadd_wait_queue(&port->open_wait, &wait);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready before block on %s count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\nspin_lock_irqsave(&info->irq_spinlock, flags);\r\nport->count--;\r\nspin_unlock_irqrestore(&info->irq_spinlock, flags);\r\nport->blocked_open++;\r\nwhile (1) {\r\nif (C_BAUD(tty) && test_bit(ASYNCB_INITIALIZED, &port->flags))\r\ntty_port_raise_dtr_rts(port);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){\r\nretval = (port->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS;\r\nbreak;\r\n}\r\ndcd = tty_port_carrier_raised(&info->port);\r\nif (!(port->flags & ASYNC_CLOSING) && (do_clocal || dcd))\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready blocking on %s count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\ntty_unlock(tty);\r\nschedule();\r\ntty_lock(tty);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&port->open_wait, &wait);\r\nif (!tty_hung_up_p(filp))\r\nport->count++;\r\nport->blocked_open--;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready after blocking on %s count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\nif (!retval)\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn retval;\r\n}\r\nstatic int mgsl_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct mgsl_struct *info;\r\nint line = tty->index;\r\nif (line >= mgsl_device_count) {\r\nprintk("%s(%d):mgsl_open with invalid line #%d.\n",\r\n__FILE__, __LINE__, line);\r\nreturn -ENODEV;\r\n}\r\ninfo = mgsl_device_list;\r\nwhile (info && info->line != line)\r\ninfo = info->next_device;\r\nif (mgsl_paranoia_check(info, tty->name, "mgsl_open"))\r\nreturn -ENODEV;\r\ntty->driver_data = info;\r\nreturn tty_port_install(&info->port, driver, tty);\r\n}\r\nstatic int mgsl_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct mgsl_struct *info = tty->driver_data;\r\nunsigned long flags;\r\nint retval;\r\ninfo->port.tty = tty;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_open(%s), old ref count = %d\n",\r\n__FILE__,__LINE__,tty->driver->name, info->port.count);\r\nif (info->port.flags & ASYNC_CLOSING){\r\nwait_event_interruptible_tty(tty, info->port.close_wait,\r\n!(info->port.flags & ASYNC_CLOSING));\r\nretval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\ngoto cleanup;\r\n}\r\ninfo->port.low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->netcount) {\r\nretval = -EBUSY;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\ngoto cleanup;\r\n}\r\ninfo->port.count++;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif (info->port.count == 1) {\r\nretval = startup(info);\r\nif (retval < 0)\r\ngoto cleanup;\r\n}\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):block_til_ready(%s) returned %d\n",\r\n__FILE__,__LINE__, info->device_name, retval);\r\ngoto cleanup;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):mgsl_open(%s) success\n",\r\n__FILE__,__LINE__, info->device_name);\r\nretval = 0;\r\ncleanup:\r\nif (retval) {\r\nif (tty->count == 1)\r\ninfo->port.tty = NULL;\r\nif(info->port.count)\r\ninfo->port.count--;\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void line_info(struct seq_file *m, struct mgsl_struct *info)\r\n{\r\nchar stat_buf[30];\r\nunsigned long flags;\r\nif (info->bus_type == MGSL_BUS_TYPE_PCI) {\r\nseq_printf(m, "%s:PCI io:%04X irq:%d mem:%08X lcr:%08X",\r\ninfo->device_name, info->io_base, info->irq_level,\r\ninfo->phys_memory_base, info->phys_lcr_base);\r\n} else {\r\nseq_printf(m, "%s:(E)ISA io:%04X irq:%d dma:%d",\r\ninfo->device_name, info->io_base,\r\ninfo->irq_level, info->dma_level);\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_get_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif (info->serial_signals & SerialSignal_RTS)\r\nstrcat(stat_buf, "|RTS");\r\nif (info->serial_signals & SerialSignal_CTS)\r\nstrcat(stat_buf, "|CTS");\r\nif (info->serial_signals & SerialSignal_DTR)\r\nstrcat(stat_buf, "|DTR");\r\nif (info->serial_signals & SerialSignal_DSR)\r\nstrcat(stat_buf, "|DSR");\r\nif (info->serial_signals & SerialSignal_DCD)\r\nstrcat(stat_buf, "|CD");\r\nif (info->serial_signals & SerialSignal_RI)\r\nstrcat(stat_buf, "|RI");\r\nif (info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nseq_printf(m, " HDLC txok:%d rxok:%d",\r\ninfo->icount.txok, info->icount.rxok);\r\nif (info->icount.txunder)\r\nseq_printf(m, " txunder:%d", info->icount.txunder);\r\nif (info->icount.txabort)\r\nseq_printf(m, " txabort:%d", info->icount.txabort);\r\nif (info->icount.rxshort)\r\nseq_printf(m, " rxshort:%d", info->icount.rxshort);\r\nif (info->icount.rxlong)\r\nseq_printf(m, " rxlong:%d", info->icount.rxlong);\r\nif (info->icount.rxover)\r\nseq_printf(m, " rxover:%d", info->icount.rxover);\r\nif (info->icount.rxcrc)\r\nseq_printf(m, " rxcrc:%d", info->icount.rxcrc);\r\n} else {\r\nseq_printf(m, " ASYNC tx:%d rx:%d",\r\ninfo->icount.tx, info->icount.rx);\r\nif (info->icount.frame)\r\nseq_printf(m, " fe:%d", info->icount.frame);\r\nif (info->icount.parity)\r\nseq_printf(m, " pe:%d", info->icount.parity);\r\nif (info->icount.brk)\r\nseq_printf(m, " brk:%d", info->icount.brk);\r\nif (info->icount.overrun)\r\nseq_printf(m, " oe:%d", info->icount.overrun);\r\n}\r\nseq_printf(m, " %s\n", stat_buf+1);\r\nseq_printf(m, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",\r\ninfo->tx_active,info->bh_requested,info->bh_running,\r\ninfo->pending_bh);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\n{\r\nu16 Tcsr = usc_InReg( info, TCSR );\r\nu16 Tdmr = usc_InDmaReg( info, TDMR );\r\nu16 Ticr = usc_InReg( info, TICR );\r\nu16 Rscr = usc_InReg( info, RCSR );\r\nu16 Rdmr = usc_InDmaReg( info, RDMR );\r\nu16 Ricr = usc_InReg( info, RICR );\r\nu16 Icr = usc_InReg( info, ICR );\r\nu16 Dccr = usc_InReg( info, DCCR );\r\nu16 Tmr = usc_InReg( info, TMR );\r\nu16 Tccr = usc_InReg( info, TCCR );\r\nu16 Ccar = inw( info->io_base + CCAR );\r\nseq_printf(m, "tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X\n"\r\n"ricr=%04X icr =%04X dccr=%04X tmr=%04X tccr=%04X ccar=%04X\n",\r\nTcsr,Tdmr,Ticr,Rscr,Rdmr,Ricr,Icr,Dccr,Tmr,Tccr,Ccar );\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\nstatic int mgsl_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct mgsl_struct *info;\r\nseq_printf(m, "synclink driver:%s\n", driver_version);\r\ninfo = mgsl_device_list;\r\nwhile( info ) {\r\nline_info(m, info);\r\ninfo = info->next_device;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgsl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mgsl_proc_show, NULL);\r\n}\r\nstatic int mgsl_allocate_dma_buffers(struct mgsl_struct *info)\r\n{\r\nunsigned short BuffersPerFrame;\r\ninfo->last_mem_alloc = 0;\r\nBuffersPerFrame = (unsigned short)(info->max_frame_size/DMABUFFERSIZE);\r\nif ( info->max_frame_size % DMABUFFERSIZE )\r\nBuffersPerFrame++;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\ninfo->tx_buffer_count = info->num_tx_dma_buffers * BuffersPerFrame;\r\ninfo->rx_buffer_count = 62 - info->tx_buffer_count;\r\n} else {\r\ninfo->tx_buffer_count = info->num_tx_dma_buffers * BuffersPerFrame;\r\ninfo->rx_buffer_count = (BuffersPerFrame * MAXRXFRAMES) + 6;\r\nif ( (info->tx_buffer_count + info->rx_buffer_count) > 62 )\r\ninfo->rx_buffer_count = 62 - info->tx_buffer_count;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):Allocating %d TX and %d RX DMA buffers.\n",\r\n__FILE__,__LINE__, info->tx_buffer_count,info->rx_buffer_count);\r\nif ( mgsl_alloc_buffer_list_memory( info ) < 0 ||\r\nmgsl_alloc_frame_memory(info, info->rx_buffer_list, info->rx_buffer_count) < 0 ||\r\nmgsl_alloc_frame_memory(info, info->tx_buffer_list, info->tx_buffer_count) < 0 ||\r\nmgsl_alloc_intermediate_rxbuffer_memory(info) < 0 ||\r\nmgsl_alloc_intermediate_txbuffer_memory(info) < 0 ) {\r\nprintk("%s(%d):Can't allocate DMA buffer memory\n",__FILE__,__LINE__);\r\nreturn -ENOMEM;\r\n}\r\nmgsl_reset_rx_dma_buffers( info );\r\nmgsl_reset_tx_dma_buffers( info );\r\nreturn 0;\r\n}\r\nstatic int mgsl_alloc_buffer_list_memory( struct mgsl_struct *info )\r\n{\r\nunsigned int i;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\ninfo->buffer_list = info->memory_base + info->last_mem_alloc;\r\ninfo->buffer_list_phys = info->last_mem_alloc;\r\ninfo->last_mem_alloc += BUFFERLISTSIZE;\r\n} else {\r\ninfo->buffer_list = dma_alloc_coherent(NULL, BUFFERLISTSIZE, &info->buffer_list_dma_addr, GFP_KERNEL);\r\nif (info->buffer_list == NULL)\r\nreturn -ENOMEM;\r\ninfo->buffer_list_phys = (u32)(info->buffer_list_dma_addr);\r\n}\r\nmemset( info->buffer_list, 0, BUFFERLISTSIZE );\r\ninfo->rx_buffer_list = (DMABUFFERENTRY *)info->buffer_list;\r\ninfo->tx_buffer_list = (DMABUFFERENTRY *)info->buffer_list;\r\ninfo->tx_buffer_list += info->rx_buffer_count;\r\nfor ( i = 0; i < info->rx_buffer_count; i++ ) {\r\ninfo->rx_buffer_list[i].phys_entry =\r\ninfo->buffer_list_phys + (i * sizeof(DMABUFFERENTRY));\r\ninfo->rx_buffer_list[i].link = info->buffer_list_phys;\r\nif ( i < info->rx_buffer_count - 1 )\r\ninfo->rx_buffer_list[i].link += (i + 1) * sizeof(DMABUFFERENTRY);\r\n}\r\nfor ( i = 0; i < info->tx_buffer_count; i++ ) {\r\ninfo->tx_buffer_list[i].phys_entry = info->buffer_list_phys +\r\n((info->rx_buffer_count + i) * sizeof(DMABUFFERENTRY));\r\ninfo->tx_buffer_list[i].link = info->buffer_list_phys +\r\ninfo->rx_buffer_count * sizeof(DMABUFFERENTRY);\r\nif ( i < info->tx_buffer_count - 1 )\r\ninfo->tx_buffer_list[i].link += (i + 1) * sizeof(DMABUFFERENTRY);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgsl_free_buffer_list_memory( struct mgsl_struct *info )\r\n{\r\nif (info->buffer_list && info->bus_type != MGSL_BUS_TYPE_PCI)\r\ndma_free_coherent(NULL, BUFFERLISTSIZE, info->buffer_list, info->buffer_list_dma_addr);\r\ninfo->buffer_list = NULL;\r\ninfo->rx_buffer_list = NULL;\r\ninfo->tx_buffer_list = NULL;\r\n}\r\nstatic int mgsl_alloc_frame_memory(struct mgsl_struct *info,DMABUFFERENTRY *BufferList,int Buffercount)\r\n{\r\nint i;\r\nu32 phys_addr;\r\nfor ( i = 0; i < Buffercount; i++ ) {\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nBufferList[i].virt_addr = info->memory_base + info->last_mem_alloc;\r\nphys_addr = info->last_mem_alloc;\r\ninfo->last_mem_alloc += DMABUFFERSIZE;\r\n} else {\r\nBufferList[i].virt_addr = dma_alloc_coherent(NULL, DMABUFFERSIZE, &BufferList[i].dma_addr, GFP_KERNEL);\r\nif (BufferList[i].virt_addr == NULL)\r\nreturn -ENOMEM;\r\nphys_addr = (u32)(BufferList[i].dma_addr);\r\n}\r\nBufferList[i].phys_addr = phys_addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgsl_free_frame_memory(struct mgsl_struct *info, DMABUFFERENTRY *BufferList, int Buffercount)\r\n{\r\nint i;\r\nif ( BufferList ) {\r\nfor ( i = 0 ; i < Buffercount ; i++ ) {\r\nif ( BufferList[i].virt_addr ) {\r\nif ( info->bus_type != MGSL_BUS_TYPE_PCI )\r\ndma_free_coherent(NULL, DMABUFFERSIZE, BufferList[i].virt_addr, BufferList[i].dma_addr);\r\nBufferList[i].virt_addr = NULL;\r\n}\r\n}\r\n}\r\n}\r\nstatic void mgsl_free_dma_buffers( struct mgsl_struct *info )\r\n{\r\nmgsl_free_frame_memory( info, info->rx_buffer_list, info->rx_buffer_count );\r\nmgsl_free_frame_memory( info, info->tx_buffer_list, info->tx_buffer_count );\r\nmgsl_free_buffer_list_memory( info );\r\n}\r\nstatic int mgsl_alloc_intermediate_rxbuffer_memory(struct mgsl_struct *info)\r\n{\r\ninfo->intermediate_rxbuffer = kmalloc(info->max_frame_size, GFP_KERNEL | GFP_DMA);\r\nif ( info->intermediate_rxbuffer == NULL )\r\nreturn -ENOMEM;\r\ninfo->flag_buf = kzalloc(info->max_frame_size, GFP_KERNEL);\r\nif (!info->flag_buf) {\r\nkfree(info->intermediate_rxbuffer);\r\ninfo->intermediate_rxbuffer = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgsl_free_intermediate_rxbuffer_memory(struct mgsl_struct *info)\r\n{\r\nkfree(info->intermediate_rxbuffer);\r\ninfo->intermediate_rxbuffer = NULL;\r\nkfree(info->flag_buf);\r\ninfo->flag_buf = NULL;\r\n}\r\nstatic int mgsl_alloc_intermediate_txbuffer_memory(struct mgsl_struct *info)\r\n{\r\nint i;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s %s(%d) allocating %d tx holding buffers\n",\r\ninfo->device_name, __FILE__,__LINE__,info->num_tx_holding_buffers);\r\nmemset(info->tx_holding_buffers,0,sizeof(info->tx_holding_buffers));\r\nfor ( i=0; i<info->num_tx_holding_buffers; ++i) {\r\ninfo->tx_holding_buffers[i].buffer =\r\nkmalloc(info->max_frame_size, GFP_KERNEL);\r\nif (info->tx_holding_buffers[i].buffer == NULL) {\r\nfor (--i; i >= 0; i--) {\r\nkfree(info->tx_holding_buffers[i].buffer);\r\ninfo->tx_holding_buffers[i].buffer = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mgsl_free_intermediate_txbuffer_memory(struct mgsl_struct *info)\r\n{\r\nint i;\r\nfor ( i=0; i<info->num_tx_holding_buffers; ++i ) {\r\nkfree(info->tx_holding_buffers[i].buffer);\r\ninfo->tx_holding_buffers[i].buffer = NULL;\r\n}\r\ninfo->get_tx_holding_index = 0;\r\ninfo->put_tx_holding_index = 0;\r\ninfo->tx_holding_count = 0;\r\n}\r\nstatic bool load_next_tx_holding_buffer(struct mgsl_struct *info)\r\n{\r\nbool ret = false;\r\nif ( info->tx_holding_count ) {\r\nstruct tx_holding_buffer *ptx =\r\n&info->tx_holding_buffers[info->get_tx_holding_index];\r\nint num_free = num_free_tx_dma_buffers(info);\r\nint num_needed = ptx->buffer_size / DMABUFFERSIZE;\r\nif ( ptx->buffer_size % DMABUFFERSIZE )\r\n++num_needed;\r\nif (num_needed <= num_free) {\r\ninfo->xmit_cnt = ptx->buffer_size;\r\nmgsl_load_tx_dma_buffer(info,ptx->buffer,ptx->buffer_size);\r\n--info->tx_holding_count;\r\nif ( ++info->get_tx_holding_index >= info->num_tx_holding_buffers)\r\ninfo->get_tx_holding_index=0;\r\nmod_timer(&info->tx_timer, jiffies + msecs_to_jiffies(5000));\r\nret = true;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int save_tx_buffer_request(struct mgsl_struct *info,const char *Buffer, unsigned int BufferSize)\r\n{\r\nstruct tx_holding_buffer *ptx;\r\nif ( info->tx_holding_count >= info->num_tx_holding_buffers ) {\r\nreturn 0;\r\n}\r\nptx = &info->tx_holding_buffers[info->put_tx_holding_index];\r\nptx->buffer_size = BufferSize;\r\nmemcpy( ptx->buffer, Buffer, BufferSize);\r\n++info->tx_holding_count;\r\nif ( ++info->put_tx_holding_index >= info->num_tx_holding_buffers)\r\ninfo->put_tx_holding_index=0;\r\nreturn 1;\r\n}\r\nstatic int mgsl_claim_resources(struct mgsl_struct *info)\r\n{\r\nif (request_region(info->io_base,info->io_addr_size,"synclink") == NULL) {\r\nprintk( "%s(%d):I/O address conflict on device %s Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->io_base);\r\nreturn -ENODEV;\r\n}\r\ninfo->io_addr_requested = true;\r\nif ( request_irq(info->irq_level,mgsl_interrupt,info->irq_flags,\r\ninfo->device_name, info ) < 0 ) {\r\nprintk( "%s(%d):Can't request interrupt on device %s IRQ=%d\n",\r\n__FILE__,__LINE__,info->device_name, info->irq_level );\r\ngoto errout;\r\n}\r\ninfo->irq_requested = true;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nif (request_mem_region(info->phys_memory_base,0x40000,"synclink") == NULL) {\r\nprintk( "%s(%d):mem addr conflict device %s Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base);\r\ngoto errout;\r\n}\r\ninfo->shared_mem_requested = true;\r\nif (request_mem_region(info->phys_lcr_base + info->lcr_offset,128,"synclink") == NULL) {\r\nprintk( "%s(%d):lcr mem addr conflict device %s Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_lcr_base + info->lcr_offset);\r\ngoto errout;\r\n}\r\ninfo->lcr_mem_requested = true;\r\ninfo->memory_base = ioremap_nocache(info->phys_memory_base,\r\n0x40000);\r\nif (!info->memory_base) {\r\nprintk( "%s(%d):Can't map shared memory on device %s MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base );\r\ngoto errout;\r\n}\r\nif ( !mgsl_memory_test(info) ) {\r\nprintk( "%s(%d):Failed shared memory test %s MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base );\r\ngoto errout;\r\n}\r\ninfo->lcr_base = ioremap_nocache(info->phys_lcr_base,\r\nPAGE_SIZE);\r\nif (!info->lcr_base) {\r\nprintk( "%s(%d):Can't map LCR memory on device %s MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_lcr_base );\r\ngoto errout;\r\n}\r\ninfo->lcr_base += info->lcr_offset;\r\n} else {\r\nif (request_dma(info->dma_level,info->device_name) < 0){\r\nprintk( "%s(%d):Can't request DMA channel on device %s DMA=%d\n",\r\n__FILE__,__LINE__,info->device_name, info->dma_level );\r\nmgsl_release_resources( info );\r\nreturn -ENODEV;\r\n}\r\ninfo->dma_requested = true;\r\nset_dma_mode(info->dma_level,DMA_MODE_CASCADE);\r\nenable_dma(info->dma_level);\r\n}\r\nif ( mgsl_allocate_dma_buffers(info) < 0 ) {\r\nprintk( "%s(%d):Can't allocate DMA buffers on device %s DMA=%d\n",\r\n__FILE__,__LINE__,info->device_name, info->dma_level );\r\ngoto errout;\r\n}\r\nreturn 0;\r\nerrout:\r\nmgsl_release_resources(info);\r\nreturn -ENODEV;\r\n}\r\nstatic void mgsl_release_resources(struct mgsl_struct *info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_release_resources(%s) entry\n",\r\n__FILE__,__LINE__,info->device_name );\r\nif ( info->irq_requested ) {\r\nfree_irq(info->irq_level, info);\r\ninfo->irq_requested = false;\r\n}\r\nif ( info->dma_requested ) {\r\ndisable_dma(info->dma_level);\r\nfree_dma(info->dma_level);\r\ninfo->dma_requested = false;\r\n}\r\nmgsl_free_dma_buffers(info);\r\nmgsl_free_intermediate_rxbuffer_memory(info);\r\nmgsl_free_intermediate_txbuffer_memory(info);\r\nif ( info->io_addr_requested ) {\r\nrelease_region(info->io_base,info->io_addr_size);\r\ninfo->io_addr_requested = false;\r\n}\r\nif ( info->shared_mem_requested ) {\r\nrelease_mem_region(info->phys_memory_base,0x40000);\r\ninfo->shared_mem_requested = false;\r\n}\r\nif ( info->lcr_mem_requested ) {\r\nrelease_mem_region(info->phys_lcr_base + info->lcr_offset,128);\r\ninfo->lcr_mem_requested = false;\r\n}\r\nif (info->memory_base){\r\niounmap(info->memory_base);\r\ninfo->memory_base = NULL;\r\n}\r\nif (info->lcr_base){\r\niounmap(info->lcr_base - info->lcr_offset);\r\ninfo->lcr_base = NULL;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_release_resources(%s) exit\n",\r\n__FILE__,__LINE__,info->device_name );\r\n}\r\nstatic void mgsl_add_device( struct mgsl_struct *info )\r\n{\r\ninfo->next_device = NULL;\r\ninfo->line = mgsl_device_count;\r\nsprintf(info->device_name,"ttySL%d",info->line);\r\nif (info->line < MAX_TOTAL_DEVICES) {\r\nif (maxframe[info->line])\r\ninfo->max_frame_size = maxframe[info->line];\r\nif (txdmabufs[info->line]) {\r\ninfo->num_tx_dma_buffers = txdmabufs[info->line];\r\nif (info->num_tx_dma_buffers < 1)\r\ninfo->num_tx_dma_buffers = 1;\r\n}\r\nif (txholdbufs[info->line]) {\r\ninfo->num_tx_holding_buffers = txholdbufs[info->line];\r\nif (info->num_tx_holding_buffers < 1)\r\ninfo->num_tx_holding_buffers = 1;\r\nelse if (info->num_tx_holding_buffers > MAX_TX_HOLDING_BUFFERS)\r\ninfo->num_tx_holding_buffers = MAX_TX_HOLDING_BUFFERS;\r\n}\r\n}\r\nmgsl_device_count++;\r\nif ( !mgsl_device_list )\r\nmgsl_device_list = info;\r\nelse {\r\nstruct mgsl_struct *current_dev = mgsl_device_list;\r\nwhile( current_dev->next_device )\r\ncurrent_dev = current_dev->next_device;\r\ncurrent_dev->next_device = info;\r\n}\r\nif ( info->max_frame_size < 4096 )\r\ninfo->max_frame_size = 4096;\r\nelse if ( info->max_frame_size > 65535 )\r\ninfo->max_frame_size = 65535;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nprintk( "SyncLink PCI v%d %s: IO=%04X IRQ=%d Mem=%08X,%08X MaxFrameSize=%u\n",\r\ninfo->hw_version + 1, info->device_name, info->io_base, info->irq_level,\r\ninfo->phys_memory_base, info->phys_lcr_base,\r\ninfo->max_frame_size );\r\n} else {\r\nprintk( "SyncLink ISA %s: IO=%04X IRQ=%d DMA=%d MaxFrameSize=%u\n",\r\ninfo->device_name, info->io_base, info->irq_level, info->dma_level,\r\ninfo->max_frame_size );\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_init(info);\r\n#endif\r\n}\r\nstatic struct mgsl_struct* mgsl_allocate_device(void)\r\n{\r\nstruct mgsl_struct *info;\r\ninfo = kzalloc(sizeof(struct mgsl_struct),\r\nGFP_KERNEL);\r\nif (!info) {\r\nprintk("Error can't allocate device instance data\n");\r\n} else {\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &mgsl_port_ops;\r\ninfo->magic = MGSL_MAGIC;\r\nINIT_WORK(&info->task, mgsl_bh_handler);\r\ninfo->max_frame_size = 4096;\r\ninfo->port.close_delay = 5*HZ/10;\r\ninfo->port.closing_wait = 30*HZ;\r\ninit_waitqueue_head(&info->status_event_wait_q);\r\ninit_waitqueue_head(&info->event_wait_q);\r\nspin_lock_init(&info->irq_spinlock);\r\nspin_lock_init(&info->netlock);\r\nmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\r\ninfo->idle_mode = HDLC_TXIDLE_FLAGS;\r\ninfo->num_tx_dma_buffers = 1;\r\ninfo->num_tx_holding_buffers = 0;\r\n}\r\nreturn info;\r\n}\r\nstatic int mgsl_init_tty(void)\r\n{\r\nint rc;\r\nserial_driver = alloc_tty_driver(128);\r\nif (!serial_driver)\r\nreturn -ENOMEM;\r\nserial_driver->driver_name = "synclink";\r\nserial_driver->name = "ttySL";\r\nserial_driver->major = ttymajor;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->init_termios.c_ispeed = 9600;\r\nserial_driver->init_termios.c_ospeed = 9600;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &mgsl_ops);\r\nif ((rc = tty_register_driver(serial_driver)) < 0) {\r\nprintk("%s(%d):Couldn't register serial driver\n",\r\n__FILE__,__LINE__);\r\nput_tty_driver(serial_driver);\r\nserial_driver = NULL;\r\nreturn rc;\r\n}\r\nprintk("%s %s, tty major#%d\n",\r\ndriver_name, driver_version,\r\nserial_driver->major);\r\nreturn 0;\r\n}\r\nstatic void mgsl_enum_isa_devices(void)\r\n{\r\nstruct mgsl_struct *info;\r\nint i;\r\nfor (i=0 ;(i < MAX_ISA_DEVICES) && io[i] && irq[i]; i++){\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("ISA device specified io=%04X,irq=%d,dma=%d\n",\r\nio[i], irq[i], dma[i] );\r\ninfo = mgsl_allocate_device();\r\nif ( !info ) {\r\nif ( debug_level >= DEBUG_LEVEL_ERROR )\r\nprintk( "can't allocate device instance data.\n");\r\ncontinue;\r\n}\r\ninfo->io_base = (unsigned int)io[i];\r\ninfo->irq_level = (unsigned int)irq[i];\r\ninfo->irq_level = irq_canonicalize(info->irq_level);\r\ninfo->dma_level = (unsigned int)dma[i];\r\ninfo->bus_type = MGSL_BUS_TYPE_ISA;\r\ninfo->io_addr_size = 16;\r\ninfo->irq_flags = 0;\r\nmgsl_add_device( info );\r\n}\r\n}\r\nstatic void synclink_cleanup(void)\r\n{\r\nint rc;\r\nstruct mgsl_struct *info;\r\nstruct mgsl_struct *tmp;\r\nprintk("Unloading %s: %s\n", driver_name, driver_version);\r\nif (serial_driver) {\r\nrc = tty_unregister_driver(serial_driver);\r\nif (rc)\r\nprintk("%s(%d) failed to unregister tty driver err=%d\n",\r\n__FILE__,__LINE__,rc);\r\nput_tty_driver(serial_driver);\r\n}\r\ninfo = mgsl_device_list;\r\nwhile(info) {\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_exit(info);\r\n#endif\r\nmgsl_release_resources(info);\r\ntmp = info;\r\ninfo = info->next_device;\r\ntty_port_destroy(&tmp->port);\r\nkfree(tmp);\r\n}\r\nif (pci_registered)\r\npci_unregister_driver(&synclink_pci_driver);\r\n}\r\nstatic int __init synclink_init(void)\r\n{\r\nint rc;\r\nif (break_on_load) {\r\nmgsl_get_text_ptr();\r\nBREAKPOINT();\r\n}\r\nprintk("%s %s\n", driver_name, driver_version);\r\nmgsl_enum_isa_devices();\r\nif ((rc = pci_register_driver(&synclink_pci_driver)) < 0)\r\nprintk("%s:failed to register PCI driver, error=%d\n",__FILE__,rc);\r\nelse\r\npci_registered = true;\r\nif ((rc = mgsl_init_tty()) < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nsynclink_cleanup();\r\nreturn rc;\r\n}\r\nstatic void __exit synclink_exit(void)\r\n{\r\nsynclink_cleanup();\r\n}\r\nstatic void usc_RTCmd( struct mgsl_struct *info, u16 Cmd )\r\n{\r\noutw( Cmd + info->loopback_bits, info->io_base + CCAR );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\ninw( info->io_base + CCAR );\r\n}\r\nstatic void usc_DmaCmd( struct mgsl_struct *info, u16 Cmd )\r\n{\r\noutw( Cmd + info->mbre_bit, info->io_base );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\ninw( info->io_base );\r\n}\r\nstatic void usc_OutDmaReg( struct mgsl_struct *info, u16 RegAddr, u16 RegValue )\r\n{\r\noutw( RegAddr + info->mbre_bit, info->io_base );\r\noutw( RegValue, info->io_base );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\ninw( info->io_base );\r\n}\r\nstatic u16 usc_InDmaReg( struct mgsl_struct *info, u16 RegAddr )\r\n{\r\noutw( RegAddr + info->mbre_bit, info->io_base );\r\nreturn inw( info->io_base );\r\n}\r\nstatic void usc_OutReg( struct mgsl_struct *info, u16 RegAddr, u16 RegValue )\r\n{\r\noutw( RegAddr + info->loopback_bits, info->io_base + CCAR );\r\noutw( RegValue, info->io_base + CCAR );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\ninw( info->io_base + CCAR );\r\n}\r\nstatic u16 usc_InReg( struct mgsl_struct *info, u16 RegAddr )\r\n{\r\noutw( RegAddr + info->loopback_bits, info->io_base + CCAR );\r\nreturn inw( info->io_base + CCAR );\r\n}\r\nstatic void usc_set_sdlc_mode( struct mgsl_struct *info )\r\n{\r\nu16 RegValue;\r\nbool PreSL1660;\r\nusc_OutReg(info,TMCR,0x1f);\r\nRegValue=usc_InReg(info,TMDR);\r\nPreSL1660 = (RegValue == IUSC_PRE_SL1660);\r\nif ( info->params.flags & HDLC_FLAG_HDLC_LOOPMODE )\r\n{\r\nRegValue = 0x8e06;\r\n}\r\nelse\r\n{\r\nif (info->params.mode == MGSL_MODE_RAW) {\r\nRegValue = 0x0001;\r\nusc_OutReg( info, IOCR,\r\n(unsigned short)((usc_InReg(info, IOCR) & ~(BIT13|BIT12)) | BIT12));\r\nRegValue |= 0x0400;\r\n}\r\nelse {\r\nRegValue = 0x0606;\r\nif ( info->params.flags & HDLC_FLAG_UNDERRUN_ABORT15 )\r\nRegValue |= BIT14;\r\nelse if ( info->params.flags & HDLC_FLAG_UNDERRUN_FLAG )\r\nRegValue |= BIT15;\r\nelse if ( info->params.flags & HDLC_FLAG_UNDERRUN_CRC )\r\nRegValue |= BIT15 | BIT14;\r\n}\r\nif ( info->params.preamble != HDLC_PREAMBLE_PATTERN_NONE )\r\nRegValue |= BIT13;\r\n}\r\nif ( info->params.mode == MGSL_MODE_HDLC &&\r\n(info->params.flags & HDLC_FLAG_SHARE_ZERO) )\r\nRegValue |= BIT12;\r\nif ( info->params.addr_filter != 0xff )\r\n{\r\nusc_OutReg( info, RSR, info->params.addr_filter );\r\nRegValue |= BIT4;\r\n}\r\nusc_OutReg( info, CMR, RegValue );\r\ninfo->cmr_value = RegValue;\r\nRegValue = 0x0500;\r\nswitch ( info->params.encoding ) {\r\ncase HDLC_ENCODING_NRZB: RegValue |= BIT13; break;\r\ncase HDLC_ENCODING_NRZI_MARK: RegValue |= BIT14; break;\r\ncase HDLC_ENCODING_NRZI_SPACE: RegValue |= BIT14 | BIT13; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK: RegValue |= BIT15; break;\r\ncase HDLC_ENCODING_BIPHASE_SPACE: RegValue |= BIT15 | BIT13; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL: RegValue |= BIT15 | BIT14; break;\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: RegValue |= BIT15 | BIT14 | BIT13; break;\r\n}\r\nif ( (info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_16_CCITT )\r\nRegValue |= BIT9;\r\nelse if ( (info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_32_CCITT )\r\nRegValue |= ( BIT12 | BIT10 | BIT9 );\r\nusc_OutReg( info, RMR, RegValue );\r\nusc_OutReg( info, RCLR, RCLRVALUE );\r\nusc_RCmd( info, RCmd_SelectRicrdma_level );\r\nRegValue = usc_InReg( info, RICR ) & 0xc0;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nusc_OutReg( info, RICR, (u16)(0x030a | RegValue) );\r\nelse\r\nusc_OutReg( info, RICR, (u16)(0x140a | RegValue) );\r\nusc_UnlatchRxstatusBits( info, RXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, RECEIVE_STATUS );\r\nRegValue = 0x0400;\r\nswitch ( info->params.encoding ) {\r\ncase HDLC_ENCODING_NRZB: RegValue |= BIT13; break;\r\ncase HDLC_ENCODING_NRZI_MARK: RegValue |= BIT14; break;\r\ncase HDLC_ENCODING_NRZI_SPACE: RegValue |= BIT14 | BIT13; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK: RegValue |= BIT15; break;\r\ncase HDLC_ENCODING_BIPHASE_SPACE: RegValue |= BIT15 | BIT13; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL: RegValue |= BIT15 | BIT14; break;\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: RegValue |= BIT15 | BIT14 | BIT13; break;\r\n}\r\nif ( (info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_16_CCITT )\r\nRegValue |= BIT9 | BIT8;\r\nelse if ( (info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_32_CCITT )\r\nRegValue |= ( BIT12 | BIT10 | BIT9 | BIT8);\r\nusc_OutReg( info, TMR, RegValue );\r\nusc_set_txidle( info );\r\nusc_TCmd( info, TCmd_SelectTicrdma_level );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nusc_OutReg( info, TICR, 0x0736 );\r\nelse\r\nusc_OutReg( info, TICR, 0x1436 );\r\nusc_UnlatchTxstatusBits( info, TXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS );\r\ninfo->tcsr_value = 0;\r\nif ( !PreSL1660 )\r\ninfo->tcsr_value |= TCSR_UNDERWAIT;\r\nusc_OutReg( info, TCSR, info->tcsr_value );\r\nRegValue = 0x0f40;\r\nif ( info->params.flags & HDLC_FLAG_RXC_DPLL )\r\nRegValue |= 0x0003;\r\nelse if ( info->params.flags & HDLC_FLAG_RXC_BRG )\r\nRegValue |= 0x0004;\r\nelse if ( info->params.flags & HDLC_FLAG_RXC_TXCPIN)\r\nRegValue |= 0x0006;\r\nelse\r\nRegValue |= 0x0007;\r\nif ( info->params.flags & HDLC_FLAG_TXC_DPLL )\r\nRegValue |= 0x0018;\r\nelse if ( info->params.flags & HDLC_FLAG_TXC_BRG )\r\nRegValue |= 0x0020;\r\nelse if ( info->params.flags & HDLC_FLAG_TXC_RXCPIN)\r\nRegValue |= 0x0038;\r\nelse\r\nRegValue |= 0x0030;\r\nusc_OutReg( info, CMCR, RegValue );\r\nRegValue = 0x0000;\r\nif ( info->params.flags & (HDLC_FLAG_RXC_DPLL | HDLC_FLAG_TXC_DPLL) ) {\r\nu32 XtalSpeed;\r\nu32 DpllDivisor;\r\nu16 Tc;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nXtalSpeed = 11059200;\r\nelse\r\nXtalSpeed = 14745600;\r\nif ( info->params.flags & HDLC_FLAG_DPLL_DIV16 ) {\r\nDpllDivisor = 16;\r\nRegValue |= BIT10;\r\n}\r\nelse if ( info->params.flags & HDLC_FLAG_DPLL_DIV8 ) {\r\nDpllDivisor = 8;\r\nRegValue |= BIT11;\r\n}\r\nelse\r\nDpllDivisor = 32;\r\nif ( info->params.clock_speed )\r\n{\r\nTc = (u16)((XtalSpeed/DpllDivisor)/info->params.clock_speed);\r\nif ( !((((XtalSpeed/DpllDivisor) % info->params.clock_speed) * 2)\r\n/ info->params.clock_speed) )\r\nTc--;\r\n}\r\nelse\r\nTc = -1;\r\nusc_OutReg( info, TC1R, Tc );\r\nRegValue |= BIT4;\r\nswitch ( info->params.encoding ) {\r\ncase HDLC_ENCODING_NRZ:\r\ncase HDLC_ENCODING_NRZB:\r\ncase HDLC_ENCODING_NRZI_MARK:\r\ncase HDLC_ENCODING_NRZI_SPACE: RegValue |= BIT8; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK:\r\ncase HDLC_ENCODING_BIPHASE_SPACE: RegValue |= BIT9; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL:\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL: RegValue |= BIT9 | BIT8; break;\r\n}\r\n}\r\nusc_OutReg( info, HCR, RegValue );\r\nusc_OutReg( info, CCSR, 0x1020 );\r\nif ( info->params.flags & HDLC_FLAG_AUTO_CTS ) {\r\nusc_OutReg( info, SICR,\r\n(u16)(usc_InReg(info,SICR) | SICR_CTS_INACTIVE) );\r\n}\r\nusc_EnableMasterIrqBit( info );\r\nusc_ClearIrqPendingBits( info, RECEIVE_STATUS | RECEIVE_DATA |\r\nTRANSMIT_STATUS | TRANSMIT_DATA | MISC);\r\nusc_OutReg(info, SICR, (u16)(usc_InReg(info,SICR) | BIT3));\r\nusc_EnableInterrupts(info, MISC);\r\ninfo->mbre_bit = 0;\r\noutw( 0, info->io_base );\r\nusc_DmaCmd( info, DmaCmd_ResetAllChannels );\r\ninfo->mbre_bit = BIT8;\r\noutw( BIT8, info->io_base );\r\nif (info->bus_type == MGSL_BUS_TYPE_ISA) {\r\nusc_OutReg(info, PCR, (u16)((usc_InReg(info, PCR) | BIT15) & ~BIT14));\r\n}\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nusc_OutDmaReg( info, DCR, 0xa00b );\r\n}\r\nelse\r\nusc_OutDmaReg( info, DCR, 0x800b );\r\nusc_OutDmaReg( info, RDMR, 0xf200 );\r\nusc_OutDmaReg( info, TDMR, 0xf200 );\r\nusc_OutDmaReg( info, DICR, 0x9000 );\r\nusc_InDmaReg( info, RDMR );\r\nusc_InDmaReg( info, TDMR );\r\nusc_OutDmaReg( info, CDIR, 0x0303 );\r\nRegValue = 0x8080;\r\nswitch ( info->params.preamble_length ) {\r\ncase HDLC_PREAMBLE_LENGTH_16BITS: RegValue |= BIT10; break;\r\ncase HDLC_PREAMBLE_LENGTH_32BITS: RegValue |= BIT11; break;\r\ncase HDLC_PREAMBLE_LENGTH_64BITS: RegValue |= BIT11 | BIT10; break;\r\n}\r\nswitch ( info->params.preamble ) {\r\ncase HDLC_PREAMBLE_PATTERN_FLAGS: RegValue |= BIT8 | BIT12; break;\r\ncase HDLC_PREAMBLE_PATTERN_ONES: RegValue |= BIT8; break;\r\ncase HDLC_PREAMBLE_PATTERN_10: RegValue |= BIT9; break;\r\ncase HDLC_PREAMBLE_PATTERN_01: RegValue |= BIT9 | BIT8; break;\r\n}\r\nusc_OutReg( info, CCR, RegValue );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nusc_OutDmaReg( info, BDCR, 0x0000 );\r\n}\r\nelse\r\nusc_OutDmaReg( info, BDCR, 0x2000 );\r\nusc_stop_transmitter(info);\r\nusc_stop_receiver(info);\r\n}\r\nstatic void usc_enable_loopback(struct mgsl_struct *info, int enable)\r\n{\r\nif (enable) {\r\nusc_OutReg(info,IOCR,usc_InReg(info,IOCR) | (BIT7 | BIT6));\r\nusc_OutReg( info, CMCR, 0x0f64 );\r\nif (info->params.clock_speed) {\r\nif (info->bus_type == MGSL_BUS_TYPE_PCI)\r\nusc_OutReg(info, TC0R, (u16)((11059200/info->params.clock_speed)-1));\r\nelse\r\nusc_OutReg(info, TC0R, (u16)((14745600/info->params.clock_speed)-1));\r\n} else\r\nusc_OutReg(info, TC0R, (u16)8);\r\nusc_OutReg( info, HCR, (u16)((usc_InReg( info, HCR ) & ~BIT1) | BIT0) );\r\nusc_OutReg(info, IOCR, (u16)((usc_InReg(info, IOCR) & 0xfff8) | 0x0004));\r\ninfo->loopback_bits = 0x300;\r\noutw( 0x0300, info->io_base + CCAR );\r\n} else {\r\nusc_OutReg(info,IOCR,usc_InReg(info,IOCR) & ~(BIT7 | BIT6));\r\ninfo->loopback_bits = 0;\r\noutw( 0,info->io_base + CCAR );\r\n}\r\n}\r\nstatic void usc_enable_aux_clock( struct mgsl_struct *info, u32 data_rate )\r\n{\r\nu32 XtalSpeed;\r\nu16 Tc;\r\nif ( data_rate ) {\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nXtalSpeed = 11059200;\r\nelse\r\nXtalSpeed = 14745600;\r\nTc = (u16)(XtalSpeed/data_rate);\r\nif ( !(((XtalSpeed % data_rate) * 2) / data_rate) )\r\nTc--;\r\nusc_OutReg( info, TC0R, Tc );\r\nusc_OutReg( info, HCR, (u16)((usc_InReg( info, HCR ) & ~BIT1) | BIT0) );\r\nusc_OutReg( info, IOCR, (u16)((usc_InReg(info, IOCR) & 0xfff8) | 0x0004) );\r\n} else {\r\nusc_OutReg( info, HCR, (u16)(usc_InReg( info, HCR ) & ~BIT0) );\r\n}\r\n}\r\nstatic void usc_process_rxoverrun_sync( struct mgsl_struct *info )\r\n{\r\nint start_index;\r\nint end_index;\r\nint frame_start_index;\r\nbool start_of_frame_found = false;\r\nbool end_of_frame_found = false;\r\nbool reprogram_dma = false;\r\nDMABUFFERENTRY *buffer_list = info->rx_buffer_list;\r\nu32 phys_addr;\r\nusc_DmaCmd( info, DmaCmd_PauseRxChannel );\r\nusc_RCmd( info, RCmd_EnterHuntmode );\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\nframe_start_index = start_index = end_index = info->current_rx_buffer;\r\nwhile( !buffer_list[end_index].count )\r\n{\r\nif ( !start_of_frame_found )\r\n{\r\nstart_of_frame_found = true;\r\nframe_start_index = end_index;\r\nend_of_frame_found = false;\r\n}\r\nif ( buffer_list[end_index].status )\r\n{\r\nstart_of_frame_found = false;\r\nend_of_frame_found = true;\r\n}\r\nend_index++;\r\nif ( end_index == info->rx_buffer_count )\r\nend_index = 0;\r\nif ( start_index == end_index )\r\n{\r\nmgsl_reset_rx_dma_buffers( info );\r\nframe_start_index = 0;\r\nstart_of_frame_found = false;\r\nreprogram_dma = true;\r\nbreak;\r\n}\r\n}\r\nif ( start_of_frame_found && !end_of_frame_found )\r\n{\r\nstart_index = frame_start_index;\r\ndo\r\n{\r\n*((unsigned long *)&(info->rx_buffer_list[start_index++].count)) = DMABUFFERSIZE;\r\nif ( start_index == info->rx_buffer_count )\r\nstart_index = 0;\r\n} while( start_index != end_index );\r\nreprogram_dma = true;\r\n}\r\nif ( reprogram_dma )\r\n{\r\nusc_UnlatchRxstatusBits(info,RXSTATUS_ALL);\r\nusc_ClearIrqPendingBits(info, RECEIVE_DATA|RECEIVE_STATUS);\r\nusc_UnlatchRxstatusBits(info, RECEIVE_DATA|RECEIVE_STATUS);\r\nusc_EnableReceiver(info,DISABLE_UNCONDITIONAL);\r\nusc_OutReg( info, CCSR, (u16)(usc_InReg(info,CCSR) | BIT13) );\r\nphys_addr = info->rx_buffer_list[frame_start_index].phys_entry;\r\nusc_OutDmaReg( info, NRARL, (u16)phys_addr );\r\nusc_OutDmaReg( info, NRARU, (u16)(phys_addr >> 16) );\r\nusc_UnlatchRxstatusBits( info, RXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, RECEIVE_DATA | RECEIVE_STATUS );\r\nusc_EnableInterrupts( info, RECEIVE_STATUS );\r\nusc_OutDmaReg( info, RDIAR, BIT3 | BIT2 );\r\nusc_OutDmaReg( info, DICR, (u16)(usc_InDmaReg(info,DICR) | BIT1) );\r\nusc_DmaCmd( info, DmaCmd_InitRxChannel );\r\nif ( info->params.flags & HDLC_FLAG_AUTO_DCD )\r\nusc_EnableReceiver(info,ENABLE_AUTO_DCD);\r\nelse\r\nusc_EnableReceiver(info,ENABLE_UNCONDITIONAL);\r\n}\r\nelse\r\n{\r\nusc_OutReg( info, CCSR, (u16)(usc_InReg(info,CCSR) | BIT13) );\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\n}\r\n}\r\nstatic void usc_stop_receiver( struct mgsl_struct *info )\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):usc_stop_receiver(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nusc_DmaCmd( info, DmaCmd_ResetRxChannel );\r\nusc_UnlatchRxstatusBits( info, RXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, RECEIVE_DATA | RECEIVE_STATUS );\r\nusc_DisableInterrupts( info, RECEIVE_DATA | RECEIVE_STATUS );\r\nusc_EnableReceiver(info,DISABLE_UNCONDITIONAL);\r\nusc_OutReg( info, CCSR, (u16)(usc_InReg(info,CCSR) | BIT13) );\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\ninfo->rx_enabled = false;\r\ninfo->rx_overflow = false;\r\ninfo->rx_rcc_underrun = false;\r\n}\r\nstatic void usc_start_receiver( struct mgsl_struct *info )\r\n{\r\nu32 phys_addr;\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):usc_start_receiver(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nmgsl_reset_rx_dma_buffers( info );\r\nusc_stop_receiver( info );\r\nusc_OutReg( info, CCSR, (u16)(usc_InReg(info,CCSR) | BIT13) );\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\nif ( info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW ) {\r\nphys_addr = info->rx_buffer_list[0].phys_entry;\r\nusc_OutDmaReg( info, NRARL, (u16)phys_addr );\r\nusc_OutDmaReg( info, NRARU, (u16)(phys_addr >> 16) );\r\nusc_UnlatchRxstatusBits( info, RXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, RECEIVE_DATA | RECEIVE_STATUS );\r\nusc_EnableInterrupts( info, RECEIVE_STATUS );\r\nusc_OutDmaReg( info, RDIAR, BIT3 | BIT2 );\r\nusc_OutDmaReg( info, DICR, (u16)(usc_InDmaReg(info,DICR) | BIT1) );\r\nusc_DmaCmd( info, DmaCmd_InitRxChannel );\r\nif ( info->params.flags & HDLC_FLAG_AUTO_DCD )\r\nusc_EnableReceiver(info,ENABLE_AUTO_DCD);\r\nelse\r\nusc_EnableReceiver(info,ENABLE_UNCONDITIONAL);\r\n} else {\r\nusc_UnlatchRxstatusBits(info, RXSTATUS_ALL);\r\nusc_ClearIrqPendingBits(info, RECEIVE_DATA | RECEIVE_STATUS);\r\nusc_EnableInterrupts(info, RECEIVE_DATA);\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\nusc_RCmd( info, RCmd_EnterHuntmode );\r\nusc_EnableReceiver(info,ENABLE_UNCONDITIONAL);\r\n}\r\nusc_OutReg( info, CCSR, 0x1020 );\r\ninfo->rx_enabled = true;\r\n}\r\nstatic void usc_start_transmitter( struct mgsl_struct *info )\r\n{\r\nu32 phys_addr;\r\nunsigned int FrameSize;\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):usc_start_transmitter(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif ( info->xmit_cnt ) {\r\ninfo->drop_rts_on_tx_done = false;\r\nif ( info->params.flags & HDLC_FLAG_AUTO_RTS ) {\r\nusc_get_serial_signals( info );\r\nif ( !(info->serial_signals & SerialSignal_RTS) ) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nusc_set_serial_signals( info );\r\ninfo->drop_rts_on_tx_done = true;\r\n}\r\n}\r\nif ( info->params.mode == MGSL_MODE_ASYNC ) {\r\nif ( !info->tx_active ) {\r\nusc_UnlatchTxstatusBits(info, TXSTATUS_ALL);\r\nusc_ClearIrqPendingBits(info, TRANSMIT_STATUS + TRANSMIT_DATA);\r\nusc_EnableInterrupts(info, TRANSMIT_DATA);\r\nusc_load_txfifo(info);\r\n}\r\n} else {\r\nusc_DmaCmd( info, DmaCmd_ResetTxChannel );\r\nFrameSize = info->tx_buffer_list[info->start_tx_dma_buffer].rcc;\r\nif ( info->params.mode == MGSL_MODE_RAW )\r\ninfo->tx_buffer_list[info->start_tx_dma_buffer].rcc = 0;\r\nusc_OutReg( info, TCLR, (u16)FrameSize );\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\nphys_addr = info->tx_buffer_list[info->start_tx_dma_buffer].phys_entry;\r\nusc_OutDmaReg( info, NTARL, (u16)phys_addr );\r\nusc_OutDmaReg( info, NTARU, (u16)(phys_addr >> 16) );\r\nusc_UnlatchTxstatusBits( info, TXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS );\r\nusc_EnableInterrupts( info, TRANSMIT_STATUS );\r\nif ( info->params.mode == MGSL_MODE_RAW &&\r\ninfo->num_tx_dma_buffers > 1 ) {\r\nusc_OutDmaReg( info, TDIAR, BIT2|BIT3 );\r\nusc_OutDmaReg( info, DICR, (u16)(usc_InDmaReg(info,DICR) | BIT0) );\r\n}\r\nusc_DmaCmd( info, DmaCmd_InitTxChannel );\r\nusc_TCmd( info, TCmd_SendFrame );\r\nmod_timer(&info->tx_timer, jiffies +\r\nmsecs_to_jiffies(5000));\r\n}\r\ninfo->tx_active = true;\r\n}\r\nif ( !info->tx_enabled ) {\r\ninfo->tx_enabled = true;\r\nif ( info->params.flags & HDLC_FLAG_AUTO_CTS )\r\nusc_EnableTransmitter(info,ENABLE_AUTO_CTS);\r\nelse\r\nusc_EnableTransmitter(info,ENABLE_UNCONDITIONAL);\r\n}\r\n}\r\nstatic void usc_stop_transmitter( struct mgsl_struct *info )\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):usc_stop_transmitter(%s)\n",\r\n__FILE__,__LINE__, info->device_name );\r\ndel_timer(&info->tx_timer);\r\nusc_UnlatchTxstatusBits( info, TXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS + TRANSMIT_DATA );\r\nusc_DisableInterrupts( info, TRANSMIT_STATUS + TRANSMIT_DATA );\r\nusc_EnableTransmitter(info,DISABLE_UNCONDITIONAL);\r\nusc_DmaCmd( info, DmaCmd_ResetTxChannel );\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\ninfo->tx_enabled = false;\r\ninfo->tx_active = false;\r\n}\r\nstatic void usc_load_txfifo( struct mgsl_struct *info )\r\n{\r\nint Fifocount;\r\nu8 TwoBytes[2];\r\nif ( !info->xmit_cnt && !info->x_char )\r\nreturn;\r\nusc_TCmd( info, TCmd_SelectTicrTxFifostatus );\r\nwhile( (Fifocount = usc_InReg(info, TICR) >> 8) && info->xmit_cnt ) {\r\nif ( (info->xmit_cnt > 1) && (Fifocount > 1) && !info->x_char ) {\r\nTwoBytes[0] = info->xmit_buf[info->xmit_tail++];\r\ninfo->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE-1);\r\nTwoBytes[1] = info->xmit_buf[info->xmit_tail++];\r\ninfo->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE-1);\r\noutw( *((u16 *)TwoBytes), info->io_base + DATAREG);\r\ninfo->xmit_cnt -= 2;\r\ninfo->icount.tx += 2;\r\n} else {\r\noutw( (inw( info->io_base + CCAR) & 0x0780) | (TDR+LSBONLY),\r\ninfo->io_base + CCAR );\r\nif (info->x_char) {\r\noutw( info->x_char,info->io_base + CCAR );\r\ninfo->x_char = 0;\r\n} else {\r\noutw( info->xmit_buf[info->xmit_tail++],info->io_base + CCAR );\r\ninfo->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE-1);\r\ninfo->xmit_cnt--;\r\n}\r\ninfo->icount.tx++;\r\n}\r\n}\r\n}\r\nstatic void usc_reset( struct mgsl_struct *info )\r\n{\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI ) {\r\nint i;\r\nu32 readval;\r\nvolatile u32 *MiscCtrl = (u32 *)(info->lcr_base + 0x50);\r\nu32 *LCR0BRDR = (u32 *)(info->lcr_base + 0x28);\r\ninfo->misc_ctrl_value |= BIT30;\r\n*MiscCtrl = info->misc_ctrl_value;\r\nfor(i=0;i<10;i++)\r\nreadval = *MiscCtrl;\r\ninfo->misc_ctrl_value &= ~BIT30;\r\n*MiscCtrl = info->misc_ctrl_value;\r\n*LCR0BRDR = BUS_DESCRIPTOR(\r\n1,\r\n2,\r\n2,\r\n0,\r\n4,\r\n0,\r\n0,\r\n5\r\n);\r\n} else {\r\noutb( 0,info->io_base + 8 );\r\n}\r\ninfo->mbre_bit = 0;\r\ninfo->loopback_bits = 0;\r\ninfo->usc_idle_mode = 0;\r\noutw( 0x000c,info->io_base + SDPIN );\r\noutw( 0,info->io_base );\r\noutw( 0,info->io_base + CCAR );\r\nusc_RTCmd( info, RTCmd_SelectLittleEndian );\r\nusc_OutReg( info, PCR, 0xf0f5 );\r\nusc_OutReg( info, IOCR, 0x0004 );\r\n}\r\nstatic void usc_set_async_mode( struct mgsl_struct *info )\r\n{\r\nu16 RegValue;\r\nusc_DisableMasterIrqBit( info );\r\noutw( 0, info->io_base );\r\nusc_DmaCmd( info, DmaCmd_ResetAllChannels );\r\nusc_loopback_frame( info );\r\nRegValue = 0;\r\nif ( info->params.stop_bits != 1 )\r\nRegValue |= BIT14;\r\nusc_OutReg( info, CMR, RegValue );\r\nRegValue = 0;\r\nif ( info->params.data_bits != 8 )\r\nRegValue |= BIT4 | BIT3 | BIT2;\r\nif ( info->params.parity != ASYNC_PARITY_NONE ) {\r\nRegValue |= BIT5;\r\nif ( info->params.parity != ASYNC_PARITY_ODD )\r\nRegValue |= BIT6;\r\n}\r\nusc_OutReg( info, RMR, RegValue );\r\nusc_RCmd( info, RCmd_SelectRicrIntLevel );\r\nusc_OutReg( info, RICR, 0x0000 );\r\nusc_UnlatchRxstatusBits( info, RXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, RECEIVE_STATUS );\r\nRegValue = 0;\r\nif ( info->params.data_bits != 8 )\r\nRegValue |= BIT4 | BIT3 | BIT2;\r\nif ( info->params.parity != ASYNC_PARITY_NONE ) {\r\nRegValue |= BIT5;\r\nif ( info->params.parity != ASYNC_PARITY_ODD )\r\nRegValue |= BIT6;\r\n}\r\nusc_OutReg( info, TMR, RegValue );\r\nusc_set_txidle( info );\r\nusc_TCmd( info, TCmd_SelectTicrIntLevel );\r\nusc_OutReg( info, TICR, 0x1f40 );\r\nusc_UnlatchTxstatusBits( info, TXSTATUS_ALL );\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS );\r\nusc_enable_async_clock( info, info->params.data_rate );\r\nusc_OutReg( info, CCSR, 0x0020 );\r\nusc_DisableInterrupts( info, TRANSMIT_STATUS + TRANSMIT_DATA +\r\nRECEIVE_DATA + RECEIVE_STATUS );\r\nusc_ClearIrqPendingBits( info, TRANSMIT_STATUS + TRANSMIT_DATA +\r\nRECEIVE_DATA + RECEIVE_STATUS );\r\nusc_EnableMasterIrqBit( info );\r\nif (info->bus_type == MGSL_BUS_TYPE_ISA) {\r\nusc_OutReg(info, PCR, (u16)((usc_InReg(info, PCR) | BIT13) & ~BIT12));\r\n}\r\nif (info->params.loopback) {\r\ninfo->loopback_bits = 0x300;\r\noutw(0x0300, info->io_base + CCAR);\r\n}\r\n}\r\nstatic void usc_loopback_frame( struct mgsl_struct *info )\r\n{\r\nint i;\r\nunsigned long oldmode = info->params.mode;\r\ninfo->params.mode = MGSL_MODE_HDLC;\r\nusc_DisableMasterIrqBit( info );\r\nusc_set_sdlc_mode( info );\r\nusc_enable_loopback( info, 1 );\r\nusc_OutReg( info, TC0R, 0 );\r\nusc_OutReg( info, CCR, 0x0100 );\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\nusc_EnableReceiver(info,ENABLE_UNCONDITIONAL);\r\nusc_OutReg( info, TCLR, 2 );\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\nusc_UnlatchTxstatusBits(info,TXSTATUS_ALL);\r\noutw(0,info->io_base + DATAREG);\r\nusc_TCmd( info, TCmd_SendFrame );\r\nusc_EnableTransmitter(info,ENABLE_UNCONDITIONAL);\r\nfor (i=0 ; i<1000 ; i++)\r\nif (usc_InReg( info, RCSR ) & (BIT8 | BIT4 | BIT3 | BIT1))\r\nbreak;\r\nusc_enable_loopback(info, 0);\r\nusc_EnableMasterIrqBit(info);\r\ninfo->params.mode = oldmode;\r\n}\r\nstatic void usc_set_sync_mode( struct mgsl_struct *info )\r\n{\r\nusc_loopback_frame( info );\r\nusc_set_sdlc_mode( info );\r\nif (info->bus_type == MGSL_BUS_TYPE_ISA) {\r\nusc_OutReg(info, PCR, (u16)((usc_InReg(info, PCR) | BIT13) & ~BIT12));\r\n}\r\nusc_enable_aux_clock(info, info->params.clock_speed);\r\nif (info->params.loopback)\r\nusc_enable_loopback(info,1);\r\n}\r\nstatic void usc_set_txidle( struct mgsl_struct *info )\r\n{\r\nu16 usc_idle_mode = IDLEMODE_FLAGS;\r\nswitch( info->idle_mode ){\r\ncase HDLC_TXIDLE_FLAGS: usc_idle_mode = IDLEMODE_FLAGS; break;\r\ncase HDLC_TXIDLE_ALT_ZEROS_ONES: usc_idle_mode = IDLEMODE_ALT_ONE_ZERO; break;\r\ncase HDLC_TXIDLE_ZEROS: usc_idle_mode = IDLEMODE_ZERO; break;\r\ncase HDLC_TXIDLE_ONES: usc_idle_mode = IDLEMODE_ONE; break;\r\ncase HDLC_TXIDLE_ALT_MARK_SPACE: usc_idle_mode = IDLEMODE_ALT_MARK_SPACE; break;\r\ncase HDLC_TXIDLE_SPACE: usc_idle_mode = IDLEMODE_SPACE; break;\r\ncase HDLC_TXIDLE_MARK: usc_idle_mode = IDLEMODE_MARK; break;\r\n}\r\ninfo->usc_idle_mode = usc_idle_mode;\r\ninfo->tcsr_value &= ~IDLEMODE_MASK;\r\ninfo->tcsr_value += usc_idle_mode;\r\nusc_OutReg(info, TCSR, info->tcsr_value);\r\nif ( info->params.mode == MGSL_MODE_RAW ) {\r\nunsigned char syncpat = 0;\r\nswitch( info->idle_mode ) {\r\ncase HDLC_TXIDLE_FLAGS:\r\nsyncpat = 0x7e;\r\nbreak;\r\ncase HDLC_TXIDLE_ALT_ZEROS_ONES:\r\nsyncpat = 0x55;\r\nbreak;\r\ncase HDLC_TXIDLE_ZEROS:\r\ncase HDLC_TXIDLE_SPACE:\r\nsyncpat = 0x00;\r\nbreak;\r\ncase HDLC_TXIDLE_ONES:\r\ncase HDLC_TXIDLE_MARK:\r\nsyncpat = 0xff;\r\nbreak;\r\ncase HDLC_TXIDLE_ALT_MARK_SPACE:\r\nsyncpat = 0xaa;\r\nbreak;\r\n}\r\nusc_SetTransmitSyncChars(info,syncpat,syncpat);\r\n}\r\n}\r\nstatic void usc_get_serial_signals( struct mgsl_struct *info )\r\n{\r\nu16 status;\r\ninfo->serial_signals &= SerialSignal_RTS | SerialSignal_DTR;\r\nstatus = usc_InReg( info, MISR );\r\nif ( status & MISCSTATUS_CTS )\r\ninfo->serial_signals |= SerialSignal_CTS;\r\nif ( status & MISCSTATUS_DCD )\r\ninfo->serial_signals |= SerialSignal_DCD;\r\nif ( status & MISCSTATUS_RI )\r\ninfo->serial_signals |= SerialSignal_RI;\r\nif ( status & MISCSTATUS_DSR )\r\ninfo->serial_signals |= SerialSignal_DSR;\r\n}\r\nstatic void usc_set_serial_signals( struct mgsl_struct *info )\r\n{\r\nu16 Control;\r\nunsigned char V24Out = info->serial_signals;\r\nControl = usc_InReg( info, PCR );\r\nif ( V24Out & SerialSignal_RTS )\r\nControl &= ~(BIT6);\r\nelse\r\nControl |= BIT6;\r\nif ( V24Out & SerialSignal_DTR )\r\nControl &= ~(BIT4);\r\nelse\r\nControl |= BIT4;\r\nusc_OutReg( info, PCR, Control );\r\n}\r\nstatic void usc_enable_async_clock( struct mgsl_struct *info, u32 data_rate )\r\n{\r\nif ( data_rate ) {\r\nusc_OutReg( info, CMCR, 0x0f64 );\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nusc_OutReg( info, TC0R, (u16)((691200/data_rate) - 1) );\r\nelse\r\nusc_OutReg( info, TC0R, (u16)((921600/data_rate) - 1) );\r\nusc_OutReg( info, HCR,\r\n(u16)((usc_InReg( info, HCR ) & ~BIT1) | BIT0) );\r\nusc_OutReg( info, IOCR,\r\n(u16)((usc_InReg(info, IOCR) & 0xfff8) | 0x0004) );\r\n} else {\r\nusc_OutReg( info, HCR, (u16)(usc_InReg( info, HCR ) & ~BIT0) );\r\n}\r\n}\r\nstatic void mgsl_reset_tx_dma_buffers( struct mgsl_struct *info )\r\n{\r\nunsigned int i;\r\nfor ( i = 0; i < info->tx_buffer_count; i++ ) {\r\n*((unsigned long *)&(info->tx_buffer_list[i].count)) = 0;\r\n}\r\ninfo->current_tx_buffer = 0;\r\ninfo->start_tx_dma_buffer = 0;\r\ninfo->tx_dma_buffers_used = 0;\r\ninfo->get_tx_holding_index = 0;\r\ninfo->put_tx_holding_index = 0;\r\ninfo->tx_holding_count = 0;\r\n}\r\nstatic int num_free_tx_dma_buffers(struct mgsl_struct *info)\r\n{\r\nreturn info->tx_buffer_count - info->tx_dma_buffers_used;\r\n}\r\nstatic void mgsl_reset_rx_dma_buffers( struct mgsl_struct *info )\r\n{\r\nunsigned int i;\r\nfor ( i = 0; i < info->rx_buffer_count; i++ ) {\r\n*((unsigned long *)&(info->rx_buffer_list[i].count)) = DMABUFFERSIZE;\r\n}\r\ninfo->current_rx_buffer = 0;\r\n}\r\nstatic void mgsl_free_rx_frame_buffers( struct mgsl_struct *info, unsigned int StartIndex, unsigned int EndIndex )\r\n{\r\nbool Done = false;\r\nDMABUFFERENTRY *pBufEntry;\r\nunsigned int Index;\r\nIndex = StartIndex;\r\nwhile( !Done ) {\r\npBufEntry = &(info->rx_buffer_list[Index]);\r\nif ( Index == EndIndex ) {\r\nDone = true;\r\n}\r\n*((unsigned long *)&(pBufEntry->count)) = DMABUFFERSIZE;\r\nIndex++;\r\nif ( Index == info->rx_buffer_count )\r\nIndex = 0;\r\n}\r\ninfo->current_rx_buffer = Index;\r\n}\r\nstatic bool mgsl_get_rx_frame(struct mgsl_struct *info)\r\n{\r\nunsigned int StartIndex, EndIndex;\r\nunsigned short status;\r\nDMABUFFERENTRY *pBufEntry;\r\nunsigned int framesize = 0;\r\nbool ReturnCode = false;\r\nunsigned long flags;\r\nstruct tty_struct *tty = info->port.tty;\r\nbool return_frame = false;\r\nStartIndex = EndIndex = info->current_rx_buffer;\r\nwhile( !info->rx_buffer_list[EndIndex].status ) {\r\nif ( info->rx_buffer_list[EndIndex].count )\r\ngoto Cleanup;\r\nEndIndex++;\r\nif ( EndIndex == info->rx_buffer_count )\r\nEndIndex = 0;\r\nif ( EndIndex == StartIndex ) {\r\nif ( info->rx_enabled ){\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_start_receiver(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\ngoto Cleanup;\r\n}\r\n}\r\nstatus = info->rx_buffer_list[EndIndex].status;\r\nif ( status & (RXSTATUS_SHORT_FRAME | RXSTATUS_OVERRUN |\r\nRXSTATUS_CRC_ERROR | RXSTATUS_ABORT) ) {\r\nif ( status & RXSTATUS_SHORT_FRAME )\r\ninfo->icount.rxshort++;\r\nelse if ( status & RXSTATUS_ABORT )\r\ninfo->icount.rxabort++;\r\nelse if ( status & RXSTATUS_OVERRUN )\r\ninfo->icount.rxover++;\r\nelse {\r\ninfo->icount.rxcrc++;\r\nif ( info->params.crc_type & HDLC_CRC_RETURN_EX )\r\nreturn_frame = true;\r\n}\r\nframesize = 0;\r\n#if SYNCLINK_GENERIC_HDLC\r\n{\r\ninfo->netdev->stats.rx_errors++;\r\ninfo->netdev->stats.rx_frame_errors++;\r\n}\r\n#endif\r\n} else\r\nreturn_frame = true;\r\nif ( return_frame ) {\r\nframesize = RCLRVALUE - info->rx_buffer_list[EndIndex].rcc;\r\nif ( info->params.crc_type == HDLC_CRC_16_CCITT )\r\nframesize -= 2;\r\nelse if ( info->params.crc_type == HDLC_CRC_32_CCITT )\r\nframesize -= 4;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk("%s(%d):mgsl_get_rx_frame(%s) status=%04X size=%d\n",\r\n__FILE__,__LINE__,info->device_name,status,framesize);\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\nmgsl_trace_block(info,info->rx_buffer_list[StartIndex].virt_addr,\r\nmin_t(int, framesize, DMABUFFERSIZE),0);\r\nif (framesize) {\r\nif ( ( (info->params.crc_type & HDLC_CRC_RETURN_EX) &&\r\n((framesize+1) > info->max_frame_size) ) ||\r\n(framesize > info->max_frame_size) )\r\ninfo->icount.rxlong++;\r\nelse {\r\nint copy_count = framesize;\r\nint index = StartIndex;\r\nunsigned char *ptmp = info->intermediate_rxbuffer;\r\nif ( !(status & RXSTATUS_CRC_ERROR))\r\ninfo->icount.rxok++;\r\nwhile(copy_count) {\r\nint partial_count;\r\nif ( copy_count > DMABUFFERSIZE )\r\npartial_count = DMABUFFERSIZE;\r\nelse\r\npartial_count = copy_count;\r\npBufEntry = &(info->rx_buffer_list[index]);\r\nmemcpy( ptmp, pBufEntry->virt_addr, partial_count );\r\nptmp += partial_count;\r\ncopy_count -= partial_count;\r\nif ( ++index == info->rx_buffer_count )\r\nindex = 0;\r\n}\r\nif ( info->params.crc_type & HDLC_CRC_RETURN_EX ) {\r\n++framesize;\r\n*ptmp = (status & RXSTATUS_CRC_ERROR ?\r\nRX_CRC_ERROR :\r\nRX_OK);\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\nprintk("%s(%d):mgsl_get_rx_frame(%s) rx frame status=%d\n",\r\n__FILE__,__LINE__,info->device_name,\r\n*ptmp);\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_rx(info,info->intermediate_rxbuffer,framesize);\r\nelse\r\n#endif\r\nldisc_receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);\r\n}\r\n}\r\nmgsl_free_rx_frame_buffers( info, StartIndex, EndIndex );\r\nReturnCode = true;\r\nCleanup:\r\nif ( info->rx_enabled && info->rx_overflow ) {\r\nif ( !info->rx_buffer_list[EndIndex].status &&\r\ninfo->rx_buffer_list[EndIndex].count ) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_start_receiver(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nreturn ReturnCode;\r\n}\r\nstatic bool mgsl_get_raw_rx_frame(struct mgsl_struct *info)\r\n{\r\nunsigned int CurrentIndex, NextIndex;\r\nunsigned short status;\r\nDMABUFFERENTRY *pBufEntry;\r\nunsigned int framesize = 0;\r\nbool ReturnCode = false;\r\nunsigned long flags;\r\nstruct tty_struct *tty = info->port.tty;\r\nCurrentIndex = NextIndex = info->current_rx_buffer;\r\n++NextIndex;\r\nif ( NextIndex == info->rx_buffer_count )\r\nNextIndex = 0;\r\nif ( info->rx_buffer_list[CurrentIndex].status != 0 ||\r\n(info->rx_buffer_list[CurrentIndex].count == 0 &&\r\ninfo->rx_buffer_list[NextIndex].count == 0)) {\r\nstatus = info->rx_buffer_list[CurrentIndex].status;\r\nif ( status & (RXSTATUS_SHORT_FRAME | RXSTATUS_OVERRUN |\r\nRXSTATUS_CRC_ERROR | RXSTATUS_ABORT) ) {\r\nif ( status & RXSTATUS_SHORT_FRAME )\r\ninfo->icount.rxshort++;\r\nelse if ( status & RXSTATUS_ABORT )\r\ninfo->icount.rxabort++;\r\nelse if ( status & RXSTATUS_OVERRUN )\r\ninfo->icount.rxover++;\r\nelse\r\ninfo->icount.rxcrc++;\r\nframesize = 0;\r\n} else {\r\nif ( status ) {\r\nif ( info->rx_buffer_list[CurrentIndex].rcc )\r\nframesize = RCLRVALUE - info->rx_buffer_list[CurrentIndex].rcc;\r\nelse\r\nframesize = DMABUFFERSIZE;\r\n}\r\nelse\r\nframesize = DMABUFFERSIZE;\r\n}\r\nif ( framesize > DMABUFFERSIZE ) {\r\nframesize = framesize % DMABUFFERSIZE;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk("%s(%d):mgsl_get_raw_rx_frame(%s) status=%04X size=%d\n",\r\n__FILE__,__LINE__,info->device_name,status,framesize);\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\nmgsl_trace_block(info,info->rx_buffer_list[CurrentIndex].virt_addr,\r\nmin_t(int, framesize, DMABUFFERSIZE),0);\r\nif (framesize) {\r\npBufEntry = &(info->rx_buffer_list[CurrentIndex]);\r\nmemcpy( info->intermediate_rxbuffer, pBufEntry->virt_addr, framesize);\r\ninfo->icount.rxok++;\r\nldisc_receive_buf(tty, info->intermediate_rxbuffer, info->flag_buf, framesize);\r\n}\r\nmgsl_free_rx_frame_buffers( info, CurrentIndex, CurrentIndex );\r\nReturnCode = true;\r\n}\r\nif ( info->rx_enabled && info->rx_overflow ) {\r\nif ( !info->rx_buffer_list[CurrentIndex].status &&\r\ninfo->rx_buffer_list[CurrentIndex].count ) {\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_start_receiver(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nreturn ReturnCode;\r\n}\r\nstatic void mgsl_load_tx_dma_buffer(struct mgsl_struct *info,\r\nconst char *Buffer, unsigned int BufferSize)\r\n{\r\nunsigned short Copycount;\r\nunsigned int i = 0;\r\nDMABUFFERENTRY *pBufEntry;\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\nmgsl_trace_block(info,Buffer, min_t(int, BufferSize, DMABUFFERSIZE), 1);\r\nif (info->params.flags & HDLC_FLAG_HDLC_LOOPMODE) {\r\ninfo->cmr_value |= BIT13;\r\n}\r\ni = info->current_tx_buffer;\r\ninfo->start_tx_dma_buffer = i;\r\ninfo->tx_buffer_list[i].status = info->cmr_value & 0xf000;\r\ninfo->tx_buffer_list[i].rcc = BufferSize;\r\ninfo->tx_buffer_list[i].count = BufferSize;\r\nwhile( BufferSize ){\r\npBufEntry = &info->tx_buffer_list[i++];\r\nif ( i == info->tx_buffer_count )\r\ni=0;\r\nif ( BufferSize > DMABUFFERSIZE )\r\nCopycount = DMABUFFERSIZE;\r\nelse\r\nCopycount = BufferSize;\r\nif ( info->bus_type == MGSL_BUS_TYPE_PCI )\r\nmgsl_load_pci_memory(pBufEntry->virt_addr, Buffer,Copycount);\r\nelse\r\nmemcpy(pBufEntry->virt_addr, Buffer, Copycount);\r\npBufEntry->count = Copycount;\r\nBuffer += Copycount;\r\nBufferSize -= Copycount;\r\n++info->tx_dma_buffers_used;\r\n}\r\ninfo->current_tx_buffer = i;\r\n}\r\nstatic bool mgsl_register_test( struct mgsl_struct *info )\r\n{\r\nstatic unsigned short BitPatterns[] =\r\n{ 0x0000, 0xffff, 0xaaaa, 0x5555, 0x1234, 0x6969, 0x9696, 0x0f0f };\r\nstatic unsigned int Patterncount = ARRAY_SIZE(BitPatterns);\r\nunsigned int i;\r\nbool rc = true;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_reset(info);\r\nif ( (usc_InReg( info, SICR ) != 0) ||\r\n(usc_InReg( info, IVR ) != 0) ||\r\n(usc_InDmaReg( info, DIVR ) != 0) ){\r\nrc = false;\r\n}\r\nif ( rc ){\r\nfor ( i = 0 ; i < Patterncount ; i++ ) {\r\nusc_OutReg( info, TC0R, BitPatterns[i] );\r\nusc_OutReg( info, TC1R, BitPatterns[(i+1)%Patterncount] );\r\nusc_OutReg( info, TCLR, BitPatterns[(i+2)%Patterncount] );\r\nusc_OutReg( info, RCLR, BitPatterns[(i+3)%Patterncount] );\r\nusc_OutReg( info, RSR, BitPatterns[(i+4)%Patterncount] );\r\nusc_OutDmaReg( info, TBCR, BitPatterns[(i+5)%Patterncount] );\r\nif ( (usc_InReg( info, TC0R ) != BitPatterns[i]) ||\r\n(usc_InReg( info, TC1R ) != BitPatterns[(i+1)%Patterncount]) ||\r\n(usc_InReg( info, TCLR ) != BitPatterns[(i+2)%Patterncount]) ||\r\n(usc_InReg( info, RCLR ) != BitPatterns[(i+3)%Patterncount]) ||\r\n(usc_InReg( info, RSR ) != BitPatterns[(i+4)%Patterncount]) ||\r\n(usc_InDmaReg( info, TBCR ) != BitPatterns[(i+5)%Patterncount]) ){\r\nrc = false;\r\nbreak;\r\n}\r\n}\r\n}\r\nusc_reset(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn rc;\r\n}\r\nstatic bool mgsl_irq_test( struct mgsl_struct *info )\r\n{\r\nunsigned long EndTime;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_reset(info);\r\ninfo->irq_occurred = false;\r\nusc_OutReg( info, PCR, (unsigned short)((usc_InReg(info, PCR) | BIT13) & ~BIT12) );\r\nusc_EnableMasterIrqBit(info);\r\nusc_EnableInterrupts(info, IO_PIN);\r\nusc_ClearIrqPendingBits(info, IO_PIN);\r\nusc_UnlatchIostatusBits(info, MISCSTATUS_TXC_LATCHED);\r\nusc_EnableStatusIrqs(info, SICR_TXC_ACTIVE + SICR_TXC_INACTIVE);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nEndTime=100;\r\nwhile( EndTime-- && !info->irq_occurred ) {\r\nmsleep_interruptible(10);\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_reset(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn info->irq_occurred;\r\n}\r\nstatic bool mgsl_dma_test( struct mgsl_struct *info )\r\n{\r\nunsigned short FifoLevel;\r\nunsigned long phys_addr;\r\nunsigned int FrameSize;\r\nunsigned int i;\r\nchar *TmpPtr;\r\nbool rc = true;\r\nunsigned short status=0;\r\nunsigned long EndTime;\r\nunsigned long flags;\r\nMGSL_PARAMS tmp_params;\r\nmemcpy(&tmp_params,&info->params,sizeof(MGSL_PARAMS));\r\nmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\r\n#define TESTFRAMESIZE 40\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_reset(info);\r\nusc_set_sdlc_mode(info);\r\nusc_enable_loopback(info,1);\r\nusc_OutDmaReg( info, RDMR, 0xe200 );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nFrameSize = TESTFRAMESIZE;\r\ninfo->tx_buffer_list[0].count = FrameSize;\r\ninfo->tx_buffer_list[0].rcc = FrameSize;\r\ninfo->tx_buffer_list[0].status = 0x4000;\r\nTmpPtr = info->tx_buffer_list[0].virt_addr;\r\nfor (i = 0; i < FrameSize; i++ )\r\n*TmpPtr++ = i;\r\ninfo->rx_buffer_list[0].status = 0;\r\ninfo->rx_buffer_list[0].count = FrameSize + 4;\r\nmemset( info->rx_buffer_list[0].virt_addr, 0, FrameSize + 4 );\r\ninfo->tx_buffer_list[1].count = 0;\r\ninfo->rx_buffer_list[1].count = 0;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_RTCmd( info, RTCmd_PurgeRxFifo );\r\nphys_addr = info->rx_buffer_list[0].phys_entry;\r\nusc_OutDmaReg( info, NRARL, (unsigned short)phys_addr );\r\nusc_OutDmaReg( info, NRARU, (unsigned short)(phys_addr >> 16) );\r\nusc_InDmaReg( info, RDMR );\r\nusc_DmaCmd( info, DmaCmd_InitRxChannel );\r\nusc_OutReg( info, RMR, (unsigned short)((usc_InReg(info, RMR) & 0xfffc) | 0x0002) );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nEndTime = jiffies + msecs_to_jiffies(100);\r\nfor(;;) {\r\nif (time_after(jiffies, EndTime)) {\r\nrc = false;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nstatus = usc_InDmaReg( info, RDMR );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nif ( !(status & BIT4) && (status & BIT5) ) {\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_OutReg( info, TCLR, (unsigned short)info->tx_buffer_list[0].count );\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\nphys_addr = info->tx_buffer_list[0].phys_entry;\r\nusc_OutDmaReg( info, NTARL, (unsigned short)phys_addr );\r\nusc_OutDmaReg( info, NTARU, (unsigned short)(phys_addr >> 16) );\r\nusc_OutReg( info, TCSR, (unsigned short)(( usc_InReg(info, TCSR) & 0x0f00) | 0xfa) );\r\nusc_DmaCmd( info, DmaCmd_InitTxChannel );\r\nusc_TCmd( info, TCmd_SelectTicrTxFifostatus );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nEndTime = jiffies + msecs_to_jiffies(100);\r\nfor(;;) {\r\nif (time_after(jiffies, EndTime)) {\r\nrc = false;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nFifoLevel = usc_InReg(info, TICR) >> 8;\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nif ( FifoLevel < 16 )\r\nbreak;\r\nelse\r\nif ( FrameSize < 32 ) {\r\nif ( FifoLevel <= (32 - FrameSize) )\r\nbreak;\r\n}\r\n}\r\nif ( rc )\r\n{\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_TCmd( info, TCmd_SendFrame );\r\nusc_OutReg( info, TMR, (unsigned short)((usc_InReg(info, TMR) & 0xfffc) | 0x0002) );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nEndTime = jiffies + msecs_to_jiffies(100);\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nstatus = usc_InReg( info, TCSR );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nwhile ( !(status & (BIT6 | BIT5 | BIT4 | BIT2 | BIT1)) ) {\r\nif (time_after(jiffies, EndTime)) {\r\nrc = false;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nstatus = usc_InReg( info, TCSR );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n}\r\n}\r\nif ( rc ){\r\nif ( status & (BIT5 | BIT1) )\r\nrc = false;\r\n}\r\nif ( rc ) {\r\nEndTime = jiffies + msecs_to_jiffies(100);\r\nstatus=info->rx_buffer_list[0].status;\r\nwhile ( status == 0 ) {\r\nif (time_after(jiffies, EndTime)) {\r\nrc = false;\r\nbreak;\r\n}\r\nstatus=info->rx_buffer_list[0].status;\r\n}\r\n}\r\nif ( rc ) {\r\nstatus = info->rx_buffer_list[0].status;\r\nif ( status & (BIT8 | BIT3 | BIT1) ) {\r\nrc = false;\r\n} else {\r\nif ( memcmp( info->tx_buffer_list[0].virt_addr ,\r\ninfo->rx_buffer_list[0].virt_addr, FrameSize ) ){\r\nrc = false;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_reset( info );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nmemcpy(&info->params,&tmp_params,sizeof(MGSL_PARAMS));\r\nreturn rc;\r\n}\r\nstatic int mgsl_adapter_test( struct mgsl_struct *info )\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):Testing device %s\n",\r\n__FILE__,__LINE__,info->device_name );\r\nif ( !mgsl_register_test( info ) ) {\r\ninfo->init_error = DiagStatus_AddressFailure;\r\nprintk( "%s(%d):Register test failure for device %s Addr=%04X\n",\r\n__FILE__,__LINE__,info->device_name, (unsigned short)(info->io_base) );\r\nreturn -ENODEV;\r\n}\r\nif ( !mgsl_irq_test( info ) ) {\r\ninfo->init_error = DiagStatus_IrqFailure;\r\nprintk( "%s(%d):Interrupt test failure for device %s IRQ=%d\n",\r\n__FILE__,__LINE__,info->device_name, (unsigned short)(info->irq_level) );\r\nreturn -ENODEV;\r\n}\r\nif ( !mgsl_dma_test( info ) ) {\r\ninfo->init_error = DiagStatus_DmaFailure;\r\nprintk( "%s(%d):DMA test failure for device %s DMA=%d\n",\r\n__FILE__,__LINE__,info->device_name, (unsigned short)(info->dma_level) );\r\nreturn -ENODEV;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):device %s passed diagnostics\n",\r\n__FILE__,__LINE__,info->device_name );\r\nreturn 0;\r\n}\r\nstatic bool mgsl_memory_test( struct mgsl_struct *info )\r\n{\r\nstatic unsigned long BitPatterns[] =\r\n{ 0x0, 0x55555555, 0xaaaaaaaa, 0x66666666, 0x99999999, 0xffffffff, 0x12345678 };\r\nunsigned long Patterncount = ARRAY_SIZE(BitPatterns);\r\nunsigned long i;\r\nunsigned long TestLimit = SHARED_MEM_ADDRESS_SIZE/sizeof(unsigned long);\r\nunsigned long * TestAddr;\r\nif ( info->bus_type != MGSL_BUS_TYPE_PCI )\r\nreturn true;\r\nTestAddr = (unsigned long *)info->memory_base;\r\nfor ( i = 0 ; i < Patterncount ; i++ ) {\r\n*TestAddr = BitPatterns[i];\r\nif ( *TestAddr != BitPatterns[i] )\r\nreturn false;\r\n}\r\nfor ( i = 0 ; i < TestLimit ; i++ ) {\r\n*TestAddr = i * 4;\r\nTestAddr++;\r\n}\r\nTestAddr = (unsigned long *)info->memory_base;\r\nfor ( i = 0 ; i < TestLimit ; i++ ) {\r\nif ( *TestAddr != i * 4 )\r\nreturn false;\r\nTestAddr++;\r\n}\r\nmemset( info->memory_base, 0, SHARED_MEM_ADDRESS_SIZE );\r\nreturn true;\r\n}\r\nstatic void mgsl_load_pci_memory( char* TargetPtr, const char* SourcePtr,\r\nunsigned short count )\r\n{\r\n#define PCI_LOAD_INTERVAL 64\r\nunsigned short Intervalcount = count / PCI_LOAD_INTERVAL;\r\nunsigned short Index;\r\nunsigned long Dummy;\r\nfor ( Index = 0 ; Index < Intervalcount ; Index++ )\r\n{\r\nmemcpy(TargetPtr, SourcePtr, PCI_LOAD_INTERVAL);\r\nDummy = *((volatile unsigned long *)TargetPtr);\r\nTargetPtr += PCI_LOAD_INTERVAL;\r\nSourcePtr += PCI_LOAD_INTERVAL;\r\n}\r\nmemcpy( TargetPtr, SourcePtr, count % PCI_LOAD_INTERVAL );\r\n}\r\nstatic void mgsl_trace_block(struct mgsl_struct *info,const char* data, int count, int xmit)\r\n{\r\nint i;\r\nint linecount;\r\nif (xmit)\r\nprintk("%s tx data:\n",info->device_name);\r\nelse\r\nprintk("%s rx data:\n",info->device_name);\r\nwhile(count) {\r\nif (count > 16)\r\nlinecount = 16;\r\nelse\r\nlinecount = count;\r\nfor(i=0;i<linecount;i++)\r\nprintk("%02X ",(unsigned char)data[i]);\r\nfor(;i<17;i++)\r\nprintk(" ");\r\nfor(i=0;i<linecount;i++) {\r\nif (data[i]>=040 && data[i]<=0176)\r\nprintk("%c",data[i]);\r\nelse\r\nprintk(".");\r\n}\r\nprintk("\n");\r\ndata += linecount;\r\ncount -= linecount;\r\n}\r\n}\r\nstatic void mgsl_tx_timeout(unsigned long context)\r\n{\r\nstruct mgsl_struct *info = (struct mgsl_struct*)context;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):mgsl_tx_timeout(%s)\n",\r\n__FILE__,__LINE__,info->device_name);\r\nif(info->tx_active &&\r\n(info->params.mode == MGSL_MODE_HDLC ||\r\ninfo->params.mode == MGSL_MODE_RAW) ) {\r\ninfo->icount.txtimeout++;\r\n}\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\ninfo->tx_active = false;\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nif ( info->params.flags & HDLC_FLAG_HDLC_LOOPMODE )\r\nusc_loopmode_cancel_transmit( info );\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\nmgsl_bh_transmit(info);\r\n}\r\nstatic int mgsl_loopmode_send_done( struct mgsl_struct * info )\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (info->params.flags & HDLC_FLAG_HDLC_LOOPMODE) {\r\nif (info->tx_active)\r\ninfo->loopmode_send_done_requested = true;\r\nelse\r\nusc_loopmode_send_done(info);\r\n}\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn 0;\r\n}\r\nstatic void usc_loopmode_send_done( struct mgsl_struct * info )\r\n{\r\ninfo->loopmode_send_done_requested = false;\r\ninfo->cmr_value &= ~BIT13;\r\nusc_OutReg(info, CMR, info->cmr_value);\r\n}\r\nstatic void usc_loopmode_cancel_transmit( struct mgsl_struct * info )\r\n{\r\nusc_RTCmd( info, RTCmd_PurgeTxFifo );\r\nusc_DmaCmd( info, DmaCmd_ResetTxChannel );\r\nusc_loopmode_send_done( info );\r\n}\r\nstatic void usc_loopmode_insert_request( struct mgsl_struct * info )\r\n{\r\ninfo->loopmode_insert_requested = true;\r\nusc_OutReg( info, RICR,\r\n(usc_InReg( info, RICR ) | RXSTATUS_ABORT_RECEIVED ) );\r\ninfo->cmr_value |= BIT13;\r\nusc_OutReg(info, CMR, info->cmr_value);\r\n}\r\nstatic int usc_loopmode_active( struct mgsl_struct * info)\r\n{\r\nreturn usc_InReg( info, CCSR ) & BIT7 ? 1 : 0 ;\r\n}\r\nstatic int hdlcdev_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nunsigned char new_encoding;\r\nunsigned short new_crctype;\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nswitch (encoding)\r\n{\r\ncase ENCODING_NRZ: new_encoding = HDLC_ENCODING_NRZ; break;\r\ncase ENCODING_NRZI: new_encoding = HDLC_ENCODING_NRZI_SPACE; break;\r\ncase ENCODING_FM_MARK: new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;\r\ncase ENCODING_FM_SPACE: new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;\r\ncase ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (parity)\r\n{\r\ncase PARITY_NONE: new_crctype = HDLC_CRC_NONE; break;\r\ncase PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;\r\ncase PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;\r\ndefault: return -EINVAL;\r\n}\r\ninfo->params.encoding = new_encoding;\r\ninfo->params.crc_type = new_crctype;\r\nif (info->netcount)\r\nmgsl_program_hw(info);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk(KERN_INFO "%s:hdlc_xmit(%s)\n",__FILE__,dev->name);\r\nnetif_stop_queue(dev);\r\ninfo->xmit_cnt = skb->len;\r\nmgsl_load_tx_dma_buffer(info, skb->data, skb->len);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\ndev->trans_start = jiffies;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nif (!info->tx_active)\r\nusc_start_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hdlcdev_open(struct net_device *dev)\r\n{\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nint rc;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_open(%s)\n",__FILE__,dev->name);\r\nrc = hdlc_open(dev);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->port.count != 0 || info->netcount != 0) {\r\nprintk(KERN_WARNING "%s: hdlc_open returning busy\n", dev->name);\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn -EBUSY;\r\n}\r\ninfo->netcount=1;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif ((rc = startup(info)) != 0) {\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn rc;\r\n}\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nmgsl_program_hw(info);\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nspin_lock_irqsave(&info->irq_spinlock, flags);\r\nusc_get_serial_signals(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock, flags);\r\nif (info->serial_signals & SerialSignal_DCD)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_close(struct net_device *dev)\r\n{\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_close(%s)\n",__FILE__,dev->name);\r\nnetif_stop_queue(dev);\r\nshutdown(info);\r\nhdlc_close(dev);\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nunsigned int flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_ioctl(%s)\n",__FILE__,dev->name);\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nflags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\nmemset(&new_line, 0, sizeof(new_line));\r\nswitch (flags){\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;\r\ncase (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_INT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_TXINT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;\r\ndefault: new_line.clock_type = CLOCK_DEFAULT;\r\n}\r\nnew_line.clock_rate = info->params.clock_speed;\r\nnew_line.loopback = info->params.loopback ? 1:0;\r\nif (copy_to_user(line, &new_line, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nswitch (new_line.clock_type)\r\n{\r\ncase CLOCK_EXT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;\r\ncase CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;\r\ncase CLOCK_INT: flags = HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_TXINT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_DEFAULT: flags = info->params.flags &\r\n(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN); break;\r\ndefault: return -EINVAL;\r\n}\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\ninfo->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\ninfo->params.flags |= flags;\r\ninfo->params.loopback = new_line.loopback;\r\nif (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))\r\ninfo->params.clock_speed = new_line.clock_rate;\r\nelse\r\ninfo->params.clock_speed = 0;\r\nif (info->netcount)\r\nmgsl_program_hw(info);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void hdlcdev_tx_timeout(struct net_device *dev)\r\n{\r\nstruct mgsl_struct *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_tx_timeout(%s)\n",dev->name);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nspin_lock_irqsave(&info->irq_spinlock,flags);\r\nusc_stop_transmitter(info);\r\nspin_unlock_irqrestore(&info->irq_spinlock,flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void hdlcdev_tx_done(struct mgsl_struct *info)\r\n{\r\nif (netif_queue_stopped(info->netdev))\r\nnetif_wake_queue(info->netdev);\r\n}\r\nstatic void hdlcdev_rx(struct mgsl_struct *info, char *buf, int size)\r\n{\r\nstruct sk_buff *skb = dev_alloc_skb(size);\r\nstruct net_device *dev = info->netdev;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_rx(%s)\n", dev->name);\r\nif (skb == NULL) {\r\nprintk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, size), buf, size);\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += size;\r\nnetif_rx(skb);\r\n}\r\nstatic int hdlcdev_init(struct mgsl_struct *info)\r\n{\r\nint rc;\r\nstruct net_device *dev;\r\nhdlc_device *hdlc;\r\ndev = alloc_hdlcdev(info);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s:hdlc device allocation failure\n",__FILE__);\r\nreturn -ENOMEM;\r\n}\r\ndev->base_addr = info->io_base;\r\ndev->irq = info->irq_level;\r\ndev->dma = info->dma_level;\r\ndev->netdev_ops = &hdlcdev_ops;\r\ndev->watchdog_timeo = 10 * HZ;\r\ndev->tx_queue_len = 50;\r\nhdlc = dev_to_hdlc(dev);\r\nhdlc->attach = hdlcdev_attach;\r\nhdlc->xmit = hdlcdev_xmit;\r\nrc = register_hdlc_device(dev);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s:unable to register hdlc device\n",__FILE__);\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\ninfo->netdev = dev;\r\nreturn 0;\r\n}\r\nstatic void hdlcdev_exit(struct mgsl_struct *info)\r\n{\r\nunregister_hdlc_device(info->netdev);\r\nfree_netdev(info->netdev);\r\ninfo->netdev = NULL;\r\n}\r\nstatic int synclink_init_one (struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct mgsl_struct *info;\r\nif (pci_enable_device(dev)) {\r\nprintk("error enabling pci device %p\n", dev);\r\nreturn -EIO;\r\n}\r\ninfo = mgsl_allocate_device();\r\nif (!info) {\r\nprintk("can't allocate device instance data.\n");\r\nreturn -EIO;\r\n}\r\ninfo->io_base = pci_resource_start(dev, 2);\r\ninfo->irq_level = dev->irq;\r\ninfo->phys_memory_base = pci_resource_start(dev, 3);\r\ninfo->phys_lcr_base = pci_resource_start(dev, 0);\r\ninfo->lcr_offset = info->phys_lcr_base & (PAGE_SIZE-1);\r\ninfo->phys_lcr_base &= ~(PAGE_SIZE-1);\r\ninfo->bus_type = MGSL_BUS_TYPE_PCI;\r\ninfo->io_addr_size = 8;\r\ninfo->irq_flags = IRQF_SHARED;\r\nif (dev->device == 0x0210) {\r\ninfo->misc_ctrl_value = 0x007c4080;\r\ninfo->hw_version = 1;\r\n} else {\r\ninfo->misc_ctrl_value = 0x087e4546;\r\ninfo->hw_version = 0;\r\n}\r\nmgsl_add_device(info);\r\nreturn 0;\r\n}\r\nstatic void synclink_remove_one (struct pci_dev *dev)\r\n{\r\n}
