const char *crush_bucket_alg_name(int alg)\r\n{\r\nswitch (alg) {\r\ncase CRUSH_BUCKET_UNIFORM: return "uniform";\r\ncase CRUSH_BUCKET_LIST: return "list";\r\ncase CRUSH_BUCKET_TREE: return "tree";\r\ncase CRUSH_BUCKET_STRAW: return "straw";\r\ncase CRUSH_BUCKET_STRAW2: return "straw2";\r\ndefault: return "unknown";\r\n}\r\n}\r\nint crush_get_bucket_item_weight(const struct crush_bucket *b, int p)\r\n{\r\nif ((__u32)p >= b->size)\r\nreturn 0;\r\nswitch (b->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\nreturn ((struct crush_bucket_uniform *)b)->item_weight;\r\ncase CRUSH_BUCKET_LIST:\r\nreturn ((struct crush_bucket_list *)b)->item_weights[p];\r\ncase CRUSH_BUCKET_TREE:\r\nreturn ((struct crush_bucket_tree *)b)->node_weights[crush_calc_tree_node(p)];\r\ncase CRUSH_BUCKET_STRAW:\r\nreturn ((struct crush_bucket_straw *)b)->item_weights[p];\r\ncase CRUSH_BUCKET_STRAW2:\r\nreturn ((struct crush_bucket_straw2 *)b)->item_weights[p];\r\n}\r\nreturn 0;\r\n}\r\nvoid crush_destroy_bucket_uniform(struct crush_bucket_uniform *b)\r\n{\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_list(struct crush_bucket_list *b)\r\n{\r\nkfree(b->item_weights);\r\nkfree(b->sum_weights);\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_tree(struct crush_bucket_tree *b)\r\n{\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b->node_weights);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_straw(struct crush_bucket_straw *b)\r\n{\r\nkfree(b->straws);\r\nkfree(b->item_weights);\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_straw2(struct crush_bucket_straw2 *b)\r\n{\r\nkfree(b->item_weights);\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket(struct crush_bucket *b)\r\n{\r\nswitch (b->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\ncrush_destroy_bucket_uniform((struct crush_bucket_uniform *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_LIST:\r\ncrush_destroy_bucket_list((struct crush_bucket_list *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_TREE:\r\ncrush_destroy_bucket_tree((struct crush_bucket_tree *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_STRAW:\r\ncrush_destroy_bucket_straw((struct crush_bucket_straw *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_STRAW2:\r\ncrush_destroy_bucket_straw2((struct crush_bucket_straw2 *)b);\r\nbreak;\r\n}\r\n}\r\nvoid crush_destroy(struct crush_map *map)\r\n{\r\nif (map->buckets) {\r\n__s32 b;\r\nfor (b = 0; b < map->max_buckets; b++) {\r\nif (map->buckets[b] == NULL)\r\ncontinue;\r\ncrush_destroy_bucket(map->buckets[b]);\r\n}\r\nkfree(map->buckets);\r\n}\r\nif (map->rules) {\r\n__u32 b;\r\nfor (b = 0; b < map->max_rules; b++)\r\ncrush_destroy_rule(map->rules[b]);\r\nkfree(map->rules);\r\n}\r\n#ifndef __KERNEL__\r\nkfree(map->choose_tries);\r\n#endif\r\nkfree(map);\r\n}\r\nvoid crush_destroy_rule(struct crush_rule *rule)\r\n{\r\nkfree(rule);\r\n}
