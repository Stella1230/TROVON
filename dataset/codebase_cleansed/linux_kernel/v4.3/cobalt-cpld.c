static u16 cpld_read(struct cobalt *cobalt, u32 offset)\r\n{\r\nreturn cobalt_bus_read32(cobalt->bar1, ADRS(offset));\r\n}\r\nstatic void cpld_write(struct cobalt *cobalt, u32 offset, u16 val)\r\n{\r\nreturn cobalt_bus_write32(cobalt->bar1, ADRS(offset), val);\r\n}\r\nstatic void cpld_info_ver3(struct cobalt *cobalt)\r\n{\r\nu32 rd;\r\nu32 tmp;\r\ncobalt_info("CPLD System control register (read/write)\n");\r\ncobalt_info("\t\tSystem control: 0x%04x (0x0f00)\n",\r\ncpld_read(cobalt, 0));\r\ncobalt_info("CPLD Clock control register (read/write)\n");\r\ncobalt_info("\t\tClock control: 0x%04x (0x0000)\n",\r\ncpld_read(cobalt, 0x04));\r\ncobalt_info("CPLD HSMA Clk Osc register (read/write) - Must set wr trigger to load default values\n");\r\ncobalt_info("\t\tRegister #7:\t0x%04x (0x0022)\n",\r\ncpld_read(cobalt, 0x08));\r\ncobalt_info("\t\tRegister #8:\t0x%04x (0x0047)\n",\r\ncpld_read(cobalt, 0x0c));\r\ncobalt_info("\t\tRegister #9:\t0x%04x (0x00fa)\n",\r\ncpld_read(cobalt, 0x10));\r\ncobalt_info("\t\tRegister #10:\t0x%04x (0x0061)\n",\r\ncpld_read(cobalt, 0x14));\r\ncobalt_info("\t\tRegister #11:\t0x%04x (0x001e)\n",\r\ncpld_read(cobalt, 0x18));\r\ncobalt_info("\t\tRegister #12:\t0x%04x (0x0045)\n",\r\ncpld_read(cobalt, 0x1c));\r\ncobalt_info("\t\tRegister #135:\t0x%04x\n",\r\ncpld_read(cobalt, 0x20));\r\ncobalt_info("\t\tRegister #137:\t0x%04x\n",\r\ncpld_read(cobalt, 0x24));\r\ncobalt_info("CPLD System status register (read only)\n");\r\ncobalt_info("\t\tSystem status: 0x%04x\n",\r\ncpld_read(cobalt, 0x28));\r\ncobalt_info("CPLD MAXII info register (read only)\n");\r\ncobalt_info("\t\tBoard serial number: 0x%04x\n",\r\ncpld_read(cobalt, 0x2c));\r\ncobalt_info("\t\tMAXII program revision: 0x%04x\n",\r\ncpld_read(cobalt, 0x30));\r\ncobalt_info("CPLD temp and voltage ADT7411 registers (read only)\n");\r\ncobalt_info("\t\tBoard temperature: %u Celcius\n",\r\ncpld_read(cobalt, 0x34) / 4);\r\ncobalt_info("\t\tFPGA temperature: %u Celcius\n",\r\ncpld_read(cobalt, 0x38) / 4);\r\nrd = cpld_read(cobalt, 0x3c);\r\ntmp = (rd * 33 * 1000) / (483 * 10);\r\ncobalt_info("\t\tVDD 3V3: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x40);\r\ntmp = (rd * 74 * 2197) / (27 * 1000);\r\ncobalt_info("\t\tADC ch3 5V: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x44);\r\ntmp = (rd * 74 * 2197) / (47 * 1000);\r\ncobalt_info("\t\tADC ch4 3V: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x48);\r\ntmp = (rd * 57 * 2197) / (47 * 1000);\r\ncobalt_info("\t\tADC ch5 2V5: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x4c);\r\ntmp = (rd * 2197) / 1000;\r\ncobalt_info("\t\tADC ch6 1V8: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x50);\r\ntmp = (rd * 2197) / 1000;\r\ncobalt_info("\t\tADC ch7 1V5: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\nrd = cpld_read(cobalt, 0x54);\r\ntmp = (rd * 2197) / 1000;\r\ncobalt_info("\t\tADC ch8 0V9: %u,%03uV\n", tmp / 1000, tmp % 1000);\r\n}\r\nvoid cobalt_cpld_status(struct cobalt *cobalt)\r\n{\r\nu32 rev = cpld_read(cobalt, 0x30);\r\nswitch (rev) {\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ncpld_info_ver3(cobalt);\r\nbreak;\r\ndefault:\r\ncobalt_info("CPLD revision %u is not supported!\n", rev);\r\nbreak;\r\n}\r\n}\r\nbool cobalt_cpld_set_freq(struct cobalt *cobalt, unsigned f_out)\r\n{\r\nconst unsigned f_xtal = 39170000;\r\nu64 dco;\r\nu64 rfreq;\r\nunsigned delta = 0xffffffff;\r\nunsigned i_best = 0;\r\nunsigned i;\r\nu8 n1, hsdiv;\r\nu8 regs[6];\r\nint found = 0;\r\nu16 clock_ctrl;\r\nint retries = 3;\r\nfor (i = 0; i < ARRAY_SIZE(multipliers); i++) {\r\nunsigned mult = multipliers[i].mult;\r\nu32 d;\r\ndco = (u64)f_out * mult;\r\nif (dco < DCO_MIN || dco > DCO_MAX)\r\ncontinue;\r\ndiv_u64_rem((dco << 28) + f_xtal / 2, f_xtal, &d);\r\nif (d < delta) {\r\nfound = 1;\r\ni_best = i;\r\ndelta = d;\r\n}\r\n}\r\nif (!found)\r\nreturn false;\r\ndco = (u64)f_out * multipliers[i_best].mult;\r\nn1 = multipliers[i_best].n1 - 1;\r\nhsdiv = multipliers[i_best].hsdiv - 4;\r\nrfreq = div_u64(dco << 28, f_xtal);\r\nclock_ctrl = cpld_read(cobalt, SI570_CLOCK_CTRL);\r\nclock_ctrl |= S01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_FPGA_CTRL;\r\nclock_ctrl |= S01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN;\r\nregs[0] = (hsdiv << 5) | (n1 >> 2);\r\nregs[1] = ((n1 & 0x3) << 6) | (rfreq >> 32);\r\nregs[2] = (rfreq >> 24) & 0xff;\r\nregs[3] = (rfreq >> 16) & 0xff;\r\nregs[4] = (rfreq >> 8) & 0xff;\r\nregs[5] = rfreq & 0xff;\r\ncobalt_dbg(1, "%u: %02x %02x %02x %02x %02x %02x\n", f_out,\r\nregs[0], regs[1], regs[2], regs[3], regs[4], regs[5]);\r\nwhile (retries--) {\r\nu8 read_regs[6];\r\ncpld_write(cobalt, SI570_CLOCK_CTRL,\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN |\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_FPGA_CTRL);\r\nusleep_range(10000, 15000);\r\ncpld_write(cobalt, SI570_REG7, regs[0]);\r\ncpld_write(cobalt, SI570_REG8, regs[1]);\r\ncpld_write(cobalt, SI570_REG9, regs[2]);\r\ncpld_write(cobalt, SI570_REG10, regs[3]);\r\ncpld_write(cobalt, SI570_REG11, regs[4]);\r\ncpld_write(cobalt, SI570_REG12, regs[5]);\r\ncpld_write(cobalt, SI570_CLOCK_CTRL,\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN |\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_WR_TRIGGER);\r\nusleep_range(10000, 15000);\r\ncpld_write(cobalt, SI570_CLOCK_CTRL,\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN |\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_FPGA_CTRL);\r\nusleep_range(10000, 15000);\r\nread_regs[0] = cpld_read(cobalt, SI570_REG7);\r\nread_regs[1] = cpld_read(cobalt, SI570_REG8);\r\nread_regs[2] = cpld_read(cobalt, SI570_REG9);\r\nread_regs[3] = cpld_read(cobalt, SI570_REG10);\r\nread_regs[4] = cpld_read(cobalt, SI570_REG11);\r\nread_regs[5] = cpld_read(cobalt, SI570_REG12);\r\ncpld_write(cobalt, SI570_CLOCK_CTRL,\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN |\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_FPGA_CTRL |\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_RST_TRIGGER);\r\nusleep_range(10000, 15000);\r\ncpld_write(cobalt, SI570_CLOCK_CTRL,\r\nS01755_REG_CLOCK_CTRL_BITMAP_CLKHSMA_EN);\r\nusleep_range(10000, 15000);\r\nif (!memcmp(read_regs, regs, sizeof(read_regs)))\r\nbreak;\r\ncobalt_dbg(1, "retry: %02x %02x %02x %02x %02x %02x\n",\r\nread_regs[0], read_regs[1], read_regs[2],\r\nread_regs[3], read_regs[4], read_regs[5]);\r\n}\r\nif (2 - retries)\r\ncobalt_info("Needed %d retries\n", 2 - retries);\r\nreturn true;\r\n}
