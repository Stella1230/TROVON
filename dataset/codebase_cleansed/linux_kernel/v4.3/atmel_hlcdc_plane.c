static inline struct atmel_hlcdc_plane_state *\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(struct drm_plane_state *s)\r\n{\r\nreturn container_of(s, struct atmel_hlcdc_plane_state, base);\r\n}\r\nstatic int atmel_hlcdc_format_to_plane_mode(u32 format, u32 *mode)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_XRGB4444:\r\n*mode = ATMEL_HLCDC_XRGB4444_MODE;\r\nbreak;\r\ncase DRM_FORMAT_ARGB4444:\r\n*mode = ATMEL_HLCDC_ARGB4444_MODE;\r\nbreak;\r\ncase DRM_FORMAT_RGBA4444:\r\n*mode = ATMEL_HLCDC_RGBA4444_MODE;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\n*mode = ATMEL_HLCDC_RGB565_MODE;\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\n*mode = ATMEL_HLCDC_RGB888_MODE;\r\nbreak;\r\ncase DRM_FORMAT_ARGB1555:\r\n*mode = ATMEL_HLCDC_ARGB1555_MODE;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\n*mode = ATMEL_HLCDC_XRGB8888_MODE;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\n*mode = ATMEL_HLCDC_ARGB8888_MODE;\r\nbreak;\r\ncase DRM_FORMAT_RGBA8888:\r\n*mode = ATMEL_HLCDC_RGBA8888_MODE;\r\nbreak;\r\ncase DRM_FORMAT_AYUV:\r\n*mode = ATMEL_HLCDC_AYUV_MODE;\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\n*mode = ATMEL_HLCDC_YUYV_MODE;\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\n*mode = ATMEL_HLCDC_UYVY_MODE;\r\nbreak;\r\ncase DRM_FORMAT_YVYU:\r\n*mode = ATMEL_HLCDC_YVYU_MODE;\r\nbreak;\r\ncase DRM_FORMAT_VYUY:\r\n*mode = ATMEL_HLCDC_VYUY_MODE;\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\n*mode = ATMEL_HLCDC_NV21_MODE;\r\nbreak;\r\ncase DRM_FORMAT_NV61:\r\n*mode = ATMEL_HLCDC_NV61_MODE;\r\nbreak;\r\ncase DRM_FORMAT_YUV420:\r\n*mode = ATMEL_HLCDC_YUV420_MODE;\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\n*mode = ATMEL_HLCDC_YUV422_MODE;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool atmel_hlcdc_format_embeds_alpha(u32 format)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(format); i++) {\r\nchar tmp = (format >> (8 * i)) & 0xff;\r\nif (tmp == 'A')\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\natmel_hlcdc_plane_update_pos_and_size(struct atmel_hlcdc_plane *plane,\r\nstruct atmel_hlcdc_plane_state *state)\r\n{\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout =\r\n&plane->layer.desc->layout;\r\nif (layout->size)\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->size,\r\n0xffffffff,\r\n(state->crtc_w - 1) |\r\n((state->crtc_h - 1) << 16));\r\nif (layout->memsize)\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->memsize,\r\n0xffffffff,\r\n(state->src_w - 1) |\r\n((state->src_h - 1) << 16));\r\nif (layout->pos)\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->pos,\r\n0xffffffff,\r\nstate->crtc_x |\r\n(state->crtc_y << 16));\r\nif (state->crtc_w != state->src_w || state->crtc_h != state->src_h) {\r\nu32 factor_reg = 0;\r\nif (state->crtc_w != state->src_w) {\r\nint i;\r\nu32 factor;\r\nu32 *coeff_tab = heo_upscaling_xcoef;\r\nu32 max_memsize;\r\nif (state->crtc_w < state->src_w)\r\ncoeff_tab = heo_downscaling_xcoef;\r\nfor (i = 0; i < ARRAY_SIZE(heo_upscaling_xcoef); i++)\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\n17 + i,\r\n0xffffffff,\r\ncoeff_tab[i]);\r\nfactor = ((8 * 256 * state->src_w) - (256 * 4)) /\r\nstate->crtc_w;\r\nfactor++;\r\nmax_memsize = ((factor * state->crtc_w) + (256 * 4)) /\r\n2048;\r\nif (max_memsize > state->src_w)\r\nfactor--;\r\nfactor_reg |= factor | 0x80000000;\r\n}\r\nif (state->crtc_h != state->src_h) {\r\nint i;\r\nu32 factor;\r\nu32 *coeff_tab = heo_upscaling_ycoef;\r\nu32 max_memsize;\r\nif (state->crtc_w < state->src_w)\r\ncoeff_tab = heo_downscaling_ycoef;\r\nfor (i = 0; i < ARRAY_SIZE(heo_upscaling_ycoef); i++)\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\n33 + i,\r\n0xffffffff,\r\ncoeff_tab[i]);\r\nfactor = ((8 * 256 * state->src_w) - (256 * 4)) /\r\nstate->crtc_w;\r\nfactor++;\r\nmax_memsize = ((factor * state->crtc_w) + (256 * 4)) /\r\n2048;\r\nif (max_memsize > state->src_w)\r\nfactor--;\r\nfactor_reg |= (factor << 16) | 0x80000000;\r\n}\r\natmel_hlcdc_layer_update_cfg(&plane->layer, 13, 0xffffffff,\r\nfactor_reg);\r\n}\r\n}\r\nstatic void\r\natmel_hlcdc_plane_update_general_settings(struct atmel_hlcdc_plane *plane,\r\nstruct atmel_hlcdc_plane_state *state)\r\n{\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout =\r\n&plane->layer.desc->layout;\r\nunsigned int cfg = ATMEL_HLCDC_LAYER_DMA;\r\nif (plane->base.type != DRM_PLANE_TYPE_PRIMARY) {\r\ncfg |= ATMEL_HLCDC_LAYER_OVR | ATMEL_HLCDC_LAYER_ITER2BL |\r\nATMEL_HLCDC_LAYER_ITER;\r\nif (atmel_hlcdc_format_embeds_alpha(state->base.fb->pixel_format))\r\ncfg |= ATMEL_HLCDC_LAYER_LAEN;\r\nelse\r\ncfg |= ATMEL_HLCDC_LAYER_GAEN |\r\nATMEL_HLCDC_LAYER_GA(state->alpha);\r\n}\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nATMEL_HLCDC_LAYER_DMA_CFG_ID,\r\nATMEL_HLCDC_LAYER_DMA_BLEN_MASK,\r\nATMEL_HLCDC_LAYER_DMA_BLEN_INCR16);\r\natmel_hlcdc_layer_update_cfg(&plane->layer, layout->general_config,\r\nATMEL_HLCDC_LAYER_ITER2BL |\r\nATMEL_HLCDC_LAYER_ITER |\r\nATMEL_HLCDC_LAYER_GAEN |\r\nATMEL_HLCDC_LAYER_GA_MASK |\r\nATMEL_HLCDC_LAYER_LAEN |\r\nATMEL_HLCDC_LAYER_OVR |\r\nATMEL_HLCDC_LAYER_DMA, cfg);\r\n}\r\nstatic void atmel_hlcdc_plane_update_format(struct atmel_hlcdc_plane *plane,\r\nstruct atmel_hlcdc_plane_state *state)\r\n{\r\nu32 cfg;\r\nint ret;\r\nret = atmel_hlcdc_format_to_plane_mode(state->base.fb->pixel_format,\r\n&cfg);\r\nif (ret)\r\nreturn;\r\nif ((state->base.fb->pixel_format == DRM_FORMAT_YUV422 ||\r\nstate->base.fb->pixel_format == DRM_FORMAT_NV61) &&\r\n(state->base.rotation & (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270))))\r\ncfg |= ATMEL_HLCDC_YUV422ROT;\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nATMEL_HLCDC_LAYER_FORMAT_CFG_ID,\r\n0xffffffff,\r\ncfg);\r\nif (state->base.fb->pixel_format == DRM_FORMAT_RGB888)\r\ncfg = ATMEL_HLCDC_LAYER_DMA_ROTDIS;\r\nelse\r\ncfg = 0;\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nATMEL_HLCDC_LAYER_DMA_CFG_ID,\r\nATMEL_HLCDC_LAYER_DMA_ROTDIS, cfg);\r\n}\r\nstatic void atmel_hlcdc_plane_update_buffers(struct atmel_hlcdc_plane *plane,\r\nstruct atmel_hlcdc_plane_state *state)\r\n{\r\nstruct atmel_hlcdc_layer *layer = &plane->layer;\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout =\r\n&layer->desc->layout;\r\nint i;\r\natmel_hlcdc_layer_update_set_fb(&plane->layer, state->base.fb,\r\nstate->offsets);\r\nfor (i = 0; i < state->nplanes; i++) {\r\nif (layout->xstride[i]) {\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->xstride[i],\r\n0xffffffff,\r\nstate->xstride[i]);\r\n}\r\nif (layout->pstride[i]) {\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->pstride[i],\r\n0xffffffff,\r\nstate->pstride[i]);\r\n}\r\n}\r\n}\r\nint\r\natmel_hlcdc_plane_prepare_disc_area(struct drm_crtc_state *c_state)\r\n{\r\nint disc_x = 0, disc_y = 0, disc_w = 0, disc_h = 0;\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout;\r\nstruct atmel_hlcdc_plane_state *primary_state;\r\nstruct drm_plane_state *primary_s;\r\nstruct atmel_hlcdc_plane *primary;\r\nstruct drm_plane *ovl;\r\nprimary = drm_plane_to_atmel_hlcdc_plane(c_state->crtc->primary);\r\nlayout = &primary->layer.desc->layout;\r\nif (!layout->disc_pos || !layout->disc_size)\r\nreturn 0;\r\nprimary_s = drm_atomic_get_plane_state(c_state->state,\r\n&primary->base);\r\nif (IS_ERR(primary_s))\r\nreturn PTR_ERR(primary_s);\r\nprimary_state = drm_plane_state_to_atmel_hlcdc_plane_state(primary_s);\r\ndrm_atomic_crtc_state_for_each_plane(ovl, c_state) {\r\nstruct atmel_hlcdc_plane_state *ovl_state;\r\nstruct drm_plane_state *ovl_s;\r\nif (ovl == c_state->crtc->primary)\r\ncontinue;\r\novl_s = drm_atomic_get_plane_state(c_state->state, ovl);\r\nif (IS_ERR(ovl_s))\r\nreturn PTR_ERR(ovl_s);\r\novl_state = drm_plane_state_to_atmel_hlcdc_plane_state(ovl_s);\r\nif (!ovl_s->fb ||\r\natmel_hlcdc_format_embeds_alpha(ovl_s->fb->pixel_format) ||\r\novl_state->alpha != 255)\r\ncontinue;\r\nif (ovl_state->crtc_h * ovl_state->crtc_w < disc_h * disc_w)\r\ncontinue;\r\ndisc_x = ovl_state->crtc_x;\r\ndisc_y = ovl_state->crtc_y;\r\ndisc_h = ovl_state->crtc_h;\r\ndisc_w = ovl_state->crtc_w;\r\n}\r\nif (disc_x == primary_state->disc_x &&\r\ndisc_y == primary_state->disc_y &&\r\ndisc_w == primary_state->disc_w &&\r\ndisc_h == primary_state->disc_h)\r\nreturn 0;\r\nprimary_state->disc_x = disc_x;\r\nprimary_state->disc_y = disc_y;\r\nprimary_state->disc_w = disc_w;\r\nprimary_state->disc_h = disc_h;\r\nprimary_state->disc_updated = true;\r\nreturn 0;\r\n}\r\nstatic void\r\natmel_hlcdc_plane_update_disc_area(struct atmel_hlcdc_plane *plane,\r\nstruct atmel_hlcdc_plane_state *state)\r\n{\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout =\r\n&plane->layer.desc->layout;\r\nint disc_surface = 0;\r\nif (!state->disc_updated)\r\nreturn;\r\ndisc_surface = state->disc_h * state->disc_w;\r\natmel_hlcdc_layer_update_cfg(&plane->layer, layout->general_config,\r\nATMEL_HLCDC_LAYER_DISCEN,\r\ndisc_surface ? ATMEL_HLCDC_LAYER_DISCEN : 0);\r\nif (!disc_surface)\r\nreturn;\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->disc_pos,\r\n0xffffffff,\r\nstate->disc_x | (state->disc_y << 16));\r\natmel_hlcdc_layer_update_cfg(&plane->layer,\r\nlayout->disc_size,\r\n0xffffffff,\r\n(state->disc_w - 1) |\r\n((state->disc_h - 1) << 16));\r\n}\r\nstatic int atmel_hlcdc_plane_atomic_check(struct drm_plane *p,\r\nstruct drm_plane_state *s)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nstruct atmel_hlcdc_plane_state *state =\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(s);\r\nconst struct atmel_hlcdc_layer_cfg_layout *layout =\r\n&plane->layer.desc->layout;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\nconst struct drm_display_mode *mode;\r\nstruct drm_crtc_state *crtc_state;\r\nunsigned int patched_crtc_w;\r\nunsigned int patched_crtc_h;\r\nunsigned int patched_src_w;\r\nunsigned int patched_src_h;\r\nunsigned int tmp;\r\nint x_offset = 0;\r\nint y_offset = 0;\r\nint hsub = 1;\r\nint vsub = 1;\r\nint i;\r\nif (!state->base.crtc || !fb)\r\nreturn 0;\r\ncrtc_state = s->state->crtc_states[drm_crtc_index(s->crtc)];\r\nmode = &crtc_state->adjusted_mode;\r\nstate->src_x = s->src_x;\r\nstate->src_y = s->src_y;\r\nstate->src_h = s->src_h;\r\nstate->src_w = s->src_w;\r\nstate->crtc_x = s->crtc_x;\r\nstate->crtc_y = s->crtc_y;\r\nstate->crtc_h = s->crtc_h;\r\nstate->crtc_w = s->crtc_w;\r\nif ((state->src_x | state->src_y | state->src_w | state->src_h) &\r\nSUBPIXEL_MASK)\r\nreturn -EINVAL;\r\nstate->src_x >>= 16;\r\nstate->src_y >>= 16;\r\nstate->src_w >>= 16;\r\nstate->src_h >>= 16;\r\nstate->nplanes = drm_format_num_planes(fb->pixel_format);\r\nif (state->nplanes > ATMEL_HLCDC_MAX_PLANES)\r\nreturn -EINVAL;\r\nif (state->base.rotation & (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270))) {\r\ntmp = state->crtc_w;\r\nstate->crtc_w = state->crtc_h;\r\nstate->crtc_h = tmp;\r\ntmp = state->src_w;\r\nstate->src_w = state->src_h;\r\nstate->src_h = tmp;\r\n}\r\nif (state->crtc_x + state->crtc_w > mode->hdisplay)\r\npatched_crtc_w = mode->hdisplay - state->crtc_x;\r\nelse\r\npatched_crtc_w = state->crtc_w;\r\nif (state->crtc_x < 0) {\r\npatched_crtc_w += state->crtc_x;\r\nx_offset = -state->crtc_x;\r\nstate->crtc_x = 0;\r\n}\r\nif (state->crtc_y + state->crtc_h > mode->vdisplay)\r\npatched_crtc_h = mode->vdisplay - state->crtc_y;\r\nelse\r\npatched_crtc_h = state->crtc_h;\r\nif (state->crtc_y < 0) {\r\npatched_crtc_h += state->crtc_y;\r\ny_offset = -state->crtc_y;\r\nstate->crtc_y = 0;\r\n}\r\npatched_src_w = DIV_ROUND_CLOSEST(patched_crtc_w * state->src_w,\r\nstate->crtc_w);\r\npatched_src_h = DIV_ROUND_CLOSEST(patched_crtc_h * state->src_h,\r\nstate->crtc_h);\r\nhsub = drm_format_horz_chroma_subsampling(fb->pixel_format);\r\nvsub = drm_format_vert_chroma_subsampling(fb->pixel_format);\r\nfor (i = 0; i < state->nplanes; i++) {\r\nunsigned int offset = 0;\r\nint xdiv = i ? hsub : 1;\r\nint ydiv = i ? vsub : 1;\r\nstate->bpp[i] = drm_format_plane_cpp(fb->pixel_format, i);\r\nif (!state->bpp[i])\r\nreturn -EINVAL;\r\nswitch (state->base.rotation & 0xf) {\r\ncase BIT(DRM_ROTATE_90):\r\noffset = ((y_offset + state->src_y + patched_src_w - 1) /\r\nydiv) * fb->pitches[i];\r\noffset += ((x_offset + state->src_x) / xdiv) *\r\nstate->bpp[i];\r\nstate->xstride[i] = ((patched_src_w - 1) / ydiv) *\r\nfb->pitches[i];\r\nstate->pstride[i] = -fb->pitches[i] - state->bpp[i];\r\nbreak;\r\ncase BIT(DRM_ROTATE_180):\r\noffset = ((y_offset + state->src_y + patched_src_h - 1) /\r\nydiv) * fb->pitches[i];\r\noffset += ((x_offset + state->src_x + patched_src_w - 1) /\r\nxdiv) * state->bpp[i];\r\nstate->xstride[i] = ((((patched_src_w - 1) / xdiv) - 1) *\r\nstate->bpp[i]) - fb->pitches[i];\r\nstate->pstride[i] = -2 * state->bpp[i];\r\nbreak;\r\ncase BIT(DRM_ROTATE_270):\r\noffset = ((y_offset + state->src_y) / ydiv) *\r\nfb->pitches[i];\r\noffset += ((x_offset + state->src_x + patched_src_h - 1) /\r\nxdiv) * state->bpp[i];\r\nstate->xstride[i] = -(((patched_src_w - 1) / ydiv) *\r\nfb->pitches[i]) -\r\n(2 * state->bpp[i]);\r\nstate->pstride[i] = fb->pitches[i] - state->bpp[i];\r\nbreak;\r\ncase BIT(DRM_ROTATE_0):\r\ndefault:\r\noffset = ((y_offset + state->src_y) / ydiv) *\r\nfb->pitches[i];\r\noffset += ((x_offset + state->src_x) / xdiv) *\r\nstate->bpp[i];\r\nstate->xstride[i] = fb->pitches[i] -\r\n((patched_src_w / xdiv) *\r\nstate->bpp[i]);\r\nstate->pstride[i] = 0;\r\nbreak;\r\n}\r\nstate->offsets[i] = offset + fb->offsets[i];\r\n}\r\nstate->src_w = patched_src_w;\r\nstate->src_h = patched_src_h;\r\nstate->crtc_w = patched_crtc_w;\r\nstate->crtc_h = patched_crtc_h;\r\nif (!layout->size &&\r\n(mode->hdisplay != state->crtc_w ||\r\nmode->vdisplay != state->crtc_h))\r\nreturn -EINVAL;\r\nif (plane->layer.desc->max_height &&\r\nstate->crtc_h > plane->layer.desc->max_height)\r\nreturn -EINVAL;\r\nif (plane->layer.desc->max_width &&\r\nstate->crtc_w > plane->layer.desc->max_width)\r\nreturn -EINVAL;\r\nif ((state->crtc_h != state->src_h || state->crtc_w != state->src_w) &&\r\n(!layout->memsize ||\r\natmel_hlcdc_format_embeds_alpha(state->base.fb->pixel_format)))\r\nreturn -EINVAL;\r\nif (state->crtc_x < 0 || state->crtc_y < 0)\r\nreturn -EINVAL;\r\nif (state->crtc_w + state->crtc_x > mode->hdisplay ||\r\nstate->crtc_h + state->crtc_y > mode->vdisplay)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_plane_prepare_fb(struct drm_plane *p,\r\nstruct drm_framebuffer *fb,\r\nconst struct drm_plane_state *new_state)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nreturn atmel_hlcdc_layer_update_start(&plane->layer);\r\n}\r\nstatic void atmel_hlcdc_plane_atomic_update(struct drm_plane *p,\r\nstruct drm_plane_state *old_s)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nstruct atmel_hlcdc_plane_state *state =\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(p->state);\r\nif (!p->state->crtc || !p->state->fb)\r\nreturn;\r\natmel_hlcdc_plane_update_pos_and_size(plane, state);\r\natmel_hlcdc_plane_update_general_settings(plane, state);\r\natmel_hlcdc_plane_update_format(plane, state);\r\natmel_hlcdc_plane_update_buffers(plane, state);\r\natmel_hlcdc_plane_update_disc_area(plane, state);\r\natmel_hlcdc_layer_update_commit(&plane->layer);\r\n}\r\nstatic void atmel_hlcdc_plane_atomic_disable(struct drm_plane *p,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\natmel_hlcdc_layer_disable(&plane->layer);\r\n}\r\nstatic void atmel_hlcdc_plane_destroy(struct drm_plane *p)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nif (plane->base.fb)\r\ndrm_framebuffer_unreference(plane->base.fb);\r\natmel_hlcdc_layer_cleanup(p->dev, &plane->layer);\r\ndrm_plane_cleanup(p);\r\ndevm_kfree(p->dev->dev, plane);\r\n}\r\nstatic int atmel_hlcdc_plane_atomic_set_property(struct drm_plane *p,\r\nstruct drm_plane_state *s,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nstruct atmel_hlcdc_plane_properties *props = plane->properties;\r\nstruct atmel_hlcdc_plane_state *state =\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(s);\r\nif (property == props->alpha)\r\nstate->alpha = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_plane_atomic_get_property(struct drm_plane *p,\r\nconst struct drm_plane_state *s,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nstruct atmel_hlcdc_plane *plane = drm_plane_to_atmel_hlcdc_plane(p);\r\nstruct atmel_hlcdc_plane_properties *props = plane->properties;\r\nconst struct atmel_hlcdc_plane_state *state =\r\ncontainer_of(s, const struct atmel_hlcdc_plane_state, base);\r\nif (property == props->alpha)\r\n*val = state->alpha;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void atmel_hlcdc_plane_init_properties(struct atmel_hlcdc_plane *plane,\r\nconst struct atmel_hlcdc_layer_desc *desc,\r\nstruct atmel_hlcdc_plane_properties *props)\r\n{\r\nstruct regmap *regmap = plane->layer.hlcdc->regmap;\r\nif (desc->type == ATMEL_HLCDC_OVERLAY_LAYER ||\r\ndesc->type == ATMEL_HLCDC_CURSOR_LAYER) {\r\ndrm_object_attach_property(&plane->base.base,\r\nprops->alpha, 255);\r\nregmap_update_bits(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_GENERAL_CFG(&plane->layer),\r\nATMEL_HLCDC_LAYER_GA_MASK,\r\nATMEL_HLCDC_LAYER_GA_MASK);\r\n}\r\nif (desc->layout.xstride && desc->layout.pstride)\r\ndrm_object_attach_property(&plane->base.base,\r\nplane->base.dev->mode_config.rotation_property,\r\nBIT(DRM_ROTATE_0));\r\nif (desc->layout.csc) {\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_CSC_CFG(&plane->layer, 0),\r\n0x4c900091);\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_CSC_CFG(&plane->layer, 1),\r\n0x7a5f5090);\r\nregmap_write(regmap,\r\ndesc->regs_offset +\r\nATMEL_HLCDC_LAYER_CSC_CFG(&plane->layer, 2),\r\n0x40040890);\r\n}\r\n}\r\nstatic void atmel_hlcdc_plane_reset(struct drm_plane *p)\r\n{\r\nstruct atmel_hlcdc_plane_state *state;\r\nif (p->state) {\r\nstate = drm_plane_state_to_atmel_hlcdc_plane_state(p->state);\r\nif (state->base.fb)\r\ndrm_framebuffer_unreference(state->base.fb);\r\nkfree(state);\r\np->state = NULL;\r\n}\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state) {\r\nstate->alpha = 255;\r\np->state = &state->base;\r\np->state->plane = p;\r\n}\r\n}\r\nstatic struct drm_plane_state *\r\natmel_hlcdc_plane_atomic_duplicate_state(struct drm_plane *p)\r\n{\r\nstruct atmel_hlcdc_plane_state *state =\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(p->state);\r\nstruct atmel_hlcdc_plane_state *copy;\r\ncopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\r\nif (!copy)\r\nreturn NULL;\r\ncopy->disc_updated = false;\r\nif (copy->base.fb)\r\ndrm_framebuffer_reference(copy->base.fb);\r\nreturn &copy->base;\r\n}\r\nstatic void atmel_hlcdc_plane_atomic_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *s)\r\n{\r\nstruct atmel_hlcdc_plane_state *state =\r\ndrm_plane_state_to_atmel_hlcdc_plane_state(s);\r\nif (s->fb)\r\ndrm_framebuffer_unreference(s->fb);\r\nkfree(state);\r\n}\r\nstatic struct atmel_hlcdc_plane *\r\natmel_hlcdc_plane_create(struct drm_device *dev,\r\nconst struct atmel_hlcdc_layer_desc *desc,\r\nstruct atmel_hlcdc_plane_properties *props)\r\n{\r\nstruct atmel_hlcdc_plane *plane;\r\nenum drm_plane_type type;\r\nint ret;\r\nplane = devm_kzalloc(dev->dev, sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = atmel_hlcdc_layer_init(dev, &plane->layer, desc);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (desc->type == ATMEL_HLCDC_BASE_LAYER)\r\ntype = DRM_PLANE_TYPE_PRIMARY;\r\nelse if (desc->type == ATMEL_HLCDC_CURSOR_LAYER)\r\ntype = DRM_PLANE_TYPE_CURSOR;\r\nelse\r\ntype = DRM_PLANE_TYPE_OVERLAY;\r\nret = drm_universal_plane_init(dev, &plane->base, 0,\r\n&layer_plane_funcs,\r\ndesc->formats->formats,\r\ndesc->formats->nformats, type);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ndrm_plane_helper_add(&plane->base,\r\n&atmel_hlcdc_layer_plane_helper_funcs);\r\natmel_hlcdc_plane_init_properties(plane, desc, props);\r\nreturn plane;\r\n}\r\nstatic struct atmel_hlcdc_plane_properties *\r\natmel_hlcdc_plane_create_properties(struct drm_device *dev)\r\n{\r\nstruct atmel_hlcdc_plane_properties *props;\r\nprops = devm_kzalloc(dev->dev, sizeof(*props), GFP_KERNEL);\r\nif (!props)\r\nreturn ERR_PTR(-ENOMEM);\r\nprops->alpha = drm_property_create_range(dev, 0, "alpha", 0, 255);\r\nif (!props->alpha)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->mode_config.rotation_property =\r\ndrm_mode_create_rotation_property(dev,\r\nBIT(DRM_ROTATE_0) |\r\nBIT(DRM_ROTATE_90) |\r\nBIT(DRM_ROTATE_180) |\r\nBIT(DRM_ROTATE_270));\r\nif (!dev->mode_config.rotation_property)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn props;\r\n}\r\nstruct atmel_hlcdc_planes *\r\natmel_hlcdc_create_planes(struct drm_device *dev)\r\n{\r\nstruct atmel_hlcdc_dc *dc = dev->dev_private;\r\nstruct atmel_hlcdc_plane_properties *props;\r\nstruct atmel_hlcdc_planes *planes;\r\nconst struct atmel_hlcdc_layer_desc *descs = dc->desc->layers;\r\nint nlayers = dc->desc->nlayers;\r\nint i;\r\nplanes = devm_kzalloc(dev->dev, sizeof(*planes), GFP_KERNEL);\r\nif (!planes)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < nlayers; i++) {\r\nif (descs[i].type == ATMEL_HLCDC_OVERLAY_LAYER)\r\nplanes->noverlays++;\r\n}\r\nif (planes->noverlays) {\r\nplanes->overlays = devm_kzalloc(dev->dev,\r\nplanes->noverlays *\r\nsizeof(*planes->overlays),\r\nGFP_KERNEL);\r\nif (!planes->overlays)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nprops = atmel_hlcdc_plane_create_properties(dev);\r\nif (IS_ERR(props))\r\nreturn ERR_CAST(props);\r\nplanes->noverlays = 0;\r\nfor (i = 0; i < nlayers; i++) {\r\nstruct atmel_hlcdc_plane *plane;\r\nif (descs[i].type == ATMEL_HLCDC_PP_LAYER)\r\ncontinue;\r\nplane = atmel_hlcdc_plane_create(dev, &descs[i], props);\r\nif (IS_ERR(plane))\r\nreturn ERR_CAST(plane);\r\nplane->properties = props;\r\nswitch (descs[i].type) {\r\ncase ATMEL_HLCDC_BASE_LAYER:\r\nif (planes->primary)\r\nreturn ERR_PTR(-EINVAL);\r\nplanes->primary = plane;\r\nbreak;\r\ncase ATMEL_HLCDC_OVERLAY_LAYER:\r\nplanes->overlays[planes->noverlays++] = plane;\r\nbreak;\r\ncase ATMEL_HLCDC_CURSOR_LAYER:\r\nif (planes->cursor)\r\nreturn ERR_PTR(-EINVAL);\r\nplanes->cursor = plane;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn planes;\r\n}
