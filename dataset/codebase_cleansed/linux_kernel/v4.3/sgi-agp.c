static struct page *sgi_tioca_alloc_page(struct agp_bridge_data *bridge)\r\n{\r\nstruct page *page;\r\nint nid;\r\nstruct tioca_kernel *info =\r\n(struct tioca_kernel *)bridge->dev_private_data;\r\nnid = info->ca_closest_node;\r\npage = alloc_pages_node(nid, GFP_KERNEL, 0);\r\nif (!page)\r\nreturn NULL;\r\nget_page(page);\r\natomic_inc(&agp_bridge->current_memory_agp);\r\nreturn page;\r\n}\r\nstatic void sgi_tioca_tlbflush(struct agp_memory *mem)\r\n{\r\ntioca_tlbflush(mem->bridge->dev_private_data);\r\n}\r\nstatic unsigned long\r\nsgi_tioca_mask_memory(struct agp_bridge_data *bridge, dma_addr_t addr,\r\nint type)\r\n{\r\nreturn tioca_physpage_to_gart(addr);\r\n}\r\nstatic void sgi_tioca_agp_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\ntioca_fastwrite_enable(bridge->dev_private_data);\r\n}\r\nstatic int sgi_tioca_configure(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sgi_tioca_fetch_size(void)\r\n{\r\nstruct tioca_kernel *info =\r\n(struct tioca_kernel *)agp_bridge->dev_private_data;\r\nsgi_tioca_sizes[0].size = info->ca_gfxap_size / MB(1);\r\nsgi_tioca_sizes[0].num_entries = info->ca_gfxgart_entries;\r\nreturn sgi_tioca_sizes[0].size;\r\n}\r\nstatic int sgi_tioca_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct tioca_kernel *info =\r\n(struct tioca_kernel *)bridge->dev_private_data;\r\nbridge->gatt_table_real = (u32 *) info->ca_gfxgart;\r\nbridge->gatt_table = bridge->gatt_table_real;\r\nbridge->gatt_bus_addr = info->ca_gfxgart_base;\r\nreturn 0;\r\n}\r\nstatic int sgi_tioca_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sgi_tioca_insert_memory(struct agp_memory *mem, off_t pg_start,\r\nint type)\r\n{\r\nint num_entries;\r\nsize_t i;\r\noff_t j;\r\nvoid *temp;\r\nstruct agp_bridge_data *bridge;\r\nu64 *table;\r\nbridge = mem->bridge;\r\nif (!bridge)\r\nreturn -EINVAL;\r\ntable = (u64 *)bridge->gatt_table;\r\ntemp = bridge->current_size;\r\nswitch (bridge->driver->size_type) {\r\ncase U8_APER_SIZE:\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\nbreak;\r\ncase U16_APER_SIZE:\r\nnum_entries = A_SIZE_16(temp)->num_entries;\r\nbreak;\r\ncase U32_APER_SIZE:\r\nnum_entries = A_SIZE_32(temp)->num_entries;\r\nbreak;\r\ncase FIXED_APER_SIZE:\r\nnum_entries = A_SIZE_FIX(temp)->num_entries;\r\nbreak;\r\ncase LVL2_APER_SIZE:\r\nreturn -EINVAL;\r\ndefault:\r\nnum_entries = 0;\r\nbreak;\r\n}\r\nnum_entries -= agp_memory_reserved / PAGE_SIZE;\r\nif (num_entries < 0)\r\nnum_entries = 0;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nj = pg_start;\r\nwhile (j < (pg_start + mem->page_count)) {\r\nif (table[j])\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nbridge->driver->cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\ntable[j] =\r\nbridge->driver->mask_memory(bridge,\r\npage_to_phys(mem->pages[i]),\r\nmem->type);\r\n}\r\nbridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int sgi_tioca_remove_memory(struct agp_memory *mem, off_t pg_start,\r\nint type)\r\n{\r\nsize_t i;\r\nstruct agp_bridge_data *bridge;\r\nu64 *table;\r\nbridge = mem->bridge;\r\nif (!bridge)\r\nreturn -EINVAL;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\ntable = (u64 *)bridge->gatt_table;\r\nfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\r\ntable[i] = 0;\r\n}\r\nbridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic void sgi_tioca_cache_flush(void)\r\n{\r\n}\r\nstatic void sgi_tioca_cleanup(void)\r\n{\r\n}\r\nstatic struct agp_bridge_data *sgi_tioca_find_bridge(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nlist_for_each_entry(bridge, &agp_bridges, list) {\r\nif (bridge->dev->bus == pdev->bus)\r\nbreak;\r\n}\r\nreturn bridge;\r\n}\r\nstatic int agp_sgi_init(void)\r\n{\r\nunsigned int j;\r\nstruct tioca_kernel *info;\r\nstruct pci_dev *pdev = NULL;\r\nif (tioca_gart_found)\r\nprintk(KERN_INFO PFX "SGI TIO CA GART driver initialized.\n");\r\nelse\r\nreturn 0;\r\nsgi_tioca_agp_bridges = kmalloc(tioca_gart_found *\r\nsizeof(struct agp_bridge_data *),\r\nGFP_KERNEL);\r\nif (!sgi_tioca_agp_bridges)\r\nreturn -ENOMEM;\r\nj = 0;\r\nlist_for_each_entry(info, &tioca_list, ca_list) {\r\nif (list_empty(info->ca_devices))\r\ncontinue;\r\nlist_for_each_entry(pdev, info->ca_devices, bus_list) {\r\nu8 cap_ptr;\r\nif (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))\r\ncontinue;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\ncontinue;\r\n}\r\nsgi_tioca_agp_bridges[j] = agp_alloc_bridge();\r\nprintk(KERN_INFO PFX "bridge %d = 0x%p\n", j,\r\nsgi_tioca_agp_bridges[j]);\r\nif (sgi_tioca_agp_bridges[j]) {\r\nsgi_tioca_agp_bridges[j]->dev = pdev;\r\nsgi_tioca_agp_bridges[j]->dev_private_data = info;\r\nsgi_tioca_agp_bridges[j]->driver = &sgi_tioca_driver;\r\nsgi_tioca_agp_bridges[j]->gart_bus_addr =\r\ninfo->ca_gfxap_base;\r\nsgi_tioca_agp_bridges[j]->mode = (0x7D << 24) |\r\n(0x1 << 9) |\r\n(0x1 << 5) |\r\n(0x1 << 4) |\r\n(0x1 << 3) |\r\n0x2;\r\nsgi_tioca_agp_bridges[j]->current_size =\r\nsgi_tioca_agp_bridges[j]->previous_size =\r\n(void *)&sgi_tioca_sizes[0];\r\nagp_add_bridge(sgi_tioca_agp_bridges[j]);\r\n}\r\nj++;\r\n}\r\nagp_find_bridge = &sgi_tioca_find_bridge;\r\nreturn 0;\r\n}\r\nstatic void agp_sgi_cleanup(void)\r\n{\r\nkfree(sgi_tioca_agp_bridges);\r\nsgi_tioca_agp_bridges = NULL;\r\n}
