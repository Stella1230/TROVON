static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,\r\nunsigned int vf_fn)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nMCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);\r\nMCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,\r\nEVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,\r\nEVB_PORT_ASSIGN_IN_VF, vf_fn);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,\r\nunsigned int vswitch_type)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);\r\nMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);\r\nMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 2);\r\nMCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,\r\nVSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc == -EPROTO) {\r\nMCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 1);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf,\r\nsizeof(inbuf), NULL, 0, NULL);\r\n} else if (rc) {\r\nefx_mcdi_display_error(efx, MC_CMD_VSWITCH_ALLOC,\r\nMC_CMD_VSWITCH_ALLOC_IN_LEN,\r\nNULL, 0, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);\r\nMCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_ef10_vport_alloc(struct efx_nic *efx,\r\nunsigned int port_id_in,\r\nunsigned int vport_type,\r\nu16 vlan,\r\nunsigned int *port_id_out)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nEFX_WARN_ON_PARANOID(!port_id_out);\r\nMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);\r\nMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);\r\nMCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS,\r\n(vlan != EFX_EF10_NO_VLAN));\r\nMCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,\r\nVPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);\r\nif (vlan != EFX_EF10_NO_VLAN)\r\nMCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_VLAN_TAGS,\r\nVPORT_ALLOC_IN_VLAN_TAG_0, vlan);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)\r\nreturn -EIO;\r\n*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);\r\nreturn 0;\r\n}\r\nstatic int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);\r\nMCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nint i;\r\nif (!nic_data->vf)\r\nreturn;\r\nfor (i = 0; i < efx->vf_count; i++) {\r\nstruct ef10_vf *vf = nic_data->vf + i;\r\nif (vf->pci_dev &&\r\nvf->pci_dev->dev_flags & PCI_DEV_FLAGS_ASSIGNED)\r\ncontinue;\r\nif (vf->vport_assigned) {\r\nefx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);\r\nvf->vport_assigned = 0;\r\n}\r\nif (!is_zero_ether_addr(vf->mac)) {\r\nefx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);\r\neth_zero_addr(vf->mac);\r\n}\r\nif (vf->vport_id) {\r\nefx_ef10_vport_free(efx, vf->vport_id);\r\nvf->vport_id = 0;\r\n}\r\nvf->efx = NULL;\r\n}\r\n}\r\nstatic void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nefx_ef10_sriov_free_vf_vports(efx);\r\nkfree(nic_data->vf);\r\nnic_data->vf = NULL;\r\n}\r\nstatic int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,\r\nunsigned int vf_i)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nstruct ef10_vf *vf = nic_data->vf + vf_i;\r\nint rc;\r\nif (WARN_ON_ONCE(!nic_data->vf))\r\nreturn -EOPNOTSUPP;\r\nrc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\r\nMC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\r\nvf->vlan, &vf->vport_id);\r\nif (rc)\r\nreturn rc;\r\nrc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);\r\nif (rc) {\r\neth_zero_addr(vf->mac);\r\nreturn rc;\r\n}\r\nrc = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\r\nif (rc)\r\nreturn rc;\r\nvf->vport_assigned = 1;\r\nreturn 0;\r\n}\r\nstatic int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nunsigned int i;\r\nint rc;\r\nnic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),\r\nGFP_KERNEL);\r\nif (!nic_data->vf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < efx->vf_count; i++) {\r\nrandom_ether_addr(nic_data->vf[i].mac);\r\nnic_data->vf[i].efx = NULL;\r\nnic_data->vf[i].vlan = EFX_EF10_NO_VLAN;\r\nrc = efx_ef10_sriov_assign_vf_vport(efx, i);\r\nif (rc)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nefx_ef10_sriov_free_vf_vports(efx);\r\nkfree(nic_data->vf);\r\nnic_data->vf = NULL;\r\nreturn rc;\r\n}\r\nstatic int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)\r\n{\r\nunsigned int i;\r\nint rc;\r\nfor (i = 0; i < efx->vf_count; i++) {\r\nrc = efx_ef10_sriov_assign_vf_vport(efx, i);\r\nif (rc)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nefx_ef10_sriov_free_vf_vswitching(efx);\r\nreturn rc;\r\n}\r\nint efx_ef10_vswitching_probe_pf(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nstruct net_device *net_dev = efx->net_dev;\r\nint rc;\r\nif (pci_sriov_get_totalvfs(efx->pci_dev) <= 0) {\r\nefx_ef10_vadaptor_alloc(efx, nic_data->vport_id);\r\nreturn 0;\r\n}\r\nrc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,\r\nMC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);\r\nif (rc)\r\ngoto fail1;\r\nrc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\r\nMC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\r\nEFX_EF10_NO_VLAN, &nic_data->vport_id);\r\nif (rc)\r\ngoto fail2;\r\nrc = efx_ef10_vport_add_mac(efx, nic_data->vport_id, net_dev->dev_addr);\r\nif (rc)\r\ngoto fail3;\r\nether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);\r\nrc = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);\r\nif (rc)\r\ngoto fail4;\r\nreturn 0;\r\nfail4:\r\nefx_ef10_vport_del_mac(efx, nic_data->vport_id, nic_data->vport_mac);\r\neth_zero_addr(nic_data->vport_mac);\r\nfail3:\r\nefx_ef10_vport_free(efx, nic_data->vport_id);\r\nnic_data->vport_id = EVB_PORT_ID_ASSIGNED;\r\nfail2:\r\nefx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);\r\nfail1:\r\nreturn rc;\r\n}\r\nint efx_ef10_vswitching_probe_vf(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nreturn efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);\r\n}\r\nint efx_ef10_vswitching_restore_pf(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nif (!nic_data->must_probe_vswitching)\r\nreturn 0;\r\nrc = efx_ef10_vswitching_probe_pf(efx);\r\nif (rc)\r\ngoto fail;\r\nrc = efx_ef10_sriov_restore_vf_vswitching(efx);\r\nif (rc)\r\ngoto fail;\r\nnic_data->must_probe_vswitching = false;\r\nfail:\r\nreturn rc;\r\n}\r\nint efx_ef10_vswitching_restore_vf(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nif (!nic_data->must_probe_vswitching)\r\nreturn 0;\r\nrc = efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);\r\nif (rc)\r\nreturn rc;\r\nnic_data->must_probe_vswitching = false;\r\nreturn 0;\r\n}\r\nvoid efx_ef10_vswitching_remove_pf(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nefx_ef10_sriov_free_vf_vswitching(efx);\r\nefx_ef10_vadaptor_free(efx, nic_data->vport_id);\r\nif (nic_data->vport_id == EVB_PORT_ID_ASSIGNED)\r\nreturn;\r\nif (!is_zero_ether_addr(nic_data->vport_mac)) {\r\nefx_ef10_vport_del_mac(efx, nic_data->vport_id,\r\nefx->net_dev->dev_addr);\r\neth_zero_addr(nic_data->vport_mac);\r\n}\r\nefx_ef10_vport_free(efx, nic_data->vport_id);\r\nnic_data->vport_id = EVB_PORT_ID_ASSIGNED;\r\nif (!pci_vfs_assigned(efx->pci_dev))\r\nefx_ef10_vswitch_free(efx, nic_data->vport_id);\r\n}\r\nvoid efx_ef10_vswitching_remove_vf(struct efx_nic *efx)\r\n{\r\nefx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);\r\n}\r\nstatic int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)\r\n{\r\nint rc = 0;\r\nstruct pci_dev *dev = efx->pci_dev;\r\nefx->vf_count = num_vfs;\r\nrc = efx_ef10_sriov_alloc_vf_vswitching(efx);\r\nif (rc)\r\ngoto fail1;\r\nrc = pci_enable_sriov(dev, num_vfs);\r\nif (rc)\r\ngoto fail2;\r\nreturn 0;\r\nfail2:\r\nefx_ef10_sriov_free_vf_vswitching(efx);\r\nfail1:\r\nefx->vf_count = 0;\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Failed to enable SRIOV VFs\n");\r\nreturn rc;\r\n}\r\nstatic int efx_ef10_pci_sriov_disable(struct efx_nic *efx, bool force)\r\n{\r\nstruct pci_dev *dev = efx->pci_dev;\r\nunsigned int vfs_assigned = 0;\r\nvfs_assigned = pci_vfs_assigned(dev);\r\nif (vfs_assigned && !force) {\r\nnetif_info(efx, drv, efx->net_dev, "VFs are assigned to guests; "\r\n"please detach them before disabling SR-IOV\n");\r\nreturn -EBUSY;\r\n}\r\nif (!vfs_assigned)\r\npci_disable_sriov(dev);\r\nefx_ef10_sriov_free_vf_vswitching(efx);\r\nefx->vf_count = 0;\r\nreturn 0;\r\n}\r\nint efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs)\r\n{\r\nif (num_vfs == 0)\r\nreturn efx_ef10_pci_sriov_disable(efx, false);\r\nelse\r\nreturn efx_ef10_pci_sriov_enable(efx, num_vfs);\r\n}\r\nint efx_ef10_sriov_init(struct efx_nic *efx)\r\n{\r\nreturn 0;\r\n}\r\nvoid efx_ef10_sriov_fini(struct efx_nic *efx)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nunsigned int i;\r\nint rc;\r\nif (!nic_data->vf) {\r\nif (pci_num_vf(efx->pci_dev) && !pci_vfs_assigned(efx->pci_dev))\r\npci_disable_sriov(efx->pci_dev);\r\nreturn;\r\n}\r\nfor (i = 0; i < efx->vf_count; ++i) {\r\nstruct efx_nic *vf_efx = nic_data->vf[i].efx;\r\nif (vf_efx)\r\nvf_efx->pci_dev->driver->remove(vf_efx->pci_dev);\r\n}\r\nrc = efx_ef10_pci_sriov_disable(efx, true);\r\nif (rc)\r\nnetif_dbg(efx, drv, efx->net_dev,\r\n"Disabling SRIOV was not successful rc=%d\n", rc);\r\nelse\r\nnetif_dbg(efx, drv, efx->net_dev, "SRIOV disabled\n");\r\n}\r\nstatic int efx_ef10_vport_del_vf_mac(struct efx_nic *efx, unsigned int port_id,\r\nu8 *mac)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);\r\nMCDI_DECLARE_BUF_ERR(outbuf);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);\r\nether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,\r\nsizeof(inbuf), outbuf, sizeof(outbuf), &outlen);\r\nreturn rc;\r\n}\r\nint efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nstruct ef10_vf *vf;\r\nint rc;\r\nif (!nic_data->vf)\r\nreturn -EOPNOTSUPP;\r\nif (vf_i >= efx->vf_count)\r\nreturn -EINVAL;\r\nvf = nic_data->vf + vf_i;\r\nif (vf->efx) {\r\nefx_device_detach_sync(vf->efx);\r\nefx_net_stop(vf->efx->net_dev);\r\ndown_write(&vf->efx->filter_sem);\r\nvf->efx->type->filter_table_remove(vf->efx);\r\nrc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);\r\nif (rc) {\r\nup_write(&vf->efx->filter_sem);\r\nreturn rc;\r\n}\r\n}\r\nrc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);\r\nif (rc)\r\nreturn rc;\r\nif (!is_zero_ether_addr(vf->mac)) {\r\nrc = efx_ef10_vport_del_vf_mac(efx, vf->vport_id, vf->mac);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (!is_zero_ether_addr(mac)) {\r\nrc = efx_ef10_vport_add_mac(efx, vf->vport_id, mac);\r\nif (rc) {\r\neth_zero_addr(vf->mac);\r\ngoto fail;\r\n}\r\nif (vf->efx)\r\nether_addr_copy(vf->efx->net_dev->dev_addr, mac);\r\n}\r\nether_addr_copy(vf->mac, mac);\r\nrc = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\r\nif (rc)\r\ngoto fail;\r\nif (vf->efx) {\r\nrc = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);\r\nif (rc) {\r\nup_write(&vf->efx->filter_sem);\r\nreturn rc;\r\n}\r\nvf->efx->type->filter_table_probe(vf->efx);\r\nup_write(&vf->efx->filter_sem);\r\nefx_net_open(vf->efx->net_dev);\r\nnetif_device_attach(vf->efx->net_dev);\r\n}\r\nreturn 0;\r\nfail:\r\nmemset(vf->mac, 0, ETH_ALEN);\r\nreturn rc;\r\n}\r\nint efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan,\r\nu8 qos)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nstruct ef10_vf *vf;\r\nu16 old_vlan, new_vlan;\r\nint rc = 0, rc2 = 0;\r\nif (vf_i >= efx->vf_count)\r\nreturn -EINVAL;\r\nif (qos != 0)\r\nreturn -EINVAL;\r\nvf = nic_data->vf + vf_i;\r\nnew_vlan = (vlan == 0) ? EFX_EF10_NO_VLAN : vlan;\r\nif (new_vlan == vf->vlan)\r\nreturn 0;\r\nif (vf->efx) {\r\nefx_device_detach_sync(vf->efx);\r\nefx_net_stop(vf->efx->net_dev);\r\ndown_write(&vf->efx->filter_sem);\r\nvf->efx->type->filter_table_remove(vf->efx);\r\nrc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);\r\nif (rc)\r\ngoto restore_filters;\r\n}\r\nif (vf->vport_assigned) {\r\nrc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);\r\nif (rc) {\r\nnetif_warn(efx, drv, efx->net_dev,\r\n"Failed to change vlan on VF %d.\n", vf_i);\r\nnetif_warn(efx, drv, efx->net_dev,\r\n"This is likely because the VF is bound to a driver in a VM.\n");\r\nnetif_warn(efx, drv, efx->net_dev,\r\n"Please unload the driver in the VM.\n");\r\ngoto restore_vadaptor;\r\n}\r\nvf->vport_assigned = 0;\r\n}\r\nif (!is_zero_ether_addr(vf->mac)) {\r\nrc = efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);\r\nif (rc)\r\ngoto restore_evb_port;\r\n}\r\nif (vf->vport_id) {\r\nrc = efx_ef10_vport_free(efx, vf->vport_id);\r\nif (rc)\r\ngoto restore_mac;\r\nvf->vport_id = 0;\r\n}\r\nold_vlan = vf->vlan;\r\nvf->vlan = new_vlan;\r\nrc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,\r\nMC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,\r\nvf->vlan, &vf->vport_id);\r\nif (rc)\r\ngoto reset_nic_up_write;\r\nrestore_mac:\r\nif (!is_zero_ether_addr(vf->mac)) {\r\nrc2 = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);\r\nif (rc2) {\r\neth_zero_addr(vf->mac);\r\ngoto reset_nic_up_write;\r\n}\r\n}\r\nrestore_evb_port:\r\nrc2 = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);\r\nif (rc2)\r\ngoto reset_nic_up_write;\r\nelse\r\nvf->vport_assigned = 1;\r\nrestore_vadaptor:\r\nif (vf->efx) {\r\nrc2 = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);\r\nif (rc2)\r\ngoto reset_nic_up_write;\r\n}\r\nrestore_filters:\r\nif (vf->efx) {\r\nrc2 = vf->efx->type->filter_table_probe(vf->efx);\r\nif (rc2)\r\ngoto reset_nic_up_write;\r\nup_write(&vf->efx->filter_sem);\r\nup_write(&vf->efx->filter_sem);\r\nrc2 = efx_net_open(vf->efx->net_dev);\r\nif (rc2)\r\ngoto reset_nic;\r\nnetif_device_attach(vf->efx->net_dev);\r\n}\r\nreturn rc;\r\nreset_nic_up_write:\r\nif (vf->efx)\r\nup_write(&vf->efx->filter_sem);\r\nreset_nic:\r\nif (vf->efx) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"Failed to restore VF - scheduling reset.\n");\r\nefx_schedule_reset(vf->efx, RESET_TYPE_DATAPATH);\r\n} else {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"Failed to restore the VF and cannot reset the VF "\r\n"- VF is not functional.\n");\r\nnetif_err(efx, drv, efx->net_dev,\r\n"Please reload the driver attached to the VF.\n");\r\n}\r\nreturn rc ? rc : rc2;\r\n}\r\nint efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i,\r\nbool spoofchk)\r\n{\r\nreturn spoofchk ? -EOPNOTSUPP : 0;\r\n}\r\nint efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i,\r\nint link_state)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nBUILD_BUG_ON(IFLA_VF_LINK_STATE_AUTO !=\r\nMC_CMD_LINK_STATE_MODE_IN_LINK_STATE_AUTO);\r\nBUILD_BUG_ON(IFLA_VF_LINK_STATE_ENABLE !=\r\nMC_CMD_LINK_STATE_MODE_IN_LINK_STATE_UP);\r\nBUILD_BUG_ON(IFLA_VF_LINK_STATE_DISABLE !=\r\nMC_CMD_LINK_STATE_MODE_IN_LINK_STATE_DOWN);\r\nMCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,\r\nLINK_STATE_MODE_IN_FUNCTION_PF,\r\nnic_data->pf_index,\r\nLINK_STATE_MODE_IN_FUNCTION_VF, vf_i);\r\nMCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE, link_state);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nint efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i,\r\nstruct ifla_vf_info *ivf)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_LINK_STATE_MODE_OUT_LEN);\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nstruct ef10_vf *vf;\r\nsize_t outlen;\r\nint rc;\r\nif (vf_i >= efx->vf_count)\r\nreturn -EINVAL;\r\nif (!nic_data->vf)\r\nreturn -EOPNOTSUPP;\r\nvf = nic_data->vf + vf_i;\r\nivf->vf = vf_i;\r\nivf->min_tx_rate = 0;\r\nivf->max_tx_rate = 0;\r\nether_addr_copy(ivf->mac, vf->mac);\r\nivf->vlan = (vf->vlan == EFX_EF10_NO_VLAN) ? 0 : vf->vlan;\r\nivf->qos = 0;\r\nMCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,\r\nLINK_STATE_MODE_IN_FUNCTION_PF,\r\nnic_data->pf_index,\r\nLINK_STATE_MODE_IN_FUNCTION_VF, vf_i);\r\nMCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE,\r\nMC_CMD_LINK_STATE_MODE_IN_DO_NOT_CHANGE);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_LINK_STATE_MODE_OUT_LEN)\r\nreturn -EIO;\r\nivf->linkstate = MCDI_DWORD(outbuf, LINK_STATE_MODE_OUT_OLD_MODE);\r\nreturn 0;\r\n}\r\nint efx_ef10_sriov_get_phys_port_id(struct efx_nic *efx,\r\nstruct netdev_phys_item_id *ppid)\r\n{\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\nif (!is_valid_ether_addr(nic_data->port_id))\r\nreturn -EOPNOTSUPP;\r\nppid->id_len = ETH_ALEN;\r\nmemcpy(ppid->id, nic_data->port_id, ppid->id_len);\r\nreturn 0;\r\n}
