static inline void align_mod(const int align, const int mod)\r\n{\r\nasm volatile(\r\n".set push\n\t"\r\n".set noreorder\n\t"\r\n".balign %0\n\t"\r\n".rept %1\n\t"\r\n"nop\n\t"\r\n".endr\n\t"\r\n".set pop"\r\n:\r\n: GCC_IMM_ASM() (align), GCC_IMM_ASM() (mod));\r\n}\r\nstatic inline void mult_sh_align_mod(long *v1, long *v2, long *w,\r\nconst int align, const int mod)\r\n{\r\nunsigned long flags;\r\nint m1, m2;\r\nlong p, s, lv1, lv2, lw;\r\nlocal_irq_save(flags);\r\nasm volatile(\r\n""\r\n: "=r" (m1), "=r" (m2), "=r" (s)\r\n: "0" (5), "1" (8), "2" (5));\r\nalign_mod(align, mod);\r\nasm volatile(\r\n".set push\n\t"\r\n".set noat\n\t"\r\n".set noreorder\n\t"\r\n".set nomacro\n\t"\r\n"mult %2, %3\n\t"\r\n"dsll32 %0, %4, %5\n\t"\r\n"mflo $0\n\t"\r\n"dsll32 %1, %4, %5\n\t"\r\n"nop\n\t"\r\n".set pop"\r\n: "=&r" (lv1), "=r" (lw)\r\n: "r" (m1), "r" (m2), "r" (s), "I" (0)\r\n: "hi", "lo", GCC_REG_ACCUM);\r\nasm volatile(\r\n""\r\n: "=r" (m1), "=r" (m2), "=r" (s)\r\n: "0" (m1), "1" (m2), "2" (s));\r\nalign_mod(align, mod);\r\np = m1 * m2;\r\nlv2 = s << 32;\r\nasm volatile(\r\n""\r\n: "=r" (lv2)\r\n: "0" (lv2), "r" (p));\r\nlocal_irq_restore(flags);\r\n*v1 = lv1;\r\n*v2 = lv2;\r\n*w = lw;\r\n}\r\nstatic inline void check_mult_sh(void)\r\n{\r\nlong v1[8], v2[8], w[8];\r\nint bug, fix, i;\r\nprintk("Checking for the multiply/shift bug... ");\r\nmult_sh_align_mod(&v1[0], &v2[0], &w[0], 32, 0);\r\nmult_sh_align_mod(&v1[1], &v2[1], &w[1], 32, 1);\r\nmult_sh_align_mod(&v1[2], &v2[2], &w[2], 32, 2);\r\nmult_sh_align_mod(&v1[3], &v2[3], &w[3], 32, 3);\r\nmult_sh_align_mod(&v1[4], &v2[4], &w[4], 32, 4);\r\nmult_sh_align_mod(&v1[5], &v2[5], &w[5], 32, 5);\r\nmult_sh_align_mod(&v1[6], &v2[6], &w[6], 32, 6);\r\nmult_sh_align_mod(&v1[7], &v2[7], &w[7], 32, 7);\r\nbug = 0;\r\nfor (i = 0; i < 8; i++)\r\nif (v1[i] != w[i])\r\nbug = 1;\r\nif (bug == 0) {\r\nprintk("no.\n");\r\nreturn;\r\n}\r\nprintk("yes, workaround... ");\r\nfix = 1;\r\nfor (i = 0; i < 8; i++)\r\nif (v2[i] != w[i])\r\nfix = 0;\r\nif (fix == 1) {\r\nprintk("yes.\n");\r\nreturn;\r\n}\r\nprintk("no.\n");\r\npanic(bug64hit, !R4000_WAR ? r4kwar : nowar);\r\n}\r\nasmlinkage void __init do_daddi_ov(struct pt_regs *regs)\r\n{\r\nenum ctx_state prev_state;\r\nprev_state = exception_enter();\r\ndaddi_ov = 1;\r\nregs->cp0_epc += 4;\r\nexception_exit(prev_state);\r\n}\r\nstatic inline void check_daddi(void)\r\n{\r\nextern asmlinkage void handle_daddi_ov(void);\r\nunsigned long flags;\r\nvoid *handler;\r\nlong v, tmp;\r\nprintk("Checking for the daddi bug... ");\r\nlocal_irq_save(flags);\r\nhandler = set_except_vector(12, handle_daddi_ov);\r\nasm volatile(\r\n".set push\n\t"\r\n".set noat\n\t"\r\n".set noreorder\n\t"\r\n".set nomacro\n\t"\r\n"addiu %1, $0, %2\n\t"\r\n"dsrl %1, %1, 1\n\t"\r\n#ifdef HAVE_AS_SET_DADDI\r\n".set daddi\n\t"\r\n#endif\r\n"daddi %0, %1, %3\n\t"\r\n".set pop"\r\n: "=r" (v), "=&r" (tmp)\r\n: "I" (0xffffffffffffdb9aUL), "I" (0x1234));\r\nset_except_vector(12, handler);\r\nlocal_irq_restore(flags);\r\nif (daddi_ov) {\r\nprintk("no.\n");\r\nreturn;\r\n}\r\nprintk("yes, workaround... ");\r\nlocal_irq_save(flags);\r\nhandler = set_except_vector(12, handle_daddi_ov);\r\nasm volatile(\r\n"addiu %1, $0, %2\n\t"\r\n"dsrl %1, %1, 1\n\t"\r\n"daddi %0, %1, %3"\r\n: "=r" (v), "=&r" (tmp)\r\n: "I" (0xffffffffffffdb9aUL), "I" (0x1234));\r\nset_except_vector(12, handler);\r\nlocal_irq_restore(flags);\r\nif (daddi_ov) {\r\nprintk("yes.\n");\r\nreturn;\r\n}\r\nprintk("no.\n");\r\npanic(bug64hit, !DADDI_WAR ? daddiwar : nowar);\r\n}\r\nstatic inline void check_daddiu(void)\r\n{\r\nlong v, w, tmp;\r\nprintk("Checking for the daddiu bug... ");\r\nasm volatile(\r\n".set push\n\t"\r\n".set noat\n\t"\r\n".set noreorder\n\t"\r\n".set nomacro\n\t"\r\n"addiu %2, $0, %3\n\t"\r\n"dsrl %2, %2, 1\n\t"\r\n#ifdef HAVE_AS_SET_DADDI\r\n".set daddi\n\t"\r\n#endif\r\n"daddiu %0, %2, %4\n\t"\r\n"addiu %1, $0, %4\n\t"\r\n"daddu %1, %2\n\t"\r\n".set pop"\r\n: "=&r" (v), "=&r" (w), "=&r" (tmp)\r\n: "I" (0xffffffffffffdb9aUL), "I" (0x1234));\r\ndaddiu_bug = v != w;\r\nif (!daddiu_bug) {\r\nprintk("no.\n");\r\nreturn;\r\n}\r\nprintk("yes, workaround... ");\r\nasm volatile(\r\n"addiu %2, $0, %3\n\t"\r\n"dsrl %2, %2, 1\n\t"\r\n"daddiu %0, %2, %4\n\t"\r\n"addiu %1, $0, %4\n\t"\r\n"daddu %1, %2"\r\n: "=&r" (v), "=&r" (w), "=&r" (tmp)\r\n: "I" (0xffffffffffffdb9aUL), "I" (0x1234));\r\nif (v == w) {\r\nprintk("yes.\n");\r\nreturn;\r\n}\r\nprintk("no.\n");\r\npanic(bug64hit, !DADDI_WAR ? daddiwar : nowar);\r\n}\r\nvoid __init check_bugs64_early(void)\r\n{\r\nif (!config_enabled(CONFIG_CPU_MIPSR6)) {\r\ncheck_mult_sh();\r\ncheck_daddiu();\r\n}\r\n}\r\nvoid __init check_bugs64(void)\r\n{\r\nif (!config_enabled(CONFIG_CPU_MIPSR6))\r\ncheck_daddi();\r\n}
