static unsigned int get_fifosize_arm(struct amba_device *dev)\r\n{\r\nreturn amba_rev(dev) < 3 ? 16 : 32;\r\n}\r\nstatic unsigned int get_fifosize_st(struct amba_device *dev)\r\n{\r\nreturn 64;\r\n}\r\nstatic int pl011_fifo_to_tty(struct uart_amba_port *uap)\r\n{\r\nu16 status, ch;\r\nunsigned int flag, max_count = 256;\r\nint fifotaken = 0;\r\nwhile (max_count--) {\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\nif (status & UART01x_FR_RXFE)\r\nbreak;\r\nch = readw(uap->port.membase + UART01x_DR) |\r\nUART_DUMMY_DR_RX;\r\nflag = TTY_NORMAL;\r\nuap->port.icount.rx++;\r\nfifotaken++;\r\nif (unlikely(ch & UART_DR_ERROR)) {\r\nif (ch & UART011_DR_BE) {\r\nch &= ~(UART011_DR_FE | UART011_DR_PE);\r\nuap->port.icount.brk++;\r\nif (uart_handle_break(&uap->port))\r\ncontinue;\r\n} else if (ch & UART011_DR_PE)\r\nuap->port.icount.parity++;\r\nelse if (ch & UART011_DR_FE)\r\nuap->port.icount.frame++;\r\nif (ch & UART011_DR_OE)\r\nuap->port.icount.overrun++;\r\nch &= uap->port.read_status_mask;\r\nif (ch & UART011_DR_BE)\r\nflag = TTY_BREAK;\r\nelse if (ch & UART011_DR_PE)\r\nflag = TTY_PARITY;\r\nelse if (ch & UART011_DR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&uap->port, ch & 255))\r\ncontinue;\r\nuart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);\r\n}\r\nreturn fifotaken;\r\n}\r\nstatic int pl011_sgbuf_init(struct dma_chan *chan, struct pl011_sgbuf *sg,\r\nenum dma_data_direction dir)\r\n{\r\ndma_addr_t dma_addr;\r\nsg->buf = dma_alloc_coherent(chan->device->dev,\r\nPL011_DMA_BUFFER_SIZE, &dma_addr, GFP_KERNEL);\r\nif (!sg->buf)\r\nreturn -ENOMEM;\r\nsg_init_table(&sg->sg, 1);\r\nsg_set_page(&sg->sg, phys_to_page(dma_addr),\r\nPL011_DMA_BUFFER_SIZE, offset_in_page(dma_addr));\r\nsg_dma_address(&sg->sg) = dma_addr;\r\nsg_dma_len(&sg->sg) = PL011_DMA_BUFFER_SIZE;\r\nreturn 0;\r\n}\r\nstatic void pl011_sgbuf_free(struct dma_chan *chan, struct pl011_sgbuf *sg,\r\nenum dma_data_direction dir)\r\n{\r\nif (sg->buf) {\r\ndma_free_coherent(chan->device->dev,\r\nPL011_DMA_BUFFER_SIZE, sg->buf,\r\nsg_dma_address(&sg->sg));\r\n}\r\n}\r\nstatic void pl011_dma_probe(struct uart_amba_port *uap)\r\n{\r\nstruct amba_pl011_data *plat = dev_get_platdata(uap->port.dev);\r\nstruct device *dev = uap->port.dev;\r\nstruct dma_slave_config tx_conf = {\r\n.dst_addr = uap->port.mapbase + UART01x_DR,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\r\n.direction = DMA_MEM_TO_DEV,\r\n.dst_maxburst = uap->fifosize >> 1,\r\n.device_fc = false,\r\n};\r\nstruct dma_chan *chan;\r\ndma_cap_mask_t mask;\r\nuap->dma_probed = true;\r\nchan = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(chan)) {\r\nif (PTR_ERR(chan) == -EPROBE_DEFER) {\r\nuap->dma_probed = false;\r\nreturn;\r\n}\r\nif (!plat || !plat->dma_filter) {\r\ndev_info(uap->port.dev, "no DMA platform data\n");\r\nreturn;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchan = dma_request_channel(mask, plat->dma_filter,\r\nplat->dma_tx_param);\r\nif (!chan) {\r\ndev_err(uap->port.dev, "no TX DMA channel!\n");\r\nreturn;\r\n}\r\n}\r\ndmaengine_slave_config(chan, &tx_conf);\r\nuap->dmatx.chan = chan;\r\ndev_info(uap->port.dev, "DMA channel TX %s\n",\r\ndma_chan_name(uap->dmatx.chan));\r\nchan = dma_request_slave_channel(dev, "rx");\r\nif (!chan && plat->dma_rx_param) {\r\nchan = dma_request_channel(mask, plat->dma_filter, plat->dma_rx_param);\r\nif (!chan) {\r\ndev_err(uap->port.dev, "no RX DMA channel!\n");\r\nreturn;\r\n}\r\n}\r\nif (chan) {\r\nstruct dma_slave_config rx_conf = {\r\n.src_addr = uap->port.mapbase + UART01x_DR,\r\n.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\r\n.direction = DMA_DEV_TO_MEM,\r\n.src_maxburst = uap->fifosize >> 2,\r\n.device_fc = false,\r\n};\r\nstruct dma_slave_caps caps;\r\nif (0 == dma_get_slave_caps(chan, &caps)) {\r\nif (caps.residue_granularity ==\r\nDMA_RESIDUE_GRANULARITY_DESCRIPTOR) {\r\ndma_release_channel(chan);\r\ndev_info(uap->port.dev,\r\n"RX DMA disabled - no residue processing\n");\r\nreturn;\r\n}\r\n}\r\ndmaengine_slave_config(chan, &rx_conf);\r\nuap->dmarx.chan = chan;\r\nuap->dmarx.auto_poll_rate = false;\r\nif (plat && plat->dma_rx_poll_enable) {\r\nif (plat->dma_rx_poll_rate) {\r\nuap->dmarx.auto_poll_rate = false;\r\nuap->dmarx.poll_rate = plat->dma_rx_poll_rate;\r\n} else {\r\nuap->dmarx.auto_poll_rate = true;\r\nuap->dmarx.poll_rate = 100;\r\n}\r\nif (plat->dma_rx_poll_timeout)\r\nuap->dmarx.poll_timeout =\r\nplat->dma_rx_poll_timeout;\r\nelse\r\nuap->dmarx.poll_timeout = 3000;\r\n} else if (!plat && dev->of_node) {\r\nuap->dmarx.auto_poll_rate = of_property_read_bool(\r\ndev->of_node, "auto-poll");\r\nif (uap->dmarx.auto_poll_rate) {\r\nu32 x;\r\nif (0 == of_property_read_u32(dev->of_node,\r\n"poll-rate-ms", &x))\r\nuap->dmarx.poll_rate = x;\r\nelse\r\nuap->dmarx.poll_rate = 100;\r\nif (0 == of_property_read_u32(dev->of_node,\r\n"poll-timeout-ms", &x))\r\nuap->dmarx.poll_timeout = x;\r\nelse\r\nuap->dmarx.poll_timeout = 3000;\r\n}\r\n}\r\ndev_info(uap->port.dev, "DMA channel RX %s\n",\r\ndma_chan_name(uap->dmarx.chan));\r\n}\r\n}\r\nstatic void pl011_dma_remove(struct uart_amba_port *uap)\r\n{\r\nif (uap->dmatx.chan)\r\ndma_release_channel(uap->dmatx.chan);\r\nif (uap->dmarx.chan)\r\ndma_release_channel(uap->dmarx.chan);\r\n}\r\nstatic void pl011_dma_tx_callback(void *data)\r\n{\r\nstruct uart_amba_port *uap = data;\r\nstruct pl011_dmatx_data *dmatx = &uap->dmatx;\r\nunsigned long flags;\r\nu16 dmacr;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nif (uap->dmatx.queued)\r\ndma_unmap_sg(dmatx->chan->device->dev, &dmatx->sg, 1,\r\nDMA_TO_DEVICE);\r\ndmacr = uap->dmacr;\r\nuap->dmacr = dmacr & ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (!(dmacr & UART011_TXDMAE) || uart_tx_stopped(&uap->port) ||\r\nuart_circ_empty(&uap->port.state->xmit)) {\r\nuap->dmatx.queued = false;\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nreturn;\r\n}\r\nif (pl011_dma_tx_refill(uap) <= 0)\r\npl011_start_tx_pio(uap);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic int pl011_dma_tx_refill(struct uart_amba_port *uap)\r\n{\r\nstruct pl011_dmatx_data *dmatx = &uap->dmatx;\r\nstruct dma_chan *chan = dmatx->chan;\r\nstruct dma_device *dma_dev = chan->device;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nunsigned int count;\r\ncount = uart_circ_chars_pending(xmit);\r\nif (count < (uap->fifosize >> 1)) {\r\nuap->dmatx.queued = false;\r\nreturn 0;\r\n}\r\ncount -= 1;\r\nif (count > PL011_DMA_BUFFER_SIZE)\r\ncount = PL011_DMA_BUFFER_SIZE;\r\nif (xmit->tail < xmit->head)\r\nmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], count);\r\nelse {\r\nsize_t first = UART_XMIT_SIZE - xmit->tail;\r\nsize_t second;\r\nif (first > count)\r\nfirst = count;\r\nsecond = count - first;\r\nmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], first);\r\nif (second)\r\nmemcpy(&dmatx->buf[first], &xmit->buf[0], second);\r\n}\r\ndmatx->sg.length = count;\r\nif (dma_map_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE) != 1) {\r\nuap->dmatx.queued = false;\r\ndev_dbg(uap->port.dev, "unable to map TX DMA\n");\r\nreturn -EBUSY;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, &dmatx->sg, 1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndma_unmap_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE);\r\nuap->dmatx.queued = false;\r\ndev_dbg(uap->port.dev, "TX DMA busy\n");\r\nreturn -EBUSY;\r\n}\r\ndesc->callback = pl011_dma_tx_callback;\r\ndesc->callback_param = uap;\r\ndmaengine_submit(desc);\r\ndma_dev->device_issue_pending(chan);\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmatx.queued = true;\r\nxmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);\r\nuap->port.icount.tx += count;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nreturn 1;\r\n}\r\nstatic bool pl011_dma_tx_irq(struct uart_amba_port *uap)\r\n{\r\nif (!uap->using_tx_dma)\r\nreturn false;\r\nif (uap->dmatx.queued) {\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn true;\r\n}\r\nif (pl011_dma_tx_refill(uap) > 0) {\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\r\n{\r\nif (uap->dmatx.queued) {\r\nuap->dmacr &= ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\n}\r\n}\r\nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\r\n{\r\nu16 dmacr;\r\nif (!uap->using_tx_dma)\r\nreturn false;\r\nif (!uap->port.x_char) {\r\nbool ret = true;\r\nif (!uap->dmatx.queued) {\r\nif (pl011_dma_tx_refill(uap) > 0) {\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase +\r\nUART011_IMSC);\r\n} else\r\nret = false;\r\n} else if (!(uap->dmacr & UART011_TXDMAE)) {\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr,\r\nuap->port.membase + UART011_DMACR);\r\n}\r\nreturn ret;\r\n}\r\ndmacr = uap->dmacr;\r\nuap->dmacr &= ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF) {\r\nreturn false;\r\n}\r\nwritew(uap->port.x_char, uap->port.membase + UART01x_DR);\r\nuap->port.icount.tx++;\r\nuap->port.x_char = 0;\r\nuap->dmacr = dmacr;\r\nwritew(dmacr, uap->port.membase + UART011_DMACR);\r\nreturn true;\r\n}\r\nstatic void pl011_dma_flush_buffer(struct uart_port *port)\r\n__releases(&uap->port.lock\r\nstatic int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\r\n{\r\nstruct dma_chan *rxchan = uap->dmarx.chan;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct pl011_sgbuf *sgbuf;\r\nif (!rxchan)\r\nreturn -EIO;\r\nsgbuf = uap->dmarx.use_buf_b ?\r\n&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;\r\ndesc = dmaengine_prep_slave_sg(rxchan, &sgbuf->sg, 1,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nuap->dmarx.running = false;\r\ndmaengine_terminate_all(rxchan);\r\nreturn -EBUSY;\r\n}\r\ndesc->callback = pl011_dma_rx_callback;\r\ndesc->callback_param = uap;\r\ndmarx->cookie = dmaengine_submit(desc);\r\ndma_async_issue_pending(rxchan);\r\nuap->dmacr |= UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmarx.running = true;\r\nuap->im &= ~UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn 0;\r\n}\r\nstatic void pl011_dma_rx_chars(struct uart_amba_port *uap,\r\nu32 pending, bool use_buf_b,\r\nbool readfifo)\r\n{\r\nstruct tty_port *port = &uap->port.state->port;\r\nstruct pl011_sgbuf *sgbuf = use_buf_b ?\r\n&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;\r\nint dma_count = 0;\r\nu32 fifotaken = 0;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nint dmataken = 0;\r\nif (uap->dmarx.poll_rate) {\r\ndmataken = sgbuf->sg.length - dmarx->last_residue;\r\nif (pending >= dmataken)\r\npending -= dmataken;\r\n}\r\nif (pending) {\r\ndma_count = tty_insert_flip_string(port, sgbuf->buf + dmataken,\r\npending);\r\nuap->port.icount.rx += dma_count;\r\nif (dma_count < pending)\r\ndev_warn(uap->port.dev,\r\n"couldn't insert all characters (TTY is full?)\n");\r\n}\r\nif (uap->dmarx.poll_rate)\r\ndmarx->last_residue = sgbuf->sg.length;\r\nif (dma_count == pending && readfifo) {\r\nwritew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS,\r\nuap->port.membase + UART011_ICR);\r\nfifotaken = pl011_fifo_to_tty(uap);\r\n}\r\nspin_unlock(&uap->port.lock);\r\ndev_vdbg(uap->port.dev,\r\n"Took %d chars from DMA buffer and %d chars from the FIFO\n",\r\ndma_count, fifotaken);\r\ntty_flip_buffer_push(port);\r\nspin_lock(&uap->port.lock);\r\n}\r\nstatic void pl011_dma_rx_irq(struct uart_amba_port *uap)\r\n{\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_chan *rxchan = dmarx->chan;\r\nstruct pl011_sgbuf *sgbuf = dmarx->use_buf_b ?\r\n&dmarx->sgbuf_b : &dmarx->sgbuf_a;\r\nsize_t pending;\r\nstruct dma_tx_state state;\r\nenum dma_status dmastat;\r\nif (dmaengine_pause(rxchan))\r\ndev_err(uap->port.dev, "unable to pause DMA transfer\n");\r\ndmastat = rxchan->device->device_tx_status(rxchan,\r\ndmarx->cookie, &state);\r\nif (dmastat != DMA_PAUSED)\r\ndev_err(uap->port.dev, "unable to pause DMA transfer\n");\r\nuap->dmacr &= ~UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmarx.running = false;\r\npending = sgbuf->sg.length - state.residue;\r\nBUG_ON(pending > PL011_DMA_BUFFER_SIZE);\r\ndmaengine_terminate_all(rxchan);\r\npl011_dma_rx_chars(uap, pending, dmarx->use_buf_b, true);\r\ndmarx->use_buf_b = !dmarx->use_buf_b;\r\nif (pl011_dma_rx_trigger_dma(uap)) {\r\ndev_dbg(uap->port.dev, "could not retrigger RX DMA job "\r\n"fall back to interrupt mode\n");\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\n}\r\nstatic void pl011_dma_rx_callback(void *data)\r\n{\r\nstruct uart_amba_port *uap = data;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_chan *rxchan = dmarx->chan;\r\nbool lastbuf = dmarx->use_buf_b;\r\nstruct pl011_sgbuf *sgbuf = dmarx->use_buf_b ?\r\n&dmarx->sgbuf_b : &dmarx->sgbuf_a;\r\nsize_t pending;\r\nstruct dma_tx_state state;\r\nint ret;\r\nspin_lock_irq(&uap->port.lock);\r\nrxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);\r\npending = sgbuf->sg.length - state.residue;\r\nBUG_ON(pending > PL011_DMA_BUFFER_SIZE);\r\ndmaengine_terminate_all(rxchan);\r\nuap->dmarx.running = false;\r\ndmarx->use_buf_b = !lastbuf;\r\nret = pl011_dma_rx_trigger_dma(uap);\r\npl011_dma_rx_chars(uap, pending, lastbuf, false);\r\nspin_unlock_irq(&uap->port.lock);\r\nif (ret) {\r\ndev_dbg(uap->port.dev, "could not retrigger RX DMA job "\r\n"fall back to interrupt mode\n");\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\n}\r\nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\r\n{\r\nuap->dmacr &= ~UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\n}\r\nstatic void pl011_dma_rx_poll(unsigned long args)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)args;\r\nstruct tty_port *port = &uap->port.state->port;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_chan *rxchan = uap->dmarx.chan;\r\nunsigned long flags = 0;\r\nunsigned int dmataken = 0;\r\nunsigned int size = 0;\r\nstruct pl011_sgbuf *sgbuf;\r\nint dma_count;\r\nstruct dma_tx_state state;\r\nsgbuf = dmarx->use_buf_b ? &uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;\r\nrxchan->device->device_tx_status(rxchan, dmarx->cookie, &state);\r\nif (likely(state.residue < dmarx->last_residue)) {\r\ndmataken = sgbuf->sg.length - dmarx->last_residue;\r\nsize = dmarx->last_residue - state.residue;\r\ndma_count = tty_insert_flip_string(port, sgbuf->buf + dmataken,\r\nsize);\r\nif (dma_count == size)\r\ndmarx->last_residue = state.residue;\r\ndmarx->last_jiffies = jiffies;\r\n}\r\ntty_flip_buffer_push(port);\r\nif (jiffies_to_msecs(jiffies - dmarx->last_jiffies)\r\n> uap->dmarx.poll_timeout) {\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\npl011_dma_rx_stop(uap);\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nuap->dmarx.running = false;\r\ndmaengine_terminate_all(rxchan);\r\ndel_timer(&uap->dmarx.timer);\r\n} else {\r\nmod_timer(&uap->dmarx.timer,\r\njiffies + msecs_to_jiffies(uap->dmarx.poll_rate));\r\n}\r\n}\r\nstatic void pl011_dma_startup(struct uart_amba_port *uap)\r\n{\r\nint ret;\r\nif (!uap->dma_probed)\r\npl011_dma_probe(uap);\r\nif (!uap->dmatx.chan)\r\nreturn;\r\nuap->dmatx.buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL | __GFP_DMA);\r\nif (!uap->dmatx.buf) {\r\ndev_err(uap->port.dev, "no memory for DMA TX buffer\n");\r\nuap->port.fifosize = uap->fifosize;\r\nreturn;\r\n}\r\nsg_init_one(&uap->dmatx.sg, uap->dmatx.buf, PL011_DMA_BUFFER_SIZE);\r\nuap->port.fifosize = PL011_DMA_BUFFER_SIZE;\r\nuap->using_tx_dma = true;\r\nif (!uap->dmarx.chan)\r\ngoto skip_rx;\r\nret = pl011_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_a,\r\nDMA_FROM_DEVICE);\r\nif (ret) {\r\ndev_err(uap->port.dev, "failed to init DMA %s: %d\n",\r\n"RX buffer A", ret);\r\ngoto skip_rx;\r\n}\r\nret = pl011_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_b,\r\nDMA_FROM_DEVICE);\r\nif (ret) {\r\ndev_err(uap->port.dev, "failed to init DMA %s: %d\n",\r\n"RX buffer B", ret);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a,\r\nDMA_FROM_DEVICE);\r\ngoto skip_rx;\r\n}\r\nuap->using_rx_dma = true;\r\nskip_rx:\r\nuap->dmacr |= UART011_DMAONERR;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (uap->vendor->dma_threshold)\r\nwritew(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,\r\nuap->port.membase + ST_UART011_DMAWM);\r\nif (uap->using_rx_dma) {\r\nif (pl011_dma_rx_trigger_dma(uap))\r\ndev_dbg(uap->port.dev, "could not trigger initial "\r\n"RX DMA job, fall back to interrupt mode\n");\r\nif (uap->dmarx.poll_rate) {\r\ninit_timer(&(uap->dmarx.timer));\r\nuap->dmarx.timer.function = pl011_dma_rx_poll;\r\nuap->dmarx.timer.data = (unsigned long)uap;\r\nmod_timer(&uap->dmarx.timer,\r\njiffies +\r\nmsecs_to_jiffies(uap->dmarx.poll_rate));\r\nuap->dmarx.last_residue = PL011_DMA_BUFFER_SIZE;\r\nuap->dmarx.last_jiffies = jiffies;\r\n}\r\n}\r\n}\r\nstatic void pl011_dma_shutdown(struct uart_amba_port *uap)\r\n{\r\nif (!(uap->using_tx_dma || uap->using_rx_dma))\r\nreturn;\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_BUSY)\r\nbarrier();\r\nspin_lock_irq(&uap->port.lock);\r\nuap->dmacr &= ~(UART011_DMAONERR | UART011_RXDMAE | UART011_TXDMAE);\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nspin_unlock_irq(&uap->port.lock);\r\nif (uap->using_tx_dma) {\r\ndmaengine_terminate_all(uap->dmatx.chan);\r\nif (uap->dmatx.queued) {\r\ndma_unmap_sg(uap->dmatx.chan->device->dev, &uap->dmatx.sg, 1,\r\nDMA_TO_DEVICE);\r\nuap->dmatx.queued = false;\r\n}\r\nkfree(uap->dmatx.buf);\r\nuap->using_tx_dma = false;\r\n}\r\nif (uap->using_rx_dma) {\r\ndmaengine_terminate_all(uap->dmarx.chan);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a, DMA_FROM_DEVICE);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_b, DMA_FROM_DEVICE);\r\nif (uap->dmarx.poll_rate)\r\ndel_timer_sync(&uap->dmarx.timer);\r\nuap->using_rx_dma = false;\r\n}\r\n}\r\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\r\n{\r\nreturn uap->using_rx_dma;\r\n}\r\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\r\n{\r\nreturn uap->using_rx_dma && uap->dmarx.running;\r\n}\r\nstatic inline void pl011_dma_probe(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_remove(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_startup(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_shutdown(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline bool pl011_dma_tx_irq(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_rx_irq(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic void pl011_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\npl011_dma_tx_stop(uap);\r\n}\r\nstatic void pl011_start_tx_pio(struct uart_amba_port *uap)\r\n{\r\nuap->im |= UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\npl011_tx_chars(uap, false);\r\n}\r\nstatic void pl011_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nif (!pl011_dma_tx_start(uap))\r\npl011_start_tx_pio(uap);\r\n}\r\nstatic void pl011_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nuap->im &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|\r\nUART011_PEIM|UART011_BEIM|UART011_OEIM);\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\npl011_dma_rx_stop(uap);\r\n}\r\nstatic void pl011_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nuap->im |= UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\nstatic void pl011_rx_chars(struct uart_amba_port *uap)\r\n__releases(&uap->port.lock\r\nstatic bool pl011_tx_char(struct uart_amba_port *uap, unsigned char c,\r\nbool from_irq)\r\n{\r\nif (unlikely(!from_irq) &&\r\nreadw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)\r\nreturn false;\r\nwritew(c, uap->port.membase + UART01x_DR);\r\nuap->port.icount.tx++;\r\nreturn true;\r\n}\r\nstatic void pl011_tx_chars(struct uart_amba_port *uap, bool from_irq)\r\n{\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nint count = uap->fifosize >> 1;\r\nif (uap->port.x_char) {\r\nif (!pl011_tx_char(uap, uap->port.x_char, from_irq))\r\nreturn;\r\nuap->port.x_char = 0;\r\n--count;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {\r\npl011_stop_tx(&uap->port);\r\nreturn;\r\n}\r\nif (pl011_dma_tx_irq(uap))\r\nreturn;\r\ndo {\r\nif (likely(from_irq) && count-- == 0)\r\nbreak;\r\nif (!pl011_tx_char(uap, xmit->buf[xmit->tail], from_irq))\r\nbreak;\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n} while (!uart_circ_empty(xmit));\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nif (uart_circ_empty(xmit))\r\npl011_stop_tx(&uap->port);\r\n}\r\nstatic void pl011_modem_status(struct uart_amba_port *uap)\r\n{\r\nunsigned int status, delta;\r\nstatus = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\ndelta = status ^ uap->old_status;\r\nuap->old_status = status;\r\nif (!delta)\r\nreturn;\r\nif (delta & UART01x_FR_DCD)\r\nuart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);\r\nif (delta & UART01x_FR_DSR)\r\nuap->port.icount.dsr++;\r\nif (delta & UART01x_FR_CTS)\r\nuart_handle_cts_change(&uap->port, status & UART01x_FR_CTS);\r\nwake_up_interruptible(&uap->port.state->port.delta_msr_wait);\r\n}\r\nstatic void check_apply_cts_event_workaround(struct uart_amba_port *uap)\r\n{\r\nunsigned int dummy_read;\r\nif (!uap->vendor->cts_event_workaround)\r\nreturn;\r\nwritew(0x00, uap->port.membase + UART011_ICR);\r\ndummy_read = readw(uap->port.membase + UART011_ICR);\r\ndummy_read = readw(uap->port.membase + UART011_ICR);\r\n}\r\nstatic irqreturn_t pl011_int(int irq, void *dev_id)\r\n{\r\nstruct uart_amba_port *uap = dev_id;\r\nunsigned long flags;\r\nunsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;\r\nu16 imsc;\r\nint handled = 0;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nimsc = readw(uap->port.membase + UART011_IMSC);\r\nstatus = readw(uap->port.membase + UART011_RIS) & imsc;\r\nif (status) {\r\ndo {\r\ncheck_apply_cts_event_workaround(uap);\r\nwritew(status & ~(UART011_TXIS|UART011_RTIS|\r\nUART011_RXIS),\r\nuap->port.membase + UART011_ICR);\r\nif (status & (UART011_RTIS|UART011_RXIS)) {\r\nif (pl011_dma_rx_running(uap))\r\npl011_dma_rx_irq(uap);\r\nelse\r\npl011_rx_chars(uap);\r\n}\r\nif (status & (UART011_DSRMIS|UART011_DCDMIS|\r\nUART011_CTSMIS|UART011_RIMIS))\r\npl011_modem_status(uap);\r\nif (status & UART011_TXIS)\r\npl011_tx_chars(uap, true);\r\nif (pass_counter-- == 0)\r\nbreak;\r\nstatus = readw(uap->port.membase + UART011_RIS) & imsc;\r\n} while (status != 0);\r\nhandled = 1;\r\n}\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned int pl011_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int status = readw(uap->port.membase + UART01x_FR);\r\nreturn status & (UART01x_FR_BUSY|UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int pl011_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int result = 0;\r\nunsigned int status = readw(uap->port.membase + UART01x_FR);\r\n#define TIOCMBIT(uartbit, tiocmbit) \\r\nif (status & uartbit) \\r\nresult |= tiocmbit\r\nTIOCMBIT(UART01x_FR_DCD, TIOCM_CAR);\r\nTIOCMBIT(UART01x_FR_DSR, TIOCM_DSR);\r\nTIOCMBIT(UART01x_FR_CTS, TIOCM_CTS);\r\nTIOCMBIT(UART011_FR_RI, TIOCM_RNG);\r\n#undef TIOCMBIT\r\nreturn result;\r\n}\r\nstatic void pl011_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int cr;\r\ncr = readw(uap->port.membase + UART011_CR);\r\n#define TIOCMBIT(tiocmbit, uartbit) \\r\nif (mctrl & tiocmbit) \\r\ncr |= uartbit; \\r\nelse \\r\ncr &= ~uartbit\r\nTIOCMBIT(TIOCM_RTS, UART011_CR_RTS);\r\nTIOCMBIT(TIOCM_DTR, UART011_CR_DTR);\r\nTIOCMBIT(TIOCM_OUT1, UART011_CR_OUT1);\r\nTIOCMBIT(TIOCM_OUT2, UART011_CR_OUT2);\r\nTIOCMBIT(TIOCM_LOOP, UART011_CR_LBE);\r\nif (uap->autorts) {\r\nTIOCMBIT(TIOCM_RTS, UART011_CR_RTSEN);\r\n}\r\n#undef TIOCMBIT\r\nwritew(cr, uap->port.membase + UART011_CR);\r\n}\r\nstatic void pl011_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned long flags;\r\nunsigned int lcr_h;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nlcr_h = readw(uap->port.membase + uap->lcrh_tx);\r\nif (break_state == -1)\r\nlcr_h |= UART01x_LCRH_BRK;\r\nelse\r\nlcr_h &= ~UART01x_LCRH_BRK;\r\nwritew(lcr_h, uap->port.membase + uap->lcrh_tx);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic void pl011_quiesce_irqs(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned char __iomem *regs = uap->port.membase;\r\nwritew(readw(regs + UART011_MIS), regs + UART011_ICR);\r\nwritew(readw(regs + UART011_IMSC) & ~UART011_TXIM, regs + UART011_IMSC);\r\n}\r\nstatic int pl011_get_poll_char(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int status;\r\npl011_quiesce_irqs(port);\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\nif (status & UART01x_FR_RXFE)\r\nreturn NO_POLL_CHAR;\r\nreturn readw(uap->port.membase + UART01x_DR);\r\n}\r\nstatic void pl011_put_poll_char(struct uart_port *port,\r\nunsigned char ch)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)\r\nbarrier();\r\nwritew(ch, uap->port.membase + UART01x_DR);\r\n}\r\nstatic int pl011_hwinit(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nint retval;\r\npinctrl_pm_select_default_state(port->dev);\r\nretval = clk_prepare_enable(uap->clk);\r\nif (retval)\r\nreturn retval;\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nwritew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS |\r\nUART011_RTIS | UART011_RXIS, uap->port.membase + UART011_ICR);\r\nuap->im = readw(uap->port.membase + UART011_IMSC);\r\nwritew(UART011_RTIM | UART011_RXIM, uap->port.membase + UART011_IMSC);\r\nif (dev_get_platdata(uap->port.dev)) {\r\nstruct amba_pl011_data *plat;\r\nplat = dev_get_platdata(uap->port.dev);\r\nif (plat->init)\r\nplat->init();\r\n}\r\nreturn 0;\r\n}\r\nstatic void pl011_write_lcr_h(struct uart_amba_port *uap, unsigned int lcr_h)\r\n{\r\nwritew(lcr_h, uap->port.membase + uap->lcrh_rx);\r\nif (uap->lcrh_rx != uap->lcrh_tx) {\r\nint i;\r\nfor (i = 0; i < 10; ++i)\r\nwritew(0xff, uap->port.membase + UART011_MIS);\r\nwritew(lcr_h, uap->port.membase + uap->lcrh_tx);\r\n}\r\n}\r\nstatic int pl011_allocate_irq(struct uart_amba_port *uap)\r\n{\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn request_irq(uap->port.irq, pl011_int, 0, "uart-pl011", uap);\r\n}\r\nstatic void pl011_enable_interrupts(struct uart_amba_port *uap)\r\n{\r\nspin_lock_irq(&uap->port.lock);\r\nwritew(UART011_RTIS | UART011_RXIS,\r\nuap->port.membase + UART011_ICR);\r\nuap->im = UART011_RTIM;\r\nif (!pl011_dma_rx_running(uap))\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nspin_unlock_irq(&uap->port.lock);\r\n}\r\nstatic int pl011_startup(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int cr;\r\nint retval;\r\nretval = pl011_hwinit(port);\r\nif (retval)\r\ngoto clk_dis;\r\nretval = pl011_allocate_irq(uap);\r\nif (retval)\r\ngoto clk_dis;\r\nwritew(uap->vendor->ifls, uap->port.membase + UART011_IFLS);\r\nspin_lock_irq(&uap->port.lock);\r\ncr = uap->old_cr & (UART011_CR_RTS | UART011_CR_DTR);\r\ncr |= UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;\r\nwritew(cr, uap->port.membase + UART011_CR);\r\nspin_unlock_irq(&uap->port.lock);\r\nuap->old_status = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\npl011_dma_startup(uap);\r\npl011_enable_interrupts(uap);\r\nreturn 0;\r\nclk_dis:\r\nclk_disable_unprepare(uap->clk);\r\nreturn retval;\r\n}\r\nstatic int sbsa_uart_startup(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nint retval;\r\nretval = pl011_hwinit(port);\r\nif (retval)\r\nreturn retval;\r\nretval = pl011_allocate_irq(uap);\r\nif (retval)\r\nreturn retval;\r\nuap->old_status = 0;\r\npl011_enable_interrupts(uap);\r\nreturn 0;\r\n}\r\nstatic void pl011_shutdown_channel(struct uart_amba_port *uap,\r\nunsigned int lcrh)\r\n{\r\nunsigned long val;\r\nval = readw(uap->port.membase + lcrh);\r\nval &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);\r\nwritew(val, uap->port.membase + lcrh);\r\n}\r\nstatic void pl011_disable_uart(struct uart_amba_port *uap)\r\n{\r\nunsigned int cr;\r\nuap->autorts = false;\r\nspin_lock_irq(&uap->port.lock);\r\ncr = readw(uap->port.membase + UART011_CR);\r\nuap->old_cr = cr;\r\ncr &= UART011_CR_RTS | UART011_CR_DTR;\r\ncr |= UART01x_CR_UARTEN | UART011_CR_TXE;\r\nwritew(cr, uap->port.membase + UART011_CR);\r\nspin_unlock_irq(&uap->port.lock);\r\npl011_shutdown_channel(uap, uap->lcrh_rx);\r\nif (uap->lcrh_rx != uap->lcrh_tx)\r\npl011_shutdown_channel(uap, uap->lcrh_tx);\r\n}\r\nstatic void pl011_disable_interrupts(struct uart_amba_port *uap)\r\n{\r\nspin_lock_irq(&uap->port.lock);\r\nuap->im = 0;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nwritew(0xffff, uap->port.membase + UART011_ICR);\r\nspin_unlock_irq(&uap->port.lock);\r\n}\r\nstatic void pl011_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\npl011_disable_interrupts(uap);\r\npl011_dma_shutdown(uap);\r\nfree_irq(uap->port.irq, uap);\r\npl011_disable_uart(uap);\r\nclk_disable_unprepare(uap->clk);\r\npinctrl_pm_select_sleep_state(port->dev);\r\nif (dev_get_platdata(uap->port.dev)) {\r\nstruct amba_pl011_data *plat;\r\nplat = dev_get_platdata(uap->port.dev);\r\nif (plat->exit)\r\nplat->exit();\r\n}\r\nif (uap->port.ops->flush_buffer)\r\nuap->port.ops->flush_buffer(port);\r\n}\r\nstatic void sbsa_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\npl011_disable_interrupts(uap);\r\nfree_irq(uap->port.irq, uap);\r\nif (uap->port.ops->flush_buffer)\r\nuap->port.ops->flush_buffer(port);\r\n}\r\nstatic void\r\npl011_setup_status_masks(struct uart_port *port, struct ktermios *termios)\r\n{\r\nport->read_status_mask = UART011_DR_OE | 255;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART011_DR_FE | UART011_DR_PE;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= UART011_DR_BE;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= UART011_DR_BE;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART011_DR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_DUMMY_DR_RX;\r\n}\r\nstatic void\r\npl011_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned int lcr_h, old_cr;\r\nunsigned long flags;\r\nunsigned int baud, quot, clkdiv;\r\nif (uap->vendor->oversampling)\r\nclkdiv = 8;\r\nelse\r\nclkdiv = 16;\r\nbaud = uart_get_baud_rate(port, termios, old, 0,\r\nport->uartclk / clkdiv);\r\n#ifdef CONFIG_DMA_ENGINE\r\nif (uap->dmarx.auto_poll_rate)\r\nuap->dmarx.poll_rate = DIV_ROUND_UP(10000000, baud);\r\n#endif\r\nif (baud > port->uartclk/16)\r\nquot = DIV_ROUND_CLOSEST(port->uartclk * 8, baud);\r\nelse\r\nquot = DIV_ROUND_CLOSEST(port->uartclk * 4, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr_h = UART01x_LCRH_WLEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr_h = UART01x_LCRH_WLEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr_h = UART01x_LCRH_WLEN_7;\r\nbreak;\r\ndefault:\r\nlcr_h = UART01x_LCRH_WLEN_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr_h |= UART01x_LCRH_STP2;\r\nif (termios->c_cflag & PARENB) {\r\nlcr_h |= UART01x_LCRH_PEN;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr_h |= UART01x_LCRH_EPS;\r\n}\r\nif (uap->fifosize > 1)\r\nlcr_h |= UART01x_LCRH_FEN;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\npl011_setup_status_masks(port, termios);\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\npl011_enable_ms(port);\r\nold_cr = readw(port->membase + UART011_CR);\r\nwritew(0, port->membase + UART011_CR);\r\nif (termios->c_cflag & CRTSCTS) {\r\nif (old_cr & UART011_CR_RTS)\r\nold_cr |= UART011_CR_RTSEN;\r\nold_cr |= UART011_CR_CTSEN;\r\nuap->autorts = true;\r\n} else {\r\nold_cr &= ~(UART011_CR_CTSEN | UART011_CR_RTSEN);\r\nuap->autorts = false;\r\n}\r\nif (uap->vendor->oversampling) {\r\nif (baud > port->uartclk / 16)\r\nold_cr |= ST_UART011_CR_OVSFACT;\r\nelse\r\nold_cr &= ~ST_UART011_CR_OVSFACT;\r\n}\r\nif (uap->vendor->oversampling) {\r\nif ((baud >= 3000000) && (baud < 3250000) && (quot > 1))\r\nquot -= 1;\r\nelse if ((baud > 3250000) && (quot > 2))\r\nquot -= 2;\r\n}\r\nwritew(quot & 0x3f, port->membase + UART011_FBRD);\r\nwritew(quot >> 6, port->membase + UART011_IBRD);\r\npl011_write_lcr_h(uap, lcr_h);\r\nwritew(old_cr, port->membase + UART011_CR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void\r\nsbsa_uart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nunsigned long flags;\r\ntty_termios_encode_baud_rate(termios, uap->fixed_baud, uap->fixed_baud);\r\ntermios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);\r\ntermios->c_cflag &= ~(CMSPAR | CRTSCTS);\r\ntermios->c_cflag |= CS8 | CLOCAL;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, CS8, uap->fixed_baud);\r\npl011_setup_status_masks(port, termios);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *pl011_type(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nreturn uap->port.type == PORT_AMBA ? uap->type : NULL;\r\n}\r\nstatic void pl011_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, SZ_4K);\r\n}\r\nstatic int pl011_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, SZ_4K, "uart-pl011")\r\n!= NULL ? 0 : -EBUSY;\r\n}\r\nstatic void pl011_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_AMBA;\r\npl011_request_port(port);\r\n}\r\n}\r\nstatic int pl011_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= nr_irqs)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void sbsa_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int sbsa_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pl011_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_amba_port *uap =\r\ncontainer_of(port, struct uart_amba_port, port);\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)\r\nbarrier();\r\nwritew(ch, uap->port.membase + UART01x_DR);\r\n}\r\nstatic void\r\npl011_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_amba_port *uap = amba_ports[co->index];\r\nunsigned int status, old_cr = 0, new_cr;\r\nunsigned long flags;\r\nint locked = 1;\r\nclk_enable(uap->clk);\r\nlocal_irq_save(flags);\r\nif (uap->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&uap->port.lock);\r\nelse\r\nspin_lock(&uap->port.lock);\r\nif (!uap->vendor->always_enabled) {\r\nold_cr = readw(uap->port.membase + UART011_CR);\r\nnew_cr = old_cr & ~UART011_CR_CTSEN;\r\nnew_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;\r\nwritew(new_cr, uap->port.membase + UART011_CR);\r\n}\r\nuart_console_write(&uap->port, s, count, pl011_console_putchar);\r\ndo {\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\n} while (status & UART01x_FR_BUSY);\r\nif (!uap->vendor->always_enabled)\r\nwritew(old_cr, uap->port.membase + UART011_CR);\r\nif (locked)\r\nspin_unlock(&uap->port.lock);\r\nlocal_irq_restore(flags);\r\nclk_disable(uap->clk);\r\n}\r\nstatic void __init\r\npl011_console_get_options(struct uart_amba_port *uap, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readw(uap->port.membase + UART011_CR) & UART01x_CR_UARTEN) {\r\nunsigned int lcr_h, ibrd, fbrd;\r\nlcr_h = readw(uap->port.membase + uap->lcrh_tx);\r\n*parity = 'n';\r\nif (lcr_h & UART01x_LCRH_PEN) {\r\nif (lcr_h & UART01x_LCRH_EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nibrd = readw(uap->port.membase + UART011_IBRD);\r\nfbrd = readw(uap->port.membase + UART011_FBRD);\r\n*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);\r\nif (uap->vendor->oversampling) {\r\nif (readw(uap->port.membase + UART011_CR)\r\n& ST_UART011_CR_OVSFACT)\r\n*baud *= 2;\r\n}\r\n}\r\n}\r\nstatic int __init pl011_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_amba_port *uap;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index >= UART_NR)\r\nco->index = 0;\r\nuap = amba_ports[co->index];\r\nif (!uap)\r\nreturn -ENODEV;\r\npinctrl_pm_select_default_state(uap->port.dev);\r\nret = clk_prepare(uap->clk);\r\nif (ret)\r\nreturn ret;\r\nif (dev_get_platdata(uap->port.dev)) {\r\nstruct amba_pl011_data *plat;\r\nplat = dev_get_platdata(uap->port.dev);\r\nif (plat->init)\r\nplat->init();\r\n}\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nif (uap->vendor->fixed_options) {\r\nbaud = uap->fixed_baud;\r\n} else {\r\nif (options)\r\nuart_parse_options(options,\r\n&baud, &parity, &bits, &flow);\r\nelse\r\npl011_console_get_options(uap, &baud, &parity, &bits);\r\n}\r\nreturn uart_set_options(&uap->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void pl011_putc(struct uart_port *port, int c)\r\n{\r\nwhile (readl(port->membase + UART01x_FR) & UART01x_FR_TXFF)\r\n;\r\nwriteb(c, port->membase + UART01x_DR);\r\nwhile (readl(port->membase + UART01x_FR) & UART01x_FR_BUSY)\r\n;\r\n}\r\nstatic void pl011_early_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, pl011_putc);\r\n}\r\nstatic int __init pl011_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = pl011_early_write;\r\nreturn 0;\r\n}\r\nstatic int pl011_probe_dt_alias(int index, struct device *dev)\r\n{\r\nstruct device_node *np;\r\nstatic bool seen_dev_with_alias = false;\r\nstatic bool seen_dev_without_alias = false;\r\nint ret = index;\r\nif (!IS_ENABLED(CONFIG_OF))\r\nreturn ret;\r\nnp = dev->of_node;\r\nif (!np)\r\nreturn ret;\r\nret = of_alias_get_id(np, "serial");\r\nif (IS_ERR_VALUE(ret)) {\r\nseen_dev_without_alias = true;\r\nret = index;\r\n} else {\r\nseen_dev_with_alias = true;\r\nif (ret >= ARRAY_SIZE(amba_ports) || amba_ports[ret] != NULL) {\r\ndev_warn(dev, "requested serial port %d not available.\n", ret);\r\nret = index;\r\n}\r\n}\r\nif (seen_dev_with_alias && seen_dev_without_alias)\r\ndev_warn(dev, "aliased and non-aliased serial devices found in device tree. Serial port enumeration may be unpredictable.\n");\r\nreturn ret;\r\n}\r\nstatic void pl011_unregister_port(struct uart_amba_port *uap)\r\n{\r\nint i;\r\nbool busy = false;\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++) {\r\nif (amba_ports[i] == uap)\r\namba_ports[i] = NULL;\r\nelse if (amba_ports[i])\r\nbusy = true;\r\n}\r\npl011_dma_remove(uap);\r\nif (!busy)\r\nuart_unregister_driver(&amba_reg);\r\n}\r\nstatic int pl011_find_free_port(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\r\nif (amba_ports[i] == NULL)\r\nreturn i;\r\nreturn -EBUSY;\r\n}\r\nstatic int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,\r\nstruct resource *mmiobase, int index)\r\n{\r\nvoid __iomem *base;\r\nbase = devm_ioremap_resource(dev, mmiobase);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nindex = pl011_probe_dt_alias(index, dev);\r\nuap->old_cr = 0;\r\nuap->port.dev = dev;\r\nuap->port.mapbase = mmiobase->start;\r\nuap->port.membase = base;\r\nuap->port.iotype = UPIO_MEM;\r\nuap->port.fifosize = uap->fifosize;\r\nuap->port.flags = UPF_BOOT_AUTOCONF;\r\nuap->port.line = index;\r\namba_ports[index] = uap;\r\nreturn 0;\r\n}\r\nstatic int pl011_register_port(struct uart_amba_port *uap)\r\n{\r\nint ret;\r\nwritew(0, uap->port.membase + UART011_IMSC);\r\nwritew(0xffff, uap->port.membase + UART011_ICR);\r\nif (!amba_reg.state) {\r\nret = uart_register_driver(&amba_reg);\r\nif (ret < 0) {\r\ndev_err(uap->port.dev,\r\n"Failed to register AMBA-PL011 driver\n");\r\nreturn ret;\r\n}\r\n}\r\nret = uart_add_one_port(&amba_reg, &uap->port);\r\nif (ret)\r\npl011_unregister_port(uap);\r\nreturn ret;\r\n}\r\nstatic int pl011_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct uart_amba_port *uap;\r\nstruct vendor_data *vendor = id->data;\r\nint portnr, ret;\r\nportnr = pl011_find_free_port();\r\nif (portnr < 0)\r\nreturn portnr;\r\nuap = devm_kzalloc(&dev->dev, sizeof(struct uart_amba_port),\r\nGFP_KERNEL);\r\nif (!uap)\r\nreturn -ENOMEM;\r\nuap->clk = devm_clk_get(&dev->dev, NULL);\r\nif (IS_ERR(uap->clk))\r\nreturn PTR_ERR(uap->clk);\r\nuap->vendor = vendor;\r\nuap->lcrh_rx = vendor->lcrh_rx;\r\nuap->lcrh_tx = vendor->lcrh_tx;\r\nuap->fifosize = vendor->get_fifosize(dev);\r\nuap->port.irq = dev->irq[0];\r\nuap->port.ops = &amba_pl011_pops;\r\nsnprintf(uap->type, sizeof(uap->type), "PL011 rev%u", amba_rev(dev));\r\nret = pl011_setup_port(&dev->dev, uap, &dev->res, portnr);\r\nif (ret)\r\nreturn ret;\r\namba_set_drvdata(dev, uap);\r\nreturn pl011_register_port(uap);\r\n}\r\nstatic int pl011_remove(struct amba_device *dev)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nuart_remove_one_port(&amba_reg, &uap->port);\r\npl011_unregister_port(uap);\r\nreturn 0;\r\n}\r\nstatic int pl011_suspend(struct device *dev)\r\n{\r\nstruct uart_amba_port *uap = dev_get_drvdata(dev);\r\nif (!uap)\r\nreturn -EINVAL;\r\nreturn uart_suspend_port(&amba_reg, &uap->port);\r\n}\r\nstatic int pl011_resume(struct device *dev)\r\n{\r\nstruct uart_amba_port *uap = dev_get_drvdata(dev);\r\nif (!uap)\r\nreturn -EINVAL;\r\nreturn uart_resume_port(&amba_reg, &uap->port);\r\n}\r\nstatic int sbsa_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_amba_port *uap;\r\nstruct resource *r;\r\nint portnr, ret;\r\nint baudrate;\r\nif (pdev->dev.of_node) {\r\nstruct device_node *np = pdev->dev.of_node;\r\nret = of_property_read_u32(np, "current-speed", &baudrate);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nbaudrate = 115200;\r\n}\r\nportnr = pl011_find_free_port();\r\nif (portnr < 0)\r\nreturn portnr;\r\nuap = devm_kzalloc(&pdev->dev, sizeof(struct uart_amba_port),\r\nGFP_KERNEL);\r\nif (!uap)\r\nreturn -ENOMEM;\r\nuap->vendor = &vendor_sbsa;\r\nuap->fifosize = 32;\r\nuap->port.irq = platform_get_irq(pdev, 0);\r\nuap->port.ops = &sbsa_uart_pops;\r\nuap->fixed_baud = baudrate;\r\nsnprintf(uap->type, sizeof(uap->type), "SBSA");\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nret = pl011_setup_port(&pdev->dev, uap, r, portnr);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, uap);\r\nreturn pl011_register_port(uap);\r\n}\r\nstatic int sbsa_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_amba_port *uap = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&amba_reg, &uap->port);\r\npl011_unregister_port(uap);\r\nreturn 0;\r\n}\r\nstatic int __init pl011_init(void)\r\n{\r\nprintk(KERN_INFO "Serial: AMBA PL011 UART driver\n");\r\nif (platform_driver_register(&arm_sbsa_uart_platform_driver))\r\npr_warn("could not register SBSA UART platform driver\n");\r\nreturn amba_driver_register(&pl011_driver);\r\n}\r\nstatic void __exit pl011_exit(void)\r\n{\r\nplatform_driver_unregister(&arm_sbsa_uart_platform_driver);\r\namba_driver_unregister(&pl011_driver);\r\n}
