static inline struct mic_device *scdev_to_mdev(struct scif_hw_dev *scdev)\r\n{\r\nreturn dev_get_drvdata(scdev->dev.parent);\r\n}\r\nstatic void *__mic_dma_alloc(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t gfp,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\ndma_addr_t tmp;\r\nvoid *va = kmalloc(size, gfp);\r\nif (va) {\r\ntmp = mic_map_single(mdev, va, size);\r\nif (dma_mapping_error(dev, tmp)) {\r\nkfree(va);\r\nva = NULL;\r\n} else {\r\n*dma_handle = tmp;\r\n}\r\n}\r\nreturn va;\r\n}\r\nstatic void __mic_dma_free(struct device *dev, size_t size, void *vaddr,\r\ndma_addr_t dma_handle, struct dma_attrs *attrs)\r\n{\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nmic_unmap_single(mdev, dma_handle, size);\r\nkfree(vaddr);\r\n}\r\nstatic dma_addr_t\r\n__mic_dma_map_page(struct device *dev, struct page *page, unsigned long offset,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *va = phys_to_virt(page_to_phys(page)) + offset;\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nreturn mic_map_single(mdev, va, size);\r\n}\r\nstatic void\r\n__mic_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nmic_unmap_single(mdev, dma_addr, size);\r\n}\r\nstatic int __mic_dma_map_sg(struct device *dev, struct scatterlist *sg,\r\nint nents, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nstruct scatterlist *s;\r\nint i, j, ret;\r\ndma_addr_t da;\r\nret = dma_map_sg(mdev->sdev->parent, sg, nents, dir);\r\nif (ret <= 0)\r\nreturn 0;\r\nfor_each_sg(sg, s, nents, i) {\r\nda = mic_map(mdev, sg_dma_address(s) + s->offset, s->length);\r\nif (!da)\r\ngoto err;\r\nsg_dma_address(s) = da;\r\n}\r\nreturn nents;\r\nerr:\r\nfor_each_sg(sg, s, i, j) {\r\nmic_unmap(mdev, sg_dma_address(s), s->length);\r\nsg_dma_address(s) = mic_to_dma_addr(mdev, sg_dma_address(s));\r\n}\r\ndma_unmap_sg(mdev->sdev->parent, sg, nents, dir);\r\nreturn 0;\r\n}\r\nstatic void __mic_dma_unmap_sg(struct device *dev,\r\nstruct scatterlist *sg, int nents,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scif_hw_dev *scdev = dev_get_drvdata(dev);\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nstruct scatterlist *s;\r\ndma_addr_t da;\r\nint i;\r\nfor_each_sg(sg, s, nents, i) {\r\nda = mic_to_dma_addr(mdev, sg_dma_address(s));\r\nmic_unmap(mdev, sg_dma_address(s), s->length);\r\nsg_dma_address(s) = da;\r\n}\r\ndma_unmap_sg(mdev->sdev->parent, sg, nents, dir);\r\n}\r\nstatic struct mic_irq *\r\n___mic_request_irq(struct scif_hw_dev *scdev,\r\nirqreturn_t (*func)(int irq, void *data),\r\nconst char *name,\r\nvoid *data, int db)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nreturn mic_request_threaded_irq(mdev, func, NULL, name, data,\r\ndb, MIC_INTR_DB);\r\n}\r\nstatic void\r\n___mic_free_irq(struct scif_hw_dev *scdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nreturn mic_free_irq(mdev, cookie, data);\r\n}\r\nstatic void ___mic_ack_interrupt(struct scif_hw_dev *scdev, int num)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nmdev->ops->intr_workarounds(mdev);\r\n}\r\nstatic int ___mic_next_db(struct scif_hw_dev *scdev)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nreturn mic_next_db(mdev);\r\n}\r\nstatic void ___mic_send_intr(struct scif_hw_dev *scdev, int db)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nmdev->ops->send_intr(mdev, db);\r\n}\r\nstatic void __iomem *___mic_ioremap(struct scif_hw_dev *scdev,\r\nphys_addr_t pa, size_t len)\r\n{\r\nstruct mic_device *mdev = scdev_to_mdev(scdev);\r\nreturn mdev->aper.va + pa;\r\n}\r\nstatic void ___mic_iounmap(struct scif_hw_dev *scdev, void __iomem *va)\r\n{\r\n}\r\nstatic inline struct mic_device *mbdev_to_mdev(struct mbus_device *mbdev)\r\n{\r\nreturn dev_get_drvdata(mbdev->dev.parent);\r\n}\r\nstatic dma_addr_t\r\nmic_dma_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *va = phys_to_virt(page_to_phys(page)) + offset;\r\nstruct mic_device *mdev = dev_get_drvdata(dev->parent);\r\nreturn mic_map_single(mdev, va, size);\r\n}\r\nstatic void\r\nmic_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct mic_device *mdev = dev_get_drvdata(dev->parent);\r\nmic_unmap_single(mdev, dma_addr, size);\r\n}\r\nstatic struct mic_irq *\r\n_mic_request_threaded_irq(struct mbus_device *mbdev,\r\nirq_handler_t handler, irq_handler_t thread_fn,\r\nconst char *name, void *data, int intr_src)\r\n{\r\nreturn mic_request_threaded_irq(mbdev_to_mdev(mbdev), handler,\r\nthread_fn, name, data,\r\nintr_src, MIC_INTR_DMA);\r\n}\r\nstatic void _mic_free_irq(struct mbus_device *mbdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nreturn mic_free_irq(mbdev_to_mdev(mbdev), cookie, data);\r\n}\r\nstatic void _mic_ack_interrupt(struct mbus_device *mbdev, int num)\r\n{\r\nstruct mic_device *mdev = mbdev_to_mdev(mbdev);\r\nmdev->ops->intr_workarounds(mdev);\r\n}\r\nstatic void mic_reset(struct mic_device *mdev)\r\n{\r\nint i;\r\n#define MIC_RESET_TO (45)\r\nreinit_completion(&mdev->reset_wait);\r\nmdev->ops->reset_fw_ready(mdev);\r\nmdev->ops->reset(mdev);\r\nfor (i = 0; i < MIC_RESET_TO; i++) {\r\nif (mdev->ops->is_fw_ready(mdev))\r\ngoto done;\r\nmsleep(1000);\r\n}\r\nmic_set_state(mdev, MIC_RESET_FAILED);\r\ndone:\r\ncomplete_all(&mdev->reset_wait);\r\n}\r\nvoid mic_bootparam_init(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\nbootparam->magic = cpu_to_le32(MIC_MAGIC);\r\nbootparam->c2h_shutdown_db = mdev->shutdown_db;\r\nbootparam->h2c_shutdown_db = -1;\r\nbootparam->h2c_config_db = -1;\r\nbootparam->shutdown_status = 0;\r\nbootparam->shutdown_card = 0;\r\nbootparam->tot_nodes = atomic_read(&g_num_mics) + 1;\r\nbootparam->node_id = mdev->id + 1;\r\nbootparam->scif_host_dma_addr = 0x0;\r\nbootparam->scif_card_dma_addr = 0x0;\r\nbootparam->c2h_scif_db = -1;\r\nbootparam->h2c_scif_db = -1;\r\n}\r\nstatic int mic_request_dma_chans(struct mic_device *mdev)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nrequest_module("mic_x100_dma");\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\ndo {\r\nchan = dma_request_channel(mask, mdev->ops->dma_filter,\r\nmdev->sdev->parent);\r\nif (chan) {\r\nmdev->dma_ch[mdev->num_dma_ch++] = chan;\r\nif (mdev->num_dma_ch >= MIC_MAX_DMA_CHAN)\r\nbreak;\r\n}\r\n} while (chan);\r\ndev_info(mdev->sdev->parent, "DMA channels # %d\n", mdev->num_dma_ch);\r\nreturn mdev->num_dma_ch;\r\n}\r\nstatic void mic_free_dma_chans(struct mic_device *mdev)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < mdev->num_dma_ch; i++) {\r\ndma_release_channel(mdev->dma_ch[i]);\r\nmdev->dma_ch[i] = NULL;\r\n}\r\nmdev->num_dma_ch = 0;\r\n}\r\nint mic_start(struct mic_device *mdev, const char *buf)\r\n{\r\nint rc;\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_bootparam_init(mdev);\r\nretry:\r\nif (MIC_OFFLINE != mdev->state) {\r\nrc = -EINVAL;\r\ngoto unlock_ret;\r\n}\r\nif (!mdev->ops->is_fw_ready(mdev)) {\r\nmic_reset(mdev);\r\ngoto retry;\r\n}\r\nmdev->dma_mbdev = mbus_register_device(mdev->sdev->parent,\r\nMBUS_DEV_DMA_HOST, &mic_dma_ops,\r\n&mbus_hw_ops, mdev->mmio.va);\r\nif (IS_ERR(mdev->dma_mbdev)) {\r\nrc = PTR_ERR(mdev->dma_mbdev);\r\ngoto unlock_ret;\r\n}\r\nif (!mic_request_dma_chans(mdev)) {\r\nrc = -ENODEV;\r\ngoto dma_remove;\r\n}\r\nmdev->scdev = scif_register_device(mdev->sdev->parent, MIC_SCIF_DEV,\r\n&__mic_dma_ops, &scif_hw_ops,\r\nmdev->id + 1, 0, &mdev->mmio,\r\n&mdev->aper, mdev->dp, NULL,\r\nmdev->dma_ch, mdev->num_dma_ch);\r\nif (IS_ERR(mdev->scdev)) {\r\nrc = PTR_ERR(mdev->scdev);\r\ngoto dma_free;\r\n}\r\nrc = mdev->ops->load_mic_fw(mdev, buf);\r\nif (rc)\r\ngoto scif_remove;\r\nmic_smpt_restore(mdev);\r\nmic_intr_restore(mdev);\r\nmdev->intr_ops->enable_interrupts(mdev);\r\nmdev->ops->write_spad(mdev, MIC_DPLO_SPAD, mdev->dp_dma_addr);\r\nmdev->ops->write_spad(mdev, MIC_DPHI_SPAD, mdev->dp_dma_addr >> 32);\r\nmdev->ops->send_firmware_intr(mdev);\r\nmic_set_state(mdev, MIC_ONLINE);\r\ngoto unlock_ret;\r\nscif_remove:\r\nscif_unregister_device(mdev->scdev);\r\ndma_free:\r\nmic_free_dma_chans(mdev);\r\ndma_remove:\r\nmbus_unregister_device(mdev->dma_mbdev);\r\nunlock_ret:\r\nmutex_unlock(&mdev->mic_mutex);\r\nreturn rc;\r\n}\r\nvoid mic_stop(struct mic_device *mdev, bool force)\r\n{\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_OFFLINE != mdev->state || force) {\r\nscif_unregister_device(mdev->scdev);\r\nmic_virtio_reset_devices(mdev);\r\nmic_free_dma_chans(mdev);\r\nmbus_unregister_device(mdev->dma_mbdev);\r\nmic_bootparam_init(mdev);\r\nmic_reset(mdev);\r\nif (MIC_RESET_FAILED == mdev->state)\r\ngoto unlock;\r\nmic_set_shutdown_status(mdev, MIC_NOP);\r\nif (MIC_SUSPENDED != mdev->state)\r\nmic_set_state(mdev, MIC_OFFLINE);\r\n}\r\nunlock:\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_shutdown(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\ns8 db = bootparam->h2c_shutdown_db;\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_ONLINE == mdev->state && db != -1) {\r\nbootparam->shutdown_card = 1;\r\nmdev->ops->send_intr(mdev, db);\r\nmic_set_state(mdev, MIC_SHUTTING_DOWN);\r\n}\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_shutdown_work(struct work_struct *work)\r\n{\r\nstruct mic_device *mdev = container_of(work, struct mic_device,\r\nshutdown_work);\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_shutdown_status(mdev, bootparam->shutdown_status);\r\nbootparam->shutdown_status = 0;\r\nif (MIC_SHUTTING_DOWN != mdev->state &&\r\nMIC_SUSPENDED != mdev->state)\r\nmic_set_state(mdev, MIC_SHUTTING_DOWN);\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_reset_trigger_work(struct work_struct *work)\r\n{\r\nstruct mic_device *mdev = container_of(work, struct mic_device,\r\nreset_trigger_work);\r\nmic_stop(mdev, false);\r\n}\r\nvoid mic_complete_resume(struct mic_device *mdev)\r\n{\r\nif (mdev->state != MIC_SUSPENDED) {\r\ndev_warn(mdev->sdev->parent, "state %d should be %d\n",\r\nmdev->state, MIC_SUSPENDED);\r\nreturn;\r\n}\r\nif (!mdev->ops->is_fw_ready(mdev))\r\nmic_stop(mdev, true);\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_state(mdev, MIC_OFFLINE);\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_prepare_suspend(struct mic_device *mdev)\r\n{\r\nunsigned long timeout;\r\n#define MIC_SUSPEND_TIMEOUT (60 * HZ)\r\nmutex_lock(&mdev->mic_mutex);\r\nswitch (mdev->state) {\r\ncase MIC_OFFLINE:\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\nbreak;\r\ncase MIC_ONLINE:\r\nmic_set_state(mdev, MIC_SUSPENDING);\r\nmutex_unlock(&mdev->mic_mutex);\r\ntimeout = wait_for_completion_timeout(&mdev->reset_wait,\r\nMIC_SUSPEND_TIMEOUT);\r\nif (!timeout) {\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\nmic_stop(mdev, true);\r\n}\r\nbreak;\r\ncase MIC_SHUTTING_DOWN:\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\ntimeout = wait_for_completion_timeout(&mdev->reset_wait,\r\nMIC_SUSPEND_TIMEOUT);\r\nif (!timeout)\r\nmic_stop(mdev, true);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&mdev->mic_mutex);\r\nbreak;\r\n}\r\n}\r\nvoid mic_suspend(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\ns8 db = bootparam->h2c_shutdown_db;\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_SUSPENDING == mdev->state && db != -1) {\r\nbootparam->shutdown_card = 1;\r\nmdev->ops->send_intr(mdev, db);\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\n}\r\nmutex_unlock(&mdev->mic_mutex);\r\n}
