int\r\ne820_any_mapped(u64 start, u64 end, unsigned type)\r\n{\r\nint i;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nif (type && ei->type != type)\r\ncontinue;\r\nif (ei->addr >= end || ei->addr + ei->size <= start)\r\ncontinue;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint __init e820_all_mapped(u64 start, u64 end, unsigned type)\r\n{\r\nint i;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nif (type && ei->type != type)\r\ncontinue;\r\nif (ei->addr >= end || ei->addr + ei->size <= start)\r\ncontinue;\r\nif (ei->addr <= start)\r\nstart = ei->addr + ei->size;\r\nif (start >= end)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,\r\nint type)\r\n{\r\nint x = e820x->nr_map;\r\nif (x >= ARRAY_SIZE(e820x->map)) {\r\nprintk(KERN_ERR "e820: too many entries; ignoring [mem %#010llx-%#010llx]\n",\r\n(unsigned long long) start,\r\n(unsigned long long) (start + size - 1));\r\nreturn;\r\n}\r\ne820x->map[x].addr = start;\r\ne820x->map[x].size = size;\r\ne820x->map[x].type = type;\r\ne820x->nr_map++;\r\n}\r\nvoid __init e820_add_region(u64 start, u64 size, int type)\r\n{\r\n__e820_add_region(&e820, start, size, type);\r\n}\r\nstatic void __init e820_print_type(u32 type)\r\n{\r\nswitch (type) {\r\ncase E820_RAM:\r\ncase E820_RESERVED_KERN:\r\nprintk(KERN_CONT "usable");\r\nbreak;\r\ncase E820_RESERVED:\r\nprintk(KERN_CONT "reserved");\r\nbreak;\r\ncase E820_ACPI:\r\nprintk(KERN_CONT "ACPI data");\r\nbreak;\r\ncase E820_NVS:\r\nprintk(KERN_CONT "ACPI NVS");\r\nbreak;\r\ncase E820_UNUSABLE:\r\nprintk(KERN_CONT "unusable");\r\nbreak;\r\ncase E820_PMEM:\r\ncase E820_PRAM:\r\nprintk(KERN_CONT "persistent (type %u)", type);\r\nbreak;\r\ndefault:\r\nprintk(KERN_CONT "type %u", type);\r\nbreak;\r\n}\r\n}\r\nvoid __init e820_print_map(char *who)\r\n{\r\nint i;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nprintk(KERN_INFO "%s: [mem %#018Lx-%#018Lx] ", who,\r\n(unsigned long long) e820.map[i].addr,\r\n(unsigned long long)\r\n(e820.map[i].addr + e820.map[i].size - 1));\r\ne820_print_type(e820.map[i].type);\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\nstatic int __init cpcompare(const void *a, const void *b)\r\n{\r\nstruct change_member * const *app = a, * const *bpp = b;\r\nconst struct change_member *ap = *app, *bp = *bpp;\r\nif (ap->addr != bp->addr)\r\nreturn ap->addr > bp->addr ? 1 : -1;\r\nreturn (ap->addr != ap->pbios->addr) - (bp->addr != bp->pbios->addr);\r\n}\r\nint __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,\r\nu32 *pnr_map)\r\n{\r\nstatic struct change_member change_point_list[2*E820_X_MAX] __initdata;\r\nstatic struct change_member *change_point[2*E820_X_MAX] __initdata;\r\nstatic struct e820entry *overlap_list[E820_X_MAX] __initdata;\r\nstatic struct e820entry new_bios[E820_X_MAX] __initdata;\r\nunsigned long current_type, last_type;\r\nunsigned long long last_addr;\r\nint chgidx;\r\nint overlap_entries;\r\nint new_bios_entry;\r\nint old_nr, new_nr, chg_nr;\r\nint i;\r\nif (*pnr_map < 2)\r\nreturn -1;\r\nold_nr = *pnr_map;\r\nBUG_ON(old_nr > max_nr_map);\r\nfor (i = 0; i < old_nr; i++)\r\nif (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)\r\nreturn -1;\r\nfor (i = 0; i < 2 * old_nr; i++)\r\nchange_point[i] = &change_point_list[i];\r\nchgidx = 0;\r\nfor (i = 0; i < old_nr; i++) {\r\nif (biosmap[i].size != 0) {\r\nchange_point[chgidx]->addr = biosmap[i].addr;\r\nchange_point[chgidx++]->pbios = &biosmap[i];\r\nchange_point[chgidx]->addr = biosmap[i].addr +\r\nbiosmap[i].size;\r\nchange_point[chgidx++]->pbios = &biosmap[i];\r\n}\r\n}\r\nchg_nr = chgidx;\r\nsort(change_point, chg_nr, sizeof *change_point, cpcompare, NULL);\r\noverlap_entries = 0;\r\nnew_bios_entry = 0;\r\nlast_type = 0;\r\nlast_addr = 0;\r\nfor (chgidx = 0; chgidx < chg_nr; chgidx++) {\r\nif (change_point[chgidx]->addr ==\r\nchange_point[chgidx]->pbios->addr) {\r\noverlap_list[overlap_entries++] =\r\nchange_point[chgidx]->pbios;\r\n} else {\r\nfor (i = 0; i < overlap_entries; i++) {\r\nif (overlap_list[i] ==\r\nchange_point[chgidx]->pbios)\r\noverlap_list[i] =\r\noverlap_list[overlap_entries-1];\r\n}\r\noverlap_entries--;\r\n}\r\ncurrent_type = 0;\r\nfor (i = 0; i < overlap_entries; i++)\r\nif (overlap_list[i]->type > current_type)\r\ncurrent_type = overlap_list[i]->type;\r\nif (current_type != last_type || current_type == E820_PRAM) {\r\nif (last_type != 0) {\r\nnew_bios[new_bios_entry].size =\r\nchange_point[chgidx]->addr - last_addr;\r\nif (new_bios[new_bios_entry].size != 0)\r\nif (++new_bios_entry >= max_nr_map)\r\nbreak;\r\n}\r\nif (current_type != 0) {\r\nnew_bios[new_bios_entry].addr =\r\nchange_point[chgidx]->addr;\r\nnew_bios[new_bios_entry].type = current_type;\r\nlast_addr = change_point[chgidx]->addr;\r\n}\r\nlast_type = current_type;\r\n}\r\n}\r\nnew_nr = new_bios_entry;\r\nmemcpy(biosmap, new_bios, new_nr * sizeof(struct e820entry));\r\n*pnr_map = new_nr;\r\nreturn 0;\r\n}\r\nstatic int __init __append_e820_map(struct e820entry *biosmap, int nr_map)\r\n{\r\nwhile (nr_map) {\r\nu64 start = biosmap->addr;\r\nu64 size = biosmap->size;\r\nu64 end = start + size;\r\nu32 type = biosmap->type;\r\nif (start > end)\r\nreturn -1;\r\ne820_add_region(start, size, type);\r\nbiosmap++;\r\nnr_map--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init append_e820_map(struct e820entry *biosmap, int nr_map)\r\n{\r\nif (nr_map < 2)\r\nreturn -1;\r\nreturn __append_e820_map(biosmap, nr_map);\r\n}\r\nstatic u64 __init __e820_update_range(struct e820map *e820x, u64 start,\r\nu64 size, unsigned old_type,\r\nunsigned new_type)\r\n{\r\nu64 end;\r\nunsigned int i;\r\nu64 real_updated_size = 0;\r\nBUG_ON(old_type == new_type);\r\nif (size > (ULLONG_MAX - start))\r\nsize = ULLONG_MAX - start;\r\nend = start + size;\r\nprintk(KERN_DEBUG "e820: update [mem %#010Lx-%#010Lx] ",\r\n(unsigned long long) start, (unsigned long long) (end - 1));\r\ne820_print_type(old_type);\r\nprintk(KERN_CONT " ==> ");\r\ne820_print_type(new_type);\r\nprintk(KERN_CONT "\n");\r\nfor (i = 0; i < e820x->nr_map; i++) {\r\nstruct e820entry *ei = &e820x->map[i];\r\nu64 final_start, final_end;\r\nu64 ei_end;\r\nif (ei->type != old_type)\r\ncontinue;\r\nei_end = ei->addr + ei->size;\r\nif (ei->addr >= start && ei_end <= end) {\r\nei->type = new_type;\r\nreal_updated_size += ei->size;\r\ncontinue;\r\n}\r\nif (ei->addr < start && ei_end > end) {\r\n__e820_add_region(e820x, start, size, new_type);\r\n__e820_add_region(e820x, end, ei_end - end, ei->type);\r\nei->size = start - ei->addr;\r\nreal_updated_size += size;\r\ncontinue;\r\n}\r\nfinal_start = max(start, ei->addr);\r\nfinal_end = min(end, ei_end);\r\nif (final_start >= final_end)\r\ncontinue;\r\n__e820_add_region(e820x, final_start, final_end - final_start,\r\nnew_type);\r\nreal_updated_size += final_end - final_start;\r\nei->size -= final_end - final_start;\r\nif (ei->addr < final_start)\r\ncontinue;\r\nei->addr = final_end;\r\n}\r\nreturn real_updated_size;\r\n}\r\nu64 __init e820_update_range(u64 start, u64 size, unsigned old_type,\r\nunsigned new_type)\r\n{\r\nreturn __e820_update_range(&e820, start, size, old_type, new_type);\r\n}\r\nstatic u64 __init e820_update_range_saved(u64 start, u64 size,\r\nunsigned old_type, unsigned new_type)\r\n{\r\nreturn __e820_update_range(&e820_saved, start, size, old_type,\r\nnew_type);\r\n}\r\nu64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,\r\nint checktype)\r\n{\r\nint i;\r\nu64 end;\r\nu64 real_removed_size = 0;\r\nif (size > (ULLONG_MAX - start))\r\nsize = ULLONG_MAX - start;\r\nend = start + size;\r\nprintk(KERN_DEBUG "e820: remove [mem %#010Lx-%#010Lx] ",\r\n(unsigned long long) start, (unsigned long long) (end - 1));\r\nif (checktype)\r\ne820_print_type(old_type);\r\nprintk(KERN_CONT "\n");\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nu64 final_start, final_end;\r\nu64 ei_end;\r\nif (checktype && ei->type != old_type)\r\ncontinue;\r\nei_end = ei->addr + ei->size;\r\nif (ei->addr >= start && ei_end <= end) {\r\nreal_removed_size += ei->size;\r\nmemset(ei, 0, sizeof(struct e820entry));\r\ncontinue;\r\n}\r\nif (ei->addr < start && ei_end > end) {\r\ne820_add_region(end, ei_end - end, ei->type);\r\nei->size = start - ei->addr;\r\nreal_removed_size += size;\r\ncontinue;\r\n}\r\nfinal_start = max(start, ei->addr);\r\nfinal_end = min(end, ei_end);\r\nif (final_start >= final_end)\r\ncontinue;\r\nreal_removed_size += final_end - final_start;\r\nei->size -= final_end - final_start;\r\nif (ei->addr < final_start)\r\ncontinue;\r\nei->addr = final_end;\r\n}\r\nreturn real_removed_size;\r\n}\r\nvoid __init update_e820(void)\r\n{\r\nif (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map))\r\nreturn;\r\nprintk(KERN_INFO "e820: modified physical RAM map:\n");\r\ne820_print_map("modified");\r\n}\r\nstatic void __init update_e820_saved(void)\r\n{\r\nsanitize_e820_map(e820_saved.map, ARRAY_SIZE(e820_saved.map),\r\n&e820_saved.nr_map);\r\n}\r\n__init int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,\r\nunsigned long start_addr, unsigned long long end_addr)\r\n{\r\nunsigned long long last;\r\nint i = e820.nr_map;\r\nint found = 0;\r\nlast = (end_addr && end_addr < MAX_GAP_END) ? end_addr : MAX_GAP_END;\r\nwhile (--i >= 0) {\r\nunsigned long long start = e820.map[i].addr;\r\nunsigned long long end = start + e820.map[i].size;\r\nif (end < start_addr)\r\ncontinue;\r\nif (last > end) {\r\nunsigned long gap = last - end;\r\nif (gap >= *gapsize) {\r\n*gapsize = gap;\r\n*gapstart = end;\r\nfound = 1;\r\n}\r\n}\r\nif (start < last)\r\nlast = start;\r\n}\r\nreturn found;\r\n}\r\n__init void e820_setup_gap(void)\r\n{\r\nunsigned long gapstart, gapsize;\r\nint found;\r\ngapstart = 0x10000000;\r\ngapsize = 0x400000;\r\nfound = e820_search_gap(&gapstart, &gapsize, 0, MAX_GAP_END);\r\n#ifdef CONFIG_X86_64\r\nif (!found) {\r\ngapstart = (max_pfn << PAGE_SHIFT) + 1024*1024;\r\nprintk(KERN_ERR\r\n"e820: cannot find a gap in the 32bit address range\n"\r\n"e820: PCI devices with unassigned 32bit BARs may break!\n");\r\n}\r\n#endif\r\npci_mem_start = gapstart;\r\nprintk(KERN_INFO\r\n"e820: [mem %#010lx-%#010lx] available for PCI devices\n",\r\ngapstart, gapstart + gapsize - 1);\r\n}\r\nvoid __init parse_e820_ext(u64 phys_addr, u32 data_len)\r\n{\r\nint entries;\r\nstruct e820entry *extmap;\r\nstruct setup_data *sdata;\r\nsdata = early_memremap(phys_addr, data_len);\r\nentries = sdata->len / sizeof(struct e820entry);\r\nextmap = (struct e820entry *)(sdata->data);\r\n__append_e820_map(extmap, entries);\r\nsanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);\r\nearly_memunmap(sdata, data_len);\r\nprintk(KERN_INFO "e820: extended physical RAM map:\n");\r\ne820_print_map("extended");\r\n}\r\nvoid __init e820_mark_nosave_regions(unsigned long limit_pfn)\r\n{\r\nint i;\r\nunsigned long pfn = 0;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nif (pfn < PFN_UP(ei->addr))\r\nregister_nosave_region(pfn, PFN_UP(ei->addr));\r\npfn = PFN_DOWN(ei->addr + ei->size);\r\nif (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)\r\nregister_nosave_region(PFN_UP(ei->addr), pfn);\r\nif (pfn >= limit_pfn)\r\nbreak;\r\n}\r\n}\r\nstatic int __init e820_mark_nvs_memory(void)\r\n{\r\nint i;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nif (ei->type == E820_NVS)\r\nacpi_nvs_register(ei->addr, ei->size);\r\n}\r\nreturn 0;\r\n}\r\nu64 __init early_reserve_e820(u64 size, u64 align)\r\n{\r\nu64 addr;\r\naddr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\r\nif (addr) {\r\ne820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);\r\nprintk(KERN_INFO "e820: update e820_saved for early_reserve_e820\n");\r\nupdate_e820_saved();\r\n}\r\nreturn addr;\r\n}\r\nstatic unsigned long __init e820_end_pfn(unsigned long limit_pfn)\r\n{\r\nint i;\r\nunsigned long last_pfn = 0;\r\nunsigned long max_arch_pfn = MAX_ARCH_PFN;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nunsigned long start_pfn;\r\nunsigned long end_pfn;\r\nif (ei->type != E820_RAM && ei->type != E820_PRAM)\r\ncontinue;\r\nstart_pfn = ei->addr >> PAGE_SHIFT;\r\nend_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;\r\nif (start_pfn >= limit_pfn)\r\ncontinue;\r\nif (end_pfn > limit_pfn) {\r\nlast_pfn = limit_pfn;\r\nbreak;\r\n}\r\nif (end_pfn > last_pfn)\r\nlast_pfn = end_pfn;\r\n}\r\nif (last_pfn > max_arch_pfn)\r\nlast_pfn = max_arch_pfn;\r\nprintk(KERN_INFO "e820: last_pfn = %#lx max_arch_pfn = %#lx\n",\r\nlast_pfn, max_arch_pfn);\r\nreturn last_pfn;\r\n}\r\nunsigned long __init e820_end_of_ram_pfn(void)\r\n{\r\nreturn e820_end_pfn(MAX_ARCH_PFN);\r\n}\r\nunsigned long __init e820_end_of_low_ram_pfn(void)\r\n{\r\nreturn e820_end_pfn(1UL << (32-PAGE_SHIFT));\r\n}\r\nstatic void early_panic(char *msg)\r\n{\r\nearly_printk(msg);\r\npanic(msg);\r\n}\r\nstatic int __init parse_memopt(char *p)\r\n{\r\nu64 mem_size;\r\nif (!p)\r\nreturn -EINVAL;\r\nif (!strcmp(p, "nopentium")) {\r\n#ifdef CONFIG_X86_32\r\nsetup_clear_cpu_cap(X86_FEATURE_PSE);\r\nreturn 0;\r\n#else\r\nprintk(KERN_WARNING "mem=nopentium ignored! (only supported on x86_32)\n");\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nuserdef = 1;\r\nmem_size = memparse(p, &p);\r\nif (mem_size == 0)\r\nreturn -EINVAL;\r\ne820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);\r\nreturn 0;\r\n}\r\nstatic int __init parse_memmap_one(char *p)\r\n{\r\nchar *oldp;\r\nu64 start_at, mem_size;\r\nif (!p)\r\nreturn -EINVAL;\r\nif (!strncmp(p, "exactmap", 8)) {\r\n#ifdef CONFIG_CRASH_DUMP\r\nsaved_max_pfn = e820_end_of_ram_pfn();\r\n#endif\r\ne820.nr_map = 0;\r\nuserdef = 1;\r\nreturn 0;\r\n}\r\noldp = p;\r\nmem_size = memparse(p, &p);\r\nif (p == oldp)\r\nreturn -EINVAL;\r\nuserdef = 1;\r\nif (*p == '@') {\r\nstart_at = memparse(p+1, &p);\r\ne820_add_region(start_at, mem_size, E820_RAM);\r\n} else if (*p == '#') {\r\nstart_at = memparse(p+1, &p);\r\ne820_add_region(start_at, mem_size, E820_ACPI);\r\n} else if (*p == '$') {\r\nstart_at = memparse(p+1, &p);\r\ne820_add_region(start_at, mem_size, E820_RESERVED);\r\n} else if (*p == '!') {\r\nstart_at = memparse(p+1, &p);\r\ne820_add_region(start_at, mem_size, E820_PRAM);\r\n} else\r\ne820_remove_range(mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);\r\nreturn *p == '\0' ? 0 : -EINVAL;\r\n}\r\nstatic int __init parse_memmap_opt(char *str)\r\n{\r\nwhile (str) {\r\nchar *k = strchr(str, ',');\r\nif (k)\r\n*k++ = 0;\r\nparse_memmap_one(str);\r\nstr = k;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init finish_e820_parsing(void)\r\n{\r\nif (userdef) {\r\nif (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map),\r\n&e820.nr_map) < 0)\r\nearly_panic("Invalid user supplied memory map");\r\nprintk(KERN_INFO "e820: user-defined physical RAM map:\n");\r\ne820_print_map("user");\r\n}\r\n}\r\nstatic inline const char *e820_type_to_string(int e820_type)\r\n{\r\nswitch (e820_type) {\r\ncase E820_RESERVED_KERN:\r\ncase E820_RAM: return "System RAM";\r\ncase E820_ACPI: return "ACPI Tables";\r\ncase E820_NVS: return "ACPI Non-volatile Storage";\r\ncase E820_UNUSABLE: return "Unusable memory";\r\ncase E820_PRAM: return "Persistent Memory (legacy)";\r\ncase E820_PMEM: return "Persistent Memory";\r\ndefault: return "reserved";\r\n}\r\n}\r\nstatic bool do_mark_busy(u32 type, struct resource *res)\r\n{\r\nif (res->start < (1ULL<<20))\r\nreturn true;\r\nswitch (type) {\r\ncase E820_RESERVED:\r\ncase E820_PRAM:\r\ncase E820_PMEM:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nvoid __init e820_reserve_resources(void)\r\n{\r\nint i;\r\nstruct resource *res;\r\nu64 end;\r\nres = alloc_bootmem(sizeof(struct resource) * e820.nr_map);\r\ne820_res = res;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nend = e820.map[i].addr + e820.map[i].size - 1;\r\nif (end != (resource_size_t)end) {\r\nres++;\r\ncontinue;\r\n}\r\nres->name = e820_type_to_string(e820.map[i].type);\r\nres->start = e820.map[i].addr;\r\nres->end = end;\r\nres->flags = IORESOURCE_MEM;\r\nif (do_mark_busy(e820.map[i].type, res)) {\r\nres->flags |= IORESOURCE_BUSY;\r\ninsert_resource(&iomem_resource, res);\r\n}\r\nres++;\r\n}\r\nfor (i = 0; i < e820_saved.nr_map; i++) {\r\nstruct e820entry *entry = &e820_saved.map[i];\r\nfirmware_map_add_early(entry->addr,\r\nentry->addr + entry->size,\r\ne820_type_to_string(entry->type));\r\n}\r\n}\r\nstatic unsigned long ram_alignment(resource_size_t pos)\r\n{\r\nunsigned long mb = pos >> 20;\r\nif (!mb)\r\nreturn 64*1024;\r\nif (mb < 16)\r\nreturn 1024*1024;\r\nreturn 64*1024*1024;\r\n}\r\nvoid __init e820_reserve_resources_late(void)\r\n{\r\nint i;\r\nstruct resource *res;\r\nres = e820_res;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nif (!res->parent && res->end)\r\ninsert_resource_expand_to_fit(&iomem_resource, res);\r\nres++;\r\n}\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *entry = &e820.map[i];\r\nu64 start, end;\r\nif (entry->type != E820_RAM)\r\ncontinue;\r\nstart = entry->addr + entry->size;\r\nend = round_up(start, ram_alignment(start)) - 1;\r\nif (end > MAX_RESOURCE_SIZE)\r\nend = MAX_RESOURCE_SIZE;\r\nif (start >= end)\r\ncontinue;\r\nprintk(KERN_DEBUG\r\n"e820: reserve RAM buffer [mem %#010llx-%#010llx]\n",\r\nstart, end);\r\nreserve_region_with_split(&iomem_resource, start, end,\r\n"RAM buffer");\r\n}\r\n}\r\nchar *__init default_machine_specific_memory_setup(void)\r\n{\r\nchar *who = "BIOS-e820";\r\nu32 new_nr;\r\nnew_nr = boot_params.e820_entries;\r\nsanitize_e820_map(boot_params.e820_map,\r\nARRAY_SIZE(boot_params.e820_map),\r\n&new_nr);\r\nboot_params.e820_entries = new_nr;\r\nif (append_e820_map(boot_params.e820_map, boot_params.e820_entries)\r\n< 0) {\r\nu64 mem_size;\r\nif (boot_params.alt_mem_k\r\n< boot_params.screen_info.ext_mem_k) {\r\nmem_size = boot_params.screen_info.ext_mem_k;\r\nwho = "BIOS-88";\r\n} else {\r\nmem_size = boot_params.alt_mem_k;\r\nwho = "BIOS-e801";\r\n}\r\ne820.nr_map = 0;\r\ne820_add_region(0, LOWMEMSIZE(), E820_RAM);\r\ne820_add_region(HIGH_MEMORY, mem_size << 10, E820_RAM);\r\n}\r\nreturn who;\r\n}\r\nvoid __init setup_memory_map(void)\r\n{\r\nchar *who;\r\nwho = x86_init.resources.memory_setup();\r\nmemcpy(&e820_saved, &e820, sizeof(struct e820map));\r\nprintk(KERN_INFO "e820: BIOS-provided physical RAM map:\n");\r\ne820_print_map(who);\r\n}\r\nvoid __init memblock_x86_fill(void)\r\n{\r\nint i;\r\nu64 end;\r\nmemblock_allow_resize();\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nstruct e820entry *ei = &e820.map[i];\r\nend = ei->addr + ei->size;\r\nif (end != (resource_size_t)end)\r\ncontinue;\r\nif (ei->type != E820_RAM && ei->type != E820_RESERVED_KERN)\r\ncontinue;\r\nmemblock_add(ei->addr, ei->size);\r\n}\r\nmemblock_trim_memory(PAGE_SIZE);\r\nmemblock_dump_all();\r\n}\r\nvoid __init memblock_find_dma_reserve(void)\r\n{\r\n#ifdef CONFIG_X86_64\r\nu64 nr_pages = 0, nr_free_pages = 0;\r\nunsigned long start_pfn, end_pfn;\r\nphys_addr_t start, end;\r\nint i;\r\nu64 u;\r\nfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\r\nstart_pfn = min(start_pfn, MAX_DMA_PFN);\r\nend_pfn = min(end_pfn, MAX_DMA_PFN);\r\nnr_pages += end_pfn - start_pfn;\r\n}\r\nfor_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\r\nNULL) {\r\nstart_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);\r\nend_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);\r\nif (start_pfn < end_pfn)\r\nnr_free_pages += end_pfn - start_pfn;\r\n}\r\nset_dma_reserve(nr_pages - nr_free_pages);\r\n#endif\r\n}
