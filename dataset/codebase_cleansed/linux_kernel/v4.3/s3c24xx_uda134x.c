static int s3c24xx_uda134x_startup(struct snd_pcm_substream *substream)\r\n{\r\nint ret = 0;\r\n#ifdef ENFORCE_RATES\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\n#endif\r\nmutex_lock(&clk_lock);\r\npr_debug("%s %d\n", __func__, clk_users);\r\nif (clk_users == 0) {\r\nxtal = clk_get(&s3c24xx_uda134x_snd_device->dev, "xtal");\r\nif (IS_ERR(xtal)) {\r\nprintk(KERN_ERR "%s cannot get xtal\n", __func__);\r\nret = PTR_ERR(xtal);\r\n} else {\r\npclk = clk_get(&s3c24xx_uda134x_snd_device->dev,\r\n"pclk");\r\nif (IS_ERR(pclk)) {\r\nprintk(KERN_ERR "%s cannot get pclk\n",\r\n__func__);\r\nclk_put(xtal);\r\nret = PTR_ERR(pclk);\r\n}\r\n}\r\nif (!ret) {\r\nint i, j;\r\nfor (i = 0; i < 2; i++) {\r\nint fs = i ? 256 : 384;\r\nrates[i*33] = clk_get_rate(xtal) / fs;\r\nfor (j = 1; j < 33; j++)\r\nrates[i*33 + j] = clk_get_rate(pclk) /\r\n(j * fs);\r\n}\r\n}\r\n}\r\nclk_users += 1;\r\nmutex_unlock(&clk_lock);\r\nif (!ret) {\r\n#ifdef ENFORCE_RATES\r\nret = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates);\r\nif (ret < 0)\r\nprintk(KERN_ERR "%s cannot set constraints\n",\r\n__func__);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic void s3c24xx_uda134x_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nmutex_lock(&clk_lock);\r\npr_debug("%s %d\n", __func__, clk_users);\r\nclk_users -= 1;\r\nif (clk_users == 0) {\r\nclk_put(xtal);\r\nxtal = NULL;\r\nclk_put(pclk);\r\npclk = NULL;\r\n}\r\nmutex_unlock(&clk_lock);\r\n}\r\nstatic int s3c24xx_uda134x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nunsigned int clk = 0;\r\nint ret = 0;\r\nint clk_source, fs_mode;\r\nunsigned long rate = params_rate(params);\r\nlong err, cerr;\r\nunsigned int div;\r\nint i, bi;\r\nerr = 999999;\r\nbi = 0;\r\nfor (i = 0; i < 2*33; i++) {\r\ncerr = rates[i] - rate;\r\nif (cerr < 0)\r\ncerr = -cerr;\r\nif (cerr < err) {\r\nerr = cerr;\r\nbi = i;\r\n}\r\n}\r\nif (bi / 33 == 1)\r\nfs_mode = S3C2410_IISMOD_256FS;\r\nelse\r\nfs_mode = S3C2410_IISMOD_384FS;\r\nif (bi % 33 == 0) {\r\nclk_source = S3C24XX_CLKSRC_MPLL;\r\ndiv = 1;\r\n} else {\r\nclk_source = S3C24XX_CLKSRC_PCLK;\r\ndiv = bi % 33;\r\n}\r\npr_debug("%s desired rate %lu, %d\n", __func__, rate, bi);\r\nclk = (fs_mode == S3C2410_IISMOD_384FS ? 384 : 256) * rate;\r\npr_debug("%s will use: %s %s %d sysclk %d err %ld\n", __func__,\r\nfs_mode == S3C2410_IISMOD_384FS ? "384FS" : "256FS",\r\nclk_source == S3C24XX_CLKSRC_MPLL ? "MPLLin" : "PCLK",\r\ndiv, clk, err);\r\nif ((err * 100 / rate) > 5) {\r\nprintk(KERN_ERR "S3C24XX_UDA134X: effective frequency "\r\n"too different from desired (%ld%%)\n",\r\nerr * 100 / rate);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_dai_set_sysclk(cpu_dai, clk_source , clk,\r\nSND_SOC_CLOCK_IN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK, fs_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_BCLK,\r\nS3C2410_IISMOD_32FS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,\r\nS3C24XX_PRESCALE(div, div));\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dai_set_sysclk(codec_dai, 0, clk,\r\nSND_SOC_CLOCK_OUT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void setdat(int v)\r\n{\r\ngpio_set_value(s3c24xx_uda134x_l3_pins->l3_data, v > 0);\r\n}\r\nstatic void setclk(int v)\r\n{\r\ngpio_set_value(s3c24xx_uda134x_l3_pins->l3_clk, v > 0);\r\n}\r\nstatic void setmode(int v)\r\n{\r\ngpio_set_value(s3c24xx_uda134x_l3_pins->l3_mode, v > 0);\r\n}\r\nstatic int s3c24xx_uda134x_setup_pin(int pin, char *fun)\r\n{\r\nif (gpio_request(pin, "s3c24xx_uda134x") < 0) {\r\nprintk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "\r\n"l3 %s pin already in use", fun);\r\nreturn -EBUSY;\r\n}\r\ngpio_direction_output(pin, 0);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_uda134x_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "S3C24XX_UDA134X SoC Audio driver\n");\r\ns3c24xx_uda134x_l3_pins = pdev->dev.platform_data;\r\nif (s3c24xx_uda134x_l3_pins == NULL) {\r\nprintk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "\r\n"unable to find platform data\n");\r\nreturn -ENODEV;\r\n}\r\ns3c24xx_uda134x.power = s3c24xx_uda134x_l3_pins->power;\r\ns3c24xx_uda134x.model = s3c24xx_uda134x_l3_pins->model;\r\nif (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_data,\r\n"data") < 0)\r\nreturn -EBUSY;\r\nif (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_clk,\r\n"clk") < 0) {\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_data);\r\nreturn -EBUSY;\r\n}\r\nif (s3c24xx_uda134x_setup_pin(s3c24xx_uda134x_l3_pins->l3_mode,\r\n"mode") < 0) {\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_data);\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_clk);\r\nreturn -EBUSY;\r\n}\r\ns3c24xx_uda134x_snd_device = platform_device_alloc("soc-audio", -1);\r\nif (!s3c24xx_uda134x_snd_device) {\r\nprintk(KERN_ERR "S3C24XX_UDA134X SoC Audio: "\r\n"Unable to register\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(s3c24xx_uda134x_snd_device,\r\n&snd_soc_s3c24xx_uda134x);\r\nplatform_device_add_data(s3c24xx_uda134x_snd_device, &s3c24xx_uda134x, sizeof(s3c24xx_uda134x));\r\nret = platform_device_add(s3c24xx_uda134x_snd_device);\r\nif (ret) {\r\nprintk(KERN_ERR "S3C24XX_UDA134X SoC Audio: Unable to add\n");\r\nplatform_device_put(s3c24xx_uda134x_snd_device);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s3c24xx_uda134x_remove(struct platform_device *pdev)\r\n{\r\nplatform_device_unregister(s3c24xx_uda134x_snd_device);\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_data);\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_clk);\r\ngpio_free(s3c24xx_uda134x_l3_pins->l3_mode);\r\nreturn 0;\r\n}
