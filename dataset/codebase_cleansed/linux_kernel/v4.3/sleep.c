static void acpi_sleep_tts_switch(u32 acpi_state)\r\n{\r\nacpi_status status;\r\nstatus = acpi_execute_simple_method(NULL, "\\_TTS", acpi_state);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nprintk(KERN_NOTICE "Failure in evaluating _TTS object\n");\r\n}\r\n}\r\nstatic int tts_notify_reboot(struct notifier_block *this,\r\nunsigned long code, void *x)\r\n{\r\nacpi_sleep_tts_switch(ACPI_STATE_S5);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int acpi_sleep_prepare(u32 acpi_state)\r\n{\r\n#ifdef CONFIG_ACPI_SLEEP\r\nif (acpi_state == ACPI_STATE_S3) {\r\nif (!acpi_wakeup_address)\r\nreturn -EFAULT;\r\nacpi_set_firmware_waking_vector(acpi_wakeup_address);\r\n}\r\nACPI_FLUSH_CPU_CACHE();\r\n#endif\r\nprintk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",\r\nacpi_state);\r\nacpi_enable_wakeup_devices(acpi_state);\r\nacpi_enter_sleep_state_prep(acpi_state);\r\nreturn 0;\r\n}\r\nstatic bool acpi_sleep_state_supported(u8 sleep_state)\r\n{\r\nacpi_status status;\r\nu8 type_a, type_b;\r\nstatus = acpi_get_sleep_type_data(sleep_state, &type_a, &type_b);\r\nreturn ACPI_SUCCESS(status) && (!acpi_gbl_reduced_hardware\r\n|| (acpi_gbl_FADT.sleep_control.address\r\n&& acpi_gbl_FADT.sleep_status.address));\r\n}\r\nu32 acpi_target_system_state(void)\r\n{\r\nreturn acpi_target_sleep_state;\r\n}\r\nvoid __init acpi_nvs_nosave(void)\r\n{\r\nnvs_nosave = true;\r\n}\r\nvoid __init acpi_nvs_nosave_s3(void)\r\n{\r\nnvs_nosave_s3 = true;\r\n}\r\nvoid __init acpi_old_suspend_ordering(void)\r\n{\r\nold_suspend_ordering = true;\r\n}\r\nstatic int __init init_old_suspend_ordering(const struct dmi_system_id *d)\r\n{\r\nacpi_old_suspend_ordering();\r\nreturn 0;\r\n}\r\nstatic int __init init_nvs_nosave(const struct dmi_system_id *d)\r\n{\r\nacpi_nvs_nosave();\r\nreturn 0;\r\n}\r\nstatic void __init acpi_sleep_dmi_check(void)\r\n{\r\nint year;\r\nif (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)\r\nacpi_nvs_nosave_s3();\r\ndmi_check_system(acpisleep_dmi_table);\r\n}\r\nstatic int acpi_pm_freeze(void)\r\n{\r\nacpi_disable_all_gpes();\r\nacpi_os_wait_events_complete();\r\nacpi_ec_block_transactions();\r\nreturn 0;\r\n}\r\nstatic int acpi_pm_pre_suspend(void)\r\n{\r\nacpi_pm_freeze();\r\nreturn suspend_nvs_save();\r\n}\r\nstatic int __acpi_pm_prepare(void)\r\n{\r\nint error = acpi_sleep_prepare(acpi_target_sleep_state);\r\nif (error)\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nreturn error;\r\n}\r\nstatic int acpi_pm_prepare(void)\r\n{\r\nint error = __acpi_pm_prepare();\r\nif (!error)\r\nerror = acpi_pm_pre_suspend();\r\nreturn error;\r\n}\r\nstatic int find_powerf_dev(struct device *dev, void *data)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nconst char *hid = acpi_device_hid(device);\r\nreturn !strcmp(hid, ACPI_BUTTON_HID_POWERF);\r\n}\r\nstatic void acpi_pm_finish(void)\r\n{\r\nstruct device *pwr_btn_dev;\r\nu32 acpi_state = acpi_target_sleep_state;\r\nacpi_ec_unblock_transactions();\r\nsuspend_nvs_free();\r\nif (acpi_state == ACPI_STATE_S0)\r\nreturn;\r\nprintk(KERN_INFO PREFIX "Waking up from system sleep state S%d\n",\r\nacpi_state);\r\nacpi_disable_wakeup_devices(acpi_state);\r\nacpi_leave_sleep_state(acpi_state);\r\nacpi_set_firmware_waking_vector((acpi_physical_address) 0);\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nacpi_resume_power_resources();\r\nif (!pwr_btn_event_pending)\r\nreturn;\r\npwr_btn_event_pending = false;\r\npwr_btn_dev = bus_find_device(&acpi_bus_type, NULL, NULL,\r\nfind_powerf_dev);\r\nif (pwr_btn_dev) {\r\npm_wakeup_event(pwr_btn_dev, 0);\r\nput_device(pwr_btn_dev);\r\n}\r\n}\r\nstatic void acpi_pm_start(u32 acpi_state)\r\n{\r\nacpi_target_sleep_state = acpi_state;\r\nacpi_sleep_tts_switch(acpi_target_sleep_state);\r\nacpi_scan_lock_acquire();\r\n}\r\nstatic void acpi_pm_end(void)\r\n{\r\nacpi_scan_lock_release();\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nacpi_sleep_tts_switch(acpi_target_sleep_state);\r\n}\r\nstatic inline void acpi_sleep_dmi_check(void) {}\r\nstatic int acpi_suspend_begin(suspend_state_t pm_state)\r\n{\r\nu32 acpi_state = acpi_suspend_states[pm_state];\r\nint error;\r\nerror = (nvs_nosave || nvs_nosave_s3) ? 0 : suspend_nvs_alloc();\r\nif (error)\r\nreturn error;\r\nif (!sleep_states[acpi_state]) {\r\npr_err("ACPI does not support sleep state S%u\n", acpi_state);\r\nreturn -ENOSYS;\r\n}\r\nacpi_pm_start(acpi_state);\r\nreturn 0;\r\n}\r\nstatic int acpi_suspend_enter(suspend_state_t pm_state)\r\n{\r\nacpi_status status = AE_OK;\r\nu32 acpi_state = acpi_target_sleep_state;\r\nint error;\r\nACPI_FLUSH_CPU_CACHE();\r\ntrace_suspend_resume(TPS("acpi_suspend"), acpi_state, true);\r\nswitch (acpi_state) {\r\ncase ACPI_STATE_S1:\r\nbarrier();\r\nstatus = acpi_enter_sleep_state(acpi_state);\r\nbreak;\r\ncase ACPI_STATE_S3:\r\nif (!acpi_suspend_lowlevel)\r\nreturn -ENOSYS;\r\nerror = acpi_suspend_lowlevel();\r\nif (error)\r\nreturn error;\r\npr_info(PREFIX "Low-level resume complete\n");\r\nbreak;\r\n}\r\ntrace_suspend_resume(TPS("acpi_suspend"), acpi_state, false);\r\nacpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);\r\nacpi_leave_sleep_state_prep(acpi_state);\r\nif (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {\r\nacpi_event_status pwr_btn_status = ACPI_EVENT_FLAG_DISABLED;\r\nacpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);\r\nif (pwr_btn_status & ACPI_EVENT_FLAG_SET) {\r\nacpi_clear_event(ACPI_EVENT_POWER_BUTTON);\r\npwr_btn_event_pending = true;\r\n}\r\n}\r\nacpi_disable_all_gpes();\r\nacpi_ec_unblock_transactions_early();\r\nsuspend_nvs_restore();\r\nreturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\r\n}\r\nstatic int acpi_suspend_state_valid(suspend_state_t pm_state)\r\n{\r\nu32 acpi_state;\r\nswitch (pm_state) {\r\ncase PM_SUSPEND_ON:\r\ncase PM_SUSPEND_STANDBY:\r\ncase PM_SUSPEND_MEM:\r\nacpi_state = acpi_suspend_states[pm_state];\r\nreturn sleep_states[acpi_state];\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int acpi_suspend_begin_old(suspend_state_t pm_state)\r\n{\r\nint error = acpi_suspend_begin(pm_state);\r\nif (!error)\r\nerror = __acpi_pm_prepare();\r\nreturn error;\r\n}\r\nstatic int acpi_freeze_begin(void)\r\n{\r\nacpi_scan_lock_acquire();\r\nreturn 0;\r\n}\r\nstatic int acpi_freeze_prepare(void)\r\n{\r\nacpi_enable_wakeup_devices(ACPI_STATE_S0);\r\nacpi_enable_all_wakeup_gpes();\r\nacpi_os_wait_events_complete();\r\nenable_irq_wake(acpi_gbl_FADT.sci_interrupt);\r\nreturn 0;\r\n}\r\nstatic void acpi_freeze_restore(void)\r\n{\r\nacpi_disable_wakeup_devices(ACPI_STATE_S0);\r\ndisable_irq_wake(acpi_gbl_FADT.sci_interrupt);\r\nacpi_enable_all_runtime_gpes();\r\n}\r\nstatic void acpi_freeze_end(void)\r\n{\r\nacpi_scan_lock_release();\r\n}\r\nstatic void acpi_sleep_suspend_setup(void)\r\n{\r\nint i;\r\nfor (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++)\r\nif (acpi_sleep_state_supported(i))\r\nsleep_states[i] = 1;\r\nsuspend_set_ops(old_suspend_ordering ?\r\n&acpi_suspend_ops_old : &acpi_suspend_ops);\r\nfreeze_set_ops(&acpi_freeze_ops);\r\n}\r\nstatic inline void acpi_sleep_suspend_setup(void) {}\r\nvoid __init acpi_no_s4_hw_signature(void)\r\n{\r\nnosigcheck = true;\r\n}\r\nstatic int acpi_hibernation_begin(void)\r\n{\r\nint error;\r\nerror = nvs_nosave ? 0 : suspend_nvs_alloc();\r\nif (!error)\r\nacpi_pm_start(ACPI_STATE_S4);\r\nreturn error;\r\n}\r\nstatic int acpi_hibernation_enter(void)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FLUSH_CPU_CACHE();\r\nstatus = acpi_enter_sleep_state(ACPI_STATE_S4);\r\nacpi_leave_sleep_state_prep(ACPI_STATE_S4);\r\nreturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\r\n}\r\nstatic void acpi_hibernation_leave(void)\r\n{\r\nacpi_enable();\r\nacpi_leave_sleep_state_prep(ACPI_STATE_S4);\r\nif (facs && s4_hardware_signature != facs->hardware_signature)\r\npr_crit("ACPI: Hardware changed while hibernated, success doubtful!\n");\r\nsuspend_nvs_restore();\r\nacpi_ec_unblock_transactions_early();\r\n}\r\nstatic void acpi_pm_thaw(void)\r\n{\r\nacpi_ec_unblock_transactions();\r\nacpi_enable_all_runtime_gpes();\r\n}\r\nstatic int acpi_hibernation_begin_old(void)\r\n{\r\nint error;\r\nacpi_sleep_tts_switch(ACPI_STATE_S4);\r\nerror = acpi_sleep_prepare(ACPI_STATE_S4);\r\nif (!error) {\r\nif (!nvs_nosave)\r\nerror = suspend_nvs_alloc();\r\nif (!error) {\r\nacpi_target_sleep_state = ACPI_STATE_S4;\r\nacpi_scan_lock_acquire();\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic void acpi_sleep_hibernate_setup(void)\r\n{\r\nif (!acpi_sleep_state_supported(ACPI_STATE_S4))\r\nreturn;\r\nhibernation_set_ops(old_suspend_ordering ?\r\n&acpi_hibernation_ops_old : &acpi_hibernation_ops);\r\nsleep_states[ACPI_STATE_S4] = 1;\r\nif (nosigcheck)\r\nreturn;\r\nacpi_get_table(ACPI_SIG_FACS, 1, (struct acpi_table_header **)&facs);\r\nif (facs)\r\ns4_hardware_signature = facs->hardware_signature;\r\n}\r\nstatic inline void acpi_sleep_hibernate_setup(void) {}\r\nstatic void acpi_power_off_prepare(void)\r\n{\r\nacpi_sleep_prepare(ACPI_STATE_S5);\r\nacpi_disable_all_gpes();\r\nacpi_os_wait_events_complete();\r\n}\r\nstatic void acpi_power_off(void)\r\n{\r\nprintk(KERN_DEBUG "%s called\n", __func__);\r\nlocal_irq_disable();\r\nacpi_enter_sleep_state(ACPI_STATE_S5);\r\n}\r\nint __init acpi_sleep_init(void)\r\n{\r\nchar supported[ACPI_S_STATE_COUNT * 3 + 1];\r\nchar *pos = supported;\r\nint i;\r\nacpi_sleep_dmi_check();\r\nsleep_states[ACPI_STATE_S0] = 1;\r\nacpi_sleep_suspend_setup();\r\nacpi_sleep_hibernate_setup();\r\nif (acpi_sleep_state_supported(ACPI_STATE_S5)) {\r\nsleep_states[ACPI_STATE_S5] = 1;\r\npm_power_off_prepare = acpi_power_off_prepare;\r\npm_power_off = acpi_power_off;\r\n}\r\nsupported[0] = 0;\r\nfor (i = 0; i < ACPI_S_STATE_COUNT; i++) {\r\nif (sleep_states[i])\r\npos += sprintf(pos, " S%d", i);\r\n}\r\npr_info(PREFIX "(supports%s)\n", supported);\r\nregister_reboot_notifier(&tts_notifier);\r\nreturn 0;\r\n}
