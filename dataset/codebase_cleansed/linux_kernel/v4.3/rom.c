int pci_enable_rom(struct pci_dev *pdev)\r\n{\r\nstruct resource *res = pdev->resource + PCI_ROM_RESOURCE;\r\nstruct pci_bus_region region;\r\nu32 rom_addr;\r\nif (!res->flags)\r\nreturn -1;\r\npcibios_resource_to_bus(pdev->bus, &region, res);\r\npci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);\r\nrom_addr &= ~PCI_ROM_ADDRESS_MASK;\r\nrom_addr |= region.start | PCI_ROM_ADDRESS_ENABLE;\r\npci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);\r\nreturn 0;\r\n}\r\nvoid pci_disable_rom(struct pci_dev *pdev)\r\n{\r\nu32 rom_addr;\r\npci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);\r\nrom_addr &= ~PCI_ROM_ADDRESS_ENABLE;\r\npci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);\r\n}\r\nsize_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)\r\n{\r\nvoid __iomem *image;\r\nint last_image;\r\nunsigned length;\r\nimage = rom;\r\ndo {\r\nvoid __iomem *pds;\r\nif (readb(image) != 0x55) {\r\ndev_err(&pdev->dev, "Invalid ROM contents\n");\r\nbreak;\r\n}\r\nif (readb(image + 1) != 0xAA)\r\nbreak;\r\npds = image + readw(image + 24);\r\nif (readb(pds) != 'P')\r\nbreak;\r\nif (readb(pds + 1) != 'C')\r\nbreak;\r\nif (readb(pds + 2) != 'I')\r\nbreak;\r\nif (readb(pds + 3) != 'R')\r\nbreak;\r\nlast_image = readb(pds + 21) & 0x80;\r\nlength = readw(pds + 16);\r\nimage += length * 512;\r\n} while (length && !last_image);\r\nreturn min((size_t)(image - rom), size);\r\n}\r\nvoid __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)\r\n{\r\nstruct resource *res = &pdev->resource[PCI_ROM_RESOURCE];\r\nloff_t start;\r\nvoid __iomem *rom;\r\nif (res->flags & IORESOURCE_ROM_SHADOW) {\r\nstart = (loff_t)0xC0000;\r\n*size = 0x20000;\r\n} else {\r\nif (res->flags &\r\n(IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {\r\n*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);\r\nreturn (void __iomem *)(unsigned long)\r\npci_resource_start(pdev, PCI_ROM_RESOURCE);\r\n} else {\r\nif (res->parent == NULL &&\r\npci_assign_resource(pdev, PCI_ROM_RESOURCE))\r\nreturn NULL;\r\nstart = pci_resource_start(pdev, PCI_ROM_RESOURCE);\r\n*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);\r\nif (*size == 0)\r\nreturn NULL;\r\nif (pci_enable_rom(pdev))\r\nreturn NULL;\r\n}\r\n}\r\nrom = ioremap(start, *size);\r\nif (!rom) {\r\nif (!(res->flags & (IORESOURCE_ROM_ENABLE |\r\nIORESOURCE_ROM_SHADOW |\r\nIORESOURCE_ROM_COPY)))\r\npci_disable_rom(pdev);\r\nreturn NULL;\r\n}\r\n*size = pci_get_rom_size(pdev, rom, *size);\r\nreturn rom;\r\n}\r\nvoid pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)\r\n{\r\nstruct resource *res = &pdev->resource[PCI_ROM_RESOURCE];\r\nif (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY))\r\nreturn;\r\niounmap(rom);\r\nif (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))\r\npci_disable_rom(pdev);\r\n}\r\nvoid pci_cleanup_rom(struct pci_dev *pdev)\r\n{\r\nstruct resource *res = &pdev->resource[PCI_ROM_RESOURCE];\r\nif (res->flags & IORESOURCE_ROM_COPY) {\r\nkfree((void *)(unsigned long)res->start);\r\nres->flags |= IORESOURCE_UNSET;\r\nres->flags &= ~IORESOURCE_ROM_COPY;\r\nres->start = 0;\r\nres->end = 0;\r\n}\r\n}\r\nvoid __iomem *pci_platform_rom(struct pci_dev *pdev, size_t *size)\r\n{\r\nif (pdev->rom && pdev->romlen) {\r\n*size = pdev->romlen;\r\nreturn phys_to_virt((phys_addr_t)pdev->rom);\r\n}\r\nreturn NULL;\r\n}
