static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *pbus;\r\nstruct device_node *dn;\r\nstruct pci_dn *pdn;\r\npbus = bus;\r\nwhile (pbus) {\r\nif (pci_is_root_bus(pbus) || pbus->self)\r\nbreak;\r\npbus = pbus->parent;\r\n}\r\ndn = pci_bus_to_OF_node(pbus);\r\npdn = dn ? PCI_DN(dn) : NULL;\r\nreturn pdn;\r\n}\r\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\r\nint devfn)\r\n{\r\nstruct device_node *dn = NULL;\r\nstruct pci_dn *parent, *pdn;\r\nstruct pci_dev *pdev = NULL;\r\nlist_for_each_entry(pdev, &bus->devices, bus_list) {\r\nif (pdev->devfn == devfn) {\r\nif (pdev->dev.archdata.pci_data)\r\nreturn pdev->dev.archdata.pci_data;\r\ndn = pci_device_to_OF_node(pdev);\r\nbreak;\r\n}\r\n}\r\npdn = dn ? PCI_DN(dn) : NULL;\r\nif (pdn)\r\nreturn pdn;\r\nparent = pci_bus_to_pdn(bus);\r\nif (!parent)\r\nreturn NULL;\r\nlist_for_each_entry(pdn, &parent->child_list, list) {\r\nif (pdn->busno == bus->number &&\r\npdn->devfn == devfn)\r\nreturn pdn;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\r\n{\r\nstruct device_node *dn;\r\nstruct pci_dn *parent, *pdn;\r\nif (pdev->dev.archdata.pci_data)\r\nreturn pdev->dev.archdata.pci_data;\r\ndn = pci_device_to_OF_node(pdev);\r\npdn = dn ? PCI_DN(dn) : NULL;\r\nif (pdn)\r\nreturn pdn;\r\nparent = pci_bus_to_pdn(pdev->bus);\r\nif (!parent)\r\nreturn NULL;\r\nlist_for_each_entry(pdn, &parent->child_list, list) {\r\nif (pdn->busno == pdev->bus->number &&\r\npdn->devfn == pdev->devfn)\r\nreturn pdn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pci_dn *add_one_dev_pci_data(struct pci_dn *parent,\r\nstruct pci_dev *pdev,\r\nint busno, int devfn)\r\n{\r\nstruct pci_dn *pdn;\r\nif (!parent)\r\nreturn NULL;\r\npdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\r\nif (!pdn) {\r\ndev_warn(&pdev->dev, "%s: Out of memory!\n", __func__);\r\nreturn NULL;\r\n}\r\npdn->phb = parent->phb;\r\npdn->parent = parent;\r\npdn->busno = busno;\r\npdn->devfn = devfn;\r\n#ifdef CONFIG_PPC_POWERNV\r\npdn->pe_number = IODA_INVALID_PE;\r\n#endif\r\nINIT_LIST_HEAD(&pdn->child_list);\r\nINIT_LIST_HEAD(&pdn->list);\r\nlist_add_tail(&pdn->list, &parent->child_list);\r\nif (pdev)\r\npdev->dev.archdata.pci_data = pdn;\r\nreturn pdn;\r\n}\r\nstruct pci_dn *add_dev_pci_data(struct pci_dev *pdev)\r\n{\r\n#ifdef CONFIG_PCI_IOV\r\nstruct pci_dn *parent, *pdn;\r\nint i;\r\nif (!pdev->is_physfn)\r\nreturn pci_get_pdn(pdev);\r\npdn = pci_get_pdn(pdev);\r\nif (!pdn || (pdn->flags & PCI_DN_FLAG_IOV_VF))\r\nreturn NULL;\r\npdn->flags |= PCI_DN_FLAG_IOV_VF;\r\nparent = pci_bus_to_pdn(pdev->bus);\r\nif (!parent)\r\nreturn NULL;\r\nfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\r\npdn = add_one_dev_pci_data(parent, NULL,\r\npci_iov_virtfn_bus(pdev, i),\r\npci_iov_virtfn_devfn(pdev, i));\r\nif (!pdn) {\r\ndev_warn(&pdev->dev, "%s: Cannot create firmware data for VF#%d\n",\r\n__func__, i);\r\nreturn NULL;\r\n}\r\n}\r\n#endif\r\nreturn pci_get_pdn(pdev);\r\n}\r\nvoid remove_dev_pci_data(struct pci_dev *pdev)\r\n{\r\n#ifdef CONFIG_PCI_IOV\r\nstruct pci_dn *parent;\r\nstruct pci_dn *pdn, *tmp;\r\nint i;\r\nif (pdev->is_virtfn) {\r\npdn = pci_get_pdn(pdev);\r\n#ifdef CONFIG_PPC_POWERNV\r\npdn->pe_number = IODA_INVALID_PE;\r\n#endif\r\nreturn;\r\n}\r\nif (!pdev->is_physfn)\r\nreturn;\r\npdn = pci_get_pdn(pdev);\r\nif (!pdn || !(pdn->flags & PCI_DN_FLAG_IOV_VF))\r\nreturn;\r\npdn->flags &= ~PCI_DN_FLAG_IOV_VF;\r\nparent = pci_bus_to_pdn(pdev->bus);\r\nif (!parent)\r\nreturn;\r\nfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\r\nlist_for_each_entry_safe(pdn, tmp,\r\n&parent->child_list, list) {\r\nif (pdn->busno != pci_iov_virtfn_bus(pdev, i) ||\r\npdn->devfn != pci_iov_virtfn_devfn(pdev, i))\r\ncontinue;\r\nif (!list_empty(&pdn->list))\r\nlist_del(&pdn->list);\r\nkfree(pdn);\r\n}\r\n}\r\n#endif\r\n}\r\nvoid *update_dn_pci_info(struct device_node *dn, void *data)\r\n{\r\nstruct pci_controller *phb = data;\r\nconst __be32 *type = of_get_property(dn, "ibm,pci-config-space-type", NULL);\r\nconst __be32 *regs;\r\nstruct device_node *parent;\r\nstruct pci_dn *pdn;\r\npdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\r\nif (pdn == NULL)\r\nreturn NULL;\r\ndn->data = pdn;\r\npdn->node = dn;\r\npdn->phb = phb;\r\n#ifdef CONFIG_PPC_POWERNV\r\npdn->pe_number = IODA_INVALID_PE;\r\n#endif\r\nregs = of_get_property(dn, "reg", NULL);\r\nif (regs) {\r\nu32 addr = of_read_number(regs, 1);\r\npdn->busno = (addr >> 16) & 0xff;\r\npdn->devfn = (addr >> 8) & 0xff;\r\n}\r\nregs = of_get_property(dn, "vendor-id", NULL);\r\npdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\r\nregs = of_get_property(dn, "device-id", NULL);\r\npdn->device_id = regs ? of_read_number(regs, 1) : 0;\r\nregs = of_get_property(dn, "class-code", NULL);\r\npdn->class_code = regs ? of_read_number(regs, 1) : 0;\r\npdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\r\nINIT_LIST_HEAD(&pdn->child_list);\r\nINIT_LIST_HEAD(&pdn->list);\r\nparent = of_get_parent(dn);\r\npdn->parent = parent ? PCI_DN(parent) : NULL;\r\nif (pdn->parent)\r\nlist_add_tail(&pdn->list, &pdn->parent->child_list);\r\nreturn NULL;\r\n}\r\nvoid *traverse_pci_devices(struct device_node *start, traverse_func pre,\r\nvoid *data)\r\n{\r\nstruct device_node *dn, *nextdn;\r\nvoid *ret;\r\nfor (dn = start->child; dn; dn = nextdn) {\r\nconst __be32 *classp;\r\nu32 class = 0;\r\nnextdn = NULL;\r\nclassp = of_get_property(dn, "class-code", NULL);\r\nif (classp)\r\nclass = of_read_number(classp, 1);\r\nif (pre && ((ret = pre(dn, data)) != NULL))\r\nreturn ret;\r\nif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\r\n(class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\r\nnextdn = dn->child;\r\nelse if (dn->sibling)\r\nnextdn = dn->sibling;\r\nif (!nextdn) {\r\ndo {\r\ndn = dn->parent;\r\nif (dn == start)\r\nreturn NULL;\r\n} while (dn->sibling == NULL);\r\nnextdn = dn->sibling;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pci_dn *pci_dn_next_one(struct pci_dn *root,\r\nstruct pci_dn *pdn)\r\n{\r\nstruct list_head *next = pdn->child_list.next;\r\nif (next != &pdn->child_list)\r\nreturn list_entry(next, struct pci_dn, list);\r\nwhile (1) {\r\nif (pdn == root)\r\nreturn NULL;\r\nnext = pdn->list.next;\r\nif (next != &pdn->parent->child_list)\r\nbreak;\r\npdn = pdn->parent;\r\n}\r\nreturn list_entry(next, struct pci_dn, list);\r\n}\r\nvoid *traverse_pci_dn(struct pci_dn *root,\r\nvoid *(*fn)(struct pci_dn *, void *),\r\nvoid *data)\r\n{\r\nstruct pci_dn *pdn = root;\r\nvoid *ret;\r\nfor (pdn = pci_dn_next_one(root, pdn); pdn;\r\npdn = pci_dn_next_one(root, pdn)) {\r\nret = fn(pdn, data);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn NULL;\r\n}\r\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\r\n{\r\nstruct device_node *dn = phb->dn;\r\nstruct pci_dn *pdn;\r\nupdate_dn_pci_info(dn, phb);\r\npdn = dn->data;\r\nif (pdn) {\r\npdn->devfn = pdn->busno = -1;\r\npdn->vendor_id = pdn->device_id = pdn->class_code = 0;\r\npdn->phb = phb;\r\nphb->pci_data = pdn;\r\n}\r\ntraverse_pci_devices(dn, update_dn_pci_info, phb);\r\n}\r\nvoid __init pci_devs_phb_init(void)\r\n{\r\nstruct pci_controller *phb, *tmp;\r\nlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\r\npci_devs_phb_init_dynamic(phb);\r\n}\r\nstatic void pci_dev_pdn_setup(struct pci_dev *pdev)\r\n{\r\nstruct pci_dn *pdn;\r\nif (pdev->dev.archdata.pci_data)\r\nreturn;\r\npdn = pci_get_pdn(pdev);\r\npdev->dev.archdata.pci_data = pdn;\r\n}
