static void copy_abs(struct input_dev *dev, unsigned int dst, unsigned int src)\r\n{\r\nif (dev->absinfo && test_bit(src, dev->absbit)) {\r\ndev->absinfo[dst] = dev->absinfo[src];\r\ndev->absinfo[dst].fuzz = 0;\r\ndev->absbit[BIT_WORD(dst)] |= BIT_MASK(dst);\r\n}\r\n}\r\nint input_mt_init_slots(struct input_dev *dev, unsigned int num_slots,\r\nunsigned int flags)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nint i;\r\nif (!num_slots)\r\nreturn 0;\r\nif (mt)\r\nreturn mt->num_slots != num_slots ? -EINVAL : 0;\r\nmt = kzalloc(sizeof(*mt) + num_slots * sizeof(*mt->slots), GFP_KERNEL);\r\nif (!mt)\r\ngoto err_mem;\r\nmt->num_slots = num_slots;\r\nmt->flags = flags;\r\ninput_set_abs_params(dev, ABS_MT_SLOT, 0, num_slots - 1, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_TRACKING_ID, 0, TRKID_MAX, 0, 0);\r\nif (flags & (INPUT_MT_POINTER | INPUT_MT_DIRECT)) {\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\ncopy_abs(dev, ABS_X, ABS_MT_POSITION_X);\r\ncopy_abs(dev, ABS_Y, ABS_MT_POSITION_Y);\r\ncopy_abs(dev, ABS_PRESSURE, ABS_MT_PRESSURE);\r\n}\r\nif (flags & INPUT_MT_POINTER) {\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\nif (num_slots >= 3)\r\n__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\r\nif (num_slots >= 4)\r\n__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\r\nif (num_slots >= 5)\r\n__set_bit(BTN_TOOL_QUINTTAP, dev->keybit);\r\n__set_bit(INPUT_PROP_POINTER, dev->propbit);\r\n}\r\nif (flags & INPUT_MT_DIRECT)\r\n__set_bit(INPUT_PROP_DIRECT, dev->propbit);\r\nif (flags & INPUT_MT_SEMI_MT)\r\n__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\r\nif (flags & INPUT_MT_TRACK) {\r\nunsigned int n2 = num_slots * num_slots;\r\nmt->red = kcalloc(n2, sizeof(*mt->red), GFP_KERNEL);\r\nif (!mt->red)\r\ngoto err_mem;\r\n}\r\nfor (i = 0; i < num_slots; i++)\r\ninput_mt_set_value(&mt->slots[i], ABS_MT_TRACKING_ID, -1);\r\nmt->frame = 1;\r\ndev->mt = mt;\r\nreturn 0;\r\nerr_mem:\r\nkfree(mt);\r\nreturn -ENOMEM;\r\n}\r\nvoid input_mt_destroy_slots(struct input_dev *dev)\r\n{\r\nif (dev->mt) {\r\nkfree(dev->mt->red);\r\nkfree(dev->mt);\r\n}\r\ndev->mt = NULL;\r\n}\r\nvoid input_mt_report_slot_state(struct input_dev *dev,\r\nunsigned int tool_type, bool active)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nstruct input_mt_slot *slot;\r\nint id;\r\nif (!mt)\r\nreturn;\r\nslot = &mt->slots[mt->slot];\r\nslot->frame = mt->frame;\r\nif (!active) {\r\ninput_event(dev, EV_ABS, ABS_MT_TRACKING_ID, -1);\r\nreturn;\r\n}\r\nid = input_mt_get_value(slot, ABS_MT_TRACKING_ID);\r\nif (id < 0 || input_mt_get_value(slot, ABS_MT_TOOL_TYPE) != tool_type)\r\nid = input_mt_new_trkid(mt);\r\ninput_event(dev, EV_ABS, ABS_MT_TRACKING_ID, id);\r\ninput_event(dev, EV_ABS, ABS_MT_TOOL_TYPE, tool_type);\r\n}\r\nvoid input_mt_report_finger_count(struct input_dev *dev, int count)\r\n{\r\ninput_event(dev, EV_KEY, BTN_TOOL_FINGER, count == 1);\r\ninput_event(dev, EV_KEY, BTN_TOOL_DOUBLETAP, count == 2);\r\ninput_event(dev, EV_KEY, BTN_TOOL_TRIPLETAP, count == 3);\r\ninput_event(dev, EV_KEY, BTN_TOOL_QUADTAP, count == 4);\r\ninput_event(dev, EV_KEY, BTN_TOOL_QUINTTAP, count == 5);\r\n}\r\nvoid input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nstruct input_mt_slot *oldest;\r\nint oldid, count, i;\r\nif (!mt)\r\nreturn;\r\noldest = NULL;\r\noldid = mt->trkid;\r\ncount = 0;\r\nfor (i = 0; i < mt->num_slots; ++i) {\r\nstruct input_mt_slot *ps = &mt->slots[i];\r\nint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\r\nif (id < 0)\r\ncontinue;\r\nif ((id - oldid) & TRKID_SGN) {\r\noldest = ps;\r\noldid = id;\r\n}\r\ncount++;\r\n}\r\ninput_event(dev, EV_KEY, BTN_TOUCH, count > 0);\r\nif (use_count)\r\ninput_mt_report_finger_count(dev, count);\r\nif (oldest) {\r\nint x = input_mt_get_value(oldest, ABS_MT_POSITION_X);\r\nint y = input_mt_get_value(oldest, ABS_MT_POSITION_Y);\r\ninput_event(dev, EV_ABS, ABS_X, x);\r\ninput_event(dev, EV_ABS, ABS_Y, y);\r\nif (test_bit(ABS_MT_PRESSURE, dev->absbit)) {\r\nint p = input_mt_get_value(oldest, ABS_MT_PRESSURE);\r\ninput_event(dev, EV_ABS, ABS_PRESSURE, p);\r\n}\r\n} else {\r\nif (test_bit(ABS_MT_PRESSURE, dev->absbit))\r\ninput_event(dev, EV_ABS, ABS_PRESSURE, 0);\r\n}\r\n}\r\nstatic void __input_mt_drop_unused(struct input_dev *dev, struct input_mt *mt)\r\n{\r\nint i;\r\nfor (i = 0; i < mt->num_slots; i++) {\r\nif (!input_mt_is_used(mt, &mt->slots[i])) {\r\ninput_mt_slot(dev, i);\r\ninput_event(dev, EV_ABS, ABS_MT_TRACKING_ID, -1);\r\n}\r\n}\r\n}\r\nvoid input_mt_drop_unused(struct input_dev *dev)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nif (mt) {\r\n__input_mt_drop_unused(dev, mt);\r\nmt->frame++;\r\n}\r\n}\r\nvoid input_mt_sync_frame(struct input_dev *dev)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nbool use_count = false;\r\nif (!mt)\r\nreturn;\r\nif (mt->flags & INPUT_MT_DROP_UNUSED)\r\n__input_mt_drop_unused(dev, mt);\r\nif ((mt->flags & INPUT_MT_POINTER) && !(mt->flags & INPUT_MT_SEMI_MT))\r\nuse_count = true;\r\ninput_mt_report_pointer_emulation(dev, use_count);\r\nmt->frame++;\r\n}\r\nstatic int adjust_dual(int *begin, int step, int *end, int eq, int mu)\r\n{\r\nint f, *p, s, c;\r\nif (begin == end)\r\nreturn 0;\r\nf = *begin;\r\np = begin + step;\r\ns = p == end ? f + 1 : *p;\r\nfor (; p != end; p += step)\r\nif (*p < f)\r\ns = f, f = *p;\r\nelse if (*p < s)\r\ns = *p;\r\nc = (f + s + 1) / 2;\r\nif (c == 0 || (c > mu && (!eq || mu > 0)))\r\nreturn 0;\r\nif (s < 0 && mu <= 0)\r\nc *= 2;\r\nfor (p = begin; p != end; p += step)\r\n*p -= c;\r\nreturn (c < s && s <= 0) || (f >= 0 && f < c);\r\n}\r\nstatic void find_reduced_matrix(int *w, int nr, int nc, int nrc, int mu)\r\n{\r\nint i, k, sum;\r\nfor (k = 0; k < nrc; k++) {\r\nfor (i = 0; i < nr; i++)\r\nadjust_dual(w + i, nr, w + i + nrc, nr <= nc, mu);\r\nsum = 0;\r\nfor (i = 0; i < nrc; i += nr)\r\nsum += adjust_dual(w + i, 1, w + i + nr, nc <= nr, mu);\r\nif (!sum)\r\nbreak;\r\n}\r\n}\r\nstatic int input_mt_set_matrix(struct input_mt *mt,\r\nconst struct input_mt_pos *pos, int num_pos,\r\nint mu)\r\n{\r\nconst struct input_mt_pos *p;\r\nstruct input_mt_slot *s;\r\nint *w = mt->red;\r\nint x, y;\r\nfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\r\nif (!input_mt_is_active(s))\r\ncontinue;\r\nx = input_mt_get_value(s, ABS_MT_POSITION_X);\r\ny = input_mt_get_value(s, ABS_MT_POSITION_Y);\r\nfor (p = pos; p != pos + num_pos; p++) {\r\nint dx = x - p->x, dy = y - p->y;\r\n*w++ = dx * dx + dy * dy - mu;\r\n}\r\n}\r\nreturn w - mt->red;\r\n}\r\nstatic void input_mt_set_slots(struct input_mt *mt,\r\nint *slots, int num_pos)\r\n{\r\nstruct input_mt_slot *s;\r\nint *w = mt->red, j;\r\nfor (j = 0; j != num_pos; j++)\r\nslots[j] = -1;\r\nfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\r\nif (!input_mt_is_active(s))\r\ncontinue;\r\nfor (j = 0; j != num_pos; j++) {\r\nif (w[j] < 0) {\r\nslots[j] = s - mt->slots;\r\nbreak;\r\n}\r\n}\r\nw += num_pos;\r\n}\r\nfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\r\nif (input_mt_is_active(s))\r\ncontinue;\r\nfor (j = 0; j != num_pos; j++) {\r\nif (slots[j] < 0) {\r\nslots[j] = s - mt->slots;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nint input_mt_assign_slots(struct input_dev *dev, int *slots,\r\nconst struct input_mt_pos *pos, int num_pos,\r\nint dmax)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nint mu = 2 * dmax * dmax;\r\nint nrc;\r\nif (!mt || !mt->red)\r\nreturn -ENXIO;\r\nif (num_pos > mt->num_slots)\r\nreturn -EINVAL;\r\nif (num_pos < 1)\r\nreturn 0;\r\nnrc = input_mt_set_matrix(mt, pos, num_pos, mu);\r\nfind_reduced_matrix(mt->red, num_pos, nrc / num_pos, nrc, mu);\r\ninput_mt_set_slots(mt, slots, num_pos);\r\nreturn 0;\r\n}\r\nint input_mt_get_slot_by_key(struct input_dev *dev, int key)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nstruct input_mt_slot *s;\r\nif (!mt)\r\nreturn -1;\r\nfor (s = mt->slots; s != mt->slots + mt->num_slots; s++)\r\nif (input_mt_is_active(s) && s->key == key)\r\nreturn s - mt->slots;\r\nfor (s = mt->slots; s != mt->slots + mt->num_slots; s++)\r\nif (!input_mt_is_active(s) && !input_mt_is_used(mt, s)) {\r\ns->key = key;\r\nreturn s - mt->slots;\r\n}\r\nreturn -1;\r\n}
