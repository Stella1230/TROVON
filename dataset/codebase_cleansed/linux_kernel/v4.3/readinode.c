static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\r\n{\r\nstruct jffs2_raw_node_ref *ref = tn->fn->raw;\r\nint err = 0, pointed = 0;\r\nstruct jffs2_eraseblock *jeb;\r\nunsigned char *buffer;\r\nuint32_t crc, ofs, len;\r\nsize_t retlen;\r\nBUG_ON(tn->csize == 0);\r\nofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\r\nlen = tn->csize;\r\nif (jffs2_is_writebuffered(c)) {\r\nint adj = ofs % c->wbuf_pagesize;\r\nif (likely(adj))\r\nadj = c->wbuf_pagesize - adj;\r\nif (adj >= tn->csize) {\r\ndbg_readinode("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",\r\nref_offset(ref), tn->csize, ofs);\r\ngoto adj_acc;\r\n}\r\nofs += adj;\r\nlen -= adj;\r\n}\r\ndbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",\r\nref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\r\n#ifndef __ECOS\r\nerr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\r\nif (!err && retlen < len) {\r\nJFFS2_WARNING("MTD point returned len too short: %zu instead of %u.\n", retlen, tn->csize);\r\nmtd_unpoint(c->mtd, ofs, retlen);\r\n} else if (err) {\r\nif (err != -EOPNOTSUPP)\r\nJFFS2_WARNING("MTD point failed: error code %d.\n", err);\r\n} else\r\npointed = 1;\r\n#endif\r\nif (!pointed) {\r\nbuffer = kmalloc(len, GFP_KERNEL);\r\nif (unlikely(!buffer))\r\nreturn -ENOMEM;\r\nerr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\r\nif (err) {\r\nJFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);\r\ngoto free_out;\r\n}\r\nif (retlen != len) {\r\nJFFS2_ERROR("short read at %#08x: %zd instead of %d.\n", ofs, retlen, len);\r\nerr = -EIO;\r\ngoto free_out;\r\n}\r\n}\r\ncrc = crc32(tn->partial_crc, buffer, len);\r\nif(!pointed)\r\nkfree(buffer);\r\n#ifndef __ECOS\r\nelse\r\nmtd_unpoint(c->mtd, ofs, len);\r\n#endif\r\nif (crc != tn->data_crc) {\r\nJFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",\r\nref_offset(ref), tn->data_crc, crc);\r\nreturn 1;\r\n}\r\nadj_acc:\r\njeb = &c->blocks[ref->flash_offset / c->sector_size];\r\nlen = ref_totlen(c, jeb, ref);\r\nref->flash_offset |= REF_PRISTINE;\r\nspin_lock(&c->erase_completion_lock);\r\njeb->used_size += len;\r\njeb->unchecked_size -= len;\r\nc->used_size += len;\r\nc->unchecked_size -= len;\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\nspin_unlock(&c->erase_completion_lock);\r\nreturn 0;\r\nfree_out:\r\nif(!pointed)\r\nkfree(buffer);\r\n#ifndef __ECOS\r\nelse\r\nmtd_unpoint(c->mtd, ofs, len);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\r\n{\r\nint ret;\r\nBUG_ON(ref_obsolete(tn->fn->raw));\r\nif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\r\nreturn 0;\r\ndbg_readinode("check node %#04x-%#04x, phys offs %#08x\n",\r\ntn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\r\nret = check_node_data(c, tn);\r\nif (unlikely(ret < 0)) {\r\nJFFS2_ERROR("check_node_data() returned error: %d.\n",\r\nret);\r\n} else if (unlikely(ret > 0)) {\r\ndbg_readinode("CRC error, mark it obsolete.\n");\r\njffs2_mark_node_obsolete(c, tn->fn->raw);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\r\n{\r\nstruct rb_node *next;\r\nstruct jffs2_tmp_dnode_info *tn = NULL;\r\ndbg_readinode("root %p, offset %d\n", tn_root, offset);\r\nnext = tn_root->rb_node;\r\nwhile (next) {\r\ntn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\r\nif (tn->fn->ofs < offset)\r\nnext = tn->rb.rb_right;\r\nelse if (tn->fn->ofs >= offset)\r\nnext = tn->rb.rb_left;\r\nelse\r\nbreak;\r\n}\r\nreturn tn;\r\n}\r\nstatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\r\n{\r\njffs2_mark_node_obsolete(c, tn->fn->raw);\r\njffs2_free_full_dnode(tn->fn);\r\njffs2_free_tmp_dnode_info(tn);\r\n}\r\nstatic int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,\r\nstruct jffs2_readinode_info *rii,\r\nstruct jffs2_tmp_dnode_info *tn)\r\n{\r\nuint32_t fn_end = tn->fn->ofs + tn->fn->size;\r\nstruct jffs2_tmp_dnode_info *this, *ptn;\r\ndbg_readinode("insert fragment %#04x-%#04x, ver %u at %08x\n", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));\r\nif (!tn->fn->size) {\r\nif (rii->mdata_tn) {\r\nif (rii->mdata_tn->version < tn->version) {\r\ndbg_readinode("kill old mdata with ver %d\n", rii->mdata_tn->version);\r\njffs2_kill_tn(c, rii->mdata_tn);\r\n} else {\r\ndbg_readinode("kill new mdata with ver %d (older than existing %d\n",\r\ntn->version, rii->mdata_tn->version);\r\njffs2_kill_tn(c, tn);\r\nreturn 0;\r\n}\r\n}\r\nrii->mdata_tn = tn;\r\ndbg_readinode("keep new mdata with ver %d\n", tn->version);\r\nreturn 0;\r\n}\r\nthis = jffs2_lookup_tn(&rii->tn_root, tn->fn->ofs);\r\nif (this) {\r\nwhile (this->overlapped) {\r\nptn = tn_prev(this);\r\nif (!ptn) {\r\nthis->overlapped = 0;\r\nbreak;\r\n}\r\nthis = ptn;\r\n}\r\ndbg_readinode("'this' found %#04x-%#04x (%s)\n", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? "data" : "hole");\r\n}\r\nwhile (this) {\r\nif (this->fn->ofs > fn_end)\r\nbreak;\r\ndbg_readinode("Ponder this ver %d, 0x%x-0x%x\n",\r\nthis->version, this->fn->ofs, this->fn->size);\r\nif (this->version == tn->version) {\r\nif (!check_tn_node(c, this)) {\r\ndbg_readinode("Like old node. Throw away new\n");\r\njffs2_kill_tn(c, tn);\r\nreturn 0;\r\n} else {\r\ndbg_readinode("Like new node. Throw away old\n");\r\nrb_replace_node(&this->rb, &tn->rb, &rii->tn_root);\r\njffs2_kill_tn(c, this);\r\nreturn 0;\r\n}\r\n}\r\nif (this->version < tn->version &&\r\nthis->fn->ofs >= tn->fn->ofs &&\r\nthis->fn->ofs + this->fn->size <= fn_end) {\r\nif (check_tn_node(c, tn)) {\r\ndbg_readinode("new node bad CRC\n");\r\njffs2_kill_tn(c, tn);\r\nreturn 0;\r\n}\r\nwhile (this && this->fn->ofs + this->fn->size <= fn_end) {\r\nstruct jffs2_tmp_dnode_info *next = tn_next(this);\r\nif (this->version < tn->version) {\r\ntn_erase(this, &rii->tn_root);\r\ndbg_readinode("Kill overlapped ver %d, 0x%x-0x%x\n",\r\nthis->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size);\r\njffs2_kill_tn(c, this);\r\n}\r\nthis = next;\r\n}\r\ndbg_readinode("Done killing overlapped nodes\n");\r\ncontinue;\r\n}\r\nif (this->version > tn->version &&\r\nthis->fn->ofs <= tn->fn->ofs &&\r\nthis->fn->ofs+this->fn->size >= fn_end) {\r\nif (!check_tn_node(c, this)) {\r\ndbg_readinode("Good CRC on old node. Kill new\n");\r\njffs2_kill_tn(c, tn);\r\nreturn 0;\r\n}\r\ndbg_readinode("Bad CRC on old overlapping node. Kill it\n");\r\ntn_erase(this, &rii->tn_root);\r\njffs2_kill_tn(c, this);\r\nbreak;\r\n}\r\nthis = tn_next(this);\r\n}\r\n{\r\nstruct rb_node *parent;\r\nstruct rb_node **link = &rii->tn_root.rb_node;\r\nstruct jffs2_tmp_dnode_info *insert_point = NULL;\r\nwhile (*link) {\r\nparent = *link;\r\ninsert_point = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\r\nif (tn->fn->ofs > insert_point->fn->ofs)\r\nlink = &insert_point->rb.rb_right;\r\nelse if (tn->fn->ofs < insert_point->fn->ofs ||\r\ntn->fn->size < insert_point->fn->size)\r\nlink = &insert_point->rb.rb_left;\r\nelse\r\nlink = &insert_point->rb.rb_right;\r\n}\r\nrb_link_node(&tn->rb, &insert_point->rb, link);\r\nrb_insert_color(&tn->rb, &rii->tn_root);\r\n}\r\nthis = tn_prev(tn);\r\nif (this) {\r\nwhile (1) {\r\nif (this->fn->ofs + this->fn->size > tn->fn->ofs) {\r\ndbg_readinode("Node is overlapped by %p (v %d, 0x%x-0x%x)\n",\r\nthis, this->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size);\r\ntn->overlapped = 1;\r\nbreak;\r\n}\r\nif (!this->overlapped)\r\nbreak;\r\nptn = tn_prev(this);\r\nif (!ptn) {\r\nthis->overlapped = 0;\r\nbreak;\r\n}\r\nthis = ptn;\r\n}\r\n}\r\nthis = tn_next(tn);\r\nwhile (this && this->fn->ofs < fn_end) {\r\nthis->overlapped = 1;\r\ndbg_readinode("Node ver %d, 0x%x-0x%x is overlapped\n",\r\nthis->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size);\r\nthis = tn_next(this);\r\n}\r\nreturn 0;\r\n}\r\nstatic void eat_last(struct rb_root *root, struct rb_node *node)\r\n{\r\nstruct rb_node *parent = rb_parent(node);\r\nstruct rb_node **link;\r\nBUG_ON(node->rb_right);\r\nif (!parent)\r\nlink = &root->rb_node;\r\nelse if (node == parent->rb_left)\r\nlink = &parent->rb_left;\r\nelse\r\nlink = &parent->rb_right;\r\n*link = node->rb_left;\r\nif (node->rb_left)\r\nnode->rb_left->__rb_parent_color = node->__rb_parent_color;\r\n}\r\nstatic void ver_insert(struct rb_root *ver_root, struct jffs2_tmp_dnode_info *tn)\r\n{\r\nstruct rb_node **link = &ver_root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct jffs2_tmp_dnode_info *this_tn;\r\nwhile (*link) {\r\nparent = *link;\r\nthis_tn = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\r\nif (tn->version > this_tn->version)\r\nlink = &parent->rb_left;\r\nelse\r\nlink = &parent->rb_right;\r\n}\r\ndbg_readinode("Link new node at %p (root is %p)\n", link, ver_root);\r\nrb_link_node(&tn->rb, parent, link);\r\nrb_insert_color(&tn->rb, ver_root);\r\n}\r\nstatic int jffs2_build_inode_fragtree(struct jffs2_sb_info *c,\r\nstruct jffs2_inode_info *f,\r\nstruct jffs2_readinode_info *rii)\r\n{\r\nstruct jffs2_tmp_dnode_info *pen, *last, *this;\r\nstruct rb_root ver_root = RB_ROOT;\r\nuint32_t high_ver = 0;\r\nif (rii->mdata_tn) {\r\ndbg_readinode("potential mdata is ver %d at %p\n", rii->mdata_tn->version, rii->mdata_tn);\r\nhigh_ver = rii->mdata_tn->version;\r\nrii->latest_ref = rii->mdata_tn->fn->raw;\r\n}\r\n#ifdef JFFS2_DBG_READINODE_MESSAGES\r\nthis = tn_last(&rii->tn_root);\r\nwhile (this) {\r\ndbg_readinode("tn %p ver %d range 0x%x-0x%x ov %d\n", this, this->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size, this->overlapped);\r\nthis = tn_prev(this);\r\n}\r\n#endif\r\npen = tn_last(&rii->tn_root);\r\nwhile ((last = pen)) {\r\npen = tn_prev(last);\r\neat_last(&rii->tn_root, &last->rb);\r\nver_insert(&ver_root, last);\r\nif (unlikely(last->overlapped)) {\r\nif (pen)\r\ncontinue;\r\nlast->overlapped = 0;\r\n}\r\nthis = tn_last(&ver_root);\r\nwhile (this) {\r\nstruct jffs2_tmp_dnode_info *vers_next;\r\nint ret;\r\nvers_next = tn_prev(this);\r\neat_last(&ver_root, &this->rb);\r\nif (check_tn_node(c, this)) {\r\ndbg_readinode("node ver %d, 0x%x-0x%x failed CRC\n",\r\nthis->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size);\r\njffs2_kill_tn(c, this);\r\n} else {\r\nif (this->version > high_ver) {\r\nhigh_ver = this->version;\r\nrii->latest_ref = this->fn->raw;\r\n}\r\ndbg_readinode("Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree\n",\r\nthis, this->version, this->fn->ofs,\r\nthis->fn->ofs+this->fn->size, this->overlapped);\r\nret = jffs2_add_full_dnode_to_inode(c, f, this->fn);\r\nif (ret) {\r\nJFFS2_ERROR("Add node to tree failed %d\n", ret);\r\nwhile (1) {\r\nvers_next = tn_prev(this);\r\nif (check_tn_node(c, this))\r\njffs2_mark_node_obsolete(c, this->fn->raw);\r\njffs2_free_full_dnode(this->fn);\r\njffs2_free_tmp_dnode_info(this);\r\nthis = vers_next;\r\nif (!this)\r\nbreak;\r\neat_last(&ver_root, &vers_next->rb);\r\n}\r\nreturn ret;\r\n}\r\njffs2_free_tmp_dnode_info(this);\r\n}\r\nthis = vers_next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void jffs2_free_tmp_dnode_info_list(struct rb_root *list)\r\n{\r\nstruct jffs2_tmp_dnode_info *tn, *next;\r\nrbtree_postorder_for_each_entry_safe(tn, next, list, rb) {\r\njffs2_free_full_dnode(tn->fn);\r\njffs2_free_tmp_dnode_info(tn);\r\n}\r\n*list = RB_ROOT;\r\n}\r\nstatic void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)\r\n{\r\nstruct jffs2_full_dirent *next;\r\nwhile (fd) {\r\nnext = fd->next;\r\njffs2_free_full_dirent(fd);\r\nfd = next;\r\n}\r\n}\r\nstatic struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)\r\n{\r\nwhile (ref && ref->next_in_ino) {\r\nif (!ref_obsolete(ref))\r\nreturn ref;\r\ndbg_noderef("node at 0x%08x is obsoleted. Ignoring.\n", ref_offset(ref));\r\nref = ref->next_in_ino;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int read_direntry(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\r\nstruct jffs2_raw_dirent *rd, size_t read,\r\nstruct jffs2_readinode_info *rii)\r\n{\r\nstruct jffs2_full_dirent *fd;\r\nuint32_t crc;\r\nBUG_ON(ref_obsolete(ref));\r\ncrc = crc32(0, rd, sizeof(*rd) - 8);\r\nif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\r\nJFFS2_NOTICE("header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\n",\r\nref_offset(ref), je32_to_cpu(rd->node_crc), crc);\r\njffs2_mark_node_obsolete(c, ref);\r\nreturn 0;\r\n}\r\nif (ref_flags(ref) == REF_UNCHECKED) {\r\nstruct jffs2_eraseblock *jeb;\r\nint len;\r\nif (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {\r\nJFFS2_ERROR("illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\n",\r\nref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));\r\njffs2_mark_node_obsolete(c, ref);\r\nreturn 0;\r\n}\r\njeb = &c->blocks[ref->flash_offset / c->sector_size];\r\nlen = ref_totlen(c, jeb, ref);\r\nspin_lock(&c->erase_completion_lock);\r\njeb->used_size += len;\r\njeb->unchecked_size -= len;\r\nc->used_size += len;\r\nc->unchecked_size -= len;\r\nref->flash_offset = ref_offset(ref) | dirent_node_state(rd);\r\nspin_unlock(&c->erase_completion_lock);\r\n}\r\nfd = jffs2_alloc_full_dirent(rd->nsize + 1);\r\nif (unlikely(!fd))\r\nreturn -ENOMEM;\r\nfd->raw = ref;\r\nfd->version = je32_to_cpu(rd->version);\r\nfd->ino = je32_to_cpu(rd->ino);\r\nfd->type = rd->type;\r\nif (fd->version > rii->highest_version)\r\nrii->highest_version = fd->version;\r\nif(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {\r\nrii->mctime_ver = fd->version;\r\nrii->latest_mctime = je32_to_cpu(rd->mctime);\r\n}\r\nif (read > sizeof(*rd))\r\nmemcpy(&fd->name[0], &rd->name[0],\r\nmin_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));\r\nif (rd->nsize + sizeof(*rd) > read) {\r\nint err;\r\nint already = read - sizeof(*rd);\r\nerr = jffs2_flash_read(c, (ref_offset(ref)) + read,\r\nrd->nsize - already, &read, &fd->name[already]);\r\nif (unlikely(read != rd->nsize - already) && likely(!err))\r\nreturn -EIO;\r\nif (unlikely(err)) {\r\nJFFS2_ERROR("read remainder of name: error %d\n", err);\r\njffs2_free_full_dirent(fd);\r\nreturn -EIO;\r\n}\r\n}\r\nfd->nhash = full_name_hash(fd->name, rd->nsize);\r\nfd->next = NULL;\r\nfd->name[rd->nsize] = '\0';\r\njffs2_add_fd_to_list(c, fd, &rii->fds);\r\nreturn 0;\r\n}\r\nstatic inline int read_dnode(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\r\nstruct jffs2_raw_inode *rd, int rdlen,\r\nstruct jffs2_readinode_info *rii)\r\n{\r\nstruct jffs2_tmp_dnode_info *tn;\r\nuint32_t len, csize;\r\nint ret = 0;\r\nuint32_t crc;\r\nBUG_ON(ref_obsolete(ref));\r\ncrc = crc32(0, rd, sizeof(*rd) - 8);\r\nif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\r\nJFFS2_NOTICE("node CRC failed on dnode at %#08x: read %#08x, calculated %#08x\n",\r\nref_offset(ref), je32_to_cpu(rd->node_crc), crc);\r\njffs2_mark_node_obsolete(c, ref);\r\nreturn 0;\r\n}\r\ntn = jffs2_alloc_tmp_dnode_info();\r\nif (!tn) {\r\nJFFS2_ERROR("failed to allocate tn (%zu bytes).\n", sizeof(*tn));\r\nreturn -ENOMEM;\r\n}\r\ntn->partial_crc = 0;\r\ncsize = je32_to_cpu(rd->csize);\r\nif (ref_flags(ref) == REF_UNCHECKED) {\r\nif (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||\r\nunlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {\r\nJFFS2_WARNING("inode node header CRC is corrupted at %#08x\n", ref_offset(ref));\r\njffs2_dbg_dump_node(c, ref_offset(ref));\r\njffs2_mark_node_obsolete(c, ref);\r\ngoto free_out;\r\n}\r\nif (jffs2_is_writebuffered(c) && csize != 0) {\r\nunsigned char *buf;\r\nbuf = (unsigned char *)rd + sizeof(*rd);\r\nlen = min_t(uint32_t, rdlen - sizeof(*rd), csize);\r\ntn->partial_crc = crc32(0, buf, len);\r\ndbg_readinode("Calculates CRC (%#08x) for %d bytes, csize %d\n", tn->partial_crc, len, csize);\r\nif (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {\r\nJFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",\r\nref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));\r\njffs2_mark_node_obsolete(c, ref);\r\ngoto free_out;\r\n}\r\n} else if (csize == 0) {\r\nstruct jffs2_eraseblock *jeb;\r\ndbg_readinode("the node has no data.\n");\r\njeb = &c->blocks[ref->flash_offset / c->sector_size];\r\nlen = ref_totlen(c, jeb, ref);\r\nspin_lock(&c->erase_completion_lock);\r\njeb->used_size += len;\r\njeb->unchecked_size -= len;\r\nc->used_size += len;\r\nc->unchecked_size -= len;\r\nref->flash_offset = ref_offset(ref) | REF_NORMAL;\r\nspin_unlock(&c->erase_completion_lock);\r\n}\r\n}\r\ntn->fn = jffs2_alloc_full_dnode();\r\nif (!tn->fn) {\r\nJFFS2_ERROR("alloc fn failed\n");\r\nret = -ENOMEM;\r\ngoto free_out;\r\n}\r\ntn->version = je32_to_cpu(rd->version);\r\ntn->fn->ofs = je32_to_cpu(rd->offset);\r\ntn->data_crc = je32_to_cpu(rd->data_crc);\r\ntn->csize = csize;\r\ntn->fn->raw = ref;\r\ntn->overlapped = 0;\r\nif (tn->version > rii->highest_version)\r\nrii->highest_version = tn->version;\r\nif (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && csize)\r\ntn->fn->size = csize;\r\nelse\r\ntn->fn->size = je32_to_cpu(rd->dsize);\r\ndbg_readinode2("dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\n",\r\nref_offset(ref), je32_to_cpu(rd->version),\r\nje32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);\r\nret = jffs2_add_tn_to_tree(c, rii, tn);\r\nif (ret) {\r\njffs2_free_full_dnode(tn->fn);\r\nfree_out:\r\njffs2_free_tmp_dnode_info(tn);\r\nreturn ret;\r\n}\r\n#ifdef JFFS2_DBG_READINODE2_MESSAGES\r\ndbg_readinode2("After adding ver %d:\n", je32_to_cpu(rd->version));\r\ntn = tn_first(&rii->tn_root);\r\nwhile (tn) {\r\ndbg_readinode2("%p: v %d r 0x%x-0x%x ov %d\n",\r\ntn, tn->version, tn->fn->ofs,\r\ntn->fn->ofs+tn->fn->size, tn->overlapped);\r\ntn = tn_next(tn);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int read_unknown(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref, struct jffs2_unknown_node *un)\r\n{\r\nif (ref_flags(ref) == REF_UNCHECKED) {\r\nJFFS2_ERROR("REF_UNCHECKED but unknown node at %#08x\n",\r\nref_offset(ref));\r\nJFFS2_ERROR("Node is {%04x,%04x,%08x,%08x}. Please report this error.\n",\r\nje16_to_cpu(un->magic), je16_to_cpu(un->nodetype),\r\nje32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));\r\njffs2_mark_node_obsolete(c, ref);\r\nreturn 0;\r\n}\r\nun->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));\r\nswitch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {\r\ncase JFFS2_FEATURE_INCOMPAT:\r\nJFFS2_ERROR("unknown INCOMPAT nodetype %#04X at %#08x\n",\r\nje16_to_cpu(un->nodetype), ref_offset(ref));\r\nBUG();\r\nbreak;\r\ncase JFFS2_FEATURE_ROCOMPAT:\r\nJFFS2_ERROR("unknown ROCOMPAT nodetype %#04X at %#08x\n",\r\nje16_to_cpu(un->nodetype), ref_offset(ref));\r\nBUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));\r\nbreak;\r\ncase JFFS2_FEATURE_RWCOMPAT_COPY:\r\nJFFS2_NOTICE("unknown RWCOMPAT_COPY nodetype %#04X at %#08x\n",\r\nje16_to_cpu(un->nodetype), ref_offset(ref));\r\nbreak;\r\ncase JFFS2_FEATURE_RWCOMPAT_DELETE:\r\nJFFS2_NOTICE("unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\n",\r\nje16_to_cpu(un->nodetype), ref_offset(ref));\r\njffs2_mark_node_obsolete(c, ref);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\r\nint needed_len, int *rdlen, unsigned char *buf)\r\n{\r\nint err, to_read = needed_len - *rdlen;\r\nsize_t retlen;\r\nuint32_t offs;\r\nif (jffs2_is_writebuffered(c)) {\r\nint rem = to_read % c->wbuf_pagesize;\r\nif (rem)\r\nto_read += c->wbuf_pagesize - rem;\r\n}\r\noffs = ref_offset(ref) + *rdlen;\r\ndbg_readinode("read more %d bytes\n", to_read);\r\nerr = jffs2_flash_read(c, offs, to_read, &retlen, buf + *rdlen);\r\nif (err) {\r\nJFFS2_ERROR("can not read %d bytes from 0x%08x, "\r\n"error code: %d.\n", to_read, offs, err);\r\nreturn err;\r\n}\r\nif (retlen < to_read) {\r\nJFFS2_ERROR("short read at %#08x: %zu instead of %d.\n",\r\noffs, retlen, to_read);\r\nreturn -EIO;\r\n}\r\n*rdlen += to_read;\r\nreturn 0;\r\n}\r\nstatic int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\r\nstruct jffs2_readinode_info *rii)\r\n{\r\nstruct jffs2_raw_node_ref *ref, *valid_ref;\r\nunsigned char *buf = NULL;\r\nunion jffs2_node_union *node;\r\nsize_t retlen;\r\nint len, err;\r\nrii->mctime_ver = 0;\r\ndbg_readinode("ino #%u\n", f->inocache->ino);\r\nlen = sizeof(union jffs2_node_union) + c->wbuf_pagesize;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nspin_lock(&c->erase_completion_lock);\r\nvalid_ref = jffs2_first_valid_node(f->inocache->nodes);\r\nif (!valid_ref && f->inocache->ino != 1)\r\nJFFS2_WARNING("Eep. No valid nodes for ino #%u.\n", f->inocache->ino);\r\nwhile (valid_ref) {\r\nref = valid_ref;\r\nvalid_ref = jffs2_first_valid_node(ref->next_in_ino);\r\nspin_unlock(&c->erase_completion_lock);\r\ncond_resched();\r\nlen = JFFS2_MIN_NODE_HEADER;\r\nif (jffs2_is_writebuffered(c)) {\r\nint end, rem;\r\nend = ref_offset(ref) + len;\r\nrem = end % c->wbuf_pagesize;\r\nif (rem)\r\nend += c->wbuf_pagesize - rem;\r\nlen = end - ref_offset(ref);\r\n}\r\ndbg_readinode("read %d bytes at %#08x(%d).\n", len, ref_offset(ref), ref_flags(ref));\r\nerr = jffs2_flash_read(c, ref_offset(ref), len, &retlen, buf);\r\nif (err) {\r\nJFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ref_offset(ref), err);\r\ngoto free_out;\r\n}\r\nif (retlen < len) {\r\nJFFS2_ERROR("short read at %#08x: %zu instead of %d.\n", ref_offset(ref), retlen, len);\r\nerr = -EIO;\r\ngoto free_out;\r\n}\r\nnode = (union jffs2_node_union *)buf;\r\nif (je32_to_cpu(node->u.hdr_crc) != crc32(0, node, sizeof(node->u)-4)) {\r\nJFFS2_NOTICE("Node header CRC failed at %#08x. {%04x,%04x,%08x,%08x}\n",\r\nref_offset(ref), je16_to_cpu(node->u.magic),\r\nje16_to_cpu(node->u.nodetype),\r\nje32_to_cpu(node->u.totlen),\r\nje32_to_cpu(node->u.hdr_crc));\r\njffs2_dbg_dump_node(c, ref_offset(ref));\r\njffs2_mark_node_obsolete(c, ref);\r\ngoto cont;\r\n}\r\nif (je16_to_cpu(node->u.magic) != JFFS2_MAGIC_BITMASK) {\r\nJFFS2_NOTICE("Wrong magic bitmask 0x%04x in node header at %#08x.\n",\r\nje16_to_cpu(node->u.magic), ref_offset(ref));\r\njffs2_mark_node_obsolete(c, ref);\r\ngoto cont;\r\n}\r\nswitch (je16_to_cpu(node->u.nodetype)) {\r\ncase JFFS2_NODETYPE_DIRENT:\r\nif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent) &&\r\nlen < sizeof(struct jffs2_raw_dirent)) {\r\nerr = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf);\r\nif (unlikely(err))\r\ngoto free_out;\r\n}\r\nerr = read_direntry(c, ref, &node->d, retlen, rii);\r\nif (unlikely(err))\r\ngoto free_out;\r\nbreak;\r\ncase JFFS2_NODETYPE_INODE:\r\nif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode) &&\r\nlen < sizeof(struct jffs2_raw_inode)) {\r\nerr = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf);\r\nif (unlikely(err))\r\ngoto free_out;\r\n}\r\nerr = read_dnode(c, ref, &node->i, len, rii);\r\nif (unlikely(err))\r\ngoto free_out;\r\nbreak;\r\ndefault:\r\nif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node) &&\r\nlen < sizeof(struct jffs2_unknown_node)) {\r\nerr = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf);\r\nif (unlikely(err))\r\ngoto free_out;\r\n}\r\nerr = read_unknown(c, ref, &node->u);\r\nif (unlikely(err))\r\ngoto free_out;\r\n}\r\ncont:\r\nspin_lock(&c->erase_completion_lock);\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nkfree(buf);\r\nf->highest_version = rii->highest_version;\r\ndbg_readinode("nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\n",\r\nf->inocache->ino, rii->highest_version, rii->latest_mctime,\r\nrii->mctime_ver);\r\nreturn 0;\r\nfree_out:\r\njffs2_free_tmp_dnode_info_list(&rii->tn_root);\r\njffs2_free_full_dirent_list(rii->fds);\r\nrii->fds = NULL;\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,\r\nstruct jffs2_inode_info *f,\r\nstruct jffs2_raw_inode *latest_node)\r\n{\r\nstruct jffs2_readinode_info rii;\r\nuint32_t crc, new_size;\r\nsize_t retlen;\r\nint ret;\r\ndbg_readinode("ino #%u pino/nlink is %d\n", f->inocache->ino,\r\nf->inocache->pino_nlink);\r\nmemset(&rii, 0, sizeof(rii));\r\nret = jffs2_get_inode_nodes(c, f, &rii);\r\nif (ret) {\r\nJFFS2_ERROR("cannot read nodes for ino %u, returned error is %d\n", f->inocache->ino, ret);\r\nif (f->inocache->state == INO_STATE_READING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\r\nreturn ret;\r\n}\r\nret = jffs2_build_inode_fragtree(c, f, &rii);\r\nif (ret) {\r\nJFFS2_ERROR("Failed to build final fragtree for inode #%u: error %d\n",\r\nf->inocache->ino, ret);\r\nif (f->inocache->state == INO_STATE_READING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\r\njffs2_free_tmp_dnode_info_list(&rii.tn_root);\r\nif (rii.mdata_tn) {\r\njffs2_free_full_dnode(rii.mdata_tn->fn);\r\njffs2_free_tmp_dnode_info(rii.mdata_tn);\r\nrii.mdata_tn = NULL;\r\n}\r\nreturn ret;\r\n}\r\nif (rii.mdata_tn) {\r\nif (rii.mdata_tn->fn->raw == rii.latest_ref) {\r\nf->metadata = rii.mdata_tn->fn;\r\njffs2_free_tmp_dnode_info(rii.mdata_tn);\r\n} else {\r\njffs2_kill_tn(c, rii.mdata_tn);\r\n}\r\nrii.mdata_tn = NULL;\r\n}\r\nf->dents = rii.fds;\r\njffs2_dbg_fragtree_paranoia_check_nolock(f);\r\nif (unlikely(!rii.latest_ref)) {\r\nif (f->inocache->ino != 1) {\r\nJFFS2_WARNING("no data nodes found for ino #%u\n", f->inocache->ino);\r\nif (!rii.fds) {\r\nif (f->inocache->state == INO_STATE_READING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\r\nreturn -EIO;\r\n}\r\nJFFS2_NOTICE("but it has children so we fake some modes for it\n");\r\n}\r\nlatest_node->mode = cpu_to_jemode(S_IFDIR|S_IRUGO|S_IWUSR|S_IXUGO);\r\nlatest_node->version = cpu_to_je32(0);\r\nlatest_node->atime = latest_node->ctime = latest_node->mtime = cpu_to_je32(0);\r\nlatest_node->isize = cpu_to_je32(0);\r\nlatest_node->gid = cpu_to_je16(0);\r\nlatest_node->uid = cpu_to_je16(0);\r\nif (f->inocache->state == INO_STATE_READING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\r\nreturn 0;\r\n}\r\nret = jffs2_flash_read(c, ref_offset(rii.latest_ref), sizeof(*latest_node), &retlen, (void *)latest_node);\r\nif (ret || retlen != sizeof(*latest_node)) {\r\nJFFS2_ERROR("failed to read from flash: error %d, %zd of %zd bytes read\n",\r\nret, retlen, sizeof(*latest_node));\r\nreturn ret ? ret : -EIO;\r\n}\r\ncrc = crc32(0, latest_node, sizeof(*latest_node)-8);\r\nif (crc != je32_to_cpu(latest_node->node_crc)) {\r\nJFFS2_ERROR("CRC failed for read_inode of inode %u at physical location 0x%x\n",\r\nf->inocache->ino, ref_offset(rii.latest_ref));\r\nreturn -EIO;\r\n}\r\nswitch(jemode_to_cpu(latest_node->mode) & S_IFMT) {\r\ncase S_IFDIR:\r\nif (rii.mctime_ver > je32_to_cpu(latest_node->version)) {\r\nlatest_node->ctime = latest_node->mtime = cpu_to_je32(rii.latest_mctime);\r\n}\r\nbreak;\r\ncase S_IFREG:\r\nnew_size = jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));\r\nif (new_size != je32_to_cpu(latest_node->isize)) {\r\nJFFS2_WARNING("Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!\n",\r\nf->inocache->ino, je32_to_cpu(latest_node->isize), new_size);\r\nlatest_node->isize = cpu_to_je32(new_size);\r\n}\r\nbreak;\r\ncase S_IFLNK:\r\nif (!je32_to_cpu(latest_node->isize))\r\nlatest_node->isize = latest_node->dsize;\r\nif (f->inocache->state != INO_STATE_CHECKING) {\r\nuint32_t csize = je32_to_cpu(latest_node->csize);\r\nif (csize > JFFS2_MAX_NAME_LEN)\r\nreturn -ENAMETOOLONG;\r\nf->target = kmalloc(csize + 1, GFP_KERNEL);\r\nif (!f->target) {\r\nJFFS2_ERROR("can't allocate %u bytes of memory for the symlink target path cache\n", csize);\r\nreturn -ENOMEM;\r\n}\r\nret = jffs2_flash_read(c, ref_offset(rii.latest_ref) + sizeof(*latest_node),\r\ncsize, &retlen, (char *)f->target);\r\nif (ret || retlen != csize) {\r\nif (retlen != csize)\r\nret = -EIO;\r\nkfree(f->target);\r\nf->target = NULL;\r\nreturn ret;\r\n}\r\nf->target[csize] = '\0';\r\ndbg_readinode("symlink's target '%s' cached\n", f->target);\r\n}\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\nif (f->metadata) {\r\nJFFS2_ERROR("Argh. Special inode #%u with mode 0%o had metadata node\n",\r\nf->inocache->ino, jemode_to_cpu(latest_node->mode));\r\nreturn -EIO;\r\n}\r\nif (!frag_first(&f->fragtree)) {\r\nJFFS2_ERROR("Argh. Special inode #%u with mode 0%o has no fragments\n",\r\nf->inocache->ino, jemode_to_cpu(latest_node->mode));\r\nreturn -EIO;\r\n}\r\nif (frag_next(frag_first(&f->fragtree))) {\r\nJFFS2_ERROR("Argh. Special inode #%u with mode 0x%x had more than one node\n",\r\nf->inocache->ino, jemode_to_cpu(latest_node->mode));\r\nreturn -EIO;\r\n}\r\nf->metadata = frag_first(&f->fragtree)->node;\r\njffs2_free_node_frag(frag_first(&f->fragtree));\r\nf->fragtree = RB_ROOT;\r\nbreak;\r\n}\r\nif (f->inocache->state == INO_STATE_READING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\r\nreturn 0;\r\n}\r\nint jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\r\nuint32_t ino, struct jffs2_raw_inode *latest_node)\r\n{\r\ndbg_readinode("read inode #%u\n", ino);\r\nretry_inocache:\r\nspin_lock(&c->inocache_lock);\r\nf->inocache = jffs2_get_ino_cache(c, ino);\r\nif (f->inocache) {\r\nswitch(f->inocache->state) {\r\ncase INO_STATE_UNCHECKED:\r\ncase INO_STATE_CHECKEDABSENT:\r\nf->inocache->state = INO_STATE_READING;\r\nbreak;\r\ncase INO_STATE_CHECKING:\r\ncase INO_STATE_GC:\r\ndbg_readinode("waiting for ino #%u in state %d\n", ino, f->inocache->state);\r\nsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\r\ngoto retry_inocache;\r\ncase INO_STATE_READING:\r\ncase INO_STATE_PRESENT:\r\nJFFS2_ERROR("Eep. Trying to read_inode #%u when it's already in state %d!\n", ino, f->inocache->state);\r\nf->inocache = NULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nspin_unlock(&c->inocache_lock);\r\nif (!f->inocache && ino == 1) {\r\nf->inocache = jffs2_alloc_inode_cache();\r\nif (!f->inocache) {\r\nJFFS2_ERROR("cannot allocate inocache for root inode\n");\r\nreturn -ENOMEM;\r\n}\r\ndbg_readinode("creating inocache for root inode\n");\r\nmemset(f->inocache, 0, sizeof(struct jffs2_inode_cache));\r\nf->inocache->ino = f->inocache->pino_nlink = 1;\r\nf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\r\nf->inocache->state = INO_STATE_READING;\r\njffs2_add_ino_cache(c, f->inocache);\r\n}\r\nif (!f->inocache) {\r\nJFFS2_ERROR("requestied to read an nonexistent ino %u\n", ino);\r\nreturn -ENOENT;\r\n}\r\nreturn jffs2_do_read_inode_internal(c, f, latest_node);\r\n}\r\nint jffs2_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\r\n{\r\nstruct jffs2_raw_inode n;\r\nstruct jffs2_inode_info *f = kzalloc(sizeof(*f), GFP_KERNEL);\r\nint ret;\r\nif (!f)\r\nreturn -ENOMEM;\r\nmutex_init(&f->sem);\r\nmutex_lock(&f->sem);\r\nf->inocache = ic;\r\nret = jffs2_do_read_inode_internal(c, f, &n);\r\nmutex_unlock(&f->sem);\r\njffs2_do_clear_inode(c, f);\r\njffs2_xattr_do_crccheck_inode(c, ic);\r\nkfree (f);\r\nreturn ret;\r\n}\r\nvoid jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f)\r\n{\r\nstruct jffs2_full_dirent *fd, *fds;\r\nint deleted;\r\njffs2_xattr_delete_inode(c, f->inocache);\r\nmutex_lock(&f->sem);\r\ndeleted = f->inocache && !f->inocache->pino_nlink;\r\nif (f->inocache && f->inocache->state != INO_STATE_CHECKING)\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_CLEARING);\r\nif (f->metadata) {\r\nif (deleted)\r\njffs2_mark_node_obsolete(c, f->metadata->raw);\r\njffs2_free_full_dnode(f->metadata);\r\n}\r\njffs2_kill_fragtree(&f->fragtree, deleted?c:NULL);\r\nif (f->target) {\r\nkfree(f->target);\r\nf->target = NULL;\r\n}\r\nfds = f->dents;\r\nwhile(fds) {\r\nfd = fds;\r\nfds = fd->next;\r\njffs2_free_full_dirent(fd);\r\n}\r\nif (f->inocache && f->inocache->state != INO_STATE_CHECKING) {\r\njffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\r\nif (f->inocache->nodes == (void *)f->inocache)\r\njffs2_del_ino_cache(c, f->inocache);\r\n}\r\nmutex_unlock(&f->sem);\r\n}
