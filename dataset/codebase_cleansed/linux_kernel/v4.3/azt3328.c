static int\r\nsnd_azf3328_io_reg_setb(unsigned reg, u8 mask, bool do_set)\r\n{\r\nu8 prev = inb(reg), new;\r\nnew = (do_set) ? (prev|mask) : (prev & ~mask);\r\noutb(new, reg);\r\nif (new != prev)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsnd_azf3328_codec_outb(const struct snd_azf3328_codec_data *codec,\r\nunsigned reg,\r\nu8 value\r\n)\r\n{\r\noutb(value, codec->io_base + reg);\r\n}\r\nstatic inline u8\r\nsnd_azf3328_codec_inb(const struct snd_azf3328_codec_data *codec, unsigned reg)\r\n{\r\nreturn inb(codec->io_base + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_codec_outw(const struct snd_azf3328_codec_data *codec,\r\nunsigned reg,\r\nu16 value\r\n)\r\n{\r\noutw(value, codec->io_base + reg);\r\n}\r\nstatic inline u16\r\nsnd_azf3328_codec_inw(const struct snd_azf3328_codec_data *codec, unsigned reg)\r\n{\r\nreturn inw(codec->io_base + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_codec_outl(const struct snd_azf3328_codec_data *codec,\r\nunsigned reg,\r\nu32 value\r\n)\r\n{\r\noutl(value, codec->io_base + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_codec_outl_multi(const struct snd_azf3328_codec_data *codec,\r\nunsigned reg, const void *buffer, int count\r\n)\r\n{\r\nunsigned long addr = codec->io_base + reg;\r\nif (count) {\r\nconst u32 *buf = buffer;\r\ndo {\r\noutl(*buf++, addr);\r\naddr += 4;\r\n} while (--count);\r\n}\r\n}\r\nstatic inline u32\r\nsnd_azf3328_codec_inl(const struct snd_azf3328_codec_data *codec, unsigned reg)\r\n{\r\nreturn inl(codec->io_base + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_ctrl_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)\r\n{\r\noutb(value, chip->ctrl_io + reg);\r\n}\r\nstatic inline u8\r\nsnd_azf3328_ctrl_inb(const struct snd_azf3328 *chip, unsigned reg)\r\n{\r\nreturn inb(chip->ctrl_io + reg);\r\n}\r\nstatic inline u16\r\nsnd_azf3328_ctrl_inw(const struct snd_azf3328 *chip, unsigned reg)\r\n{\r\nreturn inw(chip->ctrl_io + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_ctrl_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\r\n{\r\noutw(value, chip->ctrl_io + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_ctrl_outl(const struct snd_azf3328 *chip, unsigned reg, u32 value)\r\n{\r\noutl(value, chip->ctrl_io + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_game_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)\r\n{\r\noutb(value, chip->game_io + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_game_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\r\n{\r\noutw(value, chip->game_io + reg);\r\n}\r\nstatic inline u8\r\nsnd_azf3328_game_inb(const struct snd_azf3328 *chip, unsigned reg)\r\n{\r\nreturn inb(chip->game_io + reg);\r\n}\r\nstatic inline u16\r\nsnd_azf3328_game_inw(const struct snd_azf3328 *chip, unsigned reg)\r\n{\r\nreturn inw(chip->game_io + reg);\r\n}\r\nstatic inline void\r\nsnd_azf3328_mixer_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\r\n{\r\noutw(value, chip->mixer_io + reg);\r\n}\r\nstatic inline u16\r\nsnd_azf3328_mixer_inw(const struct snd_azf3328 *chip, unsigned reg)\r\n{\r\nreturn inw(chip->mixer_io + reg);\r\n}\r\nstatic bool\r\nsnd_azf3328_mixer_mute_control(const struct snd_azf3328 *chip,\r\nunsigned reg, bool do_mute\r\n)\r\n{\r\nunsigned long portbase = chip->mixer_io + reg + 1;\r\nbool updated;\r\nupdated = snd_azf3328_io_reg_setb(portbase, AZF_MUTE_BIT, do_mute);\r\nreturn (do_mute) ? !updated : updated;\r\n}\r\nstatic inline bool\r\nsnd_azf3328_mixer_mute_control_master(const struct snd_azf3328 *chip,\r\nbool do_mute\r\n)\r\n{\r\nreturn snd_azf3328_mixer_mute_control(\r\nchip,\r\nIDX_MIXER_PLAY_MASTER,\r\ndo_mute\r\n);\r\n}\r\nstatic inline bool\r\nsnd_azf3328_mixer_mute_control_pcm(const struct snd_azf3328 *chip,\r\nbool do_mute\r\n)\r\n{\r\nreturn snd_azf3328_mixer_mute_control(\r\nchip,\r\nIDX_MIXER_WAVEOUT,\r\ndo_mute\r\n);\r\n}\r\nstatic inline void\r\nsnd_azf3328_mixer_reset(const struct snd_azf3328 *chip)\r\n{\r\nsnd_azf3328_mixer_mute_control_master(chip, 1);\r\nsnd_azf3328_mixer_outw(chip, IDX_MIXER_RESET, 0x0000);\r\n}\r\nstatic inline void\r\nsnd_azf3328_mixer_ac97_map_unsupported(const struct snd_azf3328 *chip,\r\nunsigned short reg, const char *mode)\r\n{\r\ndev_warn(chip->card->dev,\r\n"missing %s emulation for AC97 register 0x%02x!\n",\r\nmode, reg);\r\n}\r\nstatic unsigned short\r\nsnd_azf3328_mixer_ac97_map_reg_idx(unsigned short reg)\r\n{\r\nstatic const struct {\r\nunsigned short azf_reg;\r\n} azf_reg_mapper[] = {\r\n{ IDX_MIXER_RESET\r\n| AZF_AC97_REG_REAL_IO_WRITE\r\n| AZF_AC97_REG_EMU_IO_READ },\r\n{ IDX_MIXER_PLAY_MASTER },\r\n{ IDX_MIXER_FMSYNTH },\r\n{ IDX_MIXER_MODEMOUT },\r\n{ IDX_MIXER_BASSTREBLE },\r\n{ IDX_MIXER_PCBEEP },\r\n{ IDX_MIXER_MODEMIN },\r\n{ IDX_MIXER_MIC },\r\n{ IDX_MIXER_LINEIN },\r\n{ IDX_MIXER_CDAUDIO },\r\n{ IDX_MIXER_VIDEO },\r\n{ IDX_MIXER_AUX },\r\n{ IDX_MIXER_WAVEOUT },\r\n{ IDX_MIXER_REC_SELECT },\r\n{ IDX_MIXER_REC_VOLUME },\r\n{ AZF_AC97_REG_EMU_IO_RW },\r\n{ IDX_MIXER_ADVCTL2 },\r\n{ IDX_MIXER_ADVCTL1 },\r\n};\r\nunsigned short reg_azf = AZF_AC97_REG_UNSUPPORTED;\r\nif (reg <= AC97_3D_CONTROL) {\r\nunsigned short reg_idx = reg / 2;\r\nreg_azf = azf_reg_mapper[reg_idx].azf_reg;\r\nif (!(reg_azf & ~AZF_REG_MASK))\r\nreg_azf |= AZF_AC97_REG_REAL_IO_RW;\r\n} else {\r\nswitch (reg) {\r\ncase AC97_POWERDOWN:\r\nreg_azf = AZF_AC97_REG_EMU_IO_RW;\r\nbreak;\r\ncase AC97_EXTENDED_ID:\r\nreg_azf = AZF_AC97_REG_EMU_IO_READ;\r\nbreak;\r\ncase AC97_EXTENDED_STATUS:\r\nreg_azf = AZF_AC97_REG_EMU_IO_RW;\r\nbreak;\r\ncase AC97_VENDOR_ID1:\r\ncase AC97_VENDOR_ID2:\r\nreg_azf = AZF_AC97_REG_EMU_IO_READ;\r\nbreak;\r\n}\r\n}\r\nreturn reg_azf;\r\n}\r\nstatic unsigned short\r\nsnd_azf3328_mixer_ac97_read(struct snd_ac97 *ac97, unsigned short reg_ac97)\r\n{\r\nconst struct snd_azf3328 *chip = ac97->private_data;\r\nunsigned short reg_azf = snd_azf3328_mixer_ac97_map_reg_idx(reg_ac97);\r\nunsigned short reg_val = 0;\r\nbool unsupported = false;\r\ndev_dbg(chip->card->dev, "snd_azf3328_mixer_ac97_read reg_ac97 %u\n",\r\nreg_ac97);\r\nif (reg_azf & AZF_AC97_REG_UNSUPPORTED)\r\nunsupported = true;\r\nelse {\r\nif (reg_azf & AZF_AC97_REG_REAL_IO_READ)\r\nreg_val = snd_azf3328_mixer_inw(chip,\r\nreg_azf & AZF_REG_MASK);\r\nelse {\r\nsnd_azf3328_mixer_inw(chip, IDX_MIXER_SOMETHING30H);\r\n}\r\nif (reg_azf & AZF_AC97_REG_EMU_IO_READ) {\r\nswitch (reg_ac97) {\r\ncase AC97_RESET:\r\nreg_val |= azf_emulated_ac97_caps;\r\nbreak;\r\ncase AC97_POWERDOWN:\r\nreg_val |= azf_emulated_ac97_powerdown;\r\nbreak;\r\ncase AC97_EXTENDED_ID:\r\ncase AC97_EXTENDED_STATUS:\r\nreg_val |= 0;\r\nbreak;\r\ncase AC97_VENDOR_ID1:\r\nreg_val = azf_emulated_ac97_vendor_id >> 16;\r\nbreak;\r\ncase AC97_VENDOR_ID2:\r\nreg_val = azf_emulated_ac97_vendor_id & 0xffff;\r\nbreak;\r\ndefault:\r\nunsupported = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (unsupported)\r\nsnd_azf3328_mixer_ac97_map_unsupported(chip, reg_ac97, "read");\r\nreturn reg_val;\r\n}\r\nstatic void\r\nsnd_azf3328_mixer_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg_ac97, unsigned short val)\r\n{\r\nconst struct snd_azf3328 *chip = ac97->private_data;\r\nunsigned short reg_azf = snd_azf3328_mixer_ac97_map_reg_idx(reg_ac97);\r\nbool unsupported = false;\r\ndev_dbg(chip->card->dev,\r\n"snd_azf3328_mixer_ac97_write reg_ac97 %u val %u\n",\r\nreg_ac97, val);\r\nif (reg_azf & AZF_AC97_REG_UNSUPPORTED)\r\nunsupported = true;\r\nelse {\r\nif (reg_azf & AZF_AC97_REG_REAL_IO_WRITE)\r\nsnd_azf3328_mixer_outw(\r\nchip,\r\nreg_azf & AZF_REG_MASK,\r\nval\r\n);\r\nelse\r\nif (reg_azf & AZF_AC97_REG_EMU_IO_WRITE) {\r\nswitch (reg_ac97) {\r\ncase AC97_REC_GAIN_MIC:\r\ncase AC97_POWERDOWN:\r\ncase AC97_EXTENDED_STATUS:\r\nbreak;\r\ndefault:\r\nunsupported = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (unsupported)\r\nsnd_azf3328_mixer_ac97_map_unsupported(chip, reg_ac97, "write");\r\n}\r\nstatic int\r\nsnd_azf3328_mixer_new(struct snd_azf3328 *chip)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_azf3328_mixer_ac97_write,\r\n.read = snd_azf3328_mixer_ac97_read,\r\n};\r\nint rc;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.scaps = AC97_SCAP_SKIP_MODEM\r\n| AC97_SCAP_AUDIO\r\n| AC97_SCAP_NO_SPDIF;\r\nac97.private_data = chip;\r\nac97.pci = chip->pci;\r\nrc = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus);\r\nif (!rc)\r\nrc = snd_ac97_mixer(bus, &ac97, &chip->ac97);\r\nif (rc)\r\ndev_err(chip->card->dev, "AC97 init failed, err %d!\n", rc);\r\nreturn rc;\r\n}\r\nstatic void\r\nsnd_azf3328_mixer_write_volume_gradually(const struct snd_azf3328 *chip,\r\nunsigned reg,\r\nunsigned char dst_vol_left,\r\nunsigned char dst_vol_right,\r\nint chan_sel, int delay\r\n)\r\n{\r\nunsigned long portbase = chip->mixer_io + reg;\r\nunsigned char curr_vol_left = 0, curr_vol_right = 0;\r\nint left_change = 0, right_change = 0;\r\nif (chan_sel & SET_CHAN_LEFT) {\r\ncurr_vol_left = inb(portbase + 1);\r\nif (curr_vol_left & AZF_MUTE_BIT)\r\ndst_vol_left |= AZF_MUTE_BIT;\r\nelse\r\ndst_vol_left &= ~AZF_MUTE_BIT;\r\nleft_change = (curr_vol_left > dst_vol_left) ? -1 : 1;\r\n}\r\nif (chan_sel & SET_CHAN_RIGHT) {\r\ncurr_vol_right = inb(portbase + 0);\r\nright_change = (curr_vol_right > dst_vol_right) ? -1 : 1;\r\n}\r\ndo {\r\nif (left_change) {\r\nif (curr_vol_left != dst_vol_left) {\r\ncurr_vol_left += left_change;\r\noutb(curr_vol_left, portbase + 1);\r\n} else\r\nleft_change = 0;\r\n}\r\nif (right_change) {\r\nif (curr_vol_right != dst_vol_right) {\r\ncurr_vol_right += right_change;\r\noutb(curr_vol_right, portbase + 0);\r\n} else\r\nright_change = 0;\r\n}\r\nif (delay)\r\nmdelay(delay);\r\n} while ((left_change) || (right_change));\r\n}\r\nstatic void snd_azf3328_mixer_reg_decode(struct azf3328_mixer_reg *r, unsigned long val)\r\n{\r\nr->reg = val & 0xff;\r\nr->lchan_shift = (val >> 8) & 0x0f;\r\nr->rchan_shift = (val >> 12) & 0x0f;\r\nr->mask = (val >> 16) & 0xff;\r\nr->invert = (val >> 24) & 1;\r\nr->stereo = (val >> 25) & 1;\r\nr->enum_c = (val >> 26) & 0x0f;\r\n}\r\nstatic int\r\nsnd_azf3328_info_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct azf3328_mixer_reg reg;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\nuinfo->type = reg.mask == 1 ?\r\nSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = reg.stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = reg.mask;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_get_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\r\nstruct azf3328_mixer_reg reg;\r\nu16 oreg, val;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\noreg = snd_azf3328_mixer_inw(chip, reg.reg);\r\nval = (oreg >> reg.lchan_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[0] = val;\r\nif (reg.stereo) {\r\nval = (oreg >> reg.rchan_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[1] = val;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"get: %02x is %04x -> vol %02lx|%02lx (shift %02d|%02d, mask %02x, inv. %d, stereo %d)\n",\r\nreg.reg, oreg,\r\nucontrol->value.integer.value[0], ucontrol->value.integer.value[1],\r\nreg.lchan_shift, reg.rchan_shift, reg.mask, reg.invert, reg.stereo);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_put_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\r\nstruct azf3328_mixer_reg reg;\r\nu16 oreg, nreg, val;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\noreg = snd_azf3328_mixer_inw(chip, reg.reg);\r\nval = ucontrol->value.integer.value[0] & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nnreg = oreg & ~(reg.mask << reg.lchan_shift);\r\nnreg |= (val << reg.lchan_shift);\r\nif (reg.stereo) {\r\nval = ucontrol->value.integer.value[1] & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nnreg &= ~(reg.mask << reg.rchan_shift);\r\nnreg |= (val << reg.rchan_shift);\r\n}\r\nif (reg.mask >= 0x07)\r\nsnd_azf3328_mixer_write_volume_gradually(\r\nchip, reg.reg, nreg >> 8, nreg & 0xff,\r\nSET_CHAN_LEFT|SET_CHAN_RIGHT,\r\n0);\r\nelse\r\nsnd_azf3328_mixer_outw(chip, reg.reg, nreg);\r\ndev_dbg(chip->card->dev,\r\n"put: %02x to %02lx|%02lx, oreg %04x; shift %02d|%02d -> nreg %04x; after: %04x\n",\r\nreg.reg, ucontrol->value.integer.value[0], ucontrol->value.integer.value[1],\r\noreg, reg.lchan_shift, reg.rchan_shift,\r\nnreg, snd_azf3328_mixer_inw(chip, reg.reg));\r\nreturn (nreg != oreg);\r\n}\r\nstatic int\r\nsnd_azf3328_info_mixer_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts1[] = {\r\n"Mic1", "Mic2"\r\n};\r\nstatic const char * const texts2[] = {\r\n"Mix", "Mic"\r\n};\r\nstatic const char * const texts3[] = {\r\n"Mic", "CD", "Video", "Aux",\r\n"Line", "Mix", "Mix Mono", "Phone"\r\n};\r\nstatic const char * const texts4[] = {\r\n"pre 3D", "post 3D"\r\n};\r\nstruct azf3328_mixer_reg reg;\r\nconst char * const *p = NULL;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\nif (reg.reg == IDX_MIXER_ADVCTL2) {\r\nswitch(reg.lchan_shift) {\r\ncase 8:\r\np = texts1;\r\nbreak;\r\ncase 9:\r\np = texts2;\r\nbreak;\r\ncase 15:\r\np = texts4;\r\nbreak;\r\n}\r\n} else if (reg.reg == IDX_MIXER_REC_SELECT)\r\np = texts3;\r\nreturn snd_ctl_enum_info(uinfo,\r\n(reg.reg == IDX_MIXER_REC_SELECT) ? 2 : 1,\r\nreg.enum_c, p);\r\n}\r\nstatic int\r\nsnd_azf3328_get_mixer_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\r\nstruct azf3328_mixer_reg reg;\r\nunsigned short val;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\nval = snd_azf3328_mixer_inw(chip, reg.reg);\r\nif (reg.reg == IDX_MIXER_REC_SELECT) {\r\nucontrol->value.enumerated.item[0] = (val >> 8) & (reg.enum_c - 1);\r\nucontrol->value.enumerated.item[1] = (val >> 0) & (reg.enum_c - 1);\r\n} else\r\nucontrol->value.enumerated.item[0] = (val >> reg.lchan_shift) & (reg.enum_c - 1);\r\ndev_dbg(chip->card->dev,\r\n"get_enum: %02x is %04x -> %d|%d (shift %02d, enum_c %d)\n",\r\nreg.reg, val, ucontrol->value.enumerated.item[0], ucontrol->value.enumerated.item[1],\r\nreg.lchan_shift, reg.enum_c);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_put_mixer_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\r\nstruct azf3328_mixer_reg reg;\r\nu16 oreg, nreg, val;\r\nsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\r\noreg = snd_azf3328_mixer_inw(chip, reg.reg);\r\nval = oreg;\r\nif (reg.reg == IDX_MIXER_REC_SELECT) {\r\nif (ucontrol->value.enumerated.item[0] > reg.enum_c - 1U ||\r\nucontrol->value.enumerated.item[1] > reg.enum_c - 1U)\r\nreturn -EINVAL;\r\nval = (ucontrol->value.enumerated.item[0] << 8) |\r\n(ucontrol->value.enumerated.item[1] << 0);\r\n} else {\r\nif (ucontrol->value.enumerated.item[0] > reg.enum_c - 1U)\r\nreturn -EINVAL;\r\nval &= ~((reg.enum_c - 1) << reg.lchan_shift);\r\nval |= (ucontrol->value.enumerated.item[0] << reg.lchan_shift);\r\n}\r\nsnd_azf3328_mixer_outw(chip, reg.reg, val);\r\nnreg = val;\r\ndev_dbg(chip->card->dev,\r\n"put_enum: %02x to %04x, oreg %04x\n", reg.reg, val, oreg);\r\nreturn (nreg != oreg);\r\n}\r\nstatic int\r\nsnd_azf3328_mixer_new(struct snd_azf3328 *chip)\r\n{\r\nstruct snd_card *card;\r\nconst struct snd_kcontrol_new *sw;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!chip || !chip->card))\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nsnd_azf3328_mixer_outw(chip, IDX_MIXER_RESET, 0x0000);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_azf3328_init_values); ++idx) {\r\nsnd_azf3328_mixer_outw(chip,\r\nsnd_azf3328_init_values[idx][0],\r\nsnd_azf3328_init_values[idx][1]);\r\n}\r\nsw = snd_azf3328_mixer_controls;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_azf3328_mixer_controls);\r\n++idx, ++sw) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(sw, chip))) < 0)\r\nreturn err;\r\n}\r\nsnd_component_add(card, "AZF3328 mixer");\r\nstrcpy(card->mixername, "AZF3328 mixer");\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int\r\nsnd_azf3328_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_azf3328_codec_setfmt(struct snd_azf3328_codec_data *codec,\r\nenum azf_freq_t bitrate,\r\nunsigned int format_width,\r\nunsigned int channels\r\n)\r\n{\r\nunsigned long flags;\r\nu16 val = 0xff00;\r\nu8 freq = 0;\r\nswitch (bitrate) {\r\ncase AZF_FREQ_4000: freq = SOUNDFORMAT_FREQ_SUSPECTED_4000; break;\r\ncase AZF_FREQ_4800: freq = SOUNDFORMAT_FREQ_SUSPECTED_4800; break;\r\ncase AZF_FREQ_5512:\r\nfreq = SOUNDFORMAT_FREQ_5510; break;\r\ncase AZF_FREQ_6620: freq = SOUNDFORMAT_FREQ_6620; break;\r\ncase AZF_FREQ_8000: freq = SOUNDFORMAT_FREQ_8000; break;\r\ncase AZF_FREQ_9600: freq = SOUNDFORMAT_FREQ_9600; break;\r\ncase AZF_FREQ_11025: freq = SOUNDFORMAT_FREQ_11025; break;\r\ncase AZF_FREQ_13240: freq = SOUNDFORMAT_FREQ_SUSPECTED_13240; break;\r\ncase AZF_FREQ_16000: freq = SOUNDFORMAT_FREQ_16000; break;\r\ncase AZF_FREQ_22050: freq = SOUNDFORMAT_FREQ_22050; break;\r\ncase AZF_FREQ_32000: freq = SOUNDFORMAT_FREQ_32000; break;\r\ndefault:\r\nsnd_printk(KERN_WARNING "unknown bitrate %d, assuming 44.1kHz!\n", bitrate);\r\ncase AZF_FREQ_44100: freq = SOUNDFORMAT_FREQ_44100; break;\r\ncase AZF_FREQ_48000: freq = SOUNDFORMAT_FREQ_48000; break;\r\ncase AZF_FREQ_66200: freq = SOUNDFORMAT_FREQ_SUSPECTED_66200; break;\r\n}\r\nval |= freq;\r\nif (channels == 2)\r\nval |= SOUNDFORMAT_FLAG_2CHANNELS;\r\nif (format_width == 16)\r\nval |= SOUNDFORMAT_FLAG_16BIT;\r\nspin_lock_irqsave(codec->lock, flags);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_SOUNDFORMAT, val);\r\nif (codec->type != AZF_CODEC_CAPTURE)\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nsnd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS) |\r\nDMA_RUN_SOMETHING1 |\r\nDMA_RUN_SOMETHING2 |\r\nSOMETHING_ALMOST_ALWAYS_SET |\r\nDMA_EPILOGUE_SOMETHING |\r\nDMA_SOMETHING_ELSE\r\n);\r\nspin_unlock_irqrestore(codec->lock, flags);\r\n}\r\nstatic inline void\r\nsnd_azf3328_codec_setfmt_lowpower(struct snd_azf3328_codec_data *codec\r\n)\r\n{\r\nsnd_azf3328_codec_setfmt(codec, AZF_FREQ_4000, 8, 1);\r\n}\r\nstatic void\r\nsnd_azf3328_ctrl_reg_6AH_update(struct snd_azf3328 *chip,\r\nunsigned bitmask,\r\nbool enable\r\n)\r\n{\r\nbool do_mask = !enable;\r\nif (do_mask)\r\nchip->shadow_reg_ctrl_6AH |= bitmask;\r\nelse\r\nchip->shadow_reg_ctrl_6AH &= ~bitmask;\r\ndev_dbg(chip->card->dev,\r\n"6AH_update mask 0x%04x do_mask %d: val 0x%04x\n",\r\nbitmask, do_mask, chip->shadow_reg_ctrl_6AH);\r\nsnd_azf3328_ctrl_outw(chip, IDX_IO_6AH, chip->shadow_reg_ctrl_6AH);\r\n}\r\nstatic inline void\r\nsnd_azf3328_ctrl_enable_codecs(struct snd_azf3328 *chip, bool enable)\r\n{\r\ndev_dbg(chip->card->dev, "codec_enable %d\n", enable);\r\nsnd_azf3328_ctrl_reg_6AH_update(\r\nchip, IO_6A_PAUSE_PLAYBACK_BIT8, enable\r\n);\r\n}\r\nstatic void\r\nsnd_azf3328_ctrl_codec_activity(struct snd_azf3328 *chip,\r\nenum snd_azf3328_codec_type codec_type,\r\nbool enable\r\n)\r\n{\r\nstruct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];\r\nbool need_change = (codec->running != enable);\r\ndev_dbg(chip->card->dev,\r\n"codec_activity: %s codec, enable %d, need_change %d\n",\r\ncodec->name, enable, need_change\r\n);\r\nif (need_change) {\r\nstatic const struct {\r\nenum snd_azf3328_codec_type other1;\r\nenum snd_azf3328_codec_type other2;\r\n} peer_codecs[3] =\r\n{ { AZF_CODEC_CAPTURE, AZF_CODEC_I2S_OUT },\r\n{ AZF_CODEC_PLAYBACK, AZF_CODEC_I2S_OUT },\r\n{ AZF_CODEC_PLAYBACK, AZF_CODEC_CAPTURE } };\r\nbool call_function;\r\nif (enable)\r\ncall_function = 1;\r\nelse {\r\ncall_function =\r\n((!chip->codecs[peer_codecs[codec_type].other1]\r\n.running)\r\n&& (!chip->codecs[peer_codecs[codec_type].other2]\r\n.running));\r\n}\r\nif (call_function)\r\nsnd_azf3328_ctrl_enable_codecs(chip, enable);\r\nif (!enable)\r\nsnd_azf3328_codec_setfmt_lowpower(codec);\r\ncodec->running = enable;\r\n}\r\n}\r\nstatic void\r\nsnd_azf3328_codec_setdmaa(struct snd_azf3328 *chip,\r\nstruct snd_azf3328_codec_data *codec,\r\nunsigned long addr,\r\nunsigned int period_bytes,\r\nunsigned int buffer_bytes\r\n)\r\n{\r\nWARN_ONCE(period_bytes & 1, "odd period length!?\n");\r\nWARN_ONCE(buffer_bytes != 2 * period_bytes,\r\n"missed our input expectations! %u vs. %u\n",\r\nbuffer_bytes, period_bytes);\r\nif (!codec->running) {\r\nunsigned long flags;\r\nu32 area_length;\r\nstruct codec_setup_io {\r\nu32 dma_start_1;\r\nu32 dma_start_2;\r\nu32 dma_lengths;\r\n} __attribute__((packed)) setup_io;\r\narea_length = buffer_bytes/2;\r\nsetup_io.dma_start_1 = addr;\r\nsetup_io.dma_start_2 = addr+area_length;\r\ndev_dbg(chip->card->dev,\r\n"setdma: buffers %08x[%u] / %08x[%u], %u, %u\n",\r\nsetup_io.dma_start_1, area_length,\r\nsetup_io.dma_start_2, area_length,\r\nperiod_bytes, buffer_bytes);\r\nsetup_io.dma_lengths = (area_length << 16) | (area_length);\r\nspin_lock_irqsave(codec->lock, flags);\r\nsnd_azf3328_codec_outl_multi(\r\ncodec, IDX_IO_CODEC_DMA_START_1, &setup_io, 3\r\n);\r\nspin_unlock_irqrestore(codec->lock, flags);\r\n}\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_azf3328_codec_data *codec = runtime->private_data;\r\n#if 0\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\n#endif\r\ncodec->dma_base = runtime->dma_addr;\r\n#if 0\r\nsnd_azf3328_codec_setfmt(codec,\r\nruntime->rate,\r\nsnd_pcm_format_width(runtime->format),\r\nruntime->channels);\r\nsnd_azf3328_codec_setdmaa(chip, codec,\r\nruntime->dma_addr, count, size);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_azf3328 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_azf3328_codec_data *codec = runtime->private_data;\r\nint result = 0;\r\nu16 flags1;\r\nbool previously_muted = false;\r\nbool is_main_mixer_playback_codec = (AZF_CODEC_PLAYBACK == codec->type);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndev_dbg(chip->card->dev, "START PCM %s\n", codec->name);\r\nif (is_main_mixer_playback_codec) {\r\npreviously_muted =\r\nsnd_azf3328_mixer_mute_control_pcm(\r\nchip, 1\r\n);\r\n}\r\nsnd_azf3328_codec_setfmt(codec,\r\nruntime->rate,\r\nsnd_pcm_format_width(runtime->format),\r\nruntime->channels);\r\nspin_lock(codec->lock);\r\nflags1 = snd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS);\r\nflags1 &= ~DMA_RESUME;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_IRQTYPE, 0xffff);\r\nspin_unlock(codec->lock);\r\nsnd_azf3328_codec_setdmaa(chip, codec, runtime->dma_addr,\r\nsnd_pcm_lib_period_bytes(substream),\r\nsnd_pcm_lib_buffer_bytes(substream)\r\n);\r\nspin_lock(codec->lock);\r\n#ifdef WIN9X\r\nflags1 |= DMA_RUN_SOMETHING1 | DMA_RUN_SOMETHING2;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\nflags1 |= DMA_RESUME | DMA_EPILOGUE_SOMETHING;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\n#else\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\n0x0000);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nDMA_RUN_SOMETHING1);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nDMA_RUN_SOMETHING1 |\r\nDMA_RUN_SOMETHING2);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nDMA_RESUME |\r\nSOMETHING_ALMOST_ALWAYS_SET |\r\nDMA_EPILOGUE_SOMETHING |\r\nDMA_SOMETHING_ELSE);\r\n#endif\r\nspin_unlock(codec->lock);\r\nsnd_azf3328_ctrl_codec_activity(chip, codec->type, 1);\r\nif (is_main_mixer_playback_codec) {\r\nif (!previously_muted)\r\nsnd_azf3328_mixer_mute_control_pcm(\r\nchip, 0\r\n);\r\n}\r\ndev_dbg(chip->card->dev, "PCM STARTED %s\n", codec->name);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ndev_dbg(chip->card->dev, "PCM RESUME %s\n", codec->name);\r\nspin_lock(codec->lock);\r\nif (codec->running)\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nsnd_azf3328_codec_inw(\r\ncodec, IDX_IO_CODEC_DMA_FLAGS\r\n) | DMA_RESUME\r\n);\r\nspin_unlock(codec->lock);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndev_dbg(chip->card->dev, "PCM STOP %s\n", codec->name);\r\nif (is_main_mixer_playback_codec) {\r\npreviously_muted =\r\nsnd_azf3328_mixer_mute_control_pcm(\r\nchip, 1\r\n);\r\n}\r\nspin_lock(codec->lock);\r\nflags1 = snd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS);\r\nflags1 &= ~DMA_RESUME;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\nflags1 |= DMA_RUN_SOMETHING1;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\nflags1 &= ~DMA_RUN_SOMETHING1;\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\r\nspin_unlock(codec->lock);\r\nsnd_azf3328_ctrl_codec_activity(chip, codec->type, 0);\r\nif (is_main_mixer_playback_codec) {\r\nif (!previously_muted)\r\nsnd_azf3328_mixer_mute_control_pcm(\r\nchip, 0\r\n);\r\n}\r\ndev_dbg(chip->card->dev, "PCM STOPPED %s\n", codec->name);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndev_dbg(chip->card->dev, "PCM SUSPEND %s\n", codec->name);\r\nsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\r\nsnd_azf3328_codec_inw(\r\ncodec, IDX_IO_CODEC_DMA_FLAGS\r\n) & ~DMA_RESUME\r\n);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nWARN(1, "FIXME: SNDRV_PCM_TRIGGER_PAUSE_PUSH NIY!\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nWARN(1, "FIXME: SNDRV_PCM_TRIGGER_PAUSE_RELEASE NIY!\n");\r\nbreak;\r\ndefault:\r\nWARN(1, "FIXME: unknown trigger mode!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_azf3328_pcm_pointer(struct snd_pcm_substream *substream\r\n)\r\n{\r\nconst struct snd_azf3328_codec_data *codec =\r\nsubstream->runtime->private_data;\r\nunsigned long result;\r\nsnd_pcm_uframes_t frmres;\r\nresult = snd_azf3328_codec_inl(codec, IDX_IO_CODEC_DMA_CURRPOS);\r\n#ifdef QUERY_HARDWARE\r\nresult -= snd_azf3328_codec_inl(codec, IDX_IO_CODEC_DMA_START_1);\r\n#else\r\nresult -= codec->dma_base;\r\n#endif\r\nfrmres = bytes_to_frames( substream->runtime, result);\r\ndev_dbg(substream->pcm->card->dev, "%08li %s @ 0x%8lx, frames %8ld\n",\r\njiffies, codec->name, result, frmres);\r\nreturn frmres;\r\n}\r\nstatic inline void\r\nsnd_azf3328_gameport_irq_enable(struct snd_azf3328 *chip,\r\nbool enable\r\n)\r\n{\r\nsnd_azf3328_io_reg_setb(\r\nchip->game_io+IDX_GAME_HWCONFIG,\r\nGAME_HWCFG_IRQ_ENABLE,\r\nenable\r\n);\r\n}\r\nstatic inline void\r\nsnd_azf3328_gameport_legacy_address_enable(struct snd_azf3328 *chip,\r\nbool enable\r\n)\r\n{\r\nsnd_azf3328_io_reg_setb(\r\nchip->game_io+IDX_GAME_HWCONFIG,\r\nGAME_HWCFG_LEGACY_ADDRESS_ENABLE,\r\nenable\r\n);\r\n}\r\nstatic void\r\nsnd_azf3328_gameport_set_counter_frequency(struct snd_azf3328 *chip,\r\nunsigned int freq_cfg\r\n)\r\n{\r\nsnd_azf3328_io_reg_setb(\r\nchip->game_io+IDX_GAME_HWCONFIG,\r\n0x02,\r\n(freq_cfg & 1) != 0\r\n);\r\nsnd_azf3328_io_reg_setb(\r\nchip->game_io+IDX_GAME_HWCONFIG,\r\n0x04,\r\n(freq_cfg & 2) != 0\r\n);\r\n}\r\nstatic inline void\r\nsnd_azf3328_gameport_axis_circuit_enable(struct snd_azf3328 *chip, bool enable)\r\n{\r\nsnd_azf3328_ctrl_reg_6AH_update(\r\nchip, IO_6A_SOMETHING2_GAMEPORT, enable\r\n);\r\n}\r\nstatic inline void\r\nsnd_azf3328_gameport_interrupt(struct snd_azf3328 *chip)\r\n{\r\ndev_dbg(chip->card->dev, "gameport irq\n");\r\nsnd_azf3328_game_inw(chip, IDX_GAME_AXIS_VALUE);\r\n}\r\nstatic int\r\nsnd_azf3328_gameport_open(struct gameport *gameport, int mode)\r\n{\r\nstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\r\nint res;\r\ndev_dbg(chip->card->dev, "gameport_open, mode %d\n", mode);\r\nswitch (mode) {\r\ncase GAMEPORT_MODE_COOKED:\r\ncase GAMEPORT_MODE_RAW:\r\nres = 0;\r\nbreak;\r\ndefault:\r\nres = -1;\r\nbreak;\r\n}\r\nsnd_azf3328_gameport_set_counter_frequency(chip,\r\nGAME_HWCFG_ADC_COUNTER_FREQ_STD);\r\nsnd_azf3328_gameport_axis_circuit_enable(chip, (res == 0));\r\nreturn res;\r\n}\r\nstatic void\r\nsnd_azf3328_gameport_close(struct gameport *gameport)\r\n{\r\nstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\r\ndev_dbg(chip->card->dev, "gameport_close\n");\r\nsnd_azf3328_gameport_set_counter_frequency(chip,\r\nGAME_HWCFG_ADC_COUNTER_FREQ_1_200);\r\nsnd_azf3328_gameport_axis_circuit_enable(chip, 0);\r\n}\r\nstatic int\r\nsnd_azf3328_gameport_cooked_read(struct gameport *gameport,\r\nint *axes,\r\nint *buttons\r\n)\r\n{\r\nstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\r\nint i;\r\nu8 val;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = snd_azf3328_game_inb(chip, IDX_GAME_LEGACY_COMPATIBLE);\r\n*buttons = (~(val) >> 4) & 0xf;\r\nval = snd_azf3328_game_inb(chip, IDX_GAME_AXES_CONFIG);\r\nif (val & GAME_AXES_SAMPLING_READY) {\r\nfor (i = 0; i < ARRAY_SIZE(chip->axes); ++i) {\r\nval = (i << 4) | 0x0f;\r\nsnd_azf3328_game_outb(chip, IDX_GAME_AXES_CONFIG, val);\r\nchip->axes[i] = snd_azf3328_game_inw(\r\nchip, IDX_GAME_AXIS_VALUE\r\n);\r\n}\r\n}\r\nval = 0x03;\r\nsnd_azf3328_game_outb(chip, IDX_GAME_AXES_CONFIG, val);\r\nsnd_azf3328_game_outw(chip, IDX_GAME_AXIS_VALUE, 0xffff);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(chip->axes); i++) {\r\naxes[i] = chip->axes[i];\r\nif (axes[i] == 0xffff)\r\naxes[i] = -1;\r\n}\r\ndev_dbg(chip->card->dev, "cooked_read: axes %d %d %d %d buttons %d\n",\r\naxes[0], axes[1], axes[2], axes[3], *buttons);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_gameport(struct snd_azf3328 *chip, int dev)\r\n{\r\nstruct gameport *gp;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(chip->card->dev, "cannot alloc memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "AZF3328 Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->io = chip->game_io;\r\ngameport_set_port_data(gp, chip);\r\ngp->open = snd_azf3328_gameport_open;\r\ngp->close = snd_azf3328_gameport_close;\r\ngp->fuzz = 16;\r\ngp->cooked_read = snd_azf3328_gameport_cooked_read;\r\nsnd_azf3328_gameport_legacy_address_enable(chip, 0);\r\nsnd_azf3328_gameport_set_counter_frequency(chip,\r\nGAME_HWCFG_ADC_COUNTER_FREQ_1_200);\r\nsnd_azf3328_gameport_axis_circuit_enable(chip, 0);\r\ngameport_register_port(chip->gameport);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_azf3328_gameport_free(struct snd_azf3328 *chip)\r\n{\r\nif (chip->gameport) {\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\n}\r\nsnd_azf3328_gameport_irq_enable(chip, 0);\r\n}\r\nstatic inline int\r\nsnd_azf3328_gameport(struct snd_azf3328 *chip, int dev) { return -ENOSYS; }\r\nstatic inline void\r\nsnd_azf3328_gameport_free(struct snd_azf3328 *chip) { }\r\nstatic inline void\r\nsnd_azf3328_gameport_interrupt(struct snd_azf3328 *chip)\r\n{\r\ndev_warn(chip->card->dev, "huh, game port IRQ occurred!?\n");\r\n}\r\nstatic inline void\r\nsnd_azf3328_irq_log_unknown_type(struct snd_azf3328 *chip, u8 which)\r\n{\r\ndev_dbg(chip->card->dev,\r\n"unknown IRQ type (%x) occurred, please report!\n",\r\nwhich);\r\n}\r\nstatic inline void\r\nsnd_azf3328_pcm_interrupt(struct snd_azf3328 *chip,\r\nconst struct snd_azf3328_codec_data *first_codec,\r\nu8 status\r\n)\r\n{\r\nu8 which;\r\nenum snd_azf3328_codec_type codec_type;\r\nconst struct snd_azf3328_codec_data *codec = first_codec;\r\nfor (codec_type = AZF_CODEC_PLAYBACK;\r\ncodec_type <= AZF_CODEC_I2S_OUT;\r\n++codec_type, ++codec) {\r\nif (!(status & (1 << codec_type)))\r\ncontinue;\r\nspin_lock(codec->lock);\r\nwhich = snd_azf3328_codec_inb(codec, IDX_IO_CODEC_IRQTYPE);\r\nsnd_azf3328_codec_outb(codec, IDX_IO_CODEC_IRQTYPE, which);\r\nspin_unlock(codec->lock);\r\nif (codec->substream) {\r\nsnd_pcm_period_elapsed(codec->substream);\r\ndev_dbg(chip->card->dev, "%s period done (#%x), @ %x\n",\r\ncodec->name,\r\nwhich,\r\nsnd_azf3328_codec_inl(\r\ncodec, IDX_IO_CODEC_DMA_CURRPOS));\r\n} else\r\ndev_warn(chip->card->dev, "irq handler problem!\n");\r\nif (which & IRQ_SOMETHING)\r\nsnd_azf3328_irq_log_unknown_type(chip, which);\r\n}\r\n}\r\nstatic irqreturn_t\r\nsnd_azf3328_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_azf3328 *chip = dev_id;\r\nu8 status;\r\nstatic unsigned long irq_count;\r\nstatus = snd_azf3328_ctrl_inb(chip, IDX_IO_IRQSTATUS);\r\nif (!(status &\r\n(IRQ_PLAYBACK|IRQ_RECORDING|IRQ_I2S_OUT\r\n|IRQ_GAMEPORT|IRQ_MPU401|IRQ_TIMER)\r\n))\r\nreturn IRQ_NONE;\r\ndev_dbg(chip->card->dev,\r\n"irq_count %ld! IDX_IO_IRQSTATUS %04x\n",\r\nirq_count++ ,\r\nstatus);\r\nif (status & IRQ_TIMER) {\r\nif (chip->timer)\r\nsnd_timer_interrupt(chip->timer, chip->timer->sticks);\r\nspin_lock(&chip->reg_lock);\r\nsnd_azf3328_ctrl_outb(chip, IDX_IO_TIMER_VALUE + 3, 0x07);\r\nspin_unlock(&chip->reg_lock);\r\ndev_dbg(chip->card->dev, "timer IRQ\n");\r\n}\r\nif (status & (IRQ_PLAYBACK|IRQ_RECORDING|IRQ_I2S_OUT))\r\nsnd_azf3328_pcm_interrupt(chip, chip->codecs, status);\r\nif (status & IRQ_GAMEPORT)\r\nsnd_azf3328_gameport_interrupt(chip);\r\nif (status & IRQ_MPU401) {\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\ndev_dbg(chip->card->dev, "MPU401 IRQ\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_open(struct snd_pcm_substream *substream,\r\nenum snd_azf3328_codec_type codec_type\r\n)\r\n{\r\nstruct snd_azf3328 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];\r\ncodec->substream = substream;\r\nruntime->hw = snd_azf3328_hardware;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_azf3328_hw_constraints_rates);\r\nruntime->private_data = codec;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_azf3328_pcm_open(substream, AZF_CODEC_PLAYBACK);\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_azf3328_pcm_open(substream, AZF_CODEC_CAPTURE);\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_i2s_out_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_azf3328_pcm_open(substream, AZF_CODEC_I2S_OUT);\r\n}\r\nstatic int\r\nsnd_azf3328_pcm_close(struct snd_pcm_substream *substream\r\n)\r\n{\r\nstruct snd_azf3328_codec_data *codec =\r\nsubstream->runtime->private_data;\r\ncodec->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_pcm(struct snd_azf3328 *chip)\r\n{\r\nenum { AZF_PCMDEV_STD, AZF_PCMDEV_I2S_OUT, NUM_AZF_PCMDEVS };\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(chip->card, "AZF3328 DSP", AZF_PCMDEV_STD,\r\n1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_azf3328_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_azf3328_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm[AZF_CODEC_PLAYBACK] = pcm;\r\nchip->pcm[AZF_CODEC_CAPTURE] = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, 64*1024);\r\nerr = snd_pcm_new(chip->card, "AZF3328 I2S OUT", AZF_PCMDEV_I2S_OUT,\r\n1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_azf3328_i2s_out_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm[AZF_CODEC_I2S_OUT] = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_timer_start(struct snd_timer *timer)\r\n{\r\nstruct snd_azf3328 *chip;\r\nunsigned long flags;\r\nunsigned int delay;\r\nchip = snd_timer_chip(timer);\r\ndelay = ((timer->sticks * seqtimer_scaling) - 1) & TIMER_VALUE_MASK;\r\nif (delay < 49) {\r\ndev_dbg(chip->card->dev, "delay was too low (%d)!\n", delay);\r\ndelay = 49;\r\n}\r\ndev_dbg(chip->card->dev, "setting timer countdown value %d\n", delay);\r\ndelay |= TIMER_COUNTDOWN_ENABLE | TIMER_IRQ_ENABLE;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_azf3328_ctrl_outl(chip, IDX_IO_TIMER_VALUE, delay);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_timer_stop(struct snd_timer *timer)\r\n{\r\nstruct snd_azf3328 *chip;\r\nunsigned long flags;\r\nchip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_azf3328_ctrl_outb(chip, IDX_IO_TIMER_VALUE + 3, 0x04);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_timer_precise_resolution(struct snd_timer *timer,\r\nunsigned long *num, unsigned long *den)\r\n{\r\n*num = 1;\r\n*den = 1024000 / seqtimer_scaling;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_timer(struct snd_azf3328 *chip, int device)\r\n{\r\nstruct snd_timer *timer = NULL;\r\nstruct snd_timer_id tid;\r\nint err;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = chip->card->number;\r\ntid.device = device;\r\ntid.subdevice = 0;\r\nsnd_azf3328_timer_hw.resolution *= seqtimer_scaling;\r\nsnd_azf3328_timer_hw.ticks /= seqtimer_scaling;\r\nerr = snd_timer_new(chip->card, "AZF3328", &tid, &timer);\r\nif (err < 0)\r\ngoto out;\r\nstrcpy(timer->name, "AZF3328 timer");\r\ntimer->private_data = chip;\r\ntimer->hw = snd_azf3328_timer_hw;\r\nchip->timer = timer;\r\nsnd_azf3328_timer_stop(timer);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_azf3328_free(struct snd_azf3328 *chip)\r\n{\r\nif (chip->irq < 0)\r\ngoto __end_hw;\r\nsnd_azf3328_mixer_reset(chip);\r\nsnd_azf3328_timer_stop(chip->timer);\r\nsnd_azf3328_gameport_free(chip);\r\nif (chip->irq >= 0)\r\nsynchronize_irq(chip->irq);\r\n__end_hw:\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_azf3328 *chip = device->device_data;\r\nreturn snd_azf3328_free(chip);\r\n}\r\nstatic inline void\r\nsnd_azf3328_debug_show_ports(const struct snd_azf3328 *chip)\r\n{\r\nu16 tmp;\r\ndev_dbg(chip->card->dev,\r\n"ctrl_io 0x%lx, game_io 0x%lx, mpu_io 0x%lx, "\r\n"opl3_io 0x%lx, mixer_io 0x%lx, irq %d\n",\r\nchip->ctrl_io, chip->game_io, chip->mpu_io,\r\nchip->opl3_io, chip->mixer_io, chip->irq);\r\ndev_dbg(chip->card->dev,\r\n"game %02x %02x %02x %02x %02x %02x\n",\r\nsnd_azf3328_game_inb(chip, 0),\r\nsnd_azf3328_game_inb(chip, 1),\r\nsnd_azf3328_game_inb(chip, 2),\r\nsnd_azf3328_game_inb(chip, 3),\r\nsnd_azf3328_game_inb(chip, 4),\r\nsnd_azf3328_game_inb(chip, 5));\r\nfor (tmp = 0; tmp < 0x07; tmp += 1)\r\ndev_dbg(chip->card->dev,\r\n"mpu_io 0x%04x\n", inb(chip->mpu_io + tmp));\r\nfor (tmp = 0; tmp <= 0x07; tmp += 1)\r\ndev_dbg(chip->card->dev,\r\n"0x%02x: game200 0x%04x, game208 0x%04x\n",\r\ntmp, inb(0x200 + tmp), inb(0x208 + tmp));\r\nfor (tmp = 0; tmp <= 0x01; tmp += 1)\r\ndev_dbg(chip->card->dev,\r\n"0x%02x: mpu300 0x%04x, mpu310 0x%04x, mpu320 0x%04x, "\r\n"mpu330 0x%04x opl388 0x%04x opl38c 0x%04x\n",\r\ntmp,\r\ninb(0x300 + tmp),\r\ninb(0x310 + tmp),\r\ninb(0x320 + tmp),\r\ninb(0x330 + tmp),\r\ninb(0x388 + tmp),\r\ninb(0x38c + tmp));\r\nfor (tmp = 0; tmp < AZF_IO_SIZE_CTRL; tmp += 2)\r\ndev_dbg(chip->card->dev,\r\n"ctrl 0x%02x: 0x%04x\n",\r\ntmp, snd_azf3328_ctrl_inw(chip, tmp));\r\nfor (tmp = 0; tmp < AZF_IO_SIZE_MIXER; tmp += 2)\r\ndev_dbg(chip->card->dev,\r\n"mixer 0x%02x: 0x%04x\n",\r\ntmp, snd_azf3328_mixer_inw(chip, tmp));\r\n}\r\nstatic int\r\nsnd_azf3328_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nunsigned long device_type,\r\nstruct snd_azf3328 **rchip)\r\n{\r\nstruct snd_azf3328 *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_azf3328_dev_free,\r\n};\r\nu8 dma_init;\r\nenum snd_azf3328_codec_type codec_type;\r\nstruct snd_azf3328_codec_data *codec_setup;\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nif (dma_set_mask(&pci->dev, DMA_BIT_MASK(24)) < 0 ||\r\ndma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(24)) < 0) {\r\ndev_err(card->dev,\r\n"architecture does not support 24bit PCI busmaster DMA\n"\r\n);\r\nerr = -ENXIO;\r\ngoto out_err;\r\n}\r\nerr = pci_request_regions(pci, "Aztech AZF3328");\r\nif (err < 0)\r\ngoto out_err;\r\nchip->ctrl_io = pci_resource_start(pci, 0);\r\nchip->game_io = pci_resource_start(pci, 1);\r\nchip->mpu_io = pci_resource_start(pci, 2);\r\nchip->opl3_io = pci_resource_start(pci, 3);\r\nchip->mixer_io = pci_resource_start(pci, 4);\r\ncodec_setup = &chip->codecs[AZF_CODEC_PLAYBACK];\r\ncodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_PLAYBACK;\r\ncodec_setup->lock = &chip->reg_lock;\r\ncodec_setup->type = AZF_CODEC_PLAYBACK;\r\ncodec_setup->name = "PLAYBACK";\r\ncodec_setup = &chip->codecs[AZF_CODEC_CAPTURE];\r\ncodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_CAPTURE;\r\ncodec_setup->lock = &chip->reg_lock;\r\ncodec_setup->type = AZF_CODEC_CAPTURE;\r\ncodec_setup->name = "CAPTURE";\r\ncodec_setup = &chip->codecs[AZF_CODEC_I2S_OUT];\r\ncodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_I2S_OUT;\r\ncodec_setup->lock = &chip->reg_lock;\r\ncodec_setup->type = AZF_CODEC_I2S_OUT;\r\ncodec_setup->name = "I2S_OUT";\r\nif (request_irq(pci->irq, snd_azf3328_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nerr = -EBUSY;\r\ngoto out_err;\r\n}\r\nchip->irq = pci->irq;\r\npci_set_master(pci);\r\nsynchronize_irq(chip->irq);\r\nsnd_azf3328_debug_show_ports(chip);\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = snd_azf3328_mixer_new(chip);\r\nif (err < 0)\r\ngoto out_err;\r\ndma_init = DMA_RUN_SOMETHING2|DMA_EPILOGUE_SOMETHING|DMA_SOMETHING_ELSE;\r\nfor (codec_type = AZF_CODEC_PLAYBACK;\r\ncodec_type <= AZF_CODEC_I2S_OUT; ++codec_type) {\r\nstruct snd_azf3328_codec_data *codec =\r\n&chip->codecs[codec_type];\r\ncodec->running = 1;\r\nsnd_azf3328_ctrl_codec_activity(chip, codec_type, 0);\r\nspin_lock_irq(codec->lock);\r\nsnd_azf3328_codec_outb(codec, IDX_IO_CODEC_DMA_FLAGS,\r\ndma_init);\r\nspin_unlock_irq(codec->lock);\r\n}\r\n*rchip = chip;\r\nerr = 0;\r\ngoto out;\r\nout_err:\r\nif (chip)\r\nsnd_azf3328_free(chip);\r\npci_disable_device(pci);\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_azf3328_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_azf3328 *chip;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nif (dev >= SNDRV_CARDS) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (!enable[dev]) {\r\ndev++;\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\ngoto out;\r\nstrcpy(card->driver, "AZF3328");\r\nstrcpy(card->shortname, "Aztech AZF3328 (PCI168)");\r\nerr = snd_azf3328_create(card, pci, pci_id->driver_data, &chip);\r\nif (err < 0)\r\ngoto out_err;\r\ncard->private_data = chip;\r\nerr = snd_mpu401_uart_new(\r\ncard, 0,\r\nMPU401_HW_AZT2320, chip->mpu_io,\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi\r\n);\r\nif (err < 0) {\r\ndev_err(card->dev, "no MPU-401 device at 0x%lx?\n",\r\nchip->mpu_io\r\n);\r\ngoto out_err;\r\n}\r\nerr = snd_azf3328_timer(chip, 0);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = snd_azf3328_pcm(chip);\r\nif (err < 0)\r\ngoto out_err;\r\nif (snd_opl3_create(card, chip->opl3_io, chip->opl3_io+2,\r\nOPL3_HW_AUTO, 1, &opl3) < 0) {\r\ndev_err(card->dev, "no OPL3 device at 0x%lx-0x%lx?\n",\r\nchip->opl3_io, chip->opl3_io+2\r\n);\r\n} else {\r\nerr = snd_opl3_timer_new(opl3, 1, 2);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\r\nif (err < 0)\r\ngoto out_err;\r\nopl3->private_data = chip;\r\n}\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, chip->ctrl_io, chip->irq);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto out_err;\r\n#ifdef MODULE\r\ndev_info(card->dev,\r\n"Sound driver for Aztech AZF3328-based soundcards such as PCI168.\n");\r\ndev_info(card->dev,\r\n"Hardware was completely undocumented, unfortunately.\n");\r\ndev_info(card->dev,\r\n"Feel free to contact andi AT lisas.de for bug reports etc.!\n");\r\ndev_info(card->dev,\r\n"User-scalable sequencer timer set to %dHz (1024000Hz / %d).\n",\r\n1024000 / seqtimer_scaling, seqtimer_scaling);\r\n#endif\r\nsnd_azf3328_gameport(chip, dev);\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nerr = 0;\r\ngoto out;\r\nout_err:\r\ndev_err(card->dev, "something failed, exiting\n");\r\nsnd_card_free(card);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nsnd_azf3328_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic inline void\r\nsnd_azf3328_suspend_regs(const struct snd_azf3328 *chip,\r\nunsigned long io_addr, unsigned count, u32 *saved_regs)\r\n{\r\nunsigned reg;\r\nfor (reg = 0; reg < count; ++reg) {\r\n*saved_regs = inl(io_addr);\r\ndev_dbg(chip->card->dev, "suspend: io 0x%04lx: 0x%08x\n",\r\nio_addr, *saved_regs);\r\n++saved_regs;\r\nio_addr += sizeof(*saved_regs);\r\n}\r\n}\r\nstatic inline void\r\nsnd_azf3328_resume_regs(const struct snd_azf3328 *chip,\r\nconst u32 *saved_regs,\r\nunsigned long io_addr,\r\nunsigned count\r\n)\r\n{\r\nunsigned reg;\r\nfor (reg = 0; reg < count; ++reg) {\r\noutl(*saved_regs, io_addr);\r\ndev_dbg(chip->card->dev,\r\n"resume: io 0x%04lx: 0x%08x --> 0x%08x\n",\r\nio_addr, *saved_regs, inl(io_addr));\r\n++saved_regs;\r\nio_addr += sizeof(*saved_regs);\r\n}\r\n}\r\nstatic inline void\r\nsnd_azf3328_suspend_ac97(struct snd_azf3328 *chip)\r\n{\r\n#ifdef AZF_USE_AC97_LAYER\r\nsnd_ac97_suspend(chip->ac97);\r\n#else\r\nsnd_azf3328_suspend_regs(chip, chip->mixer_io,\r\nARRAY_SIZE(chip->saved_regs_mixer), chip->saved_regs_mixer);\r\nsnd_azf3328_mixer_mute_control_master(chip, 1);\r\nsnd_azf3328_mixer_mute_control_pcm(chip, 1);\r\n#endif\r\n}\r\nstatic inline void\r\nsnd_azf3328_resume_ac97(const struct snd_azf3328 *chip)\r\n{\r\n#ifdef AZF_USE_AC97_LAYER\r\nsnd_ac97_resume(chip->ac97);\r\n#else\r\nsnd_azf3328_resume_regs(chip, chip->saved_regs_mixer, chip->mixer_io,\r\nARRAY_SIZE(chip->saved_regs_mixer));\r\noutw(((u16 *)chip->saved_regs_mixer)[1], chip->mixer_io + 2);\r\n#endif\r\n}\r\nstatic int\r\nsnd_azf3328_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_azf3328 *chip = card->private_data;\r\nu16 *saved_regs_ctrl_u16;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm[AZF_CODEC_PLAYBACK]);\r\nsnd_pcm_suspend_all(chip->pcm[AZF_CODEC_I2S_OUT]);\r\nsnd_azf3328_suspend_ac97(chip);\r\nsnd_azf3328_suspend_regs(chip, chip->ctrl_io,\r\nARRAY_SIZE(chip->saved_regs_ctrl), chip->saved_regs_ctrl);\r\nsaved_regs_ctrl_u16 = (u16 *)chip->saved_regs_ctrl;\r\nsaved_regs_ctrl_u16[IDX_IO_6AH / 2] = chip->shadow_reg_ctrl_6AH;\r\nsnd_azf3328_suspend_regs(chip, chip->game_io,\r\nARRAY_SIZE(chip->saved_regs_game), chip->saved_regs_game);\r\nsnd_azf3328_suspend_regs(chip, chip->mpu_io,\r\nARRAY_SIZE(chip->saved_regs_mpu), chip->saved_regs_mpu);\r\nsnd_azf3328_suspend_regs(chip, chip->opl3_io,\r\nARRAY_SIZE(chip->saved_regs_opl3), chip->saved_regs_opl3);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_azf3328_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nconst struct snd_azf3328 *chip = card->private_data;\r\nsnd_azf3328_resume_regs(chip, chip->saved_regs_game, chip->game_io,\r\nARRAY_SIZE(chip->saved_regs_game));\r\nsnd_azf3328_resume_regs(chip, chip->saved_regs_mpu, chip->mpu_io,\r\nARRAY_SIZE(chip->saved_regs_mpu));\r\nsnd_azf3328_resume_regs(chip, chip->saved_regs_opl3, chip->opl3_io,\r\nARRAY_SIZE(chip->saved_regs_opl3));\r\nsnd_azf3328_resume_ac97(chip);\r\nsnd_azf3328_resume_regs(chip, chip->saved_regs_ctrl, chip->ctrl_io,\r\nARRAY_SIZE(chip->saved_regs_ctrl));\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
