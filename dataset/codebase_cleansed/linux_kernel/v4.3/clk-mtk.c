struct clk_onecell_data *mtk_alloc_clk_data(unsigned int clk_num)\r\n{\r\nint i;\r\nstruct clk_onecell_data *clk_data;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn NULL;\r\nclk_data->clks = kcalloc(clk_num, sizeof(*clk_data->clks), GFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err_out;\r\nclk_data->clk_num = clk_num;\r\nfor (i = 0; i < clk_num; i++)\r\nclk_data->clks[i] = ERR_PTR(-ENOENT);\r\nreturn clk_data;\r\nerr_out:\r\nkfree(clk_data);\r\nreturn NULL;\r\n}\r\nvoid mtk_clk_register_factors(const struct mtk_fixed_factor *clks, int num,\r\nstruct clk_onecell_data *clk_data)\r\n{\r\nint i;\r\nstruct clk *clk;\r\nfor (i = 0; i < num; i++) {\r\nconst struct mtk_fixed_factor *ff = &clks[i];\r\nclk = clk_register_fixed_factor(NULL, ff->name, ff->parent_name,\r\nCLK_SET_RATE_PARENT, ff->mult, ff->div);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to register clk %s: %ld\n",\r\nff->name, PTR_ERR(clk));\r\ncontinue;\r\n}\r\nif (clk_data)\r\nclk_data->clks[ff->id] = clk;\r\n}\r\n}\r\nint mtk_clk_register_gates(struct device_node *node, const struct mtk_gate *clks,\r\nint num, struct clk_onecell_data *clk_data)\r\n{\r\nint i;\r\nstruct clk *clk;\r\nstruct regmap *regmap;\r\nif (!clk_data)\r\nreturn -ENOMEM;\r\nregmap = syscon_node_to_regmap(node);\r\nif (IS_ERR(regmap)) {\r\npr_err("Cannot find regmap for %s: %ld\n", node->full_name,\r\nPTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nfor (i = 0; i < num; i++) {\r\nconst struct mtk_gate *gate = &clks[i];\r\nclk = mtk_clk_register_gate(gate->name, gate->parent_name,\r\nregmap,\r\ngate->regs->set_ofs,\r\ngate->regs->clr_ofs,\r\ngate->regs->sta_ofs,\r\ngate->shift, gate->ops);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to register clk %s: %ld\n",\r\ngate->name, PTR_ERR(clk));\r\ncontinue;\r\n}\r\nclk_data->clks[gate->id] = clk;\r\n}\r\nreturn 0;\r\n}\r\nstruct clk *mtk_clk_register_composite(const struct mtk_composite *mc,\r\nvoid __iomem *base, spinlock_t *lock)\r\n{\r\nstruct clk *clk;\r\nstruct clk_mux *mux = NULL;\r\nstruct clk_gate *gate = NULL;\r\nstruct clk_divider *div = NULL;\r\nstruct clk_hw *mux_hw = NULL, *gate_hw = NULL, *div_hw = NULL;\r\nconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL, *div_ops = NULL;\r\nconst char * const *parent_names;\r\nconst char *parent;\r\nint num_parents;\r\nint ret;\r\nif (mc->mux_shift >= 0) {\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn ERR_PTR(-ENOMEM);\r\nmux->reg = base + mc->mux_reg;\r\nmux->mask = BIT(mc->mux_width) - 1;\r\nmux->shift = mc->mux_shift;\r\nmux->lock = lock;\r\nmux_hw = &mux->hw;\r\nmux_ops = &clk_mux_ops;\r\nparent_names = mc->parent_names;\r\nnum_parents = mc->num_parents;\r\n} else {\r\nparent = mc->parent;\r\nparent_names = &parent;\r\nnum_parents = 1;\r\n}\r\nif (mc->gate_shift >= 0) {\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\ngate->reg = base + mc->gate_reg;\r\ngate->bit_idx = mc->gate_shift;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = lock;\r\ngate_hw = &gate->hw;\r\ngate_ops = &clk_gate_ops;\r\n}\r\nif (mc->divider_shift >= 0) {\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div) {\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\ndiv->reg = base + mc->divider_reg;\r\ndiv->shift = mc->divider_shift;\r\ndiv->width = mc->divider_width;\r\ndiv->lock = lock;\r\ndiv_hw = &div->hw;\r\ndiv_ops = &clk_divider_ops;\r\n}\r\nclk = clk_register_composite(NULL, mc->name, parent_names, num_parents,\r\nmux_hw, mux_ops,\r\ndiv_hw, div_ops,\r\ngate_hw, gate_ops,\r\nmc->flags);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(mux);\r\n}\r\nreturn clk;\r\nerr_out:\r\nkfree(mux);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid mtk_clk_register_composites(const struct mtk_composite *mcs,\r\nint num, void __iomem *base, spinlock_t *lock,\r\nstruct clk_onecell_data *clk_data)\r\n{\r\nstruct clk *clk;\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nconst struct mtk_composite *mc = &mcs[i];\r\nclk = mtk_clk_register_composite(mc, base, lock);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to register clk %s: %ld\n",\r\nmc->name, PTR_ERR(clk));\r\ncontinue;\r\n}\r\nif (clk_data)\r\nclk_data->clks[mc->id] = clk;\r\n}\r\n}
