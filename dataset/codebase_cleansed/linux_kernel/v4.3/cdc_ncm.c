static int cdc_ncm_get_sset_count(struct net_device __always_unused *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(cdc_ncm_gstrings_stats);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void cdc_ncm_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats __always_unused *stats,\r\nu64 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nint i;\r\nchar *p = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {\r\np = (char *)ctx + cdc_ncm_gstrings_stats[i].stat_offset;\r\ndata[i] = (cdc_ncm_gstrings_stats[i].sizeof_stat == sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\r\n}\r\n}\r\nstatic void cdc_ncm_get_strings(struct net_device __always_unused *netdev, u32 stringset, u8 *data)\r\n{\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {\r\nmemcpy(p, cdc_ncm_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\n}\r\n}\r\nstatic u32 cdc_ncm_check_rx_max(struct usbnet *dev, u32 new_rx)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu32 val, max, min;\r\nmin = USB_CDC_NCM_NTB_MIN_IN_SIZE;\r\nmax = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));\r\nif (max < min) {\r\ndev_warn(&dev->intf->dev, "dwNtbInMaxSize=%u is too small. Using %u\n",\r\nle32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);\r\nmax = min;\r\n}\r\nval = clamp_t(u32, new_rx, min, max);\r\nif (val != new_rx)\r\ndev_dbg(&dev->intf->dev, "rx_max must be in the [%u, %u] range\n", min, max);\r\nreturn val;\r\n}\r\nstatic u32 cdc_ncm_check_tx_max(struct usbnet *dev, u32 new_tx)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu32 val, max, min;\r\nmin = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth16);\r\nmax = min_t(u32, CDC_NCM_NTB_MAX_SIZE_TX, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));\r\nmin = min(min, max);\r\nval = clamp_t(u32, new_tx, min, max);\r\nif (val != new_tx)\r\ndev_dbg(&dev->intf->dev, "tx_max must be in the [%u, %u] range\n", min, max);\r\nreturn val;\r\n}\r\nstatic ssize_t cdc_ncm_show_min_tx_pkt(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nreturn sprintf(buf, "%u\n", ctx->min_tx_pkt);\r\n}\r\nstatic ssize_t cdc_ncm_show_rx_max(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nreturn sprintf(buf, "%u\n", ctx->rx_max);\r\n}\r\nstatic ssize_t cdc_ncm_show_tx_max(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nreturn sprintf(buf, "%u\n", ctx->tx_max);\r\n}\r\nstatic ssize_t cdc_ncm_show_tx_timer_usecs(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nreturn sprintf(buf, "%u\n", ctx->timer_interval / (u32)NSEC_PER_USEC);\r\n}\r\nstatic ssize_t cdc_ncm_store_min_tx_pkt(struct device *d, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nctx->min_tx_pkt = val;\r\nreturn len;\r\n}\r\nstatic ssize_t cdc_ncm_store_rx_max(struct device *d, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val) || cdc_ncm_check_rx_max(dev, val) != val)\r\nreturn -EINVAL;\r\ncdc_ncm_update_rxtx_max(dev, val, ctx->tx_max);\r\nreturn len;\r\n}\r\nstatic ssize_t cdc_ncm_store_tx_max(struct device *d, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val) || cdc_ncm_check_tx_max(dev, val) != val)\r\nreturn -EINVAL;\r\ncdc_ncm_update_rxtx_max(dev, ctx->rx_max, val);\r\nreturn len;\r\n}\r\nstatic ssize_t cdc_ncm_store_tx_timer_usecs(struct device *d, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nssize_t ret;\r\nunsigned long val;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val && (val < CDC_NCM_TIMER_INTERVAL_MIN || val > CDC_NCM_TIMER_INTERVAL_MAX))\r\nreturn -EINVAL;\r\nspin_lock_bh(&ctx->mtx);\r\nctx->timer_interval = val * NSEC_PER_USEC;\r\nif (!ctx->timer_interval)\r\nctx->tx_timer_pending = 0;\r\nspin_unlock_bh(&ctx->mtx);\r\nreturn len;\r\n}\r\nstatic void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\r\nu32 val;\r\nval = cdc_ncm_check_rx_max(dev, new_rx);\r\nif (val != ctx->rx_max) {\r\n__le32 dwNtbInMaxSize = cpu_to_le32(val);\r\ndev_info(&dev->intf->dev, "setting rx_max = %u\n", val);\r\nif (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, &dwNtbInMaxSize, 4) < 0)\r\ndev_dbg(&dev->intf->dev, "Setting NTB Input Size failed\n");\r\nelse\r\nctx->rx_max = val;\r\n}\r\nif (dev->rx_urb_size != ctx->rx_max) {\r\ndev->rx_urb_size = ctx->rx_max;\r\nif (netif_running(dev->net))\r\nusbnet_unlink_rx_urbs(dev);\r\n}\r\nval = cdc_ncm_check_tx_max(dev, new_tx);\r\nif (val != ctx->tx_max)\r\ndev_info(&dev->intf->dev, "setting tx_max = %u\n", val);\r\nif (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&\r\nval % usb_maxpacket(dev->udev, dev->out, 1) == 0)\r\nval++;\r\nif (netif_running(dev->net) && val > ctx->tx_max) {\r\nnetif_tx_lock_bh(dev->net);\r\nusbnet_start_xmit(NULL, dev->net);\r\nif (ctx->tx_curr_skb) {\r\ndev_kfree_skb_any(ctx->tx_curr_skb);\r\nctx->tx_curr_skb = NULL;\r\n}\r\nctx->tx_max = val;\r\nnetif_tx_unlock_bh(dev->net);\r\n} else {\r\nctx->tx_max = val;\r\n}\r\ndev->hard_mtu = ctx->tx_max;\r\nusbnet_update_max_qlen(dev);\r\nctx->min_tx_pkt = clamp_t(u16, ctx->tx_max - 3 * usb_maxpacket(dev->udev, dev->out, 1),\r\nCDC_NCM_MIN_TX_PKT, ctx->tx_max);\r\n}\r\nstatic u8 cdc_ncm_flags(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)\r\nreturn ctx->mbim_desc->bmNetworkCapabilities;\r\nif (ctx->func_desc)\r\nreturn ctx->func_desc->bmNetworkCapabilities;\r\nreturn 0;\r\n}\r\nstatic int cdc_ncm_eth_hlen(struct usbnet *dev)\r\n{\r\nif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))\r\nreturn 0;\r\nreturn ETH_HLEN;\r\n}\r\nstatic u32 cdc_ncm_min_dgram_size(struct usbnet *dev)\r\n{\r\nif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))\r\nreturn CDC_MBIM_MIN_DATAGRAM_SIZE;\r\nreturn CDC_NCM_MIN_DATAGRAM_SIZE;\r\n}\r\nstatic u32 cdc_ncm_max_dgram_size(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)\r\nreturn le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);\r\nif (ctx->ether_desc)\r\nreturn le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\r\nreturn CDC_NCM_MAX_DATAGRAM_SIZE;\r\n}\r\nstatic int cdc_ncm_init(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\r\nint err;\r\nerr = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,\r\nUSB_TYPE_CLASS | USB_DIR_IN\r\n|USB_RECIP_INTERFACE,\r\n0, iface_no, &ctx->ncm_parm,\r\nsizeof(ctx->ncm_parm));\r\nif (err < 0) {\r\ndev_err(&dev->intf->dev, "failed GET_NTB_PARAMETERS\n");\r\nreturn err;\r\n}\r\nif (cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_CRC_MODE) {\r\ndev_dbg(&dev->intf->dev, "Setting CRC mode off\n");\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_CRC_MODE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_CRC_NOT_APPENDED,\r\niface_no, NULL, 0);\r\nif (err < 0)\r\ndev_err(&dev->intf->dev, "SET_CRC_MODE failed\n");\r\n}\r\nif (le16_to_cpu(ctx->ncm_parm.bmNtbFormatsSupported) &\r\nUSB_CDC_NCM_NTB32_SUPPORTED) {\r\ndev_dbg(&dev->intf->dev, "Setting NTB format to 16-bit\n");\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_NTB_FORMAT,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_NTB16_FORMAT,\r\niface_no, NULL, 0);\r\nif (err < 0)\r\ndev_err(&dev->intf->dev, "SET_NTB_FORMAT failed\n");\r\n}\r\nctx->rx_max = le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize);\r\nctx->tx_max = le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize);\r\nctx->tx_remainder = le16_to_cpu(ctx->ncm_parm.wNdpOutPayloadRemainder);\r\nctx->tx_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutDivisor);\r\nctx->tx_ndp_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutAlignment);\r\nctx->tx_max_datagrams = le16_to_cpu(ctx->ncm_parm.wNtbOutMaxDatagrams);\r\ndev_dbg(&dev->intf->dev,\r\n"dwNtbInMaxSize=%u dwNtbOutMaxSize=%u wNdpOutPayloadRemainder=%u wNdpOutDivisor=%u wNdpOutAlignment=%u wNtbOutMaxDatagrams=%u flags=0x%x\n",\r\nctx->rx_max, ctx->tx_max, ctx->tx_remainder, ctx->tx_modulus,\r\nctx->tx_ndp_modulus, ctx->tx_max_datagrams, cdc_ncm_flags(dev));\r\nif ((ctx->tx_max_datagrams == 0) ||\r\n(ctx->tx_max_datagrams > CDC_NCM_DPT_DATAGRAMS_MAX))\r\nctx->tx_max_datagrams = CDC_NCM_DPT_DATAGRAMS_MAX;\r\nctx->max_ndp_size = sizeof(struct usb_cdc_ncm_ndp16) + (ctx->tx_max_datagrams + 1) * sizeof(struct usb_cdc_ncm_dpe16);\r\nctx->timer_interval = CDC_NCM_TIMER_INTERVAL_USEC * NSEC_PER_USEC;\r\nreturn 0;\r\n}\r\nstatic void cdc_ncm_set_dgram_size(struct usbnet *dev, int new_size)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\r\n__le16 max_datagram_size;\r\nu16 mbim_mtu;\r\nint err;\r\nctx->max_datagram_size = clamp_t(u32, new_size,\r\ncdc_ncm_min_dgram_size(dev),\r\nCDC_NCM_MAX_DATAGRAM_SIZE);\r\nif (!(cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE))\r\ngoto out;\r\nerr = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\r\n0, iface_no, &max_datagram_size, 2);\r\nif (err < 0) {\r\ndev_dbg(&dev->intf->dev, "GET_MAX_DATAGRAM_SIZE failed\n");\r\ngoto out;\r\n}\r\nif (le16_to_cpu(max_datagram_size) == ctx->max_datagram_size)\r\ngoto out;\r\nmax_datagram_size = cpu_to_le16(ctx->max_datagram_size);\r\nerr = usbnet_write_cmd(dev, USB_CDC_SET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,\r\n0, iface_no, &max_datagram_size, 2);\r\nif (err < 0)\r\ndev_dbg(&dev->intf->dev, "SET_MAX_DATAGRAM_SIZE failed\n");\r\nout:\r\ndev->net->mtu = min_t(int, dev->net->mtu, ctx->max_datagram_size - cdc_ncm_eth_hlen(dev));\r\nif (ctx->mbim_extended_desc) {\r\nmbim_mtu = le16_to_cpu(ctx->mbim_extended_desc->wMTU);\r\nif (mbim_mtu != 0 && mbim_mtu < dev->net->mtu)\r\ndev->net->mtu = mbim_mtu;\r\n}\r\n}\r\nstatic void cdc_ncm_fix_modulus(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu32 val;\r\nval = ctx->tx_ndp_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\ndev_dbg(&dev->intf->dev, "Using default alignment: 4 bytes\n");\r\nctx->tx_ndp_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nval = ctx->tx_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\ndev_dbg(&dev->intf->dev, "Using default transmit modulus: 4 bytes\n");\r\nctx->tx_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nif (ctx->tx_remainder >= ctx->tx_modulus) {\r\ndev_dbg(&dev->intf->dev, "Using default transmit remainder: 0 bytes\n");\r\nctx->tx_remainder = 0;\r\n}\r\nctx->tx_remainder = ((ctx->tx_remainder - cdc_ncm_eth_hlen(dev)) &\r\n(ctx->tx_modulus - 1));\r\n}\r\nstatic int cdc_ncm_setup(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu32 def_rx, def_tx;\r\ndef_rx = min_t(u32, CDC_NCM_NTB_DEF_SIZE_RX,\r\nle32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));\r\ndef_tx = min_t(u32, CDC_NCM_NTB_DEF_SIZE_TX,\r\nle32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));\r\ncdc_ncm_update_rxtx_max(dev, def_rx, def_tx);\r\ncdc_ncm_fix_modulus(dev);\r\ncdc_ncm_set_dgram_size(dev, cdc_ncm_max_dgram_size(dev));\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_find_endpoints(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct usb_host_endpoint *e, *in = NULL, *out = NULL;\r\nu8 ep;\r\nfor (ep = 0; ep < intf->cur_altsetting->desc.bNumEndpoints; ep++) {\r\ne = intf->cur_altsetting->endpoint + ep;\r\nswitch (e->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (!dev->status)\r\ndev->status = e;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (!in)\r\nin = e;\r\n} else {\r\nif (!out)\r\nout = e;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (in && !dev->in)\r\ndev->in = usb_rcvbulkpipe(dev->udev,\r\nin->desc.bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nif (out && !dev->out)\r\ndev->out = usb_sndbulkpipe(dev->udev,\r\nout->desc.bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\n}\r\nstatic void cdc_ncm_free(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (ctx == NULL)\r\nreturn;\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\nctx->tx_rem_skb = NULL;\r\n}\r\nif (ctx->tx_curr_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_curr_skb);\r\nctx->tx_curr_skb = NULL;\r\n}\r\nkfree(ctx->delayed_ndp16);\r\nkfree(ctx);\r\n}\r\nint cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags)\r\n{\r\nconst struct usb_cdc_union_desc *union_desc = NULL;\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_driver *driver;\r\nu8 *buf;\r\nint len;\r\nint temp;\r\nu8 iface_no;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nhrtimer_init(&ctx->tx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nctx->tx_timer.function = &cdc_ncm_tx_timer_cb;\r\nctx->bh.data = (unsigned long)dev;\r\nctx->bh.func = cdc_ncm_txpath_bh;\r\natomic_set(&ctx->stop, 0);\r\nspin_lock_init(&ctx->mtx);\r\ndev->data[0] = (unsigned long)ctx;\r\nctx->control = intf;\r\ndriver = driver_of(intf);\r\nbuf = intf->cur_altsetting->extra;\r\nlen = intf->cur_altsetting->extralen;\r\nwhile ((len > 0) && (buf[0] > 2) && (buf[0] <= len)) {\r\nif (buf[1] != USB_DT_CS_INTERFACE)\r\ngoto advance;\r\nswitch (buf[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (buf[0] < sizeof(*union_desc))\r\nbreak;\r\nunion_desc = (const struct usb_cdc_union_desc *)buf;\r\nif (intf->cur_altsetting->desc.bInterfaceNumber !=\r\nunion_desc->bMasterInterface0) {\r\ndev_dbg(&intf->dev, "bogus CDC Union\n");\r\ngoto error;\r\n}\r\nctx->data = usb_ifnum_to_if(dev->udev,\r\nunion_desc->bSlaveInterface0);\r\nbreak;\r\ncase USB_CDC_ETHERNET_TYPE:\r\nif (buf[0] < sizeof(*(ctx->ether_desc)))\r\nbreak;\r\nctx->ether_desc =\r\n(const struct usb_cdc_ether_desc *)buf;\r\nbreak;\r\ncase USB_CDC_NCM_TYPE:\r\nif (buf[0] < sizeof(*(ctx->func_desc)))\r\nbreak;\r\nctx->func_desc = (const struct usb_cdc_ncm_desc *)buf;\r\nbreak;\r\ncase USB_CDC_MBIM_TYPE:\r\nif (buf[0] < sizeof(*(ctx->mbim_desc)))\r\nbreak;\r\nctx->mbim_desc = (const struct usb_cdc_mbim_desc *)buf;\r\nbreak;\r\ncase USB_CDC_MBIM_EXTENDED_TYPE:\r\nif (buf[0] < sizeof(*(ctx->mbim_extended_desc)))\r\nbreak;\r\nctx->mbim_extended_desc =\r\n(const struct usb_cdc_mbim_extended_desc *)buf;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadvance:\r\ntemp = buf[0];\r\nbuf += temp;\r\nlen -= temp;\r\n}\r\nif (!union_desc && intf->intf_assoc && intf->intf_assoc->bInterfaceCount == 2) {\r\nctx->data = usb_ifnum_to_if(dev->udev, intf->cur_altsetting->desc.bInterfaceNumber + 1);\r\ndev_dbg(&intf->dev, "CDC Union missing - got slave from IAD\n");\r\n}\r\nif (!ctx->data) {\r\ndev_dbg(&intf->dev, "CDC Union missing and no IAD found\n");\r\ngoto error;\r\n}\r\nif (cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting)) {\r\nif (!ctx->mbim_desc) {\r\ndev_dbg(&intf->dev, "MBIM functional descriptor missing\n");\r\ngoto error;\r\n}\r\n} else {\r\nif (!ctx->ether_desc || !ctx->func_desc) {\r\ndev_dbg(&intf->dev, "NCM or ECM functional descriptors missing\n");\r\ngoto error;\r\n}\r\n}\r\nif (ctx->data != ctx->control) {\r\ntemp = usb_driver_claim_interface(driver, ctx->data, dev);\r\nif (temp) {\r\ndev_dbg(&intf->dev, "failed to claim data intf\n");\r\ngoto error;\r\n}\r\n}\r\niface_no = ctx->data->cur_altsetting->desc.bInterfaceNumber;\r\ntemp = usb_set_interface(dev->udev, iface_no, 0);\r\nif (temp) {\r\ndev_dbg(&intf->dev, "set interface failed\n");\r\ngoto error2;\r\n}\r\nif (cdc_ncm_init(dev))\r\ngoto error2;\r\ntemp = usb_set_interface(dev->udev, iface_no, data_altsetting);\r\nif (temp) {\r\ndev_dbg(&intf->dev, "set interface failed\n");\r\ngoto error2;\r\n}\r\ncdc_ncm_find_endpoints(dev, ctx->data);\r\ncdc_ncm_find_endpoints(dev, ctx->control);\r\nif (!dev->in || !dev->out || !dev->status) {\r\ndev_dbg(&intf->dev, "failed to collect endpoints\n");\r\ngoto error2;\r\n}\r\nusb_set_intfdata(ctx->data, dev);\r\nusb_set_intfdata(ctx->control, dev);\r\nif (ctx->ether_desc) {\r\ntemp = usbnet_get_ethernet_addr(dev, ctx->ether_desc->iMACAddress);\r\nif (temp) {\r\ndev_dbg(&intf->dev, "failed to get mac address\n");\r\ngoto error2;\r\n}\r\ndev_info(&intf->dev, "MAC-Address: %pM\n", dev->net->dev_addr);\r\n}\r\ncdc_ncm_setup(dev);\r\nctx->drvflags = drvflags;\r\nif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\r\nctx->delayed_ndp16 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);\r\nif (!ctx->delayed_ndp16)\r\ngoto error2;\r\ndev_info(&intf->dev, "NDP will be placed at end of frame for this device.");\r\n}\r\ndev->net->ethtool_ops = &cdc_ncm_ethtool_ops;\r\ndev->net->sysfs_groups[0] = &cdc_ncm_sysfs_attr_group;\r\nreturn 0;\r\nerror2:\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_set_intfdata(ctx->data, NULL);\r\nif (ctx->data != ctx->control)\r\nusb_driver_release_interface(driver, ctx->data);\r\nerror:\r\ncdc_ncm_free((struct cdc_ncm_ctx *)dev->data[0]);\r\ndev->data[0] = 0;\r\ndev_info(&intf->dev, "bind() failure\n");\r\nreturn -ENODEV;\r\n}\r\nvoid cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nstruct usb_driver *driver = driver_of(intf);\r\nif (ctx == NULL)\r\nreturn;\r\natomic_set(&ctx->stop, 1);\r\nif (hrtimer_active(&ctx->tx_timer))\r\nhrtimer_cancel(&ctx->tx_timer);\r\ntasklet_kill(&ctx->bh);\r\nif (ctx->control == ctx->data)\r\nctx->data = NULL;\r\nif (intf == ctx->control && ctx->data) {\r\nusb_set_intfdata(ctx->data, NULL);\r\nusb_driver_release_interface(driver, ctx->data);\r\nctx->data = NULL;\r\n} else if (intf == ctx->data && ctx->control) {\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_driver_release_interface(driver, ctx->control);\r\nctx->control = NULL;\r\n}\r\nusb_set_intfdata(intf, NULL);\r\ncdc_ncm_free(ctx);\r\n}\r\nu8 cdc_ncm_select_altsetting(struct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *alt;\r\nif (intf->num_altsetting < 2)\r\nreturn intf->cur_altsetting->desc.bAlternateSetting;\r\nif (prefer_mbim) {\r\nalt = usb_altnum_to_altsetting(intf, CDC_NCM_COMM_ALTSETTING_MBIM);\r\nif (alt && cdc_ncm_comm_intf_is_mbim(alt))\r\nreturn CDC_NCM_COMM_ALTSETTING_MBIM;\r\n}\r\nreturn CDC_NCM_COMM_ALTSETTING_NCM;\r\n}\r\nstatic int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\r\nreturn -ENODEV;\r\nret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\r\nusbnet_link_change(dev, 0, 0);\r\nreturn ret;\r\n}\r\nstatic void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)\r\n{\r\nsize_t align = ALIGN(skb->len, modulus) - skb->len + remainder;\r\nif (skb->len + align > max)\r\nalign = max - skb->len;\r\nif (align && skb_tailroom(skb) >= align)\r\nmemset(skb_put(skb, align), 0, align);\r\n}\r\nstatic struct usb_cdc_ncm_ndp16 *cdc_ncm_ndp(struct cdc_ncm_ctx *ctx, struct sk_buff *skb, __le32 sign, size_t reserve)\r\n{\r\nstruct usb_cdc_ncm_ndp16 *ndp16 = NULL;\r\nstruct usb_cdc_ncm_nth16 *nth16 = (void *)skb->data;\r\nsize_t ndpoffset = le16_to_cpu(nth16->wNdpIndex);\r\nif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)\r\nif (ctx->delayed_ndp16->dwSignature == sign)\r\nreturn ctx->delayed_ndp16;\r\nwhile (ndpoffset) {\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb->data + ndpoffset);\r\nif (ndp16->dwSignature == sign)\r\nreturn ndp16;\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\n}\r\nif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\r\ncdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_max);\r\nif ((ctx->tx_max - skb->len - reserve) < ctx->max_ndp_size)\r\nreturn NULL;\r\nif (ndp16)\r\nndp16->wNextNdpIndex = cpu_to_le16(skb->len);\r\nelse\r\nnth16->wNdpIndex = cpu_to_le16(skb->len);\r\nif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)memset(skb_put(skb, ctx->max_ndp_size), 0, ctx->max_ndp_size);\r\nelse\r\nndp16 = ctx->delayed_ndp16;\r\nndp16->dwSignature = sign;\r\nndp16->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp16) + sizeof(struct usb_cdc_ncm_dpe16));\r\nreturn ndp16;\r\n}\r\nstruct sk_buff *\r\ncdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nstruct usb_cdc_ncm_nth16 *nth16;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct sk_buff *skb_out;\r\nu16 n = 0, index, ndplen;\r\nu8 ready2send = 0;\r\nu32 delayed_ndp_size;\r\nif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)\r\ndelayed_ndp_size = ctx->max_ndp_size;\r\nelse\r\ndelayed_ndp_size = 0;\r\nif (skb != NULL) {\r\nswap(skb, ctx->tx_rem_skb);\r\nswap(sign, ctx->tx_rem_sign);\r\n} else {\r\nready2send = 1;\r\n}\r\nskb_out = ctx->tx_curr_skb;\r\nif (!skb_out) {\r\nskb_out = alloc_skb(ctx->tx_max, GFP_ATOMIC);\r\nif (skb_out == NULL) {\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\ndev->net->stats.tx_dropped++;\r\n}\r\ngoto exit_no_skb;\r\n}\r\nnth16 = (struct usb_cdc_ncm_nth16 *)memset(skb_put(skb_out, sizeof(struct usb_cdc_ncm_nth16)), 0, sizeof(struct usb_cdc_ncm_nth16));\r\nnth16->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\r\nnth16->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\r\nnth16->wSequence = cpu_to_le16(ctx->tx_seq++);\r\nctx->tx_curr_frame_num = 0;\r\nctx->tx_curr_frame_payload = 0;\r\n}\r\nfor (n = ctx->tx_curr_frame_num; n < ctx->tx_max_datagrams; n++) {\r\nif (skb == NULL) {\r\nskb = ctx->tx_rem_skb;\r\nsign = ctx->tx_rem_sign;\r\nctx->tx_rem_skb = NULL;\r\nif (skb == NULL)\r\nbreak;\r\n}\r\nndp16 = cdc_ncm_ndp(ctx, skb_out, sign, skb->len + ctx->tx_modulus + ctx->tx_remainder);\r\ncdc_ncm_align_tail(skb_out, ctx->tx_modulus, ctx->tx_remainder, ctx->tx_max);\r\nif (!ndp16 || skb_out->len + skb->len + delayed_ndp_size > ctx->tx_max) {\r\nif (n == 0) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\ndev->net->stats.tx_dropped++;\r\n} else {\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\ndev->net->stats.tx_dropped++;\r\n}\r\nctx->tx_rem_skb = skb;\r\nctx->tx_rem_sign = sign;\r\nskb = NULL;\r\nready2send = 1;\r\nctx->tx_reason_ntb_full++;\r\n}\r\nbreak;\r\n}\r\nndplen = le16_to_cpu(ndp16->wLength);\r\nindex = (ndplen - sizeof(struct usb_cdc_ncm_ndp16)) / sizeof(struct usb_cdc_ncm_dpe16) - 1;\r\nndp16->dpe16[index].wDatagramLength = cpu_to_le16(skb->len);\r\nndp16->dpe16[index].wDatagramIndex = cpu_to_le16(skb_out->len);\r\nndp16->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe16));\r\nmemcpy(skb_put(skb_out, skb->len), skb->data, skb->len);\r\nctx->tx_curr_frame_payload += skb->len;\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (index >= CDC_NCM_DPT_DATAGRAMS_MAX) {\r\nready2send = 1;\r\nctx->tx_reason_ndp_full++;\r\nbreak;\r\n}\r\n}\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\ndev->net->stats.tx_dropped++;\r\n}\r\nctx->tx_curr_frame_num = n;\r\nif (n == 0) {\r\nctx->tx_curr_skb = skb_out;\r\ngoto exit_no_skb;\r\n} else if ((n < ctx->tx_max_datagrams) && (ready2send == 0) && (ctx->timer_interval > 0)) {\r\nctx->tx_curr_skb = skb_out;\r\nif (n < CDC_NCM_RESTART_TIMER_DATAGRAM_CNT)\r\nctx->tx_timer_pending = CDC_NCM_TIMER_PENDING_CNT;\r\ngoto exit_no_skb;\r\n} else {\r\nif (n == ctx->tx_max_datagrams)\r\nctx->tx_reason_max_datagram++;\r\n}\r\nif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\r\nnth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\r\ncdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_max);\r\nnth16->wNdpIndex = cpu_to_le16(skb_out->len);\r\nmemcpy(skb_put(skb_out, ctx->max_ndp_size), ctx->delayed_ndp16, ctx->max_ndp_size);\r\nndp16 = memset(ctx->delayed_ndp16, 0, ctx->max_ndp_size);\r\n}\r\nif (!(dev->driver_info->flags & FLAG_SEND_ZLP) &&\r\nskb_out->len > ctx->min_tx_pkt)\r\nmemset(skb_put(skb_out, ctx->tx_max - skb_out->len), 0,\r\nctx->tx_max - skb_out->len);\r\nelse if (skb_out->len < ctx->tx_max && (skb_out->len % dev->maxpacket) == 0)\r\n*skb_put(skb_out, 1) = 0;\r\nnth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\r\nnth16->wBlockLength = cpu_to_le16(skb_out->len);\r\nctx->tx_curr_skb = NULL;\r\nctx->tx_overhead += skb_out->len - ctx->tx_curr_frame_payload;\r\nctx->tx_ntbs++;\r\nusbnet_set_skb_tx_stats(skb_out, n,\r\n(long)ctx->tx_curr_frame_payload - skb_out->len);\r\nreturn skb_out;\r\nexit_no_skb:\r\nif (ctx->tx_curr_skb != NULL && n > 0)\r\ncdc_ncm_tx_timeout_start(ctx);\r\nreturn NULL;\r\n}\r\nstatic void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (!(hrtimer_active(&ctx->tx_timer) || atomic_read(&ctx->stop)))\r\nhrtimer_start(&ctx->tx_timer,\r\nktime_set(0, ctx->timer_interval),\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *timer)\r\n{\r\nstruct cdc_ncm_ctx *ctx =\r\ncontainer_of(timer, struct cdc_ncm_ctx, tx_timer);\r\nif (!atomic_read(&ctx->stop))\r\ntasklet_schedule(&ctx->bh);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void cdc_ncm_txpath_bh(unsigned long param)\r\n{\r\nstruct usbnet *dev = (struct usbnet *)param;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nspin_lock_bh(&ctx->mtx);\r\nif (ctx->tx_timer_pending != 0) {\r\nctx->tx_timer_pending--;\r\ncdc_ncm_tx_timeout_start(ctx);\r\nspin_unlock_bh(&ctx->mtx);\r\n} else if (dev->net != NULL) {\r\nctx->tx_reason_timeout++;\r\nspin_unlock_bh(&ctx->mtx);\r\nnetif_tx_lock_bh(dev->net);\r\nusbnet_start_xmit(NULL, dev->net);\r\nnetif_tx_unlock_bh(dev->net);\r\n} else {\r\nspin_unlock_bh(&ctx->mtx);\r\n}\r\n}\r\nstruct sk_buff *\r\ncdc_ncm_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (ctx == NULL)\r\ngoto error;\r\nspin_lock_bh(&ctx->mtx);\r\nskb_out = cdc_ncm_fill_tx_frame(dev, skb, cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN));\r\nspin_unlock_bh(&ctx->mtx);\r\nreturn skb_out;\r\nerror:\r\nif (skb != NULL)\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nint cdc_ncm_rx_verify_nth16(struct cdc_ncm_ctx *ctx, struct sk_buff *skb_in)\r\n{\r\nstruct usbnet *dev = netdev_priv(skb_in->dev);\r\nstruct usb_cdc_ncm_nth16 *nth16;\r\nint len;\r\nint ret = -EINVAL;\r\nif (ctx == NULL)\r\ngoto error;\r\nif (skb_in->len < (sizeof(struct usb_cdc_ncm_nth16) +\r\nsizeof(struct usb_cdc_ncm_ndp16))) {\r\nnetif_dbg(dev, rx_err, dev->net, "frame too short\n");\r\ngoto error;\r\n}\r\nnth16 = (struct usb_cdc_ncm_nth16 *)skb_in->data;\r\nif (nth16->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"invalid NTH16 signature <%#010x>\n",\r\nle32_to_cpu(nth16->dwSignature));\r\ngoto error;\r\n}\r\nlen = le16_to_cpu(nth16->wBlockLength);\r\nif (len > ctx->rx_max) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"unsupported NTB block length %u/%u\n", len,\r\nctx->rx_max);\r\ngoto error;\r\n}\r\nif ((ctx->rx_seq + 1) != le16_to_cpu(nth16->wSequence) &&\r\n(ctx->rx_seq || le16_to_cpu(nth16->wSequence)) &&\r\n!((ctx->rx_seq == 0xffff) && !le16_to_cpu(nth16->wSequence))) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"sequence number glitch prev=%d curr=%d\n",\r\nctx->rx_seq, le16_to_cpu(nth16->wSequence));\r\n}\r\nctx->rx_seq = le16_to_cpu(nth16->wSequence);\r\nret = le16_to_cpu(nth16->wNdpIndex);\r\nerror:\r\nreturn ret;\r\n}\r\nint cdc_ncm_rx_verify_ndp16(struct sk_buff *skb_in, int ndpoffset)\r\n{\r\nstruct usbnet *dev = netdev_priv(skb_in->dev);\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nint ret = -EINVAL;\r\nif ((ndpoffset + sizeof(struct usb_cdc_ncm_ndp16)) > skb_in->len) {\r\nnetif_dbg(dev, rx_err, dev->net, "invalid NDP offset <%u>\n",\r\nndpoffset);\r\ngoto error;\r\n}\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nif (le16_to_cpu(ndp16->wLength) < USB_CDC_NCM_NDP16_LENGTH_MIN) {\r\nnetif_dbg(dev, rx_err, dev->net, "invalid DPT16 length <%u>\n",\r\nle16_to_cpu(ndp16->wLength));\r\ngoto error;\r\n}\r\nret = ((le16_to_cpu(ndp16->wLength) -\r\nsizeof(struct usb_cdc_ncm_ndp16)) /\r\nsizeof(struct usb_cdc_ncm_dpe16));\r\nret--;\r\nif ((sizeof(struct usb_cdc_ncm_ndp16) +\r\nret * (sizeof(struct usb_cdc_ncm_dpe16))) > skb_in->len) {\r\nnetif_dbg(dev, rx_err, dev->net, "Invalid nframes = %d\n", ret);\r\nret = -EINVAL;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nint cdc_ncm_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nint len;\r\nint nframes;\r\nint x;\r\nint offset;\r\nstruct usb_cdc_ncm_ndp16 *ndp16;\r\nstruct usb_cdc_ncm_dpe16 *dpe16;\r\nint ndpoffset;\r\nint loopcount = 50;\r\nu32 payload = 0;\r\nndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\r\nif (ndpoffset < 0)\r\ngoto error;\r\nnext_ndp:\r\nnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\r\nif (nframes < 0)\r\ngoto error;\r\nndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\r\nif (ndp16->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"invalid DPT16 signature <%#010x>\n",\r\nle32_to_cpu(ndp16->dwSignature));\r\ngoto err_ndp;\r\n}\r\ndpe16 = ndp16->dpe16;\r\nfor (x = 0; x < nframes; x++, dpe16++) {\r\noffset = le16_to_cpu(dpe16->wDatagramIndex);\r\nlen = le16_to_cpu(dpe16->wDatagramLength);\r\nif ((offset == 0) || (len == 0)) {\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n}\r\nif (((offset + len) > skb_in->len) ||\r\n(len > ctx->rx_max) || (len < ETH_HLEN)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\n",\r\nx, offset, len, skb_in);\r\nif (!x)\r\ngoto err_ndp;\r\nbreak;\r\n} else {\r\nskb = netdev_alloc_skb_ip_align(dev->net, len);\r\nif (!skb)\r\ngoto error;\r\nmemcpy(skb_put(skb, len), skb_in->data + offset, len);\r\nusbnet_skb_return(dev, skb);\r\npayload += len;\r\n}\r\n}\r\nerr_ndp:\r\nndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\r\nif (ndpoffset && loopcount--)\r\ngoto next_ndp;\r\nctx->rx_overhead += skb_in->len - payload;\r\nctx->rx_ntbs++;\r\nreturn 1;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_speed_change(struct usbnet *dev,\r\nstruct usb_cdc_speed_change *data)\r\n{\r\nuint32_t rx_speed = le32_to_cpu(data->DLBitRRate);\r\nuint32_t tx_speed = le32_to_cpu(data->ULBitRate);\r\nif ((tx_speed > 1000000) && (rx_speed > 1000000)) {\r\nnetif_info(dev, link, dev->net,\r\n"%u mbit/s downlink %u mbit/s uplink\n",\r\n(unsigned int)(rx_speed / 1000000U),\r\n(unsigned int)(tx_speed / 1000000U));\r\n} else {\r\nnetif_info(dev, link, dev->net,\r\n"%u kbit/s downlink %u kbit/s uplink\n",\r\n(unsigned int)(rx_speed / 1000U),\r\n(unsigned int)(tx_speed / 1000U));\r\n}\r\n}\r\nstatic void cdc_ncm_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_cdc_notification *event;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (urb->actual_length < sizeof(*event))\r\nreturn;\r\nif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\r\ncdc_ncm_speed_change(dev,\r\n(struct usb_cdc_speed_change *)urb->transfer_buffer);\r\nreturn;\r\n}\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\nnetif_info(dev, link, dev->net,\r\n"network connection: %sconnected\n",\r\n!!event->wValue ? "" : "dis");\r\nusbnet_link_change(dev, !!event->wValue, 0);\r\nbreak;\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nif (urb->actual_length < (sizeof(*event) +\r\nsizeof(struct usb_cdc_speed_change)))\r\nset_bit(EVENT_STS_SPLIT, &dev->flags);\r\nelse\r\ncdc_ncm_speed_change(dev,\r\n(struct usb_cdc_speed_change *)&event[1]);\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->udev->dev,\r\n"NCM: unexpected notification 0x%02x!\n",\r\nevent->bNotificationType);\r\nbreak;\r\n}\r\n}
