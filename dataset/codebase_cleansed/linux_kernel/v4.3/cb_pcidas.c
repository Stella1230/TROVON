static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)\r\n{\r\nreturn (range & 0x3) << (8 + 2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_RANGE_MASK(unsigned int channel)\r\n{\r\nreturn 0x3 << (8 + 2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_CHAN_EN(unsigned int channel)\r\n{\r\nreturn 1 << (5 + (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_DATA_REG(unsigned int channel)\r\n{\r\nreturn 2 * (channel & 0x1);\r\n}\r\nstatic inline unsigned int cal_enable_bits(struct comedi_device *dev)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nreturn CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);\r\n}\r\nstatic int cb_pcidas_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int status;\r\nstatus = inw(devpriv->control_status + ADCMUX_CONT);\r\nif (status & EOC)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int cb_pcidas_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned int bits;\r\nint ret;\r\nint n;\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\noutw(cal_enable_bits(dev),\r\ndevpriv->control_status + CALIBRATION_REG);\r\nchan = 0;\r\n} else {\r\noutw(0, devpriv->control_status + CALIBRATION_REG);\r\n}\r\nbits = BEGIN_SCAN(chan) | END_SCAN(chan) | GAIN_BITS(range);\r\nif (range & IS_UNIPOLAR)\r\nbits |= UNIP;\r\nif (aref != AREF_DIFF)\r\nbits |= SE;\r\noutw(bits, devpriv->control_status + ADCMUX_CONT);\r\noutw(0, devpriv->adc_fifo + ADCFIFOCLR);\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(0, devpriv->adc_fifo + ADCDATA);\r\nret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[n] = inw(devpriv->adc_fifo + ADCDATA);\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nint id = data[0];\r\nunsigned int source = data[1];\r\nswitch (id) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nif (source >= 8) {\r\ndev_err(dev->class_dev,\r\n"invalid calibration source: %i\n",\r\nsource);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->calibration_source = source;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_control_bits &= (~DAC_MODE_UPDATE_BOTH &\r\n~DAC_RANGE_MASK(chan));\r\ndevpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range));\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ns->readback[chan] = data[0];\r\noutw(data[0], devpriv->ao_registers + DAC_DATA_REG(chan));\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned long flags;\r\noutw(0, devpriv->ao_registers + DACFIFOCLR);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_control_bits &= (~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) &\r\n~DAC_RANGE_MASK(chan) & ~DAC_PACER_MASK);\r\ndevpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range) |\r\nDAC_CHAN_EN(chan) | DAC_START);\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ns->readback[chan] = data[0];\r\noutw(data[0], devpriv->ao_registers + DACDATA);\r\nreturn insn->n;\r\n}\r\nstatic int wait_for_nvram_ready(unsigned long s5933_base_addr)\r\n{\r\nstatic const int timeout = 1000;\r\nunsigned int i;\r\nfor (i = 0; i < timeout; i++) {\r\nif ((inb(s5933_base_addr +\r\nAMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)\r\n== 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int nvram_read(struct comedi_device *dev, unsigned int address,\r\nuint8_t *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned long iobase = devpriv->s5933_config;\r\nif (wait_for_nvram_ready(iobase) < 0)\r\nreturn -ETIMEDOUT;\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,\r\niobase + AMCC_OP_REG_MCSR_NVCMD);\r\noutb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,\r\niobase + AMCC_OP_REG_MCSR_NVCMD);\r\noutb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);\r\nif (wait_for_nvram_ready(iobase) < 0)\r\nreturn -ETIMEDOUT;\r\n*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);\r\nreturn 0;\r\n}\r\nstatic int eeprom_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nuint8_t nvram_data;\r\nint retval;\r\nretval = nvram_read(dev, CR_CHAN(insn->chanspec), &nvram_data);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[0] = nvram_data;\r\nreturn 1;\r\n}\r\nstatic void write_calibration_bitstream(struct comedi_device *dev,\r\nunsigned int register_bits,\r\nunsigned int bitstream,\r\nunsigned int bitstream_length)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstatic const int write_delay = 1;\r\nunsigned int bit;\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nelse\r\nregister_bits &= ~SERIAL_DATA_IN_BIT;\r\nudelay(write_delay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\n}\r\n}\r\nstatic void caldac_8800_write(struct comedi_device *dev,\r\nunsigned int chan, uint8_t val)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstatic const int bitstream_length = 11;\r\nunsigned int bitstream = ((chan & 0x7) << 8) | val;\r\nstatic const int caldac_8800_udelay = 1;\r\nwrite_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,\r\nbitstream_length);\r\nudelay(caldac_8800_udelay);\r\noutw(cal_enable_bits(dev) | SELECT_8800_BIT,\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\n}\r\nstatic int cb_pcidas_caldac_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncaldac_8800_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void dac08_write(struct comedi_device *dev, unsigned int value)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nvalue &= 0xff;\r\nvalue |= cal_enable_bits(dev);\r\noutw(value, devpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\noutw(value | SELECT_DAC08_BIT,\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\noutw(value, devpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\n}\r\nstatic int cb_pcidas_dac08_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ndac08_write(dev, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int trimpot_7376_write(struct comedi_device *dev, uint8_t value)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstatic const int bitstream_length = 7;\r\nunsigned int bitstream = value & 0x7f;\r\nunsigned int register_bits;\r\nstatic const int ad7376_udelay = 1;\r\nregister_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;\r\nudelay(ad7376_udelay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\nwrite_calibration_bitstream(dev, register_bits, bitstream,\r\nbitstream_length);\r\nudelay(ad7376_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\nreturn 0;\r\n}\r\nstatic int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,\r\nuint8_t value)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstatic const int bitstream_length = 10;\r\nunsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);\r\nunsigned int register_bits;\r\nstatic const int ad8402_udelay = 1;\r\nregister_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;\r\nudelay(ad8402_udelay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\nwrite_calibration_bitstream(dev, register_bits, bitstream,\r\nbitstream_length);\r\nudelay(ad8402_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_trimpot_write(struct comedi_device *dev,\r\nunsigned int chan, unsigned int val)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nswitch (board->trimpot) {\r\ncase AD7376:\r\ntrimpot_7376_write(dev, val);\r\nbreak;\r\ncase AD8402:\r\ntrimpot_8402_write(dev, chan, val);\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "driver bug?\n");\r\nbreak;\r\n}\r\n}\r\nstatic int cb_pcidas_trimpot_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncb_pcidas_trimpot_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (chan != (chan0 + i) % s->n_chan) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nreturn -EINVAL;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must all have the same gain\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (cmd->start_src == TRIG_EXT &&\r\n(cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->start_arg\r\n& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {\r\ncmd->start_arg &= ~(CR_FLAGS_MASK &\r\n~(CR_EDGE | CR_INVERT));\r\nerr |= -EINVAL;\r\n}\r\nif (!board->is_1602 && (cmd->start_arg & CR_INVERT)) {\r\ncmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);\r\nerr |= -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed *\r\ncmd->chanlist_len);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\narg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int bits;\r\nunsigned long flags;\r\noutw(0, devpriv->control_status + CALIBRATION_REG);\r\noutw(0, devpriv->control_status + TRIG_CONTSTAT);\r\noutw(0, devpriv->adc_fifo + ADCFIFOCLR);\r\nbits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |\r\nEND_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |\r\nGAIN_BITS(CR_RANGE(cmd->chanlist[0]));\r\nif (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)\r\nbits |= UNIP;\r\nif (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)\r\nbits |= SE;\r\nif (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)\r\nbits |= PACER_EXT_RISE;\r\nelse\r\nbits |= PACER_INT;\r\noutw(bits, devpriv->control_status + ADCMUX_CONT);\r\nif (cmd->scan_begin_src == TRIG_TIMER ||\r\ncmd->convert_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits |= INTE;\r\ndevpriv->adc_fifo_bits &= ~INT_MASK;\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {\r\ndevpriv->adc_fifo_bits |= INT_EOS;\r\n} else {\r\ndevpriv->adc_fifo_bits |= INT_FNE;\r\n}\r\n} else {\r\ndevpriv->adc_fifo_bits |= INT_FHF;\r\n}\r\noutw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nbits = 0;\r\nif (cmd->start_src == TRIG_NOW) {\r\nbits |= SW_TRIGGER;\r\n} else {\r\nbits |= EXT_TRIGGER | TGEN | XTRCL;\r\nif (board->is_1602) {\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= TGPOL;\r\nif (cmd->start_arg & CR_EDGE)\r\nbits |= TGSEL;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)\r\nbits |= BURSTE;\r\noutw(bits, devpriv->control_status + TRIG_CONTSTAT);\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nif (cmd->chanlist_len > 1) {\r\nunsigned int chan1 = CR_CHAN(cmd->chanlist[1]);\r\nif (chan0 != 0 || chan1 != 1) {\r\ndev_dbg(dev->class_dev,\r\n"channels must be ordered channel 0, channel 1 in chanlist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ao_scan_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int arg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(devpriv->ao_pacer,\r\n&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas_ao_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits &= ~INTE & ~EOAIE;\r\noutw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(0, devpriv->control_status + TRIG_CONTSTAT);\r\noutw(0, devpriv->control_status + ADCMUX_CONT);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_ao_load_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int nsamples)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int nbytes;\r\nnsamples = comedi_nsamples_left(s, nsamples);\r\nnbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\noutsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, nsamples);\r\n}\r\nstatic int cb_pcidas_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long flags;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ncb_pcidas_ao_load_fifo(dev, s, board->fifo_size);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits |= DAEMIE | DAHFIE;\r\noutw(devpriv->adc_fifo_bits | DAEMI | DAHFI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\ndevpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = NULL;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\ndevpriv->ao_control_bits |=\r\nDAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));\r\ndevpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),\r\nCR_RANGE(cmd->\r\nchanlist[i]));\r\n}\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(0, devpriv->ao_registers + DACFIFOCLR);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(devpriv->ao_pacer);\r\ncomedi_8254_pacer_enable(devpriv->ao_pacer, 1, 2, true);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->ao_control_bits |= DAC_PACER_INT;\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->ao_control_bits |= DAC_PACER_EXT_RISE;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndev_err(dev->class_dev, "error setting dac pacer source\n");\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = cb_pcidas_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;\r\noutw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);\r\ndevpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long flags;\r\nif (status & DAEMI) {\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | DAEMI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\n} else {\r\ndev_err(dev->class_dev, "dac fifo underflow\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n} else if (status & DAHFI) {\r\ncb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | DAHFI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic irqreturn_t cb_pcidas_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)d;\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nint status, s5933_status;\r\nint half_fifo = board->fifo_size / 2;\r\nunsigned int num_samples, i;\r\nstatic const int timeout = 10000;\r\nunsigned long flags;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nasync = s->async;\r\ncmd = &async->cmd;\r\ns5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nif ((INTCSR_INTR_ASSERTED & s5933_status) == 0)\r\nreturn IRQ_NONE;\r\ninl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);\r\noutl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nstatus = inw(devpriv->control_status + INT_ADCFIFO);\r\nif (status & (DAHFI | DAEMI))\r\nhandle_ao_interrupt(dev, status);\r\nif (status & ADHFI) {\r\nnum_samples = comedi_nsamples_left(s, half_fifo);\r\ninsw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,\r\nnum_samples);\r\ncomedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | INT,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n} else if (status & (ADNEI | EOBI)) {\r\nfor (i = 0; i < timeout; i++) {\r\nunsigned short val;\r\nif ((ADNE & inw(devpriv->control_status +\r\nINT_ADCFIFO)) == 0)\r\nbreak;\r\nval = inw(devpriv->adc_fifo);\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | INT,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n} else if (status & EOAI) {\r\ndev_err(dev->class_dev,\r\n"bug! encountered end of acquisition interrupt?\n");\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | EOAI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nif (status & LADFUL) {\r\ndev_err(dev->class_dev, "fifo overflow\n");\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | LADFUL,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cb_pcidas_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct cb_pcidas_board *board = NULL;\r\nstruct cb_pcidas_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint i;\r\nint ret;\r\nif (context < ARRAY_SIZE(cb_pcidas_boards))\r\nboard = &cb_pcidas_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->s5933_config = pci_resource_start(pcidev, 0);\r\ndevpriv->control_status = pci_resource_start(pcidev, 1);\r\ndevpriv->adc_fifo = pci_resource_start(pcidev, 2);\r\ndev->iobase = pci_resource_start(pcidev, 3);\r\nif (board->ao_nchan)\r\ndevpriv->ao_registers = pci_resource_start(pcidev, 4);\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nret = request_irq(pcidev->irq, cb_pcidas_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret) {\r\ndev_dbg(dev->class_dev, "unable to allocate irq %d\n",\r\npcidev->irq);\r\nreturn ret;\r\n}\r\ndev->irq = pcidev->irq;\r\ndev->pacer = comedi_8254_init(dev->iobase + ADC8254,\r\nI8254_OSC_BASE_10MHZ, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ndevpriv->ao_pacer = comedi_8254_init(dev->iobase + DAC8254,\r\nI8254_OSC_BASE_10MHZ,\r\nI8254_IO8, 0);\r\nif (!devpriv->ao_pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 7);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = board->ai_nchan;\r\ns->len_chanlist = board->ai_nchan;\r\ns->maxdata = (1 << board->ai_bits) - 1;\r\ns->range_table = board->ranges;\r\ns->insn_read = cb_pcidas_ai_rinsn;\r\ns->insn_config = ai_config_insn;\r\ns->do_cmd = cb_pcidas_ai_cmd;\r\ns->do_cmdtest = cb_pcidas_ai_cmdtest;\r\ns->cancel = cb_pcidas_cancel;\r\ns = &dev->subdevices[1];\r\nif (board->ao_nchan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = board->ao_nchan;\r\ns->maxdata = (1 << board->ai_bits) - 1;\r\ns->range_table = &cb_pcidas_ao_ranges;\r\ns->insn_write = cb_pcidas_ao_nofifo_winsn;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nif (board->has_ao_fifo) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->insn_write = cb_pcidas_ao_fifo_winsn;\r\ns->do_cmdtest = cb_pcidas_ao_cmdtest;\r\ns->do_cmd = cb_pcidas_ao_cmd;\r\ns->cancel = cb_pcidas_ao_cancel;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nret = subdev_8255_init(dev, s, NULL, DIO_8255);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 256;\r\ns->maxdata = 0xff;\r\ns->insn_read = eeprom_read_insn;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = NUM_CHANNELS_8800;\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas_caldac_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ncaldac_8800_write(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\ns = &dev->subdevices[5];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\nif (board->trimpot == AD7376) {\r\ns->n_chan = NUM_CHANNELS_7376;\r\ns->maxdata = 0x7f;\r\n} else {\r\ns->n_chan = NUM_CHANNELS_8402;\r\ns->maxdata = 0xff;\r\n}\r\ns->insn_write = cb_pcidas_trimpot_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ncb_pcidas_trimpot_write(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\ns = &dev->subdevices[6];\r\nif (board->has_dac08) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = NUM_CHANNELS_DAC08;\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas_dac08_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ndac08_write(dev, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ninl(devpriv->s5933_config + AMCC_OP_REG_IMB4);\r\ndevpriv->s5933_intcsr_bits =\r\nINTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |\r\nINTCSR_INBOX_FULL_INT;\r\noutl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_detach(struct comedi_device *dev)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nif (devpriv) {\r\nif (devpriv->s5933_config)\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nkfree(devpriv->ao_pacer);\r\n}\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int cb_pcidas_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &cb_pcidas_driver,\r\nid->driver_data);\r\n}
