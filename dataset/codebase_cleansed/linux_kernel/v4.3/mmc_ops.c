static inline int __mmc_send_status(struct mmc_card *card, u32 *status,\r\nbool ignore_crc)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = MMC_SEND_STATUS;\r\nif (!mmc_host_is_spi(card->host))\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;\r\nif (ignore_crc)\r\ncmd.flags &= ~MMC_RSP_CRC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nif (status)\r\n*status = cmd.resp[0];\r\nreturn 0;\r\n}\r\nint mmc_send_status(struct mmc_card *card, u32 *status)\r\n{\r\nreturn __mmc_send_status(card, status, false);\r\n}\r\nstatic int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\ncmd.opcode = MMC_SELECT_CARD;\r\nif (card) {\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\n} else {\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_NONE | MMC_CMD_AC;\r\n}\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mmc_select_card(struct mmc_card *card)\r\n{\r\nBUG_ON(!card);\r\nreturn _mmc_select_card(card->host, card);\r\n}\r\nint mmc_deselect_cards(struct mmc_host *host)\r\n{\r\nreturn _mmc_select_card(host, NULL);\r\n}\r\nint mmc_set_dsr(struct mmc_host *host)\r\n{\r\nstruct mmc_command cmd = {0};\r\ncmd.opcode = MMC_SET_DSR;\r\ncmd.arg = (host->dsr << 16) | 0xffff;\r\ncmd.flags = MMC_RSP_NONE | MMC_CMD_AC;\r\nreturn mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\n}\r\nint mmc_go_idle(struct mmc_host *host)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nif (!mmc_host_is_spi(host)) {\r\nmmc_set_chip_select(host, MMC_CS_HIGH);\r\nmmc_delay(1);\r\n}\r\ncmd.opcode = MMC_GO_IDLE_STATE;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nmmc_delay(1);\r\nif (!mmc_host_is_spi(host)) {\r\nmmc_set_chip_select(host, MMC_CS_DONTCARE);\r\nmmc_delay(1);\r\n}\r\nhost->use_spi_crc = 0;\r\nreturn err;\r\n}\r\nint mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint i, err = 0;\r\nBUG_ON(!host);\r\ncmd.opcode = MMC_SEND_OP_COND;\r\ncmd.arg = mmc_host_is_spi(host) ? 0 : ocr;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;\r\nfor (i = 100; i; i--) {\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nbreak;\r\nif (ocr == 0)\r\nbreak;\r\nif (mmc_host_is_spi(host)) {\r\nif (!(cmd.resp[0] & R1_SPI_IDLE))\r\nbreak;\r\n} else {\r\nif (cmd.resp[0] & MMC_CARD_BUSY)\r\nbreak;\r\n}\r\nerr = -ETIMEDOUT;\r\nmmc_delay(10);\r\n}\r\nif (rocr && !mmc_host_is_spi(host))\r\n*rocr = cmd.resp[0];\r\nreturn err;\r\n}\r\nint mmc_all_send_cid(struct mmc_host *host, u32 *cid)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(!cid);\r\ncmd.opcode = MMC_ALL_SEND_CID;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nmemcpy(cid, cmd.resp, sizeof(u32) * 4);\r\nreturn 0;\r\n}\r\nint mmc_set_relative_addr(struct mmc_card *card)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = MMC_SET_RELATIVE_ADDR;\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_send_cxd_native(struct mmc_host *host, u32 arg, u32 *cxd, int opcode)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(!cxd);\r\ncmd.opcode = opcode;\r\ncmd.arg = arg;\r\ncmd.flags = MMC_RSP_R2 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nmemcpy(cxd, cmd.resp, sizeof(u32) * 4);\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,\r\nu32 opcode, void *buf, unsigned len)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = len;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, buf, len);\r\nif (opcode == MMC_SEND_CSD || opcode == MMC_SEND_CID) {\r\ndata.timeout_ns = 0;\r\ndata.timeout_clks = 64;\r\n} else\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(host, &mrq);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn 0;\r\n}\r\nint mmc_send_csd(struct mmc_card *card, u32 *csd)\r\n{\r\nint ret, i;\r\nu32 *csd_tmp;\r\nif (!mmc_host_is_spi(card->host))\r\nreturn mmc_send_cxd_native(card->host, card->rca << 16,\r\ncsd, MMC_SEND_CSD);\r\ncsd_tmp = kzalloc(16, GFP_KERNEL);\r\nif (!csd_tmp)\r\nreturn -ENOMEM;\r\nret = mmc_send_cxd_data(card, card->host, MMC_SEND_CSD, csd_tmp, 16);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0;i < 4;i++)\r\ncsd[i] = be32_to_cpu(csd_tmp[i]);\r\nerr:\r\nkfree(csd_tmp);\r\nreturn ret;\r\n}\r\nint mmc_send_cid(struct mmc_host *host, u32 *cid)\r\n{\r\nint ret, i;\r\nu32 *cid_tmp;\r\nif (!mmc_host_is_spi(host)) {\r\nif (!host->card)\r\nreturn -EINVAL;\r\nreturn mmc_send_cxd_native(host, host->card->rca << 16,\r\ncid, MMC_SEND_CID);\r\n}\r\ncid_tmp = kzalloc(16, GFP_KERNEL);\r\nif (!cid_tmp)\r\nreturn -ENOMEM;\r\nret = mmc_send_cxd_data(NULL, host, MMC_SEND_CID, cid_tmp, 16);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0;i < 4;i++)\r\ncid[i] = be32_to_cpu(cid_tmp[i]);\r\nerr:\r\nkfree(cid_tmp);\r\nreturn ret;\r\n}\r\nint mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)\r\n{\r\nint err;\r\nu8 *ext_csd;\r\nif (!card || !new_ext_csd)\r\nreturn -EINVAL;\r\nif (!mmc_can_ext_csd(card))\r\nreturn -EOPNOTSUPP;\r\next_csd = kzalloc(512, GFP_KERNEL);\r\nif (!ext_csd)\r\nreturn -ENOMEM;\r\nerr = mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD, ext_csd,\r\n512);\r\nif (err)\r\nkfree(ext_csd);\r\nelse\r\n*new_ext_csd = ext_csd;\r\nreturn err;\r\n}\r\nint mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_SPI_READ_OCR;\r\ncmd.arg = highcap ? (1 << 30) : 0;\r\ncmd.flags = MMC_RSP_SPI_R3;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\n*ocrp = cmd.resp[1];\r\nreturn err;\r\n}\r\nint mmc_spi_set_crc(struct mmc_host *host, int use_crc)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_SPI_CRC_ON_OFF;\r\ncmd.flags = MMC_RSP_SPI_R1;\r\ncmd.arg = use_crc;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (!err)\r\nhost->use_spi_crc = use_crc;\r\nreturn err;\r\n}\r\nint mmc_switch_status_error(struct mmc_host *host, u32 status)\r\n{\r\nif (mmc_host_is_spi(host)) {\r\nif (status & R1_SPI_ILLEGAL_COMMAND)\r\nreturn -EBADMSG;\r\n} else {\r\nif (status & 0xFDFFA000)\r\npr_warn("%s: unexpected status %#x after switch\n",\r\nmmc_hostname(host), status);\r\nif (status & R1_SWITCH_ERROR)\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\nint __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,\r\nunsigned int timeout_ms, bool use_busy_signal, bool send_status,\r\nbool ignore_crc)\r\n{\r\nstruct mmc_host *host = card->host;\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nunsigned long timeout;\r\nu32 status = 0;\r\nbool use_r1b_resp = use_busy_signal;\r\nmmc_retune_hold(host);\r\nif (timeout_ms && host->max_busy_timeout &&\r\n(timeout_ms > host->max_busy_timeout))\r\nuse_r1b_resp = false;\r\ncmd.opcode = MMC_SWITCH;\r\ncmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |\r\n(index << 16) |\r\n(value << 8) |\r\nset;\r\ncmd.flags = MMC_CMD_AC;\r\nif (use_r1b_resp) {\r\ncmd.flags |= MMC_RSP_SPI_R1B | MMC_RSP_R1B;\r\ncmd.busy_timeout = timeout_ms;\r\n} else {\r\ncmd.flags |= MMC_RSP_SPI_R1 | MMC_RSP_R1;\r\n}\r\nif (index == EXT_CSD_SANITIZE_START)\r\ncmd.sanitize_busy = true;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\ngoto out;\r\nif (!use_busy_signal)\r\ngoto out;\r\nif ((host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)\r\nignore_crc = false;\r\nif (!timeout_ms)\r\ntimeout_ms = MMC_OPS_TIMEOUT_MS;\r\ntimeout = jiffies + msecs_to_jiffies(timeout_ms);\r\ndo {\r\nif (send_status) {\r\nerr = __mmc_send_status(card, &status, ignore_crc);\r\nif (err)\r\ngoto out;\r\n}\r\nif ((host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)\r\nbreak;\r\nif (mmc_host_is_spi(host))\r\nbreak;\r\nif (!send_status) {\r\nmmc_delay(timeout_ms);\r\ngoto out;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\npr_err("%s: Card stuck in programming state! %s\n",\r\nmmc_hostname(host), __func__);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n} while (R1_CURRENT_STATE(status) == R1_STATE_PRG);\r\nerr = mmc_switch_status_error(host, status);\r\nout:\r\nmmc_retune_release(host);\r\nreturn err;\r\n}\r\nint mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,\r\nunsigned int timeout_ms)\r\n{\r\nreturn __mmc_switch(card, set, index, value, timeout_ms, true, true,\r\nfalse);\r\n}\r\nint mmc_send_tuning(struct mmc_host *host)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nstruct mmc_ios *ios = &host->ios;\r\nconst u8 *tuning_block_pattern;\r\nint size, err = 0;\r\nu8 *data_buf;\r\nu32 opcode;\r\nif (ios->bus_width == MMC_BUS_WIDTH_8) {\r\ntuning_block_pattern = tuning_blk_pattern_8bit;\r\nsize = sizeof(tuning_blk_pattern_8bit);\r\nopcode = MMC_SEND_TUNING_BLOCK_HS200;\r\n} else if (ios->bus_width == MMC_BUS_WIDTH_4) {\r\ntuning_block_pattern = tuning_blk_pattern_4bit;\r\nsize = sizeof(tuning_blk_pattern_4bit);\r\nopcode = MMC_SEND_TUNING_BLOCK;\r\n} else\r\nreturn -EINVAL;\r\ndata_buf = kzalloc(size, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn -ENOMEM;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = opcode;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = size;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.timeout_ns = 150 * NSEC_PER_MSEC;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, data_buf, size);\r\nmmc_wait_for_req(host, &mrq);\r\nif (cmd.error) {\r\nerr = cmd.error;\r\ngoto out;\r\n}\r\nif (data.error) {\r\nerr = data.error;\r\ngoto out;\r\n}\r\nif (memcmp(data_buf, tuning_block_pattern, size))\r\nerr = -EIO;\r\nout:\r\nkfree(data_buf);\r\nreturn err;\r\n}\r\nstatic int\r\nmmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,\r\nu8 len)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nu8 *data_buf;\r\nu8 *test_buf;\r\nint i, err;\r\nstatic u8 testdata_8bit[8] = { 0x55, 0xaa, 0, 0, 0, 0, 0, 0 };\r\nstatic u8 testdata_4bit[4] = { 0x5a, 0, 0, 0 };\r\ndata_buf = kmalloc(len, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn -ENOMEM;\r\nif (len == 8)\r\ntest_buf = testdata_8bit;\r\nelse if (len == 4)\r\ntest_buf = testdata_4bit;\r\nelse {\r\npr_err("%s: Invalid bus_width %d\n",\r\nmmc_hostname(host), len);\r\nkfree(data_buf);\r\nreturn -EINVAL;\r\n}\r\nif (opcode == MMC_BUS_TEST_W)\r\nmemcpy(data_buf, test_buf, len);\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = len;\r\ndata.blocks = 1;\r\nif (opcode == MMC_BUS_TEST_R)\r\ndata.flags = MMC_DATA_READ;\r\nelse\r\ndata.flags = MMC_DATA_WRITE;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nmmc_set_data_timeout(&data, card);\r\nsg_init_one(&sg, data_buf, len);\r\nmmc_wait_for_req(host, &mrq);\r\nerr = 0;\r\nif (opcode == MMC_BUS_TEST_R) {\r\nfor (i = 0; i < len / 4; i++)\r\nif ((test_buf[i] ^ data_buf[i]) != 0xff) {\r\nerr = -EIO;\r\nbreak;\r\n}\r\n}\r\nkfree(data_buf);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn err;\r\n}\r\nint mmc_bus_test(struct mmc_card *card, u8 bus_width)\r\n{\r\nint err, width;\r\nif (bus_width == MMC_BUS_WIDTH_8)\r\nwidth = 8;\r\nelse if (bus_width == MMC_BUS_WIDTH_4)\r\nwidth = 4;\r\nelse if (bus_width == MMC_BUS_WIDTH_1)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nmmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);\r\nerr = mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);\r\nreturn err;\r\n}\r\nint mmc_send_hpi_cmd(struct mmc_card *card, u32 *status)\r\n{\r\nstruct mmc_command cmd = {0};\r\nunsigned int opcode;\r\nint err;\r\nif (!card->ext_csd.hpi) {\r\npr_warn("%s: Card didn't support HPI command\n",\r\nmmc_hostname(card->host));\r\nreturn -EINVAL;\r\n}\r\nopcode = card->ext_csd.hpi_cmd;\r\nif (opcode == MMC_STOP_TRANSMISSION)\r\ncmd.flags = MMC_RSP_R1B | MMC_CMD_AC;\r\nelse if (opcode == MMC_SEND_STATUS)\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\ncmd.opcode = opcode;\r\ncmd.arg = card->rca << 16 | 1;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, 0);\r\nif (err) {\r\npr_warn("%s: error %d interrupting operation. "\r\n"HPI command response %#x\n", mmc_hostname(card->host),\r\nerr, cmd.resp[0]);\r\nreturn err;\r\n}\r\nif (status)\r\n*status = cmd.resp[0];\r\nreturn 0;\r\n}\r\nint mmc_can_ext_csd(struct mmc_card *card)\r\n{\r\nreturn (card && card->csd.mmca_vsn > CSD_SPEC_VER_3);\r\n}
