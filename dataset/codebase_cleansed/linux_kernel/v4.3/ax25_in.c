static int ax25_rx_fragment(ax25_cb *ax25, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbn, *skbo;\r\nif (ax25->fragno != 0) {\r\nif (!(*skb->data & AX25_SEG_FIRST)) {\r\nif ((ax25->fragno - 1) == (*skb->data & AX25_SEG_REM)) {\r\nax25->fragno = *skb->data & AX25_SEG_REM;\r\nskb_pull(skb, 1);\r\nax25->fraglen += skb->len;\r\nskb_queue_tail(&ax25->frag_queue, skb);\r\nif (ax25->fragno == 0) {\r\nskbn = alloc_skb(AX25_MAX_HEADER_LEN +\r\nax25->fraglen,\r\nGFP_ATOMIC);\r\nif (!skbn) {\r\nskb_queue_purge(&ax25->frag_queue);\r\nreturn 1;\r\n}\r\nskb_reserve(skbn, AX25_MAX_HEADER_LEN);\r\nskbn->dev = ax25->ax25_dev->dev;\r\nskb_reset_network_header(skbn);\r\nskb_reset_transport_header(skbn);\r\nwhile ((skbo = skb_dequeue(&ax25->frag_queue)) != NULL) {\r\nskb_copy_from_linear_data(skbo,\r\nskb_put(skbn, skbo->len),\r\nskbo->len);\r\nkfree_skb(skbo);\r\n}\r\nax25->fraglen = 0;\r\nif (ax25_rx_iframe(ax25, skbn) == 0)\r\nkfree_skb(skbn);\r\n}\r\nreturn 1;\r\n}\r\n}\r\n} else {\r\nif (*skb->data & AX25_SEG_FIRST) {\r\nskb_queue_purge(&ax25->frag_queue);\r\nax25->fragno = *skb->data & AX25_SEG_REM;\r\nskb_pull(skb, 1);\r\nax25->fraglen = skb->len;\r\nskb_queue_tail(&ax25->frag_queue, skb);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ax25_rx_iframe(ax25_cb *ax25, struct sk_buff *skb)\r\n{\r\nint (*func)(struct sk_buff *, ax25_cb *);\r\nunsigned char pid;\r\nint queued = 0;\r\nif (skb == NULL) return 0;\r\nax25_start_idletimer(ax25);\r\npid = *skb->data;\r\nif (pid == AX25_P_IP) {\r\nstruct sk_buff *skbn = skb_copy(skb, GFP_ATOMIC);\r\nif (skbn != NULL) {\r\nkfree_skb(skb);\r\nskb = skbn;\r\n}\r\nskb_pull(skb, 1);\r\nskb->mac_header = skb->network_header;\r\nskb_reset_network_header(skb);\r\nskb->dev = ax25->ax25_dev->dev;\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = htons(ETH_P_IP);\r\nnetif_rx(skb);\r\nreturn 1;\r\n}\r\nif (pid == AX25_P_SEGMENT) {\r\nskb_pull(skb, 1);\r\nreturn ax25_rx_fragment(ax25, skb);\r\n}\r\nif ((func = ax25_protocol_function(pid)) != NULL) {\r\nskb_pull(skb, 1);\r\nreturn (*func)(skb, ax25);\r\n}\r\nif (ax25->sk != NULL && ax25->ax25_dev->values[AX25_VALUES_CONMODE] == 2) {\r\nif ((!ax25->pidincl && ax25->sk->sk_protocol == pid) ||\r\nax25->pidincl) {\r\nif (sock_queue_rcv_skb(ax25->sk, skb) == 0)\r\nqueued = 1;\r\nelse\r\nax25->condition |= AX25_COND_OWN_RX_BUSY;\r\n}\r\n}\r\nreturn queued;\r\n}\r\nstatic int ax25_process_rx_frame(ax25_cb *ax25, struct sk_buff *skb, int type, int dama)\r\n{\r\nint queued = 0;\r\nif (ax25->state == AX25_STATE_0)\r\nreturn 0;\r\nswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\r\ncase AX25_PROTO_STD_SIMPLEX:\r\ncase AX25_PROTO_STD_DUPLEX:\r\nqueued = ax25_std_frame_in(ax25, skb, type);\r\nbreak;\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\ncase AX25_PROTO_DAMA_SLAVE:\r\nif (dama || ax25->ax25_dev->dama.slave)\r\nqueued = ax25_ds_frame_in(ax25, skb, type);\r\nelse\r\nqueued = ax25_std_frame_in(ax25, skb, type);\r\nbreak;\r\n#endif\r\n}\r\nreturn queued;\r\n}\r\nstatic int ax25_rcv(struct sk_buff *skb, struct net_device *dev,\r\nax25_address *dev_addr, struct packet_type *ptype)\r\n{\r\nax25_address src, dest, *next_digi = NULL;\r\nint type = 0, mine = 0, dama;\r\nstruct sock *make, *sk;\r\nax25_digi dp, reverse_dp;\r\nax25_cb *ax25;\r\nax25_dev *ax25_dev;\r\nskb_reset_transport_header(skb);\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\ngoto free;\r\nif (ax25_addr_parse(skb->data, skb->len, &src, &dest, &dp, &type, &dama) == NULL)\r\ngoto free;\r\nif (dp.lastrepeat + 1 < dp.ndigi)\r\nnext_digi = &dp.calls[dp.lastrepeat + 1];\r\nskb_pull(skb, ax25_addr_size(&dp));\r\nif (ax25cmp(&dest, dev_addr) == 0 && dp.lastrepeat + 1 == dp.ndigi)\r\nmine = 1;\r\nif (!mine && ax25_listen_mine(&dest, dev) && dp.lastrepeat + 1 == dp.ndigi)\r\nmine = 1;\r\nif ((*skb->data & ~0x10) == AX25_UI && dp.lastrepeat + 1 == dp.ndigi) {\r\nskb_set_transport_header(skb, 2);\r\nax25_send_to_raw(&dest, skb, skb->data[1]);\r\nif (!mine && ax25cmp(&dest, (ax25_address *)dev->broadcast) != 0)\r\ngoto free;\r\nswitch (skb->data[1]) {\r\ncase AX25_P_IP:\r\nskb_pull(skb,2);\r\nskb_reset_transport_header(skb);\r\nskb_reset_network_header(skb);\r\nskb->dev = dev;\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = htons(ETH_P_IP);\r\nnetif_rx(skb);\r\nbreak;\r\ncase AX25_P_ARP:\r\nskb_pull(skb,2);\r\nskb_reset_transport_header(skb);\r\nskb_reset_network_header(skb);\r\nskb->dev = dev;\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = htons(ETH_P_ARP);\r\nnetif_rx(skb);\r\nbreak;\r\ncase AX25_P_TEXT:\r\nsk = ax25_get_socket(&dest, &src, SOCK_DGRAM);\r\nif (sk != NULL) {\r\nbh_lock_sock(sk);\r\nif (atomic_read(&sk->sk_rmem_alloc) >=\r\nsk->sk_rcvbuf) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull(skb, 2);\r\nif (sock_queue_rcv_skb(sk, skb) != 0)\r\nkfree_skb(skb);\r\n}\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nif (ax25_dev->values[AX25_VALUES_CONMODE] == 0)\r\ngoto free;\r\nax25_digi_invert(&dp, &reverse_dp);\r\nif ((ax25 = ax25_find_cb(&dest, &src, &reverse_dp, dev)) != NULL) {\r\nif (ax25_process_rx_frame(ax25, skb, type, dama) == 0)\r\nkfree_skb(skb);\r\nax25_cb_put(ax25);\r\nreturn 0;\r\n}\r\nif ((*skb->data & ~AX25_PF) != AX25_SABM &&\r\n(*skb->data & ~AX25_PF) != AX25_SABME) {\r\nif ((*skb->data & ~AX25_PF) != AX25_DM && mine)\r\nax25_return_dm(dev, &src, &dest, &dp);\r\ngoto free;\r\n}\r\nif (dp.lastrepeat + 1 == dp.ndigi)\r\nsk = ax25_find_listener(&dest, 0, dev, SOCK_SEQPACKET);\r\nelse\r\nsk = ax25_find_listener(next_digi, 1, dev, SOCK_SEQPACKET);\r\nif (sk != NULL) {\r\nbh_lock_sock(sk);\r\nif (sk_acceptq_is_full(sk) ||\r\n(make = ax25_make_new(sk, ax25_dev)) == NULL) {\r\nif (mine)\r\nax25_return_dm(dev, &src, &dest, &dp);\r\nkfree_skb(skb);\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nax25 = sk_to_ax25(make);\r\nskb_set_owner_r(skb, make);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nmake->sk_state = TCP_ESTABLISHED;\r\nsk->sk_ack_backlog++;\r\nbh_unlock_sock(sk);\r\n} else {\r\nif (!mine)\r\ngoto free;\r\nif ((ax25 = ax25_create_cb()) == NULL) {\r\nax25_return_dm(dev, &src, &dest, &dp);\r\ngoto free;\r\n}\r\nax25_fillin_cb(ax25, ax25_dev);\r\n}\r\nax25->source_addr = dest;\r\nax25->dest_addr = src;\r\nif (dp.ndigi && !ax25->digipeat &&\r\n(ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\r\nkfree_skb(skb);\r\nax25_destroy_socket(ax25);\r\nif (sk)\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nif (dp.ndigi == 0) {\r\nkfree(ax25->digipeat);\r\nax25->digipeat = NULL;\r\n} else {\r\nmemcpy(ax25->digipeat, &reverse_dp, sizeof(ax25_digi));\r\n}\r\nif ((*skb->data & ~AX25_PF) == AX25_SABME) {\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = ax25_dev->values[AX25_VALUES_EWINDOW];\r\n} else {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25_dev->values[AX25_VALUES_WINDOW];\r\n}\r\nax25_send_control(ax25, AX25_UA, AX25_POLLON, AX25_RESPONSE);\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\nif (dama && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)\r\nax25_dama_on(ax25);\r\n#endif\r\nax25->state = AX25_STATE_3;\r\nax25_cb_add(ax25);\r\nax25_start_heartbeat(ax25);\r\nax25_start_t3timer(ax25);\r\nax25_start_idletimer(ax25);\r\nif (sk) {\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nsock_put(sk);\r\n} else {\r\nfree:\r\nkfree_skb(skb);\r\n}\r\nreturn 0;\r\n}\r\nint ax25_kiss_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype, struct net_device *orig_dev)\r\n{\r\nskb_orphan(skb);\r\nif (!net_eq(dev_net(dev), &init_net)) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif ((*skb->data & 0x0F) != 0) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_pull(skb, AX25_KISS_HEADER_LEN);\r\nreturn ax25_rcv(skb, dev, (ax25_address *)dev->dev_addr, ptype);\r\n}
