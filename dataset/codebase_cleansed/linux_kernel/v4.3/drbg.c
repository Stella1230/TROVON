static inline unsigned short drbg_sec_strength(drbg_flag_t flags)\r\n{\r\nswitch (flags & DRBG_STRENGTH_MASK) {\r\ncase DRBG_STRENGTH128:\r\nreturn 16;\r\ncase DRBG_STRENGTH192:\r\nreturn 24;\r\ncase DRBG_STRENGTH256:\r\nreturn 32;\r\ndefault:\r\nreturn 32;\r\n}\r\n}\r\nstatic bool drbg_fips_continuous_test(struct drbg_state *drbg,\r\nconst unsigned char *buf)\r\n{\r\n#ifdef CONFIG_CRYPTO_FIPS\r\nint ret = 0;\r\nif (list_empty(&drbg->test_data.list))\r\nreturn true;\r\nif (0 == fips_enabled)\r\nreturn true;\r\nif (!drbg->fips_primed) {\r\nmemcpy(drbg->prev, buf, drbg_blocklen(drbg));\r\ndrbg->fips_primed = true;\r\nreturn false;\r\n}\r\nret = memcmp(drbg->prev, buf, drbg_blocklen(drbg));\r\nif (!ret)\r\npanic("DRBG continuous self test failed\n");\r\nmemcpy(drbg->prev, buf, drbg_blocklen(drbg));\r\nreturn ret != 0;\r\n#else\r\nreturn true;\r\n#endif\r\n}\r\nstatic inline void drbg_cpu_to_be32(__u32 val, unsigned char *buf)\r\n{\r\nstruct s {\r\n__be32 conv;\r\n};\r\nstruct s *conversion = (struct s *) buf;\r\nconversion->conv = cpu_to_be32(val);\r\n}\r\nstatic int drbg_ctr_bcc(struct drbg_state *drbg,\r\nunsigned char *out, const unsigned char *key,\r\nstruct list_head *in)\r\n{\r\nint ret = 0;\r\nstruct drbg_string *curr = NULL;\r\nstruct drbg_string data;\r\nshort cnt = 0;\r\ndrbg_string_fill(&data, out, drbg_blocklen(drbg));\r\nlist_for_each_entry(curr, in, list) {\r\nconst unsigned char *pos = curr->buf;\r\nsize_t len = curr->len;\r\nwhile (len) {\r\nif (drbg_blocklen(drbg) == cnt) {\r\ncnt = 0;\r\nret = drbg_kcapi_sym(drbg, key, out, &data);\r\nif (ret)\r\nreturn ret;\r\n}\r\nout[cnt] ^= *pos;\r\npos++;\r\ncnt++;\r\nlen--;\r\n}\r\n}\r\nif (cnt)\r\nret = drbg_kcapi_sym(drbg, key, out, &data);\r\nreturn ret;\r\n}\r\nstatic int drbg_ctr_df(struct drbg_state *drbg,\r\nunsigned char *df_data, size_t bytes_to_return,\r\nstruct list_head *seedlist)\r\n{\r\nint ret = -EFAULT;\r\nunsigned char L_N[8];\r\nstruct drbg_string S1, S2, S4, cipherin;\r\nLIST_HEAD(bcc_list);\r\nunsigned char *pad = df_data + drbg_statelen(drbg);\r\nunsigned char *iv = pad + drbg_blocklen(drbg);\r\nunsigned char *temp = iv + drbg_blocklen(drbg);\r\nsize_t padlen = 0;\r\nunsigned int templen = 0;\r\nunsigned int i = 0;\r\nconst unsigned char *K = (unsigned char *)\r\n"\x00\x01\x02\x03\x04\x05\x06\x07"\r\n"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"\r\n"\x10\x11\x12\x13\x14\x15\x16\x17"\r\n"\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f";\r\nunsigned char *X;\r\nsize_t generated_len = 0;\r\nsize_t inputlen = 0;\r\nstruct drbg_string *seed = NULL;\r\nmemset(pad, 0, drbg_blocklen(drbg));\r\nmemset(iv, 0, drbg_blocklen(drbg));\r\nif ((512/8) < bytes_to_return)\r\nreturn -EINVAL;\r\nlist_for_each_entry(seed, seedlist, list)\r\ninputlen += seed->len;\r\ndrbg_cpu_to_be32(inputlen, &L_N[0]);\r\ndrbg_cpu_to_be32(bytes_to_return, &L_N[4]);\r\npadlen = (inputlen + sizeof(L_N) + 1) % (drbg_blocklen(drbg));\r\nif (padlen)\r\npadlen = drbg_blocklen(drbg) - padlen;\r\npadlen++;\r\npad[0] = 0x80;\r\ndrbg_string_fill(&S1, iv, drbg_blocklen(drbg));\r\nlist_add_tail(&S1.list, &bcc_list);\r\ndrbg_string_fill(&S2, L_N, sizeof(L_N));\r\nlist_add_tail(&S2.list, &bcc_list);\r\nlist_splice_tail(seedlist, &bcc_list);\r\ndrbg_string_fill(&S4, pad, padlen);\r\nlist_add_tail(&S4.list, &bcc_list);\r\nwhile (templen < (drbg_keylen(drbg) + (drbg_blocklen(drbg)))) {\r\ndrbg_cpu_to_be32(i, iv);\r\nret = drbg_ctr_bcc(drbg, temp + templen, K, &bcc_list);\r\nif (ret)\r\ngoto out;\r\ni++;\r\ntemplen += drbg_blocklen(drbg);\r\n}\r\nX = temp + (drbg_keylen(drbg));\r\ndrbg_string_fill(&cipherin, X, drbg_blocklen(drbg));\r\nwhile (generated_len < bytes_to_return) {\r\nshort blocklen = 0;\r\nret = drbg_kcapi_sym(drbg, temp, X, &cipherin);\r\nif (ret)\r\ngoto out;\r\nblocklen = (drbg_blocklen(drbg) <\r\n(bytes_to_return - generated_len)) ?\r\ndrbg_blocklen(drbg) :\r\n(bytes_to_return - generated_len);\r\nmemcpy(df_data + generated_len, X, blocklen);\r\ngenerated_len += blocklen;\r\n}\r\nret = 0;\r\nout:\r\nmemset(iv, 0, drbg_blocklen(drbg));\r\nmemset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));\r\nmemset(pad, 0, drbg_blocklen(drbg));\r\nreturn ret;\r\n}\r\nstatic int drbg_ctr_update(struct drbg_state *drbg, struct list_head *seed,\r\nint reseed)\r\n{\r\nint ret = -EFAULT;\r\nunsigned char *temp = drbg->scratchpad;\r\nunsigned char *df_data = drbg->scratchpad + drbg_statelen(drbg) +\r\ndrbg_blocklen(drbg);\r\nunsigned char *temp_p, *df_data_p;\r\nunsigned int len = 0;\r\nstruct drbg_string cipherin;\r\nif (3 > reseed)\r\nmemset(df_data, 0, drbg_statelen(drbg));\r\nif (seed) {\r\nret = drbg_ctr_df(drbg, df_data, drbg_statelen(drbg), seed);\r\nif (ret)\r\ngoto out;\r\n}\r\ndrbg_string_fill(&cipherin, drbg->V, drbg_blocklen(drbg));\r\nwhile (len < (drbg_statelen(drbg))) {\r\ncrypto_inc(drbg->V, drbg_blocklen(drbg));\r\nret = drbg_kcapi_sym(drbg, drbg->C, temp + len, &cipherin);\r\nif (ret)\r\ngoto out;\r\nlen += drbg_blocklen(drbg);\r\n}\r\ntemp_p = temp;\r\ndf_data_p = df_data;\r\nfor (len = 0; len < drbg_statelen(drbg); len++) {\r\n*temp_p ^= *df_data_p;\r\ndf_data_p++; temp_p++;\r\n}\r\nmemcpy(drbg->C, temp, drbg_keylen(drbg));\r\nmemcpy(drbg->V, temp + drbg_keylen(drbg), drbg_blocklen(drbg));\r\nret = 0;\r\nout:\r\nmemset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));\r\nif (2 != reseed)\r\nmemset(df_data, 0, drbg_statelen(drbg));\r\nreturn ret;\r\n}\r\nstatic int drbg_ctr_generate(struct drbg_state *drbg,\r\nunsigned char *buf, unsigned int buflen,\r\nstruct list_head *addtl)\r\n{\r\nint len = 0;\r\nint ret = 0;\r\nstruct drbg_string data;\r\nif (addtl && !list_empty(addtl)) {\r\nret = drbg_ctr_update(drbg, addtl, 2);\r\nif (ret)\r\nreturn 0;\r\n}\r\ncrypto_inc(drbg->V, drbg_blocklen(drbg));\r\ndrbg_string_fill(&data, drbg->V, drbg_blocklen(drbg));\r\nwhile (len < buflen) {\r\nint outlen = 0;\r\nret = drbg_kcapi_sym(drbg, drbg->C, drbg->scratchpad, &data);\r\nif (ret) {\r\nlen = ret;\r\ngoto out;\r\n}\r\noutlen = (drbg_blocklen(drbg) < (buflen - len)) ?\r\ndrbg_blocklen(drbg) : (buflen - len);\r\nif (!drbg_fips_continuous_test(drbg, drbg->scratchpad)) {\r\ncrypto_inc(drbg->V, drbg_blocklen(drbg));\r\ncontinue;\r\n}\r\nmemcpy(buf + len, drbg->scratchpad, outlen);\r\nlen += outlen;\r\nif (len < buflen)\r\ncrypto_inc(drbg->V, drbg_blocklen(drbg));\r\n}\r\nret = drbg_ctr_update(drbg, NULL, 3);\r\nif (ret)\r\nlen = ret;\r\nout:\r\nmemset(drbg->scratchpad, 0, drbg_blocklen(drbg));\r\nreturn len;\r\n}\r\nstatic int drbg_hmac_update(struct drbg_state *drbg, struct list_head *seed,\r\nint reseed)\r\n{\r\nint ret = -EFAULT;\r\nint i = 0;\r\nstruct drbg_string seed1, seed2, vdata;\r\nLIST_HEAD(seedlist);\r\nLIST_HEAD(vdatalist);\r\nif (!reseed)\r\nmemset(drbg->V, 1, drbg_statelen(drbg));\r\ndrbg_string_fill(&seed1, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&seed1.list, &seedlist);\r\ndrbg_string_fill(&seed2, NULL, 1);\r\nlist_add_tail(&seed2.list, &seedlist);\r\nif (seed)\r\nlist_splice_tail(seed, &seedlist);\r\ndrbg_string_fill(&vdata, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&vdata.list, &vdatalist);\r\nfor (i = 2; 0 < i; i--) {\r\nunsigned char prefix = DRBG_PREFIX0;\r\nif (1 == i)\r\nprefix = DRBG_PREFIX1;\r\nseed2.buf = &prefix;\r\nret = drbg_kcapi_hash(drbg, drbg->C, drbg->C, &seedlist);\r\nif (ret)\r\nreturn ret;\r\nret = drbg_kcapi_hash(drbg, drbg->C, drbg->V, &vdatalist);\r\nif (ret)\r\nreturn ret;\r\nif (!seed)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drbg_hmac_generate(struct drbg_state *drbg,\r\nunsigned char *buf,\r\nunsigned int buflen,\r\nstruct list_head *addtl)\r\n{\r\nint len = 0;\r\nint ret = 0;\r\nstruct drbg_string data;\r\nLIST_HEAD(datalist);\r\nif (addtl && !list_empty(addtl)) {\r\nret = drbg_hmac_update(drbg, addtl, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndrbg_string_fill(&data, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&data.list, &datalist);\r\nwhile (len < buflen) {\r\nunsigned int outlen = 0;\r\nret = drbg_kcapi_hash(drbg, drbg->C, drbg->V, &datalist);\r\nif (ret)\r\nreturn ret;\r\noutlen = (drbg_blocklen(drbg) < (buflen - len)) ?\r\ndrbg_blocklen(drbg) : (buflen - len);\r\nif (!drbg_fips_continuous_test(drbg, drbg->V))\r\ncontinue;\r\nmemcpy(buf + len, drbg->V, outlen);\r\nlen += outlen;\r\n}\r\nif (addtl && !list_empty(addtl))\r\nret = drbg_hmac_update(drbg, addtl, 1);\r\nelse\r\nret = drbg_hmac_update(drbg, NULL, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic inline void drbg_add_buf(unsigned char *dst, size_t dstlen,\r\nconst unsigned char *add, size_t addlen)\r\n{\r\nunsigned char *dstptr;\r\nconst unsigned char *addptr;\r\nunsigned int remainder = 0;\r\nsize_t len = addlen;\r\ndstptr = dst + (dstlen-1);\r\naddptr = add + (addlen-1);\r\nwhile (len) {\r\nremainder += *dstptr + *addptr;\r\n*dstptr = remainder & 0xff;\r\nremainder >>= 8;\r\nlen--; dstptr--; addptr--;\r\n}\r\nlen = dstlen - addlen;\r\nwhile (len && remainder > 0) {\r\nremainder = *dstptr + 1;\r\n*dstptr = remainder & 0xff;\r\nremainder >>= 8;\r\nlen--; dstptr--;\r\n}\r\n}\r\nstatic int drbg_hash_df(struct drbg_state *drbg,\r\nunsigned char *outval, size_t outlen,\r\nstruct list_head *entropylist)\r\n{\r\nint ret = 0;\r\nsize_t len = 0;\r\nunsigned char input[5];\r\nunsigned char *tmp = drbg->scratchpad + drbg_statelen(drbg);\r\nstruct drbg_string data;\r\ninput[0] = 1;\r\ndrbg_cpu_to_be32((outlen * 8), &input[1]);\r\ndrbg_string_fill(&data, input, 5);\r\nlist_add(&data.list, entropylist);\r\nwhile (len < outlen) {\r\nshort blocklen = 0;\r\nret = drbg_kcapi_hash(drbg, NULL, tmp, entropylist);\r\nif (ret)\r\ngoto out;\r\ninput[0]++;\r\nblocklen = (drbg_blocklen(drbg) < (outlen - len)) ?\r\ndrbg_blocklen(drbg) : (outlen - len);\r\nmemcpy(outval + len, tmp, blocklen);\r\nlen += blocklen;\r\n}\r\nout:\r\nmemset(tmp, 0, drbg_blocklen(drbg));\r\nreturn ret;\r\n}\r\nstatic int drbg_hash_update(struct drbg_state *drbg, struct list_head *seed,\r\nint reseed)\r\n{\r\nint ret = 0;\r\nstruct drbg_string data1, data2;\r\nLIST_HEAD(datalist);\r\nLIST_HEAD(datalist2);\r\nunsigned char *V = drbg->scratchpad;\r\nunsigned char prefix = DRBG_PREFIX1;\r\nif (!seed)\r\nreturn -EINVAL;\r\nif (reseed) {\r\nmemcpy(V, drbg->V, drbg_statelen(drbg));\r\ndrbg_string_fill(&data1, &prefix, 1);\r\nlist_add_tail(&data1.list, &datalist);\r\ndrbg_string_fill(&data2, V, drbg_statelen(drbg));\r\nlist_add_tail(&data2.list, &datalist);\r\n}\r\nlist_splice_tail(seed, &datalist);\r\nret = drbg_hash_df(drbg, drbg->V, drbg_statelen(drbg), &datalist);\r\nif (ret)\r\ngoto out;\r\nprefix = DRBG_PREFIX0;\r\ndrbg_string_fill(&data1, &prefix, 1);\r\nlist_add_tail(&data1.list, &datalist2);\r\ndrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&data2.list, &datalist2);\r\nret = drbg_hash_df(drbg, drbg->C, drbg_statelen(drbg), &datalist2);\r\nout:\r\nmemset(drbg->scratchpad, 0, drbg_statelen(drbg));\r\nreturn ret;\r\n}\r\nstatic int drbg_hash_process_addtl(struct drbg_state *drbg,\r\nstruct list_head *addtl)\r\n{\r\nint ret = 0;\r\nstruct drbg_string data1, data2;\r\nLIST_HEAD(datalist);\r\nunsigned char prefix = DRBG_PREFIX2;\r\nif (!addtl || list_empty(addtl))\r\nreturn 0;\r\ndrbg_string_fill(&data1, &prefix, 1);\r\ndrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&data1.list, &datalist);\r\nlist_add_tail(&data2.list, &datalist);\r\nlist_splice_tail(addtl, &datalist);\r\nret = drbg_kcapi_hash(drbg, NULL, drbg->scratchpad, &datalist);\r\nif (ret)\r\ngoto out;\r\ndrbg_add_buf(drbg->V, drbg_statelen(drbg),\r\ndrbg->scratchpad, drbg_blocklen(drbg));\r\nout:\r\nmemset(drbg->scratchpad, 0, drbg_blocklen(drbg));\r\nreturn ret;\r\n}\r\nstatic int drbg_hash_hashgen(struct drbg_state *drbg,\r\nunsigned char *buf,\r\nunsigned int buflen)\r\n{\r\nint len = 0;\r\nint ret = 0;\r\nunsigned char *src = drbg->scratchpad;\r\nunsigned char *dst = drbg->scratchpad + drbg_statelen(drbg);\r\nstruct drbg_string data;\r\nLIST_HEAD(datalist);\r\nmemcpy(src, drbg->V, drbg_statelen(drbg));\r\ndrbg_string_fill(&data, src, drbg_statelen(drbg));\r\nlist_add_tail(&data.list, &datalist);\r\nwhile (len < buflen) {\r\nunsigned int outlen = 0;\r\nret = drbg_kcapi_hash(drbg, NULL, dst, &datalist);\r\nif (ret) {\r\nlen = ret;\r\ngoto out;\r\n}\r\noutlen = (drbg_blocklen(drbg) < (buflen - len)) ?\r\ndrbg_blocklen(drbg) : (buflen - len);\r\nif (!drbg_fips_continuous_test(drbg, dst)) {\r\ncrypto_inc(src, drbg_statelen(drbg));\r\ncontinue;\r\n}\r\nmemcpy(buf + len, dst, outlen);\r\nlen += outlen;\r\nif (len < buflen)\r\ncrypto_inc(src, drbg_statelen(drbg));\r\n}\r\nout:\r\nmemset(drbg->scratchpad, 0,\r\n(drbg_statelen(drbg) + drbg_blocklen(drbg)));\r\nreturn len;\r\n}\r\nstatic int drbg_hash_generate(struct drbg_state *drbg,\r\nunsigned char *buf, unsigned int buflen,\r\nstruct list_head *addtl)\r\n{\r\nint len = 0;\r\nint ret = 0;\r\nunion {\r\nunsigned char req[8];\r\n__be64 req_int;\r\n} u;\r\nunsigned char prefix = DRBG_PREFIX3;\r\nstruct drbg_string data1, data2;\r\nLIST_HEAD(datalist);\r\nret = drbg_hash_process_addtl(drbg, addtl);\r\nif (ret)\r\nreturn ret;\r\nlen = drbg_hash_hashgen(drbg, buf, buflen);\r\ndrbg_string_fill(&data1, &prefix, 1);\r\nlist_add_tail(&data1.list, &datalist);\r\ndrbg_string_fill(&data2, drbg->V, drbg_statelen(drbg));\r\nlist_add_tail(&data2.list, &datalist);\r\nret = drbg_kcapi_hash(drbg, NULL, drbg->scratchpad, &datalist);\r\nif (ret) {\r\nlen = ret;\r\ngoto out;\r\n}\r\ndrbg_add_buf(drbg->V, drbg_statelen(drbg),\r\ndrbg->scratchpad, drbg_blocklen(drbg));\r\ndrbg_add_buf(drbg->V, drbg_statelen(drbg),\r\ndrbg->C, drbg_statelen(drbg));\r\nu.req_int = cpu_to_be64(drbg->reseed_ctr);\r\ndrbg_add_buf(drbg->V, drbg_statelen(drbg), u.req, 8);\r\nout:\r\nmemset(drbg->scratchpad, 0, drbg_blocklen(drbg));\r\nreturn len;\r\n}\r\nstatic inline int __drbg_seed(struct drbg_state *drbg, struct list_head *seed,\r\nint reseed)\r\n{\r\nint ret = drbg->d_ops->update(drbg, seed, reseed);\r\nif (ret)\r\nreturn ret;\r\ndrbg->seeded = true;\r\ndrbg->reseed_ctr = 1;\r\nreturn ret;\r\n}\r\nstatic void drbg_async_seed(struct work_struct *work)\r\n{\r\nstruct drbg_string data;\r\nLIST_HEAD(seedlist);\r\nstruct drbg_state *drbg = container_of(work, struct drbg_state,\r\nseed_work);\r\nunsigned int entropylen = drbg_sec_strength(drbg->core->flags);\r\nunsigned char entropy[32];\r\nBUG_ON(!entropylen);\r\nBUG_ON(entropylen > sizeof(entropy));\r\nget_random_bytes(entropy, entropylen);\r\ndrbg_string_fill(&data, entropy, entropylen);\r\nlist_add_tail(&data.list, &seedlist);\r\nmutex_lock(&drbg->drbg_mutex);\r\ncrypto_free_rng(drbg->jent);\r\ndrbg->jent = NULL;\r\ndrbg->seeded = false;\r\n__drbg_seed(drbg, &seedlist, true);\r\nif (drbg->seeded)\r\ndrbg->reseed_threshold = drbg_max_requests(drbg);\r\nmutex_unlock(&drbg->drbg_mutex);\r\nmemzero_explicit(entropy, entropylen);\r\n}\r\nstatic int drbg_seed(struct drbg_state *drbg, struct drbg_string *pers,\r\nbool reseed)\r\n{\r\nint ret;\r\nunsigned char entropy[((32 + 16) * 2)];\r\nunsigned int entropylen = drbg_sec_strength(drbg->core->flags);\r\nstruct drbg_string data1;\r\nLIST_HEAD(seedlist);\r\nif (pers && pers->len > (drbg_max_addtl(drbg))) {\r\npr_devel("DRBG: personalization string too long %zu\n",\r\npers->len);\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&drbg->test_data.list)) {\r\ndrbg_string_fill(&data1, drbg->test_data.buf,\r\ndrbg->test_data.len);\r\npr_devel("DRBG: using test entropy\n");\r\n} else {\r\nBUG_ON(!entropylen);\r\nif (!reseed)\r\nentropylen = ((entropylen + 1) / 2) * 3;\r\nBUG_ON((entropylen * 2) > sizeof(entropy));\r\nget_random_bytes(entropy, entropylen);\r\nif (!drbg->jent) {\r\ndrbg_string_fill(&data1, entropy, entropylen);\r\npr_devel("DRBG: (re)seeding with %u bytes of entropy\n",\r\nentropylen);\r\n} else {\r\nret = crypto_rng_get_bytes(drbg->jent,\r\nentropy + entropylen,\r\nentropylen);\r\nif (ret) {\r\npr_devel("DRBG: jent failed with %d\n", ret);\r\nreturn ret;\r\n}\r\ndrbg_string_fill(&data1, entropy, entropylen * 2);\r\npr_devel("DRBG: (re)seeding with %u bytes of entropy\n",\r\nentropylen * 2);\r\n}\r\n}\r\nlist_add_tail(&data1.list, &seedlist);\r\nif (pers && pers->buf && 0 < pers->len) {\r\nlist_add_tail(&pers->list, &seedlist);\r\npr_devel("DRBG: using personalization string\n");\r\n}\r\nif (!reseed) {\r\nmemset(drbg->V, 0, drbg_statelen(drbg));\r\nmemset(drbg->C, 0, drbg_statelen(drbg));\r\n}\r\nret = __drbg_seed(drbg, &seedlist, reseed);\r\nmemzero_explicit(entropy, entropylen * 2);\r\nreturn ret;\r\n}\r\nstatic inline void drbg_dealloc_state(struct drbg_state *drbg)\r\n{\r\nif (!drbg)\r\nreturn;\r\nkzfree(drbg->V);\r\ndrbg->V = NULL;\r\nkzfree(drbg->C);\r\ndrbg->C = NULL;\r\nkzfree(drbg->scratchpad);\r\ndrbg->scratchpad = NULL;\r\ndrbg->reseed_ctr = 0;\r\ndrbg->d_ops = NULL;\r\ndrbg->core = NULL;\r\n#ifdef CONFIG_CRYPTO_FIPS\r\nkzfree(drbg->prev);\r\ndrbg->prev = NULL;\r\ndrbg->fips_primed = false;\r\n#endif\r\n}\r\nstatic inline int drbg_alloc_state(struct drbg_state *drbg)\r\n{\r\nint ret = -ENOMEM;\r\nunsigned int sb_size = 0;\r\nswitch (drbg->core->flags & DRBG_TYPE_MASK) {\r\n#ifdef CONFIG_CRYPTO_DRBG_HMAC\r\ncase DRBG_HMAC:\r\ndrbg->d_ops = &drbg_hmac_ops;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_CRYPTO_DRBG_HASH\r\ncase DRBG_HASH:\r\ndrbg->d_ops = &drbg_hash_ops;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_CRYPTO_DRBG_CTR\r\ncase DRBG_CTR:\r\ndrbg->d_ops = &drbg_ctr_ops;\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\ndrbg->V = kmalloc(drbg_statelen(drbg), GFP_KERNEL);\r\nif (!drbg->V)\r\ngoto err;\r\ndrbg->C = kmalloc(drbg_statelen(drbg), GFP_KERNEL);\r\nif (!drbg->C)\r\ngoto err;\r\n#ifdef CONFIG_CRYPTO_FIPS\r\ndrbg->prev = kmalloc(drbg_blocklen(drbg), GFP_KERNEL);\r\nif (!drbg->prev)\r\ngoto err;\r\ndrbg->fips_primed = false;\r\n#endif\r\nif (drbg->core->flags & DRBG_HMAC)\r\nsb_size = 0;\r\nelse if (drbg->core->flags & DRBG_CTR)\r\nsb_size = drbg_statelen(drbg) + drbg_blocklen(drbg) +\r\ndrbg_statelen(drbg) +\r\ndrbg_blocklen(drbg) +\r\ndrbg_blocklen(drbg) +\r\ndrbg_statelen(drbg) + drbg_blocklen(drbg);\r\nelse\r\nsb_size = drbg_statelen(drbg) + drbg_blocklen(drbg);\r\nif (0 < sb_size) {\r\ndrbg->scratchpad = kzalloc(sb_size, GFP_KERNEL);\r\nif (!drbg->scratchpad)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndrbg_dealloc_state(drbg);\r\nreturn ret;\r\n}\r\nstatic int drbg_generate(struct drbg_state *drbg,\r\nunsigned char *buf, unsigned int buflen,\r\nstruct drbg_string *addtl)\r\n{\r\nint len = 0;\r\nLIST_HEAD(addtllist);\r\nif (!drbg->core) {\r\npr_devel("DRBG: not yet seeded\n");\r\nreturn -EINVAL;\r\n}\r\nif (0 == buflen || !buf) {\r\npr_devel("DRBG: no output buffer provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (addtl && NULL == addtl->buf && 0 < addtl->len) {\r\npr_devel("DRBG: wrong format of additional information\n");\r\nreturn -EINVAL;\r\n}\r\nlen = -EINVAL;\r\nif (buflen > (drbg_max_request_bytes(drbg))) {\r\npr_devel("DRBG: requested random numbers too large %u\n",\r\nbuflen);\r\ngoto err;\r\n}\r\nif (addtl && addtl->len > (drbg_max_addtl(drbg))) {\r\npr_devel("DRBG: additional information string too long %zu\n",\r\naddtl->len);\r\ngoto err;\r\n}\r\nif (drbg->reseed_threshold < drbg->reseed_ctr)\r\ndrbg->seeded = false;\r\nif (drbg->pr || !drbg->seeded) {\r\npr_devel("DRBG: reseeding before generation (prediction "\r\n"resistance: %s, state %s)\n",\r\ndrbg->pr ? "true" : "false",\r\ndrbg->seeded ? "seeded" : "unseeded");\r\nlen = drbg_seed(drbg, addtl, true);\r\nif (len)\r\ngoto err;\r\naddtl = NULL;\r\n}\r\nif (addtl && 0 < addtl->len)\r\nlist_add_tail(&addtl->list, &addtllist);\r\nlen = drbg->d_ops->generate(drbg, buf, buflen, &addtllist);\r\ndrbg->reseed_ctr++;\r\nif (0 >= len)\r\ngoto err;\r\n#if 0\r\nif (drbg->reseed_ctr && !(drbg->reseed_ctr % 4096)) {\r\nint err = 0;\r\npr_devel("DRBG: start to perform self test\n");\r\nif (drbg->core->flags & DRBG_HMAC)\r\nerr = alg_test("drbg_pr_hmac_sha256",\r\n"drbg_pr_hmac_sha256", 0, 0);\r\nelse if (drbg->core->flags & DRBG_CTR)\r\nerr = alg_test("drbg_pr_ctr_aes128",\r\n"drbg_pr_ctr_aes128", 0, 0);\r\nelse\r\nerr = alg_test("drbg_pr_sha256",\r\n"drbg_pr_sha256", 0, 0);\r\nif (err) {\r\npr_err("DRBG: periodical self test failed\n");\r\ndrbg_uninstantiate(drbg);\r\nreturn 0;\r\n} else {\r\npr_devel("DRBG: self test successful\n");\r\n}\r\n}\r\n#endif\r\nlen = 0;\r\nerr:\r\nreturn len;\r\n}\r\nstatic int drbg_generate_long(struct drbg_state *drbg,\r\nunsigned char *buf, unsigned int buflen,\r\nstruct drbg_string *addtl)\r\n{\r\nunsigned int len = 0;\r\nunsigned int slice = 0;\r\ndo {\r\nint err = 0;\r\nunsigned int chunk = 0;\r\nslice = ((buflen - len) / drbg_max_request_bytes(drbg));\r\nchunk = slice ? drbg_max_request_bytes(drbg) : (buflen - len);\r\nmutex_lock(&drbg->drbg_mutex);\r\nerr = drbg_generate(drbg, buf + len, chunk, addtl);\r\nmutex_unlock(&drbg->drbg_mutex);\r\nif (0 > err)\r\nreturn err;\r\nlen += chunk;\r\n} while (slice > 0 && (len < buflen));\r\nreturn 0;\r\n}\r\nstatic void drbg_schedule_async_seed(struct random_ready_callback *rdy)\r\n{\r\nstruct drbg_state *drbg = container_of(rdy, struct drbg_state,\r\nrandom_ready);\r\nschedule_work(&drbg->seed_work);\r\n}\r\nstatic int drbg_prepare_hrng(struct drbg_state *drbg)\r\n{\r\nint err;\r\nif (list_empty(&drbg->test_data.list))\r\nreturn 0;\r\nINIT_WORK(&drbg->seed_work, drbg_async_seed);\r\ndrbg->random_ready.owner = THIS_MODULE;\r\ndrbg->random_ready.func = drbg_schedule_async_seed;\r\nerr = add_random_ready_callback(&drbg->random_ready);\r\nswitch (err) {\r\ncase 0:\r\nbreak;\r\ncase -EALREADY:\r\nerr = 0;\r\ndefault:\r\ndrbg->random_ready.func = NULL;\r\nreturn err;\r\n}\r\ndrbg->jent = crypto_alloc_rng("jitterentropy_rng", 0, 0);\r\ndrbg->reseed_threshold = 50;\r\nreturn err;\r\n}\r\nstatic int drbg_instantiate(struct drbg_state *drbg, struct drbg_string *pers,\r\nint coreref, bool pr)\r\n{\r\nint ret;\r\nbool reseed = true;\r\npr_devel("DRBG: Initializing DRBG core %d with prediction resistance "\r\n"%s\n", coreref, pr ? "enabled" : "disabled");\r\nmutex_lock(&drbg->drbg_mutex);\r\nif (!drbg->core) {\r\ndrbg->core = &drbg_cores[coreref];\r\ndrbg->pr = pr;\r\ndrbg->seeded = false;\r\ndrbg->reseed_threshold = drbg_max_requests(drbg);\r\nret = drbg_alloc_state(drbg);\r\nif (ret)\r\ngoto unlock;\r\nret = -EFAULT;\r\nif (drbg->d_ops->crypto_init(drbg))\r\ngoto err;\r\nret = drbg_prepare_hrng(drbg);\r\nif (ret)\r\ngoto free_everything;\r\nif (IS_ERR(drbg->jent)) {\r\nret = PTR_ERR(drbg->jent);\r\ndrbg->jent = NULL;\r\nif (fips_enabled || ret != -ENOENT)\r\ngoto free_everything;\r\npr_info("DRBG: Continuing without Jitter RNG\n");\r\n}\r\nreseed = false;\r\n}\r\nret = drbg_seed(drbg, pers, reseed);\r\nif (ret && !reseed)\r\ngoto free_everything;\r\nmutex_unlock(&drbg->drbg_mutex);\r\nreturn ret;\r\nerr:\r\ndrbg_dealloc_state(drbg);\r\nunlock:\r\nmutex_unlock(&drbg->drbg_mutex);\r\nreturn ret;\r\nfree_everything:\r\nmutex_unlock(&drbg->drbg_mutex);\r\ndrbg_uninstantiate(drbg);\r\nreturn ret;\r\n}\r\nstatic int drbg_uninstantiate(struct drbg_state *drbg)\r\n{\r\nif (drbg->random_ready.func) {\r\ndel_random_ready_callback(&drbg->random_ready);\r\ncancel_work_sync(&drbg->seed_work);\r\ncrypto_free_rng(drbg->jent);\r\ndrbg->jent = NULL;\r\n}\r\nif (drbg->d_ops)\r\ndrbg->d_ops->crypto_fini(drbg);\r\ndrbg_dealloc_state(drbg);\r\nreturn 0;\r\n}\r\nstatic void drbg_kcapi_set_entropy(struct crypto_rng *tfm,\r\nconst u8 *data, unsigned int len)\r\n{\r\nstruct drbg_state *drbg = crypto_rng_ctx(tfm);\r\nmutex_lock(&drbg->drbg_mutex);\r\ndrbg_string_fill(&drbg->test_data, data, len);\r\nmutex_unlock(&drbg->drbg_mutex);\r\n}\r\nstatic int drbg_init_hash_kernel(struct drbg_state *drbg)\r\n{\r\nstruct sdesc *sdesc;\r\nstruct crypto_shash *tfm;\r\ntfm = crypto_alloc_shash(drbg->core->backend_cra_name, 0, 0);\r\nif (IS_ERR(tfm)) {\r\npr_info("DRBG: could not allocate digest TFM handle: %s\n",\r\ndrbg->core->backend_cra_name);\r\nreturn PTR_ERR(tfm);\r\n}\r\nBUG_ON(drbg_blocklen(drbg) != crypto_shash_digestsize(tfm));\r\nsdesc = kzalloc(sizeof(struct shash_desc) + crypto_shash_descsize(tfm),\r\nGFP_KERNEL);\r\nif (!sdesc) {\r\ncrypto_free_shash(tfm);\r\nreturn -ENOMEM;\r\n}\r\nsdesc->shash.tfm = tfm;\r\nsdesc->shash.flags = 0;\r\ndrbg->priv_data = sdesc;\r\nreturn 0;\r\n}\r\nstatic int drbg_fini_hash_kernel(struct drbg_state *drbg)\r\n{\r\nstruct sdesc *sdesc = (struct sdesc *)drbg->priv_data;\r\nif (sdesc) {\r\ncrypto_free_shash(sdesc->shash.tfm);\r\nkzfree(sdesc);\r\n}\r\ndrbg->priv_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int drbg_kcapi_hash(struct drbg_state *drbg, const unsigned char *key,\r\nunsigned char *outval, const struct list_head *in)\r\n{\r\nstruct sdesc *sdesc = (struct sdesc *)drbg->priv_data;\r\nstruct drbg_string *input = NULL;\r\nif (key)\r\ncrypto_shash_setkey(sdesc->shash.tfm, key, drbg_statelen(drbg));\r\ncrypto_shash_init(&sdesc->shash);\r\nlist_for_each_entry(input, in, list)\r\ncrypto_shash_update(&sdesc->shash, input->buf, input->len);\r\nreturn crypto_shash_final(&sdesc->shash, outval);\r\n}\r\nstatic int drbg_init_sym_kernel(struct drbg_state *drbg)\r\n{\r\nint ret = 0;\r\nstruct crypto_cipher *tfm;\r\ntfm = crypto_alloc_cipher(drbg->core->backend_cra_name, 0, 0);\r\nif (IS_ERR(tfm)) {\r\npr_info("DRBG: could not allocate cipher TFM handle: %s\n",\r\ndrbg->core->backend_cra_name);\r\nreturn PTR_ERR(tfm);\r\n}\r\nBUG_ON(drbg_blocklen(drbg) != crypto_cipher_blocksize(tfm));\r\ndrbg->priv_data = tfm;\r\nreturn ret;\r\n}\r\nstatic int drbg_fini_sym_kernel(struct drbg_state *drbg)\r\n{\r\nstruct crypto_cipher *tfm =\r\n(struct crypto_cipher *)drbg->priv_data;\r\nif (tfm)\r\ncrypto_free_cipher(tfm);\r\ndrbg->priv_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int drbg_kcapi_sym(struct drbg_state *drbg, const unsigned char *key,\r\nunsigned char *outval, const struct drbg_string *in)\r\n{\r\nstruct crypto_cipher *tfm =\r\n(struct crypto_cipher *)drbg->priv_data;\r\ncrypto_cipher_setkey(tfm, key, (drbg_keylen(drbg)));\r\nBUG_ON(in->len < drbg_blocklen(drbg));\r\ncrypto_cipher_encrypt_one(tfm, outval, in->buf);\r\nreturn 0;\r\n}\r\nstatic inline void drbg_convert_tfm_core(const char *cra_driver_name,\r\nint *coreref, bool *pr)\r\n{\r\nint i = 0;\r\nsize_t start = 0;\r\nint len = 0;\r\n*pr = true;\r\nif (!memcmp(cra_driver_name, "drbg_nopr_", 10)) {\r\nstart = 10;\r\n*pr = false;\r\n} else if (!memcmp(cra_driver_name, "drbg_pr_", 8)) {\r\nstart = 8;\r\n} else {\r\nreturn;\r\n}\r\nlen = strlen(cra_driver_name) - start;\r\nfor (i = 0; ARRAY_SIZE(drbg_cores) > i; i++) {\r\nif (!memcmp(cra_driver_name + start, drbg_cores[i].cra_name,\r\nlen)) {\r\n*coreref = i;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int drbg_kcapi_init(struct crypto_tfm *tfm)\r\n{\r\nstruct drbg_state *drbg = crypto_tfm_ctx(tfm);\r\nmutex_init(&drbg->drbg_mutex);\r\nreturn 0;\r\n}\r\nstatic void drbg_kcapi_cleanup(struct crypto_tfm *tfm)\r\n{\r\ndrbg_uninstantiate(crypto_tfm_ctx(tfm));\r\n}\r\nstatic int drbg_kcapi_random(struct crypto_rng *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *dst, unsigned int dlen)\r\n{\r\nstruct drbg_state *drbg = crypto_rng_ctx(tfm);\r\nstruct drbg_string *addtl = NULL;\r\nstruct drbg_string string;\r\nif (slen) {\r\ndrbg_string_fill(&string, src, slen);\r\naddtl = &string;\r\n}\r\nreturn drbg_generate_long(drbg, dst, dlen, addtl);\r\n}\r\nstatic int drbg_kcapi_seed(struct crypto_rng *tfm,\r\nconst u8 *seed, unsigned int slen)\r\n{\r\nstruct drbg_state *drbg = crypto_rng_ctx(tfm);\r\nstruct crypto_tfm *tfm_base = crypto_rng_tfm(tfm);\r\nbool pr = false;\r\nstruct drbg_string string;\r\nstruct drbg_string *seed_string = NULL;\r\nint coreref = 0;\r\ndrbg_convert_tfm_core(crypto_tfm_alg_driver_name(tfm_base), &coreref,\r\n&pr);\r\nif (0 < slen) {\r\ndrbg_string_fill(&string, seed, slen);\r\nseed_string = &string;\r\n}\r\nreturn drbg_instantiate(drbg, seed_string, coreref, pr);\r\n}\r\nstatic inline int __init drbg_healthcheck_sanity(void)\r\n{\r\nint len = 0;\r\n#define OUTBUFLEN 16\r\nunsigned char buf[OUTBUFLEN];\r\nstruct drbg_state *drbg = NULL;\r\nint ret = -EFAULT;\r\nint rc = -EFAULT;\r\nbool pr = false;\r\nint coreref = 0;\r\nstruct drbg_string addtl;\r\nsize_t max_addtllen, max_request_bytes;\r\nif (!fips_enabled)\r\nreturn 0;\r\n#ifdef CONFIG_CRYPTO_DRBG_CTR\r\ndrbg_convert_tfm_core("drbg_nopr_ctr_aes128", &coreref, &pr);\r\n#elif defined CONFIG_CRYPTO_DRBG_HASH\r\ndrbg_convert_tfm_core("drbg_nopr_sha256", &coreref, &pr);\r\n#else\r\ndrbg_convert_tfm_core("drbg_nopr_hmac_sha256", &coreref, &pr);\r\n#endif\r\ndrbg = kzalloc(sizeof(struct drbg_state), GFP_KERNEL);\r\nif (!drbg)\r\nreturn -ENOMEM;\r\nmutex_init(&drbg->drbg_mutex);\r\nret = drbg_instantiate(drbg, NULL, coreref, pr);\r\nif (ret) {\r\nrc = ret;\r\ngoto outbuf;\r\n}\r\nmax_addtllen = drbg_max_addtl(drbg);\r\nmax_request_bytes = drbg_max_request_bytes(drbg);\r\ndrbg_string_fill(&addtl, buf, max_addtllen + 1);\r\nlen = drbg_generate(drbg, buf, OUTBUFLEN, &addtl);\r\nBUG_ON(0 < len);\r\nlen = drbg_generate(drbg, buf, (max_request_bytes + 1), NULL);\r\nBUG_ON(0 < len);\r\ndrbg_uninstantiate(drbg);\r\nret = drbg_instantiate(drbg, &addtl, coreref, pr);\r\nBUG_ON(0 == ret);\r\nrc = 0;\r\npr_devel("DRBG: Sanity tests for failure code paths successfully "\r\n"completed\n");\r\ndrbg_uninstantiate(drbg);\r\noutbuf:\r\nkzfree(drbg);\r\nreturn rc;\r\n}\r\nstatic inline void __init drbg_fill_array(struct rng_alg *alg,\r\nconst struct drbg_core *core, int pr)\r\n{\r\nint pos = 0;\r\nstatic int priority = 200;\r\nmemcpy(alg->base.cra_name, "stdrng", 6);\r\nif (pr) {\r\nmemcpy(alg->base.cra_driver_name, "drbg_pr_", 8);\r\npos = 8;\r\n} else {\r\nmemcpy(alg->base.cra_driver_name, "drbg_nopr_", 10);\r\npos = 10;\r\n}\r\nmemcpy(alg->base.cra_driver_name + pos, core->cra_name,\r\nstrlen(core->cra_name));\r\nalg->base.cra_priority = priority;\r\npriority++;\r\nif (fips_enabled)\r\nalg->base.cra_priority += 200;\r\nalg->base.cra_ctxsize = sizeof(struct drbg_state);\r\nalg->base.cra_module = THIS_MODULE;\r\nalg->base.cra_init = drbg_kcapi_init;\r\nalg->base.cra_exit = drbg_kcapi_cleanup;\r\nalg->generate = drbg_kcapi_random;\r\nalg->seed = drbg_kcapi_seed;\r\nalg->set_ent = drbg_kcapi_set_entropy;\r\nalg->seedsize = 0;\r\n}\r\nstatic int __init drbg_init(void)\r\n{\r\nunsigned int i = 0;\r\nunsigned int j = 0;\r\nint ret = -EFAULT;\r\nret = drbg_healthcheck_sanity();\r\nif (ret)\r\nreturn ret;\r\nif (ARRAY_SIZE(drbg_cores) * 2 > ARRAY_SIZE(drbg_algs)) {\r\npr_info("DRBG: Cannot register all DRBG types"\r\n"(slots needed: %zu, slots available: %zu)\n",\r\nARRAY_SIZE(drbg_cores) * 2, ARRAY_SIZE(drbg_algs));\r\nreturn ret;\r\n}\r\nfor (j = 0; ARRAY_SIZE(drbg_cores) > j; j++, i++)\r\ndrbg_fill_array(&drbg_algs[i], &drbg_cores[j], 1);\r\nfor (j = 0; ARRAY_SIZE(drbg_cores) > j; j++, i++)\r\ndrbg_fill_array(&drbg_algs[i], &drbg_cores[j], 0);\r\nreturn crypto_register_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));\r\n}\r\nstatic void __exit drbg_exit(void)\r\n{\r\ncrypto_unregister_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));\r\n}
