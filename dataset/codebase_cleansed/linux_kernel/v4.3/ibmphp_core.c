static inline int get_cur_bus_info(struct slot **sl)\r\n{\r\nint rc = 1;\r\nstruct slot *slot_cur = *sl;\r\ndebug("options = %x\n", slot_cur->ctrl->options);\r\ndebug("revision = %x\n", slot_cur->ctrl->revision);\r\nif (READ_BUS_STATUS(slot_cur->ctrl))\r\nrc = ibmphp_hpc_readslot(slot_cur, READ_BUSSTATUS, NULL);\r\nif (rc)\r\nreturn rc;\r\nslot_cur->bus_on->current_speed = CURRENT_BUS_SPEED(slot_cur->busstatus);\r\nif (READ_BUS_MODE(slot_cur->ctrl))\r\nslot_cur->bus_on->current_bus_mode =\r\nCURRENT_BUS_MODE(slot_cur->busstatus);\r\nelse\r\nslot_cur->bus_on->current_bus_mode = 0xFF;\r\ndebug("busstatus = %x, bus_speed = %x, bus_mode = %x\n",\r\nslot_cur->busstatus,\r\nslot_cur->bus_on->current_speed,\r\nslot_cur->bus_on->current_bus_mode);\r\n*sl = slot_cur;\r\nreturn 0;\r\n}\r\nstatic inline int slot_update(struct slot **sl)\r\n{\r\nint rc;\r\nrc = ibmphp_hpc_readslot(*sl, READ_ALLSTAT, NULL);\r\nif (rc)\r\nreturn rc;\r\nif (!init_flag)\r\nrc = get_cur_bus_info(sl);\r\nreturn rc;\r\n}\r\nstatic int __init get_max_slots (void)\r\n{\r\nstruct slot *slot_cur;\r\nstruct list_head *tmp;\r\nu8 slot_count = 0;\r\nlist_for_each(tmp, &ibmphp_slot_head) {\r\nslot_cur = list_entry(tmp, struct slot, ibm_slot_list);\r\nslot_count = max(slot_count, slot_cur->number);\r\n}\r\nreturn slot_count;\r\n}\r\nint ibmphp_init_devno(struct slot **cur_slot)\r\n{\r\nstruct irq_routing_table *rtable;\r\nint len;\r\nint loop;\r\nint i;\r\nrtable = pcibios_get_irq_routing_table();\r\nif (!rtable) {\r\nerr("no BIOS routing table...\n");\r\nreturn -ENOMEM;\r\n}\r\nlen = (rtable->size - sizeof(struct irq_routing_table)) /\r\nsizeof(struct irq_info);\r\nif (!len) {\r\nkfree(rtable);\r\nreturn -1;\r\n}\r\nfor (loop = 0; loop < len; loop++) {\r\nif ((*cur_slot)->number == rtable->slots[loop].slot &&\r\n(*cur_slot)->bus == rtable->slots[loop].bus) {\r\n(*cur_slot)->device = PCI_SLOT(rtable->slots[loop].devfn);\r\nfor (i = 0; i < 4; i++)\r\n(*cur_slot)->irq[i] = IO_APIC_get_PCI_irq_vector((int) (*cur_slot)->bus,\r\n(int) (*cur_slot)->device, i);\r\ndebug("(*cur_slot)->irq[0] = %x\n",\r\n(*cur_slot)->irq[0]);\r\ndebug("(*cur_slot)->irq[1] = %x\n",\r\n(*cur_slot)->irq[1]);\r\ndebug("(*cur_slot)->irq[2] = %x\n",\r\n(*cur_slot)->irq[2]);\r\ndebug("(*cur_slot)->irq[3] = %x\n",\r\n(*cur_slot)->irq[3]);\r\ndebug("rtable->exclusive_irqs = %x\n",\r\nrtable->exclusive_irqs);\r\ndebug("rtable->slots[loop].irq[0].bitmap = %x\n",\r\nrtable->slots[loop].irq[0].bitmap);\r\ndebug("rtable->slots[loop].irq[1].bitmap = %x\n",\r\nrtable->slots[loop].irq[1].bitmap);\r\ndebug("rtable->slots[loop].irq[2].bitmap = %x\n",\r\nrtable->slots[loop].irq[2].bitmap);\r\ndebug("rtable->slots[loop].irq[3].bitmap = %x\n",\r\nrtable->slots[loop].irq[3].bitmap);\r\ndebug("rtable->slots[loop].irq[0].link = %x\n",\r\nrtable->slots[loop].irq[0].link);\r\ndebug("rtable->slots[loop].irq[1].link = %x\n",\r\nrtable->slots[loop].irq[1].link);\r\ndebug("rtable->slots[loop].irq[2].link = %x\n",\r\nrtable->slots[loop].irq[2].link);\r\ndebug("rtable->slots[loop].irq[3].link = %x\n",\r\nrtable->slots[loop].irq[3].link);\r\ndebug("end of init_devno\n");\r\nkfree(rtable);\r\nreturn 0;\r\n}\r\n}\r\nkfree(rtable);\r\nreturn -1;\r\n}\r\nstatic inline int power_on(struct slot *slot_cur)\r\n{\r\nu8 cmd = HPC_SLOT_ON;\r\nint retval;\r\nretval = ibmphp_hpc_writeslot(slot_cur, cmd);\r\nif (retval) {\r\nerr("power on failed\n");\r\nreturn retval;\r\n}\r\nif (CTLR_RESULT(slot_cur->ctrl->status)) {\r\nerr("command not completed successfully in power_on\n");\r\nreturn -EIO;\r\n}\r\nmsleep(3000);\r\nreturn 0;\r\n}\r\nstatic inline int power_off(struct slot *slot_cur)\r\n{\r\nu8 cmd = HPC_SLOT_OFF;\r\nint retval;\r\nretval = ibmphp_hpc_writeslot(slot_cur, cmd);\r\nif (retval) {\r\nerr("power off failed\n");\r\nreturn retval;\r\n}\r\nif (CTLR_RESULT(slot_cur->ctrl->status)) {\r\nerr("command not completed successfully in power_off\n");\r\nretval = -EIO;\r\n}\r\nreturn retval;\r\n}\r\nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 value)\r\n{\r\nint rc = 0;\r\nstruct slot *pslot;\r\nu8 cmd = 0x00;\r\ndebug("set_attention_status - Entry hotplug_slot[%lx] value[%x]\n",\r\n(ulong) hotplug_slot, value);\r\nibmphp_lock_operations();\r\nif (hotplug_slot) {\r\nswitch (value) {\r\ncase HPC_SLOT_ATTN_OFF:\r\ncmd = HPC_SLOT_ATTNOFF;\r\nbreak;\r\ncase HPC_SLOT_ATTN_ON:\r\ncmd = HPC_SLOT_ATTNON;\r\nbreak;\r\ncase HPC_SLOT_ATTN_BLINK:\r\ncmd = HPC_SLOT_BLINKLED;\r\nbreak;\r\ndefault:\r\nrc = -ENODEV;\r\nerr("set_attention_status - Error : invalid input [%x]\n",\r\nvalue);\r\nbreak;\r\n}\r\nif (rc == 0) {\r\npslot = hotplug_slot->private;\r\nif (pslot)\r\nrc = ibmphp_hpc_writeslot(pslot, cmd);\r\nelse\r\nrc = -ENODEV;\r\n}\r\n} else\r\nrc = -ENODEV;\r\nibmphp_unlock_operations();\r\ndebug("set_attention_status - Exit rc[%d]\n", rc);\r\nreturn rc;\r\n}\r\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nint rc = -ENODEV;\r\nstruct slot *pslot;\r\nstruct slot myslot;\r\ndebug("get_attention_status - Entry hotplug_slot[%lx] pvalue[%lx]\n",\r\n(ulong) hotplug_slot, (ulong) value);\r\nibmphp_lock_operations();\r\nif (hotplug_slot) {\r\npslot = hotplug_slot->private;\r\nif (pslot) {\r\nmemcpy(&myslot, pslot, sizeof(struct slot));\r\nrc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\r\n&(myslot.status));\r\nif (!rc)\r\nrc = ibmphp_hpc_readslot(pslot,\r\nREAD_EXTSLOTSTATUS,\r\n&(myslot.ext_status));\r\nif (!rc)\r\n*value = SLOT_ATTN(myslot.status,\r\nmyslot.ext_status);\r\n}\r\n}\r\nibmphp_unlock_operations();\r\ndebug("get_attention_status - Exit rc[%d] value[%x]\n", rc, *value);\r\nreturn rc;\r\n}\r\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nint rc = -ENODEV;\r\nstruct slot *pslot;\r\nstruct slot myslot;\r\ndebug("get_latch_status - Entry hotplug_slot[%lx] pvalue[%lx]\n",\r\n(ulong) hotplug_slot, (ulong) value);\r\nibmphp_lock_operations();\r\nif (hotplug_slot) {\r\npslot = hotplug_slot->private;\r\nif (pslot) {\r\nmemcpy(&myslot, pslot, sizeof(struct slot));\r\nrc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\r\n&(myslot.status));\r\nif (!rc)\r\n*value = SLOT_LATCH(myslot.status);\r\n}\r\n}\r\nibmphp_unlock_operations();\r\ndebug("get_latch_status - Exit rc[%d] rc[%x] value[%x]\n",\r\nrc, rc, *value);\r\nreturn rc;\r\n}\r\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nint rc = -ENODEV;\r\nstruct slot *pslot;\r\nstruct slot myslot;\r\ndebug("get_power_status - Entry hotplug_slot[%lx] pvalue[%lx]\n",\r\n(ulong) hotplug_slot, (ulong) value);\r\nibmphp_lock_operations();\r\nif (hotplug_slot) {\r\npslot = hotplug_slot->private;\r\nif (pslot) {\r\nmemcpy(&myslot, pslot, sizeof(struct slot));\r\nrc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\r\n&(myslot.status));\r\nif (!rc)\r\n*value = SLOT_PWRGD(myslot.status);\r\n}\r\n}\r\nibmphp_unlock_operations();\r\ndebug("get_power_status - Exit rc[%d] rc[%x] value[%x]\n",\r\nrc, rc, *value);\r\nreturn rc;\r\n}\r\nstatic int get_adapter_present(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nint rc = -ENODEV;\r\nstruct slot *pslot;\r\nu8 present;\r\nstruct slot myslot;\r\ndebug("get_adapter_status - Entry hotplug_slot[%lx] pvalue[%lx]\n",\r\n(ulong) hotplug_slot, (ulong) value);\r\nibmphp_lock_operations();\r\nif (hotplug_slot) {\r\npslot = hotplug_slot->private;\r\nif (pslot) {\r\nmemcpy(&myslot, pslot, sizeof(struct slot));\r\nrc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\r\n&(myslot.status));\r\nif (!rc) {\r\npresent = SLOT_PRESENT(myslot.status);\r\nif (present == HPC_SLOT_EMPTY)\r\n*value = 0;\r\nelse\r\n*value = 1;\r\n}\r\n}\r\n}\r\nibmphp_unlock_operations();\r\ndebug("get_adapter_present - Exit rc[%d] value[%x]\n", rc, *value);\r\nreturn rc;\r\n}\r\nstatic int get_max_bus_speed(struct slot *slot)\r\n{\r\nint rc;\r\nu8 mode = 0;\r\nenum pci_bus_speed speed;\r\nstruct pci_bus *bus = slot->hotplug_slot->pci_slot->bus;\r\ndebug("%s - Entry slot[%p]\n", __func__, slot);\r\nibmphp_lock_operations();\r\nmode = slot->supported_bus_mode;\r\nspeed = slot->supported_speed;\r\nibmphp_unlock_operations();\r\nswitch (speed) {\r\ncase BUS_SPEED_33:\r\nbreak;\r\ncase BUS_SPEED_66:\r\nif (mode == BUS_MODE_PCIX)\r\nspeed += 0x01;\r\nbreak;\r\ncase BUS_SPEED_100:\r\ncase BUS_SPEED_133:\r\nspeed += 0x01;\r\nbreak;\r\ndefault:\r\nrc = -ENODEV;\r\n}\r\nif (!rc)\r\nbus->max_bus_speed = speed;\r\ndebug("%s - Exit rc[%d] speed[%x]\n", __func__, rc, speed);\r\nreturn rc;\r\n}\r\nstatic int __init init_ops(void)\r\n{\r\nstruct slot *slot_cur;\r\nstruct list_head *tmp;\r\nint retval;\r\nint rc;\r\nlist_for_each(tmp, &ibmphp_slot_head) {\r\nslot_cur = list_entry(tmp, struct slot, ibm_slot_list);\r\nif (!slot_cur)\r\nreturn -ENODEV;\r\ndebug("BEFORE GETTING SLOT STATUS, slot # %x\n",\r\nslot_cur->number);\r\nif (slot_cur->ctrl->revision == 0xFF)\r\nif (get_ctrl_revision(slot_cur,\r\n&slot_cur->ctrl->revision))\r\nreturn -1;\r\nif (slot_cur->bus_on->current_speed == 0xFF)\r\nif (get_cur_bus_info(&slot_cur))\r\nreturn -1;\r\nget_max_bus_speed(slot_cur);\r\nif (slot_cur->ctrl->options == 0xFF)\r\nif (get_hpc_options(slot_cur, &slot_cur->ctrl->options))\r\nreturn -1;\r\nretval = slot_update(&slot_cur);\r\nif (retval)\r\nreturn retval;\r\ndebug("status = %x\n", slot_cur->status);\r\ndebug("ext_status = %x\n", slot_cur->ext_status);\r\ndebug("SLOT_POWER = %x\n", SLOT_POWER(slot_cur->status));\r\ndebug("SLOT_PRESENT = %x\n", SLOT_PRESENT(slot_cur->status));\r\ndebug("SLOT_LATCH = %x\n", SLOT_LATCH(slot_cur->status));\r\nif ((SLOT_PWRGD(slot_cur->status)) &&\r\n!(SLOT_PRESENT(slot_cur->status)) &&\r\n!(SLOT_LATCH(slot_cur->status))) {\r\ndebug("BEFORE POWER OFF COMMAND\n");\r\nrc = power_off(slot_cur);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\ninit_flag = 0;\r\nreturn 0;\r\n}\r\nstatic int validate(struct slot *slot_cur, int opn)\r\n{\r\nint number;\r\nint retval;\r\nif (!slot_cur)\r\nreturn -ENODEV;\r\nnumber = slot_cur->number;\r\nif ((number > max_slots) || (number < 0))\r\nreturn -EBADSLT;\r\ndebug("slot_number in validate is %d\n", slot_cur->number);\r\nretval = slot_update(&slot_cur);\r\nif (retval)\r\nreturn retval;\r\nswitch (opn) {\r\ncase ENABLE:\r\nif (!(SLOT_PWRGD(slot_cur->status)) &&\r\n(SLOT_PRESENT(slot_cur->status)) &&\r\n!(SLOT_LATCH(slot_cur->status)))\r\nreturn 0;\r\nbreak;\r\ncase DISABLE:\r\nif ((SLOT_PWRGD(slot_cur->status)) &&\r\n(SLOT_PRESENT(slot_cur->status)) &&\r\n!(SLOT_LATCH(slot_cur->status)))\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr("validate failed....\n");\r\nreturn -EINVAL;\r\n}\r\nint ibmphp_update_slot_info(struct slot *slot_cur)\r\n{\r\nstruct hotplug_slot_info *info;\r\nstruct pci_bus *bus = slot_cur->hotplug_slot->pci_slot->bus;\r\nint rc;\r\nu8 bus_speed;\r\nu8 mode;\r\ninfo = kmalloc(sizeof(struct hotplug_slot_info), GFP_KERNEL);\r\nif (!info) {\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->power_status = SLOT_PWRGD(slot_cur->status);\r\ninfo->attention_status = SLOT_ATTN(slot_cur->status,\r\nslot_cur->ext_status);\r\ninfo->latch_status = SLOT_LATCH(slot_cur->status);\r\nif (!SLOT_PRESENT(slot_cur->status)) {\r\ninfo->adapter_status = 0;\r\n} else {\r\ninfo->adapter_status = 1;\r\n}\r\nbus_speed = slot_cur->bus_on->current_speed;\r\nmode = slot_cur->bus_on->current_bus_mode;\r\nswitch (bus_speed) {\r\ncase BUS_SPEED_33:\r\nbreak;\r\ncase BUS_SPEED_66:\r\nif (mode == BUS_MODE_PCIX)\r\nbus_speed += 0x01;\r\nelse if (mode == BUS_MODE_PCI)\r\n;\r\nelse\r\nbus_speed = PCI_SPEED_UNKNOWN;\r\nbreak;\r\ncase BUS_SPEED_100:\r\ncase BUS_SPEED_133:\r\nbus_speed += 0x01;\r\nbreak;\r\ndefault:\r\nbus_speed = PCI_SPEED_UNKNOWN;\r\n}\r\nbus->cur_bus_speed = bus_speed;\r\nrc = pci_hp_change_slot_info(slot_cur->hotplug_slot, info);\r\nkfree(info);\r\nreturn rc;\r\n}\r\nstatic struct pci_func *ibm_slot_find(u8 busno, u8 device, u8 function)\r\n{\r\nstruct pci_func *func_cur;\r\nstruct slot *slot_cur;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, &ibmphp_slot_head) {\r\nslot_cur = list_entry(tmp, struct slot, ibm_slot_list);\r\nif (slot_cur->func) {\r\nfunc_cur = slot_cur->func;\r\nwhile (func_cur) {\r\nif ((func_cur->busno == busno) &&\r\n(func_cur->device == device) &&\r\n(func_cur->function == function))\r\nreturn func_cur;\r\nfunc_cur = func_cur->next;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void free_slots(void)\r\n{\r\nstruct slot *slot_cur;\r\nstruct list_head *tmp;\r\nstruct list_head *next;\r\ndebug("%s -- enter\n", __func__);\r\nlist_for_each_safe(tmp, next, &ibmphp_slot_head) {\r\nslot_cur = list_entry(tmp, struct slot, ibm_slot_list);\r\npci_hp_deregister(slot_cur->hotplug_slot);\r\n}\r\ndebug("%s -- exit\n", __func__);\r\n}\r\nstatic void ibm_unconfigure_device(struct pci_func *func)\r\n{\r\nstruct pci_dev *temp;\r\nu8 j;\r\ndebug("inside %s\n", __func__);\r\ndebug("func->device = %x, func->function = %x\n",\r\nfunc->device, func->function);\r\ndebug("func->device << 3 | 0x0 = %x\n", func->device << 3 | 0x0);\r\npci_lock_rescan_remove();\r\nfor (j = 0; j < 0x08; j++) {\r\ntemp = pci_get_bus_and_slot(func->busno, (func->device << 3) | j);\r\nif (temp) {\r\npci_stop_and_remove_bus_device(temp);\r\npci_dev_put(temp);\r\n}\r\n}\r\npci_dev_put(func->dev);\r\npci_unlock_rescan_remove();\r\n}\r\nstatic u8 bus_structure_fixup(u8 busno)\r\n{\r\nstruct pci_bus *bus, *b;\r\nstruct pci_dev *dev;\r\nu16 l;\r\nif (pci_find_bus(0, busno) || !(ibmphp_find_same_bus_num(busno)))\r\nreturn 1;\r\nbus = kmalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus) {\r\nerr("%s - out of memory\n", __func__);\r\nreturn 1;\r\n}\r\ndev = kmalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nkfree(bus);\r\nerr("%s - out of memory\n", __func__);\r\nreturn 1;\r\n}\r\nbus->number = busno;\r\nbus->ops = ibmphp_pci_bus->ops;\r\ndev->bus = bus;\r\nfor (dev->devfn = 0; dev->devfn < 256; dev->devfn += 8) {\r\nif (!pci_read_config_word(dev, PCI_VENDOR_ID, &l) &&\r\n(l != 0x0000) && (l != 0xffff)) {\r\ndebug("%s - Inside bus_structure_fixup()\n",\r\n__func__);\r\nb = pci_scan_bus(busno, ibmphp_pci_bus->ops, NULL);\r\nif (!b)\r\ncontinue;\r\npci_bus_add_devices(b);\r\nbreak;\r\n}\r\n}\r\nkfree(dev);\r\nkfree(bus);\r\nreturn 0;\r\n}\r\nstatic int ibm_configure_device(struct pci_func *func)\r\n{\r\nstruct pci_bus *child;\r\nint num;\r\nint flag = 0;\r\npci_lock_rescan_remove();\r\nif (!(bus_structure_fixup(func->busno)))\r\nflag = 1;\r\nif (func->dev == NULL)\r\nfunc->dev = pci_get_bus_and_slot(func->busno,\r\nPCI_DEVFN(func->device, func->function));\r\nif (func->dev == NULL) {\r\nstruct pci_bus *bus = pci_find_bus(0, func->busno);\r\nif (!bus)\r\ngoto out;\r\nnum = pci_scan_slot(bus,\r\nPCI_DEVFN(func->device, func->function));\r\nif (num)\r\npci_bus_add_devices(bus);\r\nfunc->dev = pci_get_bus_and_slot(func->busno,\r\nPCI_DEVFN(func->device, func->function));\r\nif (func->dev == NULL) {\r\nerr("ERROR... : pci_dev still NULL\n");\r\ngoto out;\r\n}\r\n}\r\nif (!(flag) && (func->dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)) {\r\npci_hp_add_bridge(func->dev);\r\nchild = func->dev->subordinate;\r\nif (child)\r\npci_bus_add_devices(child);\r\n}\r\nout:\r\npci_unlock_rescan_remove();\r\nreturn 0;\r\n}\r\nstatic int is_bus_empty(struct slot *slot_cur)\r\n{\r\nint rc;\r\nstruct slot *tmp_slot;\r\nu8 i = slot_cur->bus_on->slot_min;\r\nwhile (i <= slot_cur->bus_on->slot_max) {\r\nif (i == slot_cur->number) {\r\ni++;\r\ncontinue;\r\n}\r\ntmp_slot = ibmphp_get_slot_from_physical_num(i);\r\nif (!tmp_slot)\r\nreturn 0;\r\nrc = slot_update(&tmp_slot);\r\nif (rc)\r\nreturn 0;\r\nif (SLOT_PRESENT(tmp_slot->status) &&\r\nSLOT_PWRGD(tmp_slot->status))\r\nreturn 0;\r\ni++;\r\n}\r\nreturn 1;\r\n}\r\nstatic int set_bus(struct slot *slot_cur)\r\n{\r\nint rc;\r\nu8 speed;\r\nu8 cmd = 0x0;\r\nint retval;\r\nstatic struct pci_device_id ciobx[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS, 0x0101) },\r\n{ },\r\n};\r\ndebug("%s - entry slot # %d\n", __func__, slot_cur->number);\r\nif (SET_BUS_STATUS(slot_cur->ctrl) && is_bus_empty(slot_cur)) {\r\nrc = slot_update(&slot_cur);\r\nif (rc)\r\nreturn rc;\r\nspeed = SLOT_SPEED(slot_cur->ext_status);\r\ndebug("ext_status = %x, speed = %x\n", slot_cur->ext_status, speed);\r\nswitch (speed) {\r\ncase HPC_SLOT_SPEED_33:\r\ncmd = HPC_BUS_33CONVMODE;\r\nbreak;\r\ncase HPC_SLOT_SPEED_66:\r\nif (SLOT_PCIX(slot_cur->ext_status)) {\r\nif ((slot_cur->supported_speed >= BUS_SPEED_66) &&\r\n(slot_cur->supported_bus_mode == BUS_MODE_PCIX))\r\ncmd = HPC_BUS_66PCIXMODE;\r\nelse if (!SLOT_BUS_MODE(slot_cur->ext_status))\r\ncmd = HPC_BUS_66CONVMODE;\r\nelse\r\ncmd = HPC_BUS_33CONVMODE;\r\n} else {\r\nif (slot_cur->supported_speed >= BUS_SPEED_66)\r\ncmd = HPC_BUS_66CONVMODE;\r\nelse\r\ncmd = HPC_BUS_33CONVMODE;\r\n}\r\nbreak;\r\ncase HPC_SLOT_SPEED_133:\r\nswitch (slot_cur->supported_speed) {\r\ncase BUS_SPEED_33:\r\ncmd = HPC_BUS_33CONVMODE;\r\nbreak;\r\ncase BUS_SPEED_66:\r\nif (slot_cur->supported_bus_mode == BUS_MODE_PCIX)\r\ncmd = HPC_BUS_66PCIXMODE;\r\nelse\r\ncmd = HPC_BUS_66CONVMODE;\r\nbreak;\r\ncase BUS_SPEED_100:\r\ncmd = HPC_BUS_100PCIXMODE;\r\nbreak;\r\ncase BUS_SPEED_133:\r\nif (pci_dev_present(ciobx))\r\nibmphp_hpc_writeslot(slot_cur,\r\nHPC_BUS_100PCIXMODE);\r\ncmd = HPC_BUS_133PCIXMODE;\r\nbreak;\r\ndefault:\r\nerr("Wrong bus speed\n");\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ndefault:\r\nerr("wrong slot speed\n");\r\nreturn -ENODEV;\r\n}\r\ndebug("setting bus speed for slot %d, cmd %x\n",\r\nslot_cur->number, cmd);\r\nretval = ibmphp_hpc_writeslot(slot_cur, cmd);\r\nif (retval) {\r\nerr("setting bus speed failed\n");\r\nreturn retval;\r\n}\r\nif (CTLR_RESULT(slot_cur->ctrl->status)) {\r\nerr("command not completed successfully in set_bus\n");\r\nreturn -EIO;\r\n}\r\n}\r\nmsleep(1000);\r\ndebug("%s -Exit\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int check_limitations(struct slot *slot_cur)\r\n{\r\nu8 i;\r\nstruct slot *tmp_slot;\r\nu8 count = 0;\r\nu8 limitation = 0;\r\nfor (i = slot_cur->bus_on->slot_min; i <= slot_cur->bus_on->slot_max; i++) {\r\ntmp_slot = ibmphp_get_slot_from_physical_num(i);\r\nif (!tmp_slot)\r\nreturn -ENODEV;\r\nif ((SLOT_PWRGD(tmp_slot->status)) &&\r\n!(SLOT_CONNECT(tmp_slot->status)))\r\ncount++;\r\n}\r\nget_cur_bus_info(&slot_cur);\r\nswitch (slot_cur->bus_on->current_speed) {\r\ncase BUS_SPEED_33:\r\nlimitation = slot_cur->bus_on->slots_at_33_conv;\r\nbreak;\r\ncase BUS_SPEED_66:\r\nif (slot_cur->bus_on->current_bus_mode == BUS_MODE_PCIX)\r\nlimitation = slot_cur->bus_on->slots_at_66_pcix;\r\nelse\r\nlimitation = slot_cur->bus_on->slots_at_66_conv;\r\nbreak;\r\ncase BUS_SPEED_100:\r\nlimitation = slot_cur->bus_on->slots_at_100_pcix;\r\nbreak;\r\ncase BUS_SPEED_133:\r\nlimitation = slot_cur->bus_on->slots_at_133_pcix;\r\nbreak;\r\n}\r\nif ((count + 1) > limitation)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void print_card_capability(struct slot *slot_cur)\r\n{\r\ninfo("capability of the card is ");\r\nif ((slot_cur->ext_status & CARD_INFO) == PCIX133)\r\ninfo(" 133 MHz PCI-X\n");\r\nelse if ((slot_cur->ext_status & CARD_INFO) == PCIX66)\r\ninfo(" 66 MHz PCI-X\n");\r\nelse if ((slot_cur->ext_status & CARD_INFO) == PCI66)\r\ninfo(" 66 MHz PCI\n");\r\nelse\r\ninfo(" 33 MHz PCI\n");\r\n}\r\nstatic int enable_slot(struct hotplug_slot *hs)\r\n{\r\nint rc, i, rcpr;\r\nstruct slot *slot_cur;\r\nu8 function;\r\nstruct pci_func *tmp_func;\r\nibmphp_lock_operations();\r\ndebug("ENABLING SLOT........\n");\r\nslot_cur = hs->private;\r\nrc = validate(slot_cur, ENABLE);\r\nif (rc) {\r\nerr("validate function failed\n");\r\ngoto error_nopower;\r\n}\r\nattn_LED_blink(slot_cur);\r\nrc = set_bus(slot_cur);\r\nif (rc) {\r\nerr("was not able to set the bus\n");\r\ngoto error_nopower;\r\n}\r\nget_cur_bus_info(&slot_cur);\r\ndebug("the current bus speed right after set_bus = %x\n",\r\nslot_cur->bus_on->current_speed);\r\nrc = check_limitations(slot_cur);\r\nif (rc) {\r\nerr("Adding this card exceeds the limitations of this bus.\n");\r\nerr("(i.e., >1 133MHz cards running on same bus, or >2 66 PCI cards running on same bus.\n");\r\nerr("Try hot-adding into another bus\n");\r\nrc = -EINVAL;\r\ngoto error_nopower;\r\n}\r\nrc = power_on(slot_cur);\r\nif (rc) {\r\nerr("something wrong when powering up... please see below for details\n");\r\nattn_off(slot_cur);\r\nattn_on(slot_cur);\r\nif (slot_update(&slot_cur)) {\r\nattn_off(slot_cur);\r\nattn_on(slot_cur);\r\nrc = -ENODEV;\r\ngoto exit;\r\n}\r\nif ((SLOT_POWER(slot_cur->status)) &&\r\n!(SLOT_PWRGD(slot_cur->status)))\r\nerr("power fault occurred trying to power up\n");\r\nelse if (SLOT_BUS_SPEED(slot_cur->status)) {\r\nerr("bus speed mismatch occurred. please check current bus speed and card capability\n");\r\nprint_card_capability(slot_cur);\r\n} else if (SLOT_BUS_MODE(slot_cur->ext_status)) {\r\nerr("bus mode mismatch occurred. please check current bus mode and card capability\n");\r\nprint_card_capability(slot_cur);\r\n}\r\nibmphp_update_slot_info(slot_cur);\r\ngoto exit;\r\n}\r\ndebug("after power_on\n");\r\nget_cur_bus_info(&slot_cur);\r\ndebug("the current bus speed right after power_on = %x\n",\r\nslot_cur->bus_on->current_speed);\r\nrc = slot_update(&slot_cur);\r\nif (rc)\r\ngoto error_power;\r\nrc = -EINVAL;\r\nif (SLOT_POWER(slot_cur->status) && !(SLOT_PWRGD(slot_cur->status))) {\r\nerr("power fault occurred trying to power up...\n");\r\ngoto error_power;\r\n}\r\nif (SLOT_POWER(slot_cur->status) && (SLOT_BUS_SPEED(slot_cur->status))) {\r\nerr("bus speed mismatch occurred. please check current bus speed and card capability\n");\r\nprint_card_capability(slot_cur);\r\ngoto error_power;\r\n}\r\nif (!(SLOT_POWER(slot_cur->status))) {\r\nerr("power on failed...\n");\r\ngoto error_power;\r\n}\r\nslot_cur->func = kzalloc(sizeof(struct pci_func), GFP_KERNEL);\r\nif (!slot_cur->func) {\r\nerr("out of system memory\n");\r\nrc = -ENOMEM;\r\ngoto error_power;\r\n}\r\nslot_cur->func->busno = slot_cur->bus;\r\nslot_cur->func->device = slot_cur->device;\r\nfor (i = 0; i < 4; i++)\r\nslot_cur->func->irq[i] = slot_cur->irq[i];\r\ndebug("b4 configure_card, slot_cur->bus = %x, slot_cur->device = %x\n",\r\nslot_cur->bus, slot_cur->device);\r\nif (ibmphp_configure_card(slot_cur->func, slot_cur->number)) {\r\nerr("configure_card was unsuccessful...\n");\r\nibmphp_unconfigure_card(&slot_cur, 1);\r\ndebug("after unconfigure_card\n");\r\nslot_cur->func = NULL;\r\nrc = -ENOMEM;\r\ngoto error_power;\r\n}\r\nfunction = 0x00;\r\ndo {\r\ntmp_func = ibm_slot_find(slot_cur->bus, slot_cur->func->device,\r\nfunction++);\r\nif (tmp_func && !(tmp_func->dev))\r\nibm_configure_device(tmp_func);\r\n} while (tmp_func);\r\nattn_off(slot_cur);\r\nif (slot_update(&slot_cur)) {\r\nrc = -EFAULT;\r\ngoto exit;\r\n}\r\nibmphp_print_test();\r\nrc = ibmphp_update_slot_info(slot_cur);\r\nexit:\r\nibmphp_unlock_operations();\r\nreturn rc;\r\nerror_nopower:\r\nattn_off(slot_cur);\r\nattn_on(slot_cur);\r\nerror_cont:\r\nrcpr = slot_update(&slot_cur);\r\nif (rcpr) {\r\nrc = rcpr;\r\ngoto exit;\r\n}\r\nibmphp_update_slot_info(slot_cur);\r\ngoto exit;\r\nerror_power:\r\nattn_off(slot_cur);\r\nattn_on(slot_cur);\r\nrcpr = power_off(slot_cur);\r\nif (rcpr) {\r\nrc = rcpr;\r\ngoto exit;\r\n}\r\ngoto error_cont;\r\n}\r\nstatic int ibmphp_disable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nint rc;\r\nibmphp_lock_operations();\r\nrc = ibmphp_do_disable_slot(slot);\r\nibmphp_unlock_operations();\r\nreturn rc;\r\n}\r\nint ibmphp_do_disable_slot(struct slot *slot_cur)\r\n{\r\nint rc;\r\nu8 flag;\r\ndebug("DISABLING SLOT...\n");\r\nif ((slot_cur == NULL) || (slot_cur->ctrl == NULL))\r\nreturn -ENODEV;\r\nflag = slot_cur->flag;\r\nslot_cur->flag = 1;\r\nif (flag == 1) {\r\nrc = validate(slot_cur, DISABLE);\r\nif (rc)\r\ngoto error;\r\n}\r\nattn_LED_blink(slot_cur);\r\nif (slot_cur->func == NULL) {\r\nslot_cur->func = kzalloc(sizeof(struct pci_func), GFP_KERNEL);\r\nif (!slot_cur->func) {\r\nerr("out of system memory\n");\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nslot_cur->func->busno = slot_cur->bus;\r\nslot_cur->func->device = slot_cur->device;\r\n}\r\nibm_unconfigure_device(slot_cur->func);\r\nif (!flag) {\r\nattn_off(slot_cur);\r\nreturn 0;\r\n}\r\nrc = ibmphp_unconfigure_card(&slot_cur, 0);\r\nslot_cur->func = NULL;\r\ndebug("in disable_slot. after unconfigure_card\n");\r\nif (rc) {\r\nerr("could not unconfigure card.\n");\r\ngoto error;\r\n}\r\nrc = ibmphp_hpc_writeslot(slot_cur, HPC_SLOT_OFF);\r\nif (rc)\r\ngoto error;\r\nattn_off(slot_cur);\r\nrc = slot_update(&slot_cur);\r\nif (rc)\r\ngoto exit;\r\nrc = ibmphp_update_slot_info(slot_cur);\r\nibmphp_print_test();\r\nexit:\r\nreturn rc;\r\nerror:\r\nattn_off(slot_cur);\r\nattn_on(slot_cur);\r\nif (slot_update(&slot_cur)) {\r\nrc = -EFAULT;\r\ngoto exit;\r\n}\r\nif (flag)\r\nibmphp_update_slot_info(slot_cur);\r\ngoto exit;\r\n}\r\nstatic void ibmphp_unload(void)\r\n{\r\nfree_slots();\r\ndebug("after slots\n");\r\nibmphp_free_resources();\r\ndebug("after resources\n");\r\nibmphp_free_bus_info_queue();\r\ndebug("after bus info\n");\r\nibmphp_free_ebda_hpc_queue();\r\ndebug("after ebda hpc\n");\r\nibmphp_free_ebda_pci_rsrc_queue();\r\ndebug("after ebda pci rsrc\n");\r\nkfree(ibmphp_pci_bus);\r\n}\r\nstatic int __init ibmphp_init(void)\r\n{\r\nstruct pci_bus *bus;\r\nint i = 0;\r\nint rc = 0;\r\ninit_flag = 1;\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nibmphp_pci_bus = kmalloc(sizeof(*ibmphp_pci_bus), GFP_KERNEL);\r\nif (!ibmphp_pci_bus) {\r\nerr("out of memory\n");\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\nbus = pci_find_bus(0, 0);\r\nif (!bus) {\r\nerr("Can't find the root pci bus, can not continue\n");\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\nmemcpy(ibmphp_pci_bus, bus, sizeof(*ibmphp_pci_bus));\r\nibmphp_debug = debug;\r\nibmphp_hpc_initvars();\r\nfor (i = 0; i < 16; i++)\r\nirqs[i] = 0;\r\nrc = ibmphp_access_ebda();\r\nif (rc)\r\ngoto error;\r\ndebug("after ibmphp_access_ebda()\n");\r\nrc = ibmphp_rsrc_init();\r\nif (rc)\r\ngoto error;\r\ndebug("AFTER Resource & EBDA INITIALIZATIONS\n");\r\nmax_slots = get_max_slots();\r\nrc = ibmphp_register_pci();\r\nif (rc)\r\ngoto error;\r\nif (init_ops()) {\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\nibmphp_print_test();\r\nrc = ibmphp_hpc_start_poll_thread();\r\nif (rc)\r\ngoto error;\r\nexit:\r\nreturn rc;\r\nerror:\r\nibmphp_unload();\r\ngoto exit;\r\n}\r\nstatic void __exit ibmphp_exit(void)\r\n{\r\nibmphp_hpc_stop_poll_thread();\r\ndebug("after polling\n");\r\nibmphp_unload();\r\ndebug("done\n");\r\n}
