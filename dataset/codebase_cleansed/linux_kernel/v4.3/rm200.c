static int __init snirm_setup_devinit(void)\r\n{\r\nif (sni_brd_type == SNI_BRD_RM200) {\r\nplatform_device_register(&rm200_serial8250_device);\r\nplatform_device_register(&rm200_ds1216_device);\r\nplatform_device_register(&snirm_82596_rm200_pdev);\r\nplatform_device_register(&snirm_53c710_rm200_pdev);\r\nsni_eisa_root_init();\r\n}\r\nreturn 0;\r\n}\r\nstatic void sni_rm200_disable_8259A_irq(struct irq_data *d)\r\n{\r\nunsigned int mask, irq = d->irq - RM200_I8259A_IRQ_BASE;\r\nunsigned long flags;\r\nmask = 1 << irq;\r\nraw_spin_lock_irqsave(&sni_rm200_i8259A_lock, flags);\r\nrm200_cached_irq_mask |= mask;\r\nif (irq & 8)\r\nwriteb(cached_slave_mask, rm200_pic_slave + PIC_IMR);\r\nelse\r\nwriteb(cached_master_mask, rm200_pic_master + PIC_IMR);\r\nraw_spin_unlock_irqrestore(&sni_rm200_i8259A_lock, flags);\r\n}\r\nstatic void sni_rm200_enable_8259A_irq(struct irq_data *d)\r\n{\r\nunsigned int mask, irq = d->irq - RM200_I8259A_IRQ_BASE;\r\nunsigned long flags;\r\nmask = ~(1 << irq);\r\nraw_spin_lock_irqsave(&sni_rm200_i8259A_lock, flags);\r\nrm200_cached_irq_mask &= mask;\r\nif (irq & 8)\r\nwriteb(cached_slave_mask, rm200_pic_slave + PIC_IMR);\r\nelse\r\nwriteb(cached_master_mask, rm200_pic_master + PIC_IMR);\r\nraw_spin_unlock_irqrestore(&sni_rm200_i8259A_lock, flags);\r\n}\r\nstatic inline int sni_rm200_i8259A_irq_real(unsigned int irq)\r\n{\r\nint value;\r\nint irqmask = 1 << irq;\r\nif (irq < 8) {\r\nwriteb(0x0B, rm200_pic_master + PIC_CMD);\r\nvalue = readb(rm200_pic_master + PIC_CMD) & irqmask;\r\nwriteb(0x0A, rm200_pic_master + PIC_CMD);\r\nreturn value;\r\n}\r\nwriteb(0x0B, rm200_pic_slave + PIC_CMD);\r\nvalue = readb(rm200_pic_slave + PIC_CMD) & (irqmask >> 8);\r\nwriteb(0x0A, rm200_pic_slave + PIC_CMD);\r\nreturn value;\r\n}\r\nvoid sni_rm200_mask_and_ack_8259A(struct irq_data *d)\r\n{\r\nunsigned int irqmask, irq = d->irq - RM200_I8259A_IRQ_BASE;\r\nunsigned long flags;\r\nirqmask = 1 << irq;\r\nraw_spin_lock_irqsave(&sni_rm200_i8259A_lock, flags);\r\nif (rm200_cached_irq_mask & irqmask)\r\ngoto spurious_8259A_irq;\r\nrm200_cached_irq_mask |= irqmask;\r\nhandle_real_irq:\r\nif (irq & 8) {\r\nreadb(rm200_pic_slave + PIC_IMR);\r\nwriteb(cached_slave_mask, rm200_pic_slave + PIC_IMR);\r\nwriteb(0x60+(irq & 7), rm200_pic_slave + PIC_CMD);\r\nwriteb(0x60+PIC_CASCADE_IR, rm200_pic_master + PIC_CMD);\r\n} else {\r\nreadb(rm200_pic_master + PIC_IMR);\r\nwriteb(cached_master_mask, rm200_pic_master + PIC_IMR);\r\nwriteb(0x60+irq, rm200_pic_master + PIC_CMD);\r\n}\r\nraw_spin_unlock_irqrestore(&sni_rm200_i8259A_lock, flags);\r\nreturn;\r\nspurious_8259A_irq:\r\nif (sni_rm200_i8259A_irq_real(irq))\r\ngoto handle_real_irq;\r\n{\r\nstatic int spurious_irq_mask;\r\nif (!(spurious_irq_mask & irqmask)) {\r\nprintk(KERN_DEBUG\r\n"spurious RM200 8259A interrupt: IRQ%d.\n", irq);\r\nspurious_irq_mask |= irqmask;\r\n}\r\natomic_inc(&irq_err_count);\r\ngoto handle_real_irq;\r\n}\r\n}\r\nstatic inline int sni_rm200_i8259_irq(void)\r\n{\r\nint irq;\r\nraw_spin_lock(&sni_rm200_i8259A_lock);\r\nwriteb(0x0C, rm200_pic_master + PIC_CMD);\r\nirq = readb(rm200_pic_master + PIC_CMD) & 7;\r\nif (irq == PIC_CASCADE_IR) {\r\nwriteb(0x0C, rm200_pic_slave + PIC_CMD);\r\nirq = (readb(rm200_pic_slave + PIC_CMD) & 7) + 8;\r\n}\r\nif (unlikely(irq == 7)) {\r\nwriteb(0x0B, rm200_pic_master + PIC_ISR);\r\nif (~readb(rm200_pic_master + PIC_ISR) & 0x80)\r\nirq = -1;\r\n}\r\nraw_spin_unlock(&sni_rm200_i8259A_lock);\r\nreturn likely(irq >= 0) ? irq + RM200_I8259A_IRQ_BASE : irq;\r\n}\r\nvoid sni_rm200_init_8259A(void)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sni_rm200_i8259A_lock, flags);\r\nwriteb(0xff, rm200_pic_master + PIC_IMR);\r\nwriteb(0xff, rm200_pic_slave + PIC_IMR);\r\nwriteb(0x11, rm200_pic_master + PIC_CMD);\r\nwriteb(0, rm200_pic_master + PIC_IMR);\r\nwriteb(1U << PIC_CASCADE_IR, rm200_pic_master + PIC_IMR);\r\nwriteb(MASTER_ICW4_DEFAULT, rm200_pic_master + PIC_IMR);\r\nwriteb(0x11, rm200_pic_slave + PIC_CMD);\r\nwriteb(8, rm200_pic_slave + PIC_IMR);\r\nwriteb(PIC_CASCADE_IR, rm200_pic_slave + PIC_IMR);\r\nwriteb(SLAVE_ICW4_DEFAULT, rm200_pic_slave + PIC_IMR);\r\nudelay(100);\r\nwriteb(cached_master_mask, rm200_pic_master + PIC_IMR);\r\nwriteb(cached_slave_mask, rm200_pic_slave + PIC_IMR);\r\nraw_spin_unlock_irqrestore(&sni_rm200_i8259A_lock, flags);\r\n}\r\nstatic irqreturn_t sni_rm200_i8259A_irq_handler(int dummy, void *p)\r\n{\r\nint irq;\r\nirq = sni_rm200_i8259_irq();\r\nif (unlikely(irq < 0))\r\nreturn IRQ_NONE;\r\ndo_IRQ(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init sni_rm200_i8259_irqs(void)\r\n{\r\nint i;\r\nrm200_pic_master = ioremap_nocache(0x16000020, 4);\r\nif (!rm200_pic_master)\r\nreturn;\r\nrm200_pic_slave = ioremap_nocache(0x160000a0, 4);\r\nif (!rm200_pic_slave) {\r\niounmap(rm200_pic_master);\r\nreturn;\r\n}\r\ninsert_resource(&iomem_resource, &sni_rm200_pic1_resource);\r\ninsert_resource(&iomem_resource, &sni_rm200_pic2_resource);\r\nsni_rm200_init_8259A();\r\nfor (i = RM200_I8259A_IRQ_BASE; i < RM200_I8259A_IRQ_BASE + 16; i++)\r\nirq_set_chip_and_handler(i, &sni_rm200_i8259A_chip,\r\nhandle_level_irq);\r\nsetup_irq(RM200_I8259A_IRQ_BASE + PIC_CASCADE_IR, &sni_rm200_irq2);\r\n}\r\nstatic void enable_rm200_irq(struct irq_data *d)\r\n{\r\nunsigned int mask = 1 << (d->irq - SNI_RM200_INT_START);\r\n*(volatile u8 *)SNI_RM200_INT_ENA_REG &= ~mask;\r\n}\r\nvoid disable_rm200_irq(struct irq_data *d)\r\n{\r\nunsigned int mask = 1 << (d->irq - SNI_RM200_INT_START);\r\n*(volatile u8 *)SNI_RM200_INT_ENA_REG |= mask;\r\n}\r\nstatic void sni_rm200_hwint(void)\r\n{\r\nu32 pending = read_c0_cause() & read_c0_status();\r\nu8 mask;\r\nu8 stat;\r\nint irq;\r\nif (pending & C_IRQ5)\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + 7);\r\nelse if (pending & C_IRQ0) {\r\nclear_c0_status(IE_IRQ0);\r\nmask = *(volatile u8 *)SNI_RM200_INT_ENA_REG ^ 0x1f;\r\nstat = *(volatile u8 *)SNI_RM200_INT_STAT_REG ^ 0x14;\r\nirq = ffs(stat & mask & 0x1f);\r\nif (likely(irq > 0))\r\ndo_IRQ(irq + SNI_RM200_INT_START - 1);\r\nset_c0_status(IE_IRQ0);\r\n}\r\n}\r\nvoid __init sni_rm200_irq_init(void)\r\n{\r\nint i;\r\n* (volatile u8 *)SNI_RM200_INT_ENA_REG = 0x1f;\r\nsni_rm200_i8259_irqs();\r\nmips_cpu_irq_init();\r\nfor (i = SNI_RM200_INT_START; i <= SNI_RM200_INT_END; i++)\r\nirq_set_chip_and_handler(i, &rm200_irq_type, handle_level_irq);\r\nsni_hwint = sni_rm200_hwint;\r\nchange_c0_status(ST0_IM, IE_IRQ0);\r\nsetup_irq(SNI_RM200_INT_START + 0, &sni_rm200_i8259A_irq);\r\nsetup_irq(SNI_RM200_INT_START + 1, &sni_isa_irq);\r\n}\r\nvoid __init sni_rm200_init(void)\r\n{\r\n}
