void xs_init(pTHX)\r\n{\r\nconst char *file = __FILE__;\r\ndXSUB_SYS;\r\nnewXS("Perf::Trace::Context::bootstrap", boot_Perf__Trace__Context,\r\nfile);\r\nnewXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);\r\n}\r\nstatic void define_symbolic_value(const char *ev_name,\r\nconst char *field_name,\r\nconst char *field_value,\r\nconst char *field_str)\r\n{\r\nunsigned long long value;\r\ndSP;\r\nvalue = eval_flag(field_value);\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\r\nXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\r\nXPUSHs(sv_2mortal(newSVuv(value)));\r\nXPUSHs(sv_2mortal(newSVpv(field_str, 0)));\r\nPUTBACK;\r\nif (get_cv("main::define_symbolic_value", 0))\r\ncall_pv("main::define_symbolic_value", G_SCALAR);\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void define_symbolic_values(struct print_flag_sym *field,\r\nconst char *ev_name,\r\nconst char *field_name)\r\n{\r\ndefine_symbolic_value(ev_name, field_name, field->value, field->str);\r\nif (field->next)\r\ndefine_symbolic_values(field->next, ev_name, field_name);\r\n}\r\nstatic void define_symbolic_field(const char *ev_name,\r\nconst char *field_name)\r\n{\r\ndSP;\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\r\nXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\r\nPUTBACK;\r\nif (get_cv("main::define_symbolic_field", 0))\r\ncall_pv("main::define_symbolic_field", G_SCALAR);\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void define_flag_value(const char *ev_name,\r\nconst char *field_name,\r\nconst char *field_value,\r\nconst char *field_str)\r\n{\r\nunsigned long long value;\r\ndSP;\r\nvalue = eval_flag(field_value);\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\r\nXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\r\nXPUSHs(sv_2mortal(newSVuv(value)));\r\nXPUSHs(sv_2mortal(newSVpv(field_str, 0)));\r\nPUTBACK;\r\nif (get_cv("main::define_flag_value", 0))\r\ncall_pv("main::define_flag_value", G_SCALAR);\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void define_flag_values(struct print_flag_sym *field,\r\nconst char *ev_name,\r\nconst char *field_name)\r\n{\r\ndefine_flag_value(ev_name, field_name, field->value, field->str);\r\nif (field->next)\r\ndefine_flag_values(field->next, ev_name, field_name);\r\n}\r\nstatic void define_flag_field(const char *ev_name,\r\nconst char *field_name,\r\nconst char *delim)\r\n{\r\ndSP;\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpv(ev_name, 0)));\r\nXPUSHs(sv_2mortal(newSVpv(field_name, 0)));\r\nXPUSHs(sv_2mortal(newSVpv(delim, 0)));\r\nPUTBACK;\r\nif (get_cv("main::define_flag_field", 0))\r\ncall_pv("main::define_flag_field", G_SCALAR);\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void define_event_symbols(struct event_format *event,\r\nconst char *ev_name,\r\nstruct print_arg *args)\r\n{\r\nswitch (args->type) {\r\ncase PRINT_NULL:\r\nbreak;\r\ncase PRINT_ATOM:\r\ndefine_flag_value(ev_name, cur_field_name, "0",\r\nargs->atom.atom);\r\nzero_flag_atom = 0;\r\nbreak;\r\ncase PRINT_FIELD:\r\nfree(cur_field_name);\r\ncur_field_name = strdup(args->field.name);\r\nbreak;\r\ncase PRINT_FLAGS:\r\ndefine_event_symbols(event, ev_name, args->flags.field);\r\ndefine_flag_field(ev_name, cur_field_name, args->flags.delim);\r\ndefine_flag_values(args->flags.flags, ev_name, cur_field_name);\r\nbreak;\r\ncase PRINT_SYMBOL:\r\ndefine_event_symbols(event, ev_name, args->symbol.field);\r\ndefine_symbolic_field(ev_name, cur_field_name);\r\ndefine_symbolic_values(args->symbol.symbols, ev_name,\r\ncur_field_name);\r\nbreak;\r\ncase PRINT_HEX:\r\ndefine_event_symbols(event, ev_name, args->hex.field);\r\ndefine_event_symbols(event, ev_name, args->hex.size);\r\nbreak;\r\ncase PRINT_INT_ARRAY:\r\ndefine_event_symbols(event, ev_name, args->int_array.field);\r\ndefine_event_symbols(event, ev_name, args->int_array.count);\r\ndefine_event_symbols(event, ev_name, args->int_array.el_size);\r\nbreak;\r\ncase PRINT_BSTRING:\r\ncase PRINT_DYNAMIC_ARRAY:\r\ncase PRINT_STRING:\r\ncase PRINT_BITMASK:\r\nbreak;\r\ncase PRINT_TYPE:\r\ndefine_event_symbols(event, ev_name, args->typecast.item);\r\nbreak;\r\ncase PRINT_OP:\r\nif (strcmp(args->op.op, ":") == 0)\r\nzero_flag_atom = 1;\r\ndefine_event_symbols(event, ev_name, args->op.left);\r\ndefine_event_symbols(event, ev_name, args->op.right);\r\nbreak;\r\ncase PRINT_FUNC:\r\ndefault:\r\npr_err("Unsupported print arg type\n");\r\nreturn;\r\n}\r\nif (args->next)\r\ndefine_event_symbols(event, ev_name, args->next);\r\n}\r\nstatic void perl_process_tracepoint(struct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct thread *thread)\r\n{\r\nstruct event_format *event = evsel->tp_format;\r\nstruct format_field *field;\r\nstatic char handler[256];\r\nunsigned long long val;\r\nunsigned long s, ns;\r\nint pid;\r\nint cpu = sample->cpu;\r\nvoid *data = sample->raw_data;\r\nunsigned long long nsecs = sample->time;\r\nconst char *comm = thread__comm_str(thread);\r\ndSP;\r\nif (evsel->attr.type != PERF_TYPE_TRACEPOINT)\r\nreturn;\r\nif (!event)\r\ndie("ug! no event found for type %" PRIu64, (u64)evsel->attr.config);\r\npid = raw_field_value(event, "common_pid", data);\r\nsprintf(handler, "%s::%s", event->system, event->name);\r\nif (!test_and_set_bit(event->id, events_defined))\r\ndefine_event_symbols(event, handler, event->print_fmt.args);\r\ns = nsecs / NSECS_PER_SEC;\r\nns = nsecs - s * NSECS_PER_SEC;\r\nscripting_context->event_data = data;\r\nscripting_context->pevent = evsel->tp_format->pevent;\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpv(handler, 0)));\r\nXPUSHs(sv_2mortal(newSViv(PTR2IV(scripting_context))));\r\nXPUSHs(sv_2mortal(newSVuv(cpu)));\r\nXPUSHs(sv_2mortal(newSVuv(s)));\r\nXPUSHs(sv_2mortal(newSVuv(ns)));\r\nXPUSHs(sv_2mortal(newSViv(pid)));\r\nXPUSHs(sv_2mortal(newSVpv(comm, 0)));\r\nfor (field = event->format.fields; field; field = field->next) {\r\nif (field->flags & FIELD_IS_STRING) {\r\nint offset;\r\nif (field->flags & FIELD_IS_DYNAMIC) {\r\noffset = *(int *)(data + field->offset);\r\noffset &= 0xffff;\r\n} else\r\noffset = field->offset;\r\nXPUSHs(sv_2mortal(newSVpv((char *)data + offset, 0)));\r\n} else {\r\nval = read_size(event, data + field->offset,\r\nfield->size);\r\nif (field->flags & FIELD_IS_SIGNED) {\r\nXPUSHs(sv_2mortal(newSViv(val)));\r\n} else {\r\nXPUSHs(sv_2mortal(newSVuv(val)));\r\n}\r\n}\r\n}\r\nPUTBACK;\r\nif (get_cv(handler, 0))\r\ncall_pv(handler, G_SCALAR);\r\nelse if (get_cv("main::trace_unhandled", 0)) {\r\nXPUSHs(sv_2mortal(newSVpv(handler, 0)));\r\nXPUSHs(sv_2mortal(newSViv(PTR2IV(scripting_context))));\r\nXPUSHs(sv_2mortal(newSVuv(cpu)));\r\nXPUSHs(sv_2mortal(newSVuv(nsecs)));\r\nXPUSHs(sv_2mortal(newSViv(pid)));\r\nXPUSHs(sv_2mortal(newSVpv(comm, 0)));\r\ncall_pv("main::trace_unhandled", G_SCALAR);\r\n}\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void perl_process_event_generic(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel)\r\n{\r\ndSP;\r\nif (!get_cv("process_event", 0))\r\nreturn;\r\nENTER;\r\nSAVETMPS;\r\nPUSHMARK(SP);\r\nXPUSHs(sv_2mortal(newSVpvn((const char *)event, event->header.size)));\r\nXPUSHs(sv_2mortal(newSVpvn((const char *)&evsel->attr, sizeof(evsel->attr))));\r\nXPUSHs(sv_2mortal(newSVpvn((const char *)sample, sizeof(*sample))));\r\nXPUSHs(sv_2mortal(newSVpvn((const char *)sample->raw_data, sample->raw_size)));\r\nPUTBACK;\r\ncall_pv("process_event", G_SCALAR);\r\nSPAGAIN;\r\nPUTBACK;\r\nFREETMPS;\r\nLEAVE;\r\n}\r\nstatic void perl_process_event(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct addr_location *al)\r\n{\r\nperl_process_tracepoint(sample, evsel, al->thread);\r\nperl_process_event_generic(event, sample, evsel);\r\n}\r\nstatic void run_start_sub(void)\r\n{\r\ndSP;\r\nPUSHMARK(SP);\r\nif (get_cv("main::trace_begin", 0))\r\ncall_pv("main::trace_begin", G_DISCARD | G_NOARGS);\r\n}\r\nstatic int perl_start_script(const char *script, int argc, const char **argv)\r\n{\r\nconst char **command_line;\r\nint i, err = 0;\r\ncommand_line = malloc((argc + 2) * sizeof(const char *));\r\ncommand_line[0] = "";\r\ncommand_line[1] = script;\r\nfor (i = 2; i < argc + 2; i++)\r\ncommand_line[i] = argv[i - 2];\r\nmy_perl = perl_alloc();\r\nperl_construct(my_perl);\r\nif (perl_parse(my_perl, xs_init, argc + 2, (char **)command_line,\r\n(char **)NULL)) {\r\nerr = -1;\r\ngoto error;\r\n}\r\nif (perl_run(my_perl)) {\r\nerr = -1;\r\ngoto error;\r\n}\r\nif (SvTRUE(ERRSV)) {\r\nerr = -1;\r\ngoto error;\r\n}\r\nrun_start_sub();\r\nfree(command_line);\r\nreturn 0;\r\nerror:\r\nperl_free(my_perl);\r\nfree(command_line);\r\nreturn err;\r\n}\r\nstatic int perl_flush_script(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int perl_stop_script(void)\r\n{\r\ndSP;\r\nPUSHMARK(SP);\r\nif (get_cv("main::trace_end", 0))\r\ncall_pv("main::trace_end", G_DISCARD | G_NOARGS);\r\nperl_destruct(my_perl);\r\nperl_free(my_perl);\r\nreturn 0;\r\n}\r\nstatic int perl_generate_script(struct pevent *pevent, const char *outfile)\r\n{\r\nstruct event_format *event = NULL;\r\nstruct format_field *f;\r\nchar fname[PATH_MAX];\r\nint not_first, count;\r\nFILE *ofp;\r\nsprintf(fname, "%s.pl", outfile);\r\nofp = fopen(fname, "w");\r\nif (ofp == NULL) {\r\nfprintf(stderr, "couldn't open %s\n", fname);\r\nreturn -1;\r\n}\r\nfprintf(ofp, "# perf script event handlers, "\r\n"generated by perf script -g perl\n");\r\nfprintf(ofp, "# Licensed under the terms of the GNU GPL"\r\n" License version 2\n\n");\r\nfprintf(ofp, "# The common_* event handler fields are the most useful "\r\n"fields common to\n");\r\nfprintf(ofp, "# all events. They don't necessarily correspond to "\r\n"the 'common_*' fields\n");\r\nfprintf(ofp, "# in the format files. Those fields not available as "\r\n"handler params can\n");\r\nfprintf(ofp, "# be retrieved using Perl functions of the form "\r\n"common_*($context).\n");\r\nfprintf(ofp, "# See Context.pm for the list of available "\r\n"functions.\n\n");\r\nfprintf(ofp, "use lib \"$ENV{'PERF_EXEC_PATH'}/scripts/perl/"\r\n"Perf-Trace-Util/lib\";\n");\r\nfprintf(ofp, "use lib \"./Perf-Trace-Util/lib\";\n");\r\nfprintf(ofp, "use Perf::Trace::Core;\n");\r\nfprintf(ofp, "use Perf::Trace::Context;\n");\r\nfprintf(ofp, "use Perf::Trace::Util;\n\n");\r\nfprintf(ofp, "sub trace_begin\n{\n\t# optional\n}\n\n");\r\nfprintf(ofp, "sub trace_end\n{\n\t# optional\n}\n\n");\r\nwhile ((event = trace_find_next_event(pevent, event))) {\r\nfprintf(ofp, "sub %s::%s\n{\n", event->system, event->name);\r\nfprintf(ofp, "\tmy (");\r\nfprintf(ofp, "$event_name, ");\r\nfprintf(ofp, "$context, ");\r\nfprintf(ofp, "$common_cpu, ");\r\nfprintf(ofp, "$common_secs, ");\r\nfprintf(ofp, "$common_nsecs,\n");\r\nfprintf(ofp, "\t $common_pid, ");\r\nfprintf(ofp, "$common_comm,\n\t ");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (++count % 5 == 0)\r\nfprintf(ofp, "\n\t ");\r\nfprintf(ofp, "$%s", f->name);\r\n}\r\nfprintf(ofp, ") = @_;\n\n");\r\nfprintf(ofp, "\tprint_header($event_name, $common_cpu, "\r\n"$common_secs, $common_nsecs,\n\t "\r\n"$common_pid, $common_comm);\n\n");\r\nfprintf(ofp, "\tprintf(\"");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (count && count % 4 == 0) {\r\nfprintf(ofp, "\".\n\t \"");\r\n}\r\ncount++;\r\nfprintf(ofp, "%s=", f->name);\r\nif (f->flags & FIELD_IS_STRING ||\r\nf->flags & FIELD_IS_FLAG ||\r\nf->flags & FIELD_IS_SYMBOLIC)\r\nfprintf(ofp, "%%s");\r\nelse if (f->flags & FIELD_IS_SIGNED)\r\nfprintf(ofp, "%%d");\r\nelse\r\nfprintf(ofp, "%%u");\r\n}\r\nfprintf(ofp, "\\n\",\n\t ");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (++count % 5 == 0)\r\nfprintf(ofp, "\n\t ");\r\nif (f->flags & FIELD_IS_FLAG) {\r\nif ((count - 1) % 5 != 0) {\r\nfprintf(ofp, "\n\t ");\r\ncount = 4;\r\n}\r\nfprintf(ofp, "flag_str(\"");\r\nfprintf(ofp, "%s::%s\", ", event->system,\r\nevent->name);\r\nfprintf(ofp, "\"%s\", $%s)", f->name,\r\nf->name);\r\n} else if (f->flags & FIELD_IS_SYMBOLIC) {\r\nif ((count - 1) % 5 != 0) {\r\nfprintf(ofp, "\n\t ");\r\ncount = 4;\r\n}\r\nfprintf(ofp, "symbol_str(\"");\r\nfprintf(ofp, "%s::%s\", ", event->system,\r\nevent->name);\r\nfprintf(ofp, "\"%s\", $%s)", f->name,\r\nf->name);\r\n} else\r\nfprintf(ofp, "$%s", f->name);\r\n}\r\nfprintf(ofp, ");\n");\r\nfprintf(ofp, "}\n\n");\r\n}\r\nfprintf(ofp, "sub trace_unhandled\n{\n\tmy ($event_name, $context, "\r\n"$common_cpu, $common_secs, $common_nsecs,\n\t "\r\n"$common_pid, $common_comm) = @_;\n\n");\r\nfprintf(ofp, "\tprint_header($event_name, $common_cpu, "\r\n"$common_secs, $common_nsecs,\n\t $common_pid, "\r\n"$common_comm);\n}\n\n");\r\nfprintf(ofp, "sub print_header\n{\n"\r\n"\tmy ($event_name, $cpu, $secs, $nsecs, $pid, $comm) = @_;\n\n"\r\n"\tprintf(\"%%-20s %%5u %%05u.%%09u %%8u %%-20s \",\n\t "\r\n"$event_name, $cpu, $secs, $nsecs, $pid, $comm);\n}\n");\r\nfprintf(ofp,\r\n"\n# Packed byte string args of process_event():\n"\r\n"#\n"\r\n"# $event:\tunion perf_event\tutil/event.h\n"\r\n"# $attr:\tstruct perf_event_attr\tlinux/perf_event.h\n"\r\n"# $sample:\tstruct perf_sample\tutil/event.h\n"\r\n"# $raw_data:\tperf_sample->raw_data\tutil/event.h\n"\r\n"\n"\r\n"sub process_event\n"\r\n"{\n"\r\n"\tmy ($event, $attr, $sample, $raw_data) = @_;\n"\r\n"\n"\r\n"\tmy @event\t= unpack(\"LSS\", $event);\n"\r\n"\tmy @attr\t= unpack(\"LLQQQQQLLQQ\", $attr);\n"\r\n"\tmy @sample\t= unpack(\"QLLQQQQQLL\", $sample);\n"\r\n"\tmy @raw_data\t= unpack(\"C*\", $raw_data);\n"\r\n"\n"\r\n"\tuse Data::Dumper;\n"\r\n"\tprint Dumper \\@event, \\@attr, \\@sample, \\@raw_data;\n"\r\n"}\n");\r\nfclose(ofp);\r\nfprintf(stderr, "generated Perl script: %s\n", fname);\r\nreturn 0;\r\n}
