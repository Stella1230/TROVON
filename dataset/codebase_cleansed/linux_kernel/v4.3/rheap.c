static inline void fixup(unsigned long s, unsigned long e, int d,\r\nstruct list_head *l)\r\n{\r\nunsigned long *pp;\r\npp = (unsigned long *)&l->next;\r\nif (*pp >= s && *pp < e)\r\n*pp += d;\r\npp = (unsigned long *)&l->prev;\r\nif (*pp >= s && *pp < e)\r\n*pp += d;\r\n}\r\nstatic int grow(rh_info_t * info, int max_blocks)\r\n{\r\nrh_block_t *block, *blk;\r\nint i, new_blocks;\r\nint delta;\r\nunsigned long blks, blke;\r\nif (max_blocks <= info->max_blocks)\r\nreturn -EINVAL;\r\nnew_blocks = max_blocks - info->max_blocks;\r\nblock = kmalloc(sizeof(rh_block_t) * max_blocks, GFP_ATOMIC);\r\nif (block == NULL)\r\nreturn -ENOMEM;\r\nif (info->max_blocks > 0) {\r\nmemcpy(block, info->block,\r\nsizeof(rh_block_t) * info->max_blocks);\r\ndelta = (char *)block - (char *)info->block;\r\nblks = (unsigned long)info->block;\r\nblke = (unsigned long)(info->block + info->max_blocks);\r\nfor (i = 0, blk = block; i < info->max_blocks; i++, blk++)\r\nfixup(blks, blke, delta, &blk->list);\r\nfixup(blks, blke, delta, &info->empty_list);\r\nfixup(blks, blke, delta, &info->free_list);\r\nfixup(blks, blke, delta, &info->taken_list);\r\nif ((info->flags & RHIF_STATIC_BLOCK) == 0)\r\nkfree(info->block);\r\n}\r\ninfo->block = block;\r\ninfo->empty_slots += new_blocks;\r\ninfo->max_blocks = max_blocks;\r\ninfo->flags &= ~RHIF_STATIC_BLOCK;\r\nblk = block + info->max_blocks - new_blocks;\r\nfor (i = 0; i < new_blocks; i++, blk++)\r\nlist_add(&blk->list, &info->empty_list);\r\nreturn 0;\r\n}\r\nstatic int assure_empty(rh_info_t * info, int slots)\r\n{\r\nint max_blocks;\r\nif (slots >= 4)\r\nreturn -EINVAL;\r\nif (info->empty_slots >= slots)\r\nreturn 0;\r\nmax_blocks = ((info->max_blocks + slots) + 15) & ~15;\r\nreturn grow(info, max_blocks);\r\n}\r\nstatic rh_block_t *get_slot(rh_info_t * info)\r\n{\r\nrh_block_t *blk;\r\nif (info->empty_slots == 0) {\r\nprintk(KERN_ERR "rh: out of slots; crash is imminent.\n");\r\nreturn NULL;\r\n}\r\nblk = list_entry(info->empty_list.next, rh_block_t, list);\r\nlist_del_init(&blk->list);\r\ninfo->empty_slots--;\r\nblk->start = 0;\r\nblk->size = 0;\r\nblk->owner = NULL;\r\nreturn blk;\r\n}\r\nstatic inline void release_slot(rh_info_t * info, rh_block_t * blk)\r\n{\r\nlist_add(&blk->list, &info->empty_list);\r\ninfo->empty_slots++;\r\n}\r\nstatic void attach_free_block(rh_info_t * info, rh_block_t * blkn)\r\n{\r\nrh_block_t *blk;\r\nrh_block_t *before;\r\nrh_block_t *after;\r\nrh_block_t *next;\r\nint size;\r\nunsigned long s, e, bs, be;\r\nstruct list_head *l;\r\nsize = blkn->size;\r\ns = blkn->start;\r\ne = s + size;\r\nbefore = NULL;\r\nafter = NULL;\r\nnext = NULL;\r\nlist_for_each(l, &info->free_list) {\r\nblk = list_entry(l, rh_block_t, list);\r\nbs = blk->start;\r\nbe = bs + blk->size;\r\nif (next == NULL && s >= bs)\r\nnext = blk;\r\nif (be == s)\r\nbefore = blk;\r\nif (e == bs)\r\nafter = blk;\r\nif (before != NULL && after != NULL)\r\nbreak;\r\n}\r\nif (before && s != (before->start + before->size))\r\nbefore = NULL;\r\nif (after && e != after->start)\r\nafter = NULL;\r\nif (before == NULL && after == NULL) {\r\nif (next != NULL)\r\nlist_add(&blkn->list, &next->list);\r\nelse\r\nlist_add(&blkn->list, &info->free_list);\r\nreturn;\r\n}\r\nrelease_slot(info, blkn);\r\nif (before != NULL && after == NULL) {\r\nbefore->size += size;\r\nreturn;\r\n}\r\nif (before == NULL && after != NULL) {\r\nafter->start -= size;\r\nafter->size += size;\r\nreturn;\r\n}\r\nbefore->size += size + after->size;\r\nlist_del(&after->list);\r\nrelease_slot(info, after);\r\n}\r\nstatic void attach_taken_block(rh_info_t * info, rh_block_t * blkn)\r\n{\r\nrh_block_t *blk;\r\nstruct list_head *l;\r\nlist_for_each(l, &info->taken_list) {\r\nblk = list_entry(l, rh_block_t, list);\r\nif (blk->start > blkn->start) {\r\nlist_add_tail(&blkn->list, &blk->list);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&blkn->list, &info->taken_list);\r\n}\r\nrh_info_t *rh_create(unsigned int alignment)\r\n{\r\nrh_info_t *info;\r\nif ((alignment & (alignment - 1)) != 0)\r\nreturn ERR_PTR(-EINVAL);\r\ninfo = kmalloc(sizeof(*info), GFP_ATOMIC);\r\nif (info == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ninfo->alignment = alignment;\r\ninfo->block = NULL;\r\ninfo->max_blocks = 0;\r\ninfo->empty_slots = 0;\r\ninfo->flags = 0;\r\nINIT_LIST_HEAD(&info->empty_list);\r\nINIT_LIST_HEAD(&info->free_list);\r\nINIT_LIST_HEAD(&info->taken_list);\r\nreturn info;\r\n}\r\nvoid rh_destroy(rh_info_t * info)\r\n{\r\nif ((info->flags & RHIF_STATIC_BLOCK) == 0)\r\nkfree(info->block);\r\nif ((info->flags & RHIF_STATIC_INFO) == 0)\r\nkfree(info);\r\n}\r\nvoid rh_init(rh_info_t * info, unsigned int alignment, int max_blocks,\r\nrh_block_t * block)\r\n{\r\nint i;\r\nrh_block_t *blk;\r\nif ((alignment & (alignment - 1)) != 0)\r\nreturn;\r\ninfo->alignment = alignment;\r\ninfo->block = block;\r\ninfo->max_blocks = max_blocks;\r\ninfo->empty_slots = max_blocks;\r\ninfo->flags = RHIF_STATIC_INFO | RHIF_STATIC_BLOCK;\r\nINIT_LIST_HEAD(&info->empty_list);\r\nINIT_LIST_HEAD(&info->free_list);\r\nINIT_LIST_HEAD(&info->taken_list);\r\nfor (i = 0, blk = block; i < max_blocks; i++, blk++)\r\nlist_add(&blk->list, &info->empty_list);\r\n}\r\nint rh_attach_region(rh_info_t * info, unsigned long start, int size)\r\n{\r\nrh_block_t *blk;\r\nunsigned long s, e, m;\r\nint r;\r\ns = start;\r\ne = s + size;\r\nm = info->alignment - 1;\r\ns = (s + m) & ~m;\r\ne = e & ~m;\r\nif (IS_ERR_VALUE(e) || (e < s))\r\nreturn -ERANGE;\r\nstart = s;\r\nsize = e - s;\r\nr = assure_empty(info, 1);\r\nif (r < 0)\r\nreturn r;\r\nblk = get_slot(info);\r\nblk->start = start;\r\nblk->size = size;\r\nblk->owner = NULL;\r\nattach_free_block(info, blk);\r\nreturn 0;\r\n}\r\nunsigned long rh_detach_region(rh_info_t * info, unsigned long start, int size)\r\n{\r\nstruct list_head *l;\r\nrh_block_t *blk, *newblk;\r\nunsigned long s, e, m, bs, be;\r\nif (size <= 0)\r\nreturn (unsigned long) -EINVAL;\r\ns = start;\r\ne = s + size;\r\nm = info->alignment - 1;\r\ns = (s + m) & ~m;\r\ne = e & ~m;\r\nif (assure_empty(info, 1) < 0)\r\nreturn (unsigned long) -ENOMEM;\r\nblk = NULL;\r\nlist_for_each(l, &info->free_list) {\r\nblk = list_entry(l, rh_block_t, list);\r\nbs = blk->start;\r\nbe = blk->start + blk->size;\r\nif (s >= bs && e <= be)\r\nbreak;\r\nblk = NULL;\r\n}\r\nif (blk == NULL)\r\nreturn (unsigned long) -ENOMEM;\r\nif (bs == s && be == e) {\r\nlist_del(&blk->list);\r\nrelease_slot(info, blk);\r\nreturn s;\r\n}\r\nif (bs == s || be == e) {\r\nif (bs == s)\r\nblk->start += size;\r\nblk->size -= size;\r\n} else {\r\nblk->size = s - bs;\r\nnewblk = get_slot(info);\r\nnewblk->start = e;\r\nnewblk->size = be - e;\r\nlist_add(&newblk->list, &blk->list);\r\n}\r\nreturn s;\r\n}\r\nunsigned long rh_alloc_align(rh_info_t * info, int size, int alignment, const char *owner)\r\n{\r\nstruct list_head *l;\r\nrh_block_t *blk;\r\nrh_block_t *newblk;\r\nunsigned long start, sp_size;\r\nif (size <= 0 || (alignment & (alignment - 1)) != 0)\r\nreturn (unsigned long) -EINVAL;\r\nsize = (size + (info->alignment - 1)) & ~(info->alignment - 1);\r\nif (assure_empty(info, 2) < 0)\r\nreturn (unsigned long) -ENOMEM;\r\nblk = NULL;\r\nlist_for_each(l, &info->free_list) {\r\nblk = list_entry(l, rh_block_t, list);\r\nif (size <= blk->size) {\r\nstart = (blk->start + alignment - 1) & ~(alignment - 1);\r\nif (start + size <= blk->start + blk->size)\r\nbreak;\r\n}\r\nblk = NULL;\r\n}\r\nif (blk == NULL)\r\nreturn (unsigned long) -ENOMEM;\r\nif (blk->size == size) {\r\nlist_del(&blk->list);\r\nnewblk = blk;\r\n} else {\r\nsp_size = start - blk->start;\r\nif (sp_size) {\r\nrh_block_t *spblk;\r\nspblk = get_slot(info);\r\nspblk->start = blk->start;\r\nspblk->size = sp_size;\r\nlist_add(&spblk->list, blk->list.prev);\r\n}\r\nnewblk = get_slot(info);\r\nnewblk->start = start;\r\nnewblk->size = size;\r\nblk->start = start + size;\r\nblk->size -= sp_size + size;\r\nif (blk->size == 0) {\r\nlist_del(&blk->list);\r\nrelease_slot(info, blk);\r\n}\r\n}\r\nnewblk->owner = owner;\r\nattach_taken_block(info, newblk);\r\nreturn start;\r\n}\r\nunsigned long rh_alloc(rh_info_t * info, int size, const char *owner)\r\n{\r\nreturn rh_alloc_align(info, size, info->alignment, owner);\r\n}\r\nunsigned long rh_alloc_fixed(rh_info_t * info, unsigned long start, int size, const char *owner)\r\n{\r\nstruct list_head *l;\r\nrh_block_t *blk, *newblk1, *newblk2;\r\nunsigned long s, e, m, bs = 0, be = 0;\r\nif (size <= 0)\r\nreturn (unsigned long) -EINVAL;\r\ns = start;\r\ne = s + size;\r\nm = info->alignment - 1;\r\ns = (s + m) & ~m;\r\ne = e & ~m;\r\nif (assure_empty(info, 2) < 0)\r\nreturn (unsigned long) -ENOMEM;\r\nblk = NULL;\r\nlist_for_each(l, &info->free_list) {\r\nblk = list_entry(l, rh_block_t, list);\r\nbs = blk->start;\r\nbe = blk->start + blk->size;\r\nif (s >= bs && e <= be)\r\nbreak;\r\nblk = NULL;\r\n}\r\nif (blk == NULL)\r\nreturn (unsigned long) -ENOMEM;\r\nif (bs == s && be == e) {\r\nlist_del(&blk->list);\r\nblk->owner = owner;\r\nstart = blk->start;\r\nattach_taken_block(info, blk);\r\nreturn start;\r\n}\r\nif (bs == s || be == e) {\r\nif (bs == s)\r\nblk->start += size;\r\nblk->size -= size;\r\n} else {\r\nblk->size = s - bs;\r\nnewblk2 = get_slot(info);\r\nnewblk2->start = e;\r\nnewblk2->size = be - e;\r\nlist_add(&newblk2->list, &blk->list);\r\n}\r\nnewblk1 = get_slot(info);\r\nnewblk1->start = s;\r\nnewblk1->size = e - s;\r\nnewblk1->owner = owner;\r\nstart = newblk1->start;\r\nattach_taken_block(info, newblk1);\r\nreturn start;\r\n}\r\nint rh_free(rh_info_t * info, unsigned long start)\r\n{\r\nrh_block_t *blk, *blk2;\r\nstruct list_head *l;\r\nint size;\r\nblk = NULL;\r\nlist_for_each(l, &info->taken_list) {\r\nblk2 = list_entry(l, rh_block_t, list);\r\nif (start < blk2->start)\r\nbreak;\r\nblk = blk2;\r\n}\r\nif (blk == NULL || start > (blk->start + blk->size))\r\nreturn -EINVAL;\r\nlist_del(&blk->list);\r\nsize = blk->size;\r\nattach_free_block(info, blk);\r\nreturn size;\r\n}\r\nint rh_get_stats(rh_info_t * info, int what, int max_stats, rh_stats_t * stats)\r\n{\r\nrh_block_t *blk;\r\nstruct list_head *l;\r\nstruct list_head *h;\r\nint nr;\r\nswitch (what) {\r\ncase RHGS_FREE:\r\nh = &info->free_list;\r\nbreak;\r\ncase RHGS_TAKEN:\r\nh = &info->taken_list;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnr = 0;\r\nlist_for_each(l, h) {\r\nblk = list_entry(l, rh_block_t, list);\r\nif (stats != NULL && nr < max_stats) {\r\nstats->start = blk->start;\r\nstats->size = blk->size;\r\nstats->owner = blk->owner;\r\nstats++;\r\n}\r\nnr++;\r\n}\r\nreturn nr;\r\n}\r\nint rh_set_owner(rh_info_t * info, unsigned long start, const char *owner)\r\n{\r\nrh_block_t *blk, *blk2;\r\nstruct list_head *l;\r\nint size;\r\nblk = NULL;\r\nlist_for_each(l, &info->taken_list) {\r\nblk2 = list_entry(l, rh_block_t, list);\r\nif (start < blk2->start)\r\nbreak;\r\nblk = blk2;\r\n}\r\nif (blk == NULL || start > (blk->start + blk->size))\r\nreturn -EINVAL;\r\nblk->owner = owner;\r\nsize = blk->size;\r\nreturn size;\r\n}\r\nvoid rh_dump(rh_info_t * info)\r\n{\r\nstatic rh_stats_t st[32];\r\nint maxnr;\r\nint i, nr;\r\nmaxnr = ARRAY_SIZE(st);\r\nprintk(KERN_INFO\r\n"info @0x%p (%d slots empty / %d max)\n",\r\ninfo, info->empty_slots, info->max_blocks);\r\nprintk(KERN_INFO " Free:\n");\r\nnr = rh_get_stats(info, RHGS_FREE, maxnr, st);\r\nif (nr > maxnr)\r\nnr = maxnr;\r\nfor (i = 0; i < nr; i++)\r\nprintk(KERN_INFO\r\n" 0x%lx-0x%lx (%u)\n",\r\nst[i].start, st[i].start + st[i].size,\r\nst[i].size);\r\nprintk(KERN_INFO "\n");\r\nprintk(KERN_INFO " Taken:\n");\r\nnr = rh_get_stats(info, RHGS_TAKEN, maxnr, st);\r\nif (nr > maxnr)\r\nnr = maxnr;\r\nfor (i = 0; i < nr; i++)\r\nprintk(KERN_INFO\r\n" 0x%lx-0x%lx (%u) %s\n",\r\nst[i].start, st[i].start + st[i].size,\r\nst[i].size, st[i].owner != NULL ? st[i].owner : "");\r\nprintk(KERN_INFO "\n");\r\n}\r\nvoid rh_dump_blk(rh_info_t * info, rh_block_t * blk)\r\n{\r\nprintk(KERN_INFO\r\n"blk @0x%p: 0x%lx-0x%lx (%u)\n",\r\nblk, blk->start, blk->start + blk->size, blk->size);\r\n}
