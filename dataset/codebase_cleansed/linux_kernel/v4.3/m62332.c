static int m62332_set_value(struct iio_dev *indio_dev,\r\nu8 val, int channel)\r\n{\r\nstruct m62332_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nu8 outbuf[2];\r\nint res;\r\nif (val == data->raw[channel])\r\nreturn 0;\r\noutbuf[0] = channel;\r\noutbuf[1] = val;\r\nmutex_lock(&data->mutex);\r\nif (val) {\r\nres = regulator_enable(data->vcc);\r\nif (res)\r\ngoto out;\r\n}\r\nres = i2c_master_send(client, outbuf, 2);\r\nif (res >= 0 && res != 2)\r\nres = -EIO;\r\nif (res < 0)\r\ngoto out;\r\ndata->raw[channel] = val;\r\nif (!val)\r\nregulator_disable(data->vcc);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\nout:\r\nmutex_unlock(&data->mutex);\r\nreturn res;\r\n}\r\nstatic int m62332_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct m62332_data *data = iio_priv(indio_dev);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = data->vref_mv;\r\n*val2 = 8;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_RAW:\r\n*val = data->raw[chan->channel];\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = 1;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int m62332_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\nret = m62332_set_value(indio_dev, val, chan->channel);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m62332_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct m62332_data *data = iio_priv(indio_dev);\r\nint ret;\r\ndata->save[0] = data->raw[0];\r\ndata->save[1] = data->raw[1];\r\nret = m62332_set_value(indio_dev, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn m62332_set_value(indio_dev, 0, 1);\r\n}\r\nstatic int m62332_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct m62332_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = m62332_set_value(indio_dev, data->save[0], 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn m62332_set_value(indio_dev, data->save[1], 1);\r\n}\r\nstatic int m62332_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct m62332_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->mutex);\r\ndata->vcc = devm_regulator_get(&client->dev, "VCC");\r\nif (IS_ERR(data->vcc))\r\nreturn PTR_ERR(data->vcc);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->num_channels = M62332_CHANNELS;\r\nindio_dev->channels = m62332_channels;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &m62332_info;\r\nret = regulator_get_voltage(data->vcc);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->vref_mv = ret / 1000;\r\nret = iio_map_array_register(indio_dev, client->dev.platform_data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\niio_map_array_unregister(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int m62332_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\niio_map_array_unregister(indio_dev);\r\nreturn 0;\r\n}
