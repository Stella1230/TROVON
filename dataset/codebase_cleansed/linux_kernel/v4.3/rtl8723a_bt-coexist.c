static u8 BT_Operation(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->BtOperationOn)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic u8 BT_IsLegalChannel(struct rtw_adapter *padapter, u8 channel)\r\n{\r\nstruct rt_channel_info *pChanneList = NULL;\r\nu8 channelLen, i;\r\npChanneList = padapter->mlmeextpriv.channel_set;\r\nchannelLen = padapter->mlmeextpriv.max_chan_nums;\r\nfor (i = 0; i < channelLen; i++) {\r\nRTPRINT(FIOCTL, IOCTL_STATE,\r\n("Check if chnl(%d) in channel plan contains bt target chnl(%d) for BT connection\n",\r\npChanneList[i].ChannelNum, channel));\r\nif ((channel == pChanneList[i].ChannelNum) ||\r\n(channel == pChanneList[i].ChannelNum + 2))\r\nreturn channel;\r\n}\r\nreturn 0;\r\n}\r\nvoid BT_SignalCompensation(struct rtw_adapter *padapter, u8 *rssi_wifi, u8 *rssi_bt)\r\n{\r\nBTDM_SignalCompensation(padapter, rssi_wifi, rssi_bt);\r\n}\r\nvoid rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nBTHCI_WifiScanNotify(padapter, scanType);\r\nBTDM_CheckAntSelMode(padapter);\r\nBTDM_WifiScanNotify(padapter, scanType);\r\n}\r\nvoid rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter, u8 action)\r\n{\r\nif (action)\r\nBTDM_CheckAntSelMode(padapter);\r\nBTDM_WifiAssociateNotify(padapter, action);\r\n}\r\nvoid BT_HaltProcess(struct rtw_adapter *padapter)\r\n{\r\nBTDM_ForHalt(padapter);\r\n}\r\nstatic enum rt_status PlatformIndicateBTEvent(\r\nstruct rtw_adapter *padapter,\r\nvoid *pEvntData,\r\nu32 dataLen\r\n)\r\n{\r\nenum rt_status rt_status = RT_STATUS_FAILURE;\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_DETAIL, ("BT event start, %d bytes data to Transferred!!\n", dataLen));\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_EVENT_DETAIL, "To transfer Hex Data :\n",\r\npEvntData, dataLen);\r\nBT_EventParse(padapter, pEvntData, dataLen);\r\nprintk(KERN_WARNING "%s: Linux has no way to report BT event!!\n", __func__);\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_DETAIL, ("BT event end, %s\n",\r\n(rt_status == RT_STATUS_SUCCESS) ? "SUCCESS" : "FAIL"));\r\nreturn rt_status;\r\n}\r\nstatic u8 bthci_GetLocalChannel(struct rtw_adapter *padapter)\r\n{\r\nreturn padapter->mlmeextpriv.cur_channel;\r\n}\r\nstatic u8 bthci_GetCurrentEntryNum(struct rtw_adapter *padapter, u8 PhyHandle)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nu8 i;\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\nif ((pBTInfo->BtAsocEntry[i].bUsed) &&\r\n(pBTInfo->BtAsocEntry[i].PhyLinkCmdData.BtPhyLinkhandle == PhyHandle))\r\nreturn i;\r\n}\r\nreturn 0xFF;\r\n}\r\nstatic void bthci_DecideBTChannel(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_hci_info *pBtHciInfo;\r\nstruct chnl_txpower_triple *pTriple_subband = NULL;\r\nstruct common_triple *pTriple;\r\nu8 i, j, localchnl, firstRemoteLegalChnlInTriplet = 0;\r\nu8 regulatory_skipLen = 0;\r\nu8 subbandTripletCnt = 0;\r\npmlmepriv = &padapter->mlmepriv;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtHciInfo = &pBTInfo->BtHciInfo;\r\npBtMgnt->CheckChnlIsSuit = true;\r\nlocalchnl = bthci_GetLocalChannel(padapter);\r\npTriple = (struct common_triple *)\r\n&pBtHciInfo->BTPreChnllist[COUNTRY_STR_LEN];\r\nfor (i = 0; i < (pBtHciInfo->BtPreChnlListLen-COUNTRY_STR_LEN); i += 3, pTriple++) {\r\nif (pTriple->byte_1st == 0xc9) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO),\r\n("Find Regulatory ID, regulatory class = %d\n", pTriple->byte_2nd));\r\nregulatory_skipLen += 3;\r\npTriple_subband = NULL;\r\ncontinue;\r\n} else {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Find Sub-band triplet \n"));\r\nsubbandTripletCnt++;\r\npTriple_subband = (struct chnl_txpower_triple *)pTriple;\r\nfor (j = pTriple_subband->FirstChnl; j < (pTriple_subband->FirstChnl+pTriple_subband->NumChnls); j++) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), (" Check if chnl(%d) is legal\n", j));\r\nif (BT_IsLegalChannel(padapter, j)) {\r\nfirstRemoteLegalChnlInTriplet = j;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO),\r\n("Find first remote legal channel : %d\n",\r\nfirstRemoteLegalChnlInTriplet));\r\nif (!(check_fwstate(pmlmepriv, WIFI_ASOC_STATE|WIFI_ADHOC_STATE|WIFI_AP_STATE) ||\r\nBTHCI_HsConnectionEstablished(padapter))) {\r\npBtMgnt->BTChannel = firstRemoteLegalChnlInTriplet;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Remote legal channel (%d) is selected, Local not connect to any!!\n", pBtMgnt->BTChannel));\r\nreturn;\r\n} else {\r\nif ((localchnl >= firstRemoteLegalChnlInTriplet) &&\r\n(localchnl < (pTriple_subband->FirstChnl+pTriple_subband->NumChnls))) {\r\npBtMgnt->BTChannel = localchnl;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Local channel (%d) is selected, wifi or BT connection exists\n", pBtMgnt->BTChannel));\r\nreturn;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (subbandTripletCnt) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("There are %d sub band triplet exists, ", subbandTripletCnt));\r\nif (firstRemoteLegalChnlInTriplet == 0) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("no legal channel is found!!\n"));\r\n} else {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO),\r\n("Remote Legal channel is found but not match to local(wifi connection exists)!!\n"));\r\n}\r\npBtMgnt->CheckChnlIsSuit = false;\r\n} else {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("No sub band triplet exists!!\n"));\r\n}\r\npBtMgnt->BTChannel = localchnl;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Local channel (%d) is selected!!\n", pBtMgnt->BTChannel));\r\n}\r\nstatic u8 bthci_GetAssocInfo(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_hci_info *pBtHciInfo;\r\nu8 tempBuf[256];\r\nu8 i = 0;\r\nu8 BaseMemoryShift = 0;\r\nu16 TotalLen = 0;\r\nstruct amp_assoc_structure *pAmpAsoc;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("GetAssocInfo start\n"));\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar == 0) {\r\nif (pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocRemLen < (MAX_AMP_ASSOC_FRAG_LEN))\r\nTotalLen = pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocRemLen;\r\nelse if (pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocRemLen == (MAX_AMP_ASSOC_FRAG_LEN))\r\nTotalLen = MAX_AMP_ASSOC_FRAG_LEN;\r\n} else if (pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar > 0)\r\nTotalLen = pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar;\r\nwhile ((pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar >= BaseMemoryShift) || TotalLen > BaseMemoryShift) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("GetAssocInfo, TotalLen =%d, BaseMemoryShift =%d\n", TotalLen, BaseMemoryShift));\r\nmemcpy(tempBuf,\r\n(u8 *)pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocfragment+BaseMemoryShift,\r\nTotalLen-BaseMemoryShift);\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_DETAIL, "GetAssocInfo :\n",\r\ntempBuf, TotalLen-BaseMemoryShift);\r\npAmpAsoc = (struct amp_assoc_structure *)tempBuf;\r\nle16_to_cpus(&pAmpAsoc->Length);\r\nBaseMemoryShift += 3 + pAmpAsoc->Length;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("TypeID = 0x%x, ", pAmpAsoc->TypeID));\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD, "Hex Data: \n", pAmpAsoc->Data, pAmpAsoc->Length);\r\nswitch (pAmpAsoc->TypeID) {\r\ncase AMP_MAC_ADDR:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("==> AMP_MAC_ADDR\n"));\r\nif (pAmpAsoc->Length > 6)\r\nreturn false;\r\nmemcpy(pBTInfo->BtAsocEntry[EntryNum].BTRemoteMACAddr, pAmpAsoc->Data, 6);\r\nRTPRINT_ADDR(FIOCTL, IOCTL_BT_HCICMD, ("Remote Mac address \n"), pBTInfo->BtAsocEntry[EntryNum].BTRemoteMACAddr);\r\nbreak;\r\ncase AMP_PREFERRED_CHANNEL_LIST:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("==> AMP_PREFERRED_CHANNEL_LIST\n"));\r\npBtHciInfo->BtPreChnlListLen = pAmpAsoc->Length;\r\nmemcpy(pBtHciInfo->BTPreChnllist,\r\npAmpAsoc->Data,\r\npBtHciInfo->BtPreChnlListLen);\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD, "Preferred channel list : \n", pBtHciInfo->BTPreChnllist, pBtHciInfo->BtPreChnlListLen);\r\nbthci_DecideBTChannel(padapter, EntryNum);\r\nbreak;\r\ncase AMP_CONNECTED_CHANNEL:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("==> AMP_CONNECTED_CHANNEL\n"));\r\npBtHciInfo->BTConnectChnlListLen = pAmpAsoc->Length;\r\nmemcpy(pBtHciInfo->BTConnectChnllist,\r\npAmpAsoc->Data,\r\npBtHciInfo->BTConnectChnlListLen);\r\nbreak;\r\ncase AMP_80211_PAL_CAP_LIST:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("==> AMP_80211_PAL_CAP_LIST\n"));\r\npBTInfo->BtAsocEntry[EntryNum].BTCapability = *(u32 *)(pAmpAsoc->Data);\r\nif (pBTInfo->BtAsocEntry[EntryNum].BTCapability & 0x00000001) {\r\n}\r\nif (pBTInfo->BtAsocEntry[EntryNum].BTCapability & 0x00000002) {\r\n}\r\nbreak;\r\ncase AMP_80211_PAL_VISION:\r\npBtHciInfo->BTPalVersion = *(u8 *)(pAmpAsoc->Data);\r\npBtHciInfo->BTPalCompanyID = *(u16 *)(((u8 *)(pAmpAsoc->Data))+1);\r\npBtHciInfo->BTPalsubversion = *(u16 *)(((u8 *)(pAmpAsoc->Data))+3);\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("==> AMP_80211_PAL_VISION PalVersion 0x%x, PalCompanyID 0x%x, Palsubversion 0x%x\n",\r\npBtHciInfo->BTPalVersion,\r\npBtHciInfo->BTPalCompanyID,\r\npBtHciInfo->BTPalsubversion));\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("==> Unsupport TypeID !!\n"));\r\nbreak;\r\n}\r\ni++;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("GetAssocInfo end\n"));\r\nreturn true;\r\n}\r\nstatic u8 bthci_AddEntry(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nu8 i;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\nif (pBTInfo->BtAsocEntry[i].bUsed == false) {\r\npBTInfo->BtAsocEntry[i].bUsed = true;\r\npBtMgnt->CurrentConnectEntryNum = i;\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_BT_ASOC_ENTRY_NUM) {\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("bthci_AddEntry(), Add entry fail!!\n"));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u8 bthci_DiscardTxPackets(struct rtw_adapter *padapter, u16 LLH)\r\n{\r\nreturn false;\r\n}\r\nstatic u8\r\nbthci_CheckLogLinkBehavior(\r\nstruct rtw_adapter *padapter,\r\nstruct hci_flow_spec TxFlowSpec\r\n)\r\n{\r\nu8 ID = TxFlowSpec.Identifier;\r\nu8 ServiceType = TxFlowSpec.ServiceType;\r\nu16 MaxSDUSize = TxFlowSpec.MaximumSDUSize;\r\nu32 SDUInterArrivatime = TxFlowSpec.SDUInterArrivalTime;\r\nu8 match = false;\r\nswitch (ID) {\r\ncase 1:\r\nif (ServiceType == BT_LL_BE) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = TX best effort flowspec\n"));\r\n} else if ((ServiceType == BT_LL_GU) && (MaxSDUSize == 0xffff)) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = RX guaranteed latency flowspec\n"));\r\n} else if ((ServiceType == BT_LL_GU) && (MaxSDUSize == 2500)) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = RX guaranteed Large latency flowspec\n"));\r\n}\r\nbreak;\r\ncase 2:\r\nif (ServiceType == BT_LL_BE) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = RX best effort flowspec\n"));\r\n}\r\nbreak;\r\ncase 3:\r\nif ((ServiceType == BT_LL_GU) && (MaxSDUSize == 1492)) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = TX guaranteed latency flowspec\n"));\r\n} else if ((ServiceType == BT_LL_GU) && (MaxSDUSize == 2500)) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = TX guaranteed Large latency flowspec\n"));\r\n}\r\nbreak;\r\ncase 4:\r\nif (ServiceType == BT_LL_BE) {\r\nif ((SDUInterArrivatime == 0xffffffff) && (ServiceType == BT_LL_BE) && (MaxSDUSize == 1492)) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = TX/RX aggregated best effort flowspec\n"));\r\n}\r\n} else if (ServiceType == BT_LL_GU) {\r\nif (SDUInterArrivatime == 100) {\r\nmatch = true;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = TX/RX guaranteed bandwidth flowspec\n"));\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Logical Link Type = Unknow Type !!!!!!!!\n"));\r\nbreak;\r\n}\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO),\r\n("ID = 0x%x, ServiceType = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, AccessLatency = 0x%x, FlushTimeout = 0x%x\n",\r\nTxFlowSpec.Identifier, TxFlowSpec.ServiceType, MaxSDUSize,\r\nSDUInterArrivatime, TxFlowSpec.AccessLatency, TxFlowSpec.FlushTimeout));\r\nreturn match;\r\n}\r\nstatic u16 bthci_AssocMACAddr(struct rtw_adapter *padapter, void *pbuf)\r\n{\r\nstruct amp_assoc_structure *pAssoStrc = (struct amp_assoc_structure *)pbuf;\r\npAssoStrc->TypeID = AMP_MAC_ADDR;\r\npAssoStrc->Length = 0x06;\r\nmemcpy(&pAssoStrc->Data[0], padapter->eeprompriv.mac_addr, 6);\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO),\r\n("AssocMACAddr : \n"), pAssoStrc, pAssoStrc->Length+3);\r\nreturn pAssoStrc->Length + 3;\r\n}\r\nstatic u16\r\nbthci_PALCapabilities(\r\nstruct rtw_adapter *padapter,\r\nvoid *pbuf\r\n)\r\n{\r\nstruct amp_assoc_structure *pAssoStrc = (struct amp_assoc_structure *)pbuf;\r\npAssoStrc->TypeID = AMP_80211_PAL_CAP_LIST;\r\npAssoStrc->Length = 0x04;\r\npAssoStrc->Data[0] = 0x00;\r\npAssoStrc->Data[1] = 0x00;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("PALCapabilities:\n"), pAssoStrc, pAssoStrc->Length+3);\r\nRTPRINT(FIOCTL, IOCTL_BT_LOGO, ("PALCapabilities \n"));\r\nRTPRINT(FIOCTL, IOCTL_BT_LOGO, (" TypeID = 0x%x,\n Length = 0x%x,\n Content = 0x0000\n",\r\npAssoStrc->TypeID,\r\npAssoStrc->Length));\r\nreturn pAssoStrc->Length + 3;\r\n}\r\nstatic u16 bthci_AssocPreferredChannelList(struct rtw_adapter *padapter,\r\nvoid *pbuf, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nstruct amp_assoc_structure *pAssoStrc;\r\nstruct amp_pref_chnl_regulatory *pReg;\r\nstruct chnl_txpower_triple *pTriple;\r\nchar ctrString[3] = {'X', 'X', 'X'};\r\nu32 len = 0;\r\nu8 preferredChnl;\r\npBTInfo = GET_BT_INFO(padapter);\r\npAssoStrc = (struct amp_assoc_structure *)pbuf;\r\npReg = (struct amp_pref_chnl_regulatory *)&pAssoStrc->Data[3];\r\npreferredChnl = bthci_GetLocalChannel(padapter);\r\npAssoStrc->TypeID = AMP_PREFERRED_CHANNEL_LIST;\r\nmemcpy(&pAssoStrc->Data[0], &ctrString[0], 3);\r\npReg->reXId = 201;\r\npReg->regulatoryClass = 254;\r\npReg->coverageClass = 0;\r\nlen += 6;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD | IOCTL_BT_LOGO), ("PREFERRED_CHNL_LIST\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD | IOCTL_BT_LOGO), ("XXX, 201, 254, 0\n"));\r\npTriple = (struct chnl_txpower_triple *)&pAssoStrc->Data[len];\r\nif ((pBTInfo->BtAsocEntry[EntryNum].AMPRole == AMP_BTAP_CREATOR) ||\r\n(check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE |\r\nWIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE |\r\nWIFI_AP_STATE)) ||\r\nBTHCI_HsConnectionEstablished(padapter)) {\r\npTriple->FirstChnl = preferredChnl;\r\npTriple->NumChnls = 1;\r\npTriple->MaxTxPowerInDbm = 20;\r\nlen += 3;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD | IOCTL_BT_LOGO), ("First Channel = %d, Channel Num = %d, MaxDbm = %d\n",\r\npTriple->FirstChnl,\r\npTriple->NumChnls,\r\npTriple->MaxTxPowerInDbm));\r\n}\r\npAssoStrc->Length = (u16)len;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD, ("AssocPreferredChannelList : \n"), pAssoStrc, pAssoStrc->Length+3);\r\nreturn pAssoStrc->Length + 3;\r\n}\r\nstatic u16 bthci_AssocPALVer(struct rtw_adapter *padapter, void *pbuf)\r\n{\r\nstruct amp_assoc_structure *pAssoStrc = (struct amp_assoc_structure *)pbuf;\r\nu8 *pu1Tmp;\r\nu16 *pu2Tmp;\r\npAssoStrc->TypeID = AMP_80211_PAL_VISION;\r\npAssoStrc->Length = 0x5;\r\npu1Tmp = &pAssoStrc->Data[0];\r\n*pu1Tmp = 0x1;\r\npu2Tmp = (u16 *)&pAssoStrc->Data[1];\r\n*pu2Tmp = 0x5D;\r\npu2Tmp = (u16 *)&pAssoStrc->Data[3];\r\n*pu2Tmp = 0x1;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("AssocPALVer : \n"), pAssoStrc, pAssoStrc->Length+3);\r\nRTPRINT(FIOCTL, IOCTL_BT_LOGO, ("AssocPALVer \n"));\r\nRTPRINT(FIOCTL, IOCTL_BT_LOGO, (" TypeID = 0x%x,\n Length = 0x%x,\n PAL Version = 0x01,\n PAL vendor = 0x01,\n PAL Sub-version specifier = 0x01\n",\r\npAssoStrc->TypeID,\r\npAssoStrc->Length));\r\nreturn pAssoStrc->Length + 3;\r\n}\r\nstatic u8 bthci_CheckRfStateBeforeConnect(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nenum rt_rf_power_state RfState;\r\npBTInfo = GET_BT_INFO(padapter);\r\nRfState = padapter->pwrctrlpriv.rf_pwrstate;\r\nif (RfState != rf_on) {\r\nmod_timer(&pBTInfo->BTPsDisableTimer,\r\njiffies + msecs_to_jiffies(50));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void bthci_ResponderStartToScan(struct rtw_adapter *padapter)\r\n{\r\n}\r\nstatic u8 bthci_PhyLinkConnectionInProgress(struct rtw_adapter *padapter, u8 PhyLinkHandle)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->bPhyLinkInProgress &&\r\n(pBtMgnt->BtCurrentPhyLinkhandle == PhyLinkHandle))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void bthci_ResetFlowSpec(struct rtw_adapter *padapter, u8 EntryNum, u8 index)\r\n{\r\nstruct bt_30info *pBTinfo;\r\npBTinfo = GET_BT_INFO(padapter);\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].BtLogLinkhandle = 0;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].BtPhyLinkhandle = 0;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].bLLCompleteEventIsSet = false;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].bLLCancelCMDIsSetandComplete = false;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].BtTxFlowSpecID = 0;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].TxPacketCount = 0;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.Identifier = 0x01;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.ServiceType = SERVICE_BEST_EFFORT;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.MaximumSDUSize = 0xffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.SDUInterArrivalTime = 0xffffffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.AccessLatency = 0xffffffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Tx_Flow_Spec.FlushTimeout = 0xffffffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.Identifier = 0x01;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.ServiceType = SERVICE_BEST_EFFORT;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.MaximumSDUSize = 0xffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.SDUInterArrivalTime = 0xffffffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.AccessLatency = 0xffffffff;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[index].Rx_Flow_Spec.FlushTimeout = 0xffffffff;\r\n}\r\nstatic void bthci_ResetEntry(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTinfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nu8 j;\r\npBTinfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTinfo->BtMgnt;\r\npBTinfo->BtAsocEntry[EntryNum].bUsed = false;\r\npBTinfo->BtAsocEntry[EntryNum].BtCurrentState = HCI_STATE_DISCONNECTED;\r\npBTinfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_DISCONNECTED;\r\npBTinfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocRemLen = 0;\r\npBTinfo->BtAsocEntry[EntryNum].AmpAsocCmdData.BtPhyLinkhandle = 0;\r\nif (pBTinfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocfragment != NULL)\r\nmemset(pBTinfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocfragment, 0, TOTAL_ALLOCIATE_ASSOC_LEN);\r\npBTinfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar = 0;\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyType = 0;\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle = 0;\r\nmemset(pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKey, 0,\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen);\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen = 0;\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = 0x3e80;\r\npBTinfo->BtAsocEntry[EntryNum].AMPRole = AMP_BTAP_NONE;\r\npBTinfo->BtAsocEntry[EntryNum].mAssoc = false;\r\npBTinfo->BtAsocEntry[EntryNum].b4waySuccess = false;\r\npBTinfo->BtAsocEntry[EntryNum].KeyReplayCounter = 0;\r\npBTinfo->BtAsocEntry[EntryNum].BTWPAAuthState = STATE_WPA_AUTH_UNINITIALIZED;\r\npBTinfo->BtAsocEntry[EntryNum].bSendSupervisionPacket = false;\r\npBTinfo->BtAsocEntry[EntryNum].NoRxPktCnt = 0;\r\npBTinfo->BtAsocEntry[EntryNum].ShortRangeMode = 0;\r\npBTinfo->BtAsocEntry[EntryNum].rxSuvpPktCnt = 0;\r\nfor (j = 0; j < MAX_LOGICAL_LINK_NUM; j++)\r\nbthci_ResetFlowSpec(padapter, EntryNum, j);\r\npBtMgnt->BTAuthCount = 0;\r\npBtMgnt->BTAsocCount = 0;\r\npBtMgnt->BTCurrentConnectType = BT_DISCONNECT;\r\npBtMgnt->BTReceiveConnectPkt = BT_DISCONNECT;\r\nHALBT_RemoveKey(padapter, EntryNum);\r\n}\r\nstatic void bthci_RemoveEntryByEntryNum(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nbthci_ResetEntry(padapter, EntryNum);\r\nif (pBtMgnt->CurrentBTConnectionCnt > 0)\r\npBtMgnt->CurrentBTConnectionCnt--;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], CurrentBTConnectionCnt = %d!!\n",\r\npBtMgnt->CurrentBTConnectionCnt));\r\nif (pBtMgnt->CurrentBTConnectionCnt > 0) {\r\npBtMgnt->BtOperationOn = true;\r\n} else {\r\npBtMgnt->BtOperationOn = false;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], Bt Operation OFF!!\n"));\r\n}\r\nif (!pBtMgnt->BtOperationOn) {\r\ndel_timer_sync(&pBTInfo->BTHCIDiscardAclDataTimer);\r\ndel_timer_sync(&pBTInfo->BTBeaconTimer);\r\npBtMgnt->bStartSendSupervisionPkt = false;\r\n}\r\n}\r\nstatic u8\r\nbthci_CommandCompleteHeader(\r\nu8 *pbuf,\r\nu16 OGF,\r\nu16 OCF,\r\nenum hci_status status\r\n)\r\n{\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;\r\nu8 NumHCI_Comm = 0x1;\r\nPPacketIrpEvent->EventCode = HCI_EVENT_COMMAND_COMPLETE;\r\nPPacketIrpEvent->Data[0] = NumHCI_Comm;\r\nPPacketIrpEvent->Data[1] = HCIOPCODELOW(OCF, OGF);\r\nPPacketIrpEvent->Data[2] = HCIOPCODEHIGHT(OCF, OGF);\r\nif (OGF == OGF_EXTENSION) {\r\nif (OCF == HCI_SET_RSSI_VALUE) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT_PERIODICAL),\r\n("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",\r\nNumHCI_Comm, (HCIOPCODEHIGHT(OCF, OGF)), (HCIOPCODELOW(OCF, OGF)), status, OGF, OCF));\r\n} else {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_EXT),\r\n("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",\r\nNumHCI_Comm, (HCIOPCODEHIGHT(OCF, OGF)), (HCIOPCODELOW(OCF, OGF)), status, OGF, OCF));\r\n}\r\n} else {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO),\r\n("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",\r\nNumHCI_Comm, (HCIOPCODEHIGHT(OCF, OGF)), (HCIOPCODELOW(OCF, OGF)), status, OGF, OCF));\r\n}\r\nreturn 3;\r\n}\r\nstatic u8 bthci_ExtensionEventHeaderRtk(u8 *pbuf, u8 extensionEvent)\r\n{\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;\r\nPPacketIrpEvent->EventCode = HCI_EVENT_EXTENSION_RTK;\r\nPPacketIrpEvent->Data[0] = extensionEvent;\r\nreturn 1;\r\n}\r\nstatic enum rt_status\r\nbthci_IndicateEvent(\r\nstruct rtw_adapter *padapter,\r\nvoid *pEvntData,\r\nu32 dataLen\r\n)\r\n{\r\nenum rt_status rt_status;\r\nrt_status = PlatformIndicateBTEvent(padapter, pEvntData, dataLen);\r\nreturn rt_status;\r\n}\r\nstatic void\r\nbthci_EventWriteRemoteAmpAssoc(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status status,\r\nu8 PLHandle\r\n)\r\n{\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_WRITE_REMOTE_AMP_ASSOC,\r\nstatus);\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("PhyLinkHandle = 0x%x, status = %d\n", PLHandle, status));\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = PLHandle;\r\nlen += 2;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nstatic void\r\nbthci_EventEnhancedFlushComplete(\r\nstruct rtw_adapter *padapter,\r\nu16 LLH\r\n)\r\n{\r\nu8 localBuf[4] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("EventEnhancedFlushComplete, LLH = 0x%x\n", LLH));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_ENHANCED_FLUSH_COMPLETE;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = TWOBYTE_LOWBYTE(LLH);\r\nPPacketIrpEvent->Data[1] = TWOBYTE_HIGHTBYTE(LLH);\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\n}\r\nstatic void\r\nbthci_EventShortRangeModeChangeComplete(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nu8 ShortRangeState,\r\nu8 EntryNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[5] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_SHORT_RANGE_MODE_CHANGE_COMPLETE)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Short Range Mode Change Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Short Range Mode Change Complete, Status = %d\n , PLH = 0x%x\n, Short_Range_Mode_State = 0x%x\n",\r\nHciStatus, pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle, ShortRangeState));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_SHORT_RANGE_MODE_CHANGE_COMPLETE;\r\nPPacketIrpEvent->Length = 3;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\nPPacketIrpEvent->Data[2] = ShortRangeState;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 5);\r\n}\r\nstatic void bthci_EventSendFlowSpecModifyComplete(struct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nu16 logicHandle)\r\n{\r\nu8 localBuf[5] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_FLOW_SPEC_MODIFY_COMPLETE)) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO),\r\n("[BT event], Flow Spec Modify Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO),\r\n("[BT event], Flow Spec Modify Complete, status = 0x%x, LLH = 0x%x\n", HciStatus, logicHandle));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_FLOW_SPEC_MODIFY_COMPLETE;\r\nPPacketIrpEvent->Length = 3;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = TWOBYTE_LOWBYTE(logicHandle);\r\nPPacketIrpEvent->Data[2] = TWOBYTE_HIGHTBYTE(logicHandle);\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 5);\r\n}\r\nstatic void\r\nbthci_EventExtWifiScanNotify(\r\nstruct rtw_adapter *padapter,\r\nu8 scanType\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 len = 0;\r\nu8 localBuf[7] = "";\r\nu8 *pRetPar;\r\nu8 *pu1Temp;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!pBtMgnt->BtOperationOn)\r\nreturn;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_ExtensionEventHeaderRtk(&localBuf[0], HCI_EVENT_EXT_WIFI_SCAN_NOTIFY);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npu1Temp = (u8 *)&pRetPar[0];\r\n*pu1Temp = scanType;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nif (bthci_IndicateEvent(padapter, PPacketIrpEvent, len+2) == RT_STATUS_SUCCESS) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Wifi scan notify, scan type = %d\n",\r\nscanType));\r\n}\r\n}\r\nstatic void\r\nbthci_EventAMPReceiverReport(\r\nstruct rtw_adapter *padapter,\r\nu8 Reason\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (pBtHciInfo->bTestNeedReport) {\r\nu8 localBuf[20] = "";\r\nu32 *pu4Temp;\r\nu16 *pu2Temp;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), (" HCI_EVENT_AMP_RECEIVER_REPORT\n"));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_AMP_RECEIVER_REPORT;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = pBtHciInfo->TestCtrType;\r\nPPacketIrpEvent->Data[1] = Reason;\r\npu4Temp = (u32 *)&PPacketIrpEvent->Data[2];\r\n*pu4Temp = pBtHciInfo->TestEventType;\r\npu2Temp = (u16 *)&PPacketIrpEvent->Data[6];\r\n*pu2Temp = pBtHciInfo->TestNumOfFrame;\r\npu2Temp = (u16 *)&PPacketIrpEvent->Data[8];\r\n*pu2Temp = pBtHciInfo->TestNumOfErrFrame;\r\npu4Temp = (u32 *)&PPacketIrpEvent->Data[10];\r\n*pu4Temp = pBtHciInfo->TestNumOfBits;\r\npu4Temp = (u32 *)&PPacketIrpEvent->Data[14];\r\n*pu4Temp = pBtHciInfo->TestNumOfErrBits;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 20);\r\n}\r\npBtHciInfo->TestNumOfFrame = 0x00;\r\n}\r\nstatic void\r\nbthci_EventChannelSelected(\r\nstruct rtw_adapter *padapter,\r\nu8 EntryNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[3] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_CHANNEL_SELECT)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Channel Selected, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT|IOCTL_STATE,\r\n("[BT event], Channel Selected, PhyLinkHandle %d\n",\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_CHANNEL_SELECT;\r\nPPacketIrpEvent->Length = 1;\r\nPPacketIrpEvent->Data[0] = pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 3);\r\n}\r\nstatic void\r\nbthci_EventDisconnectPhyLinkComplete(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nenum hci_status Reason,\r\nu8 EntryNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[5] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_DISCONNECT_PHY_LINK_COMPLETE)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Disconnect Physical Link Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Disconnect Physical Link Complete, Status = 0x%x, PLH = 0x%x Reason = 0x%x\n",\r\nHciStatus, pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle, Reason));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_DISCONNECT_PHY_LINK_COMPLETE;\r\nPPacketIrpEvent->Length = 3;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\nPPacketIrpEvent->Data[2] = Reason;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 5);\r\n}\r\nstatic void\r\nbthci_EventPhysicalLinkComplete(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nu8 EntryNum,\r\nu8 PLHandle\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 localBuf[4] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu8 PL_handle;\r\npBtMgnt->bPhyLinkInProgress = false;\r\npBtDbg->dbgHciInfo.hciCmdPhyLinkStatus = HciStatus;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_PHY_LINK_COMPLETE)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Physical Link Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nif (EntryNum == 0xff) {\r\nPL_handle = PLHandle;\r\n} else {\r\nPL_handle = pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\npBTInfo->BtAsocEntry[EntryNum].bNeedPhysLinkCompleteEvent = false;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Physical Link Complete, Status = 0x%x PhyLinkHandle = 0x%x\n", HciStatus,\r\nPL_handle));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_PHY_LINK_COMPLETE;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = PL_handle;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\n}\r\nstatic void\r\nbthci_EventCommandStatus(\r\nstruct rtw_adapter *padapter,\r\nu8 OGF,\r\nu16 OCF,\r\nenum hci_status HciStatus\r\n)\r\n{\r\nu8 localBuf[6] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu8 Num_Hci_Comm = 0x1;\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], CommandStatus, Opcode = 0x%02x%02x, OGF = 0x%x, OCF = 0x%x, Status = 0x%x, Num_HCI_COMM = 0x%x\n",\r\n(HCIOPCODEHIGHT(OCF, OGF)), (HCIOPCODELOW(OCF, OGF)), OGF, OCF, HciStatus, Num_Hci_Comm));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_COMMAND_STATUS;\r\nPPacketIrpEvent->Length = 4;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = Num_Hci_Comm;\r\nPPacketIrpEvent->Data[2] = HCIOPCODELOW(OCF, OGF);\r\nPPacketIrpEvent->Data[3] = HCIOPCODEHIGHT(OCF, OGF);\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 6);\r\n}\r\nstatic void\r\nbthci_EventLogicalLinkComplete(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nu8 PhyLinkHandle,\r\nu16 LogLinkHandle,\r\nu8 LogLinkIndex,\r\nu8 EntryNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[7] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_LOGICAL_LINK_COMPLETE)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT,\r\n("[BT event], Logical Link Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Logical Link Complete, PhyLinkHandle = 0x%x, LogLinkHandle = 0x%x, Status = 0x%x\n",\r\nPhyLinkHandle, LogLinkHandle, HciStatus));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_LOGICAL_LINK_COMPLETE;\r\nPPacketIrpEvent->Length = 5;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = TWOBYTE_LOWBYTE(LogLinkHandle);\r\nPPacketIrpEvent->Data[2] = TWOBYTE_HIGHTBYTE(LogLinkHandle);\r\nPPacketIrpEvent->Data[3] = TWOBYTE_LOWBYTE(PhyLinkHandle);\r\nif (HciStatus == HCI_STATUS_SUCCESS) {\r\nPPacketIrpEvent->Data[4] =\r\npBTInfo->BtAsocEntry[EntryNum].LogLinkCmdData[LogLinkIndex].Tx_Flow_Spec.Identifier;\r\n} else {\r\nPPacketIrpEvent->Data[4] = 0x0;\r\n}\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 7);\r\n}\r\nstatic void\r\nbthci_EventDisconnectLogicalLinkComplete(\r\nstruct rtw_adapter *padapter,\r\nenum hci_status HciStatus,\r\nu16 LogLinkHandle,\r\nenum hci_status Reason\r\n)\r\n{\r\nu8 localBuf[6] = "";\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_DISCONNECT_LOGICAL_LINK_COMPLETE)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Disconnect Logical Link Complete, Ignore to send this event due to event mask page 2\n"));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Disconnect Logical Link Complete, Status = 0x%x, LLH = 0x%x Reason = 0x%x\n", HciStatus, LogLinkHandle, Reason));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_DISCONNECT_LOGICAL_LINK_COMPLETE;\r\nPPacketIrpEvent->Length = 4;\r\nPPacketIrpEvent->Data[0] = HciStatus;\r\nPPacketIrpEvent->Data[1] = TWOBYTE_LOWBYTE(LogLinkHandle);\r\nPPacketIrpEvent->Data[2] = TWOBYTE_HIGHTBYTE(LogLinkHandle);\r\nPPacketIrpEvent->Data[3] = Reason;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 6);\r\n}\r\nstatic void\r\nbthci_EventFlushOccurred(\r\nstruct rtw_adapter *padapter,\r\nu16 LogLinkHandle\r\n)\r\n{\r\nu8 localBuf[4] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("bthci_EventFlushOccurred(), LLH = 0x%x\n", LogLinkHandle));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_FLUSH_OCCRUED;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = TWOBYTE_LOWBYTE(LogLinkHandle);\r\nPPacketIrpEvent->Data[1] = TWOBYTE_HIGHTBYTE(LogLinkHandle);\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\n}\r\nstatic enum hci_status\r\nbthci_BuildPhysicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd,\r\nu16 OCF\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 EntryNum, PLH;\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nOCF,\r\nHCI_STATUS_SUCCESS);\r\nPLH = *((u8 *)pHciCmd->Data);\r\nif (!bthci_AddEntry(padapter)) {\r\nstatus = HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE;\r\nbthci_EventPhysicalLinkComplete(padapter, status, INVALID_ENTRY_NUM, PLH);\r\nreturn status;\r\n}\r\nEntryNum = pBtMgnt->CurrentConnectEntryNum;\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle = PLH;\r\npBtMgnt->BtCurrentPhyLinkhandle = PLH;\r\nif (pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.AMPAssocfragment == NULL) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Create/Accept PhysicalLink, AMP controller is busy\n"));\r\nstatus = HCI_STATUS_CONTROLLER_BUSY;\r\nbthci_EventPhysicalLinkComplete(padapter, status, INVALID_ENTRY_NUM, PLH);\r\nreturn status;\r\n}\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen = (*((u8 *)pHciCmd->Data+1));\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyType = (*((u8 *)pHciCmd->Data+2));\r\nmemcpy(pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKey,\r\n(((u8 *)pHciCmd->Data+3)), pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen);\r\nmemcpy(pBTInfo->BtAsocEntry[EntryNum].PMK, pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKey, PMK_LEN);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("BuildPhysicalLink, EntryNum = %d, PLH = 0x%x KeyLen = 0x%x, KeyType = 0x%x\n",\r\nEntryNum, pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyType));\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_LOGO|IOCTL_BT_HCICMD), ("BtAMPKey\n"), pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKey,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtAMPKeyLen);\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_LOGO|IOCTL_BT_HCICMD), ("PMK\n"), pBTInfo->BtAsocEntry[EntryNum].PMK,\r\nPMK_LEN);\r\nif (OCF == HCI_CREATE_PHYSICAL_LINK) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTED, STATE_CMD_CREATE_PHY_LINK, EntryNum);\r\n} else if (OCF == HCI_ACCEPT_PHYSICAL_LINK) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTED, STATE_CMD_ACCEPT_PHY_LINK, EntryNum);\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nbthci_BuildLogicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd,\r\nu16 OCF\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTinfo->BtMgnt;\r\nu8 PhyLinkHandle, EntryNum;\r\nstatic u16 AssignLogHandle = 1;\r\nstruct hci_flow_spec TxFlowSpec;\r\nstruct hci_flow_spec RxFlowSpec;\r\nu32 MaxSDUSize, ArriveTime, Bandwidth;\r\nPhyLinkHandle = *((u8 *)pHciCmd->Data);\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, PhyLinkHandle);\r\nmemcpy(&TxFlowSpec,\r\n&pHciCmd->Data[1], sizeof(struct hci_flow_spec));\r\nmemcpy(&RxFlowSpec,\r\n&pHciCmd->Data[17], sizeof(struct hci_flow_spec));\r\nMaxSDUSize = TxFlowSpec.MaximumSDUSize;\r\nArriveTime = TxFlowSpec.SDUInterArrivalTime;\r\nif (bthci_CheckLogLinkBehavior(padapter, TxFlowSpec) && bthci_CheckLogLinkBehavior(padapter, RxFlowSpec))\r\nBandwidth = BTTOTALBANDWIDTH;\r\nelse if (MaxSDUSize == 0xffff && ArriveTime == 0xffffffff)\r\nBandwidth = BTTOTALBANDWIDTH;\r\nelse\r\nBandwidth = MaxSDUSize*8*1000/(ArriveTime+244);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD,\r\n("BuildLogicalLink, PhyLinkHandle = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, Bandwidth = 0x%x\n",\r\nPhyLinkHandle, MaxSDUSize, ArriveTime, Bandwidth));\r\nif (EntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Invalid Physical Link handle = 0x%x, status = HCI_STATUS_UNKNOW_CONNECT_ID, return\n", PhyLinkHandle));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nOCF,\r\nstatus);\r\nreturn;\r\n}\r\nif (!pBtMgnt->bLogLinkInProgress) {\r\nif (bthci_PhyLinkConnectionInProgress(padapter, PhyLinkHandle)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Physical link connection in progress, status = HCI_STATUS_CMD_DISALLOW, return\n"));\r\nstatus = HCI_STATUS_CMD_DISALLOW;\r\npBtMgnt->bPhyLinkInProgressStartLL = true;\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nOCF,\r\nstatus);\r\nreturn;\r\n}\r\nif (Bandwidth > BTTOTALBANDWIDTH) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("status = HCI_STATUS_QOS_REJECT, Bandwidth = 0x%x, return\n", Bandwidth));\r\nstatus = HCI_STATUS_QOS_REJECT;\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nOCF,\r\nstatus);\r\n} else {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("status = HCI_STATUS_SUCCESS\n"));\r\nstatus = HCI_STATUS_SUCCESS;\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nOCF,\r\nstatus);\r\n}\r\nif (pBTinfo->BtAsocEntry[EntryNum].BtCurrentState != HCI_STATE_CONNECTED) {\r\nbthci_EventLogicalLinkComplete(padapter,\r\nHCI_STATUS_CMD_DISALLOW, 0, 0, 0, EntryNum);\r\n} else {\r\nu8 i, find = 0;\r\npBtMgnt->bLogLinkInProgress = true;\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtLogLinkhandle == 0) {\r\nenum hci_status LogCompEventstatus = HCI_STATUS_SUCCESS;\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtPhyLinkhandle = *((u8 *)pHciCmd->Data);\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtLogLinkhandle = AssignLogHandle;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("BuildLogicalLink, EntryNum = %d, physical link handle = 0x%x, logical link handle = 0x%x\n",\r\nEntryNum, pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle,\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtLogLinkhandle));\r\nmemcpy(&pBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].Tx_Flow_Spec,\r\n&TxFlowSpec, sizeof(struct hci_flow_spec));\r\nmemcpy(&pBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].Rx_Flow_Spec,\r\n&RxFlowSpec, sizeof(struct hci_flow_spec));\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].bLLCompleteEventIsSet = false;\r\nif (pBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].bLLCancelCMDIsSetandComplete)\r\nLogCompEventstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nbthci_EventLogicalLinkComplete(padapter,\r\nLogCompEventstatus,\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtPhyLinkhandle,\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].BtLogLinkhandle, i, EntryNum);\r\npBTinfo->BtAsocEntry[EntryNum].LogLinkCmdData[i].bLLCompleteEventIsSet = true;\r\nfind = 1;\r\npBtMgnt->BtCurrentLogLinkhandle = AssignLogHandle;\r\nAssignLogHandle++;\r\nbreak;\r\n}\r\n}\r\nif (!find) {\r\nbthci_EventLogicalLinkComplete(padapter,\r\nHCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE, 0, 0, 0, EntryNum);\r\n}\r\npBtMgnt->bLogLinkInProgress = false;\r\n}\r\n} else {\r\nbthci_EventLogicalLinkComplete(padapter,\r\nHCI_STATUS_CONTROLLER_BUSY, 0, 0, 0, EntryNum);\r\n}\r\n}\r\nstatic void\r\nbthci_StartBeaconAndConnect(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd,\r\nu8 CurrentAssocNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("StartBeaconAndConnect, CurrentAssocNum =%d, AMPRole =%d\n",\r\nCurrentAssocNum,\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AMPRole));\r\nif (!pBtMgnt->CheckChnlIsSuit) {\r\nbthci_EventPhysicalLinkComplete(padapter, HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND, CurrentAssocNum, INVALID_PL_HANDLE);\r\nbthci_RemoveEntryByEntryNum(padapter, CurrentAssocNum);\r\nreturn;\r\n}\r\nif (pBTInfo->BtAsocEntry[CurrentAssocNum].AMPRole == AMP_BTAP_CREATOR) {\r\nrsprintf((char *)pBTInfo->BtAsocEntry[CurrentAssocNum].BTSsidBuf, 32, "AMP-%02x-%02x-%02x-%02x-%02x-%02x",\r\npadapter->eeprompriv.mac_addr[0],\r\npadapter->eeprompriv.mac_addr[1],\r\npadapter->eeprompriv.mac_addr[2],\r\npadapter->eeprompriv.mac_addr[3],\r\npadapter->eeprompriv.mac_addr[4],\r\npadapter->eeprompriv.mac_addr[5]);\r\n} else if (pBTInfo->BtAsocEntry[CurrentAssocNum].AMPRole == AMP_BTAP_JOINER) {\r\nrsprintf((char *)pBTInfo->BtAsocEntry[CurrentAssocNum].BTSsidBuf, 32, "AMP-%02x-%02x-%02x-%02x-%02x-%02x",\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[0],\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[1],\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[2],\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[3],\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[4],\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTRemoteMACAddr[5]);\r\n}\r\nFillOctetString(pBTInfo->BtAsocEntry[CurrentAssocNum].BTSsid, pBTInfo->BtAsocEntry[CurrentAssocNum].BTSsidBuf, 21);\r\npBTInfo->BtAsocEntry[CurrentAssocNum].BTSsid.Length = 21;\r\nif (!pBtMgnt->bBTConnectInProgress) {\r\npBtMgnt->bBTConnectInProgress = true;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], BT Connect in progress ON!!\n"));\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_STARTING, STATE_CMD_MAC_START_COMPLETE, CurrentAssocNum);\r\nif (!bthci_CheckRfStateBeforeConnect(padapter))\r\nreturn;\r\nif (pBTInfo->BtAsocEntry[CurrentAssocNum].AMPRole == AMP_BTAP_CREATOR) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_CONNECTING, STATE_CMD_MAC_CONNECT_COMPLETE, CurrentAssocNum);\r\n} else if (pBTInfo->BtAsocEntry[CurrentAssocNum].AMPRole == AMP_BTAP_JOINER) {\r\nbthci_ResponderStartToScan(padapter);\r\n}\r\n}\r\nRT_PRINT_STR(_module_rtl871x_mlme_c_, _drv_notice_,\r\n"StartBeaconAndConnect, SSID:\n",\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].BTSsid.Octet,\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].BTSsid.Length);\r\n}\r\nstatic void bthci_ResetBtMgnt(struct bt_mgnt *pBtMgnt)\r\n{\r\npBtMgnt->BtOperationOn = false;\r\npBtMgnt->bBTConnectInProgress = false;\r\npBtMgnt->bLogLinkInProgress = false;\r\npBtMgnt->bPhyLinkInProgress = false;\r\npBtMgnt->bPhyLinkInProgressStartLL = false;\r\npBtMgnt->DisconnectEntryNum = 0xff;\r\npBtMgnt->bStartSendSupervisionPkt = false;\r\npBtMgnt->JoinerNeedSendAuth = false;\r\npBtMgnt->CurrentBTConnectionCnt = 0;\r\npBtMgnt->BTCurrentConnectType = BT_DISCONNECT;\r\npBtMgnt->BTReceiveConnectPkt = BT_DISCONNECT;\r\npBtMgnt->BTAuthCount = 0;\r\npBtMgnt->btLogoTest = 0;\r\n}\r\nstatic void bthci_ResetBtHciInfo(struct bt_hci_info *pBtHciInfo)\r\n{\r\npBtHciInfo->BTEventMask = 0;\r\npBtHciInfo->BTEventMaskPage2 = 0;\r\npBtHciInfo->ConnAcceptTimeout = 10000;\r\npBtHciInfo->PageTimeout = 0x30;\r\npBtHciInfo->LocationDomainAware = 0x0;\r\npBtHciInfo->LocationDomain = 0x5858;\r\npBtHciInfo->LocationDomainOptions = 0x58;\r\npBtHciInfo->LocationOptions = 0x0;\r\npBtHciInfo->FlowControlMode = 0x1;\r\npBtHciInfo->enFlush_LLH = 0;\r\npBtHciInfo->FLTO_LLH = 0;\r\npBtHciInfo->bTestIsEnd = true;\r\npBtHciInfo->bInTestMode = false;\r\npBtHciInfo->bTestNeedReport = false;\r\npBtHciInfo->TestScenario = 0xff;\r\npBtHciInfo->TestReportInterval = 0x01;\r\npBtHciInfo->TestCtrType = 0x5d;\r\npBtHciInfo->TestEventType = 0x00;\r\npBtHciInfo->TestNumOfFrame = 0;\r\npBtHciInfo->TestNumOfErrFrame = 0;\r\npBtHciInfo->TestNumOfBits = 0;\r\npBtHciInfo->TestNumOfErrBits = 0;\r\n}\r\nstatic void bthci_ResetBtSec(struct rtw_adapter *padapter, struct bt_security *pBtSec)\r\n{\r\nif (GET_HAL_DATA(padapter)->bBTMode)\r\npBtSec->bUsedHwEncrypt = true;\r\nelse\r\npBtSec->bUsedHwEncrypt = false;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_info_,\r\n"%s: bUsedHwEncrypt =%d\n", __func__, pBtSec->bUsedHwEncrypt);\r\npBtSec->RSNIE.Octet = pBtSec->RSNIEBuf;\r\n}\r\nstatic void bthci_ResetBtExtInfo(struct bt_mgnt *pBtMgnt)\r\n{\r\nu8 i;\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle = 0;\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode = 0;\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode = 0;\r\npBtMgnt->ExtConfig.linkInfo[i].BTProfile = BT_PROFILE_NONE;\r\npBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec = BT_SPEC_2_1_EDR;\r\npBtMgnt->ExtConfig.linkInfo[i].BT_RSSI = 0;\r\npBtMgnt->ExtConfig.linkInfo[i].TrafficProfile = BT_PROFILE_NONE;\r\npBtMgnt->ExtConfig.linkInfo[i].linkRole = BT_LINK_MASTER;\r\n}\r\npBtMgnt->ExtConfig.CurrentConnectHandle = 0;\r\npBtMgnt->ExtConfig.CurrentIncomingTrafficMode = 0;\r\npBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = 0;\r\npBtMgnt->ExtConfig.MIN_BT_RSSI = 0;\r\npBtMgnt->ExtConfig.NumberOfHandle = 0;\r\npBtMgnt->ExtConfig.NumberOfSCO = 0;\r\npBtMgnt->ExtConfig.CurrentBTStatus = 0;\r\npBtMgnt->ExtConfig.HCIExtensionVer = 0;\r\npBtMgnt->ExtConfig.bManualControl = false;\r\npBtMgnt->ExtConfig.bBTBusy = false;\r\npBtMgnt->ExtConfig.bBTA2DPBusy = false;\r\n}\r\nstatic enum hci_status bthci_CmdReset(struct rtw_adapter *_padapter, u8 bNeedSendEvent)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct rtw_adapter *padapter;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_hci_info *pBtHciInfo;\r\nstruct bt_security *pBtSec;\r\nstruct bt_dgb *pBtDbg;\r\nu8 i;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("bthci_CmdReset()\n"));\r\npadapter = GetDefaultAdapter(_padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtHciInfo = &pBTInfo->BtHciInfo;\r\npBtSec = &pBTInfo->BtSec;\r\npBtDbg = &pBTInfo->BtDbg;\r\npBTInfo->padapter = padapter;\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++)\r\nbthci_ResetEntry(padapter, i);\r\nbthci_ResetBtMgnt(pBtMgnt);\r\nbthci_ResetBtHciInfo(pBtHciInfo);\r\nbthci_ResetBtSec(padapter, pBtSec);\r\npBtMgnt->BTChannel = BT_Default_Chnl;\r\npBtMgnt->CheckChnlIsSuit = true;\r\npBTInfo->BTBeaconTmrOn = false;\r\npBtMgnt->bCreateSpportQos = true;\r\ndel_timer_sync(&pBTInfo->BTHCIDiscardAclDataTimer);\r\ndel_timer_sync(&pBTInfo->BTBeaconTimer);\r\nHALBT_SetRtsCtsNoLenLimit(padapter);\r\nbthci_ResetBtExtInfo(pBtMgnt);\r\nif (bNeedSendEvent) {\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_RESET,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteRemoteAMPAssoc(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 CurrentAssocNum;\r\nu8 PhyLinkHandle;\r\npBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc++;\r\nPhyLinkHandle = *((u8 *)pHciCmd->Data);\r\nCurrentAssocNum = bthci_GetCurrentEntryNum(padapter, PhyLinkHandle);\r\nif (CurrentAssocNum == 0xff) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("WriteRemoteAMPAssoc, No such Handle in the Entry\n"));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nbthci_EventWriteRemoteAmpAssoc(padapter, status, PhyLinkHandle);\r\nreturn status;\r\n}\r\nif (pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment == NULL) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("WriteRemoteAMPAssoc, AMP controller is busy\n"));\r\nstatus = HCI_STATUS_CONTROLLER_BUSY;\r\nbthci_EventWriteRemoteAmpAssoc(padapter, status, PhyLinkHandle);\r\nreturn status;\r\n}\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.BtPhyLinkhandle = PhyLinkHandle;\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.LenSoFar = *((u16 *)((u8 *)pHciCmd->Data+1));\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen = *((u16 *)((u8 *)pHciCmd->Data+3));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("WriteRemoteAMPAssoc, LenSoFar = 0x%x, AssocRemLen = 0x%x\n",\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.LenSoFar,\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen));\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO),\r\n("WriteRemoteAMPAssoc fragment \n"),\r\npHciCmd->Data,\r\npBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen+5);\r\nif ((pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen) > MAX_AMP_ASSOC_FRAG_LEN) {\r\nmemcpy(((u8 *)pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment+(pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.LenSoFar*(sizeof(u8)))),\r\n(u8 *)pHciCmd->Data+5,\r\nMAX_AMP_ASSOC_FRAG_LEN);\r\n} else {\r\nmemcpy((u8 *)(pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment)+(pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.LenSoFar*(sizeof(u8))),\r\n((u8 *)pHciCmd->Data+5),\r\n(pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen));\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), "WriteRemoteAMPAssoc :\n",\r\npHciCmd->Data+5, pBTInfo->BtAsocEntry[CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);\r\nif (!bthci_GetAssocInfo(padapter, CurrentAssocNum))\r\nstatus = HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE;\r\nbthci_EventWriteRemoteAmpAssoc(padapter, status, PhyLinkHandle);\r\nbthci_StartBeaconAndConnect(padapter, pHciCmd, CurrentAssocNum);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadConnectionAcceptTimeout(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_CONNECTION_ACCEPT_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = pBtHciInfo->ConnAcceptTimeout;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteConnectionAcceptTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu16 *pu2Temp;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npu2Temp = (u16 *)&pHciCmd->Data[0];\r\npBtHciInfo->ConnAcceptTimeout = *pu2Temp;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("ConnAcceptTimeout = 0x%x",\r\npBtHciInfo->ConnAcceptTimeout));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_CONNECTION_ACCEPT_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadPageTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_PAGE_TIMEOUT,\r\nstatus);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Read PageTimeout = 0x%x\n", pBtHciInfo->PageTimeout));\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = pBtHciInfo->PageTimeout;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWritePageTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu16 *pu2Temp;\r\npu2Temp = (u16 *)&pHciCmd->Data[0];\r\npBtHciInfo->PageTimeout = *pu2Temp;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Write PageTimeout = 0x%x\n",\r\npBtHciInfo->PageTimeout));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_PAGE_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadLinkSupervisionTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nu8 physicalLinkHandle, EntryNum;\r\nphysicalLinkHandle = *((u8 *)pHciCmd->Data);\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, physicalLinkHandle);\r\nif (EntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("ReadLinkSupervisionTimeout, No such Handle in the Entry\n"));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nreturn status;\r\n}\r\nif (pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle != physicalLinkHandle)\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n{\r\nu8 localBuf[10] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_LINK_SUPERVISION_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\npRetPar[2] = 0;\r\npu2Temp = (u16 *)&pRetPar[3];\r\n*pu2Temp = pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.LinkSuperversionTimeout;\r\nlen += 5;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteLinkSupervisionTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nu8 physicalLinkHandle, EntryNum;\r\nphysicalLinkHandle = *((u8 *)pHciCmd->Data);\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, physicalLinkHandle);\r\nif (EntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("WriteLinkSupervisionTimeout, No such Handle in the Entry\n"));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n} else {\r\nif (pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle != physicalLinkHandle) {\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n} else {\r\npBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = *((u16 *)(((u8 *)pHciCmd->Data)+2));\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("BT Write LinkSuperversionTimeout[%d] = 0x%x\n",\r\nEntryNum, pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.LinkSuperversionTimeout));\r\n}\r\n}\r\n{\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_LINK_SUPERVISION_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = pBTinfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\npRetPar[2] = 0;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdEnhancedFlush(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTinfo->BtHciInfo;\r\nu16 logicHandle;\r\nu8 Packet_Type;\r\nlogicHandle = *((u16 *)&pHciCmd->Data[0]);\r\nPacket_Type = pHciCmd->Data[2];\r\nif (Packet_Type != 0)\r\nstatus = HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE;\r\nelse\r\npBtHciInfo->enFlush_LLH = logicHandle;\r\nif (bthci_DiscardTxPackets(padapter, pBtHciInfo->enFlush_LLH))\r\nbthci_EventFlushOccurred(padapter, pBtHciInfo->enFlush_LLH);\r\nbthci_EventCommandStatus(padapter,\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_ENHANCED_FLUSH,\r\nstatus);\r\nif (pBtHciInfo->enFlush_LLH) {\r\nbthci_EventEnhancedFlushComplete(padapter, pBtHciInfo->enFlush_LLH);\r\npBtHciInfo->enFlush_LLH = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadLogicalLinkAcceptTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = pBtHciInfo->LogicalAcceptTimeout;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteLogicalLinkAcceptTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npBtHciInfo->LogicalAcceptTimeout = *((u16 *)pHciCmd->Data);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetEventMask(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 *pu8Temp;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npu8Temp = (u8 *)&pHciCmd->Data[0];\r\npBtHciInfo->BTEventMask = *pu8Temp;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("BTEventMask = 0x%"i64fmt"x\n",\r\npBtHciInfo->BTEventMask));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_SET_EVENT_MASK,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetEventMaskPage2(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 *pu8Temp;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npu8Temp = (u8 *)&pHciCmd->Data[0];\r\npBtHciInfo->BTEventMaskPage2 = *pu8Temp;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("BTEventMaskPage2 = 0x%"i64fmt"x\n",\r\npBtHciInfo->BTEventMaskPage2));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_SET_EVENT_MASK_PAGE_2,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadLocationData(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[12] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_LOCATION_DATA,\r\nstatus);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DomainAware = 0x%x\n", pBtHciInfo->LocationDomainAware));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Domain = 0x%x\n", pBtHciInfo->LocationDomain));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DomainOptions = 0x%x\n", pBtHciInfo->LocationDomainOptions));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Options = 0x%x\n", pBtHciInfo->LocationOptions));\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = pBtHciInfo->LocationDomainAware;\r\npu2Temp = (u16 *)&pRetPar[2];\r\n*pu2Temp = pBtHciInfo->LocationDomain;\r\npRetPar[4] = pBtHciInfo->LocationDomainOptions;\r\npRetPar[5] = pBtHciInfo->LocationOptions;\r\nlen += 6;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteLocationData(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu16 *pu2Temp;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npBtHciInfo->LocationDomainAware = pHciCmd->Data[0];\r\npu2Temp = (u16 *)&pHciCmd->Data[1];\r\npBtHciInfo->LocationDomain = *pu2Temp;\r\npBtHciInfo->LocationDomainOptions = pHciCmd->Data[3];\r\npBtHciInfo->LocationOptions = pHciCmd->Data[4];\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DomainAware = 0x%x\n", pBtHciInfo->LocationDomainAware));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Domain = 0x%x\n", pBtHciInfo->LocationDomain));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DomainOptions = 0x%x\n", pBtHciInfo->LocationDomainOptions));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Options = 0x%x\n", pBtHciInfo->LocationOptions));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_LOCATION_DATA,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadFlowControlMode(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[7] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_FLOW_CONTROL_MODE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = pBtHciInfo->FlowControlMode;\r\nlen += 2;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteFlowControlMode(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\npBtHciInfo->FlowControlMode = pHciCmd->Data[0];\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_FLOW_CONTROL_MODE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadBestEffortFlushTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nu16 i, j, logicHandle;\r\nu32 BestEffortFlushTimeout = 0xffffffff;\r\nu8 find = 0;\r\nlogicHandle = *((u16 *)pHciCmd->Data);\r\nfor (j = 0; j < MAX_BT_ASOC_ENTRY_NUM; j++) {\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle == logicHandle) {\r\nBestEffortFlushTimeout = pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BestEffortFlushTimeout;\r\nfind = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!find)\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n{\r\nu8 localBuf[10] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu32 *pu4Temp;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_READ_BEST_EFFORT_FLUSH_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu4Temp = (u32 *)&pRetPar[1];\r\n*pu4Temp = BestEffortFlushTimeout;\r\nlen += 5;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWriteBestEffortFlushTimeout(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nu16 i, j, logicHandle;\r\nu32 BestEffortFlushTimeout = 0xffffffff;\r\nu8 find = 0;\r\nlogicHandle = *((u16 *)pHciCmd->Data);\r\nBestEffortFlushTimeout = *((u32 *)(pHciCmd->Data+1));\r\nfor (j = 0; j < MAX_BT_ASOC_ENTRY_NUM; j++) {\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle == logicHandle) {\r\npBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BestEffortFlushTimeout = BestEffortFlushTimeout;\r\nfind = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!find)\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdShortRangeMode(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nu8 PhyLinkHandle, EntryNum, ShortRangeMode;\r\nPhyLinkHandle = pHciCmd->Data[0];\r\nShortRangeMode = pHciCmd->Data[1];\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("PLH = 0x%x, Short_Range_Mode = 0x%x\n", PhyLinkHandle, ShortRangeMode));\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, PhyLinkHandle);\r\nif (EntryNum != 0xff) {\r\npBTInfo->BtAsocEntry[EntryNum].ShortRangeMode = ShortRangeMode;\r\n} else {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("No such PLH(0x%x)\n", PhyLinkHandle));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n}\r\nbthci_EventCommandStatus(padapter,\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_SHORT_RANGE_MODE,\r\nstatus);\r\nbthci_EventShortRangeModeChangeComplete(padapter, status, ShortRangeMode, EntryNum);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadLocalSupportedCommands(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar, *pSupportedCmds;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_INFORMATIONAL_PARAMETERS,\r\nHCI_READ_LOCAL_SUPPORTED_COMMANDS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\npSupportedCmds = &pRetPar[1];\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[5]= 0xc0\nBit [6]= Set Event Mask, [7]= Reset\n"));\r\npSupportedCmds[5] = 0xc0;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[6]= 0x01\nBit [0]= Set Event Filter\n"));\r\npSupportedCmds[6] = 0x01;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[7]= 0x0c\nBit [2]= Read Connection Accept Timeout, [3]= Write Connection Accept Timeout\n"));\r\npSupportedCmds[7] = 0x0c;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[10]= 0x80\nBit [7]= Host Number Of Completed Packets\n"));\r\npSupportedCmds[10] = 0x80;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[11]= 0x03\nBit [0]= Read Link Supervision Timeout, [1]= Write Link Supervision Timeout\n"));\r\npSupportedCmds[11] = 0x03;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[14]= 0xa8\nBit [3]= Read Local Version Information, [5]= Read Local Supported Features, [7]= Read Buffer Size\n"));\r\npSupportedCmds[14] = 0xa8;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[15]= 0x1c\nBit [2]= Read Failed Contact Count, [3]= Reset Failed Contact Count, [4]= Get Link Quality\n"));\r\npSupportedCmds[15] = 0x1c;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[19]= 0x40\nBit [6]= Enhanced Flush\n"));\r\npSupportedCmds[19] = 0x40;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[21]= 0xff\nBit [0]= Create Physical Link, [1]= Accept Physical Link, [2]= Disconnect Physical Link, [3]= Create Logical Link\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), (" [4]= Accept Logical Link, [5]= Disconnect Logical Link, [6]= Logical Link Cancel, [7]= Flow Spec Modify\n"));\r\npSupportedCmds[21] = 0xff;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[22]= 0xff\nBit [0]= Read Logical Link Accept Timeout, [1]= Write Logical Link Accept Timeout, [2]= Set Event Mask Page 2, [3]= Read Location Data\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), (" [4]= Write Location Data, [5]= Read Local AMP Info, [6]= Read Local AMP_ASSOC, [7]= Write Remote AMP_ASSOC\n"));\r\npSupportedCmds[22] = 0xff;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[23]= 0x07\nBit [0]= Read Flow Control Mode, [1]= Write Flow Control Mode, [2]= Read Data Block Size\n"));\r\npSupportedCmds[23] = 0x07;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD|IOCTL_BT_LOGO), ("Octet[24]= 0x1c\nBit [2]= Read Best Effort Flush Timeout, [3]= Write Best Effort Flush Timeout, [4]= Short Range Mode\n"));\r\npSupportedCmds[24] = 0x1c;\r\nlen += 64;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadLocalSupportedFeatures(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_INFORMATIONAL_PARAMETERS,\r\nHCI_READ_LOCAL_SUPPORTED_FEATURES,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 9;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadLocalAMPAssoc(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 PhyLinkHandle, EntryNum;\r\npBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc++;\r\nPhyLinkHandle = *((u8 *)pHciCmd->Data);\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, PhyLinkHandle);\r\nif ((EntryNum == 0xff) && PhyLinkHandle != 0) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("ReadLocalAMPAssoc, EntryNum = %d !!!!!, physical link handle = 0x%x\n",\r\nEntryNum, PhyLinkHandle));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n} else if (pBtMgnt->bPhyLinkInProgressStartLL) {\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\npBtMgnt->bPhyLinkInProgressStartLL = false;\r\n} else {\r\npBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.BtPhyLinkhandle = *((u8 *)pHciCmd->Data);\r\npBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar = *((u16 *)((u8 *)pHciCmd->Data+1));\r\npBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen = *((u16 *)((u8 *)pHciCmd->Data+3));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("ReadLocalAMPAssoc, LenSoFar =%d, MaxRemoteASSOCLen =%d\n",\r\npBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar,\r\npBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen));\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("ReadLocalAMPAssoc, EntryNum = %d !!!!!, physical link handle = 0x%x, LengthSoFar = %x \n",\r\nEntryNum, PhyLinkHandle, pBTInfo->BtAsocEntry[EntryNum].AmpAsocCmdData.LenSoFar));\r\n{\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu16 *pRemainLen;\r\nu32 totalLen = 0;\r\nu16 typeLen = 0, remainLen = 0, ret_index = 0;\r\nu8 *pRetPar;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\ntotalLen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_READ_LOCAL_AMP_ASSOC,\r\nstatus);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("ReadLocalAMPAssoc, Remaining_Len =%d \n", remainLen));\r\npRetPar = &PPacketIrpEvent->Data[totalLen];\r\npRetPar[0] = status;\r\npRetPar[1] = *((u8 *)pHciCmd->Data);\r\npRemainLen = (u16 *)&pRetPar[2];\r\ntotalLen += 4;\r\nret_index = 4;\r\ntypeLen = bthci_AssocMACAddr(padapter, &pRetPar[ret_index]);\r\ntotalLen += typeLen;\r\nremainLen += typeLen;\r\nret_index += typeLen;\r\ntypeLen = bthci_AssocPreferredChannelList(padapter, &pRetPar[ret_index], EntryNum);\r\ntotalLen += typeLen;\r\nremainLen += typeLen;\r\nret_index += typeLen;\r\ntypeLen = bthci_PALCapabilities(padapter, &pRetPar[ret_index]);\r\ntotalLen += typeLen;\r\nremainLen += typeLen;\r\nret_index += typeLen;\r\ntypeLen = bthci_AssocPALVer(padapter, &pRetPar[ret_index]);\r\ntotalLen += typeLen;\r\nremainLen += typeLen;\r\nPPacketIrpEvent->Length = (u8)totalLen;\r\n*pRemainLen = remainLen;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("ReadLocalAMPAssoc, Remaining_Len =%d \n", remainLen));\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("AMP_ASSOC_fragment : \n"), PPacketIrpEvent->Data, totalLen);\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, totalLen+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadFailedContactCounter(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 handle;\r\nhandle = *((u16 *)pHciCmd->Data);\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_READ_FAILED_CONTACT_COUNTER,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = TWOBYTE_LOWBYTE(handle);\r\npRetPar[2] = TWOBYTE_HIGHTBYTE(handle);\r\npRetPar[3] = TWOBYTE_LOWBYTE(pBtHciInfo->FailContactCount);\r\npRetPar[4] = TWOBYTE_HIGHTBYTE(pBtHciInfo->FailContactCount);\r\nlen += 5;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdResetFailedContactCounter(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu16 handle;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nhandle = *((u16 *)pHciCmd->Data);\r\npBtHciInfo->FailContactCount = 0;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_RESET_FAILED_CONTACT_COUNTER,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = TWOBYTE_LOWBYTE(handle);\r\npRetPar[2] = TWOBYTE_HIGHTBYTE(handle);\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadLocalVersionInformation(\r\nstruct rtw_adapter *padapter\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_INFORMATIONAL_PARAMETERS,\r\nHCI_READ_LOCAL_VERSION_INFORMATION,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = 0x05;\r\npu2Temp = (u16 *)&pRetPar[2];\r\n*pu2Temp = 0x0001;\r\npRetPar[4] = 0x05;\r\npu2Temp = (u16 *)&pRetPar[5];\r\n*pu2Temp = 0x005d;\r\npu2Temp = (u16 *)&pRetPar[7];\r\n*pu2Temp = 0x0001;\r\nlen += 9;\r\nPPacketIrpEvent->Length = len;\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("LOCAL_VERSION_INFORMATION\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("Status %x\n", status));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("HCI_Version = 0x05\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("HCI_Revision = 0x0001\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("LMP/PAL_Version = 0x05\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("Manufacturer_Name = 0x0001\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("LMP/PAL_Subversion = 0x0001\n"));\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadDataBlockSize(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_INFORMATIONAL_PARAMETERS,\r\nHCI_READ_DATA_BLOCK_SIZE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = HCI_STATUS_SUCCESS;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = Max80211PALPDUSize;\r\npu2Temp = (u16 *)&pRetPar[3];\r\n*pu2Temp = Max80211PALPDUSize;\r\npu2Temp = (u16 *)&pRetPar[5];\r\n*pu2Temp = BTTotalDataBlockNum;\r\nlen += 7;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadBufferSize(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_INFORMATIONAL_PARAMETERS,\r\nHCI_READ_BUFFER_SIZE,\r\nstatus);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Synchronous_Data_Packet_Length = 0x%x\n", BTSynDataPacketLength));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Total_Num_ACL_Data_Packets = 0x%x\n", BTTotalDataBlockNum));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("Total_Num_Synchronous_Data_Packets = 0x%x\n", BTTotalDataBlockNum));\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = Max80211PALPDUSize;\r\npRetPar[3] = BTSynDataPacketLength;\r\npu2Temp = (u16 *)&pRetPar[4];\r\n*pu2Temp = BTTotalDataBlockNum;\r\npu2Temp = (u16 *)&pRetPar[6];\r\n*pu2Temp = BTTotalDataBlockNum;\r\nlen += 8;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status bthci_CmdReadLocalAMPInfo(struct rtw_adapter *padapter)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct pwrctrl_priv *ppwrctrl = &padapter->pwrctrlpriv;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\nu32 *pu4Temp;\r\nu32 TotalBandwidth = BTTOTALBANDWIDTH, MaxBandGUBandwidth = BTMAXBANDGUBANDWIDTH;\r\nu8 ControlType = 0x01, AmpStatus = 0x01;\r\nu32 MaxFlushTimeout = 10000, BestEffortFlushTimeout = 5000;\r\nu16 MaxPDUSize = Max80211PALPDUSize, PalCap = 0x1, AmpAssocLen = Max80211AMPASSOCLen, MinLatency = 20;\r\nif ((ppwrctrl->rfoff_reason & RF_CHANGE_BY_HW) ||\r\n(ppwrctrl->rfoff_reason & RF_CHANGE_BY_SW)) {\r\nAmpStatus = AMP_STATUS_NO_CAPACITY_FOR_BT;\r\n}\r\nPlatformZeroMemory(&localBuf[0], TmpLocalBufSize);\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_READ_LOCAL_AMP_INFO,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = AmpStatus;\r\npu4Temp = (u32 *)&pRetPar[2];\r\n*pu4Temp = TotalBandwidth;\r\npu4Temp = (u32 *)&pRetPar[6];\r\n*pu4Temp = MaxBandGUBandwidth;\r\npu4Temp = (u32 *)&pRetPar[10];\r\n*pu4Temp = MinLatency;\r\npu4Temp = (u32 *)&pRetPar[14];\r\n*pu4Temp = MaxPDUSize;\r\npRetPar[18] = ControlType;\r\npu2Temp = (u16 *)&pRetPar[19];\r\n*pu2Temp = PalCap;\r\npu2Temp = (u16 *)&pRetPar[21];\r\n*pu2Temp = AmpAssocLen;\r\npu4Temp = (u32 *)&pRetPar[23];\r\n*pu4Temp = MaxFlushTimeout;\r\npu4Temp = (u32 *)&pRetPar[27];\r\n*pu4Temp = BestEffortFlushTimeout;\r\nlen += 31;\r\nPPacketIrpEvent->Length = len;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("AmpStatus = 0x%x\n",\r\nAmpStatus));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("TotalBandwidth = 0x%x, MaxBandGUBandwidth = 0x%x, MinLatency = 0x%x, \n MaxPDUSize = 0x%x, ControlType = 0x%x\n",\r\nTotalBandwidth, MaxBandGUBandwidth, MinLatency, MaxPDUSize, ControlType));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("PalCap = 0x%x, AmpAssocLen = 0x%x, MaxFlushTimeout = 0x%x, BestEffortFlushTimeout = 0x%x\n",\r\nPalCap, AmpAssocLen, MaxFlushTimeout, BestEffortFlushTimeout));\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdCreatePhysicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink++;\r\nstatus = bthci_BuildPhysicalLink(padapter,\r\npHciCmd, HCI_CREATE_PHYSICAL_LINK);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdReadLinkQuality(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nu16 PLH;\r\nu8 EntryNum, LinkQuality = 0x55;\r\nPLH = *((u16 *)&pHciCmd->Data[0]);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("PLH = 0x%x\n", PLH));\r\nEntryNum = bthci_GetCurrentEntryNum(padapter, (u8)PLH);\r\nif (EntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("No such PLH(0x%x)\n", PLH));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n}\r\n{\r\nu8 localBuf[11] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_STATUS_PARAMETERS,\r\nHCI_READ_LINK_QUALITY,\r\nstatus);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, (" PLH = 0x%x\n Link Quality = 0x%x\n", PLH, LinkQuality));\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\n*((u16 *)&pRetPar[1]) = pBTInfo->BtAsocEntry[EntryNum].PhyLinkCmdData.BtPhyLinkhandle;\r\npRetPar[3] = 0x55;\r\nlen += 4;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdCreateLogicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntCreateLogLink++;\r\nbthci_BuildLogicalLink(padapter, pHciCmd,\r\nHCI_CREATE_LOGICAL_LINK);\r\nreturn HCI_STATUS_SUCCESS;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdAcceptLogicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink++;\r\nbthci_BuildLogicalLink(padapter, pHciCmd,\r\nHCI_ACCEPT_LOGICAL_LINK);\r\nreturn HCI_STATUS_SUCCESS;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdDisconnectLogicalLink(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTinfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTinfo->BtDbg;\r\nu16 logicHandle;\r\nu8 i, j, find = 0, LogLinkCount = 0;\r\npBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink++;\r\nlogicHandle = *((u16 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DisconnectLogicalLink, logicHandle = 0x%x\n", logicHandle));\r\nfor (j = 0; j < MAX_BT_ASOC_ENTRY_NUM; j++) {\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle == logicHandle) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("DisconnectLogicalLink, logicHandle is matched 0x%x\n", logicHandle));\r\nbthci_ResetFlowSpec(padapter, j, i);\r\nfind = 1;\r\npBtMgnt->DisconnectEntryNum = j;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!find)\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[pBtMgnt->DisconnectEntryNum].LogLinkCmdData[i].BtLogLinkhandle != 0)\r\nLogLinkCount++;\r\n}\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nHCI_DISCONNECT_LOGICAL_LINK,\r\nstatus);\r\nif (status == HCI_STATUS_SUCCESS) {\r\nbthci_EventDisconnectLogicalLinkComplete(padapter, status,\r\nlogicHandle, HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST);\r\n}\r\nif (LogLinkCount == 0)\r\nmod_timer(&pBTinfo->BTDisconnectPhyLinkTimer,\r\njiffies + msecs_to_jiffies(100));\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdLogicalLinkCancel(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTinfo->BtMgnt;\r\nu8 CurrentEntryNum, CurrentLogEntryNum;\r\nu8 physicalLinkHandle, TxFlowSpecID, i;\r\nu16 CurrentLogicalHandle;\r\nphysicalLinkHandle = *((u8 *)pHciCmd->Data);\r\nTxFlowSpecID = *(((u8 *)pHciCmd->Data)+1);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("LogicalLinkCancel, physicalLinkHandle = 0x%x, TxFlowSpecID = 0x%x\n",\r\nphysicalLinkHandle, TxFlowSpecID));\r\nCurrentEntryNum = pBtMgnt->CurrentConnectEntryNum;\r\nCurrentLogicalHandle = pBtMgnt->BtCurrentLogLinkhandle;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("CurrentEntryNum = 0x%x, CurrentLogicalHandle = 0x%x\n",\r\nCurrentEntryNum, CurrentLogicalHandle));\r\nCurrentLogEntryNum = 0xff;\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif ((CurrentLogicalHandle == pBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[i].BtLogLinkhandle) &&\r\n(physicalLinkHandle == pBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[i].BtPhyLinkhandle)) {\r\nCurrentLogEntryNum = i;\r\nbreak;\r\n}\r\n}\r\nif (CurrentLogEntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("LogicalLinkCancel, CurrentLogEntryNum == 0xff !!!!\n"));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nreturn status;\r\n} else {\r\nif (pBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[CurrentLogEntryNum].bLLCompleteEventIsSet) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("LogicalLinkCancel, LLCompleteEventIsSet!!!!\n"));\r\nstatus = HCI_STATUS_ACL_CONNECT_EXISTS;\r\n}\r\n}\r\n{\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nLINK_CONTROL_COMMANDS,\r\nHCI_LOGICAL_LINK_CANCEL,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = pBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[CurrentLogEntryNum].BtPhyLinkhandle;\r\npRetPar[2] = pBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[CurrentLogEntryNum].BtTxFlowSpecID;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\npBTinfo->BtAsocEntry[CurrentEntryNum].LogLinkCmdData[CurrentLogEntryNum].bLLCancelCMDIsSetandComplete = true;\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdFlowSpecModify(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTinfo = GET_BT_INFO(padapter);\r\nu8 i, j, find = 0;\r\nu16 logicHandle;\r\nlogicHandle = *((u16 *)pHciCmd->Data);\r\nfor (j = 0; j < MAX_BT_ASOC_ENTRY_NUM; j++) {\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle == logicHandle) {\r\nmemcpy(&pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].Tx_Flow_Spec,\r\n&pHciCmd->Data[2], sizeof(struct hci_flow_spec));\r\nmemcpy(&pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].Rx_Flow_Spec,\r\n&pHciCmd->Data[18], sizeof(struct hci_flow_spec));\r\nbthci_CheckLogLinkBehavior(padapter, pBTinfo->BtAsocEntry[j].LogLinkCmdData[i].Tx_Flow_Spec);\r\nfind = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_LOGO, ("FlowSpecModify, LLH = 0x%x, \n", logicHandle));\r\nbthci_EventCommandStatus(padapter,\r\nLINK_CONTROL_COMMANDS,\r\nHCI_FLOW_SPEC_MODIFY,\r\nHCI_STATUS_SUCCESS);\r\nif (!find)\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nbthci_EventSendFlowSpecModifyComplete(padapter, status, logicHandle);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdAcceptPhysicalLink(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink++;\r\nstatus = bthci_BuildPhysicalLink(padapter,\r\npHciCmd, HCI_ACCEPT_PHYSICAL_LINK);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdDisconnectPhysicalLink(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 PLH, CurrentEntryNum, PhysLinkDisconnectReason;\r\npBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink++;\r\nPLH = *((u8 *)pHciCmd->Data);\r\nPhysLinkDisconnectReason = *((u8 *)pHciCmd->Data+1);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_DISCONNECT_PHYSICAL_LINK PhyHandle = 0x%x, Reason = 0x%x\n",\r\nPLH, PhysLinkDisconnectReason));\r\nCurrentEntryNum = bthci_GetCurrentEntryNum(padapter, PLH);\r\nif (CurrentEntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD,\r\n("DisconnectPhysicalLink, No such Handle in the Entry\n"));\r\nstatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\n} else {\r\npBTInfo->BtAsocEntry[CurrentEntryNum].PhyLinkDisconnectReason =\r\n(enum hci_status)PhysLinkDisconnectReason;\r\n}\r\nbthci_EventCommandStatus(padapter, LINK_CONTROL_COMMANDS,\r\nHCI_DISCONNECT_PHYSICAL_LINK, status);\r\nif (status != HCI_STATUS_SUCCESS)\r\nreturn status;\r\nif (pBTInfo->BtAsocEntry[CurrentEntryNum].BtCurrentState == HCI_STATE_DISCONNECTED) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTED, STATE_CMD_DISCONNECT_PHY_LINK, CurrentEntryNum);\r\n} else {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTING, STATE_CMD_DISCONNECT_PHY_LINK, CurrentEntryNum);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetACLLinkDataFlowMode(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp;\r\npBtMgnt->ExtConfig.CurrentConnectHandle = *((u16 *)pHciCmd->Data);\r\npBtMgnt->ExtConfig.CurrentIncomingTrafficMode = *((u8 *)pHciCmd->Data)+2;\r\npBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = *((u8 *)pHciCmd->Data)+3;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("Connection Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic mode = 0x%x",\r\npBtMgnt->ExtConfig.CurrentConnectHandle,\r\npBtMgnt->ExtConfig.CurrentIncomingTrafficMode,\r\npBtMgnt->ExtConfig.CurrentOutgoingTrafficMode));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_SET_ACL_LINK_DATA_FLOW_MODE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npu2Temp = (u16 *)&pRetPar[1];\r\n*pu2Temp = pBtMgnt->ExtConfig.CurrentConnectHandle;\r\nlen += 3;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetACLLinkStatus(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 i;\r\nu8 *pTriple;\r\npBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus++;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_EXT, "SetACLLinkStatus, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\npBtMgnt->bSupportProfile = true;\r\npBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("NumberOfHandle = 0x%x\n", pBtMgnt->ExtConfig.NumberOfHandle));\r\npTriple = &pHciCmd->Data[1];\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle = *((u16 *)&pTriple[0]);\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode = pTriple[2];\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode = pTriple[3];\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT,\r\n("Connection_Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic Mode = 0x%x\n",\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle,\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode,\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode));\r\npTriple += 4;\r\n}\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_SET_ACL_LINK_STATUS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetSCOLinkStatus(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus++;\r\npBtMgnt->ExtConfig.NumberOfSCO = *((u8 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("NumberOfSCO = 0x%x\n",\r\npBtMgnt->ExtConfig.NumberOfSCO));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_SET_SCO_LINK_STATUS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetRSSIValue(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\ns8 min_bt_rssi = 0;\r\nu8 i;\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\nif (pBtMgnt->ExtConfig.linkInfo[i].ConnectHandle == *((u16 *)&pHciCmd->Data[0])) {\r\npBtMgnt->ExtConfig.linkInfo[i].BT_RSSI = (s8)(pHciCmd->Data[2]);\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_PERIODICAL,\r\n("Connection_Handle = 0x%x, RSSI = %d \n",\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle,\r\npBtMgnt->ExtConfig.linkInfo[i].BT_RSSI));\r\n}\r\nif (pBtMgnt->ExtConfig.linkInfo[i].BT_RSSI <= min_bt_rssi)\r\nmin_bt_rssi = pBtMgnt->ExtConfig.linkInfo[i].BT_RSSI;\r\n}\r\npBtMgnt->ExtConfig.MIN_BT_RSSI = min_bt_rssi;\r\nRTPRINT(FBT, BT_TRACE, ("[bt rssi], the min rssi is %d\n", min_bt_rssi));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_SET_RSSI_VALUE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdSetCurrentBluetoothStatus(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\npBtMgnt->ExtConfig.CurrentBTStatus = *((u8 *)&pHciCmd->Data[0]);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("SetCurrentBluetoothStatus, CurrentBTStatus = 0x%x\n",\r\npBtMgnt->ExtConfig.CurrentBTStatus));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_SET_CURRENT_BLUETOOTH_STATUS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdExtensionVersionNotify(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify++;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_EXT, "ExtensionVersionNotify, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\npBtMgnt->ExtConfig.HCIExtensionVer = *((u16 *)&pHciCmd->Data[0]);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCIExtensionVer = 0x%x\n", pBtMgnt->ExtConfig.HCIExtensionVer));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_EXTENSION_VERSION_NOTIFY,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdLinkStatusNotify(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 i;\r\nu8 *pTriple;\r\npBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify++;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_EXT, "LinkStatusNotify, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\npBtMgnt->bSupportProfile = true;\r\npBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("NumberOfHandle = 0x%x\n", pBtMgnt->ExtConfig.NumberOfHandle));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCIExtensionVer = %d\n", pBtMgnt->ExtConfig.HCIExtensionVer));\r\npTriple = &pHciCmd->Data[1];\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\nif (pBtMgnt->ExtConfig.HCIExtensionVer < 1) {\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle = *((u16 *)&pTriple[0]);\r\npBtMgnt->ExtConfig.linkInfo[i].BTProfile = pTriple[2];\r\npBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec = pTriple[3];\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT,\r\n("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d\n",\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle,\r\npBtMgnt->ExtConfig.linkInfo[i].BTProfile,\r\npBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec));\r\npTriple += 4;\r\n} else if (pBtMgnt->ExtConfig.HCIExtensionVer >= 1) {\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle = *((u16 *)&pTriple[0]);\r\npBtMgnt->ExtConfig.linkInfo[i].BTProfile = pTriple[2];\r\npBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec = pTriple[3];\r\npBtMgnt->ExtConfig.linkInfo[i].linkRole = pTriple[4];\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT,\r\n("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d, LinkRole =%d\n",\r\npBtMgnt->ExtConfig.linkInfo[i].ConnectHandle,\r\npBtMgnt->ExtConfig.linkInfo[i].BTProfile,\r\npBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec,\r\npBtMgnt->ExtConfig.linkInfo[i].linkRole));\r\npTriple += 5;\r\n}\r\n}\r\nBTHCI_UpdateBTProfileRTKToMoto(padapter);\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_LINK_STATUS_NOTIFY,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdBtOperationNotify(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_EXT, "Bt Operation notify, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\npBtMgnt->ExtConfig.btOperationCode = *((u8 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("btOperationCode = 0x%x\n", pBtMgnt->ExtConfig.btOperationCode));\r\nswitch (pBtMgnt->ExtConfig.btOperationCode) {\r\ncase HCI_BT_OP_NONE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Operation None!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_INQUIRY_START:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Inquire start!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_INQUIRY_FINISH:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Inquire finished!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_PAGING_START:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Paging is started!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_PAGING_SUCCESS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Paging complete successfully!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_PAGING_UNSUCCESS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Paging complete unsuccessfully!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_PAIRING_START:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Pairing start!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_PAIRING_FINISH:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Pairing finished!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_BT_DEV_ENABLE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : BT Device is enabled!!\n"));\r\nbreak;\r\ncase HCI_BT_OP_BT_DEV_DISABLE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : BT Device is disabled!!\n"));\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[bt operation] : Unknown, error!!\n"));\r\nbreak;\r\n}\r\nBTDM_AdjustForBtOperation(padapter);\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_BT_OPERATION_NOTIFY,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdEnableWifiScanNotify(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT_DATA(FIOCTL, IOCTL_BT_HCICMD_EXT, "Enable Wifi scan notify, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\npBtMgnt->ExtConfig.bEnableWifiScanNotify = *((u8 *)pHciCmd->Data);\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("bEnableWifiScanNotify = %d\n", pBtMgnt->ExtConfig.bEnableWifiScanNotify));\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_ENABLE_WIFI_SCAN_NOTIFY,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWIFICurrentChannel(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nu8 chnl = pmlmeext->cur_channel;\r\nif (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) {\r\nif (pmlmeext->cur_ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\nchnl += 2;\r\nelse if (pmlmeext->cur_ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\nchnl -= 2;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("Current Channel = 0x%x\n", chnl));\r\n{\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_WIFI_CURRENT_CHANNEL,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = chnl;\r\nlen += 2;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWIFICurrentBandwidth(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nenum ht_channel_width bw;\r\nu8 CurrentBW = 0;\r\nbw = padapter->mlmeextpriv.cur_bwmode;\r\nif (bw == HT_CHANNEL_WIDTH_20)\r\nCurrentBW = 0;\r\nelse if (bw == HT_CHANNEL_WIDTH_40)\r\nCurrentBW = 1;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("Current BW = 0x%x\n",\r\nCurrentBW));\r\n{\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_WIFI_CURRENT_BANDWIDTH,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = CurrentBW;\r\nlen += 2;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdWIFIConnectionStatus(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 connectStatus = HCI_WIFI_NOT_CONNECTED;\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE)) {\r\nif (padapter->stapriv.asoc_sta_count >= 3)\r\nconnectStatus = HCI_WIFI_CONNECTED;\r\nelse\r\nconnectStatus = HCI_WIFI_NOT_CONNECTED;\r\n} else if (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_ASOC_STATE)) {\r\nconnectStatus = HCI_WIFI_CONNECTED;\r\n} else if (check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING)) {\r\nconnectStatus = HCI_WIFI_CONNECT_IN_PROGRESS;\r\n} else {\r\nconnectStatus = HCI_WIFI_NOT_CONNECTED;\r\n}\r\n{\r\nu8 localBuf[8] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_EXTENSION,\r\nHCI_WIFI_CONNECTION_STATUS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\npRetPar[1] = connectStatus;\r\nlen += 2;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdEnableDeviceUnderTestMode(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\npBtHciInfo->bInTestMode = true;\r\npBtHciInfo->bTestIsEnd = false;\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_TESTING_COMMANDS,\r\nHCI_ENABLE_DEVICE_UNDER_TEST_MODE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdAMPTestEnd(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (!pBtHciInfo->bInTestMode) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n"));\r\nstatus = HCI_STATUS_CMD_DISALLOW;\r\nreturn status;\r\n}\r\npBtHciInfo->bTestIsEnd = true;\r\ndel_timer_sync(&pBTInfo->BTTestSendPacketTimer);\r\nrtl8723a_check_bssid(padapter, true);\r\n{\r\nu8 localBuf[4] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("AMP Test End Event \n"));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_AMP_TEST_END;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = status;\r\nPPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\n}\r\nbthci_EventAMPReceiverReport(padapter, 0x01);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdAMPTestCommand(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (!pBtHciInfo->bInTestMode) {\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n"));\r\nstatus = HCI_STATUS_CMD_DISALLOW;\r\nreturn status;\r\n}\r\npBtHciInfo->TestScenario = *((u8 *)pHciCmd->Data);\r\nif (pBtHciInfo->TestScenario == 0x01)\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("TX Single Test \n"));\r\nelse if (pBtHciInfo->TestScenario == 0x02)\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Receive Frame Test \n"));\r\nelse\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("No Such Test !!!!!!!!!!!!!!!!!! \n"));\r\nif (pBtHciInfo->bTestIsEnd) {\r\nu8 localBuf[5] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("AMP Test End Event \n"));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_AMP_TEST_END;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = status;\r\nPPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario ;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\nreturn status;\r\n}\r\nbthci_EventCommandStatus(padapter,\r\nOGF_TESTING_COMMANDS,\r\nHCI_AMP_TEST_COMMAND,\r\nstatus);\r\n{\r\nu8 localBuf[5] = "";\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), (" HCI_AMP_Start Test Event \n"));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nPPacketIrpEvent->EventCode = HCI_EVENT_AMP_START_TEST;\r\nPPacketIrpEvent->Length = 2;\r\nPPacketIrpEvent->Data[0] = status;\r\nPPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario ;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, 4);\r\n}\r\nif (pBtHciInfo->TestScenario == 0x01) {\r\nmod_timer(&pBTInfo->BTTestSendPacketTimer,\r\njiffies + msecs_to_jiffies(50));\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("TX Single Test \n"));\r\n} else if (pBtHciInfo->TestScenario == 0x02) {\r\nrtl8723a_check_bssid(padapter, false);\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_BT_LOGO), ("Receive Frame Test \n"));\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdEnableAMPReceiverReports(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nif (!pBtHciInfo->bInTestMode) {\r\nstatus = HCI_STATUS_CMD_DISALLOW;\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_TESTING_COMMANDS,\r\nHCI_ENABLE_AMP_RECEIVER_REPORTS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\npBtHciInfo->bTestNeedReport = *((u8 *)pHciCmd->Data);\r\npBtHciInfo->TestReportInterval = (*((u8 *)pHciCmd->Data+2));\r\nbthci_EventAMPReceiverReport(padapter, 0x00);\r\n{\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_TESTING_COMMANDS,\r\nHCI_ENABLE_AMP_RECEIVER_REPORTS,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_CmdHostBufferSize(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nu8 localBuf[6] = "";\r\nu8 *pRetPar;\r\nu8 len = 0;\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].ACLPacketsData.ACLDataPacketLen = *((u16 *)pHciCmd->Data);\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].SyncDataPacketLen = *((u8 *)(pHciCmd->Data+2));\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].TotalNumACLDataPackets = *((u16 *)(pHciCmd->Data+3));\r\npBTInfo->BtAsocEntry[pBtMgnt->CurrentConnectEntryNum].TotalSyncNumDataPackets = *((u16 *)(pHciCmd->Data+5));\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nlen += bthci_CommandCompleteHeader(&localBuf[0],\r\nOGF_SET_EVENT_MASK_COMMAND,\r\nHCI_HOST_BUFFER_SIZE,\r\nstatus);\r\npRetPar = &PPacketIrpEvent->Data[len];\r\npRetPar[0] = status;\r\nlen += 1;\r\nPPacketIrpEvent->Length = len;\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_UnknownCMD(struct rtw_adapter *padapter, struct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_UNKNOW_HCI_CMD;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\npBtDbg->dbgHciInfo.hciCmdCntUnknown++;\r\nbthci_EventCommandStatus(padapter,\r\n(u8)pHciCmd->OGF,\r\npHciCmd->OCF,\r\nstatus);\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFInformationalParameters(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_READ_LOCAL_VERSION_INFORMATION:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCAL_VERSION_INFORMATION\n"));\r\nstatus = bthci_CmdReadLocalVersionInformation(padapter);\r\nbreak;\r\ncase HCI_READ_LOCAL_SUPPORTED_COMMANDS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCAL_SUPPORTED_COMMANDS\n"));\r\nstatus = bthci_CmdReadLocalSupportedCommands(padapter);\r\nbreak;\r\ncase HCI_READ_LOCAL_SUPPORTED_FEATURES:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCAL_SUPPORTED_FEATURES\n"));\r\nstatus = bthci_CmdReadLocalSupportedFeatures(padapter);\r\nbreak;\r\ncase HCI_READ_BUFFER_SIZE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_BUFFER_SIZE\n"));\r\nstatus = bthci_CmdReadBufferSize(padapter);\r\nbreak;\r\ncase HCI_READ_DATA_BLOCK_SIZE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_DATA_BLOCK_SIZE\n"));\r\nstatus = bthci_CmdReadDataBlockSize(padapter);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("bthci_HandleOGFInformationalParameters(), Unknown case = 0x%x\n", pHciCmd->OCF));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFSetEventMaskCMD(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_SET_EVENT_MASK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_SET_EVENT_MASK\n"));\r\nstatus = bthci_CmdSetEventMask(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_RESET:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_RESET\n"));\r\nstatus = bthci_CmdReset(padapter, true);\r\nbreak;\r\ncase HCI_READ_CONNECTION_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_CONNECTION_ACCEPT_TIMEOUT\n"));\r\nstatus = bthci_CmdReadConnectionAcceptTimeout(padapter);\r\nbreak;\r\ncase HCI_SET_EVENT_FILTER:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_SET_EVENT_FILTER\n"));\r\nbreak;\r\ncase HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT\n"));\r\nstatus = bthci_CmdWriteConnectionAcceptTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_PAGE_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_PAGE_TIMEOUT\n"));\r\nstatus = bthci_CmdReadPageTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_PAGE_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_PAGE_TIMEOUT\n"));\r\nstatus = bthci_CmdWritePageTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_HOST_NUMBER_OF_COMPLETED_PACKETS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_HOST_NUMBER_OF_COMPLETED_PACKETS\n"));\r\nbreak;\r\ncase HCI_READ_LINK_SUPERVISION_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LINK_SUPERVISION_TIMEOUT\n"));\r\nstatus = bthci_CmdReadLinkSupervisionTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_LINK_SUPERVISION_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_LINK_SUPERVISION_TIMEOUT\n"));\r\nstatus = bthci_CmdWriteLinkSupervisionTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_ENHANCED_FLUSH:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_ENHANCED_FLUSH\n"));\r\nstatus = bthci_CmdEnhancedFlush(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT\n"));\r\nstatus = bthci_CmdReadLogicalLinkAcceptTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT\n"));\r\nstatus = bthci_CmdWriteLogicalLinkAcceptTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SET_EVENT_MASK_PAGE_2:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_SET_EVENT_MASK_PAGE_2\n"));\r\nstatus = bthci_CmdSetEventMaskPage2(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_LOCATION_DATA:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCATION_DATA\n"));\r\nstatus = bthci_CmdReadLocationData(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_LOCATION_DATA:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_LOCATION_DATA\n"));\r\nstatus = bthci_CmdWriteLocationData(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_FLOW_CONTROL_MODE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_FLOW_CONTROL_MODE\n"));\r\nstatus = bthci_CmdReadFlowControlMode(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_FLOW_CONTROL_MODE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_FLOW_CONTROL_MODE\n"));\r\nstatus = bthci_CmdWriteFlowControlMode(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT\n"));\r\nstatus = bthci_CmdReadBestEffortFlushTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT\n"));\r\nstatus = bthci_CmdWriteBestEffortFlushTimeout(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SHORT_RANGE_MODE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_SHORT_RANGE_MODE\n"));\r\nstatus = bthci_CmdShortRangeMode(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_HOST_BUFFER_SIZE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_HOST_BUFFER_SIZE\n"));\r\nstatus = bthci_CmdHostBufferSize(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("bthci_HandleOGFSetEventMaskCMD(), Unknown case = 0x%x\n", pHciCmd->OCF));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFStatusParameters(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_READ_FAILED_CONTACT_COUNTER:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_FAILED_CONTACT_COUNTER\n"));\r\nstatus = bthci_CmdReadFailedContactCounter(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_RESET_FAILED_CONTACT_COUNTER:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_RESET_FAILED_CONTACT_COUNTER\n"));\r\nstatus = bthci_CmdResetFailedContactCounter(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_LINK_QUALITY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LINK_QUALITY\n"));\r\nstatus = bthci_CmdReadLinkQuality(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_READ_RSSI:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_RSSI\n"));\r\nbreak;\r\ncase HCI_READ_LOCAL_AMP_INFO:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCAL_AMP_INFO\n"));\r\nstatus = bthci_CmdReadLocalAMPInfo(padapter);\r\nbreak;\r\ncase HCI_READ_LOCAL_AMP_ASSOC:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_READ_LOCAL_AMP_ASSOC\n"));\r\nstatus = bthci_CmdReadLocalAMPAssoc(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WRITE_REMOTE_AMP_ASSOC:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_WRITE_REMOTE_AMP_ASSOC\n"));\r\nstatus = bthci_CmdWriteRemoteAMPAssoc(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("bthci_HandleOGFStatusParameters(), Unknown case = 0x%x\n", pHciCmd->OCF));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFLinkControlCMD(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_CREATE_PHYSICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_CREATE_PHYSICAL_LINK\n"));\r\nstatus = bthci_CmdCreatePhysicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_ACCEPT_PHYSICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_ACCEPT_PHYSICAL_LINK\n"));\r\nstatus = bthci_CmdAcceptPhysicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_DISCONNECT_PHYSICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_DISCONNECT_PHYSICAL_LINK\n"));\r\nstatus = bthci_CmdDisconnectPhysicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_CREATE_LOGICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_CREATE_LOGICAL_LINK\n"));\r\nstatus = bthci_CmdCreateLogicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_ACCEPT_LOGICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_ACCEPT_LOGICAL_LINK\n"));\r\nstatus = bthci_CmdAcceptLogicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_DISCONNECT_LOGICAL_LINK:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_DISCONNECT_LOGICAL_LINK\n"));\r\nstatus = bthci_CmdDisconnectLogicalLink(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_LOGICAL_LINK_CANCEL:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_LOGICAL_LINK_CANCEL\n"));\r\nstatus = bthci_CmdLogicalLinkCancel(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_FLOW_SPEC_MODIFY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_FLOW_SPEC_MODIFY\n"));\r\nstatus = bthci_CmdFlowSpecModify(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("bthci_HandleOGFLinkControlCMD(), Unknown case = 0x%x\n", pHciCmd->OCF));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFTestingCMD(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_ENABLE_DEVICE_UNDER_TEST_MODE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_ENABLE_DEVICE_UNDER_TEST_MODE\n"));\r\nbthci_CmdEnableDeviceUnderTestMode(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_AMP_TEST_END:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_AMP_TEST_END\n"));\r\nbthci_CmdAMPTestEnd(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_AMP_TEST_COMMAND:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_AMP_TEST_COMMAND\n"));\r\nbthci_CmdAMPTestCommand(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_ENABLE_AMP_RECEIVER_REPORTS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_ENABLE_AMP_RECEIVER_REPORTS\n"));\r\nbthci_CmdEnableAMPReceiverReports(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum hci_status\r\nbthci_HandleOGFExtension(struct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nswitch (pHciCmd->OCF) {\r\ncase HCI_SET_ACL_LINK_DATA_FLOW_MODE:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_SET_ACL_LINK_DATA_FLOW_MODE\n"));\r\nstatus = bthci_CmdSetACLLinkDataFlowMode(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SET_ACL_LINK_STATUS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_SET_ACL_LINK_STATUS\n"));\r\nstatus = bthci_CmdSetACLLinkStatus(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SET_SCO_LINK_STATUS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_SET_SCO_LINK_STATUS\n"));\r\nstatus = bthci_CmdSetSCOLinkStatus(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SET_RSSI_VALUE:\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_PERIODICAL, ("HCI_SET_RSSI_VALUE\n"));\r\nstatus = bthci_CmdSetRSSIValue(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_SET_CURRENT_BLUETOOTH_STATUS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_SET_CURRENT_BLUETOOTH_STATUS\n"));\r\nstatus = bthci_CmdSetCurrentBluetoothStatus(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_EXTENSION_VERSION_NOTIFY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_EXTENSION_VERSION_NOTIFY\n"));\r\nstatus = bthci_CmdExtensionVersionNotify(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_LINK_STATUS_NOTIFY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_LINK_STATUS_NOTIFY\n"));\r\nstatus = bthci_CmdLinkStatusNotify(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_BT_OPERATION_NOTIFY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_BT_OPERATION_NOTIFY\n"));\r\nstatus = bthci_CmdBtOperationNotify(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_ENABLE_WIFI_SCAN_NOTIFY:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_ENABLE_WIFI_SCAN_NOTIFY\n"));\r\nstatus = bthci_CmdEnableWifiScanNotify(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WIFI_CURRENT_CHANNEL:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_WIFI_CURRENT_CHANNEL\n"));\r\nstatus = bthci_CmdWIFICurrentChannel(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WIFI_CURRENT_BANDWIDTH:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_WIFI_CURRENT_BANDWIDTH\n"));\r\nstatus = bthci_CmdWIFICurrentBandwidth(padapter, pHciCmd);\r\nbreak;\r\ncase HCI_WIFI_CONNECTION_STATUS:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_WIFI_CONNECTION_STATUS\n"));\r\nstatus = bthci_CmdWIFIConnectionStatus(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nbthci_StateStarting(struct rtw_adapter *padapter,\r\nenum hci_state_with_cmd StateCmd, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Starting], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_CONNECT_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n"));\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_CONNECT_ACCEPT_TIMEOUT;\r\npBtMgnt->bNeedNotifyAMPNoCap = true;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_MAC_START_COMPLETE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_MAC_START_COMPLETE\n"));\r\nif (pBTInfo->BtAsocEntry[EntryNum].AMPRole == AMP_BTAP_CREATOR)\r\nbthci_EventChannelSelected(padapter, EntryNum);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbthci_StateConnecting(struct rtw_adapter *padapter,\r\nenum hci_state_with_cmd StateCmd, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Connecting], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_CONNECT_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n"));\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_CONNECT_ACCEPT_TIMEOUT;\r\npBtMgnt->bNeedNotifyAMPNoCap = true;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_MAC_CONNECT_COMPLETE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_MAC_CONNECT_COMPLETE\n"));\r\nif (pBTInfo->BtAsocEntry[EntryNum].AMPRole == AMP_BTAP_JOINER) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_info_,\r\n"StateConnecting\n");\r\n}\r\nbreak;\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_MAC_CONNECT_CANCEL_INDICATE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n"));\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_CONTROLLER_BUSY;\r\npBtMgnt->bNeedNotifyAMPNoCap = false;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbthci_StateConnected(struct rtw_adapter *padapter,\r\nenum hci_state_with_cmd StateCmd, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 i;\r\nu16 logicHandle = 0;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Connected], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTInfo->BtAsocEntry[EntryNum].LogLinkCmdData->BtLogLinkhandle != 0) {\r\nlogicHandle = pBTInfo->BtAsocEntry[EntryNum].LogLinkCmdData->BtLogLinkhandle;\r\nbthci_EventDisconnectLogicalLinkComplete(padapter, HCI_STATUS_SUCCESS,\r\nlogicHandle, pBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason);\r\npBTInfo->BtAsocEntry[EntryNum].LogLinkCmdData->BtLogLinkhandle = 0;\r\n}\r\n}\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_MAC_DISCONNECT_INDICATE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_MAC_DISCONNECT_INDICATE\n"));\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\nHCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST,\r\nEntryNum);\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_ENTER_STATE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_ENTER_STATE\n"));\r\nif (pBtMgnt->bBTConnectInProgress) {\r\npBtMgnt->bBTConnectInProgress = false;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], BT Connect in progress OFF!!\n"));\r\n}\r\npBTInfo->BtAsocEntry[EntryNum].BtCurrentState = HCI_STATE_CONNECTED;\r\npBTInfo->BtAsocEntry[EntryNum].b4waySuccess = true;\r\npBtMgnt->bStartSendSupervisionPkt = true;\r\nrtl8723a_update_ramask(padapter,\r\nMAX_FW_SUPPORT_MACID_NUM-1-EntryNum, 0);\r\nHalSetBrateCfg23a(padapter, padapter->mlmepriv.cur_network.network.SupportedRates);\r\nBTDM_SetFwChnlInfo(padapter, RT_MEDIA_CONNECT);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbthci_StateAuth(struct rtw_adapter *padapter, enum hci_state_with_cmd StateCmd,\r\nu8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Authenticating], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_CONNECT_ACCEPT_TIMEOUT:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n"));\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_CONNECT_ACCEPT_TIMEOUT;\r\npBtMgnt->bNeedNotifyAMPNoCap = true;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_UNKNOW_CONNECT_ID;\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_4WAY_FAILED:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_4WAY_FAILED\n"));\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus = HCI_STATUS_AUTH_FAIL;\r\npBtMgnt->bNeedNotifyAMPNoCap = true;\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nbreak;\r\ncase STATE_CMD_4WAY_SUCCESSED:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_4WAY_SUCCESSED\n"));\r\nbthci_EventPhysicalLinkComplete(padapter, HCI_STATUS_SUCCESS, EntryNum, INVALID_PL_HANDLE);\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_CONNECTED, STATE_CMD_ENTER_STATE, EntryNum);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbthci_StateDisconnecting(struct rtw_adapter *padapter,\r\nenum hci_state_with_cmd StateCmd, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Disconnecting], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_MAC_CONNECT_CANCEL_INDICATE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n"));\r\nif (pBTInfo->BtAsocEntry[EntryNum].bNeedPhysLinkCompleteEvent) {\r\nbthci_EventPhysicalLinkComplete(padapter,\r\npBTInfo->BtAsocEntry[EntryNum].PhysLinkCompleteStatus,\r\nEntryNum, INVALID_PL_HANDLE);\r\n}\r\nif (pBtMgnt->bBTConnectInProgress) {\r\npBtMgnt->bBTConnectInProgress = false;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], BT Connect in progress OFF!!\n"));\r\n}\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTED, STATE_CMD_ENTER_STATE, EntryNum);\r\nbreak;\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nBTHCI_DisconnectPeer(padapter, EntryNum);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbthci_StateDisconnected(struct rtw_adapter *padapter,\r\nenum hci_state_with_cmd StateCmd, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT state], [Disconnected], "));\r\nswitch (StateCmd) {\r\ncase STATE_CMD_CREATE_PHY_LINK:\r\ncase STATE_CMD_ACCEPT_PHY_LINK:\r\nif (StateCmd == STATE_CMD_CREATE_PHY_LINK)\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_CREATE_PHY_LINK\n"));\r\nelse\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_ACCEPT_PHY_LINK\n"));\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT PS], Disable IPS and LPS\n"));\r\nips_leave23a(padapter);\r\nLPS_Leave23a(padapter);\r\npBtMgnt->bPhyLinkInProgress = true;\r\npBtMgnt->BTCurrentConnectType = BT_DISCONNECT;\r\npBtMgnt->CurrentBTConnectionCnt++;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], CurrentBTConnectionCnt = %d\n",\r\npBtMgnt->CurrentBTConnectionCnt));\r\npBtMgnt->BtOperationOn = true;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], Bt Operation ON!! CurrentConnectEntryNum = %d\n",\r\npBtMgnt->CurrentConnectEntryNum));\r\nif (pBtMgnt->bBTConnectInProgress) {\r\nbthci_EventPhysicalLinkComplete(padapter, HCI_STATUS_CONTROLLER_BUSY, INVALID_ENTRY_NUM, pBtMgnt->BtCurrentPhyLinkhandle);\r\nbthci_RemoveEntryByEntryNum(padapter, EntryNum);\r\nreturn;\r\n}\r\nif (StateCmd == STATE_CMD_CREATE_PHY_LINK)\r\npBTInfo->BtAsocEntry[EntryNum].AMPRole = AMP_BTAP_CREATOR;\r\nelse\r\npBTInfo->BtAsocEntry[EntryNum].AMPRole = AMP_BTAP_JOINER;\r\nwhile (check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR)) {\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("Scan/Roaming/Wifi Link is in Progress, wait 200 ms\n"));\r\nmdelay(200);\r\n}\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("Channel is Ready\n"));\r\nmod_timer(&pBTInfo->BTHCIJoinTimeoutTimer,\r\njiffies + msecs_to_jiffies(pBtHciInfo->ConnAcceptTimeout));\r\npBTInfo->BtAsocEntry[EntryNum].bNeedPhysLinkCompleteEvent = true;\r\nbreak;\r\ncase STATE_CMD_DISCONNECT_PHY_LINK:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_DISCONNECT_PHY_LINK\n"));\r\ndel_timer_sync(&pBTInfo->BTHCIJoinTimeoutTimer);\r\nbthci_EventDisconnectPhyLinkComplete(padapter,\r\nHCI_STATUS_SUCCESS,\r\npBTInfo->BtAsocEntry[EntryNum].PhyLinkDisconnectReason,\r\nEntryNum);\r\nif (pBTInfo->BtAsocEntry[EntryNum].bNeedPhysLinkCompleteEvent) {\r\nbthci_EventPhysicalLinkComplete(padapter,\r\nHCI_STATUS_UNKNOW_CONNECT_ID,\r\nEntryNum, INVALID_PL_HANDLE);\r\n}\r\nif (pBtMgnt->bBTConnectInProgress) {\r\npBtMgnt->bBTConnectInProgress = false;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], BT Connect in progress OFF!!\n"));\r\n}\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTED, STATE_CMD_ENTER_STATE, EntryNum);\r\nbthci_RemoveEntryByEntryNum(padapter, EntryNum);\r\nbreak;\r\ncase STATE_CMD_ENTER_STATE:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("STATE_CMD_ENTER_STATE\n"));\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("State command(%d) is Wrong !!!\n", StateCmd));\r\nbreak;\r\n}\r\n}\r\nvoid BTHCI_EventParse(struct rtw_adapter *padapter, void *pEvntData, u32 dataLen)\r\n{\r\n}\r\nu8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter)\r\n{\r\nu8 bBtConnectionExist = false;\r\nstruct bt_30info *pBtinfo = GET_BT_INFO(padapter);\r\nu8 i;\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\nif (pBtinfo->BtAsocEntry[i].b4waySuccess) {\r\nbBtConnectionExist = true;\r\nbreak;\r\n}\r\n}\r\nreturn bBtConnectionExist;\r\n}\r\nstatic u8\r\nBTHCI_CheckProfileExist(struct rtw_adapter *padapter,\r\nenum bt_traffic_mode_profile Profile)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 IsPRofile = false;\r\nu8 i = 0;\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\nif (pBtMgnt->ExtConfig.linkInfo[i].TrafficProfile == Profile) {\r\nIsPRofile = true;\r\nbreak;\r\n}\r\n}\r\nreturn IsPRofile;\r\n}\r\nvoid BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 i = 0;\r\npBtMgnt->ExtConfig.NumberOfSCO = 0;\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\npBtMgnt->ExtConfig.linkInfo[i].TrafficProfile = BT_PROFILE_NONE;\r\nif (pBtMgnt->ExtConfig.linkInfo[i].BTProfile == BT_PROFILE_SCO)\r\npBtMgnt->ExtConfig.NumberOfSCO++;\r\npBtMgnt->ExtConfig.linkInfo[i].TrafficProfile = pBtMgnt->ExtConfig.linkInfo[i].BTProfile;\r\nswitch (pBtMgnt->ExtConfig.linkInfo[i].TrafficProfile) {\r\ncase BT_PROFILE_SCO:\r\nbreak;\r\ncase BT_PROFILE_PAN:\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode = BT_MOTOR_EXT_BE;\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode = BT_MOTOR_EXT_BE;\r\nbreak;\r\ncase BT_PROFILE_A2DP:\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode = BT_MOTOR_EXT_GULB;\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode = BT_MOTOR_EXT_GULB;\r\nbreak;\r\ncase BT_PROFILE_HID:\r\npBtMgnt->ExtConfig.linkInfo[i].IncomingTrafficMode = BT_MOTOR_EXT_GUL;\r\npBtMgnt->ExtConfig.linkInfo[i].OutgoingTrafficMode = BT_MOTOR_EXT_BE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RTK, NumberOfHandle = %d, NumberOfSCO = %d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle, pBtMgnt->ExtConfig.NumberOfSCO));\r\n}\r\nvoid BTHCI_WifiScanNotify(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bEnableWifiScanNotify)\r\nbthci_EventExtWifiScanNotify(padapter, scanType);\r\n}\r\nvoid\r\nBTHCI_StateMachine(\r\nstruct rtw_adapter *padapter,\r\nu8 StateToEnter,\r\nenum hci_state_with_cmd StateCmd,\r\nu8 EntryNum\r\n)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (EntryNum == 0xff) {\r\nRTPRINT(FIOCTL, IOCTL_STATE, (" StateMachine, error EntryNum = 0x%x \n", EntryNum));\r\nreturn;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_STATE, (" StateMachine, EntryNum = 0x%x, CurrentState = 0x%x, BtNextState = 0x%x, StateCmd = 0x%x , StateToEnter = 0x%x\n",\r\nEntryNum, pBTInfo->BtAsocEntry[EntryNum].BtCurrentState, pBTInfo->BtAsocEntry[EntryNum].BtNextState, StateCmd, StateToEnter));\r\nif (pBTInfo->BtAsocEntry[EntryNum].BtNextState & StateToEnter) {\r\npBTInfo->BtAsocEntry[EntryNum].BtCurrentState = StateToEnter;\r\nswitch (StateToEnter) {\r\ncase HCI_STATE_STARTING:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_DISCONNECTING | HCI_STATE_CONNECTING;\r\nbthci_StateStarting(padapter, StateCmd, EntryNum);\r\nbreak;\r\ncase HCI_STATE_CONNECTING:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_CONNECTING | HCI_STATE_DISCONNECTING | HCI_STATE_AUTHENTICATING;\r\nbthci_StateConnecting(padapter, StateCmd, EntryNum);\r\nbreak;\r\ncase HCI_STATE_AUTHENTICATING:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_DISCONNECTING | HCI_STATE_CONNECTED;\r\nbthci_StateAuth(padapter, StateCmd, EntryNum);\r\nbreak;\r\ncase HCI_STATE_CONNECTED:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_CONNECTED | HCI_STATE_DISCONNECTING;\r\nbthci_StateConnected(padapter, StateCmd, EntryNum);\r\nbreak;\r\ncase HCI_STATE_DISCONNECTING:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_DISCONNECTED | HCI_STATE_DISCONNECTING;\r\nbthci_StateDisconnecting(padapter, StateCmd, EntryNum);\r\nbreak;\r\ncase HCI_STATE_DISCONNECTED:\r\npBTInfo->BtAsocEntry[EntryNum].BtNextState = HCI_STATE_DISCONNECTED | HCI_STATE_STARTING | HCI_STATE_CONNECTING;\r\nbthci_StateDisconnected(padapter, StateCmd, EntryNum);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_STATE, (" StateMachine, Unknown state to enter!!!\n"));\r\nbreak;\r\n}\r\n} else {\r\nRTPRINT(FIOCTL, IOCTL_STATE, (" StateMachine, Wrong state to enter\n"));\r\n}\r\nif (!pBtMgnt->bBTConnectInProgress && !pBtMgnt->BtOperationOn) {\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT PS], ips_enter23a()\n"));\r\nips_enter23a(padapter);\r\n}\r\n}\r\nvoid BTHCI_DisconnectPeer(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, (" BTHCI_DisconnectPeer()\n"));\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTING, STATE_CMD_MAC_CONNECT_CANCEL_INDICATE, EntryNum);\r\nif (pBTInfo->BtAsocEntry[EntryNum].bUsed) {\r\n}\r\nif (pBtMgnt->bBTConnectInProgress) {\r\npBtMgnt->bBTConnectInProgress = false;\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT Flag], BT Connect in progress OFF!!\n"));\r\n}\r\nbthci_RemoveEntryByEntryNum(padapter, EntryNum);\r\nif (pBtMgnt->bNeedNotifyAMPNoCap) {\r\nRTPRINT(FIOCTL, IOCTL_STATE, ("[BT AMPStatus], set to invalid in BTHCI_DisconnectPeer()\n"));\r\nBTHCI_EventAMPStatusChange(padapter, AMP_STATUS_NO_CAPACITY_FOR_BT);\r\n}\r\n}\r\nvoid BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_hci_info *pBtHciInfo = &pBTInfo->BtHciInfo;\r\nu8 localBuf[TmpLocalBufSize] = "";\r\nu8 *pRetPar, *pTriple;\r\nu8 len = 0, i, j, handleNum = 0;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu16 *pu2Temp, *pPackets, *pHandle, *pDblocks;\r\nu8 sent = 0;\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\nif (!(pBtHciInfo->BTEventMaskPage2 & EMP2_HCI_EVENT_NUM_OF_COMPLETE_DATA_BLOCKS)) {\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT, ("[BT event], Num Of Completed DataBlocks, Ignore to send NumOfCompletedDataBlocksEvent due to event mask page 2\n"));\r\nreturn;\r\n}\r\npRetPar = &PPacketIrpEvent->Data[0];\r\npTriple = &pRetPar[3];\r\nfor (j = 0; j < MAX_BT_ASOC_ENTRY_NUM; j++) {\r\nfor (i = 0; i < MAX_LOGICAL_LINK_NUM; i++) {\r\nif (pBTInfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle) {\r\nhandleNum++;\r\npHandle = (u16 *)&pTriple[0];\r\npPackets = (u16 *)&pTriple[2];\r\npDblocks = (u16 *)&pTriple[4];\r\n*pHandle = pBTInfo->BtAsocEntry[j].LogLinkCmdData[i].BtLogLinkhandle;\r\n*pPackets = (u16)pBTInfo->BtAsocEntry[j].LogLinkCmdData[i].TxPacketCount;\r\n*pDblocks = (u16)pBTInfo->BtAsocEntry[j].LogLinkCmdData[i].TxPacketCount;\r\nif (pBTInfo->BtAsocEntry[j].LogLinkCmdData[i].TxPacketCount) {\r\nsent = 1;\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_DETAIL,\r\n("[BT event], Num Of Completed DataBlocks, Handle = 0x%x, Num_Of_Completed_Packets = 0x%x, Num_Of_Completed_Blocks = 0x%x\n",\r\n*pHandle, *pPackets, *pDblocks));\r\n}\r\npBTInfo->BtAsocEntry[j].LogLinkCmdData[i].TxPacketCount = 0;\r\nlen += 6;\r\npTriple += len;\r\n}\r\n}\r\n}\r\npRetPar[2] = handleNum;\r\nlen += 1;\r\npu2Temp = (u16 *)&pRetPar[0];\r\n*pu2Temp = BTTotalDataBlockNum;\r\nlen += 2;\r\nPPacketIrpEvent->EventCode = HCI_EVENT_NUM_OF_COMPLETE_DATA_BLOCKS;\r\nPPacketIrpEvent->Length = len;\r\nif (handleNum && sent)\r\nbthci_IndicateEvent(padapter, PPacketIrpEvent, len+2);\r\n}\r\nvoid BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter, u8 AMP_Status)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct packet_irp_hcievent_data *PPacketIrpEvent;\r\nu8 len = 0;\r\nu8 localBuf[7] = "";\r\nu8 *pRetPar;\r\nif (AMP_Status == AMP_STATUS_NO_CAPACITY_FOR_BT) {\r\npBtMgnt->BTNeedAMPStatusChg = true;\r\npBtMgnt->bNeedNotifyAMPNoCap = false;\r\nBTHCI_DisconnectAll(padapter);\r\n} else if (AMP_Status == AMP_STATUS_FULL_CAPACITY_FOR_BT) {\r\npBtMgnt->BTNeedAMPStatusChg = false;\r\n}\r\nPPacketIrpEvent = (struct packet_irp_hcievent_data *)(&localBuf[0]);\r\npRetPar = &PPacketIrpEvent->Data[0];\r\npRetPar[0] = 0;\r\nlen += 1;\r\npRetPar[1] = AMP_Status;\r\nlen += 1;\r\nPPacketIrpEvent->EventCode = HCI_EVENT_AMP_STATUS_CHANGE;\r\nPPacketIrpEvent->Length = len;\r\nif (bthci_IndicateEvent(padapter, PPacketIrpEvent, len+2) == RT_STATUS_SUCCESS)\r\nRTPRINT(FIOCTL, (IOCTL_BT_EVENT|IOCTL_STATE), ("[BT event], AMP Status Change, AMP_Status = %d\n", AMP_Status));\r\n}\r\nvoid BTHCI_DisconnectAll(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nu8 i;\r\nRTPRINT(FIOCTL, IOCTL_STATE, (" DisconnectALL()\n"));\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\nif (pBTInfo->BtAsocEntry[i].b4waySuccess) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_CONNECTED, STATE_CMD_DISCONNECT_PHY_LINK, i);\r\n} else if (pBTInfo->BtAsocEntry[i].bUsed) {\r\nif (pBTInfo->BtAsocEntry[i].BtCurrentState == HCI_STATE_CONNECTING) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_CONNECTING, STATE_CMD_MAC_CONNECT_CANCEL_INDICATE, i);\r\n} else if (pBTInfo->BtAsocEntry[i].BtCurrentState == HCI_STATE_DISCONNECTING) {\r\nBTHCI_SM_WITH_INFO(padapter, HCI_STATE_DISCONNECTING, STATE_CMD_MAC_CONNECT_CANCEL_INDICATE, i);\r\n}\r\n}\r\n}\r\n}\r\nenum hci_status\r\nBTHCI_HandleHCICMD(\r\nstruct rtw_adapter *padapter,\r\nstruct packet_irp_hcicmd_data *pHciCmd\r\n)\r\n{\r\nenum hci_status status = HCI_STATUS_SUCCESS;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("\n"));\r\nRTPRINT(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), ("HCI Command start, OGF = 0x%x, OCF = 0x%x, Length = 0x%x\n",\r\npHciCmd->OGF, pHciCmd->OCF, pHciCmd->Length));\r\nif (pHciCmd->Length) {\r\nRTPRINT_DATA(FIOCTL, (IOCTL_BT_HCICMD_DETAIL|IOCTL_BT_LOGO), "HCI Command, Hex Data :\n",\r\n&pHciCmd->Data[0], pHciCmd->Length);\r\n}\r\nif (pHciCmd->OGF == OGF_EXTENSION) {\r\nif (pHciCmd->OCF == HCI_SET_RSSI_VALUE)\r\nRTPRINT(FIOCTL, IOCTL_BT_EVENT_PERIODICAL, ("[BT cmd], "));\r\nelse\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_EXT, ("[BT cmd], "));\r\n} else {\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("[BT cmd], "));\r\n}\r\npBtDbg->dbgHciInfo.hciCmdCnt++;\r\nswitch (pHciCmd->OGF) {\r\ncase LINK_CONTROL_COMMANDS:\r\nstatus = bthci_HandleOGFLinkControlCMD(padapter, pHciCmd);\r\nbreak;\r\ncase HOLD_MODE_COMMAND:\r\nbreak;\r\ncase OGF_SET_EVENT_MASK_COMMAND:\r\nstatus = bthci_HandleOGFSetEventMaskCMD(padapter, pHciCmd);\r\nbreak;\r\ncase OGF_INFORMATIONAL_PARAMETERS:\r\nstatus = bthci_HandleOGFInformationalParameters(padapter, pHciCmd);\r\nbreak;\r\ncase OGF_STATUS_PARAMETERS:\r\nstatus = bthci_HandleOGFStatusParameters(padapter, pHciCmd);\r\nbreak;\r\ncase OGF_TESTING_COMMANDS:\r\nstatus = bthci_HandleOGFTestingCMD(padapter, pHciCmd);\r\nbreak;\r\ncase OGF_EXTENSION:\r\nstatus = bthci_HandleOGFExtension(padapter, pHciCmd);\r\nbreak;\r\ndefault:\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI Command(), Unknown OGF = 0x%x\n", pHciCmd->OGF));\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD, ("HCI_UNKNOWN_COMMAND\n"));\r\nstatus = bthci_UnknownCMD(padapter, pHciCmd);\r\nbreak;\r\n}\r\nRTPRINT(FIOCTL, IOCTL_BT_HCICMD_DETAIL, ("HCI Command execution end!!\n"));\r\nreturn status;\r\n}\r\nstatic void btdm_SetFwIgnoreWlanAct(struct rtw_adapter *padapter, u8 bEnable)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[1] = {0};\r\nif (bEnable) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT Ignore Wlan_Act !!\n"));\r\nH2C_Parameter[0] |= BIT(0);\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT don't ignore Wlan_Act !!\n"));\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], set FW for BT Ignore Wlan_Act, write 0x25 = 0x%02x\n",\r\nH2C_Parameter[0]));\r\nFillH2CCmd(padapter, BT_IGNORE_WLAN_ACT_EID, 1, H2C_Parameter);\r\n}\r\nstatic void btdm_NotifyFwScan(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nu8 H2C_Parameter[1] = {0};\r\nif (scanType == true)\r\nH2C_Parameter[0] = 0x1;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Notify FW for wifi scan, write 0x3b = 0x%02x\n",\r\nH2C_Parameter[0]));\r\nFillH2CCmd(padapter, 0x3b, 1, H2C_Parameter);\r\n}\r\nstatic void btdm_1AntSetPSMode(struct rtw_adapter *padapter,\r\nu8 enable, u8 smartps, u8 mode)\r\n{\r\nstruct pwrctrl_priv *pwrctrl;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Current LPS(%s, %d), smartps =%d\n", enable == true?"ON":"OFF", mode, smartps));\r\npwrctrl = &padapter->pwrctrlpriv;\r\nif (enable == true) {\r\nrtw_set_ps_mode23a(padapter, PS_MODE_MIN, smartps, mode);\r\n} else {\r\nrtw_set_ps_mode23a(padapter, PS_MODE_ACTIVE, 0, 0);\r\nLPS_RF_ON_check23a(padapter, 100);\r\n}\r\n}\r\nstatic void btdm_1AntTSFSwitch(struct rtw_adapter *padapter, u8 enable)\r\n{\r\nu8 oldVal, newVal;\r\noldVal = rtl8723au_read8(padapter, 0x550);\r\nif (enable)\r\nnewVal = oldVal | EN_BCN_FUNCTION;\r\nelse\r\nnewVal = oldVal & ~EN_BCN_FUNCTION;\r\nif (oldVal != newVal)\r\nrtl8723au_write8(padapter, 0x550, newVal);\r\n}\r\nstatic u8 btdm_Is1AntPsTdmaStateChange(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_1ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nif ((pBtdm8723->bPrePsTdmaOn != pBtdm8723->bCurPsTdmaOn) ||\r\n(pBtdm8723->prePsTdma != pBtdm8723->curPsTdma))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void\r\nbtdm_1AntPsTdma(\r\nstruct rtw_adapter *padapter,\r\nu8 bTurnOn,\r\nu8 type\r\n)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_1ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\npBtdm8723->bCurPsTdmaOn = bTurnOn;\r\npBtdm8723->curPsTdma = type;\r\nif (bTurnOn) {\r\nswitch (type) {\r\ncase 1:\r\ndefault:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xd3, 0x1a, 0x1a, 0x0, 0x58);\r\n}\r\nbreak;\r\ncase 2:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xd3, 0x12, 0x12, 0x0, 0x58);\r\n}\r\nbreak;\r\ncase 3:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xd3, 0x30, 0x03, 0x10, 0x58);\r\n}\r\nbreak;\r\ncase 4:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0x93, 0x15, 0x03, 0x14, 0x0);\r\n}\r\nbreak;\r\ncase 5:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0x61, 0x15, 0x03, 0x31, 0x00);\r\n}\r\nbreak;\r\ncase 9:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xd3, 0xa, 0xa, 0x0, 0x58);\r\n}\r\nbreak;\r\ncase 10:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0x13, 0xa, 0xa, 0x0, 0x40);\r\nbreak;\r\ncase 11:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xd3, 0x05, 0x05, 0x00, 0x58);\r\n}\r\nbreak;\r\ncase 12:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xeb, 0x0a, 0x03, 0x31, 0x18);\r\n}\r\nbreak;\r\ncase 20:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0x13, 0x25, 0x25, 0x00, 0x00);\r\nbreak;\r\ncase 27:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xa3, 0x25, 0x03, 0x31, 0x98);\r\nbreak;\r\ncase 28:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0x69, 0x25, 0x03, 0x31, 0x00);\r\nbreak;\r\ncase 29:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0xeb, 0x1a, 0x1a, 0x01, 0x18);\r\nrtl8723au_write32(padapter, 0x6c0, 0x5afa5afa);\r\nrtl8723au_write32(padapter, 0x6c4, 0x5afa5afa);\r\n}\r\nbreak;\r\ncase 30:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0x93, 0x15, 0x03, 0x14, 0x00);\r\nbreak;\r\ncase 31:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xd3, 0x1a, 0x1a, 0x00, 0x58);\r\nbreak;\r\ncase 32:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xab, 0x0a, 0x03, 0x11, 0x98);\r\nbreak;\r\ncase 33:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xa3, 0x25, 0x03, 0x30, 0x98);\r\nbreak;\r\ncase 34:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xd3, 0x1a, 0x1a, 0x00, 0x18);\r\nbreak;\r\ncase 35:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter))\r\nBTDM_SetFw3a(padapter, 0xe3, 0x1a, 0x1a, 0x00, 0x18);\r\nbreak;\r\n}\r\n} else {\r\nswitch (type) {\r\ncase 8:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0x8, 0x0, 0x0, 0x0, 0x0);\r\n}\r\nbreak;\r\ncase 0:\r\ndefault:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0x0, 0x0, 0x0, 0x8, 0x0);\r\n}\r\nrtl8723au_write16(padapter, 0x860, 0x210);\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 0x860 = 0x210, Switch Antenna to BT\n"));\r\nbreak;\r\ncase 9:\r\nif (btdm_Is1AntPsTdmaStateChange(padapter)) {\r\nBTDM_SetFw3a(padapter, 0x0, 0x0, 0x0, 0x8, 0x0);\r\n}\r\nrtl8723au_write16(padapter, 0x860, 0x110);\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 0x860 = 0x110, Switch Antenna to WiFi\n"));\r\nbreak;\r\n}\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Current TDMA(%s, %d)\n",\r\npBtdm8723->bCurPsTdmaOn?"ON":"OFF", pBtdm8723->curPsTdma));\r\npBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;\r\npBtdm8723->prePsTdma = pBtdm8723->curPsTdma;\r\n}\r\nstatic void\r\n_btdm_1AntSetPSTDMA(struct rtw_adapter *padapter, u8 bPSEn, u8 smartps,\r\nu8 psOption, u8 bTDMAOn, u8 tdmaType)\r\n{\r\nstruct pwrctrl_priv *pwrctrl;\r\nstruct hal_data_8723a *pHalData;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nu8 psMode;\r\nu8 bSwitchPS;\r\nif (!check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE) &&\r\n(get_fwstate(&padapter->mlmepriv) != WIFI_NULL_STATE)) {\r\nbtdm_1AntPsTdma(padapter, bTDMAOn, tdmaType);\r\nreturn;\r\n}\r\npsOption &= ~BIT(0);\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], Set LPS(%s, %d) TDMA(%s, %d)\n",\r\nbPSEn == true?"ON":"OFF", psOption,\r\nbTDMAOn == true?"ON":"OFF", tdmaType));\r\npwrctrl = &padapter->pwrctrlpriv;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nif (bPSEn) {\r\nif (pBtdm8723->bWiFiHalt) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Enable PS Fail, WiFi in Halt!!\n"));\r\nreturn;\r\n}\r\nif (pwrctrl->bInSuspend) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Enable PS Fail, WiFi in Suspend!!\n"));\r\nreturn;\r\n}\r\nif (padapter->bDriverStopped) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Enable PS Fail, WiFi driver stopped!!\n"));\r\nreturn;\r\n}\r\nif (padapter->bSurpriseRemoved) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Enable PS Fail, WiFi Surprise Removed!!\n"));\r\nreturn;\r\n}\r\npsMode = PS_MODE_MIN;\r\n} else {\r\npsMode = PS_MODE_ACTIVE;\r\npsOption = 0;\r\n}\r\nif (psMode != pwrctrl->pwr_mode) {\r\nbSwitchPS = true;\r\n} else if (psMode != PS_MODE_ACTIVE) {\r\nif (psOption != pwrctrl->bcn_ant_mode)\r\nbSwitchPS = true;\r\nelse if (smartps != pwrctrl->smart_ps)\r\nbSwitchPS = true;\r\nelse\r\nbSwitchPS = false;\r\n} else {\r\nbSwitchPS = false;\r\n}\r\nif (bSwitchPS) {\r\nif (pBtdm8723->bCurPsTdmaOn) {\r\nif (!bTDMAOn) {\r\nbtdm_1AntPsTdma(padapter, false, tdmaType);\r\n} else {\r\nif (!rtl8723a_BT_enabled(padapter) ||\r\n(pHalData->bt_coexist.halCoex8723.c2hBtInfo == BT_INFO_STATE_NO_CONNECTION) ||\r\n(pHalData->bt_coexist.halCoex8723.c2hBtInfo == BT_INFO_STATE_CONNECT_IDLE) ||\r\n(tdmaType == 29))\r\nbtdm_1AntPsTdma(padapter, false, 9);\r\nelse\r\nbtdm_1AntPsTdma(padapter, false, 0);\r\n}\r\n}\r\nbtdm_1AntSetPSMode(padapter, bPSEn, smartps, psOption);\r\n}\r\nbtdm_1AntPsTdma(padapter, bTDMAOn, tdmaType);\r\n}\r\nstatic void\r\nbtdm_1AntSetPSTDMA(struct rtw_adapter *padapter, u8 bPSEn,\r\nu8 psOption, u8 bTDMAOn, u8 tdmaType)\r\n{\r\n_btdm_1AntSetPSTDMA(padapter, bPSEn, 0, psOption, bTDMAOn, tdmaType);\r\n}\r\nstatic void btdm_1AntWifiParaAdjust(struct rtw_adapter *padapter, u8 bEnable)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_1ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nif (bEnable) {\r\npBtdm8723->curWifiPara = 1;\r\nif (pBtdm8723->preWifiPara != pBtdm8723->curWifiPara)\r\nBTDM_SetSwPenaltyTxRateAdaptive(padapter, BT_TX_RATE_ADAPTIVE_LOW_PENALTY);\r\n} else {\r\npBtdm8723->curWifiPara = 2;\r\nif (pBtdm8723->preWifiPara != pBtdm8723->curWifiPara)\r\nBTDM_SetSwPenaltyTxRateAdaptive(padapter, BT_TX_RATE_ADAPTIVE_NORMAL);\r\n}\r\n}\r\nstatic void btdm_1AntPtaParaReload(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write8(padapter, 0x6cc, 0x0);\r\nrtl8723au_write32(padapter, 0x6c8, 0xffff);\r\nrtl8723au_write32(padapter, 0x6c4, 0x55555555);\r\nrtl8723au_write32(padapter, 0x858, 0xaaaaaaaa);\r\nif (IS_8723A_A_CUT(GET_HAL_DATA(padapter)->VersionID)) {\r\nrtl8723au_write32(padapter, 0x870, 0x0);\r\nrtl8723au_write8(padapter, 0x40, 0x24);\r\n} else {\r\nrtl8723au_write8(padapter, 0x40, 0x20);\r\nrtl8723au_write16(padapter, 0x860, 0x210);\r\nrtl8723au_write32(padapter, 0x870, 0x300);\r\nrtl8723au_write32(padapter, 0x874, 0x22804000);\r\n}\r\nrtl8723au_write8(padapter, 0x778, 0x1);\r\nbtdm_SetFwIgnoreWlanAct(padapter, false);\r\n}\r\nstatic s8 btdm_1AntTdmaJudgement(struct rtw_adapter *padapter, u8 retry)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nstatic s8 up, dn, m = 1, n = 3, WaitCount;\r\ns8 ret;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nret = 0;\r\nif (pBtdm8723->psTdmaMonitorCnt == 0) {\r\nup = 0;\r\ndn = 0;\r\nm = 1;\r\nn = 3;\r\nWaitCount = 0;\r\n} else {\r\nWaitCount++;\r\n}\r\nif (retry == 0) {\r\nup++;\r\ndn--;\r\nif (dn < 0)\r\ndn = 0;\r\nif (up >= 3*m) {\r\nret = 1;\r\nn = 3;\r\nup = 0;\r\ndn = 0;\r\nWaitCount = 0;\r\n}\r\n} else if (retry <= 3) {\r\nup--;\r\ndn++;\r\nif (up < 0)\r\nup = 0;\r\nif (dn == 2) {\r\nret = -1;\r\nif (WaitCount <= 2)\r\nm++;\r\nelse\r\nm = 1;\r\nif (m >= 20)\r\nm = 20;\r\nup = 0;\r\ndn = 0;\r\nWaitCount = 0;\r\n}\r\n} else {\r\nret = -1;\r\nif (WaitCount == 1)\r\nm++;\r\nelse\r\nm = 1;\r\nif (m >= 20)\r\nm = 20;\r\nup = 0;\r\ndn = 0;\r\nWaitCount = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void btdm_1AntTdmaDurationAdjustForACL(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_1ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nif (pBtdm8723->psTdmaGlobalCnt != pBtdm8723->psTdmaMonitorCnt) {\r\npBtdm8723->psTdmaMonitorCnt = 0;\r\npBtdm8723->psTdmaGlobalCnt = 0;\r\n}\r\nif (pBtdm8723->psTdmaMonitorCnt == 0) {\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else {\r\nif ((pBtdm8723->curPsTdma != 1) &&\r\n(pBtdm8723->curPsTdma != 2) &&\r\n(pBtdm8723->curPsTdma != 9) &&\r\n(pBtdm8723->curPsTdma != 11)) {\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, pBtdm8723->psTdmaDuAdjType);\r\n} else {\r\ns32 judge = 0;\r\njudge = btdm_1AntTdmaJudgement(padapter, pHalData->bt_coexist.halCoex8723.btRetryCnt);\r\nif (judge == -1) {\r\nif (pBtdm8723->curPsTdma == 1) {\r\nif (pHalData->bt_coexist.halCoex8723.btInfoExt)\r\npBtdm8723->psTdmaDuAdjType = 9;\r\nelse\r\npBtdm8723->psTdmaDuAdjType = 2;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, pBtdm8723->psTdmaDuAdjType);\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 9);\r\npBtdm8723->psTdmaDuAdjType = 9;\r\n} else if (pBtdm8723->curPsTdma == 9) {\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n}\r\n} else if (judge == 1) {\r\nif (pBtdm8723->curPsTdma == 11) {\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 9);\r\npBtdm8723->psTdmaDuAdjType = 9;\r\n} else if (pBtdm8723->curPsTdma == 9) {\r\nif (pHalData->bt_coexist.halCoex8723.btInfoExt)\r\npBtdm8723->psTdmaDuAdjType = 9;\r\nelse\r\npBtdm8723->psTdmaDuAdjType = 2;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, pBtdm8723->psTdmaDuAdjType);\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nif (pHalData->bt_coexist.halCoex8723.btInfoExt)\r\npBtdm8723->psTdmaDuAdjType = 9;\r\nelse\r\npBtdm8723->psTdmaDuAdjType = 1;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, pBtdm8723->psTdmaDuAdjType);\r\n}\r\n}\r\n}\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], ACL current TDMA(%s, %d)\n",\r\n(pBtdm8723->bCurPsTdmaOn ? "ON" : "OFF"), pBtdm8723->curPsTdma));\r\n}\r\npBtdm8723->psTdmaMonitorCnt++;\r\n}\r\nstatic void btdm_1AntCoexProcessForWifiConnect(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nu8 BtState;\r\npmlmepriv = &padapter->mlmepriv;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\npBtdm8723 = &pBtCoex->btdm1Ant;\r\nBtState = pBtCoex->c2hBtInfo;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], WiFi is %s\n",\r\nBTDM_IsWifiBusy(padapter)?"Busy":"IDLE"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT is %s\n",\r\nBtStateString[BtState]));\r\npadapter->pwrctrlpriv.btcoex_rfon = false;\r\nif (!BTDM_IsWifiBusy(padapter) &&\r\n!check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) &&\r\n(BtState == BT_INFO_STATE_NO_CONNECTION ||\r\nBtState == BT_INFO_STATE_CONNECT_IDLE)) {\r\nswitch (BtState) {\r\ncase BT_INFO_STATE_NO_CONNECTION:\r\n_btdm_1AntSetPSTDMA(padapter, true, 2, 0x26, false, 9);\r\nbreak;\r\ncase BT_INFO_STATE_CONNECT_IDLE:\r\n_btdm_1AntSetPSTDMA(padapter, true, 2, 0x26, false, 0);\r\nbreak;\r\n}\r\n} else {\r\nswitch (BtState) {\r\ncase BT_INFO_STATE_NO_CONNECTION:\r\ncase BT_INFO_STATE_CONNECT_IDLE:\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, true, 5);\r\nrtl8723au_write32(padapter, 0x6c0, 0x5a5a5a5a);\r\nrtl8723au_write32(padapter, 0x6c4, 0x5a5a5a5a);\r\nbreak;\r\ncase BT_INFO_STATE_ACL_INQ_OR_PAG:\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is "\r\n"BT_INFO_STATE_ACL_INQ_OR_PAG\n"));\r\ncase BT_INFO_STATE_INQ_OR_PAG:\r\npadapter->pwrctrlpriv.btcoex_rfon = true;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 30);\r\nbreak;\r\ncase BT_INFO_STATE_SCO_ONLY_BUSY:\r\ncase BT_INFO_STATE_ACL_SCO_BUSY:\r\nif (true == pBtCoex->bC2hBtInquiryPage)\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 32);\r\nelse {\r\n#ifdef BTCOEX_CMCC_TEST\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 23);\r\n#else\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\nfalse, 8);\r\nrtl8723au_write32(padapter, 0x6c0, 0x5a5a5a5a);\r\nrtl8723au_write32(padapter, 0x6c4, 0x5a5a5a5a);\r\n#endif\r\n}\r\nbreak;\r\ncase BT_INFO_STATE_ACL_ONLY_BUSY:\r\npadapter->pwrctrlpriv.btcoex_rfon = true;\r\nif (pBtCoex->c2hBtProfile == BT_INFO_HID) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is HID\n"));\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 31);\r\n} else if (pBtCoex->c2hBtProfile == BT_INFO_FTP) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is FTP/OPP\n"));\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 3);\r\n} else if (pBtCoex->c2hBtProfile == (BT_INFO_A2DP|BT_INFO_FTP)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is A2DP_FTP\n"));\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 11);\r\n} else {\r\nif (pBtCoex->c2hBtProfile == BT_INFO_A2DP)\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is "\r\n"A2DP\n"));\r\nelse\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], BT PROFILE is "\r\n"UNKNOWN(0x%02X)! Use A2DP "\r\n"Profile\n",\r\npBtCoex->c2hBtProfile));\r\nbtdm_1AntTdmaDurationAdjustForACL(padapter);\r\n}\r\nbreak;\r\n}\r\n}\r\npBtdm8723->psTdmaGlobalCnt++;\r\n}\r\nstatic void\r\nbtdm_1AntUpdateHalRAMask(struct rtw_adapter *padapter, u32 mac_id, u32 filter)\r\n{\r\nu8 init_rate = 0;\r\nu8 raid, arg;\r\nu32 mask;\r\nu8 shortGIrate = false;\r\nint supportRateNum = 0;\r\nstruct sta_info *psta;\r\nstruct hal_data_8723a *pHalData;\r\nstruct dm_priv *pdmpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nstruct wlan_bssid_ex *cur_network;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], %s, MACID =%d, filter = 0x%08x!!\n",\r\n__func__, mac_id, filter));\r\npHalData = GET_HAL_DATA(padapter);\r\npdmpriv = &pHalData->dmpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\ncur_network = &pmlmeinfo->network;\r\nif (mac_id >= NUM_STA) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], %s, MACID =%d illegal!!\n",\r\n__func__, mac_id));\r\nreturn;\r\n}\r\npsta = pmlmeinfo->FW_sta_info[mac_id].psta;\r\nif (!psta) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], %s, Can't find station!!\n",\r\n__func__));\r\nreturn;\r\n}\r\nraid = psta->raid;\r\nswitch (mac_id) {\r\ncase 0:\r\nsupportRateNum =\r\nrtw_get_rateset_len23a(cur_network->SupportedRates);\r\nmask = update_supported_rate23a(cur_network->SupportedRates,\r\nsupportRateNum);\r\nmask |= (pmlmeinfo->HT_enable) ?\r\nupdate_MSC_rate23a(&pmlmeinfo->ht_cap):0;\r\nif (support_short_GI23a(padapter, &pmlmeinfo->ht_cap))\r\nshortGIrate = true;\r\nbreak;\r\ncase 1:\r\nsupportRateNum = rtw_get_rateset_len23a(\r\npmlmeinfo->FW_sta_info[mac_id].SupportedRates);\r\nmask = update_basic_rate23a(cur_network->SupportedRates,\r\nsupportRateNum);\r\nbreak;\r\ndefault:\r\nsupportRateNum = rtw_get_rateset_len23a(\r\npmlmeinfo->FW_sta_info[mac_id].SupportedRates);\r\nmask = update_supported_rate23a(cur_network->SupportedRates,\r\nsupportRateNum);\r\nbreak;\r\n}\r\nmask |= ((raid<<28)&0xf0000000);\r\nmask &= 0xffffffff;\r\nmask &= ~filter;\r\ninit_rate = get_highest_rate_idx23a(mask)&0x3f;\r\narg = mac_id&0x1f;\r\narg |= BIT(7);\r\nif (true == shortGIrate)\r\narg |= BIT(5);\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], Update FW RAID entry, MASK = 0x%08x, "\r\n"arg = 0x%02x\n", mask, arg));\r\nrtl8723a_set_raid_cmd(padapter, mask, arg);\r\npsta->init_rate = init_rate;\r\npdmpriv->INIDATA_RATE[mac_id] = init_rate;\r\n}\r\nstatic void\r\nbtdm_1AntUpdateHalRAMaskForSCO(struct rtw_adapter *padapter, u8 forceUpdate)\r\n{\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nstruct sta_priv *pstapriv;\r\nstruct wlan_bssid_ex *cur_network;\r\nstruct sta_info *psta;\r\nu32 macid;\r\nu32 filter = 0;\r\npBtdm8723 = &GET_HAL_DATA(padapter)->bt_coexist.halCoex8723.btdm1Ant;\r\nif (pBtdm8723->bRAChanged == true && forceUpdate == false)\r\nreturn;\r\npstapriv = &padapter->stapriv;\r\ncur_network = &padapter->mlmeextpriv.mlmext_info.network;\r\npsta = rtw_get_stainfo23a(pstapriv, cur_network->MacAddress);\r\nmacid = psta->mac_id;\r\nfilter |= BIT(_1M_RATE_);\r\nfilter |= BIT(_2M_RATE_);\r\nfilter |= BIT(_5M_RATE_);\r\nfilter |= BIT(_11M_RATE_);\r\nfilter |= BIT(_6M_RATE_);\r\nfilter |= BIT(_9M_RATE_);\r\nbtdm_1AntUpdateHalRAMask(padapter, macid, filter);\r\npBtdm8723->bRAChanged = true;\r\n}\r\nstatic void btdm_1AntRecoverHalRAMask(struct rtw_adapter *padapter)\r\n{\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nstruct sta_priv *pstapriv;\r\nstruct wlan_bssid_ex *cur_network;\r\nstruct sta_info *psta;\r\npBtdm8723 = &GET_HAL_DATA(padapter)->bt_coexist.halCoex8723.btdm1Ant;\r\nif (pBtdm8723->bRAChanged == false)\r\nreturn;\r\npstapriv = &padapter->stapriv;\r\ncur_network = &padapter->mlmeextpriv.mlmext_info.network;\r\npsta = rtw_get_stainfo23a(pstapriv, cur_network->MacAddress);\r\nUpdate_RA_Entry23a(padapter, psta);\r\npBtdm8723->bRAChanged = false;\r\n}\r\nstatic void\r\nbtdm_1AntBTStateChangeHandler(struct rtw_adapter *padapter,\r\nenum bt_state_1ant oldState,\r\nenum bt_state_1ant newState)\r\n{\r\nstruct hal_data_8723a *phaldata;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT state change, %s => %s\n",\r\nBtStateString[oldState],\r\nBtStateString[newState]));\r\nif (newState > BT_INFO_STATE_DISABLED)\r\nbtdm_SetFwIgnoreWlanAct(padapter, false);\r\nif ((check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE)) &&\r\n(BTDM_IsWifiConnectionExist(padapter))) {\r\nif ((newState == BT_INFO_STATE_SCO_ONLY_BUSY) ||\r\n(newState == BT_INFO_STATE_ACL_SCO_BUSY)) {\r\nbtdm_1AntUpdateHalRAMaskForSCO(padapter, false);\r\n} else {\r\nbtdm_1AntRecoverHalRAMask(padapter);\r\n}\r\n} else {\r\nphaldata = GET_HAL_DATA(padapter);\r\nphaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = false;\r\n}\r\nif (oldState == newState)\r\nreturn;\r\nif (oldState == BT_INFO_STATE_ACL_ONLY_BUSY) {\r\nstruct hal_data_8723a *Hal = GET_HAL_DATA(padapter);\r\nHal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCnt = 0;\r\nHal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0;\r\n}\r\nif ((oldState == BT_INFO_STATE_SCO_ONLY_BUSY) ||\r\n(oldState == BT_INFO_STATE_ACL_SCO_BUSY)) {\r\nstruct hal_data_8723a *Hal = GET_HAL_DATA(padapter);\r\nHal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0;\r\n}\r\nif ((oldState == BT_INFO_STATE_DISABLED) ||\r\n(oldState == BT_INFO_STATE_NO_CONNECTION)) {\r\nif ((newState != BT_INFO_STATE_DISABLED) &&\r\n(newState != BT_INFO_STATE_NO_CONNECTION)) {\r\nBTDM_SetSwRfRxLpfCorner(padapter,\r\nBT_RF_RX_LPF_CORNER_SHRINK);\r\nBTDM_AGCTable(padapter, BT_AGCTABLE_ON);\r\nBTDM_BBBackOffLevel(padapter, BT_BB_BACKOFF_ON);\r\n}\r\n} else {\r\nif ((newState == BT_INFO_STATE_DISABLED) ||\r\n(newState == BT_INFO_STATE_NO_CONNECTION)) {\r\nBTDM_SetSwRfRxLpfCorner(padapter,\r\nBT_RF_RX_LPF_CORNER_RESUME);\r\nBTDM_AGCTable(padapter, BT_AGCTABLE_OFF);\r\nBTDM_BBBackOffLevel(padapter, BT_BB_BACKOFF_OFF);\r\n}\r\n}\r\n}\r\nstatic void btdm_1AntBtCoexistHandler(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_coexist_8723a *pBtCoex8723;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtCoex8723 = &pHalData->bt_coexist.halCoex8723;\r\npBtdm8723 = &pBtCoex8723->btdm1Ant;\r\npadapter->pwrctrlpriv.btcoex_rfon = false;\r\nif (!rtl8723a_BT_enabled(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT is disabled\n"));\r\nif (BTDM_IsWifiConnectionExist(padapter)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is connected\n"));\r\nif (BTDM_IsWifiBusy(padapter)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], Wifi is busy\n"));\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\nfalse, 9);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], Wifi is idle\n"));\r\n_btdm_1AntSetPSTDMA(padapter, true, 2, 1,\r\nfalse, 9);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is disconnected\n"));\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, false, 9);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT is enabled\n"));\r\nif (BTDM_IsWifiConnectionExist(padapter)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is connected\n"));\r\nbtdm_1AntWifiParaAdjust(padapter, true);\r\nbtdm_1AntCoexProcessForWifiConnect(padapter);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is disconnected\n"));\r\nbtdm_1AntWifiParaAdjust(padapter, false);\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, false, 0);\r\n}\r\n}\r\nbtdm_1AntBTStateChangeHandler(padapter, pBtCoex8723->prec2hBtInfo,\r\npBtCoex8723->c2hBtInfo);\r\npBtCoex8723->prec2hBtInfo = pBtCoex8723->c2hBtInfo;\r\n}\r\nvoid BTDM_1AntSignalCompensation(struct rtw_adapter *padapter,\r\nu8 *rssi_wifi, u8 *rssi_bt)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\nu8 RSSI_WiFi_Cmpnstn, RSSI_BT_Cmpnstn;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm1Ant;\r\nRSSI_WiFi_Cmpnstn = 0;\r\nRSSI_BT_Cmpnstn = 0;\r\nswitch (pBtdm8723->curPsTdma) {\r\ncase 1:\r\nRSSI_WiFi_Cmpnstn = 11;\r\nbreak;\r\ncase 2:\r\nRSSI_WiFi_Cmpnstn = 14;\r\nbreak;\r\ncase 9:\r\nRSSI_WiFi_Cmpnstn = 18;\r\nbreak;\r\ncase 11:\r\nRSSI_WiFi_Cmpnstn = 20;\r\nbreak;\r\ncase 4:\r\nRSSI_WiFi_Cmpnstn = 17;\r\nbreak;\r\ncase 16:\r\nRSSI_WiFi_Cmpnstn = 18;\r\nbreak;\r\ncase 18:\r\nRSSI_WiFi_Cmpnstn = 14;\r\nbreak;\r\ncase 23:\r\ncase 24:\r\ncase 25:\r\ncase 26:\r\ncase 27:\r\ncase 33:\r\nRSSI_WiFi_Cmpnstn = 22;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (rssi_wifi && RSSI_WiFi_Cmpnstn) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], 1AntSgnlCmpnstn, case %d, WiFiCmpnstn "\r\n"=%d(%d => %d)\n", pBtdm8723->curPsTdma,\r\nRSSI_WiFi_Cmpnstn, *rssi_wifi,\r\n*rssi_wifi+RSSI_WiFi_Cmpnstn));\r\n*rssi_wifi += RSSI_WiFi_Cmpnstn;\r\n}\r\nif (rssi_bt && RSSI_BT_Cmpnstn) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], 1AntSgnlCmpnstn, case %d, BTCmpnstn "\r\n"=%d(%d => %d)\n", pBtdm8723->curPsTdma,\r\nRSSI_BT_Cmpnstn, *rssi_bt, *rssi_bt+RSSI_BT_Cmpnstn));\r\n*rssi_bt += RSSI_BT_Cmpnstn;\r\n}\r\n}\r\nstatic void BTDM_1AntParaInit(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\npBtdm8723 = &pBtCoex->btdm1Ant;\r\nrtl8723au_write8(padapter, 0x76e, 0x4);\r\nbtdm_1AntPtaParaReload(padapter);\r\npBtdm8723->wifiRssiThresh = 48;\r\npBtdm8723->bWiFiHalt = false;\r\npBtdm8723->bRAChanged = false;\r\nif ((pBtCoex->c2hBtInfo != BT_INFO_STATE_DISABLED) &&\r\n(pBtCoex->c2hBtInfo != BT_INFO_STATE_NO_CONNECTION)) {\r\nBTDM_SetSwRfRxLpfCorner(padapter, BT_RF_RX_LPF_CORNER_SHRINK);\r\nBTDM_AGCTable(padapter, BT_AGCTABLE_ON);\r\nBTDM_BBBackOffLevel(padapter, BT_BB_BACKOFF_ON);\r\n}\r\n}\r\nstatic void BTDM_1AntForHalt(struct rtw_adapter *padapter)\r\n{\r\nRTPRINT(FBT, BT_TRACE, ("\n[BTCoex], 1Ant for halt\n"));\r\nGET_HAL_DATA(padapter)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt =\r\ntrue;\r\nbtdm_1AntWifiParaAdjust(padapter, false);\r\nbtdm_1AntPsTdma(padapter, false, 0);\r\nbtdm_SetFwIgnoreWlanAct(padapter, true);\r\n}\r\nstatic void BTDM_1AntLpsLeave(struct rtw_adapter *padapter)\r\n{\r\nRTPRINT(FBT, BT_TRACE, ("\n[BTCoex], 1Ant for LPS Leave\n"));\r\nGET_HAL_DATA(padapter)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt =\r\ntrue;\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, false, 8);\r\n}\r\nstatic void BTDM_1AntWifiAssociateNotify(struct rtw_adapter *padapter, u8 type)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRTPRINT(FBT, BT_TRACE,\r\n("\n[BTCoex], 1Ant for associate, type =%d\n", type));\r\nif (type) {\r\nrtl8723a_CheckAntenna_Selection(padapter);\r\nif (!rtl8723a_BT_enabled(padapter))\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, false, 9);\r\nelse {\r\nstruct bt_coexist_8723a *pBtCoex;\r\nu8 BtState;\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nBtState = pBtCoex->c2hBtInfo;\r\nbtdm_1AntTSFSwitch(padapter, true);\r\nif (BtState == BT_INFO_STATE_NO_CONNECTION ||\r\nBtState == BT_INFO_STATE_CONNECT_IDLE) {\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 28);\r\n} else if (BtState == BT_INFO_STATE_SCO_ONLY_BUSY ||\r\nBtState == BT_INFO_STATE_ACL_SCO_BUSY) {\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\nfalse, 8);\r\nrtl8723au_write32(padapter, 0x6c0, 0x5a5a5a5a);\r\nrtl8723au_write32(padapter, 0x6c4, 0x5a5a5a5a);\r\n} else if (BtState == BT_INFO_STATE_ACL_ONLY_BUSY ||\r\nBtState == BT_INFO_STATE_ACL_INQ_OR_PAG) {\r\nif (pBtCoex->c2hBtProfile == BT_INFO_HID)\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 35);\r\nelse\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 29);\r\n}\r\n}\r\n} else {\r\nif (!rtl8723a_BT_enabled(padapter)) {\r\nif (!BTDM_IsWifiConnectionExist(padapter)) {\r\nbtdm_1AntPsTdma(padapter, false, 0);\r\nbtdm_1AntTSFSwitch(padapter, false);\r\n}\r\n}\r\nbtdm_1AntBtCoexistHandler(padapter);\r\n}\r\n}\r\nstatic void\r\nBTDM_1AntMediaStatusNotify(struct rtw_adapter *padapter,\r\nenum rt_media_status mstatus)\r\n{\r\nstruct bt_coexist_8723a *pBtCoex;\r\npBtCoex = &GET_HAL_DATA(padapter)->bt_coexist.halCoex8723;\r\nRTPRINT(FBT, BT_TRACE,\r\n("\n\n[BTCoex]******************************\n"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], MediaStatus, WiFi %s !!\n",\r\nmstatus == RT_MEDIA_CONNECT?"CONNECT":"DISCONNECT"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex]******************************\n"));\r\nif (RT_MEDIA_CONNECT == mstatus) {\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE)) {\r\nif (pBtCoex->c2hBtInfo == BT_INFO_STATE_SCO_ONLY_BUSY ||\r\npBtCoex->c2hBtInfo == BT_INFO_STATE_ACL_SCO_BUSY)\r\nbtdm_1AntUpdateHalRAMaskForSCO(padapter, true);\r\n}\r\npadapter->pwrctrlpriv.DelayLPSLastTimeStamp = jiffies;\r\nBTDM_1AntForDhcp(padapter);\r\n} else {\r\nrtl8723a_DeinitAntenna_Selection(padapter);\r\nbtdm_1AntBtCoexistHandler(padapter);\r\npBtCoex->btdm1Ant.bRAChanged = false;\r\n}\r\n}\r\nvoid BTDM_1AntForDhcp(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nu8 BtState;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nBtState = pBtCoex->c2hBtInfo;\r\npBtdm8723 = &pBtCoex->btdm1Ant;\r\nRTPRINT(FBT, BT_TRACE, ("\n[BTCoex], 1Ant for DHCP\n"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 1Ant for DHCP, WiFi is %s\n",\r\nBTDM_IsWifiBusy(padapter)?"Busy":"IDLE"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 1Ant for DHCP, %s\n",\r\nBtStateString[BtState]));\r\nBTDM_1AntWifiAssociateNotify(padapter, true);\r\n}\r\nstatic void BTDM_1AntWifiScanNotify(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nu8 BtState;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nstruct btdm_8723a_1ant *pBtdm8723;\r\npHalData = GET_HAL_DATA(padapter);\r\nBtState = pHalData->bt_coexist.halCoex8723.c2hBtInfo;\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\npBtdm8723 = &pBtCoex->btdm1Ant;\r\nRTPRINT(FBT, BT_TRACE, ("\n[BTCoex], 1Ant for wifi scan =%d!!\n",\r\nscanType));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 1Ant for wifi scan, WiFi is %s\n",\r\nBTDM_IsWifiBusy(padapter)?"Busy":"IDLE"));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 1Ant for wifi scan, %s\n",\r\nBtStateString[BtState]));\r\nif (scanType) {\r\nrtl8723a_CheckAntenna_Selection(padapter);\r\nif (!rtl8723a_BT_enabled(padapter)) {\r\nbtdm_1AntSetPSTDMA(padapter, false, 0, false, 9);\r\n} else if (BTDM_IsWifiConnectionExist(padapter) == false) {\r\nBTDM_1AntWifiAssociateNotify(padapter, true);\r\n} else {\r\nif ((BtState == BT_INFO_STATE_SCO_ONLY_BUSY) ||\r\n(BtState == BT_INFO_STATE_ACL_SCO_BUSY)) {\r\nif (pBtCoex->bC2hBtInquiryPage) {\r\nbtdm_1AntSetPSTDMA(padapter, false, 0,\r\ntrue, 32);\r\n} else {\r\npadapter->pwrctrlpriv.btcoex_rfon =\r\ntrue;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0,\r\ntrue, 33);\r\n}\r\n} else if (true == pBtCoex->bC2hBtInquiryPage) {\r\npadapter->pwrctrlpriv.btcoex_rfon = true;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 30);\r\n} else if (BtState == BT_INFO_STATE_ACL_ONLY_BUSY) {\r\npadapter->pwrctrlpriv.btcoex_rfon = true;\r\nif (pBtCoex->c2hBtProfile == BT_INFO_HID)\r\nbtdm_1AntSetPSTDMA(padapter, true, 0,\r\ntrue, 34);\r\nelse\r\nbtdm_1AntSetPSTDMA(padapter, true, 0,\r\ntrue, 4);\r\n} else {\r\npadapter->pwrctrlpriv.btcoex_rfon = true;\r\nbtdm_1AntSetPSTDMA(padapter, true, 0, true, 5);\r\n}\r\n}\r\nbtdm_NotifyFwScan(padapter, 1);\r\n} else {\r\nbtdm_NotifyFwScan(padapter, 0);\r\nbtdm_1AntBtCoexistHandler(padapter);\r\n}\r\n}\r\nstatic void BTDM_1AntFwC2hBtInfo8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nu8 u1tmp, btState;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nu1tmp = pBtCoex->c2hBtInfoOriginal;\r\nbtState = u1tmp & 0xF;\r\npBtCoex->c2hBtProfile = u1tmp & 0xE0;\r\npBtMgnt->ExtConfig.bBTBusy = false;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_IDLE;\r\nif (btState & BIT(2))\r\npBtCoex->bC2hBtInquiryPage = true;\r\nelse\r\npBtCoex->bC2hBtInquiryPage = false;\r\nbtState &= ~BIT(2);\r\nif (!(btState & BIT(0)))\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_NO_CONNECTION;\r\nelse {\r\nif (btState == 0x1)\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_CONNECT_IDLE;\r\nelse if (btState == 0x9) {\r\nif (pBtCoex->bC2hBtInquiryPage == true)\r\npBtCoex->c2hBtInfo =\r\nBT_INFO_STATE_ACL_INQ_OR_PAG;\r\nelse\r\npBtCoex->c2hBtInfo =\r\nBT_INFO_STATE_ACL_ONLY_BUSY;\r\npBtMgnt->ExtConfig.bBTBusy = true;\r\n} else if (btState == 0x3) {\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_SCO_ONLY_BUSY;\r\npBtMgnt->ExtConfig.bBTBusy = true;\r\n} else if (btState == 0xb) {\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_ACL_SCO_BUSY;\r\npBtMgnt->ExtConfig.bBTBusy = true;\r\n} else\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_MAX;\r\nif (pBtMgnt->ExtConfig.bBTBusy)\r\npHalData->bt_coexist.CurrentState &=\r\n~BT_COEX_STATE_BT_IDLE;\r\n}\r\nif (BT_INFO_STATE_NO_CONNECTION == pBtCoex->c2hBtInfo ||\r\nBT_INFO_STATE_CONNECT_IDLE == pBtCoex->c2hBtInfo) {\r\nif (pBtCoex->bC2hBtInquiryPage)\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_INQ_OR_PAG;\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], %s(%d)\n",\r\nBtStateString[pBtCoex->c2hBtInfo], pBtCoex->c2hBtInfo));\r\nif (pBtCoex->c2hBtProfile != BT_INFO_HID)\r\npBtCoex->c2hBtProfile &= ~BT_INFO_HID;\r\n}\r\nvoid BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct hal_data_8723a *pHalData;\r\nunsigned long delta_time;\r\npmlmepriv = &padapter->mlmepriv;\r\npHalData = GET_HAL_DATA(padapter);\r\nif (check_fwstate(pmlmepriv, WIFI_SITE_MONITOR)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is under scan progress!!\n"));\r\nreturn;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_UNDER_LINKING)) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], wifi is under link progress!!\n"));\r\nreturn;\r\n}\r\ndelta_time = jiffies - padapter->pwrctrlpriv.DelayLPSLastTimeStamp;\r\ndelta_time = jiffies_to_msecs(delta_time);\r\nif (delta_time < 500) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], wifi is under DHCP "\r\n"progress(%li ms)!!\n", delta_time));\r\nreturn;\r\n}\r\nBTDM_CheckWiFiState(padapter);\r\nbtdm_1AntBtCoexistHandler(padapter);\r\n}\r\nstatic u8 btdm_ActionAlgorithm(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nu8 bScoExist = false, bBtLinkExist = false, bBtHsModeExist = false;\r\nu8 algorithm = BT_2ANT_COEX_ALGO_UNDEFINED;\r\nif (pBtMgnt->ExtConfig.NumberOfHandle)\r\nbBtLinkExist = true;\r\nif (pBtMgnt->ExtConfig.NumberOfSCO)\r\nbScoExist = true;\r\nif (BT_HsConnectionEstablished(padapter))\r\nbBtHsModeExist = true;\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_IDLE;\r\nif ((bScoExist) || (bBtHsModeExist) ||\r\n(BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID))) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_NON_IDLE;\r\n} else {\r\nif ((pBtMgnt->ExtConfig.NumberOfHandle == 1) &&\r\n(BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP))) {\r\nif (BTDM_BtTxRxCounterL(padapter) < 100) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_NON_IDLE;\r\n}\r\n}\r\nif ((pBtMgnt->ExtConfig.NumberOfHandle == 1) &&\r\n(BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN))) {\r\nif (BTDM_BtTxRxCounterL(padapter) < 600) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n} else {\r\nif (pHalData->bt_coexist.halCoex8723.lowPriorityTx) {\r\nif ((pHalData->bt_coexist.halCoex8723.lowPriorityRx /\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx) > 9) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n}\r\n}\r\n}\r\nif (BT_2ANT_BT_STATUS_CONNECTED_IDLE != pBtdm8723->btStatus) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN, set BT non-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_NON_IDLE;\r\n}\r\n}\r\nif ((pBtMgnt->ExtConfig.NumberOfHandle == 2) &&\r\n(BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) &&\r\n(BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN))) {\r\nif (BTDM_BtTxRxCounterL(padapter) < 600) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n} else {\r\nif (pHalData->bt_coexist.halCoex8723.lowPriorityTx) {\r\nif ((pHalData->bt_coexist.halCoex8723.lowPriorityRx /\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx) > 9) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n}\r\n}\r\n}\r\nif (BT_2ANT_BT_STATUS_CONNECTED_IDLE != pBtdm8723->btStatus) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN+A2DP, set BT non-idle!!!\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_NON_IDLE;\r\n}\r\n}\r\n}\r\nif (BT_2ANT_BT_STATUS_IDLE != pBtdm8723->btStatus)\r\npBtMgnt->ExtConfig.bBTBusy = true;\r\nelse\r\npBtMgnt->ExtConfig.bBTBusy = false;\r\nif (!bBtLinkExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], No profile exists!!!\n"));\r\nreturn algorithm;\r\n}\r\nif (pBtMgnt->ExtConfig.NumberOfHandle == 1) {\r\nif (bScoExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_SCO;\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID;\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_A2DP;\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN(HS) only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANHS;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN(EDR) only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d \n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n}\r\n} else if (pBtMgnt->ExtConfig.NumberOfHandle == 2) {\r\nif (bScoExist) {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + HID\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID;\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + A2DP\n"));\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_SCO;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO exists but why NO matched ACL profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_A2DP;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n}\r\n} else if (pBtMgnt->ExtConfig.NumberOfHandle == 3) {\r\nif (bScoExist) {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + HID + A2DP\n"));\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + HID + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + HID + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\n} else if (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_SCO;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + A2DP + PAN(EDR)\n"));\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP_PANHS;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP_PANEDR;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n}\r\n} else if (pBtMgnt->ExtConfig.NumberOfHandle >= 3) {\r\nif (bScoExist) {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\nif (bBtHsModeExist)\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n"));\r\nelse\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + HID + A2DP + PAN(EDR)\n"));\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",\r\npBtMgnt->ExtConfig.NumberOfHandle));\r\n}\r\n}\r\nreturn algorithm;\r\n}\r\nstatic u8 btdm_NeedToDecBtPwr(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 bRet = false;\r\nif (BT_Operation(padapter)) {\r\nif (pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB > 47) {\r\nRTPRINT(FBT, BT_TRACE, ("Need to decrease bt power for HS mode!!\n"));\r\nbRet = true;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("NO Need to decrease bt power for HS mode!!\n"));\r\n}\r\n} else {\r\nif (BTDM_IsWifiConnectionExist(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("Need to decrease bt power for Wifi is connected!!\n"));\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nstatic void\r\nbtdm_SetCoexTable(struct rtw_adapter *padapter, u32 val0x6c0,\r\nu32 val0x6c8, u8 val0x6cc)\r\n{\r\nRTPRINT(FBT, BT_TRACE, ("set coex table, set 0x6c0 = 0x%x\n", val0x6c0));\r\nrtl8723au_write32(padapter, 0x6c0, val0x6c0);\r\nRTPRINT(FBT, BT_TRACE, ("set coex table, set 0x6c8 = 0x%x\n", val0x6c8));\r\nrtl8723au_write32(padapter, 0x6c8, val0x6c8);\r\nRTPRINT(FBT, BT_TRACE, ("set coex table, set 0x6cc = 0x%x\n", val0x6cc));\r\nrtl8723au_write8(padapter, 0x6cc, val0x6cc);\r\n}\r\nstatic void\r\nbtdm_SetSwFullTimeDacSwing(struct rtw_adapter *padapter, u8 bSwDacSwingOn,\r\nu32 swDacSwingLvl)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (bSwDacSwingOn) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SwDacSwing = 0x%x\n", swDacSwingLvl));\r\nPHY_SetBBReg(padapter, 0x880, 0xff000000, swDacSwingLvl);\r\npHalData->bt_coexist.bSWCoexistAllOff = false;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SwDacSwing Off!\n"));\r\nPHY_SetBBReg(padapter, 0x880, 0xff000000, 0xc0);\r\n}\r\n}\r\nstatic void\r\nbtdm_SetFwDacSwingLevel(struct rtw_adapter *padapter, u8 dacSwingLvl)\r\n{\r\nu8 H2C_Parameter[1] = {0};\r\nH2C_Parameter[0] = dacSwingLvl;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Set Dac Swing Level = 0x%x\n", dacSwingLvl));\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], write 0x29 = 0x%x\n", H2C_Parameter[0]));\r\nFillH2CCmd(padapter, 0x29, 1, H2C_Parameter);\r\n}\r\nstatic void btdm_2AntDecBtPwr(struct rtw_adapter *padapter, u8 bDecBtPwr)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], Dec BT power = %s\n",\r\n((bDecBtPwr) ? "ON" : "OFF")));\r\npBtdm8723->bCurDecBtPwr = bDecBtPwr;\r\nif (pBtdm8723->bPreDecBtPwr == pBtdm8723->bCurDecBtPwr)\r\nreturn;\r\nBTDM_SetFwDecBtPwr(padapter, pBtdm8723->bCurDecBtPwr);\r\npBtdm8723->bPreDecBtPwr = pBtdm8723->bCurDecBtPwr;\r\n}\r\nstatic void\r\nbtdm_2AntFwDacSwingLvl(struct rtw_adapter *padapter, u8 fwDacSwingLvl)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], set FW Dac Swing level = %d\n", fwDacSwingLvl));\r\npBtdm8723->curFwDacSwingLvl = fwDacSwingLvl;\r\nif (pBtdm8723->preFwDacSwingLvl == pBtdm8723->curFwDacSwingLvl)\r\nreturn;\r\nbtdm_SetFwDacSwingLevel(padapter, pBtdm8723->curFwDacSwingLvl);\r\npBtdm8723->preFwDacSwingLvl = pBtdm8723->curFwDacSwingLvl;\r\n}\r\nstatic void\r\nbtdm_2AntRfShrink(struct rtw_adapter *padapter, u8 bRxRfShrinkOn)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn Rx RF Shrink = %s\n",\r\n((bRxRfShrinkOn) ? "ON" : "OFF")));\r\npBtdm8723->bCurRfRxLpfShrink = bRxRfShrinkOn;\r\nif (pBtdm8723->bPreRfRxLpfShrink == pBtdm8723->bCurRfRxLpfShrink)\r\nreturn;\r\nBTDM_SetSwRfRxLpfCorner(padapter, (u8)pBtdm8723->bCurRfRxLpfShrink);\r\npBtdm8723->bPreRfRxLpfShrink = pBtdm8723->bCurRfRxLpfShrink;\r\n}\r\nstatic void\r\nbtdm_2AntLowPenaltyRa(struct rtw_adapter *padapter, u8 bLowPenaltyRa)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn LowPenaltyRA = %s\n",\r\n((bLowPenaltyRa) ? "ON" : "OFF")));\r\npBtdm8723->bCurLowPenaltyRa = bLowPenaltyRa;\r\nif (pBtdm8723->bPreLowPenaltyRa == pBtdm8723->bCurLowPenaltyRa)\r\nreturn;\r\nBTDM_SetSwPenaltyTxRateAdaptive(padapter, (u8)pBtdm8723->bCurLowPenaltyRa);\r\npBtdm8723->bPreLowPenaltyRa = pBtdm8723->bCurLowPenaltyRa;\r\n}\r\nstatic void\r\nbtdm_2AntDacSwing(struct rtw_adapter *padapter,\r\nu8 bDacSwingOn, u32 dacSwingLvl)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn DacSwing =%s, dacSwingLvl = 0x%x\n",\r\n(bDacSwingOn ? "ON" : "OFF"), dacSwingLvl));\r\npBtdm8723->bCurDacSwingOn = bDacSwingOn;\r\npBtdm8723->curDacSwingLvl = dacSwingLvl;\r\nif ((pBtdm8723->bPreDacSwingOn == pBtdm8723->bCurDacSwingOn) &&\r\n(pBtdm8723->preDacSwingLvl == pBtdm8723->curDacSwingLvl))\r\nreturn;\r\nmdelay(30);\r\nbtdm_SetSwFullTimeDacSwing(padapter, bDacSwingOn, dacSwingLvl);\r\npBtdm8723->bPreDacSwingOn = pBtdm8723->bCurDacSwingOn;\r\npBtdm8723->preDacSwingLvl = pBtdm8723->curDacSwingLvl;\r\n}\r\nstatic void btdm_2AntAdcBackOff(struct rtw_adapter *padapter, u8 bAdcBackOff)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn AdcBackOff = %s\n",\r\n((bAdcBackOff) ? "ON" : "OFF")));\r\npBtdm8723->bCurAdcBackOff = bAdcBackOff;\r\nif (pBtdm8723->bPreAdcBackOff == pBtdm8723->bCurAdcBackOff)\r\nreturn;\r\nBTDM_BBBackOffLevel(padapter, (u8)pBtdm8723->bCurAdcBackOff);\r\npBtdm8723->bPreAdcBackOff = pBtdm8723->bCurAdcBackOff;\r\n}\r\nstatic void btdm_2AntAgcTable(struct rtw_adapter *padapter, u8 bAgcTableEn)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], %s Agc Table\n", ((bAgcTableEn) ? "Enable" : "Disable")));\r\npBtdm8723->bCurAgcTableEn = bAgcTableEn;\r\nif (pBtdm8723->bPreAgcTableEn == pBtdm8723->bCurAgcTableEn)\r\nreturn;\r\nBTDM_AGCTable(padapter, (u8)bAgcTableEn);\r\npBtdm8723->bPreAgcTableEn = pBtdm8723->bCurAgcTableEn;\r\n}\r\nstatic void\r\nbtdm_2AntCoexTable(struct rtw_adapter *padapter,\r\nu32 val0x6c0, u32 val0x6c8, u8 val0x6cc)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], write Coex Table 0x6c0 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",\r\nval0x6c0, val0x6c8, val0x6cc));\r\npBtdm8723->curVal0x6c0 = val0x6c0;\r\npBtdm8723->curVal0x6c8 = val0x6c8;\r\npBtdm8723->curVal0x6cc = val0x6cc;\r\nif ((pBtdm8723->preVal0x6c0 == pBtdm8723->curVal0x6c0) &&\r\n(pBtdm8723->preVal0x6c8 == pBtdm8723->curVal0x6c8) &&\r\n(pBtdm8723->preVal0x6cc == pBtdm8723->curVal0x6cc))\r\nreturn;\r\nbtdm_SetCoexTable(padapter, val0x6c0, val0x6c8, val0x6cc);\r\npBtdm8723->preVal0x6c0 = pBtdm8723->curVal0x6c0;\r\npBtdm8723->preVal0x6c8 = pBtdm8723->curVal0x6c8;\r\npBtdm8723->preVal0x6cc = pBtdm8723->curVal0x6cc;\r\n}\r\nstatic void btdm_2AntIgnoreWlanAct(struct rtw_adapter *padapter, u8 bEnable)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn Ignore WlanAct %s\n", (bEnable ? "ON" : "OFF")));\r\npBtdm8723->bCurIgnoreWlanAct = bEnable;\r\nif (pBtdm8723->bPreIgnoreWlanAct == pBtdm8723->bCurIgnoreWlanAct)\r\nreturn;\r\nbtdm_SetFwIgnoreWlanAct(padapter, bEnable);\r\npBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;\r\n}\r\nstatic void\r\nbtdm_2AntSetFw3a(struct rtw_adapter *padapter, u8 byte1, u8 byte2,\r\nu8 byte3, u8 byte4, u8 byte5)\r\n{\r\nu8 H2C_Parameter[5] = {0};\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (byte1)\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\nH2C_Parameter[0] = byte1;\r\nH2C_Parameter[1] = byte2;\r\nH2C_Parameter[2] = byte3;\r\nH2C_Parameter[3] = byte4;\r\nH2C_Parameter[4] = byte5;\r\npHalData->bt_coexist.fw3aVal[0] = byte1;\r\npHalData->bt_coexist.fw3aVal[1] = byte2;\r\npHalData->bt_coexist.fw3aVal[2] = byte3;\r\npHalData->bt_coexist.fw3aVal[3] = byte4;\r\npHalData->bt_coexist.fw3aVal[4] = byte5;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], FW write 0x3a(5bytes) = 0x%x%08x\n",\r\nH2C_Parameter[0],\r\nH2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));\r\nFillH2CCmd(padapter, 0x3a, 5, H2C_Parameter);\r\n}\r\nstatic void btdm_2AntPsTdma(struct rtw_adapter *padapter, u8 bTurnOn, u8 type)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nu32 btTxRxCnt = 0;\r\nu8 bTurnOnByCnt = false;\r\nu8 psTdmaTypeByCnt = 0;\r\nbtTxRxCnt = BTDM_BtTxRxCounterH(padapter)+BTDM_BtTxRxCounterL(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT TxRx Counters = %d\n", btTxRxCnt));\r\nif (btTxRxCnt > 3000) {\r\nbTurnOnByCnt = true;\r\npsTdmaTypeByCnt = 8;\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], For BTTxRxCounters, turn %s PS TDMA, type =%d\n",\r\n(bTurnOnByCnt ? "ON" : "OFF"), psTdmaTypeByCnt));\r\npBtdm8723->bCurPsTdmaOn = bTurnOnByCnt;\r\npBtdm8723->curPsTdma = psTdmaTypeByCnt;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], turn %s PS TDMA, type =%d\n",\r\n(bTurnOn ? "ON" : "OFF"), type));\r\npBtdm8723->bCurPsTdmaOn = bTurnOn;\r\npBtdm8723->curPsTdma = type;\r\n}\r\nif ((pBtdm8723->bPrePsTdmaOn == pBtdm8723->bCurPsTdmaOn) &&\r\n(pBtdm8723->prePsTdma == pBtdm8723->curPsTdma))\r\nreturn;\r\nif (bTurnOn) {\r\nswitch (type) {\r\ncase 1:\r\ndefault:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x1a, 0x1a, 0xa1, 0x98);\r\nbreak;\r\ncase 2:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x12, 0x12, 0xa1, 0x98);\r\nbreak;\r\ncase 3:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0xa, 0xa, 0xa1, 0x98);\r\nbreak;\r\ncase 4:\r\nbtdm_2AntSetFw3a(padapter, 0xa3, 0x5, 0x5, 0xa1, 0x80);\r\nbreak;\r\ncase 5:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x1a, 0x1a, 0x20, 0x98);\r\nbreak;\r\ncase 6:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x12, 0x12, 0x20, 0x98);\r\nbreak;\r\ncase 7:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0xa, 0xa, 0x20, 0x98);\r\nbreak;\r\ncase 8:\r\nbtdm_2AntSetFw3a(padapter, 0xa3, 0x5, 0x5, 0x20, 0x80);\r\nbreak;\r\ncase 9:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x1a, 0x1a, 0xa1, 0x98);\r\nbreak;\r\ncase 10:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x12, 0x12, 0xa1, 0x98);\r\nbreak;\r\ncase 11:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0xa, 0xa, 0xa1, 0x98);\r\nbreak;\r\ncase 12:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x5, 0x5, 0xa1, 0x98);\r\nbreak;\r\ncase 13:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x1a, 0x1a, 0x20, 0x98);\r\nbreak;\r\ncase 14:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x12, 0x12, 0x20, 0x98);\r\nbreak;\r\ncase 15:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0xa, 0xa, 0x20, 0x98);\r\nbreak;\r\ncase 16:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x5, 0x5, 0x20, 0x98);\r\nbreak;\r\ncase 17:\r\nbtdm_2AntSetFw3a(padapter, 0xa3, 0x2f, 0x2f, 0x20, 0x80);\r\nbreak;\r\ncase 18:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x5, 0x5, 0xa1, 0x98);\r\nbreak;\r\ncase 19:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x25, 0x25, 0xa1, 0x98);\r\nbreak;\r\ncase 20:\r\nbtdm_2AntSetFw3a(padapter, 0xe3, 0x25, 0x25, 0x20, 0x98);\r\nbreak;\r\n}\r\n} else {\r\nswitch (type) {\r\ncase 0:\r\nbtdm_2AntSetFw3a(padapter, 0x0, 0x0, 0x0, 0x8, 0x0);\r\nbreak;\r\ncase 1:\r\nbtdm_2AntSetFw3a(padapter, 0x0, 0x0, 0x0, 0x0, 0x0);\r\nbreak;\r\ndefault:\r\nbtdm_2AntSetFw3a(padapter, 0x0, 0x0, 0x0, 0x8, 0x0);\r\nbreak;\r\n}\r\n}\r\npBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;\r\npBtdm8723->prePsTdma = pBtdm8723->curPsTdma;\r\n}\r\nstatic void btdm_2AntBtInquiryPage(struct rtw_adapter *padapter)\r\n{\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\n}\r\nstatic u8 btdm_HoldForBtInqPage(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu32 curTime = jiffies;\r\nif (pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage) {\r\nif (pHalData->bt_coexist.halCoex8723.btInqPageStartTime == 0) {\r\npHalData->bt_coexist.halCoex8723.btInqPageStartTime = curTime;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT Inquiry/page is started at time : 0x%lx \n",\r\npHalData->bt_coexist.halCoex8723.btInqPageStartTime));\r\n}\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT Inquiry/page started time : 0x%lx, curTime : 0x%x \n",\r\npHalData->bt_coexist.halCoex8723.btInqPageStartTime, curTime));\r\nif (pHalData->bt_coexist.halCoex8723.btInqPageStartTime) {\r\nif (((curTime - pHalData->bt_coexist.halCoex8723.btInqPageStartTime)/1000000) >= 10) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], BT Inquiry/page >= 10sec!!!"));\r\npHalData->bt_coexist.halCoex8723.btInqPageStartTime = 0;\r\n}\r\n}\r\nif (pHalData->bt_coexist.halCoex8723.btInqPageStartTime) {\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic u8 btdm_Is2Ant8723ACommonAction(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nu8 bCommon = false;\r\nRTPRINT(FBT, BT_TRACE, ("%s :BTDM_IsWifiConnectionExist =%x check_fwstate =%x pmlmepriv->fw_state = 0x%x\n", __func__, BTDM_IsWifiConnectionExist(padapter), check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING)), padapter->mlmepriv.fw_state));\r\nif ((!BTDM_IsWifiConnectionExist(padapter)) &&\r\n(!check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) &&\r\n(BT_2ANT_BT_STATUS_IDLE == pBtdm8723->btStatus)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi idle + Bt idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, false);\r\nbtdm_2AntRfShrink(padapter, false);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\nbCommon = true;\r\n} else if (((BTDM_IsWifiConnectionExist(padapter)) ||\r\n(check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING)))) &&\r\n(BT_2ANT_BT_STATUS_IDLE == pBtdm8723->btStatus)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi non-idle + BT idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, true);\r\nbtdm_2AntRfShrink(padapter, false);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\nbCommon = true;\r\n} else if ((!BTDM_IsWifiConnectionExist(padapter)) &&\r\n(!check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) &&\r\n(BT_2ANT_BT_STATUS_CONNECTED_IDLE == pBtdm8723->btStatus)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi idle + Bt connected idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, true);\r\nbtdm_2AntRfShrink(padapter, true);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\nbCommon = true;\r\n} else if (((BTDM_IsWifiConnectionExist(padapter)) ||\r\n(check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING)))) &&\r\n(BT_2ANT_BT_STATUS_CONNECTED_IDLE == pBtdm8723->btStatus)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi non-idle + Bt connected idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, true);\r\nbtdm_2AntRfShrink(padapter, true);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\nbCommon = true;\r\n} else if ((!BTDM_IsWifiConnectionExist(padapter)) &&\r\n(!check_fwstate(&padapter->mlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) &&\r\n(BT_2ANT_BT_STATUS_NON_IDLE == pBtdm8723->btStatus)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi idle + BT non-idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, true);\r\nbtdm_2AntRfShrink(padapter, true);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\nbCommon = true;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi non-idle + BT non-idle!!\n"));\r\nbtdm_2AntLowPenaltyRa(padapter, true);\r\nbtdm_2AntRfShrink(padapter, true);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbCommon = false;\r\n}\r\nreturn bCommon;\r\n}\r\nstatic void\r\nbtdm_2AntTdmaDurationAdjust(struct rtw_adapter *padapter, u8 bScoHid,\r\nu8 bTxPause, u8 maxInterval)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nstatic s32 up, dn, m, n, WaitCount;\r\ns32 result;\r\nu8 retryCount = 0;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TdmaDurationAdjust()\n"));\r\nif (pBtdm8723->bResetTdmaAdjust) {\r\npBtdm8723->bResetTdmaAdjust = false;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], first run TdmaDurationAdjust()!!\n"));\r\nif (bScoHid) {\r\nif (bTxPause) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n}\r\n} else {\r\nif (bTxPause) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n}\r\n}\r\nup = 0;\r\ndn = 0;\r\nm = 1;\r\nn = 3;\r\nresult = 0;\r\nWaitCount = 0;\r\n} else {\r\nretryCount = pHalData->bt_coexist.halCoex8723.btRetryCnt;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], retryCount = %d\n", retryCount));\r\nresult = 0;\r\nWaitCount++;\r\nif (retryCount == 0) {\r\nup++;\r\ndn--;\r\nif (dn <= 0)\r\ndn = 0;\r\nif (up >= n) {\r\nWaitCount = 0;\r\nn = 3;\r\nup = 0;\r\ndn = 0;\r\nresult = 1;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Increase wifi duration!!\n"));\r\n}\r\n} else if (retryCount <= 3) {\r\nup--;\r\ndn++;\r\nif (up <= 0)\r\nup = 0;\r\nif (dn == 2) {\r\nif (WaitCount <= 2)\r\nm++;\r\nelse\r\nm = 1;\r\nif (m >= 20)\r\nm = 20;\r\nn = 3*m;\r\nup = 0;\r\ndn = 0;\r\nWaitCount = 0;\r\nresult = -1;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter<3!!\n"));\r\n}\r\n} else {\r\nif (WaitCount == 1)\r\nm++;\r\nelse\r\nm = 1;\r\nif (m >= 20)\r\nm = 20;\r\nn = 3*m;\r\nup = 0;\r\ndn = 0;\r\nWaitCount = 0;\r\nresult = -1;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter>3!!\n"));\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], max Interval = %d\n", maxInterval));\r\nif (maxInterval == 1) {\r\nif (bTxPause) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 1\n"));\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 5);\r\npBtdm8723->psTdmaDuAdjType = 5;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n}\r\nif (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 13);\r\npBtdm8723->psTdmaDuAdjType = 13;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n} else if (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 5);\r\npBtdm8723->psTdmaDuAdjType = 5;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 13);\r\npBtdm8723->psTdmaDuAdjType = 13;\r\n}\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 0\n"));\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 1);\r\npBtdm8723->psTdmaDuAdjType = 1;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n}\r\nif (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 9);\r\npBtdm8723->psTdmaDuAdjType = 9;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n} else if (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 1);\r\npBtdm8723->psTdmaDuAdjType = 1;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 9);\r\npBtdm8723->psTdmaDuAdjType = 9;\r\n}\r\n}\r\n}\r\n} else if (maxInterval == 2) {\r\nif (bTxPause) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 1\n"));\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n}\r\nif (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n} else if (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\npBtdm8723->psTdmaDuAdjType = 6;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\npBtdm8723->psTdmaDuAdjType = 14;\r\n}\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 0\n"));\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n}\r\nif (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n} else if (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\npBtdm8723->psTdmaDuAdjType = 2;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\npBtdm8723->psTdmaDuAdjType = 10;\r\n}\r\n}\r\n}\r\n} else if (maxInterval == 3) {\r\nif (bTxPause) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 1\n"));\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n}\r\nif (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\npBtdm8723->psTdmaDuAdjType = 8;\r\n} else if (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\npBtdm8723->psTdmaDuAdjType = 16;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 7);\r\npBtdm8723->psTdmaDuAdjType = 7;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\npBtdm8723->psTdmaDuAdjType = 15;\r\n}\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], TxPause = 0\n"));\r\nif (pBtdm8723->curPsTdma == 5) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 6) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 7) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 8) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n}\r\nif (pBtdm8723->curPsTdma == 13) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 14) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 15) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 16) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\nif (result == -1) {\r\nif (pBtdm8723->curPsTdma == 1) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\npBtdm8723->psTdmaDuAdjType = 4;\r\n} else if (pBtdm8723->curPsTdma == 9) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\npBtdm8723->psTdmaDuAdjType = 12;\r\n}\r\n} else if (result == 1) {\r\nif (pBtdm8723->curPsTdma == 4) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 3) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 2) {\r\nbtdm_2AntPsTdma(padapter, true, 3);\r\npBtdm8723->psTdmaDuAdjType = 3;\r\n} else if (pBtdm8723->curPsTdma == 12) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 11) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n} else if (pBtdm8723->curPsTdma == 10) {\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\npBtdm8723->psTdmaDuAdjType = 11;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PsTdma type : recordPsTdma =%d\n", pBtdm8723->psTdmaDuAdjType));\r\nif (pBtdm8723->curPsTdma != pBtdm8723->psTdmaDuAdjType) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PsTdma type dismatch!!!, curPsTdma =%d, recordPsTdma =%d\n",\r\npBtdm8723->curPsTdma, pBtdm8723->psTdmaDuAdjType));\r\nif (!check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING))\r\nbtdm_2AntPsTdma(padapter, true, pBtdm8723->psTdmaDuAdjType);\r\nelse\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n"));\r\n}\r\n}\r\nstatic void btdm_2Ant8723ASCOAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 11);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 15);\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723AHIDAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 9);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 13);\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 9);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 13);\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723AA2DPAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 1);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 1);\r\n}\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 1);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 1);\r\n}\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723APANEDRAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723APANHSAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState;\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntDecBtPwr(padapter, true);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntDecBtPwr(padapter, false);\r\n}\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high\n"));\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low\n"));\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723APANEDRA2DPAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1, btInfoExt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nbtInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\n}\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 4);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 2);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 8);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 6);\r\n}\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723APANEDRHIDAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723AHIDA2DPPANEDRAction(struct rtw_adapter *padapter)\r\n{\r\nu8 btRssiState, btRssiState1, btInfoExt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nbtInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\n}\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 37, 0);\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 12);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 10);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 16);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntPsTdma(padapter, true, 14);\r\n}\r\n}\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723AHIDA2DPAction(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 btRssiState, btRssiState1, btInfoExt;\r\nbtInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, false, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, false, 1);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, true, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, true, 1);\r\n}\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, false, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, false, 1);\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nif (btInfoExt&BIT(0)) {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp basic rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, true, 3);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("a2dp edr rate \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, true, true, 1);\r\n}\r\n}\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void btdm_2Ant8723AA2dp(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 btRssiState, btRssiState1, btInfoExt;\r\nbtInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nif (btdm_NeedToDecBtPwr(padapter))\r\nbtdm_2AntDecBtPwr(padapter, true);\r\nelse\r\nbtdm_2AntDecBtPwr(padapter, false);\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nif (BTDM_IsHT40(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("HT40\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 1);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 1);\r\n}\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("HT20 or Legacy\n"));\r\nbtRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);\r\nbtRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);\r\nif ((btRssiState1 == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState1 == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 high \n"));\r\nPlatformEFIOWrite1Byte(padapter, 0x883, 0x40);\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, false, 1);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi-1 low \n"));\r\nbtdm_2AntTdmaDurationAdjust(padapter, false, true, 1);\r\n}\r\nif ((btRssiState == BT_RSSI_STATE_HIGH) ||\r\n(btRssiState == BT_RSSI_STATE_STAY_HIGH)) {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi high \n"));\r\nbtdm_2AntAgcTable(padapter, true);\r\nbtdm_2AntAdcBackOff(padapter, true);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("Wifi rssi low \n"));\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\n}\r\n}\r\nstatic void BTDM_2AntParaInit(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 2Ant Parameter Init!!\n"));\r\nrtl8723au_write8(padapter, 0x76e, 0x4);\r\nrtl8723au_write8(padapter, 0x778, 0x3);\r\nrtl8723au_write8(padapter, 0x40, 0x20);\r\npBtdm8723->preVal0x6c0 = 0x0;\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\npBtdm8723->bPrePsTdmaOn = true;\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\npBtdm8723->preFwDacSwingLvl = 0x10;\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\npBtdm8723->bPreDecBtPwr = true;\r\nbtdm_2AntDecBtPwr(padapter, false);\r\npBtdm8723->bPreAgcTableEn = true;\r\nbtdm_2AntAgcTable(padapter, false);\r\npBtdm8723->bPreAdcBackOff = true;\r\nbtdm_2AntAdcBackOff(padapter, false);\r\npBtdm8723->bPreLowPenaltyRa = true;\r\nbtdm_2AntLowPenaltyRa(padapter, false);\r\npBtdm8723->bPreRfRxLpfShrink = true;\r\nbtdm_2AntRfShrink(padapter, false);\r\npBtdm8723->bPreDacSwingOn = true;\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\npBtdm8723->bPreIgnoreWlanAct = true;\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\n}\r\nstatic void BTDM_2AntHwCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nbtdm_2AntCoexTable(padapter, 0x55555555, 0xffff, 0x3);\r\n}\r\nstatic void BTDM_2AntFwCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nbtdm_2AntIgnoreWlanAct(padapter, false);\r\nbtdm_2AntPsTdma(padapter, false, 0);\r\nbtdm_2AntFwDacSwingLvl(padapter, 0x20);\r\nbtdm_2AntDecBtPwr(padapter, false);\r\n}\r\nstatic void BTDM_2AntSwCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nbtdm_2AntAgcTable(padapter, false);\r\nbtdm_2AntAdcBackOff(padapter, false);\r\nbtdm_2AntLowPenaltyRa(padapter, false);\r\nbtdm_2AntRfShrink(padapter, false);\r\nbtdm_2AntDacSwing(padapter, false, 0xc0);\r\n}\r\nstatic void BTDM_2AntFwC2hBtInfo8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nu8 btInfo = 0;\r\nu8 algorithm = BT_2ANT_COEX_ALGO_UNDEFINED;\r\nu8 bBtLinkExist = false, bBtHsModeExist = false;\r\nbtInfo = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_IDLE;\r\nif (btInfo & BIT(2)) {\r\nif (!pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage) {\r\npBtMgnt->ExtConfig.bHoldForBtOperation = true;\r\npBtMgnt->ExtConfig.bHoldPeriodCnt = 1;\r\nbtdm_2AntBtInquiryPage(padapter);\r\n} else {\r\npBtMgnt->ExtConfig.bHoldPeriodCnt++;\r\nbtdm_HoldForBtInqPage(padapter);\r\n}\r\npHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = true;\r\n} else {\r\npHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = false;\r\npBtMgnt->ExtConfig.bHoldForBtOperation = false;\r\npBtMgnt->ExtConfig.bHoldPeriodCnt = 0;\r\n}\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTC2H], pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage =%x pBtMgnt->ExtConfig.bHoldPeriodCnt =%x pBtMgnt->ExtConfig.bHoldForBtOperation =%x\n",\r\npHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage,\r\npBtMgnt->ExtConfig.bHoldPeriodCnt,\r\npBtMgnt->ExtConfig.bHoldForBtOperation));\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTC2H], btInfo =%x pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal =%x\n",\r\nbtInfo, pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal));\r\nif (btInfo&BT_INFO_ACL) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], BTInfo: bConnect = true btInfo =%x\n", btInfo));\r\nbBtLinkExist = true;\r\nif (((btInfo&(BT_INFO_FTP|BT_INFO_A2DP|BT_INFO_HID|BT_INFO_SCO_BUSY)) != 0) ||\r\npHalData->bt_coexist.halCoex8723.btRetryCnt > 0) {\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_NON_IDLE;\r\n} else {\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_CONNECTED_IDLE;\r\n}\r\nif (btInfo&BT_INFO_SCO || btInfo&BT_INFO_SCO_BUSY) {\r\nif (btInfo&BT_INFO_FTP || btInfo&BT_INFO_A2DP || btInfo&BT_INFO_HID) {\r\nswitch (btInfo&0xe0) {\r\ncase BT_INFO_HID:\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + HID\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID;\r\nbreak;\r\ncase BT_INFO_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Error!!! SCO + A2DP\n"));\r\nbreak;\r\ncase BT_INFO_FTP:\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_SCO;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\nbreak;\r\ncase (BT_INFO_HID | BT_INFO_A2DP):\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\nbreak;\r\ncase (BT_INFO_HID | BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\nbreak;\r\ncase (BT_INFO_A2DP | BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_A2DP;\r\n}\r\nbreak;\r\ncase (BT_INFO_HID | BT_INFO_A2DP | BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP_PANEDR;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], SCO only\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_SCO;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], non SCO\n"));\r\nswitch (btInfo&0xe0) {\r\ncase BT_INFO_HID:\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID;\r\nbreak;\r\ncase BT_INFO_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_A2DP;\r\nbreak;\r\ncase BT_INFO_FTP:\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\nbreak;\r\ncase (BT_INFO_HID | BT_INFO_A2DP):\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\nbreak;\r\ncase (BT_INFO_HID|BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_HID;\r\n}\r\nbreak;\r\ncase (BT_INFO_A2DP|BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_PANEDR_A2DP;\r\n}\r\nbreak;\r\ncase (BT_INFO_HID|BT_INFO_A2DP|BT_INFO_FTP):\r\nif (bBtHsModeExist) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(HS)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));\r\nalgorithm = BT_2ANT_COEX_ALGO_HID_A2DP_PANEDR;\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], BTInfo: bConnect = false\n"));\r\npBtdm8723->btStatus = BT_2ANT_BT_STATUS_IDLE;\r\n}\r\npBtdm8723->curAlgorithm = algorithm;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Algorithm = %d \n", pBtdm8723->curAlgorithm));\r\nBTDM_CheckWiFiState(padapter);\r\nif (pBtMgnt->ExtConfig.bManualControl) {\r\nRTPRINT(FBT, BT_TRACE, ("Action Manual control, won't execute bt coexist mechanism!!\n"));\r\nreturn;\r\n}\r\n}\r\nvoid BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct bt_dgb *pBtDbg = &pBTInfo->BtDbg;\r\nu8 btInfoOriginal = 0;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct btdm_8723a_2ant *pBtdm8723 = &pHalData->bt_coexist.halCoex8723.btdm2Ant;\r\nif (BTDM_BtProfileSupport(padapter)) {\r\nif (pBtMgnt->ExtConfig.bHoldForBtOperation) {\r\nRTPRINT(FBT, BT_TRACE, ("Action for BT Operation adjust!!\n"));\r\nreturn;\r\n}\r\nif (pBtMgnt->ExtConfig.bHoldPeriodCnt) {\r\nRTPRINT(FBT, BT_TRACE, ("Hold BT inquiry/page scan setting (cnt = %d)!!\n",\r\npBtMgnt->ExtConfig.bHoldPeriodCnt));\r\nif (pBtMgnt->ExtConfig.bHoldPeriodCnt >= 11) {\r\npBtMgnt->ExtConfig.bHoldPeriodCnt = 0;\r\n} else {\r\npBtMgnt->ExtConfig.bHoldPeriodCnt++;\r\n}\r\nreturn;\r\n}\r\nif (pBtDbg->dbgCtrl)\r\nRTPRINT(FBT, BT_TRACE, ("[Dbg control], "));\r\npBtdm8723->curAlgorithm = btdm_ActionAlgorithm(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Algorithm = %d \n", pBtdm8723->curAlgorithm));\r\nif (btdm_Is2Ant8723ACommonAction(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant common.\n"));\r\npBtdm8723->bResetTdmaAdjust = true;\r\n} else {\r\nif (pBtdm8723->curAlgorithm != pBtdm8723->preAlgorithm) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n",\r\npBtdm8723->preAlgorithm, pBtdm8723->curAlgorithm));\r\npBtdm8723->bResetTdmaAdjust = true;\r\n}\r\nswitch (pBtdm8723->curAlgorithm) {\r\ncase BT_2ANT_COEX_ALGO_SCO:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = SCO.\n"));\r\nbtdm_2Ant8723ASCOAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID.\n"));\r\nbtdm_2Ant8723AHIDAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = A2DP.\n"));\r\nbtdm_2Ant8723AA2DPAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN(EDR).\n"));\r\nbtdm_2Ant8723APANEDRAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANHS:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HS mode.\n"));\r\nbtdm_2Ant8723APANHSAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN+A2DP.\n"));\r\nbtdm_2Ant8723APANEDRA2DPAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR_HID:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN(EDR)+HID.\n"));\r\nbtdm_2Ant8723APANEDRHIDAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID_A2DP_PANEDR:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID+A2DP+PAN.\n"));\r\nbtdm_2Ant8723AHIDA2DPPANEDRAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID+A2DP.\n"));\r\nbtdm_2Ant8723AHIDA2DPAction(padapter);\r\nbreak;\r\ndefault:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = 0.\n"));\r\nbtdm_2Ant8723AA2DPAction(padapter);\r\nbreak;\r\n}\r\npBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;\r\n}\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex] Get bt info by fw!!\n"));\r\nif (pHalData->bt_coexist.halCoex8723.bC2hBtInfoReqSent)\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex] c2h for btInfo not rcvd yet!!\n"));\r\nbtInfoOriginal = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;\r\nif (pBtMgnt->ExtConfig.bHoldForBtOperation) {\r\nRTPRINT(FBT, BT_TRACE, ("Action for BT Operation adjust!!\n"));\r\nreturn;\r\n}\r\nif (pBtMgnt->ExtConfig.bHoldPeriodCnt) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("Hold BT inquiry/page scan setting (cnt = %d)!!\n",\r\npBtMgnt->ExtConfig.bHoldPeriodCnt));\r\nif (pBtMgnt->ExtConfig.bHoldPeriodCnt >= 11) {\r\npBtMgnt->ExtConfig.bHoldPeriodCnt = 0;\r\n} else {\r\npBtMgnt->ExtConfig.bHoldPeriodCnt++;\r\n}\r\nreturn;\r\n}\r\nif (pBtDbg->dbgCtrl)\r\nRTPRINT(FBT, BT_TRACE, ("[Dbg control], "));\r\nif (btdm_Is2Ant8723ACommonAction(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant common.\n"));\r\npBtdm8723->bResetTdmaAdjust = true;\r\n} else {\r\nif (pBtdm8723->curAlgorithm != pBtdm8723->preAlgorithm) {\r\nRTPRINT(FBT, BT_TRACE,\r\n("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n",\r\npBtdm8723->preAlgorithm,\r\npBtdm8723->curAlgorithm));\r\npBtdm8723->bResetTdmaAdjust = true;\r\n}\r\nswitch (pBtdm8723->curAlgorithm) {\r\ncase BT_2ANT_COEX_ALGO_SCO:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = SCO.\n"));\r\nbtdm_2Ant8723ASCOAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID.\n"));\r\nbtdm_2Ant8723AHIDAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = A2DP.\n"));\r\nbtdm_2Ant8723AA2dp(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN(EDR).\n"));\r\nbtdm_2Ant8723APANEDRAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANHS:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HS mode.\n"));\r\nbtdm_2Ant8723APANHSAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN+A2DP.\n"));\r\nbtdm_2Ant8723APANEDRA2DPAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_PANEDR_HID:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = PAN(EDR)+HID.\n"));\r\nbtdm_2Ant8723APANEDRHIDAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID_A2DP_PANEDR:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID+A2DP+PAN.\n"));\r\nbtdm_2Ant8723AHIDA2DPPANEDRAction(padapter);\r\nbreak;\r\ncase BT_2ANT_COEX_ALGO_HID_A2DP:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = HID+A2DP.\n"));\r\nbtdm_2Ant8723AHIDA2DPAction(padapter);\r\nbreak;\r\ndefault:\r\nRTPRINT(FBT, BT_TRACE, ("Action 2-Ant, algorithm = 0.\n"));\r\nbtdm_2Ant8723AA2DPAction(padapter);\r\nbreak;\r\n}\r\npBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;\r\n}\r\n}\r\n}\r\nstatic u8 btdm_BtWifiAntNum(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct bt_coexist_8723a *pBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nif (Ant_x2 == pHalData->bt_coexist.BT_Ant_Num) {\r\nif (Ant_x2 == pBtCoex->TotalAntNum)\r\nreturn Ant_x2;\r\nelse\r\nreturn Ant_x1;\r\n} else {\r\nreturn Ant_x1;\r\n}\r\nreturn Ant_x2;\r\n}\r\nstatic void btdm_BtHwCountersMonitor(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu32 regHPTxRx, regLPTxRx, u4Tmp;\r\nu32 regHPTx = 0, regHPRx = 0, regLPTx = 0, regLPRx = 0;\r\nregHPTxRx = REG_HIGH_PRIORITY_TXRX;\r\nregLPTxRx = REG_LOW_PRIORITY_TXRX;\r\nu4Tmp = rtl8723au_read32(padapter, regHPTxRx);\r\nregHPTx = u4Tmp & bMaskLWord;\r\nregHPRx = (u4Tmp & bMaskHWord)>>16;\r\nu4Tmp = rtl8723au_read32(padapter, regLPTxRx);\r\nregLPTx = u4Tmp & bMaskLWord;\r\nregLPRx = (u4Tmp & bMaskHWord)>>16;\r\npHalData->bt_coexist.halCoex8723.highPriorityTx = regHPTx;\r\npHalData->bt_coexist.halCoex8723.highPriorityRx = regHPRx;\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx = regLPTx;\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx = regLPRx;\r\nRTPRINT(FBT, BT_TRACE, ("High Priority Tx/Rx = %d / %d\n", regHPTx, regHPRx));\r\nRTPRINT(FBT, BT_TRACE, ("Low Priority Tx/Rx = %d / %d\n", regLPTx, regLPRx));\r\nrtl8723au_write8(padapter, 0x76e, 0xc);\r\n}\r\nstatic void btdm_BtEnableDisableCheck8723A(struct rtw_adapter *padapter)\r\n{\r\nu8 btAlife = true;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\n#ifdef CHECK_BT_EXIST_FROM_REG\r\nu8 val8;\r\nval8 = rtl8723au_read8(padapter, 0x6B);\r\nif (!(val8 & BIT(4)))\r\nbtAlife = false;\r\nif (btAlife)\r\npHalData->bt_coexist.bCurBtDisabled = false;\r\nelse\r\npHalData->bt_coexist.bCurBtDisabled = true;\r\n#else\r\nif (pHalData->bt_coexist.halCoex8723.highPriorityTx == 0 &&\r\npHalData->bt_coexist.halCoex8723.highPriorityRx == 0 &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx == 0 &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx == 0)\r\nbtAlife = false;\r\nif (pHalData->bt_coexist.halCoex8723.highPriorityTx == 0xeaea &&\r\npHalData->bt_coexist.halCoex8723.highPriorityRx == 0xeaea &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx == 0xeaea &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx == 0xeaea)\r\nbtAlife = false;\r\nif (pHalData->bt_coexist.halCoex8723.highPriorityTx == 0xffff &&\r\npHalData->bt_coexist.halCoex8723.highPriorityRx == 0xffff &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx == 0xffff &&\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx == 0xffff)\r\nbtAlife = false;\r\nif (btAlife) {\r\npHalData->bt_coexist.btActiveZeroCnt = 0;\r\npHalData->bt_coexist.bCurBtDisabled = false;\r\nRTPRINT(FBT, BT_TRACE, ("8723A BT is enabled !!\n"));\r\n} else {\r\npHalData->bt_coexist.btActiveZeroCnt++;\r\nRTPRINT(FBT, BT_TRACE, ("8723A bt all counters = 0, %d times!!\n",\r\npHalData->bt_coexist.btActiveZeroCnt));\r\nif (pHalData->bt_coexist.btActiveZeroCnt >= 2) {\r\npHalData->bt_coexist.bCurBtDisabled = true;\r\nRTPRINT(FBT, BT_TRACE, ("8723A BT is disabled !!\n"));\r\n}\r\n}\r\n#endif\r\nif (!pHalData->bt_coexist.bCurBtDisabled) {\r\nif (BTDM_IsWifiConnectionExist(padapter))\r\nBTDM_SetFwChnlInfo(padapter, RT_MEDIA_CONNECT);\r\nelse\r\nBTDM_SetFwChnlInfo(padapter, RT_MEDIA_DISCONNECT);\r\n}\r\nif (pHalData->bt_coexist.bPreBtDisabled !=\r\npHalData->bt_coexist.bCurBtDisabled) {\r\nRTPRINT(FBT, BT_TRACE, ("8723A BT is from %s to %s!!\n",\r\n(pHalData->bt_coexist.bPreBtDisabled ? "disabled":"enabled"),\r\n(pHalData->bt_coexist.bCurBtDisabled ? "disabled":"enabled")));\r\npHalData->bt_coexist.bPreBtDisabled = pHalData->bt_coexist.bCurBtDisabled;\r\n}\r\n}\r\nstatic void btdm_BTCoexist8723AHandler(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\npHalData = GET_HAL_DATA(padapter);\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x2) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 2 Ant mechanism\n"));\r\nBTDM_2AntBtCoexist8723A(padapter);\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], 1 Ant mechanism\n"));\r\nBTDM_1AntBtCoexist8723A(padapter);\r\n}\r\nif (!BTDM_IsSameCoexistState(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Coexist State[bitMap] change from 0x%"i64fmt"x to 0x%"i64fmt"x\n",\r\npHalData->bt_coexist.PreviousState,\r\npHalData->bt_coexist.CurrentState));\r\npHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;\r\nRTPRINT(FBT, BT_TRACE, ("["));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_BT30)\r\nRTPRINT(FBT, BT_TRACE, ("BT 3.0, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_HT20)\r\nRTPRINT(FBT, BT_TRACE, ("HT20, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_HT40)\r\nRTPRINT(FBT, BT_TRACE, ("HT40, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_LEGACY)\r\nRTPRINT(FBT, BT_TRACE, ("Legacy, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_RSSI_LOW)\r\nRTPRINT(FBT, BT_TRACE, ("Rssi_Low, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_RSSI_MEDIUM)\r\nRTPRINT(FBT, BT_TRACE, ("Rssi_Mid, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_RSSI_HIGH)\r\nRTPRINT(FBT, BT_TRACE, ("Rssi_High, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_IDLE)\r\nRTPRINT(FBT, BT_TRACE, ("Wifi_Idle, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_UPLINK)\r\nRTPRINT(FBT, BT_TRACE, ("Wifi_Uplink, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_WIFI_DOWNLINK)\r\nRTPRINT(FBT, BT_TRACE, ("Wifi_Downlink, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_BT_IDLE)\r\nRTPRINT(FBT, BT_TRACE, ("BT_idle, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_PROFILE_HID)\r\nRTPRINT(FBT, BT_TRACE, ("PRO_HID, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_PROFILE_A2DP)\r\nRTPRINT(FBT, BT_TRACE, ("PRO_A2DP, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_PROFILE_PAN)\r\nRTPRINT(FBT, BT_TRACE, ("PRO_PAN, "));\r\nif (pHalData->bt_coexist.CurrentState & BT_COEX_STATE_PROFILE_SCO)\r\nRTPRINT(FBT, BT_TRACE, ("PRO_SCO, "));\r\nRTPRINT(FBT, BT_TRACE, ("]\n"));\r\n}\r\n}\r\nu32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu32 counters = 0;\r\ncounters = pHalData->bt_coexist.halCoex8723.highPriorityTx+\r\npHalData->bt_coexist.halCoex8723.highPriorityRx;\r\nreturn counters;\r\n}\r\nu32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu32 counters = 0;\r\ncounters = pHalData->bt_coexist.halCoex8723.lowPriorityTx+\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx;\r\nreturn counters;\r\n}\r\nvoid BTDM_SetFwChnlInfo(struct rtw_adapter *padapter, enum rt_media_status mstatus)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 H2C_Parameter[3] = {0};\r\nu8 chnl;\r\nif (RT_MEDIA_CONNECT == mstatus)\r\nH2C_Parameter[0] = 0x1;\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE)) {\r\nchnl = pmlmeext->cur_channel;\r\nif (BTDM_IsHT40(padapter)) {\r\nif (pmlmeext->cur_ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\nchnl -= 2;\r\nelse if (pmlmeext->cur_ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\nchnl += 2;\r\n}\r\nH2C_Parameter[1] = chnl;\r\n} else {\r\nif (BT_Operation(padapter))\r\nH2C_Parameter[1] = pBtMgnt->BTChannel;\r\nelse\r\nH2C_Parameter[1] = pmlmeext->cur_channel;\r\n}\r\nif (BTDM_IsHT40(padapter))\r\nH2C_Parameter[2] = 0x30;\r\nelse\r\nH2C_Parameter[2] = 0x20;\r\nFillH2CCmd(padapter, 0x19, 3, H2C_Parameter);\r\n}\r\nu8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter)\r\n{\r\nu8 bRet = false;\r\nif (BTHCI_HsConnectionEstablished(padapter))\r\nbRet = true;\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE) == true)\r\nbRet = true;\r\nreturn bRet;\r\n}\r\nvoid BTDM_SetFw3a(\r\nstruct rtw_adapter *padapter,\r\nu8 byte1,\r\nu8 byte2,\r\nu8 byte3,\r\nu8 byte4,\r\nu8 byte5\r\n)\r\n{\r\nu8 H2C_Parameter[5] = {0};\r\nif (rtl8723a_BT_using_antenna_1(padapter)) {\r\nif ((!check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE)) &&\r\n(get_fwstate(&padapter->mlmepriv) != WIFI_NULL_STATE)) {\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct bt_coexist_8723a *pBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nu8 BtState = pBtCoex->c2hBtInfo;\r\nif ((BtState != BT_INFO_STATE_NO_CONNECTION) &&\r\n(BtState != BT_INFO_STATE_CONNECT_IDLE)) {\r\nif (byte1 & BIT(4)) {\r\nbyte1 &= ~BIT(4);\r\nbyte1 |= BIT(5);\r\n}\r\nbyte5 |= BIT(5);\r\nif (byte5 & BIT(6))\r\nbyte5 &= ~BIT(6);\r\n}\r\n}\r\n}\r\nH2C_Parameter[0] = byte1;\r\nH2C_Parameter[1] = byte2;\r\nH2C_Parameter[2] = byte3;\r\nH2C_Parameter[3] = byte4;\r\nH2C_Parameter[4] = byte5;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], FW write 0x3a(5bytes) = 0x%02x%08x\n",\r\nH2C_Parameter[0],\r\nH2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));\r\nFillH2CCmd(padapter, 0x3a, 5, H2C_Parameter);\r\n}\r\nvoid BTDM_QueryBtInformation(struct rtw_adapter *padapter)\r\n{\r\nu8 H2C_Parameter[1] = {0};\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_coexist_8723a *pBtCoex;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nif (!rtl8723a_BT_enabled(padapter)) {\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_DISABLED;\r\npBtCoex->bC2hBtInfoReqSent = false;\r\nreturn;\r\n}\r\nif (pBtCoex->c2hBtInfo == BT_INFO_STATE_DISABLED)\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_NO_CONNECTION;\r\nif (pBtCoex->bC2hBtInfoReqSent == true)\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], didn't recv previous BtInfo report!\n"));\r\nelse\r\npBtCoex->bC2hBtInfoReqSent = true;\r\nH2C_Parameter[0] |= BIT(0);\r\nFillH2CCmd(padapter, 0x38, 1, H2C_Parameter);\r\n}\r\nvoid BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter, u8 type)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (BT_RF_RX_LPF_CORNER_SHRINK == type) {\r\nRTPRINT(FBT, BT_TRACE, ("Shrink RF Rx LPF corner!!\n"));\r\nPHY_SetRFReg(padapter, PathA, 0x1e, bRFRegOffsetMask, 0xf0ff7);\r\npHalData->bt_coexist.bSWCoexistAllOff = false;\r\n} else if (BT_RF_RX_LPF_CORNER_RESUME == type) {\r\nRTPRINT(FBT, BT_TRACE, ("Resume RF Rx LPF corner!!\n"));\r\nPHY_SetRFReg(padapter, PathA, 0x1e, bRFRegOffsetMask, pHalData->bt_coexist.BtRfRegOrigin1E);\r\n}\r\n}\r\nvoid\r\nBTDM_SetSwPenaltyTxRateAdaptive(\r\nstruct rtw_adapter *padapter,\r\nu8 raType\r\n)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 tmpU1;\r\ntmpU1 = rtl8723au_read8(padapter, 0x4fd);\r\ntmpU1 |= BIT(0);\r\nif (BT_TX_RATE_ADAPTIVE_LOW_PENALTY == raType) {\r\ntmpU1 &= ~BIT(2);\r\npHalData->bt_coexist.bSWCoexistAllOff = false;\r\n} else if (BT_TX_RATE_ADAPTIVE_NORMAL == raType) {\r\ntmpU1 |= BIT(2);\r\n}\r\nrtl8723au_write8(padapter, 0x4fd, tmpU1);\r\n}\r\nvoid BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter, u8 bDecBtPwr)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[1] = {0};\r\nH2C_Parameter[0] = 0;\r\nif (bDecBtPwr) {\r\nH2C_Parameter[0] |= BIT(1);\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], decrease Bt Power : %s, write 0x21 = 0x%x\n",\r\n(bDecBtPwr ? "Yes!!" : "No!!"), H2C_Parameter[0]));\r\nFillH2CCmd(padapter, 0x21, 1, H2C_Parameter);\r\n}\r\nu8 BTDM_BtProfileSupport(struct rtw_adapter *padapter)\r\n{\r\nu8 bRet = false;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pBtMgnt->bSupportProfile &&\r\n!pHalData->bt_coexist.halCoex8723.bForceFwBtInfo)\r\nbRet = true;\r\nreturn bRet;\r\n}\r\nstatic void BTDM_AdjustForBtOperation8723A(struct rtw_adapter *padapter)\r\n{\r\n}\r\nstatic void BTDM_FwC2hBtRssi8723A(struct rtw_adapter *padapter, u8 *tmpBuf)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 percent = 0, u1tmp = 0;\r\nu1tmp = tmpBuf[0];\r\npercent = u1tmp*2+10;\r\npHalData->bt_coexist.halCoex8723.btRssi = percent;\r\n}\r\nvoid\r\nrtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter, u8 *tmpBuf, u8 length)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_coexist_8723a *pBtCoex;\r\nu8 i;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\npBtCoex->bC2hBtInfoReqSent = false;\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], BT info[%d]=[", length));\r\npBtCoex->btRetryCnt = 0;\r\nfor (i = 0; i < length; i++) {\r\nswitch (i) {\r\ncase 0:\r\npBtCoex->c2hBtInfoOriginal = tmpBuf[i];\r\nbreak;\r\ncase 1:\r\npBtCoex->btRetryCnt = tmpBuf[i];\r\nbreak;\r\ncase 2:\r\nBTDM_FwC2hBtRssi8723A(padapter, &tmpBuf[i]);\r\nbreak;\r\ncase 3:\r\npBtCoex->btInfoExt = tmpBuf[i]&BIT(0);\r\nbreak;\r\n}\r\nif (i == length-1)\r\nRTPRINT(FBT, BT_TRACE, ("0x%02x]\n", tmpBuf[i]));\r\nelse\r\nRTPRINT(FBT, BT_TRACE, ("0x%02x, ", tmpBuf[i]));\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], BT RSSI =%d\n", pBtCoex->btRssi));\r\nif (pBtCoex->btInfoExt)\r\nRTPRINT(FBT, BT_TRACE, ("[BTC2H], pBtCoex->btInfoExt =%x\n", pBtCoex->btInfoExt));\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntFwC2hBtInfo8723A(padapter);\r\nelse\r\nBTDM_2AntFwC2hBtInfo8723A(padapter);\r\nif (pBtMgnt->ExtConfig.bManualControl) {\r\nRTPRINT(FBT, BT_TRACE, ("%s: Action Manual control!!\n", __func__));\r\nreturn;\r\n}\r\nbtdm_BTCoexist8723AHandler(padapter);\r\n}\r\nstatic void BTDM_Display8723ABtCoexInfo(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct bt_coexist_8723a *pBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nu8 u1Tmp, u1Tmp1, u1Tmp2, i, btInfoExt, psTdmaCase = 0;\r\nu32 u4Tmp[4];\r\nu8 antNum = Ant_x2;\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (!rtl8723a_BT_coexist(padapter)) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");\r\nDCMD_Printf(btCoexDbgBuf);\r\nreturn;\r\n}\r\nantNum = btdm_BtWifiAntNum(padapter);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/%d ", "Ant mechanism PG/Now run :", \\r\n((pHalData->bt_coexist.BT_Ant_Num == Ant_x2) ? 2 : 1), ((antNum == Ant_x2) ? 2 : 1));\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");\r\nDCMD_Printf(btCoexDbgBuf);\r\n} else {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \\r\n((pBtMgnt->bSupportProfile) ? "Yes" : "No"), pBtMgnt->ExtConfig.HCIExtensionVer);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\n %-35s = / %d", "Dot11 channel / BT channel", \\r\npBtMgnt->BTChannel);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\n %-35s = %d / %d / %d", "Wifi/BT/HS rssi", \\r\nBTDM_GetRxSS(padapter),\r\npHalData->bt_coexist.halCoex8723.btRssi,\r\npHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\n %-35s = %s / %s ", "WIfi status",\r\n((BTDM_Legacy(padapter)) ? "Legacy" : (((BTDM_IsHT40(padapter)) ? "HT40" : "HT20"))),\r\n((!BTDM_IsWifiBusy(padapter)) ? "idle" : ((BTDM_IsWifiUplink(padapter)) ? "uplink" : "downlink")));\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (pBtMgnt->bSupportProfile) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP",\r\n((BTHCI_CheckProfileExist(padapter, BT_PROFILE_SCO)) ? 1 : 0),\r\n((BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID)) ? 1 : 0),\r\n((BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) ? 1 : 0),\r\n((BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) ? 1 : 0));\r\nDCMD_Printf(btCoexDbgBuf);\r\nfor (i = 0; i < pBtMgnt->ExtConfig.NumberOfHandle; i++) {\r\nif (pBtMgnt->ExtConfig.HCIExtensionVer >= 1) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s", "Bt link type/spec/role",\r\nBtProfileString[pBtMgnt->ExtConfig.linkInfo[i].BTProfile],\r\nBtSpecString[pBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec],\r\nBtLinkRoleString[pBtMgnt->ExtConfig.linkInfo[i].linkRole]);\r\nDCMD_Printf(btCoexDbgBuf);\r\nbtInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "A2DP rate", \\r\n(btInfoExt & BIT(0)) ?\r\n"Basic rate" : "EDR rate");\r\nDCMD_Printf(btCoexDbgBuf);\r\n} else {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s", "Bt link type/spec", \\r\nBtProfileString[pBtMgnt->ExtConfig.linkInfo[i].BTProfile],\r\nBtSpecString[pBtMgnt->ExtConfig.linkInfo[i].BTCoreSpec]);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\n}\r\n}\r\n}\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw BT Coex mechanism]============");\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "AGC Table", \\r\npBtCoex->btdm2Ant.bCurAgcTableEn);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "ADC Backoff", \\r\npBtCoex->btdm2Ant.bCurAdcBackOff);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "Low penalty RA", \\r\npBtCoex->btdm2Ant.bCurLowPenaltyRa);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "RF Rx LPF Shrink", \\r\npBtCoex->btdm2Ant.bCurRfRxLpfShrink);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nu4Tmp[0] = PHY_QueryRFReg(padapter, PathA, 0x1e, 0xff0);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "RF-A, 0x1e[11:4]/original val", \\r\nu4Tmp[0], pHalData->bt_coexist.BtRfRegOrigin1E);\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw BT Coex mechanism]============");\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\npsTdmaCase = pHalData->bt_coexist.halCoex8723.btdm1Ant.curPsTdma;\r\nelse\r\npsTdmaCase = pHalData->bt_coexist.halCoex8723.btdm2Ant.curPsTdma;\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d", "PS TDMA(0x3a)", \\r\npHalData->bt_coexist.fw3aVal[0], pHalData->bt_coexist.fw3aVal[1],\r\npHalData->bt_coexist.fw3aVal[2], pHalData->bt_coexist.fw3aVal[3],\r\npHalData->bt_coexist.fw3aVal[4], psTdmaCase);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "Decrease Bt Power", \\r\npBtCoex->btdm2Ant.bCurDecBtPwr);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nu1Tmp = rtl8723au_read8(padapter, 0x778);\r\nu1Tmp1 = rtl8723au_read8(padapter, 0x783);\r\nu1Tmp2 = rtl8723au_read8(padapter, 0x796);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x778/ 0x783/ 0x796", \\r\nu1Tmp, u1Tmp1, u1Tmp2);\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x / 0x%x", "Sw DacSwing Ctrl/Val", \\r\npBtCoex->btdm2Ant.bCurDacSwingOn, pBtCoex->btdm2Ant.curDacSwingLvl);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0x880);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x880", \\r\nu4Tmp[0]);\r\nDCMD_Printf(btCoexDbgBuf);\r\nif (!pBtMgnt->ExtConfig.bManualControl) {\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw BT Coex mechanism]============");\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nu1Tmp = rtl8723au_read8(padapter, 0x40);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40", \\r\nu1Tmp);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0x550);\r\nu1Tmp = rtl8723au_read8(padapter, 0x522);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x", "0x550(bcn contrl)/0x522", \\r\nu4Tmp[0], u1Tmp);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0x484);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x484(rate adaptive)", \\r\nu4Tmp[0]);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0x50);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)", \\r\nu4Tmp[0]);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0xda0);\r\nu4Tmp[1] = rtl8723au_read32(padapter, 0xda4);\r\nu4Tmp[2] = rtl8723au_read32(padapter, 0xda8);\r\nu4Tmp[3] = rtl8723au_read32(padapter, 0xdac);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0xda0/0xda4/0xda8/0xdac(FA cnt)", \\r\nu4Tmp[0], u4Tmp[1], u4Tmp[2], u4Tmp[3]);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu4Tmp[0] = rtl8723au_read32(padapter, 0x6c0);\r\nu4Tmp[1] = rtl8723au_read32(padapter, 0x6c4);\r\nu4Tmp[2] = rtl8723au_read32(padapter, 0x6c8);\r\nu1Tmp = rtl8723au_read8(padapter, 0x6cc);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", \\r\nu4Tmp[0], u4Tmp[1], u4Tmp[2], u1Tmp);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "0x770(Hi pri Rx[31:16]/Tx[15:0])", \\r\npHalData->bt_coexist.halCoex8723.highPriorityRx,\r\npHalData->bt_coexist.halCoex8723.highPriorityTx);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "0x774(Lo pri Rx[31:16]/Tx[15:0])", \\r\npHalData->bt_coexist.halCoex8723.lowPriorityRx,\r\npHalData->bt_coexist.halCoex8723.lowPriorityTx);\r\nDCMD_Printf(btCoexDbgBuf);\r\nu1Tmp = rtl8723au_read8(padapter, 0x41b);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x41b (hang chk == 0xf)", \\r\nu1Tmp);\r\nDCMD_Printf(btCoexDbgBuf);\r\nrsprintf(btCoexDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "lastHMEBoxNum", \\r\npHalData->LastHMEBoxNum);\r\nDCMD_Printf(btCoexDbgBuf);\r\n}\r\nstatic void\r\nBTDM_8723ASignalCompensation(struct rtw_adapter *padapter,\r\nu8 *rssi_wifi, u8 *rssi_bt)\r\n{\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntSignalCompensation(padapter, rssi_wifi, rssi_bt);\r\n}\r\nstatic void BTDM_8723AInit(struct rtw_adapter *padapter)\r\n{\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x2)\r\nBTDM_2AntParaInit(padapter);\r\nelse\r\nBTDM_1AntParaInit(padapter);\r\n}\r\nstatic void BTDM_HWCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x2)\r\nBTDM_2AntHwCoexAllOff8723A(padapter);\r\n}\r\nstatic void BTDM_FWCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x2)\r\nBTDM_2AntFwCoexAllOff8723A(padapter);\r\n}\r\nstatic void BTDM_SWCoexAllOff8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x2)\r\nBTDM_2AntSwCoexAllOff8723A(padapter);\r\n}\r\nstatic void\r\nBTDM_Set8723ABtCoexCurrAntNum(struct rtw_adapter *padapter, u8 antNum)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct bt_coexist_8723a *pBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nif (antNum == 1)\r\npBtCoex->TotalAntNum = Ant_x1;\r\nelse if (antNum == 2)\r\npBtCoex->TotalAntNum = Ant_x2;\r\n}\r\nvoid rtl8723a_BT_lps_leave(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntLpsLeave(padapter);\r\n}\r\nstatic void BTDM_ForHalt8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntForHalt(padapter);\r\n}\r\nstatic void BTDM_WifiScanNotify8723A(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntWifiScanNotify(padapter, scanType);\r\n}\r\nstatic void\r\nBTDM_WifiAssociateNotify8723A(struct rtw_adapter *padapter, u8 action)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntWifiAssociateNotify(padapter, action);\r\n}\r\nstatic void\r\nBTDM_MediaStatusNotify8723A(struct rtw_adapter *padapter,\r\nenum rt_media_status mstatus)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], MediaStatusNotify, %s\n",\r\nmstatus?"connect":"disconnect"));\r\nBTDM_SetFwChnlInfo(padapter, mstatus);\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntMediaStatusNotify(padapter, mstatus);\r\n}\r\nstatic void BTDM_ForDhcp8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nBTDM_1AntForDhcp(padapter);\r\n}\r\nbool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter)\r\n{\r\nif (btdm_BtWifiAntNum(padapter) == Ant_x1)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void BTDM_BTCoexist8723A(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_coexist_8723a *pBtCoex;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtCoex = &pHalData->bt_coexist.halCoex8723;\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], beacon RSSI = 0x%x(%d)\n",\r\npHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB,\r\npHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB));\r\nbtdm_BtHwCountersMonitor(padapter);\r\nbtdm_BtEnableDisableCheck8723A(padapter);\r\nif (pBtMgnt->ExtConfig.bManualControl) {\r\nRTPRINT(FBT, BT_TRACE, ("%s: Action Manual control!!\n", __func__));\r\nreturn;\r\n}\r\nif (pBtCoex->bC2hBtInfoReqSent) {\r\nif (!rtl8723a_BT_enabled(padapter)) {\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_DISABLED;\r\n} else {\r\nif (pBtCoex->c2hBtInfo == BT_INFO_STATE_DISABLED)\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_NO_CONNECTION;\r\n}\r\nbtdm_BTCoexist8723AHandler(padapter);\r\n} else if (!rtl8723a_BT_enabled(padapter)) {\r\npBtCoex->c2hBtInfo = BT_INFO_STATE_DISABLED;\r\nbtdm_BTCoexist8723AHandler(padapter);\r\n}\r\nBTDM_QueryBtInformation(padapter);\r\n}\r\nstatic void BTDM_SetAntenna(struct rtw_adapter *padapter, u8 who)\r\n{\r\n}\r\nvoid\r\nBTDM_SingleAnt(\r\nstruct rtw_adapter *padapter,\r\nu8 bSingleAntOn,\r\nu8 bInterruptOn,\r\nu8 bMultiNAVOn\r\n)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[3] = {0};\r\nif (pHalData->bt_coexist.BT_Ant_Num != Ant_x1)\r\nreturn;\r\nH2C_Parameter[2] = 0;\r\nH2C_Parameter[1] = 0;\r\nH2C_Parameter[0] = 0;\r\nif (bInterruptOn) {\r\nH2C_Parameter[2] |= 0x02;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\npHalData->bt_coexist.bInterruptOn = bInterruptOn;\r\nif (bSingleAntOn) {\r\nH2C_Parameter[2] |= 0x10;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\npHalData->bt_coexist.bSingleAntOn = bSingleAntOn;\r\nif (bMultiNAVOn) {\r\nH2C_Parameter[2] |= 0x20;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\npHalData->bt_coexist.bMultiNAVOn = bMultiNAVOn;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], SingleAntenna =[%s:%s:%s], write 0xe = 0x%x\n",\r\nbSingleAntOn?"ON":"OFF", bInterruptOn?"ON":"OFF", bMultiNAVOn?"ON":"OFF",\r\nH2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));\r\n}\r\nvoid BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 stateChange = false;\r\nu32 BT_Polling, Ratio_Act, Ratio_STA;\r\nu32 BT_Active, BT_State;\r\nu32 regBTActive = 0, regBTState = 0, regBTPolling = 0;\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nif (pBtMgnt->ExtConfig.bManualControl)\r\nreturn;\r\nif (pHalData->bt_coexist.BT_CoexistType != BT_CSR_BC8)\r\nreturn;\r\nif (pHalData->bt_coexist.BT_Ant_Num != Ant_x1)\r\nreturn;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], FirmwareVersion = 0x%x(%d)\n",\r\npHalData->FirmwareVersion, pHalData->FirmwareVersion));\r\nregBTActive = REG_BT_ACTIVE;\r\nregBTState = REG_BT_STATE;\r\nif (pHalData->FirmwareVersion >= FW_VER_BT_REG1)\r\nregBTPolling = REG_BT_POLLING1;\r\nelse\r\nregBTPolling = REG_BT_POLLING;\r\nBT_Active = rtl8723au_read32(padapter, regBTActive);\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT_Active(0x%x) =%x\n", regBTActive, BT_Active));\r\nBT_Active = BT_Active & 0x00ffffff;\r\nBT_State = rtl8723au_read32(padapter, regBTState);\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT_State(0x%x) =%x\n", regBTState, BT_State));\r\nBT_State = BT_State & 0x00ffffff;\r\nBT_Polling = rtl8723au_read32(padapter, regBTPolling);\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT_Polling(0x%x) =%x\n", regBTPolling, BT_Polling));\r\nif (BT_Active == 0xffffffff && BT_State == 0xffffffff && BT_Polling == 0xffffffff)\r\nreturn;\r\nif (BT_Polling == 0)\r\nreturn;\r\nRatio_Act = BT_Active*1000/BT_Polling;\r\nRatio_STA = BT_State*1000/BT_Polling;\r\npHalData->bt_coexist.Ratio_Tx = Ratio_Act;\r\npHalData->bt_coexist.Ratio_PRI = Ratio_STA;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], Ratio_Act =%d\n", Ratio_Act));\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], Ratio_STA =%d\n", Ratio_STA));\r\nif (Ratio_STA < 60 && Ratio_Act < 500) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_PAN_IDLE;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_DOWNLINK;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_UPLINK;\r\n} else {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_IDLE;\r\nif (Ratio_STA) {\r\nif ((Ratio_Act/Ratio_STA) < 2) {\r\npHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = true;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_PAN_UPLINK;\r\npHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = false;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_DOWNLINK;\r\n} else {\r\npHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = false;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_UPLINK;\r\npHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = true;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_PAN_DOWNLINK;\r\n}\r\n} else {\r\npHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = false;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_PAN_UPLINK;\r\npHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = true;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_PAN_DOWNLINK;\r\n}\r\n}\r\nif (pBtMgnt->ExtConfig.NumberOfHandle == 0 &&\r\npBtMgnt->ExtConfig.NumberOfSCO == 0) {\r\npBtMgnt->ExtConfig.bBTBusy = false;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_IDLE;\r\n} else {\r\nif (Ratio_STA < 60) {\r\npBtMgnt->ExtConfig.bBTBusy = false;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_IDLE;\r\n} else {\r\npBtMgnt->ExtConfig.bBTBusy = true;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_IDLE;\r\n}\r\n}\r\nif (pBtMgnt->ExtConfig.NumberOfHandle == 0 &&\r\npBtMgnt->ExtConfig.NumberOfSCO == 0) {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_RSSI_LOW;\r\npBtMgnt->ExtConfig.MIN_BT_RSSI = 0;\r\nBTDM_SetAntenna(padapter, BTDM_ANT_BT_IDLE);\r\n} else {\r\nif (pBtMgnt->ExtConfig.MIN_BT_RSSI <= -5) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT_RSSI_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], core stack notify bt rssi Low\n"));\r\n} else {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT_RSSI_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], core stack notify bt rssi Normal\n"));\r\n}\r\n}\r\nif (pHalData->bt_coexist.bBTBusyTraffic != pBtMgnt->ExtConfig.bBTBusy) {\r\npHalData->bt_coexist.bBTBusyTraffic = pBtMgnt->ExtConfig.bBTBusy;\r\nstateChange = true;\r\n}\r\nif (stateChange) {\r\nif (!pBtMgnt->ExtConfig.bBTBusy)\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT is idle or disable\n"));\r\nelse\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT is non-idle\n"));\r\n}\r\nif (!pBtMgnt->ExtConfig.bBTBusy) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT is idle or disable\n"));\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING|WIFI_SITE_MONITOR) == true)\r\nBTDM_SetAntenna(padapter, BTDM_ANT_WIFI);\r\n}\r\n}\r\nvoid\r\nBTDM_DiminishWiFi(\r\nstruct rtw_adapter *padapter,\r\nu8 bDACOn,\r\nu8 bInterruptOn,\r\nu8 DACSwingLevel,\r\nu8 bNAVOn\r\n)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[3] = {0};\r\nif (pHalData->bt_coexist.BT_Ant_Num != Ant_x2)\r\nreturn;\r\nif ((pHalData->bt_coexist.CurrentState & BT_COEX_STATE_BT_RSSI_LOW) &&\r\n(DACSwingLevel == 0x20)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT]DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n"));\r\nDACSwingLevel = 0x18;\r\n}\r\nH2C_Parameter[2] = 0;\r\nH2C_Parameter[1] = DACSwingLevel;\r\nH2C_Parameter[0] = 0;\r\nif (bDACOn) {\r\nH2C_Parameter[2] |= 0x01;\r\nif (bInterruptOn)\r\nH2C_Parameter[2] |= 0x02;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\nif (bNAVOn) {\r\nH2C_Parameter[2] |= 0x08;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], bDACOn = %s, bInterruptOn = %s, write 0xe = 0x%x\n",\r\nbDACOn?"ON":"OFF", bInterruptOn?"ON":"OFF",\r\nH2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], bNAVOn = %s\n",\r\nbNAVOn?"ON":"OFF"));\r\n}\r\nstatic void btdm_ResetFWCoexState(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->bt_coexist.CurrentState = 0;\r\npHalData->bt_coexist.PreviousState = 0;\r\n}\r\nstatic void btdm_InitBtCoexistDM(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->bt_coexist.BtRfRegOrigin1E = PHY_QueryRFReg(padapter, PathA, RF_RCK1, bRFRegOffsetMask);\r\npHalData->bt_coexist.BtRfRegOrigin1F = PHY_QueryRFReg(padapter, PathA, RF_RCK2, 0xf0);\r\npHalData->bt_coexist.CurrentState = 0;\r\npHalData->bt_coexist.PreviousState = 0;\r\nBTDM_8723AInit(padapter);\r\npHalData->bt_coexist.bInitlized = true;\r\n}\r\nvoid BTDM_CheckAntSelMode(struct rtw_adapter *padapter)\r\n{\r\n}\r\nvoid BTDM_FwC2hBtRssi(struct rtw_adapter *padapter, u8 *tmpBuf)\r\n{\r\nBTDM_FwC2hBtRssi8723A(padapter, tmpBuf);\r\n}\r\nvoid BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter)\r\n{\r\nBTDM_Display8723ABtCoexInfo(padapter);\r\n}\r\nvoid BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter, u8 bReject)\r\n{\r\n}\r\nu8 BTDM_IsHT40(struct rtw_adapter *padapter)\r\n{\r\nu8 isht40 = true;\r\nenum ht_channel_width bw;\r\nbw = padapter->mlmeextpriv.cur_bwmode;\r\nif (bw == HT_CHANNEL_WIDTH_20)\r\nisht40 = false;\r\nelse if (bw == HT_CHANNEL_WIDTH_40)\r\nisht40 = true;\r\nreturn isht40;\r\n}\r\nu8 BTDM_Legacy(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext;\r\nu8 isLegacy = false;\r\npmlmeext = &padapter->mlmeextpriv;\r\nif ((pmlmeext->cur_wireless_mode == WIRELESS_11B) ||\r\n(pmlmeext->cur_wireless_mode == WIRELESS_11G) ||\r\n(pmlmeext->cur_wireless_mode == WIRELESS_11BG))\r\nisLegacy = true;\r\nreturn isLegacy;\r\n}\r\nvoid BTDM_CheckWiFiState(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct mlme_priv *pmlmepriv;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\npHalData = GET_HAL_DATA(padapter);\r\npmlmepriv = &padapter->mlmepriv;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\nif (pmlmepriv->LinkDetectInfo.bBusyTraffic) {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_IDLE;\r\nif (pmlmepriv->LinkDetectInfo.bTxBusyTraffic)\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_UPLINK;\r\nelse\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_UPLINK;\r\nif (pmlmepriv->LinkDetectInfo.bRxBusyTraffic)\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_DOWNLINK;\r\nelse\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_DOWNLINK;\r\n} else {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_IDLE;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_UPLINK;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_DOWNLINK;\r\n}\r\nif (BTDM_Legacy(padapter)) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_LEGACY;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_HT20;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_HT40;\r\n} else {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_LEGACY;\r\nif (BTDM_IsHT40(padapter)) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_HT40;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_HT20;\r\n} else {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_HT20;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_HT40;\r\n}\r\n}\r\nif (pBtMgnt->BtOperationOn)\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_BT30;\r\nelse\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_BT30;\r\n}\r\ns32 BTDM_GetRxSS(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct hal_data_8723a *pHalData;\r\ns32 UndecoratedSmoothedPWDB = 0;\r\npmlmepriv = &padapter->mlmepriv;\r\npHalData = GET_HAL_DATA(padapter);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nUndecoratedSmoothedPWDB = GET_UNDECORATED_AVERAGE_RSSI(padapter);\r\n} else {\r\nUndecoratedSmoothedPWDB = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_GetRxSS() = %d\n", UndecoratedSmoothedPWDB));\r\nreturn UndecoratedSmoothedPWDB;\r\n}\r\nstatic s32 BTDM_GetRxBeaconSS(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct hal_data_8723a *pHalData;\r\ns32 pwdbBeacon = 0;\r\npmlmepriv = &padapter->mlmepriv;\r\npHalData = GET_HAL_DATA(padapter);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\npwdbBeacon = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_GetRxBeaconSS() = %d\n", pwdbBeacon));\r\nreturn pwdbBeacon;\r\n}\r\nu8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter, u8 levelNum,\r\nu8 RssiThresh, u8 RssiThresh1)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\ns32 pwdbBeacon = 0;\r\nu8 bcnRssiState = 0;\r\npwdbBeacon = BTDM_GetRxBeaconSS(padapter);\r\nif (levelNum == 2) {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_MEDIUM;\r\nif ((pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_STAY_LOW)) {\r\nif (pwdbBeacon >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbcnRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to High\n"));\r\n} else {\r\nbcnRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state stay at Low\n"));\r\n}\r\n} else {\r\nif (pwdbBeacon < RssiThresh) {\r\nbcnRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to Low\n"));\r\n} else {\r\nbcnRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state stay at High\n"));\r\n}\r\n}\r\n} else if (levelNum == 3) {\r\nif (RssiThresh > RssiThresh1) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON thresh error!!\n"));\r\nreturn pHalData->bt_coexist.preRssiStateBeacon;\r\n}\r\nif ((pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_STAY_LOW)) {\r\nif (pwdbBeacon >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbcnRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to Medium\n"));\r\n} else {\r\nbcnRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state stay at Low\n"));\r\n}\r\n} else if ((pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_MEDIUM) ||\r\n(pHalData->bt_coexist.preRssiStateBeacon == BT_RSSI_STATE_STAY_MEDIUM)) {\r\nif (pwdbBeacon >= (RssiThresh1+BT_FW_COEX_THRESH_TOL)) {\r\nbcnRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to High\n"));\r\n} else if (pwdbBeacon < RssiThresh) {\r\nbcnRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to Low\n"));\r\n} else {\r\nbcnRssiState = BT_RSSI_STATE_STAY_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state stay at Medium\n"));\r\n}\r\n} else {\r\nif (pwdbBeacon < RssiThresh1) {\r\nbcnRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_BEACON_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_BEACON_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state switch to Medium\n"));\r\n} else {\r\nbcnRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_BEACON state stay at High\n"));\r\n}\r\n}\r\n}\r\npHalData->bt_coexist.preRssiStateBeacon = bcnRssiState;\r\nreturn bcnRssiState;\r\n}\r\nu8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter, u8 levelNum,\r\nu8 RssiThresh, u8 RssiThresh1)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\ns32 UndecoratedSmoothedPWDB = 0;\r\nu8 btRssiState = 0;\r\nUndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);\r\nif (levelNum == 2) {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_MEDIUM;\r\nif ((pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_STAY_LOW)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to High\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state stay at Low\n"));\r\n}\r\n} else {\r\nif (UndecoratedSmoothedPWDB < RssiThresh) {\r\nbtRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to Low\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state stay at High\n"));\r\n}\r\n}\r\n} else if (levelNum == 3) {\r\nif (RssiThresh > RssiThresh1) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 thresh error!!\n"));\r\nreturn pHalData->bt_coexist.preRssiState1;\r\n}\r\nif ((pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_STAY_LOW)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to Medium\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state stay at Low\n"));\r\n}\r\n} else if ((pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_MEDIUM) ||\r\n(pHalData->bt_coexist.preRssiState1 == BT_RSSI_STATE_STAY_MEDIUM)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh1+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to High\n"));\r\n} else if (UndecoratedSmoothedPWDB < RssiThresh) {\r\nbtRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to Low\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state stay at Medium\n"));\r\n}\r\n} else {\r\nif (UndecoratedSmoothedPWDB < RssiThresh1) {\r\nbtRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_1_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_1_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state switch to Medium\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI_1 state stay at High\n"));\r\n}\r\n}\r\n}\r\npHalData->bt_coexist.preRssiState1 = btRssiState;\r\nreturn btRssiState;\r\n}\r\nu8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter, u8 levelNum,\r\nu8 RssiThresh, u8 RssiThresh1)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\ns32 UndecoratedSmoothedPWDB = 0;\r\nu8 btRssiState = 0;\r\nUndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);\r\nif (levelNum == 2) {\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_MEDIUM;\r\nif ((pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_STAY_LOW)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to High\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state stay at Low\n"));\r\n}\r\n} else {\r\nif (UndecoratedSmoothedPWDB < RssiThresh) {\r\nbtRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to Low\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state stay at High\n"));\r\n}\r\n}\r\n} else if (levelNum == 3) {\r\nif (RssiThresh > RssiThresh1) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI thresh error!!\n"));\r\nreturn pHalData->bt_coexist.preRssiState;\r\n}\r\nif ((pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_LOW) ||\r\n(pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_STAY_LOW)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to Medium\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state stay at Low\n"));\r\n}\r\n} else if ((pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_MEDIUM) ||\r\n(pHalData->bt_coexist.preRssiState == BT_RSSI_STATE_STAY_MEDIUM)) {\r\nif (UndecoratedSmoothedPWDB >= (RssiThresh1+BT_FW_COEX_THRESH_TOL)) {\r\nbtRssiState = BT_RSSI_STATE_HIGH;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to High\n"));\r\n} else if (UndecoratedSmoothedPWDB < RssiThresh) {\r\nbtRssiState = BT_RSSI_STATE_LOW;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_LOW;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to Low\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_MEDIUM;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state stay at Medium\n"));\r\n}\r\n} else {\r\nif (UndecoratedSmoothedPWDB < RssiThresh1) {\r\nbtRssiState = BT_RSSI_STATE_MEDIUM;\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_WIFI_RSSI_MEDIUM;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_HIGH;\r\npHalData->bt_coexist.CurrentState &= ~BT_COEX_STATE_WIFI_RSSI_LOW;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state switch to Medium\n"));\r\n} else {\r\nbtRssiState = BT_RSSI_STATE_STAY_HIGH;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], RSSI state stay at High\n"));\r\n}\r\n}\r\n}\r\npHalData->bt_coexist.preRssiState = btRssiState;\r\nreturn btRssiState;\r\n}\r\nbool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct hal_data_8723a *pHalData;\r\nu8 bBtChangeEDCA = false;\r\nu32 EDCA_BT_BE = 0x5ea42b, cur_EDCA_reg;\r\nbool bRet = false;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtMgnt = &pHalData->BtInfo.BtMgnt;\r\nif (!rtl8723a_BT_coexist(padapter)) {\r\nbRet = false;\r\npHalData->bt_coexist.lastBtEdca = 0;\r\nreturn bRet;\r\n}\r\nif (!((pBtMgnt->bSupportProfile) ||\r\n(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC8))) {\r\nbRet = false;\r\npHalData->bt_coexist.lastBtEdca = 0;\r\nreturn bRet;\r\n}\r\nif (rtl8723a_BT_using_antenna_1(padapter)) {\r\nbRet = false;\r\npHalData->bt_coexist.lastBtEdca = 0;\r\nreturn bRet;\r\n}\r\nif (pHalData->bt_coexist.exec_cnt < 3)\r\npHalData->bt_coexist.exec_cnt++;\r\nelse\r\npHalData->bt_coexist.bEDCAInitialized = true;\r\nif (!(pHalData->bt_coexist.CurrentState & BT_COEX_STATE_BT_IDLE)) {\r\nRTPRINT(FBT, BT_TRACE, ("BT state non idle, set bt EDCA\n"));\r\nif (pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA) {\r\nbBtChangeEDCA = true;\r\npHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA = false;\r\npHalData->dmpriv.prv_traffic_idx = 3;\r\n}\r\ncur_EDCA_reg = rtl8723au_read32(padapter, REG_EDCA_BE_PARAM);\r\nif (cur_EDCA_reg != EDCA_BT_BE)\r\nbBtChangeEDCA = true;\r\nif (bBtChangeEDCA || !pHalData->bt_coexist.bEDCAInitialized) {\r\nrtl8723au_write32(padapter, REG_EDCA_BE_PARAM,\r\nEDCA_BT_BE);\r\npHalData->bt_coexist.lastBtEdca = EDCA_BT_BE;\r\n}\r\nbRet = true;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("BT state idle, set original EDCA\n"));\r\npHalData->bt_coexist.lastBtEdca = 0;\r\nbRet = false;\r\n}\r\nreturn bRet;\r\n}\r\nvoid\r\nBTDM_Balance(\r\nstruct rtw_adapter *padapter,\r\nu8 bBalanceOn,\r\nu8 ms0,\r\nu8 ms1\r\n)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[3] = {0};\r\nif (bBalanceOn) {\r\nH2C_Parameter[2] = 1;\r\nH2C_Parameter[1] = ms1;\r\nH2C_Parameter[0] = ms0;\r\npHalData->bt_coexist.bFWCoexistAllOff = false;\r\n} else {\r\nH2C_Parameter[2] = 0;\r\nH2C_Parameter[1] = 0;\r\nH2C_Parameter[0] = 0;\r\n}\r\npHalData->bt_coexist.bBalanceOn = bBalanceOn;\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], Balance =[%s:%dms:%dms], write 0xc = 0x%x\n",\r\nbBalanceOn?"ON":"OFF", ms0, ms1,\r\nH2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));\r\nFillH2CCmd(padapter, 0xc, 3, H2C_Parameter);\r\n}\r\nvoid BTDM_AGCTable(struct rtw_adapter *padapter, u8 type)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (type == BT_AGCTABLE_OFF) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT]AGCTable Off!\n"));\r\nrtl8723au_write32(padapter, 0xc78, 0x641c0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x631d0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x621e0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x611f0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x60200001);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0x32000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0x71000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0xb0000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0xfc000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_G1, bRFRegOffsetMask, 0x30355);\r\npHalData->bt_coexist.b8723aAgcTableOn = false;\r\n} else if (type == BT_AGCTABLE_ON) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT]AGCTable On!\n"));\r\nrtl8723au_write32(padapter, 0xc78, 0x4e1c0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x4d1d0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x4c1e0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x4b1f0001);\r\nrtl8723au_write32(padapter, 0xc78, 0x4a200001);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0xdc000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0x90000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0x51000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_AGC_HP, bRFRegOffsetMask, 0x12000);\r\nPHY_SetRFReg(padapter, PathA, RF_RX_G1, bRFRegOffsetMask, 0x00355);\r\npHalData->bt_coexist.b8723aAgcTableOn = true;\r\npHalData->bt_coexist.bSWCoexistAllOff = false;\r\n}\r\n}\r\nvoid BTDM_BBBackOffLevel(struct rtw_adapter *padapter, u8 type)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (type == BT_BB_BACKOFF_OFF) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT]BBBackOffLevel Off!\n"));\r\nrtl8723au_write32(padapter, 0xc04, 0x3a05611);\r\n} else if (type == BT_BB_BACKOFF_ON) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT]BBBackOffLevel On!\n"));\r\nrtl8723au_write32(padapter, 0xc04, 0x3a07611);\r\npHalData->bt_coexist.bSWCoexistAllOff = false;\r\n}\r\n}\r\nvoid BTDM_FWCoexAllOff(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_FWCoexAllOff()\n"));\r\nif (pHalData->bt_coexist.bFWCoexistAllOff)\r\nreturn;\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_FWCoexAllOff(), real Do\n"));\r\nBTDM_FWCoexAllOff8723A(padapter);\r\npHalData->bt_coexist.bFWCoexistAllOff = true;\r\n}\r\nvoid BTDM_SWCoexAllOff(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_SWCoexAllOff()\n"));\r\nif (pHalData->bt_coexist.bSWCoexistAllOff)\r\nreturn;\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_SWCoexAllOff(), real Do\n"));\r\nBTDM_SWCoexAllOff8723A(padapter);\r\npHalData->bt_coexist.bSWCoexistAllOff = true;\r\n}\r\nvoid BTDM_HWCoexAllOff(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_HWCoexAllOff()\n"));\r\nif (pHalData->bt_coexist.bHWCoexistAllOff)\r\nreturn;\r\nRTPRINT(FBT, BT_TRACE, ("BTDM_HWCoexAllOff(), real Do\n"));\r\nBTDM_HWCoexAllOff8723A(padapter);\r\npHalData->bt_coexist.bHWCoexistAllOff = true;\r\n}\r\nvoid BTDM_CoexAllOff(struct rtw_adapter *padapter)\r\n{\r\nBTDM_FWCoexAllOff(padapter);\r\nBTDM_SWCoexAllOff(padapter);\r\nBTDM_HWCoexAllOff(padapter);\r\n}\r\nvoid rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *ppwrctrl = &padapter->pwrctrlpriv;\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nif (rtl8723a_BT_using_antenna_1(padapter))\r\nreturn;\r\nif (ppwrctrl->reg_rfoff == rf_on) {\r\nRTPRINT(FBT, BT_TRACE, ("[BT][DM], Before enter IPS, turn off all Coexist DM\n"));\r\nbtdm_ResetFWCoexState(padapter);\r\nBTDM_CoexAllOff(padapter);\r\nBTDM_SetAntenna(padapter, BTDM_ANT_BT);\r\n}\r\n}\r\nvoid BTDM_SignalCompensation(struct rtw_adapter *padapter, u8 *rssi_wifi, u8 *rssi_bt)\r\n{\r\nBTDM_8723ASignalCompensation(padapter, rssi_wifi, rssi_bt);\r\n}\r\nvoid rtl8723a_BT_do_coexist(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (!rtl8723a_BT_coexist(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BT not exists!!\n"));\r\nreturn;\r\n}\r\nif (!pHalData->bt_coexist.bInitlized) {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], btdm_InitBtCoexistDM()\n"));\r\nbtdm_InitBtCoexistDM(padapter);\r\n}\r\nRTPRINT(FBT, BT_TRACE, ("\n\n[DM][BT], BTDM start!!\n"));\r\nBTDM_PWDBMonitor(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], HW type is 8723\n"));\r\nBTDM_BTCoexist8723A(padapter);\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], BTDM end!!\n\n"));\r\n}\r\nvoid BTDM_UpdateCoexState(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (!BTDM_IsSameCoexistState(padapter)) {\r\nRTPRINT(FBT, BT_TRACE, ("[BTCoex], Coexist State[bitMap] change from 0x%"i64fmt"x to 0x%"i64fmt"x, changeBits = 0x%"i64fmt"x\n",\r\npHalData->bt_coexist.PreviousState,\r\npHalData->bt_coexist.CurrentState,\r\n(pHalData->bt_coexist.PreviousState^pHalData->bt_coexist.CurrentState)));\r\npHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;\r\n}\r\n}\r\nu8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {\r\nreturn true;\r\n} else {\r\nRTPRINT(FBT, BT_TRACE, ("[DM][BT], Coexist state changed!!\n"));\r\nreturn false;\r\n}\r\n}\r\nvoid BTDM_PWDBMonitor(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(GetDefaultAdapter(padapter));\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 H2C_Parameter[3] = {0};\r\ns32 tmpBTEntryMaxPWDB = 0, tmpBTEntryMinPWDB = 0xff;\r\nu8 i;\r\nif (pBtMgnt->BtOperationOn) {\r\nfor (i = 0; i < MAX_BT_ASOC_ENTRY_NUM; i++) {\r\nif (pBTInfo->BtAsocEntry[i].bUsed) {\r\nif (pBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB < tmpBTEntryMinPWDB)\r\ntmpBTEntryMinPWDB = pBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB;\r\nif (pBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB > tmpBTEntryMaxPWDB)\r\ntmpBTEntryMaxPWDB = pBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB;\r\nH2C_Parameter[2] = (u8)(pBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB & 0xFF);\r\nH2C_Parameter[0] = (MAX_FW_SUPPORT_MACID_NUM-1-i);\r\nRTPRINT(FDM, DM_BT30, ("RSSI report for BT[%d], H2C_Par = 0x%x\n", i, H2C_Parameter[0]));\r\nFillH2CCmd(padapter, RSSI_SETTING_EID, 3, H2C_Parameter);\r\nRTPRINT_ADDR(FDM, (DM_PWDB|DM_BT30), ("BT_Entry Mac :"),\r\npBTInfo->BtAsocEntry[i].BTRemoteMACAddr)\r\nRTPRINT(FDM, (DM_PWDB|DM_BT30),\r\n("BT rx pwdb[%d] = 0x%x(%d)\n", i,\r\npBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB,\r\npBTInfo->BtAsocEntry[i].UndecoratedSmoothedPWDB));\r\n}\r\n}\r\nif (tmpBTEntryMaxPWDB != 0) {\r\npHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = tmpBTEntryMaxPWDB;\r\nRTPRINT(FDM, (DM_PWDB|DM_BT30), ("BT_EntryMaxPWDB = 0x%x(%d)\n",\r\ntmpBTEntryMaxPWDB, tmpBTEntryMaxPWDB));\r\n} else {\r\npHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = 0;\r\n}\r\nif (tmpBTEntryMinPWDB != 0xff) {\r\npHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = tmpBTEntryMinPWDB;\r\nRTPRINT(FDM, (DM_PWDB|DM_BT30), ("BT_EntryMinPWDB = 0x%x(%d)\n",\r\ntmpBTEntryMinPWDB, tmpBTEntryMinPWDB));\r\n} else {\r\npHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = 0;\r\n}\r\n}\r\n}\r\nu8 BTDM_IsBTBusy(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_mgnt *pBtMgnt = &pBTInfo->BtMgnt;\r\nif (pBtMgnt->ExtConfig.bBTBusy)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsWifiBusy(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &GetDefaultAdapter(padapter)->mlmepriv;\r\nstruct bt_30info *pBTInfo = GET_BT_INFO(padapter);\r\nstruct bt_traffic *pBtTraffic = &pBTInfo->BtTraffic;\r\nif (pmlmepriv->LinkDetectInfo.bBusyTraffic ||\r\npBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic ||\r\npBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nu8 BTDM_IsWifiUplink(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_traffic *pBtTraffic;\r\npmlmepriv = &padapter->mlmepriv;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtTraffic = &pBTInfo->BtTraffic;\r\nif ((pmlmepriv->LinkDetectInfo.bTxBusyTraffic) ||\r\n(pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_traffic *pBtTraffic;\r\npmlmepriv = &padapter->mlmepriv;\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtTraffic = &pBTInfo->BtTraffic;\r\nif ((pmlmepriv->LinkDetectInfo.bRxBusyTraffic) ||\r\n(pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsBTHSMode(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_mgnt *pBtMgnt;\r\npHalData = GET_HAL_DATA(padapter);\r\npBtMgnt = &pHalData->BtInfo.BtMgnt;\r\nif (pBtMgnt->BtOperationOn)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsBTUplink(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 BTDM_IsBTDownlink(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid BTDM_AdjustForBtOperation(struct rtw_adapter *padapter)\r\n{\r\nRTPRINT(FBT, BT_TRACE, ("[BT][DM], BTDM_AdjustForBtOperation()\n"));\r\nBTDM_AdjustForBtOperation8723A(padapter);\r\n}\r\nvoid BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter, u8 antNum)\r\n{\r\nBTDM_Set8723ABtCoexCurrAntNum(padapter, antNum);\r\n}\r\nvoid BTDM_ForHalt(struct rtw_adapter *padapter)\r\n{\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nBTDM_ForHalt8723A(padapter);\r\nGET_HAL_DATA(padapter)->bt_coexist.bInitlized = false;\r\n}\r\nvoid BTDM_WifiScanNotify(struct rtw_adapter *padapter, u8 scanType)\r\n{\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nBTDM_WifiScanNotify8723A(padapter, scanType);\r\n}\r\nvoid BTDM_WifiAssociateNotify(struct rtw_adapter *padapter, u8 action)\r\n{\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nBTDM_WifiAssociateNotify8723A(padapter, action);\r\n}\r\nvoid rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter,\r\nenum rt_media_status mstatus)\r\n{\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nBTDM_MediaStatusNotify8723A(padapter, mstatus);\r\n}\r\nvoid rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter)\r\n{\r\nif (!rtl8723a_BT_coexist(padapter))\r\nreturn;\r\nBTDM_ForDhcp8723A(padapter);\r\n}\r\nvoid BTDM_ResetActionProfileState(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npHalData->bt_coexist.CurrentState &= ~\\r\n(BT_COEX_STATE_PROFILE_HID|BT_COEX_STATE_PROFILE_A2DP|\r\nBT_COEX_STATE_PROFILE_PAN|BT_COEX_STATE_PROFILE_SCO);\r\n}\r\nu8 BTDM_IsActionSCO(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_SCO) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_SCO;\r\nbRet = true;\r\n}\r\n} else {\r\nif (pBtMgnt->ExtConfig.NumberOfSCO > 0) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_SCO;\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionHID(struct rtw_adapter *padapter)\r\n{\r\nstruct bt_30info *pBTInfo;\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_HID) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_HID;\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\npBtMgnt->ExtConfig.NumberOfHandle == 1) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_HID;\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionA2DP(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_A2DP) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_A2DP;\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP) &&\r\npBtMgnt->ExtConfig.NumberOfHandle == 1) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_A2DP;\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionPAN(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_PAN) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_PAN;\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) &&\r\npBtMgnt->ExtConfig.NumberOfHandle == 1) {\r\npHalData->bt_coexist.CurrentState |= BT_COEX_STATE_PROFILE_PAN;\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_mgnt *pBtMgnt;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtMgnt = &pBTInfo->BtMgnt;\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_HID_A2DP) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_HID|BT_COEX_STATE_PROFILE_A2DP);\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_HID|BT_COEX_STATE_PROFILE_A2DP);\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_HID_PAN) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_HID|BT_COEX_STATE_PROFILE_PAN);\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_HID) &&\r\nBTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN)) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_HID|BT_COEX_STATE_PROFILE_PAN);\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nu8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct bt_30info *pBTInfo;\r\nstruct bt_dgb *pBtDbg;\r\nu8 bRet;\r\npHalData = GET_HAL_DATA(padapter);\r\npBTInfo = GET_BT_INFO(padapter);\r\npBtDbg = &pBTInfo->BtDbg;\r\nbRet = false;\r\nif (pBtDbg->dbgCtrl) {\r\nif (pBtDbg->dbgProfile == BT_DBG_PROFILE_PAN_A2DP) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_PAN|BT_COEX_STATE_PROFILE_A2DP);\r\nbRet = true;\r\n}\r\n} else {\r\nif (BTHCI_CheckProfileExist(padapter, BT_PROFILE_PAN) && BTHCI_CheckProfileExist(padapter, BT_PROFILE_A2DP)) {\r\npHalData->bt_coexist.CurrentState |= (BT_COEX_STATE_PROFILE_PAN|BT_COEX_STATE_PROFILE_A2DP);\r\nbRet = true;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nbool rtl8723a_BT_enabled(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.bCurBtDisabled)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic void halbt_InitHwConfig8723A(struct rtw_adapter *padapter)\r\n{\r\n}\r\nu8 HALBT_GetPGAntNum(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nreturn pHalData->bt_coexist.BT_Ant_Num;\r\n}\r\nvoid HALBT_SetKey(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTinfo;\r\nstruct bt_asoc_entry *pBtAssocEntry;\r\nu16 usConfig = 0;\r\npBTinfo = GET_BT_INFO(padapter);\r\npBtAssocEntry = &pBTinfo->BtAsocEntry[EntryNum];\r\npBtAssocEntry->HwCAMIndex = BT_HWCAM_STAR + EntryNum;\r\nusConfig = CAM_VALID | (CAM_AES << 2);\r\nrtl8723a_cam_write(padapter, pBtAssocEntry->HwCAMIndex, usConfig,\r\npBtAssocEntry->BTRemoteMACAddr,\r\npBtAssocEntry->PTK + TKIP_ENC_KEY_POS);\r\n}\r\nvoid HALBT_RemoveKey(struct rtw_adapter *padapter, u8 EntryNum)\r\n{\r\nstruct bt_30info *pBTinfo;\r\nstruct bt_asoc_entry *pBtAssocEntry;\r\npBTinfo = GET_BT_INFO(padapter);\r\npBtAssocEntry = &pBTinfo->BtAsocEntry[EntryNum];\r\nif (pBTinfo->BtAsocEntry[EntryNum].HwCAMIndex != 0) {\r\nif (pBtAssocEntry->HwCAMIndex >= BT_HWCAM_STAR &&\r\npBtAssocEntry->HwCAMIndex < HALF_CAM_ENTRY)\r\nrtl8723a_cam_empty_entry(padapter,\r\npBtAssocEntry->HwCAMIndex);\r\npBTinfo->BtAsocEntry[EntryNum].HwCAMIndex = 0;\r\n}\r\n}\r\nvoid rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\npHalData = GET_HAL_DATA(padapter);\r\npHalData->bt_coexist.BluetoothCoexist = pHalData->EEPROMBluetoothCoexist;\r\npHalData->bt_coexist.BT_Ant_Num = pHalData->EEPROMBluetoothAntNum;\r\npHalData->bt_coexist.BT_CoexistType = pHalData->EEPROMBluetoothType;\r\npHalData->bt_coexist.BT_Ant_isolation = pHalData->EEPROMBluetoothAntIsolation;\r\npHalData->bt_coexist.bt_radiosharedtype = pHalData->EEPROMBluetoothRadioShared;\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n"BT Coexistance = 0x%x\n", rtl8723a_BT_coexist(padapter));\r\nif (rtl8723a_BT_coexist(padapter)) {\r\nif (pHalData->bt_coexist.BT_Ant_Num == Ant_x2) {\r\nBTDM_SetBtCoexCurrAntNum(padapter, 2);\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n"BlueTooth BT_Ant_Num = Antx2\n");\r\n} else if (pHalData->bt_coexist.BT_Ant_Num == Ant_x1) {\r\nBTDM_SetBtCoexCurrAntNum(padapter, 1);\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n"BlueTooth BT_Ant_Num = Antx1\n");\r\n}\r\npHalData->bt_coexist.bBTBusyTraffic = false;\r\npHalData->bt_coexist.bBTTrafficModeSet = false;\r\npHalData->bt_coexist.bBTNonTrafficModeSet = false;\r\npHalData->bt_coexist.CurrentState = 0;\r\npHalData->bt_coexist.PreviousState = 0;\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n"bt_radiosharedType = 0x%x\n",\r\npHalData->bt_coexist.bt_radiosharedtype);\r\n}\r\n}\r\nbool rtl8723a_BT_coexist(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->bt_coexist.BluetoothCoexist)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu8 HALBT_BTChipType(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nreturn pHalData->bt_coexist.BT_CoexistType;\r\n}\r\nvoid rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter)\r\n{\r\nhalbt_InitHwConfig8723A(padapter);\r\nrtl8723a_BT_do_coexist(padapter);\r\n}\r\nvoid HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter)\r\n{\r\n}\r\nvoid rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct dm_odm_t *pDM_Odm;\r\nstruct sw_ant_sw *pDM_SWAT_Table;\r\nu8 i;\r\npHalData = GET_HAL_DATA(padapter);\r\npDM_Odm = &pHalData->odmpriv;\r\npDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;\r\nif (!pHalData->bAntennaDetected) {\r\nu8 btAntNum = BT_GetPGAntNum(padapter);\r\nif (btAntNum == Ant_x2)\r\npDM_SWAT_Table->ANTB_ON = true;\r\nelse if (btAntNum == Ant_x1)\r\npDM_SWAT_Table->ANTB_ON = false;\r\nelse\r\npDM_SWAT_Table->ANTB_ON = true;\r\nif (pHalData->CustomerID != RT_CID_TOSHIBA) {\r\nfor (i = 0; i < MAX_ANTENNA_DETECTION_CNT; i++) {\r\nif (ODM_SingleDualAntennaDetection\r\n(&pHalData->odmpriv, ANTTESTALL) == true)\r\nbreak;\r\n}\r\nif (btAntNum == Ant_x2)\r\nBT_SetBtCoexCurrAntNum(padapter,\r\npDM_SWAT_Table->\r\nANTB_ON ? 2 : 1);\r\n}\r\npHalData->bAntennaDetected = true;\r\n}\r\n}
