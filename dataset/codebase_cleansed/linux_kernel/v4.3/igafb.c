static inline unsigned int iga_inb(struct iga_par *par, unsigned int reg,\r\nunsigned int idx)\r\n{\r\npci_outb(par, idx, reg);\r\nreturn pci_inb(par, reg + 1);\r\n}\r\nstatic inline void iga_outb(struct iga_par *par, unsigned char val,\r\nunsigned int reg, unsigned int idx )\r\n{\r\npci_outb(par, idx, reg);\r\npci_outb(par, val, reg+1);\r\n}\r\nstatic void iga_blank_border(struct iga_par *par)\r\n{\r\nint i;\r\n#if 0\r\n(void) pci_inb(par, 0x3DA);\r\npci_outb(par, IGA_IDX_VGA_OVERSCAN, IGA_ATTR_CTL);\r\n(void) pci_inb(par, IGA_ATTR_CTL+1);\r\npci_outb(par, 0x38, IGA_ATTR_CTL);\r\npci_outb(par, 0x20, IGA_ATTR_CTL);\r\n#endif\r\nfor (i=0; i < 3; i++)\r\niga_outb(par, 0, IGA_EXT_CNTRL, IGA_IDX_OVERSCAN_COLOR + i);\r\n}\r\nstatic int igafb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct iga_par *par = (struct iga_par *)info->par;\r\nunsigned int size, page, map_size = 0;\r\nunsigned long map_offset = 0;\r\nint i;\r\nif (!par->mmap_map)\r\nreturn -ENXIO;\r\nsize = vma->vm_end - vma->vm_start;\r\nfor (page = 0; page < size; ) {\r\nmap_size = 0;\r\nfor (i = 0; par->mmap_map[i].size; i++) {\r\nunsigned long start = par->mmap_map[i].voff;\r\nunsigned long end = start + par->mmap_map[i].size;\r\nunsigned long offset = (vma->vm_pgoff << PAGE_SHIFT) + page;\r\nif (start > offset)\r\ncontinue;\r\nif (offset >= end)\r\ncontinue;\r\nmap_size = par->mmap_map[i].size - (offset - start);\r\nmap_offset = par->mmap_map[i].poff + (offset - start);\r\nbreak;\r\n}\r\nif (!map_size) {\r\npage += PAGE_SIZE;\r\ncontinue;\r\n}\r\nif (page + map_size > size)\r\nmap_size = size - page;\r\npgprot_val(vma->vm_page_prot) &= ~(par->mmap_map[i].prot_mask);\r\npgprot_val(vma->vm_page_prot) |= par->mmap_map[i].prot_flag;\r\nif (remap_pfn_range(vma, vma->vm_start + page,\r\nmap_offset >> PAGE_SHIFT, map_size, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\npage += map_size;\r\n}\r\nif (!map_size)\r\nreturn -EINVAL;\r\nvma->vm_flags |= VM_IO;\r\nreturn 0;\r\n}\r\nstatic int igafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct iga_par *par = (struct iga_par *)info->par;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\npci_outb(par, regno, DAC_W_INDEX);\r\npci_outb(par, red, DAC_DATA);\r\npci_outb(par, green, DAC_DATA);\r\npci_outb(par, blue, DAC_DATA);\r\nif (regno < 16) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\n((u16*)(info->pseudo_palette))[regno] =\r\n(regno << 10) | (regno << 5) | regno;\r\nbreak;\r\ncase 24:\r\n((u32*)(info->pseudo_palette))[regno] =\r\n(regno << 16) | (regno << 8) | regno;\r\nbreak;\r\ncase 32:\r\n{ int i;\r\ni = (regno << 8) | regno;\r\n((u32*)(info->pseudo_palette))[regno] = (i << 16) | i;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init iga_init(struct fb_info *info, struct iga_par *par)\r\n{\r\nchar vramsz = iga_inb(par, IGA_EXT_CNTRL, IGA_IDX_EXT_BUS_CNTL)\r\n& MEM_SIZE_ALIAS;\r\nint video_cmap_len;\r\nswitch (vramsz) {\r\ncase MEM_SIZE_1M:\r\ninfo->fix.smem_len = 0x100000;\r\nbreak;\r\ncase MEM_SIZE_2M:\r\ninfo->fix.smem_len = 0x200000;\r\nbreak;\r\ncase MEM_SIZE_4M:\r\ncase MEM_SIZE_RESERVED:\r\ninfo->fix.smem_len = 0x400000;\r\nbreak;\r\n}\r\nif (info->var.bits_per_pixel > 8)\r\nvideo_cmap_len = 16;\r\nelse\r\nvideo_cmap_len = 256;\r\ninfo->fbops = &igafb_ops;\r\ninfo->flags = FBINFO_DEFAULT;\r\nfb_alloc_cmap(&info->cmap, video_cmap_len, 0);\r\nif (register_framebuffer(info) < 0)\r\nreturn 0;\r\nfb_info(info, "%s frame buffer device at 0x%08lx [%dMB VRAM]\n",\r\ninfo->fix.id, par->frame_buffer_phys, info->fix.smem_len >> 20);\r\niga_blank_border(par);\r\nreturn 1;\r\n}\r\nstatic int __init igafb_init(void)\r\n{\r\nstruct fb_info *info;\r\nstruct pci_dev *pdev;\r\nstruct iga_par *par;\r\nunsigned long addr;\r\nint size, iga2000 = 0;\r\nif (fb_get_options("igafb", NULL))\r\nreturn -ENODEV;\r\npdev = pci_get_device(PCI_VENDOR_ID_INTERG,\r\nPCI_DEVICE_ID_INTERG_1682, 0);\r\nif (pdev == NULL) {\r\npdev = pci_get_device(PCI_VENDOR_ID_INTERG, 0x2000, 0);\r\nif(pdev == NULL) {\r\nreturn -ENXIO;\r\n}\r\niga2000 = 1;\r\n}\r\nsize = sizeof(struct iga_par) + sizeof(u32)*16;\r\ninfo = framebuffer_alloc(size, &pdev->dev);\r\nif (!info) {\r\nprintk("igafb_init: can't alloc fb_info\n");\r\npci_dev_put(pdev);\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\nif ((addr = pdev->resource[0].start) == 0) {\r\nprintk("igafb_init: no memory start\n");\r\nkfree(info);\r\npci_dev_put(pdev);\r\nreturn -ENXIO;\r\n}\r\nif ((info->screen_base = ioremap(addr, 1024*1024*2)) == 0) {\r\nprintk("igafb_init: can't remap %lx[2M]\n", addr);\r\nkfree(info);\r\npci_dev_put(pdev);\r\nreturn -ENXIO;\r\n}\r\npar->frame_buffer_phys = addr & PCI_BASE_ADDRESS_MEM_MASK;\r\n#ifdef CONFIG_SPARC\r\nif (iga2000) {\r\nigafb_fix.mmio_start = par->frame_buffer_phys | 0x00800000;\r\n} else {\r\nigafb_fix.mmio_start = 0x30000000;\r\n}\r\nif ((par->io_base = (int) ioremap(igafb_fix.mmio_start, igafb_fix.smem_len)) == 0) {\r\nprintk("igafb_init: can't remap %lx[4K]\n", igafb_fix.mmio_start);\r\niounmap((void *)info->screen_base);\r\nkfree(info);\r\npci_dev_put(pdev);\r\nreturn -ENXIO;\r\n}\r\npar->mmap_map = kzalloc(4 * sizeof(*par->mmap_map), GFP_ATOMIC);\r\nif (!par->mmap_map) {\r\nprintk("igafb_init: can't alloc mmap_map\n");\r\niounmap((void *)par->io_base);\r\niounmap(info->screen_base);\r\nkfree(info);\r\npci_dev_put(pdev);\r\nreturn -ENOMEM;\r\n}\r\n{\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nint node = dp->node;\r\nint width = prom_getintdefault(node, "width", 1024);\r\nint height = prom_getintdefault(node, "height", 768);\r\nint depth = prom_getintdefault(node, "depth", 8);\r\nswitch (width) {\r\ncase 1024:\r\nif (height == 768)\r\ndefault_var = default_var_1024x768;\r\nbreak;\r\ncase 1152:\r\nif (height == 900)\r\ndefault_var = default_var_1152x900;\r\nbreak;\r\ncase 1280:\r\nif (height == 1024)\r\ndefault_var = default_var_1280x1024;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (depth) {\r\ncase 8:\r\ndefault_var.bits_per_pixel = 8;\r\nbreak;\r\ncase 16:\r\ndefault_var.bits_per_pixel = 16;\r\nbreak;\r\ncase 24:\r\ndefault_var.bits_per_pixel = 24;\r\nbreak;\r\ncase 32:\r\ndefault_var.bits_per_pixel = 32;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n#endif\r\nigafb_fix.smem_start = (unsigned long) info->screen_base;\r\nigafb_fix.line_length = default_var.xres*(default_var.bits_per_pixel/8);\r\nigafb_fix.visual = default_var.bits_per_pixel <= 8 ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\ninfo->var = default_var;\r\ninfo->fix = igafb_fix;\r\ninfo->pseudo_palette = (void *)(par + 1);\r\nif (!iga_init(info, par)) {\r\niounmap((void *)par->io_base);\r\niounmap(info->screen_base);\r\nkfree(par->mmap_map);\r\nkfree(info);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_SPARC\r\npar->mmap_map[0].voff = 0x0;\r\npar->mmap_map[0].poff = par->frame_buffer_phys & PAGE_MASK;\r\npar->mmap_map[0].size = info->fix.smem_len & PAGE_MASK;\r\npar->mmap_map[0].prot_mask = SRMMU_CACHE;\r\npar->mmap_map[0].prot_flag = SRMMU_WRITE;\r\npar->mmap_map[1].voff = par->frame_buffer_phys & PAGE_MASK;\r\npar->mmap_map[1].poff = info->fix.smem_start & PAGE_MASK;\r\npar->mmap_map[1].size = PAGE_SIZE * 2;\r\npar->mmap_map[1].prot_mask = SRMMU_CACHE;\r\npar->mmap_map[1].prot_flag = SRMMU_WRITE;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init igafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\n}\r\nreturn 0;\r\n}
