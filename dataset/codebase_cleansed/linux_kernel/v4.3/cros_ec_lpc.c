static int ec_response_timed_out(void)\r\n{\r\nunsigned long one_second = jiffies + HZ;\r\nusleep_range(200, 300);\r\ndo {\r\nif (!(inb(EC_LPC_ADDR_HOST_CMD) & EC_LPC_STATUS_BUSY_MASK))\r\nreturn 0;\r\nusleep_range(100, 200);\r\n} while (time_before(jiffies, one_second));\r\nreturn 1;\r\n}\r\nstatic int cros_ec_pkt_xfer_lpc(struct cros_ec_device *ec,\r\nstruct cros_ec_command *msg)\r\n{\r\nstruct ec_host_request *request;\r\nstruct ec_host_response response;\r\nu8 sum = 0;\r\nint i;\r\nint ret = 0;\r\nu8 *dout;\r\nret = cros_ec_prepare_tx(ec, msg);\r\nfor (i = 0; i < ret; i++)\r\noutb(ec->dout[i], EC_LPC_ADDR_HOST_PACKET + i);\r\nrequest = (struct ec_host_request *)ec->dout;\r\noutb(EC_COMMAND_PROTOCOL_3, EC_LPC_ADDR_HOST_CMD);\r\nif (ec_response_timed_out()) {\r\ndev_warn(ec->dev, "EC responsed timed out\n");\r\nret = -EIO;\r\ngoto done;\r\n}\r\nmsg->result = inb(EC_LPC_ADDR_HOST_DATA);\r\nret = cros_ec_check_result(ec, msg);\r\nif (ret)\r\ngoto done;\r\ndout = (u8 *)&response;\r\nfor (i = 0; i < sizeof(response); i++) {\r\ndout[i] = inb(EC_LPC_ADDR_HOST_PACKET + i);\r\nsum += dout[i];\r\n}\r\nmsg->result = response.result;\r\nif (response.data_len > msg->insize) {\r\ndev_err(ec->dev,\r\n"packet too long (%d bytes, expected %d)",\r\nresponse.data_len, msg->insize);\r\nret = -EMSGSIZE;\r\ngoto done;\r\n}\r\nfor (i = 0; i < response.data_len; i++) {\r\nmsg->data[i] =\r\ninb(EC_LPC_ADDR_HOST_PACKET + sizeof(response) + i);\r\nsum += msg->data[i];\r\n}\r\nif (sum) {\r\ndev_err(ec->dev,\r\n"bad packet checksum %02x\n",\r\nresponse.checksum);\r\nret = -EBADMSG;\r\ngoto done;\r\n}\r\nret = response.data_len;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int cros_ec_cmd_xfer_lpc(struct cros_ec_device *ec,\r\nstruct cros_ec_command *msg)\r\n{\r\nstruct ec_lpc_host_args args;\r\nint csum;\r\nint i;\r\nint ret = 0;\r\nif (msg->outsize > EC_PROTO2_MAX_PARAM_SIZE ||\r\nmsg->insize > EC_PROTO2_MAX_PARAM_SIZE) {\r\ndev_err(ec->dev,\r\n"invalid buffer sizes (out %d, in %d)\n",\r\nmsg->outsize, msg->insize);\r\nreturn -EINVAL;\r\n}\r\nargs.flags = EC_HOST_ARGS_FLAG_FROM_HOST;\r\nargs.command_version = msg->version;\r\nargs.data_size = msg->outsize;\r\ncsum = msg->command + args.flags +\r\nargs.command_version + args.data_size;\r\nfor (i = 0; i < msg->outsize; i++) {\r\noutb(msg->data[i], EC_LPC_ADDR_HOST_PARAM + i);\r\ncsum += msg->data[i];\r\n}\r\nargs.checksum = csum & 0xFF;\r\noutb(args.flags, EC_LPC_ADDR_HOST_ARGS);\r\noutb(args.command_version, EC_LPC_ADDR_HOST_ARGS + 1);\r\noutb(args.data_size, EC_LPC_ADDR_HOST_ARGS + 2);\r\noutb(args.checksum, EC_LPC_ADDR_HOST_ARGS + 3);\r\noutb(msg->command, EC_LPC_ADDR_HOST_CMD);\r\nif (ec_response_timed_out()) {\r\ndev_warn(ec->dev, "EC responsed timed out\n");\r\nret = -EIO;\r\ngoto done;\r\n}\r\nmsg->result = inb(EC_LPC_ADDR_HOST_DATA);\r\nswitch (msg->result) {\r\ncase EC_RES_SUCCESS:\r\nbreak;\r\ncase EC_RES_IN_PROGRESS:\r\nret = -EAGAIN;\r\ndev_dbg(ec->dev, "command 0x%02x in progress\n",\r\nmsg->command);\r\ngoto done;\r\ndefault:\r\ndev_dbg(ec->dev, "command 0x%02x returned %d\n",\r\nmsg->command, msg->result);\r\n}\r\nargs.flags = inb(EC_LPC_ADDR_HOST_ARGS);\r\nargs.command_version = inb(EC_LPC_ADDR_HOST_ARGS + 1);\r\nargs.data_size = inb(EC_LPC_ADDR_HOST_ARGS + 2);\r\nargs.checksum = inb(EC_LPC_ADDR_HOST_ARGS + 3);\r\nif (args.data_size > msg->insize) {\r\ndev_err(ec->dev,\r\n"packet too long (%d bytes, expected %d)",\r\nargs.data_size, msg->insize);\r\nret = -ENOSPC;\r\ngoto done;\r\n}\r\ncsum = msg->command + args.flags +\r\nargs.command_version + args.data_size;\r\nfor (i = 0; i < args.data_size; i++) {\r\nmsg->data[i] = inb(EC_LPC_ADDR_HOST_PARAM + i);\r\ncsum += msg->data[i];\r\n}\r\nif (args.checksum != (csum & 0xFF)) {\r\ndev_err(ec->dev,\r\n"bad packet checksum, expected %02x, got %02x\n",\r\nargs.checksum, csum & 0xFF);\r\nret = -EBADMSG;\r\ngoto done;\r\n}\r\nret = args.data_size;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int cros_ec_lpc_readmem(struct cros_ec_device *ec, unsigned int offset,\r\nunsigned int bytes, void *dest)\r\n{\r\nint i = offset;\r\nchar *s = dest;\r\nint cnt = 0;\r\nif (offset >= EC_MEMMAP_SIZE - bytes)\r\nreturn -EINVAL;\r\nif (bytes) {\r\nfor (; cnt < bytes; i++, s++, cnt++)\r\n*s = inb(EC_LPC_ADDR_MEMMAP + i);\r\nreturn cnt;\r\n}\r\nfor (; i < EC_MEMMAP_SIZE; i++, s++) {\r\n*s = inb(EC_LPC_ADDR_MEMMAP + i);\r\ncnt++;\r\nif (!*s)\r\nbreak;\r\n}\r\nreturn cnt;\r\n}\r\nstatic int cros_ec_lpc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_device *ec_dev;\r\nint ret;\r\nif (!devm_request_region(dev, EC_LPC_ADDR_MEMMAP, EC_MEMMAP_SIZE,\r\ndev_name(dev))) {\r\ndev_err(dev, "couldn't reserve memmap region\n");\r\nreturn -EBUSY;\r\n}\r\nif ((inb(EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID) != 'E') ||\r\n(inb(EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID + 1) != 'C')) {\r\ndev_err(dev, "EC ID not detected\n");\r\nreturn -ENODEV;\r\n}\r\nif (!devm_request_region(dev, EC_HOST_CMD_REGION0,\r\nEC_HOST_CMD_REGION_SIZE, dev_name(dev))) {\r\ndev_err(dev, "couldn't reserve region0\n");\r\nreturn -EBUSY;\r\n}\r\nif (!devm_request_region(dev, EC_HOST_CMD_REGION1,\r\nEC_HOST_CMD_REGION_SIZE, dev_name(dev))) {\r\ndev_err(dev, "couldn't reserve region1\n");\r\nreturn -EBUSY;\r\n}\r\nec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\r\nif (!ec_dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ec_dev);\r\nec_dev->dev = dev;\r\nec_dev->phys_name = dev_name(dev);\r\nec_dev->cmd_xfer = cros_ec_cmd_xfer_lpc;\r\nec_dev->pkt_xfer = cros_ec_pkt_xfer_lpc;\r\nec_dev->cmd_readmem = cros_ec_lpc_readmem;\r\nec_dev->din_size = sizeof(struct ec_host_response) +\r\nsizeof(struct ec_response_get_protocol_info);\r\nec_dev->dout_size = sizeof(struct ec_host_request);\r\nret = cros_ec_register(ec_dev);\r\nif (ret) {\r\ndev_err(dev, "couldn't register ec_dev (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cros_ec_lpc_remove(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_device *ec_dev;\r\nec_dev = platform_get_drvdata(pdev);\r\ncros_ec_remove(ec_dev);\r\nreturn 0;\r\n}\r\nstatic int __init cros_ec_lpc_init(void)\r\n{\r\nint ret;\r\nif (!dmi_check_system(cros_ec_lpc_dmi_table)) {\r\npr_err(DRV_NAME ": unsupported system.\n");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&cros_ec_lpc_driver);\r\nif (ret) {\r\npr_err(DRV_NAME ": can't register driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = platform_device_register(&cros_ec_lpc_device);\r\nif (ret) {\r\npr_err(DRV_NAME ": can't register device: %d\n", ret);\r\nplatform_driver_unregister(&cros_ec_lpc_driver);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cros_ec_lpc_exit(void)\r\n{\r\nplatform_device_unregister(&cros_ec_lpc_device);\r\nplatform_driver_unregister(&cros_ec_lpc_driver);\r\n}
