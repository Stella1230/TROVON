static int lpass_platform_pcmops_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nint ret;\r\nsnd_soc_set_runtime_hwparams(substream, &lpass_platform_pcm_hardware);\r\nruntime->dma_bytes = lpass_platform_pcm_hardware.buffer_bytes_max;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\ndev_err(soc_runtime->dev, "%s() setting constraints failed: %d\n",\r\n__func__, ret);\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nsnd_pcm_format_t format = params_format(params);\r\nunsigned int channels = params_channels(params);\r\nunsigned int regval;\r\nint bitwidth;\r\nint ret, rdma_port = pcm_data->i2s_port + v->rdmactl_audif_start;\r\nbitwidth = snd_pcm_format_width(format);\r\nif (bitwidth < 0) {\r\ndev_err(soc_runtime->dev, "%s() invalid bit width given: %d\n",\r\n__func__, bitwidth);\r\nreturn bitwidth;\r\n}\r\nregval = LPAIF_RDMACTL_BURSTEN_INCR4 |\r\nLPAIF_RDMACTL_AUDINTF(rdma_port) |\r\nLPAIF_RDMACTL_FIFOWM_8;\r\nswitch (bitwidth) {\r\ncase 16:\r\nswitch (channels) {\r\ncase 1:\r\ncase 2:\r\nregval |= LPAIF_RDMACTL_WPSCNT_ONE;\r\nbreak;\r\ncase 4:\r\nregval |= LPAIF_RDMACTL_WPSCNT_TWO;\r\nbreak;\r\ncase 6:\r\nregval |= LPAIF_RDMACTL_WPSCNT_THREE;\r\nbreak;\r\ncase 8:\r\nregval |= LPAIF_RDMACTL_WPSCNT_FOUR;\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nswitch (channels) {\r\ncase 1:\r\nregval |= LPAIF_RDMACTL_WPSCNT_ONE;\r\nbreak;\r\ncase 2:\r\nregval |= LPAIF_RDMACTL_WPSCNT_TWO;\r\nbreak;\r\ncase 4:\r\nregval |= LPAIF_RDMACTL_WPSCNT_FOUR;\r\nbreak;\r\ncase 6:\r\nregval |= LPAIF_RDMACTL_WPSCNT_SIX;\r\nbreak;\r\ncase 8:\r\nregval |= LPAIF_RDMACTL_WPSCNT_EIGHT;\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(soc_runtime->dev, "%s() invalid PCM config given: bw=%d, ch=%u\n",\r\n__func__, bitwidth, channels);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, pcm_data->rdma_ch), regval);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, pcm_data->rdma_ch), 0);\r\nif (ret)\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int lpass_platform_pcmops_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret, ch = pcm_data->rdma_ch;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMABASE_REG(v, ch),\r\nruntime->dma_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmabase reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMABUFF_REG(v, ch),\r\n(snd_pcm_lib_buffer_bytes(substream) >> 2) - 1);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmabuff reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMAPER_REG(v, ch),\r\n(snd_pcm_lib_period_bytes(substream) >> 2) - 1);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmaper reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, ch),\r\nLPAIF_RDMACTL_ENABLE_MASK, LPAIF_RDMACTL_ENABLE_ON);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpass_platform_pcmops_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret, ch = pcm_data->rdma_ch;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch));\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch),\r\nLPAIF_IRQ_ALL(ch));\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, ch),\r\nLPAIF_RDMACTL_ENABLE_MASK,\r\nLPAIF_RDMACTL_ENABLE_ON);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, ch),\r\nLPAIF_RDMACTL_ENABLE_MASK,\r\nLPAIF_RDMACTL_ENABLE_OFF);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ALL(ch), 0);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t lpass_platform_pcmops_pointer(\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nunsigned int base_addr, curr_addr;\r\nint ret, ch = pcm_data->rdma_ch;\r\nret = regmap_read(drvdata->lpaif_map,\r\nLPAIF_RDMABASE_REG(v, ch), &base_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error reading from rdmabase reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(drvdata->lpaif_map,\r\nLPAIF_RDMACURR_REG(v, ch), &curr_addr);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error reading from rdmacurr reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn bytes_to_frames(substream->runtime, curr_addr - base_addr);\r\n}\r\nstatic int lpass_platform_pcmops_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_coherent(substream->pcm->card->dev, vma,\r\nruntime->dma_area, runtime->dma_addr,\r\nruntime->dma_bytes);\r\n}\r\nstatic irqreturn_t lpass_dma_interrupt_handler(\r\nstruct snd_pcm_substream *substream,\r\nstruct lpass_data *drvdata,\r\nint chan, u32 interrupts)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_variant *v = drvdata->variant;\r\nirqreturn_t ret = IRQ_NONE;\r\nint rv;\r\nif (interrupts & LPAIF_IRQ_PER(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_PER(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\nsnd_pcm_period_elapsed(substream);\r\nret = IRQ_HANDLED;\r\n}\r\nif (interrupts & LPAIF_IRQ_XRUN(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_XRUN(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\ndev_warn(soc_runtime->dev, "%s() xrun warning\n", __func__);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nret = IRQ_HANDLED;\r\n}\r\nif (interrupts & LPAIF_IRQ_ERR(chan)) {\r\nrv = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST),\r\nLPAIF_IRQ_ERR(chan));\r\nif (rv) {\r\ndev_err(soc_runtime->dev, "%s() error writing to irqclear reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\ndev_err(soc_runtime->dev, "%s() bus access error\n", __func__);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t lpass_platform_lpaif_irq(int irq, void *data)\r\n{\r\nstruct lpass_data *drvdata = data;\r\nstruct lpass_variant *v = drvdata->variant;\r\nunsigned int irqs;\r\nint rv, chan;\r\nrv = regmap_read(drvdata->lpaif_map,\r\nLPAIF_IRQSTAT_REG(v, LPAIF_IRQ_PORT_HOST), &irqs);\r\nif (rv) {\r\npr_err("%s() error reading from irqstat reg: %d\n",\r\n__func__, rv);\r\nreturn IRQ_NONE;\r\n}\r\nfor (chan = 0; chan < LPASS_MAX_DMA_CHANNELS; chan++) {\r\nif (irqs & LPAIF_IRQ_ALL(chan) && drvdata->substream[chan]) {\r\nrv = lpass_dma_interrupt_handler(\r\ndrvdata->substream[chan],\r\ndrvdata, chan, irqs);\r\nif (rv != IRQ_HANDLED)\r\nreturn rv;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpass_platform_alloc_buffer(struct snd_pcm_substream *substream,\r\nstruct snd_soc_pcm_runtime *soc_runtime)\r\n{\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = lpass_platform_pcm_hardware.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = soc_runtime->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_coherent(soc_runtime->dev, size, &buf->addr,\r\nGFP_KERNEL);\r\nif (!buf->area) {\r\ndev_err(soc_runtime->dev, "%s: Could not allocate DMA buffer\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void lpass_platform_free_buffer(struct snd_pcm_substream *substream,\r\nstruct snd_soc_pcm_runtime *soc_runtime)\r\n{\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nif (buf->area) {\r\ndma_free_coherent(soc_runtime->dev, buf->bytes, buf->area,\r\nbuf->addr);\r\n}\r\nbuf->area = NULL;\r\n}\r\nstatic int lpass_platform_pcm_new(struct snd_soc_pcm_runtime *soc_runtime)\r\n{\r\nstruct snd_pcm *pcm = soc_runtime->pcm;\r\nstruct snd_pcm_substream *substream =\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret;\r\nstruct lpass_pcm_data *data;\r\ndata = devm_kzalloc(soc_runtime->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (v->alloc_dma_channel)\r\ndata->rdma_ch = v->alloc_dma_channel(drvdata);\r\nif (IS_ERR_VALUE(data->rdma_ch))\r\nreturn data->rdma_ch;\r\ndrvdata->substream[data->rdma_ch] = substream;\r\ndata->i2s_port = cpu_dai->driver->id;\r\nsnd_soc_pcm_set_drvdata(soc_runtime, data);\r\nsoc_runtime->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nsoc_runtime->dev->dma_mask = &soc_runtime->dev->coherent_dma_mask;\r\nret = lpass_platform_alloc_buffer(substream, soc_runtime);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_RDMACTL_REG(v, data->rdma_ch), 0);\r\nif (ret) {\r\ndev_err(soc_runtime->dev, "%s() error writing to rdmactl reg: %d\n",\r\n__func__, ret);\r\ngoto err_buf;\r\n}\r\nreturn 0;\r\nerr_buf:\r\nlpass_platform_free_buffer(substream, soc_runtime);\r\nreturn ret;\r\n}\r\nstatic void lpass_platform_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream =\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct lpass_data *drvdata =\r\nsnd_soc_platform_get_drvdata(soc_runtime->platform);\r\nstruct lpass_pcm_data *data = snd_soc_pcm_get_drvdata(soc_runtime);\r\nstruct lpass_variant *v = drvdata->variant;\r\ndrvdata->substream[data->rdma_ch] = NULL;\r\nif (v->free_dma_channel)\r\nv->free_dma_channel(drvdata, data->rdma_ch);\r\nlpass_platform_free_buffer(substream, soc_runtime);\r\n}\r\nint asoc_qcom_lpass_platform_register(struct platform_device *pdev)\r\n{\r\nstruct lpass_data *drvdata = platform_get_drvdata(pdev);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint ret;\r\ndrvdata->lpaif_irq = platform_get_irq_byname(pdev, "lpass-irq-lpaif");\r\nif (drvdata->lpaif_irq < 0) {\r\ndev_err(&pdev->dev, "%s() error getting irq handle: %d\n",\r\n__func__, drvdata->lpaif_irq);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST), 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error writing to irqen reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, drvdata->lpaif_irq,\r\nlpass_platform_lpaif_irq, IRQF_TRIGGER_RISING,\r\n"lpass-irq-lpaif", drvdata);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() irq request failed: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn devm_snd_soc_register_platform(&pdev->dev,\r\n&lpass_platform_driver);\r\n}
