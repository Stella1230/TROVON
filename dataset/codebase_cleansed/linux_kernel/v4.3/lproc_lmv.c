static ssize_t numobd_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct lmv_desc *desc;\r\ndesc = &dev->u.lmv.desc;\r\nreturn sprintf(buf, "%u\n", desc->ld_tgt_count);\r\n}\r\nstatic enum placement_policy placement_name2policy(char *name, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < PLACEMENT_MAX_POLICY; i++) {\r\nif (!strncmp(placement_name[i], name, len))\r\nreturn i;\r\n}\r\nreturn PLACEMENT_INVAL_POLICY;\r\n}\r\nstatic const char *placement_policy2name(enum placement_policy placement)\r\n{\r\nLASSERT(placement < PLACEMENT_MAX_POLICY);\r\nreturn placement_name[placement];\r\n}\r\nstatic ssize_t placement_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct lmv_obd *lmv;\r\nlmv = &dev->u.lmv;\r\nreturn sprintf(buf, "%s\n", placement_policy2name(lmv->lmv_placement));\r\n}\r\nstatic ssize_t placement_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nchar dummy[MAX_POLICY_STRING_SIZE + 1];\r\nenum placement_policy policy;\r\nstruct lmv_obd *lmv = &dev->u.lmv;\r\nmemcpy(dummy, buffer, MAX_POLICY_STRING_SIZE);\r\nif (count > MAX_POLICY_STRING_SIZE)\r\ncount = MAX_POLICY_STRING_SIZE;\r\nif (dummy[count - 1] == '\n')\r\ncount--;\r\ndummy[count] = '\0';\r\npolicy = placement_name2policy(dummy, count);\r\nif (policy != PLACEMENT_INVAL_POLICY) {\r\nspin_lock(&lmv->lmv_lock);\r\nlmv->lmv_placement = policy;\r\nspin_unlock(&lmv->lmv_lock);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t activeobd_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct lmv_desc *desc;\r\ndesc = &dev->u.lmv.desc;\r\nreturn sprintf(buf, "%u\n", desc->ld_active_tgt_count);\r\n}\r\nstatic int lmv_desc_uuid_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = (struct obd_device *)m->private;\r\nstruct lmv_obd *lmv;\r\nLASSERT(dev != NULL);\r\nlmv = &dev->u.lmv;\r\nseq_printf(m, "%s\n", lmv->desc.ld_uuid.uuid);\r\nreturn 0;\r\n}\r\nstatic void *lmv_tgt_seq_start(struct seq_file *p, loff_t *pos)\r\n{\r\nstruct obd_device *dev = p->private;\r\nstruct lmv_obd *lmv = &dev->u.lmv;\r\nreturn (*pos >= lmv->desc.ld_tgt_count) ? NULL : lmv->tgts[*pos];\r\n}\r\nstatic void lmv_tgt_seq_stop(struct seq_file *p, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic void *lmv_tgt_seq_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nstruct obd_device *dev = p->private;\r\nstruct lmv_obd *lmv = &dev->u.lmv;\r\n++*pos;\r\nreturn (*pos >= lmv->desc.ld_tgt_count) ? NULL : lmv->tgts[*pos];\r\n}\r\nstatic int lmv_tgt_seq_show(struct seq_file *p, void *v)\r\n{\r\nstruct lmv_tgt_desc *tgt = v;\r\nif (tgt == NULL)\r\nreturn 0;\r\nseq_printf(p, "%d: %s %sACTIVE\n",\r\ntgt->ltd_idx, tgt->ltd_uuid.uuid,\r\ntgt->ltd_active ? "" : "IN");\r\nreturn 0;\r\n}\r\nstatic int lmv_target_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint rc;\r\nrc = seq_open(file, &lmv_tgt_sops);\r\nif (rc)\r\nreturn rc;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nvoid lprocfs_lmv_init_vars(struct lprocfs_static_vars *lvars)\r\n{\r\nlvars->sysfs_vars = &lmv_attr_group;\r\nlvars->obd_vars = lprocfs_lmv_obd_vars;\r\n}
