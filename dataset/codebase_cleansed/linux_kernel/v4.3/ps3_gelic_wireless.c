static inline int wpa2_capable(void)\r\n{\r\nreturn 0 <= ps3_compare_firmware_version(2, 0, 0);\r\n}\r\nstatic inline int precise_ie(void)\r\n{\r\nreturn 0 <= ps3_compare_firmware_version(2, 2, 0);\r\n}\r\nstatic const char *cmdstr(enum gelic_eurus_command ix)\r\n{\r\nswitch (ix) {\r\ncase GELIC_EURUS_CMD_ASSOC:\r\nreturn "ASSOC";\r\ncase GELIC_EURUS_CMD_DISASSOC:\r\nreturn "DISASSOC";\r\ncase GELIC_EURUS_CMD_START_SCAN:\r\nreturn "SCAN";\r\ncase GELIC_EURUS_CMD_GET_SCAN:\r\nreturn "GET SCAN";\r\ncase GELIC_EURUS_CMD_SET_COMMON_CFG:\r\nreturn "SET_COMMON_CFG";\r\ncase GELIC_EURUS_CMD_GET_COMMON_CFG:\r\nreturn "GET_COMMON_CFG";\r\ncase GELIC_EURUS_CMD_SET_WEP_CFG:\r\nreturn "SET_WEP_CFG";\r\ncase GELIC_EURUS_CMD_GET_WEP_CFG:\r\nreturn "GET_WEP_CFG";\r\ncase GELIC_EURUS_CMD_SET_WPA_CFG:\r\nreturn "SET_WPA_CFG";\r\ncase GELIC_EURUS_CMD_GET_WPA_CFG:\r\nreturn "GET_WPA_CFG";\r\ncase GELIC_EURUS_CMD_GET_RSSI_CFG:\r\nreturn "GET_RSSI";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "";\r\n}\r\nstatic inline const char *cmdstr(enum gelic_eurus_command ix)\r\n{\r\nreturn "";\r\n}\r\nstatic void gelic_eurus_sync_cmd_worker(struct work_struct *work)\r\n{\r\nstruct gelic_eurus_cmd *cmd;\r\nstruct gelic_card *card;\r\nstruct gelic_wl_info *wl;\r\nu64 arg1, arg2;\r\npr_debug("%s: <-\n", __func__);\r\ncmd = container_of(work, struct gelic_eurus_cmd, work);\r\nBUG_ON(cmd_info[cmd->cmd].pre_arg &&\r\ncmd_info[cmd->cmd].post_arg);\r\nwl = cmd->wl;\r\ncard = port_to_card(wl_port(wl));\r\nif (cmd_info[cmd->cmd].pre_arg) {\r\narg1 = (cmd->buffer) ?\r\nps3_mm_phys_to_lpar(__pa(cmd->buffer)) :\r\n0;\r\narg2 = cmd->buf_size;\r\n} else {\r\narg1 = 0;\r\narg2 = 0;\r\n}\r\ninit_completion(&wl->cmd_done_intr);\r\npr_debug("%s: cmd='%s' start\n", __func__, cmdstr(cmd->cmd));\r\ncmd->status = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_POST_WLAN_CMD,\r\ncmd->cmd, arg1, arg2,\r\n&cmd->tag, &cmd->size);\r\nif (cmd->status) {\r\ncomplete(&cmd->done);\r\npr_info("%s: cmd issue failed\n", __func__);\r\nreturn;\r\n}\r\nwait_for_completion(&wl->cmd_done_intr);\r\nif (cmd_info[cmd->cmd].post_arg) {\r\narg1 = ps3_mm_phys_to_lpar(__pa(cmd->buffer));\r\narg2 = cmd->buf_size;\r\n} else {\r\narg1 = 0;\r\narg2 = 0;\r\n}\r\ncmd->status = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_WLAN_CMD_RESULT,\r\ncmd->tag, arg1, arg2,\r\n&cmd->cmd_status, &cmd->size);\r\n#ifdef DEBUG\r\nif (cmd->status || cmd->cmd_status) {\r\npr_debug("%s: cmd done tag=%#lx arg1=%#lx, arg2=%#lx\n", __func__,\r\ncmd->tag, arg1, arg2);\r\npr_debug("%s: cmd done status=%#x cmd_status=%#lx size=%#lx\n",\r\n__func__, cmd->status, cmd->cmd_status, cmd->size);\r\n}\r\n#endif\r\ncomplete(&cmd->done);\r\npr_debug("%s: cmd='%s' done\n", __func__, cmdstr(cmd->cmd));\r\n}\r\nstatic struct gelic_eurus_cmd *gelic_eurus_sync_cmd(struct gelic_wl_info *wl,\r\nunsigned int eurus_cmd,\r\nvoid *buffer,\r\nunsigned int buf_size)\r\n{\r\nstruct gelic_eurus_cmd *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn NULL;\r\ncmd->cmd = eurus_cmd;\r\ncmd->buffer = buffer;\r\ncmd->buf_size = buf_size;\r\ncmd->wl = wl;\r\nINIT_WORK(&cmd->work, gelic_eurus_sync_cmd_worker);\r\ninit_completion(&cmd->done);\r\nqueue_work(wl->eurus_cmd_queue, &cmd->work);\r\nwait_for_completion(&cmd->done);\r\nreturn cmd;\r\n}\r\nstatic u32 gelic_wl_get_link(struct net_device *netdev)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\r\nu32 ret;\r\npr_debug("%s: <-\n", __func__);\r\nmutex_lock(&wl->assoc_stat_lock);\r\nif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\r\nret = 1;\r\nelse\r\nret = 0;\r\nmutex_unlock(&wl->assoc_stat_lock);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void gelic_wl_send_iwap_event(struct gelic_wl_info *wl, u8 *bssid)\r\n{\r\nunion iwreq_data data;\r\nmemset(&data, 0, sizeof(data));\r\nif (bssid)\r\nmemcpy(data.ap_addr.sa_data, bssid, ETH_ALEN);\r\ndata.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(port_to_netdev(wl_port(wl)), SIOCGIWAP,\r\n&data, NULL);\r\n}\r\nstatic int gelic_wl_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *iwreq, char *extra)\r\n{\r\nstrcpy(iwreq->name, "IEEE 802.11bg");\r\nreturn 0;\r\n}\r\nstatic void gelic_wl_get_ch_info(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_card *card = port_to_card(wl_port(wl));\r\nu64 ch_info_raw, tmp;\r\nint status;\r\nif (!test_and_set_bit(GELIC_WL_STAT_CH_INFO, &wl->stat)) {\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_CHANNEL, 0, 0, 0,\r\n&ch_info_raw,\r\n&tmp);\r\nif (status) {\r\nif (status != LV1_NO_ENTRY)\r\npr_info("%s: available ch unknown\n", __func__);\r\nwl->ch_info = 0x07ff;\r\n} else\r\nwl->ch_info = ch_info_raw >> 48;\r\n}\r\n}\r\nstatic int gelic_wl_get_range(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *iwreq, char *extra)\r\n{\r\nstruct iw_point *point = &iwreq->data;\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\r\nunsigned int i, chs;\r\npr_debug("%s: <-\n", __func__);\r\npoint->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 22;\r\ngelic_wl_get_ch_info(wl);\r\nfor (i = 0, chs = 0;\r\ni < NUM_CHANNELS && chs < IW_MAX_FREQUENCIES; i++)\r\nif (wl->ch_info & (1 << i)) {\r\nrange->freq[chs].i = i + 1;\r\nrange->freq[chs].m = channel_freq[i];\r\nrange->freq[chs].e = 6;\r\nchs++;\r\n}\r\nrange->num_frequency = chs;\r\nrange->old_num_frequency = chs;\r\nrange->num_channels = chs;\r\nrange->old_num_channels = chs;\r\nfor (i = 0; i < NUM_BITRATES; i++)\r\nrange->bitrate[i] = bitrate_list[i];\r\nrange->num_bitrates = i;\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 100;\r\nrange->avg_qual.qual = 50;\r\nrange->avg_qual.level = 50;\r\nrange->sensitivity = 0;\r\nIW_EVENT_CAPA_SET_KERNEL(range->event_capa);\r\nIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);\r\nIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);\r\nrange->enc_capa = IW_ENC_CAPA_WPA |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP |\r\nIW_ENC_CAPA_4WAY_HANDSHAKE;\r\nif (wpa2_capable())\r\nrange->enc_capa |= IW_ENC_CAPA_WPA2;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->encoding_size[2] = 32;\r\nrange->num_encoding_sizes = 3;\r\nrange->max_encoding_tokens = GELIC_WEP_KEYS;\r\nrange->scan_capa = IW_SCAN_CAPA_ESSID;\r\npr_debug("%s: ->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_set_scan(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct iw_scan_req *req;\r\nu8 *essid = NULL;\r\nsize_t essid_len = 0;\r\nif (wrqu->data.length == sizeof(struct iw_scan_req) &&\r\nwrqu->data.flags & IW_SCAN_THIS_ESSID) {\r\nreq = (struct iw_scan_req*)extra;\r\nessid = req->essid;\r\nessid_len = req->essid_len;\r\npr_debug("%s: ESSID scan =%s\n", __func__, essid);\r\n}\r\nreturn gelic_wl_start_scan(wl, 1, essid, essid_len);\r\n}\r\nstatic size_t gelic_wl_synthesize_ie(u8 *buf,\r\nstruct gelic_eurus_scan_info *scan)\r\n{\r\nconst u8 *oui_header;\r\nu8 *start = buf;\r\nint rsn;\r\nint ccmp;\r\npr_debug("%s: <- sec=%16x\n", __func__, scan->security);\r\nswitch (be16_to_cpu(scan->security) & GELIC_EURUS_SCAN_SEC_MASK) {\r\ncase GELIC_EURUS_SCAN_SEC_WPA:\r\nrsn = 0;\r\nbreak;\r\ncase GELIC_EURUS_SCAN_SEC_WPA2:\r\nrsn = 1;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (be16_to_cpu(scan->security) & GELIC_EURUS_SCAN_SEC_WPA_MASK) {\r\ncase GELIC_EURUS_SCAN_SEC_WPA_TKIP:\r\nccmp = 0;\r\nbreak;\r\ncase GELIC_EURUS_SCAN_SEC_WPA_AES:\r\nccmp = 1;\r\nbreak;\r\ndefault:\r\nif (rsn) {\r\nccmp = 1;\r\npr_info("%s: no cipher info. defaulted to CCMP\n",\r\n__func__);\r\n} else {\r\nccmp = 0;\r\npr_info("%s: no cipher info. defaulted to TKIP\n",\r\n__func__);\r\n}\r\n}\r\nif (rsn)\r\noui_header = rsn_oui;\r\nelse\r\noui_header = wpa_oui;\r\nif (rsn)\r\n*buf++ = WLAN_EID_RSN;\r\nelse\r\n*buf++ = WLAN_EID_VENDOR_SPECIFIC;\r\nbuf++;\r\nif (!rsn) {\r\nmemcpy(buf, wpa_oui, OUI_LEN);\r\nbuf += OUI_LEN;\r\n*buf++ = 0x01;\r\n}\r\n*buf++ = 0x01;\r\n*buf++ = 0x00;\r\nmemcpy(buf, oui_header, OUI_LEN);\r\nbuf += OUI_LEN;\r\nif (ccmp)\r\n*buf++ = 0x04;\r\nelse\r\n*buf++ = 0x02;\r\n*buf++ = 0x01;\r\n*buf++ = 0x00;\r\nmemcpy(buf, oui_header, OUI_LEN);\r\nbuf += OUI_LEN;\r\nif (ccmp)\r\n*buf++ = 0x04;\r\nelse\r\n*buf++ = 0x02;\r\n*buf++ = 0x01;\r\n*buf++ = 0x00;\r\nmemcpy(buf, oui_header, OUI_LEN);\r\nbuf += OUI_LEN;\r\n*buf++ = 0x02;\r\n*buf++ = 0x00;\r\n*buf++ = 0x00;\r\nstart[1] = (buf - start - 2);\r\npr_debug("%s: ->\n", __func__);\r\nreturn buf - start;\r\n}\r\nstatic void gelic_wl_parse_ie(u8 *data, size_t len,\r\nstruct ie_info *ie_info)\r\n{\r\nsize_t data_left = len;\r\nu8 *pos = data;\r\nu8 item_len;\r\nu8 item_id;\r\npr_debug("%s: data=%p len=%ld\n", __func__,\r\ndata, len);\r\nmemset(ie_info, 0, sizeof(struct ie_info));\r\nwhile (2 <= data_left) {\r\nitem_id = *pos++;\r\nitem_len = *pos++;\r\ndata_left -= 2;\r\nif (data_left < item_len)\r\nbreak;\r\nswitch (item_id) {\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif ((OUI_LEN + 1 <= item_len) &&\r\n!memcmp(pos, wpa_oui, OUI_LEN) &&\r\npos[OUI_LEN] == 0x01) {\r\nie_info->wpa.data = pos - 2;\r\nie_info->wpa.len = item_len + 2;\r\n}\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nie_info->rsn.data = pos - 2;\r\nie_info->rsn.len = item_len + 2;\r\nbreak;\r\ndefault:\r\npr_debug("%s: ignore %#x,%d\n", __func__,\r\nitem_id, item_len);\r\nbreak;\r\n}\r\npos += item_len;\r\ndata_left -= item_len;\r\n}\r\npr_debug("%s: wpa=%p,%d wpa2=%p,%d\n", __func__,\r\nie_info->wpa.data, ie_info->wpa.len,\r\nie_info->rsn.data, ie_info->rsn.len);\r\n}\r\nstatic char *gelic_wl_translate_scan(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nchar *ev,\r\nchar *stop,\r\nstruct gelic_wl_scan_info *network)\r\n{\r\nstruct iw_event iwe;\r\nstruct gelic_eurus_scan_info *scan = network->hwinfo;\r\nchar *tmp;\r\nu8 rate;\r\nunsigned int i, j, len;\r\nu8 buf[64];\r\npr_debug("%s: <-\n", __func__);\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, &scan->bssid[2], ETH_ALEN);\r\nev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\niwe.u.data.length = strnlen(scan->essid, 32);\r\nev = iwe_stream_add_point(info, ev, stop, &iwe, scan->essid);\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = be16_to_cpu(scan->channel);\r\niwe.u.freq.e = 0;\r\niwe.u.freq.i = 0;\r\nev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\ntmp = ev + iwe_stream_lcp_len(info);\r\ni = 0;\r\nj = 0;\r\npr_debug("%s: rates=%d rate=%d\n", __func__,\r\nnetwork->rate_len, network->rate_ext_len);\r\nwhile (i < network->rate_len) {\r\nif (j < network->rate_ext_len &&\r\n((scan->ext_rate[j] & 0x7f) < (scan->rate[i] & 0x7f)))\r\nrate = scan->ext_rate[j++] & 0x7f;\r\nelse\r\nrate = scan->rate[i++] & 0x7f;\r\niwe.u.bitrate.value = rate * 500000;\r\ntmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,\r\nIW_EV_PARAM_LEN);\r\n}\r\nwhile (j < network->rate_ext_len) {\r\niwe.u.bitrate.value = (scan->ext_rate[j++] & 0x7f) * 500000;\r\ntmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,\r\nIW_EV_PARAM_LEN);\r\n}\r\nif (iwe_stream_lcp_len(info) < (tmp - ev))\r\nev = tmp;\r\niwe.cmd = SIOCGIWENCODE;\r\nif (be16_to_cpu(scan->capability) & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\nev = iwe_stream_add_point(info, ev, stop, &iwe, scan->essid);\r\niwe.cmd = SIOCGIWMODE;\r\nif (be16_to_cpu(scan->capability) &\r\n(WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\r\nif (be16_to_cpu(scan->capability) & WLAN_CAPABILITY_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\nev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_UINT_LEN);\r\n}\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.updated = IW_QUAL_ALL_UPDATED |\r\nIW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;\r\niwe.u.qual.level = be16_to_cpu(scan->rssi);\r\niwe.u.qual.qual = be16_to_cpu(scan->rssi);\r\niwe.u.qual.noise = 0;\r\nev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_QUAL_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (be16_to_cpu(scan->size) <= sizeof(*scan)) {\r\nlen = gelic_wl_synthesize_ie(buf, scan);\r\nif (len) {\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = len;\r\nev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\r\n}\r\n} else {\r\nstruct ie_info ie_info;\r\nsize_t data_len;\r\ndata_len = be16_to_cpu(scan->size) - sizeof(*scan);\r\ngelic_wl_parse_ie(scan->elements, data_len, &ie_info);\r\nif (ie_info.wpa.len && (ie_info.wpa.len <= sizeof(buf))) {\r\nmemcpy(buf, ie_info.wpa.data, ie_info.wpa.len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = ie_info.wpa.len;\r\nev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\r\n}\r\nif (ie_info.rsn.len && (ie_info.rsn.len <= sizeof(buf))) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\nmemcpy(buf, ie_info.rsn.data, ie_info.rsn.len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = ie_info.rsn.len;\r\nev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\r\n}\r\n}\r\npr_debug("%s: ->\n", __func__);\r\nreturn ev;\r\n}\r\nstatic int gelic_wl_get_scan(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct gelic_wl_scan_info *scan_info;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nint ret = 0;\r\nunsigned long this_time = jiffies;\r\npr_debug("%s: <-\n", __func__);\r\nif (mutex_lock_interruptible(&wl->scan_lock))\r\nreturn -EAGAIN;\r\nswitch (wl->scan_stat) {\r\ncase GELIC_WL_SCAN_STAT_SCANNING:\r\nret = -EAGAIN;\r\ngoto out;\r\ncase GELIC_WL_SCAN_STAT_INIT:\r\nret = -ENODEV;\r\ngoto out;\r\ncase GELIC_WL_SCAN_STAT_GOT_LIST:\r\nbreak;\r\n}\r\nlist_for_each_entry(scan_info, &wl->network_list, list) {\r\nif (wl->scan_age == 0 ||\r\ntime_after(scan_info->last_scanned + wl->scan_age,\r\nthis_time))\r\nev = gelic_wl_translate_scan(netdev, info,\r\nev, stop,\r\nscan_info);\r\nelse\r\npr_debug("%s:entry too old\n", __func__);\r\nif (stop - ev <= IW_EV_ADDR_LEN) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\n}\r\nwrqu->data.length = ev - extra;\r\nwrqu->data.flags = 0;\r\nout:\r\nmutex_unlock(&wl->scan_lock);\r\npr_debug("%s: -> %d %d\n", __func__, ret, wrqu->data.length);\r\nreturn ret;\r\n}\r\nstatic void scan_list_dump(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_wl_scan_info *scan_info;\r\nint i;\r\ni = 0;\r\nlist_for_each_entry(scan_info, &wl->network_list, list) {\r\npr_debug("%s: item %d\n", __func__, i++);\r\npr_debug("valid=%d eurusindex=%d last=%lx\n",\r\nscan_info->valid, scan_info->eurus_index,\r\nscan_info->last_scanned);\r\npr_debug("r_len=%d r_ext_len=%d essid_len=%d\n",\r\nscan_info->rate_len, scan_info->rate_ext_len,\r\nscan_info->essid_len);\r\npr_debug("bssid=%pM\n", &scan_info->hwinfo->bssid[2]);\r\npr_debug("essid=%s\n", scan_info->hwinfo->essid);\r\n}\r\n}\r\nstatic int gelic_wl_set_auth(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct iw_param *param = &data->param;\r\nstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\r\nunsigned long irqflag;\r\nint ret = 0;\r\npr_debug("%s: <- %d\n", __func__, param->flags & IW_AUTH_INDEX);\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nif (param->value & IW_AUTH_WPA_VERSION_DISABLED) {\r\npr_debug("%s: NO WPA selected\n", __func__);\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_WEP;\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\r\n}\r\nif (param->value & IW_AUTH_WPA_VERSION_WPA) {\r\npr_debug("%s: WPA version 1 selected\n", __func__);\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_WPA;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_TKIP;\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_TKIP;\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\n}\r\nif (param->value & IW_AUTH_WPA_VERSION_WPA2) {\r\nif (!precise_ie())\r\npr_info("%s: WPA2 may not work\n", __func__);\r\nif (wpa2_capable()) {\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_WPA2;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_AES;\r\nwl->pairwise_cipher_method =\r\nGELIC_WL_CIPHER_AES;\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\n} else\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nif (param->value &\r\n(IW_AUTH_CIPHER_WEP104 | IW_AUTH_CIPHER_WEP40)) {\r\npr_debug("%s: WEP selected\n", __func__);\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_TKIP) {\r\npr_debug("%s: TKIP selected\n", __func__);\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_TKIP;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_CCMP) {\r\npr_debug("%s: CCMP selected\n", __func__);\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_AES;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_NONE) {\r\npr_debug("%s: no auth selected\n", __func__);\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\r\n}\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nif (param->value &\r\n(IW_AUTH_CIPHER_WEP104 | IW_AUTH_CIPHER_WEP40)) {\r\npr_debug("%s: WEP selected\n", __func__);\r\nwl->group_cipher_method = GELIC_WL_CIPHER_WEP;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_TKIP) {\r\npr_debug("%s: TKIP selected\n", __func__);\r\nwl->group_cipher_method = GELIC_WL_CIPHER_TKIP;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_CCMP) {\r\npr_debug("%s: CCMP selected\n", __func__);\r\nwl->group_cipher_method = GELIC_WL_CIPHER_AES;\r\n}\r\nif (param->value & IW_AUTH_CIPHER_NONE) {\r\npr_debug("%s: no auth selected\n", __func__);\r\nwl->group_cipher_method = GELIC_WL_CIPHER_NONE;\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (param->value & IW_AUTH_ALG_SHARED_KEY) {\r\npr_debug("%s: shared key specified\n", __func__);\r\nwl->auth_method = GELIC_EURUS_AUTH_SHARED;\r\n} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\npr_debug("%s: open system specified\n", __func__);\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (param->value) {\r\npr_debug("%s: WPA enabled\n", __func__);\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_WPA;\r\n} else {\r\npr_debug("%s: WPA disabled\n", __func__);\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\r\n}\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nif (param->value & IW_AUTH_KEY_MGMT_PSK)\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!ret)\r\nset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: -> %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_get_auth(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *iwreq, char *extra)\r\n{\r\nstruct iw_param *param = &iwreq->param;\r\nstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\r\nunsigned long irqflag;\r\nint ret = 0;\r\npr_debug("%s: <- %d\n", __func__, param->flags & IW_AUTH_INDEX);\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nswitch (wl->wpa_level) {\r\ncase GELIC_WL_WPA_LEVEL_WPA:\r\nparam->value |= IW_AUTH_WPA_VERSION_WPA;\r\nbreak;\r\ncase GELIC_WL_WPA_LEVEL_WPA2:\r\nparam->value |= IW_AUTH_WPA_VERSION_WPA2;\r\nbreak;\r\ndefault:\r\nparam->value |= IW_AUTH_WPA_VERSION_DISABLED;\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (wl->auth_method == GELIC_EURUS_AUTH_SHARED)\r\nparam->value = IW_AUTH_ALG_SHARED_KEY;\r\nelse if (wl->auth_method == GELIC_EURUS_AUTH_OPEN)\r\nparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nswitch (wl->wpa_level) {\r\ncase GELIC_WL_WPA_LEVEL_WPA:\r\ncase GELIC_WL_WPA_LEVEL_WPA2:\r\nparam->value = 1;\r\nbreak;\r\ndefault:\r\nparam->value = 0;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: -> %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_set_essid(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nunsigned long irqflag;\r\npr_debug("%s: <- l=%d f=%d\n", __func__,\r\ndata->essid.length, data->essid.flags);\r\nif (IW_ESSID_MAX_SIZE < data->essid.length)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (data->essid.flags) {\r\nwl->essid_len = data->essid.length;\r\nmemcpy(wl->essid, extra, wl->essid_len);\r\npr_debug("%s: essid = '%s'\n", __func__, extra);\r\nset_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat);\r\n} else {\r\npr_debug("%s: ESSID any\n", __func__);\r\nclear_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat);\r\n}\r\nset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\ngelic_wl_try_associate(netdev);\r\npr_debug("%s: ->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_get_essid(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nunsigned long irqflag;\r\npr_debug("%s: <-\n", __func__);\r\nmutex_lock(&wl->assoc_stat_lock);\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat) ||\r\nwl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED) {\r\nmemcpy(extra, wl->essid, wl->essid_len);\r\ndata->essid.length = wl->essid_len;\r\ndata->essid.flags = 1;\r\n} else\r\ndata->essid.flags = 0;\r\nmutex_unlock(&wl->assoc_stat_lock);\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: -> len=%d\n", __func__, data->essid.length);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_set_encode(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct iw_point *enc = &data->encoding;\r\n__u16 flags;\r\nunsigned long irqflag;\r\nint key_index, index_specified;\r\nint ret = 0;\r\npr_debug("%s: <-\n", __func__);\r\nflags = enc->flags & IW_ENCODE_FLAGS;\r\nkey_index = enc->flags & IW_ENCODE_INDEX;\r\npr_debug("%s: key_index = %d\n", __func__, key_index);\r\npr_debug("%s: key_len = %d\n", __func__, enc->length);\r\npr_debug("%s: flag=%x\n", __func__, enc->flags & IW_ENCODE_FLAGS);\r\nif (GELIC_WEP_KEYS < key_index)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (key_index) {\r\nindex_specified = 1;\r\nkey_index--;\r\n} else {\r\nindex_specified = 0;\r\nkey_index = wl->current_key;\r\n}\r\nif (flags & IW_ENCODE_NOKEY) {\r\nif (!flags && index_specified) {\r\nwl->current_key = key_index;\r\ngoto done;\r\n}\r\nif (flags & IW_ENCODE_DISABLED) {\r\nif (!index_specified) {\r\nwl->group_cipher_method = GELIC_WL_CIPHER_NONE;\r\nwl->pairwise_cipher_method =\r\nGELIC_WL_CIPHER_NONE;\r\nwl->key_enabled = 0;\r\n} else\r\nclear_bit(key_index, &wl->key_enabled);\r\n}\r\nif (flags & IW_ENCODE_OPEN)\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\nif (flags & IW_ENCODE_RESTRICTED) {\r\npr_info("%s: shared key mode enabled\n", __func__);\r\nwl->auth_method = GELIC_EURUS_AUTH_SHARED;\r\n}\r\n} else {\r\nif (IW_ENCODING_TOKEN_MAX < enc->length) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nwl->key_len[key_index] = enc->length;\r\nmemcpy(wl->key[key_index], extra, enc->length);\r\nset_bit(key_index, &wl->key_enabled);\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_WEP;\r\n}\r\nset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\r\ndone:\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_get_encode(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct iw_point *enc = &data->encoding;\r\nunsigned long irqflag;\r\nunsigned int key_index, index_specified;\r\nint ret = 0;\r\npr_debug("%s: <-\n", __func__);\r\nkey_index = enc->flags & IW_ENCODE_INDEX;\r\npr_debug("%s: flag=%#x point=%p len=%d extra=%p\n", __func__,\r\nenc->flags, enc->pointer, enc->length, extra);\r\nif (GELIC_WEP_KEYS < key_index)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (key_index) {\r\nindex_specified = 1;\r\nkey_index--;\r\n} else {\r\nindex_specified = 0;\r\nkey_index = wl->current_key;\r\n}\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\r\nswitch (wl->auth_method) {\r\ncase GELIC_EURUS_AUTH_OPEN:\r\nenc->flags = IW_ENCODE_OPEN;\r\nbreak;\r\ncase GELIC_EURUS_AUTH_SHARED:\r\nenc->flags = IW_ENCODE_RESTRICTED;\r\nbreak;\r\n}\r\n} else\r\nenc->flags = IW_ENCODE_DISABLED;\r\nif (test_bit(key_index, &wl->key_enabled)) {\r\nif (enc->length < wl->key_len[key_index]) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nenc->length = wl->key_len[key_index];\r\nmemcpy(extra, wl->key[key_index], wl->key_len[key_index]);\r\n} else {\r\nenc->length = 0;\r\nenc->flags |= IW_ENCODE_NOKEY;\r\n}\r\nenc->flags |= key_index + 1;\r\npr_debug("%s: -> flag=%x len=%d\n", __func__,\r\nenc->flags, enc->length);\r\ndone:\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_set_ap(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nunsigned long irqflag;\r\npr_debug("%s: <-\n", __func__);\r\nif (data->ap_addr.sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (is_valid_ether_addr(data->ap_addr.sa_data)) {\r\nmemcpy(wl->bssid, data->ap_addr.sa_data,\r\nETH_ALEN);\r\nset_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat);\r\nset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\r\npr_debug("%s: bss=%pM\n", __func__, wl->bssid);\r\n} else {\r\npr_debug("%s: clear bssid\n", __func__);\r\nclear_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat);\r\neth_zero_addr(wl->bssid);\r\n}\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: ->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_get_ap(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nunsigned long irqflag;\r\npr_debug("%s: <-\n", __func__);\r\nmutex_lock(&wl->assoc_stat_lock);\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED) {\r\ndata->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(data->ap_addr.sa_data, wl->active_bssid,\r\nETH_ALEN);\r\n} else\r\neth_zero_addr(data->ap_addr.sa_data);\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\nmutex_unlock(&wl->assoc_stat_lock);\r\npr_debug("%s: ->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_set_encodeext(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct iw_point *enc = &data->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\n__u16 alg;\r\n__u16 flags;\r\nunsigned long irqflag;\r\nint key_index;\r\nint ret = 0;\r\npr_debug("%s: <-\n", __func__);\r\nflags = enc->flags & IW_ENCODE_FLAGS;\r\nalg = ext->alg;\r\nkey_index = enc->flags & IW_ENCODE_INDEX;\r\npr_debug("%s: key_index = %d\n", __func__, key_index);\r\npr_debug("%s: key_len = %d\n", __func__, enc->length);\r\npr_debug("%s: flag=%x\n", __func__, enc->flags & IW_ENCODE_FLAGS);\r\npr_debug("%s: ext_flag=%x\n", __func__, ext->ext_flags);\r\npr_debug("%s: ext_key_len=%x\n", __func__, ext->key_len);\r\nif (GELIC_WEP_KEYS < key_index)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (key_index)\r\nkey_index--;\r\nelse\r\nkey_index = wl->current_key;\r\nif (!enc->length && (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)) {\r\npr_debug("%s: request to change default key to %d\n",\r\n__func__, key_index);\r\nwl->current_key = key_index;\r\ngoto done;\r\n}\r\nif (alg == IW_ENCODE_ALG_NONE || (flags & IW_ENCODE_DISABLED)) {\r\npr_debug("%s: alg disabled\n", __func__);\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_NONE;\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\n} else if (alg == IW_ENCODE_ALG_WEP) {\r\npr_debug("%s: WEP requested\n", __func__);\r\nif (flags & IW_ENCODE_OPEN) {\r\npr_debug("%s: open key mode\n", __func__);\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\n}\r\nif (flags & IW_ENCODE_RESTRICTED) {\r\npr_debug("%s: shared key mode\n", __func__);\r\nwl->auth_method = GELIC_EURUS_AUTH_SHARED;\r\n}\r\nif (IW_ENCODING_TOKEN_MAX < ext->key_len) {\r\npr_info("%s: key is too long %d\n", __func__,\r\next->key_len);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nwl->key_len[key_index] = ext->key_len;\r\nmemset(wl->key[key_index], 0, IW_ENCODING_TOKEN_MAX);\r\nmemcpy(wl->key[key_index], ext->key, ext->key_len);\r\nset_bit(key_index, &wl->key_enabled);\r\nset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\r\n} else if (alg == IW_ENCODE_ALG_PMK) {\r\nif (ext->key_len != WPA_PSK_LEN) {\r\npr_err("%s: PSK length wrong %d\n", __func__,\r\next->key_len);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmemset(wl->psk, 0, sizeof(wl->psk));\r\nmemcpy(wl->psk, ext->key, ext->key_len);\r\nwl->psk_len = ext->key_len;\r\nwl->psk_type = GELIC_EURUS_WPA_PSK_BIN;\r\nset_bit(GELIC_WL_STAT_WPA_PSK_SET, &wl->stat);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_get_encodeext(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct iw_point *enc = &data->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nunsigned long irqflag;\r\nint key_index;\r\nint ret = 0;\r\nint max_key_len;\r\npr_debug("%s: <-\n", __func__);\r\nmax_key_len = enc->length - sizeof(struct iw_encode_ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nkey_index = enc->flags & IW_ENCODE_INDEX;\r\npr_debug("%s: key_index = %d\n", __func__, key_index);\r\npr_debug("%s: key_len = %d\n", __func__, enc->length);\r\npr_debug("%s: flag=%x\n", __func__, enc->flags & IW_ENCODE_FLAGS);\r\nif (GELIC_WEP_KEYS < key_index)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (key_index)\r\nkey_index--;\r\nelse\r\nkey_index = wl->current_key;\r\nmemset(ext, 0, sizeof(struct iw_encode_ext));\r\nswitch (wl->group_cipher_method) {\r\ncase GELIC_WL_CIPHER_WEP:\r\next->alg = IW_ENCODE_ALG_WEP;\r\nenc->flags |= IW_ENCODE_ENABLED;\r\nbreak;\r\ncase GELIC_WL_CIPHER_TKIP:\r\next->alg = IW_ENCODE_ALG_TKIP;\r\nenc->flags |= IW_ENCODE_ENABLED;\r\nbreak;\r\ncase GELIC_WL_CIPHER_AES:\r\next->alg = IW_ENCODE_ALG_CCMP;\r\nenc->flags |= IW_ENCODE_ENABLED;\r\nbreak;\r\ncase GELIC_WL_CIPHER_NONE:\r\ndefault:\r\next->alg = IW_ENCODE_ALG_NONE;\r\nenc->flags |= IW_ENCODE_NOKEY;\r\nbreak;\r\n}\r\nif (!(enc->flags & IW_ENCODE_NOKEY)) {\r\nif (max_key_len < wl->key_len[key_index]) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nif (test_bit(key_index, &wl->key_enabled))\r\nmemcpy(ext->key, wl->key[key_index],\r\nwl->key_len[key_index]);\r\nelse\r\npr_debug("%s: disabled key requested ix=%d\n",\r\n__func__, key_index);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_set_mode(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\n__u32 mode = data->mode;\r\nint ret;\r\npr_debug("%s: <-\n", __func__);\r\nif (mode == IW_MODE_INFRA)\r\nret = 0;\r\nelse\r\nret = -EOPNOTSUPP;\r\npr_debug("%s: -> %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_get_mode(struct net_device *netdev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\n__u32 *mode = &data->mode;\r\npr_debug("%s: <-\n", __func__);\r\n*mode = IW_MODE_INFRA;\r\npr_debug("%s: ->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_get_nick(struct net_device *net_dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstrcpy(extra, "gelic_wl");\r\ndata->data.length = strlen(extra);\r\ndata->data.flags = 1;\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *gelic_wl_get_wireless_stats(\r\nstruct net_device *netdev)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nstruct gelic_eurus_cmd *cmd;\r\nstruct iw_statistics *is;\r\nstruct gelic_eurus_rssi_info *rssi;\r\nvoid *buf;\r\npr_debug("%s: <-\n", __func__);\r\nbuf = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nis = &wl->iwstat;\r\nmemset(is, 0, sizeof(*is));\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_GET_RSSI_CFG,\r\nbuf, sizeof(*rssi));\r\nif (cmd && !cmd->status && !cmd->cmd_status) {\r\nrssi = buf;\r\nis->qual.level = be16_to_cpu(rssi->rssi);\r\nis->qual.updated = IW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;\r\n} else\r\nis->qual.updated = IW_QUAL_ALL_INVALID;\r\nkfree(cmd);\r\nfree_page((unsigned long)buf);\r\npr_debug("%s: ->\n", __func__);\r\nreturn is;\r\n}\r\nstatic int gelic_wl_start_scan(struct gelic_wl_info *wl, int always_scan,\r\nu8 *essid, size_t essid_len)\r\n{\r\nstruct gelic_eurus_cmd *cmd;\r\nint ret = 0;\r\nvoid *buf = NULL;\r\nsize_t len;\r\npr_debug("%s: <- always=%d\n", __func__, always_scan);\r\nif (mutex_lock_interruptible(&wl->scan_lock))\r\nreturn -ERESTARTSYS;\r\nif (wl->scan_stat == GELIC_WL_SCAN_STAT_SCANNING) {\r\npr_debug("%s: scanning now\n", __func__);\r\ngoto out;\r\n}\r\ninit_completion(&wl->scan_done);\r\nif ((!essid_len && !always_scan)\r\n&& wl->scan_stat == GELIC_WL_SCAN_STAT_GOT_LIST) {\r\npr_debug("%s: already has the list\n", __func__);\r\ncomplete(&wl->scan_done);\r\ngoto out;\r\n}\r\nif (essid_len && essid) {\r\nbuf = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nlen = IW_ESSID_MAX_SIZE;\r\nmemset(buf, 0, len);\r\nmemcpy(buf, essid, essid_len);\r\npr_debug("%s: essid scan='%s'\n", __func__, (char *)buf);\r\n} else\r\nlen = 0;\r\nwl->scan_stat = GELIC_WL_SCAN_STAT_SCANNING;\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_START_SCAN,\r\nbuf, len);\r\nif (!cmd || cmd->status || cmd->cmd_status) {\r\nwl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\r\ncomplete(&wl->scan_done);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkfree(cmd);\r\nout:\r\nfree_page((unsigned long)buf);\r\nmutex_unlock(&wl->scan_lock);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void gelic_wl_scan_complete_event(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_eurus_cmd *cmd = NULL;\r\nstruct gelic_wl_scan_info *target, *tmp;\r\nstruct gelic_wl_scan_info *oldest = NULL;\r\nstruct gelic_eurus_scan_info *scan_info;\r\nunsigned int scan_info_size;\r\nunion iwreq_data data;\r\nunsigned long this_time = jiffies;\r\nunsigned int data_len, i, found, r;\r\nvoid *buf;\r\npr_debug("%s:start\n", __func__);\r\nmutex_lock(&wl->scan_lock);\r\nbuf = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buf) {\r\npr_info("%s: scan buffer alloc failed\n", __func__);\r\ngoto out;\r\n}\r\nif (wl->scan_stat != GELIC_WL_SCAN_STAT_SCANNING) {\r\npr_debug("%s: scan complete when stat != scanning(%d)\n",\r\n__func__, wl->scan_stat);\r\ngoto out;\r\n}\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_GET_SCAN,\r\nbuf, PAGE_SIZE);\r\nif (!cmd || cmd->status || cmd->cmd_status) {\r\nwl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\r\npr_info("%s:cmd failed\n", __func__);\r\nkfree(cmd);\r\ngoto out;\r\n}\r\ndata_len = cmd->size;\r\npr_debug("%s: data_len = %d\n", __func__, data_len);\r\nkfree(cmd);\r\nwl->scan_stat = GELIC_WL_SCAN_STAT_GOT_LIST;\r\nlist_for_each_entry_safe(target, tmp, &wl->network_list, list) {\r\ntarget->valid = 0;\r\nif (time_before(target->last_scanned + wl->scan_age,\r\nthis_time)) {\r\nkfree(target->hwinfo);\r\ntarget->hwinfo = NULL;\r\nlist_move_tail(&target->list, &wl->network_free_list);\r\n}\r\n}\r\nfor (i = 0, scan_info_size = 0, scan_info = buf;\r\nscan_info_size < data_len;\r\ni++, scan_info_size += be16_to_cpu(scan_info->size),\r\nscan_info = (void *)scan_info + be16_to_cpu(scan_info->size)) {\r\npr_debug("%s:size=%d bssid=%pM scan_info=%p\n", __func__,\r\nbe16_to_cpu(scan_info->size),\r\n&scan_info->bssid[2], scan_info);\r\nif (!be16_to_cpu(scan_info->channel) || !scan_info->rate[0]) {\r\npr_debug("%s: invalid scan info\n", __func__);\r\ncontinue;\r\n}\r\nfound = 0;\r\noldest = NULL;\r\nlist_for_each_entry(target, &wl->network_list, list) {\r\nif (ether_addr_equal(&target->hwinfo->bssid[2],\r\n&scan_info->bssid[2])) {\r\nfound = 1;\r\npr_debug("%s: same BBS found scanned list\n",\r\n__func__);\r\nbreak;\r\n}\r\nif (!oldest ||\r\n(target->last_scanned < oldest->last_scanned))\r\noldest = target;\r\n}\r\nif (!found) {\r\nif (list_empty(&wl->network_free_list)) {\r\ntarget = oldest;\r\n} else {\r\ntarget = list_entry(wl->network_free_list.next,\r\nstruct gelic_wl_scan_info,\r\nlist);\r\n}\r\n}\r\ntarget->last_scanned = this_time;\r\ntarget->valid = 1;\r\ntarget->eurus_index = i;\r\nkfree(target->hwinfo);\r\ntarget->hwinfo = kzalloc(be16_to_cpu(scan_info->size),\r\nGFP_KERNEL);\r\nif (!target->hwinfo)\r\ncontinue;\r\nmemcpy(target->hwinfo, scan_info, scan_info->size);\r\ntarget->essid_len = strnlen(scan_info->essid,\r\nsizeof(scan_info->essid));\r\ntarget->rate_len = 0;\r\nfor (r = 0; r < 12; r++)\r\nif (scan_info->rate[r])\r\ntarget->rate_len++;\r\nif (8 < target->rate_len)\r\npr_info("%s: AP returns %d rates\n", __func__,\r\ntarget->rate_len);\r\ntarget->rate_ext_len = 0;\r\nfor (r = 0; r < 16; r++)\r\nif (scan_info->ext_rate[r])\r\ntarget->rate_ext_len++;\r\nlist_move_tail(&target->list, &wl->network_list);\r\n}\r\nmemset(&data, 0, sizeof(data));\r\nwireless_send_event(port_to_netdev(wl_port(wl)), SIOCGIWSCAN, &data,\r\nNULL);\r\nout:\r\nfree_page((unsigned long)buf);\r\ncomplete(&wl->scan_done);\r\nmutex_unlock(&wl->scan_lock);\r\npr_debug("%s:end\n", __func__);\r\n}\r\nstatic void update_best(struct gelic_wl_scan_info **best,\r\nstruct gelic_wl_scan_info *candid,\r\nint *best_weight,\r\nint *weight)\r\n{\r\nif (*best_weight < ++(*weight)) {\r\n*best_weight = *weight;\r\n*best = candid;\r\n}\r\n}\r\nstatic\r\nstruct gelic_wl_scan_info *gelic_wl_find_best_bss(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_wl_scan_info *scan_info;\r\nstruct gelic_wl_scan_info *best_bss;\r\nint weight, best_weight;\r\nu16 security;\r\npr_debug("%s: <-\n", __func__);\r\nbest_bss = NULL;\r\nbest_weight = 0;\r\nlist_for_each_entry(scan_info, &wl->network_list, list) {\r\npr_debug("%s: station %p\n", __func__, scan_info);\r\nif (!scan_info->valid) {\r\npr_debug("%s: station invalid\n", __func__);\r\ncontinue;\r\n}\r\nif (test_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat)) {\r\nif (ether_addr_equal(&scan_info->hwinfo->bssid[2],\r\nwl->bssid)) {\r\nbest_bss = scan_info;\r\npr_debug("%s: bssid matched\n", __func__);\r\nbreak;\r\n} else {\r\npr_debug("%s: bssid unmached\n", __func__);\r\ncontinue;\r\n}\r\n}\r\nweight = 0;\r\nsecurity = be16_to_cpu(scan_info->hwinfo->security) &\r\nGELIC_EURUS_SCAN_SEC_MASK;\r\nif (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA2) {\r\nif (security == GELIC_EURUS_SCAN_SEC_WPA2)\r\nupdate_best(&best_bss, scan_info,\r\n&best_weight, &weight);\r\nelse\r\ncontinue;\r\n} else if (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA) {\r\nif (security == GELIC_EURUS_SCAN_SEC_WPA)\r\nupdate_best(&best_bss, scan_info,\r\n&best_weight, &weight);\r\nelse\r\ncontinue;\r\n} else if (wl->wpa_level == GELIC_WL_WPA_LEVEL_NONE &&\r\nwl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\r\nif (security == GELIC_EURUS_SCAN_SEC_WEP)\r\nupdate_best(&best_bss, scan_info,\r\n&best_weight, &weight);\r\nelse\r\ncontinue;\r\n}\r\nif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat)) {\r\nif ((scan_info->essid_len == wl->essid_len) &&\r\n!strncmp(wl->essid,\r\nscan_info->hwinfo->essid,\r\nscan_info->essid_len))\r\nupdate_best(&best_bss, scan_info,\r\n&best_weight, &weight);\r\nelse\r\ncontinue;\r\n}\r\n}\r\n#ifdef DEBUG\r\npr_debug("%s: -> bss=%p\n", __func__, best_bss);\r\nif (best_bss) {\r\npr_debug("%s:addr=%pM\n", __func__,\r\n&best_bss->hwinfo->bssid[2]);\r\n}\r\n#endif\r\nreturn best_bss;\r\n}\r\nstatic int gelic_wl_do_wep_setup(struct gelic_wl_info *wl)\r\n{\r\nunsigned int i;\r\nstruct gelic_eurus_wep_cfg *wep;\r\nstruct gelic_eurus_cmd *cmd;\r\nint wep104 = 0;\r\nint have_key = 0;\r\nint ret = 0;\r\npr_debug("%s: <-\n", __func__);\r\nwep = (struct gelic_eurus_wep_cfg *)__get_free_page(GFP_KERNEL);\r\nif (!wep)\r\nreturn -ENOMEM;\r\nmemset(wep, 0, sizeof(*wep));\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\r\npr_debug("%s: WEP mode\n", __func__);\r\nfor (i = 0; i < GELIC_WEP_KEYS; i++) {\r\nif (!test_bit(i, &wl->key_enabled))\r\ncontinue;\r\npr_debug("%s: key#%d enabled\n", __func__, i);\r\nhave_key = 1;\r\nif (wl->key_len[i] == 13)\r\nwep104 = 1;\r\nelse if (wl->key_len[i] != 5) {\r\npr_info("%s: wrong wep key[%d]=%d\n",\r\n__func__, i, wl->key_len[i]);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(wep->key[i], wl->key[i], wl->key_len[i]);\r\n}\r\nif (!have_key) {\r\npr_info("%s: all wep key disabled\n", __func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (wep104) {\r\npr_debug("%s: 104bit key\n", __func__);\r\nwep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_104BIT);\r\n} else {\r\npr_debug("%s: 40bit key\n", __func__);\r\nwep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_40BIT);\r\n}\r\n} else {\r\npr_debug("%s: NO encryption\n", __func__);\r\nwep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_NONE);\r\n}\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_WEP_CFG,\r\nwep, sizeof(*wep));\r\nif (!cmd)\r\nret = -ENOMEM;\r\nelse if (cmd->status || cmd->cmd_status)\r\nret = -ENXIO;\r\nkfree(cmd);\r\nout:\r\nfree_page((unsigned long)wep);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic const char *wpasecstr(enum gelic_eurus_wpa_security sec)\r\n{\r\nswitch (sec) {\r\ncase GELIC_EURUS_WPA_SEC_NONE:\r\nreturn "NONE";\r\ncase GELIC_EURUS_WPA_SEC_WPA_TKIP_TKIP:\r\nreturn "WPA_TKIP_TKIP";\r\ncase GELIC_EURUS_WPA_SEC_WPA_TKIP_AES:\r\nreturn "WPA_TKIP_AES";\r\ncase GELIC_EURUS_WPA_SEC_WPA_AES_AES:\r\nreturn "WPA_AES_AES";\r\ncase GELIC_EURUS_WPA_SEC_WPA2_TKIP_TKIP:\r\nreturn "WPA2_TKIP_TKIP";\r\ncase GELIC_EURUS_WPA_SEC_WPA2_TKIP_AES:\r\nreturn "WPA2_TKIP_AES";\r\ncase GELIC_EURUS_WPA_SEC_WPA2_AES_AES:\r\nreturn "WPA2_AES_AES";\r\n}\r\nreturn "";\r\n}\r\nstatic int gelic_wl_do_wpa_setup(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_eurus_wpa_cfg *wpa;\r\nstruct gelic_eurus_cmd *cmd;\r\nu16 security;\r\nint ret = 0;\r\npr_debug("%s: <-\n", __func__);\r\nwpa = (struct gelic_eurus_wpa_cfg *)__get_free_page(GFP_KERNEL);\r\nif (!wpa)\r\nreturn -ENOMEM;\r\nmemset(wpa, 0, sizeof(*wpa));\r\nif (!test_bit(GELIC_WL_STAT_WPA_PSK_SET, &wl->stat))\r\npr_info("%s: PSK not configured yet\n", __func__);\r\nmemcpy(wpa->psk, wl->psk, wl->psk_len);\r\nif (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA2) {\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_AES) {\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA2_AES_AES;\r\n} else {\r\nif (wl->pairwise_cipher_method == GELIC_WL_CIPHER_AES &&\r\nprecise_ie())\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA2_TKIP_AES;\r\nelse\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA2_TKIP_TKIP;\r\n}\r\n} else {\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_AES) {\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA_AES_AES;\r\n} else {\r\nif (wl->pairwise_cipher_method == GELIC_WL_CIPHER_AES &&\r\nprecise_ie())\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA_TKIP_AES;\r\nelse\r\nsecurity = GELIC_EURUS_WPA_SEC_WPA_TKIP_TKIP;\r\n}\r\n}\r\nwpa->security = cpu_to_be16(security);\r\nwpa->psk_type = cpu_to_be16(wl->psk_type);\r\n#ifdef DEBUG\r\npr_debug("%s: sec=%s psktype=%s\n", __func__,\r\nwpasecstr(wpa->security),\r\n(wpa->psk_type == GELIC_EURUS_WPA_PSK_BIN) ?\r\n"BIN" : "passphrase");\r\n#if 0\r\npr_debug("%s: psk=%s\n", __func__,\r\n(wpa->psk_type == GELIC_EURUS_WPA_PSK_BIN) ?\r\n"N/A" : wpa->psk);\r\n#endif\r\n#endif\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_WPA_CFG,\r\nwpa, sizeof(*wpa));\r\nif (!cmd)\r\nret = -ENOMEM;\r\nelse if (cmd->status || cmd->cmd_status)\r\nret = -ENXIO;\r\nkfree(cmd);\r\nfree_page((unsigned long)wpa);\r\npr_debug("%s: --> %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_associate_bss(struct gelic_wl_info *wl,\r\nstruct gelic_wl_scan_info *bss)\r\n{\r\nstruct gelic_eurus_cmd *cmd;\r\nstruct gelic_eurus_common_cfg *common;\r\nint ret = 0;\r\nunsigned long rc;\r\npr_debug("%s: <-\n", __func__);\r\ncommon = (struct gelic_eurus_common_cfg *)__get_free_page(GFP_KERNEL);\r\nif (!common)\r\nreturn -ENOMEM;\r\nmemset(common, 0, sizeof(*common));\r\ncommon->bss_type = cpu_to_be16(GELIC_EURUS_BSS_INFRA);\r\ncommon->op_mode = cpu_to_be16(GELIC_EURUS_OPMODE_11BG);\r\ncommon->scan_index = cpu_to_be16(bss->eurus_index);\r\nswitch (wl->auth_method) {\r\ncase GELIC_EURUS_AUTH_OPEN:\r\ncommon->auth_method = cpu_to_be16(GELIC_EURUS_AUTH_OPEN);\r\nbreak;\r\ncase GELIC_EURUS_AUTH_SHARED:\r\ncommon->auth_method = cpu_to_be16(GELIC_EURUS_AUTH_SHARED);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nscan_list_dump(wl);\r\n#endif\r\npr_debug("%s: common cfg index=%d bsstype=%d auth=%d\n", __func__,\r\nbe16_to_cpu(common->scan_index),\r\nbe16_to_cpu(common->bss_type),\r\nbe16_to_cpu(common->auth_method));\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_COMMON_CFG,\r\ncommon, sizeof(*common));\r\nif (!cmd || cmd->status || cmd->cmd_status) {\r\nret = -ENOMEM;\r\nkfree(cmd);\r\ngoto out;\r\n}\r\nkfree(cmd);\r\nswitch (wl->wpa_level) {\r\ncase GELIC_WL_WPA_LEVEL_NONE:\r\nret = gelic_wl_do_wep_setup(wl);\r\nbreak;\r\ncase GELIC_WL_WPA_LEVEL_WPA:\r\ncase GELIC_WL_WPA_LEVEL_WPA2:\r\nret = gelic_wl_do_wpa_setup(wl);\r\nbreak;\r\n}\r\nif (ret) {\r\npr_debug("%s: WEP/WPA setup failed %d\n", __func__,\r\nret);\r\nret = -EPERM;\r\ngelic_wl_send_iwap_event(wl, NULL);\r\ngoto out;\r\n}\r\ninit_completion(&wl->assoc_done);\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_ASSOCIATING;\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_ASSOC,\r\nNULL, 0);\r\nif (!cmd || cmd->status || cmd->cmd_status) {\r\npr_debug("%s: assoc request failed\n", __func__);\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\r\nkfree(cmd);\r\nret = -ENOMEM;\r\ngelic_wl_send_iwap_event(wl, NULL);\r\ngoto out;\r\n}\r\nkfree(cmd);\r\nrc = wait_for_completion_timeout(&wl->assoc_done, HZ * 4);\r\nif (!rc) {\r\npr_info("%s: connect timeout\n", __func__);\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC,\r\nNULL, 0);\r\nkfree(cmd);\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\r\ngelic_wl_send_iwap_event(wl, NULL);\r\nret = -ENXIO;\r\n} else {\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_ASSOCIATED;\r\nmemcpy(wl->active_bssid, &bss->hwinfo->bssid[2], ETH_ALEN);\r\ngelic_wl_send_iwap_event(wl, wl->active_bssid);\r\npr_info("%s: connected\n", __func__);\r\n}\r\nout:\r\nfree_page((unsigned long)common);\r\npr_debug("%s: ->\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void gelic_wl_connected_event(struct gelic_wl_info *wl,\r\nu64 event)\r\n{\r\nu64 desired_event = 0;\r\nswitch (wl->wpa_level) {\r\ncase GELIC_WL_WPA_LEVEL_NONE:\r\ndesired_event = GELIC_LV1_WL_EVENT_CONNECTED;\r\nbreak;\r\ncase GELIC_WL_WPA_LEVEL_WPA:\r\ncase GELIC_WL_WPA_LEVEL_WPA2:\r\ndesired_event = GELIC_LV1_WL_EVENT_WPA_CONNECTED;\r\nbreak;\r\n}\r\nif (desired_event == event) {\r\npr_debug("%s: completed\n", __func__);\r\ncomplete(&wl->assoc_done);\r\nnetif_carrier_on(port_to_netdev(wl_port(wl)));\r\n} else\r\npr_debug("%s: event %#llx under wpa\n",\r\n__func__, event);\r\n}\r\nstatic void gelic_wl_disconnect_event(struct gelic_wl_info *wl,\r\nu64 event)\r\n{\r\nstruct gelic_eurus_cmd *cmd;\r\nint lock;\r\nif (!mutex_trylock(&wl->assoc_stat_lock)) {\r\npr_debug("%s: already locked\n", __func__);\r\nlock = 0;\r\n} else {\r\npr_debug("%s: obtain lock\n", __func__);\r\nlock = 1;\r\n}\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC, NULL, 0);\r\nkfree(cmd);\r\nif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\r\ngelic_wl_send_iwap_event(wl, NULL);\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\r\nnetif_carrier_off(port_to_netdev(wl_port(wl)));\r\nif (lock)\r\nmutex_unlock(&wl->assoc_stat_lock);\r\n}\r\nstatic const char *eventstr(enum gelic_lv1_wl_event event)\r\n{\r\nstatic char buf[32];\r\nchar *ret;\r\nif (event & GELIC_LV1_WL_EVENT_DEVICE_READY)\r\nret = "EURUS_READY";\r\nelse if (event & GELIC_LV1_WL_EVENT_SCAN_COMPLETED)\r\nret = "SCAN_COMPLETED";\r\nelse if (event & GELIC_LV1_WL_EVENT_DEAUTH)\r\nret = "DEAUTH";\r\nelse if (event & GELIC_LV1_WL_EVENT_BEACON_LOST)\r\nret = "BEACON_LOST";\r\nelse if (event & GELIC_LV1_WL_EVENT_CONNECTED)\r\nret = "CONNECTED";\r\nelse if (event & GELIC_LV1_WL_EVENT_WPA_CONNECTED)\r\nret = "WPA_CONNECTED";\r\nelse if (event & GELIC_LV1_WL_EVENT_WPA_ERROR)\r\nret = "WPA_ERROR";\r\nelse {\r\nsprintf(buf, "Unknown(%#x)", event);\r\nret = buf;\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *eventstr(enum gelic_lv1_wl_event event)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void gelic_wl_event_worker(struct work_struct *work)\r\n{\r\nstruct gelic_wl_info *wl;\r\nstruct gelic_port *port;\r\nu64 event, tmp;\r\nint status;\r\npr_debug("%s:start\n", __func__);\r\nwl = container_of(work, struct gelic_wl_info, event_work.work);\r\nport = wl_port(wl);\r\nwhile (1) {\r\nstatus = lv1_net_control(bus_id(port->card), dev_id(port->card),\r\nGELIC_LV1_GET_WLAN_EVENT, 0, 0, 0,\r\n&event, &tmp);\r\nif (status) {\r\nif (status != LV1_NO_ENTRY)\r\npr_debug("%s:wlan event failed %d\n",\r\n__func__, status);\r\npr_debug("%s:end\n", __func__);\r\nreturn;\r\n}\r\npr_debug("%s: event=%s\n", __func__, eventstr(event));\r\nswitch (event) {\r\ncase GELIC_LV1_WL_EVENT_SCAN_COMPLETED:\r\ngelic_wl_scan_complete_event(wl);\r\nbreak;\r\ncase GELIC_LV1_WL_EVENT_BEACON_LOST:\r\ncase GELIC_LV1_WL_EVENT_DEAUTH:\r\ngelic_wl_disconnect_event(wl, event);\r\nbreak;\r\ncase GELIC_LV1_WL_EVENT_CONNECTED:\r\ncase GELIC_LV1_WL_EVENT_WPA_CONNECTED:\r\ngelic_wl_connected_event(wl, event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void gelic_wl_assoc_worker(struct work_struct *work)\r\n{\r\nstruct gelic_wl_info *wl;\r\nstruct gelic_wl_scan_info *best_bss;\r\nint ret;\r\nunsigned long irqflag;\r\nu8 *essid;\r\nsize_t essid_len;\r\nwl = container_of(work, struct gelic_wl_info, assoc_work.work);\r\nmutex_lock(&wl->assoc_stat_lock);\r\nif (wl->assoc_stat != GELIC_WL_ASSOC_STAT_DISCONN)\r\ngoto out;\r\nspin_lock_irqsave(&wl->lock, irqflag);\r\nif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat)) {\r\npr_debug("%s: assoc ESSID configured %s\n", __func__,\r\nwl->essid);\r\nessid = wl->essid;\r\nessid_len = wl->essid_len;\r\n} else {\r\nessid = NULL;\r\nessid_len = 0;\r\n}\r\nspin_unlock_irqrestore(&wl->lock, irqflag);\r\nret = gelic_wl_start_scan(wl, 0, essid, essid_len);\r\nif (ret == -ERESTARTSYS) {\r\npr_debug("%s: scan start failed association\n", __func__);\r\nschedule_delayed_work(&wl->assoc_work, HZ/10);\r\ngoto out;\r\n} else if (ret) {\r\npr_info("%s: scan prerequisite failed\n", __func__);\r\ngoto out;\r\n}\r\nwait_for_completion(&wl->scan_done);\r\npr_debug("%s: scan done\n", __func__);\r\nmutex_lock(&wl->scan_lock);\r\nif (wl->scan_stat != GELIC_WL_SCAN_STAT_GOT_LIST) {\r\ngelic_wl_send_iwap_event(wl, NULL);\r\npr_info("%s: no scan list. association failed\n", __func__);\r\ngoto scan_lock_out;\r\n}\r\nbest_bss = gelic_wl_find_best_bss(wl);\r\nif (!best_bss) {\r\ngelic_wl_send_iwap_event(wl, NULL);\r\npr_info("%s: no bss matched. association failed\n", __func__);\r\ngoto scan_lock_out;\r\n}\r\nret = gelic_wl_associate_bss(wl, best_bss);\r\nif (ret)\r\npr_info("%s: association failed %d\n", __func__, ret);\r\nscan_lock_out:\r\nmutex_unlock(&wl->scan_lock);\r\nout:\r\nmutex_unlock(&wl->assoc_stat_lock);\r\n}\r\nvoid gelic_wl_interrupt(struct net_device *netdev, u64 status)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nif (status & GELIC_CARD_WLAN_COMMAND_COMPLETED) {\r\npr_debug("%s:cmd complete\n", __func__);\r\ncomplete(&wl->cmd_done_intr);\r\n}\r\nif (status & GELIC_CARD_WLAN_EVENT_RECEIVED) {\r\npr_debug("%s:event received\n", __func__);\r\nqueue_delayed_work(wl->event_queue, &wl->event_work, 0);\r\n}\r\n}\r\nstatic struct net_device *gelic_wl_alloc(struct gelic_card *card)\r\n{\r\nstruct net_device *netdev;\r\nstruct gelic_port *port;\r\nstruct gelic_wl_info *wl;\r\nunsigned int i;\r\npr_debug("%s:start\n", __func__);\r\nnetdev = alloc_etherdev(sizeof(struct gelic_port) +\r\nsizeof(struct gelic_wl_info));\r\npr_debug("%s: netdev =%p card=%p\n", __func__, netdev, card);\r\nif (!netdev)\r\nreturn NULL;\r\nstrcpy(netdev->name, "wlan%d");\r\nport = netdev_priv(netdev);\r\nport->netdev = netdev;\r\nport->card = card;\r\nport->type = GELIC_PORT_WIRELESS;\r\nwl = port_wl(port);\r\npr_debug("%s: wl=%p port=%p\n", __func__, wl, port);\r\nwl->networks = kzalloc(sizeof(struct gelic_wl_scan_info) *\r\nGELIC_WL_BSS_MAX_ENT, GFP_KERNEL);\r\nif (!wl->networks)\r\ngoto fail_bss;\r\nwl->eurus_cmd_queue = create_singlethread_workqueue("gelic_cmd");\r\nif (!wl->eurus_cmd_queue)\r\ngoto fail_cmd_workqueue;\r\nwl->event_queue = create_singlethread_workqueue("gelic_event");\r\nif (!wl->event_queue)\r\ngoto fail_event_workqueue;\r\nINIT_LIST_HEAD(&wl->network_free_list);\r\nINIT_LIST_HEAD(&wl->network_list);\r\nfor (i = 0; i < GELIC_WL_BSS_MAX_ENT; i++)\r\nlist_add_tail(&wl->networks[i].list,\r\n&wl->network_free_list);\r\ninit_completion(&wl->cmd_done_intr);\r\nINIT_DELAYED_WORK(&wl->event_work, gelic_wl_event_worker);\r\nINIT_DELAYED_WORK(&wl->assoc_work, gelic_wl_assoc_worker);\r\nmutex_init(&wl->scan_lock);\r\nmutex_init(&wl->assoc_stat_lock);\r\ninit_completion(&wl->scan_done);\r\ncomplete(&wl->scan_done);\r\nspin_lock_init(&wl->lock);\r\nwl->scan_age = 5*HZ;\r\nBUILD_BUG_ON(PAGE_SIZE <\r\nsizeof(struct gelic_eurus_scan_info) *\r\nGELIC_EURUS_MAX_SCAN);\r\npr_debug("%s:end\n", __func__);\r\nreturn netdev;\r\nfail_event_workqueue:\r\ndestroy_workqueue(wl->eurus_cmd_queue);\r\nfail_cmd_workqueue:\r\nkfree(wl->networks);\r\nfail_bss:\r\nfree_netdev(netdev);\r\npr_debug("%s:end error\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic void gelic_wl_free(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_wl_scan_info *scan_info;\r\nunsigned int i;\r\npr_debug("%s: <-\n", __func__);\r\npr_debug("%s: destroy queues\n", __func__);\r\ndestroy_workqueue(wl->eurus_cmd_queue);\r\ndestroy_workqueue(wl->event_queue);\r\nscan_info = wl->networks;\r\nfor (i = 0; i < GELIC_WL_BSS_MAX_ENT; i++, scan_info++)\r\nkfree(scan_info->hwinfo);\r\nkfree(wl->networks);\r\nfree_netdev(port_to_netdev(wl_port(wl)));\r\npr_debug("%s: ->\n", __func__);\r\n}\r\nstatic int gelic_wl_try_associate(struct net_device *netdev)\r\n{\r\nstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\r\nint ret = -1;\r\nunsigned int i;\r\npr_debug("%s: <-\n", __func__);\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_NONE) {\r\nif (test_bit(GELIC_WL_STAT_CONFIGURED,\r\n&wl->stat))\r\ngoto do_associate;\r\nelse {\r\npr_debug("%s: no wep, not configured\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\r\nfor (i = 0; i < GELIC_WEP_KEYS; i++) {\r\nif (test_bit(i, &wl->key_enabled))\r\ngoto do_associate;\r\n}\r\npr_debug("%s: WEP, but no key specified\n", __func__);\r\nreturn ret;\r\n}\r\nif ((wl->group_cipher_method == GELIC_WL_CIPHER_TKIP) ||\r\n(wl->group_cipher_method == GELIC_WL_CIPHER_AES)) {\r\nif (test_bit(GELIC_WL_STAT_WPA_PSK_SET,\r\n&wl->stat))\r\ngoto do_associate;\r\nelse {\r\npr_debug("%s: AES/TKIP, but PSK not configured\n",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\ndo_associate:\r\nret = schedule_delayed_work(&wl->assoc_work, 0);\r\npr_debug("%s: start association work %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int gelic_wl_open(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\npr_debug("%s:->%p\n", __func__, netdev);\r\ngelic_card_up(card);\r\ngelic_wl_try_associate(netdev);\r\nnetif_start_queue(netdev);\r\npr_debug("%s:<-\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gelic_wl_reset_state(struct gelic_wl_info *wl)\r\n{\r\nstruct gelic_wl_scan_info *target;\r\nstruct gelic_wl_scan_info *tmp;\r\nlist_for_each_entry_safe(target, tmp, &wl->network_list, list) {\r\nlist_move_tail(&target->list, &wl->network_free_list);\r\n}\r\nwl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\r\nwl->auth_method = GELIC_EURUS_AUTH_OPEN;\r\nwl->group_cipher_method = GELIC_WL_CIPHER_NONE;\r\nwl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\r\nwl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\r\nwl->key_enabled = 0;\r\nwl->current_key = 0;\r\nwl->psk_type = GELIC_EURUS_WPA_PSK_PASSPHRASE;\r\nwl->psk_len = 0;\r\nwl->essid_len = 0;\r\nmemset(wl->essid, 0, sizeof(wl->essid));\r\nmemset(wl->bssid, 0, sizeof(wl->bssid));\r\nmemset(wl->active_bssid, 0, sizeof(wl->active_bssid));\r\nwl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\r\nmemset(&wl->iwstat, 0, sizeof(wl->iwstat));\r\nwl->stat = 0;\r\nreturn 0;\r\n}\r\nstatic void gelic_wl_disconnect(struct net_device *netdev)\r\n{\r\nstruct gelic_port *port = netdev_priv(netdev);\r\nstruct gelic_wl_info *wl = port_wl(port);\r\nstruct gelic_eurus_cmd *cmd;\r\nif (wl->scan_stat == GELIC_WL_SCAN_STAT_SCANNING)\r\nwait_for_completion_timeout(&wl->scan_done, HZ);\r\ncmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC, NULL, 0);\r\nkfree(cmd);\r\ngelic_wl_send_iwap_event(wl, NULL);\r\n}\r\nstatic int gelic_wl_stop(struct net_device *netdev)\r\n{\r\nstruct gelic_port *port = netdev_priv(netdev);\r\nstruct gelic_wl_info *wl = port_wl(port);\r\nstruct gelic_card *card = netdev_card(netdev);\r\npr_debug("%s:<-\n", __func__);\r\ncancel_delayed_work(&wl->assoc_work);\r\nif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\r\ngelic_wl_disconnect(netdev);\r\ngelic_wl_reset_state(wl);\r\nnetif_stop_queue(netdev);\r\ngelic_card_down(card);\r\npr_debug("%s:->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void gelic_wl_setup_netdev_ops(struct net_device *netdev)\r\n{\r\nstruct gelic_wl_info *wl;\r\nwl = port_wl(netdev_priv(netdev));\r\nBUG_ON(!wl);\r\nnetdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;\r\nnetdev->ethtool_ops = &gelic_wl_ethtool_ops;\r\nnetdev->netdev_ops = &gelic_wl_netdevice_ops;\r\nnetdev->wireless_data = &wl->wireless_data;\r\nnetdev->wireless_handlers = &gelic_wl_wext_handler_def;\r\n}\r\nint gelic_wl_driver_probe(struct gelic_card *card)\r\n{\r\nint ret;\r\nstruct net_device *netdev;\r\npr_debug("%s:start\n", __func__);\r\nif (ps3_compare_firmware_version(1, 6, 0) < 0)\r\nreturn 0;\r\nif (!card->vlan[GELIC_PORT_WIRELESS].tx)\r\nreturn 0;\r\nnetdev = gelic_wl_alloc(card);\r\nif (!netdev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(netdev, &card->dev->core);\r\ngelic_wl_setup_netdev_ops(netdev);\r\nret = gelic_net_setup_netdev(netdev, card);\r\nif (ret)\r\ngoto fail_setup;\r\ncard->netdev[GELIC_PORT_WIRELESS] = netdev;\r\ncard->irq_mask |= GELIC_CARD_WLAN_EVENT_RECEIVED |\r\nGELIC_CARD_WLAN_COMMAND_COMPLETED;\r\ngelic_card_set_irq_mask(card, GELIC_CARD_WLAN_EVENT_RECEIVED |\r\nGELIC_CARD_WLAN_COMMAND_COMPLETED);\r\npr_debug("%s:end\n", __func__);\r\nreturn 0;\r\nfail_setup:\r\ngelic_wl_free(port_wl(netdev_port(netdev)));\r\nreturn ret;\r\n}\r\nint gelic_wl_driver_remove(struct gelic_card *card)\r\n{\r\nstruct gelic_wl_info *wl;\r\nstruct net_device *netdev;\r\npr_debug("%s:start\n", __func__);\r\nif (ps3_compare_firmware_version(1, 6, 0) < 0)\r\nreturn 0;\r\nif (!card->vlan[GELIC_PORT_WIRELESS].tx)\r\nreturn 0;\r\nnetdev = card->netdev[GELIC_PORT_WIRELESS];\r\nwl = port_wl(netdev_priv(netdev));\r\nif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\r\ngelic_wl_disconnect(netdev);\r\ncomplete(&wl->cmd_done_intr);\r\ncancel_delayed_work(&wl->assoc_work);\r\ncancel_delayed_work(&wl->event_work);\r\nflush_workqueue(wl->eurus_cmd_queue);\r\nflush_workqueue(wl->event_queue);\r\nunregister_netdev(netdev);\r\npr_debug("%s: disable intr\n", __func__);\r\ncard->irq_mask &= ~(GELIC_CARD_WLAN_EVENT_RECEIVED |\r\nGELIC_CARD_WLAN_COMMAND_COMPLETED);\r\ngelic_wl_free(wl);\r\npr_debug("%s:end\n", __func__);\r\nreturn 0;\r\n}
