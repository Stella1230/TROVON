static int meson_get_bank(struct meson_domain *domain, unsigned int pin,\r\nstruct meson_bank **bank)\r\n{\r\nint i;\r\nfor (i = 0; i < domain->data->num_banks; i++) {\r\nif (pin >= domain->data->banks[i].first &&\r\npin <= domain->data->banks[i].last) {\r\n*bank = &domain->data->banks[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int meson_get_domain_and_bank(struct meson_pinctrl *pc, unsigned int pin,\r\nstruct meson_domain **domain,\r\nstruct meson_bank **bank)\r\n{\r\nstruct meson_domain *d;\r\nint i;\r\nfor (i = 0; i < pc->data->num_domains; i++) {\r\nd = &pc->domains[i];\r\nif (pin >= d->data->pin_base &&\r\npin < d->data->pin_base + d->data->num_pins) {\r\n*domain = d;\r\nreturn meson_get_bank(d, pin, bank);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void meson_calc_reg_and_bit(struct meson_bank *bank, unsigned int pin,\r\nenum meson_reg_type reg_type,\r\nunsigned int *reg, unsigned int *bit)\r\n{\r\nstruct meson_reg_desc *desc = &bank->regs[reg_type];\r\n*reg = desc->reg * 4;\r\n*bit = desc->bit + pin - bank->first;\r\n}\r\nstatic int meson_get_groups_count(struct pinctrl_dev *pcdev)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nreturn pc->data->num_groups;\r\n}\r\nstatic const char *meson_get_group_name(struct pinctrl_dev *pcdev,\r\nunsigned selector)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nreturn pc->data->groups[selector].name;\r\n}\r\nstatic int meson_get_group_pins(struct pinctrl_dev *pcdev, unsigned selector,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\n*pins = pc->data->groups[selector].pins;\r\n*num_pins = pc->data->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void meson_pin_dbg_show(struct pinctrl_dev *pcdev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pcdev->dev));\r\n}\r\nstatic void meson_pmx_disable_other_groups(struct meson_pinctrl *pc,\r\nunsigned int pin, int sel_group)\r\n{\r\nstruct meson_pmx_group *group;\r\nstruct meson_domain *domain;\r\nint i, j;\r\nfor (i = 0; i < pc->data->num_groups; i++) {\r\ngroup = &pc->data->groups[i];\r\nif (group->is_gpio || i == sel_group)\r\ncontinue;\r\nfor (j = 0; j < group->num_pins; j++) {\r\nif (group->pins[j] == pin) {\r\ndomain = &pc->domains[group->domain];\r\nregmap_update_bits(domain->reg_mux,\r\ngroup->reg * 4,\r\nBIT(group->bit), 0);\r\n}\r\n}\r\n}\r\n}\r\nstatic int meson_pmx_set_mux(struct pinctrl_dev *pcdev, unsigned func_num,\r\nunsigned group_num)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nstruct meson_pmx_func *func = &pc->data->funcs[func_num];\r\nstruct meson_pmx_group *group = &pc->data->groups[group_num];\r\nstruct meson_domain *domain = &pc->domains[group->domain];\r\nint i, ret = 0;\r\ndev_dbg(pc->dev, "enable function %s, group %s\n", func->name,\r\ngroup->name);\r\nfor (i = 0; i < group->num_pins; i++)\r\nmeson_pmx_disable_other_groups(pc, group->pins[i], group_num);\r\nif (func_num)\r\nret = regmap_update_bits(domain->reg_mux, group->reg * 4,\r\nBIT(group->bit), BIT(group->bit));\r\nreturn ret;\r\n}\r\nstatic int meson_pmx_request_gpio(struct pinctrl_dev *pcdev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nmeson_pmx_disable_other_groups(pc, range->pin_base + offset, -1);\r\nreturn 0;\r\n}\r\nstatic int meson_pmx_get_funcs_count(struct pinctrl_dev *pcdev)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nreturn pc->data->num_funcs;\r\n}\r\nstatic const char *meson_pmx_get_func_name(struct pinctrl_dev *pcdev,\r\nunsigned selector)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nreturn pc->data->funcs[selector].name;\r\n}\r\nstatic int meson_pmx_get_groups(struct pinctrl_dev *pcdev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\n*groups = pc->data->funcs[selector].groups;\r\n*num_groups = pc->data->funcs[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int meson_pinconf_set(struct pinctrl_dev *pcdev, unsigned int pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nstruct meson_domain *domain;\r\nstruct meson_bank *bank;\r\nenum pin_config_param param;\r\nunsigned int reg, bit;\r\nint i, ret;\r\nu16 arg;\r\nret = meson_get_domain_and_bank(pc, pin, &domain, &bank);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ndev_dbg(pc->dev, "pin %u: disable bias\n", pin);\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULL, &reg, &bit);\r\nret = regmap_update_bits(domain->reg_pull, reg,\r\nBIT(bit), 0);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ndev_dbg(pc->dev, "pin %u: enable pull-up\n", pin);\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULLEN,\r\n&reg, &bit);\r\nret = regmap_update_bits(domain->reg_pullen, reg,\r\nBIT(bit), BIT(bit));\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULL, &reg, &bit);\r\nret = regmap_update_bits(domain->reg_pull, reg,\r\nBIT(bit), BIT(bit));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ndev_dbg(pc->dev, "pin %u: enable pull-down\n", pin);\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULLEN,\r\n&reg, &bit);\r\nret = regmap_update_bits(domain->reg_pullen, reg,\r\nBIT(bit), BIT(bit));\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULL, &reg, &bit);\r\nret = regmap_update_bits(domain->reg_pull, reg,\r\nBIT(bit), 0);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int meson_pinconf_get_pull(struct meson_pinctrl *pc, unsigned int pin)\r\n{\r\nstruct meson_domain *domain;\r\nstruct meson_bank *bank;\r\nunsigned int reg, bit, val;\r\nint ret, conf;\r\nret = meson_get_domain_and_bank(pc, pin, &domain, &bank);\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULLEN, &reg, &bit);\r\nret = regmap_read(domain->reg_pullen, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nif (!(val & BIT(bit))) {\r\nconf = PIN_CONFIG_BIAS_DISABLE;\r\n} else {\r\nmeson_calc_reg_and_bit(bank, pin, REG_PULL, &reg, &bit);\r\nret = regmap_read(domain->reg_pull, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & BIT(bit))\r\nconf = PIN_CONFIG_BIAS_PULL_UP;\r\nelse\r\nconf = PIN_CONFIG_BIAS_PULL_DOWN;\r\n}\r\nreturn conf;\r\n}\r\nstatic int meson_pinconf_get(struct pinctrl_dev *pcdev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nu16 arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (meson_pinconf_get_pull(pc, pin) == param)\r\narg = 1;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\ndev_dbg(pc->dev, "pinconf for pin %u is %lu\n", pin, *config);\r\nreturn 0;\r\n}\r\nstatic int meson_pinconf_group_set(struct pinctrl_dev *pcdev,\r\nunsigned int num_group,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\r\nstruct meson_pmx_group *group = &pc->data->groups[num_group];\r\nint i;\r\ndev_dbg(pc->dev, "set pinconf for group %s\n", group->name);\r\nfor (i = 0; i < group->num_pins; i++) {\r\nmeson_pinconf_set(pcdev, group->pins[i], configs,\r\nnum_configs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int meson_pinconf_group_get(struct pinctrl_dev *pcdev,\r\nunsigned int group, unsigned long *config)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline struct meson_domain *to_meson_domain(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct meson_domain, chip);\r\n}\r\nstatic int meson_gpio_request(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + gpio);\r\n}\r\nstatic void meson_gpio_free(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct meson_domain *domain = to_meson_domain(chip);\r\npinctrl_free_gpio(domain->data->pin_base + gpio);\r\n}\r\nstatic int meson_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct meson_domain *domain = to_meson_domain(chip);\r\nunsigned int reg, bit, pin;\r\nstruct meson_bank *bank;\r\nint ret;\r\npin = domain->data->pin_base + gpio;\r\nret = meson_get_bank(domain, pin, &bank);\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_DIR, &reg, &bit);\r\nreturn regmap_update_bits(domain->reg_gpio, reg, BIT(bit), BIT(bit));\r\n}\r\nstatic int meson_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\r\nint value)\r\n{\r\nstruct meson_domain *domain = to_meson_domain(chip);\r\nunsigned int reg, bit, pin;\r\nstruct meson_bank *bank;\r\nint ret;\r\npin = domain->data->pin_base + gpio;\r\nret = meson_get_bank(domain, pin, &bank);\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_DIR, &reg, &bit);\r\nret = regmap_update_bits(domain->reg_gpio, reg, BIT(bit), 0);\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_OUT, &reg, &bit);\r\nreturn regmap_update_bits(domain->reg_gpio, reg, BIT(bit),\r\nvalue ? BIT(bit) : 0);\r\n}\r\nstatic void meson_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\r\n{\r\nstruct meson_domain *domain = to_meson_domain(chip);\r\nunsigned int reg, bit, pin;\r\nstruct meson_bank *bank;\r\nint ret;\r\npin = domain->data->pin_base + gpio;\r\nret = meson_get_bank(domain, pin, &bank);\r\nif (ret)\r\nreturn;\r\nmeson_calc_reg_and_bit(bank, pin, REG_OUT, &reg, &bit);\r\nregmap_update_bits(domain->reg_gpio, reg, BIT(bit),\r\nvalue ? BIT(bit) : 0);\r\n}\r\nstatic int meson_gpio_get(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct meson_domain *domain = to_meson_domain(chip);\r\nunsigned int reg, bit, val, pin;\r\nstruct meson_bank *bank;\r\nint ret;\r\npin = domain->data->pin_base + gpio;\r\nret = meson_get_bank(domain, pin, &bank);\r\nif (ret)\r\nreturn ret;\r\nmeson_calc_reg_and_bit(bank, pin, REG_IN, &reg, &bit);\r\nregmap_read(domain->reg_gpio, reg, &val);\r\nreturn !!(val & BIT(bit));\r\n}\r\nstatic int meson_gpiolib_register(struct meson_pinctrl *pc)\r\n{\r\nstruct meson_domain *domain;\r\nint i, ret;\r\nfor (i = 0; i < pc->data->num_domains; i++) {\r\ndomain = &pc->domains[i];\r\ndomain->chip.label = domain->data->name;\r\ndomain->chip.dev = pc->dev;\r\ndomain->chip.request = meson_gpio_request;\r\ndomain->chip.free = meson_gpio_free;\r\ndomain->chip.direction_input = meson_gpio_direction_input;\r\ndomain->chip.direction_output = meson_gpio_direction_output;\r\ndomain->chip.get = meson_gpio_get;\r\ndomain->chip.set = meson_gpio_set;\r\ndomain->chip.base = domain->data->pin_base;\r\ndomain->chip.ngpio = domain->data->num_pins;\r\ndomain->chip.can_sleep = false;\r\ndomain->chip.of_node = domain->of_node;\r\ndomain->chip.of_gpio_n_cells = 2;\r\nret = gpiochip_add(&domain->chip);\r\nif (ret) {\r\ndev_err(pc->dev, "can't add gpio chip %s\n",\r\ndomain->data->name);\r\ngoto fail;\r\n}\r\nret = gpiochip_add_pin_range(&domain->chip, dev_name(pc->dev),\r\n0, domain->data->pin_base,\r\ndomain->chip.ngpio);\r\nif (ret) {\r\ndev_err(pc->dev, "can't add pin range\n");\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--)\r\ngpiochip_remove(&pc->domains[i].chip);\r\nreturn ret;\r\n}\r\nstatic struct meson_domain_data *meson_get_domain_data(struct meson_pinctrl *pc,\r\nstruct device_node *np)\r\n{\r\nint i;\r\nfor (i = 0; i < pc->data->num_domains; i++) {\r\nif (!strcmp(np->name, pc->data->domain_data[i].name))\r\nreturn &pc->data->domain_data[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct regmap *meson_map_resource(struct meson_pinctrl *pc,\r\nstruct device_node *node, char *name)\r\n{\r\nstruct resource res;\r\nvoid __iomem *base;\r\nint i;\r\ni = of_property_match_string(node, "reg-names", name);\r\nif (of_address_to_resource(node, i, &res))\r\nreturn ERR_PTR(-ENOENT);\r\nbase = devm_ioremap_resource(pc->dev, &res);\r\nif (IS_ERR(base))\r\nreturn ERR_CAST(base);\r\nmeson_regmap_config.max_register = resource_size(&res) - 4;\r\nmeson_regmap_config.name = devm_kasprintf(pc->dev, GFP_KERNEL,\r\n"%s-%s", node->name,\r\nname);\r\nif (!meson_regmap_config.name)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn devm_regmap_init_mmio(pc->dev, base, &meson_regmap_config);\r\n}\r\nstatic int meson_pinctrl_parse_dt(struct meson_pinctrl *pc,\r\nstruct device_node *node)\r\n{\r\nstruct device_node *np;\r\nstruct meson_domain *domain;\r\nint i = 0, num_domains = 0;\r\nfor_each_child_of_node(node, np) {\r\nif (!of_find_property(np, "gpio-controller", NULL))\r\ncontinue;\r\nnum_domains++;\r\n}\r\nif (num_domains != pc->data->num_domains) {\r\ndev_err(pc->dev, "wrong number of subnodes\n");\r\nreturn -EINVAL;\r\n}\r\npc->domains = devm_kzalloc(pc->dev, num_domains *\r\nsizeof(struct meson_domain), GFP_KERNEL);\r\nif (!pc->domains)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(node, np) {\r\nif (!of_find_property(np, "gpio-controller", NULL))\r\ncontinue;\r\ndomain = &pc->domains[i];\r\ndomain->data = meson_get_domain_data(pc, np);\r\nif (!domain->data) {\r\ndev_err(pc->dev, "domain data not found for node %s\n",\r\nnp->name);\r\nreturn -ENODEV;\r\n}\r\ndomain->of_node = np;\r\ndomain->reg_mux = meson_map_resource(pc, np, "mux");\r\nif (IS_ERR(domain->reg_mux)) {\r\ndev_err(pc->dev, "mux registers not found\n");\r\nreturn PTR_ERR(domain->reg_mux);\r\n}\r\ndomain->reg_pull = meson_map_resource(pc, np, "pull");\r\nif (IS_ERR(domain->reg_pull)) {\r\ndev_err(pc->dev, "pull registers not found\n");\r\nreturn PTR_ERR(domain->reg_pull);\r\n}\r\ndomain->reg_pullen = meson_map_resource(pc, np, "pull-enable");\r\nif (IS_ERR(domain->reg_pullen))\r\ndomain->reg_pullen = domain->reg_pull;\r\ndomain->reg_gpio = meson_map_resource(pc, np, "gpio");\r\nif (IS_ERR(domain->reg_gpio)) {\r\ndev_err(pc->dev, "gpio registers not found\n");\r\nreturn PTR_ERR(domain->reg_gpio);\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int meson_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nstruct meson_pinctrl *pc;\r\nint ret;\r\npc = devm_kzalloc(dev, sizeof(struct meson_pinctrl), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\npc->dev = dev;\r\nmatch = of_match_node(meson_pinctrl_dt_match, pdev->dev.of_node);\r\npc->data = (struct meson_pinctrl_data *)match->data;\r\nret = meson_pinctrl_parse_dt(pc, pdev->dev.of_node);\r\nif (ret)\r\nreturn ret;\r\npc->desc.name = "pinctrl-meson";\r\npc->desc.owner = THIS_MODULE;\r\npc->desc.pctlops = &meson_pctrl_ops;\r\npc->desc.pmxops = &meson_pmx_ops;\r\npc->desc.confops = &meson_pinconf_ops;\r\npc->desc.pins = pc->data->pins;\r\npc->desc.npins = pc->data->num_pins;\r\npc->pcdev = pinctrl_register(&pc->desc, pc->dev, pc);\r\nif (IS_ERR(pc->pcdev)) {\r\ndev_err(pc->dev, "can't register pinctrl device");\r\nreturn PTR_ERR(pc->pcdev);\r\n}\r\nret = meson_gpiolib_register(pc);\r\nif (ret) {\r\npinctrl_unregister(pc->pcdev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
