static u32 m5mols_swap_byte(u8 *data, u8 length)\r\n{\r\nif (length == 1)\r\nreturn *data;\r\nelse if (length == 2)\r\nreturn be16_to_cpu(*((__be16 *)data));\r\nelse\r\nreturn be32_to_cpu(*((__be32 *)data));\r\n}\r\nstatic int m5mols_read(struct v4l2_subdev *sd, u32 size, u32 reg, u32 *val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nu8 rbuf[M5MOLS_I2C_MAX_SIZE + 1];\r\nu8 category = I2C_CATEGORY(reg);\r\nu8 cmd = I2C_COMMAND(reg);\r\nstruct i2c_msg msg[2];\r\nu8 wbuf[5];\r\nint ret;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 5;\r\nmsg[0].buf = wbuf;\r\nwbuf[0] = 5;\r\nwbuf[1] = M5MOLS_BYTE_READ;\r\nwbuf[2] = category;\r\nwbuf[3] = cmd;\r\nwbuf[4] = size;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = size + 1;\r\nmsg[1].buf = rbuf;\r\nusleep_range(200, 200);\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret == 2) {\r\n*val = m5mols_swap_byte(&rbuf[1], size);\r\nreturn 0;\r\n}\r\nif (info->isp_ready)\r\nv4l2_err(sd, "read failed: size:%d cat:%02x cmd:%02x. %d\n",\r\nsize, category, cmd, ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nint m5mols_read_u8(struct v4l2_subdev *sd, u32 reg, u8 *val)\r\n{\r\nu32 val_32;\r\nint ret;\r\nif (I2C_SIZE(reg) != 1) {\r\nv4l2_err(sd, "Wrong data size\n");\r\nreturn -EINVAL;\r\n}\r\nret = m5mols_read(sd, I2C_SIZE(reg), reg, &val_32);\r\nif (ret)\r\nreturn ret;\r\n*val = (u8)val_32;\r\nreturn ret;\r\n}\r\nint m5mols_read_u16(struct v4l2_subdev *sd, u32 reg, u16 *val)\r\n{\r\nu32 val_32;\r\nint ret;\r\nif (I2C_SIZE(reg) != 2) {\r\nv4l2_err(sd, "Wrong data size\n");\r\nreturn -EINVAL;\r\n}\r\nret = m5mols_read(sd, I2C_SIZE(reg), reg, &val_32);\r\nif (ret)\r\nreturn ret;\r\n*val = (u16)val_32;\r\nreturn ret;\r\n}\r\nint m5mols_read_u32(struct v4l2_subdev *sd, u32 reg, u32 *val)\r\n{\r\nif (I2C_SIZE(reg) != 4) {\r\nv4l2_err(sd, "Wrong data size\n");\r\nreturn -EINVAL;\r\n}\r\nreturn m5mols_read(sd, I2C_SIZE(reg), reg, val);\r\n}\r\nint m5mols_write(struct v4l2_subdev *sd, u32 reg, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nu8 wbuf[M5MOLS_I2C_MAX_SIZE + 4];\r\nu8 category = I2C_CATEGORY(reg);\r\nu8 cmd = I2C_COMMAND(reg);\r\nu8 size = I2C_SIZE(reg);\r\nu32 *buf = (u32 *)&wbuf[4];\r\nstruct i2c_msg msg[1];\r\nint ret;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nif (size != 1 && size != 2 && size != 4) {\r\nv4l2_err(sd, "Wrong data size\n");\r\nreturn -EINVAL;\r\n}\r\nmsg->addr = client->addr;\r\nmsg->flags = 0;\r\nmsg->len = (u16)size + 4;\r\nmsg->buf = wbuf;\r\nwbuf[0] = size + 4;\r\nwbuf[1] = M5MOLS_BYTE_WRITE;\r\nwbuf[2] = category;\r\nwbuf[3] = cmd;\r\n*buf = m5mols_swap_byte((u8 *)&val, size);\r\nusleep_range(200, 200);\r\nret = i2c_transfer(client->adapter, msg, 1);\r\nif (ret == 1)\r\nreturn 0;\r\nif (info->isp_ready)\r\nv4l2_err(sd, "write failed: cat:%02x cmd:%02x ret:%d\n",\r\ncategory, cmd, ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nint m5mols_busy_wait(struct v4l2_subdev *sd, u32 reg, u32 value, u32 mask,\r\nint timeout)\r\n{\r\nint ms = timeout < 0 ? M5MOLS_BUSY_WAIT_DEF_TIMEOUT : timeout;\r\nunsigned long end = jiffies + msecs_to_jiffies(ms);\r\nu8 status;\r\ndo {\r\nint ret = m5mols_read_u8(sd, reg, &status);\r\nif (ret < 0 && !(mask & M5MOLS_I2C_RDY_WAIT_FL))\r\nreturn ret;\r\nif (!ret && (status & mask & 0xff) == (value & 0xff))\r\nreturn 0;\r\nusleep_range(100, 250);\r\n} while (ms > 0 && time_is_after_jiffies(end));\r\nreturn -EBUSY;\r\n}\r\nint m5mols_enable_interrupt(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nu8 mask = is_available_af(info) ? REG_INT_AF : 0;\r\nu8 dummy;\r\nint ret;\r\nret = m5mols_read_u8(sd, SYSTEM_INT_FACTOR, &dummy);\r\nif (!ret)\r\nret = m5mols_write(sd, SYSTEM_INT_ENABLE, reg & ~mask);\r\nreturn ret;\r\n}\r\nint m5mols_wait_interrupt(struct v4l2_subdev *sd, u8 irq_mask, u32 timeout)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nint ret = wait_event_interruptible_timeout(info->irq_waitq,\r\natomic_add_unless(&info->irq_done, -1, 0),\r\nmsecs_to_jiffies(timeout));\r\nif (ret <= 0)\r\nreturn ret ? ret : -ETIMEDOUT;\r\nreturn m5mols_busy_wait(sd, SYSTEM_INT_FACTOR, irq_mask,\r\nM5MOLS_I2C_RDY_WAIT_FL | irq_mask, -1);\r\n}\r\nstatic int m5mols_reg_mode(struct v4l2_subdev *sd, u8 mode)\r\n{\r\nint ret = m5mols_write(sd, SYSTEM_SYSMODE, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn m5mols_busy_wait(sd, SYSTEM_SYSMODE, mode, 0xff,\r\nM5MOLS_MODE_CHANGE_TIMEOUT);\r\n}\r\nint m5mols_set_mode(struct m5mols_info *info, u8 mode)\r\n{\r\nstruct v4l2_subdev *sd = &info->sd;\r\nint ret = -EINVAL;\r\nu8 reg;\r\nif (mode < REG_PARAMETER || mode > REG_CAPTURE)\r\nreturn ret;\r\nret = m5mols_read_u8(sd, SYSTEM_SYSMODE, &reg);\r\nif (ret || reg == mode)\r\nreturn ret;\r\nswitch (reg) {\r\ncase REG_PARAMETER:\r\nret = m5mols_reg_mode(sd, REG_MONITOR);\r\nif (mode == REG_MONITOR)\r\nbreak;\r\nif (!ret)\r\nret = m5mols_reg_mode(sd, REG_CAPTURE);\r\nbreak;\r\ncase REG_MONITOR:\r\nif (mode == REG_PARAMETER) {\r\nret = m5mols_reg_mode(sd, REG_PARAMETER);\r\nbreak;\r\n}\r\nret = m5mols_reg_mode(sd, REG_CAPTURE);\r\nbreak;\r\ncase REG_CAPTURE:\r\nret = m5mols_reg_mode(sd, REG_MONITOR);\r\nif (mode == REG_MONITOR)\r\nbreak;\r\nif (!ret)\r\nret = m5mols_reg_mode(sd, REG_PARAMETER);\r\nbreak;\r\ndefault:\r\nv4l2_warn(sd, "Wrong mode: %d\n", mode);\r\n}\r\nif (!ret)\r\ninfo->mode = mode;\r\nreturn ret;\r\n}\r\nstatic int m5mols_get_version(struct v4l2_subdev *sd)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nstruct m5mols_version *ver = &info->ver;\r\nu8 *str = ver->str;\r\nint i;\r\nint ret;\r\nret = m5mols_read_u8(sd, SYSTEM_VER_CUSTOMER, &ver->customer);\r\nif (!ret)\r\nret = m5mols_read_u8(sd, SYSTEM_VER_PROJECT, &ver->project);\r\nif (!ret)\r\nret = m5mols_read_u16(sd, SYSTEM_VER_FIRMWARE, &ver->fw);\r\nif (!ret)\r\nret = m5mols_read_u16(sd, SYSTEM_VER_HARDWARE, &ver->hw);\r\nif (!ret)\r\nret = m5mols_read_u16(sd, SYSTEM_VER_PARAMETER, &ver->param);\r\nif (!ret)\r\nret = m5mols_read_u16(sd, SYSTEM_VER_AWB, &ver->awb);\r\nif (!ret)\r\nret = m5mols_read_u8(sd, AF_VERSION, &ver->af);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < VERSION_STRING_SIZE; i++) {\r\nret = m5mols_read_u8(sd, SYSTEM_VER_STRING, &str[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nv4l2_info(sd, "Manufacturer\t[%s]\n",\r\nis_manufacturer(info, REG_SAMSUNG_ELECTRO) ?\r\n"Samsung Electro-Machanics" :\r\nis_manufacturer(info, REG_SAMSUNG_OPTICS) ?\r\n"Samsung Fiber-Optics" :\r\nis_manufacturer(info, REG_SAMSUNG_TECHWIN) ?\r\n"Samsung Techwin" : "None");\r\nv4l2_info(sd, "Customer/Project\t[0x%02x/0x%02x]\n",\r\ninfo->ver.customer, info->ver.project);\r\nif (!is_available_af(info))\r\nv4l2_info(sd, "No support Auto Focus on this firmware\n");\r\nreturn ret;\r\n}\r\nstatic enum m5mols_restype __find_restype(u32 code)\r\n{\r\nenum m5mols_restype type = M5MOLS_RESTYPE_MONITOR;\r\ndo {\r\nif (code == m5mols_default_ffmt[type].code)\r\nreturn type;\r\n} while (type++ != SIZE_DEFAULT_FFMT);\r\nreturn 0;\r\n}\r\nstatic int __find_resolution(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf,\r\nenum m5mols_restype *type,\r\nu32 *resolution)\r\n{\r\nconst struct m5mols_resolution *fsize = &m5mols_reg_res[0];\r\nconst struct m5mols_resolution *match = NULL;\r\nenum m5mols_restype stype = __find_restype(mf->code);\r\nint i = ARRAY_SIZE(m5mols_reg_res);\r\nunsigned int min_err = ~0;\r\nwhile (i--) {\r\nint err;\r\nif (stype == fsize->type) {\r\nerr = abs(fsize->width - mf->width)\r\n+ abs(fsize->height - mf->height);\r\nif (err < min_err) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\n}\r\nfsize++;\r\n}\r\nif (match) {\r\nmf->width = match->width;\r\nmf->height = match->height;\r\n*resolution = match->reg;\r\n*type = stype;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct v4l2_mbus_framefmt *__find_format(struct m5mols_info *info,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nenum v4l2_subdev_format_whence which,\r\nenum m5mols_restype type)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn cfg ? v4l2_subdev_get_try_format(&info->sd, cfg, 0) : NULL;\r\nreturn &info->ffmt[type];\r\n}\r\nstatic int m5mols_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nformat = __find_format(info, cfg, fmt->which, info->res_type);\r\nif (format)\r\nfmt->format = *format;\r\nelse\r\nret = -EINVAL;\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int m5mols_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nstruct v4l2_mbus_framefmt *format = &fmt->format;\r\nstruct v4l2_mbus_framefmt *sfmt;\r\nenum m5mols_restype type;\r\nu32 resolution = 0;\r\nint ret;\r\nret = __find_resolution(sd, format, &type, &resolution);\r\nif (ret < 0)\r\nreturn ret;\r\nsfmt = __find_format(info, cfg, fmt->which, type);\r\nif (!sfmt)\r\nreturn 0;\r\nmutex_lock(&info->lock);\r\nformat->code = m5mols_default_ffmt[type].code;\r\nformat->colorspace = V4L2_COLORSPACE_JPEG;\r\nformat->field = V4L2_FIELD_NONE;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\n*sfmt = *format;\r\ninfo->resolution = resolution;\r\ninfo->res_type = type;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int m5mols_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\r\nstruct v4l2_mbus_frame_desc *fd)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nif (pad != 0 || fd == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&info->lock);\r\nfd->entry[0].length = info->cap.buf_size;\r\nfd->entry[0].pixelcode = info->ffmt[M5MOLS_RESTYPE_CAPTURE].code;\r\nmutex_unlock(&info->lock);\r\nfd->entry[0].flags = V4L2_MBUS_FRAME_DESC_FL_LEN_MAX;\r\nfd->num_entries = 1;\r\nreturn 0;\r\n}\r\nstatic int m5mols_set_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\r\nstruct v4l2_mbus_frame_desc *fd)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nstruct v4l2_mbus_framefmt *mf = &info->ffmt[M5MOLS_RESTYPE_CAPTURE];\r\nif (pad != 0 || fd == NULL)\r\nreturn -EINVAL;\r\nfd->entry[0].flags = V4L2_MBUS_FRAME_DESC_FL_LEN_MAX;\r\nfd->num_entries = 1;\r\nfd->entry[0].length = clamp_t(u32, fd->entry[0].length,\r\nmf->width * mf->height,\r\nM5MOLS_MAIN_JPEG_SIZE_MAX);\r\nmutex_lock(&info->lock);\r\ninfo->cap.buf_size = fd->entry[0].length;\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\n}\r\nstatic int m5mols_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (!code || code->index >= SIZE_DEFAULT_FFMT)\r\nreturn -EINVAL;\r\ncode->code = m5mols_default_ffmt[code->index].code;\r\nreturn 0;\r\n}\r\nint m5mols_restore_controls(struct m5mols_info *info)\r\n{\r\nint ret;\r\nif (info->ctrl_sync)\r\nreturn 0;\r\nret = m5mols_do_scenemode(info, REG_SCENE_NORMAL);\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_ctrl_handler_setup(&info->handle);\r\ninfo->ctrl_sync = !ret;\r\nreturn ret;\r\n}\r\nstatic int m5mols_start_monitor(struct m5mols_info *info)\r\n{\r\nstruct v4l2_subdev *sd = &info->sd;\r\nint ret;\r\nret = m5mols_set_mode(info, REG_PARAMETER);\r\nif (!ret)\r\nret = m5mols_write(sd, PARM_MON_SIZE, info->resolution);\r\nif (!ret)\r\nret = m5mols_write(sd, PARM_MON_FPS, REG_FPS_30);\r\nif (!ret)\r\nret = m5mols_set_mode(info, REG_MONITOR);\r\nif (!ret)\r\nret = m5mols_restore_controls(info);\r\nreturn ret;\r\n}\r\nstatic int m5mols_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nu32 code;\r\nint ret;\r\nmutex_lock(&info->lock);\r\ncode = info->ffmt[info->res_type].code;\r\nif (enable) {\r\nif (is_code(code, M5MOLS_RESTYPE_MONITOR))\r\nret = m5mols_start_monitor(info);\r\nelse if (is_code(code, M5MOLS_RESTYPE_CAPTURE))\r\nret = m5mols_start_capture(info);\r\nelse\r\nret = -EINVAL;\r\n} else {\r\nret = m5mols_set_mode(info, REG_PARAMETER);\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int m5mols_sensor_power(struct m5mols_info *info, bool enable)\r\n{\r\nstruct v4l2_subdev *sd = &info->sd;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nconst struct m5mols_platform_data *pdata = info->pdata;\r\nint ret;\r\nif (info->power == enable)\r\nreturn 0;\r\nif (enable) {\r\nif (info->set_power) {\r\nret = info->set_power(&client->dev, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(supplies), supplies);\r\nif (ret) {\r\ninfo->set_power(&client->dev, 0);\r\nreturn ret;\r\n}\r\ngpio_set_value(pdata->gpio_reset, !pdata->reset_polarity);\r\ninfo->power = 1;\r\nreturn ret;\r\n}\r\nret = regulator_bulk_disable(ARRAY_SIZE(supplies), supplies);\r\nif (ret)\r\nreturn ret;\r\nif (info->set_power)\r\ninfo->set_power(&client->dev, 0);\r\ngpio_set_value(pdata->gpio_reset, pdata->reset_polarity);\r\ninfo->isp_ready = 0;\r\ninfo->power = 0;\r\nreturn ret;\r\n}\r\nstatic int m5mols_fw_start(struct v4l2_subdev *sd)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nint ret;\r\natomic_set(&info->irq_done, 0);\r\nret = m5mols_busy_wait(sd, FLASH_CAM_START, REG_IN_FLASH_MODE,\r\nM5MOLS_I2C_RDY_WAIT_FL | 0xff, -1);\r\nif (!ret)\r\nret = m5mols_write(sd, FLASH_CAM_START, REG_START_ARM_BOOT);\r\nif (!ret)\r\nret = m5mols_wait_interrupt(sd, REG_INT_MODE, 2000);\r\nif (ret < 0)\r\nreturn ret;\r\ninfo->isp_ready = 1;\r\nret = m5mols_get_version(sd);\r\nif (!ret)\r\nret = m5mols_update_fw(sd, m5mols_sensor_power);\r\nif (ret)\r\nreturn ret;\r\nv4l2_dbg(1, m5mols_debug, sd, "Success ARM Booting\n");\r\nret = m5mols_write(sd, PARM_INTERFACE, REG_INTERFACE_MIPI);\r\nif (!ret)\r\nret = m5mols_enable_interrupt(sd,\r\nREG_INT_AF | REG_INT_CAPTURE);\r\nreturn ret;\r\n}\r\nstatic int m5mols_auto_focus_stop(struct m5mols_info *info)\r\n{\r\nint ret;\r\nret = m5mols_write(&info->sd, AF_EXECUTE, REG_AF_STOP);\r\nif (!ret)\r\nret = m5mols_write(&info->sd, AF_MODE, REG_AF_POWEROFF);\r\nif (!ret)\r\nret = m5mols_busy_wait(&info->sd, SYSTEM_STATUS, REG_AF_IDLE,\r\n0xff, -1);\r\nreturn ret;\r\n}\r\nstatic int m5mols_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nint ret;\r\nmutex_lock(&info->lock);\r\nif (on) {\r\nret = m5mols_sensor_power(info, true);\r\nif (!ret)\r\nret = m5mols_fw_start(sd);\r\n} else {\r\nif (is_manufacturer(info, REG_SAMSUNG_TECHWIN)) {\r\nret = m5mols_set_mode(info, REG_MONITOR);\r\nif (!ret)\r\nret = m5mols_auto_focus_stop(info);\r\nif (ret < 0)\r\nv4l2_warn(sd, "Soft landing lens failed\n");\r\n}\r\nret = m5mols_sensor_power(info, false);\r\ninfo->ctrl_sync = 0;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int m5mols_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct m5mols_info *info = to_m5mols(sd);\r\nv4l2_ctrl_handler_log_status(&info->handle, sd->name);\r\nreturn 0;\r\n}\r\nstatic int m5mols_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(sd, fh->pad, 0);\r\n*format = m5mols_default_ffmt[0];\r\nreturn 0;\r\n}\r\nstatic irqreturn_t m5mols_irq_handler(int irq, void *data)\r\n{\r\nstruct m5mols_info *info = to_m5mols(data);\r\natomic_set(&info->irq_done, 1);\r\nwake_up_interruptible(&info->irq_waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int m5mols_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct m5mols_platform_data *pdata = client->dev.platform_data;\r\nunsigned long gpio_flags;\r\nstruct m5mols_info *info;\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!gpio_is_valid(pdata->gpio_reset)) {\r\ndev_err(&client->dev, "No valid RESET GPIO specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "Interrupt not assigned\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdata = pdata;\r\ninfo->set_power = pdata->set_power;\r\ngpio_flags = pdata->reset_polarity\r\n? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(&client->dev, pdata->gpio_reset, gpio_flags,\r\n"M5MOLS_NRST");\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to request gpio: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(supplies),\r\nsupplies);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\nsd = &info->sd;\r\nv4l2_i2c_subdev_init(sd, client, &m5mols_ops);\r\nstrlcpy(sd->name, MODULE_NAME, sizeof(sd->name));\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsd->internal_ops = &m5mols_subdev_internal_ops;\r\ninfo->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sd->entity, 1, &info->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\ninit_waitqueue_head(&info->irq_waitq);\r\nmutex_init(&info->lock);\r\nret = devm_request_irq(&client->dev, client->irq, m5mols_irq_handler,\r\nIRQF_TRIGGER_RISING, MODULE_NAME, sd);\r\nif (ret) {\r\ndev_err(&client->dev, "Interrupt request failed: %d\n", ret);\r\ngoto error;\r\n}\r\ninfo->res_type = M5MOLS_RESTYPE_MONITOR;\r\ninfo->ffmt[0] = m5mols_default_ffmt[0];\r\ninfo->ffmt[1] = m5mols_default_ffmt[1];\r\nret = m5mols_sensor_power(info, true);\r\nif (ret)\r\ngoto error;\r\nret = m5mols_fw_start(sd);\r\nif (!ret)\r\nret = m5mols_init_controls(sd);\r\nret = m5mols_sensor_power(info, false);\r\nif (!ret)\r\nreturn 0;\r\nerror:\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn ret;\r\n}\r\nstatic int m5mols_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
