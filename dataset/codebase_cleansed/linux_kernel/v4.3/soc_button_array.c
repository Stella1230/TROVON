static int soc_button_lookup_gpio(struct device *dev, int acpi_index)\r\n{\r\nstruct gpio_desc *desc;\r\nint gpio;\r\ndesc = gpiod_get_index(dev, KBUILD_MODNAME, acpi_index, GPIOD_ASIS);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\ngpio = desc_to_gpio(desc);\r\ngpiod_put(desc);\r\nreturn gpio;\r\n}\r\nstatic struct platform_device *\r\nsoc_button_device_create(struct platform_device *pdev,\r\nconst struct soc_button_info *button_info,\r\nbool autorepeat)\r\n{\r\nconst struct soc_button_info *info;\r\nstruct platform_device *pd;\r\nstruct gpio_keys_button *gpio_keys;\r\nstruct gpio_keys_platform_data *gpio_keys_pdata;\r\nint n_buttons = 0;\r\nint gpio;\r\nint error;\r\ngpio_keys_pdata = devm_kzalloc(&pdev->dev,\r\nsizeof(*gpio_keys_pdata) +\r\nsizeof(*gpio_keys) * MAX_NBUTTONS,\r\nGFP_KERNEL);\r\nif (!gpio_keys_pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\ngpio_keys = (void *)(gpio_keys_pdata + 1);\r\nfor (info = button_info; info->name; info++) {\r\nif (info->autorepeat != autorepeat)\r\ncontinue;\r\ngpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);\r\nif (gpio < 0)\r\ncontinue;\r\ngpio_keys[n_buttons].type = info->event_type;\r\ngpio_keys[n_buttons].code = info->event_code;\r\ngpio_keys[n_buttons].gpio = gpio;\r\ngpio_keys[n_buttons].active_low = 1;\r\ngpio_keys[n_buttons].desc = info->name;\r\ngpio_keys[n_buttons].wakeup = info->wakeup;\r\nn_buttons++;\r\n}\r\nif (n_buttons == 0) {\r\nerror = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\ngpio_keys_pdata->buttons = gpio_keys;\r\ngpio_keys_pdata->nbuttons = n_buttons;\r\ngpio_keys_pdata->rep = autorepeat;\r\npd = platform_device_alloc("gpio-keys", PLATFORM_DEVID_AUTO);\r\nif (!pd) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nerror = platform_device_add_data(pd, gpio_keys_pdata,\r\nsizeof(*gpio_keys_pdata));\r\nif (error)\r\ngoto err_free_pdev;\r\nerror = platform_device_add(pd);\r\nif (error)\r\ngoto err_free_pdev;\r\nreturn pd;\r\nerr_free_pdev:\r\nplatform_device_put(pd);\r\nerr_free_mem:\r\ndevm_kfree(&pdev->dev, gpio_keys_pdata);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int soc_button_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_button_data *priv = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < BUTTON_TYPES; i++)\r\nif (priv->children[i])\r\nplatform_device_unregister(priv->children[i]);\r\nreturn 0;\r\n}\r\nstatic int soc_button_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct acpi_device_id *id;\r\nstruct soc_button_info *button_info;\r\nstruct soc_button_data *priv;\r\nstruct platform_device *pd;\r\nint i;\r\nint error;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nbutton_info = (struct soc_button_info *)id->driver_data;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nfor (i = 0; i < BUTTON_TYPES; i++) {\r\npd = soc_button_device_create(pdev, button_info, i == 0);\r\nif (IS_ERR(pd)) {\r\nerror = PTR_ERR(pd);\r\nif (error != -ENODEV) {\r\nsoc_button_remove(pdev);\r\nreturn error;\r\n}\r\ncontinue;\r\n}\r\npriv->children[i] = pd;\r\n}\r\nif (!priv->children[0] && !priv->children[1])\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
