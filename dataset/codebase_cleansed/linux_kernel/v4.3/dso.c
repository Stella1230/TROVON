char dso__symtab_origin(const struct dso *dso)\r\n{\r\nstatic const char origin[] = {\r\n[DSO_BINARY_TYPE__KALLSYMS] = 'k',\r\n[DSO_BINARY_TYPE__VMLINUX] = 'v',\r\n[DSO_BINARY_TYPE__JAVA_JIT] = 'j',\r\n[DSO_BINARY_TYPE__DEBUGLINK] = 'l',\r\n[DSO_BINARY_TYPE__BUILD_ID_CACHE] = 'B',\r\n[DSO_BINARY_TYPE__FEDORA_DEBUGINFO] = 'f',\r\n[DSO_BINARY_TYPE__UBUNTU_DEBUGINFO] = 'u',\r\n[DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO] = 'o',\r\n[DSO_BINARY_TYPE__BUILDID_DEBUGINFO] = 'b',\r\n[DSO_BINARY_TYPE__SYSTEM_PATH_DSO] = 'd',\r\n[DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE] = 'K',\r\n[DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP] = 'm',\r\n[DSO_BINARY_TYPE__GUEST_KALLSYMS] = 'g',\r\n[DSO_BINARY_TYPE__GUEST_KMODULE] = 'G',\r\n[DSO_BINARY_TYPE__GUEST_KMODULE_COMP] = 'M',\r\n[DSO_BINARY_TYPE__GUEST_VMLINUX] = 'V',\r\n};\r\nif (dso == NULL || dso->symtab_type == DSO_BINARY_TYPE__NOT_FOUND)\r\nreturn '!';\r\nreturn origin[dso->symtab_type];\r\n}\r\nint dso__read_binary_type_filename(const struct dso *dso,\r\nenum dso_binary_type type,\r\nchar *root_dir, char *filename, size_t size)\r\n{\r\nchar build_id_hex[BUILD_ID_SIZE * 2 + 1];\r\nint ret = 0;\r\nsize_t len;\r\nswitch (type) {\r\ncase DSO_BINARY_TYPE__DEBUGLINK: {\r\nchar *debuglink;\r\nlen = __symbol__join_symfs(filename, size, dso->long_name);\r\ndebuglink = filename + len;\r\nwhile (debuglink != filename && *debuglink != '/')\r\ndebuglink--;\r\nif (*debuglink == '/')\r\ndebuglink++;\r\nret = filename__read_debuglink(filename, debuglink,\r\nsize - (debuglink - filename));\r\n}\r\nbreak;\r\ncase DSO_BINARY_TYPE__BUILD_ID_CACHE:\r\nif (symbol_conf.symfs[0] ||\r\n(dso__build_id_filename(dso, filename, size) == NULL))\r\nret = -1;\r\nbreak;\r\ncase DSO_BINARY_TYPE__FEDORA_DEBUGINFO:\r\nlen = __symbol__join_symfs(filename, size, "/usr/lib/debug");\r\nsnprintf(filename + len, size - len, "%s.debug", dso->long_name);\r\nbreak;\r\ncase DSO_BINARY_TYPE__UBUNTU_DEBUGINFO:\r\nlen = __symbol__join_symfs(filename, size, "/usr/lib/debug");\r\nsnprintf(filename + len, size - len, "%s", dso->long_name);\r\nbreak;\r\ncase DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO:\r\n{\r\nconst char *last_slash;\r\nsize_t dir_size;\r\nlast_slash = dso->long_name + dso->long_name_len;\r\nwhile (last_slash != dso->long_name && *last_slash != '/')\r\nlast_slash--;\r\nlen = __symbol__join_symfs(filename, size, "");\r\ndir_size = last_slash - dso->long_name + 2;\r\nif (dir_size > (size - len)) {\r\nret = -1;\r\nbreak;\r\n}\r\nlen += scnprintf(filename + len, dir_size, "%s", dso->long_name);\r\nlen += scnprintf(filename + len , size - len, ".debug%s",\r\nlast_slash);\r\nbreak;\r\n}\r\ncase DSO_BINARY_TYPE__BUILDID_DEBUGINFO:\r\nif (!dso->has_build_id) {\r\nret = -1;\r\nbreak;\r\n}\r\nbuild_id__sprintf(dso->build_id,\r\nsizeof(dso->build_id),\r\nbuild_id_hex);\r\nlen = __symbol__join_symfs(filename, size, "/usr/lib/debug/.build-id/");\r\nsnprintf(filename + len, size - len, "%.2s/%s.debug",\r\nbuild_id_hex, build_id_hex + 2);\r\nbreak;\r\ncase DSO_BINARY_TYPE__VMLINUX:\r\ncase DSO_BINARY_TYPE__GUEST_VMLINUX:\r\ncase DSO_BINARY_TYPE__SYSTEM_PATH_DSO:\r\n__symbol__join_symfs(filename, size, dso->long_name);\r\nbreak;\r\ncase DSO_BINARY_TYPE__GUEST_KMODULE:\r\ncase DSO_BINARY_TYPE__GUEST_KMODULE_COMP:\r\npath__join3(filename, size, symbol_conf.symfs,\r\nroot_dir, dso->long_name);\r\nbreak;\r\ncase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE:\r\ncase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP:\r\n__symbol__join_symfs(filename, size, dso->long_name);\r\nbreak;\r\ncase DSO_BINARY_TYPE__KCORE:\r\ncase DSO_BINARY_TYPE__GUEST_KCORE:\r\nsnprintf(filename, size, "%s", dso->long_name);\r\nbreak;\r\ndefault:\r\ncase DSO_BINARY_TYPE__KALLSYMS:\r\ncase DSO_BINARY_TYPE__GUEST_KALLSYMS:\r\ncase DSO_BINARY_TYPE__JAVA_JIT:\r\ncase DSO_BINARY_TYPE__NOT_FOUND:\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nbool is_supported_compression(const char *ext)\r\n{\r\nunsigned i;\r\nfor (i = 0; compressions[i].fmt; i++) {\r\nif (!strcmp(ext, compressions[i].fmt))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool is_kernel_module(const char *pathname, int cpumode)\r\n{\r\nstruct kmod_path m;\r\nint mode = cpumode & PERF_RECORD_MISC_CPUMODE_MASK;\r\nWARN_ONCE(mode != cpumode,\r\n"Internal error: passing unmasked cpumode (%x) to is_kernel_module",\r\ncpumode);\r\nswitch (mode) {\r\ncase PERF_RECORD_MISC_USER:\r\ncase PERF_RECORD_MISC_HYPERVISOR:\r\ncase PERF_RECORD_MISC_GUEST_USER:\r\nreturn false;\r\ndefault:\r\nif (kmod_path__parse(&m, pathname)) {\r\npr_err("Failed to check whether %s is a kernel module or not. Assume it is.",\r\npathname);\r\nreturn true;\r\n}\r\n}\r\nreturn m.kmod;\r\n}\r\nbool decompress_to_file(const char *ext, const char *filename, int output_fd)\r\n{\r\nunsigned i;\r\nfor (i = 0; compressions[i].fmt; i++) {\r\nif (!strcmp(ext, compressions[i].fmt))\r\nreturn !compressions[i].decompress(filename,\r\noutput_fd);\r\n}\r\nreturn false;\r\n}\r\nbool dso__needs_decompress(struct dso *dso)\r\n{\r\nreturn dso->symtab_type == DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP ||\r\ndso->symtab_type == DSO_BINARY_TYPE__GUEST_KMODULE_COMP;\r\n}\r\nint __kmod_path__parse(struct kmod_path *m, const char *path,\r\nbool alloc_name, bool alloc_ext)\r\n{\r\nconst char *name = strrchr(path, '/');\r\nconst char *ext = strrchr(path, '.');\r\nbool is_simple_name = false;\r\nmemset(m, 0x0, sizeof(*m));\r\nname = name ? name + 1 : path;\r\nif (name[0] == '[') {\r\nis_simple_name = true;\r\nif ((strncmp(name, "[kernel.kallsyms]", 17) == 0) ||\r\n(strncmp(name, "[guest.kernel.kallsyms", 22) == 0) ||\r\n(strncmp(name, "[vdso]", 6) == 0) ||\r\n(strncmp(name, "[vsyscall]", 10) == 0)) {\r\nm->kmod = false;\r\n} else\r\nm->kmod = true;\r\n}\r\nif ((ext == NULL) || is_simple_name) {\r\nif (alloc_name) {\r\nm->name = strdup(name);\r\nreturn m->name ? 0 : -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nif (is_supported_compression(ext + 1)) {\r\nm->comp = true;\r\next -= 3;\r\n}\r\nif (ext > name)\r\nm->kmod = !strncmp(ext, ".ko", 3);\r\nif (alloc_name) {\r\nif (m->kmod) {\r\nif (asprintf(&m->name, "[%.*s]", (int) (ext - name), name) == -1)\r\nreturn -ENOMEM;\r\n} else {\r\nif (asprintf(&m->name, "%s", name) == -1)\r\nreturn -ENOMEM;\r\n}\r\nstrxfrchar(m->name, '-', '_');\r\n}\r\nif (alloc_ext && m->comp) {\r\nm->ext = strdup(ext + 4);\r\nif (!m->ext) {\r\nfree((void *) m->name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dso__list_add(struct dso *dso)\r\n{\r\nlist_add_tail(&dso->data.open_entry, &dso__data_open);\r\ndso__data_open_cnt++;\r\n}\r\nstatic void dso__list_del(struct dso *dso)\r\n{\r\nlist_del(&dso->data.open_entry);\r\nWARN_ONCE(dso__data_open_cnt <= 0,\r\n"DSO data fd counter out of bounds.");\r\ndso__data_open_cnt--;\r\n}\r\nstatic int do_open(char *name)\r\n{\r\nint fd;\r\nchar sbuf[STRERR_BUFSIZE];\r\ndo {\r\nfd = open(name, O_RDONLY);\r\nif (fd >= 0)\r\nreturn fd;\r\npr_debug("dso open failed: %s\n",\r\nstrerror_r(errno, sbuf, sizeof(sbuf)));\r\nif (!dso__data_open_cnt || errno != EMFILE)\r\nbreak;\r\nclose_first_dso();\r\n} while (1);\r\nreturn -1;\r\n}\r\nstatic int __open_dso(struct dso *dso, struct machine *machine)\r\n{\r\nint fd;\r\nchar *root_dir = (char *)"";\r\nchar *name = malloc(PATH_MAX);\r\nif (!name)\r\nreturn -ENOMEM;\r\nif (machine)\r\nroot_dir = machine->root_dir;\r\nif (dso__read_binary_type_filename(dso, dso->binary_type,\r\nroot_dir, name, PATH_MAX)) {\r\nfree(name);\r\nreturn -EINVAL;\r\n}\r\nfd = do_open(name);\r\nfree(name);\r\nreturn fd;\r\n}\r\nstatic int open_dso(struct dso *dso, struct machine *machine)\r\n{\r\nint fd = __open_dso(dso, machine);\r\nif (fd >= 0) {\r\ndso__list_add(dso);\r\ncheck_data_close();\r\n}\r\nreturn fd;\r\n}\r\nstatic void close_data_fd(struct dso *dso)\r\n{\r\nif (dso->data.fd >= 0) {\r\nclose(dso->data.fd);\r\ndso->data.fd = -1;\r\ndso->data.file_size = 0;\r\ndso__list_del(dso);\r\n}\r\n}\r\nstatic void close_dso(struct dso *dso)\r\n{\r\nclose_data_fd(dso);\r\n}\r\nstatic void close_first_dso(void)\r\n{\r\nstruct dso *dso;\r\ndso = list_first_entry(&dso__data_open, struct dso, data.open_entry);\r\nclose_dso(dso);\r\n}\r\nstatic rlim_t get_fd_limit(void)\r\n{\r\nstruct rlimit l;\r\nrlim_t limit = 0;\r\nif (getrlimit(RLIMIT_NOFILE, &l) == 0) {\r\nif (l.rlim_cur == RLIM_INFINITY)\r\nlimit = l.rlim_cur;\r\nelse\r\nlimit = l.rlim_cur / 2;\r\n} else {\r\npr_err("failed to get fd limit\n");\r\nlimit = 1;\r\n}\r\nreturn limit;\r\n}\r\nstatic bool may_cache_fd(void)\r\n{\r\nstatic rlim_t limit;\r\nif (!limit)\r\nlimit = get_fd_limit();\r\nif (limit == RLIM_INFINITY)\r\nreturn true;\r\nreturn limit > (rlim_t) dso__data_open_cnt;\r\n}\r\nstatic void check_data_close(void)\r\n{\r\nbool cache_fd = may_cache_fd();\r\nif (!cache_fd)\r\nclose_first_dso();\r\n}\r\nvoid dso__data_close(struct dso *dso)\r\n{\r\npthread_mutex_lock(&dso__data_open_lock);\r\nclose_dso(dso);\r\npthread_mutex_unlock(&dso__data_open_lock);\r\n}\r\nstatic void try_to_open_dso(struct dso *dso, struct machine *machine)\r\n{\r\nenum dso_binary_type binary_type_data[] = {\r\nDSO_BINARY_TYPE__BUILD_ID_CACHE,\r\nDSO_BINARY_TYPE__SYSTEM_PATH_DSO,\r\nDSO_BINARY_TYPE__NOT_FOUND,\r\n};\r\nint i = 0;\r\nif (dso->data.fd >= 0)\r\nreturn;\r\nif (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND) {\r\ndso->data.fd = open_dso(dso, machine);\r\ngoto out;\r\n}\r\ndo {\r\ndso->binary_type = binary_type_data[i++];\r\ndso->data.fd = open_dso(dso, machine);\r\nif (dso->data.fd >= 0)\r\ngoto out;\r\n} while (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND);\r\nout:\r\nif (dso->data.fd >= 0)\r\ndso->data.status = DSO_DATA_STATUS_OK;\r\nelse\r\ndso->data.status = DSO_DATA_STATUS_ERROR;\r\n}\r\nint dso__data_get_fd(struct dso *dso, struct machine *machine)\r\n{\r\nif (dso->data.status == DSO_DATA_STATUS_ERROR)\r\nreturn -1;\r\nif (pthread_mutex_lock(&dso__data_open_lock) < 0)\r\nreturn -1;\r\ntry_to_open_dso(dso, machine);\r\nif (dso->data.fd < 0)\r\npthread_mutex_unlock(&dso__data_open_lock);\r\nreturn dso->data.fd;\r\n}\r\nvoid dso__data_put_fd(struct dso *dso __maybe_unused)\r\n{\r\npthread_mutex_unlock(&dso__data_open_lock);\r\n}\r\nbool dso__data_status_seen(struct dso *dso, enum dso_data_status_seen by)\r\n{\r\nu32 flag = 1 << by;\r\nif (dso->data.status_seen & flag)\r\nreturn true;\r\ndso->data.status_seen |= flag;\r\nreturn false;\r\n}\r\nstatic void\r\ndso_cache__free(struct dso *dso)\r\n{\r\nstruct rb_root *root = &dso->data.cache;\r\nstruct rb_node *next = rb_first(root);\r\npthread_mutex_lock(&dso->lock);\r\nwhile (next) {\r\nstruct dso_cache *cache;\r\ncache = rb_entry(next, struct dso_cache, rb_node);\r\nnext = rb_next(&cache->rb_node);\r\nrb_erase(&cache->rb_node, root);\r\nfree(cache);\r\n}\r\npthread_mutex_unlock(&dso->lock);\r\n}\r\nstatic struct dso_cache *dso_cache__find(struct dso *dso, u64 offset)\r\n{\r\nconst struct rb_root *root = &dso->data.cache;\r\nstruct rb_node * const *p = &root->rb_node;\r\nconst struct rb_node *parent = NULL;\r\nstruct dso_cache *cache;\r\nwhile (*p != NULL) {\r\nu64 end;\r\nparent = *p;\r\ncache = rb_entry(parent, struct dso_cache, rb_node);\r\nend = cache->offset + DSO__DATA_CACHE_SIZE;\r\nif (offset < cache->offset)\r\np = &(*p)->rb_left;\r\nelse if (offset >= end)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn cache;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dso_cache *\r\ndso_cache__insert(struct dso *dso, struct dso_cache *new)\r\n{\r\nstruct rb_root *root = &dso->data.cache;\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct dso_cache *cache;\r\nu64 offset = new->offset;\r\npthread_mutex_lock(&dso->lock);\r\nwhile (*p != NULL) {\r\nu64 end;\r\nparent = *p;\r\ncache = rb_entry(parent, struct dso_cache, rb_node);\r\nend = cache->offset + DSO__DATA_CACHE_SIZE;\r\nif (offset < cache->offset)\r\np = &(*p)->rb_left;\r\nelse if (offset >= end)\r\np = &(*p)->rb_right;\r\nelse\r\ngoto out;\r\n}\r\nrb_link_node(&new->rb_node, parent, p);\r\nrb_insert_color(&new->rb_node, root);\r\ncache = NULL;\r\nout:\r\npthread_mutex_unlock(&dso->lock);\r\nreturn cache;\r\n}\r\nstatic ssize_t\r\ndso_cache__memcpy(struct dso_cache *cache, u64 offset,\r\nu8 *data, u64 size)\r\n{\r\nu64 cache_offset = offset - cache->offset;\r\nu64 cache_size = min(cache->size - cache_offset, size);\r\nmemcpy(data, cache->data + cache_offset, cache_size);\r\nreturn cache_size;\r\n}\r\nstatic ssize_t\r\ndso_cache__read(struct dso *dso, struct machine *machine,\r\nu64 offset, u8 *data, ssize_t size)\r\n{\r\nstruct dso_cache *cache;\r\nstruct dso_cache *old;\r\nssize_t ret;\r\ndo {\r\nu64 cache_offset;\r\ncache = zalloc(sizeof(*cache) + DSO__DATA_CACHE_SIZE);\r\nif (!cache)\r\nreturn -ENOMEM;\r\npthread_mutex_lock(&dso__data_open_lock);\r\ntry_to_open_dso(dso, machine);\r\nif (dso->data.fd < 0) {\r\nret = -errno;\r\ndso->data.status = DSO_DATA_STATUS_ERROR;\r\nbreak;\r\n}\r\ncache_offset = offset & DSO__DATA_CACHE_MASK;\r\nret = pread(dso->data.fd, cache->data, DSO__DATA_CACHE_SIZE, cache_offset);\r\nif (ret <= 0)\r\nbreak;\r\ncache->offset = cache_offset;\r\ncache->size = ret;\r\n} while (0);\r\npthread_mutex_unlock(&dso__data_open_lock);\r\nif (ret > 0) {\r\nold = dso_cache__insert(dso, cache);\r\nif (old) {\r\nfree(cache);\r\ncache = old;\r\n}\r\nret = dso_cache__memcpy(cache, offset, data, size);\r\n}\r\nif (ret <= 0)\r\nfree(cache);\r\nreturn ret;\r\n}\r\nstatic ssize_t dso_cache_read(struct dso *dso, struct machine *machine,\r\nu64 offset, u8 *data, ssize_t size)\r\n{\r\nstruct dso_cache *cache;\r\ncache = dso_cache__find(dso, offset);\r\nif (cache)\r\nreturn dso_cache__memcpy(cache, offset, data, size);\r\nelse\r\nreturn dso_cache__read(dso, machine, offset, data, size);\r\n}\r\nstatic ssize_t cached_read(struct dso *dso, struct machine *machine,\r\nu64 offset, u8 *data, ssize_t size)\r\n{\r\nssize_t r = 0;\r\nu8 *p = data;\r\ndo {\r\nssize_t ret;\r\nret = dso_cache_read(dso, machine, offset, p, size);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!ret)\r\nbreak;\r\nBUG_ON(ret > size);\r\nr += ret;\r\np += ret;\r\noffset += ret;\r\nsize -= ret;\r\n} while (size);\r\nreturn r;\r\n}\r\nstatic int data_file_size(struct dso *dso, struct machine *machine)\r\n{\r\nint ret = 0;\r\nstruct stat st;\r\nchar sbuf[STRERR_BUFSIZE];\r\nif (dso->data.file_size)\r\nreturn 0;\r\nif (dso->data.status == DSO_DATA_STATUS_ERROR)\r\nreturn -1;\r\npthread_mutex_lock(&dso__data_open_lock);\r\ntry_to_open_dso(dso, machine);\r\nif (dso->data.fd < 0) {\r\nret = -errno;\r\ndso->data.status = DSO_DATA_STATUS_ERROR;\r\ngoto out;\r\n}\r\nif (fstat(dso->data.fd, &st) < 0) {\r\nret = -errno;\r\npr_err("dso cache fstat failed: %s\n",\r\nstrerror_r(errno, sbuf, sizeof(sbuf)));\r\ndso->data.status = DSO_DATA_STATUS_ERROR;\r\ngoto out;\r\n}\r\ndso->data.file_size = st.st_size;\r\nout:\r\npthread_mutex_unlock(&dso__data_open_lock);\r\nreturn ret;\r\n}\r\noff_t dso__data_size(struct dso *dso, struct machine *machine)\r\n{\r\nif (data_file_size(dso, machine))\r\nreturn -1;\r\nreturn dso->data.file_size;\r\n}\r\nstatic ssize_t data_read_offset(struct dso *dso, struct machine *machine,\r\nu64 offset, u8 *data, ssize_t size)\r\n{\r\nif (data_file_size(dso, machine))\r\nreturn -1;\r\nif (offset > dso->data.file_size)\r\nreturn -1;\r\nif (offset + size < offset)\r\nreturn -1;\r\nreturn cached_read(dso, machine, offset, data, size);\r\n}\r\nssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,\r\nu64 offset, u8 *data, ssize_t size)\r\n{\r\nif (dso->data.status == DSO_DATA_STATUS_ERROR)\r\nreturn -1;\r\nreturn data_read_offset(dso, machine, offset, data, size);\r\n}\r\nssize_t dso__data_read_addr(struct dso *dso, struct map *map,\r\nstruct machine *machine, u64 addr,\r\nu8 *data, ssize_t size)\r\n{\r\nu64 offset = map->map_ip(map, addr);\r\nreturn dso__data_read_offset(dso, machine, offset, data, size);\r\n}\r\nstruct map *dso__new_map(const char *name)\r\n{\r\nstruct map *map = NULL;\r\nstruct dso *dso = dso__new(name);\r\nif (dso)\r\nmap = map__new2(0, dso, MAP__FUNCTION);\r\nreturn map;\r\n}\r\nstruct dso *machine__findnew_kernel(struct machine *machine, const char *name,\r\nconst char *short_name, int dso_type)\r\n{\r\nstruct dso *dso = machine__findnew_dso(machine, name);\r\nif (dso != NULL) {\r\ndso__set_short_name(dso, short_name, false);\r\ndso->kernel = dso_type;\r\n}\r\nreturn dso;\r\n}\r\nstatic struct dso *__dso__findlink_by_longname(struct rb_root *root,\r\nstruct dso *dso, const char *name)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nif (!name)\r\nname = dso->long_name;\r\nwhile (*p) {\r\nstruct dso *this = rb_entry(*p, struct dso, rb_node);\r\nint rc = strcmp(name, this->long_name);\r\nparent = *p;\r\nif (rc == 0) {\r\nif (!dso || (dso == this))\r\nreturn this;\r\nrc = strcmp(dso->short_name, this->short_name);\r\nif (rc == 0) {\r\npr_err("Duplicated dso name: %s\n", name);\r\nreturn NULL;\r\n}\r\n}\r\nif (rc < 0)\r\np = &parent->rb_left;\r\nelse\r\np = &parent->rb_right;\r\n}\r\nif (dso) {\r\nrb_link_node(&dso->rb_node, parent, p);\r\nrb_insert_color(&dso->rb_node, root);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct dso *__dso__find_by_longname(struct rb_root *root,\r\nconst char *name)\r\n{\r\nreturn __dso__findlink_by_longname(root, NULL, name);\r\n}\r\nvoid dso__set_long_name(struct dso *dso, const char *name, bool name_allocated)\r\n{\r\nif (name == NULL)\r\nreturn;\r\nif (dso->long_name_allocated)\r\nfree((char *)dso->long_name);\r\ndso->long_name = name;\r\ndso->long_name_len = strlen(name);\r\ndso->long_name_allocated = name_allocated;\r\n}\r\nvoid dso__set_short_name(struct dso *dso, const char *name, bool name_allocated)\r\n{\r\nif (name == NULL)\r\nreturn;\r\nif (dso->short_name_allocated)\r\nfree((char *)dso->short_name);\r\ndso->short_name = name;\r\ndso->short_name_len = strlen(name);\r\ndso->short_name_allocated = name_allocated;\r\n}\r\nstatic void dso__set_basename(struct dso *dso)\r\n{\r\nchar *base, *lname = strdup(dso->long_name);\r\nif (!lname)\r\nreturn;\r\nbase = strdup(basename(lname));\r\nfree(lname);\r\nif (!base)\r\nreturn;\r\ndso__set_short_name(dso, base, true);\r\n}\r\nint dso__name_len(const struct dso *dso)\r\n{\r\nif (!dso)\r\nreturn strlen("[unknown]");\r\nif (verbose)\r\nreturn dso->long_name_len;\r\nreturn dso->short_name_len;\r\n}\r\nbool dso__loaded(const struct dso *dso, enum map_type type)\r\n{\r\nreturn dso->loaded & (1 << type);\r\n}\r\nbool dso__sorted_by_name(const struct dso *dso, enum map_type type)\r\n{\r\nreturn dso->sorted_by_name & (1 << type);\r\n}\r\nvoid dso__set_sorted_by_name(struct dso *dso, enum map_type type)\r\n{\r\ndso->sorted_by_name |= (1 << type);\r\n}\r\nstruct dso *dso__new(const char *name)\r\n{\r\nstruct dso *dso = calloc(1, sizeof(*dso) + strlen(name) + 1);\r\nif (dso != NULL) {\r\nint i;\r\nstrcpy(dso->name, name);\r\ndso__set_long_name(dso, dso->name, false);\r\ndso__set_short_name(dso, dso->name, false);\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\ndso->symbols[i] = dso->symbol_names[i] = RB_ROOT;\r\ndso->data.cache = RB_ROOT;\r\ndso->data.fd = -1;\r\ndso->data.status = DSO_DATA_STATUS_UNKNOWN;\r\ndso->symtab_type = DSO_BINARY_TYPE__NOT_FOUND;\r\ndso->binary_type = DSO_BINARY_TYPE__NOT_FOUND;\r\ndso->is_64_bit = (sizeof(void *) == 8);\r\ndso->loaded = 0;\r\ndso->rel = 0;\r\ndso->sorted_by_name = 0;\r\ndso->has_build_id = 0;\r\ndso->has_srcline = 1;\r\ndso->a2l_fails = 1;\r\ndso->kernel = DSO_TYPE_USER;\r\ndso->needs_swap = DSO_SWAP__UNSET;\r\nRB_CLEAR_NODE(&dso->rb_node);\r\nINIT_LIST_HEAD(&dso->node);\r\nINIT_LIST_HEAD(&dso->data.open_entry);\r\npthread_mutex_init(&dso->lock, NULL);\r\natomic_set(&dso->refcnt, 1);\r\n}\r\nreturn dso;\r\n}\r\nvoid dso__delete(struct dso *dso)\r\n{\r\nint i;\r\nif (!RB_EMPTY_NODE(&dso->rb_node))\r\npr_err("DSO %s is still in rbtree when being deleted!\n",\r\ndso->long_name);\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nsymbols__delete(&dso->symbols[i]);\r\nif (dso->short_name_allocated) {\r\nzfree((char **)&dso->short_name);\r\ndso->short_name_allocated = false;\r\n}\r\nif (dso->long_name_allocated) {\r\nzfree((char **)&dso->long_name);\r\ndso->long_name_allocated = false;\r\n}\r\ndso__data_close(dso);\r\nauxtrace_cache__free(dso->auxtrace_cache);\r\ndso_cache__free(dso);\r\ndso__free_a2l(dso);\r\nzfree(&dso->symsrc_filename);\r\npthread_mutex_destroy(&dso->lock);\r\nfree(dso);\r\n}\r\nstruct dso *dso__get(struct dso *dso)\r\n{\r\nif (dso)\r\natomic_inc(&dso->refcnt);\r\nreturn dso;\r\n}\r\nvoid dso__put(struct dso *dso)\r\n{\r\nif (dso && atomic_dec_and_test(&dso->refcnt))\r\ndso__delete(dso);\r\n}\r\nvoid dso__set_build_id(struct dso *dso, void *build_id)\r\n{\r\nmemcpy(dso->build_id, build_id, sizeof(dso->build_id));\r\ndso->has_build_id = 1;\r\n}\r\nbool dso__build_id_equal(const struct dso *dso, u8 *build_id)\r\n{\r\nreturn memcmp(dso->build_id, build_id, sizeof(dso->build_id)) == 0;\r\n}\r\nvoid dso__read_running_kernel_build_id(struct dso *dso, struct machine *machine)\r\n{\r\nchar path[PATH_MAX];\r\nif (machine__is_default_guest(machine))\r\nreturn;\r\nsprintf(path, "%s/sys/kernel/notes", machine->root_dir);\r\nif (sysfs__read_build_id(path, dso->build_id,\r\nsizeof(dso->build_id)) == 0)\r\ndso->has_build_id = true;\r\n}\r\nint dso__kernel_module_get_build_id(struct dso *dso,\r\nconst char *root_dir)\r\n{\r\nchar filename[PATH_MAX];\r\nconst char *name = dso->short_name + 1;\r\nsnprintf(filename, sizeof(filename),\r\n"%s/sys/module/%.*s/notes/.note.gnu.build-id",\r\nroot_dir, (int)strlen(name) - 1, name);\r\nif (sysfs__read_build_id(filename, dso->build_id,\r\nsizeof(dso->build_id)) == 0)\r\ndso->has_build_id = true;\r\nreturn 0;\r\n}\r\nbool __dsos__read_build_ids(struct list_head *head, bool with_hits)\r\n{\r\nbool have_build_id = false;\r\nstruct dso *pos;\r\nlist_for_each_entry(pos, head, node) {\r\nif (with_hits && !pos->hit)\r\ncontinue;\r\nif (pos->has_build_id) {\r\nhave_build_id = true;\r\ncontinue;\r\n}\r\nif (filename__read_build_id(pos->long_name, pos->build_id,\r\nsizeof(pos->build_id)) > 0) {\r\nhave_build_id = true;\r\npos->has_build_id = true;\r\n}\r\n}\r\nreturn have_build_id;\r\n}\r\nvoid __dsos__add(struct dsos *dsos, struct dso *dso)\r\n{\r\nlist_add_tail(&dso->node, &dsos->head);\r\n__dso__findlink_by_longname(&dsos->root, dso, NULL);\r\ndso__get(dso);\r\n}\r\nvoid dsos__add(struct dsos *dsos, struct dso *dso)\r\n{\r\npthread_rwlock_wrlock(&dsos->lock);\r\n__dsos__add(dsos, dso);\r\npthread_rwlock_unlock(&dsos->lock);\r\n}\r\nstruct dso *__dsos__find(struct dsos *dsos, const char *name, bool cmp_short)\r\n{\r\nstruct dso *pos;\r\nif (cmp_short) {\r\nlist_for_each_entry(pos, &dsos->head, node)\r\nif (strcmp(pos->short_name, name) == 0)\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nreturn __dso__find_by_longname(&dsos->root, name);\r\n}\r\nstruct dso *dsos__find(struct dsos *dsos, const char *name, bool cmp_short)\r\n{\r\nstruct dso *dso;\r\npthread_rwlock_rdlock(&dsos->lock);\r\ndso = __dsos__find(dsos, name, cmp_short);\r\npthread_rwlock_unlock(&dsos->lock);\r\nreturn dso;\r\n}\r\nstruct dso *__dsos__addnew(struct dsos *dsos, const char *name)\r\n{\r\nstruct dso *dso = dso__new(name);\r\nif (dso != NULL) {\r\n__dsos__add(dsos, dso);\r\ndso__set_basename(dso);\r\n}\r\nreturn dso;\r\n}\r\nstruct dso *__dsos__findnew(struct dsos *dsos, const char *name)\r\n{\r\nstruct dso *dso = __dsos__find(dsos, name, false);\r\nreturn dso ? dso : __dsos__addnew(dsos, name);\r\n}\r\nstruct dso *dsos__findnew(struct dsos *dsos, const char *name)\r\n{\r\nstruct dso *dso;\r\npthread_rwlock_wrlock(&dsos->lock);\r\ndso = dso__get(__dsos__findnew(dsos, name));\r\npthread_rwlock_unlock(&dsos->lock);\r\nreturn dso;\r\n}\r\nsize_t __dsos__fprintf_buildid(struct list_head *head, FILE *fp,\r\nbool (skip)(struct dso *dso, int parm), int parm)\r\n{\r\nstruct dso *pos;\r\nsize_t ret = 0;\r\nlist_for_each_entry(pos, head, node) {\r\nif (skip && skip(pos, parm))\r\ncontinue;\r\nret += dso__fprintf_buildid(pos, fp);\r\nret += fprintf(fp, " %s\n", pos->long_name);\r\n}\r\nreturn ret;\r\n}\r\nsize_t __dsos__fprintf(struct list_head *head, FILE *fp)\r\n{\r\nstruct dso *pos;\r\nsize_t ret = 0;\r\nlist_for_each_entry(pos, head, node) {\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nret += dso__fprintf(pos, i, fp);\r\n}\r\nreturn ret;\r\n}\r\nsize_t dso__fprintf_buildid(struct dso *dso, FILE *fp)\r\n{\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id), sbuild_id);\r\nreturn fprintf(fp, "%s", sbuild_id);\r\n}\r\nsize_t dso__fprintf(struct dso *dso, enum map_type type, FILE *fp)\r\n{\r\nstruct rb_node *nd;\r\nsize_t ret = fprintf(fp, "dso: %s (", dso->short_name);\r\nif (dso->short_name != dso->long_name)\r\nret += fprintf(fp, "%s, ", dso->long_name);\r\nret += fprintf(fp, "%s, %sloaded, ", map_type__name[type],\r\ndso__loaded(dso, type) ? "" : "NOT ");\r\nret += dso__fprintf_buildid(dso, fp);\r\nret += fprintf(fp, ")\n");\r\nfor (nd = rb_first(&dso->symbols[type]); nd; nd = rb_next(nd)) {\r\nstruct symbol *pos = rb_entry(nd, struct symbol, rb_node);\r\nret += symbol__fprintf(pos, fp);\r\n}\r\nreturn ret;\r\n}\r\nenum dso_type dso__type(struct dso *dso, struct machine *machine)\r\n{\r\nint fd;\r\nenum dso_type type = DSO__TYPE_UNKNOWN;\r\nfd = dso__data_get_fd(dso, machine);\r\nif (fd >= 0) {\r\ntype = dso__type_fd(fd);\r\ndso__data_put_fd(dso);\r\n}\r\nreturn type;\r\n}\r\nint dso__strerror_load(struct dso *dso, char *buf, size_t buflen)\r\n{\r\nint idx, errnum = dso->load_errno;\r\nstatic const char *dso_load__error_str[] = {\r\n"Internal tools/perf/ library error",\r\n"Invalid ELF file",\r\n"Can not read build id",\r\n"Mismatching build id",\r\n"Decompression failure",\r\n};\r\nBUG_ON(buflen == 0);\r\nif (errnum >= 0) {\r\nconst char *err = strerror_r(errnum, buf, buflen);\r\nif (err != buf)\r\nscnprintf(buf, buflen, "%s", err);\r\nreturn 0;\r\n}\r\nif (errnum < __DSO_LOAD_ERRNO__START || errnum >= __DSO_LOAD_ERRNO__END)\r\nreturn -1;\r\nidx = errnum - __DSO_LOAD_ERRNO__START;\r\nscnprintf(buf, buflen, "%s", dso_load__error_str[idx]);\r\nreturn 0;\r\n}
