int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time)\r\n{\r\nunsigned long end_time = jiffies + (time * HZ + 999) / 1000;\r\nstatic char *reg_names[VX_REG_MAX] = {\r\n"ICR", "CVR", "ISR", "IVR", "RXH", "RXM", "RXL",\r\n"DMA", "CDSP", "RFREQ", "RUER/V2", "DATA", "MEMIRQ",\r\n"ACQ", "BIT0", "BIT1", "MIC0", "MIC1", "MIC2",\r\n"MIC3", "INTCSR", "CNTRL", "GPIOC",\r\n"LOFREQ", "HIFREQ", "CSUER", "RUER"\r\n};\r\ndo {\r\nif ((snd_vx_inb(chip, reg) & mask) == bit)\r\nreturn 0;\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printd(KERN_DEBUG "vx_check_reg_bit: timeout, reg=%s, mask=0x%x, val=0x%x\n", reg_names[reg], mask, snd_vx_inb(chip, reg));\r\nreturn -EIO;\r\n}\r\nstatic int vx_send_irq_dsp(struct vx_core *chip, int num)\r\n{\r\nint nirq;\r\nif (snd_vx_check_reg_bit(chip, VX_CVR, CVR_HC, 0, 200) < 0)\r\nreturn -EIO;\r\nnirq = num;\r\nif (vx_has_new_dsp(chip))\r\nnirq += VXP_IRQ_OFFSET;\r\nvx_outb(chip, CVR, (nirq >> 1) | CVR_HC);\r\nreturn 0;\r\n}\r\nstatic int vx_reset_chk(struct vx_core *chip)\r\n{\r\nif (vx_send_irq_dsp(chip, IRQ_RESET_CHK) < 0)\r\nreturn -EIO;\r\nif (vx_check_isr(chip, ISR_CHK, 0, 200) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int vx_transfer_end(struct vx_core *chip, int cmd)\r\n{\r\nint err;\r\nif ((err = vx_reset_chk(chip)) < 0)\r\nreturn err;\r\nif ((err = vx_send_irq_dsp(chip, cmd)) < 0)\r\nreturn err;\r\nif ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)\r\nreturn err;\r\nif ((err = vx_inb(chip, ISR)) & ISR_ERR) {\r\nif ((err = vx_wait_for_rx_full(chip)) < 0) {\r\nsnd_printd(KERN_DEBUG "transfer_end: error in rx_full\n");\r\nreturn err;\r\n}\r\nerr = vx_inb(chip, RXH) << 16;\r\nerr |= vx_inb(chip, RXM) << 8;\r\nerr |= vx_inb(chip, RXL);\r\nsnd_printd(KERN_DEBUG "transfer_end: error = 0x%x\n", err);\r\nreturn -(VX_ERR_MASK | err);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)\r\n{\r\nint i, err, val, size;\r\nif (rmh->DspStat == RMH_SSIZE_FIXED && rmh->LgStat == 0)\r\nreturn 0;\r\nerr = vx_wait_for_rx_full(chip);\r\nif (err < 0)\r\nreturn err;\r\nval = vx_inb(chip, RXH) << 16;\r\nval |= vx_inb(chip, RXM) << 8;\r\nval |= vx_inb(chip, RXL);\r\nswitch (rmh->DspStat) {\r\ncase RMH_SSIZE_ARG:\r\nsize = val & 0xff;\r\nrmh->Stat[0] = val & 0xffff00;\r\nrmh->LgStat = size + 1;\r\nbreak;\r\ncase RMH_SSIZE_MASK:\r\nrmh->Stat[0] = val;\r\nsize = 0;\r\nwhile (val) {\r\nif (val & 0x01)\r\nsize++;\r\nval >>= 1;\r\n}\r\nrmh->LgStat = size + 1;\r\nbreak;\r\ndefault:\r\nsize = rmh->LgStat;\r\nrmh->Stat[0] = val;\r\nsize--;\r\nbreak;\r\n}\r\nif (size < 1)\r\nreturn 0;\r\nif (snd_BUG_ON(size >= SIZE_MAX_STATUS))\r\nreturn -EINVAL;\r\nfor (i = 1; i <= size; i++) {\r\nerr = vx_send_irq_dsp(chip, IRQ_MESS_WRITE_NEXT);\r\nif (err < 0)\r\nreturn err;\r\nerr = vx_wait_for_rx_full(chip);\r\nif (err < 0)\r\nreturn err;\r\nrmh->Stat[i] = vx_inb(chip, RXH) << 16;\r\nrmh->Stat[i] |= vx_inb(chip, RXM) << 8;\r\nrmh->Stat[i] |= vx_inb(chip, RXL);\r\n}\r\nreturn vx_transfer_end(chip, IRQ_MESS_WRITE_END);\r\n}\r\nint vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)\r\n{\r\nint i, err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\nif ((err = vx_reset_chk(chip)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: vx_reset_chk error\n");\r\nreturn err;\r\n}\r\n#if 0\r\nprintk(KERN_DEBUG "rmh: cmd = 0x%06x, length = %d, stype = %d\n",\r\nrmh->Cmd[0], rmh->LgCmd, rmh->DspStat);\r\nif (rmh->LgCmd > 1) {\r\nprintk(KERN_DEBUG " ");\r\nfor (i = 1; i < rmh->LgCmd; i++)\r\nprintk("0x%06x ", rmh->Cmd[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nif (rmh->LgCmd > 1)\r\nrmh->Cmd[0] |= MASK_MORE_THAN_1_WORD_COMMAND;\r\nelse\r\nrmh->Cmd[0] &= MASK_1_WORD_COMMAND;\r\nif ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: wait tx empty error\n");\r\nreturn err;\r\n}\r\nvx_outb(chip, TXH, (rmh->Cmd[0] >> 16) & 0xff);\r\nvx_outb(chip, TXM, (rmh->Cmd[0] >> 8) & 0xff);\r\nvx_outb(chip, TXL, rmh->Cmd[0] & 0xff);\r\nif ((err = vx_send_irq_dsp(chip, IRQ_MESSAGE)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: send IRQ_MESSAGE error\n");\r\nreturn err;\r\n}\r\nif ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)\r\nreturn err;\r\nif (vx_inb(chip, ISR) & ISR_ERR) {\r\nif ((err = vx_wait_for_rx_full(chip)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: rx_full read error\n");\r\nreturn err;\r\n}\r\nerr = vx_inb(chip, RXH) << 16;\r\nerr |= vx_inb(chip, RXM) << 8;\r\nerr |= vx_inb(chip, RXL);\r\nsnd_printd(KERN_DEBUG "msg got error = 0x%x at cmd[0]\n", err);\r\nerr = -(VX_ERR_MASK | err);\r\nreturn err;\r\n}\r\nif (rmh->LgCmd > 1) {\r\nfor (i = 1; i < rmh->LgCmd; i++) {\r\nif ((err = vx_wait_isr_bit(chip, ISR_TX_READY)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: tx_ready error\n");\r\nreturn err;\r\n}\r\nvx_outb(chip, TXH, (rmh->Cmd[i] >> 16) & 0xff);\r\nvx_outb(chip, TXM, (rmh->Cmd[i] >> 8) & 0xff);\r\nvx_outb(chip, TXL, rmh->Cmd[i] & 0xff);\r\nif ((err = vx_send_irq_dsp(chip, IRQ_MESS_READ_NEXT)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: IRQ_READ_NEXT error\n");\r\nreturn err;\r\n}\r\n}\r\nif ((err = vx_wait_isr_bit(chip, ISR_TX_READY)) < 0) {\r\nsnd_printd(KERN_DEBUG "vx_send_msg: TX_READY error\n");\r\nreturn err;\r\n}\r\nerr = vx_transfer_end(chip, IRQ_MESS_READ_END);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn vx_read_status(chip, rmh);\r\n}\r\nint vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh)\r\n{\r\nint err;\r\nmutex_lock(&chip->lock);\r\nerr = vx_send_msg_nolock(chip, rmh);\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nint vx_send_rih_nolock(struct vx_core *chip, int cmd)\r\n{\r\nint err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\n#if 0\r\nprintk(KERN_DEBUG "send_rih: cmd = 0x%x\n", cmd);\r\n#endif\r\nif ((err = vx_reset_chk(chip)) < 0)\r\nreturn err;\r\nif ((err = vx_send_irq_dsp(chip, cmd)) < 0)\r\nreturn err;\r\nif ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)\r\nreturn err;\r\nif (vx_inb(chip, ISR) & ISR_ERR) {\r\nif ((err = vx_wait_for_rx_full(chip)) < 0)\r\nreturn err;\r\nerr = vx_inb(chip, RXH) << 16;\r\nerr |= vx_inb(chip, RXM) << 8;\r\nerr |= vx_inb(chip, RXL);\r\nreturn -(VX_ERR_MASK | err);\r\n}\r\nreturn 0;\r\n}\r\nint vx_send_rih(struct vx_core *chip, int cmd)\r\n{\r\nint err;\r\nmutex_lock(&chip->lock);\r\nerr = vx_send_rih_nolock(chip, cmd);\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nint snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)\r\n{\r\nunsigned int i;\r\nint no_fillup = vx_has_new_dsp(chip);\r\nif (boot->size <= 0)\r\nreturn -EINVAL;\r\nif (boot->size % 3)\r\nreturn -EINVAL;\r\n#if 0\r\n{\r\nunsigned int c = ((u32)boot->data[0] << 16) | ((u32)boot->data[1] << 8) | boot->data[2];\r\nif (boot->size != (c + 2) * 3)\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nvx_reset_dsp(chip);\r\nudelay(END_OF_RESET_WAIT_TIME);\r\nfor (i = 0; i < 0x600; i += 3) {\r\nif (i >= boot->size) {\r\nif (no_fillup)\r\nbreak;\r\nif (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {\r\nsnd_printk(KERN_ERR "dsp boot failed at %d\n", i);\r\nreturn -EIO;\r\n}\r\nvx_outb(chip, TXH, 0);\r\nvx_outb(chip, TXM, 0);\r\nvx_outb(chip, TXL, 0);\r\n} else {\r\nconst unsigned char *image = boot->data + i;\r\nif (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {\r\nsnd_printk(KERN_ERR "dsp boot failed at %d\n", i);\r\nreturn -EIO;\r\n}\r\nvx_outb(chip, TXH, image[0]);\r\nvx_outb(chip, TXM, image[1]);\r\nvx_outb(chip, TXL, image[2]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx_test_irq_src(struct vx_core *chip, unsigned int *ret)\r\n{\r\nint err;\r\nvx_init_rmh(&chip->irq_rmh, CMD_TEST_IT);\r\nmutex_lock(&chip->lock);\r\nerr = vx_send_msg_nolock(chip, &chip->irq_rmh);\r\nif (err < 0)\r\n*ret = 0;\r\nelse\r\n*ret = chip->irq_rmh.Stat[0];\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nirqreturn_t snd_vx_threaded_irq_handler(int irq, void *dev)\r\n{\r\nstruct vx_core *chip = dev;\r\nunsigned int events;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn IRQ_HANDLED;\r\nif (vx_test_irq_src(chip, &events) < 0)\r\nreturn IRQ_HANDLED;\r\n#if 0\r\nif (events & 0x000800)\r\nprintk(KERN_ERR "DSP Stream underrun ! IRQ events = 0x%x\n", events);\r\n#endif\r\nif (events & FATAL_DSP_ERROR) {\r\nsnd_printk(KERN_ERR "vx_core: fatal DSP error!!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (events & TIME_CODE_EVENT_PENDING)\r\n;\r\nif (events & FREQUENCY_CHANGE_EVENT_PENDING)\r\nvx_change_frequency(chip);\r\nvx_pcm_update_intr(chip, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t snd_vx_irq_handler(int irq, void *dev)\r\n{\r\nstruct vx_core *chip = dev;\r\nif (! (chip->chip_status & VX_STAT_CHIP_INIT) ||\r\n(chip->chip_status & VX_STAT_IS_STALE))\r\nreturn IRQ_NONE;\r\nif (! vx_test_and_ack(chip))\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_NONE;\r\n}\r\nstatic void vx_reset_board(struct vx_core *chip, int cold_reset)\r\n{\r\nif (snd_BUG_ON(!chip->ops->reset_board))\r\nreturn;\r\nchip->audio_source = VX_AUDIO_SRC_LINE;\r\nif (cold_reset) {\r\nchip->audio_source_target = chip->audio_source;\r\nchip->clock_source = INTERNAL_QUARTZ;\r\nchip->clock_mode = VX_CLOCK_MODE_AUTO;\r\nchip->freq = 48000;\r\nchip->uer_detected = VX_UER_MODE_NOT_PRESENT;\r\nchip->uer_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\n}\r\nchip->ops->reset_board(chip, cold_reset);\r\nvx_reset_codec(chip, cold_reset);\r\nvx_set_internal_clock(chip, chip->freq);\r\nvx_reset_dsp(chip);\r\nif (vx_is_pcmcia(chip)) {\r\nvx_test_and_ack(chip);\r\nvx_validate_irq(chip, 1);\r\n}\r\nvx_set_iec958_status(chip, chip->uer_bits);\r\n}\r\nstatic void vx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct vx_core *chip = entry->private_data;\r\nstatic char *audio_src_vxp[] = { "Line", "Mic", "Digital" };\r\nstatic char *audio_src_vx2[] = { "Analog", "Analog", "Digital" };\r\nstatic char *clock_mode[] = { "Auto", "Internal", "External" };\r\nstatic char *clock_src[] = { "Internal", "External" };\r\nstatic char *uer_type[] = { "Consumer", "Professional", "Not Present" };\r\nsnd_iprintf(buffer, "%s\n", chip->card->longname);\r\nsnd_iprintf(buffer, "Xilinx Firmware: %s\n",\r\nchip->chip_status & VX_STAT_XILINX_LOADED ? "Loaded" : "No");\r\nsnd_iprintf(buffer, "Device Initialized: %s\n",\r\nchip->chip_status & VX_STAT_DEVICE_INIT ? "Yes" : "No");\r\nsnd_iprintf(buffer, "DSP audio info:");\r\nif (chip->audio_info & VX_AUDIO_INFO_REAL_TIME)\r\nsnd_iprintf(buffer, " realtime");\r\nif (chip->audio_info & VX_AUDIO_INFO_OFFLINE)\r\nsnd_iprintf(buffer, " offline");\r\nif (chip->audio_info & VX_AUDIO_INFO_MPEG1)\r\nsnd_iprintf(buffer, " mpeg1");\r\nif (chip->audio_info & VX_AUDIO_INFO_MPEG2)\r\nsnd_iprintf(buffer, " mpeg2");\r\nif (chip->audio_info & VX_AUDIO_INFO_LINEAR_8)\r\nsnd_iprintf(buffer, " linear8");\r\nif (chip->audio_info & VX_AUDIO_INFO_LINEAR_16)\r\nsnd_iprintf(buffer, " linear16");\r\nif (chip->audio_info & VX_AUDIO_INFO_LINEAR_24)\r\nsnd_iprintf(buffer, " linear24");\r\nsnd_iprintf(buffer, "\n");\r\nsnd_iprintf(buffer, "Input Source: %s\n", vx_is_pcmcia(chip) ?\r\naudio_src_vxp[chip->audio_source] :\r\naudio_src_vx2[chip->audio_source]);\r\nsnd_iprintf(buffer, "Clock Mode: %s\n", clock_mode[chip->clock_mode]);\r\nsnd_iprintf(buffer, "Clock Source: %s\n", clock_src[chip->clock_source]);\r\nsnd_iprintf(buffer, "Frequency: %d\n", chip->freq);\r\nsnd_iprintf(buffer, "Detected Frequency: %d\n", chip->freq_detected);\r\nsnd_iprintf(buffer, "Detected UER type: %s\n", uer_type[chip->uer_detected]);\r\nsnd_iprintf(buffer, "Min/Max/Cur IBL: %d/%d/%d (granularity=%d)\n",\r\nchip->ibl.min_size, chip->ibl.max_size, chip->ibl.size,\r\nchip->ibl.granularity);\r\n}\r\nstatic void vx_proc_init(struct vx_core *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "vx-status", &entry))\r\nsnd_info_set_text_ops(entry, chip, vx_proc_read);\r\n}\r\nint snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *boot)\r\n{\r\nint err;\r\nint cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);\r\nvx_reset_board(chip, cold_reset);\r\nvx_validate_irq(chip, 0);\r\nif ((err = snd_vx_load_boot_image(chip, boot)) < 0)\r\nreturn err;\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nint snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)\r\n{\r\nunsigned int i;\r\nint err;\r\nunsigned int csum = 0;\r\nconst unsigned char *image, *cptr;\r\nif (dsp->size % 3)\r\nreturn -EINVAL;\r\nvx_toggle_dac_mute(chip, 1);\r\nfor (i = 0; i < dsp->size; i += 3) {\r\nimage = dsp->data + i;\r\nif ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {\r\nprintk(KERN_ERR\r\n"dsp loading error at position %d\n", i);\r\nreturn err;\r\n}\r\ncptr = image;\r\ncsum ^= *cptr;\r\ncsum = (csum >> 24) | (csum << 8);\r\nvx_outb(chip, TXH, *cptr++);\r\ncsum ^= *cptr;\r\ncsum = (csum >> 24) | (csum << 8);\r\nvx_outb(chip, TXM, *cptr++);\r\ncsum ^= *cptr;\r\ncsum = (csum >> 24) | (csum << 8);\r\nvx_outb(chip, TXL, *cptr++);\r\n}\r\nsnd_printdd(KERN_DEBUG "checksum = 0x%08x\n", csum);\r\nmsleep(200);\r\nif ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)\r\nreturn err;\r\nvx_toggle_dac_mute(chip, 0);\r\nvx_test_and_ack(chip);\r\nvx_validate_irq(chip, 1);\r\nreturn 0;\r\n}\r\nint snd_vx_suspend(struct vx_core *chip)\r\n{\r\nunsigned int i;\r\nsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\r\nchip->chip_status |= VX_STAT_IN_SUSPEND;\r\nfor (i = 0; i < chip->hw->num_codecs; i++)\r\nsnd_pcm_suspend_all(chip->pcm[i]);\r\nreturn 0;\r\n}\r\nint snd_vx_resume(struct vx_core *chip)\r\n{\r\nint i, err;\r\nchip->chip_status &= ~VX_STAT_CHIP_INIT;\r\nfor (i = 0; i < 4; i++) {\r\nif (! chip->firmware[i])\r\ncontinue;\r\nerr = chip->ops->load_dsp(chip, i, chip->firmware[i]);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "vx: firmware resume error at DSP %d\n", i);\r\nreturn -EIO;\r\n}\r\n}\r\nchip->chip_status |= VX_STAT_CHIP_INIT;\r\nchip->chip_status &= ~VX_STAT_IN_SUSPEND;\r\nsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstruct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,\r\nstruct snd_vx_ops *ops,\r\nint extra_size)\r\n{\r\nstruct vx_core *chip;\r\nif (snd_BUG_ON(!card || !hw || !ops))\r\nreturn NULL;\r\nchip = kzalloc(sizeof(*chip) + extra_size, GFP_KERNEL);\r\nif (! chip) {\r\nsnd_printk(KERN_ERR "vx_core: no memory\n");\r\nreturn NULL;\r\n}\r\nmutex_init(&chip->lock);\r\nchip->irq = -1;\r\nchip->hw = hw;\r\nchip->type = hw->type;\r\nchip->ops = ops;\r\nmutex_init(&chip->mixer_mutex);\r\nchip->card = card;\r\ncard->private_data = chip;\r\nstrcpy(card->driver, hw->name);\r\nsprintf(card->shortname, "Digigram %s", hw->name);\r\nvx_proc_init(chip);\r\nreturn chip;\r\n}\r\nstatic int __init alsa_vx_core_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_vx_core_exit(void)\r\n{\r\n}
