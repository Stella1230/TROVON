int scsi_complete_async_scans(void)\r\n{\r\nstruct async_scan_data *data;\r\ndo {\r\nif (list_empty(&scanning_hosts))\r\nreturn 0;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nmsleep(1);\r\n} while (!data);\r\ndata->shost = NULL;\r\ninit_completion(&data->prev_finished);\r\nspin_lock(&async_scan_lock);\r\nif (list_empty(&scanning_hosts))\r\ngoto done;\r\nlist_add_tail(&data->list, &scanning_hosts);\r\nspin_unlock(&async_scan_lock);\r\nprintk(KERN_INFO "scsi: waiting for bus probes to complete ...\n");\r\nwait_for_completion(&data->prev_finished);\r\nspin_lock(&async_scan_lock);\r\nlist_del(&data->list);\r\nif (!list_empty(&scanning_hosts)) {\r\nstruct async_scan_data *next = list_entry(scanning_hosts.next,\r\nstruct async_scan_data, list);\r\ncomplete(&next->prev_finished);\r\n}\r\ndone:\r\nspin_unlock(&async_scan_lock);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void scsi_unlock_floptical(struct scsi_device *sdev,\r\nunsigned char *result)\r\n{\r\nunsigned char scsi_cmd[MAX_COMMAND_SIZE];\r\nsdev_printk(KERN_NOTICE, sdev, "unlocking floptical drive\n");\r\nscsi_cmd[0] = MODE_SENSE;\r\nscsi_cmd[1] = 0;\r\nscsi_cmd[2] = 0x2e;\r\nscsi_cmd[3] = 0;\r\nscsi_cmd[4] = 0x2a;\r\nscsi_cmd[5] = 0;\r\nscsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE, result, 0x2a, NULL,\r\nSCSI_TIMEOUT, 3, NULL);\r\n}\r\nstatic struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,\r\nu64 lun, void *hostdata)\r\n{\r\nstruct scsi_device *sdev;\r\nint display_failure_msg = 1, ret;\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nextern void scsi_evt_thread(struct work_struct *work);\r\nextern void scsi_requeue_run_queue(struct work_struct *work);\r\nsdev = kzalloc(sizeof(*sdev) + shost->transportt->device_size,\r\nGFP_ATOMIC);\r\nif (!sdev)\r\ngoto out;\r\nsdev->vendor = scsi_null_device_strs;\r\nsdev->model = scsi_null_device_strs;\r\nsdev->rev = scsi_null_device_strs;\r\nsdev->host = shost;\r\nsdev->queue_ramp_up_period = SCSI_DEFAULT_RAMP_UP_PERIOD;\r\nsdev->id = starget->id;\r\nsdev->lun = lun;\r\nsdev->channel = starget->channel;\r\nsdev->sdev_state = SDEV_CREATED;\r\nINIT_LIST_HEAD(&sdev->siblings);\r\nINIT_LIST_HEAD(&sdev->same_target_siblings);\r\nINIT_LIST_HEAD(&sdev->cmd_list);\r\nINIT_LIST_HEAD(&sdev->starved_entry);\r\nINIT_LIST_HEAD(&sdev->event_list);\r\nspin_lock_init(&sdev->list_lock);\r\nINIT_WORK(&sdev->event_work, scsi_evt_thread);\r\nINIT_WORK(&sdev->requeue_work, scsi_requeue_run_queue);\r\nsdev->sdev_gendev.parent = get_device(&starget->dev);\r\nsdev->sdev_target = starget;\r\nsdev->hostdata = hostdata;\r\nsdev->max_device_blocked = SCSI_DEFAULT_DEVICE_BLOCKED;\r\nsdev->type = -1;\r\nsdev->borken = 1;\r\nif (shost_use_blk_mq(shost))\r\nsdev->request_queue = scsi_mq_alloc_queue(sdev);\r\nelse\r\nsdev->request_queue = scsi_alloc_queue(sdev);\r\nif (!sdev->request_queue) {\r\nput_device(&starget->dev);\r\nkfree(sdev);\r\ngoto out;\r\n}\r\nWARN_ON_ONCE(!blk_get_queue(sdev->request_queue));\r\nsdev->request_queue->queuedata = sdev;\r\nif (!shost_use_blk_mq(sdev->host) &&\r\n(shost->bqt || shost->hostt->use_blk_tags)) {\r\nblk_queue_init_tags(sdev->request_queue,\r\nsdev->host->cmd_per_lun, shost->bqt,\r\nshost->hostt->tag_alloc_policy);\r\n}\r\nscsi_change_queue_depth(sdev, sdev->host->cmd_per_lun ?\r\nsdev->host->cmd_per_lun : 1);\r\nscsi_sysfs_device_initialize(sdev);\r\nif (shost->hostt->slave_alloc) {\r\nret = shost->hostt->slave_alloc(sdev);\r\nif (ret) {\r\nif (ret == -ENXIO)\r\ndisplay_failure_msg = 0;\r\ngoto out_device_destroy;\r\n}\r\n}\r\nreturn sdev;\r\nout_device_destroy:\r\n__scsi_remove_device(sdev);\r\nout:\r\nif (display_failure_msg)\r\nprintk(ALLOC_FAILURE_MSG, __func__);\r\nreturn NULL;\r\n}\r\nstatic void scsi_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct device *dev = &starget->dev;\r\nstruct Scsi_Host *shost = dev_to_shost(dev->parent);\r\nunsigned long flags;\r\nstarget->state = STARGET_DEL;\r\ntransport_destroy_device(dev);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (shost->hostt->target_destroy)\r\nshost->hostt->target_destroy(starget);\r\nlist_del_init(&starget->siblings);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nput_device(dev);\r\n}\r\nstatic void scsi_target_dev_release(struct device *dev)\r\n{\r\nstruct device *parent = dev->parent;\r\nstruct scsi_target *starget = to_scsi_target(dev);\r\nkfree(starget);\r\nput_device(parent);\r\n}\r\nint scsi_is_target_device(const struct device *dev)\r\n{\r\nreturn dev->type == &scsi_target_type;\r\n}\r\nstatic struct scsi_target *__scsi_find_target(struct device *parent,\r\nint channel, uint id)\r\n{\r\nstruct scsi_target *starget, *found_starget = NULL;\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nlist_for_each_entry(starget, &shost->__targets, siblings) {\r\nif (starget->id == id &&\r\nstarget->channel == channel) {\r\nfound_starget = starget;\r\nbreak;\r\n}\r\n}\r\nif (found_starget)\r\nget_device(&found_starget->dev);\r\nreturn found_starget;\r\n}\r\nstatic void scsi_target_reap_ref_release(struct kref *kref)\r\n{\r\nstruct scsi_target *starget\r\n= container_of(kref, struct scsi_target, reap_ref);\r\nif (starget->state != STARGET_CREATED) {\r\ntransport_remove_device(&starget->dev);\r\ndevice_del(&starget->dev);\r\n}\r\nscsi_target_destroy(starget);\r\n}\r\nstatic void scsi_target_reap_ref_put(struct scsi_target *starget)\r\n{\r\nkref_put(&starget->reap_ref, scsi_target_reap_ref_release);\r\n}\r\nstatic struct scsi_target *scsi_alloc_target(struct device *parent,\r\nint channel, uint id)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nstruct device *dev = NULL;\r\nunsigned long flags;\r\nconst int size = sizeof(struct scsi_target)\r\n+ shost->transportt->target_size;\r\nstruct scsi_target *starget;\r\nstruct scsi_target *found_target;\r\nint error, ref_got;\r\nstarget = kzalloc(size, GFP_KERNEL);\r\nif (!starget) {\r\nprintk(KERN_ERR "%s: allocation failure\n", __func__);\r\nreturn NULL;\r\n}\r\ndev = &starget->dev;\r\ndevice_initialize(dev);\r\nkref_init(&starget->reap_ref);\r\ndev->parent = get_device(parent);\r\ndev_set_name(dev, "target%d:%d:%d", shost->host_no, channel, id);\r\ndev->bus = &scsi_bus_type;\r\ndev->type = &scsi_target_type;\r\nstarget->id = id;\r\nstarget->channel = channel;\r\nstarget->can_queue = 0;\r\nINIT_LIST_HEAD(&starget->siblings);\r\nINIT_LIST_HEAD(&starget->devices);\r\nstarget->state = STARGET_CREATED;\r\nstarget->scsi_level = SCSI_2;\r\nstarget->max_target_blocked = SCSI_DEFAULT_TARGET_BLOCKED;\r\nretry:\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nfound_target = __scsi_find_target(parent, channel, id);\r\nif (found_target)\r\ngoto found;\r\nlist_add_tail(&starget->siblings, &shost->__targets);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ntransport_setup_device(dev);\r\nif (shost->hostt->target_alloc) {\r\nerror = shost->hostt->target_alloc(starget);\r\nif(error) {\r\ndev_printk(KERN_ERR, dev, "target allocation failed, error %d\n", error);\r\nscsi_target_destroy(starget);\r\nreturn NULL;\r\n}\r\n}\r\nget_device(dev);\r\nreturn starget;\r\nfound:\r\nref_got = kref_get_unless_zero(&found_target->reap_ref);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (ref_got) {\r\nput_device(dev);\r\nreturn found_target;\r\n}\r\nput_device(&found_target->dev);\r\nmsleep(1);\r\ngoto retry;\r\n}\r\nvoid scsi_target_reap(struct scsi_target *starget)\r\n{\r\nBUG_ON(starget->state == STARGET_DEL);\r\nscsi_target_reap_ref_put(starget);\r\n}\r\nstatic void sanitize_inquiry_string(unsigned char *s, int len)\r\n{\r\nint terminated = 0;\r\nfor (; len > 0; (--len, ++s)) {\r\nif (*s == 0)\r\nterminated = 1;\r\nif (terminated || *s < 0x20 || *s > 0x7e)\r\n*s = ' ';\r\n}\r\n}\r\nstatic int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,\r\nint result_len, int *bflags)\r\n{\r\nunsigned char scsi_cmd[MAX_COMMAND_SIZE];\r\nint first_inquiry_len, try_inquiry_len, next_inquiry_len;\r\nint response_len = 0;\r\nint pass, count, result;\r\nstruct scsi_sense_hdr sshdr;\r\n*bflags = 0;\r\nfirst_inquiry_len = sdev->inquiry_len ? sdev->inquiry_len : 36;\r\ntry_inquiry_len = first_inquiry_len;\r\npass = 1;\r\nnext_pass:\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\r\n"scsi scan: INQUIRY pass %d length %d\n",\r\npass, try_inquiry_len));\r\nfor (count = 0; count < 3; ++count) {\r\nint resid;\r\nmemset(scsi_cmd, 0, 6);\r\nscsi_cmd[0] = INQUIRY;\r\nscsi_cmd[4] = (unsigned char) try_inquiry_len;\r\nmemset(inq_result, 0, try_inquiry_len);\r\nresult = scsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE,\r\ninq_result, try_inquiry_len, &sshdr,\r\nHZ / 2 + HZ * scsi_inq_timeout, 3,\r\n&resid);\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\r\n"scsi scan: INQUIRY %s with code 0x%x\n",\r\nresult ? "failed" : "successful", result));\r\nif (result) {\r\nif ((driver_byte(result) & DRIVER_SENSE) &&\r\nscsi_sense_valid(&sshdr)) {\r\nif ((sshdr.sense_key == UNIT_ATTENTION) &&\r\n((sshdr.asc == 0x28) ||\r\n(sshdr.asc == 0x29)) &&\r\n(sshdr.ascq == 0))\r\ncontinue;\r\n}\r\n} else {\r\nif (resid == try_inquiry_len)\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (result == 0) {\r\nsanitize_inquiry_string(&inq_result[8], 8);\r\nsanitize_inquiry_string(&inq_result[16], 16);\r\nsanitize_inquiry_string(&inq_result[32], 4);\r\nresponse_len = inq_result[4] + 5;\r\nif (response_len > 255)\r\nresponse_len = first_inquiry_len;\r\n*bflags = scsi_get_device_flags(sdev, &inq_result[8],\r\n&inq_result[16]);\r\nif (pass == 1) {\r\nif (BLIST_INQUIRY_36 & *bflags)\r\nnext_inquiry_len = 36;\r\nelse if (BLIST_INQUIRY_58 & *bflags)\r\nnext_inquiry_len = 58;\r\nelse if (sdev->inquiry_len)\r\nnext_inquiry_len = sdev->inquiry_len;\r\nelse\r\nnext_inquiry_len = response_len;\r\nif (next_inquiry_len > try_inquiry_len) {\r\ntry_inquiry_len = next_inquiry_len;\r\npass = 2;\r\ngoto next_pass;\r\n}\r\n}\r\n} else if (pass == 2) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"scsi scan: %d byte inquiry failed. "\r\n"Consider BLIST_INQUIRY_36 for this device\n",\r\ntry_inquiry_len);\r\ntry_inquiry_len = first_inquiry_len;\r\npass = 3;\r\ngoto next_pass;\r\n}\r\nif (result)\r\nreturn -EIO;\r\nsdev->inquiry_len = min(try_inquiry_len, response_len);\r\nif (sdev->inquiry_len < 36) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"scsi scan: INQUIRY result too short (%d),"\r\n" using 36\n", sdev->inquiry_len);\r\nsdev->inquiry_len = 36;\r\n}\r\nsdev->scsi_level = inq_result[2] & 0x07;\r\nif (sdev->scsi_level >= 2 ||\r\n(sdev->scsi_level == 1 && (inq_result[3] & 0x0f) == 1))\r\nsdev->scsi_level++;\r\nsdev->sdev_target->scsi_level = sdev->scsi_level;\r\nsdev->lun_in_cdb = 0;\r\nif (sdev->scsi_level <= SCSI_2 &&\r\nsdev->scsi_level != SCSI_UNKNOWN &&\r\n!sdev->host->no_scsi2_lun_in_cdb)\r\nsdev->lun_in_cdb = 1;\r\nreturn 0;\r\n}\r\nstatic int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,\r\nint *bflags, int async)\r\n{\r\nint ret;\r\nsdev->inquiry = kmemdup(inq_result,\r\nmax_t(size_t, sdev->inquiry_len, 36),\r\nGFP_ATOMIC);\r\nif (sdev->inquiry == NULL)\r\nreturn SCSI_SCAN_NO_RESPONSE;\r\nsdev->vendor = (char *) (sdev->inquiry + 8);\r\nsdev->model = (char *) (sdev->inquiry + 16);\r\nsdev->rev = (char *) (sdev->inquiry + 32);\r\nif (strncmp(sdev->vendor, "ATA ", 8) == 0) {\r\nsdev->allow_restart = 1;\r\n}\r\nif (*bflags & BLIST_ISROM) {\r\nsdev->type = TYPE_ROM;\r\nsdev->removable = 1;\r\n} else {\r\nsdev->type = (inq_result[0] & 0x1f);\r\nsdev->removable = (inq_result[1] & 0x80) >> 7;\r\nif (scsi_is_wlun(sdev->lun) && sdev->type != TYPE_WLUN) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: correcting incorrect peripheral device type 0x%x for W-LUN 0x%16xhN\n",\r\n__func__, sdev->type, (unsigned int)sdev->lun);\r\nsdev->type = TYPE_WLUN;\r\n}\r\n}\r\nif (sdev->type == TYPE_RBC || sdev->type == TYPE_ROM) {\r\nif ((*bflags & BLIST_REPORTLUN2) == 0)\r\n*bflags |= BLIST_NOREPORTLUN;\r\n}\r\nsdev->inq_periph_qual = (inq_result[0] >> 5) & 7;\r\nsdev->lockable = sdev->removable;\r\nsdev->soft_reset = (inq_result[7] & 1) && ((inq_result[3] & 7) == 2);\r\nif (sdev->scsi_level >= SCSI_3 ||\r\n(sdev->inquiry_len > 56 && inq_result[56] & 0x04))\r\nsdev->ppr = 1;\r\nif (inq_result[7] & 0x60)\r\nsdev->wdtr = 1;\r\nif (inq_result[7] & 0x10)\r\nsdev->sdtr = 1;\r\nsdev_printk(KERN_NOTICE, sdev, "%s %.8s %.16s %.4s PQ: %d "\r\n"ANSI: %d%s\n", scsi_device_type(sdev->type),\r\nsdev->vendor, sdev->model, sdev->rev,\r\nsdev->inq_periph_qual, inq_result[2] & 0x07,\r\n(inq_result[3] & 0x0f) == 1 ? " CCS" : "");\r\nif ((sdev->scsi_level >= SCSI_2) && (inq_result[7] & 2) &&\r\n!(*bflags & BLIST_NOTQ)) {\r\nsdev->tagged_supported = 1;\r\nsdev->simple_tags = 1;\r\n}\r\nif ((*bflags & BLIST_BORKEN) == 0)\r\nsdev->borken = 0;\r\nif (*bflags & BLIST_NO_ULD_ATTACH)\r\nsdev->no_uld_attach = 1;\r\nif (*bflags & BLIST_SELECT_NO_ATN)\r\nsdev->select_no_atn = 1;\r\nif (*bflags & BLIST_MAX_512)\r\nblk_queue_max_hw_sectors(sdev->request_queue, 512);\r\nelse if (*bflags & BLIST_MAX_1024)\r\nblk_queue_max_hw_sectors(sdev->request_queue, 1024);\r\nif (*bflags & BLIST_NOSTARTONADD)\r\nsdev->no_start_on_add = 1;\r\nif (*bflags & BLIST_SINGLELUN)\r\nscsi_target(sdev)->single_lun = 1;\r\nsdev->use_10_for_rw = 1;\r\nif (*bflags & BLIST_MS_SKIP_PAGE_08)\r\nsdev->skip_ms_page_8 = 1;\r\nif (*bflags & BLIST_MS_SKIP_PAGE_3F)\r\nsdev->skip_ms_page_3f = 1;\r\nif (*bflags & BLIST_USE_10_BYTE_MS)\r\nsdev->use_10_for_ms = 1;\r\nif (*bflags & BLIST_NO_RSOC)\r\nsdev->no_report_opcodes = 1;\r\nret = scsi_device_set_state(sdev, SDEV_RUNNING);\r\nif (ret) {\r\nret = scsi_device_set_state(sdev, SDEV_BLOCK);\r\nif (ret) {\r\nsdev_printk(KERN_ERR, sdev,\r\n"in wrong state %s to complete scan\n",\r\nscsi_device_state_name(sdev->sdev_state));\r\nreturn SCSI_SCAN_NO_RESPONSE;\r\n}\r\n}\r\nif (*bflags & BLIST_MS_192_BYTES_FOR_3F)\r\nsdev->use_192_bytes_for_3f = 1;\r\nif (*bflags & BLIST_NOT_LOCKABLE)\r\nsdev->lockable = 0;\r\nif (*bflags & BLIST_RETRY_HWERROR)\r\nsdev->retry_hwerror = 1;\r\nif (*bflags & BLIST_NO_DIF)\r\nsdev->no_dif = 1;\r\nsdev->eh_timeout = SCSI_DEFAULT_EH_TIMEOUT;\r\nif (*bflags & BLIST_TRY_VPD_PAGES)\r\nsdev->try_vpd_pages = 1;\r\nelse if (*bflags & BLIST_SKIP_VPD_PAGES)\r\nsdev->skip_vpd_pages = 1;\r\ntransport_configure_device(&sdev->sdev_gendev);\r\nif (sdev->host->hostt->slave_configure) {\r\nret = sdev->host->hostt->slave_configure(sdev);\r\nif (ret) {\r\nif (ret != -ENXIO) {\r\nsdev_printk(KERN_ERR, sdev,\r\n"failed to configure device\n");\r\n}\r\nreturn SCSI_SCAN_NO_RESPONSE;\r\n}\r\n}\r\nif (sdev->scsi_level >= SCSI_3)\r\nscsi_attach_vpd(sdev);\r\nsdev->max_queue_depth = sdev->queue_depth;\r\nif (!async && scsi_sysfs_add_sdev(sdev) != 0)\r\nreturn SCSI_SCAN_NO_RESPONSE;\r\nreturn SCSI_SCAN_LUN_PRESENT;\r\n}\r\nstatic unsigned char *scsi_inq_str(unsigned char *buf, unsigned char *inq,\r\nunsigned first, unsigned end)\r\n{\r\nunsigned term = 0, idx;\r\nfor (idx = 0; idx + first < end && idx + first < inq[4] + 5; idx++) {\r\nif (inq[idx+first] > ' ') {\r\nbuf[idx] = inq[idx+first];\r\nterm = idx+1;\r\n} else {\r\nbuf[idx] = ' ';\r\n}\r\n}\r\nbuf[term] = 0;\r\nreturn buf;\r\n}\r\nstatic int scsi_probe_and_add_lun(struct scsi_target *starget,\r\nu64 lun, int *bflagsp,\r\nstruct scsi_device **sdevp, int rescan,\r\nvoid *hostdata)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned char *result;\r\nint bflags, res = SCSI_SCAN_NO_RESPONSE, result_len = 256;\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nsdev = scsi_device_lookup_by_target(starget, lun);\r\nif (sdev) {\r\nif (rescan || !scsi_device_created(sdev)) {\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\r\n"scsi scan: device exists on %s\n",\r\ndev_name(&sdev->sdev_gendev)));\r\nif (sdevp)\r\n*sdevp = sdev;\r\nelse\r\nscsi_device_put(sdev);\r\nif (bflagsp)\r\n*bflagsp = scsi_get_device_flags(sdev,\r\nsdev->vendor,\r\nsdev->model);\r\nreturn SCSI_SCAN_LUN_PRESENT;\r\n}\r\nscsi_device_put(sdev);\r\n} else\r\nsdev = scsi_alloc_sdev(starget, lun, hostdata);\r\nif (!sdev)\r\ngoto out;\r\nresult = kmalloc(result_len, GFP_ATOMIC |\r\n((shost->unchecked_isa_dma) ? __GFP_DMA : 0));\r\nif (!result)\r\ngoto out_free_sdev;\r\nif (scsi_probe_lun(sdev, result, result_len, &bflags))\r\ngoto out_free_result;\r\nif (bflagsp)\r\n*bflagsp = bflags;\r\nif (((result[0] >> 5) == 3) && !(bflags & BLIST_ATTACH_PQ3)) {\r\nSCSI_LOG_SCAN_BUS(2, sdev_printk(KERN_INFO, sdev, "scsi scan:"\r\n" peripheral qualifier of 3, device not"\r\n" added\n"))\r\nif (lun == 0) {\r\nSCSI_LOG_SCAN_BUS(1, {\r\nunsigned char vend[9];\r\nunsigned char mod[17];\r\nsdev_printk(KERN_INFO, sdev,\r\n"scsi scan: consider passing scsi_mod."\r\n"dev_flags=%s:%s:0x240 or 0x1000240\n",\r\nscsi_inq_str(vend, result, 8, 16),\r\nscsi_inq_str(mod, result, 16, 32));\r\n});\r\n}\r\nres = SCSI_SCAN_TARGET_PRESENT;\r\ngoto out_free_result;\r\n}\r\nif (((result[0] >> 5) == 1 || starget->pdt_1f_for_no_lun) &&\r\n(result[0] & 0x1f) == 0x1f &&\r\n!scsi_is_wlun(lun)) {\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\r\n"scsi scan: peripheral device type"\r\n" of 31, no device added\n"));\r\nres = SCSI_SCAN_TARGET_PRESENT;\r\ngoto out_free_result;\r\n}\r\nres = scsi_add_lun(sdev, result, &bflags, shost->async_scan);\r\nif (res == SCSI_SCAN_LUN_PRESENT) {\r\nif (bflags & BLIST_KEY) {\r\nsdev->lockable = 0;\r\nscsi_unlock_floptical(sdev, result);\r\n}\r\n}\r\nout_free_result:\r\nkfree(result);\r\nout_free_sdev:\r\nif (res == SCSI_SCAN_LUN_PRESENT) {\r\nif (sdevp) {\r\nif (scsi_device_get(sdev) == 0) {\r\n*sdevp = sdev;\r\n} else {\r\n__scsi_remove_device(sdev);\r\nres = SCSI_SCAN_NO_RESPONSE;\r\n}\r\n}\r\n} else\r\n__scsi_remove_device(sdev);\r\nout:\r\nreturn res;\r\n}\r\nstatic void scsi_sequential_lun_scan(struct scsi_target *starget,\r\nint bflags, int scsi_level, int rescan)\r\n{\r\nuint max_dev_lun;\r\nu64 sparse_lun, lun;\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nSCSI_LOG_SCAN_BUS(3, starget_printk(KERN_INFO, starget,\r\n"scsi scan: Sequential scan\n"));\r\nmax_dev_lun = min(max_scsi_luns, shost->max_lun);\r\nif (bflags & BLIST_SPARSELUN) {\r\nmax_dev_lun = shost->max_lun;\r\nsparse_lun = 1;\r\n} else\r\nsparse_lun = 0;\r\nif (bflags & BLIST_FORCELUN)\r\nmax_dev_lun = shost->max_lun;\r\nif (bflags & BLIST_MAX5LUN)\r\nmax_dev_lun = min(5U, max_dev_lun);\r\nif (scsi_level < SCSI_3 && !(bflags & BLIST_LARGELUN))\r\nmax_dev_lun = min(8U, max_dev_lun);\r\nif (!(bflags & BLIST_SCSI3LUN))\r\nmax_dev_lun = min(256U, max_dev_lun);\r\nfor (lun = 1; lun < max_dev_lun; ++lun)\r\nif ((scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan,\r\nNULL) != SCSI_SCAN_LUN_PRESENT) &&\r\n!sparse_lun)\r\nreturn;\r\n}\r\nstatic int scsi_report_lun_scan(struct scsi_target *starget, int bflags,\r\nint rescan)\r\n{\r\nchar devname[64];\r\nunsigned char scsi_cmd[MAX_COMMAND_SIZE];\r\nunsigned int length;\r\nu64 lun;\r\nunsigned int num_luns;\r\nunsigned int retries;\r\nint result;\r\nstruct scsi_lun *lunp, *lun_data;\r\nstruct scsi_sense_hdr sshdr;\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nint ret = 0;\r\nif (bflags & BLIST_NOREPORTLUN)\r\nreturn 1;\r\nif (starget->scsi_level < SCSI_2 &&\r\nstarget->scsi_level != SCSI_UNKNOWN)\r\nreturn 1;\r\nif (starget->scsi_level < SCSI_3 &&\r\n(!(bflags & BLIST_REPORTLUN2) || shost->max_lun <= 8))\r\nreturn 1;\r\nif (bflags & BLIST_NOLUN)\r\nreturn 0;\r\nif (starget->no_report_luns)\r\nreturn 1;\r\nif (!(sdev = scsi_device_lookup_by_target(starget, 0))) {\r\nsdev = scsi_alloc_sdev(starget, 0, NULL);\r\nif (!sdev)\r\nreturn 0;\r\nif (scsi_device_get(sdev)) {\r\n__scsi_remove_device(sdev);\r\nreturn 0;\r\n}\r\n}\r\nsprintf(devname, "host %d channel %d id %d",\r\nshost->host_no, sdev->channel, sdev->id);\r\nlength = (511 + 1) * sizeof(struct scsi_lun);\r\nretry:\r\nlun_data = kmalloc(length, GFP_KERNEL |\r\n(sdev->host->unchecked_isa_dma ? __GFP_DMA : 0));\r\nif (!lun_data) {\r\nprintk(ALLOC_FAILURE_MSG, __func__);\r\ngoto out;\r\n}\r\nscsi_cmd[0] = REPORT_LUNS;\r\nmemset(&scsi_cmd[1], 0, 5);\r\nput_unaligned_be32(length, &scsi_cmd[6]);\r\nscsi_cmd[10] = 0;\r\nscsi_cmd[11] = 0;\r\nfor (retries = 0; retries < 3; retries++) {\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\r\n"scsi scan: Sending REPORT LUNS to (try %d)\n",\r\nretries));\r\nresult = scsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE,\r\nlun_data, length, &sshdr,\r\nSCSI_TIMEOUT + 4 * HZ, 3, NULL);\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\r\n"scsi scan: REPORT LUNS"\r\n" %s (try %d) result 0x%x\n",\r\nresult ? "failed" : "successful",\r\nretries, result));\r\nif (result == 0)\r\nbreak;\r\nelse if (scsi_sense_valid(&sshdr)) {\r\nif (sshdr.sense_key != UNIT_ATTENTION)\r\nbreak;\r\n}\r\n}\r\nif (result) {\r\nret = 1;\r\ngoto out_err;\r\n}\r\nif (get_unaligned_be32(lun_data->scsi_lun) +\r\nsizeof(struct scsi_lun) > length) {\r\nlength = get_unaligned_be32(lun_data->scsi_lun) +\r\nsizeof(struct scsi_lun);\r\nkfree(lun_data);\r\ngoto retry;\r\n}\r\nlength = get_unaligned_be32(lun_data->scsi_lun);\r\nnum_luns = (length / sizeof(struct scsi_lun));\r\nSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\r\n"scsi scan: REPORT LUN scan\n"));\r\nfor (lunp = &lun_data[1]; lunp <= &lun_data[num_luns]; lunp++) {\r\nlun = scsilun_to_int(lunp);\r\nif (lun > sdev->host->max_lun) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"lun%llu has a LUN larger than"\r\n" allowed by the host adapter\n", lun);\r\n} else {\r\nint res;\r\nres = scsi_probe_and_add_lun(starget,\r\nlun, NULL, NULL, rescan, NULL);\r\nif (res == SCSI_SCAN_NO_RESPONSE) {\r\nsdev_printk(KERN_ERR, sdev,\r\n"Unexpected response"\r\n" from lun %llu while scanning, scan"\r\n" aborted\n", (unsigned long long)lun);\r\nbreak;\r\n}\r\n}\r\n}\r\nout_err:\r\nkfree(lun_data);\r\nout:\r\nscsi_device_put(sdev);\r\nif (scsi_device_created(sdev))\r\n__scsi_remove_device(sdev);\r\nreturn ret;\r\n}\r\nstruct scsi_device *__scsi_add_device(struct Scsi_Host *shost, uint channel,\r\nuint id, u64 lun, void *hostdata)\r\n{\r\nstruct scsi_device *sdev = ERR_PTR(-ENODEV);\r\nstruct device *parent = &shost->shost_gendev;\r\nstruct scsi_target *starget;\r\nif (strncmp(scsi_scan_type, "none", 4) == 0)\r\nreturn ERR_PTR(-ENODEV);\r\nstarget = scsi_alloc_target(parent, channel, id);\r\nif (!starget)\r\nreturn ERR_PTR(-ENOMEM);\r\nscsi_autopm_get_target(starget);\r\nmutex_lock(&shost->scan_mutex);\r\nif (!shost->async_scan)\r\nscsi_complete_async_scans();\r\nif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\r\nscsi_probe_and_add_lun(starget, lun, NULL, &sdev, 1, hostdata);\r\nscsi_autopm_put_host(shost);\r\n}\r\nmutex_unlock(&shost->scan_mutex);\r\nscsi_autopm_put_target(starget);\r\nscsi_target_reap(starget);\r\nput_device(&starget->dev);\r\nreturn sdev;\r\n}\r\nint scsi_add_device(struct Scsi_Host *host, uint channel,\r\nuint target, u64 lun)\r\n{\r\nstruct scsi_device *sdev =\r\n__scsi_add_device(host, channel, target, lun, NULL);\r\nif (IS_ERR(sdev))\r\nreturn PTR_ERR(sdev);\r\nscsi_device_put(sdev);\r\nreturn 0;\r\n}\r\nvoid scsi_rescan_device(struct device *dev)\r\n{\r\ndevice_lock(dev);\r\nif (dev->driver && try_module_get(dev->driver->owner)) {\r\nstruct scsi_driver *drv = to_scsi_driver(dev->driver);\r\nif (drv->rescan)\r\ndrv->rescan(dev);\r\nmodule_put(dev->driver->owner);\r\n}\r\ndevice_unlock(dev);\r\n}\r\nstatic void __scsi_scan_target(struct device *parent, unsigned int channel,\r\nunsigned int id, u64 lun, int rescan)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nint bflags = 0;\r\nint res;\r\nstruct scsi_target *starget;\r\nif (shost->this_id == id)\r\nreturn;\r\nstarget = scsi_alloc_target(parent, channel, id);\r\nif (!starget)\r\nreturn;\r\nscsi_autopm_get_target(starget);\r\nif (lun != SCAN_WILD_CARD) {\r\nscsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan, NULL);\r\ngoto out_reap;\r\n}\r\nres = scsi_probe_and_add_lun(starget, 0, &bflags, NULL, rescan, NULL);\r\nif (res == SCSI_SCAN_LUN_PRESENT || res == SCSI_SCAN_TARGET_PRESENT) {\r\nif (scsi_report_lun_scan(starget, bflags, rescan) != 0)\r\nscsi_sequential_lun_scan(starget, bflags,\r\nstarget->scsi_level, rescan);\r\n}\r\nout_reap:\r\nscsi_autopm_put_target(starget);\r\nscsi_target_reap(starget);\r\nput_device(&starget->dev);\r\n}\r\nvoid scsi_scan_target(struct device *parent, unsigned int channel,\r\nunsigned int id, u64 lun, int rescan)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nif (strncmp(scsi_scan_type, "none", 4) == 0)\r\nreturn;\r\nmutex_lock(&shost->scan_mutex);\r\nif (!shost->async_scan)\r\nscsi_complete_async_scans();\r\nif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\r\n__scsi_scan_target(parent, channel, id, lun, rescan);\r\nscsi_autopm_put_host(shost);\r\n}\r\nmutex_unlock(&shost->scan_mutex);\r\n}\r\nstatic void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,\r\nunsigned int id, u64 lun, int rescan)\r\n{\r\nuint order_id;\r\nif (id == SCAN_WILD_CARD)\r\nfor (id = 0; id < shost->max_id; ++id) {\r\nif (shost->reverse_ordering)\r\norder_id = shost->max_id - id - 1;\r\nelse\r\norder_id = id;\r\n__scsi_scan_target(&shost->shost_gendev, channel,\r\norder_id, lun, rescan);\r\n}\r\nelse\r\n__scsi_scan_target(&shost->shost_gendev, channel,\r\nid, lun, rescan);\r\n}\r\nint scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,\r\nunsigned int id, u64 lun, int rescan)\r\n{\r\nSCSI_LOG_SCAN_BUS(3, shost_printk (KERN_INFO, shost,\r\n"%s: <%u:%u:%llu>\n",\r\n__func__, channel, id, lun));\r\nif (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||\r\n((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||\r\n((lun != SCAN_WILD_CARD) && (lun >= shost->max_lun)))\r\nreturn -EINVAL;\r\nmutex_lock(&shost->scan_mutex);\r\nif (!shost->async_scan)\r\nscsi_complete_async_scans();\r\nif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\r\nif (channel == SCAN_WILD_CARD)\r\nfor (channel = 0; channel <= shost->max_channel;\r\nchannel++)\r\nscsi_scan_channel(shost, channel, id, lun,\r\nrescan);\r\nelse\r\nscsi_scan_channel(shost, channel, id, lun, rescan);\r\nscsi_autopm_put_host(shost);\r\n}\r\nmutex_unlock(&shost->scan_mutex);\r\nreturn 0;\r\n}\r\nstatic void scsi_sysfs_add_devices(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nif (sdev->sdev_state == SDEV_DEL)\r\ncontinue;\r\nif (sdev->is_visible)\r\ncontinue;\r\nif (!scsi_host_scan_allowed(shost) ||\r\nscsi_sysfs_add_sdev(sdev) != 0)\r\n__scsi_remove_device(sdev);\r\n}\r\n}\r\nstatic struct async_scan_data *scsi_prep_async_scan(struct Scsi_Host *shost)\r\n{\r\nstruct async_scan_data *data;\r\nunsigned long flags;\r\nif (strncmp(scsi_scan_type, "sync", 4) == 0)\r\nreturn NULL;\r\nif (shost->async_scan) {\r\nshost_printk(KERN_INFO, shost, "%s called twice\n", __func__);\r\ndump_stack();\r\nreturn NULL;\r\n}\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto err;\r\ndata->shost = scsi_host_get(shost);\r\nif (!data->shost)\r\ngoto err;\r\ninit_completion(&data->prev_finished);\r\nmutex_lock(&shost->scan_mutex);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->async_scan = 1;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nmutex_unlock(&shost->scan_mutex);\r\nspin_lock(&async_scan_lock);\r\nif (list_empty(&scanning_hosts))\r\ncomplete(&data->prev_finished);\r\nlist_add_tail(&data->list, &scanning_hosts);\r\nspin_unlock(&async_scan_lock);\r\nreturn data;\r\nerr:\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nstatic void scsi_finish_async_scan(struct async_scan_data *data)\r\n{\r\nstruct Scsi_Host *shost;\r\nunsigned long flags;\r\nif (!data)\r\nreturn;\r\nshost = data->shost;\r\nmutex_lock(&shost->scan_mutex);\r\nif (!shost->async_scan) {\r\nshost_printk(KERN_INFO, shost, "%s called twice\n", __func__);\r\ndump_stack();\r\nmutex_unlock(&shost->scan_mutex);\r\nreturn;\r\n}\r\nwait_for_completion(&data->prev_finished);\r\nscsi_sysfs_add_devices(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->async_scan = 0;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nmutex_unlock(&shost->scan_mutex);\r\nspin_lock(&async_scan_lock);\r\nlist_del(&data->list);\r\nif (!list_empty(&scanning_hosts)) {\r\nstruct async_scan_data *next = list_entry(scanning_hosts.next,\r\nstruct async_scan_data, list);\r\ncomplete(&next->prev_finished);\r\n}\r\nspin_unlock(&async_scan_lock);\r\nscsi_autopm_put_host(shost);\r\nscsi_host_put(shost);\r\nkfree(data);\r\n}\r\nstatic void do_scsi_scan_host(struct Scsi_Host *shost)\r\n{\r\nif (shost->hostt->scan_finished) {\r\nunsigned long start = jiffies;\r\nif (shost->hostt->scan_start)\r\nshost->hostt->scan_start(shost);\r\nwhile (!shost->hostt->scan_finished(shost, jiffies - start))\r\nmsleep(10);\r\n} else {\r\nscsi_scan_host_selected(shost, SCAN_WILD_CARD, SCAN_WILD_CARD,\r\nSCAN_WILD_CARD, 0);\r\n}\r\n}\r\nstatic void do_scan_async(void *_data, async_cookie_t c)\r\n{\r\nstruct async_scan_data *data = _data;\r\nstruct Scsi_Host *shost = data->shost;\r\ndo_scsi_scan_host(shost);\r\nscsi_finish_async_scan(data);\r\n}\r\nvoid scsi_scan_host(struct Scsi_Host *shost)\r\n{\r\nstruct async_scan_data *data;\r\nif (strncmp(scsi_scan_type, "none", 4) == 0)\r\nreturn;\r\nif (scsi_autopm_get_host(shost) < 0)\r\nreturn;\r\ndata = scsi_prep_async_scan(shost);\r\nif (!data) {\r\ndo_scsi_scan_host(shost);\r\nscsi_autopm_put_host(shost);\r\nreturn;\r\n}\r\nasync_schedule(do_scan_async, data);\r\n}\r\nvoid scsi_forget_host(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nrestart:\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry(sdev, &shost->__devices, siblings) {\r\nif (sdev->sdev_state == SDEV_DEL)\r\ncontinue;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n__scsi_remove_device(sdev);\r\ngoto restart;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstruct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev = NULL;\r\nstruct scsi_target *starget;\r\nmutex_lock(&shost->scan_mutex);\r\nif (!scsi_host_scan_allowed(shost))\r\ngoto out;\r\nstarget = scsi_alloc_target(&shost->shost_gendev, 0, shost->this_id);\r\nif (!starget)\r\ngoto out;\r\nsdev = scsi_alloc_sdev(starget, 0, NULL);\r\nif (sdev)\r\nsdev->borken = 0;\r\nelse\r\nscsi_target_reap(starget);\r\nput_device(&starget->dev);\r\nout:\r\nmutex_unlock(&shost->scan_mutex);\r\nreturn sdev;\r\n}\r\nvoid scsi_free_host_dev(struct scsi_device *sdev)\r\n{\r\nBUG_ON(sdev->id != sdev->host->this_id);\r\n__scsi_remove_device(sdev);\r\n}
