static inline u32 pmx_read(struct tz1090_pdc_pmx *pmx, u32 reg)\r\n{\r\nreturn ioread32(pmx->regs + reg);\r\n}\r\nstatic inline void pmx_write(struct tz1090_pdc_pmx *pmx, u32 val, u32 reg)\r\n{\r\niowrite32(val, pmx->regs + reg);\r\n}\r\nstatic int tz1090_pdc_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(tz1090_pdc_groups);\r\n}\r\nstatic const char *tz1090_pdc_pinctrl_get_group_name(struct pinctrl_dev *pctl,\r\nunsigned int group)\r\n{\r\nreturn tz1090_pdc_groups[group].name;\r\n}\r\nstatic int tz1090_pdc_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\n*pins = tz1090_pdc_groups[group].pins;\r\n*num_pins = tz1090_pdc_groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void tz1090_pdc_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned int offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int reserve_map(struct device *dev, struct pinctrl_map **map,\r\nunsigned int *reserved_maps, unsigned int *num_maps,\r\nunsigned int reserve)\r\n{\r\nunsigned int old_num = *reserved_maps;\r\nunsigned int new_num = *num_maps + reserve;\r\nstruct pinctrl_map *new_map;\r\nif (old_num >= new_num)\r\nreturn 0;\r\nnew_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);\r\nif (!new_map) {\r\ndev_err(dev, "krealloc(map) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\r\n*map = new_map;\r\n*reserved_maps = new_num;\r\nreturn 0;\r\n}\r\nstatic int add_map_mux(struct pinctrl_map **map, unsigned int *reserved_maps,\r\nunsigned int *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int get_group_selector(const char *pin_group)\r\n{\r\nunsigned int group;\r\nfor (group = 0; group < ARRAY_SIZE(tz1090_pdc_groups); ++group)\r\nif (!strcmp(tz1090_pdc_groups[group].name, pin_group))\r\nreturn group;\r\nreturn -EINVAL;\r\n}\r\nstatic int add_map_configs(struct device *dev,\r\nstruct pinctrl_map **map,\r\nunsigned int *reserved_maps, unsigned int *num_maps,\r\nconst char *group, unsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nenum pinctrl_map_type type;\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs) {\r\ndev_err(dev, "kmemdup(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (get_group_selector(group) >= 0)\r\ntype = PIN_MAP_TYPE_CONFIGS_GROUP;\r\nelse\r\ntype = PIN_MAP_TYPE_CONFIGS_PIN;\r\n(*map)[*num_maps].type = type;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic void tz1090_pdc_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned int num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\nkfree(map);\r\n}\r\nstatic int tz1090_pdc_pinctrl_dt_subnode_to_map(struct device *dev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned int *reserved_maps,\r\nunsigned int *num_maps)\r\n{\r\nint ret;\r\nconst char *function;\r\nunsigned long *configs = NULL;\r\nunsigned int num_configs = 0;\r\nunsigned int reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nret = of_property_read_string(np, "tz1090,function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev,\r\n"could not parse property function\n");\r\nfunction = NULL;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\r\nif (ret)\r\nreturn ret;\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "tz1090,pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = reserve_map(dev, map, reserved_maps, num_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "tz1090,pins", prop, group) {\r\nif (function) {\r\nret = add_map_mux(map, reserved_maps, num_maps,\r\ngroup, function);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = add_map_configs(dev, map, reserved_maps,\r\nnum_maps, group, configs,\r\nnum_configs);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int tz1090_pdc_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned int *num_maps)\r\n{\r\nunsigned int reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = tz1090_pdc_pinctrl_dt_subnode_to_map(pctldev->dev, np,\r\nmap, &reserved_maps,\r\nnum_maps);\r\nif (ret < 0) {\r\ntz1090_pdc_pinctrl_dt_free_map(pctldev, *map,\r\n*num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(tz1090_pdc_functions);\r\n}\r\nstatic const char *tz1090_pdc_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned int function)\r\n{\r\nreturn tz1090_pdc_functions[function].name;\r\n}\r\nstatic int tz1090_pdc_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned int function,\r\nconst char * const **groups,\r\nunsigned int * const num_groups)\r\n{\r\n*groups = tz1090_pdc_functions[function].groups;\r\n*num_groups = tz1090_pdc_functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic void tz1090_pdc_pinctrl_mux(struct tz1090_pdc_pmx *pmx,\r\nconst struct tz1090_pdc_pingroup *grp)\r\n{\r\nu32 reg, select;\r\nunsigned int pin_shift = grp->pins[0];\r\nunsigned long flags;\r\nselect = ((pmx->mux_en & ~pmx->gpio_en) >> pin_shift) & 1;\r\n__global_lock2(flags);\r\nreg = pmx_read(pmx, grp->reg);\r\nreg &= ~BIT(grp->bit);\r\nreg |= select << grp->bit;\r\npmx_write(pmx, reg, grp->reg);\r\n__global_unlock2(flags);\r\n}\r\nstatic int tz1090_pdc_pinctrl_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned int function,\r\nunsigned int group)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pdc_pingroup *grp = &tz1090_pdc_groups[group];\r\ndev_dbg(pctldev->dev, "%s(func=%u (%s), group=%u (%s))\n",\r\n__func__,\r\nfunction, tz1090_pdc_functions[function].name,\r\ngroup, tz1090_pdc_groups[group].name);\r\nif (grp->drv)\r\nreturn -EINVAL;\r\nif (function != grp->func)\r\nreturn -EINVAL;\r\nspin_lock(&pmx->lock);\r\npmx->mux_en |= BIT(grp->pins[0]);\r\ntz1090_pdc_pinctrl_mux(pmx, grp);\r\nspin_unlock(&pmx->lock);\r\nreturn 0;\r\n}\r\nstatic const struct tz1090_pdc_pingroup *find_mux_group(\r\nstruct tz1090_pdc_pmx *pmx,\r\nunsigned int pin)\r\n{\r\nconst struct tz1090_pdc_pingroup *grp;\r\nunsigned int group;\r\ngrp = tz1090_pdc_groups;\r\nfor (group = 0; group < ARRAY_SIZE(tz1090_pdc_groups); ++group, ++grp) {\r\nif (grp->drv)\r\ncontinue;\r\nif (grp->pins[0] == pin)\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int tz1090_pdc_pinctrl_gpio_request_enable(\r\nstruct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pdc_pingroup *grp = find_mux_group(pmx, pin);\r\nif (grp) {\r\nspin_lock(&pmx->lock);\r\npmx->gpio_en |= BIT(pin);\r\ntz1090_pdc_pinctrl_mux(pmx, grp);\r\nspin_unlock(&pmx->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tz1090_pdc_pinctrl_gpio_disable_free(\r\nstruct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pdc_pingroup *grp = find_mux_group(pmx, pin);\r\nif (grp) {\r\nspin_lock(&pmx->lock);\r\npmx->gpio_en &= ~BIT(pin);\r\ntz1090_pdc_pinctrl_mux(pmx, grp);\r\nspin_unlock(&pmx->lock);\r\n}\r\n}\r\nstatic int tz1090_pdc_pinconf_reg(struct pinctrl_dev *pctldev,\r\nunsigned int pin,\r\nenum pin_config_param param,\r\nbool report_err,\r\nu32 *reg, u32 *width, u32 *mask, u32 *shift,\r\nu32 *val)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\n*val = REG_PU_PD_TRISTATE;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\n*val = REG_PU_PD_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\n*val = REG_PU_PD_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\n*val = REG_PU_PD_REPEATER;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\n*reg = REG_GPIO_CONTROL2;\r\n*shift = REG_GPIO_CONTROL2_PU_PD_S + pin*2;\r\n*width = 2;\r\n*mask = (BIT(*width) - 1) << *shift;\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *config)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nint ret;\r\nu32 reg, width, mask, shift, val, tmp, arg;\r\nret = tz1090_pdc_pinconf_reg(pctldev, pin, param, true,\r\n&reg, &width, &mask, &shift, &val);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = pmx_read(pmx, reg);\r\narg = ((tmp & mask) >> shift) == val;\r\nif (!arg)\r\nreturn -EINVAL;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nunsigned int arg;\r\nint ret;\r\nu32 reg, width, mask, shift, val, tmp;\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\ndev_dbg(pctldev->dev, "%s(pin=%s, config=%#lx)\n",\r\n__func__, tz1090_pdc_pins[pin].name, configs[i]);\r\nret = tz1090_pdc_pinconf_reg(pctldev, pin, param, true,\r\n&reg, &width, &mask, &shift, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (arg > 1) {\r\ndev_dbg(pctldev->dev, "%s: arg %u out of range\n",\r\n__func__, arg);\r\nreturn -EINVAL;\r\n}\r\n__global_lock2(flags);\r\ntmp = pmx_read(pmx, reg);\r\ntmp &= ~mask;\r\nif (arg)\r\ntmp |= val << shift;\r\npmx_write(pmx, tmp, reg);\r\n__global_unlock2(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinconf_group_reg(struct pinctrl_dev *pctldev,\r\nconst struct tz1090_pdc_pingroup *g,\r\nenum pin_config_param param,\r\nbool report_err, u32 *reg, u32 *width,\r\nu32 *mask, u32 *shift, const int **map)\r\n{\r\nif (!g->drv) {\r\nif (report_err)\r\ndev_dbg(pctldev->dev,\r\n"%s: group %s has no drive control\n",\r\n__func__, g->name);\r\nreturn -ENOTSUPP;\r\n}\r\n*reg = REG_GPIO_CONTROL2;\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\n*shift = REG_GPIO_CONTROL2_PDC_SCHMITT_S;\r\n*width = 1;\r\n*map = tz1090_pdc_boolean_map;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\n*shift = REG_GPIO_CONTROL2_PDC_DR_S;\r\n*width = 2;\r\n*map = tz1090_pdc_dr_map;\r\nbreak;\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\n*shift = REG_GPIO_CONTROL2_PDC_POS_S;\r\n*width = 1;\r\n*map = tz1090_pdc_boolean_map;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\n*mask = (BIT(*width) - 1) << *shift;\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nunsigned long *config)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pdc_pingroup *g = &tz1090_pdc_groups[group];\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nint ret, arg;\r\nu32 reg, width, mask, shift, val;\r\nconst int *map;\r\nret = tz1090_pdc_pinconf_group_reg(pctldev, g, param, true,\r\n&reg, &width, &mask, &shift, &map);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_read(pmx, reg);\r\narg = map[(val & mask) >> shift];\r\nif (arg < 0)\r\nreturn arg;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pdc_pingroup *g = &tz1090_pdc_groups[group];\r\nenum pin_config_param param;\r\nconst unsigned int *pit;\r\nunsigned int i;\r\nint ret, arg;\r\nu32 reg, width, mask, shift, val;\r\nunsigned long flags;\r\nconst int *map;\r\nint j;\r\nfor (j = 0; j < num_configs; j++) {\r\nparam = pinconf_to_config_param(configs[j]);\r\ndev_dbg(pctldev->dev, "%s(group=%s, config=%#lx)\n",\r\n__func__, g->name, configs[j]);\r\nret = tz1090_pdc_pinconf_group_reg(pctldev, g, param, true,\r\n&reg, &width, &mask, &shift,\r\n&map);\r\nif (ret < 0) {\r\nfor (i = 0, pit = g->pins; i < g->npins; ++i, ++pit) {\r\nret = tz1090_pdc_pinconf_set(pctldev, *pit,\r\nconfigs, num_configs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\narg = pinconf_to_config_argument(configs[j]);\r\nfor (i = 0; i < BIT(width); ++i) {\r\nif (map[i] == arg || (map[i] == -EINVAL && !arg)) {\r\n__global_lock2(flags);\r\nval = pmx_read(pmx, reg);\r\nval &= ~mask;\r\nval |= i << shift;\r\npmx_write(pmx, val, reg);\r\n__global_unlock2(flags);\r\ngoto next_config;\r\n}\r\n}\r\ndev_dbg(pctldev->dev, "%s: arg %u not supported\n",\r\n__func__, arg);\r\nreturn 0;\r\nnext_config:\r\n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct tz1090_pdc_pmx *pmx;\r\nstruct resource *res;\r\npmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx) {\r\ndev_err(&pdev->dev, "Can't alloc tz1090_pdc_pmx\n");\r\nreturn -ENOMEM;\r\n}\r\npmx->dev = &pdev->dev;\r\nspin_lock_init(&pmx->lock);\r\ntz1090_pdc_pinctrl_desc.name = dev_name(&pdev->dev);\r\ntz1090_pdc_pinctrl_desc.pins = tz1090_pdc_pins;\r\ntz1090_pdc_pinctrl_desc.npins = ARRAY_SIZE(tz1090_pdc_pins);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npmx->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pmx->regs))\r\nreturn PTR_ERR(pmx->regs);\r\npmx->pctl = pinctrl_register(&tz1090_pdc_pinctrl_desc, &pdev->dev, pmx);\r\nif (IS_ERR(pmx->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pmx->pctl);\r\n}\r\nplatform_set_drvdata(pdev, pmx);\r\ndev_info(&pdev->dev, "TZ1090 PDC pinctrl driver initialised\n");\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct tz1090_pdc_pmx *pmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(pmx->pctl);\r\nreturn 0;\r\n}\r\nstatic int __init tz1090_pdc_pinctrl_init(void)\r\n{\r\nreturn platform_driver_register(&tz1090_pdc_pinctrl_driver);\r\n}\r\nstatic void __exit tz1090_pdc_pinctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&tz1090_pdc_pinctrl_driver);\r\n}
