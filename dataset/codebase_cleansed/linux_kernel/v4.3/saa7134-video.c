static struct saa7134_format* format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < FORMATS; i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nstatic void set_tvnorm(struct saa7134_dev *dev, struct saa7134_tvnorm *norm)\r\n{\r\nvideo_dbg("set tv norm = %s\n", norm->name);\r\ndev->tvnorm = norm;\r\ndev->crop_bounds.left = norm->h_start;\r\ndev->crop_defrect.left = norm->h_start;\r\ndev->crop_bounds.width = norm->h_stop - norm->h_start +1;\r\ndev->crop_defrect.width = norm->h_stop - norm->h_start +1;\r\ndev->crop_bounds.top = (norm->vbi_v_stop_0+1)*2;\r\ndev->crop_defrect.top = norm->video_v_start*2;\r\ndev->crop_bounds.height = ((norm->id & V4L2_STD_525_60) ? 524 : 624)\r\n- dev->crop_bounds.top;\r\ndev->crop_defrect.height = (norm->video_v_stop - norm->video_v_start +1)*2;\r\ndev->crop_current = dev->crop_defrect;\r\nsaa7134_set_tvnorm_hw(dev);\r\n}\r\nstatic void video_mux(struct saa7134_dev *dev, int input)\r\n{\r\nvideo_dbg("video input = %d [%s]\n", input, card_in(dev, input).name);\r\ndev->ctl_input = input;\r\nset_tvnorm(dev, dev->tvnorm);\r\nsaa7134_tvaudio_setinput(dev, &card_in(dev, input));\r\n}\r\nstatic void saa7134_set_decoder(struct saa7134_dev *dev)\r\n{\r\nint luma_control, sync_control, chroma_ctrl1, mux;\r\nstruct saa7134_tvnorm *norm = dev->tvnorm;\r\nmux = card_in(dev, dev->ctl_input).vmux;\r\nluma_control = norm->luma_control;\r\nsync_control = norm->sync_control;\r\nchroma_ctrl1 = norm->chroma_ctrl1;\r\nif (mux > 5)\r\nluma_control |= 0x80;\r\nif (noninterlaced || dev->nosignal)\r\nsync_control |= 0x20;\r\nsync_control |= SAA7134_SYNC_CTRL_AUFD;\r\nchroma_ctrl1 |= SAA7134_CHROMA_CTRL1_AUTO0;\r\nchroma_ctrl1 &= ~SAA7134_CHROMA_CTRL1_FCTC;\r\nluma_control &= ~SAA7134_LUMA_CTRL_LDEL;\r\nsaa_writeb(SAA7134_INCR_DELAY, 0x08);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL1, 0xc0 | mux);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL2, 0x00);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL3, 0x90);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL4, 0x90);\r\nsaa_writeb(SAA7134_HSYNC_START, 0xeb);\r\nsaa_writeb(SAA7134_HSYNC_STOP, 0xe0);\r\nsaa_writeb(SAA7134_SOURCE_TIMING1, norm->src_timing);\r\nsaa_writeb(SAA7134_SYNC_CTRL, sync_control);\r\nsaa_writeb(SAA7134_LUMA_CTRL, luma_control);\r\nsaa_writeb(SAA7134_DEC_LUMA_BRIGHT, dev->ctl_bright);\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nsaa_writeb(SAA7134_DEC_CHROMA_HUE, dev->ctl_hue);\r\nsaa_writeb(SAA7134_CHROMA_CTRL1, chroma_ctrl1);\r\nsaa_writeb(SAA7134_CHROMA_GAIN, norm->chroma_gain);\r\nsaa_writeb(SAA7134_CHROMA_CTRL2, norm->chroma_ctrl2);\r\nsaa_writeb(SAA7134_MODE_DELAY_CTRL, 0x00);\r\nsaa_writeb(SAA7134_ANALOG_ADC, 0x01);\r\nsaa_writeb(SAA7134_VGATE_START, 0x11);\r\nsaa_writeb(SAA7134_VGATE_STOP, 0xfe);\r\nsaa_writeb(SAA7134_MISC_VGATE_MSB, norm->vgate_misc);\r\nsaa_writeb(SAA7134_RAW_DATA_GAIN, 0x40);\r\nsaa_writeb(SAA7134_RAW_DATA_OFFSET, 0x80);\r\n}\r\nvoid saa7134_set_tvnorm_hw(struct saa7134_dev *dev)\r\n{\r\nsaa7134_set_decoder(dev);\r\nif (card_in(dev, dev->ctl_input).tv)\r\nsaa_call_all(dev, video, s_std, dev->tvnorm->id);\r\nsaa_call_empress(dev, video, s_std, dev->tvnorm->id);\r\n}\r\nstatic void set_h_prescale(struct saa7134_dev *dev, int task, int prescale)\r\n{\r\nstatic const struct {\r\nint xpsc;\r\nint xacl;\r\nint xc2_1;\r\nint xdcg;\r\nint vpfy;\r\n} vals[] = {\r\n{ 1, 0, 0, 0, 0 },\r\n{ 2, 2, 1, 2, 2 },\r\n{ 3, 4, 1, 3, 2 },\r\n{ 4, 8, 1, 4, 2 },\r\n{ 5, 8, 1, 4, 2 },\r\n{ 6, 8, 1, 4, 3 },\r\n{ 7, 8, 1, 4, 3 },\r\n{ 8, 15, 0, 4, 3 },\r\n{ 9, 15, 0, 4, 3 },\r\n{ 10, 16, 1, 5, 3 },\r\n};\r\nstatic const int count = ARRAY_SIZE(vals);\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nif (vals[i].xpsc == prescale)\r\nbreak;\r\nif (i == count)\r\nreturn;\r\nsaa_writeb(SAA7134_H_PRESCALE(task), vals[i].xpsc);\r\nsaa_writeb(SAA7134_ACC_LENGTH(task), vals[i].xacl);\r\nsaa_writeb(SAA7134_LEVEL_CTRL(task),\r\n(vals[i].xc2_1 << 3) | (vals[i].xdcg));\r\nsaa_andorb(SAA7134_FIR_PREFILTER_CTRL(task), 0x0f,\r\n(vals[i].vpfy << 2) | vals[i].vpfy);\r\n}\r\nstatic void set_v_scale(struct saa7134_dev *dev, int task, int yscale)\r\n{\r\nint val,mirror;\r\nsaa_writeb(SAA7134_V_SCALE_RATIO1(task), yscale & 0xff);\r\nsaa_writeb(SAA7134_V_SCALE_RATIO2(task), yscale >> 8);\r\nmirror = (dev->ctl_mirror) ? 0x02 : 0x00;\r\nif (yscale < 2048) {\r\nvideo_dbg("yscale LPI yscale=%d\n", yscale);\r\nsaa_writeb(SAA7134_V_FILTER(task), 0x00 | mirror);\r\nsaa_writeb(SAA7134_LUMA_CONTRAST(task), 0x40);\r\nsaa_writeb(SAA7134_CHROMA_SATURATION(task), 0x40);\r\n} else {\r\nval = 0x40 * 1024 / yscale;\r\nvideo_dbg("yscale ACM yscale=%d val=0x%x\n", yscale, val);\r\nsaa_writeb(SAA7134_V_FILTER(task), 0x01 | mirror);\r\nsaa_writeb(SAA7134_LUMA_CONTRAST(task), val);\r\nsaa_writeb(SAA7134_CHROMA_SATURATION(task), val);\r\n}\r\nsaa_writeb(SAA7134_LUMA_BRIGHT(task), 0x80);\r\n}\r\nstatic void set_size(struct saa7134_dev *dev, int task,\r\nint width, int height, int interlace)\r\n{\r\nint prescale,xscale,yscale,y_even,y_odd;\r\nint h_start, h_stop, v_start, v_stop;\r\nint div = interlace ? 2 : 1;\r\nh_start = dev->crop_current.left;\r\nv_start = dev->crop_current.top/2;\r\nh_stop = (dev->crop_current.left + dev->crop_current.width -1);\r\nv_stop = (dev->crop_current.top + dev->crop_current.height -1)/2;\r\nsaa_writeb(SAA7134_VIDEO_H_START1(task), h_start & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_H_START2(task), h_start >> 8);\r\nsaa_writeb(SAA7134_VIDEO_H_STOP1(task), h_stop & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_H_STOP2(task), h_stop >> 8);\r\nsaa_writeb(SAA7134_VIDEO_V_START1(task), v_start & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_V_START2(task), v_start >> 8);\r\nsaa_writeb(SAA7134_VIDEO_V_STOP1(task), v_stop & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_V_STOP2(task), v_stop >> 8);\r\nprescale = dev->crop_current.width / width;\r\nif (0 == prescale)\r\nprescale = 1;\r\nxscale = 1024 * dev->crop_current.width / prescale / width;\r\nyscale = 512 * div * dev->crop_current.height / height;\r\nvideo_dbg("prescale=%d xscale=%d yscale=%d\n",\r\nprescale, xscale, yscale);\r\nset_h_prescale(dev,task,prescale);\r\nsaa_writeb(SAA7134_H_SCALE_INC1(task), xscale & 0xff);\r\nsaa_writeb(SAA7134_H_SCALE_INC2(task), xscale >> 8);\r\nset_v_scale(dev,task,yscale);\r\nsaa_writeb(SAA7134_VIDEO_PIXELS1(task), width & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_PIXELS2(task), width >> 8);\r\nsaa_writeb(SAA7134_VIDEO_LINES1(task), height/div & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_LINES2(task), height/div >> 8);\r\ny_odd = dev->ctl_y_odd;\r\ny_even = dev->ctl_y_even;\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET0(task), y_odd);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET1(task), y_even);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET2(task), y_odd);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET3(task), y_even);\r\n}\r\nstatic void set_cliplist(struct saa7134_dev *dev, int reg,\r\nstruct cliplist *cl, int entries, char *name)\r\n{\r\n__u8 winbits = 0;\r\nint i;\r\nfor (i = 0; i < entries; i++) {\r\nwinbits |= cl[i].enable;\r\nwinbits &= ~cl[i].disable;\r\nif (i < 15 && cl[i].position == cl[i+1].position)\r\ncontinue;\r\nsaa_writeb(reg + 0, winbits);\r\nsaa_writeb(reg + 2, cl[i].position & 0xff);\r\nsaa_writeb(reg + 3, cl[i].position >> 8);\r\nvideo_dbg("clip: %s winbits=%02x pos=%d\n",\r\nname,winbits,cl[i].position);\r\nreg += 8;\r\n}\r\nfor (; reg < 0x400; reg += 8) {\r\nsaa_writeb(reg+ 0, 0);\r\nsaa_writeb(reg + 1, 0);\r\nsaa_writeb(reg + 2, 0);\r\nsaa_writeb(reg + 3, 0);\r\n}\r\n}\r\nstatic int clip_range(int val)\r\n{\r\nif (val < 0)\r\nval = 0;\r\nreturn val;\r\n}\r\nstatic int cliplist_cmp(const void *a, const void *b)\r\n{\r\nconst struct cliplist *cla = a;\r\nconst struct cliplist *clb = b;\r\nif (cla->position < clb->position)\r\nreturn -1;\r\nif (cla->position > clb->position)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int setup_clipping(struct saa7134_dev *dev, struct v4l2_clip *clips,\r\nint nclips, int interlace)\r\n{\r\nstruct cliplist col[16], row[16];\r\nint cols = 0, rows = 0, i;\r\nint div = interlace ? 2 : 1;\r\nmemset(col, 0, sizeof(col));\r\nmemset(row, 0, sizeof(row));\r\nfor (i = 0; i < nclips && i < 8; i++) {\r\ncol[cols].position = clip_range(clips[i].c.left);\r\ncol[cols].enable = (1 << i);\r\ncols++;\r\ncol[cols].position = clip_range(clips[i].c.left+clips[i].c.width);\r\ncol[cols].disable = (1 << i);\r\ncols++;\r\nrow[rows].position = clip_range(clips[i].c.top / div);\r\nrow[rows].enable = (1 << i);\r\nrows++;\r\nrow[rows].position = clip_range((clips[i].c.top + clips[i].c.height)\r\n/ div);\r\nrow[rows].disable = (1 << i);\r\nrows++;\r\n}\r\nsort(col, cols, sizeof col[0], cliplist_cmp, NULL);\r\nsort(row, rows, sizeof row[0], cliplist_cmp, NULL);\r\nset_cliplist(dev,0x380,col,cols,"cols");\r\nset_cliplist(dev,0x384,row,rows,"rows");\r\nreturn 0;\r\n}\r\nstatic int verify_preview(struct saa7134_dev *dev, struct v4l2_window *win, bool try)\r\n{\r\nenum v4l2_field field;\r\nint maxw, maxh;\r\nif (!try && (dev->ovbuf.base == NULL || dev->ovfmt == NULL))\r\nreturn -EINVAL;\r\nif (win->w.width < 48)\r\nwin->w.width = 48;\r\nif (win->w.height < 32)\r\nwin->w.height = 32;\r\nif (win->clipcount > 8)\r\nwin->clipcount = 8;\r\nwin->chromakey = 0;\r\nwin->global_alpha = 0;\r\nfield = win->field;\r\nmaxw = dev->crop_current.width;\r\nmaxh = dev->crop_current.height;\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (win->w.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_TOP;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nwin->field = field;\r\nif (win->w.width > maxw)\r\nwin->w.width = maxw;\r\nif (win->w.height > maxh)\r\nwin->w.height = maxh;\r\nreturn 0;\r\n}\r\nstatic int start_preview(struct saa7134_dev *dev)\r\n{\r\nunsigned long base,control,bpl;\r\nint err;\r\nerr = verify_preview(dev, &dev->win, false);\r\nif (0 != err)\r\nreturn err;\r\ndev->ovfield = dev->win.field;\r\nvideo_dbg("start_preview %dx%d+%d+%d %s field=%s\n",\r\ndev->win.w.width, dev->win.w.height,\r\ndev->win.w.left, dev->win.w.top,\r\ndev->ovfmt->name, v4l2_field_names[dev->ovfield]);\r\nset_size(dev, TASK_B, dev->win.w.width, dev->win.w.height,\r\nV4L2_FIELD_HAS_BOTH(dev->ovfield));\r\nsetup_clipping(dev, dev->clips, dev->nclips,\r\nV4L2_FIELD_HAS_BOTH(dev->ovfield));\r\nif (dev->ovfmt->yuv)\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_B), 0x3f, 0x03);\r\nelse\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_B), 0x3f, 0x01);\r\nsaa_writeb(SAA7134_OFMT_VIDEO_B, dev->ovfmt->pm | 0x20);\r\nbase = (unsigned long)dev->ovbuf.base;\r\nbase += dev->ovbuf.fmt.bytesperline * dev->win.w.top;\r\nbase += dev->ovfmt->depth/8 * dev->win.w.left;\r\nbpl = dev->ovbuf.fmt.bytesperline;\r\ncontrol = SAA7134_RS_CONTROL_BURST_16;\r\nif (dev->ovfmt->bswap)\r\ncontrol |= SAA7134_RS_CONTROL_BSWAP;\r\nif (dev->ovfmt->wswap)\r\ncontrol |= SAA7134_RS_CONTROL_WSWAP;\r\nif (V4L2_FIELD_HAS_BOTH(dev->ovfield)) {\r\nsaa_writel(SAA7134_RS_BA1(1),base);\r\nsaa_writel(SAA7134_RS_BA2(1),base+bpl);\r\nsaa_writel(SAA7134_RS_PITCH(1),bpl*2);\r\nsaa_writel(SAA7134_RS_CONTROL(1),control);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(1),base);\r\nsaa_writel(SAA7134_RS_BA2(1),base);\r\nsaa_writel(SAA7134_RS_PITCH(1),bpl);\r\nsaa_writel(SAA7134_RS_CONTROL(1),control);\r\n}\r\ndev->ovenable = 1;\r\nsaa7134_set_dmabits(dev);\r\nreturn 0;\r\n}\r\nstatic int stop_preview(struct saa7134_dev *dev)\r\n{\r\ndev->ovenable = 0;\r\nsaa7134_set_dmabits(dev);\r\nreturn 0;\r\n}\r\nstatic int buffer_activate(struct saa7134_dev *dev,\r\nstruct saa7134_buf *buf,\r\nstruct saa7134_buf *next)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = buf->vb2.vb2_queue->drv_priv;\r\nunsigned long base,control,bpl;\r\nunsigned long bpl_uv,lines_uv,base2,base3,tmp;\r\nvideo_dbg("buffer_activate buf=%p\n", buf);\r\nbuf->top_seen = 0;\r\nset_size(dev, TASK_A, dev->width, dev->height,\r\nV4L2_FIELD_HAS_BOTH(dev->field));\r\nif (dev->fmt->yuv)\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x03);\r\nelse\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x01);\r\nsaa_writeb(SAA7134_OFMT_VIDEO_A, dev->fmt->pm);\r\nbase = saa7134_buffer_base(buf);\r\nif (dev->fmt->planar)\r\nbpl = dev->width;\r\nelse\r\nbpl = (dev->width * dev->fmt->depth) / 8;\r\ncontrol = SAA7134_RS_CONTROL_BURST_16 |\r\nSAA7134_RS_CONTROL_ME |\r\n(dmaq->pt.dma >> 12);\r\nif (dev->fmt->bswap)\r\ncontrol |= SAA7134_RS_CONTROL_BSWAP;\r\nif (dev->fmt->wswap)\r\ncontrol |= SAA7134_RS_CONTROL_WSWAP;\r\nif (V4L2_FIELD_HAS_BOTH(dev->field)) {\r\nsaa_writel(SAA7134_RS_BA1(0),base);\r\nsaa_writel(SAA7134_RS_BA2(0),base+bpl);\r\nsaa_writel(SAA7134_RS_PITCH(0),bpl*2);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(0),base);\r\nsaa_writel(SAA7134_RS_BA2(0),base);\r\nsaa_writel(SAA7134_RS_PITCH(0),bpl);\r\n}\r\nsaa_writel(SAA7134_RS_CONTROL(0),control);\r\nif (dev->fmt->planar) {\r\nbpl_uv = bpl >> dev->fmt->hshift;\r\nlines_uv = dev->height >> dev->fmt->vshift;\r\nbase2 = base + bpl * dev->height;\r\nbase3 = base2 + bpl_uv * lines_uv;\r\nif (dev->fmt->uvswap)\r\ntmp = base2, base2 = base3, base3 = tmp;\r\nvideo_dbg("uv: bpl=%ld lines=%ld base2/3=%ld/%ld\n",\r\nbpl_uv,lines_uv,base2,base3);\r\nif (V4L2_FIELD_HAS_BOTH(dev->field)) {\r\nsaa_writel(SAA7134_RS_BA1(4),base2);\r\nsaa_writel(SAA7134_RS_BA2(4),base2+bpl_uv);\r\nsaa_writel(SAA7134_RS_PITCH(4),bpl_uv*2);\r\nsaa_writel(SAA7134_RS_BA1(5),base3);\r\nsaa_writel(SAA7134_RS_BA2(5),base3+bpl_uv);\r\nsaa_writel(SAA7134_RS_PITCH(5),bpl_uv*2);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(4),base2);\r\nsaa_writel(SAA7134_RS_BA2(4),base2);\r\nsaa_writel(SAA7134_RS_PITCH(4),bpl_uv);\r\nsaa_writel(SAA7134_RS_BA1(5),base3);\r\nsaa_writel(SAA7134_RS_BA2(5),base3);\r\nsaa_writel(SAA7134_RS_PITCH(5),bpl_uv);\r\n}\r\nsaa_writel(SAA7134_RS_CONTROL(4),control);\r\nsaa_writel(SAA7134_RS_CONTROL(5),control);\r\n}\r\nsaa7134_set_dmabits(dev);\r\nmod_timer(&dmaq->timeout, jiffies + BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb2)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\r\nstruct saa7134_buf *buf = container_of(vb2, struct saa7134_buf, vb2);\r\ndmaq->curr = NULL;\r\nbuf->activate = buffer_activate;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb2)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vb2->vb2_queue->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nstruct saa7134_buf *buf = container_of(vb2, struct saa7134_buf, vb2);\r\nstruct sg_table *dma = vb2_dma_sg_plane_desc(&buf->vb2, 0);\r\nunsigned int size;\r\nif (dma->sgl->offset) {\r\npr_err("The buffer is not page-aligned\n");\r\nreturn -EINVAL;\r\n}\r\nsize = (dev->width * dev->height * dev->fmt->depth) >> 3;\r\nif (vb2_plane_size(vb2, 0) < size)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(vb2, 0, size);\r\nvb2->v4l2_buf.field = dev->field;\r\nreturn saa7134_pgtable_build(dev->pci, &dmaq->pt, dma->sgl, dma->nents,\r\nsaa7134_buffer_startpage(buf));\r\n}\r\nstatic int queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct saa7134_dmaqueue *dmaq = q->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nint size = dev->fmt->depth * dev->width * dev->height >> 3;\r\nif (dev->width < 48 ||\r\ndev->height < 32 ||\r\ndev->width/4 > dev->crop_current.width ||\r\ndev->height/4 > dev->crop_current.height ||\r\ndev->width > dev->crop_bounds.width ||\r\ndev->height > dev->crop_bounds.height)\r\nreturn -EINVAL;\r\n*nbuffers = saa7134_buffer_count(size, *nbuffers);\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = dev->alloc_ctx;\r\nreturn 0;\r\n}\r\nvoid saa7134_vb2_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vb->vb2_queue->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nstruct saa7134_buf *buf = container_of(vb, struct saa7134_buf, vb2);\r\nsaa7134_buffer_queue(dev, dmaq, buf);\r\n}\r\nint saa7134_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nif (card_is_empress(dev) && vb2_is_busy(&dev->empress_vbq) &&\r\ndmaq == &dev->video_q && dev->fmt->planar) {\r\nstruct saa7134_buf *buf, *tmp;\r\nlist_for_each_entry_safe(buf, tmp, &dmaq->queue, entry) {\r\nlist_del(&buf->entry);\r\nvb2_buffer_done(&buf->vb2, VB2_BUF_STATE_QUEUED);\r\n}\r\nif (dmaq->curr) {\r\nvb2_buffer_done(&dmaq->curr->vb2, VB2_BUF_STATE_QUEUED);\r\ndmaq->curr = NULL;\r\n}\r\nreturn -EBUSY;\r\n}\r\nif ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||\r\n(dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))\r\npm_qos_add_request(&dev->qos_request,\r\nPM_QOS_CPU_DMA_LATENCY, 20);\r\ndmaq->seq_nr = 0;\r\nreturn 0;\r\n}\r\nvoid saa7134_vb2_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nsaa7134_stop_streaming(dev, dmaq);\r\nif ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||\r\n(dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))\r\npm_qos_remove_request(&dev->qos_request);\r\n}\r\nstatic int saa7134_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct saa7134_dev *dev = container_of(ctrl->handler, struct saa7134_dev, ctrl_handler);\r\nunsigned long flags;\r\nint restart_overlay = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ndev->ctl_bright = ctrl->val;\r\nsaa_writeb(SAA7134_DEC_LUMA_BRIGHT, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ndev->ctl_hue = ctrl->val;\r\nsaa_writeb(SAA7134_DEC_CHROMA_HUE, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ndev->ctl_contrast = ctrl->val;\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ndev->ctl_saturation = ctrl->val;\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nbreak;\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->ctl_mute = ctrl->val;\r\nsaa7134_tvaudio_setmute(dev);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->ctl_volume = ctrl->val;\r\nsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_INVERT:\r\ndev->ctl_invert = ctrl->val;\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\ndev->ctl_mirror = ctrl->val;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_EVEN:\r\ndev->ctl_y_even = ctrl->val;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_ODD:\r\ndev->ctl_y_odd = ctrl->val;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\n{\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &dev->tda9887_conf;\r\ndev->ctl_automute = ctrl->val;\r\nif (dev->tda9887_conf) {\r\nif (dev->ctl_automute)\r\ndev->tda9887_conf |= TDA9887_AUTOMUTE;\r\nelse\r\ndev->tda9887_conf &= ~TDA9887_AUTOMUTE;\r\nsaa_call_all(dev, tuner, s_config, &tda9887_cfg);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (restart_overlay && dev->overlay_owner) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev);\r\nstart_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int video_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint ret = v4l2_fh_open(file);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO) {\r\nsaa7134_tvaudio_setinput(dev, &card(dev).radio);\r\nsaa_call_all(dev, tuner, s_radio);\r\n} else {\r\nvideo_mux(dev, dev->ctl_input);\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_fh *fh = file->private_data;\r\nstruct saa6588_command cmd;\r\nunsigned long flags;\r\nmutex_lock(&dev->lock);\r\nsaa7134_tvaudio_close(dev);\r\nif (fh == dev->overlay_owner) {\r\nspin_lock_irqsave(&dev->slock,flags);\r\nstop_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\ndev->overlay_owner = NULL;\r\n}\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nv4l2_fh_release(file);\r\nelse\r\n_vb2_fop_release(file, NULL);\r\nsaa_andorb(SAA7134_OFMT_VIDEO_A, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_VIDEO_B, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_DATA_A, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_DATA_B, 0x1f, 0);\r\nsaa_call_all(dev, core, s_power, 0);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_CLOSE, &cmd);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t radio_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa6588_command cmd;\r\ncmd.block_count = count/3;\r\ncmd.nonblocking = file->f_flags & O_NONBLOCK;\r\ncmd.buffer = data;\r\ncmd.instance = file;\r\ncmd.result = -ENODEV;\r\nmutex_lock(&dev->lock);\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_READ, &cmd);\r\nmutex_unlock(&dev->lock);\r\nreturn cmd.result;\r\n}\r\nstatic unsigned int radio_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa6588_command cmd;\r\nunsigned int rc = v4l2_ctrl_poll(file, wait);\r\ncmd.instance = file;\r\ncmd.event_list = wait;\r\ncmd.result = 0;\r\nmutex_lock(&dev->lock);\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_POLL, &cmd);\r\nmutex_unlock(&dev->lock);\r\nreturn rc | cmd.result;\r\n}\r\nstatic int saa7134_try_get_set_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_tvnorm *norm = dev->tvnorm;\r\nmemset(&f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = 2048 ;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 64 * 4;\r\nf->fmt.vbi.start[0] = norm->vbi_v_start_0;\r\nf->fmt.vbi.count[0] = norm->vbi_v_stop_0 - norm->vbi_v_start_0 +1;\r\nf->fmt.vbi.start[1] = norm->vbi_v_start_1;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nf->fmt.vbi.flags = 0;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = dev->field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_clip __user *clips = f->fmt.win.clips;\r\nu32 clipcount = f->fmt.win.clipcount;\r\nint err = 0;\r\nint i;\r\nif (saa7134_no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nf->fmt.win = dev->win;\r\nf->fmt.win.clips = clips;\r\nif (clips == NULL)\r\nclipcount = 0;\r\nif (dev->nclips < clipcount)\r\nclipcount = dev->nclips;\r\nf->fmt.win.clipcount = clipcount;\r\nfor (i = 0; !err && i < clipcount; i++) {\r\nif (copy_to_user(&f->fmt.win.clips[i].c, &dev->clips[i].c,\r\nsizeof(struct v4l2_rect)))\r\nerr = -EFAULT;\r\n}\r\nreturn err;\r\n}\r\nstatic int saa7134_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_format *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = min(dev->crop_current.width*4, dev->crop_bounds.width);\r\nmaxh = min(dev->crop_current.height*4, dev->crop_bounds.height);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.width < 48)\r\nf->fmt.pix.width = 48;\r\nif (f->fmt.pix.height < 32)\r\nf->fmt.pix.height = 32;\r\nif (f->fmt.pix.width > maxw)\r\nf->fmt.pix.width = maxw;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\nf->fmt.pix.width &= ~0x03;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa7134_try_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (saa7134_no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->fmt.win.clips == NULL)\r\nf->fmt.win.clipcount = 0;\r\nreturn verify_preview(dev, &f->fmt.win, true);\r\n}\r\nstatic int saa7134_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint err;\r\nerr = saa7134_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\ndev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint err;\r\nunsigned long flags;\r\nif (saa7134_no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->fmt.win.clips == NULL)\r\nf->fmt.win.clipcount = 0;\r\nerr = verify_preview(dev, &f->fmt.win, true);\r\nif (0 != err)\r\nreturn err;\r\ndev->win = f->fmt.win;\r\ndev->nclips = f->fmt.win.clipcount;\r\nif (copy_from_user(dev->clips, f->fmt.win.clips,\r\nsizeof(struct v4l2_clip) * dev->nclips))\r\nreturn -EFAULT;\r\nif (priv == dev->overlay_owner) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev);\r\nstart_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint saa7134_enum_input(struct file *file, void *priv, struct v4l2_input *i)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL == card_in(dev, i->index).name)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, card_in(dev, n).name);\r\nif (card_in(dev, n).tv)\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nif (n == dev->ctl_input) {\r\nint v1 = saa_readb(SAA7134_STATUS_VIDEO1);\r\nint v2 = saa_readb(SAA7134_STATUS_VIDEO2);\r\nif (0 != (v1 & 0x40))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\nif (0 != (v2 & 0x40))\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (0 != (v2 & 0x0e))\r\ni->status |= V4L2_IN_ST_MACROVISION;\r\n}\r\ni->std = SAA7134_NORMS;\r\nreturn 0;\r\n}\r\nint saa7134_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\n*i = dev->ctl_input;\r\nreturn 0;\r\n}\r\nint saa7134_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (i >= SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL == card_in(dev, i).name)\r\nreturn -EINVAL;\r\nvideo_mux(dev, i);\r\nreturn 0;\r\n}\r\nint saa7134_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nu32 radio_caps, video_caps, vbi_caps;\r\nunsigned int tuner_type = dev->tuner_type;\r\nstrcpy(cap->driver, "saa7134");\r\nstrlcpy(cap->card, saa7134_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nif ((tuner_type != TUNER_ABSENT) && (tuner_type != UNSET))\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\nradio_caps = V4L2_CAP_RADIO;\r\nif (dev->has_rds)\r\nradio_caps |= V4L2_CAP_RDS_CAPTURE;\r\nvideo_caps = V4L2_CAP_VIDEO_CAPTURE;\r\nif (saa7134_no_overlay <= 0 && !is_empress(file))\r\nvideo_caps |= V4L2_CAP_VIDEO_OVERLAY;\r\nvbi_caps = V4L2_CAP_VBI_CAPTURE;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_RADIO:\r\ncap->device_caps |= radio_caps;\r\nbreak;\r\ncase VFL_TYPE_GRABBER:\r\ncap->device_caps |= video_caps;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ncap->device_caps |= vbi_caps;\r\nbreak;\r\n}\r\ncap->capabilities = radio_caps | video_caps | vbi_caps |\r\ncap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nif (vdev->vfl_type == VFL_TYPE_RADIO) {\r\ncap->device_caps &= ~V4L2_CAP_STREAMING;\r\nif (!dev->has_rds)\r\ncap->device_caps &= ~V4L2_CAP_READWRITE;\r\n}\r\nreturn 0;\r\n}\r\nint saa7134_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_fh *fh = priv;\r\nunsigned long flags;\r\nunsigned int i;\r\nv4l2_std_id fixup;\r\nif (is_empress(file) && dev->overlay_owner) {\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < TVNORMS; i++)\r\nif (id == tvnorms[i].id)\r\nbreak;\r\nif (i == TVNORMS)\r\nfor (i = 0; i < TVNORMS; i++)\r\nif (id & tvnorms[i].id)\r\nbreak;\r\nif (i == TVNORMS)\r\nreturn -EINVAL;\r\nif ((id & V4L2_STD_SECAM) && (secam[0] != '-')) {\r\nif (secam[0] == 'L' || secam[0] == 'l') {\r\nif (secam[1] == 'C' || secam[1] == 'c')\r\nfixup = V4L2_STD_SECAM_LC;\r\nelse\r\nfixup = V4L2_STD_SECAM_L;\r\n} else {\r\nif (secam[0] == 'D' || secam[0] == 'd')\r\nfixup = V4L2_STD_SECAM_DK;\r\nelse\r\nfixup = V4L2_STD_SECAM;\r\n}\r\nfor (i = 0; i < TVNORMS; i++) {\r\nif (fixup == tvnorms[i].id)\r\nbreak;\r\n}\r\nif (i == TVNORMS)\r\nreturn -EINVAL;\r\n}\r\nid = tvnorms[i].id;\r\nif (!is_empress(file) && fh == dev->overlay_owner) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nset_tvnorm(dev, &tvnorms[i]);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstart_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n} else\r\nset_tvnorm(dev, &tvnorms[i]);\r\nsaa7134_tvaudio_do_scan(dev);\r\nreturn 0;\r\n}\r\nint saa7134_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\n*id = dev->tvnorm->id;\r\nreturn 0;\r\n}\r\nstatic v4l2_std_id saa7134_read_std(struct saa7134_dev *dev)\r\n{\r\nstatic v4l2_std_id stds[] = {\r\nV4L2_STD_UNKNOWN,\r\nV4L2_STD_NTSC,\r\nV4L2_STD_PAL,\r\nV4L2_STD_SECAM };\r\nv4l2_std_id result = 0;\r\nu8 st1 = saa_readb(SAA7134_STATUS_VIDEO1);\r\nu8 st2 = saa_readb(SAA7134_STATUS_VIDEO2);\r\nif (!(st2 & 0x1))\r\nresult = V4L2_STD_UNKNOWN;\r\nelse\r\nresult = stds[st1 & 0x03];\r\nreturn result;\r\n}\r\nint saa7134_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\n*std &= saa7134_read_std(dev);\r\nreturn 0;\r\n}\r\nstatic int saa7134_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cap)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\ncap->bounds = dev->crop_bounds;\r\ncap->defrect = dev->crop_defrect;\r\ncap->pixelaspect.numerator = 1;\r\ncap->pixelaspect.denominator = 1;\r\nif (dev->tvnorm->id & V4L2_STD_525_60) {\r\ncap->pixelaspect.numerator = 11;\r\ncap->pixelaspect.denominator = 10;\r\n}\r\nif (dev->tvnorm->id & V4L2_STD_625_50) {\r\ncap->pixelaspect.numerator = 54;\r\ncap->pixelaspect.denominator = 59;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_crop(struct file *file, void *f, struct v4l2_crop *crop)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\ncrop->c = dev->crop_current;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_crop(struct file *file, void *f, const struct v4l2_crop *crop)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_rect *b = &dev->crop_bounds;\r\nstruct v4l2_rect *c = &dev->crop_current;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\nif (dev->overlay_owner)\r\nreturn -EBUSY;\r\nif (vb2_is_streaming(&dev->video_vbq))\r\nreturn -EBUSY;\r\n*c = crop->c;\r\nif (c->top < b->top)\r\nc->top = b->top;\r\nif (c->top > b->top + b->height)\r\nc->top = b->top + b->height;\r\nif (c->height > b->top - c->top + b->height)\r\nc->height = b->top - c->top + b->height;\r\nif (c->left < b->left)\r\nc->left = b->left;\r\nif (c->left > b->left + b->width)\r\nc->left = b->left + b->width;\r\nif (c->width > b->left - c->left + b->width)\r\nc->width = b->left - c->left + b->width;\r\nreturn 0;\r\n}\r\nint saa7134_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint n;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nmemset(t, 0, sizeof(*t));\r\nfor (n = 0; n < SAA7134_INPUT_MAX; n++) {\r\nif (card_in(dev, n).tv)\r\nbreak;\r\n}\r\nif (n == SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL != card_in(dev, n).name) {\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nsaa_call_all(dev, tuner, g_tuner, t);\r\nt->capability = V4L2_TUNER_CAP_NORM |\r\nV4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2;\r\nt->rxsubchans = saa7134_tvaudio_getstereo(dev);\r\nt->audmode = saa7134_tvaudio_rx2mode(t->rxsubchans);\r\n}\r\nif (0 != (saa_readb(SAA7134_STATUS_VIDEO1) & 0x03))\r\nt->signal = 0xffff;\r\nreturn 0;\r\n}\r\nint saa7134_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint rx, mode;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nmode = dev->thread.mode;\r\nif (UNSET == mode) {\r\nrx = saa7134_tvaudio_getstereo(dev);\r\nmode = saa7134_tvaudio_rx2mode(rx);\r\n}\r\nif (mode != t->audmode)\r\ndev->thread.mode = t->audmode;\r\nreturn 0;\r\n}\r\nint saa7134_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nsaa_call_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nint saa7134_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nsaa_call_all(dev, tuner, s_frequency, f);\r\nsaa7134_tvaudio_do_scan(dev);\r\nreturn 0;\r\n}\r\nstatic int saa7134_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int saa7134_enum_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (saa7134_no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif ((f->index >= FORMATS) || formats[f->index].planar)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fbuf(struct file *file, void *f,\r\nstruct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\n*fb = dev->ovbuf;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_fbuf(struct file *file, void *f,\r\nconst struct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_format *fmt;\r\nif (!capable(CAP_SYS_ADMIN) &&\r\n!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nfmt = format_by_fourcc(fb->fmt.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\ndev->ovbuf = *fb;\r\ndev->ovfmt = fmt;\r\nif (0 == dev->ovbuf.fmt.bytesperline)\r\ndev->ovbuf.fmt.bytesperline =\r\ndev->ovbuf.fmt.width*fmt->depth/8;\r\nreturn 0;\r\n}\r\nstatic int saa7134_overlay(struct file *file, void *priv, unsigned int on)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nunsigned long flags;\r\nif (on) {\r\nif (saa7134_no_overlay > 0) {\r\nvideo_dbg("no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev->overlay_owner && priv != dev->overlay_owner)\r\nreturn -EBUSY;\r\ndev->overlay_owner = priv;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstart_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nif (!on) {\r\nif (priv != dev->overlay_owner)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ndev->overlay_owner = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register (struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nreg->val = saa_readb(reg->reg & 0xffffff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register (struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nsaa_writeb(reg->reg & 0xffffff, reg->val);\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nsaa_call_all(dev, tuner, g_tuner, t);\r\nt->audmode &= V4L2_TUNER_MODE_MONO | V4L2_TUNER_MODE_STEREO;\r\nif (dev->input->amux == TV) {\r\nt->signal = 0xf800 - ((saa_readb(0x581) & 0x1f) << 11);\r\nt->rxsubchans = (saa_readb(0x529) & 0x08) ?\r\nV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nsaa_call_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nint saa7134_video_init1(struct saa7134_dev *dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\r\nstruct vb2_queue *q;\r\nint ret;\r\nif (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)\r\ngbuffers = 2;\r\nif (gbufsize > gbufsize_max)\r\ngbufsize = gbufsize_max;\r\ngbufsize = (gbufsize + PAGE_SIZE - 1) & PAGE_MASK;\r\nv4l2_ctrl_handler_init(hdl, 11);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 68);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa7134_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, -15, 15, 1, 0);\r\nv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_invert, NULL);\r\nv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_y_odd, NULL);\r\nv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_y_even, NULL);\r\nv4l2_ctrl_new_custom(hdl, &saa7134_ctrl_automute, NULL);\r\nif (hdl->error)\r\nreturn hdl->error;\r\nif (card_has_radio(dev)) {\r\nhdl = &dev->radio_ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\nv4l2_ctrl_add_handler(hdl, &dev->ctrl_handler,\r\nv4l2_ctrl_radio_filter);\r\nif (hdl->error)\r\nreturn hdl->error;\r\n}\r\ndev->ctl_mute = 1;\r\nif (dev->tda9887_conf && saa7134_ctrl_automute.def)\r\ndev->tda9887_conf |= TDA9887_AUTOMUTE;\r\ndev->automute = 0;\r\nINIT_LIST_HEAD(&dev->video_q.queue);\r\ninit_timer(&dev->video_q.timeout);\r\ndev->video_q.timeout.function = saa7134_buffer_timeout;\r\ndev->video_q.timeout.data = (unsigned long)(&dev->video_q);\r\ndev->video_q.dev = dev;\r\ndev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\ndev->width = 720;\r\ndev->height = 576;\r\ndev->field = V4L2_FIELD_INTERLACED;\r\ndev->win.w.width = dev->width;\r\ndev->win.w.height = dev->height;\r\ndev->win.field = V4L2_FIELD_INTERLACED;\r\ndev->ovbuf.fmt.width = dev->width;\r\ndev->ovbuf.fmt.height = dev->height;\r\ndev->ovbuf.fmt.pixelformat = dev->fmt->fourcc;\r\ndev->ovbuf.fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (saa7134_boards[dev->board].video_out)\r\nsaa7134_videoport_init(dev);\r\nq = &dev->video_vbq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ;\r\nif (saa7134_userptr)\r\nq->io_modes |= VB2_USERPTR;\r\nq->drv_priv = &dev->video_q;\r\nq->ops = &vb2_qops;\r\nq->gfp_flags = GFP_DMA32;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->buf_struct_size = sizeof(struct saa7134_buf);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\nreturn ret;\r\nsaa7134_pgtable_alloc(dev->pci, &dev->video_q.pt);\r\nq = &dev->vbi_vbq;\r\nq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ;\r\nif (saa7134_userptr)\r\nq->io_modes |= VB2_USERPTR;\r\nq->drv_priv = &dev->vbi_q;\r\nq->ops = &saa7134_vbi_qops;\r\nq->gfp_flags = GFP_DMA32;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->buf_struct_size = sizeof(struct saa7134_buf);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\nreturn ret;\r\nsaa7134_pgtable_alloc(dev->pci, &dev->vbi_q.pt);\r\nreturn 0;\r\n}\r\nvoid saa7134_video_fini(struct saa7134_dev *dev)\r\n{\r\nvb2_queue_release(&dev->video_vbq);\r\nsaa7134_pgtable_free(dev->pci, &dev->video_q.pt);\r\nvb2_queue_release(&dev->vbi_vbq);\r\nsaa7134_pgtable_free(dev->pci, &dev->vbi_q.pt);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nif (card_has_radio(dev))\r\nv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\r\n}\r\nint saa7134_videoport_init(struct saa7134_dev *dev)\r\n{\r\nint vo = saa7134_boards[dev->board].video_out;\r\nint video_reg;\r\nunsigned int vid_port_opts = saa7134_boards[dev->board].vid_port_opts;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL0, video_out[vo][0]);\r\nvideo_reg = video_out[vo][1];\r\nif (vid_port_opts & SET_T_CODE_POLARITY_NON_INVERTED)\r\nvideo_reg &= ~VP_T_CODE_P_INVERTED;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL1, video_reg);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL2, video_out[vo][2]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL4, video_out[vo][4]);\r\nvideo_reg = video_out[vo][5];\r\nif (vid_port_opts & SET_CLOCK_NOT_DELAYED)\r\nvideo_reg &= ~VP_CLK_CTRL2_DELAYED;\r\nif (vid_port_opts & SET_CLOCK_INVERTED)\r\nvideo_reg |= VP_CLK_CTRL1_INVERTED;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL5, video_reg);\r\nvideo_reg = video_out[vo][6];\r\nif (vid_port_opts & SET_VSYNC_OFF) {\r\nvideo_reg &= ~VP_VS_TYPE_MASK;\r\nvideo_reg |= VP_VS_TYPE_OFF;\r\n}\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL6, video_reg);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL7, video_out[vo][7]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL8, video_out[vo][8]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL3, video_out[vo][3]);\r\nreturn 0;\r\n}\r\nint saa7134_video_init2(struct saa7134_dev *dev)\r\n{\r\nset_tvnorm(dev,&tvnorms[0]);\r\nvideo_mux(dev,0);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_handler);\r\nsaa7134_tvaudio_setmute(dev);\r\nsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\r\nreturn 0;\r\n}\r\nvoid saa7134_irq_video_signalchange(struct saa7134_dev *dev)\r\n{\r\nstatic const char *st[] = {\r\n"(no signal)", "NTSC", "PAL", "SECAM" };\r\nu32 st1,st2;\r\nst1 = saa_readb(SAA7134_STATUS_VIDEO1);\r\nst2 = saa_readb(SAA7134_STATUS_VIDEO2);\r\nvideo_dbg("DCSDT: pll: %s, sync: %s, norm: %s\n",\r\n(st1 & 0x40) ? "not locked" : "locked",\r\n(st2 & 0x40) ? "no" : "yes",\r\nst[st1 & 0x03]);\r\ndev->nosignal = (st1 & 0x40) || (st2 & 0x40) || !(st2 & 0x1);\r\nif (dev->nosignal) {\r\nif (dev->ctl_automute)\r\ndev->automute = 1;\r\nsaa7134_tvaudio_setmute(dev);\r\n} else {\r\nsaa7134_tvaudio_do_scan(dev);\r\n}\r\nif ((st2 & 0x80) && !noninterlaced && !dev->nosignal)\r\nsaa_clearb(SAA7134_SYNC_CTRL, 0x20);\r\nelse\r\nsaa_setb(SAA7134_SYNC_CTRL, 0x20);\r\nif (dev->mops && dev->mops->signal_change)\r\ndev->mops->signal_change(dev);\r\n}\r\nvoid saa7134_irq_video_done(struct saa7134_dev *dev, unsigned long status)\r\n{\r\nenum v4l2_field field;\r\nspin_lock(&dev->slock);\r\nif (dev->video_q.curr) {\r\nfield = dev->field;\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\nif ((status & 0x10) == 0x00) {\r\ndev->video_q.curr->top_seen = 1;\r\ngoto done;\r\n}\r\nif (!dev->video_q.curr->top_seen)\r\ngoto done;\r\n} else if (field == V4L2_FIELD_TOP) {\r\nif ((status & 0x10) != 0x10)\r\ngoto done;\r\n} else if (field == V4L2_FIELD_BOTTOM) {\r\nif ((status & 0x10) != 0x00)\r\ngoto done;\r\n}\r\nsaa7134_buffer_finish(dev, &dev->video_q, VB2_BUF_STATE_DONE);\r\n}\r\nsaa7134_buffer_next(dev, &dev->video_q);\r\ndone:\r\nspin_unlock(&dev->slock);\r\n}
