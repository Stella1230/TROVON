int pci_enable_pcie_error_reporting(struct pci_dev *dev)\r\n{\r\nif (pcie_aer_get_firmware_first(dev))\r\nreturn -EIO;\r\nif (!pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))\r\nreturn -EIO;\r\nreturn pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_AER_FLAGS);\r\n}\r\nint pci_disable_pcie_error_reporting(struct pci_dev *dev)\r\n{\r\nif (pcie_aer_get_firmware_first(dev))\r\nreturn -EIO;\r\nreturn pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,\r\nPCI_EXP_AER_FLAGS);\r\n}\r\nint pci_cleanup_aer_uncorrect_error_status(struct pci_dev *dev)\r\n{\r\nint pos;\r\nu32 status;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (!pos)\r\nreturn -EIO;\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &status);\r\nif (status)\r\npci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, status);\r\nreturn 0;\r\n}\r\nstatic int add_error_device(struct aer_err_info *e_info, struct pci_dev *dev)\r\n{\r\nif (e_info->error_dev_num < AER_MAX_MULTI_ERR_DEVICES) {\r\ne_info->dev[e_info->error_dev_num] = dev;\r\ne_info->error_dev_num++;\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic bool is_error_source(struct pci_dev *dev, struct aer_err_info *e_info)\r\n{\r\nint pos;\r\nu32 status, mask;\r\nu16 reg16;\r\nif (!nosourceid && (PCI_BUS_NUM(e_info->id) != 0)) {\r\nif (e_info->id == ((dev->bus->number << 8) | dev->devfn))\r\nreturn true;\r\nif (!e_info->multi_error_valid)\r\nreturn false;\r\n}\r\nif (atomic_read(&dev->enable_cnt) == 0)\r\nreturn false;\r\npcie_capability_read_word(dev, PCI_EXP_DEVCTL, &reg16);\r\nif (!(reg16 & PCI_EXP_AER_FLAGS))\r\nreturn false;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (!pos)\r\nreturn false;\r\nif (e_info->severity == AER_CORRECTABLE) {\r\npci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &status);\r\npci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &mask);\r\n} else {\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &status);\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &mask);\r\n}\r\nif (status & ~mask)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int find_device_iter(struct pci_dev *dev, void *data)\r\n{\r\nstruct aer_err_info *e_info = (struct aer_err_info *)data;\r\nif (is_error_source(dev, e_info)) {\r\nif (add_error_device(e_info, dev)) {\r\nreturn 1;\r\n}\r\nif (!e_info->multi_error_valid)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool find_source_device(struct pci_dev *parent,\r\nstruct aer_err_info *e_info)\r\n{\r\nstruct pci_dev *dev = parent;\r\nint result;\r\ne_info->error_dev_num = 0;\r\nresult = find_device_iter(dev, e_info);\r\nif (result)\r\nreturn true;\r\npci_walk_bus(parent->subordinate, find_device_iter, e_info);\r\nif (!e_info->error_dev_num) {\r\ndev_printk(KERN_DEBUG, &parent->dev,\r\n"can't find device of ID%04x\n",\r\ne_info->id);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int report_error_detected(struct pci_dev *dev, void *data)\r\n{\r\npci_ers_result_t vote;\r\nconst struct pci_error_handlers *err_handler;\r\nstruct aer_broadcast_data *result_data;\r\nresult_data = (struct aer_broadcast_data *) data;\r\ndevice_lock(&dev->dev);\r\ndev->error_state = result_data->state;\r\nif (!dev->driver ||\r\n!dev->driver->err_handler ||\r\n!dev->driver->err_handler->error_detected) {\r\nif (result_data->state == pci_channel_io_frozen &&\r\n!(dev->hdr_type & PCI_HEADER_TYPE_BRIDGE)) {\r\ndev_printk(KERN_DEBUG, &dev->dev, "device has %s\n",\r\ndev->driver ?\r\n"no AER-aware driver" : "no driver");\r\n}\r\nif (!(dev->hdr_type & PCI_HEADER_TYPE_BRIDGE))\r\nvote = PCI_ERS_RESULT_NO_AER_DRIVER;\r\nelse\r\nvote = PCI_ERS_RESULT_NONE;\r\n} else {\r\nerr_handler = dev->driver->err_handler;\r\nvote = err_handler->error_detected(dev, result_data->state);\r\n}\r\nresult_data->result = merge_result(result_data->result, vote);\r\ndevice_unlock(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int report_mmio_enabled(struct pci_dev *dev, void *data)\r\n{\r\npci_ers_result_t vote;\r\nconst struct pci_error_handlers *err_handler;\r\nstruct aer_broadcast_data *result_data;\r\nresult_data = (struct aer_broadcast_data *) data;\r\ndevice_lock(&dev->dev);\r\nif (!dev->driver ||\r\n!dev->driver->err_handler ||\r\n!dev->driver->err_handler->mmio_enabled)\r\ngoto out;\r\nerr_handler = dev->driver->err_handler;\r\nvote = err_handler->mmio_enabled(dev);\r\nresult_data->result = merge_result(result_data->result, vote);\r\nout:\r\ndevice_unlock(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int report_slot_reset(struct pci_dev *dev, void *data)\r\n{\r\npci_ers_result_t vote;\r\nconst struct pci_error_handlers *err_handler;\r\nstruct aer_broadcast_data *result_data;\r\nresult_data = (struct aer_broadcast_data *) data;\r\ndevice_lock(&dev->dev);\r\nif (!dev->driver ||\r\n!dev->driver->err_handler ||\r\n!dev->driver->err_handler->slot_reset)\r\ngoto out;\r\nerr_handler = dev->driver->err_handler;\r\nvote = err_handler->slot_reset(dev);\r\nresult_data->result = merge_result(result_data->result, vote);\r\nout:\r\ndevice_unlock(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int report_resume(struct pci_dev *dev, void *data)\r\n{\r\nconst struct pci_error_handlers *err_handler;\r\ndevice_lock(&dev->dev);\r\ndev->error_state = pci_channel_io_normal;\r\nif (!dev->driver ||\r\n!dev->driver->err_handler ||\r\n!dev->driver->err_handler->resume)\r\ngoto out;\r\nerr_handler = dev->driver->err_handler;\r\nerr_handler->resume(dev);\r\nout:\r\ndevice_unlock(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t broadcast_error_message(struct pci_dev *dev,\r\nenum pci_channel_state state,\r\nchar *error_mesg,\r\nint (*cb)(struct pci_dev *, void *))\r\n{\r\nstruct aer_broadcast_data result_data;\r\ndev_printk(KERN_DEBUG, &dev->dev, "broadcast %s message\n", error_mesg);\r\nresult_data.state = state;\r\nif (cb == report_error_detected)\r\nresult_data.result = PCI_ERS_RESULT_CAN_RECOVER;\r\nelse\r\nresult_data.result = PCI_ERS_RESULT_RECOVERED;\r\nif (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE) {\r\nif (cb == report_error_detected)\r\ndev->error_state = state;\r\npci_walk_bus(dev->subordinate, cb, &result_data);\r\nif (cb == report_resume) {\r\npci_cleanup_aer_uncorrect_error_status(dev);\r\ndev->error_state = pci_channel_io_normal;\r\n}\r\n} else {\r\npci_walk_bus(dev->bus, cb, &result_data);\r\n}\r\nreturn result_data.result;\r\n}\r\nstatic pci_ers_result_t default_reset_link(struct pci_dev *dev)\r\n{\r\npci_reset_bridge_secondary_bus(dev);\r\ndev_printk(KERN_DEBUG, &dev->dev, "downstream link has been reset\n");\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic int find_aer_service_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_port_service_driver *service_driver, **drv;\r\ndrv = (struct pcie_port_service_driver **) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\nservice_driver = to_service_driver(device->driver);\r\nif (service_driver->service == PCIE_PORT_SERVICE_AER) {\r\n*drv = service_driver;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcie_port_service_driver *find_aer_service(struct pci_dev *dev)\r\n{\r\nstruct pcie_port_service_driver *drv = NULL;\r\ndevice_for_each_child(&dev->dev, &drv, find_aer_service_iter);\r\nreturn drv;\r\n}\r\nstatic pci_ers_result_t reset_link(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *udev;\r\npci_ers_result_t status;\r\nstruct pcie_port_service_driver *driver;\r\nif (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE) {\r\nudev = dev;\r\n} else {\r\nudev = dev->bus->self;\r\n}\r\ndriver = find_aer_service(udev);\r\nif (driver && driver->reset_link) {\r\nstatus = driver->reset_link(udev);\r\n} else if (udev->has_secondary_link) {\r\nstatus = default_reset_link(udev);\r\n} else {\r\ndev_printk(KERN_DEBUG, &dev->dev,\r\n"no link-reset support at upstream device %s\n",\r\npci_name(udev));\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nif (status != PCI_ERS_RESULT_RECOVERED) {\r\ndev_printk(KERN_DEBUG, &dev->dev,\r\n"link reset at upstream device %s failed\n",\r\npci_name(udev));\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nreturn status;\r\n}\r\nstatic void do_recovery(struct pci_dev *dev, int severity)\r\n{\r\npci_ers_result_t status, result = PCI_ERS_RESULT_RECOVERED;\r\nenum pci_channel_state state;\r\nif (severity == AER_FATAL)\r\nstate = pci_channel_io_frozen;\r\nelse\r\nstate = pci_channel_io_normal;\r\nstatus = broadcast_error_message(dev,\r\nstate,\r\n"error_detected",\r\nreport_error_detected);\r\nif (severity == AER_FATAL) {\r\nresult = reset_link(dev);\r\nif (result != PCI_ERS_RESULT_RECOVERED)\r\ngoto failed;\r\n}\r\nif (status == PCI_ERS_RESULT_CAN_RECOVER)\r\nstatus = broadcast_error_message(dev,\r\nstate,\r\n"mmio_enabled",\r\nreport_mmio_enabled);\r\nif (status == PCI_ERS_RESULT_NEED_RESET) {\r\nstatus = broadcast_error_message(dev,\r\nstate,\r\n"slot_reset",\r\nreport_slot_reset);\r\n}\r\nif (status != PCI_ERS_RESULT_RECOVERED)\r\ngoto failed;\r\nbroadcast_error_message(dev,\r\nstate,\r\n"resume",\r\nreport_resume);\r\ndev_info(&dev->dev, "AER: Device recovery successful\n");\r\nreturn;\r\nfailed:\r\ndev_info(&dev->dev, "AER: Device recovery failed\n");\r\n}\r\nstatic void handle_error_source(struct pcie_device *aerdev,\r\nstruct pci_dev *dev,\r\nstruct aer_err_info *info)\r\n{\r\nint pos;\r\nif (info->severity == AER_CORRECTABLE) {\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (pos)\r\npci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS,\r\ninfo->status);\r\n} else\r\ndo_recovery(dev, info->severity);\r\n}\r\nvoid aer_recover_queue(int domain, unsigned int bus, unsigned int devfn,\r\nint severity, struct aer_capability_regs *aer_regs)\r\n{\r\nunsigned long flags;\r\nstruct aer_recover_entry entry = {\r\n.bus = bus,\r\n.devfn = devfn,\r\n.domain = domain,\r\n.severity = severity,\r\n.regs = aer_regs,\r\n};\r\nspin_lock_irqsave(&aer_recover_ring_lock, flags);\r\nif (kfifo_put(&aer_recover_ring, entry))\r\nschedule_work(&aer_recover_work);\r\nelse\r\npr_err("AER recover: Buffer overflow when recovering AER for %04x:%02x:%02x:%x\n",\r\ndomain, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\nspin_unlock_irqrestore(&aer_recover_ring_lock, flags);\r\n}\r\nstatic void aer_recover_work_func(struct work_struct *work)\r\n{\r\nstruct aer_recover_entry entry;\r\nstruct pci_dev *pdev;\r\nwhile (kfifo_get(&aer_recover_ring, &entry)) {\r\npdev = pci_get_domain_bus_and_slot(entry.domain, entry.bus,\r\nentry.devfn);\r\nif (!pdev) {\r\npr_err("AER recover: Can not find pci_dev for %04x:%02x:%02x:%x\n",\r\nentry.domain, entry.bus,\r\nPCI_SLOT(entry.devfn), PCI_FUNC(entry.devfn));\r\ncontinue;\r\n}\r\ncper_print_aer(pdev, entry.severity, entry.regs);\r\ndo_recovery(pdev, entry.severity);\r\npci_dev_put(pdev);\r\n}\r\n}\r\nstatic int get_device_error_info(struct pci_dev *dev, struct aer_err_info *info)\r\n{\r\nint pos, temp;\r\ninfo->status = 0;\r\ninfo->tlp_header_valid = 0;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (!pos)\r\nreturn 1;\r\nif (info->severity == AER_CORRECTABLE) {\r\npci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS,\r\n&info->status);\r\npci_read_config_dword(dev, pos + PCI_ERR_COR_MASK,\r\n&info->mask);\r\nif (!(info->status & ~info->mask))\r\nreturn 0;\r\n} else if (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE ||\r\ninfo->severity == AER_NONFATAL) {\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,\r\n&info->status);\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK,\r\n&info->mask);\r\nif (!(info->status & ~info->mask))\r\nreturn 0;\r\npci_read_config_dword(dev, pos + PCI_ERR_CAP, &temp);\r\ninfo->first_error = PCI_ERR_CAP_FEP(temp);\r\nif (info->status & AER_LOG_TLP_MASKS) {\r\ninfo->tlp_header_valid = 1;\r\npci_read_config_dword(dev,\r\npos + PCI_ERR_HEADER_LOG, &info->tlp.dw0);\r\npci_read_config_dword(dev,\r\npos + PCI_ERR_HEADER_LOG + 4, &info->tlp.dw1);\r\npci_read_config_dword(dev,\r\npos + PCI_ERR_HEADER_LOG + 8, &info->tlp.dw2);\r\npci_read_config_dword(dev,\r\npos + PCI_ERR_HEADER_LOG + 12, &info->tlp.dw3);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void aer_process_err_devices(struct pcie_device *p_device,\r\nstruct aer_err_info *e_info)\r\n{\r\nint i;\r\nfor (i = 0; i < e_info->error_dev_num && e_info->dev[i]; i++) {\r\nif (get_device_error_info(e_info->dev[i], e_info))\r\naer_print_error(e_info->dev[i], e_info);\r\n}\r\nfor (i = 0; i < e_info->error_dev_num && e_info->dev[i]; i++) {\r\nif (get_device_error_info(e_info->dev[i], e_info))\r\nhandle_error_source(p_device, e_info->dev[i], e_info);\r\n}\r\n}\r\nstatic void aer_isr_one_error(struct pcie_device *p_device,\r\nstruct aer_err_source *e_src)\r\n{\r\nstruct aer_err_info *e_info;\r\ne_info = kmalloc(sizeof(struct aer_err_info), GFP_KERNEL);\r\nif (!e_info) {\r\ndev_printk(KERN_DEBUG, &p_device->port->dev,\r\n"Can't allocate mem when processing AER errors\n");\r\nreturn;\r\n}\r\nif (e_src->status & PCI_ERR_ROOT_COR_RCV) {\r\ne_info->id = ERR_COR_ID(e_src->id);\r\ne_info->severity = AER_CORRECTABLE;\r\nif (e_src->status & PCI_ERR_ROOT_MULTI_COR_RCV)\r\ne_info->multi_error_valid = 1;\r\nelse\r\ne_info->multi_error_valid = 0;\r\naer_print_port_info(p_device->port, e_info);\r\nif (find_source_device(p_device->port, e_info))\r\naer_process_err_devices(p_device, e_info);\r\n}\r\nif (e_src->status & PCI_ERR_ROOT_UNCOR_RCV) {\r\ne_info->id = ERR_UNCOR_ID(e_src->id);\r\nif (e_src->status & PCI_ERR_ROOT_FATAL_RCV)\r\ne_info->severity = AER_FATAL;\r\nelse\r\ne_info->severity = AER_NONFATAL;\r\nif (e_src->status & PCI_ERR_ROOT_MULTI_UNCOR_RCV)\r\ne_info->multi_error_valid = 1;\r\nelse\r\ne_info->multi_error_valid = 0;\r\naer_print_port_info(p_device->port, e_info);\r\nif (find_source_device(p_device->port, e_info))\r\naer_process_err_devices(p_device, e_info);\r\n}\r\nkfree(e_info);\r\n}\r\nstatic int get_e_source(struct aer_rpc *rpc, struct aer_err_source *e_src)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rpc->e_lock, flags);\r\nif (rpc->prod_idx == rpc->cons_idx) {\r\nspin_unlock_irqrestore(&rpc->e_lock, flags);\r\nreturn 0;\r\n}\r\n*e_src = rpc->e_sources[rpc->cons_idx];\r\nrpc->cons_idx++;\r\nif (rpc->cons_idx == AER_ERROR_SOURCES_MAX)\r\nrpc->cons_idx = 0;\r\nspin_unlock_irqrestore(&rpc->e_lock, flags);\r\nreturn 1;\r\n}\r\nvoid aer_isr(struct work_struct *work)\r\n{\r\nstruct aer_rpc *rpc = container_of(work, struct aer_rpc, dpc_handler);\r\nstruct pcie_device *p_device = rpc->rpd;\r\nstruct aer_err_source uninitialized_var(e_src);\r\nmutex_lock(&rpc->rpc_mutex);\r\nwhile (get_e_source(rpc, &e_src))\r\naer_isr_one_error(p_device, &e_src);\r\nmutex_unlock(&rpc->rpc_mutex);\r\nwake_up(&rpc->wait_release);\r\n}\r\nint aer_init(struct pcie_device *dev)\r\n{\r\nif (forceload) {\r\ndev_printk(KERN_DEBUG, &dev->device,\r\n"aerdrv forceload requested.\n");\r\npcie_aer_force_firmware_first(dev->port, 0);\r\n}\r\nreturn 0;\r\n}
