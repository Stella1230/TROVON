static void __init setup_ehci_io_mux(const enum usbhs_omap_port_mode *port_mode)\r\n{\r\nswitch (port_mode[0]) {\r\ncase OMAP_EHCI_PORT_MODE_PHY:\r\nomap_mux_init_signal("hsusb1_stp", OMAP_PIN_OUTPUT);\r\nomap_mux_init_signal("hsusb1_clk", OMAP_PIN_OUTPUT);\r\nomap_mux_init_signal("hsusb1_dir", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_nxt", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data0", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data1", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data2", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data3", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data4", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data5", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data6", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_data7", OMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_EHCI_PORT_MODE_TLL:\r\nomap_mux_init_signal("hsusb1_tll_stp",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("hsusb1_tll_clk",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_dir",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_nxt",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data1",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data2",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data3",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data4",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data5",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data6",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb1_tll_data7",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (port_mode[1]) {\r\ncase OMAP_EHCI_PORT_MODE_PHY:\r\nomap_mux_init_signal("hsusb2_stp", OMAP_PIN_OUTPUT);\r\nomap_mux_init_signal("hsusb2_clk", OMAP_PIN_OUTPUT);\r\nomap_mux_init_signal("hsusb2_dir", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_nxt", OMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data1",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data2",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data3",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data4",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data5",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data6",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_data7",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_EHCI_PORT_MODE_TLL:\r\nomap_mux_init_signal("hsusb2_tll_stp",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("hsusb2_tll_clk",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_dir",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_nxt",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data1",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data2",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data3",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data4",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data5",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data6",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb2_tll_data7",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (port_mode[2]) {\r\ncase OMAP_EHCI_PORT_MODE_PHY:\r\nprintk(KERN_WARNING "Port3 can't be used in PHY mode\n");\r\nbreak;\r\ncase OMAP_EHCI_PORT_MODE_TLL:\r\nomap_mux_init_signal("hsusb3_tll_stp",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("hsusb3_tll_clk",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_dir",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_nxt",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data1",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data2",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data3",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data4",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data5",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data6",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("hsusb3_tll_data7",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void __init setup_ohci_io_mux(const enum usbhs_omap_port_mode *port_mode)\r\n{\r\nswitch (port_mode[0]) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\nomap_mux_init_signal("mm1_rxdp",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm1_rxdm",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\nomap_mux_init_signal("mm1_rxrcv",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\nomap_mux_init_signal("mm1_txen_n", OMAP_PIN_OUTPUT);\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nomap_mux_init_signal("mm1_txse0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm1_txdat",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (port_mode[1]) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\nomap_mux_init_signal("mm2_rxdp",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm2_rxdm",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\nomap_mux_init_signal("mm2_rxrcv",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\nomap_mux_init_signal("mm2_txen_n", OMAP_PIN_OUTPUT);\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nomap_mux_init_signal("mm2_txse0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm2_txdat",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (port_mode[2]) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\nomap_mux_init_signal("mm3_rxdp",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm3_rxdm",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\nomap_mux_init_signal("mm3_rxrcv",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\nomap_mux_init_signal("mm3_txen_n", OMAP_PIN_OUTPUT);\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nomap_mux_init_signal("mm3_txse0",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nomap_mux_init_signal("mm3_txdat",\r\nOMAP_PIN_INPUT_PULLDOWN);\r\nbreak;\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid __init usbhs_init(struct usbhs_omap_platform_data *pdata)\r\n{\r\nstruct omap_hwmod *uhh_hwm, *tll_hwm;\r\nstruct platform_device *pdev;\r\nint bus_id = -1;\r\nif (cpu_is_omap34xx()) {\r\nsetup_ehci_io_mux(pdata->port_mode);\r\nsetup_ohci_io_mux(pdata->port_mode);\r\nif (omap_rev() <= OMAP3430_REV_ES2_1)\r\npdata->single_ulpi_bypass = true;\r\n}\r\nuhh_hwm = omap_hwmod_lookup(USBHS_UHH_HWMODNAME);\r\nif (!uhh_hwm) {\r\npr_err("Could not look up %s\n", USBHS_UHH_HWMODNAME);\r\nreturn;\r\n}\r\ntll_hwm = omap_hwmod_lookup(USBHS_TLL_HWMODNAME);\r\nif (!tll_hwm) {\r\npr_err("Could not look up %s\n", USBHS_TLL_HWMODNAME);\r\nreturn;\r\n}\r\npdev = omap_device_build(OMAP_USBTLL_DEVICE, bus_id, tll_hwm,\r\npdata, sizeof(*pdata));\r\nif (IS_ERR(pdev)) {\r\npr_err("Could not build hwmod device %s\n",\r\nUSBHS_TLL_HWMODNAME);\r\nreturn;\r\n}\r\npdev = omap_device_build(OMAP_USBHS_DEVICE, bus_id, uhh_hwm,\r\npdata, sizeof(*pdata));\r\nif (IS_ERR(pdev)) {\r\npr_err("Could not build hwmod devices %s\n",\r\nUSBHS_UHH_HWMODNAME);\r\nreturn;\r\n}\r\n}\r\nvoid __init usbhs_init(struct usbhs_omap_platform_data *pdata)\r\n{\r\n}\r\nstatic int usbhs_add_regulator(char *name, char *dev_id, char *dev_supply,\r\nint gpio, int polarity)\r\n{\r\nstruct regulator_consumer_supply *supplies;\r\nstruct regulator_init_data *reg_data;\r\nstruct fixed_voltage_config *config;\r\nstruct platform_device *pdev;\r\nstruct platform_device_info pdevinfo;\r\nint ret = -ENOMEM;\r\nsupplies = kzalloc(sizeof(*supplies), GFP_KERNEL);\r\nif (!supplies)\r\nreturn -ENOMEM;\r\nsupplies->supply = dev_supply;\r\nsupplies->dev_name = dev_id;\r\nreg_data = kzalloc(sizeof(*reg_data), GFP_KERNEL);\r\nif (!reg_data)\r\ngoto err_data;\r\nreg_data->constraints.valid_ops_mask = REGULATOR_CHANGE_STATUS;\r\nreg_data->consumer_supplies = supplies;\r\nreg_data->num_consumer_supplies = 1;\r\nconfig = kmemdup(&hsusb_reg_config, sizeof(hsusb_reg_config),\r\nGFP_KERNEL);\r\nif (!config)\r\ngoto err_config;\r\nconfig->supply_name = kstrdup(name, GFP_KERNEL);\r\nif (!config->supply_name)\r\ngoto err_supplyname;\r\nconfig->gpio = gpio;\r\nconfig->enable_high = polarity;\r\nconfig->init_data = reg_data;\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.name = reg_name;\r\npdevinfo.id = PLATFORM_DEVID_AUTO;\r\npdevinfo.data = config;\r\npdevinfo.size_data = sizeof(*config);\r\npdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\npr_err("%s: Failed registering regulator %s for %s : %d\n",\r\n__func__, name, dev_id, ret);\r\ngoto err_register;\r\n}\r\nreturn 0;\r\nerr_register:\r\nkfree(config->supply_name);\r\nerr_supplyname:\r\nkfree(config);\r\nerr_config:\r\nkfree(reg_data);\r\nerr_data:\r\nkfree(supplies);\r\nreturn ret;\r\n}\r\nint usbhs_init_phys(struct usbhs_phy_data *phy, int num_phys)\r\n{\r\nchar rail_name[MAX_STR];\r\nint i;\r\nstruct platform_device *pdev;\r\nchar *phy_id;\r\nstruct platform_device_info pdevinfo;\r\nstruct usb_phy_generic_platform_data nop_pdata;\r\nfor (i = 0; i < num_phys; i++) {\r\nif (!phy->port) {\r\npr_err("%s: Invalid port 0. Must start from 1\n",\r\n__func__);\r\ncontinue;\r\n}\r\nif (!gpio_is_valid(phy->reset_gpio) &&\r\n!gpio_is_valid(phy->vcc_gpio))\r\ncontinue;\r\nphy_id = kmalloc(MAX_STR, GFP_KERNEL);\r\nif (!phy_id) {\r\npr_err("%s: kmalloc() failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(&nop_pdata, 0, sizeof(nop_pdata));\r\nif (gpio_is_valid(phy->vcc_gpio))\r\nnop_pdata.needs_vcc = true;\r\nnop_pdata.gpio_reset = phy->reset_gpio;\r\nnop_pdata.type = USB_PHY_TYPE_USB2;\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.name = nop_name;\r\npdevinfo.id = phy->port;\r\npdevinfo.data = &nop_pdata;\r\npdevinfo.size_data =\r\nsizeof(struct usb_phy_generic_platform_data);\r\nscnprintf(phy_id, MAX_STR, "usb_phy_generic.%d",\r\nphy->port);\r\npdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(pdev)) {\r\npr_err("%s: Failed to register device %s : %ld\n",\r\n__func__, phy_id, PTR_ERR(pdev));\r\nkfree(phy_id);\r\ncontinue;\r\n}\r\nusb_bind_phy("ehci-omap.0", phy->port - 1, phy_id);\r\nif (gpio_is_valid(phy->vcc_gpio)) {\r\nscnprintf(rail_name, MAX_STR, "hsusb%d_vcc", phy->port);\r\nusbhs_add_regulator(rail_name, phy_id, "vcc",\r\nphy->vcc_gpio, phy->vcc_polarity);\r\n}\r\nphy++;\r\n}\r\nreturn 0;\r\n}
