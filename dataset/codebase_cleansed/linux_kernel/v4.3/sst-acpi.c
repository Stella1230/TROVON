static void sst_acpi_fw_cb(const struct firmware *fw, void *context)\r\n{\r\nstruct platform_device *pdev = context;\r\nstruct device *dev = &pdev->dev;\r\nstruct sst_acpi_priv *sst_acpi = platform_get_drvdata(pdev);\r\nstruct sst_pdata *sst_pdata = &sst_acpi->sst_pdata;\r\nstruct sst_acpi_desc *desc = sst_acpi->desc;\r\nstruct sst_acpi_mach *mach = sst_acpi->mach;\r\nsst_pdata->fw = fw;\r\nif (!fw) {\r\ndev_err(dev, "Cannot load firmware %s\n", mach->fw_filename);\r\nreturn;\r\n}\r\nsst_acpi->pdev_pcm =\r\nplatform_device_register_data(dev, desc->drv_name, -1,\r\nsst_pdata, sizeof(*sst_pdata));\r\nif (IS_ERR(sst_acpi->pdev_pcm)) {\r\ndev_err(dev, "Cannot register device %s. Error %d\n",\r\ndesc->drv_name, (int)PTR_ERR(sst_acpi->pdev_pcm));\r\n}\r\nreturn;\r\n}\r\nstatic acpi_status sst_acpi_mach_match(acpi_handle handle, u32 level,\r\nvoid *context, void **ret)\r\n{\r\n*(bool *)context = true;\r\nreturn AE_OK;\r\n}\r\nstatic struct sst_acpi_mach *sst_acpi_find_machine(\r\nstruct sst_acpi_mach *machines)\r\n{\r\nstruct sst_acpi_mach *mach;\r\nbool found = false;\r\nfor (mach = machines; mach->id[0]; mach++)\r\nif (ACPI_SUCCESS(acpi_get_devices(mach->id,\r\nsst_acpi_mach_match,\r\n&found, NULL)) && found)\r\nreturn mach;\r\nreturn NULL;\r\n}\r\nstatic int sst_acpi_probe(struct platform_device *pdev)\r\n{\r\nconst struct acpi_device_id *id;\r\nstruct device *dev = &pdev->dev;\r\nstruct sst_acpi_priv *sst_acpi;\r\nstruct sst_pdata *sst_pdata;\r\nstruct sst_acpi_mach *mach;\r\nstruct sst_acpi_desc *desc;\r\nstruct resource *mmio;\r\nint ret = 0;\r\nsst_acpi = devm_kzalloc(dev, sizeof(*sst_acpi), GFP_KERNEL);\r\nif (sst_acpi == NULL)\r\nreturn -ENOMEM;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\ndesc = (struct sst_acpi_desc *)id->driver_data;\r\nmach = sst_acpi_find_machine(desc->machines);\r\nif (mach == NULL) {\r\ndev_err(dev, "No matching ASoC machine driver found\n");\r\nreturn -ENODEV;\r\n}\r\nsst_pdata = &sst_acpi->sst_pdata;\r\nsst_pdata->id = desc->sst_id;\r\nsst_pdata->dma_dev = dev;\r\nsst_acpi->desc = desc;\r\nsst_acpi->mach = mach;\r\nsst_pdata->resindex_dma_base = desc->resindex_dma_base;\r\nif (desc->resindex_dma_base >= 0) {\r\nsst_pdata->dma_engine = desc->dma_engine;\r\nsst_pdata->dma_base = desc->resindex_dma_base;\r\nsst_pdata->dma_size = desc->dma_size;\r\n}\r\nif (desc->irqindex_host_ipc >= 0)\r\nsst_pdata->irq = platform_get_irq(pdev, desc->irqindex_host_ipc);\r\nif (desc->resindex_lpe_base >= 0) {\r\nmmio = platform_get_resource(pdev, IORESOURCE_MEM,\r\ndesc->resindex_lpe_base);\r\nif (mmio) {\r\nsst_pdata->lpe_base = mmio->start;\r\nsst_pdata->lpe_size = resource_size(mmio);\r\n}\r\n}\r\nif (desc->resindex_pcicfg_base >= 0) {\r\nmmio = platform_get_resource(pdev, IORESOURCE_MEM,\r\ndesc->resindex_pcicfg_base);\r\nif (mmio) {\r\nsst_pdata->pcicfg_base = mmio->start;\r\nsst_pdata->pcicfg_size = resource_size(mmio);\r\n}\r\n}\r\nif (desc->resindex_fw_base >= 0) {\r\nmmio = platform_get_resource(pdev, IORESOURCE_MEM,\r\ndesc->resindex_fw_base);\r\nif (mmio) {\r\nsst_pdata->fw_base = mmio->start;\r\nsst_pdata->fw_size = resource_size(mmio);\r\n}\r\n}\r\nplatform_set_drvdata(pdev, sst_acpi);\r\nsst_acpi->pdev_mach =\r\nplatform_device_register_data(dev, mach->drv_name, -1,\r\nsst_pdata, sizeof(*sst_pdata));\r\nif (IS_ERR(sst_acpi->pdev_mach))\r\nreturn PTR_ERR(sst_acpi->pdev_mach);\r\nret = request_firmware_nowait(THIS_MODULE, true, mach->fw_filename,\r\ndev, GFP_KERNEL, pdev, sst_acpi_fw_cb);\r\nif (ret)\r\nplatform_device_unregister(sst_acpi->pdev_mach);\r\nreturn ret;\r\n}\r\nstatic int sst_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct sst_acpi_priv *sst_acpi = platform_get_drvdata(pdev);\r\nstruct sst_pdata *sst_pdata = &sst_acpi->sst_pdata;\r\nplatform_device_unregister(sst_acpi->pdev_mach);\r\nif (!IS_ERR_OR_NULL(sst_acpi->pdev_pcm))\r\nplatform_device_unregister(sst_acpi->pdev_pcm);\r\nrelease_firmware(sst_pdata->fw);\r\nreturn 0;\r\n}
