static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)\r\n{\r\nstruct i2c_msg msgs[1] = {{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1 } };\r\nreturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\r\n}\r\nstatic int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = &reg, .len = 1 },\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1 } };\r\nreturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\r\n}\r\nstatic int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,\r\nu16 reg, u8 *val)\r\n{\r\nu8 msg[2] = {reg>>8, reg&0xff};\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = msg, .len = 2},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1} };\r\nreturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\r\n}\r\nstatic int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)\r\n{\r\nstruct ddb *dev = i2c->dev;\r\nint stat;\r\nu32 val;\r\ni2c->done = 0;\r\nddbwritel((adr << 9) | cmd, i2c->regs + I2C_COMMAND);\r\nstat = wait_event_timeout(i2c->wq, i2c->done == 1, HZ);\r\nif (stat <= 0) {\r\nprintk(KERN_ERR "I2C timeout\n");\r\n{\r\nu32 istat = ddbreadl(INTERRUPT_STATUS);\r\nprintk(KERN_ERR "IRS %08x\n", istat);\r\nddbwritel(istat, INTERRUPT_ACK);\r\n}\r\nreturn -EIO;\r\n}\r\nval = ddbreadl(i2c->regs+I2C_COMMAND);\r\nif (val & 0x70000)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ddb_i2c_master_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);\r\nstruct ddb *dev = i2c->dev;\r\nu8 addr = 0;\r\nif (num)\r\naddr = msg[0].addr;\r\nif (num == 2 && msg[1].flags & I2C_M_RD &&\r\n!(msg[0].flags & I2C_M_RD)) {\r\nmemcpy_toio(dev->regs + I2C_TASKMEM_BASE + i2c->wbuf,\r\nmsg[0].buf, msg[0].len);\r\nddbwritel(msg[0].len|(msg[1].len << 16),\r\ni2c->regs+I2C_TASKLENGTH);\r\nif (!ddb_i2c_cmd(i2c, addr, 1)) {\r\nmemcpy_fromio(msg[1].buf,\r\ndev->regs + I2C_TASKMEM_BASE + i2c->rbuf,\r\nmsg[1].len);\r\nreturn num;\r\n}\r\n}\r\nif (num == 1 && !(msg[0].flags & I2C_M_RD)) {\r\nddbcpyto(I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);\r\nddbwritel(msg[0].len, i2c->regs + I2C_TASKLENGTH);\r\nif (!ddb_i2c_cmd(i2c, addr, 2))\r\nreturn num;\r\n}\r\nif (num == 1 && (msg[0].flags & I2C_M_RD)) {\r\nddbwritel(msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);\r\nif (!ddb_i2c_cmd(i2c, addr, 3)) {\r\nddbcpyfrom(msg[0].buf,\r\nI2C_TASKMEM_BASE + i2c->rbuf, msg[0].len);\r\nreturn num;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic u32 ddb_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void ddb_i2c_release(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_i2c *i2c;\r\nstruct i2c_adapter *adap;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\ni2c = &dev->i2c[i];\r\nadap = &i2c->adap;\r\ni2c_del_adapter(adap);\r\n}\r\n}\r\nstatic int ddb_i2c_init(struct ddb *dev)\r\n{\r\nint i, j, stat = 0;\r\nstruct ddb_i2c *i2c;\r\nstruct i2c_adapter *adap;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\ni2c = &dev->i2c[i];\r\ni2c->dev = dev;\r\ni2c->nr = i;\r\ni2c->wbuf = i * (I2C_TASKMEM_SIZE / 4);\r\ni2c->rbuf = i2c->wbuf + (I2C_TASKMEM_SIZE / 8);\r\ni2c->regs = 0x80 + i * 0x20;\r\nddbwritel(I2C_SPEED_100, i2c->regs + I2C_TIMING);\r\nddbwritel((i2c->rbuf << 16) | i2c->wbuf,\r\ni2c->regs + I2C_TASKADDRESS);\r\ninit_waitqueue_head(&i2c->wq);\r\nadap = &i2c->adap;\r\ni2c_set_adapdata(adap, i2c);\r\n#ifdef I2C_ADAP_CLASS_TV_DIGITAL\r\nadap->class = I2C_ADAP_CLASS_TV_DIGITAL|I2C_CLASS_TV_ANALOG;\r\n#else\r\n#ifdef I2C_CLASS_TV_ANALOG\r\nadap->class = I2C_CLASS_TV_ANALOG;\r\n#endif\r\n#endif\r\nstrcpy(adap->name, "ddbridge");\r\nadap->algo = &ddb_i2c_algo;\r\nadap->algo_data = (void *)i2c;\r\nadap->dev.parent = &dev->pdev->dev;\r\nstat = i2c_add_adapter(adap);\r\nif (stat)\r\nbreak;\r\n}\r\nif (stat)\r\nfor (j = 0; j < i; j++) {\r\ni2c = &dev->i2c[j];\r\nadap = &i2c->adap;\r\ni2c_del_adapter(adap);\r\n}\r\nreturn stat;\r\n}\r\nstatic void ddb_address_table(struct ddb *dev)\r\n{\r\nu32 i, j, base;\r\nu64 mem;\r\ndma_addr_t *pbuf;\r\nfor (i = 0; i < dev->info->port_num * 2; i++) {\r\nbase = DMA_BASE_ADDRESS_TABLE + i * 0x100;\r\npbuf = dev->input[i].pbuf;\r\nfor (j = 0; j < dev->input[i].dma_buf_num; j++) {\r\nmem = pbuf[j];\r\nddbwritel(mem & 0xffffffff, base + j * 8);\r\nddbwritel(mem >> 32, base + j * 8 + 4);\r\n}\r\n}\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nbase = DMA_BASE_ADDRESS_TABLE + 0x800 + i * 0x100;\r\npbuf = dev->output[i].pbuf;\r\nfor (j = 0; j < dev->output[i].dma_buf_num; j++) {\r\nmem = pbuf[j];\r\nddbwritel(mem & 0xffffffff, base + j * 8);\r\nddbwritel(mem >> 32, base + j * 8 + 4);\r\n}\r\n}\r\n}\r\nstatic void io_free(struct pci_dev *pdev, u8 **vbuf,\r\ndma_addr_t *pbuf, u32 size, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nif (vbuf[i]) {\r\npci_free_consistent(pdev, size, vbuf[i], pbuf[i]);\r\nvbuf[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int io_alloc(struct pci_dev *pdev, u8 **vbuf,\r\ndma_addr_t *pbuf, u32 size, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nvbuf[i] = pci_alloc_consistent(pdev, size, &pbuf[i]);\r\nif (!vbuf[i])\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ddb_buffers_alloc(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nswitch (port->class) {\r\ncase DDB_PORT_TUNER:\r\nif (io_alloc(dev->pdev, port->input[0]->vbuf,\r\nport->input[0]->pbuf,\r\nport->input[0]->dma_buf_size,\r\nport->input[0]->dma_buf_num) < 0)\r\nreturn -1;\r\nif (io_alloc(dev->pdev, port->input[1]->vbuf,\r\nport->input[1]->pbuf,\r\nport->input[1]->dma_buf_size,\r\nport->input[1]->dma_buf_num) < 0)\r\nreturn -1;\r\nbreak;\r\ncase DDB_PORT_CI:\r\nif (io_alloc(dev->pdev, port->input[0]->vbuf,\r\nport->input[0]->pbuf,\r\nport->input[0]->dma_buf_size,\r\nport->input[0]->dma_buf_num) < 0)\r\nreturn -1;\r\nif (io_alloc(dev->pdev, port->output->vbuf,\r\nport->output->pbuf,\r\nport->output->dma_buf_size,\r\nport->output->dma_buf_num) < 0)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nddb_address_table(dev);\r\nreturn 0;\r\n}\r\nstatic void ddb_buffers_free(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nio_free(dev->pdev, port->input[0]->vbuf,\r\nport->input[0]->pbuf,\r\nport->input[0]->dma_buf_size,\r\nport->input[0]->dma_buf_num);\r\nio_free(dev->pdev, port->input[1]->vbuf,\r\nport->input[1]->pbuf,\r\nport->input[1]->dma_buf_size,\r\nport->input[1]->dma_buf_num);\r\nio_free(dev->pdev, port->output->vbuf,\r\nport->output->pbuf,\r\nport->output->dma_buf_size,\r\nport->output->dma_buf_num);\r\n}\r\n}\r\nstatic void ddb_input_start(struct ddb_input *input)\r\n{\r\nstruct ddb *dev = input->port->dev;\r\nspin_lock_irq(&input->lock);\r\ninput->cbuf = 0;\r\ninput->coff = 0;\r\nddbwritel(0, TS_INPUT_CONTROL(input->nr));\r\nddbwritel(2, TS_INPUT_CONTROL(input->nr));\r\nddbwritel(0, TS_INPUT_CONTROL(input->nr));\r\nddbwritel((1 << 16) |\r\n(input->dma_buf_num << 11) |\r\n(input->dma_buf_size >> 7),\r\nDMA_BUFFER_SIZE(input->nr));\r\nddbwritel(0, DMA_BUFFER_ACK(input->nr));\r\nddbwritel(1, DMA_BASE_WRITE);\r\nddbwritel(3, DMA_BUFFER_CONTROL(input->nr));\r\nddbwritel(9, TS_INPUT_CONTROL(input->nr));\r\ninput->running = 1;\r\nspin_unlock_irq(&input->lock);\r\n}\r\nstatic void ddb_input_stop(struct ddb_input *input)\r\n{\r\nstruct ddb *dev = input->port->dev;\r\nspin_lock_irq(&input->lock);\r\nddbwritel(0, TS_INPUT_CONTROL(input->nr));\r\nddbwritel(0, DMA_BUFFER_CONTROL(input->nr));\r\ninput->running = 0;\r\nspin_unlock_irq(&input->lock);\r\n}\r\nstatic void ddb_output_start(struct ddb_output *output)\r\n{\r\nstruct ddb *dev = output->port->dev;\r\nspin_lock_irq(&output->lock);\r\noutput->cbuf = 0;\r\noutput->coff = 0;\r\nddbwritel(0, TS_OUTPUT_CONTROL(output->nr));\r\nddbwritel(2, TS_OUTPUT_CONTROL(output->nr));\r\nddbwritel(0, TS_OUTPUT_CONTROL(output->nr));\r\nddbwritel(0x3c, TS_OUTPUT_CONTROL(output->nr));\r\nddbwritel((1 << 16) |\r\n(output->dma_buf_num << 11) |\r\n(output->dma_buf_size >> 7),\r\nDMA_BUFFER_SIZE(output->nr + 8));\r\nddbwritel(0, DMA_BUFFER_ACK(output->nr + 8));\r\nddbwritel(1, DMA_BASE_READ);\r\nddbwritel(3, DMA_BUFFER_CONTROL(output->nr + 8));\r\nddbwritel(0x1d, TS_OUTPUT_CONTROL(output->nr));\r\noutput->running = 1;\r\nspin_unlock_irq(&output->lock);\r\n}\r\nstatic void ddb_output_stop(struct ddb_output *output)\r\n{\r\nstruct ddb *dev = output->port->dev;\r\nspin_lock_irq(&output->lock);\r\nddbwritel(0, TS_OUTPUT_CONTROL(output->nr));\r\nddbwritel(0, DMA_BUFFER_CONTROL(output->nr + 8));\r\noutput->running = 0;\r\nspin_unlock_irq(&output->lock);\r\n}\r\nstatic u32 ddb_output_free(struct ddb_output *output)\r\n{\r\nu32 idx, off, stat = output->stat;\r\ns32 diff;\r\nidx = (stat >> 11) & 0x1f;\r\noff = (stat & 0x7ff) << 7;\r\nif (output->cbuf != idx) {\r\nif ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&\r\n(output->dma_buf_size - output->coff <= 188))\r\nreturn 0;\r\nreturn 188;\r\n}\r\ndiff = off - output->coff;\r\nif (diff <= 0 || diff > 188)\r\nreturn 188;\r\nreturn 0;\r\n}\r\nstatic ssize_t ddb_output_write(struct ddb_output *output,\r\nconst __user u8 *buf, size_t count)\r\n{\r\nstruct ddb *dev = output->port->dev;\r\nu32 idx, off, stat = output->stat;\r\nu32 left = count, len;\r\nidx = (stat >> 11) & 0x1f;\r\noff = (stat & 0x7ff) << 7;\r\nwhile (left) {\r\nlen = output->dma_buf_size - output->coff;\r\nif ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&\r\n(off == 0)) {\r\nif (len <= 188)\r\nbreak;\r\nlen -= 188;\r\n}\r\nif (output->cbuf == idx) {\r\nif (off > output->coff) {\r\n#if 1\r\nlen = off - output->coff;\r\nlen -= (len % 188);\r\nif (len <= 188)\r\n#endif\r\nbreak;\r\nlen -= 188;\r\n}\r\n}\r\nif (len > left)\r\nlen = left;\r\nif (copy_from_user(output->vbuf[output->cbuf] + output->coff,\r\nbuf, len))\r\nreturn -EIO;\r\nleft -= len;\r\nbuf += len;\r\noutput->coff += len;\r\nif (output->coff == output->dma_buf_size) {\r\noutput->coff = 0;\r\noutput->cbuf = ((output->cbuf + 1) % output->dma_buf_num);\r\n}\r\nddbwritel((output->cbuf << 11) | (output->coff >> 7),\r\nDMA_BUFFER_ACK(output->nr + 8));\r\n}\r\nreturn count - left;\r\n}\r\nstatic u32 ddb_input_avail(struct ddb_input *input)\r\n{\r\nstruct ddb *dev = input->port->dev;\r\nu32 idx, off, stat = input->stat;\r\nu32 ctrl = ddbreadl(DMA_BUFFER_CONTROL(input->nr));\r\nidx = (stat >> 11) & 0x1f;\r\noff = (stat & 0x7ff) << 7;\r\nif (ctrl & 4) {\r\nprintk(KERN_ERR "IA %d %d %08x\n", idx, off, ctrl);\r\nddbwritel(input->stat, DMA_BUFFER_ACK(input->nr));\r\nreturn 0;\r\n}\r\nif (input->cbuf != idx)\r\nreturn 188;\r\nreturn 0;\r\n}\r\nstatic ssize_t ddb_input_read(struct ddb_input *input, __user u8 *buf, size_t count)\r\n{\r\nstruct ddb *dev = input->port->dev;\r\nu32 left = count;\r\nu32 idx, free, stat = input->stat;\r\nint ret;\r\nidx = (stat >> 11) & 0x1f;\r\nwhile (left) {\r\nif (input->cbuf == idx)\r\nreturn count - left;\r\nfree = input->dma_buf_size - input->coff;\r\nif (free > left)\r\nfree = left;\r\nret = copy_to_user(buf, input->vbuf[input->cbuf] +\r\ninput->coff, free);\r\nif (ret)\r\nreturn -EFAULT;\r\ninput->coff += free;\r\nif (input->coff == input->dma_buf_size) {\r\ninput->coff = 0;\r\ninput->cbuf = (input->cbuf+1) % input->dma_buf_num;\r\n}\r\nleft -= free;\r\nddbwritel((input->cbuf << 11) | (input->coff >> 7),\r\nDMA_BUFFER_ACK(input->nr));\r\n}\r\nreturn count;\r\n}\r\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct ddb_input *input = fe->sec_priv;\r\nstruct ddb_port *port = input->port;\r\nint status;\r\nif (enable) {\r\nmutex_lock(&port->i2c_gate_lock);\r\nstatus = input->gate_ctrl(fe, 1);\r\n} else {\r\nstatus = input->gate_ctrl(fe, 0);\r\nmutex_unlock(&port->i2c_gate_lock);\r\n}\r\nreturn status;\r\n}\r\nstatic int demod_attach_drxk(struct ddb_input *input)\r\n{\r\nstruct i2c_adapter *i2c = &input->port->i2c->adap;\r\nstruct dvb_frontend *fe;\r\nstruct drxk_config config;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.microcode_name = "drxk_a3.mc";\r\nconfig.qam_demod_parameter_count = 4;\r\nconfig.adr = 0x29 + (input->nr & 1);\r\nfe = input->fe = dvb_attach(drxk_attach, &config, i2c);\r\nif (!input->fe) {\r\nprintk(KERN_ERR "No DRXK found!\n");\r\nreturn -ENODEV;\r\n}\r\nfe->sec_priv = input;\r\ninput->gate_ctrl = fe->ops.i2c_gate_ctrl;\r\nfe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\nreturn 0;\r\n}\r\nstatic int tuner_attach_tda18271(struct ddb_input *input)\r\n{\r\nstruct i2c_adapter *i2c = &input->port->i2c->adap;\r\nstruct dvb_frontend *fe;\r\nif (input->fe->ops.i2c_gate_ctrl)\r\ninput->fe->ops.i2c_gate_ctrl(input->fe, 1);\r\nfe = dvb_attach(tda18271c2dd_attach, input->fe, i2c, 0x60);\r\nif (!fe) {\r\nprintk(KERN_ERR "No TDA18271 found!\n");\r\nreturn -ENODEV;\r\n}\r\nif (input->fe->ops.i2c_gate_ctrl)\r\ninput->fe->ops.i2c_gate_ctrl(input->fe, 0);\r\nreturn 0;\r\n}\r\nstatic int demod_attach_stv0900(struct ddb_input *input, int type)\r\n{\r\nstruct i2c_adapter *i2c = &input->port->i2c->adap;\r\nstruct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;\r\ninput->fe = dvb_attach(stv090x_attach, feconf, i2c,\r\n(input->nr & 1) ? STV090x_DEMODULATOR_1\r\n: STV090x_DEMODULATOR_0);\r\nif (!input->fe) {\r\nprintk(KERN_ERR "No STV0900 found!\n");\r\nreturn -ENODEV;\r\n}\r\nif (!dvb_attach(lnbh24_attach, input->fe, i2c, 0,\r\n0, (input->nr & 1) ?\r\n(0x09 - type) : (0x0b - type))) {\r\nprintk(KERN_ERR "No LNBH24 found!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tuner_attach_stv6110(struct ddb_input *input, int type)\r\n{\r\nstruct i2c_adapter *i2c = &input->port->i2c->adap;\r\nstruct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;\r\nstruct stv6110x_config *tunerconf = (input->nr & 1) ?\r\n&stv6110b : &stv6110a;\r\nstruct stv6110x_devctl *ctl;\r\nctl = dvb_attach(stv6110x_attach, input->fe, tunerconf, i2c);\r\nif (!ctl) {\r\nprintk(KERN_ERR "No STV6110X found!\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "attach tuner input %d adr %02x\n",\r\ninput->nr, tunerconf->addr);\r\nfeconf->tuner_init = ctl->tuner_init;\r\nfeconf->tuner_sleep = ctl->tuner_sleep;\r\nfeconf->tuner_set_mode = ctl->tuner_set_mode;\r\nfeconf->tuner_set_frequency = ctl->tuner_set_frequency;\r\nfeconf->tuner_get_frequency = ctl->tuner_get_frequency;\r\nfeconf->tuner_set_bandwidth = ctl->tuner_set_bandwidth;\r\nfeconf->tuner_get_bandwidth = ctl->tuner_get_bandwidth;\r\nfeconf->tuner_set_bbgain = ctl->tuner_set_bbgain;\r\nfeconf->tuner_get_bbgain = ctl->tuner_get_bbgain;\r\nfeconf->tuner_set_refclk = ctl->tuner_set_refclk;\r\nfeconf->tuner_get_status = ctl->tuner_get_status;\r\nreturn 0;\r\n}\r\nstatic int my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\r\nint (*start_feed)(struct dvb_demux_feed *),\r\nint (*stop_feed)(struct dvb_demux_feed *),\r\nvoid *priv)\r\n{\r\ndvbdemux->priv = priv;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = start_feed;\r\ndvbdemux->stop_feed = stop_feed;\r\ndvbdemux->write_to_decoder = NULL;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\nreturn dvb_dmx_init(dvbdemux);\r\n}\r\nstatic int my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\r\nstruct dvb_demux *dvbdemux,\r\nstruct dmx_frontend *hw_frontend,\r\nstruct dmx_frontend *mem_frontend,\r\nstruct dvb_adapter *dvb_adapter)\r\n{\r\nint ret;\r\ndmxdev->filternum = 256;\r\ndmxdev->demux = &dvbdemux->dmx;\r\ndmxdev->capabilities = 0;\r\nret = dvb_dmxdev_init(dmxdev, dvb_adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nhw_frontend->source = DMX_FRONTEND_0;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, hw_frontend);\r\nmem_frontend->source = DMX_MEMORY_FE;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, mem_frontend);\r\nreturn dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, hw_frontend);\r\n}\r\nstatic int start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct ddb_input *input = dvbdmx->priv;\r\nif (!input->users)\r\nddb_input_start(input);\r\nreturn ++input->users;\r\n}\r\nstatic int stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct ddb_input *input = dvbdmx->priv;\r\nif (--input->users)\r\nreturn input->users;\r\nddb_input_stop(input);\r\nreturn 0;\r\n}\r\nstatic void dvb_input_detach(struct ddb_input *input)\r\n{\r\nstruct dvb_adapter *adap = &input->adap;\r\nstruct dvb_demux *dvbdemux = &input->demux;\r\nswitch (input->attached) {\r\ncase 5:\r\nif (input->fe2)\r\ndvb_unregister_frontend(input->fe2);\r\nif (input->fe) {\r\ndvb_unregister_frontend(input->fe);\r\ndvb_frontend_detach(input->fe);\r\ninput->fe = NULL;\r\n}\r\ncase 4:\r\ndvb_net_release(&input->dvbnet);\r\ncase 3:\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\r\n&input->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\r\n&input->mem_frontend);\r\ndvb_dmxdev_release(&input->dmxdev);\r\ncase 2:\r\ndvb_dmx_release(&input->demux);\r\ncase 1:\r\ndvb_unregister_adapter(adap);\r\n}\r\ninput->attached = 0;\r\n}\r\nstatic int dvb_input_attach(struct ddb_input *input)\r\n{\r\nint ret;\r\nstruct ddb_port *port = input->port;\r\nstruct dvb_adapter *adap = &input->adap;\r\nstruct dvb_demux *dvbdemux = &input->demux;\r\nret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,\r\n&input->port->dev->pdev->dev,\r\nadapter_nr);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "ddbridge: Could not register adapter."\r\n"Check if you enabled enough adapters in dvb-core!\n");\r\nreturn ret;\r\n}\r\ninput->attached = 1;\r\nret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",\r\nstart_feed,\r\nstop_feed, input);\r\nif (ret < 0)\r\nreturn ret;\r\ninput->attached = 2;\r\nret = my_dvb_dmxdev_ts_card_init(&input->dmxdev, &input->demux,\r\n&input->hw_frontend,\r\n&input->mem_frontend, adap);\r\nif (ret < 0)\r\nreturn ret;\r\ninput->attached = 3;\r\nret = dvb_net_init(adap, &input->dvbnet, input->dmxdev.demux);\r\nif (ret < 0)\r\nreturn ret;\r\ninput->attached = 4;\r\ninput->fe = NULL;\r\nswitch (port->type) {\r\ncase DDB_TUNER_DVBS_ST:\r\nif (demod_attach_stv0900(input, 0) < 0)\r\nreturn -ENODEV;\r\nif (tuner_attach_stv6110(input, 0) < 0)\r\nreturn -ENODEV;\r\nif (input->fe) {\r\nif (dvb_register_frontend(adap, input->fe) < 0)\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase DDB_TUNER_DVBS_ST_AA:\r\nif (demod_attach_stv0900(input, 1) < 0)\r\nreturn -ENODEV;\r\nif (tuner_attach_stv6110(input, 1) < 0)\r\nreturn -ENODEV;\r\nif (input->fe) {\r\nif (dvb_register_frontend(adap, input->fe) < 0)\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase DDB_TUNER_DVBCT_TR:\r\nif (demod_attach_drxk(input) < 0)\r\nreturn -ENODEV;\r\nif (tuner_attach_tda18271(input) < 0)\r\nreturn -ENODEV;\r\nif (dvb_register_frontend(adap, input->fe) < 0)\r\nreturn -ENODEV;\r\nif (input->fe2) {\r\nif (dvb_register_frontend(adap, input->fe2) < 0)\r\nreturn -ENODEV;\r\ninput->fe2->tuner_priv = input->fe->tuner_priv;\r\nmemcpy(&input->fe2->ops.tuner_ops,\r\n&input->fe->ops.tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\n}\r\nbreak;\r\n}\r\ninput->attached = 5;\r\nreturn 0;\r\n}\r\nstatic ssize_t ts_write(struct file *file, const __user char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct ddb_output *output = dvbdev->priv;\r\nsize_t left = count;\r\nint stat;\r\nwhile (left) {\r\nif (ddb_output_free(output) < 188) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nif (wait_event_interruptible(\r\noutput->wq, ddb_output_free(output) >= 188) < 0)\r\nbreak;\r\n}\r\nstat = ddb_output_write(output, buf, left);\r\nif (stat < 0)\r\nbreak;\r\nbuf += stat;\r\nleft -= stat;\r\n}\r\nreturn (left == count) ? -EAGAIN : (count - left);\r\n}\r\nstatic ssize_t ts_read(struct file *file, __user char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct ddb_output *output = dvbdev->priv;\r\nstruct ddb_input *input = output->port->input[0];\r\nint left, read;\r\ncount -= count % 188;\r\nleft = count;\r\nwhile (left) {\r\nif (ddb_input_avail(input) < 188) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nif (wait_event_interruptible(\r\ninput->wq, ddb_input_avail(input) >= 188) < 0)\r\nbreak;\r\n}\r\nread = ddb_input_read(input, buf, left);\r\nif (read < 0)\r\nreturn read;\r\nleft -= read;\r\nbuf += read;\r\n}\r\nreturn (left == count) ? -EAGAIN : (count - left);\r\n}\r\nstatic unsigned int ts_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\n#if 0\r\nif (data_avail_to_read)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (data_avail_to_write)\r\nmask |= POLLOUT | POLLWRNORM;\r\npoll_wait(file, &read_queue, wait);\r\npoll_wait(file, &write_queue, wait);\r\n#endif\r\nreturn mask;\r\n}\r\nstatic void input_tasklet(unsigned long data)\r\n{\r\nstruct ddb_input *input = (struct ddb_input *) data;\r\nstruct ddb *dev = input->port->dev;\r\nspin_lock(&input->lock);\r\nif (!input->running) {\r\nspin_unlock(&input->lock);\r\nreturn;\r\n}\r\ninput->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));\r\nif (input->port->class == DDB_PORT_TUNER) {\r\nif (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))\r\nprintk(KERN_ERR "Overflow input %d\n", input->nr);\r\nwhile (input->cbuf != ((input->stat >> 11) & 0x1f)\r\n|| (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {\r\ndvb_dmx_swfilter_packets(&input->demux,\r\ninput->vbuf[input->cbuf],\r\ninput->dma_buf_size / 188);\r\ninput->cbuf = (input->cbuf + 1) % input->dma_buf_num;\r\nddbwritel((input->cbuf << 11),\r\nDMA_BUFFER_ACK(input->nr));\r\ninput->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));\r\n}\r\n}\r\nif (input->port->class == DDB_PORT_CI)\r\nwake_up(&input->wq);\r\nspin_unlock(&input->lock);\r\n}\r\nstatic void output_tasklet(unsigned long data)\r\n{\r\nstruct ddb_output *output = (struct ddb_output *) data;\r\nstruct ddb *dev = output->port->dev;\r\nspin_lock(&output->lock);\r\nif (!output->running) {\r\nspin_unlock(&output->lock);\r\nreturn;\r\n}\r\noutput->stat = ddbreadl(DMA_BUFFER_CURRENT(output->nr + 8));\r\nwake_up(&output->wq);\r\nspin_unlock(&output->lock);\r\n}\r\nstatic int ddb_ci_attach(struct ddb_port *port)\r\n{\r\nint ret;\r\nret = dvb_register_adapter(&port->output->adap,\r\n"DDBridge",\r\nTHIS_MODULE,\r\n&port->dev->pdev->dev,\r\nadapter_nr);\r\nif (ret < 0)\r\nreturn ret;\r\nport->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);\r\nif (!port->en) {\r\ndvb_unregister_adapter(&port->output->adap);\r\nreturn -ENODEV;\r\n}\r\nddb_input_start(port->input[0]);\r\nddb_output_start(port->output);\r\ndvb_ca_en50221_init(&port->output->adap,\r\nport->en, 0, 1);\r\nret = dvb_register_device(&port->output->adap, &port->output->dev,\r\n&dvbdev_ci, (void *) port->output,\r\nDVB_DEVICE_SEC);\r\nreturn ret;\r\n}\r\nstatic int ddb_port_attach(struct ddb_port *port)\r\n{\r\nint ret = 0;\r\nswitch (port->class) {\r\ncase DDB_PORT_TUNER:\r\nret = dvb_input_attach(port->input[0]);\r\nif (ret < 0)\r\nbreak;\r\nret = dvb_input_attach(port->input[1]);\r\nbreak;\r\ncase DDB_PORT_CI:\r\nret = ddb_ci_attach(port);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret < 0)\r\nprintk(KERN_ERR "port_attach on port %d failed\n", port->nr);\r\nreturn ret;\r\n}\r\nstatic int ddb_ports_attach(struct ddb *dev)\r\n{\r\nint i, ret = 0;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nret = ddb_port_attach(port);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ddb_ports_detach(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nswitch (port->class) {\r\ncase DDB_PORT_TUNER:\r\ndvb_input_detach(port->input[0]);\r\ndvb_input_detach(port->input[1]);\r\nbreak;\r\ncase DDB_PORT_CI:\r\ndvb_unregister_device(port->output->dev);\r\nif (port->en) {\r\nddb_input_stop(port->input[0]);\r\nddb_output_stop(port->output);\r\ndvb_ca_en50221_release(port->en);\r\nkfree(port->en);\r\nport->en = NULL;\r\ndvb_unregister_adapter(&port->output->adap);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int port_has_ci(struct ddb_port *port)\r\n{\r\nu8 val;\r\nreturn i2c_read_reg(&port->i2c->adap, 0x40, 0, &val) ? 0 : 1;\r\n}\r\nstatic int port_has_stv0900(struct ddb_port *port)\r\n{\r\nu8 val;\r\nif (i2c_read_reg16(&port->i2c->adap, 0x69, 0xf100, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int port_has_stv0900_aa(struct ddb_port *port)\r\n{\r\nu8 val;\r\nif (i2c_read_reg16(&port->i2c->adap, 0x68, 0xf100, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int port_has_drxks(struct ddb_port *port)\r\n{\r\nu8 val;\r\nif (i2c_read(&port->i2c->adap, 0x29, &val) < 0)\r\nreturn 0;\r\nif (i2c_read(&port->i2c->adap, 0x2a, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void ddb_port_probe(struct ddb_port *port)\r\n{\r\nstruct ddb *dev = port->dev;\r\nchar *modname = "NO MODULE";\r\nport->class = DDB_PORT_NONE;\r\nif (port_has_ci(port)) {\r\nmodname = "CI";\r\nport->class = DDB_PORT_CI;\r\nddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);\r\n} else if (port_has_stv0900(port)) {\r\nmodname = "DUAL DVB-S2";\r\nport->class = DDB_PORT_TUNER;\r\nport->type = DDB_TUNER_DVBS_ST;\r\nddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);\r\n} else if (port_has_stv0900_aa(port)) {\r\nmodname = "DUAL DVB-S2";\r\nport->class = DDB_PORT_TUNER;\r\nport->type = DDB_TUNER_DVBS_ST_AA;\r\nddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);\r\n} else if (port_has_drxks(port)) {\r\nmodname = "DUAL DVB-C/T";\r\nport->class = DDB_PORT_TUNER;\r\nport->type = DDB_TUNER_DVBCT_TR;\r\nddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);\r\n}\r\nprintk(KERN_INFO "Port %d (TAB %d): %s\n",\r\nport->nr, port->nr+1, modname);\r\n}\r\nstatic void ddb_input_init(struct ddb_port *port, int nr)\r\n{\r\nstruct ddb *dev = port->dev;\r\nstruct ddb_input *input = &dev->input[nr];\r\ninput->nr = nr;\r\ninput->port = port;\r\ninput->dma_buf_num = INPUT_DMA_BUFS;\r\ninput->dma_buf_size = INPUT_DMA_SIZE;\r\nddbwritel(0, TS_INPUT_CONTROL(nr));\r\nddbwritel(2, TS_INPUT_CONTROL(nr));\r\nddbwritel(0, TS_INPUT_CONTROL(nr));\r\nddbwritel(0, DMA_BUFFER_ACK(nr));\r\ntasklet_init(&input->tasklet, input_tasklet, (unsigned long) input);\r\nspin_lock_init(&input->lock);\r\ninit_waitqueue_head(&input->wq);\r\n}\r\nstatic void ddb_output_init(struct ddb_port *port, int nr)\r\n{\r\nstruct ddb *dev = port->dev;\r\nstruct ddb_output *output = &dev->output[nr];\r\noutput->nr = nr;\r\noutput->port = port;\r\noutput->dma_buf_num = OUTPUT_DMA_BUFS;\r\noutput->dma_buf_size = OUTPUT_DMA_SIZE;\r\nddbwritel(0, TS_OUTPUT_CONTROL(nr));\r\nddbwritel(2, TS_OUTPUT_CONTROL(nr));\r\nddbwritel(0, TS_OUTPUT_CONTROL(nr));\r\ntasklet_init(&output->tasklet, output_tasklet, (unsigned long) output);\r\ninit_waitqueue_head(&output->wq);\r\n}\r\nstatic void ddb_ports_init(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nport->dev = dev;\r\nport->nr = i;\r\nport->i2c = &dev->i2c[i];\r\nport->input[0] = &dev->input[2 * i];\r\nport->input[1] = &dev->input[2 * i + 1];\r\nport->output = &dev->output[i];\r\nmutex_init(&port->i2c_gate_lock);\r\nddb_port_probe(port);\r\nddb_input_init(port, 2 * i);\r\nddb_input_init(port, 2 * i + 1);\r\nddb_output_init(port, i);\r\n}\r\n}\r\nstatic void ddb_ports_release(struct ddb *dev)\r\n{\r\nint i;\r\nstruct ddb_port *port;\r\nfor (i = 0; i < dev->info->port_num; i++) {\r\nport = &dev->port[i];\r\nport->dev = dev;\r\ntasklet_kill(&port->input[0]->tasklet);\r\ntasklet_kill(&port->input[1]->tasklet);\r\ntasklet_kill(&port->output->tasklet);\r\n}\r\n}\r\nstatic void irq_handle_i2c(struct ddb *dev, int n)\r\n{\r\nstruct ddb_i2c *i2c = &dev->i2c[n];\r\ni2c->done = 1;\r\nwake_up(&i2c->wq);\r\n}\r\nstatic irqreturn_t irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ddb *dev = (struct ddb *) dev_id;\r\nu32 s = ddbreadl(INTERRUPT_STATUS);\r\nif (!s)\r\nreturn IRQ_NONE;\r\ndo {\r\nddbwritel(s, INTERRUPT_ACK);\r\nif (s & 0x00000001)\r\nirq_handle_i2c(dev, 0);\r\nif (s & 0x00000002)\r\nirq_handle_i2c(dev, 1);\r\nif (s & 0x00000004)\r\nirq_handle_i2c(dev, 2);\r\nif (s & 0x00000008)\r\nirq_handle_i2c(dev, 3);\r\nif (s & 0x00000100)\r\ntasklet_schedule(&dev->input[0].tasklet);\r\nif (s & 0x00000200)\r\ntasklet_schedule(&dev->input[1].tasklet);\r\nif (s & 0x00000400)\r\ntasklet_schedule(&dev->input[2].tasklet);\r\nif (s & 0x00000800)\r\ntasklet_schedule(&dev->input[3].tasklet);\r\nif (s & 0x00001000)\r\ntasklet_schedule(&dev->input[4].tasklet);\r\nif (s & 0x00002000)\r\ntasklet_schedule(&dev->input[5].tasklet);\r\nif (s & 0x00004000)\r\ntasklet_schedule(&dev->input[6].tasklet);\r\nif (s & 0x00008000)\r\ntasklet_schedule(&dev->input[7].tasklet);\r\nif (s & 0x00010000)\r\ntasklet_schedule(&dev->output[0].tasklet);\r\nif (s & 0x00020000)\r\ntasklet_schedule(&dev->output[1].tasklet);\r\nif (s & 0x00040000)\r\ntasklet_schedule(&dev->output[2].tasklet);\r\nif (s & 0x00080000)\r\ntasklet_schedule(&dev->output[3].tasklet);\r\n} while ((s = ddbreadl(INTERRUPT_STATUS)));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int flashio(struct ddb *dev, u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)\r\n{\r\nu32 data, shift;\r\nif (wlen > 4)\r\nddbwritel(1, SPI_CONTROL);\r\nwhile (wlen > 4) {\r\ndata = swab32(*(u32 *)wbuf);\r\nwbuf += 4;\r\nwlen -= 4;\r\nddbwritel(data, SPI_DATA);\r\nwhile (ddbreadl(SPI_CONTROL) & 0x0004)\r\n;\r\n}\r\nif (rlen)\r\nddbwritel(0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);\r\nelse\r\nddbwritel(0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);\r\ndata = 0;\r\nshift = ((4 - wlen) * 8);\r\nwhile (wlen) {\r\ndata <<= 8;\r\ndata |= *wbuf;\r\nwlen--;\r\nwbuf++;\r\n}\r\nif (shift)\r\ndata <<= shift;\r\nddbwritel(data, SPI_DATA);\r\nwhile (ddbreadl(SPI_CONTROL) & 0x0004)\r\n;\r\nif (!rlen) {\r\nddbwritel(0, SPI_CONTROL);\r\nreturn 0;\r\n}\r\nif (rlen > 4)\r\nddbwritel(1, SPI_CONTROL);\r\nwhile (rlen > 4) {\r\nddbwritel(0xffffffff, SPI_DATA);\r\nwhile (ddbreadl(SPI_CONTROL) & 0x0004)\r\n;\r\ndata = ddbreadl(SPI_DATA);\r\n*(u32 *) rbuf = swab32(data);\r\nrbuf += 4;\r\nrlen -= 4;\r\n}\r\nddbwritel(0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);\r\nddbwritel(0xffffffff, SPI_DATA);\r\nwhile (ddbreadl(SPI_CONTROL) & 0x0004)\r\n;\r\ndata = ddbreadl(SPI_DATA);\r\nddbwritel(0, SPI_CONTROL);\r\nif (rlen < 4)\r\ndata <<= ((4 - rlen) * 8);\r\nwhile (rlen > 0) {\r\n*rbuf = ((data >> 24) & 0xff);\r\ndata <<= 8;\r\nrbuf++;\r\nrlen--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ddb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ddb *dev = ddbs[iminor(inode)];\r\nfile->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic long ddb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ddb *dev = file->private_data;\r\n__user void *parg = (__user void *)arg;\r\nint res;\r\nswitch (cmd) {\r\ncase IOCTL_DDB_FLASHIO:\r\n{\r\nstruct ddb_flashio fio;\r\nu8 *rbuf, *wbuf;\r\nif (copy_from_user(&fio, parg, sizeof(fio)))\r\nreturn -EFAULT;\r\nif (fio.write_len > 1028 || fio.read_len > 1028)\r\nreturn -EINVAL;\r\nif (fio.write_len + fio.read_len > 1028)\r\nreturn -EINVAL;\r\nwbuf = &dev->iobuf[0];\r\nrbuf = wbuf + fio.write_len;\r\nif (copy_from_user(wbuf, fio.write_buf, fio.write_len))\r\nreturn -EFAULT;\r\nres = flashio(dev, wbuf, fio.write_len, rbuf, fio.read_len);\r\nif (res)\r\nreturn res;\r\nif (copy_to_user(fio.read_buf, rbuf, fio.read_len))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *ddb_devnode(struct device *device, umode_t *mode)\r\n{\r\nstruct ddb *dev = dev_get_drvdata(device);\r\nreturn kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);\r\n}\r\nstatic int ddb_class_create(void)\r\n{\r\nddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);\r\nif (ddb_major < 0)\r\nreturn ddb_major;\r\nddb_class = class_create(THIS_MODULE, DDB_NAME);\r\nif (IS_ERR(ddb_class)) {\r\nunregister_chrdev(ddb_major, DDB_NAME);\r\nreturn PTR_ERR(ddb_class);\r\n}\r\nddb_class->devnode = ddb_devnode;\r\nreturn 0;\r\n}\r\nstatic void ddb_class_destroy(void)\r\n{\r\nclass_destroy(ddb_class);\r\nunregister_chrdev(ddb_major, DDB_NAME);\r\n}\r\nstatic int ddb_device_create(struct ddb *dev)\r\n{\r\ndev->nr = ddb_num++;\r\ndev->ddb_dev = device_create(ddb_class, NULL,\r\nMKDEV(ddb_major, dev->nr),\r\ndev, "ddbridge%d", dev->nr);\r\nddbs[dev->nr] = dev;\r\nif (IS_ERR(dev->ddb_dev))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void ddb_device_destroy(struct ddb *dev)\r\n{\r\nddb_num--;\r\nif (IS_ERR(dev->ddb_dev))\r\nreturn;\r\ndevice_destroy(ddb_class, MKDEV(ddb_major, 0));\r\n}\r\nstatic void ddb_unmap(struct ddb *dev)\r\n{\r\nif (dev->regs)\r\niounmap(dev->regs);\r\nvfree(dev);\r\n}\r\nstatic void ddb_remove(struct pci_dev *pdev)\r\n{\r\nstruct ddb *dev = pci_get_drvdata(pdev);\r\nddb_ports_detach(dev);\r\nddb_i2c_release(dev);\r\nddbwritel(0, INTERRUPT_ENABLE);\r\nfree_irq(dev->pdev->irq, dev);\r\n#ifdef CONFIG_PCI_MSI\r\nif (dev->msi)\r\npci_disable_msi(dev->pdev);\r\n#endif\r\nddb_ports_release(dev);\r\nddb_buffers_free(dev);\r\nddb_device_destroy(dev);\r\nddb_unmap(dev);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\n}\r\nstatic int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct ddb *dev;\r\nint stat = 0;\r\nint irq_flag = IRQF_SHARED;\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -ENODEV;\r\ndev = vmalloc(sizeof(struct ddb));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nmemset(dev, 0, sizeof(struct ddb));\r\ndev->pdev = pdev;\r\npci_set_drvdata(pdev, dev);\r\ndev->info = (struct ddb_info *) id->driver_data;\r\nprintk(KERN_INFO "DDBridge driver detected: %s\n", dev->info->name);\r\ndev->regs = ioremap(pci_resource_start(dev->pdev, 0),\r\npci_resource_len(dev->pdev, 0));\r\nif (!dev->regs) {\r\nstat = -ENOMEM;\r\ngoto fail;\r\n}\r\nprintk(KERN_INFO "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));\r\n#ifdef CONFIG_PCI_MSI\r\nif (pci_msi_enabled())\r\nstat = pci_enable_msi(dev->pdev);\r\nif (stat) {\r\nprintk(KERN_INFO ": MSI not available.\n");\r\n} else {\r\nirq_flag = 0;\r\ndev->msi = 1;\r\n}\r\n#endif\r\nstat = request_irq(dev->pdev->irq, irq_handler,\r\nirq_flag, "DDBridge", (void *) dev);\r\nif (stat < 0)\r\ngoto fail1;\r\nddbwritel(0, DMA_BASE_WRITE);\r\nddbwritel(0, DMA_BASE_READ);\r\nddbwritel(0xffffffff, INTERRUPT_ACK);\r\nddbwritel(0xfff0f, INTERRUPT_ENABLE);\r\nddbwritel(0, MSI1_ENABLE);\r\nif (ddb_i2c_init(dev) < 0)\r\ngoto fail1;\r\nddb_ports_init(dev);\r\nif (ddb_buffers_alloc(dev) < 0) {\r\nprintk(KERN_INFO ": Could not allocate buffer memory\n");\r\ngoto fail2;\r\n}\r\nif (ddb_ports_attach(dev) < 0)\r\ngoto fail3;\r\nddb_device_create(dev);\r\nreturn 0;\r\nfail3:\r\nddb_ports_detach(dev);\r\nprintk(KERN_ERR "fail3\n");\r\nddb_ports_release(dev);\r\nfail2:\r\nprintk(KERN_ERR "fail2\n");\r\nddb_buffers_free(dev);\r\nfail1:\r\nprintk(KERN_ERR "fail1\n");\r\nif (dev->msi)\r\npci_disable_msi(dev->pdev);\r\nif (stat == 0)\r\nfree_irq(dev->pdev->irq, dev);\r\nfail:\r\nprintk(KERN_ERR "fail\n");\r\nddb_unmap(dev);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\nreturn -1;\r\n}\r\nstatic __init int module_init_ddbridge(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Digital Devices PCIE bridge driver, "\r\n"Copyright (C) 2010-11 Digital Devices GmbH\n");\r\nret = ddb_class_create();\r\nif (ret < 0)\r\nreturn ret;\r\nret = pci_register_driver(&ddb_pci_driver);\r\nif (ret < 0)\r\nddb_class_destroy();\r\nreturn ret;\r\n}\r\nstatic __exit void module_exit_ddbridge(void)\r\n{\r\npci_unregister_driver(&ddb_pci_driver);\r\nddb_class_destroy();\r\n}
