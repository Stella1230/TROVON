static int scif_fdopen(struct inode *inode, struct file *f)\r\n{\r\nstruct scif_endpt *priv = scif_open();\r\nif (!priv)\r\nreturn -ENOMEM;\r\nf->private_data = priv;\r\nreturn 0;\r\n}\r\nstatic int scif_fdclose(struct inode *inode, struct file *f)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nreturn scif_close(priv);\r\n}\r\nstatic int scif_fdflush(struct file *f, fl_owner_t id)\r\n{\r\nstruct scif_endpt *ep = f->private_data;\r\nspin_lock(&ep->lock);\r\nif (ep->files == id)\r\n__scif_flush(ep);\r\nspin_unlock(&ep->lock);\r\nreturn 0;\r\n}\r\nstatic __always_inline void scif_err_debug(int err, const char *str)\r\n{\r\nif (err < 0 && err != -ENOTCONN)\r\ndev_dbg(scif_info.mdev.this_device, "%s err %d\n", str, err);\r\n}\r\nstatic long scif_fdioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint err = 0;\r\nstruct scifioctl_msg request;\r\nbool non_block = false;\r\nnon_block = !!(f->f_flags & O_NONBLOCK);\r\nswitch (cmd) {\r\ncase SCIF_BIND:\r\n{\r\nint pn;\r\nif (copy_from_user(&pn, argp, sizeof(pn)))\r\nreturn -EFAULT;\r\npn = scif_bind(priv, pn);\r\nif (pn < 0)\r\nreturn pn;\r\nif (copy_to_user(argp, &pn, sizeof(pn)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SCIF_LISTEN:\r\nreturn scif_listen(priv, arg);\r\ncase SCIF_CONNECT:\r\n{\r\nstruct scifioctl_connect req;\r\nstruct scif_endpt *ep = (struct scif_endpt *)priv;\r\nif (copy_from_user(&req, argp, sizeof(req)))\r\nreturn -EFAULT;\r\nerr = __scif_connect(priv, &req.peer, non_block);\r\nif (err < 0)\r\nreturn err;\r\nreq.self.node = ep->port.node;\r\nreq.self.port = ep->port.port;\r\nif (copy_to_user(argp, &req, sizeof(req)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SCIF_ACCEPTREQ:\r\n{\r\nstruct scifioctl_accept request;\r\nscif_epd_t *ep = (scif_epd_t *)&request.endpt;\r\nif (copy_from_user(&request, argp, sizeof(request)))\r\nreturn -EFAULT;\r\nerr = scif_accept(priv, &request.peer, ep, request.flags);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(argp, &request, sizeof(request))) {\r\nscif_close(*ep);\r\nreturn -EFAULT;\r\n}\r\nspin_lock(&scif_info.eplock);\r\nlist_add_tail(&((*ep)->miacceptlist), &scif_info.uaccept);\r\nlist_add_tail(&((*ep)->liacceptlist), &priv->li_accept);\r\n(*ep)->listenep = priv;\r\npriv->acceptcnt++;\r\nspin_unlock(&scif_info.eplock);\r\nreturn 0;\r\n}\r\ncase SCIF_ACCEPTREG:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scif_endpt *newep;\r\nstruct scif_endpt *lisep;\r\nstruct scif_endpt *fep = NULL;\r\nstruct scif_endpt *tmpep;\r\nstruct list_head *pos, *tmpq;\r\nif (copy_from_user(&newep, argp, sizeof(void *)))\r\nreturn -EFAULT;\r\nspin_lock(&scif_info.eplock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.uaccept) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, miacceptlist);\r\nif (tmpep == newep) {\r\nlist_del(pos);\r\nfep = tmpep;\r\nbreak;\r\n}\r\n}\r\nif (!fep) {\r\nspin_unlock(&scif_info.eplock);\r\nreturn -ENOENT;\r\n}\r\nlisep = newep->listenep;\r\nlist_for_each_safe(pos, tmpq, &lisep->li_accept) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, liacceptlist);\r\nif (tmpep == newep) {\r\nlist_del(pos);\r\nlisep->acceptcnt--;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&scif_info.eplock);\r\nscif_teardown_ep(priv);\r\nscif_add_epd_to_zombie_list(priv, !SCIF_EPLOCK_HELD);\r\nf->private_data = newep;\r\nreturn 0;\r\n}\r\ncase SCIF_SEND:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nif (copy_from_user(&request, argp,\r\nsizeof(struct scifioctl_msg))) {\r\nerr = -EFAULT;\r\ngoto send_err;\r\n}\r\nerr = scif_user_send(priv, (void __user *)request.msg,\r\nrequest.len, request.flags);\r\nif (err < 0)\r\ngoto send_err;\r\nif (copy_to_user(&\r\n((struct scifioctl_msg __user *)argp)->out_len,\r\n&err, sizeof(err))) {\r\nerr = -EFAULT;\r\ngoto send_err;\r\n}\r\nerr = 0;\r\nsend_err:\r\nscif_err_debug(err, "scif_send");\r\nreturn err;\r\n}\r\ncase SCIF_RECV:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nif (copy_from_user(&request, argp,\r\nsizeof(struct scifioctl_msg))) {\r\nerr = -EFAULT;\r\ngoto recv_err;\r\n}\r\nerr = scif_user_recv(priv, (void __user *)request.msg,\r\nrequest.len, request.flags);\r\nif (err < 0)\r\ngoto recv_err;\r\nif (copy_to_user(&\r\n((struct scifioctl_msg __user *)argp)->out_len,\r\n&err, sizeof(err))) {\r\nerr = -EFAULT;\r\ngoto recv_err;\r\n}\r\nerr = 0;\r\nrecv_err:\r\nscif_err_debug(err, "scif_recv");\r\nreturn err;\r\n}\r\ncase SCIF_GET_NODEIDS:\r\n{\r\nstruct scifioctl_node_ids node_ids;\r\nint entries;\r\nu16 *nodes;\r\nvoid __user *unodes, *uself;\r\nu16 self;\r\nif (copy_from_user(&node_ids, argp, sizeof(node_ids))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err2;\r\n}\r\nentries = min_t(int, scif_info.maxid, node_ids.len);\r\nnodes = kmalloc_array(entries, sizeof(u16), GFP_KERNEL);\r\nif (entries && !nodes) {\r\nerr = -ENOMEM;\r\ngoto getnodes_err2;\r\n}\r\nnode_ids.len = scif_get_node_ids(nodes, entries, &self);\r\nunodes = (void __user *)node_ids.nodes;\r\nif (copy_to_user(unodes, nodes, sizeof(u16) * entries)) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\nuself = (void __user *)node_ids.self;\r\nif (copy_to_user(uself, &self, sizeof(u16))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\nif (copy_to_user(argp, &node_ids, sizeof(node_ids))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\ngetnodes_err1:\r\nkfree(nodes);\r\ngetnodes_err2:\r\nreturn err;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}
