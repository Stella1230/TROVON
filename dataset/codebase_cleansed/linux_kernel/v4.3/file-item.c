int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nu64 objectid, u64 pos,\r\nu64 disk_offset, u64 disk_num_bytes,\r\nu64 num_bytes, u64 offset, u64 ram_bytes,\r\nu8 compression, u8 encryption, u16 other_encoding)\r\n{\r\nint ret = 0;\r\nstruct btrfs_file_extent_item *item;\r\nstruct btrfs_key file_key;\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *leaf;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nfile_key.objectid = objectid;\r\nfile_key.offset = pos;\r\nfile_key.type = BTRFS_EXTENT_DATA_KEY;\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &file_key,\r\nsizeof(*item));\r\nif (ret < 0)\r\ngoto out;\r\nBUG_ON(ret);\r\nleaf = path->nodes[0];\r\nitem = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_file_extent_item);\r\nbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\r\nbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\r\nbtrfs_set_file_extent_offset(leaf, item, offset);\r\nbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\r\nbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\r\nbtrfs_set_file_extent_generation(leaf, item, trans->transid);\r\nbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\r\nbtrfs_set_file_extent_compression(leaf, item, compression);\r\nbtrfs_set_file_extent_encryption(leaf, item, encryption);\r\nbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic struct btrfs_csum_item *\r\nbtrfs_lookup_csum(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nu64 bytenr, int cow)\r\n{\r\nint ret;\r\nstruct btrfs_key file_key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_csum_item *item;\r\nstruct extent_buffer *leaf;\r\nu64 csum_offset = 0;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nint csums_in_item;\r\nfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nfile_key.offset = bytenr;\r\nfile_key.type = BTRFS_EXTENT_CSUM_KEY;\r\nret = btrfs_search_slot(trans, root, &file_key, path, 0, cow);\r\nif (ret < 0)\r\ngoto fail;\r\nleaf = path->nodes[0];\r\nif (ret > 0) {\r\nret = 1;\r\nif (path->slots[0] == 0)\r\ngoto fail;\r\npath->slots[0]--;\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\r\nif (found_key.type != BTRFS_EXTENT_CSUM_KEY)\r\ngoto fail;\r\ncsum_offset = (bytenr - found_key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\ncsums_in_item = btrfs_item_size_nr(leaf, path->slots[0]);\r\ncsums_in_item /= csum_size;\r\nif (csum_offset == csums_in_item) {\r\nret = -EFBIG;\r\ngoto fail;\r\n} else if (csum_offset > csums_in_item) {\r\ngoto fail;\r\n}\r\n}\r\nitem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\r\nitem = (struct btrfs_csum_item *)((unsigned char *)item +\r\ncsum_offset * csum_size);\r\nreturn item;\r\nfail:\r\nif (ret > 0)\r\nret = -ENOENT;\r\nreturn ERR_PTR(ret);\r\n}\r\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 objectid,\r\nu64 offset, int mod)\r\n{\r\nint ret;\r\nstruct btrfs_key file_key;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nfile_key.objectid = objectid;\r\nfile_key.offset = offset;\r\nfile_key.type = BTRFS_EXTENT_DATA_KEY;\r\nret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\r\nreturn ret;\r\n}\r\nstatic void btrfs_io_bio_endio_readpage(struct btrfs_io_bio *bio, int err)\r\n{\r\nkfree(bio->csum_allocated);\r\n}\r\nstatic int __btrfs_lookup_bio_sums(struct btrfs_root *root,\r\nstruct inode *inode, struct bio *bio,\r\nu64 logical_offset, u32 *dst, int dio)\r\n{\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\r\nstruct btrfs_csum_item *item = NULL;\r\nstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\r\nstruct btrfs_path *path;\r\nu8 *csum;\r\nu64 offset = 0;\r\nu64 item_start_offset = 0;\r\nu64 item_last_offset = 0;\r\nu64 disk_bytenr;\r\nu32 diff;\r\nint nblocks;\r\nint bio_index = 0;\r\nint count;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\r\nif (!dst) {\r\nif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\r\nbtrfs_bio->csum_allocated = kmalloc_array(nblocks,\r\ncsum_size, GFP_NOFS);\r\nif (!btrfs_bio->csum_allocated) {\r\nbtrfs_free_path(path);\r\nreturn -ENOMEM;\r\n}\r\nbtrfs_bio->csum = btrfs_bio->csum_allocated;\r\nbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\r\n} else {\r\nbtrfs_bio->csum = btrfs_bio->csum_inline;\r\n}\r\ncsum = btrfs_bio->csum;\r\n} else {\r\ncsum = (u8 *)dst;\r\n}\r\nif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\r\npath->reada = 2;\r\nWARN_ON(bio->bi_vcnt <= 0);\r\nif (btrfs_is_free_space_inode(inode)) {\r\npath->search_commit_root = 1;\r\npath->skip_locking = 1;\r\n}\r\ndisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\r\nif (dio)\r\noffset = logical_offset;\r\nwhile (bio_index < bio->bi_vcnt) {\r\nif (!dio)\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\ncount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\r\n(u32 *)csum, nblocks);\r\nif (count)\r\ngoto found;\r\nif (!item || disk_bytenr < item_start_offset ||\r\ndisk_bytenr >= item_last_offset) {\r\nstruct btrfs_key found_key;\r\nu32 item_size;\r\nif (item)\r\nbtrfs_release_path(path);\r\nitem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\r\npath, disk_bytenr, 0);\r\nif (IS_ERR(item)) {\r\ncount = 1;\r\nmemset(csum, 0, csum_size);\r\nif (BTRFS_I(inode)->root->root_key.objectid ==\r\nBTRFS_DATA_RELOC_TREE_OBJECTID) {\r\nset_extent_bits(io_tree, offset,\r\noffset + bvec->bv_len - 1,\r\nEXTENT_NODATASUM, GFP_NOFS);\r\n} else {\r\nbtrfs_info(BTRFS_I(inode)->root->fs_info,\r\n"no csum found for inode %llu start %llu",\r\nbtrfs_ino(inode), offset);\r\n}\r\nitem = NULL;\r\nbtrfs_release_path(path);\r\ngoto found;\r\n}\r\nbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\r\npath->slots[0]);\r\nitem_start_offset = found_key.offset;\r\nitem_size = btrfs_item_size_nr(path->nodes[0],\r\npath->slots[0]);\r\nitem_last_offset = item_start_offset +\r\n(item_size / csum_size) *\r\nroot->sectorsize;\r\nitem = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_csum_item);\r\n}\r\ndiff = disk_bytenr - item_start_offset;\r\ndiff = diff / root->sectorsize;\r\ndiff = diff * csum_size;\r\ncount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\r\ninode->i_sb->s_blocksize_bits);\r\nread_extent_buffer(path->nodes[0], csum,\r\n((unsigned long)item) + diff,\r\ncsum_size * count);\r\nfound:\r\ncsum += count * csum_size;\r\nnblocks -= count;\r\nbio_index += count;\r\nwhile (count--) {\r\ndisk_bytenr += bvec->bv_len;\r\noffset += bvec->bv_len;\r\nbvec++;\r\n}\r\n}\r\nbtrfs_free_path(path);\r\nreturn 0;\r\n}\r\nint btrfs_lookup_bio_sums(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u32 *dst)\r\n{\r\nreturn __btrfs_lookup_bio_sums(root, inode, bio, 0, dst, 0);\r\n}\r\nint btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u64 offset)\r\n{\r\nreturn __btrfs_lookup_bio_sums(root, inode, bio, offset, NULL, 1);\r\n}\r\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\r\nstruct list_head *list, int search_commit)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_ordered_sum *sums;\r\nstruct btrfs_csum_item *item;\r\nLIST_HEAD(tmplist);\r\nunsigned long offset;\r\nint ret;\r\nsize_t size;\r\nu64 csum_end;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nASSERT(IS_ALIGNED(start, root->sectorsize) &&\r\nIS_ALIGNED(end + 1, root->sectorsize));\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nif (search_commit) {\r\npath->skip_locking = 1;\r\npath->reada = 2;\r\npath->search_commit_root = 1;\r\n}\r\nkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nkey.offset = start;\r\nkey.type = BTRFS_EXTENT_CSUM_KEY;\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\ngoto fail;\r\nif (ret > 0 && path->slots[0] > 0) {\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\r\nif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\r\nkey.type == BTRFS_EXTENT_CSUM_KEY) {\r\noffset = (start - key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\nif (offset * csum_size <\r\nbtrfs_item_size_nr(leaf, path->slots[0] - 1))\r\npath->slots[0]--;\r\n}\r\n}\r\nwhile (start <= end) {\r\nleaf = path->nodes[0];\r\nif (path->slots[0] >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret < 0)\r\ngoto fail;\r\nif (ret > 0)\r\nbreak;\r\nleaf = path->nodes[0];\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nkey.type != BTRFS_EXTENT_CSUM_KEY ||\r\nkey.offset > end)\r\nbreak;\r\nif (key.offset > start)\r\nstart = key.offset;\r\nsize = btrfs_item_size_nr(leaf, path->slots[0]);\r\ncsum_end = key.offset + (size / csum_size) * root->sectorsize;\r\nif (csum_end <= start) {\r\npath->slots[0]++;\r\ncontinue;\r\n}\r\ncsum_end = min(csum_end, end + 1);\r\nitem = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_csum_item);\r\nwhile (start < csum_end) {\r\nsize = min_t(size_t, csum_end - start,\r\nMAX_ORDERED_SUM_BYTES(root));\r\nsums = kzalloc(btrfs_ordered_sum_size(root, size),\r\nGFP_NOFS);\r\nif (!sums) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsums->bytenr = start;\r\nsums->len = (int)size;\r\noffset = (start - key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\noffset *= csum_size;\r\nsize >>= root->fs_info->sb->s_blocksize_bits;\r\nread_extent_buffer(path->nodes[0],\r\nsums->sums,\r\n((unsigned long)item) + offset,\r\ncsum_size * size);\r\nstart += root->sectorsize * size;\r\nlist_add_tail(&sums->list, &tmplist);\r\n}\r\npath->slots[0]++;\r\n}\r\nret = 0;\r\nfail:\r\nwhile (ret < 0 && !list_empty(&tmplist)) {\r\nsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\r\nlist_del(&sums->list);\r\nkfree(sums);\r\n}\r\nlist_splice_tail(&tmplist, list);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u64 file_start, int contig)\r\n{\r\nstruct btrfs_ordered_sum *sums;\r\nstruct btrfs_ordered_extent *ordered;\r\nchar *data;\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint bio_index = 0;\r\nint index;\r\nunsigned long total_bytes = 0;\r\nunsigned long this_sum_bytes = 0;\r\nu64 offset;\r\nWARN_ON(bio->bi_vcnt <= 0);\r\nsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_iter.bi_size),\r\nGFP_NOFS);\r\nif (!sums)\r\nreturn -ENOMEM;\r\nsums->len = bio->bi_iter.bi_size;\r\nINIT_LIST_HEAD(&sums->list);\r\nif (contig)\r\noffset = file_start;\r\nelse\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\nordered = btrfs_lookup_ordered_extent(inode, offset);\r\nBUG_ON(!ordered);\r\nsums->bytenr = (u64)bio->bi_iter.bi_sector << 9;\r\nindex = 0;\r\nwhile (bio_index < bio->bi_vcnt) {\r\nif (!contig)\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\nif (offset >= ordered->file_offset + ordered->len ||\r\noffset < ordered->file_offset) {\r\nunsigned long bytes_left;\r\nsums->len = this_sum_bytes;\r\nthis_sum_bytes = 0;\r\nbtrfs_add_ordered_sum(inode, ordered, sums);\r\nbtrfs_put_ordered_extent(ordered);\r\nbytes_left = bio->bi_iter.bi_size - total_bytes;\r\nsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\r\nGFP_NOFS);\r\nBUG_ON(!sums);\r\nsums->len = bytes_left;\r\nordered = btrfs_lookup_ordered_extent(inode, offset);\r\nBUG_ON(!ordered);\r\nsums->bytenr = ((u64)bio->bi_iter.bi_sector << 9) +\r\ntotal_bytes;\r\nindex = 0;\r\n}\r\ndata = kmap_atomic(bvec->bv_page);\r\nsums->sums[index] = ~(u32)0;\r\nsums->sums[index] = btrfs_csum_data(data + bvec->bv_offset,\r\nsums->sums[index],\r\nbvec->bv_len);\r\nkunmap_atomic(data);\r\nbtrfs_csum_final(sums->sums[index],\r\n(char *)(sums->sums + index));\r\nbio_index++;\r\nindex++;\r\ntotal_bytes += bvec->bv_len;\r\nthis_sum_bytes += bvec->bv_len;\r\noffset += bvec->bv_len;\r\nbvec++;\r\n}\r\nthis_sum_bytes = 0;\r\nbtrfs_add_ordered_sum(inode, ordered, sums);\r\nbtrfs_put_ordered_extent(ordered);\r\nreturn 0;\r\n}\r\nstatic noinline void truncate_one_csum(struct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nstruct btrfs_key *key,\r\nu64 bytenr, u64 len)\r\n{\r\nstruct extent_buffer *leaf;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nu64 csum_end;\r\nu64 end_byte = bytenr + len;\r\nu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\r\nleaf = path->nodes[0];\r\ncsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\r\ncsum_end <<= root->fs_info->sb->s_blocksize_bits;\r\ncsum_end += key->offset;\r\nif (key->offset < bytenr && csum_end <= end_byte) {\r\nu32 new_size = (bytenr - key->offset) >> blocksize_bits;\r\nnew_size *= csum_size;\r\nbtrfs_truncate_item(root, path, new_size, 1);\r\n} else if (key->offset >= bytenr && csum_end > end_byte &&\r\nend_byte > key->offset) {\r\nu32 new_size = (csum_end - end_byte) >> blocksize_bits;\r\nnew_size *= csum_size;\r\nbtrfs_truncate_item(root, path, new_size, 0);\r\nkey->offset = end_byte;\r\nbtrfs_set_item_key_safe(root->fs_info, path, key);\r\n} else {\r\nBUG();\r\n}\r\n}\r\nint btrfs_del_csums(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root, u64 bytenr, u64 len)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nu64 end_byte = bytenr + len;\r\nu64 csum_end;\r\nstruct extent_buffer *leaf;\r\nint ret;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nint blocksize_bits = root->fs_info->sb->s_blocksize_bits;\r\nroot = root->fs_info->csum_root;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nwhile (1) {\r\nkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nkey.offset = end_byte - 1;\r\nkey.type = BTRFS_EXTENT_CSUM_KEY;\r\npath->leave_spinning = 1;\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret > 0) {\r\nif (path->slots[0] == 0)\r\nbreak;\r\npath->slots[0]--;\r\n} else if (ret < 0) {\r\nbreak;\r\n}\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nkey.type != BTRFS_EXTENT_CSUM_KEY) {\r\nbreak;\r\n}\r\nif (key.offset >= end_byte)\r\nbreak;\r\ncsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\r\ncsum_end <<= blocksize_bits;\r\ncsum_end += key.offset;\r\nif (csum_end <= bytenr)\r\nbreak;\r\nif (key.offset >= bytenr && csum_end <= end_byte) {\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret)\r\ngoto out;\r\nif (key.offset == bytenr)\r\nbreak;\r\n} else if (key.offset < bytenr && csum_end > end_byte) {\r\nunsigned long offset;\r\nunsigned long shift_len;\r\nunsigned long item_offset;\r\noffset = (bytenr - key.offset) >> blocksize_bits;\r\noffset *= csum_size;\r\nshift_len = (len >> blocksize_bits) * csum_size;\r\nitem_offset = btrfs_item_ptr_offset(leaf,\r\npath->slots[0]);\r\nmemset_extent_buffer(leaf, 0, item_offset + offset,\r\nshift_len);\r\nkey.offset = bytenr;\r\nret = btrfs_split_item(trans, root, path, &key, offset);\r\nif (ret && ret != -EAGAIN) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nkey.offset = end_byte - 1;\r\n} else {\r\ntruncate_one_csum(root, path, &key, bytenr, len);\r\nif (key.offset < bytenr)\r\nbreak;\r\n}\r\nbtrfs_release_path(path);\r\n}\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_ordered_sum *sums)\r\n{\r\nstruct btrfs_key file_key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_path *path;\r\nstruct btrfs_csum_item *item;\r\nstruct btrfs_csum_item *item_end;\r\nstruct extent_buffer *leaf = NULL;\r\nu64 next_offset;\r\nu64 total_bytes = 0;\r\nu64 csum_offset;\r\nu64 bytenr;\r\nu32 nritems;\r\nu32 ins_size;\r\nint index = 0;\r\nint found_next;\r\nint ret;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nagain:\r\nnext_offset = (u64)-1;\r\nfound_next = 0;\r\nbytenr = sums->bytenr + total_bytes;\r\nfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nfile_key.offset = bytenr;\r\nfile_key.type = BTRFS_EXTENT_CSUM_KEY;\r\nitem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\r\nif (!IS_ERR(item)) {\r\nret = 0;\r\nleaf = path->nodes[0];\r\nitem_end = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_csum_item);\r\nitem_end = (struct btrfs_csum_item *)((char *)item_end +\r\nbtrfs_item_size_nr(leaf, path->slots[0]));\r\ngoto found;\r\n}\r\nret = PTR_ERR(item);\r\nif (ret != -EFBIG && ret != -ENOENT)\r\ngoto fail_unlock;\r\nif (ret == -EFBIG) {\r\nu32 item_size;\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif ((item_size / csum_size) >=\r\nMAX_CSUM_ITEMS(root, csum_size)) {\r\ngoto insert;\r\n}\r\n} else {\r\nint slot = path->slots[0] + 1;\r\nnritems = btrfs_header_nritems(path->nodes[0]);\r\nif (!nritems || (path->slots[0] >= nritems - 1)) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret == 1)\r\nfound_next = 1;\r\nif (ret != 0)\r\ngoto insert;\r\nslot = path->slots[0];\r\n}\r\nbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\r\nif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nfound_key.type != BTRFS_EXTENT_CSUM_KEY) {\r\nfound_next = 1;\r\ngoto insert;\r\n}\r\nnext_offset = found_key.offset;\r\nfound_next = 1;\r\ngoto insert;\r\n}\r\nbtrfs_release_path(path);\r\nret = btrfs_search_slot(trans, root, &file_key, path,\r\ncsum_size, 1);\r\nif (ret < 0)\r\ngoto fail_unlock;\r\nif (ret > 0) {\r\nif (path->slots[0] == 0)\r\ngoto insert;\r\npath->slots[0]--;\r\n}\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\r\ncsum_offset = (bytenr - found_key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\nif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\r\nfound_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\ncsum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\r\ngoto insert;\r\n}\r\nif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\r\ncsum_size) {\r\nint extend_nr;\r\nu64 tmp;\r\nu32 diff;\r\nu32 free_space;\r\nif (btrfs_leaf_free_space(root, leaf) <\r\nsizeof(struct btrfs_item) + csum_size * 2)\r\ngoto insert;\r\nfree_space = btrfs_leaf_free_space(root, leaf) -\r\nsizeof(struct btrfs_item) - csum_size;\r\ntmp = sums->len - total_bytes;\r\ntmp >>= root->fs_info->sb->s_blocksize_bits;\r\nWARN_ON(tmp < 1);\r\nextend_nr = max_t(int, 1, (int)tmp);\r\ndiff = (csum_offset + extend_nr) * csum_size;\r\ndiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\r\ndiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\r\ndiff = min(free_space, diff);\r\ndiff /= csum_size;\r\ndiff *= csum_size;\r\nbtrfs_extend_item(root, path, diff);\r\nret = 0;\r\ngoto csum;\r\n}\r\ninsert:\r\nbtrfs_release_path(path);\r\ncsum_offset = 0;\r\nif (found_next) {\r\nu64 tmp;\r\ntmp = sums->len - total_bytes;\r\ntmp >>= root->fs_info->sb->s_blocksize_bits;\r\ntmp = min(tmp, (next_offset - file_key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits);\r\ntmp = max((u64)1, tmp);\r\ntmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\r\nins_size = csum_size * tmp;\r\n} else {\r\nins_size = csum_size;\r\n}\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &file_key,\r\nins_size);\r\npath->leave_spinning = 0;\r\nif (ret < 0)\r\ngoto fail_unlock;\r\nif (WARN_ON(ret != 0))\r\ngoto fail_unlock;\r\nleaf = path->nodes[0];\r\ncsum:\r\nitem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\r\nitem_end = (struct btrfs_csum_item *)((unsigned char *)item +\r\nbtrfs_item_size_nr(leaf, path->slots[0]));\r\nitem = (struct btrfs_csum_item *)((unsigned char *)item +\r\ncsum_offset * csum_size);\r\nfound:\r\nins_size = (u32)(sums->len - total_bytes) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\nins_size *= csum_size;\r\nins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\r\nins_size);\r\nwrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\r\nins_size);\r\nins_size /= csum_size;\r\ntotal_bytes += ins_size * root->sectorsize;\r\nindex += ins_size;\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nif (total_bytes < sums->len) {\r\nbtrfs_release_path(path);\r\ncond_resched();\r\ngoto again;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\nfail_unlock:\r\ngoto out;\r\n}\r\nvoid btrfs_extent_item_to_extent_map(struct inode *inode,\r\nconst struct btrfs_path *path,\r\nstruct btrfs_file_extent_item *fi,\r\nconst bool new_inline,\r\nstruct extent_map *em)\r\n{\r\nstruct btrfs_root *root = BTRFS_I(inode)->root;\r\nstruct extent_buffer *leaf = path->nodes[0];\r\nconst int slot = path->slots[0];\r\nstruct btrfs_key key;\r\nu64 extent_start, extent_end;\r\nu64 bytenr;\r\nu8 type = btrfs_file_extent_type(leaf, fi);\r\nint compress_type = btrfs_file_extent_compression(leaf, fi);\r\nem->bdev = root->fs_info->fs_devices->latest_bdev;\r\nbtrfs_item_key_to_cpu(leaf, &key, slot);\r\nextent_start = key.offset;\r\nif (type == BTRFS_FILE_EXTENT_REG ||\r\ntype == BTRFS_FILE_EXTENT_PREALLOC) {\r\nextent_end = extent_start +\r\nbtrfs_file_extent_num_bytes(leaf, fi);\r\n} else if (type == BTRFS_FILE_EXTENT_INLINE) {\r\nsize_t size;\r\nsize = btrfs_file_extent_inline_len(leaf, slot, fi);\r\nextent_end = ALIGN(extent_start + size, root->sectorsize);\r\n}\r\nem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\r\nif (type == BTRFS_FILE_EXTENT_REG ||\r\ntype == BTRFS_FILE_EXTENT_PREALLOC) {\r\nem->start = extent_start;\r\nem->len = extent_end - extent_start;\r\nem->orig_start = extent_start -\r\nbtrfs_file_extent_offset(leaf, fi);\r\nem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\r\nbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\r\nif (bytenr == 0) {\r\nem->block_start = EXTENT_MAP_HOLE;\r\nreturn;\r\n}\r\nif (compress_type != BTRFS_COMPRESS_NONE) {\r\nset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\r\nem->compress_type = compress_type;\r\nem->block_start = bytenr;\r\nem->block_len = em->orig_block_len;\r\n} else {\r\nbytenr += btrfs_file_extent_offset(leaf, fi);\r\nem->block_start = bytenr;\r\nem->block_len = em->len;\r\nif (type == BTRFS_FILE_EXTENT_PREALLOC)\r\nset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\r\n}\r\n} else if (type == BTRFS_FILE_EXTENT_INLINE) {\r\nem->block_start = EXTENT_MAP_INLINE;\r\nem->start = extent_start;\r\nem->len = extent_end - extent_start;\r\nem->orig_start = EXTENT_MAP_HOLE;\r\nem->block_len = (u64)-1;\r\nif (!new_inline && compress_type != BTRFS_COMPRESS_NONE) {\r\nset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\r\nem->compress_type = compress_type;\r\n}\r\n} else {\r\nbtrfs_err(root->fs_info,\r\n"unknown file extent item type %d, inode %llu, offset %llu, root %llu",\r\ntype, btrfs_ino(inode), extent_start,\r\nroot->root_key.objectid);\r\n}\r\n}
