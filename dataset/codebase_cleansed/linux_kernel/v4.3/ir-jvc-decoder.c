static int ir_jvc_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct jvc_dec *data = &dev->raw->jvc;\r\nif (!(dev->enabled_protocols & RC_BIT_JVC))\r\nreturn 0;\r\nif (!is_timing_event(ev)) {\r\nif (ev.reset)\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nif (!geq_margin(ev.duration, JVC_UNIT, JVC_UNIT / 2))\r\ngoto out;\r\nIR_dprintk(2, "JVC decode started at state %d (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\nagain:\r\nswitch (data->state) {\r\ncase STATE_INACTIVE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, JVC_HEADER_PULSE, JVC_UNIT / 2))\r\nbreak;\r\ndata->count = 0;\r\ndata->first = true;\r\ndata->toggle = !data->toggle;\r\ndata->state = STATE_HEADER_SPACE;\r\nreturn 0;\r\ncase STATE_HEADER_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, JVC_HEADER_SPACE, JVC_UNIT / 2))\r\nbreak;\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\ncase STATE_BIT_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, JVC_BIT_PULSE, JVC_UNIT / 2))\r\nbreak;\r\ndata->state = STATE_BIT_SPACE;\r\nreturn 0;\r\ncase STATE_BIT_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\ndata->bits <<= 1;\r\nif (eq_margin(ev.duration, JVC_BIT_1_SPACE, JVC_UNIT / 2)) {\r\ndata->bits |= 1;\r\ndecrease_duration(&ev, JVC_BIT_1_SPACE);\r\n} else if (eq_margin(ev.duration, JVC_BIT_0_SPACE, JVC_UNIT / 2))\r\ndecrease_duration(&ev, JVC_BIT_0_SPACE);\r\nelse\r\nbreak;\r\ndata->count++;\r\nif (data->count == JVC_NBITS)\r\ndata->state = STATE_TRAILER_PULSE;\r\nelse\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\ncase STATE_TRAILER_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, JVC_TRAILER_PULSE, JVC_UNIT / 2))\r\nbreak;\r\ndata->state = STATE_TRAILER_SPACE;\r\nreturn 0;\r\ncase STATE_TRAILER_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!geq_margin(ev.duration, JVC_TRAILER_SPACE, JVC_UNIT / 2))\r\nbreak;\r\nif (data->first) {\r\nu32 scancode;\r\nscancode = (bitrev8((data->bits >> 8) & 0xff) << 8) |\r\n(bitrev8((data->bits >> 0) & 0xff) << 0);\r\nIR_dprintk(1, "JVC scancode 0x%04x\n", scancode);\r\nrc_keydown(dev, RC_TYPE_JVC, scancode, data->toggle);\r\ndata->first = false;\r\ndata->old_bits = data->bits;\r\n} else if (data->bits == data->old_bits) {\r\nIR_dprintk(1, "JVC repeat\n");\r\nrc_repeat(dev);\r\n} else {\r\nIR_dprintk(1, "JVC invalid repeat msg\n");\r\nbreak;\r\n}\r\ndata->count = 0;\r\ndata->state = STATE_CHECK_REPEAT;\r\nreturn 0;\r\ncase STATE_CHECK_REPEAT:\r\nif (!ev.pulse)\r\nbreak;\r\nif (eq_margin(ev.duration, JVC_HEADER_PULSE, JVC_UNIT / 2))\r\ndata->state = STATE_INACTIVE;\r\nelse\r\ndata->state = STATE_BIT_PULSE;\r\ngoto again;\r\n}\r\nout:\r\nIR_dprintk(1, "JVC decode failed at state %d (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init ir_jvc_decode_init(void)\r\n{\r\nir_raw_handler_register(&jvc_handler);\r\nprintk(KERN_INFO "IR JVC protocol handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_jvc_decode_exit(void)\r\n{\r\nir_raw_handler_unregister(&jvc_handler);\r\n}
