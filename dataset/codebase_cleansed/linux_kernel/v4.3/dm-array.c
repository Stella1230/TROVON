static void array_block_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t size_of_block)\r\n{\r\nstruct array_block *bh_le = dm_block_data(b);\r\nbh_le->blocknr = cpu_to_le64(dm_block_location(b));\r\nbh_le->csum = cpu_to_le32(dm_bm_checksum(&bh_le->max_entries,\r\nsize_of_block - sizeof(__le32),\r\nCSUM_XOR));\r\n}\r\nstatic int array_block_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t size_of_block)\r\n{\r\nstruct array_block *bh_le = dm_block_data(b);\r\n__le32 csum_disk;\r\nif (dm_block_location(b) != le64_to_cpu(bh_le->blocknr)) {\r\nDMERR_LIMIT("array_block_check failed: blocknr %llu != wanted %llu",\r\n(unsigned long long) le64_to_cpu(bh_le->blocknr),\r\n(unsigned long long) dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\ncsum_disk = cpu_to_le32(dm_bm_checksum(&bh_le->max_entries,\r\nsize_of_block - sizeof(__le32),\r\nCSUM_XOR));\r\nif (csum_disk != bh_le->csum) {\r\nDMERR_LIMIT("array_block_check failed: csum %u != wanted %u",\r\n(unsigned) le32_to_cpu(csum_disk),\r\n(unsigned) le32_to_cpu(bh_le->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *element_at(struct dm_array_info *info, struct array_block *ab,\r\nunsigned index)\r\n{\r\nunsigned char *entry = (unsigned char *) (ab + 1);\r\nentry += index * info->value_type.size;\r\nreturn entry;\r\n}\r\nstatic void on_entries(struct dm_array_info *info, struct array_block *ab,\r\nvoid (*fn)(void *, const void *))\r\n{\r\nunsigned i, nr_entries = le32_to_cpu(ab->nr_entries);\r\nfor (i = 0; i < nr_entries; i++)\r\nfn(info->value_type.context, element_at(info, ab, i));\r\n}\r\nstatic void inc_ablock_entries(struct dm_array_info *info, struct array_block *ab)\r\n{\r\nstruct dm_btree_value_type *vt = &info->value_type;\r\nif (vt->inc)\r\non_entries(info, ab, vt->inc);\r\n}\r\nstatic void dec_ablock_entries(struct dm_array_info *info, struct array_block *ab)\r\n{\r\nstruct dm_btree_value_type *vt = &info->value_type;\r\nif (vt->dec)\r\non_entries(info, ab, vt->dec);\r\n}\r\nstatic uint32_t calc_max_entries(size_t value_size, size_t size_of_block)\r\n{\r\nreturn (size_of_block - sizeof(struct array_block)) / value_size;\r\n}\r\nstatic int alloc_ablock(struct dm_array_info *info, size_t size_of_block,\r\nuint32_t max_entries,\r\nstruct dm_block **block, struct array_block **ab)\r\n{\r\nint r;\r\nr = dm_tm_new_block(info->btree_info.tm, &array_validator, block);\r\nif (r)\r\nreturn r;\r\n(*ab) = dm_block_data(*block);\r\n(*ab)->max_entries = cpu_to_le32(max_entries);\r\n(*ab)->nr_entries = cpu_to_le32(0);\r\n(*ab)->value_size = cpu_to_le32(info->value_type.size);\r\nreturn 0;\r\n}\r\nstatic void fill_ablock(struct dm_array_info *info, struct array_block *ab,\r\nconst void *value, unsigned new_nr)\r\n{\r\nunsigned i;\r\nuint32_t nr_entries;\r\nstruct dm_btree_value_type *vt = &info->value_type;\r\nBUG_ON(new_nr > le32_to_cpu(ab->max_entries));\r\nBUG_ON(new_nr < le32_to_cpu(ab->nr_entries));\r\nnr_entries = le32_to_cpu(ab->nr_entries);\r\nfor (i = nr_entries; i < new_nr; i++) {\r\nif (vt->inc)\r\nvt->inc(vt->context, value);\r\nmemcpy(element_at(info, ab, i), value, vt->size);\r\n}\r\nab->nr_entries = cpu_to_le32(new_nr);\r\n}\r\nstatic void trim_ablock(struct dm_array_info *info, struct array_block *ab,\r\nunsigned new_nr)\r\n{\r\nunsigned i;\r\nuint32_t nr_entries;\r\nstruct dm_btree_value_type *vt = &info->value_type;\r\nBUG_ON(new_nr > le32_to_cpu(ab->max_entries));\r\nBUG_ON(new_nr > le32_to_cpu(ab->nr_entries));\r\nnr_entries = le32_to_cpu(ab->nr_entries);\r\nfor (i = nr_entries; i > new_nr; i--)\r\nif (vt->dec)\r\nvt->dec(vt->context, element_at(info, ab, i - 1));\r\nab->nr_entries = cpu_to_le32(new_nr);\r\n}\r\nstatic int get_ablock(struct dm_array_info *info, dm_block_t b,\r\nstruct dm_block **block, struct array_block **ab)\r\n{\r\nint r;\r\nr = dm_tm_read_lock(info->btree_info.tm, b, &array_validator, block);\r\nif (r)\r\nreturn r;\r\n*ab = dm_block_data(*block);\r\nreturn 0;\r\n}\r\nstatic int unlock_ablock(struct dm_array_info *info, struct dm_block *block)\r\n{\r\nreturn dm_tm_unlock(info->btree_info.tm, block);\r\n}\r\nstatic int lookup_ablock(struct dm_array_info *info, dm_block_t root,\r\nunsigned index, struct dm_block **block,\r\nstruct array_block **ab)\r\n{\r\nint r;\r\nuint64_t key = index;\r\n__le64 block_le;\r\nr = dm_btree_lookup(&info->btree_info, root, &key, &block_le);\r\nif (r)\r\nreturn r;\r\nreturn get_ablock(info, le64_to_cpu(block_le), block, ab);\r\n}\r\nstatic int insert_ablock(struct dm_array_info *info, uint64_t index,\r\nstruct dm_block *block, dm_block_t *root)\r\n{\r\n__le64 block_le = cpu_to_le64(dm_block_location(block));\r\n__dm_bless_for_disk(block_le);\r\nreturn dm_btree_insert(&info->btree_info, *root, &index, &block_le, root);\r\n}\r\nstatic int shadow_ablock(struct dm_array_info *info, dm_block_t *root,\r\nunsigned index, struct dm_block **block,\r\nstruct array_block **ab)\r\n{\r\nint r, inc;\r\nuint64_t key = index;\r\ndm_block_t b;\r\n__le64 block_le;\r\nr = dm_btree_lookup(&info->btree_info, *root, &key, &block_le);\r\nif (r)\r\nreturn r;\r\nb = le64_to_cpu(block_le);\r\nr = dm_tm_shadow_block(info->btree_info.tm, b,\r\n&array_validator, block, &inc);\r\nif (r)\r\nreturn r;\r\n*ab = dm_block_data(*block);\r\nif (inc)\r\ninc_ablock_entries(info, *ab);\r\nif (dm_block_location(*block) != b) {\r\ndm_tm_inc(info->btree_info.tm, b);\r\nr = insert_ablock(info, index, *block, root);\r\n}\r\nreturn r;\r\n}\r\nstatic int insert_new_ablock(struct dm_array_info *info, size_t size_of_block,\r\nuint32_t max_entries,\r\nunsigned block_index, uint32_t nr,\r\nconst void *value, dm_block_t *root)\r\n{\r\nint r;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nr = alloc_ablock(info, size_of_block, max_entries, &block, &ab);\r\nif (r)\r\nreturn r;\r\nfill_ablock(info, ab, value, nr);\r\nr = insert_ablock(info, block_index, block, root);\r\nunlock_ablock(info, block);\r\nreturn r;\r\n}\r\nstatic int insert_full_ablocks(struct dm_array_info *info, size_t size_of_block,\r\nunsigned begin_block, unsigned end_block,\r\nunsigned max_entries, const void *value,\r\ndm_block_t *root)\r\n{\r\nint r = 0;\r\nfor (; !r && begin_block != end_block; begin_block++)\r\nr = insert_new_ablock(info, size_of_block, max_entries, begin_block, max_entries, value, root);\r\nreturn r;\r\n}\r\nstatic int drop_blocks(struct resize *resize, unsigned begin_index,\r\nunsigned end_index)\r\n{\r\nint r;\r\nwhile (begin_index != end_index) {\r\nuint64_t key = begin_index++;\r\nr = dm_btree_remove(&resize->info->btree_info, resize->root,\r\n&key, &resize->root);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned total_nr_blocks_needed(unsigned nr_full_blocks,\r\nunsigned nr_entries_in_last_block)\r\n{\r\nreturn nr_full_blocks + (nr_entries_in_last_block ? 1 : 0);\r\n}\r\nstatic int shrink(struct resize *resize)\r\n{\r\nint r;\r\nunsigned begin, end;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nif (resize->new_nr_full_blocks < resize->old_nr_full_blocks) {\r\nbegin = total_nr_blocks_needed(resize->new_nr_full_blocks,\r\nresize->new_nr_entries_in_last_block);\r\nend = total_nr_blocks_needed(resize->old_nr_full_blocks,\r\nresize->old_nr_entries_in_last_block);\r\nr = drop_blocks(resize, begin, end);\r\nif (r)\r\nreturn r;\r\n}\r\nif (resize->new_nr_entries_in_last_block) {\r\nr = shadow_ablock(resize->info, &resize->root,\r\nresize->new_nr_full_blocks, &block, &ab);\r\nif (r)\r\nreturn r;\r\ntrim_ablock(resize->info, ab, resize->new_nr_entries_in_last_block);\r\nunlock_ablock(resize->info, block);\r\n}\r\nreturn 0;\r\n}\r\nstatic int grow_extend_tail_block(struct resize *resize, uint32_t new_nr_entries)\r\n{\r\nint r;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nr = shadow_ablock(resize->info, &resize->root,\r\nresize->old_nr_full_blocks, &block, &ab);\r\nif (r)\r\nreturn r;\r\nfill_ablock(resize->info, ab, resize->value, new_nr_entries);\r\nunlock_ablock(resize->info, block);\r\nreturn r;\r\n}\r\nstatic int grow_add_tail_block(struct resize *resize)\r\n{\r\nreturn insert_new_ablock(resize->info, resize->size_of_block,\r\nresize->max_entries,\r\nresize->new_nr_full_blocks,\r\nresize->new_nr_entries_in_last_block,\r\nresize->value, &resize->root);\r\n}\r\nstatic int grow_needs_more_blocks(struct resize *resize)\r\n{\r\nint r;\r\nunsigned old_nr_blocks = resize->old_nr_full_blocks;\r\nif (resize->old_nr_entries_in_last_block > 0) {\r\nold_nr_blocks++;\r\nr = grow_extend_tail_block(resize, resize->max_entries);\r\nif (r)\r\nreturn r;\r\n}\r\nr = insert_full_ablocks(resize->info, resize->size_of_block,\r\nold_nr_blocks,\r\nresize->new_nr_full_blocks,\r\nresize->max_entries, resize->value,\r\n&resize->root);\r\nif (r)\r\nreturn r;\r\nif (resize->new_nr_entries_in_last_block)\r\nr = grow_add_tail_block(resize);\r\nreturn r;\r\n}\r\nstatic int grow(struct resize *resize)\r\n{\r\nif (resize->new_nr_full_blocks > resize->old_nr_full_blocks)\r\nreturn grow_needs_more_blocks(resize);\r\nelse if (resize->old_nr_entries_in_last_block)\r\nreturn grow_extend_tail_block(resize, resize->new_nr_entries_in_last_block);\r\nelse\r\nreturn grow_add_tail_block(resize);\r\n}\r\nstatic void block_inc(void *context, const void *value)\r\n{\r\n__le64 block_le;\r\nstruct dm_array_info *info = context;\r\nmemcpy(&block_le, value, sizeof(block_le));\r\ndm_tm_inc(info->btree_info.tm, le64_to_cpu(block_le));\r\n}\r\nstatic void block_dec(void *context, const void *value)\r\n{\r\nint r;\r\nuint64_t b;\r\n__le64 block_le;\r\nuint32_t ref_count;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nstruct dm_array_info *info = context;\r\nmemcpy(&block_le, value, sizeof(block_le));\r\nb = le64_to_cpu(block_le);\r\nr = dm_tm_ref(info->btree_info.tm, b, &ref_count);\r\nif (r) {\r\nDMERR_LIMIT("couldn't get reference count for block %llu",\r\n(unsigned long long) b);\r\nreturn;\r\n}\r\nif (ref_count == 1) {\r\nr = get_ablock(info, b, &block, &ab);\r\nif (r) {\r\nDMERR_LIMIT("couldn't get array block %llu",\r\n(unsigned long long) b);\r\nreturn;\r\n}\r\ndec_ablock_entries(info, ab);\r\nunlock_ablock(info, block);\r\n}\r\ndm_tm_dec(info->btree_info.tm, b);\r\n}\r\nstatic int block_equal(void *context, const void *value1, const void *value2)\r\n{\r\nreturn !memcmp(value1, value2, sizeof(__le64));\r\n}\r\nvoid dm_array_info_init(struct dm_array_info *info,\r\nstruct dm_transaction_manager *tm,\r\nstruct dm_btree_value_type *vt)\r\n{\r\nstruct dm_btree_value_type *bvt = &info->btree_info.value_type;\r\nmemcpy(&info->value_type, vt, sizeof(info->value_type));\r\ninfo->btree_info.tm = tm;\r\ninfo->btree_info.levels = 1;\r\nbvt->context = info;\r\nbvt->size = sizeof(__le64);\r\nbvt->inc = block_inc;\r\nbvt->dec = block_dec;\r\nbvt->equal = block_equal;\r\n}\r\nint dm_array_empty(struct dm_array_info *info, dm_block_t *root)\r\n{\r\nreturn dm_btree_empty(&info->btree_info, root);\r\n}\r\nstatic int array_resize(struct dm_array_info *info, dm_block_t root,\r\nuint32_t old_size, uint32_t new_size,\r\nconst void *value, dm_block_t *new_root)\r\n{\r\nint r;\r\nstruct resize resize;\r\nif (old_size == new_size) {\r\n*new_root = root;\r\nreturn 0;\r\n}\r\nresize.info = info;\r\nresize.root = root;\r\nresize.size_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\r\nresize.max_entries = calc_max_entries(info->value_type.size,\r\nresize.size_of_block);\r\nresize.old_nr_full_blocks = old_size / resize.max_entries;\r\nresize.old_nr_entries_in_last_block = old_size % resize.max_entries;\r\nresize.new_nr_full_blocks = new_size / resize.max_entries;\r\nresize.new_nr_entries_in_last_block = new_size % resize.max_entries;\r\nresize.value = value;\r\nr = ((new_size > old_size) ? grow : shrink)(&resize);\r\nif (r)\r\nreturn r;\r\n*new_root = resize.root;\r\nreturn 0;\r\n}\r\nint dm_array_resize(struct dm_array_info *info, dm_block_t root,\r\nuint32_t old_size, uint32_t new_size,\r\nconst void *value, dm_block_t *new_root)\r\n__dm_written_to_disk(value)\r\n{\r\nint r = array_resize(info, root, old_size, new_size, value, new_root);\r\n__dm_unbless_for_disk(value);\r\nreturn r;\r\n}\r\nint dm_array_del(struct dm_array_info *info, dm_block_t root)\r\n{\r\nreturn dm_btree_del(&info->btree_info, root);\r\n}\r\nint dm_array_get_value(struct dm_array_info *info, dm_block_t root,\r\nuint32_t index, void *value_le)\r\n{\r\nint r;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nsize_t size_of_block;\r\nunsigned entry, max_entries;\r\nsize_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\r\nmax_entries = calc_max_entries(info->value_type.size, size_of_block);\r\nr = lookup_ablock(info, root, index / max_entries, &block, &ab);\r\nif (r)\r\nreturn r;\r\nentry = index % max_entries;\r\nif (entry >= le32_to_cpu(ab->nr_entries))\r\nr = -ENODATA;\r\nelse\r\nmemcpy(value_le, element_at(info, ab, entry),\r\ninfo->value_type.size);\r\nunlock_ablock(info, block);\r\nreturn r;\r\n}\r\nstatic int array_set_value(struct dm_array_info *info, dm_block_t root,\r\nuint32_t index, const void *value, dm_block_t *new_root)\r\n{\r\nint r;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nsize_t size_of_block;\r\nunsigned max_entries;\r\nunsigned entry;\r\nvoid *old_value;\r\nstruct dm_btree_value_type *vt = &info->value_type;\r\nsize_of_block = dm_bm_block_size(dm_tm_get_bm(info->btree_info.tm));\r\nmax_entries = calc_max_entries(info->value_type.size, size_of_block);\r\nr = shadow_ablock(info, &root, index / max_entries, &block, &ab);\r\nif (r)\r\nreturn r;\r\n*new_root = root;\r\nentry = index % max_entries;\r\nif (entry >= le32_to_cpu(ab->nr_entries)) {\r\nr = -ENODATA;\r\ngoto out;\r\n}\r\nold_value = element_at(info, ab, entry);\r\nif (vt->dec &&\r\n(!vt->equal || !vt->equal(vt->context, old_value, value))) {\r\nvt->dec(vt->context, old_value);\r\nif (vt->inc)\r\nvt->inc(vt->context, value);\r\n}\r\nmemcpy(old_value, value, info->value_type.size);\r\nout:\r\nunlock_ablock(info, block);\r\nreturn r;\r\n}\r\nint dm_array_set_value(struct dm_array_info *info, dm_block_t root,\r\nuint32_t index, const void *value, dm_block_t *new_root)\r\n__dm_written_to_disk(value)\r\n{\r\nint r;\r\nr = array_set_value(info, root, index, value, new_root);\r\n__dm_unbless_for_disk(value);\r\nreturn r;\r\n}\r\nstatic int walk_ablock(void *context, uint64_t *keys, void *leaf)\r\n{\r\nstruct walk_info *wi = context;\r\nint r;\r\nunsigned i;\r\n__le64 block_le;\r\nunsigned nr_entries, max_entries;\r\nstruct dm_block *block;\r\nstruct array_block *ab;\r\nmemcpy(&block_le, leaf, sizeof(block_le));\r\nr = get_ablock(wi->info, le64_to_cpu(block_le), &block, &ab);\r\nif (r)\r\nreturn r;\r\nmax_entries = le32_to_cpu(ab->max_entries);\r\nnr_entries = le32_to_cpu(ab->nr_entries);\r\nfor (i = 0; i < nr_entries; i++) {\r\nr = wi->fn(wi->context, keys[0] * max_entries + i,\r\nelement_at(wi->info, ab, i));\r\nif (r)\r\nbreak;\r\n}\r\nunlock_ablock(wi->info, block);\r\nreturn r;\r\n}\r\nint dm_array_walk(struct dm_array_info *info, dm_block_t root,\r\nint (*fn)(void *, uint64_t key, void *leaf),\r\nvoid *context)\r\n{\r\nstruct walk_info wi;\r\nwi.info = info;\r\nwi.fn = fn;\r\nwi.context = context;\r\nreturn dm_btree_walk(&info->btree_info, root, walk_ablock, &wi);\r\n}
