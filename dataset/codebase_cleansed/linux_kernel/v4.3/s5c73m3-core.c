static void s5c73m3_fill_mbus_fmt(struct v4l2_mbus_framefmt *mf,\r\nconst struct s5c73m3_frame_size *fs,\r\nu32 code)\r\n{\r\nmf->width = fs->width;\r\nmf->height = fs->height;\r\nmf->code = code;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int s5c73m3_i2c_write(struct i2c_client *client, u16 addr, u16 data)\r\n{\r\nu8 buf[4] = { addr >> 8, addr & 0xff, data >> 8, data & 0xff };\r\nint ret = i2c_master_send(client, buf, sizeof(buf));\r\nv4l_dbg(4, s5c73m3_dbg, client, "%s: addr 0x%04x, data 0x%04x\n",\r\n__func__, addr, data);\r\nif (ret == 4)\r\nreturn 0;\r\nreturn ret < 0 ? ret : -EREMOTEIO;\r\n}\r\nstatic int s5c73m3_i2c_read(struct i2c_client *client, u16 addr, u16 *data)\r\n{\r\nint ret;\r\nu8 rbuf[2], wbuf[2] = { addr >> 8, addr & 0xff };\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = sizeof(wbuf),\r\n.buf = wbuf\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(rbuf),\r\n.buf = rbuf\r\n}\r\n};\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret == 2) {\r\n*data = be16_to_cpup((u16 *)rbuf);\r\nv4l2_dbg(4, s5c73m3_dbg, client,\r\n"%s: addr: 0x%04x, data: 0x%04x\n",\r\n__func__, addr, *data);\r\nreturn 0;\r\n}\r\nv4l2_err(client, "I2C read failed: addr: %04x, (%d)\n", addr, ret);\r\nreturn ret >= 0 ? -EREMOTEIO : ret;\r\n}\r\nint s5c73m3_write(struct s5c73m3 *state, u32 addr, u16 data)\r\n{\r\nstruct i2c_client *client = state->i2c_client;\r\nint ret;\r\nif ((addr ^ state->i2c_write_address) & 0xffff0000) {\r\nret = s5c73m3_i2c_write(client, REG_CMDWR_ADDRH, addr >> 16);\r\nif (ret < 0) {\r\nstate->i2c_write_address = 0;\r\nreturn ret;\r\n}\r\n}\r\nif ((addr ^ state->i2c_write_address) & 0xffff) {\r\nret = s5c73m3_i2c_write(client, REG_CMDWR_ADDRL, addr & 0xffff);\r\nif (ret < 0) {\r\nstate->i2c_write_address = 0;\r\nreturn ret;\r\n}\r\n}\r\nstate->i2c_write_address = addr;\r\nret = s5c73m3_i2c_write(client, REG_CMDBUF_ADDR, data);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->i2c_write_address += 2;\r\nreturn ret;\r\n}\r\nint s5c73m3_read(struct s5c73m3 *state, u32 addr, u16 *data)\r\n{\r\nstruct i2c_client *client = state->i2c_client;\r\nint ret;\r\nif ((addr ^ state->i2c_read_address) & 0xffff0000) {\r\nret = s5c73m3_i2c_write(client, REG_CMDRD_ADDRH, addr >> 16);\r\nif (ret < 0) {\r\nstate->i2c_read_address = 0;\r\nreturn ret;\r\n}\r\n}\r\nif ((addr ^ state->i2c_read_address) & 0xffff) {\r\nret = s5c73m3_i2c_write(client, REG_CMDRD_ADDRL, addr & 0xffff);\r\nif (ret < 0) {\r\nstate->i2c_read_address = 0;\r\nreturn ret;\r\n}\r\n}\r\nstate->i2c_read_address = addr;\r\nret = s5c73m3_i2c_read(client, REG_CMDBUF_ADDR, data);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->i2c_read_address += 2;\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_check_status(struct s5c73m3 *state, unsigned int value)\r\n{\r\nunsigned long start = jiffies;\r\nunsigned long end = start + msecs_to_jiffies(2000);\r\nint ret = 0;\r\nu16 status;\r\nint count = 0;\r\nwhile (time_is_after_jiffies(end)) {\r\nret = s5c73m3_read(state, REG_STATUS, &status);\r\nif (ret < 0 || status == value)\r\nbreak;\r\nusleep_range(500, 1000);\r\n++count;\r\n}\r\nif (count > 0)\r\nv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\r\n"status check took %dms\n",\r\njiffies_to_msecs(jiffies - start));\r\nif (ret == 0 && status != value) {\r\nu16 i2c_status = 0;\r\nu16 i2c_seq_status = 0;\r\ns5c73m3_read(state, REG_I2C_STATUS, &i2c_status);\r\ns5c73m3_read(state, REG_I2C_SEQ_STATUS, &i2c_seq_status);\r\nv4l2_err(&state->sensor_sd,\r\n"wrong status %#x, expected: %#x, i2c_status: %#x/%#x\n",\r\nstatus, value, i2c_status, i2c_seq_status);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn ret;\r\n}\r\nint s5c73m3_isp_command(struct s5c73m3 *state, u16 command, u16 data)\r\n{\r\nint ret;\r\nret = s5c73m3_check_status(state, REG_STATUS_ISP_COMMAND_COMPLETED);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x00095000, command);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x00095002, data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn s5c73m3_write(state, REG_STATUS, 0x0001);\r\n}\r\nstatic int s5c73m3_isp_comm_result(struct s5c73m3 *state, u16 command,\r\nu16 *data)\r\n{\r\nreturn s5c73m3_read(state, COMM_RESULT_OFFSET + command, data);\r\n}\r\nstatic int s5c73m3_set_af_softlanding(struct s5c73m3 *state)\r\n{\r\nunsigned long start = jiffies;\r\nu16 af_softlanding;\r\nint count = 0;\r\nint ret;\r\nconst char *msg;\r\nret = s5c73m3_isp_command(state, COMM_AF_SOFTLANDING,\r\nCOMM_AF_SOFTLANDING_ON);\r\nif (ret < 0) {\r\nv4l2_info(&state->sensor_sd, "AF soft-landing failed\n");\r\nreturn ret;\r\n}\r\nfor (;;) {\r\nret = s5c73m3_isp_comm_result(state, COMM_AF_SOFTLANDING,\r\n&af_softlanding);\r\nif (ret < 0) {\r\nmsg = "failed";\r\nbreak;\r\n}\r\nif (af_softlanding == COMM_AF_SOFTLANDING_RES_COMPLETE) {\r\nmsg = "succeeded";\r\nbreak;\r\n}\r\nif (++count > 100) {\r\nret = -ETIME;\r\nmsg = "timed out";\r\nbreak;\r\n}\r\nmsleep(25);\r\n}\r\nv4l2_info(&state->sensor_sd, "AF soft-landing %s after %dms\n",\r\nmsg, jiffies_to_msecs(jiffies - start));\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_load_fw(struct v4l2_subdev *sd)\r\n{\r\nstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\r\nstruct i2c_client *client = state->i2c_client;\r\nconst struct firmware *fw;\r\nint ret;\r\nchar fw_name[20];\r\nsnprintf(fw_name, sizeof(fw_name), "SlimISP_%.2s.bin",\r\nstate->fw_file_version);\r\nret = request_firmware(&fw, fw_name, &client->dev);\r\nif (ret < 0) {\r\nv4l2_err(sd, "Firmware request failed (%s)\n", fw_name);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(sd, "Loading firmware (%s, %zu B)\n", fw_name, fw->size);\r\nret = s5c73m3_spi_write(state, fw->data, fw->size, 64);\r\nif (ret >= 0)\r\nstate->isp_ready = 1;\r\nelse\r\nv4l2_err(sd, "SPI write failed\n");\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_set_frame_size(struct s5c73m3 *state)\r\n{\r\nconst struct s5c73m3_frame_size *prev_size =\r\nstate->sensor_pix_size[RES_ISP];\r\nconst struct s5c73m3_frame_size *cap_size =\r\nstate->sensor_pix_size[RES_JPEG];\r\nunsigned int chg_mode;\r\nv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\r\n"Preview size: %dx%d, reg_val: 0x%x\n",\r\nprev_size->width, prev_size->height, prev_size->reg_val);\r\nchg_mode = prev_size->reg_val | COMM_CHG_MODE_NEW;\r\nif (state->mbus_code == S5C73M3_JPEG_FMT) {\r\nv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\r\n"Capture size: %dx%d, reg_val: 0x%x\n",\r\ncap_size->width, cap_size->height, cap_size->reg_val);\r\nchg_mode |= cap_size->reg_val;\r\n}\r\nreturn s5c73m3_isp_command(state, COMM_CHG_MODE, chg_mode);\r\n}\r\nstatic int s5c73m3_set_frame_rate(struct s5c73m3 *state)\r\n{\r\nint ret;\r\nif (state->ctrls.stabilization->val)\r\nreturn 0;\r\nif (WARN_ON(state->fiv == NULL))\r\nreturn -EINVAL;\r\nret = s5c73m3_isp_command(state, COMM_FRAME_RATE, state->fiv->fps_reg);\r\nif (!ret)\r\nstate->apply_fiv = 0;\r\nreturn ret;\r\n}\r\nstatic int __s5c73m3_s_stream(struct s5c73m3 *state, struct v4l2_subdev *sd,\r\nint on)\r\n{\r\nu16 mode;\r\nint ret;\r\nif (on && state->apply_fmt) {\r\nif (state->mbus_code == S5C73M3_JPEG_FMT)\r\nmode = COMM_IMG_OUTPUT_INTERLEAVED;\r\nelse\r\nmode = COMM_IMG_OUTPUT_YUV;\r\nret = s5c73m3_isp_command(state, COMM_IMG_OUTPUT, mode);\r\nif (!ret)\r\nret = s5c73m3_set_frame_size(state);\r\nif (ret)\r\nreturn ret;\r\nstate->apply_fmt = 0;\r\n}\r\nret = s5c73m3_isp_command(state, COMM_SENSOR_STREAMING, !!on);\r\nif (ret)\r\nreturn ret;\r\nstate->streaming = !!on;\r\nif (!on)\r\nreturn ret;\r\nif (state->apply_fiv) {\r\nret = s5c73m3_set_frame_rate(state);\r\nif (ret < 0)\r\nv4l2_err(sd, "Error setting frame rate(%d)\n", ret);\r\n}\r\nreturn s5c73m3_check_status(state, REG_STATUS_ISP_COMMAND_COMPLETED);\r\n}\r\nstatic int s5c73m3_oif_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint ret;\r\nmutex_lock(&state->lock);\r\nret = __s5c73m3_s_stream(state, sd, on);\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_system_status_wait(struct s5c73m3 *state, u32 value,\r\nunsigned int delay, unsigned int steps)\r\n{\r\nu16 reg = 0;\r\nwhile (steps-- > 0) {\r\nint ret = s5c73m3_read(state, 0x30100010, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (reg == value)\r\nreturn 0;\r\nusleep_range(delay, delay + 25);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int s5c73m3_read_fw_version(struct s5c73m3 *state)\r\n{\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nint i, ret;\r\nu16 data[2];\r\nint offset;\r\noffset = state->isp_ready ? 0x60 : 0;\r\nfor (i = 0; i < S5C73M3_SENSOR_FW_LEN / 2; i++) {\r\nret = s5c73m3_read(state, offset + i * 2, data);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->sensor_fw[i * 2] = (char)(*data & 0xff);\r\nstate->sensor_fw[i * 2 + 1] = (char)(*data >> 8);\r\n}\r\nstate->sensor_fw[S5C73M3_SENSOR_FW_LEN] = '\0';\r\nfor (i = 0; i < S5C73M3_SENSOR_TYPE_LEN / 2; i++) {\r\nret = s5c73m3_read(state, offset + 6 + i * 2, data);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->sensor_type[i * 2] = (char)(*data & 0xff);\r\nstate->sensor_type[i * 2 + 1] = (char)(*data >> 8);\r\n}\r\nstate->sensor_type[S5C73M3_SENSOR_TYPE_LEN] = '\0';\r\nret = s5c73m3_read(state, offset + 0x14, data);\r\nif (ret >= 0) {\r\nret = s5c73m3_read(state, offset + 0x16, data + 1);\r\nif (ret >= 0)\r\nstate->fw_size = data[0] + (data[1] << 16);\r\n}\r\nv4l2_info(sd, "Sensor type: %s, FW version: %s\n",\r\nstate->sensor_type, state->sensor_fw);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_fw_update_from(struct s5c73m3 *state)\r\n{\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nu16 status = COMM_FW_UPDATE_NOT_READY;\r\nint ret;\r\nint count = 0;\r\nv4l2_warn(sd, "Updating F-ROM firmware.\n");\r\ndo {\r\nif (status == COMM_FW_UPDATE_NOT_READY) {\r\nret = s5c73m3_isp_command(state, COMM_FW_UPDATE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = s5c73m3_read(state, 0x00095906, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (status) {\r\ncase COMM_FW_UPDATE_FAIL:\r\nv4l2_warn(sd, "Updating F-ROM firmware failed.\n");\r\nreturn -EIO;\r\ncase COMM_FW_UPDATE_SUCCESS:\r\nv4l2_warn(sd, "Updating F-ROM firmware finished.\n");\r\nreturn 0;\r\n}\r\n++count;\r\nmsleep(20);\r\n} while (count < 500);\r\nv4l2_warn(sd, "Updating F-ROM firmware timed-out.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int s5c73m3_spi_boot(struct s5c73m3 *state, bool load_fw)\r\n{\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nint ret;\r\nret = s5c73m3_write(state, 0x30000004, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(400, 500);\r\nret = s5c73m3_system_status_wait(state, 0x0c, 100, 3);\r\nif (ret < 0) {\r\nv4l2_err(sd, "booting failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = s5c73m3_write(state, 0x30100014, 0x2146);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x30100010, 0x210c);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(200, 250);\r\nret = s5c73m3_system_status_wait(state, 0x210d, 100, 300);\r\nif (ret < 0)\r\nv4l2_err(sd, "SPI not ready: %d\n", ret);\r\nif (load_fw)\r\ns5c73m3_load_fw(sd);\r\nret = s5c73m3_write(state, 0x30000004, 0xfffd);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x301000a4, 0x0183);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x30000004, 0xffff);\r\nif (ret < 0 || !load_fw)\r\nreturn ret;\r\nret = s5c73m3_read_fw_version(state);\r\nif (ret < 0)\r\nreturn ret;\r\nif (load_fw && update_fw) {\r\nret = s5c73m3_fw_update_from(state);\r\nupdate_fw = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_set_timing_register_for_vdd(struct s5c73m3 *state)\r\n{\r\nstatic const u32 regs[][2] = {\r\n{ 0x30100018, 0x0618 },\r\n{ 0x3010001c, 0x10c1 },\r\n{ 0x30100020, 0x249e }\r\n};\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++) {\r\nret = s5c73m3_write(state, regs[i][0], regs[i][1]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s5c73m3_set_fw_file_version(struct s5c73m3 *state)\r\n{\r\nswitch (state->sensor_fw[0]) {\r\ncase 'G':\r\ncase 'O':\r\nstate->fw_file_version[0] = 'G';\r\nbreak;\r\ncase 'S':\r\ncase 'Z':\r\nstate->fw_file_version[0] = 'Z';\r\nbreak;\r\n}\r\nswitch (state->sensor_fw[1]) {\r\ncase 'C'...'F':\r\nstate->fw_file_version[1] = state->sensor_fw[1];\r\nbreak;\r\n}\r\n}\r\nstatic int s5c73m3_get_fw_version(struct s5c73m3 *state)\r\n{\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nint ret;\r\nret = s5c73m3_write(state, 0x30000004, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(400, 500);\r\nret = s5c73m3_system_status_wait(state, 0x0c, 100, 3);\r\nif (ret < 0) {\r\nv4l2_err(sd, "%s: booting failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = s5c73m3_write(state, 0x30100120, 0x0820);\r\nret = s5c73m3_write(state, 0x30100124, 0x0820);\r\nret = s5c73m3_write(state, 0x00010418, 0x0008);\r\nret = s5c73m3_write(state, 0x30100014, 0x2146);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x30100010, 0x230c);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(200, 250);\r\nret = s5c73m3_system_status_wait(state, 0x230e, 100, 300);\r\nif (ret < 0)\r\nv4l2_err(sd, "SPI not ready: %d\n", ret);\r\nret = s5c73m3_write(state, 0x30000004, 0xfffd);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x301000a4, 0x0183);\r\nif (ret < 0)\r\nreturn ret;\r\ns5c73m3_set_timing_register_for_vdd(state);\r\nret = s5c73m3_read_fw_version(state);\r\ns5c73m3_set_fw_file_version(state);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_rom_boot(struct s5c73m3 *state, bool load_fw)\r\n{\r\nstatic const u32 boot_regs[][2] = {\r\n{ 0x3100010c, 0x0044 },\r\n{ 0x31000108, 0x000d },\r\n{ 0x31000304, 0x0001 },\r\n{ 0x00010000, 0x5800 },\r\n{ 0x00010002, 0x0002 },\r\n{ 0x31000000, 0x0001 },\r\n{ 0x30100014, 0x1b85 },\r\n{ 0x30100010, 0x230c }\r\n};\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nint i, ret;\r\nret = s5c73m3_write(state, 0x30000004, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(400, 450);\r\nret = s5c73m3_system_status_wait(state, 0x0c, 100, 4);\r\nif (ret < 0) {\r\nv4l2_err(sd, "Booting failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(boot_regs); i++) {\r\nret = s5c73m3_write(state, boot_regs[i][0], boot_regs[i][1]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmsleep(200);\r\nret = s5c73m3_system_status_wait(state, 0x230e, 1000, 150);\r\nif (ret < 0) {\r\nv4l2_err(sd, "Binary read failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = s5c73m3_write(state, 0x30000004, 0xfffd);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x301000a4, 0x0183);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_write(state, 0x30000004, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->isp_ready = 1;\r\nreturn s5c73m3_read_fw_version(state);\r\n}\r\nstatic int s5c73m3_isp_init(struct s5c73m3 *state)\r\n{\r\nint ret;\r\nstate->i2c_read_address = 0;\r\nstate->i2c_write_address = 0;\r\nret = s5c73m3_i2c_write(state->i2c_client, AHB_MSB_ADDR_PTR, 0x3310);\r\nif (ret < 0)\r\nreturn ret;\r\nif (boot_from_rom)\r\nreturn s5c73m3_rom_boot(state, true);\r\nelse\r\nreturn s5c73m3_spi_boot(state, true);\r\n}\r\nstatic const struct s5c73m3_frame_size *s5c73m3_find_frame_size(\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum s5c73m3_resolution_types idx)\r\n{\r\nconst struct s5c73m3_frame_size *fs;\r\nconst struct s5c73m3_frame_size *best_fs;\r\nint best_dist = INT_MAX;\r\nint i;\r\nfs = s5c73m3_resolutions[idx];\r\nbest_fs = NULL;\r\nfor (i = 0; i < s5c73m3_resolutions_len[idx]; ++i) {\r\nint dist = abs(fs->width - fmt->width) +\r\nabs(fs->height - fmt->height);\r\nif (dist < best_dist) {\r\nbest_dist = dist;\r\nbest_fs = fs;\r\n}\r\n++fs;\r\n}\r\nreturn best_fs;\r\n}\r\nstatic void s5c73m3_oif_try_format(struct s5c73m3 *state,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt,\r\nconst struct s5c73m3_frame_size **fs)\r\n{\r\nstruct v4l2_subdev *sd = &state->sensor_sd;\r\nu32 code;\r\nswitch (fmt->pad) {\r\ncase OIF_ISP_PAD:\r\n*fs = s5c73m3_find_frame_size(&fmt->format, RES_ISP);\r\ncode = S5C73M3_ISP_FMT;\r\nbreak;\r\ncase OIF_JPEG_PAD:\r\n*fs = s5c73m3_find_frame_size(&fmt->format, RES_JPEG);\r\ncode = S5C73M3_JPEG_FMT;\r\nbreak;\r\ncase OIF_SOURCE_PAD:\r\ndefault:\r\nif (fmt->format.code == S5C73M3_JPEG_FMT)\r\ncode = S5C73M3_JPEG_FMT;\r\nelse\r\ncode = S5C73M3_ISP_FMT;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\n*fs = state->oif_pix_size[RES_ISP];\r\nelse\r\n*fs = s5c73m3_find_frame_size(\r\nv4l2_subdev_get_try_format(sd, cfg,\r\nOIF_ISP_PAD),\r\nRES_ISP);\r\nbreak;\r\n}\r\ns5c73m3_fill_mbus_fmt(&fmt->format, *fs, code);\r\n}\r\nstatic void s5c73m3_try_format(struct s5c73m3 *state,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt,\r\nconst struct s5c73m3_frame_size **fs)\r\n{\r\nu32 code;\r\nif (fmt->pad == S5C73M3_ISP_PAD) {\r\n*fs = s5c73m3_find_frame_size(&fmt->format, RES_ISP);\r\ncode = S5C73M3_ISP_FMT;\r\n} else {\r\n*fs = s5c73m3_find_frame_size(&fmt->format, RES_JPEG);\r\ncode = S5C73M3_JPEG_FMT;\r\n}\r\ns5c73m3_fill_mbus_fmt(&fmt->format, *fs, code);\r\n}\r\nstatic int s5c73m3_oif_g_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nif (fi->pad != OIF_SOURCE_PAD)\r\nreturn -EINVAL;\r\nmutex_lock(&state->lock);\r\nfi->interval = state->fiv->interval;\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int __s5c73m3_set_frame_interval(struct s5c73m3 *state,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nconst struct s5c73m3_frame_size *prev_size =\r\nstate->sensor_pix_size[RES_ISP];\r\nconst struct s5c73m3_interval *fiv = &s5c73m3_intervals[0];\r\nunsigned int ret, min_err = UINT_MAX;\r\nunsigned int i, fr_time;\r\nif (fi->interval.denominator == 0)\r\nreturn -EINVAL;\r\nfr_time = fi->interval.numerator * 1000 / fi->interval.denominator;\r\nfor (i = 0; i < ARRAY_SIZE(s5c73m3_intervals); i++) {\r\nconst struct s5c73m3_interval *iv = &s5c73m3_intervals[i];\r\nif (prev_size->width > iv->size.width ||\r\nprev_size->height > iv->size.height)\r\ncontinue;\r\nret = abs(iv->interval.numerator / 1000 - fr_time);\r\nif (ret < min_err) {\r\nfiv = iv;\r\nmin_err = ret;\r\n}\r\n}\r\nstate->fiv = fiv;\r\nv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\r\n"Changed frame interval to %u us\n", fiv->interval.numerator);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_s_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint ret;\r\nif (fi->pad != OIF_SOURCE_PAD)\r\nreturn -EINVAL;\r\nv4l2_dbg(1, s5c73m3_dbg, sd, "Setting %d/%d frame interval\n",\r\nfi->interval.numerator, fi->interval.denominator);\r\nmutex_lock(&state->lock);\r\nret = __s5c73m3_set_frame_interval(state, fi);\r\nif (!ret) {\r\nif (state->streaming)\r\nret = s5c73m3_set_frame_rate(state);\r\nelse\r\nstate->apply_fiv = 1;\r\n}\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_enum_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_interval_enum *fie)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nconst struct s5c73m3_interval *fi;\r\nint ret = 0;\r\nif (fie->pad != OIF_SOURCE_PAD)\r\nreturn -EINVAL;\r\nif (fie->index >= ARRAY_SIZE(s5c73m3_intervals))\r\nreturn -EINVAL;\r\nmutex_lock(&state->lock);\r\nfi = &s5c73m3_intervals[fie->index];\r\nif (fie->width > fi->size.width || fie->height > fi->size.height)\r\nret = -EINVAL;\r\nelse\r\nfie->interval = fi->interval;\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_get_pad_code(int pad, int index)\r\n{\r\nif (pad == OIF_SOURCE_PAD) {\r\nif (index > 1)\r\nreturn -EINVAL;\r\nreturn (index == 0) ? S5C73M3_ISP_FMT : S5C73M3_JPEG_FMT;\r\n}\r\nif (index > 0)\r\nreturn -EINVAL;\r\nreturn (pad == OIF_ISP_PAD) ? S5C73M3_ISP_FMT : S5C73M3_JPEG_FMT;\r\n}\r\nstatic int s5c73m3_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\r\nconst struct s5c73m3_frame_size *fs;\r\nu32 code;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nfmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\nreturn 0;\r\n}\r\nmutex_lock(&state->lock);\r\nswitch (fmt->pad) {\r\ncase S5C73M3_ISP_PAD:\r\ncode = S5C73M3_ISP_FMT;\r\nfs = state->sensor_pix_size[RES_ISP];\r\nbreak;\r\ncase S5C73M3_JPEG_PAD:\r\ncode = S5C73M3_JPEG_FMT;\r\nfs = state->sensor_pix_size[RES_JPEG];\r\nbreak;\r\ndefault:\r\nmutex_unlock(&state->lock);\r\nreturn -EINVAL;\r\n}\r\ns5c73m3_fill_mbus_fmt(&fmt->format, fs, code);\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nconst struct s5c73m3_frame_size *fs;\r\nu32 code;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nfmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\nreturn 0;\r\n}\r\nmutex_lock(&state->lock);\r\nswitch (fmt->pad) {\r\ncase OIF_ISP_PAD:\r\ncode = S5C73M3_ISP_FMT;\r\nfs = state->oif_pix_size[RES_ISP];\r\nbreak;\r\ncase OIF_JPEG_PAD:\r\ncode = S5C73M3_JPEG_FMT;\r\nfs = state->oif_pix_size[RES_JPEG];\r\nbreak;\r\ncase OIF_SOURCE_PAD:\r\ncode = state->mbus_code;\r\nfs = state->oif_pix_size[RES_ISP];\r\nbreak;\r\ndefault:\r\nmutex_unlock(&state->lock);\r\nreturn -EINVAL;\r\n}\r\ns5c73m3_fill_mbus_fmt(&fmt->format, fs, code);\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nconst struct s5c73m3_frame_size *frame_size = NULL;\r\nstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nint ret = 0;\r\nmutex_lock(&state->lock);\r\ns5c73m3_try_format(state, cfg, fmt, &frame_size);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\n*mf = fmt->format;\r\n} else {\r\nswitch (fmt->pad) {\r\ncase S5C73M3_ISP_PAD:\r\nstate->sensor_pix_size[RES_ISP] = frame_size;\r\nbreak;\r\ncase S5C73M3_JPEG_PAD:\r\nstate->sensor_pix_size[RES_JPEG] = frame_size;\r\nbreak;\r\ndefault:\r\nret = -EBUSY;\r\n}\r\nif (state->streaming)\r\nret = -EBUSY;\r\nelse\r\nstate->apply_fmt = 1;\r\n}\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nconst struct s5c73m3_frame_size *frame_size = NULL;\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nint ret = 0;\r\nmutex_lock(&state->lock);\r\ns5c73m3_oif_try_format(state, cfg, fmt, &frame_size);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\n*mf = fmt->format;\r\nif (fmt->pad == OIF_ISP_PAD) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, OIF_SOURCE_PAD);\r\nmf->width = fmt->format.width;\r\nmf->height = fmt->format.height;\r\n}\r\n} else {\r\nswitch (fmt->pad) {\r\ncase OIF_ISP_PAD:\r\nstate->oif_pix_size[RES_ISP] = frame_size;\r\nbreak;\r\ncase OIF_JPEG_PAD:\r\nstate->oif_pix_size[RES_JPEG] = frame_size;\r\nbreak;\r\ncase OIF_SOURCE_PAD:\r\nstate->mbus_code = fmt->format.code;\r\nbreak;\r\ndefault:\r\nret = -EBUSY;\r\n}\r\nif (state->streaming)\r\nret = -EBUSY;\r\nelse\r\nstate->apply_fmt = 1;\r\n}\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\r\nstruct v4l2_mbus_frame_desc *fd)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint i;\r\nif (pad != OIF_SOURCE_PAD || fd == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&state->lock);\r\nfd->num_entries = 2;\r\nfor (i = 0; i < fd->num_entries; i++)\r\nfd->entry[i] = state->frame_desc.entry[i];\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_set_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\r\nstruct v4l2_mbus_frame_desc *fd)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nstruct v4l2_mbus_frame_desc *frame_desc = &state->frame_desc;\r\nint i;\r\nif (pad != OIF_SOURCE_PAD || fd == NULL)\r\nreturn -EINVAL;\r\nfd->entry[0].length = 10 * SZ_1M;\r\nfd->entry[1].length = max_t(u32, fd->entry[1].length,\r\nS5C73M3_EMBEDDED_DATA_MAXLEN);\r\nfd->num_entries = 2;\r\nmutex_lock(&state->lock);\r\nfor (i = 0; i < fd->num_entries; i++)\r\nframe_desc->entry[i] = fd->entry[i];\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstatic const int codes[] = {\r\n[S5C73M3_ISP_PAD] = S5C73M3_ISP_FMT,\r\n[S5C73M3_JPEG_PAD] = S5C73M3_JPEG_FMT};\r\nif (code->index > 0 || code->pad >= S5C73M3_NUM_PADS)\r\nreturn -EINVAL;\r\ncode->code = codes[code->pad];\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nint ret;\r\nret = s5c73m3_oif_get_pad_code(code->pad, code->index);\r\nif (ret < 0)\r\nreturn ret;\r\ncode->code = ret;\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nint idx;\r\nif (fse->pad == S5C73M3_ISP_PAD) {\r\nif (fse->code != S5C73M3_ISP_FMT)\r\nreturn -EINVAL;\r\nidx = RES_ISP;\r\n} else{\r\nif (fse->code != S5C73M3_JPEG_FMT)\r\nreturn -EINVAL;\r\nidx = RES_JPEG;\r\n}\r\nif (fse->index >= s5c73m3_resolutions_len[idx])\r\nreturn -EINVAL;\r\nfse->min_width = s5c73m3_resolutions[idx][fse->index].width;\r\nfse->max_width = fse->min_width;\r\nfse->max_height = s5c73m3_resolutions[idx][fse->index].height;\r\nfse->min_height = fse->max_height;\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint idx;\r\nif (fse->pad == OIF_SOURCE_PAD) {\r\nif (fse->index > 0)\r\nreturn -EINVAL;\r\nswitch (fse->code) {\r\ncase S5C73M3_JPEG_FMT:\r\ncase S5C73M3_ISP_FMT: {\r\nunsigned w, h;\r\nif (fse->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = v4l2_subdev_get_try_format(sd, cfg,\r\nOIF_ISP_PAD);\r\nw = mf->width;\r\nh = mf->height;\r\n} else {\r\nconst struct s5c73m3_frame_size *fs;\r\nfs = state->oif_pix_size[RES_ISP];\r\nw = fs->width;\r\nh = fs->height;\r\n}\r\nfse->max_width = fse->min_width = w;\r\nfse->max_height = fse->min_height = h;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (fse->code != s5c73m3_oif_get_pad_code(fse->pad, 0))\r\nreturn -EINVAL;\r\nif (fse->pad == OIF_JPEG_PAD)\r\nidx = RES_JPEG;\r\nelse\r\nidx = RES_ISP;\r\nif (fse->index >= s5c73m3_resolutions_len[idx])\r\nreturn -EINVAL;\r\nfse->min_width = s5c73m3_resolutions[idx][fse->index].width;\r\nfse->max_width = fse->min_width;\r\nfse->max_height = s5c73m3_resolutions[idx][fse->index].height;\r\nfse->min_height = fse->max_height;\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\r\nv4l2_info(sd, "power: %d, apply_fmt: %d\n", state->power,\r\nstate->apply_fmt);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, S5C73M3_ISP_PAD);\r\ns5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\r\nS5C73M3_ISP_FMT);\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, S5C73M3_JPEG_PAD);\r\ns5c73m3_fill_mbus_fmt(mf, &s5c73m3_jpeg_resolutions[1],\r\nS5C73M3_JPEG_FMT);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_oif_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, OIF_ISP_PAD);\r\ns5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\r\nS5C73M3_ISP_FMT);\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, OIF_JPEG_PAD);\r\ns5c73m3_fill_mbus_fmt(mf, &s5c73m3_jpeg_resolutions[1],\r\nS5C73M3_JPEG_FMT);\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, OIF_SOURCE_PAD);\r\ns5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\r\nS5C73M3_ISP_FMT);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_gpio_set_value(struct s5c73m3 *priv, int id, u32 val)\r\n{\r\nif (!gpio_is_valid(priv->gpio[id].gpio))\r\nreturn 0;\r\ngpio_set_value(priv->gpio[id].gpio, !!val);\r\nreturn 1;\r\n}\r\nstatic int s5c73m3_gpio_assert(struct s5c73m3 *priv, int id)\r\n{\r\nreturn s5c73m3_gpio_set_value(priv, id, priv->gpio[id].level);\r\n}\r\nstatic int s5c73m3_gpio_deassert(struct s5c73m3 *priv, int id)\r\n{\r\nreturn s5c73m3_gpio_set_value(priv, id, !priv->gpio[id].level);\r\n}\r\nstatic int __s5c73m3_power_on(struct s5c73m3 *state)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < S5C73M3_MAX_SUPPLIES; i++) {\r\nret = regulator_enable(state->supplies[i].consumer);\r\nif (ret)\r\ngoto err_reg_dis;\r\n}\r\nret = clk_set_rate(state->clock, state->mclk_frequency);\r\nif (ret < 0)\r\ngoto err_reg_dis;\r\nret = clk_prepare_enable(state->clock);\r\nif (ret < 0)\r\ngoto err_reg_dis;\r\nv4l2_dbg(1, s5c73m3_dbg, &state->oif_sd, "clock frequency: %ld\n",\r\nclk_get_rate(state->clock));\r\ns5c73m3_gpio_deassert(state, STBY);\r\nusleep_range(100, 200);\r\ns5c73m3_gpio_deassert(state, RST);\r\nusleep_range(50, 100);\r\nreturn 0;\r\nerr_reg_dis:\r\nfor (--i; i >= 0; i--)\r\nregulator_disable(state->supplies[i].consumer);\r\nreturn ret;\r\n}\r\nstatic int __s5c73m3_power_off(struct s5c73m3 *state)\r\n{\r\nint i, ret;\r\nif (s5c73m3_gpio_assert(state, RST))\r\nusleep_range(10, 50);\r\nif (s5c73m3_gpio_assert(state, STBY))\r\nusleep_range(100, 200);\r\nclk_disable_unprepare(state->clock);\r\nstate->streaming = 0;\r\nstate->isp_ready = 0;\r\nfor (i = S5C73M3_MAX_SUPPLIES - 1; i >= 0; i--) {\r\nret = regulator_disable(state->supplies[i].consumer);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (++i; i < S5C73M3_MAX_SUPPLIES; i++) {\r\nint r = regulator_enable(state->supplies[i].consumer);\r\nif (r < 0)\r\nv4l2_err(&state->oif_sd, "Failed to reenable %s: %d\n",\r\nstate->supplies[i].supply, r);\r\n}\r\nclk_prepare_enable(state->clock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_set_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint ret = 0;\r\nmutex_lock(&state->lock);\r\nif (on && !state->power) {\r\nret = __s5c73m3_power_on(state);\r\nif (!ret)\r\nret = s5c73m3_isp_init(state);\r\nif (!ret) {\r\nstate->apply_fiv = 1;\r\nstate->apply_fmt = 1;\r\n}\r\n} else if (state->power == !on) {\r\nret = s5c73m3_set_af_softlanding(state);\r\nif (!ret)\r\nret = __s5c73m3_power_off(state);\r\nelse\r\nv4l2_err(sd, "Soft landing lens failed\n");\r\n}\r\nif (!ret)\r\nstate->power += on ? 1 : -1;\r\nv4l2_dbg(1, s5c73m3_dbg, sd, "%s: power: %d\n",\r\n__func__, state->power);\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_oif_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nint ret;\r\nret = v4l2_device_register_subdev(sd->v4l2_dev, &state->sensor_sd);\r\nif (ret) {\r\nv4l2_err(sd->v4l2_dev, "Failed to register %s\n",\r\nstate->oif_sd.name);\r\nreturn ret;\r\n}\r\nret = media_entity_create_link(&state->sensor_sd.entity,\r\nS5C73M3_ISP_PAD, &state->oif_sd.entity, OIF_ISP_PAD,\r\nMEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);\r\nret = media_entity_create_link(&state->sensor_sd.entity,\r\nS5C73M3_JPEG_PAD, &state->oif_sd.entity, OIF_JPEG_PAD,\r\nMEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);\r\nreturn ret;\r\n}\r\nstatic void s5c73m3_oif_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\r\nv4l2_device_unregister_subdev(&state->sensor_sd);\r\n}\r\nstatic int s5c73m3_configure_gpios(struct s5c73m3 *state)\r\n{\r\nstatic const char * const gpio_names[] = {\r\n"S5C73M3_STBY", "S5C73M3_RST"\r\n};\r\nstruct i2c_client *c = state->i2c_client;\r\nstruct s5c73m3_gpio *g = state->gpio;\r\nint ret, i;\r\nfor (i = 0; i < GPIO_NUM; ++i) {\r\nunsigned int flags = GPIOF_DIR_OUT;\r\nif (g[i].level)\r\nflags |= GPIOF_INIT_HIGH;\r\nret = devm_gpio_request_one(&c->dev, g[i].gpio, flags,\r\ngpio_names[i]);\r\nif (ret) {\r\nv4l2_err(c, "failed to request gpio %s\n",\r\ngpio_names[i]);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_parse_gpios(struct s5c73m3 *state)\r\n{\r\nstatic const char * const prop_names[] = {\r\n"standby-gpios", "xshutdown-gpios",\r\n};\r\nstruct device *dev = &state->i2c_client->dev;\r\nstruct device_node *node = dev->of_node;\r\nint ret, i;\r\nfor (i = 0; i < GPIO_NUM; ++i) {\r\nenum of_gpio_flags of_flags;\r\nret = of_get_named_gpio_flags(node, prop_names[i],\r\n0, &of_flags);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to parse %s DT property\n",\r\nprop_names[i]);\r\nreturn -EINVAL;\r\n}\r\nstate->gpio[i].gpio = ret;\r\nstate->gpio[i].level = !(of_flags & OF_GPIO_ACTIVE_LOW);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_get_platform_data(struct s5c73m3 *state)\r\n{\r\nstruct device *dev = &state->i2c_client->dev;\r\nconst struct s5c73m3_platform_data *pdata = dev->platform_data;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *node_ep;\r\nstruct v4l2_of_endpoint ep;\r\nint ret;\r\nif (!node) {\r\nif (!pdata) {\r\ndev_err(dev, "Platform data not specified\n");\r\nreturn -EINVAL;\r\n}\r\nstate->mclk_frequency = pdata->mclk_frequency;\r\nstate->gpio[STBY] = pdata->gpio_stby;\r\nstate->gpio[RST] = pdata->gpio_reset;\r\nreturn 0;\r\n}\r\nstate->clock = devm_clk_get(dev, S5C73M3_CLK_NAME);\r\nif (IS_ERR(state->clock))\r\nreturn PTR_ERR(state->clock);\r\nif (of_property_read_u32(node, "clock-frequency",\r\n&state->mclk_frequency)) {\r\nstate->mclk_frequency = S5C73M3_DEFAULT_MCLK_FREQ;\r\ndev_info(dev, "using default %u Hz clock frequency\n",\r\nstate->mclk_frequency);\r\n}\r\nret = s5c73m3_parse_gpios(state);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nnode_ep = of_graph_get_next_endpoint(node, NULL);\r\nif (!node_ep) {\r\ndev_warn(dev, "no endpoint defined for node: %s\n",\r\nnode->full_name);\r\nreturn 0;\r\n}\r\nv4l2_of_parse_endpoint(node_ep, &ep);\r\nof_node_put(node_ep);\r\nif (ep.bus_type != V4L2_MBUS_CSI2) {\r\ndev_err(dev, "unsupported bus type\n");\r\nreturn -EINVAL;\r\n}\r\nif (ep.bus.mipi_csi2.num_data_lanes != S5C73M3_MIPI_DATA_LANES)\r\ndev_info(dev, "falling back to 4 MIPI CSI-2 data lanes\n");\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_subdev *oif_sd;\r\nstruct s5c73m3 *state;\r\nint ret, i;\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->i2c_client = client;\r\nret = s5c73m3_get_platform_data(state);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&state->lock);\r\nsd = &state->sensor_sd;\r\noif_sd = &state->oif_sd;\r\nv4l2_subdev_init(sd, &s5c73m3_subdev_ops);\r\nsd->owner = client->dev.driver->owner;\r\nv4l2_set_subdevdata(sd, state);\r\nstrlcpy(sd->name, "S5C73M3", sizeof(sd->name));\r\nsd->internal_ops = &s5c73m3_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->sensor_pads[S5C73M3_JPEG_PAD].flags = MEDIA_PAD_FL_SOURCE;\r\nstate->sensor_pads[S5C73M3_ISP_PAD].flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV;\r\nret = media_entity_init(&sd->entity, S5C73M3_NUM_PADS,\r\nstate->sensor_pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_i2c_subdev_init(oif_sd, client, &oif_subdev_ops);\r\nstrcpy(oif_sd->name, "S5C73M3-OIF");\r\noif_sd->internal_ops = &oif_internal_ops;\r\noif_sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->oif_pads[OIF_ISP_PAD].flags = MEDIA_PAD_FL_SINK;\r\nstate->oif_pads[OIF_JPEG_PAD].flags = MEDIA_PAD_FL_SINK;\r\nstate->oif_pads[OIF_SOURCE_PAD].flags = MEDIA_PAD_FL_SOURCE;\r\noif_sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV;\r\nret = media_entity_init(&oif_sd->entity, OIF_NUM_PADS,\r\nstate->oif_pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5c73m3_configure_gpios(state);\r\nif (ret)\r\ngoto out_err;\r\nfor (i = 0; i < S5C73M3_MAX_SUPPLIES; i++)\r\nstate->supplies[i].supply = s5c73m3_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, S5C73M3_MAX_SUPPLIES,\r\nstate->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to get regulators\n");\r\ngoto out_err;\r\n}\r\nret = s5c73m3_init_controls(state);\r\nif (ret)\r\ngoto out_err;\r\nstate->sensor_pix_size[RES_ISP] = &s5c73m3_isp_resolutions[1];\r\nstate->sensor_pix_size[RES_JPEG] = &s5c73m3_jpeg_resolutions[1];\r\nstate->oif_pix_size[RES_ISP] = state->sensor_pix_size[RES_ISP];\r\nstate->oif_pix_size[RES_JPEG] = state->sensor_pix_size[RES_JPEG];\r\nstate->mbus_code = S5C73M3_ISP_FMT;\r\nstate->fiv = &s5c73m3_intervals[S5C73M3_DEFAULT_FRAME_INTERVAL];\r\nstate->fw_file_version[0] = 'G';\r\nstate->fw_file_version[1] = 'C';\r\nret = s5c73m3_register_spi_driver(state);\r\nif (ret < 0)\r\ngoto out_err;\r\noif_sd->dev = dev;\r\nret = __s5c73m3_power_on(state);\r\nif (ret < 0)\r\ngoto out_err1;\r\nret = s5c73m3_get_fw_version(state);\r\n__s5c73m3_power_off(state);\r\nif (ret < 0) {\r\ndev_err(dev, "Device detection failed: %d\n", ret);\r\ngoto out_err1;\r\n}\r\nret = v4l2_async_register_subdev(oif_sd);\r\nif (ret < 0)\r\ngoto out_err1;\r\nv4l2_info(sd, "%s: completed successfully\n", __func__);\r\nreturn 0;\r\nout_err1:\r\ns5c73m3_unregister_spi_driver(state);\r\nout_err:\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn ret;\r\n}\r\nstatic int s5c73m3_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *oif_sd = i2c_get_clientdata(client);\r\nstruct s5c73m3 *state = oif_sd_to_s5c73m3(oif_sd);\r\nstruct v4l2_subdev *sensor_sd = &state->sensor_sd;\r\nv4l2_async_unregister_subdev(oif_sd);\r\nv4l2_ctrl_handler_free(oif_sd->ctrl_handler);\r\nmedia_entity_cleanup(&oif_sd->entity);\r\nv4l2_device_unregister_subdev(sensor_sd);\r\nmedia_entity_cleanup(&sensor_sd->entity);\r\ns5c73m3_unregister_spi_driver(state);\r\nreturn 0;\r\n}
