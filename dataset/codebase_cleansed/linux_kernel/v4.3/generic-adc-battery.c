static struct gab *to_generic_bat(struct power_supply *psy)\r\n{\r\nreturn power_supply_get_drvdata(psy);\r\n}\r\nstatic void gab_ext_power_changed(struct power_supply *psy)\r\n{\r\nstruct gab *adc_bat = to_generic_bat(psy);\r\nschedule_delayed_work(&adc_bat->bat_work, msecs_to_jiffies(0));\r\n}\r\nstatic bool gab_charge_finished(struct gab *adc_bat)\r\n{\r\nstruct gab_platform_data *pdata = adc_bat->pdata;\r\nbool ret = gpio_get_value(pdata->gpio_charge_finished);\r\nbool inv = pdata->gpio_inverted;\r\nif (!gpio_is_valid(pdata->gpio_charge_finished))\r\nreturn false;\r\nreturn ret ^ inv;\r\n}\r\nstatic int gab_get_status(struct gab *adc_bat)\r\n{\r\nstruct gab_platform_data *pdata = adc_bat->pdata;\r\nstruct power_supply_info *bat_info;\r\nbat_info = &pdata->battery_info;\r\nif (adc_bat->level == bat_info->charge_full_design)\r\nreturn POWER_SUPPLY_STATUS_FULL;\r\nreturn adc_bat->status;\r\n}\r\nstatic enum gab_chan_type gab_prop_to_chan(enum power_supply_property psp)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_POWER_NOW:\r\nreturn GAB_POWER;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nreturn GAB_VOLTAGE;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nreturn GAB_CURRENT;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn GAB_POWER;\r\n}\r\nstatic int read_channel(struct gab *adc_bat, enum power_supply_property psp,\r\nint *result)\r\n{\r\nint ret;\r\nint chan_index;\r\nchan_index = gab_prop_to_chan(psp);\r\nret = iio_read_channel_processed(adc_bat->channel[chan_index],\r\nresult);\r\nif (ret < 0)\r\npr_err("read channel error\n");\r\nreturn ret;\r\n}\r\nstatic int gab_get_property(struct power_supply *psy,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\nstruct gab *adc_bat;\r\nstruct gab_platform_data *pdata;\r\nstruct power_supply_info *bat_info;\r\nint result = 0;\r\nint ret = 0;\r\nadc_bat = to_generic_bat(psy);\r\nif (!adc_bat) {\r\ndev_err(&psy->dev, "no battery infos ?!\n");\r\nreturn -EINVAL;\r\n}\r\npdata = adc_bat->pdata;\r\nbat_info = &pdata->battery_info;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = gab_get_status(adc_bat);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN:\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nval->intval = pdata->cal_charge(result);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_POWER_NOW:\r\nret = read_channel(adc_bat, psp, &result);\r\nif (ret < 0)\r\ngoto err;\r\nval->intval = result;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = bat_info->technology;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = bat_info->voltage_min_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = bat_info->voltage_max_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = bat_info->charge_full_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = bat_info->name;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void gab_work(struct work_struct *work)\r\n{\r\nstruct gab *adc_bat;\r\nstruct gab_platform_data *pdata;\r\nstruct delayed_work *delayed_work;\r\nbool is_plugged;\r\nint status;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\nadc_bat = container_of(delayed_work, struct gab, bat_work);\r\npdata = adc_bat->pdata;\r\nstatus = adc_bat->status;\r\nis_plugged = power_supply_am_i_supplied(adc_bat->psy);\r\nadc_bat->cable_plugged = is_plugged;\r\nif (!is_plugged)\r\nadc_bat->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (gab_charge_finished(adc_bat))\r\nadc_bat->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nadc_bat->status = POWER_SUPPLY_STATUS_CHARGING;\r\nif (status != adc_bat->status)\r\npower_supply_changed(adc_bat->psy);\r\n}\r\nstatic irqreturn_t gab_charged(int irq, void *dev_id)\r\n{\r\nstruct gab *adc_bat = dev_id;\r\nstruct gab_platform_data *pdata = adc_bat->pdata;\r\nint delay;\r\ndelay = pdata->jitter_delay ? pdata->jitter_delay : JITTER_DEFAULT;\r\nschedule_delayed_work(&adc_bat->bat_work,\r\nmsecs_to_jiffies(delay));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gab_probe(struct platform_device *pdev)\r\n{\r\nstruct gab *adc_bat;\r\nstruct power_supply_desc *psy_desc;\r\nstruct power_supply_config psy_cfg = {};\r\nstruct gab_platform_data *pdata = pdev->dev.platform_data;\r\nenum power_supply_property *properties;\r\nint ret = 0;\r\nint chan;\r\nint index = 0;\r\nadc_bat = devm_kzalloc(&pdev->dev, sizeof(*adc_bat), GFP_KERNEL);\r\nif (!adc_bat) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\npsy_cfg.drv_data = adc_bat;\r\npsy_desc = &adc_bat->psy_desc;\r\npsy_desc->name = pdata->battery_info.name;\r\nadc_bat->cable_plugged = false;\r\nadc_bat->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\npsy_desc->type = POWER_SUPPLY_TYPE_BATTERY;\r\npsy_desc->get_property = gab_get_property;\r\npsy_desc->external_power_changed = gab_ext_power_changed;\r\nadc_bat->pdata = pdata;\r\npsy_desc->properties = kcalloc(ARRAY_SIZE(gab_props) +\r\nARRAY_SIZE(gab_chan_name),\r\nsizeof(*psy_desc->properties),\r\nGFP_KERNEL);\r\nif (!psy_desc->properties) {\r\nret = -ENOMEM;\r\ngoto first_mem_fail;\r\n}\r\nmemcpy(psy_desc->properties, gab_props, sizeof(gab_props));\r\nproperties = (enum power_supply_property *)\r\n((char *)psy_desc->properties + sizeof(gab_props));\r\nfor (chan = 0; chan < ARRAY_SIZE(gab_chan_name); chan++) {\r\nadc_bat->channel[chan] = iio_channel_get(&pdev->dev,\r\ngab_chan_name[chan]);\r\nif (IS_ERR(adc_bat->channel[chan])) {\r\nret = PTR_ERR(adc_bat->channel[chan]);\r\nadc_bat->channel[chan] = NULL;\r\n} else {\r\nmemcpy(properties + sizeof(*(psy_desc->properties)) * index,\r\n&gab_dyn_props[chan],\r\nsizeof(gab_dyn_props[chan]));\r\nindex++;\r\n}\r\n}\r\nif (index == 0) {\r\nret = -ENODEV;\r\ngoto second_mem_fail;\r\n}\r\npsy_desc->num_properties = ARRAY_SIZE(gab_props) + index;\r\nadc_bat->psy = power_supply_register(&pdev->dev, psy_desc, &psy_cfg);\r\nif (IS_ERR(adc_bat->psy)) {\r\nret = PTR_ERR(adc_bat->psy);\r\ngoto err_reg_fail;\r\n}\r\nINIT_DELAYED_WORK(&adc_bat->bat_work, gab_work);\r\nif (gpio_is_valid(pdata->gpio_charge_finished)) {\r\nint irq;\r\nret = gpio_request(pdata->gpio_charge_finished, "charged");\r\nif (ret)\r\ngoto gpio_req_fail;\r\nirq = gpio_to_irq(pdata->gpio_charge_finished);\r\nret = request_any_context_irq(irq, gab_charged,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"battery charged", adc_bat);\r\nif (ret < 0)\r\ngoto err_gpio;\r\n}\r\nplatform_set_drvdata(pdev, adc_bat);\r\nschedule_delayed_work(&adc_bat->bat_work,\r\nmsecs_to_jiffies(0));\r\nreturn 0;\r\nerr_gpio:\r\ngpio_free(pdata->gpio_charge_finished);\r\ngpio_req_fail:\r\npower_supply_unregister(adc_bat->psy);\r\nerr_reg_fail:\r\nfor (chan = 0; chan < ARRAY_SIZE(gab_chan_name); chan++) {\r\nif (adc_bat->channel[chan])\r\niio_channel_release(adc_bat->channel[chan]);\r\n}\r\nsecond_mem_fail:\r\nkfree(psy_desc->properties);\r\nfirst_mem_fail:\r\nreturn ret;\r\n}\r\nstatic int gab_remove(struct platform_device *pdev)\r\n{\r\nint chan;\r\nstruct gab *adc_bat = platform_get_drvdata(pdev);\r\nstruct gab_platform_data *pdata = adc_bat->pdata;\r\npower_supply_unregister(adc_bat->psy);\r\nif (gpio_is_valid(pdata->gpio_charge_finished)) {\r\nfree_irq(gpio_to_irq(pdata->gpio_charge_finished), adc_bat);\r\ngpio_free(pdata->gpio_charge_finished);\r\n}\r\nfor (chan = 0; chan < ARRAY_SIZE(gab_chan_name); chan++) {\r\nif (adc_bat->channel[chan])\r\niio_channel_release(adc_bat->channel[chan]);\r\n}\r\nkfree(adc_bat->psy_desc.properties);\r\ncancel_delayed_work(&adc_bat->bat_work);\r\nreturn 0;\r\n}\r\nstatic int gab_suspend(struct device *dev)\r\n{\r\nstruct gab *adc_bat = dev_get_drvdata(dev);\r\ncancel_delayed_work_sync(&adc_bat->bat_work);\r\nadc_bat->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int gab_resume(struct device *dev)\r\n{\r\nstruct gab *adc_bat = dev_get_drvdata(dev);\r\nstruct gab_platform_data *pdata = adc_bat->pdata;\r\nint delay;\r\ndelay = pdata->jitter_delay ? pdata->jitter_delay : JITTER_DEFAULT;\r\nschedule_delayed_work(&adc_bat->bat_work,\r\nmsecs_to_jiffies(delay));\r\nreturn 0;\r\n}
