static int phantom_status(struct phantom_device *dev, unsigned long newstat)\r\n{\r\npr_debug("phantom_status %lx %lx\n", dev->status, newstat);\r\nif (!(dev->status & PHB_RUNNING) && (newstat & PHB_RUNNING)) {\r\natomic_set(&dev->counter, 0);\r\niowrite32(PHN_CTL_IRQ, dev->iaddr + PHN_CONTROL);\r\niowrite32(0x43, dev->caddr + PHN_IRQCTL);\r\nioread32(dev->caddr + PHN_IRQCTL);\r\n} else if ((dev->status & PHB_RUNNING) && !(newstat & PHB_RUNNING)) {\r\niowrite32(0, dev->caddr + PHN_IRQCTL);\r\nioread32(dev->caddr + PHN_IRQCTL);\r\n}\r\ndev->status = newstat;\r\nreturn 0;\r\n}\r\nstatic long phantom_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct phantom_device *dev = file->private_data;\r\nstruct phm_regs rs;\r\nstruct phm_reg r;\r\nvoid __user *argp = (void __user *)arg;\r\nunsigned long flags;\r\nunsigned int i;\r\nswitch (cmd) {\r\ncase PHN_SETREG:\r\ncase PHN_SET_REG:\r\nif (copy_from_user(&r, argp, sizeof(r)))\r\nreturn -EFAULT;\r\nif (r.reg > 7)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->regs_lock, flags);\r\nif (r.reg == PHN_CONTROL && (r.value & PHN_CTL_IRQ) &&\r\nphantom_status(dev, dev->status | PHB_RUNNING)){\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nreturn -ENODEV;\r\n}\r\npr_debug("phantom: writing %x to %u\n", r.value, r.reg);\r\nif (r.reg == PHN_CONTROL && (dev->status & PHB_NOT_OH)) {\r\nr.value &= ~PHN_CTL_AMP;\r\nr.value |= dev->ctl_reg & PHN_CTL_AMP;\r\ndev->ctl_reg = r.value;\r\n}\r\niowrite32(r.value, dev->iaddr + r.reg);\r\nioread32(dev->iaddr);\r\nif (r.reg == PHN_CONTROL && !(r.value & PHN_CTL_IRQ))\r\nphantom_status(dev, dev->status & ~PHB_RUNNING);\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nbreak;\r\ncase PHN_SETREGS:\r\ncase PHN_SET_REGS:\r\nif (copy_from_user(&rs, argp, sizeof(rs)))\r\nreturn -EFAULT;\r\npr_debug("phantom: SRS %u regs %x\n", rs.count, rs.mask);\r\nspin_lock_irqsave(&dev->regs_lock, flags);\r\nif (dev->status & PHB_NOT_OH)\r\nmemcpy(&dev->oregs, &rs, sizeof(rs));\r\nelse {\r\nu32 m = min(rs.count, 8U);\r\nfor (i = 0; i < m; i++)\r\nif (rs.mask & BIT(i))\r\niowrite32(rs.values[i], dev->oaddr + i);\r\nioread32(dev->iaddr);\r\n}\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nbreak;\r\ncase PHN_GETREG:\r\ncase PHN_GET_REG:\r\nif (copy_from_user(&r, argp, sizeof(r)))\r\nreturn -EFAULT;\r\nif (r.reg > 7)\r\nreturn -EINVAL;\r\nr.value = ioread32(dev->iaddr + r.reg);\r\nif (copy_to_user(argp, &r, sizeof(r)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase PHN_GETREGS:\r\ncase PHN_GET_REGS: {\r\nu32 m;\r\nif (copy_from_user(&rs, argp, sizeof(rs)))\r\nreturn -EFAULT;\r\nm = min(rs.count, 8U);\r\npr_debug("phantom: GRS %u regs %x\n", rs.count, rs.mask);\r\nspin_lock_irqsave(&dev->regs_lock, flags);\r\nfor (i = 0; i < m; i++)\r\nif (rs.mask & BIT(i))\r\nrs.values[i] = ioread32(dev->iaddr + i);\r\natomic_set(&dev->counter, 0);\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nif (copy_to_user(argp, &rs, sizeof(rs)))\r\nreturn -EFAULT;\r\nbreak;\r\n} case PHN_NOT_OH:\r\nspin_lock_irqsave(&dev->regs_lock, flags);\r\nif (dev->status & PHB_RUNNING) {\r\nprintk(KERN_ERR "phantom: you need to set NOT_OH "\r\n"before you start the device!\n");\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndev->status |= PHB_NOT_OH;\r\nspin_unlock_irqrestore(&dev->regs_lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic long phantom_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (_IOC_NR(cmd) <= 3 && _IOC_SIZE(cmd) == sizeof(compat_uptr_t)) {\r\ncmd &= ~(_IOC_SIZEMASK << _IOC_SIZESHIFT);\r\ncmd |= sizeof(void *) << _IOC_SIZESHIFT;\r\n}\r\nreturn phantom_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int phantom_open(struct inode *inode, struct file *file)\r\n{\r\nstruct phantom_device *dev = container_of(inode->i_cdev,\r\nstruct phantom_device, cdev);\r\nmutex_lock(&phantom_mutex);\r\nnonseekable_open(inode, file);\r\nif (mutex_lock_interruptible(&dev->open_lock)) {\r\nmutex_unlock(&phantom_mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (dev->opened) {\r\nmutex_unlock(&dev->open_lock);\r\nmutex_unlock(&phantom_mutex);\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(dev->status & PHB_NOT_OH);\r\nfile->private_data = dev;\r\natomic_set(&dev->counter, 0);\r\ndev->opened++;\r\nmutex_unlock(&dev->open_lock);\r\nmutex_unlock(&phantom_mutex);\r\nreturn 0;\r\n}\r\nstatic int phantom_release(struct inode *inode, struct file *file)\r\n{\r\nstruct phantom_device *dev = file->private_data;\r\nmutex_lock(&dev->open_lock);\r\ndev->opened = 0;\r\nphantom_status(dev, dev->status & ~PHB_RUNNING);\r\ndev->status &= ~PHB_NOT_OH;\r\nmutex_unlock(&dev->open_lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int phantom_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct phantom_device *dev = file->private_data;\r\nunsigned int mask = 0;\r\npr_debug("phantom_poll: %d\n", atomic_read(&dev->counter));\r\npoll_wait(file, &dev->wait, wait);\r\nif (!(dev->status & PHB_RUNNING))\r\nmask = POLLERR;\r\nelse if (atomic_read(&dev->counter))\r\nmask = POLLIN | POLLRDNORM;\r\npr_debug("phantom_poll end: %x/%d\n", mask, atomic_read(&dev->counter));\r\nreturn mask;\r\n}\r\nstatic irqreturn_t phantom_isr(int irq, void *data)\r\n{\r\nstruct phantom_device *dev = data;\r\nunsigned int i;\r\nu32 ctl;\r\nspin_lock(&dev->regs_lock);\r\nctl = ioread32(dev->iaddr + PHN_CONTROL);\r\nif (!(ctl & PHN_CTL_IRQ)) {\r\nspin_unlock(&dev->regs_lock);\r\nreturn IRQ_NONE;\r\n}\r\niowrite32(0, dev->iaddr);\r\niowrite32(0xc0, dev->iaddr);\r\nif (dev->status & PHB_NOT_OH) {\r\nstruct phm_regs *r = &dev->oregs;\r\nu32 m = min(r->count, 8U);\r\nfor (i = 0; i < m; i++)\r\nif (r->mask & BIT(i))\r\niowrite32(r->values[i], dev->oaddr + i);\r\ndev->ctl_reg ^= PHN_CTL_AMP;\r\niowrite32(dev->ctl_reg, dev->iaddr + PHN_CONTROL);\r\n}\r\nspin_unlock(&dev->regs_lock);\r\nioread32(dev->iaddr);\r\natomic_inc(&dev->counter);\r\nwake_up_interruptible(&dev->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int phantom_get_free(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PHANTOM_MAX_MINORS; i++)\r\nif (phantom_devices[i] == 0)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic int phantom_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct phantom_device *pht;\r\nunsigned int minor;\r\nint retval;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "pci_enable_device failed!\n");\r\ngoto err;\r\n}\r\nminor = phantom_get_free();\r\nif (minor == PHANTOM_MAX_MINORS) {\r\ndev_err(&pdev->dev, "too many devices found!\n");\r\nretval = -EIO;\r\ngoto err_dis;\r\n}\r\nphantom_devices[minor] = 1;\r\nretval = pci_request_regions(pdev, "phantom");\r\nif (retval) {\r\ndev_err(&pdev->dev, "pci_request_regions failed!\n");\r\ngoto err_null;\r\n}\r\nretval = -ENOMEM;\r\npht = kzalloc(sizeof(*pht), GFP_KERNEL);\r\nif (pht == NULL) {\r\ndev_err(&pdev->dev, "unable to allocate device\n");\r\ngoto err_reg;\r\n}\r\npht->caddr = pci_iomap(pdev, 0, 0);\r\nif (pht->caddr == NULL) {\r\ndev_err(&pdev->dev, "can't remap conf space\n");\r\ngoto err_fr;\r\n}\r\npht->iaddr = pci_iomap(pdev, 2, 0);\r\nif (pht->iaddr == NULL) {\r\ndev_err(&pdev->dev, "can't remap input space\n");\r\ngoto err_unmc;\r\n}\r\npht->oaddr = pci_iomap(pdev, 3, 0);\r\nif (pht->oaddr == NULL) {\r\ndev_err(&pdev->dev, "can't remap output space\n");\r\ngoto err_unmi;\r\n}\r\nmutex_init(&pht->open_lock);\r\nspin_lock_init(&pht->regs_lock);\r\ninit_waitqueue_head(&pht->wait);\r\ncdev_init(&pht->cdev, &phantom_file_ops);\r\npht->cdev.owner = THIS_MODULE;\r\niowrite32(0, pht->caddr + PHN_IRQCTL);\r\nioread32(pht->caddr + PHN_IRQCTL);\r\nretval = request_irq(pdev->irq, phantom_isr,\r\nIRQF_SHARED, "phantom", pht);\r\nif (retval) {\r\ndev_err(&pdev->dev, "can't establish ISR\n");\r\ngoto err_unmo;\r\n}\r\nretval = cdev_add(&pht->cdev, MKDEV(phantom_major, minor), 1);\r\nif (retval) {\r\ndev_err(&pdev->dev, "chardev registration failed\n");\r\ngoto err_irq;\r\n}\r\nif (IS_ERR(device_create(phantom_class, &pdev->dev,\r\nMKDEV(phantom_major, minor), NULL,\r\n"phantom%u", minor)))\r\ndev_err(&pdev->dev, "can't create device\n");\r\npci_set_drvdata(pdev, pht);\r\nreturn 0;\r\nerr_irq:\r\nfree_irq(pdev->irq, pht);\r\nerr_unmo:\r\npci_iounmap(pdev, pht->oaddr);\r\nerr_unmi:\r\npci_iounmap(pdev, pht->iaddr);\r\nerr_unmc:\r\npci_iounmap(pdev, pht->caddr);\r\nerr_fr:\r\nkfree(pht);\r\nerr_reg:\r\npci_release_regions(pdev);\r\nerr_null:\r\nphantom_devices[minor] = 0;\r\nerr_dis:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void phantom_remove(struct pci_dev *pdev)\r\n{\r\nstruct phantom_device *pht = pci_get_drvdata(pdev);\r\nunsigned int minor = MINOR(pht->cdev.dev);\r\ndevice_destroy(phantom_class, MKDEV(phantom_major, minor));\r\ncdev_del(&pht->cdev);\r\niowrite32(0, pht->caddr + PHN_IRQCTL);\r\nioread32(pht->caddr + PHN_IRQCTL);\r\nfree_irq(pdev->irq, pht);\r\npci_iounmap(pdev, pht->oaddr);\r\npci_iounmap(pdev, pht->iaddr);\r\npci_iounmap(pdev, pht->caddr);\r\nkfree(pht);\r\npci_release_regions(pdev);\r\nphantom_devices[minor] = 0;\r\npci_disable_device(pdev);\r\n}\r\nstatic int phantom_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct phantom_device *dev = pci_get_drvdata(pdev);\r\niowrite32(0, dev->caddr + PHN_IRQCTL);\r\nioread32(dev->caddr + PHN_IRQCTL);\r\nsynchronize_irq(pdev->irq);\r\nreturn 0;\r\n}\r\nstatic int phantom_resume(struct pci_dev *pdev)\r\n{\r\nstruct phantom_device *dev = pci_get_drvdata(pdev);\r\niowrite32(0, dev->caddr + PHN_IRQCTL);\r\nreturn 0;\r\n}\r\nstatic int __init phantom_init(void)\r\n{\r\nint retval;\r\ndev_t dev;\r\nphantom_class = class_create(THIS_MODULE, "phantom");\r\nif (IS_ERR(phantom_class)) {\r\nretval = PTR_ERR(phantom_class);\r\nprintk(KERN_ERR "phantom: can't register phantom class\n");\r\ngoto err;\r\n}\r\nretval = class_create_file(phantom_class, &class_attr_version.attr);\r\nif (retval) {\r\nprintk(KERN_ERR "phantom: can't create sysfs version file\n");\r\ngoto err_class;\r\n}\r\nretval = alloc_chrdev_region(&dev, 0, PHANTOM_MAX_MINORS, "phantom");\r\nif (retval) {\r\nprintk(KERN_ERR "phantom: can't register character device\n");\r\ngoto err_attr;\r\n}\r\nphantom_major = MAJOR(dev);\r\nretval = pci_register_driver(&phantom_pci_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "phantom: can't register pci driver\n");\r\ngoto err_unchr;\r\n}\r\nprintk(KERN_INFO "Phantom Linux Driver, version " PHANTOM_VERSION ", "\r\n"init OK\n");\r\nreturn 0;\r\nerr_unchr:\r\nunregister_chrdev_region(dev, PHANTOM_MAX_MINORS);\r\nerr_attr:\r\nclass_remove_file(phantom_class, &class_attr_version.attr);\r\nerr_class:\r\nclass_destroy(phantom_class);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void __exit phantom_exit(void)\r\n{\r\npci_unregister_driver(&phantom_pci_driver);\r\nunregister_chrdev_region(MKDEV(phantom_major, 0), PHANTOM_MAX_MINORS);\r\nclass_remove_file(phantom_class, &class_attr_version.attr);\r\nclass_destroy(phantom_class);\r\npr_debug("phantom: module successfully removed\n");\r\n}
