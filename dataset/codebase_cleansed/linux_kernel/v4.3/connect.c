int\r\ncifs_reconnect(struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\nstruct list_head *tmp, *tmp2;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct mid_q_entry *mid_entry;\r\nstruct list_head retry_list;\r\nspin_lock(&GlobalMid_Lock);\r\nif (server->tcpStatus == CifsExiting) {\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn rc;\r\n} else\r\nserver->tcpStatus = CifsNeedReconnect;\r\nspin_unlock(&GlobalMid_Lock);\r\nserver->maxBuf = 0;\r\n#ifdef CONFIG_CIFS_SMB2\r\nserver->max_read = 0;\r\n#endif\r\ncifs_dbg(FYI, "Reconnecting tcp session\n");\r\ncifs_dbg(FYI, "%s: marking sessions and tcons for reconnect\n",\r\n__func__);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &server->smb_ses_list) {\r\nses = list_entry(tmp, struct cifs_ses, smb_ses_list);\r\nses->need_reconnect = true;\r\nses->ipc_tid = 0;\r\nlist_for_each(tmp2, &ses->tcon_list) {\r\ntcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\r\ntcon->need_reconnect = true;\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "%s: tearing down socket\n", __func__);\r\nmutex_lock(&server->srv_mutex);\r\nif (server->ssocket) {\r\ncifs_dbg(FYI, "State: 0x%x Flags: 0x%lx\n",\r\nserver->ssocket->state, server->ssocket->flags);\r\nkernel_sock_shutdown(server->ssocket, SHUT_WR);\r\ncifs_dbg(FYI, "Post shutdown state: 0x%x Flags: 0x%lx\n",\r\nserver->ssocket->state, server->ssocket->flags);\r\nsock_release(server->ssocket);\r\nserver->ssocket = NULL;\r\n}\r\nserver->sequence_number = 0;\r\nserver->session_estab = false;\r\nkfree(server->session_key.response);\r\nserver->session_key.response = NULL;\r\nserver->session_key.len = 0;\r\nserver->lstrp = jiffies;\r\nmutex_unlock(&server->srv_mutex);\r\nINIT_LIST_HEAD(&retry_list);\r\ncifs_dbg(FYI, "%s: moving mids to private list\n", __func__);\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\r\nmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\r\nif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\r\nmid_entry->mid_state = MID_RETRY_NEEDED;\r\nlist_move(&mid_entry->qhead, &retry_list);\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\ncifs_dbg(FYI, "%s: issuing mid callbacks\n", __func__);\r\nlist_for_each_safe(tmp, tmp2, &retry_list) {\r\nmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\r\nlist_del_init(&mid_entry->qhead);\r\nmid_entry->callback(mid_entry);\r\n}\r\ndo {\r\ntry_to_freeze();\r\nmutex_lock(&server->srv_mutex);\r\nrc = generic_ip_connect(server);\r\nif (rc) {\r\ncifs_dbg(FYI, "reconnect error %d\n", rc);\r\nmutex_unlock(&server->srv_mutex);\r\nmsleep(3000);\r\n} else {\r\natomic_inc(&tcpSesReconnectCount);\r\nspin_lock(&GlobalMid_Lock);\r\nif (server->tcpStatus != CifsExiting)\r\nserver->tcpStatus = CifsNeedNegotiate;\r\nspin_unlock(&GlobalMid_Lock);\r\nmutex_unlock(&server->srv_mutex);\r\n}\r\n} while (server->tcpStatus == CifsNeedReconnect);\r\nreturn rc;\r\n}\r\nstatic void\r\ncifs_echo_request(struct work_struct *work)\r\n{\r\nint rc;\r\nstruct TCP_Server_Info *server = container_of(work,\r\nstruct TCP_Server_Info, echo.work);\r\nif (!server->ops->need_neg || server->ops->need_neg(server) ||\r\n(server->ops->can_echo && !server->ops->can_echo(server)) ||\r\ntime_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\r\ngoto requeue_echo;\r\nrc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\r\nif (rc)\r\ncifs_dbg(FYI, "Unable to send echo request to server: %s\n",\r\nserver->hostname);\r\nrequeue_echo:\r\nqueue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);\r\n}\r\nstatic bool\r\nallocate_buffers(struct TCP_Server_Info *server)\r\n{\r\nif (!server->bigbuf) {\r\nserver->bigbuf = (char *)cifs_buf_get();\r\nif (!server->bigbuf) {\r\ncifs_dbg(VFS, "No memory for large SMB response\n");\r\nmsleep(3000);\r\nreturn false;\r\n}\r\n} else if (server->large_buf) {\r\nmemset(server->bigbuf, 0, HEADER_SIZE(server));\r\n}\r\nif (!server->smallbuf) {\r\nserver->smallbuf = (char *)cifs_small_buf_get();\r\nif (!server->smallbuf) {\r\ncifs_dbg(VFS, "No memory for SMB response\n");\r\nmsleep(1000);\r\nreturn false;\r\n}\r\n} else {\r\nmemset(server->smallbuf, 0, HEADER_SIZE(server));\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nserver_unresponsive(struct TCP_Server_Info *server)\r\n{\r\nif (server->tcpStatus == CifsGood &&\r\ntime_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\r\ncifs_dbg(VFS, "Server %s has not responded in %d seconds. Reconnecting...\n",\r\nserver->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\r\ncifs_reconnect(server);\r\nwake_up(&server->response_q);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned int\r\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\r\nsize_t bytes)\r\n{\r\nsize_t base = 0;\r\nwhile (bytes || !iov->iov_len) {\r\nint copy = min(bytes, iov->iov_len);\r\nbytes -= copy;\r\nbase += copy;\r\nif (iov->iov_len == base) {\r\niov++;\r\nnr_segs--;\r\nbase = 0;\r\n}\r\n}\r\nmemcpy(new, iov, sizeof(*iov) * nr_segs);\r\nnew->iov_base += base;\r\nnew->iov_len -= base;\r\nreturn nr_segs;\r\n}\r\nstatic struct kvec *\r\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\r\n{\r\nstruct kvec *new_iov;\r\nif (server->iov && nr_segs <= server->nr_iov)\r\nreturn server->iov;\r\nnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\r\nif (new_iov) {\r\nkfree(server->iov);\r\nserver->iov = new_iov;\r\nserver->nr_iov = nr_segs;\r\n}\r\nreturn new_iov;\r\n}\r\nint\r\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\r\nunsigned int nr_segs, unsigned int to_read)\r\n{\r\nint length = 0;\r\nint total_read;\r\nunsigned int segs;\r\nstruct msghdr smb_msg;\r\nstruct kvec *iov;\r\niov = get_server_iovec(server, nr_segs);\r\nif (!iov)\r\nreturn -ENOMEM;\r\nsmb_msg.msg_control = NULL;\r\nsmb_msg.msg_controllen = 0;\r\nfor (total_read = 0; to_read; total_read += length, to_read -= length) {\r\ntry_to_freeze();\r\nif (server_unresponsive(server)) {\r\ntotal_read = -ECONNABORTED;\r\nbreak;\r\n}\r\nsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\r\nlength = kernel_recvmsg(server->ssocket, &smb_msg,\r\niov, segs, to_read, 0);\r\nif (server->tcpStatus == CifsExiting) {\r\ntotal_read = -ESHUTDOWN;\r\nbreak;\r\n} else if (server->tcpStatus == CifsNeedReconnect) {\r\ncifs_reconnect(server);\r\ntotal_read = -ECONNABORTED;\r\nbreak;\r\n} else if (length == -ERESTARTSYS ||\r\nlength == -EAGAIN ||\r\nlength == -EINTR) {\r\nusleep_range(1000, 2000);\r\nlength = 0;\r\ncontinue;\r\n} else if (length <= 0) {\r\ncifs_dbg(FYI, "Received no data or error: expecting %d\n"\r\n"got %d", to_read, length);\r\ncifs_reconnect(server);\r\ntotal_read = -ECONNABORTED;\r\nbreak;\r\n}\r\n}\r\nreturn total_read;\r\n}\r\nint\r\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\r\nunsigned int to_read)\r\n{\r\nstruct kvec iov;\r\niov.iov_base = buf;\r\niov.iov_len = to_read;\r\nreturn cifs_readv_from_socket(server, &iov, 1, to_read);\r\n}\r\nstatic bool\r\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\r\n{\r\nswitch (type) {\r\ncase RFC1002_SESSION_MESSAGE:\r\nreturn true;\r\ncase RFC1002_SESSION_KEEP_ALIVE:\r\ncifs_dbg(FYI, "RFC 1002 session keep alive\n");\r\nbreak;\r\ncase RFC1002_POSITIVE_SESSION_RESPONSE:\r\ncifs_dbg(FYI, "RFC 1002 positive session response\n");\r\nbreak;\r\ncase RFC1002_NEGATIVE_SESSION_RESPONSE:\r\ncifs_dbg(FYI, "RFC 1002 negative session response\n");\r\nmsleep(1000);\r\ncifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\r\ncifs_reconnect(server);\r\nwake_up(&server->response_q);\r\nbreak;\r\ndefault:\r\ncifs_dbg(VFS, "RFC 1002 unknown response type 0x%x\n", type);\r\ncifs_reconnect(server);\r\n}\r\nreturn false;\r\n}\r\nvoid\r\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\r\n{\r\n#ifdef CONFIG_CIFS_STATS2\r\nmid->when_received = jiffies;\r\n#endif\r\nspin_lock(&GlobalMid_Lock);\r\nif (!malformed)\r\nmid->mid_state = MID_RESPONSE_RECEIVED;\r\nelse\r\nmid->mid_state = MID_RESPONSE_MALFORMED;\r\nlist_del_init(&mid->qhead);\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nstatic void\r\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\r\nchar *buf, int malformed)\r\n{\r\nif (server->ops->check_trans2 &&\r\nserver->ops->check_trans2(mid, server, buf, malformed))\r\nreturn;\r\nmid->resp_buf = buf;\r\nmid->large_buf = server->large_buf;\r\nif (!mid->multiRsp) {\r\nif (server->large_buf)\r\nserver->bigbuf = NULL;\r\nelse\r\nserver->smallbuf = NULL;\r\n}\r\ndequeue_mid(mid, malformed);\r\n}\r\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\r\n{\r\nint length;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_del_init(&server->tcp_ses_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nspin_lock(&GlobalMid_Lock);\r\nserver->tcpStatus = CifsExiting;\r\nspin_unlock(&GlobalMid_Lock);\r\nwake_up_all(&server->response_q);\r\nspin_lock(&server->req_lock);\r\nif (server->credits <= 0)\r\nserver->credits = 1;\r\nspin_unlock(&server->req_lock);\r\nwake_up_all(&server->request_q);\r\nmsleep(125);\r\nif (server->ssocket) {\r\nsock_release(server->ssocket);\r\nserver->ssocket = NULL;\r\n}\r\nif (!list_empty(&server->pending_mid_q)) {\r\nstruct list_head dispose_list;\r\nstruct mid_q_entry *mid_entry;\r\nstruct list_head *tmp, *tmp2;\r\nINIT_LIST_HEAD(&dispose_list);\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\r\nmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\r\ncifs_dbg(FYI, "Clearing mid 0x%llx\n", mid_entry->mid);\r\nmid_entry->mid_state = MID_SHUTDOWN;\r\nlist_move(&mid_entry->qhead, &dispose_list);\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\nlist_for_each_safe(tmp, tmp2, &dispose_list) {\r\nmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\r\ncifs_dbg(FYI, "Callback mid 0x%llx\n", mid_entry->mid);\r\nlist_del_init(&mid_entry->qhead);\r\nmid_entry->callback(mid_entry);\r\n}\r\nmsleep(125);\r\n}\r\nif (!list_empty(&server->pending_mid_q)) {\r\ncifs_dbg(FYI, "Wait for exit from demultiplex thread\n");\r\nmsleep(46000);\r\n}\r\nkfree(server->hostname);\r\nkfree(server->iov);\r\nkfree(server);\r\nlength = atomic_dec_return(&tcpSesAllocCount);\r\nif (length > 0)\r\nmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\r\n}\r\nstatic int\r\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\r\n{\r\nint length;\r\nchar *buf = server->smallbuf;\r\nunsigned int pdu_length = get_rfc1002_length(buf);\r\nif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\r\ncifs_dbg(VFS, "SMB response too long (%u bytes)\n", pdu_length);\r\ncifs_reconnect(server);\r\nwake_up(&server->response_q);\r\nreturn -ECONNABORTED;\r\n}\r\nif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\r\nserver->large_buf = true;\r\nmemcpy(server->bigbuf, buf, server->total_read);\r\nbuf = server->bigbuf;\r\n}\r\nlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\r\npdu_length - HEADER_SIZE(server) + 1 + 4);\r\nif (length < 0)\r\nreturn length;\r\nserver->total_read += length;\r\ndump_smb(buf, server->total_read);\r\nlength = server->ops->check_message(buf, server->total_read);\r\nif (length != 0)\r\ncifs_dump_mem("Bad SMB: ", buf,\r\nmin_t(unsigned int, server->total_read, 48));\r\nif (server->ops->is_status_pending &&\r\nserver->ops->is_status_pending(buf, server, length))\r\nreturn -1;\r\nif (!mid)\r\nreturn length;\r\nhandle_mid(mid, server, buf, length);\r\nreturn 0;\r\n}\r\nstatic int\r\ncifs_demultiplex_thread(void *p)\r\n{\r\nint length;\r\nstruct TCP_Server_Info *server = p;\r\nunsigned int pdu_length;\r\nchar *buf = NULL;\r\nstruct task_struct *task_to_wake = NULL;\r\nstruct mid_q_entry *mid_entry;\r\ncurrent->flags |= PF_MEMALLOC;\r\ncifs_dbg(FYI, "Demultiplex PID: %d\n", task_pid_nr(current));\r\nlength = atomic_inc_return(&tcpSesAllocCount);\r\nif (length > 1)\r\nmempool_resize(cifs_req_poolp, length + cifs_min_rcv);\r\nset_freezable();\r\nwhile (server->tcpStatus != CifsExiting) {\r\nif (try_to_freeze())\r\ncontinue;\r\nif (!allocate_buffers(server))\r\ncontinue;\r\nserver->large_buf = false;\r\nbuf = server->smallbuf;\r\npdu_length = 4;\r\nlength = cifs_read_from_socket(server, buf, pdu_length);\r\nif (length < 0)\r\ncontinue;\r\nserver->total_read = length;\r\npdu_length = get_rfc1002_length(buf);\r\ncifs_dbg(FYI, "RFC1002 header 0x%x\n", pdu_length);\r\nif (!is_smb_response(server, buf[0]))\r\ncontinue;\r\nif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\r\ncifs_dbg(VFS, "SMB response too short (%u bytes)\n",\r\npdu_length);\r\ncifs_reconnect(server);\r\nwake_up(&server->response_q);\r\ncontinue;\r\n}\r\nlength = cifs_read_from_socket(server, buf + 4,\r\nHEADER_SIZE(server) - 1 - 4);\r\nif (length < 0)\r\ncontinue;\r\nserver->total_read += length;\r\nmid_entry = server->ops->find_mid(server, buf);\r\nif (!mid_entry || !mid_entry->receive)\r\nlength = standard_receive3(server, mid_entry);\r\nelse\r\nlength = mid_entry->receive(server, mid_entry);\r\nif (length < 0)\r\ncontinue;\r\nif (server->large_buf)\r\nbuf = server->bigbuf;\r\nserver->lstrp = jiffies;\r\nif (mid_entry != NULL) {\r\nif (!mid_entry->multiRsp || mid_entry->multiEnd)\r\nmid_entry->callback(mid_entry);\r\n} else if (!server->ops->is_oplock_break ||\r\n!server->ops->is_oplock_break(buf, server)) {\r\ncifs_dbg(VFS, "No task to wake, unknown frame received! NumMids %d\n",\r\natomic_read(&midCount));\r\ncifs_dump_mem("Received Data is: ", buf,\r\nHEADER_SIZE(server));\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nif (server->ops->dump_detail)\r\nserver->ops->dump_detail(buf);\r\ncifs_dump_mids(server);\r\n#endif\r\n}\r\n}\r\ncifs_buf_release(server->bigbuf);\r\nif (server->smallbuf)\r\ncifs_small_buf_release(server->smallbuf);\r\ntask_to_wake = xchg(&server->tsk, NULL);\r\nclean_demultiplex_info(server);\r\nif (!task_to_wake) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!signal_pending(current)) {\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\n}\r\nmodule_put_and_exit(0);\r\n}\r\nstatic char *\r\nextract_hostname(const char *unc)\r\n{\r\nconst char *src;\r\nchar *dst, *delim;\r\nunsigned int len;\r\nsrc = unc + 2;\r\ndelim = strchr(src, '\\');\r\nif (!delim)\r\nreturn ERR_PTR(-EINVAL);\r\nlen = delim - src;\r\ndst = kmalloc((len + 1), GFP_KERNEL);\r\nif (dst == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(dst, src, len);\r\ndst[len] = '\0';\r\nreturn dst;\r\n}\r\nstatic int get_option_ul(substring_t args[], unsigned long *option)\r\n{\r\nint rc;\r\nchar *string;\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\nreturn -ENOMEM;\r\nrc = kstrtoul(string, 0, option);\r\nkfree(string);\r\nreturn rc;\r\n}\r\nstatic int get_option_uid(substring_t args[], kuid_t *result)\r\n{\r\nunsigned long value;\r\nkuid_t uid;\r\nint rc;\r\nrc = get_option_ul(args, &value);\r\nif (rc)\r\nreturn rc;\r\nuid = make_kuid(current_user_ns(), value);\r\nif (!uid_valid(uid))\r\nreturn -EINVAL;\r\n*result = uid;\r\nreturn 0;\r\n}\r\nstatic int get_option_gid(substring_t args[], kgid_t *result)\r\n{\r\nunsigned long value;\r\nkgid_t gid;\r\nint rc;\r\nrc = get_option_ul(args, &value);\r\nif (rc)\r\nreturn rc;\r\ngid = make_kgid(current_user_ns(), value);\r\nif (!gid_valid(gid))\r\nreturn -EINVAL;\r\n*result = gid;\r\nreturn 0;\r\n}\r\nstatic int cifs_parse_security_flavors(char *value,\r\nstruct smb_vol *vol)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nvol->sectype = Unspecified;\r\nvol->sign = false;\r\nswitch (match_token(value, cifs_secflavor_tokens, args)) {\r\ncase Opt_sec_krb5p:\r\ncifs_dbg(VFS, "sec=krb5p is not supported!\n");\r\nreturn 1;\r\ncase Opt_sec_krb5i:\r\nvol->sign = true;\r\ncase Opt_sec_krb5:\r\nvol->sectype = Kerberos;\r\nbreak;\r\ncase Opt_sec_ntlmsspi:\r\nvol->sign = true;\r\ncase Opt_sec_ntlmssp:\r\nvol->sectype = RawNTLMSSP;\r\nbreak;\r\ncase Opt_sec_ntlmi:\r\nvol->sign = true;\r\ncase Opt_ntlm:\r\nvol->sectype = NTLM;\r\nbreak;\r\ncase Opt_sec_ntlmv2i:\r\nvol->sign = true;\r\ncase Opt_sec_ntlmv2:\r\nvol->sectype = NTLMv2;\r\nbreak;\r\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\r\ncase Opt_sec_lanman:\r\nvol->sectype = LANMAN;\r\nbreak;\r\n#endif\r\ncase Opt_sec_none:\r\nvol->nullauth = 1;\r\nbreak;\r\ndefault:\r\ncifs_dbg(VFS, "bad security option: %s\n", value);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\r\ncase Opt_cache_loose:\r\nvol->direct_io = false;\r\nvol->strict_io = false;\r\nbreak;\r\ncase Opt_cache_strict:\r\nvol->direct_io = false;\r\nvol->strict_io = true;\r\nbreak;\r\ncase Opt_cache_none:\r\nvol->direct_io = true;\r\nvol->strict_io = false;\r\nbreak;\r\ndefault:\r\ncifs_dbg(VFS, "bad cache= option: %s\n", value);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nswitch (match_token(value, cifs_smb_version_tokens, args)) {\r\ncase Smb_1:\r\nvol->ops = &smb1_operations;\r\nvol->vals = &smb1_values;\r\nbreak;\r\n#ifdef CONFIG_CIFS_SMB2\r\ncase Smb_20:\r\nvol->ops = &smb20_operations;\r\nvol->vals = &smb20_values;\r\nbreak;\r\ncase Smb_21:\r\nvol->ops = &smb21_operations;\r\nvol->vals = &smb21_values;\r\nbreak;\r\ncase Smb_30:\r\nvol->ops = &smb30_operations;\r\nvol->vals = &smb30_values;\r\nbreak;\r\ncase Smb_302:\r\nvol->ops = &smb30_operations;\r\nvol->vals = &smb302_values;\r\nbreak;\r\n#ifdef CONFIG_CIFS_SMB311\r\ncase Smb_311:\r\nvol->ops = &smb311_operations;\r\nvol->vals = &smb311_values;\r\nbreak;\r\n#endif\r\n#endif\r\ndefault:\r\ncifs_dbg(VFS, "Unknown vers= option specified: %s\n", value);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\r\n{\r\nchar *pos;\r\nconst char *delims = "/\\";\r\nsize_t len;\r\nlen = strspn(devname, delims);\r\nif (len != 2)\r\nreturn -EINVAL;\r\npos = strpbrk(devname + 2, delims);\r\nif (!pos)\r\nreturn -EINVAL;\r\n++pos;\r\nlen = strcspn(pos, delims);\r\npos += len;\r\nvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\r\nif (!vol->UNC)\r\nreturn -ENOMEM;\r\nconvert_delimiter(vol->UNC, '\\');\r\nif (!*pos++ || !*pos)\r\nreturn 0;\r\nvol->prepath = kstrdup(pos, GFP_KERNEL);\r\nif (!vol->prepath)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int\r\ncifs_parse_mount_options(const char *mountdata, const char *devname,\r\nstruct smb_vol *vol)\r\n{\r\nchar *data, *end;\r\nchar *mountdata_copy = NULL, *options;\r\nunsigned int temp_len, i, j;\r\nchar separator[2];\r\nshort int override_uid = -1;\r\nshort int override_gid = -1;\r\nbool uid_specified = false;\r\nbool gid_specified = false;\r\nbool sloppy = false;\r\nchar *invalid = NULL;\r\nchar *nodename = utsname()->nodename;\r\nchar *string = NULL;\r\nchar *tmp_end, *value;\r\nchar delim;\r\nbool got_ip = false;\r\nunsigned short port = 0;\r\nstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\r\nseparator[0] = ',';\r\nseparator[1] = 0;\r\ndelim = separator[0];\r\nmemset(vol, 0, sizeof(*vol));\r\nmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\r\nfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\r\nvol->source_rfc1001_name[i] = toupper(nodename[i]);\r\nvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\r\nvol->target_rfc1001_name[0] = 0;\r\nvol->cred_uid = current_uid();\r\nvol->linux_uid = current_uid();\r\nvol->linux_gid = current_gid();\r\nvol->remap = true;\r\nvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\r\nvol->posix_paths = 1;\r\nvol->server_ino = 1;\r\nvol->strict_io = true;\r\nvol->actimeo = CIFS_DEF_ACTIMEO;\r\nvol->ops = &smb1_operations;\r\nvol->vals = &smb1_values;\r\nif (!mountdata)\r\ngoto cifs_parse_mount_err;\r\nmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\r\nif (!mountdata_copy)\r\ngoto cifs_parse_mount_err;\r\noptions = mountdata_copy;\r\nend = options + strlen(options);\r\nif (strncmp(options, "sep=", 4) == 0) {\r\nif (options[4] != 0) {\r\nseparator[0] = options[4];\r\noptions += 5;\r\n} else {\r\ncifs_dbg(FYI, "Null separator not allowed\n");\r\n}\r\n}\r\nvol->backupuid_specified = false;\r\nvol->backupgid_specified = false;\r\nswitch (cifs_parse_devname(devname, vol)) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMEM:\r\ncifs_dbg(VFS, "Unable to allocate memory for devname.\n");\r\ngoto cifs_parse_mount_err;\r\ncase -EINVAL:\r\ncifs_dbg(VFS, "Malformed UNC in devname.\n");\r\ngoto cifs_parse_mount_err;\r\ndefault:\r\ncifs_dbg(VFS, "Unknown error parsing devname.\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nwhile ((data = strsep(&options, separator)) != NULL) {\r\nsubstring_t args[MAX_OPT_ARGS];\r\nunsigned long option;\r\nint token;\r\nif (!*data)\r\ncontinue;\r\ntoken = match_token(data, cifs_mount_option_tokens, args);\r\nswitch (token) {\r\ncase Opt_ignore:\r\nbreak;\r\ncase Opt_user_xattr:\r\nvol->no_xattr = 0;\r\nbreak;\r\ncase Opt_nouser_xattr:\r\nvol->no_xattr = 1;\r\nbreak;\r\ncase Opt_forceuid:\r\noverride_uid = 1;\r\nbreak;\r\ncase Opt_noforceuid:\r\noverride_uid = 0;\r\nbreak;\r\ncase Opt_forcegid:\r\noverride_gid = 1;\r\nbreak;\r\ncase Opt_noforcegid:\r\noverride_gid = 0;\r\nbreak;\r\ncase Opt_noblocksend:\r\nvol->noblocksnd = 1;\r\nbreak;\r\ncase Opt_noautotune:\r\nvol->noautotune = 1;\r\nbreak;\r\ncase Opt_hard:\r\nvol->retry = 1;\r\nbreak;\r\ncase Opt_soft:\r\nvol->retry = 0;\r\nbreak;\r\ncase Opt_perm:\r\nvol->noperm = 0;\r\nbreak;\r\ncase Opt_noperm:\r\nvol->noperm = 1;\r\nbreak;\r\ncase Opt_mapchars:\r\nvol->sfu_remap = true;\r\nvol->remap = false;\r\nbreak;\r\ncase Opt_nomapchars:\r\nvol->sfu_remap = false;\r\nbreak;\r\ncase Opt_mapposix:\r\nvol->remap = true;\r\nvol->sfu_remap = false;\r\nbreak;\r\ncase Opt_nomapposix:\r\nvol->remap = false;\r\nbreak;\r\ncase Opt_sfu:\r\nvol->sfu_emul = 1;\r\nbreak;\r\ncase Opt_nosfu:\r\nvol->sfu_emul = 0;\r\nbreak;\r\ncase Opt_nodfs:\r\nvol->nodfs = 1;\r\nbreak;\r\ncase Opt_posixpaths:\r\nvol->posix_paths = 1;\r\nbreak;\r\ncase Opt_noposixpaths:\r\nvol->posix_paths = 0;\r\nbreak;\r\ncase Opt_nounix:\r\nvol->no_linux_ext = 1;\r\nbreak;\r\ncase Opt_nocase:\r\nvol->nocase = 1;\r\nbreak;\r\ncase Opt_brl:\r\nvol->nobrl = 0;\r\nbreak;\r\ncase Opt_nobrl:\r\nvol->nobrl = 1;\r\nif (vol->file_mode ==\r\n(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\r\nvol->file_mode = S_IALLUGO;\r\nbreak;\r\ncase Opt_forcemandatorylock:\r\nvol->mand_lock = 1;\r\nbreak;\r\ncase Opt_setuids:\r\nvol->setuids = 1;\r\nbreak;\r\ncase Opt_nosetuids:\r\nvol->setuids = 0;\r\nbreak;\r\ncase Opt_dynperm:\r\nvol->dynperm = true;\r\nbreak;\r\ncase Opt_nodynperm:\r\nvol->dynperm = false;\r\nbreak;\r\ncase Opt_nohard:\r\nvol->retry = 0;\r\nbreak;\r\ncase Opt_nosoft:\r\nvol->retry = 1;\r\nbreak;\r\ncase Opt_nointr:\r\nvol->intr = 0;\r\nbreak;\r\ncase Opt_intr:\r\nvol->intr = 1;\r\nbreak;\r\ncase Opt_nostrictsync:\r\nvol->nostrictsync = 1;\r\nbreak;\r\ncase Opt_strictsync:\r\nvol->nostrictsync = 0;\r\nbreak;\r\ncase Opt_serverino:\r\nvol->server_ino = 1;\r\nbreak;\r\ncase Opt_noserverino:\r\nvol->server_ino = 0;\r\nbreak;\r\ncase Opt_rwpidforward:\r\nvol->rwpidforward = 1;\r\nbreak;\r\ncase Opt_cifsacl:\r\nvol->cifs_acl = 1;\r\nbreak;\r\ncase Opt_nocifsacl:\r\nvol->cifs_acl = 0;\r\nbreak;\r\ncase Opt_acl:\r\nvol->no_psx_acl = 0;\r\nbreak;\r\ncase Opt_noacl:\r\nvol->no_psx_acl = 1;\r\nbreak;\r\ncase Opt_locallease:\r\nvol->local_lease = 1;\r\nbreak;\r\ncase Opt_sign:\r\nvol->sign = true;\r\nbreak;\r\ncase Opt_seal:\r\nvol->seal = 1;\r\nbreak;\r\ncase Opt_noac:\r\npr_warn("CIFS: Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n");\r\nbreak;\r\ncase Opt_fsc:\r\n#ifndef CONFIG_CIFS_FSCACHE\r\ncifs_dbg(VFS, "FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\n");\r\ngoto cifs_parse_mount_err;\r\n#endif\r\nvol->fsc = true;\r\nbreak;\r\ncase Opt_mfsymlinks:\r\nvol->mfsymlinks = true;\r\nbreak;\r\ncase Opt_multiuser:\r\nvol->multiuser = true;\r\nbreak;\r\ncase Opt_sloppy:\r\nsloppy = true;\r\nbreak;\r\ncase Opt_nosharesock:\r\nvol->nosharesock = true;\r\nbreak;\r\ncase Opt_backupuid:\r\nif (get_option_uid(args, &vol->backupuid)) {\r\ncifs_dbg(VFS, "%s: Invalid backupuid value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->backupuid_specified = true;\r\nbreak;\r\ncase Opt_backupgid:\r\nif (get_option_gid(args, &vol->backupgid)) {\r\ncifs_dbg(VFS, "%s: Invalid backupgid value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->backupgid_specified = true;\r\nbreak;\r\ncase Opt_uid:\r\nif (get_option_uid(args, &vol->linux_uid)) {\r\ncifs_dbg(VFS, "%s: Invalid uid value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nuid_specified = true;\r\nbreak;\r\ncase Opt_cruid:\r\nif (get_option_uid(args, &vol->cred_uid)) {\r\ncifs_dbg(VFS, "%s: Invalid cruid value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nbreak;\r\ncase Opt_gid:\r\nif (get_option_gid(args, &vol->linux_gid)) {\r\ncifs_dbg(VFS, "%s: Invalid gid value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\ngid_specified = true;\r\nbreak;\r\ncase Opt_file_mode:\r\nif (get_option_ul(args, &option)) {\r\ncifs_dbg(VFS, "%s: Invalid file_mode value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->file_mode = option;\r\nbreak;\r\ncase Opt_dirmode:\r\nif (get_option_ul(args, &option)) {\r\ncifs_dbg(VFS, "%s: Invalid dir_mode value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->dir_mode = option;\r\nbreak;\r\ncase Opt_port:\r\nif (get_option_ul(args, &option) ||\r\noption > USHRT_MAX) {\r\ncifs_dbg(VFS, "%s: Invalid port value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nport = (unsigned short)option;\r\nbreak;\r\ncase Opt_rsize:\r\nif (get_option_ul(args, &option)) {\r\ncifs_dbg(VFS, "%s: Invalid rsize value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->rsize = option;\r\nbreak;\r\ncase Opt_wsize:\r\nif (get_option_ul(args, &option)) {\r\ncifs_dbg(VFS, "%s: Invalid wsize value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->wsize = option;\r\nbreak;\r\ncase Opt_actimeo:\r\nif (get_option_ul(args, &option)) {\r\ncifs_dbg(VFS, "%s: Invalid actimeo value\n",\r\n__func__);\r\ngoto cifs_parse_mount_err;\r\n}\r\nvol->actimeo = HZ * option;\r\nif (vol->actimeo > CIFS_MAX_ACTIMEO) {\r\ncifs_dbg(VFS, "attribute cache timeout too large\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nbreak;\r\ncase Opt_blank_user:\r\nvol->nullauth = 1;\r\nvol->username = NULL;\r\nbreak;\r\ncase Opt_user:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (strnlen(string, CIFS_MAX_USERNAME_LEN) >\r\nCIFS_MAX_USERNAME_LEN) {\r\npr_warn("CIFS: username too long\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nkfree(vol->username);\r\nvol->username = kstrdup(string, GFP_KERNEL);\r\nif (!vol->username)\r\ngoto cifs_parse_mount_err;\r\nbreak;\r\ncase Opt_blank_pass:\r\ntmp_end = strchr(data, '=');\r\ntmp_end++;\r\nif (!(tmp_end < end && tmp_end[1] == delim)) {\r\nkfree(vol->password);\r\nvol->password = NULL;\r\nbreak;\r\n}\r\ncase Opt_pass:\r\nvalue = strchr(data, '=');\r\nvalue++;\r\ntmp_end = (char *) value + strlen(value);\r\nif (tmp_end < end && tmp_end[1] == delim) {\r\ntmp_end[0] = delim;\r\nwhile ((tmp_end = strchr(tmp_end, delim))\r\n!= NULL && (tmp_end[1] == delim)) {\r\ntmp_end = (char *) &tmp_end[2];\r\n}\r\nif (tmp_end) {\r\ntmp_end[0] = '\0';\r\noptions = (char *) &tmp_end[1];\r\n} else\r\noptions = end;\r\n}\r\nkfree(vol->password);\r\ntemp_len = strlen(value);\r\nvol->password = kzalloc(temp_len+1, GFP_KERNEL);\r\nif (vol->password == NULL) {\r\npr_warn("CIFS: no memory for password\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nfor (i = 0, j = 0; i < temp_len; i++, j++) {\r\nvol->password[j] = value[i];\r\nif ((value[i] == delim) &&\r\nvalue[i+1] == delim)\r\ni++;\r\n}\r\nvol->password[j] = '\0';\r\nbreak;\r\ncase Opt_blank_ip:\r\ngot_ip = false;\r\nbreak;\r\ncase Opt_ip:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (!cifs_convert_address(dstaddr, string,\r\nstrlen(string))) {\r\npr_err("CIFS: bad ip= option (%s).\n", string);\r\ngoto cifs_parse_mount_err;\r\n}\r\ngot_ip = true;\r\nbreak;\r\ncase Opt_domain:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (strnlen(string, CIFS_MAX_DOMAINNAME_LEN)\r\n== CIFS_MAX_DOMAINNAME_LEN) {\r\npr_warn("CIFS: domain name too long\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nkfree(vol->domainname);\r\nvol->domainname = kstrdup(string, GFP_KERNEL);\r\nif (!vol->domainname) {\r\npr_warn("CIFS: no memory for domainname\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\ncifs_dbg(FYI, "Domain name set\n");\r\nbreak;\r\ncase Opt_srcaddr:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (!cifs_convert_address(\r\n(struct sockaddr *)&vol->srcaddr,\r\nstring, strlen(string))) {\r\npr_warn("CIFS: Could not parse srcaddr: %s\n",\r\nstring);\r\ngoto cifs_parse_mount_err;\r\n}\r\nbreak;\r\ncase Opt_iocharset:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (strnlen(string, 1024) >= 65) {\r\npr_warn("CIFS: iocharset name too long.\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nif (strncasecmp(string, "default", 7) != 0) {\r\nkfree(vol->iocharset);\r\nvol->iocharset = kstrdup(string,\r\nGFP_KERNEL);\r\nif (!vol->iocharset) {\r\npr_warn("CIFS: no memory for charset\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\n}\r\ncifs_dbg(FYI, "iocharset set to %s\n", string);\r\nbreak;\r\ncase Opt_netbiosname:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nmemset(vol->source_rfc1001_name, 0x20,\r\nRFC1001_NAME_LEN);\r\nfor (i = 0; i < RFC1001_NAME_LEN; i++) {\r\nif (string[i] == 0)\r\nbreak;\r\nvol->source_rfc1001_name[i] = string[i];\r\n}\r\nif (i == RFC1001_NAME_LEN && string[i] != 0)\r\npr_warn("CIFS: netbiosname longer than 15 truncated.\n");\r\nbreak;\r\ncase Opt_servern:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nmemset(vol->target_rfc1001_name, 0x20,\r\nRFC1001_NAME_LEN_WITH_NULL);\r\nfor (i = 0; i < 15; i++) {\r\nif (string[i] == 0)\r\nbreak;\r\nvol->target_rfc1001_name[i] = string[i];\r\n}\r\nif (i == RFC1001_NAME_LEN && string[i] != 0)\r\npr_warn("CIFS: server netbiosname longer than 15 truncated.\n");\r\nbreak;\r\ncase Opt_ver:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (strncasecmp(string, "1", 1) == 0) {\r\nbreak;\r\n}\r\npr_warn("CIFS: Invalid version specified\n");\r\ngoto cifs_parse_mount_err;\r\ncase Opt_vers:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (cifs_parse_smb_version(string, vol) != 0)\r\ngoto cifs_parse_mount_err;\r\nbreak;\r\ncase Opt_sec:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (cifs_parse_security_flavors(string, vol) != 0)\r\ngoto cifs_parse_mount_err;\r\nbreak;\r\ncase Opt_cache:\r\nstring = match_strdup(args);\r\nif (string == NULL)\r\ngoto out_nomem;\r\nif (cifs_parse_cache_flavor(string, vol) != 0)\r\ngoto cifs_parse_mount_err;\r\nbreak;\r\ndefault:\r\nif (!invalid)\r\ninvalid = data;\r\nbreak;\r\n}\r\nkfree(string);\r\nstring = NULL;\r\n}\r\nif (!sloppy && invalid) {\r\npr_err("CIFS: Unknown mount option \"%s\"\n", invalid);\r\ngoto cifs_parse_mount_err;\r\n}\r\n#ifndef CONFIG_KEYS\r\nif (vol->multiuser) {\r\ncifs_dbg(VFS, "Multiuser mounts require kernels with CONFIG_KEYS enabled\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\n#endif\r\nif (!vol->UNC) {\r\ncifs_dbg(VFS, "CIFS mount error: No usable UNC path provided in device string!\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nif (!strchr(vol->UNC + 3, '\\')) {\r\ncifs_dbg(VFS, "Malformed UNC. Unable to find share name.\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\nif (!got_ip) {\r\nif (!cifs_convert_address(dstaddr, &vol->UNC[2],\r\nstrlen(&vol->UNC[2]))) {\r\npr_err("Unable to determine destination address.\n");\r\ngoto cifs_parse_mount_err;\r\n}\r\n}\r\ncifs_set_port(dstaddr, port);\r\nif (uid_specified)\r\nvol->override_uid = override_uid;\r\nelse if (override_uid == 1)\r\npr_notice("CIFS: ignoring forceuid mount option specified with no uid= option.\n");\r\nif (gid_specified)\r\nvol->override_gid = override_gid;\r\nelse if (override_gid == 1)\r\npr_notice("CIFS: ignoring forcegid mount option specified with no gid= option.\n");\r\nkfree(mountdata_copy);\r\nreturn 0;\r\nout_nomem:\r\npr_warn("Could not allocate temporary buffer\n");\r\ncifs_parse_mount_err:\r\nkfree(string);\r\nkfree(mountdata_copy);\r\nreturn 1;\r\n}\r\nstatic bool\r\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\r\n{\r\nswitch (srcaddr->sa_family) {\r\ncase AF_UNSPEC:\r\nreturn (rhs->sa_family == AF_UNSPEC);\r\ncase AF_INET: {\r\nstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\r\nstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\r\nreturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\r\n}\r\ncase AF_INET6: {\r\nstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\r\nstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\r\nreturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\r\n}\r\ndefault:\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\r\n{\r\n__be16 port, *sport;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\r\nport = ((struct sockaddr_in *) addr)->sin_port;\r\nbreak;\r\ncase AF_INET6:\r\nsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\r\nport = ((struct sockaddr_in6 *) addr)->sin6_port;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\nif (!port) {\r\nport = htons(CIFS_PORT);\r\nif (port == *sport)\r\nreturn true;\r\nport = htons(RFC1001_PORT);\r\n}\r\nreturn port == *sport;\r\n}\r\nstatic bool\r\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\r\nstruct sockaddr *srcaddr)\r\n{\r\nswitch (addr->sa_family) {\r\ncase AF_INET: {\r\nstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\r\nstruct sockaddr_in *srv_addr4 =\r\n(struct sockaddr_in *)&server->dstaddr;\r\nif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\r\nreturn false;\r\nbreak;\r\n}\r\ncase AF_INET6: {\r\nstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\r\nstruct sockaddr_in6 *srv_addr6 =\r\n(struct sockaddr_in6 *)&server->dstaddr;\r\nif (!ipv6_addr_equal(&addr6->sin6_addr,\r\n&srv_addr6->sin6_addr))\r\nreturn false;\r\nif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\r\nreturn false;\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\nif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\r\n{\r\nif (select_sectype(server, vol->sectype) == Unspecified)\r\nreturn false;\r\nif (vol->sign && !server->sign)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\r\n{\r\nstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\r\nif (vol->nosharesock)\r\nreturn 0;\r\nif ((server->vals != vol->vals) || (server->ops != vol->ops))\r\nreturn 0;\r\nif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\r\nreturn 0;\r\nif (!match_address(server, addr,\r\n(struct sockaddr *)&vol->srcaddr))\r\nreturn 0;\r\nif (!match_port(server, addr))\r\nreturn 0;\r\nif (!match_security(server, vol))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct TCP_Server_Info *\r\ncifs_find_tcp_session(struct smb_vol *vol)\r\n{\r\nstruct TCP_Server_Info *server;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\r\nif (!match_server(server, vol))\r\ncontinue;\r\n++server->srv_count;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "Existing tcp session with server found\n");\r\nreturn server;\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\ncifs_put_tcp_session(struct TCP_Server_Info *server)\r\n{\r\nstruct task_struct *task;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif (--server->srv_count > 0) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn;\r\n}\r\nput_net(cifs_net_ns(server));\r\nlist_del_init(&server->tcp_ses_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncancel_delayed_work_sync(&server->echo);\r\nspin_lock(&GlobalMid_Lock);\r\nserver->tcpStatus = CifsExiting;\r\nspin_unlock(&GlobalMid_Lock);\r\ncifs_crypto_shash_release(server);\r\ncifs_fscache_release_client_cookie(server);\r\nkfree(server->session_key.response);\r\nserver->session_key.response = NULL;\r\nserver->session_key.len = 0;\r\ntask = xchg(&server->tsk, NULL);\r\nif (task)\r\nforce_sig(SIGKILL, task);\r\n}\r\nstatic struct TCP_Server_Info *\r\ncifs_get_tcp_session(struct smb_vol *volume_info)\r\n{\r\nstruct TCP_Server_Info *tcp_ses = NULL;\r\nint rc;\r\ncifs_dbg(FYI, "UNC: %s\n", volume_info->UNC);\r\ntcp_ses = cifs_find_tcp_session(volume_info);\r\nif (tcp_ses)\r\nreturn tcp_ses;\r\ntcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\r\nif (!tcp_ses) {\r\nrc = -ENOMEM;\r\ngoto out_err;\r\n}\r\ntcp_ses->ops = volume_info->ops;\r\ntcp_ses->vals = volume_info->vals;\r\ncifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\r\ntcp_ses->hostname = extract_hostname(volume_info->UNC);\r\nif (IS_ERR(tcp_ses->hostname)) {\r\nrc = PTR_ERR(tcp_ses->hostname);\r\ngoto out_err_crypto_release;\r\n}\r\ntcp_ses->noblocksnd = volume_info->noblocksnd;\r\ntcp_ses->noautotune = volume_info->noautotune;\r\ntcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\r\ntcp_ses->in_flight = 0;\r\ntcp_ses->credits = 1;\r\ninit_waitqueue_head(&tcp_ses->response_q);\r\ninit_waitqueue_head(&tcp_ses->request_q);\r\nINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\r\nmutex_init(&tcp_ses->srv_mutex);\r\nmemcpy(tcp_ses->workstation_RFC1001_name,\r\nvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\r\nmemcpy(tcp_ses->server_RFC1001_name,\r\nvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\r\ntcp_ses->session_estab = false;\r\ntcp_ses->sequence_number = 0;\r\ntcp_ses->lstrp = jiffies;\r\nspin_lock_init(&tcp_ses->req_lock);\r\nINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\r\nINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\r\nINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\r\nmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\r\nsizeof(tcp_ses->srcaddr));\r\nmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\r\nsizeof(tcp_ses->dstaddr));\r\n#ifdef CONFIG_CIFS_SMB2\r\nget_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);\r\n#endif\r\ntcp_ses->tcpStatus = CifsNew;\r\n++tcp_ses->srv_count;\r\nrc = ip_connect(tcp_ses);\r\nif (rc < 0) {\r\ncifs_dbg(VFS, "Error connecting to socket. Aborting operation.\n");\r\ngoto out_err_crypto_release;\r\n}\r\n__module_get(THIS_MODULE);\r\ntcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\r\ntcp_ses, "cifsd");\r\nif (IS_ERR(tcp_ses->tsk)) {\r\nrc = PTR_ERR(tcp_ses->tsk);\r\ncifs_dbg(VFS, "error %d create cifsd thread\n", rc);\r\nmodule_put(THIS_MODULE);\r\ngoto out_err_crypto_release;\r\n}\r\ntcp_ses->tcpStatus = CifsNeedNegotiate;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_fscache_get_client_cookie(tcp_ses);\r\nqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\r\nreturn tcp_ses;\r\nout_err_crypto_release:\r\ncifs_crypto_shash_release(tcp_ses);\r\nput_net(cifs_net_ns(tcp_ses));\r\nout_err:\r\nif (tcp_ses) {\r\nif (!IS_ERR(tcp_ses->hostname))\r\nkfree(tcp_ses->hostname);\r\nif (tcp_ses->ssocket)\r\nsock_release(tcp_ses->ssocket);\r\nkfree(tcp_ses);\r\n}\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\r\n{\r\nif (vol->sectype != Unspecified &&\r\nvol->sectype != ses->sectype)\r\nreturn 0;\r\nswitch (ses->sectype) {\r\ncase Kerberos:\r\nif (!uid_eq(vol->cred_uid, ses->cred_uid))\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nif (ses->user_name == NULL) {\r\nif (!vol->nullauth)\r\nreturn 0;\r\nbreak;\r\n}\r\nif (strncmp(ses->user_name,\r\nvol->username ? vol->username : "",\r\nCIFS_MAX_USERNAME_LEN))\r\nreturn 0;\r\nif ((vol->username && strlen(vol->username) != 0) &&\r\nses->password != NULL &&\r\nstrncmp(ses->password,\r\nvol->password ? vol->password : "",\r\nCIFS_MAX_PASSWORD_LEN))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct cifs_ses *\r\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\r\n{\r\nstruct cifs_ses *ses;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\r\nif (ses->status == CifsExiting)\r\ncontinue;\r\nif (!match_session(ses, vol))\r\ncontinue;\r\n++ses->ses_count;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn ses;\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\ncifs_put_smb_ses(struct cifs_ses *ses)\r\n{\r\nunsigned int rc, xid;\r\nstruct TCP_Server_Info *server = ses->server;\r\ncifs_dbg(FYI, "%s: ses_count=%d\n", __func__, ses->ses_count);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif (ses->status == CifsExiting) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn;\r\n}\r\nif (--ses->ses_count > 0) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn;\r\n}\r\nif (ses->status == CifsGood)\r\nses->status = CifsExiting;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nif (ses->status == CifsExiting && server->ops->logoff) {\r\nxid = get_xid();\r\nrc = server->ops->logoff(xid, ses);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Session Logoff failure rc=%d\n",\r\n__func__, rc);\r\n_free_xid(xid);\r\n}\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_del_init(&ses->smb_ses_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nsesInfoFree(ses);\r\ncifs_put_tcp_session(server);\r\n}\r\nstatic int\r\ncifs_set_cifscreds(struct smb_vol *vol, struct cifs_ses *ses)\r\n{\r\nint rc = 0;\r\nchar *desc, *delim, *payload;\r\nssize_t len;\r\nstruct key *key;\r\nstruct TCP_Server_Info *server = ses->server;\r\nstruct sockaddr_in *sa;\r\nstruct sockaddr_in6 *sa6;\r\nstruct user_key_payload *upayload;\r\ndesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\nswitch (server->dstaddr.ss_family) {\r\ncase AF_INET:\r\nsa = (struct sockaddr_in *)&server->dstaddr;\r\nsprintf(desc, "cifs:a:%pI4", &sa->sin_addr.s_addr);\r\nbreak;\r\ncase AF_INET6:\r\nsa6 = (struct sockaddr_in6 *)&server->dstaddr;\r\nsprintf(desc, "cifs:a:%pI6c", &sa6->sin6_addr.s6_addr);\r\nbreak;\r\ndefault:\r\ncifs_dbg(FYI, "Bad ss_family (%hu)\n",\r\nserver->dstaddr.ss_family);\r\nrc = -EINVAL;\r\ngoto out_err;\r\n}\r\ncifs_dbg(FYI, "%s: desc=%s\n", __func__, desc);\r\nkey = request_key(&key_type_logon, desc, "");\r\nif (IS_ERR(key)) {\r\nif (!ses->domainName) {\r\ncifs_dbg(FYI, "domainName is NULL\n");\r\nrc = PTR_ERR(key);\r\ngoto out_err;\r\n}\r\nsprintf(desc, "cifs:d:%s", ses->domainName);\r\ncifs_dbg(FYI, "%s: desc=%s\n", __func__, desc);\r\nkey = request_key(&key_type_logon, desc, "");\r\nif (IS_ERR(key)) {\r\nrc = PTR_ERR(key);\r\ngoto out_err;\r\n}\r\n}\r\ndown_read(&key->sem);\r\nupayload = key->payload.data;\r\nif (IS_ERR_OR_NULL(upayload)) {\r\nrc = upayload ? PTR_ERR(upayload) : -EINVAL;\r\ngoto out_key_put;\r\n}\r\npayload = (char *)upayload->data;\r\ndelim = strnchr(payload, upayload->datalen, ':');\r\ncifs_dbg(FYI, "payload=%s\n", payload);\r\nif (!delim) {\r\ncifs_dbg(FYI, "Unable to find ':' in payload (datalen=%d)\n",\r\nupayload->datalen);\r\nrc = -EINVAL;\r\ngoto out_key_put;\r\n}\r\nlen = delim - payload;\r\nif (len > CIFS_MAX_USERNAME_LEN || len <= 0) {\r\ncifs_dbg(FYI, "Bad value from username search (len=%zd)\n",\r\nlen);\r\nrc = -EINVAL;\r\ngoto out_key_put;\r\n}\r\nvol->username = kstrndup(payload, len, GFP_KERNEL);\r\nif (!vol->username) {\r\ncifs_dbg(FYI, "Unable to allocate %zd bytes for username\n",\r\nlen);\r\nrc = -ENOMEM;\r\ngoto out_key_put;\r\n}\r\ncifs_dbg(FYI, "%s: username=%s\n", __func__, vol->username);\r\nlen = key->datalen - (len + 1);\r\nif (len > CIFS_MAX_PASSWORD_LEN || len <= 0) {\r\ncifs_dbg(FYI, "Bad len for password search (len=%zd)\n", len);\r\nrc = -EINVAL;\r\nkfree(vol->username);\r\nvol->username = NULL;\r\ngoto out_key_put;\r\n}\r\n++delim;\r\nvol->password = kstrndup(delim, len, GFP_KERNEL);\r\nif (!vol->password) {\r\ncifs_dbg(FYI, "Unable to allocate %zd bytes for password\n",\r\nlen);\r\nrc = -ENOMEM;\r\nkfree(vol->username);\r\nvol->username = NULL;\r\ngoto out_key_put;\r\n}\r\nout_key_put:\r\nup_read(&key->sem);\r\nkey_put(key);\r\nout_err:\r\nkfree(desc);\r\ncifs_dbg(FYI, "%s: returning %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic struct cifs_ses *\r\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\r\n{\r\nint rc = -ENOMEM;\r\nunsigned int xid;\r\nstruct cifs_ses *ses;\r\nstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\r\nstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\r\nxid = get_xid();\r\nses = cifs_find_smb_ses(server, volume_info);\r\nif (ses) {\r\ncifs_dbg(FYI, "Existing smb sess found (status=%d)\n",\r\nses->status);\r\nmutex_lock(&ses->session_mutex);\r\nrc = cifs_negotiate_protocol(xid, ses);\r\nif (rc) {\r\nmutex_unlock(&ses->session_mutex);\r\ncifs_put_smb_ses(ses);\r\nfree_xid(xid);\r\nreturn ERR_PTR(rc);\r\n}\r\nif (ses->need_reconnect) {\r\ncifs_dbg(FYI, "Session needs reconnect\n");\r\nrc = cifs_setup_session(xid, ses,\r\nvolume_info->local_nls);\r\nif (rc) {\r\nmutex_unlock(&ses->session_mutex);\r\ncifs_put_smb_ses(ses);\r\nfree_xid(xid);\r\nreturn ERR_PTR(rc);\r\n}\r\n}\r\nmutex_unlock(&ses->session_mutex);\r\ncifs_put_tcp_session(server);\r\nfree_xid(xid);\r\nreturn ses;\r\n}\r\ncifs_dbg(FYI, "Existing smb sess not found\n");\r\nses = sesInfoAlloc();\r\nif (ses == NULL)\r\ngoto get_ses_fail;\r\nses->server = server;\r\nif (server->dstaddr.ss_family == AF_INET6)\r\nsprintf(ses->serverName, "%pI6", &addr6->sin6_addr);\r\nelse\r\nsprintf(ses->serverName, "%pI4", &addr->sin_addr);\r\nif (volume_info->username) {\r\nses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\r\nif (!ses->user_name)\r\ngoto get_ses_fail;\r\n}\r\nif (volume_info->password) {\r\nses->password = kstrdup(volume_info->password, GFP_KERNEL);\r\nif (!ses->password)\r\ngoto get_ses_fail;\r\n}\r\nif (volume_info->domainname) {\r\nses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\r\nif (!ses->domainName)\r\ngoto get_ses_fail;\r\n}\r\nses->cred_uid = volume_info->cred_uid;\r\nses->linux_uid = volume_info->linux_uid;\r\nses->sectype = volume_info->sectype;\r\nses->sign = volume_info->sign;\r\nmutex_lock(&ses->session_mutex);\r\nrc = cifs_negotiate_protocol(xid, ses);\r\nif (!rc)\r\nrc = cifs_setup_session(xid, ses, volume_info->local_nls);\r\nmutex_unlock(&ses->session_mutex);\r\nif (rc)\r\ngoto get_ses_fail;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_add(&ses->smb_ses_list, &server->smb_ses_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nfree_xid(xid);\r\nreturn ses;\r\nget_ses_fail:\r\nsesInfoFree(ses);\r\nfree_xid(xid);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\r\n{\r\nif (tcon->tidStatus == CifsExiting)\r\nreturn 0;\r\nif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct cifs_tcon *\r\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\r\n{\r\nstruct list_head *tmp;\r\nstruct cifs_tcon *tcon;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &ses->tcon_list) {\r\ntcon = list_entry(tmp, struct cifs_tcon, tcon_list);\r\nif (!match_tcon(tcon, unc))\r\ncontinue;\r\n++tcon->tc_count;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn tcon;\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\ncifs_put_tcon(struct cifs_tcon *tcon)\r\n{\r\nunsigned int xid;\r\nstruct cifs_ses *ses = tcon->ses;\r\ncifs_dbg(FYI, "%s: tc_count=%d\n", __func__, tcon->tc_count);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif (--tcon->tc_count > 0) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn;\r\n}\r\nlist_del_init(&tcon->tcon_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nxid = get_xid();\r\nif (ses->server->ops->tree_disconnect)\r\nses->server->ops->tree_disconnect(xid, tcon);\r\n_free_xid(xid);\r\ncifs_fscache_release_super_cookie(tcon);\r\ntconInfoFree(tcon);\r\ncifs_put_smb_ses(ses);\r\n}\r\nstatic struct cifs_tcon *\r\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\r\n{\r\nint rc, xid;\r\nstruct cifs_tcon *tcon;\r\ntcon = cifs_find_tcon(ses, volume_info->UNC);\r\nif (tcon) {\r\ncifs_dbg(FYI, "Found match on UNC path\n");\r\ncifs_put_smb_ses(ses);\r\nif (tcon->seal != volume_info->seal)\r\ncifs_dbg(VFS, "transport encryption setting conflicts with existing tid\n");\r\nreturn tcon;\r\n}\r\nif (!ses->server->ops->tree_connect) {\r\nrc = -ENOSYS;\r\ngoto out_fail;\r\n}\r\ntcon = tconInfoAlloc();\r\nif (tcon == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_fail;\r\n}\r\ntcon->ses = ses;\r\nif (volume_info->password) {\r\ntcon->password = kstrdup(volume_info->password, GFP_KERNEL);\r\nif (!tcon->password) {\r\nrc = -ENOMEM;\r\ngoto out_fail;\r\n}\r\n}\r\nxid = get_xid();\r\nrc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\r\nvolume_info->local_nls);\r\nfree_xid(xid);\r\ncifs_dbg(FYI, "Tcon rc = %d\n", rc);\r\nif (rc)\r\ngoto out_fail;\r\nif (volume_info->nodfs) {\r\ntcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\r\ncifs_dbg(FYI, "DFS disabled (%d)\n", tcon->Flags);\r\n}\r\ntcon->seal = volume_info->seal;\r\ntcon->retry = volume_info->retry;\r\ntcon->nocase = volume_info->nocase;\r\ntcon->local_lease = volume_info->local_lease;\r\nINIT_LIST_HEAD(&tcon->pending_opens);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_add(&tcon->tcon_list, &ses->tcon_list);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_fscache_get_super_cookie(tcon);\r\nreturn tcon;\r\nout_fail:\r\ntconInfoFree(tcon);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid\r\ncifs_put_tlink(struct tcon_link *tlink)\r\n{\r\nif (!tlink || IS_ERR(tlink))\r\nreturn;\r\nif (!atomic_dec_and_test(&tlink->tl_count) ||\r\ntest_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\r\ntlink->tl_time = jiffies;\r\nreturn;\r\n}\r\nif (!IS_ERR(tlink_tcon(tlink)))\r\ncifs_put_tcon(tlink_tcon(tlink));\r\nkfree(tlink);\r\nreturn;\r\n}\r\nstatic inline struct tcon_link *\r\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\r\n{\r\nreturn cifs_sb->master_tlink;\r\n}\r\nstatic int\r\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\r\n{\r\nstruct cifs_sb_info *old = CIFS_SB(sb);\r\nstruct cifs_sb_info *new = mnt_data->cifs_sb;\r\nif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\r\nreturn 0;\r\nif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\r\n(new->mnt_cifs_flags & CIFS_MOUNT_MASK))\r\nreturn 0;\r\nif (new->wsize && new->wsize < old->wsize)\r\nreturn 0;\r\nif (new->rsize && new->rsize < old->rsize)\r\nreturn 0;\r\nif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\r\nreturn 0;\r\nif (old->mnt_file_mode != new->mnt_file_mode ||\r\nold->mnt_dir_mode != new->mnt_dir_mode)\r\nreturn 0;\r\nif (strcmp(old->local_nls->charset, new->local_nls->charset))\r\nreturn 0;\r\nif (old->actimeo != new->actimeo)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\ncifs_match_super(struct super_block *sb, void *data)\r\n{\r\nstruct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\r\nstruct smb_vol *volume_info;\r\nstruct cifs_sb_info *cifs_sb;\r\nstruct TCP_Server_Info *tcp_srv;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct tcon_link *tlink;\r\nint rc = 0;\r\nspin_lock(&cifs_tcp_ses_lock);\r\ncifs_sb = CIFS_SB(sb);\r\ntlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\r\nif (IS_ERR(tlink)) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn rc;\r\n}\r\ntcon = tlink_tcon(tlink);\r\nses = tcon->ses;\r\ntcp_srv = ses->server;\r\nvolume_info = mnt_data->vol;\r\nif (!match_server(tcp_srv, volume_info) ||\r\n!match_session(ses, volume_info) ||\r\n!match_tcon(tcon, volume_info->UNC)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = compare_mount_options(sb, mnt_data);\r\nout:\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nint\r\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\r\nconst struct nls_table *nls_codepage, unsigned int *num_referrals,\r\nstruct dfs_info3_param **referrals, int remap)\r\n{\r\nchar *temp_unc;\r\nint rc = 0;\r\nif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\r\nreturn -ENOSYS;\r\n*num_referrals = 0;\r\n*referrals = NULL;\r\nif (ses->ipc_tid == 0) {\r\ntemp_unc = kmalloc(2 +\r\nstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\r\n+ 1 + 4 + 2, GFP_KERNEL);\r\nif (temp_unc == NULL)\r\nreturn -ENOMEM;\r\ntemp_unc[0] = '\\';\r\ntemp_unc[1] = '\\';\r\nstrcpy(temp_unc + 2, ses->serverName);\r\nstrcpy(temp_unc + 2 + strlen(ses->serverName), "\\IPC$");\r\nrc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\r\nnls_codepage);\r\ncifs_dbg(FYI, "Tcon rc = %d ipc_tid = %d\n", rc, ses->ipc_tid);\r\nkfree(temp_unc);\r\n}\r\nif (rc == 0)\r\nrc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\r\nreferrals, num_referrals,\r\nnls_codepage, remap);\r\nreturn rc;\r\n}\r\nstatic inline void\r\ncifs_reclassify_socket4(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET-CIFS",\r\n&cifs_slock_key[0], "sk_lock-AF_INET-CIFS", &cifs_key[0]);\r\n}\r\nstatic inline void\r\ncifs_reclassify_socket6(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET6-CIFS",\r\n&cifs_slock_key[1], "sk_lock-AF_INET6-CIFS", &cifs_key[1]);\r\n}\r\nstatic inline void\r\ncifs_reclassify_socket4(struct socket *sock)\r\n{\r\n}\r\nstatic inline void\r\ncifs_reclassify_socket6(struct socket *sock)\r\n{\r\n}\r\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\r\n{\r\nunsigned int i, j;\r\nfor (i = 0, j = 0; i < (length); i++) {\r\ntarget[j] = 'A' + (0x0F & (source[i] >> 4));\r\ntarget[j+1] = 'A' + (0x0F & source[i]);\r\nj += 2;\r\n}\r\n}\r\nstatic int\r\nbind_socket(struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\nif (server->srcaddr.ss_family != AF_UNSPEC) {\r\nstruct socket *socket = server->ssocket;\r\nrc = socket->ops->bind(socket,\r\n(struct sockaddr *) &server->srcaddr,\r\nsizeof(server->srcaddr));\r\nif (rc < 0) {\r\nstruct sockaddr_in *saddr4;\r\nstruct sockaddr_in6 *saddr6;\r\nsaddr4 = (struct sockaddr_in *)&server->srcaddr;\r\nsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\r\nif (saddr6->sin6_family == AF_INET6)\r\ncifs_dbg(VFS, "Failed to bind to: %pI6c, error: %d\n",\r\n&saddr6->sin6_addr, rc);\r\nelse\r\ncifs_dbg(VFS, "Failed to bind to: %pI4, error: %d\n",\r\n&saddr4->sin_addr.s_addr, rc);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nip_rfc1001_connect(struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\nstruct rfc1002_session_packet *ses_init_buf;\r\nstruct smb_hdr *smb_buf;\r\nses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\r\nGFP_KERNEL);\r\nif (ses_init_buf) {\r\nses_init_buf->trailer.session_req.called_len = 32;\r\nif (server->server_RFC1001_name &&\r\nserver->server_RFC1001_name[0] != 0)\r\nrfc1002mangle(ses_init_buf->trailer.\r\nsession_req.called_name,\r\nserver->server_RFC1001_name,\r\nRFC1001_NAME_LEN_WITH_NULL);\r\nelse\r\nrfc1002mangle(ses_init_buf->trailer.\r\nsession_req.called_name,\r\nDEFAULT_CIFS_CALLED_NAME,\r\nRFC1001_NAME_LEN_WITH_NULL);\r\nses_init_buf->trailer.session_req.calling_len = 32;\r\nif (server->workstation_RFC1001_name[0] != 0)\r\nrfc1002mangle(ses_init_buf->trailer.\r\nsession_req.calling_name,\r\nserver->workstation_RFC1001_name,\r\nRFC1001_NAME_LEN_WITH_NULL);\r\nelse\r\nrfc1002mangle(ses_init_buf->trailer.\r\nsession_req.calling_name,\r\n"LINUX_CIFS_CLNT",\r\nRFC1001_NAME_LEN_WITH_NULL);\r\nses_init_buf->trailer.session_req.scope1 = 0;\r\nses_init_buf->trailer.session_req.scope2 = 0;\r\nsmb_buf = (struct smb_hdr *)ses_init_buf;\r\nsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\r\nrc = smb_send(server, smb_buf, 0x44);\r\nkfree(ses_init_buf);\r\nusleep_range(1000, 2000);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\ngeneric_ip_connect(struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\n__be16 sport;\r\nint slen, sfamily;\r\nstruct socket *socket = server->ssocket;\r\nstruct sockaddr *saddr;\r\nsaddr = (struct sockaddr *) &server->dstaddr;\r\nif (server->dstaddr.ss_family == AF_INET6) {\r\nsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\r\nslen = sizeof(struct sockaddr_in6);\r\nsfamily = AF_INET6;\r\n} else {\r\nsport = ((struct sockaddr_in *) saddr)->sin_port;\r\nslen = sizeof(struct sockaddr_in);\r\nsfamily = AF_INET;\r\n}\r\nif (socket == NULL) {\r\nrc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\r\nIPPROTO_TCP, &socket, 1);\r\nif (rc < 0) {\r\ncifs_dbg(VFS, "Error %d creating socket\n", rc);\r\nserver->ssocket = NULL;\r\nreturn rc;\r\n}\r\ncifs_dbg(FYI, "Socket created\n");\r\nserver->ssocket = socket;\r\nsocket->sk->sk_allocation = GFP_NOFS;\r\nif (sfamily == AF_INET6)\r\ncifs_reclassify_socket6(socket);\r\nelse\r\ncifs_reclassify_socket4(socket);\r\n}\r\nrc = bind_socket(server);\r\nif (rc < 0)\r\nreturn rc;\r\nsocket->sk->sk_rcvtimeo = 7 * HZ;\r\nsocket->sk->sk_sndtimeo = 5 * HZ;\r\nif (server->noautotune) {\r\nif (socket->sk->sk_sndbuf < (200 * 1024))\r\nsocket->sk->sk_sndbuf = 200 * 1024;\r\nif (socket->sk->sk_rcvbuf < (140 * 1024))\r\nsocket->sk->sk_rcvbuf = 140 * 1024;\r\n}\r\nif (server->tcp_nodelay) {\r\nint val = 1;\r\nrc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\r\n(char *)&val, sizeof(val));\r\nif (rc)\r\ncifs_dbg(FYI, "set TCP_NODELAY socket option error %d\n",\r\nrc);\r\n}\r\ncifs_dbg(FYI, "sndbuf %d rcvbuf %d rcvtimeo 0x%lx\n",\r\nsocket->sk->sk_sndbuf,\r\nsocket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\r\nrc = socket->ops->connect(socket, saddr, slen, 0);\r\nif (rc < 0) {\r\ncifs_dbg(FYI, "Error %d connecting to server\n", rc);\r\nsock_release(socket);\r\nserver->ssocket = NULL;\r\nreturn rc;\r\n}\r\nif (sport == htons(RFC1001_PORT))\r\nrc = ip_rfc1001_connect(server);\r\nreturn rc;\r\n}\r\nstatic int\r\nip_connect(struct TCP_Server_Info *server)\r\n{\r\n__be16 *sport;\r\nstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\r\nstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\r\nif (server->dstaddr.ss_family == AF_INET6)\r\nsport = &addr6->sin6_port;\r\nelse\r\nsport = &addr->sin_port;\r\nif (*sport == 0) {\r\nint rc;\r\n*sport = htons(CIFS_PORT);\r\nrc = generic_ip_connect(server);\r\nif (rc >= 0)\r\nreturn rc;\r\n*sport = htons(RFC1001_PORT);\r\n}\r\nreturn generic_ip_connect(server);\r\n}\r\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\r\n{\r\n__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\r\nif (vol_info && vol_info->no_linux_ext) {\r\ntcon->fsUnixInfo.Capability = 0;\r\ntcon->unix_ext = 0;\r\ncifs_dbg(FYI, "Linux protocol extensions disabled\n");\r\nreturn;\r\n} else if (vol_info)\r\ntcon->unix_ext = 1;\r\nif (tcon->unix_ext == 0) {\r\ncifs_dbg(FYI, "Unix extensions disabled so not set on reconnect\n");\r\nreturn;\r\n}\r\nif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\r\n__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\r\ncifs_dbg(FYI, "unix caps which server supports %lld\n", cap);\r\nif (vol_info == NULL) {\r\nif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\r\ncap &= ~CIFS_UNIX_POSIX_ACL_CAP;\r\nif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\r\nif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\r\ncifs_dbg(VFS, "POSIXPATH support change\n");\r\ncap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\r\n} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\r\ncifs_dbg(VFS, "possible reconnect error\n");\r\ncifs_dbg(VFS, "server disabled POSIX path support\n");\r\n}\r\n}\r\nif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\r\ncifs_dbg(VFS, "per-share encryption not supported yet\n");\r\ncap &= CIFS_UNIX_CAP_MASK;\r\nif (vol_info && vol_info->no_psx_acl)\r\ncap &= ~CIFS_UNIX_POSIX_ACL_CAP;\r\nelse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\r\ncifs_dbg(FYI, "negotiated posix acl support\n");\r\nif (cifs_sb)\r\ncifs_sb->mnt_cifs_flags |=\r\nCIFS_MOUNT_POSIXACL;\r\n}\r\nif (vol_info && vol_info->posix_paths == 0)\r\ncap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\r\nelse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\r\ncifs_dbg(FYI, "negotiate posix pathnames\n");\r\nif (cifs_sb)\r\ncifs_sb->mnt_cifs_flags |=\r\nCIFS_MOUNT_POSIX_PATHS;\r\n}\r\ncifs_dbg(FYI, "Negotiate caps 0x%x\n", (int)cap);\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nif (cap & CIFS_UNIX_FCNTL_CAP)\r\ncifs_dbg(FYI, "FCNTL cap\n");\r\nif (cap & CIFS_UNIX_EXTATTR_CAP)\r\ncifs_dbg(FYI, "EXTATTR cap\n");\r\nif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\r\ncifs_dbg(FYI, "POSIX path cap\n");\r\nif (cap & CIFS_UNIX_XATTR_CAP)\r\ncifs_dbg(FYI, "XATTR cap\n");\r\nif (cap & CIFS_UNIX_POSIX_ACL_CAP)\r\ncifs_dbg(FYI, "POSIX ACL cap\n");\r\nif (cap & CIFS_UNIX_LARGE_READ_CAP)\r\ncifs_dbg(FYI, "very large read cap\n");\r\nif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\r\ncifs_dbg(FYI, "very large write cap\n");\r\nif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\r\ncifs_dbg(FYI, "transport encryption cap\n");\r\nif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\r\ncifs_dbg(FYI, "mandatory transport encryption cap\n");\r\n#endif\r\nif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\r\nif (vol_info == NULL) {\r\ncifs_dbg(FYI, "resetting capabilities failed\n");\r\n} else\r\ncifs_dbg(VFS, "Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\n");\r\n}\r\n}\r\n}\r\nvoid cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\r\nspin_lock_init(&cifs_sb->tlink_tree_lock);\r\ncifs_sb->tlink_tree = RB_ROOT;\r\ncifs_sb->rsize = pvolume_info->rsize;\r\ncifs_sb->wsize = pvolume_info->wsize;\r\ncifs_sb->mnt_uid = pvolume_info->linux_uid;\r\ncifs_sb->mnt_gid = pvolume_info->linux_gid;\r\ncifs_sb->mnt_file_mode = pvolume_info->file_mode;\r\ncifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\r\ncifs_dbg(FYI, "file mode: 0x%hx dir mode: 0x%hx\n",\r\ncifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\r\ncifs_sb->actimeo = pvolume_info->actimeo;\r\ncifs_sb->local_nls = pvolume_info->local_nls;\r\nif (pvolume_info->noperm)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\r\nif (pvolume_info->setuids)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\r\nif (pvolume_info->server_ino)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\r\nif (pvolume_info->remap)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\r\nif (pvolume_info->sfu_remap)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\r\nif (pvolume_info->no_xattr)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\r\nif (pvolume_info->sfu_emul)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\r\nif (pvolume_info->nobrl)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\r\nif (pvolume_info->nostrictsync)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\r\nif (pvolume_info->mand_lock)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\r\nif (pvolume_info->rwpidforward)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\r\nif (pvolume_info->cifs_acl)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\r\nif (pvolume_info->backupuid_specified) {\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\r\ncifs_sb->mnt_backupuid = pvolume_info->backupuid;\r\n}\r\nif (pvolume_info->backupgid_specified) {\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\r\ncifs_sb->mnt_backupgid = pvolume_info->backupgid;\r\n}\r\nif (pvolume_info->override_uid)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\r\nif (pvolume_info->override_gid)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\r\nif (pvolume_info->dynperm)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\r\nif (pvolume_info->fsc)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\r\nif (pvolume_info->multiuser)\r\ncifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\r\nCIFS_MOUNT_NO_PERM);\r\nif (pvolume_info->strict_io)\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\r\nif (pvolume_info->direct_io) {\r\ncifs_dbg(FYI, "mounting share using direct i/o\n");\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\r\n}\r\nif (pvolume_info->mfsymlinks) {\r\nif (pvolume_info->sfu_emul) {\r\ncifs_dbg(VFS, "mount options mfsymlinks and sfu both enabled\n");\r\n}\r\ncifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\r\n}\r\nif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\r\ncifs_dbg(VFS, "mount option dynperm ignored if cifsacl mount option supported\n");\r\n}\r\nstatic void\r\ncleanup_volume_info_contents(struct smb_vol *volume_info)\r\n{\r\nkfree(volume_info->username);\r\nkzfree(volume_info->password);\r\nkfree(volume_info->UNC);\r\nkfree(volume_info->domainname);\r\nkfree(volume_info->iocharset);\r\nkfree(volume_info->prepath);\r\n}\r\nvoid\r\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\r\n{\r\nif (!volume_info)\r\nreturn;\r\ncleanup_volume_info_contents(volume_info);\r\nkfree(volume_info);\r\n}\r\nstatic char *\r\nbuild_unc_path_to_root(const struct smb_vol *vol,\r\nconst struct cifs_sb_info *cifs_sb)\r\n{\r\nchar *full_path, *pos;\r\nunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\r\nunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\r\nfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\r\nif (full_path == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrncpy(full_path, vol->UNC, unc_len);\r\npos = full_path + unc_len;\r\nif (pplen) {\r\n*pos = CIFS_DIR_SEP(cifs_sb);\r\nstrncpy(pos + 1, vol->prepath, pplen);\r\npos += pplen;\r\n}\r\n*pos = '\0';\r\nconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\r\ncifs_dbg(FYI, "%s: full_path=%s\n", __func__, full_path);\r\nreturn full_path;\r\n}\r\nstatic int\r\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\r\nstruct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\r\nint check_prefix)\r\n{\r\nint rc;\r\nunsigned int num_referrals = 0;\r\nstruct dfs_info3_param *referrals = NULL;\r\nchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\r\nfull_path = build_unc_path_to_root(volume_info, cifs_sb);\r\nif (IS_ERR(full_path))\r\nreturn PTR_ERR(full_path);\r\nref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\r\nrc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\r\n&num_referrals, &referrals, cifs_remap(cifs_sb));\r\nif (!rc && num_referrals > 0) {\r\nchar *fake_devname = NULL;\r\nmdata = cifs_compose_mount_options(cifs_sb->mountdata,\r\nfull_path + 1, referrals,\r\n&fake_devname);\r\nfree_dfs_info_array(referrals, num_referrals);\r\nif (IS_ERR(mdata)) {\r\nrc = PTR_ERR(mdata);\r\nmdata = NULL;\r\n} else {\r\ncleanup_volume_info_contents(volume_info);\r\nrc = cifs_setup_volume_info(volume_info, mdata,\r\nfake_devname);\r\n}\r\nkfree(fake_devname);\r\nkfree(cifs_sb->mountdata);\r\ncifs_sb->mountdata = mdata;\r\n}\r\nkfree(full_path);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\r\nconst char *devname)\r\n{\r\nint rc = 0;\r\nif (cifs_parse_mount_options(mount_data, devname, volume_info))\r\nreturn -EINVAL;\r\nif (volume_info->nullauth) {\r\ncifs_dbg(FYI, "Anonymous login\n");\r\nkfree(volume_info->username);\r\nvolume_info->username = NULL;\r\n} else if (volume_info->username) {\r\ncifs_dbg(FYI, "Username: %s\n", volume_info->username);\r\n} else {\r\ncifs_dbg(VFS, "No username specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (volume_info->iocharset == NULL) {\r\nvolume_info->local_nls = load_nls_default();\r\n} else {\r\nvolume_info->local_nls = load_nls(volume_info->iocharset);\r\nif (volume_info->local_nls == NULL) {\r\ncifs_dbg(VFS, "CIFS mount error: iocharset %s not found\n",\r\nvolume_info->iocharset);\r\nreturn -ELIBACC;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstruct smb_vol *\r\ncifs_get_volume_info(char *mount_data, const char *devname)\r\n{\r\nint rc;\r\nstruct smb_vol *volume_info;\r\nvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\r\nif (!volume_info)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = cifs_setup_volume_info(volume_info, mount_data, devname);\r\nif (rc) {\r\ncifs_cleanup_volume_info(volume_info);\r\nvolume_info = ERR_PTR(rc);\r\n}\r\nreturn volume_info;\r\n}\r\nint\r\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\r\n{\r\nint rc;\r\nunsigned int xid;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct TCP_Server_Info *server;\r\nchar *full_path;\r\nstruct tcon_link *tlink;\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\nint referral_walks_count = 0;\r\n#endif\r\nrc = bdi_setup_and_register(&cifs_sb->bdi, "cifs");\r\nif (rc)\r\nreturn rc;\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\ntry_mount_again:\r\nif (referral_walks_count) {\r\nif (tcon)\r\ncifs_put_tcon(tcon);\r\nelse if (ses)\r\ncifs_put_smb_ses(ses);\r\ncifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;\r\nfree_xid(xid);\r\n}\r\n#endif\r\nrc = 0;\r\ntcon = NULL;\r\nses = NULL;\r\nserver = NULL;\r\nfull_path = NULL;\r\ntlink = NULL;\r\nxid = get_xid();\r\nserver = cifs_get_tcp_session(volume_info);\r\nif (IS_ERR(server)) {\r\nrc = PTR_ERR(server);\r\nbdi_destroy(&cifs_sb->bdi);\r\ngoto out;\r\n}\r\nses = cifs_get_smb_ses(server, volume_info);\r\nif (IS_ERR(ses)) {\r\nrc = PTR_ERR(ses);\r\nses = NULL;\r\ngoto mount_fail_check;\r\n}\r\ntcon = cifs_get_tcon(ses, volume_info);\r\nif (IS_ERR(tcon)) {\r\nrc = PTR_ERR(tcon);\r\ntcon = NULL;\r\ngoto remote_path_check;\r\n}\r\nif (cap_unix(tcon->ses)) {\r\nreset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\r\nif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\r\n(le64_to_cpu(tcon->fsUnixInfo.Capability) &\r\nCIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\r\nrc = -EACCES;\r\ngoto mount_fail_check;\r\n}\r\n} else\r\ntcon->unix_ext = 0;\r\nif (!tcon->ipc && server->ops->qfs_tcon)\r\nserver->ops->qfs_tcon(xid, tcon);\r\ncifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\r\ncifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\r\ncifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\r\nremote_path_check:\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\nif (referral_walks_count == 0) {\r\nint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\r\nfalse);\r\nif (!refrc) {\r\nreferral_walks_count++;\r\ngoto try_mount_again;\r\n}\r\n}\r\n#endif\r\nif (!rc && tcon) {\r\nif (!server->ops->is_path_accessible) {\r\nrc = -ENOSYS;\r\ngoto mount_fail_check;\r\n}\r\nfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\r\nif (full_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto mount_fail_check;\r\n}\r\nrc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\r\nfull_path);\r\nif (rc != 0 && rc != -EREMOTE) {\r\nkfree(full_path);\r\ngoto mount_fail_check;\r\n}\r\nkfree(full_path);\r\n}\r\nif (rc == -EREMOTE) {\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\nif (referral_walks_count > MAX_NESTED_LINKS) {\r\nrc = -ELOOP;\r\ngoto mount_fail_check;\r\n}\r\nrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\r\nif (!rc) {\r\nreferral_walks_count++;\r\ngoto try_mount_again;\r\n}\r\ngoto mount_fail_check;\r\n#else\r\nrc = -EOPNOTSUPP;\r\n#endif\r\n}\r\nif (rc)\r\ngoto mount_fail_check;\r\ntlink = kzalloc(sizeof *tlink, GFP_KERNEL);\r\nif (tlink == NULL) {\r\nrc = -ENOMEM;\r\ngoto mount_fail_check;\r\n}\r\ntlink->tl_uid = ses->linux_uid;\r\ntlink->tl_tcon = tcon;\r\ntlink->tl_time = jiffies;\r\nset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\r\nset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\r\ncifs_sb->master_tlink = tlink;\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\ntlink_rb_insert(&cifs_sb->tlink_tree, tlink);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\nqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\r\nTLINK_IDLE_EXPIRE);\r\nmount_fail_check:\r\nif (rc) {\r\nif (tcon)\r\ncifs_put_tcon(tcon);\r\nelse if (ses)\r\ncifs_put_smb_ses(ses);\r\nelse\r\ncifs_put_tcp_session(server);\r\nbdi_destroy(&cifs_sb->bdi);\r\n}\r\nout:\r\nfree_xid(xid);\r\nreturn rc;\r\n}\r\nint\r\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\r\nconst char *tree, struct cifs_tcon *tcon,\r\nconst struct nls_table *nls_codepage)\r\n{\r\nstruct smb_hdr *smb_buffer;\r\nstruct smb_hdr *smb_buffer_response;\r\nTCONX_REQ *pSMB;\r\nTCONX_RSP *pSMBr;\r\nunsigned char *bcc_ptr;\r\nint rc = 0;\r\nint length;\r\n__u16 bytes_left, count;\r\nif (ses == NULL)\r\nreturn -EIO;\r\nsmb_buffer = cifs_buf_get();\r\nif (smb_buffer == NULL)\r\nreturn -ENOMEM;\r\nsmb_buffer_response = smb_buffer;\r\nheader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\r\nNULL , 4 );\r\nsmb_buffer->Mid = get_next_mid(ses->server);\r\nsmb_buffer->Uid = ses->Suid;\r\npSMB = (TCONX_REQ *) smb_buffer;\r\npSMBr = (TCONX_RSP *) smb_buffer_response;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\r\nbcc_ptr = &pSMB->Password[0];\r\nif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\r\npSMB->PasswordLength = cpu_to_le16(1);\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n} else {\r\npSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\r\nif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\r\n(ses->sectype == LANMAN))\r\ncalc_lanman_hash(tcon->password, ses->server->cryptkey,\r\nses->server->sec_mode &\r\nSECMODE_PW_ENCRYPT ? true : false,\r\nbcc_ptr);\r\nelse\r\n#endif\r\nrc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\r\nbcc_ptr, nls_codepage);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s Can't generate NTLM rsp. Error: %d\n",\r\n__func__, rc);\r\ncifs_buf_release(smb_buffer);\r\nreturn rc;\r\n}\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\nif (ses->capabilities & CAP_UNICODE) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\n}\r\nif (ses->server->sign)\r\nsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\nif (ses->capabilities & CAP_STATUS32) {\r\nsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\r\n}\r\nif (ses->capabilities & CAP_DFS) {\r\nsmb_buffer->Flags2 |= SMBFLG2_DFS;\r\n}\r\nif (ses->capabilities & CAP_UNICODE) {\r\nsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\r\nlength =\r\ncifs_strtoUTF16((__le16 *) bcc_ptr, tree,\r\n6 *\r\n( + 256 ), nls_codepage);\r\nbcc_ptr += 2 * length;\r\nbcc_ptr += 2;\r\n} else {\r\nstrcpy(bcc_ptr, tree);\r\nbcc_ptr += strlen(tree) + 1;\r\n}\r\nstrcpy(bcc_ptr, "?????");\r\nbcc_ptr += strlen("?????");\r\nbcc_ptr += 1;\r\ncount = bcc_ptr - &pSMB->Password[0];\r\npSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\r\npSMB->hdr.smb_buf_length) + count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\r\n0);\r\nif ((rc == 0) && (tcon != NULL)) {\r\nbool is_unicode;\r\ntcon->tidStatus = CifsGood;\r\ntcon->need_reconnect = false;\r\ntcon->tid = smb_buffer_response->Tid;\r\nbcc_ptr = pByteArea(smb_buffer_response);\r\nbytes_left = get_bcc(smb_buffer_response);\r\nlength = strnlen(bcc_ptr, bytes_left - 2);\r\nif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\r\nis_unicode = true;\r\nelse\r\nis_unicode = false;\r\nif (length == 3) {\r\nif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\r\n(bcc_ptr[2] == 'C')) {\r\ncifs_dbg(FYI, "IPC connection\n");\r\ntcon->ipc = 1;\r\n}\r\n} else if (length == 2) {\r\nif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\r\ncifs_dbg(FYI, "disk share connection\n");\r\n}\r\n}\r\nbcc_ptr += length + 1;\r\nbytes_left -= (length + 1);\r\nstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\r\nkfree(tcon->nativeFileSystem);\r\ntcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\r\nbytes_left, is_unicode,\r\nnls_codepage);\r\ncifs_dbg(FYI, "nativeFileSystem=%s\n", tcon->nativeFileSystem);\r\nif ((smb_buffer_response->WordCount == 3) ||\r\n(smb_buffer_response->WordCount == 7))\r\ntcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\r\nelse\r\ntcon->Flags = 0;\r\ncifs_dbg(FYI, "Tcon flags: 0x%x\n", tcon->Flags);\r\n} else if ((rc == 0) && tcon == NULL) {\r\nses->ipc_tid = smb_buffer_response->Tid;\r\n}\r\ncifs_buf_release(smb_buffer);\r\nreturn rc;\r\n}\r\nstatic void delayed_free(struct rcu_head *p)\r\n{\r\nstruct cifs_sb_info *sbi = container_of(p, struct cifs_sb_info, rcu);\r\nunload_nls(sbi->local_nls);\r\nkfree(sbi);\r\n}\r\nvoid\r\ncifs_umount(struct cifs_sb_info *cifs_sb)\r\n{\r\nstruct rb_root *root = &cifs_sb->tlink_tree;\r\nstruct rb_node *node;\r\nstruct tcon_link *tlink;\r\ncancel_delayed_work_sync(&cifs_sb->prune_tlinks);\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\nwhile ((node = rb_first(root))) {\r\ntlink = rb_entry(node, struct tcon_link, tl_rbnode);\r\ncifs_get_tlink(tlink);\r\nclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\r\nrb_erase(node, root);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\ncifs_put_tlink(tlink);\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\n}\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\nbdi_destroy(&cifs_sb->bdi);\r\nkfree(cifs_sb->mountdata);\r\ncall_rcu(&cifs_sb->rcu, delayed_free);\r\n}\r\nint\r\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nint rc = 0;\r\nstruct TCP_Server_Info *server = ses->server;\r\nif (!server->ops->need_neg || !server->ops->negotiate)\r\nreturn -ENOSYS;\r\nif (!server->ops->need_neg(server))\r\nreturn 0;\r\nset_credits(server, 1);\r\nrc = server->ops->negotiate(xid, ses);\r\nif (rc == 0) {\r\nspin_lock(&GlobalMid_Lock);\r\nif (server->tcpStatus == CifsNeedNegotiate)\r\nserver->tcpStatus = CifsGood;\r\nelse\r\nrc = -EHOSTDOWN;\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nreturn rc;\r\n}\r\nint\r\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\r\nstruct nls_table *nls_info)\r\n{\r\nint rc = -ENOSYS;\r\nstruct TCP_Server_Info *server = ses->server;\r\nses->capabilities = server->capabilities;\r\nif (linuxExtEnabled == 0)\r\nses->capabilities &= (~server->vals->cap_unix);\r\ncifs_dbg(FYI, "Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n",\r\nserver->sec_mode, server->capabilities, server->timeAdj);\r\nif (server->ops->sess_setup)\r\nrc = server->ops->sess_setup(xid, ses, nls_info);\r\nif (rc)\r\ncifs_dbg(VFS, "Send error in SessSetup = %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\r\n{\r\nvol->sectype = ses->sectype;\r\nif (vol->sectype == Kerberos)\r\nreturn 0;\r\nreturn cifs_set_cifscreds(vol, ses);\r\n}\r\nstatic struct cifs_tcon *\r\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\r\n{\r\nint rc;\r\nstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon = NULL;\r\nstruct smb_vol *vol_info;\r\nvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\r\nif (vol_info == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nvol_info->local_nls = cifs_sb->local_nls;\r\nvol_info->linux_uid = fsuid;\r\nvol_info->cred_uid = fsuid;\r\nvol_info->UNC = master_tcon->treeName;\r\nvol_info->retry = master_tcon->retry;\r\nvol_info->nocase = master_tcon->nocase;\r\nvol_info->local_lease = master_tcon->local_lease;\r\nvol_info->no_linux_ext = !master_tcon->unix_ext;\r\nvol_info->sectype = master_tcon->ses->sectype;\r\nvol_info->sign = master_tcon->ses->sign;\r\nrc = cifs_set_vol_auth(vol_info, master_tcon->ses);\r\nif (rc) {\r\ntcon = ERR_PTR(rc);\r\ngoto out;\r\n}\r\nspin_lock(&cifs_tcp_ses_lock);\r\n++master_tcon->ses->server->srv_count;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\r\nif (IS_ERR(ses)) {\r\ntcon = (struct cifs_tcon *)ses;\r\ncifs_put_tcp_session(master_tcon->ses->server);\r\ngoto out;\r\n}\r\ntcon = cifs_get_tcon(ses, vol_info);\r\nif (IS_ERR(tcon)) {\r\ncifs_put_smb_ses(ses);\r\ngoto out;\r\n}\r\nif (cap_unix(ses))\r\nreset_cifs_unix_caps(0, tcon, NULL, vol_info);\r\nout:\r\nkfree(vol_info->username);\r\nkfree(vol_info->password);\r\nkfree(vol_info);\r\nreturn tcon;\r\n}\r\nstruct cifs_tcon *\r\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\r\n{\r\nreturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\r\n}\r\nstatic struct tcon_link *\r\ntlink_rb_search(struct rb_root *root, kuid_t uid)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct tcon_link *tlink;\r\nwhile (node) {\r\ntlink = rb_entry(node, struct tcon_link, tl_rbnode);\r\nif (uid_gt(tlink->tl_uid, uid))\r\nnode = node->rb_left;\r\nelse if (uid_lt(tlink->tl_uid, uid))\r\nnode = node->rb_right;\r\nelse\r\nreturn tlink;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\r\n{\r\nstruct rb_node **new = &(root->rb_node), *parent = NULL;\r\nstruct tcon_link *tlink;\r\nwhile (*new) {\r\ntlink = rb_entry(*new, struct tcon_link, tl_rbnode);\r\nparent = *new;\r\nif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\r\nnew = &((*new)->rb_left);\r\nelse\r\nnew = &((*new)->rb_right);\r\n}\r\nrb_link_node(&new_tlink->tl_rbnode, parent, new);\r\nrb_insert_color(&new_tlink->tl_rbnode, root);\r\n}\r\nstruct tcon_link *\r\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\r\n{\r\nint ret;\r\nkuid_t fsuid = current_fsuid();\r\nstruct tcon_link *tlink, *newtlink;\r\nif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\r\nreturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\ntlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\r\nif (tlink)\r\ncifs_get_tlink(tlink);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\nif (tlink == NULL) {\r\nnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\r\nif (newtlink == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nnewtlink->tl_uid = fsuid;\r\nnewtlink->tl_tcon = ERR_PTR(-EACCES);\r\nset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\r\nset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\r\ncifs_get_tlink(newtlink);\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\ntlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\r\nif (tlink) {\r\ncifs_get_tlink(tlink);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\nkfree(newtlink);\r\ngoto wait_for_construction;\r\n}\r\ntlink = newtlink;\r\ntlink_rb_insert(&cifs_sb->tlink_tree, tlink);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\n} else {\r\nwait_for_construction:\r\nret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\r\nTASK_INTERRUPTIBLE);\r\nif (ret) {\r\ncifs_put_tlink(tlink);\r\nreturn ERR_PTR(-ERESTARTSYS);\r\n}\r\nif (!IS_ERR(tlink->tl_tcon))\r\nreturn tlink;\r\nif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\r\ncifs_put_tlink(tlink);\r\nreturn ERR_PTR(-EACCES);\r\n}\r\nif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\r\ngoto wait_for_construction;\r\n}\r\ntlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\r\nclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\r\nwake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\r\nif (IS_ERR(tlink->tl_tcon)) {\r\ncifs_put_tlink(tlink);\r\nreturn ERR_PTR(-EACCES);\r\n}\r\nreturn tlink;\r\n}\r\nstatic void\r\ncifs_prune_tlinks(struct work_struct *work)\r\n{\r\nstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\r\nprune_tlinks.work);\r\nstruct rb_root *root = &cifs_sb->tlink_tree;\r\nstruct rb_node *node = rb_first(root);\r\nstruct rb_node *tmp;\r\nstruct tcon_link *tlink;\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\nnode = rb_first(root);\r\nwhile (node != NULL) {\r\ntmp = node;\r\nnode = rb_next(tmp);\r\ntlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\r\nif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\r\natomic_read(&tlink->tl_count) != 0 ||\r\ntime_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\r\ncontinue;\r\ncifs_get_tlink(tlink);\r\nclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\r\nrb_erase(tmp, root);\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\ncifs_put_tlink(tlink);\r\nspin_lock(&cifs_sb->tlink_tree_lock);\r\n}\r\nspin_unlock(&cifs_sb->tlink_tree_lock);\r\nqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\r\nTLINK_IDLE_EXPIRE);\r\n}
