static inline int serial_paranoia_check(struct m68k_serial *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef SERIAL_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for serial struct %s in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null m68k_serial for %s in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != SERIAL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int get_baud(struct m68k_serial *ss)\r\n{\r\nunsigned long result = 115200;\r\nunsigned short int baud = uart_addr[ss->line].ubaud;\r\nif (GET_FIELD(baud, UBAUD_PRESCALER) == 0x38) result = 38400;\r\nresult >>= GET_FIELD(baud, UBAUD_DIVIDE);\r\nreturn result;\r\n}\r\nstatic void rs_stop(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_stop"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nuart->ustcnt &= ~USTCNT_TXEN;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_put_char(char ch)\r\n{\r\nunsigned long flags;\r\nint loops = 0;\r\nlocal_irq_save(flags);\r\nwhile (!(UTX & UTX_TX_AVAIL) && (loops < 1000)) {\r\nloops++;\r\nudelay(5);\r\n}\r\nUTX_TXDATA = ch;\r\nudelay(5);\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic void rs_start(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_start"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->xmit_cnt && info->xmit_buf && !(uart->ustcnt & USTCNT_TXEN)) {\r\n#ifdef USE_INTS\r\nuart->ustcnt |= USTCNT_TXEN | USTCNT_TX_INTR_MASK;\r\n#else\r\nuart->ustcnt |= USTCNT_TXEN;\r\n#endif\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void receive_chars(struct m68k_serial *info, unsigned short rx)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned char ch, flag;\r\n#ifndef CONFIG_XCOPILOT_BUGS\r\ndo {\r\n#endif\r\nch = GET_FIELD(rx, URX_RXDATA);\r\nif(info->is_cons) {\r\nif(URX_BREAK & rx) {\r\nreturn;\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\n} else if (ch == 0x10) {\r\nshow_state();\r\nshow_free_areas(0);\r\nshow_buffers();\r\nreturn;\r\n} else if (ch == 0x12) {\r\nemergency_restart();\r\nreturn;\r\n#endif\r\n}\r\n}\r\nflag = TTY_NORMAL;\r\nif (rx & URX_PARITY_ERROR)\r\nflag = TTY_PARITY;\r\nelse if (rx & URX_OVRUN)\r\nflag = TTY_OVERRUN;\r\nelse if (rx & URX_FRAME_ERROR)\r\nflag = TTY_FRAME;\r\ntty_insert_flip_char(&info->tport, ch, flag);\r\n#ifndef CONFIG_XCOPILOT_BUGS\r\n} while((rx = uart->urx.w) & URX_DATA_READY);\r\n#endif\r\ntty_schedule_flip(&info->tport);\r\n}\r\nstatic void transmit_chars(struct m68k_serial *info, struct tty_struct *tty)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nif (info->x_char) {\r\nuart->utx.b.txdata = info->x_char;\r\ninfo->x_char = 0;\r\ngoto clear_and_return;\r\n}\r\nif ((info->xmit_cnt <= 0) || !tty || tty->stopped) {\r\nuart->ustcnt &= ~USTCNT_TX_INTR_MASK;\r\ngoto clear_and_return;\r\n}\r\nuart->utx.b.txdata = info->xmit_buf[info->xmit_tail++];\r\ninfo->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE-1);\r\ninfo->xmit_cnt--;\r\nif(info->xmit_cnt <= 0) {\r\nuart->ustcnt &= ~USTCNT_TX_INTR_MASK;\r\ngoto clear_and_return;\r\n}\r\nclear_and_return:\r\nreturn;\r\n}\r\nirqreturn_t rs_interrupt(int irq, void *dev_id)\r\n{\r\nstruct m68k_serial *info = dev_id;\r\nstruct tty_struct *tty = tty_port_tty_get(&info->tport);\r\nm68328_uart *uart;\r\nunsigned short rx;\r\nunsigned short tx;\r\nuart = &uart_addr[info->line];\r\nrx = uart->urx.w;\r\n#ifdef USE_INTS\r\ntx = uart->utx.w;\r\nif (rx & URX_DATA_READY)\r\nreceive_chars(info, rx);\r\nif (tx & UTX_TX_AVAIL)\r\ntransmit_chars(info, tty);\r\n#else\r\nreceive_chars(info, rx);\r\n#endif\r\ntty_kref_put(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(struct m68k_serial *info, struct tty_struct *tty)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (info->tport.flags & ASYNC_INITIALIZED)\r\nreturn 0;\r\nif (!info->xmit_buf) {\r\ninfo->xmit_buf = (unsigned char *) __get_free_page(GFP_KERNEL);\r\nif (!info->xmit_buf)\r\nreturn -ENOMEM;\r\n}\r\nlocal_irq_save(flags);\r\nuart->ustcnt = USTCNT_UEN;\r\nuart->ustcnt = USTCNT_UEN | USTCNT_RXEN | USTCNT_TXEN;\r\n(void)uart->urx.w;\r\n#ifdef USE_INTS\r\nuart->ustcnt = USTCNT_UEN | USTCNT_RXEN |\r\nUSTCNT_RX_INTR_MASK | USTCNT_TX_INTR_MASK;\r\n#else\r\nuart->ustcnt = USTCNT_UEN | USTCNT_RXEN | USTCNT_RX_INTR_MASK;\r\n#endif\r\nif (tty)\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nchange_speed(info, tty);\r\ninfo->tport.flags |= ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void shutdown(struct m68k_serial *info, struct tty_struct *tty)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nuart->ustcnt = 0;\r\nif (!(info->tport.flags & ASYNC_INITIALIZED))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->xmit_buf) {\r\nfree_page((unsigned long) info->xmit_buf);\r\ninfo->xmit_buf = 0;\r\n}\r\nif (tty)\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->tport.flags &= ~ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void change_speed(struct m68k_serial *info, struct tty_struct *tty)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned short port;\r\nunsigned short ustcnt;\r\nunsigned cflag;\r\nint i;\r\ncflag = tty->termios.c_cflag;\r\nport = info->port;\r\nif (!port)\r\nreturn;\r\nustcnt = uart->ustcnt;\r\nuart->ustcnt = ustcnt & ~USTCNT_TXEN;\r\ni = cflag & CBAUD;\r\nif (i & CBAUDEX) {\r\ni = (i & ~CBAUDEX) + B38400;\r\n}\r\nuart->ubaud = PUT_FIELD(UBAUD_DIVIDE, hw_baud_table[i].divisor) |\r\nPUT_FIELD(UBAUD_PRESCALER, hw_baud_table[i].prescale);\r\nustcnt &= ~(USTCNT_PARITYEN | USTCNT_ODD_EVEN | USTCNT_STOP | USTCNT_8_7);\r\nif ((cflag & CSIZE) == CS8)\r\nustcnt |= USTCNT_8_7;\r\nif (cflag & CSTOPB)\r\nustcnt |= USTCNT_STOP;\r\nif (cflag & PARENB)\r\nustcnt |= USTCNT_PARITYEN;\r\nif (cflag & PARODD)\r\nustcnt |= USTCNT_ODD_EVEN;\r\n#ifdef CONFIG_SERIAL_68328_RTS_CTS\r\nif (cflag & CRTSCTS) {\r\nuart->utx.w &= ~ UTX_NOCTS;\r\n} else {\r\nuart->utx.w |= UTX_NOCTS;\r\n}\r\n#endif\r\nustcnt |= USTCNT_TXEN;\r\nuart->ustcnt = ustcnt;\r\nreturn;\r\n}\r\nstatic void rs_fair_output(void)\r\n{\r\nint left;\r\nunsigned long flags;\r\nstruct m68k_serial *info = &m68k_soft[0];\r\nchar c;\r\nif (info == 0) return;\r\nif (info->xmit_buf == 0) return;\r\nlocal_irq_save(flags);\r\nleft = info->xmit_cnt;\r\nwhile (left != 0) {\r\nc = info->xmit_buf[info->xmit_tail];\r\ninfo->xmit_tail = (info->xmit_tail+1) & (SERIAL_XMIT_SIZE-1);\r\ninfo->xmit_cnt--;\r\nlocal_irq_restore(flags);\r\nrs_put_char(c);\r\nlocal_irq_save(flags);\r\nleft = min(info->xmit_cnt, left-1);\r\n}\r\nudelay(5);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nvoid console_print_68328(const char *p)\r\n{\r\nchar c;\r\nwhile((c=*(p++)) != 0) {\r\nif(c == '\n')\r\nrs_put_char('\r');\r\nrs_put_char(c);\r\n}\r\nrs_fair_output();\r\nreturn;\r\n}\r\nstatic void rs_set_ldisc(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_set_ldisc"))\r\nreturn;\r\ninfo->is_cons = (tty->termios.c_line == N_TTY);\r\nprintk("ttyS%d console mode %s\n", info->line, info->is_cons ? "on" : "off");\r\n}\r\nstatic int rs_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, total = 0;\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_write"))\r\nreturn 0;\r\nif (!tty || !info->xmit_buf)\r\nreturn 0;\r\nlocal_save_flags(flags);\r\nwhile (1) {\r\nlocal_irq_disable();\r\nc = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,\r\nSERIAL_XMIT_SIZE - info->xmit_head));\r\nlocal_irq_restore(flags);\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->xmit_buf + info->xmit_head, buf, c);\r\nlocal_irq_disable();\r\ninfo->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);\r\ninfo->xmit_cnt += c;\r\nlocal_irq_restore(flags);\r\nbuf += c;\r\ncount -= c;\r\ntotal += c;\r\n}\r\nif (info->xmit_cnt && !tty->stopped) {\r\nlocal_irq_disable();\r\n#ifndef USE_INTS\r\nwhile(info->xmit_cnt) {\r\n#endif\r\nuart->ustcnt |= USTCNT_TXEN;\r\n#ifdef USE_INTS\r\nuart->ustcnt |= USTCNT_TX_INTR_MASK;\r\n#else\r\nwhile (!(uart->utx.w & UTX_TX_AVAIL)) udelay(5);\r\n#endif\r\nif (uart->utx.w & UTX_TX_AVAIL) {\r\nuart->utx.b.txdata = info->xmit_buf[info->xmit_tail++];\r\ninfo->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE-1);\r\ninfo->xmit_cnt--;\r\n}\r\n#ifndef USE_INTS\r\n}\r\n#endif\r\nlocal_irq_restore(flags);\r\n}\r\nreturn total;\r\n}\r\nstatic int rs_write_room(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nint ret;\r\nif (serial_paranoia_check(info, tty->name, "rs_write_room"))\r\nreturn 0;\r\nret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int rs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))\r\nreturn 0;\r\nreturn info->xmit_cnt;\r\n}\r\nstatic void rs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))\r\nreturn;\r\nlocal_irq_save(flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_throttle(struct tty_struct * tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\ninfo->x_char = STOP_CHAR(tty);\r\n}\r\nstatic void rs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\ninfo->x_char = START_CHAR(tty);\r\n}\r\n}\r\nstatic int get_serial_info(struct m68k_serial * info,\r\nstruct serial_struct * retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = info->type;\r\ntmp.line = info->line;\r\ntmp.port = info->port;\r\ntmp.irq = info->irq;\r\ntmp.flags = info->tport.flags;\r\ntmp.baud_base = info->baud_base;\r\ntmp.close_delay = info->tport.close_delay;\r\ntmp.closing_wait = info->tport.closing_wait;\r\ntmp.custom_divisor = info->custom_divisor;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct m68k_serial *info, struct tty_struct *tty,\r\nstruct serial_struct * new_info)\r\n{\r\nstruct tty_port *port = &info->tport;\r\nstruct serial_struct new_serial;\r\nstruct m68k_serial old_info;\r\nint retval = 0;\r\nif (!new_info)\r\nreturn -EFAULT;\r\nif (copy_from_user(&new_serial, new_info, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nold_info = *info;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((new_serial.baud_base != info->baud_base) ||\r\n(new_serial.type != info->type) ||\r\n(new_serial.close_delay != port->close_delay) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(port->flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\nport->flags = ((port->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\ninfo->custom_divisor = new_serial.custom_divisor;\r\ngoto check_and_exit;\r\n}\r\nif (port->count > 1)\r\nreturn -EBUSY;\r\ninfo->baud_base = new_serial.baud_base;\r\nport->flags = ((port->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\ninfo->type = new_serial.type;\r\nport->close_delay = new_serial.close_delay;\r\nport->closing_wait = new_serial.closing_wait;\r\ncheck_and_exit:\r\nretval = startup(info, tty);\r\nreturn retval;\r\n}\r\nstatic int get_lsr_info(struct m68k_serial * info, unsigned int *value)\r\n{\r\n#ifdef CONFIG_SERIAL_68328_RTS_CTS\r\nm68328_uart *uart = &uart_addr[info->line];\r\n#endif\r\nunsigned char status;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n#ifdef CONFIG_SERIAL_68328_RTS_CTS\r\nstatus = (uart->utx.w & UTX_CTS_STAT) ? 1 : 0;\r\n#else\r\nstatus = 0;\r\n#endif\r\nlocal_irq_restore(flags);\r\nreturn put_user(status, value);\r\n}\r\nstatic void send_break(struct m68k_serial * info, unsigned int duration)\r\n{\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (!info->port)\r\nreturn;\r\nlocal_irq_save(flags);\r\n#ifdef USE_INTS\r\nuart->utx.w |= UTX_SEND_BREAK;\r\nmsleep_interruptible(duration);\r\nuart->utx.w &= ~UTX_SEND_BREAK;\r\n#endif\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct m68k_serial * info = (struct m68k_serial *)tty->driver_data;\r\nint retval;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD) &&\r\n(cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TCSBRK:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\ntty_wait_until_sent(tty, 0);\r\nif (!arg)\r\nsend_break(info, 250);\r\nreturn 0;\r\ncase TCSBRKP:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\ntty_wait_until_sent(tty, 0);\r\nsend_break(info, arg ? arg*(100) : 250);\r\nreturn 0;\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(info,\r\n(struct serial_struct *) arg);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(info, tty,\r\n(struct serial_struct *) arg);\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(info, (unsigned int *) arg);\r\ncase TIOCSERGSTRUCT:\r\nif (copy_to_user((struct m68k_serial *) arg,\r\ninfo, sizeof(struct m68k_serial)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct m68k_serial *info = (struct m68k_serial *)tty->driver_data;\r\nchange_speed(info, tty);\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios.c_cflag & CRTSCTS))\r\nrs_start(tty);\r\n}\r\nstatic void rs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct m68k_serial * info = (struct m68k_serial *)tty->driver_data;\r\nstruct tty_port *port = &info->tport;\r\nm68328_uart *uart = &uart_addr[info->line];\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_close"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (tty_hung_up_p(filp)) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nif ((tty->count == 1) && (port->count != 1)) {\r\nprintk("rs_close: bad serial port count; tty->count is 1, "\r\n"port->count is %d\n", port->count);\r\nport->count = 1;\r\n}\r\nif (--port->count < 0) {\r\nprintk("rs_close: bad serial port count for ttyS%d: %d\n",\r\ninfo->line, port->count);\r\nport->count = 0;\r\n}\r\nif (port->count) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nport->flags |= ASYNC_CLOSING;\r\ntty->closing = 1;\r\nif (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent(tty, port->closing_wait);\r\nuart->ustcnt &= ~USTCNT_RXEN;\r\nuart->ustcnt &= ~(USTCNT_RXEN | USTCNT_RX_INTR_MASK);\r\nshutdown(info, tty);\r\nrs_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty->closing = 0;\r\ntty_port_tty_set(&info->tport, NULL);\r\n#warning "This is not and has never been valid so fix it"\r\n#if 0\r\nif (tty->ldisc.num != ldiscs[N_TTY].num) {\r\nif (tty->ldisc.close)\r\n(tty->ldisc.close)(tty);\r\ntty->ldisc = ldiscs[N_TTY];\r\ntty->termios.c_line = N_TTY;\r\nif (tty->ldisc.open)\r\n(tty->ldisc.open)(tty);\r\n}\r\n#endif\r\nif (port->blocked_open) {\r\nif (port->close_delay)\r\nmsleep_interruptible(jiffies_to_msecs(port->close_delay));\r\nwake_up_interruptible(&port->open_wait);\r\n}\r\nport->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&port->close_wait);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid rs_hangup(struct tty_struct *tty)\r\n{\r\nstruct m68k_serial * info = (struct m68k_serial *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_hangup"))\r\nreturn;\r\nrs_flush_buffer(tty);\r\nshutdown(info, tty);\r\ninfo->tport.count = 0;\r\ninfo->tport.flags &= ~ASYNC_NORMAL_ACTIVE;\r\ntty_port_tty_set(&info->tport, NULL);\r\nwake_up_interruptible(&info->tport.open_wait);\r\n}\r\nint rs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct m68k_serial *info;\r\nint retval;\r\ninfo = &m68k_soft[tty->index];\r\nif (serial_paranoia_check(info, tty->name, "rs_open"))\r\nreturn -ENODEV;\r\ninfo->tport.count++;\r\ntty->driver_data = info;\r\ntty_port_tty_set(&info->tport, tty);\r\nretval = startup(info, tty);\r\nif (retval)\r\nreturn retval;\r\nreturn tty_port_block_til_ready(&info->tport, tty, filp);\r\n}\r\nstatic void show_serial_version(void)\r\n{\r\nprintk("MC68328 serial driver version 1.00\n");\r\n}\r\nstatic int __init\r\nrs68328_init(void)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct m68k_serial *info;\r\nserial_driver = alloc_tty_driver(NR_PORTS);\r\nif (!serial_driver)\r\nreturn -ENOMEM;\r\nshow_serial_version();\r\nserial_driver->name = "ttyS";\r\nserial_driver->major = TTY_MAJOR;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nm68328_console_cbaud | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &rs_ops);\r\nlocal_irq_save(flags);\r\nfor(i=0;i<NR_PORTS;i++) {\r\ninfo = &m68k_soft[i];\r\ntty_port_init(&info->tport);\r\ninfo->tport.ops = &rs_port_ops;\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->port = (int) &uart_addr[i];\r\ninfo->irq = uart_irqs[i];\r\ninfo->custom_divisor = 16;\r\ninfo->x_char = 0;\r\ninfo->line = i;\r\ninfo->is_cons = 1;\r\nprintk("%s%d at 0x%08x (irq = %d)", serial_driver->name, info->line,\r\ninfo->port, info->irq);\r\nprintk(" is a builtin MC68328 UART\n");\r\n#ifdef CONFIG_M68VZ328\r\nif (i > 0 )\r\nPJSEL &= 0xCF;\r\n#endif\r\nif (request_irq(uart_irqs[i],\r\nrs_interrupt,\r\n0,\r\n"M68328_UART", info))\r\npanic("Unable to attach 68328 serial interrupt\n");\r\ntty_port_link_device(&info->tport, serial_driver, i);\r\n}\r\nlocal_irq_restore(flags);\r\nif (tty_register_driver(serial_driver)) {\r\nput_tty_driver(serial_driver);\r\nfor (i = 0; i < NR_PORTS; i++)\r\ntty_port_destroy(&m68k_soft[i].tport);\r\nprintk(KERN_ERR "Couldn't register serial driver\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void m68328_set_baud(void)\r\n{\r\nunsigned short ustcnt;\r\nint i;\r\nustcnt = USTCNT;\r\nUSTCNT = ustcnt & ~USTCNT_TXEN;\r\nagain:\r\nfor (i = 0; i < ARRAY_SIZE(baud_table); i++)\r\nif (baud_table[i] == m68328_console_baud)\r\nbreak;\r\nif (i >= ARRAY_SIZE(baud_table)) {\r\nm68328_console_baud = 9600;\r\ngoto again;\r\n}\r\nUBAUD = PUT_FIELD(UBAUD_DIVIDE, hw_baud_table[i].divisor) |\r\nPUT_FIELD(UBAUD_PRESCALER, hw_baud_table[i].prescale);\r\nustcnt &= ~(USTCNT_PARITYEN | USTCNT_ODD_EVEN | USTCNT_STOP | USTCNT_8_7);\r\nustcnt |= USTCNT_8_7;\r\nustcnt |= USTCNT_TXEN;\r\nUSTCNT = ustcnt;\r\nm68328_console_initted = 1;\r\nreturn;\r\n}\r\nint m68328_console_setup(struct console *cp, char *arg)\r\n{\r\nint i, n = CONSOLE_BAUD_RATE;\r\nif (!cp)\r\nreturn(-1);\r\nif (arg)\r\nn = simple_strtoul(arg,NULL,0);\r\nfor (i = 0; i < ARRAY_SIZE(baud_table); i++)\r\nif (baud_table[i] == n)\r\nbreak;\r\nif (i < ARRAY_SIZE(baud_table)) {\r\nm68328_console_baud = n;\r\nm68328_console_cbaud = 0;\r\nif (i > 15) {\r\nm68328_console_cbaud |= CBAUDEX;\r\ni -= 15;\r\n}\r\nm68328_console_cbaud |= i;\r\n}\r\nm68328_set_baud();\r\nreturn(0);\r\n}\r\nstatic struct tty_driver *m68328_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn serial_driver;\r\n}\r\nvoid m68328_console_write (struct console *co, const char *str,\r\nunsigned int count)\r\n{\r\nif (!m68328_console_initted)\r\nm68328_set_baud();\r\nwhile (count--) {\r\nif (*str == '\n')\r\nrs_put_char('\r');\r\nrs_put_char( *str++ );\r\n}\r\n}\r\nstatic int __init m68328_console_init(void)\r\n{\r\nregister_console(&m68328_driver);\r\nreturn 0;\r\n}
