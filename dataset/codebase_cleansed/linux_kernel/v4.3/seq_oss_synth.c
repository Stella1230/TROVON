void __init\r\nsnd_seq_oss_synth_init(void)\r\n{\r\nsnd_use_lock_init(&midi_synth_dev.use_lock);\r\n}\r\nint\r\nsnd_seq_oss_synth_probe(struct device *_dev)\r\n{\r\nstruct snd_seq_device *dev = to_seq_dev(_dev);\r\nint i;\r\nstruct seq_oss_synth *rec;\r\nstruct snd_seq_oss_reg *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\nunsigned long flags;\r\nrec = kzalloc(sizeof(*rec), GFP_KERNEL);\r\nif (!rec)\r\nreturn -ENOMEM;\r\nrec->seq_device = -1;\r\nrec->synth_type = reg->type;\r\nrec->synth_subtype = reg->subtype;\r\nrec->nr_voices = reg->nvoices;\r\nrec->oper = reg->oper;\r\nrec->private_data = reg->private_data;\r\nrec->opened = 0;\r\nsnd_use_lock_init(&rec->use_lock);\r\nstrlcpy(rec->name, dev->name, sizeof(rec->name));\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (i = 0; i < max_synth_devs; i++) {\r\nif (synth_devs[i] == NULL)\r\nbreak;\r\n}\r\nif (i >= max_synth_devs) {\r\nif (max_synth_devs >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS) {\r\nspin_unlock_irqrestore(&register_lock, flags);\r\npr_err("ALSA: seq_oss: no more synth slot\n");\r\nkfree(rec);\r\nreturn -ENOMEM;\r\n}\r\nmax_synth_devs++;\r\n}\r\nrec->seq_device = i;\r\nsynth_devs[i] = rec;\r\nspin_unlock_irqrestore(&register_lock, flags);\r\ndev->driver_data = rec;\r\n#ifdef SNDRV_OSS_INFO_DEV_SYNTH\r\nif (i < SNDRV_CARDS)\r\nsnd_oss_info_register(SNDRV_OSS_INFO_DEV_SYNTH, i, rec->name);\r\n#endif\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_synth_remove(struct device *_dev)\r\n{\r\nstruct snd_seq_device *dev = to_seq_dev(_dev);\r\nint index;\r\nstruct seq_oss_synth *rec = dev->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (index = 0; index < max_synth_devs; index++) {\r\nif (synth_devs[index] == rec)\r\nbreak;\r\n}\r\nif (index >= max_synth_devs) {\r\nspin_unlock_irqrestore(&register_lock, flags);\r\npr_err("ALSA: seq_oss: can't unregister synth\n");\r\nreturn -EINVAL;\r\n}\r\nsynth_devs[index] = NULL;\r\nif (index == max_synth_devs - 1) {\r\nfor (index--; index >= 0; index--) {\r\nif (synth_devs[index])\r\nbreak;\r\n}\r\nmax_synth_devs = index + 1;\r\n}\r\nspin_unlock_irqrestore(&register_lock, flags);\r\n#ifdef SNDRV_OSS_INFO_DEV_SYNTH\r\nif (rec->seq_device < SNDRV_CARDS)\r\nsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_SYNTH, rec->seq_device);\r\n#endif\r\nsnd_use_lock_sync(&rec->use_lock);\r\nkfree(rec);\r\nreturn 0;\r\n}\r\nstatic struct seq_oss_synth *\r\nget_sdev(int dev)\r\n{\r\nstruct seq_oss_synth *rec;\r\nunsigned long flags;\r\nspin_lock_irqsave(&register_lock, flags);\r\nrec = synth_devs[dev];\r\nif (rec)\r\nsnd_use_lock_use(&rec->use_lock);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn rec;\r\n}\r\nvoid\r\nsnd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)\r\n{\r\nint i;\r\nstruct seq_oss_synth *rec;\r\nstruct seq_oss_synthinfo *info;\r\ndp->max_synthdev = max_synth_devs;\r\ndp->synth_opened = 0;\r\nmemset(dp->synths, 0, sizeof(dp->synths));\r\nfor (i = 0; i < dp->max_synthdev; i++) {\r\nrec = get_sdev(i);\r\nif (rec == NULL)\r\ncontinue;\r\nif (rec->oper.open == NULL || rec->oper.close == NULL) {\r\nsnd_use_lock_free(&rec->use_lock);\r\ncontinue;\r\n}\r\ninfo = &dp->synths[i];\r\ninfo->arg.app_index = dp->port;\r\ninfo->arg.file_mode = dp->file_mode;\r\ninfo->arg.seq_mode = dp->seq_mode;\r\nif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH)\r\ninfo->arg.event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;\r\nelse\r\ninfo->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;\r\ninfo->opened = 0;\r\nif (!try_module_get(rec->oper.owner)) {\r\nsnd_use_lock_free(&rec->use_lock);\r\ncontinue;\r\n}\r\nif (rec->oper.open(&info->arg, rec->private_data) < 0) {\r\nmodule_put(rec->oper.owner);\r\nsnd_use_lock_free(&rec->use_lock);\r\ncontinue;\r\n}\r\ninfo->nr_voices = rec->nr_voices;\r\nif (info->nr_voices > 0) {\r\ninfo->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);\r\nif (!info->ch) {\r\nrec->oper.close(&info->arg);\r\nmodule_put(rec->oper.owner);\r\nsnd_use_lock_free(&rec->use_lock);\r\ncontinue;\r\n}\r\nreset_channels(info);\r\n}\r\ninfo->opened++;\r\nrec->opened++;\r\ndp->synth_opened++;\r\nsnd_use_lock_free(&rec->use_lock);\r\n}\r\n}\r\nvoid\r\nsnd_seq_oss_synth_setup_midi(struct seq_oss_devinfo *dp)\r\n{\r\nint i;\r\nif (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)\r\nreturn;\r\nfor (i = 0; i < dp->max_mididev; i++) {\r\nstruct seq_oss_synthinfo *info;\r\ninfo = &dp->synths[dp->max_synthdev];\r\nif (snd_seq_oss_midi_open(dp, i, dp->file_mode) < 0)\r\ncontinue;\r\ninfo->arg.app_index = dp->port;\r\ninfo->arg.file_mode = dp->file_mode;\r\ninfo->arg.seq_mode = dp->seq_mode;\r\ninfo->arg.private_data = info;\r\ninfo->is_midi = 1;\r\ninfo->midi_mapped = i;\r\ninfo->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;\r\nsnd_seq_oss_midi_get_addr(dp, i, &info->arg.addr);\r\ninfo->opened = 1;\r\nmidi_synth_dev.opened++;\r\ndp->max_synthdev++;\r\nif (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)\r\nbreak;\r\n}\r\n}\r\nvoid\r\nsnd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)\r\n{\r\nint i;\r\nstruct seq_oss_synth *rec;\r\nstruct seq_oss_synthinfo *info;\r\nif (snd_BUG_ON(dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))\r\nreturn;\r\nfor (i = 0; i < dp->max_synthdev; i++) {\r\ninfo = &dp->synths[i];\r\nif (! info->opened)\r\ncontinue;\r\nif (info->is_midi) {\r\nif (midi_synth_dev.opened > 0) {\r\nsnd_seq_oss_midi_close(dp, info->midi_mapped);\r\nmidi_synth_dev.opened--;\r\n}\r\n} else {\r\nrec = get_sdev(i);\r\nif (rec == NULL)\r\ncontinue;\r\nif (rec->opened > 0) {\r\nrec->oper.close(&info->arg);\r\nmodule_put(rec->oper.owner);\r\nrec->opened = 0;\r\n}\r\nsnd_use_lock_free(&rec->use_lock);\r\n}\r\nkfree(info->sysex);\r\ninfo->sysex = NULL;\r\nkfree(info->ch);\r\ninfo->ch = NULL;\r\n}\r\ndp->synth_opened = 0;\r\ndp->max_synthdev = 0;\r\n}\r\nstatic int\r\nis_midi_dev(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nif (dev < 0 || dev >= dp->max_synthdev)\r\nreturn 0;\r\nif (dp->synths[dev].is_midi)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct seq_oss_synth *\r\nget_synthdev(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_synth *rec;\r\nif (dev < 0 || dev >= dp->max_synthdev)\r\nreturn NULL;\r\nif (! dp->synths[dev].opened)\r\nreturn NULL;\r\nif (dp->synths[dev].is_midi)\r\nreturn &midi_synth_dev;\r\nif ((rec = get_sdev(dev)) == NULL)\r\nreturn NULL;\r\nif (! rec->opened) {\r\nsnd_use_lock_free(&rec->use_lock);\r\nreturn NULL;\r\n}\r\nreturn rec;\r\n}\r\nstatic void\r\nreset_channels(struct seq_oss_synthinfo *info)\r\n{\r\nint i;\r\nif (info->ch == NULL || ! info->nr_voices)\r\nreturn;\r\nfor (i = 0; i < info->nr_voices; i++) {\r\ninfo->ch[i].note = -1;\r\ninfo->ch[i].vel = 0;\r\n}\r\n}\r\nvoid\r\nsnd_seq_oss_synth_reset(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_synth *rec;\r\nstruct seq_oss_synthinfo *info;\r\nif (snd_BUG_ON(dev < 0 || dev >= dp->max_synthdev))\r\nreturn;\r\ninfo = &dp->synths[dev];\r\nif (! info->opened)\r\nreturn;\r\nif (info->sysex)\r\ninfo->sysex->len = 0;\r\nreset_channels(info);\r\nif (info->is_midi) {\r\nif (midi_synth_dev.opened <= 0)\r\nreturn;\r\nsnd_seq_oss_midi_reset(dp, info->midi_mapped);\r\nsnd_seq_oss_midi_close(dp, dev);\r\nif (snd_seq_oss_midi_open(dp, info->midi_mapped,\r\ndp->file_mode) < 0) {\r\nmidi_synth_dev.opened--;\r\ninfo->opened = 0;\r\nkfree(info->sysex);\r\ninfo->sysex = NULL;\r\nkfree(info->ch);\r\ninfo->ch = NULL;\r\n}\r\nreturn;\r\n}\r\nrec = get_sdev(dev);\r\nif (rec == NULL)\r\nreturn;\r\nif (rec->oper.reset) {\r\nrec->oper.reset(&info->arg);\r\n} else {\r\nstruct snd_seq_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nsnd_seq_oss_fill_addr(dp, &ev, info->arg.addr.client,\r\ninfo->arg.addr.port);\r\nev.type = SNDRV_SEQ_EVENT_RESET;\r\nsnd_seq_oss_dispatch(dp, &ev, 0, 0);\r\n}\r\nsnd_use_lock_free(&rec->use_lock);\r\n}\r\nint\r\nsnd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,\r\nconst char __user *buf, int p, int c)\r\n{\r\nstruct seq_oss_synth *rec;\r\nint rc;\r\nif (dev < 0 || dev >= dp->max_synthdev)\r\nreturn -ENXIO;\r\nif (is_midi_dev(dp, dev))\r\nreturn 0;\r\nif ((rec = get_synthdev(dp, dev)) == NULL)\r\nreturn -ENXIO;\r\nif (rec->oper.load_patch == NULL)\r\nrc = -ENXIO;\r\nelse\r\nrc = rec->oper.load_patch(&dp->synths[dev].arg, fmt, buf, p, c);\r\nsnd_use_lock_free(&rec->use_lock);\r\nreturn rc;\r\n}\r\nint\r\nsnd_seq_oss_synth_is_valid(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_synth *rec;\r\nrec = get_synthdev(dp, dev);\r\nif (rec) {\r\nsnd_use_lock_free(&rec->use_lock);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_synth_sysex(struct seq_oss_devinfo *dp, int dev, unsigned char *buf, struct snd_seq_event *ev)\r\n{\r\nint i, send;\r\nunsigned char *dest;\r\nstruct seq_oss_synth_sysex *sysex;\r\nif (! snd_seq_oss_synth_is_valid(dp, dev))\r\nreturn -ENXIO;\r\nsysex = dp->synths[dev].sysex;\r\nif (sysex == NULL) {\r\nsysex = kzalloc(sizeof(*sysex), GFP_KERNEL);\r\nif (sysex == NULL)\r\nreturn -ENOMEM;\r\ndp->synths[dev].sysex = sysex;\r\n}\r\nsend = 0;\r\ndest = sysex->buf + sysex->len;\r\nfor (i = 0; i < 6; i++) {\r\nif (buf[i] == 0xff) {\r\nsend = 1;\r\nbreak;\r\n}\r\ndest[i] = buf[i];\r\nsysex->len++;\r\nif (sysex->len >= MAX_SYSEX_BUFLEN) {\r\nsysex->len = 0;\r\nsysex->skip = 1;\r\nbreak;\r\n}\r\n}\r\nif (sysex->len && send) {\r\nif (sysex->skip) {\r\nsysex->skip = 0;\r\nsysex->len = 0;\r\nreturn -EINVAL;\r\n}\r\nev->flags = SNDRV_SEQ_EVENT_LENGTH_VARIABLE;\r\nif (snd_seq_oss_synth_addr(dp, dev, ev))\r\nreturn -EINVAL;\r\nev->data.ext.len = sysex->len;\r\nev->data.ext.ptr = sysex->buf;\r\nsysex->len = 0;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint\r\nsnd_seq_oss_synth_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_event *ev)\r\n{\r\nif (! snd_seq_oss_synth_is_valid(dp, dev))\r\nreturn -EINVAL;\r\nsnd_seq_oss_fill_addr(dp, ev, dp->synths[dev].arg.addr.client,\r\ndp->synths[dev].arg.addr.port);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_synth_ioctl(struct seq_oss_devinfo *dp, int dev, unsigned int cmd, unsigned long addr)\r\n{\r\nstruct seq_oss_synth *rec;\r\nint rc;\r\nif (is_midi_dev(dp, dev))\r\nreturn -ENXIO;\r\nif ((rec = get_synthdev(dp, dev)) == NULL)\r\nreturn -ENXIO;\r\nif (rec->oper.ioctl == NULL)\r\nrc = -ENXIO;\r\nelse\r\nrc = rec->oper.ioctl(&dp->synths[dev].arg, cmd, addr);\r\nsnd_use_lock_free(&rec->use_lock);\r\nreturn rc;\r\n}\r\nint\r\nsnd_seq_oss_synth_raw_event(struct seq_oss_devinfo *dp, int dev, unsigned char *data, struct snd_seq_event *ev)\r\n{\r\nif (! snd_seq_oss_synth_is_valid(dp, dev) || is_midi_dev(dp, dev))\r\nreturn -ENXIO;\r\nev->type = SNDRV_SEQ_EVENT_OSS;\r\nmemcpy(ev->data.raw8.d, data, 8);\r\nreturn snd_seq_oss_synth_addr(dp, dev, ev);\r\n}\r\nint\r\nsnd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\r\n{\r\nstruct seq_oss_synth *rec;\r\nif (dev < 0 || dev >= dp->max_synthdev)\r\nreturn -ENXIO;\r\nif (dp->synths[dev].is_midi) {\r\nstruct midi_info minf;\r\nsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\r\ninf->synth_type = SYNTH_TYPE_MIDI;\r\ninf->synth_subtype = 0;\r\ninf->nr_voices = 16;\r\ninf->device = dev;\r\nstrlcpy(inf->name, minf.name, sizeof(inf->name));\r\n} else {\r\nif ((rec = get_synthdev(dp, dev)) == NULL)\r\nreturn -ENXIO;\r\ninf->synth_type = rec->synth_type;\r\ninf->synth_subtype = rec->synth_subtype;\r\ninf->nr_voices = rec->nr_voices;\r\ninf->device = dev;\r\nstrlcpy(inf->name, rec->name, sizeof(inf->name));\r\nsnd_use_lock_free(&rec->use_lock);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_seq_oss_synth_info_read(struct snd_info_buffer *buf)\r\n{\r\nint i;\r\nstruct seq_oss_synth *rec;\r\nsnd_iprintf(buf, "\nNumber of synth devices: %d\n", max_synth_devs);\r\nfor (i = 0; i < max_synth_devs; i++) {\r\nsnd_iprintf(buf, "\nsynth %d: ", i);\r\nrec = get_sdev(i);\r\nif (rec == NULL) {\r\nsnd_iprintf(buf, "*empty*\n");\r\ncontinue;\r\n}\r\nsnd_iprintf(buf, "[%s]\n", rec->name);\r\nsnd_iprintf(buf, " type 0x%x : subtype 0x%x : voices %d\n",\r\nrec->synth_type, rec->synth_subtype,\r\nrec->nr_voices);\r\nsnd_iprintf(buf, " capabilities : ioctl %s / load_patch %s\n",\r\nenabled_str((long)rec->oper.ioctl),\r\nenabled_str((long)rec->oper.load_patch));\r\nsnd_use_lock_free(&rec->use_lock);\r\n}\r\n}
