static int fc_frame_drop(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nfc_frame_free(fp);\r\nreturn 0;\r\n}\r\nstatic void fc_lport_rport_callback(struct fc_lport *lport,\r\nstruct fc_rport_priv *rdata,\r\nenum fc_rport_event event)\r\n{\r\nFC_LPORT_DBG(lport, "Received a %d event for port (%6.6x)\n", event,\r\nrdata->ids.port_id);\r\nmutex_lock(&lport->lp_mutex);\r\nswitch (event) {\r\ncase RPORT_EV_READY:\r\nif (lport->state == LPORT_ST_DNS) {\r\nlport->dns_rdata = rdata;\r\nfc_lport_enter_ns(lport, LPORT_ST_RNN_ID);\r\n} else if (lport->state == LPORT_ST_FDMI) {\r\nlport->ms_rdata = rdata;\r\nfc_lport_enter_ms(lport, LPORT_ST_DHBA);\r\n} else {\r\nFC_LPORT_DBG(lport, "Received an READY event "\r\n"on port (%6.6x) for the directory "\r\n"server, but the lport is not "\r\n"in the DNS or FDMI state, it's in the "\r\n"%d state", rdata->ids.port_id,\r\nlport->state);\r\nlport->tt.rport_logoff(rdata);\r\n}\r\nbreak;\r\ncase RPORT_EV_LOGO:\r\ncase RPORT_EV_FAILED:\r\ncase RPORT_EV_STOP:\r\nif (rdata->ids.port_id == FC_FID_DIR_SERV)\r\nlport->dns_rdata = NULL;\r\nelse if (rdata->ids.port_id == FC_FID_MGMT_SERV)\r\nlport->ms_rdata = NULL;\r\nbreak;\r\ncase RPORT_EV_NONE:\r\nbreak;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic const char *fc_lport_state(struct fc_lport *lport)\r\n{\r\nconst char *cp;\r\ncp = fc_lport_state_names[lport->state];\r\nif (!cp)\r\ncp = "unknown";\r\nreturn cp;\r\n}\r\nstatic void fc_lport_ptp_setup(struct fc_lport *lport,\r\nu32 remote_fid, u64 remote_wwpn,\r\nu64 remote_wwnn)\r\n{\r\nmutex_lock(&lport->disc.disc_mutex);\r\nif (lport->ptp_rdata) {\r\nlport->tt.rport_logoff(lport->ptp_rdata);\r\nkref_put(&lport->ptp_rdata->kref, lport->tt.rport_destroy);\r\n}\r\nlport->ptp_rdata = lport->tt.rport_create(lport, remote_fid);\r\nkref_get(&lport->ptp_rdata->kref);\r\nlport->ptp_rdata->ids.port_name = remote_wwpn;\r\nlport->ptp_rdata->ids.node_name = remote_wwnn;\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nlport->tt.rport_login(lport->ptp_rdata);\r\nfc_lport_enter_ready(lport);\r\n}\r\nvoid fc_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct fc_lport *lport = shost_priv(shost);\r\nmutex_lock(&lport->lp_mutex);\r\nif (!lport->link_up)\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nelse\r\nswitch (lport->state) {\r\ncase LPORT_ST_READY:\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nbreak;\r\ndefault:\r\nfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nvoid fc_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct fc_lport *lport = shost_priv(shost);\r\nfc_host_speed(shost) = lport->link_speed;\r\n}\r\nstruct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *shost)\r\n{\r\nstruct fc_host_statistics *fc_stats;\r\nstruct fc_lport *lport = shost_priv(shost);\r\nstruct timespec v0, v1;\r\nunsigned int cpu;\r\nu64 fcp_in_bytes = 0;\r\nu64 fcp_out_bytes = 0;\r\nfc_stats = &lport->host_stats;\r\nmemset(fc_stats, 0, sizeof(struct fc_host_statistics));\r\njiffies_to_timespec(jiffies, &v0);\r\njiffies_to_timespec(lport->boot_time, &v1);\r\nfc_stats->seconds_since_last_reset = (v0.tv_sec - v1.tv_sec);\r\nfor_each_possible_cpu(cpu) {\r\nstruct fc_stats *stats;\r\nstats = per_cpu_ptr(lport->stats, cpu);\r\nfc_stats->tx_frames += stats->TxFrames;\r\nfc_stats->tx_words += stats->TxWords;\r\nfc_stats->rx_frames += stats->RxFrames;\r\nfc_stats->rx_words += stats->RxWords;\r\nfc_stats->error_frames += stats->ErrorFrames;\r\nfc_stats->invalid_crc_count += stats->InvalidCRCCount;\r\nfc_stats->fcp_input_requests += stats->InputRequests;\r\nfc_stats->fcp_output_requests += stats->OutputRequests;\r\nfc_stats->fcp_control_requests += stats->ControlRequests;\r\nfcp_in_bytes += stats->InputBytes;\r\nfcp_out_bytes += stats->OutputBytes;\r\nfc_stats->fcp_packet_alloc_failures += stats->FcpPktAllocFails;\r\nfc_stats->fcp_packet_aborts += stats->FcpPktAborts;\r\nfc_stats->fcp_frame_alloc_failures += stats->FcpFrameAllocFails;\r\nfc_stats->link_failure_count += stats->LinkFailureCount;\r\n}\r\nfc_stats->fcp_input_megabytes = div_u64(fcp_in_bytes, 1000000);\r\nfc_stats->fcp_output_megabytes = div_u64(fcp_out_bytes, 1000000);\r\nfc_stats->lip_count = -1;\r\nfc_stats->nos_count = -1;\r\nfc_stats->loss_of_sync_count = -1;\r\nfc_stats->loss_of_signal_count = -1;\r\nfc_stats->prim_seq_protocol_err_count = -1;\r\nfc_stats->dumped_frames = -1;\r\nfc_exch_update_stats(lport);\r\nreturn fc_stats;\r\n}\r\nstatic void fc_lport_flogi_fill(struct fc_lport *lport,\r\nstruct fc_els_flogi *flogi,\r\nunsigned int op)\r\n{\r\nstruct fc_els_csp *sp;\r\nstruct fc_els_cssp *cp;\r\nmemset(flogi, 0, sizeof(*flogi));\r\nflogi->fl_cmd = (u8) op;\r\nput_unaligned_be64(lport->wwpn, &flogi->fl_wwpn);\r\nput_unaligned_be64(lport->wwnn, &flogi->fl_wwnn);\r\nsp = &flogi->fl_csp;\r\nsp->sp_hi_ver = 0x20;\r\nsp->sp_lo_ver = 0x20;\r\nsp->sp_bb_cred = htons(10);\r\nsp->sp_bb_data = htons((u16) lport->mfs);\r\ncp = &flogi->fl_cssp[3 - 1];\r\ncp->cp_class = htons(FC_CPC_VALID | FC_CPC_SEQ);\r\nif (op != ELS_FLOGI) {\r\nsp->sp_features = htons(FC_SP_FT_CIRO);\r\nsp->sp_tot_seq = htons(255);\r\nsp->sp_rel_off = htons(0x1f);\r\nsp->sp_e_d_tov = htonl(lport->e_d_tov);\r\ncp->cp_rdfs = htons((u16) lport->mfs);\r\ncp->cp_con_seq = htons(255);\r\ncp->cp_open_seq = 1;\r\n}\r\n}\r\nstatic void fc_lport_add_fc4_type(struct fc_lport *lport, enum fc_fh_type type)\r\n{\r\n__be32 *mp;\r\nmp = &lport->fcts.ff_type_map[type / FC_NS_BPW];\r\n*mp = htonl(ntohl(*mp) | 1UL << (type % FC_NS_BPW));\r\n}\r\nstatic void fc_lport_recv_rlir_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nFC_LPORT_DBG(lport, "Received RLIR request while in state %s\n",\r\nfc_lport_state(lport));\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_lport_recv_echo_req(struct fc_lport *lport,\r\nstruct fc_frame *in_fp)\r\n{\r\nstruct fc_frame *fp;\r\nunsigned int len;\r\nvoid *pp;\r\nvoid *dp;\r\nFC_LPORT_DBG(lport, "Received ECHO request while in state %s\n",\r\nfc_lport_state(lport));\r\nlen = fr_len(in_fp) - sizeof(struct fc_frame_header);\r\npp = fc_frame_payload_get(in_fp, len);\r\nif (len < sizeof(__be32))\r\nlen = sizeof(__be32);\r\nfp = fc_frame_alloc(lport, len);\r\nif (fp) {\r\ndp = fc_frame_payload_get(fp, len);\r\nmemcpy(dp, pp, len);\r\n*((__be32 *)dp) = htonl(ELS_LS_ACC << 24);\r\nfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\n}\r\nfc_frame_free(in_fp);\r\n}\r\nstatic void fc_lport_recv_rnid_req(struct fc_lport *lport,\r\nstruct fc_frame *in_fp)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_els_rnid *req;\r\nstruct {\r\nstruct fc_els_rnid_resp rnid;\r\nstruct fc_els_rnid_cid cid;\r\nstruct fc_els_rnid_gen gen;\r\n} *rp;\r\nstruct fc_seq_els_data rjt_data;\r\nu8 fmt;\r\nsize_t len;\r\nFC_LPORT_DBG(lport, "Received RNID request while in state %s\n",\r\nfc_lport_state(lport));\r\nreq = fc_frame_payload_get(in_fp, sizeof(*req));\r\nif (!req) {\r\nrjt_data.reason = ELS_RJT_LOGIC;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\nlport->tt.seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);\r\n} else {\r\nfmt = req->rnid_fmt;\r\nlen = sizeof(*rp);\r\nif (fmt != ELS_RNIDF_GEN ||\r\nntohl(lport->rnid_gen.rnid_atype) == 0) {\r\nfmt = ELS_RNIDF_NONE;\r\nlen -= sizeof(rp->gen);\r\n}\r\nfp = fc_frame_alloc(lport, len);\r\nif (fp) {\r\nrp = fc_frame_payload_get(fp, len);\r\nmemset(rp, 0, len);\r\nrp->rnid.rnid_cmd = ELS_LS_ACC;\r\nrp->rnid.rnid_fmt = fmt;\r\nrp->rnid.rnid_cid_len = sizeof(rp->cid);\r\nrp->cid.rnid_wwpn = htonll(lport->wwpn);\r\nrp->cid.rnid_wwnn = htonll(lport->wwnn);\r\nif (fmt == ELS_RNIDF_GEN) {\r\nrp->rnid.rnid_sid_len = sizeof(rp->gen);\r\nmemcpy(&rp->gen, &lport->rnid_gen,\r\nsizeof(rp->gen));\r\n}\r\nfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\n}\r\n}\r\nfc_frame_free(in_fp);\r\n}\r\nstatic void fc_lport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\r\nfc_lport_enter_reset(lport);\r\nfc_frame_free(fp);\r\n}\r\nint fc_fabric_login(struct fc_lport *lport)\r\n{\r\nint rc = -1;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state == LPORT_ST_DISABLED ||\r\nlport->state == LPORT_ST_LOGO) {\r\nfc_lport_state_enter(lport, LPORT_ST_RESET);\r\nfc_lport_enter_reset(lport);\r\nrc = 0;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\nreturn rc;\r\n}\r\nvoid __fc_linkup(struct fc_lport *lport)\r\n{\r\nif (!lport->link_up) {\r\nlport->link_up = 1;\r\nif (lport->state == LPORT_ST_RESET)\r\nfc_lport_enter_flogi(lport);\r\n}\r\n}\r\nvoid fc_linkup(struct fc_lport *lport)\r\n{\r\nprintk(KERN_INFO "host%d: libfc: Link up on port (%6.6x)\n",\r\nlport->host->host_no, lport->port_id);\r\nmutex_lock(&lport->lp_mutex);\r\n__fc_linkup(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nvoid __fc_linkdown(struct fc_lport *lport)\r\n{\r\nif (lport->link_up) {\r\nlport->link_up = 0;\r\nfc_lport_enter_reset(lport);\r\nlport->tt.fcp_cleanup(lport);\r\n}\r\n}\r\nvoid fc_linkdown(struct fc_lport *lport)\r\n{\r\nprintk(KERN_INFO "host%d: libfc: Link down on port (%6.6x)\n",\r\nlport->host->host_no, lport->port_id);\r\nmutex_lock(&lport->lp_mutex);\r\n__fc_linkdown(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nint fc_fabric_logoff(struct fc_lport *lport)\r\n{\r\nlport->tt.disc_stop_final(lport);\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->dns_rdata)\r\nlport->tt.rport_logoff(lport->dns_rdata);\r\nmutex_unlock(&lport->lp_mutex);\r\nlport->tt.rport_flush_queue();\r\nmutex_lock(&lport->lp_mutex);\r\nfc_lport_enter_logo(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\ncancel_delayed_work_sync(&lport->retry_work);\r\nreturn 0;\r\n}\r\nint fc_lport_destroy(struct fc_lport *lport)\r\n{\r\nmutex_lock(&lport->lp_mutex);\r\nlport->state = LPORT_ST_DISABLED;\r\nlport->link_up = 0;\r\nlport->tt.frame_send = fc_frame_drop;\r\nmutex_unlock(&lport->lp_mutex);\r\nlport->tt.fcp_abort_io(lport);\r\nlport->tt.disc_stop_final(lport);\r\nlport->tt.exch_mgr_reset(lport, 0, 0);\r\ncancel_delayed_work_sync(&lport->retry_work);\r\nfc_fc4_del_lport(lport);\r\nreturn 0;\r\n}\r\nint fc_set_mfs(struct fc_lport *lport, u32 mfs)\r\n{\r\nunsigned int old_mfs;\r\nint rc = -EINVAL;\r\nmutex_lock(&lport->lp_mutex);\r\nold_mfs = lport->mfs;\r\nif (mfs >= FC_MIN_MAX_FRAME) {\r\nmfs &= ~3;\r\nif (mfs > FC_MAX_FRAME)\r\nmfs = FC_MAX_FRAME;\r\nmfs -= sizeof(struct fc_frame_header);\r\nlport->mfs = mfs;\r\nrc = 0;\r\n}\r\nif (!rc && mfs < old_mfs)\r\nfc_lport_enter_reset(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\nreturn rc;\r\n}\r\nstatic void fc_lport_disc_callback(struct fc_lport *lport,\r\nenum fc_disc_event event)\r\n{\r\nswitch (event) {\r\ncase DISC_EV_SUCCESS:\r\nFC_LPORT_DBG(lport, "Discovery succeeded\n");\r\nbreak;\r\ncase DISC_EV_FAILED:\r\nprintk(KERN_ERR "host%d: libfc: "\r\n"Discovery failed for port (%6.6x)\n",\r\nlport->host->host_no, lport->port_id);\r\nmutex_lock(&lport->lp_mutex);\r\nfc_lport_enter_reset(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\nbreak;\r\ncase DISC_EV_NONE:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void fc_lport_enter_ready(struct fc_lport *lport)\r\n{\r\nFC_LPORT_DBG(lport, "Entered READY from state %s\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_READY);\r\nif (lport->vport)\r\nfc_vport_set_state(lport->vport, FC_VPORT_ACTIVE);\r\nfc_vports_linkchange(lport);\r\nif (!lport->ptp_rdata)\r\nlport->tt.disc_start(fc_lport_disc_callback, lport);\r\n}\r\nstatic void fc_lport_set_port_id(struct fc_lport *lport, u32 port_id,\r\nstruct fc_frame *fp)\r\n{\r\nif (port_id)\r\nprintk(KERN_INFO "host%d: Assigned Port ID %6.6x\n",\r\nlport->host->host_no, port_id);\r\nlport->port_id = port_id;\r\nfc_host_port_id(lport->host) = port_id;\r\nif (lport->tt.lport_set_port_id)\r\nlport->tt.lport_set_port_id(lport, port_id, fp);\r\n}\r\nvoid fc_lport_set_local_id(struct fc_lport *lport, u32 port_id)\r\n{\r\nmutex_lock(&lport->lp_mutex);\r\nfc_lport_set_port_id(lport, port_id, NULL);\r\nswitch (lport->state) {\r\ncase LPORT_ST_RESET:\r\ncase LPORT_ST_FLOGI:\r\nif (port_id)\r\nfc_lport_enter_ready(lport);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_recv_flogi_req(struct fc_lport *lport,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *fh;\r\nstruct fc_els_flogi *flp;\r\nstruct fc_els_flogi *new_flp;\r\nu64 remote_wwpn;\r\nu32 remote_fid;\r\nu32 local_fid;\r\nFC_LPORT_DBG(lport, "Received FLOGI request while in state %s\n",\r\nfc_lport_state(lport));\r\nremote_fid = fc_frame_sid(rx_fp);\r\nflp = fc_frame_payload_get(rx_fp, sizeof(*flp));\r\nif (!flp)\r\ngoto out;\r\nremote_wwpn = get_unaligned_be64(&flp->fl_wwpn);\r\nif (remote_wwpn == lport->wwpn) {\r\nprintk(KERN_WARNING "host%d: libfc: Received FLOGI from port "\r\n"with same WWPN %16.16llx\n",\r\nlport->host->host_no, remote_wwpn);\r\ngoto out;\r\n}\r\nFC_LPORT_DBG(lport, "FLOGI from port WWPN %16.16llx\n", remote_wwpn);\r\nlocal_fid = FC_LOCAL_PTP_FID_LO;\r\nif (remote_wwpn < lport->wwpn) {\r\nlocal_fid = FC_LOCAL_PTP_FID_HI;\r\nif (!remote_fid || remote_fid == local_fid)\r\nremote_fid = FC_LOCAL_PTP_FID_LO;\r\n} else if (!remote_fid) {\r\nremote_fid = FC_LOCAL_PTP_FID_HI;\r\n}\r\nfc_lport_set_port_id(lport, local_fid, rx_fp);\r\nfp = fc_frame_alloc(lport, sizeof(*flp));\r\nif (fp) {\r\nnew_flp = fc_frame_payload_get(fp, sizeof(*flp));\r\nfc_lport_flogi_fill(lport, new_flp, ELS_FLOGI);\r\nnew_flp->fl_cmd = (u8) ELS_LS_ACC;\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nfh = fc_frame_header_get(fp);\r\nhton24(fh->fh_s_id, local_fid);\r\nhton24(fh->fh_d_id, remote_fid);\r\nlport->tt.frame_send(lport, fp);\r\n} else {\r\nfc_lport_error(lport, fp);\r\n}\r\nfc_lport_ptp_setup(lport, remote_fid, remote_wwpn,\r\nget_unaligned_be64(&flp->fl_wwnn));\r\nout:\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic void fc_lport_recv_els_req(struct fc_lport *lport,\r\nstruct fc_frame *fp)\r\n{\r\nvoid (*recv)(struct fc_lport *, struct fc_frame *);\r\nmutex_lock(&lport->lp_mutex);\r\nif (!lport->link_up)\r\nfc_frame_free(fp);\r\nelse {\r\nrecv = lport->tt.rport_recv_req;\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_FLOGI:\r\nif (!lport->point_to_multipoint)\r\nrecv = fc_lport_recv_flogi_req;\r\nbreak;\r\ncase ELS_LOGO:\r\nif (fc_frame_sid(fp) == FC_FID_FLOGI)\r\nrecv = fc_lport_recv_logo_req;\r\nbreak;\r\ncase ELS_RSCN:\r\nrecv = lport->tt.disc_recv_req;\r\nbreak;\r\ncase ELS_ECHO:\r\nrecv = fc_lport_recv_echo_req;\r\nbreak;\r\ncase ELS_RLIR:\r\nrecv = fc_lport_recv_rlir_req;\r\nbreak;\r\ncase ELS_RNID:\r\nrecv = fc_lport_recv_rnid_req;\r\nbreak;\r\n}\r\nrecv(lport, fp);\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic int fc_lport_els_prli(struct fc_rport_priv *rdata, u32 spp_len,\r\nconst struct fc_els_spp *spp_in,\r\nstruct fc_els_spp *spp_out)\r\n{\r\nreturn FC_SPP_RESP_INVL;\r\n}\r\nstatic void fc_lport_recv_req(struct fc_lport *lport,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_seq *sp = fr_seq(fp);\r\nstruct fc4_prov *prov;\r\nrcu_read_lock();\r\nif (fh->fh_type >= FC_FC4_PROV_SIZE)\r\ngoto drop;\r\nprov = rcu_dereference(fc_passive_prov[fh->fh_type]);\r\nif (!prov || !try_module_get(prov->module))\r\ngoto drop;\r\nrcu_read_unlock();\r\nprov->recv(lport, fp);\r\nmodule_put(prov->module);\r\nreturn;\r\ndrop:\r\nrcu_read_unlock();\r\nFC_LPORT_DBG(lport, "dropping unexpected frame type %x\n", fh->fh_type);\r\nfc_frame_free(fp);\r\nif (sp)\r\nlport->tt.exch_done(sp);\r\n}\r\nint fc_lport_reset(struct fc_lport *lport)\r\n{\r\ncancel_delayed_work_sync(&lport->retry_work);\r\nmutex_lock(&lport->lp_mutex);\r\nfc_lport_enter_reset(lport);\r\nmutex_unlock(&lport->lp_mutex);\r\nreturn 0;\r\n}\r\nstatic void fc_lport_reset_locked(struct fc_lport *lport)\r\n{\r\nif (lport->dns_rdata)\r\nlport->tt.rport_logoff(lport->dns_rdata);\r\nif (lport->ptp_rdata) {\r\nlport->tt.rport_logoff(lport->ptp_rdata);\r\nkref_put(&lport->ptp_rdata->kref, lport->tt.rport_destroy);\r\nlport->ptp_rdata = NULL;\r\n}\r\nlport->tt.disc_stop(lport);\r\nlport->tt.exch_mgr_reset(lport, 0, 0);\r\nfc_host_fabric_name(lport->host) = 0;\r\nif (lport->port_id && (!lport->point_to_multipoint || !lport->link_up))\r\nfc_lport_set_port_id(lport, 0, NULL);\r\n}\r\nstatic void fc_lport_enter_reset(struct fc_lport *lport)\r\n{\r\nFC_LPORT_DBG(lport, "Entered RESET state from %s state\n",\r\nfc_lport_state(lport));\r\nif (lport->state == LPORT_ST_DISABLED || lport->state == LPORT_ST_LOGO)\r\nreturn;\r\nif (lport->vport) {\r\nif (lport->link_up)\r\nfc_vport_set_state(lport->vport, FC_VPORT_INITIALIZING);\r\nelse\r\nfc_vport_set_state(lport->vport, FC_VPORT_LINKDOWN);\r\n}\r\nfc_lport_state_enter(lport, LPORT_ST_RESET);\r\nfc_host_post_event(lport->host, fc_get_event_number(),\r\nFCH_EVT_LIPRESET, 0);\r\nfc_vports_linkchange(lport);\r\nfc_lport_reset_locked(lport);\r\nif (lport->link_up)\r\nfc_lport_enter_flogi(lport);\r\n}\r\nstatic void fc_lport_enter_disabled(struct fc_lport *lport)\r\n{\r\nFC_LPORT_DBG(lport, "Entered disabled state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_DISABLED);\r\nfc_vports_linkchange(lport);\r\nfc_lport_reset_locked(lport);\r\n}\r\nstatic void fc_lport_error(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nunsigned long delay = 0;\r\nFC_LPORT_DBG(lport, "Error %ld in state %s, retries %d\n",\r\nIS_ERR(fp) ? -PTR_ERR(fp) : 0, fc_lport_state(lport),\r\nlport->retry_count);\r\nif (PTR_ERR(fp) == -FC_EX_CLOSED)\r\nreturn;\r\nif (lport->retry_count < lport->max_retry_count) {\r\nlport->retry_count++;\r\nif (!fp)\r\ndelay = msecs_to_jiffies(500);\r\nelse\r\ndelay = msecs_to_jiffies(lport->e_d_tov);\r\nschedule_delayed_work(&lport->retry_work, delay);\r\n} else\r\nfc_lport_enter_reset(lport);\r\n}\r\nstatic void fc_lport_ns_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lp_arg)\r\n{\r\nstruct fc_lport *lport = lp_arg;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ct_hdr *ct;\r\nFC_LPORT_DBG(lport, "Received a ns %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\nreturn;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state < LPORT_ST_RNN_ID || lport->state > LPORT_ST_RFF_ID) {\r\nFC_LPORT_DBG(lport, "Received a name server response, "\r\n"but in state %s\n", fc_lport_state(lport));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nct = fc_frame_payload_get(fp, sizeof(*ct));\r\nif (fh && ct && fh->fh_type == FC_TYPE_CT &&\r\nct->ct_fs_type == FC_FST_DIR &&\r\nct->ct_fs_subtype == FC_NS_SUBTYPE &&\r\nntohs(ct->ct_cmd) == FC_FS_ACC)\r\nswitch (lport->state) {\r\ncase LPORT_ST_RNN_ID:\r\nfc_lport_enter_ns(lport, LPORT_ST_RSNN_NN);\r\nbreak;\r\ncase LPORT_ST_RSNN_NN:\r\nfc_lport_enter_ns(lport, LPORT_ST_RSPN_ID);\r\nbreak;\r\ncase LPORT_ST_RSPN_ID:\r\nfc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\r\nbreak;\r\ncase LPORT_ST_RFT_ID:\r\nfc_lport_enter_ns(lport, LPORT_ST_RFF_ID);\r\nbreak;\r\ncase LPORT_ST_RFF_ID:\r\nif (lport->fdmi_enabled)\r\nfc_lport_enter_fdmi(lport);\r\nelse\r\nfc_lport_enter_scr(lport);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nelse\r\nfc_lport_error(lport, fp);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_ms_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lp_arg)\r\n{\r\nstruct fc_lport *lport = lp_arg;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ct_hdr *ct;\r\nFC_LPORT_DBG(lport, "Received a ms %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\nreturn;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state < LPORT_ST_RHBA || lport->state > LPORT_ST_DPRT) {\r\nFC_LPORT_DBG(lport, "Received a management server response, "\r\n"but in state %s\n", fc_lport_state(lport));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nct = fc_frame_payload_get(fp, sizeof(*ct));\r\nif (fh && ct && fh->fh_type == FC_TYPE_CT &&\r\nct->ct_fs_type == FC_FST_MGMT &&\r\nct->ct_fs_subtype == FC_FDMI_SUBTYPE) {\r\nFC_LPORT_DBG(lport, "Received a management server response, "\r\n"reason=%d explain=%d\n",\r\nct->ct_reason,\r\nct->ct_explan);\r\nswitch (lport->state) {\r\ncase LPORT_ST_RHBA:\r\nif (ntohs(ct->ct_cmd) == FC_FS_ACC)\r\nfc_lport_enter_ms(lport, LPORT_ST_RPA);\r\nelse\r\nfc_lport_enter_scr(lport);\r\nbreak;\r\ncase LPORT_ST_RPA:\r\nfc_lport_enter_scr(lport);\r\nbreak;\r\ncase LPORT_ST_DPRT:\r\nfc_lport_enter_ms(lport, LPORT_ST_RHBA);\r\nbreak;\r\ncase LPORT_ST_DHBA:\r\nfc_lport_enter_ms(lport, LPORT_ST_DPRT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nfc_lport_error(lport, fp);\r\n}\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_scr_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lp_arg)\r\n{\r\nstruct fc_lport *lport = lp_arg;\r\nu8 op;\r\nFC_LPORT_DBG(lport, "Received a SCR %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\nreturn;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state != LPORT_ST_SCR) {\r\nFC_LPORT_DBG(lport, "Received a SCR response, but in state "\r\n"%s\n", fc_lport_state(lport));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC)\r\nfc_lport_enter_ready(lport);\r\nelse\r\nfc_lport_error(lport, fp);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_enter_scr(struct fc_lport *lport)\r\n{\r\nstruct fc_frame *fp;\r\nFC_LPORT_DBG(lport, "Entered SCR state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_SCR);\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_scr));\r\nif (!fp) {\r\nfc_lport_error(lport, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, FC_FID_FCTRL, fp, ELS_SCR,\r\nfc_lport_scr_resp, lport,\r\n2 * lport->r_a_tov))\r\nfc_lport_error(lport, NULL);\r\n}\r\nstatic void fc_lport_enter_ns(struct fc_lport *lport, enum fc_lport_state state)\r\n{\r\nstruct fc_frame *fp;\r\nenum fc_ns_req cmd;\r\nint size = sizeof(struct fc_ct_hdr);\r\nsize_t len;\r\nFC_LPORT_DBG(lport, "Entered %s state from %s state\n",\r\nfc_lport_state_names[state],\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, state);\r\nswitch (state) {\r\ncase LPORT_ST_RNN_ID:\r\ncmd = FC_NS_RNN_ID;\r\nsize += sizeof(struct fc_ns_rn_id);\r\nbreak;\r\ncase LPORT_ST_RSNN_NN:\r\nlen = strnlen(fc_host_symbolic_name(lport->host), 255);\r\nif (!len)\r\nreturn fc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\r\ncmd = FC_NS_RSNN_NN;\r\nsize += sizeof(struct fc_ns_rsnn) + len;\r\nbreak;\r\ncase LPORT_ST_RSPN_ID:\r\nlen = strnlen(fc_host_symbolic_name(lport->host), 255);\r\nif (!len)\r\nreturn fc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\r\ncmd = FC_NS_RSPN_ID;\r\nsize += sizeof(struct fc_ns_rspn) + len;\r\nbreak;\r\ncase LPORT_ST_RFT_ID:\r\ncmd = FC_NS_RFT_ID;\r\nsize += sizeof(struct fc_ns_rft);\r\nbreak;\r\ncase LPORT_ST_RFF_ID:\r\ncmd = FC_NS_RFF_ID;\r\nsize += sizeof(struct fc_ns_rff_id);\r\nbreak;\r\ndefault:\r\nfc_lport_error(lport, NULL);\r\nreturn;\r\n}\r\nfp = fc_frame_alloc(lport, size);\r\nif (!fp) {\r\nfc_lport_error(lport, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, cmd,\r\nfc_lport_ns_resp,\r\nlport, 3 * lport->r_a_tov))\r\nfc_lport_error(lport, fp);\r\n}\r\nstatic void fc_lport_enter_dns(struct fc_lport *lport)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nFC_LPORT_DBG(lport, "Entered DNS state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_DNS);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_create(lport, FC_FID_DIR_SERV);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nif (!rdata)\r\ngoto err;\r\nrdata->ops = &fc_lport_rport_ops;\r\nlport->tt.rport_login(rdata);\r\nreturn;\r\nerr:\r\nfc_lport_error(lport, NULL);\r\n}\r\nstatic void fc_lport_enter_ms(struct fc_lport *lport, enum fc_lport_state state)\r\n{\r\nstruct fc_frame *fp;\r\nenum fc_fdmi_req cmd;\r\nint size = sizeof(struct fc_ct_hdr);\r\nsize_t len;\r\nint numattrs;\r\nFC_LPORT_DBG(lport, "Entered %s state from %s state\n",\r\nfc_lport_state_names[state],\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, state);\r\nswitch (state) {\r\ncase LPORT_ST_RHBA:\r\ncmd = FC_FDMI_RHBA;\r\nnumattrs = 10;\r\nlen = sizeof(struct fc_fdmi_rhba);\r\nlen -= sizeof(struct fc_fdmi_attr_entry);\r\nlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\r\nlen += FC_FDMI_HBA_ATTR_NODENAME_LEN;\r\nlen += FC_FDMI_HBA_ATTR_MANUFACTURER_LEN;\r\nlen += FC_FDMI_HBA_ATTR_SERIALNUMBER_LEN;\r\nlen += FC_FDMI_HBA_ATTR_MODEL_LEN;\r\nlen += FC_FDMI_HBA_ATTR_MODELDESCR_LEN;\r\nlen += FC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN;\r\nlen += FC_FDMI_HBA_ATTR_DRIVERVERSION_LEN;\r\nlen += FC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN;\r\nlen += FC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN;\r\nlen += FC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN;\r\nsize += len;\r\nbreak;\r\ncase LPORT_ST_RPA:\r\ncmd = FC_FDMI_RPA;\r\nnumattrs = 6;\r\nlen = sizeof(struct fc_fdmi_rpa);\r\nlen -= sizeof(struct fc_fdmi_attr_entry);\r\nlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\r\nlen += FC_FDMI_PORT_ATTR_FC4TYPES_LEN;\r\nlen += FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN;\r\nlen += FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN;\r\nlen += FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN;\r\nlen += FC_FDMI_PORT_ATTR_OSDEVICENAME_LEN;\r\nlen += FC_FDMI_PORT_ATTR_HOSTNAME_LEN;\r\nsize += len;\r\nbreak;\r\ncase LPORT_ST_DPRT:\r\ncmd = FC_FDMI_DPRT;\r\nlen = sizeof(struct fc_fdmi_dprt);\r\nsize += len;\r\nbreak;\r\ncase LPORT_ST_DHBA:\r\ncmd = FC_FDMI_DHBA;\r\nlen = sizeof(struct fc_fdmi_dhba);\r\nsize += len;\r\nbreak;\r\ndefault:\r\nfc_lport_error(lport, NULL);\r\nreturn;\r\n}\r\nFC_LPORT_DBG(lport, "Cmd=0x%x Len %d size %d\n",\r\ncmd, (int)len, size);\r\nfp = fc_frame_alloc(lport, size);\r\nif (!fp) {\r\nfc_lport_error(lport, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, FC_FID_MGMT_SERV, fp, cmd,\r\nfc_lport_ms_resp,\r\nlport, 3 * lport->r_a_tov))\r\nfc_lport_error(lport, fp);\r\n}\r\nstatic void fc_lport_enter_fdmi(struct fc_lport *lport)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nFC_LPORT_DBG(lport, "Entered FDMI state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_FDMI);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_create(lport, FC_FID_MGMT_SERV);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nif (!rdata)\r\ngoto err;\r\nrdata->ops = &fc_lport_rport_ops;\r\nlport->tt.rport_login(rdata);\r\nreturn;\r\nerr:\r\nfc_lport_error(lport, NULL);\r\n}\r\nstatic void fc_lport_timeout(struct work_struct *work)\r\n{\r\nstruct fc_lport *lport =\r\ncontainer_of(work, struct fc_lport,\r\nretry_work.work);\r\nmutex_lock(&lport->lp_mutex);\r\nswitch (lport->state) {\r\ncase LPORT_ST_DISABLED:\r\nbreak;\r\ncase LPORT_ST_READY:\r\nbreak;\r\ncase LPORT_ST_RESET:\r\nbreak;\r\ncase LPORT_ST_FLOGI:\r\nfc_lport_enter_flogi(lport);\r\nbreak;\r\ncase LPORT_ST_DNS:\r\nfc_lport_enter_dns(lport);\r\nbreak;\r\ncase LPORT_ST_RNN_ID:\r\ncase LPORT_ST_RSNN_NN:\r\ncase LPORT_ST_RSPN_ID:\r\ncase LPORT_ST_RFT_ID:\r\ncase LPORT_ST_RFF_ID:\r\nfc_lport_enter_ns(lport, lport->state);\r\nbreak;\r\ncase LPORT_ST_FDMI:\r\nfc_lport_enter_fdmi(lport);\r\nbreak;\r\ncase LPORT_ST_RHBA:\r\ncase LPORT_ST_RPA:\r\ncase LPORT_ST_DHBA:\r\ncase LPORT_ST_DPRT:\r\nFC_LPORT_DBG(lport, "Skipping lport state %s to SCR\n",\r\nfc_lport_state(lport));\r\ncase LPORT_ST_SCR:\r\nfc_lport_enter_scr(lport);\r\nbreak;\r\ncase LPORT_ST_LOGO:\r\nfc_lport_enter_logo(lport);\r\nbreak;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nvoid fc_lport_logo_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lp_arg)\r\n{\r\nstruct fc_lport *lport = lp_arg;\r\nu8 op;\r\nFC_LPORT_DBG(lport, "Received a LOGO %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\nreturn;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state != LPORT_ST_LOGO) {\r\nFC_LPORT_DBG(lport, "Received a LOGO response, but in state "\r\n"%s\n", fc_lport_state(lport));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC)\r\nfc_lport_enter_disabled(lport);\r\nelse\r\nfc_lport_error(lport, fp);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_enter_logo(struct fc_lport *lport)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_els_logo *logo;\r\nFC_LPORT_DBG(lport, "Entered LOGO state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_LOGO);\r\nfc_vports_linkchange(lport);\r\nfp = fc_frame_alloc(lport, sizeof(*logo));\r\nif (!fp) {\r\nfc_lport_error(lport, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp, ELS_LOGO,\r\nfc_lport_logo_resp, lport,\r\n2 * lport->r_a_tov))\r\nfc_lport_error(lport, NULL);\r\n}\r\nvoid fc_lport_flogi_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lp_arg)\r\n{\r\nstruct fc_lport *lport = lp_arg;\r\nstruct fc_frame_header *fh;\r\nstruct fc_els_flogi *flp;\r\nu32 did;\r\nu16 csp_flags;\r\nunsigned int r_a_tov;\r\nunsigned int e_d_tov;\r\nu16 mfs;\r\nFC_LPORT_DBG(lport, "Received a FLOGI %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\nreturn;\r\nmutex_lock(&lport->lp_mutex);\r\nif (lport->state != LPORT_ST_FLOGI) {\r\nFC_LPORT_DBG(lport, "Received a FLOGI response, but in state "\r\n"%s\n", fc_lport_state(lport));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nfh = fc_frame_header_get(fp);\r\ndid = fc_frame_did(fp);\r\nif (fh->fh_r_ctl != FC_RCTL_ELS_REP || did == 0 ||\r\nfc_frame_payload_op(fp) != ELS_LS_ACC) {\r\nFC_LPORT_DBG(lport, "FLOGI not accepted or bad response\n");\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nflp = fc_frame_payload_get(fp, sizeof(*flp));\r\nif (!flp) {\r\nFC_LPORT_DBG(lport, "FLOGI bad response\n");\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nmfs = ntohs(flp->fl_csp.sp_bb_data) &\r\nFC_SP_BB_DATA_MASK;\r\nif (mfs < FC_SP_MIN_MAX_PAYLOAD || mfs > FC_SP_MAX_MAX_PAYLOAD) {\r\nFC_LPORT_DBG(lport, "FLOGI bad mfs:%hu response, "\r\n"lport->mfs:%hu\n", mfs, lport->mfs);\r\nfc_lport_error(lport, fp);\r\ngoto err;\r\n}\r\nif (mfs <= lport->mfs) {\r\nlport->mfs = mfs;\r\nfc_host_maxframe_size(lport->host) = mfs;\r\n}\r\ncsp_flags = ntohs(flp->fl_csp.sp_features);\r\nr_a_tov = ntohl(flp->fl_csp.sp_r_a_tov);\r\ne_d_tov = ntohl(flp->fl_csp.sp_e_d_tov);\r\nif (csp_flags & FC_SP_FT_EDTR)\r\ne_d_tov /= 1000000;\r\nlport->npiv_enabled = !!(csp_flags & FC_SP_FT_NPIV_ACC);\r\nif ((csp_flags & FC_SP_FT_FPORT) == 0) {\r\nif (e_d_tov > lport->e_d_tov)\r\nlport->e_d_tov = e_d_tov;\r\nlport->r_a_tov = 2 * e_d_tov;\r\nfc_lport_set_port_id(lport, did, fp);\r\nprintk(KERN_INFO "host%d: libfc: "\r\n"Port (%6.6x) entered "\r\n"point-to-point mode\n",\r\nlport->host->host_no, did);\r\nfc_lport_ptp_setup(lport, fc_frame_sid(fp),\r\nget_unaligned_be64(\r\n&flp->fl_wwpn),\r\nget_unaligned_be64(\r\n&flp->fl_wwnn));\r\n} else {\r\nlport->e_d_tov = e_d_tov;\r\nlport->r_a_tov = r_a_tov;\r\nfc_host_fabric_name(lport->host) =\r\nget_unaligned_be64(&flp->fl_wwnn);\r\nfc_lport_set_port_id(lport, did, fp);\r\nfc_lport_enter_dns(lport);\r\n}\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic void fc_lport_enter_flogi(struct fc_lport *lport)\r\n{\r\nstruct fc_frame *fp;\r\nFC_LPORT_DBG(lport, "Entered FLOGI state from %s state\n",\r\nfc_lport_state(lport));\r\nfc_lport_state_enter(lport, LPORT_ST_FLOGI);\r\nif (lport->point_to_multipoint) {\r\nif (lport->port_id)\r\nfc_lport_enter_ready(lport);\r\nreturn;\r\n}\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\r\nif (!fp)\r\nreturn fc_lport_error(lport, fp);\r\nif (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp,\r\nlport->vport ? ELS_FDISC : ELS_FLOGI,\r\nfc_lport_flogi_resp, lport,\r\nlport->vport ? 2 * lport->r_a_tov :\r\nlport->e_d_tov))\r\nfc_lport_error(lport, NULL);\r\n}\r\nint fc_lport_config(struct fc_lport *lport)\r\n{\r\nINIT_DELAYED_WORK(&lport->retry_work, fc_lport_timeout);\r\nmutex_init(&lport->lp_mutex);\r\nfc_lport_state_enter(lport, LPORT_ST_DISABLED);\r\nfc_lport_add_fc4_type(lport, FC_TYPE_FCP);\r\nfc_lport_add_fc4_type(lport, FC_TYPE_CT);\r\nfc_fc4_conf_lport_params(lport, FC_TYPE_FCP);\r\nreturn 0;\r\n}\r\nint fc_lport_init(struct fc_lport *lport)\r\n{\r\nif (!lport->tt.lport_recv)\r\nlport->tt.lport_recv = fc_lport_recv_req;\r\nif (!lport->tt.lport_reset)\r\nlport->tt.lport_reset = fc_lport_reset;\r\nfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\r\nfc_host_node_name(lport->host) = lport->wwnn;\r\nfc_host_port_name(lport->host) = lport->wwpn;\r\nfc_host_supported_classes(lport->host) = FC_COS_CLASS3;\r\nmemset(fc_host_supported_fc4s(lport->host), 0,\r\nsizeof(fc_host_supported_fc4s(lport->host)));\r\nfc_host_supported_fc4s(lport->host)[2] = 1;\r\nfc_host_supported_fc4s(lport->host)[7] = 1;\r\nmemset(fc_host_active_fc4s(lport->host), 0,\r\nsizeof(fc_host_active_fc4s(lport->host)));\r\nfc_host_active_fc4s(lport->host)[2] = 1;\r\nfc_host_active_fc4s(lport->host)[7] = 1;\r\nfc_host_maxframe_size(lport->host) = lport->mfs;\r\nfc_host_supported_speeds(lport->host) = 0;\r\nif (lport->link_supported_speeds & FC_PORTSPEED_1GBIT)\r\nfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_1GBIT;\r\nif (lport->link_supported_speeds & FC_PORTSPEED_10GBIT)\r\nfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_10GBIT;\r\nfc_fc4_add_lport(lport);\r\nreturn 0;\r\n}\r\nstatic void fc_lport_bsg_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *info_arg)\r\n{\r\nstruct fc_bsg_info *info = info_arg;\r\nstruct fc_bsg_job *job = info->job;\r\nstruct fc_lport *lport = info->lport;\r\nstruct fc_frame_header *fh;\r\nsize_t len;\r\nvoid *buf;\r\nif (IS_ERR(fp)) {\r\njob->reply->result = (PTR_ERR(fp) == -FC_EX_CLOSED) ?\r\n-ECONNABORTED : -ETIMEDOUT;\r\njob->reply_len = sizeof(uint32_t);\r\njob->state_flags |= FC_RQST_STATE_DONE;\r\njob->job_done(job);\r\nkfree(info);\r\nreturn;\r\n}\r\nmutex_lock(&lport->lp_mutex);\r\nfh = fc_frame_header_get(fp);\r\nlen = fr_len(fp) - sizeof(*fh);\r\nbuf = fc_frame_payload_get(fp, 0);\r\nif (fr_sof(fp) == FC_SOF_I3 && !ntohs(fh->fh_seq_cnt)) {\r\nunsigned short cmd = (info->rsp_code == FC_FS_ACC) ?\r\nntohs(((struct fc_ct_hdr *)buf)->ct_cmd) :\r\n(unsigned short)fc_frame_payload_op(fp);\r\njob->reply->reply_data.ctels_reply.status =\r\n(cmd == info->rsp_code) ?\r\nFC_CTELS_STATUS_OK : FC_CTELS_STATUS_REJECT;\r\n}\r\njob->reply->reply_payload_rcv_len +=\r\nfc_copy_buffer_to_sglist(buf, len, info->sg, &info->nents,\r\n&info->offset, NULL);\r\nif (fr_eof(fp) == FC_EOF_T &&\r\n(ntoh24(fh->fh_f_ctl) & (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) ==\r\n(FC_FC_LAST_SEQ | FC_FC_END_SEQ)) {\r\nif (job->reply->reply_payload_rcv_len >\r\njob->reply_payload.payload_len)\r\njob->reply->reply_payload_rcv_len =\r\njob->reply_payload.payload_len;\r\njob->reply->result = 0;\r\njob->state_flags |= FC_RQST_STATE_DONE;\r\njob->job_done(job);\r\nkfree(info);\r\n}\r\nfc_frame_free(fp);\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic int fc_lport_els_request(struct fc_bsg_job *job,\r\nstruct fc_lport *lport,\r\nu32 did, u32 tov)\r\n{\r\nstruct fc_bsg_info *info;\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *fh;\r\nchar *pp;\r\nint len;\r\nfp = fc_frame_alloc(lport, job->request_payload.payload_len);\r\nif (!fp)\r\nreturn -ENOMEM;\r\nlen = job->request_payload.payload_len;\r\npp = fc_frame_payload_get(fp, len);\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\npp, len);\r\nfh = fc_frame_header_get(fp);\r\nfh->fh_r_ctl = FC_RCTL_ELS_REQ;\r\nhton24(fh->fh_d_id, did);\r\nhton24(fh->fh_s_id, lport->port_id);\r\nfh->fh_type = FC_TYPE_ELS;\r\nhton24(fh->fh_f_ctl, FC_FCTL_REQ);\r\nfh->fh_cs_ctl = 0;\r\nfh->fh_df_ctl = 0;\r\nfh->fh_parm_offset = 0;\r\ninfo = kzalloc(sizeof(struct fc_bsg_info), GFP_KERNEL);\r\nif (!info) {\r\nfc_frame_free(fp);\r\nreturn -ENOMEM;\r\n}\r\ninfo->job = job;\r\ninfo->lport = lport;\r\ninfo->rsp_code = ELS_LS_ACC;\r\ninfo->nents = job->reply_payload.sg_cnt;\r\ninfo->sg = job->reply_payload.sg_list;\r\nif (!lport->tt.exch_seq_send(lport, fp, fc_lport_bsg_resp,\r\nNULL, info, tov)) {\r\nkfree(info);\r\nreturn -ECOMM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc_lport_ct_request(struct fc_bsg_job *job,\r\nstruct fc_lport *lport, u32 did, u32 tov)\r\n{\r\nstruct fc_bsg_info *info;\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ct_req *ct;\r\nsize_t len;\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +\r\njob->request_payload.payload_len);\r\nif (!fp)\r\nreturn -ENOMEM;\r\nlen = job->request_payload.payload_len;\r\nct = fc_frame_payload_get(fp, len);\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nct, len);\r\nfh = fc_frame_header_get(fp);\r\nfh->fh_r_ctl = FC_RCTL_DD_UNSOL_CTL;\r\nhton24(fh->fh_d_id, did);\r\nhton24(fh->fh_s_id, lport->port_id);\r\nfh->fh_type = FC_TYPE_CT;\r\nhton24(fh->fh_f_ctl, FC_FCTL_REQ);\r\nfh->fh_cs_ctl = 0;\r\nfh->fh_df_ctl = 0;\r\nfh->fh_parm_offset = 0;\r\ninfo = kzalloc(sizeof(struct fc_bsg_info), GFP_KERNEL);\r\nif (!info) {\r\nfc_frame_free(fp);\r\nreturn -ENOMEM;\r\n}\r\ninfo->job = job;\r\ninfo->lport = lport;\r\ninfo->rsp_code = FC_FS_ACC;\r\ninfo->nents = job->reply_payload.sg_cnt;\r\ninfo->sg = job->reply_payload.sg_list;\r\nif (!lport->tt.exch_seq_send(lport, fp, fc_lport_bsg_resp,\r\nNULL, info, tov)) {\r\nkfree(info);\r\nreturn -ECOMM;\r\n}\r\nreturn 0;\r\n}\r\nint fc_lport_bsg_request(struct fc_bsg_job *job)\r\n{\r\nstruct request *rsp = job->req->next_rq;\r\nstruct Scsi_Host *shost = job->shost;\r\nstruct fc_lport *lport = shost_priv(shost);\r\nstruct fc_rport *rport;\r\nstruct fc_rport_priv *rdata;\r\nint rc = -EINVAL;\r\nu32 did;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (rsp)\r\nrsp->resid_len = job->reply_payload.payload_len;\r\nmutex_lock(&lport->lp_mutex);\r\nswitch (job->request->msgcode) {\r\ncase FC_BSG_RPT_ELS:\r\nrport = job->rport;\r\nif (!rport)\r\nbreak;\r\nrdata = rport->dd_data;\r\nrc = fc_lport_els_request(job, lport, rport->port_id,\r\nrdata->e_d_tov);\r\nbreak;\r\ncase FC_BSG_RPT_CT:\r\nrport = job->rport;\r\nif (!rport)\r\nbreak;\r\nrdata = rport->dd_data;\r\nrc = fc_lport_ct_request(job, lport, rport->port_id,\r\nrdata->e_d_tov);\r\nbreak;\r\ncase FC_BSG_HST_CT:\r\ndid = ntoh24(job->request->rqst_data.h_ct.port_id);\r\nif (did == FC_FID_DIR_SERV)\r\nrdata = lport->dns_rdata;\r\nelse\r\nrdata = lport->tt.rport_lookup(lport, did);\r\nif (!rdata)\r\nbreak;\r\nrc = fc_lport_ct_request(job, lport, did, rdata->e_d_tov);\r\nbreak;\r\ncase FC_BSG_HST_ELS_NOLOGIN:\r\ndid = ntoh24(job->request->rqst_data.h_els.port_id);\r\nrc = fc_lport_els_request(job, lport, did, lport->e_d_tov);\r\nbreak;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\nreturn rc;\r\n}
