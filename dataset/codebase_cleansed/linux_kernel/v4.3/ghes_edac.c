static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)\r\n{\r\nint *num_dimm = arg;\r\nif (dh->type == DMI_ENTRY_MEM_DEVICE)\r\n(*num_dimm)++;\r\n}\r\nstatic void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)\r\n{\r\nstruct ghes_edac_dimm_fill *dimm_fill = arg;\r\nstruct mem_ctl_info *mci = dimm_fill->mci;\r\nif (dh->type == DMI_ENTRY_MEM_DEVICE) {\r\nstruct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;\r\nstruct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,\r\nmci->n_layers,\r\ndimm_fill->count, 0, 0);\r\nif (entry->size == 0xffff) {\r\npr_info("Can't get DIMM%i size\n",\r\ndimm_fill->count);\r\ndimm->nr_pages = MiB_TO_PAGES(32);\r\n} else if (entry->size == 0x7fff) {\r\ndimm->nr_pages = MiB_TO_PAGES(entry->extended_size);\r\n} else {\r\nif (entry->size & 1 << 15)\r\ndimm->nr_pages = MiB_TO_PAGES((entry->size &\r\n0x7fff) << 10);\r\nelse\r\ndimm->nr_pages = MiB_TO_PAGES(entry->size);\r\n}\r\nswitch (entry->memory_type) {\r\ncase 0x12:\r\nif (entry->type_detail & 1 << 13)\r\ndimm->mtype = MEM_RDDR;\r\nelse\r\ndimm->mtype = MEM_DDR;\r\nbreak;\r\ncase 0x13:\r\nif (entry->type_detail & 1 << 13)\r\ndimm->mtype = MEM_RDDR2;\r\nelse\r\ndimm->mtype = MEM_DDR2;\r\nbreak;\r\ncase 0x14:\r\ndimm->mtype = MEM_FB_DDR2;\r\nbreak;\r\ncase 0x18:\r\nif (entry->type_detail & 1 << 13)\r\ndimm->mtype = MEM_RDDR3;\r\nelse\r\ndimm->mtype = MEM_DDR3;\r\nbreak;\r\ndefault:\r\nif (entry->type_detail & 1 << 6)\r\ndimm->mtype = MEM_RMBS;\r\nelse if ((entry->type_detail & ((1 << 7) | (1 << 13)))\r\n== ((1 << 7) | (1 << 13)))\r\ndimm->mtype = MEM_RDR;\r\nelse if (entry->type_detail & 1 << 7)\r\ndimm->mtype = MEM_SDR;\r\nelse if (entry->type_detail & 1 << 9)\r\ndimm->mtype = MEM_EDO;\r\nelse\r\ndimm->mtype = MEM_UNKNOWN;\r\n}\r\nif (entry->total_width == entry->data_width)\r\ndimm->edac_mode = EDAC_NONE;\r\nelse\r\ndimm->edac_mode = EDAC_SECDED;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->grain = 128;\r\nif (dimm->nr_pages) {\r\nedac_dbg(1, "DIMM%i: %s size = %d MB%s\n",\r\ndimm_fill->count, memory_type[dimm->mtype],\r\nPAGES_TO_MiB(dimm->nr_pages),\r\n(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");\r\nedac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",\r\nentry->memory_type, entry->type_detail,\r\nentry->total_width, entry->data_width);\r\n}\r\ndimm_fill->count++;\r\n}\r\n}\r\nvoid ghes_edac_report_mem_error(struct ghes *ghes, int sev,\r\nstruct cper_sec_mem_err *mem_err)\r\n{\r\nenum hw_event_mc_err_type type;\r\nstruct edac_raw_error_desc *e;\r\nstruct mem_ctl_info *mci;\r\nstruct ghes_edac_pvt *pvt = NULL;\r\nchar *p;\r\nu8 grain_bits;\r\nlist_for_each_entry(pvt, &ghes_reglist, list) {\r\nif (ghes == pvt->ghes)\r\nbreak;\r\n}\r\nif (!pvt) {\r\npr_err("Internal error: Can't find EDAC structure\n");\r\nreturn;\r\n}\r\nmci = pvt->mci;\r\ne = &mci->error_desc;\r\nmemset(e, 0, sizeof (*e));\r\ne->error_count = 1;\r\nstrcpy(e->label, "unknown label");\r\ne->msg = pvt->msg;\r\ne->other_detail = pvt->other_detail;\r\ne->top_layer = -1;\r\ne->mid_layer = -1;\r\ne->low_layer = -1;\r\n*pvt->other_detail = '\0';\r\n*pvt->msg = '\0';\r\nswitch (sev) {\r\ncase GHES_SEV_CORRECTED:\r\ntype = HW_EVENT_ERR_CORRECTED;\r\nbreak;\r\ncase GHES_SEV_RECOVERABLE:\r\ntype = HW_EVENT_ERR_UNCORRECTED;\r\nbreak;\r\ncase GHES_SEV_PANIC:\r\ntype = HW_EVENT_ERR_FATAL;\r\nbreak;\r\ndefault:\r\ncase GHES_SEV_NO:\r\ntype = HW_EVENT_ERR_INFO;\r\n}\r\nedac_dbg(1, "error validation_bits: 0x%08llx\n",\r\n(long long)mem_err->validation_bits);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {\r\np = pvt->msg;\r\nswitch (mem_err->error_type) {\r\ncase 0:\r\np += sprintf(p, "Unknown");\r\nbreak;\r\ncase 1:\r\np += sprintf(p, "No error");\r\nbreak;\r\ncase 2:\r\np += sprintf(p, "Single-bit ECC");\r\nbreak;\r\ncase 3:\r\np += sprintf(p, "Multi-bit ECC");\r\nbreak;\r\ncase 4:\r\np += sprintf(p, "Single-symbol ChipKill ECC");\r\nbreak;\r\ncase 5:\r\np += sprintf(p, "Multi-symbol ChipKill ECC");\r\nbreak;\r\ncase 6:\r\np += sprintf(p, "Master abort");\r\nbreak;\r\ncase 7:\r\np += sprintf(p, "Target abort");\r\nbreak;\r\ncase 8:\r\np += sprintf(p, "Parity Error");\r\nbreak;\r\ncase 9:\r\np += sprintf(p, "Watchdog timeout");\r\nbreak;\r\ncase 10:\r\np += sprintf(p, "Invalid address");\r\nbreak;\r\ncase 11:\r\np += sprintf(p, "Mirror Broken");\r\nbreak;\r\ncase 12:\r\np += sprintf(p, "Memory Sparing");\r\nbreak;\r\ncase 13:\r\np += sprintf(p, "Scrub corrected error");\r\nbreak;\r\ncase 14:\r\np += sprintf(p, "Scrub uncorrected error");\r\nbreak;\r\ncase 15:\r\np += sprintf(p, "Physical Memory Map-out event");\r\nbreak;\r\ndefault:\r\np += sprintf(p, "reserved error (%d)",\r\nmem_err->error_type);\r\n}\r\n} else {\r\nstrcpy(pvt->msg, "unknown error");\r\n}\r\nif (mem_err->validation_bits & CPER_MEM_VALID_PA) {\r\ne->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;\r\ne->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;\r\n}\r\nif (mem_err->validation_bits & CPER_MEM_VALID_PA_MASK)\r\ne->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);\r\np = e->location;\r\nif (mem_err->validation_bits & CPER_MEM_VALID_NODE)\r\np += sprintf(p, "node:%d ", mem_err->node);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_CARD)\r\np += sprintf(p, "card:%d ", mem_err->card);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_MODULE)\r\np += sprintf(p, "module:%d ", mem_err->module);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_RANK_NUMBER)\r\np += sprintf(p, "rank:%d ", mem_err->rank);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_BANK)\r\np += sprintf(p, "bank:%d ", mem_err->bank);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_ROW)\r\np += sprintf(p, "row:%d ", mem_err->row);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_COLUMN)\r\np += sprintf(p, "col:%d ", mem_err->column);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_BIT_POSITION)\r\np += sprintf(p, "bit_pos:%d ", mem_err->bit_pos);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_MODULE_HANDLE) {\r\nconst char *bank = NULL, *device = NULL;\r\ndmi_memdev_name(mem_err->mem_dev_handle, &bank, &device);\r\nif (bank != NULL && device != NULL)\r\np += sprintf(p, "DIMM location:%s %s ", bank, device);\r\nelse\r\np += sprintf(p, "DIMM DMI handle: 0x%.4x ",\r\nmem_err->mem_dev_handle);\r\n}\r\nif (p > e->location)\r\n*(p - 1) = '\0';\r\np = pvt->other_detail;\r\nif (mem_err->validation_bits & CPER_MEM_VALID_ERROR_STATUS) {\r\nu64 status = mem_err->error_status;\r\np += sprintf(p, "status(0x%016llx): ", (long long)status);\r\nswitch ((status >> 8) & 0xff) {\r\ncase 1:\r\np += sprintf(p, "Error detected internal to the component ");\r\nbreak;\r\ncase 16:\r\np += sprintf(p, "Error detected in the bus ");\r\nbreak;\r\ncase 4:\r\np += sprintf(p, "Storage error in DRAM memory ");\r\nbreak;\r\ncase 5:\r\np += sprintf(p, "Storage error in TLB ");\r\nbreak;\r\ncase 6:\r\np += sprintf(p, "Storage error in cache ");\r\nbreak;\r\ncase 7:\r\np += sprintf(p, "Error in one or more functional units ");\r\nbreak;\r\ncase 8:\r\np += sprintf(p, "component failed self test ");\r\nbreak;\r\ncase 9:\r\np += sprintf(p, "Overflow or undervalue of internal queue ");\r\nbreak;\r\ncase 17:\r\np += sprintf(p, "Virtual address not found on IO-TLB or IO-PDIR ");\r\nbreak;\r\ncase 18:\r\np += sprintf(p, "Improper access error ");\r\nbreak;\r\ncase 19:\r\np += sprintf(p, "Access to a memory address which is not mapped to any component ");\r\nbreak;\r\ncase 20:\r\np += sprintf(p, "Loss of Lockstep ");\r\nbreak;\r\ncase 21:\r\np += sprintf(p, "Response not associated with a request ");\r\nbreak;\r\ncase 22:\r\np += sprintf(p, "Bus parity error - must also set the A, C, or D Bits ");\r\nbreak;\r\ncase 23:\r\np += sprintf(p, "Detection of a PATH_ERROR ");\r\nbreak;\r\ncase 25:\r\np += sprintf(p, "Bus operation timeout ");\r\nbreak;\r\ncase 26:\r\np += sprintf(p, "A read was issued to data that has been poisoned ");\r\nbreak;\r\ndefault:\r\np += sprintf(p, "reserved ");\r\nbreak;\r\n}\r\n}\r\nif (mem_err->validation_bits & CPER_MEM_VALID_REQUESTOR_ID)\r\np += sprintf(p, "requestorID: 0x%016llx ",\r\n(long long)mem_err->requestor_id);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_RESPONDER_ID)\r\np += sprintf(p, "responderID: 0x%016llx ",\r\n(long long)mem_err->responder_id);\r\nif (mem_err->validation_bits & CPER_MEM_VALID_TARGET_ID)\r\np += sprintf(p, "targetID: 0x%016llx ",\r\n(long long)mem_err->responder_id);\r\nif (p > pvt->other_detail)\r\n*(p - 1) = '\0';\r\ngrain_bits = fls_long(e->grain);\r\nsnprintf(pvt->detail_location, sizeof(pvt->detail_location),\r\n"APEI location: %s %s", e->location, e->other_detail);\r\ntrace_mc_event(type, e->msg, e->label, e->error_count,\r\nmci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,\r\nPAGES_TO_MiB(e->page_frame_number) | e->offset_in_page,\r\ngrain_bits, e->syndrome, pvt->detail_location);\r\nedac_raw_mc_handle_error(type, mci, e);\r\n}\r\nint ghes_edac_register(struct ghes *ghes, struct device *dev)\r\n{\r\nbool fake = false;\r\nint rc, num_dimm = 0;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[1];\r\nstruct ghes_edac_pvt *pvt;\r\nstruct ghes_edac_dimm_fill dimm_fill;\r\ndmi_walk(ghes_edac_count_dimms, &num_dimm);\r\nif (num_dimm == 0) {\r\nfake = true;\r\nnum_dimm = 1;\r\n}\r\nlayers[0].type = EDAC_MC_LAYER_ALL_MEM;\r\nlayers[0].size = num_dimm;\r\nlayers[0].is_virt_csrow = true;\r\nmutex_lock(&ghes_edac_lock);\r\nmci = edac_mc_alloc(ghes_edac_mc_num, ARRAY_SIZE(layers), layers,\r\nsizeof(*pvt));\r\nif (!mci) {\r\npr_info("Can't allocate memory for EDAC data\n");\r\nmutex_unlock(&ghes_edac_lock);\r\nreturn -ENOMEM;\r\n}\r\npvt = mci->pvt_info;\r\nmemset(pvt, 0, sizeof(*pvt));\r\nlist_add_tail(&pvt->list, &ghes_reglist);\r\npvt->ghes = ghes;\r\npvt->mci = mci;\r\nmci->pdev = dev;\r\nmci->mtype_cap = MEM_FLAG_EMPTY;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE;\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = "ghes_edac.c";\r\nmci->mod_ver = GHES_EDAC_REVISION;\r\nmci->ctl_name = "ghes_edac";\r\nmci->dev_name = "ghes";\r\nif (!ghes_edac_mc_num) {\r\nif (!fake) {\r\npr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");\r\npr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");\r\npr_info("So, the end result of using this driver varies from vendor to vendor.\n");\r\npr_info("If you find incorrect reports, please contact your hardware vendor\n");\r\npr_info("to correct its BIOS.\n");\r\npr_info("This system has %d DIMM sockets.\n",\r\nnum_dimm);\r\n} else {\r\npr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");\r\npr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");\r\npr_info("work on such system. Use this driver with caution\n");\r\n}\r\n}\r\nif (!fake) {\r\nif (!ghes_edac_mc_num) {\r\ndimm_fill.count = 0;\r\ndimm_fill.mci = mci;\r\ndmi_walk(ghes_edac_dmidecode, &dimm_fill);\r\n}\r\n} else {\r\nstruct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,\r\nmci->n_layers, 0, 0, 0);\r\ndimm->nr_pages = 1;\r\ndimm->grain = 128;\r\ndimm->mtype = MEM_UNKNOWN;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = EDAC_SECDED;\r\n}\r\nrc = edac_mc_add_mc(mci);\r\nif (rc < 0) {\r\npr_info("Can't register at EDAC core\n");\r\nedac_mc_free(mci);\r\nmutex_unlock(&ghes_edac_lock);\r\nreturn -ENODEV;\r\n}\r\nghes_edac_mc_num++;\r\nmutex_unlock(&ghes_edac_lock);\r\nreturn 0;\r\n}\r\nvoid ghes_edac_unregister(struct ghes *ghes)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct ghes_edac_pvt *pvt, *tmp;\r\nlist_for_each_entry_safe(pvt, tmp, &ghes_reglist, list) {\r\nif (ghes == pvt->ghes) {\r\nmci = pvt->mci;\r\nedac_mc_del_mc(mci->pdev);\r\nedac_mc_free(mci);\r\nlist_del(&pvt->list);\r\n}\r\n}\r\n}
