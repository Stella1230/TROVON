static void axp288_extcon_log_rsi(struct axp288_extcon_info *info)\r\n{\r\nchar **rsi;\r\nunsigned int val, i, clear_mask = 0;\r\nint ret;\r\nret = regmap_read(info->regmap, AXP288_PS_BOOT_REASON_REG, &val);\r\nfor (i = 0, rsi = axp288_pwr_up_down_info; *rsi; rsi++, i++) {\r\nif (val & BIT(i)) {\r\ndev_dbg(info->dev, "%s\n", *rsi);\r\nclear_mask |= BIT(i);\r\n}\r\n}\r\nregmap_write(info->regmap, AXP288_PS_BOOT_REASON_REG, clear_mask);\r\n}\r\nstatic int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)\r\n{\r\nstatic bool notify_otg, notify_charger;\r\nstatic unsigned int cable;\r\nint ret, stat, cfg, pwr_stat;\r\nu8 chrg_type;\r\nbool vbus_attach = false;\r\nret = regmap_read(info->regmap, AXP288_PS_STAT_REG, &pwr_stat);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to read vbus status\n");\r\nreturn ret;\r\n}\r\nvbus_attach = (pwr_stat & PS_STAT_VBUS_PRESENT);\r\nif (!vbus_attach)\r\ngoto notify_otg;\r\nret = regmap_read(info->regmap, AXP288_BC_GLOBAL_REG, &cfg);\r\nif (ret < 0)\r\ngoto dev_det_ret;\r\nif (cfg & BC_GLOBAL_DET_STAT) {\r\ndev_dbg(info->dev, "can't complete the charger detection\n");\r\ngoto dev_det_ret;\r\n}\r\nret = regmap_read(info->regmap, AXP288_BC_DET_STAT_REG, &stat);\r\nif (ret < 0)\r\ngoto dev_det_ret;\r\nchrg_type = (stat & DET_STAT_MASK) >> DET_STAT_SHIFT;\r\nswitch (chrg_type) {\r\ncase DET_STAT_SDP:\r\ndev_dbg(info->dev, "sdp cable is connecetd\n");\r\nnotify_otg = true;\r\nnotify_charger = true;\r\ncable = EXTCON_SLOW_CHARGER;\r\nbreak;\r\ncase DET_STAT_CDP:\r\ndev_dbg(info->dev, "cdp cable is connecetd\n");\r\nnotify_otg = true;\r\nnotify_charger = true;\r\ncable = EXTCON_CHARGE_DOWNSTREAM;\r\nbreak;\r\ncase DET_STAT_DCP:\r\ndev_dbg(info->dev, "dcp cable is connecetd\n");\r\nnotify_charger = true;\r\ncable = EXTCON_FAST_CHARGER;\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev,\r\n"disconnect or unknown or ID event\n");\r\n}\r\nnotify_otg:\r\nif (notify_otg) {\r\nif (info->pdata->gpio_mux_cntl)\r\ngpiod_set_value(info->pdata->gpio_mux_cntl,\r\nvbus_attach ? EXTCON_GPIO_MUX_SEL_SOC\r\n: EXTCON_GPIO_MUX_SEL_PMIC);\r\natomic_notifier_call_chain(&info->otg->notifier,\r\nvbus_attach ? USB_EVENT_VBUS : USB_EVENT_NONE, NULL);\r\n}\r\nif (notify_charger)\r\nextcon_set_cable_state_(info->edev, cable, vbus_attach);\r\nif (!vbus_attach)\r\nnotify_otg = notify_charger = false;\r\nreturn 0;\r\ndev_det_ret:\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to detect BC Mod\n");\r\nreturn ret;\r\n}\r\nstatic irqreturn_t axp288_extcon_isr(int irq, void *data)\r\n{\r\nstruct axp288_extcon_info *info = data;\r\nint ret;\r\nret = axp288_handle_chrg_det_event(info);\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to handle the interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void axp288_extcon_enable_irq(struct axp288_extcon_info *info)\r\n{\r\nregmap_write(info->regmap, AXP288_PWRSRC_IRQ_CFG_REG,\r\nPWRSRC_IRQ_CFG_MASK);\r\nregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\r\nBC_GLOBAL_RUN, 0);\r\nregmap_write(info->regmap, AXP288_BC12_IRQ_CFG_REG, BC12_IRQ_CFG_MASK);\r\nregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\r\nBC_GLOBAL_RUN, BC_GLOBAL_RUN);\r\n}\r\nstatic int axp288_extcon_probe(struct platform_device *pdev)\r\n{\r\nstruct axp288_extcon_info *info;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nint ret, i, pirq, gpio;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->pdata = pdev->dev.platform_data;\r\nif (!info->pdata) {\r\nif (!device_property_present(&pdev->dev,\r\n"axp288_extcon_data\n"))\r\ndev_err(&pdev->dev, "failed to get platform data\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\naxp288_extcon_log_rsi(info);\r\ninfo->edev = devm_extcon_dev_allocate(&pdev->dev,\r\naxp288_extcon_cables);\r\nif (IS_ERR(info->edev)) {\r\ndev_err(&pdev->dev, "failed to allocate memory for extcon\n");\r\nreturn PTR_ERR(info->edev);\r\n}\r\nret = devm_extcon_dev_register(&pdev->dev, info->edev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register extcon device\n");\r\nreturn ret;\r\n}\r\ninfo->otg = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR(info->otg)) {\r\ndev_err(&pdev->dev, "failed to get otg transceiver\n");\r\nreturn PTR_ERR(info->otg);\r\n}\r\nif (info->pdata->gpio_mux_cntl) {\r\ngpio = desc_to_gpio(info->pdata->gpio_mux_cntl);\r\nret = gpio_request(gpio, "USB_MUX");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to request the gpio=%d\n", gpio);\r\ngoto gpio_req_failed;\r\n}\r\ngpiod_direction_output(info->pdata->gpio_mux_cntl,\r\nEXTCON_GPIO_MUX_SEL_PMIC);\r\n}\r\nfor (i = 0; i < EXTCON_IRQ_END; i++) {\r\npirq = platform_get_irq(pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to get virtual interrupt=%d\n", pirq);\r\nret = info->irq[i];\r\ngoto gpio_req_failed;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, info->irq[i],\r\nNULL, axp288_extcon_isr,\r\nIRQF_ONESHOT | IRQF_NO_SUSPEND,\r\npdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request interrupt=%d\n",\r\ninfo->irq[i]);\r\ngoto gpio_req_failed;\r\n}\r\n}\r\naxp288_extcon_enable_irq(info);\r\nreturn 0;\r\ngpio_req_failed:\r\nusb_put_phy(info->otg);\r\nreturn ret;\r\n}\r\nstatic int axp288_extcon_remove(struct platform_device *pdev)\r\n{\r\nstruct axp288_extcon_info *info = platform_get_drvdata(pdev);\r\nusb_put_phy(info->otg);\r\nreturn 0;\r\n}
