static void genrtc_troutine(struct work_struct *work)\r\n{\r\nunsigned int tmp = get_rtc_ss();\r\nif (stop_rtc_timers) {\r\nstask_active = 0;\r\nreturn;\r\n}\r\nif (oldsecs != tmp){\r\noldsecs = tmp;\r\ntimer_task.function = gen_rtc_timer;\r\ntimer_task.expires = jiffies + HZ - (HZ/10);\r\ntt_exp=timer_task.expires;\r\nttask_active=1;\r\nstask_active=0;\r\nadd_timer(&timer_task);\r\ngen_rtc_interrupt(0);\r\n} else if (schedule_work(&genrtc_task) == 0)\r\nstask_active = 0;\r\n}\r\nstatic void gen_rtc_timer(unsigned long data)\r\n{\r\nlostint = get_rtc_ss() - oldsecs ;\r\nif (lostint<0)\r\nlostint = 60 - lostint;\r\nif (time_after(jiffies, tt_exp))\r\nprintk(KERN_INFO "genrtc: timer task delayed by %ld jiffies\n",\r\njiffies-tt_exp);\r\nttask_active=0;\r\nstask_active=1;\r\nif ((schedule_work(&genrtc_task) == 0))\r\nstask_active = 0;\r\n}\r\nstatic void gen_rtc_interrupt(unsigned long arg)\r\n{\r\ngen_rtc_irq_data += 0x100;\r\ngen_rtc_irq_data &= ~0xff;\r\ngen_rtc_irq_data |= RTC_UIE;\r\nif (lostint){\r\nprintk("genrtc: system delaying clock ticks?\n");\r\ngen_rtc_irq_data += ((lostint-1)<<8);\r\nlostint = 0;\r\n}\r\nwake_up_interruptible(&gen_rtc_wait);\r\n}\r\nstatic ssize_t gen_rtc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long data;\r\nssize_t retval;\r\nif (count != sizeof (unsigned int) && count != sizeof (unsigned long))\r\nreturn -EINVAL;\r\nif (file->f_flags & O_NONBLOCK && !gen_rtc_irq_data)\r\nreturn -EAGAIN;\r\nretval = wait_event_interruptible(gen_rtc_wait,\r\n(data = xchg(&gen_rtc_irq_data, 0)));\r\nif (retval)\r\ngoto out;\r\nif (sizeof (int) != sizeof (long) && count == sizeof (unsigned int)) {\r\nunsigned int uidata = data;\r\nretval = put_user(uidata, (unsigned int __user *)buf) ?:\r\nsizeof(unsigned int);\r\n}\r\nelse {\r\nretval = put_user(data, (unsigned long __user *)buf) ?:\r\nsizeof(unsigned long);\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic unsigned int gen_rtc_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\npoll_wait(file, &gen_rtc_wait, wait);\r\nif (gen_rtc_irq_data != 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic inline void gen_clear_rtc_irq_bit(unsigned char bit)\r\n{\r\n#ifdef CONFIG_GEN_RTC_X\r\nstop_rtc_timers = 1;\r\nif (ttask_active){\r\ndel_timer_sync(&timer_task);\r\nttask_active = 0;\r\n}\r\nwhile (stask_active)\r\nschedule();\r\nspin_lock(&gen_rtc_lock);\r\nirq_active = 0;\r\nspin_unlock(&gen_rtc_lock);\r\n#endif\r\n}\r\nstatic inline int gen_set_rtc_irq_bit(unsigned char bit)\r\n{\r\n#ifdef CONFIG_GEN_RTC_X\r\nspin_lock(&gen_rtc_lock);\r\nif ( !irq_active ) {\r\nirq_active = 1;\r\nstop_rtc_timers = 0;\r\nlostint = 0;\r\nINIT_WORK(&genrtc_task, genrtc_troutine);\r\noldsecs = get_rtc_ss();\r\ninit_timer(&timer_task);\r\nstask_active = 1;\r\nif (schedule_work(&genrtc_task) == 0){\r\nstask_active = 0;\r\n}\r\n}\r\nspin_unlock(&gen_rtc_lock);\r\ngen_rtc_irq_data = 0;\r\nreturn 0;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int gen_rtc_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct rtc_time wtime;\r\nstruct rtc_pll_info pll;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase RTC_PLL_GET:\r\nif (get_rtc_pll(&pll))\r\nreturn -EINVAL;\r\nelse\r\nreturn copy_to_user(argp, &pll, sizeof pll) ? -EFAULT : 0;\r\ncase RTC_PLL_SET:\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EACCES;\r\nif (copy_from_user(&pll, argp, sizeof(pll)))\r\nreturn -EFAULT;\r\nreturn set_rtc_pll(&pll);\r\ncase RTC_UIE_OFF:\r\ngen_clear_rtc_irq_bit(RTC_UIE);\r\nreturn 0;\r\ncase RTC_UIE_ON:\r\nreturn gen_set_rtc_irq_bit(RTC_UIE);\r\ncase RTC_RD_TIME:\r\nmemset(&wtime, 0, sizeof(wtime));\r\nget_rtc_time(&wtime);\r\nreturn copy_to_user(argp, &wtime, sizeof(wtime)) ? -EFAULT : 0;\r\ncase RTC_SET_TIME:\r\n{\r\nint year;\r\nunsigned char leap_yr;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EACCES;\r\nif (copy_from_user(&wtime, argp, sizeof(wtime)))\r\nreturn -EFAULT;\r\nyear = wtime.tm_year + 1900;\r\nleap_yr = ((!(year % 4) && (year % 100)) ||\r\n!(year % 400));\r\nif ((wtime.tm_mon < 0 || wtime.tm_mon > 11) || (wtime.tm_mday < 1))\r\nreturn -EINVAL;\r\nif (wtime.tm_mday < 0 || wtime.tm_mday >\r\n(days_in_mo[wtime.tm_mon] + ((wtime.tm_mon == 1) && leap_yr)))\r\nreturn -EINVAL;\r\nif (wtime.tm_hour < 0 || wtime.tm_hour >= 24 ||\r\nwtime.tm_min < 0 || wtime.tm_min >= 60 ||\r\nwtime.tm_sec < 0 || wtime.tm_sec >= 60)\r\nreturn -EINVAL;\r\nreturn set_rtc_time(&wtime);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long gen_rtc_unlocked_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&gen_rtc_mutex);\r\nret = gen_rtc_ioctl(file, cmd, arg);\r\nmutex_unlock(&gen_rtc_mutex);\r\nreturn ret;\r\n}\r\nstatic int gen_rtc_open(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&gen_rtc_mutex);\r\nif (gen_rtc_status & RTC_IS_OPEN) {\r\nmutex_unlock(&gen_rtc_mutex);\r\nreturn -EBUSY;\r\n}\r\ngen_rtc_status |= RTC_IS_OPEN;\r\ngen_rtc_irq_data = 0;\r\nirq_active = 0;\r\nmutex_unlock(&gen_rtc_mutex);\r\nreturn 0;\r\n}\r\nstatic int gen_rtc_release(struct inode *inode, struct file *file)\r\n{\r\ngen_clear_rtc_irq_bit(RTC_PIE|RTC_AIE|RTC_UIE);\r\ngen_rtc_status &= ~RTC_IS_OPEN;\r\nreturn 0;\r\n}\r\nstatic int gen_rtc_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct rtc_time tm;\r\nunsigned int flags;\r\nstruct rtc_pll_info pll;\r\nflags = get_rtc_time(&tm);\r\nseq_printf(m,\r\n"rtc_time\t: %02d:%02d:%02d\n"\r\n"rtc_date\t: %04d-%02d-%02d\n"\r\n"rtc_epoch\t: %04u\n",\r\ntm.tm_hour, tm.tm_min, tm.tm_sec,\r\ntm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, 1900);\r\ntm.tm_hour = tm.tm_min = tm.tm_sec = 0;\r\nseq_puts(m, "alarm\t\t: ");\r\nif (tm.tm_hour <= 24)\r\nseq_printf(m, "%02d:", tm.tm_hour);\r\nelse\r\nseq_puts(m, "**:");\r\nif (tm.tm_min <= 59)\r\nseq_printf(m, "%02d:", tm.tm_min);\r\nelse\r\nseq_puts(m, "**:");\r\nif (tm.tm_sec <= 59)\r\nseq_printf(m, "%02d\n", tm.tm_sec);\r\nelse\r\nseq_puts(m, "**\n");\r\nseq_printf(m,\r\n"DST_enable\t: %s\n"\r\n"BCD\t\t: %s\n"\r\n"24hr\t\t: %s\n"\r\n"square_wave\t: %s\n"\r\n"alarm_IRQ\t: %s\n"\r\n"update_IRQ\t: %s\n"\r\n"periodic_IRQ\t: %s\n"\r\n"periodic_freq\t: %ld\n"\r\n"batt_status\t: %s\n",\r\n(flags & RTC_DST_EN) ? "yes" : "no",\r\n(flags & RTC_DM_BINARY) ? "no" : "yes",\r\n(flags & RTC_24H) ? "yes" : "no",\r\n(flags & RTC_SQWE) ? "yes" : "no",\r\n(flags & RTC_AIE) ? "yes" : "no",\r\nirq_active ? "yes" : "no",\r\n(flags & RTC_PIE) ? "yes" : "no",\r\n0L ,\r\n(flags & RTC_BATT_BAD) ? "bad" : "okay");\r\nif (!get_rtc_pll(&pll))\r\nseq_printf(m,\r\n"PLL adjustment\t: %d\n"\r\n"PLL max +ve adjustment\t: %d\n"\r\n"PLL max -ve adjustment\t: %d\n"\r\n"PLL +ve adjustment factor\t: %d\n"\r\n"PLL -ve adjustment factor\t: %d\n"\r\n"PLL frequency\t: %ld\n",\r\npll.pll_value,\r\npll.pll_max,\r\npll.pll_min,\r\npll.pll_posmult,\r\npll.pll_negmult,\r\npll.pll_clock);\r\nreturn 0;\r\n}\r\nstatic int gen_rtc_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gen_rtc_proc_show, NULL);\r\n}\r\nstatic int __init gen_rtc_proc_init(void)\r\n{\r\nstruct proc_dir_entry *r;\r\nr = proc_create("driver/rtc", 0, NULL, &gen_rtc_proc_fops);\r\nif (!r)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic inline int gen_rtc_proc_init(void) { return 0; }\r\nstatic int __init rtc_generic_init(void)\r\n{\r\nint retval;\r\nprintk(KERN_INFO "Generic RTC Driver v%s\n", RTC_VERSION);\r\nretval = misc_register(&rtc_gen_dev);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = gen_rtc_proc_init();\r\nif (retval) {\r\nmisc_deregister(&rtc_gen_dev);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit rtc_generic_exit(void)\r\n{\r\nremove_proc_entry ("driver/rtc", NULL);\r\nmisc_deregister(&rtc_gen_dev);\r\n}
