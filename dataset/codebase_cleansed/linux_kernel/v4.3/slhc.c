struct slcompress *\r\nslhc_init(int rslots, int tslots)\r\n{\r\nregister short i;\r\nregister struct cstate *ts;\r\nstruct slcompress *comp;\r\ncomp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);\r\nif (! comp)\r\ngoto out_fail;\r\nif ( rslots > 0 && rslots < 256 ) {\r\nsize_t rsize = rslots * sizeof(struct cstate);\r\ncomp->rstate = kzalloc(rsize, GFP_KERNEL);\r\nif (! comp->rstate)\r\ngoto out_free;\r\ncomp->rslot_limit = rslots - 1;\r\n}\r\nif ( tslots > 0 && tslots < 256 ) {\r\nsize_t tsize = tslots * sizeof(struct cstate);\r\ncomp->tstate = kzalloc(tsize, GFP_KERNEL);\r\nif (! comp->tstate)\r\ngoto out_free2;\r\ncomp->tslot_limit = tslots - 1;\r\n}\r\ncomp->xmit_oldest = 0;\r\ncomp->xmit_current = 255;\r\ncomp->recv_current = 255;\r\ncomp->flags |= SLF_TOSS;\r\nif ( tslots > 0 ) {\r\nts = comp->tstate;\r\nfor(i = comp->tslot_limit; i > 0; --i){\r\nts[i].cs_this = i;\r\nts[i].next = &(ts[i - 1]);\r\n}\r\nts[0].next = &(ts[comp->tslot_limit]);\r\nts[0].cs_this = 0;\r\n}\r\nreturn comp;\r\nout_free2:\r\nkfree(comp->rstate);\r\nout_free:\r\nkfree(comp);\r\nout_fail:\r\nreturn NULL;\r\n}\r\nvoid\r\nslhc_free(struct slcompress *comp)\r\n{\r\nif ( comp == NULLSLCOMPR )\r\nreturn;\r\nif ( comp->tstate != NULLSLSTATE )\r\nkfree( comp->tstate );\r\nif ( comp->rstate != NULLSLSTATE )\r\nkfree( comp->rstate );\r\nkfree( comp );\r\n}\r\nstatic inline unsigned char *\r\nput16(unsigned char *cp, unsigned short x)\r\n{\r\n*cp++ = x >> 8;\r\n*cp++ = x;\r\nreturn cp;\r\n}\r\nstatic unsigned char *\r\nencode(unsigned char *cp, unsigned short n)\r\n{\r\nif(n >= 256 || n == 0){\r\n*cp++ = 0;\r\ncp = put16(cp,n);\r\n} else {\r\n*cp++ = n;\r\n}\r\nreturn cp;\r\n}\r\nstatic unsigned short\r\npull16(unsigned char **cpp)\r\n{\r\nshort rval;\r\nrval = *(*cpp)++;\r\nrval <<= 8;\r\nrval |= *(*cpp)++;\r\nreturn rval;\r\n}\r\nstatic long\r\ndecode(unsigned char **cpp)\r\n{\r\nregister int x;\r\nx = *(*cpp)++;\r\nif(x == 0){\r\nreturn pull16(cpp) & 0xffff;\r\n} else {\r\nreturn x & 0xff;\r\n}\r\n}\r\nint\r\nslhc_compress(struct slcompress *comp, unsigned char *icp, int isize,\r\nunsigned char *ocp, unsigned char **cpp, int compress_cid)\r\n{\r\nregister struct cstate *ocs = &(comp->tstate[comp->xmit_oldest]);\r\nregister struct cstate *lcs = ocs;\r\nregister struct cstate *cs = lcs->next;\r\nregister unsigned long deltaS, deltaA;\r\nregister short changes = 0;\r\nint hlen;\r\nunsigned char new_seq[16];\r\nregister unsigned char *cp = new_seq;\r\nstruct iphdr *ip;\r\nstruct tcphdr *th, *oth;\r\n__sum16 csum;\r\nif(isize<sizeof(struct iphdr))\r\nreturn isize;\r\nip = (struct iphdr *) icp;\r\nif (ip->protocol != IPPROTO_TCP || (ntohs(ip->frag_off) & 0x3fff)) {\r\nif(ip->protocol != IPPROTO_TCP)\r\ncomp->sls_o_nontcp++;\r\nelse\r\ncomp->sls_o_tcp++;\r\nreturn isize;\r\n}\r\nth = (struct tcphdr *)(((unsigned char *)ip) + ip->ihl*4);\r\nhlen = ip->ihl*4 + th->doff*4;\r\nif(hlen > isize || th->syn || th->fin || th->rst ||\r\n! (th->ack)){\r\ncomp->sls_o_tcp++;\r\nreturn isize;\r\n}\r\nfor ( ; ; ) {\r\nif( ip->saddr == cs->cs_ip.saddr\r\n&& ip->daddr == cs->cs_ip.daddr\r\n&& th->source == cs->cs_tcp.source\r\n&& th->dest == cs->cs_tcp.dest)\r\ngoto found;\r\nif ( cs == ocs )\r\nbreak;\r\nlcs = cs;\r\ncs = cs->next;\r\ncomp->sls_o_searches++;\r\n}\r\ncomp->sls_o_misses++;\r\ncomp->xmit_oldest = lcs->cs_this;\r\ngoto uncompressed;\r\nfound:\r\nif(lcs == ocs) {\r\n} else if (cs == ocs) {\r\ncomp->xmit_oldest = lcs->cs_this;\r\n} else {\r\nlcs->next = cs->next;\r\ncs->next = ocs->next;\r\nocs->next = cs;\r\n}\r\noth = &cs->cs_tcp;\r\nif(ip->version != cs->cs_ip.version || ip->ihl != cs->cs_ip.ihl\r\n|| ip->tos != cs->cs_ip.tos\r\n|| (ip->frag_off & htons(0x4000)) != (cs->cs_ip.frag_off & htons(0x4000))\r\n|| ip->ttl != cs->cs_ip.ttl\r\n|| th->doff != cs->cs_tcp.doff\r\n|| (ip->ihl > 5 && memcmp(ip+1,cs->cs_ipopt,((ip->ihl)-5)*4) != 0)\r\n|| (th->doff > 5 && memcmp(th+1,cs->cs_tcpopt,((th->doff)-5)*4) != 0)){\r\ngoto uncompressed;\r\n}\r\nif(th->urg){\r\ndeltaS = ntohs(th->urg_ptr);\r\ncp = encode(cp,deltaS);\r\nchanges |= NEW_U;\r\n} else if(th->urg_ptr != oth->urg_ptr){\r\ngoto uncompressed;\r\n}\r\nif((deltaS = ntohs(th->window) - ntohs(oth->window)) != 0){\r\ncp = encode(cp,deltaS);\r\nchanges |= NEW_W;\r\n}\r\nif((deltaA = ntohl(th->ack_seq) - ntohl(oth->ack_seq)) != 0L){\r\nif(deltaA > 0x0000ffff)\r\ngoto uncompressed;\r\ncp = encode(cp,deltaA);\r\nchanges |= NEW_A;\r\n}\r\nif((deltaS = ntohl(th->seq) - ntohl(oth->seq)) != 0L){\r\nif(deltaS > 0x0000ffff)\r\ngoto uncompressed;\r\ncp = encode(cp,deltaS);\r\nchanges |= NEW_S;\r\n}\r\nswitch(changes){\r\ncase 0:\r\nif(ip->tot_len != cs->cs_ip.tot_len &&\r\nntohs(cs->cs_ip.tot_len) == hlen)\r\nbreak;\r\ngoto uncompressed;\r\ncase SPECIAL_I:\r\ncase SPECIAL_D:\r\ngoto uncompressed;\r\ncase NEW_S|NEW_A:\r\nif(deltaS == deltaA &&\r\ndeltaS == ntohs(cs->cs_ip.tot_len) - hlen){\r\nchanges = SPECIAL_I;\r\ncp = new_seq;\r\n}\r\nbreak;\r\ncase NEW_S:\r\nif(deltaS == ntohs(cs->cs_ip.tot_len) - hlen){\r\nchanges = SPECIAL_D;\r\ncp = new_seq;\r\n}\r\nbreak;\r\n}\r\ndeltaS = ntohs(ip->id) - ntohs(cs->cs_ip.id);\r\nif(deltaS != 1){\r\ncp = encode(cp,deltaS);\r\nchanges |= NEW_I;\r\n}\r\nif(th->psh)\r\nchanges |= TCP_PUSH_BIT;\r\ncsum = th->check;\r\nmemcpy(&cs->cs_ip,ip,20);\r\nmemcpy(&cs->cs_tcp,th,20);\r\ndeltaS = cp - new_seq;\r\nif(compress_cid == 0 || comp->xmit_current != cs->cs_this){\r\ncp = ocp;\r\n*cpp = ocp;\r\n*cp++ = changes | NEW_C;\r\n*cp++ = cs->cs_this;\r\ncomp->xmit_current = cs->cs_this;\r\n} else {\r\ncp = ocp;\r\n*cpp = ocp;\r\n*cp++ = changes;\r\n}\r\n*(__sum16 *)cp = csum;\r\ncp += 2;\r\nmemcpy(cp,new_seq,deltaS);\r\nmemcpy(cp+deltaS,icp+hlen,isize-hlen);\r\ncomp->sls_o_compressed++;\r\nocp[0] |= SL_TYPE_COMPRESSED_TCP;\r\nreturn isize - hlen + deltaS + (cp - ocp);\r\nuncompressed:\r\nmemcpy(&cs->cs_ip,ip,20);\r\nmemcpy(&cs->cs_tcp,th,20);\r\nif (ip->ihl > 5)\r\nmemcpy(cs->cs_ipopt, ip+1, ((ip->ihl) - 5) * 4);\r\nif (th->doff > 5)\r\nmemcpy(cs->cs_tcpopt, th+1, ((th->doff) - 5) * 4);\r\ncomp->xmit_current = cs->cs_this;\r\ncomp->sls_o_uncompressed++;\r\nmemcpy(ocp, icp, isize);\r\n*cpp = ocp;\r\nocp[9] = cs->cs_this;\r\nocp[0] |= SL_TYPE_UNCOMPRESSED_TCP;\r\nreturn isize;\r\n}\r\nint\r\nslhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)\r\n{\r\nregister int changes;\r\nlong x;\r\nregister struct tcphdr *thp;\r\nregister struct iphdr *ip;\r\nregister struct cstate *cs;\r\nint len, hdrlen;\r\nunsigned char *cp = icp;\r\ncomp->sls_i_compressed++;\r\nif(isize < 3){\r\ncomp->sls_i_error++;\r\nreturn 0;\r\n}\r\nchanges = *cp++;\r\nif(changes & NEW_C){\r\nx = *cp++;\r\nif(x < 0 || x > comp->rslot_limit)\r\ngoto bad;\r\ncomp->flags &=~ SLF_TOSS;\r\ncomp->recv_current = x;\r\n} else {\r\nif(comp->flags & SLF_TOSS){\r\ncomp->sls_i_tossed++;\r\nreturn 0;\r\n}\r\n}\r\ncs = &comp->rstate[comp->recv_current];\r\nthp = &cs->cs_tcp;\r\nip = &cs->cs_ip;\r\nthp->check = *(__sum16 *)cp;\r\ncp += 2;\r\nthp->psh = (changes & TCP_PUSH_BIT) ? 1 : 0;\r\nhdrlen = ip->ihl * 4 + thp->doff * 4;\r\nswitch(changes & SPECIALS_MASK){\r\ncase SPECIAL_I:\r\n{\r\nregister short i;\r\ni = ntohs(ip->tot_len) - hdrlen;\r\nthp->ack_seq = htonl( ntohl(thp->ack_seq) + i);\r\nthp->seq = htonl( ntohl(thp->seq) + i);\r\n}\r\nbreak;\r\ncase SPECIAL_D:\r\nthp->seq = htonl( ntohl(thp->seq) +\r\nntohs(ip->tot_len) - hdrlen);\r\nbreak;\r\ndefault:\r\nif(changes & NEW_U){\r\nthp->urg = 1;\r\nif((x = decode(&cp)) == -1) {\r\ngoto bad;\r\n}\r\nthp->urg_ptr = htons(x);\r\n} else\r\nthp->urg = 0;\r\nif(changes & NEW_W){\r\nif((x = decode(&cp)) == -1) {\r\ngoto bad;\r\n}\r\nthp->window = htons( ntohs(thp->window) + x);\r\n}\r\nif(changes & NEW_A){\r\nif((x = decode(&cp)) == -1) {\r\ngoto bad;\r\n}\r\nthp->ack_seq = htonl( ntohl(thp->ack_seq) + x);\r\n}\r\nif(changes & NEW_S){\r\nif((x = decode(&cp)) == -1) {\r\ngoto bad;\r\n}\r\nthp->seq = htonl( ntohl(thp->seq) + x);\r\n}\r\nbreak;\r\n}\r\nif(changes & NEW_I){\r\nif((x = decode(&cp)) == -1) {\r\ngoto bad;\r\n}\r\nip->id = htons (ntohs (ip->id) + x);\r\n} else\r\nip->id = htons (ntohs (ip->id) + 1);\r\nlen = isize - (cp - icp);\r\nif (len < 0)\r\ngoto bad;\r\nlen += hdrlen;\r\nip->tot_len = htons(len);\r\nip->check = 0;\r\nmemmove(icp + hdrlen, cp, len - hdrlen);\r\ncp = icp;\r\nmemcpy(cp, ip, 20);\r\ncp += 20;\r\nif (ip->ihl > 5) {\r\nmemcpy(cp, cs->cs_ipopt, (ip->ihl - 5) * 4);\r\ncp += (ip->ihl - 5) * 4;\r\n}\r\nput_unaligned(ip_fast_csum(icp, ip->ihl),\r\n&((struct iphdr *)icp)->check);\r\nmemcpy(cp, thp, 20);\r\ncp += 20;\r\nif (thp->doff > 5) {\r\nmemcpy(cp, cs->cs_tcpopt, ((thp->doff) - 5) * 4);\r\ncp += ((thp->doff) - 5) * 4;\r\n}\r\nreturn len;\r\nbad:\r\ncomp->sls_i_error++;\r\nreturn slhc_toss( comp );\r\n}\r\nint\r\nslhc_remember(struct slcompress *comp, unsigned char *icp, int isize)\r\n{\r\nregister struct cstate *cs;\r\nunsigned ihl;\r\nunsigned char index;\r\nif(isize < 20) {\r\ncomp->sls_i_runt++;\r\nreturn slhc_toss( comp );\r\n}\r\nihl = icp[0] & 0xf;\r\nif(ihl < 20 / 4){\r\ncomp->sls_i_runt++;\r\nreturn slhc_toss( comp );\r\n}\r\nindex = icp[9];\r\nicp[9] = IPPROTO_TCP;\r\nif (ip_fast_csum(icp, ihl)) {\r\ncomp->sls_i_badcheck++;\r\nreturn slhc_toss( comp );\r\n}\r\nif(index > comp->rslot_limit) {\r\ncomp->sls_i_error++;\r\nreturn slhc_toss(comp);\r\n}\r\ncs = &comp->rstate[comp->recv_current = index];\r\ncomp->flags &=~ SLF_TOSS;\r\nmemcpy(&cs->cs_ip,icp,20);\r\nmemcpy(&cs->cs_tcp,icp + ihl*4,20);\r\nif (ihl > 5)\r\nmemcpy(cs->cs_ipopt, icp + sizeof(struct iphdr), (ihl - 5) * 4);\r\nif (cs->cs_tcp.doff > 5)\r\nmemcpy(cs->cs_tcpopt, icp + ihl*4 + sizeof(struct tcphdr), (cs->cs_tcp.doff - 5) * 4);\r\ncs->cs_hsize = ihl*2 + cs->cs_tcp.doff*2;\r\ncomp->sls_i_uncompressed++;\r\nreturn isize;\r\n}\r\nint\r\nslhc_toss(struct slcompress *comp)\r\n{\r\nif ( comp == NULLSLCOMPR )\r\nreturn 0;\r\ncomp->flags |= SLF_TOSS;\r\nreturn 0;\r\n}\r\nint\r\nslhc_toss(struct slcompress *comp)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_toss");\r\nreturn -EINVAL;\r\n}\r\nint\r\nslhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_uncompress");\r\nreturn -EINVAL;\r\n}\r\nint\r\nslhc_compress(struct slcompress *comp, unsigned char *icp, int isize,\r\nunsigned char *ocp, unsigned char **cpp, int compress_cid)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_compress");\r\nreturn -EINVAL;\r\n}\r\nint\r\nslhc_remember(struct slcompress *comp, unsigned char *icp, int isize)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_remember");\r\nreturn -EINVAL;\r\n}\r\nvoid\r\nslhc_free(struct slcompress *comp)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_free");\r\n}\r\nstruct slcompress *\r\nslhc_init(int rslots, int tslots)\r\n{\r\nprintk(KERN_DEBUG "Called IP function on non IP-system: slhc_init");\r\nreturn NULL;\r\n}
