static inline int smb_hc_read(struct acpi_smb_hc *hc, u8 address, u8 *data)\r\n{\r\nreturn ec_read(hc->offset + address, data);\r\n}\r\nstatic inline int smb_hc_write(struct acpi_smb_hc *hc, u8 address, u8 data)\r\n{\r\nreturn ec_write(hc->offset + address, data);\r\n}\r\nstatic inline int smb_check_done(struct acpi_smb_hc *hc)\r\n{\r\nunion acpi_smb_status status = {.raw = 0};\r\nsmb_hc_read(hc, ACPI_SMB_STATUS, &status.raw);\r\nreturn status.fields.done && (status.fields.status == SMBUS_OK);\r\n}\r\nstatic int wait_transaction_complete(struct acpi_smb_hc *hc, int timeout)\r\n{\r\nif (wait_event_timeout(hc->wait, smb_check_done(hc),\r\nmsecs_to_jiffies(timeout)))\r\nreturn 0;\r\nif (smb_check_done(hc))\r\nreturn 0;\r\nelse\r\nreturn -ETIME;\r\n}\r\nstatic int acpi_smbus_transaction(struct acpi_smb_hc *hc, u8 protocol,\r\nu8 address, u8 command, u8 *data, u8 length)\r\n{\r\nint ret = -EFAULT, i;\r\nu8 temp, sz = 0;\r\nif (!hc) {\r\nprintk(KERN_ERR PREFIX "host controller is not configured\n");\r\nreturn ret;\r\n}\r\nmutex_lock(&hc->lock);\r\nif (macbook)\r\nudelay(5);\r\nif (smb_hc_read(hc, ACPI_SMB_PROTOCOL, &temp))\r\ngoto end;\r\nif (temp) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nsmb_hc_write(hc, ACPI_SMB_COMMAND, command);\r\nif (!(protocol & 0x01)) {\r\nsmb_hc_write(hc, ACPI_SMB_BLOCK_COUNT, length);\r\nfor (i = 0; i < length; ++i)\r\nsmb_hc_write(hc, ACPI_SMB_DATA + i, data[i]);\r\n}\r\nsmb_hc_write(hc, ACPI_SMB_ADDRESS, address << 1);\r\nsmb_hc_write(hc, ACPI_SMB_PROTOCOL, protocol);\r\nret = wait_transaction_complete(hc, 1000);\r\nif (ret || !(protocol & 0x01))\r\ngoto end;\r\nswitch (protocol) {\r\ncase SMBUS_RECEIVE_BYTE:\r\ncase SMBUS_READ_BYTE:\r\nsz = 1;\r\nbreak;\r\ncase SMBUS_READ_WORD:\r\nsz = 2;\r\nbreak;\r\ncase SMBUS_READ_BLOCK:\r\nif (smb_hc_read(hc, ACPI_SMB_BLOCK_COUNT, &sz)) {\r\nret = -EFAULT;\r\ngoto end;\r\n}\r\nsz &= 0x1f;\r\nbreak;\r\n}\r\nfor (i = 0; i < sz; ++i)\r\nsmb_hc_read(hc, ACPI_SMB_DATA + i, &data[i]);\r\nend:\r\nmutex_unlock(&hc->lock);\r\nreturn ret;\r\n}\r\nint acpi_smbus_read(struct acpi_smb_hc *hc, u8 protocol, u8 address,\r\nu8 command, u8 *data)\r\n{\r\nreturn acpi_smbus_transaction(hc, protocol, address, command, data, 0);\r\n}\r\nint acpi_smbus_write(struct acpi_smb_hc *hc, u8 protocol, u8 address,\r\nu8 command, u8 *data, u8 length)\r\n{\r\nreturn acpi_smbus_transaction(hc, protocol, address, command, data, length);\r\n}\r\nint acpi_smbus_register_callback(struct acpi_smb_hc *hc,\r\nsmbus_alarm_callback callback, void *context)\r\n{\r\nmutex_lock(&hc->lock);\r\nhc->callback = callback;\r\nhc->context = context;\r\nmutex_unlock(&hc->lock);\r\nreturn 0;\r\n}\r\nint acpi_smbus_unregister_callback(struct acpi_smb_hc *hc)\r\n{\r\nmutex_lock(&hc->lock);\r\nhc->callback = NULL;\r\nhc->context = NULL;\r\nmutex_unlock(&hc->lock);\r\nreturn 0;\r\n}\r\nstatic inline void acpi_smbus_callback(void *context)\r\n{\r\nstruct acpi_smb_hc *hc = context;\r\nif (hc->callback)\r\nhc->callback(hc->context);\r\n}\r\nstatic int smbus_alarm(void *context)\r\n{\r\nstruct acpi_smb_hc *hc = context;\r\nunion acpi_smb_status status;\r\nu8 address;\r\nif (smb_hc_read(hc, ACPI_SMB_STATUS, &status.raw))\r\nreturn 0;\r\nif (status.fields.done)\r\nwake_up(&hc->wait);\r\nif (!status.fields.alarm)\r\nreturn 0;\r\nmutex_lock(&hc->lock);\r\nsmb_hc_read(hc, ACPI_SMB_ALARM_ADDRESS, &address);\r\nstatus.fields.alarm = 0;\r\nsmb_hc_write(hc, ACPI_SMB_STATUS, status.raw);\r\nswitch (address >> 1) {\r\ncase ACPI_SBS_CHARGER:\r\ncase ACPI_SBS_MANAGER:\r\ncase ACPI_SBS_BATTERY:\r\nacpi_os_execute(OSL_NOTIFY_HANDLER,\r\nacpi_smbus_callback, hc);\r\ndefault:;\r\n}\r\nmutex_unlock(&hc->lock);\r\nreturn 0;\r\n}\r\nstatic int macbook_dmi_match(const struct dmi_system_id *d)\r\n{\r\npr_debug("Detected MacBook, enabling workaround\n");\r\nmacbook = true;\r\nreturn 0;\r\n}\r\nstatic int acpi_smbus_hc_add(struct acpi_device *device)\r\n{\r\nint status;\r\nunsigned long long val;\r\nstruct acpi_smb_hc *hc;\r\ndmi_check_system(acpi_smbus_dmi_table);\r\nif (!device)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(device->handle, "_EC", NULL, &val);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX "error obtaining _EC.\n");\r\nreturn -EIO;\r\n}\r\nstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\r\nhc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\r\nif (!hc)\r\nreturn -ENOMEM;\r\nmutex_init(&hc->lock);\r\ninit_waitqueue_head(&hc->wait);\r\nhc->ec = acpi_driver_data(device->parent);\r\nhc->offset = (val >> 8) & 0xff;\r\nhc->query_bit = val & 0xff;\r\ndevice->driver_data = hc;\r\nacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\r\nprintk(KERN_INFO PREFIX "SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\n",\r\nhc->ec, hc->offset, hc->query_bit);\r\nreturn 0;\r\n}\r\nstatic int acpi_smbus_hc_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_smb_hc *hc;\r\nif (!device)\r\nreturn -EINVAL;\r\nhc = acpi_driver_data(device);\r\nacpi_ec_remove_query_handler(hc->ec, hc->query_bit);\r\nkfree(hc);\r\ndevice->driver_data = NULL;\r\nreturn 0;\r\n}
