static void meson_i2c_set_mask(struct meson_i2c *i2c, int reg, u32 mask,\r\nu32 val)\r\n{\r\nu32 data;\r\ndata = readl(i2c->regs + reg);\r\ndata &= ~mask;\r\ndata |= val & mask;\r\nwritel(data, i2c->regs + reg);\r\n}\r\nstatic void meson_i2c_reset_tokens(struct meson_i2c *i2c)\r\n{\r\ni2c->tokens[0] = 0;\r\ni2c->tokens[1] = 0;\r\ni2c->num_tokens = 0;\r\n}\r\nstatic void meson_i2c_add_token(struct meson_i2c *i2c, int token)\r\n{\r\nif (i2c->num_tokens < 8)\r\ni2c->tokens[0] |= (token & 0xf) << (i2c->num_tokens * 4);\r\nelse\r\ni2c->tokens[1] |= (token & 0xf) << ((i2c->num_tokens % 8) * 4);\r\ni2c->num_tokens++;\r\n}\r\nstatic void meson_i2c_write_tokens(struct meson_i2c *i2c)\r\n{\r\nwritel(i2c->tokens[0], i2c->regs + REG_TOK_LIST0);\r\nwritel(i2c->tokens[1], i2c->regs + REG_TOK_LIST1);\r\n}\r\nstatic void meson_i2c_set_clk_div(struct meson_i2c *i2c)\r\n{\r\nunsigned long clk_rate = clk_get_rate(i2c->clk);\r\nunsigned int div;\r\ndiv = DIV_ROUND_UP(clk_rate, i2c->frequency * 4);\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_CLKDIV_MASK,\r\ndiv << REG_CTRL_CLKDIV_SHIFT);\r\ndev_dbg(i2c->dev, "%s: clk %lu, freq %u, div %u\n", __func__,\r\nclk_rate, i2c->frequency, div);\r\n}\r\nstatic void meson_i2c_get_data(struct meson_i2c *i2c, char *buf, int len)\r\n{\r\nu32 rdata0, rdata1;\r\nint i;\r\nrdata0 = readl(i2c->regs + REG_TOK_RDATA0);\r\nrdata1 = readl(i2c->regs + REG_TOK_RDATA1);\r\ndev_dbg(i2c->dev, "%s: data %08x %08x len %d\n", __func__,\r\nrdata0, rdata1, len);\r\nfor (i = 0; i < min_t(int, 4, len); i++)\r\n*buf++ = (rdata0 >> i * 8) & 0xff;\r\nfor (i = 4; i < min_t(int, 8, len); i++)\r\n*buf++ = (rdata1 >> (i - 4) * 8) & 0xff;\r\n}\r\nstatic void meson_i2c_put_data(struct meson_i2c *i2c, char *buf, int len)\r\n{\r\nu32 wdata0 = 0, wdata1 = 0;\r\nint i;\r\nfor (i = 0; i < min_t(int, 4, len); i++)\r\nwdata0 |= *buf++ << (i * 8);\r\nfor (i = 4; i < min_t(int, 8, len); i++)\r\nwdata1 |= *buf++ << ((i - 4) * 8);\r\nwritel(wdata0, i2c->regs + REG_TOK_WDATA0);\r\nwritel(wdata0, i2c->regs + REG_TOK_WDATA1);\r\ndev_dbg(i2c->dev, "%s: data %08x %08x len %d\n", __func__,\r\nwdata0, wdata1, len);\r\n}\r\nstatic void meson_i2c_prepare_xfer(struct meson_i2c *i2c)\r\n{\r\nbool write = !(i2c->msg->flags & I2C_M_RD);\r\nint i;\r\ni2c->count = min_t(int, i2c->msg->len - i2c->pos, 8);\r\nfor (i = 0; i < i2c->count - 1; i++)\r\nmeson_i2c_add_token(i2c, TOKEN_DATA);\r\nif (i2c->count) {\r\nif (write || i2c->pos + i2c->count < i2c->msg->len)\r\nmeson_i2c_add_token(i2c, TOKEN_DATA);\r\nelse\r\nmeson_i2c_add_token(i2c, TOKEN_DATA_LAST);\r\n}\r\nif (write)\r\nmeson_i2c_put_data(i2c, i2c->msg->buf + i2c->pos, i2c->count);\r\n}\r\nstatic void meson_i2c_stop(struct meson_i2c *i2c)\r\n{\r\ndev_dbg(i2c->dev, "%s: last %d\n", __func__, i2c->last);\r\nif (i2c->last) {\r\ni2c->state = STATE_STOP;\r\nmeson_i2c_add_token(i2c, TOKEN_STOP);\r\n} else {\r\ni2c->state = STATE_IDLE;\r\ncomplete_all(&i2c->done);\r\n}\r\n}\r\nstatic irqreturn_t meson_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct meson_i2c *i2c = dev_id;\r\nunsigned int ctrl;\r\nspin_lock(&i2c->lock);\r\nmeson_i2c_reset_tokens(i2c);\r\nctrl = readl(i2c->regs + REG_CTRL);\r\ndev_dbg(i2c->dev, "irq: state %d, pos %d, count %d, ctrl %08x\n",\r\ni2c->state, i2c->pos, i2c->count, ctrl);\r\nif (ctrl & REG_CTRL_ERROR && i2c->state != STATE_IDLE) {\r\ndev_dbg(i2c->dev, "error bit set\n");\r\ni2c->error = -ENXIO;\r\ni2c->state = STATE_IDLE;\r\ncomplete_all(&i2c->done);\r\ngoto out;\r\n}\r\nswitch (i2c->state) {\r\ncase STATE_READ:\r\nif (i2c->count > 0) {\r\nmeson_i2c_get_data(i2c, i2c->msg->buf + i2c->pos,\r\ni2c->count);\r\ni2c->pos += i2c->count;\r\n}\r\nif (i2c->pos >= i2c->msg->len) {\r\nmeson_i2c_stop(i2c);\r\nbreak;\r\n}\r\nmeson_i2c_prepare_xfer(i2c);\r\nbreak;\r\ncase STATE_WRITE:\r\ni2c->pos += i2c->count;\r\nif (i2c->pos >= i2c->msg->len) {\r\nmeson_i2c_stop(i2c);\r\nbreak;\r\n}\r\nmeson_i2c_prepare_xfer(i2c);\r\nbreak;\r\ncase STATE_STOP:\r\ni2c->state = STATE_IDLE;\r\ncomplete_all(&i2c->done);\r\nbreak;\r\ncase STATE_IDLE:\r\nbreak;\r\n}\r\nout:\r\nif (i2c->state != STATE_IDLE) {\r\nmeson_i2c_write_tokens(i2c);\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START,\r\nREG_CTRL_START);\r\n}\r\nspin_unlock(&i2c->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void meson_i2c_do_start(struct meson_i2c *i2c, struct i2c_msg *msg)\r\n{\r\nint token;\r\ntoken = (msg->flags & I2C_M_RD) ? TOKEN_SLAVE_ADDR_READ :\r\nTOKEN_SLAVE_ADDR_WRITE;\r\nwritel(msg->addr << 1, i2c->regs + REG_SLAVE_ADDR);\r\nmeson_i2c_add_token(i2c, TOKEN_START);\r\nmeson_i2c_add_token(i2c, token);\r\n}\r\nstatic int meson_i2c_xfer_msg(struct meson_i2c *i2c, struct i2c_msg *msg,\r\nint last)\r\n{\r\nunsigned long time_left, flags;\r\nint ret = 0;\r\ni2c->msg = msg;\r\ni2c->last = last;\r\ni2c->pos = 0;\r\ni2c->count = 0;\r\ni2c->error = 0;\r\nmeson_i2c_reset_tokens(i2c);\r\nflags = (msg->flags & I2C_M_IGNORE_NAK) ? REG_CTRL_ACK_IGNORE : 0;\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_ACK_IGNORE, flags);\r\nif (!(msg->flags & I2C_M_NOSTART))\r\nmeson_i2c_do_start(i2c, msg);\r\ni2c->state = (msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;\r\nmeson_i2c_prepare_xfer(i2c);\r\nmeson_i2c_write_tokens(i2c);\r\nreinit_completion(&i2c->done);\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, REG_CTRL_START);\r\ntime_left = msecs_to_jiffies(I2C_TIMEOUT_MS);\r\ntime_left = wait_for_completion_timeout(&i2c->done, time_left);\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\r\nif (!time_left) {\r\ni2c->state = STATE_IDLE;\r\nret = -ETIMEDOUT;\r\n}\r\nif (i2c->error)\r\nret = i2c->error;\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int meson_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct meson_i2c *i2c = adap->algo_data;\r\nint i, ret = 0, count = 0;\r\nclk_enable(i2c->clk);\r\nmeson_i2c_set_clk_div(i2c);\r\nfor (i = 0; i < num; i++) {\r\nret = meson_i2c_xfer_msg(i2c, msgs + i, i == num - 1);\r\nif (ret)\r\nbreak;\r\ncount++;\r\n}\r\nclk_disable(i2c->clk);\r\nreturn ret ? ret : count;\r\n}\r\nstatic u32 meson_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int meson_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct meson_i2c *i2c;\r\nstruct resource *mem;\r\nint ret = 0;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct meson_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&i2c->frequency))\r\ni2c->frequency = DEFAULT_FREQ;\r\ni2c->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, i2c);\r\nspin_lock_init(&i2c->lock);\r\ninit_completion(&i2c->done);\r\ni2c->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "can't get device clock\n");\r\nreturn PTR_ERR(i2c->clk);\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(i2c->regs))\r\nreturn PTR_ERR(i2c->regs);\r\ni2c->irq = platform_get_irq(pdev, 0);\r\nif (i2c->irq < 0) {\r\ndev_err(&pdev->dev, "can't find IRQ\n");\r\nreturn i2c->irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c->irq, meson_i2c_irq,\r\n0, dev_name(&pdev->dev), i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't request IRQ\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare(i2c->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't prepare clock\n");\r\nreturn ret;\r\n}\r\nstrlcpy(i2c->adap.name, "Meson I2C adapter",\r\nsizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &meson_i2c_algorithm;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = np;\r\ni2c->adap.algo_data = i2c;\r\nmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't register adapter\n");\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int meson_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct meson_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_unprepare(i2c->clk);\r\nreturn 0;\r\n}
