static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 * data, int len)\r\n{\r\nstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len };\r\nif (i2c_transfer(adap, &msg, 1) != 1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int i2c_read(struct i2c_adapter *adap,\r\nu8 adr, u8 *msg, int len, u8 *answ, int alen)\r\n{\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = adr, .flags = 0,\r\n.buf = msg, .len = len\r\n}, {\r\n.addr = adr, .flags = I2C_M_RD,\r\n.buf = answ, .len = alen\r\n}\r\n};\r\nif (i2c_transfer(adap, msgs, 2) != 2)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic inline u32 MulDiv32(u32 a, u32 b, u32 c)\r\n{\r\nu64 tmp64;\r\ntmp64 = (u64)a * (u64)b;\r\ndo_div(tmp64, c);\r\nreturn (u32) tmp64;\r\n}\r\nstatic int Read16(struct drxd_state *state, u32 reg, u16 *data, u8 flags)\r\n{\r\nu8 adr = state->config.demod_address;\r\nu8 mm1[4] = { reg & 0xff, (reg >> 16) & 0xff,\r\nflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\r\n};\r\nu8 mm2[2];\r\nif (i2c_read(state->i2c, adr, mm1, 4, mm2, 2) < 0)\r\nreturn -1;\r\nif (data)\r\n*data = mm2[0] | (mm2[1] << 8);\r\nreturn mm2[0] | (mm2[1] << 8);\r\n}\r\nstatic int Read32(struct drxd_state *state, u32 reg, u32 *data, u8 flags)\r\n{\r\nu8 adr = state->config.demod_address;\r\nu8 mm1[4] = { reg & 0xff, (reg >> 16) & 0xff,\r\nflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\r\n};\r\nu8 mm2[4];\r\nif (i2c_read(state->i2c, adr, mm1, 4, mm2, 4) < 0)\r\nreturn -1;\r\nif (data)\r\n*data =\r\nmm2[0] | (mm2[1] << 8) | (mm2[2] << 16) | (mm2[3] << 24);\r\nreturn 0;\r\n}\r\nstatic int Write16(struct drxd_state *state, u32 reg, u16 data, u8 flags)\r\n{\r\nu8 adr = state->config.demod_address;\r\nu8 mm[6] = { reg & 0xff, (reg >> 16) & 0xff,\r\nflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff,\r\ndata & 0xff, (data >> 8) & 0xff\r\n};\r\nif (i2c_write(state->i2c, adr, mm, 6) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int Write32(struct drxd_state *state, u32 reg, u32 data, u8 flags)\r\n{\r\nu8 adr = state->config.demod_address;\r\nu8 mm[8] = { reg & 0xff, (reg >> 16) & 0xff,\r\nflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff,\r\ndata & 0xff, (data >> 8) & 0xff,\r\n(data >> 16) & 0xff, (data >> 24) & 0xff\r\n};\r\nif (i2c_write(state->i2c, adr, mm, 8) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int write_chunk(struct drxd_state *state,\r\nu32 reg, u8 *data, u32 len, u8 flags)\r\n{\r\nu8 adr = state->config.demod_address;\r\nu8 mm[CHUNK_SIZE + 4] = { reg & 0xff, (reg >> 16) & 0xff,\r\nflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\r\n};\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nmm[4 + i] = data[i];\r\nif (i2c_write(state->i2c, adr, mm, 4 + len) < 0) {\r\nprintk(KERN_ERR "error in write_chunk\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int WriteBlock(struct drxd_state *state,\r\nu32 Address, u16 BlockSize, u8 *pBlock, u8 Flags)\r\n{\r\nwhile (BlockSize > 0) {\r\nu16 Chunk = BlockSize > CHUNK_SIZE ? CHUNK_SIZE : BlockSize;\r\nif (write_chunk(state, Address, pBlock, Chunk, Flags) < 0)\r\nreturn -1;\r\npBlock += Chunk;\r\nAddress += (Chunk >> 1);\r\nBlockSize -= Chunk;\r\n}\r\nreturn 0;\r\n}\r\nstatic int WriteTable(struct drxd_state *state, u8 * pTable)\r\n{\r\nint status = 0;\r\nif (pTable == NULL)\r\nreturn 0;\r\nwhile (!status) {\r\nu16 Length;\r\nu32 Address = pTable[0] | (pTable[1] << 8) |\r\n(pTable[2] << 16) | (pTable[3] << 24);\r\nif (Address == 0xFFFFFFFF)\r\nbreak;\r\npTable += sizeof(u32);\r\nLength = pTable[0] | (pTable[1] << 8);\r\npTable += sizeof(u16);\r\nif (!Length)\r\nbreak;\r\nstatus = WriteBlock(state, Address, Length * 2, pTable, 0);\r\npTable += (Length * 2);\r\n}\r\nreturn status;\r\n}\r\nstatic int ResetCEFR(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_ResetCEFR);\r\n}\r\nstatic int InitCP(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_InitCP);\r\n}\r\nstatic int InitCE(struct drxd_state *state)\r\n{\r\nint status;\r\nenum app_env AppEnv = state->app_env_default;\r\ndo {\r\nstatus = WriteTable(state, state->m_InitCE);\r\nif (status < 0)\r\nbreak;\r\nif (state->operation_mode == OM_DVBT_Diversity_Front ||\r\nstate->operation_mode == OM_DVBT_Diversity_End) {\r\nAppEnv = state->app_env_diversity;\r\n}\r\nif (AppEnv == APPENV_STATIC) {\r\nstatus = Write16(state, CE_REG_TAPSET__A, 0x0000, 0);\r\nif (status < 0)\r\nbreak;\r\n} else if (AppEnv == APPENV_PORTABLE) {\r\nstatus = Write16(state, CE_REG_TAPSET__A, 0x0001, 0);\r\nif (status < 0)\r\nbreak;\r\n} else if (AppEnv == APPENV_MOBILE && state->type_A) {\r\nstatus = Write16(state, CE_REG_TAPSET__A, 0x0002, 0);\r\nif (status < 0)\r\nbreak;\r\n} else if (AppEnv == APPENV_MOBILE && !state->type_A) {\r\nstatus = Write16(state, CE_REG_TAPSET__A, 0x0006, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = Write16(state, B_CE_REG_COMM_EXEC__A, 0x0001, 0);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int StopOC(struct drxd_state *state)\r\n{\r\nint status = 0;\r\nu16 ocSyncLvl = 0;\r\nu16 ocModeLop = state->m_EcOcRegOcModeLop;\r\nu16 dtoIncLop = 0;\r\nu16 dtoIncHip = 0;\r\ndo {\r\nstatus = Read16(state, EC_OC_REG_SNC_ISC_LVL__A, &ocSyncLvl, 0);\r\nif (status < 0)\r\nbreak;\r\nstate->m_EcOcRegSncSncLvl = ocSyncLvl;\r\nstatus = Read16(state, EC_OC_REG_RCN_MAP_LOP__A, &dtoIncLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, EC_OC_REG_RCN_MAP_HIP__A, &dtoIncHip, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_DTO_INC_LOP__A, dtoIncLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_DTO_INC_HIP__A, dtoIncHip, 0);\r\nif (status < 0)\r\nbreak;\r\nocModeLop &= ~(EC_OC_REG_OC_MODE_LOP_DTO_CTR_SRC__M);\r\nocModeLop |= EC_OC_REG_OC_MODE_LOP_DTO_CTR_SRC_STATIC;\r\nstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, ocModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_HOLD, 0);\r\nif (status < 0)\r\nbreak;\r\nmsleep(1);\r\nstatus = Write16(state, EC_OC_REG_OCR_MPG_UOS__A, EC_OC_REG_OCR_MPG_UOS__M, 0);\r\nif (status < 0)\r\nbreak;\r\nocSyncLvl &= ~(EC_OC_REG_SNC_ISC_LVL_OSC__M);\r\nstatus = Write16(state, EC_OC_REG_SNC_ISC_LVL__A, ocSyncLvl, 0);\r\nif (status < 0)\r\nbreak;\r\nocModeLop &= ~(EC_OC_REG_OC_MODE_LOP_PAR_ENA__M);\r\nocModeLop |= EC_OC_REG_OC_MODE_LOP_PAR_ENA_ENABLE;\r\nocModeLop |= 0x2;\r\nstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, ocModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_COMM_INT_STA__A, 0x0, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_ACTIVE, 0);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int StartOC(struct drxd_state *state)\r\n{\r\nint status = 0;\r\ndo {\r\nstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_HOLD, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_SNC_ISC_LVL__A, state->m_EcOcRegSncSncLvl, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, state->m_EcOcRegOcModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_OCR_MPG_UOS__A, EC_OC_REG_OCR_MPG_UOS_INIT, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_ACTIVE, 0);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int InitEQ(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_InitEQ);\r\n}\r\nstatic int InitEC(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_InitEC);\r\n}\r\nstatic int InitSC(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_InitSC);\r\n}\r\nstatic int InitAtomicRead(struct drxd_state *state)\r\n{\r\nreturn WriteTable(state, state->m_InitAtomicRead);\r\n}\r\nstatic int DRX_GetLockStatus(struct drxd_state *state, u32 * pLockStatus)\r\n{\r\nu16 ScRaRamLock = 0;\r\nconst u16 mpeg_lock_mask = (SC_RA_RAM_LOCK_MPEG__M |\r\nSC_RA_RAM_LOCK_FEC__M |\r\nSC_RA_RAM_LOCK_DEMOD__M);\r\nconst u16 fec_lock_mask = (SC_RA_RAM_LOCK_FEC__M |\r\nSC_RA_RAM_LOCK_DEMOD__M);\r\nconst u16 demod_lock_mask = SC_RA_RAM_LOCK_DEMOD__M;\r\nint status;\r\n*pLockStatus = 0;\r\nstatus = Read16(state, SC_RA_RAM_LOCK__A, &ScRaRamLock, 0x0000);\r\nif (status < 0) {\r\nprintk(KERN_ERR "Can't read SC_RA_RAM_LOCK__A status = %08x\n", status);\r\nreturn status;\r\n}\r\nif (state->drxd_state != DRXD_STARTED)\r\nreturn 0;\r\nif ((ScRaRamLock & mpeg_lock_mask) == mpeg_lock_mask) {\r\n*pLockStatus |= DRX_LOCK_MPEG;\r\nCorrectSysClockDeviation(state);\r\n}\r\nif ((ScRaRamLock & fec_lock_mask) == fec_lock_mask)\r\n*pLockStatus |= DRX_LOCK_FEC;\r\nif ((ScRaRamLock & demod_lock_mask) == demod_lock_mask)\r\n*pLockStatus |= DRX_LOCK_DEMOD;\r\nreturn 0;\r\n}\r\nstatic int SetCfgIfAgc(struct drxd_state *state, struct SCfgAgc *cfg)\r\n{\r\nint status;\r\nif (cfg->outputLevel > DRXD_FE_CTRL_MAX)\r\nreturn -1;\r\nif (cfg->ctrlMode == AGC_CTRL_USER) {\r\ndo {\r\nu16 FeAgRegPm1AgcWri;\r\nu16 FeAgRegAgModeLop;\r\nstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &FeAgRegAgModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegAgModeLop &= (~FE_AG_REG_AG_MODE_LOP_MODE_4__M);\r\nFeAgRegAgModeLop |= FE_AG_REG_AG_MODE_LOP_MODE_4_STATIC;\r\nstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, FeAgRegAgModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegPm1AgcWri = (u16) (cfg->outputLevel &\r\nFE_AG_REG_PM1_AGC_WRI__M);\r\nstatus = Write16(state, FE_AG_REG_PM1_AGC_WRI__A, FeAgRegPm1AgcWri, 0);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\n} else if (cfg->ctrlMode == AGC_CTRL_AUTO) {\r\nif (((cfg->maxOutputLevel) < (cfg->minOutputLevel)) ||\r\n((cfg->maxOutputLevel) > DRXD_FE_CTRL_MAX) ||\r\n((cfg->speed) > DRXD_FE_CTRL_MAX) ||\r\n((cfg->settleLevel) > DRXD_FE_CTRL_MAX)\r\n)\r\nreturn -1;\r\ndo {\r\nu16 FeAgRegAgModeLop;\r\nu16 FeAgRegEgcSetLvl;\r\nu16 slope, offset;\r\nstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &FeAgRegAgModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegAgModeLop &= (~FE_AG_REG_AG_MODE_LOP_MODE_4__M);\r\nFeAgRegAgModeLop |=\r\nFE_AG_REG_AG_MODE_LOP_MODE_4_DYNAMIC;\r\nstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, FeAgRegAgModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegEgcSetLvl = (u16) ((cfg->settleLevel >> 1) &\r\nFE_AG_REG_EGC_SET_LVL__M);\r\nstatus = Write16(state, FE_AG_REG_EGC_SET_LVL__A, FeAgRegEgcSetLvl, 0);\r\nif (status < 0)\r\nbreak;\r\nslope = (u16) ((cfg->maxOutputLevel -\r\ncfg->minOutputLevel) / 2);\r\noffset = (u16) ((cfg->maxOutputLevel +\r\ncfg->minOutputLevel) / 2 - 511);\r\nstatus = Write16(state, FE_AG_REG_GC1_AGC_RIC__A, slope, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_GC1_AGC_OFF__A, offset, 0);\r\nif (status < 0)\r\nbreak;\r\n{\r\nconst u16 maxRur = 8;\r\nconst u16 slowIncrDecLUT[] = { 3, 4, 4, 5, 6 };\r\nconst u16 fastIncrDecLUT[] = { 14, 15, 15, 16,\r\n17, 18, 18, 19,\r\n20, 21, 22, 23,\r\n24, 26, 27, 28,\r\n29, 31\r\n};\r\nu16 fineSteps = (DRXD_FE_CTRL_MAX + 1) /\r\n(maxRur + 1);\r\nu16 fineSpeed = (u16) (cfg->speed -\r\n((cfg->speed /\r\nfineSteps) *\r\nfineSteps));\r\nu16 invRurCount = (u16) (cfg->speed /\r\nfineSteps);\r\nu16 rurCount;\r\nif (invRurCount > maxRur) {\r\nrurCount = 0;\r\nfineSpeed += fineSteps;\r\n} else {\r\nrurCount = maxRur - invRurCount;\r\n}\r\n{\r\nu16 fastIncrDec =\r\nfastIncrDecLUT[fineSpeed /\r\n((fineSteps /\r\n(14 + 1)) + 1)];\r\nu16 slowIncrDec =\r\nslowIncrDecLUT[fineSpeed /\r\n(fineSteps /\r\n(3 + 1))];\r\nstatus = Write16(state, FE_AG_REG_EGC_RUR_CNT__A, rurCount, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_EGC_FAS_INC__A, fastIncrDec, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_EGC_FAS_DEC__A, fastIncrDec, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_EGC_SLO_INC__A, slowIncrDec, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_EGC_SLO_DEC__A, slowIncrDec, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\n}\r\n} while (0);\r\n} else {\r\nreturn -1;\r\n}\r\nreturn status;\r\n}\r\nstatic int SetCfgRfAgc(struct drxd_state *state, struct SCfgAgc *cfg)\r\n{\r\nint status = 0;\r\nif (cfg->outputLevel > DRXD_FE_CTRL_MAX)\r\nreturn -1;\r\nif (cfg->ctrlMode == AGC_CTRL_USER) {\r\ndo {\r\nu16 AgModeLop = 0;\r\nu16 level = (cfg->outputLevel);\r\nif (level == DRXD_FE_CTRL_MAX)\r\nlevel++;\r\nstatus = Write16(state, FE_AG_REG_PM2_AGC_WRI__A, level, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstate->m_FeAgRegAgPwd &= ~(FE_AG_REG_AG_PWD_PWD_PD2__M);\r\nstate->m_FeAgRegAgPwd |=\r\nFE_AG_REG_AG_PWD_PWD_PD2_DISABLE;\r\nstatus = Write16(state, FE_AG_REG_AG_PWD__A, state->m_FeAgRegAgPwd, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E__M));\r\nAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E_STATIC);\r\nstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n{\r\nu16 FeAgRegAgAgcSio = 0;\r\nstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegAgAgcSio &=\r\n~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\r\nFeAgRegAgAgcSio |=\r\nFE_AG_REG_AG_AGC_SIO_AGC_SIO_2_OUTPUT;\r\nstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\n} else if (cfg->ctrlMode == AGC_CTRL_AUTO) {\r\nu16 AgModeLop = 0;\r\ndo {\r\nu16 level;\r\n(state->m_FeAgRegAgPwd) &=\r\n~(FE_AG_REG_AG_PWD_PWD_PD2__M);\r\n(state->m_FeAgRegAgPwd) |=\r\nFE_AG_REG_AG_PWD_PWD_PD2_DISABLE;\r\nstatus = Write16(state, FE_AG_REG_AG_PWD__A, (state->m_FeAgRegAgPwd), 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E__M));\r\nAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E_DYNAMIC);\r\nstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nlevel = (((cfg->settleLevel) >> 4) &\r\nFE_AG_REG_TGC_SET_LVL__M);\r\nstatus = Write16(state, FE_AG_REG_TGC_SET_LVL__A, level, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n{\r\nu16 FeAgRegAgAgcSio = 0;\r\nstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegAgAgcSio &=\r\n~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\r\nFeAgRegAgAgcSio |=\r\nFE_AG_REG_AG_AGC_SIO_AGC_SIO_2_OUTPUT;\r\nstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\n} else {\r\nu16 AgModeLop = 0;\r\ndo {\r\n(state->m_FeAgRegAgPwd) &=\r\n~(FE_AG_REG_AG_PWD_PWD_PD2__M);\r\n(state->m_FeAgRegAgPwd) |=\r\nFE_AG_REG_AG_PWD_PWD_PD2_ENABLE;\r\nstatus = Write16(state, FE_AG_REG_AG_PWD__A, (state->m_FeAgRegAgPwd), 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E__M));\r\nAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\r\nFE_AG_REG_AG_MODE_LOP_MODE_E_STATIC);\r\nstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n{\r\nu16 FeAgRegAgAgcSio = 0;\r\nstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nFeAgRegAgAgcSio &=\r\n~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\r\nFeAgRegAgAgcSio |=\r\nFE_AG_REG_AG_AGC_SIO_AGC_SIO_2_INPUT;\r\nstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\n}\r\nreturn status;\r\n}\r\nstatic int ReadIFAgc(struct drxd_state *state, u32 * pValue)\r\n{\r\nint status = 0;\r\n*pValue = 0;\r\nif (state->if_agc_cfg.ctrlMode != AGC_CTRL_OFF) {\r\nu16 Value;\r\nstatus = Read16(state, FE_AG_REG_GC1_AGC_DAT__A, &Value, 0);\r\nValue &= FE_AG_REG_GC1_AGC_DAT__M;\r\nif (status >= 0) {\r\nu32 R1 = state->if_agc_cfg.R1;\r\nu32 R2 = state->if_agc_cfg.R2;\r\nu32 R3 = state->if_agc_cfg.R3;\r\nu32 Vmax, Rpar, Vmin, Vout;\r\nif (R2 == 0 && (R1 == 0 || R3 == 0))\r\nreturn 0;\r\nVmax = (3300 * R2) / (R1 + R2);\r\nRpar = (R2 * R3) / (R3 + R2);\r\nVmin = (3300 * Rpar) / (R1 + Rpar);\r\nVout = Vmin + ((Vmax - Vmin) * Value) / 1024;\r\n*pValue = Vout;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int load_firmware(struct drxd_state *state, const char *fw_name)\r\n{\r\nconst struct firmware *fw;\r\nif (request_firmware(&fw, fw_name, state->dev) < 0) {\r\nprintk(KERN_ERR "drxd: firmware load failure [%s]\n", fw_name);\r\nreturn -EIO;\r\n}\r\nstate->microcode = kmemdup(fw->data, fw->size, GFP_KERNEL);\r\nif (state->microcode == NULL) {\r\nrelease_firmware(fw);\r\nprintk(KERN_ERR "drxd: firmware load failure: no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nstate->microcode_length = fw->size;\r\nrelease_firmware(fw);\r\nreturn 0;\r\n}\r\nstatic int DownloadMicrocode(struct drxd_state *state,\r\nconst u8 *pMCImage, u32 Length)\r\n{\r\nu8 *pSrc;\r\nu32 Address;\r\nu16 nBlocks;\r\nu16 BlockSize;\r\nu32 offset = 0;\r\nint i, status = 0;\r\npSrc = (u8 *) pMCImage;\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nnBlocks = (pSrc[0] << 8) | pSrc[1];\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nfor (i = 0; i < nBlocks; i++) {\r\nAddress = (pSrc[0] << 24) | (pSrc[1] << 16) |\r\n(pSrc[2] << 8) | pSrc[3];\r\npSrc += sizeof(u32);\r\noffset += sizeof(u32);\r\nBlockSize = ((pSrc[0] << 8) | pSrc[1]) * sizeof(u16);\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nstatus = WriteBlock(state, Address, BlockSize,\r\npSrc, DRX_I2C_CLEARCRC);\r\nif (status < 0)\r\nbreak;\r\npSrc += BlockSize;\r\noffset += BlockSize;\r\n}\r\nreturn status;\r\n}\r\nstatic int HI_Command(struct drxd_state *state, u16 cmd, u16 * pResult)\r\n{\r\nu32 nrRetries = 0;\r\nu16 waitCmd;\r\nint status;\r\nstatus = Write16(state, HI_RA_RAM_SRV_CMD__A, cmd, 0);\r\nif (status < 0)\r\nreturn status;\r\ndo {\r\nnrRetries += 1;\r\nif (nrRetries > DRXD_MAX_RETRIES) {\r\nstatus = -1;\r\nbreak;\r\n}\r\nstatus = Read16(state, HI_RA_RAM_SRV_CMD__A, &waitCmd, 0);\r\n} while (waitCmd != 0);\r\nif (status >= 0)\r\nstatus = Read16(state, HI_RA_RAM_SRV_RES__A, pResult, 0);\r\nreturn status;\r\n}\r\nstatic int HI_CfgCommand(struct drxd_state *state)\r\n{\r\nint status = 0;\r\nmutex_lock(&state->mutex);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_KEY__A, HI_RA_RAM_SRV_RST_KEY_ACT, 0);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_DIV__A, state->hi_cfg_timing_div, 0);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_BDL__A, state->hi_cfg_bridge_delay, 0);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_WUP__A, state->hi_cfg_wakeup_key, 0);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_ACT__A, state->hi_cfg_ctrl, 0);\r\nWrite16(state, HI_RA_RAM_SRV_CFG_KEY__A, HI_RA_RAM_SRV_RST_KEY_ACT, 0);\r\nif ((state->hi_cfg_ctrl & HI_RA_RAM_SRV_CFG_ACT_PWD_EXE) ==\r\nHI_RA_RAM_SRV_CFG_ACT_PWD_EXE)\r\nstatus = Write16(state, HI_RA_RAM_SRV_CMD__A,\r\nHI_RA_RAM_SRV_CMD_CONFIG, 0);\r\nelse\r\nstatus = HI_Command(state, HI_RA_RAM_SRV_CMD_CONFIG, NULL);\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int InitHI(struct drxd_state *state)\r\n{\r\nstate->hi_cfg_wakeup_key = (state->chip_adr);\r\nstate->hi_cfg_ctrl = HI_RA_RAM_SRV_CFG_ACT_SLV0_ON;\r\nreturn HI_CfgCommand(state);\r\n}\r\nstatic int HI_ResetCommand(struct drxd_state *state)\r\n{\r\nint status;\r\nmutex_lock(&state->mutex);\r\nstatus = Write16(state, HI_RA_RAM_SRV_RST_KEY__A,\r\nHI_RA_RAM_SRV_RST_KEY_ACT, 0);\r\nif (status == 0)\r\nstatus = HI_Command(state, HI_RA_RAM_SRV_CMD_RESET, NULL);\r\nmutex_unlock(&state->mutex);\r\nmsleep(1);\r\nreturn status;\r\n}\r\nstatic int DRX_ConfigureI2CBridge(struct drxd_state *state, int bEnableBridge)\r\n{\r\nstate->hi_cfg_ctrl &= (~HI_RA_RAM_SRV_CFG_ACT_BRD__M);\r\nif (bEnableBridge)\r\nstate->hi_cfg_ctrl |= HI_RA_RAM_SRV_CFG_ACT_BRD_ON;\r\nelse\r\nstate->hi_cfg_ctrl |= HI_RA_RAM_SRV_CFG_ACT_BRD_OFF;\r\nreturn HI_CfgCommand(state);\r\n}\r\nstatic int StopAllProcessors(struct drxd_state *state)\r\n{\r\nreturn Write16(state, HI_COMM_EXEC__A,\r\nSC_COMM_EXEC_CTL_STOP, DRX_I2C_BROADCAST);\r\n}\r\nstatic int EnableAndResetMB(struct drxd_state *state)\r\n{\r\nif (state->type_A) {\r\nWrite16(state, EC_OC_REG_OC_MON_SIO__A, 0x0000, 0x0000);\r\n}\r\nWrite16(state, HI_COMM_MB__A, 0x0000, DRX_I2C_BROADCAST);\r\nWrite16(state, HI_COMM_MB__A, 0x0000, 0x0000);\r\nreturn 0;\r\n}\r\nstatic int InitCC(struct drxd_state *state)\r\n{\r\nif (state->osc_clock_freq == 0 ||\r\nstate->osc_clock_freq > 20000 ||\r\n(state->osc_clock_freq % 4000) != 0) {\r\nprintk(KERN_ERR "invalid osc frequency %d\n", state->osc_clock_freq);\r\nreturn -1;\r\n}\r\nWrite16(state, CC_REG_OSC_MODE__A, CC_REG_OSC_MODE_M20, 0);\r\nWrite16(state, CC_REG_PLL_MODE__A, CC_REG_PLL_MODE_BYPASS_PLL |\r\nCC_REG_PLL_MODE_PUMP_CUR_12, 0);\r\nWrite16(state, CC_REG_REF_DIVIDE__A, state->osc_clock_freq / 4000, 0);\r\nWrite16(state, CC_REG_PWD_MODE__A, CC_REG_PWD_MODE_DOWN_PLL, 0);\r\nWrite16(state, CC_REG_UPDATE__A, CC_REG_UPDATE_KEY, 0);\r\nreturn 0;\r\n}\r\nstatic int ResetECOD(struct drxd_state *state)\r\n{\r\nint status = 0;\r\nif (state->type_A)\r\nstatus = Write16(state, EC_OD_REG_SYNC__A, 0x0664, 0);\r\nelse\r\nstatus = Write16(state, B_EC_OD_REG_SYNC__A, 0x0664, 0);\r\nif (!(status < 0))\r\nstatus = WriteTable(state, state->m_ResetECRAM);\r\nif (!(status < 0))\r\nstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0001, 0);\r\nreturn status;\r\n}\r\nstatic int SetCfgPga(struct drxd_state *state, int pgaSwitch)\r\n{\r\nint status;\r\nu16 AgModeLop = 0;\r\nu16 AgModeHip = 0;\r\ndo {\r\nif (pgaSwitch) {\r\nstatus = Read16(state, B_FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeLop &= (~(B_FE_AG_REG_AG_MODE_LOP_MODE_C__M));\r\nAgModeLop |= B_FE_AG_REG_AG_MODE_LOP_MODE_C_DYNAMIC;\r\nstatus = Write16(state, B_FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, B_FE_AG_REG_AG_MODE_HIP__A, &AgModeHip, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeHip &= (~(B_FE_AG_REG_AG_MODE_HIP_MODE_J__M));\r\nAgModeHip |= B_FE_AG_REG_AG_MODE_HIP_MODE_J_DYNAMIC;\r\nstatus = Write16(state, B_FE_AG_REG_AG_MODE_HIP__A, AgModeHip, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_FE_AG_REG_AG_PGA_MODE__A, B_FE_AG_REG_AG_PGA_MODE_PFY_PCY_AFY_REN, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = Read16(state, B_FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeLop &= (~(B_FE_AG_REG_AG_MODE_LOP_MODE_C__M));\r\nAgModeLop |= B_FE_AG_REG_AG_MODE_LOP_MODE_C_STATIC;\r\nstatus = Write16(state, B_FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, B_FE_AG_REG_AG_MODE_HIP__A, &AgModeHip, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nAgModeHip &= (~(B_FE_AG_REG_AG_MODE_HIP_MODE_J__M));\r\nAgModeHip |= B_FE_AG_REG_AG_MODE_HIP_MODE_J_STATIC;\r\nstatus = Write16(state, B_FE_AG_REG_AG_MODE_HIP__A, AgModeHip, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_FE_AG_REG_AG_PGA_MODE__A, B_FE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int InitFE(struct drxd_state *state)\r\n{\r\nint status;\r\ndo {\r\nstatus = WriteTable(state, state->m_InitFE_1);\r\nif (status < 0)\r\nbreak;\r\nif (state->type_A) {\r\nstatus = Write16(state, FE_AG_REG_AG_PGA_MODE__A,\r\nFE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN,\r\n0);\r\n} else {\r\nif (state->PGA)\r\nstatus = SetCfgPga(state, 0);\r\nelse\r\nstatus =\r\nWrite16(state, B_FE_AG_REG_AG_PGA_MODE__A,\r\nB_FE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN,\r\n0);\r\n}\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, state->m_FeAgRegAgAgcSio, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_AG_REG_AG_PWD__A, state->m_FeAgRegAgPwd, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = WriteTable(state, state->m_InitFE_2);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int InitFT(struct drxd_state *state)\r\n{\r\nreturn Write16(state, FT_REG_COMM_EXEC__A, 0x0001, 0x0000);\r\n}\r\nstatic int SC_WaitForReady(struct drxd_state *state)\r\n{\r\nu16 curCmd;\r\nint i;\r\nfor (i = 0; i < DRXD_MAX_RETRIES; i += 1) {\r\nint status = Read16(state, SC_RA_RAM_CMD__A, &curCmd, 0);\r\nif (status == 0 || curCmd == 0)\r\nreturn status;\r\n}\r\nreturn -1;\r\n}\r\nstatic int SC_SendCommand(struct drxd_state *state, u16 cmd)\r\n{\r\nint status = 0;\r\nu16 errCode;\r\nWrite16(state, SC_RA_RAM_CMD__A, cmd, 0);\r\nSC_WaitForReady(state);\r\nRead16(state, SC_RA_RAM_CMD_ADDR__A, &errCode, 0);\r\nif (errCode == 0xFFFF) {\r\nprintk(KERN_ERR "Command Error\n");\r\nstatus = -1;\r\n}\r\nreturn status;\r\n}\r\nstatic int SC_ProcStartCommand(struct drxd_state *state,\r\nu16 subCmd, u16 param0, u16 param1)\r\n{\r\nint status = 0;\r\nu16 scExec;\r\nmutex_lock(&state->mutex);\r\ndo {\r\nRead16(state, SC_COMM_EXEC__A, &scExec, 0);\r\nif (scExec != 1) {\r\nstatus = -1;\r\nbreak;\r\n}\r\nSC_WaitForReady(state);\r\nWrite16(state, SC_RA_RAM_CMD_ADDR__A, subCmd, 0);\r\nWrite16(state, SC_RA_RAM_PARAM1__A, param1, 0);\r\nWrite16(state, SC_RA_RAM_PARAM0__A, param0, 0);\r\nSC_SendCommand(state, SC_RA_RAM_CMD_PROC_START);\r\n} while (0);\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int SC_SetPrefParamCommand(struct drxd_state *state,\r\nu16 subCmd, u16 param0, u16 param1)\r\n{\r\nint status;\r\nmutex_lock(&state->mutex);\r\ndo {\r\nstatus = SC_WaitForReady(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_RA_RAM_CMD_ADDR__A, subCmd, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_RA_RAM_PARAM1__A, param1, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_RA_RAM_PARAM0__A, param0, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = SC_SendCommand(state, SC_RA_RAM_CMD_SET_PREF_PARAM);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int ConfigureMPEGOutput(struct drxd_state *state, int bEnableOutput)\r\n{\r\nint status;\r\ndo {\r\nu16 EcOcRegIprInvMpg = 0;\r\nu16 EcOcRegOcModeLop = 0;\r\nu16 EcOcRegOcModeHip = 0;\r\nu16 EcOcRegOcMpgSio = 0;\r\nif (state->operation_mode == OM_DVBT_Diversity_Front) {\r\nif (bEnableOutput) {\r\nEcOcRegOcModeHip |=\r\nB_EC_OC_REG_OC_MODE_HIP_MPG_BUS_SRC_MONITOR;\r\n} else\r\nEcOcRegOcMpgSio |= EC_OC_REG_OC_MPG_SIO__M;\r\nEcOcRegOcModeLop |=\r\nEC_OC_REG_OC_MODE_LOP_PAR_ENA_DISABLE;\r\n} else {\r\nEcOcRegOcModeLop = state->m_EcOcRegOcModeLop;\r\nif (bEnableOutput)\r\nEcOcRegOcMpgSio &= (~(EC_OC_REG_OC_MPG_SIO__M));\r\nelse\r\nEcOcRegOcMpgSio |= EC_OC_REG_OC_MPG_SIO__M;\r\nif (state->insert_rs_byte) {\r\nEcOcRegOcModeLop &=\r\n(~(EC_OC_REG_OC_MODE_LOP_PAR_ENA__M));\r\nEcOcRegOcModeHip &=\r\n(~EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL__M);\r\nEcOcRegOcModeHip |=\r\nEC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL_ENABLE;\r\n} else {\r\nEcOcRegOcModeLop |=\r\nEC_OC_REG_OC_MODE_LOP_PAR_ENA_DISABLE;\r\nEcOcRegOcModeHip &=\r\n(~EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL__M);\r\nEcOcRegOcModeHip |=\r\nEC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL_DISABLE;\r\n}\r\nif (state->enable_parallel)\r\nEcOcRegOcModeLop &=\r\n(~(EC_OC_REG_OC_MODE_LOP_MPG_TRM_MDE__M));\r\nelse\r\nEcOcRegOcModeLop |=\r\nEC_OC_REG_OC_MODE_LOP_MPG_TRM_MDE_SERIAL;\r\n}\r\nEcOcRegIprInvMpg &= (~(0x00FF));\r\nEcOcRegIprInvMpg &= (~(0x0100));\r\nEcOcRegIprInvMpg &= (~(0x0200));\r\nEcOcRegIprInvMpg &= (~(0x0400));\r\nEcOcRegIprInvMpg &= (~(0x0800));\r\nstatus = Write16(state, EC_OC_REG_IPR_INV_MPG__A, EcOcRegIprInvMpg, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, EcOcRegOcModeLop, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_OC_MODE_HIP__A, EcOcRegOcModeHip, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OC_REG_OC_MPG_SIO__A, EcOcRegOcMpgSio, 0);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int SetDeviceTypeId(struct drxd_state *state)\r\n{\r\nint status = 0;\r\nu16 deviceId = 0;\r\ndo {\r\nstatus = Read16(state, CC_REG_JTAGID_L__A, &deviceId, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read16(state, CC_REG_JTAGID_L__A, &deviceId, 0);\r\nif (status < 0)\r\nbreak;\r\nprintk(KERN_INFO "drxd: deviceId = %04x\n", deviceId);\r\nstate->type_A = 0;\r\nstate->PGA = 0;\r\nstate->diversity = 0;\r\nif (deviceId == 0) {\r\nstate->type_A = 1;\r\nprintk(KERN_INFO "DRX3975D-A2\n");\r\n} else {\r\ndeviceId >>= 12;\r\nprintk(KERN_INFO "DRX397%dD-B1\n", deviceId);\r\nswitch (deviceId) {\r\ncase 4:\r\nstate->diversity = 1;\r\ncase 3:\r\ncase 7:\r\nstate->PGA = 1;\r\nbreak;\r\ncase 6:\r\nstate->diversity = 1;\r\ncase 5:\r\ncase 8:\r\nbreak;\r\ndefault:\r\nstatus = -1;\r\nbreak;\r\n}\r\n}\r\n} while (0);\r\nif (status < 0)\r\nreturn status;\r\nstate->m_InitAtomicRead = DRXD_InitAtomicRead;\r\nstate->m_InitSC = DRXD_InitSC;\r\nstate->m_ResetECRAM = DRXD_ResetECRAM;\r\nif (state->type_A) {\r\nstate->m_ResetCEFR = DRXD_ResetCEFR;\r\nstate->m_InitFE_1 = DRXD_InitFEA2_1;\r\nstate->m_InitFE_2 = DRXD_InitFEA2_2;\r\nstate->m_InitCP = DRXD_InitCPA2;\r\nstate->m_InitCE = DRXD_InitCEA2;\r\nstate->m_InitEQ = DRXD_InitEQA2;\r\nstate->m_InitEC = DRXD_InitECA2;\r\nif (load_firmware(state, DRX_FW_FILENAME_A2))\r\nreturn -EIO;\r\n} else {\r\nstate->m_ResetCEFR = NULL;\r\nstate->m_InitFE_1 = DRXD_InitFEB1_1;\r\nstate->m_InitFE_2 = DRXD_InitFEB1_2;\r\nstate->m_InitCP = DRXD_InitCPB1;\r\nstate->m_InitCE = DRXD_InitCEB1;\r\nstate->m_InitEQ = DRXD_InitEQB1;\r\nstate->m_InitEC = DRXD_InitECB1;\r\nif (load_firmware(state, DRX_FW_FILENAME_B1))\r\nreturn -EIO;\r\n}\r\nif (state->diversity) {\r\nstate->m_InitDiversityFront = DRXD_InitDiversityFront;\r\nstate->m_InitDiversityEnd = DRXD_InitDiversityEnd;\r\nstate->m_DisableDiversity = DRXD_DisableDiversity;\r\nstate->m_StartDiversityFront = DRXD_StartDiversityFront;\r\nstate->m_StartDiversityEnd = DRXD_StartDiversityEnd;\r\nstate->m_DiversityDelay8MHZ = DRXD_DiversityDelay8MHZ;\r\nstate->m_DiversityDelay6MHZ = DRXD_DiversityDelay6MHZ;\r\n} else {\r\nstate->m_InitDiversityFront = NULL;\r\nstate->m_InitDiversityEnd = NULL;\r\nstate->m_DisableDiversity = NULL;\r\nstate->m_StartDiversityFront = NULL;\r\nstate->m_StartDiversityEnd = NULL;\r\nstate->m_DiversityDelay8MHZ = NULL;\r\nstate->m_DiversityDelay6MHZ = NULL;\r\n}\r\nreturn status;\r\n}\r\nstatic int CorrectSysClockDeviation(struct drxd_state *state)\r\n{\r\nint status;\r\ns32 incr = 0;\r\ns32 nomincr = 0;\r\nu32 bandwidth = 0;\r\nu32 sysClockInHz = 0;\r\nu32 sysClockFreq = 0;\r\ns16 oscClockDeviation;\r\ns16 Diff;\r\ndo {\r\nstatus = Read32(state, LC_RA_RAM_IFINCR_NOM_L__A, ((u32 *) &nomincr), 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read32(state, FE_IF_REG_INCR0__A, (u32 *) &incr, 0);\r\nif (status < 0)\r\nbreak;\r\nif (state->type_A) {\r\nif ((nomincr - incr < -500) || (nomincr - incr > 500))\r\nbreak;\r\n} else {\r\nif ((nomincr - incr < -2000) || (nomincr - incr > 2000))\r\nbreak;\r\n}\r\nswitch (state->props.bandwidth_hz) {\r\ncase 8000000:\r\nbandwidth = DRXD_BANDWIDTH_8MHZ_IN_HZ;\r\nbreak;\r\ncase 7000000:\r\nbandwidth = DRXD_BANDWIDTH_7MHZ_IN_HZ;\r\nbreak;\r\ncase 6000000:\r\nbandwidth = DRXD_BANDWIDTH_6MHZ_IN_HZ;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nincr += (1 << 23);\r\nsysClockInHz = MulDiv32(incr, bandwidth, 1 << 21);\r\nsysClockFreq = (u32) (sysClockInHz / 1000);\r\nif ((sysClockInHz % 1000) > 500)\r\nsysClockFreq++;\r\noscClockDeviation = (u16) ((((s32) (sysClockFreq) -\r\n(s32)\r\n(state->expected_sys_clock_freq)) *\r\n1000000L) /\r\n(s32)\r\n(state->expected_sys_clock_freq));\r\nDiff = oscClockDeviation - state->osc_clock_deviation;\r\nif (Diff >= -200 && Diff <= 200) {\r\nstate->sys_clock_freq = (u16) sysClockFreq;\r\nif (oscClockDeviation != state->osc_clock_deviation) {\r\nif (state->config.osc_deviation) {\r\nstate->config.osc_deviation(state->priv,\r\noscClockDeviation,\r\n1);\r\nstate->osc_clock_deviation =\r\noscClockDeviation;\r\n}\r\n}\r\nstatus = Write16(state, SC_RA_RAM_SAMPLE_RATE_COUNT__A, DRXD_OSCDEV_DONT_SCAN, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_RA_RAM_IF_SAVE__AX, state->current_fe_if_incr, 0);\r\nif (status < 0)\r\nbreak;\r\nstate->cscd_state = CSCD_SAVED;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int DRX_Stop(struct drxd_state *state)\r\n{\r\nint status;\r\nif (state->drxd_state != DRXD_STARTED)\r\nreturn 0;\r\ndo {\r\nif (state->cscd_state != CSCD_SAVED) {\r\nu32 lock;\r\nstatus = DRX_GetLockStatus(state, &lock);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = StopOC(state);\r\nif (status < 0)\r\nbreak;\r\nstate->drxd_state = DRXD_STOPPED;\r\nstatus = ConfigureMPEGOutput(state, 0);\r\nif (status < 0)\r\nbreak;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = Write16(state, B_SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_FT_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_CP_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_CE_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_EQ_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0000, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int StartDiversity(struct drxd_state *state)\r\n{\r\nint status = 0;\r\nu16 rcControl;\r\ndo {\r\nif (state->operation_mode == OM_DVBT_Diversity_Front) {\r\nstatus = WriteTable(state, state->m_StartDiversityFront);\r\nif (status < 0)\r\nbreak;\r\n} else if (state->operation_mode == OM_DVBT_Diversity_End) {\r\nstatus = WriteTable(state, state->m_StartDiversityEnd);\r\nif (status < 0)\r\nbreak;\r\nif (state->props.bandwidth_hz == 8000000) {\r\nstatus = WriteTable(state, state->m_DiversityDelay8MHZ);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = WriteTable(state, state->m_DiversityDelay6MHZ);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = Read16(state, B_EQ_REG_RC_SEL_CAR__A, &rcControl, 0);\r\nif (status < 0)\r\nbreak;\r\nrcControl &= ~(B_EQ_REG_RC_SEL_CAR_FFTMODE__M);\r\nrcControl |= B_EQ_REG_RC_SEL_CAR_DIV_ON |\r\nB_EQ_REG_RC_SEL_CAR_MEAS_A_CC |\r\nB_EQ_REG_RC_SEL_CAR_PASS_A_CC |\r\nB_EQ_REG_RC_SEL_CAR_LOCAL_A_CC;\r\nstatus = Write16(state, B_EQ_REG_RC_SEL_CAR__A, rcControl, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int SetFrequencyShift(struct drxd_state *state,\r\nu32 offsetFreq, int channelMirrored)\r\n{\r\nint negativeShift = (state->tuner_mirrors == channelMirrored);\r\nstate->fe_fs_add_incr = MulDiv32(state->intermediate_freq +\r\noffsetFreq,\r\n1 << 28, state->sys_clock_freq);\r\nstate->fe_fs_add_incr &= 0x0FFFFFFFL;\r\nif (negativeShift)\r\nstate->fe_fs_add_incr = ((1 << 28) - state->fe_fs_add_incr);\r\nstate->org_fe_fs_add_incr = MulDiv32(state->intermediate_freq,\r\n1 << 28, state->sys_clock_freq);\r\nstate->org_fe_fs_add_incr &= 0x0FFFFFFFL;\r\nif (negativeShift)\r\nstate->org_fe_fs_add_incr = ((1L << 28) -\r\nstate->org_fe_fs_add_incr);\r\nreturn Write32(state, FE_FS_REG_ADD_INC_LOP__A,\r\nstate->fe_fs_add_incr, 0);\r\n}\r\nstatic int SetCfgNoiseCalibration(struct drxd_state *state,\r\nstruct SNoiseCal *noiseCal)\r\n{\r\nu16 beOptEna;\r\nint status = 0;\r\ndo {\r\nstatus = Read16(state, SC_RA_RAM_BE_OPT_ENA__A, &beOptEna, 0);\r\nif (status < 0)\r\nbreak;\r\nif (noiseCal->cpOpt) {\r\nbeOptEna |= (1 << SC_RA_RAM_BE_OPT_ENA_CP_OPT);\r\n} else {\r\nbeOptEna &= ~(1 << SC_RA_RAM_BE_OPT_ENA_CP_OPT);\r\nstatus = Write16(state, CP_REG_AC_NEXP_OFFS__A, noiseCal->cpNexpOfs, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = Write16(state, SC_RA_RAM_BE_OPT_ENA__A, beOptEna, 0);\r\nif (status < 0)\r\nbreak;\r\nif (!state->type_A) {\r\nstatus = Write16(state, B_SC_RA_RAM_CO_TD_CAL_2K__A, noiseCal->tdCal2k, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, B_SC_RA_RAM_CO_TD_CAL_8K__A, noiseCal->tdCal8k, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int DRX_Start(struct drxd_state *state, s32 off)\r\n{\r\nstruct dtv_frontend_properties *p = &state->props;\r\nint status;\r\nu16 transmissionParams = 0;\r\nu16 operationMode = 0;\r\nu16 qpskTdTpsPwr = 0;\r\nu16 qam16TdTpsPwr = 0;\r\nu16 qam64TdTpsPwr = 0;\r\nu32 feIfIncr = 0;\r\nu32 bandwidth = 0;\r\nint mirrorFreqSpect;\r\nu16 qpskSnCeGain = 0;\r\nu16 qam16SnCeGain = 0;\r\nu16 qam64SnCeGain = 0;\r\nu16 qpskIsGainMan = 0;\r\nu16 qam16IsGainMan = 0;\r\nu16 qam64IsGainMan = 0;\r\nu16 qpskIsGainExp = 0;\r\nu16 qam16IsGainExp = 0;\r\nu16 qam64IsGainExp = 0;\r\nu16 bandwidthParam = 0;\r\nif (off < 0)\r\noff = (off - 500) / 1000;\r\nelse\r\noff = (off + 500) / 1000;\r\ndo {\r\nif (state->drxd_state != DRXD_STOPPED)\r\nreturn -1;\r\nstatus = ResetECOD(state);\r\nif (status < 0)\r\nbreak;\r\nif (state->type_A) {\r\nstatus = InitSC(state);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = InitFT(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitCP(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitCE(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitEQ(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitSC(state);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = SetCfgIfAgc(state, &state->if_agc_cfg);\r\nif (status < 0)\r\nbreak;\r\nstatus = SetCfgRfAgc(state, &state->rf_agc_cfg);\r\nif (status < 0)\r\nbreak;\r\nmirrorFreqSpect = (state->props.inversion == INVERSION_ON);\r\nswitch (p->transmission_mode) {\r\ndefault:\r\noperationMode |= SC_RA_RAM_OP_AUTO_MODE__M;\r\ncase TRANSMISSION_MODE_8K:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_MODE_8K;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_SB_REG_TR_MODE__A, EC_SB_REG_TR_MODE_8K, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskSnCeGain = 99;\r\nqam16SnCeGain = 83;\r\nqam64SnCeGain = 67;\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_MODE_2K;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_SB_REG_TR_MODE__A, EC_SB_REG_TR_MODE_2K, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskSnCeGain = 97;\r\nqam16SnCeGain = 71;\r\nqam64SnCeGain = 65;\r\n}\r\nbreak;\r\n}\r\nswitch (p->guard_interval) {\r\ncase GUARD_INTERVAL_1_4:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_4;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_8;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_16;\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_32;\r\nbreak;\r\ndefault:\r\noperationMode |= SC_RA_RAM_OP_AUTO_GUARD__M;\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_4;\r\nbreak;\r\n}\r\nswitch (p->hierarchy) {\r\ncase HIERARCHY_1:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A1;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0001, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0001, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\r\nqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA1;\r\nqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA1;\r\nqpskIsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\r\nqam16IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_MAN__PRE;\r\nqam64IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_MAN__PRE;\r\nqpskIsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\r\nqam16IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_EXP__PRE;\r\nqam64IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_EXP__PRE;\r\n}\r\nbreak;\r\ncase HIERARCHY_2:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A2;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0002, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0002, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\r\nqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA2;\r\nqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA2;\r\nqpskIsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\r\nqam16IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_A2_MAN__PRE;\r\nqam64IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_A2_MAN__PRE;\r\nqpskIsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\r\nqam16IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_A2_EXP__PRE;\r\nqam64IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_A2_EXP__PRE;\r\n}\r\nbreak;\r\ncase HIERARCHY_4:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A4;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0003, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0003, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\r\nqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA4;\r\nqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA4;\r\nqpskIsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\r\nqam16IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_A4_MAN__PRE;\r\nqam64IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_A4_MAN__PRE;\r\nqpskIsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\r\nqam16IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_A4_EXP__PRE;\r\nqam64IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_A4_EXP__PRE;\r\n}\r\nbreak;\r\ncase HIERARCHY_AUTO:\r\ndefault:\r\noperationMode |= SC_RA_RAM_OP_AUTO_HIER__M;\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_NO;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nqpskTdTpsPwr = EQ_TD_TPS_PWR_QPSK;\r\nqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHAN;\r\nqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHAN;\r\nqpskIsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_QPSK_MAN__PRE;\r\nqam16IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_MAN__PRE;\r\nqam64IsGainMan =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_MAN__PRE;\r\nqpskIsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_QPSK_EXP__PRE;\r\nqam16IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_16QAM_EXP__PRE;\r\nqam64IsGainExp =\r\nSC_RA_RAM_EQ_IS_GAIN_64QAM_EXP__PRE;\r\n}\r\nbreak;\r\n}\r\nstatus = status;\r\nif (status < 0)\r\nbreak;\r\nswitch (p->modulation) {\r\ndefault:\r\noperationMode |= SC_RA_RAM_OP_AUTO_CONST__M;\r\ncase QAM_64:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QAM64;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0002, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_64QAM, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0020, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0008, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0002, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qam64TdTpsPwr, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qam64SnCeGain, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qam64IsGainMan, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qam64IsGainExp, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase QPSK:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QPSK;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_QPSK, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0010, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qpskTdTpsPwr, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qpskSnCeGain, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qpskIsGainMan, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qpskIsGainExp, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase QAM_16:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QAM16;\r\nif (state->type_A) {\r\nstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0001, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_16QAM, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0010, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0004, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0000, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qam16TdTpsPwr, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qam16SnCeGain, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qam16IsGainMan, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qam16IsGainExp, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nstatus = status;\r\nif (status < 0)\r\nbreak;\r\nswitch (DRX_CHANNEL_HIGH) {\r\ndefault:\r\ncase DRX_CHANNEL_AUTO:\r\ncase DRX_CHANNEL_LOW:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_PRIO_LO;\r\nstatus = Write16(state, EC_SB_REG_PRIOR__A, EC_SB_REG_PRIOR_LO, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nbreak;\r\ncase DRX_CHANNEL_HIGH:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_PRIO_HI;\r\nstatus = Write16(state, EC_SB_REG_PRIOR__A, EC_SB_REG_PRIOR_HI, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nbreak;\r\n}\r\nswitch (p->code_rate_HP) {\r\ncase FEC_1_2:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_1_2;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C1_2, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\noperationMode |= SC_RA_RAM_OP_AUTO_RATE__M;\r\ncase FEC_2_3:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_2_3;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C2_3, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase FEC_3_4:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_3_4;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C3_4, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase FEC_5_6:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_5_6;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C5_6, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase FEC_7_8:\r\ntransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_7_8;\r\nif (state->type_A) {\r\nstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C7_8, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nstatus = status;\r\nif (status < 0)\r\nbreak;\r\nswitch (p->bandwidth_hz) {\r\ncase 0:\r\np->bandwidth_hz = 8000000;\r\ncase 8000000:\r\nbandwidth = DRXD_BANDWIDTH_8MHZ_IN_HZ;\r\nbandwidthParam = 0;\r\nstatus = Write16(state,\r\nFE_AG_REG_IND_DEL__A, 50, 0x0000);\r\nbreak;\r\ncase 7000000:\r\nbandwidth = DRXD_BANDWIDTH_7MHZ_IN_HZ;\r\nbandwidthParam = 0x4807;\r\nstatus = Write16(state,\r\nFE_AG_REG_IND_DEL__A, 59, 0x0000);\r\nbreak;\r\ncase 6000000:\r\nbandwidth = DRXD_BANDWIDTH_6MHZ_IN_HZ;\r\nbandwidthParam = 0x0F07;\r\nstatus = Write16(state,\r\nFE_AG_REG_IND_DEL__A, 71, 0x0000);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_RA_RAM_BAND__A, bandwidthParam, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n{\r\nu16 sc_config;\r\nstatus = Read16(state, SC_RA_RAM_CONFIG__A, &sc_config, 0);\r\nif (status < 0)\r\nbreak;\r\nif ((p->transmission_mode == TRANSMISSION_MODE_2K) &&\r\n(p->guard_interval == GUARD_INTERVAL_1_32)) {\r\nsc_config |= SC_RA_RAM_CONFIG_SLAVE__M;\r\n} else {\r\nsc_config &= ~SC_RA_RAM_CONFIG_SLAVE__M;\r\n}\r\nstatus = Write16(state, SC_RA_RAM_CONFIG__A, sc_config, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = SetCfgNoiseCalibration(state, &state->noise_cal);\r\nif (status < 0)\r\nbreak;\r\nif (state->cscd_state == CSCD_INIT) {\r\nstatus = Write16(state, SC_RA_RAM_SAMPLE_RATE_COUNT__A, DRXD_OSCDEV_DO_SCAN, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstate->cscd_state = CSCD_SET;\r\n}\r\nfeIfIncr = MulDiv32(state->sys_clock_freq * 1000,\r\n(1ULL << 21), bandwidth) - (1 << 23);\r\nstatus = Write16(state, FE_IF_REG_INCR0__A, (u16) (feIfIncr & FE_IF_REG_INCR0__M), 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, FE_IF_REG_INCR1__A, (u16) ((feIfIncr >> FE_IF_REG_INCR0__W) & FE_IF_REG_INCR1__M), 0x0000);\r\nif (status < 0)\r\nbreak;\r\nSetFrequencyShift(state, off, mirrorFreqSpect);\r\nstatus = Write16(state, SC_COMM_STATE__A, 0, 0x0000);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, SC_COMM_EXEC__A, 1, 0x0000);\r\nif (status < 0)\r\nbreak;\r\n#if 1\r\noperationMode = (SC_RA_RAM_OP_AUTO_MODE__M |\r\nSC_RA_RAM_OP_AUTO_GUARD__M |\r\nSC_RA_RAM_OP_AUTO_CONST__M |\r\nSC_RA_RAM_OP_AUTO_HIER__M |\r\nSC_RA_RAM_OP_AUTO_RATE__M);\r\n#endif\r\nstatus = SC_SetPrefParamCommand(state, 0x0000, transmissionParams, operationMode);\r\nif (status < 0)\r\nbreak;\r\nstatus = SC_ProcStartCommand(state, SC_RA_RAM_PROC_LOCKTRACK, SC_RA_RAM_SW_EVENT_RUN_NMASK__M, SC_RA_RAM_LOCKTRACK_MIN);\r\nif (status < 0)\r\nbreak;\r\nstatus = StartOC(state);\r\nif (status < 0)\r\nbreak;\r\nif (state->operation_mode != OM_Default) {\r\nstatus = StartDiversity(state);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstate->drxd_state = DRXD_STARTED;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int CDRXD(struct drxd_state *state, u32 IntermediateFrequency)\r\n{\r\nu32 ulRfAgcOutputLevel = 0xffffffff;\r\nu32 ulRfAgcSettleLevel = 528;\r\nu32 ulRfAgcMinLevel = 0;\r\nu32 ulRfAgcMaxLevel = DRXD_FE_CTRL_MAX;\r\nu32 ulRfAgcSpeed = 0;\r\nu32 ulRfAgcMode = 0;\r\nu32 ulRfAgcR1 = 820;\r\nu32 ulRfAgcR2 = 2200;\r\nu32 ulRfAgcR3 = 150;\r\nu32 ulIfAgcMode = 0;\r\nu32 ulIfAgcOutputLevel = 0xffffffff;\r\nu32 ulIfAgcSettleLevel = 0xffffffff;\r\nu32 ulIfAgcMinLevel = 0xffffffff;\r\nu32 ulIfAgcMaxLevel = 0xffffffff;\r\nu32 ulIfAgcSpeed = 0xffffffff;\r\nu32 ulIfAgcR1 = 820;\r\nu32 ulIfAgcR2 = 2200;\r\nu32 ulIfAgcR3 = 150;\r\nu32 ulClock = state->config.clock;\r\nu32 ulSerialMode = 0;\r\nu32 ulEcOcRegOcModeLop = 4;\r\nu32 ulHiI2cDelay = HI_I2C_DELAY;\r\nu32 ulHiI2cBridgeDelay = HI_I2C_BRIDGE_DELAY;\r\nu32 ulHiI2cPatch = 0;\r\nu32 ulEnvironment = APPENV_PORTABLE;\r\nu32 ulEnvironmentDiversity = APPENV_MOBILE;\r\nu32 ulIFFilter = IFFILTER_SAW;\r\nstate->if_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\r\nstate->if_agc_cfg.outputLevel = 0;\r\nstate->if_agc_cfg.settleLevel = 140;\r\nstate->if_agc_cfg.minOutputLevel = 0;\r\nstate->if_agc_cfg.maxOutputLevel = 1023;\r\nstate->if_agc_cfg.speed = 904;\r\nif (ulIfAgcMode == 1 && ulIfAgcOutputLevel <= DRXD_FE_CTRL_MAX) {\r\nstate->if_agc_cfg.ctrlMode = AGC_CTRL_USER;\r\nstate->if_agc_cfg.outputLevel = (u16) (ulIfAgcOutputLevel);\r\n}\r\nif (ulIfAgcMode == 0 &&\r\nulIfAgcSettleLevel <= DRXD_FE_CTRL_MAX &&\r\nulIfAgcMinLevel <= DRXD_FE_CTRL_MAX &&\r\nulIfAgcMaxLevel <= DRXD_FE_CTRL_MAX &&\r\nulIfAgcSpeed <= DRXD_FE_CTRL_MAX) {\r\nstate->if_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\r\nstate->if_agc_cfg.settleLevel = (u16) (ulIfAgcSettleLevel);\r\nstate->if_agc_cfg.minOutputLevel = (u16) (ulIfAgcMinLevel);\r\nstate->if_agc_cfg.maxOutputLevel = (u16) (ulIfAgcMaxLevel);\r\nstate->if_agc_cfg.speed = (u16) (ulIfAgcSpeed);\r\n}\r\nstate->if_agc_cfg.R1 = (u16) (ulIfAgcR1);\r\nstate->if_agc_cfg.R2 = (u16) (ulIfAgcR2);\r\nstate->if_agc_cfg.R3 = (u16) (ulIfAgcR3);\r\nstate->rf_agc_cfg.R1 = (u16) (ulRfAgcR1);\r\nstate->rf_agc_cfg.R2 = (u16) (ulRfAgcR2);\r\nstate->rf_agc_cfg.R3 = (u16) (ulRfAgcR3);\r\nstate->rf_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\r\nif (ulRfAgcMode == 1 && ulRfAgcOutputLevel <= DRXD_FE_CTRL_MAX) {\r\nstate->rf_agc_cfg.ctrlMode = AGC_CTRL_USER;\r\nstate->rf_agc_cfg.outputLevel = (u16) (ulRfAgcOutputLevel);\r\n}\r\nif (ulRfAgcMode == 0 &&\r\nulRfAgcSettleLevel <= DRXD_FE_CTRL_MAX &&\r\nulRfAgcMinLevel <= DRXD_FE_CTRL_MAX &&\r\nulRfAgcMaxLevel <= DRXD_FE_CTRL_MAX &&\r\nulRfAgcSpeed <= DRXD_FE_CTRL_MAX) {\r\nstate->rf_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\r\nstate->rf_agc_cfg.settleLevel = (u16) (ulRfAgcSettleLevel);\r\nstate->rf_agc_cfg.minOutputLevel = (u16) (ulRfAgcMinLevel);\r\nstate->rf_agc_cfg.maxOutputLevel = (u16) (ulRfAgcMaxLevel);\r\nstate->rf_agc_cfg.speed = (u16) (ulRfAgcSpeed);\r\n}\r\nif (ulRfAgcMode == 2)\r\nstate->rf_agc_cfg.ctrlMode = AGC_CTRL_OFF;\r\nif (ulEnvironment <= 2)\r\nstate->app_env_default = (enum app_env)\r\n(ulEnvironment);\r\nif (ulEnvironmentDiversity <= 2)\r\nstate->app_env_diversity = (enum app_env)\r\n(ulEnvironmentDiversity);\r\nif (ulIFFilter == IFFILTER_DISCRETE) {\r\nstate->noise_cal.cpOpt = 0;\r\nstate->noise_cal.cpNexpOfs = 40;\r\nstate->noise_cal.tdCal2k = -40;\r\nstate->noise_cal.tdCal8k = -24;\r\n} else {\r\nstate->noise_cal.cpOpt = 1;\r\nstate->noise_cal.cpNexpOfs = 0;\r\nstate->noise_cal.tdCal2k = -21;\r\nstate->noise_cal.tdCal8k = -24;\r\n}\r\nstate->m_EcOcRegOcModeLop = (u16) (ulEcOcRegOcModeLop);\r\nstate->chip_adr = (state->config.demod_address << 1) | 1;\r\nswitch (ulHiI2cPatch) {\r\ncase 1:\r\nstate->m_HiI2cPatch = DRXD_HiI2cPatch_1;\r\nbreak;\r\ncase 3:\r\nstate->m_HiI2cPatch = DRXD_HiI2cPatch_3;\r\nbreak;\r\ndefault:\r\nstate->m_HiI2cPatch = NULL;\r\n}\r\nstate->intermediate_freq = (u16) (IntermediateFrequency / 1000);\r\nstate->expected_sys_clock_freq = 48000;\r\nstate->sys_clock_freq = 48000;\r\nstate->osc_clock_freq = (u16) ulClock;\r\nstate->osc_clock_deviation = 0;\r\nstate->cscd_state = CSCD_INIT;\r\nstate->drxd_state = DRXD_UNINITIALIZED;\r\nstate->PGA = 0;\r\nstate->type_A = 0;\r\nstate->tuner_mirrors = 0;\r\nstate->insert_rs_byte = state->config.insert_rs_byte;\r\nstate->enable_parallel = (ulSerialMode != 1);\r\nstate->hi_cfg_timing_div = (u16) ((state->sys_clock_freq / 1000) *\r\nulHiI2cDelay) / 1000;\r\nstate->hi_cfg_bridge_delay = (u16) ((state->osc_clock_freq / 1000) *\r\nulHiI2cBridgeDelay) / 1000;\r\nstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_CONSUMER;\r\nstate->m_FeAgRegAgAgcSio = DRXD_DEF_AG_AGC_SIO;\r\nreturn 0;\r\n}\r\nstatic int DRXD_init(struct drxd_state *state, const u8 *fw, u32 fw_size)\r\n{\r\nint status = 0;\r\nu32 driverVersion;\r\nif (state->init_done)\r\nreturn 0;\r\nCDRXD(state, state->config.IF ? state->config.IF : 36000000);\r\ndo {\r\nstate->operation_mode = OM_Default;\r\nstatus = SetDeviceTypeId(state);\r\nif (status < 0)\r\nbreak;\r\nif (!state->type_A && state->m_HiI2cPatch != NULL) {\r\nstatus = WriteTable(state, state->m_HiI2cPatch);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (state->type_A) {\r\nstatus = Write16(state, 0x43012D, 0x047f, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = HI_ResetCommand(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = StopAllProcessors(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitCC(state);\r\nif (status < 0)\r\nbreak;\r\nstate->osc_clock_deviation = 0;\r\nif (state->config.osc_deviation)\r\nstate->osc_clock_deviation =\r\nstate->config.osc_deviation(state->priv, 0, 0);\r\n{\r\ns32 devB;\r\ns32 devA = (s32) (state->osc_clock_deviation) *\r\n(s32) (state->expected_sys_clock_freq);\r\ns32 deviation = (devA / (1000000L));\r\nif (devA > 0)\r\ndevB = (2);\r\nelse\r\ndevB = (-2);\r\nif ((devB * (devA % 1000000L) > 1000000L)) {\r\ndeviation += (devB / 2);\r\n}\r\nstate->sys_clock_freq =\r\n(u16) ((state->expected_sys_clock_freq) +\r\ndeviation);\r\n}\r\nstatus = InitHI(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitAtomicRead(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = EnableAndResetMB(state);\r\nif (status < 0)\r\nbreak;\r\nif (state->type_A) {\r\nstatus = ResetCEFR(state);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (fw) {\r\nstatus = DownloadMicrocode(state, fw, fw_size);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = DownloadMicrocode(state, state->microcode, state->microcode_length);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (state->PGA) {\r\nstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_PRO;\r\nSetCfgPga(state, 0);\r\n} else {\r\nstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_CONSUMER;\r\n}\r\nstate->m_FeAgRegAgAgcSio = DRXD_DEF_AG_AGC_SIO;\r\nstatus = InitFE(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitFT(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitCP(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitCE(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitEQ(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitEC(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = InitSC(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = SetCfgIfAgc(state, &state->if_agc_cfg);\r\nif (status < 0)\r\nbreak;\r\nstatus = SetCfgRfAgc(state, &state->rf_agc_cfg);\r\nif (status < 0)\r\nbreak;\r\nstate->cscd_state = CSCD_INIT;\r\nstatus = Write16(state, SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = Write16(state, LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\r\nif (status < 0)\r\nbreak;\r\ndriverVersion = (((VERSION_MAJOR / 10) << 4) +\r\n(VERSION_MAJOR % 10)) << 24;\r\ndriverVersion += (((VERSION_MINOR / 10) << 4) +\r\n(VERSION_MINOR % 10)) << 16;\r\ndriverVersion += ((VERSION_PATCH / 1000) << 12) +\r\n((VERSION_PATCH / 100) << 8) +\r\n((VERSION_PATCH / 10) << 4) + (VERSION_PATCH % 10);\r\nstatus = Write32(state, SC_RA_RAM_DRIVER_VERSION__AX, driverVersion, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = StopOC(state);\r\nif (status < 0)\r\nbreak;\r\nstate->drxd_state = DRXD_STOPPED;\r\nstate->init_done = 1;\r\nstatus = 0;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int DRXD_status(struct drxd_state *state, u32 *pLockStatus)\r\n{\r\nDRX_GetLockStatus(state, pLockStatus);\r\nif (*pLockStatus & DRX_LOCK_FEC) {\r\nConfigureMPEGOutput(state, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int drxd_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nu32 value;\r\nint res;\r\nres = ReadIFAgc(state, &value);\r\nif (res < 0)\r\n*strength = 0;\r\nelse\r\n*strength = 0xffff - (value << 4);\r\nreturn 0;\r\n}\r\nstatic int drxd_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nu32 lock;\r\nDRXD_status(state, &lock);\r\n*status = 0;\r\n#if 1\r\nif (lock & DRX_LOCK_MPEG)\r\n*status |= FE_HAS_LOCK;\r\n#else\r\nif (lock & DRX_LOCK_FEC)\r\n*status |= FE_HAS_LOCK;\r\n#endif\r\nif (lock & DRX_LOCK_FEC)\r\n*status |= FE_HAS_VITERBI | FE_HAS_SYNC;\r\nif (lock & DRX_LOCK_DEMOD)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int drxd_init(struct dvb_frontend *fe)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nreturn DRXD_init(state, NULL, 0);\r\n}\r\nstatic int drxd_config_i2c(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nif (state->config.disable_i2c_gate_ctrl == 1)\r\nreturn 0;\r\nreturn DRX_ConfigureI2CBridge(state, onoff);\r\n}\r\nstatic int drxd_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *sets)\r\n{\r\nsets->min_delay_ms = 10000;\r\nsets->max_drift = 0;\r\nsets->step_size = 0;\r\nreturn 0;\r\n}\r\nstatic int drxd_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int drxd_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int drxd_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int drxd_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nConfigureMPEGOutput(state, 0);\r\nreturn 0;\r\n}\r\nstatic int drxd_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nreturn drxd_config_i2c(fe, enable);\r\n}\r\nstatic int drxd_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct drxd_state *state = fe->demodulator_priv;\r\ns32 off = 0;\r\nstate->props = *p;\r\nDRX_Stop(state);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nmsleep(200);\r\nreturn DRX_Start(state, off);\r\n}\r\nstatic void drxd_release(struct dvb_frontend *fe)\r\n{\r\nstruct drxd_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *drxd_attach(const struct drxd_config *config,\r\nvoid *priv, struct i2c_adapter *i2c,\r\nstruct device *dev)\r\n{\r\nstruct drxd_state *state = NULL;\r\nstate = kmalloc(sizeof(struct drxd_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nmemset(state, 0, sizeof(*state));\r\nstate->ops = drxd_ops;\r\nstate->dev = dev;\r\nstate->config = *config;\r\nstate->i2c = i2c;\r\nstate->priv = priv;\r\nmutex_init(&state->mutex);\r\nif (Read16(state, 0, NULL, 0) < 0)\r\ngoto error;\r\nstate->frontend.ops = drxd_ops;\r\nstate->frontend.demodulator_priv = state;\r\nConfigureMPEGOutput(state, 0);\r\nCDRXD(state, state->config.IF ? state->config.IF : 36000000);\r\nInitHI(state);\r\nreturn &state->frontend;\r\nerror:\r\nprintk(KERN_ERR "drxd: not found\n");\r\nkfree(state);\r\nreturn NULL;\r\n}
