static int lio_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct oct_link_info *linfo;\r\nlinfo = &lio->linfo;\r\nif (linfo->link.s.interface == INTERFACE_MODE_XAUI ||\r\nlinfo->link.s.interface == INTERFACE_MODE_RXAUI) {\r\necmd->port = PORT_FIBRE;\r\necmd->supported =\r\n(SUPPORTED_10000baseT_Full | SUPPORTED_FIBRE |\r\nSUPPORTED_Pause);\r\necmd->advertising =\r\n(ADVERTISED_10000baseT_Full | ADVERTISED_Pause);\r\necmd->transceiver = XCVR_EXTERNAL;\r\necmd->autoneg = AUTONEG_DISABLE;\r\n} else {\r\ndev_err(&oct->pci_dev->dev, "Unknown link interface reported\n");\r\n}\r\nif (linfo->link.s.status) {\r\nethtool_cmd_speed_set(ecmd, linfo->link.s.speed);\r\necmd->duplex = linfo->link.s.duplex;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlio_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct lio *lio;\r\nstruct octeon_device *oct;\r\nlio = GET_LIO(netdev);\r\noct = lio->oct_dev;\r\nmemset(drvinfo, 0, sizeof(struct ethtool_drvinfo));\r\nstrcpy(drvinfo->driver, "liquidio");\r\nstrcpy(drvinfo->version, LIQUIDIO_VERSION);\r\nstrncpy(drvinfo->fw_version, oct->fw_info.liquidio_firmware_version,\r\nETHTOOL_FWVERS_LEN);\r\nstrncpy(drvinfo->bus_info, pci_name(oct->pci_dev), 32);\r\ndrvinfo->regdump_len = OCT_ETHTOOL_REGDUMP_LEN;\r\n}\r\nstatic void\r\nlio_ethtool_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct lio *lio = GET_LIO(dev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nu32 max_rx = 0, max_tx = 0, tx_count = 0, rx_count = 0;\r\nif (OCTEON_CN6XXX(oct)) {\r\nstruct octeon_config *conf6x = CHIP_FIELD(oct, cn6xxx, conf);\r\nmax_rx = CFG_GET_OQ_MAX_Q(conf6x);\r\nmax_tx = CFG_GET_IQ_MAX_Q(conf6x);\r\nrx_count = CFG_GET_NUM_RXQS_NIC_IF(conf6x, lio->ifidx);\r\ntx_count = CFG_GET_NUM_TXQS_NIC_IF(conf6x, lio->ifidx);\r\n}\r\nchannel->max_rx = max_rx;\r\nchannel->max_tx = max_tx;\r\nchannel->rx_count = rx_count;\r\nchannel->tx_count = tx_count;\r\n}\r\nstatic int lio_get_eeprom_len(struct net_device *netdev)\r\n{\r\nu8 buf[128];\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nstruct octeon_board_info *board_info;\r\nint len;\r\nboard_info = (struct octeon_board_info *)(&oct_dev->boardinfo);\r\nlen = sprintf(buf, "boardname:%s serialnum:%s maj:%lld min:%lld\n",\r\nboard_info->name, board_info->serial_number,\r\nboard_info->major, board_info->minor);\r\nreturn len;\r\n}\r\nstatic int\r\nlio_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom,\r\nu8 *bytes)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nstruct octeon_board_info *board_info;\r\nint len;\r\nif (eeprom->offset != 0)\r\nreturn -EINVAL;\r\neeprom->magic = oct_dev->pci_dev->vendor;\r\nboard_info = (struct octeon_board_info *)(&oct_dev->boardinfo);\r\nlen =\r\nsprintf((char *)bytes,\r\n"boardname:%s serialnum:%s maj:%lld min:%lld\n",\r\nboard_info->name, board_info->serial_number,\r\nboard_info->major, board_info->minor);\r\nreturn 0;\r\n}\r\nstatic int octnet_gpio_access(struct net_device *netdev, int addr, int val)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct octnic_ctrl_pkt nctrl;\r\nstruct octnic_ctrl_params nparams;\r\nint ret = 0;\r\nmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\r\nnctrl.ncmd.u64 = 0;\r\nnctrl.ncmd.s.cmd = OCTNET_CMD_GPIO_ACCESS;\r\nnctrl.ncmd.s.param1 = lio->linfo.ifidx;\r\nnctrl.ncmd.s.param2 = addr;\r\nnctrl.ncmd.s.param3 = val;\r\nnctrl.wait_time = 100;\r\nnctrl.netpndev = (u64)netdev;\r\nnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\r\nnparams.resp_order = OCTEON_RESP_ORDERED;\r\nret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl, nparams);\r\nif (ret < 0) {\r\ndev_err(&oct->pci_dev->dev, "Failed to configure gpio value\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void octnet_mdio_resp_callback(struct octeon_device *oct,\r\nu32 status,\r\nvoid *buf)\r\n{\r\nstruct oct_mdio_cmd_resp *mdio_cmd_rsp;\r\nstruct oct_mdio_cmd_context *mdio_cmd_ctx;\r\nstruct octeon_soft_command *sc = (struct octeon_soft_command *)buf;\r\nmdio_cmd_rsp = (struct oct_mdio_cmd_resp *)sc->virtrptr;\r\nmdio_cmd_ctx = (struct oct_mdio_cmd_context *)sc->ctxptr;\r\noct = lio_get_device(mdio_cmd_ctx->octeon_id);\r\nif (status) {\r\ndev_err(&oct->pci_dev->dev, "MIDO instruction failed. Status: %llx\n",\r\nCVM_CAST64(status));\r\nACCESS_ONCE(mdio_cmd_ctx->cond) = -1;\r\n} else {\r\nACCESS_ONCE(mdio_cmd_ctx->cond) = 1;\r\n}\r\nwake_up_interruptible(&mdio_cmd_ctx->wc);\r\n}\r\nstatic int\r\noctnet_mdio45_access(struct lio *lio, int op, int loc, int *value)\r\n{\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nstruct octeon_soft_command *sc;\r\nstruct oct_mdio_cmd_resp *mdio_cmd_rsp;\r\nstruct oct_mdio_cmd_context *mdio_cmd_ctx;\r\nstruct oct_mdio_cmd *mdio_cmd;\r\nint retval = 0;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct_dev,\r\nsizeof(struct oct_mdio_cmd),\r\nsizeof(struct oct_mdio_cmd_resp),\r\nsizeof(struct oct_mdio_cmd_context));\r\nif (!sc)\r\nreturn -ENOMEM;\r\nmdio_cmd_ctx = (struct oct_mdio_cmd_context *)sc->ctxptr;\r\nmdio_cmd_rsp = (struct oct_mdio_cmd_resp *)sc->virtrptr;\r\nmdio_cmd = (struct oct_mdio_cmd *)sc->virtdptr;\r\nACCESS_ONCE(mdio_cmd_ctx->cond) = 0;\r\nmdio_cmd_ctx->octeon_id = lio_get_device_id(oct_dev);\r\nmdio_cmd->op = op;\r\nmdio_cmd->mdio_addr = loc;\r\nif (op)\r\nmdio_cmd->value1 = *value;\r\nmdio_cmd->value2 = lio->linfo.ifidx;\r\nocteon_swap_8B_data((u64 *)mdio_cmd, sizeof(struct oct_mdio_cmd) / 8);\r\nocteon_prepare_soft_command(oct_dev, sc, OPCODE_NIC, OPCODE_NIC_MDIO45,\r\n0, 0, 0);\r\nsc->wait_time = 1000;\r\nsc->callback = octnet_mdio_resp_callback;\r\nsc->callback_arg = sc;\r\ninit_waitqueue_head(&mdio_cmd_ctx->wc);\r\nretval = octeon_send_soft_command(oct_dev, sc);\r\nif (retval) {\r\ndev_err(&oct_dev->pci_dev->dev,\r\n"octnet_mdio45_access instruction failed status: %x\n",\r\nretval);\r\nretval = -EBUSY;\r\n} else {\r\nsleep_cond(&mdio_cmd_ctx->wc, &mdio_cmd_ctx->cond);\r\nretval = mdio_cmd_rsp->status;\r\nif (retval) {\r\ndev_err(&oct_dev->pci_dev->dev, "octnet mdio45 access failed\n");\r\nretval = -EBUSY;\r\n} else {\r\nocteon_swap_8B_data((u64 *)(&mdio_cmd_rsp->resp),\r\nsizeof(struct oct_mdio_cmd) / 8);\r\nif (ACCESS_ONCE(mdio_cmd_ctx->cond) == 1) {\r\nif (!op)\r\n*value = mdio_cmd_rsp->resp.value1;\r\n} else {\r\nretval = -EINVAL;\r\n}\r\n}\r\n}\r\nocteon_free_soft_command(oct_dev, sc);\r\nreturn retval;\r\n}\r\nstatic int lio_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nint value, ret;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nif (oct->chip_id == OCTEON_CN66XX) {\r\noctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\r\nVITESSE_PHY_GPIO_DRIVEON);\r\nreturn 2;\r\n} else if (oct->chip_id == OCTEON_CN68XX) {\r\nret = octnet_mdio45_access(lio, 0,\r\nLIO68XX_LED_BEACON_ADDR,\r\n&lio->phy_beacon_val);\r\nif (ret)\r\nreturn ret;\r\nret = octnet_mdio45_access(lio, 0,\r\nLIO68XX_LED_CTRL_ADDR,\r\n&lio->led_ctrl_val);\r\nif (ret)\r\nreturn ret;\r\nvalue = LIO68XX_LED_BEACON_CFGON;\r\nret =\r\noctnet_mdio45_access(lio, 1,\r\nLIO68XX_LED_BEACON_ADDR,\r\n&value);\r\nif (ret)\r\nreturn ret;\r\nvalue = LIO68XX_LED_CTRL_CFGON;\r\nret =\r\noctnet_mdio45_access(lio, 1,\r\nLIO68XX_LED_CTRL_ADDR,\r\n&value);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ETHTOOL_ID_ON:\r\nif (oct->chip_id == OCTEON_CN66XX) {\r\noctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\r\nVITESSE_PHY_GPIO_HIGH);\r\n} else if (oct->chip_id == OCTEON_CN68XX) {\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nif (oct->chip_id == OCTEON_CN66XX)\r\noctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\r\nVITESSE_PHY_GPIO_LOW);\r\nelse if (oct->chip_id == OCTEON_CN68XX)\r\nreturn -EINVAL;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nif (oct->chip_id == OCTEON_CN66XX) {\r\noctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\r\nVITESSE_PHY_GPIO_DRIVEOFF);\r\n} else if (oct->chip_id == OCTEON_CN68XX) {\r\nret = octnet_mdio45_access(lio, 1,\r\nLIO68XX_LED_CTRL_ADDR,\r\n&lio->led_ctrl_val);\r\nif (ret)\r\nreturn ret;\r\nret = octnet_mdio45_access(lio, 1,\r\nLIO68XX_LED_BEACON_ADDR,\r\n&lio->phy_beacon_val);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlio_ethtool_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nu32 tx_max_pending = 0, rx_max_pending = 0, tx_pending = 0,\r\nrx_pending = 0;\r\nif (OCTEON_CN6XXX(oct)) {\r\nstruct octeon_config *conf6x = CHIP_FIELD(oct, cn6xxx, conf);\r\ntx_max_pending = CN6XXX_MAX_IQ_DESCRIPTORS;\r\nrx_max_pending = CN6XXX_MAX_OQ_DESCRIPTORS;\r\nrx_pending = CFG_GET_NUM_RX_DESCS_NIC_IF(conf6x, lio->ifidx);\r\ntx_pending = CFG_GET_NUM_TX_DESCS_NIC_IF(conf6x, lio->ifidx);\r\n}\r\nif (lio->mtu > OCTNET_DEFAULT_FRM_SIZE) {\r\nering->rx_pending = 0;\r\nering->rx_max_pending = 0;\r\nering->rx_mini_pending = 0;\r\nering->rx_jumbo_pending = rx_pending;\r\nering->rx_mini_max_pending = 0;\r\nering->rx_jumbo_max_pending = rx_max_pending;\r\n} else {\r\nering->rx_pending = rx_pending;\r\nering->rx_max_pending = rx_max_pending;\r\nering->rx_mini_pending = 0;\r\nering->rx_jumbo_pending = 0;\r\nering->rx_mini_max_pending = 0;\r\nering->rx_jumbo_max_pending = 0;\r\n}\r\nering->tx_pending = tx_pending;\r\nering->tx_max_pending = tx_max_pending;\r\n}\r\nstatic u32 lio_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nreturn lio->msg_enable;\r\n}\r\nstatic void lio_set_msglevel(struct net_device *netdev, u32 msglvl)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nif ((msglvl ^ lio->msg_enable) & NETIF_MSG_HW) {\r\nif (msglvl & NETIF_MSG_HW)\r\nliquidio_set_feature(netdev,\r\nOCTNET_CMD_VERBOSE_ENABLE);\r\nelse\r\nliquidio_set_feature(netdev,\r\nOCTNET_CMD_VERBOSE_DISABLE);\r\n}\r\nlio->msg_enable = msglvl;\r\n}\r\nstatic void\r\nlio_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\r\n{\r\npause->tx_pause = 1;\r\npause->rx_pause = 1;\r\n}\r\nstatic void\r\nlio_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nint i = 0, j;\r\nfor (j = 0; j < MAX_OCTEON_INSTR_QUEUES; j++) {\r\nif (!(oct_dev->io_qmask.iq & (1UL << j)))\r\ncontinue;\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.instr_posted);\r\ndata[i++] =\r\nCVM_CAST64(\r\noct_dev->instr_queue[j]->stats.instr_processed);\r\ndata[i++] =\r\nCVM_CAST64(\r\noct_dev->instr_queue[j]->stats.instr_dropped);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.bytes_sent);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.sgentry_sent);\r\ndata[i++] =\r\nreadl(oct_dev->instr_queue[j]->inst_cnt_reg);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_done);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_iq_busy);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_dropped);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_tot_bytes);\r\n}\r\nfor (j = 0; j < MAX_OCTEON_OUTPUT_QUEUES; j++) {\r\nif (!(oct_dev->io_qmask.oq & (1UL << j)))\r\ncontinue;\r\ndata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.pkts_received);\r\ndata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.bytes_received);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->droq[j]->stats.dropped_nodispatch);\r\ndata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_nomem);\r\ndata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_toomany);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->droq[j]->stats.rx_pkts_received);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->droq[j]->stats.rx_bytes_received);\r\ndata[i++] =\r\nCVM_CAST64(oct_dev->droq[j]->stats.rx_dropped);\r\n}\r\n}\r\nstatic void lio_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nint num_iq_stats, num_oq_stats, i, j;\r\nnum_iq_stats = ARRAY_SIZE(oct_iq_stats_strings);\r\nfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES; i++) {\r\nif (!(oct_dev->io_qmask.iq & (1UL << i)))\r\ncontinue;\r\nfor (j = 0; j < num_iq_stats; j++) {\r\nsprintf(data, "IQ%d %s", i, oct_iq_stats_strings[j]);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\nnum_oq_stats = ARRAY_SIZE(oct_droq_stats_strings);\r\nfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES; i++) {\r\nif (!(oct_dev->io_qmask.oq & (1UL << i)))\r\ncontinue;\r\nfor (j = 0; j < num_oq_stats; j++) {\r\nsprintf(data, "OQ%d %s", i, oct_droq_stats_strings[j]);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\n}\r\nstatic int lio_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct_dev = lio->oct_dev;\r\nreturn (ARRAY_SIZE(oct_iq_stats_strings) * oct_dev->num_iqs) +\r\n(ARRAY_SIZE(oct_droq_stats_strings) * oct_dev->num_oqs);\r\n}\r\nstatic int lio_get_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *intr_coal)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nstruct octeon_instr_queue *iq;\r\nstruct oct_intrmod_cfg *intrmod_cfg;\r\nintrmod_cfg = &oct->intrmod;\r\nswitch (oct->chip_id) {\r\ncase OCTEON_CN68XX:\r\ncase OCTEON_CN66XX:\r\nif (!intrmod_cfg->intrmod_enable) {\r\nintr_coal->rx_coalesce_usecs =\r\nCFG_GET_OQ_INTR_TIME(cn6xxx->conf);\r\nintr_coal->rx_max_coalesced_frames =\r\nCFG_GET_OQ_INTR_PKT(cn6xxx->conf);\r\n} else {\r\nintr_coal->use_adaptive_rx_coalesce =\r\nintrmod_cfg->intrmod_enable;\r\nintr_coal->rate_sample_interval =\r\nintrmod_cfg->intrmod_check_intrvl;\r\nintr_coal->pkt_rate_high =\r\nintrmod_cfg->intrmod_maxpkt_ratethr;\r\nintr_coal->pkt_rate_low =\r\nintrmod_cfg->intrmod_minpkt_ratethr;\r\nintr_coal->rx_max_coalesced_frames_high =\r\nintrmod_cfg->intrmod_maxcnt_trigger;\r\nintr_coal->rx_coalesce_usecs_high =\r\nintrmod_cfg->intrmod_maxtmr_trigger;\r\nintr_coal->rx_coalesce_usecs_low =\r\nintrmod_cfg->intrmod_mintmr_trigger;\r\nintr_coal->rx_max_coalesced_frames_low =\r\nintrmod_cfg->intrmod_mincnt_trigger;\r\n}\r\niq = oct->instr_queue[lio->linfo.txpciq[0]];\r\nintr_coal->tx_max_coalesced_frames = iq->fill_threshold;\r\nbreak;\r\ndefault:\r\nnetif_info(lio, drv, lio->netdev, "Unknown Chip !!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void octnet_intrmod_callback(struct octeon_device *oct_dev,\r\nu32 status,\r\nvoid *ptr)\r\n{\r\nstruct oct_intrmod_cmd *cmd = ptr;\r\nstruct octeon_soft_command *sc = cmd->sc;\r\noct_dev = cmd->oct_dev;\r\nif (status)\r\ndev_err(&oct_dev->pci_dev->dev, "intrmod config failed. Status: %llx\n",\r\nCVM_CAST64(status));\r\nelse\r\ndev_info(&oct_dev->pci_dev->dev,\r\n"Rx-Adaptive Interrupt moderation enabled:%llx\n",\r\noct_dev->intrmod.intrmod_enable);\r\nocteon_free_soft_command(oct_dev, sc);\r\n}\r\nstatic int octnet_set_intrmod_cfg(void *oct, struct oct_intrmod_cfg *intr_cfg)\r\n{\r\nstruct octeon_soft_command *sc;\r\nstruct oct_intrmod_cmd *cmd;\r\nstruct oct_intrmod_cfg *cfg;\r\nint retval;\r\nstruct octeon_device *oct_dev = (struct octeon_device *)oct;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct_dev,\r\nsizeof(struct oct_intrmod_cfg),\r\n0,\r\nsizeof(struct oct_intrmod_cmd));\r\nif (!sc)\r\nreturn -ENOMEM;\r\ncmd = (struct oct_intrmod_cmd *)sc->ctxptr;\r\ncfg = (struct oct_intrmod_cfg *)sc->virtdptr;\r\nmemcpy(cfg, intr_cfg, sizeof(struct oct_intrmod_cfg));\r\nocteon_swap_8B_data((u64 *)cfg, (sizeof(struct oct_intrmod_cfg)) / 8);\r\ncmd->sc = sc;\r\ncmd->cfg = cfg;\r\ncmd->oct_dev = oct_dev;\r\nocteon_prepare_soft_command(oct_dev, sc, OPCODE_NIC,\r\nOPCODE_NIC_INTRMOD_CFG, 0, 0, 0);\r\nsc->callback = octnet_intrmod_callback;\r\nsc->callback_arg = cmd;\r\nsc->wait_time = 1000;\r\nretval = octeon_send_soft_command(oct_dev, sc);\r\nif (retval) {\r\nocteon_free_soft_command(oct_dev, sc);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int oct_cfg_adaptive_intr(struct lio *lio, struct ethtool_coalesce\r\n*intr_coal, int adaptive)\r\n{\r\nint ret = 0;\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct oct_intrmod_cfg *intrmod_cfg;\r\nintrmod_cfg = &oct->intrmod;\r\nif (adaptive) {\r\nif (intr_coal->rate_sample_interval)\r\nintrmod_cfg->intrmod_check_intrvl =\r\nintr_coal->rate_sample_interval;\r\nelse\r\nintrmod_cfg->intrmod_check_intrvl =\r\nLIO_INTRMOD_CHECK_INTERVAL;\r\nif (intr_coal->pkt_rate_high)\r\nintrmod_cfg->intrmod_maxpkt_ratethr =\r\nintr_coal->pkt_rate_high;\r\nelse\r\nintrmod_cfg->intrmod_maxpkt_ratethr =\r\nLIO_INTRMOD_MAXPKT_RATETHR;\r\nif (intr_coal->pkt_rate_low)\r\nintrmod_cfg->intrmod_minpkt_ratethr =\r\nintr_coal->pkt_rate_low;\r\nelse\r\nintrmod_cfg->intrmod_minpkt_ratethr =\r\nLIO_INTRMOD_MINPKT_RATETHR;\r\nif (intr_coal->rx_max_coalesced_frames_high)\r\nintrmod_cfg->intrmod_maxcnt_trigger =\r\nintr_coal->rx_max_coalesced_frames_high;\r\nelse\r\nintrmod_cfg->intrmod_maxcnt_trigger =\r\nLIO_INTRMOD_MAXCNT_TRIGGER;\r\nif (intr_coal->rx_coalesce_usecs_high)\r\nintrmod_cfg->intrmod_maxtmr_trigger =\r\nintr_coal->rx_coalesce_usecs_high;\r\nelse\r\nintrmod_cfg->intrmod_maxtmr_trigger =\r\nLIO_INTRMOD_MAXTMR_TRIGGER;\r\nif (intr_coal->rx_coalesce_usecs_low)\r\nintrmod_cfg->intrmod_mintmr_trigger =\r\nintr_coal->rx_coalesce_usecs_low;\r\nelse\r\nintrmod_cfg->intrmod_mintmr_trigger =\r\nLIO_INTRMOD_MINTMR_TRIGGER;\r\nif (intr_coal->rx_max_coalesced_frames_low)\r\nintrmod_cfg->intrmod_mincnt_trigger =\r\nintr_coal->rx_max_coalesced_frames_low;\r\nelse\r\nintrmod_cfg->intrmod_mincnt_trigger =\r\nLIO_INTRMOD_MINCNT_TRIGGER;\r\n}\r\nintrmod_cfg->intrmod_enable = adaptive;\r\nret = octnet_set_intrmod_cfg(oct, intrmod_cfg);\r\nreturn ret;\r\n}\r\nstatic int\r\noct_cfg_rx_intrcnt(struct lio *lio, struct ethtool_coalesce *intr_coal)\r\n{\r\nint ret;\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nu32 rx_max_coalesced_frames;\r\nif (!intr_coal->rx_max_coalesced_frames)\r\nrx_max_coalesced_frames = CN6XXX_OQ_INTR_PKT;\r\nelse\r\nrx_max_coalesced_frames = intr_coal->rx_max_coalesced_frames;\r\nret = oct_cfg_adaptive_intr(lio, intr_coal, 0);\r\nif (ret)\r\nreturn ret;\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_INT_LEVEL_PKTS,\r\nrx_max_coalesced_frames);\r\nCFG_SET_OQ_INTR_PKT(cn6xxx->conf, rx_max_coalesced_frames);\r\nreturn 0;\r\n}\r\nstatic int oct_cfg_rx_intrtime(struct lio *lio, struct ethtool_coalesce\r\n*intr_coal)\r\n{\r\nint ret;\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;\r\nu32 time_threshold, rx_coalesce_usecs;\r\nif (!intr_coal->rx_coalesce_usecs)\r\nrx_coalesce_usecs = CN6XXX_OQ_INTR_TIME;\r\nelse\r\nrx_coalesce_usecs = intr_coal->rx_coalesce_usecs;\r\nret = oct_cfg_adaptive_intr(lio, intr_coal, 0);\r\nif (ret)\r\nreturn ret;\r\ntime_threshold = lio_cn6xxx_get_oq_ticks(oct, rx_coalesce_usecs);\r\nocteon_write_csr(oct, CN6XXX_SLI_OQ_INT_LEVEL_TIME, time_threshold);\r\nCFG_SET_OQ_INTR_TIME(cn6xxx->conf, rx_coalesce_usecs);\r\nreturn 0;\r\n}\r\nstatic int lio_set_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *intr_coal)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nint ret;\r\nstruct octeon_device *oct = lio->oct_dev;\r\nu32 j, q_no;\r\nif ((intr_coal->tx_max_coalesced_frames >= CN6XXX_DB_MIN) &&\r\n(intr_coal->tx_max_coalesced_frames <= CN6XXX_DB_MAX)) {\r\nfor (j = 0; j < lio->linfo.num_txpciq; j++) {\r\nq_no = lio->linfo.txpciq[j];\r\noct->instr_queue[q_no]->fill_threshold =\r\nintr_coal->tx_max_coalesced_frames;\r\n}\r\n} else {\r\ndev_err(&oct->pci_dev->dev,\r\n"LIQUIDIO: Invalid tx-frames:%d. Range is min:%d max:%d\n",\r\nintr_coal->tx_max_coalesced_frames, CN6XXX_DB_MIN,\r\nCN6XXX_DB_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (intr_coal->use_adaptive_rx_coalesce) {\r\nret = oct_cfg_adaptive_intr(lio, intr_coal, 1);\r\nif (ret)\r\ngoto ret_intrmod;\r\n}\r\nif ((intr_coal->rx_coalesce_usecs) &&\r\n(!intr_coal->use_adaptive_rx_coalesce)) {\r\nret = oct_cfg_rx_intrtime(lio, intr_coal);\r\nif (ret)\r\ngoto ret_intrmod;\r\n}\r\nif ((intr_coal->rx_max_coalesced_frames) &&\r\n(!intr_coal->use_adaptive_rx_coalesce)) {\r\nret = oct_cfg_rx_intrcnt(lio, intr_coal);\r\nif (ret)\r\ngoto ret_intrmod;\r\n}\r\nif ((!intr_coal->rx_max_coalesced_frames) &&\r\n(!intr_coal->use_adaptive_rx_coalesce) &&\r\n(!intr_coal->rx_coalesce_usecs)) {\r\ndev_info(&oct->pci_dev->dev,\r\n"Turning off adaptive-rx interrupt moderation\n");\r\ndev_info(&oct->pci_dev->dev,\r\n"Using RX Coalesce Default values rx_coalesce_usecs:%d rx_max_coalesced_frames:%d\n",\r\nCN6XXX_OQ_INTR_TIME, CN6XXX_OQ_INTR_PKT);\r\nret = oct_cfg_rx_intrtime(lio, intr_coal);\r\nif (ret)\r\ngoto ret_intrmod;\r\nret = oct_cfg_rx_intrcnt(lio, intr_coal);\r\nif (ret)\r\ngoto ret_intrmod;\r\n}\r\nreturn 0;\r\nret_intrmod:\r\nreturn ret;\r\n}\r\nstatic int lio_get_ts_info(struct net_device *netdev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE | SOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (lio->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(lio->ptp_clock);\r\nelse\r\ninfo->phc_index = -1;\r\ninfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\r\nreturn 0;\r\n}\r\nstatic int lio_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct lio *lio = GET_LIO(netdev);\r\nstruct octeon_device *oct = lio->oct_dev;\r\nstruct oct_link_info *linfo;\r\nstruct octnic_ctrl_pkt nctrl;\r\nstruct octnic_ctrl_params nparams;\r\nint ret = 0;\r\nlinfo = &lio->linfo;\r\nif (ecmd->autoneg != AUTONEG_ENABLE && ecmd->autoneg != AUTONEG_DISABLE)\r\nreturn -EINVAL;\r\nif (ecmd->autoneg == AUTONEG_DISABLE && ((ecmd->speed != SPEED_100 &&\r\necmd->speed != SPEED_10) ||\r\n(ecmd->duplex != DUPLEX_HALF &&\r\necmd->duplex != DUPLEX_FULL)))\r\nreturn -EINVAL;\r\nif (linfo->link.s.interface == INTERFACE_MODE_XAUI ||\r\nlinfo->link.s.interface == INTERFACE_MODE_RXAUI) {\r\ndev_info(&oct->pci_dev->dev, "XAUI IFs settings cannot be modified.\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\r\nnctrl.ncmd.u64 = 0;\r\nnctrl.ncmd.s.cmd = OCTNET_CMD_SET_SETTINGS;\r\nnctrl.wait_time = 1000;\r\nnctrl.netpndev = (u64)netdev;\r\nnctrl.ncmd.s.param1 = lio->linfo.ifidx;\r\nnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nnctrl.ncmd.s.more = OCTNIC_NCMD_PHY_ON |\r\nOCTNIC_NCMD_AUTONEG_ON;\r\nnctrl.ncmd.s.param2 = ecmd->advertising;\r\n} else {\r\nnctrl.ncmd.s.more = OCTNIC_NCMD_PHY_ON;\r\nnctrl.ncmd.s.param3 = ecmd->duplex;\r\nnctrl.ncmd.s.param2 = ecmd->speed;\r\n}\r\nnparams.resp_order = OCTEON_RESP_ORDERED;\r\nret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl, nparams);\r\nif (ret < 0) {\r\ndev_err(&oct->pci_dev->dev, "Failed to set settings\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lio_nway_reset(struct net_device *netdev)\r\n{\r\nif (netif_running(netdev)) {\r\nstruct ethtool_cmd ecmd;\r\nmemset(&ecmd, 0, sizeof(struct ethtool_cmd));\r\necmd.autoneg = 0;\r\necmd.speed = 0;\r\necmd.duplex = 0;\r\nlio_set_settings(netdev, &ecmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lio_get_regs_len(struct net_device *dev)\r\n{\r\nreturn OCT_ETHTOOL_REGDUMP_LEN;\r\n}\r\nstatic int cn6xxx_read_csr_reg(char *s, struct octeon_device *oct)\r\n{\r\nu32 reg;\r\nint i, len = 0;\r\nlen += sprintf(s + len, "\n\t Octeon CSR Registers\n\n");\r\nreg = CN6XXX_WIN_WR_ADDR_LO;\r\nlen += sprintf(s + len, "\n[%02x] (WIN_WR_ADDR_LO): %08x\n",\r\nCN6XXX_WIN_WR_ADDR_LO, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_WIN_WR_ADDR_HI;\r\nlen += sprintf(s + len, "[%02x] (WIN_WR_ADDR_HI): %08x\n",\r\nCN6XXX_WIN_WR_ADDR_HI, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_WIN_RD_ADDR_LO;\r\nlen += sprintf(s + len, "[%02x] (WIN_RD_ADDR_LO): %08x\n",\r\nCN6XXX_WIN_RD_ADDR_LO, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_WIN_RD_ADDR_HI;\r\nlen += sprintf(s + len, "[%02x] (WIN_RD_ADDR_HI): %08x\n",\r\nCN6XXX_WIN_RD_ADDR_HI, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_WIN_WR_DATA_LO;\r\nlen += sprintf(s + len, "[%02x] (WIN_WR_DATA_LO): %08x\n",\r\nCN6XXX_WIN_WR_DATA_LO, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_WIN_WR_DATA_HI;\r\nlen += sprintf(s + len, "[%02x] (WIN_WR_DATA_HI): %08x\n",\r\nCN6XXX_WIN_WR_DATA_HI, octeon_read_csr(oct, reg));\r\nlen += sprintf(s + len, "[%02x] (WIN_WR_MASK_REG): %08x\n",\r\nCN6XXX_WIN_WR_MASK_REG,\r\nocteon_read_csr(oct, CN6XXX_WIN_WR_MASK_REG));\r\nlen += sprintf(s + len, "\n[%x] (INT_ENABLE PORT 0): %08x\n",\r\nCN6XXX_SLI_INT_ENB64_PORT0, octeon_read_csr(oct,\r\nCN6XXX_SLI_INT_ENB64_PORT0));\r\nlen += sprintf(s + len, "\n[%x] (INT_ENABLE PORT 1): %08x\n",\r\nCN6XXX_SLI_INT_ENB64_PORT1,\r\nocteon_read_csr(oct, CN6XXX_SLI_INT_ENB64_PORT1));\r\nlen += sprintf(s + len, "[%x] (INT_SUM): %08x\n", CN6XXX_SLI_INT_SUM64,\r\nocteon_read_csr(oct, CN6XXX_SLI_INT_SUM64));\r\nfor (i = 0; i < oct->num_oqs; i++) {\r\nreg = CN6XXX_SLI_OQ_PKTS_SENT(i);\r\nlen += sprintf(s + len, "\n[%x] (PKTS_SENT_%d): %08x\n",\r\nreg, i, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_SLI_OQ_PKTS_CREDIT(i);\r\nlen += sprintf(s + len, "[%x] (PKT_CREDITS_%d): %08x\n",\r\nreg, i, octeon_read_csr(oct, reg));\r\n}\r\nreg = CN6XXX_SLI_OQ_INT_LEVEL_PKTS;\r\nlen += sprintf(s + len, "\n[%x] (PKTS_SENT_INT_LEVEL): %08x\n",\r\nreg, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_SLI_OQ_INT_LEVEL_TIME;\r\nlen += sprintf(s + len, "[%x] (PKTS_SENT_TIME): %08x\n",\r\nreg, octeon_read_csr(oct, reg));\r\nfor (i = 0; i <= 3; i++) {\r\nu32 reg;\r\nreg = CN6XXX_SLI_IQ_DOORBELL(i);\r\nlen += sprintf(s + len, "\n[%x] (INSTR_DOORBELL_%d): %08x\n",\r\nreg, i, octeon_read_csr(oct, reg));\r\nreg = CN6XXX_SLI_IQ_INSTR_COUNT(i);\r\nlen += sprintf(s + len, "[%x] (INSTR_COUNT_%d): %08x\n",\r\nreg, i, octeon_read_csr(oct, reg));\r\n}\r\nlen += sprintf(s + len, "\n[%x] (DMA_CNT_0): %08x\n",\r\nCN6XXX_DMA_CNT(0),\r\nocteon_read_csr(oct, CN6XXX_DMA_CNT(0)));\r\nreg = CN6XXX_DMA_PKT_INT_LEVEL(0);\r\nlen += sprintf(s + len, "[%x] (DMA_INT_LEV_0): %08x\n",\r\nCN6XXX_DMA_PKT_INT_LEVEL(0), octeon_read_csr(oct, reg));\r\nreg = CN6XXX_DMA_TIME_INT_LEVEL(0);\r\nlen += sprintf(s + len, "[%x] (DMA_TIME_0): %08x\n",\r\nCN6XXX_DMA_TIME_INT_LEVEL(0),\r\nocteon_read_csr(oct, reg));\r\nlen += sprintf(s + len, "\n[%x] (DMA_CNT_1): %08x\n",\r\nCN6XXX_DMA_CNT(1),\r\nocteon_read_csr(oct, CN6XXX_DMA_CNT(1)));\r\nreg = CN6XXX_DMA_PKT_INT_LEVEL(1);\r\nlen += sprintf(s + len, "[%x] (DMA_INT_LEV_1): %08x\n",\r\nCN6XXX_DMA_PKT_INT_LEVEL(1),\r\nocteon_read_csr(oct, reg));\r\nreg = CN6XXX_DMA_PKT_INT_LEVEL(1);\r\nlen += sprintf(s + len, "[%x] (DMA_TIME_1): %08x\n",\r\nCN6XXX_DMA_TIME_INT_LEVEL(1),\r\nocteon_read_csr(oct, reg));\r\nlen += sprintf(s + len, "\n");\r\nfor (i = 0; i < 16; i++) {\r\nreg = lio_pci_readq(oct, CN6XXX_BAR1_REG(i, oct->pcie_port));\r\nlen += sprintf(s + len, "[%llx] (BAR1_INDEX_%02d): %08x\n",\r\nCN6XXX_BAR1_REG(i, oct->pcie_port), i, reg);\r\n}\r\nreturn len;\r\n}\r\nstatic int cn6xxx_read_config_reg(char *s, struct octeon_device *oct)\r\n{\r\nu32 val;\r\nint i, len = 0;\r\nlen += sprintf(s + len,\r\n"\n\t Octeon Config space Registers\n\n");\r\nfor (i = 0; i <= 13; i++) {\r\npci_read_config_dword(oct->pci_dev, (i * 4), &val);\r\nlen += sprintf(s + len, "[0x%x] (Config[%d]): 0x%08x\n",\r\n(i * 4), i, val);\r\n}\r\nfor (i = 30; i <= 34; i++) {\r\npci_read_config_dword(oct->pci_dev, (i * 4), &val);\r\nlen += sprintf(s + len, "[0x%x] (Config[%d]): 0x%08x\n",\r\n(i * 4), i, val);\r\n}\r\nreturn len;\r\n}\r\nstatic void lio_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *regbuf)\r\n{\r\nstruct lio *lio = GET_LIO(dev);\r\nint len = 0;\r\nstruct octeon_device *oct = lio->oct_dev;\r\nmemset(regbuf, 0, OCT_ETHTOOL_REGDUMP_LEN);\r\nregs->version = OCT_ETHTOOL_REGSVER;\r\nswitch (oct->chip_id) {\r\ncase OCTEON_CN68XX:\r\ncase OCTEON_CN66XX:\r\nlen += cn6xxx_read_csr_reg(regbuf + len, oct);\r\nlen += cn6xxx_read_config_reg(regbuf + len, oct);\r\nbreak;\r\ndefault:\r\ndev_err(&oct->pci_dev->dev, "%s Unknown chipid: %d\n",\r\n__func__, oct->chip_id);\r\n}\r\n}\r\nvoid liquidio_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &lio_ethtool_ops;\r\n}
