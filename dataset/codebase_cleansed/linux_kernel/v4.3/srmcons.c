static int\r\nsrmcons_do_receive_chars(struct tty_port *port)\r\n{\r\nsrmcons_result result;\r\nint count = 0, loops = 0;\r\ndo {\r\nresult.as_long = callback_getc(0);\r\nif (result.bits.status < 2) {\r\ntty_insert_flip_char(port, (char)result.bits.c, 0);\r\ncount++;\r\n}\r\n} while((result.bits.status & 1) && (++loops < 10));\r\nif (count)\r\ntty_schedule_flip(port);\r\nreturn count;\r\n}\r\nstatic void\r\nsrmcons_receive_chars(unsigned long data)\r\n{\r\nstruct srmcons_private *srmconsp = (struct srmcons_private *)data;\r\nstruct tty_port *port = &srmconsp->port;\r\nunsigned long flags;\r\nint incr = 10;\r\nlocal_irq_save(flags);\r\nif (spin_trylock(&srmcons_callback_lock)) {\r\nif (!srmcons_do_receive_chars(port))\r\nincr = 100;\r\nspin_unlock(&srmcons_callback_lock);\r\n}\r\nspin_lock(&port->lock);\r\nif (port->tty)\r\nmod_timer(&srmconsp->timer, jiffies + incr);\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nsrmcons_do_write(struct tty_port *port, const char *buf, int count)\r\n{\r\nstatic char str_cr[1] = "\r";\r\nlong c, remaining = count;\r\nsrmcons_result result;\r\nchar *cur;\r\nint need_cr;\r\nfor (cur = (char *)buf; remaining > 0; ) {\r\nneed_cr = 0;\r\nfor (c = 0; c < min_t(long, 128L, remaining) && !need_cr; c++)\r\nif (cur[c] == '\n')\r\nneed_cr = 1;\r\nwhile (c > 0) {\r\nresult.as_long = callback_puts(0, cur, c);\r\nc -= result.bits.c;\r\nremaining -= result.bits.c;\r\ncur += result.bits.c;\r\nif (port)\r\nsrmcons_do_receive_chars(port);\r\n}\r\nwhile (need_cr) {\r\nresult.as_long = callback_puts(0, str_cr, 1);\r\nif (result.bits.c > 0)\r\nneed_cr = 0;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nsrmcons_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&srmcons_callback_lock, flags);\r\nsrmcons_do_write(tty->port, (const char *) buf, count);\r\nspin_unlock_irqrestore(&srmcons_callback_lock, flags);\r\nreturn count;\r\n}\r\nstatic int\r\nsrmcons_write_room(struct tty_struct *tty)\r\n{\r\nreturn 512;\r\n}\r\nstatic int\r\nsrmcons_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nsrmcons_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct srmcons_private *srmconsp = &srmcons_singleton;\r\nstruct tty_port *port = &srmconsp->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!port->tty) {\r\ntty->driver_data = srmconsp;\r\ntty->port = port;\r\nport->tty = tty;\r\nmod_timer(&srmconsp->timer, jiffies + 10);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nsrmcons_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct srmcons_private *srmconsp = tty->driver_data;\r\nstruct tty_port *port = &srmconsp->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (tty->count == 1) {\r\nport->tty = NULL;\r\ndel_timer(&srmconsp->timer);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int __init\r\nsrmcons_init(void)\r\n{\r\nsetup_timer(&srmcons_singleton.timer, srmcons_receive_chars,\r\n(unsigned long)&srmcons_singleton);\r\nif (srm_is_registered_console) {\r\nstruct tty_driver *driver;\r\nint err;\r\ndriver = alloc_tty_driver(MAX_SRM_CONSOLE_DEVICES);\r\nif (!driver)\r\nreturn -ENOMEM;\r\ntty_port_init(&srmcons_singleton.port);\r\ndriver->driver_name = "srm";\r\ndriver->name = "srm";\r\ndriver->major = 0;\r\ndriver->minor_start = 0;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_SYSCONS;\r\ndriver->init_termios = tty_std_termios;\r\ntty_set_operations(driver, &srmcons_ops);\r\ntty_port_link_device(&srmcons_singleton.port, driver, 0);\r\nerr = tty_register_driver(driver);\r\nif (err) {\r\nput_tty_driver(driver);\r\ntty_port_destroy(&srmcons_singleton.port);\r\nreturn err;\r\n}\r\nsrmcons_driver = driver;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nsrm_console_write(struct console *co, const char *s, unsigned count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&srmcons_callback_lock, flags);\r\nsrmcons_do_write(NULL, s, count);\r\nspin_unlock_irqrestore(&srmcons_callback_lock, flags);\r\n}\r\nstatic struct tty_driver *\r\nsrm_console_device(struct console *co, int *index)\r\n{\r\n*index = co->index;\r\nreturn srmcons_driver;\r\n}\r\nstatic int\r\nsrm_console_setup(struct console *co, char *options)\r\n{\r\nreturn 0;\r\n}\r\nvoid __init\r\nregister_srm_console(void)\r\n{\r\nif (!srm_is_registered_console) {\r\ncallback_open_console();\r\nregister_console(&srmcons);\r\nsrm_is_registered_console = 1;\r\n}\r\n}\r\nvoid __init\r\nunregister_srm_console(void)\r\n{\r\nif (srm_is_registered_console) {\r\ncallback_close_console();\r\nunregister_console(&srmcons);\r\nsrm_is_registered_console = 0;\r\n}\r\n}
