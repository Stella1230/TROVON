static int\r\nsnic_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct snic_tgt *tgt = starget_to_tgt(scsi_target(sdev));\r\nif (!tgt || snic_tgt_chkready(tgt))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnic_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct snic *snic = shost_priv(sdev->host);\r\nu32 qdepth = 0, max_ios = 0;\r\nint tmo = SNIC_DFLT_CMD_TIMEOUT * HZ;\r\nmax_ios = snic_max_qdepth;\r\nqdepth = min_t(u32, max_ios, SNIC_MAX_QUEUE_DEPTH);\r\nscsi_change_queue_depth(sdev, qdepth);\r\nif (snic->fwinfo.io_tmo > 1)\r\ntmo = snic->fwinfo.io_tmo * HZ;\r\nblk_queue_rq_timeout(sdev->request_queue, tmo);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnic_change_queue_depth(struct scsi_device *sdev, int qdepth)\r\n{\r\nint qsz = 0;\r\nqsz = min_t(u32, qdepth, SNIC_MAX_QUEUE_DEPTH);\r\nscsi_change_queue_depth(sdev, qsz);\r\nSNIC_INFO("QDepth Changed to %d\n", sdev->queue_depth);\r\nreturn sdev->queue_depth;\r\n}\r\nvoid\r\nsnic_handle_link_event(struct snic *snic)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nif (snic->stop_link_events) {\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nqueue_work(snic_glob->event_q, &snic->link_work);\r\n}\r\nstatic int\r\nsnic_notify_set(struct snic *snic)\r\n{\r\nint ret = 0;\r\nenum vnic_dev_intr_mode intr_mode;\r\nintr_mode = svnic_dev_get_intr_mode(snic->vdev);\r\nif (intr_mode == VNIC_DEV_INTR_MODE_MSIX) {\r\nret = svnic_dev_notify_set(snic->vdev, SNIC_MSIX_ERR_NOTIFY);\r\n} else {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Interrupt mode should be setup before devcmd notify set %d\n",\r\nintr_mode);\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_dev_wait(struct vnic_dev *vdev,\r\nint (*start)(struct vnic_dev *, int),\r\nint (*finished)(struct vnic_dev *, int *),\r\nint arg)\r\n{\r\nunsigned long time;\r\nint ret, done;\r\nint retry_cnt = 0;\r\nret = start(vdev, arg);\r\nif (ret)\r\nreturn ret;\r\ntime = jiffies + (HZ * 2);\r\ndo {\r\nret = finished(vdev, &done);\r\nif (ret)\r\nreturn ret;\r\nif (done)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(HZ/10);\r\n++retry_cnt;\r\n} while (time_after(time, jiffies) || (retry_cnt < 3));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nsnic_cleanup(struct snic *snic)\r\n{\r\nunsigned int i;\r\nint ret;\r\nsvnic_dev_disable(snic->vdev);\r\nfor (i = 0; i < snic->intr_count; i++)\r\nsvnic_intr_mask(&snic->intr[i]);\r\nfor (i = 0; i < snic->wq_count; i++) {\r\nret = svnic_wq_disable(&snic->wq[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsnic_fwcq_cmpl_handler(snic, -1);\r\nsnic_wq_cmpl_handler(snic, -1);\r\nfor (i = 0; i < snic->wq_count; i++)\r\nsvnic_wq_clean(&snic->wq[i], snic_free_wq_buf);\r\nfor (i = 0; i < snic->cq_count; i++)\r\nsvnic_cq_clean(&snic->cq[i]);\r\nfor (i = 0; i < snic->intr_count; i++)\r\nsvnic_intr_clean(&snic->intr[i]);\r\nsnic_free_all_untagged_reqs(snic);\r\nsnic_shutdown_scsi_cleanup(snic);\r\nfor (i = 0; i < SNIC_REQ_MAX_CACHES; i++)\r\nmempool_destroy(snic->req_pool[i]);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnic_iounmap(struct snic *snic)\r\n{\r\nif (snic->bar0.vaddr)\r\niounmap(snic->bar0.vaddr);\r\n}\r\nstatic int\r\nsnic_vdev_open_done(struct vnic_dev *vdev, int *done)\r\n{\r\nstruct snic *snic = svnic_dev_priv(vdev);\r\nint ret;\r\nint nretries = 5;\r\ndo {\r\nret = svnic_dev_open_done(vdev, done);\r\nif (ret == 0)\r\nbreak;\r\nSNIC_HOST_INFO(snic->shost, "VNIC_DEV_OPEN Timedout.\n");\r\n} while (nretries--);\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_add_host(struct Scsi_Host *shost, struct pci_dev *pdev)\r\n{\r\nint ret = 0;\r\nret = scsi_add_host(shost, &pdev->dev);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"snic: scsi_add_host failed. %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nSNIC_BUG_ON(shost->work_q != NULL);\r\nsnprintf(shost->work_q_name, sizeof(shost->work_q_name), "scsi_wq_%d",\r\nshost->host_no);\r\nshost->work_q = create_singlethread_workqueue(shost->work_q_name);\r\nif (!shost->work_q) {\r\nSNIC_HOST_ERR(shost, "Failed to Create ScsiHost wq.\n");\r\nret = -ENOMEM;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_del_host(struct Scsi_Host *shost)\r\n{\r\nif (!shost->work_q)\r\nreturn;\r\ndestroy_workqueue(shost->work_q);\r\nshost->work_q = NULL;\r\nscsi_remove_host(shost);\r\n}\r\nint\r\nsnic_get_state(struct snic *snic)\r\n{\r\nreturn atomic_read(&snic->state);\r\n}\r\nvoid\r\nsnic_set_state(struct snic *snic, enum snic_state state)\r\n{\r\nSNIC_HOST_INFO(snic->shost, "snic state change from %s to %s\n",\r\nsnic_state_to_str(snic_get_state(snic)),\r\nsnic_state_to_str(state));\r\natomic_set(&snic->state, state);\r\n}\r\nstatic int\r\nsnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct snic *snic;\r\nmempool_t *pool;\r\nunsigned long flags;\r\nu32 max_ios = 0;\r\nint ret, i;\r\nSNIC_INFO("snic device %4x:%4x:%4x:%4x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nSNIC_INFO("snic device bus %x: slot %x: fn %x\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\nshost = scsi_host_alloc(&snic_host_template, sizeof(struct snic));\r\nif (!shost) {\r\nSNIC_ERR("Unable to alloc scsi_host\n");\r\nret = -ENOMEM;\r\ngoto prob_end;\r\n}\r\nsnic = shost_priv(shost);\r\nsnic->shost = shost;\r\nsnprintf(snic->name, sizeof(snic->name) - 1, "%s%d", SNIC_DRV_NAME,\r\nshost->host_no);\r\nSNIC_HOST_INFO(shost,\r\n"snic%d = %p shost = %p device bus %x: slot %x: fn %x\n",\r\nshost->host_no, snic, shost, pdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nret = snic_stats_debugfs_init(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Failed to initialize debugfs stats\n");\r\nsnic_stats_debugfs_remove(snic);\r\n}\r\n#endif\r\npci_set_drvdata(pdev, snic);\r\nsnic->pdev = pdev;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Cannot enable PCI Resources, aborting : %d\n",\r\nret);\r\ngoto err_free_snic;\r\n}\r\nret = pci_request_regions(pdev, SNIC_DRV_NAME);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Cannot obtain PCI Resources, aborting : %d\n",\r\nret);\r\ngoto err_pci_disable;\r\n}\r\npci_set_master(pdev);\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(43));\r\nif (ret) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"No Usable DMA Configuration, aborting %d\n",\r\nret);\r\ngoto err_rel_regions;\r\n}\r\nret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Unable to obtain 32-bit DMA for consistent allocations, aborting: %d\n",\r\nret);\r\ngoto err_rel_regions;\r\n}\r\n} else {\r\nret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(43));\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Unable to obtain 43-bit DMA for consistent allocations. aborting: %d\n",\r\nret);\r\ngoto err_rel_regions;\r\n}\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nSNIC_HOST_ERR(shost, "BAR0 not memory mappable aborting.\n");\r\nret = -ENODEV;\r\ngoto err_rel_regions;\r\n}\r\nsnic->bar0.vaddr = pci_iomap(pdev, 0, 0);\r\nif (!snic->bar0.vaddr) {\r\nSNIC_HOST_ERR(shost,\r\n"Cannot memory map BAR0 res hdr aborting.\n");\r\nret = -ENODEV;\r\ngoto err_rel_regions;\r\n}\r\nsnic->bar0.bus_addr = pci_resource_start(pdev, 0);\r\nsnic->bar0.len = pci_resource_len(pdev, 0);\r\nSNIC_BUG_ON(snic->bar0.bus_addr == 0);\r\nsnic->vdev = svnic_dev_alloc_discover(NULL, snic, pdev, &snic->bar0, 1);\r\nif (!snic->vdev) {\r\nSNIC_HOST_ERR(shost, "vNIC Resource Discovery Failed.\n");\r\nret = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\nret = svnic_dev_cmd_init(snic->vdev, 0);\r\nif (ret) {\r\nSNIC_HOST_INFO(shost, "Devcmd2 Init Failed. err = %d\n", ret);\r\ngoto err_vnic_unreg;\r\n}\r\nret = snic_dev_wait(snic->vdev, svnic_dev_open, snic_vdev_open_done, 0);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"vNIC dev open failed, aborting. %d\n",\r\nret);\r\ngoto err_vnic_unreg;\r\n}\r\nret = svnic_dev_init(snic->vdev, 0);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"vNIC dev init failed. aborting. %d\n",\r\nret);\r\ngoto err_dev_close;\r\n}\r\nret = snic_get_vnic_config(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Get vNIC configuration failed, aborting. %d\n",\r\nret);\r\ngoto err_dev_close;\r\n}\r\nmax_ios = snic->config.io_throttle_count;\r\nif (max_ios != SNIC_UCSM_DFLT_THROTTLE_CNT_BLD)\r\nshost->can_queue = min_t(u32, SNIC_MAX_IO_REQ,\r\nmax_t(u32, SNIC_MIN_IO_REQ, max_ios));\r\nsnic->max_tag_id = shost->can_queue;\r\nret = scsi_init_shared_tag_map(shost, snic->max_tag_id);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Unable to alloc shared tag map. %d\n",\r\nret);\r\ngoto err_dev_close;\r\n}\r\nshost->max_lun = snic->config.luns_per_tgt;\r\nshost->max_id = SNIC_MAX_TARGET;\r\nshost->max_cmd_len = MAX_COMMAND_SIZE;\r\nsnic_get_res_counts(snic);\r\nret = snic_set_intr_mode(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Failed to set intr mode aborting. %d\n",\r\nret);\r\ngoto err_dev_close;\r\n}\r\nret = snic_alloc_vnic_res(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Failed to alloc vNIC resources aborting. %d\n",\r\nret);\r\ngoto err_clear_intr;\r\n}\r\nINIT_LIST_HEAD(&snic->list);\r\nINIT_LIST_HEAD(&snic->spl_cmd_list);\r\nspin_lock_init(&snic->spl_cmd_lock);\r\nspin_lock_init(&snic->snic_lock);\r\nfor (i = 0; i < SNIC_WQ_MAX; i++)\r\nspin_lock_init(&snic->wq_lock[i]);\r\nfor (i = 0; i < SNIC_IO_LOCKS; i++)\r\nspin_lock_init(&snic->io_req_lock[i]);\r\npool = mempool_create_slab_pool(2,\r\nsnic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\r\nif (!pool) {\r\nSNIC_HOST_ERR(shost, "dflt sgl pool creation failed\n");\r\ngoto err_free_res;\r\n}\r\nsnic->req_pool[SNIC_REQ_CACHE_DFLT_SGL] = pool;\r\npool = mempool_create_slab_pool(2,\r\nsnic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\r\nif (!pool) {\r\nSNIC_HOST_ERR(shost, "max sgl pool creation failed\n");\r\ngoto err_free_dflt_sgl_pool;\r\n}\r\nsnic->req_pool[SNIC_REQ_CACHE_MAX_SGL] = pool;\r\npool = mempool_create_slab_pool(2,\r\nsnic_glob->req_cache[SNIC_REQ_TM_CACHE]);\r\nif (!pool) {\r\nSNIC_HOST_ERR(shost, "snic tmreq info pool creation failed.\n");\r\ngoto err_free_max_sgl_pool;\r\n}\r\nsnic->req_pool[SNIC_REQ_TM_CACHE] = pool;\r\natomic_set(&snic->state, SNIC_INIT);\r\natomic_set(&snic->ios_inflight, 0);\r\nret = snic_notify_set(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Failed to alloc notify buffer aborting. %d\n",\r\nret);\r\ngoto err_free_tmreq_pool;\r\n}\r\nret = snic_add_host(shost, pdev);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Adding scsi host Failed ... exiting. %d\n",\r\nret);\r\ngoto err_notify_unset;\r\n}\r\nspin_lock_irqsave(&snic_glob->snic_list_lock, flags);\r\nlist_add_tail(&snic->list, &snic_glob->snic_list);\r\nspin_unlock_irqrestore(&snic_glob->snic_list_lock, flags);\r\nsnic_disc_init(&snic->disc);\r\nINIT_WORK(&snic->tgt_work, snic_handle_tgt_disc);\r\nINIT_WORK(&snic->disc_work, snic_handle_disc);\r\nINIT_WORK(&snic->link_work, snic_handle_link);\r\nfor (i = 0; i < snic->wq_count; i++)\r\nsvnic_wq_enable(&snic->wq[i]);\r\nret = svnic_dev_enable_wait(snic->vdev);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"vNIC dev enable failed w/ error %d\n",\r\nret);\r\ngoto err_vdev_enable;\r\n}\r\nret = snic_request_intr(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost, "Unable to request irq. %d\n", ret);\r\ngoto err_req_intr;\r\n}\r\nfor (i = 0; i < snic->intr_count; i++)\r\nsvnic_intr_unmask(&snic->intr[i]);\r\nsnic_set_state(snic, SNIC_ONLINE);\r\nret = snic_get_conf(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"Failed to get snic io config from FW w err %d\n",\r\nret);\r\ngoto err_get_conf;\r\n}\r\nret = snic_disc_start(snic);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost, "snic_probe:Discovery Failed w err = %d\n",\r\nret);\r\ngoto err_get_conf;\r\n}\r\nSNIC_HOST_INFO(shost, "SNIC Device Probe Successful.\n");\r\nreturn 0;\r\nerr_get_conf:\r\nsnic_free_all_untagged_reqs(snic);\r\nfor (i = 0; i < snic->intr_count; i++)\r\nsvnic_intr_mask(&snic->intr[i]);\r\nsnic_free_intr(snic);\r\nerr_req_intr:\r\nsvnic_dev_disable(snic->vdev);\r\nerr_vdev_enable:\r\nfor (i = 0; i < snic->wq_count; i++) {\r\nint rc = 0;\r\nrc = svnic_wq_disable(&snic->wq[i]);\r\nif (rc) {\r\nSNIC_HOST_ERR(shost,\r\n"WQ Disable Failed w/ err = %d\n", rc);\r\nbreak;\r\n}\r\n}\r\nsnic_del_host(snic->shost);\r\nerr_notify_unset:\r\nsvnic_dev_notify_unset(snic->vdev);\r\nerr_free_tmreq_pool:\r\nmempool_destroy(snic->req_pool[SNIC_REQ_TM_CACHE]);\r\nerr_free_max_sgl_pool:\r\nmempool_destroy(snic->req_pool[SNIC_REQ_CACHE_MAX_SGL]);\r\nerr_free_dflt_sgl_pool:\r\nmempool_destroy(snic->req_pool[SNIC_REQ_CACHE_DFLT_SGL]);\r\nerr_free_res:\r\nsnic_free_vnic_res(snic);\r\nerr_clear_intr:\r\nsnic_clear_intr_mode(snic);\r\nerr_dev_close:\r\nsvnic_dev_close(snic->vdev);\r\nerr_vnic_unreg:\r\nsvnic_dev_unregister(snic->vdev);\r\nerr_iounmap:\r\nsnic_iounmap(snic);\r\nerr_rel_regions:\r\npci_release_regions(pdev);\r\nerr_pci_disable:\r\npci_disable_device(pdev);\r\nerr_free_snic:\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nsnic_stats_debugfs_remove(snic);\r\n#endif\r\nscsi_host_put(shost);\r\npci_set_drvdata(pdev, NULL);\r\nprob_end:\r\nSNIC_INFO("sNIC device : bus %d: slot %d: fn %d Registration Failed.\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_remove(struct pci_dev *pdev)\r\n{\r\nstruct snic *snic = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nif (!snic) {\r\nSNIC_INFO("sNIC dev: bus %d slot %d fn %d snic inst is null.\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\nreturn;\r\n}\r\nsnic_set_state(snic, SNIC_OFFLINE);\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nsnic->stop_link_events = 1;\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nflush_workqueue(snic_glob->event_q);\r\nsnic_disc_term(snic);\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nsnic->in_remove = 1;\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nsnic_cleanup(snic);\r\nspin_lock_irqsave(&snic_glob->snic_list_lock, flags);\r\nlist_del(&snic->list);\r\nspin_unlock_irqrestore(&snic_glob->snic_list_lock, flags);\r\nsnic_tgt_del_all(snic);\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nsnic_stats_debugfs_remove(snic);\r\n#endif\r\nsnic_del_host(snic->shost);\r\nsvnic_dev_notify_unset(snic->vdev);\r\nsnic_free_intr(snic);\r\nsnic_free_vnic_res(snic);\r\nsnic_clear_intr_mode(snic);\r\nsvnic_dev_close(snic->vdev);\r\nsvnic_dev_unregister(snic->vdev);\r\nsnic_iounmap(snic);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nscsi_host_put(snic->shost);\r\n}\r\nstatic int\r\nsnic_global_data_init(void)\r\n{\r\nint ret = 0;\r\nstruct kmem_cache *cachep;\r\nssize_t len = 0;\r\nsnic_glob = kzalloc(sizeof(*snic_glob), GFP_KERNEL);\r\nif (!snic_glob) {\r\nSNIC_ERR("Failed to allocate Global Context.\n");\r\nret = -ENOMEM;\r\ngoto gdi_end;\r\n}\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nret = snic_debugfs_init();\r\nif (ret < 0) {\r\nSNIC_ERR("Failed to create sysfs dir for tracing and stats.\n");\r\nsnic_debugfs_term();\r\n}\r\nret = snic_trc_init();\r\nif (ret < 0) {\r\nSNIC_ERR("Trace buffer init failed, SNIC tracing disabled\n");\r\nsnic_trc_free();\r\n}\r\n#endif\r\nINIT_LIST_HEAD(&snic_glob->snic_list);\r\nspin_lock_init(&snic_glob->snic_list_lock);\r\nlen = sizeof(struct snic_req_info);\r\nlen += sizeof(struct snic_host_req) + sizeof(struct snic_dflt_sgl);\r\ncachep = kmem_cache_create("snic_req_dfltsgl", len, SNIC_SG_DESC_ALIGN,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!cachep) {\r\nSNIC_ERR("Failed to create snic default sgl slab\n");\r\nret = -ENOMEM;\r\ngoto err_dflt_req_slab;\r\n}\r\nsnic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL] = cachep;\r\nlen = sizeof(struct snic_req_info);\r\nlen += sizeof(struct snic_host_req) + sizeof(struct snic_max_sgl);\r\ncachep = kmem_cache_create("snic_req_maxsgl", len, SNIC_SG_DESC_ALIGN,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!cachep) {\r\nSNIC_ERR("Failed to create snic max sgl slab\n");\r\nret = -ENOMEM;\r\ngoto err_max_req_slab;\r\n}\r\nsnic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL] = cachep;\r\nlen = sizeof(struct snic_host_req);\r\ncachep = kmem_cache_create("snic_req_maxsgl", len, SNIC_SG_DESC_ALIGN,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!cachep) {\r\nSNIC_ERR("Failed to create snic tm req slab\n");\r\nret = -ENOMEM;\r\ngoto err_tmreq_slab;\r\n}\r\nsnic_glob->req_cache[SNIC_REQ_TM_CACHE] = cachep;\r\nsnic_glob->event_q = create_singlethread_workqueue("snic_event_wq");\r\nif (!snic_glob->event_q) {\r\nSNIC_ERR("snic event queue create failed\n");\r\nret = -ENOMEM;\r\ngoto err_eventq;\r\n}\r\nreturn ret;\r\nerr_eventq:\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_TM_CACHE]);\r\nerr_tmreq_slab:\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\r\nerr_max_req_slab:\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\r\nerr_dflt_req_slab:\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nsnic_trc_free();\r\nsnic_debugfs_term();\r\n#endif\r\nkfree(snic_glob);\r\nsnic_glob = NULL;\r\ngdi_end:\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_global_data_cleanup(void)\r\n{\r\nSNIC_BUG_ON(snic_glob == NULL);\r\ndestroy_workqueue(snic_glob->event_q);\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_TM_CACHE]);\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_MAX_SGL]);\r\nkmem_cache_destroy(snic_glob->req_cache[SNIC_REQ_CACHE_DFLT_SGL]);\r\n#ifdef CONFIG_SCSI_SNIC_DEBUG_FS\r\nsnic_trc_free();\r\nsnic_debugfs_term();\r\n#endif\r\nkfree(snic_glob);\r\nsnic_glob = NULL;\r\n}\r\nstatic int __init\r\nsnic_init_module(void)\r\n{\r\nint ret = 0;\r\n#ifndef __x86_64__\r\nSNIC_INFO("SNIC Driver is supported only for x86_64 platforms!\n");\r\nadd_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);\r\n#endif\r\nSNIC_INFO("%s, ver %s\n", SNIC_DRV_DESCRIPTION, SNIC_DRV_VERSION);\r\nret = snic_global_data_init();\r\nif (ret) {\r\nSNIC_ERR("Failed to Initialize Global Data.\n");\r\nreturn ret;\r\n}\r\nret = pci_register_driver(&snic_driver);\r\nif (ret < 0) {\r\nSNIC_ERR("PCI driver register error\n");\r\ngoto err_pci_reg;\r\n}\r\nreturn ret;\r\nerr_pci_reg:\r\nsnic_global_data_cleanup();\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nsnic_cleanup_module(void)\r\n{\r\npci_unregister_driver(&snic_driver);\r\nsnic_global_data_cleanup();\r\n}
