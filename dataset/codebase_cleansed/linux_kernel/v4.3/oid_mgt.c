int\r\nchannel_of_freq(int f)\r\n{\r\nint c = 0;\r\nif ((f >= 2412) && (f <= 2484)) {\r\nwhile ((c < 14) && (f != frequency_list_bg[c]))\r\nc++;\r\nreturn (c >= 14) ? 0 : ++c;\r\n} else if ((f >= (int) 5000) && (f <= (int) 6000)) {\r\nreturn ( (f - 5000) / 5 );\r\n} else\r\nreturn 0;\r\n}\r\nint\r\nmgt_init(islpci_private *priv)\r\n{\r\nint i;\r\npriv->mib = kcalloc(OID_NUM_LAST, sizeof (void *), GFP_KERNEL);\r\nif (!priv->mib)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < OID_NUM_LAST; i++) {\r\nif (isl_oid[i].flags & OID_FLAG_CACHED) {\r\npriv->mib[i] = kzalloc(isl_oid[i].size *\r\n(isl_oid[i].range + 1),\r\nGFP_KERNEL);\r\nif (!priv->mib[i])\r\nreturn -ENOMEM;\r\n} else\r\npriv->mib[i] = NULL;\r\n}\r\ninit_rwsem(&priv->mib_sem);\r\nprism54_mib_init(priv);\r\nreturn 0;\r\n}\r\nvoid\r\nmgt_clean(islpci_private *priv)\r\n{\r\nint i;\r\nif (!priv->mib)\r\nreturn;\r\nfor (i = 0; i < OID_NUM_LAST; i++) {\r\nkfree(priv->mib[i]);\r\npriv->mib[i] = NULL;\r\n}\r\nkfree(priv->mib);\r\npriv->mib = NULL;\r\n}\r\nvoid\r\nmgt_le_to_cpu(int type, void *data)\r\n{\r\nswitch (type) {\r\ncase OID_TYPE_U32:\r\n*(u32 *) data = le32_to_cpu(*(u32 *) data);\r\nbreak;\r\ncase OID_TYPE_BUFFER:{\r\nstruct obj_buffer *buff = data;\r\nbuff->size = le32_to_cpu(buff->size);\r\nbuff->addr = le32_to_cpu(buff->addr);\r\nbreak;\r\n}\r\ncase OID_TYPE_BSS:{\r\nstruct obj_bss *bss = data;\r\nbss->age = le16_to_cpu(bss->age);\r\nbss->channel = le16_to_cpu(bss->channel);\r\nbss->capinfo = le16_to_cpu(bss->capinfo);\r\nbss->rates = le16_to_cpu(bss->rates);\r\nbss->basic_rates = le16_to_cpu(bss->basic_rates);\r\nbreak;\r\n}\r\ncase OID_TYPE_BSSLIST:{\r\nstruct obj_bsslist *list = data;\r\nint i;\r\nlist->nr = le32_to_cpu(list->nr);\r\nfor (i = 0; i < list->nr; i++)\r\nmgt_le_to_cpu(OID_TYPE_BSS, &list->bsslist[i]);\r\nbreak;\r\n}\r\ncase OID_TYPE_FREQUENCIES:{\r\nstruct obj_frequencies *freq = data;\r\nint i;\r\nfreq->nr = le16_to_cpu(freq->nr);\r\nfor (i = 0; i < freq->nr; i++)\r\nfreq->mhz[i] = le16_to_cpu(freq->mhz[i]);\r\nbreak;\r\n}\r\ncase OID_TYPE_MLME:{\r\nstruct obj_mlme *mlme = data;\r\nmlme->id = le16_to_cpu(mlme->id);\r\nmlme->state = le16_to_cpu(mlme->state);\r\nmlme->code = le16_to_cpu(mlme->code);\r\nbreak;\r\n}\r\ncase OID_TYPE_MLMEEX:{\r\nstruct obj_mlmeex *mlme = data;\r\nmlme->id = le16_to_cpu(mlme->id);\r\nmlme->state = le16_to_cpu(mlme->state);\r\nmlme->code = le16_to_cpu(mlme->code);\r\nmlme->size = le16_to_cpu(mlme->size);\r\nbreak;\r\n}\r\ncase OID_TYPE_ATTACH:{\r\nstruct obj_attachment *attach = data;\r\nattach->id = le16_to_cpu(attach->id);\r\nattach->size = le16_to_cpu(attach->size);\r\nbreak;\r\n}\r\ncase OID_TYPE_SSID:\r\ncase OID_TYPE_KEY:\r\ncase OID_TYPE_ADDR:\r\ncase OID_TYPE_RAW:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void\r\nmgt_cpu_to_le(int type, void *data)\r\n{\r\nswitch (type) {\r\ncase OID_TYPE_U32:\r\n*(u32 *) data = cpu_to_le32(*(u32 *) data);\r\nbreak;\r\ncase OID_TYPE_BUFFER:{\r\nstruct obj_buffer *buff = data;\r\nbuff->size = cpu_to_le32(buff->size);\r\nbuff->addr = cpu_to_le32(buff->addr);\r\nbreak;\r\n}\r\ncase OID_TYPE_BSS:{\r\nstruct obj_bss *bss = data;\r\nbss->age = cpu_to_le16(bss->age);\r\nbss->channel = cpu_to_le16(bss->channel);\r\nbss->capinfo = cpu_to_le16(bss->capinfo);\r\nbss->rates = cpu_to_le16(bss->rates);\r\nbss->basic_rates = cpu_to_le16(bss->basic_rates);\r\nbreak;\r\n}\r\ncase OID_TYPE_BSSLIST:{\r\nstruct obj_bsslist *list = data;\r\nint i;\r\nlist->nr = cpu_to_le32(list->nr);\r\nfor (i = 0; i < list->nr; i++)\r\nmgt_cpu_to_le(OID_TYPE_BSS, &list->bsslist[i]);\r\nbreak;\r\n}\r\ncase OID_TYPE_FREQUENCIES:{\r\nstruct obj_frequencies *freq = data;\r\nint i;\r\nfreq->nr = cpu_to_le16(freq->nr);\r\nfor (i = 0; i < freq->nr; i++)\r\nfreq->mhz[i] = cpu_to_le16(freq->mhz[i]);\r\nbreak;\r\n}\r\ncase OID_TYPE_MLME:{\r\nstruct obj_mlme *mlme = data;\r\nmlme->id = cpu_to_le16(mlme->id);\r\nmlme->state = cpu_to_le16(mlme->state);\r\nmlme->code = cpu_to_le16(mlme->code);\r\nbreak;\r\n}\r\ncase OID_TYPE_MLMEEX:{\r\nstruct obj_mlmeex *mlme = data;\r\nmlme->id = cpu_to_le16(mlme->id);\r\nmlme->state = cpu_to_le16(mlme->state);\r\nmlme->code = cpu_to_le16(mlme->code);\r\nmlme->size = cpu_to_le16(mlme->size);\r\nbreak;\r\n}\r\ncase OID_TYPE_ATTACH:{\r\nstruct obj_attachment *attach = data;\r\nattach->id = cpu_to_le16(attach->id);\r\nattach->size = cpu_to_le16(attach->size);\r\nbreak;\r\n}\r\ncase OID_TYPE_SSID:\r\ncase OID_TYPE_KEY:\r\ncase OID_TYPE_ADDR:\r\ncase OID_TYPE_RAW:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nint\r\nmgt_set_request(islpci_private *priv, enum oid_num_t n, int extra, void *data)\r\n{\r\nint ret = 0;\r\nstruct islpci_mgmtframe *response = NULL;\r\nint response_op = PIMFOR_OP_ERROR;\r\nint dlen;\r\nvoid *cache, *_data = data;\r\nu32 oid;\r\nBUG_ON(OID_NUM_LAST <= n);\r\nBUG_ON(extra > isl_oid[n].range);\r\nif (!priv->mib)\r\nreturn -1;\r\ndlen = isl_oid[n].size;\r\ncache = priv->mib[n];\r\ncache += (cache ? extra * dlen : 0);\r\noid = isl_oid[n].oid + extra;\r\nif (_data == NULL)\r\n_data = cache;\r\nelse\r\nmgt_cpu_to_le(isl_oid[n].flags & OID_FLAG_TYPE, _data);\r\nif (cache)\r\ndown_write(&priv->mib_sem);\r\nif (islpci_get_state(priv) >= PRV_STATE_READY) {\r\nret = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET, oid,\r\n_data, dlen, &response);\r\nif (!ret) {\r\nresponse_op = response->header->operation;\r\nislpci_mgt_release(response);\r\n}\r\nif (ret || response_op == PIMFOR_OP_ERROR)\r\nret = -EIO;\r\n} else if (!cache)\r\nret = -EIO;\r\nif (cache) {\r\nif (!ret && data)\r\nmemcpy(cache, _data, dlen);\r\nup_write(&priv->mib_sem);\r\n}\r\nif (data)\r\nmgt_le_to_cpu(isl_oid[n].flags & OID_FLAG_TYPE, data);\r\nreturn ret;\r\n}\r\nint\r\nmgt_set_varlen(islpci_private *priv, enum oid_num_t n, void *data, int extra_len)\r\n{\r\nint ret = 0;\r\nstruct islpci_mgmtframe *response;\r\nint response_op = PIMFOR_OP_ERROR;\r\nint dlen;\r\nu32 oid;\r\nBUG_ON(OID_NUM_LAST <= n);\r\ndlen = isl_oid[n].size;\r\noid = isl_oid[n].oid;\r\nmgt_cpu_to_le(isl_oid[n].flags & OID_FLAG_TYPE, data);\r\nif (islpci_get_state(priv) >= PRV_STATE_READY) {\r\nret = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET, oid,\r\ndata, dlen + extra_len, &response);\r\nif (!ret) {\r\nresponse_op = response->header->operation;\r\nislpci_mgt_release(response);\r\n}\r\nif (ret || response_op == PIMFOR_OP_ERROR)\r\nret = -EIO;\r\n} else\r\nret = -EIO;\r\nif (data)\r\nmgt_le_to_cpu(isl_oid[n].flags & OID_FLAG_TYPE, data);\r\nreturn ret;\r\n}\r\nint\r\nmgt_get_request(islpci_private *priv, enum oid_num_t n, int extra, void *data,\r\nunion oid_res_t *res)\r\n{\r\nint ret = -EIO;\r\nint reslen = 0;\r\nstruct islpci_mgmtframe *response = NULL;\r\nint dlen;\r\nvoid *cache, *_res = NULL;\r\nu32 oid;\r\nBUG_ON(OID_NUM_LAST <= n);\r\nBUG_ON(extra > isl_oid[n].range);\r\nres->ptr = NULL;\r\nif (!priv->mib)\r\nreturn -1;\r\ndlen = isl_oid[n].size;\r\ncache = priv->mib[n];\r\ncache += cache ? extra * dlen : 0;\r\noid = isl_oid[n].oid + extra;\r\nreslen = dlen;\r\nif (cache)\r\ndown_read(&priv->mib_sem);\r\nif (islpci_get_state(priv) >= PRV_STATE_READY) {\r\nret = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_GET,\r\noid, data, dlen, &response);\r\nif (ret || !response ||\r\nresponse->header->operation == PIMFOR_OP_ERROR) {\r\nif (response)\r\nislpci_mgt_release(response);\r\nret = -EIO;\r\n}\r\nif (!ret) {\r\n_res = response->data;\r\nreslen = response->header->length;\r\n}\r\n} else if (cache) {\r\n_res = cache;\r\nret = 0;\r\n}\r\nif ((isl_oid[n].flags & OID_FLAG_TYPE) == OID_TYPE_U32)\r\nres->u = ret ? 0 : le32_to_cpu(*(u32 *) _res);\r\nelse {\r\nres->ptr = kmalloc(reslen, GFP_KERNEL);\r\nBUG_ON(res->ptr == NULL);\r\nif (ret)\r\nmemset(res->ptr, 0, reslen);\r\nelse {\r\nmemcpy(res->ptr, _res, reslen);\r\nmgt_le_to_cpu(isl_oid[n].flags & OID_FLAG_TYPE,\r\nres->ptr);\r\n}\r\n}\r\nif (cache)\r\nup_read(&priv->mib_sem);\r\nif (response && !ret)\r\nislpci_mgt_release(response);\r\nif (reslen > isl_oid[n].size)\r\nprintk(KERN_DEBUG\r\n"mgt_get_request(0x%x): received data length was bigger "\r\n"than expected (%d > %d). Memory is probably corrupted...",\r\noid, reslen, isl_oid[n].size);\r\nreturn ret;\r\n}\r\nint\r\nmgt_commit_list(islpci_private *priv, enum oid_num_t *l, int n)\r\n{\r\nint i, ret = 0;\r\nstruct islpci_mgmtframe *response;\r\nfor (i = 0; i < n; i++) {\r\nstruct oid_t *t = &(isl_oid[l[i]]);\r\nvoid *data = priv->mib[l[i]];\r\nint j = 0;\r\nu32 oid = t->oid;\r\nBUG_ON(data == NULL);\r\nwhile (j <= t->range) {\r\nint r = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET,\r\noid, data, t->size,\r\n&response);\r\nif (response) {\r\nr |= (response->header->operation == PIMFOR_OP_ERROR);\r\nislpci_mgt_release(response);\r\n}\r\nif (r)\r\nprintk(KERN_ERR "%s: mgt_commit_list: failure. "\r\n"oid=%08x err=%d\n",\r\npriv->ndev->name, oid, r);\r\nret |= r;\r\nj++;\r\noid++;\r\ndata += t->size;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nmgt_set(islpci_private *priv, enum oid_num_t n, void *data)\r\n{\r\nBUG_ON(OID_NUM_LAST <= n);\r\nBUG_ON(priv->mib[n] == NULL);\r\nmemcpy(priv->mib[n], data, isl_oid[n].size);\r\nmgt_cpu_to_le(isl_oid[n].flags & OID_FLAG_TYPE, priv->mib[n]);\r\n}\r\nvoid\r\nmgt_get(islpci_private *priv, enum oid_num_t n, void *res)\r\n{\r\nBUG_ON(OID_NUM_LAST <= n);\r\nBUG_ON(priv->mib[n] == NULL);\r\nBUG_ON(res == NULL);\r\nmemcpy(res, priv->mib[n], isl_oid[n].size);\r\nmgt_le_to_cpu(isl_oid[n].flags & OID_FLAG_TYPE, res);\r\n}\r\nstatic int\r\nmgt_update_addr(islpci_private *priv)\r\n{\r\nstruct islpci_mgmtframe *res;\r\nint ret;\r\nret = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_GET,\r\nisl_oid[GEN_OID_MACADDRESS].oid, NULL,\r\nisl_oid[GEN_OID_MACADDRESS].size, &res);\r\nif ((ret == 0) && res && (res->header->operation != PIMFOR_OP_ERROR))\r\nmemcpy(priv->ndev->dev_addr, res->data, ETH_ALEN);\r\nelse\r\nret = -EIO;\r\nif (res)\r\nislpci_mgt_release(res);\r\nif (ret)\r\nprintk(KERN_ERR "%s: mgt_update_addr: failure\n", priv->ndev->name);\r\nreturn ret;\r\n}\r\nint\r\nmgt_commit(islpci_private *priv)\r\n{\r\nint rvalue;\r\nenum oid_num_t u;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\nrvalue = mgt_commit_list(priv, commit_part1, ARRAY_SIZE(commit_part1));\r\nif (priv->iw_mode != IW_MODE_MONITOR)\r\nrvalue |= mgt_commit_list(priv, commit_part2, ARRAY_SIZE(commit_part2));\r\nu = OID_INL_MODE;\r\nrvalue |= mgt_commit_list(priv, &u, 1);\r\nrvalue |= mgt_update_addr(priv);\r\nif (rvalue) {\r\nprintk(KERN_DEBUG "%s: mgt_commit: failure\n", priv->ndev->name);\r\n}\r\nreturn rvalue;\r\n}\r\nint\r\nmgt_mlme_answer(islpci_private *priv)\r\n{\r\nu32 mlmeautolevel;\r\ndown_read(&priv->mib_sem);\r\nmlmeautolevel =\r\nle32_to_cpu(*(u32 *) priv->mib[DOT11_OID_MLMEAUTOLEVEL]);\r\nup_read(&priv->mib_sem);\r\nreturn ((priv->iw_mode == IW_MODE_MASTER) &&\r\n(mlmeautolevel >= DOT11_MLME_INTERMEDIATE));\r\n}\r\nenum oid_num_t\r\nmgt_oidtonum(u32 oid)\r\n{\r\nint i;\r\nfor (i = 0; i < OID_NUM_LAST; i++)\r\nif (isl_oid[i].oid == oid)\r\nreturn i;\r\nprintk(KERN_DEBUG "looking for an unknown oid 0x%x", oid);\r\nreturn OID_NUM_LAST;\r\n}\r\nint\r\nmgt_response_to_str(enum oid_num_t n, union oid_res_t *r, char *str)\r\n{\r\nswitch (isl_oid[n].flags & OID_FLAG_TYPE) {\r\ncase OID_TYPE_U32:\r\nreturn snprintf(str, PRIV_STR_SIZE, "%u\n", r->u);\r\ncase OID_TYPE_BUFFER:{\r\nstruct obj_buffer *buff = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"size=%u\naddr=0x%X\n", buff->size,\r\nbuff->addr);\r\n}\r\nbreak;\r\ncase OID_TYPE_BSS:{\r\nstruct obj_bss *bss = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"age=%u\nchannel=%u\n"\r\n"capinfo=0x%X\nrates=0x%X\n"\r\n"basic_rates=0x%X\n", bss->age,\r\nbss->channel, bss->capinfo,\r\nbss->rates, bss->basic_rates);\r\n}\r\nbreak;\r\ncase OID_TYPE_BSSLIST:{\r\nstruct obj_bsslist *list = r->ptr;\r\nint i, k;\r\nk = snprintf(str, PRIV_STR_SIZE, "nr=%u\n", list->nr);\r\nfor (i = 0; i < list->nr; i++)\r\nk += snprintf(str + k, PRIV_STR_SIZE - k,\r\n"bss[%u] :\nage=%u\nchannel=%u\n"\r\n"capinfo=0x%X\nrates=0x%X\n"\r\n"basic_rates=0x%X\n",\r\ni, list->bsslist[i].age,\r\nlist->bsslist[i].channel,\r\nlist->bsslist[i].capinfo,\r\nlist->bsslist[i].rates,\r\nlist->bsslist[i].basic_rates);\r\nreturn k;\r\n}\r\nbreak;\r\ncase OID_TYPE_FREQUENCIES:{\r\nstruct obj_frequencies *freq = r->ptr;\r\nint i, t;\r\nprintk("nr : %u\n", freq->nr);\r\nt = snprintf(str, PRIV_STR_SIZE, "nr=%u\n", freq->nr);\r\nfor (i = 0; i < freq->nr; i++)\r\nt += snprintf(str + t, PRIV_STR_SIZE - t,\r\n"mhz[%u]=%u\n", i, freq->mhz[i]);\r\nreturn t;\r\n}\r\nbreak;\r\ncase OID_TYPE_MLME:{\r\nstruct obj_mlme *mlme = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"id=0x%X\nstate=0x%X\ncode=0x%X\n",\r\nmlme->id, mlme->state, mlme->code);\r\n}\r\nbreak;\r\ncase OID_TYPE_MLMEEX:{\r\nstruct obj_mlmeex *mlme = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"id=0x%X\nstate=0x%X\n"\r\n"code=0x%X\nsize=0x%X\n", mlme->id,\r\nmlme->state, mlme->code, mlme->size);\r\n}\r\nbreak;\r\ncase OID_TYPE_ATTACH:{\r\nstruct obj_attachment *attach = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"id=%d\nsize=%d\n",\r\nattach->id,\r\nattach->size);\r\n}\r\nbreak;\r\ncase OID_TYPE_SSID:{\r\nstruct obj_ssid *ssid = r->ptr;\r\nreturn snprintf(str, PRIV_STR_SIZE,\r\n"length=%u\noctets=%.*s\n",\r\nssid->length, ssid->length,\r\nssid->octets);\r\n}\r\nbreak;\r\ncase OID_TYPE_KEY:{\r\nstruct obj_key *key = r->ptr;\r\nint t, i;\r\nt = snprintf(str, PRIV_STR_SIZE,\r\n"type=0x%X\nlength=0x%X\nkey=0x",\r\nkey->type, key->length);\r\nfor (i = 0; i < key->length; i++)\r\nt += snprintf(str + t, PRIV_STR_SIZE - t,\r\n"%02X:", key->key[i]);\r\nt += snprintf(str + t, PRIV_STR_SIZE - t, "\n");\r\nreturn t;\r\n}\r\nbreak;\r\ncase OID_TYPE_RAW:\r\ncase OID_TYPE_ADDR:{\r\nunsigned char *buff = r->ptr;\r\nint t, i;\r\nt = snprintf(str, PRIV_STR_SIZE, "hex data=");\r\nfor (i = 0; i < isl_oid[n].size; i++)\r\nt += snprintf(str + t, PRIV_STR_SIZE - t,\r\n"%02X:", buff[i]);\r\nt += snprintf(str + t, PRIV_STR_SIZE - t, "\n");\r\nreturn t;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}
