static bool ip_exceeds_mtu(const struct sk_buff *skb, unsigned int mtu)\r\n{\r\nif (skb->len <= mtu)\r\nreturn false;\r\nif (unlikely((ip_hdr(skb)->frag_off & htons(IP_DF)) == 0))\r\nreturn false;\r\nif (unlikely(IPCB(skb)->frag_max_size > mtu))\r\nreturn true;\r\nif (skb->ignore_df)\r\nreturn false;\r\nif (skb_is_gso(skb) && skb_gso_network_seglen(skb) <= mtu)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int ip_forward_finish(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ip_options *opt = &(IPCB(skb)->opt);\r\nIP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTFORWDATAGRAMS);\r\nIP_ADD_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTOCTETS, skb->len);\r\nif (unlikely(opt->optlen))\r\nip_forward_options(skb);\r\nskb_sender_cpu_clear(skb);\r\nreturn dst_output_sk(sk, skb);\r\n}\r\nint ip_forward(struct sk_buff *skb)\r\n{\r\nu32 mtu;\r\nstruct iphdr *iph;\r\nstruct rtable *rt;\r\nstruct ip_options *opt = &(IPCB(skb)->opt);\r\nif (skb->pkt_type != PACKET_HOST)\r\ngoto drop;\r\nif (unlikely(skb->sk))\r\ngoto drop;\r\nif (skb_warn_if_lro(skb))\r\ngoto drop;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))\r\ngoto drop;\r\nif (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))\r\nreturn NET_RX_SUCCESS;\r\nskb_forward_csum(skb);\r\nif (ip_hdr(skb)->ttl <= 1)\r\ngoto too_many_hops;\r\nif (!xfrm4_route_forward(skb))\r\ngoto drop;\r\nrt = skb_rtable(skb);\r\nif (opt->is_strictroute && rt->rt_uses_gateway)\r\ngoto sr_failed;\r\nIPCB(skb)->flags |= IPSKB_FORWARDED;\r\nmtu = ip_dst_mtu_maybe_forward(&rt->dst, true);\r\nif (ip_exceeds_mtu(skb, mtu)) {\r\nIP_INC_STATS(dev_net(rt->dst.dev), IPSTATS_MIB_FRAGFAILS);\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\r\nhtonl(mtu));\r\ngoto drop;\r\n}\r\nif (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))\r\ngoto drop;\r\niph = ip_hdr(skb);\r\nip_decrease_ttl(iph);\r\nif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\r\n!skb_sec_path(skb))\r\nip_rt_send_redirect(skb);\r\nskb->priority = rt_tos2priority(iph->tos);\r\nreturn NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, NULL, skb,\r\nskb->dev, rt->dst.dev, ip_forward_finish);\r\nsr_failed:\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);\r\ngoto drop;\r\ntoo_many_hops:\r\nIP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_INHDRERRORS);\r\nicmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}
