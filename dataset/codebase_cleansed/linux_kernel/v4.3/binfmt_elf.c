static int set_brk(unsigned long start, unsigned long end)\r\n{\r\nstart = ELF_PAGEALIGN(start);\r\nend = ELF_PAGEALIGN(end);\r\nif (end > start) {\r\nunsigned long addr;\r\naddr = vm_brk(start, end - start);\r\nif (BAD_ADDR(addr))\r\nreturn addr;\r\n}\r\ncurrent->mm->start_brk = current->mm->brk = end;\r\nreturn 0;\r\n}\r\nstatic int padzero(unsigned long elf_bss)\r\n{\r\nunsigned long nbyte;\r\nnbyte = ELF_PAGEOFFSET(elf_bss);\r\nif (nbyte) {\r\nnbyte = ELF_MIN_ALIGN - nbyte;\r\nif (clear_user((void __user *) elf_bss, nbyte))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\r\nunsigned long load_addr, unsigned long interp_load_addr)\r\n{\r\nunsigned long p = bprm->p;\r\nint argc = bprm->argc;\r\nint envc = bprm->envc;\r\nelf_addr_t __user *argv;\r\nelf_addr_t __user *envp;\r\nelf_addr_t __user *sp;\r\nelf_addr_t __user *u_platform;\r\nelf_addr_t __user *u_base_platform;\r\nelf_addr_t __user *u_rand_bytes;\r\nconst char *k_platform = ELF_PLATFORM;\r\nconst char *k_base_platform = ELF_BASE_PLATFORM;\r\nunsigned char k_rand_bytes[16];\r\nint items;\r\nelf_addr_t *elf_info;\r\nint ei_index = 0;\r\nconst struct cred *cred = current_cred();\r\nstruct vm_area_struct *vma;\r\np = arch_align_stack(p);\r\nu_platform = NULL;\r\nif (k_platform) {\r\nsize_t len = strlen(k_platform) + 1;\r\nu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\r\nif (__copy_to_user(u_platform, k_platform, len))\r\nreturn -EFAULT;\r\n}\r\nu_base_platform = NULL;\r\nif (k_base_platform) {\r\nsize_t len = strlen(k_base_platform) + 1;\r\nu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\r\nif (__copy_to_user(u_base_platform, k_base_platform, len))\r\nreturn -EFAULT;\r\n}\r\nget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\r\nu_rand_bytes = (elf_addr_t __user *)\r\nSTACK_ALLOC(p, sizeof(k_rand_bytes));\r\nif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\r\nreturn -EFAULT;\r\nelf_info = (elf_addr_t *)current->mm->saved_auxv;\r\n#define NEW_AUX_ENT(id, val) \\r\ndo { \\r\nelf_info[ei_index++] = id; \\r\nelf_info[ei_index++] = val; \\r\n} while (0)\r\n#ifdef ARCH_DLINFO\r\nARCH_DLINFO;\r\n#endif\r\nNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\r\nNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\r\nNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\r\nNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\r\nNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\r\nNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\r\nNEW_AUX_ENT(AT_BASE, interp_load_addr);\r\nNEW_AUX_ENT(AT_FLAGS, 0);\r\nNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\r\nNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\r\nNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\r\nNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\r\nNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\r\nNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\r\nNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\r\n#ifdef ELF_HWCAP2\r\nNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\r\n#endif\r\nNEW_AUX_ENT(AT_EXECFN, bprm->exec);\r\nif (k_platform) {\r\nNEW_AUX_ENT(AT_PLATFORM,\r\n(elf_addr_t)(unsigned long)u_platform);\r\n}\r\nif (k_base_platform) {\r\nNEW_AUX_ENT(AT_BASE_PLATFORM,\r\n(elf_addr_t)(unsigned long)u_base_platform);\r\n}\r\nif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\r\nNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\r\n}\r\n#undef NEW_AUX_ENT\r\nmemset(&elf_info[ei_index], 0,\r\nsizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\r\nei_index += 2;\r\nsp = STACK_ADD(p, ei_index);\r\nitems = (argc + 1) + (envc + 1) + 1;\r\nbprm->p = STACK_ROUND(sp, items);\r\n#ifdef CONFIG_STACK_GROWSUP\r\nsp = (elf_addr_t __user *)bprm->p - items - ei_index;\r\nbprm->exec = (unsigned long)sp;\r\n#else\r\nsp = (elf_addr_t __user *)bprm->p;\r\n#endif\r\nvma = find_extend_vma(current->mm, bprm->p);\r\nif (!vma)\r\nreturn -EFAULT;\r\nif (__put_user(argc, sp++))\r\nreturn -EFAULT;\r\nargv = sp;\r\nenvp = argv + argc + 1;\r\np = current->mm->arg_end = current->mm->arg_start;\r\nwhile (argc-- > 0) {\r\nsize_t len;\r\nif (__put_user((elf_addr_t)p, argv++))\r\nreturn -EFAULT;\r\nlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\nif (__put_user(0, argv))\r\nreturn -EFAULT;\r\ncurrent->mm->arg_end = current->mm->env_start = p;\r\nwhile (envc-- > 0) {\r\nsize_t len;\r\nif (__put_user((elf_addr_t)p, envp++))\r\nreturn -EFAULT;\r\nlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\nif (__put_user(0, envp))\r\nreturn -EFAULT;\r\ncurrent->mm->env_end = p;\r\nsp = (elf_addr_t __user *)envp + 1;\r\nif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\r\nstruct elf_phdr *eppnt, int prot, int type,\r\nunsigned long total_size)\r\n{\r\nunsigned long map_addr;\r\nunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\r\nunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\r\naddr = ELF_PAGESTART(addr);\r\nsize = ELF_PAGEALIGN(size);\r\nif (!size)\r\nreturn addr;\r\nif (total_size) {\r\ntotal_size = ELF_PAGEALIGN(total_size);\r\nmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\r\nif (!BAD_ADDR(map_addr))\r\nvm_munmap(map_addr+size, total_size-size);\r\n} else\r\nmap_addr = vm_mmap(filep, addr, size, prot, type, off);\r\nreturn(map_addr);\r\n}\r\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\r\n{\r\nint i, first_idx = -1, last_idx = -1;\r\nfor (i = 0; i < nr; i++) {\r\nif (cmds[i].p_type == PT_LOAD) {\r\nlast_idx = i;\r\nif (first_idx == -1)\r\nfirst_idx = i;\r\n}\r\n}\r\nif (first_idx == -1)\r\nreturn 0;\r\nreturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\r\nELF_PAGESTART(cmds[first_idx].p_vaddr);\r\n}\r\nstatic struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\r\nstruct file *elf_file)\r\n{\r\nstruct elf_phdr *elf_phdata = NULL;\r\nint retval, size, err = -1;\r\nif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\r\ngoto out;\r\nif (elf_ex->e_phnum < 1 ||\r\nelf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\r\ngoto out;\r\nsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\r\nif (size > ELF_MIN_ALIGN)\r\ngoto out;\r\nelf_phdata = kmalloc(size, GFP_KERNEL);\r\nif (!elf_phdata)\r\ngoto out;\r\nretval = kernel_read(elf_file, elf_ex->e_phoff,\r\n(char *)elf_phdata, size);\r\nif (retval != size) {\r\nerr = (retval < 0) ? retval : -EIO;\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nif (err) {\r\nkfree(elf_phdata);\r\nelf_phdata = NULL;\r\n}\r\nreturn elf_phdata;\r\n}\r\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\r\nstruct elf_phdr *phdr,\r\nstruct file *elf, bool is_interp,\r\nstruct arch_elf_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\r\nstruct arch_elf_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\r\nstruct file *interpreter, unsigned long *interp_map_addr,\r\nunsigned long no_base, struct elf_phdr *interp_elf_phdata)\r\n{\r\nstruct elf_phdr *eppnt;\r\nunsigned long load_addr = 0;\r\nint load_addr_set = 0;\r\nunsigned long last_bss = 0, elf_bss = 0;\r\nunsigned long error = ~0UL;\r\nunsigned long total_size;\r\nint i;\r\nif (interp_elf_ex->e_type != ET_EXEC &&\r\ninterp_elf_ex->e_type != ET_DYN)\r\ngoto out;\r\nif (!elf_check_arch(interp_elf_ex))\r\ngoto out;\r\nif (!interpreter->f_op->mmap)\r\ngoto out;\r\ntotal_size = total_mapping_size(interp_elf_phdata,\r\ninterp_elf_ex->e_phnum);\r\nif (!total_size) {\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\neppnt = interp_elf_phdata;\r\nfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\r\nif (eppnt->p_type == PT_LOAD) {\r\nint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\r\nint elf_prot = 0;\r\nunsigned long vaddr = 0;\r\nunsigned long k, map_addr;\r\nif (eppnt->p_flags & PF_R)\r\nelf_prot = PROT_READ;\r\nif (eppnt->p_flags & PF_W)\r\nelf_prot |= PROT_WRITE;\r\nif (eppnt->p_flags & PF_X)\r\nelf_prot |= PROT_EXEC;\r\nvaddr = eppnt->p_vaddr;\r\nif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\r\nelf_type |= MAP_FIXED;\r\nelse if (no_base && interp_elf_ex->e_type == ET_DYN)\r\nload_addr = -vaddr;\r\nmap_addr = elf_map(interpreter, load_addr + vaddr,\r\neppnt, elf_prot, elf_type, total_size);\r\ntotal_size = 0;\r\nif (!*interp_map_addr)\r\n*interp_map_addr = map_addr;\r\nerror = map_addr;\r\nif (BAD_ADDR(map_addr))\r\ngoto out;\r\nif (!load_addr_set &&\r\ninterp_elf_ex->e_type == ET_DYN) {\r\nload_addr = map_addr - ELF_PAGESTART(vaddr);\r\nload_addr_set = 1;\r\n}\r\nk = load_addr + eppnt->p_vaddr;\r\nif (BAD_ADDR(k) ||\r\neppnt->p_filesz > eppnt->p_memsz ||\r\neppnt->p_memsz > TASK_SIZE ||\r\nTASK_SIZE - eppnt->p_memsz < k) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\r\nif (k > elf_bss)\r\nelf_bss = k;\r\nk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\r\nif (k > last_bss)\r\nlast_bss = k;\r\n}\r\n}\r\nif (last_bss > elf_bss) {\r\nif (padzero(elf_bss)) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\nelf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\r\nerror = vm_brk(elf_bss, last_bss - elf_bss);\r\nif (BAD_ADDR(error))\r\ngoto out;\r\n}\r\nerror = load_addr;\r\nout:\r\nreturn error;\r\n}\r\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\r\n{\r\nunsigned long random_variable = 0;\r\nif ((current->flags & PF_RANDOMIZE) &&\r\n!(current->personality & ADDR_NO_RANDOMIZE)) {\r\nrandom_variable = (unsigned long) get_random_int();\r\nrandom_variable &= STACK_RND_MASK;\r\nrandom_variable <<= PAGE_SHIFT;\r\n}\r\n#ifdef CONFIG_STACK_GROWSUP\r\nreturn PAGE_ALIGN(stack_top) + random_variable;\r\n#else\r\nreturn PAGE_ALIGN(stack_top) - random_variable;\r\n#endif\r\n}\r\nstatic int load_elf_binary(struct linux_binprm *bprm)\r\n{\r\nstruct file *interpreter = NULL;\r\nunsigned long load_addr = 0, load_bias = 0;\r\nint load_addr_set = 0;\r\nchar * elf_interpreter = NULL;\r\nunsigned long error;\r\nstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\r\nunsigned long elf_bss, elf_brk;\r\nint retval, i;\r\nunsigned long elf_entry;\r\nunsigned long interp_load_addr = 0;\r\nunsigned long start_code, end_code, start_data, end_data;\r\nunsigned long reloc_func_desc __maybe_unused = 0;\r\nint executable_stack = EXSTACK_DEFAULT;\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct {\r\nstruct elfhdr elf_ex;\r\nstruct elfhdr interp_elf_ex;\r\n} *loc;\r\nstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\r\nloc = kmalloc(sizeof(*loc), GFP_KERNEL);\r\nif (!loc) {\r\nretval = -ENOMEM;\r\ngoto out_ret;\r\n}\r\nloc->elf_ex = *((struct elfhdr *)bprm->buf);\r\nretval = -ENOEXEC;\r\nif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\r\ngoto out;\r\nif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\r\ngoto out;\r\nif (!elf_check_arch(&loc->elf_ex))\r\ngoto out;\r\nif (!bprm->file->f_op->mmap)\r\ngoto out;\r\nelf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\r\nif (!elf_phdata)\r\ngoto out;\r\nelf_ppnt = elf_phdata;\r\nelf_bss = 0;\r\nelf_brk = 0;\r\nstart_code = ~0UL;\r\nend_code = 0;\r\nstart_data = 0;\r\nend_data = 0;\r\nfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\r\nif (elf_ppnt->p_type == PT_INTERP) {\r\nretval = -ENOEXEC;\r\nif (elf_ppnt->p_filesz > PATH_MAX ||\r\nelf_ppnt->p_filesz < 2)\r\ngoto out_free_ph;\r\nretval = -ENOMEM;\r\nelf_interpreter = kmalloc(elf_ppnt->p_filesz,\r\nGFP_KERNEL);\r\nif (!elf_interpreter)\r\ngoto out_free_ph;\r\nretval = kernel_read(bprm->file, elf_ppnt->p_offset,\r\nelf_interpreter,\r\nelf_ppnt->p_filesz);\r\nif (retval != elf_ppnt->p_filesz) {\r\nif (retval >= 0)\r\nretval = -EIO;\r\ngoto out_free_interp;\r\n}\r\nretval = -ENOEXEC;\r\nif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\0')\r\ngoto out_free_interp;\r\ninterpreter = open_exec(elf_interpreter);\r\nretval = PTR_ERR(interpreter);\r\nif (IS_ERR(interpreter))\r\ngoto out_free_interp;\r\nwould_dump(bprm, interpreter);\r\nretval = kernel_read(interpreter, 0, bprm->buf,\r\nBINPRM_BUF_SIZE);\r\nif (retval != BINPRM_BUF_SIZE) {\r\nif (retval >= 0)\r\nretval = -EIO;\r\ngoto out_free_dentry;\r\n}\r\nloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\r\nbreak;\r\n}\r\nelf_ppnt++;\r\n}\r\nelf_ppnt = elf_phdata;\r\nfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\r\nswitch (elf_ppnt->p_type) {\r\ncase PT_GNU_STACK:\r\nif (elf_ppnt->p_flags & PF_X)\r\nexecutable_stack = EXSTACK_ENABLE_X;\r\nelse\r\nexecutable_stack = EXSTACK_DISABLE_X;\r\nbreak;\r\ncase PT_LOPROC ... PT_HIPROC:\r\nretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\r\nbprm->file, false,\r\n&arch_state);\r\nif (retval)\r\ngoto out_free_dentry;\r\nbreak;\r\n}\r\nif (elf_interpreter) {\r\nretval = -ELIBBAD;\r\nif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\r\ngoto out_free_dentry;\r\nif (!elf_check_arch(&loc->interp_elf_ex))\r\ngoto out_free_dentry;\r\ninterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\r\ninterpreter);\r\nif (!interp_elf_phdata)\r\ngoto out_free_dentry;\r\nelf_ppnt = interp_elf_phdata;\r\nfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\r\nswitch (elf_ppnt->p_type) {\r\ncase PT_LOPROC ... PT_HIPROC:\r\nretval = arch_elf_pt_proc(&loc->interp_elf_ex,\r\nelf_ppnt, interpreter,\r\ntrue, &arch_state);\r\nif (retval)\r\ngoto out_free_dentry;\r\nbreak;\r\n}\r\n}\r\nretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\r\nif (retval)\r\ngoto out_free_dentry;\r\nretval = flush_old_exec(bprm);\r\nif (retval)\r\ngoto out_free_dentry;\r\nSET_PERSONALITY2(loc->elf_ex, &arch_state);\r\nif (elf_read_implies_exec(loc->elf_ex, executable_stack))\r\ncurrent->personality |= READ_IMPLIES_EXEC;\r\nif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\r\ncurrent->flags |= PF_RANDOMIZE;\r\nsetup_new_exec(bprm);\r\nretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\r\nexecutable_stack);\r\nif (retval < 0)\r\ngoto out_free_dentry;\r\ncurrent->mm->start_stack = bprm->p;\r\nfor(i = 0, elf_ppnt = elf_phdata;\r\ni < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\r\nint elf_prot = 0, elf_flags;\r\nunsigned long k, vaddr;\r\nunsigned long total_size = 0;\r\nif (elf_ppnt->p_type != PT_LOAD)\r\ncontinue;\r\nif (unlikely (elf_brk > elf_bss)) {\r\nunsigned long nbyte;\r\nretval = set_brk(elf_bss + load_bias,\r\nelf_brk + load_bias);\r\nif (retval)\r\ngoto out_free_dentry;\r\nnbyte = ELF_PAGEOFFSET(elf_bss);\r\nif (nbyte) {\r\nnbyte = ELF_MIN_ALIGN - nbyte;\r\nif (nbyte > elf_brk - elf_bss)\r\nnbyte = elf_brk - elf_bss;\r\nif (clear_user((void __user *)elf_bss +\r\nload_bias, nbyte)) {\r\n}\r\n}\r\n}\r\nif (elf_ppnt->p_flags & PF_R)\r\nelf_prot |= PROT_READ;\r\nif (elf_ppnt->p_flags & PF_W)\r\nelf_prot |= PROT_WRITE;\r\nif (elf_ppnt->p_flags & PF_X)\r\nelf_prot |= PROT_EXEC;\r\nelf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\r\nvaddr = elf_ppnt->p_vaddr;\r\nif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\r\nelf_flags |= MAP_FIXED;\r\n} else if (loc->elf_ex.e_type == ET_DYN) {\r\nload_bias = ELF_ET_DYN_BASE - vaddr;\r\nif (current->flags & PF_RANDOMIZE)\r\nload_bias += arch_mmap_rnd();\r\nload_bias = ELF_PAGESTART(load_bias);\r\ntotal_size = total_mapping_size(elf_phdata,\r\nloc->elf_ex.e_phnum);\r\nif (!total_size) {\r\nretval = -EINVAL;\r\ngoto out_free_dentry;\r\n}\r\n}\r\nerror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\r\nelf_prot, elf_flags, total_size);\r\nif (BAD_ADDR(error)) {\r\nretval = IS_ERR((void *)error) ?\r\nPTR_ERR((void*)error) : -EINVAL;\r\ngoto out_free_dentry;\r\n}\r\nif (!load_addr_set) {\r\nload_addr_set = 1;\r\nload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\r\nif (loc->elf_ex.e_type == ET_DYN) {\r\nload_bias += error -\r\nELF_PAGESTART(load_bias + vaddr);\r\nload_addr += load_bias;\r\nreloc_func_desc = load_bias;\r\n}\r\n}\r\nk = elf_ppnt->p_vaddr;\r\nif (k < start_code)\r\nstart_code = k;\r\nif (start_data < k)\r\nstart_data = k;\r\nif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\r\nelf_ppnt->p_memsz > TASK_SIZE ||\r\nTASK_SIZE - elf_ppnt->p_memsz < k) {\r\nretval = -EINVAL;\r\ngoto out_free_dentry;\r\n}\r\nk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\r\nif (k > elf_bss)\r\nelf_bss = k;\r\nif ((elf_ppnt->p_flags & PF_X) && end_code < k)\r\nend_code = k;\r\nif (end_data < k)\r\nend_data = k;\r\nk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\r\nif (k > elf_brk)\r\nelf_brk = k;\r\n}\r\nloc->elf_ex.e_entry += load_bias;\r\nelf_bss += load_bias;\r\nelf_brk += load_bias;\r\nstart_code += load_bias;\r\nend_code += load_bias;\r\nstart_data += load_bias;\r\nend_data += load_bias;\r\nretval = set_brk(elf_bss, elf_brk);\r\nif (retval)\r\ngoto out_free_dentry;\r\nif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\r\nretval = -EFAULT;\r\ngoto out_free_dentry;\r\n}\r\nif (elf_interpreter) {\r\nunsigned long interp_map_addr = 0;\r\nelf_entry = load_elf_interp(&loc->interp_elf_ex,\r\ninterpreter,\r\n&interp_map_addr,\r\nload_bias, interp_elf_phdata);\r\nif (!IS_ERR((void *)elf_entry)) {\r\ninterp_load_addr = elf_entry;\r\nelf_entry += loc->interp_elf_ex.e_entry;\r\n}\r\nif (BAD_ADDR(elf_entry)) {\r\nretval = IS_ERR((void *)elf_entry) ?\r\n(int)elf_entry : -EINVAL;\r\ngoto out_free_dentry;\r\n}\r\nreloc_func_desc = interp_load_addr;\r\nallow_write_access(interpreter);\r\nfput(interpreter);\r\nkfree(elf_interpreter);\r\n} else {\r\nelf_entry = loc->elf_ex.e_entry;\r\nif (BAD_ADDR(elf_entry)) {\r\nretval = -EINVAL;\r\ngoto out_free_dentry;\r\n}\r\n}\r\nkfree(interp_elf_phdata);\r\nkfree(elf_phdata);\r\nset_binfmt(&elf_format);\r\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\r\nretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\r\nif (retval < 0)\r\ngoto out;\r\n#endif\r\ninstall_exec_creds(bprm);\r\nretval = create_elf_tables(bprm, &loc->elf_ex,\r\nload_addr, interp_load_addr);\r\nif (retval < 0)\r\ngoto out;\r\ncurrent->mm->end_code = end_code;\r\ncurrent->mm->start_code = start_code;\r\ncurrent->mm->start_data = start_data;\r\ncurrent->mm->end_data = end_data;\r\ncurrent->mm->start_stack = bprm->p;\r\nif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\r\ncurrent->mm->brk = current->mm->start_brk =\r\narch_randomize_brk(current->mm);\r\n#ifdef compat_brk_randomized\r\ncurrent->brk_randomized = 1;\r\n#endif\r\n}\r\nif (current->personality & MMAP_PAGE_ZERO) {\r\nerror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE, 0);\r\n}\r\n#ifdef ELF_PLAT_INIT\r\nELF_PLAT_INIT(regs, reloc_func_desc);\r\n#endif\r\nstart_thread(regs, elf_entry, bprm->p);\r\nretval = 0;\r\nout:\r\nkfree(loc);\r\nout_ret:\r\nreturn retval;\r\nout_free_dentry:\r\nkfree(interp_elf_phdata);\r\nallow_write_access(interpreter);\r\nif (interpreter)\r\nfput(interpreter);\r\nout_free_interp:\r\nkfree(elf_interpreter);\r\nout_free_ph:\r\nkfree(elf_phdata);\r\ngoto out;\r\n}\r\nstatic int load_elf_library(struct file *file)\r\n{\r\nstruct elf_phdr *elf_phdata;\r\nstruct elf_phdr *eppnt;\r\nunsigned long elf_bss, bss, len;\r\nint retval, error, i, j;\r\nstruct elfhdr elf_ex;\r\nerror = -ENOEXEC;\r\nretval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));\r\nif (retval != sizeof(elf_ex))\r\ngoto out;\r\nif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\r\ngoto out;\r\nif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\r\n!elf_check_arch(&elf_ex) || !file->f_op->mmap)\r\ngoto out;\r\nj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\r\nerror = -ENOMEM;\r\nelf_phdata = kmalloc(j, GFP_KERNEL);\r\nif (!elf_phdata)\r\ngoto out;\r\neppnt = elf_phdata;\r\nerror = -ENOEXEC;\r\nretval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);\r\nif (retval != j)\r\ngoto out_free_ph;\r\nfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\r\nif ((eppnt + i)->p_type == PT_LOAD)\r\nj++;\r\nif (j != 1)\r\ngoto out_free_ph;\r\nwhile (eppnt->p_type != PT_LOAD)\r\neppnt++;\r\nerror = vm_mmap(file,\r\nELF_PAGESTART(eppnt->p_vaddr),\r\n(eppnt->p_filesz +\r\nELF_PAGEOFFSET(eppnt->p_vaddr)),\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\r\n(eppnt->p_offset -\r\nELF_PAGEOFFSET(eppnt->p_vaddr)));\r\nif (error != ELF_PAGESTART(eppnt->p_vaddr))\r\ngoto out_free_ph;\r\nelf_bss = eppnt->p_vaddr + eppnt->p_filesz;\r\nif (padzero(elf_bss)) {\r\nerror = -EFAULT;\r\ngoto out_free_ph;\r\n}\r\nlen = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +\r\nELF_MIN_ALIGN - 1);\r\nbss = eppnt->p_memsz + eppnt->p_vaddr;\r\nif (bss > len)\r\nvm_brk(len, bss - len);\r\nerror = 0;\r\nout_free_ph:\r\nkfree(elf_phdata);\r\nout:\r\nreturn error;\r\n}\r\nstatic bool always_dump_vma(struct vm_area_struct *vma)\r\n{\r\nif (vma == get_gate_vma(vma->vm_mm))\r\nreturn true;\r\nif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\r\nreturn true;\r\nif (arch_vma_name(vma))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\r\nunsigned long mm_flags)\r\n{\r\n#define FILTER(type) (mm_flags & (1UL << MMF_DUMP_##type))\r\nif (always_dump_vma(vma))\r\ngoto whole;\r\nif (vma->vm_flags & VM_DONTDUMP)\r\nreturn 0;\r\nif (vma->vm_flags & VM_HUGETLB) {\r\nif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\r\ngoto whole;\r\nif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\r\ngoto whole;\r\nreturn 0;\r\n}\r\nif (vma->vm_flags & VM_IO)\r\nreturn 0;\r\nif (vma->vm_flags & VM_SHARED) {\r\nif (file_inode(vma->vm_file)->i_nlink == 0 ?\r\nFILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\r\ngoto whole;\r\nreturn 0;\r\n}\r\nif (vma->anon_vma && FILTER(ANON_PRIVATE))\r\ngoto whole;\r\nif (vma->vm_file == NULL)\r\nreturn 0;\r\nif (FILTER(MAPPED_PRIVATE))\r\ngoto whole;\r\nif (FILTER(ELF_HEADERS) &&\r\nvma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\r\nu32 __user *header = (u32 __user *) vma->vm_start;\r\nu32 word;\r\nmm_segment_t fs = get_fs();\r\nunion {\r\nu32 cmp;\r\nchar elfmag[SELFMAG];\r\n} magic;\r\nBUILD_BUG_ON(SELFMAG != sizeof word);\r\nmagic.elfmag[EI_MAG0] = ELFMAG0;\r\nmagic.elfmag[EI_MAG1] = ELFMAG1;\r\nmagic.elfmag[EI_MAG2] = ELFMAG2;\r\nmagic.elfmag[EI_MAG3] = ELFMAG3;\r\nset_fs(USER_DS);\r\nif (unlikely(get_user(word, header)))\r\nword = 0;\r\nset_fs(fs);\r\nif (word == magic.cmp)\r\nreturn PAGE_SIZE;\r\n}\r\n#undef FILTER\r\nreturn 0;\r\nwhole:\r\nreturn vma->vm_end - vma->vm_start;\r\n}\r\nstatic int notesize(struct memelfnote *en)\r\n{\r\nint sz;\r\nsz = sizeof(struct elf_note);\r\nsz += roundup(strlen(en->name) + 1, 4);\r\nsz += roundup(en->datasz, 4);\r\nreturn sz;\r\n}\r\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\r\n{\r\nstruct elf_note en;\r\nen.n_namesz = strlen(men->name) + 1;\r\nen.n_descsz = men->datasz;\r\nen.n_type = men->type;\r\nreturn dump_emit(cprm, &en, sizeof(en)) &&\r\ndump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\r\ndump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\r\n}\r\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\r\nu16 machine, u32 flags)\r\n{\r\nmemset(elf, 0, sizeof(*elf));\r\nmemcpy(elf->e_ident, ELFMAG, SELFMAG);\r\nelf->e_ident[EI_CLASS] = ELF_CLASS;\r\nelf->e_ident[EI_DATA] = ELF_DATA;\r\nelf->e_ident[EI_VERSION] = EV_CURRENT;\r\nelf->e_ident[EI_OSABI] = ELF_OSABI;\r\nelf->e_type = ET_CORE;\r\nelf->e_machine = machine;\r\nelf->e_version = EV_CURRENT;\r\nelf->e_phoff = sizeof(struct elfhdr);\r\nelf->e_flags = flags;\r\nelf->e_ehsize = sizeof(struct elfhdr);\r\nelf->e_phentsize = sizeof(struct elf_phdr);\r\nelf->e_phnum = segs;\r\nreturn;\r\n}\r\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\r\n{\r\nphdr->p_type = PT_NOTE;\r\nphdr->p_offset = offset;\r\nphdr->p_vaddr = 0;\r\nphdr->p_paddr = 0;\r\nphdr->p_filesz = sz;\r\nphdr->p_memsz = 0;\r\nphdr->p_flags = 0;\r\nphdr->p_align = 0;\r\nreturn;\r\n}\r\nstatic void fill_note(struct memelfnote *note, const char *name, int type,\r\nunsigned int sz, void *data)\r\n{\r\nnote->name = name;\r\nnote->type = type;\r\nnote->datasz = sz;\r\nnote->data = data;\r\nreturn;\r\n}\r\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\r\nstruct task_struct *p, long signr)\r\n{\r\nprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\r\nprstatus->pr_sigpend = p->pending.signal.sig[0];\r\nprstatus->pr_sighold = p->blocked.sig[0];\r\nrcu_read_lock();\r\nprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\r\nrcu_read_unlock();\r\nprstatus->pr_pid = task_pid_vnr(p);\r\nprstatus->pr_pgrp = task_pgrp_vnr(p);\r\nprstatus->pr_sid = task_session_vnr(p);\r\nif (thread_group_leader(p)) {\r\nstruct task_cputime cputime;\r\nthread_group_cputime(p, &cputime);\r\ncputime_to_timeval(cputime.utime, &prstatus->pr_utime);\r\ncputime_to_timeval(cputime.stime, &prstatus->pr_stime);\r\n} else {\r\ncputime_t utime, stime;\r\ntask_cputime(p, &utime, &stime);\r\ncputime_to_timeval(utime, &prstatus->pr_utime);\r\ncputime_to_timeval(stime, &prstatus->pr_stime);\r\n}\r\ncputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\r\ncputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\r\n}\r\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\r\nstruct mm_struct *mm)\r\n{\r\nconst struct cred *cred;\r\nunsigned int i, len;\r\nmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\r\nlen = mm->arg_end - mm->arg_start;\r\nif (len >= ELF_PRARGSZ)\r\nlen = ELF_PRARGSZ-1;\r\nif (copy_from_user(&psinfo->pr_psargs,\r\n(const char __user *)mm->arg_start, len))\r\nreturn -EFAULT;\r\nfor(i = 0; i < len; i++)\r\nif (psinfo->pr_psargs[i] == 0)\r\npsinfo->pr_psargs[i] = ' ';\r\npsinfo->pr_psargs[len] = 0;\r\nrcu_read_lock();\r\npsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\r\nrcu_read_unlock();\r\npsinfo->pr_pid = task_pid_vnr(p);\r\npsinfo->pr_pgrp = task_pgrp_vnr(p);\r\npsinfo->pr_sid = task_session_vnr(p);\r\ni = p->state ? ffz(~p->state) + 1 : 0;\r\npsinfo->pr_state = i;\r\npsinfo->pr_sname = (i > 5) ? '.' : "RSDTZW"[i];\r\npsinfo->pr_zomb = psinfo->pr_sname == 'Z';\r\npsinfo->pr_nice = task_nice(p);\r\npsinfo->pr_flag = p->flags;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\nSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\r\nSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\r\nrcu_read_unlock();\r\nstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\r\nreturn 0;\r\n}\r\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\r\n{\r\nelf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\r\nint i = 0;\r\ndo\r\ni += 2;\r\nwhile (auxv[i - 2] != AT_NULL);\r\nfill_note(note, "CORE", NT_AUXV, i * sizeof(elf_addr_t), auxv);\r\n}\r\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\r\nconst siginfo_t *siginfo)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\ncopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\r\nset_fs(old_fs);\r\nfill_note(note, "CORE", NT_SIGINFO, sizeof(*csigdata), csigdata);\r\n}\r\nstatic int fill_files_note(struct memelfnote *note)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned count, size, names_ofs, remaining, n;\r\nuser_long_t *data;\r\nuser_long_t *start_end_ofs;\r\nchar *name_base, *name_curpos;\r\ncount = current->mm->map_count;\r\nsize = count * 64;\r\nnames_ofs = (2 + 3 * count) * sizeof(data[0]);\r\nalloc:\r\nif (size >= MAX_FILE_NOTE_SIZE)\r\nreturn -EINVAL;\r\nsize = round_up(size, PAGE_SIZE);\r\ndata = vmalloc(size);\r\nif (!data)\r\nreturn -ENOMEM;\r\nstart_end_ofs = data + 2;\r\nname_base = name_curpos = ((char *)data) + names_ofs;\r\nremaining = size - names_ofs;\r\ncount = 0;\r\nfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\r\nstruct file *file;\r\nconst char *filename;\r\nfile = vma->vm_file;\r\nif (!file)\r\ncontinue;\r\nfilename = file_path(file, name_curpos, remaining);\r\nif (IS_ERR(filename)) {\r\nif (PTR_ERR(filename) == -ENAMETOOLONG) {\r\nvfree(data);\r\nsize = size * 5 / 4;\r\ngoto alloc;\r\n}\r\ncontinue;\r\n}\r\nn = (name_curpos + remaining) - filename;\r\nremaining = filename - name_curpos;\r\nmemmove(name_curpos, filename, n);\r\nname_curpos += n;\r\n*start_end_ofs++ = vma->vm_start;\r\n*start_end_ofs++ = vma->vm_end;\r\n*start_end_ofs++ = vma->vm_pgoff;\r\ncount++;\r\n}\r\ndata[0] = count;\r\ndata[1] = PAGE_SIZE;\r\nn = current->mm->map_count - count;\r\nif (n != 0) {\r\nunsigned shift_bytes = n * 3 * sizeof(data[0]);\r\nmemmove(name_base - shift_bytes, name_base,\r\nname_curpos - name_base);\r\nname_curpos -= shift_bytes;\r\n}\r\nsize = name_curpos - (char *)data;\r\nfill_note(note, "CORE", NT_FILE, size, data);\r\nreturn 0;\r\n}\r\nstatic void do_thread_regset_writeback(struct task_struct *task,\r\nconst struct user_regset *regset)\r\n{\r\nif (regset->writeback)\r\nregset->writeback(task, regset, 1);\r\n}\r\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\r\nconst struct user_regset_view *view,\r\nlong signr, size_t *total)\r\n{\r\nunsigned int i;\r\nfill_prstatus(&t->prstatus, t->task, signr);\r\n(void) view->regsets[0].get(t->task, &view->regsets[0],\r\n0, PR_REG_SIZE(t->prstatus.pr_reg),\r\nPR_REG_PTR(&t->prstatus), NULL);\r\nfill_note(&t->notes[0], "CORE", NT_PRSTATUS,\r\nPRSTATUS_SIZE(t->prstatus), &t->prstatus);\r\n*total += notesize(&t->notes[0]);\r\ndo_thread_regset_writeback(t->task, &view->regsets[0]);\r\nfor (i = 1; i < view->n; ++i) {\r\nconst struct user_regset *regset = &view->regsets[i];\r\ndo_thread_regset_writeback(t->task, regset);\r\nif (regset->core_note_type && regset->get &&\r\n(!regset->active || regset->active(t->task, regset))) {\r\nint ret;\r\nsize_t size = regset->n * regset->size;\r\nvoid *data = kmalloc(size, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn 0;\r\nret = regset->get(t->task, regset,\r\n0, size, data, NULL);\r\nif (unlikely(ret))\r\nkfree(data);\r\nelse {\r\nif (regset->core_note_type != NT_PRFPREG)\r\nfill_note(&t->notes[i], "LINUX",\r\nregset->core_note_type,\r\nsize, data);\r\nelse {\r\nSET_PR_FPVALID(&t->prstatus, 1);\r\nfill_note(&t->notes[i], "CORE",\r\nNT_PRFPREG, size, data);\r\n}\r\n*total += notesize(&t->notes[i]);\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\r\nstruct elf_note_info *info,\r\nconst siginfo_t *siginfo, struct pt_regs *regs)\r\n{\r\nstruct task_struct *dump_task = current;\r\nconst struct user_regset_view *view = task_user_regset_view(dump_task);\r\nstruct elf_thread_core_info *t;\r\nstruct elf_prpsinfo *psinfo;\r\nstruct core_thread *ct;\r\nunsigned int i;\r\ninfo->size = 0;\r\ninfo->thread = NULL;\r\npsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\r\nif (psinfo == NULL) {\r\ninfo->psinfo.data = NULL;\r\nreturn 0;\r\n}\r\nfill_note(&info->psinfo, "CORE", NT_PRPSINFO, sizeof(*psinfo), psinfo);\r\ninfo->thread_notes = 0;\r\nfor (i = 0; i < view->n; ++i)\r\nif (view->regsets[i].core_note_type != 0)\r\n++info->thread_notes;\r\nif (unlikely(info->thread_notes == 0) ||\r\nunlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nfill_elf_header(elf, phdrs,\r\nview->e_machine, view->e_flags);\r\nfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\r\nt = kzalloc(offsetof(struct elf_thread_core_info,\r\nnotes[info->thread_notes]),\r\nGFP_KERNEL);\r\nif (unlikely(!t))\r\nreturn 0;\r\nt->task = ct->task;\r\nif (ct->task == dump_task || !info->thread) {\r\nt->next = info->thread;\r\ninfo->thread = t;\r\n} else {\r\nt->next = info->thread->next;\r\ninfo->thread->next = t;\r\n}\r\n}\r\nfor (t = info->thread; t != NULL; t = t->next)\r\nif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\r\nreturn 0;\r\nfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\r\ninfo->size += notesize(&info->psinfo);\r\nfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\r\ninfo->size += notesize(&info->signote);\r\nfill_auxv_note(&info->auxv, current->mm);\r\ninfo->size += notesize(&info->auxv);\r\nif (fill_files_note(&info->files) == 0)\r\ninfo->size += notesize(&info->files);\r\nreturn 1;\r\n}\r\nstatic size_t get_note_info_size(struct elf_note_info *info)\r\n{\r\nreturn info->size;\r\n}\r\nstatic int write_note_info(struct elf_note_info *info,\r\nstruct coredump_params *cprm)\r\n{\r\nbool first = true;\r\nstruct elf_thread_core_info *t = info->thread;\r\ndo {\r\nint i;\r\nif (!writenote(&t->notes[0], cprm))\r\nreturn 0;\r\nif (first && !writenote(&info->psinfo, cprm))\r\nreturn 0;\r\nif (first && !writenote(&info->signote, cprm))\r\nreturn 0;\r\nif (first && !writenote(&info->auxv, cprm))\r\nreturn 0;\r\nif (first && info->files.data &&\r\n!writenote(&info->files, cprm))\r\nreturn 0;\r\nfor (i = 1; i < info->thread_notes; ++i)\r\nif (t->notes[i].data &&\r\n!writenote(&t->notes[i], cprm))\r\nreturn 0;\r\nfirst = false;\r\nt = t->next;\r\n} while (t);\r\nreturn 1;\r\n}\r\nstatic void free_note_info(struct elf_note_info *info)\r\n{\r\nstruct elf_thread_core_info *threads = info->thread;\r\nwhile (threads) {\r\nunsigned int i;\r\nstruct elf_thread_core_info *t = threads;\r\nthreads = t->next;\r\nWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\r\nfor (i = 1; i < info->thread_notes; ++i)\r\nkfree(t->notes[i].data);\r\nkfree(t);\r\n}\r\nkfree(info->psinfo.data);\r\nvfree(info->files.data);\r\n}\r\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\r\n{\r\nint sz = 0;\r\nstruct task_struct *p = t->thread;\r\nt->num_notes = 0;\r\nfill_prstatus(&t->prstatus, p, signr);\r\nelf_core_copy_task_regs(p, &t->prstatus.pr_reg);\r\nfill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus),\r\n&(t->prstatus));\r\nt->num_notes++;\r\nsz += notesize(&t->notes[0]);\r\nif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\r\n&t->fpu))) {\r\nfill_note(&t->notes[1], "CORE", NT_PRFPREG, sizeof(t->fpu),\r\n&(t->fpu));\r\nt->num_notes++;\r\nsz += notesize(&t->notes[1]);\r\n}\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\r\nfill_note(&t->notes[2], "LINUX", ELF_CORE_XFPREG_TYPE,\r\nsizeof(t->xfpu), &t->xfpu);\r\nt->num_notes++;\r\nsz += notesize(&t->notes[2]);\r\n}\r\n#endif\r\nreturn sz;\r\n}\r\nstatic int elf_note_info_init(struct elf_note_info *info)\r\n{\r\nmemset(info, 0, sizeof(*info));\r\nINIT_LIST_HEAD(&info->thread_list);\r\ninfo->notes = kmalloc(8 * sizeof(struct memelfnote), GFP_KERNEL);\r\nif (!info->notes)\r\nreturn 0;\r\ninfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\r\nif (!info->psinfo)\r\nreturn 0;\r\ninfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\r\nif (!info->prstatus)\r\nreturn 0;\r\ninfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\r\nif (!info->fpu)\r\nreturn 0;\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\ninfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\r\nif (!info->xfpu)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\r\nstruct elf_note_info *info,\r\nconst siginfo_t *siginfo, struct pt_regs *regs)\r\n{\r\nstruct list_head *t;\r\nstruct core_thread *ct;\r\nstruct elf_thread_status *ets;\r\nif (!elf_note_info_init(info))\r\nreturn 0;\r\nfor (ct = current->mm->core_state->dumper.next;\r\nct; ct = ct->next) {\r\nets = kzalloc(sizeof(*ets), GFP_KERNEL);\r\nif (!ets)\r\nreturn 0;\r\nets->thread = ct->task;\r\nlist_add(&ets->list, &info->thread_list);\r\n}\r\nlist_for_each(t, &info->thread_list) {\r\nint sz;\r\nets = list_entry(t, struct elf_thread_status, list);\r\nsz = elf_dump_thread_status(siginfo->si_signo, ets);\r\ninfo->thread_status_size += sz;\r\n}\r\nmemset(info->prstatus, 0, sizeof(*info->prstatus));\r\nfill_prstatus(info->prstatus, current, siginfo->si_signo);\r\nelf_core_copy_regs(&info->prstatus->pr_reg, regs);\r\nfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\r\nfill_note(info->notes + 0, "CORE", NT_PRSTATUS,\r\nsizeof(*info->prstatus), info->prstatus);\r\nfill_psinfo(info->psinfo, current->group_leader, current->mm);\r\nfill_note(info->notes + 1, "CORE", NT_PRPSINFO,\r\nsizeof(*info->psinfo), info->psinfo);\r\nfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\r\nfill_auxv_note(info->notes + 3, current->mm);\r\ninfo->numnote = 4;\r\nif (fill_files_note(info->notes + info->numnote) == 0) {\r\ninfo->notes_files = info->notes + info->numnote;\r\ninfo->numnote++;\r\n}\r\ninfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\r\ninfo->fpu);\r\nif (info->prstatus->pr_fpvalid)\r\nfill_note(info->notes + info->numnote++,\r\n"CORE", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nif (elf_core_copy_task_xfpregs(current, info->xfpu))\r\nfill_note(info->notes + info->numnote++,\r\n"LINUX", ELF_CORE_XFPREG_TYPE,\r\nsizeof(*info->xfpu), info->xfpu);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic size_t get_note_info_size(struct elf_note_info *info)\r\n{\r\nint sz = 0;\r\nint i;\r\nfor (i = 0; i < info->numnote; i++)\r\nsz += notesize(info->notes + i);\r\nsz += info->thread_status_size;\r\nreturn sz;\r\n}\r\nstatic int write_note_info(struct elf_note_info *info,\r\nstruct coredump_params *cprm)\r\n{\r\nint i;\r\nstruct list_head *t;\r\nfor (i = 0; i < info->numnote; i++)\r\nif (!writenote(info->notes + i, cprm))\r\nreturn 0;\r\nlist_for_each(t, &info->thread_list) {\r\nstruct elf_thread_status *tmp =\r\nlist_entry(t, struct elf_thread_status, list);\r\nfor (i = 0; i < tmp->num_notes; i++)\r\nif (!writenote(&tmp->notes[i], cprm))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void free_note_info(struct elf_note_info *info)\r\n{\r\nwhile (!list_empty(&info->thread_list)) {\r\nstruct list_head *tmp = info->thread_list.next;\r\nlist_del(tmp);\r\nkfree(list_entry(tmp, struct elf_thread_status, list));\r\n}\r\nif (info->notes_files)\r\nvfree(info->notes_files->data);\r\nkfree(info->prstatus);\r\nkfree(info->psinfo);\r\nkfree(info->notes);\r\nkfree(info->fpu);\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nkfree(info->xfpu);\r\n#endif\r\n}\r\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\r\nstruct vm_area_struct *gate_vma)\r\n{\r\nstruct vm_area_struct *ret = tsk->mm->mmap;\r\nif (ret)\r\nreturn ret;\r\nreturn gate_vma;\r\n}\r\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\r\nstruct vm_area_struct *gate_vma)\r\n{\r\nstruct vm_area_struct *ret;\r\nret = this_vma->vm_next;\r\nif (ret)\r\nreturn ret;\r\nif (this_vma == gate_vma)\r\nreturn NULL;\r\nreturn gate_vma;\r\n}\r\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\r\nelf_addr_t e_shoff, int segs)\r\n{\r\nelf->e_shoff = e_shoff;\r\nelf->e_shentsize = sizeof(*shdr4extnum);\r\nelf->e_shnum = 1;\r\nelf->e_shstrndx = SHN_UNDEF;\r\nmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\r\nshdr4extnum->sh_type = SHT_NULL;\r\nshdr4extnum->sh_size = elf->e_shnum;\r\nshdr4extnum->sh_link = elf->e_shstrndx;\r\nshdr4extnum->sh_info = segs;\r\n}\r\nstatic int elf_core_dump(struct coredump_params *cprm)\r\n{\r\nint has_dumped = 0;\r\nmm_segment_t fs;\r\nint segs, i;\r\nsize_t vma_data_size = 0;\r\nstruct vm_area_struct *vma, *gate_vma;\r\nstruct elfhdr *elf = NULL;\r\nloff_t offset = 0, dataoff;\r\nstruct elf_note_info info = { };\r\nstruct elf_phdr *phdr4note = NULL;\r\nstruct elf_shdr *shdr4extnum = NULL;\r\nElf_Half e_phnum;\r\nelf_addr_t e_shoff;\r\nelf_addr_t *vma_filesz = NULL;\r\nelf = kmalloc(sizeof(*elf), GFP_KERNEL);\r\nif (!elf)\r\ngoto out;\r\nsegs = current->mm->map_count;\r\nsegs += elf_core_extra_phdrs();\r\ngate_vma = get_gate_vma(current->mm);\r\nif (gate_vma != NULL)\r\nsegs++;\r\nsegs++;\r\ne_phnum = segs > PN_XNUM ? PN_XNUM : segs;\r\nif (!fill_note_info(elf, e_phnum, &info, cprm->siginfo, cprm->regs))\r\ngoto cleanup;\r\nhas_dumped = 1;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\noffset += sizeof(*elf);\r\noffset += segs * sizeof(struct elf_phdr);\r\n{\r\nsize_t sz = get_note_info_size(&info);\r\nsz += elf_coredump_extra_notes_size();\r\nphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\r\nif (!phdr4note)\r\ngoto end_coredump;\r\nfill_elf_note_phdr(phdr4note, sz, offset);\r\noffset += sz;\r\n}\r\ndataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\r\nvma_filesz = kmalloc_array(segs - 1, sizeof(*vma_filesz), GFP_KERNEL);\r\nif (!vma_filesz)\r\ngoto end_coredump;\r\nfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\r\nvma = next_vma(vma, gate_vma)) {\r\nunsigned long dump_size;\r\ndump_size = vma_dump_size(vma, cprm->mm_flags);\r\nvma_filesz[i++] = dump_size;\r\nvma_data_size += dump_size;\r\n}\r\noffset += vma_data_size;\r\noffset += elf_core_extra_data_size();\r\ne_shoff = offset;\r\nif (e_phnum == PN_XNUM) {\r\nshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\r\nif (!shdr4extnum)\r\ngoto end_coredump;\r\nfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\r\n}\r\noffset = dataoff;\r\nif (!dump_emit(cprm, elf, sizeof(*elf)))\r\ngoto end_coredump;\r\nif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\r\ngoto end_coredump;\r\nfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\r\nvma = next_vma(vma, gate_vma)) {\r\nstruct elf_phdr phdr;\r\nphdr.p_type = PT_LOAD;\r\nphdr.p_offset = offset;\r\nphdr.p_vaddr = vma->vm_start;\r\nphdr.p_paddr = 0;\r\nphdr.p_filesz = vma_filesz[i++];\r\nphdr.p_memsz = vma->vm_end - vma->vm_start;\r\noffset += phdr.p_filesz;\r\nphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\r\nif (vma->vm_flags & VM_WRITE)\r\nphdr.p_flags |= PF_W;\r\nif (vma->vm_flags & VM_EXEC)\r\nphdr.p_flags |= PF_X;\r\nphdr.p_align = ELF_EXEC_PAGESIZE;\r\nif (!dump_emit(cprm, &phdr, sizeof(phdr)))\r\ngoto end_coredump;\r\n}\r\nif (!elf_core_write_extra_phdrs(cprm, offset))\r\ngoto end_coredump;\r\nif (!write_note_info(&info, cprm))\r\ngoto end_coredump;\r\nif (elf_coredump_extra_notes_write(cprm))\r\ngoto end_coredump;\r\nif (!dump_skip(cprm, dataoff - cprm->written))\r\ngoto end_coredump;\r\nfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\r\nvma = next_vma(vma, gate_vma)) {\r\nunsigned long addr;\r\nunsigned long end;\r\nend = vma->vm_start + vma_filesz[i++];\r\nfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\r\nstruct page *page;\r\nint stop;\r\npage = get_dump_page(addr);\r\nif (page) {\r\nvoid *kaddr = kmap(page);\r\nstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\r\nkunmap(page);\r\npage_cache_release(page);\r\n} else\r\nstop = !dump_skip(cprm, PAGE_SIZE);\r\nif (stop)\r\ngoto end_coredump;\r\n}\r\n}\r\nif (!elf_core_write_extra_data(cprm))\r\ngoto end_coredump;\r\nif (e_phnum == PN_XNUM) {\r\nif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\r\ngoto end_coredump;\r\n}\r\nend_coredump:\r\nset_fs(fs);\r\ncleanup:\r\nfree_note_info(&info);\r\nkfree(shdr4extnum);\r\nkfree(vma_filesz);\r\nkfree(phdr4note);\r\nkfree(elf);\r\nout:\r\nreturn has_dumped;\r\n}\r\nstatic int __init init_elf_binfmt(void)\r\n{\r\nregister_binfmt(&elf_format);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_elf_binfmt(void)\r\n{\r\nunregister_binfmt(&elf_format);\r\n}
