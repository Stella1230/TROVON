struct mite_struct *mite_alloc(struct pci_dev *pcidev)\r\n{\r\nstruct mite_struct *mite;\r\nunsigned int i;\r\nmite = kzalloc(sizeof(*mite), GFP_KERNEL);\r\nif (mite) {\r\nspin_lock_init(&mite->lock);\r\nmite->pcidev = pcidev;\r\nfor (i = 0; i < MAX_MITE_DMA_CHANNELS; ++i) {\r\nmite->channels[i].mite = mite;\r\nmite->channels[i].channel = i;\r\nmite->channels[i].done = 1;\r\n}\r\n}\r\nreturn mite;\r\n}\r\nstatic void dump_chip_signature(u32 csigr_bits)\r\n{\r\npr_info("version = %i, type = %i, mite mode = %i, interface mode = %i\n",\r\nmite_csigr_version(csigr_bits), mite_csigr_type(csigr_bits),\r\nmite_csigr_mmode(csigr_bits), mite_csigr_imode(csigr_bits));\r\npr_info("num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\n",\r\nmite_csigr_dmac(csigr_bits), mite_csigr_wpdep(csigr_bits),\r\nmite_csigr_wins(csigr_bits), mite_csigr_iowins(csigr_bits));\r\n}\r\nstatic unsigned mite_fifo_size(struct mite_struct *mite, unsigned channel)\r\n{\r\nunsigned fcr_bits = readl(mite->mite_io_addr + MITE_FCR(channel));\r\nunsigned empty_count = (fcr_bits >> 16) & 0xff;\r\nunsigned full_count = fcr_bits & 0xff;\r\nreturn empty_count + full_count;\r\n}\r\nint mite_setup2(struct comedi_device *dev,\r\nstruct mite_struct *mite, bool use_win1)\r\n{\r\nunsigned long length;\r\nint i;\r\nu32 csigr_bits;\r\nunsigned unknown_dma_burst_bits;\r\npci_set_master(mite->pcidev);\r\nmite->mite_io_addr = pci_ioremap_bar(mite->pcidev, 0);\r\nif (!mite->mite_io_addr) {\r\ndev_err(dev->class_dev,\r\n"Failed to remap mite io memory address\n");\r\nreturn -ENOMEM;\r\n}\r\nmite->mite_phys_addr = pci_resource_start(mite->pcidev, 0);\r\ndev->mmio = pci_ioremap_bar(mite->pcidev, 1);\r\nif (!dev->mmio) {\r\ndev_err(dev->class_dev,\r\n"Failed to remap daq io memory address\n");\r\nreturn -ENOMEM;\r\n}\r\nmite->daq_phys_addr = pci_resource_start(mite->pcidev, 1);\r\nlength = pci_resource_len(mite->pcidev, 1);\r\nif (use_win1) {\r\nwritel(0, mite->mite_io_addr + MITE_IODWBSR);\r\ndev_info(dev->class_dev,\r\n"using I/O Window Base Size register 1\n");\r\nwritel(mite->daq_phys_addr | WENAB |\r\nMITE_IODWBSR_1_WSIZE_bits(length),\r\nmite->mite_io_addr + MITE_IODWBSR_1);\r\nwritel(0, mite->mite_io_addr + MITE_IODWCR_1);\r\n} else {\r\nwritel(mite->daq_phys_addr | WENAB,\r\nmite->mite_io_addr + MITE_IODWBSR);\r\n}\r\nunknown_dma_burst_bits =\r\nreadl(mite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);\r\nunknown_dma_burst_bits |= UNKNOWN_DMA_BURST_ENABLE_BITS;\r\nwritel(unknown_dma_burst_bits,\r\nmite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);\r\ncsigr_bits = readl(mite->mite_io_addr + MITE_CSIGR);\r\nmite->num_channels = mite_csigr_dmac(csigr_bits);\r\nif (mite->num_channels > MAX_MITE_DMA_CHANNELS) {\r\ndev_warn(dev->class_dev,\r\n"mite: bug? chip claims to have %i dma channels. Setting to %i.\n",\r\nmite->num_channels, MAX_MITE_DMA_CHANNELS);\r\nmite->num_channels = MAX_MITE_DMA_CHANNELS;\r\n}\r\ndump_chip_signature(csigr_bits);\r\nfor (i = 0; i < mite->num_channels; i++) {\r\nwritel(CHOR_DMARESET, mite->mite_io_addr + MITE_CHOR(i));\r\nwritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |\r\nCHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\r\nCHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\r\nmite->mite_io_addr + MITE_CHCR(i));\r\n}\r\nmite->fifo_size = mite_fifo_size(mite, 0);\r\ndev_info(dev->class_dev, "fifo size is %i.\n", mite->fifo_size);\r\nreturn 0;\r\n}\r\nvoid mite_detach(struct mite_struct *mite)\r\n{\r\nif (!mite)\r\nreturn;\r\nif (mite->mite_io_addr)\r\niounmap(mite->mite_io_addr);\r\nkfree(mite);\r\n}\r\nstruct mite_dma_descriptor_ring *mite_alloc_ring(struct mite_struct *mite)\r\n{\r\nstruct mite_dma_descriptor_ring *ring =\r\nkmalloc(sizeof(struct mite_dma_descriptor_ring), GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nring->hw_dev = get_device(&mite->pcidev->dev);\r\nif (!ring->hw_dev) {\r\nkfree(ring);\r\nreturn NULL;\r\n}\r\nring->n_links = 0;\r\nring->descriptors = NULL;\r\nring->descriptors_dma_addr = 0;\r\nreturn ring;\r\n}\r\nvoid mite_free_ring(struct mite_dma_descriptor_ring *ring)\r\n{\r\nif (ring) {\r\nif (ring->descriptors) {\r\ndma_free_coherent(ring->hw_dev,\r\nring->n_links *\r\nsizeof(struct mite_dma_descriptor),\r\nring->descriptors,\r\nring->descriptors_dma_addr);\r\n}\r\nput_device(ring->hw_dev);\r\nkfree(ring);\r\n}\r\n}\r\nstruct mite_channel *mite_request_channel_in_range(struct mite_struct *mite,\r\nstruct\r\nmite_dma_descriptor_ring\r\n*ring, unsigned min_channel,\r\nunsigned max_channel)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct mite_channel *channel = NULL;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nfor (i = min_channel; i <= max_channel; ++i) {\r\nif (mite->channel_allocated[i] == 0) {\r\nmite->channel_allocated[i] = 1;\r\nchannel = &mite->channels[i];\r\nchannel->ring = ring;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn channel;\r\n}\r\nvoid mite_release_channel(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nif (mite->channel_allocated[mite_chan->channel]) {\r\nmite_dma_disarm(mite_chan);\r\nmite_dma_reset(mite_chan);\r\nwritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE |\r\nCHCR_CLR_SAR_IE | CHCR_CLR_DONE_IE |\r\nCHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\r\nCHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\r\nmite->mite_io_addr + MITE_CHCR(mite_chan->channel));\r\nmite->channel_allocated[mite_chan->channel] = 0;\r\nmite_chan->ring = NULL;\r\nmmiowb();\r\n}\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\n}\r\nvoid mite_dma_arm(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nint chor;\r\nunsigned long flags;\r\nsmp_mb();\r\nchor = CHOR_START;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nmite_chan->done = 0;\r\nwritel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));\r\nmmiowb();\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\n}\r\nint mite_buf_change(struct mite_dma_descriptor_ring *ring,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int n_links;\r\nint i;\r\nif (ring->descriptors) {\r\ndma_free_coherent(ring->hw_dev,\r\nring->n_links *\r\nsizeof(struct mite_dma_descriptor),\r\nring->descriptors,\r\nring->descriptors_dma_addr);\r\n}\r\nring->descriptors = NULL;\r\nring->descriptors_dma_addr = 0;\r\nring->n_links = 0;\r\nif (async->prealloc_bufsz == 0)\r\nreturn 0;\r\nn_links = async->prealloc_bufsz >> PAGE_SHIFT;\r\nring->descriptors =\r\ndma_alloc_coherent(ring->hw_dev,\r\nn_links * sizeof(struct mite_dma_descriptor),\r\n&ring->descriptors_dma_addr, GFP_KERNEL);\r\nif (!ring->descriptors) {\r\ndev_err(s->device->class_dev,\r\n"mite: ring buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nring->n_links = n_links;\r\nfor (i = 0; i < n_links; i++) {\r\nring->descriptors[i].count = cpu_to_le32(PAGE_SIZE);\r\nring->descriptors[i].addr =\r\ncpu_to_le32(async->buf_map->page_list[i].dma_addr);\r\nring->descriptors[i].next =\r\ncpu_to_le32(ring->descriptors_dma_addr + (i +\r\n1) *\r\nsizeof(struct mite_dma_descriptor));\r\n}\r\nring->descriptors[n_links - 1].next =\r\ncpu_to_le32(ring->descriptors_dma_addr);\r\nsmp_wmb();\r\nreturn 0;\r\n}\r\nvoid mite_prep_dma(struct mite_channel *mite_chan,\r\nunsigned int num_device_bits, unsigned int num_memory_bits)\r\n{\r\nunsigned int chor, chcr, mcr, dcr, lkcr;\r\nstruct mite_struct *mite = mite_chan->mite;\r\nchor = CHOR_DMARESET | CHOR_FRESET;\r\nwritel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));\r\nchcr = CHCR_SET_DMA_IE | CHCR_LINKSHORT | CHCR_SET_DONE_IE |\r\nCHCR_BURSTEN;\r\nchcr |= CHCR_SET_LC_IE;\r\nif (num_memory_bits == 32 && num_device_bits == 16) {\r\nchcr |= CHCR_BYTE_SWAP_DEVICE | CHCR_BYTE_SWAP_MEMORY;\r\n}\r\nif (mite_chan->dir == COMEDI_INPUT)\r\nchcr |= CHCR_DEV_TO_MEM;\r\nwritel(chcr, mite->mite_io_addr + MITE_CHCR(mite_chan->channel));\r\nmcr = CR_RL(64) | CR_ASEQUP;\r\nswitch (num_memory_bits) {\r\ncase 8:\r\nmcr |= CR_PSIZE8;\r\nbreak;\r\ncase 16:\r\nmcr |= CR_PSIZE16;\r\nbreak;\r\ncase 32:\r\nmcr |= CR_PSIZE32;\r\nbreak;\r\ndefault:\r\npr_warn("bug! invalid mem bit width for dma transfer\n");\r\nbreak;\r\n}\r\nwritel(mcr, mite->mite_io_addr + MITE_MCR(mite_chan->channel));\r\ndcr = CR_RL(64) | CR_ASEQUP;\r\ndcr |= CR_PORTIO | CR_AMDEVICE | CR_REQSDRQ(mite_chan->channel);\r\nswitch (num_device_bits) {\r\ncase 8:\r\ndcr |= CR_PSIZE8;\r\nbreak;\r\ncase 16:\r\ndcr |= CR_PSIZE16;\r\nbreak;\r\ncase 32:\r\ndcr |= CR_PSIZE32;\r\nbreak;\r\ndefault:\r\npr_warn("bug! invalid dev bit width for dma transfer\n");\r\nbreak;\r\n}\r\nwritel(dcr, mite->mite_io_addr + MITE_DCR(mite_chan->channel));\r\nwritel(0, mite->mite_io_addr + MITE_DAR(mite_chan->channel));\r\nlkcr = CR_RL(64) | CR_ASEQUP | CR_PSIZE32;\r\nwritel(lkcr, mite->mite_io_addr + MITE_LKCR(mite_chan->channel));\r\nwritel(mite_chan->ring->descriptors_dma_addr,\r\nmite->mite_io_addr + MITE_LKAR(mite_chan->channel));\r\n}\r\nstatic u32 mite_device_bytes_transferred(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nreturn readl(mite->mite_io_addr + MITE_DAR(mite_chan->channel));\r\n}\r\nu32 mite_bytes_in_transit(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nreturn readl(mite->mite_io_addr +\r\nMITE_FCR(mite_chan->channel)) & 0x000000FF;\r\n}\r\nu32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan)\r\n{\r\nu32 device_byte_count;\r\ndevice_byte_count = mite_device_bytes_transferred(mite_chan);\r\nreturn device_byte_count - mite_bytes_in_transit(mite_chan);\r\n}\r\nu32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan)\r\n{\r\nu32 in_transit_count;\r\nin_transit_count = mite_bytes_in_transit(mite_chan);\r\nreturn mite_device_bytes_transferred(mite_chan) - in_transit_count;\r\n}\r\nu32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan)\r\n{\r\nu32 device_byte_count;\r\ndevice_byte_count = mite_device_bytes_transferred(mite_chan);\r\nreturn device_byte_count + mite_bytes_in_transit(mite_chan);\r\n}\r\nu32 mite_bytes_read_from_memory_ub(struct mite_channel *mite_chan)\r\n{\r\nu32 in_transit_count;\r\nin_transit_count = mite_bytes_in_transit(mite_chan);\r\nreturn mite_device_bytes_transferred(mite_chan) + in_transit_count;\r\n}\r\nunsigned mite_dma_tcr(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nreturn readl(mite->mite_io_addr + MITE_TCR(mite_chan->channel));\r\n}\r\nvoid mite_dma_disarm(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nunsigned chor;\r\nchor = CHOR_ABORT;\r\nwritel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));\r\n}\r\nint mite_sync_input_dma(struct mite_channel *mite_chan,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nint count;\r\nunsigned int nbytes, old_alloc_count;\r\nold_alloc_count = async->buf_write_alloc_count;\r\ncomedi_buf_write_alloc(s, async->prealloc_bufsz);\r\nnbytes = mite_bytes_written_to_memory_lb(mite_chan);\r\nif ((int)(mite_bytes_written_to_memory_ub(mite_chan) -\r\nold_alloc_count) > 0) {\r\ndev_warn(s->device->class_dev,\r\n"mite: DMA overwrite of free area\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn -1;\r\n}\r\ncount = nbytes - async->buf_write_count;\r\nif (count <= 0)\r\nreturn 0;\r\ncomedi_buf_write_free(s, count);\r\ncomedi_inc_scan_progress(s, count);\r\nasync->events |= COMEDI_CB_BLOCK;\r\nreturn 0;\r\n}\r\nint mite_sync_output_dma(struct mite_channel *mite_chan,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu32 stop_count = cmd->stop_arg * comedi_bytes_per_scan(s);\r\nunsigned int old_alloc_count = async->buf_read_alloc_count;\r\nu32 nbytes_ub, nbytes_lb;\r\nint count;\r\ncomedi_buf_read_alloc(s, async->prealloc_bufsz);\r\nnbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);\r\nif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_lb - stop_count) > 0)\r\nnbytes_lb = stop_count;\r\nnbytes_ub = mite_bytes_read_from_memory_ub(mite_chan);\r\nif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_ub - stop_count) > 0)\r\nnbytes_ub = stop_count;\r\nif ((int)(nbytes_ub - old_alloc_count) > 0) {\r\ndev_warn(s->device->class_dev, "mite: DMA underrun\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn -1;\r\n}\r\ncount = nbytes_lb - async->buf_read_count;\r\nif (count <= 0)\r\nreturn 0;\r\nif (count) {\r\ncomedi_buf_read_free(s, count);\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\nreturn 0;\r\n}\r\nunsigned mite_get_status(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nunsigned status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nstatus = readl(mite->mite_io_addr + MITE_CHSR(mite_chan->channel));\r\nif (status & CHSR_DONE) {\r\nmite_chan->done = 1;\r\nwritel(CHOR_CLRDONE,\r\nmite->mite_io_addr + MITE_CHOR(mite_chan->channel));\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn status;\r\n}\r\nint mite_done(struct mite_channel *mite_chan)\r\n{\r\nstruct mite_struct *mite = mite_chan->mite;\r\nunsigned long flags;\r\nint done;\r\nmite_get_status(mite_chan);\r\nspin_lock_irqsave(&mite->lock, flags);\r\ndone = mite_chan->done;\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn done;\r\n}\r\nstatic int __init mite_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit mite_module_exit(void)\r\n{\r\n}
