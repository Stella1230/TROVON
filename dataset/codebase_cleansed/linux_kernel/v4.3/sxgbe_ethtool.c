static int sxgbe_get_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nif (!priv->hw_cap.eee)\r\nreturn -EOPNOTSUPP;\r\nedata->eee_enabled = priv->eee_enabled;\r\nedata->eee_active = priv->eee_active;\r\nedata->tx_lpi_timer = priv->tx_lpi_timer;\r\nreturn phy_ethtool_get_eee(priv->phydev, edata);\r\n}\r\nstatic int sxgbe_set_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\npriv->eee_enabled = edata->eee_enabled;\r\nif (!priv->eee_enabled) {\r\nsxgbe_disable_eee_mode(priv);\r\n} else {\r\npriv->eee_enabled = sxgbe_eee_init(priv);\r\nif (!priv->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\npriv->tx_lpi_timer = edata->tx_lpi_timer;\r\n}\r\nreturn phy_ethtool_set_eee(priv->phydev, edata);\r\n}\r\nstatic void sxgbe_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic int sxgbe_getsettings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nif (priv->phydev)\r\nreturn phy_ethtool_gset(priv->phydev, cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int sxgbe_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nif (priv->phydev)\r\nreturn phy_ethtool_sset(priv->phydev, cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic u32 sxgbe_getmsglevel(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void sxgbe_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\npriv->msg_enable = level;\r\n}\r\nstatic void sxgbe_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nint i;\r\nu8 *p = data;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < SXGBE_STATS_LEN; i++) {\r\nmemcpy(p, sxgbe_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int sxgbe_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nint len;\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nlen = SXGBE_STATS_LEN;\r\nreturn len;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void sxgbe_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *dummy, u64 *data)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nint i;\r\nchar *p;\r\nif (priv->eee_enabled) {\r\nint val = phy_get_eee_err(priv->phydev);\r\nif (val)\r\npriv->xstats.eee_wakeup_error_n = val;\r\n}\r\nfor (i = 0; i < SXGBE_STATS_LEN; i++) {\r\np = (char *)priv + sxgbe_gstrings_stats[i].stat_offset;\r\ndata[i] = (sxgbe_gstrings_stats[i].sizeof_stat == sizeof(u64))\r\n? (*(u64 *)p) : (*(u32 *)p);\r\n}\r\n}\r\nstatic void sxgbe_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nchannel->max_rx = SXGBE_MAX_RX_CHANNELS;\r\nchannel->max_tx = SXGBE_MAX_TX_CHANNELS;\r\nchannel->rx_count = SXGBE_RX_QUEUES;\r\nchannel->tx_count = SXGBE_TX_QUEUES;\r\n}\r\nstatic u32 sxgbe_riwt2usec(u32 riwt, struct sxgbe_priv_data *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->sxgbe_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (riwt * 256) / (clk / 1000000);\r\n}\r\nstatic u32 sxgbe_usec2riwt(u32 usec, struct sxgbe_priv_data *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->sxgbe_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (usec * (clk / 1000000)) / 256;\r\n}\r\nstatic int sxgbe_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nif (priv->use_riwt)\r\nec->rx_coalesce_usecs = sxgbe_riwt2usec(priv->rx_riwt, priv);\r\nreturn 0;\r\n}\r\nstatic int sxgbe_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nunsigned int rx_riwt;\r\nif (!ec->rx_coalesce_usecs)\r\nreturn -EINVAL;\r\nrx_riwt = sxgbe_usec2riwt(ec->rx_coalesce_usecs, priv);\r\nif ((rx_riwt > SXGBE_MAX_DMA_RIWT) || (rx_riwt < SXGBE_MIN_DMA_RIWT))\r\nreturn -EINVAL;\r\nelse if (!priv->use_riwt)\r\nreturn -EOPNOTSUPP;\r\npriv->rx_riwt = rx_riwt;\r\npriv->hw->dma->rx_watchdog(priv->ioaddr, priv->rx_riwt);\r\nreturn 0;\r\n}\r\nstatic int sxgbe_get_rss_hash_opts(struct sxgbe_priv_data *priv,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\ncmd->data = 0;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase IPV4_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\ncase UDP_V6_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IPV6_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sxgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXFH:\r\nret = sxgbe_get_rss_hash_opts(priv, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sxgbe_set_rss_hash_opt(struct sxgbe_priv_data *priv,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nu32 reg_val = 0;\r\nif (cmd->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nif (!(cmd->data & RXH_IP_SRC) ||\r\n!(cmd->data & RXH_IP_DST) ||\r\n!(cmd->data & RXH_L4_B_0_1) ||\r\n!(cmd->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nreg_val = SXGBE_CORE_RSS_CTL_TCP4TE;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\ncase UDP_V6_FLOW:\r\nif (!(cmd->data & RXH_IP_SRC) ||\r\n!(cmd->data & RXH_IP_DST) ||\r\n!(cmd->data & RXH_L4_B_0_1) ||\r\n!(cmd->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nreg_val = SXGBE_CORE_RSS_CTL_UDP4TE;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\nif (!(cmd->data & RXH_IP_SRC) ||\r\n!(cmd->data & RXH_IP_DST) ||\r\n(cmd->data & RXH_L4_B_0_1) ||\r\n(cmd->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nreg_val = SXGBE_CORE_RSS_CTL_IP2TE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg_val |= readl(priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\r\nwritel(reg_val, priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\r\nreadl(priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\r\nreturn 0;\r\n}\r\nstatic int sxgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nret = sxgbe_set_rss_hash_opt(priv, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sxgbe_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *space)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nu32 *reg_space = (u32 *)space;\r\nint reg_offset;\r\nint reg_ix = 0;\r\nvoid __iomem *ioaddr = priv->ioaddr;\r\nmemset(reg_space, 0x0, REG_SPACE_SIZE);\r\nfor (reg_offset = START_MAC_REG_OFFSET;\r\nreg_offset <= MAX_MAC_REG_OFFSET; reg_offset += 4) {\r\nreg_space[reg_ix] = readl(ioaddr + reg_offset);\r\nreg_ix++;\r\n}\r\nfor (reg_offset = START_MTL_REG_OFFSET;\r\nreg_offset <= MAX_MTL_REG_OFFSET; reg_offset += 4) {\r\nreg_space[reg_ix] = readl(ioaddr + reg_offset);\r\nreg_ix++;\r\n}\r\nfor (reg_offset = START_DMA_REG_OFFSET;\r\nreg_offset <= MAX_DMA_REG_OFFSET; reg_offset += 4) {\r\nreg_space[reg_ix] = readl(ioaddr + reg_offset);\r\nreg_ix++;\r\n}\r\nBUG_ON(reg_ix * 4 > REG_SPACE_SIZE);\r\n}\r\nstatic int sxgbe_get_regs_len(struct net_device *dev)\r\n{\r\nreturn REG_SPACE_SIZE;\r\n}\r\nvoid sxgbe_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &sxgbe_ethtool_ops;\r\n}
