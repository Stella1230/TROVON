static void fhci_gpio_set_value(struct fhci_hcd *fhci, int gpio_nr, bool on)\r\n{\r\nint gpio = fhci->gpios[gpio_nr];\r\nbool alow = fhci->alow_gpios[gpio_nr];\r\nif (!gpio_is_valid(gpio))\r\nreturn;\r\ngpio_set_value(gpio, on ^ alow);\r\nmdelay(5);\r\n}\r\nvoid fhci_config_transceiver(struct fhci_hcd *fhci,\r\nenum fhci_port_status status)\r\n{\r\nfhci_dbg(fhci, "-> %s: %d\n", __func__, status);\r\nswitch (status) {\r\ncase FHCI_PORT_POWER_OFF:\r\nfhci_gpio_set_value(fhci, GPIO_POWER, false);\r\nbreak;\r\ncase FHCI_PORT_DISABLED:\r\ncase FHCI_PORT_WAITING:\r\nfhci_gpio_set_value(fhci, GPIO_POWER, true);\r\nbreak;\r\ncase FHCI_PORT_LOW:\r\nfhci_gpio_set_value(fhci, GPIO_SPEED, false);\r\nbreak;\r\ncase FHCI_PORT_FULL:\r\nfhci_gpio_set_value(fhci, GPIO_SPEED, true);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nfhci_dbg(fhci, "<- %s: %d\n", __func__, status);\r\n}\r\nvoid fhci_port_disable(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = (struct fhci_usb *)fhci->usb_lld;\r\nenum fhci_port_status port_status;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nfhci_stop_sof_timer(fhci);\r\nfhci_flush_all_transmissions(usb);\r\nfhci_usb_disable_interrupt((struct fhci_usb *)fhci->usb_lld);\r\nport_status = usb->port_status;\r\nusb->port_status = FHCI_PORT_DISABLED;\r\nusb->saved_msk |= USB_E_IDLE_MASK;\r\nout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\r\nif (port_status == FHCI_PORT_WAITING)\r\nfhci_device_connected_interrupt(fhci);\r\nusb->vroot_hub->port.wPortStatus &= ~USB_PORT_STAT_ENABLE;\r\nusb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_ENABLE;\r\nfhci_usb_enable_interrupt((struct fhci_usb *)fhci->usb_lld);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nvoid fhci_port_enable(void *lld)\r\n{\r\nstruct fhci_usb *usb = (struct fhci_usb *)lld;\r\nstruct fhci_hcd *fhci = usb->fhci;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nfhci_config_transceiver(fhci, usb->port_status);\r\nif ((usb->port_status != FHCI_PORT_FULL) &&\r\n(usb->port_status != FHCI_PORT_LOW))\r\nfhci_start_sof_timer(fhci);\r\nusb->vroot_hub->port.wPortStatus |= USB_PORT_STAT_ENABLE;\r\nusb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_ENABLE;\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nvoid fhci_io_port_generate_reset(struct fhci_hcd *fhci)\r\n{\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\ngpio_direction_output(fhci->gpios[GPIO_USBOE], 0);\r\ngpio_direction_output(fhci->gpios[GPIO_USBTP], 0);\r\ngpio_direction_output(fhci->gpios[GPIO_USBTN], 0);\r\nmdelay(5);\r\nqe_pin_set_dedicated(fhci->pins[PIN_USBOE]);\r\nqe_pin_set_dedicated(fhci->pins[PIN_USBTP]);\r\nqe_pin_set_dedicated(fhci->pins[PIN_USBTN]);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nvoid fhci_port_reset(void *lld)\r\n{\r\nstruct fhci_usb *usb = (struct fhci_usb *)lld;\r\nstruct fhci_hcd *fhci = usb->fhci;\r\nu8 mode;\r\nu16 mask;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nfhci_stop_sof_timer(fhci);\r\nmode = in_8(&fhci->regs->usb_usmod);\r\nout_8(&fhci->regs->usb_usmod, mode & (~USB_MODE_EN));\r\nmask = in_be16(&fhci->regs->usb_usbmr);\r\nout_be16(&fhci->regs->usb_usbmr, mask & (~USB_E_IDLE_MASK));\r\nfhci_io_port_generate_reset(fhci);\r\nout_be16(&fhci->regs->usb_usbmr, mask);\r\nmode = in_8(&fhci->regs->usb_usmod);\r\nout_8(&fhci->regs->usb_usmod, mode | USB_MODE_EN);\r\nfhci_start_sof_timer(fhci);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nint fhci_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nint ret = 0;\r\nunsigned long flags;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nspin_lock_irqsave(&fhci->lock, flags);\r\nif (fhci->vroot_hub->port.wPortChange & (USB_PORT_STAT_C_CONNECTION |\r\nUSB_PORT_STAT_C_ENABLE | USB_PORT_STAT_C_SUSPEND |\r\nUSB_PORT_STAT_C_RESET | USB_PORT_STAT_C_OVERCURRENT)) {\r\n*buf = 1 << 1;\r\nret = 1;\r\nfhci_dbg(fhci, "-- %s\n", __func__);\r\n}\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\nreturn ret;\r\n}\r\nint fhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nint retval = 0;\r\nstruct usb_hub_status *hub_status;\r\nstruct usb_port_status *port_status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fhci->lock, flags);\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nfhci->vroot_hub->feature &= (1 << wValue);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nfhci->vroot_hub->port.wPortStatus &=\r\n~USB_PORT_STAT_ENABLE;\r\nfhci_port_disable(fhci);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nfhci->vroot_hub->port.wPortChange &=\r\n~USB_PORT_STAT_C_ENABLE;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nfhci->vroot_hub->port.wPortStatus &=\r\n~USB_PORT_STAT_SUSPEND;\r\nfhci_stop_sof_timer(fhci);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nfhci->vroot_hub->port.wPortChange &=\r\n~USB_PORT_STAT_C_SUSPEND;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nfhci->vroot_hub->port.wPortStatus &=\r\n~USB_PORT_STAT_POWER;\r\nfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nfhci->vroot_hub->port.wPortChange &=\r\n~USB_PORT_STAT_C_CONNECTION;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nfhci->vroot_hub->port.wPortChange &=\r\n~USB_PORT_STAT_C_OVERCURRENT;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nfhci->vroot_hub->port.wPortChange &=\r\n~USB_PORT_STAT_C_RESET;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nmemcpy(buf, root_hub_des, sizeof(root_hub_des));\r\nbreak;\r\ncase GetHubStatus:\r\nhub_status = (struct usb_hub_status *)buf;\r\nhub_status->wHubStatus =\r\ncpu_to_le16(fhci->vroot_hub->hub.wHubStatus);\r\nhub_status->wHubChange =\r\ncpu_to_le16(fhci->vroot_hub->hub.wHubChange);\r\nbreak;\r\ncase GetPortStatus:\r\nport_status = (struct usb_port_status *)buf;\r\nport_status->wPortStatus =\r\ncpu_to_le16(fhci->vroot_hub->port.wPortStatus);\r\nport_status->wPortChange =\r\ncpu_to_le16(fhci->vroot_hub->port.wPortChange);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nfhci->vroot_hub->feature |= (1 << wValue);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nfhci->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_ENABLE;\r\nfhci_port_enable(fhci->usb_lld);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nfhci->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_SUSPEND;\r\nfhci_stop_sof_timer(fhci);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nfhci->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_RESET;\r\nfhci_port_reset(fhci->usb_lld);\r\nfhci->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_ENABLE;\r\nfhci->vroot_hub->port.wPortStatus &=\r\n~USB_PORT_STAT_RESET;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nfhci->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_POWER;\r\nfhci_config_transceiver(fhci, FHCI_PORT_WAITING);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\nreturn retval;\r\n}
