static int prism2_result2err(int prism2_result)\r\n{\r\nint err = 0;\r\nswitch (prism2_result) {\r\ncase P80211ENUM_resultcode_invalid_parameters:\r\nerr = -EINVAL;\r\nbreak;\r\ncase P80211ENUM_resultcode_implementation_failure:\r\nerr = -EIO;\r\nbreak;\r\ncase P80211ENUM_resultcode_not_supported:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nerr = 0;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int prism2_domibset_uint32(wlandevice_t *wlandev, u32 did, u32 data)\r\n{\r\nstruct p80211msg_dot11req_mibset msg;\r\np80211item_uint32_t *mibitem =\r\n(p80211item_uint32_t *) &msg.mibattribute.data;\r\nmsg.msgcode = DIDmsg_dot11req_mibset;\r\nmibitem->did = did;\r\nmibitem->data = data;\r\nreturn p80211req_dorequest(wlandev, (u8 *) &msg);\r\n}\r\nstatic int prism2_domibset_pstr32(wlandevice_t *wlandev,\r\nu32 did, u8 len, const u8 *data)\r\n{\r\nstruct p80211msg_dot11req_mibset msg;\r\np80211item_pstr32_t *mibitem =\r\n(p80211item_pstr32_t *) &msg.mibattribute.data;\r\nmsg.msgcode = DIDmsg_dot11req_mibset;\r\nmibitem->did = did;\r\nmibitem->data.len = len;\r\nmemcpy(mibitem->data.data, data, len);\r\nreturn p80211req_dorequest(wlandev, (u8 *) &msg);\r\n}\r\nstatic int prism2_change_virtual_intf(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nu32 data;\r\nint result;\r\nint err = 0;\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (wlandev->macmode == WLAN_MACMODE_IBSS_STA)\r\ngoto exit;\r\nwlandev->macmode = WLAN_MACMODE_IBSS_STA;\r\ndata = 0;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nif (wlandev->macmode == WLAN_MACMODE_ESS_STA)\r\ngoto exit;\r\nwlandev->macmode = WLAN_MACMODE_ESS_STA;\r\ndata = 1;\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "Operation mode: %d not support\n", type);\r\nreturn -EOPNOTSUPP;\r\n}\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_p2_p2Static_p2CnfPortType,\r\ndata);\r\nif (result)\r\nerr = -EFAULT;\r\ndev->ieee80211_ptr->iftype = type;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int prism2_add_key(struct wiphy *wiphy, struct net_device *dev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nu32 did;\r\nint err = 0;\r\nint result = 0;\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,\r\nkey_index);\r\nif (result)\r\ngoto exit;\r\nswitch (key_index) {\r\ncase 0:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;\r\nbreak;\r\ncase 1:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;\r\nbreak;\r\ncase 2:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;\r\nbreak;\r\ncase 3:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nresult = prism2_domibset_pstr32(wlandev, did,\r\nparams->key_len, params->key);\r\nif (result)\r\ngoto exit;\r\nbreak;\r\ndefault:\r\npr_debug("Unsupported cipher suite\n");\r\nresult = 1;\r\n}\r\nexit:\r\nif (result)\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int prism2_get_key(struct wiphy *wiphy, struct net_device *dev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr, void *cookie,\r\nvoid (*callback)(void *cookie, struct key_params*))\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nstruct key_params params;\r\nint len;\r\nif (key_index >= NUM_WEPKEYS)\r\nreturn -EINVAL;\r\nlen = wlandev->wep_keylens[key_index];\r\nmemset(&params, 0, sizeof(params));\r\nif (len == 13)\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP104;\r\nelse if (len == 5)\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP104;\r\nelse\r\nreturn -ENOENT;\r\nparams.key_len = len;\r\nparams.key = wlandev->wep_keys[key_index];\r\nparams.seq_len = 0;\r\ncallback(cookie, &params);\r\nreturn 0;\r\n}\r\nstatic int prism2_del_key(struct wiphy *wiphy, struct net_device *dev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nu32 did;\r\nint err = 0;\r\nint result = 0;\r\nswitch (key_index) {\r\ncase 0:\r\ndid =\r\nDIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;\r\nbreak;\r\ncase 1:\r\ndid =\r\nDIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;\r\nbreak;\r\ncase 2:\r\ndid =\r\nDIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;\r\nbreak;\r\ncase 3:\r\ndid =\r\nDIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nresult = prism2_domibset_pstr32(wlandev, did, 13, "0000000000000");\r\nexit:\r\nif (result)\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int prism2_set_default_key(struct wiphy *wiphy, struct net_device *dev,\r\nu8 key_index, bool unicast, bool multicast)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nint err = 0;\r\nint result = 0;\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,\r\nkey_index);\r\nif (result)\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int prism2_get_station(struct wiphy *wiphy, struct net_device *dev,\r\nconst u8 *mac, struct station_info *sinfo)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nstruct p80211msg_lnxreq_commsquality quality;\r\nint result;\r\nmemset(sinfo, 0, sizeof(*sinfo));\r\nif ((wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING))\r\nreturn -EOPNOTSUPP;\r\nquality.msgcode = DIDmsg_lnxreq_commsquality;\r\nquality.dbm.data = P80211ENUM_truth_true;\r\nquality.dbm.status = P80211ENUM_msgitem_status_data_ok;\r\nif (wlandev->mlmerequest == NULL)\r\nreturn -EOPNOTSUPP;\r\nresult = wlandev->mlmerequest(wlandev, (struct p80211msg *) &quality);\r\nif (result == 0) {\r\nsinfo->txrate.legacy = quality.txrate.data;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\r\nsinfo->signal = quality.level.data;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\r\n}\r\nreturn result;\r\n}\r\nstatic int prism2_scan(struct wiphy *wiphy,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nstruct net_device *dev;\r\nstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\r\nwlandevice_t *wlandev;\r\nstruct p80211msg_dot11req_scan msg1;\r\nstruct p80211msg_dot11req_scan_results msg2;\r\nstruct cfg80211_bss *bss;\r\nint result;\r\nint err = 0;\r\nint numbss = 0;\r\nint i = 0;\r\nu8 ie_buf[46];\r\nint ie_len;\r\nif (!request)\r\nreturn -EINVAL;\r\ndev = request->wdev->netdev;\r\nwlandev = dev->ml_priv;\r\nif (priv->scan_request && priv->scan_request != request)\r\nreturn -EBUSY;\r\nif (wlandev->macmode == WLAN_MACMODE_ESS_AP) {\r\nnetdev_err(dev, "Can't scan in AP mode\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->scan_request = request;\r\nmemset(&msg1, 0x00, sizeof(struct p80211msg_dot11req_scan));\r\nmsg1.msgcode = DIDmsg_dot11req_scan;\r\nmsg1.bsstype.data = P80211ENUM_bsstype_any;\r\nmemset(&msg1.bssid.data.data, 0xFF, sizeof(msg1.bssid.data.data));\r\nmsg1.bssid.data.len = 6;\r\nif (request->n_ssids > 0) {\r\nmsg1.scantype.data = P80211ENUM_scantype_active;\r\nmsg1.ssid.data.len = request->ssids->ssid_len;\r\nmemcpy(msg1.ssid.data.data,\r\nrequest->ssids->ssid, request->ssids->ssid_len);\r\n} else {\r\nmsg1.scantype.data = 0;\r\n}\r\nmsg1.probedelay.data = 0;\r\nfor (i = 0;\r\n(i < request->n_channels) && i < ARRAY_SIZE(prism2_channels);\r\ni++)\r\nmsg1.channellist.data.data[i] =\r\nieee80211_frequency_to_channel(\r\nrequest->channels[i]->center_freq);\r\nmsg1.channellist.data.len = request->n_channels;\r\nmsg1.maxchanneltime.data = 250;\r\nmsg1.minchanneltime.data = 200;\r\nresult = p80211req_dorequest(wlandev, (u8 *) &msg1);\r\nif (result) {\r\nerr = prism2_result2err(msg1.resultcode.data);\r\ngoto exit;\r\n}\r\nnumbss = msg1.numbss.data;\r\nfor (i = 0; i < numbss; i++) {\r\nint freq;\r\nmemset(&msg2, 0, sizeof(msg2));\r\nmsg2.msgcode = DIDmsg_dot11req_scan_results;\r\nmsg2.bssindex.data = i;\r\nresult = p80211req_dorequest(wlandev, (u8 *) &msg2);\r\nif ((result != 0) ||\r\n(msg2.resultcode.data != P80211ENUM_resultcode_success)) {\r\nbreak;\r\n}\r\nie_buf[0] = WLAN_EID_SSID;\r\nie_buf[1] = msg2.ssid.data.len;\r\nie_len = ie_buf[1] + 2;\r\nmemcpy(&ie_buf[2], &(msg2.ssid.data.data), msg2.ssid.data.len);\r\nfreq = ieee80211_channel_to_frequency(msg2.dschannel.data,\r\nIEEE80211_BAND_2GHZ);\r\nbss = cfg80211_inform_bss(wiphy,\r\nieee80211_get_channel(wiphy, freq),\r\nCFG80211_BSS_FTYPE_UNKNOWN,\r\n(const u8 *) &(msg2.bssid.data.data),\r\nmsg2.timestamp.data, msg2.capinfo.data,\r\nmsg2.beaconperiod.data,\r\nie_buf,\r\nie_len,\r\n(msg2.signal.data - 65536) * 100,\r\nGFP_KERNEL\r\n);\r\nif (!bss) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ncfg80211_put_bss(wiphy, bss);\r\n}\r\nif (result)\r\nerr = prism2_result2err(msg2.resultcode.data);\r\nexit:\r\ncfg80211_scan_done(request, err ? 1 : 0);\r\npriv->scan_request = NULL;\r\nreturn err;\r\n}\r\nstatic int prism2_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\r\nwlandevice_t *wlandev = priv->wlandev;\r\nu32 data;\r\nint result;\r\nint err = 0;\r\nif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\r\nif (wiphy->rts_threshold == -1)\r\ndata = 2347;\r\nelse\r\ndata = wiphy->rts_threshold;\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold,\r\ndata);\r\nif (result) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\n}\r\nif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\r\nif (wiphy->frag_threshold == -1)\r\ndata = 2346;\r\nelse\r\ndata = wiphy->frag_threshold;\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold,\r\ndata);\r\nif (result) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nstatic int prism2_connect(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nstruct ieee80211_channel *channel = sme->channel;\r\nstruct p80211msg_lnxreq_autojoin msg_join;\r\nu32 did;\r\nint length = sme->ssid_len;\r\nint chan = -1;\r\nint is_wep = (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||\r\n(sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);\r\nint result;\r\nint err = 0;\r\nif (channel) {\r\nchan = ieee80211_frequency_to_channel(channel->center_freq);\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel,\r\nchan);\r\nif (result)\r\ngoto exit;\r\n}\r\nif ((sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) ||\r\n((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))\r\nmsg_join.authtype.data = P80211ENUM_authalg_opensystem;\r\nelse if ((sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) ||\r\n((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && is_wep))\r\nmsg_join.authtype.data = P80211ENUM_authalg_sharedkey;\r\nelse\r\nnetdev_warn(dev,\r\n"Unhandled authorisation type for connect (%d)\n",\r\nsme->auth_type);\r\nif (is_wep) {\r\nif (sme->key) {\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,\r\nsme->key_idx);\r\nif (result)\r\ngoto exit;\r\nswitch (sme->key_idx) {\r\ncase 0:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;\r\nbreak;\r\ncase 1:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;\r\nbreak;\r\ncase 2:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;\r\nbreak;\r\ncase 3:\r\ndid = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nresult = prism2_domibset_pstr32(wlandev,\r\ndid, sme->key_len,\r\n(u8 *)sme->key);\r\nif (result)\r\ngoto exit;\r\n}\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,\r\nP80211ENUM_truth_true);\r\nif (result)\r\ngoto exit;\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,\r\nP80211ENUM_truth_true);\r\nif (result)\r\ngoto exit;\r\n} else {\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,\r\nP80211ENUM_truth_false);\r\nif (result)\r\ngoto exit;\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,\r\nP80211ENUM_truth_false);\r\nif (result)\r\ngoto exit;\r\n}\r\nmsg_join.msgcode = DIDmsg_lnxreq_autojoin;\r\nmemcpy(msg_join.ssid.data.data, sme->ssid, length);\r\nmsg_join.ssid.data.len = length;\r\nresult = p80211req_dorequest(wlandev, (u8 *) &msg_join);\r\nexit:\r\nif (result)\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int prism2_disconnect(struct wiphy *wiphy, struct net_device *dev,\r\nu16 reason_code)\r\n{\r\nwlandevice_t *wlandev = dev->ml_priv;\r\nstruct p80211msg_lnxreq_autojoin msg_join;\r\nint result;\r\nint err = 0;\r\nmsg_join.msgcode = DIDmsg_lnxreq_autojoin;\r\nmemcpy(msg_join.ssid.data.data, "---", 3);\r\nmsg_join.ssid.data.len = 3;\r\nresult = p80211req_dorequest(wlandev, (u8 *) &msg_join);\r\nif (result)\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int prism2_join_ibss(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int prism2_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int prism2_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type, int mbm)\r\n{\r\nstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\r\nwlandevice_t *wlandev = priv->wlandev;\r\nu32 data;\r\nint result;\r\nint err = 0;\r\nif (type == NL80211_TX_POWER_AUTOMATIC)\r\ndata = 30;\r\nelse\r\ndata = MBM_TO_DBM(mbm);\r\nresult = prism2_domibset_uint32(wlandev,\r\nDIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel,\r\ndata);\r\nif (result) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nstatic int prism2_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nint *dbm)\r\n{\r\nstruct prism2_wiphy_private *priv = wiphy_priv(wiphy);\r\nwlandevice_t *wlandev = priv->wlandev;\r\nstruct p80211msg_dot11req_mibget msg;\r\np80211item_uint32_t *mibitem;\r\nint result;\r\nint err = 0;\r\nmibitem = (p80211item_uint32_t *) &msg.mibattribute.data;\r\nmsg.msgcode = DIDmsg_dot11req_mibget;\r\nmibitem->did =\r\nDIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;\r\nresult = p80211req_dorequest(wlandev, (u8 *) &msg);\r\nif (result) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\n*dbm = mibitem->data;\r\nexit:\r\nreturn err;\r\n}\r\nvoid prism2_connect_result(wlandevice_t *wlandev, u8 failed)\r\n{\r\nu16 status = failed ?\r\nWLAN_STATUS_UNSPECIFIED_FAILURE : WLAN_STATUS_SUCCESS;\r\ncfg80211_connect_result(wlandev->netdev, wlandev->bssid,\r\nNULL, 0, NULL, 0, status, GFP_KERNEL);\r\n}\r\nvoid prism2_disconnected(wlandevice_t *wlandev)\r\n{\r\ncfg80211_disconnected(wlandev->netdev, 0, NULL,\r\n0, false, GFP_KERNEL);\r\n}\r\nvoid prism2_roamed(wlandevice_t *wlandev)\r\n{\r\ncfg80211_roamed(wlandev->netdev, NULL, wlandev->bssid,\r\nNULL, 0, NULL, 0, GFP_KERNEL);\r\n}\r\nstatic struct wiphy *wlan_create_wiphy(struct device *dev, wlandevice_t *wlandev)\r\n{\r\nstruct wiphy *wiphy;\r\nstruct prism2_wiphy_private *priv;\r\nwiphy = wiphy_new(&prism2_usb_cfg_ops, sizeof(*priv));\r\nif (!wiphy)\r\nreturn NULL;\r\npriv = wiphy_priv(wiphy);\r\npriv->wlandev = wlandev;\r\nmemcpy(priv->channels, prism2_channels, sizeof(prism2_channels));\r\nmemcpy(priv->rates, prism2_rates, sizeof(prism2_rates));\r\npriv->band.channels = priv->channels;\r\npriv->band.n_channels = ARRAY_SIZE(prism2_channels);\r\npriv->band.bitrates = priv->rates;\r\npriv->band.n_bitrates = ARRAY_SIZE(prism2_rates);\r\npriv->band.band = IEEE80211_BAND_2GHZ;\r\npriv->band.ht_cap.ht_supported = false;\r\nwiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band;\r\nset_wiphy_dev(wiphy, dev);\r\nwiphy->privid = prism2_wiphy_privid;\r\nwiphy->max_scan_ssids = 1;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\r\n| BIT(NL80211_IFTYPE_ADHOC);\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->n_cipher_suites = PRISM2_NUM_CIPHER_SUITES;\r\nwiphy->cipher_suites = prism2_cipher_suites;\r\nif (wiphy_register(wiphy) < 0)\r\nreturn NULL;\r\nreturn wiphy;\r\n}\r\nstatic void wlan_free_wiphy(struct wiphy *wiphy)\r\n{\r\nwiphy_unregister(wiphy);\r\nwiphy_free(wiphy);\r\n}
