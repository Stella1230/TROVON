static enum drm_connector_status imx_pd_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int imx_pd_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_parallel_display *imxpd = con_to_imxpd(connector);\r\nstruct device_node *np = imxpd->dev->of_node;\r\nint num_modes = 0;\r\nif (imxpd->panel && imxpd->panel->funcs &&\r\nimxpd->panel->funcs->get_modes) {\r\nnum_modes = imxpd->panel->funcs->get_modes(imxpd->panel);\r\nif (num_modes > 0)\r\nreturn num_modes;\r\n}\r\nif (imxpd->edid) {\r\ndrm_mode_connector_update_edid_property(connector, imxpd->edid);\r\nnum_modes = drm_add_edid_modes(connector, imxpd->edid);\r\n}\r\nif (imxpd->mode_valid) {\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\nif (!mode)\r\nreturn -EINVAL;\r\ndrm_mode_copy(mode, &imxpd->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nif (np) {\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\nif (!mode)\r\nreturn -EINVAL;\r\nof_get_drm_display_mode(np, &imxpd->mode, OF_USE_NATIVE_MODE);\r\ndrm_mode_copy(mode, &imxpd->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nreturn num_modes;\r\n}\r\nstatic struct drm_encoder *imx_pd_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct imx_parallel_display *imxpd = con_to_imxpd(connector);\r\nreturn &imxpd->encoder;\r\n}\r\nstatic void imx_pd_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct imx_parallel_display *imxpd = enc_to_imxpd(encoder);\r\nif (mode != DRM_MODE_DPMS_ON)\r\ndrm_panel_disable(imxpd->panel);\r\nelse\r\ndrm_panel_enable(imxpd->panel);\r\n}\r\nstatic bool imx_pd_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void imx_pd_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct imx_parallel_display *imxpd = enc_to_imxpd(encoder);\r\nimx_drm_set_bus_format(encoder, imxpd->bus_format);\r\n}\r\nstatic void imx_pd_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct imx_parallel_display *imxpd = enc_to_imxpd(encoder);\r\ndrm_panel_prepare(imxpd->panel);\r\ndrm_panel_enable(imxpd->panel);\r\n}\r\nstatic void imx_pd_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *orig_mode,\r\nstruct drm_display_mode *mode)\r\n{\r\n}\r\nstatic void imx_pd_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_parallel_display *imxpd = enc_to_imxpd(encoder);\r\ndrm_panel_disable(imxpd->panel);\r\ndrm_panel_unprepare(imxpd->panel);\r\n}\r\nstatic int imx_pd_register(struct drm_device *drm,\r\nstruct imx_parallel_display *imxpd)\r\n{\r\nint ret;\r\nret = imx_drm_encoder_parse_of(drm, &imxpd->encoder,\r\nimxpd->dev->of_node);\r\nif (ret)\r\nreturn ret;\r\nimxpd->connector.dpms = DRM_MODE_DPMS_OFF;\r\ndrm_encoder_helper_add(&imxpd->encoder, &imx_pd_encoder_helper_funcs);\r\ndrm_encoder_init(drm, &imxpd->encoder, &imx_pd_encoder_funcs,\r\nDRM_MODE_ENCODER_NONE);\r\ndrm_connector_helper_add(&imxpd->connector,\r\n&imx_pd_connector_helper_funcs);\r\ndrm_connector_init(drm, &imxpd->connector, &imx_pd_connector_funcs,\r\nDRM_MODE_CONNECTOR_VGA);\r\nif (imxpd->panel)\r\ndrm_panel_attach(imxpd->panel, &imxpd->connector);\r\ndrm_mode_connector_attach_encoder(&imxpd->connector, &imxpd->encoder);\r\nimxpd->connector.encoder = &imxpd->encoder;\r\nreturn 0;\r\n}\r\nstatic int imx_pd_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *drm = data;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *port;\r\nconst u8 *edidp;\r\nstruct imx_parallel_display *imxpd;\r\nint ret;\r\nconst char *fmt;\r\nimxpd = devm_kzalloc(dev, sizeof(*imxpd), GFP_KERNEL);\r\nif (!imxpd)\r\nreturn -ENOMEM;\r\nedidp = of_get_property(np, "edid", &imxpd->edid_len);\r\nif (edidp)\r\nimxpd->edid = kmemdup(edidp, imxpd->edid_len, GFP_KERNEL);\r\nret = of_property_read_string(np, "interface-pix-fmt", &fmt);\r\nif (!ret) {\r\nif (!strcmp(fmt, "rgb24"))\r\nimxpd->bus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nelse if (!strcmp(fmt, "rgb565"))\r\nimxpd->bus_format = MEDIA_BUS_FMT_RGB565_1X16;\r\nelse if (!strcmp(fmt, "bgr666"))\r\nimxpd->bus_format = MEDIA_BUS_FMT_RGB666_1X18;\r\nelse if (!strcmp(fmt, "lvds666"))\r\nimxpd->bus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;\r\n}\r\nport = of_graph_get_port_by_id(np, 1);\r\nif (port) {\r\nstruct device_node *endpoint, *remote;\r\nendpoint = of_get_child_by_name(port, "endpoint");\r\nif (endpoint) {\r\nremote = of_graph_get_remote_port_parent(endpoint);\r\nif (remote)\r\nimxpd->panel = of_drm_find_panel(remote);\r\nif (!imxpd->panel)\r\nreturn -EPROBE_DEFER;\r\n}\r\n}\r\nimxpd->dev = dev;\r\nret = imx_pd_register(drm, imxpd);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, imxpd);\r\nreturn 0;\r\n}\r\nstatic void imx_pd_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct imx_parallel_display *imxpd = dev_get_drvdata(dev);\r\nimxpd->encoder.funcs->destroy(&imxpd->encoder);\r\nimxpd->connector.funcs->destroy(&imxpd->connector);\r\nkfree(imxpd->edid);\r\n}\r\nstatic int imx_pd_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &imx_pd_ops);\r\n}\r\nstatic int imx_pd_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &imx_pd_ops);\r\nreturn 0;\r\n}
