static s32 fm10k_reset_hw_pf(struct fm10k_hw *hw)\r\n{\r\ns32 err;\r\nu32 reg;\r\nu16 i;\r\nfm10k_write_reg(hw, FM10K_EIMR, FM10K_EIMR_DISABLE(ALL));\r\nfm10k_write_reg(hw, FM10K_ITR2(0), 0);\r\nfm10k_write_reg(hw, FM10K_INT_CTRL, 0);\r\nfor (i = 0; i < FM10K_TQMAP_TABLE_SIZE; i++) {\r\nfm10k_write_reg(hw, FM10K_TQMAP(i), 0);\r\nfm10k_write_reg(hw, FM10K_RQMAP(i), 0);\r\n}\r\nerr = fm10k_disable_queues_generic(hw, FM10K_MAX_QUEUES);\r\nif (err)\r\nreturn err;\r\nreg = fm10k_read_reg(hw, FM10K_DMA_CTRL);\r\nif (reg & (FM10K_DMA_CTRL_TX_ACTIVE | FM10K_DMA_CTRL_RX_ACTIVE))\r\nreturn FM10K_ERR_DMA_PENDING;\r\nreg |= FM10K_DMA_CTRL_DATAPATH_RESET;\r\nfm10k_write_reg(hw, FM10K_DMA_CTRL, reg);\r\nfm10k_write_flush(hw);\r\nudelay(FM10K_RESET_TIMEOUT);\r\nreg = fm10k_read_reg(hw, FM10K_IP);\r\nif (!(reg & FM10K_IP_NOTINRESET))\r\nerr = FM10K_ERR_RESET_FAILED;\r\nreturn err;\r\n}\r\nstatic bool fm10k_is_ari_hierarchy_pf(struct fm10k_hw *hw)\r\n{\r\nu16 sriov_ctrl = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_SRIOV_CTRL);\r\nreturn !!(sriov_ctrl & FM10K_PCIE_SRIOV_CTRL_VFARI);\r\n}\r\nstatic s32 fm10k_init_hw_pf(struct fm10k_hw *hw)\r\n{\r\nu32 dma_ctrl, txqctl;\r\nu16 i;\r\nfm10k_write_reg(hw, FM10K_DGLORTDEC(fm10k_dglort_default), 0);\r\nfm10k_write_reg(hw, FM10K_DGLORTMAP(fm10k_dglort_default),\r\nFM10K_DGLORTMAP_ANY);\r\nfor (i = 1; i < FM10K_DGLORT_COUNT; i++)\r\nfm10k_write_reg(hw, FM10K_DGLORTMAP(i), FM10K_DGLORTMAP_NONE);\r\nfm10k_write_reg(hw, FM10K_ITR2(0), 0);\r\nfm10k_write_reg(hw, FM10K_ITR2(FM10K_ITR_REG_COUNT_PF), 0);\r\nfor (i = 1; i < FM10K_ITR_REG_COUNT_PF; i++)\r\nfm10k_write_reg(hw, FM10K_ITR2(i), i - 1);\r\nfm10k_write_reg(hw, FM10K_INT_CTRL, FM10K_INT_CTRL_ENABLEMODERATOR);\r\ntxqctl = FM10K_TXQCTL_PF | FM10K_TXQCTL_UNLIMITED_BW |\r\n(hw->mac.default_vid << FM10K_TXQCTL_VID_SHIFT);\r\nfor (i = 0; i < FM10K_MAX_QUEUES; i++) {\r\nfm10k_write_reg(hw, FM10K_TQDLOC(i),\r\n(i * FM10K_TQDLOC_BASE_32_DESC) |\r\nFM10K_TQDLOC_SIZE_32_DESC);\r\nfm10k_write_reg(hw, FM10K_TXQCTL(i), txqctl);\r\nfm10k_write_reg(hw, FM10K_TPH_TXCTRL(i),\r\nFM10K_TPH_TXCTRL_DESC_TPHEN |\r\nFM10K_TPH_TXCTRL_DESC_RROEN |\r\nFM10K_TPH_TXCTRL_DESC_WROEN |\r\nFM10K_TPH_TXCTRL_DATA_RROEN);\r\nfm10k_write_reg(hw, FM10K_TPH_RXCTRL(i),\r\nFM10K_TPH_RXCTRL_DESC_TPHEN |\r\nFM10K_TPH_RXCTRL_DESC_RROEN |\r\nFM10K_TPH_RXCTRL_DATA_WROEN |\r\nFM10K_TPH_RXCTRL_HDR_WROEN);\r\n}\r\nswitch (hw->bus.speed) {\r\ncase fm10k_bus_speed_2500:\r\ndma_ctrl = FM10K_DMA_CTRL_MAX_HOLD_1US_GEN1;\r\nbreak;\r\ncase fm10k_bus_speed_5000:\r\ndma_ctrl = FM10K_DMA_CTRL_MAX_HOLD_1US_GEN2;\r\nbreak;\r\ncase fm10k_bus_speed_8000:\r\ndma_ctrl = FM10K_DMA_CTRL_MAX_HOLD_1US_GEN3;\r\nbreak;\r\ndefault:\r\ndma_ctrl = 0;\r\nbreak;\r\n}\r\nfm10k_write_reg(hw, FM10K_DTXTCPFLGL, FM10K_TSO_FLAGS_LOW);\r\nfm10k_write_reg(hw, FM10K_DTXTCPFLGH, FM10K_TSO_FLAGS_HI);\r\ndma_ctrl |= FM10K_DMA_CTRL_TX_ENABLE | FM10K_DMA_CTRL_RX_ENABLE |\r\nFM10K_DMA_CTRL_RX_DESC_SIZE | FM10K_DMA_CTRL_MINMSS_64 |\r\nFM10K_DMA_CTRL_32_DESC;\r\nfm10k_write_reg(hw, FM10K_DMA_CTRL, dma_ctrl);\r\nhw->mac.max_queues = FM10K_MAX_QUEUES_PF;\r\nhw->iov.total_vfs = fm10k_is_ari_hierarchy_pf(hw) ? 64 : 7;\r\nreturn 0;\r\n}\r\nstatic bool fm10k_is_slot_appropriate_pf(struct fm10k_hw *hw)\r\n{\r\nreturn (hw->bus.speed == hw->bus_caps.speed) &&\r\n(hw->bus.width == hw->bus_caps.width);\r\n}\r\nstatic s32 fm10k_update_vlan_pf(struct fm10k_hw *hw, u32 vid, u8 vsi, bool set)\r\n{\r\nu32 vlan_table, reg, mask, bit, len;\r\nif (vsi > FM10K_VLAN_TABLE_VSI_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nlen = vid >> 16;\r\nvid = (vid << 17) >> 17;\r\nif (len >= FM10K_VLAN_TABLE_VID_MAX || vid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nfor (reg = FM10K_VLAN_TABLE(vsi, vid / 32), bit = vid % 32;\r\nlen < FM10K_VLAN_TABLE_VID_MAX;\r\nlen -= 32 - bit, reg++, bit = 0) {\r\nvlan_table = fm10k_read_reg(hw, reg);\r\nmask = (~(u32)0 >> ((len < 31) ? 31 - len : 0)) << bit;\r\nmask &= set ? ~vlan_table : vlan_table;\r\nif (mask)\r\nfm10k_write_reg(hw, reg, vlan_table ^ mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_read_mac_addr_pf(struct fm10k_hw *hw)\r\n{\r\nu8 perm_addr[ETH_ALEN];\r\nu32 serial_num;\r\nint i;\r\nserial_num = fm10k_read_reg(hw, FM10K_SM_AREA(1));\r\nif ((~serial_num) << 24)\r\nreturn FM10K_ERR_INVALID_MAC_ADDR;\r\nperm_addr[0] = (u8)(serial_num >> 24);\r\nperm_addr[1] = (u8)(serial_num >> 16);\r\nperm_addr[2] = (u8)(serial_num >> 8);\r\nserial_num = fm10k_read_reg(hw, FM10K_SM_AREA(0));\r\nif ((~serial_num) >> 24)\r\nreturn FM10K_ERR_INVALID_MAC_ADDR;\r\nperm_addr[3] = (u8)(serial_num >> 16);\r\nperm_addr[4] = (u8)(serial_num >> 8);\r\nperm_addr[5] = (u8)(serial_num);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nhw->mac.perm_addr[i] = perm_addr[i];\r\nhw->mac.addr[i] = perm_addr[i];\r\n}\r\nreturn 0;\r\n}\r\nbool fm10k_glort_valid_pf(struct fm10k_hw *hw, u16 glort)\r\n{\r\nglort &= hw->mac.dglort_map >> FM10K_DGLORTMAP_MASK_SHIFT;\r\nreturn glort == (hw->mac.dglort_map & FM10K_DGLORTMAP_NONE);\r\n}\r\nstatic s32 fm10k_update_xc_addr_pf(struct fm10k_hw *hw, u16 glort,\r\nconst u8 *mac, u16 vid, bool add, u8 flags)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nstruct fm10k_mac_update mac_update;\r\nu32 msg[5];\r\nvid &= ~FM10K_VLAN_CLEAR;\r\nif (!fm10k_glort_valid_pf(hw, glort) || vid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nmac_update.mac_lower = cpu_to_le32(((u32)mac[2] << 24) |\r\n((u32)mac[3] << 16) |\r\n((u32)mac[4] << 8) |\r\n((u32)mac[5]));\r\nmac_update.mac_upper = cpu_to_le16(((u32)mac[0] << 8) |\r\n((u32)mac[1]));\r\nmac_update.vlan = cpu_to_le16(vid);\r\nmac_update.glort = cpu_to_le16(glort);\r\nmac_update.action = add ? 0 : 1;\r\nmac_update.flags = flags;\r\nfm10k_tlv_msg_init(msg, FM10K_PF_MSG_ID_UPDATE_MAC_FWD_RULE);\r\nfm10k_tlv_attr_put_le_struct(msg, FM10K_PF_ATTR_ID_MAC_UPDATE,\r\n&mac_update, sizeof(mac_update));\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic s32 fm10k_update_uc_addr_pf(struct fm10k_hw *hw, u16 glort,\r\nconst u8 *mac, u16 vid, bool add, u8 flags)\r\n{\r\nif (!is_valid_ether_addr(mac))\r\nreturn FM10K_ERR_PARAM;\r\nreturn fm10k_update_xc_addr_pf(hw, glort, mac, vid, add, flags);\r\n}\r\nstatic s32 fm10k_update_mc_addr_pf(struct fm10k_hw *hw, u16 glort,\r\nconst u8 *mac, u16 vid, bool add)\r\n{\r\nif (!is_multicast_ether_addr(mac))\r\nreturn FM10K_ERR_PARAM;\r\nreturn fm10k_update_xc_addr_pf(hw, glort, mac, vid, add, 0);\r\n}\r\nstatic s32 fm10k_update_xcast_mode_pf(struct fm10k_hw *hw, u16 glort, u8 mode)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[3], xcast_mode;\r\nif (mode > FM10K_XCAST_MODE_NONE)\r\nreturn FM10K_ERR_PARAM;\r\nif (!fm10k_glort_valid_pf(hw, glort))\r\nreturn FM10K_ERR_PARAM;\r\nxcast_mode = ((u32)mode << 16) | glort;\r\nfm10k_tlv_msg_init(msg, FM10K_PF_MSG_ID_XCAST_MODES);\r\nfm10k_tlv_attr_put_u32(msg, FM10K_PF_ATTR_ID_XCAST_MODE, xcast_mode);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic void fm10k_update_int_moderator_pf(struct fm10k_hw *hw)\r\n{\r\nu32 i;\r\nfm10k_write_reg(hw, FM10K_INT_CTRL, 0);\r\nfor (i = FM10K_ITR_REG_COUNT_PF - 1; i; i--) {\r\nif (!fm10k_read_reg(hw, FM10K_MSIX_VECTOR_MASK(i)))\r\nbreak;\r\n}\r\nfm10k_write_reg(hw, FM10K_ITR2(FM10K_ITR_REG_COUNT_PF), i);\r\nif (!hw->iov.num_vfs)\r\nfm10k_write_reg(hw, FM10K_ITR2(0), i);\r\nfm10k_write_reg(hw, FM10K_INT_CTRL, FM10K_INT_CTRL_ENABLEMODERATOR);\r\n}\r\nstatic s32 fm10k_update_lport_state_pf(struct fm10k_hw *hw, u16 glort,\r\nu16 count, bool enable)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[3], lport_msg;\r\nif (!count)\r\nreturn 0;\r\nif (!fm10k_glort_valid_pf(hw, glort))\r\nreturn FM10K_ERR_PARAM;\r\nlport_msg = ((u32)count << 16) | glort;\r\nfm10k_tlv_msg_init(msg, enable ? FM10K_PF_MSG_ID_LPORT_CREATE :\r\nFM10K_PF_MSG_ID_LPORT_DELETE);\r\nfm10k_tlv_attr_put_u32(msg, FM10K_PF_ATTR_ID_PORT, lport_msg);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic s32 fm10k_configure_dglort_map_pf(struct fm10k_hw *hw,\r\nstruct fm10k_dglort_cfg *dglort)\r\n{\r\nu16 glort, queue_count, vsi_count, pc_count;\r\nu16 vsi, queue, pc, q_idx;\r\nu32 txqctl, dglortdec, dglortmap;\r\nif (!dglort)\r\nreturn FM10K_ERR_PARAM;\r\nif ((dglort->idx > 7) || (dglort->rss_l > 7) || (dglort->pc_l > 3) ||\r\n(dglort->vsi_l > 6) || (dglort->vsi_b > 64) ||\r\n(dglort->queue_l > 8) || (dglort->queue_b >= 256))\r\nreturn FM10K_ERR_PARAM;\r\nqueue_count = 1 << (dglort->rss_l + dglort->pc_l);\r\nvsi_count = 1 << (dglort->vsi_l + dglort->queue_l);\r\nglort = dglort->glort;\r\nq_idx = dglort->queue_b;\r\nfor (vsi = 0; vsi < vsi_count; vsi++, glort++) {\r\nfor (queue = 0; queue < queue_count; queue++, q_idx++) {\r\nif (q_idx >= FM10K_MAX_QUEUES)\r\nbreak;\r\nfm10k_write_reg(hw, FM10K_TX_SGLORT(q_idx), glort);\r\nfm10k_write_reg(hw, FM10K_RX_SGLORT(q_idx), glort);\r\n}\r\n}\r\nqueue_count = 1 << (dglort->queue_l + dglort->rss_l + dglort->vsi_l);\r\npc_count = 1 << dglort->pc_l;\r\nfor (pc = 0; pc < pc_count; pc++) {\r\nq_idx = pc + dglort->queue_b;\r\nfor (queue = 0; queue < queue_count; queue++) {\r\nif (q_idx >= FM10K_MAX_QUEUES)\r\nbreak;\r\ntxqctl = fm10k_read_reg(hw, FM10K_TXQCTL(q_idx));\r\ntxqctl &= ~FM10K_TXQCTL_PC_MASK;\r\ntxqctl |= pc << FM10K_TXQCTL_PC_SHIFT;\r\nfm10k_write_reg(hw, FM10K_TXQCTL(q_idx), txqctl);\r\nq_idx += pc_count;\r\n}\r\n}\r\ndglortdec = ((u32)(dglort->rss_l) << FM10K_DGLORTDEC_RSSLENGTH_SHIFT) |\r\n((u32)(dglort->queue_b) << FM10K_DGLORTDEC_QBASE_SHIFT) |\r\n((u32)(dglort->pc_l) << FM10K_DGLORTDEC_PCLENGTH_SHIFT) |\r\n((u32)(dglort->vsi_b) << FM10K_DGLORTDEC_VSIBASE_SHIFT) |\r\n((u32)(dglort->vsi_l) << FM10K_DGLORTDEC_VSILENGTH_SHIFT) |\r\n((u32)(dglort->queue_l));\r\nif (dglort->inner_rss)\r\ndglortdec |= FM10K_DGLORTDEC_INNERRSS_ENABLE;\r\ndglortmap = (dglort->idx == fm10k_dglort_default) ?\r\nFM10K_DGLORTMAP_ANY : FM10K_DGLORTMAP_ZERO;\r\ndglortmap <<= dglort->vsi_l + dglort->queue_l + dglort->shared_l;\r\ndglortmap |= dglort->glort;\r\nfm10k_write_reg(hw, FM10K_DGLORTDEC(dglort->idx), dglortdec);\r\nfm10k_write_reg(hw, FM10K_DGLORTMAP(dglort->idx), dglortmap);\r\nreturn 0;\r\n}\r\nu16 fm10k_queues_per_pool(struct fm10k_hw *hw)\r\n{\r\nu16 num_pools = hw->iov.num_pools;\r\nreturn (num_pools > 32) ? 2 : (num_pools > 16) ? 4 : (num_pools > 8) ?\r\n8 : FM10K_MAX_QUEUES_POOL;\r\n}\r\nu16 fm10k_vf_queue_index(struct fm10k_hw *hw, u16 vf_idx)\r\n{\r\nu16 num_vfs = hw->iov.num_vfs;\r\nu16 vf_q_idx = FM10K_MAX_QUEUES;\r\nvf_q_idx -= fm10k_queues_per_pool(hw) * (num_vfs - vf_idx);\r\nreturn vf_q_idx;\r\n}\r\nstatic u16 fm10k_vectors_per_pool(struct fm10k_hw *hw)\r\n{\r\nu16 num_pools = hw->iov.num_pools;\r\nreturn (num_pools > 32) ? 8 : (num_pools > 16) ? 16 :\r\nFM10K_MAX_VECTORS_POOL;\r\n}\r\nstatic u16 fm10k_vf_vector_index(struct fm10k_hw *hw, u16 vf_idx)\r\n{\r\nu16 vf_v_idx = FM10K_MAX_VECTORS_PF;\r\nvf_v_idx += fm10k_vectors_per_pool(hw) * vf_idx;\r\nreturn vf_v_idx;\r\n}\r\nstatic s32 fm10k_iov_assign_resources_pf(struct fm10k_hw *hw, u16 num_vfs,\r\nu16 num_pools)\r\n{\r\nu16 qmap_stride, qpp, vpp, vf_q_idx, vf_q_idx0, qmap_idx;\r\nu32 vid = hw->mac.default_vid << FM10K_TXQCTL_VID_SHIFT;\r\nint i, j;\r\nif (num_pools > 64)\r\nreturn FM10K_ERR_PARAM;\r\nif ((num_vfs > num_pools) || (num_vfs > hw->iov.total_vfs))\r\nreturn FM10K_ERR_PARAM;\r\nhw->iov.num_vfs = num_vfs;\r\nhw->iov.num_pools = num_pools;\r\nqmap_stride = (num_vfs > 8) ? 32 : 256;\r\nqpp = fm10k_queues_per_pool(hw);\r\nvpp = fm10k_vectors_per_pool(hw);\r\nvf_q_idx = fm10k_vf_queue_index(hw, 0);\r\nqmap_idx = 0;\r\nfor (i = 0; i < num_vfs; i++) {\r\nfm10k_write_reg(hw, FM10K_TC_MAXCREDIT(i), 0);\r\nfm10k_write_reg(hw, FM10K_TC_RATE(i), 0);\r\nfm10k_write_reg(hw, FM10K_TC_CREDIT(i),\r\nFM10K_TC_CREDIT_CREDIT_MASK);\r\n}\r\nfor (i = FM10K_VFMBMEM_LEN * num_vfs; i--;)\r\nfm10k_write_reg(hw, FM10K_MBMEM(i), 0);\r\nfm10k_write_reg(hw, FM10K_PFVFLREC(0), ~0);\r\nfm10k_write_reg(hw, FM10K_PFVFLREC(1), ~0);\r\nfor (i = FM10K_MAX_QUEUES_PF; i < vf_q_idx; i++) {\r\nfm10k_write_reg(hw, FM10K_TXDCTL(i), 0);\r\nfm10k_write_reg(hw, FM10K_TXQCTL(i), FM10K_TXQCTL_PF |\r\nFM10K_TXQCTL_UNLIMITED_BW | vid);\r\nfm10k_write_reg(hw, FM10K_RXQCTL(i), FM10K_RXQCTL_PF);\r\n}\r\nfor (i = FM10K_ITR_REG_COUNT_PF + 1; i < FM10K_ITR_REG_COUNT; i++) {\r\nif (!(i & (vpp - 1)))\r\nfm10k_write_reg(hw, FM10K_ITR2(i), i - vpp);\r\nelse\r\nfm10k_write_reg(hw, FM10K_ITR2(i), i - 1);\r\n}\r\nfm10k_write_reg(hw, FM10K_ITR2(0),\r\nfm10k_vf_vector_index(hw, num_vfs - 1));\r\nfor (i = 0; i < num_vfs; i++) {\r\nvf_q_idx0 = vf_q_idx;\r\nfor (j = 0; j < qpp; j++, qmap_idx++, vf_q_idx++) {\r\nfm10k_write_reg(hw, FM10K_TXDCTL(vf_q_idx), 0);\r\nfm10k_write_reg(hw, FM10K_TXQCTL(vf_q_idx),\r\n(i << FM10K_TXQCTL_TC_SHIFT) | i |\r\nFM10K_TXQCTL_VF | vid);\r\nfm10k_write_reg(hw, FM10K_RXDCTL(vf_q_idx),\r\nFM10K_RXDCTL_WRITE_BACK_MIN_DELAY |\r\nFM10K_RXDCTL_DROP_ON_EMPTY);\r\nfm10k_write_reg(hw, FM10K_RXQCTL(vf_q_idx),\r\nFM10K_RXQCTL_VF |\r\n(i << FM10K_RXQCTL_VF_SHIFT));\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx), vf_q_idx);\r\nfm10k_write_reg(hw, FM10K_RQMAP(qmap_idx), vf_q_idx);\r\n}\r\nfor (; j < qmap_stride; j++, qmap_idx++) {\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx), vf_q_idx0);\r\nfm10k_write_reg(hw, FM10K_RQMAP(qmap_idx), vf_q_idx0);\r\n}\r\n}\r\nwhile (qmap_idx < FM10K_TQMAP_TABLE_SIZE) {\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx), 0);\r\nfm10k_write_reg(hw, FM10K_RQMAP(qmap_idx), 0);\r\nqmap_idx++;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_iov_configure_tc_pf(struct fm10k_hw *hw, u16 vf_idx, int rate)\r\n{\r\nu32 interval = FM10K_TC_RATE_INTERVAL_4US_GEN3;\r\nu32 tc_rate = FM10K_TC_RATE_QUANTA_MASK;\r\nif (vf_idx >= hw->iov.num_vfs)\r\nreturn FM10K_ERR_PARAM;\r\nswitch (hw->bus.speed) {\r\ncase fm10k_bus_speed_2500:\r\ninterval = FM10K_TC_RATE_INTERVAL_4US_GEN1;\r\nbreak;\r\ncase fm10k_bus_speed_5000:\r\ninterval = FM10K_TC_RATE_INTERVAL_4US_GEN2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (rate) {\r\nif (rate > FM10K_VF_TC_MAX || rate < FM10K_VF_TC_MIN)\r\nreturn FM10K_ERR_PARAM;\r\ntc_rate = (rate * 128) / 125;\r\nif (rate < 4000)\r\ninterval <<= 1;\r\nelse\r\ntc_rate >>= 1;\r\n}\r\nfm10k_write_reg(hw, FM10K_TC_RATE(vf_idx), tc_rate | interval);\r\nfm10k_write_reg(hw, FM10K_TC_MAXCREDIT(vf_idx), FM10K_TC_MAXCREDIT_64K);\r\nfm10k_write_reg(hw, FM10K_TC_CREDIT(vf_idx), FM10K_TC_MAXCREDIT_64K);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_iov_assign_int_moderator_pf(struct fm10k_hw *hw, u16 vf_idx)\r\n{\r\nu16 vf_v_idx, vf_v_limit, i;\r\nif (vf_idx >= hw->iov.num_vfs)\r\nreturn FM10K_ERR_PARAM;\r\nvf_v_idx = fm10k_vf_vector_index(hw, vf_idx);\r\nvf_v_limit = vf_v_idx + fm10k_vectors_per_pool(hw);\r\nfor (i = vf_v_limit - 1; i > vf_v_idx; i--) {\r\nif (!fm10k_read_reg(hw, FM10K_MSIX_VECTOR_MASK(i)))\r\nbreak;\r\n}\r\nif (vf_idx == (hw->iov.num_vfs - 1))\r\nfm10k_write_reg(hw, FM10K_ITR2(0), i);\r\nelse\r\nfm10k_write_reg(hw, FM10K_ITR2(vf_v_limit), i);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_iov_assign_default_mac_vlan_pf(struct fm10k_hw *hw,\r\nstruct fm10k_vf_info *vf_info)\r\n{\r\nu16 qmap_stride, queues_per_pool, vf_q_idx, timeout, qmap_idx, i;\r\nu32 msg[4], txdctl, txqctl, tdbal = 0, tdbah = 0;\r\ns32 err = 0;\r\nu16 vf_idx, vf_vid;\r\nif (!vf_info || vf_info->vf_idx >= hw->iov.num_vfs)\r\nreturn FM10K_ERR_PARAM;\r\nqmap_stride = (hw->iov.num_vfs > 8) ? 32 : 256;\r\nqueues_per_pool = fm10k_queues_per_pool(hw);\r\nvf_idx = vf_info->vf_idx;\r\nvf_q_idx = fm10k_vf_queue_index(hw, vf_idx);\r\nqmap_idx = qmap_stride * vf_idx;\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx), 0);\r\nfm10k_write_reg(hw, FM10K_TXDCTL(vf_q_idx), 0);\r\nif (vf_info->pf_vid)\r\nvf_vid = vf_info->pf_vid | FM10K_VLAN_CLEAR;\r\nelse\r\nvf_vid = vf_info->sw_vid;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\r\nfm10k_tlv_attr_put_mac_vlan(msg, FM10K_MAC_VLAN_MSG_DEFAULT_MAC,\r\nvf_info->mac, vf_vid);\r\nif (vf_info->mbx.ops.enqueue_tx)\r\nvf_info->mbx.ops.enqueue_tx(hw, &vf_info->mbx, msg);\r\ntxdctl = fm10k_read_reg(hw, FM10K_TXDCTL(vf_q_idx));\r\nfor (timeout = 0; txdctl & FM10K_TXDCTL_ENABLE; timeout++) {\r\nif (timeout == 10) {\r\nerr = FM10K_ERR_DMA_PENDING;\r\ngoto err_out;\r\n}\r\nusleep_range(100, 200);\r\ntxdctl = fm10k_read_reg(hw, FM10K_TXDCTL(vf_q_idx));\r\n}\r\nif (is_valid_ether_addr(vf_info->mac)) {\r\ntdbal = (((u32)vf_info->mac[3]) << 24) |\r\n(((u32)vf_info->mac[4]) << 16) |\r\n(((u32)vf_info->mac[5]) << 8);\r\ntdbah = (((u32)0xFF) << 24) |\r\n(((u32)vf_info->mac[0]) << 16) |\r\n(((u32)vf_info->mac[1]) << 8) |\r\n((u32)vf_info->mac[2]);\r\n}\r\nfm10k_write_reg(hw, FM10K_TDBAL(vf_q_idx), tdbal);\r\nfm10k_write_reg(hw, FM10K_TDBAH(vf_q_idx), tdbah);\r\nerr_out:\r\ntxqctl = ((u32)vf_vid << FM10K_TXQCTL_VID_SHIFT) &\r\nFM10K_TXQCTL_VID_MASK;\r\ntxqctl |= (vf_idx << FM10K_TXQCTL_TC_SHIFT) |\r\nFM10K_TXQCTL_VF | vf_idx;\r\nfor (i = 0; i < queues_per_pool; i++)\r\nfm10k_write_reg(hw, FM10K_TXQCTL(vf_q_idx + i), txqctl);\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx), vf_q_idx);\r\nreturn err;\r\n}\r\nstatic s32 fm10k_iov_reset_resources_pf(struct fm10k_hw *hw,\r\nstruct fm10k_vf_info *vf_info)\r\n{\r\nu16 qmap_stride, queues_per_pool, vf_q_idx, qmap_idx;\r\nu32 tdbal = 0, tdbah = 0, txqctl, rxqctl;\r\nu16 vf_v_idx, vf_v_limit, vf_vid;\r\nu8 vf_idx = vf_info->vf_idx;\r\nint i;\r\nif (vf_idx >= hw->iov.num_vfs)\r\nreturn FM10K_ERR_PARAM;\r\nfm10k_write_reg(hw, FM10K_PFVFLREC(vf_idx / 32), 1 << (vf_idx % 32));\r\nvf_info->mbx.timeout = 0;\r\nif (vf_info->mbx.ops.disconnect)\r\nvf_info->mbx.ops.disconnect(hw, &vf_info->mbx);\r\nvf_v_idx = fm10k_vf_vector_index(hw, vf_idx);\r\nvf_v_limit = vf_v_idx + fm10k_vectors_per_pool(hw);\r\nqmap_stride = (hw->iov.num_vfs > 8) ? 32 : 256;\r\nqueues_per_pool = fm10k_queues_per_pool(hw);\r\nqmap_idx = qmap_stride * vf_idx;\r\nfor (i = qmap_idx; i < (qmap_idx + qmap_stride); i++) {\r\nfm10k_write_reg(hw, FM10K_TQMAP(i), 0);\r\nfm10k_write_reg(hw, FM10K_RQMAP(i), 0);\r\n}\r\nvf_q_idx = fm10k_vf_queue_index(hw, vf_idx);\r\nif (vf_info->pf_vid)\r\nvf_vid = vf_info->pf_vid;\r\nelse\r\nvf_vid = vf_info->sw_vid;\r\ntxqctl = ((u32)vf_vid << FM10K_TXQCTL_VID_SHIFT) |\r\n(vf_idx << FM10K_TXQCTL_TC_SHIFT) |\r\nFM10K_TXQCTL_VF | vf_idx;\r\nrxqctl = FM10K_RXQCTL_VF | (vf_idx << FM10K_RXQCTL_VF_SHIFT);\r\nfor (i = vf_q_idx; i < (queues_per_pool + vf_q_idx); i++) {\r\nfm10k_write_reg(hw, FM10K_TXDCTL(i), 0);\r\nfm10k_write_reg(hw, FM10K_TXQCTL(i), txqctl);\r\nfm10k_write_reg(hw, FM10K_RXDCTL(i),\r\nFM10K_RXDCTL_WRITE_BACK_MIN_DELAY |\r\nFM10K_RXDCTL_DROP_ON_EMPTY);\r\nfm10k_write_reg(hw, FM10K_RXQCTL(i), rxqctl);\r\n}\r\nfm10k_write_reg(hw, FM10K_TC_MAXCREDIT(vf_idx), 0);\r\nfm10k_write_reg(hw, FM10K_TC_RATE(vf_idx), 0);\r\nfm10k_write_reg(hw, FM10K_TC_CREDIT(vf_idx),\r\nFM10K_TC_CREDIT_CREDIT_MASK);\r\nif (!vf_idx)\r\nhw->mac.ops.update_int_moderator(hw);\r\nelse\r\nhw->iov.ops.assign_int_moderator(hw, vf_idx - 1);\r\nif (vf_idx == (hw->iov.num_vfs - 1))\r\nfm10k_write_reg(hw, FM10K_ITR2(0), vf_v_idx);\r\nelse\r\nfm10k_write_reg(hw, FM10K_ITR2(vf_v_limit), vf_v_idx);\r\nfor (vf_v_idx++; vf_v_idx < vf_v_limit; vf_v_idx++)\r\nfm10k_write_reg(hw, FM10K_ITR2(vf_v_idx), vf_v_idx - 1);\r\nfor (i = FM10K_VFMBMEM_LEN; i--;)\r\nfm10k_write_reg(hw, FM10K_MBMEM_VF(vf_idx, i), 0);\r\nfor (i = FM10K_VLAN_TABLE_SIZE; i--;)\r\nfm10k_write_reg(hw, FM10K_VLAN_TABLE(vf_info->vsi, i), 0);\r\nfor (i = FM10K_RETA_SIZE; i--;)\r\nfm10k_write_reg(hw, FM10K_RETA(vf_info->vsi, i), 0);\r\nfor (i = FM10K_RSSRK_SIZE; i--;)\r\nfm10k_write_reg(hw, FM10K_RSSRK(vf_info->vsi, i), 0);\r\nfm10k_write_reg(hw, FM10K_MRQC(vf_info->vsi), 0);\r\nif (is_valid_ether_addr(vf_info->mac)) {\r\ntdbal = (((u32)vf_info->mac[3]) << 24) |\r\n(((u32)vf_info->mac[4]) << 16) |\r\n(((u32)vf_info->mac[5]) << 8);\r\ntdbah = (((u32)0xFF) << 24) |\r\n(((u32)vf_info->mac[0]) << 16) |\r\n(((u32)vf_info->mac[1]) << 8) |\r\n((u32)vf_info->mac[2]);\r\n}\r\nfor (i = queues_per_pool; i--;) {\r\nfm10k_write_reg(hw, FM10K_TDBAL(vf_q_idx + i), tdbal);\r\nfm10k_write_reg(hw, FM10K_TDBAH(vf_q_idx + i), tdbah);\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx + i), vf_q_idx + i);\r\nfm10k_write_reg(hw, FM10K_RQMAP(qmap_idx + i), vf_q_idx + i);\r\n}\r\nfor (i = queues_per_pool; i < qmap_stride; i++) {\r\nfm10k_write_reg(hw, FM10K_TQMAP(qmap_idx + i), vf_q_idx);\r\nfm10k_write_reg(hw, FM10K_RQMAP(qmap_idx + i), vf_q_idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_iov_set_lport_pf(struct fm10k_hw *hw,\r\nstruct fm10k_vf_info *vf_info,\r\nu16 lport_idx, u8 flags)\r\n{\r\nu16 glort = (hw->mac.dglort_map + lport_idx) & FM10K_DGLORTMAP_NONE;\r\nif (!fm10k_glort_valid_pf(hw, glort))\r\nreturn FM10K_ERR_PARAM;\r\nvf_info->vf_flags = flags | FM10K_VF_FLAG_NONE_CAPABLE;\r\nvf_info->glort = glort;\r\nreturn 0;\r\n}\r\nstatic void fm10k_iov_reset_lport_pf(struct fm10k_hw *hw,\r\nstruct fm10k_vf_info *vf_info)\r\n{\r\nu32 msg[1];\r\nif (FM10K_VF_FLAG_ENABLED(vf_info)) {\r\nfm10k_update_lport_state_pf(hw, vf_info->glort, 1, false);\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\r\nvf_info->mbx.ops.enqueue_tx(hw, &vf_info->mbx, msg);\r\n}\r\nvf_info->vf_flags = 0;\r\nvf_info->glort = 0;\r\n}\r\nstatic void fm10k_iov_update_stats_pf(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats_q *q,\r\nu16 vf_idx)\r\n{\r\nu32 idx, qpp;\r\nqpp = fm10k_queues_per_pool(hw);\r\nidx = fm10k_vf_queue_index(hw, vf_idx);\r\nfm10k_update_hw_stats_q(hw, q, idx, qpp);\r\n}\r\nstatic s32 fm10k_iov_report_timestamp_pf(struct fm10k_hw *hw,\r\nstruct fm10k_vf_info *vf_info,\r\nu64 timestamp)\r\n{\r\nu32 msg[4];\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_1588);\r\nfm10k_tlv_attr_put_u64(msg, FM10K_1588_MSG_TIMESTAMP, timestamp);\r\nreturn vf_info->mbx.ops.enqueue_tx(hw, &vf_info->mbx, msg);\r\n}\r\ns32 fm10k_iov_msg_msix_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\r\nu8 vf_idx = vf_info->vf_idx;\r\nreturn hw->iov.ops.assign_int_moderator(hw, vf_idx);\r\n}\r\ns32 fm10k_iov_msg_mac_vlan_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\r\nint err = 0;\r\nu8 mac[ETH_ALEN];\r\nu32 *result;\r\nu16 vlan;\r\nu32 vid;\r\nif (!FM10K_VF_FLAG_ENABLED(vf_info))\r\nerr = FM10K_ERR_PARAM;\r\nif (!err && !!results[FM10K_MAC_VLAN_MSG_VLAN]) {\r\nresult = results[FM10K_MAC_VLAN_MSG_VLAN];\r\nerr = fm10k_tlv_attr_get_u32(result, &vid);\r\nif (err)\r\nreturn err;\r\nif (!vid || (vid == FM10K_VLAN_CLEAR)) {\r\nif (vf_info->pf_vid)\r\nvid |= vf_info->pf_vid;\r\nelse\r\nvid |= vf_info->sw_vid;\r\n} else if (vid != vf_info->pf_vid) {\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nerr = hw->mac.ops.update_vlan(hw, vid, vf_info->vsi,\r\n!(vid & FM10K_VLAN_CLEAR));\r\n}\r\nif (!err && !!results[FM10K_MAC_VLAN_MSG_MAC]) {\r\nresult = results[FM10K_MAC_VLAN_MSG_MAC];\r\nerr = fm10k_tlv_attr_get_mac_vlan(result, mac, &vlan);\r\nif (err)\r\nreturn err;\r\nif (is_valid_ether_addr(vf_info->mac) &&\r\nmemcmp(mac, vf_info->mac, ETH_ALEN))\r\nreturn FM10K_ERR_PARAM;\r\nif (!vlan || (vlan == FM10K_VLAN_CLEAR)) {\r\nif (vf_info->pf_vid)\r\nvlan |= vf_info->pf_vid;\r\nelse\r\nvlan |= vf_info->sw_vid;\r\n} else if (vf_info->pf_vid) {\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nerr = hw->mac.ops.update_uc_addr(hw, vf_info->glort, mac, vlan,\r\n!(vlan & FM10K_VLAN_CLEAR), 0);\r\n}\r\nif (!err && !!results[FM10K_MAC_VLAN_MSG_MULTICAST]) {\r\nresult = results[FM10K_MAC_VLAN_MSG_MULTICAST];\r\nerr = fm10k_tlv_attr_get_mac_vlan(result, mac, &vlan);\r\nif (err)\r\nreturn err;\r\nif (!(vf_info->vf_flags & FM10K_VF_FLAG_MULTI_ENABLED))\r\nreturn FM10K_ERR_PARAM;\r\nif (!vlan || (vlan == FM10K_VLAN_CLEAR)) {\r\nif (vf_info->pf_vid)\r\nvlan |= vf_info->pf_vid;\r\nelse\r\nvlan |= vf_info->sw_vid;\r\n} else if (vf_info->pf_vid) {\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nerr = hw->mac.ops.update_mc_addr(hw, vf_info->glort, mac, vlan,\r\n!(vlan & FM10K_VLAN_CLEAR));\r\n}\r\nreturn err;\r\n}\r\nstatic u8 fm10k_iov_supported_xcast_mode_pf(struct fm10k_vf_info *vf_info,\r\nu8 mode)\r\n{\r\nu8 vf_flags = vf_info->vf_flags;\r\nswitch (mode) {\r\ncase FM10K_XCAST_MODE_PROMISC:\r\nif (vf_flags & FM10K_VF_FLAG_PROMISC_CAPABLE)\r\nreturn FM10K_XCAST_MODE_PROMISC;\r\ncase FM10K_XCAST_MODE_ALLMULTI:\r\nif (vf_flags & FM10K_VF_FLAG_ALLMULTI_CAPABLE)\r\nreturn FM10K_XCAST_MODE_ALLMULTI;\r\ncase FM10K_XCAST_MODE_MULTI:\r\nif (vf_flags & FM10K_VF_FLAG_MULTI_CAPABLE)\r\nreturn FM10K_XCAST_MODE_MULTI;\r\ncase FM10K_XCAST_MODE_NONE:\r\nif (vf_flags & FM10K_VF_FLAG_NONE_CAPABLE)\r\nreturn FM10K_XCAST_MODE_NONE;\r\ndefault:\r\nbreak;\r\n}\r\nreturn FM10K_XCAST_MODE_DISABLE;\r\n}\r\ns32 fm10k_iov_msg_lport_state_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\r\nu32 *result;\r\ns32 err = 0;\r\nu32 msg[2];\r\nu8 mode = 0;\r\nif (!(vf_info->vf_flags & FM10K_VF_FLAG_NONE_CAPABLE))\r\nreturn FM10K_ERR_PARAM;\r\nif (!!results[FM10K_LPORT_STATE_MSG_XCAST_MODE]) {\r\nresult = results[FM10K_LPORT_STATE_MSG_XCAST_MODE];\r\nerr = fm10k_tlv_attr_get_u8(result, &mode);\r\nif (err)\r\nreturn FM10K_ERR_PARAM;\r\nmode = fm10k_iov_supported_xcast_mode_pf(vf_info, mode);\r\nif (!(FM10K_VF_FLAG_ENABLED(vf_info) & (1 << mode)))\r\nfm10k_update_xcast_mode_pf(hw, vf_info->glort, mode);\r\nmode = FM10K_VF_FLAG_SET_MODE(mode);\r\n} else if (!results[FM10K_LPORT_STATE_MSG_DISABLE]) {\r\nif (FM10K_VF_FLAG_ENABLED(vf_info))\r\nerr = fm10k_update_lport_state_pf(hw, vf_info->glort,\r\n1, false);\r\nif (!err)\r\nvf_info->vf_flags = FM10K_VF_FLAG_CAPABLE(vf_info);\r\nhw->iov.ops.configure_tc(hw, vf_info->vf_idx, vf_info->rate);\r\nmode = FM10K_VF_FLAG_SET_MODE_NONE;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\r\nfm10k_tlv_attr_put_bool(msg, FM10K_LPORT_STATE_MSG_READY);\r\nmbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nif (!err && (!FM10K_VF_FLAG_ENABLED(vf_info) != !mode))\r\nerr = fm10k_update_lport_state_pf(hw, vf_info->glort, 1,\r\n!!mode);\r\nmode |= FM10K_VF_FLAG_CAPABLE(vf_info);\r\nif (!err)\r\nvf_info->vf_flags = mode;\r\nreturn err;\r\n}\r\nstatic void fm10k_update_hw_stats_pf(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats *stats)\r\n{\r\nu32 timeout, ur, ca, um, xec, vlan_drop, loopback_drop, nodesc_drop;\r\nu32 id, id_prev;\r\nid = fm10k_read_reg(hw, FM10K_TXQCTL(0));\r\ndo {\r\ntimeout = fm10k_read_hw_stats_32b(hw, FM10K_STATS_TIMEOUT,\r\n&stats->timeout);\r\nur = fm10k_read_hw_stats_32b(hw, FM10K_STATS_UR, &stats->ur);\r\nca = fm10k_read_hw_stats_32b(hw, FM10K_STATS_CA, &stats->ca);\r\num = fm10k_read_hw_stats_32b(hw, FM10K_STATS_UM, &stats->um);\r\nxec = fm10k_read_hw_stats_32b(hw, FM10K_STATS_XEC, &stats->xec);\r\nvlan_drop = fm10k_read_hw_stats_32b(hw, FM10K_STATS_VLAN_DROP,\r\n&stats->vlan_drop);\r\nloopback_drop = fm10k_read_hw_stats_32b(hw,\r\nFM10K_STATS_LOOPBACK_DROP,\r\n&stats->loopback_drop);\r\nnodesc_drop = fm10k_read_hw_stats_32b(hw,\r\nFM10K_STATS_NODESC_DROP,\r\n&stats->nodesc_drop);\r\nid_prev = id;\r\nid = fm10k_read_reg(hw, FM10K_TXQCTL(0));\r\n} while ((id ^ id_prev) & FM10K_TXQCTL_ID_MASK);\r\nid &= FM10K_TXQCTL_ID_MASK;\r\nid |= FM10K_STAT_VALID;\r\nif (stats->stats_idx == id) {\r\nstats->timeout.count += timeout;\r\nstats->ur.count += ur;\r\nstats->ca.count += ca;\r\nstats->um.count += um;\r\nstats->xec.count += xec;\r\nstats->vlan_drop.count += vlan_drop;\r\nstats->loopback_drop.count += loopback_drop;\r\nstats->nodesc_drop.count += nodesc_drop;\r\n}\r\nfm10k_update_hw_base_32b(&stats->timeout, timeout);\r\nfm10k_update_hw_base_32b(&stats->ur, ur);\r\nfm10k_update_hw_base_32b(&stats->ca, ca);\r\nfm10k_update_hw_base_32b(&stats->um, um);\r\nfm10k_update_hw_base_32b(&stats->xec, xec);\r\nfm10k_update_hw_base_32b(&stats->vlan_drop, vlan_drop);\r\nfm10k_update_hw_base_32b(&stats->loopback_drop, loopback_drop);\r\nfm10k_update_hw_base_32b(&stats->nodesc_drop, nodesc_drop);\r\nstats->stats_idx = id;\r\nfm10k_update_hw_stats_q(hw, stats->q, 0, hw->mac.max_queues);\r\n}\r\nstatic void fm10k_rebind_hw_stats_pf(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats *stats)\r\n{\r\nfm10k_unbind_hw_stats_32b(&stats->timeout);\r\nfm10k_unbind_hw_stats_32b(&stats->ur);\r\nfm10k_unbind_hw_stats_32b(&stats->ca);\r\nfm10k_unbind_hw_stats_32b(&stats->um);\r\nfm10k_unbind_hw_stats_32b(&stats->xec);\r\nfm10k_unbind_hw_stats_32b(&stats->vlan_drop);\r\nfm10k_unbind_hw_stats_32b(&stats->loopback_drop);\r\nfm10k_unbind_hw_stats_32b(&stats->nodesc_drop);\r\nfm10k_unbind_hw_stats_q(stats->q, 0, hw->mac.max_queues);\r\nfm10k_update_hw_stats_pf(hw, stats);\r\n}\r\nstatic void fm10k_set_dma_mask_pf(struct fm10k_hw *hw, u64 dma_mask)\r\n{\r\nu32 phyaddr = (u32)(dma_mask >> 32);\r\nfm10k_write_reg(hw, FM10K_PHYADDR, phyaddr);\r\n}\r\nstatic s32 fm10k_get_fault_pf(struct fm10k_hw *hw, int type,\r\nstruct fm10k_fault *fault)\r\n{\r\nu32 func;\r\nswitch (type) {\r\ncase FM10K_PCA_FAULT:\r\ncase FM10K_THI_FAULT:\r\ncase FM10K_FUM_FAULT:\r\nbreak;\r\ndefault:\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nfunc = fm10k_read_reg(hw, type + FM10K_FAULT_FUNC);\r\nif (!(func & FM10K_FAULT_FUNC_VALID))\r\nreturn FM10K_ERR_PARAM;\r\nfault->address = fm10k_read_reg(hw, type + FM10K_FAULT_ADDR_HI);\r\nfault->address <<= 32;\r\nfault->address = fm10k_read_reg(hw, type + FM10K_FAULT_ADDR_LO);\r\nfault->specinfo = fm10k_read_reg(hw, type + FM10K_FAULT_SPECINFO);\r\nfm10k_write_reg(hw, type + FM10K_FAULT_FUNC, FM10K_FAULT_FUNC_VALID);\r\nif (func & FM10K_FAULT_FUNC_PF)\r\nfault->func = 0;\r\nelse\r\nfault->func = 1 + ((func & FM10K_FAULT_FUNC_VF_MASK) >>\r\nFM10K_FAULT_FUNC_VF_SHIFT);\r\nfault->type = func & FM10K_FAULT_FUNC_TYPE_MASK;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_request_lport_map_pf(struct fm10k_hw *hw)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[1];\r\nfm10k_tlv_msg_init(msg, FM10K_PF_MSG_ID_LPORT_MAP);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic s32 fm10k_get_host_state_pf(struct fm10k_hw *hw, bool *switch_ready)\r\n{\r\ns32 ret_val = 0;\r\nu32 dma_ctrl2;\r\ndma_ctrl2 = fm10k_read_reg(hw, FM10K_DMA_CTRL2);\r\nif (!(dma_ctrl2 & FM10K_DMA_CTRL2_SWITCH_READY))\r\ngoto out;\r\nret_val = fm10k_get_host_state_generic(hw, switch_ready);\r\nif (ret_val)\r\ngoto out;\r\nif (hw->mac.dglort_map == FM10K_DGLORTMAP_NONE)\r\nret_val = fm10k_request_lport_map_pf(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 fm10k_msg_lport_map_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nu16 glort, mask;\r\nu32 dglort_map;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_u32(results[FM10K_PF_ATTR_ID_LPORT_MAP],\r\n&dglort_map);\r\nif (err)\r\nreturn err;\r\nglort = FM10K_MSG_HDR_FIELD_GET(dglort_map, LPORT_MAP_GLORT);\r\nmask = FM10K_MSG_HDR_FIELD_GET(dglort_map, LPORT_MAP_MASK);\r\nif (!mask || (glort & ~mask))\r\nreturn FM10K_ERR_PARAM;\r\nif (((~(mask - 1) & mask) + mask) & FM10K_DGLORTMAP_NONE)\r\nreturn FM10K_ERR_PARAM;\r\nhw->mac.dglort_map = dglort_map;\r\nreturn 0;\r\n}\r\ns32 fm10k_msg_update_pvid_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nu16 glort, pvid;\r\nu32 pvid_update;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_u32(results[FM10K_PF_ATTR_ID_UPDATE_PVID],\r\n&pvid_update);\r\nif (err)\r\nreturn err;\r\nglort = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_GLORT);\r\npvid = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_PVID);\r\nif (!fm10k_glort_valid_pf(hw, glort))\r\nreturn FM10K_ERR_PARAM;\r\nif (pvid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nhw->mac.default_vid = pvid;\r\nreturn 0;\r\n}\r\nstatic void fm10k_record_global_table_data(struct fm10k_global_table_data *from,\r\nstruct fm10k_swapi_table_info *to)\r\n{\r\nto->used = le32_to_cpu(from->used);\r\nto->avail = le32_to_cpu(from->avail);\r\n}\r\ns32 fm10k_msg_err_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_swapi_error err_msg;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_le_struct(results[FM10K_PF_ATTR_ID_ERR],\r\n&err_msg, sizeof(err_msg));\r\nif (err)\r\nreturn err;\r\nfm10k_record_global_table_data(&err_msg.mac, &hw->swapi.mac);\r\nfm10k_record_global_table_data(&err_msg.nexthop, &hw->swapi.nexthop);\r\nfm10k_record_global_table_data(&err_msg.ffu, &hw->swapi.ffu);\r\nhw->swapi.status = le32_to_cpu(err_msg.status);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_adjust_systime_pf(struct fm10k_hw *hw, s32 ppb)\r\n{\r\nu64 systime_adjust;\r\nif (!hw->sw_addr)\r\nreturn ppb ? FM10K_ERR_PARAM : 0;\r\nsystime_adjust = (ppb < 0) ? -ppb : ppb;\r\nsystime_adjust <<= 31;\r\ndo_div(systime_adjust, 1953125);\r\nif (systime_adjust > FM10K_SW_SYSTIME_ADJUST_MASK)\r\nreturn FM10K_ERR_PARAM;\r\nif (ppb > 0)\r\nsystime_adjust |= FM10K_SW_SYSTIME_ADJUST_DIR_POSITIVE;\r\nfm10k_write_sw_reg(hw, FM10K_SW_SYSTIME_ADJUST, (u32)systime_adjust);\r\nreturn 0;\r\n}\r\nstatic u64 fm10k_read_systime_pf(struct fm10k_hw *hw)\r\n{\r\nu32 systime_l, systime_h, systime_tmp;\r\nsystime_h = fm10k_read_reg(hw, FM10K_SYSTIME + 1);\r\ndo {\r\nsystime_tmp = systime_h;\r\nsystime_l = fm10k_read_reg(hw, FM10K_SYSTIME);\r\nsystime_h = fm10k_read_reg(hw, FM10K_SYSTIME + 1);\r\n} while (systime_tmp != systime_h);\r\nreturn ((u64)systime_h << 32) | systime_l;\r\n}\r\nstatic s32 fm10k_get_invariants_pf(struct fm10k_hw *hw)\r\n{\r\nfm10k_get_invariants_generic(hw);\r\nreturn fm10k_sm_mbx_init(hw, &hw->mbx, fm10k_msg_data_pf);\r\n}
