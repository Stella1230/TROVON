static inline int axp288_charger_set_cc(struct axp288_chrg_info *info, int cc)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nif (cc < CHRG_CCCV_CC_OFFSET)\r\ncc = CHRG_CCCV_CC_OFFSET;\r\nelse if (cc > info->max_cc)\r\ncc = info->max_cc;\r\nreg_val = (cc - CHRG_CCCV_CC_OFFSET) / CHRG_CCCV_CC_LSB_RES;\r\ncc = (reg_val * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\r\nreg_val = reg_val << CHRG_CCCV_CC_BIT_POS;\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CC_MASK, reg_val);\r\nif (ret >= 0)\r\ninfo->cc = cc;\r\nreturn ret;\r\n}\r\nstatic inline int axp288_charger_set_cv(struct axp288_chrg_info *info, int cv)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nif (cv <= CV_4100MV) {\r\nreg_val = CHRG_CCCV_CV_4100MV;\r\ncv = CV_4100MV;\r\n} else if (cv <= CV_4150MV) {\r\nreg_val = CHRG_CCCV_CV_4150MV;\r\ncv = CV_4150MV;\r\n} else if (cv <= CV_4200MV) {\r\nreg_val = CHRG_CCCV_CV_4200MV;\r\ncv = CV_4200MV;\r\n} else {\r\nreg_val = CHRG_CCCV_CV_4350MV;\r\ncv = CV_4350MV;\r\n}\r\nreg_val = reg_val << CHRG_CCCV_CV_BIT_POS;\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CV_MASK, reg_val);\r\nif (ret >= 0)\r\ninfo->cv = cv;\r\nreturn ret;\r\n}\r\nstatic inline int axp288_charger_set_vbus_inlmt(struct axp288_chrg_info *info,\r\nint inlmt)\r\n{\r\nint ret;\r\nunsigned int val;\r\nu8 reg_val;\r\nret = regmap_read(info->regmap, AXP20X_CHRG_BAK_CTRL, &val);\r\nif (ret < 0)\r\ngoto set_inlmt_fail;\r\nif (inlmt <= ILIM_100MA) {\r\nreg_val = CHRG_VBUS_ILIM_100MA;\r\ninlmt = ILIM_100MA;\r\n} else if (inlmt <= ILIM_500MA) {\r\nreg_val = CHRG_VBUS_ILIM_500MA;\r\ninlmt = ILIM_500MA;\r\n} else if (inlmt <= ILIM_900MA) {\r\nreg_val = CHRG_VBUS_ILIM_900MA;\r\ninlmt = ILIM_900MA;\r\n} else if (inlmt <= ILIM_1500MA) {\r\nreg_val = CHRG_VBUS_ILIM_1500MA;\r\ninlmt = ILIM_1500MA;\r\n} else if (inlmt <= ILIM_2000MA) {\r\nreg_val = CHRG_VBUS_ILIM_2000MA;\r\ninlmt = ILIM_2000MA;\r\n} else if (inlmt <= ILIM_2500MA) {\r\nreg_val = CHRG_VBUS_ILIM_2500MA;\r\ninlmt = ILIM_2500MA;\r\n} else {\r\nreg_val = CHRG_VBUS_ILIM_3000MA;\r\ninlmt = ILIM_3000MA;\r\n}\r\nreg_val = (val & ~CHRG_VBUS_ILIM_MASK)\r\n| (reg_val << CHRG_VBUS_ILIM_BIT_POS);\r\nret = regmap_write(info->regmap, AXP20X_CHRG_BAK_CTRL, reg_val);\r\nif (ret >= 0)\r\ninfo->inlmt = inlmt;\r\nelse\r\ndev_err(&info->pdev->dev, "charger BAK control %d\n", ret);\r\nset_inlmt_fail:\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_vbus_path_select(struct axp288_chrg_info *info,\r\nbool enable)\r\n{\r\nint ret;\r\nif (enable)\r\nret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\r\nVBUS_ISPOUT_VBUS_PATH_DIS, 0);\r\nelse\r\nret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\r\nVBUS_ISPOUT_VBUS_PATH_DIS, VBUS_ISPOUT_VBUS_PATH_DIS);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 vbus path select %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_enable_charger(struct axp288_chrg_info *info,\r\nbool enable)\r\n{\r\nint ret;\r\nif (enable)\r\nret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CHG_EN, CHRG_CCCV_CHG_EN);\r\nelse\r\nret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CHG_EN, 0);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 enable charger %d\n", ret);\r\nelse\r\ninfo->is_charger_enabled = enable;\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_is_present(struct axp288_chrg_info *info)\r\n{\r\nint ret, present = 0;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & PS_STAT_VBUS_PRESENT)\r\npresent = 1;\r\nreturn present;\r\n}\r\nstatic int axp288_charger_is_online(struct axp288_chrg_info *info)\r\n{\r\nint ret, online = 0;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & PS_STAT_VBUS_VALID)\r\nonline = 1;\r\nreturn online;\r\n}\r\nstatic int axp288_get_charger_health(struct axp288_chrg_info *info)\r\n{\r\nint ret, pwr_stat, chrg_stat;\r\nint health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif ((ret < 0) || !(val & PS_STAT_VBUS_PRESENT))\r\ngoto health_read_fail;\r\nelse\r\npwr_stat = val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_OP_MODE, &val);\r\nif (ret < 0)\r\ngoto health_read_fail;\r\nelse\r\nchrg_stat = val;\r\nif (!(pwr_stat & PS_STAT_VBUS_VALID))\r\nhealth = POWER_SUPPLY_HEALTH_DEAD;\r\nelse if (chrg_stat & CHRG_STAT_PMIC_OTP)\r\nhealth = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (chrg_stat & CHRG_STAT_BAT_SAFE_MODE)\r\nhealth = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nelse\r\nhealth = POWER_SUPPLY_HEALTH_GOOD;\r\nhealth_read_fail:\r\nreturn health;\r\n}\r\nstatic int axp288_charger_usb_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nint scaled_val;\r\nmutex_lock(&info->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nscaled_val = min(val->intval, info->max_cc);\r\nscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\r\nret = axp288_charger_set_cc(info, scaled_val);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "set charge current failed\n");\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nscaled_val = min(val->intval, info->max_cv);\r\nscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\r\nret = axp288_charger_set_cv(info, scaled_val);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "set charge voltage failed\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_usb_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (info->otg.id_short) {\r\nval->intval = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_is_present(info);\r\nif (ret < 0)\r\ngoto psy_get_prop_fail;\r\ninfo->present = ret;\r\nval->intval = info->present;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nif (info->otg.id_short) {\r\nval->intval = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_is_online(info);\r\nif (ret < 0)\r\ngoto psy_get_prop_fail;\r\ninfo->online = ret;\r\nval->intval = info->online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nval->intval = axp288_get_charger_health(info);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nval->intval = info->cc * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nval->intval = info->max_cc * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nval->intval = info->cv * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nval->intval = info->max_cv * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nval->intval = info->inlmt * 1000;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto psy_get_prop_fail;\r\n}\r\npsy_get_prop_fail:\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t axp288_charger_irq_thread_handler(int irq, void *dev)\r\n{\r\nstruct axp288_chrg_info *info = dev;\r\nint i;\r\nfor (i = 0; i < CHRG_INTR_END; i++) {\r\nif (info->irq[i] == irq)\r\nbreak;\r\n}\r\nif (i >= CHRG_INTR_END) {\r\ndev_warn(&info->pdev->dev, "spurious interrupt!!\n");\r\nreturn IRQ_NONE;\r\n}\r\nswitch (i) {\r\ncase VBUS_OV_IRQ:\r\ndev_dbg(&info->pdev->dev, "VBUS Over Voltage INTR\n");\r\nbreak;\r\ncase CHARGE_DONE_IRQ:\r\ndev_dbg(&info->pdev->dev, "Charging Done INTR\n");\r\nbreak;\r\ncase CHARGE_CHARGING_IRQ:\r\ndev_dbg(&info->pdev->dev, "Start Charging IRQ\n");\r\nbreak;\r\ncase BAT_SAFE_QUIT_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Safe Mode(restart timer) Charging IRQ\n");\r\nbreak;\r\ncase BAT_SAFE_ENTER_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Enter Safe Mode(timer expire) Charging IRQ\n");\r\nbreak;\r\ncase QCBTU_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Battery Under Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase CBTU_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Hit Battery Under Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase QCBTO_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Battery Over Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase CBTO_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Hit Battery Over Temperature(CHRG) INTR\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");\r\ngoto out;\r\n}\r\npower_supply_changed(info->psy_usb);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void axp288_charger_extcon_evt_worker(struct work_struct *work)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(work, struct axp288_chrg_info, cable.work);\r\nint ret, current_limit;\r\nbool changed = false;\r\nstruct extcon_dev *edev = info->cable.edev;\r\nbool old_connected = info->cable.connected;\r\nif (extcon_get_cable_state(edev, AXP288_EXTCON_SLOW_CHARGER) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB SDP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB;\r\n} else if (extcon_get_cable_state(edev,\r\nAXP288_EXTCON_DOWNSTREAM_CHARGER) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB CDP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB_CDP;\r\n} else if (extcon_get_cable_state(edev,\r\nAXP288_EXTCON_FAST_CHARGER) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB DCP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB_DCP;\r\n} else {\r\nif (old_connected)\r\ndev_dbg(&info->pdev->dev, "USB charger disconnected");\r\ninfo->cable.connected = false;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB;\r\n}\r\nif (old_connected != info->cable.connected)\r\nchanged = true;\r\nif (!changed)\r\nreturn;\r\nmutex_lock(&info->lock);\r\nif (info->is_charger_enabled && !info->cable.connected) {\r\ninfo->enable_charger = false;\r\nret = axp288_charger_enable_charger(info, info->enable_charger);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev,\r\n"cannot disable charger (%d)", ret);\r\n} else if (!info->is_charger_enabled && info->cable.connected) {\r\nswitch (info->cable.chg_type) {\r\ncase POWER_SUPPLY_TYPE_USB:\r\ncurrent_limit = ILIM_500MA;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB_CDP:\r\ncurrent_limit = ILIM_1500MA;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB_DCP:\r\ncurrent_limit = ILIM_2000MA;\r\nbreak;\r\ndefault:\r\ncurrent_limit = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_set_vbus_inlmt(info, current_limit);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"error setting current limit (%d)", ret);\r\n} else {\r\ninfo->enable_charger = (current_limit > 0);\r\nret = axp288_charger_enable_charger(info,\r\ninfo->enable_charger);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev,\r\n"cannot enable charger (%d)", ret);\r\n}\r\n}\r\nif (changed)\r\ninfo->health = axp288_get_charger_health(info);\r\nmutex_unlock(&info->lock);\r\nif (changed)\r\npower_supply_changed(info->psy_usb);\r\n}\r\nstatic int axp288_charger_handle_cable_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, cable.nb);\r\nschedule_work(&info->cable.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void axp288_charger_otg_evt_worker(struct work_struct *work)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(work, struct axp288_chrg_info, otg.work);\r\nint ret;\r\nret = axp288_charger_vbus_path_select(info, !info->otg.id_short);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "vbus path disable failed\n");\r\n}\r\nstatic int axp288_charger_handle_otg_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, otg.id_nb);\r\nstruct extcon_dev *edev = param;\r\nint usb_host = extcon_get_cable_state(edev, "USB-Host");\r\ndev_dbg(&info->pdev->dev, "external connector USB-Host is %s\n",\r\nusb_host ? "attached" : "detached");\r\ninfo->otg.id_short = usb_host;\r\nschedule_work(&info->otg.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void charger_init_hw_regs(struct axp288_chrg_info *info)\r\n{\r\nint ret, cc, cv;\r\nunsigned int val;\r\nret = regmap_write(info->regmap, AXP20X_V_LTF_CHRG, CHRG_VLTFC_0C);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_V_LTF_CHRG, ret);\r\nret = regmap_write(info->regmap, AXP20X_V_HTF_CHRG, CHRG_VHTFC_45C);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_V_HTF_CHRG, ret);\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL2,\r\nCNTL2_CHG_OUT_TURNON, 1);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CHRG_CTRL2, ret);\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_IRQ2_EN,\r\nBAT_IRQ_CFG_BAT_MASK, 1);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_IRQ2_EN, ret);\r\nret = regmap_update_bits(info->regmap, AXP20X_IRQ3_EN,\r\nTEMP_IRQ_CFG_MASK, 1);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_IRQ3_EN, ret);\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_ITERM_20P, 0);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CHRG_CTRL1, ret);\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CC_CTRL,\r\nFG_CNTL_OCV_ADJ_EN, 0);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CC_CTRL, ret);\r\ninfo->max_cc = info->pdata->max_cc;\r\ninfo->max_cv = info->pdata->max_cv;\r\nret = regmap_read(info->regmap, AXP20X_CHRG_CTRL1, &val);\r\nif (ret < 0) {\r\ninfo->cc = info->pdata->def_cc;\r\ninfo->cv = info->pdata->def_cv;\r\n} else {\r\ncv = (val & CHRG_CCCV_CV_MASK) >> CHRG_CCCV_CV_BIT_POS;\r\nswitch (cv) {\r\ncase CHRG_CCCV_CV_4100MV:\r\ninfo->cv = CV_4100MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4150MV:\r\ninfo->cv = CV_4150MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4200MV:\r\ninfo->cv = CV_4200MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4350MV:\r\ninfo->cv = CV_4350MV;\r\nbreak;\r\ndefault:\r\ninfo->cv = INT_MAX;\r\nbreak;\r\n}\r\ncc = (ret & CHRG_CCCV_CC_MASK) >> CHRG_CCCV_CC_BIT_POS;\r\ncc = (cc * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\r\ninfo->cc = cc;\r\ncc = min(info->pdata->def_cc, info->max_cc);\r\ncv = min(info->pdata->def_cv, info->max_cv);\r\nret = axp288_charger_set_cc(info, cc);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev,\r\n"error(%d) in setting CC\n", ret);\r\nret = axp288_charger_set_cv(info, cv);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev,\r\n"error(%d) in setting CV\n", ret);\r\n}\r\n}\r\nstatic int axp288_charger_probe(struct platform_device *pdev)\r\n{\r\nint ret, i, pirq;\r\nstruct axp288_chrg_info *info;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config charger_cfg = {};\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->pdata = pdev->dev.platform_data;\r\nif (!info->pdata) {\r\nif (!device_property_present(&pdev->dev,\r\n"axp288_charger_data\n"))\r\ndev_err(&pdev->dev, "failed to get platform data\n");\r\nreturn -ENODEV;\r\n}\r\ninfo->cable.edev = extcon_get_extcon_dev(AXP288_EXTCON_DEV_NAME);\r\nif (info->cable.edev == NULL) {\r\ndev_dbg(&pdev->dev, "%s is not ready, probe deferred\n",\r\nAXP288_EXTCON_DEV_NAME);\r\nreturn -EPROBE_DEFER;\r\n}\r\nINIT_WORK(&info->cable.work, axp288_charger_extcon_evt_worker);\r\ninfo->cable.nb.notifier_call = axp288_charger_handle_cable_evt;\r\nret = extcon_register_notifier(info->cable.edev, EXTCON_NONE, &info->cable.nb);\r\nif (ret) {\r\ndev_err(&info->pdev->dev,\r\n"failed to register extcon notifier %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->lock);\r\ncharger_cfg.drv_data = info;\r\ninfo->psy_usb = power_supply_register(&pdev->dev, &axp288_charger_desc,\r\n&charger_cfg);\r\nif (IS_ERR(info->psy_usb)) {\r\ndev_err(&pdev->dev, "failed to register power supply charger\n");\r\nret = PTR_ERR(info->psy_usb);\r\ngoto psy_reg_failed;\r\n}\r\nINIT_WORK(&info->otg.work, axp288_charger_otg_evt_worker);\r\ninfo->otg.id_nb.notifier_call = axp288_charger_handle_otg_evt;\r\nret = extcon_register_interest(&info->otg.cable, NULL, "USB-Host",\r\n&info->otg.id_nb);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to register otg notifier\n");\r\nif (info->otg.cable.edev)\r\ninfo->otg.id_short = extcon_get_cable_state(\r\ninfo->otg.cable.edev, "USB-Host");\r\nfor (i = 0; i < CHRG_INTR_END; i++) {\r\npirq = platform_get_irq(info->pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_warn(&info->pdev->dev,\r\n"failed to get virtual interrupt=%d\n", pirq);\r\nret = info->irq[i];\r\ngoto intr_reg_failed;\r\n}\r\nret = devm_request_threaded_irq(&info->pdev->dev, info->irq[i],\r\nNULL, axp288_charger_irq_thread_handler,\r\nIRQF_ONESHOT, info->pdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request interrupt=%d\n",\r\ninfo->irq[i]);\r\ngoto intr_reg_failed;\r\n}\r\n}\r\ncharger_init_hw_regs(info);\r\nreturn 0;\r\nintr_reg_failed:\r\nif (info->otg.cable.edev)\r\nextcon_unregister_interest(&info->otg.cable);\r\npower_supply_unregister(info->psy_usb);\r\npsy_reg_failed:\r\nextcon_unregister_notifier(info->cable.edev, EXTCON_NONE, &info->cable.nb);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct axp288_chrg_info *info = dev_get_drvdata(&pdev->dev);\r\nif (info->otg.cable.edev)\r\nextcon_unregister_interest(&info->otg.cable);\r\nextcon_unregister_notifier(info->cable.edev, EXTCON_NONE, &info->cable.nb);\r\npower_supply_unregister(info->psy_usb);\r\nreturn 0;\r\n}
