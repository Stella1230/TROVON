int\r\nlpfc_config_port_prep(struct lpfc_hba *phba)\r\n{\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nint i = 0, rc;\r\nLPFC_MBOXQ_t *pmb;\r\nMAILBOX_t *mb;\r\nchar *lpfc_vpd_data = NULL;\r\nuint16_t offset = 0;\r\nstatic char licensed[56] =\r\n"key unlock for use with gnu public licensed code only\0";\r\nstatic int init_key = 1;\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nmb = &pmb->u.mb;\r\nphba->link_state = LPFC_INIT_MBX_CMDS;\r\nif (lpfc_is_LC_HBA(phba->pcidev->device)) {\r\nif (init_key) {\r\nuint32_t *ptext = (uint32_t *) licensed;\r\nfor (i = 0; i < 56; i += sizeof (uint32_t), ptext++)\r\n*ptext = cpu_to_be32(*ptext);\r\ninit_key = 0;\r\n}\r\nlpfc_read_nv(phba, pmb);\r\nmemset((char*)mb->un.varRDnvp.rsvd3, 0,\r\nsizeof (mb->un.varRDnvp.rsvd3));\r\nmemcpy((char*)mb->un.varRDnvp.rsvd3, licensed,\r\nsizeof (licensed));\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"0324 Config Port initialization "\r\n"error, mbxCmd x%x READ_NVPARM, "\r\n"mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -ERESTART;\r\n}\r\nmemcpy(phba->wwnn, (char *)mb->un.varRDnvp.nodename,\r\nsizeof(phba->wwnn));\r\nmemcpy(phba->wwpn, (char *)mb->un.varRDnvp.portname,\r\nsizeof(phba->wwpn));\r\n}\r\nphba->sli3_options = 0x0;\r\nlpfc_read_rev(phba, pmb);\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0439 Adapter failed to init, mbxCmd x%x "\r\n"READ_REV, mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nmempool_free( pmb, phba->mbox_mem_pool);\r\nreturn -ERESTART;\r\n}\r\nif (mb->un.varRdRev.rr == 0) {\r\nvp->rev.rBit = 0;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0440 Adapter failed to init, READ_REV has "\r\n"missing revision information.\n");\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -ERESTART;\r\n}\r\nif (phba->sli_rev == 3 && !mb->un.varRdRev.v3rsp) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EINVAL;\r\n}\r\nvp->rev.rBit = 1;\r\nmemcpy(&vp->sli3Feat, &mb->un.varRdRev.sli3Feat, sizeof(uint32_t));\r\nvp->rev.sli1FwRev = mb->un.varRdRev.sli1FwRev;\r\nmemcpy(vp->rev.sli1FwName, (char*) mb->un.varRdRev.sli1FwName, 16);\r\nvp->rev.sli2FwRev = mb->un.varRdRev.sli2FwRev;\r\nmemcpy(vp->rev.sli2FwName, (char *) mb->un.varRdRev.sli2FwName, 16);\r\nvp->rev.biuRev = mb->un.varRdRev.biuRev;\r\nvp->rev.smRev = mb->un.varRdRev.smRev;\r\nvp->rev.smFwRev = mb->un.varRdRev.un.smFwRev;\r\nvp->rev.endecRev = mb->un.varRdRev.endecRev;\r\nvp->rev.fcphHigh = mb->un.varRdRev.fcphHigh;\r\nvp->rev.fcphLow = mb->un.varRdRev.fcphLow;\r\nvp->rev.feaLevelHigh = mb->un.varRdRev.feaLevelHigh;\r\nvp->rev.feaLevelLow = mb->un.varRdRev.feaLevelLow;\r\nvp->rev.postKernRev = mb->un.varRdRev.postKernRev;\r\nvp->rev.opFwRev = mb->un.varRdRev.opFwRev;\r\nif (vp->rev.feaLevelHigh < 9)\r\nphba->sli3_options |= LPFC_SLI3_VPORT_TEARDOWN;\r\nif (lpfc_is_LC_HBA(phba->pcidev->device))\r\nmemcpy(phba->RandomData, (char *)&mb->un.varWords[24],\r\nsizeof (phba->RandomData));\r\nlpfc_vpd_data = kmalloc(DMP_VPD_SIZE, GFP_KERNEL);\r\nif (!lpfc_vpd_data)\r\ngoto out_free_mbox;\r\ndo {\r\nlpfc_dump_mem(phba, pmb, offset, DMP_REGION_VPD);\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0441 VPD not present on adapter, "\r\n"mbxCmd x%x DUMP VPD, mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nmb->un.varDmp.word_cnt = 0;\r\n}\r\nif (mb->un.varDmp.word_cnt == 0)\r\nbreak;\r\nif (mb->un.varDmp.word_cnt > DMP_VPD_SIZE - offset)\r\nmb->un.varDmp.word_cnt = DMP_VPD_SIZE - offset;\r\nlpfc_sli_pcimem_bcopy(((uint8_t *)mb) + DMP_RSP_OFFSET,\r\nlpfc_vpd_data + offset,\r\nmb->un.varDmp.word_cnt);\r\noffset += mb->un.varDmp.word_cnt;\r\n} while (mb->un.varDmp.word_cnt && offset < DMP_VPD_SIZE);\r\nlpfc_parse_vpd(phba, lpfc_vpd_data, offset);\r\nkfree(lpfc_vpd_data);\r\nout_free_mbox:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_config_async_cmpl(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmboxq)\r\n{\r\nif (pmboxq->u.mb.mbxStatus == MBX_SUCCESS)\r\nphba->temp_sensor_support = 1;\r\nelse\r\nphba->temp_sensor_support = 0;\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_dump_wakeup_param_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\r\n{\r\nstruct prog_id *prg;\r\nuint32_t prog_id_word;\r\nchar dist = ' ';\r\nchar dist_char[] = "nabx";\r\nif (pmboxq->u.mb.mbxStatus != MBX_SUCCESS) {\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nprg = (struct prog_id *) &prog_id_word;\r\nprog_id_word = pmboxq->u.mb.un.varWords[7];\r\nif (prg->dist < 4)\r\ndist = dist_char[prg->dist];\r\nif ((prg->dist == 3) && (prg->num == 0))\r\nsnprintf(phba->OptionROMVersion, 32, "%d.%d%d",\r\nprg->ver, prg->rev, prg->lev);\r\nelse\r\nsnprintf(phba->OptionROMVersion, 32, "%d.%d%d%c%d",\r\nprg->ver, prg->rev, prg->lev,\r\ndist, prg->num);\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_update_vport_wwn(struct lpfc_vport *vport)\r\n{\r\nif (vport->phba->cfg_soft_wwnn)\r\nu64_to_wwn(vport->phba->cfg_soft_wwnn,\r\nvport->fc_sparam.nodeName.u.wwn);\r\nif (vport->phba->cfg_soft_wwpn)\r\nu64_to_wwn(vport->phba->cfg_soft_wwpn,\r\nvport->fc_sparam.portName.u.wwn);\r\nif (vport->fc_nodename.u.wwn[0] == 0 || vport->phba->cfg_soft_wwnn)\r\nmemcpy(&vport->fc_nodename, &vport->fc_sparam.nodeName,\r\nsizeof(struct lpfc_name));\r\nelse\r\nmemcpy(&vport->fc_sparam.nodeName, &vport->fc_nodename,\r\nsizeof(struct lpfc_name));\r\nif (vport->fc_portname.u.wwn[0] == 0 || vport->phba->cfg_soft_wwpn)\r\nmemcpy(&vport->fc_portname, &vport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nelse\r\nmemcpy(&vport->fc_sparam.portName, &vport->fc_portname,\r\nsizeof(struct lpfc_name));\r\n}\r\nint\r\nlpfc_config_port_post(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nLPFC_MBOXQ_t *pmb;\r\nMAILBOX_t *mb;\r\nstruct lpfc_dmabuf *mp;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nuint32_t status, timeout;\r\nint i, j;\r\nint rc;\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->over_temp_state == HBA_OVER_TEMP)\r\nphba->over_temp_state = HBA_NORMAL_TEMP;\r\nspin_unlock_irq(&phba->hbalock);\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nmb = &pmb->u.mb;\r\nrc = lpfc_read_sparam(phba, pmb, 0);\r\nif (rc) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -ENOMEM;\r\n}\r\npmb->vport = vport;\r\nif (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0448 Adapter failed init, mbxCmd x%x "\r\n"READ_SPARM mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nphba->link_state = LPFC_HBA_ERROR;\r\nmp = (struct lpfc_dmabuf *) pmb->context1;\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\nreturn -EIO;\r\n}\r\nmp = (struct lpfc_dmabuf *) pmb->context1;\r\nmemcpy(&vport->fc_sparam, mp->virt, sizeof (struct serv_parm));\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\npmb->context1 = NULL;\r\nlpfc_update_vport_wwn(vport);\r\nfc_host_node_name(shost) = wwn_to_u64(vport->fc_nodename.u.wwn);\r\nfc_host_port_name(shost) = wwn_to_u64(vport->fc_portname.u.wwn);\r\nfc_host_max_npiv_vports(shost) = phba->max_vpi;\r\nif (phba->SerialNumber[0] == 0) {\r\nuint8_t *outptr;\r\noutptr = &vport->fc_nodename.u.s.IEEE[0];\r\nfor (i = 0; i < 12; i++) {\r\nstatus = *outptr++;\r\nj = ((status & 0xf0) >> 4);\r\nif (j <= 9)\r\nphba->SerialNumber[i] =\r\n(char)((uint8_t) 0x30 + (uint8_t) j);\r\nelse\r\nphba->SerialNumber[i] =\r\n(char)((uint8_t) 0x61 + (uint8_t) (j - 10));\r\ni++;\r\nj = (status & 0xf);\r\nif (j <= 9)\r\nphba->SerialNumber[i] =\r\n(char)((uint8_t) 0x30 + (uint8_t) j);\r\nelse\r\nphba->SerialNumber[i] =\r\n(char)((uint8_t) 0x61 + (uint8_t) (j - 10));\r\n}\r\n}\r\nlpfc_read_config(phba, pmb);\r\npmb->vport = vport;\r\nif (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0453 Adapter failed to init, mbxCmd x%x "\r\n"READ_CONFIG, mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nphba->link_state = LPFC_HBA_ERROR;\r\nmempool_free( pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nlpfc_sli_read_link_ste(phba);\r\ni = (mb->un.varRdConfig.max_xri + 1);\r\nif (phba->cfg_hba_queue_depth > i) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"3359 HBA queue depth changed from %d to %d\n",\r\nphba->cfg_hba_queue_depth, i);\r\nphba->cfg_hba_queue_depth = i;\r\n}\r\ni = (mb->un.varRdConfig.max_xri >> 3);\r\nif (phba->pport->cfg_lun_queue_depth > i) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"3360 LUN queue depth changed from %d to %d\n",\r\nphba->pport->cfg_lun_queue_depth, i);\r\nphba->pport->cfg_lun_queue_depth = i;\r\n}\r\nphba->lmt = mb->un.varRdConfig.lmt;\r\nlpfc_get_hba_model_desc(phba, phba->ModelName, phba->ModelDesc);\r\nphba->link_state = LPFC_LINK_DOWN;\r\nif (psli->ring[psli->extra_ring].sli.sli3.cmdringaddr)\r\npsli->ring[psli->extra_ring].flag |= LPFC_STOP_IOCB_EVENT;\r\nif (psli->ring[psli->fcp_ring].sli.sli3.cmdringaddr)\r\npsli->ring[psli->fcp_ring].flag |= LPFC_STOP_IOCB_EVENT;\r\nif (psli->ring[psli->next_ring].sli.sli3.cmdringaddr)\r\npsli->ring[psli->next_ring].flag |= LPFC_STOP_IOCB_EVENT;\r\nif (phba->sli_rev != 3)\r\nlpfc_post_rcv_buf(phba);\r\nif (phba->intr_type == MSIX) {\r\nrc = lpfc_config_msi(phba, pmb);\r\nif (rc) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"0352 Config MSI mailbox command "\r\n"failed, mbxCmd x%x, mbxStatus x%x\n",\r\npmb->u.mb.mbxCommand,\r\npmb->u.mb.mbxStatus);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~HBA_ERATT_HANDLED;\r\nif (lpfc_readl(phba->HCregaddr, &status)) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn -EIO;\r\n}\r\nstatus |= HC_MBINT_ENA | HC_ERINT_ENA | HC_LAINT_ENA;\r\nif (psli->num_rings > 0)\r\nstatus |= HC_R0INT_ENA;\r\nif (psli->num_rings > 1)\r\nstatus |= HC_R1INT_ENA;\r\nif (psli->num_rings > 2)\r\nstatus |= HC_R2INT_ENA;\r\nif (psli->num_rings > 3)\r\nstatus |= HC_R3INT_ENA;\r\nif ((phba->cfg_poll & ENABLE_FCP_RING_POLLING) &&\r\n(phba->cfg_poll & DISABLE_FCP_RING_INT))\r\nstatus &= ~(HC_R0INT_ENA);\r\nwritel(status, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\nspin_unlock_irq(&phba->hbalock);\r\ntimeout = phba->fc_ratov * 2;\r\nmod_timer(&vport->els_tmofunc,\r\njiffies + msecs_to_jiffies(1000 * timeout));\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies + msecs_to_jiffies(1000 * LPFC_HB_MBOX_INTERVAL));\r\nphba->hb_outstanding = 0;\r\nphba->last_completion_time = jiffies;\r\nmod_timer(&phba->eratt_poll,\r\njiffies + msecs_to_jiffies(1000 * LPFC_ERATT_POLL_INTERVAL));\r\nif (phba->hba_flag & LINK_DISABLED) {\r\nlpfc_printf_log(phba,\r\nKERN_ERR, LOG_INIT,\r\n"2598 Adapter Link is disabled.\n");\r\nlpfc_down_link(phba, pmb);\r\npmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif ((rc != MBX_SUCCESS) && (rc != MBX_BUSY)) {\r\nlpfc_printf_log(phba,\r\nKERN_ERR, LOG_INIT,\r\n"2599 Adapter failed to issue DOWN_LINK"\r\n" mbox command rc 0x%x\n", rc);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\n} else if (phba->cfg_suppress_link_up == LPFC_INITIALIZE_LINK) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nrc = phba->lpfc_hba_init_link(phba, MBX_NOWAIT);\r\nif (rc)\r\nreturn rc;\r\n}\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nlpfc_config_async(phba, pmb, LPFC_ELS_RING);\r\npmb->mbox_cmpl = lpfc_config_async_cmpl;\r\npmb->vport = phba->pport;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif ((rc != MBX_BUSY) && (rc != MBX_SUCCESS)) {\r\nlpfc_printf_log(phba,\r\nKERN_ERR,\r\nLOG_INIT,\r\n"0456 Adapter failed to issue "\r\n"ASYNCEVT_ENABLE mbox status x%x\n",\r\nrc);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\n}\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nlpfc_dump_wakeup_param(phba, pmb);\r\npmb->mbox_cmpl = lpfc_dump_wakeup_param_cmpl;\r\npmb->vport = phba->pport;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif ((rc != MBX_BUSY) && (rc != MBX_SUCCESS)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT, "0435 Adapter failed "\r\n"to get Option ROM version status x%x\n", rc);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_hba_init_link(struct lpfc_hba *phba, uint32_t flag)\r\n{\r\nreturn lpfc_hba_init_link_fc_topology(phba, phba->cfg_topology, flag);\r\n}\r\nint\r\nlpfc_hba_init_link_fc_topology(struct lpfc_hba *phba, uint32_t fc_topology,\r\nuint32_t flag)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nLPFC_MBOXQ_t *pmb;\r\nMAILBOX_t *mb;\r\nint rc;\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nmb = &pmb->u.mb;\r\npmb->vport = vport;\r\nif ((phba->cfg_link_speed > LPFC_USER_LINK_SPEED_MAX) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_1G) &&\r\n!(phba->lmt & LMT_1Gb)) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_2G) &&\r\n!(phba->lmt & LMT_2Gb)) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_4G) &&\r\n!(phba->lmt & LMT_4Gb)) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_8G) &&\r\n!(phba->lmt & LMT_8Gb)) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_10G) &&\r\n!(phba->lmt & LMT_10Gb)) ||\r\n((phba->cfg_link_speed == LPFC_USER_LINK_SPEED_16G) &&\r\n!(phba->lmt & LMT_16Gb))) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\r\n"1302 Invalid speed for this board:%d "\r\n"Reset link speed to auto.\n",\r\nphba->cfg_link_speed);\r\nphba->cfg_link_speed = LPFC_USER_LINK_SPEED_AUTO;\r\n}\r\nlpfc_init_link(phba, pmb, fc_topology, phba->cfg_link_speed);\r\npmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nlpfc_set_loopback_flag(phba);\r\nrc = lpfc_sli_issue_mbox(phba, pmb, flag);\r\nif ((rc != MBX_BUSY) && (rc != MBX_SUCCESS)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0498 Adapter failed to init, mbxCmd x%x "\r\n"INIT_LINK, mbxStatus x%x\n",\r\nmb->mbxCommand, mb->mbxStatus);\r\nif (phba->sli_rev <= LPFC_SLI_REV3) {\r\nwritel(0, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\nwritel(0xffffffff, phba->HAregaddr);\r\nreadl(phba->HAregaddr);\r\n}\r\nphba->link_state = LPFC_HBA_ERROR;\r\nif (rc != MBX_BUSY || flag == MBX_POLL)\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nphba->cfg_suppress_link_up = LPFC_INITIALIZE_LINK;\r\nif (flag == MBX_POLL)\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_hba_down_link(struct lpfc_hba *phba, uint32_t flag)\r\n{\r\nLPFC_MBOXQ_t *pmb;\r\nint rc;\r\npmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn -ENOMEM;\r\n}\r\nlpfc_printf_log(phba,\r\nKERN_ERR, LOG_INIT,\r\n"0491 Adapter Link is disabled.\n");\r\nlpfc_down_link(phba, pmb);\r\npmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, flag);\r\nif ((rc != MBX_SUCCESS) && (rc != MBX_BUSY)) {\r\nlpfc_printf_log(phba,\r\nKERN_ERR, LOG_INIT,\r\n"2522 Adapter failed to issue DOWN_LINK"\r\n" mbox command rc 0x%x\n", rc);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nif (flag == MBX_POLL)\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn 0;\r\n}\r\nint\r\nlpfc_hba_down_prep(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nint i;\r\nif (phba->sli_rev <= LPFC_SLI_REV3) {\r\nwritel(0, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\n}\r\nif (phba->pport->load_flag & FC_UNLOADING)\r\nlpfc_cleanup_discovery_resources(phba->pport);\r\nelse {\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports &&\r\nvports[i] != NULL; i++)\r\nlpfc_cleanup_discovery_resources(vports[i]);\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli4_free_sp_events(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_iocbq *rspiocbq;\r\nstruct hbq_dmabuf *dmabuf;\r\nstruct lpfc_cq_event *cq_event;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~HBA_SP_QUEUE_EVT;\r\nspin_unlock_irq(&phba->hbalock);\r\nwhile (!list_empty(&phba->sli4_hba.sp_queue_event)) {\r\nspin_lock_irq(&phba->hbalock);\r\nlist_remove_head(&phba->sli4_hba.sp_queue_event,\r\ncq_event, struct lpfc_cq_event, list);\r\nspin_unlock_irq(&phba->hbalock);\r\nswitch (bf_get(lpfc_wcqe_c_code, &cq_event->cqe.wcqe_cmpl)) {\r\ncase CQE_CODE_COMPL_WQE:\r\nrspiocbq = container_of(cq_event, struct lpfc_iocbq,\r\ncq_event);\r\nlpfc_sli_release_iocbq(phba, rspiocbq);\r\nbreak;\r\ncase CQE_CODE_RECEIVE:\r\ncase CQE_CODE_RECEIVE_V1:\r\ndmabuf = container_of(cq_event, struct hbq_dmabuf,\r\ncq_event);\r\nlpfc_in_buf_free(phba, &dmabuf->dbuf);\r\n}\r\n}\r\n}\r\nstatic void\r\nlpfc_hba_free_post_buf(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring;\r\nstruct lpfc_dmabuf *mp, *next_mp;\r\nLIST_HEAD(buflist);\r\nint count;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED)\r\nlpfc_sli_hbqbuf_free_all(phba);\r\nelse {\r\npring = &psli->ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice_init(&pring->postbufq, &buflist);\r\nspin_unlock_irq(&phba->hbalock);\r\ncount = 0;\r\nlist_for_each_entry_safe(mp, next_mp, &buflist, list) {\r\nlist_del(&mp->list);\r\ncount++;\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\npring->postbufq_cnt -= count;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\n}\r\nstatic void\r\nlpfc_hba_clean_txcmplq(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring;\r\nLIST_HEAD(completions);\r\nint i;\r\nfor (i = 0; i < psli->num_rings; i++) {\r\npring = &psli->ring[i];\r\nif (phba->sli_rev >= LPFC_SLI_REV4)\r\nspin_lock_irq(&pring->ring_lock);\r\nelse\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice_init(&pring->txcmplq, &completions);\r\npring->txcmplq_cnt = 0;\r\nif (phba->sli_rev >= LPFC_SLI_REV4)\r\nspin_unlock_irq(&pring->ring_lock);\r\nelse\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\nlpfc_sli_abort_iocb_ring(phba, pring);\r\n}\r\n}\r\nstatic int\r\nlpfc_hba_down_post_s3(struct lpfc_hba *phba)\r\n{\r\nlpfc_hba_free_post_buf(phba);\r\nlpfc_hba_clean_txcmplq(phba);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_hba_down_post_s4(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_scsi_buf *psb, *psb_next;\r\nLIST_HEAD(aborts);\r\nunsigned long iflag = 0;\r\nstruct lpfc_sglq *sglq_entry = NULL;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring;\r\nlpfc_hba_free_post_buf(phba);\r\nlpfc_hba_clean_txcmplq(phba);\r\npring = &psli->ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&phba->sli4_hba.abts_sgl_list_lock);\r\nlist_for_each_entry(sglq_entry,\r\n&phba->sli4_hba.lpfc_abts_els_sgl_list, list)\r\nsglq_entry->state = SGL_FREED;\r\nspin_lock(&pring->ring_lock);\r\nlist_splice_init(&phba->sli4_hba.lpfc_abts_els_sgl_list,\r\n&phba->sli4_hba.lpfc_sgl_list);\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock(&phba->sli4_hba.abts_sgl_list_lock);\r\nspin_lock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nlist_splice_init(&phba->sli4_hba.lpfc_abts_scsi_buf_list,\r\n&aborts);\r\nspin_unlock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(psb, psb_next, &aborts, list) {\r\npsb->pCmd = NULL;\r\npsb->status = IOSTAT_SUCCESS;\r\n}\r\nspin_lock_irqsave(&phba->scsi_buf_list_put_lock, iflag);\r\nlist_splice(&aborts, &phba->lpfc_scsi_buf_list_put);\r\nspin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);\r\nlpfc_sli4_free_sp_events(phba);\r\nreturn 0;\r\n}\r\nint\r\nlpfc_hba_down_post(struct lpfc_hba *phba)\r\n{\r\nreturn (*phba->lpfc_hba_down_post)(phba);\r\n}\r\nstatic void\r\nlpfc_hb_timeout(unsigned long ptr)\r\n{\r\nstruct lpfc_hba *phba;\r\nuint32_t tmo_posted;\r\nunsigned long iflag;\r\nphba = (struct lpfc_hba *)ptr;\r\nspin_lock_irqsave(&phba->pport->work_port_lock, iflag);\r\ntmo_posted = phba->pport->work_port_events & WORKER_HB_TMO;\r\nif (!tmo_posted)\r\nphba->pport->work_port_events |= WORKER_HB_TMO;\r\nspin_unlock_irqrestore(&phba->pport->work_port_lock, iflag);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_rrq_timeout(unsigned long ptr)\r\n{\r\nstruct lpfc_hba *phba;\r\nunsigned long iflag;\r\nphba = (struct lpfc_hba *)ptr;\r\nspin_lock_irqsave(&phba->pport->work_port_lock, iflag);\r\nif (!(phba->pport->load_flag & FC_UNLOADING))\r\nphba->hba_flag |= HBA_RRQ_ACTIVE;\r\nelse\r\nphba->hba_flag &= ~HBA_RRQ_ACTIVE;\r\nspin_unlock_irqrestore(&phba->pport->work_port_lock, iflag);\r\nif (!(phba->pport->load_flag & FC_UNLOADING))\r\nlpfc_worker_wake_up(phba);\r\n}\r\nstatic void\r\nlpfc_hb_mbox_cmpl(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmboxq)\r\n{\r\nunsigned long drvr_flag;\r\nspin_lock_irqsave(&phba->hbalock, drvr_flag);\r\nphba->hb_outstanding = 0;\r\nspin_unlock_irqrestore(&phba->hbalock, drvr_flag);\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nif (!(phba->pport->fc_flag & FC_OFFLINE_MODE) &&\r\n!(phba->link_state == LPFC_HBA_ERROR) &&\r\n!(phba->pport->load_flag & FC_UNLOADING))\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_INTERVAL));\r\nreturn;\r\n}\r\nvoid\r\nlpfc_hb_timeout_handler(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nLPFC_MBOXQ_t *pmboxq;\r\nstruct lpfc_dmabuf *buf_ptr;\r\nint retval, i;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nLIST_HEAD(completions);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++)\r\nlpfc_rcv_seq_check_edtov(vports[i]);\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nif ((phba->link_state == LPFC_HBA_ERROR) ||\r\n(phba->pport->load_flag & FC_UNLOADING) ||\r\n(phba->pport->fc_flag & FC_OFFLINE_MODE))\r\nreturn;\r\nspin_lock_irq(&phba->pport->work_port_lock);\r\nif (time_after(phba->last_completion_time +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_INTERVAL),\r\njiffies)) {\r\nspin_unlock_irq(&phba->pport->work_port_lock);\r\nif (!phba->hb_outstanding)\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_INTERVAL));\r\nelse\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_TIMEOUT));\r\nreturn;\r\n}\r\nspin_unlock_irq(&phba->pport->work_port_lock);\r\nif (phba->elsbuf_cnt &&\r\n(phba->elsbuf_cnt == phba->elsbuf_prev_cnt)) {\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice_init(&phba->elsbuf, &completions);\r\nphba->elsbuf_cnt = 0;\r\nphba->elsbuf_prev_cnt = 0;\r\nspin_unlock_irq(&phba->hbalock);\r\nwhile (!list_empty(&completions)) {\r\nlist_remove_head(&completions, buf_ptr,\r\nstruct lpfc_dmabuf, list);\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\n}\r\n}\r\nphba->elsbuf_prev_cnt = phba->elsbuf_cnt;\r\nif (phba->cfg_enable_hba_heartbeat) {\r\nif (!phba->hb_outstanding) {\r\nif ((!(psli->sli_flag & LPFC_SLI_MBOX_ACTIVE)) &&\r\n(list_empty(&psli->mboxq))) {\r\npmboxq = mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!pmboxq) {\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 *\r\nLPFC_HB_MBOX_INTERVAL));\r\nreturn;\r\n}\r\nlpfc_heart_beat(phba, pmboxq);\r\npmboxq->mbox_cmpl = lpfc_hb_mbox_cmpl;\r\npmboxq->vport = phba->pport;\r\nretval = lpfc_sli_issue_mbox(phba, pmboxq,\r\nMBX_NOWAIT);\r\nif (retval != MBX_BUSY &&\r\nretval != MBX_SUCCESS) {\r\nmempool_free(pmboxq,\r\nphba->mbox_mem_pool);\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 *\r\nLPFC_HB_MBOX_INTERVAL));\r\nreturn;\r\n}\r\nphba->skipped_hb = 0;\r\nphba->hb_outstanding = 1;\r\n} else if (time_before_eq(phba->last_completion_time,\r\nphba->skipped_hb)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2857 Last completion time not "\r\n" updated in %d ms\n",\r\njiffies_to_msecs(jiffies\r\n- phba->last_completion_time));\r\n} else\r\nphba->skipped_hb = jiffies;\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_TIMEOUT));\r\nreturn;\r\n} else {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0459 Adapter heartbeat still out"\r\n"standing:last compl time was %d ms.\n",\r\njiffies_to_msecs(jiffies\r\n- phba->last_completion_time));\r\nmod_timer(&phba->hb_tmofunc,\r\njiffies +\r\nmsecs_to_jiffies(1000 * LPFC_HB_MBOX_TIMEOUT));\r\n}\r\n}\r\n}\r\nstatic void\r\nlpfc_offline_eratt(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag &= ~LPFC_SLI_ACTIVE;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_offline_prep(phba, LPFC_MBX_NO_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_reset_barrier(phba);\r\nspin_lock_irq(&phba->hbalock);\r\nlpfc_sli_brdreset(phba);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_hba_down_post(phba);\r\nlpfc_sli_brdready(phba, HS_MBRDY);\r\nlpfc_unblock_mgmt_io(phba);\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_sli4_offline_eratt(struct lpfc_hba *phba)\r\n{\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_state = LPFC_HBA_ERROR;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_offline_prep(phba, LPFC_MBX_NO_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_hba_down_post(phba);\r\nlpfc_unblock_mgmt_io(phba);\r\n}\r\nstatic void\r\nlpfc_handle_deferred_eratt(struct lpfc_hba *phba)\r\n{\r\nuint32_t old_host_status = phba->work_hs;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nif (pci_channel_offline(phba->pcidev)) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~DEFER_ERATT;\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0479 Deferred Adapter Hardware Error "\r\n"Data: x%x x%x x%x\n",\r\nphba->work_hs,\r\nphba->work_status[0], phba->work_status[1]);\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag &= ~LPFC_SLI_ACTIVE;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_abort_fcp_rings(phba);\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nwhile (phba->work_hs & HS_FFER1) {\r\nmsleep(100);\r\nif (lpfc_readl(phba->HSregaddr, &phba->work_hs)) {\r\nphba->work_hs = UNPLUG_ERR ;\r\nbreak;\r\n}\r\nif (phba->pport->load_flag & FC_UNLOADING) {\r\nphba->work_hs = 0;\r\nbreak;\r\n}\r\n}\r\nif ((!phba->work_hs) && (!(phba->pport->load_flag & FC_UNLOADING)))\r\nphba->work_hs = old_host_status & ~HS_FFER1;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~DEFER_ERATT;\r\nspin_unlock_irq(&phba->hbalock);\r\nphba->work_status[0] = readl(phba->MBslimaddr + 0xa8);\r\nphba->work_status[1] = readl(phba->MBslimaddr + 0xac);\r\n}\r\nstatic void\r\nlpfc_board_errevt_to_mgmt(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_board_event_header board_event;\r\nstruct Scsi_Host *shost;\r\nboard_event.event_type = FC_REG_BOARD_EVENT;\r\nboard_event.subcategory = LPFC_EVENT_PORTINTERR;\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(board_event),\r\n(char *) &board_event,\r\nLPFC_NL_VENDOR_ID);\r\n}\r\nstatic void\r\nlpfc_handle_eratt_s3(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nuint32_t event_data;\r\nunsigned long temperature;\r\nstruct temp_event temp_event_data;\r\nstruct Scsi_Host *shost;\r\nif (pci_channel_offline(phba->pcidev)) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~DEFER_ERATT;\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\n}\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn;\r\nlpfc_board_errevt_to_mgmt(phba);\r\nif (phba->hba_flag & DEFER_ERATT)\r\nlpfc_handle_deferred_eratt(phba);\r\nif ((phba->work_hs & HS_FFER6) || (phba->work_hs & HS_FFER8)) {\r\nif (phba->work_hs & HS_FFER6)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,\r\n"1301 Re-establishing Link "\r\n"Data: x%x x%x x%x\n",\r\nphba->work_hs, phba->work_status[0],\r\nphba->work_status[1]);\r\nif (phba->work_hs & HS_FFER8)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,\r\n"2861 Host Authentication device "\r\n"zeroization Data:x%x x%x x%x\n",\r\nphba->work_hs, phba->work_status[0],\r\nphba->work_status[1]);\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag &= ~LPFC_SLI_ACTIVE;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_abort_fcp_rings(phba);\r\nlpfc_offline_prep(phba, LPFC_MBX_NO_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_sli_brdrestart(phba);\r\nif (lpfc_online(phba) == 0) {\r\nlpfc_unblock_mgmt_io(phba);\r\nreturn;\r\n}\r\nlpfc_unblock_mgmt_io(phba);\r\n} else if (phba->work_hs & HS_CRIT_TEMP) {\r\ntemperature = readl(phba->MBslimaddr + TEMPERATURE_OFFSET);\r\ntemp_event_data.event_type = FC_REG_TEMPERATURE_EVENT;\r\ntemp_event_data.event_code = LPFC_CRIT_TEMP;\r\ntemp_event_data.data = (uint32_t)temperature;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0406 Adapter maximum temperature exceeded "\r\n"(%ld), taking this port offline "\r\n"Data: x%x x%x x%x\n",\r\ntemperature, phba->work_hs,\r\nphba->work_status[0], phba->work_status[1]);\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(temp_event_data),\r\n(char *) &temp_event_data,\r\nSCSI_NL_VID_TYPE_PCI\r\n| PCI_VENDOR_ID_EMULEX);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->over_temp_state = HBA_OVER_TEMP;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_offline_eratt(phba);\r\n} else {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0457 Adapter Hardware Error "\r\n"Data: x%x x%x x%x\n",\r\nphba->work_hs,\r\nphba->work_status[0], phba->work_status[1]);\r\nevent_data = FC_REG_DUMP_EVENT;\r\nshost = lpfc_shost_from_vport(vport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(event_data), (char *) &event_data,\r\nSCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX);\r\nlpfc_offline_eratt(phba);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli4_port_sta_fn_reset(struct lpfc_hba *phba, int mbx_action,\r\nbool en_rn_msg)\r\n{\r\nint rc;\r\nuint32_t intr_mode;\r\nrc = lpfc_sli4_pdev_status_reg_wait(phba);\r\nif (!rc) {\r\nif (en_rn_msg)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2887 Reset Needed: Attempting Port "\r\n"Recovery...\n");\r\nlpfc_offline_prep(phba, mbx_action);\r\nlpfc_offline(phba);\r\nlpfc_sli4_disable_intr(phba);\r\nlpfc_sli_brdrestart(phba);\r\nintr_mode = lpfc_sli4_enable_intr(phba, phba->intr_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3175 Failed to enable interrupt\n");\r\nreturn -EIO;\r\n} else {\r\nphba->intr_mode = intr_mode;\r\n}\r\nrc = lpfc_online(phba);\r\nif (rc == 0)\r\nlpfc_unblock_mgmt_io(phba);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_handle_eratt_s4(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nuint32_t event_data;\r\nstruct Scsi_Host *shost;\r\nuint32_t if_type;\r\nstruct lpfc_register portstat_reg = {0};\r\nuint32_t reg_err1, reg_err2;\r\nuint32_t uerrlo_reg, uemasklo_reg;\r\nuint32_t pci_rd_rc1, pci_rd_rc2;\r\nbool en_rn_msg = true;\r\nstruct temp_event temp_event_data;\r\nint rc;\r\nif (pci_channel_offline(phba->pcidev))\r\nreturn;\r\nif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\npci_rd_rc1 = lpfc_readl(\r\nphba->sli4_hba.u.if_type0.UERRLOregaddr,\r\n&uerrlo_reg);\r\npci_rd_rc2 = lpfc_readl(\r\nphba->sli4_hba.u.if_type0.UEMASKLOregaddr,\r\n&uemasklo_reg);\r\nif (pci_rd_rc1 == -EIO && pci_rd_rc2 == -EIO)\r\nreturn;\r\nlpfc_sli4_offline_eratt(phba);\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\npci_rd_rc1 = lpfc_readl(\r\nphba->sli4_hba.u.if_type2.STATUSregaddr,\r\n&portstat_reg.word0);\r\nif (pci_rd_rc1 == -EIO) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3151 PCI bus read access failure: x%x\n",\r\nreadl(phba->sli4_hba.u.if_type2.STATUSregaddr));\r\nreturn;\r\n}\r\nreg_err1 = readl(phba->sli4_hba.u.if_type2.ERR1regaddr);\r\nreg_err2 = readl(phba->sli4_hba.u.if_type2.ERR2regaddr);\r\nif (bf_get(lpfc_sliport_status_oti, &portstat_reg)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2889 Port Overtemperature event, "\r\n"taking port offline Data: x%x x%x\n",\r\nreg_err1, reg_err2);\r\ntemp_event_data.event_type = FC_REG_TEMPERATURE_EVENT;\r\ntemp_event_data.event_code = LPFC_CRIT_TEMP;\r\ntemp_event_data.data = 0xFFFFFFFF;\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(temp_event_data),\r\n(char *)&temp_event_data,\r\nSCSI_NL_VID_TYPE_PCI\r\n| PCI_VENDOR_ID_EMULEX);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->over_temp_state = HBA_OVER_TEMP;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli4_offline_eratt(phba);\r\nreturn;\r\n}\r\nif (reg_err1 == SLIPORT_ERR1_REG_ERR_CODE_2 &&\r\nreg_err2 == SLIPORT_ERR2_REG_FW_RESTART) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3143 Port Down: Firmware Update "\r\n"Detected\n");\r\nen_rn_msg = false;\r\n} else if (reg_err1 == SLIPORT_ERR1_REG_ERR_CODE_2 &&\r\nreg_err2 == SLIPORT_ERR2_REG_FORCED_DUMP)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3144 Port Down: Debug Dump\n");\r\nelse if (reg_err1 == SLIPORT_ERR1_REG_ERR_CODE_2 &&\r\nreg_err2 == SLIPORT_ERR2_REG_FUNC_PROVISON)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3145 Port Down: Provisioning\n");\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn;\r\nrc = lpfc_sli4_port_sta_fn_reset(phba, LPFC_MBX_NO_WAIT,\r\nen_rn_msg);\r\nif (rc == 0) {\r\nif (reg_err1 == SLIPORT_ERR1_REG_ERR_CODE_2 &&\r\nreg_err2 == SLIPORT_ERR2_REG_FORCED_DUMP)\r\nreturn;\r\nelse\r\nbreak;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3152 Unrecoverable error, bring the port "\r\n"offline\n");\r\nlpfc_sli4_offline_eratt(phba);\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\nbreak;\r\n}\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"3123 Report dump event to upper layer\n");\r\nlpfc_board_errevt_to_mgmt(phba);\r\nevent_data = FC_REG_DUMP_EVENT;\r\nshost = lpfc_shost_from_vport(vport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(event_data), (char *) &event_data,\r\nSCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX);\r\n}\r\nvoid\r\nlpfc_handle_eratt(struct lpfc_hba *phba)\r\n{\r\n(*phba->lpfc_handle_eratt)(phba);\r\n}\r\nvoid\r\nlpfc_handle_latt(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nLPFC_MBOXQ_t *pmb;\r\nvolatile uint32_t control;\r\nstruct lpfc_dmabuf *mp;\r\nint rc = 0;\r\npmb = (LPFC_MBOXQ_t *)mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nrc = 1;\r\ngoto lpfc_handle_latt_err_exit;\r\n}\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nrc = 2;\r\ngoto lpfc_handle_latt_free_pmb;\r\n}\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp->virt) {\r\nrc = 3;\r\ngoto lpfc_handle_latt_free_mp;\r\n}\r\nlpfc_els_flush_all_cmd(phba);\r\npsli->slistat.link_event++;\r\nlpfc_read_topology(phba, pmb, mp);\r\npmb->mbox_cmpl = lpfc_mbx_cmpl_read_topology;\r\npmb->vport = vport;\r\nphba->sli.ring[LPFC_ELS_RING].flag |= LPFC_STOP_IOCB_EVENT;\r\nrc = lpfc_sli_issue_mbox (phba, pmb, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nrc = 4;\r\ngoto lpfc_handle_latt_free_mbuf;\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nwritel(HA_LATT, phba->HAregaddr);\r\nreadl(phba->HAregaddr);\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\nlpfc_handle_latt_free_mbuf:\r\nphba->sli.ring[LPFC_ELS_RING].flag &= ~LPFC_STOP_IOCB_EVENT;\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nlpfc_handle_latt_free_mp:\r\nkfree(mp);\r\nlpfc_handle_latt_free_pmb:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nlpfc_handle_latt_err_exit:\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag |= LPFC_PROCESS_LA;\r\ncontrol = readl(phba->HCregaddr);\r\ncontrol |= HC_LAINT_ENA;\r\nwritel(control, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\nwritel(HA_LATT, phba->HAregaddr);\r\nreadl(phba->HAregaddr);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_linkdown(phba);\r\nphba->link_state = LPFC_HBA_ERROR;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"0300 LATT: Cannot issue READ_LA: Data:%d\n", rc);\r\nreturn;\r\n}\r\nint\r\nlpfc_parse_vpd(struct lpfc_hba *phba, uint8_t *vpd, int len)\r\n{\r\nuint8_t lenlo, lenhi;\r\nint Length;\r\nint i, j;\r\nint finished = 0;\r\nint index = 0;\r\nif (!vpd)\r\nreturn 0;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0455 Vital Product Data: x%x x%x x%x x%x\n",\r\n(uint32_t) vpd[0], (uint32_t) vpd[1], (uint32_t) vpd[2],\r\n(uint32_t) vpd[3]);\r\nwhile (!finished && (index < (len - 4))) {\r\nswitch (vpd[index]) {\r\ncase 0x82:\r\ncase 0x91:\r\nindex += 1;\r\nlenlo = vpd[index];\r\nindex += 1;\r\nlenhi = vpd[index];\r\nindex += 1;\r\ni = ((((unsigned short)lenhi) << 8) + lenlo);\r\nindex += i;\r\nbreak;\r\ncase 0x90:\r\nindex += 1;\r\nlenlo = vpd[index];\r\nindex += 1;\r\nlenhi = vpd[index];\r\nindex += 1;\r\nLength = ((((unsigned short)lenhi) << 8) + lenlo);\r\nif (Length > len - index)\r\nLength = len - index;\r\nwhile (Length > 0) {\r\nif ((vpd[index] == 'S') && (vpd[index+1] == 'N')) {\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nj = 0;\r\nLength -= (3+i);\r\nwhile(i--) {\r\nphba->SerialNumber[j++] = vpd[index++];\r\nif (j == 31)\r\nbreak;\r\n}\r\nphba->SerialNumber[j] = 0;\r\ncontinue;\r\n}\r\nelse if ((vpd[index] == 'V') && (vpd[index+1] == '1')) {\r\nphba->vpd_flag |= VPD_MODEL_DESC;\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nj = 0;\r\nLength -= (3+i);\r\nwhile(i--) {\r\nphba->ModelDesc[j++] = vpd[index++];\r\nif (j == 255)\r\nbreak;\r\n}\r\nphba->ModelDesc[j] = 0;\r\ncontinue;\r\n}\r\nelse if ((vpd[index] == 'V') && (vpd[index+1] == '2')) {\r\nphba->vpd_flag |= VPD_MODEL_NAME;\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nj = 0;\r\nLength -= (3+i);\r\nwhile(i--) {\r\nphba->ModelName[j++] = vpd[index++];\r\nif (j == 79)\r\nbreak;\r\n}\r\nphba->ModelName[j] = 0;\r\ncontinue;\r\n}\r\nelse if ((vpd[index] == 'V') && (vpd[index+1] == '3')) {\r\nphba->vpd_flag |= VPD_PROGRAM_TYPE;\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nj = 0;\r\nLength -= (3+i);\r\nwhile(i--) {\r\nphba->ProgramType[j++] = vpd[index++];\r\nif (j == 255)\r\nbreak;\r\n}\r\nphba->ProgramType[j] = 0;\r\ncontinue;\r\n}\r\nelse if ((vpd[index] == 'V') && (vpd[index+1] == '4')) {\r\nphba->vpd_flag |= VPD_PORT;\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nj = 0;\r\nLength -= (3+i);\r\nwhile(i--) {\r\nif ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n(phba->sli4_hba.pport_name_sta ==\r\nLPFC_SLI4_PPNAME_GET)) {\r\nj++;\r\nindex++;\r\n} else\r\nphba->Port[j++] = vpd[index++];\r\nif (j == 19)\r\nbreak;\r\n}\r\nif ((phba->sli_rev != LPFC_SLI_REV4) ||\r\n(phba->sli4_hba.pport_name_sta ==\r\nLPFC_SLI4_PPNAME_NON))\r\nphba->Port[j] = 0;\r\ncontinue;\r\n}\r\nelse {\r\nindex += 2;\r\ni = vpd[index];\r\nindex += 1;\r\nindex += i;\r\nLength -= (3 + i);\r\n}\r\n}\r\nfinished = 0;\r\nbreak;\r\ncase 0x78:\r\nfinished = 1;\r\nbreak;\r\ndefault:\r\nindex ++;\r\nbreak;\r\n}\r\n}\r\nreturn(1);\r\n}\r\nstatic void\r\nlpfc_get_hba_model_desc(struct lpfc_hba *phba, uint8_t *mdp, uint8_t *descp)\r\n{\r\nlpfc_vpd_t *vp;\r\nuint16_t dev_id = phba->pcidev->device;\r\nint max_speed;\r\nint GE = 0;\r\nint oneConnect = 0;\r\nstruct {\r\nchar *name;\r\nchar *bus;\r\nchar *function;\r\n} m = {"<Unknown>", "", ""};\r\nif (mdp && mdp[0] != '\0'\r\n&& descp && descp[0] != '\0')\r\nreturn;\r\nif (phba->lmt & LMT_16Gb)\r\nmax_speed = 16;\r\nelse if (phba->lmt & LMT_10Gb)\r\nmax_speed = 10;\r\nelse if (phba->lmt & LMT_8Gb)\r\nmax_speed = 8;\r\nelse if (phba->lmt & LMT_4Gb)\r\nmax_speed = 4;\r\nelse if (phba->lmt & LMT_2Gb)\r\nmax_speed = 2;\r\nelse if (phba->lmt & LMT_1Gb)\r\nmax_speed = 1;\r\nelse\r\nmax_speed = 0;\r\nvp = &phba->vpd;\r\nswitch (dev_id) {\r\ncase PCI_DEVICE_ID_FIREFLY:\r\nm = (typeof(m)){"LP6000", "PCI",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SUPERFLY:\r\nif (vp->rev.biuRev >= 1 && vp->rev.biuRev <= 3)\r\nm = (typeof(m)){"LP7000", "PCI", ""};\r\nelse\r\nm = (typeof(m)){"LP7000E", "PCI", ""};\r\nm.function = "Obsolete, Unsupported Fibre Channel Adapter";\r\nbreak;\r\ncase PCI_DEVICE_ID_DRAGONFLY:\r\nm = (typeof(m)){"LP8000", "PCI",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_CENTAUR:\r\nif (FC_JEDEC_ID(vp->rev.biuRev) == CENTAUR_2G_JEDEC_ID)\r\nm = (typeof(m)){"LP9002", "PCI", ""};\r\nelse\r\nm = (typeof(m)){"LP9000", "PCI", ""};\r\nm.function = "Obsolete, Unsupported Fibre Channel Adapter";\r\nbreak;\r\ncase PCI_DEVICE_ID_RFLY:\r\nm = (typeof(m)){"LP952", "PCI",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_PEGASUS:\r\nm = (typeof(m)){"LP9802", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_THOR:\r\nm = (typeof(m)){"LP10000", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_VIPER:\r\nm = (typeof(m)){"LPX1000", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_PFLY:\r\nm = (typeof(m)){"LP982", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_TFLY:\r\nm = (typeof(m)){"LP1050", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_HELIOS:\r\nm = (typeof(m)){"LP11000", "PCI-X2",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_HELIOS_SCSP:\r\nm = (typeof(m)){"LP11000-SP", "PCI-X2",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_HELIOS_DCSP:\r\nm = (typeof(m)){"LP11002-SP", "PCI-X2",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_NEPTUNE:\r\nm = (typeof(m)){"LPe1000", "PCIe",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_NEPTUNE_SCSP:\r\nm = (typeof(m)){"LPe1000-SP", "PCIe",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_NEPTUNE_DCSP:\r\nm = (typeof(m)){"LPe1002-SP", "PCIe",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_BMID:\r\nm = (typeof(m)){"LP1150", "PCI-X2", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_BSMB:\r\nm = (typeof(m)){"LP111", "PCI-X2",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_ZEPHYR:\r\nm = (typeof(m)){"LPe11000", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_ZEPHYR_SCSP:\r\nm = (typeof(m)){"LPe11000", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_ZEPHYR_DCSP:\r\nm = (typeof(m)){"LP2105", "PCIe", "FCoE Adapter"};\r\nGE = 1;\r\nbreak;\r\ncase PCI_DEVICE_ID_ZMID:\r\nm = (typeof(m)){"LPe1150", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_ZSMB:\r\nm = (typeof(m)){"LPe111", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LP101:\r\nm = (typeof(m)){"LP101", "PCI-X",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LP10000S:\r\nm = (typeof(m)){"LP10000-S", "PCI",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LP11000S:\r\nm = (typeof(m)){"LP11000-S", "PCI-X2",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LPE11000S:\r\nm = (typeof(m)){"LPe11000-S", "PCIe",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT:\r\nm = (typeof(m)){"LPe12000", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT_MID:\r\nm = (typeof(m)){"LPe1250", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT_SMB:\r\nm = (typeof(m)){"LPe121", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT_DCSP:\r\nm = (typeof(m)){"LPe12002-SP", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT_SCSP:\r\nm = (typeof(m)){"LPe12000-SP", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SAT_S:\r\nm = (typeof(m)){"LPe12000-S", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_HORNET:\r\nm = (typeof(m)){"LP21000", "PCIe",\r\n"Obsolete, Unsupported FCoE Adapter"};\r\nGE = 1;\r\nbreak;\r\ncase PCI_DEVICE_ID_PROTEUS_VF:\r\nm = (typeof(m)){"LPev12000", "PCIe IOV",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_PROTEUS_PF:\r\nm = (typeof(m)){"LPev12000", "PCIe IOV",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_PROTEUS_S:\r\nm = (typeof(m)){"LPemv12002-S", "PCIe IOV",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_TIGERSHARK:\r\noneConnect = 1;\r\nm = (typeof(m)){"OCe10100", "PCIe", "FCoE"};\r\nbreak;\r\ncase PCI_DEVICE_ID_TOMCAT:\r\noneConnect = 1;\r\nm = (typeof(m)){"OCe11100", "PCIe", "FCoE"};\r\nbreak;\r\ncase PCI_DEVICE_ID_FALCON:\r\nm = (typeof(m)){"LPSe12002-ML1-E", "PCIe",\r\n"EmulexSecure Fibre"};\r\nbreak;\r\ncase PCI_DEVICE_ID_BALIUS:\r\nm = (typeof(m)){"LPVe12002", "PCIe Shared I/O",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LANCER_FC:\r\nm = (typeof(m)){"LPe16000", "PCIe", "Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LANCER_FC_VF:\r\nm = (typeof(m)){"LPe16000", "PCIe",\r\n"Obsolete, Unsupported Fibre Channel Adapter"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LANCER_FCOE:\r\noneConnect = 1;\r\nm = (typeof(m)){"OCe15100", "PCIe", "FCoE"};\r\nbreak;\r\ncase PCI_DEVICE_ID_LANCER_FCOE_VF:\r\noneConnect = 1;\r\nm = (typeof(m)){"OCe15100", "PCIe",\r\n"Obsolete, Unsupported FCoE"};\r\nbreak;\r\ncase PCI_DEVICE_ID_SKYHAWK:\r\ncase PCI_DEVICE_ID_SKYHAWK_VF:\r\noneConnect = 1;\r\nm = (typeof(m)){"OCe14000", "PCIe", "FCoE"};\r\nbreak;\r\ndefault:\r\nm = (typeof(m)){"Unknown", "", ""};\r\nbreak;\r\n}\r\nif (mdp && mdp[0] == '\0')\r\nsnprintf(mdp, 79,"%s", m.name);\r\nif (descp && descp[0] == '\0') {\r\nif (oneConnect)\r\nsnprintf(descp, 255,\r\n"Emulex OneConnect %s, %s Initiator %s",\r\nm.name, m.function,\r\nphba->Port);\r\nelse if (max_speed == 0)\r\nsnprintf(descp, 255,\r\n"Emulex %s %s %s ",\r\nm.name, m.bus, m.function);\r\nelse\r\nsnprintf(descp, 255,\r\n"Emulex %s %d%s %s %s",\r\nm.name, max_speed, (GE) ? "GE" : "Gb",\r\nm.bus, m.function);\r\n}\r\n}\r\nint\r\nlpfc_post_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring, int cnt)\r\n{\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *iocb;\r\nstruct lpfc_dmabuf *mp1, *mp2;\r\ncnt += pring->missbufcnt;\r\nwhile (cnt > 0) {\r\niocb = lpfc_sli_get_iocbq(phba);\r\nif (iocb == NULL) {\r\npring->missbufcnt = cnt;\r\nreturn cnt;\r\n}\r\nicmd = &iocb->iocb;\r\nmp1 = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp1)\r\nmp1->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &mp1->phys);\r\nif (!mp1 || !mp1->virt) {\r\nkfree(mp1);\r\nlpfc_sli_release_iocbq(phba, iocb);\r\npring->missbufcnt = cnt;\r\nreturn cnt;\r\n}\r\nINIT_LIST_HEAD(&mp1->list);\r\nif (cnt > 1) {\r\nmp2 = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp2)\r\nmp2->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\r\n&mp2->phys);\r\nif (!mp2 || !mp2->virt) {\r\nkfree(mp2);\r\nlpfc_mbuf_free(phba, mp1->virt, mp1->phys);\r\nkfree(mp1);\r\nlpfc_sli_release_iocbq(phba, iocb);\r\npring->missbufcnt = cnt;\r\nreturn cnt;\r\n}\r\nINIT_LIST_HEAD(&mp2->list);\r\n} else {\r\nmp2 = NULL;\r\n}\r\nicmd->un.cont64[0].addrHigh = putPaddrHigh(mp1->phys);\r\nicmd->un.cont64[0].addrLow = putPaddrLow(mp1->phys);\r\nicmd->un.cont64[0].tus.f.bdeSize = FCELSSIZE;\r\nicmd->ulpBdeCount = 1;\r\ncnt--;\r\nif (mp2) {\r\nicmd->un.cont64[1].addrHigh = putPaddrHigh(mp2->phys);\r\nicmd->un.cont64[1].addrLow = putPaddrLow(mp2->phys);\r\nicmd->un.cont64[1].tus.f.bdeSize = FCELSSIZE;\r\ncnt--;\r\nicmd->ulpBdeCount = 2;\r\n}\r\nicmd->ulpCommand = CMD_QUE_RING_BUF64_CN;\r\nicmd->ulpLe = 1;\r\nif (lpfc_sli_issue_iocb(phba, pring->ringno, iocb, 0) ==\r\nIOCB_ERROR) {\r\nlpfc_mbuf_free(phba, mp1->virt, mp1->phys);\r\nkfree(mp1);\r\ncnt++;\r\nif (mp2) {\r\nlpfc_mbuf_free(phba, mp2->virt, mp2->phys);\r\nkfree(mp2);\r\ncnt++;\r\n}\r\nlpfc_sli_release_iocbq(phba, iocb);\r\npring->missbufcnt = cnt;\r\nreturn cnt;\r\n}\r\nlpfc_sli_ringpostbuf_put(phba, pring, mp1);\r\nif (mp2)\r\nlpfc_sli_ringpostbuf_put(phba, pring, mp2);\r\n}\r\npring->missbufcnt = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_post_rcv_buf(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nlpfc_post_buffer(phba, &psli->ring[LPFC_ELS_RING], LPFC_BUF_RING0);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sha_init(uint32_t * HashResultPointer)\r\n{\r\nHashResultPointer[0] = 0x67452301;\r\nHashResultPointer[1] = 0xEFCDAB89;\r\nHashResultPointer[2] = 0x98BADCFE;\r\nHashResultPointer[3] = 0x10325476;\r\nHashResultPointer[4] = 0xC3D2E1F0;\r\n}\r\nstatic void\r\nlpfc_sha_iterate(uint32_t * HashResultPointer, uint32_t * HashWorkingPointer)\r\n{\r\nint t;\r\nuint32_t TEMP;\r\nuint32_t A, B, C, D, E;\r\nt = 16;\r\ndo {\r\nHashWorkingPointer[t] =\r\nS(1,\r\nHashWorkingPointer[t - 3] ^ HashWorkingPointer[t -\r\n8] ^\r\nHashWorkingPointer[t - 14] ^ HashWorkingPointer[t - 16]);\r\n} while (++t <= 79);\r\nt = 0;\r\nA = HashResultPointer[0];\r\nB = HashResultPointer[1];\r\nC = HashResultPointer[2];\r\nD = HashResultPointer[3];\r\nE = HashResultPointer[4];\r\ndo {\r\nif (t < 20) {\r\nTEMP = ((B & C) | ((~B) & D)) + 0x5A827999;\r\n} else if (t < 40) {\r\nTEMP = (B ^ C ^ D) + 0x6ED9EBA1;\r\n} else if (t < 60) {\r\nTEMP = ((B & C) | (B & D) | (C & D)) + 0x8F1BBCDC;\r\n} else {\r\nTEMP = (B ^ C ^ D) + 0xCA62C1D6;\r\n}\r\nTEMP += S(5, A) + E + HashWorkingPointer[t];\r\nE = D;\r\nD = C;\r\nC = S(30, B);\r\nB = A;\r\nA = TEMP;\r\n} while (++t <= 79);\r\nHashResultPointer[0] += A;\r\nHashResultPointer[1] += B;\r\nHashResultPointer[2] += C;\r\nHashResultPointer[3] += D;\r\nHashResultPointer[4] += E;\r\n}\r\nstatic void\r\nlpfc_challenge_key(uint32_t * RandomChallenge, uint32_t * HashWorking)\r\n{\r\n*HashWorking = (*RandomChallenge ^ *HashWorking);\r\n}\r\nvoid\r\nlpfc_hba_init(struct lpfc_hba *phba, uint32_t *hbainit)\r\n{\r\nint t;\r\nuint32_t *HashWorking;\r\nuint32_t *pwwnn = (uint32_t *) phba->wwnn;\r\nHashWorking = kcalloc(80, sizeof(uint32_t), GFP_KERNEL);\r\nif (!HashWorking)\r\nreturn;\r\nHashWorking[0] = HashWorking[78] = *pwwnn++;\r\nHashWorking[1] = HashWorking[79] = *pwwnn;\r\nfor (t = 0; t < 7; t++)\r\nlpfc_challenge_key(phba->RandomData + t, HashWorking + t);\r\nlpfc_sha_init(hbainit);\r\nlpfc_sha_iterate(hbainit, HashWorking);\r\nkfree(HashWorking);\r\n}\r\nvoid\r\nlpfc_cleanup(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nint i = 0;\r\nif (phba->link_state > LPFC_LINK_DOWN)\r\nlpfc_port_link_failure(vport);\r\nlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp,\r\nNLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\ncontinue;\r\nspin_lock_irq(&phba->ndlp_lock);\r\nNLP_SET_FREE_REQ(ndlp);\r\nspin_unlock_irq(&phba->ndlp_lock);\r\nlpfc_nlp_put(ndlp);\r\ncontinue;\r\n}\r\nspin_lock_irq(&phba->ndlp_lock);\r\nif (NLP_CHK_FREE_REQ(ndlp)) {\r\nspin_unlock_irq(&phba->ndlp_lock);\r\ncontinue;\r\n} else\r\nNLP_SET_FREE_REQ(ndlp);\r\nspin_unlock_irq(&phba->ndlp_lock);\r\nif (vport->port_type != LPFC_PHYSICAL_PORT &&\r\nndlp->nlp_DID == Fabric_DID) {\r\nlpfc_nlp_put(ndlp);\r\ncontinue;\r\n}\r\nif (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {\r\nlpfc_nlp_put(ndlp);\r\ncontinue;\r\n}\r\nif (ndlp->nlp_type & NLP_FABRIC)\r\nlpfc_disc_state_machine(vport, ndlp, NULL,\r\nNLP_EVT_DEVICE_RECOVERY);\r\nlpfc_disc_state_machine(vport, ndlp, NULL,\r\nNLP_EVT_DEVICE_RM);\r\n}\r\nwhile (!list_empty(&vport->fc_nodes)) {\r\nif (i++ > 3000) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0233 Nodelist not empty\n");\r\nlist_for_each_entry_safe(ndlp, next_ndlp,\r\n&vport->fc_nodes, nlp_listp) {\r\nlpfc_printf_vlog(ndlp->vport, KERN_ERR,\r\nLOG_NODE,\r\n"0282 did:x%x ndlp:x%p "\r\n"usgmap:x%x refcnt:%d\n",\r\nndlp->nlp_DID, (void *)ndlp,\r\nndlp->nlp_usg_map,\r\natomic_read(\r\n&ndlp->kref.refcount));\r\n}\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nlpfc_cleanup_vports_rrqs(vport, NULL);\r\n}\r\nvoid\r\nlpfc_stop_vport_timers(struct lpfc_vport *vport)\r\n{\r\ndel_timer_sync(&vport->els_tmofunc);\r\ndel_timer_sync(&vport->fc_fdmitmo);\r\ndel_timer_sync(&vport->delayed_disc_tmo);\r\nlpfc_can_disctmo(vport);\r\nreturn;\r\n}\r\nvoid\r\n__lpfc_sli4_stop_fcf_redisc_wait_timer(struct lpfc_hba *phba)\r\n{\r\nphba->fcf.fcf_flag &= ~FCF_REDISC_PEND;\r\ndel_timer(&phba->fcf.redisc_wait);\r\n}\r\nvoid\r\nlpfc_sli4_stop_fcf_redisc_wait_timer(struct lpfc_hba *phba)\r\n{\r\nspin_lock_irq(&phba->hbalock);\r\nif (!(phba->fcf.fcf_flag & FCF_REDISC_PEND)) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\n}\r\n__lpfc_sli4_stop_fcf_redisc_wait_timer(phba);\r\nphba->fcf.fcf_flag &= ~(FCF_DEAD_DISC | FCF_ACVL_DISC);\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nvoid\r\nlpfc_stop_hba_timers(struct lpfc_hba *phba)\r\n{\r\nlpfc_stop_vport_timers(phba->pport);\r\ndel_timer_sync(&phba->sli.mbox_tmo);\r\ndel_timer_sync(&phba->fabric_block_timer);\r\ndel_timer_sync(&phba->eratt_poll);\r\ndel_timer_sync(&phba->hb_tmofunc);\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\ndel_timer_sync(&phba->rrq_tmr);\r\nphba->hba_flag &= ~HBA_RRQ_ACTIVE;\r\n}\r\nphba->hb_outstanding = 0;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\ndel_timer_sync(&phba->fcp_poll_timer);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nlpfc_sli4_stop_fcf_redisc_wait_timer(phba);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0297 Invalid device group (x%x)\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_block_mgmt_io(struct lpfc_hba *phba, int mbx_action)\r\n{\r\nunsigned long iflag;\r\nuint8_t actcmd = MBX_HEARTBEAT;\r\nunsigned long timeout;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nphba->sli.sli_flag |= LPFC_BLOCK_MGMT_IO;\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nif (mbx_action == LPFC_MBX_NO_WAIT)\r\nreturn;\r\ntimeout = msecs_to_jiffies(LPFC_MBOX_TMO * 1000) + jiffies;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nif (phba->sli.mbox_active) {\r\nactcmd = phba->sli.mbox_active->u.mb.mbxCommand;\r\ntimeout = msecs_to_jiffies(lpfc_mbox_tmo_val(phba,\r\nphba->sli.mbox_active) * 1000) + jiffies;\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nwhile (phba->sli.mbox_active) {\r\nmsleep(2);\r\nif (time_after(jiffies, timeout)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2813 Mgmt IO is Blocked %x "\r\n"- mbox cmd %x still active\n",\r\nphba->sli.sli_flag, actcmd);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid\r\nlpfc_sli4_node_prep(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nstruct lpfc_vport **vports;\r\nint i;\r\nif (phba->sli_rev != LPFC_SLI_REV4)\r\nreturn;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL) {\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nif (vports[i]->load_flag & FC_UNLOADING)\r\ncontinue;\r\nlist_for_each_entry_safe(ndlp, next_ndlp,\r\n&vports[i]->fc_nodes,\r\nnlp_listp) {\r\nif (NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp->nlp_rpi =\r\nlpfc_sli4_alloc_rpi(phba);\r\nlpfc_printf_vlog(ndlp->vport, KERN_INFO,\r\nLOG_NODE,\r\n"0009 rpi:%x DID:%x "\r\n"flg:%x map:%x %p\n",\r\nndlp->nlp_rpi,\r\nndlp->nlp_DID,\r\nndlp->nlp_flag,\r\nndlp->nlp_usg_map,\r\nndlp);\r\n}\r\n}\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nint\r\nlpfc_online(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_vport **vports;\r\nint i;\r\nbool vpis_cleared = false;\r\nif (!phba)\r\nreturn 0;\r\nvport = phba->pport;\r\nif (!(vport->fc_flag & FC_OFFLINE_MODE))\r\nreturn 0;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0458 Bring Adapter online\n");\r\nlpfc_block_mgmt_io(phba, LPFC_MBX_WAIT);\r\nif (!lpfc_sli_queue_setup(phba)) {\r\nlpfc_unblock_mgmt_io(phba);\r\nreturn 1;\r\n}\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nif (lpfc_sli4_hba_setup(phba)) {\r\nlpfc_unblock_mgmt_io(phba);\r\nreturn 1;\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nif (!phba->sli4_hba.max_cfg_param.vpi_used)\r\nvpis_cleared = true;\r\nspin_unlock_irq(&phba->hbalock);\r\n} else {\r\nif (lpfc_sli_hba_setup(phba)) {\r\nlpfc_unblock_mgmt_io(phba);\r\nreturn 1;\r\n}\r\n}\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nstruct Scsi_Host *shost;\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(shost->host_lock);\r\nvports[i]->fc_flag &= ~FC_OFFLINE_MODE;\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)\r\nvports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nvports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\r\nif ((vpis_cleared) &&\r\n(vports[i]->port_type !=\r\nLPFC_PHYSICAL_PORT))\r\nvports[i]->vpi = 0;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nlpfc_unblock_mgmt_io(phba);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_unblock_mgmt_io(struct lpfc_hba * phba)\r\n{\r\nunsigned long iflag;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nphba->sli.sli_flag &= ~LPFC_BLOCK_MGMT_IO;\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\n}\r\nvoid\r\nlpfc_offline_prep(struct lpfc_hba *phba, int mbx_action)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nstruct lpfc_vport **vports;\r\nstruct Scsi_Host *shost;\r\nint i;\r\nif (vport->fc_flag & FC_OFFLINE_MODE)\r\nreturn;\r\nlpfc_block_mgmt_io(phba, mbx_action);\r\nlpfc_linkdown(phba);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL) {\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nif (vports[i]->load_flag & FC_UNLOADING)\r\ncontinue;\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(shost->host_lock);\r\nvports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;\r\nvports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nvports[i]->fc_flag &= ~FC_VFI_REGISTERED;\r\nspin_unlock_irq(shost->host_lock);\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nlist_for_each_entry_safe(ndlp, next_ndlp,\r\n&vports[i]->fc_nodes,\r\nnlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp))\r\ncontinue;\r\nif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\r\ncontinue;\r\nif (ndlp->nlp_type & NLP_FABRIC) {\r\nlpfc_disc_state_machine(vports[i], ndlp,\r\nNULL, NLP_EVT_DEVICE_RECOVERY);\r\nlpfc_disc_state_machine(vports[i], ndlp,\r\nNULL, NLP_EVT_DEVICE_RM);\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nlpfc_printf_vlog(ndlp->vport,\r\nKERN_INFO, LOG_NODE,\r\n"0011 lpfc_offline: "\r\n"ndlp:x%p did %x "\r\n"usgmap:x%x rpi:%x\n",\r\nndlp, ndlp->nlp_DID,\r\nndlp->nlp_usg_map,\r\nndlp->nlp_rpi);\r\nlpfc_sli4_free_rpi(phba, ndlp->nlp_rpi);\r\n}\r\nlpfc_unreg_rpi(vports[i], ndlp);\r\n}\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nlpfc_sli_mbox_sys_shutdown(phba, mbx_action);\r\n}\r\nvoid\r\nlpfc_offline(struct lpfc_hba *phba)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_vport **vports;\r\nint i;\r\nif (phba->pport->fc_flag & FC_OFFLINE_MODE)\r\nreturn;\r\nlpfc_stop_port(phba);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++)\r\nlpfc_stop_vport_timers(vports[i]);\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0460 Bring Adapter offline\n");\r\nlpfc_sli_hba_down(phba);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->work_ha = 0;\r\nspin_unlock_irq(&phba->hbalock);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(shost->host_lock);\r\nvports[i]->work_port_events = 0;\r\nvports[i]->fc_flag |= FC_OFFLINE_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nstatic void\r\nlpfc_scsi_free(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_scsi_buf *sb, *sb_next;\r\nstruct lpfc_iocbq *io, *io_next;\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_for_each_entry_safe(sb, sb_next, &phba->lpfc_scsi_buf_list_put,\r\nlist) {\r\nlist_del(&sb->list);\r\npci_pool_free(phba->lpfc_scsi_dma_buf_pool, sb->data,\r\nsb->dma_handle);\r\nkfree(sb);\r\nphba->total_scsi_bufs--;\r\n}\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\nspin_lock(&phba->scsi_buf_list_get_lock);\r\nlist_for_each_entry_safe(sb, sb_next, &phba->lpfc_scsi_buf_list_get,\r\nlist) {\r\nlist_del(&sb->list);\r\npci_pool_free(phba->lpfc_scsi_dma_buf_pool, sb->data,\r\nsb->dma_handle);\r\nkfree(sb);\r\nphba->total_scsi_bufs--;\r\n}\r\nspin_unlock(&phba->scsi_buf_list_get_lock);\r\nlist_for_each_entry_safe(io, io_next, &phba->lpfc_iocb_list, list) {\r\nlist_del(&io->list);\r\nkfree(io);\r\nphba->total_iocbq_bufs--;\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nint\r\nlpfc_sli4_xri_sgl_update(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sglq *sglq_entry = NULL, *sglq_entry_next = NULL;\r\nstruct lpfc_scsi_buf *psb = NULL, *psb_next = NULL;\r\nuint16_t i, lxri, xri_cnt, els_xri_cnt, scsi_xri_cnt;\r\nLIST_HEAD(els_sgl_list);\r\nLIST_HEAD(scsi_sgl_list);\r\nint rc;\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nels_xri_cnt = lpfc_sli4_get_els_iocb_cnt(phba);\r\nif (els_xri_cnt > phba->sli4_hba.els_xri_cnt) {\r\nxri_cnt = els_xri_cnt - phba->sli4_hba.els_xri_cnt;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3157 ELS xri-sgl count increased from "\r\n"%d to %d\n", phba->sli4_hba.els_xri_cnt,\r\nels_xri_cnt);\r\nfor (i = 0; i < xri_cnt; i++) {\r\nsglq_entry = kzalloc(sizeof(struct lpfc_sglq),\r\nGFP_KERNEL);\r\nif (sglq_entry == NULL) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2562 Failure to allocate an "\r\n"ELS sgl entry:%d\n", i);\r\nrc = -ENOMEM;\r\ngoto out_free_mem;\r\n}\r\nsglq_entry->buff_type = GEN_BUFF_TYPE;\r\nsglq_entry->virt = lpfc_mbuf_alloc(phba, 0,\r\n&sglq_entry->phys);\r\nif (sglq_entry->virt == NULL) {\r\nkfree(sglq_entry);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2563 Failure to allocate an "\r\n"ELS mbuf:%d\n", i);\r\nrc = -ENOMEM;\r\ngoto out_free_mem;\r\n}\r\nsglq_entry->sgl = sglq_entry->virt;\r\nmemset(sglq_entry->sgl, 0, LPFC_BPL_SIZE);\r\nsglq_entry->state = SGL_FREED;\r\nlist_add_tail(&sglq_entry->list, &els_sgl_list);\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&pring->ring_lock);\r\nlist_splice_init(&els_sgl_list, &phba->sli4_hba.lpfc_sgl_list);\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\n} else if (els_xri_cnt < phba->sli4_hba.els_xri_cnt) {\r\nxri_cnt = phba->sli4_hba.els_xri_cnt - els_xri_cnt;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3158 ELS xri-sgl count decreased from "\r\n"%d to %d\n", phba->sli4_hba.els_xri_cnt,\r\nels_xri_cnt);\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&pring->ring_lock);\r\nlist_splice_init(&phba->sli4_hba.lpfc_sgl_list, &els_sgl_list);\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\nfor (i = 0; i < xri_cnt; i++) {\r\nlist_remove_head(&els_sgl_list,\r\nsglq_entry, struct lpfc_sglq, list);\r\nif (sglq_entry) {\r\nlpfc_mbuf_free(phba, sglq_entry->virt,\r\nsglq_entry->phys);\r\nkfree(sglq_entry);\r\n}\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&pring->ring_lock);\r\nlist_splice_init(&els_sgl_list, &phba->sli4_hba.lpfc_sgl_list);\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\n} else\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3163 ELS xri-sgl count unchanged: %d\n",\r\nels_xri_cnt);\r\nphba->sli4_hba.els_xri_cnt = els_xri_cnt;\r\nsglq_entry = NULL;\r\nsglq_entry_next = NULL;\r\nlist_for_each_entry_safe(sglq_entry, sglq_entry_next,\r\n&phba->sli4_hba.lpfc_sgl_list, list) {\r\nlxri = lpfc_sli4_next_xritag(phba);\r\nif (lxri == NO_XRI) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2400 Failed to allocate xri for "\r\n"ELS sgl\n");\r\nrc = -ENOMEM;\r\ngoto out_free_mem;\r\n}\r\nsglq_entry->sli4_lxritag = lxri;\r\nsglq_entry->sli4_xritag = phba->sli4_hba.xri_ids[lxri];\r\n}\r\nphba->total_scsi_bufs = 0;\r\nphba->sli4_hba.scsi_xri_max = phba->sli4_hba.max_cfg_param.max_xri -\r\nels_xri_cnt;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2401 Current allocated SCSI xri-sgl count:%d, "\r\n"maximum SCSI xri count:%d\n",\r\nphba->sli4_hba.scsi_xri_cnt,\r\nphba->sli4_hba.scsi_xri_max);\r\nspin_lock_irq(&phba->scsi_buf_list_get_lock);\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_splice_init(&phba->lpfc_scsi_buf_list_get, &scsi_sgl_list);\r\nlist_splice(&phba->lpfc_scsi_buf_list_put, &scsi_sgl_list);\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\nspin_unlock_irq(&phba->scsi_buf_list_get_lock);\r\nif (phba->sli4_hba.scsi_xri_cnt > phba->sli4_hba.scsi_xri_max) {\r\nscsi_xri_cnt = phba->sli4_hba.scsi_xri_cnt -\r\nphba->sli4_hba.scsi_xri_max;\r\nfor (i = 0; i < scsi_xri_cnt; i++) {\r\nlist_remove_head(&scsi_sgl_list, psb,\r\nstruct lpfc_scsi_buf, list);\r\nif (psb) {\r\npci_pool_free(phba->lpfc_scsi_dma_buf_pool,\r\npsb->data, psb->dma_handle);\r\nkfree(psb);\r\n}\r\n}\r\nspin_lock_irq(&phba->scsi_buf_list_get_lock);\r\nphba->sli4_hba.scsi_xri_cnt -= scsi_xri_cnt;\r\nspin_unlock_irq(&phba->scsi_buf_list_get_lock);\r\n}\r\npsb = NULL;\r\npsb_next = NULL;\r\nlist_for_each_entry_safe(psb, psb_next, &scsi_sgl_list, list) {\r\nlxri = lpfc_sli4_next_xritag(phba);\r\nif (lxri == NO_XRI) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2560 Failed to allocate xri for "\r\n"scsi buffer\n");\r\nrc = -ENOMEM;\r\ngoto out_free_mem;\r\n}\r\npsb->cur_iocbq.sli4_lxritag = lxri;\r\npsb->cur_iocbq.sli4_xritag = phba->sli4_hba.xri_ids[lxri];\r\n}\r\nspin_lock_irq(&phba->scsi_buf_list_get_lock);\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_splice_init(&scsi_sgl_list, &phba->lpfc_scsi_buf_list_get);\r\nINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\nspin_unlock_irq(&phba->scsi_buf_list_get_lock);\r\nreturn 0;\r\nout_free_mem:\r\nlpfc_free_els_sgl_list(phba);\r\nlpfc_scsi_free(phba);\r\nreturn rc;\r\n}\r\nstruct lpfc_vport *\r\nlpfc_create_port(struct lpfc_hba *phba, int instance, struct device *dev)\r\n{\r\nstruct lpfc_vport *vport;\r\nstruct Scsi_Host *shost;\r\nint error = 0;\r\nif (dev != &phba->pcidev->dev) {\r\nshost = scsi_host_alloc(&lpfc_vport_template,\r\nsizeof(struct lpfc_vport));\r\n} else {\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nshost = scsi_host_alloc(&lpfc_template,\r\nsizeof(struct lpfc_vport));\r\nelse\r\nshost = scsi_host_alloc(&lpfc_template_s3,\r\nsizeof(struct lpfc_vport));\r\n}\r\nif (!shost)\r\ngoto out;\r\nvport = (struct lpfc_vport *) shost->hostdata;\r\nvport->phba = phba;\r\nvport->load_flag |= FC_LOADING;\r\nvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nvport->fc_rscn_flush = 0;\r\nlpfc_get_vport_cfgparam(vport);\r\nshost->unique_id = instance;\r\nshost->max_id = LPFC_MAX_TARGET;\r\nshost->max_lun = vport->cfg_max_luns;\r\nshost->this_id = -1;\r\nshost->max_cmd_len = 16;\r\nshost->nr_hw_queues = phba->cfg_fcp_io_channel;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nshost->dma_boundary =\r\nphba->sli4_hba.pc_sli4_params.sge_supp_len-1;\r\nshost->sg_tablesize = phba->cfg_sg_seg_cnt;\r\n}\r\nshost->can_queue = phba->cfg_hba_queue_depth - 10;\r\nif (dev != &phba->pcidev->dev) {\r\nshost->transportt = lpfc_vport_transport_template;\r\nvport->port_type = LPFC_NPIV_PORT;\r\n} else {\r\nshost->transportt = lpfc_transport_template;\r\nvport->port_type = LPFC_PHYSICAL_PORT;\r\n}\r\nINIT_LIST_HEAD(&vport->fc_nodes);\r\nINIT_LIST_HEAD(&vport->rcv_buffer_list);\r\nspin_lock_init(&vport->work_port_lock);\r\ninit_timer(&vport->fc_disctmo);\r\nvport->fc_disctmo.function = lpfc_disc_timeout;\r\nvport->fc_disctmo.data = (unsigned long)vport;\r\ninit_timer(&vport->fc_fdmitmo);\r\nvport->fc_fdmitmo.function = lpfc_fdmi_tmo;\r\nvport->fc_fdmitmo.data = (unsigned long)vport;\r\ninit_timer(&vport->els_tmofunc);\r\nvport->els_tmofunc.function = lpfc_els_timeout;\r\nvport->els_tmofunc.data = (unsigned long)vport;\r\ninit_timer(&vport->delayed_disc_tmo);\r\nvport->delayed_disc_tmo.function = lpfc_delayed_disc_tmo;\r\nvport->delayed_disc_tmo.data = (unsigned long)vport;\r\nerror = scsi_add_host_with_dma(shost, dev, &phba->pcidev->dev);\r\nif (error)\r\ngoto out_put_shost;\r\nspin_lock_irq(&phba->hbalock);\r\nlist_add_tail(&vport->listentry, &phba->port_list);\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn vport;\r\nout_put_shost:\r\nscsi_host_put(shost);\r\nout:\r\nreturn NULL;\r\n}\r\nvoid\r\ndestroy_port(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nlpfc_debugfs_terminate(vport);\r\nfc_remove_host(shost);\r\nscsi_remove_host(shost);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_del_init(&vport->listentry);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_cleanup(vport);\r\nreturn;\r\n}\r\nint\r\nlpfc_get_instance(void)\r\n{\r\nint ret;\r\nret = idr_alloc(&lpfc_hba_index, NULL, 0, 0, GFP_KERNEL);\r\nreturn ret < 0 ? -1 : ret;\r\n}\r\nint lpfc_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint stat = 0;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->load_flag & FC_UNLOADING) {\r\nstat = 1;\r\ngoto finished;\r\n}\r\nif (time >= msecs_to_jiffies(30 * 1000)) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0461 Scanning longer than 30 "\r\n"seconds. Continuing initialization\n");\r\nstat = 1;\r\ngoto finished;\r\n}\r\nif (time >= msecs_to_jiffies(15 * 1000) &&\r\nphba->link_state <= LPFC_LINK_DOWN) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0465 Link down longer than 15 "\r\n"seconds. Continuing initialization\n");\r\nstat = 1;\r\ngoto finished;\r\n}\r\nif (vport->port_state != LPFC_VPORT_READY)\r\ngoto finished;\r\nif (vport->num_disc_nodes || vport->fc_prli_sent)\r\ngoto finished;\r\nif (vport->fc_map_cnt == 0 && time < msecs_to_jiffies(2 * 1000))\r\ngoto finished;\r\nif ((phba->sli.sli_flag & LPFC_SLI_MBOX_ACTIVE) != 0)\r\ngoto finished;\r\nstat = 1;\r\nfinished:\r\nspin_unlock_irq(shost->host_lock);\r\nreturn stat;\r\n}\r\nvoid lpfc_host_attrib_init(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nfc_host_node_name(shost) = wwn_to_u64(vport->fc_nodename.u.wwn);\r\nfc_host_port_name(shost) = wwn_to_u64(vport->fc_portname.u.wwn);\r\nfc_host_supported_classes(shost) = FC_COS_CLASS3;\r\nmemset(fc_host_supported_fc4s(shost), 0,\r\nsizeof(fc_host_supported_fc4s(shost)));\r\nfc_host_supported_fc4s(shost)[2] = 1;\r\nfc_host_supported_fc4s(shost)[7] = 1;\r\nlpfc_vport_symbolic_node_name(vport, fc_host_symbolic_name(shost),\r\nsizeof fc_host_symbolic_name(shost));\r\nfc_host_supported_speeds(shost) = 0;\r\nif (phba->lmt & LMT_16Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_16GBIT;\r\nif (phba->lmt & LMT_10Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_10GBIT;\r\nif (phba->lmt & LMT_8Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_8GBIT;\r\nif (phba->lmt & LMT_4Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_4GBIT;\r\nif (phba->lmt & LMT_2Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_2GBIT;\r\nif (phba->lmt & LMT_1Gb)\r\nfc_host_supported_speeds(shost) |= FC_PORTSPEED_1GBIT;\r\nfc_host_maxframe_size(shost) =\r\n(((uint32_t) vport->fc_sparam.cmn.bbRcvSizeMsb & 0x0F) << 8) |\r\n(uint32_t) vport->fc_sparam.cmn.bbRcvSizeLsb;\r\nfc_host_dev_loss_tmo(shost) = vport->cfg_devloss_tmo;\r\nmemset(fc_host_active_fc4s(shost), 0,\r\nsizeof(fc_host_active_fc4s(shost)));\r\nfc_host_active_fc4s(shost)[2] = 1;\r\nfc_host_active_fc4s(shost)[7] = 1;\r\nfc_host_max_npiv_vports(shost) = phba->max_vpi;\r\nspin_lock_irq(shost->host_lock);\r\nvport->load_flag &= ~FC_LOADING;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic void\r\nlpfc_stop_port_s3(struct lpfc_hba *phba)\r\n{\r\nwritel(0, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\nwritel(0xffffffff, phba->HAregaddr);\r\nreadl(phba->HAregaddr);\r\nlpfc_stop_hba_timers(phba);\r\nphba->pport->work_port_events = 0;\r\n}\r\nstatic void\r\nlpfc_stop_port_s4(struct lpfc_hba *phba)\r\n{\r\nlpfc_stop_hba_timers(phba);\r\nphba->pport->work_port_events = 0;\r\nphba->sli4_hba.intr_enable = 0;\r\n}\r\nvoid\r\nlpfc_stop_port(struct lpfc_hba *phba)\r\n{\r\nphba->lpfc_stop_port(phba);\r\n}\r\nvoid\r\nlpfc_fcf_redisc_wait_start_timer(struct lpfc_hba *phba)\r\n{\r\nunsigned long fcf_redisc_wait_tmo =\r\n(jiffies + msecs_to_jiffies(LPFC_FCF_REDISCOVER_WAIT_TMO));\r\nmod_timer(&phba->fcf.redisc_wait, fcf_redisc_wait_tmo);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~(FCF_AVAILABLE | FCF_SCAN_DONE);\r\nphba->fcf.fcf_flag |= FCF_REDISC_PEND;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nstatic void\r\nlpfc_sli4_fcf_redisc_wait_tmo(unsigned long ptr)\r\n{\r\nstruct lpfc_hba *phba = (struct lpfc_hba *)ptr;\r\nspin_lock_irq(&phba->hbalock);\r\nif (!(phba->fcf.fcf_flag & FCF_REDISC_PEND)) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\n}\r\nphba->fcf.fcf_flag &= ~FCF_REDISC_PEND;\r\nphba->fcf.fcf_flag |= FCF_REDISC_EVT;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\r\n"2776 FCF rediscover quiescent timer expired\n");\r\nlpfc_worker_wake_up(phba);\r\n}\r\nstatic uint16_t\r\nlpfc_sli4_parse_latt_fault(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_link *acqe_link)\r\n{\r\nuint16_t latt_fault;\r\nswitch (bf_get(lpfc_acqe_link_fault, acqe_link)) {\r\ncase LPFC_ASYNC_LINK_FAULT_NONE:\r\ncase LPFC_ASYNC_LINK_FAULT_LOCAL:\r\ncase LPFC_ASYNC_LINK_FAULT_REMOTE:\r\nlatt_fault = 0;\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0398 Invalid link fault code: x%x\n",\r\nbf_get(lpfc_acqe_link_fault, acqe_link));\r\nlatt_fault = MBXERR_ERROR;\r\nbreak;\r\n}\r\nreturn latt_fault;\r\n}\r\nstatic uint8_t\r\nlpfc_sli4_parse_latt_type(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_link *acqe_link)\r\n{\r\nuint8_t att_type;\r\nswitch (bf_get(lpfc_acqe_link_status, acqe_link)) {\r\ncase LPFC_ASYNC_LINK_STATUS_DOWN:\r\ncase LPFC_ASYNC_LINK_STATUS_LOGICAL_DOWN:\r\natt_type = LPFC_ATT_LINK_DOWN;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_STATUS_UP:\r\natt_type = LPFC_ATT_RESERVED;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_STATUS_LOGICAL_UP:\r\natt_type = LPFC_ATT_LINK_UP;\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0399 Invalid link attention type: x%x\n",\r\nbf_get(lpfc_acqe_link_status, acqe_link));\r\natt_type = LPFC_ATT_RESERVED;\r\nbreak;\r\n}\r\nreturn att_type;\r\n}\r\nstatic uint8_t\r\nlpfc_sli4_parse_latt_link_speed(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_link *acqe_link)\r\n{\r\nuint8_t link_speed;\r\nswitch (bf_get(lpfc_acqe_link_speed, acqe_link)) {\r\ncase LPFC_ASYNC_LINK_SPEED_ZERO:\r\ncase LPFC_ASYNC_LINK_SPEED_10MBPS:\r\ncase LPFC_ASYNC_LINK_SPEED_100MBPS:\r\nlink_speed = LPFC_LINK_SPEED_UNKNOWN;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_1GBPS:\r\nlink_speed = LPFC_LINK_SPEED_1GHZ;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_10GBPS:\r\nlink_speed = LPFC_LINK_SPEED_10GHZ;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_20GBPS:\r\ncase LPFC_ASYNC_LINK_SPEED_25GBPS:\r\ncase LPFC_ASYNC_LINK_SPEED_40GBPS:\r\nlink_speed = LPFC_LINK_SPEED_UNKNOWN;\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0483 Invalid link-attention link speed: x%x\n",\r\nbf_get(lpfc_acqe_link_speed, acqe_link));\r\nlink_speed = LPFC_LINK_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\nreturn link_speed;\r\n}\r\nuint32_t\r\nlpfc_sli_port_speed_get(struct lpfc_hba *phba)\r\n{\r\nuint32_t link_speed;\r\nif (!lpfc_is_link_up(phba))\r\nreturn 0;\r\nswitch (phba->fc_linkspeed) {\r\ncase LPFC_LINK_SPEED_1GHZ:\r\nlink_speed = 1000;\r\nbreak;\r\ncase LPFC_LINK_SPEED_2GHZ:\r\nlink_speed = 2000;\r\nbreak;\r\ncase LPFC_LINK_SPEED_4GHZ:\r\nlink_speed = 4000;\r\nbreak;\r\ncase LPFC_LINK_SPEED_8GHZ:\r\nlink_speed = 8000;\r\nbreak;\r\ncase LPFC_LINK_SPEED_10GHZ:\r\nlink_speed = 10000;\r\nbreak;\r\ncase LPFC_LINK_SPEED_16GHZ:\r\nlink_speed = 16000;\r\nbreak;\r\ndefault:\r\nlink_speed = 0;\r\n}\r\nreturn link_speed;\r\n}\r\nstatic uint32_t\r\nlpfc_sli4_port_speed_parse(struct lpfc_hba *phba, uint32_t evt_code,\r\nuint8_t speed_code)\r\n{\r\nuint32_t port_speed;\r\nswitch (evt_code) {\r\ncase LPFC_TRAILER_CODE_LINK:\r\nswitch (speed_code) {\r\ncase LPFC_ASYNC_LINK_SPEED_ZERO:\r\nport_speed = 0;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_10MBPS:\r\nport_speed = 10;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_100MBPS:\r\nport_speed = 100;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_1GBPS:\r\nport_speed = 1000;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_10GBPS:\r\nport_speed = 10000;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_20GBPS:\r\nport_speed = 20000;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_25GBPS:\r\nport_speed = 25000;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_40GBPS:\r\nport_speed = 40000;\r\nbreak;\r\ndefault:\r\nport_speed = 0;\r\n}\r\nbreak;\r\ncase LPFC_TRAILER_CODE_FC:\r\nswitch (speed_code) {\r\ncase LPFC_FC_LA_SPEED_UNKNOWN:\r\nport_speed = 0;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_1G:\r\nport_speed = 1000;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_2G:\r\nport_speed = 2000;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_4G:\r\nport_speed = 4000;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_8G:\r\nport_speed = 8000;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_10G:\r\nport_speed = 10000;\r\nbreak;\r\ncase LPFC_FC_LA_SPEED_16G:\r\nport_speed = 16000;\r\nbreak;\r\ndefault:\r\nport_speed = 0;\r\n}\r\nbreak;\r\ndefault:\r\nport_speed = 0;\r\n}\r\nreturn port_speed;\r\n}\r\nstatic void\r\nlpfc_sli4_async_link_evt(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_link *acqe_link)\r\n{\r\nstruct lpfc_dmabuf *mp;\r\nLPFC_MBOXQ_t *pmb;\r\nMAILBOX_t *mb;\r\nstruct lpfc_mbx_read_top *la;\r\nuint8_t att_type;\r\nint rc;\r\natt_type = lpfc_sli4_parse_latt_type(phba, acqe_link);\r\nif (att_type != LPFC_ATT_LINK_DOWN && att_type != LPFC_ATT_LINK_UP)\r\nreturn;\r\nphba->fcoe_eventtag = acqe_link->event_tag;\r\npmb = (LPFC_MBOXQ_t *)mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"0395 The mboxq allocation failed\n");\r\nreturn;\r\n}\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"0396 The lpfc_dmabuf allocation failed\n");\r\ngoto out_free_pmb;\r\n}\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp->virt) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"0397 The mbuf allocation failed\n");\r\ngoto out_free_dmabuf;\r\n}\r\nlpfc_els_flush_all_cmd(phba);\r\nphba->sli.ring[LPFC_ELS_RING].flag |= LPFC_STOP_IOCB_EVENT;\r\nphba->sli.slistat.link_event++;\r\nlpfc_read_topology(phba, pmb, mp);\r\npmb->mbox_cmpl = lpfc_mbx_cmpl_read_topology;\r\npmb->vport = phba->pport;\r\nphba->sli4_hba.link_state.speed =\r\nlpfc_sli4_port_speed_parse(phba, LPFC_TRAILER_CODE_LINK,\r\nbf_get(lpfc_acqe_link_speed, acqe_link));\r\nphba->sli4_hba.link_state.duplex =\r\nbf_get(lpfc_acqe_link_duplex, acqe_link);\r\nphba->sli4_hba.link_state.status =\r\nbf_get(lpfc_acqe_link_status, acqe_link);\r\nphba->sli4_hba.link_state.type =\r\nbf_get(lpfc_acqe_link_type, acqe_link);\r\nphba->sli4_hba.link_state.number =\r\nbf_get(lpfc_acqe_link_number, acqe_link);\r\nphba->sli4_hba.link_state.fault =\r\nbf_get(lpfc_acqe_link_fault, acqe_link);\r\nphba->sli4_hba.link_state.logical_speed =\r\nbf_get(lpfc_acqe_logical_link_speed, acqe_link) * 10;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2900 Async FC/FCoE Link event - Speed:%dGBit "\r\n"duplex:x%x LA Type:x%x Port Type:%d Port Number:%d "\r\n"Logical speed:%dMbps Fault:%d\n",\r\nphba->sli4_hba.link_state.speed,\r\nphba->sli4_hba.link_state.topology,\r\nphba->sli4_hba.link_state.status,\r\nphba->sli4_hba.link_state.type,\r\nphba->sli4_hba.link_state.number,\r\nphba->sli4_hba.link_state.logical_speed,\r\nphba->sli4_hba.link_state.fault);\r\nif (!(phba->hba_flag & HBA_FCOE_MODE)) {\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED)\r\ngoto out_free_dmabuf;\r\nreturn;\r\n}\r\nmb = &pmb->u.mb;\r\nmb->mbxStatus = lpfc_sli4_parse_latt_fault(phba, acqe_link);\r\nla = (struct lpfc_mbx_read_top *) &pmb->u.mb.un.varReadTop;\r\nla->eventTag = acqe_link->event_tag;\r\nbf_set(lpfc_mbx_read_top_att_type, la, att_type);\r\nbf_set(lpfc_mbx_read_top_link_spd, la,\r\nlpfc_sli4_parse_latt_link_speed(phba, acqe_link));\r\nbf_set(lpfc_mbx_read_top_topology, la, LPFC_TOPOLOGY_PT_PT);\r\nbf_set(lpfc_mbx_read_top_alpa_granted, la, 0);\r\nbf_set(lpfc_mbx_read_top_il, la, 0);\r\nbf_set(lpfc_mbx_read_top_pb, la, 0);\r\nbf_set(lpfc_mbx_read_top_fa, la, 0);\r\nbf_set(lpfc_mbx_read_top_mm, la, 0);\r\nlpfc_mbx_cmpl_read_topology(phba, pmb);\r\nreturn;\r\nout_free_dmabuf:\r\nkfree(mp);\r\nout_free_pmb:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\n}\r\nstatic void\r\nlpfc_sli4_async_fc_evt(struct lpfc_hba *phba, struct lpfc_acqe_fc_la *acqe_fc)\r\n{\r\nstruct lpfc_dmabuf *mp;\r\nLPFC_MBOXQ_t *pmb;\r\nint rc;\r\nif (bf_get(lpfc_trailer_type, acqe_fc) !=\r\nLPFC_FC_LA_EVENT_TYPE_FC_LINK) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2895 Non FC link Event detected.(%d)\n",\r\nbf_get(lpfc_trailer_type, acqe_fc));\r\nreturn;\r\n}\r\nphba->sli4_hba.link_state.speed =\r\nlpfc_sli4_port_speed_parse(phba, LPFC_TRAILER_CODE_FC,\r\nbf_get(lpfc_acqe_fc_la_speed, acqe_fc));\r\nphba->sli4_hba.link_state.duplex = LPFC_ASYNC_LINK_DUPLEX_FULL;\r\nphba->sli4_hba.link_state.topology =\r\nbf_get(lpfc_acqe_fc_la_topology, acqe_fc);\r\nphba->sli4_hba.link_state.status =\r\nbf_get(lpfc_acqe_fc_la_att_type, acqe_fc);\r\nphba->sli4_hba.link_state.type =\r\nbf_get(lpfc_acqe_fc_la_port_type, acqe_fc);\r\nphba->sli4_hba.link_state.number =\r\nbf_get(lpfc_acqe_fc_la_port_number, acqe_fc);\r\nphba->sli4_hba.link_state.fault =\r\nbf_get(lpfc_acqe_link_fault, acqe_fc);\r\nphba->sli4_hba.link_state.logical_speed =\r\nbf_get(lpfc_acqe_fc_la_llink_spd, acqe_fc) * 10;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2896 Async FC event - Speed:%dGBaud Topology:x%x "\r\n"LA Type:x%x Port Type:%d Port Number:%d Logical speed:"\r\n"%dMbps Fault:%d\n",\r\nphba->sli4_hba.link_state.speed,\r\nphba->sli4_hba.link_state.topology,\r\nphba->sli4_hba.link_state.status,\r\nphba->sli4_hba.link_state.type,\r\nphba->sli4_hba.link_state.number,\r\nphba->sli4_hba.link_state.logical_speed,\r\nphba->sli4_hba.link_state.fault);\r\npmb = (LPFC_MBOXQ_t *)mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2897 The mboxq allocation failed\n");\r\nreturn;\r\n}\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2898 The lpfc_dmabuf allocation failed\n");\r\ngoto out_free_pmb;\r\n}\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp->virt) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2899 The mbuf allocation failed\n");\r\ngoto out_free_dmabuf;\r\n}\r\nlpfc_els_flush_all_cmd(phba);\r\nphba->sli.ring[LPFC_ELS_RING].flag |= LPFC_STOP_IOCB_EVENT;\r\nphba->sli.slistat.link_event++;\r\nlpfc_read_topology(phba, pmb, mp);\r\npmb->mbox_cmpl = lpfc_mbx_cmpl_read_topology;\r\npmb->vport = phba->pport;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED)\r\ngoto out_free_dmabuf;\r\nreturn;\r\nout_free_dmabuf:\r\nkfree(mp);\r\nout_free_pmb:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\n}\r\nstatic void\r\nlpfc_sli4_async_sli_evt(struct lpfc_hba *phba, struct lpfc_acqe_sli *acqe_sli)\r\n{\r\nchar port_name;\r\nchar message[128];\r\nuint8_t status;\r\nuint8_t evt_type;\r\nstruct temp_event temp_event_data;\r\nstruct lpfc_acqe_misconfigured_event *misconfigured;\r\nstruct Scsi_Host *shost;\r\nevt_type = bf_get(lpfc_trailer_type, acqe_sli);\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2901 Async SLI event - Event Data1:x%08x Event Data2:"\r\n"x%08x SLI Event Type:%d\n",\r\nacqe_sli->event_data1, acqe_sli->event_data2,\r\nevt_type);\r\nreturn;\r\n}\r\nport_name = phba->Port[0];\r\nif (port_name == 0x00)\r\nport_name = '?';\r\nswitch (evt_type) {\r\ncase LPFC_SLI_EVENT_TYPE_OVER_TEMP:\r\ntemp_event_data.event_type = FC_REG_TEMPERATURE_EVENT;\r\ntemp_event_data.event_code = LPFC_THRESHOLD_TEMP;\r\ntemp_event_data.data = (uint32_t)acqe_sli->event_data1;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_SLI,\r\n"3190 Over Temperature:%d Celsius- Port Name %c\n",\r\nacqe_sli->event_data1, port_name);\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(temp_event_data),\r\n(char *)&temp_event_data,\r\nSCSI_NL_VID_TYPE_PCI\r\n| PCI_VENDOR_ID_EMULEX);\r\nbreak;\r\ncase LPFC_SLI_EVENT_TYPE_NORM_TEMP:\r\ntemp_event_data.event_type = FC_REG_TEMPERATURE_EVENT;\r\ntemp_event_data.event_code = LPFC_NORMAL_TEMP;\r\ntemp_event_data.data = (uint32_t)acqe_sli->event_data1;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3191 Normal Temperature:%d Celsius - Port Name %c\n",\r\nacqe_sli->event_data1, port_name);\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(temp_event_data),\r\n(char *)&temp_event_data,\r\nSCSI_NL_VID_TYPE_PCI\r\n| PCI_VENDOR_ID_EMULEX);\r\nbreak;\r\ncase LPFC_SLI_EVENT_TYPE_MISCONFIGURED:\r\nmisconfigured = (struct lpfc_acqe_misconfigured_event *)\r\n&acqe_sli->event_data1;\r\nswitch (phba->sli4_hba.lnk_info.lnk_no) {\r\ncase LPFC_LINK_NUMBER_0:\r\nstatus = bf_get(lpfc_sli_misconfigured_port0,\r\n&misconfigured->theEvent);\r\nbreak;\r\ncase LPFC_LINK_NUMBER_1:\r\nstatus = bf_get(lpfc_sli_misconfigured_port1,\r\n&misconfigured->theEvent);\r\nbreak;\r\ncase LPFC_LINK_NUMBER_2:\r\nstatus = bf_get(lpfc_sli_misconfigured_port2,\r\n&misconfigured->theEvent);\r\nbreak;\r\ncase LPFC_LINK_NUMBER_3:\r\nstatus = bf_get(lpfc_sli_misconfigured_port3,\r\n&misconfigured->theEvent);\r\nbreak;\r\ndefault:\r\nstatus = ~LPFC_SLI_EVENT_STATUS_VALID;\r\nbreak;\r\n}\r\nswitch (status) {\r\ncase LPFC_SLI_EVENT_STATUS_VALID:\r\nreturn;\r\ncase LPFC_SLI_EVENT_STATUS_NOT_PRESENT:\r\nsprintf(message, "Optics faulted/incorrectly "\r\n"installed/not installed - Reseat optics, "\r\n"if issue not resolved, replace.");\r\nbreak;\r\ncase LPFC_SLI_EVENT_STATUS_WRONG_TYPE:\r\nsprintf(message,\r\n"Optics of two types installed - Remove one "\r\n"optic or install matching pair of optics.");\r\nbreak;\r\ncase LPFC_SLI_EVENT_STATUS_UNSUPPORTED:\r\nsprintf(message, "Incompatible optics - Replace with "\r\n"compatible optics for card to function.");\r\nbreak;\r\ndefault:\r\nsprintf(message, "Unknown event status x%02x", status);\r\nbreak;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"3176 Misconfigured Physical Port - "\r\n"Port Name %c %s\n", port_name, message);\r\nbreak;\r\ncase LPFC_SLI_EVENT_TYPE_REMOTE_DPORT:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3192 Remote DPort Test Initiated - "\r\n"Event Data1:x%08x Event Data2: x%08x\n",\r\nacqe_sli->event_data1, acqe_sli->event_data2);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3193 Async SLI event - Event Data1:x%08x Event Data2:"\r\n"x%08x SLI Event Type:%d\n",\r\nacqe_sli->event_data1, acqe_sli->event_data2,\r\nevt_type);\r\nbreak;\r\n}\r\n}\r\nstatic struct lpfc_nodelist *\r\nlpfc_sli4_perform_vport_cvl(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp;\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_hba *phba;\r\nif (!vport)\r\nreturn NULL;\r\nphba = vport->phba;\r\nif (!phba)\r\nreturn NULL;\r\nndlp = lpfc_findnode_did(vport, Fabric_DID);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\nreturn 0;\r\nlpfc_nlp_init(vport, ndlp, Fabric_DID);\r\nndlp->nlp_type |= NLP_FABRIC;\r\nlpfc_enqueue_node(vport, ndlp);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\nreturn 0;\r\n}\r\nif ((phba->pport->port_state < LPFC_FLOGI) &&\r\n(phba->pport->port_state != LPFC_VPORT_FAILED))\r\nreturn NULL;\r\nif ((vport != phba->pport) && (vport->port_state < LPFC_FDISC)\r\n&& (vport->port_state != LPFC_VPORT_FAILED))\r\nreturn NULL;\r\nshost = lpfc_shost_from_vport(vport);\r\nif (!shost)\r\nreturn NULL;\r\nlpfc_linkdown_port(vport);\r\nlpfc_cleanup_pending_mbox(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_CVL_RCVD;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp;\r\n}\r\nstatic void\r\nlpfc_sli4_perform_all_vport_cvl(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nint i;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++)\r\nlpfc_sli4_perform_vport_cvl(vports[i]);\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nstatic void\r\nlpfc_sli4_async_fip_evt(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_fip *acqe_fip)\r\n{\r\nuint8_t event_type = bf_get(lpfc_trailer_type, acqe_fip);\r\nint rc;\r\nstruct lpfc_vport *vport;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct Scsi_Host *shost;\r\nint active_vlink_present;\r\nstruct lpfc_vport **vports;\r\nint i;\r\nphba->fc_eventTag = acqe_fip->event_tag;\r\nphba->fcoe_eventtag = acqe_fip->event_tag;\r\nswitch (event_type) {\r\ncase LPFC_FIP_EVENT_TYPE_NEW_FCF:\r\ncase LPFC_FIP_EVENT_TYPE_FCF_PARAM_MOD:\r\nif (event_type == LPFC_FIP_EVENT_TYPE_NEW_FCF)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2546 New FCF event, evt_tag:x%x, "\r\n"index:x%x\n",\r\nacqe_fip->event_tag,\r\nacqe_fip->index);\r\nelse\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2788 FCF param modified event, "\r\n"evt_tag:x%x, index:x%x\n",\r\nacqe_fip->event_tag,\r\nacqe_fip->index);\r\nif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2779 Read FCF (x%x) for updating "\r\n"roundrobin FCF failover bmask\n",\r\nacqe_fip->index);\r\nrc = lpfc_sli4_read_fcf_rec(phba, acqe_fip->index);\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->hba_flag & FCF_TS_INPROG) {\r\nspin_unlock_irq(&phba->hbalock);\r\nbreak;\r\n}\r\nif (phba->fcf.fcf_flag & FCF_REDISC_EVT) {\r\nspin_unlock_irq(&phba->hbalock);\r\nbreak;\r\n}\r\nif (phba->fcf.fcf_flag & FCF_SCAN_DONE) {\r\nspin_unlock_irq(&phba->hbalock);\r\nbreak;\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\r\n"2770 Start FCF table scan per async FCF "\r\n"event, evt_tag:x%x, index:x%x\n",\r\nacqe_fip->event_tag, acqe_fip->index);\r\nrc = lpfc_sli4_fcf_scan_read_fcf_rec(phba,\r\nLPFC_FCOE_FCF_GET_FIRST);\r\nif (rc)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP | LOG_DISCOVERY,\r\n"2547 Issue FCF scan read FCF mailbox "\r\n"command failed (x%x)\n", rc);\r\nbreak;\r\ncase LPFC_FIP_EVENT_TYPE_FCF_TABLE_FULL:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2548 FCF Table full count 0x%x tag 0x%x\n",\r\nbf_get(lpfc_acqe_fip_fcf_count, acqe_fip),\r\nacqe_fip->event_tag);\r\nbreak;\r\ncase LPFC_FIP_EVENT_TYPE_FCF_DEAD:\r\nphba->fcoe_cvl_eventtag = acqe_fip->event_tag;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP | LOG_DISCOVERY,\r\n"2549 FCF (x%x) disconnected from network, "\r\n"tag:x%x\n", acqe_fip->index, acqe_fip->event_tag);\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli4_fcf_rr_index_clear(phba, acqe_fip->index);\r\nbreak;\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nif (phba->fcf.current_rec.fcf_indx != acqe_fip->index)\r\nbreak;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag |= FCF_DEAD_DISC;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\r\n"2771 Start FCF fast failover process due to "\r\n"FCF DEAD event: evt_tag:x%x, fcf_index:x%x "\r\n"\n", acqe_fip->event_tag, acqe_fip->index);\r\nrc = lpfc_sli4_redisc_fcf_table(phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2772 Issue FCF rediscover mabilbox "\r\n"command failed, fail through to FCF "\r\n"dead event\n");\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~FCF_DEAD_DISC;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli4_fcf_dead_failthrough(phba);\r\n} else {\r\nlpfc_sli4_clear_fcf_rr_bmask(phba);\r\nlpfc_sli4_perform_all_vport_cvl(phba);\r\n}\r\nbreak;\r\ncase LPFC_FIP_EVENT_TYPE_CVL:\r\nphba->fcoe_cvl_eventtag = acqe_fip->event_tag;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP | LOG_DISCOVERY,\r\n"2718 Clear Virtual Link Received for VPI 0x%x"\r\n" tag 0x%x\n", acqe_fip->index, acqe_fip->event_tag);\r\nvport = lpfc_find_vport_by_vpid(phba,\r\nacqe_fip->index);\r\nndlp = lpfc_sli4_perform_vport_cvl(vport);\r\nif (!ndlp)\r\nbreak;\r\nactive_vlink_present = 0;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports) {\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL;\r\ni++) {\r\nif ((!(vports[i]->fc_flag &\r\nFC_VPORT_CVL_RCVD)) &&\r\n(vports[i]->port_state > LPFC_FDISC)) {\r\nactive_vlink_present = 1;\r\nbreak;\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nif (!(vport->load_flag & FC_UNLOADING) &&\r\nactive_vlink_present) {\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(1000));\r\nshost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_FDISC;\r\nvport->port_state = LPFC_FDISC;\r\n} else {\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\r\nspin_unlock_irq(&phba->hbalock);\r\nbreak;\r\n}\r\nphba->fcf.fcf_flag |= FCF_ACVL_DISC;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2773 Start FCF failover per CVL, "\r\n"evt_tag:x%x\n", acqe_fip->event_tag);\r\nrc = lpfc_sli4_redisc_fcf_table(phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP |\r\nLOG_DISCOVERY,\r\n"2774 Issue FCF rediscover "\r\n"mabilbox command failed, "\r\n"through to CVL event\n");\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~FCF_ACVL_DISC;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_retry_pport_discovery(phba);\r\n} else\r\nlpfc_sli4_clear_fcf_rr_bmask(phba);\r\n}\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"0288 Unknown FCoE event type 0x%x event tag "\r\n"0x%x\n", event_type, acqe_fip->event_tag);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlpfc_sli4_async_dcbx_evt(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_dcbx *acqe_dcbx)\r\n{\r\nphba->fc_eventTag = acqe_dcbx->event_tag;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"0290 The SLI4 DCBX asynchronous event is not "\r\n"handled yet\n");\r\n}\r\nstatic void\r\nlpfc_sli4_async_grp5_evt(struct lpfc_hba *phba,\r\nstruct lpfc_acqe_grp5 *acqe_grp5)\r\n{\r\nuint16_t prev_ll_spd;\r\nphba->fc_eventTag = acqe_grp5->event_tag;\r\nphba->fcoe_eventtag = acqe_grp5->event_tag;\r\nprev_ll_spd = phba->sli4_hba.link_state.logical_speed;\r\nphba->sli4_hba.link_state.logical_speed =\r\n(bf_get(lpfc_acqe_grp5_llink_spd, acqe_grp5)) * 10;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2789 GRP5 Async Event: Updating logical link speed "\r\n"from %dMbps to %dMbps\n", prev_ll_spd,\r\nphba->sli4_hba.link_state.logical_speed);\r\n}\r\nvoid lpfc_sli4_async_event_proc(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_cq_event *cq_event;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~ASYNC_EVENT;\r\nspin_unlock_irq(&phba->hbalock);\r\nwhile (!list_empty(&phba->sli4_hba.sp_asynce_work_queue)) {\r\nspin_lock_irq(&phba->hbalock);\r\nlist_remove_head(&phba->sli4_hba.sp_asynce_work_queue,\r\ncq_event, struct lpfc_cq_event, list);\r\nspin_unlock_irq(&phba->hbalock);\r\nswitch (bf_get(lpfc_trailer_code, &cq_event->cqe.mcqe_cmpl)) {\r\ncase LPFC_TRAILER_CODE_LINK:\r\nlpfc_sli4_async_link_evt(phba,\r\n&cq_event->cqe.acqe_link);\r\nbreak;\r\ncase LPFC_TRAILER_CODE_FCOE:\r\nlpfc_sli4_async_fip_evt(phba, &cq_event->cqe.acqe_fip);\r\nbreak;\r\ncase LPFC_TRAILER_CODE_DCBX:\r\nlpfc_sli4_async_dcbx_evt(phba,\r\n&cq_event->cqe.acqe_dcbx);\r\nbreak;\r\ncase LPFC_TRAILER_CODE_GRP5:\r\nlpfc_sli4_async_grp5_evt(phba,\r\n&cq_event->cqe.acqe_grp5);\r\nbreak;\r\ncase LPFC_TRAILER_CODE_FC:\r\nlpfc_sli4_async_fc_evt(phba, &cq_event->cqe.acqe_fc);\r\nbreak;\r\ncase LPFC_TRAILER_CODE_SLI:\r\nlpfc_sli4_async_sli_evt(phba, &cq_event->cqe.acqe_sli);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"1804 Invalid asynchrous event code: "\r\n"x%x\n", bf_get(lpfc_trailer_code,\r\n&cq_event->cqe.mcqe_cmpl));\r\nbreak;\r\n}\r\nlpfc_sli4_cq_event_release(phba, cq_event);\r\n}\r\n}\r\nvoid lpfc_sli4_fcf_redisc_event_proc(struct lpfc_hba *phba)\r\n{\r\nint rc;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~FCF_REDISC_EVT;\r\nphba->fcf.failover_rec.flag = 0;\r\nphba->fcf.fcf_flag |= FCF_REDISC_FOV;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\r\n"2777 Start post-quiescent FCF table scan\n");\r\nrc = lpfc_sli4_fcf_scan_read_fcf_rec(phba, LPFC_FCOE_FCF_GET_FIRST);\r\nif (rc)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FIP | LOG_DISCOVERY,\r\n"2747 Issue FCF scan read FCF mailbox "\r\n"command failed 0x%x\n", rc);\r\n}\r\nint\r\nlpfc_api_table_setup(struct lpfc_hba *phba, uint8_t dev_grp)\r\n{\r\nint rc;\r\nphba->pci_dev_grp = dev_grp;\r\nif (dev_grp == LPFC_PCI_DEV_OC)\r\nphba->sli_rev = LPFC_SLI_REV4;\r\nrc = lpfc_init_api_table_setup(phba, dev_grp);\r\nif (rc)\r\nreturn -ENODEV;\r\nrc = lpfc_scsi_api_table_setup(phba, dev_grp);\r\nif (rc)\r\nreturn -ENODEV;\r\nrc = lpfc_sli_api_table_setup(phba, dev_grp);\r\nif (rc)\r\nreturn -ENODEV;\r\nrc = lpfc_mbox_api_table_setup(phba, dev_grp);\r\nif (rc)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void lpfc_log_intr_mode(struct lpfc_hba *phba, uint32_t intr_mode)\r\n{\r\nswitch (intr_mode) {\r\ncase 0:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0470 Enable INTx interrupt mode.\n");\r\nbreak;\r\ncase 1:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0481 Enabled MSI interrupt mode.\n");\r\nbreak;\r\ncase 2:\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0480 Enabled MSI-X interrupt mode.\n");\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0482 Illegal interrupt mode.\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_enable_pci_dev(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev;\r\nint bars = 0;\r\nif (!phba->pcidev)\r\ngoto out_error;\r\nelse\r\npdev = phba->pcidev;\r\nbars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nif (pci_enable_device_mem(pdev))\r\ngoto out_error;\r\nif (pci_request_selected_regions(pdev, bars, LPFC_DRIVER_NAME))\r\ngoto out_disable_device;\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\npci_save_state(pdev);\r\nif (pci_is_pcie(pdev))\r\npdev->needs_freset = 1;\r\nreturn 0;\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout_error:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1401 Failed to enable pci device, bars:x%x\n", bars);\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nlpfc_disable_pci_dev(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev;\r\nint bars;\r\nif (!phba->pcidev)\r\nreturn;\r\nelse\r\npdev = phba->pcidev;\r\nbars = pci_select_bars(pdev, IORESOURCE_MEM);\r\npci_release_selected_regions(pdev, bars);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_reset_hba(struct lpfc_hba *phba)\r\n{\r\nif (!phba->cfg_enable_hba_reset) {\r\nphba->link_state = LPFC_HBA_ERROR;\r\nreturn;\r\n}\r\nif (phba->sli.sli_flag & LPFC_SLI_ACTIVE)\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nelse\r\nlpfc_offline_prep(phba, LPFC_MBX_NO_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_online(phba);\r\nlpfc_unblock_mgmt_io(phba);\r\n}\r\nuint16_t\r\nlpfc_sli_sriov_nr_virtfn_get(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev = phba->pcidev;\r\nuint16_t nr_virtfn;\r\nint pos;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\r\nif (pos == 0)\r\nreturn 0;\r\npci_read_config_word(pdev, pos + PCI_SRIOV_TOTAL_VF, &nr_virtfn);\r\nreturn nr_virtfn;\r\n}\r\nint\r\nlpfc_sli_probe_sriov_nr_virtfn(struct lpfc_hba *phba, int nr_vfn)\r\n{\r\nstruct pci_dev *pdev = phba->pcidev;\r\nuint16_t max_nr_vfn;\r\nint rc;\r\nmax_nr_vfn = lpfc_sli_sriov_nr_virtfn_get(phba);\r\nif (nr_vfn > max_nr_vfn) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3057 Requested vfs (%d) greater than "\r\n"supported vfs (%d)", nr_vfn, max_nr_vfn);\r\nreturn -EINVAL;\r\n}\r\nrc = pci_enable_sriov(pdev, nr_vfn);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"2806 Failed to enable sriov on this device "\r\n"with vfn number nr_vf:%d, rc:%d\n",\r\nnr_vfn, rc);\r\n} else\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"2807 Successful enable sriov on this device "\r\n"with vfn number nr_vf:%d\n", nr_vfn);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli_driver_resource_setup(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli;\r\nint rc;\r\ninit_timer(&phba->hb_tmofunc);\r\nphba->hb_tmofunc.function = lpfc_hb_timeout;\r\nphba->hb_tmofunc.data = (unsigned long)phba;\r\npsli = &phba->sli;\r\ninit_timer(&psli->mbox_tmo);\r\npsli->mbox_tmo.function = lpfc_mbox_timeout;\r\npsli->mbox_tmo.data = (unsigned long) phba;\r\ninit_timer(&phba->fcp_poll_timer);\r\nphba->fcp_poll_timer.function = lpfc_poll_timeout;\r\nphba->fcp_poll_timer.data = (unsigned long) phba;\r\ninit_timer(&phba->fabric_block_timer);\r\nphba->fabric_block_timer.function = lpfc_fabric_block_timeout;\r\nphba->fabric_block_timer.data = (unsigned long) phba;\r\ninit_timer(&phba->eratt_poll);\r\nphba->eratt_poll.function = lpfc_poll_eratt;\r\nphba->eratt_poll.data = (unsigned long) phba;\r\nphba->work_ha_mask = (HA_ERATT | HA_MBATT | HA_LATT);\r\nphba->work_ha_mask |= (HA_RXMASK << (LPFC_ELS_RING * 4));\r\nlpfc_get_cfgparam(phba);\r\nif (phba->pcidev->device == PCI_DEVICE_ID_HORNET) {\r\nphba->menlo_flag |= HBA_MENLO_SUPPORT;\r\nif (phba->cfg_sg_seg_cnt < LPFC_DEFAULT_MENLO_SG_SEG_CNT)\r\nphba->cfg_sg_seg_cnt = LPFC_DEFAULT_MENLO_SG_SEG_CNT;\r\n}\r\nif (!phba->sli.ring)\r\nphba->sli.ring = (struct lpfc_sli_ring *)\r\nkzalloc(LPFC_SLI3_MAX_RING *\r\nsizeof(struct lpfc_sli_ring), GFP_KERNEL);\r\nif (!phba->sli.ring)\r\nreturn -ENOMEM;\r\nlpfc_vport_template.sg_tablesize = phba->cfg_sg_seg_cnt;\r\nlpfc_template.sg_tablesize = phba->cfg_sg_seg_cnt;\r\nif (phba->cfg_enable_bg) {\r\nphba->cfg_sg_dma_buf_size = sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp) +\r\n(LPFC_MAX_SG_SEG_CNT * sizeof(struct ulp_bde64));\r\nif (phba->cfg_sg_seg_cnt > LPFC_MAX_SG_SEG_CNT_DIF)\r\nphba->cfg_sg_seg_cnt = LPFC_MAX_SG_SEG_CNT_DIF;\r\nphba->cfg_total_seg_cnt = LPFC_MAX_SG_SEG_CNT;\r\n} else {\r\nphba->cfg_sg_dma_buf_size = sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp) +\r\n((phba->cfg_sg_seg_cnt + 2) * sizeof(struct ulp_bde64));\r\nphba->cfg_total_seg_cnt = phba->cfg_sg_seg_cnt + 2;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT | LOG_FCP,\r\n"9088 sg_tablesize:%d dmabuf_size:%d total_bde:%d\n",\r\nphba->cfg_sg_seg_cnt, phba->cfg_sg_dma_buf_size,\r\nphba->cfg_total_seg_cnt);\r\nphba->max_vpi = LPFC_MAX_VPI;\r\nphba->max_vports = 0;\r\nlpfc_sli_setup(phba);\r\nlpfc_sli_queue_setup(phba);\r\nif (lpfc_mem_alloc(phba, BPL_ALIGN_SZ))\r\nreturn -ENOMEM;\r\nif (phba->cfg_sriov_nr_virtfn > 0) {\r\nrc = lpfc_sli_probe_sriov_nr_virtfn(phba,\r\nphba->cfg_sriov_nr_virtfn);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"2808 Requested number of SR-IOV "\r\n"virtual functions (%d) is not "\r\n"supported\n",\r\nphba->cfg_sriov_nr_virtfn);\r\nphba->cfg_sriov_nr_virtfn = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli_driver_resource_unset(struct lpfc_hba *phba)\r\n{\r\nlpfc_mem_free_all(phba);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli4_driver_resource_setup(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vector_map_info *cpup;\r\nstruct lpfc_sli *psli;\r\nLPFC_MBOXQ_t *mboxq;\r\nint rc, i, hbq_count, max_buf_size;\r\nuint8_t pn_page[LPFC_MAX_SUPPORTED_PAGES] = {0};\r\nstruct lpfc_mqe *mqe;\r\nint longs;\r\nint fof_vectors = 0;\r\nlpfc_get_cfgparam(phba);\r\nrc = lpfc_sli4_post_status_check(phba);\r\nif (rc)\r\nreturn -ENODEV;\r\ninit_timer(&phba->hb_tmofunc);\r\nphba->hb_tmofunc.function = lpfc_hb_timeout;\r\nphba->hb_tmofunc.data = (unsigned long)phba;\r\ninit_timer(&phba->rrq_tmr);\r\nphba->rrq_tmr.function = lpfc_rrq_timeout;\r\nphba->rrq_tmr.data = (unsigned long)phba;\r\npsli = &phba->sli;\r\ninit_timer(&psli->mbox_tmo);\r\npsli->mbox_tmo.function = lpfc_mbox_timeout;\r\npsli->mbox_tmo.data = (unsigned long) phba;\r\ninit_timer(&phba->fabric_block_timer);\r\nphba->fabric_block_timer.function = lpfc_fabric_block_timeout;\r\nphba->fabric_block_timer.data = (unsigned long) phba;\r\ninit_timer(&phba->eratt_poll);\r\nphba->eratt_poll.function = lpfc_poll_eratt;\r\nphba->eratt_poll.data = (unsigned long) phba;\r\ninit_timer(&phba->fcf.redisc_wait);\r\nphba->fcf.redisc_wait.function = lpfc_sli4_fcf_redisc_wait_tmo;\r\nphba->fcf.redisc_wait.data = (unsigned long)phba;\r\nmemset((uint8_t *)&phba->mbox_ext_buf_ctx, 0,\r\nsizeof(struct lpfc_mbox_ext_buf_ctx));\r\nINIT_LIST_HEAD(&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\r\nphba->max_vpi = LPFC_MAX_VPI;\r\nphba->max_vports = 0;\r\nphba->valid_vlan = 0;\r\nphba->fc_map[0] = LPFC_FCOE_FCF_MAP0;\r\nphba->fc_map[1] = LPFC_FCOE_FCF_MAP1;\r\nphba->fc_map[2] = LPFC_FCOE_FCF_MAP2;\r\nif (!phba->sli.ring)\r\nphba->sli.ring = kzalloc(\r\n(LPFC_SLI3_MAX_RING + phba->cfg_fcp_io_channel) *\r\nsizeof(struct lpfc_sli_ring), GFP_KERNEL);\r\nif (!phba->sli.ring)\r\nreturn -ENOMEM;\r\nmax_buf_size = (2 * SLI4_PAGE_SIZE);\r\nif (phba->cfg_sg_seg_cnt > LPFC_MAX_SGL_SEG_CNT - 2)\r\nphba->cfg_sg_seg_cnt = LPFC_MAX_SGL_SEG_CNT - 2;\r\nif (phba->cfg_enable_bg) {\r\nphba->cfg_sg_dma_buf_size = sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp) + max_buf_size;\r\nphba->cfg_total_seg_cnt = LPFC_MAX_SGL_SEG_CNT;\r\nif (phba->cfg_sg_seg_cnt > LPFC_MAX_SG_SLI4_SEG_CNT_DIF)\r\nphba->cfg_sg_seg_cnt = LPFC_MAX_SG_SLI4_SEG_CNT_DIF;\r\n} else {\r\nphba->cfg_sg_dma_buf_size = sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp) +\r\n((phba->cfg_sg_seg_cnt + 2) * sizeof(struct sli4_sge));\r\nphba->cfg_total_seg_cnt = phba->cfg_sg_seg_cnt + 2;\r\n}\r\nlpfc_vport_template.sg_tablesize = phba->cfg_sg_seg_cnt;\r\nlpfc_template.sg_tablesize = phba->cfg_sg_seg_cnt;\r\nif (phba->cfg_sg_dma_buf_size <= LPFC_MIN_SG_SLI4_BUF_SZ)\r\nphba->cfg_sg_dma_buf_size = LPFC_MIN_SG_SLI4_BUF_SZ;\r\nelse\r\nphba->cfg_sg_dma_buf_size =\r\nSLI4_PAGE_ALIGN(phba->cfg_sg_dma_buf_size);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT | LOG_FCP,\r\n"9087 sg_tablesize:%d dmabuf_size:%d total_sge:%d\n",\r\nphba->cfg_sg_seg_cnt, phba->cfg_sg_dma_buf_size,\r\nphba->cfg_total_seg_cnt);\r\nhbq_count = lpfc_sli_hbq_count();\r\nfor (i = 0; i < hbq_count; ++i)\r\nINIT_LIST_HEAD(&phba->hbqs[i].hbq_buffer_list);\r\nINIT_LIST_HEAD(&phba->rb_pend_list);\r\nphba->hbqs[LPFC_ELS_HBQ].hbq_alloc_buffer = lpfc_sli4_rb_alloc;\r\nphba->hbqs[LPFC_ELS_HBQ].hbq_free_buffer = lpfc_sli4_rb_free;\r\nspin_lock_init(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_scsi_buf_list);\r\nspin_lock_init(&phba->sli4_hba.abts_sgl_list_lock);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_cqe_event_pool);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_queue_event);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_asynce_work_queue);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_els_xri_aborted_work_queue);\r\nINIT_LIST_HEAD(&phba->sli4_hba.sp_unsol_work_queue);\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_rpi_blk_list);\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_xri_blk_list);\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_vfi_blk_list);\r\nINIT_LIST_HEAD(&phba->lpfc_vpi_blk_list);\r\nlpfc_sli_setup(phba);\r\nlpfc_sli_queue_setup(phba);\r\nrc = lpfc_mem_alloc(phba, SGL_ALIGN_SZ);\r\nif (rc)\r\nreturn -ENOMEM;\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\r\nLPFC_SLI_INTF_IF_TYPE_2) {\r\nrc = lpfc_pci_function_reset(phba);\r\nif (unlikely(rc))\r\nreturn -ENODEV;\r\nphba->temp_sensor_support = 1;\r\n}\r\nrc = lpfc_create_bootstrap_mbox(phba);\r\nif (unlikely(rc))\r\ngoto out_free_mem;\r\nrc = lpfc_setup_endian_order(phba);\r\nif (unlikely(rc))\r\ngoto out_free_bsmbx;\r\nrc = lpfc_sli4_read_config(phba);\r\nif (unlikely(rc))\r\ngoto out_free_bsmbx;\r\nrc = lpfc_mem_alloc_active_rrq_pool_s4(phba);\r\nif (unlikely(rc))\r\ngoto out_free_bsmbx;\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\r\nLPFC_SLI_INTF_IF_TYPE_0) {\r\nrc = lpfc_pci_function_reset(phba);\r\nif (unlikely(rc))\r\ngoto out_free_bsmbx;\r\n}\r\nmboxq = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!mboxq) {\r\nrc = -ENOMEM;\r\ngoto out_free_bsmbx;\r\n}\r\nlpfc_supported_pages(mboxq);\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nif (!rc) {\r\nmqe = &mboxq->u.mqe;\r\nmemcpy(&pn_page[0], ((uint8_t *)&mqe->un.supp_pages.word3),\r\nLPFC_MAX_SUPPORTED_PAGES);\r\nfor (i = 0; i < LPFC_MAX_SUPPORTED_PAGES; i++) {\r\nswitch (pn_page[i]) {\r\ncase LPFC_SLI4_PARAMETERS:\r\nphba->sli4_hba.pc_sli4_params.supported = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (phba->sli4_hba.pc_sli4_params.supported)\r\nrc = lpfc_pc_sli4_params_get(phba, mboxq);\r\nif (rc) {\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nrc = -EIO;\r\ngoto out_free_bsmbx;\r\n}\r\n}\r\nrc = lpfc_get_sli4_parameters(phba, mboxq);\r\nif (rc) {\r\nif (phba->sli4_hba.extents_in_use &&\r\nphba->sli4_hba.rpi_hdrs_in_use) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2999 Unsupported SLI4 Parameters "\r\n"Extents and RPI headers enabled.\n");\r\ngoto out_free_bsmbx;\r\n}\r\n}\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nlpfc_sli4_oas_verify(phba);\r\nif (phba->cfg_fof)\r\nfof_vectors = 1;\r\nrc = lpfc_sli4_queue_verify(phba);\r\nif (rc)\r\ngoto out_free_bsmbx;\r\nrc = lpfc_sli4_cq_event_pool_create(phba);\r\nif (rc)\r\ngoto out_free_bsmbx;\r\nlpfc_init_sgl_list(phba);\r\nrc = lpfc_init_active_sgl_array(phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1430 Failed to initialize sgl list.\n");\r\ngoto out_destroy_cq_event_pool;\r\n}\r\nrc = lpfc_sli4_init_rpi_hdrs(phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1432 Failed to initialize rpi headers.\n");\r\ngoto out_free_active_sgl;\r\n}\r\nlongs = (LPFC_SLI4_FCF_TBL_INDX_MAX + BITS_PER_LONG - 1)/BITS_PER_LONG;\r\nphba->fcf.fcf_rr_bmask = kzalloc(longs * sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!phba->fcf.fcf_rr_bmask) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2759 Failed allocate memory for FCF round "\r\n"robin failover bmask\n");\r\nrc = -ENOMEM;\r\ngoto out_remove_rpi_hdrs;\r\n}\r\nphba->sli4_hba.fcp_eq_hdl =\r\nkzalloc((sizeof(struct lpfc_fcp_eq_hdl) *\r\n(fof_vectors + phba->cfg_fcp_io_channel)),\r\nGFP_KERNEL);\r\nif (!phba->sli4_hba.fcp_eq_hdl) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2572 Failed allocate memory for "\r\n"fast-path per-EQ handle array\n");\r\nrc = -ENOMEM;\r\ngoto out_free_fcf_rr_bmask;\r\n}\r\nphba->sli4_hba.msix_entries = kzalloc((sizeof(struct msix_entry) *\r\n(fof_vectors +\r\nphba->cfg_fcp_io_channel)), GFP_KERNEL);\r\nif (!phba->sli4_hba.msix_entries) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2573 Failed allocate memory for msi-x "\r\n"interrupt vector entries\n");\r\nrc = -ENOMEM;\r\ngoto out_free_fcp_eq_hdl;\r\n}\r\nphba->sli4_hba.cpu_map = kzalloc((sizeof(struct lpfc_vector_map_info) *\r\nphba->sli4_hba.num_present_cpu),\r\nGFP_KERNEL);\r\nif (!phba->sli4_hba.cpu_map) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3327 Failed allocate memory for msi-x "\r\n"interrupt vector mapping\n");\r\nrc = -ENOMEM;\r\ngoto out_free_msix;\r\n}\r\nif (lpfc_used_cpu == NULL) {\r\nlpfc_used_cpu = kzalloc((sizeof(uint16_t) * lpfc_present_cpu),\r\nGFP_KERNEL);\r\nif (!lpfc_used_cpu) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3335 Failed allocate memory for msi-x "\r\n"interrupt vector mapping\n");\r\nkfree(phba->sli4_hba.cpu_map);\r\nrc = -ENOMEM;\r\ngoto out_free_msix;\r\n}\r\nfor (i = 0; i < lpfc_present_cpu; i++)\r\nlpfc_used_cpu[i] = LPFC_VECTOR_MAP_EMPTY;\r\n}\r\ncpup = phba->sli4_hba.cpu_map;\r\nrc = 0;\r\nfor (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {\r\ncpup->channel_id = rc;\r\nrc++;\r\nif (rc >= phba->cfg_fcp_io_channel)\r\nrc = 0;\r\n}\r\nif (phba->cfg_sriov_nr_virtfn > 0) {\r\nrc = lpfc_sli_probe_sriov_nr_virtfn(phba,\r\nphba->cfg_sriov_nr_virtfn);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"3020 Requested number of SR-IOV "\r\n"virtual functions (%d) is not "\r\n"supported\n",\r\nphba->cfg_sriov_nr_virtfn);\r\nphba->cfg_sriov_nr_virtfn = 0;\r\n}\r\n}\r\nreturn 0;\r\nout_free_msix:\r\nkfree(phba->sli4_hba.msix_entries);\r\nout_free_fcp_eq_hdl:\r\nkfree(phba->sli4_hba.fcp_eq_hdl);\r\nout_free_fcf_rr_bmask:\r\nkfree(phba->fcf.fcf_rr_bmask);\r\nout_remove_rpi_hdrs:\r\nlpfc_sli4_remove_rpi_hdrs(phba);\r\nout_free_active_sgl:\r\nlpfc_free_active_sgl(phba);\r\nout_destroy_cq_event_pool:\r\nlpfc_sli4_cq_event_pool_destroy(phba);\r\nout_free_bsmbx:\r\nlpfc_destroy_bootstrap_mbox(phba);\r\nout_free_mem:\r\nlpfc_mem_free(phba);\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_sli4_driver_resource_unset(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_fcf_conn_entry *conn_entry, *next_conn_entry;\r\nkfree(phba->sli4_hba.cpu_map);\r\nphba->sli4_hba.num_present_cpu = 0;\r\nphba->sli4_hba.num_online_cpu = 0;\r\nphba->sli4_hba.curr_disp_cpu = 0;\r\nkfree(phba->sli4_hba.msix_entries);\r\nkfree(phba->sli4_hba.fcp_eq_hdl);\r\nlpfc_sli4_remove_rpi_hdrs(phba);\r\nlpfc_sli4_remove_rpis(phba);\r\nkfree(phba->fcf.fcf_rr_bmask);\r\nlpfc_free_active_sgl(phba);\r\nlpfc_free_els_sgl_list(phba);\r\nlpfc_sli4_cq_event_release_all(phba);\r\nlpfc_sli4_cq_event_pool_destroy(phba);\r\nlpfc_sli4_dealloc_resource_identifiers(phba);\r\nlpfc_destroy_bootstrap_mbox(phba);\r\nlpfc_mem_free_all(phba);\r\nlist_for_each_entry_safe(conn_entry, next_conn_entry,\r\n&phba->fcf_conn_rec_list, list) {\r\nlist_del_init(&conn_entry->list);\r\nkfree(conn_entry);\r\n}\r\nreturn;\r\n}\r\nint\r\nlpfc_init_api_table_setup(struct lpfc_hba *phba, uint8_t dev_grp)\r\n{\r\nphba->lpfc_hba_init_link = lpfc_hba_init_link;\r\nphba->lpfc_hba_down_link = lpfc_hba_down_link;\r\nphba->lpfc_selective_reset = lpfc_selective_reset;\r\nswitch (dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nphba->lpfc_hba_down_post = lpfc_hba_down_post_s3;\r\nphba->lpfc_handle_eratt = lpfc_handle_eratt_s3;\r\nphba->lpfc_stop_port = lpfc_stop_port_s3;\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nphba->lpfc_hba_down_post = lpfc_hba_down_post_s4;\r\nphba->lpfc_handle_eratt = lpfc_handle_eratt_s4;\r\nphba->lpfc_stop_port = lpfc_stop_port_s4;\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1431 Invalid HBA PCI-device group: 0x%x\n",\r\ndev_grp);\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_setup_driver_resource_phase1(struct lpfc_hba *phba)\r\n{\r\natomic_set(&phba->fast_event_count, 0);\r\nspin_lock_init(&phba->hbalock);\r\nspin_lock_init(&phba->ndlp_lock);\r\nINIT_LIST_HEAD(&phba->port_list);\r\nINIT_LIST_HEAD(&phba->work_list);\r\ninit_waitqueue_head(&phba->wait_4_mlo_m_q);\r\ninit_waitqueue_head(&phba->work_waitq);\r\nspin_lock_init(&phba->scsi_buf_list_get_lock);\r\nINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_get);\r\nspin_lock_init(&phba->scsi_buf_list_put_lock);\r\nINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\r\nINIT_LIST_HEAD(&phba->fabric_iocb_list);\r\nINIT_LIST_HEAD(&phba->elsbuf);\r\nINIT_LIST_HEAD(&phba->fcf_conn_rec_list);\r\nspin_lock_init(&phba->devicelock);\r\nINIT_LIST_HEAD(&phba->luns);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_setup_driver_resource_phase2(struct lpfc_hba *phba)\r\n{\r\nint error;\r\nphba->worker_thread = kthread_run(lpfc_do_work, phba,\r\n"lpfc_worker_%d", phba->brd_no);\r\nif (IS_ERR(phba->worker_thread)) {\r\nerror = PTR_ERR(phba->worker_thread);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_unset_driver_resource_phase2(struct lpfc_hba *phba)\r\n{\r\nkthread_stop(phba->worker_thread);\r\n}\r\nstatic void\r\nlpfc_free_iocb_list(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_iocbq *iocbq_entry = NULL, *iocbq_next = NULL;\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(iocbq_entry, iocbq_next,\r\n&phba->lpfc_iocb_list, list) {\r\nlist_del(&iocbq_entry->list);\r\nkfree(iocbq_entry);\r\nphba->total_iocbq_bufs--;\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_init_iocb_list(struct lpfc_hba *phba, int iocb_count)\r\n{\r\nstruct lpfc_iocbq *iocbq_entry = NULL;\r\nuint16_t iotag;\r\nint i;\r\nINIT_LIST_HEAD(&phba->lpfc_iocb_list);\r\nfor (i = 0; i < iocb_count; i++) {\r\niocbq_entry = kzalloc(sizeof(struct lpfc_iocbq), GFP_KERNEL);\r\nif (iocbq_entry == NULL) {\r\nprintk(KERN_ERR "%s: only allocated %d iocbs of "\r\n"expected %d count. Unloading driver.\n",\r\n__func__, i, LPFC_IOCB_LIST_CNT);\r\ngoto out_free_iocbq;\r\n}\r\niotag = lpfc_sli_next_iotag(phba, iocbq_entry);\r\nif (iotag == 0) {\r\nkfree(iocbq_entry);\r\nprintk(KERN_ERR "%s: failed to allocate IOTAG. "\r\n"Unloading driver.\n", __func__);\r\ngoto out_free_iocbq;\r\n}\r\niocbq_entry->sli4_lxritag = NO_XRI;\r\niocbq_entry->sli4_xritag = NO_XRI;\r\nspin_lock_irq(&phba->hbalock);\r\nlist_add(&iocbq_entry->list, &phba->lpfc_iocb_list);\r\nphba->total_iocbq_bufs++;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nreturn 0;\r\nout_free_iocbq:\r\nlpfc_free_iocb_list(phba);\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nlpfc_free_sgl_list(struct lpfc_hba *phba, struct list_head *sglq_list)\r\n{\r\nstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\r\nlist_for_each_entry_safe(sglq_entry, sglq_next, sglq_list, list) {\r\nlist_del(&sglq_entry->list);\r\nlpfc_mbuf_free(phba, sglq_entry->virt, sglq_entry->phys);\r\nkfree(sglq_entry);\r\n}\r\n}\r\nstatic void\r\nlpfc_free_els_sgl_list(struct lpfc_hba *phba)\r\n{\r\nLIST_HEAD(sglq_list);\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nspin_lock(&pring->ring_lock);\r\nlist_splice_init(&phba->sli4_hba.lpfc_sgl_list, &sglq_list);\r\nspin_unlock(&pring->ring_lock);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_free_sgl_list(phba, &sglq_list);\r\n}\r\nstatic int\r\nlpfc_init_active_sgl_array(struct lpfc_hba *phba)\r\n{\r\nint size;\r\nsize = sizeof(struct lpfc_sglq *);\r\nsize *= phba->sli4_hba.max_cfg_param.max_xri;\r\nphba->sli4_hba.lpfc_sglq_active_list =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!phba->sli4_hba.lpfc_sglq_active_list)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_free_active_sgl(struct lpfc_hba *phba)\r\n{\r\nkfree(phba->sli4_hba.lpfc_sglq_active_list);\r\n}\r\nstatic void\r\nlpfc_init_sgl_list(struct lpfc_hba *phba)\r\n{\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_sgl_list);\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_els_sgl_list);\r\nphba->sli4_hba.els_xri_cnt = 0;\r\nphba->sli4_hba.scsi_xri_cnt = 0;\r\n}\r\nint\r\nlpfc_sli4_init_rpi_hdrs(struct lpfc_hba *phba)\r\n{\r\nint rc = 0;\r\nstruct lpfc_rpi_hdr *rpi_hdr;\r\nINIT_LIST_HEAD(&phba->sli4_hba.lpfc_rpi_hdr_list);\r\nif (!phba->sli4_hba.rpi_hdrs_in_use)\r\nreturn rc;\r\nif (phba->sli4_hba.extents_in_use)\r\nreturn -EIO;\r\nrpi_hdr = lpfc_sli4_create_rpi_hdr(phba);\r\nif (!rpi_hdr) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,\r\n"0391 Error during rpi post operation\n");\r\nlpfc_sli4_remove_rpis(phba);\r\nrc = -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstruct lpfc_rpi_hdr *\r\nlpfc_sli4_create_rpi_hdr(struct lpfc_hba *phba)\r\n{\r\nuint16_t rpi_limit, curr_rpi_range;\r\nstruct lpfc_dmabuf *dmabuf;\r\nstruct lpfc_rpi_hdr *rpi_hdr;\r\nuint32_t rpi_count;\r\nif (!phba->sli4_hba.rpi_hdrs_in_use)\r\nreturn NULL;\r\nif (phba->sli4_hba.extents_in_use)\r\nreturn NULL;\r\nrpi_limit = phba->sli4_hba.max_cfg_param.rpi_base +\r\nphba->sli4_hba.max_cfg_param.max_rpi - 1;\r\nspin_lock_irq(&phba->hbalock);\r\ncurr_rpi_range = phba->sli4_hba.next_rpi;\r\nspin_unlock_irq(&phba->hbalock);\r\nif ((curr_rpi_range + (LPFC_RPI_HDR_COUNT - 1)) > rpi_limit)\r\nrpi_count = rpi_limit - curr_rpi_range;\r\nelse\r\nrpi_count = LPFC_RPI_HDR_COUNT;\r\nif (!rpi_count)\r\nreturn NULL;\r\ndmabuf = kzalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn NULL;\r\ndmabuf->virt = dma_zalloc_coherent(&phba->pcidev->dev,\r\nLPFC_HDR_TEMPLATE_SIZE,\r\n&dmabuf->phys, GFP_KERNEL);\r\nif (!dmabuf->virt) {\r\nrpi_hdr = NULL;\r\ngoto err_free_dmabuf;\r\n}\r\nif (!IS_ALIGNED(dmabuf->phys, LPFC_HDR_TEMPLATE_SIZE)) {\r\nrpi_hdr = NULL;\r\ngoto err_free_coherent;\r\n}\r\nrpi_hdr = kzalloc(sizeof(struct lpfc_rpi_hdr), GFP_KERNEL);\r\nif (!rpi_hdr)\r\ngoto err_free_coherent;\r\nrpi_hdr->dmabuf = dmabuf;\r\nrpi_hdr->len = LPFC_HDR_TEMPLATE_SIZE;\r\nrpi_hdr->page_count = 1;\r\nspin_lock_irq(&phba->hbalock);\r\nrpi_hdr->start_rpi = curr_rpi_range;\r\nlist_add_tail(&rpi_hdr->list, &phba->sli4_hba.lpfc_rpi_hdr_list);\r\nphba->sli4_hba.next_rpi += rpi_count;\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn rpi_hdr;\r\nerr_free_coherent:\r\ndma_free_coherent(&phba->pcidev->dev, LPFC_HDR_TEMPLATE_SIZE,\r\ndmabuf->virt, dmabuf->phys);\r\nerr_free_dmabuf:\r\nkfree(dmabuf);\r\nreturn NULL;\r\n}\r\nvoid\r\nlpfc_sli4_remove_rpi_hdrs(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_rpi_hdr *rpi_hdr, *next_rpi_hdr;\r\nif (!phba->sli4_hba.rpi_hdrs_in_use)\r\ngoto exit;\r\nlist_for_each_entry_safe(rpi_hdr, next_rpi_hdr,\r\n&phba->sli4_hba.lpfc_rpi_hdr_list, list) {\r\nlist_del(&rpi_hdr->list);\r\ndma_free_coherent(&phba->pcidev->dev, rpi_hdr->len,\r\nrpi_hdr->dmabuf->virt, rpi_hdr->dmabuf->phys);\r\nkfree(rpi_hdr->dmabuf);\r\nkfree(rpi_hdr);\r\n}\r\nexit:\r\nphba->sli4_hba.next_rpi = 0;\r\n}\r\nstatic struct lpfc_hba *\r\nlpfc_hba_alloc(struct pci_dev *pdev)\r\n{\r\nstruct lpfc_hba *phba;\r\nphba = kzalloc(sizeof(struct lpfc_hba), GFP_KERNEL);\r\nif (!phba) {\r\ndev_err(&pdev->dev, "failed to allocate hba struct\n");\r\nreturn NULL;\r\n}\r\nphba->pcidev = pdev;\r\nphba->brd_no = lpfc_get_instance();\r\nif (phba->brd_no < 0) {\r\nkfree(phba);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&phba->ct_ev_lock);\r\nINIT_LIST_HEAD(&phba->ct_ev_waiters);\r\nreturn phba;\r\n}\r\nstatic void\r\nlpfc_hba_free(struct lpfc_hba *phba)\r\n{\r\nidr_remove(&lpfc_hba_index, phba->brd_no);\r\nkfree(phba->sli.ring);\r\nphba->sli.ring = NULL;\r\nkfree(phba);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_create_shost(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport;\r\nstruct Scsi_Host *shost;\r\nphba->fc_edtov = FF_DEF_EDTOV;\r\nphba->fc_ratov = FF_DEF_RATOV;\r\nphba->fc_altov = FF_DEF_ALTOV;\r\nphba->fc_arbtov = FF_DEF_ARBTOV;\r\natomic_set(&phba->sdev_cnt, 0);\r\nvport = lpfc_create_port(phba, phba->brd_no, &phba->pcidev->dev);\r\nif (!vport)\r\nreturn -ENODEV;\r\nshost = lpfc_shost_from_vport(vport);\r\nphba->pport = vport;\r\nlpfc_debugfs_initialize(vport);\r\npci_set_drvdata(phba->pcidev, shost);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_destroy_shost(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\ndestroy_port(vport);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_setup_bg(struct lpfc_hba *phba, struct Scsi_Host *shost)\r\n{\r\nuint32_t old_mask;\r\nuint32_t old_guard;\r\nint pagecnt = 10;\r\nif (lpfc_prot_mask && lpfc_prot_guard) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"1478 Registering BlockGuard with the "\r\n"SCSI layer\n");\r\nold_mask = lpfc_prot_mask;\r\nold_guard = lpfc_prot_guard;\r\nlpfc_prot_mask &= (SHOST_DIF_TYPE1_PROTECTION |\r\nSHOST_DIX_TYPE0_PROTECTION |\r\nSHOST_DIX_TYPE1_PROTECTION);\r\nlpfc_prot_guard &= (SHOST_DIX_GUARD_IP | SHOST_DIX_GUARD_CRC);\r\nif (lpfc_prot_mask == SHOST_DIX_TYPE1_PROTECTION)\r\nlpfc_prot_mask |= SHOST_DIF_TYPE1_PROTECTION;\r\nif (lpfc_prot_mask && lpfc_prot_guard) {\r\nif ((old_mask != lpfc_prot_mask) ||\r\n(old_guard != lpfc_prot_guard))\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1475 Registering BlockGuard with the "\r\n"SCSI layer: mask %d guard %d\n",\r\nlpfc_prot_mask, lpfc_prot_guard);\r\nscsi_host_set_prot(shost, lpfc_prot_mask);\r\nscsi_host_set_guard(shost, lpfc_prot_guard);\r\n} else\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1479 Not Registering BlockGuard with the SCSI "\r\n"layer, Bad protection parameters: %d %d\n",\r\nold_mask, old_guard);\r\n}\r\nif (!_dump_buf_data) {\r\nwhile (pagecnt) {\r\nspin_lock_init(&_dump_buf_lock);\r\n_dump_buf_data =\r\n(char *) __get_free_pages(GFP_KERNEL, pagecnt);\r\nif (_dump_buf_data) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9043 BLKGRD: allocated %d pages for "\r\n"_dump_buf_data at 0x%p\n",\r\n(1 << pagecnt), _dump_buf_data);\r\n_dump_buf_data_order = pagecnt;\r\nmemset(_dump_buf_data, 0,\r\n((1 << PAGE_SHIFT) << pagecnt));\r\nbreak;\r\n} else\r\n--pagecnt;\r\n}\r\nif (!_dump_buf_data_order)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9044 BLKGRD: ERROR unable to allocate "\r\n"memory for hexdump\n");\r\n} else\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9045 BLKGRD: already allocated _dump_buf_data=0x%p"\r\n"\n", _dump_buf_data);\r\nif (!_dump_buf_dif) {\r\nwhile (pagecnt) {\r\n_dump_buf_dif =\r\n(char *) __get_free_pages(GFP_KERNEL, pagecnt);\r\nif (_dump_buf_dif) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9046 BLKGRD: allocated %d pages for "\r\n"_dump_buf_dif at 0x%p\n",\r\n(1 << pagecnt), _dump_buf_dif);\r\n_dump_buf_dif_order = pagecnt;\r\nmemset(_dump_buf_dif, 0,\r\n((1 << PAGE_SHIFT) << pagecnt));\r\nbreak;\r\n} else\r\n--pagecnt;\r\n}\r\nif (!_dump_buf_dif_order)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9047 BLKGRD: ERROR unable to allocate "\r\n"memory for hexdump\n");\r\n} else\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9048 BLKGRD: already allocated _dump_buf_dif=0x%p\n",\r\n_dump_buf_dif);\r\n}\r\nstatic void\r\nlpfc_post_init_setup(struct lpfc_hba *phba)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_adapter_event_header adapter_event;\r\nlpfc_get_hba_model_desc(phba, phba->ModelName, phba->ModelDesc);\r\nshost = pci_get_drvdata(phba->pcidev);\r\nshost->can_queue = phba->cfg_hba_queue_depth - 10;\r\nif (phba->sli3_options & LPFC_SLI3_BG_ENABLED)\r\nlpfc_setup_bg(phba, shost);\r\nlpfc_host_attrib_init(shost);\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\r\nspin_lock_irq(shost->host_lock);\r\nlpfc_poll_start_timer(phba);\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0428 Perform SCSI scan\n");\r\nadapter_event.event_type = FC_REG_ADAPTER_EVENT;\r\nadapter_event.subcategory = LPFC_EVENT_ARRIVAL;\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(adapter_event),\r\n(char *) &adapter_event,\r\nLPFC_NL_VENDOR_ID);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli_pci_mem_setup(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev;\r\nunsigned long bar0map_len, bar2map_len;\r\nint i, hbq_count;\r\nvoid *ptr;\r\nint error = -ENODEV;\r\nif (!phba->pcidev)\r\nreturn error;\r\nelse\r\npdev = phba->pcidev;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0\r\n|| pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(64)) != 0) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0\r\n|| pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(32)) != 0) {\r\nreturn error;\r\n}\r\n}\r\nphba->pci_bar0_map = pci_resource_start(pdev, 0);\r\nbar0map_len = pci_resource_len(pdev, 0);\r\nphba->pci_bar2_map = pci_resource_start(pdev, 2);\r\nbar2map_len = pci_resource_len(pdev, 2);\r\nphba->slim_memmap_p = ioremap(phba->pci_bar0_map, bar0map_len);\r\nif (!phba->slim_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for SLIM memory.\n");\r\ngoto out;\r\n}\r\nphba->ctrl_regs_memmap_p = ioremap(phba->pci_bar2_map, bar2map_len);\r\nif (!phba->ctrl_regs_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for HBA control registers.\n");\r\ngoto out_iounmap_slim;\r\n}\r\nphba->slim2p.virt = dma_zalloc_coherent(&pdev->dev, SLI2_SLIM_SIZE,\r\n&phba->slim2p.phys, GFP_KERNEL);\r\nif (!phba->slim2p.virt)\r\ngoto out_iounmap;\r\nphba->mbox = phba->slim2p.virt + offsetof(struct lpfc_sli2_slim, mbx);\r\nphba->mbox_ext = (phba->slim2p.virt +\r\noffsetof(struct lpfc_sli2_slim, mbx_ext_words));\r\nphba->pcb = (phba->slim2p.virt + offsetof(struct lpfc_sli2_slim, pcb));\r\nphba->IOCBs = (phba->slim2p.virt +\r\noffsetof(struct lpfc_sli2_slim, IOCBs));\r\nphba->hbqslimp.virt = dma_alloc_coherent(&pdev->dev,\r\nlpfc_sli_hbq_size(),\r\n&phba->hbqslimp.phys,\r\nGFP_KERNEL);\r\nif (!phba->hbqslimp.virt)\r\ngoto out_free_slim;\r\nhbq_count = lpfc_sli_hbq_count();\r\nptr = phba->hbqslimp.virt;\r\nfor (i = 0; i < hbq_count; ++i) {\r\nphba->hbqs[i].hbq_virt = ptr;\r\nINIT_LIST_HEAD(&phba->hbqs[i].hbq_buffer_list);\r\nptr += (lpfc_hbq_defs[i]->entry_count *\r\nsizeof(struct lpfc_hbq_entry));\r\n}\r\nphba->hbqs[LPFC_ELS_HBQ].hbq_alloc_buffer = lpfc_els_hbq_alloc;\r\nphba->hbqs[LPFC_ELS_HBQ].hbq_free_buffer = lpfc_els_hbq_free;\r\nmemset(phba->hbqslimp.virt, 0, lpfc_sli_hbq_size());\r\nINIT_LIST_HEAD(&phba->rb_pend_list);\r\nphba->MBslimaddr = phba->slim_memmap_p;\r\nphba->HAregaddr = phba->ctrl_regs_memmap_p + HA_REG_OFFSET;\r\nphba->CAregaddr = phba->ctrl_regs_memmap_p + CA_REG_OFFSET;\r\nphba->HSregaddr = phba->ctrl_regs_memmap_p + HS_REG_OFFSET;\r\nphba->HCregaddr = phba->ctrl_regs_memmap_p + HC_REG_OFFSET;\r\nreturn 0;\r\nout_free_slim:\r\ndma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,\r\nphba->slim2p.virt, phba->slim2p.phys);\r\nout_iounmap:\r\niounmap(phba->ctrl_regs_memmap_p);\r\nout_iounmap_slim:\r\niounmap(phba->slim_memmap_p);\r\nout:\r\nreturn error;\r\n}\r\nstatic void\r\nlpfc_sli_pci_mem_unset(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev;\r\nif (!phba->pcidev)\r\nreturn;\r\nelse\r\npdev = phba->pcidev;\r\ndma_free_coherent(&pdev->dev, lpfc_sli_hbq_size(),\r\nphba->hbqslimp.virt, phba->hbqslimp.phys);\r\ndma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,\r\nphba->slim2p.virt, phba->slim2p.phys);\r\niounmap(phba->ctrl_regs_memmap_p);\r\niounmap(phba->slim_memmap_p);\r\nreturn;\r\n}\r\nint\r\nlpfc_sli4_post_status_check(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_register portsmphr_reg, uerrlo_reg, uerrhi_reg;\r\nstruct lpfc_register reg_data;\r\nint i, port_error = 0;\r\nuint32_t if_type;\r\nmemset(&portsmphr_reg, 0, sizeof(portsmphr_reg));\r\nmemset(&reg_data, 0, sizeof(reg_data));\r\nif (!phba->sli4_hba.PSMPHRregaddr)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 3000; i++) {\r\nif (lpfc_readl(phba->sli4_hba.PSMPHRregaddr,\r\n&portsmphr_reg.word0) ||\r\n(bf_get(lpfc_port_smphr_perr, &portsmphr_reg))) {\r\nport_error = -ENODEV;\r\nbreak;\r\n}\r\nif (LPFC_POST_STAGE_PORT_READY ==\r\nbf_get(lpfc_port_smphr_port_status, &portsmphr_reg))\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (port_error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1408 Port Failed POST - portsmphr=0x%x, "\r\n"perr=x%x, sfi=x%x, nip=x%x, ipc=x%x, scr1=x%x, "\r\n"scr2=x%x, hscratch=x%x, pstatus=x%x\n",\r\nportsmphr_reg.word0,\r\nbf_get(lpfc_port_smphr_perr, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_sfi, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_nip, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_ipc, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_scr1, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_scr2, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_host_scratch, &portsmphr_reg),\r\nbf_get(lpfc_port_smphr_port_status, &portsmphr_reg));\r\n} else {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2534 Device Info: SLIFamily=0x%x, "\r\n"SLIRev=0x%x, IFType=0x%x, SLIHint_1=0x%x, "\r\n"SLIHint_2=0x%x, FT=0x%x\n",\r\nbf_get(lpfc_sli_intf_sli_family,\r\n&phba->sli4_hba.sli_intf),\r\nbf_get(lpfc_sli_intf_slirev,\r\n&phba->sli4_hba.sli_intf),\r\nbf_get(lpfc_sli_intf_if_type,\r\n&phba->sli4_hba.sli_intf),\r\nbf_get(lpfc_sli_intf_sli_hint1,\r\n&phba->sli4_hba.sli_intf),\r\nbf_get(lpfc_sli_intf_sli_hint2,\r\n&phba->sli4_hba.sli_intf),\r\nbf_get(lpfc_sli_intf_func_type,\r\n&phba->sli4_hba.sli_intf));\r\nif_type = bf_get(lpfc_sli_intf_if_type,\r\n&phba->sli4_hba.sli_intf);\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\nphba->sli4_hba.ue_mask_lo =\r\nreadl(phba->sli4_hba.u.if_type0.UEMASKLOregaddr);\r\nphba->sli4_hba.ue_mask_hi =\r\nreadl(phba->sli4_hba.u.if_type0.UEMASKHIregaddr);\r\nuerrlo_reg.word0 =\r\nreadl(phba->sli4_hba.u.if_type0.UERRLOregaddr);\r\nuerrhi_reg.word0 =\r\nreadl(phba->sli4_hba.u.if_type0.UERRHIregaddr);\r\nif ((~phba->sli4_hba.ue_mask_lo & uerrlo_reg.word0) ||\r\n(~phba->sli4_hba.ue_mask_hi & uerrhi_reg.word0)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1422 Unrecoverable Error "\r\n"Detected during POST "\r\n"uerr_lo_reg=0x%x, "\r\n"uerr_hi_reg=0x%x, "\r\n"ue_mask_lo_reg=0x%x, "\r\n"ue_mask_hi_reg=0x%x\n",\r\nuerrlo_reg.word0,\r\nuerrhi_reg.word0,\r\nphba->sli4_hba.ue_mask_lo,\r\nphba->sli4_hba.ue_mask_hi);\r\nport_error = -ENODEV;\r\n}\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\nif (lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\r\n&reg_data.word0) ||\r\n(bf_get(lpfc_sliport_status_err, &reg_data) &&\r\n!bf_get(lpfc_sliport_status_rn, &reg_data))) {\r\nphba->work_status[0] =\r\nreadl(phba->sli4_hba.u.if_type2.\r\nERR1regaddr);\r\nphba->work_status[1] =\r\nreadl(phba->sli4_hba.u.if_type2.\r\nERR2regaddr);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2888 Unrecoverable port error "\r\n"following POST: port status reg "\r\n"0x%x, port_smphr reg 0x%x, "\r\n"error 1=0x%x, error 2=0x%x\n",\r\nreg_data.word0,\r\nportsmphr_reg.word0,\r\nphba->work_status[0],\r\nphba->work_status[1]);\r\nport_error = -ENODEV;\r\n}\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn port_error;\r\n}\r\nstatic void\r\nlpfc_sli4_bar0_register_memmap(struct lpfc_hba *phba, uint32_t if_type)\r\n{\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\nphba->sli4_hba.u.if_type0.UERRLOregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_UERR_STATUS_LO;\r\nphba->sli4_hba.u.if_type0.UERRHIregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_UERR_STATUS_HI;\r\nphba->sli4_hba.u.if_type0.UEMASKLOregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_UE_MASK_LO;\r\nphba->sli4_hba.u.if_type0.UEMASKHIregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_UE_MASK_HI;\r\nphba->sli4_hba.SLIINTFregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_SLI_INTF;\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\nphba->sli4_hba.u.if_type2.ERR1regaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PORT_ER1_OFFSET;\r\nphba->sli4_hba.u.if_type2.ERR2regaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PORT_ER2_OFFSET;\r\nphba->sli4_hba.u.if_type2.CTRLregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PORT_CTL_OFFSET;\r\nphba->sli4_hba.u.if_type2.STATUSregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PORT_STA_OFFSET;\r\nphba->sli4_hba.SLIINTFregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_SLI_INTF;\r\nphba->sli4_hba.PSMPHRregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PORT_SEM_OFFSET;\r\nphba->sli4_hba.RQDBregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_ULP0_RQ_DOORBELL;\r\nphba->sli4_hba.WQDBregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_ULP0_WQ_DOORBELL;\r\nphba->sli4_hba.EQCQDBregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_EQCQ_DOORBELL;\r\nphba->sli4_hba.MQDBregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_MQ_DOORBELL;\r\nphba->sli4_hba.BMBXregaddr =\r\nphba->sli4_hba.conf_regs_memmap_p + LPFC_BMBX;\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\ndev_printk(KERN_ERR, &phba->pcidev->dev,\r\n"FATAL - unsupported SLI4 interface type - %d\n",\r\nif_type);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlpfc_sli4_bar1_register_memmap(struct lpfc_hba *phba)\r\n{\r\nphba->sli4_hba.PSMPHRregaddr = phba->sli4_hba.ctrl_regs_memmap_p +\r\nLPFC_SLIPORT_IF0_SMPHR;\r\nphba->sli4_hba.ISRregaddr = phba->sli4_hba.ctrl_regs_memmap_p +\r\nLPFC_HST_ISR0;\r\nphba->sli4_hba.IMRregaddr = phba->sli4_hba.ctrl_regs_memmap_p +\r\nLPFC_HST_IMR0;\r\nphba->sli4_hba.ISCRregaddr = phba->sli4_hba.ctrl_regs_memmap_p +\r\nLPFC_HST_ISCR0;\r\n}\r\nstatic int\r\nlpfc_sli4_bar2_register_memmap(struct lpfc_hba *phba, uint32_t vf)\r\n{\r\nif (vf > LPFC_VIR_FUNC_MAX)\r\nreturn -ENODEV;\r\nphba->sli4_hba.RQDBregaddr = (phba->sli4_hba.drbl_regs_memmap_p +\r\nvf * LPFC_VFR_PAGE_SIZE +\r\nLPFC_ULP0_RQ_DOORBELL);\r\nphba->sli4_hba.WQDBregaddr = (phba->sli4_hba.drbl_regs_memmap_p +\r\nvf * LPFC_VFR_PAGE_SIZE +\r\nLPFC_ULP0_WQ_DOORBELL);\r\nphba->sli4_hba.EQCQDBregaddr = (phba->sli4_hba.drbl_regs_memmap_p +\r\nvf * LPFC_VFR_PAGE_SIZE + LPFC_EQCQ_DOORBELL);\r\nphba->sli4_hba.MQDBregaddr = (phba->sli4_hba.drbl_regs_memmap_p +\r\nvf * LPFC_VFR_PAGE_SIZE + LPFC_MQ_DOORBELL);\r\nphba->sli4_hba.BMBXregaddr = (phba->sli4_hba.drbl_regs_memmap_p +\r\nvf * LPFC_VFR_PAGE_SIZE + LPFC_BMBX);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_create_bootstrap_mbox(struct lpfc_hba *phba)\r\n{\r\nuint32_t bmbx_size;\r\nstruct lpfc_dmabuf *dmabuf;\r\nstruct dma_address *dma_address;\r\nuint32_t pa_addr;\r\nuint64_t phys_addr;\r\ndmabuf = kzalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn -ENOMEM;\r\nbmbx_size = sizeof(struct lpfc_bmbx_create) + (LPFC_ALIGN_16_BYTE - 1);\r\ndmabuf->virt = dma_zalloc_coherent(&phba->pcidev->dev, bmbx_size,\r\n&dmabuf->phys, GFP_KERNEL);\r\nif (!dmabuf->virt) {\r\nkfree(dmabuf);\r\nreturn -ENOMEM;\r\n}\r\nphba->sli4_hba.bmbx.dmabuf = dmabuf;\r\nphba->sli4_hba.bmbx.bmbx_size = bmbx_size;\r\nphba->sli4_hba.bmbx.avirt = PTR_ALIGN(dmabuf->virt,\r\nLPFC_ALIGN_16_BYTE);\r\nphba->sli4_hba.bmbx.aphys = ALIGN(dmabuf->phys,\r\nLPFC_ALIGN_16_BYTE);\r\ndma_address = &phba->sli4_hba.bmbx.dma_address;\r\nphys_addr = (uint64_t)phba->sli4_hba.bmbx.aphys;\r\npa_addr = (uint32_t) ((phys_addr >> 34) & 0x3fffffff);\r\ndma_address->addr_hi = (uint32_t) ((pa_addr << 2) |\r\nLPFC_BMBX_BIT1_ADDR_HI);\r\npa_addr = (uint32_t) ((phba->sli4_hba.bmbx.aphys >> 4) & 0x3fffffff);\r\ndma_address->addr_lo = (uint32_t) ((pa_addr << 2) |\r\nLPFC_BMBX_BIT1_ADDR_LO);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_destroy_bootstrap_mbox(struct lpfc_hba *phba)\r\n{\r\ndma_free_coherent(&phba->pcidev->dev,\r\nphba->sli4_hba.bmbx.bmbx_size,\r\nphba->sli4_hba.bmbx.dmabuf->virt,\r\nphba->sli4_hba.bmbx.dmabuf->phys);\r\nkfree(phba->sli4_hba.bmbx.dmabuf);\r\nmemset(&phba->sli4_hba.bmbx, 0, sizeof(struct lpfc_bmbx));\r\n}\r\nint\r\nlpfc_sli4_read_config(struct lpfc_hba *phba)\r\n{\r\nLPFC_MBOXQ_t *pmb;\r\nstruct lpfc_mbx_read_config *rd_config;\r\nunion lpfc_sli4_cfg_shdr *shdr;\r\nuint32_t shdr_status, shdr_add_status;\r\nstruct lpfc_mbx_get_func_cfg *get_func_cfg;\r\nstruct lpfc_rsrc_desc_fcfcoe *desc;\r\nchar *pdesc_0;\r\nint length, i, rc = 0, rc2;\r\npmb = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2011 Unable to allocate memory for issuing "\r\n"SLI_CONFIG_SPECIAL mailbox command\n");\r\nreturn -ENOMEM;\r\n}\r\nlpfc_read_config(phba, pmb);\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"2012 Mailbox failed , mbxCmd x%x "\r\n"READ_CONFIG, mbxStatus x%x\n",\r\nbf_get(lpfc_mqe_command, &pmb->u.mqe),\r\nbf_get(lpfc_mqe_status, &pmb->u.mqe));\r\nrc = -EIO;\r\n} else {\r\nrd_config = &pmb->u.mqe.un.rd_config;\r\nif (bf_get(lpfc_mbx_rd_conf_lnk_ldv, rd_config)) {\r\nphba->sli4_hba.lnk_info.lnk_dv = LPFC_LNK_DAT_VAL;\r\nphba->sli4_hba.lnk_info.lnk_tp =\r\nbf_get(lpfc_mbx_rd_conf_lnk_type, rd_config);\r\nphba->sli4_hba.lnk_info.lnk_no =\r\nbf_get(lpfc_mbx_rd_conf_lnk_numb, rd_config);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3081 lnk_type:%d, lnk_numb:%d\n",\r\nphba->sli4_hba.lnk_info.lnk_tp,\r\nphba->sli4_hba.lnk_info.lnk_no);\r\n} else\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_SLI,\r\n"3082 Mailbox (x%x) returned ldv:x0\n",\r\nbf_get(lpfc_mqe_command, &pmb->u.mqe));\r\nphba->sli4_hba.extents_in_use =\r\nbf_get(lpfc_mbx_rd_conf_extnts_inuse, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_xri =\r\nbf_get(lpfc_mbx_rd_conf_xri_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.xri_base =\r\nbf_get(lpfc_mbx_rd_conf_xri_base, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_vpi =\r\nbf_get(lpfc_mbx_rd_conf_vpi_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.vpi_base =\r\nbf_get(lpfc_mbx_rd_conf_vpi_base, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_rpi =\r\nbf_get(lpfc_mbx_rd_conf_rpi_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.rpi_base =\r\nbf_get(lpfc_mbx_rd_conf_rpi_base, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_vfi =\r\nbf_get(lpfc_mbx_rd_conf_vfi_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.vfi_base =\r\nbf_get(lpfc_mbx_rd_conf_vfi_base, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_fcfi =\r\nbf_get(lpfc_mbx_rd_conf_fcfi_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_eq =\r\nbf_get(lpfc_mbx_rd_conf_eq_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_rq =\r\nbf_get(lpfc_mbx_rd_conf_rq_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_wq =\r\nbf_get(lpfc_mbx_rd_conf_wq_count, rd_config);\r\nphba->sli4_hba.max_cfg_param.max_cq =\r\nbf_get(lpfc_mbx_rd_conf_cq_count, rd_config);\r\nphba->lmt = bf_get(lpfc_mbx_rd_conf_lmt, rd_config);\r\nphba->sli4_hba.next_xri = phba->sli4_hba.max_cfg_param.xri_base;\r\nphba->vpi_base = phba->sli4_hba.max_cfg_param.vpi_base;\r\nphba->vfi_base = phba->sli4_hba.max_cfg_param.vfi_base;\r\nphba->max_vpi = (phba->sli4_hba.max_cfg_param.max_vpi > 0) ?\r\n(phba->sli4_hba.max_cfg_param.max_vpi - 1) : 0;\r\nphba->max_vports = phba->max_vpi;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"2003 cfg params Extents? %d "\r\n"XRI(B:%d M:%d), "\r\n"VPI(B:%d M:%d) "\r\n"VFI(B:%d M:%d) "\r\n"RPI(B:%d M:%d) "\r\n"FCFI(Count:%d)\n",\r\nphba->sli4_hba.extents_in_use,\r\nphba->sli4_hba.max_cfg_param.xri_base,\r\nphba->sli4_hba.max_cfg_param.max_xri,\r\nphba->sli4_hba.max_cfg_param.vpi_base,\r\nphba->sli4_hba.max_cfg_param.max_vpi,\r\nphba->sli4_hba.max_cfg_param.vfi_base,\r\nphba->sli4_hba.max_cfg_param.max_vfi,\r\nphba->sli4_hba.max_cfg_param.rpi_base,\r\nphba->sli4_hba.max_cfg_param.max_rpi,\r\nphba->sli4_hba.max_cfg_param.max_fcfi);\r\n}\r\nif (rc)\r\ngoto read_cfg_out;\r\nlength = phba->sli4_hba.max_cfg_param.max_xri -\r\nlpfc_sli4_get_els_iocb_cnt(phba);\r\nif (phba->cfg_hba_queue_depth > length) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"3361 HBA queue depth changed from %d to %d\n",\r\nphba->cfg_hba_queue_depth, length);\r\nphba->cfg_hba_queue_depth = length;\r\n}\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2)\r\ngoto read_cfg_out;\r\nlength = (sizeof(struct lpfc_mbx_get_func_cfg) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nlpfc_sli4_config(phba, pmb, LPFC_MBOX_SUBSYSTEM_COMMON,\r\nLPFC_MBOX_OPCODE_GET_FUNCTION_CONFIG,\r\nlength, LPFC_SLI4_MBX_EMBED);\r\nrc2 = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nshdr = (union lpfc_sli4_cfg_shdr *)\r\n&pmb->u.mqe.un.sli4_config.header.cfg_shdr;\r\nshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\r\nshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\r\nif (rc2 || shdr_status || shdr_add_status) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"3026 Mailbox failed , mbxCmd x%x "\r\n"GET_FUNCTION_CONFIG, mbxStatus x%x\n",\r\nbf_get(lpfc_mqe_command, &pmb->u.mqe),\r\nbf_get(lpfc_mqe_status, &pmb->u.mqe));\r\ngoto read_cfg_out;\r\n}\r\nget_func_cfg = &pmb->u.mqe.un.get_func_cfg;\r\npdesc_0 = (char *)&get_func_cfg->func_cfg.desc[0];\r\ndesc = (struct lpfc_rsrc_desc_fcfcoe *)pdesc_0;\r\nlength = bf_get(lpfc_rsrc_desc_fcfcoe_length, desc);\r\nif (length == LPFC_RSRC_DESC_TYPE_FCFCOE_V0_RSVD)\r\nlength = LPFC_RSRC_DESC_TYPE_FCFCOE_V0_LENGTH;\r\nelse if (length != LPFC_RSRC_DESC_TYPE_FCFCOE_V1_LENGTH)\r\ngoto read_cfg_out;\r\nfor (i = 0; i < LPFC_RSRC_DESC_MAX_NUM; i++) {\r\ndesc = (struct lpfc_rsrc_desc_fcfcoe *)(pdesc_0 + length * i);\r\nif (LPFC_RSRC_DESC_TYPE_FCFCOE ==\r\nbf_get(lpfc_rsrc_desc_fcfcoe_type, desc)) {\r\nphba->sli4_hba.iov.pf_number =\r\nbf_get(lpfc_rsrc_desc_fcfcoe_pfnum, desc);\r\nphba->sli4_hba.iov.vf_number =\r\nbf_get(lpfc_rsrc_desc_fcfcoe_vfnum, desc);\r\nbreak;\r\n}\r\n}\r\nif (i < LPFC_RSRC_DESC_MAX_NUM)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_SLI,\r\n"3027 GET_FUNCTION_CONFIG: pf_number:%d, "\r\n"vf_number:%d\n", phba->sli4_hba.iov.pf_number,\r\nphba->sli4_hba.iov.vf_number);\r\nelse\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"3028 GET_FUNCTION_CONFIG: failed to find "\r\n"Resrouce Descriptor:x%x\n",\r\nLPFC_RSRC_DESC_TYPE_FCFCOE);\r\nread_cfg_out:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_setup_endian_order(struct lpfc_hba *phba)\r\n{\r\nLPFC_MBOXQ_t *mboxq;\r\nuint32_t if_type, rc = 0;\r\nuint32_t endian_mb_data[2] = {HOST_ENDIAN_LOW_WORD0,\r\nHOST_ENDIAN_HIGH_WORD1};\r\nif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\nmboxq = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!mboxq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0492 Unable to allocate memory for "\r\n"issuing SLI_CONFIG_SPECIAL mailbox "\r\n"command\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(mboxq, 0, sizeof(LPFC_MBOXQ_t));\r\nmemcpy(&mboxq->u.mqe, &endian_mb_data, sizeof(endian_mb_data));\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0493 SLI_CONFIG_SPECIAL mailbox "\r\n"failed with status x%x\n",\r\nrc);\r\nrc = -EIO;\r\n}\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_queue_verify(struct lpfc_hba *phba)\r\n{\r\nint cfg_fcp_io_channel;\r\nuint32_t cpu;\r\nuint32_t i = 0;\r\nint fof_vectors = phba->cfg_fof ? 1 : 0;\r\ncfg_fcp_io_channel = phba->cfg_fcp_io_channel;\r\nfor_each_present_cpu(cpu) {\r\nif (cpu_online(cpu))\r\ni++;\r\n}\r\nphba->sli4_hba.num_online_cpu = i;\r\nphba->sli4_hba.num_present_cpu = lpfc_present_cpu;\r\nphba->sli4_hba.curr_disp_cpu = 0;\r\nif (i < cfg_fcp_io_channel) {\r\nlpfc_printf_log(phba,\r\nKERN_ERR, LOG_INIT,\r\n"3188 Reducing IO channels to match number of "\r\n"online CPUs: from %d to %d\n",\r\ncfg_fcp_io_channel, i);\r\ncfg_fcp_io_channel = i;\r\n}\r\nif (cfg_fcp_io_channel + fof_vectors >\r\nphba->sli4_hba.max_cfg_param.max_eq) {\r\nif (phba->sli4_hba.max_cfg_param.max_eq <\r\nLPFC_FCP_IO_CHAN_MIN) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2574 Not enough EQs (%d) from the "\r\n"pci function for supporting FCP "\r\n"EQs (%d)\n",\r\nphba->sli4_hba.max_cfg_param.max_eq,\r\nphba->cfg_fcp_io_channel);\r\ngoto out_error;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2575 Reducing IO channels to match number of "\r\n"available EQs: from %d to %d\n",\r\ncfg_fcp_io_channel,\r\nphba->sli4_hba.max_cfg_param.max_eq);\r\ncfg_fcp_io_channel = phba->sli4_hba.max_cfg_param.max_eq -\r\nfof_vectors;\r\n}\r\nphba->cfg_fcp_io_channel = cfg_fcp_io_channel;\r\nphba->sli4_hba.eq_esize = LPFC_EQE_SIZE_4B;\r\nphba->sli4_hba.eq_ecount = LPFC_EQE_DEF_COUNT;\r\nphba->sli4_hba.cq_esize = LPFC_CQE_SIZE;\r\nphba->sli4_hba.cq_ecount = LPFC_CQE_DEF_COUNT;\r\nreturn 0;\r\nout_error:\r\nreturn -ENOMEM;\r\n}\r\nint\r\nlpfc_sli4_queue_create(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_queue *qdesc;\r\nint idx;\r\nif (!phba->cfg_fcp_io_channel)\r\nreturn -ERANGE;\r\nphba->sli4_hba.mq_esize = LPFC_MQE_SIZE;\r\nphba->sli4_hba.mq_ecount = LPFC_MQE_DEF_COUNT;\r\nphba->sli4_hba.wq_esize = LPFC_WQE_SIZE;\r\nphba->sli4_hba.wq_ecount = LPFC_WQE_DEF_COUNT;\r\nphba->sli4_hba.rq_esize = LPFC_RQE_SIZE;\r\nphba->sli4_hba.rq_ecount = LPFC_RQE_DEF_COUNT;\r\nphba->sli4_hba.hba_eq = kzalloc((sizeof(struct lpfc_queue *) *\r\nphba->cfg_fcp_io_channel), GFP_KERNEL);\r\nif (!phba->sli4_hba.hba_eq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2576 Failed allocate memory for "\r\n"fast-path EQ record array\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fcp_cq = kzalloc((sizeof(struct lpfc_queue *) *\r\nphba->cfg_fcp_io_channel), GFP_KERNEL);\r\nif (!phba->sli4_hba.fcp_cq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2577 Failed allocate memory for fast-path "\r\n"CQ record array\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fcp_wq = kzalloc((sizeof(struct lpfc_queue *) *\r\nphba->cfg_fcp_io_channel), GFP_KERNEL);\r\nif (!phba->sli4_hba.fcp_wq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2578 Failed allocate memory for fast-path "\r\n"WQ record array\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fcp_cq_map = kzalloc((sizeof(uint16_t) *\r\nphba->cfg_fcp_io_channel), GFP_KERNEL);\r\nif (!phba->sli4_hba.fcp_cq_map) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2545 Failed allocate memory for fast-path "\r\n"CQ map\n");\r\ngoto out_error;\r\n}\r\nfor (idx = 0; idx < phba->cfg_fcp_io_channel; idx++) {\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.eq_esize,\r\nphba->sli4_hba.eq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0497 Failed allocate EQ (%d)\n", idx);\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.hba_eq[idx] = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.cq_esize,\r\nphba->sli4_hba.cq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0499 Failed allocate fast-path FCP "\r\n"CQ (%d)\n", idx);\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fcp_cq[idx] = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.wq_esize,\r\nphba->sli4_hba.wq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0503 Failed allocate fast-path FCP "\r\n"WQ (%d)\n", idx);\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fcp_wq[idx] = qdesc;\r\n}\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.cq_esize,\r\nphba->sli4_hba.cq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0500 Failed allocate slow-path mailbox CQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.mbx_cq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.cq_esize,\r\nphba->sli4_hba.cq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0501 Failed allocate slow-path ELS CQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.els_cq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.mq_esize,\r\nphba->sli4_hba.mq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0505 Failed allocate slow-path MQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.mbx_wq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.wq_esize,\r\nphba->sli4_hba.wq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0504 Failed allocate slow-path ELS WQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.els_wq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.rq_esize,\r\nphba->sli4_hba.rq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0506 Failed allocate receive HRQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.hdr_rq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.rq_esize,\r\nphba->sli4_hba.rq_ecount);\r\nif (!qdesc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0507 Failed allocate receive DRQ\n");\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.dat_rq = qdesc;\r\nif (phba->cfg_fof)\r\nlpfc_fof_queue_create(phba);\r\nreturn 0;\r\nout_error:\r\nlpfc_sli4_queue_destroy(phba);\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nlpfc_sli4_queue_destroy(struct lpfc_hba *phba)\r\n{\r\nint idx;\r\nif (phba->cfg_fof)\r\nlpfc_fof_queue_destroy(phba);\r\nif (phba->sli4_hba.hba_eq != NULL) {\r\nfor (idx = 0; idx < phba->cfg_fcp_io_channel; idx++) {\r\nif (phba->sli4_hba.hba_eq[idx] != NULL) {\r\nlpfc_sli4_queue_free(\r\nphba->sli4_hba.hba_eq[idx]);\r\nphba->sli4_hba.hba_eq[idx] = NULL;\r\n}\r\n}\r\nkfree(phba->sli4_hba.hba_eq);\r\nphba->sli4_hba.hba_eq = NULL;\r\n}\r\nif (phba->sli4_hba.fcp_cq != NULL) {\r\nfor (idx = 0; idx < phba->cfg_fcp_io_channel; idx++) {\r\nif (phba->sli4_hba.fcp_cq[idx] != NULL) {\r\nlpfc_sli4_queue_free(\r\nphba->sli4_hba.fcp_cq[idx]);\r\nphba->sli4_hba.fcp_cq[idx] = NULL;\r\n}\r\n}\r\nkfree(phba->sli4_hba.fcp_cq);\r\nphba->sli4_hba.fcp_cq = NULL;\r\n}\r\nif (phba->sli4_hba.fcp_wq != NULL) {\r\nfor (idx = 0; idx < phba->cfg_fcp_io_channel; idx++) {\r\nif (phba->sli4_hba.fcp_wq[idx] != NULL) {\r\nlpfc_sli4_queue_free(\r\nphba->sli4_hba.fcp_wq[idx]);\r\nphba->sli4_hba.fcp_wq[idx] = NULL;\r\n}\r\n}\r\nkfree(phba->sli4_hba.fcp_wq);\r\nphba->sli4_hba.fcp_wq = NULL;\r\n}\r\nif (phba->sli4_hba.fcp_cq_map != NULL) {\r\nkfree(phba->sli4_hba.fcp_cq_map);\r\nphba->sli4_hba.fcp_cq_map = NULL;\r\n}\r\nif (phba->sli4_hba.mbx_wq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.mbx_wq);\r\nphba->sli4_hba.mbx_wq = NULL;\r\n}\r\nif (phba->sli4_hba.els_wq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.els_wq);\r\nphba->sli4_hba.els_wq = NULL;\r\n}\r\nif (phba->sli4_hba.hdr_rq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.hdr_rq);\r\nphba->sli4_hba.hdr_rq = NULL;\r\n}\r\nif (phba->sli4_hba.dat_rq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.dat_rq);\r\nphba->sli4_hba.dat_rq = NULL;\r\n}\r\nif (phba->sli4_hba.els_cq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.els_cq);\r\nphba->sli4_hba.els_cq = NULL;\r\n}\r\nif (phba->sli4_hba.mbx_cq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.mbx_cq);\r\nphba->sli4_hba.mbx_cq = NULL;\r\n}\r\nreturn;\r\n}\r\nint\r\nlpfc_sli4_queue_setup(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring;\r\nint rc = -ENOMEM;\r\nint fcp_eqidx, fcp_cqidx, fcp_wqidx;\r\nint fcp_cq_index = 0;\r\nuint32_t shdr_status, shdr_add_status;\r\nunion lpfc_sli4_cfg_shdr *shdr;\r\nLPFC_MBOXQ_t *mboxq;\r\nuint32_t length;\r\nmboxq = (LPFC_MBOXQ_t *)mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mboxq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3249 Unable to allocate memory for "\r\n"QUERY_FW_CFG mailbox command\n");\r\nreturn -ENOMEM;\r\n}\r\nlength = (sizeof(struct lpfc_mbx_query_fw_config) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nlpfc_sli4_config(phba, mboxq, LPFC_MBOX_SUBSYSTEM_COMMON,\r\nLPFC_MBOX_OPCODE_QUERY_FW_CFG,\r\nlength, LPFC_SLI4_MBX_EMBED);\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nshdr = (union lpfc_sli4_cfg_shdr *)\r\n&mboxq->u.mqe.un.sli4_config.header.cfg_shdr;\r\nshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\r\nshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\r\nif (shdr_status || shdr_add_status || rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3250 QUERY_FW_CFG mailbox failed with status "\r\n"x%x add_status x%x, mbx status x%x\n",\r\nshdr_status, shdr_add_status, rc);\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nrc = -ENXIO;\r\ngoto out_error;\r\n}\r\nphba->sli4_hba.fw_func_mode =\r\nmboxq->u.mqe.un.query_fw_cfg.rsp.function_mode;\r\nphba->sli4_hba.ulp0_mode = mboxq->u.mqe.un.query_fw_cfg.rsp.ulp0_mode;\r\nphba->sli4_hba.ulp1_mode = mboxq->u.mqe.un.query_fw_cfg.rsp.ulp1_mode;\r\nphba->sli4_hba.physical_port =\r\nmboxq->u.mqe.un.query_fw_cfg.rsp.physical_port;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3251 QUERY_FW_CFG: func_mode:x%x, ulp0_mode:x%x, "\r\n"ulp1_mode:x%x\n", phba->sli4_hba.fw_func_mode,\r\nphba->sli4_hba.ulp0_mode, phba->sli4_hba.ulp1_mode);\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nif (phba->cfg_fcp_io_channel && !phba->sli4_hba.hba_eq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3147 Fast-path EQs not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_error;\r\n}\r\nfor (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_io_channel; fcp_eqidx++) {\r\nif (!phba->sli4_hba.hba_eq[fcp_eqidx]) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0522 Fast-path EQ (%d) not "\r\n"allocated\n", fcp_eqidx);\r\nrc = -ENOMEM;\r\ngoto out_destroy_hba_eq;\r\n}\r\nrc = lpfc_eq_create(phba, phba->sli4_hba.hba_eq[fcp_eqidx],\r\n(phba->cfg_fcp_imax / phba->cfg_fcp_io_channel));\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0523 Failed setup of fast-path EQ "\r\n"(%d), rc = 0x%x\n", fcp_eqidx,\r\n(uint32_t)rc);\r\ngoto out_destroy_hba_eq;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2584 HBA EQ setup: "\r\n"queue[%d]-id=%d\n", fcp_eqidx,\r\nphba->sli4_hba.hba_eq[fcp_eqidx]->queue_id);\r\n}\r\nif (!phba->sli4_hba.fcp_cq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3148 Fast-path FCP CQ array not "\r\n"allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_hba_eq;\r\n}\r\nfor (fcp_cqidx = 0; fcp_cqidx < phba->cfg_fcp_io_channel; fcp_cqidx++) {\r\nif (!phba->sli4_hba.fcp_cq[fcp_cqidx]) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0526 Fast-path FCP CQ (%d) not "\r\n"allocated\n", fcp_cqidx);\r\nrc = -ENOMEM;\r\ngoto out_destroy_fcp_cq;\r\n}\r\nrc = lpfc_cq_create(phba, phba->sli4_hba.fcp_cq[fcp_cqidx],\r\nphba->sli4_hba.hba_eq[fcp_cqidx], LPFC_WCQ, LPFC_FCP);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0527 Failed setup of fast-path FCP "\r\n"CQ (%d), rc = 0x%x\n", fcp_cqidx,\r\n(uint32_t)rc);\r\ngoto out_destroy_fcp_cq;\r\n}\r\nphba->sli4_hba.fcp_cq_map[fcp_cqidx] =\r\nphba->sli4_hba.fcp_cq[fcp_cqidx]->queue_id;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2588 FCP CQ setup: cq[%d]-id=%d, "\r\n"parent seq[%d]-id=%d\n",\r\nfcp_cqidx,\r\nphba->sli4_hba.fcp_cq[fcp_cqidx]->queue_id,\r\nfcp_cqidx,\r\nphba->sli4_hba.hba_eq[fcp_cqidx]->queue_id);\r\n}\r\nif (!phba->sli4_hba.fcp_wq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3149 Fast-path FCP WQ array not "\r\n"allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_fcp_cq;\r\n}\r\nfor (fcp_wqidx = 0; fcp_wqidx < phba->cfg_fcp_io_channel; fcp_wqidx++) {\r\nif (!phba->sli4_hba.fcp_wq[fcp_wqidx]) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0534 Fast-path FCP WQ (%d) not "\r\n"allocated\n", fcp_wqidx);\r\nrc = -ENOMEM;\r\ngoto out_destroy_fcp_wq;\r\n}\r\nrc = lpfc_wq_create(phba, phba->sli4_hba.fcp_wq[fcp_wqidx],\r\nphba->sli4_hba.fcp_cq[fcp_wqidx],\r\nLPFC_FCP);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0535 Failed setup of fast-path FCP "\r\n"WQ (%d), rc = 0x%x\n", fcp_wqidx,\r\n(uint32_t)rc);\r\ngoto out_destroy_fcp_wq;\r\n}\r\npring = &psli->ring[MAX_SLI3_CONFIGURED_RINGS + fcp_wqidx];\r\npring->sli.sli4.wqp = (void *)phba->sli4_hba.fcp_wq[fcp_wqidx];\r\nphba->sli4_hba.fcp_cq[fcp_wqidx]->pring = pring;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2591 FCP WQ setup: wq[%d]-id=%d, "\r\n"parent cq[%d]-id=%d\n",\r\nfcp_wqidx,\r\nphba->sli4_hba.fcp_wq[fcp_wqidx]->queue_id,\r\nfcp_cq_index,\r\nphba->sli4_hba.fcp_cq[fcp_wqidx]->queue_id);\r\n}\r\nif (!phba->sli4_hba.mbx_cq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0528 Mailbox CQ not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_fcp_wq;\r\n}\r\nrc = lpfc_cq_create(phba, phba->sli4_hba.mbx_cq,\r\nphba->sli4_hba.hba_eq[0], LPFC_MCQ, LPFC_MBOX);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0529 Failed setup of slow-path mailbox CQ: "\r\n"rc = 0x%x\n", (uint32_t)rc);\r\ngoto out_destroy_fcp_wq;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2585 MBX CQ setup: cq-id=%d, parent eq-id=%d\n",\r\nphba->sli4_hba.mbx_cq->queue_id,\r\nphba->sli4_hba.hba_eq[0]->queue_id);\r\nif (!phba->sli4_hba.els_cq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0530 ELS CQ not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_mbx_cq;\r\n}\r\nrc = lpfc_cq_create(phba, phba->sli4_hba.els_cq,\r\nphba->sli4_hba.hba_eq[0], LPFC_WCQ, LPFC_ELS);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0531 Failed setup of slow-path ELS CQ: "\r\n"rc = 0x%x\n", (uint32_t)rc);\r\ngoto out_destroy_mbx_cq;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2586 ELS CQ setup: cq-id=%d, parent eq-id=%d\n",\r\nphba->sli4_hba.els_cq->queue_id,\r\nphba->sli4_hba.hba_eq[0]->queue_id);\r\nif (!phba->sli4_hba.mbx_wq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0538 Slow-path MQ not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_els_cq;\r\n}\r\nrc = lpfc_mq_create(phba, phba->sli4_hba.mbx_wq,\r\nphba->sli4_hba.mbx_cq, LPFC_MBOX);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0539 Failed setup of slow-path MQ: "\r\n"rc = 0x%x\n", rc);\r\ngoto out_destroy_els_cq;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2589 MBX MQ setup: wq-id=%d, parent cq-id=%d\n",\r\nphba->sli4_hba.mbx_wq->queue_id,\r\nphba->sli4_hba.mbx_cq->queue_id);\r\nif (!phba->sli4_hba.els_wq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0536 Slow-path ELS WQ not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_mbx_wq;\r\n}\r\nrc = lpfc_wq_create(phba, phba->sli4_hba.els_wq,\r\nphba->sli4_hba.els_cq, LPFC_ELS);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0537 Failed setup of slow-path ELS WQ: "\r\n"rc = 0x%x\n", (uint32_t)rc);\r\ngoto out_destroy_mbx_wq;\r\n}\r\npring = &psli->ring[LPFC_ELS_RING];\r\npring->sli.sli4.wqp = (void *)phba->sli4_hba.els_wq;\r\nphba->sli4_hba.els_cq->pring = pring;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2590 ELS WQ setup: wq-id=%d, parent cq-id=%d\n",\r\nphba->sli4_hba.els_wq->queue_id,\r\nphba->sli4_hba.els_cq->queue_id);\r\nif (!phba->sli4_hba.hdr_rq || !phba->sli4_hba.dat_rq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0540 Receive Queue not allocated\n");\r\nrc = -ENOMEM;\r\ngoto out_destroy_els_wq;\r\n}\r\nlpfc_rq_adjust_repost(phba, phba->sli4_hba.hdr_rq, LPFC_ELS_HBQ);\r\nlpfc_rq_adjust_repost(phba, phba->sli4_hba.dat_rq, LPFC_ELS_HBQ);\r\nrc = lpfc_rq_create(phba, phba->sli4_hba.hdr_rq, phba->sli4_hba.dat_rq,\r\nphba->sli4_hba.els_cq, LPFC_USOL);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0541 Failed setup of Receive Queue: "\r\n"rc = 0x%x\n", (uint32_t)rc);\r\ngoto out_destroy_fcp_wq;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2592 USL RQ setup: hdr-rq-id=%d, dat-rq-id=%d "\r\n"parent cq-id=%d\n",\r\nphba->sli4_hba.hdr_rq->queue_id,\r\nphba->sli4_hba.dat_rq->queue_id,\r\nphba->sli4_hba.els_cq->queue_id);\r\nif (phba->cfg_fof) {\r\nrc = lpfc_fof_queue_setup(phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0549 Failed setup of FOF Queues: "\r\n"rc = 0x%x\n", rc);\r\ngoto out_destroy_els_rq;\r\n}\r\n}\r\nfor (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_io_channel;\r\nfcp_eqidx += LPFC_MAX_EQ_DELAY)\r\nlpfc_modify_fcp_eq_delay(phba, fcp_eqidx);\r\nreturn 0;\r\nout_destroy_els_rq:\r\nlpfc_rq_destroy(phba, phba->sli4_hba.hdr_rq, phba->sli4_hba.dat_rq);\r\nout_destroy_els_wq:\r\nlpfc_wq_destroy(phba, phba->sli4_hba.els_wq);\r\nout_destroy_mbx_wq:\r\nlpfc_mq_destroy(phba, phba->sli4_hba.mbx_wq);\r\nout_destroy_els_cq:\r\nlpfc_cq_destroy(phba, phba->sli4_hba.els_cq);\r\nout_destroy_mbx_cq:\r\nlpfc_cq_destroy(phba, phba->sli4_hba.mbx_cq);\r\nout_destroy_fcp_wq:\r\nfor (--fcp_wqidx; fcp_wqidx >= 0; fcp_wqidx--)\r\nlpfc_wq_destroy(phba, phba->sli4_hba.fcp_wq[fcp_wqidx]);\r\nout_destroy_fcp_cq:\r\nfor (--fcp_cqidx; fcp_cqidx >= 0; fcp_cqidx--)\r\nlpfc_cq_destroy(phba, phba->sli4_hba.fcp_cq[fcp_cqidx]);\r\nout_destroy_hba_eq:\r\nfor (--fcp_eqidx; fcp_eqidx >= 0; fcp_eqidx--)\r\nlpfc_eq_destroy(phba, phba->sli4_hba.hba_eq[fcp_eqidx]);\r\nout_error:\r\nreturn rc;\r\n}\r\nvoid\r\nlpfc_sli4_queue_unset(struct lpfc_hba *phba)\r\n{\r\nint fcp_qidx;\r\nif (phba->cfg_fof)\r\nlpfc_fof_queue_destroy(phba);\r\nlpfc_mq_destroy(phba, phba->sli4_hba.mbx_wq);\r\nlpfc_wq_destroy(phba, phba->sli4_hba.els_wq);\r\nlpfc_rq_destroy(phba, phba->sli4_hba.hdr_rq, phba->sli4_hba.dat_rq);\r\nif (phba->sli4_hba.fcp_wq) {\r\nfor (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_io_channel;\r\nfcp_qidx++)\r\nlpfc_wq_destroy(phba, phba->sli4_hba.fcp_wq[fcp_qidx]);\r\n}\r\nlpfc_cq_destroy(phba, phba->sli4_hba.mbx_cq);\r\nlpfc_cq_destroy(phba, phba->sli4_hba.els_cq);\r\nif (phba->sli4_hba.fcp_cq) {\r\nfor (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_io_channel;\r\nfcp_qidx++)\r\nlpfc_cq_destroy(phba, phba->sli4_hba.fcp_cq[fcp_qidx]);\r\n}\r\nif (phba->sli4_hba.hba_eq) {\r\nfor (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_io_channel;\r\nfcp_qidx++)\r\nlpfc_eq_destroy(phba, phba->sli4_hba.hba_eq[fcp_qidx]);\r\n}\r\n}\r\nstatic int\r\nlpfc_sli4_cq_event_pool_create(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_cq_event *cq_event;\r\nint i;\r\nfor (i = 0; i < (4 * phba->sli4_hba.cq_ecount); i++) {\r\ncq_event = kmalloc(sizeof(struct lpfc_cq_event), GFP_KERNEL);\r\nif (!cq_event)\r\ngoto out_pool_create_fail;\r\nlist_add_tail(&cq_event->list,\r\n&phba->sli4_hba.sp_cqe_event_pool);\r\n}\r\nreturn 0;\r\nout_pool_create_fail:\r\nlpfc_sli4_cq_event_pool_destroy(phba);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nlpfc_sli4_cq_event_pool_destroy(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_cq_event *cq_event, *next_cq_event;\r\nlist_for_each_entry_safe(cq_event, next_cq_event,\r\n&phba->sli4_hba.sp_cqe_event_pool, list) {\r\nlist_del(&cq_event->list);\r\nkfree(cq_event);\r\n}\r\n}\r\nstruct lpfc_cq_event *\r\n__lpfc_sli4_cq_event_alloc(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_cq_event *cq_event = NULL;\r\nlist_remove_head(&phba->sli4_hba.sp_cqe_event_pool, cq_event,\r\nstruct lpfc_cq_event, list);\r\nreturn cq_event;\r\n}\r\nstruct lpfc_cq_event *\r\nlpfc_sli4_cq_event_alloc(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_cq_event *cq_event;\r\nunsigned long iflags;\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\ncq_event = __lpfc_sli4_cq_event_alloc(phba);\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\nreturn cq_event;\r\n}\r\nvoid\r\n__lpfc_sli4_cq_event_release(struct lpfc_hba *phba,\r\nstruct lpfc_cq_event *cq_event)\r\n{\r\nlist_add_tail(&cq_event->list, &phba->sli4_hba.sp_cqe_event_pool);\r\n}\r\nvoid\r\nlpfc_sli4_cq_event_release(struct lpfc_hba *phba,\r\nstruct lpfc_cq_event *cq_event)\r\n{\r\nunsigned long iflags;\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\n__lpfc_sli4_cq_event_release(phba, cq_event);\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\n}\r\nstatic void\r\nlpfc_sli4_cq_event_release_all(struct lpfc_hba *phba)\r\n{\r\nLIST_HEAD(cqelist);\r\nstruct lpfc_cq_event *cqe;\r\nunsigned long iflags;\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\nlist_splice_init(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue,\r\n&cqelist);\r\nlist_splice_init(&phba->sli4_hba.sp_els_xri_aborted_work_queue,\r\n&cqelist);\r\nlist_splice_init(&phba->sli4_hba.sp_asynce_work_queue,\r\n&cqelist);\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\nwhile (!list_empty(&cqelist)) {\r\nlist_remove_head(&cqelist, cqe, struct lpfc_cq_event, list);\r\nlpfc_sli4_cq_event_release(phba, cqe);\r\n}\r\n}\r\nint\r\nlpfc_pci_function_reset(struct lpfc_hba *phba)\r\n{\r\nLPFC_MBOXQ_t *mboxq;\r\nuint32_t rc = 0, if_type;\r\nuint32_t shdr_status, shdr_add_status;\r\nuint32_t rdy_chk;\r\nuint32_t port_reset = 0;\r\nunion lpfc_sli4_cfg_shdr *shdr;\r\nstruct lpfc_register reg_data;\r\nuint16_t devid;\r\nif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\nmboxq = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!mboxq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0494 Unable to allocate memory for "\r\n"issuing SLI_FUNCTION_RESET mailbox "\r\n"command\n");\r\nreturn -ENOMEM;\r\n}\r\nlpfc_sli4_config(phba, mboxq, LPFC_MBOX_SUBSYSTEM_COMMON,\r\nLPFC_MBOX_OPCODE_FUNCTION_RESET, 0,\r\nLPFC_SLI4_MBX_EMBED);\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nshdr = (union lpfc_sli4_cfg_shdr *)\r\n&mboxq->u.mqe.un.sli4_config.header.cfg_shdr;\r\nshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\r\nshdr_add_status = bf_get(lpfc_mbox_hdr_add_status,\r\n&shdr->response);\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nif (shdr_status || shdr_add_status || rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0495 SLI_FUNCTION_RESET mailbox "\r\n"failed with status x%x add_status x%x,"\r\n" mbx status x%x\n",\r\nshdr_status, shdr_add_status, rc);\r\nrc = -ENXIO;\r\n}\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\nwait:\r\nfor (rdy_chk = 0; rdy_chk < 1500; rdy_chk++) {\r\nif (lpfc_readl(phba->sli4_hba.u.if_type2.\r\nSTATUSregaddr, &reg_data.word0)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif (bf_get(lpfc_sliport_status_rdy, &reg_data))\r\nbreak;\r\nmsleep(20);\r\n}\r\nif (!bf_get(lpfc_sliport_status_rdy, &reg_data)) {\r\nphba->work_status[0] = readl(\r\nphba->sli4_hba.u.if_type2.ERR1regaddr);\r\nphba->work_status[1] = readl(\r\nphba->sli4_hba.u.if_type2.ERR2regaddr);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2890 Port not ready, port status reg "\r\n"0x%x error 1=0x%x, error 2=0x%x\n",\r\nreg_data.word0,\r\nphba->work_status[0],\r\nphba->work_status[1]);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif (!port_reset) {\r\nreg_data.word0 = 0;\r\nbf_set(lpfc_sliport_ctrl_end, &reg_data,\r\nLPFC_SLIPORT_LITTLE_ENDIAN);\r\nbf_set(lpfc_sliport_ctrl_ip, &reg_data,\r\nLPFC_SLIPORT_INIT_PORT);\r\nwritel(reg_data.word0, phba->sli4_hba.u.if_type2.\r\nCTRLregaddr);\r\npci_read_config_word(phba->pcidev,\r\nPCI_DEVICE_ID, &devid);\r\nport_reset = 1;\r\nmsleep(20);\r\ngoto wait;\r\n} else if (bf_get(lpfc_sliport_status_rn, &reg_data)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3317 HBA not functional: IP Reset Failed "\r\n"try: echo fw_reset > board_mode\n");\r\nrc = -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sli4_pci_mem_setup(struct lpfc_hba *phba)\r\n{\r\nstruct pci_dev *pdev;\r\nunsigned long bar0map_len, bar1map_len, bar2map_len;\r\nint error = -ENODEV;\r\nuint32_t if_type;\r\nif (!phba->pcidev)\r\nreturn error;\r\nelse\r\npdev = phba->pcidev;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0\r\n|| pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(64)) != 0) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0\r\n|| pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(32)) != 0) {\r\nreturn error;\r\n}\r\n}\r\nif (pci_read_config_dword(pdev, LPFC_SLI_INTF,\r\n&phba->sli4_hba.sli_intf.word0)) {\r\nreturn error;\r\n}\r\nif (bf_get(lpfc_sli_intf_valid, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_VALID) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2894 SLI_INTF reg contents invalid "\r\n"sli_intf reg 0x%x\n",\r\nphba->sli4_hba.sli_intf.word0);\r\nreturn error;\r\n}\r\nif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\r\nif (pci_resource_start(pdev, PCI_64BIT_BAR0)) {\r\nphba->pci_bar0_map = pci_resource_start(pdev, PCI_64BIT_BAR0);\r\nbar0map_len = pci_resource_len(pdev, PCI_64BIT_BAR0);\r\nphba->sli4_hba.conf_regs_memmap_p =\r\nioremap(phba->pci_bar0_map, bar0map_len);\r\nif (!phba->sli4_hba.conf_regs_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for SLI4 PCI config "\r\n"registers.\n");\r\ngoto out;\r\n}\r\nphba->pci_bar0_memmap_p = phba->sli4_hba.conf_regs_memmap_p;\r\nlpfc_sli4_bar0_register_memmap(phba, if_type);\r\n} else {\r\nphba->pci_bar0_map = pci_resource_start(pdev, 1);\r\nbar0map_len = pci_resource_len(pdev, 1);\r\nif (if_type == LPFC_SLI_INTF_IF_TYPE_2) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"FATAL - No BAR0 mapping for SLI4, if_type 2\n");\r\ngoto out;\r\n}\r\nphba->sli4_hba.conf_regs_memmap_p =\r\nioremap(phba->pci_bar0_map, bar0map_len);\r\nif (!phba->sli4_hba.conf_regs_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for SLI4 PCI config "\r\n"registers.\n");\r\ngoto out;\r\n}\r\nlpfc_sli4_bar0_register_memmap(phba, if_type);\r\n}\r\nif ((if_type == LPFC_SLI_INTF_IF_TYPE_0) &&\r\n(pci_resource_start(pdev, PCI_64BIT_BAR2))) {\r\nphba->pci_bar1_map = pci_resource_start(pdev, PCI_64BIT_BAR2);\r\nbar1map_len = pci_resource_len(pdev, PCI_64BIT_BAR2);\r\nphba->sli4_hba.ctrl_regs_memmap_p =\r\nioremap(phba->pci_bar1_map, bar1map_len);\r\nif (!phba->sli4_hba.ctrl_regs_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for SLI4 HBA control registers.\n");\r\ngoto out_iounmap_conf;\r\n}\r\nphba->pci_bar2_memmap_p = phba->sli4_hba.ctrl_regs_memmap_p;\r\nlpfc_sli4_bar1_register_memmap(phba);\r\n}\r\nif ((if_type == LPFC_SLI_INTF_IF_TYPE_0) &&\r\n(pci_resource_start(pdev, PCI_64BIT_BAR4))) {\r\nphba->pci_bar2_map = pci_resource_start(pdev, PCI_64BIT_BAR4);\r\nbar2map_len = pci_resource_len(pdev, PCI_64BIT_BAR4);\r\nphba->sli4_hba.drbl_regs_memmap_p =\r\nioremap(phba->pci_bar2_map, bar2map_len);\r\nif (!phba->sli4_hba.drbl_regs_memmap_p) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"ioremap failed for SLI4 HBA doorbell registers.\n");\r\ngoto out_iounmap_ctrl;\r\n}\r\nphba->pci_bar4_memmap_p = phba->sli4_hba.drbl_regs_memmap_p;\r\nerror = lpfc_sli4_bar2_register_memmap(phba, LPFC_VF0);\r\nif (error)\r\ngoto out_iounmap_all;\r\n}\r\nreturn 0;\r\nout_iounmap_all:\r\niounmap(phba->sli4_hba.drbl_regs_memmap_p);\r\nout_iounmap_ctrl:\r\niounmap(phba->sli4_hba.ctrl_regs_memmap_p);\r\nout_iounmap_conf:\r\niounmap(phba->sli4_hba.conf_regs_memmap_p);\r\nout:\r\nreturn error;\r\n}\r\nstatic void\r\nlpfc_sli4_pci_mem_unset(struct lpfc_hba *phba)\r\n{\r\nuint32_t if_type;\r\nif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\r\nswitch (if_type) {\r\ncase LPFC_SLI_INTF_IF_TYPE_0:\r\niounmap(phba->sli4_hba.drbl_regs_memmap_p);\r\niounmap(phba->sli4_hba.ctrl_regs_memmap_p);\r\niounmap(phba->sli4_hba.conf_regs_memmap_p);\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_2:\r\niounmap(phba->sli4_hba.conf_regs_memmap_p);\r\nbreak;\r\ncase LPFC_SLI_INTF_IF_TYPE_1:\r\ndefault:\r\ndev_printk(KERN_ERR, &phba->pcidev->dev,\r\n"FATAL - unsupported SLI4 interface type - %d\n",\r\nif_type);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nlpfc_sli_enable_msix(struct lpfc_hba *phba)\r\n{\r\nint rc, i;\r\nLPFC_MBOXQ_t *pmb;\r\nfor (i = 0; i < LPFC_MSIX_VECTORS; i++)\r\nphba->msix_entries[i].entry = i;\r\nrc = pci_enable_msix_exact(phba->pcidev, phba->msix_entries,\r\nLPFC_MSIX_VECTORS);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0420 PCI enable MSI-X failed (%d)\n", rc);\r\ngoto vec_fail_out;\r\n}\r\nfor (i = 0; i < LPFC_MSIX_VECTORS; i++)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0477 MSI-X entry[%d]: vector=x%x "\r\n"message=%d\n", i,\r\nphba->msix_entries[i].vector,\r\nphba->msix_entries[i].entry);\r\nrc = request_irq(phba->msix_entries[0].vector,\r\n&lpfc_sli_sp_intr_handler, 0,\r\nLPFC_SP_DRIVER_HANDLER_NAME, phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0421 MSI-X slow-path request_irq failed "\r\n"(%d)\n", rc);\r\ngoto msi_fail_out;\r\n}\r\nrc = request_irq(phba->msix_entries[1].vector,\r\n&lpfc_sli_fp_intr_handler, 0,\r\nLPFC_FP_DRIVER_HANDLER_NAME, phba);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0429 MSI-X fast-path request_irq failed "\r\n"(%d)\n", rc);\r\ngoto irq_fail_out;\r\n}\r\npmb = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmb) {\r\nrc = -ENOMEM;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0474 Unable to allocate memory for issuing "\r\n"MBOX_CONFIG_MSI command\n");\r\ngoto mem_fail_out;\r\n}\r\nrc = lpfc_config_msi(phba, pmb);\r\nif (rc)\r\ngoto mbx_fail_out;\r\nrc = lpfc_sli_issue_mbox(phba, pmb, MBX_POLL);\r\nif (rc != MBX_SUCCESS) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\r\n"0351 Config MSI mailbox command failed, "\r\n"mbxCmd x%x, mbxStatus x%x\n",\r\npmb->u.mb.mbxCommand, pmb->u.mb.mbxStatus);\r\ngoto mbx_fail_out;\r\n}\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn rc;\r\nmbx_fail_out:\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nmem_fail_out:\r\nfree_irq(phba->msix_entries[1].vector, phba);\r\nirq_fail_out:\r\nfree_irq(phba->msix_entries[0].vector, phba);\r\nmsi_fail_out:\r\npci_disable_msix(phba->pcidev);\r\nvec_fail_out:\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_sli_disable_msix(struct lpfc_hba *phba)\r\n{\r\nint i;\r\nfor (i = 0; i < LPFC_MSIX_VECTORS; i++)\r\nfree_irq(phba->msix_entries[i].vector, phba);\r\npci_disable_msix(phba->pcidev);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli_enable_msi(struct lpfc_hba *phba)\r\n{\r\nint rc;\r\nrc = pci_enable_msi(phba->pcidev);\r\nif (!rc)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0462 PCI enable MSI mode success.\n");\r\nelse {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0471 PCI enable MSI mode failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nrc = request_irq(phba->pcidev->irq, lpfc_sli_intr_handler,\r\n0, LPFC_DRIVER_NAME, phba);\r\nif (rc) {\r\npci_disable_msi(phba->pcidev);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0478 MSI request_irq failed (%d)\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_sli_disable_msi(struct lpfc_hba *phba)\r\n{\r\nfree_irq(phba->pcidev->irq, phba);\r\npci_disable_msi(phba->pcidev);\r\nreturn;\r\n}\r\nstatic uint32_t\r\nlpfc_sli_enable_intr(struct lpfc_hba *phba, uint32_t cfg_mode)\r\n{\r\nuint32_t intr_mode = LPFC_INTR_ERROR;\r\nint retval;\r\nif (cfg_mode == 2) {\r\nretval = lpfc_sli_config_port(phba, LPFC_SLI_REV3);\r\nif (!retval) {\r\nretval = lpfc_sli_enable_msix(phba);\r\nif (!retval) {\r\nphba->intr_type = MSIX;\r\nintr_mode = 2;\r\n}\r\n}\r\n}\r\nif (cfg_mode >= 1 && phba->intr_type == NONE) {\r\nretval = lpfc_sli_enable_msi(phba);\r\nif (!retval) {\r\nphba->intr_type = MSI;\r\nintr_mode = 1;\r\n}\r\n}\r\nif (phba->intr_type == NONE) {\r\nretval = request_irq(phba->pcidev->irq, lpfc_sli_intr_handler,\r\nIRQF_SHARED, LPFC_DRIVER_NAME, phba);\r\nif (!retval) {\r\nphba->intr_type = INTx;\r\nintr_mode = 0;\r\n}\r\n}\r\nreturn intr_mode;\r\n}\r\nstatic void\r\nlpfc_sli_disable_intr(struct lpfc_hba *phba)\r\n{\r\nif (phba->intr_type == MSIX)\r\nlpfc_sli_disable_msix(phba);\r\nelse if (phba->intr_type == MSI)\r\nlpfc_sli_disable_msi(phba);\r\nelse if (phba->intr_type == INTx)\r\nfree_irq(phba->pcidev->irq, phba);\r\nphba->intr_type = NONE;\r\nphba->sli.slistat.sli_intr = 0;\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_find_next_cpu(struct lpfc_hba *phba, uint32_t phys_id)\r\n{\r\nstruct lpfc_vector_map_info *cpup;\r\nint cpu;\r\ncpup = phba->sli4_hba.cpu_map;\r\nfor (cpu = 0; cpu < phba->sli4_hba.num_present_cpu; cpu++) {\r\nif (cpu_online(cpu)) {\r\nif ((cpup->irq == LPFC_VECTOR_MAP_EMPTY) &&\r\n(lpfc_used_cpu[cpu] == LPFC_VECTOR_MAP_EMPTY) &&\r\n(cpup->phys_id == phys_id)) {\r\nreturn cpu;\r\n}\r\n}\r\ncpup++;\r\n}\r\nfor (cpu = 0; cpu < phba->sli4_hba.num_present_cpu; cpu++) {\r\nif (lpfc_used_cpu[cpu] == phys_id)\r\nlpfc_used_cpu[cpu] = LPFC_VECTOR_MAP_EMPTY;\r\n}\r\ncpup = phba->sli4_hba.cpu_map;\r\nfor (cpu = 0; cpu < phba->sli4_hba.num_present_cpu; cpu++) {\r\nif (cpu_online(cpu)) {\r\nif ((cpup->irq == LPFC_VECTOR_MAP_EMPTY) &&\r\n(cpup->phys_id == phys_id)) {\r\nreturn cpu;\r\n}\r\n}\r\ncpup++;\r\n}\r\nreturn LPFC_VECTOR_MAP_EMPTY;\r\n}\r\nstatic int\r\nlpfc_sli4_set_affinity(struct lpfc_hba *phba, int vectors)\r\n{\r\nint i, idx, saved_chann, used_chann, cpu, phys_id;\r\nint max_phys_id, min_phys_id;\r\nint num_io_channel, first_cpu, chan;\r\nstruct lpfc_vector_map_info *cpup;\r\n#ifdef CONFIG_X86\r\nstruct cpuinfo_x86 *cpuinfo;\r\n#endif\r\nstruct cpumask *mask;\r\nuint8_t chann[LPFC_FCP_IO_CHAN_MAX+1];\r\nif (!phba->cfg_fcp_cpu_map)\r\nreturn 1;\r\nmemset(phba->sli4_hba.cpu_map, 0xff,\r\n(sizeof(struct lpfc_vector_map_info) *\r\nphba->sli4_hba.num_present_cpu));\r\nmax_phys_id = 0;\r\nmin_phys_id = 0xff;\r\nphys_id = 0;\r\nnum_io_channel = 0;\r\nfirst_cpu = LPFC_VECTOR_MAP_EMPTY;\r\ncpup = phba->sli4_hba.cpu_map;\r\nfor (cpu = 0; cpu < phba->sli4_hba.num_present_cpu; cpu++) {\r\n#ifdef CONFIG_X86\r\ncpuinfo = &cpu_data(cpu);\r\ncpup->phys_id = cpuinfo->phys_proc_id;\r\ncpup->core_id = cpuinfo->cpu_core_id;\r\n#else\r\ncpup->phys_id = 0;\r\ncpup->core_id = 0;\r\n#endif\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3328 CPU physid %d coreid %d\n",\r\ncpup->phys_id, cpup->core_id);\r\nif (cpup->phys_id > max_phys_id)\r\nmax_phys_id = cpup->phys_id;\r\nif (cpup->phys_id < min_phys_id)\r\nmin_phys_id = cpup->phys_id;\r\ncpup++;\r\n}\r\nphys_id = min_phys_id;\r\nfor (idx = 0; idx < vectors; idx++) {\r\ncpup = phba->sli4_hba.cpu_map;\r\ncpu = lpfc_find_next_cpu(phba, phys_id);\r\nif (cpu == LPFC_VECTOR_MAP_EMPTY) {\r\nfor (i = 1; i < max_phys_id; i++) {\r\nphys_id++;\r\nif (phys_id > max_phys_id)\r\nphys_id = min_phys_id;\r\ncpu = lpfc_find_next_cpu(phba, phys_id);\r\nif (cpu == LPFC_VECTOR_MAP_EMPTY)\r\ncontinue;\r\ngoto found;\r\n}\r\nphba->cfg_fcp_io_sched = LPFC_FCP_SCHED_ROUND_ROBIN;\r\nchan = 0;\r\ncpup = phba->sli4_hba.cpu_map;\r\nfor (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {\r\ncpup->channel_id = chan;\r\ncpup++;\r\nchan++;\r\nif (chan >= phba->cfg_fcp_io_channel)\r\nchan = 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3329 Cannot set affinity:"\r\n"Error mapping vector %d (%d)\n",\r\nidx, vectors);\r\nreturn 0;\r\n}\r\nfound:\r\ncpup += cpu;\r\nif (phba->cfg_fcp_cpu_map == LPFC_DRIVER_CPU_MAP)\r\nlpfc_used_cpu[cpu] = phys_id;\r\ncpup->irq = phba->sli4_hba.msix_entries[idx].vector;\r\ncpup->channel_id = idx;\r\nnum_io_channel++;\r\nif (first_cpu == LPFC_VECTOR_MAP_EMPTY)\r\nfirst_cpu = cpu;\r\nmask = &cpup->maskbits;\r\ncpumask_clear(mask);\r\ncpumask_set_cpu(cpu, mask);\r\ni = irq_set_affinity_hint(phba->sli4_hba.msix_entries[idx].\r\nvector, mask);\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3330 Set Affinity: CPU %d channel %d "\r\n"irq %d (%x)\n",\r\ncpu, cpup->channel_id,\r\nphba->sli4_hba.msix_entries[idx].vector, i);\r\nphys_id++;\r\nif (phys_id > max_phys_id)\r\nphys_id = min_phys_id;\r\n}\r\nfor (i = min_phys_id; i <= max_phys_id; i++) {\r\nfor (idx = 0; idx < phba->cfg_fcp_io_channel; idx++)\r\nchann[idx] = idx;\r\nsaved_chann = 0;\r\nused_chann = 0;\r\ncpup = phba->sli4_hba.cpu_map;\r\ncpu = first_cpu;\r\ncpup += cpu;\r\nfor (idx = 0; idx < phba->sli4_hba.num_present_cpu;\r\nidx++) {\r\nif (cpup->phys_id == i) {\r\nif (cpup->irq != LPFC_VECTOR_MAP_EMPTY) {\r\nchann[saved_chann] =\r\ncpup->channel_id;\r\nsaved_chann++;\r\ngoto out;\r\n}\r\nif (saved_chann == 0)\r\nsaved_chann =\r\nphba->cfg_fcp_io_channel;\r\ncpup->channel_id = chann[used_chann];\r\nnum_io_channel++;\r\nused_chann++;\r\nif (used_chann == saved_chann)\r\nused_chann = 0;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3331 Set IO_CHANN "\r\n"CPU %d channel %d\n",\r\nidx, cpup->channel_id);\r\n}\r\nout:\r\ncpu++;\r\nif (cpu >= phba->sli4_hba.num_present_cpu) {\r\ncpup = phba->sli4_hba.cpu_map;\r\ncpu = 0;\r\n} else {\r\ncpup++;\r\n}\r\n}\r\n}\r\nif (phba->sli4_hba.num_online_cpu != phba->sli4_hba.num_present_cpu) {\r\ncpup = phba->sli4_hba.cpu_map;\r\nfor (idx = 0; idx < phba->sli4_hba.num_present_cpu; idx++) {\r\nif (cpup->channel_id == LPFC_VECTOR_MAP_EMPTY) {\r\ncpup->channel_id = 0;\r\nnum_io_channel++;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3332 Assign IO_CHANN "\r\n"CPU %d channel %d\n",\r\nidx, cpup->channel_id);\r\n}\r\ncpup++;\r\n}\r\n}\r\nif (num_io_channel != phba->sli4_hba.num_present_cpu)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3333 Set affinity mismatch:"\r\n"%d chann != %d cpus: %d vectors\n",\r\nnum_io_channel, phba->sli4_hba.num_present_cpu,\r\nvectors);\r\nphba->cfg_fcp_io_sched = LPFC_FCP_SCHED_BY_CPU;\r\nreturn 1;\r\n}\r\nstatic int\r\nlpfc_sli4_enable_msix(struct lpfc_hba *phba)\r\n{\r\nint vectors, rc, index;\r\nfor (index = 0; index < phba->cfg_fcp_io_channel; index++)\r\nphba->sli4_hba.msix_entries[index].entry = index;\r\nvectors = phba->cfg_fcp_io_channel;\r\nif (phba->cfg_fof) {\r\nphba->sli4_hba.msix_entries[index].entry = index;\r\nvectors++;\r\n}\r\nrc = pci_enable_msix_range(phba->pcidev, phba->sli4_hba.msix_entries,\r\n2, vectors);\r\nif (rc < 0) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0484 PCI enable MSI-X failed (%d)\n", rc);\r\ngoto vec_fail_out;\r\n}\r\nvectors = rc;\r\nfor (index = 0; index < vectors; index++)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0489 MSI-X entry[%d]: vector=x%x "\r\n"message=%d\n", index,\r\nphba->sli4_hba.msix_entries[index].vector,\r\nphba->sli4_hba.msix_entries[index].entry);\r\nfor (index = 0; index < vectors; index++) {\r\nmemset(&phba->sli4_hba.handler_name[index], 0, 16);\r\nsnprintf((char *)&phba->sli4_hba.handler_name[index],\r\nLPFC_SLI4_HANDLER_NAME_SZ,\r\nLPFC_DRIVER_HANDLER_NAME"%d", index);\r\nphba->sli4_hba.fcp_eq_hdl[index].idx = index;\r\nphba->sli4_hba.fcp_eq_hdl[index].phba = phba;\r\natomic_set(&phba->sli4_hba.fcp_eq_hdl[index].fcp_eq_in_use, 1);\r\nif (phba->cfg_fof && (index == (vectors - 1)))\r\nrc = request_irq(\r\nphba->sli4_hba.msix_entries[index].vector,\r\n&lpfc_sli4_fof_intr_handler, 0,\r\n(char *)&phba->sli4_hba.handler_name[index],\r\n&phba->sli4_hba.fcp_eq_hdl[index]);\r\nelse\r\nrc = request_irq(\r\nphba->sli4_hba.msix_entries[index].vector,\r\n&lpfc_sli4_hba_intr_handler, 0,\r\n(char *)&phba->sli4_hba.handler_name[index],\r\n&phba->sli4_hba.fcp_eq_hdl[index]);\r\nif (rc) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0486 MSI-X fast-path (%d) "\r\n"request_irq failed (%d)\n", index, rc);\r\ngoto cfg_fail_out;\r\n}\r\n}\r\nif (phba->cfg_fof)\r\nvectors--;\r\nif (vectors != phba->cfg_fcp_io_channel) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3238 Reducing IO channels to match number of "\r\n"MSI-X vectors, requested %d got %d\n",\r\nphba->cfg_fcp_io_channel, vectors);\r\nphba->cfg_fcp_io_channel = vectors;\r\n}\r\nif (!shost_use_blk_mq(lpfc_shost_from_vport(phba->pport)))\r\nlpfc_sli4_set_affinity(phba, vectors);\r\nreturn rc;\r\ncfg_fail_out:\r\nfor (--index; index >= 0; index--) {\r\nirq_set_affinity_hint(phba->sli4_hba.msix_entries[index].\r\nvector, NULL);\r\nfree_irq(phba->sli4_hba.msix_entries[index].vector,\r\n&phba->sli4_hba.fcp_eq_hdl[index]);\r\n}\r\npci_disable_msix(phba->pcidev);\r\nvec_fail_out:\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_sli4_disable_msix(struct lpfc_hba *phba)\r\n{\r\nint index;\r\nfor (index = 0; index < phba->cfg_fcp_io_channel; index++) {\r\nirq_set_affinity_hint(phba->sli4_hba.msix_entries[index].\r\nvector, NULL);\r\nfree_irq(phba->sli4_hba.msix_entries[index].vector,\r\n&phba->sli4_hba.fcp_eq_hdl[index]);\r\n}\r\nif (phba->cfg_fof) {\r\nfree_irq(phba->sli4_hba.msix_entries[index].vector,\r\n&phba->sli4_hba.fcp_eq_hdl[index]);\r\n}\r\npci_disable_msix(phba->pcidev);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_sli4_enable_msi(struct lpfc_hba *phba)\r\n{\r\nint rc, index;\r\nrc = pci_enable_msi(phba->pcidev);\r\nif (!rc)\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0487 PCI enable MSI mode success.\n");\r\nelse {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0488 PCI enable MSI mode failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nrc = request_irq(phba->pcidev->irq, lpfc_sli4_intr_handler,\r\n0, LPFC_DRIVER_NAME, phba);\r\nif (rc) {\r\npci_disable_msi(phba->pcidev);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\r\n"0490 MSI request_irq failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nfor (index = 0; index < phba->cfg_fcp_io_channel; index++) {\r\nphba->sli4_hba.fcp_eq_hdl[index].idx = index;\r\nphba->sli4_hba.fcp_eq_hdl[index].phba = phba;\r\n}\r\nif (phba->cfg_fof) {\r\nphba->sli4_hba.fcp_eq_hdl[index].idx = index;\r\nphba->sli4_hba.fcp_eq_hdl[index].phba = phba;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli4_disable_msi(struct lpfc_hba *phba)\r\n{\r\nfree_irq(phba->pcidev->irq, phba);\r\npci_disable_msi(phba->pcidev);\r\nreturn;\r\n}\r\nstatic uint32_t\r\nlpfc_sli4_enable_intr(struct lpfc_hba *phba, uint32_t cfg_mode)\r\n{\r\nuint32_t intr_mode = LPFC_INTR_ERROR;\r\nint retval, index;\r\nif (cfg_mode == 2) {\r\nretval = 0;\r\nif (!retval) {\r\nretval = lpfc_sli4_enable_msix(phba);\r\nif (!retval) {\r\nphba->intr_type = MSIX;\r\nintr_mode = 2;\r\n}\r\n}\r\n}\r\nif (cfg_mode >= 1 && phba->intr_type == NONE) {\r\nretval = lpfc_sli4_enable_msi(phba);\r\nif (!retval) {\r\nphba->intr_type = MSI;\r\nintr_mode = 1;\r\n}\r\n}\r\nif (phba->intr_type == NONE) {\r\nretval = request_irq(phba->pcidev->irq, lpfc_sli4_intr_handler,\r\nIRQF_SHARED, LPFC_DRIVER_NAME, phba);\r\nif (!retval) {\r\nphba->intr_type = INTx;\r\nintr_mode = 0;\r\nfor (index = 0; index < phba->cfg_fcp_io_channel;\r\nindex++) {\r\nphba->sli4_hba.fcp_eq_hdl[index].idx = index;\r\nphba->sli4_hba.fcp_eq_hdl[index].phba = phba;\r\natomic_set(&phba->sli4_hba.fcp_eq_hdl[index].\r\nfcp_eq_in_use, 1);\r\n}\r\nif (phba->cfg_fof) {\r\nphba->sli4_hba.fcp_eq_hdl[index].idx = index;\r\nphba->sli4_hba.fcp_eq_hdl[index].phba = phba;\r\natomic_set(&phba->sli4_hba.fcp_eq_hdl[index].\r\nfcp_eq_in_use, 1);\r\n}\r\n}\r\n}\r\nreturn intr_mode;\r\n}\r\nstatic void\r\nlpfc_sli4_disable_intr(struct lpfc_hba *phba)\r\n{\r\nif (phba->intr_type == MSIX)\r\nlpfc_sli4_disable_msix(phba);\r\nelse if (phba->intr_type == MSI)\r\nlpfc_sli4_disable_msi(phba);\r\nelse if (phba->intr_type == INTx)\r\nfree_irq(phba->pcidev->irq, phba);\r\nphba->intr_type = NONE;\r\nphba->sli.slistat.sli_intr = 0;\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_unset_hba(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->load_flag |= FC_UNLOADING;\r\nspin_unlock_irq(shost->host_lock);\r\nkfree(phba->vpi_bmask);\r\nkfree(phba->vpi_ids);\r\nlpfc_stop_hba_timers(phba);\r\nphba->pport->work_port_events = 0;\r\nlpfc_sli_hba_down(phba);\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_sli_disable_intr(phba);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_sli4_xri_exchange_busy_wait(struct lpfc_hba *phba)\r\n{\r\nint wait_time = 0;\r\nint fcp_xri_cmpl = list_empty(&phba->sli4_hba.lpfc_abts_scsi_buf_list);\r\nint els_xri_cmpl = list_empty(&phba->sli4_hba.lpfc_abts_els_sgl_list);\r\nwhile (!fcp_xri_cmpl || !els_xri_cmpl) {\r\nif (wait_time > LPFC_XRI_EXCH_BUSY_WAIT_TMO) {\r\nif (!fcp_xri_cmpl)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2877 FCP XRI exchange busy "\r\n"wait time: %d seconds.\n",\r\nwait_time/1000);\r\nif (!els_xri_cmpl)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2878 ELS XRI exchange busy "\r\n"wait time: %d seconds.\n",\r\nwait_time/1000);\r\nmsleep(LPFC_XRI_EXCH_BUSY_WAIT_T2);\r\nwait_time += LPFC_XRI_EXCH_BUSY_WAIT_T2;\r\n} else {\r\nmsleep(LPFC_XRI_EXCH_BUSY_WAIT_T1);\r\nwait_time += LPFC_XRI_EXCH_BUSY_WAIT_T1;\r\n}\r\nfcp_xri_cmpl =\r\nlist_empty(&phba->sli4_hba.lpfc_abts_scsi_buf_list);\r\nels_xri_cmpl =\r\nlist_empty(&phba->sli4_hba.lpfc_abts_els_sgl_list);\r\n}\r\n}\r\nstatic void\r\nlpfc_sli4_hba_unset(struct lpfc_hba *phba)\r\n{\r\nint wait_cnt = 0;\r\nLPFC_MBOXQ_t *mboxq;\r\nstruct pci_dev *pdev = phba->pcidev;\r\nlpfc_stop_hba_timers(phba);\r\nphba->sli4_hba.intr_enable = 0;\r\nspin_lock_irq(&phba->hbalock);\r\nphba->sli.sli_flag |= LPFC_SLI_ASYNC_MBX_BLK;\r\nspin_unlock_irq(&phba->hbalock);\r\nwhile (phba->sli.sli_flag & LPFC_SLI_MBOX_ACTIVE) {\r\nmsleep(10);\r\nif (++wait_cnt > LPFC_ACTIVE_MBOX_WAIT_CNT)\r\nbreak;\r\n}\r\nif (phba->sli.sli_flag & LPFC_SLI_MBOX_ACTIVE) {\r\nspin_lock_irq(&phba->hbalock);\r\nmboxq = phba->sli.mbox_active;\r\nmboxq->u.mb.mbxStatus = MBX_NOT_FINISHED;\r\n__lpfc_mbox_cmpl_put(phba, mboxq);\r\nphba->sli.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;\r\nphba->sli.mbox_active = NULL;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nlpfc_sli_hba_iocb_abort(phba);\r\nlpfc_sli4_xri_exchange_busy_wait(phba);\r\nlpfc_sli4_disable_intr(phba);\r\nif (phba->cfg_sriov_nr_virtfn)\r\npci_disable_sriov(pdev);\r\nkthread_stop(phba->worker_thread);\r\nlpfc_pci_function_reset(phba);\r\nlpfc_sli4_queue_destroy(phba);\r\nphba->pport->work_port_events = 0;\r\n}\r\nint\r\nlpfc_pc_sli4_params_get(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\r\n{\r\nint rc;\r\nstruct lpfc_mqe *mqe;\r\nstruct lpfc_pc_sli4_params *sli4_params;\r\nuint32_t mbox_tmo;\r\nrc = 0;\r\nmqe = &mboxq->u.mqe;\r\nlpfc_pc_sli4_params(mboxq);\r\nif (!phba->sli4_hba.intr_enable)\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nelse {\r\nmbox_tmo = lpfc_mbox_tmo_val(phba, mboxq);\r\nrc = lpfc_sli_issue_mbox_wait(phba, mboxq, mbox_tmo);\r\n}\r\nif (unlikely(rc))\r\nreturn 1;\r\nsli4_params = &phba->sli4_hba.pc_sli4_params;\r\nsli4_params->if_type = bf_get(if_type, &mqe->un.sli4_params);\r\nsli4_params->sli_rev = bf_get(sli_rev, &mqe->un.sli4_params);\r\nsli4_params->sli_family = bf_get(sli_family, &mqe->un.sli4_params);\r\nsli4_params->featurelevel_1 = bf_get(featurelevel_1,\r\n&mqe->un.sli4_params);\r\nsli4_params->featurelevel_2 = bf_get(featurelevel_2,\r\n&mqe->un.sli4_params);\r\nsli4_params->proto_types = mqe->un.sli4_params.word3;\r\nsli4_params->sge_supp_len = mqe->un.sli4_params.sge_supp_len;\r\nsli4_params->if_page_sz = bf_get(if_page_sz, &mqe->un.sli4_params);\r\nsli4_params->rq_db_window = bf_get(rq_db_window, &mqe->un.sli4_params);\r\nsli4_params->loopbk_scope = bf_get(loopbk_scope, &mqe->un.sli4_params);\r\nsli4_params->eq_pages_max = bf_get(eq_pages, &mqe->un.sli4_params);\r\nsli4_params->eqe_size = bf_get(eqe_size, &mqe->un.sli4_params);\r\nsli4_params->cq_pages_max = bf_get(cq_pages, &mqe->un.sli4_params);\r\nsli4_params->cqe_size = bf_get(cqe_size, &mqe->un.sli4_params);\r\nsli4_params->mq_pages_max = bf_get(mq_pages, &mqe->un.sli4_params);\r\nsli4_params->mqe_size = bf_get(mqe_size, &mqe->un.sli4_params);\r\nsli4_params->mq_elem_cnt = bf_get(mq_elem_cnt, &mqe->un.sli4_params);\r\nsli4_params->wq_pages_max = bf_get(wq_pages, &mqe->un.sli4_params);\r\nsli4_params->wqe_size = bf_get(wqe_size, &mqe->un.sli4_params);\r\nsli4_params->rq_pages_max = bf_get(rq_pages, &mqe->un.sli4_params);\r\nsli4_params->rqe_size = bf_get(rqe_size, &mqe->un.sli4_params);\r\nsli4_params->hdr_pages_max = bf_get(hdr_pages, &mqe->un.sli4_params);\r\nsli4_params->hdr_size = bf_get(hdr_size, &mqe->un.sli4_params);\r\nsli4_params->hdr_pp_align = bf_get(hdr_pp_align, &mqe->un.sli4_params);\r\nsli4_params->sgl_pages_max = bf_get(sgl_pages, &mqe->un.sli4_params);\r\nsli4_params->sgl_pp_align = bf_get(sgl_pp_align, &mqe->un.sli4_params);\r\nif (sli4_params->sge_supp_len > LPFC_MAX_SGE_SIZE)\r\nsli4_params->sge_supp_len = LPFC_MAX_SGE_SIZE;\r\nreturn rc;\r\n}\r\nint\r\nlpfc_get_sli4_parameters(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\r\n{\r\nint rc;\r\nstruct lpfc_mqe *mqe = &mboxq->u.mqe;\r\nstruct lpfc_pc_sli4_params *sli4_params;\r\nuint32_t mbox_tmo;\r\nint length;\r\nstruct lpfc_sli4_parameters *mbx_sli4_parameters;\r\nphba->sli4_hba.rpi_hdrs_in_use = 1;\r\nlength = (sizeof(struct lpfc_mbx_get_sli4_parameters) -\r\nsizeof(struct lpfc_sli4_cfg_mhdr));\r\nlpfc_sli4_config(phba, mboxq, LPFC_MBOX_SUBSYSTEM_COMMON,\r\nLPFC_MBOX_OPCODE_GET_SLI4_PARAMETERS,\r\nlength, LPFC_SLI4_MBX_EMBED);\r\nif (!phba->sli4_hba.intr_enable)\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);\r\nelse {\r\nmbox_tmo = lpfc_mbox_tmo_val(phba, mboxq);\r\nrc = lpfc_sli_issue_mbox_wait(phba, mboxq, mbox_tmo);\r\n}\r\nif (unlikely(rc))\r\nreturn rc;\r\nsli4_params = &phba->sli4_hba.pc_sli4_params;\r\nmbx_sli4_parameters = &mqe->un.get_sli4_parameters.sli4_parameters;\r\nsli4_params->if_type = bf_get(cfg_if_type, mbx_sli4_parameters);\r\nsli4_params->sli_rev = bf_get(cfg_sli_rev, mbx_sli4_parameters);\r\nsli4_params->sli_family = bf_get(cfg_sli_family, mbx_sli4_parameters);\r\nsli4_params->featurelevel_1 = bf_get(cfg_sli_hint_1,\r\nmbx_sli4_parameters);\r\nsli4_params->featurelevel_2 = bf_get(cfg_sli_hint_2,\r\nmbx_sli4_parameters);\r\nif (bf_get(cfg_phwq, mbx_sli4_parameters))\r\nphba->sli3_options |= LPFC_SLI4_PHWQ_ENABLED;\r\nelse\r\nphba->sli3_options &= ~LPFC_SLI4_PHWQ_ENABLED;\r\nsli4_params->sge_supp_len = mbx_sli4_parameters->sge_supp_len;\r\nsli4_params->loopbk_scope = bf_get(loopbk_scope, mbx_sli4_parameters);\r\nsli4_params->oas_supported = bf_get(cfg_oas, mbx_sli4_parameters);\r\nsli4_params->cqv = bf_get(cfg_cqv, mbx_sli4_parameters);\r\nsli4_params->mqv = bf_get(cfg_mqv, mbx_sli4_parameters);\r\nsli4_params->wqv = bf_get(cfg_wqv, mbx_sli4_parameters);\r\nsli4_params->rqv = bf_get(cfg_rqv, mbx_sli4_parameters);\r\nsli4_params->wqsize = bf_get(cfg_wqsize, mbx_sli4_parameters);\r\nsli4_params->sgl_pages_max = bf_get(cfg_sgl_page_cnt,\r\nmbx_sli4_parameters);\r\nsli4_params->sgl_pp_align = bf_get(cfg_sgl_pp_align,\r\nmbx_sli4_parameters);\r\nphba->sli4_hba.extents_in_use = bf_get(cfg_ext, mbx_sli4_parameters);\r\nphba->sli4_hba.rpi_hdrs_in_use = bf_get(cfg_hdrr, mbx_sli4_parameters);\r\nif (sli4_params->sge_supp_len > LPFC_MAX_SGE_SIZE)\r\nsli4_params->sge_supp_len = LPFC_MAX_SGE_SIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_pci_probe_one_s3(struct pci_dev *pdev, const struct pci_device_id *pid)\r\n{\r\nstruct lpfc_hba *phba;\r\nstruct lpfc_vport *vport = NULL;\r\nstruct Scsi_Host *shost = NULL;\r\nint error;\r\nuint32_t cfg_mode, intr_mode;\r\nphba = lpfc_hba_alloc(pdev);\r\nif (!phba)\r\nreturn -ENOMEM;\r\nerror = lpfc_enable_pci_dev(phba);\r\nif (error)\r\ngoto out_free_phba;\r\nerror = lpfc_api_table_setup(phba, LPFC_PCI_DEV_LP);\r\nif (error)\r\ngoto out_disable_pci_dev;\r\nerror = lpfc_sli_pci_mem_setup(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1402 Failed to set up pci memory space.\n");\r\ngoto out_disable_pci_dev;\r\n}\r\nerror = lpfc_setup_driver_resource_phase1(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1403 Failed to set up driver resource.\n");\r\ngoto out_unset_pci_mem_s3;\r\n}\r\nerror = lpfc_sli_driver_resource_setup(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1404 Failed to set up driver resource.\n");\r\ngoto out_unset_pci_mem_s3;\r\n}\r\nerror = lpfc_init_iocb_list(phba, LPFC_IOCB_LIST_CNT);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1405 Failed to initialize iocb list.\n");\r\ngoto out_unset_driver_resource_s3;\r\n}\r\nerror = lpfc_setup_driver_resource_phase2(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1406 Failed to set up driver resource.\n");\r\ngoto out_free_iocb_list;\r\n}\r\nlpfc_get_hba_model_desc(phba, phba->ModelName, phba->ModelDesc);\r\nerror = lpfc_create_shost(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1407 Failed to create scsi host.\n");\r\ngoto out_unset_driver_resource;\r\n}\r\nvport = phba->pport;\r\nerror = lpfc_alloc_sysfs_attr(vport);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1476 Failed to allocate sysfs attr\n");\r\ngoto out_destroy_shost;\r\n}\r\nshost = lpfc_shost_from_vport(vport);\r\ncfg_mode = phba->cfg_use_msi;\r\nwhile (true) {\r\nlpfc_stop_port(phba);\r\nintr_mode = lpfc_sli_enable_intr(phba, cfg_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0431 Failed to enable interrupt.\n");\r\nerror = -ENODEV;\r\ngoto out_free_sysfs_attr;\r\n}\r\nif (lpfc_sli_hba_setup(phba)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1477 Failed to set up hba\n");\r\nerror = -ENODEV;\r\ngoto out_remove_device;\r\n}\r\nmsleep(50);\r\nif (intr_mode == 0 ||\r\nphba->sli.slistat.sli_intr > LPFC_MSIX_VECTORS) {\r\nphba->intr_mode = intr_mode;\r\nlpfc_log_intr_mode(phba, intr_mode);\r\nbreak;\r\n} else {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0447 Configure interrupt mode (%d) "\r\n"failed active interrupt test.\n",\r\nintr_mode);\r\nlpfc_sli_disable_intr(phba);\r\ncfg_mode = --intr_mode;\r\n}\r\n}\r\nlpfc_post_init_setup(phba);\r\nlpfc_create_static_vport(phba);\r\nreturn 0;\r\nout_remove_device:\r\nlpfc_unset_hba(phba);\r\nout_free_sysfs_attr:\r\nlpfc_free_sysfs_attr(vport);\r\nout_destroy_shost:\r\nlpfc_destroy_shost(phba);\r\nout_unset_driver_resource:\r\nlpfc_unset_driver_resource_phase2(phba);\r\nout_free_iocb_list:\r\nlpfc_free_iocb_list(phba);\r\nout_unset_driver_resource_s3:\r\nlpfc_sli_driver_resource_unset(phba);\r\nout_unset_pci_mem_s3:\r\nlpfc_sli_pci_mem_unset(phba);\r\nout_disable_pci_dev:\r\nlpfc_disable_pci_dev(phba);\r\nif (shost)\r\nscsi_host_put(shost);\r\nout_free_phba:\r\nlpfc_hba_free(phba);\r\nreturn error;\r\n}\r\nstatic void\r\nlpfc_pci_remove_one_s3(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_vport **vports;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint i;\r\nint bars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nspin_lock_irq(&phba->hbalock);\r\nvport->load_flag |= FC_UNLOADING;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_free_sysfs_attr(vport);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nif (vports[i]->port_type == LPFC_PHYSICAL_PORT)\r\ncontinue;\r\nfc_vport_terminate(vports[i]->fc_vport);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nfc_remove_host(shost);\r\nscsi_remove_host(shost);\r\nlpfc_cleanup(vport);\r\nlpfc_sli_hba_down(phba);\r\nkthread_stop(phba->worker_thread);\r\nlpfc_sli_brdrestart(phba);\r\nkfree(phba->vpi_bmask);\r\nkfree(phba->vpi_ids);\r\nlpfc_stop_hba_timers(phba);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_del_init(&vport->listentry);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_debugfs_terminate(vport);\r\nif (phba->cfg_sriov_nr_virtfn)\r\npci_disable_sriov(pdev);\r\nlpfc_sli_disable_intr(phba);\r\nscsi_host_put(shost);\r\nlpfc_scsi_free(phba);\r\nlpfc_mem_free_all(phba);\r\ndma_free_coherent(&pdev->dev, lpfc_sli_hbq_size(),\r\nphba->hbqslimp.virt, phba->hbqslimp.phys);\r\ndma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,\r\nphba->slim2p.virt, phba->slim2p.phys);\r\niounmap(phba->ctrl_regs_memmap_p);\r\niounmap(phba->slim_memmap_p);\r\nlpfc_hba_free(phba);\r\npci_release_selected_regions(pdev, bars);\r\npci_disable_device(pdev);\r\n}\r\nstatic int\r\nlpfc_pci_suspend_one_s3(struct pci_dev *pdev, pm_message_t msg)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0473 PCI device Power Management suspend.\n");\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nkthread_stop(phba->worker_thread);\r\nlpfc_sli_disable_intr(phba);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_pci_resume_one_s3(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nuint32_t intr_mode;\r\nint error;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0452 PCI device Power Management resume.\n");\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (pdev->is_busmaster)\r\npci_set_master(pdev);\r\nphba->worker_thread = kthread_run(lpfc_do_work, phba,\r\n"lpfc_worker_%d", phba->brd_no);\r\nif (IS_ERR(phba->worker_thread)) {\r\nerror = PTR_ERR(phba->worker_thread);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0434 PM resume failed to start worker "\r\n"thread: error=x%x.\n", error);\r\nreturn error;\r\n}\r\nintr_mode = lpfc_sli_enable_intr(phba, phba->intr_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0430 PM resume Failed to enable interrupt\n");\r\nreturn -EIO;\r\n} else\r\nphba->intr_mode = intr_mode;\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_online(phba);\r\nlpfc_log_intr_mode(phba, phba->intr_mode);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli_prep_dev_for_recover(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2723 PCI channel I/O abort preparing for recovery\n");\r\nlpfc_sli_abort_fcp_rings(phba);\r\n}\r\nstatic void\r\nlpfc_sli_prep_dev_for_reset(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2710 PCI channel disable preparing for reset\n");\r\nlpfc_block_mgmt_io(phba, LPFC_MBX_WAIT);\r\nlpfc_scsi_dev_block(phba);\r\nlpfc_sli_flush_fcp_rings(phba);\r\nlpfc_stop_hba_timers(phba);\r\nlpfc_sli_disable_intr(phba);\r\npci_disable_device(phba->pcidev);\r\n}\r\nstatic void\r\nlpfc_sli_prep_dev_for_perm_failure(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2711 PCI channel permanent disable for failure\n");\r\nlpfc_scsi_dev_block(phba);\r\nlpfc_stop_hba_timers(phba);\r\nlpfc_sli_flush_fcp_rings(phba);\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_error_detected_s3(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nswitch (state) {\r\ncase pci_channel_io_normal:\r\nlpfc_sli_prep_dev_for_recover(phba);\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\ncase pci_channel_io_frozen:\r\nlpfc_sli_prep_dev_for_reset(phba);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\ncase pci_channel_io_perm_failure:\r\nlpfc_sli_prep_dev_for_perm_failure(phba);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0472 Unknown PCI error state: x%x\n", state);\r\nlpfc_sli_prep_dev_for_reset(phba);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_slot_reset_s3(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nuint32_t intr_mode;\r\ndev_printk(KERN_INFO, &pdev->dev, "recovering from a slot reset.\n");\r\nif (pci_enable_device_mem(pdev)) {\r\nprintk(KERN_ERR "lpfc: Cannot re-enable "\r\n"PCI device after reset.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (pdev->is_busmaster)\r\npci_set_master(pdev);\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag &= ~LPFC_SLI_ACTIVE;\r\nspin_unlock_irq(&phba->hbalock);\r\nintr_mode = lpfc_sli_enable_intr(phba, phba->intr_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0427 Cannot re-enable interrupt after "\r\n"slot reset.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n} else\r\nphba->intr_mode = intr_mode;\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_log_intr_mode(phba, phba->intr_mode);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void\r\nlpfc_io_resume_s3(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nlpfc_online(phba);\r\nif (phba->hba_flag & HBA_AER_ENABLED)\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\n}\r\nint\r\nlpfc_sli4_get_els_iocb_cnt(struct lpfc_hba *phba)\r\n{\r\nint max_xri = phba->sli4_hba.max_cfg_param.max_xri;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nif (max_xri <= 100)\r\nreturn 10;\r\nelse if (max_xri <= 256)\r\nreturn 25;\r\nelse if (max_xri <= 512)\r\nreturn 50;\r\nelse if (max_xri <= 1024)\r\nreturn 100;\r\nelse if (max_xri <= 1536)\r\nreturn 150;\r\nelse if (max_xri <= 2048)\r\nreturn 200;\r\nelse\r\nreturn 250;\r\n} else\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_write_firmware(const struct firmware *fw, void *context)\r\n{\r\nstruct lpfc_hba *phba = (struct lpfc_hba *)context;\r\nchar fwrev[FW_REV_STR_SIZE];\r\nstruct lpfc_grp_hdr *image;\r\nstruct list_head dma_buffer_list;\r\nint i, rc = 0;\r\nstruct lpfc_dmabuf *dmabuf, *next;\r\nuint32_t offset = 0, temp_offset = 0;\r\nif (!fw) {\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\nimage = (struct lpfc_grp_hdr *)fw->data;\r\nINIT_LIST_HEAD(&dma_buffer_list);\r\nif ((be32_to_cpu(image->magic_number) != LPFC_GROUP_OJECT_MAGIC_NUM) ||\r\n(bf_get_be32(lpfc_grp_hdr_file_type, image) !=\r\nLPFC_FILE_TYPE_GROUP) ||\r\n(bf_get_be32(lpfc_grp_hdr_id, image) != LPFC_FILE_ID_GROUP) ||\r\n(be32_to_cpu(image->size) != fw->size)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3022 Invalid FW image found. "\r\n"Magic:%x Type:%x ID:%x\n",\r\nbe32_to_cpu(image->magic_number),\r\nbf_get_be32(lpfc_grp_hdr_file_type, image),\r\nbf_get_be32(lpfc_grp_hdr_id, image));\r\nrc = -EINVAL;\r\ngoto release_out;\r\n}\r\nlpfc_decode_firmware_rev(phba, fwrev, 1);\r\nif (strncmp(fwrev, image->revision, strnlen(image->revision, 16))) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3023 Updating Firmware, Current Version:%s "\r\n"New Version:%s\n",\r\nfwrev, image->revision);\r\nfor (i = 0; i < LPFC_MBX_WR_CONFIG_MAX_BDE; i++) {\r\ndmabuf = kzalloc(sizeof(struct lpfc_dmabuf),\r\nGFP_KERNEL);\r\nif (!dmabuf) {\r\nrc = -ENOMEM;\r\ngoto release_out;\r\n}\r\ndmabuf->virt = dma_alloc_coherent(&phba->pcidev->dev,\r\nSLI4_PAGE_SIZE,\r\n&dmabuf->phys,\r\nGFP_KERNEL);\r\nif (!dmabuf->virt) {\r\nkfree(dmabuf);\r\nrc = -ENOMEM;\r\ngoto release_out;\r\n}\r\nlist_add_tail(&dmabuf->list, &dma_buffer_list);\r\n}\r\nwhile (offset < fw->size) {\r\ntemp_offset = offset;\r\nlist_for_each_entry(dmabuf, &dma_buffer_list, list) {\r\nif (temp_offset + SLI4_PAGE_SIZE > fw->size) {\r\nmemcpy(dmabuf->virt,\r\nfw->data + temp_offset,\r\nfw->size - temp_offset);\r\ntemp_offset = fw->size;\r\nbreak;\r\n}\r\nmemcpy(dmabuf->virt, fw->data + temp_offset,\r\nSLI4_PAGE_SIZE);\r\ntemp_offset += SLI4_PAGE_SIZE;\r\n}\r\nrc = lpfc_wr_object(phba, &dma_buffer_list,\r\n(fw->size - offset), &offset);\r\nif (rc)\r\ngoto release_out;\r\n}\r\nrc = offset;\r\n}\r\nrelease_out:\r\nlist_for_each_entry_safe(dmabuf, next, &dma_buffer_list, list) {\r\nlist_del(&dmabuf->list);\r\ndma_free_coherent(&phba->pcidev->dev, SLI4_PAGE_SIZE,\r\ndmabuf->virt, dmabuf->phys);\r\nkfree(dmabuf);\r\n}\r\nrelease_firmware(fw);\r\nout:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3024 Firmware update done: %d.\n", rc);\r\nreturn;\r\n}\r\nint\r\nlpfc_sli4_request_firmware_update(struct lpfc_hba *phba, uint8_t fw_upgrade)\r\n{\r\nuint8_t file_name[ELX_MODEL_NAME_SIZE];\r\nint ret;\r\nconst struct firmware *fw;\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2)\r\nreturn -EPERM;\r\nsnprintf(file_name, ELX_MODEL_NAME_SIZE, "%s.grp", phba->ModelName);\r\nif (fw_upgrade == INT_FW_UPGRADE) {\r\nret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\nfile_name, &phba->pcidev->dev,\r\nGFP_KERNEL, (void *)phba,\r\nlpfc_write_firmware);\r\n} else if (fw_upgrade == RUN_FW_UPGRADE) {\r\nret = request_firmware(&fw, file_name, &phba->pcidev->dev);\r\nif (!ret)\r\nlpfc_write_firmware(fw, (void *)phba);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_pci_probe_one_s4(struct pci_dev *pdev, const struct pci_device_id *pid)\r\n{\r\nstruct lpfc_hba *phba;\r\nstruct lpfc_vport *vport = NULL;\r\nstruct Scsi_Host *shost = NULL;\r\nint error, ret;\r\nuint32_t cfg_mode, intr_mode;\r\nint adjusted_fcp_io_channel;\r\nphba = lpfc_hba_alloc(pdev);\r\nif (!phba)\r\nreturn -ENOMEM;\r\nerror = lpfc_enable_pci_dev(phba);\r\nif (error)\r\ngoto out_free_phba;\r\nerror = lpfc_api_table_setup(phba, LPFC_PCI_DEV_OC);\r\nif (error)\r\ngoto out_disable_pci_dev;\r\nerror = lpfc_sli4_pci_mem_setup(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1410 Failed to set up pci memory space.\n");\r\ngoto out_disable_pci_dev;\r\n}\r\nerror = lpfc_setup_driver_resource_phase1(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1411 Failed to set up driver resource.\n");\r\ngoto out_unset_pci_mem_s4;\r\n}\r\nerror = lpfc_sli4_driver_resource_setup(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1412 Failed to set up driver resource.\n");\r\ngoto out_unset_pci_mem_s4;\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2821 initialize iocb list %d.\n",\r\nphba->cfg_iocb_cnt*1024);\r\nerror = lpfc_init_iocb_list(phba, phba->cfg_iocb_cnt*1024);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1413 Failed to initialize iocb list.\n");\r\ngoto out_unset_driver_resource_s4;\r\n}\r\nINIT_LIST_HEAD(&phba->active_rrq_list);\r\nINIT_LIST_HEAD(&phba->fcf.fcf_pri_list);\r\nerror = lpfc_setup_driver_resource_phase2(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1414 Failed to set up driver resource.\n");\r\ngoto out_free_iocb_list;\r\n}\r\nlpfc_get_hba_model_desc(phba, phba->ModelName, phba->ModelDesc);\r\nerror = lpfc_create_shost(phba);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1415 Failed to create scsi host.\n");\r\ngoto out_unset_driver_resource;\r\n}\r\nvport = phba->pport;\r\nerror = lpfc_alloc_sysfs_attr(vport);\r\nif (error) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1416 Failed to allocate sysfs attr\n");\r\ngoto out_destroy_shost;\r\n}\r\nshost = lpfc_shost_from_vport(vport);\r\ncfg_mode = phba->cfg_use_msi;\r\nlpfc_stop_port(phba);\r\nintr_mode = lpfc_sli4_enable_intr(phba, cfg_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0426 Failed to enable interrupt.\n");\r\nerror = -ENODEV;\r\ngoto out_free_sysfs_attr;\r\n}\r\nif (phba->intr_type != MSIX)\r\nadjusted_fcp_io_channel = 1;\r\nelse\r\nadjusted_fcp_io_channel = phba->cfg_fcp_io_channel;\r\nphba->cfg_fcp_io_channel = adjusted_fcp_io_channel;\r\nif (lpfc_sli4_hba_setup(phba)) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1421 Failed to set up hba\n");\r\nerror = -ENODEV;\r\ngoto out_disable_intr;\r\n}\r\nphba->intr_mode = intr_mode;\r\nlpfc_log_intr_mode(phba, intr_mode);\r\nlpfc_post_init_setup(phba);\r\nif (phba->cfg_request_firmware_upgrade)\r\nret = lpfc_sli4_request_firmware_update(phba, INT_FW_UPGRADE);\r\nlpfc_create_static_vport(phba);\r\nreturn 0;\r\nout_disable_intr:\r\nlpfc_sli4_disable_intr(phba);\r\nout_free_sysfs_attr:\r\nlpfc_free_sysfs_attr(vport);\r\nout_destroy_shost:\r\nlpfc_destroy_shost(phba);\r\nout_unset_driver_resource:\r\nlpfc_unset_driver_resource_phase2(phba);\r\nout_free_iocb_list:\r\nlpfc_free_iocb_list(phba);\r\nout_unset_driver_resource_s4:\r\nlpfc_sli4_driver_resource_unset(phba);\r\nout_unset_pci_mem_s4:\r\nlpfc_sli4_pci_mem_unset(phba);\r\nout_disable_pci_dev:\r\nlpfc_disable_pci_dev(phba);\r\nif (shost)\r\nscsi_host_put(shost);\r\nout_free_phba:\r\nlpfc_hba_free(phba);\r\nreturn error;\r\n}\r\nstatic void\r\nlpfc_pci_remove_one_s4(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_vport **vports;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint i;\r\nspin_lock_irq(&phba->hbalock);\r\nvport->load_flag |= FC_UNLOADING;\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_free_sysfs_attr(vport);\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nif (vports[i]->port_type == LPFC_PHYSICAL_PORT)\r\ncontinue;\r\nfc_vport_terminate(vports[i]->fc_vport);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nfc_remove_host(shost);\r\nscsi_remove_host(shost);\r\nlpfc_cleanup(vport);\r\nlpfc_debugfs_terminate(vport);\r\nlpfc_sli4_hba_unset(phba);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_del_init(&vport->listentry);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_scsi_free(phba);\r\nlpfc_sli4_driver_resource_unset(phba);\r\nlpfc_sli4_pci_mem_unset(phba);\r\nscsi_host_put(shost);\r\nlpfc_disable_pci_dev(phba);\r\nlpfc_hba_free(phba);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_pci_suspend_one_s4(struct pci_dev *pdev, pm_message_t msg)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"2843 PCI device Power Management suspend.\n");\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nkthread_stop(phba->worker_thread);\r\nlpfc_sli4_disable_intr(phba);\r\nlpfc_sli4_queue_destroy(phba);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_pci_resume_one_s4(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nuint32_t intr_mode;\r\nint error;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"0292 PCI device Power Management resume.\n");\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (pdev->is_busmaster)\r\npci_set_master(pdev);\r\nphba->worker_thread = kthread_run(lpfc_do_work, phba,\r\n"lpfc_worker_%d", phba->brd_no);\r\nif (IS_ERR(phba->worker_thread)) {\r\nerror = PTR_ERR(phba->worker_thread);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0293 PM resume failed to start worker "\r\n"thread: error=x%x.\n", error);\r\nreturn error;\r\n}\r\nintr_mode = lpfc_sli4_enable_intr(phba, phba->intr_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0294 PM resume Failed to enable interrupt\n");\r\nreturn -EIO;\r\n} else\r\nphba->intr_mode = intr_mode;\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_online(phba);\r\nlpfc_log_intr_mode(phba, phba->intr_mode);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli4_prep_dev_for_recover(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2828 PCI channel I/O abort preparing for recovery\n");\r\nlpfc_sli_abort_fcp_rings(phba);\r\n}\r\nstatic void\r\nlpfc_sli4_prep_dev_for_reset(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2826 PCI channel disable preparing for reset\n");\r\nlpfc_block_mgmt_io(phba, LPFC_MBX_NO_WAIT);\r\nlpfc_scsi_dev_block(phba);\r\nlpfc_sli_flush_fcp_rings(phba);\r\nlpfc_stop_hba_timers(phba);\r\nlpfc_sli4_disable_intr(phba);\r\nlpfc_sli4_queue_destroy(phba);\r\npci_disable_device(phba->pcidev);\r\n}\r\nstatic void\r\nlpfc_sli4_prep_dev_for_perm_failure(struct lpfc_hba *phba)\r\n{\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2827 PCI channel permanent disable for failure\n");\r\nlpfc_scsi_dev_block(phba);\r\nlpfc_stop_hba_timers(phba);\r\nlpfc_sli_flush_fcp_rings(phba);\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_error_detected_s4(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nswitch (state) {\r\ncase pci_channel_io_normal:\r\nlpfc_sli4_prep_dev_for_recover(phba);\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\ncase pci_channel_io_frozen:\r\nlpfc_sli4_prep_dev_for_reset(phba);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\ncase pci_channel_io_perm_failure:\r\nlpfc_sli4_prep_dev_for_perm_failure(phba);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2825 Unknown PCI error state: x%x\n", state);\r\nlpfc_sli4_prep_dev_for_reset(phba);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_slot_reset_s4(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nuint32_t intr_mode;\r\ndev_printk(KERN_INFO, &pdev->dev, "recovering from a slot reset.\n");\r\nif (pci_enable_device_mem(pdev)) {\r\nprintk(KERN_ERR "lpfc: Cannot re-enable "\r\n"PCI device after reset.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (pdev->is_busmaster)\r\npci_set_master(pdev);\r\nspin_lock_irq(&phba->hbalock);\r\npsli->sli_flag &= ~LPFC_SLI_ACTIVE;\r\nspin_unlock_irq(&phba->hbalock);\r\nintr_mode = lpfc_sli4_enable_intr(phba, phba->intr_mode);\r\nif (intr_mode == LPFC_INTR_ERROR) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2824 Cannot re-enable interrupt after "\r\n"slot reset.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n} else\r\nphba->intr_mode = intr_mode;\r\nlpfc_log_intr_mode(phba, phba->intr_mode);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void\r\nlpfc_io_resume_s4(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nif (!(phba->sli.sli_flag & LPFC_SLI_ACTIVE)) {\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nlpfc_sli_brdrestart(phba);\r\nlpfc_online(phba);\r\n}\r\nif (phba->hba_flag & HBA_AER_ENABLED)\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\n}\r\nstatic int\r\nlpfc_pci_probe_one(struct pci_dev *pdev, const struct pci_device_id *pid)\r\n{\r\nint rc;\r\nstruct lpfc_sli_intf intf;\r\nif (pci_read_config_dword(pdev, LPFC_SLI_INTF, &intf.word0))\r\nreturn -ENODEV;\r\nif ((bf_get(lpfc_sli_intf_valid, &intf) == LPFC_SLI_INTF_VALID) &&\r\n(bf_get(lpfc_sli_intf_slirev, &intf) == LPFC_SLI_INTF_REV_SLI4))\r\nrc = lpfc_pci_probe_one_s4(pdev, pid);\r\nelse\r\nrc = lpfc_pci_probe_one_s3(pdev, pid);\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_pci_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nlpfc_pci_remove_one_s3(pdev);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nlpfc_pci_remove_one_s4(pdev);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1424 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_pci_suspend_one(struct pci_dev *pdev, pm_message_t msg)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nint rc = -ENODEV;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nrc = lpfc_pci_suspend_one_s3(pdev, msg);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nrc = lpfc_pci_suspend_one_s4(pdev, msg);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1425 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_pci_resume_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nint rc = -ENODEV;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nrc = lpfc_pci_resume_one_s3(pdev);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nrc = lpfc_pci_resume_one_s4(pdev);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1426 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\npci_ers_result_t rc = PCI_ERS_RESULT_DISCONNECT;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nrc = lpfc_io_error_detected_s3(pdev, state);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nrc = lpfc_io_error_detected_s4(pdev, state);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1427 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic pci_ers_result_t\r\nlpfc_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\npci_ers_result_t rc = PCI_ERS_RESULT_DISCONNECT;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nrc = lpfc_io_slot_reset_s3(pdev);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nrc = lpfc_io_slot_reset_s4(pdev);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1428 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nlpfc_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nswitch (phba->pci_dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nlpfc_io_resume_s3(pdev);\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nlpfc_io_resume_s4(pdev);\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1429 Invalid PCI device group: 0x%x\n",\r\nphba->pci_dev_grp);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_sli4_oas_verify(struct lpfc_hba *phba)\r\n{\r\nif (!phba->cfg_EnableXLane)\r\nreturn;\r\nif (phba->sli4_hba.pc_sli4_params.oas_supported) {\r\nphba->cfg_fof = 1;\r\n} else {\r\nphba->cfg_fof = 0;\r\nif (phba->device_data_mem_pool)\r\nmempool_destroy(phba->device_data_mem_pool);\r\nphba->device_data_mem_pool = NULL;\r\n}\r\nreturn;\r\n}\r\nint\r\nlpfc_fof_queue_setup(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nint rc;\r\nrc = lpfc_eq_create(phba, phba->sli4_hba.fof_eq, LPFC_MAX_IMAX);\r\nif (rc)\r\nreturn -ENOMEM;\r\nif (phba->cfg_fof) {\r\nrc = lpfc_cq_create(phba, phba->sli4_hba.oas_cq,\r\nphba->sli4_hba.fof_eq, LPFC_WCQ, LPFC_FCP);\r\nif (rc)\r\ngoto out_oas_cq;\r\nrc = lpfc_wq_create(phba, phba->sli4_hba.oas_wq,\r\nphba->sli4_hba.oas_cq, LPFC_FCP);\r\nif (rc)\r\ngoto out_oas_wq;\r\nphba->sli4_hba.oas_cq->pring = &psli->ring[LPFC_FCP_OAS_RING];\r\nphba->sli4_hba.oas_ring = &psli->ring[LPFC_FCP_OAS_RING];\r\n}\r\nreturn 0;\r\nout_oas_wq:\r\nlpfc_cq_destroy(phba, phba->sli4_hba.oas_cq);\r\nout_oas_cq:\r\nlpfc_eq_destroy(phba, phba->sli4_hba.fof_eq);\r\nreturn rc;\r\n}\r\nint\r\nlpfc_fof_queue_create(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_queue *qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.eq_esize,\r\nphba->sli4_hba.eq_ecount);\r\nif (!qdesc)\r\ngoto out_error;\r\nphba->sli4_hba.fof_eq = qdesc;\r\nif (phba->cfg_fof) {\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.cq_esize,\r\nphba->sli4_hba.cq_ecount);\r\nif (!qdesc)\r\ngoto out_error;\r\nphba->sli4_hba.oas_cq = qdesc;\r\nqdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.wq_esize,\r\nphba->sli4_hba.wq_ecount);\r\nif (!qdesc)\r\ngoto out_error;\r\nphba->sli4_hba.oas_wq = qdesc;\r\n}\r\nreturn 0;\r\nout_error:\r\nlpfc_fof_queue_destroy(phba);\r\nreturn -ENOMEM;\r\n}\r\nint\r\nlpfc_fof_queue_destroy(struct lpfc_hba *phba)\r\n{\r\nif (phba->sli4_hba.fof_eq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.fof_eq);\r\nphba->sli4_hba.fof_eq = NULL;\r\n}\r\nif (phba->sli4_hba.oas_cq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.oas_cq);\r\nphba->sli4_hba.oas_cq = NULL;\r\n}\r\nif (phba->sli4_hba.oas_wq != NULL) {\r\nlpfc_sli4_queue_free(phba->sli4_hba.oas_wq);\r\nphba->sli4_hba.oas_wq = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlpfc_init(void)\r\n{\r\nint cpu;\r\nint error = 0;\r\nprintk(LPFC_MODULE_DESC "\n");\r\nprintk(LPFC_COPYRIGHT "\n");\r\nerror = misc_register(&lpfc_mgmt_dev);\r\nif (error)\r\nprintk(KERN_ERR "Could not register lpfcmgmt device, "\r\n"misc_register returned with status %d", error);\r\nif (lpfc_enable_npiv) {\r\nlpfc_transport_functions.vport_create = lpfc_vport_create;\r\nlpfc_transport_functions.vport_delete = lpfc_vport_delete;\r\n}\r\nlpfc_transport_template =\r\nfc_attach_transport(&lpfc_transport_functions);\r\nif (lpfc_transport_template == NULL)\r\nreturn -ENOMEM;\r\nif (lpfc_enable_npiv) {\r\nlpfc_vport_transport_template =\r\nfc_attach_transport(&lpfc_vport_transport_functions);\r\nif (lpfc_vport_transport_template == NULL) {\r\nfc_release_transport(lpfc_transport_template);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nlpfc_used_cpu = NULL;\r\nlpfc_present_cpu = 0;\r\nfor_each_present_cpu(cpu)\r\nlpfc_present_cpu++;\r\nerror = pci_register_driver(&lpfc_driver);\r\nif (error) {\r\nfc_release_transport(lpfc_transport_template);\r\nif (lpfc_enable_npiv)\r\nfc_release_transport(lpfc_vport_transport_template);\r\n}\r\nreturn error;\r\n}\r\nstatic void __exit\r\nlpfc_exit(void)\r\n{\r\nmisc_deregister(&lpfc_mgmt_dev);\r\npci_unregister_driver(&lpfc_driver);\r\nfc_release_transport(lpfc_transport_template);\r\nif (lpfc_enable_npiv)\r\nfc_release_transport(lpfc_vport_transport_template);\r\nif (_dump_buf_data) {\r\nprintk(KERN_ERR "9062 BLKGRD: freeing %lu pages for "\r\n"_dump_buf_data at 0x%p\n",\r\n(1L << _dump_buf_data_order), _dump_buf_data);\r\nfree_pages((unsigned long)_dump_buf_data, _dump_buf_data_order);\r\n}\r\nif (_dump_buf_dif) {\r\nprintk(KERN_ERR "9049 BLKGRD: freeing %lu pages for "\r\n"_dump_buf_dif at 0x%p\n",\r\n(1L << _dump_buf_dif_order), _dump_buf_dif);\r\nfree_pages((unsigned long)_dump_buf_dif, _dump_buf_dif_order);\r\n}\r\nkfree(lpfc_used_cpu);\r\n}
