static void appldata_timer_function(unsigned long data)\r\n{\r\nqueue_work(appldata_wq, (struct work_struct *) data);\r\n}\r\nstatic void appldata_work_fn(struct work_struct *work)\r\n{\r\nstruct list_head *lh;\r\nstruct appldata_ops *ops;\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nops->callback(ops->data);\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\n}\r\nint appldata_diag(char record_nr, u16 function, unsigned long buffer,\r\nu16 length, char *mod_lvl)\r\n{\r\nstruct appldata_product_id id = {\r\n.prod_nr = {0xD3, 0xC9, 0xD5, 0xE4,\r\n0xE7, 0xD2, 0xD9},\r\n.prod_fn = 0xD5D3,\r\n.version_nr = 0xF2F6,\r\n.release_nr = 0xF0F1,\r\n};\r\nid.record_nr = record_nr;\r\nid.mod_lvl = (mod_lvl[0]) << 8 | mod_lvl[1];\r\nreturn appldata_asm(&id, function, (void *) buffer, length);\r\n}\r\nstatic void __appldata_vtimer_setup(int cmd)\r\n{\r\nu64 timer_interval = (u64) appldata_interval * 1000 * TOD_MICRO;\r\nswitch (cmd) {\r\ncase APPLDATA_ADD_TIMER:\r\nif (appldata_timer_active)\r\nbreak;\r\nappldata_timer.expires = timer_interval;\r\nadd_virt_timer_periodic(&appldata_timer);\r\nappldata_timer_active = 1;\r\nbreak;\r\ncase APPLDATA_DEL_TIMER:\r\ndel_virt_timer(&appldata_timer);\r\nif (!appldata_timer_active)\r\nbreak;\r\nappldata_timer_active = 0;\r\nbreak;\r\ncase APPLDATA_MOD_TIMER:\r\nif (!appldata_timer_active)\r\nbreak;\r\nmod_virt_timer_periodic(&appldata_timer, timer_interval);\r\n}\r\n}\r\nstatic int\r\nappldata_timer_handler(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nunsigned int len;\r\nchar buf[2];\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (!write) {\r\nstrncpy(buf, appldata_timer_active ? "1\n" : "0\n",\r\nARRAY_SIZE(buf));\r\nlen = strnlen(buf, ARRAY_SIZE(buf));\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer, len > sizeof(buf) ? sizeof(buf) : len))\r\nreturn -EFAULT;\r\nspin_lock(&appldata_timer_lock);\r\nif (buf[0] == '1')\r\n__appldata_vtimer_setup(APPLDATA_ADD_TIMER);\r\nelse if (buf[0] == '0')\r\n__appldata_vtimer_setup(APPLDATA_DEL_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int\r\nappldata_interval_handler(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nunsigned int len;\r\nint interval;\r\nchar buf[16];\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (!write) {\r\nlen = sprintf(buf, "%i\n", appldata_interval);\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer, len > sizeof(buf) ? sizeof(buf) : len))\r\nreturn -EFAULT;\r\ninterval = 0;\r\nsscanf(buf, "%i", &interval);\r\nif (interval <= 0)\r\nreturn -EINVAL;\r\nspin_lock(&appldata_timer_lock);\r\nappldata_interval = interval;\r\n__appldata_vtimer_setup(APPLDATA_MOD_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int\r\nappldata_generic_handler(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct appldata_ops *ops = NULL, *tmp_ops;\r\nunsigned int len;\r\nint rc, found;\r\nchar buf[2];\r\nstruct list_head *lh;\r\nfound = 0;\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\ntmp_ops = list_entry(lh, struct appldata_ops, list);\r\nif (&tmp_ops->ctl_table[2] == ctl) {\r\nfound = 1;\r\n}\r\n}\r\nif (!found) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn -ENODEV;\r\n}\r\nops = ctl->data;\r\nif (!try_module_get(ops->owner)) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nmodule_put(ops->owner);\r\nreturn 0;\r\n}\r\nif (!write) {\r\nstrncpy(buf, ops->active ? "1\n" : "0\n", ARRAY_SIZE(buf));\r\nlen = strnlen(buf, ARRAY_SIZE(buf));\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len)) {\r\nmodule_put(ops->owner);\r\nreturn -EFAULT;\r\n}\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer,\r\nlen > sizeof(buf) ? sizeof(buf) : len)) {\r\nmodule_put(ops->owner);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&appldata_ops_mutex);\r\nif ((buf[0] == '1') && (ops->active == 0)) {\r\nif (!try_module_get(ops->owner)) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nmodule_put(ops->owner);\r\nreturn -ENODEV;\r\n}\r\nops->callback(ops->data);\r\nrc = appldata_diag(ops->record_nr,\r\nAPPLDATA_START_INTERVAL_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0) {\r\npr_err("Starting the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\nmodule_put(ops->owner);\r\n} else\r\nops->active = 1;\r\n} else if ((buf[0] == '0') && (ops->active == 1)) {\r\nops->active = 0;\r\nrc = appldata_diag(ops->record_nr, APPLDATA_STOP_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0)\r\npr_err("Stopping the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\nmodule_put(ops->owner);\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nmodule_put(ops->owner);\r\nreturn 0;\r\n}\r\nint appldata_register_ops(struct appldata_ops *ops)\r\n{\r\nif (ops->size > APPLDATA_MAX_REC_SIZE)\r\nreturn -EINVAL;\r\nops->ctl_table = kzalloc(4 * sizeof(struct ctl_table), GFP_KERNEL);\r\nif (!ops->ctl_table)\r\nreturn -ENOMEM;\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_add(&ops->list, &appldata_ops_list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nops->ctl_table[0].procname = appldata_proc_name;\r\nops->ctl_table[0].maxlen = 0;\r\nops->ctl_table[0].mode = S_IRUGO | S_IXUGO;\r\nops->ctl_table[0].child = &ops->ctl_table[2];\r\nops->ctl_table[2].procname = ops->name;\r\nops->ctl_table[2].mode = S_IRUGO | S_IWUSR;\r\nops->ctl_table[2].proc_handler = appldata_generic_handler;\r\nops->ctl_table[2].data = ops;\r\nops->sysctl_header = register_sysctl_table(ops->ctl_table);\r\nif (!ops->sysctl_header)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_del(&ops->list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nkfree(ops->ctl_table);\r\nreturn -ENOMEM;\r\n}\r\nvoid appldata_unregister_ops(struct appldata_ops *ops)\r\n{\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_del(&ops->list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nunregister_sysctl_table(ops->sysctl_header);\r\nkfree(ops->ctl_table);\r\n}\r\nstatic int appldata_freeze(struct device *dev)\r\n{\r\nstruct appldata_ops *ops;\r\nint rc;\r\nstruct list_head *lh;\r\nspin_lock(&appldata_timer_lock);\r\nif (appldata_timer_active) {\r\n__appldata_vtimer_setup(APPLDATA_DEL_TIMER);\r\nappldata_timer_suspended = 1;\r\n}\r\nspin_unlock(&appldata_timer_lock);\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nrc = appldata_diag(ops->record_nr, APPLDATA_STOP_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0)\r\npr_err("Stopping the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int appldata_restore(struct device *dev)\r\n{\r\nstruct appldata_ops *ops;\r\nint rc;\r\nstruct list_head *lh;\r\nspin_lock(&appldata_timer_lock);\r\nif (appldata_timer_suspended) {\r\n__appldata_vtimer_setup(APPLDATA_ADD_TIMER);\r\nappldata_timer_suspended = 0;\r\n}\r\nspin_unlock(&appldata_timer_lock);\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nops->callback(ops->data);\r\nrc = appldata_diag(ops->record_nr,\r\nAPPLDATA_START_INTERVAL_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0) {\r\npr_err("Starting the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\n}\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int appldata_thaw(struct device *dev)\r\n{\r\nreturn appldata_restore(dev);\r\n}\r\nstatic int __init appldata_init(void)\r\n{\r\nint rc;\r\ninit_virt_timer(&appldata_timer);\r\nappldata_timer.function = appldata_timer_function;\r\nappldata_timer.data = (unsigned long) &appldata_work;\r\nrc = platform_driver_register(&appldata_pdrv);\r\nif (rc)\r\nreturn rc;\r\nappldata_pdev = platform_device_register_simple("appldata", -1, NULL,\r\n0);\r\nif (IS_ERR(appldata_pdev)) {\r\nrc = PTR_ERR(appldata_pdev);\r\ngoto out_driver;\r\n}\r\nappldata_wq = create_singlethread_workqueue("appldata");\r\nif (!appldata_wq) {\r\nrc = -ENOMEM;\r\ngoto out_device;\r\n}\r\nappldata_sysctl_header = register_sysctl_table(appldata_dir_table);\r\nreturn 0;\r\nout_device:\r\nplatform_device_unregister(appldata_pdev);\r\nout_driver:\r\nplatform_driver_unregister(&appldata_pdrv);\r\nreturn rc;\r\n}
