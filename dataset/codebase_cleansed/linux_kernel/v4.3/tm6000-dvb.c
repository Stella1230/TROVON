static inline void print_err_status(struct tm6000_core *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ndprintk(dev, 1, "URB status %d [%s].\n",\r\nstatus, errmsg);\r\n} else {\r\ndprintk(dev, 1, "URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic void tm6000_urb_received(struct urb *urb)\r\n{\r\nint ret;\r\nstruct tm6000_core *dev = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nprint_err_status(dev, 0, urb->status);\r\n}\r\nif (urb->actual_length > 0)\r\ndvb_dmx_swfilter(&dev->dvb->demux, urb->transfer_buffer,\r\nurb->actual_length);\r\nif (dev->dvb->streams > 0) {\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tm6000: error %s\n", __func__);\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\n}\r\nstatic int tm6000_start_stream(struct tm6000_core *dev)\r\n{\r\nint ret;\r\nunsigned int pipe, size;\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nprintk(KERN_INFO "tm6000: got start stream request %s\n", __func__);\r\nif (dev->mode != TM6000_MODE_DIGITAL) {\r\ntm6000_init_digital_mode(dev);\r\ndev->mode = TM6000_MODE_DIGITAL;\r\n}\r\ndvb->bulk_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (dvb->bulk_urb == NULL) {\r\nprintk(KERN_ERR "tm6000: couldn't allocate urb\n");\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvbulkpipe(dev->udev, dev->bulk_in.endp->desc.bEndpointAddress\r\n& USB_ENDPOINT_NUMBER_MASK);\r\nsize = usb_maxpacket(dev->udev, pipe, usb_pipeout(pipe));\r\nsize = size * 15;\r\ndvb->bulk_urb->transfer_buffer = kzalloc(size, GFP_KERNEL);\r\nif (dvb->bulk_urb->transfer_buffer == NULL) {\r\nusb_free_urb(dvb->bulk_urb);\r\nprintk(KERN_ERR "tm6000: couldn't allocate transfer buffer!\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(dvb->bulk_urb, dev->udev, pipe,\r\ndvb->bulk_urb->transfer_buffer,\r\nsize,\r\ntm6000_urb_received, dev);\r\nret = usb_clear_halt(dev->udev, pipe);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tm6000: error %i in %s during pipe reset\n",\r\nret, __func__);\r\nreturn ret;\r\n} else\r\nprintk(KERN_ERR "tm6000: pipe resetted\n");\r\nret = usb_submit_urb(dvb->bulk_urb, GFP_ATOMIC);\r\nif (ret) {\r\nprintk(KERN_ERR "tm6000: submit of urb failed (error=%i)\n",\r\nret);\r\nkfree(dvb->bulk_urb->transfer_buffer);\r\nusb_free_urb(dvb->bulk_urb);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tm6000_stop_stream(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nif (dvb->bulk_urb) {\r\nprintk(KERN_INFO "urb killing\n");\r\nusb_kill_urb(dvb->bulk_urb);\r\nprintk(KERN_INFO "urb buffer free\n");\r\nkfree(dvb->bulk_urb->transfer_buffer);\r\nusb_free_urb(dvb->bulk_urb);\r\ndvb->bulk_urb = NULL;\r\n}\r\n}\r\nstatic int tm6000_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct tm6000_core *dev = demux->priv;\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nprintk(KERN_INFO "tm6000: got start feed request %s\n", __func__);\r\nmutex_lock(&dvb->mutex);\r\nif (dvb->streams == 0) {\r\ndvb->streams = 1;\r\ntm6000_start_stream(dev);\r\n} else\r\n++(dvb->streams);\r\nmutex_unlock(&dvb->mutex);\r\nreturn 0;\r\n}\r\nstatic int tm6000_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct tm6000_core *dev = demux->priv;\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nprintk(KERN_INFO "tm6000: got stop feed request %s\n", __func__);\r\nmutex_lock(&dvb->mutex);\r\nprintk(KERN_INFO "stream %#x\n", dvb->streams);\r\n--(dvb->streams);\r\nif (dvb->streams == 0) {\r\nprintk(KERN_INFO "stop stream\n");\r\ntm6000_stop_stream(dev);\r\n}\r\nmutex_unlock(&dvb->mutex);\r\nreturn 0;\r\n}\r\nstatic int tm6000_dvb_attach_frontend(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nif (dev->caps.has_zl10353) {\r\nstruct zl10353_config config = {\r\n.demod_address = dev->demod_addr,\r\n.no_tuner = 1,\r\n.parallel_ts = 1,\r\n.if2 = 45700,\r\n.disable_i2c_gate_ctrl = 1,\r\n};\r\ndvb->frontend = dvb_attach(zl10353_attach, &config,\r\n&dev->i2c_adap);\r\n} else {\r\nprintk(KERN_ERR "tm6000: no frontend defined for the device!\n");\r\nreturn -1;\r\n}\r\nreturn (!dvb->frontend) ? -1 : 0;\r\n}\r\nstatic int register_dvb(struct tm6000_core *dev)\r\n{\r\nint ret = -1;\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nmutex_init(&dvb->mutex);\r\ndvb->streams = 0;\r\nret = tm6000_dvb_attach_frontend(dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tm6000: couldn't attach the frontend!\n");\r\ngoto err;\r\n}\r\nret = dvb_register_adapter(&dvb->adapter, "Trident TVMaster 6000 DVB-T",\r\nTHIS_MODULE, &dev->udev->dev, adapter_nr);\r\ndvb->adapter.priv = dev;\r\nif (dvb->frontend) {\r\nswitch (dev->tuner_type) {\r\ncase TUNER_XC2028: {\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &dev->i2c_adap,\r\n.i2c_addr = dev->tuner_addr,\r\n};\r\ndvb->frontend->callback = tm6000_tuner_callback;\r\nret = dvb_register_frontend(&dvb->adapter, dvb->frontend);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"tm6000: couldn't register frontend\n");\r\ngoto adapter_err;\r\n}\r\nif (!dvb_attach(xc2028_attach, dvb->frontend, &cfg)) {\r\nprintk(KERN_ERR "tm6000: couldn't register "\r\n"frontend (xc3028)\n");\r\nret = -EINVAL;\r\ngoto frontend_err;\r\n}\r\nprintk(KERN_INFO "tm6000: XC2028/3028 asked to be "\r\n"attached to frontend!\n");\r\nbreak;\r\n}\r\ncase TUNER_XC5000: {\r\nstruct xc5000_config cfg = {\r\n.i2c_address = dev->tuner_addr,\r\n};\r\ndvb->frontend->callback = tm6000_xc5000_callback;\r\nret = dvb_register_frontend(&dvb->adapter, dvb->frontend);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"tm6000: couldn't register frontend\n");\r\ngoto adapter_err;\r\n}\r\nif (!dvb_attach(xc5000_attach, dvb->frontend, &dev->i2c_adap, &cfg)) {\r\nprintk(KERN_ERR "tm6000: couldn't register "\r\n"frontend (xc5000)\n");\r\nret = -EINVAL;\r\ngoto frontend_err;\r\n}\r\nprintk(KERN_INFO "tm6000: XC5000 asked to be "\r\n"attached to frontend!\n");\r\nbreak;\r\n}\r\n}\r\n} else\r\nprintk(KERN_ERR "tm6000: no frontend found\n");\r\ndvb->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING\r\n| DMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dev;\r\ndvb->demux.filternum = 8;\r\ndvb->demux.feednum = 8;\r\ndvb->demux.start_feed = tm6000_start_feed;\r\ndvb->demux.stop_feed = tm6000_stop_feed;\r\ndvb->demux.write_to_decoder = NULL;\r\nret = dvb_dmx_init(&dvb->demux);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tm6000: dvb_dmx_init failed (errno = %d)\n", ret);\r\ngoto frontend_err;\r\n}\r\ndvb->dmxdev.filternum = dev->dvb->demux.filternum;\r\ndvb->dmxdev.demux = &dev->dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nret = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "tm6000: dvb_dmxdev_init failed (errno = %d)\n", ret);\r\ngoto dvb_dmx_err;\r\n}\r\nreturn 0;\r\ndvb_dmx_err:\r\ndvb_dmx_release(&dvb->demux);\r\nfrontend_err:\r\nif (dvb->frontend) {\r\ndvb_unregister_frontend(dvb->frontend);\r\ndvb_frontend_detach(dvb->frontend);\r\n}\r\nadapter_err:\r\ndvb_unregister_adapter(&dvb->adapter);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void unregister_dvb(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dvb *dvb = dev->dvb;\r\nif (dvb->bulk_urb != NULL) {\r\nstruct urb *bulk_urb = dvb->bulk_urb;\r\nkfree(bulk_urb->transfer_buffer);\r\nbulk_urb->transfer_buffer = NULL;\r\nusb_unlink_urb(bulk_urb);\r\nusb_free_urb(bulk_urb);\r\n}\r\nif (dvb->frontend) {\r\ndvb_unregister_frontend(dvb->frontend);\r\ndvb_frontend_detach(dvb->frontend);\r\n}\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(&dvb->demux);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nmutex_destroy(&dvb->mutex);\r\n}\r\nstatic int dvb_init(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dvb *dvb;\r\nint rc;\r\nif (!dev)\r\nreturn 0;\r\nif (!dev->caps.has_dvb)\r\nreturn 0;\r\nif (dev->udev->speed == USB_SPEED_FULL) {\r\nprintk(KERN_INFO "This USB2.0 device cannot be run on a USB1.1 port. (it lacks a hardware PID filter)\n");\r\nreturn 0;\r\n}\r\ndvb = kzalloc(sizeof(struct tm6000_dvb), GFP_KERNEL);\r\nif (!dvb) {\r\nprintk(KERN_INFO "Cannot allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dvb = dvb;\r\nrc = register_dvb(dev);\r\nif (rc < 0) {\r\nkfree(dvb);\r\ndev->dvb = NULL;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_fini(struct tm6000_core *dev)\r\n{\r\nif (!dev)\r\nreturn 0;\r\nif (!dev->caps.has_dvb)\r\nreturn 0;\r\nif (dev->dvb) {\r\nunregister_dvb(dev);\r\nkfree(dev->dvb);\r\ndev->dvb = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init tm6000_dvb_register(void)\r\n{\r\nreturn tm6000_register_extension(&dvb_ops);\r\n}\r\nstatic void __exit tm6000_dvb_unregister(void)\r\n{\r\ntm6000_unregister_extension(&dvb_ops);\r\n}
