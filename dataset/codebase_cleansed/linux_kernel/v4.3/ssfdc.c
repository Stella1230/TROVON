static int get_chs(unsigned long size, unsigned short *cyl, unsigned char *head,\r\nunsigned char *sec)\r\n{\r\nint k;\r\nint found = 0;\r\nk = 0;\r\nwhile (chs_table[k].size > 0 && size > chs_table[k].size)\r\nk++;\r\nif (chs_table[k].size > 0) {\r\nif (cyl)\r\n*cyl = chs_table[k].cyl;\r\nif (head)\r\n*head = chs_table[k].head;\r\nif (sec)\r\n*sec = chs_table[k].sec;\r\nfound = 1;\r\n}\r\nreturn found;\r\n}\r\nstatic int get_valid_cis_sector(struct mtd_info *mtd)\r\n{\r\nint ret, k, cis_sector;\r\nsize_t retlen;\r\nloff_t offset;\r\nuint8_t *sect_buf;\r\ncis_sector = -1;\r\nsect_buf = kmalloc(SECTOR_SIZE, GFP_KERNEL);\r\nif (!sect_buf)\r\ngoto out;\r\nfor (k = 0, offset = 0; k < 4; k++, offset += mtd->erasesize) {\r\nif (mtd_block_isbad(mtd, offset)) {\r\nret = mtd_read(mtd, offset, SECTOR_SIZE, &retlen,\r\nsect_buf);\r\nif (ret < 0 || retlen != SECTOR_SIZE) {\r\nprintk(KERN_WARNING\r\n"SSFDC_RO:can't read CIS/IDI sector\n");\r\n} else if (!memcmp(sect_buf, cis_numbers,\r\nsizeof(cis_numbers))) {\r\ncis_sector = (int)(offset >> SECTOR_SHIFT);\r\n} else {\r\npr_debug("SSFDC_RO: CIS/IDI sector not found"\r\n" on %s (mtd%d)\n", mtd->name,\r\nmtd->index);\r\n}\r\nbreak;\r\n}\r\n}\r\nkfree(sect_buf);\r\nout:\r\nreturn cis_sector;\r\n}\r\nstatic int read_physical_sector(struct mtd_info *mtd, uint8_t *sect_buf,\r\nint sect_no)\r\n{\r\nint ret;\r\nsize_t retlen;\r\nloff_t offset = (loff_t)sect_no << SECTOR_SHIFT;\r\nret = mtd_read(mtd, offset, SECTOR_SIZE, &retlen, sect_buf);\r\nif (ret < 0 || retlen != SECTOR_SIZE)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int read_raw_oob(struct mtd_info *mtd, loff_t offs, uint8_t *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nops.mode = MTD_OPS_RAW;\r\nops.ooboffs = 0;\r\nops.ooblen = OOB_SIZE;\r\nops.oobbuf = buf;\r\nops.datbuf = NULL;\r\nret = mtd_read_oob(mtd, offs, &ops);\r\nif (ret < 0 || ops.oobretlen != OOB_SIZE)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int get_parity(int number, int size)\r\n{\r\nint k;\r\nint parity;\r\nparity = 1;\r\nfor (k = 0; k < size; k++) {\r\nparity += (number >> k);\r\nparity &= 1;\r\n}\r\nreturn parity;\r\n}\r\nstatic int get_logical_address(uint8_t *oob_buf)\r\n{\r\nint block_address, parity;\r\nint offset[2] = {6, 11};\r\nint j;\r\nint ok = 0;\r\nfor (j = 0; j < ARRAY_SIZE(offset); j++) {\r\nblock_address = ((int)oob_buf[offset[j]] << 8) |\r\noob_buf[offset[j]+1];\r\nif ((block_address & ~0x7FF) == 0x1000) {\r\nparity = block_address & 0x01;\r\nblock_address &= 0x7FF;\r\nblock_address >>= 1;\r\nif (get_parity(block_address, 10) != parity) {\r\npr_debug("SSFDC_RO: logical address field%d"\r\n"parity error(0x%04X)\n", j+1,\r\nblock_address);\r\n} else {\r\nok = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!ok)\r\nblock_address = -2;\r\npr_debug("SSFDC_RO: get_logical_address() %d\n",\r\nblock_address);\r\nreturn block_address;\r\n}\r\nstatic int build_logical_block_map(struct ssfdcr_record *ssfdc)\r\n{\r\nunsigned long offset;\r\nuint8_t oob_buf[OOB_SIZE];\r\nint ret, block_address, phys_block;\r\nstruct mtd_info *mtd = ssfdc->mbd.mtd;\r\npr_debug("SSFDC_RO: build_block_map() nblks=%d (%luK)\n",\r\nssfdc->map_len,\r\n(unsigned long)ssfdc->map_len * ssfdc->erase_size / 1024);\r\nfor (phys_block = ssfdc->cis_block + 1; phys_block < ssfdc->map_len;\r\nphys_block++) {\r\noffset = (unsigned long)phys_block * ssfdc->erase_size;\r\nif (mtd_block_isbad(mtd, offset))\r\ncontinue;\r\nret = read_raw_oob(mtd, offset, oob_buf);\r\nif (ret < 0) {\r\npr_debug("SSFDC_RO: mtd read_oob() failed at %lu\n",\r\noffset);\r\nreturn -1;\r\n}\r\nblock_address = get_logical_address(oob_buf);\r\nif (block_address >= 0 &&\r\nblock_address < MAX_LOGIC_BLK_PER_ZONE) {\r\nint zone_index;\r\nzone_index = phys_block / MAX_PHYS_BLK_PER_ZONE;\r\nblock_address += zone_index * MAX_LOGIC_BLK_PER_ZONE;\r\nssfdc->logic_block_map[block_address] =\r\n(unsigned short)phys_block;\r\npr_debug("SSFDC_RO: build_block_map() phys_block=%d,"\r\n"logic_block_addr=%d, zone=%d\n",\r\nphys_block, block_address, zone_index);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ssfdcr_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct ssfdcr_record *ssfdc;\r\nint cis_sector;\r\nif (!mtd_type_is_nand(mtd) || mtd->oobsize != OOB_SIZE ||\r\nmtd->size > UINT_MAX)\r\nreturn;\r\ncis_sector = get_valid_cis_sector(mtd);\r\nif (cis_sector == -1)\r\nreturn;\r\nssfdc = kzalloc(sizeof(struct ssfdcr_record), GFP_KERNEL);\r\nif (!ssfdc)\r\nreturn;\r\nssfdc->mbd.mtd = mtd;\r\nssfdc->mbd.devnum = -1;\r\nssfdc->mbd.tr = tr;\r\nssfdc->mbd.readonly = 1;\r\nssfdc->cis_block = cis_sector / (mtd->erasesize >> SECTOR_SHIFT);\r\nssfdc->erase_size = mtd->erasesize;\r\nssfdc->map_len = (u32)mtd->size / mtd->erasesize;\r\npr_debug("SSFDC_RO: cis_block=%d,erase_size=%d,map_len=%d,n_zones=%d\n",\r\nssfdc->cis_block, ssfdc->erase_size, ssfdc->map_len,\r\nDIV_ROUND_UP(ssfdc->map_len, MAX_PHYS_BLK_PER_ZONE));\r\nssfdc->heads = 16;\r\nssfdc->sectors = 32;\r\nget_chs(mtd->size, NULL, &ssfdc->heads, &ssfdc->sectors);\r\nssfdc->cylinders = (unsigned short)(((u32)mtd->size >> SECTOR_SHIFT) /\r\n((long)ssfdc->sectors * (long)ssfdc->heads));\r\npr_debug("SSFDC_RO: using C:%d H:%d S:%d == %ld sects\n",\r\nssfdc->cylinders, ssfdc->heads , ssfdc->sectors,\r\n(long)ssfdc->cylinders * (long)ssfdc->heads *\r\n(long)ssfdc->sectors);\r\nssfdc->mbd.size = (long)ssfdc->heads * (long)ssfdc->cylinders *\r\n(long)ssfdc->sectors;\r\nssfdc->logic_block_map = kmalloc(sizeof(ssfdc->logic_block_map[0]) *\r\nssfdc->map_len, GFP_KERNEL);\r\nif (!ssfdc->logic_block_map)\r\ngoto out_err;\r\nmemset(ssfdc->logic_block_map, 0xff, sizeof(ssfdc->logic_block_map[0]) *\r\nssfdc->map_len);\r\nif (build_logical_block_map(ssfdc) < 0)\r\ngoto out_err;\r\nif (add_mtd_blktrans_dev(&ssfdc->mbd))\r\ngoto out_err;\r\nprintk(KERN_INFO "SSFDC_RO: Found ssfdc%c on mtd%d (%s)\n",\r\nssfdc->mbd.devnum + 'a', mtd->index, mtd->name);\r\nreturn;\r\nout_err:\r\nkfree(ssfdc->logic_block_map);\r\nkfree(ssfdc);\r\n}\r\nstatic void ssfdcr_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\r\npr_debug("SSFDC_RO: remove_dev (i=%d)\n", dev->devnum);\r\ndel_mtd_blktrans_dev(dev);\r\nkfree(ssfdc->logic_block_map);\r\n}\r\nstatic int ssfdcr_readsect(struct mtd_blktrans_dev *dev,\r\nunsigned long logic_sect_no, char *buf)\r\n{\r\nstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\r\nint sectors_per_block, offset, block_address;\r\nsectors_per_block = ssfdc->erase_size >> SECTOR_SHIFT;\r\noffset = (int)(logic_sect_no % sectors_per_block);\r\nblock_address = (int)(logic_sect_no / sectors_per_block);\r\npr_debug("SSFDC_RO: ssfdcr_readsect(%lu) sec_per_blk=%d, ofst=%d,"\r\n" block_addr=%d\n", logic_sect_no, sectors_per_block, offset,\r\nblock_address);\r\nif (block_address >= ssfdc->map_len)\r\nBUG();\r\nblock_address = ssfdc->logic_block_map[block_address];\r\npr_debug("SSFDC_RO: ssfdcr_readsect() phys_block_addr=%d\n",\r\nblock_address);\r\nif (block_address < 0xffff) {\r\nunsigned long sect_no;\r\nsect_no = (unsigned long)block_address * sectors_per_block +\r\noffset;\r\npr_debug("SSFDC_RO: ssfdcr_readsect() phys_sect_no=%lu\n",\r\nsect_no);\r\nif (read_physical_sector(ssfdc->mbd.mtd, buf, sect_no) < 0)\r\nreturn -EIO;\r\n} else {\r\nmemset(buf, 0xff, SECTOR_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssfdcr_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\nstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\r\npr_debug("SSFDC_RO: ssfdcr_getgeo() C=%d, H=%d, S=%d\n",\r\nssfdc->cylinders, ssfdc->heads, ssfdc->sectors);\r\ngeo->heads = ssfdc->heads;\r\ngeo->sectors = ssfdc->sectors;\r\ngeo->cylinders = ssfdc->cylinders;\r\nreturn 0;\r\n}\r\nstatic int __init init_ssfdcr(void)\r\n{\r\nprintk(KERN_INFO "SSFDC read-only Flash Translation layer\n");\r\nreturn register_mtd_blktrans(&ssfdcr_tr);\r\n}\r\nstatic void __exit cleanup_ssfdcr(void)\r\n{\r\nderegister_mtd_blktrans(&ssfdcr_tr);\r\n}
