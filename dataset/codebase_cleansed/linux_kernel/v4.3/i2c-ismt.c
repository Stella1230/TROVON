static void __ismt_desc_dump(struct device *dev, const struct ismt_desc *desc)\r\n{\r\ndev_dbg(dev, "Descriptor struct: %p\n", desc);\r\ndev_dbg(dev, "\ttgtaddr_rw=0x%02X\n", desc->tgtaddr_rw);\r\ndev_dbg(dev, "\twr_len_cmd=0x%02X\n", desc->wr_len_cmd);\r\ndev_dbg(dev, "\trd_len= 0x%02X\n", desc->rd_len);\r\ndev_dbg(dev, "\tcontrol= 0x%02X\n", desc->control);\r\ndev_dbg(dev, "\tstatus= 0x%02X\n", desc->status);\r\ndev_dbg(dev, "\tretry= 0x%02X\n", desc->retry);\r\ndev_dbg(dev, "\trxbytes= 0x%02X\n", desc->rxbytes);\r\ndev_dbg(dev, "\ttxbytes= 0x%02X\n", desc->txbytes);\r\ndev_dbg(dev, "\tdptr_low= 0x%08X\n", desc->dptr_low);\r\ndev_dbg(dev, "\tdptr_high= 0x%08X\n", desc->dptr_high);\r\n}\r\nstatic void ismt_desc_dump(struct ismt_priv *priv)\r\n{\r\nstruct device *dev = &priv->pci_dev->dev;\r\nstruct ismt_desc *desc = &priv->hw[priv->head];\r\ndev_dbg(dev, "Dump of the descriptor struct: 0x%X\n", priv->head);\r\n__ismt_desc_dump(dev, desc);\r\n}\r\nstatic void ismt_gen_reg_dump(struct ismt_priv *priv)\r\n{\r\nstruct device *dev = &priv->pci_dev->dev;\r\ndev_dbg(dev, "Dump of the iSMT General Registers\n");\r\ndev_dbg(dev, " GCTRL.... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_GR_GCTRL,\r\nreadl(priv->smba + ISMT_GR_GCTRL));\r\ndev_dbg(dev, " SMTICL... : (0x%p)=0x%016llX\n",\r\npriv->smba + ISMT_GR_SMTICL,\r\n(long long unsigned int)readq(priv->smba + ISMT_GR_SMTICL));\r\ndev_dbg(dev, " ERRINTMSK : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_GR_ERRINTMSK,\r\nreadl(priv->smba + ISMT_GR_ERRINTMSK));\r\ndev_dbg(dev, " ERRAERMSK : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_GR_ERRAERMSK,\r\nreadl(priv->smba + ISMT_GR_ERRAERMSK));\r\ndev_dbg(dev, " ERRSTS... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_GR_ERRSTS,\r\nreadl(priv->smba + ISMT_GR_ERRSTS));\r\ndev_dbg(dev, " ERRINFO.. : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_GR_ERRINFO,\r\nreadl(priv->smba + ISMT_GR_ERRINFO));\r\n}\r\nstatic void ismt_mstr_reg_dump(struct ismt_priv *priv)\r\n{\r\nstruct device *dev = &priv->pci_dev->dev;\r\ndev_dbg(dev, "Dump of the iSMT Master Registers\n");\r\ndev_dbg(dev, " MDBA..... : (0x%p)=0x%016llX\n",\r\npriv->smba + ISMT_MSTR_MDBA,\r\n(long long unsigned int)readq(priv->smba + ISMT_MSTR_MDBA));\r\ndev_dbg(dev, " MCTRL.... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_MSTR_MCTRL,\r\nreadl(priv->smba + ISMT_MSTR_MCTRL));\r\ndev_dbg(dev, " MSTS..... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_MSTR_MSTS,\r\nreadl(priv->smba + ISMT_MSTR_MSTS));\r\ndev_dbg(dev, " MDS...... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_MSTR_MDS,\r\nreadl(priv->smba + ISMT_MSTR_MDS));\r\ndev_dbg(dev, " RPOLICY.. : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_MSTR_RPOLICY,\r\nreadl(priv->smba + ISMT_MSTR_RPOLICY));\r\ndev_dbg(dev, " SPGT..... : (0x%p)=0x%X\n",\r\npriv->smba + ISMT_SPGT,\r\nreadl(priv->smba + ISMT_SPGT));\r\n}\r\nstatic void ismt_submit_desc(struct ismt_priv *priv)\r\n{\r\nuint fmhp;\r\nuint val;\r\nismt_desc_dump(priv);\r\nismt_gen_reg_dump(priv);\r\nismt_mstr_reg_dump(priv);\r\nfmhp = ((priv->head + 1) % ISMT_DESC_ENTRIES) << 16;\r\nval = readl(priv->smba + ISMT_MSTR_MCTRL);\r\nwritel((val & ~ISMT_MCTRL_FMHP) | fmhp,\r\npriv->smba + ISMT_MSTR_MCTRL);\r\nval = readl(priv->smba + ISMT_MSTR_MCTRL);\r\nwritel(val | ISMT_MCTRL_SS,\r\npriv->smba + ISMT_MSTR_MCTRL);\r\n}\r\nstatic int ismt_process_desc(const struct ismt_desc *desc,\r\nunion i2c_smbus_data *data,\r\nstruct ismt_priv *priv, int size,\r\nchar read_write)\r\n{\r\nu8 *dma_buffer = priv->dma_buffer;\r\ndev_dbg(&priv->pci_dev->dev, "Processing completed descriptor\n");\r\n__ismt_desc_dump(&priv->pci_dev->dev, desc);\r\nif (desc->status & ISMT_DESC_SCS) {\r\nif (read_write == I2C_SMBUS_WRITE &&\r\nsize != I2C_SMBUS_PROC_CALL)\r\nreturn 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndata->byte = dma_buffer[0];\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\ndata->word = dma_buffer[0] | (dma_buffer[1] << 8);\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nmemcpy(&data->block[1], dma_buffer, desc->rxbytes);\r\ndata->block[0] = desc->rxbytes;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nif (likely(desc->status & ISMT_DESC_NAK))\r\nreturn -ENXIO;\r\nif (desc->status & ISMT_DESC_CRC)\r\nreturn -EBADMSG;\r\nif (desc->status & ISMT_DESC_COL)\r\nreturn -EAGAIN;\r\nif (desc->status & ISMT_DESC_LPR)\r\nreturn -EPROTO;\r\nif (desc->status & (ISMT_DESC_DLTO | ISMT_DESC_CLTO))\r\nreturn -ETIMEDOUT;\r\nreturn -EIO;\r\n}\r\nstatic int ismt_access(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nint ret;\r\nunsigned long time_left;\r\ndma_addr_t dma_addr = 0;\r\nu8 dma_size = 0;\r\nenum dma_data_direction dma_direction = 0;\r\nstruct ismt_desc *desc;\r\nstruct ismt_priv *priv = i2c_get_adapdata(adap);\r\nstruct device *dev = &priv->pci_dev->dev;\r\ndesc = &priv->hw[priv->head];\r\nmemset(priv->dma_buffer, 0, sizeof(priv->dma_buffer));\r\nmemset(desc, 0, sizeof(struct ismt_desc));\r\ndesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\r\nif (likely(priv->using_msi))\r\ndesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\r\nelse\r\ndesc->control = ISMT_DESC_FAIR;\r\nif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\r\n&& (size != I2C_SMBUS_I2C_BLOCK_DATA))\r\ndesc->control |= ISMT_DESC_PEC;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\ndev_dbg(dev, "I2C_SMBUS_QUICK\n");\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\ndev_dbg(dev, "I2C_SMBUS_BYTE: WRITE\n");\r\ndesc->control |= ISMT_DESC_CWRL;\r\ndesc->wr_len_cmd = command;\r\n} else {\r\ndev_dbg(dev, "I2C_SMBUS_BYTE: READ\n");\r\ndma_size = 1;\r\ndma_direction = DMA_FROM_DEVICE;\r\ndesc->rd_len = 1;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\ndev_dbg(dev, "I2C_SMBUS_BYTE_DATA: WRITE\n");\r\ndesc->wr_len_cmd = 2;\r\ndma_size = 2;\r\ndma_direction = DMA_TO_DEVICE;\r\npriv->dma_buffer[0] = command;\r\npriv->dma_buffer[1] = data->byte;\r\n} else {\r\ndev_dbg(dev, "I2C_SMBUS_BYTE_DATA: READ\n");\r\ndesc->control |= ISMT_DESC_CWRL;\r\ndesc->wr_len_cmd = command;\r\ndesc->rd_len = 1;\r\ndma_size = 1;\r\ndma_direction = DMA_FROM_DEVICE;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\ndev_dbg(dev, "I2C_SMBUS_WORD_DATA: WRITE\n");\r\ndesc->wr_len_cmd = 3;\r\ndma_size = 3;\r\ndma_direction = DMA_TO_DEVICE;\r\npriv->dma_buffer[0] = command;\r\npriv->dma_buffer[1] = data->word & 0xff;\r\npriv->dma_buffer[2] = data->word >> 8;\r\n} else {\r\ndev_dbg(dev, "I2C_SMBUS_WORD_DATA: READ\n");\r\ndesc->wr_len_cmd = command;\r\ndesc->control |= ISMT_DESC_CWRL;\r\ndesc->rd_len = 2;\r\ndma_size = 2;\r\ndma_direction = DMA_FROM_DEVICE;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\ndev_dbg(dev, "I2C_SMBUS_PROC_CALL\n");\r\ndesc->wr_len_cmd = 3;\r\ndesc->rd_len = 2;\r\ndma_size = 3;\r\ndma_direction = DMA_BIDIRECTIONAL;\r\npriv->dma_buffer[0] = command;\r\npriv->dma_buffer[1] = data->word & 0xff;\r\npriv->dma_buffer[2] = data->word >> 8;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\ndev_dbg(dev, "I2C_SMBUS_BLOCK_DATA: WRITE\n");\r\ndma_size = data->block[0] + 1;\r\ndma_direction = DMA_TO_DEVICE;\r\ndesc->wr_len_cmd = dma_size;\r\ndesc->control |= ISMT_DESC_BLK;\r\npriv->dma_buffer[0] = command;\r\nmemcpy(&priv->dma_buffer[1], &data->block[1], dma_size - 1);\r\n} else {\r\ndev_dbg(dev, "I2C_SMBUS_BLOCK_DATA: READ\n");\r\ndma_size = I2C_SMBUS_BLOCK_MAX;\r\ndma_direction = DMA_FROM_DEVICE;\r\ndesc->rd_len = dma_size;\r\ndesc->wr_len_cmd = command;\r\ndesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\r\n}\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (data->block[0] < 1)\r\ndata->block[0] = 1;\r\nif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\r\ndata->block[0] = I2C_SMBUS_BLOCK_MAX;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\ndev_dbg(dev, "I2C_SMBUS_I2C_BLOCK_DATA: WRITE\n");\r\ndma_size = data->block[0] + 1;\r\ndma_direction = DMA_TO_DEVICE;\r\ndesc->wr_len_cmd = dma_size;\r\ndesc->control |= ISMT_DESC_I2C;\r\npriv->dma_buffer[0] = command;\r\nmemcpy(&priv->dma_buffer[1], &data->block[1], dma_size - 1);\r\n} else {\r\ndev_dbg(dev, "I2C_SMBUS_I2C_BLOCK_DATA: READ\n");\r\ndma_size = data->block[0];\r\ndma_direction = DMA_FROM_DEVICE;\r\ndesc->rd_len = dma_size;\r\ndesc->wr_len_cmd = command;\r\ndesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\r\ndesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unsupported transaction %d\n",\r\nsize);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (dma_size != 0) {\r\ndev_dbg(dev, " dev=%p\n", dev);\r\ndev_dbg(dev, " data=%p\n", data);\r\ndev_dbg(dev, " dma_buffer=%p\n", priv->dma_buffer);\r\ndev_dbg(dev, " dma_size=%d\n", dma_size);\r\ndev_dbg(dev, " dma_direction=%d\n", dma_direction);\r\ndma_addr = dma_map_single(dev,\r\npriv->dma_buffer,\r\ndma_size,\r\ndma_direction);\r\nif (dma_mapping_error(dev, dma_addr)) {\r\ndev_err(dev, "Error in mapping dma buffer %p\n",\r\npriv->dma_buffer);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, " dma_addr = 0x%016llX\n",\r\n(unsigned long long)dma_addr);\r\ndesc->dptr_low = lower_32_bits(dma_addr);\r\ndesc->dptr_high = upper_32_bits(dma_addr);\r\n}\r\nreinit_completion(&priv->cmp);\r\nismt_submit_desc(priv);\r\ntime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\r\nif (dma_size != 0)\r\ndma_unmap_single(&adap->dev, dma_addr, dma_size, dma_direction);\r\nif (unlikely(!time_left)) {\r\ndev_err(dev, "completion wait timed out\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nret = ismt_process_desc(desc, data, priv, size, read_write);\r\nout:\r\npriv->head++;\r\npriv->head %= ISMT_DESC_ENTRIES;\r\nreturn ret;\r\n}\r\nstatic u32 ismt_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK |\r\nI2C_FUNC_SMBUS_PEC;\r\n}\r\nstatic irqreturn_t ismt_handle_isr(struct ismt_priv *priv)\r\n{\r\ncomplete(&priv->cmp);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ismt_do_interrupt(int vec, void *data)\r\n{\r\nu32 val;\r\nstruct ismt_priv *priv = data;\r\nval = readl(priv->smba + ISMT_MSTR_MSTS);\r\nif (!(val & (ISMT_MSTS_MIS | ISMT_MSTS_MEIS)))\r\nreturn IRQ_NONE;\r\nelse\r\nwritel(val | ISMT_MSTS_MIS | ISMT_MSTS_MEIS,\r\npriv->smba + ISMT_MSTR_MSTS);\r\nreturn ismt_handle_isr(priv);\r\n}\r\nstatic irqreturn_t ismt_do_msi_interrupt(int vec, void *data)\r\n{\r\nreturn ismt_handle_isr(data);\r\n}\r\nstatic void ismt_hw_init(struct ismt_priv *priv)\r\n{\r\nu32 val;\r\nstruct device *dev = &priv->pci_dev->dev;\r\nwriteq(priv->io_rng_dma, priv->smba + ISMT_MSTR_MDBA);\r\nwritel(ISMT_MCTRL_MEIE, priv->smba + ISMT_MSTR_MCTRL);\r\nwritel(0, priv->smba + ISMT_MSTR_MSTS);\r\nval = readl(priv->smba + ISMT_MSTR_MDS);\r\nwritel((val & ~ISMT_MDS_MASK) | (ISMT_DESC_ENTRIES - 1),\r\npriv->smba + ISMT_MSTR_MDS);\r\nval = readl(priv->smba + ISMT_SPGT);\r\nswitch (bus_speed) {\r\ncase 0:\r\nbreak;\r\ncase 80:\r\ndev_dbg(dev, "Setting SMBus clock to 80 kHz\n");\r\nwritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_80K),\r\npriv->smba + ISMT_SPGT);\r\nbreak;\r\ncase 100:\r\ndev_dbg(dev, "Setting SMBus clock to 100 kHz\n");\r\nwritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_100K),\r\npriv->smba + ISMT_SPGT);\r\nbreak;\r\ncase 400:\r\ndev_dbg(dev, "Setting SMBus clock to 400 kHz\n");\r\nwritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_400K),\r\npriv->smba + ISMT_SPGT);\r\nbreak;\r\ncase 1000:\r\ndev_dbg(dev, "Setting SMBus clock to 1000 kHz\n");\r\nwritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_1M),\r\npriv->smba + ISMT_SPGT);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "Invalid SMBus clock speed, only 0, 80, 100, 400, and 1000 are valid\n");\r\nbreak;\r\n}\r\nval = readl(priv->smba + ISMT_SPGT);\r\nswitch (val & ISMT_SPGT_SPD_MASK) {\r\ncase ISMT_SPGT_SPD_80K:\r\nbus_speed = 80;\r\nbreak;\r\ncase ISMT_SPGT_SPD_100K:\r\nbus_speed = 100;\r\nbreak;\r\ncase ISMT_SPGT_SPD_400K:\r\nbus_speed = 400;\r\nbreak;\r\ncase ISMT_SPGT_SPD_1M:\r\nbus_speed = 1000;\r\nbreak;\r\n}\r\ndev_dbg(dev, "SMBus clock is running at %d kHz\n", bus_speed);\r\n}\r\nstatic int ismt_dev_init(struct ismt_priv *priv)\r\n{\r\npriv->hw = dmam_alloc_coherent(&priv->pci_dev->dev,\r\n(ISMT_DESC_ENTRIES\r\n* sizeof(struct ismt_desc)),\r\n&priv->io_rng_dma,\r\nGFP_KERNEL);\r\nif (!priv->hw)\r\nreturn -ENOMEM;\r\nmemset(priv->hw, 0, (ISMT_DESC_ENTRIES * sizeof(struct ismt_desc)));\r\npriv->head = 0;\r\ninit_completion(&priv->cmp);\r\nreturn 0;\r\n}\r\nstatic int ismt_int_init(struct ismt_priv *priv)\r\n{\r\nint err;\r\nerr = pci_enable_msi(priv->pci_dev);\r\nif (err) {\r\ndev_warn(&priv->pci_dev->dev,\r\n"Unable to use MSI interrupts, falling back to legacy\n");\r\ngoto intx;\r\n}\r\nerr = devm_request_irq(&priv->pci_dev->dev,\r\npriv->pci_dev->irq,\r\nismt_do_msi_interrupt,\r\n0,\r\n"ismt-msi",\r\npriv);\r\nif (err) {\r\npci_disable_msi(priv->pci_dev);\r\ngoto intx;\r\n}\r\npriv->using_msi = true;\r\ngoto done;\r\nintx:\r\nerr = devm_request_irq(&priv->pci_dev->dev,\r\npriv->pci_dev->irq,\r\nismt_do_interrupt,\r\nIRQF_SHARED,\r\n"ismt-intx",\r\npriv);\r\nif (err) {\r\ndev_err(&priv->pci_dev->dev, "no usable interrupts\n");\r\nreturn -ENODEV;\r\n}\r\npriv->using_msi = false;\r\ndone:\r\nreturn 0;\r\n}\r\nstatic int\r\nismt_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint err;\r\nstruct ismt_priv *priv;\r\nunsigned long start, len;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, priv);\r\ni2c_set_adapdata(&priv->adapter, priv);\r\npriv->adapter.owner = THIS_MODULE;\r\npriv->adapter.class = I2C_CLASS_HWMON;\r\npriv->adapter.algo = &smbus_algorithm;\r\npriv->adapter.dev.parent = &pdev->dev;\r\npriv->adapter.retries = ISMT_MAX_RETRIES;\r\npriv->pci_dev = pdev;\r\nerr = pcim_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to enable SMBus PCI device (%d)\n",\r\nerr);\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\nstart = pci_resource_start(pdev, SMBBAR);\r\nlen = pci_resource_len(pdev, SMBBAR);\r\nif (!start || !len) {\r\ndev_err(&pdev->dev,\r\n"SMBus base address uninitialized, upgrade BIOS\n");\r\nreturn -ENODEV;\r\n}\r\nsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\r\n"SMBus iSMT adapter at %lx", start);\r\ndev_dbg(&priv->pci_dev->dev, " start=0x%lX\n", start);\r\ndev_dbg(&priv->pci_dev->dev, " len=0x%lX\n", len);\r\nerr = acpi_check_resource_conflict(&pdev->resource[SMBBAR]);\r\nif (err) {\r\ndev_err(&pdev->dev, "ACPI resource conflict!\n");\r\nreturn err;\r\n}\r\nerr = pci_request_region(pdev, SMBBAR, ismt_driver.name);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Failed to request SMBus region 0x%lx-0x%lx\n",\r\nstart, start + len);\r\nreturn err;\r\n}\r\npriv->smba = pcim_iomap(pdev, SMBBAR, len);\r\nif (!priv->smba) {\r\ndev_err(&pdev->dev, "Unable to ioremap SMBus BAR\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif ((pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) ||\r\n(pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)) != 0)) {\r\nif ((pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) ||\r\n(pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32)) != 0)) {\r\ndev_err(&pdev->dev, "pci_set_dma_mask fail %p\n",\r\npdev);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\n}\r\nerr = ismt_dev_init(priv);\r\nif (err)\r\ngoto fail;\r\nismt_hw_init(priv);\r\nerr = ismt_int_init(priv);\r\nif (err)\r\ngoto fail;\r\nerr = i2c_add_adapter(&priv->adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to add SMBus iSMT adapter\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\npci_release_region(pdev, SMBBAR);\r\nreturn err;\r\n}\r\nstatic void ismt_remove(struct pci_dev *pdev)\r\n{\r\nstruct ismt_priv *priv = pci_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adapter);\r\npci_release_region(pdev, SMBBAR);\r\n}\r\nstatic int ismt_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, mesg));\r\nreturn 0;\r\n}\r\nstatic int ismt_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn pci_enable_device(pdev);\r\n}
