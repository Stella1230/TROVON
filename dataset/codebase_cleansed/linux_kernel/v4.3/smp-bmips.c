static void __init bmips_smp_setup(void)\r\n{\r\nint i, cpu = 1, boot_cpu = 0;\r\nint cpu_hw_intr;\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\ncase CPU_BMIPS4380:\r\nclear_c0_brcm_cmt_ctrl(0x30);\r\nset_c0_brcm_config_0(0x30000);\r\nboot_cpu = !!(read_c0_brcm_cmt_local() & (1 << 31));\r\nif (boot_cpu == 0)\r\ncpu_hw_intr = 0x02;\r\nelse\r\ncpu_hw_intr = 0x1d;\r\nchange_c0_brcm_cmt_intr(0xf8018000,\r\n(cpu_hw_intr << 27) | (0x03 << 15));\r\nmax_cpus = 2;\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nset_c0_brcm_config(0x03 << 22);\r\nchange_c0_brcm_mode(0x1f << 27, 0x02 << 27);\r\nmax_cpus = (((read_c0_brcm_config() >> 6) & 0x03) + 1) << 1;\r\nfor (i = 0; i < max_cpus; i++) {\r\nwrite_c0_brcm_action(ACTION_CLR_IPI(i, 0));\r\nwrite_c0_brcm_action(ACTION_CLR_IPI(i, 1));\r\n}\r\nbreak;\r\ndefault:\r\nmax_cpus = 1;\r\n}\r\nif (!bmips_smp_enabled)\r\nmax_cpus = 1;\r\nif (!board_ebase_setup)\r\nboard_ebase_setup = &bmips_ebase_setup;\r\n__cpu_number_map[boot_cpu] = 0;\r\n__cpu_logical_map[0] = boot_cpu;\r\nfor (i = 0; i < max_cpus; i++) {\r\nif (i != boot_cpu) {\r\n__cpu_number_map[i] = cpu;\r\n__cpu_logical_map[cpu] = i;\r\ncpu++;\r\n}\r\nset_cpu_possible(i, 1);\r\nset_cpu_present(i, 1);\r\n}\r\n}\r\nstatic void bmips_prepare_cpus(unsigned int max_cpus)\r\n{\r\nirqreturn_t (*bmips_ipi_interrupt)(int irq, void *dev_id);\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\ncase CPU_BMIPS4380:\r\nbmips_ipi_interrupt = bmips43xx_ipi_interrupt;\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nbmips_ipi_interrupt = bmips5000_ipi_interrupt;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (request_irq(IPI0_IRQ, bmips_ipi_interrupt, IRQF_PERCPU,\r\n"smp_ipi0", NULL))\r\npanic("Can't request IPI0 interrupt");\r\nif (request_irq(IPI1_IRQ, bmips_ipi_interrupt, IRQF_PERCPU,\r\n"smp_ipi1", NULL))\r\npanic("Can't request IPI1 interrupt");\r\n}\r\nstatic void bmips_boot_secondary(int cpu, struct task_struct *idle)\r\n{\r\nbmips_smp_boot_sp = __KSTK_TOS(idle);\r\nbmips_smp_boot_gp = (unsigned long)task_thread_info(idle);\r\nmb();\r\npr_info("SMP: Booting CPU%d...\n", cpu);\r\nif (cpumask_test_cpu(cpu, &bmips_booted_mask)) {\r\nbmips_set_reset_vec(cpu, RESET_FROM_KSEG0);\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\ncase CPU_BMIPS4380:\r\nbmips43xx_send_ipi_single(cpu, 0);\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nbmips5000_send_ipi_single(cpu, 0);\r\nbreak;\r\n}\r\n} else {\r\nbmips_set_reset_vec(cpu, RESET_FROM_KSEG1);\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\ncase CPU_BMIPS4380:\r\nif (cpu_logical_map(cpu) == 1)\r\nset_c0_brcm_cmt_ctrl(0x01);\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nwrite_c0_brcm_action(ACTION_BOOT_THREAD(cpu));\r\nbreak;\r\n}\r\ncpumask_set_cpu(cpu, &bmips_booted_mask);\r\n}\r\n}\r\nstatic void bmips_init_secondary(void)\r\n{\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\ncase CPU_BMIPS4380:\r\nclear_c0_cause(smp_processor_id() ? C_SW1 : C_SW0);\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nwrite_c0_brcm_action(ACTION_CLR_IPI(smp_processor_id(), 0));\r\nbreak;\r\n}\r\n}\r\nstatic void bmips_smp_finish(void)\r\n{\r\npr_info("SMP: CPU%d is running\n", smp_processor_id());\r\nwrite_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);\r\nirq_enable_hazard();\r\nset_c0_status(IE_SW0 | IE_SW1 | bmips_tp1_irqs | IE_IRQ5 | ST0_IE);\r\nirq_enable_hazard();\r\n}\r\nstatic void bmips5000_send_ipi_single(int cpu, unsigned int action)\r\n{\r\nwrite_c0_brcm_action(ACTION_SET_IPI(cpu, action == SMP_CALL_FUNCTION));\r\n}\r\nstatic irqreturn_t bmips5000_ipi_interrupt(int irq, void *dev_id)\r\n{\r\nint action = irq - IPI0_IRQ;\r\nwrite_c0_brcm_action(ACTION_CLR_IPI(smp_processor_id(), action));\r\nif (action == 0)\r\nscheduler_ipi();\r\nelse\r\ngeneric_smp_call_function_interrupt();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bmips5000_send_ipi_mask(const struct cpumask *mask,\r\nunsigned int action)\r\n{\r\nunsigned int i;\r\nfor_each_cpu(i, mask)\r\nbmips5000_send_ipi_single(i, action);\r\n}\r\nstatic void bmips43xx_send_ipi_single(int cpu, unsigned int action)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipi_lock, flags);\r\nset_c0_cause(cpu ? C_SW1 : C_SW0);\r\nper_cpu(ipi_action_mask, cpu) |= action;\r\nirq_enable_hazard();\r\nspin_unlock_irqrestore(&ipi_lock, flags);\r\n}\r\nstatic irqreturn_t bmips43xx_ipi_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint action, cpu = irq - IPI0_IRQ;\r\nspin_lock_irqsave(&ipi_lock, flags);\r\naction = __this_cpu_read(ipi_action_mask);\r\nper_cpu(ipi_action_mask, cpu) = 0;\r\nclear_c0_cause(cpu ? C_SW1 : C_SW0);\r\nspin_unlock_irqrestore(&ipi_lock, flags);\r\nif (action & SMP_RESCHEDULE_YOURSELF)\r\nscheduler_ipi();\r\nif (action & SMP_CALL_FUNCTION)\r\ngeneric_smp_call_function_interrupt();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bmips43xx_send_ipi_mask(const struct cpumask *mask,\r\nunsigned int action)\r\n{\r\nunsigned int i;\r\nfor_each_cpu(i, mask)\r\nbmips43xx_send_ipi_single(i, action);\r\n}\r\nstatic int bmips_cpu_disable(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nif (cpu == 0)\r\nreturn -EBUSY;\r\npr_info("SMP: CPU%d is offline\n", cpu);\r\nset_cpu_online(cpu, false);\r\ncpumask_clear_cpu(cpu, &cpu_callin_map);\r\nclear_c0_status(IE_IRQ5);\r\nlocal_flush_tlb_all();\r\nlocal_flush_icache_range(0, ~0);\r\nreturn 0;\r\n}\r\nstatic void bmips_cpu_die(unsigned int cpu)\r\n{\r\n}\r\nvoid __ref play_dead(void)\r\n{\r\nidle_task_exit();\r\n_dma_cache_wback_inv(0, ~0);\r\nclear_c0_cause(CAUSEF_IV | C_SW0 | C_SW1);\r\nchange_c0_status(\r\nIE_IRQ5 | bmips_tp1_irqs | IE_SW0 | IE_SW1 | ST0_IE | ST0_BEV,\r\nIE_SW0 | IE_SW1 | ST0_IE | ST0_BEV);\r\nirq_disable_hazard();\r\n__asm__ __volatile__(\r\n" wait\n"\r\n" j bmips_secondary_reentry\n"\r\n: : : "memory");\r\n}\r\nstatic void bmips_wr_vec(unsigned long dst, char *start, char *end)\r\n{\r\nmemcpy((void *)dst, start, end - start);\r\ndma_cache_wback(dst, end - start);\r\nlocal_flush_icache_range(dst, dst + (end - start));\r\ninstruction_hazard();\r\n}\r\nstatic inline void bmips_nmi_handler_setup(void)\r\n{\r\nbmips_wr_vec(BMIPS_NMI_RESET_VEC, &bmips_reset_nmi_vec,\r\n&bmips_reset_nmi_vec_end);\r\nbmips_wr_vec(BMIPS_WARM_RESTART_VEC, &bmips_smp_int_vec,\r\n&bmips_smp_int_vec_end);\r\n}\r\nstatic void bmips_set_reset_vec_remote(void *vinfo)\r\n{\r\nstruct reset_vec_info *info = vinfo;\r\nint shift = info->cpu & 0x01 ? 16 : 0;\r\nu32 mask = ~(0xffff << shift), val = info->val >> 16;\r\npreempt_disable();\r\nif (smp_processor_id() > 0) {\r\nsmp_call_function_single(0, &bmips_set_reset_vec_remote,\r\ninfo, 1);\r\n} else {\r\nif (info->cpu & 0x02) {\r\nbmips_write_zscm_reg(0xa0, (val << 16) | val);\r\nbmips_read_zscm_reg(0xa0);\r\n} else {\r\nwrite_c0_brcm_bootvec((read_c0_brcm_bootvec() & mask) |\r\n(val << shift));\r\n}\r\n}\r\npreempt_enable();\r\n}\r\nstatic void bmips_set_reset_vec(int cpu, u32 val)\r\n{\r\nstruct reset_vec_info info;\r\nif (current_cpu_type() == CPU_BMIPS5000) {\r\ninfo.cpu = cpu;\r\ninfo.val = val;\r\nbmips_set_reset_vec_remote(&info);\r\n} else {\r\nvoid __iomem *cbr = BMIPS_GET_CBR();\r\nif (cpu == 0)\r\n__raw_writel(val, cbr + BMIPS_RELO_VECTOR_CONTROL_0);\r\nelse {\r\nif (current_cpu_type() != CPU_BMIPS4380)\r\nreturn;\r\n__raw_writel(val, cbr + BMIPS_RELO_VECTOR_CONTROL_1);\r\n}\r\n}\r\n__sync();\r\nback_to_back_c0_hazard();\r\n}\r\nvoid bmips_ebase_setup(void)\r\n{\r\nunsigned long new_ebase = ebase;\r\nBUG_ON(ebase != CKSEG0);\r\nswitch (current_cpu_type()) {\r\ncase CPU_BMIPS4350:\r\nset_uncached_handler(BMIPS_WARM_RESTART_VEC - CKSEG0,\r\n&bmips_smp_int_vec, 0x80);\r\n__sync();\r\nreturn;\r\ncase CPU_BMIPS3300:\r\ncase CPU_BMIPS4380:\r\nnew_ebase = 0x80000400;\r\nbmips_set_reset_vec(0, RESET_FROM_KSEG0);\r\nbreak;\r\ncase CPU_BMIPS5000:\r\nnew_ebase = 0x80001000;\r\nbmips_set_reset_vec(0, RESET_FROM_KSEG0);\r\nwrite_c0_ebase(new_ebase);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nboard_nmi_handler_setup = &bmips_nmi_handler_setup;\r\nebase = new_ebase;\r\n}\r\nasmlinkage void __weak plat_wired_tlb_setup(void)\r\n{\r\n}
