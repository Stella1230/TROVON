int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)\r\n{\r\nint err;\r\nif (!access_ok(VERIFY_WRITE, to, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nerr = __put_user(from->si_signo, &to->si_signo);\r\nerr |= __put_user(from->si_errno, &to->si_errno);\r\nerr |= __put_user((short)from->si_code, &to->si_code);\r\nif (from->si_code < 0)\r\nerr |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);\r\nelse {\r\nswitch (from->si_code >> 16) {\r\ncase __SI_TIMER >> 16:\r\nerr |= __put_user(from->si_tid, &to->si_tid);\r\nerr |= __put_user(from->si_overrun, &to->si_overrun);\r\nerr |= __put_user(from->si_int, &to->si_int);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nerr |= __put_user(from->si_utime, &to->si_utime);\r\nerr |= __put_user(from->si_stime, &to->si_stime);\r\nerr |= __put_user(from->si_status, &to->si_status);\r\ndefault:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nbreak;\r\ncase __SI_FAULT >> 16:\r\nerr |= __put_user(from->si_trapno, &to->si_trapno);\r\nerr |= __put_user((unsigned long)from->si_addr, &to->si_addr);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nerr |= __put_user(from->si_band, &to->si_band);\r\nerr |= __put_user(from->si_fd, &to->si_fd);\r\nbreak;\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nerr |= __put_user(from->si_int, &to->si_int);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)\r\n{\r\nif (!access_ok(VERIFY_WRITE, from, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nif (copy_from_user(to, from, 3*sizeof(int)) ||\r\ncopy_from_user(to->_sifields._pad, from->_sifields._pad,\r\nSI_PAD_SIZE))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid do_sigreturn32(struct pt_regs *regs)\r\n{\r\nstruct signal_frame32 __user *sf;\r\ncompat_uptr_t fpu_save;\r\ncompat_uptr_t rwin_save;\r\nunsigned int psr;\r\nunsigned pc, npc;\r\nsigset_t set;\r\ncompat_sigset_t seta;\r\nint err, i;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nsynchronize_user_stack();\r\nregs->u_regs[UREG_FP] &= 0x00000000ffffffffUL;\r\nsf = (struct signal_frame32 __user *) regs->u_regs[UREG_FP];\r\nif (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||\r\n(((unsigned long) sf) & 3))\r\ngoto segv;\r\nif (get_user(pc, &sf->info.si_regs.pc) ||\r\n__get_user(npc, &sf->info.si_regs.npc))\r\ngoto segv;\r\nif ((pc | npc) & 3)\r\ngoto segv;\r\nif (test_thread_flag(TIF_32BIT)) {\r\npc &= 0xffffffff;\r\nnpc &= 0xffffffff;\r\n}\r\nregs->tpc = pc;\r\nregs->tnpc = npc;\r\nerr = __get_user(regs->y, &sf->info.si_regs.y);\r\nerr |= __get_user(psr, &sf->info.si_regs.psr);\r\nfor (i = UREG_G1; i <= UREG_I7; i++)\r\nerr |= __get_user(regs->u_regs[i], &sf->info.si_regs.u_regs[i]);\r\nif ((psr & (PSR_VERS|PSR_IMPL)) == PSR_V8PLUS) {\r\nerr |= __get_user(i, &sf->v8plus.g_upper[0]);\r\nif (i == SIGINFO_EXTRA_V8PLUS_MAGIC) {\r\nunsigned long asi;\r\nfor (i = UREG_G1; i <= UREG_I7; i++)\r\nerr |= __get_user(((u32 *)regs->u_regs)[2*i], &sf->v8plus.g_upper[i]);\r\nerr |= __get_user(asi, &sf->v8plus.asi);\r\nregs->tstate &= ~TSTATE_ASI;\r\nregs->tstate |= ((asi & 0xffUL) << 24UL);\r\n}\r\n}\r\nregs->tstate &= ~(TSTATE_ICC|TSTATE_XCC);\r\nregs->tstate |= psr_to_tstate_icc(psr);\r\npt_regs_clear_syscall(regs);\r\nerr |= __get_user(fpu_save, &sf->fpu_save);\r\nif (!err && fpu_save)\r\nerr |= restore_fpu_state(regs, compat_ptr(fpu_save));\r\nerr |= __get_user(rwin_save, &sf->rwin_save);\r\nif (!err && rwin_save) {\r\nif (restore_rwin_state(compat_ptr(rwin_save)))\r\ngoto segv;\r\n}\r\nerr |= __get_user(seta.sig[0], &sf->info.si_mask);\r\nerr |= copy_from_user(&seta.sig[1], &sf->extramask,\r\n(_COMPAT_NSIG_WORDS - 1) * sizeof(unsigned int));\r\nif (err)\r\ngoto segv;\r\nset.sig[0] = seta.sig[0] + (((long)seta.sig[1]) << 32);\r\nset_current_blocked(&set);\r\nreturn;\r\nsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nasmlinkage void do_rt_sigreturn32(struct pt_regs *regs)\r\n{\r\nstruct rt_signal_frame32 __user *sf;\r\nunsigned int psr, pc, npc;\r\ncompat_uptr_t fpu_save;\r\ncompat_uptr_t rwin_save;\r\nsigset_t set;\r\ncompat_sigset_t seta;\r\nint err, i;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nsynchronize_user_stack();\r\nregs->u_regs[UREG_FP] &= 0x00000000ffffffffUL;\r\nsf = (struct rt_signal_frame32 __user *) regs->u_regs[UREG_FP];\r\nif (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||\r\n(((unsigned long) sf) & 3))\r\ngoto segv;\r\nif (get_user(pc, &sf->regs.pc) ||\r\n__get_user(npc, &sf->regs.npc))\r\ngoto segv;\r\nif ((pc | npc) & 3)\r\ngoto segv;\r\nif (test_thread_flag(TIF_32BIT)) {\r\npc &= 0xffffffff;\r\nnpc &= 0xffffffff;\r\n}\r\nregs->tpc = pc;\r\nregs->tnpc = npc;\r\nerr = __get_user(regs->y, &sf->regs.y);\r\nerr |= __get_user(psr, &sf->regs.psr);\r\nfor (i = UREG_G1; i <= UREG_I7; i++)\r\nerr |= __get_user(regs->u_regs[i], &sf->regs.u_regs[i]);\r\nif ((psr & (PSR_VERS|PSR_IMPL)) == PSR_V8PLUS) {\r\nerr |= __get_user(i, &sf->v8plus.g_upper[0]);\r\nif (i == SIGINFO_EXTRA_V8PLUS_MAGIC) {\r\nunsigned long asi;\r\nfor (i = UREG_G1; i <= UREG_I7; i++)\r\nerr |= __get_user(((u32 *)regs->u_regs)[2*i], &sf->v8plus.g_upper[i]);\r\nerr |= __get_user(asi, &sf->v8plus.asi);\r\nregs->tstate &= ~TSTATE_ASI;\r\nregs->tstate |= ((asi & 0xffUL) << 24UL);\r\n}\r\n}\r\nregs->tstate &= ~(TSTATE_ICC|TSTATE_XCC);\r\nregs->tstate |= psr_to_tstate_icc(psr);\r\npt_regs_clear_syscall(regs);\r\nerr |= __get_user(fpu_save, &sf->fpu_save);\r\nif (!err && fpu_save)\r\nerr |= restore_fpu_state(regs, compat_ptr(fpu_save));\r\nerr |= copy_from_user(&seta, &sf->mask, sizeof(compat_sigset_t));\r\nerr |= compat_restore_altstack(&sf->stack);\r\nif (err)\r\ngoto segv;\r\nerr |= __get_user(rwin_save, &sf->rwin_save);\r\nif (!err && rwin_save) {\r\nif (restore_rwin_state(compat_ptr(rwin_save)))\r\ngoto segv;\r\n}\r\nset.sig[0] = seta.sig[0] + (((long)seta.sig[1]) << 32);\r\nset_current_blocked(&set);\r\nreturn;\r\nsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic int invalid_frame_pointer(void __user *fp, int fplen)\r\n{\r\nif ((((unsigned long) fp) & 7) || ((unsigned long)fp) > 0x100000000ULL - fplen)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)\r\n{\r\nunsigned long sp;\r\nregs->u_regs[UREG_FP] &= 0x00000000ffffffffUL;\r\nsp = regs->u_regs[UREG_FP];\r\nif (on_sig_stack(sp) && !likely(on_sig_stack(sp - framesize)))\r\nreturn (void __user *) -1L;\r\nsp = sigsp(sp, ksig) - framesize;\r\nsp &= ~15UL;\r\nreturn (void __user *) sp;\r\n}\r\nstatic void flush_signal_insns(unsigned long address)\r\n{\r\nunsigned long pstate, paddr;\r\npte_t *ptep, pte;\r\npgd_t *pgdp;\r\npud_t *pudp;\r\npmd_t *pmdp;\r\nwmb();\r\n__asm__ __volatile__("rdpr %%pstate, %0" : "=r" (pstate));\r\n__asm__ __volatile__("wrpr %0, %1, %%pstate"\r\n: : "r" (pstate), "i" (PSTATE_IE));\r\npgdp = pgd_offset(current->mm, address);\r\nif (pgd_none(*pgdp))\r\ngoto out_irqs_on;\r\npudp = pud_offset(pgdp, address);\r\nif (pud_none(*pudp))\r\ngoto out_irqs_on;\r\npmdp = pmd_offset(pudp, address);\r\nif (pmd_none(*pmdp))\r\ngoto out_irqs_on;\r\nptep = pte_offset_map(pmdp, address);\r\npte = *ptep;\r\nif (!pte_present(pte))\r\ngoto out_unmap;\r\npaddr = (unsigned long) page_address(pte_page(pte));\r\n__asm__ __volatile__("flush %0 + %1"\r\n:\r\n: "r" (paddr),\r\n"r" (address & (PAGE_SIZE - 1))\r\n: "memory");\r\nout_unmap:\r\npte_unmap(ptep);\r\nout_irqs_on:\r\n__asm__ __volatile__("wrpr %0, 0x0, %%pstate" : : "r" (pstate));\r\n}\r\nstatic int setup_frame32(struct ksignal *ksig, struct pt_regs *regs,\r\nsigset_t *oldset)\r\n{\r\nstruct signal_frame32 __user *sf;\r\nint i, err, wsaved;\r\nvoid __user *tail;\r\nint sigframe_size;\r\nu32 psr;\r\ncompat_sigset_t seta;\r\nsynchronize_user_stack();\r\nsave_and_clear_fpu();\r\nwsaved = get_thread_wsaved();\r\nsigframe_size = sizeof(*sf);\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF)\r\nsigframe_size += sizeof(__siginfo_fpu_t);\r\nif (wsaved)\r\nsigframe_size += sizeof(__siginfo_rwin_t);\r\nsf = (struct signal_frame32 __user *)\r\nget_sigframe(ksig, regs, sigframe_size);\r\nif (invalid_frame_pointer(sf, sigframe_size)) {\r\ndo_exit(SIGILL);\r\nreturn -EINVAL;\r\n}\r\ntail = (sf + 1);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc &= 0xffffffff;\r\nregs->tnpc &= 0xffffffff;\r\n}\r\nerr = put_user(regs->tpc, &sf->info.si_regs.pc);\r\nerr |= __put_user(regs->tnpc, &sf->info.si_regs.npc);\r\nerr |= __put_user(regs->y, &sf->info.si_regs.y);\r\npsr = tstate_to_psr(regs->tstate);\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF)\r\npsr |= PSR_EF;\r\nerr |= __put_user(psr, &sf->info.si_regs.psr);\r\nfor (i = 0; i < 16; i++)\r\nerr |= __put_user(regs->u_regs[i], &sf->info.si_regs.u_regs[i]);\r\nerr |= __put_user(sizeof(siginfo_extra_v8plus_t), &sf->extra_size);\r\nerr |= __put_user(SIGINFO_EXTRA_V8PLUS_MAGIC, &sf->v8plus.g_upper[0]);\r\nfor (i = 1; i < 16; i++)\r\nerr |= __put_user(((u32 *)regs->u_regs)[2*i],\r\n&sf->v8plus.g_upper[i]);\r\nerr |= __put_user((regs->tstate & TSTATE_ASI) >> 24UL,\r\n&sf->v8plus.asi);\r\nif (psr & PSR_EF) {\r\n__siginfo_fpu_t __user *fp = tail;\r\ntail += sizeof(*fp);\r\nerr |= save_fpu_state(regs, fp);\r\nerr |= __put_user((u64)fp, &sf->fpu_save);\r\n} else {\r\nerr |= __put_user(0, &sf->fpu_save);\r\n}\r\nif (wsaved) {\r\n__siginfo_rwin_t __user *rwp = tail;\r\ntail += sizeof(*rwp);\r\nerr |= save_rwin_state(wsaved, rwp);\r\nerr |= __put_user((u64)rwp, &sf->rwin_save);\r\nset_thread_wsaved(0);\r\n} else {\r\nerr |= __put_user(0, &sf->rwin_save);\r\n}\r\nBUILD_BUG_ON(_NSIG_WORDS != 1);\r\nBUILD_BUG_ON(_COMPAT_NSIG_WORDS != 2);\r\nseta.sig[1] = (oldset->sig[0] >> 32);\r\nseta.sig[0] = oldset->sig[0];\r\nerr |= __put_user(seta.sig[0], &sf->info.si_mask);\r\nerr |= __copy_to_user(sf->extramask, &seta.sig[1],\r\n(_COMPAT_NSIG_WORDS - 1) * sizeof(unsigned int));\r\nif (!wsaved) {\r\nerr |= copy_in_user((u32 __user *)sf,\r\n(u32 __user *)(regs->u_regs[UREG_FP]),\r\nsizeof(struct reg_window32));\r\n} else {\r\nstruct reg_window *rp;\r\nrp = &current_thread_info()->reg_window[wsaved - 1];\r\nfor (i = 0; i < 8; i++)\r\nerr |= __put_user(rp->locals[i], &sf->ss.locals[i]);\r\nfor (i = 0; i < 6; i++)\r\nerr |= __put_user(rp->ins[i], &sf->ss.ins[i]);\r\nerr |= __put_user(rp->ins[6], &sf->ss.fp);\r\nerr |= __put_user(rp->ins[7], &sf->ss.callers_pc);\r\n}\r\nif (err)\r\nreturn err;\r\nregs->u_regs[UREG_FP] = (unsigned long) sf;\r\nregs->u_regs[UREG_I0] = ksig->sig;\r\nregs->u_regs[UREG_I1] = (unsigned long) &sf->info;\r\nregs->u_regs[UREG_I2] = (unsigned long) &sf->info;\r\nregs->tpc = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->tnpc = (regs->tpc + 4);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc &= 0xffffffff;\r\nregs->tnpc &= 0xffffffff;\r\n}\r\nif (ksig->ka.ka_restorer) {\r\nregs->u_regs[UREG_I7] = (unsigned long)ksig->ka.ka_restorer;\r\n} else {\r\nunsigned long address = ((unsigned long)&(sf->insns[0]));\r\nregs->u_regs[UREG_I7] = (unsigned long) (&(sf->insns[0]) - 2);\r\nerr = __put_user(0x821020d8, &sf->insns[0]);\r\nerr |= __put_user(0x91d02010, &sf->insns[1]);\r\nif (err)\r\nreturn err;\r\nflush_signal_insns(address);\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_rt_frame32(struct ksignal *ksig, struct pt_regs *regs,\r\nsigset_t *oldset)\r\n{\r\nstruct rt_signal_frame32 __user *sf;\r\nint i, err, wsaved;\r\nvoid __user *tail;\r\nint sigframe_size;\r\nu32 psr;\r\ncompat_sigset_t seta;\r\nsynchronize_user_stack();\r\nsave_and_clear_fpu();\r\nwsaved = get_thread_wsaved();\r\nsigframe_size = sizeof(*sf);\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF)\r\nsigframe_size += sizeof(__siginfo_fpu_t);\r\nif (wsaved)\r\nsigframe_size += sizeof(__siginfo_rwin_t);\r\nsf = (struct rt_signal_frame32 __user *)\r\nget_sigframe(ksig, regs, sigframe_size);\r\nif (invalid_frame_pointer(sf, sigframe_size)) {\r\ndo_exit(SIGILL);\r\nreturn -EINVAL;\r\n}\r\ntail = (sf + 1);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc &= 0xffffffff;\r\nregs->tnpc &= 0xffffffff;\r\n}\r\nerr = put_user(regs->tpc, &sf->regs.pc);\r\nerr |= __put_user(regs->tnpc, &sf->regs.npc);\r\nerr |= __put_user(regs->y, &sf->regs.y);\r\npsr = tstate_to_psr(regs->tstate);\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF)\r\npsr |= PSR_EF;\r\nerr |= __put_user(psr, &sf->regs.psr);\r\nfor (i = 0; i < 16; i++)\r\nerr |= __put_user(regs->u_regs[i], &sf->regs.u_regs[i]);\r\nerr |= __put_user(sizeof(siginfo_extra_v8plus_t), &sf->extra_size);\r\nerr |= __put_user(SIGINFO_EXTRA_V8PLUS_MAGIC, &sf->v8plus.g_upper[0]);\r\nfor (i = 1; i < 16; i++)\r\nerr |= __put_user(((u32 *)regs->u_regs)[2*i],\r\n&sf->v8plus.g_upper[i]);\r\nerr |= __put_user((regs->tstate & TSTATE_ASI) >> 24UL,\r\n&sf->v8plus.asi);\r\nif (psr & PSR_EF) {\r\n__siginfo_fpu_t __user *fp = tail;\r\ntail += sizeof(*fp);\r\nerr |= save_fpu_state(regs, fp);\r\nerr |= __put_user((u64)fp, &sf->fpu_save);\r\n} else {\r\nerr |= __put_user(0, &sf->fpu_save);\r\n}\r\nif (wsaved) {\r\n__siginfo_rwin_t __user *rwp = tail;\r\ntail += sizeof(*rwp);\r\nerr |= save_rwin_state(wsaved, rwp);\r\nerr |= __put_user((u64)rwp, &sf->rwin_save);\r\nset_thread_wsaved(0);\r\n} else {\r\nerr |= __put_user(0, &sf->rwin_save);\r\n}\r\nerr |= copy_siginfo_to_user32(&sf->info, &ksig->info);\r\nerr |= __compat_save_altstack(&sf->stack, regs->u_regs[UREG_FP]);\r\nseta.sig[1] = (oldset->sig[0] >> 32);\r\nseta.sig[0] = oldset->sig[0];\r\nerr |= __copy_to_user(&sf->mask, &seta, sizeof(compat_sigset_t));\r\nif (!wsaved) {\r\nerr |= copy_in_user((u32 __user *)sf,\r\n(u32 __user *)(regs->u_regs[UREG_FP]),\r\nsizeof(struct reg_window32));\r\n} else {\r\nstruct reg_window *rp;\r\nrp = &current_thread_info()->reg_window[wsaved - 1];\r\nfor (i = 0; i < 8; i++)\r\nerr |= __put_user(rp->locals[i], &sf->ss.locals[i]);\r\nfor (i = 0; i < 6; i++)\r\nerr |= __put_user(rp->ins[i], &sf->ss.ins[i]);\r\nerr |= __put_user(rp->ins[6], &sf->ss.fp);\r\nerr |= __put_user(rp->ins[7], &sf->ss.callers_pc);\r\n}\r\nif (err)\r\nreturn err;\r\nregs->u_regs[UREG_FP] = (unsigned long) sf;\r\nregs->u_regs[UREG_I0] = ksig->sig;\r\nregs->u_regs[UREG_I1] = (unsigned long) &sf->info;\r\nregs->u_regs[UREG_I2] = (unsigned long) &sf->regs;\r\nregs->tpc = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->tnpc = (regs->tpc + 4);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc &= 0xffffffff;\r\nregs->tnpc &= 0xffffffff;\r\n}\r\nif (ksig->ka.ka_restorer)\r\nregs->u_regs[UREG_I7] = (unsigned long)ksig->ka.ka_restorer;\r\nelse {\r\nunsigned long address = ((unsigned long)&(sf->insns[0]));\r\nregs->u_regs[UREG_I7] = (unsigned long) (&(sf->insns[0]) - 2);\r\nerr |= __put_user(0x82102065, &sf->insns[0]);\r\nerr |= __put_user(0x91d02010, &sf->insns[1]);\r\nif (err)\r\nreturn err;\r\nflush_signal_insns(address);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void handle_signal32(struct ksignal *ksig,\r\nstruct pt_regs *regs)\r\n{\r\nsigset_t *oldset = sigmask_to_save();\r\nint err;\r\nif (ksig->ka.sa.sa_flags & SA_SIGINFO)\r\nerr = setup_rt_frame32(ksig, regs, oldset);\r\nelse\r\nerr = setup_frame32(ksig, regs, oldset);\r\nsignal_setup_done(err, ksig, 0);\r\n}\r\nstatic inline void syscall_restart32(unsigned long orig_i0, struct pt_regs *regs,\r\nstruct sigaction *sa)\r\n{\r\nswitch (regs->u_regs[UREG_I0]) {\r\ncase ERESTART_RESTARTBLOCK:\r\ncase ERESTARTNOHAND:\r\nno_system_call_restart:\r\nregs->u_regs[UREG_I0] = EINTR;\r\nregs->tstate |= TSTATE_ICARRY;\r\nbreak;\r\ncase ERESTARTSYS:\r\nif (!(sa->sa_flags & SA_RESTART))\r\ngoto no_system_call_restart;\r\ncase ERESTARTNOINTR:\r\nregs->u_regs[UREG_I0] = orig_i0;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\n}\r\n}\r\nvoid do_signal32(struct pt_regs * regs)\r\n{\r\nstruct ksignal ksig;\r\nunsigned long orig_i0 = 0;\r\nint restart_syscall = 0;\r\nbool has_handler = get_signal(&ksig);\r\nif (pt_regs_is_syscall(regs) &&\r\n(regs->tstate & (TSTATE_XCARRY | TSTATE_ICARRY))) {\r\nrestart_syscall = 1;\r\norig_i0 = regs->u_regs[UREG_G6];\r\n}\r\nif (has_handler) {\r\nif (restart_syscall)\r\nsyscall_restart32(orig_i0, regs, &ksig.ka.sa);\r\nhandle_signal32(&ksig, regs);\r\n} else {\r\nif (restart_syscall) {\r\nswitch (regs->u_regs[UREG_I0]) {\r\ncase ERESTARTNOHAND:\r\ncase ERESTARTSYS:\r\ncase ERESTARTNOINTR:\r\nregs->u_regs[UREG_I0] = orig_i0;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\npt_regs_clear_syscall(regs);\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->u_regs[UREG_G1] = __NR_restart_syscall;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\npt_regs_clear_syscall(regs);\r\n}\r\n}\r\nrestore_saved_sigmask();\r\n}\r\n}\r\nasmlinkage int do_sys32_sigstack(u32 u_ssptr, u32 u_ossptr, unsigned long sp)\r\n{\r\nstruct sigstack32 __user *ssptr =\r\n(struct sigstack32 __user *)((unsigned long)(u_ssptr));\r\nstruct sigstack32 __user *ossptr =\r\n(struct sigstack32 __user *)((unsigned long)(u_ossptr));\r\nint ret = -EFAULT;\r\nif (ossptr) {\r\nif (put_user(current->sas_ss_sp + current->sas_ss_size,\r\n&ossptr->the_stack) ||\r\n__put_user(on_sig_stack(sp), &ossptr->cur_status))\r\ngoto out;\r\n}\r\nif (ssptr) {\r\nu32 ss_sp;\r\nif (get_user(ss_sp, &ssptr->the_stack))\r\ngoto out;\r\nret = -EPERM;\r\nif (current->sas_ss_sp && on_sig_stack(sp))\r\ngoto out;\r\ncurrent->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;\r\ncurrent->sas_ss_size = SIGSTKSZ;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}
