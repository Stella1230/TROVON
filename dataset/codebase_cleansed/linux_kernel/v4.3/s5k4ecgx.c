static inline struct s5k4ecgx *to_s5k4ecgx(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct s5k4ecgx, sd);\r\n}\r\nstatic int s5k4ecgx_i2c_read(struct i2c_client *client, u16 addr, u16 *val)\r\n{\r\nu8 wbuf[2] = { addr >> 8, addr & 0xff };\r\nstruct i2c_msg msg[2];\r\nu8 rbuf[2];\r\nint ret;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = wbuf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = 2;\r\nmsg[1].buf = rbuf;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\n*val = be16_to_cpu(*((__be16 *)rbuf));\r\nv4l2_dbg(4, debug, client, "i2c_read: 0x%04X : 0x%04x\n", addr, *val);\r\nreturn ret == 2 ? 0 : ret;\r\n}\r\nstatic int s5k4ecgx_i2c_write(struct i2c_client *client, u16 addr, u16 val)\r\n{\r\nu8 buf[4] = { addr >> 8, addr & 0xff, val >> 8, val & 0xff };\r\nint ret = i2c_master_send(client, buf, 4);\r\nv4l2_dbg(4, debug, client, "i2c_write: 0x%04x : 0x%04x\n", addr, val);\r\nreturn ret == 4 ? 0 : ret;\r\n}\r\nstatic int s5k4ecgx_write(struct i2c_client *client, u32 addr, u16 val)\r\n{\r\nu16 high = addr >> 16, low = addr & 0xffff;\r\nint ret;\r\nv4l2_dbg(3, debug, client, "write: 0x%08x : 0x%04x\n", addr, val);\r\nret = s5k4ecgx_i2c_write(client, REG_CMDWR_ADDRH, high);\r\nif (!ret)\r\nret = s5k4ecgx_i2c_write(client, REG_CMDWR_ADDRL, low);\r\nif (!ret)\r\nret = s5k4ecgx_i2c_write(client, REG_CMDBUF0_ADDR, val);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_read(struct i2c_client *client, u32 addr, u16 *val)\r\n{\r\nu16 high = addr >> 16, low = addr & 0xffff;\r\nint ret;\r\nret = s5k4ecgx_i2c_write(client, REG_CMDRD_ADDRH, high);\r\nif (!ret)\r\nret = s5k4ecgx_i2c_write(client, REG_CMDRD_ADDRL, low);\r\nif (!ret)\r\nret = s5k4ecgx_i2c_read(client, REG_CMDBUF0_ADDR, val);\r\nif (!ret)\r\ndev_err(&client->dev, "Failed to execute read command\n");\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_read_fw_ver(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu16 hw_rev, fw_ver = 0;\r\nint ret;\r\nret = s5k4ecgx_read(client, REG_FW_VERSION, &fw_ver);\r\nif (ret < 0 || fw_ver != S5K4ECGX_FW_VERSION) {\r\nv4l2_err(sd, "FW version check failed!\n");\r\nreturn -ENODEV;\r\n}\r\nret = s5k4ecgx_read(client, REG_FW_REVISION, &hw_rev);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_info(sd, "chip found FW ver: 0x%x, HW rev: 0x%x\n",\r\nfw_ver, hw_rev);\r\nreturn 0;\r\n}\r\nstatic int s5k4ecgx_set_ahb_address(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nret = s5k4ecgx_i2c_write(client, AHB_MSB_ADDR_PTR, GEN_REG_OFFSH);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5k4ecgx_i2c_write(client, 0x0010, 0x0001);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5k4ecgx_i2c_write(client, 0x1030, 0x0000);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn s5k4ecgx_i2c_write(client, 0x0014, 0x0001);\r\n}\r\nstatic int s5k4ecgx_load_firmware(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nconst struct firmware *fw;\r\nconst u8 *ptr;\r\nint err, i, regs_num;\r\nu32 addr, crc, crc_file, addr_inc = 0;\r\nu16 val;\r\nerr = request_firmware(&fw, S5K4ECGX_FIRMWARE, sd->v4l2_dev->dev);\r\nif (err) {\r\nv4l2_err(sd, "Failed to read firmware %s\n", S5K4ECGX_FIRMWARE);\r\nreturn err;\r\n}\r\nregs_num = get_unaligned_le32(fw->data);\r\nv4l2_dbg(3, debug, sd, "FW: %s size %zu register sets %d\n",\r\nS5K4ECGX_FIRMWARE, fw->size, regs_num);\r\nregs_num++;\r\nif (fw->size != regs_num * FW_RECORD_SIZE + FW_CRC_SIZE) {\r\nerr = -EINVAL;\r\ngoto fw_out;\r\n}\r\ncrc_file = get_unaligned_le32(fw->data + regs_num * FW_RECORD_SIZE);\r\ncrc = crc32_le(~0, fw->data, regs_num * FW_RECORD_SIZE);\r\nif (crc != crc_file) {\r\nv4l2_err(sd, "FW: invalid crc (%#x:%#x)\n", crc, crc_file);\r\nerr = -EINVAL;\r\ngoto fw_out;\r\n}\r\nptr = fw->data + FW_RECORD_SIZE;\r\nfor (i = 1; i < regs_num; i++) {\r\naddr = get_unaligned_le32(ptr);\r\nptr += sizeof(u32);\r\nval = get_unaligned_le16(ptr);\r\nptr += sizeof(u16);\r\nif (addr - addr_inc != 2)\r\nerr = s5k4ecgx_write(client, addr, val);\r\nelse\r\nerr = s5k4ecgx_i2c_write(client, REG_CMDBUF0_ADDR, val);\r\nif (err)\r\nbreak;\r\naddr_inc = addr;\r\n}\r\nfw_out:\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int s5k4ecgx_set_input_window(struct i2c_client *c,\r\nconst struct v4l2_rect *r)\r\n{\r\nint ret;\r\nret = s5k4ecgx_write(c, REG_G_PREV_IN_WIDTH, r->width);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREV_IN_HEIGHT, r->height);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREV_IN_XOFFS, r->left);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREV_IN_YOFFS, r->top);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAP_IN_WIDTH, r->width);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAP_IN_HEIGHT, r->height);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAP_IN_XOFFS, r->left);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAP_IN_YOFFS, r->top);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_set_zoom_window(struct i2c_client *c,\r\nconst struct v4l2_rect *r)\r\n{\r\nint ret;\r\nret = s5k4ecgx_write(c, REG_G_PREVZOOM_IN_WIDTH, r->width);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREVZOOM_IN_HEIGHT, r->height);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREVZOOM_IN_XOFFS, r->left);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_PREVZOOM_IN_YOFFS, r->top);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAPZOOM_IN_WIDTH, r->width);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAPZOOM_IN_HEIGHT, r->height);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAPZOOM_IN_XOFFS, r->left);\r\nif (!ret)\r\nret = s5k4ecgx_write(c, REG_G_CAPZOOM_IN_YOFFS, r->top);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_set_output_framefmt(struct s5k4ecgx *priv)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\r\nint ret;\r\nret = s5k4ecgx_write(client, REG_P_OUT_WIDTH(0),\r\npriv->curr_frmsize->size.width);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_OUT_HEIGHT(0),\r\npriv->curr_frmsize->size.height);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_FMT(0),\r\npriv->curr_pixfmt->reg_p_format);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_init_sensor(struct v4l2_subdev *sd)\r\n{\r\nint ret;\r\nret = s5k4ecgx_set_ahb_address(sd);\r\nmsleep(100);\r\nif (!ret)\r\nret = s5k4ecgx_load_firmware(sd);\r\nif (ret)\r\nv4l2_err(sd, "Failed to write initial settings\n");\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_gpio_set_value(struct s5k4ecgx *priv, int id, u32 val)\r\n{\r\nif (!gpio_is_valid(priv->gpio[id].gpio))\r\nreturn 0;\r\ngpio_set_value(priv->gpio[id].gpio, val);\r\nreturn 1;\r\n}\r\nstatic int __s5k4ecgx_power_on(struct s5k4ecgx *priv)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(S5K4ECGX_NUM_SUPPLIES, priv->supplies);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(30, 50);\r\nif (s5k4ecgx_gpio_set_value(priv, STBY, priv->gpio[STBY].level))\r\nusleep_range(30, 50);\r\nif (s5k4ecgx_gpio_set_value(priv, RST, priv->gpio[RST].level))\r\nusleep_range(30, 50);\r\nreturn 0;\r\n}\r\nstatic int __s5k4ecgx_power_off(struct s5k4ecgx *priv)\r\n{\r\nif (s5k4ecgx_gpio_set_value(priv, RST, !priv->gpio[RST].level))\r\nusleep_range(30, 50);\r\nif (s5k4ecgx_gpio_set_value(priv, STBY, !priv->gpio[STBY].level))\r\nusleep_range(30, 50);\r\npriv->streaming = 0;\r\nreturn regulator_bulk_disable(S5K4ECGX_NUM_SUPPLIES, priv->supplies);\r\n}\r\nstatic int s5k4ecgx_try_frame_size(struct v4l2_mbus_framefmt *mf,\r\nconst struct s5k4ecgx_frmsize **size)\r\n{\r\nunsigned int min_err = ~0;\r\nint i = ARRAY_SIZE(s5k4ecgx_prev_sizes);\r\nconst struct s5k4ecgx_frmsize *fsize = &s5k4ecgx_prev_sizes[0],\r\n*match = NULL;\r\nwhile (i--) {\r\nint err = abs(fsize->size.width - mf->width)\r\n+ abs(fsize->size.height - mf->height);\r\nif (err < min_err) {\r\nmin_err = err;\r\nmatch = fsize;\r\n}\r\nfsize++;\r\n}\r\nif (match) {\r\nmf->width = match->size.width;\r\nmf->height = match->size.height;\r\nif (size)\r\n*size = match;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int s5k4ecgx_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(s5k4ecgx_formats))\r\nreturn -EINVAL;\r\ncode->code = s5k4ecgx_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int s5k4ecgx_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (cfg) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, 0);\r\nfmt->format = *mf;\r\n}\r\nreturn 0;\r\n}\r\nmf = &fmt->format;\r\nmutex_lock(&priv->lock);\r\nmf->width = priv->curr_frmsize->size.width;\r\nmf->height = priv->curr_frmsize->size.height;\r\nmf->code = priv->curr_pixfmt->code;\r\nmf->colorspace = priv->curr_pixfmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic const struct s5k4ecgx_pixfmt *s5k4ecgx_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i = ARRAY_SIZE(s5k4ecgx_formats);\r\nwhile (--i)\r\nif (mf->code == s5k4ecgx_formats[i].code)\r\nbreak;\r\nmf->code = s5k4ecgx_formats[i].code;\r\nreturn &s5k4ecgx_formats[i];\r\n}\r\nstatic int s5k4ecgx_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nconst struct s5k4ecgx_frmsize *fsize = NULL;\r\nconst struct s5k4ecgx_pixfmt *pf;\r\nstruct v4l2_mbus_framefmt *mf;\r\nint ret = 0;\r\npf = s5k4ecgx_try_fmt(sd, &fmt->format);\r\ns5k4ecgx_try_frame_size(&fmt->format, &fsize);\r\nfmt->format.colorspace = V4L2_COLORSPACE_JPEG;\r\nfmt->format.field = V4L2_FIELD_NONE;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (cfg) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, 0);\r\n*mf = fmt->format;\r\n}\r\nreturn 0;\r\n}\r\nmutex_lock(&priv->lock);\r\nif (!priv->streaming) {\r\npriv->curr_frmsize = fsize;\r\npriv->curr_pixfmt = pf;\r\npriv->set_params = 1;\r\n} else {\r\nret = -EBUSY;\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = &container_of(ctrl->handler, struct s5k4ecgx,\r\nhandler)->sd;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nunsigned int i;\r\nint err = 0;\r\nv4l2_dbg(1, debug, sd, "ctrl: 0x%x, value: %d\n", ctrl->id, ctrl->val);\r\nmutex_lock(&priv->lock);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_CONTRAST:\r\nerr = s5k4ecgx_write(client, REG_USER_CONTRAST, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nerr = s5k4ecgx_write(client, REG_USER_SATURATION, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nfor (i = 0; i < 4 && !err; i++)\r\nerr = s5k4ecgx_write(client, REG_USER_SHARPNESS(i),\r\nctrl->val * SHARPNESS_DIV);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nerr = s5k4ecgx_write(client, REG_USER_BRIGHTNESS, ctrl->val);\r\nbreak;\r\n}\r\nmutex_unlock(&priv->lock);\r\nif (err < 0)\r\nv4l2_err(sd, "Failed to write s_ctrl err %d\n", err);\r\nreturn err;\r\n}\r\nstatic int s5k4ecgx_registered(struct v4l2_subdev *sd)\r\n{\r\nint ret;\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nmutex_lock(&priv->lock);\r\nret = __s5k4ecgx_power_on(priv);\r\nif (!ret) {\r\nret = s5k4ecgx_read_fw_ver(sd);\r\n__s5k4ecgx_power_off(priv);\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = v4l2_subdev_get_try_format(sd, fh->pad, 0);\r\nmf->width = s5k4ecgx_prev_sizes[0].size.width;\r\nmf->height = s5k4ecgx_prev_sizes[0].size.height;\r\nmf->code = s5k4ecgx_formats[0].code;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int s5k4ecgx_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nint ret;\r\nv4l2_dbg(1, debug, sd, "Switching %s\n", on ? "on" : "off");\r\nif (on) {\r\nret = __s5k4ecgx_power_on(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = s5k4ecgx_init_sensor(sd);\r\nif (ret < 0)\r\n__s5k4ecgx_power_off(priv);\r\nelse\r\npriv->set_params = 1;\r\n} else {\r\nret = __s5k4ecgx_power_off(priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_log_status(struct v4l2_subdev *sd)\r\n{\r\nv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\r\nreturn 0;\r\n}\r\nstatic int __s5k4ecgx_s_params(struct s5k4ecgx *priv)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\r\nconst struct v4l2_rect *crop_rect = &priv->curr_frmsize->input_window;\r\nint ret;\r\nret = s5k4ecgx_set_input_window(client, crop_rect);\r\nif (!ret)\r\nret = s5k4ecgx_set_zoom_window(client, crop_rect);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_G_INPUTS_CHANGE_REQ, 1);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, 0x70000a1e, 0x28);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, 0x70000ad4, 0x3c);\r\nif (!ret)\r\nret = s5k4ecgx_set_output_framefmt(priv);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_PVI_MASK(0), 0x52);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_FR_TIME_TYPE(0),\r\nFR_TIME_DYNAMIC);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_FR_TIME_Q_TYPE(0),\r\nFR_TIME_Q_BEST_FRRATE);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_MIN_FR_TIME(0),\r\nUS_TO_FR_TIME(33300));\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_MAX_FR_TIME(0),\r\nUS_TO_FR_TIME(66600));\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_PREV_MIRROR(0), 0);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_P_CAP_MIRROR(0), 0);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_G_ACTIVE_PREV_CFG, 0);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_G_PREV_OPEN_AFTER_CH, 1);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_G_NEW_CFG_SYNC, 1);\r\nif (!ret)\r\nret = s5k4ecgx_write(client, REG_G_PREV_CFG_CHG, 1);\r\nreturn ret;\r\n}\r\nstatic int __s5k4ecgx_s_stream(struct s5k4ecgx *priv, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\r\nint ret;\r\nif (on && priv->set_params) {\r\nret = __s5k4ecgx_s_params(priv);\r\nif (ret < 0)\r\nreturn ret;\r\npriv->set_params = 0;\r\n}\r\nret = s5k4ecgx_write(client, REG_G_ENABLE_PREV, on);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn s5k4ecgx_write(client, REG_G_ENABLE_PREV_CHG, 1);\r\n}\r\nstatic int s5k4ecgx_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "Turn streaming %s\n", on ? "on" : "off");\r\nmutex_lock(&priv->lock);\r\nif (priv->streaming == !on) {\r\nret = __s5k4ecgx_s_stream(priv, on);\r\nif (!ret)\r\npriv->streaming = on & 1;\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_config_gpio(int nr, int val, const char *name)\r\n{\r\nunsigned long flags = val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nint ret;\r\nif (!gpio_is_valid(nr))\r\nreturn 0;\r\nret = gpio_request_one(nr, flags, name);\r\nif (!ret)\r\ngpio_export(nr, 0);\r\nreturn ret;\r\n}\r\nstatic void s5k4ecgx_free_gpios(struct s5k4ecgx *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(priv->gpio); i++) {\r\nif (!gpio_is_valid(priv->gpio[i].gpio))\r\ncontinue;\r\ngpio_free(priv->gpio[i].gpio);\r\npriv->gpio[i].gpio = -EINVAL;\r\n}\r\n}\r\nstatic int s5k4ecgx_config_gpios(struct s5k4ecgx *priv,\r\nconst struct s5k4ecgx_platform_data *pdata)\r\n{\r\nconst struct s5k4ecgx_gpio *gpio = &pdata->gpio_stby;\r\nint ret;\r\npriv->gpio[STBY].gpio = -EINVAL;\r\npriv->gpio[RST].gpio = -EINVAL;\r\nret = s5k4ecgx_config_gpio(gpio->gpio, gpio->level, "S5K4ECGX_STBY");\r\nif (ret) {\r\ns5k4ecgx_free_gpios(priv);\r\nreturn ret;\r\n}\r\npriv->gpio[STBY] = *gpio;\r\nif (gpio_is_valid(gpio->gpio))\r\ngpio_set_value(gpio->gpio, 0);\r\ngpio = &pdata->gpio_reset;\r\nret = s5k4ecgx_config_gpio(gpio->gpio, gpio->level, "S5K4ECGX_RST");\r\nif (ret) {\r\ns5k4ecgx_free_gpios(priv);\r\nreturn ret;\r\n}\r\npriv->gpio[RST] = *gpio;\r\nif (gpio_is_valid(gpio->gpio))\r\ngpio_set_value(gpio->gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int s5k4ecgx_init_v4l2_ctrls(struct s5k4ecgx *priv)\r\n{\r\nconst struct v4l2_ctrl_ops *ops = &s5k4ecgx_ctrl_ops;\r\nstruct v4l2_ctrl_handler *hdl = &priv->handler;\r\nint ret;\r\nret = v4l2_ctrl_handler_init(hdl, 4);\r\nif (ret)\r\nreturn ret;\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS, -208, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS, -32704/SHARPNESS_DIV,\r\n24612/SHARPNESS_DIV, 1, 2);\r\nif (hdl->error) {\r\nret = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn ret;\r\n}\r\npriv->sd.ctrl_handler = hdl;\r\nreturn 0;\r\n}\r\nstatic int s5k4ecgx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct s5k4ecgx_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_subdev *sd;\r\nstruct s5k4ecgx *priv;\r\nint ret, i;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "platform data is missing!\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(struct s5k4ecgx), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->lock);\r\npriv->streaming = 0;\r\nsd = &priv->sd;\r\nv4l2_i2c_subdev_init(sd, client, &s5k4ecgx_ops);\r\nstrlcpy(sd->name, S5K4ECGX_DRIVER_NAME, sizeof(sd->name));\r\nsd->internal_ops = &s5k4ecgx_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npriv->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nret = media_entity_init(&sd->entity, 1, &priv->pad, 0);\r\nif (ret)\r\nreturn ret;\r\nret = s5k4ecgx_config_gpios(priv, pdata);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to set gpios\n");\r\ngoto out_err1;\r\n}\r\nfor (i = 0; i < S5K4ECGX_NUM_SUPPLIES; i++)\r\npriv->supplies[i].supply = s5k4ecgx_supply_names[i];\r\nret = devm_regulator_bulk_get(&client->dev, S5K4ECGX_NUM_SUPPLIES,\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to get regulators\n");\r\ngoto out_err2;\r\n}\r\nret = s5k4ecgx_init_v4l2_ctrls(priv);\r\nif (ret)\r\ngoto out_err2;\r\npriv->curr_pixfmt = &s5k4ecgx_formats[0];\r\npriv->curr_frmsize = &s5k4ecgx_prev_sizes[0];\r\nreturn 0;\r\nout_err2:\r\ns5k4ecgx_free_gpios(priv);\r\nout_err1:\r\nmedia_entity_cleanup(&priv->sd.entity);\r\nreturn ret;\r\n}\r\nstatic int s5k4ecgx_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct s5k4ecgx *priv = to_s5k4ecgx(sd);\r\nmutex_destroy(&priv->lock);\r\ns5k4ecgx_free_gpios(priv);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&priv->handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
