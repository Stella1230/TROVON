static enum drm_connector_status imx_ldb_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int imx_ldb_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = con_to_imx_ldb_ch(connector);\r\nint num_modes = 0;\r\nif (imx_ldb_ch->panel && imx_ldb_ch->panel->funcs &&\r\nimx_ldb_ch->panel->funcs->get_modes) {\r\nstruct drm_display_info *di = &connector->display_info;\r\nnum_modes = imx_ldb_ch->panel->funcs->get_modes(imx_ldb_ch->panel);\r\nif (!imx_ldb_ch->bus_format && di->num_bus_formats)\r\nimx_ldb_ch->bus_format = di->bus_formats[0];\r\nif (num_modes > 0)\r\nreturn num_modes;\r\n}\r\nif (imx_ldb_ch->edid) {\r\ndrm_mode_connector_update_edid_property(connector,\r\nimx_ldb_ch->edid);\r\nnum_modes = drm_add_edid_modes(connector, imx_ldb_ch->edid);\r\n}\r\nif (imx_ldb_ch->mode_valid) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode)\r\nreturn -EINVAL;\r\ndrm_mode_copy(mode, &imx_ldb_ch->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nreturn num_modes;\r\n}\r\nstatic struct drm_encoder *imx_ldb_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = con_to_imx_ldb_ch(connector);\r\nreturn &imx_ldb_ch->encoder;\r\n}\r\nstatic void imx_ldb_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool imx_ldb_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void imx_ldb_set_clock(struct imx_ldb *ldb, int mux, int chno,\r\nunsigned long serial_clk, unsigned long di_clk)\r\n{\r\nint ret;\r\ndev_dbg(ldb->dev, "%s: now: %ld want: %ld\n", __func__,\r\nclk_get_rate(ldb->clk_pll[chno]), serial_clk);\r\nclk_set_rate(ldb->clk_pll[chno], serial_clk);\r\ndev_dbg(ldb->dev, "%s after: %ld\n", __func__,\r\nclk_get_rate(ldb->clk_pll[chno]));\r\ndev_dbg(ldb->dev, "%s: now: %ld want: %ld\n", __func__,\r\nclk_get_rate(ldb->clk[chno]),\r\n(long int)di_clk);\r\nclk_set_rate(ldb->clk[chno], di_clk);\r\ndev_dbg(ldb->dev, "%s after: %ld\n", __func__,\r\nclk_get_rate(ldb->clk[chno]));\r\nret = clk_set_parent(ldb->clk_sel[mux], ldb->clk[chno]);\r\nif (ret)\r\ndev_err(ldb->dev,\r\n"unable to set di%d parent clock to ldb_di%d\n", mux,\r\nchno);\r\n}\r\nstatic void imx_ldb_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\r\nu32 bus_format;\r\nswitch (imx_ldb_ch->bus_format) {\r\ndefault:\r\ndev_warn(ldb->dev,\r\n"could not determine data mapping, default to 18-bit \"spwg\"\n");\r\ncase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\r\nbus_format = MEDIA_BUS_FMT_RGB666_1X18;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\r\nbus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nif (imx_ldb_ch->chno == 0 || dual)\r\nldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24;\r\nif (imx_ldb_ch->chno == 1 || dual)\r\nldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\r\nbus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nif (imx_ldb_ch->chno == 0 || dual)\r\nldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24 |\r\nLDB_BIT_MAP_CH0_JEIDA;\r\nif (imx_ldb_ch->chno == 1 || dual)\r\nldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24 |\r\nLDB_BIT_MAP_CH1_JEIDA;\r\nbreak;\r\n}\r\nimx_drm_set_bus_format(encoder, bus_format);\r\n}\r\nstatic void imx_ldb_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\r\nint mux = imx_drm_encoder_get_mux_id(imx_ldb_ch->child, encoder);\r\ndrm_panel_prepare(imx_ldb_ch->panel);\r\nif (dual) {\r\nclk_prepare_enable(ldb->clk[0]);\r\nclk_prepare_enable(ldb->clk[1]);\r\n}\r\nif (imx_ldb_ch == &ldb->channel[0] || dual) {\r\nldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\r\nif (mux == 0 || ldb->lvds_mux)\r\nldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\r\nelse if (mux == 1)\r\nldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;\r\n}\r\nif (imx_ldb_ch == &ldb->channel[1] || dual) {\r\nldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\r\nif (mux == 1 || ldb->lvds_mux)\r\nldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;\r\nelse if (mux == 0)\r\nldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\r\n}\r\nif (ldb->lvds_mux) {\r\nconst struct bus_mux *lvds_mux = NULL;\r\nif (imx_ldb_ch == &ldb->channel[0])\r\nlvds_mux = &ldb->lvds_mux[0];\r\nelse if (imx_ldb_ch == &ldb->channel[1])\r\nlvds_mux = &ldb->lvds_mux[1];\r\nregmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,\r\nmux << lvds_mux->shift);\r\n}\r\nregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\r\ndrm_panel_enable(imx_ldb_ch->panel);\r\n}\r\nstatic void imx_ldb_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *orig_mode,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\r\nunsigned long serial_clk;\r\nunsigned long di_clk = mode->clock * 1000;\r\nint mux = imx_drm_encoder_get_mux_id(imx_ldb_ch->child, encoder);\r\nif (mode->clock > 170000) {\r\ndev_warn(ldb->dev,\r\n"%s: mode exceeds 170 MHz pixel clock\n", __func__);\r\n}\r\nif (mode->clock > 85000 && !dual) {\r\ndev_warn(ldb->dev,\r\n"%s: mode exceeds 85 MHz pixel clock\n", __func__);\r\n}\r\nif (dual) {\r\nserial_clk = 3500UL * mode->clock;\r\nimx_ldb_set_clock(ldb, mux, 0, serial_clk, di_clk);\r\nimx_ldb_set_clock(ldb, mux, 1, serial_clk, di_clk);\r\n} else {\r\nserial_clk = 7000UL * mode->clock;\r\nimx_ldb_set_clock(ldb, mux, imx_ldb_ch->chno, serial_clk,\r\ndi_clk);\r\n}\r\nif (imx_ldb_ch == &ldb->channel[0]) {\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nldb->ldb_ctrl |= LDB_DI0_VS_POL_ACT_LOW;\r\nelse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nldb->ldb_ctrl &= ~LDB_DI0_VS_POL_ACT_LOW;\r\n}\r\nif (imx_ldb_ch == &ldb->channel[1]) {\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nldb->ldb_ctrl |= LDB_DI1_VS_POL_ACT_LOW;\r\nelse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nldb->ldb_ctrl &= ~LDB_DI1_VS_POL_ACT_LOW;\r\n}\r\n}\r\nstatic void imx_ldb_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint mux, ret;\r\nif (imx_ldb_ch == &ldb->channel[0] &&\r\n(ldb->ldb_ctrl & LDB_CH0_MODE_EN_MASK) == 0)\r\nreturn;\r\nelse if (imx_ldb_ch == &ldb->channel[1] &&\r\n(ldb->ldb_ctrl & LDB_CH1_MODE_EN_MASK) == 0)\r\nreturn;\r\ndrm_panel_disable(imx_ldb_ch->panel);\r\nif (imx_ldb_ch == &ldb->channel[0])\r\nldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\r\nelse if (imx_ldb_ch == &ldb->channel[1])\r\nldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\r\nregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\r\nif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\r\nclk_disable_unprepare(ldb->clk[0]);\r\nclk_disable_unprepare(ldb->clk[1]);\r\n}\r\nif (ldb->lvds_mux) {\r\nconst struct bus_mux *lvds_mux = NULL;\r\nif (imx_ldb_ch == &ldb->channel[0])\r\nlvds_mux = &ldb->lvds_mux[0];\r\nelse if (imx_ldb_ch == &ldb->channel[1])\r\nlvds_mux = &ldb->lvds_mux[1];\r\nregmap_read(ldb->regmap, lvds_mux->reg, &mux);\r\nmux &= lvds_mux->mask;\r\nmux >>= lvds_mux->shift;\r\n} else {\r\nmux = (imx_ldb_ch == &ldb->channel[0]) ? 0 : 1;\r\n}\r\nret = clk_set_parent(ldb->clk_sel[mux], ldb->clk_parent[mux]);\r\nif (ret)\r\ndev_err(ldb->dev,\r\n"unable to set di%d parent clock to original parent\n",\r\nmux);\r\ndrm_panel_unprepare(imx_ldb_ch->panel);\r\n}\r\nstatic int imx_ldb_get_clk(struct imx_ldb *ldb, int chno)\r\n{\r\nchar clkname[16];\r\nsnprintf(clkname, sizeof(clkname), "di%d", chno);\r\nldb->clk[chno] = devm_clk_get(ldb->dev, clkname);\r\nif (IS_ERR(ldb->clk[chno]))\r\nreturn PTR_ERR(ldb->clk[chno]);\r\nsnprintf(clkname, sizeof(clkname), "di%d_pll", chno);\r\nldb->clk_pll[chno] = devm_clk_get(ldb->dev, clkname);\r\nreturn PTR_ERR_OR_ZERO(ldb->clk_pll[chno]);\r\n}\r\nstatic int imx_ldb_register(struct drm_device *drm,\r\nstruct imx_ldb_channel *imx_ldb_ch)\r\n{\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint ret;\r\nret = imx_drm_encoder_parse_of(drm, &imx_ldb_ch->encoder,\r\nimx_ldb_ch->child);\r\nif (ret)\r\nreturn ret;\r\nret = imx_ldb_get_clk(ldb, imx_ldb_ch->chno);\r\nif (ret)\r\nreturn ret;\r\nif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\r\nret = imx_ldb_get_clk(ldb, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(&imx_ldb_ch->encoder,\r\n&imx_ldb_encoder_helper_funcs);\r\ndrm_encoder_init(drm, &imx_ldb_ch->encoder, &imx_ldb_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_connector_helper_add(&imx_ldb_ch->connector,\r\n&imx_ldb_connector_helper_funcs);\r\ndrm_connector_init(drm, &imx_ldb_ch->connector,\r\n&imx_ldb_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\r\nif (imx_ldb_ch->panel)\r\ndrm_panel_attach(imx_ldb_ch->panel, &imx_ldb_ch->connector);\r\ndrm_mode_connector_attach_encoder(&imx_ldb_ch->connector,\r\n&imx_ldb_ch->encoder);\r\nreturn 0;\r\n}\r\nstatic u32 of_get_bus_format(struct device *dev, struct device_node *np)\r\n{\r\nconst char *bm;\r\nu32 datawidth = 0;\r\nint ret, i;\r\nret = of_property_read_string(np, "fsl,data-mapping", &bm);\r\nif (ret < 0)\r\nreturn ret;\r\nof_property_read_u32(np, "fsl,data-width", &datawidth);\r\nfor (i = 0; i < ARRAY_SIZE(imx_ldb_bit_mappings); i++) {\r\nif (!strcasecmp(bm, imx_ldb_bit_mappings[i].mapping) &&\r\ndatawidth == imx_ldb_bit_mappings[i].datawidth)\r\nreturn imx_ldb_bit_mappings[i].bus_format;\r\n}\r\ndev_err(dev, "invalid data mapping: %d-bit \"%s\"\n", datawidth, bm);\r\nreturn -ENOENT;\r\n}\r\nstatic int imx_ldb_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *drm = data;\r\nstruct device_node *np = dev->of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_ldb_dt_ids, dev);\r\nstruct device_node *child;\r\nconst u8 *edidp;\r\nstruct imx_ldb *imx_ldb;\r\nint dual;\r\nint ret;\r\nint i;\r\nimx_ldb = devm_kzalloc(dev, sizeof(*imx_ldb), GFP_KERNEL);\r\nif (!imx_ldb)\r\nreturn -ENOMEM;\r\nimx_ldb->regmap = syscon_regmap_lookup_by_phandle(np, "gpr");\r\nif (IS_ERR(imx_ldb->regmap)) {\r\ndev_err(dev, "failed to get parent regmap\n");\r\nreturn PTR_ERR(imx_ldb->regmap);\r\n}\r\nimx_ldb->dev = dev;\r\nif (of_id)\r\nimx_ldb->lvds_mux = of_id->data;\r\ndual = of_property_read_bool(np, "fsl,dual-channel");\r\nif (dual)\r\nimx_ldb->ldb_ctrl |= LDB_SPLIT_MODE_EN;\r\nfor (i = 0; i < 4; i++) {\r\nchar clkname[16];\r\nsprintf(clkname, "di%d_sel", i);\r\nimx_ldb->clk_sel[i] = devm_clk_get(imx_ldb->dev, clkname);\r\nif (IS_ERR(imx_ldb->clk_sel[i])) {\r\nret = PTR_ERR(imx_ldb->clk_sel[i]);\r\nimx_ldb->clk_sel[i] = NULL;\r\nbreak;\r\n}\r\nimx_ldb->clk_parent[i] = clk_get_parent(imx_ldb->clk_sel[i]);\r\n}\r\nif (i == 0)\r\nreturn ret;\r\nfor_each_child_of_node(np, child) {\r\nstruct imx_ldb_channel *channel;\r\nstruct device_node *port;\r\nret = of_property_read_u32(child, "reg", &i);\r\nif (ret || i < 0 || i > 1)\r\nreturn -EINVAL;\r\nif (dual && i > 0) {\r\ndev_warn(dev, "dual-channel mode, ignoring second output\n");\r\ncontinue;\r\n}\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nchannel = &imx_ldb->channel[i];\r\nchannel->ldb = imx_ldb;\r\nchannel->chno = i;\r\nchannel->child = child;\r\nport = of_graph_get_port_by_id(child, imx_ldb->lvds_mux ? 4 : 2);\r\nif (port) {\r\nstruct device_node *endpoint, *remote;\r\nendpoint = of_get_child_by_name(port, "endpoint");\r\nif (endpoint) {\r\nremote = of_graph_get_remote_port_parent(endpoint);\r\nif (remote)\r\nchannel->panel = of_drm_find_panel(remote);\r\nelse\r\nreturn -EPROBE_DEFER;\r\nif (!channel->panel) {\r\ndev_err(dev, "panel not found: %s\n",\r\nremote->full_name);\r\nreturn -EPROBE_DEFER;\r\n}\r\n}\r\n}\r\nedidp = of_get_property(child, "edid", &channel->edid_len);\r\nif (edidp) {\r\nchannel->edid = kmemdup(edidp, channel->edid_len,\r\nGFP_KERNEL);\r\n} else if (!channel->panel) {\r\nret = of_get_drm_display_mode(child, &channel->mode, 0);\r\nif (!ret)\r\nchannel->mode_valid = 1;\r\n}\r\nchannel->bus_format = of_get_bus_format(dev, child);\r\nif (channel->bus_format == -EINVAL) {\r\nif (channel->panel && channel->panel->funcs &&\r\nchannel->panel->funcs->get_modes)\r\nchannel->bus_format = 0;\r\n}\r\nif (channel->bus_format < 0) {\r\ndev_err(dev, "could not determine data mapping: %d\n",\r\nchannel->bus_format);\r\nreturn channel->bus_format;\r\n}\r\nret = imx_ldb_register(drm, channel);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, imx_ldb);\r\nreturn 0;\r\n}\r\nstatic void imx_ldb_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct imx_ldb *imx_ldb = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct imx_ldb_channel *channel = &imx_ldb->channel[i];\r\nif (!channel->connector.funcs)\r\ncontinue;\r\nchannel->connector.funcs->destroy(&channel->connector);\r\nchannel->encoder.funcs->destroy(&channel->encoder);\r\nkfree(channel->edid);\r\n}\r\n}\r\nstatic int imx_ldb_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &imx_ldb_ops);\r\n}\r\nstatic int imx_ldb_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &imx_ldb_ops);\r\nreturn 0;\r\n}
