static int set_io_32bit(ide_drive_t *drive, int arg)\r\n{\r\nif (drive->dev_flags & IDE_DFLAG_NO_IO_32BIT)\r\nreturn -EPERM;\r\nif (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))\r\nreturn -EINVAL;\r\ndrive->io_32bit = arg;\r\nreturn 0;\r\n}\r\nstatic int set_ksettings(ide_drive_t *drive, int arg)\r\n{\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nif (arg)\r\ndrive->dev_flags |= IDE_DFLAG_KEEP_SETTINGS;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_KEEP_SETTINGS;\r\nreturn 0;\r\n}\r\nstatic int set_using_dma(ide_drive_t *drive, int arg)\r\n{\r\n#ifdef CONFIG_BLK_DEV_IDEDMA\r\nint err = -EPERM;\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nif (ata_id_has_dma(drive->id) == 0)\r\ngoto out;\r\nif (drive->hwif->dma_ops == NULL)\r\ngoto out;\r\nerr = 0;\r\nif (arg) {\r\nif (ide_set_dma(drive))\r\nerr = -EIO;\r\n} else\r\nide_dma_off(drive);\r\nout:\r\nreturn err;\r\n#else\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nreturn -EPERM;\r\n#endif\r\n}\r\nstatic int set_pio_mode_abuse(ide_hwif_t *hwif, u8 req_pio)\r\n{\r\nswitch (req_pio) {\r\ncase 202:\r\ncase 201:\r\ncase 200:\r\ncase 102:\r\ncase 101:\r\ncase 100:\r\nreturn (hwif->host_flags & IDE_HFLAG_ABUSE_DMA_MODES) ? 1 : 0;\r\ncase 9:\r\ncase 8:\r\nreturn (hwif->host_flags & IDE_HFLAG_ABUSE_PREFETCH) ? 1 : 0;\r\ncase 7:\r\ncase 6:\r\nreturn (hwif->host_flags & IDE_HFLAG_ABUSE_FAST_DEVSEL) ? 1 : 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int set_pio_mode(ide_drive_t *drive, int arg)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nif (arg < 0 || arg > 255)\r\nreturn -EINVAL;\r\nif (port_ops == NULL || port_ops->set_pio_mode == NULL ||\r\n(hwif->host_flags & IDE_HFLAG_NO_SET_MODE))\r\nreturn -ENOSYS;\r\nif (set_pio_mode_abuse(drive->hwif, arg)) {\r\ndrive->pio_mode = arg + XFER_PIO_0;\r\nif (arg == 8 || arg == 9) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwif->lock, flags);\r\nport_ops->set_pio_mode(hwif, drive);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\n} else\r\nport_ops->set_pio_mode(hwif, drive);\r\n} else {\r\nint keep_dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);\r\nide_set_pio(drive, arg);\r\nif (hwif->host_flags & IDE_HFLAG_SET_PIO_MODE_KEEP_DMA) {\r\nif (keep_dma)\r\nide_dma_on(drive);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_unmaskirq(ide_drive_t *drive, int arg)\r\n{\r\nif (drive->dev_flags & IDE_DFLAG_NO_UNMASK)\r\nreturn -EPERM;\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nif (arg)\r\ndrive->dev_flags |= IDE_DFLAG_UNMASK;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_UNMASK;\r\nreturn 0;\r\n}\r\nint ide_devset_execute(ide_drive_t *drive, const struct ide_devset *setting,\r\nint arg)\r\n{\r\nstruct request_queue *q = drive->queue;\r\nstruct request *rq;\r\nint ret = 0;\r\nif (!(setting->flags & DS_SYNC))\r\nreturn setting->set(drive, arg);\r\nrq = blk_get_request(q, READ, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nrq->cmd_len = 5;\r\nrq->cmd[0] = REQ_DEVSET_EXEC;\r\n*(int *)&rq->cmd[1] = arg;\r\nrq->special = setting->set;\r\nif (blk_execute_rq(q, NULL, rq, 0))\r\nret = rq->errors;\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nide_startstop_t ide_do_devset(ide_drive_t *drive, struct request *rq)\r\n{\r\nint err, (*setfunc)(ide_drive_t *, int) = rq->special;\r\nerr = setfunc(drive, *(int *)&rq->cmd[1]);\r\nif (err)\r\nrq->errors = err;\r\nide_complete_rq(drive, err, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}
