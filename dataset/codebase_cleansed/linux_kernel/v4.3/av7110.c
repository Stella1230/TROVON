static void init_av7110_av(struct av7110 *av7110)\r\n{\r\nint ret;\r\nstruct saa7146_dev *dev = av7110->dev;\r\nav7110->adac_type = DVB_ADAC_TI;\r\nret = av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);\r\nif (ret < 0)\r\nprintk("dvb-ttpci:cannot set internal volume to maximum:%d\n",ret);\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetMonitorType,\r\n1, (u16) av7110->display_ar);\r\nif (ret < 0)\r\nprintk("dvb-ttpci: unable to set aspect ratio\n");\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetPanScanType,\r\n1, av7110->display_panscan);\r\nif (ret < 0)\r\nprintk("dvb-ttpci: unable to set pan scan\n");\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 2, wss_cfg_4_3);\r\nif (ret < 0)\r\nprintk("dvb-ttpci: unable to configure 4:3 wss\n");\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 3, wss_cfg_16_9);\r\nif (ret < 0)\r\nprintk("dvb-ttpci: unable to configure 16:9 wss\n");\r\nret = av7710_set_video_mode(av7110, vidmode);\r\nif (ret < 0)\r\nprintk("dvb-ttpci:cannot set video mode:%d\n",ret);\r\nav7110->analog_tuner_flags = 0;\r\nav7110->current_input = 0;\r\nif (dev->pci->subsystem_vendor == 0x13c2 && dev->pci->subsystem_device == 0x000a)\r\nav7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 0);\r\nif (i2c_writereg(av7110, 0x20, 0x00, 0x00) == 1) {\r\nprintk ("dvb-ttpci: Crystal audio DAC @ card %d detected\n",\r\nav7110->dvb_adapter.num);\r\nav7110->adac_type = DVB_ADAC_CRYSTAL;\r\ni2c_writereg(av7110, 0x20, 0x01, 0xd2);\r\ni2c_writereg(av7110, 0x20, 0x02, 0x49);\r\ni2c_writereg(av7110, 0x20, 0x03, 0x00);\r\ni2c_writereg(av7110, 0x20, 0x04, 0x00);\r\n} else if (0 == av7110_init_analog_module(av7110)) {\r\n}\r\nelse if (dev->pci->subsystem_vendor == 0x110a) {\r\nprintk("dvb-ttpci: DVB-C w/o analog module @ card %d detected\n",\r\nav7110->dvb_adapter.num);\r\nav7110->adac_type = DVB_ADAC_NONE;\r\n}\r\nelse {\r\nav7110->adac_type = adac;\r\nprintk("dvb-ttpci: adac type set to %d @ card %d\n",\r\nav7110->adac_type, av7110->dvb_adapter.num);\r\n}\r\nif (av7110->adac_type == DVB_ADAC_NONE || av7110->adac_type == DVB_ADAC_MSP34x0) {\r\nret = av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, MainSwitch, 1, 0);\r\nif (ret < 0)\r\nprintk("dvb-ttpci:cannot switch on SCART(Main):%d\n",ret);\r\nret = av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, 1);\r\nif (ret < 0)\r\nprintk("dvb-ttpci:cannot switch on SCART(AD):%d\n",ret);\r\nif (rgb_on &&\r\n((av7110->dev->pci->subsystem_vendor == 0x110a) ||\r\n(av7110->dev->pci->subsystem_vendor == 0x13c2)) &&\r\n(av7110->dev->pci->subsystem_device == 0x0000)) {\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\r\n}\r\n}\r\nif (dev->pci->subsystem_vendor == 0x13c2 && dev->pci->subsystem_device == 0x000e)\r\nav7110_fw_cmd(av7110, COMTYPE_AUDIODAC, SpdifSwitch, 1, 0);\r\nret = av7110_set_volume(av7110, av7110->mixer.volume_left, av7110->mixer.volume_right);\r\nif (ret < 0)\r\nprintk("dvb-ttpci:cannot set volume :%d\n",ret);\r\n}\r\nstatic void recover_arm(struct av7110 *av7110)\r\n{\r\ndprintk(4, "%p\n",av7110);\r\nav7110_bootarm(av7110);\r\nmsleep(100);\r\ninit_av7110_av(av7110);\r\nif (av7110->recover)\r\nav7110->recover(av7110);\r\nrestart_feeds(av7110);\r\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\r\nav7110_check_ir_config(av7110, true);\r\n#endif\r\n}\r\nstatic void av7110_arm_sync(struct av7110 *av7110)\r\n{\r\nif (av7110->arm_thread)\r\nkthread_stop(av7110->arm_thread);\r\nav7110->arm_thread = NULL;\r\n}\r\nstatic int arm_thread(void *data)\r\n{\r\nstruct av7110 *av7110 = data;\r\nu16 newloops = 0;\r\nint timeout;\r\ndprintk(4, "%p\n",av7110);\r\nfor (;;) {\r\ntimeout = wait_event_interruptible_timeout(av7110->arm_wait,\r\nkthread_should_stop(), 5 * HZ);\r\nif (-ERESTARTSYS == timeout || kthread_should_stop()) {\r\nbreak;\r\n}\r\nif (!av7110->arm_ready)\r\ncontinue;\r\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\r\nav7110_check_ir_config(av7110, false);\r\n#endif\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nbreak;\r\nnewloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2);\r\nmutex_unlock(&av7110->dcomlock);\r\nif (newloops == av7110->arm_loops || av7110->arm_errors > 3) {\r\nprintk(KERN_ERR "dvb-ttpci: ARM crashed @ card %d\n",\r\nav7110->dvb_adapter.num);\r\nrecover_arm(av7110);\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nbreak;\r\nnewloops = rdebi(av7110, DEBINOSWAP, STATUS_LOOPS, 0, 2) - 1;\r\nmutex_unlock(&av7110->dcomlock);\r\n}\r\nav7110->arm_loops = newloops;\r\nav7110->arm_errors = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int DvbDmxFilterCallback(u8 *buffer1, size_t buffer1_len,\r\nu8 *buffer2, size_t buffer2_len,\r\nstruct dvb_demux_filter *dvbdmxfilter,\r\nenum dmx_success success,\r\nstruct av7110 *av7110)\r\n{\r\nif (!dvbdmxfilter->feed->demux->dmx.frontend)\r\nreturn 0;\r\nif (dvbdmxfilter->feed->demux->dmx.frontend->source == DMX_MEMORY_FE)\r\nreturn 0;\r\nswitch (dvbdmxfilter->type) {\r\ncase DMX_TYPE_SEC:\r\nif ((((buffer1[1] << 8) | buffer1[2]) & 0xfff) + 3 != buffer1_len)\r\nreturn 0;\r\nif (dvbdmxfilter->doneq) {\r\nstruct dmx_section_filter *filter = &dvbdmxfilter->filter;\r\nint i;\r\nu8 xor, neq = 0;\r\nfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\r\nxor = filter->filter_value[i] ^ buffer1[i];\r\nneq |= dvbdmxfilter->maskandnotmode[i] & xor;\r\n}\r\nif (!neq)\r\nreturn 0;\r\n}\r\nreturn dvbdmxfilter->feed->cb.sec(buffer1, buffer1_len,\r\nbuffer2, buffer2_len,\r\n&dvbdmxfilter->filter,\r\nDMX_OK);\r\ncase DMX_TYPE_TS:\r\nif (!(dvbdmxfilter->feed->ts_type & TS_PACKET))\r\nreturn 0;\r\nif (dvbdmxfilter->feed->ts_type & TS_PAYLOAD_ONLY)\r\nreturn dvbdmxfilter->feed->cb.ts(buffer1, buffer1_len,\r\nbuffer2, buffer2_len,\r\n&dvbdmxfilter->feed->feed.ts,\r\nDMX_OK);\r\nelse\r\nav7110_p2t_write(buffer1, buffer1_len,\r\ndvbdmxfilter->feed->pid,\r\n&av7110->p2t_filter[dvbdmxfilter->index]);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void print_time(char *s)\r\n{\r\n#ifdef DEBUG_TIMING\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nprintk("%s: %d.%d\n", s, (int)tv.tv_sec, (int)tv.tv_usec);\r\n#endif\r\n}\r\nstatic inline void start_debi_dma(struct av7110 *av7110, int dir,\r\nunsigned long addr, unsigned int len)\r\n{\r\ndprintk(8, "%c %08lx %u\n", dir == DEBI_READ ? 'R' : 'W', addr, len);\r\nif (saa7146_wait_for_debi_done(av7110->dev, 0)) {\r\nprintk(KERN_ERR "%s: saa7146_wait_for_debi_done timed out\n", __func__);\r\nreturn;\r\n}\r\nSAA7146_ISR_CLEAR(av7110->dev, MASK_19);\r\nSAA7146_IER_ENABLE(av7110->dev, MASK_19);\r\nif (len < 5)\r\nlen = 5;\r\nif (dir == DEBI_WRITE)\r\niwdebi(av7110, DEBISWAB, addr, 0, (len + 3) & ~3);\r\nelse\r\nirdebi(av7110, DEBISWAB, addr, 0, len);\r\n}\r\nstatic void debiirq(unsigned long cookie)\r\n{\r\nstruct av7110 *av7110 = (struct av7110 *)cookie;\r\nint type = av7110->debitype;\r\nint handle = (type >> 8) & 0x1f;\r\nunsigned int xfer = 0;\r\nprint_time("debi");\r\ndprintk(4, "type 0x%04x\n", type);\r\nif (type == -1) {\r\nprintk("DEBI irq oops @ %ld, psr:0x%08x, ssr:0x%08x\n",\r\njiffies, saa7146_read(av7110->dev, PSR),\r\nsaa7146_read(av7110->dev, SSR));\r\ngoto debi_done;\r\n}\r\nav7110->debitype = -1;\r\nswitch (type & 0xff) {\r\ncase DATA_TS_RECORD:\r\ndvb_dmx_swfilter_packets(&av7110->demux,\r\n(const u8 *) av7110->debi_virt,\r\nav7110->debilen / 188);\r\nxfer = RX_BUFF;\r\nbreak;\r\ncase DATA_PES_RECORD:\r\nif (av7110->demux.recording)\r\nav7110_record_cb(&av7110->p2t[handle],\r\n(u8 *) av7110->debi_virt,\r\nav7110->debilen);\r\nxfer = RX_BUFF;\r\nbreak;\r\ncase DATA_IPMPE:\r\ncase DATA_FSECTION:\r\ncase DATA_PIPING:\r\nif (av7110->handle2filter[handle])\r\nDvbDmxFilterCallback((u8 *)av7110->debi_virt,\r\nav7110->debilen, NULL, 0,\r\nav7110->handle2filter[handle],\r\nDMX_OK, av7110);\r\nxfer = RX_BUFF;\r\nbreak;\r\ncase DATA_CI_GET:\r\n{\r\nu8 *data = av7110->debi_virt;\r\nif ((data[0] < 2) && data[2] == 0xff) {\r\nint flags = 0;\r\nif (data[5] > 0)\r\nflags |= CA_CI_MODULE_PRESENT;\r\nif (data[5] > 5)\r\nflags |= CA_CI_MODULE_READY;\r\nav7110->ci_slot[data[0]].flags = flags;\r\n} else\r\nci_get_data(&av7110->ci_rbuffer,\r\nav7110->debi_virt,\r\nav7110->debilen);\r\nxfer = RX_BUFF;\r\nbreak;\r\n}\r\ncase DATA_COMMON_INTERFACE:\r\nCI_handle(av7110, (u8 *)av7110->debi_virt, av7110->debilen);\r\n#if 0\r\n{\r\nint i;\r\nprintk("av7110%d: ", av7110->num);\r\nprintk("%02x ", *(u8 *)av7110->debi_virt);\r\nprintk("%02x ", *(1+(u8 *)av7110->debi_virt));\r\nfor (i = 2; i < av7110->debilen; i++)\r\nprintk("%02x ", (*(i+(unsigned char *)av7110->debi_virt)));\r\nfor (i = 2; i < av7110->debilen; i++)\r\nprintk("%c", chtrans(*(i+(unsigned char *)av7110->debi_virt)));\r\nprintk("\n");\r\n}\r\n#endif\r\nxfer = RX_BUFF;\r\nbreak;\r\ncase DATA_DEBUG_MESSAGE:\r\n((s8*)av7110->debi_virt)[Reserved_SIZE - 1] = 0;\r\nprintk("%s\n", (s8 *) av7110->debi_virt);\r\nxfer = RX_BUFF;\r\nbreak;\r\ncase DATA_CI_PUT:\r\ndprintk(4, "debi DATA_CI_PUT\n");\r\ncase DATA_MPEG_PLAY:\r\ndprintk(4, "debi DATA_MPEG_PLAY\n");\r\ncase DATA_BMP_LOAD:\r\ndprintk(4, "debi DATA_BMP_LOAD\n");\r\nxfer = TX_BUFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndebi_done:\r\nspin_lock(&av7110->debilock);\r\nif (xfer)\r\niwdebi(av7110, DEBINOSWAP, xfer, 0, 2);\r\nARM_ClearMailBox(av7110);\r\nspin_unlock(&av7110->debilock);\r\n}\r\nstatic void gpioirq(unsigned long cookie)\r\n{\r\nstruct av7110 *av7110 = (struct av7110 *)cookie;\r\nu32 rxbuf, txbuf;\r\nint len;\r\nif (av7110->debitype != -1)\r\nprintk("dvb-ttpci: GPIO0 irq oops @ %ld, psr:0x%08x, ssr:0x%08x\n",\r\njiffies, saa7146_read(av7110->dev, PSR),\r\nsaa7146_read(av7110->dev, SSR));\r\nif (saa7146_wait_for_debi_done(av7110->dev, 0)) {\r\nprintk(KERN_ERR "%s: saa7146_wait_for_debi_done timed out\n", __func__);\r\nBUG();\r\n}\r\nspin_lock(&av7110->debilock);\r\nARM_ClearIrq(av7110);\r\nav7110->debitype = irdebi(av7110, DEBINOSWAP, IRQ_STATE, 0, 2);\r\nav7110->debilen = irdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\nrxbuf = irdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\r\ntxbuf = irdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nlen = (av7110->debilen + 3) & ~3;\r\nprint_time("gpio");\r\ndprintk(8, "GPIO0 irq 0x%04x %d\n", av7110->debitype, av7110->debilen);\r\nswitch (av7110->debitype & 0xff) {\r\ncase DATA_TS_PLAY:\r\ncase DATA_PES_PLAY:\r\nbreak;\r\ncase DATA_MPEG_VIDEO_EVENT:\r\n{\r\nu32 h_ar;\r\nstruct video_event event;\r\nav7110->video_size.w = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_WIDTH, 0, 2);\r\nh_ar = irdebi(av7110, DEBINOSWAP, STATUS_MPEG_HEIGHT_AR, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\r\nav7110->video_size.h = h_ar & 0xfff;\r\nevent.type = VIDEO_EVENT_SIZE_CHANGED;\r\nevent.u.size.w = av7110->video_size.w;\r\nevent.u.size.h = av7110->video_size.h;\r\nswitch ((h_ar >> 12) & 0xf)\r\n{\r\ncase 3:\r\nav7110->video_size.aspect_ratio = VIDEO_FORMAT_16_9;\r\nevent.u.size.aspect_ratio = VIDEO_FORMAT_16_9;\r\nav7110->videostate.video_format = VIDEO_FORMAT_16_9;\r\nbreak;\r\ncase 4:\r\nav7110->video_size.aspect_ratio = VIDEO_FORMAT_221_1;\r\nevent.u.size.aspect_ratio = VIDEO_FORMAT_221_1;\r\nav7110->videostate.video_format = VIDEO_FORMAT_221_1;\r\nbreak;\r\ndefault:\r\nav7110->video_size.aspect_ratio = VIDEO_FORMAT_4_3;\r\nevent.u.size.aspect_ratio = VIDEO_FORMAT_4_3;\r\nav7110->videostate.video_format = VIDEO_FORMAT_4_3;\r\n}\r\ndprintk(8, "GPIO0 irq: DATA_MPEG_VIDEO_EVENT: w/h/ar = %u/%u/%u\n",\r\nav7110->video_size.w, av7110->video_size.h,\r\nav7110->video_size.aspect_ratio);\r\ndvb_video_add_event(av7110, &event);\r\nbreak;\r\n}\r\ncase DATA_CI_PUT:\r\n{\r\nint avail;\r\nstruct dvb_ringbuffer *cibuf = &av7110->ci_wbuffer;\r\navail = dvb_ringbuffer_avail(cibuf);\r\nif (avail <= 2) {\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nbreak;\r\n}\r\nlen = DVB_RINGBUFFER_PEEK(cibuf, 0) << 8;\r\nlen |= DVB_RINGBUFFER_PEEK(cibuf, 1);\r\nif (avail < len + 2) {\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nbreak;\r\n}\r\nDVB_RINGBUFFER_SKIP(cibuf, 2);\r\ndvb_ringbuffer_read(cibuf, av7110->debi_virt, len);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\r\ndprintk(8, "DMA: CI\n");\r\nstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE + txbuf, len);\r\nspin_unlock(&av7110->debilock);\r\nwake_up(&cibuf->queue);\r\nreturn;\r\n}\r\ncase DATA_MPEG_PLAY:\r\nif (!av7110->playing) {\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nbreak;\r\n}\r\nlen = 0;\r\nif (av7110->debitype & 0x100) {\r\nspin_lock(&av7110->aout.lock);\r\nlen = av7110_pes_play(av7110->debi_virt, &av7110->aout, 2048);\r\nspin_unlock(&av7110->aout.lock);\r\n}\r\nif (len <= 0 && (av7110->debitype & 0x200)\r\n&&av7110->videostate.play_state != VIDEO_FREEZED) {\r\nspin_lock(&av7110->avout.lock);\r\nlen = av7110_pes_play(av7110->debi_virt, &av7110->avout, 2048);\r\nspin_unlock(&av7110->avout.lock);\r\n}\r\nif (len <= 0) {\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nbreak;\r\n}\r\ndprintk(8, "GPIO0 PES_PLAY len=%04x\n", len);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\r\ndprintk(8, "DMA: MPEG_PLAY\n");\r\nstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE + txbuf, len);\r\nspin_unlock(&av7110->debilock);\r\nreturn;\r\ncase DATA_BMP_LOAD:\r\nlen = av7110->debilen;\r\ndprintk(8, "gpio DATA_BMP_LOAD len %d\n", len);\r\nif (!len) {\r\nav7110->bmp_state = BMP_LOADED;\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, TX_BUFF, 0, 2);\r\nwake_up(&av7110->bmpq);\r\ndprintk(8, "gpio DATA_BMP_LOAD done\n");\r\nbreak;\r\n}\r\nif (len > av7110->bmplen)\r\nlen = av7110->bmplen;\r\nif (len > 2 * 1024)\r\nlen = 2 * 1024;\r\niwdebi(av7110, DEBINOSWAP, TX_LEN, len, 2);\r\niwdebi(av7110, DEBINOSWAP, IRQ_STATE_EXT, len, 2);\r\nmemcpy(av7110->debi_virt, av7110->bmpbuf+av7110->bmpp, len);\r\nav7110->bmpp += len;\r\nav7110->bmplen -= len;\r\ndprintk(8, "gpio DATA_BMP_LOAD DMA len %d\n", len);\r\nstart_debi_dma(av7110, DEBI_WRITE, DPRAM_BASE+txbuf, len);\r\nspin_unlock(&av7110->debilock);\r\nreturn;\r\ncase DATA_CI_GET:\r\ncase DATA_COMMON_INTERFACE:\r\ncase DATA_FSECTION:\r\ncase DATA_IPMPE:\r\ncase DATA_PIPING:\r\nif (!len || len > 4 * 1024) {\r\niwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\r\nbreak;\r\n}\r\ncase DATA_TS_RECORD:\r\ncase DATA_PES_RECORD:\r\ndprintk(8, "DMA: TS_REC etc.\n");\r\nstart_debi_dma(av7110, DEBI_READ, DPRAM_BASE+rxbuf, len);\r\nspin_unlock(&av7110->debilock);\r\nreturn;\r\ncase DATA_DEBUG_MESSAGE:\r\nif (!len || len > 0xff) {\r\niwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\r\nbreak;\r\n}\r\nstart_debi_dma(av7110, DEBI_READ, Reserved, len);\r\nspin_unlock(&av7110->debilock);\r\nreturn;\r\ncase DATA_IRCOMMAND:\r\nif (av7110->ir.ir_handler)\r\nav7110->ir.ir_handler(av7110,\r\nswahw32(irdebi(av7110, DEBINOSWAP, Reserved, 0, 4)));\r\niwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);\r\nbreak;\r\ndefault:\r\nprintk("dvb-ttpci: gpioirq unknown type=%d len=%d\n",\r\nav7110->debitype, av7110->debilen);\r\nbreak;\r\n}\r\nav7110->debitype = -1;\r\nARM_ClearMailBox(av7110);\r\nspin_unlock(&av7110->debilock);\r\n}\r\nstatic int dvb_osd_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\ndprintk(4, "%p\n", av7110);\r\nif (cmd == OSD_SEND_CMD)\r\nreturn av7110_osd_cmd(av7110, (osd_cmd_t *) parg);\r\nif (cmd == OSD_GET_CAPABILITY)\r\nreturn av7110_osd_capability(av7110, (osd_cap_t *) parg);\r\nreturn -EINVAL;\r\n}\r\nstatic inline int SetPIDs(struct av7110 *av7110, u16 vpid, u16 apid, u16 ttpid,\r\nu16 subpid, u16 pcrpid)\r\n{\r\nu16 aflags = 0;\r\ndprintk(4, "%p\n", av7110);\r\nif (vpid == 0x1fff || apid == 0x1fff ||\r\nttpid == 0x1fff || subpid == 0x1fff || pcrpid == 0x1fff) {\r\nvpid = apid = ttpid = subpid = pcrpid = 0;\r\nav7110->pids[DMX_PES_VIDEO] = 0;\r\nav7110->pids[DMX_PES_AUDIO] = 0;\r\nav7110->pids[DMX_PES_TELETEXT] = 0;\r\nav7110->pids[DMX_PES_PCR] = 0;\r\n}\r\nif (av7110->audiostate.bypass_mode)\r\naflags |= 0x8000;\r\nreturn av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, MultiPID, 6,\r\npcrpid, vpid, apid, ttpid, subpid, aflags);\r\n}\r\nint ChangePIDs(struct av7110 *av7110, u16 vpid, u16 apid, u16 ttpid,\r\nu16 subpid, u16 pcrpid)\r\n{\r\nint ret = 0;\r\ndprintk(4, "%p\n", av7110);\r\nif (mutex_lock_interruptible(&av7110->pid_mutex))\r\nreturn -ERESTARTSYS;\r\nif (!(vpid & 0x8000))\r\nav7110->pids[DMX_PES_VIDEO] = vpid;\r\nif (!(apid & 0x8000))\r\nav7110->pids[DMX_PES_AUDIO] = apid;\r\nif (!(ttpid & 0x8000))\r\nav7110->pids[DMX_PES_TELETEXT] = ttpid;\r\nif (!(pcrpid & 0x8000))\r\nav7110->pids[DMX_PES_PCR] = pcrpid;\r\nav7110->pids[DMX_PES_SUBTITLE] = 0;\r\nif (av7110->fe_synced) {\r\npcrpid = av7110->pids[DMX_PES_PCR];\r\nret = SetPIDs(av7110, vpid, apid, ttpid, subpid, pcrpid);\r\n}\r\nmutex_unlock(&av7110->pid_mutex);\r\nreturn ret;\r\n}\r\nstatic int StartHWFilter(struct dvb_demux_filter *dvbdmxfilter)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = dvbdmxfilter->feed;\r\nstruct av7110 *av7110 = dvbdmxfeed->demux->priv;\r\nu16 buf[20];\r\nint ret, i;\r\nu16 handle;\r\nu16 mode = 0xb96a;\r\ndprintk(4, "%p\n", av7110);\r\nif (av7110->full_ts)\r\nreturn 0;\r\nif (dvbdmxfilter->type == DMX_TYPE_SEC) {\r\nif (hw_sections) {\r\nbuf[4] = (dvbdmxfilter->filter.filter_value[0] << 8) |\r\ndvbdmxfilter->maskandmode[0];\r\nfor (i = 3; i < 18; i++)\r\nbuf[i + 4 - 2] =\r\n(dvbdmxfilter->filter.filter_value[i] << 8) |\r\ndvbdmxfilter->maskandmode[i];\r\nmode = 4;\r\n}\r\n} else if ((dvbdmxfeed->ts_type & TS_PACKET) &&\r\n!(dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)) {\r\nav7110_p2t_init(&av7110->p2t_filter[dvbdmxfilter->index], dvbdmxfeed);\r\n}\r\nbuf[0] = (COMTYPE_PID_FILTER << 8) + AddPIDFilter;\r\nbuf[1] = 16;\r\nbuf[2] = dvbdmxfeed->pid;\r\nbuf[3] = mode;\r\nret = av7110_fw_request(av7110, buf, 20, &handle, 1);\r\nif (ret != 0 || handle >= 32) {\r\nprintk("dvb-ttpci: %s error buf %04x %04x %04x %04x "\r\n"ret %d handle %04x\n",\r\n__func__, buf[0], buf[1], buf[2], buf[3],\r\nret, handle);\r\ndvbdmxfilter->hw_handle = 0xffff;\r\nif (!ret)\r\nret = -1;\r\nreturn ret;\r\n}\r\nav7110->handle2filter[handle] = dvbdmxfilter;\r\ndvbdmxfilter->hw_handle = handle;\r\nreturn ret;\r\n}\r\nstatic int StopHWFilter(struct dvb_demux_filter *dvbdmxfilter)\r\n{\r\nstruct av7110 *av7110 = dvbdmxfilter->feed->demux->priv;\r\nu16 buf[3];\r\nu16 answ[2];\r\nint ret;\r\nu16 handle;\r\ndprintk(4, "%p\n", av7110);\r\nif (av7110->full_ts)\r\nreturn 0;\r\nhandle = dvbdmxfilter->hw_handle;\r\nif (handle >= 32) {\r\nprintk("%s tried to stop invalid filter %04x, filter type = %x\n",\r\n__func__, handle, dvbdmxfilter->type);\r\nreturn -EINVAL;\r\n}\r\nav7110->handle2filter[handle] = NULL;\r\nbuf[0] = (COMTYPE_PID_FILTER << 8) + DelPIDFilter;\r\nbuf[1] = 1;\r\nbuf[2] = handle;\r\nret = av7110_fw_request(av7110, buf, 3, answ, 2);\r\nif (ret != 0 || answ[1] != handle) {\r\nprintk("dvb-ttpci: %s error cmd %04x %04x %04x ret %x "\r\n"resp %04x %04x pid %d\n",\r\n__func__, buf[0], buf[1], buf[2], ret,\r\nansw[0], answ[1], dvbdmxfilter->feed->pid);\r\nif (!ret)\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dvb_feed_start_pid(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct av7110 *av7110 = dvbdmx->priv;\r\nu16 *pid = dvbdmx->pids, npids[5];\r\nint i;\r\nint ret = 0;\r\ndprintk(4, "%p\n", av7110);\r\nnpids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;\r\ni = dvbdmxfeed->pes_type;\r\nnpids[i] = (pid[i]&0x8000) ? 0 : pid[i];\r\nif ((i == 2) && npids[i] && (dvbdmxfeed->ts_type & TS_PACKET)) {\r\nnpids[i] = 0;\r\nret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\r\nif (!ret)\r\nret = StartHWFilter(dvbdmxfeed->filter);\r\nreturn ret;\r\n}\r\nif (dvbdmxfeed->pes_type <= 2 || dvbdmxfeed->pes_type == 4) {\r\nret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (dvbdmxfeed->pes_type < 2 && npids[0])\r\nif (av7110->fe_synced)\r\n{\r\nret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((dvbdmxfeed->ts_type & TS_PACKET) && !av7110->full_ts) {\r\nif (dvbdmxfeed->pes_type == 0 && !(dvbdmx->pids[0] & 0x8000))\r\nret = av7110_av_start_record(av7110, RP_AUDIO, dvbdmxfeed);\r\nif (dvbdmxfeed->pes_type == 1 && !(dvbdmx->pids[1] & 0x8000))\r\nret = av7110_av_start_record(av7110, RP_VIDEO, dvbdmxfeed);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dvb_feed_stop_pid(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct av7110 *av7110 = dvbdmx->priv;\r\nu16 *pid = dvbdmx->pids, npids[5];\r\nint i;\r\nint ret = 0;\r\ndprintk(4, "%p\n", av7110);\r\nif (dvbdmxfeed->pes_type <= 1) {\r\nret = av7110_av_stop(av7110, dvbdmxfeed->pes_type ? RP_VIDEO : RP_AUDIO);\r\nif (ret)\r\nreturn ret;\r\nif (!av7110->rec_mode)\r\ndvbdmx->recording = 0;\r\nif (!av7110->playing)\r\ndvbdmx->playing = 0;\r\n}\r\nnpids[0] = npids[1] = npids[2] = npids[3] = npids[4] = 0xffff;\r\ni = dvbdmxfeed->pes_type;\r\nswitch (i) {\r\ncase 2:\r\nif (dvbdmxfeed->ts_type & TS_PACKET)\r\nret = StopHWFilter(dvbdmxfeed->filter);\r\nnpids[2] = 0;\r\nbreak;\r\ncase 0:\r\ncase 1:\r\ncase 4:\r\nif (!pids_off)\r\nreturn 0;\r\nnpids[i] = (pid[i]&0x8000) ? 0 : pid[i];\r\nbreak;\r\n}\r\nif (!ret)\r\nret = ChangePIDs(av7110, npids[1], npids[0], npids[2], npids[3], npids[4]);\r\nreturn ret;\r\n}\r\nstatic int av7110_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct av7110 *av7110 = demux->priv;\r\nint ret = 0;\r\ndprintk(4, "%p\n", av7110);\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nif (!av7110->full_ts && feed->pid > 0x1fff)\r\nreturn -EINVAL;\r\nif (feed->type == DMX_TYPE_TS) {\r\nif ((feed->ts_type & TS_DECODER) &&\r\n(feed->pes_type <= DMX_PES_PCR)) {\r\nswitch (demux->dmx.frontend->source) {\r\ncase DMX_MEMORY_FE:\r\nif (feed->ts_type & TS_DECODER)\r\nif (feed->pes_type < 2 &&\r\n!(demux->pids[0] & 0x8000) &&\r\n!(demux->pids[1] & 0x8000)) {\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\r\nret = av7110_av_start_play(av7110,RP_AV);\r\nif (!ret)\r\ndemux->playing = 1;\r\n}\r\nbreak;\r\ndefault:\r\nret = dvb_feed_start_pid(feed);\r\nbreak;\r\n}\r\n} else if ((feed->ts_type & TS_PACKET) &&\r\n(demux->dmx.frontend->source != DMX_MEMORY_FE)) {\r\nret = StartHWFilter(feed->filter);\r\n}\r\n}\r\nif (av7110->full_ts) {\r\nbudget_start_feed(feed);\r\nreturn ret;\r\n}\r\nif (feed->type == DMX_TYPE_SEC) {\r\nint i;\r\nfor (i = 0; i < demux->filternum; i++) {\r\nif (demux->filter[i].state != DMX_STATE_READY)\r\ncontinue;\r\nif (demux->filter[i].type != DMX_TYPE_SEC)\r\ncontinue;\r\nif (demux->filter[i].filter.parent != &feed->feed.sec)\r\ncontinue;\r\ndemux->filter[i].state = DMX_STATE_GO;\r\nif (demux->dmx.frontend->source != DMX_MEMORY_FE) {\r\nret = StartHWFilter(&demux->filter[i]);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct av7110 *av7110 = demux->priv;\r\nint i, rc, ret = 0;\r\ndprintk(4, "%p\n", av7110);\r\nif (feed->type == DMX_TYPE_TS) {\r\nif (feed->ts_type & TS_DECODER) {\r\nif (feed->pes_type >= DMX_PES_OTHER ||\r\n!demux->pesfilter[feed->pes_type])\r\nreturn -EINVAL;\r\ndemux->pids[feed->pes_type] |= 0x8000;\r\ndemux->pesfilter[feed->pes_type] = NULL;\r\n}\r\nif (feed->ts_type & TS_DECODER &&\r\nfeed->pes_type < DMX_PES_OTHER) {\r\nret = dvb_feed_stop_pid(feed);\r\n} else\r\nif ((feed->ts_type & TS_PACKET) &&\r\n(demux->dmx.frontend->source != DMX_MEMORY_FE))\r\nret = StopHWFilter(feed->filter);\r\n}\r\nif (av7110->full_ts) {\r\nbudget_stop_feed(feed);\r\nreturn ret;\r\n}\r\nif (feed->type == DMX_TYPE_SEC) {\r\nfor (i = 0; i<demux->filternum; i++) {\r\nif (demux->filter[i].state == DMX_STATE_GO &&\r\ndemux->filter[i].filter.parent == &feed->feed.sec) {\r\ndemux->filter[i].state = DMX_STATE_READY;\r\nif (demux->dmx.frontend->source != DMX_MEMORY_FE) {\r\nrc = StopHWFilter(&demux->filter[i]);\r\nif (!ret)\r\nret = rc;\r\n}\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void restart_feeds(struct av7110 *av7110)\r\n{\r\nstruct dvb_demux *dvbdmx = &av7110->demux;\r\nstruct dvb_demux_feed *feed;\r\nint mode;\r\nint feeding;\r\nint i, j;\r\ndprintk(4, "%p\n", av7110);\r\nmode = av7110->playing;\r\nav7110->playing = 0;\r\nav7110->rec_mode = 0;\r\nfeeding = av7110->feeding1;\r\nfor (i = 0; i < dvbdmx->feednum; i++) {\r\nfeed = &dvbdmx->feed[i];\r\nif (feed->state == DMX_STATE_GO) {\r\nif (feed->type == DMX_TYPE_SEC) {\r\nfor (j = 0; j < dvbdmx->filternum; j++) {\r\nif (dvbdmx->filter[j].type != DMX_TYPE_SEC)\r\ncontinue;\r\nif (dvbdmx->filter[j].filter.parent != &feed->feed.sec)\r\ncontinue;\r\nif (dvbdmx->filter[j].state == DMX_STATE_GO)\r\ndvbdmx->filter[j].state = DMX_STATE_READY;\r\n}\r\n}\r\nav7110_start_feed(feed);\r\n}\r\n}\r\nav7110->feeding1 = feeding;\r\nif (mode)\r\nav7110_av_start_play(av7110, mode);\r\n}\r\nstatic int dvb_get_stc(struct dmx_demux *demux, unsigned int num,\r\nuint64_t *stc, unsigned int *base)\r\n{\r\nint ret;\r\nu16 fwstc[4];\r\nu16 tag = ((COMTYPE_REQUEST << 8) + ReqSTC);\r\nstruct dvb_demux *dvbdemux;\r\nstruct av7110 *av7110;\r\nBUG_ON(!demux);\r\ndvbdemux = demux->priv;\r\nBUG_ON(!dvbdemux);\r\nav7110 = dvbdemux->priv;\r\ndprintk(4, "%p\n", av7110);\r\nif (num != 0)\r\nreturn -EINVAL;\r\nret = av7110_fw_request(av7110, &tag, 0, fwstc, 4);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: av7110_fw_request error\n", __func__);\r\nreturn ret;\r\n}\r\ndprintk(2, "fwstc = %04hx %04hx %04hx %04hx\n",\r\nfwstc[0], fwstc[1], fwstc[2], fwstc[3]);\r\n*stc = (((uint64_t) ((fwstc[3] & 0x8000) >> 15)) << 32) |\r\n(((uint64_t) fwstc[1]) << 16) | ((uint64_t) fwstc[0]);\r\n*base = 1;\r\ndprintk(4, "stc = %lu\n", (unsigned long)*stc);\r\nreturn 0;\r\n}\r\nstatic int av7110_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nreturn Set22K(av7110, 1);\r\ncase SEC_TONE_OFF:\r\nreturn Set22K(av7110, 0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int av7110_diseqc_send_master_cmd(struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd* cmd)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nreturn av7110_diseqc_send(av7110, cmd->msg_len, cmd->msg, -1);\r\n}\r\nstatic int av7110_diseqc_send_burst(struct dvb_frontend* fe,\r\nenum fe_sec_mini_cmd minicmd)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nreturn av7110_diseqc_send(av7110, 0, NULL, minicmd);\r\n}\r\nstatic int stop_ts_capture(struct av7110 *budget)\r\n{\r\ndprintk(2, "budget: %p\n", budget);\r\nif (--budget->feeding1)\r\nreturn budget->feeding1;\r\nsaa7146_write(budget->dev, MC1, MASK_20);\r\nSAA7146_IER_DISABLE(budget->dev, MASK_10);\r\nSAA7146_ISR_CLEAR(budget->dev, MASK_10);\r\nreturn 0;\r\n}\r\nstatic int start_ts_capture(struct av7110 *budget)\r\n{\r\nunsigned y;\r\ndprintk(2, "budget: %p\n", budget);\r\nif (budget->feeding1)\r\nreturn ++budget->feeding1;\r\nfor (y = 0; y < TS_HEIGHT; y++)\r\nmemset(budget->grabbing + y * TS_WIDTH, 0x00, TS_WIDTH);\r\nbudget->ttbp = 0;\r\nSAA7146_ISR_CLEAR(budget->dev, MASK_10);\r\nSAA7146_IER_ENABLE(budget->dev, MASK_10);\r\nsaa7146_write(budget->dev, MC1, (MASK_04 | MASK_20));\r\nreturn ++budget->feeding1;\r\n}\r\nstatic int budget_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct av7110 *budget = demux->priv;\r\nint status;\r\ndprintk(2, "av7110: %p\n", budget);\r\nspin_lock(&budget->feedlock1);\r\nfeed->pusi_seen = 0;\r\nstatus = start_ts_capture(budget);\r\nspin_unlock(&budget->feedlock1);\r\nreturn status;\r\n}\r\nstatic int budget_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct av7110 *budget = demux->priv;\r\nint status;\r\ndprintk(2, "budget: %p\n", budget);\r\nspin_lock(&budget->feedlock1);\r\nstatus = stop_ts_capture(budget);\r\nspin_unlock(&budget->feedlock1);\r\nreturn status;\r\n}\r\nstatic void vpeirq(unsigned long cookie)\r\n{\r\nstruct av7110 *budget = (struct av7110 *)cookie;\r\nu8 *mem = (u8 *) (budget->grabbing);\r\nu32 olddma = budget->ttbp;\r\nu32 newdma = saa7146_read(budget->dev, PCI_VDP3);\r\nstruct dvb_demux *demux = budget->full_ts ? &budget->demux : &budget->demux1;\r\nnewdma -= newdma % 188;\r\nif (newdma >= TS_BUFLEN)\r\nreturn;\r\nbudget->ttbp = newdma;\r\nif (!budget->feeding1 || (newdma == olddma))\r\nreturn;\r\npci_dma_sync_sg_for_cpu(budget->dev->pci, budget->pt.slist, budget->pt.nents, PCI_DMA_FROMDEVICE);\r\n#if 0\r\nprintk("vpeirq: %02x Event Counter 1 0x%04x\n",\r\nmem[olddma],\r\nsaa7146_read(budget->dev, EC1R) & 0x3fff);\r\n#endif\r\nif (newdma > olddma)\r\ndvb_dmx_swfilter_packets(demux, mem + olddma, (newdma - olddma) / 188);\r\nelse {\r\ndvb_dmx_swfilter_packets(demux, mem + olddma, (TS_BUFLEN - olddma) / 188);\r\ndvb_dmx_swfilter_packets(demux, mem, newdma / 188);\r\n}\r\n}\r\nstatic int av7110_register(struct av7110 *av7110)\r\n{\r\nint ret, i;\r\nstruct dvb_demux *dvbdemux = &av7110->demux;\r\nstruct dvb_demux *dvbdemux1 = &av7110->demux1;\r\ndprintk(4, "%p\n", av7110);\r\nif (av7110->registered)\r\nreturn -1;\r\nav7110->registered = 1;\r\ndvbdemux->priv = (void *) av7110;\r\nfor (i = 0; i < 32; i++)\r\nav7110->handle2filter[i] = NULL;\r\ndvbdemux->filternum = (av7110->full_ts) ? 256 : 32;\r\ndvbdemux->feednum = (av7110->full_ts) ? 256 : 32;\r\ndvbdemux->start_feed = av7110_start_feed;\r\ndvbdemux->stop_feed = av7110_stop_feed;\r\ndvbdemux->write_to_decoder = av7110_write_to_decoder;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\ndvb_dmx_init(&av7110->demux);\r\nav7110->demux.dmx.get_stc = dvb_get_stc;\r\nav7110->dmxdev.filternum = (av7110->full_ts) ? 256 : 32;\r\nav7110->dmxdev.demux = &dvbdemux->dmx;\r\nav7110->dmxdev.capabilities = 0;\r\ndvb_dmxdev_init(&av7110->dmxdev, &av7110->dvb_adapter);\r\nav7110->hw_frontend.source = DMX_FRONTEND_0;\r\nret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->hw_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\nav7110->mem_frontend.source = DMX_MEMORY_FE;\r\nret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &av7110->mem_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx,\r\n&av7110->hw_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\nav7110_av_register(av7110);\r\nav7110_ca_register(av7110);\r\n#ifdef CONFIG_DVB_AV7110_OSD\r\ndvb_register_device(&av7110->dvb_adapter, &av7110->osd_dev,\r\n&dvbdev_osd, av7110, DVB_DEVICE_OSD);\r\n#endif\r\ndvb_net_init(&av7110->dvb_adapter, &av7110->dvb_net, &dvbdemux->dmx);\r\nif (budgetpatch) {\r\ndvbdemux1->priv = (void *) av7110;\r\ndvbdemux1->filternum = 256;\r\ndvbdemux1->feednum = 256;\r\ndvbdemux1->start_feed = budget_start_feed;\r\ndvbdemux1->stop_feed = budget_stop_feed;\r\ndvbdemux1->write_to_decoder = NULL;\r\ndvbdemux1->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\ndvb_dmx_init(&av7110->demux1);\r\nav7110->dmxdev1.filternum = 256;\r\nav7110->dmxdev1.demux = &dvbdemux1->dmx;\r\nav7110->dmxdev1.capabilities = 0;\r\ndvb_dmxdev_init(&av7110->dmxdev1, &av7110->dvb_adapter);\r\ndvb_net_init(&av7110->dvb_adapter, &av7110->dvb_net1, &dvbdemux1->dmx);\r\nprintk("dvb-ttpci: additional demux1 for budget-patch registered\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void dvb_unregister(struct av7110 *av7110)\r\n{\r\nstruct dvb_demux *dvbdemux = &av7110->demux;\r\nstruct dvb_demux *dvbdemux1 = &av7110->demux1;\r\ndprintk(4, "%p\n", av7110);\r\nif (!av7110->registered)\r\nreturn;\r\nif (budgetpatch) {\r\ndvb_net_release(&av7110->dvb_net1);\r\ndvbdemux->dmx.close(&dvbdemux1->dmx);\r\ndvb_dmxdev_release(&av7110->dmxdev1);\r\ndvb_dmx_release(&av7110->demux1);\r\n}\r\ndvb_net_release(&av7110->dvb_net);\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &av7110->mem_frontend);\r\ndvb_dmxdev_release(&av7110->dmxdev);\r\ndvb_dmx_release(&av7110->demux);\r\nif (av7110->fe != NULL) {\r\ndvb_unregister_frontend(av7110->fe);\r\ndvb_frontend_detach(av7110->fe);\r\n}\r\ndvb_unregister_device(av7110->osd_dev);\r\nav7110_av_unregister(av7110);\r\nav7110_ca_unregister(av7110);\r\n}\r\nint i2c_writereg(struct av7110 *av7110, u8 id, u8 reg, u8 val)\r\n{\r\nu8 msg[2] = { reg, val };\r\nstruct i2c_msg msgs;\r\nmsgs.flags = 0;\r\nmsgs.addr = id / 2;\r\nmsgs.len = 2;\r\nmsgs.buf = msg;\r\nreturn i2c_transfer(&av7110->i2c_adap, &msgs, 1);\r\n}\r\nu8 i2c_readreg(struct av7110 *av7110, u8 id, u8 reg)\r\n{\r\nu8 mm1[] = {0x00};\r\nu8 mm2[] = {0x00};\r\nstruct i2c_msg msgs[2];\r\nmsgs[0].flags = 0;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[0].addr = msgs[1].addr = id / 2;\r\nmm1[0] = reg;\r\nmsgs[0].len = 1; msgs[1].len = 1;\r\nmsgs[0].buf = mm1; msgs[1].buf = mm2;\r\ni2c_transfer(&av7110->i2c_adap, msgs, 2);\r\nreturn mm2[0];\r\n}\r\nstatic int check_firmware(struct av7110* av7110)\r\n{\r\nu32 crc = 0, len = 0;\r\nunsigned char *ptr;\r\nptr = av7110->bin_fw;\r\nif (ptr[0] != 'A' || ptr[1] != 'V' ||\r\nptr[2] != 'F' || ptr[3] != 'W') {\r\nprintk("dvb-ttpci: this is not an av7110 firmware\n");\r\nreturn -EINVAL;\r\n}\r\nptr += 4;\r\ncrc = get_unaligned_be32(ptr);\r\nptr += 4;\r\nlen = get_unaligned_be32(ptr);\r\nptr += 4;\r\nif (len >= 512) {\r\nprintk("dvb-ttpci: dpram file is way too big.\n");\r\nreturn -EINVAL;\r\n}\r\nif (crc != crc32_le(0, ptr, len)) {\r\nprintk("dvb-ttpci: crc32 of dpram file does not match.\n");\r\nreturn -EINVAL;\r\n}\r\nav7110->bin_dpram = ptr;\r\nav7110->size_dpram = len;\r\nptr += len;\r\ncrc = get_unaligned_be32(ptr);\r\nptr += 4;\r\nlen = get_unaligned_be32(ptr);\r\nptr += 4;\r\nif (len <= 200000 || len >= 300000 ||\r\nlen > ((av7110->bin_fw + av7110->size_fw) - ptr)) {\r\nprintk("dvb-ttpci: root file has strange size (%d). aborting.\n", len);\r\nreturn -EINVAL;\r\n}\r\nif( crc != crc32_le(0, ptr, len)) {\r\nprintk("dvb-ttpci: crc32 of root file does not match.\n");\r\nreturn -EINVAL;\r\n}\r\nav7110->bin_root = ptr;\r\nav7110->size_root = len;\r\nreturn 0;\r\n}\r\nstatic void put_firmware(struct av7110* av7110)\r\n{\r\nvfree(av7110->bin_fw);\r\n}\r\nstatic int get_firmware(struct av7110* av7110)\r\n{\r\nint ret;\r\nconst struct firmware *fw;\r\nret = request_firmware(&fw, "dvb-ttpci-01.fw", &av7110->dev->pci->dev);\r\nif (ret) {\r\nif (ret == -ENOENT) {\r\nprintk(KERN_ERR "dvb-ttpci: could not load firmware,"\r\n" file not found: dvb-ttpci-01.fw\n");\r\nprintk(KERN_ERR "dvb-ttpci: usually this should be in "\r\n"/usr/lib/hotplug/firmware or /lib/firmware\n");\r\nprintk(KERN_ERR "dvb-ttpci: and can be downloaded from"\r\n" http://www.linuxtv.org/download/dvb/firmware/\n");\r\n} else\r\nprintk(KERN_ERR "dvb-ttpci: cannot request firmware"\r\n" (error %i)\n", ret);\r\nreturn -EINVAL;\r\n}\r\nif (fw->size <= 200000) {\r\nprintk("dvb-ttpci: this firmware is way too small.\n");\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nav7110->bin_fw = vmalloc(fw->size);\r\nif (NULL == av7110->bin_fw) {\r\ndprintk(1, "out of memory\n");\r\nrelease_firmware(fw);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(av7110->bin_fw, fw->data, fw->size);\r\nav7110->size_fw = fw->size;\r\nif ((ret = check_firmware(av7110)))\r\nvfree(av7110->bin_fw);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int alps_bsrv2_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu8 pwr = 0;\r\nu8 buf[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = buf, .len = sizeof(buf) };\r\nu32 div = (p->frequency + 479500) / 125;\r\nif (p->frequency > 2000000)\r\npwr = 3;\r\nelse if (p->frequency > 1800000)\r\npwr = 2;\r\nelse if (p->frequency > 1600000)\r\npwr = 1;\r\nelse if (p->frequency > 1200000)\r\npwr = 0;\r\nelse if (p->frequency >= 1100000)\r\npwr = 1;\r\nelse\r\npwr = 2;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = ((div & 0x18000) >> 10) | 0x95;\r\nbuf[3] = (pwr << 6) | 0x30;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (p->frequency + 35937500 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x85 | ((div >> 10) & 0x60);\r\ndata[3] = (p->frequency < 174000000 ? 0x88 : p->frequency < 470000000 ? 0x84 : 0x81);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int grundig_29504_451_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = p->frequency / 125;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x8e;\r\ndata[3] = 0x00;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int philips_cd1516_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div;\r\nu32 f = p->frequency;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (f + 36125000 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x8e;\r\ndata[3] = (f < 174000000 ? 0xa1 : f < 470000000 ? 0x92 : 0x34);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdlb7_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div, pwr;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x60, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (p->frequency + 36200000) / 166666;\r\nif (p->frequency <= 782000000)\r\npwr = 1;\r\nelse\r\npwr = 2;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x85;\r\ndata[3] = pwr << 6;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdlb7_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\r\n{\r\n#if IS_ENABLED(CONFIG_DVB_SP8870)\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nreturn request_firmware(fw, name, &av7110->dev->pci->dev);\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int nexusca_stv0297_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x63, .flags = 0, .buf = data, .len = sizeof(data) };\r\nstruct i2c_msg readmsg = { .addr = 0x63, .flags = I2C_M_RD, .buf = data, .len = 1 };\r\nint i;\r\ndiv = (p->frequency + 36150000 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0xce;\r\nif (p->frequency < 45000000)\r\nreturn -EINVAL;\r\nelse if (p->frequency < 137000000)\r\ndata[3] = 0x01;\r\nelse if (p->frequency < 403000000)\r\ndata[3] = 0x02;\r\nelse if (p->frequency < 860000000)\r\ndata[3] = 0x04;\r\nelse\r\nreturn -EINVAL;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &msg, 1) != 1) {\r\nprintk("nexusca: pll transfer failed!\n");\r\nreturn -EIO;\r\n}\r\nfor(i = 0; i < 20; i++) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&av7110->i2c_adap, &readmsg, 1) == 1)\r\nif (data[0] & 0x40) break;\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int grundig_29504_401_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nu32 div;\r\nu8 cfg, cpump, band_select;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (36125000 + p->frequency) / 166666;\r\ncfg = 0x88;\r\nif (p->frequency < 175000000)\r\ncpump = 2;\r\nelse if (p->frequency < 390000000)\r\ncpump = 1;\r\nelse if (p->frequency < 470000000)\r\ncpump = 2;\r\nelse if (p->frequency < 750000000)\r\ncpump = 1;\r\nelse\r\ncpump = 3;\r\nif (p->frequency < 175000000)\r\nband_select = 0x0e;\r\nelse if (p->frequency < 470000000)\r\nband_select = 0x05;\r\nelse\r\nband_select = 0x03;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = ((div >> 10) & 0x60) | cfg;\r\ndata[3] = (cpump << 6) | band_select;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&av7110->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int av7110_fe_lock_fix(struct av7110 *av7110, enum fe_status status)\r\n{\r\nint ret = 0;\r\nint synced = (status & FE_HAS_LOCK) ? 1 : 0;\r\nav7110->fe_status = status;\r\nif (av7110->fe_synced == synced)\r\nreturn 0;\r\nif (av7110->playing) {\r\nav7110->fe_synced = synced;\r\nreturn 0;\r\n}\r\nif (mutex_lock_interruptible(&av7110->pid_mutex))\r\nreturn -ERESTARTSYS;\r\nif (synced) {\r\nret = SetPIDs(av7110, av7110->pids[DMX_PES_VIDEO],\r\nav7110->pids[DMX_PES_AUDIO],\r\nav7110->pids[DMX_PES_TELETEXT], 0,\r\nav7110->pids[DMX_PES_PCR]);\r\nif (!ret)\r\nret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\r\n} else {\r\nret = SetPIDs(av7110, 0, 0, 0, 0, 0);\r\nif (!ret) {\r\nret = av7110_fw_cmd(av7110, COMTYPE_PID_FILTER, FlushTSQueue, 0);\r\nif (!ret)\r\nret = av7110_wait_msgstate(av7110, GPMQBusy);\r\n}\r\n}\r\nif (!ret)\r\nav7110->fe_synced = synced;\r\nmutex_unlock(&av7110->pid_mutex);\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret)\r\nret = av7110->fe_set_frontend(fe);\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_init(struct dvb_frontend* fe)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret)\r\nret = av7110->fe_init(fe);\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110->fe_read_status(fe, status);\r\nif (!ret)\r\nif (((*status ^ av7110->fe_status) & FE_HAS_LOCK) && (*status & FE_HAS_LOCK))\r\nret = av7110_fe_lock_fix(av7110, *status);\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_diseqc_reset_overload(struct dvb_frontend* fe)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret)\r\nret = av7110->fe_diseqc_reset_overload(fe);\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_diseqc_send_master_cmd(struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd* cmd)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret) {\r\nav7110->saved_master_cmd = *cmd;\r\nret = av7110->fe_diseqc_send_master_cmd(fe, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd minicmd)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret) {\r\nav7110->saved_minicmd = minicmd;\r\nret = av7110->fe_diseqc_send_burst(fe, minicmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret) {\r\nav7110->saved_tone = tone;\r\nret = av7110->fe_set_tone(fe, tone);\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret) {\r\nav7110->saved_voltage = voltage;\r\nret = av7110->fe_set_voltage(fe, voltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_fe_dishnetwork_send_legacy_command(struct dvb_frontend* fe, unsigned long cmd)\r\n{\r\nstruct av7110* av7110 = fe->dvb->priv;\r\nint ret = av7110_fe_lock_fix(av7110, 0);\r\nif (!ret)\r\nret = av7110->fe_dishnetwork_send_legacy_command(fe, cmd);\r\nreturn ret;\r\n}\r\nstatic void dvb_s_recover(struct av7110* av7110)\r\n{\r\nav7110_fe_init(av7110->fe);\r\nav7110_fe_set_voltage(av7110->fe, av7110->saved_voltage);\r\nif (av7110->saved_master_cmd.msg_len) {\r\nmsleep(20);\r\nav7110_fe_diseqc_send_master_cmd(av7110->fe, &av7110->saved_master_cmd);\r\n}\r\nmsleep(20);\r\nav7110_fe_diseqc_send_burst(av7110->fe, av7110->saved_minicmd);\r\nmsleep(20);\r\nav7110_fe_set_tone(av7110->fe, av7110->saved_tone);\r\nav7110_fe_set_frontend(av7110->fe);\r\n}\r\nstatic u8 read_pwm(struct av7110* av7110)\r\n{\r\nu8 b = 0xff;\r\nu8 pwm;\r\nstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\r\n{ .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\r\nif ((i2c_transfer(&av7110->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\r\npwm = 0x48;\r\nreturn pwm;\r\n}\r\nstatic int frontend_init(struct av7110 *av7110)\r\n{\r\nint ret;\r\nif (av7110->dev->pci->subsystem_vendor == 0x110a) {\r\nswitch(av7110->dev->pci->subsystem_device) {\r\ncase 0x0000:\r\nav7110->fe = dvb_attach(ves1820_attach, &philips_cd1516_config,\r\n&av7110->i2c_adap, read_pwm(av7110));\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = philips_cd1516_tuner_set_params;\r\n}\r\nbreak;\r\n}\r\n} else if (av7110->dev->pci->subsystem_vendor == 0x13c2) {\r\nswitch(av7110->dev->pci->subsystem_device) {\r\ncase 0x0000:\r\ncase 0x0003:\r\ncase 0x1002:\r\nav7110->fe = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\r\nav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\r\nav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\r\nav7110->fe->ops.set_tone = av7110_set_tone;\r\nav7110->recover = dvb_s_recover;\r\nbreak;\r\n}\r\nav7110->fe = dvb_attach(stv0299_attach, &alps_bsru6_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\r\nav7110->fe->tuner_priv = &av7110->i2c_adap;\r\nav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\r\nav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\r\nav7110->fe->ops.set_tone = av7110_set_tone;\r\nav7110->recover = dvb_s_recover;\r\nbreak;\r\n}\r\nav7110->fe = dvb_attach(tda8083_attach, &grundig_29504_451_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\r\nav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\r\nav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\r\nav7110->fe->ops.set_tone = av7110_set_tone;\r\nav7110->recover = dvb_s_recover;\r\nbreak;\r\n}\r\nswitch(av7110->dev->pci->subsystem_device) {\r\ncase 0x0000:\r\nav7110->fe = dvb_attach(ves1820_attach, &philips_cd1516_config, &av7110->i2c_adap,\r\nread_pwm(av7110));\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = philips_cd1516_tuner_set_params;\r\n}\r\nbreak;\r\ncase 0x0003:\r\nav7110->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &av7110->i2c_adap,\r\nread_pwm(av7110));\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x0001:\r\nav7110->fe = dvb_attach(sp8870_attach, &alps_tdlb7_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_tdlb7_tuner_set_params;\r\nbreak;\r\n}\r\ncase 0x0008:\r\nav7110->fe = dvb_attach(l64781_attach, &grundig_29504_401_config, &av7110->i2c_adap);\r\nif (av7110->fe)\r\nav7110->fe->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\r\nbreak;\r\ncase 0x0002:\r\nav7110->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &av7110->i2c_adap, read_pwm(av7110));\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\r\n}\r\nbreak;\r\ncase 0x0004:\r\nav7110->fe = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\r\nav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\r\nav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\r\nav7110->fe->ops.set_tone = av7110_set_tone;\r\nav7110->recover = dvb_s_recover;\r\n}\r\nbreak;\r\ncase 0x0006:\r\nav7110->fe = dvb_attach(tda8083_attach, &grundig_29504_451_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\r\nav7110->fe->ops.diseqc_send_master_cmd = av7110_diseqc_send_master_cmd;\r\nav7110->fe->ops.diseqc_send_burst = av7110_diseqc_send_burst;\r\nav7110->fe->ops.set_tone = av7110_set_tone;\r\nav7110->recover = dvb_s_recover;\r\n}\r\nbreak;\r\ncase 0x000A:\r\nav7110->fe = dvb_attach(stv0297_attach, &nexusca_stv0297_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = nexusca_stv0297_tuner_set_params;\r\nsaa7146_setgpio(av7110->dev, 1, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(av7110->dev, 3, SAA7146_GPIO_OUTLO);\r\nav7110->dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x000E:\r\nav7110->fe = dvb_attach(stv0299_attach, &alps_bsbe1_config, &av7110->i2c_adap);\r\nif (av7110->fe) {\r\nav7110->fe->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\r\nav7110->fe->tuner_priv = &av7110->i2c_adap;\r\nif (dvb_attach(lnbp21_attach, av7110->fe, &av7110->i2c_adap, 0, 0) == NULL) {\r\nprintk("dvb-ttpci: LNBP21 not found!\n");\r\nif (av7110->fe->ops.release)\r\nav7110->fe->ops.release(av7110->fe);\r\nav7110->fe = NULL;\r\n} else {\r\nav7110->fe->ops.dishnetwork_send_legacy_command = NULL;\r\nav7110->recover = dvb_s_recover;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!av7110->fe) {\r\nret = -ENOMEM;\r\nprintk("dvb-ttpci: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\nav7110->dev->pci->vendor,\r\nav7110->dev->pci->device,\r\nav7110->dev->pci->subsystem_vendor,\r\nav7110->dev->pci->subsystem_device);\r\n} else {\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.init, av7110->fe_init, av7110_fe_init);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.read_status, av7110->fe_read_status, av7110_fe_read_status);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_reset_overload, av7110->fe_diseqc_reset_overload, av7110_fe_diseqc_reset_overload);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_send_master_cmd, av7110->fe_diseqc_send_master_cmd, av7110_fe_diseqc_send_master_cmd);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.diseqc_send_burst, av7110->fe_diseqc_send_burst, av7110_fe_diseqc_send_burst);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.set_tone, av7110->fe_set_tone, av7110_fe_set_tone);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.set_voltage, av7110->fe_set_voltage, av7110_fe_set_voltage);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.dishnetwork_send_legacy_command, av7110->fe_dishnetwork_send_legacy_command, av7110_fe_dishnetwork_send_legacy_command);\r\nFE_FUNC_OVERRIDE(av7110->fe->ops.set_frontend, av7110->fe_set_frontend, av7110_fe_set_frontend);\r\nret = dvb_register_frontend(&av7110->dvb_adapter, av7110->fe);\r\nif (ret < 0) {\r\nprintk("av7110: Frontend registration failed!\n");\r\ndvb_frontend_detach(av7110->fe);\r\nav7110->fe = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int av7110_attach(struct saa7146_dev* dev,\r\nstruct saa7146_pci_extension_data *pci_ext)\r\n{\r\nconst int length = TS_WIDTH * TS_HEIGHT;\r\nstruct pci_dev *pdev = dev->pci;\r\nstruct av7110 *av7110;\r\nstruct task_struct *thread;\r\nint ret, count = 0;\r\ndprintk(4, "dev: %p\n", dev);\r\n#define RPS_IRQ 0\r\nif (budgetpatch == 1) {\r\nbudgetpatch = 0;\r\nsaa7146_write(dev, MC1, MASK_31);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\nsaa7146_write(dev, DD1_STREAM_B, 0);\r\nsaa7146_write(dev, DD1_INIT, 0x00000200);\r\nsaa7146_write(dev, BRS_CTRL, 0x00000000);\r\nsaa7146_write(dev, MC2,\r\n1 * (MASK_08 | MASK_24) |\r\n0 * (MASK_09 | MASK_25) |\r\n1 * (MASK_10 | MASK_26) |\r\n0 * (MASK_06 | MASK_22) |\r\n0 * (MASK_05 | MASK_21) |\r\n0 * (MASK_01 | MASK_15)\r\n);\r\ncount = 0;\r\nsaa7146_write(dev, MC1, MASK_29);\r\nsaa7146_write(dev, RPS_TOV1, 0);\r\nWRITE_RPS1(CMD_PAUSE | EVT_VBI_B);\r\nWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\r\nWRITE_RPS1(GPIO3_MSK);\r\nWRITE_RPS1(SAA7146_GPIO_OUTLO<<24);\r\n#if RPS_IRQ\r\nWRITE_RPS1(CMD_INTERRUPT);\r\n#endif\r\nWRITE_RPS1(CMD_STOP);\r\nWRITE_RPS1(CMD_JUMP);\r\nWRITE_RPS1(dev->d_rps1.dma_handle);\r\n#if RPS_IRQ\r\nsaa7146_write(dev, EC1SSR, (0x03<<2) | 3 );\r\nsaa7146_write(dev, ECT1R, 0x3fff );\r\n#endif\r\nsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\r\nsaa7146_write(dev, MC1, (MASK_13 | MASK_29 ));\r\nmdelay(10);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\r\nmdelay(10);\r\nif ((saa7146_read(dev, GPIO_CTRL) & 0x10000000) == 0) {\r\nbudgetpatch = 1;\r\nprintk("dvb-ttpci: BUDGET-PATCH DETECTED.\n");\r\n}\r\nsaa7146_write(dev, MC1, ( MASK_29 ));\r\n#if RPS_IRQ\r\nprintk("dvb-ttpci: Event Counter 1 0x%04x\n", saa7146_read(dev, EC1R) & 0x3fff );\r\n#endif\r\n}\r\nav7110 = kzalloc(sizeof(struct av7110), GFP_KERNEL);\r\nif (!av7110) {\r\ndprintk(1, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nav7110->card_name = (char*) pci_ext->ext_priv;\r\nav7110->dev = dev;\r\ndev->ext_priv = av7110;\r\nret = get_firmware(av7110);\r\nif (ret < 0)\r\ngoto err_kfree_0;\r\nret = dvb_register_adapter(&av7110->dvb_adapter, av7110->card_name,\r\nTHIS_MODULE, &dev->pci->dev, adapter_nr);\r\nif (ret < 0)\r\ngoto err_put_firmware_1;\r\nsaa7146_write(dev, GPIO_CTRL, 0x500000);\r\nstrlcpy(av7110->i2c_adap.name, pci_ext->ext_priv, sizeof(av7110->i2c_adap.name));\r\nsaa7146_i2c_adapter_prepare(dev, &av7110->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120);\r\nret = i2c_add_adapter(&av7110->i2c_adap);\r\nif (ret < 0)\r\ngoto err_dvb_unregister_adapter_2;\r\nttpci_eeprom_parse_mac(&av7110->i2c_adap,\r\nav7110->dvb_adapter.proposed_mac);\r\nret = -ENOMEM;\r\nif (full_ts)\r\nav7110->full_ts = true;\r\nif (i2c_readreg(av7110, 0xaa, 0) == 0x4f && i2c_readreg(av7110, 0xaa, 1) == 0x45) {\r\nu8 flags = i2c_readreg(av7110, 0xaa, 2);\r\nif (flags != 0xff && (flags & 0x01))\r\nav7110->full_ts = true;\r\n}\r\nif (av7110->full_ts) {\r\nprintk(KERN_INFO "dvb-ttpci: full-ts mode enabled for saa7146 port B\n");\r\nspin_lock_init(&av7110->feedlock1);\r\nav7110->grabbing = saa7146_vmalloc_build_pgtable(pdev, length,\r\n&av7110->pt);\r\nif (!av7110->grabbing)\r\ngoto err_i2c_del_3;\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\r\nsaa7146_write(dev, DD1_INIT, 0x00000600);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x60000000);\r\nsaa7146_write(dev, MC2, MASK_08 | MASK_24);\r\nsaa7146_write(dev, PCI_BT_V1, 0x001c0000 | (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));\r\nsaa7146_write(dev, BASE_ODD3, 0);\r\nsaa7146_write(dev, BASE_EVEN3, 0);\r\nsaa7146_write(dev, PROT_ADDR3, TS_WIDTH * TS_HEIGHT);\r\nsaa7146_write(dev, PITCH3, TS_WIDTH);\r\nsaa7146_write(dev, BASE_PAGE3, av7110->pt.dma | ME1 | 0x90);\r\nsaa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT << 16) | TS_WIDTH);\r\nsaa7146_write(dev, MC2, MASK_04 | MASK_20);\r\ntasklet_init(&av7110->vpe_tasklet, vpeirq, (unsigned long) av7110);\r\n} else if (budgetpatch) {\r\nspin_lock_init(&av7110->feedlock1);\r\nav7110->grabbing = saa7146_vmalloc_build_pgtable(pdev, length,\r\n&av7110->pt);\r\nif (!av7110->grabbing)\r\ngoto err_i2c_del_3;\r\nsaa7146_write(dev, PCI_BT_V1, 0x1c1f101f);\r\nsaa7146_write(dev, BCS_CTRL, 0x80400040);\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, DD1_INIT, 0x03000200);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x60000000);\r\nsaa7146_write(dev, BASE_ODD3, 0);\r\nsaa7146_write(dev, BASE_EVEN3, 0);\r\nsaa7146_write(dev, PROT_ADDR3, TS_WIDTH * TS_HEIGHT);\r\nsaa7146_write(dev, BASE_PAGE3, av7110->pt.dma | ME1 | 0x90);\r\nsaa7146_write(dev, PITCH3, TS_WIDTH);\r\nsaa7146_write(dev, NUM_LINE_BYTE3, (TS_HEIGHT << 16) | TS_WIDTH);\r\nsaa7146_write(dev, MC2, 0x077c077c);\r\nsaa7146_write(dev, GPIO_CTRL, 0x000000);\r\n#if RPS_IRQ\r\nsaa7146_write(dev, EC1SSR, (0x03<<2) | 3 );\r\nsaa7146_write(dev, ECT1R, 0x3fff );\r\n#endif\r\ncount = 0;\r\nWRITE_RPS1(CMD_PAUSE | EVT_HS);\r\nWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\r\nWRITE_RPS1(GPIO3_MSK);\r\nWRITE_RPS1(SAA7146_GPIO_OUTHI<<24);\r\n#if RPS_IRQ\r\nWRITE_RPS1(CMD_INTERRUPT);\r\n#endif\r\nWRITE_RPS1(CMD_PAUSE | RPS_INV | EVT_HS);\r\nWRITE_RPS1(CMD_WR_REG_MASK | (GPIO_CTRL>>2));\r\nWRITE_RPS1(GPIO3_MSK);\r\nWRITE_RPS1(SAA7146_GPIO_OUTLO<<24);\r\n#if RPS_IRQ\r\nWRITE_RPS1(CMD_INTERRUPT);\r\n#endif\r\nWRITE_RPS1(CMD_JUMP);\r\nWRITE_RPS1(dev->d_rps1.dma_handle);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\nsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\r\nsaa7146_write(dev, RPS_THRESH1, (TS_HEIGHT*1) | MASK_12 );\r\nsaa7146_write(dev, MC1, (MASK_13 | MASK_29));\r\ntasklet_init (&av7110->vpe_tasklet, vpeirq, (unsigned long) av7110);\r\n} else {\r\nsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\r\nsaa7146_write(dev, BCS_CTRL, 0x80400040);\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, DD1_INIT, 0x03000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, MC2, 0x077c077c);\r\nsaa7146_write(dev, GPIO_CTRL, 0x000000);\r\n}\r\ntasklet_init (&av7110->debi_tasklet, debiirq, (unsigned long) av7110);\r\ntasklet_init (&av7110->gpio_tasklet, gpioirq, (unsigned long) av7110);\r\nmutex_init(&av7110->pid_mutex);\r\nspin_lock_init(&av7110->debilock);\r\nmutex_init(&av7110->dcomlock);\r\nav7110->debitype = -1;\r\nav7110->osdwin = 1;\r\nmutex_init(&av7110->osd_mutex);\r\nav7110->vidmode = tv_standard == 1 ? AV7110_VIDEO_MODE_NTSC\r\n: AV7110_VIDEO_MODE_PAL;\r\ninit_waitqueue_head(&av7110->arm_wait);\r\nav7110->arm_thread = NULL;\r\nav7110->debi_virt = pci_alloc_consistent(pdev, 8192, &av7110->debi_bus);\r\nif (!av7110->debi_virt)\r\ngoto err_saa71466_vfree_4;\r\nav7110->iobuf = vmalloc(AVOUTLEN+AOUTLEN+BMPLEN+4*IPACKS);\r\nif (!av7110->iobuf)\r\ngoto err_pci_free_5;\r\nret = av7110_av_init(av7110);\r\nif (ret < 0)\r\ngoto err_iobuf_vfree_6;\r\nav7110->bmpbuf = av7110->iobuf+AVOUTLEN+AOUTLEN;\r\ninit_waitqueue_head(&av7110->bmpq);\r\nret = av7110_ca_init(av7110);\r\nif (ret < 0)\r\ngoto err_av7110_av_exit_7;\r\nret = av7110_bootarm(av7110);\r\nif (ret < 0)\r\ngoto err_av7110_ca_exit_8;\r\nret = av7110_firmversion(av7110);\r\nif (ret < 0)\r\ngoto err_stop_arm_9;\r\nif (FW_VERSION(av7110->arm_app)<0x2501)\r\nprintk ("dvb-ttpci: Warning, firmware version 0x%04x is too old. "\r\n"System might be unstable!\n", FW_VERSION(av7110->arm_app));\r\nthread = kthread_run(arm_thread, (void *) av7110, "arm_mon");\r\nif (IS_ERR(thread)) {\r\nret = PTR_ERR(thread);\r\ngoto err_stop_arm_9;\r\n}\r\nav7110->arm_thread = thread;\r\nav7110->mixer.volume_left = volume;\r\nav7110->mixer.volume_right = volume;\r\nret = av7110_register(av7110);\r\nif (ret < 0)\r\ngoto err_arm_thread_stop_10;\r\ninit_av7110_av(av7110);\r\nret = av7110_init_v4l(av7110);\r\nif (ret < 0)\r\ngoto err_av7110_unregister_11;\r\nav7110->dvb_adapter.priv = av7110;\r\nret = frontend_init(av7110);\r\nif (ret < 0)\r\ngoto err_av7110_exit_v4l_12;\r\nmutex_init(&av7110->ioctl_mutex);\r\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\r\nav7110_ir_init(av7110);\r\n#endif\r\nprintk(KERN_INFO "dvb-ttpci: found av7110-%d.\n", av7110_num);\r\nav7110_num++;\r\nout:\r\nreturn ret;\r\nerr_av7110_exit_v4l_12:\r\nav7110_exit_v4l(av7110);\r\nerr_av7110_unregister_11:\r\ndvb_unregister(av7110);\r\nerr_arm_thread_stop_10:\r\nav7110_arm_sync(av7110);\r\nerr_stop_arm_9:\r\nerr_av7110_ca_exit_8:\r\nav7110_ca_exit(av7110);\r\nerr_av7110_av_exit_7:\r\nav7110_av_exit(av7110);\r\nerr_iobuf_vfree_6:\r\nvfree(av7110->iobuf);\r\nerr_pci_free_5:\r\npci_free_consistent(pdev, 8192, av7110->debi_virt, av7110->debi_bus);\r\nerr_saa71466_vfree_4:\r\nif (av7110->grabbing)\r\nsaa7146_vfree_destroy_pgtable(pdev, av7110->grabbing, &av7110->pt);\r\nerr_i2c_del_3:\r\ni2c_del_adapter(&av7110->i2c_adap);\r\nerr_dvb_unregister_adapter_2:\r\ndvb_unregister_adapter(&av7110->dvb_adapter);\r\nerr_put_firmware_1:\r\nput_firmware(av7110);\r\nerr_kfree_0:\r\nkfree(av7110);\r\ngoto out;\r\n}\r\nstatic int av7110_detach(struct saa7146_dev* saa)\r\n{\r\nstruct av7110 *av7110 = saa->ext_priv;\r\ndprintk(4, "%p\n", av7110);\r\n#if IS_ENABLED(CONFIG_DVB_AV7110_IR)\r\nav7110_ir_exit(av7110);\r\n#endif\r\nif (budgetpatch || av7110->full_ts) {\r\nif (budgetpatch) {\r\nsaa7146_write(saa, MC1, MASK_29);\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\r\n}\r\nsaa7146_write(saa, MC1, MASK_20);\r\nSAA7146_IER_DISABLE(saa, MASK_10);\r\nSAA7146_ISR_CLEAR(saa, MASK_10);\r\nmsleep(50);\r\ntasklet_kill(&av7110->vpe_tasklet);\r\nsaa7146_vfree_destroy_pgtable(saa->pci, av7110->grabbing, &av7110->pt);\r\n}\r\nav7110_exit_v4l(av7110);\r\nav7110_arm_sync(av7110);\r\ntasklet_kill(&av7110->debi_tasklet);\r\ntasklet_kill(&av7110->gpio_tasklet);\r\ndvb_unregister(av7110);\r\nSAA7146_IER_DISABLE(saa, MASK_19 | MASK_03);\r\nSAA7146_ISR_CLEAR(saa, MASK_19 | MASK_03);\r\nav7110_ca_exit(av7110);\r\nav7110_av_exit(av7110);\r\nvfree(av7110->iobuf);\r\npci_free_consistent(saa->pci, 8192, av7110->debi_virt,\r\nav7110->debi_bus);\r\ni2c_del_adapter(&av7110->i2c_adap);\r\ndvb_unregister_adapter (&av7110->dvb_adapter);\r\nav7110_num--;\r\nput_firmware(av7110);\r\nkfree(av7110);\r\nsaa->ext_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic void av7110_irq(struct saa7146_dev* dev, u32 *isr)\r\n{\r\nstruct av7110 *av7110 = dev->ext_priv;\r\nif (*isr & MASK_19) {\r\nSAA7146_IER_DISABLE(av7110->dev, MASK_19);\r\nSAA7146_ISR_CLEAR(av7110->dev, MASK_19);\r\ntasklet_schedule(&av7110->debi_tasklet);\r\n}\r\nif (*isr & MASK_03) {\r\ntasklet_schedule(&av7110->gpio_tasklet);\r\n}\r\nif (*isr & MASK_10)\r\ntasklet_schedule(&av7110->vpe_tasklet);\r\n}\r\nstatic int __init av7110_init(void)\r\n{\r\nint retval;\r\nretval = saa7146_register_extension(&av7110_extension_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit av7110_exit(void)\r\n{\r\nsaa7146_unregister_extension(&av7110_extension_driver);\r\n}
