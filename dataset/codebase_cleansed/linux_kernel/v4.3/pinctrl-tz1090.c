static void __init tz1090_init_mux_pins(void)\r\n{\r\nunsigned int g, p;\r\nconst struct tz1090_pingroup *grp;\r\nconst unsigned int *pin;\r\nfor (p = 0; p < NUM_GPIOS; ++p)\r\ntz1090_mux_pins[p] = TZ1090_MUX_GROUP_MAX;\r\ngrp = tz1090_mux_groups;\r\nfor (g = 0, grp = tz1090_mux_groups;\r\ng < ARRAY_SIZE(tz1090_mux_groups); ++g, ++grp)\r\nfor (pin = grp->pins, p = 0; p < grp->npins; ++p, ++pin)\r\ntz1090_mux_pins[*pin] = g;\r\n}\r\nstatic inline u32 pmx_read(struct tz1090_pmx *pmx, u32 reg)\r\n{\r\nreturn ioread32(pmx->regs + reg);\r\n}\r\nstatic inline void pmx_write(struct tz1090_pmx *pmx, u32 val, u32 reg)\r\n{\r\niowrite32(val, pmx->regs + reg);\r\n}\r\nstatic int tz1090_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(tz1090_groups) + NUM_GPIOS;\r\n}\r\nstatic const char *tz1090_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int group)\r\n{\r\nif (group < ARRAY_SIZE(tz1090_groups)) {\r\nreturn tz1090_groups[group].name;\r\n} else {\r\nunsigned int pin = group - ARRAY_SIZE(tz1090_groups);\r\nreturn tz1090_pins[pin].name;\r\n}\r\n}\r\nstatic int tz1090_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nif (group < ARRAY_SIZE(tz1090_groups)) {\r\n*pins = tz1090_groups[group].pins;\r\n*num_pins = tz1090_groups[group].npins;\r\n} else {\r\nunsigned int pin = group - ARRAY_SIZE(tz1090_groups);\r\n*pins = &tz1090_pins[pin].number;\r\n*num_pins = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tz1090_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned int offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int reserve_map(struct device *dev, struct pinctrl_map **map,\r\nunsigned int *reserved_maps, unsigned int *num_maps,\r\nunsigned int reserve)\r\n{\r\nunsigned int old_num = *reserved_maps;\r\nunsigned int new_num = *num_maps + reserve;\r\nstruct pinctrl_map *new_map;\r\nif (old_num >= new_num)\r\nreturn 0;\r\nnew_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);\r\nif (!new_map) {\r\ndev_err(dev, "krealloc(map) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\r\n*map = new_map;\r\n*reserved_maps = new_num;\r\nreturn 0;\r\n}\r\nstatic int add_map_mux(struct pinctrl_map **map, unsigned int *reserved_maps,\r\nunsigned int *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int add_map_configs(struct device *dev,\r\nstruct pinctrl_map **map,\r\nunsigned int *reserved_maps, unsigned int *num_maps,\r\nconst char *group, unsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs) {\r\ndev_err(dev, "kmemdup(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic void tz1090_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned int num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\nkfree(map);\r\n}\r\nstatic int tz1090_pinctrl_dt_subnode_to_map(struct device *dev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned int *reserved_maps,\r\nunsigned int *num_maps)\r\n{\r\nint ret;\r\nconst char *function;\r\nunsigned long *configs = NULL;\r\nunsigned int num_configs = 0;\r\nunsigned int reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nret = of_property_read_string(np, "tz1090,function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev, "could not parse property function\n");\r\nfunction = NULL;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\r\nif (ret)\r\nreturn ret;\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "tz1090,pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = reserve_map(dev, map, reserved_maps, num_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "tz1090,pins", prop, group) {\r\nif (function) {\r\nret = add_map_mux(map, reserved_maps, num_maps,\r\ngroup, function);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = add_map_configs(dev, map, reserved_maps,\r\nnum_maps, group, configs,\r\nnum_configs);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int tz1090_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned int *num_maps)\r\n{\r\nunsigned int reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = tz1090_pinctrl_dt_subnode_to_map(pctldev->dev, np, map,\r\n&reserved_maps,\r\nnum_maps);\r\nif (ret < 0) {\r\ntz1090_pinctrl_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(tz1090_functions);\r\n}\r\nstatic const char *tz1090_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned int function)\r\n{\r\nreturn tz1090_functions[function].name;\r\n}\r\nstatic int tz1090_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned int function,\r\nconst char * const **groups,\r\nunsigned int * const num_groups)\r\n{\r\n*groups = tz1090_functions[function].groups;\r\n*num_groups = tz1090_functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic void tz1090_pinctrl_select(struct tz1090_pmx *pmx,\r\nunsigned int pin)\r\n{\r\nu32 reg, reg_shift, select, val;\r\nunsigned int pmx_index, pmx_shift;\r\nunsigned long flags;\r\npmx_index = pin >> 5;\r\npmx_shift = pin & 0x1f;\r\nselect = ((~pmx->pin_en[pmx_index] |\r\npmx->gpio_en[pmx_index]) >> pmx_shift) & 1;\r\nreg = REG_PINCTRL_SELECT + 4*(pin / 30);\r\nreg_shift = pin % 30;\r\n__global_lock2(flags);\r\nval = pmx_read(pmx, reg);\r\nval &= ~BIT(reg_shift);\r\nval |= select << reg_shift;\r\npmx_write(pmx, val, reg);\r\n__global_unlock2(flags);\r\n}\r\nstatic void tz1090_pinctrl_gpio_select(struct tz1090_pmx *pmx,\r\nunsigned int pin,\r\nbool gpio_select)\r\n{\r\nunsigned int index, shift;\r\nu32 gpio_en;\r\nif (pin >= NUM_GPIOS)\r\nreturn;\r\nindex = pin >> 5;\r\nshift = pin & 0x1f;\r\nspin_lock(&pmx->lock);\r\ngpio_en = pmx->gpio_en[index];\r\ngpio_en &= ~BIT(shift);\r\nif (gpio_select)\r\ngpio_en |= BIT(shift);\r\npmx->gpio_en[index] = gpio_en;\r\ntz1090_pinctrl_select(pmx, pin);\r\nspin_unlock(&pmx->lock);\r\n}\r\nstatic void tz1090_pinctrl_perip_select(struct tz1090_pmx *pmx,\r\nunsigned int pin,\r\nbool perip_select)\r\n{\r\nunsigned int index, shift;\r\nu32 pin_en;\r\nif (pin >= NUM_GPIOS)\r\nreturn;\r\nindex = pin >> 5;\r\nshift = pin & 0x1f;\r\nspin_lock(&pmx->lock);\r\npin_en = pmx->pin_en[index];\r\npin_en &= ~BIT(shift);\r\nif (perip_select)\r\npin_en |= BIT(shift);\r\npmx->pin_en[index] = pin_en;\r\ntz1090_pinctrl_select(pmx, pin);\r\nspin_unlock(&pmx->lock);\r\n}\r\nstatic int tz1090_pinctrl_enable_mux(struct tz1090_pmx *pmx,\r\nconst struct tz1090_muxdesc *desc,\r\nunsigned int function)\r\n{\r\nconst int *fit;\r\nunsigned long flags;\r\nint mux;\r\nunsigned int func, ret;\r\nu32 reg, mask;\r\nfor (mux = 0, fit = desc->funcs;\r\nmux < ARRAY_SIZE(desc->funcs); ++mux, ++fit) {\r\nfunc = *fit;\r\nif (func == function)\r\ngoto found_mux;\r\nif (func < ARRAY_SIZE(tz1090_submux) && tz1090_submux[func]) {\r\nret = tz1090_pinctrl_enable_mux(pmx,\r\ntz1090_submux[func],\r\nfunction);\r\nif (!ret)\r\ngoto found_mux;\r\n}\r\n}\r\nreturn -EINVAL;\r\nfound_mux:\r\nif (desc->width) {\r\nmask = (BIT(desc->width) - 1) << desc->bit;\r\n__global_lock2(flags);\r\nreg = pmx_read(pmx, desc->reg);\r\nreg &= ~mask;\r\nreg |= (mux << desc->bit) & mask;\r\npmx_write(pmx, reg, desc->reg);\r\n__global_unlock2(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinctrl_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned int function, unsigned int group)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct tz1090_pingroup *grp;\r\nint ret;\r\nunsigned int pin_num, mux_group, i, npins;\r\nconst unsigned int *pins;\r\nif (group < ARRAY_SIZE(tz1090_groups)) {\r\ngrp = &tz1090_groups[group];\r\nnpins = grp->npins;\r\npins = grp->pins;\r\n} else {\r\npin_num = group - ARRAY_SIZE(tz1090_groups);\r\nnpins = 1;\r\npins = &pin_num;\r\n}\r\nmux_group = tz1090_mux_pins[*pins];\r\nif (mux_group >= TZ1090_MUX_GROUP_MAX) {\r\nif (function == TZ1090_MUX_PERIP)\r\ngoto mux_pins;\r\nreturn -EINVAL;\r\n}\r\ngrp = &tz1090_mux_groups[mux_group];\r\nif (grp->func_count && grp->func != function) {\r\ndev_err(pctldev->dev,\r\n"%s: can't mux pin(s) to '%s', group already muxed to '%s'\n",\r\n__func__, tz1090_functions[function].name,\r\ntz1090_functions[grp->func].name);\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(pctldev->dev, "%s: muxing %u pin(s) in '%s' to '%s'\n",\r\n__func__, npins, grp->name, tz1090_functions[function].name);\r\nif (!grp->func_count) {\r\ngrp->func = function;\r\nret = tz1090_pinctrl_enable_mux(pmx, &grp->mux, function);\r\nif (ret)\r\nreturn ret;\r\n}\r\ngrp->func_count += npins;\r\nmux_pins:\r\nfor (i = 0; i < npins; ++i)\r\ntz1090_pinctrl_perip_select(pmx, pins[i], true);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\ntz1090_pinctrl_gpio_select(pmx, pin, true);\r\nreturn 0;\r\n}\r\nstatic void tz1090_pinctrl_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\ntz1090_pinctrl_gpio_select(pmx, pin, false);\r\n}\r\nstatic int tz1090_pinconf_reg(struct pinctrl_dev *pctldev,\r\nunsigned int pin,\r\nenum pin_config_param param,\r\nbool report_err,\r\nu32 *reg, u32 *width, u32 *mask, u32 *shift,\r\nu32 *val)\r\n{\r\nstruct tz1090_pinconf_pullup *pu;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\n*val = REG_PU_PD_TRISTATE;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\n*val = REG_PU_PD_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\n*val = REG_PU_PD_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\n*val = REG_PU_PD_REPEATER;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\npu = &tz1090_pinconf_pullup[pin];\r\n*reg = REG_PINCTRL_PU_PD + 4*pu->index;\r\n*shift = pu->shift;\r\n*width = 2;\r\n*mask = (BIT(*width) - 1) << *shift;\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *config)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nint ret;\r\nu32 reg, width, mask, shift, val, tmp, arg;\r\nret = tz1090_pinconf_reg(pctldev, pin, param, true,\r\n&reg, &width, &mask, &shift, &val);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = pmx_read(pmx, reg);\r\narg = ((tmp & mask) >> shift) == val;\r\nif (!arg)\r\nreturn -EINVAL;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nunsigned int arg;\r\nint ret;\r\nu32 reg, width, mask, shift, val, tmp;\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\ndev_dbg(pctldev->dev, "%s(pin=%s, config=%#lx)\n",\r\n__func__, tz1090_pins[pin].name, configs[i]);\r\nret = tz1090_pinconf_reg(pctldev, pin, param, true,\r\n&reg, &width, &mask, &shift, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (arg > 1) {\r\ndev_dbg(pctldev->dev, "%s: arg %u out of range\n",\r\n__func__, arg);\r\nreturn -EINVAL;\r\n}\r\n__global_lock2(flags);\r\ntmp = pmx_read(pmx, reg);\r\ntmp &= ~mask;\r\nif (arg)\r\ntmp |= val << shift;\r\npmx_write(pmx, tmp, reg);\r\n__global_unlock2(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinconf_group_reg(struct pinctrl_dev *pctldev,\r\nconst struct tz1090_pingroup *g,\r\nenum pin_config_param param,\r\nbool report_err,\r\nu32 *reg, u32 *width, u32 *mask, u32 *shift,\r\nconst int **map)\r\n{\r\nif (!g->drv) {\r\nif (report_err)\r\ndev_dbg(pctldev->dev,\r\n"%s: group %s has no drive control\n",\r\n__func__, g->name);\r\nreturn -ENOTSUPP;\r\n}\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\n*reg = REG_PINCTRL_SCHMITT;\r\n*width = 1;\r\n*map = tz1090_boolean_map;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\n*reg = REG_PINCTRL_DR;\r\n*width = 2;\r\n*map = tz1090_dr_map;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\n*shift = g->slw_bit * *width;\r\n*mask = (BIT(*width) - 1) << *shift;\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nunsigned long *config)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pingroup *g;\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nint ret, arg;\r\nunsigned int pin;\r\nu32 reg, width, mask, shift, val;\r\nconst int *map;\r\nif (group >= ARRAY_SIZE(tz1090_groups)) {\r\npin = group - ARRAY_SIZE(tz1090_groups);\r\nreturn tz1090_pinconf_get(pctldev, pin, config);\r\n}\r\ng = &tz1090_groups[group];\r\nif (g->npins == 1) {\r\npin = g->pins[0];\r\nret = tz1090_pinconf_get(pctldev, pin, config);\r\nif (ret != -ENOTSUPP)\r\nreturn ret;\r\n}\r\nret = tz1090_pinconf_group_reg(pctldev, g, param, true,\r\n&reg, &width, &mask, &shift, &map);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_read(pmx, reg);\r\narg = map[(val & mask) >> shift];\r\nif (arg < 0)\r\nreturn arg;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct tz1090_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tz1090_pingroup *g;\r\nenum pin_config_param param;\r\nunsigned int arg, pin, i;\r\nconst unsigned int *pit;\r\nint ret;\r\nu32 reg, width, mask, shift, val;\r\nunsigned long flags;\r\nconst int *map;\r\nint j;\r\nif (group >= ARRAY_SIZE(tz1090_groups)) {\r\npin = group - ARRAY_SIZE(tz1090_groups);\r\nreturn tz1090_pinconf_set(pctldev, pin, configs, num_configs);\r\n}\r\ng = &tz1090_groups[group];\r\nif (g->npins == 1) {\r\npin = g->pins[0];\r\nret = tz1090_pinconf_set(pctldev, pin, configs, num_configs);\r\nif (ret != -ENOTSUPP)\r\nreturn ret;\r\n}\r\nfor (j = 0; j < num_configs; j++) {\r\nparam = pinconf_to_config_param(configs[j]);\r\ndev_dbg(pctldev->dev, "%s(group=%s, config=%#lx)\n",\r\n__func__, g->name, configs[j]);\r\nret = tz1090_pinconf_group_reg(pctldev, g, param, true, &reg,\r\n&width, &mask, &shift, &map);\r\nif (ret < 0) {\r\nfor (i = 0, pit = g->pins; i < g->npins; ++i, ++pit) {\r\nret = tz1090_pinconf_set(pctldev, *pit, configs,\r\nnum_configs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\narg = pinconf_to_config_argument(configs[j]);\r\nfor (i = 0; i < BIT(width); ++i) {\r\nif (map[i] == arg || (map[i] == -EINVAL && !arg)) {\r\n__global_lock2(flags);\r\nval = pmx_read(pmx, reg);\r\nval &= ~mask;\r\nval |= i << shift;\r\npmx_write(pmx, val, reg);\r\n__global_unlock2(flags);\r\ngoto next_config;\r\n}\r\n}\r\ndev_dbg(pctldev->dev, "%s: arg %u not supported\n",\r\n__func__, arg);\r\nreturn -EINVAL;\r\nnext_config:\r\n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct tz1090_pmx *pmx;\r\nstruct resource *res;\r\npmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx) {\r\ndev_err(&pdev->dev, "Can't alloc tz1090_pmx\n");\r\nreturn -ENOMEM;\r\n}\r\npmx->dev = &pdev->dev;\r\nspin_lock_init(&pmx->lock);\r\ntz1090_pinctrl_desc.name = dev_name(&pdev->dev);\r\ntz1090_pinctrl_desc.pins = tz1090_pins;\r\ntz1090_pinctrl_desc.npins = ARRAY_SIZE(tz1090_pins);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npmx->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pmx->regs))\r\nreturn PTR_ERR(pmx->regs);\r\npmx->pctl = pinctrl_register(&tz1090_pinctrl_desc, &pdev->dev, pmx);\r\nif (IS_ERR(pmx->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pmx->pctl);\r\n}\r\nplatform_set_drvdata(pdev, pmx);\r\ndev_info(&pdev->dev, "TZ1090 pinctrl driver initialised\n");\r\nreturn 0;\r\n}\r\nstatic int tz1090_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct tz1090_pmx *pmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(pmx->pctl);\r\nreturn 0;\r\n}\r\nstatic int __init tz1090_pinctrl_init(void)\r\n{\r\ntz1090_init_mux_pins();\r\nreturn platform_driver_register(&tz1090_pinctrl_driver);\r\n}\r\nstatic void __exit tz1090_pinctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&tz1090_pinctrl_driver);\r\n}
