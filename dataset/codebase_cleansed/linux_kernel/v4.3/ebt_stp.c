static bool ebt_filter_config(const struct ebt_stp_info *info,\r\nconst struct stp_config_pdu *stpc)\r\n{\r\nconst struct ebt_stp_config_info *c;\r\nuint16_t v16;\r\nuint32_t v32;\r\nint verdict, i;\r\nc = &info->config;\r\nif ((info->bitmask & EBT_STP_FLAGS) &&\r\nFWINV(c->flags != stpc->flags, EBT_STP_FLAGS))\r\nreturn false;\r\nif (info->bitmask & EBT_STP_ROOTPRIO) {\r\nv16 = NR16(stpc->root);\r\nif (FWINV(v16 < c->root_priol ||\r\nv16 > c->root_priou, EBT_STP_ROOTPRIO))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_ROOTADDR) {\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (stpc->root[2+i] ^ c->root_addr[i]) &\r\nc->root_addrmsk[i];\r\nif (FWINV(verdict != 0, EBT_STP_ROOTADDR))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_ROOTCOST) {\r\nv32 = NR32(stpc->root_cost);\r\nif (FWINV(v32 < c->root_costl ||\r\nv32 > c->root_costu, EBT_STP_ROOTCOST))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_SENDERPRIO) {\r\nv16 = NR16(stpc->sender);\r\nif (FWINV(v16 < c->sender_priol ||\r\nv16 > c->sender_priou, EBT_STP_SENDERPRIO))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_SENDERADDR) {\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (stpc->sender[2+i] ^ c->sender_addr[i]) &\r\nc->sender_addrmsk[i];\r\nif (FWINV(verdict != 0, EBT_STP_SENDERADDR))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_PORT) {\r\nv16 = NR16(stpc->port);\r\nif (FWINV(v16 < c->portl ||\r\nv16 > c->portu, EBT_STP_PORT))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_MSGAGE) {\r\nv16 = NR16(stpc->msg_age);\r\nif (FWINV(v16 < c->msg_agel ||\r\nv16 > c->msg_ageu, EBT_STP_MSGAGE))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_MAXAGE) {\r\nv16 = NR16(stpc->max_age);\r\nif (FWINV(v16 < c->max_agel ||\r\nv16 > c->max_ageu, EBT_STP_MAXAGE))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_HELLOTIME) {\r\nv16 = NR16(stpc->hello_time);\r\nif (FWINV(v16 < c->hello_timel ||\r\nv16 > c->hello_timeu, EBT_STP_HELLOTIME))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_STP_FWDD) {\r\nv16 = NR16(stpc->forward_delay);\r\nif (FWINV(v16 < c->forward_delayl ||\r\nv16 > c->forward_delayu, EBT_STP_FWDD))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nebt_stp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ebt_stp_info *info = par->matchinfo;\r\nconst struct stp_header *sp;\r\nstruct stp_header _stph;\r\nconst uint8_t header[6] = {0x42, 0x42, 0x03, 0x00, 0x00, 0x00};\r\nsp = skb_header_pointer(skb, 0, sizeof(_stph), &_stph);\r\nif (sp == NULL)\r\nreturn false;\r\nif (memcmp(sp, header, sizeof(header)))\r\nreturn false;\r\nif (info->bitmask & EBT_STP_TYPE &&\r\nFWINV(info->type != sp->type, EBT_STP_TYPE))\r\nreturn false;\r\nif (sp->type == BPDU_TYPE_CONFIG &&\r\ninfo->bitmask & EBT_STP_CONFIG_MASK) {\r\nconst struct stp_config_pdu *st;\r\nstruct stp_config_pdu _stpc;\r\nst = skb_header_pointer(skb, sizeof(_stph),\r\nsizeof(_stpc), &_stpc);\r\nif (st == NULL)\r\nreturn false;\r\nreturn ebt_filter_config(info, st);\r\n}\r\nreturn true;\r\n}\r\nstatic int ebt_stp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ebt_stp_info *info = par->matchinfo;\r\nconst uint8_t bridge_ula[6] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};\r\nconst uint8_t msk[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nconst struct ebt_entry *e = par->entryinfo;\r\nif (info->bitmask & ~EBT_STP_MASK || info->invflags & ~EBT_STP_MASK ||\r\n!(info->bitmask & EBT_STP_MASK))\r\nreturn -EINVAL;\r\nif (!par->nft_compat &&\r\n(!ether_addr_equal(e->destmac, bridge_ula) ||\r\n!ether_addr_equal(e->destmsk, msk) ||\r\n!(e->bitmask & EBT_DESTMAC)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init ebt_stp_init(void)\r\n{\r\nreturn xt_register_match(&ebt_stp_mt_reg);\r\n}\r\nstatic void __exit ebt_stp_fini(void)\r\n{\r\nxt_unregister_match(&ebt_stp_mt_reg);\r\n}
