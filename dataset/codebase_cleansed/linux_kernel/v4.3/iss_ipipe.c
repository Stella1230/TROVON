static void ipipe_print_status(struct iss_ipipe_device *ipipe)\r\n{\r\nstruct iss_device *iss = to_iss_device(ipipe);\r\ndev_dbg(iss->dev, "-------------IPIPE Register dump-------------\n");\r\nIPIPE_PRINT_REGISTER(iss, SRC_EN);\r\nIPIPE_PRINT_REGISTER(iss, SRC_MODE);\r\nIPIPE_PRINT_REGISTER(iss, SRC_FMT);\r\nIPIPE_PRINT_REGISTER(iss, SRC_COL);\r\nIPIPE_PRINT_REGISTER(iss, SRC_VPS);\r\nIPIPE_PRINT_REGISTER(iss, SRC_VSZ);\r\nIPIPE_PRINT_REGISTER(iss, SRC_HPS);\r\nIPIPE_PRINT_REGISTER(iss, SRC_HSZ);\r\nIPIPE_PRINT_REGISTER(iss, GCK_MMR);\r\nIPIPE_PRINT_REGISTER(iss, YUV_PHS);\r\ndev_dbg(iss->dev, "-----------------------------------------------\n");\r\n}\r\nstatic void ipipe_enable(struct iss_ipipe_device *ipipe, u8 enable)\r\n{\r\nstruct iss_device *iss = to_iss_device(ipipe);\r\niss_reg_update(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_EN,\r\nIPIPE_SRC_EN_EN, enable ? IPIPE_SRC_EN_EN : 0);\r\n}\r\nstatic void ipipe_configure(struct iss_ipipe_device *ipipe)\r\n{\r\nstruct iss_device *iss = to_iss_device(ipipe);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = &ipipe->formats[IPIPE_PAD_SINK];\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_FMT,\r\nIPIPE_SRC_FMT_RAW2YUV);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_YUV_PHS,\r\nIPIPE_YUV_PHS_LPF);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_VPS, 0);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_HPS, 0);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_VSZ,\r\n(format->height - 2) & IPIPE_SRC_VSZ_MASK);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_HSZ,\r\n(format->width - 1) & IPIPE_SRC_HSZ_MASK);\r\niss_reg_clr(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_MODE,\r\nIPIPE_SRC_MODE_WRT | IPIPE_SRC_MODE_OST);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_SRC_COL,\r\nIPIPE_SRC_COL_EE_B | IPIPE_SRC_COL_EO_GB |\r\nIPIPE_SRC_COL_OE_GR | IPIPE_SRC_COL_OO_R);\r\nformat = &ipipe->formats[IPIPE_PAD_SOURCE_VP];\r\n}\r\nstatic int ipipe_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct iss_device *iss = to_iss_device(ipipe);\r\nint ret = 0;\r\nif (ipipe->state == ISS_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISS_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap4iss_isp_subclk_enable(iss, OMAP4_ISS_ISP_SUBCLK_IPIPE);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_GCK_MMR,\r\nIPIPE_GCK_MMR_REG);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_IPIPE, IPIPE_GCK_PIX,\r\nIPIPE_GCK_PIX_G3 | IPIPE_GCK_PIX_G2 |\r\nIPIPE_GCK_PIX_G1 | IPIPE_GCK_PIX_G0);\r\n}\r\nswitch (enable) {\r\ncase ISS_PIPELINE_STREAM_CONTINUOUS:\r\nipipe_configure(ipipe);\r\nipipe_print_status(ipipe);\r\natomic_set(&ipipe->stopping, 0);\r\nipipe_enable(ipipe, 1);\r\nbreak;\r\ncase ISS_PIPELINE_STREAM_STOPPED:\r\nif (ipipe->state == ISS_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nif (omap4iss_module_sync_idle(&sd->entity, &ipipe->wait,\r\n&ipipe->stopping))\r\nret = -ETIMEDOUT;\r\nipipe_enable(ipipe, 0);\r\nomap4iss_isp_subclk_disable(iss, OMAP4_ISS_ISP_SUBCLK_IPIPE);\r\nbreak;\r\n}\r\nipipe->state = enable;\r\nreturn ret;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__ipipe_get_format(struct iss_ipipe_device *ipipe,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(&ipipe->subdev, cfg, pad);\r\nreturn &ipipe->formats[pad];\r\n}\r\nstatic void\r\nipipe_try_format(struct iss_ipipe_device *ipipe,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned int width = fmt->width;\r\nunsigned int height = fmt->height;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase IPIPE_PAD_SINK:\r\nfor (i = 0; i < ARRAY_SIZE(ipipe_fmts); i++) {\r\nif (fmt->code == ipipe_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(ipipe_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nfmt->width = clamp_t(u32, width, 1, 8192);\r\nfmt->height = clamp_t(u32, height, 1, 8192);\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ncase IPIPE_PAD_SOURCE_VP:\r\nformat = __ipipe_get_format(ipipe, cfg, IPIPE_PAD_SINK, which);\r\nmemcpy(fmt, format, sizeof(*fmt));\r\nfmt->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nfmt->width = clamp_t(u32, width, 32, fmt->width);\r\nfmt->height = clamp_t(u32, height, 32, fmt->height);\r\nfmt->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int ipipe_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase IPIPE_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(ipipe_fmts))\r\nreturn -EINVAL;\r\ncode->code = ipipe_fmts[code->index];\r\nbreak;\r\ncase IPIPE_PAD_SOURCE_VP:\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipipe_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nipipe_try_format(ipipe, cfg, fse->pad, &format, fse->which);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nipipe_try_format(ipipe, cfg, fse->pad, &format, fse->which);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ipipe_get_format(ipipe, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ipipe_get_format(ipipe, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nipipe_try_format(ipipe, cfg, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == IPIPE_PAD_SINK) {\r\nformat = __ipipe_get_format(ipipe, cfg, IPIPE_PAD_SOURCE_VP,\r\nfmt->which);\r\n*format = fmt->format;\r\nipipe_try_format(ipipe, cfg, IPIPE_PAD_SOURCE_VP, format,\r\nfmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipipe_link_validate(struct v4l2_subdev *sd, struct media_link *link,\r\nstruct v4l2_subdev_format *source_fmt,\r\nstruct v4l2_subdev_format *sink_fmt)\r\n{\r\nif (source_fmt->format.width != sink_fmt->format.width ||\r\nsource_fmt->format.height != sink_fmt->format.height)\r\nreturn -EPIPE;\r\nif (source_fmt->format.code != sink_fmt->format.code)\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nstatic int ipipe_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = IPIPE_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\nipipe_set_format(sd, fh ? fh->pad : NULL, &format);\r\nreturn 0;\r\n}\r\nstatic int ipipe_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct iss_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct iss_device *iss = to_iss_device(ipipe);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase IPIPE_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nipipe->input = IPIPE_INPUT_NONE;\r\nbreak;\r\n}\r\nif (ipipe->input != IPIPE_INPUT_NONE)\r\nreturn -EBUSY;\r\nif (remote->entity == &iss->ipipeif.subdev.entity)\r\nipipe->input = IPIPE_INPUT_IPIPEIF;\r\nbreak;\r\ncase IPIPE_PAD_SOURCE_VP | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ipipe->output & ~IPIPE_OUTPUT_VP)\r\nreturn -EBUSY;\r\nipipe->output |= IPIPE_OUTPUT_VP;\r\n} else {\r\nipipe->output &= ~IPIPE_OUTPUT_VP;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipipe_init_entities(struct iss_ipipe_device *ipipe)\r\n{\r\nstruct v4l2_subdev *sd = &ipipe->subdev;\r\nstruct media_pad *pads = ipipe->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nipipe->input = IPIPE_INPUT_NONE;\r\nv4l2_subdev_init(sd, &ipipe_v4l2_ops);\r\nsd->internal_ops = &ipipe_v4l2_internal_ops;\r\nstrlcpy(sd->name, "OMAP4 ISS ISP IPIPE", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, ipipe);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[IPIPE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[IPIPE_PAD_SOURCE_VP].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &ipipe_media_ops;\r\nret = media_entity_init(me, IPIPE_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nipipe_init_formats(sd, NULL);\r\nreturn 0;\r\n}\r\nvoid omap4iss_ipipe_unregister_entities(struct iss_ipipe_device *ipipe)\r\n{\r\nv4l2_device_unregister_subdev(&ipipe->subdev);\r\n}\r\nint omap4iss_ipipe_register_entities(struct iss_ipipe_device *ipipe,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &ipipe->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap4iss_ipipe_unregister_entities(ipipe);\r\nreturn ret;\r\n}\r\nint omap4iss_ipipe_init(struct iss_device *iss)\r\n{\r\nstruct iss_ipipe_device *ipipe = &iss->ipipe;\r\nipipe->state = ISS_PIPELINE_STREAM_STOPPED;\r\ninit_waitqueue_head(&ipipe->wait);\r\nreturn ipipe_init_entities(ipipe);\r\n}\r\nvoid omap4iss_ipipe_cleanup(struct iss_device *iss)\r\n{\r\nstruct iss_ipipe_device *ipipe = &iss->ipipe;\r\nmedia_entity_cleanup(&ipipe->subdev.entity);\r\n}
