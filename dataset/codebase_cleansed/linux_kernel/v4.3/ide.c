int ide_device_get(ide_drive_t *drive)\r\n{\r\nstruct device *host_dev;\r\nstruct module *module;\r\nif (!get_device(&drive->gendev))\r\nreturn -ENXIO;\r\nhost_dev = drive->hwif->host->dev[0];\r\nmodule = host_dev ? host_dev->driver->owner : NULL;\r\nif (module && !try_module_get(module)) {\r\nput_device(&drive->gendev);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid ide_device_put(ide_drive_t *drive)\r\n{\r\n#ifdef CONFIG_MODULE_UNLOAD\r\nstruct device *host_dev = drive->hwif->host->dev[0];\r\nstruct module *module = host_dev ? host_dev->driver->owner : NULL;\r\nmodule_put(module);\r\n#endif\r\nput_device(&drive->gendev);\r\n}\r\nstatic int ide_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ide_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nide_drive_t *drive = to_ide_device(dev);\r\nadd_uevent_var(env, "MEDIA=%s", ide_media_string(drive));\r\nadd_uevent_var(env, "DRIVENAME=%s", drive->name);\r\nadd_uevent_var(env, "MODALIAS=ide:m-%s", ide_media_string(drive));\r\nreturn 0;\r\n}\r\nstatic int generic_ide_probe(struct device *dev)\r\n{\r\nide_drive_t *drive = to_ide_device(dev);\r\nstruct ide_driver *drv = to_ide_driver(dev->driver);\r\nreturn drv->probe ? drv->probe(drive) : -ENODEV;\r\n}\r\nstatic int generic_ide_remove(struct device *dev)\r\n{\r\nide_drive_t *drive = to_ide_device(dev);\r\nstruct ide_driver *drv = to_ide_driver(dev->driver);\r\nif (drv->remove)\r\ndrv->remove(drive);\r\nreturn 0;\r\n}\r\nstatic void generic_ide_shutdown(struct device *dev)\r\n{\r\nide_drive_t *drive = to_ide_device(dev);\r\nstruct ide_driver *drv = to_ide_driver(dev->driver);\r\nif (dev->driver && drv->shutdown)\r\ndrv->shutdown(drive);\r\n}\r\nstatic int ide_set_dev_param_mask(const char *s, const struct kernel_param *kp)\r\n{\r\nint a, b, i, j = 1;\r\nunsigned int *dev_param_mask = (unsigned int *)kp->arg;\r\nif (sscanf(s, "%d.%d:%d", &a, &b, &j) != 3 &&\r\nsscanf(s, "%d.%d", &a, &b) != 2)\r\nreturn -EINVAL;\r\ni = a * MAX_DRIVES + b;\r\nif (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)\r\nreturn -EINVAL;\r\nif (j)\r\n*dev_param_mask |= (1 << i);\r\nelse\r\n*dev_param_mask &= ~(1 << i);\r\nreturn 0;\r\n}\r\nstatic int ide_set_disk_chs(const char *str, struct kernel_param *kp)\r\n{\r\nint a, b, c = 0, h = 0, s = 0, i, j = 1;\r\nif (sscanf(str, "%d.%d:%d,%d,%d", &a, &b, &c, &h, &s) != 5 &&\r\nsscanf(str, "%d.%d:%d", &a, &b, &j) != 3)\r\nreturn -EINVAL;\r\ni = a * MAX_DRIVES + b;\r\nif (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)\r\nreturn -EINVAL;\r\nif (c > INT_MAX || h > 255 || s > 255)\r\nreturn -EINVAL;\r\nif (j)\r\nide_disks |= (1 << i);\r\nelse\r\nide_disks &= ~(1 << i);\r\nide_disks_chs[i].cyl = c;\r\nide_disks_chs[i].head = h;\r\nide_disks_chs[i].sect = s;\r\nreturn 0;\r\n}\r\nstatic void ide_dev_apply_params(ide_drive_t *drive, u8 unit)\r\n{\r\nint i = drive->hwif->index * MAX_DRIVES + unit;\r\nif (ide_nodma & (1 << i)) {\r\nprintk(KERN_INFO "ide: disallowing DMA for %s\n", drive->name);\r\ndrive->dev_flags |= IDE_DFLAG_NODMA;\r\n}\r\nif (ide_noflush & (1 << i)) {\r\nprintk(KERN_INFO "ide: disabling flush requests for %s\n",\r\ndrive->name);\r\ndrive->dev_flags |= IDE_DFLAG_NOFLUSH;\r\n}\r\nif (ide_nohpa & (1 << i)) {\r\nprintk(KERN_INFO "ide: disabling Host Protected Area for %s\n",\r\ndrive->name);\r\ndrive->dev_flags |= IDE_DFLAG_NOHPA;\r\n}\r\nif (ide_noprobe & (1 << i)) {\r\nprintk(KERN_INFO "ide: skipping probe for %s\n", drive->name);\r\ndrive->dev_flags |= IDE_DFLAG_NOPROBE;\r\n}\r\nif (ide_nowerr & (1 << i)) {\r\nprintk(KERN_INFO "ide: ignoring the ATA_DF bit for %s\n",\r\ndrive->name);\r\ndrive->bad_wstat = BAD_R_STAT;\r\n}\r\nif (ide_cdroms & (1 << i)) {\r\nprintk(KERN_INFO "ide: forcing %s as a CD-ROM\n", drive->name);\r\ndrive->dev_flags |= IDE_DFLAG_PRESENT;\r\ndrive->media = ide_cdrom;\r\ndrive->ready_stat = 0;\r\n}\r\nif (ide_disks & (1 << i)) {\r\ndrive->cyl = drive->bios_cyl = ide_disks_chs[i].cyl;\r\ndrive->head = drive->bios_head = ide_disks_chs[i].head;\r\ndrive->sect = drive->bios_sect = ide_disks_chs[i].sect;\r\nprintk(KERN_INFO "ide: forcing %s as a disk (%d/%d/%d)\n",\r\ndrive->name,\r\ndrive->cyl, drive->head, drive->sect);\r\ndrive->dev_flags |= IDE_DFLAG_FORCED_GEOM | IDE_DFLAG_PRESENT;\r\ndrive->media = ide_disk;\r\ndrive->ready_stat = ATA_DRDY;\r\n}\r\n}\r\nstatic int ide_set_ignore_cable(const char *s, struct kernel_param *kp)\r\n{\r\nint i, j = 1;\r\nif (sscanf(s, "%d:%d", &i, &j) != 2 && sscanf(s, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (i >= MAX_HWIFS || j < 0 || j > 1)\r\nreturn -EINVAL;\r\nif (j)\r\nide_ignore_cable |= (1 << i);\r\nelse\r\nide_ignore_cable &= ~(1 << i);\r\nreturn 0;\r\n}\r\nvoid ide_port_apply_params(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i;\r\nif (ide_ignore_cable & (1 << hwif->index)) {\r\nprintk(KERN_INFO "ide: ignoring cable detection for %s\n",\r\nhwif->name);\r\nhwif->cbl = ATA_CBL_PATA40_SHORT;\r\n}\r\nide_port_for_each_dev(i, drive, hwif)\r\nide_dev_apply_params(drive, i);\r\n}\r\nstatic int __init ide_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Uniform Multi-Platform E-IDE driver\n");\r\nret = bus_register(&ide_bus_type);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "IDE: bus_register error: %d\n", ret);\r\nreturn ret;\r\n}\r\nide_port_class = class_create(THIS_MODULE, "ide_port");\r\nif (IS_ERR(ide_port_class)) {\r\nret = PTR_ERR(ide_port_class);\r\ngoto out_port_class;\r\n}\r\nide_acpi_init();\r\nproc_ide_create();\r\nreturn 0;\r\nout_port_class:\r\nbus_unregister(&ide_bus_type);\r\nreturn ret;\r\n}\r\nstatic void __exit ide_exit(void)\r\n{\r\nproc_ide_destroy();\r\nclass_destroy(ide_port_class);\r\nbus_unregister(&ide_bus_type);\r\n}
