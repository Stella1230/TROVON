static inline int WaitTillCardIsFree(unsigned long base)\r\n{\r\nunsigned int count = 0;\r\nunsigned int a = in_atomic();\r\nwhile (!(inw(base + 0xe) & 0x1) && count++ < 100)\r\nif (a)\r\nmdelay(1);\r\nelse\r\nmsleep(1);\r\nreturn !(inw(base + 0xe) & 0x1);\r\n}\r\nstatic int lock_card(struct isi_board *card)\r\n{\r\nunsigned long base = card->base;\r\nunsigned int retries, a;\r\nfor (retries = 0; retries < 10; retries++) {\r\nspin_lock_irqsave(&card->card_lock, card->flags);\r\nfor (a = 0; a < 10; a++) {\r\nif (inw(base + 0xe) & 0x1)\r\nreturn 1;\r\nudelay(10);\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, card->flags);\r\nmsleep(10);\r\n}\r\npr_warn("Failed to lock Card (0x%lx)\n", card->base);\r\nreturn 0;\r\n}\r\nstatic void unlock_card(struct isi_board *card)\r\n{\r\nspin_unlock_irqrestore(&card->card_lock, card->flags);\r\n}\r\nstatic void raise_dtr(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nu16 channel = port->channel;\r\nif (WaitTillCardIsFree(base))\r\nreturn;\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0504, base);\r\nInterruptTheCard(base);\r\nport->status |= ISI_DTR;\r\n}\r\nstatic inline void drop_dtr(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nu16 channel = port->channel;\r\nif (WaitTillCardIsFree(base))\r\nreturn;\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0404, base);\r\nInterruptTheCard(base);\r\nport->status &= ~ISI_DTR;\r\n}\r\nstatic inline void raise_rts(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nu16 channel = port->channel;\r\nif (WaitTillCardIsFree(base))\r\nreturn;\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0a04, base);\r\nInterruptTheCard(base);\r\nport->status |= ISI_RTS;\r\n}\r\nstatic inline void drop_rts(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nu16 channel = port->channel;\r\nif (WaitTillCardIsFree(base))\r\nreturn;\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0804, base);\r\nInterruptTheCard(base);\r\nport->status &= ~ISI_RTS;\r\n}\r\nstatic void isicom_dtr_rts(struct tty_port *port, int on)\r\n{\r\nstruct isi_port *ip = container_of(port, struct isi_port, port);\r\nstruct isi_board *card = ip->card;\r\nunsigned long base = card->base;\r\nu16 channel = ip->channel;\r\nif (!lock_card(card))\r\nreturn;\r\nif (on) {\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0f04, base);\r\nInterruptTheCard(base);\r\nip->status |= (ISI_DTR | ISI_RTS);\r\n} else {\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0C04, base);\r\nInterruptTheCard(base);\r\nip->status &= ~(ISI_DTR | ISI_RTS);\r\n}\r\nunlock_card(card);\r\n}\r\nstatic void drop_dtr_rts(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nu16 channel = port->channel;\r\nif (WaitTillCardIsFree(base))\r\nreturn;\r\noutw(0x8000 | (channel << card->shift_count) | 0x02, base);\r\noutw(0x0c04, base);\r\nInterruptTheCard(base);\r\nport->status &= ~(ISI_RTS | ISI_DTR);\r\n}\r\nstatic inline int __isicom_paranoia_check(struct isi_port const *port,\r\nchar *name, const char *routine)\r\n{\r\nif (!port) {\r\npr_warn("Warning: bad isicom magic for dev %s in %s\n",\r\nname, routine);\r\nreturn 1;\r\n}\r\nif (port->magic != ISICOM_MAGIC) {\r\npr_warn("Warning: NULL isicom port for dev %s in %s\n",\r\nname, routine);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isicom_tx(unsigned long _data)\r\n{\r\nunsigned long flags, base;\r\nunsigned int retries;\r\nshort count = (BOARD_COUNT-1), card;\r\nshort txcount, wrd, residue, word_count, cnt;\r\nstruct isi_port *port;\r\nstruct tty_struct *tty;\r\ncard = (prev_card + 1) & 0x0003;\r\nwhile (count-- > 0) {\r\nif (isi_card[card].status & BOARD_ACTIVE)\r\nbreak;\r\ncard = (card + 1) & 0x0003;\r\n}\r\nif (!(isi_card[card].status & BOARD_ACTIVE))\r\ngoto sched_again;\r\nprev_card = card;\r\ncount = isi_card[card].port_count;\r\nport = isi_card[card].ports;\r\nbase = isi_card[card].base;\r\nspin_lock_irqsave(&isi_card[card].card_lock, flags);\r\nfor (retries = 0; retries < 100; retries++) {\r\nif (inw(base + 0xe) & 0x1)\r\nbreak;\r\nudelay(2);\r\n}\r\nif (retries >= 100)\r\ngoto unlock;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty == NULL)\r\ngoto put_unlock;\r\nfor (; count > 0; count--, port++) {\r\nif (!(port->port.flags & ASYNC_INITIALIZED) ||\r\n!(port->status & ISI_TXOK))\r\ncontinue;\r\ntxcount = min_t(short, TX_SIZE, port->xmit_cnt);\r\nif (txcount <= 0 || tty->stopped || tty->hw_stopped)\r\ncontinue;\r\nif (!(inw(base + 0x02) & (1 << port->channel)))\r\ncontinue;\r\npr_debug("txing %d bytes, port%d.\n",\r\ntxcount, port->channel + 1);\r\noutw((port->channel << isi_card[card].shift_count) | txcount,\r\nbase);\r\nresidue = NO;\r\nwrd = 0;\r\nwhile (1) {\r\ncnt = min_t(int, txcount, (SERIAL_XMIT_SIZE\r\n- port->xmit_tail));\r\nif (residue == YES) {\r\nresidue = NO;\r\nif (cnt > 0) {\r\nwrd |= (port->port.xmit_buf[port->xmit_tail]\r\n<< 8);\r\nport->xmit_tail = (port->xmit_tail + 1)\r\n& (SERIAL_XMIT_SIZE - 1);\r\nport->xmit_cnt--;\r\ntxcount--;\r\ncnt--;\r\noutw(wrd, base);\r\n} else {\r\noutw(wrd, base);\r\nbreak;\r\n}\r\n}\r\nif (cnt <= 0)\r\nbreak;\r\nword_count = cnt >> 1;\r\noutsw(base, port->port.xmit_buf+port->xmit_tail, word_count);\r\nport->xmit_tail = (port->xmit_tail\r\n+ (word_count << 1)) & (SERIAL_XMIT_SIZE - 1);\r\ntxcount -= (word_count << 1);\r\nport->xmit_cnt -= (word_count << 1);\r\nif (cnt & 0x0001) {\r\nresidue = YES;\r\nwrd = port->port.xmit_buf[port->xmit_tail];\r\nport->xmit_tail = (port->xmit_tail + 1)\r\n& (SERIAL_XMIT_SIZE - 1);\r\nport->xmit_cnt--;\r\ntxcount--;\r\n}\r\n}\r\nInterruptTheCard(base);\r\nif (port->xmit_cnt <= 0)\r\nport->status &= ~ISI_TXOK;\r\nif (port->xmit_cnt <= WAKEUP_CHARS)\r\ntty_wakeup(tty);\r\n}\r\nput_unlock:\r\ntty_kref_put(tty);\r\nunlock:\r\nspin_unlock_irqrestore(&isi_card[card].card_lock, flags);\r\nsched_again:\r\nmod_timer(&tx, jiffies + msecs_to_jiffies(10));\r\n}\r\nstatic irqreturn_t isicom_interrupt(int irq, void *dev_id)\r\n{\r\nstruct isi_board *card = dev_id;\r\nstruct isi_port *port;\r\nstruct tty_struct *tty;\r\nunsigned long base;\r\nu16 header, word_count, count, channel;\r\nshort byte_count;\r\nunsigned char *rp;\r\nif (!card || !(card->status & FIRMWARE_LOADED))\r\nreturn IRQ_NONE;\r\nbase = card->base;\r\nif (!(inw(base + 0x0e) & 0x02))\r\nreturn IRQ_NONE;\r\nspin_lock(&card->card_lock);\r\noutw(0x8000, base+0x04);\r\nClearInterrupt(base);\r\ninw(base);\r\nheader = inw(base);\r\nchannel = (header & 0x7800) >> card->shift_count;\r\nbyte_count = header & 0xff;\r\nif (channel + 1 > card->port_count) {\r\npr_warn("%s(0x%lx): %d(channel) > port_count\n",\r\n__func__, base, channel + 1);\r\noutw(0x0000, base+0x04);\r\nspin_unlock(&card->card_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nport = card->ports + channel;\r\nif (!(port->port.flags & ASYNC_INITIALIZED)) {\r\noutw(0x0000, base+0x04);\r\nspin_unlock(&card->card_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty == NULL) {\r\nword_count = byte_count >> 1;\r\nwhile (byte_count > 1) {\r\ninw(base);\r\nbyte_count -= 2;\r\n}\r\nif (byte_count & 0x01)\r\ninw(base);\r\noutw(0x0000, base+0x04);\r\nspin_unlock(&card->card_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (header & 0x8000) {\r\nheader = inw(base);\r\nswitch (header & 0xff) {\r\ncase 0:\r\nif (port->port.flags & ASYNC_CHECK_CD) {\r\nif (port->status & ISI_DCD) {\r\nif (!(header & ISI_DCD)) {\r\npr_debug("%s: DCD->low.\n",\r\n__func__);\r\nport->status &= ~ISI_DCD;\r\ntty_hangup(tty);\r\n}\r\n} else if (header & ISI_DCD) {\r\npr_debug("%s: DCD->high.\n",\r\n__func__);\r\nport->status |= ISI_DCD;\r\nwake_up_interruptible(&port->port.open_wait);\r\n}\r\n} else {\r\nif (header & ISI_DCD)\r\nport->status |= ISI_DCD;\r\nelse\r\nport->status &= ~ISI_DCD;\r\n}\r\nif (tty_port_cts_enabled(&port->port)) {\r\nif (tty->hw_stopped) {\r\nif (header & ISI_CTS) {\r\ntty->hw_stopped = 0;\r\nport->status |= (ISI_TXOK\r\n| ISI_CTS);\r\ntty_wakeup(tty);\r\n}\r\n} else if (!(header & ISI_CTS)) {\r\ntty->hw_stopped = 1;\r\nport->status &= ~(ISI_TXOK | ISI_CTS);\r\n}\r\n} else {\r\nif (header & ISI_CTS)\r\nport->status |= ISI_CTS;\r\nelse\r\nport->status &= ~ISI_CTS;\r\n}\r\nif (header & ISI_DSR)\r\nport->status |= ISI_DSR;\r\nelse\r\nport->status &= ~ISI_DSR;\r\nif (header & ISI_RI)\r\nport->status |= ISI_RI;\r\nelse\r\nport->status &= ~ISI_RI;\r\nbreak;\r\ncase 1:\r\ntty_insert_flip_char(&port->port, 0, TTY_BREAK);\r\nif (port->port.flags & ASYNC_SAK)\r\ndo_SAK(tty);\r\ntty_flip_buffer_push(&port->port);\r\nbreak;\r\ncase 2:\r\npr_debug("%s: stats!!!\n", __func__);\r\nbreak;\r\ndefault:\r\npr_debug("%s: Unknown code in status packet.\n",\r\n__func__);\r\nbreak;\r\n}\r\n} else {\r\ncount = tty_prepare_flip_string(&port->port, &rp,\r\nbyte_count & ~1);\r\npr_debug("%s: Can rx %d of %d bytes.\n",\r\n__func__, count, byte_count);\r\nword_count = count >> 1;\r\ninsw(base, rp, word_count);\r\nbyte_count -= (word_count << 1);\r\nif (count & 0x0001) {\r\ntty_insert_flip_char(&port->port, inw(base) & 0xff,\r\nTTY_NORMAL);\r\nbyte_count -= 2;\r\n}\r\nif (byte_count > 0) {\r\npr_debug("%s(0x%lx:%d): Flip buffer overflow! dropping bytes...\n",\r\n__func__, base, channel + 1);\r\nwhile (byte_count > 0) {\r\ninw(base);\r\nbyte_count -= 2;\r\n}\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\noutw(0x0000, base+0x04);\r\nspin_unlock(&card->card_lock);\r\ntty_kref_put(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void isicom_config_port(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nunsigned long baud;\r\nunsigned long base = card->base;\r\nu16 channel_setup, channel = port->channel,\r\nshift_count = card->shift_count;\r\nunsigned char flow_ctrl;\r\nbaud = C_BAUD(tty);\r\nif (baud & CBAUDEX) {\r\nbaud &= ~CBAUDEX;\r\nif (baud < 1 || baud > 4)\r\ntty->termios.c_cflag &= ~CBAUDEX;\r\nelse\r\nbaud += 15;\r\n}\r\nif (baud == 15) {\r\nif ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\nbaud++;\r\nif ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\nbaud += 2;\r\nif ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\nbaud += 3;\r\nif ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\nbaud += 4;\r\n}\r\nif (linuxb_to_isib[baud] == -1) {\r\ndrop_dtr(port);\r\nreturn;\r\n} else\r\nraise_dtr(port);\r\nif (WaitTillCardIsFree(base) == 0) {\r\noutw(0x8000 | (channel << shift_count) | 0x03, base);\r\noutw(linuxb_to_isib[baud] << 8 | 0x03, base);\r\nchannel_setup = 0;\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\nchannel_setup |= ISICOM_CS5;\r\nbreak;\r\ncase CS6:\r\nchannel_setup |= ISICOM_CS6;\r\nbreak;\r\ncase CS7:\r\nchannel_setup |= ISICOM_CS7;\r\nbreak;\r\ncase CS8:\r\nchannel_setup |= ISICOM_CS8;\r\nbreak;\r\n}\r\nif (C_CSTOPB(tty))\r\nchannel_setup |= ISICOM_2SB;\r\nif (C_PARENB(tty)) {\r\nchannel_setup |= ISICOM_EVPAR;\r\nif (C_PARODD(tty))\r\nchannel_setup |= ISICOM_ODPAR;\r\n}\r\noutw(channel_setup, base);\r\nInterruptTheCard(base);\r\n}\r\nif (C_CLOCAL(tty))\r\nport->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\nport->port.flags |= ASYNC_CHECK_CD;\r\nflow_ctrl = 0;\r\nport->port.flags &= ~ASYNC_CTS_FLOW;\r\nif (C_CRTSCTS(tty)) {\r\nport->port.flags |= ASYNC_CTS_FLOW;\r\nflow_ctrl |= ISICOM_CTSRTS;\r\n}\r\nif (I_IXON(tty))\r\nflow_ctrl |= ISICOM_RESPOND_XONXOFF;\r\nif (I_IXOFF(tty))\r\nflow_ctrl |= ISICOM_INITIATE_XONXOFF;\r\nif (WaitTillCardIsFree(base) == 0) {\r\noutw(0x8000 | (channel << shift_count) | 0x04, base);\r\noutw(flow_ctrl << 8 | 0x05, base);\r\noutw((STOP_CHAR(tty)) << 8 | (START_CHAR(tty)), base);\r\nInterruptTheCard(base);\r\n}\r\nif (C_CREAD(tty)) {\r\ncard->port_status |= (1 << channel);\r\noutw(card->port_status, base + 0x02);\r\n}\r\n}\r\nstatic inline void isicom_setup_board(struct isi_board *bp)\r\n{\r\nint channel;\r\nstruct isi_port *port;\r\nbp->count++;\r\nif (!(bp->status & BOARD_INIT)) {\r\nport = bp->ports;\r\nfor (channel = 0; channel < bp->port_count; channel++, port++)\r\ndrop_dtr_rts(port);\r\n}\r\nbp->status |= BOARD_ACTIVE | BOARD_INIT;\r\n}\r\nstatic int isicom_activate(struct tty_port *tport, struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = container_of(tport, struct isi_port, port);\r\nstruct isi_board *card = port->card;\r\nunsigned long flags;\r\nif (tty_port_alloc_xmit_buf(tport) < 0)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nisicom_setup_board(card);\r\nport->xmit_cnt = port->xmit_head = port->xmit_tail = 0;\r\nif (WaitTillCardIsFree(card->base) == 0) {\r\noutw(0x8000 | (port->channel << card->shift_count) | 0x02,\r\ncard->base);\r\noutw(((ISICOM_KILLTX | ISICOM_KILLRX) << 8) | 0x06, card->base);\r\nInterruptTheCard(card->base);\r\n}\r\nisicom_config_port(tty);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isicom_carrier_raised(struct tty_port *port)\r\n{\r\nstruct isi_port *ip = container_of(port, struct isi_port, port);\r\nreturn (ip->status & ISI_DCD)?1 : 0;\r\n}\r\nstatic struct tty_port *isicom_find_port(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port;\r\nstruct isi_board *card;\r\nunsigned int board;\r\nint line = tty->index;\r\nboard = BOARD(line);\r\ncard = &isi_card[board];\r\nif (!(card->status & FIRMWARE_LOADED))\r\nreturn NULL;\r\nif (line > ((board * 16) + card->port_count - 1))\r\nreturn NULL;\r\nport = &isi_ports[line];\r\nif (isicom_paranoia_check(port, tty->name, "isicom_open"))\r\nreturn NULL;\r\nreturn &port->port;\r\n}\r\nstatic int isicom_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct isi_port *port;\r\nstruct tty_port *tport;\r\ntport = isicom_find_port(tty);\r\nif (tport == NULL)\r\nreturn -ENODEV;\r\nport = container_of(tport, struct isi_port, port);\r\ntty->driver_data = port;\r\nreturn tty_port_open(tport, tty, filp);\r\n}\r\nstatic void isicom_shutdown_port(struct isi_port *port)\r\n{\r\nstruct isi_board *card = port->card;\r\nif (--card->count < 0) {\r\npr_debug("%s: bad board(0x%lx) count %d.\n",\r\n__func__, card->base, card->count);\r\ncard->count = 0;\r\n}\r\nif (!card->count)\r\ncard->status &= BOARD_ACTIVE;\r\n}\r\nstatic void isicom_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nunsigned long flags;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_flush_buffer"))\r\nreturn;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nport->xmit_cnt = port->xmit_head = port->xmit_tail = 0;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void isicom_shutdown(struct tty_port *port)\r\n{\r\nstruct isi_port *ip = container_of(port, struct isi_port, port);\r\nstruct isi_board *card = ip->card;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncard->port_status &= ~(1 << ip->channel);\r\noutw(card->port_status, card->base + 0x02);\r\nisicom_shutdown_port(ip);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\ntty_port_free_xmit_buf(port);\r\n}\r\nstatic void isicom_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct isi_port *ip = tty->driver_data;\r\nstruct tty_port *port;\r\nif (ip == NULL)\r\nreturn;\r\nport = &ip->port;\r\nif (isicom_paranoia_check(ip, tty->name, "isicom_close"))\r\nreturn;\r\ntty_port_close(port, tty, filp);\r\n}\r\nstatic int isicom_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nunsigned long flags;\r\nint cnt, total = 0;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_write"))\r\nreturn 0;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nwhile (1) {\r\ncnt = min_t(int, count, min(SERIAL_XMIT_SIZE - port->xmit_cnt\r\n- 1, SERIAL_XMIT_SIZE - port->xmit_head));\r\nif (cnt <= 0)\r\nbreak;\r\nmemcpy(port->port.xmit_buf + port->xmit_head, buf, cnt);\r\nport->xmit_head = (port->xmit_head + cnt) & (SERIAL_XMIT_SIZE\r\n- 1);\r\nport->xmit_cnt += cnt;\r\nbuf += cnt;\r\ncount -= cnt;\r\ntotal += cnt;\r\n}\r\nif (port->xmit_cnt && !tty->stopped && !tty->hw_stopped)\r\nport->status |= ISI_TXOK;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nreturn total;\r\n}\r\nstatic int isicom_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nunsigned long flags;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_put_char"))\r\nreturn 0;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (port->xmit_cnt >= SERIAL_XMIT_SIZE - 1) {\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nreturn 0;\r\n}\r\nport->port.xmit_buf[port->xmit_head++] = ch;\r\nport->xmit_head &= (SERIAL_XMIT_SIZE - 1);\r\nport->xmit_cnt++;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nreturn 1;\r\n}\r\nstatic void isicom_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_flush_chars"))\r\nreturn;\r\nif (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||\r\n!port->port.xmit_buf)\r\nreturn;\r\nport->status |= ISI_TXOK;\r\n}\r\nstatic int isicom_write_room(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nint free;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_write_room"))\r\nreturn 0;\r\nfree = SERIAL_XMIT_SIZE - port->xmit_cnt - 1;\r\nif (free < 0)\r\nfree = 0;\r\nreturn free;\r\n}\r\nstatic int isicom_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_chars_in_buffer"))\r\nreturn 0;\r\nreturn port->xmit_cnt;\r\n}\r\nstatic int isicom_send_break(struct tty_struct *tty, int length)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nunsigned long base = card->base;\r\nif (length == -1)\r\nreturn -EOPNOTSUPP;\r\nif (!lock_card(card))\r\nreturn -EINVAL;\r\noutw(0x8000 | ((port->channel) << (card->shift_count)) | 0x3, base);\r\noutw((length & 0xff) << 8 | 0x00, base);\r\noutw((length & 0xff00u), base);\r\nInterruptTheCard(base);\r\nunlock_card(card);\r\nreturn 0;\r\n}\r\nstatic int isicom_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nu16 status = port->status;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_ioctl"))\r\nreturn -ENODEV;\r\nreturn ((status & ISI_RTS) ? TIOCM_RTS : 0) |\r\n((status & ISI_DTR) ? TIOCM_DTR : 0) |\r\n((status & ISI_DCD) ? TIOCM_CAR : 0) |\r\n((status & ISI_DSR) ? TIOCM_DSR : 0) |\r\n((status & ISI_CTS) ? TIOCM_CTS : 0) |\r\n((status & ISI_RI ) ? TIOCM_RI : 0);\r\n}\r\nstatic int isicom_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nunsigned long flags;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_ioctl"))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&port->card->card_lock, flags);\r\nif (set & TIOCM_RTS)\r\nraise_rts(port);\r\nif (set & TIOCM_DTR)\r\nraise_dtr(port);\r\nif (clear & TIOCM_RTS)\r\ndrop_rts(port);\r\nif (clear & TIOCM_DTR)\r\ndrop_dtr(port);\r\nspin_unlock_irqrestore(&port->card->card_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isicom_set_serial_info(struct tty_struct *tty,\r\nstruct serial_struct __user *info)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct serial_struct newinfo;\r\nint reconfig_port;\r\nif (copy_from_user(&newinfo, info, sizeof(newinfo)))\r\nreturn -EFAULT;\r\nmutex_lock(&port->port.mutex);\r\nreconfig_port = ((port->port.flags & ASYNC_SPD_MASK) !=\r\n(newinfo.flags & ASYNC_SPD_MASK));\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((newinfo.close_delay != port->port.close_delay) ||\r\n(newinfo.closing_wait != port->port.closing_wait) ||\r\n((newinfo.flags & ~ASYNC_USR_MASK) !=\r\n(port->port.flags & ~ASYNC_USR_MASK))) {\r\nmutex_unlock(&port->port.mutex);\r\nreturn -EPERM;\r\n}\r\nport->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |\r\n(newinfo.flags & ASYNC_USR_MASK));\r\n} else {\r\nport->port.close_delay = newinfo.close_delay;\r\nport->port.closing_wait = newinfo.closing_wait;\r\nport->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |\r\n(newinfo.flags & ASYNC_FLAGS));\r\n}\r\nif (reconfig_port) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->card->card_lock, flags);\r\nisicom_config_port(tty);\r\nspin_unlock_irqrestore(&port->card->card_lock, flags);\r\n}\r\nmutex_unlock(&port->port.mutex);\r\nreturn 0;\r\n}\r\nstatic int isicom_get_serial_info(struct isi_port *port,\r\nstruct serial_struct __user *info)\r\n{\r\nstruct serial_struct out_info;\r\nmutex_lock(&port->port.mutex);\r\nmemset(&out_info, 0, sizeof(out_info));\r\nout_info.line = port - isi_ports;\r\nout_info.port = port->card->base;\r\nout_info.irq = port->card->irq;\r\nout_info.flags = port->port.flags;\r\nout_info.close_delay = port->port.close_delay;\r\nout_info.closing_wait = port->port.closing_wait;\r\nmutex_unlock(&port->port.mutex);\r\nif (copy_to_user(info, &out_info, sizeof(out_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int isicom_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_ioctl"))\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn isicom_get_serial_info(port, argp);\r\ncase TIOCSSERIAL:\r\nreturn isicom_set_serial_info(tty, argp);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isicom_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nunsigned long flags;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_set_termios"))\r\nreturn;\r\nif (tty->termios.c_cflag == old_termios->c_cflag &&\r\ntty->termios.c_iflag == old_termios->c_iflag)\r\nreturn;\r\nspin_lock_irqsave(&port->card->card_lock, flags);\r\nisicom_config_port(tty);\r\nspin_unlock_irqrestore(&port->card->card_lock, flags);\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nisicom_start(tty);\r\n}\r\n}\r\nstatic void isicom_throttle(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_throttle"))\r\nreturn;\r\ncard->port_status &= ~(1 << port->channel);\r\noutw(card->port_status, card->base + 0x02);\r\n}\r\nstatic void isicom_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nstruct isi_board *card = port->card;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_unthrottle"))\r\nreturn;\r\ncard->port_status |= (1 << port->channel);\r\noutw(card->port_status, card->base + 0x02);\r\n}\r\nstatic void isicom_stop(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_stop"))\r\nreturn;\r\nport->status &= ~ISI_TXOK;\r\n}\r\nstatic void isicom_start(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_start"))\r\nreturn;\r\nport->status |= ISI_TXOK;\r\n}\r\nstatic void isicom_hangup(struct tty_struct *tty)\r\n{\r\nstruct isi_port *port = tty->driver_data;\r\nif (isicom_paranoia_check(port, tty->name, "isicom_hangup"))\r\nreturn;\r\ntty_port_hangup(&port->port);\r\n}\r\nstatic int reset_card(struct pci_dev *pdev,\r\nconst unsigned int card, unsigned int *signature)\r\n{\r\nstruct isi_board *board = pci_get_drvdata(pdev);\r\nunsigned long base = board->base;\r\nunsigned int sig, portcount = 0;\r\nint retval = 0;\r\ndev_dbg(&pdev->dev, "ISILoad:Resetting Card%d at 0x%lx\n", card + 1,\r\nbase);\r\ninw(base + 0x8);\r\nmsleep(10);\r\noutw(0, base + 0x8);\r\nmsleep(1000);\r\nsig = inw(base + 0x4) & 0xff;\r\nif (sig != 0xa5 && sig != 0xbb && sig != 0xcc && sig != 0xdd &&\r\nsig != 0xee) {\r\ndev_warn(&pdev->dev, "ISILoad:Card%u reset failure (Possible "\r\n"bad I/O Port Address 0x%lx).\n", card + 1, base);\r\ndev_dbg(&pdev->dev, "Sig=0x%x\n", sig);\r\nretval = -EIO;\r\ngoto end;\r\n}\r\nmsleep(10);\r\nportcount = inw(base + 0x2);\r\nif (!(inw(base + 0xe) & 0x1) || (portcount != 0 && portcount != 4 &&\r\nportcount != 8 && portcount != 16)) {\r\ndev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.\n",\r\ncard + 1);\r\nretval = -EIO;\r\ngoto end;\r\n}\r\nswitch (sig) {\r\ncase 0xa5:\r\ncase 0xbb:\r\ncase 0xdd:\r\nboard->port_count = (portcount == 4) ? 4 : 8;\r\nboard->shift_count = 12;\r\nbreak;\r\ncase 0xcc:\r\ncase 0xee:\r\nboard->port_count = 16;\r\nboard->shift_count = 11;\r\nbreak;\r\n}\r\ndev_info(&pdev->dev, "-Done\n");\r\n*signature = sig;\r\nend:\r\nreturn retval;\r\n}\r\nstatic int load_firmware(struct pci_dev *pdev,\r\nconst unsigned int index, const unsigned int signature)\r\n{\r\nstruct isi_board *board = pci_get_drvdata(pdev);\r\nconst struct firmware *fw;\r\nunsigned long base = board->base;\r\nunsigned int a;\r\nu16 word_count, status;\r\nint retval = -EIO;\r\nchar *name;\r\nu8 *data;\r\nstruct stframe {\r\nu16 addr;\r\nu16 count;\r\nu8 data[0];\r\n} *frame;\r\nswitch (signature) {\r\ncase 0xa5:\r\nname = "isi608.bin";\r\nbreak;\r\ncase 0xbb:\r\nname = "isi608em.bin";\r\nbreak;\r\ncase 0xcc:\r\nname = "isi616em.bin";\r\nbreak;\r\ncase 0xdd:\r\nname = "isi4608.bin";\r\nbreak;\r\ncase 0xee:\r\nname = "isi4616.bin";\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown signature.\n");\r\ngoto end;\r\n}\r\nretval = request_firmware(&fw, name, &pdev->dev);\r\nif (retval)\r\ngoto end;\r\nretval = -EIO;\r\nfor (frame = (struct stframe *)fw->data;\r\nframe < (struct stframe *)(fw->data + fw->size);\r\nframe = (struct stframe *)((u8 *)(frame + 1) +\r\nframe->count)) {\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\noutw(0xf0, base);\r\noutw(0x00, base);\r\noutw(frame->addr, base);\r\nword_count = frame->count / 2 + frame->count % 2;\r\noutw(word_count, base);\r\nInterruptTheCard(base);\r\nudelay(100);\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\nstatus = inw(base + 0x4);\r\nif (status != 0) {\r\ndev_warn(&pdev->dev, "Card%d rejected load header:\n"\r\n"Address:0x%x\n"\r\n"Count:0x%x\n"\r\n"Status:0x%x\n",\r\nindex + 1, frame->addr, frame->count, status);\r\ngoto errrelfw;\r\n}\r\noutsw(base, frame->data, word_count);\r\nInterruptTheCard(base);\r\nudelay(50);\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\nstatus = inw(base + 0x4);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "Card%d got out of sync.Card "\r\n"Status:0x%x\n", index + 1, status);\r\ngoto errrelfw;\r\n}\r\n}\r\nfor (frame = (struct stframe *)fw->data;\r\nframe < (struct stframe *)(fw->data + fw->size);\r\nframe = (struct stframe *)((u8 *)(frame + 1) +\r\nframe->count)) {\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\noutw(0xf1, base);\r\noutw(0x00, base);\r\noutw(frame->addr, base);\r\nword_count = (frame->count >> 1) + frame->count % 2;\r\noutw(word_count + 1, base);\r\nInterruptTheCard(base);\r\nudelay(50);\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\nstatus = inw(base + 0x4);\r\nif (status != 0) {\r\ndev_warn(&pdev->dev, "Card%d rejected verify header:\n"\r\n"Address:0x%x\n"\r\n"Count:0x%x\n"\r\n"Status: 0x%x\n",\r\nindex + 1, frame->addr, frame->count, status);\r\ngoto errrelfw;\r\n}\r\ndata = kmalloc(word_count * 2, GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(&pdev->dev, "Card%d, firmware upload "\r\n"failed, not enough memory\n", index + 1);\r\ngoto errrelfw;\r\n}\r\ninw(base);\r\ninsw(base, data, word_count);\r\nInterruptTheCard(base);\r\nfor (a = 0; a < frame->count; a++)\r\nif (data[a] != frame->data[a]) {\r\nkfree(data);\r\ndev_err(&pdev->dev, "Card%d, firmware upload "\r\n"failed\n", index + 1);\r\ngoto errrelfw;\r\n}\r\nkfree(data);\r\nudelay(50);\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\nstatus = inw(base + 0x4);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "Card%d verify got out of sync. "\r\n"Card Status:0x%x\n", index + 1, status);\r\ngoto errrelfw;\r\n}\r\n}\r\nif (WaitTillCardIsFree(base))\r\ngoto errrelfw;\r\noutw(0xf2, base);\r\noutw(0x800, base);\r\noutw(0x0, base);\r\noutw(0x0, base);\r\nInterruptTheCard(base);\r\noutw(0x0, base + 0x4);\r\nboard->status |= FIRMWARE_LOADED;\r\nretval = 0;\r\nerrrelfw:\r\nrelease_firmware(fw);\r\nend:\r\nreturn retval;\r\n}\r\nstatic int isicom_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned int uninitialized_var(signature), index;\r\nint retval = -EPERM;\r\nstruct isi_board *board = NULL;\r\nif (card_count >= BOARD_COUNT)\r\ngoto err;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "failed to enable\n");\r\ngoto err;\r\n}\r\ndev_info(&pdev->dev, "ISI PCI Card(Device ID 0x%x)\n", ent->device);\r\nfor (index = 0; index < BOARD_COUNT; index++) {\r\nif (isi_card[index].base == 0) {\r\nboard = &isi_card[index];\r\nbreak;\r\n}\r\n}\r\nif (index == BOARD_COUNT) {\r\nretval = -ENODEV;\r\ngoto err_disable;\r\n}\r\nboard->index = index;\r\nboard->base = pci_resource_start(pdev, 3);\r\nboard->irq = pdev->irq;\r\ncard_count++;\r\npci_set_drvdata(pdev, board);\r\nretval = pci_request_region(pdev, 3, ISICOM_NAME);\r\nif (retval) {\r\ndev_err(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "\r\n"will be disabled.\n", board->base, board->base + 15,\r\nindex + 1);\r\nretval = -EBUSY;\r\ngoto errdec;\r\n}\r\nretval = request_irq(board->irq, isicom_interrupt,\r\nIRQF_SHARED, ISICOM_NAME, board);\r\nif (retval < 0) {\r\ndev_err(&pdev->dev, "Could not install handler at Irq %d. "\r\n"Card%d will be disabled.\n", board->irq, index + 1);\r\ngoto errunrr;\r\n}\r\nretval = reset_card(pdev, index, &signature);\r\nif (retval < 0)\r\ngoto errunri;\r\nretval = load_firmware(pdev, index, signature);\r\nif (retval < 0)\r\ngoto errunri;\r\nfor (index = 0; index < board->port_count; index++) {\r\nstruct tty_port *tport = &board->ports[index].port;\r\ntty_port_init(tport);\r\ntport->ops = &isicom_port_ops;\r\ntport->close_delay = 50 * HZ/100;\r\ntport->closing_wait = 3000 * HZ/100;\r\ntty_port_register_device(tport, isicom_normal,\r\nboard->index * 16 + index, &pdev->dev);\r\n}\r\nreturn 0;\r\nerrunri:\r\nfree_irq(board->irq, board);\r\nerrunrr:\r\npci_release_region(pdev, 3);\r\nerrdec:\r\nboard->base = 0;\r\ncard_count--;\r\nerr_disable:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void isicom_remove(struct pci_dev *pdev)\r\n{\r\nstruct isi_board *board = pci_get_drvdata(pdev);\r\nunsigned int i;\r\nfor (i = 0; i < board->port_count; i++) {\r\ntty_unregister_device(isicom_normal, board->index * 16 + i);\r\ntty_port_destroy(&board->ports[i].port);\r\n}\r\nfree_irq(board->irq, board);\r\npci_release_region(pdev, 3);\r\nboard->base = 0;\r\ncard_count--;\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init isicom_init(void)\r\n{\r\nint retval, idx, channel;\r\nstruct isi_port *port;\r\nfor (idx = 0; idx < BOARD_COUNT; idx++) {\r\nport = &isi_ports[idx * 16];\r\nisi_card[idx].ports = port;\r\nspin_lock_init(&isi_card[idx].card_lock);\r\nfor (channel = 0; channel < 16; channel++, port++) {\r\nport->magic = ISICOM_MAGIC;\r\nport->card = &isi_card[idx];\r\nport->channel = channel;\r\nport->status = 0;\r\n}\r\nisi_card[idx].base = 0;\r\nisi_card[idx].irq = 0;\r\n}\r\nisicom_normal = alloc_tty_driver(PORT_COUNT);\r\nif (!isicom_normal) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nisicom_normal->name = "ttyM";\r\nisicom_normal->major = ISICOM_NMAJOR;\r\nisicom_normal->minor_start = 0;\r\nisicom_normal->type = TTY_DRIVER_TYPE_SERIAL;\r\nisicom_normal->subtype = SERIAL_TYPE_NORMAL;\r\nisicom_normal->init_termios = tty_std_termios;\r\nisicom_normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL |\r\nCLOCAL;\r\nisicom_normal->flags = TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK;\r\ntty_set_operations(isicom_normal, &isicom_ops);\r\nretval = tty_register_driver(isicom_normal);\r\nif (retval) {\r\npr_debug("Couldn't register the dialin driver\n");\r\ngoto err_puttty;\r\n}\r\nretval = pci_register_driver(&isicom_driver);\r\nif (retval < 0) {\r\npr_err("Unable to register pci driver.\n");\r\ngoto err_unrtty;\r\n}\r\nmod_timer(&tx, jiffies + 1);\r\nreturn 0;\r\nerr_unrtty:\r\ntty_unregister_driver(isicom_normal);\r\nerr_puttty:\r\nput_tty_driver(isicom_normal);\r\nerror:\r\nreturn retval;\r\n}\r\nstatic void __exit isicom_exit(void)\r\n{\r\ndel_timer_sync(&tx);\r\npci_unregister_driver(&isicom_driver);\r\ntty_unregister_driver(isicom_normal);\r\nput_tty_driver(isicom_normal);\r\n}
