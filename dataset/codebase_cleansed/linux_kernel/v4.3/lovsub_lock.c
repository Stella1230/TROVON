static void lovsub_lock_fini(const struct lu_env *env,\r\nstruct cl_lock_slice *slice)\r\n{\r\nstruct lovsub_lock *lsl;\r\nlsl = cl2lovsub_lock(slice);\r\nLASSERT(list_empty(&lsl->lss_parents));\r\nOBD_SLAB_FREE_PTR(lsl, lovsub_lock_kmem);\r\n}\r\nstatic void lovsub_parent_lock(const struct lu_env *env, struct lov_lock *lov)\r\n{\r\nstruct cl_lock *parent;\r\nparent = lov->lls_cl.cls_lock;\r\ncl_lock_get(parent);\r\nlu_ref_add(&parent->cll_reference, "lovsub-parent", current);\r\ncl_lock_mutex_get(env, parent);\r\n}\r\nstatic void lovsub_parent_unlock(const struct lu_env *env, struct lov_lock *lov)\r\n{\r\nstruct cl_lock *parent;\r\nparent = lov->lls_cl.cls_lock;\r\ncl_lock_mutex_put(env, lov->lls_cl.cls_lock);\r\nlu_ref_del(&parent->cll_reference, "lovsub-parent", current);\r\ncl_lock_put(env, parent);\r\n}\r\nstatic void lovsub_lock_state(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice,\r\nenum cl_lock_state state)\r\n{\r\nstruct lovsub_lock *sub = cl2lovsub_lock(slice);\r\nstruct lov_lock_link *scan;\r\nLASSERT(cl_lock_is_mutexed(slice->cls_lock));\r\nlist_for_each_entry(scan, &sub->lss_parents, lll_list) {\r\nstruct lov_lock *lov = scan->lll_super;\r\nstruct cl_lock *parent = lov->lls_cl.cls_lock;\r\nif (sub->lss_active != parent) {\r\nlovsub_parent_lock(env, lov);\r\ncl_lock_signal(env, parent);\r\nlovsub_parent_unlock(env, lov);\r\n}\r\n}\r\n}\r\nstatic unsigned long lovsub_lock_weigh(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct lovsub_lock *lock = cl2lovsub_lock(slice);\r\nstruct lov_lock *lov;\r\nunsigned long dumbbell;\r\nLASSERT(cl_lock_is_mutexed(slice->cls_lock));\r\nif (!list_empty(&lock->lss_parents)) {\r\nlov = container_of(lock->lss_parents.next,\r\nstruct lov_lock_link, lll_list)->lll_super;\r\nlovsub_parent_lock(env, lov);\r\ndumbbell = cl_lock_weigh(env, lov->lls_cl.cls_lock);\r\nlovsub_parent_unlock(env, lov);\r\n} else\r\ndumbbell = 0;\r\nreturn dumbbell;\r\n}\r\nstatic void lovsub_lock_descr_map(const struct cl_lock_descr *in,\r\nstruct lov_object *lov,\r\nint stripe, struct cl_lock_descr *out)\r\n{\r\npgoff_t size;\r\npgoff_t skip;\r\npgoff_t start;\r\npgoff_t end;\r\nstart = in->cld_start;\r\nend = in->cld_end;\r\nif (lov->lo_lsm->lsm_stripe_count > 1) {\r\nsize = cl_index(lov2cl(lov), lov->lo_lsm->lsm_stripe_size);\r\nskip = (lov->lo_lsm->lsm_stripe_count - 1) * size;\r\nstart += start/size * skip + stripe * size;\r\nif (end != CL_PAGE_EOF) {\r\nend += end/size * skip + stripe * size;\r\nif (end < in->cld_end)\r\nend = CL_PAGE_EOF;\r\n}\r\n}\r\nout->cld_start = start;\r\nout->cld_end = end;\r\n}\r\nint lov_sublock_modify(const struct lu_env *env, struct lov_lock *lov,\r\nstruct lovsub_lock *sublock,\r\nconst struct cl_lock_descr *d, int idx)\r\n{\r\nstruct cl_lock *parent;\r\nstruct lovsub_object *subobj;\r\nstruct cl_lock_descr *pd;\r\nstruct cl_lock_descr *parent_descr;\r\nint result;\r\nparent = lov->lls_cl.cls_lock;\r\nparent_descr = &parent->cll_descr;\r\nLASSERT(cl_lock_mode_match(d->cld_mode, parent_descr->cld_mode));\r\nsubobj = cl2lovsub(sublock->lss_cl.cls_obj);\r\npd = &lov_env_info(env)->lti_ldescr;\r\npd->cld_obj = parent_descr->cld_obj;\r\npd->cld_mode = parent_descr->cld_mode;\r\npd->cld_gid = parent_descr->cld_gid;\r\nlovsub_lock_descr_map(d, subobj->lso_super, subobj->lso_index, pd);\r\nlov->lls_sub[idx].sub_got = *d;\r\nif (!cl_lock_ext_match(parent_descr, pd))\r\nresult = cl_lock_modify(env, parent, pd);\r\nelse\r\nresult = 0;\r\nreturn result;\r\n}\r\nstatic int lovsub_lock_modify(const struct lu_env *env,\r\nconst struct cl_lock_slice *s,\r\nconst struct cl_lock_descr *d)\r\n{\r\nstruct lovsub_lock *lock = cl2lovsub_lock(s);\r\nstruct lov_lock_link *scan;\r\nstruct lov_lock *lov;\r\nint result = 0;\r\nLASSERT(cl_lock_mode_match(d->cld_mode,\r\ns->cls_lock->cll_descr.cld_mode));\r\nlist_for_each_entry(scan, &lock->lss_parents, lll_list) {\r\nint rc;\r\nlov = scan->lll_super;\r\nlovsub_parent_lock(env, lov);\r\nrc = lov_sublock_modify(env, lov, lock, d, scan->lll_idx);\r\nlovsub_parent_unlock(env, lov);\r\nresult = result ?: rc;\r\n}\r\nreturn result;\r\n}\r\nstatic int lovsub_lock_closure(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice,\r\nstruct cl_lock_closure *closure)\r\n{\r\nstruct lovsub_lock *sub;\r\nstruct cl_lock *parent;\r\nstruct lov_lock_link *scan;\r\nint result;\r\nLASSERT(cl_lock_is_mutexed(slice->cls_lock));\r\nsub = cl2lovsub_lock(slice);\r\nresult = 0;\r\nlist_for_each_entry(scan, &sub->lss_parents, lll_list) {\r\nparent = scan->lll_super->lls_cl.cls_lock;\r\nresult = cl_lock_closure_build(env, parent, closure);\r\nif (result != 0)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int lovsub_lock_delete_one(const struct lu_env *env,\r\nstruct cl_lock *child, struct lov_lock *lov)\r\n{\r\nstruct cl_lock *parent;\r\nint result;\r\nparent = lov->lls_cl.cls_lock;\r\nif (parent->cll_error)\r\nreturn 0;\r\nresult = 0;\r\nswitch (parent->cll_state) {\r\ncase CLS_ENQUEUED:\r\nLASSERT(parent->cll_flags & CLF_CANCELLED);\r\nbreak;\r\ncase CLS_QUEUING:\r\ncase CLS_FREEING:\r\ncl_lock_signal(env, parent);\r\nbreak;\r\ncase CLS_INTRANSIT:\r\nif (cl_lock_is_intransit(parent))\r\nlov->lls_cancel_race = 1;\r\nbreak;\r\ncase CLS_CACHED:\r\ncl_lock_state_set(env, parent, CLS_NEW);\r\ncase CLS_NEW:\r\nif (lov->lls_nr_filled == 0) {\r\nif (cl_lock_nr_mutexed(env) == 2) {\r\ncl_lock_mutex_put(env, child);\r\ncl_lock_cancel(env, parent);\r\ncl_lock_delete(env, parent);\r\nresult = 1;\r\n}\r\n}\r\nbreak;\r\ncase CLS_HELD:\r\nCL_LOCK_DEBUG(D_ERROR, env, parent, "Delete CLS_HELD lock\n");\r\ndefault:\r\nCERROR("Impossible state: %d\n", parent->cll_state);\r\nLBUG();\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void lovsub_lock_delete(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct cl_lock *child = slice->cls_lock;\r\nstruct lovsub_lock *sub = cl2lovsub_lock(slice);\r\nint restart;\r\nLASSERT(cl_lock_is_mutexed(child));\r\ndo {\r\nstruct lov_lock *lov;\r\nstruct lov_lock_link *scan;\r\nstruct lov_lock_link *temp;\r\nstruct lov_lock_sub *subdata;\r\nrestart = 0;\r\nlist_for_each_entry_safe(scan, temp,\r\n&sub->lss_parents, lll_list) {\r\nlov = scan->lll_super;\r\nsubdata = &lov->lls_sub[scan->lll_idx];\r\nlovsub_parent_lock(env, lov);\r\nsubdata->sub_got = subdata->sub_descr;\r\nlov_lock_unlink(env, scan, sub);\r\nrestart = lovsub_lock_delete_one(env, child, lov);\r\nlovsub_parent_unlock(env, lov);\r\nif (restart) {\r\ncl_lock_mutex_get(env, child);\r\nbreak;\r\n}\r\n}\r\n} while (restart);\r\n}\r\nstatic int lovsub_lock_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct cl_lock_slice *slice)\r\n{\r\nstruct lovsub_lock *sub = cl2lovsub_lock(slice);\r\nstruct lov_lock *lov;\r\nstruct lov_lock_link *scan;\r\nlist_for_each_entry(scan, &sub->lss_parents, lll_list) {\r\nlov = scan->lll_super;\r\n(*p)(env, cookie, "[%d %p ", scan->lll_idx, lov);\r\nif (lov != NULL)\r\ncl_lock_descr_print(env, cookie, p,\r\n&lov->lls_cl.cls_lock->cll_descr);\r\n(*p)(env, cookie, "] ");\r\n}\r\nreturn 0;\r\n}\r\nint lovsub_lock_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_lock *lock, const struct cl_io *io)\r\n{\r\nstruct lovsub_lock *lsk;\r\nint result;\r\nOBD_SLAB_ALLOC_PTR_GFP(lsk, lovsub_lock_kmem, GFP_NOFS);\r\nif (lsk != NULL) {\r\nINIT_LIST_HEAD(&lsk->lss_parents);\r\ncl_lock_slice_add(lock, &lsk->lss_cl, obj, &lovsub_lock_ops);\r\nresult = 0;\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}
