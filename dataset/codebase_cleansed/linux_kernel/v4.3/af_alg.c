static const struct af_alg_type *alg_get_type(const char *name)\r\n{\r\nconst struct af_alg_type *type = ERR_PTR(-ENOENT);\r\nstruct alg_type_list *node;\r\ndown_read(&alg_types_sem);\r\nlist_for_each_entry(node, &alg_types, list) {\r\nif (strcmp(node->type->name, name))\r\ncontinue;\r\nif (try_module_get(node->type->owner))\r\ntype = node->type;\r\nbreak;\r\n}\r\nup_read(&alg_types_sem);\r\nreturn type;\r\n}\r\nint af_alg_register_type(const struct af_alg_type *type)\r\n{\r\nstruct alg_type_list *node;\r\nint err = -EEXIST;\r\ndown_write(&alg_types_sem);\r\nlist_for_each_entry(node, &alg_types, list) {\r\nif (!strcmp(node->type->name, type->name))\r\ngoto unlock;\r\n}\r\nnode = kmalloc(sizeof(*node), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!node)\r\ngoto unlock;\r\ntype->ops->owner = THIS_MODULE;\r\nnode->type = type;\r\nlist_add(&node->list, &alg_types);\r\nerr = 0;\r\nunlock:\r\nup_write(&alg_types_sem);\r\nreturn err;\r\n}\r\nint af_alg_unregister_type(const struct af_alg_type *type)\r\n{\r\nstruct alg_type_list *node;\r\nint err = -ENOENT;\r\ndown_write(&alg_types_sem);\r\nlist_for_each_entry(node, &alg_types, list) {\r\nif (strcmp(node->type->name, type->name))\r\ncontinue;\r\nlist_del(&node->list);\r\nkfree(node);\r\nerr = 0;\r\nbreak;\r\n}\r\nup_write(&alg_types_sem);\r\nreturn err;\r\n}\r\nstatic void alg_do_release(const struct af_alg_type *type, void *private)\r\n{\r\nif (!type)\r\nreturn;\r\ntype->release(private);\r\nmodule_put(type->owner);\r\n}\r\nint af_alg_release(struct socket *sock)\r\n{\r\nif (sock->sk)\r\nsock_put(sock->sk);\r\nreturn 0;\r\n}\r\nstatic int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nconst u32 forbidden = CRYPTO_ALG_INTERNAL;\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct sockaddr_alg *sa = (void *)uaddr;\r\nconst struct af_alg_type *type;\r\nvoid *private;\r\nif (sock->state == SS_CONNECTED)\r\nreturn -EINVAL;\r\nif (addr_len != sizeof(*sa))\r\nreturn -EINVAL;\r\nsa->salg_type[sizeof(sa->salg_type) - 1] = 0;\r\nsa->salg_name[sizeof(sa->salg_name) - 1] = 0;\r\ntype = alg_get_type(sa->salg_type);\r\nif (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {\r\nrequest_module("algif-%s", sa->salg_type);\r\ntype = alg_get_type(sa->salg_type);\r\n}\r\nif (IS_ERR(type))\r\nreturn PTR_ERR(type);\r\nprivate = type->bind(sa->salg_name,\r\nsa->salg_feat & ~forbidden,\r\nsa->salg_mask & ~forbidden);\r\nif (IS_ERR(private)) {\r\nmodule_put(type->owner);\r\nreturn PTR_ERR(private);\r\n}\r\nlock_sock(sk);\r\nswap(ask->type, type);\r\nswap(ask->private, private);\r\nrelease_sock(sk);\r\nalg_do_release(type, private);\r\nreturn 0;\r\n}\r\nstatic int alg_setkey(struct sock *sk, char __user *ukey,\r\nunsigned int keylen)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nconst struct af_alg_type *type = ask->type;\r\nu8 *key;\r\nint err;\r\nkey = sock_kmalloc(sk, keylen, GFP_KERNEL);\r\nif (!key)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(key, ukey, keylen))\r\ngoto out;\r\nerr = type->setkey(ask->private, key, keylen);\r\nout:\r\nsock_kzfree_s(sk, key, keylen);\r\nreturn err;\r\n}\r\nstatic int alg_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nconst struct af_alg_type *type;\r\nint err = -ENOPROTOOPT;\r\nlock_sock(sk);\r\ntype = ask->type;\r\nif (level != SOL_ALG || !type)\r\ngoto unlock;\r\nswitch (optname) {\r\ncase ALG_SET_KEY:\r\nif (sock->state == SS_CONNECTED)\r\ngoto unlock;\r\nif (!type->setkey)\r\ngoto unlock;\r\nerr = alg_setkey(sk, optval, optlen);\r\nbreak;\r\ncase ALG_SET_AEAD_AUTHSIZE:\r\nif (sock->state == SS_CONNECTED)\r\ngoto unlock;\r\nif (!type->setauthsize)\r\ngoto unlock;\r\nerr = type->setauthsize(ask->private, optlen);\r\n}\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nint af_alg_accept(struct sock *sk, struct socket *newsock)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nconst struct af_alg_type *type;\r\nstruct sock *sk2;\r\nint err;\r\nlock_sock(sk);\r\ntype = ask->type;\r\nerr = -EINVAL;\r\nif (!type)\r\ngoto unlock;\r\nsk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto, 0);\r\nerr = -ENOMEM;\r\nif (!sk2)\r\ngoto unlock;\r\nsock_init_data(newsock, sk2);\r\nsock_graft(sk2, newsock);\r\nsecurity_sk_clone(sk, sk2);\r\nerr = type->accept(ask->private, sk2);\r\nif (err) {\r\nsk_free(sk2);\r\ngoto unlock;\r\n}\r\nsk2->sk_family = PF_ALG;\r\nsock_hold(sk);\r\nalg_sk(sk2)->parent = sk;\r\nalg_sk(sk2)->type = type;\r\nnewsock->ops = type->ops;\r\nnewsock->state = SS_CONNECTED;\r\nerr = 0;\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int alg_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nreturn af_alg_accept(sock->sk, newsock);\r\n}\r\nstatic void alg_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nalg_do_release(ask->type, ask->private);\r\n}\r\nstatic int alg_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nint err;\r\nif (sock->type != SOCK_SEQPACKET)\r\nreturn -ESOCKTNOSUPPORT;\r\nif (protocol != 0)\r\nreturn -EPROTONOSUPPORT;\r\nerr = -ENOMEM;\r\nsk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto, kern);\r\nif (!sk)\r\ngoto out;\r\nsock->ops = &alg_proto_ops;\r\nsock_init_data(sock, sk);\r\nsk->sk_family = PF_ALG;\r\nsk->sk_destruct = alg_sock_destruct;\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nint af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\r\n{\r\nsize_t off;\r\nssize_t n;\r\nint npages, i;\r\nn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\r\nif (n < 0)\r\nreturn n;\r\nnpages = (off + n + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (WARN_ON(npages == 0))\r\nreturn -EINVAL;\r\nsg_init_table(sgl->sg, npages + 1);\r\nfor (i = 0, len = n; i < npages; i++) {\r\nint plen = min_t(int, len, PAGE_SIZE - off);\r\nsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\r\noff = 0;\r\nlen -= plen;\r\n}\r\nsg_mark_end(sgl->sg + npages - 1);\r\nsgl->npages = npages;\r\nreturn n;\r\n}\r\nvoid af_alg_link_sg(struct af_alg_sgl *sgl_prev, struct af_alg_sgl *sgl_new)\r\n{\r\nsg_unmark_end(sgl_prev->sg + sgl_prev->npages - 1);\r\nsg_chain(sgl_prev->sg, sgl_prev->npages + 1, sgl_new->sg);\r\n}\r\nvoid af_alg_free_sg(struct af_alg_sgl *sgl)\r\n{\r\nint i;\r\nfor (i = 0; i < sgl->npages; i++)\r\nput_page(sgl->pages[i]);\r\n}\r\nint af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)\r\n{\r\nstruct cmsghdr *cmsg;\r\nfor_each_cmsghdr(cmsg, msg) {\r\nif (!CMSG_OK(msg, cmsg))\r\nreturn -EINVAL;\r\nif (cmsg->cmsg_level != SOL_ALG)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase ALG_SET_IV:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))\r\nreturn -EINVAL;\r\ncon->iv = (void *)CMSG_DATA(cmsg);\r\nif (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +\r\nsizeof(*con->iv)))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ALG_SET_OP:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\r\nreturn -EINVAL;\r\ncon->op = *(u32 *)CMSG_DATA(cmsg);\r\nbreak;\r\ncase ALG_SET_AEAD_ASSOCLEN:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\r\nreturn -EINVAL;\r\ncon->aead_assoclen = *(u32 *)CMSG_DATA(cmsg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint af_alg_wait_for_completion(int err, struct af_alg_completion *completion)\r\n{\r\nswitch (err) {\r\ncase -EINPROGRESS:\r\ncase -EBUSY:\r\nwait_for_completion(&completion->completion);\r\nreinit_completion(&completion->completion);\r\nerr = completion->err;\r\nbreak;\r\n};\r\nreturn err;\r\n}\r\nvoid af_alg_complete(struct crypto_async_request *req, int err)\r\n{\r\nstruct af_alg_completion *completion = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\ncompletion->err = err;\r\ncomplete(&completion->completion);\r\n}\r\nstatic int __init af_alg_init(void)\r\n{\r\nint err = proto_register(&alg_proto, 0);\r\nif (err)\r\ngoto out;\r\nerr = sock_register(&alg_family);\r\nif (err != 0)\r\ngoto out_unregister_proto;\r\nout:\r\nreturn err;\r\nout_unregister_proto:\r\nproto_unregister(&alg_proto);\r\ngoto out;\r\n}\r\nstatic void __exit af_alg_exit(void)\r\n{\r\nsock_unregister(PF_ALG);\r\nproto_unregister(&alg_proto);\r\n}
