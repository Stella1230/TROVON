static inline unsigned int serial_in(struct uart_omap_port *up, int offset)\r\n{\r\noffset <<= up->port.regshift;\r\nreturn readw(up->port.membase + offset);\r\n}\r\nstatic inline void serial_out(struct uart_omap_port *up, int offset, int value)\r\n{\r\noffset <<= up->port.regshift;\r\nwritew(value, up->port.membase + offset);\r\n}\r\nstatic inline void serial_omap_clear_fifos(struct uart_omap_port *up)\r\n{\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n}\r\nstatic int serial_omap_get_context_loss_count(struct uart_omap_port *up)\r\n{\r\nstruct omap_uart_port_info *pdata = dev_get_platdata(up->dev);\r\nif (!pdata || !pdata->get_context_loss_count)\r\nreturn -EINVAL;\r\nreturn pdata->get_context_loss_count(up->dev);\r\n}\r\nstatic void serial_omap_enable_wakeup(struct uart_omap_port *up, bool enable)\r\n{\r\nstruct omap_uart_port_info *pdata = dev_get_platdata(up->dev);\r\nif (!pdata || !pdata->enable_wakeup)\r\nreturn;\r\npdata->enable_wakeup(up->dev, enable);\r\n}\r\nstatic inline int calculate_baud_abs_diff(struct uart_port *port,\r\nunsigned int baud, unsigned int mode)\r\n{\r\nunsigned int n = port->uartclk / (mode * baud);\r\nint abs_diff;\r\nif (n == 0)\r\nn = 1;\r\nabs_diff = baud - (port->uartclk / (mode * n));\r\nif (abs_diff < 0)\r\nabs_diff = -abs_diff;\r\nreturn abs_diff;\r\n}\r\nstatic bool\r\nserial_omap_baud_is_mode16(struct uart_port *port, unsigned int baud)\r\n{\r\nint abs_diff_13 = calculate_baud_abs_diff(port, baud, 13);\r\nint abs_diff_16 = calculate_baud_abs_diff(port, baud, 16);\r\nreturn (abs_diff_13 >= abs_diff_16);\r\n}\r\nstatic unsigned int\r\nserial_omap_get_divisor(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int mode;\r\nif (!serial_omap_baud_is_mode16(port, baud))\r\nmode = 13;\r\nelse\r\nmode = 16;\r\nreturn port->uartclk/(mode * baud);\r\n}\r\nstatic void serial_omap_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\ndev_dbg(up->port.dev, "serial_omap_enable_ms+%d\n", up->port.line);\r\npm_runtime_get_sync(up->dev);\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nint res;\r\npm_runtime_get_sync(up->dev);\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\nif (up->scr & OMAP_UART_SCR_TX_EMPTY) {\r\nup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\nres = (port->rs485.flags & SER_RS485_RTS_AFTER_SEND) ?\r\n1 : 0;\r\nif (gpio_get_value(up->rts_gpio) != res) {\r\nif (port->rs485.delay_rts_after_send > 0)\r\nmdelay(\r\nport->rs485.delay_rts_after_send);\r\ngpio_set_value(up->rts_gpio, res);\r\n}\r\n} else {\r\nup->scr |= OMAP_UART_SCR_TX_EMPTY;\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\nreturn;\r\n}\r\n}\r\nif (up->ier & UART_IER_THRI) {\r\nup->ier &= ~UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX)) {\r\nserial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_RCVR);\r\nup->ier |= UART_IER_RLSI | UART_IER_RDI;\r\nup->port.read_status_mask |= UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\npm_runtime_get_sync(up->dev);\r\nup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void transmit_chars(struct uart_omap_port *up, unsigned int lsr)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nserial_out(up, UART_TX, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nserial_omap_stop_tx(&up->port);\r\nreturn;\r\n}\r\ncount = up->port.fifosize / 4;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nserial_omap_stop_tx(&up->port);\r\n}\r\nstatic inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)\r\n{\r\nif (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic void serial_omap_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nint res;\r\npm_runtime_get_sync(up->dev);\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\nup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\nres = (port->rs485.flags & SER_RS485_RTS_ON_SEND) ? 1 : 0;\r\nif (gpio_get_value(up->rts_gpio) != res) {\r\ngpio_set_value(up->rts_gpio, res);\r\nif (port->rs485.delay_rts_before_send > 0)\r\nmdelay(port->rs485.delay_rts_before_send);\r\n}\r\n}\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX))\r\nserial_omap_stop_rx(port);\r\nserial_omap_enable_ier_thri(up);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_throttle(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags;\r\npm_runtime_get_sync(up->dev);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_unthrottle(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags;\r\npm_runtime_get_sync(up->dev);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->ier |= UART_IER_RLSI | UART_IER_RDI;\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic unsigned int check_modem_status(struct uart_omap_port *up)\r\n{\r\nunsigned int status;\r\nstatus = serial_in(up, UART_MSR);\r\nstatus |= up->msr_saved_flags;\r\nup->msr_saved_flags = 0;\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn status;\r\nif (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&\r\nup->port.state != NULL) {\r\nif (status & UART_MSR_TERI)\r\nup->port.icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nup->port.icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change\r\n(&up->port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change\r\n(&up->port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nreturn status;\r\n}\r\nstatic void serial_omap_rlsi(struct uart_omap_port *up, unsigned int lsr)\r\n{\r\nunsigned int flag;\r\nunsigned char ch = 0;\r\nif (likely(lsr & UART_LSR_DR))\r\nch = serial_in(up, UART_RX);\r\nup->port.icount.rx++;\r\nflag = TTY_NORMAL;\r\nif (lsr & UART_LSR_BI) {\r\nflag = TTY_BREAK;\r\nlsr &= ~(UART_LSR_FE | UART_LSR_PE);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\nreturn;\r\n}\r\nif (lsr & UART_LSR_PE) {\r\nflag = TTY_PARITY;\r\nup->port.icount.parity++;\r\n}\r\nif (lsr & UART_LSR_FE) {\r\nflag = TTY_FRAME;\r\nup->port.icount.frame++;\r\n}\r\nif (lsr & UART_LSR_OE)\r\nup->port.icount.overrun++;\r\n#ifdef CONFIG_SERIAL_OMAP_CONSOLE\r\nif (up->port.line == up->port.cons->index) {\r\nlsr |= up->lsr_break_flag;\r\n}\r\n#endif\r\nuart_insert_char(&up->port, lsr, UART_LSR_OE, 0, flag);\r\n}\r\nstatic void serial_omap_rdi(struct uart_omap_port *up, unsigned int lsr)\r\n{\r\nunsigned char ch = 0;\r\nunsigned int flag;\r\nif (!(lsr & UART_LSR_DR))\r\nreturn;\r\nch = serial_in(up, UART_RX);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\nreturn;\r\nuart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);\r\n}\r\nstatic irqreturn_t serial_omap_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_omap_port *up = dev_id;\r\nunsigned int iir, lsr;\r\nunsigned int type;\r\nirqreturn_t ret = IRQ_NONE;\r\nint max_count = 256;\r\nspin_lock(&up->port.lock);\r\npm_runtime_get_sync(up->dev);\r\ndo {\r\niir = serial_in(up, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nbreak;\r\nret = IRQ_HANDLED;\r\nlsr = serial_in(up, UART_LSR);\r\ntype = iir & 0x3e;\r\nswitch (type) {\r\ncase UART_IIR_MSI:\r\ncheck_modem_status(up);\r\nbreak;\r\ncase UART_IIR_THRI:\r\ntransmit_chars(up, lsr);\r\nbreak;\r\ncase UART_IIR_RX_TIMEOUT:\r\ncase UART_IIR_RDI:\r\nserial_omap_rdi(up, lsr);\r\nbreak;\r\ncase UART_IIR_RLSI:\r\nserial_omap_rlsi(up, lsr);\r\nbreak;\r\ncase UART_IIR_CTS_RTS_DSR:\r\nbreak;\r\ncase UART_IIR_XOFF:\r\ndefault:\r\nbreak;\r\n}\r\n} while (!(iir & UART_IIR_NO_INT) && max_count--);\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(&up->port.state->port);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nup->port_activity = jiffies;\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_omap_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags = 0;\r\nunsigned int ret = 0;\r\npm_runtime_get_sync(up->dev);\r\ndev_dbg(up->port.dev, "serial_omap_tx_empty+%d\n", up->port.line);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_omap_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned int status;\r\nunsigned int ret = 0;\r\npm_runtime_get_sync(up->dev);\r\nstatus = check_modem_status(up);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\ndev_dbg(up->port.dev, "serial_omap_get_mctrl+%d\n", up->port.line);\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned char mcr = 0, old_mcr, lcr;\r\ndev_dbg(up->port.dev, "serial_omap_set_mctrl+%d\n", up->port.line);\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\npm_runtime_get_sync(up->dev);\r\nold_mcr = serial_in(up, UART_MCR);\r\nold_mcr &= ~(UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_OUT1 |\r\nUART_MCR_DTR | UART_MCR_RTS);\r\nup->mcr = old_mcr | mcr;\r\nserial_out(up, UART_MCR, up->mcr);\r\nlcr = serial_in(up, UART_LCR);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\r\nup->efr |= UART_EFR_RTS;\r\nelse\r\nup->efr &= UART_EFR_RTS;\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, lcr);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags = 0;\r\ndev_dbg(up->port.dev, "serial_omap_break_ctl+%d\n", up->port.line);\r\npm_runtime_get_sync(up->dev);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_out(up, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic int serial_omap_startup(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags = 0;\r\nint retval;\r\nretval = request_irq(up->port.irq, serial_omap_irq, up->port.irqflags,\r\nup->name, up);\r\nif (retval)\r\nreturn retval;\r\nif (up->wakeirq) {\r\nretval = dev_pm_set_dedicated_wake_irq(up->dev, up->wakeirq);\r\nif (retval) {\r\nfree_irq(up->port.irq, up);\r\nreturn retval;\r\n}\r\n}\r\ndev_dbg(up->port.dev, "serial_omap_startup+%d\n", up->port.line);\r\npm_runtime_get_sync(up->dev);\r\nserial_omap_clear_fifos(up);\r\n(void) serial_in(up, UART_LSR);\r\nif (serial_in(up, UART_LSR) & UART_LSR_DR)\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nserial_out(up, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl |= TIOCM_OUT2;\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nup->msr_saved_flags = 0;\r\nup->ier = UART_IER_RLSI | UART_IER_RDI;\r\nserial_out(up, UART_IER, up->ier);\r\nup->wer = OMAP_UART_WER_MOD_WKUP;\r\nif (up->features & OMAP_UART_WER_HAS_TX_WAKEUP)\r\nup->wer |= OMAP_UART_TX_WAKEUP_EN;\r\nserial_out(up, UART_OMAP_WER, up->wer);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nup->port_activity = jiffies;\r\nreturn 0;\r\n}\r\nstatic void serial_omap_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned long flags = 0;\r\ndev_dbg(up->port.dev, "serial_omap_shutdown+%d\n", up->port.line);\r\npm_runtime_get_sync(up->dev);\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl &= ~TIOCM_OUT2;\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\r\nserial_omap_clear_fifos(up);\r\nif (serial_in(up, UART_LSR) & UART_LSR_DR)\r\n(void) serial_in(up, UART_RX);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nfree_irq(up->port.irq, up);\r\ndev_pm_clear_wake_irq(up->dev);\r\n}\r\nstatic void serial_omap_uart_qos_work(struct work_struct *work)\r\n{\r\nstruct uart_omap_port *up = container_of(work, struct uart_omap_port,\r\nqos_work);\r\npm_qos_update_request(&up->pm_qos_request, up->latency);\r\n}\r\nstatic void\r\nserial_omap_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned char cval = 0;\r\nunsigned long flags = 0;\r\nunsigned int baud, quot;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nif (termios->c_cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/13);\r\nquot = serial_omap_get_divisor(port, baud);\r\nup->calc_latency = (USEC_PER_SEC * up->port.fifosize) / (baud / 8);\r\nup->latency = up->calc_latency;\r\nschedule_work(&up->qos_work);\r\nup->dll = quot & 0xff;\r\nup->dlh = quot >> 8;\r\nup->mdr1 = UART_OMAP_MDR1_DISABLE;\r\nup->fcr = UART_FCR_R_TRIG_01 | UART_FCR_T_TRIG_01 |\r\nUART_FCR_ENABLE_FIFO;\r\npm_runtime_get_sync(up->dev);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_LCR, cval);\r\nup->lcr = cval;\r\nup->scr = 0;\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_DLL, 0);\r\nserial_out(up, UART_DLM, 0);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nup->efr = serial_in(up, UART_EFR) & ~UART_EFR_ECB;\r\nup->efr &= ~UART_EFR_SCD;\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nup->mcr = serial_in(up, UART_MCR) & ~UART_MCR_TCRTLR;\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\r\nup->scr |= OMAP_UART_SCR_RX_TRIG_GRANU1_MASK;\r\nup->fcr &= ~OMAP_UART_FCR_RX_FIFO_TRIG_MASK;\r\nup->fcr &= ~OMAP_UART_FCR_TX_FIFO_TRIG_MASK;\r\nup->fcr |= UART_FCR6_R_TRIGGER_16 | UART_FCR6_T_TRIGGER_24 |\r\nUART_FCR_ENABLE_FIFO;\r\nserial_out(up, UART_FCR, up->fcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\r\nserial_omap_mdr1_errataset(up, up->mdr1);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, up->mdr1);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_DLL, up->dll);\r\nserial_out(up, UART_DLM, up->dlh);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, cval);\r\nif (!serial_omap_baud_is_mode16(port, baud))\r\nup->mdr1 = UART_OMAP_MDR1_13X_MODE;\r\nelse\r\nup->mdr1 = UART_OMAP_MDR1_16X_MODE;\r\nif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\r\nserial_omap_mdr1_errataset(up, up->mdr1);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, up->mdr1);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_XON1, termios->c_cc[VSTART]);\r\nserial_out(up, UART_XOFF1, termios->c_cc[VSTOP]);\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\r\nserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);\r\nup->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);\r\nif (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW) {\r\nup->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\r\nup->efr |= UART_EFR_CTS;\r\n} else {\r\nup->efr &= ~(UART_EFR_CTS | UART_EFR_RTS);\r\n}\r\nif (up->port.flags & UPF_SOFT_FLOW) {\r\nup->efr &= OMAP_UART_SW_CLR;\r\nif (termios->c_iflag & IXON)\r\nup->efr |= OMAP_UART_SW_RX;\r\nif (termios->c_iflag & IXOFF) {\r\nup->port.status |= UPSTAT_AUTOXOFF;\r\nup->efr |= OMAP_UART_SW_TX;\r\n}\r\nif (termios->c_iflag & IXANY)\r\nup->mcr |= UART_MCR_XONANY;\r\nelse\r\nup->mcr &= ~UART_MCR_XONANY;\r\n}\r\nserial_out(up, UART_MCR, up->mcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, up->lcr);\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\ndev_dbg(up->port.dev, "serial_omap_set_termios+%d\n", up->port.line);\r\n}\r\nstatic void\r\nserial_omap_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned char efr;\r\ndev_dbg(up->port.dev, "serial_omap_pm+%d\n", up->port.line);\r\npm_runtime_get_sync(up->dev);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nefr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, efr);\r\nserial_out(up, UART_LCR, 0);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic void serial_omap_release_port(struct uart_port *port)\r\n{\r\ndev_dbg(port->dev, "serial_omap_release_port+\n");\r\n}\r\nstatic int serial_omap_request_port(struct uart_port *port)\r\n{\r\ndev_dbg(port->dev, "serial_omap_request_port+\n");\r\nreturn 0;\r\n}\r\nstatic void serial_omap_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\ndev_dbg(up->port.dev, "serial_omap_config_port+%d\n",\r\nup->port.line);\r\nup->port.type = PORT_OMAP;\r\nup->port.flags |= UPF_SOFT_FLOW | UPF_HARD_FLOW;\r\n}\r\nstatic int\r\nserial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\ndev_dbg(port->dev, "serial_omap_verify_port+\n");\r\nreturn -EINVAL;\r\n}\r\nstatic const char *\r\nserial_omap_type(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\ndev_dbg(up->port.dev, "serial_omap_type+%d\n", up->port.line);\r\nreturn up->name;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_omap_port *up)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = serial_in(up, UART_LSR);\r\nif (status & UART_LSR_BI)\r\nup->lsr_break_flag = UART_LSR_BI;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & BOTH_EMPTY) != BOTH_EMPTY);\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nfor (tmout = 1000000; tmout; tmout--) {\r\nunsigned int msr = serial_in(up, UART_MSR);\r\nup->msr_saved_flags |= msr & MSR_SAVE_FLAGS;\r\nif (msr & UART_MSR_CTS)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic void serial_omap_poll_put_char(struct uart_port *port, unsigned char ch)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\npm_runtime_get_sync(up->dev);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\n}\r\nstatic int serial_omap_poll_get_char(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned int status;\r\npm_runtime_get_sync(up->dev);\r\nstatus = serial_in(up, UART_LSR);\r\nif (!(status & UART_LSR_DR)) {\r\nstatus = NO_POLL_CHAR;\r\ngoto out;\r\n}\r\nstatus = serial_in(up, UART_RX);\r\nout:\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nreturn status;\r\n}\r\nstatic void serial_omap_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic void\r\nserial_omap_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_omap_port *up = serial_omap_console_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\npm_runtime_get_sync(up->dev);\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&up->port.lock);\r\nelse\r\nspin_lock(&up->port.lock);\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\nuart_console_write(&up->port, s, count, serial_omap_console_putchar);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_IER, ier);\r\nif (up->msr_saved_flags)\r\ncheck_modem_status(up);\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init\r\nserial_omap_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_omap_port *up;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (serial_omap_console_ports[co->index] == NULL)\r\nreturn -ENODEV;\r\nup = serial_omap_console_ports[co->index];\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void serial_omap_add_console_port(struct uart_omap_port *up)\r\n{\r\nserial_omap_console_ports[up->port.line] = up;\r\n}\r\nstatic inline void serial_omap_add_console_port(struct uart_omap_port *up)\r\n{}\r\nstatic int\r\nserial_omap_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)\r\n{\r\nstruct uart_omap_port *up = to_uart_omap_port(port);\r\nunsigned int mode;\r\nint val;\r\npm_runtime_get_sync(up->dev);\r\nmode = up->ier;\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nport->rs485 = *rs485conf;\r\nif (gpio_is_valid(up->rts_gpio)) {\r\nval = (port->rs485.flags & SER_RS485_ENABLED) ?\r\nSER_RS485_RTS_AFTER_SEND : SER_RS485_RTS_ON_SEND;\r\nval = (port->rs485.flags & val) ? 1 : 0;\r\ngpio_set_value(up->rts_gpio, val);\r\n} else\r\nport->rs485.flags &= ~SER_RS485_ENABLED;\r\nup->ier = mode;\r\nserial_out(up, UART_IER, up->ier);\r\nif (!(port->rs485.flags & SER_RS485_ENABLED) &&\r\n(up->scr & OMAP_UART_SCR_TX_EMPTY)) {\r\nup->scr &= ~OMAP_UART_SCR_TX_EMPTY;\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\n}\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nreturn 0;\r\n}\r\nstatic int serial_omap_prepare(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nup->is_suspending = true;\r\nreturn 0;\r\n}\r\nstatic void serial_omap_complete(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nup->is_suspending = false;\r\n}\r\nstatic int serial_omap_suspend(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nuart_suspend_port(&serial_omap_reg, &up->port);\r\nflush_work(&up->qos_work);\r\nif (device_may_wakeup(dev))\r\nserial_omap_enable_wakeup(up, true);\r\nelse\r\nserial_omap_enable_wakeup(up, false);\r\nreturn 0;\r\n}\r\nstatic int serial_omap_resume(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nserial_omap_enable_wakeup(up, false);\r\nuart_resume_port(&serial_omap_reg, &up->port);\r\nreturn 0;\r\n}\r\nstatic void omap_serial_fill_features_erratas(struct uart_omap_port *up)\r\n{\r\nu32 mvr, scheme;\r\nu16 revision, major, minor;\r\nmvr = readl(up->port.membase + (UART_OMAP_MVER << up->port.regshift));\r\nscheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;\r\nswitch (scheme) {\r\ncase 0:\r\nmajor = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>\r\nOMAP_UART_LEGACY_MVR_MAJ_SHIFT;\r\nminor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);\r\nbreak;\r\ncase 1:\r\nmajor = (mvr & OMAP_UART_MVR_MAJ_MASK) >>\r\nOMAP_UART_MVR_MAJ_SHIFT;\r\nminor = (mvr & OMAP_UART_MVR_MIN_MASK);\r\nbreak;\r\ndefault:\r\ndev_warn(up->dev,\r\n"Unknown %s revision, defaulting to highest\n",\r\nup->name);\r\nmajor = 0xff;\r\nminor = 0xff;\r\n}\r\nrevision = UART_BUILD_REVISION(major, minor);\r\nswitch (revision) {\r\ncase OMAP_UART_REV_46:\r\nup->errata |= (UART_ERRATA_i202_MDR1_ACCESS |\r\nUART_ERRATA_i291_DMA_FORCEIDLE);\r\nbreak;\r\ncase OMAP_UART_REV_52:\r\nup->errata |= (UART_ERRATA_i202_MDR1_ACCESS |\r\nUART_ERRATA_i291_DMA_FORCEIDLE);\r\nup->features |= OMAP_UART_WER_HAS_TX_WAKEUP;\r\nbreak;\r\ncase OMAP_UART_REV_63:\r\nup->errata |= UART_ERRATA_i202_MDR1_ACCESS;\r\nup->features |= OMAP_UART_WER_HAS_TX_WAKEUP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic struct omap_uart_port_info *of_get_uart_port_info(struct device *dev)\r\n{\r\nstruct omap_uart_port_info *omap_up_info;\r\nomap_up_info = devm_kzalloc(dev, sizeof(*omap_up_info), GFP_KERNEL);\r\nif (!omap_up_info)\r\nreturn NULL;\r\nof_property_read_u32(dev->of_node, "clock-frequency",\r\n&omap_up_info->uartclk);\r\nreturn omap_up_info;\r\n}\r\nstatic int serial_omap_probe_rs485(struct uart_omap_port *up,\r\nstruct device_node *np)\r\n{\r\nstruct serial_rs485 *rs485conf = &up->port.rs485;\r\nu32 rs485_delay[2];\r\nenum of_gpio_flags flags;\r\nint ret;\r\nrs485conf->flags = 0;\r\nup->rts_gpio = -EINVAL;\r\nif (!np)\r\nreturn 0;\r\nif (of_property_read_bool(np, "rs485-rts-active-high"))\r\nrs485conf->flags |= SER_RS485_RTS_ON_SEND;\r\nelse\r\nrs485conf->flags |= SER_RS485_RTS_AFTER_SEND;\r\nup->rts_gpio = of_get_named_gpio_flags(np, "rts-gpio", 0, &flags);\r\nif (gpio_is_valid(up->rts_gpio)) {\r\nret = devm_gpio_request(up->dev, up->rts_gpio, "omap-serial");\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpio_direction_output(up->rts_gpio,\r\nflags & SER_RS485_RTS_AFTER_SEND);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (up->rts_gpio == -EPROBE_DEFER) {\r\nreturn -EPROBE_DEFER;\r\n} else {\r\nup->rts_gpio = -EINVAL;\r\n}\r\nif (of_property_read_u32_array(np, "rs485-rts-delay",\r\nrs485_delay, 2) == 0) {\r\nrs485conf->delay_rts_before_send = rs485_delay[0];\r\nrs485conf->delay_rts_after_send = rs485_delay[1];\r\n}\r\nif (of_property_read_bool(np, "rs485-rx-during-tx"))\r\nrs485conf->flags |= SER_RS485_RX_DURING_TX;\r\nif (of_property_read_bool(np, "linux,rs485-enabled-at-boot-time"))\r\nrs485conf->flags |= SER_RS485_ENABLED;\r\nreturn 0;\r\n}\r\nstatic int serial_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_uart_port_info *omap_up_info = dev_get_platdata(&pdev->dev);\r\nstruct uart_omap_port *up;\r\nstruct resource *mem;\r\nvoid __iomem *base;\r\nint uartirq = 0;\r\nint wakeirq = 0;\r\nint ret;\r\nif (pdev->dev.of_node) {\r\nuartirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (!uartirq)\r\nreturn -EPROBE_DEFER;\r\nwakeirq = irq_of_parse_and_map(pdev->dev.of_node, 1);\r\nomap_up_info = of_get_uart_port_info(&pdev->dev);\r\npdev->dev.platform_data = omap_up_info;\r\n} else {\r\nuartirq = platform_get_irq(pdev, 0);\r\nif (uartirq < 0)\r\nreturn -EPROBE_DEFER;\r\n}\r\nup = devm_kzalloc(&pdev->dev, sizeof(*up), GFP_KERNEL);\r\nif (!up)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nup->dev = &pdev->dev;\r\nup->port.dev = &pdev->dev;\r\nup->port.type = PORT_OMAP;\r\nup->port.iotype = UPIO_MEM;\r\nup->port.irq = uartirq;\r\nup->port.regshift = 2;\r\nup->port.fifosize = 64;\r\nup->port.ops = &serial_omap_pops;\r\nif (pdev->dev.of_node)\r\nret = of_alias_get_id(pdev->dev.of_node, "serial");\r\nelse\r\nret = pdev->id;\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias/pdev id, errno %d\n",\r\nret);\r\ngoto err_port_line;\r\n}\r\nup->port.line = ret;\r\nif (up->port.line >= OMAP_MAX_HSUART_PORTS) {\r\ndev_err(&pdev->dev, "uart ID %d > MAX %d.\n", up->port.line,\r\nOMAP_MAX_HSUART_PORTS);\r\nret = -ENXIO;\r\ngoto err_port_line;\r\n}\r\nup->wakeirq = wakeirq;\r\nif (!up->wakeirq)\r\ndev_info(up->port.dev, "no wakeirq for uart%d\n",\r\nup->port.line);\r\nret = serial_omap_probe_rs485(up, pdev->dev.of_node);\r\nif (ret < 0)\r\ngoto err_rs485;\r\nsprintf(up->name, "OMAP UART%d", up->port.line);\r\nup->port.mapbase = mem->start;\r\nup->port.membase = base;\r\nup->port.flags = omap_up_info->flags;\r\nup->port.uartclk = omap_up_info->uartclk;\r\nup->port.rs485_config = serial_omap_config_rs485;\r\nif (!up->port.uartclk) {\r\nup->port.uartclk = DEFAULT_CLK_SPEED;\r\ndev_warn(&pdev->dev,\r\n"No clock speed specified: using default: %d\n",\r\nDEFAULT_CLK_SPEED);\r\n}\r\nup->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\nup->calc_latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\npm_qos_add_request(&up->pm_qos_request,\r\nPM_QOS_CPU_DMA_LATENCY, up->latency);\r\nINIT_WORK(&up->qos_work, serial_omap_uart_qos_work);\r\nplatform_set_drvdata(pdev, up);\r\nif (omap_up_info->autosuspend_timeout == 0)\r\nomap_up_info->autosuspend_timeout = -1;\r\ndevice_init_wakeup(up->dev, true);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev,\r\nomap_up_info->autosuspend_timeout);\r\npm_runtime_irq_safe(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nomap_serial_fill_features_erratas(up);\r\nui[up->port.line] = up;\r\nserial_omap_add_console_port(up);\r\nret = uart_add_one_port(&serial_omap_reg, &up->port);\r\nif (ret != 0)\r\ngoto err_add_port;\r\npm_runtime_mark_last_busy(up->dev);\r\npm_runtime_put_autosuspend(up->dev);\r\nreturn 0;\r\nerr_add_port:\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_qos_remove_request(&up->pm_qos_request);\r\ndevice_init_wakeup(up->dev, false);\r\nerr_rs485:\r\nerr_port_line:\r\nreturn ret;\r\n}\r\nstatic int serial_omap_remove(struct platform_device *dev)\r\n{\r\nstruct uart_omap_port *up = platform_get_drvdata(dev);\r\npm_runtime_put_sync(up->dev);\r\npm_runtime_disable(up->dev);\r\nuart_remove_one_port(&serial_omap_reg, &up->port);\r\npm_qos_remove_request(&up->pm_qos_request);\r\ndevice_init_wakeup(&dev->dev, false);\r\nreturn 0;\r\n}\r\nstatic void serial_omap_mdr1_errataset(struct uart_omap_port *up, u8 mdr1)\r\n{\r\nu8 timeout = 255;\r\nserial_out(up, UART_OMAP_MDR1, mdr1);\r\nudelay(2);\r\nserial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |\r\nUART_FCR_CLEAR_RCVR);\r\nwhile (UART_LSR_THRE != (serial_in(up, UART_LSR) &\r\n(UART_LSR_THRE | UART_LSR_DR))) {\r\ntimeout--;\r\nif (!timeout) {\r\ndev_crit(up->dev, "Errata i202: timedout %x\n",\r\nserial_in(up, UART_LSR));\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic void serial_omap_restore_context(struct uart_omap_port *up)\r\n{\r\nif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\r\nserial_omap_mdr1_errataset(up, UART_OMAP_MDR1_DISABLE);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0x0);\r\nserial_out(up, UART_IER, 0x0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_DLL, up->dll);\r\nserial_out(up, UART_DLM, up->dlh);\r\nserial_out(up, UART_LCR, 0x0);\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_FCR, up->fcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_OMAP_SCR, up->scr);\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, up->lcr);\r\nif (up->errata & UART_ERRATA_i202_MDR1_ACCESS)\r\nserial_omap_mdr1_errataset(up, up->mdr1);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, up->mdr1);\r\nserial_out(up, UART_OMAP_WER, up->wer);\r\n}\r\nstatic int serial_omap_runtime_suspend(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nif (!up)\r\nreturn -EINVAL;\r\nif (up->is_suspending && !console_suspend_enabled &&\r\nuart_console(&up->port))\r\nreturn -EBUSY;\r\nup->context_loss_cnt = serial_omap_get_context_loss_count(up);\r\nserial_omap_enable_wakeup(up, true);\r\nup->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\nschedule_work(&up->qos_work);\r\nreturn 0;\r\n}\r\nstatic int serial_omap_runtime_resume(struct device *dev)\r\n{\r\nstruct uart_omap_port *up = dev_get_drvdata(dev);\r\nint loss_cnt = serial_omap_get_context_loss_count(up);\r\nserial_omap_enable_wakeup(up, false);\r\nif (loss_cnt < 0) {\r\ndev_dbg(dev, "serial_omap_get_context_loss_count failed : %d\n",\r\nloss_cnt);\r\nserial_omap_restore_context(up);\r\n} else if (up->context_loss_cnt != loss_cnt) {\r\nserial_omap_restore_context(up);\r\n}\r\nup->latency = up->calc_latency;\r\nschedule_work(&up->qos_work);\r\nreturn 0;\r\n}\r\nstatic int __init serial_omap_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&serial_omap_reg);\r\nif (ret != 0)\r\nreturn ret;\r\nret = platform_driver_register(&serial_omap_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&serial_omap_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit serial_omap_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_omap_driver);\r\nuart_unregister_driver(&serial_omap_reg);\r\n}
