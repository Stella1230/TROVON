static int check_offs_len(struct mtd_info *mtd,\r\nloff_t ofs, uint64_t len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = 0;\r\nif (ofs & ((1ULL << chip->phys_erase_shift) - 1)) {\r\npr_debug("%s: unaligned address\n", __func__);\r\nret = -EINVAL;\r\n}\r\nif (len & ((1ULL << chip->phys_erase_shift) - 1)) {\r\npr_debug("%s: length not block aligned\n", __func__);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nand_release_device(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nspin_lock(&chip->controller->lock);\r\nchip->controller->active = NULL;\r\nchip->state = FL_READY;\r\nwake_up(&chip->controller->wq);\r\nspin_unlock(&chip->controller->lock);\r\n}\r\nstatic uint8_t nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn readb(chip->IO_ADDR_R);\r\n}\r\nstatic uint8_t nand_read_byte16(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn (uint8_t) cpu_to_le16(readw(chip->IO_ADDR_R));\r\n}\r\nstatic u16 nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn readw(chip->IO_ADDR_R);\r\n}\r\nstatic void nand_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nswitch (chipnr) {\r\ncase -1:\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void nand_write_byte(struct mtd_info *mtd, uint8_t byte)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nchip->write_buf(mtd, &byte, 1);\r\n}\r\nstatic void nand_write_byte16(struct mtd_info *mtd, uint8_t byte)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nuint16_t word = byte;\r\nchip->write_buf(mtd, (uint8_t *)&word, 2);\r\n}\r\nstatic void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\niowrite8_rep(chip->IO_ADDR_W, buf, len);\r\n}\r\nstatic void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nioread8_rep(chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\niowrite16_rep(chip->IO_ADDR_W, p, len >> 1);\r\n}\r\nstatic void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nioread16_rep(chip->IO_ADDR_R, p, len >> 1);\r\n}\r\nstatic int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)\r\n{\r\nint page, chipnr, res = 0, i = 0;\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 bad;\r\nif (chip->bbt_options & NAND_BBT_SCANLASTPAGE)\r\nofs += mtd->erasesize - mtd->writesize;\r\npage = (int)(ofs >> chip->page_shift) & chip->pagemask;\r\nif (getchip) {\r\nchipnr = (int)(ofs >> chip->chip_shift);\r\nnand_get_device(mtd, FL_READING);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\ndo {\r\nif (chip->options & NAND_BUSWIDTH_16) {\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB,\r\nchip->badblockpos & 0xFE, page);\r\nbad = cpu_to_le16(chip->read_word(mtd));\r\nif (chip->badblockpos & 0x1)\r\nbad >>= 8;\r\nelse\r\nbad &= 0xFF;\r\n} else {\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos,\r\npage);\r\nbad = chip->read_byte(mtd);\r\n}\r\nif (likely(chip->badblockbits == 8))\r\nres = bad != 0xFF;\r\nelse\r\nres = hweight8(bad) < chip->badblockbits;\r\nofs += mtd->writesize;\r\npage = (int)(ofs >> chip->page_shift) & chip->pagemask;\r\ni++;\r\n} while (!res && i < 2 && (chip->bbt_options & NAND_BBT_SCAN2NDPAGE));\r\nif (getchip) {\r\nchip->select_chip(mtd, -1);\r\nnand_release_device(mtd);\r\n}\r\nreturn res;\r\n}\r\nstatic int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mtd_oob_ops ops;\r\nuint8_t buf[2] = { 0, 0 };\r\nint ret = 0, res, i = 0;\r\nmemset(&ops, 0, sizeof(ops));\r\nops.oobbuf = buf;\r\nops.ooboffs = chip->badblockpos;\r\nif (chip->options & NAND_BUSWIDTH_16) {\r\nops.ooboffs &= ~0x01;\r\nops.len = ops.ooblen = 2;\r\n} else {\r\nops.len = ops.ooblen = 1;\r\n}\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nif (chip->bbt_options & NAND_BBT_SCANLASTPAGE)\r\nofs += mtd->erasesize - mtd->writesize;\r\ndo {\r\nres = nand_do_write_oob(mtd, ofs, &ops);\r\nif (!ret)\r\nret = res;\r\ni++;\r\nofs += mtd->writesize;\r\n} while ((chip->bbt_options & NAND_BBT_SCAN2NDPAGE) && i < 2);\r\nreturn ret;\r\n}\r\nstatic int nand_block_markbad_lowlevel(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint res, ret = 0;\r\nif (!(chip->bbt_options & NAND_BBT_NO_OOB_BBM)) {\r\nstruct erase_info einfo;\r\nmemset(&einfo, 0, sizeof(einfo));\r\neinfo.mtd = mtd;\r\neinfo.addr = ofs;\r\neinfo.len = 1ULL << chip->phys_erase_shift;\r\nnand_erase_nand(mtd, &einfo, 0);\r\nnand_get_device(mtd, FL_WRITING);\r\nret = chip->block_markbad(mtd, ofs);\r\nnand_release_device(mtd);\r\n}\r\nif (chip->bbt) {\r\nres = nand_markbad_bbt(mtd, ofs);\r\nif (!ret)\r\nret = res;\r\n}\r\nif (!ret)\r\nmtd->ecc_stats.badblocks++;\r\nreturn ret;\r\n}\r\nstatic int nand_check_wp(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->options & NAND_BROKEN_XD)\r\nreturn 0;\r\nchip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nreturn (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;\r\n}\r\nstatic int nand_block_isreserved(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (!chip->bbt)\r\nreturn 0;\r\nreturn nand_isreserved_bbt(mtd, ofs);\r\n}\r\nstatic int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,\r\nint allowbbt)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (!chip->bbt)\r\nreturn chip->block_bad(mtd, ofs, getchip);\r\nreturn nand_isbad_bbt(mtd, ofs, allowbbt);\r\n}\r\nstatic void panic_nand_wait_ready(struct mtd_info *mtd, unsigned long timeo)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint i;\r\nfor (i = 0; i < timeo; i++) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\ntouch_softlockup_watchdog();\r\nmdelay(1);\r\n}\r\n}\r\nvoid nand_wait_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned long timeo = jiffies + msecs_to_jiffies(20);\r\nif (in_interrupt() || oops_in_progress)\r\nreturn panic_nand_wait_ready(mtd, 400);\r\nled_trigger_event(nand_led_trigger, LED_FULL);\r\ndo {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\ntouch_softlockup_watchdog();\r\n} while (time_before(jiffies, timeo));\r\nled_trigger_event(nand_led_trigger, LED_OFF);\r\n}\r\nstatic void nand_wait_status_ready(struct mtd_info *mtd, unsigned long timeo)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\ntimeo = jiffies + msecs_to_jiffies(timeo);\r\ndo {\r\nif ((chip->read_byte(mtd) & NAND_STATUS_READY))\r\nbreak;\r\ntouch_softlockup_watchdog();\r\n} while (time_before(jiffies, timeo));\r\n}\r\nstatic void nand_command(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\nint ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;\r\nif (command == NAND_CMD_SEQIN) {\r\nint readcmd;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nreadcmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nreadcmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nreadcmd = NAND_CMD_READ1;\r\n}\r\nchip->cmd_ctrl(mtd, readcmd, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\n}\r\nchip->cmd_ctrl(mtd, command, ctrl);\r\nctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16 &&\r\n!nand_opcode_8bits(command))\r\ncolumn >>= 1;\r\nchip->cmd_ctrl(mtd, column, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\n}\r\nif (page_addr != -1) {\r\nchip->cmd_ctrl(mtd, page_addr, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\nchip->cmd_ctrl(mtd, page_addr >> 8, ctrl);\r\nif (chip->chipsize > (32 << 20))\r\nchip->cmd_ctrl(mtd, page_addr >> 16, ctrl);\r\n}\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nchip->cmd_ctrl(mtd, NAND_CMD_STATUS,\r\nNAND_CTRL_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd,\r\nNAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nnand_wait_status_ready(mtd, 250);\r\nreturn;\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nnand_wait_ready(mtd);\r\n}\r\nstatic void nand_command_lp(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\nif (command == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\n}\r\nchip->cmd_ctrl(mtd, command, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nif (column != -1 || page_addr != -1) {\r\nint ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16 &&\r\n!nand_opcode_8bits(command))\r\ncolumn >>= 1;\r\nchip->cmd_ctrl(mtd, column, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\nchip->cmd_ctrl(mtd, column >> 8, ctrl);\r\n}\r\nif (page_addr != -1) {\r\nchip->cmd_ctrl(mtd, page_addr, ctrl);\r\nchip->cmd_ctrl(mtd, page_addr >> 8,\r\nNAND_NCE | NAND_ALE);\r\nif (chip->chipsize > (128 << 20))\r\nchip->cmd_ctrl(mtd, page_addr >> 16,\r\nNAND_NCE | NAND_ALE);\r\n}\r\n}\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nchip->cmd_ctrl(mtd, NAND_CMD_STATUS,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\nnand_wait_status_ready(mtd, 250);\r\nreturn;\r\ncase NAND_CMD_RNDOUT:\r\nchip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\nreturn;\r\ncase NAND_CMD_READ0:\r\nchip->cmd_ctrl(mtd, NAND_CMD_READSTART,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nnand_wait_ready(mtd);\r\n}\r\nstatic void panic_nand_get_device(struct nand_chip *chip,\r\nstruct mtd_info *mtd, int new_state)\r\n{\r\nchip->controller->active = chip;\r\nchip->state = new_state;\r\n}\r\nstatic int\r\nnand_get_device(struct mtd_info *mtd, int new_state)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nspinlock_t *lock = &chip->controller->lock;\r\nwait_queue_head_t *wq = &chip->controller->wq;\r\nDECLARE_WAITQUEUE(wait, current);\r\nretry:\r\nspin_lock(lock);\r\nif (!chip->controller->active)\r\nchip->controller->active = chip;\r\nif (chip->controller->active == chip && chip->state == FL_READY) {\r\nchip->state = new_state;\r\nspin_unlock(lock);\r\nreturn 0;\r\n}\r\nif (new_state == FL_PM_SUSPENDED) {\r\nif (chip->controller->active->state == FL_PM_SUSPENDED) {\r\nchip->state = FL_PM_SUSPENDED;\r\nspin_unlock(lock);\r\nreturn 0;\r\n}\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(wq, &wait);\r\nspin_unlock(lock);\r\nschedule();\r\nremove_wait_queue(wq, &wait);\r\ngoto retry;\r\n}\r\nstatic void panic_nand_wait(struct mtd_info *mtd, struct nand_chip *chip,\r\nunsigned long timeo)\r\n{\r\nint i;\r\nfor (i = 0; i < timeo; i++) {\r\nif (chip->dev_ready) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\n} else {\r\nif (chip->read_byte(mtd) & NAND_STATUS_READY)\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\n}\r\nstatic int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nint status, state = chip->state;\r\nunsigned long timeo = (state == FL_ERASING ? 400 : 20);\r\nled_trigger_event(nand_led_trigger, LED_FULL);\r\nndelay(100);\r\nchip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nif (in_interrupt() || oops_in_progress)\r\npanic_nand_wait(mtd, chip, timeo);\r\nelse {\r\ntimeo = jiffies + msecs_to_jiffies(timeo);\r\nwhile (time_before(jiffies, timeo)) {\r\nif (chip->dev_ready) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\n} else {\r\nif (chip->read_byte(mtd) & NAND_STATUS_READY)\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\n}\r\nled_trigger_event(nand_led_trigger, LED_OFF);\r\nstatus = (int)chip->read_byte(mtd);\r\nWARN_ON(!(status & NAND_STATUS_READY));\r\nreturn status;\r\n}\r\nstatic int __nand_unlock(struct mtd_info *mtd, loff_t ofs,\r\nuint64_t len, int invert)\r\n{\r\nint ret = 0;\r\nint status, page;\r\nstruct nand_chip *chip = mtd->priv;\r\npage = ofs >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);\r\npage = (ofs + len) >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1,\r\n(page | invert) & chip->pagemask);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL) {\r\npr_debug("%s: error status = 0x%08x\n",\r\n__func__, status);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nint nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret = 0;\r\nint chipnr;\r\nstruct nand_chip *chip = mtd->priv;\r\npr_debug("%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)ofs, len);\r\nif (check_offs_len(mtd, ofs, len))\r\nreturn -EINVAL;\r\nif (ofs + len == mtd->size)\r\nlen -= mtd->erasesize;\r\nnand_get_device(mtd, FL_UNLOCKING);\r\nchipnr = ofs >> chip->chip_shift;\r\nchip->select_chip(mtd, chipnr);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nif (nand_check_wp(mtd)) {\r\npr_debug("%s: device is write protected!\n",\r\n__func__);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = __nand_unlock(mtd, ofs, len, 0);\r\nout:\r\nchip->select_chip(mtd, -1);\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nint nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret = 0;\r\nint chipnr, status, page;\r\nstruct nand_chip *chip = mtd->priv;\r\npr_debug("%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)ofs, len);\r\nif (check_offs_len(mtd, ofs, len))\r\nreturn -EINVAL;\r\nnand_get_device(mtd, FL_LOCKING);\r\nchipnr = ofs >> chip->chip_shift;\r\nchip->select_chip(mtd, chipnr);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nif (nand_check_wp(mtd)) {\r\npr_debug("%s: device is write protected!\n",\r\n__func__);\r\nstatus = MTD_ERASE_FAILED;\r\nret = -EIO;\r\ngoto out;\r\n}\r\npage = ofs >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_LOCK, -1, page & chip->pagemask);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL) {\r\npr_debug("%s: error status = 0x%08x\n",\r\n__func__, status);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = __nand_unlock(mtd, ofs, len, 0x1);\r\nout:\r\nchip->select_chip(mtd, -1);\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint8_t *oob = chip->oob_poi;\r\nint steps, size;\r\nfor (steps = chip->ecc.steps; steps > 0; steps--) {\r\nchip->read_buf(mtd, buf, eccsize);\r\nbuf += eccsize;\r\nif (chip->ecc.prepad) {\r\nchip->read_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->read_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->read_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\nsize = mtd->oobsize - (oob - chip->oob_poi);\r\nif (size)\r\nchip->read_buf(mtd, oob, size);\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nunsigned int max_bitflips = 0;\r\nchip->ecc.read_page_raw(mtd, chip, buf, 1, page);\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\neccsteps = chip->ecc.steps;\r\np = buf;\r\nfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t data_offs, uint32_t readlen, uint8_t *bufpoi,\r\nint page)\r\n{\r\nint start_step, end_step, num_steps;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *p;\r\nint data_col_addr, i, gaps = 0;\r\nint datafrag_len, eccfrag_len, aligned_len, aligned_pos;\r\nint busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;\r\nint index;\r\nunsigned int max_bitflips = 0;\r\nstart_step = data_offs / chip->ecc.size;\r\nend_step = (data_offs + readlen - 1) / chip->ecc.size;\r\nnum_steps = end_step - start_step + 1;\r\nindex = start_step * chip->ecc.bytes;\r\ndatafrag_len = num_steps * chip->ecc.size;\r\neccfrag_len = num_steps * chip->ecc.bytes;\r\ndata_col_addr = start_step * chip->ecc.size;\r\nif (data_col_addr != 0)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);\r\np = bufpoi + data_col_addr;\r\nchip->read_buf(mtd, p, datafrag_len);\r\nfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)\r\nchip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);\r\nfor (i = 0; i < eccfrag_len - 1; i++) {\r\nif (eccpos[i + index] + 1 != eccpos[i + index + 1]) {\r\ngaps = 1;\r\nbreak;\r\n}\r\n}\r\nif (gaps) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\n} else {\r\naligned_pos = eccpos[index] & ~(busw - 1);\r\naligned_len = eccfrag_len;\r\nif (eccpos[index] & (busw - 1))\r\naligned_len++;\r\nif (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))\r\naligned_len++;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nmtd->writesize + aligned_pos, -1);\r\nchip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);\r\n}\r\nfor (i = 0; i < eccfrag_len; i++)\r\nchip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];\r\np = bufpoi + data_col_addr;\r\nfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p,\r\n&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nunsigned int max_bitflips = 0;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\n}\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\neccsteps = chip->ecc.steps;\r\np = buf;\r\nfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nunsigned int max_bitflips = 0;\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nunsigned int max_bitflips = 0;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nif (chip->ecc.prepad) {\r\nchip->read_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->ecc.hwctl(mtd, NAND_ECC_READSYN);\r\nchip->read_buf(mtd, oob, eccbytes);\r\nstat = chip->ecc.correct(mtd, p, oob, NULL);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->read_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\ni = mtd->oobsize - (oob - chip->oob_poi);\r\nif (i)\r\nchip->read_buf(mtd, oob, i);\r\nreturn max_bitflips;\r\n}\r\nstatic uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,\r\nstruct mtd_oob_ops *ops, size_t len)\r\n{\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_RAW:\r\nmemcpy(oob, chip->oob_poi + ops->ooboffs, len);\r\nreturn oob + len;\r\ncase MTD_OPS_AUTO_OOB: {\r\nstruct nand_oobfree *free = chip->ecc.layout->oobfree;\r\nuint32_t boffs = 0, roffs = ops->ooboffs;\r\nsize_t bytes = 0;\r\nfor (; free->length && len; free++, len -= bytes) {\r\nif (unlikely(roffs)) {\r\nif (roffs >= free->length) {\r\nroffs -= free->length;\r\ncontinue;\r\n}\r\nboffs = free->offset + roffs;\r\nbytes = min_t(size_t, len,\r\n(free->length - roffs));\r\nroffs = 0;\r\n} else {\r\nbytes = min_t(size_t, len, free->length);\r\nboffs = free->offset;\r\n}\r\nmemcpy(oob, chip->oob_poi + boffs, bytes);\r\noob += bytes;\r\n}\r\nreturn oob;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nand_setup_read_retry(struct mtd_info *mtd, int retry_mode)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\npr_debug("setting READ RETRY mode %d\n", retry_mode);\r\nif (retry_mode >= chip->read_retries)\r\nreturn -EINVAL;\r\nif (!chip->setup_read_retry)\r\nreturn -EOPNOTSUPP;\r\nreturn chip->setup_read_retry(mtd, retry_mode);\r\n}\r\nstatic int nand_do_read_ops(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, page, realpage, col, bytes, aligned, oob_required;\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = 0;\r\nuint32_t readlen = ops->len;\r\nuint32_t oobreadlen = ops->ooblen;\r\nuint32_t max_oobsize = ops->mode == MTD_OPS_AUTO_OOB ?\r\nmtd->oobavail : mtd->oobsize;\r\nuint8_t *bufpoi, *oob, *buf;\r\nint use_bufpoi;\r\nunsigned int max_bitflips = 0;\r\nint retry_mode = 0;\r\nbool ecc_fail = false;\r\nchipnr = (int)(from >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nrealpage = (int)(from >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\ncol = (int)(from & (mtd->writesize - 1));\r\nbuf = ops->datbuf;\r\noob = ops->oobbuf;\r\noob_required = oob ? 1 : 0;\r\nwhile (1) {\r\nunsigned int ecc_failures = mtd->ecc_stats.failed;\r\nbytes = min(mtd->writesize - col, readlen);\r\naligned = (bytes == mtd->writesize);\r\nif (!aligned)\r\nuse_bufpoi = 1;\r\nelse if (chip->options & NAND_USE_BOUNCE_BUFFER)\r\nuse_bufpoi = !virt_addr_valid(buf);\r\nelse\r\nuse_bufpoi = 0;\r\nif (realpage != chip->pagebuf || oob) {\r\nbufpoi = use_bufpoi ? chip->buffers->databuf : buf;\r\nif (use_bufpoi && aligned)\r\npr_debug("%s: using read bounce buffer for buf@%p\n",\r\n__func__, buf);\r\nread_retry:\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);\r\nif (unlikely(ops->mode == MTD_OPS_RAW))\r\nret = chip->ecc.read_page_raw(mtd, chip, bufpoi,\r\noob_required,\r\npage);\r\nelse if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&\r\n!oob)\r\nret = chip->ecc.read_subpage(mtd, chip,\r\ncol, bytes, bufpoi,\r\npage);\r\nelse\r\nret = chip->ecc.read_page(mtd, chip, bufpoi,\r\noob_required, page);\r\nif (ret < 0) {\r\nif (use_bufpoi)\r\nchip->pagebuf = -1;\r\nbreak;\r\n}\r\nmax_bitflips = max_t(unsigned int, max_bitflips, ret);\r\nif (use_bufpoi) {\r\nif (!NAND_HAS_SUBPAGE_READ(chip) && !oob &&\r\n!(mtd->ecc_stats.failed - ecc_failures) &&\r\n(ops->mode != MTD_OPS_RAW)) {\r\nchip->pagebuf = realpage;\r\nchip->pagebuf_bitflips = ret;\r\n} else {\r\nchip->pagebuf = -1;\r\n}\r\nmemcpy(buf, chip->buffers->databuf + col, bytes);\r\n}\r\nif (unlikely(oob)) {\r\nint toread = min(oobreadlen, max_oobsize);\r\nif (toread) {\r\noob = nand_transfer_oob(chip,\r\noob, ops, toread);\r\noobreadlen -= toread;\r\n}\r\n}\r\nif (chip->options & NAND_NEED_READRDY) {\r\nif (!chip->dev_ready)\r\nudelay(chip->chip_delay);\r\nelse\r\nnand_wait_ready(mtd);\r\n}\r\nif (mtd->ecc_stats.failed - ecc_failures) {\r\nif (retry_mode + 1 < chip->read_retries) {\r\nretry_mode++;\r\nret = nand_setup_read_retry(mtd,\r\nretry_mode);\r\nif (ret < 0)\r\nbreak;\r\nmtd->ecc_stats.failed = ecc_failures;\r\ngoto read_retry;\r\n} else {\r\necc_fail = true;\r\n}\r\n}\r\nbuf += bytes;\r\n} else {\r\nmemcpy(buf, chip->buffers->databuf + col, bytes);\r\nbuf += bytes;\r\nmax_bitflips = max_t(unsigned int, max_bitflips,\r\nchip->pagebuf_bitflips);\r\n}\r\nreadlen -= bytes;\r\nif (retry_mode) {\r\nret = nand_setup_read_retry(mtd, 0);\r\nif (ret < 0)\r\nbreak;\r\nretry_mode = 0;\r\n}\r\nif (!readlen)\r\nbreak;\r\ncol = 0;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\n}\r\nchip->select_chip(mtd, -1);\r\nops->retlen = ops->len - (size_t) readlen;\r\nif (oob)\r\nops->oobretlen = ops->ooblen - oobreadlen;\r\nif (ret < 0)\r\nreturn ret;\r\nif (ecc_fail)\r\nreturn -EBADMSG;\r\nreturn max_bitflips;\r\n}\r\nstatic int nand_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nnand_get_device(mtd, FL_READING);\r\nmemset(&ops, 0, sizeof(ops));\r\nops.len = len;\r\nops.datbuf = buf;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nret = nand_do_read_ops(mtd, from, &ops);\r\n*retlen = ops.retlen;\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nint length = mtd->oobsize;\r\nint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\r\nint eccsize = chip->ecc.size;\r\nuint8_t *bufpoi = chip->oob_poi;\r\nint i, toread, sndrnd = 0, pos;\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nif (sndrnd) {\r\npos = eccsize + i * (eccsize + chunk);\r\nif (mtd->writesize > 512)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);\r\nelse\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);\r\n} else\r\nsndrnd = 1;\r\ntoread = min_t(int, length, chunk);\r\nchip->read_buf(mtd, bufpoi, toread);\r\nbufpoi += toread;\r\nlength -= toread;\r\n}\r\nif (length > 0)\r\nchip->read_buf(mtd, bufpoi, length);\r\nreturn 0;\r\n}\r\nstatic int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nint status = 0;\r\nconst uint8_t *buf = chip->oob_poi;\r\nint length = mtd->oobsize;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);\r\nchip->write_buf(mtd, buf, length);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int nand_write_oob_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int page)\r\n{\r\nint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\r\nint eccsize = chip->ecc.size, length = mtd->oobsize;\r\nint i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;\r\nconst uint8_t *bufpoi = chip->oob_poi;\r\nif (!chip->ecc.prepad && !chip->ecc.postpad) {\r\npos = steps * (eccsize + chunk);\r\nsteps = 0;\r\n} else\r\npos = eccsize;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);\r\nfor (i = 0; i < steps; i++) {\r\nif (sndcmd) {\r\nif (mtd->writesize <= 512) {\r\nuint32_t fill = 0xFFFFFFFF;\r\nlen = eccsize;\r\nwhile (len > 0) {\r\nint num = min_t(int, len, 4);\r\nchip->write_buf(mtd, (uint8_t *)&fill,\r\nnum);\r\nlen -= num;\r\n}\r\n} else {\r\npos = eccsize + i * (eccsize + chunk);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);\r\n}\r\n} else\r\nsndcmd = 1;\r\nlen = min_t(int, length, chunk);\r\nchip->write_buf(mtd, bufpoi, len);\r\nbufpoi += len;\r\nlength -= len;\r\n}\r\nif (length > 0)\r\nchip->write_buf(mtd, bufpoi, length);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int nand_do_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint page, realpage, chipnr;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mtd_ecc_stats stats;\r\nint readlen = ops->ooblen;\r\nint len;\r\nuint8_t *buf = ops->oobbuf;\r\nint ret = 0;\r\npr_debug("%s: from = 0x%08Lx, len = %i\n",\r\n__func__, (unsigned long long)from, readlen);\r\nstats = mtd->ecc_stats;\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nlen = chip->ecc.layout->oobavail;\r\nelse\r\nlen = mtd->oobsize;\r\nif (unlikely(ops->ooboffs >= len)) {\r\npr_debug("%s: attempt to start read outside oob\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(from >= mtd->size ||\r\nops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -\r\n(from >> chip->page_shift)) * len)) {\r\npr_debug("%s: attempt to read beyond end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nchipnr = (int)(from >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nrealpage = (int)(from >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\nwhile (1) {\r\nif (ops->mode == MTD_OPS_RAW)\r\nret = chip->ecc.read_oob_raw(mtd, chip, page);\r\nelse\r\nret = chip->ecc.read_oob(mtd, chip, page);\r\nif (ret < 0)\r\nbreak;\r\nlen = min(len, readlen);\r\nbuf = nand_transfer_oob(chip, buf, ops, len);\r\nif (chip->options & NAND_NEED_READRDY) {\r\nif (!chip->dev_ready)\r\nudelay(chip->chip_delay);\r\nelse\r\nnand_wait_ready(mtd);\r\n}\r\nreadlen -= len;\r\nif (!readlen)\r\nbreak;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\n}\r\nchip->select_chip(mtd, -1);\r\nops->oobretlen = ops->ooblen - readlen;\r\nif (ret < 0)\r\nreturn ret;\r\nif (mtd->ecc_stats.failed - stats.failed)\r\nreturn -EBADMSG;\r\nreturn mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;\r\n}\r\nstatic int nand_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint ret = -ENOTSUPP;\r\nops->retlen = 0;\r\nif (ops->datbuf && (from + ops->len) > mtd->size) {\r\npr_debug("%s: attempt to read beyond end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nnand_get_device(mtd, FL_READING);\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_AUTO_OOB:\r\ncase MTD_OPS_RAW:\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (!ops->datbuf)\r\nret = nand_do_read_oob(mtd, from, ops);\r\nelse\r\nret = nand_do_read_ops(mtd, from, ops);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_write_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint8_t *oob = chip->oob_poi;\r\nint steps, size;\r\nfor (steps = chip->ecc.steps; steps > 0; steps--) {\r\nchip->write_buf(mtd, buf, eccsize);\r\nbuf += eccsize;\r\nif (chip->ecc.prepad) {\r\nchip->write_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->write_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->write_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\nsize = mtd->oobsize - (oob - chip->oob_poi);\r\nif (size)\r\nchip->write_buf(mtd, oob, size);\r\nreturn 0;\r\n}\r\nstatic int nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nconst uint8_t *p = buf;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nreturn chip->ecc.write_page_raw(mtd, chip, buf, 1);\r\n}\r\nstatic int nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nconst uint8_t *p = buf;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\n}\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_write_subpage_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint32_t offset,\r\nuint32_t data_len, const uint8_t *buf,\r\nint oob_required)\r\n{\r\nuint8_t *oob_buf = chip->oob_poi;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nint ecc_size = chip->ecc.size;\r\nint ecc_bytes = chip->ecc.bytes;\r\nint ecc_steps = chip->ecc.steps;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint32_t start_step = offset / ecc_size;\r\nuint32_t end_step = (offset + data_len - 1) / ecc_size;\r\nint oob_bytes = mtd->oobsize / ecc_steps;\r\nint step, i;\r\nfor (step = 0; step < ecc_steps; step++) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, buf, ecc_size);\r\nif ((step < start_step) || (step > end_step))\r\nmemset(ecc_calc, 0xff, ecc_bytes);\r\nelse\r\nchip->ecc.calculate(mtd, buf, ecc_calc);\r\nif (!oob_required || (step < start_step) || (step > end_step))\r\nmemset(oob_buf, 0xff, oob_bytes);\r\nbuf += ecc_size;\r\necc_calc += ecc_bytes;\r\noob_buf += oob_bytes;\r\n}\r\necc_calc = chip->buffers->ecccalc;\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_write_page_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nconst uint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, p, eccsize);\r\nif (chip->ecc.prepad) {\r\nchip->write_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->ecc.calculate(mtd, p, oob);\r\nchip->write_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->write_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\ni = mtd->oobsize - (oob - chip->oob_poi);\r\nif (i)\r\nchip->write_buf(mtd, oob, i);\r\nreturn 0;\r\n}\r\nstatic int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t offset, int data_len, const uint8_t *buf,\r\nint oob_required, int page, int cached, int raw)\r\n{\r\nint status, subpage;\r\nif (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&\r\nchip->ecc.write_subpage)\r\nsubpage = offset || (data_len < mtd->writesize);\r\nelse\r\nsubpage = 0;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nif (unlikely(raw))\r\nstatus = chip->ecc.write_page_raw(mtd, chip, buf,\r\noob_required);\r\nelse if (subpage)\r\nstatus = chip->ecc.write_subpage(mtd, chip, offset, data_len,\r\nbuf, oob_required);\r\nelse\r\nstatus = chip->ecc.write_page(mtd, chip, buf, oob_required);\r\nif (status < 0)\r\nreturn status;\r\ncached = 0;\r\nif (!cached || !NAND_HAS_CACHEPROG(chip)) {\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_WRITING, status,\r\npage);\r\nif (status & NAND_STATUS_FAIL)\r\nreturn -EIO;\r\n} else {\r\nchip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic uint8_t *nand_fill_oob(struct mtd_info *mtd, uint8_t *oob, size_t len,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nmemset(chip->oob_poi, 0xff, mtd->oobsize);\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_RAW:\r\nmemcpy(chip->oob_poi + ops->ooboffs, oob, len);\r\nreturn oob + len;\r\ncase MTD_OPS_AUTO_OOB: {\r\nstruct nand_oobfree *free = chip->ecc.layout->oobfree;\r\nuint32_t boffs = 0, woffs = ops->ooboffs;\r\nsize_t bytes = 0;\r\nfor (; free->length && len; free++, len -= bytes) {\r\nif (unlikely(woffs)) {\r\nif (woffs >= free->length) {\r\nwoffs -= free->length;\r\ncontinue;\r\n}\r\nboffs = free->offset + woffs;\r\nbytes = min_t(size_t, len,\r\n(free->length - woffs));\r\nwoffs = 0;\r\n} else {\r\nbytes = min_t(size_t, len, free->length);\r\nboffs = free->offset;\r\n}\r\nmemcpy(chip->oob_poi + boffs, oob, bytes);\r\noob += bytes;\r\n}\r\nreturn oob;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nand_do_write_ops(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, realpage, page, blockmask, column;\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t writelen = ops->len;\r\nuint32_t oobwritelen = ops->ooblen;\r\nuint32_t oobmaxlen = ops->mode == MTD_OPS_AUTO_OOB ?\r\nmtd->oobavail : mtd->oobsize;\r\nuint8_t *oob = ops->oobbuf;\r\nuint8_t *buf = ops->datbuf;\r\nint ret;\r\nint oob_required = oob ? 1 : 0;\r\nops->retlen = 0;\r\nif (!writelen)\r\nreturn 0;\r\nif (NOTALIGNED(to) || NOTALIGNED(ops->len)) {\r\npr_notice("%s: attempt to write non page aligned data\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ncolumn = to & (mtd->writesize - 1);\r\nchipnr = (int)(to >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd)) {\r\nret = -EIO;\r\ngoto err_out;\r\n}\r\nrealpage = (int)(to >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\nblockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;\r\nif (to <= ((loff_t)chip->pagebuf << chip->page_shift) &&\r\n((loff_t)chip->pagebuf << chip->page_shift) < (to + ops->len))\r\nchip->pagebuf = -1;\r\nif (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen)) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nwhile (1) {\r\nint bytes = mtd->writesize;\r\nint cached = writelen > bytes && page != blockmask;\r\nuint8_t *wbuf = buf;\r\nint use_bufpoi;\r\nint part_pagewr = (column || writelen < (mtd->writesize - 1));\r\nif (part_pagewr)\r\nuse_bufpoi = 1;\r\nelse if (chip->options & NAND_USE_BOUNCE_BUFFER)\r\nuse_bufpoi = !virt_addr_valid(buf);\r\nelse\r\nuse_bufpoi = 0;\r\nif (use_bufpoi) {\r\npr_debug("%s: using write bounce buffer for buf@%p\n",\r\n__func__, buf);\r\ncached = 0;\r\nif (part_pagewr)\r\nbytes = min_t(int, bytes - column, writelen);\r\nchip->pagebuf = -1;\r\nmemset(chip->buffers->databuf, 0xff, mtd->writesize);\r\nmemcpy(&chip->buffers->databuf[column], buf, bytes);\r\nwbuf = chip->buffers->databuf;\r\n}\r\nif (unlikely(oob)) {\r\nsize_t len = min(oobwritelen, oobmaxlen);\r\noob = nand_fill_oob(mtd, oob, len, ops);\r\noobwritelen -= len;\r\n} else {\r\nmemset(chip->oob_poi, 0xff, mtd->oobsize);\r\n}\r\nret = chip->write_page(mtd, chip, column, bytes, wbuf,\r\noob_required, page, cached,\r\n(ops->mode == MTD_OPS_RAW));\r\nif (ret)\r\nbreak;\r\nwritelen -= bytes;\r\nif (!writelen)\r\nbreak;\r\ncolumn = 0;\r\nbuf += bytes;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\n}\r\nops->retlen = ops->len - writelen;\r\nif (unlikely(oob))\r\nops->oobretlen = ops->ooblen;\r\nerr_out:\r\nchip->select_chip(mtd, -1);\r\nreturn ret;\r\n}\r\nstatic int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const uint8_t *buf)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\npanic_nand_wait(mtd, chip, 400);\r\npanic_nand_get_device(chip, mtd, FL_WRITING);\r\nmemset(&ops, 0, sizeof(ops));\r\nops.len = len;\r\nops.datbuf = (uint8_t *)buf;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nret = nand_do_write_ops(mtd, to, &ops);\r\n*retlen = ops.retlen;\r\nreturn ret;\r\n}\r\nstatic int nand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const uint8_t *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nnand_get_device(mtd, FL_WRITING);\r\nmemset(&ops, 0, sizeof(ops));\r\nops.len = len;\r\nops.datbuf = (uint8_t *)buf;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nret = nand_do_write_ops(mtd, to, &ops);\r\n*retlen = ops.retlen;\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_do_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, page, status, len;\r\nstruct nand_chip *chip = mtd->priv;\r\npr_debug("%s: to = 0x%08x, len = %i\n",\r\n__func__, (unsigned int)to, (int)ops->ooblen);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nlen = chip->ecc.layout->oobavail;\r\nelse\r\nlen = mtd->oobsize;\r\nif ((ops->ooboffs + ops->ooblen) > len) {\r\npr_debug("%s: attempt to write past end of page\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(ops->ooboffs >= len)) {\r\npr_debug("%s: attempt to start write outside oob\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(to >= mtd->size ||\r\nops->ooboffs + ops->ooblen >\r\n((mtd->size >> chip->page_shift) -\r\n(to >> chip->page_shift)) * len)) {\r\npr_debug("%s: attempt to write beyond end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nchipnr = (int)(to >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\npage = (int)(to >> chip->page_shift);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nif (nand_check_wp(mtd)) {\r\nchip->select_chip(mtd, -1);\r\nreturn -EROFS;\r\n}\r\nif (page == chip->pagebuf)\r\nchip->pagebuf = -1;\r\nnand_fill_oob(mtd, ops->oobbuf, ops->ooblen, ops);\r\nif (ops->mode == MTD_OPS_RAW)\r\nstatus = chip->ecc.write_oob_raw(mtd, chip, page & chip->pagemask);\r\nelse\r\nstatus = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);\r\nchip->select_chip(mtd, -1);\r\nif (status)\r\nreturn status;\r\nops->oobretlen = ops->ooblen;\r\nreturn 0;\r\n}\r\nstatic int nand_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint ret = -ENOTSUPP;\r\nops->retlen = 0;\r\nif (ops->datbuf && (to + ops->len) > mtd->size) {\r\npr_debug("%s: attempt to write beyond end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nnand_get_device(mtd, FL_WRITING);\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_AUTO_OOB:\r\ncase MTD_OPS_RAW:\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (!ops->datbuf)\r\nret = nand_do_write_oob(mtd, to, ops);\r\nelse\r\nret = nand_do_write_ops(mtd, to, ops);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int single_erase(struct mtd_info *mtd, int page)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);\r\nreturn chip->waitfunc(mtd, chip);\r\n}\r\nstatic int nand_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nreturn nand_erase_nand(mtd, instr, 0);\r\n}\r\nint nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,\r\nint allowbbt)\r\n{\r\nint page, status, pages_per_block, ret, chipnr;\r\nstruct nand_chip *chip = mtd->priv;\r\nloff_t len;\r\npr_debug("%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)instr->addr,\r\n(unsigned long long)instr->len);\r\nif (check_offs_len(mtd, instr->addr, instr->len))\r\nreturn -EINVAL;\r\nnand_get_device(mtd, FL_ERASING);\r\npage = (int)(instr->addr >> chip->page_shift);\r\nchipnr = (int)(instr->addr >> chip->chip_shift);\r\npages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd)) {\r\npr_debug("%s: device is write protected!\n",\r\n__func__);\r\ninstr->state = MTD_ERASE_FAILED;\r\ngoto erase_exit;\r\n}\r\nlen = instr->len;\r\ninstr->state = MTD_ERASING;\r\nwhile (len) {\r\nif (nand_block_checkbad(mtd, ((loff_t) page) <<\r\nchip->page_shift, 0, allowbbt)) {\r\npr_warn("%s: attempt to erase a bad block at page 0x%08x\n",\r\n__func__, page);\r\ninstr->state = MTD_ERASE_FAILED;\r\ngoto erase_exit;\r\n}\r\nif (page <= chip->pagebuf && chip->pagebuf <\r\n(page + pages_per_block))\r\nchip->pagebuf = -1;\r\nstatus = chip->erase(mtd, page & chip->pagemask);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_ERASING,\r\nstatus, page);\r\nif (status & NAND_STATUS_FAIL) {\r\npr_debug("%s: failed erase, page 0x%08x\n",\r\n__func__, page);\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr =\r\n((loff_t)page << chip->page_shift);\r\ngoto erase_exit;\r\n}\r\nlen -= (1ULL << chip->phys_erase_shift);\r\npage += pages_per_block;\r\nif (len && !(page & chip->pagemask)) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nerase_exit:\r\nret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;\r\nchip->select_chip(mtd, -1);\r\nnand_release_device(mtd);\r\nif (!ret)\r\nmtd_erase_callback(instr);\r\nreturn ret;\r\n}\r\nstatic void nand_sync(struct mtd_info *mtd)\r\n{\r\npr_debug("%s: called\n", __func__);\r\nnand_get_device(mtd, FL_SYNCING);\r\nnand_release_device(mtd);\r\n}\r\nstatic int nand_block_isbad(struct mtd_info *mtd, loff_t offs)\r\n{\r\nreturn nand_block_checkbad(mtd, offs, 1, 0);\r\n}\r\nstatic int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nint ret;\r\nret = nand_block_isbad(mtd, ofs);\r\nif (ret) {\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nreturn nand_block_markbad_lowlevel(mtd, ofs);\r\n}\r\nstatic int nand_onfi_set_features(struct mtd_info *mtd, struct nand_chip *chip,\r\nint addr, uint8_t *subfeature_param)\r\n{\r\nint status;\r\nint i;\r\nif (!chip->onfi_version ||\r\n!(le16_to_cpu(chip->onfi_params.opt_cmd)\r\n& ONFI_OPT_CMD_SET_GET_FEATURES))\r\nreturn -EINVAL;\r\nchip->cmdfunc(mtd, NAND_CMD_SET_FEATURES, addr, -1);\r\nfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\r\nchip->write_byte(mtd, subfeature_param[i]);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int nand_onfi_get_features(struct mtd_info *mtd, struct nand_chip *chip,\r\nint addr, uint8_t *subfeature_param)\r\n{\r\nint i;\r\nif (!chip->onfi_version ||\r\n!(le16_to_cpu(chip->onfi_params.opt_cmd)\r\n& ONFI_OPT_CMD_SET_GET_FEATURES))\r\nreturn -EINVAL;\r\nchip->cmdfunc(mtd, NAND_CMD_GET_FEATURES, addr, -1);\r\nfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\r\n*subfeature_param++ = chip->read_byte(mtd);\r\nreturn 0;\r\n}\r\nstatic int nand_suspend(struct mtd_info *mtd)\r\n{\r\nreturn nand_get_device(mtd, FL_PM_SUSPENDED);\r\n}\r\nstatic void nand_resume(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->state == FL_PM_SUSPENDED)\r\nnand_release_device(mtd);\r\nelse\r\npr_err("%s called for a chip which is not in suspended state\n",\r\n__func__);\r\n}\r\nstatic void nand_shutdown(struct mtd_info *mtd)\r\n{\r\nnand_get_device(mtd, FL_SHUTDOWN);\r\n}\r\nstatic void nand_set_defaults(struct nand_chip *chip, int busw)\r\n{\r\nif (!chip->chip_delay)\r\nchip->chip_delay = 20;\r\nif (chip->cmdfunc == NULL)\r\nchip->cmdfunc = nand_command;\r\nif (chip->waitfunc == NULL)\r\nchip->waitfunc = nand_wait;\r\nif (!chip->select_chip)\r\nchip->select_chip = nand_select_chip;\r\nif (!chip->onfi_set_features)\r\nchip->onfi_set_features = nand_onfi_set_features;\r\nif (!chip->onfi_get_features)\r\nchip->onfi_get_features = nand_onfi_get_features;\r\nif (!chip->read_byte || chip->read_byte == nand_read_byte)\r\nchip->read_byte = busw ? nand_read_byte16 : nand_read_byte;\r\nif (!chip->read_word)\r\nchip->read_word = nand_read_word;\r\nif (!chip->block_bad)\r\nchip->block_bad = nand_block_bad;\r\nif (!chip->block_markbad)\r\nchip->block_markbad = nand_default_block_markbad;\r\nif (!chip->write_buf || chip->write_buf == nand_write_buf)\r\nchip->write_buf = busw ? nand_write_buf16 : nand_write_buf;\r\nif (!chip->write_byte || chip->write_byte == nand_write_byte)\r\nchip->write_byte = busw ? nand_write_byte16 : nand_write_byte;\r\nif (!chip->read_buf || chip->read_buf == nand_read_buf)\r\nchip->read_buf = busw ? nand_read_buf16 : nand_read_buf;\r\nif (!chip->scan_bbt)\r\nchip->scan_bbt = nand_default_bbt;\r\nif (!chip->controller) {\r\nchip->controller = &chip->hwcontrol;\r\nspin_lock_init(&chip->controller->lock);\r\ninit_waitqueue_head(&chip->controller->wq);\r\n}\r\n}\r\nstatic void sanitize_string(uint8_t *s, size_t len)\r\n{\r\nssize_t i;\r\ns[len - 1] = 0;\r\nfor (i = 0; i < len - 1; i++) {\r\nif (s[i] < ' ' || s[i] > 127)\r\ns[i] = '?';\r\n}\r\nstrim(s);\r\n}\r\nstatic u16 onfi_crc16(u16 crc, u8 const *p, size_t len)\r\n{\r\nint i;\r\nwhile (len--) {\r\ncrc ^= *p++ << 8;\r\nfor (i = 0; i < 8; i++)\r\ncrc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);\r\n}\r\nreturn crc;\r\n}\r\nstatic int nand_flash_detect_ext_param_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, struct nand_onfi_params *p)\r\n{\r\nstruct onfi_ext_param_page *ep;\r\nstruct onfi_ext_section *s;\r\nstruct onfi_ext_ecc_info *ecc;\r\nuint8_t *cursor;\r\nint ret = -EINVAL;\r\nint len;\r\nint i;\r\nlen = le16_to_cpu(p->ext_param_page_length) * 16;\r\nep = kmalloc(len, GFP_KERNEL);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nchip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nsizeof(*p) * p->num_of_param_pages , -1);\r\nchip->read_buf(mtd, (uint8_t *)ep, len);\r\nif ((onfi_crc16(ONFI_CRC_BASE, ((uint8_t *)ep) + 2, len - 2)\r\n!= le16_to_cpu(ep->crc))) {\r\npr_debug("fail in the CRC.\n");\r\ngoto ext_out;\r\n}\r\nif (strncmp(ep->sig, "EPPS", 4)) {\r\npr_debug("The signature is invalid.\n");\r\ngoto ext_out;\r\n}\r\ncursor = (uint8_t *)(ep + 1);\r\nfor (i = 0; i < ONFI_EXT_SECTION_MAX; i++) {\r\ns = ep->sections + i;\r\nif (s->type == ONFI_SECTION_TYPE_2)\r\nbreak;\r\ncursor += s->length * 16;\r\n}\r\nif (i == ONFI_EXT_SECTION_MAX) {\r\npr_debug("We can not find the ECC section.\n");\r\ngoto ext_out;\r\n}\r\necc = (struct onfi_ext_ecc_info *)cursor;\r\nif (!ecc->codeword_size) {\r\npr_debug("Invalid codeword size\n");\r\ngoto ext_out;\r\n}\r\nchip->ecc_strength_ds = ecc->ecc_bits;\r\nchip->ecc_step_ds = 1 << ecc->codeword_size;\r\nret = 0;\r\next_out:\r\nkfree(ep);\r\nreturn ret;\r\n}\r\nstatic int nand_setup_read_retry_micron(struct mtd_info *mtd, int retry_mode)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nuint8_t feature[ONFI_SUBFEATURE_PARAM_LEN] = {retry_mode};\r\nreturn chip->onfi_set_features(mtd, chip, ONFI_FEATURE_ADDR_READ_RETRY,\r\nfeature);\r\n}\r\nstatic void nand_onfi_detect_micron(struct nand_chip *chip,\r\nstruct nand_onfi_params *p)\r\n{\r\nstruct nand_onfi_vendor_micron *micron = (void *)p->vendor;\r\nif (le16_to_cpu(p->vendor_revision) < 1)\r\nreturn;\r\nchip->read_retries = micron->read_retry_options;\r\nchip->setup_read_retry = nand_setup_read_retry_micron;\r\n}\r\nstatic int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,\r\nint *busw)\r\n{\r\nstruct nand_onfi_params *p = &chip->onfi_params;\r\nint i, j;\r\nint val;\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);\r\nif (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||\r\nchip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')\r\nreturn 0;\r\nchip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);\r\nfor (i = 0; i < 3; i++) {\r\nfor (j = 0; j < sizeof(*p); j++)\r\n((uint8_t *)p)[j] = chip->read_byte(mtd);\r\nif (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==\r\nle16_to_cpu(p->crc)) {\r\nbreak;\r\n}\r\n}\r\nif (i == 3) {\r\npr_err("Could not find valid ONFI parameter page; aborting\n");\r\nreturn 0;\r\n}\r\nval = le16_to_cpu(p->revision);\r\nif (val & (1 << 5))\r\nchip->onfi_version = 23;\r\nelse if (val & (1 << 4))\r\nchip->onfi_version = 22;\r\nelse if (val & (1 << 3))\r\nchip->onfi_version = 21;\r\nelse if (val & (1 << 2))\r\nchip->onfi_version = 20;\r\nelse if (val & (1 << 1))\r\nchip->onfi_version = 10;\r\nif (!chip->onfi_version) {\r\npr_info("unsupported ONFI version: %d\n", val);\r\nreturn 0;\r\n}\r\nsanitize_string(p->manufacturer, sizeof(p->manufacturer));\r\nsanitize_string(p->model, sizeof(p->model));\r\nif (!mtd->name)\r\nmtd->name = p->model;\r\nmtd->writesize = le32_to_cpu(p->byte_per_page);\r\nmtd->erasesize = 1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);\r\nmtd->erasesize *= mtd->writesize;\r\nmtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);\r\nchip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);\r\nchip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;\r\nchip->bits_per_cell = p->bits_per_cell;\r\nif (onfi_feature(chip) & ONFI_FEATURE_16_BIT_BUS)\r\n*busw = NAND_BUSWIDTH_16;\r\nelse\r\n*busw = 0;\r\nif (p->ecc_bits != 0xff) {\r\nchip->ecc_strength_ds = p->ecc_bits;\r\nchip->ecc_step_ds = 512;\r\n} else if (chip->onfi_version >= 21 &&\r\n(onfi_feature(chip) & ONFI_FEATURE_EXT_PARAM_PAGE)) {\r\nif (mtd->writesize > 512 && chip->cmdfunc == nand_command)\r\nchip->cmdfunc = nand_command_lp;\r\nif (nand_flash_detect_ext_param_page(mtd, chip, p))\r\npr_warn("Failed to detect ONFI extended param page\n");\r\n} else {\r\npr_warn("Could not retrieve ONFI ECC requirements\n");\r\n}\r\nif (p->jedec_id == NAND_MFR_MICRON)\r\nnand_onfi_detect_micron(chip, p);\r\nreturn 1;\r\n}\r\nstatic int nand_flash_detect_jedec(struct mtd_info *mtd, struct nand_chip *chip,\r\nint *busw)\r\n{\r\nstruct nand_jedec_params *p = &chip->jedec_params;\r\nstruct jedec_ecc_info *ecc;\r\nint val;\r\nint i, j;\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x40, -1);\r\nif (chip->read_byte(mtd) != 'J' || chip->read_byte(mtd) != 'E' ||\r\nchip->read_byte(mtd) != 'D' || chip->read_byte(mtd) != 'E' ||\r\nchip->read_byte(mtd) != 'C')\r\nreturn 0;\r\nchip->cmdfunc(mtd, NAND_CMD_PARAM, 0x40, -1);\r\nfor (i = 0; i < 3; i++) {\r\nfor (j = 0; j < sizeof(*p); j++)\r\n((uint8_t *)p)[j] = chip->read_byte(mtd);\r\nif (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 510) ==\r\nle16_to_cpu(p->crc))\r\nbreak;\r\n}\r\nif (i == 3) {\r\npr_err("Could not find valid JEDEC parameter page; aborting\n");\r\nreturn 0;\r\n}\r\nval = le16_to_cpu(p->revision);\r\nif (val & (1 << 2))\r\nchip->jedec_version = 10;\r\nelse if (val & (1 << 1))\r\nchip->jedec_version = 1;\r\nif (!chip->jedec_version) {\r\npr_info("unsupported JEDEC version: %d\n", val);\r\nreturn 0;\r\n}\r\nsanitize_string(p->manufacturer, sizeof(p->manufacturer));\r\nsanitize_string(p->model, sizeof(p->model));\r\nif (!mtd->name)\r\nmtd->name = p->model;\r\nmtd->writesize = le32_to_cpu(p->byte_per_page);\r\nmtd->erasesize = 1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);\r\nmtd->erasesize *= mtd->writesize;\r\nmtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);\r\nchip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);\r\nchip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;\r\nchip->bits_per_cell = p->bits_per_cell;\r\nif (jedec_feature(chip) & JEDEC_FEATURE_16_BIT_BUS)\r\n*busw = NAND_BUSWIDTH_16;\r\nelse\r\n*busw = 0;\r\necc = &p->ecc_info[0];\r\nif (ecc->codeword_size >= 9) {\r\nchip->ecc_strength_ds = ecc->ecc_bits;\r\nchip->ecc_step_ds = 1 << ecc->codeword_size;\r\n} else {\r\npr_warn("Invalid codeword size\n");\r\n}\r\nreturn 1;\r\n}\r\nstatic int nand_id_has_period(u8 *id_data, int arrlen, int period)\r\n{\r\nint i, j;\r\nfor (i = 0; i < period; i++)\r\nfor (j = i + period; j < arrlen; j += period)\r\nif (id_data[i] != id_data[j])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int nand_id_len(u8 *id_data, int arrlen)\r\n{\r\nint last_nonzero, period;\r\nfor (last_nonzero = arrlen - 1; last_nonzero >= 0; last_nonzero--)\r\nif (id_data[last_nonzero])\r\nbreak;\r\nif (last_nonzero < 0)\r\nreturn 0;\r\nfor (period = 1; period < arrlen; period++)\r\nif (nand_id_has_period(id_data, arrlen, period))\r\nbreak;\r\nif (period < arrlen)\r\nreturn period;\r\nif (last_nonzero < arrlen - 1)\r\nreturn last_nonzero + 1;\r\nreturn arrlen;\r\n}\r\nstatic int nand_get_bits_per_cell(u8 cellinfo)\r\n{\r\nint bits;\r\nbits = cellinfo & NAND_CI_CELLTYPE_MSK;\r\nbits >>= NAND_CI_CELLTYPE_SHIFT;\r\nreturn bits + 1;\r\n}\r\nstatic void nand_decode_ext_id(struct mtd_info *mtd, struct nand_chip *chip,\r\nu8 id_data[8], int *busw)\r\n{\r\nint extid, id_len;\r\nchip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\r\nextid = id_data[3];\r\nid_len = nand_id_len(id_data, 8);\r\nif (id_len == 6 && id_data[0] == NAND_MFR_SAMSUNG &&\r\n!nand_is_slc(chip) && id_data[5] != 0x00) {\r\nmtd->writesize = 2048 << (extid & 0x03);\r\nextid >>= 2;\r\nswitch (((extid >> 2) & 0x04) | (extid & 0x03)) {\r\ncase 1:\r\nmtd->oobsize = 128;\r\nbreak;\r\ncase 2:\r\nmtd->oobsize = 218;\r\nbreak;\r\ncase 3:\r\nmtd->oobsize = 400;\r\nbreak;\r\ncase 4:\r\nmtd->oobsize = 436;\r\nbreak;\r\ncase 5:\r\nmtd->oobsize = 512;\r\nbreak;\r\ncase 6:\r\nmtd->oobsize = 640;\r\nbreak;\r\ncase 7:\r\ndefault:\r\nmtd->oobsize = 1024;\r\nbreak;\r\n}\r\nextid >>= 2;\r\nmtd->erasesize = (128 * 1024) <<\r\n(((extid >> 1) & 0x04) | (extid & 0x03));\r\n*busw = 0;\r\n} else if (id_len == 6 && id_data[0] == NAND_MFR_HYNIX &&\r\n!nand_is_slc(chip)) {\r\nunsigned int tmp;\r\nmtd->writesize = 2048 << (extid & 0x03);\r\nextid >>= 2;\r\nswitch (((extid >> 2) & 0x04) | (extid & 0x03)) {\r\ncase 0:\r\nmtd->oobsize = 128;\r\nbreak;\r\ncase 1:\r\nmtd->oobsize = 224;\r\nbreak;\r\ncase 2:\r\nmtd->oobsize = 448;\r\nbreak;\r\ncase 3:\r\nmtd->oobsize = 64;\r\nbreak;\r\ncase 4:\r\nmtd->oobsize = 32;\r\nbreak;\r\ncase 5:\r\nmtd->oobsize = 16;\r\nbreak;\r\ndefault:\r\nmtd->oobsize = 640;\r\nbreak;\r\n}\r\nextid >>= 2;\r\ntmp = ((extid >> 1) & 0x04) | (extid & 0x03);\r\nif (tmp < 0x03)\r\nmtd->erasesize = (128 * 1024) << tmp;\r\nelse if (tmp == 0x03)\r\nmtd->erasesize = 768 * 1024;\r\nelse\r\nmtd->erasesize = (64 * 1024) << tmp;\r\n*busw = 0;\r\n} else {\r\nmtd->writesize = 1024 << (extid & 0x03);\r\nextid >>= 2;\r\nmtd->oobsize = (8 << (extid & 0x01)) *\r\n(mtd->writesize >> 9);\r\nextid >>= 2;\r\nmtd->erasesize = (64 * 1024) << (extid & 0x03);\r\nextid >>= 2;\r\n*busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;\r\nif (id_len >= 6 && id_data[0] == NAND_MFR_TOSHIBA &&\r\nnand_is_slc(chip) &&\r\n(id_data[5] & 0x7) == 0x6 &&\r\n!(id_data[4] & 0x80) ) {\r\nmtd->oobsize = 32 * mtd->writesize >> 9;\r\n}\r\n}\r\n}\r\nstatic void nand_decode_id(struct mtd_info *mtd, struct nand_chip *chip,\r\nstruct nand_flash_dev *type, u8 id_data[8],\r\nint *busw)\r\n{\r\nint maf_id = id_data[0];\r\nmtd->erasesize = type->erasesize;\r\nmtd->writesize = type->pagesize;\r\nmtd->oobsize = mtd->writesize / 32;\r\n*busw = type->options & NAND_BUSWIDTH_16;\r\nchip->bits_per_cell = 1;\r\nif (maf_id == NAND_MFR_AMD && id_data[4] != 0x00 && id_data[5] == 0x00\r\n&& id_data[6] == 0x00 && id_data[7] == 0x00\r\n&& mtd->writesize == 512) {\r\nmtd->erasesize = 128 * 1024;\r\nmtd->erasesize <<= ((id_data[3] & 0x03) << 1);\r\n}\r\n}\r\nstatic void nand_decode_bbm_options(struct mtd_info *mtd,\r\nstruct nand_chip *chip, u8 id_data[8])\r\n{\r\nint maf_id = id_data[0];\r\nif (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))\r\nchip->badblockpos = NAND_LARGE_BADBLOCK_POS;\r\nelse\r\nchip->badblockpos = NAND_SMALL_BADBLOCK_POS;\r\nif (!nand_is_slc(chip) &&\r\n(maf_id == NAND_MFR_SAMSUNG ||\r\nmaf_id == NAND_MFR_HYNIX))\r\nchip->bbt_options |= NAND_BBT_SCANLASTPAGE;\r\nelse if ((nand_is_slc(chip) &&\r\n(maf_id == NAND_MFR_SAMSUNG ||\r\nmaf_id == NAND_MFR_HYNIX ||\r\nmaf_id == NAND_MFR_TOSHIBA ||\r\nmaf_id == NAND_MFR_AMD ||\r\nmaf_id == NAND_MFR_MACRONIX)) ||\r\n(mtd->writesize == 2048 &&\r\nmaf_id == NAND_MFR_MICRON))\r\nchip->bbt_options |= NAND_BBT_SCAN2NDPAGE;\r\n}\r\nstatic inline bool is_full_id_nand(struct nand_flash_dev *type)\r\n{\r\nreturn type->id_len;\r\n}\r\nstatic bool find_full_id_nand(struct mtd_info *mtd, struct nand_chip *chip,\r\nstruct nand_flash_dev *type, u8 *id_data, int *busw)\r\n{\r\nif (!strncmp(type->id, id_data, type->id_len)) {\r\nmtd->writesize = type->pagesize;\r\nmtd->erasesize = type->erasesize;\r\nmtd->oobsize = type->oobsize;\r\nchip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\r\nchip->chipsize = (uint64_t)type->chipsize << 20;\r\nchip->options |= type->options;\r\nchip->ecc_strength_ds = NAND_ECC_STRENGTH(type);\r\nchip->ecc_step_ds = NAND_ECC_STEP(type);\r\nchip->onfi_timing_mode_default =\r\ntype->onfi_timing_mode_default;\r\n*busw = type->options & NAND_BUSWIDTH_16;\r\nif (!mtd->name)\r\nmtd->name = type->name;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nint *maf_id, int *dev_id,\r\nstruct nand_flash_dev *type)\r\n{\r\nint busw;\r\nint i, maf_idx;\r\nu8 id_data[8];\r\nchip->select_chip(mtd, 0);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\n*maf_id = chip->read_byte(mtd);\r\n*dev_id = chip->read_byte(mtd);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nfor (i = 0; i < 8; i++)\r\nid_data[i] = chip->read_byte(mtd);\r\nif (id_data[0] != *maf_id || id_data[1] != *dev_id) {\r\npr_info("second ID read did not match %02x,%02x against %02x,%02x\n",\r\n*maf_id, *dev_id, id_data[0], id_data[1]);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (!type)\r\ntype = nand_flash_ids;\r\nfor (; type->name != NULL; type++) {\r\nif (is_full_id_nand(type)) {\r\nif (find_full_id_nand(mtd, chip, type, id_data, &busw))\r\ngoto ident_done;\r\n} else if (*dev_id == type->dev_id) {\r\nbreak;\r\n}\r\n}\r\nchip->onfi_version = 0;\r\nif (!type->name || !type->pagesize) {\r\nif (nand_flash_detect_onfi(mtd, chip, &busw))\r\ngoto ident_done;\r\nif (nand_flash_detect_jedec(mtd, chip, &busw))\r\ngoto ident_done;\r\n}\r\nif (!type->name)\r\nreturn ERR_PTR(-ENODEV);\r\nif (!mtd->name)\r\nmtd->name = type->name;\r\nchip->chipsize = (uint64_t)type->chipsize << 20;\r\nif (!type->pagesize && chip->init_size) {\r\nbusw = chip->init_size(mtd, chip, id_data);\r\n} else if (!type->pagesize) {\r\nnand_decode_ext_id(mtd, chip, id_data, &busw);\r\n} else {\r\nnand_decode_id(mtd, chip, type, id_data, &busw);\r\n}\r\nchip->options |= type->options;\r\nif (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)\r\nchip->options &= ~NAND_SAMSUNG_LP_OPTIONS;\r\nident_done:\r\nfor (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {\r\nif (nand_manuf_ids[maf_idx].id == *maf_id)\r\nbreak;\r\n}\r\nif (chip->options & NAND_BUSWIDTH_AUTO) {\r\nWARN_ON(chip->options & NAND_BUSWIDTH_16);\r\nchip->options |= busw;\r\nnand_set_defaults(chip, busw);\r\n} else if (busw != (chip->options & NAND_BUSWIDTH_16)) {\r\npr_info("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",\r\n*maf_id, *dev_id);\r\npr_info("%s %s\n", nand_manuf_ids[maf_idx].name, mtd->name);\r\npr_warn("bus width %d instead %d bit\n",\r\n(chip->options & NAND_BUSWIDTH_16) ? 16 : 8,\r\nbusw ? 16 : 8);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnand_decode_bbm_options(mtd, chip, id_data);\r\nchip->page_shift = ffs(mtd->writesize) - 1;\r\nchip->pagemask = (chip->chipsize >> chip->page_shift) - 1;\r\nchip->bbt_erase_shift = chip->phys_erase_shift =\r\nffs(mtd->erasesize) - 1;\r\nif (chip->chipsize & 0xffffffff)\r\nchip->chip_shift = ffs((unsigned)chip->chipsize) - 1;\r\nelse {\r\nchip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));\r\nchip->chip_shift += 32 - 1;\r\n}\r\nchip->badblockbits = 8;\r\nchip->erase = single_erase;\r\nif (mtd->writesize > 512 && chip->cmdfunc == nand_command)\r\nchip->cmdfunc = nand_command_lp;\r\npr_info("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",\r\n*maf_id, *dev_id);\r\nif (chip->onfi_version)\r\npr_info("%s %s\n", nand_manuf_ids[maf_idx].name,\r\nchip->onfi_params.model);\r\nelse if (chip->jedec_version)\r\npr_info("%s %s\n", nand_manuf_ids[maf_idx].name,\r\nchip->jedec_params.model);\r\nelse\r\npr_info("%s %s\n", nand_manuf_ids[maf_idx].name,\r\ntype->name);\r\npr_info("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",\r\n(int)(chip->chipsize >> 20), nand_is_slc(chip) ? "SLC" : "MLC",\r\nmtd->erasesize >> 10, mtd->writesize, mtd->oobsize);\r\nreturn type;\r\n}\r\nstatic int nand_dt_init(struct mtd_info *mtd, struct nand_chip *chip,\r\nstruct device_node *dn)\r\n{\r\nint ecc_mode, ecc_strength, ecc_step;\r\nif (of_get_nand_bus_width(dn) == 16)\r\nchip->options |= NAND_BUSWIDTH_16;\r\nif (of_get_nand_on_flash_bbt(dn))\r\nchip->bbt_options |= NAND_BBT_USE_FLASH;\r\necc_mode = of_get_nand_ecc_mode(dn);\r\necc_strength = of_get_nand_ecc_strength(dn);\r\necc_step = of_get_nand_ecc_step_size(dn);\r\nif ((ecc_step >= 0 && !(ecc_strength >= 0)) ||\r\n(!(ecc_step >= 0) && ecc_strength >= 0)) {\r\npr_err("must set both strength and step size in DT\n");\r\nreturn -EINVAL;\r\n}\r\nif (ecc_mode >= 0)\r\nchip->ecc.mode = ecc_mode;\r\nif (ecc_strength >= 0)\r\nchip->ecc.strength = ecc_strength;\r\nif (ecc_step > 0)\r\nchip->ecc.size = ecc_step;\r\nreturn 0;\r\n}\r\nint nand_scan_ident(struct mtd_info *mtd, int maxchips,\r\nstruct nand_flash_dev *table)\r\n{\r\nint i, nand_maf_id, nand_dev_id;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct nand_flash_dev *type;\r\nint ret;\r\nif (chip->dn) {\r\nret = nand_dt_init(mtd, chip, chip->dn);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnand_set_defaults(chip, chip->options & NAND_BUSWIDTH_16);\r\ntype = nand_get_flash_type(mtd, chip, &nand_maf_id,\r\n&nand_dev_id, table);\r\nif (IS_ERR(type)) {\r\nif (!(chip->options & NAND_SCAN_SILENT_NODEV))\r\npr_warn("No NAND device found\n");\r\nchip->select_chip(mtd, -1);\r\nreturn PTR_ERR(type);\r\n}\r\nchip->select_chip(mtd, -1);\r\nfor (i = 1; i < maxchips; i++) {\r\nchip->select_chip(mtd, i);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nif (nand_maf_id != chip->read_byte(mtd) ||\r\nnand_dev_id != chip->read_byte(mtd)) {\r\nchip->select_chip(mtd, -1);\r\nbreak;\r\n}\r\nchip->select_chip(mtd, -1);\r\n}\r\nif (i > 1)\r\npr_info("%d chips detected\n", i);\r\nchip->numchips = i;\r\nmtd->size = i * chip->chipsize;\r\nreturn 0;\r\n}\r\nstatic bool nand_ecc_strength_good(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint corr, ds_corr;\r\nif (ecc->size == 0 || chip->ecc_step_ds == 0)\r\nreturn true;\r\ncorr = (mtd->writesize * ecc->strength) / ecc->size;\r\nds_corr = (mtd->writesize * chip->ecc_strength_ds) / chip->ecc_step_ds;\r\nreturn corr >= ds_corr && ecc->strength >= chip->ecc_strength_ds;\r\n}\r\nint nand_scan_tail(struct mtd_info *mtd)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct nand_buffers *nbuf;\r\nBUG_ON((chip->bbt_options & NAND_BBT_NO_OOB_BBM) &&\r\n!(chip->bbt_options & NAND_BBT_USE_FLASH));\r\nif (!(chip->options & NAND_OWN_BUFFERS)) {\r\nnbuf = kzalloc(sizeof(*nbuf) + mtd->writesize\r\n+ mtd->oobsize * 3, GFP_KERNEL);\r\nif (!nbuf)\r\nreturn -ENOMEM;\r\nnbuf->ecccalc = (uint8_t *)(nbuf + 1);\r\nnbuf->ecccode = nbuf->ecccalc + mtd->oobsize;\r\nnbuf->databuf = nbuf->ecccode + mtd->oobsize;\r\nchip->buffers = nbuf;\r\n} else {\r\nif (!chip->buffers)\r\nreturn -ENOMEM;\r\n}\r\nchip->oob_poi = chip->buffers->databuf + mtd->writesize;\r\nif (!ecc->layout && (ecc->mode != NAND_ECC_SOFT_BCH)) {\r\nswitch (mtd->oobsize) {\r\ncase 8:\r\necc->layout = &nand_oob_8;\r\nbreak;\r\ncase 16:\r\necc->layout = &nand_oob_16;\r\nbreak;\r\ncase 64:\r\necc->layout = &nand_oob_64;\r\nbreak;\r\ncase 128:\r\necc->layout = &nand_oob_128;\r\nbreak;\r\ndefault:\r\npr_warn("No oob scheme defined for oobsize %d\n",\r\nmtd->oobsize);\r\nBUG();\r\n}\r\n}\r\nif (!chip->write_page)\r\nchip->write_page = nand_write_page;\r\nswitch (ecc->mode) {\r\ncase NAND_ECC_HW_OOB_FIRST:\r\nif (!ecc->calculate || !ecc->correct || !ecc->hwctl) {\r\npr_warn("No ECC functions supplied; hardware ECC not possible\n");\r\nBUG();\r\n}\r\nif (!ecc->read_page)\r\necc->read_page = nand_read_page_hwecc_oob_first;\r\ncase NAND_ECC_HW:\r\nif (!ecc->read_page)\r\necc->read_page = nand_read_page_hwecc;\r\nif (!ecc->write_page)\r\necc->write_page = nand_write_page_hwecc;\r\nif (!ecc->read_page_raw)\r\necc->read_page_raw = nand_read_page_raw;\r\nif (!ecc->write_page_raw)\r\necc->write_page_raw = nand_write_page_raw;\r\nif (!ecc->read_oob)\r\necc->read_oob = nand_read_oob_std;\r\nif (!ecc->write_oob)\r\necc->write_oob = nand_write_oob_std;\r\nif (!ecc->read_subpage)\r\necc->read_subpage = nand_read_subpage;\r\nif (!ecc->write_subpage)\r\necc->write_subpage = nand_write_subpage_hwecc;\r\ncase NAND_ECC_HW_SYNDROME:\r\nif ((!ecc->calculate || !ecc->correct || !ecc->hwctl) &&\r\n(!ecc->read_page ||\r\necc->read_page == nand_read_page_hwecc ||\r\n!ecc->write_page ||\r\necc->write_page == nand_write_page_hwecc)) {\r\npr_warn("No ECC functions supplied; hardware ECC not possible\n");\r\nBUG();\r\n}\r\nif (!ecc->read_page)\r\necc->read_page = nand_read_page_syndrome;\r\nif (!ecc->write_page)\r\necc->write_page = nand_write_page_syndrome;\r\nif (!ecc->read_page_raw)\r\necc->read_page_raw = nand_read_page_raw_syndrome;\r\nif (!ecc->write_page_raw)\r\necc->write_page_raw = nand_write_page_raw_syndrome;\r\nif (!ecc->read_oob)\r\necc->read_oob = nand_read_oob_syndrome;\r\nif (!ecc->write_oob)\r\necc->write_oob = nand_write_oob_syndrome;\r\nif (mtd->writesize >= ecc->size) {\r\nif (!ecc->strength) {\r\npr_warn("Driver must set ecc.strength when using hardware ECC\n");\r\nBUG();\r\n}\r\nbreak;\r\n}\r\npr_warn("%d byte HW ECC not possible on %d byte page size, fallback to SW ECC\n",\r\necc->size, mtd->writesize);\r\necc->mode = NAND_ECC_SOFT;\r\ncase NAND_ECC_SOFT:\r\necc->calculate = nand_calculate_ecc;\r\necc->correct = nand_correct_data;\r\necc->read_page = nand_read_page_swecc;\r\necc->read_subpage = nand_read_subpage;\r\necc->write_page = nand_write_page_swecc;\r\necc->read_page_raw = nand_read_page_raw;\r\necc->write_page_raw = nand_write_page_raw;\r\necc->read_oob = nand_read_oob_std;\r\necc->write_oob = nand_write_oob_std;\r\nif (!ecc->size)\r\necc->size = 256;\r\necc->bytes = 3;\r\necc->strength = 1;\r\nbreak;\r\ncase NAND_ECC_SOFT_BCH:\r\nif (!mtd_nand_has_bch()) {\r\npr_warn("CONFIG_MTD_NAND_ECC_BCH not enabled\n");\r\nBUG();\r\n}\r\necc->calculate = nand_bch_calculate_ecc;\r\necc->correct = nand_bch_correct_data;\r\necc->read_page = nand_read_page_swecc;\r\necc->read_subpage = nand_read_subpage;\r\necc->write_page = nand_write_page_swecc;\r\necc->read_page_raw = nand_read_page_raw;\r\necc->write_page_raw = nand_write_page_raw;\r\necc->read_oob = nand_read_oob_std;\r\necc->write_oob = nand_write_oob_std;\r\nif (!ecc->size && (mtd->oobsize >= 64)) {\r\necc->size = 512;\r\necc->strength = 4;\r\n}\r\necc->bytes = DIV_ROUND_UP(\r\necc->strength * fls(8 * ecc->size), 8);\r\necc->priv = nand_bch_init(mtd, ecc->size, ecc->bytes,\r\n&ecc->layout);\r\nif (!ecc->priv) {\r\npr_warn("BCH ECC initialization failed!\n");\r\nBUG();\r\n}\r\nbreak;\r\ncase NAND_ECC_NONE:\r\npr_warn("NAND_ECC_NONE selected by board driver. This is not recommended!\n");\r\necc->read_page = nand_read_page_raw;\r\necc->write_page = nand_write_page_raw;\r\necc->read_oob = nand_read_oob_std;\r\necc->read_page_raw = nand_read_page_raw;\r\necc->write_page_raw = nand_write_page_raw;\r\necc->write_oob = nand_write_oob_std;\r\necc->size = mtd->writesize;\r\necc->bytes = 0;\r\necc->strength = 0;\r\nbreak;\r\ndefault:\r\npr_warn("Invalid NAND_ECC_MODE %d\n", ecc->mode);\r\nBUG();\r\n}\r\nif (!ecc->read_oob_raw)\r\necc->read_oob_raw = ecc->read_oob;\r\nif (!ecc->write_oob_raw)\r\necc->write_oob_raw = ecc->write_oob;\r\necc->layout->oobavail = 0;\r\nfor (i = 0; ecc->layout->oobfree[i].length\r\n&& i < ARRAY_SIZE(ecc->layout->oobfree); i++)\r\necc->layout->oobavail += ecc->layout->oobfree[i].length;\r\nmtd->oobavail = ecc->layout->oobavail;\r\nif (!nand_ecc_strength_good(mtd))\r\npr_warn("WARNING: %s: the ECC used on your system is too weak compared to the one required by the NAND chip\n",\r\nmtd->name);\r\necc->steps = mtd->writesize / ecc->size;\r\nif (ecc->steps * ecc->size != mtd->writesize) {\r\npr_warn("Invalid ECC parameters\n");\r\nBUG();\r\n}\r\necc->total = ecc->steps * ecc->bytes;\r\nif (!(chip->options & NAND_NO_SUBPAGE_WRITE) && nand_is_slc(chip)) {\r\nswitch (ecc->steps) {\r\ncase 2:\r\nmtd->subpage_sft = 1;\r\nbreak;\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\nmtd->subpage_sft = 2;\r\nbreak;\r\n}\r\n}\r\nchip->subpagesize = mtd->writesize >> mtd->subpage_sft;\r\nchip->state = FL_READY;\r\nchip->pagebuf = -1;\r\nswitch (ecc->mode) {\r\ncase NAND_ECC_SOFT:\r\ncase NAND_ECC_SOFT_BCH:\r\nif (chip->page_shift > 9)\r\nchip->options |= NAND_SUBPAGE_READ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmtd->type = nand_is_slc(chip) ? MTD_NANDFLASH : MTD_MLCNANDFLASH;\r\nmtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :\r\nMTD_CAP_NANDFLASH;\r\nmtd->_erase = nand_erase;\r\nmtd->_point = NULL;\r\nmtd->_unpoint = NULL;\r\nmtd->_read = nand_read;\r\nmtd->_write = nand_write;\r\nmtd->_panic_write = panic_nand_write;\r\nmtd->_read_oob = nand_read_oob;\r\nmtd->_write_oob = nand_write_oob;\r\nmtd->_sync = nand_sync;\r\nmtd->_lock = NULL;\r\nmtd->_unlock = NULL;\r\nmtd->_suspend = nand_suspend;\r\nmtd->_resume = nand_resume;\r\nmtd->_reboot = nand_shutdown;\r\nmtd->_block_isreserved = nand_block_isreserved;\r\nmtd->_block_isbad = nand_block_isbad;\r\nmtd->_block_markbad = nand_block_markbad;\r\nmtd->writebufsize = mtd->writesize;\r\nmtd->ecclayout = ecc->layout;\r\nmtd->ecc_strength = ecc->strength;\r\nmtd->ecc_step_size = ecc->size;\r\nif (!mtd->bitflip_threshold)\r\nmtd->bitflip_threshold = DIV_ROUND_UP(mtd->ecc_strength * 3, 4);\r\nif (chip->options & NAND_SKIP_BBTSCAN)\r\nreturn 0;\r\nreturn chip->scan_bbt(mtd);\r\n}\r\nint nand_scan(struct mtd_info *mtd, int maxchips)\r\n{\r\nint ret;\r\nif (!mtd->owner && caller_is_module()) {\r\npr_crit("%s called with NULL mtd->owner!\n", __func__);\r\nBUG();\r\n}\r\nret = nand_scan_ident(mtd, maxchips, NULL);\r\nif (!ret)\r\nret = nand_scan_tail(mtd);\r\nreturn ret;\r\n}\r\nvoid nand_release(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->ecc.mode == NAND_ECC_SOFT_BCH)\r\nnand_bch_free((struct nand_bch_control *)chip->ecc.priv);\r\nmtd_device_unregister(mtd);\r\nkfree(chip->bbt);\r\nif (!(chip->options & NAND_OWN_BUFFERS))\r\nkfree(chip->buffers);\r\nif (chip->badblock_pattern && chip->badblock_pattern->options\r\n& NAND_BBT_DYNAMICSTRUCT)\r\nkfree(chip->badblock_pattern);\r\n}\r\nstatic int __init nand_base_init(void)\r\n{\r\nled_trigger_register_simple("nand-disk", &nand_led_trigger);\r\nreturn 0;\r\n}\r\nstatic void __exit nand_base_exit(void)\r\n{\r\nled_trigger_unregister_simple(nand_led_trigger);\r\n}
