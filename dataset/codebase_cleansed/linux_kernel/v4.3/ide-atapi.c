static inline int dev_is_idecd(ide_drive_t *drive)\r\n{\r\nreturn drive->media == ide_cdrom || drive->media == ide_optical;\r\n}\r\nint ide_check_atapi_device(ide_drive_t *drive, const char *s)\r\n{\r\nu16 *id = drive->id;\r\nu8 gcw[2], protocol, device_type, removable, drq_type, packet_size;\r\n*((u16 *)&gcw) = id[ATA_ID_CONFIG];\r\nprotocol = (gcw[1] & 0xC0) >> 6;\r\ndevice_type = gcw[1] & 0x1F;\r\nremovable = (gcw[0] & 0x80) >> 7;\r\ndrq_type = (gcw[0] & 0x60) >> 5;\r\npacket_size = gcw[0] & 0x03;\r\n#ifdef CONFIG_PPC\r\nif (drive->media == ide_floppy && device_type == 5 &&\r\n!strstr((char *)&id[ATA_ID_PROD], "CD-ROM") &&\r\nstrstr((char *)&id[ATA_ID_PROD], "ZIP"))\r\ndevice_type = 0;\r\n#endif\r\nif (protocol != 2)\r\nprintk(KERN_ERR "%s: %s: protocol (0x%02x) is not ATAPI\n",\r\ns, drive->name, protocol);\r\nelse if ((drive->media == ide_floppy && device_type != 0) ||\r\n(drive->media == ide_tape && device_type != 1))\r\nprintk(KERN_ERR "%s: %s: invalid device type (0x%02x)\n",\r\ns, drive->name, device_type);\r\nelse if (removable == 0)\r\nprintk(KERN_ERR "%s: %s: the removable flag is not set\n",\r\ns, drive->name);\r\nelse if (drive->media == ide_floppy && drq_type == 3)\r\nprintk(KERN_ERR "%s: %s: sorry, DRQ type (0x%02x) not "\r\n"supported\n", s, drive->name, drq_type);\r\nelse if (packet_size != 0)\r\nprintk(KERN_ERR "%s: %s: packet size (0x%02x) is not 12 "\r\n"bytes\n", s, drive->name, packet_size);\r\nelse\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid ide_init_pc(struct ide_atapi_pc *pc)\r\n{\r\nmemset(pc, 0, sizeof(*pc));\r\n}\r\nint ide_queue_pc_tail(ide_drive_t *drive, struct gendisk *disk,\r\nstruct ide_atapi_pc *pc, void *buf, unsigned int bufflen)\r\n{\r\nstruct request *rq;\r\nint error;\r\nrq = blk_get_request(drive->queue, READ, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nrq->special = (char *)pc;\r\nif (buf && bufflen) {\r\nerror = blk_rq_map_kern(drive->queue, rq, buf, bufflen,\r\nGFP_NOIO);\r\nif (error)\r\ngoto put_req;\r\n}\r\nmemcpy(rq->cmd, pc->c, 12);\r\nif (drive->media == ide_tape)\r\nrq->cmd[13] = REQ_IDETAPE_PC1;\r\nerror = blk_execute_rq(drive->queue, disk, rq, 0);\r\nput_req:\r\nblk_put_request(rq);\r\nreturn error;\r\n}\r\nint ide_do_test_unit_ready(ide_drive_t *drive, struct gendisk *disk)\r\n{\r\nstruct ide_atapi_pc pc;\r\nide_init_pc(&pc);\r\npc.c[0] = TEST_UNIT_READY;\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\n}\r\nint ide_do_start_stop(ide_drive_t *drive, struct gendisk *disk, int start)\r\n{\r\nstruct ide_atapi_pc pc;\r\nide_init_pc(&pc);\r\npc.c[0] = START_STOP;\r\npc.c[4] = start;\r\nif (drive->media == ide_tape)\r\npc.flags |= PC_FLAG_WAIT_FOR_DSC;\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\n}\r\nint ide_set_media_lock(ide_drive_t *drive, struct gendisk *disk, int on)\r\n{\r\nstruct ide_atapi_pc pc;\r\nif ((drive->dev_flags & IDE_DFLAG_DOORLOCKING) == 0)\r\nreturn 0;\r\nide_init_pc(&pc);\r\npc.c[0] = ALLOW_MEDIUM_REMOVAL;\r\npc.c[4] = on;\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\n}\r\nvoid ide_create_request_sense_cmd(ide_drive_t *drive, struct ide_atapi_pc *pc)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = REQUEST_SENSE;\r\nif (drive->media == ide_floppy) {\r\npc->c[4] = 255;\r\npc->req_xfer = 18;\r\n} else {\r\npc->c[4] = 20;\r\npc->req_xfer = 20;\r\n}\r\n}\r\nvoid ide_prep_sense(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct request_sense *sense = &drive->sense_data;\r\nstruct request *sense_rq = &drive->sense_rq;\r\nunsigned int cmd_len, sense_len;\r\nint err;\r\nswitch (drive->media) {\r\ncase ide_floppy:\r\ncmd_len = 255;\r\nsense_len = 18;\r\nbreak;\r\ncase ide_tape:\r\ncmd_len = 20;\r\nsense_len = 20;\r\nbreak;\r\ndefault:\r\ncmd_len = 18;\r\nsense_len = 18;\r\n}\r\nBUG_ON(sense_len > sizeof(*sense));\r\nif (rq->cmd_type == REQ_TYPE_ATA_SENSE || drive->sense_rq_armed)\r\nreturn;\r\nmemset(sense, 0, sizeof(*sense));\r\nblk_rq_init(rq->q, sense_rq);\r\nerr = blk_rq_map_kern(drive->queue, sense_rq, sense, sense_len,\r\nGFP_NOIO);\r\nif (unlikely(err)) {\r\nif (printk_ratelimit())\r\nprintk(KERN_WARNING PFX "%s: failed to map sense "\r\n"buffer\n", drive->name);\r\nreturn;\r\n}\r\nsense_rq->rq_disk = rq->rq_disk;\r\nsense_rq->cmd[0] = GPCMD_REQUEST_SENSE;\r\nsense_rq->cmd[4] = cmd_len;\r\nsense_rq->cmd_type = REQ_TYPE_ATA_SENSE;\r\nsense_rq->cmd_flags |= REQ_PREEMPT;\r\nif (drive->media == ide_tape)\r\nsense_rq->cmd[13] = REQ_IDETAPE_PC1;\r\ndrive->sense_rq_armed = true;\r\n}\r\nint ide_queue_sense_rq(ide_drive_t *drive, void *special)\r\n{\r\nif (!drive->sense_rq_armed) {\r\nprintk(KERN_WARNING PFX "%s: error queuing a sense request\n",\r\ndrive->name);\r\nreturn -ENOMEM;\r\n}\r\ndrive->sense_rq.special = special;\r\ndrive->sense_rq_armed = false;\r\ndrive->hwif->rq = NULL;\r\nelv_add_request(drive->queue, &drive->sense_rq, ELEVATOR_INSERT_FRONT);\r\nreturn 0;\r\n}\r\nvoid ide_retry_pc(ide_drive_t *drive)\r\n{\r\nstruct request *failed_rq = drive->hwif->rq;\r\nstruct request *sense_rq = &drive->sense_rq;\r\nstruct ide_atapi_pc *pc = &drive->request_sense_pc;\r\n(void)ide_read_error(drive);\r\nide_init_pc(pc);\r\nmemcpy(pc->c, sense_rq->cmd, 12);\r\nif (drive->media == ide_tape)\r\ndrive->atapi_flags |= IDE_AFLAG_IGNORE_DSC;\r\ndrive->hwif->rq = NULL;\r\nide_requeue_and_plug(drive, failed_rq);\r\nif (ide_queue_sense_rq(drive, pc)) {\r\nblk_start_request(failed_rq);\r\nide_complete_rq(drive, -EIO, blk_rq_bytes(failed_rq));\r\n}\r\n}\r\nint ide_cd_expiry(ide_drive_t *drive)\r\n{\r\nstruct request *rq = drive->hwif->rq;\r\nunsigned long wait = 0;\r\ndebug_log("%s: rq->cmd[0]: 0x%x\n", __func__, rq->cmd[0]);\r\nswitch (rq->cmd[0]) {\r\ncase GPCMD_BLANK:\r\ncase GPCMD_FORMAT_UNIT:\r\ncase GPCMD_RESERVE_RZONE_TRACK:\r\ncase GPCMD_CLOSE_TRACK:\r\ncase GPCMD_FLUSH_CACHE:\r\nwait = ATAPI_WAIT_PC;\r\nbreak;\r\ndefault:\r\nif (!(rq->cmd_flags & REQ_QUIET))\r\nprintk(KERN_INFO PFX "cmd 0x%x timed out\n",\r\nrq->cmd[0]);\r\nwait = 0;\r\nbreak;\r\n}\r\nreturn wait;\r\n}\r\nint ide_cd_get_xferlen(struct request *rq)\r\n{\r\nswitch (rq->cmd_type) {\r\ncase REQ_TYPE_FS:\r\nreturn 32768;\r\ncase REQ_TYPE_ATA_SENSE:\r\ncase REQ_TYPE_BLOCK_PC:\r\ncase REQ_TYPE_ATA_PC:\r\nreturn blk_rq_bytes(rq);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid ide_read_bcount_and_ireason(ide_drive_t *drive, u16 *bcount, u8 *ireason)\r\n{\r\nstruct ide_taskfile tf;\r\ndrive->hwif->tp_ops->tf_read(drive, &tf, IDE_VALID_NSECT |\r\nIDE_VALID_LBAM | IDE_VALID_LBAH);\r\n*bcount = (tf.lbah << 8) | tf.lbam;\r\n*ireason = tf.nsect & 3;\r\n}\r\nint ide_check_ireason(ide_drive_t *drive, struct request *rq, int len,\r\nint ireason, int rw)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\ndebug_log("ireason: 0x%x, rw: 0x%x\n", ireason, rw);\r\nif (ireason == (!rw << 1))\r\nreturn 0;\r\nelse if (ireason == (rw << 1)) {\r\nprintk(KERN_ERR PFX "%s: %s: wrong transfer direction!\n",\r\ndrive->name, __func__);\r\nif (dev_is_idecd(drive))\r\nide_pad_transfer(drive, rw, len);\r\n} else if (!rw && ireason == ATAPI_COD) {\r\nif (dev_is_idecd(drive)) {\r\n(void)hwif->tp_ops->read_status(hwif);\r\nreturn 0;\r\n}\r\n} else {\r\nif (ireason & ATAPI_COD)\r\nprintk(KERN_ERR PFX "%s: CoD != 0 in %s\n", drive->name,\r\n__func__);\r\nprintk(KERN_ERR PFX "%s: %s: bad interrupt reason 0x%02x\n",\r\ndrive->name, __func__, ireason);\r\n}\r\nif (dev_is_idecd(drive) && rq->cmd_type == REQ_TYPE_ATA_PC)\r\nrq->cmd_flags |= REQ_FAILED;\r\nreturn 1;\r\n}\r\nstatic ide_startstop_t ide_pc_intr(ide_drive_t *drive)\r\n{\r\nstruct ide_atapi_pc *pc = drive->pc;\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nstruct request *rq = hwif->rq;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nunsigned int timeout, done;\r\nu16 bcount;\r\nu8 stat, ireason, dsc = 0;\r\nu8 write = !!(pc->flags & PC_FLAG_WRITING);\r\ndebug_log("Enter %s - interrupt handler\n", __func__);\r\ntimeout = (drive->media == ide_floppy) ? WAIT_FLOPPY_CMD\r\n: WAIT_TAPE_CMD;\r\nstat = tp_ops->read_status(hwif);\r\nif (pc->flags & PC_FLAG_DMA_IN_PROGRESS) {\r\nint rc;\r\ndrive->waiting_for_dma = 0;\r\nrc = hwif->dma_ops->dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\nif (rc || (drive->media == ide_tape && (stat & ATA_ERR))) {\r\nif (drive->media == ide_floppy)\r\nprintk(KERN_ERR PFX "%s: DMA %s error\n",\r\ndrive->name, rq_data_dir(pc->rq)\r\n? "write" : "read");\r\npc->flags |= PC_FLAG_DMA_ERROR;\r\n} else\r\nrq->resid_len = 0;\r\ndebug_log("%s: DMA finished\n", drive->name);\r\n}\r\nif ((stat & ATA_DRQ) == 0) {\r\nint uptodate, error;\r\ndebug_log("Packet command completed, %d bytes transferred\n",\r\nblk_rq_bytes(rq));\r\npc->flags &= ~PC_FLAG_DMA_IN_PROGRESS;\r\nlocal_irq_enable_in_hardirq();\r\nif (drive->media == ide_tape &&\r\n(stat & ATA_ERR) && rq->cmd[0] == REQUEST_SENSE)\r\nstat &= ~ATA_ERR;\r\nif ((stat & ATA_ERR) || (pc->flags & PC_FLAG_DMA_ERROR)) {\r\ndebug_log("%s: I/O error\n", drive->name);\r\nif (drive->media != ide_tape)\r\npc->rq->errors++;\r\nif (rq->cmd[0] == REQUEST_SENSE) {\r\nprintk(KERN_ERR PFX "%s: I/O error in request "\r\n"sense command\n", drive->name);\r\nreturn ide_do_reset(drive);\r\n}\r\ndebug_log("[cmd %x]: check condition\n", rq->cmd[0]);\r\nide_retry_pc(drive);\r\nreturn ide_stopped;\r\n}\r\npc->error = 0;\r\nif ((pc->flags & PC_FLAG_WAIT_FOR_DSC) && (stat & ATA_DSC) == 0)\r\ndsc = 1;\r\ndone = blk_rq_bytes(rq);\r\nuptodate = drive->pc_callback(drive, dsc);\r\nif (uptodate == 0)\r\ndrive->failed_pc = NULL;\r\nif (rq->cmd_type == REQ_TYPE_DRV_PRIV) {\r\nrq->errors = 0;\r\nerror = 0;\r\n} else {\r\nif (rq->cmd_type != REQ_TYPE_FS && uptodate <= 0) {\r\nif (rq->errors == 0)\r\nrq->errors = -EIO;\r\n}\r\nerror = uptodate ? 0 : -EIO;\r\n}\r\nide_complete_rq(drive, error, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}\r\nif (pc->flags & PC_FLAG_DMA_IN_PROGRESS) {\r\npc->flags &= ~PC_FLAG_DMA_IN_PROGRESS;\r\nprintk(KERN_ERR PFX "%s: The device wants to issue more "\r\n"interrupts in DMA mode\n", drive->name);\r\nide_dma_off(drive);\r\nreturn ide_do_reset(drive);\r\n}\r\nide_read_bcount_and_ireason(drive, &bcount, &ireason);\r\nif (ide_check_ireason(drive, rq, bcount, ireason, write))\r\nreturn ide_do_reset(drive);\r\ndone = min_t(unsigned int, bcount, cmd->nleft);\r\nide_pio_bytes(drive, cmd, write, done);\r\nrq->resid_len -= done;\r\nbcount -= done;\r\nif (bcount)\r\nide_pad_transfer(drive, write, bcount);\r\ndebug_log("[cmd %x] transferred %d bytes, padded %d bytes, resid: %u\n",\r\nrq->cmd[0], done, bcount, rq->resid_len);\r\nide_set_handler(drive, ide_pc_intr, timeout);\r\nreturn ide_started;\r\n}\r\nstatic void ide_init_packet_cmd(struct ide_cmd *cmd, u8 valid_tf,\r\nu16 bcount, u8 dma)\r\n{\r\ncmd->protocol = dma ? ATAPI_PROT_DMA : ATAPI_PROT_PIO;\r\ncmd->valid.out.tf = IDE_VALID_LBAH | IDE_VALID_LBAM |\r\nIDE_VALID_FEATURE | valid_tf;\r\ncmd->tf.command = ATA_CMD_PACKET;\r\ncmd->tf.feature = dma;\r\ncmd->tf.lbam = bcount & 0xff;\r\ncmd->tf.lbah = (bcount >> 8) & 0xff;\r\n}\r\nstatic u8 ide_read_ireason(ide_drive_t *drive)\r\n{\r\nstruct ide_taskfile tf;\r\ndrive->hwif->tp_ops->tf_read(drive, &tf, IDE_VALID_NSECT);\r\nreturn tf.nsect & 3;\r\n}\r\nstatic u8 ide_wait_ireason(ide_drive_t *drive, u8 ireason)\r\n{\r\nint retries = 100;\r\nwhile (retries-- && ((ireason & ATAPI_COD) == 0 ||\r\n(ireason & ATAPI_IO))) {\r\nprintk(KERN_ERR PFX "%s: (IO,CoD != (0,1) while issuing "\r\n"a packet command, retrying\n", drive->name);\r\nudelay(100);\r\nireason = ide_read_ireason(drive);\r\nif (retries == 0) {\r\nprintk(KERN_ERR PFX "%s: (IO,CoD != (0,1) while issuing"\r\n" a packet command, ignoring\n",\r\ndrive->name);\r\nireason |= ATAPI_COD;\r\nireason &= ~ATAPI_IO;\r\n}\r\n}\r\nreturn ireason;\r\n}\r\nstatic int ide_delayed_transfer_pc(ide_drive_t *drive)\r\n{\r\ndrive->hwif->tp_ops->output_data(drive, NULL, drive->pc->c, 12);\r\nreturn WAIT_FLOPPY_CMD;\r\n}\r\nstatic ide_startstop_t ide_transfer_pc(ide_drive_t *drive)\r\n{\r\nstruct ide_atapi_pc *uninitialized_var(pc);\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct request *rq = hwif->rq;\r\nide_expiry_t *expiry;\r\nunsigned int timeout;\r\nint cmd_len;\r\nide_startstop_t startstop;\r\nu8 ireason;\r\nif (ide_wait_stat(&startstop, drive, ATA_DRQ, ATA_BUSY, WAIT_READY)) {\r\nprintk(KERN_ERR PFX "%s: Strange, packet command initiated yet "\r\n"DRQ isn't asserted\n", drive->name);\r\nreturn startstop;\r\n}\r\nif (drive->atapi_flags & IDE_AFLAG_DRQ_INTERRUPT) {\r\nif (drive->dma)\r\ndrive->waiting_for_dma = 1;\r\n}\r\nif (dev_is_idecd(drive)) {\r\ncmd_len = COMMAND_SIZE(rq->cmd[0]);\r\nif (cmd_len < ATAPI_MIN_CDB_BYTES)\r\ncmd_len = ATAPI_MIN_CDB_BYTES;\r\ntimeout = rq->timeout;\r\nexpiry = ide_cd_expiry;\r\n} else {\r\npc = drive->pc;\r\ncmd_len = ATAPI_MIN_CDB_BYTES;\r\nif (drive->atapi_flags & IDE_AFLAG_ZIP_DRIVE) {\r\ntimeout = drive->pc_delay;\r\nexpiry = &ide_delayed_transfer_pc;\r\n} else {\r\ntimeout = (drive->media == ide_floppy) ? WAIT_FLOPPY_CMD\r\n: WAIT_TAPE_CMD;\r\nexpiry = NULL;\r\n}\r\nireason = ide_read_ireason(drive);\r\nif (drive->media == ide_tape)\r\nireason = ide_wait_ireason(drive, ireason);\r\nif ((ireason & ATAPI_COD) == 0 || (ireason & ATAPI_IO)) {\r\nprintk(KERN_ERR PFX "%s: (IO,CoD) != (0,1) while "\r\n"issuing a packet command\n", drive->name);\r\nreturn ide_do_reset(drive);\r\n}\r\n}\r\nhwif->expiry = expiry;\r\nide_set_handler(drive,\r\n(dev_is_idecd(drive) ? drive->irq_handler\r\n: ide_pc_intr),\r\ntimeout);\r\nif ((drive->atapi_flags & IDE_AFLAG_ZIP_DRIVE) == 0)\r\nhwif->tp_ops->output_data(drive, NULL, rq->cmd, cmd_len);\r\nif (dev_is_idecd(drive)) {\r\nif (drive->dma)\r\nhwif->dma_ops->dma_start(drive);\r\n} else {\r\nif (pc->flags & PC_FLAG_DMA_OK) {\r\npc->flags |= PC_FLAG_DMA_IN_PROGRESS;\r\nhwif->dma_ops->dma_start(drive);\r\n}\r\n}\r\nreturn ide_started;\r\n}\r\nide_startstop_t ide_issue_pc(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nstruct ide_atapi_pc *pc;\r\nide_hwif_t *hwif = drive->hwif;\r\nide_expiry_t *expiry = NULL;\r\nstruct request *rq = hwif->rq;\r\nunsigned int timeout, bytes;\r\nu16 bcount;\r\nu8 valid_tf;\r\nu8 drq_int = !!(drive->atapi_flags & IDE_AFLAG_DRQ_INTERRUPT);\r\nif (dev_is_idecd(drive)) {\r\nvalid_tf = IDE_VALID_NSECT | IDE_VALID_LBAL;\r\nbcount = ide_cd_get_xferlen(rq);\r\nexpiry = ide_cd_expiry;\r\ntimeout = ATAPI_WAIT_PC;\r\nif (drive->dma)\r\ndrive->dma = !ide_dma_prepare(drive, cmd);\r\n} else {\r\npc = drive->pc;\r\nvalid_tf = IDE_VALID_DEVICE;\r\nbytes = blk_rq_bytes(rq);\r\nbcount = ((drive->media == ide_tape) ? bytes\r\n: min_t(unsigned int,\r\nbytes, 63 * 1024));\r\nrq->resid_len = bcount;\r\nif (pc->flags & PC_FLAG_DMA_ERROR) {\r\npc->flags &= ~PC_FLAG_DMA_ERROR;\r\nide_dma_off(drive);\r\n}\r\nif (pc->flags & PC_FLAG_DMA_OK)\r\ndrive->dma = !ide_dma_prepare(drive, cmd);\r\nif (!drive->dma)\r\npc->flags &= ~PC_FLAG_DMA_OK;\r\ntimeout = (drive->media == ide_floppy) ? WAIT_FLOPPY_CMD\r\n: WAIT_TAPE_CMD;\r\n}\r\nide_init_packet_cmd(cmd, valid_tf, bcount, drive->dma);\r\n(void)do_rw_taskfile(drive, cmd);\r\nif (drq_int) {\r\nif (drive->dma)\r\ndrive->waiting_for_dma = 0;\r\nhwif->expiry = expiry;\r\n}\r\nide_execute_command(drive, cmd, ide_transfer_pc, timeout);\r\nreturn drq_int ? ide_started : ide_transfer_pc(drive);\r\n}
