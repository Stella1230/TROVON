static int bfin_can_set_bittiming(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu16 clk, timing;\r\nclk = bt->brp - 1;\r\ntiming = ((bt->sjw - 1) << 8) | (bt->prop_seg + bt->phase_seg1 - 1) |\r\n((bt->phase_seg2 - 1) << 4);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\ntiming |= SAM;\r\nwritew(clk, &reg->clock);\r\nwritew(timing, &reg->timing);\r\nnetdev_info(dev, "setting CLOCK=0x%04x TIMING=0x%04x\n", clk, timing);\r\nreturn 0;\r\n}\r\nstatic void bfin_can_set_reset_mode(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nint timeout = BFIN_CAN_TIMEOUT;\r\nint i;\r\nwritew(0, &reg->mbim1);\r\nwritew(0, &reg->mbim2);\r\nwritew(0, &reg->gim);\r\nwritew(SRS | CCR, &reg->control);\r\nwritew(CCR, &reg->control);\r\nwhile (!(readw(&reg->control) & CCA)) {\r\nudelay(10);\r\nif (--timeout == 0) {\r\nnetdev_err(dev, "fail to enter configuration mode\n");\r\nBUG();\r\n}\r\n}\r\nwritew(0, &reg->mc1);\r\nwritew(0, &reg->mc2);\r\nwritew(0xFFFF, &reg->md1);\r\nwritew(0, &reg->md2);\r\nfor (i = 0; i < 2; i++) {\r\nwritew(0, &reg->chl[RECEIVE_STD_CHL + i].id0);\r\nwritew(AME, &reg->chl[RECEIVE_STD_CHL + i].id1);\r\nwritew(0, &reg->chl[RECEIVE_STD_CHL + i].dlc);\r\nwritew(0x1FFF, &reg->msk[RECEIVE_STD_CHL + i].amh);\r\nwritew(0xFFFF, &reg->msk[RECEIVE_STD_CHL + i].aml);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nwritew(0, &reg->chl[RECEIVE_EXT_CHL + i].id0);\r\nwritew(AME | IDE, &reg->chl[RECEIVE_EXT_CHL + i].id1);\r\nwritew(0, &reg->chl[RECEIVE_EXT_CHL + i].dlc);\r\nwritew(0x1FFF, &reg->msk[RECEIVE_EXT_CHL + i].amh);\r\nwritew(0xFFFF, &reg->msk[RECEIVE_EXT_CHL + i].aml);\r\n}\r\nwritew(BIT(TRANSMIT_CHL - 16), &reg->mc2);\r\nwritew(BIT(RECEIVE_STD_CHL) + BIT(RECEIVE_EXT_CHL), &reg->mc1);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic void bfin_can_set_normal_mode(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nint timeout = BFIN_CAN_TIMEOUT;\r\nwritew(readw(&reg->control) & ~CCR, &reg->control);\r\nwhile (readw(&reg->status) & CCA) {\r\nudelay(10);\r\nif (--timeout == 0) {\r\nnetdev_err(dev, "fail to leave configuration mode\n");\r\nBUG();\r\n}\r\n}\r\nwritew(0xFFFF, &reg->mbtif1);\r\nwritew(0xFFFF, &reg->mbtif2);\r\nwritew(0xFFFF, &reg->mbrif1);\r\nwritew(0xFFFF, &reg->mbrif2);\r\nwritew(0x7FF, &reg->gis);\r\nwritew(BIT(RECEIVE_STD_CHL) + BIT(RECEIVE_EXT_CHL), &reg->mbim1);\r\nwritew(BIT(TRANSMIT_CHL - 16), &reg->mbim2);\r\nwritew(EPIM | BOIM | RMLIM, &reg->gim);\r\n}\r\nstatic void bfin_can_start(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nif (priv->can.state != CAN_STATE_STOPPED)\r\nbfin_can_set_reset_mode(dev);\r\nbfin_can_set_normal_mode(dev);\r\n}\r\nstatic int bfin_can_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nbfin_can_start(dev);\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nu16 cec = readw(&reg->cec);\r\nbec->txerr = cec >> 8;\r\nbec->rxerr = cec;\r\nreturn 0;\r\n}\r\nstatic int bfin_can_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu8 dlc = cf->can_dlc;\r\ncanid_t id = cf->can_id;\r\nu8 *data = cf->data;\r\nu16 val;\r\nint i;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nif (id & CAN_EFF_FLAG) {\r\nwritew(id, &reg->chl[TRANSMIT_CHL].id0);\r\nval = ((id & 0x1FFF0000) >> 16) | IDE;\r\n} else\r\nval = (id << 2);\r\nif (id & CAN_RTR_FLAG)\r\nval |= RTR;\r\nwritew(val | AME, &reg->chl[TRANSMIT_CHL].id1);\r\nfor (i = 0; i < 8; i += 2) {\r\nval = ((7 - i) < dlc ? (data[7 - i]) : 0) +\r\n((6 - i) < dlc ? (data[6 - i] << 8) : 0);\r\nwritew(val, &reg->chl[TRANSMIT_CHL].data[i]);\r\n}\r\nwritew(dlc, &reg->chl[TRANSMIT_CHL].dlc);\r\ncan_put_echo_skb(skb, dev, 0);\r\nwritew(BIT(TRANSMIT_CHL - 16), &reg->trs2);\r\nreturn 0;\r\n}\r\nstatic void bfin_can_rx(struct net_device *dev, u16 isrc)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nint obj;\r\nint i;\r\nu16 val;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (skb == NULL)\r\nreturn;\r\nif (isrc & BIT(RECEIVE_EXT_CHL)) {\r\ncf->can_id = ((readw(&reg->chl[RECEIVE_EXT_CHL].id1)\r\n& 0x1FFF) << 16)\r\n+ readw(&reg->chl[RECEIVE_EXT_CHL].id0);\r\ncf->can_id |= CAN_EFF_FLAG;\r\nobj = RECEIVE_EXT_CHL;\r\n} else {\r\ncf->can_id = (readw(&reg->chl[RECEIVE_STD_CHL].id1)\r\n& 0x1ffc) >> 2;\r\nobj = RECEIVE_STD_CHL;\r\n}\r\nif (readw(&reg->chl[obj].id1) & RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc(readw(&reg->chl[obj].dlc) & 0xF);\r\nfor (i = 0; i < 8; i += 2) {\r\nval = readw(&reg->chl[obj].data[i]);\r\ncf->data[7 - i] = (7 - i) < cf->can_dlc ? val : 0;\r\ncf->data[6 - i] = (6 - i) < cf->can_dlc ? (val >> 8) : 0;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic int bfin_can_err(struct net_device *dev, u16 isrc, u16 status)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nenum can_state state = priv->can.state;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (isrc & RMLIS) {\r\nnetdev_dbg(dev, "data overrun interrupt\n");\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\n}\r\nif (isrc & BOIS) {\r\nnetdev_dbg(dev, "bus-off mode interrupt\n");\r\nstate = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(dev);\r\n}\r\nif (isrc & EPIS) {\r\nnetdev_dbg(dev, "error passive interrupt\n");\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\n}\r\nif ((isrc & EWTIS) || (isrc & EWRIS)) {\r\nnetdev_dbg(dev, "Error Warning Transmit/Receive Interrupt\n");\r\nstate = CAN_STATE_ERROR_WARNING;\r\n}\r\nif (state != priv->can.state && (state == CAN_STATE_ERROR_WARNING ||\r\nstate == CAN_STATE_ERROR_PASSIVE)) {\r\nu16 cec = readw(&reg->cec);\r\nu8 rxerr = cec;\r\nu8 txerr = cec >> 8;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (state == CAN_STATE_ERROR_WARNING) {\r\npriv->can.can_stats.error_warning++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n} else {\r\npriv->can.can_stats.error_passive++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\n}\r\nif (status) {\r\npriv->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nif (status & BEF)\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nelse if (status & FER)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nelse if (status & SER)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nelse\r\ncf->data[2] |= CAN_ERR_PROT_UNSPEC;\r\n}\r\npriv->can.state = state;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bfin_can_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nstruct net_device_stats *stats = &dev->stats;\r\nu16 status, isrc;\r\nif ((irq == priv->tx_irq) && readw(&reg->mbtif2)) {\r\nwritew(0xFFFF, &reg->mbtif2);\r\nstats->tx_packets++;\r\nstats->tx_bytes += readw(&reg->chl[TRANSMIT_CHL].dlc);\r\ncan_get_echo_skb(dev, 0);\r\nnetif_wake_queue(dev);\r\n} else if ((irq == priv->rx_irq) && readw(&reg->mbrif1)) {\r\nisrc = readw(&reg->mbrif1);\r\nwritew(0xFFFF, &reg->mbrif1);\r\nbfin_can_rx(dev, isrc);\r\n} else if ((irq == priv->err_irq) && readw(&reg->gis)) {\r\nisrc = readw(&reg->gis);\r\nstatus = readw(&reg->esr);\r\nwritew(0x7FF, &reg->gis);\r\nbfin_can_err(dev, isrc, status);\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_can_open(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nbfin_can_set_reset_mode(dev);\r\nerr = open_candev(dev);\r\nif (err)\r\ngoto exit_open;\r\nerr = request_irq(priv->rx_irq, &bfin_can_interrupt, 0,\r\n"bfin-can-rx", dev);\r\nif (err)\r\ngoto exit_rx_irq;\r\nerr = request_irq(priv->tx_irq, &bfin_can_interrupt, 0,\r\n"bfin-can-tx", dev);\r\nif (err)\r\ngoto exit_tx_irq;\r\nerr = request_irq(priv->err_irq, &bfin_can_interrupt, 0,\r\n"bfin-can-err", dev);\r\nif (err)\r\ngoto exit_err_irq;\r\nbfin_can_start(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_err_irq:\r\nfree_irq(priv->tx_irq, dev);\r\nexit_tx_irq:\r\nfree_irq(priv->rx_irq, dev);\r\nexit_rx_irq:\r\nclose_candev(dev);\r\nexit_open:\r\nreturn err;\r\n}\r\nstatic int bfin_can_close(struct net_device *dev)\r\n{\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nbfin_can_set_reset_mode(dev);\r\nclose_candev(dev);\r\nfree_irq(priv->rx_irq, dev);\r\nfree_irq(priv->tx_irq, dev);\r\nfree_irq(priv->err_irq, dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device *alloc_bfin_candev(void)\r\n{\r\nstruct net_device *dev;\r\nstruct bfin_can_priv *priv;\r\ndev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &bfin_can_bittiming_const;\r\npriv->can.do_set_bittiming = bfin_can_set_bittiming;\r\npriv->can.do_set_mode = bfin_can_set_mode;\r\npriv->can.do_get_berr_counter = bfin_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nreturn dev;\r\n}\r\nstatic int bfin_can_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct net_device *dev;\r\nstruct bfin_can_priv *priv;\r\nstruct resource *res_mem, *rx_irq, *tx_irq, *err_irq;\r\nunsigned short *pdata;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data provided!\n");\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\ntx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nerr_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 2);\r\nif (!res_mem || !rx_irq || !tx_irq || !err_irq) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nerr = peripheral_request_list(pdata, dev_name(&pdev->dev));\r\nif (err)\r\ngoto exit;\r\ndev = alloc_bfin_candev();\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_peri_pin_free;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->membase = devm_ioremap_resource(&pdev->dev, res_mem);\r\nif (IS_ERR(priv->membase)) {\r\nerr = PTR_ERR(priv->membase);\r\ngoto exit_peri_pin_free;\r\n}\r\npriv->rx_irq = rx_irq->start;\r\npriv->tx_irq = tx_irq->start;\r\npriv->err_irq = err_irq->start;\r\npriv->pin_list = pdata;\r\npriv->can.clock.freq = get_sclk();\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &bfin_can_netdev_ops;\r\nbfin_can_set_reset_mode(dev);\r\nerr = register_candev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering failed (err=%d)\n", err);\r\ngoto exit_candev_free;\r\n}\r\ndev_info(&pdev->dev,\r\n"%s device registered"\r\n"(&reg_base=%p, rx_irq=%d, tx_irq=%d, err_irq=%d, sclk=%d)\n",\r\nDRV_NAME, priv->membase, priv->rx_irq,\r\npriv->tx_irq, priv->err_irq, priv->can.clock.freq);\r\nreturn 0;\r\nexit_candev_free:\r\nfree_candev(dev);\r\nexit_peri_pin_free:\r\nperipheral_free_list(pdata);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int bfin_can_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nbfin_can_set_reset_mode(dev);\r\nunregister_candev(dev);\r\nperipheral_free_list(priv->pin_list);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int bfin_can_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nint timeout = BFIN_CAN_TIMEOUT;\r\nif (netif_running(dev)) {\r\nwritew(readw(&reg->control) | SMR, &reg->control);\r\nwhile (!(readw(&reg->intr) & SMACK)) {\r\nudelay(10);\r\nif (--timeout == 0) {\r\nnetdev_err(dev, "fail to enter sleep mode\n");\r\nBUG();\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_can_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct bfin_can_priv *priv = netdev_priv(dev);\r\nstruct bfin_can_regs __iomem *reg = priv->membase;\r\nif (netif_running(dev)) {\r\nwritew(0, &reg->intr);\r\n}\r\nreturn 0;\r\n}
