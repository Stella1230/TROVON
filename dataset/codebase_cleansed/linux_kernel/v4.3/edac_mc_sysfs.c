int edac_mc_get_log_ue(void)\r\n{\r\nreturn edac_mc_log_ue;\r\n}\r\nint edac_mc_get_log_ce(void)\r\n{\r\nreturn edac_mc_log_ce;\r\n}\r\nint edac_mc_get_panic_on_ue(void)\r\n{\r\nreturn edac_mc_panic_on_ue;\r\n}\r\nint edac_mc_get_poll_msec(void)\r\n{\r\nreturn edac_mc_poll_msec;\r\n}\r\nstatic int edac_set_poll_msec(const char *val, struct kernel_param *kp)\r\n{\r\nunsigned long l;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nret = kstrtoul(val, 0, &l);\r\nif (ret)\r\nreturn ret;\r\nif (l < 1000)\r\nreturn -EINVAL;\r\n*((unsigned long *)kp->arg) = l;\r\nedac_mc_reset_delay_period(l);\r\nreturn 0;\r\n}\r\nstatic ssize_t csrow_ue_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%u\n", csrow->ue_count);\r\n}\r\nstatic ssize_t csrow_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%u\n", csrow->ce_count);\r\n}\r\nstatic ssize_t csrow_size_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nint i;\r\nu32 nr_pages = 0;\r\nfor (i = 0; i < csrow->nr_channels; i++)\r\nnr_pages += csrow->channels[i]->dimm->nr_pages;\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(nr_pages));\r\n}\r\nstatic ssize_t csrow_mem_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", mem_types[csrow->channels[0]->dimm->mtype]);\r\n}\r\nstatic ssize_t csrow_dev_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", dev_types[csrow->channels[0]->dimm->dtype]);\r\n}\r\nstatic ssize_t csrow_edac_mode_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", edac_caps[csrow->channels[0]->dimm->edac_mode]);\r\n}\r\nstatic ssize_t channel_dimm_label_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nif (!rank->dimm->label[0])\r\nreturn 0;\r\nreturn snprintf(data, EDAC_MC_LABEL_LEN, "%s\n",\r\nrank->dimm->label);\r\n}\r\nstatic ssize_t channel_dimm_label_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nssize_t max_size = 0;\r\nmax_size = min((ssize_t) count, (ssize_t) EDAC_MC_LABEL_LEN - 1);\r\nstrncpy(rank->dimm->label, data, max_size);\r\nrank->dimm->label[max_size] = '\0';\r\nreturn max_size;\r\n}\r\nstatic ssize_t channel_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nreturn sprintf(data, "%u\n", rank->ce_count);\r\n}\r\nstatic void csrow_attr_release(struct device *dev)\r\n{\r\nstruct csrow_info *csrow = container_of(dev, struct csrow_info, dev);\r\nedac_dbg(1, "Releasing csrow device %s\n", dev_name(dev));\r\nkfree(csrow);\r\n}\r\nstatic umode_t csrow_dev_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct csrow_info *csrow = container_of(dev, struct csrow_info, dev);\r\nif (idx >= csrow->nr_channels)\r\nreturn 0;\r\nif (!csrow->channels[idx]->dimm->nr_pages)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic inline int nr_pages_per_csrow(struct csrow_info *csrow)\r\n{\r\nint chan, nr_pages = 0;\r\nfor (chan = 0; chan < csrow->nr_channels; chan++)\r\nnr_pages += csrow->channels[chan]->dimm->nr_pages;\r\nreturn nr_pages;\r\n}\r\nstatic int edac_create_csrow_object(struct mem_ctl_info *mci,\r\nstruct csrow_info *csrow, int index)\r\n{\r\ncsrow->dev.type = &csrow_attr_type;\r\ncsrow->dev.bus = mci->bus;\r\ncsrow->dev.groups = csrow_dev_groups;\r\ndevice_initialize(&csrow->dev);\r\ncsrow->dev.parent = &mci->dev;\r\ncsrow->mci = mci;\r\ndev_set_name(&csrow->dev, "csrow%d", index);\r\ndev_set_drvdata(&csrow->dev, csrow);\r\nedac_dbg(0, "creating (virtual) csrow node %s\n",\r\ndev_name(&csrow->dev));\r\nreturn device_add(&csrow->dev);\r\n}\r\nstatic int edac_create_csrow_objects(struct mem_ctl_info *mci)\r\n{\r\nint err, i;\r\nstruct csrow_info *csrow;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\nerr = edac_create_csrow_object(mci, mci->csrows[i], i);\r\nif (err < 0) {\r\nedac_dbg(1,\r\n"failure: create csrow objects for csrow %d\n",\r\ni);\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nfor (--i; i >= 0; i--) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\nput_device(&mci->csrows[i]->dev);\r\n}\r\nreturn err;\r\n}\r\nstatic void edac_delete_csrow_objects(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nstruct csrow_info *csrow;\r\nfor (i = mci->nr_csrows - 1; i >= 0; i--) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\ndevice_unregister(&mci->csrows[i]->dev);\r\n}\r\n}\r\nstatic ssize_t dimmdev_location_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn edac_dimm_info_location(dimm, data, PAGE_SIZE);\r\n}\r\nstatic ssize_t dimmdev_label_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nif (!dimm->label[0])\r\nreturn 0;\r\nreturn snprintf(data, EDAC_MC_LABEL_LEN, "%s\n", dimm->label);\r\n}\r\nstatic ssize_t dimmdev_label_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data,\r\nsize_t count)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nssize_t max_size = 0;\r\nmax_size = min((ssize_t) count, (ssize_t) EDAC_MC_LABEL_LEN - 1);\r\nstrncpy(dimm->label, data, max_size);\r\ndimm->label[max_size] = '\0';\r\nreturn max_size;\r\n}\r\nstatic ssize_t dimmdev_size_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(dimm->nr_pages));\r\n}\r\nstatic ssize_t dimmdev_mem_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", mem_types[dimm->mtype]);\r\n}\r\nstatic ssize_t dimmdev_dev_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", dev_types[dimm->dtype]);\r\n}\r\nstatic ssize_t dimmdev_edac_mode_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", edac_caps[dimm->edac_mode]);\r\n}\r\nstatic void dimm_attr_release(struct device *dev)\r\n{\r\nstruct dimm_info *dimm = container_of(dev, struct dimm_info, dev);\r\nedac_dbg(1, "Releasing dimm device %s\n", dev_name(dev));\r\nkfree(dimm);\r\n}\r\nstatic int edac_create_dimm_object(struct mem_ctl_info *mci,\r\nstruct dimm_info *dimm,\r\nint index)\r\n{\r\nint err;\r\ndimm->mci = mci;\r\ndimm->dev.type = &dimm_attr_type;\r\ndimm->dev.bus = mci->bus;\r\ndevice_initialize(&dimm->dev);\r\ndimm->dev.parent = &mci->dev;\r\nif (mci->csbased)\r\ndev_set_name(&dimm->dev, "rank%d", index);\r\nelse\r\ndev_set_name(&dimm->dev, "dimm%d", index);\r\ndev_set_drvdata(&dimm->dev, dimm);\r\npm_runtime_forbid(&mci->dev);\r\nerr = device_add(&dimm->dev);\r\nedac_dbg(0, "creating rank/dimm device %s\n", dev_name(&dimm->dev));\r\nreturn err;\r\n}\r\nstatic ssize_t mci_reset_counters_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint cnt, row, chan, i;\r\nmci->ue_mc = 0;\r\nmci->ce_mc = 0;\r\nmci->ue_noinfo_count = 0;\r\nmci->ce_noinfo_count = 0;\r\nfor (row = 0; row < mci->nr_csrows; row++) {\r\nstruct csrow_info *ri = mci->csrows[row];\r\nri->ue_count = 0;\r\nri->ce_count = 0;\r\nfor (chan = 0; chan < ri->nr_channels; chan++)\r\nri->channels[chan]->ce_count = 0;\r\n}\r\ncnt = 1;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\ncnt *= mci->layers[i].size;\r\nmemset(mci->ce_per_layer[i], 0, cnt * sizeof(u32));\r\nmemset(mci->ue_per_layer[i], 0, cnt * sizeof(u32));\r\n}\r\nmci->start_time = jiffies;\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nunsigned long bandwidth = 0;\r\nint new_bw = 0;\r\nif (kstrtoul(data, 10, &bandwidth) < 0)\r\nreturn -EINVAL;\r\nnew_bw = mci->set_sdram_scrub_rate(mci, bandwidth);\r\nif (new_bw < 0) {\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"Error setting scrub rate to: %lu\n", bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint bandwidth = 0;\r\nbandwidth = mci->get_sdram_scrub_rate(mci);\r\nif (bandwidth < 0) {\r\nedac_printk(KERN_DEBUG, EDAC_MC, "Error reading scrub rate\n");\r\nreturn bandwidth;\r\n}\r\nreturn sprintf(data, "%d\n", bandwidth);\r\n}\r\nstatic ssize_t mci_ue_count_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ue_mc);\r\n}\r\nstatic ssize_t mci_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ce_mc);\r\n}\r\nstatic ssize_t mci_ce_noinfo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ce_noinfo_count);\r\n}\r\nstatic ssize_t mci_ue_noinfo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ue_noinfo_count);\r\n}\r\nstatic ssize_t mci_seconds_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%ld\n", (jiffies - mci->start_time) / HZ);\r\n}\r\nstatic ssize_t mci_ctl_name_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%s\n", mci->ctl_name);\r\n}\r\nstatic ssize_t mci_size_mb_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint total_pages = 0, csrow_idx, j;\r\nfor (csrow_idx = 0; csrow_idx < mci->nr_csrows; csrow_idx++) {\r\nstruct csrow_info *csrow = mci->csrows[csrow_idx];\r\nfor (j = 0; j < csrow->nr_channels; j++) {\r\nstruct dimm_info *dimm = csrow->channels[j]->dimm;\r\ntotal_pages += dimm->nr_pages;\r\n}\r\n}\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));\r\n}\r\nstatic ssize_t mci_max_location_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint i;\r\nchar *p = data;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\np += sprintf(p, "%s %d ",\r\nedac_layer_name[mci->layers[i].type],\r\nmci->layers[i].size - 1);\r\n}\r\nreturn p - data;\r\n}\r\nstatic ssize_t edac_fake_inject_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstatic enum hw_event_mc_err_type type;\r\nu16 errcount = mci->fake_inject_count;\r\nif (!errcount)\r\nerrcount = 1;\r\ntype = mci->fake_inject_ue ? HW_EVENT_ERR_UNCORRECTED\r\n: HW_EVENT_ERR_CORRECTED;\r\nprintk(KERN_DEBUG\r\n"Generating %d %s fake error%s to %d.%d.%d to test core handling. NOTE: this won't test the driver-specific decoding logic.\n",\r\nerrcount,\r\n(type == HW_EVENT_ERR_UNCORRECTED) ? "UE" : "CE",\r\nerrcount > 1 ? "s" : "",\r\nmci->fake_inject_layer[0],\r\nmci->fake_inject_layer[1],\r\nmci->fake_inject_layer[2]\r\n);\r\nedac_mc_handle_error(type, mci, errcount, 0, 0, 0,\r\nmci->fake_inject_layer[0],\r\nmci->fake_inject_layer[1],\r\nmci->fake_inject_layer[2],\r\n"FAKE ERROR", "for EDAC testing only");\r\nreturn count;\r\n}\r\nstatic umode_t mci_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\numode_t mode = 0;\r\nif (attr != &dev_attr_sdram_scrub_rate.attr)\r\nreturn attr->mode;\r\nif (mci->get_sdram_scrub_rate)\r\nmode |= S_IRUGO;\r\nif (mci->set_sdram_scrub_rate)\r\nmode |= S_IWUSR;\r\nreturn mode;\r\n}\r\nstatic void mci_attr_release(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci = container_of(dev, struct mem_ctl_info, dev);\r\nedac_dbg(1, "Releasing csrow device %s\n", dev_name(dev));\r\nkfree(mci);\r\n}\r\nint __init edac_debugfs_init(void)\r\n{\r\nedac_debugfs = debugfs_create_dir("edac", NULL);\r\nif (IS_ERR(edac_debugfs)) {\r\nedac_debugfs = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid edac_debugfs_exit(void)\r\n{\r\ndebugfs_remove(edac_debugfs);\r\n}\r\nstatic int edac_create_debug_nodes(struct mem_ctl_info *mci)\r\n{\r\nstruct dentry *d, *parent;\r\nchar name[80];\r\nint i;\r\nif (!edac_debugfs)\r\nreturn -ENODEV;\r\nd = debugfs_create_dir(mci->dev.kobj.name, edac_debugfs);\r\nif (!d)\r\nreturn -ENOMEM;\r\nparent = d;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nsprintf(name, "fake_inject_%s",\r\nedac_layer_name[mci->layers[i].type]);\r\nd = debugfs_create_u8(name, S_IRUGO | S_IWUSR, parent,\r\n&mci->fake_inject_layer[i]);\r\nif (!d)\r\ngoto nomem;\r\n}\r\nd = debugfs_create_bool("fake_inject_ue", S_IRUGO | S_IWUSR, parent,\r\n&mci->fake_inject_ue);\r\nif (!d)\r\ngoto nomem;\r\nd = debugfs_create_u16("fake_inject_count", S_IRUGO | S_IWUSR, parent,\r\n&mci->fake_inject_count);\r\nif (!d)\r\ngoto nomem;\r\nd = debugfs_create_file("fake_inject", S_IWUSR, parent,\r\n&mci->dev,\r\n&debug_fake_inject_fops);\r\nif (!d)\r\ngoto nomem;\r\nmci->debugfs = parent;\r\nreturn 0;\r\nnomem:\r\ndebugfs_remove(mci->debugfs);\r\nreturn -ENOMEM;\r\n}\r\nint edac_create_sysfs_mci_device(struct mem_ctl_info *mci,\r\nconst struct attribute_group **groups)\r\n{\r\nint i, err;\r\nmci->bus->name = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);\r\nif (!mci->bus->name)\r\nreturn -ENOMEM;\r\nedac_dbg(0, "creating bus %s\n", mci->bus->name);\r\nerr = bus_register(mci->bus);\r\nif (err < 0)\r\ngoto fail_free_name;\r\nmci->dev.type = &mci_attr_type;\r\ndevice_initialize(&mci->dev);\r\nmci->dev.parent = mci_pdev;\r\nmci->dev.bus = mci->bus;\r\nmci->dev.groups = groups;\r\ndev_set_name(&mci->dev, "mc%d", mci->mc_idx);\r\ndev_set_drvdata(&mci->dev, mci);\r\npm_runtime_forbid(&mci->dev);\r\nedac_dbg(0, "creating device %s\n", dev_name(&mci->dev));\r\nerr = device_add(&mci->dev);\r\nif (err < 0) {\r\nedac_dbg(1, "failure: create device %s\n", dev_name(&mci->dev));\r\ngoto fail_unregister_bus;\r\n}\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (!dimm->nr_pages)\r\ncontinue;\r\n#ifdef CONFIG_EDAC_DEBUG\r\nedac_dbg(1, "creating dimm%d, located at ", i);\r\nif (edac_debug_level >= 1) {\r\nint lay;\r\nfor (lay = 0; lay < mci->n_layers; lay++)\r\nprintk(KERN_CONT "%s %d ",\r\nedac_layer_name[mci->layers[lay].type],\r\ndimm->location[lay]);\r\nprintk(KERN_CONT "\n");\r\n}\r\n#endif\r\nerr = edac_create_dimm_object(mci, dimm, i);\r\nif (err) {\r\nedac_dbg(1, "failure: create dimm %d obj\n", i);\r\ngoto fail_unregister_dimm;\r\n}\r\n}\r\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\r\nerr = edac_create_csrow_objects(mci);\r\nif (err < 0)\r\ngoto fail_unregister_dimm;\r\n#endif\r\n#ifdef CONFIG_EDAC_DEBUG\r\nedac_create_debug_nodes(mci);\r\n#endif\r\nreturn 0;\r\nfail_unregister_dimm:\r\nfor (i--; i >= 0; i--) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (!dimm->nr_pages)\r\ncontinue;\r\ndevice_unregister(&dimm->dev);\r\n}\r\ndevice_unregister(&mci->dev);\r\nfail_unregister_bus:\r\nbus_unregister(mci->bus);\r\nfail_free_name:\r\nkfree(mci->bus->name);\r\nreturn err;\r\n}\r\nvoid edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nedac_dbg(0, "\n");\r\n#ifdef CONFIG_EDAC_DEBUG\r\ndebugfs_remove(mci->debugfs);\r\n#endif\r\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\r\nedac_delete_csrow_objects(mci);\r\n#endif\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (dimm->nr_pages == 0)\r\ncontinue;\r\nedac_dbg(0, "removing device %s\n", dev_name(&dimm->dev));\r\ndevice_unregister(&dimm->dev);\r\n}\r\n}\r\nvoid edac_unregister_sysfs(struct mem_ctl_info *mci)\r\n{\r\nedac_dbg(1, "Unregistering device %s\n", dev_name(&mci->dev));\r\ndevice_unregister(&mci->dev);\r\nbus_unregister(mci->bus);\r\nkfree(mci->bus->name);\r\n}\r\nstatic void mc_attr_release(struct device *dev)\r\n{\r\nedac_dbg(1, "Releasing device %s\n", dev_name(dev));\r\nkfree(dev);\r\n}\r\nint __init edac_mc_sysfs_init(void)\r\n{\r\nstruct bus_type *edac_subsys;\r\nint err;\r\nedac_subsys = edac_get_sysfs_subsys();\r\nif (edac_subsys == NULL) {\r\nedac_dbg(1, "no edac_subsys\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmci_pdev = kzalloc(sizeof(*mci_pdev), GFP_KERNEL);\r\nif (!mci_pdev) {\r\nerr = -ENOMEM;\r\ngoto out_put_sysfs;\r\n}\r\nmci_pdev->bus = edac_subsys;\r\nmci_pdev->type = &mc_attr_type;\r\ndevice_initialize(mci_pdev);\r\ndev_set_name(mci_pdev, "mc");\r\nerr = device_add(mci_pdev);\r\nif (err < 0)\r\ngoto out_dev_free;\r\nedac_dbg(0, "device %s created\n", dev_name(mci_pdev));\r\nreturn 0;\r\nout_dev_free:\r\nkfree(mci_pdev);\r\nout_put_sysfs:\r\nedac_put_sysfs_subsys();\r\nout:\r\nreturn err;\r\n}\r\nvoid edac_mc_sysfs_exit(void)\r\n{\r\ndevice_unregister(mci_pdev);\r\nedac_put_sysfs_subsys();\r\n}
