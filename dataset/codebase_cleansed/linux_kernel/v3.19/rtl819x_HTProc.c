void HTUpdateDefaultSetting(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\npHTInfo->bAcceptAddbaReq = 1;\r\npHTInfo->bRegShortGI20MHz = 1;\r\npHTInfo->bRegShortGI40MHz = 1;\r\npHTInfo->bRegBW40MHz = 1;\r\nif (pHTInfo->bRegBW40MHz)\r\npHTInfo->bRegSuppCCK = 1;\r\nelse\r\npHTInfo->bRegSuppCCK = true;\r\npHTInfo->nAMSDU_MaxSize = 7935UL;\r\npHTInfo->bAMSDU_Support = 0;\r\npHTInfo->bAMPDUEnable = 1;\r\npHTInfo->AMPDU_Factor = 2;\r\npHTInfo->MPDU_Density = 0;\r\npHTInfo->SelfMimoPs = 3;\r\nif (pHTInfo->SelfMimoPs == 2)\r\npHTInfo->SelfMimoPs = 3;\r\nieee->bTxDisableRateFallBack = 0;\r\nieee->bTxUseDriverAssingedRate = 0;\r\nieee->bTxEnableFwCalcDur = 1;\r\npHTInfo->bRegRT2RTAggregation = 1;\r\npHTInfo->bRegRxReorderEnable = 1;\r\npHTInfo->RxReorderWinSize = 64;\r\npHTInfo->RxReorderPendingTime = 30;\r\n}\r\nvoid HTDebugHTCapability(u8 *CapIE, u8 *TitleString)\r\n{\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nstruct ht_capab_ele *pCapELE;\r\nif (!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap))) {\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);\r\npCapELE = (struct ht_capab_ele *)(&CapIE[4]);\r\n} else\r\npCapELE = (struct ht_capab_ele *)(&CapIE[0]);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Capability>. Called by %s\n",\r\nTitleString);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSupported Channel Width = %s\n",\r\n(pCapELE->ChlWidth) ? "20MHz" : "20/40MHz");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSupport Short GI for 20M = %s\n",\r\n(pCapELE->ShortGI20Mhz) ? "YES" : "NO");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSupport Short GI for 40M = %s\n",\r\n(pCapELE->ShortGI40Mhz) ? "YES" : "NO");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSupport TX STBC = %s\n",\r\n(pCapELE->TxSTBC) ? "YES" : "NO");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tMax AMSDU Size = %s\n",\r\n(pCapELE->MaxAMSDUSize) ? "3839" : "7935");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSupport CCK in 20/40 mode = %s\n",\r\n(pCapELE->DssCCk) ? "YES" : "NO");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tMax AMPDU Factor = %d\n",\r\npCapELE->MaxRxAMPDUFactor);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tMPDU Density = %d\n",\r\npCapELE->MPDUDensity);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n",\r\npCapELE->MCS[0], pCapELE->MCS[1], pCapELE->MCS[2],\r\npCapELE->MCS[3], pCapELE->MCS[4]);\r\nreturn;\r\n}\r\nvoid HTDebugHTInfo(u8 *InfoIE, u8 *TitleString)\r\n{\r\nstatic u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\r\nstruct ht_info_ele *pHTInfoEle;\r\nif (!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo))) {\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "EWC IE in %s()\n", __func__);\r\npHTInfoEle = (struct ht_info_ele *)(&InfoIE[4]);\r\n} else\r\npHTInfoEle = (struct ht_info_ele *)(&InfoIE[0]);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "<Log HT Information Element>. "\r\n"Called by %s\n", TitleString);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tPrimary channel = %d\n",\r\npHTInfoEle->ControlChl);\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tSenondary channel =");\r\nswitch (pHTInfoEle->ExtChlOffset) {\r\ncase 0:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "Not Present\n");\r\nbreak;\r\ncase 1:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "Upper channel\n");\r\nbreak;\r\ncase 2:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "Reserved. Eooro!!!\n");\r\nbreak;\r\ncase 3:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "Lower Channel\n");\r\nbreak;\r\n}\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tRecommended channel width = %s\n",\r\n(pHTInfoEle->RecommemdedTxWidth) ? "20Mhz" : "40Mhz");\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tOperation mode for protection = ");\r\nswitch (pHTInfoEle->OptMode) {\r\ncase 0:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "No Protection\n");\r\nbreak;\r\ncase 1:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "HT non-member protection mode\n");\r\nbreak;\r\ncase 2:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "Suggest to open protection\n");\r\nbreak;\r\ncase 3:\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "HT mixed mode\n");\r\nbreak;\r\n}\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x]"\r\n"[%x]\n", pHTInfoEle->BasicMSC[0], pHTInfoEle->BasicMSC[1],\r\npHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3],\r\npHTInfoEle->BasicMSC[4]);\r\n}\r\nstatic bool IsHTHalfNmode40Bandwidth(struct rtllib_device *ieee)\r\n{\r\nbool retValue = false;\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nif (pHTInfo->bCurrentHTSupport == false)\r\nretValue = false;\r\nelse if (pHTInfo->bRegBW40MHz == false)\r\nretValue = false;\r\nelse if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\r\nretValue = false;\r\nelse if (((struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf))->ChlWidth)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\nreturn retValue;\r\n}\r\nstatic bool IsHTHalfNmodeSGI(struct rtllib_device *ieee, bool is40MHz)\r\n{\r\nbool retValue = false;\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nif (pHTInfo->bCurrentHTSupport == false)\r\nretValue = false;\r\nelse if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\r\nretValue = false;\r\nelse if (is40MHz) {\r\nif (((struct ht_capab_ele *)\r\n(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\n} else {\r\nif (((struct ht_capab_ele *)\r\n(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\n}\r\nreturn retValue;\r\n}\r\nu16 HTHalfMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)\r\n{\r\nu8 is40MHz;\r\nu8 isShortGI;\r\nis40MHz = (IsHTHalfNmode40Bandwidth(ieee)) ? 1 : 0;\r\nisShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz)) ? 1 : 0;\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];\r\n}\r\nu16 HTMcsToDataRate(struct rtllib_device *ieee, u8 nMcsRate)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nu8 is40MHz = (pHTInfo->bCurBW40MHz) ? 1 : 0;\r\nu8 isShortGI = (pHTInfo->bCurBW40MHz) ?\r\n((pHTInfo->bCurShortGI40MHz) ? 1 : 0) :\r\n((pHTInfo->bCurShortGI20MHz) ? 1 : 0);\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate & 0x7f)];\r\n}\r\nu16 TxCountToDataRate(struct rtllib_device *ieee, u8 nDataRate)\r\n{\r\nu16 CCKOFDMRate[12] = {0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18,\r\n0x24, 0x30, 0x48, 0x60, 0x6c};\r\nu8 is40MHz = 0;\r\nu8 isShortGI = 0;\r\nif (nDataRate < 12) {\r\nreturn CCKOFDMRate[nDataRate];\r\n} else {\r\nif (nDataRate >= 0x10 && nDataRate <= 0x1f) {\r\nis40MHz = 0;\r\nisShortGI = 0;\r\n} else if (nDataRate >= 0x20 && nDataRate <= 0x2f) {\r\nis40MHz = 1;\r\nisShortGI = 0;\r\n} else if (nDataRate >= 0x30 && nDataRate <= 0x3f) {\r\nis40MHz = 0;\r\nisShortGI = 1;\r\n} else if (nDataRate >= 0x40 && nDataRate <= 0x4f) {\r\nis40MHz = 1;\r\nisShortGI = 1;\r\n}\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];\r\n}\r\n}\r\nbool IsHTHalfNmodeAPs(struct rtllib_device *ieee)\r\n{\r\nbool retValue = false;\r\nstruct rtllib_network *net = &ieee->current_network;\r\nif ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\r\n(net->ralink_cap_exist))\r\nretValue = true;\r\nelse if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||\r\n!memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||\r\n!memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ||\r\n(net->broadcom_cap_exist))\r\nretValue = true;\r\nelse if (net->bssht.bdRT2RTAggregation)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\nreturn retValue;\r\n}\r\nstatic void HTIOTPeerDetermine(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nstruct rtllib_network *net = &ieee->current_network;\r\nif (net->bssht.bdRT2RTAggregation) {\r\npHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;\r\nif (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE)\r\npHTInfo->IOTPeer = HT_IOT_PEER_REALTEK_92SE;\r\nif (net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_SOFTAP)\r\npHTInfo->IOTPeer = HT_IOT_PEER_92U_SOFTAP;\r\n} else if (net->broadcom_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\r\nelse if (!memcmp(net->bssid, UNKNOWN_BORADCOM, 3) ||\r\n!memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3) ||\r\n!memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3))\r\npHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\r\nelse if ((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, PCI_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, EDIMAX_RALINK, 3) == 0) ||\r\n(memcmp(net->bssid, AIRLINK_RALINK, 3) == 0) ||\r\nnet->ralink_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_RALINK;\r\nelse if ((net->atheros_cap_exist) ||\r\n(memcmp(net->bssid, DLINK_ATHEROS_1, 3) == 0) ||\r\n(memcmp(net->bssid, DLINK_ATHEROS_2, 3) == 0))\r\npHTInfo->IOTPeer = HT_IOT_PEER_ATHEROS;\r\nelse if ((memcmp(net->bssid, CISCO_BROADCOM, 3) == 0) ||\r\nnet->cisco_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_CISCO;\r\nelse if ((memcmp(net->bssid, LINKSYS_MARVELL_4400N, 3) == 0) ||\r\nnet->marvell_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_MARVELL;\r\nelse if (net->airgo_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_AIRGO;\r\nelse\r\npHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\r\nRTLLIB_DEBUG(RTLLIB_DL_IOT, "Joseph debug!! IOTPEER: %x\n",\r\npHTInfo->IOTPeer);\r\n}\r\nstatic u8 HTIOTActIsDisableMCS14(struct rtllib_device *ieee, u8 *PeerMacAddr)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool HTIOTActIsDisableMCS15(struct rtllib_device *ieee)\r\n{\r\nbool retValue = false;\r\nreturn retValue;\r\n}\r\nstatic bool HTIOTActIsDisableMCSTwoSpatialStream(struct rtllib_device *ieee)\r\n{\r\nreturn false;\r\n}\r\nstatic u8 HTIOTActIsDisableEDCATurbo(struct rtllib_device *ieee, u8 *PeerMacAddr)\r\n{\r\nreturn false;\r\n}\r\nstatic u8 HTIOTActIsMgntUseCCK6M(struct rtllib_device *ieee,\r\nstruct rtllib_network *network)\r\n{\r\nu8 retValue = 0;\r\nif (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)\r\nretValue = 1;\r\nreturn retValue;\r\n}\r\nstatic u8 HTIOTActIsCCDFsync(struct rtllib_device *ieee)\r\n{\r\nu8 retValue = 0;\r\nif (ieee->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)\r\nretValue = 1;\r\nreturn retValue;\r\n}\r\nstatic void HTIOTActDetermineRaFunc(struct rtllib_device *ieee, bool bPeerRx2ss)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\npHTInfo->IOTRaFunc &= HT_IOT_RAFUNC_DISABLE_ALL;\r\nif (pHTInfo->IOTPeer == HT_IOT_PEER_RALINK && !bPeerRx2ss)\r\npHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_PEER_1R;\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_AMSDU_ENABLE)\r\npHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_TX_AMSDU;\r\n}\r\nvoid HTResetIOTSetting(struct rt_hi_throughput *pHTInfo)\r\n{\r\npHTInfo->IOTAction = 0;\r\npHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\r\npHTInfo->IOTRaFunc = 0;\r\n}\r\nvoid HTConstructCapabilityElement(struct rtllib_device *ieee, u8 *posHTCap,\r\nu8 *len, u8 IsEncrypt, bool bAssoc)\r\n{\r\nstruct rt_hi_throughput *pHT = ieee->pHTInfo;\r\nstruct ht_capab_ele *pCapELE = NULL;\r\nif ((posHTCap == NULL) || (pHT == NULL)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTCap or pHTInfo can't be "\r\n"null in HTConstructCapabilityElement()\n");\r\nreturn;\r\n}\r\nmemset(posHTCap, 0, *len);\r\nif ((bAssoc) && (pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)) {\r\nu8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nmemcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));\r\npCapELE = (struct ht_capab_ele *)&(posHTCap[4]);\r\n*len = 30 + 2;\r\n} else {\r\npCapELE = (struct ht_capab_ele *)posHTCap;\r\n*len = 26 + 2;\r\n}\r\npCapELE->AdvCoding = 0;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\r\npCapELE->ChlWidth = 0;\r\nelse\r\npCapELE->ChlWidth = (pHT->bRegBW40MHz ? 1 : 0);\r\npCapELE->MimoPwrSave = pHT->SelfMimoPs;\r\npCapELE->GreenField = 0;\r\npCapELE->ShortGI20Mhz = 1;\r\npCapELE->ShortGI40Mhz = 1;\r\npCapELE->TxSTBC = 1;\r\npCapELE->RxSTBC = 0;\r\npCapELE->DelayBA = 0;\r\npCapELE->MaxAMSDUSize = (MAX_RECEIVE_BUFFER_SIZE >= 7935) ? 1 : 0;\r\npCapELE->DssCCk = ((pHT->bRegBW40MHz) ? (pHT->bRegSuppCCK ? 1 : 0) : 0);\r\npCapELE->PSMP = 0;\r\npCapELE->LSigTxopProtect = 0;\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d "\r\n"DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize,\r\npCapELE->DssCCk);\r\nif (IsEncrypt) {\r\npCapELE->MPDUDensity = 7;\r\npCapELE->MaxRxAMPDUFactor = 2;\r\n} else {\r\npCapELE->MaxRxAMPDUFactor = 3;\r\npCapELE->MPDUDensity = 0;\r\n}\r\nmemcpy(pCapELE->MCS, ieee->Regdot11HTOperationalRateSet, 16);\r\nmemset(&pCapELE->ExtHTCapInfo, 0, 2);\r\nmemset(pCapELE->TxBFCap, 0, 4);\r\npCapELE->ASCap = 0;\r\nif (bAssoc) {\r\nif (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS15)\r\npCapELE->MCS[1] &= 0x7f;\r\nif (pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS14)\r\npCapELE->MCS[1] &= 0xbf;\r\nif (pHT->IOTAction & HT_IOT_ACT_DISABLE_ALL_2SS)\r\npCapELE->MCS[1] &= 0x00;\r\nif (pHT->IOTAction & HT_IOT_ACT_DISABLE_RX_40MHZ_SHORT_GI)\r\npCapELE->ShortGI40Mhz = 0;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)) {\r\npCapELE->ChlWidth = 0;\r\npCapELE->MCS[1] = 0;\r\n}\r\n}\r\n}\r\nvoid HTConstructInfoElement(struct rtllib_device *ieee, u8 *posHTInfo,\r\nu8 *len, u8 IsEncrypt)\r\n{\r\nstruct rt_hi_throughput *pHT = ieee->pHTInfo;\r\nstruct ht_info_ele *pHTInfoEle = (struct ht_info_ele *)posHTInfo;\r\nif ((posHTInfo == NULL) || (pHTInfoEle == NULL)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "posHTInfo or pHTInfoEle can't be "\r\n"null in HTConstructInfoElement()\n");\r\nreturn;\r\n}\r\nmemset(posHTInfo, 0, *len);\r\nif ((ieee->iw_mode == IW_MODE_ADHOC) ||\r\n(ieee->iw_mode == IW_MODE_MASTER)) {\r\npHTInfoEle->ControlChl = ieee->current_network.channel;\r\npHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false) ?\r\nHT_EXTCHNL_OFFSET_NO_EXT :\r\n(ieee->current_network.channel <= 6)\r\n? HT_EXTCHNL_OFFSET_UPPER :\r\nHT_EXTCHNL_OFFSET_LOWER);\r\npHTInfoEle->RecommemdedTxWidth = pHT->bRegBW40MHz;\r\npHTInfoEle->RIFS = 0;\r\npHTInfoEle->PSMPAccessOnly = 0;\r\npHTInfoEle->SrvIntGranularity = 0;\r\npHTInfoEle->OptMode = pHT->CurrentOpMode;\r\npHTInfoEle->NonGFDevPresent = 0;\r\npHTInfoEle->DualBeacon = 0;\r\npHTInfoEle->SecondaryBeacon = 0;\r\npHTInfoEle->LSigTxopProtectFull = 0;\r\npHTInfoEle->PcoActive = 0;\r\npHTInfoEle->PcoPhase = 0;\r\nmemset(pHTInfoEle->BasicMSC, 0, 16);\r\n*len = 22 + 2;\r\n} else {\r\n*len = 0;\r\n}\r\n}\r\nvoid HTConstructRT2RTAggElement(struct rtllib_device *ieee, u8 *posRT2RTAgg,\r\nu8 *len)\r\n{\r\nif (posRT2RTAgg == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "posRT2RTAgg can't be null in "\r\n"HTConstructRT2RTAggElement()\n");\r\nreturn;\r\n}\r\nmemset(posRT2RTAgg, 0, *len);\r\n*posRT2RTAgg++ = 0x00;\r\n*posRT2RTAgg++ = 0xe0;\r\n*posRT2RTAgg++ = 0x4c;\r\n*posRT2RTAgg++ = 0x02;\r\n*posRT2RTAgg++ = 0x01;\r\n*posRT2RTAgg = 0x30;\r\nif (ieee->bSupportRemoteWakeUp)\r\n*posRT2RTAgg |= RT_HT_CAP_USE_WOW;\r\n*len = 6 + 2;\r\n}\r\nstatic u8 HT_PickMCSRate(struct rtllib_device *ieee, u8 *pOperateMCS)\r\n{\r\nu8 i;\r\nif (pOperateMCS == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "pOperateMCS can't be null"\r\n" in HT_PickMCSRate()\n");\r\nreturn false;\r\n}\r\nswitch (ieee->mode) {\r\ncase IEEE_A:\r\ncase IEEE_B:\r\ncase IEEE_G:\r\nfor (i = 0; i <= 15; i++)\r\npOperateMCS[i] = 0;\r\nbreak;\r\ncase IEEE_N_24G:\r\ncase IEEE_N_5G:\r\npOperateMCS[0] &= RATE_ADPT_1SS_MASK;\r\npOperateMCS[1] &= RATE_ADPT_2SS_MASK;\r\npOperateMCS[3] &= RATE_ADPT_MCS32_MASK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nu8 HTGetHighestMCSRate(struct rtllib_device *ieee, u8 *pMCSRateSet,\r\nu8 *pMCSFilter)\r\n{\r\nu8 i, j;\r\nu8 bitMap;\r\nu8 mcsRate = 0;\r\nu8 availableMcsRate[16];\r\nif (pMCSRateSet == NULL || pMCSFilter == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "pMCSRateSet or pMCSFilter can't "\r\n"be null in HTGetHighestMCSRate()\n");\r\nreturn false;\r\n}\r\nfor (i = 0; i < 16; i++)\r\navailableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];\r\nfor (i = 0; i < 16; i++) {\r\nif (availableMcsRate[i] != 0)\r\nbreak;\r\n}\r\nif (i == 16)\r\nreturn false;\r\nfor (i = 0; i < 16; i++) {\r\nif (availableMcsRate[i] != 0) {\r\nbitMap = availableMcsRate[i];\r\nfor (j = 0; j < 8; j++) {\r\nif ((bitMap%2) != 0) {\r\nif (HTMcsToDataRate(ieee, (8*i+j)) >\r\nHTMcsToDataRate(ieee, mcsRate))\r\nmcsRate = (8*i+j);\r\n}\r\nbitMap = bitMap>>1;\r\n}\r\n}\r\n}\r\nreturn mcsRate | 0x80;\r\n}\r\nu8 HTFilterMCSRate(struct rtllib_device *ieee, u8 *pSupportMCS, u8 *pOperateMCS)\r\n{\r\nu8 i;\r\nfor (i = 0; i <= 15; i++)\r\npOperateMCS[i] = ieee->Regdot11TxHTOperationalRateSet[i] &\r\npSupportMCS[i];\r\nHT_PickMCSRate(ieee, pOperateMCS);\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\r\npOperateMCS[1] = 0;\r\nfor (i = 2; i <= 15; i++)\r\npOperateMCS[i] = 0;\r\nreturn true;\r\n}\r\nvoid HTOnAssocRsp(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nstruct ht_capab_ele *pPeerHTCap = NULL;\r\nstruct ht_info_ele *pPeerHTInfo = NULL;\r\nu16 nMaxAMSDUSize = 0;\r\nu8 *pMcsFilter = NULL;\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nstatic u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\r\nif (pHTInfo->bCurrentHTSupport == false) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "<=== HTOnAssocRsp(): "\r\n"HT_DISABLE\n");\r\nreturn;\r\n}\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");\r\nif (!memcmp(pHTInfo->PeerHTCapBuf, EWC11NHTCap, sizeof(EWC11NHTCap)))\r\npPeerHTCap = (struct ht_capab_ele *)(&pHTInfo->PeerHTCapBuf[4]);\r\nelse\r\npPeerHTCap = (struct ht_capab_ele *)(pHTInfo->PeerHTCapBuf);\r\nif (!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))\r\npPeerHTInfo = (struct ht_info_ele *)\r\n(&pHTInfo->PeerHTInfoBuf[4]);\r\nelse\r\npPeerHTInfo = (struct ht_info_ele *)(pHTInfo->PeerHTInfoBuf);\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA | RTLLIB_DL_HT, pPeerHTCap,\r\nsizeof(struct ht_capab_ele));\r\nHTSetConnectBwMode(ieee, (enum ht_channel_width)(pPeerHTCap->ChlWidth),\r\n(enum ht_extchnl_offset)(pPeerHTInfo->ExtChlOffset));\r\npHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1) ?\r\ntrue : false);\r\npHTInfo->bCurShortGI20MHz = ((pHTInfo->bRegShortGI20MHz) ?\r\n((pPeerHTCap->ShortGI20Mhz == 1) ?\r\ntrue : false) : false);\r\npHTInfo->bCurShortGI40MHz = ((pHTInfo->bRegShortGI40MHz) ?\r\n((pPeerHTCap->ShortGI40Mhz == 1) ?\r\ntrue : false) : false);\r\npHTInfo->bCurSuppCCK = ((pHTInfo->bRegSuppCCK) ?\r\n((pPeerHTCap->DssCCk == 1) ? true :\r\nfalse) : false);\r\npHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;\r\nnMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize == 0) ? 3839 : 7935;\r\nif (pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize)\r\npHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;\r\nelse\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;\r\nif (ieee->rtllib_ap_sec_type &&\r\n(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP))) {\r\nif ((pHTInfo->IOTPeer == HT_IOT_PEER_ATHEROS) ||\r\n(pHTInfo->IOTPeer == HT_IOT_PEER_UNKNOWN))\r\npHTInfo->bCurrentAMPDUEnable = false;\r\n}\r\nif (!pHTInfo->bRegRT2RTAggregation) {\r\nif (pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)\r\npHTInfo->CurrentAMPDUFactor =\r\npPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\n} else {\r\nif (ieee->current_network.bssht.bdRT2RTAggregation) {\r\nif (ieee->pairwise_key_type != KEY_TYPE_NA)\r\npHTInfo->CurrentAMPDUFactor =\r\npPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;\r\n} else {\r\nif (pPeerHTCap->MaxRxAMPDUFactor < HT_AGG_SIZE_32K)\r\npHTInfo->CurrentAMPDUFactor =\r\npPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_32K;\r\n}\r\n}\r\nif (pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)\r\npHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\r\nelse\r\npHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_TX_USE_AMSDU_8K) {\r\npHTInfo->bCurrentAMPDUEnable = false;\r\npHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;\r\npHTInfo->ForcedAMSDUMaxSize = 7935;\r\n}\r\npHTInfo->bCurRxReorderEnable = pHTInfo->bRegRxReorderEnable;\r\nif (pPeerHTCap->MCS[0] == 0)\r\npPeerHTCap->MCS[0] = 0xff;\r\nHTIOTActDetermineRaFunc(ieee, ((pPeerHTCap->MCS[1]) != 0));\r\nHTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);\r\npHTInfo->PeerMimoPs = pPeerHTCap->MimoPwrSave;\r\nif (pHTInfo->PeerMimoPs == MIMO_PS_STATIC)\r\npMcsFilter = MCS_FILTER_1SS;\r\nelse\r\npMcsFilter = MCS_FILTER_ALL;\r\nieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,\r\nieee->dot11HTOperationalRateSet, pMcsFilter);\r\nieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\r\npHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\r\n}\r\nvoid HTInitializeHTInfo(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "===========>%s()\n", __func__);\r\npHTInfo->bCurrentHTSupport = false;\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->bCurTxBW40MHz = false;\r\npHTInfo->bCurShortGI20MHz = false;\r\npHTInfo->bCurShortGI40MHz = false;\r\npHTInfo->bForcedShortGI = false;\r\npHTInfo->bCurSuppCCK = true;\r\npHTInfo->bCurrent_AMSDU_Support = false;\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\nmemset((void *)(&(pHTInfo->SelfHTCap)), 0,\r\nsizeof(pHTInfo->SelfHTCap));\r\nmemset((void *)(&(pHTInfo->SelfHTInfo)), 0,\r\nsizeof(pHTInfo->SelfHTInfo));\r\nmemset((void *)(&(pHTInfo->PeerHTCapBuf)), 0,\r\nsizeof(pHTInfo->PeerHTCapBuf));\r\nmemset((void *)(&(pHTInfo->PeerHTInfoBuf)), 0,\r\nsizeof(pHTInfo->PeerHTInfoBuf));\r\npHTInfo->bSwBwInProgress = false;\r\npHTInfo->ChnlOp = CHNLOP_NONE;\r\npHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\npHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;\r\npHTInfo->IOTPeer = 0;\r\npHTInfo->IOTAction = 0;\r\npHTInfo->IOTRaFunc = 0;\r\n{\r\nu8 *RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);\r\nRegHTSuppRateSets[0] = 0xFF;\r\nRegHTSuppRateSets[1] = 0xFF;\r\nRegHTSuppRateSets[4] = 0x01;\r\n}\r\n}\r\nvoid HTInitializeBssDesc(struct bss_ht *pBssHT)\r\n{\r\npBssHT->bdSupportHT = false;\r\nmemset(pBssHT->bdHTCapBuf, 0, sizeof(pBssHT->bdHTCapBuf));\r\npBssHT->bdHTCapLen = 0;\r\nmemset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));\r\npBssHT->bdHTInfoLen = 0;\r\npBssHT->bdHTSpecVer = HT_SPEC_VER_IEEE;\r\npBssHT->bdRT2RTAggregation = false;\r\npBssHT->bdRT2RTLongSlotTime = false;\r\npBssHT->RT2RT_HT_Mode = (enum rt_ht_capability)0;\r\n}\r\nvoid HTResetSelfAndSavePeerSetting(struct rtllib_device *ieee,\r\nstruct rtllib_network *pNetwork)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nu8 bIOTAction = 0;\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "==============>%s()\n", __func__);\r\nif (pNetwork->bssht.bdSupportHT) {\r\npHTInfo->bCurrentHTSupport = true;\r\npHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;\r\nif (pNetwork->bssht.bdHTCapLen > 0 &&\r\npNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))\r\nmemcpy(pHTInfo->PeerHTCapBuf,\r\npNetwork->bssht.bdHTCapBuf,\r\npNetwork->bssht.bdHTCapLen);\r\nif (pNetwork->bssht.bdHTInfoLen > 0 &&\r\npNetwork->bssht.bdHTInfoLen <=\r\nsizeof(pHTInfo->PeerHTInfoBuf))\r\nmemcpy(pHTInfo->PeerHTInfoBuf,\r\npNetwork->bssht.bdHTInfoBuf,\r\npNetwork->bssht.bdHTInfoLen);\r\nif (pHTInfo->bRegRT2RTAggregation) {\r\npHTInfo->bCurrentRT2RTAggregation =\r\npNetwork->bssht.bdRT2RTAggregation;\r\npHTInfo->bCurrentRT2RTLongSlotTime =\r\npNetwork->bssht.bdRT2RTLongSlotTime;\r\npHTInfo->RT2RT_HT_Mode = pNetwork->bssht.RT2RT_HT_Mode;\r\n} else {\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\npHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;\r\n}\r\nHTIOTPeerDetermine(ieee);\r\npHTInfo->IOTAction = 0;\r\nbIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS14;\r\nbIOTAction = HTIOTActIsDisableMCS15(ieee);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS15;\r\nbIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_ALL_2SS;\r\nbIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;\r\nbIOTAction = HTIOTActIsMgntUseCCK6M(ieee, pNetwork);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;\r\nbIOTAction = HTIOTActIsCCDFsync(ieee);\r\nif (bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;\r\n} else {\r\npHTInfo->bCurrentHTSupport = false;\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\npHTInfo->RT2RT_HT_Mode = (enum rt_ht_capability)0;\r\npHTInfo->IOTAction = 0;\r\npHTInfo->IOTRaFunc = 0;\r\n}\r\n}\r\nvoid HT_update_self_and_peer_setting(struct rtllib_device *ieee,\r\nstruct rtllib_network *pNetwork)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nstruct ht_info_ele *pPeerHTInfo =\r\n(struct ht_info_ele *)pNetwork->bssht.bdHTInfoBuf;\r\nif (pHTInfo->bCurrentHTSupport) {\r\nif (pNetwork->bssht.bdHTInfoLen != 0)\r\npHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\r\n}\r\n}\r\nvoid HTUseDefaultSetting(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nif (pHTInfo->bEnableHT) {\r\npHTInfo->bCurrentHTSupport = true;\r\npHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK;\r\npHTInfo->bCurBW40MHz = pHTInfo->bRegBW40MHz;\r\npHTInfo->bCurShortGI20MHz = pHTInfo->bRegShortGI20MHz;\r\npHTInfo->bCurShortGI40MHz = pHTInfo->bRegShortGI40MHz;\r\nif (ieee->iw_mode == IW_MODE_ADHOC)\r\nieee->current_network.qos_data.active =\r\nieee->current_network.qos_data.supported;\r\npHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\npHTInfo->CurrentMPDUDensity = pHTInfo->CurrentMPDUDensity;\r\nHTFilterMCSRate(ieee, ieee->Regdot11TxHTOperationalRateSet,\r\nieee->dot11HTOperationalRateSet);\r\nieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee,\r\nieee->dot11HTOperationalRateSet,\r\nMCS_FILTER_ALL);\r\nieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\r\n} else {\r\npHTInfo->bCurrentHTSupport = false;\r\n}\r\n}\r\nu8 HTCCheck(struct rtllib_device *ieee, u8 *pFrame)\r\n{\r\nif (ieee->pHTInfo->bCurrentHTSupport) {\r\nif ((IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1) {\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "HT CONTROL FILED "\r\n"EXIST!!\n");\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void HTSetConnectBwModeCallback(struct rtllib_device *ieee)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nRTLLIB_DEBUG(RTLLIB_DL_HT, "======>%s()\n", __func__);\r\nif (pHTInfo->bCurBW40MHz) {\r\nif (pHTInfo->CurSTAExtChnlOffset == HT_EXTCHNL_OFFSET_UPPER)\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel + 2);\r\nelse if (pHTInfo->CurSTAExtChnlOffset ==\r\nHT_EXTCHNL_OFFSET_LOWER)\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel - 2);\r\nelse\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel);\r\nieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20_40,\r\npHTInfo->CurSTAExtChnlOffset);\r\n} else {\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->SetBWModeHandler(ieee->dev, HT_CHANNEL_WIDTH_20,\r\nHT_EXTCHNL_OFFSET_NO_EXT);\r\n}\r\npHTInfo->bSwBwInProgress = false;\r\n}\r\nvoid HTSetConnectBwMode(struct rtllib_device *ieee,\r\nenum ht_channel_width Bandwidth,\r\nenum ht_extchnl_offset Offset)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nif (pHTInfo->bRegBW40MHz == false)\r\nreturn;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))\r\nBandwidth = HT_CHANNEL_WIDTH_20;\r\nif (pHTInfo->bSwBwInProgress) {\r\npr_info("%s: bSwBwInProgress!!\n", __func__);\r\nreturn;\r\n}\r\nif (Bandwidth == HT_CHANNEL_WIDTH_20_40) {\r\nif (ieee->current_network.channel < 2 &&\r\nOffset == HT_EXTCHNL_OFFSET_LOWER)\r\nOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\nif (Offset == HT_EXTCHNL_OFFSET_UPPER ||\r\nOffset == HT_EXTCHNL_OFFSET_LOWER) {\r\npHTInfo->bCurBW40MHz = true;\r\npHTInfo->CurSTAExtChnlOffset = Offset;\r\n} else {\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\n}\r\n} else {\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\n}\r\npr_info("%s():pHTInfo->bCurBW40MHz:%x\n", __func__,\r\npHTInfo->bCurBW40MHz);\r\npHTInfo->bSwBwInProgress = true;\r\nHTSetConnectBwModeCallback(ieee);\r\n}
