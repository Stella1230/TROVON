static void pmu_backlight_init_curve(u8 off, u8 min, u8 max)\r\n{\r\nint i, flat, count, range = (max - min);\r\nbl_curve[0] = off;\r\nfor (flat = 1; flat < (FB_BACKLIGHT_LEVELS / 16); ++flat)\r\nbl_curve[flat] = min;\r\ncount = FB_BACKLIGHT_LEVELS * 15 / 16;\r\nfor (i = 0; i < count; ++i)\r\nbl_curve[flat + i] = min + (range * (i + 1) / count);\r\n}\r\nstatic int pmu_backlight_curve_lookup(int value)\r\n{\r\nint level = (FB_BACKLIGHT_LEVELS - 1);\r\nint i, max = 0;\r\nfor (i = 0; i < FB_BACKLIGHT_LEVELS; i++)\r\nmax = max((int)bl_curve[i], max);\r\nfor (i = 0; i < FB_BACKLIGHT_LEVELS; i++) {\r\nint diff = abs(bl_curve[i] - value);\r\nif (diff < max) {\r\nmax = diff;\r\nlevel = i;\r\n}\r\n}\r\nreturn level;\r\n}\r\nstatic int pmu_backlight_get_level_brightness(int level)\r\n{\r\nint pmulevel;\r\npmulevel = bl_curve[level] * FB_BACKLIGHT_MAX / MAX_PMU_LEVEL;\r\nif (pmulevel < 0)\r\npmulevel = 0;\r\nelse if (pmulevel > MAX_PMU_LEVEL)\r\npmulevel = MAX_PMU_LEVEL;\r\nreturn pmulevel;\r\n}\r\nstatic int __pmu_backlight_update_status(struct backlight_device *bd)\r\n{\r\nstruct adb_request req;\r\nint level = bd->props.brightness;\r\nif (bd->props.power != FB_BLANK_UNBLANK ||\r\nbd->props.fb_blank != FB_BLANK_UNBLANK)\r\nlevel = 0;\r\nif (level > 0) {\r\nint pmulevel = pmu_backlight_get_level_brightness(level);\r\npmu_request(&req, NULL, 2, PMU_BACKLIGHT_BRIGHT, pmulevel);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_BACKLIGHT | PMU_POW_ON);\r\npmu_wait_complete(&req);\r\n} else {\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_BACKLIGHT | PMU_POW_OFF);\r\npmu_wait_complete(&req);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmu_backlight_update_status(struct backlight_device *bd)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&pmu_backlight_lock, flags);\r\nif (!sleeping)\r\nrc = __pmu_backlight_update_status(bd);\r\nspin_unlock_irqrestore(&pmu_backlight_lock, flags);\r\nreturn rc;\r\n}\r\nvoid pmu_backlight_set_sleep(int sleep)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pmu_backlight_lock, flags);\r\nsleeping = sleep;\r\nif (pmac_backlight && uses_pmu_bl) {\r\nif (sleep) {\r\nstruct adb_request req;\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_BACKLIGHT | PMU_POW_OFF);\r\npmu_wait_complete(&req);\r\n} else\r\n__pmu_backlight_update_status(pmac_backlight);\r\n}\r\nspin_unlock_irqrestore(&pmu_backlight_lock, flags);\r\n}\r\nvoid __init pmu_backlight_init()\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nchar name[10];\r\nint level, autosave;\r\nautosave =\r\nof_machine_is_compatible("AAPL,3400/2400") ||\r\nof_machine_is_compatible("AAPL,3500");\r\nif (!autosave &&\r\n!pmac_has_backlight_type("pmu") &&\r\n!of_machine_is_compatible("AAPL,PowerBook1998") &&\r\n!of_machine_is_compatible("PowerBook1,1"))\r\nreturn;\r\nsnprintf(name, sizeof(name), "pmubl");\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\r\nbd = backlight_device_register(name, NULL, NULL, &pmu_backlight_data,\r\n&props);\r\nif (IS_ERR(bd)) {\r\nprintk(KERN_ERR "PMU Backlight registration failed\n");\r\nreturn;\r\n}\r\nuses_pmu_bl = 1;\r\npmu_backlight_init_curve(0x7F, 0x46, 0x0E);\r\nlevel = bd->props.max_brightness;\r\nif (autosave) {\r\nstruct adb_request req;\r\npmu_request(&req, NULL, 2, 0xd9, 0);\r\npmu_wait_complete(&req);\r\nlevel = pmu_backlight_curve_lookup(\r\n(req.reply[0] >> 4) *\r\nbd->props.max_brightness / 15);\r\n}\r\nbd->props.brightness = level;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nprintk(KERN_INFO "PMU Backlight initialized (%s)\n", name);\r\n}
