static struct fscache_object *cachefiles_alloc_object(\r\nstruct fscache_cache *_cache,\r\nstruct fscache_cookie *cookie)\r\n{\r\nstruct cachefiles_lookup_data *lookup_data;\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nstruct cachefiles_xattr *auxdata;\r\nunsigned keylen, auxlen;\r\nvoid *buffer;\r\nchar *key;\r\ncache = container_of(_cache, struct cachefiles_cache, cache);\r\n_enter("{%s},%p,", cache->cache.identifier, cookie);\r\nlookup_data = kmalloc(sizeof(*lookup_data), cachefiles_gfp);\r\nif (!lookup_data)\r\ngoto nomem_lookup_data;\r\nobject = kmem_cache_alloc(cachefiles_object_jar, cachefiles_gfp);\r\nif (!object)\r\ngoto nomem_object;\r\nASSERTCMP(object->backer, ==, NULL);\r\nBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\r\natomic_set(&object->usage, 1);\r\nfscache_object_init(&object->fscache, cookie, &cache->cache);\r\nobject->type = cookie->def->type;\r\nbuffer = kmalloc((2 + 512) + 3, cachefiles_gfp);\r\nif (!buffer)\r\ngoto nomem_buffer;\r\nkeylen = cookie->def->get_key(cookie->netfs_data, buffer + 2, 512);\r\nASSERTCMP(keylen, <, 512);\r\n*(uint16_t *)buffer = keylen;\r\n((char *)buffer)[keylen + 2] = 0;\r\n((char *)buffer)[keylen + 3] = 0;\r\n((char *)buffer)[keylen + 4] = 0;\r\nkey = cachefiles_cook_key(buffer, keylen + 2, object->type);\r\nif (!key)\r\ngoto nomem_key;\r\nauxdata = buffer;\r\nauxlen = 0;\r\nif (cookie->def->get_aux) {\r\nauxlen = cookie->def->get_aux(cookie->netfs_data,\r\nauxdata->data, 511);\r\nASSERTCMP(auxlen, <, 511);\r\n}\r\nauxdata->len = auxlen + 1;\r\nauxdata->type = cookie->def->type;\r\nlookup_data->auxdata = auxdata;\r\nlookup_data->key = key;\r\nobject->lookup_data = lookup_data;\r\n_leave(" = %p [%p]", &object->fscache, lookup_data);\r\nreturn &object->fscache;\r\nnomem_key:\r\nkfree(buffer);\r\nnomem_buffer:\r\nBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\r\nkmem_cache_free(cachefiles_object_jar, object);\r\nfscache_object_destroyed(&cache->cache);\r\nnomem_object:\r\nkfree(lookup_data);\r\nnomem_lookup_data:\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic int cachefiles_lookup_object(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_lookup_data *lookup_data;\r\nstruct cachefiles_object *parent, *object;\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nint ret;\r\n_enter("{OBJ%x}", _object->debug_id);\r\ncache = container_of(_object->cache, struct cachefiles_cache, cache);\r\nparent = container_of(_object->parent,\r\nstruct cachefiles_object, fscache);\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\nlookup_data = object->lookup_data;\r\nASSERTCMP(lookup_data, !=, NULL);\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = cachefiles_walk_to_object(parent, object,\r\nlookup_data->key,\r\nlookup_data->auxdata);\r\ncachefiles_end_secure(cache, saved_cred);\r\nif (ret == 0 &&\r\nobject->fscache.cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX)\r\ncachefiles_attr_changed(&object->fscache);\r\nif (ret < 0 && ret != -ETIMEDOUT) {\r\nif (ret != -ENOBUFS)\r\npr_warn("Lookup failed error %d\n", ret);\r\nfscache_object_lookup_error(&object->fscache);\r\n}\r\n_leave(" [%d]", ret);\r\nreturn ret;\r\n}\r\nstatic void cachefiles_lookup_complete(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object;\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\n_enter("{OBJ%x,%p}", object->fscache.debug_id, object->lookup_data);\r\nif (object->lookup_data) {\r\nkfree(object->lookup_data->key);\r\nkfree(object->lookup_data->auxdata);\r\nkfree(object->lookup_data);\r\nobject->lookup_data = NULL;\r\n}\r\n}\r\nstatic\r\nstruct fscache_object *cachefiles_grab_object(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object =\r\ncontainer_of(_object, struct cachefiles_object, fscache);\r\n_enter("{OBJ%x,%d}", _object->debug_id, atomic_read(&object->usage));\r\n#ifdef CACHEFILES_DEBUG_SLAB\r\nASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\r\n#endif\r\natomic_inc(&object->usage);\r\nreturn &object->fscache;\r\n}\r\nstatic void cachefiles_update_object(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_xattr *auxdata;\r\nstruct cachefiles_cache *cache;\r\nstruct fscache_cookie *cookie;\r\nconst struct cred *saved_cred;\r\nunsigned auxlen;\r\n_enter("{OBJ%x}", _object->debug_id);\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache, struct cachefiles_cache,\r\ncache);\r\nif (!fscache_use_cookie(_object)) {\r\n_leave(" [relinq]");\r\nreturn;\r\n}\r\ncookie = object->fscache.cookie;\r\nif (!cookie->def->get_aux) {\r\nfscache_unuse_cookie(_object);\r\n_leave(" [no aux]");\r\nreturn;\r\n}\r\nauxdata = kmalloc(2 + 512 + 3, cachefiles_gfp);\r\nif (!auxdata) {\r\nfscache_unuse_cookie(_object);\r\n_leave(" [nomem]");\r\nreturn;\r\n}\r\nauxlen = cookie->def->get_aux(cookie->netfs_data, auxdata->data, 511);\r\nfscache_unuse_cookie(_object);\r\nASSERTCMP(auxlen, <, 511);\r\nauxdata->len = auxlen + 1;\r\nauxdata->type = cookie->def->type;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\ncachefiles_update_object_xattr(object, auxdata);\r\ncachefiles_end_secure(cache, saved_cred);\r\nkfree(auxdata);\r\n_leave("");\r\n}\r\nstatic void cachefiles_drop_object(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nASSERT(_object);\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\n_enter("{OBJ%x,%d}",\r\nobject->fscache.debug_id, atomic_read(&object->usage));\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n#ifdef CACHEFILES_DEBUG_SLAB\r\nASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\r\n#endif\r\nif (object->dentry) {\r\nif (test_bit(FSCACHE_OBJECT_RETIRED, &object->fscache.flags) &&\r\n_object != cache->cache.fsdef\r\n) {\r\n_debug("- retire object OBJ%x", object->fscache.debug_id);\r\ncachefiles_begin_secure(cache, &saved_cred);\r\ncachefiles_delete_object(cache, object);\r\ncachefiles_end_secure(cache, saved_cred);\r\n}\r\nif (object->backer != object->dentry)\r\ndput(object->backer);\r\nobject->backer = NULL;\r\n}\r\nif (test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\r\nwrite_lock(&cache->active_lock);\r\nif (!test_and_clear_bit(CACHEFILES_OBJECT_ACTIVE,\r\n&object->flags))\r\nBUG();\r\nrb_erase(&object->active_node, &cache->active_nodes);\r\nwake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\r\nwrite_unlock(&cache->active_lock);\r\n}\r\ndput(object->dentry);\r\nobject->dentry = NULL;\r\n_leave("");\r\n}\r\nstatic void cachefiles_put_object(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct fscache_cache *cache;\r\nASSERT(_object);\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\n_enter("{OBJ%x,%d}",\r\nobject->fscache.debug_id, atomic_read(&object->usage));\r\n#ifdef CACHEFILES_DEBUG_SLAB\r\nASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\r\n#endif\r\nASSERTIFCMP(object->fscache.parent,\r\nobject->fscache.parent->n_children, >, 0);\r\nif (atomic_dec_and_test(&object->usage)) {\r\n_debug("- kill object OBJ%x", object->fscache.debug_id);\r\nASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\r\nASSERTCMP(object->fscache.parent, ==, NULL);\r\nASSERTCMP(object->backer, ==, NULL);\r\nASSERTCMP(object->dentry, ==, NULL);\r\nASSERTCMP(object->fscache.n_ops, ==, 0);\r\nASSERTCMP(object->fscache.n_children, ==, 0);\r\nif (object->lookup_data) {\r\nkfree(object->lookup_data->key);\r\nkfree(object->lookup_data->auxdata);\r\nkfree(object->lookup_data);\r\nobject->lookup_data = NULL;\r\n}\r\ncache = object->fscache.cache;\r\nfscache_object_destroy(&object->fscache);\r\nkmem_cache_free(cachefiles_object_jar, object);\r\nfscache_object_destroyed(cache);\r\n}\r\n_leave("");\r\n}\r\nstatic void cachefiles_sync_cache(struct fscache_cache *_cache)\r\n{\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nint ret;\r\n_enter("%p", _cache);\r\ncache = container_of(_cache, struct cachefiles_cache, cache);\r\ncachefiles_begin_secure(cache, &saved_cred);\r\ndown_read(&cache->mnt->mnt_sb->s_umount);\r\nret = sync_filesystem(cache->mnt->mnt_sb);\r\nup_read(&cache->mnt->mnt_sb->s_umount);\r\ncachefiles_end_secure(cache, saved_cred);\r\nif (ret == -EIO)\r\ncachefiles_io_error(cache,\r\n"Attempt to sync backing fs superblock"\r\n" returned error %d",\r\nret);\r\n}\r\nstatic bool cachefiles_check_consistency(struct fscache_operation *op)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nint ret;\r\n_enter("{OBJ%x}", op->object->debug_id);\r\nobject = container_of(op->object, struct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = cachefiles_check_auxdata(object);\r\ncachefiles_end_secure(cache, saved_cred);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int cachefiles_attr_changed(struct fscache_object *_object)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nstruct iattr newattrs;\r\nuint64_t ni_size;\r\nloff_t oi_size;\r\nint ret;\r\n_object->cookie->def->get_attr(_object->cookie->netfs_data, &ni_size);\r\n_enter("{OBJ%x},[%llu]",\r\n_object->debug_id, (unsigned long long) ni_size);\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\nif (ni_size == object->i_size)\r\nreturn 0;\r\nif (!object->backer)\r\nreturn -ENOBUFS;\r\nASSERT(S_ISREG(object->backer->d_inode->i_mode));\r\nfscache_set_store_limit(&object->fscache, ni_size);\r\noi_size = i_size_read(object->backer->d_inode);\r\nif (oi_size == ni_size)\r\nreturn 0;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nmutex_lock(&object->backer->d_inode->i_mutex);\r\nif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\r\n_debug("discard tail %llx", oi_size);\r\nnewattrs.ia_valid = ATTR_SIZE;\r\nnewattrs.ia_size = oi_size & PAGE_MASK;\r\nret = notify_change(object->backer, &newattrs, NULL);\r\nif (ret < 0)\r\ngoto truncate_failed;\r\n}\r\nnewattrs.ia_valid = ATTR_SIZE;\r\nnewattrs.ia_size = ni_size;\r\nret = notify_change(object->backer, &newattrs, NULL);\r\ntruncate_failed:\r\nmutex_unlock(&object->backer->d_inode->i_mutex);\r\ncachefiles_end_secure(cache, saved_cred);\r\nif (ret == -EIO) {\r\nfscache_set_store_limit(&object->fscache, 0);\r\ncachefiles_io_error_obj(object, "Size set failed");\r\nret = -ENOBUFS;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void cachefiles_invalidate_object(struct fscache_operation *op)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nconst struct cred *saved_cred;\r\nstruct path path;\r\nuint64_t ni_size;\r\nint ret;\r\nobject = container_of(op->object, struct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\nop->object->cookie->def->get_attr(op->object->cookie->netfs_data,\r\n&ni_size);\r\n_enter("{OBJ%x},[%llu]",\r\nop->object->debug_id, (unsigned long long)ni_size);\r\nif (object->backer) {\r\nASSERT(S_ISREG(object->backer->d_inode->i_mode));\r\nfscache_set_store_limit(&object->fscache, ni_size);\r\npath.dentry = object->backer;\r\npath.mnt = cache->mnt;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = vfs_truncate(&path, 0);\r\nif (ret == 0)\r\nret = vfs_truncate(&path, ni_size);\r\ncachefiles_end_secure(cache, saved_cred);\r\nif (ret != 0) {\r\nfscache_set_store_limit(&object->fscache, 0);\r\nif (ret == -EIO)\r\ncachefiles_io_error_obj(object,\r\n"Invalidate failed");\r\n}\r\n}\r\nfscache_op_complete(op, true);\r\n_leave("");\r\n}\r\nstatic void cachefiles_dissociate_pages(struct fscache_cache *cache)\r\n{\r\n_enter("");\r\n}
