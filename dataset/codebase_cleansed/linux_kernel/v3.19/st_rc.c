static void st_rc_send_lirc_timeout(struct rc_dev *rdev)\r\n{\r\nDEFINE_IR_RAW_EVENT(ev);\r\nev.timeout = true;\r\nir_raw_event_store(rdev, &ev);\r\n}\r\nstatic irqreturn_t st_rc_rx_interrupt(int irq, void *data)\r\n{\r\nunsigned int symbol, mark = 0;\r\nstruct st_rc_device *dev = data;\r\nint last_symbol = 0;\r\nu32 status;\r\nDEFINE_IR_RAW_EVENT(ev);\r\nif (dev->irq_wake)\r\npm_wakeup_event(dev->dev, 0);\r\nstatus = readl(dev->rx_base + IRB_RX_STATUS);\r\nwhile (status & (IRB_FIFO_NOT_EMPTY | IRB_OVERFLOW)) {\r\nu32 int_status = readl(dev->rx_base + IRB_RX_INT_STATUS);\r\nif (unlikely(int_status & IRB_RX_OVERRUN_INT)) {\r\nir_raw_event_reset(dev->rdev);\r\ndev_info(dev->dev, "IR RX overrun\n");\r\nwritel(IRB_RX_OVERRUN_INT,\r\ndev->rx_base + IRB_RX_INT_CLEAR);\r\ncontinue;\r\n}\r\nsymbol = readl(dev->rx_base + IRB_RX_SYS);\r\nmark = readl(dev->rx_base + IRB_RX_ON);\r\nif (symbol == IRB_TIMEOUT)\r\nlast_symbol = 1;\r\nif ((mark > 2) && (symbol > 1)) {\r\nsymbol -= mark;\r\nif (dev->overclocking) {\r\nsymbol *= dev->sample_mult;\r\nsymbol /= dev->sample_div;\r\nmark *= dev->sample_mult;\r\nmark /= dev->sample_div;\r\n}\r\nev.duration = US_TO_NS(mark);\r\nev.pulse = true;\r\nir_raw_event_store(dev->rdev, &ev);\r\nif (!last_symbol) {\r\nev.duration = US_TO_NS(symbol);\r\nev.pulse = false;\r\nir_raw_event_store(dev->rdev, &ev);\r\n} else {\r\nst_rc_send_lirc_timeout(dev->rdev);\r\n}\r\n}\r\nlast_symbol = 0;\r\nstatus = readl(dev->rx_base + IRB_RX_STATUS);\r\n}\r\nwritel(IRB_RX_INTS, dev->rx_base + IRB_RX_INT_CLEAR);\r\nir_raw_event_handle(dev->rdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void st_rc_hardware_init(struct st_rc_device *dev)\r\n{\r\nint baseclock, freqdiff;\r\nunsigned int rx_max_symbol_per = MAX_SYMB_TIME;\r\nunsigned int rx_sampling_freq_div;\r\nif (dev->rstc)\r\nreset_control_deassert(dev->rstc);\r\nclk_prepare_enable(dev->sys_clock);\r\nbaseclock = clk_get_rate(dev->sys_clock);\r\nwritel(1, dev->rx_base + IRB_RX_POLARITY_INV);\r\nrx_sampling_freq_div = baseclock / IRB_SAMPLE_FREQ;\r\nwritel(rx_sampling_freq_div, dev->base + IRB_SAMPLE_RATE_COMM);\r\nfreqdiff = baseclock - (rx_sampling_freq_div * IRB_SAMPLE_FREQ);\r\nif (freqdiff) {\r\ndev->overclocking = true;\r\ndev->sample_mult = 1000;\r\ndev->sample_div = baseclock / (10000 * rx_sampling_freq_div);\r\nrx_max_symbol_per = (rx_max_symbol_per * 1000)/dev->sample_div;\r\n}\r\nwritel(rx_max_symbol_per, dev->rx_base + IRB_MAX_SYM_PERIOD);\r\n}\r\nstatic int st_rc_remove(struct platform_device *pdev)\r\n{\r\nstruct st_rc_device *rc_dev = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(rc_dev->sys_clock);\r\nrc_unregister_device(rc_dev->rdev);\r\nreturn 0;\r\n}\r\nstatic int st_rc_open(struct rc_dev *rdev)\r\n{\r\nstruct st_rc_device *dev = rdev->priv;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwritel(IRB_RX_INTS, dev->rx_base + IRB_RX_INT_EN);\r\nwritel(0x01, dev->rx_base + IRB_RX_EN);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void st_rc_close(struct rc_dev *rdev)\r\n{\r\nstruct st_rc_device *dev = rdev->priv;\r\nwritel(0x00, dev->rx_base + IRB_RX_EN);\r\nwritel(0x00, dev->rx_base + IRB_RX_INT_EN);\r\n}\r\nstatic int st_rc_probe(struct platform_device *pdev)\r\n{\r\nint ret = -EINVAL;\r\nstruct rc_dev *rdev;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct st_rc_device *rc_dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst char *rx_mode;\r\nrc_dev = devm_kzalloc(dev, sizeof(struct st_rc_device), GFP_KERNEL);\r\nif (!rc_dev)\r\nreturn -ENOMEM;\r\nrdev = rc_allocate_device();\r\nif (!rdev)\r\nreturn -ENOMEM;\r\nif (np && !of_property_read_string(np, "rx-mode", &rx_mode)) {\r\nif (!strcmp(rx_mode, "uhf")) {\r\nrc_dev->rxuhfmode = true;\r\n} else if (!strcmp(rx_mode, "infrared")) {\r\nrc_dev->rxuhfmode = false;\r\n} else {\r\ndev_err(dev, "Unsupported rx mode [%s]\n", rx_mode);\r\ngoto err;\r\n}\r\n} else {\r\ngoto err;\r\n}\r\nrc_dev->sys_clock = devm_clk_get(dev, NULL);\r\nif (IS_ERR(rc_dev->sys_clock)) {\r\ndev_err(dev, "System clock not found\n");\r\nret = PTR_ERR(rc_dev->sys_clock);\r\ngoto err;\r\n}\r\nrc_dev->irq = platform_get_irq(pdev, 0);\r\nif (rc_dev->irq < 0) {\r\nret = rc_dev->irq;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrc_dev->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR((__force void *)rc_dev->base)) {\r\nret = PTR_ERR((__force void *)rc_dev->base);\r\ngoto err;\r\n}\r\nif (rc_dev->rxuhfmode)\r\nrc_dev->rx_base = rc_dev->base + 0x40;\r\nelse\r\nrc_dev->rx_base = rc_dev->base;\r\nrc_dev->rstc = reset_control_get_optional(dev, NULL);\r\nif (IS_ERR(rc_dev->rstc))\r\nrc_dev->rstc = NULL;\r\nrc_dev->dev = dev;\r\nplatform_set_drvdata(pdev, rc_dev);\r\nst_rc_hardware_init(rc_dev);\r\nrdev->driver_type = RC_DRIVER_IR_RAW;\r\nrdev->allowed_protocols = RC_BIT_ALL;\r\nrdev->rx_resolution = 100;\r\nrdev->timeout = US_TO_NS(MAX_SYMB_TIME);\r\nrdev->priv = rc_dev;\r\nrdev->open = st_rc_open;\r\nrdev->close = st_rc_close;\r\nrdev->driver_name = IR_ST_NAME;\r\nrdev->map_name = RC_MAP_LIRC;\r\nrdev->input_name = "ST Remote Control Receiver";\r\ndevice_set_wakeup_capable(dev, true);\r\ndevice_set_wakeup_enable(dev, true);\r\nret = rc_register_device(rdev);\r\nif (ret < 0)\r\ngoto clkerr;\r\nrc_dev->rdev = rdev;\r\nif (devm_request_irq(dev, rc_dev->irq, st_rc_rx_interrupt,\r\nIRQF_NO_SUSPEND, IR_ST_NAME, rc_dev) < 0) {\r\ndev_err(dev, "IRQ %d register failed\n", rc_dev->irq);\r\nret = -EINVAL;\r\ngoto rcerr;\r\n}\r\nst_rc_send_lirc_timeout(rdev);\r\ndev_info(dev, "setup in %s mode\n", rc_dev->rxuhfmode ? "UHF" : "IR");\r\nreturn ret;\r\nrcerr:\r\nrc_unregister_device(rdev);\r\nrdev = NULL;\r\nclkerr:\r\nclk_disable_unprepare(rc_dev->sys_clock);\r\nerr:\r\nrc_free_device(rdev);\r\ndev_err(dev, "Unable to register device (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int st_rc_suspend(struct device *dev)\r\n{\r\nstruct st_rc_device *rc_dev = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev)) {\r\nif (!enable_irq_wake(rc_dev->irq))\r\nrc_dev->irq_wake = 1;\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\npinctrl_pm_select_sleep_state(dev);\r\nwritel(0x00, rc_dev->rx_base + IRB_RX_EN);\r\nwritel(0x00, rc_dev->rx_base + IRB_RX_INT_EN);\r\nclk_disable_unprepare(rc_dev->sys_clock);\r\nif (rc_dev->rstc)\r\nreset_control_assert(rc_dev->rstc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_rc_resume(struct device *dev)\r\n{\r\nstruct st_rc_device *rc_dev = dev_get_drvdata(dev);\r\nstruct rc_dev *rdev = rc_dev->rdev;\r\nif (rc_dev->irq_wake) {\r\ndisable_irq_wake(rc_dev->irq);\r\nrc_dev->irq_wake = 0;\r\n} else {\r\npinctrl_pm_select_default_state(dev);\r\nst_rc_hardware_init(rc_dev);\r\nif (rdev->users) {\r\nwritel(IRB_RX_INTS, rc_dev->rx_base + IRB_RX_INT_EN);\r\nwritel(0x01, rc_dev->rx_base + IRB_RX_EN);\r\n}\r\n}\r\nreturn 0;\r\n}
