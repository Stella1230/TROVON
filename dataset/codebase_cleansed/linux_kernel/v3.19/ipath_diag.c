int ipath_diag_add(struct ipath_devdata *dd)\r\n{\r\nchar name[16];\r\nint ret = 0;\r\nif (atomic_inc_return(&diagpkt_count) == 1) {\r\nret = ipath_cdev_init(IPATH_DIAGPKT_MINOR,\r\n"ipath_diagpkt", &diagpkt_file_ops,\r\n&diagpkt_cdev, &diagpkt_dev);\r\nif (ret) {\r\nipath_dev_err(dd, "Couldn't create ipath_diagpkt "\r\n"device: %d", ret);\r\ngoto done;\r\n}\r\n}\r\nsnprintf(name, sizeof(name), "ipath_diag%d", dd->ipath_unit);\r\nret = ipath_cdev_init(IPATH_DIAG_MINOR_BASE + dd->ipath_unit, name,\r\n&diag_file_ops, &dd->diag_cdev,\r\n&dd->diag_dev);\r\nif (ret)\r\nipath_dev_err(dd, "Couldn't create %s device: %d",\r\nname, ret);\r\ndone:\r\nreturn ret;\r\n}\r\nvoid ipath_diag_remove(struct ipath_devdata *dd)\r\n{\r\nif (atomic_dec_and_test(&diagpkt_count))\r\nipath_cdev_cleanup(&diagpkt_cdev, &diagpkt_dev);\r\nipath_cdev_cleanup(&dd->diag_cdev, &dd->diag_dev);\r\n}\r\nstatic int ipath_read_umem64(struct ipath_devdata *dd, void __user *uaddr,\r\nconst void __iomem *caddr, size_t count)\r\n{\r\nconst u64 __iomem *reg_addr = caddr;\r\nconst u64 __iomem *reg_end = reg_addr + (count / sizeof(u64));\r\nint ret;\r\nif (reg_addr < dd->ipath_kregbase || reg_end > dd->ipath_kregend) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nwhile (reg_addr < reg_end) {\r\nu64 data = readq(reg_addr);\r\nif (copy_to_user(uaddr, &data, sizeof(u64))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nreg_addr++;\r\nuaddr += sizeof(u64);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ipath_write_umem64(struct ipath_devdata *dd, void __iomem *caddr,\r\nconst void __user *uaddr, size_t count)\r\n{\r\nu64 __iomem *reg_addr = caddr;\r\nconst u64 __iomem *reg_end = reg_addr + (count / sizeof(u64));\r\nint ret;\r\nif (reg_addr < dd->ipath_kregbase || reg_end > dd->ipath_kregend) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nwhile (reg_addr < reg_end) {\r\nu64 data;\r\nif (copy_from_user(&data, uaddr, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nwriteq(data, reg_addr);\r\nreg_addr++;\r\nuaddr += sizeof(u64);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ipath_read_umem32(struct ipath_devdata *dd, void __user *uaddr,\r\nconst void __iomem *caddr, size_t count)\r\n{\r\nconst u32 __iomem *reg_addr = caddr;\r\nconst u32 __iomem *reg_end = reg_addr + (count / sizeof(u32));\r\nint ret;\r\nif (reg_addr < (u32 __iomem *) dd->ipath_kregbase ||\r\nreg_end > (u32 __iomem *) dd->ipath_kregend) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nwhile (reg_addr < reg_end) {\r\nu32 data = readl(reg_addr);\r\nif (copy_to_user(uaddr, &data, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nreg_addr++;\r\nuaddr += sizeof(u32);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ipath_write_umem32(struct ipath_devdata *dd, void __iomem *caddr,\r\nconst void __user *uaddr, size_t count)\r\n{\r\nu32 __iomem *reg_addr = caddr;\r\nconst u32 __iomem *reg_end = reg_addr + (count / sizeof(u32));\r\nint ret;\r\nif (reg_addr < (u32 __iomem *) dd->ipath_kregbase ||\r\nreg_end > (u32 __iomem *) dd->ipath_kregend) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nwhile (reg_addr < reg_end) {\r\nu32 data;\r\nif (copy_from_user(&data, uaddr, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nwritel(data, reg_addr);\r\nreg_addr++;\r\nuaddr += sizeof(u32);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ipath_diag_open(struct inode *in, struct file *fp)\r\n{\r\nint unit = iminor(in) - IPATH_DIAG_MINOR_BASE;\r\nstruct ipath_devdata *dd;\r\nint ret;\r\nmutex_lock(&ipath_mutex);\r\nif (ipath_diag_inuse) {\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\ndd = ipath_lookup(unit);\r\nif (dd == NULL || !(dd->ipath_flags & IPATH_PRESENT) ||\r\n!dd->ipath_kregbase) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nfp->private_data = dd;\r\nipath_diag_inuse = -2;\r\ndiag_set_link = 0;\r\nret = 0;\r\nipath_expose_reset(&dd->pcidev->dev);\r\nbail:\r\nmutex_unlock(&ipath_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ipath_diagpkt_write(struct file *fp,\r\nconst char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nu32 __iomem *piobuf;\r\nu32 plen, pbufn, maxlen_reserve;\r\nstruct ipath_diag_pkt odp;\r\nstruct ipath_diag_xpkt dp;\r\nu32 *tmpbuf = NULL;\r\nstruct ipath_devdata *dd;\r\nssize_t ret = 0;\r\nu64 val;\r\nu32 l_state, lt_state;\r\nif (count == sizeof(dp)) {\r\nif (copy_from_user(&dp, data, sizeof(dp))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\n} else if (count == sizeof(odp)) {\r\nif (copy_from_user(&odp, data, sizeof(odp))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\ndp.len = odp.len;\r\ndp.unit = odp.unit;\r\ndp.data = odp.data;\r\ndp.pbc_wd = 0;\r\n} else {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (dp.len & 3) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nplen = dp.len >> 2;\r\ndd = ipath_lookup(dp.unit);\r\nif (!dd || !(dd->ipath_flags & IPATH_PRESENT) ||\r\n!dd->ipath_kregbase) {\r\nipath_cdbg(VERBOSE, "illegal unit %u for diag data send\n",\r\ndp.unit);\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nif (ipath_diag_inuse && !diag_set_link &&\r\n!(dd->ipath_flags & IPATH_LINKACTIVE)) {\r\ndiag_set_link = 1;\r\nipath_cdbg(VERBOSE, "Trying to set to set link active for "\r\n"diag pkt\n");\r\nipath_set_linkstate(dd, IPATH_IB_LINKARM);\r\nipath_set_linkstate(dd, IPATH_IB_LINKACTIVE);\r\n}\r\nif (!(dd->ipath_flags & IPATH_INITTED)) {\r\nipath_cdbg(VERBOSE, "unit %u not usable\n", dd->ipath_unit);\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nval = ipath_ib_state(dd, dd->ipath_lastibcstat);\r\nlt_state = ipath_ib_linktrstate(dd, dd->ipath_lastibcstat);\r\nl_state = ipath_ib_linkstate(dd, dd->ipath_lastibcstat);\r\nif (!dp.pbc_wd && (lt_state != INFINIPATH_IBCS_LT_STATE_LINKUP ||\r\n(val != dd->ib_init && val != dd->ib_arm &&\r\nval != dd->ib_active))) {\r\nipath_cdbg(VERBOSE, "unit %u not ready (state %llx)\n",\r\ndd->ipath_unit, (unsigned long long) val);\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nmaxlen_reserve = 2 * sizeof(u32);\r\nif (dp.len > dd->ipath_ibmaxlen - maxlen_reserve) {\r\nipath_dbg("Pkt len 0x%x > ibmaxlen %x\n",\r\ndp.len, dd->ipath_ibmaxlen);\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nplen = sizeof(u32) + dp.len;\r\ntmpbuf = vmalloc(plen);\r\nif (!tmpbuf) {\r\ndev_info(&dd->pcidev->dev, "Unable to allocate tmp buffer, "\r\n"failing\n");\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nif (copy_from_user(tmpbuf,\r\n(const void __user *) (unsigned long) dp.data,\r\ndp.len)) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nplen >>= 2;\r\npiobuf = ipath_getpiobuf(dd, plen, &pbufn);\r\nif (!piobuf) {\r\nipath_cdbg(VERBOSE, "No PIO buffers avail unit for %u\n",\r\ndd->ipath_unit);\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\nipath_disarm_piobufs(dd, pbufn, 1);\r\nif (ipath_debug & __IPATH_PKTDBG)\r\nipath_cdbg(VERBOSE, "unit %u 0x%x+1w pio%d\n",\r\ndd->ipath_unit, plen - 1, pbufn);\r\nif (dp.pbc_wd == 0)\r\ndp.pbc_wd = plen;\r\nwriteq(dp.pbc_wd, piobuf);\r\nif (dd->ipath_flags & IPATH_PIO_FLUSH_WC) {\r\nipath_flush_wc();\r\n__iowrite32_copy(piobuf + 2, tmpbuf, plen - 1);\r\nipath_flush_wc();\r\n__raw_writel(tmpbuf[plen - 1], piobuf + plen + 1);\r\n} else\r\n__iowrite32_copy(piobuf + 2, tmpbuf, plen);\r\nipath_flush_wc();\r\nret = sizeof(dp);\r\nbail:\r\nvfree(tmpbuf);\r\nreturn ret;\r\n}\r\nstatic int ipath_diag_release(struct inode *in, struct file *fp)\r\n{\r\nmutex_lock(&ipath_mutex);\r\nipath_diag_inuse = 0;\r\nfp->private_data = NULL;\r\nmutex_unlock(&ipath_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t ipath_diag_read(struct file *fp, char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ipath_devdata *dd = fp->private_data;\r\nvoid __iomem *kreg_base;\r\nssize_t ret;\r\nkreg_base = dd->ipath_kregbase;\r\nif (count == 0)\r\nret = 0;\r\nelse if ((count % 4) || (*off % 4))\r\nret = -EINVAL;\r\nelse if (ipath_diag_inuse < 1 && (*off || count != 8))\r\nret = -EINVAL;\r\nelse if ((count % 8) || (*off % 8))\r\nret = ipath_read_umem32(dd, data, kreg_base + *off, count);\r\nelse\r\nret = ipath_read_umem64(dd, data, kreg_base + *off, count);\r\nif (ret >= 0) {\r\n*off += count;\r\nret = count;\r\nif (ipath_diag_inuse == -2)\r\nipath_diag_inuse++;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t ipath_diag_write(struct file *fp, const char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ipath_devdata *dd = fp->private_data;\r\nvoid __iomem *kreg_base;\r\nssize_t ret;\r\nkreg_base = dd->ipath_kregbase;\r\nif (count == 0)\r\nret = 0;\r\nelse if ((count % 4) || (*off % 4))\r\nret = -EINVAL;\r\nelse if ((ipath_diag_inuse == -1 && (*off || count != 8)) ||\r\nipath_diag_inuse == -2)\r\nret = -EINVAL;\r\nelse if ((count % 8) || (*off % 8))\r\nret = ipath_write_umem32(dd, kreg_base + *off, data, count);\r\nelse\r\nret = ipath_write_umem64(dd, kreg_base + *off, data, count);\r\nif (ret >= 0) {\r\n*off += count;\r\nret = count;\r\nif (ipath_diag_inuse == -1)\r\nipath_diag_inuse = 1;\r\n}\r\nreturn ret;\r\n}
