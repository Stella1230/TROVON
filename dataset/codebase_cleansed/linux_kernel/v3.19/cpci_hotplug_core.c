static int\r\nupdate_latch_status(struct hotplug_slot *hotplug_slot, u8 value)\r\n{\r\nstruct hotplug_slot_info info;\r\nmemcpy(&info, hotplug_slot->info, sizeof(struct hotplug_slot_info));\r\ninfo.latch_status = value;\r\nreturn pci_hp_change_slot_info(hotplug_slot, &info);\r\n}\r\nstatic int\r\nupdate_adapter_status(struct hotplug_slot *hotplug_slot, u8 value)\r\n{\r\nstruct hotplug_slot_info info;\r\nmemcpy(&info, hotplug_slot->info, sizeof(struct hotplug_slot_info));\r\ninfo.adapter_status = value;\r\nreturn pci_hp_change_slot_info(hotplug_slot, &info);\r\n}\r\nstatic int\r\nenable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nint retval = 0;\r\ndbg("%s - physical_slot = %s", __func__, slot_name(slot));\r\nif (controller->ops->set_power)\r\nretval = controller->ops->set_power(slot, 1);\r\nreturn retval;\r\n}\r\nstatic int\r\ndisable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nint retval = 0;\r\ndbg("%s - physical_slot = %s", __func__, slot_name(slot));\r\ndown_write(&list_rwsem);\r\ndbg("%s - unconfiguring slot %s", __func__, slot_name(slot));\r\nretval = cpci_unconfigure_slot(slot);\r\nif (retval) {\r\nerr("%s - could not unconfigure slot %s",\r\n__func__, slot_name(slot));\r\ngoto disable_error;\r\n}\r\ndbg("%s - finished unconfiguring slot %s", __func__, slot_name(slot));\r\nif (cpci_clear_ext(slot)) {\r\nerr("%s - could not clear EXT for slot %s",\r\n__func__, slot_name(slot));\r\nretval = -ENODEV;\r\ngoto disable_error;\r\n}\r\ncpci_led_on(slot);\r\nif (controller->ops->set_power) {\r\nretval = controller->ops->set_power(slot, 0);\r\nif (retval)\r\ngoto disable_error;\r\n}\r\nif (update_adapter_status(slot->hotplug_slot, 0))\r\nwarn("failure to update adapter file");\r\nif (slot->extracting) {\r\nslot->extracting = 0;\r\natomic_dec(&extracting);\r\n}\r\ndisable_error:\r\nup_write(&list_rwsem);\r\nreturn retval;\r\n}\r\nstatic u8\r\ncpci_get_power_status(struct slot *slot)\r\n{\r\nu8 power = 1;\r\nif (controller->ops->get_power)\r\npower = controller->ops->get_power(slot);\r\nreturn power;\r\n}\r\nstatic int\r\nget_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\n*value = cpci_get_power_status(slot);\r\nreturn 0;\r\n}\r\nstatic int\r\nget_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\n*value = cpci_get_attention_status(slot);\r\nreturn 0;\r\n}\r\nstatic int\r\nset_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\r\n{\r\nreturn cpci_set_attention_status(hotplug_slot->private, status);\r\n}\r\nstatic int\r\nget_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\n*value = hotplug_slot->info->adapter_status;\r\nreturn 0;\r\n}\r\nstatic int\r\nget_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\n*value = hotplug_slot->info->latch_status;\r\nreturn 0;\r\n}\r\nstatic void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nkfree(slot->hotplug_slot->info);\r\nkfree(slot->hotplug_slot);\r\nif (slot->dev)\r\npci_dev_put(slot->dev);\r\nkfree(slot);\r\n}\r\nint\r\ncpci_hp_register_bus(struct pci_bus *bus, u8 first, u8 last)\r\n{\r\nstruct slot *slot;\r\nstruct hotplug_slot *hotplug_slot;\r\nstruct hotplug_slot_info *info;\r\nchar name[SLOT_NAME_SIZE];\r\nint status;\r\nint i;\r\nif (!(controller && bus))\r\nreturn -ENODEV;\r\nfor (i = first; i <= last; ++i) {\r\nslot = kzalloc(sizeof (struct slot), GFP_KERNEL);\r\nif (!slot) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\nhotplug_slot =\r\nkzalloc(sizeof (struct hotplug_slot), GFP_KERNEL);\r\nif (!hotplug_slot) {\r\nstatus = -ENOMEM;\r\ngoto error_slot;\r\n}\r\nslot->hotplug_slot = hotplug_slot;\r\ninfo = kzalloc(sizeof (struct hotplug_slot_info), GFP_KERNEL);\r\nif (!info) {\r\nstatus = -ENOMEM;\r\ngoto error_hpslot;\r\n}\r\nhotplug_slot->info = info;\r\nslot->bus = bus;\r\nslot->number = i;\r\nslot->devfn = PCI_DEVFN(i, 0);\r\nsnprintf(name, SLOT_NAME_SIZE, "%02x:%02x", bus->number, i);\r\nhotplug_slot->private = slot;\r\nhotplug_slot->release = &release_slot;\r\nhotplug_slot->ops = &cpci_hotplug_slot_ops;\r\ndbg("initializing slot %s", name);\r\ninfo->power_status = cpci_get_power_status(slot);\r\ninfo->attention_status = cpci_get_attention_status(slot);\r\ndbg("registering slot %s", name);\r\nstatus = pci_hp_register(slot->hotplug_slot, bus, i, name);\r\nif (status) {\r\nerr("pci_hp_register failed with error %d", status);\r\ngoto error_info;\r\n}\r\ndbg("slot registered with name: %s", slot_name(slot));\r\ndown_write(&list_rwsem);\r\nlist_add(&slot->slot_list, &slot_list);\r\nslots++;\r\nup_write(&list_rwsem);\r\n}\r\nreturn 0;\r\nerror_info:\r\nkfree(info);\r\nerror_hpslot:\r\nkfree(hotplug_slot);\r\nerror_slot:\r\nkfree(slot);\r\nerror:\r\nreturn status;\r\n}\r\nint\r\ncpci_hp_unregister_bus(struct pci_bus *bus)\r\n{\r\nstruct slot *slot;\r\nstruct slot *tmp;\r\nint status = 0;\r\ndown_write(&list_rwsem);\r\nif (!slots) {\r\nup_write(&list_rwsem);\r\nreturn -1;\r\n}\r\nlist_for_each_entry_safe(slot, tmp, &slot_list, slot_list) {\r\nif (slot->bus == bus) {\r\nlist_del(&slot->slot_list);\r\nslots--;\r\ndbg("deregistering slot %s", slot_name(slot));\r\nstatus = pci_hp_deregister(slot->hotplug_slot);\r\nif (status) {\r\nerr("pci_hp_deregister failed with error %d",\r\nstatus);\r\nbreak;\r\n}\r\n}\r\n}\r\nup_write(&list_rwsem);\r\nreturn status;\r\n}\r\nstatic irqreturn_t\r\ncpci_hp_intr(int irq, void *data)\r\n{\r\ndbg("entered cpci_hp_intr");\r\nif ((controller->irq_flags & IRQF_SHARED) &&\r\n!controller->ops->check_irq(controller->dev_id)) {\r\ndbg("exited cpci_hp_intr, not our interrupt");\r\nreturn IRQ_NONE;\r\n}\r\ncontroller->ops->disable_irq();\r\nwake_up_process(cpci_thread);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\ninit_slots(int clear_ins)\r\n{\r\nstruct slot *slot;\r\nstruct pci_dev *dev;\r\ndbg("%s - enter", __func__);\r\ndown_read(&list_rwsem);\r\nif (!slots) {\r\nup_read(&list_rwsem);\r\nreturn -1;\r\n}\r\nlist_for_each_entry(slot, &slot_list, slot_list) {\r\ndbg("%s - looking at slot %s", __func__, slot_name(slot));\r\nif (clear_ins && cpci_check_and_clear_ins(slot))\r\ndbg("%s - cleared INS for slot %s",\r\n__func__, slot_name(slot));\r\ndev = pci_get_slot(slot->bus, PCI_DEVFN(slot->number, 0));\r\nif (dev) {\r\nif (update_adapter_status(slot->hotplug_slot, 1))\r\nwarn("failure to update adapter file");\r\nif (update_latch_status(slot->hotplug_slot, 1))\r\nwarn("failure to update latch file");\r\nslot->dev = dev;\r\n}\r\n}\r\nup_read(&list_rwsem);\r\ndbg("%s - exit", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_slots(void)\r\n{\r\nstruct slot *slot;\r\nint extracted;\r\nint inserted;\r\nu16 hs_csr;\r\ndown_read(&list_rwsem);\r\nif (!slots) {\r\nup_read(&list_rwsem);\r\nerr("no slots registered, shutting down");\r\nreturn -1;\r\n}\r\nextracted = inserted = 0;\r\nlist_for_each_entry(slot, &slot_list, slot_list) {\r\ndbg("%s - looking at slot %s", __func__, slot_name(slot));\r\nif (cpci_check_and_clear_ins(slot)) {\r\nif (slot->dev) {\r\nwarn("slot %s already inserted",\r\nslot_name(slot));\r\ninserted++;\r\ncontinue;\r\n}\r\ndbg("%s - slot %s inserted", __func__, slot_name(slot));\r\nhs_csr = cpci_get_hs_csr(slot);\r\ndbg("%s - slot %s HS_CSR (1) = %04x",\r\n__func__, slot_name(slot), hs_csr);\r\ndbg("%s - configuring slot %s",\r\n__func__, slot_name(slot));\r\nif (cpci_configure_slot(slot)) {\r\nerr("%s - could not configure slot %s",\r\n__func__, slot_name(slot));\r\ncontinue;\r\n}\r\ndbg("%s - finished configuring slot %s",\r\n__func__, slot_name(slot));\r\nhs_csr = cpci_get_hs_csr(slot);\r\ndbg("%s - slot %s HS_CSR (2) = %04x",\r\n__func__, slot_name(slot), hs_csr);\r\nif (update_latch_status(slot->hotplug_slot, 1))\r\nwarn("failure to update latch file");\r\nif (update_adapter_status(slot->hotplug_slot, 1))\r\nwarn("failure to update adapter file");\r\ncpci_led_off(slot);\r\nhs_csr = cpci_get_hs_csr(slot);\r\ndbg("%s - slot %s HS_CSR (3) = %04x",\r\n__func__, slot_name(slot), hs_csr);\r\ninserted++;\r\n} else if (cpci_check_ext(slot)) {\r\ndbg("%s - slot %s extracted",\r\n__func__, slot_name(slot));\r\nhs_csr = cpci_get_hs_csr(slot);\r\ndbg("%s - slot %s HS_CSR = %04x",\r\n__func__, slot_name(slot), hs_csr);\r\nif (!slot->extracting) {\r\nif (update_latch_status(slot->hotplug_slot, 0))\r\nwarn("failure to update latch file");\r\nslot->extracting = 1;\r\natomic_inc(&extracting);\r\n}\r\nextracted++;\r\n} else if (slot->extracting) {\r\nhs_csr = cpci_get_hs_csr(slot);\r\nif (hs_csr == 0xffff) {\r\nerr("card in slot %s was improperly removed",\r\nslot_name(slot));\r\nif (update_adapter_status(slot->hotplug_slot, 0))\r\nwarn("failure to update adapter file");\r\nslot->extracting = 0;\r\natomic_dec(&extracting);\r\n}\r\n}\r\n}\r\nup_read(&list_rwsem);\r\ndbg("inserted=%d, extracted=%d, extracting=%d",\r\ninserted, extracted, atomic_read(&extracting));\r\nif (inserted || extracted)\r\nreturn extracted;\r\nelse if (!atomic_read(&extracting)) {\r\nerr("cannot find ENUM# source, shutting down");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nevent_thread(void *data)\r\n{\r\nint rc;\r\ndbg("%s - event thread started", __func__);\r\nwhile (1) {\r\ndbg("event thread sleeping");\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nif (kthread_should_stop())\r\nbreak;\r\ndo {\r\nrc = check_slots();\r\nif (rc > 0) {\r\nmsleep(500);\r\n} else if (rc < 0) {\r\ndbg("%s - error checking slots", __func__);\r\nthread_finished = 1;\r\ngoto out;\r\n}\r\n} while (atomic_read(&extracting) && !kthread_should_stop());\r\nif (kthread_should_stop())\r\nbreak;\r\ndbg("%s - re-enabling irq", __func__);\r\ncontroller->ops->enable_irq();\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\npoll_thread(void *data)\r\n{\r\nint rc;\r\nwhile (1) {\r\nif (kthread_should_stop() || signal_pending(current))\r\nbreak;\r\nif (controller->ops->query_enum()) {\r\ndo {\r\nrc = check_slots();\r\nif (rc > 0) {\r\nmsleep(500);\r\n} else if (rc < 0) {\r\ndbg("%s - error checking slots", __func__);\r\nthread_finished = 1;\r\ngoto out;\r\n}\r\n} while (atomic_read(&extracting) && !kthread_should_stop());\r\n}\r\nmsleep(100);\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\ncpci_start_thread(void)\r\n{\r\nif (controller->irq)\r\ncpci_thread = kthread_run(event_thread, NULL, "cpci_hp_eventd");\r\nelse\r\ncpci_thread = kthread_run(poll_thread, NULL, "cpci_hp_polld");\r\nif (IS_ERR(cpci_thread)) {\r\nerr("Can't start up our thread");\r\nreturn PTR_ERR(cpci_thread);\r\n}\r\nthread_finished = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\ncpci_stop_thread(void)\r\n{\r\nkthread_stop(cpci_thread);\r\nthread_finished = 1;\r\n}\r\nint\r\ncpci_hp_register_controller(struct cpci_hp_controller *new_controller)\r\n{\r\nint status = 0;\r\nif (controller)\r\nreturn -1;\r\nif (!(new_controller && new_controller->ops))\r\nreturn -EINVAL;\r\nif (new_controller->irq) {\r\nif (!(new_controller->ops->enable_irq &&\r\nnew_controller->ops->disable_irq))\r\nstatus = -EINVAL;\r\nif (request_irq(new_controller->irq,\r\ncpci_hp_intr,\r\nnew_controller->irq_flags,\r\nMY_NAME,\r\nnew_controller->dev_id)) {\r\nerr("Can't get irq %d for the hotplug cPCI controller",\r\nnew_controller->irq);\r\nstatus = -ENODEV;\r\n}\r\ndbg("%s - acquired controller irq %d",\r\n__func__, new_controller->irq);\r\n}\r\nif (!status)\r\ncontroller = new_controller;\r\nreturn status;\r\n}\r\nstatic void\r\ncleanup_slots(void)\r\n{\r\nstruct slot *slot;\r\nstruct slot *tmp;\r\ndown_write(&list_rwsem);\r\nif (!slots)\r\ngoto cleanup_null;\r\nlist_for_each_entry_safe(slot, tmp, &slot_list, slot_list) {\r\nlist_del(&slot->slot_list);\r\npci_hp_deregister(slot->hotplug_slot);\r\n}\r\ncleanup_null:\r\nup_write(&list_rwsem);\r\nreturn;\r\n}\r\nint\r\ncpci_hp_unregister_controller(struct cpci_hp_controller *old_controller)\r\n{\r\nint status = 0;\r\nif (controller) {\r\nif (!thread_finished)\r\ncpci_stop_thread();\r\nif (controller->irq)\r\nfree_irq(controller->irq, controller->dev_id);\r\ncontroller = NULL;\r\ncleanup_slots();\r\n} else\r\nstatus = -ENODEV;\r\nreturn status;\r\n}\r\nint\r\ncpci_hp_start(void)\r\n{\r\nstatic int first = 1;\r\nint status;\r\ndbg("%s - enter", __func__);\r\nif (!controller)\r\nreturn -ENODEV;\r\ndown_read(&list_rwsem);\r\nif (list_empty(&slot_list)) {\r\nup_read(&list_rwsem);\r\nreturn -ENODEV;\r\n}\r\nup_read(&list_rwsem);\r\nstatus = init_slots(first);\r\nif (first)\r\nfirst = 0;\r\nif (status)\r\nreturn status;\r\nstatus = cpci_start_thread();\r\nif (status)\r\nreturn status;\r\ndbg("%s - thread started", __func__);\r\nif (controller->irq) {\r\ndbg("%s - enabling irq", __func__);\r\ncontroller->ops->enable_irq();\r\n}\r\ndbg("%s - exit", __func__);\r\nreturn 0;\r\n}\r\nint\r\ncpci_hp_stop(void)\r\n{\r\nif (!controller)\r\nreturn -ENODEV;\r\nif (controller->irq) {\r\ndbg("%s - disabling irq", __func__);\r\ncontroller->ops->disable_irq();\r\n}\r\ncpci_stop_thread();\r\nreturn 0;\r\n}\r\nint __init\r\ncpci_hotplug_init(int debug)\r\n{\r\ncpci_debug = debug;\r\nreturn 0;\r\n}\r\nvoid __exit\r\ncpci_hotplug_exit(void)\r\n{\r\ncpci_hp_stop();\r\ncpci_hp_unregister_controller(controller);\r\n}
