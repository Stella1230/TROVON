void gunzip_start(struct gunzip_state *state, void *src, int srclen)\r\n{\r\nchar *hdr = src;\r\nint hdrlen = 0;\r\nmemset(state, 0, sizeof(*state));\r\nif ((hdr[0] == 0x1f) && (hdr[1] == 0x8b)) {\r\nint r, flags;\r\nstate->s.workspace = state->scratch;\r\nif (zlib_inflate_workspacesize() > sizeof(state->scratch))\r\nfatal("insufficient scratch space for gunzip\n\r");\r\nhdrlen = 10;\r\nflags = hdr[3];\r\nif (hdr[2] != Z_DEFLATED || (flags & RESERVED) != 0)\r\nfatal("bad gzipped data\n\r");\r\nif ((flags & EXTRA_FIELD) != 0)\r\nhdrlen = 12 + hdr[10] + (hdr[11] << 8);\r\nif ((flags & ORIG_NAME) != 0)\r\nwhile (hdr[hdrlen++] != 0)\r\n;\r\nif ((flags & COMMENT) != 0)\r\nwhile (hdr[hdrlen++] != 0)\r\n;\r\nif ((flags & HEAD_CRC) != 0)\r\nhdrlen += 2;\r\nif (hdrlen >= srclen)\r\nfatal("gunzip_start: ran out of data in header\n\r");\r\nr = zlib_inflateInit2(&state->s, -MAX_WBITS);\r\nif (r != Z_OK)\r\nfatal("inflateInit2 returned %d\n\r", r);\r\n}\r\nstate->s.total_in = hdrlen;\r\nstate->s.next_in = src + hdrlen;\r\nstate->s.avail_in = srclen - hdrlen;\r\n}\r\nint gunzip_partial(struct gunzip_state *state, void *dst, int dstlen)\r\n{\r\nint len;\r\nif (state->s.workspace) {\r\nint r;\r\nstate->s.next_out = dst;\r\nstate->s.avail_out = dstlen;\r\nr = zlib_inflate(&state->s, Z_FULL_FLUSH);\r\nif (r != Z_OK && r != Z_STREAM_END)\r\nfatal("inflate returned %d msg: %s\n\r", r, state->s.msg);\r\nlen = state->s.next_out - (Byte *)dst;\r\n} else {\r\nlen = min(state->s.avail_in, (uLong)dstlen);\r\nmemcpy(dst, state->s.next_in, len);\r\nstate->s.next_in += len;\r\nstate->s.avail_in -= len;\r\n}\r\nreturn len;\r\n}\r\nvoid gunzip_exactly(struct gunzip_state *state, void *dst, int dstlen)\r\n{\r\nint len;\r\nlen = gunzip_partial(state, dst, dstlen);\r\nif (len < dstlen)\r\nfatal("\n\rgunzip_exactly: ran out of data!"\r\n" Wanted %d, got %d.\n\r", dstlen, len);\r\n}\r\nvoid gunzip_discard(struct gunzip_state *state, int len)\r\n{\r\nstatic char discard_buf[128];\r\nwhile (len > sizeof(discard_buf)) {\r\ngunzip_exactly(state, discard_buf, sizeof(discard_buf));\r\nlen -= sizeof(discard_buf);\r\n}\r\nif (len > 0)\r\ngunzip_exactly(state, discard_buf, len);\r\n}\r\nint gunzip_finish(struct gunzip_state *state, void *dst, int dstlen)\r\n{\r\nint len;\r\nlen = gunzip_partial(state, dst, dstlen);\r\nif (state->s.workspace) {\r\nzlib_inflateEnd(&state->s);\r\n}\r\nreturn len;\r\n}
