static void qxl_fb_image_init(struct qxl_fb_image *qxl_fb_image,\r\nstruct qxl_device *qdev, struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nqxl_fb_image->qdev = qdev;\r\nif (info) {\r\nqxl_fb_image->visual = info->fix.visual;\r\nif (qxl_fb_image->visual == FB_VISUAL_TRUECOLOR ||\r\nqxl_fb_image->visual == FB_VISUAL_DIRECTCOLOR)\r\nmemcpy(&qxl_fb_image->pseudo_palette,\r\ninfo->pseudo_palette,\r\nsizeof(qxl_fb_image->pseudo_palette));\r\n} else {\r\nif (image->depth == 1)\r\nqxl_fb_image->visual = FB_VISUAL_MONO10;\r\nelse\r\nqxl_fb_image->visual = FB_VISUAL_DIRECTCOLOR;\r\n}\r\nif (image) {\r\nmemcpy(&qxl_fb_image->fb_image, image,\r\nsizeof(qxl_fb_image->fb_image));\r\n}\r\n}\r\nstatic void qxl_fb_dirty_flush(struct fb_info *info)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct qxl_fb_image qxl_fb_image;\r\nstruct fb_image *image = &qxl_fb_image.fb_image;\r\nu32 x1, x2, y1, y2;\r\nint stride = qfbdev->qfb.base.pitches[0];\r\nx1 = qfbdev->dirty.x1;\r\nx2 = qfbdev->dirty.x2;\r\ny1 = qfbdev->dirty.y1;\r\ny2 = qfbdev->dirty.y2;\r\nqxl_io_log(qdev, "dirty x[%d, %d], y[%d, %d]", x1, x2, y1, y2);\r\nimage->dx = x1;\r\nimage->dy = y1;\r\nimage->width = x2 - x1;\r\nimage->height = y2 - y1;\r\nimage->fg_color = 0xffffffff;\r\nimage->bg_color = 0;\r\nimage->depth = 32;\r\nimage->cmap.start = 0;\r\nimage->cmap.len = 0;\r\nimage->cmap.red = NULL;\r\nimage->cmap.green = NULL;\r\nimage->cmap.blue = NULL;\r\nimage->cmap.transp = NULL;\r\nimage->data = qfbdev->shadow + (x1 * 4) + (stride * y1);\r\nqxl_fb_image_init(&qxl_fb_image, qdev, info, NULL);\r\nqxl_draw_opaque_fb(&qxl_fb_image, stride);\r\nqfbdev->dirty.x1 = 0;\r\nqfbdev->dirty.x2 = 0;\r\nqfbdev->dirty.y1 = 0;\r\nqfbdev->dirty.y2 = 0;\r\n}\r\nstatic void qxl_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nunsigned long start, end, min, max;\r\nstruct page *page;\r\nint y1, y2;\r\nmin = ULONG_MAX;\r\nmax = 0;\r\nlist_for_each_entry(page, pagelist, lru) {\r\nstart = page->index << PAGE_SHIFT;\r\nend = start + PAGE_SIZE - 1;\r\nmin = min(min, start);\r\nmax = max(max, end);\r\n}\r\nif (min < max) {\r\ny1 = min / info->fix.line_length;\r\ny2 = (max / info->fix.line_length) + 1;\r\nqfbdev->dirty.x1 = 0;\r\nqfbdev->dirty.y1 = y1;\r\nqfbdev->dirty.x2 = info->var.xres;\r\nqfbdev->dirty.y2 = y2;\r\n}\r\nqxl_fb_dirty_flush(info);\r\n}\r\nstatic void qxl_fb_delayed_fillrect(struct qxl_fbdev *qfbdev,\r\nconst struct fb_fillrect *fb_rect)\r\n{\r\nstruct qxl_fb_op *op;\r\nunsigned long flags;\r\nop = kmalloc(sizeof(struct qxl_fb_op), GFP_ATOMIC | __GFP_NOWARN);\r\nif (!op)\r\nreturn;\r\nop->op.fr = *fb_rect;\r\nop->img_data = NULL;\r\nop->op_type = QXL_FB_OP_FILLRECT;\r\nspin_lock_irqsave(&qfbdev->delayed_ops_lock, flags);\r\nlist_add_tail(&op->head, &qfbdev->delayed_ops);\r\nspin_unlock_irqrestore(&qfbdev->delayed_ops_lock, flags);\r\n}\r\nstatic void qxl_fb_delayed_copyarea(struct qxl_fbdev *qfbdev,\r\nconst struct fb_copyarea *fb_copy)\r\n{\r\nstruct qxl_fb_op *op;\r\nunsigned long flags;\r\nop = kmalloc(sizeof(struct qxl_fb_op), GFP_ATOMIC | __GFP_NOWARN);\r\nif (!op)\r\nreturn;\r\nop->op.ca = *fb_copy;\r\nop->img_data = NULL;\r\nop->op_type = QXL_FB_OP_COPYAREA;\r\nspin_lock_irqsave(&qfbdev->delayed_ops_lock, flags);\r\nlist_add_tail(&op->head, &qfbdev->delayed_ops);\r\nspin_unlock_irqrestore(&qfbdev->delayed_ops_lock, flags);\r\n}\r\nstatic void qxl_fb_delayed_imageblit(struct qxl_fbdev *qfbdev,\r\nconst struct fb_image *fb_image)\r\n{\r\nstruct qxl_fb_op *op;\r\nunsigned long flags;\r\nuint32_t size = fb_image->width * fb_image->height * (fb_image->depth >= 8 ? fb_image->depth / 8 : 1);\r\nop = kmalloc(sizeof(struct qxl_fb_op) + size, GFP_ATOMIC | __GFP_NOWARN);\r\nif (!op)\r\nreturn;\r\nop->op.ib = *fb_image;\r\nop->img_data = (void *)(op + 1);\r\nop->op_type = QXL_FB_OP_IMAGEBLIT;\r\nmemcpy(op->img_data, fb_image->data, size);\r\nop->op.ib.data = op->img_data;\r\nspin_lock_irqsave(&qfbdev->delayed_ops_lock, flags);\r\nlist_add_tail(&op->head, &qfbdev->delayed_ops);\r\nspin_unlock_irqrestore(&qfbdev->delayed_ops_lock, flags);\r\n}\r\nstatic void qxl_fb_fillrect_internal(struct fb_info *info,\r\nconst struct fb_fillrect *fb_rect)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct qxl_rect rect;\r\nuint32_t color;\r\nint x = fb_rect->dx;\r\nint y = fb_rect->dy;\r\nint width = fb_rect->width;\r\nint height = fb_rect->height;\r\nuint16_t rop;\r\nstruct qxl_draw_fill qxl_draw_fill_rec;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\ncolor = ((u32 *) (info->pseudo_palette))[fb_rect->color];\r\nelse\r\ncolor = fb_rect->color;\r\nrect.left = x;\r\nrect.right = x + width;\r\nrect.top = y;\r\nrect.bottom = y + height;\r\nswitch (fb_rect->rop) {\r\ncase ROP_XOR:\r\nrop = SPICE_ROPD_OP_XOR;\r\nbreak;\r\ncase ROP_COPY:\r\nrop = SPICE_ROPD_OP_PUT;\r\nbreak;\r\ndefault:\r\npr_err("qxl_fb_fillrect(): unknown rop, "\r\n"defaulting to SPICE_ROPD_OP_PUT\n");\r\nrop = SPICE_ROPD_OP_PUT;\r\n}\r\nqxl_draw_fill_rec.qdev = qdev;\r\nqxl_draw_fill_rec.rect = rect;\r\nqxl_draw_fill_rec.color = color;\r\nqxl_draw_fill_rec.rop = rop;\r\nqxl_draw_fill(&qxl_draw_fill_rec);\r\n}\r\nstatic void qxl_fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *fb_rect)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nif (!drm_can_sleep()) {\r\nqxl_fb_delayed_fillrect(qfbdev, fb_rect);\r\nschedule_work(&qdev->fb_work);\r\nreturn;\r\n}\r\nflush_work(&qdev->fb_work);\r\nqxl_fb_fillrect_internal(info, fb_rect);\r\n}\r\nstatic void qxl_fb_copyarea_internal(struct fb_info *info,\r\nconst struct fb_copyarea *region)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nqxl_draw_copyarea(qfbdev->qdev,\r\nregion->width, region->height,\r\nregion->sx, region->sy,\r\nregion->dx, region->dy);\r\n}\r\nstatic void qxl_fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *region)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nif (!drm_can_sleep()) {\r\nqxl_fb_delayed_copyarea(qfbdev, region);\r\nschedule_work(&qdev->fb_work);\r\nreturn;\r\n}\r\nflush_work(&qdev->fb_work);\r\nqxl_fb_copyarea_internal(info, region);\r\n}\r\nstatic void qxl_fb_imageblit_safe(struct qxl_fb_image *qxl_fb_image)\r\n{\r\nqxl_draw_opaque_fb(qxl_fb_image, 0);\r\n}\r\nstatic void qxl_fb_imageblit_internal(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_fb_image qxl_fb_image;\r\nqxl_fb_image_init(&qxl_fb_image, qfbdev->qdev, info, image);\r\nqxl_fb_imageblit_safe(&qxl_fb_image);\r\n}\r\nstatic void qxl_fb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nif (!drm_can_sleep()) {\r\nqxl_fb_delayed_imageblit(qfbdev, image);\r\nschedule_work(&qdev->fb_work);\r\nreturn;\r\n}\r\nflush_work(&qdev->fb_work);\r\nqxl_fb_imageblit_internal(info, image);\r\n}\r\nstatic void qxl_fb_work(struct work_struct *work)\r\n{\r\nstruct qxl_device *qdev = container_of(work, struct qxl_device, fb_work);\r\nunsigned long flags;\r\nstruct qxl_fb_op *entry, *tmp;\r\nstruct qxl_fbdev *qfbdev = qdev->mode_info.qfbdev;\r\nspin_lock_irqsave(&qfbdev->delayed_ops_lock, flags);\r\nlist_for_each_entry_safe(entry, tmp, &qfbdev->delayed_ops, head) {\r\nspin_unlock_irqrestore(&qfbdev->delayed_ops_lock, flags);\r\nswitch (entry->op_type) {\r\ncase QXL_FB_OP_FILLRECT:\r\nqxl_fb_fillrect_internal(qfbdev->helper.fbdev, &entry->op.fr);\r\nbreak;\r\ncase QXL_FB_OP_COPYAREA:\r\nqxl_fb_copyarea_internal(qfbdev->helper.fbdev, &entry->op.ca);\r\nbreak;\r\ncase QXL_FB_OP_IMAGEBLIT:\r\nqxl_fb_imageblit_internal(qfbdev->helper.fbdev, &entry->op.ib);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&qfbdev->delayed_ops_lock, flags);\r\nlist_del(&entry->head);\r\nkfree(entry);\r\n}\r\nspin_unlock_irqrestore(&qfbdev->delayed_ops_lock, flags);\r\n}\r\nint qxl_fb_init(struct qxl_device *qdev)\r\n{\r\nINIT_WORK(&qdev->fb_work, qxl_fb_work);\r\nreturn 0;\r\n}\r\nstatic void qxlfb_destroy_pinned_object(struct drm_gem_object *gobj)\r\n{\r\nstruct qxl_bo *qbo = gem_to_qxl_bo(gobj);\r\nint ret;\r\nret = qxl_bo_reserve(qbo, false);\r\nif (likely(ret == 0)) {\r\nqxl_bo_kunmap(qbo);\r\nqxl_bo_unpin(qbo);\r\nqxl_bo_unreserve(qbo);\r\n}\r\ndrm_gem_object_unreference_unlocked(gobj);\r\n}\r\nint qxl_get_handle_for_primary_fb(struct qxl_device *qdev,\r\nstruct drm_file *file_priv,\r\nuint32_t *handle)\r\n{\r\nint r;\r\nstruct drm_gem_object *gobj = qdev->fbdev_qfb->obj;\r\nBUG_ON(!gobj);\r\nr = drm_gem_handle_create(file_priv, gobj, handle);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int qxlfb_create_pinned_object(struct qxl_fbdev *qfbdev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object **gobj_p)\r\n{\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct qxl_bo *qbo = NULL;\r\nint ret;\r\nint aligned_size, size;\r\nint height = mode_cmd->height;\r\nint bpp;\r\nint depth;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &bpp, &depth);\r\nsize = mode_cmd->pitches[0] * height;\r\naligned_size = ALIGN(size, PAGE_SIZE);\r\nret = qxl_gem_object_create(qdev, aligned_size, 0,\r\nQXL_GEM_DOMAIN_SURFACE,\r\nfalse,\r\nfalse,\r\nNULL,\r\n&gobj);\r\nif (ret) {\r\npr_err("failed to allocate framebuffer (%d)\n",\r\naligned_size);\r\nreturn -ENOMEM;\r\n}\r\nqbo = gem_to_qxl_bo(gobj);\r\nqbo->surf.width = mode_cmd->width;\r\nqbo->surf.height = mode_cmd->height;\r\nqbo->surf.stride = mode_cmd->pitches[0];\r\nqbo->surf.format = SPICE_SURFACE_FMT_32_xRGB;\r\nret = qxl_bo_reserve(qbo, false);\r\nif (unlikely(ret != 0))\r\ngoto out_unref;\r\nret = qxl_bo_pin(qbo, QXL_GEM_DOMAIN_SURFACE, NULL);\r\nif (ret) {\r\nqxl_bo_unreserve(qbo);\r\ngoto out_unref;\r\n}\r\nret = qxl_bo_kmap(qbo, NULL);\r\nqxl_bo_unreserve(qbo);\r\nif (ret)\r\ngoto out_unref;\r\n*gobj_p = gobj;\r\nreturn 0;\r\nout_unref:\r\nqxlfb_destroy_pinned_object(gobj);\r\n*gobj_p = NULL;\r\nreturn ret;\r\n}\r\nstatic int qxlfb_create(struct qxl_fbdev *qfbdev,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb = NULL;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct qxl_bo *qbo = NULL;\r\nstruct device *device = &qdev->pdev->dev;\r\nint ret;\r\nint size;\r\nint bpp = sizes->surface_bpp;\r\nint depth = sizes->surface_depth;\r\nvoid *shadow;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.width * ((bpp + 1) / 8), 64);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);\r\nret = qxlfb_create_pinned_object(qfbdev, &mode_cmd, &gobj);\r\nqbo = gem_to_qxl_bo(gobj);\r\nQXL_INFO(qdev, "%s: %dx%d %d\n", __func__, mode_cmd.width,\r\nmode_cmd.height, mode_cmd.pitches[0]);\r\nshadow = vmalloc(mode_cmd.pitches[0] * mode_cmd.height);\r\nBUG_ON(!shadow);\r\nQXL_INFO(qdev,\r\n"surface0 at gpu offset %lld, mmap_offset %lld (virt %p, shadow %p)\n",\r\nqxl_bo_gpu_offset(qbo),\r\nqxl_bo_mmap_offset(qbo),\r\nqbo->kptr,\r\nshadow);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\ninfo = framebuffer_alloc(0, device);\r\nif (info == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->par = qfbdev;\r\nqxl_framebuffer_init(qdev->ddev, &qfbdev->qfb, &mode_cmd, gobj);\r\nfb = &qfbdev->qfb.base;\r\nqfbdev->helper.fb = fb;\r\nqfbdev->helper.fbdev = info;\r\nqfbdev->shadow = shadow;\r\nstrcpy(info->fix.id, "qxldrmfb");\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT;\r\ninfo->fbops = &qxlfb_ops;\r\ninfo->fix.smem_start = qdev->vram_base;\r\ninfo->fix.smem_len = gobj->size;\r\ninfo->screen_base = qfbdev->shadow;\r\ninfo->screen_size = gobj->size;\r\ndrm_fb_helper_fill_var(info, &qfbdev->helper, sizes->fb_width,\r\nsizes->fb_height);\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->apertures->ranges[0].base = qdev->ddev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size = qdev->vram_size;\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\nif (info->screen_base == NULL) {\r\nret = -ENOSPC;\r\ngoto out_unref;\r\n}\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->fbdefio = &qxl_defio;\r\nfb_deferred_io_init(info);\r\nqdev->fbdev_info = info;\r\nqdev->fbdev_qfb = &qfbdev->qfb;\r\nDRM_INFO("fb mappable at 0x%lX, size %lu\n", info->fix.smem_start, (unsigned long)info->screen_size);\r\nDRM_INFO("fb: depth %d, pitch %d, width %d, height %d\n", fb->depth, fb->pitches[0], fb->width, fb->height);\r\nreturn 0;\r\nout_unref:\r\nif (qbo) {\r\nret = qxl_bo_reserve(qbo, false);\r\nif (likely(ret == 0)) {\r\nqxl_bo_kunmap(qbo);\r\nqxl_bo_unpin(qbo);\r\nqxl_bo_unreserve(qbo);\r\n}\r\n}\r\nif (fb && ret) {\r\ndrm_gem_object_unreference(gobj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\ndrm_gem_object_unreference(gobj);\r\nreturn ret;\r\n}\r\nstatic int qxl_fb_find_or_create_single(\r\nstruct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct qxl_fbdev *qfbdev =\r\ncontainer_of(helper, struct qxl_fbdev, helper);\r\nint new_fb = 0;\r\nint ret;\r\nif (!helper->fb) {\r\nret = qxlfb_create(qfbdev, sizes);\r\nif (ret)\r\nreturn ret;\r\nnew_fb = 1;\r\n}\r\nreturn new_fb;\r\n}\r\nstatic int qxl_fbdev_destroy(struct drm_device *dev, struct qxl_fbdev *qfbdev)\r\n{\r\nstruct fb_info *info;\r\nstruct qxl_framebuffer *qfb = &qfbdev->qfb;\r\nif (qfbdev->helper.fbdev) {\r\ninfo = qfbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\nframebuffer_release(info);\r\n}\r\nif (qfb->obj) {\r\nqxlfb_destroy_pinned_object(qfb->obj);\r\nqfb->obj = NULL;\r\n}\r\ndrm_fb_helper_fini(&qfbdev->helper);\r\nvfree(qfbdev->shadow);\r\ndrm_framebuffer_cleanup(&qfb->base);\r\nreturn 0;\r\n}\r\nint qxl_fbdev_init(struct qxl_device *qdev)\r\n{\r\nstruct qxl_fbdev *qfbdev;\r\nint bpp_sel = 32;\r\nint ret;\r\nqfbdev = kzalloc(sizeof(struct qxl_fbdev), GFP_KERNEL);\r\nif (!qfbdev)\r\nreturn -ENOMEM;\r\nqfbdev->qdev = qdev;\r\nqdev->mode_info.qfbdev = qfbdev;\r\nspin_lock_init(&qfbdev->delayed_ops_lock);\r\nINIT_LIST_HEAD(&qfbdev->delayed_ops);\r\ndrm_fb_helper_prepare(qdev->ddev, &qfbdev->helper,\r\n&qxl_fb_helper_funcs);\r\nret = drm_fb_helper_init(qdev->ddev, &qfbdev->helper,\r\nqxl_num_crtc ,\r\nQXLFB_CONN_LIMIT);\r\nif (ret) {\r\nkfree(qfbdev);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&qfbdev->helper);\r\ndrm_fb_helper_initial_config(&qfbdev->helper, bpp_sel);\r\nreturn 0;\r\n}\r\nvoid qxl_fbdev_fini(struct qxl_device *qdev)\r\n{\r\nif (!qdev->mode_info.qfbdev)\r\nreturn;\r\nqxl_fbdev_destroy(qdev->ddev, qdev->mode_info.qfbdev);\r\nkfree(qdev->mode_info.qfbdev);\r\nqdev->mode_info.qfbdev = NULL;\r\n}\r\nvoid qxl_fbdev_set_suspend(struct qxl_device *qdev, int state)\r\n{\r\nfb_set_suspend(qdev->mode_info.qfbdev->helper.fbdev, state);\r\n}\r\nbool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj)\r\n{\r\nif (qobj == gem_to_qxl_bo(qdev->mode_info.qfbdev->qfb.obj))\r\nreturn true;\r\nreturn false;\r\n}
