static int mic_dp_init(struct mic_device *mdev)\r\n{\r\nmdev->dp = kzalloc(MIC_DP_SIZE, GFP_KERNEL);\r\nif (!mdev->dp) {\r\ndev_err(mdev->sdev->parent, "%s %d err %d\n",\r\n__func__, __LINE__, -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nmdev->dp_dma_addr = mic_map_single(mdev,\r\nmdev->dp, MIC_DP_SIZE);\r\nif (mic_map_error(mdev->dp_dma_addr)) {\r\nkfree(mdev->dp);\r\ndev_err(mdev->sdev->parent, "%s %d err %d\n",\r\n__func__, __LINE__, -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nmdev->ops->write_spad(mdev, MIC_DPLO_SPAD, mdev->dp_dma_addr);\r\nmdev->ops->write_spad(mdev, MIC_DPHI_SPAD, mdev->dp_dma_addr >> 32);\r\nreturn 0;\r\n}\r\nstatic void mic_dp_uninit(struct mic_device *mdev)\r\n{\r\nmic_unmap_single(mdev, mdev->dp_dma_addr, MIC_DP_SIZE);\r\nkfree(mdev->dp);\r\n}\r\nstatic irqreturn_t mic_shutdown_db(int irq, void *data)\r\n{\r\nstruct mic_device *mdev = data;\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\nmdev->ops->intr_workarounds(mdev);\r\nswitch (bootparam->shutdown_status) {\r\ncase MIC_HALTED:\r\ncase MIC_POWER_OFF:\r\ncase MIC_RESTART:\r\ncase MIC_CRASHED:\r\nschedule_work(&mdev->shutdown_work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mic_ops_init(struct mic_device *mdev)\r\n{\r\nswitch (mdev->family) {\r\ncase MIC_FAMILY_X100:\r\nmdev->ops = &mic_x100_ops;\r\nmdev->intr_ops = &mic_x100_intr_ops;\r\nmdev->smpt_ops = &mic_x100_smpt_ops;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic enum mic_hw_family mic_get_family(struct pci_dev *pdev)\r\n{\r\nenum mic_hw_family family;\r\nswitch (pdev->device) {\r\ncase MIC_X100_PCI_DEVICE_2250:\r\ncase MIC_X100_PCI_DEVICE_2251:\r\ncase MIC_X100_PCI_DEVICE_2252:\r\ncase MIC_X100_PCI_DEVICE_2253:\r\ncase MIC_X100_PCI_DEVICE_2254:\r\ncase MIC_X100_PCI_DEVICE_2255:\r\ncase MIC_X100_PCI_DEVICE_2256:\r\ncase MIC_X100_PCI_DEVICE_2257:\r\ncase MIC_X100_PCI_DEVICE_2258:\r\ncase MIC_X100_PCI_DEVICE_2259:\r\ncase MIC_X100_PCI_DEVICE_225a:\r\ncase MIC_X100_PCI_DEVICE_225b:\r\ncase MIC_X100_PCI_DEVICE_225c:\r\ncase MIC_X100_PCI_DEVICE_225d:\r\ncase MIC_X100_PCI_DEVICE_225e:\r\nfamily = MIC_FAMILY_X100;\r\nbreak;\r\ndefault:\r\nfamily = MIC_FAMILY_UNKNOWN;\r\nbreak;\r\n}\r\nreturn family;\r\n}\r\nstatic int mic_pm_notifier(struct notifier_block *notifier,\r\nunsigned long pm_event, void *unused)\r\n{\r\nstruct mic_device *mdev = container_of(notifier,\r\nstruct mic_device, pm_notifier);\r\nswitch (pm_event) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\nmic_prepare_suspend(mdev);\r\nbreak;\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\ncase PM_POST_RESTORE:\r\nmic_complete_resume(mdev);\r\nbreak;\r\ncase PM_RESTORE_PREPARE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nmic_device_init(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint rc;\r\nmdev->family = mic_get_family(pdev);\r\nmdev->stepping = pdev->revision;\r\nmic_ops_init(mdev);\r\nmic_sysfs_init(mdev);\r\nmutex_init(&mdev->mic_mutex);\r\nmdev->irq_info.next_avail_src = 0;\r\nINIT_WORK(&mdev->reset_trigger_work, mic_reset_trigger_work);\r\nINIT_WORK(&mdev->shutdown_work, mic_shutdown_work);\r\ninit_completion(&mdev->reset_wait);\r\nINIT_LIST_HEAD(&mdev->vdev_list);\r\nmdev->pm_notifier.notifier_call = mic_pm_notifier;\r\nrc = register_pm_notifier(&mdev->pm_notifier);\r\nif (rc) {\r\ndev_err(&pdev->dev, "register_pm_notifier failed rc %d\n",\r\nrc);\r\ngoto register_pm_notifier_fail;\r\n}\r\nreturn 0;\r\nregister_pm_notifier_fail:\r\nflush_work(&mdev->shutdown_work);\r\nflush_work(&mdev->reset_trigger_work);\r\nreturn rc;\r\n}\r\nstatic void mic_device_uninit(struct mic_device *mdev)\r\n{\r\nkfree(mdev->cmdline);\r\nkfree(mdev->firmware);\r\nkfree(mdev->ramdisk);\r\nkfree(mdev->bootmode);\r\nflush_work(&mdev->reset_trigger_work);\r\nflush_work(&mdev->shutdown_work);\r\nunregister_pm_notifier(&mdev->pm_notifier);\r\n}\r\nstatic int mic_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\nstruct mic_device *mdev;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev) {\r\nrc = -ENOMEM;\r\ndev_err(&pdev->dev, "mdev kmalloc failed rc %d\n", rc);\r\ngoto mdev_alloc_fail;\r\n}\r\nmdev->id = ida_simple_get(&g_mic_ida, 0, MIC_MAX_NUM_DEVS, GFP_KERNEL);\r\nif (mdev->id < 0) {\r\nrc = mdev->id;\r\ndev_err(&pdev->dev, "ida_simple_get failed rc %d\n", rc);\r\ngoto ida_fail;\r\n}\r\nrc = mic_device_init(mdev, pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "mic_device_init failed rc %d\n", rc);\r\ngoto device_init_fail;\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to enable pci device.\n");\r\ngoto uninit_device;\r\n}\r\npci_set_master(pdev);\r\nrc = pci_request_regions(pdev, mic_driver_name);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to get pci regions.\n");\r\ngoto disable_device;\r\n}\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot set DMA mask\n");\r\ngoto release_regions;\r\n}\r\nmdev->mmio.pa = pci_resource_start(pdev, mdev->ops->mmio_bar);\r\nmdev->mmio.len = pci_resource_len(pdev, mdev->ops->mmio_bar);\r\nmdev->mmio.va = pci_ioremap_bar(pdev, mdev->ops->mmio_bar);\r\nif (!mdev->mmio.va) {\r\ndev_err(&pdev->dev, "Cannot remap MMIO BAR\n");\r\nrc = -EIO;\r\ngoto release_regions;\r\n}\r\nmdev->aper.pa = pci_resource_start(pdev, mdev->ops->aper_bar);\r\nmdev->aper.len = pci_resource_len(pdev, mdev->ops->aper_bar);\r\nmdev->aper.va = ioremap_wc(mdev->aper.pa, mdev->aper.len);\r\nif (!mdev->aper.va) {\r\ndev_err(&pdev->dev, "Cannot remap Aperture BAR\n");\r\nrc = -EIO;\r\ngoto unmap_mmio;\r\n}\r\nmdev->intr_ops->intr_init(mdev);\r\nrc = mic_setup_interrupts(mdev, pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "mic_setup_interrupts failed %d\n", rc);\r\ngoto unmap_aper;\r\n}\r\nrc = mic_smpt_init(mdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "smpt_init failed %d\n", rc);\r\ngoto free_interrupts;\r\n}\r\npci_set_drvdata(pdev, mdev);\r\nmdev->sdev = device_create_with_groups(g_mic_class, &pdev->dev,\r\nMKDEV(MAJOR(g_mic_devno), mdev->id), NULL,\r\nmdev->attr_group, "mic%d", mdev->id);\r\nif (IS_ERR(mdev->sdev)) {\r\nrc = PTR_ERR(mdev->sdev);\r\ndev_err(&pdev->dev,\r\n"device_create_with_groups failed rc %d\n", rc);\r\ngoto smpt_uninit;\r\n}\r\nmdev->state_sysfs = sysfs_get_dirent(mdev->sdev->kobj.sd, "state");\r\nif (!mdev->state_sysfs) {\r\nrc = -ENODEV;\r\ndev_err(&pdev->dev, "sysfs_get_dirent failed rc %d\n", rc);\r\ngoto destroy_device;\r\n}\r\nrc = mic_dp_init(mdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "mic_dp_init failed rc %d\n", rc);\r\ngoto sysfs_put;\r\n}\r\nmutex_lock(&mdev->mic_mutex);\r\nmdev->shutdown_db = mic_next_db(mdev);\r\nmdev->shutdown_cookie = mic_request_threaded_irq(mdev, mic_shutdown_db,\r\nNULL, "shutdown-interrupt", mdev,\r\nmdev->shutdown_db, MIC_INTR_DB);\r\nif (IS_ERR(mdev->shutdown_cookie)) {\r\nrc = PTR_ERR(mdev->shutdown_cookie);\r\nmutex_unlock(&mdev->mic_mutex);\r\ngoto dp_uninit;\r\n}\r\nmutex_unlock(&mdev->mic_mutex);\r\nmic_bootparam_init(mdev);\r\nmic_create_debug_dir(mdev);\r\ncdev_init(&mdev->cdev, &mic_fops);\r\nmdev->cdev.owner = THIS_MODULE;\r\nrc = cdev_add(&mdev->cdev, MKDEV(MAJOR(g_mic_devno), mdev->id), 1);\r\nif (rc) {\r\ndev_err(&pdev->dev, "cdev_add err id %d rc %d\n", mdev->id, rc);\r\ngoto cleanup_debug_dir;\r\n}\r\nreturn 0;\r\ncleanup_debug_dir:\r\nmic_delete_debug_dir(mdev);\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_free_irq(mdev, mdev->shutdown_cookie, mdev);\r\nmutex_unlock(&mdev->mic_mutex);\r\ndp_uninit:\r\nmic_dp_uninit(mdev);\r\nsysfs_put:\r\nsysfs_put(mdev->state_sysfs);\r\ndestroy_device:\r\ndevice_destroy(g_mic_class, MKDEV(MAJOR(g_mic_devno), mdev->id));\r\nsmpt_uninit:\r\nmic_smpt_uninit(mdev);\r\nfree_interrupts:\r\nmic_free_interrupts(mdev, pdev);\r\nunmap_aper:\r\niounmap(mdev->aper.va);\r\nunmap_mmio:\r\niounmap(mdev->mmio.va);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nuninit_device:\r\nmic_device_uninit(mdev);\r\ndevice_init_fail:\r\nida_simple_remove(&g_mic_ida, mdev->id);\r\nida_fail:\r\nkfree(mdev);\r\nmdev_alloc_fail:\r\ndev_err(&pdev->dev, "Probe failed rc %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void mic_remove(struct pci_dev *pdev)\r\n{\r\nstruct mic_device *mdev;\r\nmdev = pci_get_drvdata(pdev);\r\nif (!mdev)\r\nreturn;\r\nmic_stop(mdev, false);\r\ncdev_del(&mdev->cdev);\r\nmic_delete_debug_dir(mdev);\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_free_irq(mdev, mdev->shutdown_cookie, mdev);\r\nmutex_unlock(&mdev->mic_mutex);\r\nflush_work(&mdev->shutdown_work);\r\nmic_dp_uninit(mdev);\r\nsysfs_put(mdev->state_sysfs);\r\ndevice_destroy(g_mic_class, MKDEV(MAJOR(g_mic_devno), mdev->id));\r\nmic_smpt_uninit(mdev);\r\nmic_free_interrupts(mdev, pdev);\r\niounmap(mdev->mmio.va);\r\niounmap(mdev->aper.va);\r\nmic_device_uninit(mdev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nida_simple_remove(&g_mic_ida, mdev->id);\r\nkfree(mdev);\r\n}\r\nstatic int __init mic_init(void)\r\n{\r\nint ret;\r\nret = alloc_chrdev_region(&g_mic_devno, 0,\r\nMIC_MAX_NUM_DEVS, mic_driver_name);\r\nif (ret) {\r\npr_err("alloc_chrdev_region failed ret %d\n", ret);\r\ngoto error;\r\n}\r\ng_mic_class = class_create(THIS_MODULE, mic_driver_name);\r\nif (IS_ERR(g_mic_class)) {\r\nret = PTR_ERR(g_mic_class);\r\npr_err("class_create failed ret %d\n", ret);\r\ngoto cleanup_chrdev;\r\n}\r\nmic_init_debugfs();\r\nida_init(&g_mic_ida);\r\nret = pci_register_driver(&mic_driver);\r\nif (ret) {\r\npr_err("pci_register_driver failed ret %d\n", ret);\r\ngoto cleanup_debugfs;\r\n}\r\nreturn ret;\r\ncleanup_debugfs:\r\nmic_exit_debugfs();\r\nclass_destroy(g_mic_class);\r\ncleanup_chrdev:\r\nunregister_chrdev_region(g_mic_devno, MIC_MAX_NUM_DEVS);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void __exit mic_exit(void)\r\n{\r\npci_unregister_driver(&mic_driver);\r\nida_destroy(&g_mic_ida);\r\nmic_exit_debugfs();\r\nclass_destroy(g_mic_class);\r\nunregister_chrdev_region(g_mic_devno, MIC_MAX_NUM_DEVS);\r\n}
