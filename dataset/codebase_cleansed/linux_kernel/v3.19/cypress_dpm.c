static void cypress_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp, bif;\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif (enable) {\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\r\nif (!pi->boot_in_gen2) {\r\nbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\r\nbif |= CG_CLIENT_REQ(0xd);\r\nWREG32(CG_BIF_REQ_AND_RSP, bif);\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\r\ntmp |= LC_GEN2_EN_STRAP;\r\ntmp |= LC_CLR_FAILED_SPD_CHANGE_CNT;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\nudelay(10);\r\ntmp &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\n}\r\n} else {\r\nif (!pi->boot_in_gen2) {\r\ntmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\r\ntmp &= ~LC_GEN2_EN_STRAP;\r\n}\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\r\nWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\r\n}\r\n}\r\nstatic void cypress_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\ncypress_enable_bif_dynamic_pcie_gen2(rdev, enable);\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\r\n}\r\nstatic void cypress_gfx_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (enable) {\r\nif (eg_pi->light_sleep) {\r\nWREG32(GRBM_GFX_INDEX, 0xC0000000);\r\nWREG32_CG(CG_CGLS_TILE_0, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_1, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_2, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_3, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_4, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_5, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_6, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_7, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_8, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_9, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_10, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGLS_TILE_11, 0xFFFFFFFF);\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_LIGHT_SLEEP_EN, ~DYN_LIGHT_SLEEP_EN);\r\n}\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\n} else {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\r\nWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\r\nRREG32(GB_ADDR_CONFIG);\r\nif (eg_pi->light_sleep) {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_LIGHT_SLEEP_EN);\r\nWREG32(GRBM_GFX_INDEX, 0xC0000000);\r\nWREG32_CG(CG_CGLS_TILE_0, 0);\r\nWREG32_CG(CG_CGLS_TILE_1, 0);\r\nWREG32_CG(CG_CGLS_TILE_2, 0);\r\nWREG32_CG(CG_CGLS_TILE_3, 0);\r\nWREG32_CG(CG_CGLS_TILE_4, 0);\r\nWREG32_CG(CG_CGLS_TILE_5, 0);\r\nWREG32_CG(CG_CGLS_TILE_6, 0);\r\nWREG32_CG(CG_CGLS_TILE_7, 0);\r\nWREG32_CG(CG_CGLS_TILE_8, 0);\r\nWREG32_CG(CG_CGLS_TILE_9, 0);\r\nWREG32_CG(CG_CGLS_TILE_10, 0);\r\nWREG32_CG(CG_CGLS_TILE_11, 0);\r\n}\r\n}\r\n}\r\nstatic void cypress_mg_clock_gating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (enable) {\r\nu32 cgts_sm_ctrl_reg;\r\nif (rdev->family == CHIP_CEDAR)\r\ncgts_sm_ctrl_reg = CEDAR_MGCGCGTSSMCTRL_DFLT;\r\nelse if (rdev->family == CHIP_REDWOOD)\r\ncgts_sm_ctrl_reg = REDWOOD_MGCGCGTSSMCTRL_DFLT;\r\nelse\r\ncgts_sm_ctrl_reg = CYPRESS_MGCGCGTSSMCTRL_DFLT;\r\nWREG32(GRBM_GFX_INDEX, 0xC0000000);\r\nWREG32_CG(CG_CGTT_LOCAL_0, CYPRESS_MGCGTTLOCAL0_DFLT);\r\nWREG32_CG(CG_CGTT_LOCAL_1, CYPRESS_MGCGTTLOCAL1_DFLT & 0xFFFFCFFF);\r\nWREG32_CG(CG_CGTT_LOCAL_2, CYPRESS_MGCGTTLOCAL2_DFLT);\r\nWREG32_CG(CG_CGTT_LOCAL_3, CYPRESS_MGCGTTLOCAL3_DFLT);\r\nif (pi->mgcgtssm)\r\nWREG32(CGTS_SM_CTRL_REG, cgts_sm_ctrl_reg);\r\nif (eg_pi->mcls) {\r\nWREG32_P(MC_CITF_MISC_RD_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_CITF_MISC_WR_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_CITF_MISC_VM_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_HUB_MISC_HUB_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_HUB_MISC_VM_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_HUB_MISC_SIP_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(MC_XPB_CLK_GAT, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\nWREG32_P(VM_L2_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\r\n}\r\n} else {\r\nWREG32(GRBM_GFX_INDEX, 0xC0000000);\r\nWREG32_CG(CG_CGTT_LOCAL_0, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGTT_LOCAL_1, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGTT_LOCAL_2, 0xFFFFFFFF);\r\nWREG32_CG(CG_CGTT_LOCAL_3, 0xFFFFFFFF);\r\nif (pi->mgcgtssm)\r\nWREG32(CGTS_SM_CTRL_REG, 0x81f44bc0);\r\n}\r\n}\r\nvoid cypress_enable_spread_spectrum(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nif (enable) {\r\nif (pi->sclk_ss)\r\nWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\r\nif (pi->mclk_ss)\r\nWREG32_P(MPLL_CNTL_MODE, SS_SSEN, ~SS_SSEN);\r\n} else {\r\nWREG32_P(CG_SPLL_SPREAD_SPECTRUM, 0, ~SSEN);\r\nWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\r\nWREG32_P(MPLL_CNTL_MODE, 0, ~SS_SSEN);\r\nWREG32_P(MPLL_CNTL_MODE, 0, ~SS_DSMODE_EN);\r\n}\r\n}\r\nvoid cypress_start_dpm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\r\n}\r\nvoid cypress_enable_sclk_control(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\r\nelse\r\nWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\r\n}\r\nvoid cypress_enable_mclk_control(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable)\r\nWREG32_P(MCLK_PWRMGT_CNTL, 0, ~MPLL_PWRMGT_OFF);\r\nelse\r\nWREG32_P(MCLK_PWRMGT_CNTL, MPLL_PWRMGT_OFF, ~MPLL_PWRMGT_OFF);\r\n}\r\nint cypress_notify_smc_display_change(struct radeon_device *rdev,\r\nbool has_display)\r\n{\r\nPPSMC_Msg msg = has_display ?\r\n(PPSMC_Msg)PPSMC_MSG_HasDisplay : (PPSMC_Msg)PPSMC_MSG_NoDisplay;\r\nif (rv770_send_msg_to_smc(rdev, msg) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid cypress_program_response_times(struct radeon_device *rdev)\r\n{\r\nu32 reference_clock;\r\nu32 mclk_switch_limit;\r\nreference_clock = radeon_get_xclk(rdev);\r\nmclk_switch_limit = (460 * reference_clock) / 100;\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_mclk_switch_lim,\r\nmclk_switch_limit);\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_mvdd_chg_time, 1);\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_mc_block_delay, 0xAA);\r\nrv770_program_response_times(rdev);\r\nif (ASIC_IS_LOMBOK(rdev))\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_is_asic_lombok, 1);\r\n}\r\nstatic int cypress_pcie_performance_request(struct radeon_device *rdev,\r\nu8 perf_req, bool advertise)\r\n{\r\n#if defined(CONFIG_ACPI)\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\n#endif\r\nu32 tmp;\r\nudelay(10);\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif ((perf_req == PCIE_PERF_REQ_PECI_GEN1) && (tmp & LC_CURRENT_DATA_RATE))\r\nreturn 0;\r\n#if defined(CONFIG_ACPI)\r\nif ((perf_req == PCIE_PERF_REQ_PECI_GEN1) ||\r\n(perf_req == PCIE_PERF_REQ_PECI_GEN2)) {\r\neg_pi->pcie_performance_request_registered = true;\r\nreturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\r\n} else if ((perf_req == PCIE_PERF_REQ_REMOVE_REGISTRY) &&\r\neg_pi->pcie_performance_request_registered) {\r\neg_pi->pcie_performance_request_registered = false;\r\nreturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid cypress_advertise_gen2_capability(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 tmp;\r\n#if defined(CONFIG_ACPI)\r\nradeon_acpi_pcie_notify_device_ready(rdev);\r\n#endif\r\ntmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\r\nif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\r\n(tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\r\npi->pcie_gen2 = true;\r\nelse\r\npi->pcie_gen2 = false;\r\nif (!pi->pcie_gen2)\r\ncypress_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, true);\r\n}\r\nstatic enum radeon_pcie_gen cypress_get_maximum_link_speed(struct radeon_ps *radeon_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nif (state->high.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid cypress_notify_link_speed_change_after_state_change(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nenum radeon_pcie_gen pcie_link_speed_target =\r\ncypress_get_maximum_link_speed(radeon_new_state);\r\nenum radeon_pcie_gen pcie_link_speed_current =\r\ncypress_get_maximum_link_speed(radeon_current_state);\r\nu8 request;\r\nif (pcie_link_speed_target < pcie_link_speed_current) {\r\nif (pcie_link_speed_target == RADEON_PCIE_GEN1)\r\nrequest = PCIE_PERF_REQ_PECI_GEN1;\r\nelse if (pcie_link_speed_target == RADEON_PCIE_GEN2)\r\nrequest = PCIE_PERF_REQ_PECI_GEN2;\r\nelse\r\nrequest = PCIE_PERF_REQ_PECI_GEN3;\r\ncypress_pcie_performance_request(rdev, request, false);\r\n}\r\n}\r\nvoid cypress_notify_link_speed_change_before_state_change(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nenum radeon_pcie_gen pcie_link_speed_target =\r\ncypress_get_maximum_link_speed(radeon_new_state);\r\nenum radeon_pcie_gen pcie_link_speed_current =\r\ncypress_get_maximum_link_speed(radeon_current_state);\r\nu8 request;\r\nif (pcie_link_speed_target > pcie_link_speed_current) {\r\nif (pcie_link_speed_target == RADEON_PCIE_GEN1)\r\nrequest = PCIE_PERF_REQ_PECI_GEN1;\r\nelse if (pcie_link_speed_target == RADEON_PCIE_GEN2)\r\nrequest = PCIE_PERF_REQ_PECI_GEN2;\r\nelse\r\nrequest = PCIE_PERF_REQ_PECI_GEN3;\r\ncypress_pcie_performance_request(rdev, request, false);\r\n}\r\n}\r\nstatic int cypress_populate_voltage_value(struct radeon_device *rdev,\r\nstruct atom_voltage_table *table,\r\nu16 value, RV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < table->count; i++) {\r\nif (value <= table->entries[i].value) {\r\nvoltage->index = (u8)i;\r\nvoltage->value = cpu_to_be16(table->entries[i].value);\r\nbreak;\r\n}\r\n}\r\nif (i == table->count)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nu8 cypress_get_strobe_mode_settings(struct radeon_device *rdev, u32 mclk)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 result = 0;\r\nbool strobe_mode = false;\r\nif (pi->mem_gddr5) {\r\nif (mclk <= pi->mclk_strobe_mode_threshold)\r\nstrobe_mode = true;\r\nresult = cypress_get_mclk_frequency_ratio(rdev, mclk, strobe_mode);\r\nif (strobe_mode)\r\nresult |= SMC_STROBE_ENABLE;\r\n}\r\nreturn result;\r\n}\r\nu32 cypress_map_clkf_to_ibias(struct radeon_device *rdev, u32 clkf)\r\n{\r\nu32 ref_clk = rdev->clock.mpll.reference_freq;\r\nu32 vco = clkf * ref_clk;\r\nif (ref_clk == 10000) {\r\nif (vco > 500000)\r\nreturn 0xC6;\r\nif (vco > 400000)\r\nreturn 0x9D;\r\nif (vco > 330000)\r\nreturn 0x6C;\r\nif (vco > 250000)\r\nreturn 0x2B;\r\nif (vco > 160000)\r\nreturn 0x5B;\r\nif (vco > 120000)\r\nreturn 0x0A;\r\nreturn 0x4B;\r\n}\r\nif (vco > 250000)\r\nreturn 0x8B;\r\nif (vco > 200000)\r\nreturn 0xCC;\r\nif (vco > 150000)\r\nreturn 0x9B;\r\nreturn 0x6B;\r\n}\r\nstatic int cypress_populate_mclk_value(struct radeon_device *rdev,\r\nu32 engine_clock, u32 memory_clock,\r\nRV7XX_SMC_MCLK_VALUE *mclk,\r\nbool strobe_mode, bool dll_state_on)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 mpll_ad_func_cntl =\r\npi->clk_regs.rv770.mpll_ad_func_cntl;\r\nu32 mpll_ad_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_ad_func_cntl_2;\r\nu32 mpll_dq_func_cntl =\r\npi->clk_regs.rv770.mpll_dq_func_cntl;\r\nu32 mpll_dq_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_dq_func_cntl_2;\r\nu32 mclk_pwrmgt_cntl =\r\npi->clk_regs.rv770.mclk_pwrmgt_cntl;\r\nu32 dll_cntl =\r\npi->clk_regs.rv770.dll_cntl;\r\nu32 mpll_ss1 = pi->clk_regs.rv770.mpll_ss1;\r\nu32 mpll_ss2 = pi->clk_regs.rv770.mpll_ss2;\r\nstruct atom_clock_dividers dividers;\r\nu32 ibias;\r\nu32 dll_speed;\r\nint ret;\r\nu32 mc_seq_misc7;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\r\nmemory_clock, strobe_mode, &dividers);\r\nif (ret)\r\nreturn ret;\r\nif (!strobe_mode) {\r\nmc_seq_misc7 = RREG32(MC_SEQ_MISC7);\r\nif(mc_seq_misc7 & 0x8000000)\r\ndividers.post_div = 1;\r\n}\r\nibias = cypress_map_clkf_to_ibias(rdev, dividers.whole_fb_div);\r\nmpll_ad_func_cntl &= ~(CLKR_MASK |\r\nYCLK_POST_DIV_MASK |\r\nCLKF_MASK |\r\nCLKFRAC_MASK |\r\nIBIAS_MASK);\r\nmpll_ad_func_cntl |= CLKR(dividers.ref_div);\r\nmpll_ad_func_cntl |= YCLK_POST_DIV(dividers.post_div);\r\nmpll_ad_func_cntl |= CLKF(dividers.whole_fb_div);\r\nmpll_ad_func_cntl |= CLKFRAC(dividers.frac_fb_div);\r\nmpll_ad_func_cntl |= IBIAS(ibias);\r\nif (dividers.vco_mode)\r\nmpll_ad_func_cntl_2 |= VCO_MODE;\r\nelse\r\nmpll_ad_func_cntl_2 &= ~VCO_MODE;\r\nif (pi->mem_gddr5) {\r\nmpll_dq_func_cntl &= ~(CLKR_MASK |\r\nYCLK_POST_DIV_MASK |\r\nCLKF_MASK |\r\nCLKFRAC_MASK |\r\nIBIAS_MASK);\r\nmpll_dq_func_cntl |= CLKR(dividers.ref_div);\r\nmpll_dq_func_cntl |= YCLK_POST_DIV(dividers.post_div);\r\nmpll_dq_func_cntl |= CLKF(dividers.whole_fb_div);\r\nmpll_dq_func_cntl |= CLKFRAC(dividers.frac_fb_div);\r\nmpll_dq_func_cntl |= IBIAS(ibias);\r\nif (strobe_mode)\r\nmpll_dq_func_cntl &= ~PDNB;\r\nelse\r\nmpll_dq_func_cntl |= PDNB;\r\nif (dividers.vco_mode)\r\nmpll_dq_func_cntl_2 |= VCO_MODE;\r\nelse\r\nmpll_dq_func_cntl_2 &= ~VCO_MODE;\r\n}\r\nif (pi->mclk_ss) {\r\nstruct radeon_atom_ss ss;\r\nu32 vco_freq = memory_clock * dividers.post_div;\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, vco_freq)) {\r\nu32 reference_clock = rdev->clock.mpll.reference_freq;\r\nu32 decoded_ref = rv740_get_decoded_reference_divider(dividers.ref_div);\r\nu32 clk_s = reference_clock * 5 / (decoded_ref * ss.rate);\r\nu32 clk_v = ss.percentage *\r\n(0x4000 * dividers.whole_fb_div + 0x800 * dividers.frac_fb_div) / (clk_s * 625);\r\nmpll_ss1 &= ~CLKV_MASK;\r\nmpll_ss1 |= CLKV(clk_v);\r\nmpll_ss2 &= ~CLKS_MASK;\r\nmpll_ss2 |= CLKS(clk_s);\r\n}\r\n}\r\ndll_speed = rv740_get_dll_speed(pi->mem_gddr5,\r\nmemory_clock);\r\nmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\r\nmclk_pwrmgt_cntl |= DLL_SPEED(dll_speed);\r\nif (dll_state_on)\r\nmclk_pwrmgt_cntl |= (MRDCKA0_PDNB |\r\nMRDCKA1_PDNB |\r\nMRDCKB0_PDNB |\r\nMRDCKB1_PDNB |\r\nMRDCKC0_PDNB |\r\nMRDCKC1_PDNB |\r\nMRDCKD0_PDNB |\r\nMRDCKD1_PDNB);\r\nelse\r\nmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\r\nMRDCKA1_PDNB |\r\nMRDCKB0_PDNB |\r\nMRDCKB1_PDNB |\r\nMRDCKC0_PDNB |\r\nMRDCKC1_PDNB |\r\nMRDCKD0_PDNB |\r\nMRDCKD1_PDNB);\r\nmclk->mclk770.mclk_value = cpu_to_be32(memory_clock);\r\nmclk->mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\r\nmclk->mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\r\nmclk->mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\r\nmclk->mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\r\nmclk->mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\r\nmclk->mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\r\nmclk->mclk770.vMPLL_SS = cpu_to_be32(mpll_ss1);\r\nmclk->mclk770.vMPLL_SS2 = cpu_to_be32(mpll_ss2);\r\nreturn 0;\r\n}\r\nu8 cypress_get_mclk_frequency_ratio(struct radeon_device *rdev,\r\nu32 memory_clock, bool strobe_mode)\r\n{\r\nu8 mc_para_index;\r\nif (rdev->family >= CHIP_BARTS) {\r\nif (strobe_mode) {\r\nif (memory_clock < 10000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 47500)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 10000) / 2500);\r\n} else {\r\nif (memory_clock < 65000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 135000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 60000) / 5000);\r\n}\r\n} else {\r\nif (strobe_mode) {\r\nif (memory_clock < 10000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 47500)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 10000) / 2500);\r\n} else {\r\nif (memory_clock < 40000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 115000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 40000) / 5000);\r\n}\r\n}\r\nreturn mc_para_index;\r\n}\r\nstatic int cypress_populate_mvdd_value(struct radeon_device *rdev,\r\nu32 mclk,\r\nRV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nif (!pi->mvdd_control) {\r\nvoltage->index = eg_pi->mvdd_high_index;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\nreturn 0;\r\n}\r\nif (mclk <= pi->mvdd_split_frequency) {\r\nvoltage->index = eg_pi->mvdd_low_index;\r\nvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\r\n} else {\r\nvoltage->index = eg_pi->mvdd_high_index;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\n}\r\nreturn 0;\r\n}\r\nint cypress_convert_power_level_to_smc(struct radeon_device *rdev,\r\nstruct rv7xx_pl *pl,\r\nRV770_SMC_HW_PERFORMANCE_LEVEL *level,\r\nu8 watermark_level)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nint ret;\r\nbool dll_state_on;\r\nlevel->gen2PCIE = pi->pcie_gen2 ?\r\n((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;\r\nlevel->gen2XSP = (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0;\r\nlevel->backbias = (pl->flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? 1 : 0;\r\nlevel->displayWatermark = watermark_level;\r\nret = rv740_populate_sclk_value(rdev, pl->sclk, &level->sclk);\r\nif (ret)\r\nreturn ret;\r\nlevel->mcFlags = 0;\r\nif (pi->mclk_stutter_mode_threshold &&\r\n(pl->mclk <= pi->mclk_stutter_mode_threshold) &&\r\n!eg_pi->uvd_enabled) {\r\nlevel->mcFlags |= SMC_MC_STUTTER_EN;\r\nif (eg_pi->sclk_deep_sleep)\r\nlevel->stateFlags |= PPSMC_STATEFLAG_AUTO_PULSE_SKIP;\r\nelse\r\nlevel->stateFlags &= ~PPSMC_STATEFLAG_AUTO_PULSE_SKIP;\r\n}\r\nif (pi->mem_gddr5) {\r\nif (pl->mclk > pi->mclk_edc_enable_threshold)\r\nlevel->mcFlags |= SMC_MC_EDC_RD_FLAG;\r\nif (pl->mclk > eg_pi->mclk_edc_wr_enable_threshold)\r\nlevel->mcFlags |= SMC_MC_EDC_WR_FLAG;\r\nlevel->strobeMode = cypress_get_strobe_mode_settings(rdev, pl->mclk);\r\nif (level->strobeMode & SMC_STROBE_ENABLE) {\r\nif (cypress_get_mclk_frequency_ratio(rdev, pl->mclk, true) >=\r\n((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))\r\ndll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\r\nelse\r\ndll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\r\n} else\r\ndll_state_on = eg_pi->dll_default_on;\r\nret = cypress_populate_mclk_value(rdev,\r\npl->sclk,\r\npl->mclk,\r\n&level->mclk,\r\n(level->strobeMode & SMC_STROBE_ENABLE) != 0,\r\ndll_state_on);\r\n} else {\r\nret = cypress_populate_mclk_value(rdev,\r\npl->sclk,\r\npl->mclk,\r\n&level->mclk,\r\ntrue,\r\ntrue);\r\n}\r\nif (ret)\r\nreturn ret;\r\nret = cypress_populate_voltage_value(rdev,\r\n&eg_pi->vddc_voltage_table,\r\npl->vddc,\r\n&level->vddc);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->vddci_control) {\r\nret = cypress_populate_voltage_value(rdev,\r\n&eg_pi->vddci_voltage_table,\r\npl->vddci,\r\n&level->vddci);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = cypress_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);\r\nreturn ret;\r\n}\r\nstatic int cypress_convert_power_state_to_smc(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nRV770_SMC_SWSTATE *smc_state)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nint ret;\r\nif (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))\r\nsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\r\nret = cypress_convert_power_level_to_smc(rdev,\r\n&state->low,\r\n&smc_state->levels[0],\r\nPPSMC_DISPLAY_WATERMARK_LOW);\r\nif (ret)\r\nreturn ret;\r\nret = cypress_convert_power_level_to_smc(rdev,\r\n&state->medium,\r\n&smc_state->levels[1],\r\nPPSMC_DISPLAY_WATERMARK_LOW);\r\nif (ret)\r\nreturn ret;\r\nret = cypress_convert_power_level_to_smc(rdev,\r\n&state->high,\r\n&smc_state->levels[2],\r\nPPSMC_DISPLAY_WATERMARK_HIGH);\r\nif (ret)\r\nreturn ret;\r\nsmc_state->levels[0].arbValue = MC_CG_ARB_FREQ_F1;\r\nsmc_state->levels[1].arbValue = MC_CG_ARB_FREQ_F2;\r\nsmc_state->levels[2].arbValue = MC_CG_ARB_FREQ_F3;\r\nif (eg_pi->dynamic_ac_timing) {\r\nsmc_state->levels[0].ACIndex = 2;\r\nsmc_state->levels[1].ACIndex = 3;\r\nsmc_state->levels[2].ACIndex = 4;\r\n} else {\r\nsmc_state->levels[0].ACIndex = 0;\r\nsmc_state->levels[1].ACIndex = 0;\r\nsmc_state->levels[2].ACIndex = 0;\r\n}\r\nrv770_populate_smc_sp(rdev, radeon_state, smc_state);\r\nreturn rv770_populate_smc_t(rdev, radeon_state, smc_state);\r\n}\r\nstatic void cypress_convert_mc_registers(struct evergreen_mc_reg_entry *entry,\r\nSMC_Evergreen_MCRegisterSet *data,\r\nu32 num_entries, u32 valid_flag)\r\n{\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < num_entries; j++) {\r\nif (valid_flag & (1 << j)) {\r\ndata->value[i] = cpu_to_be32(entry->mc_data[j]);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic void cypress_convert_mc_reg_table_entry_to_smc(struct radeon_device *rdev,\r\nstruct rv7xx_pl *pl,\r\nSMC_Evergreen_MCRegisterSet *mc_reg_table_data)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 i = 0;\r\nfor (i = 0; i < eg_pi->mc_reg_table.num_entries; i++) {\r\nif (pl->mclk <=\r\neg_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\r\nbreak;\r\n}\r\nif ((i == eg_pi->mc_reg_table.num_entries) && (i > 0))\r\n--i;\r\ncypress_convert_mc_registers(&eg_pi->mc_reg_table.mc_reg_table_entry[i],\r\nmc_reg_table_data,\r\neg_pi->mc_reg_table.last,\r\neg_pi->mc_reg_table.valid_flag);\r\n}\r\nstatic void cypress_convert_mc_reg_table_to_smc(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state,\r\nSMC_Evergreen_MCRegisters *mc_reg_table)\r\n{\r\nstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\r\ncypress_convert_mc_reg_table_entry_to_smc(rdev,\r\n&state->low,\r\n&mc_reg_table->data[2]);\r\ncypress_convert_mc_reg_table_entry_to_smc(rdev,\r\n&state->medium,\r\n&mc_reg_table->data[3]);\r\ncypress_convert_mc_reg_table_entry_to_smc(rdev,\r\n&state->high,\r\n&mc_reg_table->data[4]);\r\n}\r\nint cypress_upload_sw_state(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu16 address = pi->state_table_start +\r\noffsetof(RV770_SMC_STATETABLE, driverState);\r\nRV770_SMC_SWSTATE state = { 0 };\r\nint ret;\r\nret = cypress_convert_power_state_to_smc(rdev, radeon_new_state, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn rv770_copy_bytes_to_smc(rdev, address, (u8 *)&state,\r\nsizeof(RV770_SMC_SWSTATE),\r\npi->sram_end);\r\n}\r\nint cypress_upload_mc_reg_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nSMC_Evergreen_MCRegisters mc_reg_table = { 0 };\r\nu16 address;\r\ncypress_convert_mc_reg_table_to_smc(rdev, radeon_new_state, &mc_reg_table);\r\naddress = eg_pi->mc_reg_table_start +\r\n(u16)offsetof(SMC_Evergreen_MCRegisters, data[2]);\r\nreturn rv770_copy_bytes_to_smc(rdev, address,\r\n(u8 *)&mc_reg_table.data[2],\r\nsizeof(SMC_Evergreen_MCRegisterSet) * 3,\r\npi->sram_end);\r\n}\r\nu32 cypress_calculate_burst_time(struct radeon_device *rdev,\r\nu32 engine_clock, u32 memory_clock)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 multiplier = pi->mem_gddr5 ? 1 : 2;\r\nu32 result = (4 * multiplier * engine_clock) / (memory_clock / 2);\r\nu32 burst_time;\r\nif (result <= 4)\r\nburst_time = 0;\r\nelse if (result < 8)\r\nburst_time = result - 4;\r\nelse {\r\nburst_time = result / 2 ;\r\nif (burst_time > 18)\r\nburst_time = 18;\r\n}\r\nreturn burst_time;\r\n}\r\nvoid cypress_program_memory_timing_parameters(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state)\r\n{\r\nstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\r\nu32 mc_arb_burst_time = RREG32(MC_ARB_BURST_TIME);\r\nmc_arb_burst_time &= ~(STATE1_MASK | STATE2_MASK | STATE3_MASK);\r\nmc_arb_burst_time |= STATE1(cypress_calculate_burst_time(rdev,\r\nnew_state->low.sclk,\r\nnew_state->low.mclk));\r\nmc_arb_burst_time |= STATE2(cypress_calculate_burst_time(rdev,\r\nnew_state->medium.sclk,\r\nnew_state->medium.mclk));\r\nmc_arb_burst_time |= STATE3(cypress_calculate_burst_time(rdev,\r\nnew_state->high.sclk,\r\nnew_state->high.mclk));\r\nrv730_program_memory_timing_parameters(rdev, radeon_new_state);\r\nWREG32(MC_ARB_BURST_TIME, mc_arb_burst_time);\r\n}\r\nstatic void cypress_populate_mc_reg_addresses(struct radeon_device *rdev,\r\nSMC_Evergreen_MCRegisters *mc_reg_table)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < eg_pi->mc_reg_table.last; j++) {\r\nif (eg_pi->mc_reg_table.valid_flag & (1 << j)) {\r\nmc_reg_table->address[i].s0 =\r\ncpu_to_be16(eg_pi->mc_reg_table.mc_reg_address[j].s0);\r\nmc_reg_table->address[i].s1 =\r\ncpu_to_be16(eg_pi->mc_reg_table.mc_reg_address[j].s1);\r\ni++;\r\n}\r\n}\r\nmc_reg_table->last = (u8)i;\r\n}\r\nstatic void cypress_set_mc_reg_address_table(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 i = 0;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RAS_TIMING_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RAS_TIMING >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_CAS_TIMING_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_CAS_TIMING >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC_TIMING_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC_TIMING >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC_TIMING2_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC_TIMING2 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RD_CTL_D0_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RD_CTL_D0 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RD_CTL_D1_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RD_CTL_D1 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_WR_CTL_D0_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_WR_CTL_D0 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_WR_CTL_D1_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_WR_CTL_D1 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_EMRS >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_MRS >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_MRS1 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC1 >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC1 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RESERVE_M >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RESERVE_M >> 2;\r\ni++;\r\neg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC3 >> 2;\r\neg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC3 >> 2;\r\ni++;\r\neg_pi->mc_reg_table.last = (u8)i;\r\n}\r\nstatic void cypress_retrieve_ac_timing_for_one_entry(struct radeon_device *rdev,\r\nstruct evergreen_mc_reg_entry *entry)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 i;\r\nfor (i = 0; i < eg_pi->mc_reg_table.last; i++)\r\nentry->mc_data[i] =\r\nRREG32(eg_pi->mc_reg_table.mc_reg_address[i].s1 << 2);\r\n}\r\nstatic void cypress_retrieve_ac_timing_for_all_ranges(struct radeon_device *rdev,\r\nstruct atom_memory_clock_range_table *range_table)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 i, j;\r\nfor (i = 0; i < range_table->num_entries; i++) {\r\neg_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max =\r\nrange_table->mclk[i];\r\nradeon_atom_set_ac_timing(rdev, range_table->mclk[i]);\r\ncypress_retrieve_ac_timing_for_one_entry(rdev,\r\n&eg_pi->mc_reg_table.mc_reg_table_entry[i]);\r\n}\r\neg_pi->mc_reg_table.num_entries = range_table->num_entries;\r\neg_pi->mc_reg_table.valid_flag = 0;\r\nfor (i = 0; i < eg_pi->mc_reg_table.last; i++) {\r\nfor (j = 1; j < range_table->num_entries; j++) {\r\nif (eg_pi->mc_reg_table.mc_reg_table_entry[j-1].mc_data[i] !=\r\neg_pi->mc_reg_table.mc_reg_table_entry[j].mc_data[i]) {\r\neg_pi->mc_reg_table.valid_flag |= (1 << i);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int cypress_initialize_mc_reg_table(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu8 module_index = rv770_get_memory_module_index(rdev);\r\nstruct atom_memory_clock_range_table range_table = { 0 };\r\nint ret;\r\nret = radeon_atom_get_mclk_range_table(rdev,\r\npi->mem_gddr5,\r\nmodule_index, &range_table);\r\nif (ret)\r\nreturn ret;\r\ncypress_retrieve_ac_timing_for_all_ranges(rdev, &range_table);\r\nreturn 0;\r\n}\r\nstatic void cypress_wait_for_mc_sequencer(struct radeon_device *rdev, u8 value)\r\n{\r\nu32 i, j;\r\nu32 channels = 2;\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK))\r\nchannels = 4;\r\nelse if (rdev->family == CHIP_CEDAR)\r\nchannels = 1;\r\nfor (i = 0; i < channels; i++) {\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK)) {\r\nWREG32_P(MC_CONFIG_MCD, MC_RD_ENABLE_MCD(i), ~MC_RD_ENABLE_MCD_MASK);\r\nWREG32_P(MC_CG_CONFIG_MCD, MC_RD_ENABLE_MCD(i), ~MC_RD_ENABLE_MCD_MASK);\r\n} else {\r\nWREG32_P(MC_CONFIG, MC_RD_ENABLE(i), ~MC_RD_ENABLE_MASK);\r\nWREG32_P(MC_CG_CONFIG, MC_RD_ENABLE(i), ~MC_RD_ENABLE_MASK);\r\n}\r\nfor (j = 0; j < rdev->usec_timeout; j++) {\r\nif (((RREG32(MC_SEQ_CG) & CG_SEQ_RESP_MASK) >> CG_SEQ_RESP_SHIFT) == value)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic void cypress_force_mc_use_s1(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\r\nu32 strobe_mode;\r\nu32 mc_seq_cg;\r\nint i;\r\nif (RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE)\r\nreturn;\r\nradeon_atom_set_ac_timing(rdev, boot_state->low.mclk);\r\nradeon_mc_wait_for_idle(rdev);\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK)) {\r\nWREG32(MC_CONFIG_MCD, 0xf);\r\nWREG32(MC_CG_CONFIG_MCD, 0xf);\r\n} else {\r\nWREG32(MC_CONFIG, 0xf);\r\nWREG32(MC_CG_CONFIG, 0xf);\r\n}\r\nfor (i = 0; i < rdev->num_crtc; i++)\r\nradeon_wait_for_vblank(rdev, i);\r\nWREG32(MC_SEQ_CG, MC_CG_SEQ_YCLK_SUSPEND);\r\ncypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_SUSPEND);\r\nstrobe_mode = cypress_get_strobe_mode_settings(rdev,\r\nboot_state->low.mclk);\r\nmc_seq_cg = CG_SEQ_REQ(MC_CG_SEQ_DRAMCONF_S1);\r\nmc_seq_cg |= SEQ_CG_RESP(strobe_mode);\r\nWREG32(MC_SEQ_CG, mc_seq_cg);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE)\r\nbreak;\r\nudelay(1);\r\n}\r\nmc_seq_cg &= ~CG_SEQ_REQ_MASK;\r\nmc_seq_cg |= CG_SEQ_REQ(MC_CG_SEQ_YCLK_RESUME);\r\nWREG32(MC_SEQ_CG, mc_seq_cg);\r\ncypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_RESUME);\r\n}\r\nstatic void cypress_copy_ac_timing_from_s1_to_s0(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 value;\r\nu32 i;\r\nfor (i = 0; i < eg_pi->mc_reg_table.last; i++) {\r\nvalue = RREG32(eg_pi->mc_reg_table.mc_reg_address[i].s1 << 2);\r\nWREG32(eg_pi->mc_reg_table.mc_reg_address[i].s0 << 2, value);\r\n}\r\n}\r\nstatic void cypress_force_mc_use_s0(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\r\nu32 strobe_mode;\r\nu32 mc_seq_cg;\r\nint i;\r\ncypress_copy_ac_timing_from_s1_to_s0(rdev);\r\nradeon_mc_wait_for_idle(rdev);\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK)) {\r\nWREG32(MC_CONFIG_MCD, 0xf);\r\nWREG32(MC_CG_CONFIG_MCD, 0xf);\r\n} else {\r\nWREG32(MC_CONFIG, 0xf);\r\nWREG32(MC_CG_CONFIG, 0xf);\r\n}\r\nfor (i = 0; i < rdev->num_crtc; i++)\r\nradeon_wait_for_vblank(rdev, i);\r\nWREG32(MC_SEQ_CG, MC_CG_SEQ_YCLK_SUSPEND);\r\ncypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_SUSPEND);\r\nstrobe_mode = cypress_get_strobe_mode_settings(rdev,\r\nboot_state->low.mclk);\r\nmc_seq_cg = CG_SEQ_REQ(MC_CG_SEQ_DRAMCONF_S0);\r\nmc_seq_cg |= SEQ_CG_RESP(strobe_mode);\r\nWREG32(MC_SEQ_CG, mc_seq_cg);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (!(RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE))\r\nbreak;\r\nudelay(1);\r\n}\r\nmc_seq_cg &= ~CG_SEQ_REQ_MASK;\r\nmc_seq_cg |= CG_SEQ_REQ(MC_CG_SEQ_YCLK_RESUME);\r\nWREG32(MC_SEQ_CG, mc_seq_cg);\r\ncypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_RESUME);\r\n}\r\nstatic int cypress_populate_initial_mvdd_value(struct radeon_device *rdev,\r\nRV770_SMC_VOLTAGE_VALUE *voltage)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nvoltage->index = eg_pi->mvdd_high_index;\r\nvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\r\nreturn 0;\r\n}\r\nint cypress_populate_smc_initial_state(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_initial_state,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_ps *initial_state = rv770_get_ps(radeon_initial_state);\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 a_t;\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl_2);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl_2);\r\ntable->initialState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.mclk_pwrmgt_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vDLL_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.dll_cntl);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_SS =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ss1);\r\ntable->initialState.levels[0].mclk.mclk770.vMPLL_SS2 =\r\ncpu_to_be32(pi->clk_regs.rv770.mpll_ss2);\r\ntable->initialState.levels[0].mclk.mclk770.mclk_value =\r\ncpu_to_be32(initial_state->low.mclk);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_2);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_3);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum);\r\ntable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =\r\ncpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum_2);\r\ntable->initialState.levels[0].sclk.sclk_value =\r\ncpu_to_be32(initial_state->low.sclk);\r\ntable->initialState.levels[0].arbValue = MC_CG_ARB_FREQ_F0;\r\ntable->initialState.levels[0].ACIndex = 0;\r\ncypress_populate_voltage_value(rdev,\r\n&eg_pi->vddc_voltage_table,\r\ninitial_state->low.vddc,\r\n&table->initialState.levels[0].vddc);\r\nif (eg_pi->vddci_control)\r\ncypress_populate_voltage_value(rdev,\r\n&eg_pi->vddci_voltage_table,\r\ninitial_state->low.vddci,\r\n&table->initialState.levels[0].vddci);\r\ncypress_populate_initial_mvdd_value(rdev,\r\n&table->initialState.levels[0].mvdd);\r\na_t = CG_R(0xffff) | CG_L(0);\r\ntable->initialState.levels[0].aT = cpu_to_be32(a_t);\r\ntable->initialState.levels[0].bSP = cpu_to_be32(pi->dsp);\r\nif (pi->boot_in_gen2)\r\ntable->initialState.levels[0].gen2PCIE = 1;\r\nelse\r\ntable->initialState.levels[0].gen2PCIE = 0;\r\nif (initial_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\r\ntable->initialState.levels[0].gen2XSP = 1;\r\nelse\r\ntable->initialState.levels[0].gen2XSP = 0;\r\nif (pi->mem_gddr5) {\r\ntable->initialState.levels[0].strobeMode =\r\ncypress_get_strobe_mode_settings(rdev,\r\ninitial_state->low.mclk);\r\nif (initial_state->low.mclk > pi->mclk_edc_enable_threshold)\r\ntable->initialState.levels[0].mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\r\nelse\r\ntable->initialState.levels[0].mcFlags = 0;\r\n}\r\ntable->initialState.levels[1] = table->initialState.levels[0];\r\ntable->initialState.levels[2] = table->initialState.levels[0];\r\ntable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\r\nreturn 0;\r\n}\r\nint cypress_populate_smc_acpi_state(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 mpll_ad_func_cntl =\r\npi->clk_regs.rv770.mpll_ad_func_cntl;\r\nu32 mpll_ad_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_ad_func_cntl_2;\r\nu32 mpll_dq_func_cntl =\r\npi->clk_regs.rv770.mpll_dq_func_cntl;\r\nu32 mpll_dq_func_cntl_2 =\r\npi->clk_regs.rv770.mpll_dq_func_cntl_2;\r\nu32 spll_func_cntl =\r\npi->clk_regs.rv770.cg_spll_func_cntl;\r\nu32 spll_func_cntl_2 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_2;\r\nu32 spll_func_cntl_3 =\r\npi->clk_regs.rv770.cg_spll_func_cntl_3;\r\nu32 mclk_pwrmgt_cntl =\r\npi->clk_regs.rv770.mclk_pwrmgt_cntl;\r\nu32 dll_cntl =\r\npi->clk_regs.rv770.dll_cntl;\r\ntable->ACPIState = table->initialState;\r\ntable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\nif (pi->acpi_vddc) {\r\ncypress_populate_voltage_value(rdev,\r\n&eg_pi->vddc_voltage_table,\r\npi->acpi_vddc,\r\n&table->ACPIState.levels[0].vddc);\r\nif (pi->pcie_gen2) {\r\nif (pi->acpi_pcie_gen2)\r\ntable->ACPIState.levels[0].gen2PCIE = 1;\r\nelse\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\n} else\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\nif (pi->acpi_pcie_gen2)\r\ntable->ACPIState.levels[0].gen2XSP = 1;\r\nelse\r\ntable->ACPIState.levels[0].gen2XSP = 0;\r\n} else {\r\ncypress_populate_voltage_value(rdev,\r\n&eg_pi->vddc_voltage_table,\r\npi->min_vddc_in_table,\r\n&table->ACPIState.levels[0].vddc);\r\ntable->ACPIState.levels[0].gen2PCIE = 0;\r\n}\r\nif (eg_pi->acpi_vddci) {\r\nif (eg_pi->vddci_control) {\r\ncypress_populate_voltage_value(rdev,\r\n&eg_pi->vddci_voltage_table,\r\neg_pi->acpi_vddci,\r\n&table->ACPIState.levels[0].vddci);\r\n}\r\n}\r\nmpll_ad_func_cntl &= ~PDNB;\r\nmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\r\nif (pi->mem_gddr5)\r\nmpll_dq_func_cntl &= ~PDNB;\r\nmpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN | BYPASS;\r\nmclk_pwrmgt_cntl |= (MRDCKA0_RESET |\r\nMRDCKA1_RESET |\r\nMRDCKB0_RESET |\r\nMRDCKB1_RESET |\r\nMRDCKC0_RESET |\r\nMRDCKC1_RESET |\r\nMRDCKD0_RESET |\r\nMRDCKD1_RESET);\r\nmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\r\nMRDCKA1_PDNB |\r\nMRDCKB0_PDNB |\r\nMRDCKB1_PDNB |\r\nMRDCKC0_PDNB |\r\nMRDCKC1_PDNB |\r\nMRDCKD0_PDNB |\r\nMRDCKD1_PDNB);\r\ndll_cntl |= (MRDCKA0_BYPASS |\r\nMRDCKA1_BYPASS |\r\nMRDCKB0_BYPASS |\r\nMRDCKB1_BYPASS |\r\nMRDCKC0_BYPASS |\r\nMRDCKC1_BYPASS |\r\nMRDCKD0_BYPASS |\r\nMRDCKD1_BYPASS);\r\nif (rdev->family <= CHIP_HEMLOCK)\r\nspll_func_cntl |= SPLL_RESET | SPLL_SLEEP | SPLL_BYPASS_EN;\r\nspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\r\nspll_func_cntl_2 |= SCLK_MUX_SEL(4);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\r\ncpu_to_be32(mpll_ad_func_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\r\ncpu_to_be32(mpll_ad_func_cntl_2);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\r\ncpu_to_be32(mpll_dq_func_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\r\ncpu_to_be32(mpll_dq_func_cntl_2);\r\ntable->ACPIState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\r\ncpu_to_be32(mclk_pwrmgt_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\r\ntable->ACPIState.levels[0].mclk.mclk770.mclk_value = 0;\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\r\ncpu_to_be32(spll_func_cntl);\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\r\ncpu_to_be32(spll_func_cntl_2);\r\ntable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\r\ncpu_to_be32(spll_func_cntl_3);\r\ntable->ACPIState.levels[0].sclk.sclk_value = 0;\r\ncypress_populate_mvdd_value(rdev, 0, &table->ACPIState.levels[0].mvdd);\r\nif (eg_pi->dynamic_ac_timing)\r\ntable->ACPIState.levels[0].ACIndex = 1;\r\ntable->ACPIState.levels[1] = table->ACPIState.levels[0];\r\ntable->ACPIState.levels[2] = table->ACPIState.levels[0];\r\nreturn 0;\r\n}\r\nstatic void cypress_trim_voltage_table_to_fit_state_table(struct radeon_device *rdev,\r\nstruct atom_voltage_table *voltage_table)\r\n{\r\nunsigned int i, diff;\r\nif (voltage_table->count <= MAX_NO_VREG_STEPS)\r\nreturn;\r\ndiff = voltage_table->count - MAX_NO_VREG_STEPS;\r\nfor (i= 0; i < MAX_NO_VREG_STEPS; i++)\r\nvoltage_table->entries[i] = voltage_table->entries[i + diff];\r\nvoltage_table->count = MAX_NO_VREG_STEPS;\r\n}\r\nint cypress_construct_voltage_tables(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nint ret;\r\nret = radeon_atom_get_voltage_table(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0,\r\n&eg_pi->vddc_voltage_table);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->vddc_voltage_table.count > MAX_NO_VREG_STEPS)\r\ncypress_trim_voltage_table_to_fit_state_table(rdev,\r\n&eg_pi->vddc_voltage_table);\r\nif (eg_pi->vddci_control) {\r\nret = radeon_atom_get_voltage_table(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0,\r\n&eg_pi->vddci_voltage_table);\r\nif (ret)\r\nreturn ret;\r\nif (eg_pi->vddci_voltage_table.count > MAX_NO_VREG_STEPS)\r\ncypress_trim_voltage_table_to_fit_state_table(rdev,\r\n&eg_pi->vddci_voltage_table);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cypress_populate_smc_voltage_table(struct radeon_device *rdev,\r\nstruct atom_voltage_table *voltage_table,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < voltage_table->count; i++) {\r\ntable->highSMIO[i] = 0;\r\ntable->lowSMIO[i] |= cpu_to_be32(voltage_table->entries[i].smio_low);\r\n}\r\n}\r\nint cypress_populate_smc_voltage_tables(struct radeon_device *rdev,\r\nRV770_SMC_STATETABLE *table)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nunsigned char i;\r\nif (eg_pi->vddc_voltage_table.count) {\r\ncypress_populate_smc_voltage_table(rdev,\r\n&eg_pi->vddc_voltage_table,\r\ntable);\r\ntable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDC] = 0;\r\ntable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDC] =\r\ncpu_to_be32(eg_pi->vddc_voltage_table.mask_low);\r\nfor (i = 0; i < eg_pi->vddc_voltage_table.count; i++) {\r\nif (pi->max_vddc_in_table <=\r\neg_pi->vddc_voltage_table.entries[i].value) {\r\ntable->maxVDDCIndexInPPTable = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (eg_pi->vddci_voltage_table.count) {\r\ncypress_populate_smc_voltage_table(rdev,\r\n&eg_pi->vddci_voltage_table,\r\ntable);\r\ntable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDCI] = 0;\r\ntable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDCI] =\r\ncpu_to_be32(eg_pi->vddci_voltage_table.mask_low);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 cypress_get_mclk_split_point(struct atom_memory_info *memory_info)\r\n{\r\nif ((memory_info->mem_type == MEM_TYPE_GDDR3) ||\r\n(memory_info->mem_type == MEM_TYPE_DDR3))\r\nreturn 30000;\r\nreturn 0;\r\n}\r\nint cypress_get_mvdd_configuration(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu8 module_index;\r\nstruct atom_memory_info memory_info;\r\nu32 tmp = RREG32(GENERAL_PWRMGT);\r\nif (!(tmp & BACKBIAS_PAD_EN)) {\r\neg_pi->mvdd_high_index = 0;\r\neg_pi->mvdd_low_index = 1;\r\npi->mvdd_control = false;\r\nreturn 0;\r\n}\r\nif (tmp & BACKBIAS_VALUE)\r\neg_pi->mvdd_high_index = 1;\r\nelse\r\neg_pi->mvdd_high_index = 0;\r\neg_pi->mvdd_low_index =\r\n(eg_pi->mvdd_high_index == 0) ? 1 : 0;\r\nmodule_index = rv770_get_memory_module_index(rdev);\r\nif (radeon_atom_get_memory_info(rdev, module_index, &memory_info)) {\r\npi->mvdd_control = false;\r\nreturn 0;\r\n}\r\npi->mvdd_split_frequency =\r\ncypress_get_mclk_split_point(&memory_info);\r\nif (pi->mvdd_split_frequency == 0) {\r\npi->mvdd_control = false;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cypress_init_smc_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nRV770_SMC_STATETABLE *table = &pi->smc_statetable;\r\nint ret;\r\nmemset(table, 0, sizeof(RV770_SMC_STATETABLE));\r\ncypress_populate_smc_voltage_tables(rdev, table);\r\nswitch (rdev->pm.int_thermal_type) {\r\ncase THERMAL_TYPE_EVERGREEN:\r\ncase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\r\nbreak;\r\ncase THERMAL_TYPE_NONE:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\r\nbreak;\r\ndefault:\r\ntable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\r\nbreak;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (pi->mem_gddr5)\r\ntable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nret = cypress_populate_smc_initial_state(rdev, radeon_boot_state, table);\r\nif (ret)\r\nreturn ret;\r\nret = cypress_populate_smc_acpi_state(rdev, table);\r\nif (ret)\r\nreturn ret;\r\ntable->driverState = table->initialState;\r\nreturn rv770_copy_bytes_to_smc(rdev,\r\npi->state_table_start,\r\n(u8 *)table, sizeof(RV770_SMC_STATETABLE),\r\npi->sram_end);\r\n}\r\nint cypress_populate_mc_reg_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\r\nSMC_Evergreen_MCRegisters mc_reg_table = { 0 };\r\nrv770_write_smc_soft_register(rdev,\r\nRV770_SMC_SOFT_REGISTER_seq_index, 1);\r\ncypress_populate_mc_reg_addresses(rdev, &mc_reg_table);\r\ncypress_convert_mc_reg_table_entry_to_smc(rdev,\r\n&boot_state->low,\r\n&mc_reg_table.data[0]);\r\ncypress_convert_mc_registers(&eg_pi->mc_reg_table.mc_reg_table_entry[0],\r\n&mc_reg_table.data[1], eg_pi->mc_reg_table.last,\r\neg_pi->mc_reg_table.valid_flag);\r\ncypress_convert_mc_reg_table_to_smc(rdev, radeon_boot_state, &mc_reg_table);\r\nreturn rv770_copy_bytes_to_smc(rdev, eg_pi->mc_reg_table_start,\r\n(u8 *)&mc_reg_table, sizeof(SMC_Evergreen_MCRegisters),\r\npi->sram_end);\r\n}\r\nint cypress_get_table_locations(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nu32 tmp;\r\nint ret;\r\nret = rv770_read_smc_sram_dword(rdev,\r\nEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\r\nEVERGREEN_SMC_FIRMWARE_HEADER_stateTable,\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->state_table_start = (u16)tmp;\r\nret = rv770_read_smc_sram_dword(rdev,\r\nEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\r\nEVERGREEN_SMC_FIRMWARE_HEADER_softRegisters,\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->soft_regs_start = (u16)tmp;\r\nret = rv770_read_smc_sram_dword(rdev,\r\nEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\r\nEVERGREEN_SMC_FIRMWARE_HEADER_mcRegisterTable,\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\neg_pi->mc_reg_table_start = (u16)tmp;\r\nreturn 0;\r\n}\r\nvoid cypress_enable_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\r\ntmp |= (DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE) |\r\nDISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE));\r\ntmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\r\ntmp |= (DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK) |\r\nDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE));\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nstatic void cypress_program_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp, pipe;\r\nint i;\r\ntmp = RREG32(CG_DISPLAY_GAP_CNTL) & ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\r\nif (rdev->pm.dpm.new_active_crtc_count > 0)\r\ntmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\r\nelse\r\ntmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE);\r\nif (rdev->pm.dpm.new_active_crtc_count > 1)\r\ntmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\r\nelse\r\ntmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE);\r\nWREG32(CG_DISPLAY_GAP_CNTL, tmp);\r\ntmp = RREG32(DCCG_DISP_SLOW_SELECT_REG);\r\npipe = (tmp & DCCG_DISP1_SLOW_SELECT_MASK) >> DCCG_DISP1_SLOW_SELECT_SHIFT;\r\nif ((rdev->pm.dpm.new_active_crtc_count > 0) &&\r\n(!(rdev->pm.dpm.new_active_crtcs & (1 << pipe)))) {\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nif (rdev->pm.dpm.new_active_crtcs & (1 << i))\r\nbreak;\r\n}\r\nif (i == rdev->num_crtc)\r\npipe = 0;\r\nelse\r\npipe = i;\r\ntmp &= ~DCCG_DISP1_SLOW_SELECT_MASK;\r\ntmp |= DCCG_DISP1_SLOW_SELECT(pipe);\r\nWREG32(DCCG_DISP_SLOW_SELECT_REG, tmp);\r\n}\r\ncypress_notify_smc_display_change(rdev, rdev->pm.dpm.new_active_crtc_count > 0);\r\n}\r\nvoid cypress_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nrv740_read_clock_registers(rdev);\r\nrv770_read_voltage_smio_registers(rdev);\r\nrv770_get_max_vddc(rdev);\r\nrv770_get_memory_type(rdev);\r\nif (eg_pi->pcie_performance_request)\r\neg_pi->pcie_performance_request_registered = false;\r\nif (eg_pi->pcie_performance_request)\r\ncypress_advertise_gen2_capability(rdev);\r\nrv770_get_pcie_gen2_status(rdev);\r\nrv770_enable_acpi_pm(rdev);\r\n}\r\nint cypress_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nint ret;\r\nif (pi->gfx_clock_gating)\r\nrv770_restore_cgcg(rdev);\r\nif (rv770_dpm_enabled(rdev))\r\nreturn -EINVAL;\r\nif (pi->voltage_control) {\r\nrv770_enable_voltage_control(rdev, true);\r\nret = cypress_construct_voltage_tables(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_construct_voltage_tables failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pi->mvdd_control) {\r\nret = cypress_get_mvdd_configuration(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_get_mvdd_configuration failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (eg_pi->dynamic_ac_timing) {\r\ncypress_set_mc_reg_address_table(rdev);\r\ncypress_force_mc_use_s0(rdev, boot_ps);\r\nret = cypress_initialize_mc_reg_table(rdev);\r\nif (ret)\r\neg_pi->dynamic_ac_timing = false;\r\ncypress_force_mc_use_s1(rdev, boot_ps);\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\r\nrv770_enable_backbias(rdev, true);\r\nif (pi->dynamic_ss)\r\ncypress_enable_spread_spectrum(rdev, true);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, true);\r\nrv770_setup_bsp(rdev);\r\nrv770_program_git(rdev);\r\nrv770_program_tp(rdev);\r\nrv770_program_tpp(rdev);\r\nrv770_program_sstp(rdev);\r\nrv770_program_engine_speed_parameters(rdev);\r\ncypress_enable_display_gap(rdev);\r\nrv770_program_vc(rdev);\r\nif (pi->dynamic_pcie_gen2)\r\ncypress_enable_dynamic_pcie_gen2(rdev, true);\r\nret = rv770_upload_firmware(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nret = cypress_get_table_locations(rdev);\r\nif (ret) {\r\nDRM_ERROR("cypress_get_table_locations failed\n");\r\nreturn ret;\r\n}\r\nret = cypress_init_smc_table(rdev, boot_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_init_smc_table failed\n");\r\nreturn ret;\r\n}\r\nif (eg_pi->dynamic_ac_timing) {\r\nret = cypress_populate_mc_reg_table(rdev, boot_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_populate_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\ncypress_program_response_times(rdev);\r\nr7xx_start_smc(rdev);\r\nret = cypress_notify_smc_display_change(rdev, false);\r\nif (ret) {\r\nDRM_ERROR("cypress_notify_smc_display_change failed\n");\r\nreturn ret;\r\n}\r\ncypress_enable_sclk_control(rdev, true);\r\nif (eg_pi->memory_transition)\r\ncypress_enable_mclk_control(rdev, true);\r\ncypress_start_dpm(rdev);\r\nif (pi->gfx_clock_gating)\r\ncypress_gfx_clock_gating_enable(rdev, true);\r\nif (pi->mg_clock_gating)\r\ncypress_mg_clock_gating_enable(rdev, true);\r\nrv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nreturn 0;\r\n}\r\nvoid cypress_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nif (!rv770_dpm_enabled(rdev))\r\nreturn;\r\nrv770_clear_vc(rdev);\r\nif (pi->thermal_protection)\r\nrv770_enable_thermal_protection(rdev, false);\r\nif (pi->dynamic_pcie_gen2)\r\ncypress_enable_dynamic_pcie_gen2(rdev, false);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\nif (pi->gfx_clock_gating)\r\ncypress_gfx_clock_gating_enable(rdev, false);\r\nif (pi->mg_clock_gating)\r\ncypress_mg_clock_gating_enable(rdev, false);\r\nrv770_stop_dpm(rdev);\r\nr7xx_stop_smc(rdev);\r\ncypress_enable_spread_spectrum(rdev, false);\r\nif (eg_pi->dynamic_ac_timing)\r\ncypress_force_mc_use_s1(rdev, boot_ps);\r\nrv770_reset_smio_status(rdev);\r\n}\r\nint cypress_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\r\nstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\r\nint ret;\r\nret = rv770_restrict_performance_levels_before_switch(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_restrict_performance_levels_before_switch failed\n");\r\nreturn ret;\r\n}\r\nif (eg_pi->pcie_performance_request)\r\ncypress_notify_link_speed_change_before_state_change(rdev, new_ps, old_ps);\r\nrv770_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\nret = rv770_halt_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_halt_smc failed\n");\r\nreturn ret;\r\n}\r\nret = cypress_upload_sw_state(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_upload_sw_state failed\n");\r\nreturn ret;\r\n}\r\nif (eg_pi->dynamic_ac_timing) {\r\nret = cypress_upload_mc_reg_table(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("cypress_upload_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\ncypress_program_memory_timing_parameters(rdev, new_ps);\r\nret = rv770_resume_smc(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_resume_smc failed\n");\r\nreturn ret;\r\n}\r\nret = rv770_set_sw_state(rdev);\r\nif (ret) {\r\nDRM_ERROR("rv770_set_sw_state failed\n");\r\nreturn ret;\r\n}\r\nrv770_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\nif (eg_pi->pcie_performance_request)\r\ncypress_notify_link_speed_change_after_state_change(rdev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nvoid cypress_dpm_reset_asic(struct radeon_device *rdev)\r\n{\r\nrv770_restrict_performance_levels_before_switch(rdev);\r\nrv770_set_boot_state(rdev);\r\n}\r\nvoid cypress_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\ncypress_program_display_gap(rdev);\r\n}\r\nint cypress_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi;\r\nstruct evergreen_power_info *eg_pi;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\neg_pi = kzalloc(sizeof(struct evergreen_power_info), GFP_KERNEL);\r\nif (eg_pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = eg_pi;\r\npi = &eg_pi->rv7xx;\r\nrv770_get_max_vddc(rdev);\r\neg_pi->ulv.supported = false;\r\npi->acpi_vddc = 0;\r\neg_pi->acpi_vddci = 0;\r\npi->min_vddc_in_table = 0;\r\npi->max_vddc_in_table = 0;\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = rv7xx_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->pm.dpm.voltage_response_time == 0)\r\nrdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\r\nif (rdev->pm.dpm.backbias_response_time == 0)\r\nrdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\n0, false, &dividers);\r\nif (ret)\r\npi->ref_div = dividers.ref_div + 1;\r\nelse\r\npi->ref_div = R600_REFERENCEDIVIDER_DFLT;\r\npi->mclk_strobe_mode_threshold = 40000;\r\npi->mclk_edc_enable_threshold = 40000;\r\neg_pi->mclk_edc_wr_enable_threshold = 40000;\r\npi->rlp = RV770_RLP_DFLT;\r\npi->rmp = RV770_RMP_DFLT;\r\npi->lhp = RV770_LHP_DFLT;\r\npi->lmp = RV770_LMP_DFLT;\r\npi->voltage_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\r\npi->mvdd_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\r\neg_pi->vddci_control =\r\nradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0);\r\nrv770_get_engine_memory_ss(rdev);\r\npi->asi = RV770_ASI_DFLT;\r\npi->pasi = CYPRESS_HASI_DFLT;\r\npi->vrc = CYPRESS_VRC_DFLT;\r\npi->power_gating = false;\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK))\r\npi->gfx_clock_gating = false;\r\nelse\r\npi->gfx_clock_gating = true;\r\npi->mg_clock_gating = true;\r\npi->mgcgtssm = true;\r\neg_pi->ls_clock_gating = false;\r\neg_pi->sclk_deep_sleep = false;\r\npi->dynamic_pcie_gen2 = true;\r\nif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->display_gap = true;\r\nif (rdev->flags & RADEON_IS_MOBILITY)\r\npi->dcodt = true;\r\nelse\r\npi->dcodt = false;\r\npi->ulps = true;\r\neg_pi->dynamic_ac_timing = true;\r\neg_pi->abm = true;\r\neg_pi->mcls = true;\r\neg_pi->light_sleep = true;\r\neg_pi->memory_transition = true;\r\n#if defined(CONFIG_ACPI)\r\neg_pi->pcie_performance_request =\r\nradeon_acpi_is_pcie_performance_request_supported(rdev);\r\n#else\r\neg_pi->pcie_performance_request = false;\r\n#endif\r\nif ((rdev->family == CHIP_CYPRESS) ||\r\n(rdev->family == CHIP_HEMLOCK) ||\r\n(rdev->family == CHIP_JUNIPER))\r\neg_pi->dll_default_on = true;\r\nelse\r\neg_pi->dll_default_on = false;\r\neg_pi->sclk_deep_sleep = false;\r\npi->mclk_stutter_mode_threshold = 0;\r\npi->sram_end = SMC_RAM_END;\r\nreturn 0;\r\n}\r\nvoid cypress_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\n}\r\nbool cypress_dpm_vblank_too_short(struct radeon_device *rdev)\r\n{\r\nstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\r\nu32 vblank_time = r600_dpm_get_vblank_time(rdev);\r\nu32 switch_limit = pi->mem_gddr5 ? 450 : 0;\r\nif (vblank_time < switch_limit)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}
