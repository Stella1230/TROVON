static ssize_t adis16136_show_serial(struct file *file,\r\nchar __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct adis16136 *adis16136 = file->private_data;\r\nuint16_t lot1, lot2, lot3, serial;\r\nchar buf[20];\r\nsize_t len;\r\nint ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_SERIAL_NUM,\r\n&serial);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT1, &lot1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT2, &lot2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT3, &lot3);\r\nif (ret < 0)\r\nreturn ret;\r\nlen = snprintf(buf, sizeof(buf), "%.4x%.4x%.4x-%.4x\n", lot1, lot2,\r\nlot3, serial);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\r\n}\r\nstatic int adis16136_show_product_id(void *arg, u64 *val)\r\n{\r\nstruct adis16136 *adis16136 = arg;\r\nu16 prod_id;\r\nint ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_PROD_ID,\r\n&prod_id);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = prod_id;\r\nreturn 0;\r\n}\r\nstatic int adis16136_show_flash_count(void *arg, u64 *val)\r\n{\r\nstruct adis16136 *adis16136 = arg;\r\nuint16_t flash_count;\r\nint ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_FLASH_CNT,\r\n&flash_count);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = flash_count;\r\nreturn 0;\r\n}\r\nstatic int adis16136_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\ndebugfs_create_file("serial_number", 0400, indio_dev->debugfs_dentry,\r\nadis16136, &adis16136_serial_fops);\r\ndebugfs_create_file("product_id", 0400, indio_dev->debugfs_dentry,\r\nadis16136, &adis16136_product_id_fops);\r\ndebugfs_create_file("flash_count", 0400, indio_dev->debugfs_dentry,\r\nadis16136, &adis16136_flash_count_fops);\r\nreturn 0;\r\n}\r\nstatic int adis16136_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int adis16136_set_freq(struct adis16136 *adis16136, unsigned int freq)\r\n{\r\nunsigned int t;\r\nt = 32768 / freq;\r\nif (t < 0xf)\r\nt = 0xf;\r\nelse if (t > 0xffff)\r\nt = 0xffff;\r\nelse\r\nt--;\r\nreturn adis_write_reg_16(&adis16136->adis, ADIS16136_REG_SMPL_PRD, t);\r\n}\r\nstatic int adis16136_get_freq(struct adis16136 *adis16136, unsigned int *freq)\r\n{\r\nuint16_t t;\r\nint ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_SMPL_PRD, &t);\r\nif (ret < 0)\r\nreturn ret;\r\n*freq = 32768 / (t + 1);\r\nreturn 0;\r\n}\r\nstatic ssize_t adis16136_write_frequency(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nunsigned int val;\r\nint ret;\r\nret = kstrtouint(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nret = adis16136_set_freq(adis16136, val);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t adis16136_read_frequency(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nunsigned int freq;\r\nint ret;\r\nret = adis16136_get_freq(adis16136, &freq);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", freq);\r\n}\r\nstatic int adis16136_set_filter(struct iio_dev *indio_dev, int val)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nunsigned int freq;\r\nint i, ret;\r\nret = adis16136_get_freq(adis16136, &freq);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = ARRAY_SIZE(adis16136_3db_divisors) - 1; i >= 1; i--) {\r\nif (freq / adis16136_3db_divisors[i] >= val)\r\nbreak;\r\n}\r\nreturn adis_write_reg_16(&adis16136->adis, ADIS16136_REG_AVG_CNT, i);\r\n}\r\nstatic int adis16136_get_filter(struct iio_dev *indio_dev, int *val)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nunsigned int freq;\r\nuint16_t val16;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_AVG_CNT, &val16);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = adis16136_get_freq(adis16136, &freq);\r\nif (ret < 0)\r\ngoto err_unlock;\r\n*val = freq / adis16136_3db_divisors[val16 & 0x07];\r\nerr_unlock:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : IIO_VAL_INT;\r\n}\r\nstatic int adis16136_read_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *val, int *val2, long info)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nuint32_t val32;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn adis_single_conversion(indio_dev, chan, 0, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = adis16136->chip_info->precision;\r\n*val2 = (adis16136->chip_info->fullscale << 16);\r\nreturn IIO_VAL_FRACTIONAL;\r\ncase IIO_TEMP:\r\n*val = 10;\r\n*val2 = 697000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = adis_read_reg_32(&adis16136->adis,\r\nADIS16136_REG_GYRO_OFF2, &val32);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(val32, 31);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nreturn adis16136_get_filter(indio_dev, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int adis16136_write_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int val, int val2, long info)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nreturn adis_write_reg_32(&adis16136->adis,\r\nADIS16136_REG_GYRO_OFF2, val);\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nreturn adis16136_set_filter(indio_dev, val);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adis16136_stop_device(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nint ret;\r\nret = adis_write_reg_16(&adis16136->adis, ADIS16136_REG_SLP_CTRL, 0xff);\r\nif (ret)\r\ndev_err(&indio_dev->dev,\r\n"Could not power down device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int adis16136_initial_setup(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\nunsigned int device_id;\r\nuint16_t prod_id;\r\nint ret;\r\nret = adis_initial_startup(&adis16136->adis);\r\nif (ret)\r\nreturn ret;\r\nret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_PROD_ID,\r\n&prod_id);\r\nif (ret)\r\nreturn ret;\r\nsscanf(indio_dev->name, "adis%u\n", &device_id);\r\nif (prod_id != device_id)\r\ndev_warn(&indio_dev->dev, "Device ID(%u) and product ID(%u) do not match.",\r\ndevice_id, prod_id);\r\nreturn 0;\r\n}\r\nstatic int adis16136_probe(struct spi_device *spi)\r\n{\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct adis16136 *adis16136;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adis16136));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, indio_dev);\r\nadis16136 = iio_priv(indio_dev);\r\nadis16136->chip_info = &adis16136_chip_info[id->driver_data];\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->channels = adis16136_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(adis16136_channels);\r\nindio_dev->info = &adis16136_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = adis_init(&adis16136->adis, indio_dev, spi, &adis16136_data);\r\nif (ret)\r\nreturn ret;\r\nret = adis_setup_buffer_and_trigger(&adis16136->adis, indio_dev, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = adis16136_initial_setup(indio_dev);\r\nif (ret)\r\ngoto error_cleanup_buffer;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_stop_device;\r\nadis16136_debugfs_init(indio_dev);\r\nreturn 0;\r\nerror_stop_device:\r\nadis16136_stop_device(indio_dev);\r\nerror_cleanup_buffer:\r\nadis_cleanup_buffer_and_trigger(&adis16136->adis, indio_dev);\r\nreturn ret;\r\n}\r\nstatic int adis16136_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct adis16136 *adis16136 = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nadis16136_stop_device(indio_dev);\r\nadis_cleanup_buffer_and_trigger(&adis16136->adis, indio_dev);\r\nreturn 0;\r\n}
