int libcfs_ioctl_getdata(char *buf, char *end, void *arg)\r\n{\r\nstruct libcfs_ioctl_hdr *hdr;\r\nstruct libcfs_ioctl_data *data;\r\nint orig_len;\r\nhdr = (struct libcfs_ioctl_hdr *)buf;\r\ndata = (struct libcfs_ioctl_data *)buf;\r\nif (copy_from_user(buf, (void *)arg, sizeof(*hdr)))\r\nreturn -EFAULT;\r\nif (hdr->ioc_version != LIBCFS_IOCTL_VERSION) {\r\nCERROR("PORTALS: version mismatch kernel vs application\n");\r\nreturn -EINVAL;\r\n}\r\nif (hdr->ioc_len + buf >= end) {\r\nCERROR("PORTALS: user buffer exceeds kernel buffer\n");\r\nreturn -EINVAL;\r\n}\r\nif (hdr->ioc_len < sizeof(struct libcfs_ioctl_data)) {\r\nCERROR("PORTALS: user buffer too small for ioctl\n");\r\nreturn -EINVAL;\r\n}\r\norig_len = hdr->ioc_len;\r\nif (copy_from_user(buf, (void *)arg, hdr->ioc_len))\r\nreturn -EFAULT;\r\nif (orig_len != data->ioc_len)\r\nreturn -EINVAL;\r\nif (libcfs_ioctl_is_invalid(data)) {\r\nCERROR("PORTALS: ioctl not correctly formatted\n");\r\nreturn -EINVAL;\r\n}\r\nif (data->ioc_inllen1)\r\ndata->ioc_inlbuf1 = &data->ioc_bulk[0];\r\nif (data->ioc_inllen2)\r\ndata->ioc_inlbuf2 = &data->ioc_bulk[0] +\r\ncfs_size_round(data->ioc_inllen1);\r\nreturn 0;\r\n}\r\nint libcfs_ioctl_popdata(void *arg, void *data, int size)\r\n{\r\nif (copy_to_user((char *)arg, data, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nlibcfs_psdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct libcfs_device_userstate **pdu = NULL;\r\nint rc = 0;\r\nif (!inode)\r\nreturn -EINVAL;\r\npdu = (struct libcfs_device_userstate **)&file->private_data;\r\nif (libcfs_psdev_ops.p_open != NULL)\r\nrc = libcfs_psdev_ops.p_open(0, (void *)pdu);\r\nelse\r\nreturn -EPERM;\r\nreturn rc;\r\n}\r\nstatic int\r\nlibcfs_psdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct libcfs_device_userstate *pdu;\r\nint rc = 0;\r\nif (!inode)\r\nreturn -EINVAL;\r\npdu = file->private_data;\r\nif (libcfs_psdev_ops.p_close != NULL)\r\nrc = libcfs_psdev_ops.p_close(0, (void *)pdu);\r\nelse\r\nrc = -EPERM;\r\nreturn rc;\r\n}\r\nstatic long libcfs_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cfs_psdev_file pfile;\r\nint rc = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (_IOC_TYPE(cmd) != IOC_LIBCFS_TYPE ||\r\n_IOC_NR(cmd) < IOC_LIBCFS_MIN_NR ||\r\n_IOC_NR(cmd) > IOC_LIBCFS_MAX_NR) {\r\nCDEBUG(D_IOCTL, "invalid ioctl ( type %d, nr %d, size %d )\n",\r\n_IOC_TYPE(cmd), _IOC_NR(cmd), _IOC_SIZE(cmd));\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase IOC_LIBCFS_PANIC:\r\nif (!capable(CFS_CAP_SYS_BOOT))\r\nreturn -EPERM;\r\npanic("debugctl-invoked panic");\r\nreturn 0;\r\ncase IOC_LIBCFS_MEMHOG:\r\nif (!capable(CFS_CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n}\r\npfile.off = 0;\r\npfile.private_data = file->private_data;\r\nif (libcfs_psdev_ops.p_ioctl != NULL)\r\nrc = libcfs_psdev_ops.p_ioctl(&pfile, cmd, (void *)arg);\r\nelse\r\nrc = -EPERM;\r\nreturn rc;\r\n}
