static inline u32 snd_bt87x_readl(struct snd_bt87x *chip, u32 reg)\r\n{\r\nreturn readl(chip->mmio + reg);\r\n}\r\nstatic inline void snd_bt87x_writel(struct snd_bt87x *chip, u32 reg, u32 value)\r\n{\r\nwritel(value, chip->mmio + reg);\r\n}\r\nstatic int snd_bt87x_create_risc(struct snd_bt87x *chip, struct snd_pcm_substream *substream,\r\nunsigned int periods, unsigned int period_bytes)\r\n{\r\nunsigned int i, offset;\r\nu32 *risc;\r\nif (chip->dma_risc.area == NULL) {\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nPAGE_ALIGN(MAX_RISC_SIZE), &chip->dma_risc) < 0)\r\nreturn -ENOMEM;\r\n}\r\nrisc = (u32 *)chip->dma_risc.area;\r\noffset = 0;\r\n*risc++ = cpu_to_le32(RISC_SYNC | RISC_SYNC_FM1);\r\n*risc++ = cpu_to_le32(0);\r\nfor (i = 0; i < periods; ++i) {\r\nu32 rest;\r\nrest = period_bytes;\r\ndo {\r\nu32 cmd, len;\r\nunsigned int addr;\r\nlen = PAGE_SIZE - (offset % PAGE_SIZE);\r\nif (len > rest)\r\nlen = rest;\r\ncmd = RISC_WRITE | len;\r\nif (rest == period_bytes) {\r\nu32 block = i * 16 / periods;\r\ncmd |= RISC_SOL;\r\ncmd |= block << RISC_SET_STATUS_SHIFT;\r\ncmd |= (~block & 0xf) << RISC_RESET_STATUS_SHIFT;\r\n}\r\nif (len == rest)\r\ncmd |= RISC_EOL | RISC_IRQ;\r\n*risc++ = cpu_to_le32(cmd);\r\naddr = snd_pcm_sgbuf_get_addr(substream, offset);\r\n*risc++ = cpu_to_le32(addr);\r\noffset += len;\r\nrest -= len;\r\n} while (rest > 0);\r\n}\r\n*risc++ = cpu_to_le32(RISC_SYNC | RISC_SYNC_VRO);\r\n*risc++ = cpu_to_le32(0);\r\n*risc++ = cpu_to_le32(RISC_JUMP);\r\n*risc++ = cpu_to_le32(chip->dma_risc.addr);\r\nchip->line_bytes = period_bytes;\r\nchip->lines = periods;\r\nreturn 0;\r\n}\r\nstatic void snd_bt87x_free_risc(struct snd_bt87x *chip)\r\n{\r\nif (chip->dma_risc.area) {\r\nsnd_dma_free_pages(&chip->dma_risc);\r\nchip->dma_risc.area = NULL;\r\n}\r\n}\r\nstatic void snd_bt87x_pci_error(struct snd_bt87x *chip, unsigned int status)\r\n{\r\nu16 pci_status;\r\npci_read_config_word(chip->pci, PCI_STATUS, &pci_status);\r\npci_status &= PCI_STATUS_PARITY | PCI_STATUS_SIG_TARGET_ABORT |\r\nPCI_STATUS_REC_TARGET_ABORT | PCI_STATUS_REC_MASTER_ABORT |\r\nPCI_STATUS_SIG_SYSTEM_ERROR | PCI_STATUS_DETECTED_PARITY;\r\npci_write_config_word(chip->pci, PCI_STATUS, pci_status);\r\nif (pci_status != PCI_STATUS_DETECTED_PARITY)\r\ndev_err(chip->card->dev,\r\n"Aieee - PCI error! status %#08x, PCI status %#04x\n",\r\nstatus & ERROR_INTERRUPTS, pci_status);\r\nelse {\r\ndev_err(chip->card->dev,\r\n"Aieee - PCI parity error detected!\n");\r\nchip->pci_parity_errors++;\r\nif (chip->pci_parity_errors > 20) {\r\ndev_err(chip->card->dev,\r\n"Too many PCI parity errors observed.\n");\r\ndev_err(chip->card->dev,\r\n"Some device on this bus is generating bad parity.\n");\r\ndev_err(chip->card->dev,\r\n"This is an error *observed by*, not *generated by*, this card.\n");\r\ndev_err(chip->card->dev,\r\n"PCI parity error checking has been disabled.\n");\r\nchip->interrupt_mask &= ~(INT_PPERR | INT_RIPERR);\r\nsnd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t snd_bt87x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_bt87x *chip = dev_id;\r\nunsigned int status, irq_status;\r\nstatus = snd_bt87x_readl(chip, REG_INT_STAT);\r\nirq_status = status & chip->interrupt_mask;\r\nif (!irq_status)\r\nreturn IRQ_NONE;\r\nsnd_bt87x_writel(chip, REG_INT_STAT, irq_status);\r\nif (irq_status & ERROR_INTERRUPTS) {\r\nif (irq_status & (INT_FBUS | INT_FTRGT))\r\ndev_warn(chip->card->dev,\r\n"FIFO overrun, status %#08x\n", status);\r\nif (irq_status & INT_OCERR)\r\ndev_err(chip->card->dev,\r\n"internal RISC error, status %#08x\n", status);\r\nif (irq_status & (INT_PPERR | INT_RIPERR | INT_PABORT))\r\nsnd_bt87x_pci_error(chip, irq_status);\r\n}\r\nif ((irq_status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {\r\nint current_block, irq_block;\r\nchip->current_line = (chip->current_line + 1) % chip->lines;\r\ncurrent_block = chip->current_line * 16 / chip->lines;\r\nirq_block = status >> INT_RISCS_SHIFT;\r\nif (current_block != irq_block)\r\nchip->current_line = (irq_block * chip->lines + 15) / 16;\r\nsnd_pcm_period_elapsed(chip->substream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_bt87x_set_digital_hw(struct snd_bt87x *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nchip->reg_control |= CTL_DA_IOM_DA | CTL_A_PWRDN;\r\nruntime->hw = snd_bt87x_digital_hw;\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(chip->board.dig_rate);\r\nruntime->hw.rate_min = chip->board.dig_rate;\r\nruntime->hw.rate_max = chip->board.dig_rate;\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_set_analog_hw(struct snd_bt87x *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nstatic struct snd_ratnum analog_clock = {\r\n.num = ANALOG_CLOCK,\r\n.den_min = CLOCK_DIV_MIN,\r\n.den_max = CLOCK_DIV_MAX,\r\n.den_step = 1\r\n};\r\nstatic struct snd_pcm_hw_constraint_ratnums constraint_rates = {\r\n.nrats = 1,\r\n.rats = &analog_clock\r\n};\r\nchip->reg_control &= ~(CTL_DA_IOM_DA | CTL_A_PWRDN);\r\nruntime->hw = snd_bt87x_analog_hw;\r\nreturn snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&constraint_rates);\r\n}\r\nstatic int snd_bt87x_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif (test_and_set_bit(0, &chip->opened))\r\nreturn -EBUSY;\r\nif (substream->pcm->device == DEVICE_DIGITAL)\r\nerr = snd_bt87x_set_digital_hw(chip, runtime);\r\nelse\r\nerr = snd_bt87x_set_analog_hw(chip, runtime);\r\nif (err < 0)\r\ngoto _error;\r\nerr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\ngoto _error;\r\nchip->substream = substream;\r\nreturn 0;\r\n_error:\r\nclear_bit(0, &chip->opened);\r\nsmp_mb__after_atomic();\r\nreturn err;\r\n}\r\nstatic int snd_bt87x_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->reg_control |= CTL_A_PWRDN;\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->substream = NULL;\r\nclear_bit(0, &chip->opened);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_bt87x_create_risc(chip, substream,\r\nparams_periods(hw_params),\r\nparams_period_bytes(hw_params));\r\n}\r\nstatic int snd_bt87x_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nsnd_bt87x_free_risc(chip);\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint decimation;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->reg_control &= ~(CTL_DA_SDR_MASK | CTL_DA_SBR);\r\ndecimation = (ANALOG_CLOCK + runtime->rate / 4) / runtime->rate;\r\nchip->reg_control |= decimation << CTL_DA_SDR_SHIFT;\r\nif (runtime->format == SNDRV_PCM_FORMAT_S8)\r\nchip->reg_control |= CTL_DA_SBR;\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_start(struct snd_bt87x *chip)\r\n{\r\nspin_lock(&chip->reg_lock);\r\nchip->current_line = 0;\r\nchip->reg_control |= CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN;\r\nsnd_bt87x_writel(chip, REG_RISC_STRT_ADD, chip->dma_risc.addr);\r\nsnd_bt87x_writel(chip, REG_PACKET_LEN,\r\nchip->line_bytes | (chip->lines << 16));\r\nsnd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_stop(struct snd_bt87x *chip)\r\n{\r\nspin_lock(&chip->reg_lock);\r\nchip->reg_control &= ~(CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN);\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nsnd_bt87x_writel(chip, REG_INT_MASK, 0);\r\nsnd_bt87x_writel(chip, REG_INT_STAT, MY_INTERRUPTS);\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nreturn snd_bt87x_start(chip);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn snd_bt87x_stop(chip);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic snd_pcm_uframes_t snd_bt87x_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn (snd_pcm_uframes_t)bytes_to_frames(runtime, chip->current_line * chip->line_bytes);\r\n}\r\nstatic int snd_bt87x_capture_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 1;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 15;\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_capture_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nvalue->value.integer.value[0] = (chip->reg_control & CTL_A_GAIN_MASK) >> CTL_A_GAIN_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_capture_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nu32 old_control;\r\nint changed;\r\nspin_lock_irq(&chip->reg_lock);\r\nold_control = chip->reg_control;\r\nchip->reg_control = (chip->reg_control & ~CTL_A_GAIN_MASK)\r\n| (value->value.integer.value[0] << CTL_A_GAIN_SHIFT);\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nchanged = old_control != chip->reg_control;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int snd_bt87x_capture_boost_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nvalue->value.integer.value[0] = !! (chip->reg_control & CTL_A_G2X);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_capture_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nu32 old_control;\r\nint changed;\r\nspin_lock_irq(&chip->reg_lock);\r\nold_control = chip->reg_control;\r\nchip->reg_control = (chip->reg_control & ~CTL_A_G2X)\r\n| (value->value.integer.value[0] ? CTL_A_G2X : 0);\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nchanged = chip->reg_control != old_control;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int snd_bt87x_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const texts[3] = {"TV Tuner", "FM", "Mic/Line"};\r\nreturn snd_ctl_enum_info(info, 1, 3, texts);\r\n}\r\nstatic int snd_bt87x_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nvalue->value.enumerated.item[0] = (chip->reg_control & CTL_A_SEL_MASK) >> CTL_A_SEL_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\r\nu32 old_control;\r\nint changed;\r\nspin_lock_irq(&chip->reg_lock);\r\nold_control = chip->reg_control;\r\nchip->reg_control = (chip->reg_control & ~CTL_A_SEL_MASK)\r\n| (value->value.enumerated.item[0] << CTL_A_SEL_SHIFT);\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nchanged = chip->reg_control != old_control;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int snd_bt87x_free(struct snd_bt87x *chip)\r\n{\r\nif (chip->mmio)\r\nsnd_bt87x_stop(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->mmio)\r\niounmap(chip->mmio);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_bt87x_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_bt87x *chip = device->device_data;\r\nreturn snd_bt87x_free(chip);\r\n}\r\nstatic int snd_bt87x_pcm(struct snd_bt87x *chip, int device, char *name)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nerr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_bt87x_pcm_ops);\r\nreturn snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n128 * 1024,\r\nALIGN(255 * 4092, 1024));\r\n}\r\nstatic int snd_bt87x_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct snd_bt87x **rchip)\r\n{\r\nstruct snd_bt87x *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_bt87x_dev_free\r\n};\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->reg_lock);\r\nif ((err = pci_request_regions(pci, "Bt87x audio")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->mmio = pci_ioremap_bar(pci, 0);\r\nif (!chip->mmio) {\r\ndev_err(card->dev, "cannot remap io memory\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nchip->reg_control = CTL_A_PWRDN | CTL_DA_ES2 |\r\nCTL_PKTP_16 | (15 << CTL_DA_SDR_SHIFT);\r\nchip->interrupt_mask = MY_INTERRUPTS;\r\nsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\r\nsnd_bt87x_writel(chip, REG_INT_MASK, 0);\r\nsnd_bt87x_writel(chip, REG_INT_STAT, MY_INTERRUPTS);\r\nerr = request_irq(pci->irq, snd_bt87x_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot grab irq %d\n", pci->irq);\r\ngoto fail;\r\n}\r\nchip->irq = pci->irq;\r\npci_set_master(pci);\r\nsynchronize_irq(chip->irq);\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0)\r\ngoto fail;\r\n*rchip = chip;\r\nreturn 0;\r\nfail:\r\nsnd_bt87x_free(chip);\r\nreturn err;\r\n}\r\nstatic int snd_bt87x_detect_card(struct pci_dev *pci)\r\n{\r\nint i;\r\nconst struct pci_device_id *supported;\r\nsupported = pci_match_id(snd_bt87x_ids, pci);\r\nif (supported && supported->driver_data > 0)\r\nreturn supported->driver_data;\r\nfor (i = 0; i < ARRAY_SIZE(blacklist); ++i)\r\nif (blacklist[i].subvendor == pci->subsystem_vendor &&\r\nblacklist[i].subdevice == pci->subsystem_device) {\r\ndev_dbg(&pci->dev,\r\n"card %#04x-%#04x:%#04x has no audio\n",\r\npci->device, pci->subsystem_vendor, pci->subsystem_device);\r\nreturn -EBUSY;\r\n}\r\ndev_info(&pci->dev, "unknown card %#04x-%#04x:%#04x\n",\r\npci->device, pci->subsystem_vendor, pci->subsystem_device);\r\ndev_info(&pci->dev, "please mail id, board name, and, "\r\n"if it works, the correct digital_rate option to "\r\n"<alsa-devel@alsa-project.org>\n");\r\nreturn SND_BT87X_BOARD_UNKNOWN;\r\n}\r\nstatic int snd_bt87x_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_bt87x *chip;\r\nint err;\r\nenum snd_bt87x_boardid boardid;\r\nif (!pci_id->driver_data) {\r\nerr = snd_bt87x_detect_card(pci);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nboardid = err;\r\n} else\r\nboardid = pci_id->driver_data;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\n++dev;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_bt87x_create(card, pci, &chip);\r\nif (err < 0)\r\ngoto _error;\r\nmemcpy(&chip->board, &snd_bt87x_boards[boardid], sizeof(chip->board));\r\nif (!chip->board.no_digital) {\r\nif (digital_rate[dev] > 0)\r\nchip->board.dig_rate = digital_rate[dev];\r\nchip->reg_control |= chip->board.digital_fmt;\r\nerr = snd_bt87x_pcm(chip, DEVICE_DIGITAL, "Bt87x Digital");\r\nif (err < 0)\r\ngoto _error;\r\n}\r\nif (!chip->board.no_analog) {\r\nerr = snd_bt87x_pcm(chip, DEVICE_ANALOG, "Bt87x Analog");\r\nif (err < 0)\r\ngoto _error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(\r\n&snd_bt87x_capture_volume, chip));\r\nif (err < 0)\r\ngoto _error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(\r\n&snd_bt87x_capture_boost, chip));\r\nif (err < 0)\r\ngoto _error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(\r\n&snd_bt87x_capture_source, chip));\r\nif (err < 0)\r\ngoto _error;\r\n}\r\ndev_info(card->dev, "bt87x%d: Using board %d, %sanalog, %sdigital "\r\n"(rate %d Hz)\n", dev, boardid,\r\nchip->board.no_analog ? "no " : "",\r\nchip->board.no_digital ? "no " : "", chip->board.dig_rate);\r\nstrcpy(card->driver, "Bt87x");\r\nsprintf(card->shortname, "Brooktree Bt%x", pci->device);\r\nsprintf(card->longname, "%s at %#llx, irq %i",\r\ncard->shortname, (unsigned long long)pci_resource_start(pci, 0),\r\nchip->irq);\r\nstrcpy(card->mixername, "Bt87x");\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto _error;\r\npci_set_drvdata(pci, card);\r\n++dev;\r\nreturn 0;\r\n_error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_bt87x_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int __init alsa_card_bt87x_init(void)\r\n{\r\nif (load_all)\r\ndriver.id_table = snd_bt87x_default_ids;\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit alsa_card_bt87x_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n}
