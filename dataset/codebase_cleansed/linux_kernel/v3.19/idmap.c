void nfs_fattr_init_names(struct nfs_fattr *fattr,\r\nstruct nfs4_string *owner_name,\r\nstruct nfs4_string *group_name)\r\n{\r\nfattr->owner_name = owner_name;\r\nfattr->group_name = group_name;\r\n}\r\nstatic void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\r\n{\r\nfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\r\nkfree(fattr->owner_name->data);\r\n}\r\nstatic void nfs_fattr_free_group_name(struct nfs_fattr *fattr)\r\n{\r\nfattr->valid &= ~NFS_ATTR_FATTR_GROUP_NAME;\r\nkfree(fattr->group_name->data);\r\n}\r\nstatic bool nfs_fattr_map_owner_name(struct nfs_server *server, struct nfs_fattr *fattr)\r\n{\r\nstruct nfs4_string *owner = fattr->owner_name;\r\nkuid_t uid;\r\nif (!(fattr->valid & NFS_ATTR_FATTR_OWNER_NAME))\r\nreturn false;\r\nif (nfs_map_name_to_uid(server, owner->data, owner->len, &uid) == 0) {\r\nfattr->uid = uid;\r\nfattr->valid |= NFS_ATTR_FATTR_OWNER;\r\n}\r\nreturn true;\r\n}\r\nstatic bool nfs_fattr_map_group_name(struct nfs_server *server, struct nfs_fattr *fattr)\r\n{\r\nstruct nfs4_string *group = fattr->group_name;\r\nkgid_t gid;\r\nif (!(fattr->valid & NFS_ATTR_FATTR_GROUP_NAME))\r\nreturn false;\r\nif (nfs_map_group_to_gid(server, group->data, group->len, &gid) == 0) {\r\nfattr->gid = gid;\r\nfattr->valid |= NFS_ATTR_FATTR_GROUP;\r\n}\r\nreturn true;\r\n}\r\nvoid nfs_fattr_free_names(struct nfs_fattr *fattr)\r\n{\r\nif (fattr->valid & NFS_ATTR_FATTR_OWNER_NAME)\r\nnfs_fattr_free_owner_name(fattr);\r\nif (fattr->valid & NFS_ATTR_FATTR_GROUP_NAME)\r\nnfs_fattr_free_group_name(fattr);\r\n}\r\nvoid nfs_fattr_map_and_free_names(struct nfs_server *server, struct nfs_fattr *fattr)\r\n{\r\nif (nfs_fattr_map_owner_name(server, fattr))\r\nnfs_fattr_free_owner_name(fattr);\r\nif (nfs_fattr_map_group_name(server, fattr))\r\nnfs_fattr_free_group_name(fattr);\r\n}\r\nstatic int nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\r\n{\r\nunsigned long val;\r\nchar buf[16];\r\nif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\r\nreturn 0;\r\nmemcpy(buf, name, namelen);\r\nbuf[namelen] = '\0';\r\nif (kstrtoul(buf, 0, &val) != 0)\r\nreturn 0;\r\n*res = val;\r\nreturn 1;\r\n}\r\nstatic int nfs_map_numeric_to_string(__u32 id, char *buf, size_t buflen)\r\n{\r\nreturn snprintf(buf, buflen, "%u", id);\r\n}\r\nstatic int nfs_idmap_init_keyring(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret = 0;\r\nprintk(KERN_NOTICE "NFS: Registering the %s key type\n",\r\nkey_type_id_resolver.name);\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = keyring_alloc(".id_resolver",\r\nGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = register_key_type(&key_type_id_resolver);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nret = register_key_type(&key_type_id_resolver_legacy);\r\nif (ret < 0)\r\ngoto failed_reg_legacy;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\nid_resolver_cache = cred;\r\nreturn 0;\r\nfailed_reg_legacy:\r\nunregister_key_type(&key_type_id_resolver);\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nstatic void nfs_idmap_quit_keyring(void)\r\n{\r\nkey_revoke(id_resolver_cache->thread_keyring);\r\nunregister_key_type(&key_type_id_resolver);\r\nunregister_key_type(&key_type_id_resolver_legacy);\r\nput_cred(id_resolver_cache);\r\n}\r\nstatic ssize_t nfs_idmap_get_desc(const char *name, size_t namelen,\r\nconst char *type, size_t typelen, char **desc)\r\n{\r\nchar *cp;\r\nsize_t desclen = typelen + namelen + 2;\r\n*desc = kmalloc(desclen, GFP_KERNEL);\r\nif (!*desc)\r\nreturn -ENOMEM;\r\ncp = *desc;\r\nmemcpy(cp, type, typelen);\r\ncp += typelen;\r\n*cp++ = ':';\r\nmemcpy(cp, name, namelen);\r\ncp += namelen;\r\n*cp = '\0';\r\nreturn desclen;\r\n}\r\nstatic struct key *nfs_idmap_request_key(const char *name, size_t namelen,\r\nconst char *type, struct idmap *idmap)\r\n{\r\nchar *desc;\r\nstruct key *rkey;\r\nssize_t ret;\r\nret = nfs_idmap_get_desc(name, namelen, type, strlen(type), &desc);\r\nif (ret <= 0)\r\nreturn ERR_PTR(ret);\r\nrkey = request_key(&key_type_id_resolver, desc, "");\r\nif (IS_ERR(rkey)) {\r\nmutex_lock(&idmap->idmap_mutex);\r\nrkey = request_key_with_auxdata(&key_type_id_resolver_legacy,\r\ndesc, "", 0, idmap);\r\nmutex_unlock(&idmap->idmap_mutex);\r\n}\r\nif (!IS_ERR(rkey))\r\nset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\r\nkfree(desc);\r\nreturn rkey;\r\n}\r\nstatic ssize_t nfs_idmap_get_key(const char *name, size_t namelen,\r\nconst char *type, void *data,\r\nsize_t data_size, struct idmap *idmap)\r\n{\r\nconst struct cred *saved_cred;\r\nstruct key *rkey;\r\nstruct user_key_payload *payload;\r\nssize_t ret;\r\nsaved_cred = override_creds(id_resolver_cache);\r\nrkey = nfs_idmap_request_key(name, namelen, type, idmap);\r\nrevert_creds(saved_cred);\r\nif (IS_ERR(rkey)) {\r\nret = PTR_ERR(rkey);\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nrkey->perm |= KEY_USR_VIEW;\r\nret = key_validate(rkey);\r\nif (ret < 0)\r\ngoto out_up;\r\npayload = rcu_dereference(rkey->payload.rcudata);\r\nif (IS_ERR_OR_NULL(payload)) {\r\nret = PTR_ERR(payload);\r\ngoto out_up;\r\n}\r\nret = payload->datalen;\r\nif (ret > 0 && ret <= data_size)\r\nmemcpy(data, payload->data, ret);\r\nelse\r\nret = -EINVAL;\r\nout_up:\r\nrcu_read_unlock();\r\nkey_put(rkey);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t nfs_idmap_lookup_name(__u32 id, const char *type, char *buf,\r\nsize_t buflen, struct idmap *idmap)\r\n{\r\nchar id_str[NFS_UINT_MAXLEN];\r\nint id_len;\r\nssize_t ret;\r\nid_len = snprintf(id_str, sizeof(id_str), "%u", id);\r\nret = nfs_idmap_get_key(id_str, id_len, type, buf, buflen, idmap);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int nfs_idmap_lookup_id(const char *name, size_t namelen, const char *type,\r\n__u32 *id, struct idmap *idmap)\r\n{\r\nchar id_str[NFS_UINT_MAXLEN];\r\nlong id_long;\r\nssize_t data_size;\r\nint ret = 0;\r\ndata_size = nfs_idmap_get_key(name, namelen, type, id_str, NFS_UINT_MAXLEN, idmap);\r\nif (data_size <= 0) {\r\nret = -EINVAL;\r\n} else {\r\nret = kstrtol(id_str, 10, &id_long);\r\n*id = (__u32)id_long;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nfs_idmap_pipe_destroy(struct dentry *dir,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nstruct idmap *idmap = pdo->pdo_data;\r\nstruct rpc_pipe *pipe = idmap->idmap_pipe;\r\nif (pipe->dentry) {\r\nrpc_unlink(pipe->dentry);\r\npipe->dentry = NULL;\r\n}\r\n}\r\nstatic int nfs_idmap_pipe_create(struct dentry *dir,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nstruct idmap *idmap = pdo->pdo_data;\r\nstruct rpc_pipe *pipe = idmap->idmap_pipe;\r\nstruct dentry *dentry;\r\ndentry = rpc_mkpipe_dentry(dir, "idmap", idmap, pipe);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\npipe->dentry = dentry;\r\nreturn 0;\r\n}\r\nint\r\nnfs_idmap_new(struct nfs_client *clp)\r\n{\r\nstruct idmap *idmap;\r\nstruct rpc_pipe *pipe;\r\nint error;\r\nidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\r\nif (idmap == NULL)\r\nreturn -ENOMEM;\r\nrpc_init_pipe_dir_object(&idmap->idmap_pdo,\r\n&nfs_idmap_pipe_dir_object_ops,\r\nidmap);\r\npipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\r\nif (IS_ERR(pipe)) {\r\nerror = PTR_ERR(pipe);\r\ngoto err;\r\n}\r\nidmap->idmap_pipe = pipe;\r\nmutex_init(&idmap->idmap_mutex);\r\nerror = rpc_add_pipe_dir_object(clp->cl_net,\r\n&clp->cl_rpcclient->cl_pipedir_objects,\r\n&idmap->idmap_pdo);\r\nif (error)\r\ngoto err_destroy_pipe;\r\nclp->cl_idmap = idmap;\r\nreturn 0;\r\nerr_destroy_pipe:\r\nrpc_destroy_pipe_data(idmap->idmap_pipe);\r\nerr:\r\nkfree(idmap);\r\nreturn error;\r\n}\r\nvoid\r\nnfs_idmap_delete(struct nfs_client *clp)\r\n{\r\nstruct idmap *idmap = clp->cl_idmap;\r\nif (!idmap)\r\nreturn;\r\nclp->cl_idmap = NULL;\r\nrpc_remove_pipe_dir_object(clp->cl_net,\r\n&clp->cl_rpcclient->cl_pipedir_objects,\r\n&idmap->idmap_pdo);\r\nrpc_destroy_pipe_data(idmap->idmap_pipe);\r\nkfree(idmap);\r\n}\r\nint nfs_idmap_init(void)\r\n{\r\nint ret;\r\nret = nfs_idmap_init_keyring();\r\nif (ret != 0)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nvoid nfs_idmap_quit(void)\r\n{\r\nnfs_idmap_quit_keyring();\r\n}\r\nstatic int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,\r\nstruct idmap_msg *im,\r\nstruct rpc_pipe_msg *msg)\r\n{\r\nsubstring_t substr;\r\nint token, ret;\r\nim->im_type = IDMAP_TYPE_GROUP;\r\ntoken = match_token(desc, nfs_idmap_tokens, &substr);\r\nswitch (token) {\r\ncase Opt_find_uid:\r\nim->im_type = IDMAP_TYPE_USER;\r\ncase Opt_find_gid:\r\nim->im_conv = IDMAP_CONV_NAMETOID;\r\nret = match_strlcpy(im->im_name, &substr, IDMAP_NAMESZ);\r\nbreak;\r\ncase Opt_find_user:\r\nim->im_type = IDMAP_TYPE_USER;\r\ncase Opt_find_group:\r\nim->im_conv = IDMAP_CONV_IDTONAME;\r\nret = match_int(&substr, &im->im_id);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmsg->data = im;\r\nmsg->len = sizeof(struct idmap_msg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic bool\r\nnfs_idmap_prepare_pipe_upcall(struct idmap *idmap,\r\nstruct idmap_legacy_upcalldata *data)\r\n{\r\nif (idmap->idmap_upcall_data != NULL) {\r\nWARN_ON_ONCE(1);\r\nreturn false;\r\n}\r\nidmap->idmap_upcall_data = data;\r\nreturn true;\r\n}\r\nstatic void\r\nnfs_idmap_complete_pipe_upcall_locked(struct idmap *idmap, int ret)\r\n{\r\nstruct key_construction *cons = idmap->idmap_upcall_data->key_cons;\r\nkfree(idmap->idmap_upcall_data);\r\nidmap->idmap_upcall_data = NULL;\r\ncomplete_request_key(cons, ret);\r\n}\r\nstatic void\r\nnfs_idmap_abort_pipe_upcall(struct idmap *idmap, int ret)\r\n{\r\nif (idmap->idmap_upcall_data != NULL)\r\nnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\r\n}\r\nstatic int nfs_idmap_legacy_upcall(struct key_construction *cons,\r\nconst char *op,\r\nvoid *aux)\r\n{\r\nstruct idmap_legacy_upcalldata *data;\r\nstruct rpc_pipe_msg *msg;\r\nstruct idmap_msg *im;\r\nstruct idmap *idmap = (struct idmap *)aux;\r\nstruct key *key = cons->key;\r\nint ret = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto out1;\r\nmsg = &data->pipe_msg;\r\nim = &data->idmap_msg;\r\ndata->idmap = idmap;\r\ndata->key_cons = cons;\r\nret = nfs_idmap_prepare_message(key->description, idmap, im, msg);\r\nif (ret < 0)\r\ngoto out2;\r\nret = -EAGAIN;\r\nif (!nfs_idmap_prepare_pipe_upcall(idmap, data))\r\ngoto out2;\r\nret = rpc_queue_upcall(idmap->idmap_pipe, msg);\r\nif (ret < 0)\r\nnfs_idmap_abort_pipe_upcall(idmap, ret);\r\nreturn ret;\r\nout2:\r\nkfree(data);\r\nout1:\r\ncomplete_request_key(cons, ret);\r\nreturn ret;\r\n}\r\nstatic int nfs_idmap_instantiate(struct key *key, struct key *authkey, char *data, size_t datalen)\r\n{\r\nreturn key_instantiate_and_link(key, data, datalen,\r\nid_resolver_cache->thread_keyring,\r\nauthkey);\r\n}\r\nstatic int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\r\nstruct idmap_msg *upcall,\r\nstruct key *key, struct key *authkey)\r\n{\r\nchar id_str[NFS_UINT_MAXLEN];\r\nsize_t len;\r\nint ret = -ENOKEY;\r\nif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\r\ngoto out;\r\nswitch (im->im_conv) {\r\ncase IDMAP_CONV_NAMETOID:\r\nif (strcmp(upcall->im_name, im->im_name) != 0)\r\nbreak;\r\nlen = sprintf(id_str, "%d", im->im_id) + 1;\r\nret = nfs_idmap_instantiate(key, authkey, id_str, len);\r\nbreak;\r\ncase IDMAP_CONV_IDTONAME:\r\nif (upcall->im_id != im->im_id)\r\nbreak;\r\nlen = strlen(im->im_name);\r\nret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nidmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\r\n{\r\nstruct rpc_inode *rpci = RPC_I(file_inode(filp));\r\nstruct idmap *idmap = (struct idmap *)rpci->private;\r\nstruct key_construction *cons;\r\nstruct idmap_msg im;\r\nsize_t namelen_in;\r\nint ret = -ENOKEY;\r\nif (idmap->idmap_upcall_data == NULL)\r\ngoto out_noupcall;\r\ncons = idmap->idmap_upcall_data->key_cons;\r\nif (mlen != sizeof(im)) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nif (copy_from_user(&im, src, mlen) != 0) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (!(im.im_status & IDMAP_STATUS_SUCCESS)) {\r\nret = -ENOKEY;\r\ngoto out;\r\n}\r\nnamelen_in = strnlen(im.im_name, IDMAP_NAMESZ);\r\nif (namelen_in == 0 || namelen_in == IDMAP_NAMESZ) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = nfs_idmap_read_and_verify_message(&im,\r\n&idmap->idmap_upcall_data->idmap_msg,\r\ncons->key, cons->authkey);\r\nif (ret >= 0) {\r\nkey_set_timeout(cons->key, nfs_idmap_cache_timeout);\r\nret = mlen;\r\n}\r\nout:\r\nnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\r\nout_noupcall:\r\nreturn ret;\r\n}\r\nstatic void\r\nidmap_pipe_destroy_msg(struct rpc_pipe_msg *msg)\r\n{\r\nstruct idmap_legacy_upcalldata *data = container_of(msg,\r\nstruct idmap_legacy_upcalldata,\r\npipe_msg);\r\nstruct idmap *idmap = data->idmap;\r\nif (msg->errno)\r\nnfs_idmap_abort_pipe_upcall(idmap, msg->errno);\r\n}\r\nstatic void\r\nidmap_release_pipe(struct inode *inode)\r\n{\r\nstruct rpc_inode *rpci = RPC_I(inode);\r\nstruct idmap *idmap = (struct idmap *)rpci->private;\r\nnfs_idmap_abort_pipe_upcall(idmap, -EPIPE);\r\n}\r\nint nfs_map_name_to_uid(const struct nfs_server *server, const char *name, size_t namelen, kuid_t *uid)\r\n{\r\nstruct idmap *idmap = server->nfs_client->cl_idmap;\r\n__u32 id = -1;\r\nint ret = 0;\r\nif (!nfs_map_string_to_numeric(name, namelen, &id))\r\nret = nfs_idmap_lookup_id(name, namelen, "uid", &id, idmap);\r\nif (ret == 0) {\r\n*uid = make_kuid(&init_user_ns, id);\r\nif (!uid_valid(*uid))\r\nret = -ERANGE;\r\n}\r\ntrace_nfs4_map_name_to_uid(name, namelen, id, ret);\r\nreturn ret;\r\n}\r\nint nfs_map_group_to_gid(const struct nfs_server *server, const char *name, size_t namelen, kgid_t *gid)\r\n{\r\nstruct idmap *idmap = server->nfs_client->cl_idmap;\r\n__u32 id = -1;\r\nint ret = 0;\r\nif (!nfs_map_string_to_numeric(name, namelen, &id))\r\nret = nfs_idmap_lookup_id(name, namelen, "gid", &id, idmap);\r\nif (ret == 0) {\r\n*gid = make_kgid(&init_user_ns, id);\r\nif (!gid_valid(*gid))\r\nret = -ERANGE;\r\n}\r\ntrace_nfs4_map_group_to_gid(name, namelen, id, ret);\r\nreturn ret;\r\n}\r\nint nfs_map_uid_to_name(const struct nfs_server *server, kuid_t uid, char *buf, size_t buflen)\r\n{\r\nstruct idmap *idmap = server->nfs_client->cl_idmap;\r\nint ret = -EINVAL;\r\n__u32 id;\r\nid = from_kuid(&init_user_ns, uid);\r\nif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\r\nret = nfs_idmap_lookup_name(id, "user", buf, buflen, idmap);\r\nif (ret < 0)\r\nret = nfs_map_numeric_to_string(id, buf, buflen);\r\ntrace_nfs4_map_uid_to_name(buf, ret, id, ret);\r\nreturn ret;\r\n}\r\nint nfs_map_gid_to_group(const struct nfs_server *server, kgid_t gid, char *buf, size_t buflen)\r\n{\r\nstruct idmap *idmap = server->nfs_client->cl_idmap;\r\nint ret = -EINVAL;\r\n__u32 id;\r\nid = from_kgid(&init_user_ns, gid);\r\nif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\r\nret = nfs_idmap_lookup_name(id, "group", buf, buflen, idmap);\r\nif (ret < 0)\r\nret = nfs_map_numeric_to_string(id, buf, buflen);\r\ntrace_nfs4_map_gid_to_group(buf, ret, id, ret);\r\nreturn ret;\r\n}
