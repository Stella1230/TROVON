static inline struct nouveau_fence *\r\nfrom_fence(struct fence *fence)\r\n{\r\nreturn container_of(fence, struct nouveau_fence, base);\r\n}\r\nstatic inline struct nouveau_fence_chan *\r\nnouveau_fctx(struct nouveau_fence *fence)\r\n{\r\nreturn container_of(fence->base.lock, struct nouveau_fence_chan, lock);\r\n}\r\nstatic int\r\nnouveau_fence_signal(struct nouveau_fence *fence)\r\n{\r\nint drop = 0;\r\nfence_signal_locked(&fence->base);\r\nlist_del(&fence->head);\r\nrcu_assign_pointer(fence->channel, NULL);\r\nif (test_bit(FENCE_FLAG_USER_BITS, &fence->base.flags)) {\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nif (!--fctx->notify_ref)\r\ndrop = 1;\r\n}\r\nfence_put(&fence->base);\r\nreturn drop;\r\n}\r\nstatic struct nouveau_fence *\r\nnouveau_local_fence(struct fence *fence, struct nouveau_drm *drm) {\r\nstruct nouveau_fence_priv *priv = (void*)drm->fence;\r\nif (fence->ops != &nouveau_fence_ops_legacy &&\r\nfence->ops != &nouveau_fence_ops_uevent)\r\nreturn NULL;\r\nif (fence->context < priv->context_base ||\r\nfence->context >= priv->context_base + priv->contexts)\r\nreturn NULL;\r\nreturn from_fence(fence);\r\n}\r\nvoid\r\nnouveau_fence_context_del(struct nouveau_fence_chan *fctx)\r\n{\r\nstruct nouveau_fence *fence;\r\nspin_lock_irq(&fctx->lock);\r\nwhile (!list_empty(&fctx->pending)) {\r\nfence = list_entry(fctx->pending.next, typeof(*fence), head);\r\nif (nouveau_fence_signal(fence))\r\nnvif_notify_put(&fctx->notify);\r\n}\r\nspin_unlock_irq(&fctx->lock);\r\nnvif_notify_fini(&fctx->notify);\r\nfctx->dead = 1;\r\nsynchronize_rcu();\r\n}\r\nstatic void\r\nnouveau_fence_context_put(struct kref *fence_ref)\r\n{\r\nkfree(container_of(fence_ref, struct nouveau_fence_chan, fence_ref));\r\n}\r\nvoid\r\nnouveau_fence_context_free(struct nouveau_fence_chan *fctx)\r\n{\r\nkref_put(&fctx->fence_ref, nouveau_fence_context_put);\r\n}\r\nstatic int\r\nnouveau_fence_update(struct nouveau_channel *chan, struct nouveau_fence_chan *fctx)\r\n{\r\nstruct nouveau_fence *fence;\r\nint drop = 0;\r\nu32 seq = fctx->read(chan);\r\nwhile (!list_empty(&fctx->pending)) {\r\nfence = list_entry(fctx->pending.next, typeof(*fence), head);\r\nif ((int)(seq - fence->base.seqno) < 0)\r\nbreak;\r\ndrop |= nouveau_fence_signal(fence);\r\n}\r\nreturn drop;\r\n}\r\nstatic int\r\nnouveau_fence_wait_uevent_handler(struct nvif_notify *notify)\r\n{\r\nstruct nouveau_fence_chan *fctx =\r\ncontainer_of(notify, typeof(*fctx), notify);\r\nunsigned long flags;\r\nint ret = NVIF_NOTIFY_KEEP;\r\nspin_lock_irqsave(&fctx->lock, flags);\r\nif (!list_empty(&fctx->pending)) {\r\nstruct nouveau_fence *fence;\r\nstruct nouveau_channel *chan;\r\nfence = list_entry(fctx->pending.next, typeof(*fence), head);\r\nchan = rcu_dereference_protected(fence->channel, lockdep_is_held(&fctx->lock));\r\nif (nouveau_fence_update(fence->channel, fctx))\r\nret = NVIF_NOTIFY_DROP;\r\n}\r\nspin_unlock_irqrestore(&fctx->lock, flags);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_fence_context_new(struct nouveau_channel *chan, struct nouveau_fence_chan *fctx)\r\n{\r\nstruct nouveau_fence_priv *priv = (void*)chan->drm->fence;\r\nstruct nouveau_cli *cli = (void *)nvif_client(chan->object);\r\nint ret;\r\nINIT_LIST_HEAD(&fctx->flip);\r\nINIT_LIST_HEAD(&fctx->pending);\r\nspin_lock_init(&fctx->lock);\r\nfctx->context = priv->context_base + chan->chid;\r\nif (chan == chan->drm->cechan)\r\nstrcpy(fctx->name, "copy engine channel");\r\nelse if (chan == chan->drm->channel)\r\nstrcpy(fctx->name, "generic kernel channel");\r\nelse\r\nstrcpy(fctx->name, nvkm_client(&cli->base)->name);\r\nkref_init(&fctx->fence_ref);\r\nif (!priv->uevent)\r\nreturn;\r\nret = nvif_notify_init(chan->object, NULL,\r\nnouveau_fence_wait_uevent_handler, false,\r\nG82_CHANNEL_DMA_V0_NTFY_UEVENT,\r\n&(struct nvif_notify_uevent_req) { },\r\nsizeof(struct nvif_notify_uevent_req),\r\nsizeof(struct nvif_notify_uevent_rep),\r\n&fctx->notify);\r\nWARN_ON(ret);\r\n}\r\nstatic void\r\nnouveau_fence_work_handler(struct work_struct *kwork)\r\n{\r\nstruct nouveau_fence_work *work = container_of(kwork, typeof(*work), work);\r\nwork->func(work->data);\r\nkfree(work);\r\n}\r\nstatic void nouveau_fence_work_cb(struct fence *fence, struct fence_cb *cb)\r\n{\r\nstruct nouveau_fence_work *work = container_of(cb, typeof(*work), cb);\r\nschedule_work(&work->work);\r\n}\r\nvoid\r\nnouveau_fence_work(struct fence *fence,\r\nvoid (*func)(void *), void *data)\r\n{\r\nstruct nouveau_fence_work *work;\r\nif (fence_is_signaled(fence))\r\ngoto err;\r\nwork = kmalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work) {\r\nWARN_ON(nouveau_fence_wait((struct nouveau_fence *)fence,\r\ntrue, false));\r\ngoto err;\r\n}\r\nINIT_WORK(&work->work, nouveau_fence_work_handler);\r\nwork->func = func;\r\nwork->data = data;\r\nif (fence_add_callback(fence, &work->cb, nouveau_fence_work_cb) < 0)\r\ngoto err_free;\r\nreturn;\r\nerr_free:\r\nkfree(work);\r\nerr:\r\nfunc(data);\r\n}\r\nint\r\nnouveau_fence_emit(struct nouveau_fence *fence, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_fence_priv *priv = (void*)chan->drm->fence;\r\nint ret;\r\nfence->channel = chan;\r\nfence->timeout = jiffies + (15 * HZ);\r\nif (priv->uevent)\r\nfence_init(&fence->base, &nouveau_fence_ops_uevent,\r\n&fctx->lock, fctx->context, ++fctx->sequence);\r\nelse\r\nfence_init(&fence->base, &nouveau_fence_ops_legacy,\r\n&fctx->lock, fctx->context, ++fctx->sequence);\r\nkref_get(&fctx->fence_ref);\r\ntrace_fence_emit(&fence->base);\r\nret = fctx->emit(fence);\r\nif (!ret) {\r\nfence_get(&fence->base);\r\nspin_lock_irq(&fctx->lock);\r\nif (nouveau_fence_update(chan, fctx))\r\nnvif_notify_put(&fctx->notify);\r\nlist_add_tail(&fence->head, &fctx->pending);\r\nspin_unlock_irq(&fctx->lock);\r\n}\r\nreturn ret;\r\n}\r\nbool\r\nnouveau_fence_done(struct nouveau_fence *fence)\r\n{\r\nif (fence->base.ops == &nouveau_fence_ops_legacy ||\r\nfence->base.ops == &nouveau_fence_ops_uevent) {\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nstruct nouveau_channel *chan;\r\nunsigned long flags;\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->base.flags))\r\nreturn true;\r\nspin_lock_irqsave(&fctx->lock, flags);\r\nchan = rcu_dereference_protected(fence->channel, lockdep_is_held(&fctx->lock));\r\nif (chan && nouveau_fence_update(chan, fctx))\r\nnvif_notify_put(&fctx->notify);\r\nspin_unlock_irqrestore(&fctx->lock, flags);\r\n}\r\nreturn fence_is_signaled(&fence->base);\r\n}\r\nstatic long\r\nnouveau_fence_wait_legacy(struct fence *f, bool intr, long wait)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nunsigned long sleep_time = NSEC_PER_MSEC / 1000;\r\nunsigned long t = jiffies, timeout = t + wait;\r\nwhile (!nouveau_fence_done(fence)) {\r\nktime_t kt;\r\nt = jiffies;\r\nif (wait != MAX_SCHEDULE_TIMEOUT && time_after_eq(t, timeout)) {\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\n__set_current_state(intr ? TASK_INTERRUPTIBLE :\r\nTASK_UNINTERRUPTIBLE);\r\nkt = ktime_set(0, sleep_time);\r\nschedule_hrtimeout(&kt, HRTIMER_MODE_REL);\r\nsleep_time *= 2;\r\nif (sleep_time > NSEC_PER_MSEC)\r\nsleep_time = NSEC_PER_MSEC;\r\nif (intr && signal_pending(current))\r\nreturn -ERESTARTSYS;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn timeout - t;\r\n}\r\nstatic int\r\nnouveau_fence_wait_busy(struct nouveau_fence *fence, bool intr)\r\n{\r\nint ret = 0;\r\nwhile (!nouveau_fence_done(fence)) {\r\nif (time_after_eq(jiffies, fence->timeout)) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n__set_current_state(intr ?\r\nTASK_INTERRUPTIBLE :\r\nTASK_UNINTERRUPTIBLE);\r\nif (intr && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_fence_wait(struct nouveau_fence *fence, bool lazy, bool intr)\r\n{\r\nlong ret;\r\nif (!lazy)\r\nreturn nouveau_fence_wait_busy(fence, intr);\r\nret = fence_wait_timeout(&fence->base, intr, 15 * HZ);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (!ret)\r\nreturn -EBUSY;\r\nelse\r\nreturn 0;\r\n}\r\nint\r\nnouveau_fence_sync(struct nouveau_bo *nvbo, struct nouveau_channel *chan, bool exclusive, bool intr)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct fence *fence;\r\nstruct reservation_object *resv = nvbo->bo.resv;\r\nstruct reservation_object_list *fobj;\r\nstruct nouveau_fence *f;\r\nint ret = 0, i;\r\nif (!exclusive) {\r\nret = reservation_object_reserve_shared(resv);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfobj = reservation_object_get_list(resv);\r\nfence = reservation_object_get_excl(resv);\r\nif (fence && (!exclusive || !fobj || !fobj->shared_count)) {\r\nstruct nouveau_channel *prev = NULL;\r\nbool must_wait = true;\r\nf = nouveau_local_fence(fence, chan->drm);\r\nif (f) {\r\nrcu_read_lock();\r\nprev = rcu_dereference(f->channel);\r\nif (prev && (prev == chan || fctx->sync(f, prev, chan) == 0))\r\nmust_wait = false;\r\nrcu_read_unlock();\r\n}\r\nif (must_wait)\r\nret = fence_wait(fence, intr);\r\nreturn ret;\r\n}\r\nif (!exclusive || !fobj)\r\nreturn ret;\r\nfor (i = 0; i < fobj->shared_count && !ret; ++i) {\r\nstruct nouveau_channel *prev = NULL;\r\nbool must_wait = true;\r\nfence = rcu_dereference_protected(fobj->shared[i],\r\nreservation_object_held(resv));\r\nf = nouveau_local_fence(fence, chan->drm);\r\nif (f) {\r\nrcu_read_lock();\r\nprev = rcu_dereference(f->channel);\r\nif (prev && (prev == chan || fctx->sync(f, prev, chan) == 0))\r\nmust_wait = false;\r\nrcu_read_unlock();\r\n}\r\nif (must_wait)\r\nret = fence_wait(fence, intr);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_fence_unref(struct nouveau_fence **pfence)\r\n{\r\nif (*pfence)\r\nfence_put(&(*pfence)->base);\r\n*pfence = NULL;\r\n}\r\nint\r\nnouveau_fence_new(struct nouveau_channel *chan, bool sysmem,\r\nstruct nouveau_fence **pfence)\r\n{\r\nstruct nouveau_fence *fence;\r\nint ret = 0;\r\nif (unlikely(!chan->fence))\r\nreturn -ENODEV;\r\nfence = kzalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence)\r\nreturn -ENOMEM;\r\nfence->sysmem = sysmem;\r\nret = nouveau_fence_emit(fence, chan);\r\nif (ret)\r\nnouveau_fence_unref(&fence);\r\n*pfence = fence;\r\nreturn ret;\r\n}\r\nstatic const char *nouveau_fence_get_get_driver_name(struct fence *fence)\r\n{\r\nreturn "nouveau";\r\n}\r\nstatic const char *nouveau_fence_get_timeline_name(struct fence *f)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nreturn !fctx->dead ? fctx->name : "dead channel";\r\n}\r\nstatic bool nouveau_fence_is_signaled(struct fence *f)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nstruct nouveau_channel *chan;\r\nbool ret = false;\r\nrcu_read_lock();\r\nchan = rcu_dereference(fence->channel);\r\nif (chan)\r\nret = (int)(fctx->read(chan) - fence->base.seqno) >= 0;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic bool nouveau_fence_no_signaling(struct fence *f)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nWARN_ON(atomic_read(&fence->base.refcount.refcount) <= 1);\r\nif (nouveau_fence_is_signaled(f)) {\r\nlist_del(&fence->head);\r\nfence_put(&fence->base);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void nouveau_fence_release(struct fence *f)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nkref_put(&fctx->fence_ref, nouveau_fence_context_put);\r\nfence_free(&fence->base);\r\n}\r\nstatic bool nouveau_fence_enable_signaling(struct fence *f)\r\n{\r\nstruct nouveau_fence *fence = from_fence(f);\r\nstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\r\nbool ret;\r\nif (!fctx->notify_ref++)\r\nnvif_notify_get(&fctx->notify);\r\nret = nouveau_fence_no_signaling(f);\r\nif (ret)\r\nset_bit(FENCE_FLAG_USER_BITS, &fence->base.flags);\r\nelse if (!--fctx->notify_ref)\r\nnvif_notify_put(&fctx->notify);\r\nreturn ret;\r\n}
