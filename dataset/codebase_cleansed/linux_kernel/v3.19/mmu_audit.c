static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\r\ninspect_spte_fn fn, int level)\r\n{\r\nint i;\r\nfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\r\nu64 *ent = sp->spt;\r\nfn(vcpu, ent + i, level);\r\nif (is_shadow_present_pte(ent[i]) &&\r\n!is_last_spte(ent[i], level)) {\r\nstruct kvm_mmu_page *child;\r\nchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\r\n__mmu_spte_walk(vcpu, child, fn, level - 1);\r\n}\r\n}\r\n}\r\nstatic void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\r\n{\r\nint i;\r\nstruct kvm_mmu_page *sp;\r\nif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\r\nreturn;\r\nif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\r\nhpa_t root = vcpu->arch.mmu.root_hpa;\r\nsp = page_header(root);\r\n__mmu_spte_walk(vcpu, sp, fn, PT64_ROOT_LEVEL);\r\nreturn;\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nhpa_t root = vcpu->arch.mmu.pae_root[i];\r\nif (root && VALID_PAGE(root)) {\r\nroot &= PT64_BASE_ADDR_MASK;\r\nsp = page_header(root);\r\n__mmu_spte_walk(vcpu, sp, fn, 2);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\r\n{\r\nstruct kvm_mmu_page *sp;\r\nlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\r\nfn(kvm, sp);\r\n}\r\nstatic void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\r\n{\r\nstruct kvm_mmu_page *sp;\r\ngfn_t gfn;\r\npfn_t pfn;\r\nhpa_t hpa;\r\nsp = page_header(__pa(sptep));\r\nif (sp->unsync) {\r\nif (level != PT_PAGE_TABLE_LEVEL) {\r\naudit_printk(vcpu->kvm, "unsync sp: %p "\r\n"level = %d\n", sp, level);\r\nreturn;\r\n}\r\n}\r\nif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\r\nreturn;\r\ngfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\r\npfn = gfn_to_pfn_atomic(vcpu->kvm, gfn);\r\nif (is_error_pfn(pfn))\r\nreturn;\r\nhpa = pfn << PAGE_SHIFT;\r\nif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\r\naudit_printk(vcpu->kvm, "levels %d pfn %llx hpa %llx "\r\n"ent %llxn", vcpu->arch.mmu.root_level, pfn,\r\nhpa, *sptep);\r\n}\r\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\r\n{\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\r\nunsigned long *rmapp;\r\nstruct kvm_mmu_page *rev_sp;\r\ngfn_t gfn;\r\nrev_sp = page_header(__pa(sptep));\r\ngfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\r\nif (!gfn_to_memslot(kvm, gfn)) {\r\nif (!__ratelimit(&ratelimit_state))\r\nreturn;\r\naudit_printk(kvm, "no memslot for gfn %llx\n", gfn);\r\naudit_printk(kvm, "index %ld of sp (gfn=%llx)\n",\r\n(long int)(sptep - rev_sp->spt), rev_sp->gfn);\r\ndump_stack();\r\nreturn;\r\n}\r\nrmapp = gfn_to_rmap(kvm, gfn, rev_sp->role.level);\r\nif (!*rmapp) {\r\nif (!__ratelimit(&ratelimit_state))\r\nreturn;\r\naudit_printk(kvm, "no rmap for writable spte %llx\n",\r\n*sptep);\r\ndump_stack();\r\n}\r\n}\r\nstatic void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\r\n{\r\nif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\r\ninspect_spte_has_rmap(vcpu->kvm, sptep);\r\n}\r\nstatic void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\r\n{\r\nstruct kvm_mmu_page *sp = page_header(__pa(sptep));\r\nif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\r\naudit_printk(vcpu->kvm, "meet unsync sp(%p) after sync "\r\n"root.\n", sp);\r\n}\r\nstatic void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\r\n{\r\nint i;\r\nif (sp->role.level != PT_PAGE_TABLE_LEVEL)\r\nreturn;\r\nfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\r\nif (!is_rmap_spte(sp->spt[i]))\r\ncontinue;\r\ninspect_spte_has_rmap(kvm, sp->spt + i);\r\n}\r\n}\r\nstatic void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\r\n{\r\nunsigned long *rmapp;\r\nu64 *sptep;\r\nstruct rmap_iterator iter;\r\nif (sp->role.direct || sp->unsync || sp->role.invalid)\r\nreturn;\r\nrmapp = gfn_to_rmap(kvm, sp->gfn, PT_PAGE_TABLE_LEVEL);\r\nfor (sptep = rmap_get_first(*rmapp, &iter); sptep;\r\nsptep = rmap_get_next(&iter)) {\r\nif (is_writable_pte(*sptep))\r\naudit_printk(kvm, "shadow page has writable "\r\n"mappings: gfn %llx role %x\n",\r\nsp->gfn, sp->role.word);\r\n}\r\n}\r\nstatic void audit_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\r\n{\r\ncheck_mappings_rmap(kvm, sp);\r\naudit_write_protection(kvm, sp);\r\n}\r\nstatic void audit_all_active_sps(struct kvm *kvm)\r\n{\r\nwalk_all_active_sps(kvm, audit_sp);\r\n}\r\nstatic void audit_spte(struct kvm_vcpu *vcpu, u64 *sptep, int level)\r\n{\r\naudit_sptes_have_rmaps(vcpu, sptep, level);\r\naudit_mappings(vcpu, sptep, level);\r\naudit_spte_after_sync(vcpu, sptep, level);\r\n}\r\nstatic void audit_vcpu_spte(struct kvm_vcpu *vcpu)\r\n{\r\nmmu_spte_walk(vcpu, audit_spte);\r\n}\r\nstatic void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\r\n{\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\r\nif (!__ratelimit(&ratelimit_state))\r\nreturn;\r\nvcpu->kvm->arch.audit_point = point;\r\naudit_all_active_sps(vcpu->kvm);\r\naudit_vcpu_spte(vcpu);\r\n}\r\nstatic inline void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\r\n{\r\nif (static_key_false((&mmu_audit_key)))\r\n__kvm_mmu_audit(vcpu, point);\r\n}\r\nstatic void mmu_audit_enable(void)\r\n{\r\nif (mmu_audit)\r\nreturn;\r\nstatic_key_slow_inc(&mmu_audit_key);\r\nmmu_audit = true;\r\n}\r\nstatic void mmu_audit_disable(void)\r\n{\r\nif (!mmu_audit)\r\nreturn;\r\nstatic_key_slow_dec(&mmu_audit_key);\r\nmmu_audit = false;\r\n}\r\nstatic int mmu_audit_set(const char *val, const struct kernel_param *kp)\r\n{\r\nint ret;\r\nunsigned long enable;\r\nret = kstrtoul(val, 10, &enable);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nswitch (enable) {\r\ncase 0:\r\nmmu_audit_disable();\r\nbreak;\r\ncase 1:\r\nmmu_audit_enable();\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
