static int powernv_eeh_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nif (!firmware_has_feature(FW_FEATURE_OPALv3)) {\r\npr_warn("%s: OPALv3 is required !\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\neeh_add_flag(EEH_PROBE_MODE_DEV);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (phb->model == PNV_PHB_MODEL_P7IOC)\r\neeh_add_flag(EEH_ENABLE_IO_FOR_LOG);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int powernv_eeh_post_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nint ret = 0;\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (phb->eeh_ops && phb->eeh_ops->post_init) {\r\nret = phb->eeh_ops->post_init(hose);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_dev_probe(struct pci_dev *dev, void *flag)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nint ret;\r\nif (!dn || !edev || edev->pe)\r\nreturn 0;\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_ISA)\r\nreturn 0;\r\nedev->class_code = dev->class;\r\nedev->mode &= 0xFFFFFF00;\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)\r\nedev->mode |= EEH_DEV_BRIDGE;\r\nedev->pcix_cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\r\nif (pci_is_pcie(dev)) {\r\nedev->pcie_cap = pci_pcie_cap(dev);\r\nif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)\r\nedev->mode |= EEH_DEV_ROOT_PORT;\r\nelse if (pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM)\r\nedev->mode |= EEH_DEV_DS_PORT;\r\nedev->aer_cap = pci_find_ext_capability(dev,\r\nPCI_EXT_CAP_ID_ERR);\r\n}\r\nedev->config_addr = ((dev->bus->number << 8) | dev->devfn);\r\nedev->pe_config_addr = phb->bdfn_to_pe(phb, dev->bus, dev->devfn & 0xff);\r\nret = eeh_add_to_parent_pe(edev);\r\nif (ret) {\r\npr_warn("%s: Can't add PCI dev %s to parent PE (%d)\n",\r\n__func__, pci_name(dev), ret);\r\nreturn ret;\r\n}\r\nif ((dev->vendor == PCI_VENDOR_ID_BROADCOM && dev->device == 0x1657) ||\r\n(dev->vendor == PCI_VENDOR_ID_BROADCOM && dev->device == 0x168e))\r\nedev->pe->state |= EEH_PE_CFG_RESTRICTED;\r\nif (!edev->pe->bus)\r\nedev->pe->bus = dev->bus;\r\neeh_add_flag(EEH_ENABLED);\r\neeh_save_bars(edev);\r\nreturn 0;\r\n}\r\nstatic int powernv_eeh_set_option(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->set_option)\r\nret = phb->eeh_ops->set_option(pe, option);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_get_pe_addr(struct eeh_pe *pe)\r\n{\r\nreturn pe->addr;\r\n}\r\nstatic int powernv_eeh_get_state(struct eeh_pe *pe, int *delay)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = EEH_STATE_NOT_SUPPORT;\r\nif (phb->eeh_ops && phb->eeh_ops->get_state) {\r\nret = phb->eeh_ops->get_state(pe);\r\nif (delay) {\r\n*delay = 0;\r\nif (ret & EEH_STATE_UNAVAILABLE)\r\n*delay = 1000;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_reset(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->reset)\r\nret = phb->eeh_ops->reset(pe, option);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_wait_state(struct eeh_pe *pe, int max_wait)\r\n{\r\nint ret;\r\nint mwait;\r\nwhile (1) {\r\nret = powernv_eeh_get_state(pe, &mwait);\r\nif (ret != EEH_STATE_UNAVAILABLE)\r\nreturn ret;\r\nmax_wait -= mwait;\r\nif (max_wait <= 0) {\r\npr_warn("%s: Timeout getting PE#%x's state (%d)\n",\r\n__func__, pe->addr, max_wait);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nmsleep(mwait);\r\n}\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nstatic int powernv_eeh_get_log(struct eeh_pe *pe, int severity,\r\nchar *drv_log, unsigned long len)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->get_log)\r\nret = phb->eeh_ops->get_log(pe, severity, drv_log, len);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_configure_bridge(struct eeh_pe *pe)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = 0;\r\nif (phb->eeh_ops && phb->eeh_ops->configure_bridge)\r\nret = phb->eeh_ops->configure_bridge(pe);\r\nreturn ret;\r\n}\r\nstatic int powernv_eeh_err_inject(struct eeh_pe *pe, int type, int func,\r\nunsigned long addr, unsigned long mask)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret = -EEXIST;\r\nif (phb->eeh_ops && phb->eeh_ops->err_inject)\r\nret = phb->eeh_ops->err_inject(pe, type, func, addr, mask);\r\nreturn ret;\r\n}\r\nstatic inline bool powernv_eeh_cfg_blocked(struct device_node *dn)\r\n{\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nif (!edev || !edev->pe)\r\nreturn false;\r\nif (edev->pe->state & EEH_PE_CFG_BLOCKED)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int powernv_eeh_read_config(struct device_node *dn,\r\nint where, int size, u32 *val)\r\n{\r\nif (powernv_eeh_cfg_blocked(dn)) {\r\n*val = 0xFFFFFFFF;\r\nreturn PCIBIOS_SET_FAILED;\r\n}\r\nreturn pnv_pci_cfg_read(dn, where, size, val);\r\n}\r\nstatic int powernv_eeh_write_config(struct device_node *dn,\r\nint where, int size, u32 val)\r\n{\r\nif (powernv_eeh_cfg_blocked(dn))\r\nreturn PCIBIOS_SET_FAILED;\r\nreturn pnv_pci_cfg_write(dn, where, size, val);\r\n}\r\nstatic int powernv_eeh_next_error(struct eeh_pe **pe)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb = NULL;\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nbreak;\r\n}\r\nif (phb && phb->eeh_ops->next_error)\r\nreturn phb->eeh_ops->next_error(pe);\r\nreturn -EEXIST;\r\n}\r\nstatic int powernv_eeh_restore_config(struct device_node *dn)\r\n{\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nstruct pnv_phb *phb;\r\ns64 ret;\r\nif (!edev)\r\nreturn -EEXIST;\r\nphb = edev->phb->private_data;\r\nret = opal_pci_reinit(phb->opal_id,\r\nOPAL_REINIT_PCI_DEV, edev->config_addr);\r\nif (ret) {\r\npr_warn("%s: Can't reinit PCI dev 0x%x (%lld)\n",\r\n__func__, edev->config_addr, ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init eeh_powernv_init(void)\r\n{\r\nint ret = -EINVAL;\r\neeh_set_pe_aux_size(PNV_PCI_DIAG_BUF_SIZE);\r\nret = eeh_ops_register(&powernv_eeh_ops);\r\nif (!ret)\r\npr_info("EEH: PowerNV platform initialized\n");\r\nelse\r\npr_info("EEH: Failed to initialize PowerNV platform (%d)\n", ret);\r\nreturn ret;\r\n}
