int nfs4_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\r\n{\r\nstruct nfs4_setclientid_res clid = {\r\n.clientid = clp->cl_clientid,\r\n.confirm = clp->cl_confirm,\r\n};\r\nunsigned short port;\r\nint status;\r\nstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\r\nif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\r\ngoto do_confirm;\r\nport = nn->nfs_callback_tcpport;\r\nif (clp->cl_addr.ss_family == AF_INET6)\r\nport = nn->nfs_callback_tcpport6;\r\nstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\r\nif (status != 0)\r\ngoto out;\r\nclp->cl_clientid = clid.clientid;\r\nclp->cl_confirm = clid.confirm;\r\nset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\ndo_confirm:\r\nstatus = nfs4_proc_setclientid_confirm(clp, &clid, cred);\r\nif (status != 0)\r\ngoto out;\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nnfs4_schedule_state_renewal(clp);\r\nout:\r\nreturn status;\r\n}\r\nint nfs40_discover_server_trunking(struct nfs_client *clp,\r\nstruct nfs_client **result,\r\nstruct rpc_cred *cred)\r\n{\r\nstruct nfs4_setclientid_res clid = {\r\n.clientid = clp->cl_clientid,\r\n.confirm = clp->cl_confirm,\r\n};\r\nstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\r\nunsigned short port;\r\nint status;\r\nport = nn->nfs_callback_tcpport;\r\nif (clp->cl_addr.ss_family == AF_INET6)\r\nport = nn->nfs_callback_tcpport6;\r\nstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\r\nif (status != 0)\r\ngoto out;\r\nclp->cl_clientid = clid.clientid;\r\nclp->cl_confirm = clid.confirm;\r\nstatus = nfs40_walk_client_list(clp, result, cred);\r\nif (status == 0) {\r\nnfs4_schedule_state_renewal(*result);\r\n}\r\nout:\r\nreturn status;\r\n}\r\nstruct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred = NULL;\r\nif (clp->cl_machine_cred != NULL)\r\ncred = get_rpccred(clp->cl_machine_cred);\r\nreturn cred;\r\n}\r\nstatic void nfs4_root_machine_cred(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred, *new;\r\nnew = rpc_lookup_machine_cred(NULL);\r\nspin_lock(&clp->cl_lock);\r\ncred = clp->cl_machine_cred;\r\nclp->cl_machine_cred = new;\r\nspin_unlock(&clp->cl_lock);\r\nif (cred != NULL)\r\nput_rpccred(cred);\r\n}\r\nstatic struct rpc_cred *\r\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\r\n{\r\nstruct rpc_cred *cred = NULL;\r\nstruct nfs4_state_owner *sp;\r\nstruct rb_node *pos;\r\nfor (pos = rb_first(&server->state_owners);\r\npos != NULL;\r\npos = rb_next(pos)) {\r\nsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\r\nif (list_empty(&sp->so_states))\r\ncontinue;\r\ncred = get_rpccred(sp->so_cred);\r\nbreak;\r\n}\r\nreturn cred;\r\n}\r\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred = NULL;\r\nstruct nfs_server *server;\r\ncred = nfs4_get_machine_cred_locked(clp);\r\nif (cred != NULL)\r\ngoto out;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\ncred = nfs4_get_renew_cred_server_locked(server);\r\nif (cred != NULL)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nout:\r\nreturn cred;\r\n}\r\nstatic void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\r\n{\r\nif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\r\nspin_lock(&tbl->slot_tbl_lock);\r\nnfs41_wake_slot_table(tbl);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\n}\r\n}\r\nstatic void nfs4_end_drain_session(struct nfs_client *clp)\r\n{\r\nstruct nfs4_session *ses = clp->cl_session;\r\nif (clp->cl_slot_tbl) {\r\nnfs4_end_drain_slot_table(clp->cl_slot_tbl);\r\nreturn;\r\n}\r\nif (ses != NULL) {\r\nnfs4_end_drain_slot_table(&ses->bc_slot_table);\r\nnfs4_end_drain_slot_table(&ses->fc_slot_table);\r\n}\r\n}\r\nstatic int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\r\n{\r\nset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\r\nspin_lock(&tbl->slot_tbl_lock);\r\nif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\r\nreinit_completion(&tbl->complete);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nreturn wait_for_completion_interruptible(&tbl->complete);\r\n}\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nreturn 0;\r\n}\r\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\r\n{\r\nstruct nfs4_session *ses = clp->cl_session;\r\nint ret = 0;\r\nif (clp->cl_slot_tbl)\r\nreturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\r\nret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\r\nif (ret)\r\nreturn ret;\r\nreturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\r\n}\r\nstatic int nfs41_setup_state_renewal(struct nfs_client *clp)\r\n{\r\nint status;\r\nstruct nfs_fsinfo fsinfo;\r\nif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\r\nnfs4_schedule_state_renewal(clp);\r\nreturn 0;\r\n}\r\nstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\r\nif (status == 0) {\r\nspin_lock(&clp->cl_lock);\r\nclp->cl_lease_time = fsinfo.lease_time * HZ;\r\nclp->cl_last_renewal = jiffies;\r\nspin_unlock(&clp->cl_lock);\r\nnfs4_schedule_state_renewal(clp);\r\n}\r\nreturn status;\r\n}\r\nstatic void nfs41_finish_session_reset(struct nfs_client *clp)\r\n{\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\r\nclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\r\nnfs41_setup_state_renewal(clp);\r\n}\r\nint nfs41_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\r\n{\r\nint status;\r\nif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\r\ngoto do_confirm;\r\nnfs4_begin_drain_session(clp);\r\nstatus = nfs4_proc_exchange_id(clp, cred);\r\nif (status != 0)\r\ngoto out;\r\nset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\ndo_confirm:\r\nstatus = nfs4_proc_create_session(clp, cred);\r\nif (status != 0)\r\ngoto out;\r\nnfs41_finish_session_reset(clp);\r\nnfs_mark_client_ready(clp, NFS_CS_READY);\r\nout:\r\nreturn status;\r\n}\r\nint nfs41_discover_server_trunking(struct nfs_client *clp,\r\nstruct nfs_client **result,\r\nstruct rpc_cred *cred)\r\n{\r\nint status;\r\nstatus = nfs4_proc_exchange_id(clp, cred);\r\nif (status != NFS4_OK)\r\nreturn status;\r\nset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nreturn nfs41_walk_client_list(clp, result, cred);\r\n}\r\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred;\r\nspin_lock(&clp->cl_lock);\r\ncred = nfs4_get_machine_cred_locked(clp);\r\nspin_unlock(&clp->cl_lock);\r\nreturn cred;\r\n}\r\nstatic struct nfs4_state_owner *\r\nnfs4_find_state_owner_locked(struct nfs_server *server, struct rpc_cred *cred)\r\n{\r\nstruct rb_node **p = &server->state_owners.rb_node,\r\n*parent = NULL;\r\nstruct nfs4_state_owner *sp;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\r\nif (cred < sp->so_cred)\r\np = &parent->rb_left;\r\nelse if (cred > sp->so_cred)\r\np = &parent->rb_right;\r\nelse {\r\nif (!list_empty(&sp->so_lru))\r\nlist_del_init(&sp->so_lru);\r\natomic_inc(&sp->so_count);\r\nreturn sp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_state_owner *\r\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\r\n{\r\nstruct nfs_server *server = new->so_server;\r\nstruct rb_node **p = &server->state_owners.rb_node,\r\n*parent = NULL;\r\nstruct nfs4_state_owner *sp;\r\nint err;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\r\nif (new->so_cred < sp->so_cred)\r\np = &parent->rb_left;\r\nelse if (new->so_cred > sp->so_cred)\r\np = &parent->rb_right;\r\nelse {\r\nif (!list_empty(&sp->so_lru))\r\nlist_del_init(&sp->so_lru);\r\natomic_inc(&sp->so_count);\r\nreturn sp;\r\n}\r\n}\r\nerr = ida_get_new(&server->openowner_id, &new->so_seqid.owner_id);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nrb_link_node(&new->so_server_node, parent, p);\r\nrb_insert_color(&new->so_server_node, &server->state_owners);\r\nreturn new;\r\n}\r\nstatic void\r\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\r\n{\r\nstruct nfs_server *server = sp->so_server;\r\nif (!RB_EMPTY_NODE(&sp->so_server_node))\r\nrb_erase(&sp->so_server_node, &server->state_owners);\r\nida_remove(&server->openowner_id, sp->so_seqid.owner_id);\r\n}\r\nstatic void\r\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\r\n{\r\nsc->create_time = ktime_get();\r\nsc->flags = 0;\r\nsc->counter = 0;\r\nspin_lock_init(&sc->lock);\r\nINIT_LIST_HEAD(&sc->list);\r\nrpc_init_wait_queue(&sc->wait, "Seqid_waitqueue");\r\n}\r\nstatic void\r\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\r\n{\r\nrpc_destroy_wait_queue(&sc->wait);\r\n}\r\nstatic struct nfs4_state_owner *\r\nnfs4_alloc_state_owner(struct nfs_server *server,\r\nstruct rpc_cred *cred,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_state_owner *sp;\r\nsp = kzalloc(sizeof(*sp), gfp_flags);\r\nif (!sp)\r\nreturn NULL;\r\nsp->so_server = server;\r\nsp->so_cred = get_rpccred(cred);\r\nspin_lock_init(&sp->so_lock);\r\nINIT_LIST_HEAD(&sp->so_states);\r\nnfs4_init_seqid_counter(&sp->so_seqid);\r\natomic_set(&sp->so_count, 1);\r\nINIT_LIST_HEAD(&sp->so_lru);\r\nseqcount_init(&sp->so_reclaim_seqcount);\r\nmutex_init(&sp->so_delegreturn_mutex);\r\nreturn sp;\r\n}\r\nstatic void\r\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\r\n{\r\nstruct rb_node *rb_node = &sp->so_server_node;\r\nif (!RB_EMPTY_NODE(rb_node)) {\r\nstruct nfs_server *server = sp->so_server;\r\nstruct nfs_client *clp = server->nfs_client;\r\nspin_lock(&clp->cl_lock);\r\nif (!RB_EMPTY_NODE(rb_node)) {\r\nrb_erase(rb_node, &server->state_owners);\r\nRB_CLEAR_NODE(rb_node);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\n}\r\n}\r\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\r\n{\r\nnfs4_destroy_seqid_counter(&sp->so_seqid);\r\nput_rpccred(sp->so_cred);\r\nkfree(sp);\r\n}\r\nstatic void nfs4_gc_state_owners(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_state_owner *sp, *tmp;\r\nunsigned long time_min, time_max;\r\nLIST_HEAD(doomed);\r\nspin_lock(&clp->cl_lock);\r\ntime_max = jiffies;\r\ntime_min = (long)time_max - (long)clp->cl_lease_time;\r\nlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\r\nif (time_in_range(sp->so_expires, time_min, time_max))\r\nbreak;\r\nlist_move(&sp->so_lru, &doomed);\r\nnfs4_remove_state_owner_locked(sp);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\r\nlist_del(&sp->so_lru);\r\nnfs4_free_state_owner(sp);\r\n}\r\n}\r\nstruct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server,\r\nstruct rpc_cred *cred,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_state_owner *sp, *new;\r\nspin_lock(&clp->cl_lock);\r\nsp = nfs4_find_state_owner_locked(server, cred);\r\nspin_unlock(&clp->cl_lock);\r\nif (sp != NULL)\r\ngoto out;\r\nnew = nfs4_alloc_state_owner(server, cred, gfp_flags);\r\nif (new == NULL)\r\ngoto out;\r\ndo {\r\nif (ida_pre_get(&server->openowner_id, gfp_flags) == 0)\r\nbreak;\r\nspin_lock(&clp->cl_lock);\r\nsp = nfs4_insert_state_owner_locked(new);\r\nspin_unlock(&clp->cl_lock);\r\n} while (sp == ERR_PTR(-EAGAIN));\r\nif (sp != new)\r\nnfs4_free_state_owner(new);\r\nout:\r\nnfs4_gc_state_owners(server);\r\nreturn sp;\r\n}\r\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\r\n{\r\nstruct nfs_server *server = sp->so_server;\r\nstruct nfs_client *clp = server->nfs_client;\r\nif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\r\nreturn;\r\nsp->so_expires = jiffies;\r\nlist_add_tail(&sp->so_lru, &server->state_owners_lru);\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nvoid nfs4_purge_state_owners(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_state_owner *sp, *tmp;\r\nLIST_HEAD(doomed);\r\nspin_lock(&clp->cl_lock);\r\nlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\r\nlist_move(&sp->so_lru, &doomed);\r\nnfs4_remove_state_owner_locked(sp);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\r\nlist_del(&sp->so_lru);\r\nnfs4_free_state_owner(sp);\r\n}\r\n}\r\nstatic struct nfs4_state *\r\nnfs4_alloc_open_state(void)\r\n{\r\nstruct nfs4_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_NOFS);\r\nif (!state)\r\nreturn NULL;\r\natomic_set(&state->count, 1);\r\nINIT_LIST_HEAD(&state->lock_states);\r\nspin_lock_init(&state->state_lock);\r\nseqlock_init(&state->seqlock);\r\nreturn state;\r\n}\r\nvoid\r\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\r\n{\r\nif (state->state == fmode)\r\nreturn;\r\nif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\r\nif (fmode & FMODE_WRITE)\r\nlist_move(&state->open_states, &state->owner->so_states);\r\nelse\r\nlist_move_tail(&state->open_states, &state->owner->so_states);\r\n}\r\nstate->state = fmode;\r\n}\r\nstatic struct nfs4_state *\r\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs4_state *state;\r\nlist_for_each_entry(state, &nfsi->open_states, inode_states) {\r\nif (state->owner != owner)\r\ncontinue;\r\nif (!nfs4_valid_open_stateid(state))\r\ncontinue;\r\nif (atomic_inc_not_zero(&state->count))\r\nreturn state;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nnfs4_free_open_state(struct nfs4_state *state)\r\n{\r\nkfree(state);\r\n}\r\nstruct nfs4_state *\r\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\r\n{\r\nstruct nfs4_state *state, *new;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nspin_lock(&inode->i_lock);\r\nstate = __nfs4_find_state_byowner(inode, owner);\r\nspin_unlock(&inode->i_lock);\r\nif (state)\r\ngoto out;\r\nnew = nfs4_alloc_open_state();\r\nspin_lock(&owner->so_lock);\r\nspin_lock(&inode->i_lock);\r\nstate = __nfs4_find_state_byowner(inode, owner);\r\nif (state == NULL && new != NULL) {\r\nstate = new;\r\nstate->owner = owner;\r\natomic_inc(&owner->so_count);\r\nlist_add(&state->inode_states, &nfsi->open_states);\r\nihold(inode);\r\nstate->inode = inode;\r\nspin_unlock(&inode->i_lock);\r\nlist_add_tail(&state->open_states, &owner->so_states);\r\nspin_unlock(&owner->so_lock);\r\n} else {\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&owner->so_lock);\r\nif (new)\r\nnfs4_free_open_state(new);\r\n}\r\nout:\r\nreturn state;\r\n}\r\nvoid nfs4_put_open_state(struct nfs4_state *state)\r\n{\r\nstruct inode *inode = state->inode;\r\nstruct nfs4_state_owner *owner = state->owner;\r\nif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\r\nreturn;\r\nspin_lock(&inode->i_lock);\r\nlist_del(&state->inode_states);\r\nlist_del(&state->open_states);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&owner->so_lock);\r\niput(inode);\r\nnfs4_free_open_state(state);\r\nnfs4_put_state_owner(owner);\r\n}\r\nstatic void __nfs4_close(struct nfs4_state *state,\r\nfmode_t fmode, gfp_t gfp_mask, int wait)\r\n{\r\nstruct nfs4_state_owner *owner = state->owner;\r\nint call_close = 0;\r\nfmode_t newstate;\r\natomic_inc(&owner->so_count);\r\nspin_lock(&owner->so_lock);\r\nswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\r\ncase FMODE_READ:\r\nstate->n_rdonly--;\r\nbreak;\r\ncase FMODE_WRITE:\r\nstate->n_wronly--;\r\nbreak;\r\ncase FMODE_READ|FMODE_WRITE:\r\nstate->n_rdwr--;\r\n}\r\nnewstate = FMODE_READ|FMODE_WRITE;\r\nif (state->n_rdwr == 0) {\r\nif (state->n_rdonly == 0) {\r\nnewstate &= ~FMODE_READ;\r\ncall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\r\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\r\n}\r\nif (state->n_wronly == 0) {\r\nnewstate &= ~FMODE_WRITE;\r\ncall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\r\ncall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\r\n}\r\nif (newstate == 0)\r\nclear_bit(NFS_DELEGATED_STATE, &state->flags);\r\n}\r\nnfs4_state_set_mode_locked(state, newstate);\r\nspin_unlock(&owner->so_lock);\r\nif (!call_close) {\r\nnfs4_put_open_state(state);\r\nnfs4_put_state_owner(owner);\r\n} else\r\nnfs4_do_close(state, gfp_mask, wait);\r\n}\r\nvoid nfs4_close_state(struct nfs4_state *state, fmode_t fmode)\r\n{\r\n__nfs4_close(state, fmode, GFP_NOFS, 0);\r\n}\r\nvoid nfs4_close_sync(struct nfs4_state *state, fmode_t fmode)\r\n{\r\n__nfs4_close(state, fmode, GFP_KERNEL, 1);\r\n}\r\nstatic struct nfs4_lock_state *\r\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\r\n{\r\nstruct nfs4_lock_state *pos;\r\nlist_for_each_entry(pos, &state->lock_states, ls_locks) {\r\nif (pos->ls_owner != fl_owner)\r\ncontinue;\r\natomic_inc(&pos->ls_count);\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\r\n{\r\nstruct nfs4_lock_state *lsp;\r\nstruct nfs_server *server = state->owner->so_server;\r\nlsp = kzalloc(sizeof(*lsp), GFP_NOFS);\r\nif (lsp == NULL)\r\nreturn NULL;\r\nnfs4_init_seqid_counter(&lsp->ls_seqid);\r\natomic_set(&lsp->ls_count, 1);\r\nlsp->ls_state = state;\r\nlsp->ls_owner = fl_owner;\r\nlsp->ls_seqid.owner_id = ida_simple_get(&server->lockowner_id, 0, 0, GFP_NOFS);\r\nif (lsp->ls_seqid.owner_id < 0)\r\ngoto out_free;\r\nINIT_LIST_HEAD(&lsp->ls_locks);\r\nreturn lsp;\r\nout_free:\r\nkfree(lsp);\r\nreturn NULL;\r\n}\r\nvoid nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\r\n{\r\nida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\r\nnfs4_destroy_seqid_counter(&lsp->ls_seqid);\r\nkfree(lsp);\r\n}\r\nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\r\n{\r\nstruct nfs4_lock_state *lsp, *new = NULL;\r\nfor(;;) {\r\nspin_lock(&state->state_lock);\r\nlsp = __nfs4_find_lock_state(state, owner);\r\nif (lsp != NULL)\r\nbreak;\r\nif (new != NULL) {\r\nlist_add(&new->ls_locks, &state->lock_states);\r\nset_bit(LK_STATE_IN_USE, &state->flags);\r\nlsp = new;\r\nnew = NULL;\r\nbreak;\r\n}\r\nspin_unlock(&state->state_lock);\r\nnew = nfs4_alloc_lock_state(state, owner);\r\nif (new == NULL)\r\nreturn NULL;\r\n}\r\nspin_unlock(&state->state_lock);\r\nif (new != NULL)\r\nnfs4_free_lock_state(state->owner->so_server, new);\r\nreturn lsp;\r\n}\r\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\r\n{\r\nstruct nfs_server *server;\r\nstruct nfs4_state *state;\r\nif (lsp == NULL)\r\nreturn;\r\nstate = lsp->ls_state;\r\nif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\r\nreturn;\r\nlist_del(&lsp->ls_locks);\r\nif (list_empty(&state->lock_states))\r\nclear_bit(LK_STATE_IN_USE, &state->flags);\r\nspin_unlock(&state->state_lock);\r\nserver = state->owner->so_server;\r\nif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\r\nstruct nfs_client *clp = server->nfs_client;\r\nclp->cl_mvops->free_lock_state(server, lsp);\r\n} else\r\nnfs4_free_lock_state(server, lsp);\r\n}\r\nstatic void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\r\n{\r\nstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\r\ndst->fl_u.nfs4_fl.owner = lsp;\r\natomic_inc(&lsp->ls_count);\r\n}\r\nstatic void nfs4_fl_release_lock(struct file_lock *fl)\r\n{\r\nnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\r\n}\r\nint nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\r\n{\r\nstruct nfs4_lock_state *lsp;\r\nif (fl->fl_ops != NULL)\r\nreturn 0;\r\nlsp = nfs4_get_lock_state(state, fl->fl_owner);\r\nif (lsp == NULL)\r\nreturn -ENOMEM;\r\nfl->fl_u.nfs4_fl.owner = lsp;\r\nfl->fl_ops = &nfs4_fl_lock_ops;\r\nreturn 0;\r\n}\r\nstatic int nfs4_copy_lock_stateid(nfs4_stateid *dst,\r\nstruct nfs4_state *state,\r\nconst struct nfs_lockowner *lockowner)\r\n{\r\nstruct nfs4_lock_state *lsp;\r\nfl_owner_t fl_owner;\r\nint ret = -ENOENT;\r\nif (lockowner == NULL)\r\ngoto out;\r\nif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\r\ngoto out;\r\nfl_owner = lockowner->l_owner;\r\nspin_lock(&state->state_lock);\r\nlsp = __nfs4_find_lock_state(state, fl_owner);\r\nif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\r\nret = -EIO;\r\nelse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\r\nnfs4_stateid_copy(dst, &lsp->ls_stateid);\r\nret = 0;\r\n}\r\nspin_unlock(&state->state_lock);\r\nnfs4_put_lock_state(lsp);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\r\n{\r\nconst nfs4_stateid *src;\r\nint seq;\r\ndo {\r\nsrc = &zero_stateid;\r\nseq = read_seqbegin(&state->seqlock);\r\nif (test_bit(NFS_OPEN_STATE, &state->flags))\r\nsrc = &state->open_stateid;\r\nnfs4_stateid_copy(dst, src);\r\n} while (read_seqretry(&state->seqlock, seq));\r\n}\r\nint nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,\r\nfmode_t fmode, const struct nfs_lockowner *lockowner)\r\n{\r\nint ret = nfs4_copy_lock_stateid(dst, state, lockowner);\r\nif (ret == -EIO)\r\ngoto out;\r\nif (nfs4_copy_delegation_stateid(dst, state->inode, fmode)) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (ret != -ENOENT)\r\ngoto out;\r\nnfs4_copy_open_stateid(dst, state);\r\nret = 0;\r\nout:\r\nif (nfs_server_capable(state->inode, NFS_CAP_STATEID_NFSV41))\r\ndst->seqid = 0;\r\nreturn ret;\r\n}\r\nstruct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask)\r\n{\r\nstruct nfs_seqid *new;\r\nnew = kmalloc(sizeof(*new), gfp_mask);\r\nif (new != NULL) {\r\nnew->sequence = counter;\r\nINIT_LIST_HEAD(&new->list);\r\nnew->task = NULL;\r\n}\r\nreturn new;\r\n}\r\nvoid nfs_release_seqid(struct nfs_seqid *seqid)\r\n{\r\nstruct nfs_seqid_counter *sequence;\r\nif (list_empty(&seqid->list))\r\nreturn;\r\nsequence = seqid->sequence;\r\nspin_lock(&sequence->lock);\r\nlist_del_init(&seqid->list);\r\nif (!list_empty(&sequence->list)) {\r\nstruct nfs_seqid *next;\r\nnext = list_first_entry(&sequence->list,\r\nstruct nfs_seqid, list);\r\nrpc_wake_up_queued_task(&sequence->wait, next->task);\r\n}\r\nspin_unlock(&sequence->lock);\r\n}\r\nvoid nfs_free_seqid(struct nfs_seqid *seqid)\r\n{\r\nnfs_release_seqid(seqid);\r\nkfree(seqid);\r\n}\r\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\r\n{\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -NFS4ERR_BAD_SEQID:\r\nif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\r\nreturn;\r\npr_warn_ratelimited("NFS: v4 server returned a bad"\r\n" sequence-id error on an"\r\n" unconfirmed sequence %p!\n",\r\nseqid->sequence);\r\ncase -NFS4ERR_STALE_CLIENTID:\r\ncase -NFS4ERR_STALE_STATEID:\r\ncase -NFS4ERR_BAD_STATEID:\r\ncase -NFS4ERR_BADXDR:\r\ncase -NFS4ERR_RESOURCE:\r\ncase -NFS4ERR_NOFILEHANDLE:\r\nreturn;\r\n};\r\nseqid->sequence->counter++;\r\n}\r\nvoid nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\r\n{\r\nstruct nfs4_state_owner *sp = container_of(seqid->sequence,\r\nstruct nfs4_state_owner, so_seqid);\r\nstruct nfs_server *server = sp->so_server;\r\nif (status == -NFS4ERR_BAD_SEQID)\r\nnfs4_drop_state_owner(sp);\r\nif (!nfs4_has_session(server->nfs_client))\r\nnfs_increment_seqid(status, seqid);\r\n}\r\nvoid nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\r\n{\r\nnfs_increment_seqid(status, seqid);\r\n}\r\nint nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\r\n{\r\nstruct nfs_seqid_counter *sequence = seqid->sequence;\r\nint status = 0;\r\nspin_lock(&sequence->lock);\r\nseqid->task = task;\r\nif (list_empty(&seqid->list))\r\nlist_add_tail(&seqid->list, &sequence->list);\r\nif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\r\ngoto unlock;\r\nrpc_sleep_on(&sequence->wait, task, NULL);\r\nstatus = -EAGAIN;\r\nunlock:\r\nspin_unlock(&sequence->lock);\r\nreturn status;\r\n}\r\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\r\nrpc_wake_up(&clp->cl_rpcwaitq);\r\n}\r\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\r\n{\r\nstruct task_struct *task;\r\nchar buf[INET6_ADDRSTRLEN + sizeof("-manager") + 1];\r\nif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\r\nreturn;\r\n__module_get(THIS_MODULE);\r\natomic_inc(&clp->cl_count);\r\nrcu_read_lock();\r\nsnprintf(buf, sizeof(buf), "%s-manager",\r\nrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nrcu_read_unlock();\r\ntask = kthread_run(nfs4_run_state_manager, clp, "%s", buf);\r\nif (IS_ERR(task)) {\r\nprintk(KERN_ERR "%s: kthread_run: %ld\n",\r\n__func__, PTR_ERR(task));\r\nnfs4_clear_state_manager_bit(clp);\r\nnfs_put_client(clp);\r\nmodule_put(THIS_MODULE);\r\n}\r\n}\r\nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\r\n{\r\nif (!clp)\r\nreturn;\r\nif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\r\nset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\r\ndprintk("%s: scheduling lease recovery for server %s\n", __func__,\r\nclp->cl_hostname);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nint nfs4_schedule_migration_recovery(const struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nif (server->fh_expire_type != NFS4_FH_PERSISTENT) {\r\npr_err("NFS: volatile file handles not supported (server %s)\n",\r\nclp->cl_hostname);\r\nreturn -NFS4ERR_IO;\r\n}\r\nif (test_bit(NFS_MIG_FAILED, &server->mig_status))\r\nreturn -NFS4ERR_IO;\r\ndprintk("%s: scheduling migration recovery for (%llx:%llx) on %s\n",\r\n__func__,\r\n(unsigned long long)server->fsid.major,\r\n(unsigned long long)server->fsid.minor,\r\nclp->cl_hostname);\r\nset_bit(NFS_MIG_IN_TRANSITION,\r\n&((struct nfs_server *)server)->mig_status);\r\nset_bit(NFS4CLNT_MOVED, &clp->cl_state);\r\nnfs4_schedule_state_manager(clp);\r\nreturn 0;\r\n}\r\nvoid nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\r\n{\r\ndprintk("%s: scheduling lease-moved recovery for client ID %llx on %s\n",\r\n__func__, clp->cl_clientid, clp->cl_hostname);\r\nset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nint nfs4_wait_clnt_recover(struct nfs_client *clp)\r\n{\r\nint res;\r\nmight_sleep();\r\natomic_inc(&clp->cl_count);\r\nres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\r\nnfs_wait_bit_killable, TASK_KILLABLE);\r\nif (res)\r\ngoto out;\r\nif (clp->cl_cons_state < 0)\r\nres = clp->cl_cons_state;\r\nout:\r\nnfs_put_client(clp);\r\nreturn res;\r\n}\r\nint nfs4_client_recover_expired_lease(struct nfs_client *clp)\r\n{\r\nunsigned int loop;\r\nint ret;\r\nfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\r\nret = nfs4_wait_clnt_recover(clp);\r\nif (ret != 0)\r\nbreak;\r\nif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\r\n!test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\r\nbreak;\r\nnfs4_schedule_state_manager(clp);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nfs40_handle_cb_pathdown(struct nfs_client *clp)\r\n{\r\nset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\nnfs_expire_all_delegations(clp);\r\ndprintk("%s: handling CB_PATHDOWN recovery for server %s\n", __func__,\r\nclp->cl_hostname);\r\n}\r\nvoid nfs4_schedule_path_down_recovery(struct nfs_client *clp)\r\n{\r\nnfs40_handle_cb_pathdown(clp);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nstatic int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\r\n{\r\nset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\r\nif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\r\nclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\r\nreturn 0;\r\n}\r\nset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\r\nset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\r\nreturn 1;\r\n}\r\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\r\n{\r\nset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\r\nclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\r\nset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\r\nset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\r\nreturn 1;\r\n}\r\nint nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nif (!nfs4_valid_open_stateid(state))\r\nreturn -EBADF;\r\nnfs4_state_mark_reclaim_nograce(clp, state);\r\ndprintk("%s: scheduling stateid recovery for server %s\n", __func__,\r\nclp->cl_hostname);\r\nnfs4_schedule_state_manager(clp);\r\nreturn 0;\r\n}\r\nvoid nfs_inode_find_state_and_recover(struct inode *inode,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_open_context *ctx;\r\nstruct nfs4_state *state;\r\nbool found = false;\r\nspin_lock(&inode->i_lock);\r\nlist_for_each_entry(ctx, &nfsi->open_files, list) {\r\nstate = ctx->state;\r\nif (state == NULL)\r\ncontinue;\r\nif (!test_bit(NFS_DELEGATED_STATE, &state->flags))\r\ncontinue;\r\nif (!nfs4_stateid_match(&state->stateid, stateid))\r\ncontinue;\r\nnfs4_state_mark_reclaim_nograce(clp, state);\r\nfound = true;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nif (found)\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nstatic void nfs4_state_mark_open_context_bad(struct nfs4_state *state)\r\n{\r\nstruct inode *inode = state->inode;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_open_context *ctx;\r\nspin_lock(&inode->i_lock);\r\nlist_for_each_entry(ctx, &nfsi->open_files, list) {\r\nif (ctx->state != state)\r\ncontinue;\r\nset_bit(NFS_CONTEXT_BAD, &ctx->flags);\r\n}\r\nspin_unlock(&inode->i_lock);\r\n}\r\nstatic void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\r\n{\r\nset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\r\nnfs4_state_mark_open_context_bad(state);\r\n}\r\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\r\n{\r\nstruct inode *inode = state->inode;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct file_lock *fl;\r\nint status = 0;\r\nif (inode->i_flock == NULL)\r\nreturn 0;\r\ndown_write(&nfsi->rwsem);\r\nspin_lock(&inode->i_lock);\r\nfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\r\nif (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))\r\ncontinue;\r\nif (nfs_file_open_context(fl->fl_file)->state != state)\r\ncontinue;\r\nspin_unlock(&inode->i_lock);\r\nstatus = ops->recover_lock(state, fl);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ESTALE:\r\ncase -NFS4ERR_ADMIN_REVOKED:\r\ncase -NFS4ERR_STALE_STATEID:\r\ncase -NFS4ERR_BAD_STATEID:\r\ncase -NFS4ERR_EXPIRED:\r\ncase -NFS4ERR_NO_GRACE:\r\ncase -NFS4ERR_STALE_CLIENTID:\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_BADSLOT:\r\ncase -NFS4ERR_BAD_HIGH_SLOT:\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\ngoto out;\r\ndefault:\r\nprintk(KERN_ERR "NFS: %s: unhandled error %d\n",\r\n__func__, status);\r\ncase -ENOMEM:\r\ncase -NFS4ERR_DENIED:\r\ncase -NFS4ERR_RECLAIM_BAD:\r\ncase -NFS4ERR_RECLAIM_CONFLICT:\r\nstatus = 0;\r\n}\r\nspin_lock(&inode->i_lock);\r\n}\r\nspin_unlock(&inode->i_lock);\r\nout:\r\nup_write(&nfsi->rwsem);\r\nreturn status;\r\n}\r\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\r\n{\r\nstruct nfs4_state *state;\r\nstruct nfs4_lock_state *lock;\r\nint status = 0;\r\nspin_lock(&sp->so_lock);\r\nraw_write_seqcount_begin(&sp->so_reclaim_seqcount);\r\nrestart:\r\nlist_for_each_entry(state, &sp->so_states, open_states) {\r\nif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\r\ncontinue;\r\nif (!nfs4_valid_open_stateid(state))\r\ncontinue;\r\nif (state->state == 0)\r\ncontinue;\r\natomic_inc(&state->count);\r\nspin_unlock(&sp->so_lock);\r\nstatus = ops->recover_open(sp, state);\r\nif (status >= 0) {\r\nstatus = nfs4_reclaim_locks(state, ops);\r\nif (status >= 0) {\r\nif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\r\nspin_lock(&state->state_lock);\r\nlist_for_each_entry(lock, &state->lock_states, ls_locks) {\r\nif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags))\r\npr_warn_ratelimited("NFS: "\r\n"%s: Lock reclaim "\r\n"failed!\n", __func__);\r\n}\r\nspin_unlock(&state->state_lock);\r\n}\r\nnfs4_put_open_state(state);\r\nspin_lock(&sp->so_lock);\r\ngoto restart;\r\n}\r\n}\r\nswitch (status) {\r\ndefault:\r\nprintk(KERN_ERR "NFS: %s: unhandled error %d\n",\r\n__func__, status);\r\ncase -ENOENT:\r\ncase -ENOMEM:\r\ncase -ESTALE:\r\nnfs4_state_mark_recovery_failed(state, status);\r\nbreak;\r\ncase -EAGAIN:\r\nssleep(1);\r\ncase -NFS4ERR_ADMIN_REVOKED:\r\ncase -NFS4ERR_STALE_STATEID:\r\ncase -NFS4ERR_BAD_STATEID:\r\ncase -NFS4ERR_RECLAIM_BAD:\r\ncase -NFS4ERR_RECLAIM_CONFLICT:\r\nnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\r\nbreak;\r\ncase -NFS4ERR_EXPIRED:\r\ncase -NFS4ERR_NO_GRACE:\r\nnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\r\ncase -NFS4ERR_STALE_CLIENTID:\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_BADSLOT:\r\ncase -NFS4ERR_BAD_HIGH_SLOT:\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\ngoto out_err;\r\n}\r\nnfs4_put_open_state(state);\r\nspin_lock(&sp->so_lock);\r\ngoto restart;\r\n}\r\nraw_write_seqcount_end(&sp->so_reclaim_seqcount);\r\nspin_unlock(&sp->so_lock);\r\nreturn 0;\r\nout_err:\r\nnfs4_put_open_state(state);\r\nspin_lock(&sp->so_lock);\r\nraw_write_seqcount_end(&sp->so_reclaim_seqcount);\r\nspin_unlock(&sp->so_lock);\r\nreturn status;\r\n}\r\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\r\n{\r\nstruct nfs4_lock_state *lock;\r\nclear_bit(NFS_DELEGATED_STATE, &state->flags);\r\nclear_bit(NFS_O_RDONLY_STATE, &state->flags);\r\nclear_bit(NFS_O_WRONLY_STATE, &state->flags);\r\nclear_bit(NFS_O_RDWR_STATE, &state->flags);\r\nspin_lock(&state->state_lock);\r\nlist_for_each_entry(lock, &state->lock_states, ls_locks) {\r\nlock->ls_seqid.flags = 0;\r\nclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\r\n}\r\nspin_unlock(&state->state_lock);\r\n}\r\nstatic void nfs4_reset_seqids(struct nfs_server *server,\r\nint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_state_owner *sp;\r\nstruct rb_node *pos;\r\nstruct nfs4_state *state;\r\nspin_lock(&clp->cl_lock);\r\nfor (pos = rb_first(&server->state_owners);\r\npos != NULL;\r\npos = rb_next(pos)) {\r\nsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\r\nsp->so_seqid.flags = 0;\r\nspin_lock(&sp->so_lock);\r\nlist_for_each_entry(state, &sp->so_states, open_states) {\r\nif (mark_reclaim(clp, state))\r\nnfs4_clear_open_state(state);\r\n}\r\nspin_unlock(&sp->so_lock);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\r\nint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs4_reset_seqids(server, mark_reclaim);\r\nrcu_read_unlock();\r\n}\r\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\r\n{\r\nnfs_delegation_mark_reclaim(clp);\r\nnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\r\n}\r\nstatic void nfs4_reclaim_complete(struct nfs_client *clp,\r\nconst struct nfs4_state_recovery_ops *ops,\r\nstruct rpc_cred *cred)\r\n{\r\nif (ops->reclaim_complete)\r\n(void)ops->reclaim_complete(clp, cred);\r\n}\r\nstatic void nfs4_clear_reclaim_server(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_state_owner *sp;\r\nstruct rb_node *pos;\r\nstruct nfs4_state *state;\r\nspin_lock(&clp->cl_lock);\r\nfor (pos = rb_first(&server->state_owners);\r\npos != NULL;\r\npos = rb_next(pos)) {\r\nsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\r\nspin_lock(&sp->so_lock);\r\nlist_for_each_entry(state, &sp->so_states, open_states) {\r\nif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\r\n&state->flags))\r\ncontinue;\r\nnfs4_state_mark_reclaim_nograce(clp, state);\r\n}\r\nspin_unlock(&sp->so_lock);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nstatic int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\r\nreturn 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs4_clear_reclaim_server(server);\r\nrcu_read_unlock();\r\nnfs_delegation_reap_unclaimed(clp);\r\nreturn 1;\r\n}\r\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\r\n{\r\nconst struct nfs4_state_recovery_ops *ops;\r\nstruct rpc_cred *cred;\r\nif (!nfs4_state_clear_reclaim_reboot(clp))\r\nreturn;\r\nops = clp->cl_mvops->reboot_recovery_ops;\r\ncred = nfs4_get_clid_cred(clp);\r\nnfs4_reclaim_complete(clp, ops, cred);\r\nput_rpccred(cred);\r\n}\r\nstatic void nfs_delegation_clear_all(struct nfs_client *clp)\r\n{\r\nnfs_delegation_mark_reclaim(clp);\r\nnfs_delegation_reap_unclaimed(clp);\r\n}\r\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\r\n{\r\nnfs_delegation_clear_all(clp);\r\nnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\r\n}\r\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\r\n{\r\nswitch (error) {\r\ncase 0:\r\nbreak;\r\ncase -NFS4ERR_CB_PATH_DOWN:\r\nnfs40_handle_cb_pathdown(clp);\r\nbreak;\r\ncase -NFS4ERR_NO_GRACE:\r\nnfs4_state_end_reclaim_reboot(clp);\r\nbreak;\r\ncase -NFS4ERR_STALE_CLIENTID:\r\nset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\nnfs4_state_clear_reclaim_reboot(clp);\r\nnfs4_state_start_reclaim_reboot(clp);\r\nbreak;\r\ncase -NFS4ERR_EXPIRED:\r\nset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\nnfs4_state_start_reclaim_nograce(clp);\r\nbreak;\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_BADSLOT:\r\ncase -NFS4ERR_BAD_HIGH_SLOT:\r\ncase -NFS4ERR_DEADSESSION:\r\ncase -NFS4ERR_SEQ_FALSE_RETRY:\r\ncase -NFS4ERR_SEQ_MISORDERED:\r\nset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\r\nbreak;\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\nset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\r\nbreak;\r\ndefault:\r\ndprintk("%s: failed to handle error %d for server %s\n",\r\n__func__, error, clp->cl_hostname);\r\nreturn error;\r\n}\r\ndprintk("%s: handled error %d for server %s\n", __func__, error,\r\nclp->cl_hostname);\r\nreturn 0;\r\n}\r\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\r\n{\r\nstruct nfs4_state_owner *sp;\r\nstruct nfs_server *server;\r\nstruct rb_node *pos;\r\nint status = 0;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nnfs4_purge_state_owners(server);\r\nspin_lock(&clp->cl_lock);\r\nfor (pos = rb_first(&server->state_owners);\r\npos != NULL;\r\npos = rb_next(pos)) {\r\nsp = rb_entry(pos,\r\nstruct nfs4_state_owner, so_server_node);\r\nif (!test_and_clear_bit(ops->owner_flag_bit,\r\n&sp->so_flags))\r\ncontinue;\r\natomic_inc(&sp->so_count);\r\nspin_unlock(&clp->cl_lock);\r\nrcu_read_unlock();\r\nstatus = nfs4_reclaim_open_state(sp, ops);\r\nif (status < 0) {\r\nset_bit(ops->owner_flag_bit, &sp->so_flags);\r\nnfs4_put_state_owner(sp);\r\nstatus = nfs4_recovery_handle_error(clp, status);\r\nreturn (status != 0) ? status : -EAGAIN;\r\n}\r\nnfs4_put_state_owner(sp);\r\ngoto restart;\r\n}\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int nfs4_check_lease(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred;\r\nconst struct nfs4_state_maintenance_ops *ops =\r\nclp->cl_mvops->state_renewal_ops;\r\nint status;\r\nif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\r\nreturn 0;\r\nspin_lock(&clp->cl_lock);\r\ncred = ops->get_state_renewal_cred_locked(clp);\r\nspin_unlock(&clp->cl_lock);\r\nif (cred == NULL) {\r\ncred = nfs4_get_clid_cred(clp);\r\nstatus = -ENOKEY;\r\nif (cred == NULL)\r\ngoto out;\r\n}\r\nstatus = ops->renew_lease(clp, cred);\r\nput_rpccred(cred);\r\nif (status == -ETIMEDOUT) {\r\nset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\r\nreturn 0;\r\n}\r\nout:\r\nreturn nfs4_recovery_handle_error(clp, status);\r\n}\r\nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\r\n{\r\nswitch (status) {\r\ncase -NFS4ERR_SEQ_MISORDERED:\r\nif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\r\nreturn -ESERVERFAULT;\r\nssleep(1);\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nbreak;\r\ncase -NFS4ERR_STALE_CLIENTID:\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nnfs4_state_start_reclaim_reboot(clp);\r\nbreak;\r\ncase -NFS4ERR_CLID_INUSE:\r\npr_err("NFS: Server %s reports our clientid is in use\n",\r\nclp->cl_hostname);\r\nnfs_mark_client_ready(clp, -EPERM);\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nreturn -EPERM;\r\ncase -EACCES:\r\ncase -NFS4ERR_DELAY:\r\ncase -ETIMEDOUT:\r\ncase -EAGAIN:\r\nssleep(1);\r\nbreak;\r\ncase -NFS4ERR_MINOR_VERS_MISMATCH:\r\nif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\r\nnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\r\ndprintk("%s: exit with error %d for server %s\n",\r\n__func__, -EPROTONOSUPPORT, clp->cl_hostname);\r\nreturn -EPROTONOSUPPORT;\r\ncase -NFS4ERR_NOT_SAME:\r\ndefault:\r\ndprintk("%s: exit with error %d for server %s\n", __func__,\r\nstatus, clp->cl_hostname);\r\nreturn status;\r\n}\r\nset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\ndprintk("%s: handled error %d for server %s\n", __func__, status,\r\nclp->cl_hostname);\r\nreturn 0;\r\n}\r\nstatic int nfs4_establish_lease(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred;\r\nconst struct nfs4_state_recovery_ops *ops =\r\nclp->cl_mvops->reboot_recovery_ops;\r\nint status;\r\ncred = nfs4_get_clid_cred(clp);\r\nif (cred == NULL)\r\nreturn -ENOENT;\r\nstatus = ops->establish_clid(clp, cred);\r\nput_rpccred(cred);\r\nif (status != 0)\r\nreturn status;\r\npnfs_destroy_all_layouts(clp);\r\nreturn 0;\r\n}\r\nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\r\n{\r\nint status;\r\nstatus = nfs4_establish_lease(clp);\r\nif (status < 0)\r\nreturn nfs4_handle_reclaim_lease_error(clp, status);\r\nif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\r\nnfs4_state_start_reclaim_nograce(clp);\r\nif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\r\nset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\r\nclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\r\nclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\nreturn 0;\r\n}\r\nstatic int nfs4_purge_lease(struct nfs_client *clp)\r\n{\r\nint status;\r\nstatus = nfs4_establish_lease(clp);\r\nif (status < 0)\r\nreturn nfs4_handle_reclaim_lease_error(clp, status);\r\nclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\r\nset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\r\nnfs4_state_start_reclaim_nograce(clp);\r\nreturn 0;\r\n}\r\nstatic int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs4_fs_locations *locations = NULL;\r\nstruct inode *inode;\r\nstruct page *page;\r\nint status, result;\r\ndprintk("--> %s: FSID %llx:%llx on \"%s\"\n", __func__,\r\n(unsigned long long)server->fsid.major,\r\n(unsigned long long)server->fsid.minor,\r\nclp->cl_hostname);\r\nresult = 0;\r\npage = alloc_page(GFP_KERNEL);\r\nlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\r\nif (page == NULL || locations == NULL) {\r\ndprintk("<-- %s: no memory\n", __func__);\r\ngoto out;\r\n}\r\ninode = server->super->s_root->d_inode;\r\nresult = nfs4_proc_get_locations(inode, locations, page, cred);\r\nif (result) {\r\ndprintk("<-- %s: failed to retrieve fs_locations: %d\n",\r\n__func__, result);\r\ngoto out;\r\n}\r\nresult = -NFS4ERR_NXIO;\r\nif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\r\ndprintk("<-- %s: No fs_locations data, migration skipped\n",\r\n__func__);\r\ngoto out;\r\n}\r\nnfs4_begin_drain_session(clp);\r\nstatus = nfs4_replace_transport(server, locations);\r\nif (status != 0) {\r\ndprintk("<-- %s: failed to replace transport: %d\n",\r\n__func__, status);\r\ngoto out;\r\n}\r\nresult = 0;\r\ndprintk("<-- %s: migration succeeded\n", __func__);\r\nout:\r\nif (page != NULL)\r\n__free_page(page);\r\nkfree(locations);\r\nif (result) {\r\npr_err("NFS: migration recovery failed (server %s)\n",\r\nclp->cl_hostname);\r\nset_bit(NFS_MIG_FAILED, &server->mig_status);\r\n}\r\nreturn result;\r\n}\r\nstatic int nfs4_handle_migration(struct nfs_client *clp)\r\n{\r\nconst struct nfs4_state_maintenance_ops *ops =\r\nclp->cl_mvops->state_renewal_ops;\r\nstruct nfs_server *server;\r\nstruct rpc_cred *cred;\r\ndprintk("%s: migration reported on \"%s\"\n", __func__,\r\nclp->cl_hostname);\r\nspin_lock(&clp->cl_lock);\r\ncred = ops->get_state_renewal_cred_locked(clp);\r\nspin_unlock(&clp->cl_lock);\r\nif (cred == NULL)\r\nreturn -NFS4ERR_NOENT;\r\nclp->cl_mig_gen++;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nint status;\r\nif (server->mig_gen == clp->cl_mig_gen)\r\ncontinue;\r\nserver->mig_gen = clp->cl_mig_gen;\r\nif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\r\n&server->mig_status))\r\ncontinue;\r\nrcu_read_unlock();\r\nstatus = nfs4_try_migration(server, cred);\r\nif (status < 0) {\r\nput_rpccred(cred);\r\nreturn status;\r\n}\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nput_rpccred(cred);\r\nreturn 0;\r\n}\r\nstatic int nfs4_handle_lease_moved(struct nfs_client *clp)\r\n{\r\nconst struct nfs4_state_maintenance_ops *ops =\r\nclp->cl_mvops->state_renewal_ops;\r\nstruct nfs_server *server;\r\nstruct rpc_cred *cred;\r\ndprintk("%s: lease moved reported on \"%s\"\n", __func__,\r\nclp->cl_hostname);\r\nspin_lock(&clp->cl_lock);\r\ncred = ops->get_state_renewal_cred_locked(clp);\r\nspin_unlock(&clp->cl_lock);\r\nif (cred == NULL)\r\nreturn -NFS4ERR_NOENT;\r\nclp->cl_mig_gen++;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nstruct inode *inode;\r\nint status;\r\nif (server->mig_gen == clp->cl_mig_gen)\r\ncontinue;\r\nserver->mig_gen = clp->cl_mig_gen;\r\nrcu_read_unlock();\r\ninode = server->super->s_root->d_inode;\r\nstatus = nfs4_proc_fsid_present(inode, cred);\r\nif (status != -NFS4ERR_MOVED)\r\ngoto restart;\r\nif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\r\ngoto restart;\r\ngoto out;\r\n}\r\nrcu_read_unlock();\r\nout:\r\nput_rpccred(cred);\r\nreturn 0;\r\n}\r\nint nfs4_discover_server_trunking(struct nfs_client *clp,\r\nstruct nfs_client **result)\r\n{\r\nconst struct nfs4_state_recovery_ops *ops =\r\nclp->cl_mvops->reboot_recovery_ops;\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_cred *cred;\r\nint i, status;\r\ndprintk("NFS: %s: testing '%s'\n", __func__, clp->cl_hostname);\r\nclnt = clp->cl_rpcclient;\r\ni = 0;\r\nmutex_lock(&nfs_clid_init_mutex);\r\nagain:\r\nstatus = -ENOENT;\r\ncred = nfs4_get_clid_cred(clp);\r\nif (cred == NULL)\r\ngoto out_unlock;\r\nstatus = ops->detect_trunking(clp, result, cred);\r\nput_rpccred(cred);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ETIMEDOUT:\r\nif (clnt->cl_softrtry)\r\nbreak;\r\ncase -NFS4ERR_DELAY:\r\ncase -EAGAIN:\r\nssleep(1);\r\ncase -NFS4ERR_STALE_CLIENTID:\r\ndprintk("NFS: %s after status %d, retrying\n",\r\n__func__, status);\r\ngoto again;\r\ncase -EACCES:\r\nif (i++ == 0) {\r\nnfs4_root_machine_cred(clp);\r\ngoto again;\r\n}\r\nif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX)\r\nbreak;\r\ncase -NFS4ERR_CLID_INUSE:\r\ncase -NFS4ERR_WRONGSEC:\r\nif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX) {\r\nstatus = -EPERM;\r\nbreak;\r\n}\r\nclnt = rpc_clone_client_set_auth(clnt, RPC_AUTH_UNIX);\r\nif (IS_ERR(clnt)) {\r\nstatus = PTR_ERR(clnt);\r\nbreak;\r\n}\r\nclnt = xchg(&clp->cl_rpcclient, clnt);\r\nrpc_shutdown_client(clnt);\r\nclnt = clp->cl_rpcclient;\r\ngoto again;\r\ncase -NFS4ERR_MINOR_VERS_MISMATCH:\r\nstatus = -EPROTONOSUPPORT;\r\nbreak;\r\ncase -EKEYEXPIRED:\r\ncase -NFS4ERR_NOT_SAME:\r\nstatus = -EKEYEXPIRED;\r\nbreak;\r\ndefault:\r\npr_warn("NFS: %s unhandled error %d. Exiting with error EIO\n",\r\n__func__, status);\r\nstatus = -EIO;\r\n}\r\nout_unlock:\r\nmutex_unlock(&nfs_clid_init_mutex);\r\ndprintk("NFS: %s: status = %d\n", __func__, status);\r\nreturn status;\r\n}\r\nvoid nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\r\n{\r\nstruct nfs_client *clp = session->clp;\r\nswitch (err) {\r\ndefault:\r\nset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\r\nbreak;\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\nset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\r\n}\r\nnfs4_schedule_lease_recovery(clp);\r\n}\r\nstatic void nfs41_ping_server(struct nfs_client *clp)\r\n{\r\nset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nvoid nfs41_server_notify_target_slotid_update(struct nfs_client *clp)\r\n{\r\nnfs41_ping_server(clp);\r\n}\r\nvoid nfs41_server_notify_highest_slotid_update(struct nfs_client *clp)\r\n{\r\nnfs41_ping_server(clp);\r\n}\r\nstatic void nfs4_reset_all_state(struct nfs_client *clp)\r\n{\r\nif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\r\nset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\r\nclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\r\nnfs4_state_start_reclaim_nograce(clp);\r\ndprintk("%s: scheduling reset of all state for server %s!\n",\r\n__func__, clp->cl_hostname);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\n}\r\nstatic void nfs41_handle_server_reboot(struct nfs_client *clp)\r\n{\r\nif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\r\nnfs4_state_start_reclaim_reboot(clp);\r\ndprintk("%s: server %s rebooted!\n", __func__,\r\nclp->cl_hostname);\r\nnfs4_schedule_state_manager(clp);\r\n}\r\n}\r\nstatic void nfs41_handle_state_revoked(struct nfs_client *clp)\r\n{\r\nnfs4_reset_all_state(clp);\r\ndprintk("%s: state revoked on server %s\n", __func__, clp->cl_hostname);\r\n}\r\nstatic void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\r\n{\r\nnfs_expire_all_delegations(clp);\r\ndprintk("%s: Recallable state revoked on server %s!\n", __func__,\r\nclp->cl_hostname);\r\n}\r\nstatic void nfs41_handle_backchannel_fault(struct nfs_client *clp)\r\n{\r\nnfs_expire_all_delegations(clp);\r\nif (test_and_set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state) == 0)\r\nnfs4_schedule_state_manager(clp);\r\ndprintk("%s: server %s declared a backchannel fault\n", __func__,\r\nclp->cl_hostname);\r\n}\r\nstatic void nfs41_handle_cb_path_down(struct nfs_client *clp)\r\n{\r\nif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\r\n&clp->cl_state) == 0)\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nvoid nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags)\r\n{\r\nif (!flags)\r\nreturn;\r\ndprintk("%s: \"%s\" (client ID %llx) flags=0x%08x\n",\r\n__func__, clp->cl_hostname, clp->cl_clientid, flags);\r\nif (flags & SEQ4_STATUS_RESTART_RECLAIM_NEEDED)\r\nnfs41_handle_server_reboot(clp);\r\nif (flags & (SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED |\r\nSEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED |\r\nSEQ4_STATUS_ADMIN_STATE_REVOKED))\r\nnfs41_handle_state_revoked(clp);\r\nif (flags & SEQ4_STATUS_LEASE_MOVED)\r\nnfs4_schedule_lease_moved_recovery(clp);\r\nif (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED)\r\nnfs41_handle_recallable_state_revoked(clp);\r\nif (flags & SEQ4_STATUS_BACKCHANNEL_FAULT)\r\nnfs41_handle_backchannel_fault(clp);\r\nelse if (flags & (SEQ4_STATUS_CB_PATH_DOWN |\r\nSEQ4_STATUS_CB_PATH_DOWN_SESSION))\r\nnfs41_handle_cb_path_down(clp);\r\n}\r\nstatic int nfs4_reset_session(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred;\r\nint status;\r\nif (!nfs4_has_session(clp))\r\nreturn 0;\r\nnfs4_begin_drain_session(clp);\r\ncred = nfs4_get_clid_cred(clp);\r\nstatus = nfs4_proc_destroy_session(clp->cl_session, cred);\r\nswitch (status) {\r\ncase 0:\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_DEADSESSION:\r\nbreak;\r\ncase -NFS4ERR_BACK_CHAN_BUSY:\r\ncase -NFS4ERR_DELAY:\r\nset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\r\nstatus = 0;\r\nssleep(1);\r\ngoto out;\r\ndefault:\r\nstatus = nfs4_recovery_handle_error(clp, status);\r\ngoto out;\r\n}\r\nmemset(clp->cl_session->sess_id.data, 0, NFS4_MAX_SESSIONID_LEN);\r\nstatus = nfs4_proc_create_session(clp, cred);\r\nif (status) {\r\ndprintk("%s: session reset failed with status %d for server %s!\n",\r\n__func__, status, clp->cl_hostname);\r\nstatus = nfs4_handle_reclaim_lease_error(clp, status);\r\ngoto out;\r\n}\r\nnfs41_finish_session_reset(clp);\r\ndprintk("%s: session reset was successful for server %s!\n",\r\n__func__, clp->cl_hostname);\r\nout:\r\nif (cred)\r\nput_rpccred(cred);\r\nreturn status;\r\n}\r\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\r\n{\r\nstruct rpc_cred *cred;\r\nint ret;\r\nif (!nfs4_has_session(clp))\r\nreturn 0;\r\nnfs4_begin_drain_session(clp);\r\ncred = nfs4_get_clid_cred(clp);\r\nret = nfs4_proc_bind_conn_to_session(clp, cred);\r\nif (cred)\r\nput_rpccred(cred);\r\nclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\r\nswitch (ret) {\r\ncase 0:\r\ndprintk("%s: bind_conn_to_session was successful for server %s!\n",\r\n__func__, clp->cl_hostname);\r\nbreak;\r\ncase -NFS4ERR_DELAY:\r\nssleep(1);\r\nset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\r\nbreak;\r\ndefault:\r\nreturn nfs4_recovery_handle_error(clp, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfs4_reset_session(struct nfs_client *clp) { return 0; }\r\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nfs4_state_manager(struct nfs_client *clp)\r\n{\r\nint status = 0;\r\nconst char *section = "", *section_sep = "";\r\ndo {\r\nif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\r\nsection = "purge state";\r\nstatus = nfs4_purge_lease(clp);\r\nif (status < 0)\r\ngoto out_error;\r\ncontinue;\r\n}\r\nif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\r\nsection = "lease expired";\r\nstatus = nfs4_reclaim_lease(clp);\r\nif (status < 0)\r\ngoto out_error;\r\ncontinue;\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\r\nsection = "reset session";\r\nstatus = nfs4_reset_session(clp);\r\nif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\r\ncontinue;\r\nif (status < 0)\r\ngoto out_error;\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\r\n&clp->cl_state)) {\r\nsection = "bind conn to session";\r\nstatus = nfs4_bind_conn_to_session(clp);\r\nif (status < 0)\r\ngoto out_error;\r\ncontinue;\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\r\nsection = "check lease";\r\nstatus = nfs4_check_lease(clp);\r\nif (status < 0)\r\ngoto out_error;\r\ncontinue;\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\r\nsection = "migration";\r\nstatus = nfs4_handle_migration(clp);\r\nif (status < 0)\r\ngoto out_error;\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\r\nsection = "lease moved";\r\nstatus = nfs4_handle_lease_moved(clp);\r\nif (status < 0)\r\ngoto out_error;\r\n}\r\nif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\r\nsection = "reclaim reboot";\r\nstatus = nfs4_do_reclaim(clp,\r\nclp->cl_mvops->reboot_recovery_ops);\r\nif (status == -EAGAIN)\r\ncontinue;\r\nif (status < 0)\r\ngoto out_error;\r\nnfs4_state_end_reclaim_reboot(clp);\r\n}\r\nif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\r\nsection = "reclaim nograce";\r\nstatus = nfs4_do_reclaim(clp,\r\nclp->cl_mvops->nograce_recovery_ops);\r\nif (status == -EAGAIN)\r\ncontinue;\r\nif (status < 0)\r\ngoto out_error;\r\n}\r\nnfs4_end_drain_session(clp);\r\nif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\r\nnfs_client_return_marked_delegations(clp);\r\ncontinue;\r\n}\r\nnfs4_clear_state_manager_bit(clp);\r\nif (clp->cl_state == 0)\r\nbreak;\r\nif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\r\nbreak;\r\n} while (atomic_read(&clp->cl_count) > 1);\r\nreturn;\r\nout_error:\r\nif (strlen(section))\r\nsection_sep = ": ";\r\npr_warn_ratelimited("NFS: state manager%s%s failed on NFSv4 server %s"\r\n" with error %d\n", section_sep, section,\r\nclp->cl_hostname, -status);\r\nssleep(1);\r\nnfs4_end_drain_session(clp);\r\nnfs4_clear_state_manager_bit(clp);\r\n}\r\nstatic int nfs4_run_state_manager(void *ptr)\r\n{\r\nstruct nfs_client *clp = ptr;\r\nallow_signal(SIGKILL);\r\nnfs4_state_manager(clp);\r\nnfs_put_client(clp);\r\nmodule_put_and_exit(0);\r\nreturn 0;\r\n}
