static void dm1105_card_list(struct pci_dev *pci)\r\n{\r\nint i;\r\nif (0 == pci->subsystem_vendor &&\r\n0 == pci->subsystem_device) {\r\nprintk(KERN_ERR\r\n"dm1105: Your board has no valid PCI Subsystem ID\n"\r\n"dm1105: and thus can't be autodetected\n"\r\n"dm1105: Please pass card=<n> insmod option to\n"\r\n"dm1105: workaround that. Redirect complaints to\n"\r\n"dm1105: the vendor of the TV card. Best regards,\n"\r\n"dm1105: -- tux\n");\r\n} else {\r\nprintk(KERN_ERR\r\n"dm1105: Your board isn't known (yet) to the driver.\n"\r\n"dm1105: You can try to pick one of the existing\n"\r\n"dm1105: card configs via card=<n> insmod option.\n"\r\n"dm1105: Updating to the latest version might help\n"\r\n"dm1105: as well.\n");\r\n}\r\nprintk(KERN_ERR "Here is a list of valid choices for the card=<n> "\r\n"insmod option:\n");\r\nfor (i = 0; i < ARRAY_SIZE(dm1105_boards); i++)\r\nprintk(KERN_ERR "dm1105: card=%d -> %s\n",\r\ni, dm1105_boards[i].name);\r\n}\r\nstatic void dm1105_gpio_set(struct dm1105_dev *dev, u32 mask)\r\n{\r\nif (mask & 0xfffc0000)\r\nprintk(KERN_ERR "%s: Only 18 GPIO's are allowed\n", __func__);\r\nif (mask & 0x0003ffff)\r\ndm_setl(DM1105_GPIOVAL, mask & 0x0003ffff);\r\n}\r\nstatic void dm1105_gpio_clear(struct dm1105_dev *dev, u32 mask)\r\n{\r\nif (mask & 0xfffc0000)\r\nprintk(KERN_ERR "%s: Only 18 GPIO's are allowed\n", __func__);\r\nif (mask & 0x0003ffff)\r\ndm_clearl(DM1105_GPIOVAL, mask & 0x0003ffff);\r\n}\r\nstatic void dm1105_gpio_andor(struct dm1105_dev *dev, u32 mask, u32 val)\r\n{\r\nif (mask & 0xfffc0000)\r\nprintk(KERN_ERR "%s: Only 18 GPIO's are allowed\n", __func__);\r\nif (mask & 0x0003ffff)\r\ndm_andorl(DM1105_GPIOVAL, mask & 0x0003ffff, val);\r\n}\r\nstatic u32 dm1105_gpio_get(struct dm1105_dev *dev, u32 mask)\r\n{\r\nif (mask & 0xfffc0000)\r\nprintk(KERN_ERR "%s: Only 18 GPIO's are allowed\n", __func__);\r\nif (mask & 0x0003ffff)\r\nreturn dm_readl(DM1105_GPIOVAL) & mask & 0x0003ffff;\r\nreturn 0;\r\n}\r\nstatic void dm1105_gpio_enable(struct dm1105_dev *dev, u32 mask, int asoutput)\r\n{\r\nif (mask & 0xfffc0000)\r\nprintk(KERN_ERR "%s: Only 18 GPIO's are allowed\n", __func__);\r\nif ((mask & 0x0003ffff) && asoutput)\r\ndm_clearl(DM1105_GPIOCTR, mask & 0x0003ffff);\r\nelse if ((mask & 0x0003ffff) && !asoutput)\r\ndm_setl(DM1105_GPIOCTR, mask & 0x0003ffff);\r\n}\r\nstatic void dm1105_setline(struct dm1105_dev *dev, u32 line, int state)\r\n{\r\nif (state)\r\ndm1105_gpio_enable(dev, line, 0);\r\nelse {\r\ndm1105_gpio_enable(dev, line, 1);\r\ndm1105_gpio_clear(dev, line);\r\n}\r\n}\r\nstatic void dm1105_setsda(void *data, int state)\r\n{\r\nstruct dm1105_dev *dev = data;\r\ndm1105_setline(dev, dm1105_boards[dev->boardnr].gpio_sda, state);\r\n}\r\nstatic void dm1105_setscl(void *data, int state)\r\n{\r\nstruct dm1105_dev *dev = data;\r\ndm1105_setline(dev, dm1105_boards[dev->boardnr].gpio_scl, state);\r\n}\r\nstatic int dm1105_getsda(void *data)\r\n{\r\nstruct dm1105_dev *dev = data;\r\nreturn dm1105_gpio_get(dev, dm1105_boards[dev->boardnr].gpio_sda)\r\n? 1 : 0;\r\n}\r\nstatic int dm1105_getscl(void *data)\r\n{\r\nstruct dm1105_dev *dev = data;\r\nreturn dm1105_gpio_get(dev, dm1105_boards[dev->boardnr].gpio_scl)\r\n? 1 : 0;\r\n}\r\nstatic int dm1105_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct dm1105_dev *dev ;\r\nint addr, rc, i, j, k, len, byte, data;\r\nu8 status;\r\ndev = i2c_adap->algo_data;\r\nfor (i = 0; i < num; i++) {\r\ndm_writeb(DM1105_I2CCTR, 0x00);\r\nif (msgs[i].flags & I2C_M_RD) {\r\naddr = msgs[i].addr << 1;\r\naddr |= 1;\r\ndm_writeb(DM1105_I2CDAT, addr);\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\ndm_writeb(DM1105_I2CDAT + byte + 1, 0);\r\ndm_writeb(DM1105_I2CCTR, 0x81 + msgs[i].len);\r\nfor (j = 0; j < 55; j++) {\r\nmdelay(10);\r\nstatus = dm_readb(DM1105_I2CSTS);\r\nif ((status & 0xc0) == 0x40)\r\nbreak;\r\n}\r\nif (j >= 55)\r\nreturn -1;\r\nfor (byte = 0; byte < msgs[i].len; byte++) {\r\nrc = dm_readb(DM1105_I2CDAT + byte + 1);\r\nif (rc < 0)\r\ngoto err;\r\nmsgs[i].buf[byte] = rc;\r\n}\r\n} else if ((msgs[i].buf[0] == 0xf7) && (msgs[i].addr == 0x55)) {\r\nlen = msgs[i].len - 1;\r\nk = 1;\r\ndo {\r\ndm_writeb(DM1105_I2CDAT, msgs[i].addr << 1);\r\ndm_writeb(DM1105_I2CDAT + 1, 0xf7);\r\nfor (byte = 0; byte < (len > 48 ? 48 : len); byte++) {\r\ndata = msgs[i].buf[k + byte];\r\ndm_writeb(DM1105_I2CDAT + byte + 2, data);\r\n}\r\ndm_writeb(DM1105_I2CCTR, 0x82 + (len > 48 ? 48 : len));\r\nfor (j = 0; j < 25; j++) {\r\nmdelay(10);\r\nstatus = dm_readb(DM1105_I2CSTS);\r\nif ((status & 0xc0) == 0x40)\r\nbreak;\r\n}\r\nif (j >= 25)\r\nreturn -1;\r\nk += 48;\r\nlen -= 48;\r\n} while (len > 0);\r\n} else {\r\ndm_writeb(DM1105_I2CDAT, msgs[i].addr << 1);\r\nfor (byte = 0; byte < msgs[i].len; byte++) {\r\ndata = msgs[i].buf[byte];\r\ndm_writeb(DM1105_I2CDAT + byte + 1, data);\r\n}\r\ndm_writeb(DM1105_I2CCTR, 0x81 + msgs[i].len);\r\nfor (j = 0; j < 25; j++) {\r\nmdelay(10);\r\nstatus = dm_readb(DM1105_I2CSTS);\r\nif ((status & 0xc0) == 0x40)\r\nbreak;\r\n}\r\nif (j >= 25)\r\nreturn -1;\r\n}\r\n}\r\nreturn num;\r\nerr:\r\nreturn rc;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic inline struct dm1105_dev *feed_to_dm1105_dev(struct dvb_demux_feed *feed)\r\n{\r\nreturn container_of(feed->demux, struct dm1105_dev, demux);\r\n}\r\nstatic inline struct dm1105_dev *frontend_to_dm1105_dev(struct dvb_frontend *fe)\r\n{\r\nreturn container_of(fe->dvb, struct dm1105_dev, dvb_adapter);\r\n}\r\nstatic int dm1105_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct dm1105_dev *dev = frontend_to_dm1105_dev(fe);\r\ndm1105_gpio_enable(dev, dm1105_boards[dev->boardnr].lnb.mask, 1);\r\nif (voltage == SEC_VOLTAGE_18)\r\ndm1105_gpio_andor(dev,\r\ndm1105_boards[dev->boardnr].lnb.mask,\r\ndm1105_boards[dev->boardnr].lnb.v18);\r\nelse if (voltage == SEC_VOLTAGE_13)\r\ndm1105_gpio_andor(dev,\r\ndm1105_boards[dev->boardnr].lnb.mask,\r\ndm1105_boards[dev->boardnr].lnb.v13);\r\nelse\r\ndm1105_gpio_andor(dev,\r\ndm1105_boards[dev->boardnr].lnb.mask,\r\ndm1105_boards[dev->boardnr].lnb.off);\r\nreturn 0;\r\n}\r\nstatic void dm1105_set_dma_addr(struct dm1105_dev *dev)\r\n{\r\ndm_writel(DM1105_STADR, (__force u32)cpu_to_le32(dev->dma_addr));\r\n}\r\nstatic int dm1105_dma_map(struct dm1105_dev *dev)\r\n{\r\ndev->ts_buf = pci_alloc_consistent(dev->pdev,\r\n6 * DM1105_DMA_BYTES,\r\n&dev->dma_addr);\r\nreturn !dev->ts_buf;\r\n}\r\nstatic void dm1105_dma_unmap(struct dm1105_dev *dev)\r\n{\r\npci_free_consistent(dev->pdev,\r\n6 * DM1105_DMA_BYTES,\r\ndev->ts_buf,\r\ndev->dma_addr);\r\n}\r\nstatic void dm1105_enable_irqs(struct dm1105_dev *dev)\r\n{\r\ndm_writeb(DM1105_INTMAK, INTMAK_ALLMASK);\r\ndm_writeb(DM1105_CR, 1);\r\n}\r\nstatic void dm1105_disable_irqs(struct dm1105_dev *dev)\r\n{\r\ndm_writeb(DM1105_INTMAK, INTMAK_IRM);\r\ndm_writeb(DM1105_CR, 0);\r\n}\r\nstatic int dm1105_start_feed(struct dvb_demux_feed *f)\r\n{\r\nstruct dm1105_dev *dev = feed_to_dm1105_dev(f);\r\nif (dev->full_ts_users++ == 0)\r\ndm1105_enable_irqs(dev);\r\nreturn 0;\r\n}\r\nstatic int dm1105_stop_feed(struct dvb_demux_feed *f)\r\n{\r\nstruct dm1105_dev *dev = feed_to_dm1105_dev(f);\r\nif (--dev->full_ts_users == 0)\r\ndm1105_disable_irqs(dev);\r\nreturn 0;\r\n}\r\nstatic void dm1105_emit_key(struct work_struct *work)\r\n{\r\nstruct infrared *ir = container_of(work, struct infrared, work);\r\nu32 ircom = ir->ir_command;\r\nu8 data;\r\nif (ir_debug)\r\nprintk(KERN_INFO "%s: received byte 0x%04x\n", __func__, ircom);\r\ndata = (ircom >> 8) & 0x7f;\r\nrc_keydown(ir->dev, RC_TYPE_UNKNOWN, data, 0);\r\n}\r\nstatic void dm1105_dmx_buffer(struct work_struct *work)\r\n{\r\nstruct dm1105_dev *dev = container_of(work, struct dm1105_dev, work);\r\nunsigned int nbpackets;\r\nu32 oldwrp = dev->wrp;\r\nu32 nextwrp = dev->nextwrp;\r\nif (!((dev->ts_buf[oldwrp] == 0x47) &&\r\n(dev->ts_buf[oldwrp + 188] == 0x47) &&\r\n(dev->ts_buf[oldwrp + 188 * 2] == 0x47))) {\r\ndev->PacketErrorCount++;\r\nif ((dev->PacketErrorCount >= 2) &&\r\n(dev->dmarst == 0)) {\r\ndm_writeb(DM1105_RST, 1);\r\ndev->wrp = 0;\r\ndev->PacketErrorCount = 0;\r\ndev->dmarst = 0;\r\nreturn;\r\n}\r\n}\r\nif (nextwrp < oldwrp) {\r\nmemcpy(dev->ts_buf + dev->buffer_size, dev->ts_buf, nextwrp);\r\nnbpackets = ((dev->buffer_size - oldwrp) + nextwrp) / 188;\r\n} else\r\nnbpackets = (nextwrp - oldwrp) / 188;\r\ndev->wrp = nextwrp;\r\ndvb_dmx_swfilter_packets(&dev->demux, &dev->ts_buf[oldwrp], nbpackets);\r\n}\r\nstatic irqreturn_t dm1105_irq(int irq, void *dev_id)\r\n{\r\nstruct dm1105_dev *dev = dev_id;\r\nunsigned int intsts = dm_readb(DM1105_INTSTS);\r\ndm_writeb(DM1105_INTSTS, intsts);\r\nswitch (intsts) {\r\ncase INTSTS_TSIRQ:\r\ncase (INTSTS_TSIRQ | INTSTS_IR):\r\ndev->nextwrp = dm_readl(DM1105_WRP) - dm_readl(DM1105_STADR);\r\nqueue_work(dev->wq, &dev->work);\r\nbreak;\r\ncase INTSTS_IR:\r\ndev->ir.ir_command = dm_readl(DM1105_IRCODE);\r\nschedule_work(&dev->ir.work);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dm1105_ir_init(struct dm1105_dev *dm1105)\r\n{\r\nstruct rc_dev *dev;\r\nint err = -ENOMEM;\r\ndev = rc_allocate_device();\r\nif (!dev)\r\nreturn -ENOMEM;\r\nsnprintf(dm1105->ir.input_phys, sizeof(dm1105->ir.input_phys),\r\n"pci-%s/ir0", pci_name(dm1105->pdev));\r\ndev->driver_name = MODULE_NAME;\r\ndev->map_name = RC_MAP_DM1105_NEC;\r\ndev->driver_type = RC_DRIVER_SCANCODE;\r\ndev->input_name = "DVB on-card IR receiver";\r\ndev->input_phys = dm1105->ir.input_phys;\r\ndev->input_id.bustype = BUS_PCI;\r\ndev->input_id.version = 1;\r\nif (dm1105->pdev->subsystem_vendor) {\r\ndev->input_id.vendor = dm1105->pdev->subsystem_vendor;\r\ndev->input_id.product = dm1105->pdev->subsystem_device;\r\n} else {\r\ndev->input_id.vendor = dm1105->pdev->vendor;\r\ndev->input_id.product = dm1105->pdev->device;\r\n}\r\ndev->dev.parent = &dm1105->pdev->dev;\r\nINIT_WORK(&dm1105->ir.work, dm1105_emit_key);\r\nerr = rc_register_device(dev);\r\nif (err < 0) {\r\nrc_free_device(dev);\r\nreturn err;\r\n}\r\ndm1105->ir.dev = dev;\r\nreturn 0;\r\n}\r\nstatic void dm1105_ir_exit(struct dm1105_dev *dm1105)\r\n{\r\nrc_unregister_device(dm1105->ir.dev);\r\n}\r\nstatic int dm1105_hw_init(struct dm1105_dev *dev)\r\n{\r\ndm1105_disable_irqs(dev);\r\ndm_writeb(DM1105_HOST_CTR, 0);\r\ndm_writeb(DM1105_DTALENTH, 188);\r\ndm_writew(DM1105_TSCTR, 0xc10a);\r\ndm1105_dma_map(dev);\r\ndm1105_set_dma_addr(dev);\r\ndm_writel(DM1105_RLEN, 5 * DM1105_DMA_BYTES);\r\ndm_writeb(DM1105_INTCNT, 47);\r\ndm_writeb(DM1105_IRCTR, (DM1105_IR_EN | DM1105_SYS_CHK));\r\ndm_writeb(DM1105_IRMODE, 0);\r\ndm_writew(DM1105_SYSTEMCODE, 0);\r\nreturn 0;\r\n}\r\nstatic void dm1105_hw_exit(struct dm1105_dev *dev)\r\n{\r\ndm1105_disable_irqs(dev);\r\ndm_writeb(DM1105_IRCTR, 0);\r\ndm_writeb(DM1105_INTMAK, INTMAK_NONEMASK);\r\ndm1105_dma_unmap(dev);\r\n}\r\nstatic int frontend_init(struct dm1105_dev *dev)\r\n{\r\nint ret;\r\nswitch (dev->boardnr) {\r\ncase DM1105_BOARD_UNBRANDED_I2C_ON_GPIO:\r\ndm1105_gpio_enable(dev, GPIO15, 1);\r\ndm1105_gpio_clear(dev, GPIO15);\r\nmsleep(100);\r\ndm1105_gpio_set(dev, GPIO15);\r\nmsleep(200);\r\ndev->fe = dvb_attach(\r\nstv0299_attach, &sharp_z0194a_config,\r\n&dev->i2c_bb_adap);\r\nif (dev->fe) {\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\ndvb_attach(dvb_pll_attach, dev->fe, 0x60,\r\n&dev->i2c_bb_adap, DVB_PLL_OPERA1);\r\nbreak;\r\n}\r\ndev->fe = dvb_attach(\r\nstv0288_attach, &earda_config,\r\n&dev->i2c_bb_adap);\r\nif (dev->fe) {\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\ndvb_attach(stb6000_attach, dev->fe, 0x61,\r\n&dev->i2c_bb_adap);\r\nbreak;\r\n}\r\ndev->fe = dvb_attach(\r\nsi21xx_attach, &serit_config,\r\n&dev->i2c_bb_adap);\r\nif (dev->fe)\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\nbreak;\r\ncase DM1105_BOARD_DVBWORLD_2004:\r\ndev->fe = dvb_attach(\r\ncx24116_attach, &serit_sp2633_config,\r\n&dev->i2c_adap);\r\nif (dev->fe) {\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\nbreak;\r\n}\r\ndev->fe = dvb_attach(\r\nds3000_attach, &dvbworld_ds3000_config,\r\n&dev->i2c_adap);\r\nif (dev->fe) {\r\ndvb_attach(ts2020_attach, dev->fe,\r\n&dvbworld_ts2020_config, &dev->i2c_adap);\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\n}\r\nbreak;\r\ncase DM1105_BOARD_DVBWORLD_2002:\r\ncase DM1105_BOARD_AXESS_DM05:\r\ndefault:\r\ndev->fe = dvb_attach(\r\nstv0299_attach, &sharp_z0194a_config,\r\n&dev->i2c_adap);\r\nif (dev->fe) {\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\ndvb_attach(dvb_pll_attach, dev->fe, 0x60,\r\n&dev->i2c_adap, DVB_PLL_OPERA1);\r\nbreak;\r\n}\r\ndev->fe = dvb_attach(\r\nstv0288_attach, &earda_config,\r\n&dev->i2c_adap);\r\nif (dev->fe) {\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\ndvb_attach(stb6000_attach, dev->fe, 0x61,\r\n&dev->i2c_adap);\r\nbreak;\r\n}\r\ndev->fe = dvb_attach(\r\nsi21xx_attach, &serit_config,\r\n&dev->i2c_adap);\r\nif (dev->fe)\r\ndev->fe->ops.set_voltage = dm1105_set_voltage;\r\n}\r\nif (!dev->fe) {\r\ndev_err(&dev->pdev->dev, "could not attach frontend\n");\r\nreturn -ENODEV;\r\n}\r\nret = dvb_register_frontend(&dev->dvb_adapter, dev->fe);\r\nif (ret < 0) {\r\nif (dev->fe->ops.release)\r\ndev->fe->ops.release(dev->fe);\r\ndev->fe = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dm1105_read_mac(struct dm1105_dev *dev, u8 *mac)\r\n{\r\nstatic u8 command[1] = { 0x28 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = IIC_24C01_addr >> 1,\r\n.flags = 0,\r\n.buf = command,\r\n.len = 1\r\n}, {\r\n.addr = IIC_24C01_addr >> 1,\r\n.flags = I2C_M_RD,\r\n.buf = mac,\r\n.len = 6\r\n},\r\n};\r\ndm1105_i2c_xfer(&dev->i2c_adap, msg , 2);\r\ndev_info(&dev->pdev->dev, "MAC %pM\n", mac);\r\n}\r\nstatic int dm1105_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct dm1105_dev *dev;\r\nstruct dvb_adapter *dvb_adapter;\r\nstruct dvb_demux *dvbdemux;\r\nstruct dmx_demux *dmx;\r\nint ret = -ENOMEM;\r\nint i;\r\ndev = kzalloc(sizeof(struct dm1105_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->nr = dm1105_devcount;\r\ndev->boardnr = UNSET;\r\nif (card[dev->nr] < ARRAY_SIZE(dm1105_boards))\r\ndev->boardnr = card[dev->nr];\r\nfor (i = 0; UNSET == dev->boardnr &&\r\ni < ARRAY_SIZE(dm1105_subids); i++)\r\nif (pdev->subsystem_vendor ==\r\ndm1105_subids[i].subvendor &&\r\npdev->subsystem_device ==\r\ndm1105_subids[i].subdevice)\r\ndev->boardnr = dm1105_subids[i].card;\r\nif (UNSET == dev->boardnr) {\r\ndev->boardnr = DM1105_BOARD_UNKNOWN;\r\ndm1105_card_list(pdev);\r\n}\r\ndm1105_devcount++;\r\ndev->pdev = pdev;\r\ndev->buffer_size = 5 * DM1105_DMA_BYTES;\r\ndev->PacketErrorCount = 0;\r\ndev->dmarst = 0;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0)\r\ngoto err_kfree;\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, DRIVER_NAME);\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\ndev->io_mem = pci_iomap(pdev, 0, pci_resource_len(pdev, 0));\r\nif (!dev->io_mem) {\r\nret = -EIO;\r\ngoto err_pci_release_regions;\r\n}\r\nspin_lock_init(&dev->lock);\r\npci_set_drvdata(pdev, dev);\r\nret = dm1105_hw_init(dev);\r\nif (ret < 0)\r\ngoto err_pci_iounmap;\r\ni2c_set_adapdata(&dev->i2c_adap, dev);\r\nstrcpy(dev->i2c_adap.name, DRIVER_NAME);\r\ndev->i2c_adap.owner = THIS_MODULE;\r\ndev->i2c_adap.dev.parent = &pdev->dev;\r\ndev->i2c_adap.algo = &dm1105_algo;\r\ndev->i2c_adap.algo_data = dev;\r\nret = i2c_add_adapter(&dev->i2c_adap);\r\nif (ret < 0)\r\ngoto err_dm1105_hw_exit;\r\ni2c_set_adapdata(&dev->i2c_bb_adap, dev);\r\nstrcpy(dev->i2c_bb_adap.name, DM1105_I2C_GPIO_NAME);\r\ndev->i2c_bb_adap.owner = THIS_MODULE;\r\ndev->i2c_bb_adap.dev.parent = &pdev->dev;\r\ndev->i2c_bb_adap.algo_data = &dev->i2c_bit;\r\ndev->i2c_bit.data = dev;\r\ndev->i2c_bit.setsda = dm1105_setsda;\r\ndev->i2c_bit.setscl = dm1105_setscl;\r\ndev->i2c_bit.getsda = dm1105_getsda;\r\ndev->i2c_bit.getscl = dm1105_getscl;\r\ndev->i2c_bit.udelay = 10;\r\ndev->i2c_bit.timeout = 10;\r\ndm1105_setsda(dev, 1);\r\ndm1105_setscl(dev, 1);\r\nret = i2c_bit_add_bus(&dev->i2c_bb_adap);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\nret = dvb_register_adapter(&dev->dvb_adapter, DRIVER_NAME,\r\nTHIS_MODULE, &pdev->dev, adapter_nr);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapters;\r\ndvb_adapter = &dev->dvb_adapter;\r\ndm1105_read_mac(dev, dvb_adapter->proposed_mac);\r\ndvbdemux = &dev->demux;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = dm1105_start_feed;\r\ndvbdemux->stop_feed = dm1105_stop_feed;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\r\nret = dvb_dmx_init(dvbdemux);\r\nif (ret < 0)\r\ngoto err_dvb_unregister_adapter;\r\ndmx = &dvbdemux->dmx;\r\ndev->dmxdev.filternum = 256;\r\ndev->dmxdev.demux = dmx;\r\ndev->dmxdev.capabilities = 0;\r\nret = dvb_dmxdev_init(&dev->dmxdev, dvb_adapter);\r\nif (ret < 0)\r\ngoto err_dvb_dmx_release;\r\ndev->hw_frontend.source = DMX_FRONTEND_0;\r\nret = dmx->add_frontend(dmx, &dev->hw_frontend);\r\nif (ret < 0)\r\ngoto err_dvb_dmxdev_release;\r\ndev->mem_frontend.source = DMX_MEMORY_FE;\r\nret = dmx->add_frontend(dmx, &dev->mem_frontend);\r\nif (ret < 0)\r\ngoto err_remove_hw_frontend;\r\nret = dmx->connect_frontend(dmx, &dev->hw_frontend);\r\nif (ret < 0)\r\ngoto err_remove_mem_frontend;\r\nret = dvb_net_init(dvb_adapter, &dev->dvbnet, dmx);\r\nif (ret < 0)\r\ngoto err_disconnect_frontend;\r\nret = frontend_init(dev);\r\nif (ret < 0)\r\ngoto err_dvb_net;\r\ndm1105_ir_init(dev);\r\nINIT_WORK(&dev->work, dm1105_dmx_buffer);\r\nsprintf(dev->wqn, "%s/%d", dvb_adapter->name, dvb_adapter->num);\r\ndev->wq = create_singlethread_workqueue(dev->wqn);\r\nif (!dev->wq) {\r\nret = -ENOMEM;\r\ngoto err_dvb_net;\r\n}\r\nret = request_irq(pdev->irq, dm1105_irq, IRQF_SHARED,\r\nDRIVER_NAME, dev);\r\nif (ret < 0)\r\ngoto err_workqueue;\r\nreturn 0;\r\nerr_workqueue:\r\ndestroy_workqueue(dev->wq);\r\nerr_dvb_net:\r\ndvb_net_release(&dev->dvbnet);\r\nerr_disconnect_frontend:\r\ndmx->disconnect_frontend(dmx);\r\nerr_remove_mem_frontend:\r\ndmx->remove_frontend(dmx, &dev->mem_frontend);\r\nerr_remove_hw_frontend:\r\ndmx->remove_frontend(dmx, &dev->hw_frontend);\r\nerr_dvb_dmxdev_release:\r\ndvb_dmxdev_release(&dev->dmxdev);\r\nerr_dvb_dmx_release:\r\ndvb_dmx_release(dvbdemux);\r\nerr_dvb_unregister_adapter:\r\ndvb_unregister_adapter(dvb_adapter);\r\nerr_i2c_del_adapters:\r\ni2c_del_adapter(&dev->i2c_bb_adap);\r\nerr_i2c_del_adapter:\r\ni2c_del_adapter(&dev->i2c_adap);\r\nerr_dm1105_hw_exit:\r\ndm1105_hw_exit(dev);\r\nerr_pci_iounmap:\r\npci_iounmap(pdev, dev->io_mem);\r\nerr_pci_release_regions:\r\npci_release_regions(pdev);\r\nerr_pci_disable_device:\r\npci_disable_device(pdev);\r\nerr_kfree:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic void dm1105_remove(struct pci_dev *pdev)\r\n{\r\nstruct dm1105_dev *dev = pci_get_drvdata(pdev);\r\nstruct dvb_adapter *dvb_adapter = &dev->dvb_adapter;\r\nstruct dvb_demux *dvbdemux = &dev->demux;\r\nstruct dmx_demux *dmx = &dvbdemux->dmx;\r\ndm1105_ir_exit(dev);\r\ndmx->close(dmx);\r\ndvb_net_release(&dev->dvbnet);\r\nif (dev->fe)\r\ndvb_unregister_frontend(dev->fe);\r\ndmx->disconnect_frontend(dmx);\r\ndmx->remove_frontend(dmx, &dev->mem_frontend);\r\ndmx->remove_frontend(dmx, &dev->hw_frontend);\r\ndvb_dmxdev_release(&dev->dmxdev);\r\ndvb_dmx_release(dvbdemux);\r\ndvb_unregister_adapter(dvb_adapter);\r\ni2c_del_adapter(&dev->i2c_adap);\r\ndm1105_hw_exit(dev);\r\nsynchronize_irq(pdev->irq);\r\nfree_irq(pdev->irq, dev);\r\npci_iounmap(pdev, dev->io_mem);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\ndm1105_devcount--;\r\nkfree(dev);\r\n}
