static long __init sp804_get_clock_rate(struct clk *clk)\r\n{\r\nlong rate;\r\nint err;\r\nerr = clk_prepare(clk);\r\nif (err) {\r\npr_err("sp804: clock failed to prepare: %d\n", err);\r\nclk_put(clk);\r\nreturn err;\r\n}\r\nerr = clk_enable(clk);\r\nif (err) {\r\npr_err("sp804: clock failed to enable: %d\n", err);\r\nclk_unprepare(clk);\r\nclk_put(clk);\r\nreturn err;\r\n}\r\nrate = clk_get_rate(clk);\r\nif (rate < 0) {\r\npr_err("sp804: clock failed to get rate: %ld\n", rate);\r\nclk_disable(clk);\r\nclk_unprepare(clk);\r\nclk_put(clk);\r\n}\r\nreturn rate;\r\n}\r\nstatic u64 notrace sp804_read(void)\r\n{\r\nreturn ~readl_relaxed(sched_clock_base + TIMER_VALUE);\r\n}\r\nvoid __init __sp804_clocksource_and_sched_clock_init(void __iomem *base,\r\nconst char *name,\r\nstruct clk *clk,\r\nint use_sched_clock)\r\n{\r\nlong rate;\r\nif (!clk) {\r\nclk = clk_get_sys("sp804", name);\r\nif (IS_ERR(clk)) {\r\npr_err("sp804: clock not found: %d\n",\r\n(int)PTR_ERR(clk));\r\nreturn;\r\n}\r\n}\r\nrate = sp804_get_clock_rate(clk);\r\nif (rate < 0)\r\nreturn;\r\nwritel(0, base + TIMER_CTRL);\r\nwritel(0xffffffff, base + TIMER_LOAD);\r\nwritel(0xffffffff, base + TIMER_VALUE);\r\nwritel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,\r\nbase + TIMER_CTRL);\r\nclocksource_mmio_init(base + TIMER_VALUE, name,\r\nrate, 200, 32, clocksource_mmio_readl_down);\r\nif (use_sched_clock) {\r\nsched_clock_base = base;\r\nsched_clock_register(sp804_read, 32, rate);\r\n}\r\n}\r\nstatic irqreturn_t sp804_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(1, clkevt_base + TIMER_INTCLR);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sp804_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = TIMER_CTRL_32BIT | TIMER_CTRL_IE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nwritel(clkevt_reload, clkevt_base + TIMER_LOAD);\r\nctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nctrl |= TIMER_CTRL_ONESHOT;\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nbreak;\r\n}\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\n}\r\nstatic int sp804_set_next_event(unsigned long next,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = readl(clkevt_base + TIMER_CTRL);\r\nwritel(next, clkevt_base + TIMER_LOAD);\r\nwritel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nvoid __init __sp804_clockevents_init(void __iomem *base, unsigned int irq, struct clk *clk, const char *name)\r\n{\r\nstruct clock_event_device *evt = &sp804_clockevent;\r\nlong rate;\r\nif (!clk)\r\nclk = clk_get_sys("sp804", name);\r\nif (IS_ERR(clk)) {\r\npr_err("sp804: %s clock not found: %d\n", name,\r\n(int)PTR_ERR(clk));\r\nreturn;\r\n}\r\nrate = sp804_get_clock_rate(clk);\r\nif (rate < 0)\r\nreturn;\r\nclkevt_base = base;\r\nclkevt_reload = DIV_ROUND_CLOSEST(rate, HZ);\r\nevt->name = name;\r\nevt->irq = irq;\r\nevt->cpumask = cpu_possible_mask;\r\nwritel(0, base + TIMER_CTRL);\r\nsetup_irq(irq, &sp804_timer_irq);\r\nclockevents_config_and_register(evt, rate, 0xf, 0xffffffff);\r\n}\r\nstatic void __init sp804_of_init(struct device_node *np)\r\n{\r\nstatic bool initialized = false;\r\nvoid __iomem *base;\r\nint irq;\r\nu32 irq_num = 0;\r\nstruct clk *clk1, *clk2;\r\nconst char *name = of_get_property(np, "compatible", NULL);\r\nbase = of_iomap(np, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nwritel(0, base + TIMER_CTRL);\r\nwritel(0, base + TIMER_2_BASE + TIMER_CTRL);\r\nif (initialized || !of_device_is_available(np))\r\ngoto err;\r\nclk1 = of_clk_get(np, 0);\r\nif (IS_ERR(clk1))\r\nclk1 = NULL;\r\nif (of_count_phandle_with_args(np, "clocks", "#clock-cells") == 3) {\r\nclk2 = of_clk_get(np, 1);\r\nif (IS_ERR(clk2)) {\r\npr_err("sp804: %s clock not found: %d\n", np->name,\r\n(int)PTR_ERR(clk2));\r\nclk2 = NULL;\r\n}\r\n} else\r\nclk2 = clk1;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0)\r\ngoto err;\r\nof_property_read_u32(np, "arm,sp804-has-irq", &irq_num);\r\nif (irq_num == 2) {\r\n__sp804_clockevents_init(base + TIMER_2_BASE, irq, clk2, name);\r\n__sp804_clocksource_and_sched_clock_init(base, name, clk1, 1);\r\n} else {\r\n__sp804_clockevents_init(base, irq, clk1 , name);\r\n__sp804_clocksource_and_sched_clock_init(base + TIMER_2_BASE,\r\nname, clk2, 1);\r\n}\r\ninitialized = true;\r\nreturn;\r\nerr:\r\niounmap(base);\r\n}\r\nstatic void __init integrator_cp_of_init(struct device_node *np)\r\n{\r\nstatic int init_count = 0;\r\nvoid __iomem *base;\r\nint irq;\r\nconst char *name = of_get_property(np, "compatible", NULL);\r\nstruct clk *clk;\r\nbase = of_iomap(np, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nclk = of_clk_get(np, 0);\r\nif (WARN_ON(IS_ERR(clk)))\r\nreturn;\r\nwritel(0, base + TIMER_CTRL);\r\nif (init_count == 2 || !of_device_is_available(np))\r\ngoto err;\r\nif (!init_count)\r\n__sp804_clocksource_and_sched_clock_init(base, name, clk, 0);\r\nelse {\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0)\r\ngoto err;\r\n__sp804_clockevents_init(base, irq, clk, name);\r\n}\r\ninit_count++;\r\nreturn;\r\nerr:\r\niounmap(base);\r\n}
