int tps6105x_set(struct tps6105x *tps6105x, u8 reg, u8 value)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&tps6105x->lock);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(tps6105x->client, reg, value);\r\nmutex_unlock(&tps6105x->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint tps6105x_get(struct tps6105x *tps6105x, u8 reg, u8 *buf)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&tps6105x->lock);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(tps6105x->client, reg);\r\nmutex_unlock(&tps6105x->lock);\r\nif (ret < 0)\r\nreturn ret;\r\n*buf = ret;\r\nreturn 0;\r\n}\r\nint tps6105x_mask_and_set(struct tps6105x *tps6105x, u8 reg,\r\nu8 bitmask, u8 bitvalues)\r\n{\r\nint ret;\r\nu8 regval;\r\nret = mutex_lock_interruptible(&tps6105x->lock);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(tps6105x->client, reg);\r\nif (ret < 0)\r\ngoto fail;\r\nregval = ret;\r\nregval = (~bitmask & regval) | (bitmask & bitvalues);\r\nret = i2c_smbus_write_byte_data(tps6105x->client, reg, regval);\r\nfail:\r\nmutex_unlock(&tps6105x->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tps6105x_startup(struct tps6105x *tps6105x)\r\n{\r\nint ret;\r\nu8 regval;\r\nret = tps6105x_get(tps6105x, TPS6105X_REG_0, &regval);\r\nif (ret)\r\nreturn ret;\r\nswitch (regval >> TPS6105X_REG0_MODE_SHIFT) {\r\ncase TPS6105X_REG0_MODE_SHUTDOWN:\r\ndev_info(&tps6105x->client->dev,\r\n"TPS6105x found in SHUTDOWN mode\n");\r\nbreak;\r\ncase TPS6105X_REG0_MODE_TORCH:\r\ndev_info(&tps6105x->client->dev,\r\n"TPS6105x found in TORCH mode\n");\r\nbreak;\r\ncase TPS6105X_REG0_MODE_TORCH_FLASH:\r\ndev_info(&tps6105x->client->dev,\r\n"TPS6105x found in FLASH mode\n");\r\nbreak;\r\ncase TPS6105X_REG0_MODE_VOLTAGE:\r\ndev_info(&tps6105x->client->dev,\r\n"TPS6105x found in VOLTAGE mode\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps6105x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps6105x *tps6105x;\r\nstruct tps6105x_platform_data *pdata;\r\nint ret;\r\nint i;\r\ntps6105x = devm_kmalloc(&client->dev, sizeof(*tps6105x), GFP_KERNEL);\r\nif (!tps6105x)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, tps6105x);\r\ntps6105x->client = client;\r\npdata = dev_get_platdata(&client->dev);\r\ntps6105x->pdata = pdata;\r\nmutex_init(&tps6105x->lock);\r\nret = tps6105x_startup(tps6105x);\r\nif (ret) {\r\ndev_err(&client->dev, "chip initialization failed\n");\r\nreturn ret;\r\n}\r\nswitch (pdata->mode) {\r\ncase TPS6105X_MODE_SHUTDOWN:\r\ndev_info(&client->dev,\r\n"present, not used for anything, only GPIO\n");\r\nbreak;\r\ncase TPS6105X_MODE_TORCH:\r\ntps6105x_cells[0].name = "tps6105x-leds";\r\ndev_warn(&client->dev,\r\n"torch mode is unsupported\n");\r\nbreak;\r\ncase TPS6105X_MODE_TORCH_FLASH:\r\ntps6105x_cells[0].name = "tps6105x-flash";\r\ndev_warn(&client->dev,\r\n"flash mode is unsupported\n");\r\nbreak;\r\ncase TPS6105X_MODE_VOLTAGE:\r\ntps6105x_cells[0].name ="tps6105x-regulator";\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tps6105x_cells); i++) {\r\ntps6105x_cells[i].platform_data = tps6105x;\r\ntps6105x_cells[i].pdata_size = sizeof(*tps6105x);\r\n}\r\nreturn mfd_add_devices(&client->dev, 0, tps6105x_cells,\r\nARRAY_SIZE(tps6105x_cells), NULL, 0, NULL);\r\n}\r\nstatic int tps6105x_remove(struct i2c_client *client)\r\n{\r\nstruct tps6105x *tps6105x = i2c_get_clientdata(client);\r\nmfd_remove_devices(&client->dev);\r\ntps6105x_mask_and_set(tps6105x, TPS6105X_REG_0,\r\nTPS6105X_REG0_MODE_MASK,\r\nTPS6105X_MODE_SHUTDOWN << TPS6105X_REG0_MODE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int __init tps6105x_init(void)\r\n{\r\nreturn i2c_add_driver(&tps6105x_driver);\r\n}\r\nstatic void __exit tps6105x_exit(void)\r\n{\r\ni2c_del_driver(&tps6105x_driver);\r\n}
