unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)\r\n{\r\nunsigned long long result;\r\nunsigned int rv;\r\ncp = _parse_integer_fixup_radix(cp, &base);\r\nrv = _parse_integer(cp, base, &result);\r\ncp += (rv & ~KSTRTOX_OVERFLOW);\r\nif (endp)\r\n*endp = (char *)cp;\r\nreturn result;\r\n}\r\nunsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)\r\n{\r\nreturn simple_strtoull(cp, endp, base);\r\n}\r\nlong simple_strtol(const char *cp, char **endp, unsigned int base)\r\n{\r\nif (*cp == '-')\r\nreturn -simple_strtoul(cp + 1, endp, base);\r\nreturn simple_strtoul(cp, endp, base);\r\n}\r\nlong long simple_strtoll(const char *cp, char **endp, unsigned int base)\r\n{\r\nif (*cp == '-')\r\nreturn -simple_strtoull(cp + 1, endp, base);\r\nreturn simple_strtoull(cp, endp, base);\r\n}\r\nstatic noinline_for_stack\r\nint skip_atoi(const char **s)\r\n{\r\nint i = 0;\r\nwhile (isdigit(**s))\r\ni = i*10 + *((*s)++) - '0';\r\nreturn i;\r\n}\r\nstatic noinline_for_stack\r\nchar *put_dec_full9(char *buf, unsigned q)\r\n{\r\nunsigned r;\r\nr = (q * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = (q - 10 * r) + '0';\r\nq = (r * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = (r - 10 * q) + '0';\r\nr = (q * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = (q - 10 * r) + '0';\r\nq = (r * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = (r - 10 * q) + '0';\r\nr = (q * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = (q - 10 * r) + '0';\r\nq = (r * 0x199a) >> 16;\r\n*buf++ = (r - 10 * q) + '0';\r\nr = (q * 0xcd) >> 11;\r\n*buf++ = (q - 10 * r) + '0';\r\nq = (r * 0xcd) >> 11;\r\n*buf++ = (r - 10 * q) + '0';\r\n*buf++ = q + '0';\r\nreturn buf;\r\n}\r\nstatic noinline_for_stack\r\nchar *put_dec_trunc8(char *buf, unsigned r)\r\n{\r\nunsigned q;\r\nwhile (r >= 10000) {\r\nq = r + '0';\r\nr = (r * (uint64_t)0x1999999a) >> 32;\r\n*buf++ = q - 10*r;\r\n}\r\nq = (r * 0x199a) >> 16;\r\n*buf++ = (r - 10 * q) + '0';\r\nif (q == 0)\r\nreturn buf;\r\nr = (q * 0xcd) >> 11;\r\n*buf++ = (q - 10 * r) + '0';\r\nif (r == 0)\r\nreturn buf;\r\nq = (r * 0xcd) >> 11;\r\n*buf++ = (r - 10 * q) + '0';\r\nif (q == 0)\r\nreturn buf;\r\n*buf++ = q + '0';\r\nreturn buf;\r\n}\r\nstatic\r\nchar *put_dec(char *buf, unsigned long long n)\r\n{\r\nif (n >= 100*1000*1000) {\r\nwhile (n >= 1000*1000*1000)\r\nbuf = put_dec_full9(buf, do_div(n, 1000*1000*1000));\r\nif (n >= 100*1000*1000)\r\nreturn put_dec_full9(buf, n);\r\n}\r\nreturn put_dec_trunc8(buf, n);\r\n}\r\nstatic noinline_for_stack\r\nvoid put_dec_full4(char *buf, unsigned q)\r\n{\r\nunsigned r;\r\nr = (q * 0xccd) >> 15;\r\nbuf[0] = (q - 10 * r) + '0';\r\nq = (r * 0xcd) >> 11;\r\nbuf[1] = (r - 10 * q) + '0';\r\nr = (q * 0xcd) >> 11;\r\nbuf[2] = (q - 10 * r) + '0';\r\nbuf[3] = r + '0';\r\n}\r\nstatic\r\nunsigned put_dec_helper4(char *buf, unsigned x)\r\n{\r\nuint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;\r\nput_dec_full4(buf, x - q * 10000);\r\nreturn q;\r\n}\r\nstatic\r\nchar *put_dec(char *buf, unsigned long long n)\r\n{\r\nuint32_t d3, d2, d1, q, h;\r\nif (n < 100*1000*1000)\r\nreturn put_dec_trunc8(buf, n);\r\nd1 = ((uint32_t)n >> 16);\r\nh = (n >> 32);\r\nd2 = (h ) & 0xffff;\r\nd3 = (h >> 16);\r\nq = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);\r\nq = put_dec_helper4(buf, q);\r\nq += 7671 * d3 + 9496 * d2 + 6 * d1;\r\nq = put_dec_helper4(buf+4, q);\r\nq += 4749 * d3 + 42 * d2;\r\nq = put_dec_helper4(buf+8, q);\r\nq += 281 * d3;\r\nbuf += 12;\r\nif (q)\r\nbuf = put_dec_trunc8(buf, q);\r\nelse while (buf[-1] == '0')\r\n--buf;\r\nreturn buf;\r\n}\r\nint num_to_str(char *buf, int size, unsigned long long num)\r\n{\r\nchar tmp[sizeof(num) * 3];\r\nint idx, len;\r\nif (num <= 9) {\r\ntmp[0] = '0' + num;\r\nlen = 1;\r\n} else {\r\nlen = put_dec(tmp, num) - tmp;\r\n}\r\nif (len > size)\r\nreturn 0;\r\nfor (idx = 0; idx < len; ++idx)\r\nbuf[idx] = tmp[len - idx - 1];\r\nreturn len;\r\n}\r\nstatic noinline_for_stack\r\nchar *number(char *buf, char *end, unsigned long long num,\r\nstruct printf_spec spec)\r\n{\r\nstatic const char digits[16] = "0123456789ABCDEF";\r\nchar tmp[66];\r\nchar sign;\r\nchar locase;\r\nint need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);\r\nint i;\r\nbool is_zero = num == 0LL;\r\nlocase = (spec.flags & SMALL);\r\nif (spec.flags & LEFT)\r\nspec.flags &= ~ZEROPAD;\r\nsign = 0;\r\nif (spec.flags & SIGN) {\r\nif ((signed long long)num < 0) {\r\nsign = '-';\r\nnum = -(signed long long)num;\r\nspec.field_width--;\r\n} else if (spec.flags & PLUS) {\r\nsign = '+';\r\nspec.field_width--;\r\n} else if (spec.flags & SPACE) {\r\nsign = ' ';\r\nspec.field_width--;\r\n}\r\n}\r\nif (need_pfx) {\r\nif (spec.base == 16)\r\nspec.field_width -= 2;\r\nelse if (!is_zero)\r\nspec.field_width--;\r\n}\r\ni = 0;\r\nif (num < spec.base)\r\ntmp[i++] = digits[num] | locase;\r\nelse if (spec.base != 10) {\r\nint mask = spec.base - 1;\r\nint shift = 3;\r\nif (spec.base == 16)\r\nshift = 4;\r\ndo {\r\ntmp[i++] = (digits[((unsigned char)num) & mask] | locase);\r\nnum >>= shift;\r\n} while (num);\r\n} else {\r\ni = put_dec(tmp, num) - tmp;\r\n}\r\nif (i > spec.precision)\r\nspec.precision = i;\r\nspec.field_width -= spec.precision;\r\nif (!(spec.flags & (ZEROPAD+LEFT))) {\r\nwhile (--spec.field_width >= 0) {\r\nif (buf < end)\r\n*buf = ' ';\r\n++buf;\r\n}\r\n}\r\nif (sign) {\r\nif (buf < end)\r\n*buf = sign;\r\n++buf;\r\n}\r\nif (need_pfx) {\r\nif (spec.base == 16 || !is_zero) {\r\nif (buf < end)\r\n*buf = '0';\r\n++buf;\r\n}\r\nif (spec.base == 16) {\r\nif (buf < end)\r\n*buf = ('X' | locase);\r\n++buf;\r\n}\r\n}\r\nif (!(spec.flags & LEFT)) {\r\nchar c = (spec.flags & ZEROPAD) ? '0' : ' ';\r\nwhile (--spec.field_width >= 0) {\r\nif (buf < end)\r\n*buf = c;\r\n++buf;\r\n}\r\n}\r\nwhile (i <= --spec.precision) {\r\nif (buf < end)\r\n*buf = '0';\r\n++buf;\r\n}\r\nwhile (--i >= 0) {\r\nif (buf < end)\r\n*buf = tmp[i];\r\n++buf;\r\n}\r\nwhile (--spec.field_width >= 0) {\r\nif (buf < end)\r\n*buf = ' ';\r\n++buf;\r\n}\r\nreturn buf;\r\n}\r\nstatic noinline_for_stack\r\nchar *string(char *buf, char *end, const char *s, struct printf_spec spec)\r\n{\r\nint len, i;\r\nif ((unsigned long)s < PAGE_SIZE)\r\ns = "(null)";\r\nlen = strnlen(s, spec.precision);\r\nif (!(spec.flags & LEFT)) {\r\nwhile (len < spec.field_width--) {\r\nif (buf < end)\r\n*buf = ' ';\r\n++buf;\r\n}\r\n}\r\nfor (i = 0; i < len; ++i) {\r\nif (buf < end)\r\n*buf = *s;\r\n++buf; ++s;\r\n}\r\nwhile (len < spec.field_width--) {\r\nif (buf < end)\r\n*buf = ' ';\r\n++buf;\r\n}\r\nreturn buf;\r\n}\r\nstatic void widen(char *buf, char *end, unsigned len, unsigned spaces)\r\n{\r\nsize_t size;\r\nif (buf >= end)\r\nreturn;\r\nsize = end - buf;\r\nif (size <= spaces) {\r\nmemset(buf, ' ', size);\r\nreturn;\r\n}\r\nif (len) {\r\nif (len > size - spaces)\r\nlen = size - spaces;\r\nmemmove(buf + spaces, buf, len);\r\n}\r\nmemset(buf, ' ', spaces);\r\n}\r\nstatic noinline_for_stack\r\nchar *dentry_name(char *buf, char *end, const struct dentry *d, struct printf_spec spec,\r\nconst char *fmt)\r\n{\r\nconst char *array[4], *s;\r\nconst struct dentry *p;\r\nint depth;\r\nint i, n;\r\nswitch (fmt[1]) {\r\ncase '2': case '3': case '4':\r\ndepth = fmt[1] - '0';\r\nbreak;\r\ndefault:\r\ndepth = 1;\r\n}\r\nrcu_read_lock();\r\nfor (i = 0; i < depth; i++, d = p) {\r\np = ACCESS_ONCE(d->d_parent);\r\narray[i] = ACCESS_ONCE(d->d_name.name);\r\nif (p == d) {\r\nif (i)\r\narray[i] = "";\r\ni++;\r\nbreak;\r\n}\r\n}\r\ns = array[--i];\r\nfor (n = 0; n != spec.precision; n++, buf++) {\r\nchar c = *s++;\r\nif (!c) {\r\nif (!i)\r\nbreak;\r\nc = '/';\r\ns = array[--i];\r\n}\r\nif (buf < end)\r\n*buf = c;\r\n}\r\nrcu_read_unlock();\r\nif (n < spec.field_width) {\r\nunsigned spaces = spec.field_width - n;\r\nif (!(spec.flags & LEFT)) {\r\nwiden(buf - n, end, n, spaces);\r\nreturn buf + spaces;\r\n}\r\nwhile (spaces--) {\r\nif (buf < end)\r\n*buf = ' ';\r\n++buf;\r\n}\r\n}\r\nreturn buf;\r\n}\r\nstatic noinline_for_stack\r\nchar *symbol_string(char *buf, char *end, void *ptr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nunsigned long value;\r\n#ifdef CONFIG_KALLSYMS\r\nchar sym[KSYM_SYMBOL_LEN];\r\n#endif\r\nif (fmt[1] == 'R')\r\nptr = __builtin_extract_return_addr(ptr);\r\nvalue = (unsigned long)ptr;\r\n#ifdef CONFIG_KALLSYMS\r\nif (*fmt == 'B')\r\nsprint_backtrace(sym, value);\r\nelse if (*fmt != 'f' && *fmt != 's')\r\nsprint_symbol(sym, value);\r\nelse\r\nsprint_symbol_no_offset(sym, value);\r\nreturn string(buf, end, sym, spec);\r\n#else\r\nspec.field_width = 2 * sizeof(void *);\r\nspec.flags |= SPECIAL | SMALL | ZEROPAD;\r\nspec.base = 16;\r\nreturn number(buf, end, value, spec);\r\n#endif\r\n}\r\nstatic noinline_for_stack\r\nchar *resource_string(char *buf, char *end, struct resource *res,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\n#ifndef IO_RSRC_PRINTK_SIZE\r\n#define IO_RSRC_PRINTK_SIZE 6\r\n#endif\r\n#ifndef MEM_RSRC_PRINTK_SIZE\r\n#define MEM_RSRC_PRINTK_SIZE 10\r\n#endif\r\nstatic const struct printf_spec io_spec = {\r\n.base = 16,\r\n.field_width = IO_RSRC_PRINTK_SIZE,\r\n.precision = -1,\r\n.flags = SPECIAL | SMALL | ZEROPAD,\r\n};\r\nstatic const struct printf_spec mem_spec = {\r\n.base = 16,\r\n.field_width = MEM_RSRC_PRINTK_SIZE,\r\n.precision = -1,\r\n.flags = SPECIAL | SMALL | ZEROPAD,\r\n};\r\nstatic const struct printf_spec bus_spec = {\r\n.base = 16,\r\n.field_width = 2,\r\n.precision = -1,\r\n.flags = SMALL | ZEROPAD,\r\n};\r\nstatic const struct printf_spec dec_spec = {\r\n.base = 10,\r\n.precision = -1,\r\n.flags = 0,\r\n};\r\nstatic const struct printf_spec str_spec = {\r\n.field_width = -1,\r\n.precision = 10,\r\n.flags = LEFT,\r\n};\r\nstatic const struct printf_spec flag_spec = {\r\n.base = 16,\r\n.precision = -1,\r\n.flags = SPECIAL | SMALL,\r\n};\r\n#define RSRC_BUF_SIZE ((2 * sizeof(resource_size_t)) + 4)\r\n#define FLAG_BUF_SIZE (2 * sizeof(res->flags))\r\n#define DECODED_BUF_SIZE sizeof("[mem - 64bit pref window disabled]")\r\n#define RAW_BUF_SIZE sizeof("[mem - flags 0x]")\r\nchar sym[max(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\r\n2*RSRC_BUF_SIZE + FLAG_BUF_SIZE + RAW_BUF_SIZE)];\r\nchar *p = sym, *pend = sym + sizeof(sym);\r\nint decode = (fmt[0] == 'R') ? 1 : 0;\r\nconst struct printf_spec *specp;\r\n*p++ = '[';\r\nif (res->flags & IORESOURCE_IO) {\r\np = string(p, pend, "io ", str_spec);\r\nspecp = &io_spec;\r\n} else if (res->flags & IORESOURCE_MEM) {\r\np = string(p, pend, "mem ", str_spec);\r\nspecp = &mem_spec;\r\n} else if (res->flags & IORESOURCE_IRQ) {\r\np = string(p, pend, "irq ", str_spec);\r\nspecp = &dec_spec;\r\n} else if (res->flags & IORESOURCE_DMA) {\r\np = string(p, pend, "dma ", str_spec);\r\nspecp = &dec_spec;\r\n} else if (res->flags & IORESOURCE_BUS) {\r\np = string(p, pend, "bus ", str_spec);\r\nspecp = &bus_spec;\r\n} else {\r\np = string(p, pend, "??? ", str_spec);\r\nspecp = &mem_spec;\r\ndecode = 0;\r\n}\r\nif (decode && res->flags & IORESOURCE_UNSET) {\r\np = string(p, pend, "size ", str_spec);\r\np = number(p, pend, resource_size(res), *specp);\r\n} else {\r\np = number(p, pend, res->start, *specp);\r\nif (res->start != res->end) {\r\n*p++ = '-';\r\np = number(p, pend, res->end, *specp);\r\n}\r\n}\r\nif (decode) {\r\nif (res->flags & IORESOURCE_MEM_64)\r\np = string(p, pend, " 64bit", str_spec);\r\nif (res->flags & IORESOURCE_PREFETCH)\r\np = string(p, pend, " pref", str_spec);\r\nif (res->flags & IORESOURCE_WINDOW)\r\np = string(p, pend, " window", str_spec);\r\nif (res->flags & IORESOURCE_DISABLED)\r\np = string(p, pend, " disabled", str_spec);\r\n} else {\r\np = string(p, pend, " flags ", str_spec);\r\np = number(p, pend, res->flags, flag_spec);\r\n}\r\n*p++ = ']';\r\n*p = '\0';\r\nreturn string(buf, end, sym, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *hex_string(char *buf, char *end, u8 *addr, struct printf_spec spec,\r\nconst char *fmt)\r\n{\r\nint i, len = 1;\r\nchar separator;\r\nif (spec.field_width == 0)\r\nreturn buf;\r\nif (ZERO_OR_NULL_PTR(addr))\r\nreturn string(buf, end, NULL, spec);\r\nswitch (fmt[1]) {\r\ncase 'C':\r\nseparator = ':';\r\nbreak;\r\ncase 'D':\r\nseparator = '-';\r\nbreak;\r\ncase 'N':\r\nseparator = 0;\r\nbreak;\r\ndefault:\r\nseparator = ' ';\r\nbreak;\r\n}\r\nif (spec.field_width > 0)\r\nlen = min_t(int, spec.field_width, 64);\r\nfor (i = 0; i < len && buf < end - 1; i++) {\r\nbuf = hex_byte_pack(buf, addr[i]);\r\nif (buf < end && separator && i != len - 1)\r\n*buf++ = separator;\r\n}\r\nreturn buf;\r\n}\r\nstatic noinline_for_stack\r\nchar *mac_address_string(char *buf, char *end, u8 *addr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nchar mac_addr[sizeof("xx:xx:xx:xx:xx:xx")];\r\nchar *p = mac_addr;\r\nint i;\r\nchar separator;\r\nbool reversed = false;\r\nswitch (fmt[1]) {\r\ncase 'F':\r\nseparator = '-';\r\nbreak;\r\ncase 'R':\r\nreversed = true;\r\ndefault:\r\nseparator = ':';\r\nbreak;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (reversed)\r\np = hex_byte_pack(p, addr[5 - i]);\r\nelse\r\np = hex_byte_pack(p, addr[i]);\r\nif (fmt[0] == 'M' && i != 5)\r\n*p++ = separator;\r\n}\r\n*p = '\0';\r\nreturn string(buf, end, mac_addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *ip4_string(char *p, const u8 *addr, const char *fmt)\r\n{\r\nint i;\r\nbool leading_zeros = (fmt[0] == 'i');\r\nint index;\r\nint step;\r\nswitch (fmt[2]) {\r\ncase 'h':\r\n#ifdef __BIG_ENDIAN\r\nindex = 0;\r\nstep = 1;\r\n#else\r\nindex = 3;\r\nstep = -1;\r\n#endif\r\nbreak;\r\ncase 'l':\r\nindex = 3;\r\nstep = -1;\r\nbreak;\r\ncase 'n':\r\ncase 'b':\r\ndefault:\r\nindex = 0;\r\nstep = 1;\r\nbreak;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nchar temp[3];\r\nint digits = put_dec_trunc8(temp, addr[index]) - temp;\r\nif (leading_zeros) {\r\nif (digits < 3)\r\n*p++ = '0';\r\nif (digits < 2)\r\n*p++ = '0';\r\n}\r\nwhile (digits--)\r\n*p++ = temp[digits];\r\nif (i < 3)\r\n*p++ = '.';\r\nindex += step;\r\n}\r\n*p = '\0';\r\nreturn p;\r\n}\r\nstatic noinline_for_stack\r\nchar *ip6_compressed_string(char *p, const char *addr)\r\n{\r\nint i, j, range;\r\nunsigned char zerolength[8];\r\nint longest = 1;\r\nint colonpos = -1;\r\nu16 word;\r\nu8 hi, lo;\r\nbool needcolon = false;\r\nbool useIPv4;\r\nstruct in6_addr in6;\r\nmemcpy(&in6, addr, sizeof(struct in6_addr));\r\nuseIPv4 = ipv6_addr_v4mapped(&in6) || ipv6_addr_is_isatap(&in6);\r\nmemset(zerolength, 0, sizeof(zerolength));\r\nif (useIPv4)\r\nrange = 6;\r\nelse\r\nrange = 8;\r\nfor (i = 0; i < range; i++) {\r\nfor (j = i; j < range; j++) {\r\nif (in6.s6_addr16[j] != 0)\r\nbreak;\r\nzerolength[i]++;\r\n}\r\n}\r\nfor (i = 0; i < range; i++) {\r\nif (zerolength[i] > longest) {\r\nlongest = zerolength[i];\r\ncolonpos = i;\r\n}\r\n}\r\nif (longest == 1)\r\ncolonpos = -1;\r\nfor (i = 0; i < range; i++) {\r\nif (i == colonpos) {\r\nif (needcolon || i == 0)\r\n*p++ = ':';\r\n*p++ = ':';\r\nneedcolon = false;\r\ni += longest - 1;\r\ncontinue;\r\n}\r\nif (needcolon) {\r\n*p++ = ':';\r\nneedcolon = false;\r\n}\r\nword = ntohs(in6.s6_addr16[i]);\r\nhi = word >> 8;\r\nlo = word & 0xff;\r\nif (hi) {\r\nif (hi > 0x0f)\r\np = hex_byte_pack(p, hi);\r\nelse\r\n*p++ = hex_asc_lo(hi);\r\np = hex_byte_pack(p, lo);\r\n}\r\nelse if (lo > 0x0f)\r\np = hex_byte_pack(p, lo);\r\nelse\r\n*p++ = hex_asc_lo(lo);\r\nneedcolon = true;\r\n}\r\nif (useIPv4) {\r\nif (needcolon)\r\n*p++ = ':';\r\np = ip4_string(p, &in6.s6_addr[12], "I4");\r\n}\r\n*p = '\0';\r\nreturn p;\r\n}\r\nstatic noinline_for_stack\r\nchar *ip6_string(char *p, const char *addr, const char *fmt)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\np = hex_byte_pack(p, *addr++);\r\np = hex_byte_pack(p, *addr++);\r\nif (fmt[0] == 'I' && i != 7)\r\n*p++ = ':';\r\n}\r\n*p = '\0';\r\nreturn p;\r\n}\r\nstatic noinline_for_stack\r\nchar *ip6_addr_string(char *buf, char *end, const u8 *addr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nchar ip6_addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")];\r\nif (fmt[0] == 'I' && fmt[2] == 'c')\r\nip6_compressed_string(ip6_addr, addr);\r\nelse\r\nip6_string(ip6_addr, addr, fmt);\r\nreturn string(buf, end, ip6_addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *ip4_addr_string(char *buf, char *end, const u8 *addr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nchar ip4_addr[sizeof("255.255.255.255")];\r\nip4_string(ip4_addr, addr, fmt);\r\nreturn string(buf, end, ip4_addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *ip6_addr_string_sa(char *buf, char *end, const struct sockaddr_in6 *sa,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nbool have_p = false, have_s = false, have_f = false, have_c = false;\r\nchar ip6_addr[sizeof("[xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255]") +\r\nsizeof(":12345") + sizeof("/123456789") +\r\nsizeof("%1234567890")];\r\nchar *p = ip6_addr, *pend = ip6_addr + sizeof(ip6_addr);\r\nconst u8 *addr = (const u8 *) &sa->sin6_addr;\r\nchar fmt6[2] = { fmt[0], '6' };\r\nu8 off = 0;\r\nfmt++;\r\nwhile (isalpha(*++fmt)) {\r\nswitch (*fmt) {\r\ncase 'p':\r\nhave_p = true;\r\nbreak;\r\ncase 'f':\r\nhave_f = true;\r\nbreak;\r\ncase 's':\r\nhave_s = true;\r\nbreak;\r\ncase 'c':\r\nhave_c = true;\r\nbreak;\r\n}\r\n}\r\nif (have_p || have_s || have_f) {\r\n*p = '[';\r\noff = 1;\r\n}\r\nif (fmt6[0] == 'I' && have_c)\r\np = ip6_compressed_string(ip6_addr + off, addr);\r\nelse\r\np = ip6_string(ip6_addr + off, addr, fmt6);\r\nif (have_p || have_s || have_f)\r\n*p++ = ']';\r\nif (have_p) {\r\n*p++ = ':';\r\np = number(p, pend, ntohs(sa->sin6_port), spec);\r\n}\r\nif (have_f) {\r\n*p++ = '/';\r\np = number(p, pend, ntohl(sa->sin6_flowinfo &\r\nIPV6_FLOWINFO_MASK), spec);\r\n}\r\nif (have_s) {\r\n*p++ = '%';\r\np = number(p, pend, sa->sin6_scope_id, spec);\r\n}\r\n*p = '\0';\r\nreturn string(buf, end, ip6_addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *ip4_addr_string_sa(char *buf, char *end, const struct sockaddr_in *sa,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nbool have_p = false;\r\nchar *p, ip4_addr[sizeof("255.255.255.255") + sizeof(":12345")];\r\nchar *pend = ip4_addr + sizeof(ip4_addr);\r\nconst u8 *addr = (const u8 *) &sa->sin_addr.s_addr;\r\nchar fmt4[3] = { fmt[0], '4', 0 };\r\nfmt++;\r\nwhile (isalpha(*++fmt)) {\r\nswitch (*fmt) {\r\ncase 'p':\r\nhave_p = true;\r\nbreak;\r\ncase 'h':\r\ncase 'l':\r\ncase 'n':\r\ncase 'b':\r\nfmt4[2] = *fmt;\r\nbreak;\r\n}\r\n}\r\np = ip4_string(ip4_addr, addr, fmt4);\r\nif (have_p) {\r\n*p++ = ':';\r\np = number(p, pend, ntohs(sa->sin_port), spec);\r\n}\r\n*p = '\0';\r\nreturn string(buf, end, ip4_addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *escaped_string(char *buf, char *end, u8 *addr, struct printf_spec spec,\r\nconst char *fmt)\r\n{\r\nbool found = true;\r\nint count = 1;\r\nunsigned int flags = 0;\r\nint len;\r\nif (spec.field_width == 0)\r\nreturn buf;\r\nif (ZERO_OR_NULL_PTR(addr))\r\nreturn string(buf, end, NULL, spec);\r\ndo {\r\nswitch (fmt[count++]) {\r\ncase 'a':\r\nflags |= ESCAPE_ANY;\r\nbreak;\r\ncase 'c':\r\nflags |= ESCAPE_SPECIAL;\r\nbreak;\r\ncase 'h':\r\nflags |= ESCAPE_HEX;\r\nbreak;\r\ncase 'n':\r\nflags |= ESCAPE_NULL;\r\nbreak;\r\ncase 'o':\r\nflags |= ESCAPE_OCTAL;\r\nbreak;\r\ncase 'p':\r\nflags |= ESCAPE_NP;\r\nbreak;\r\ncase 's':\r\nflags |= ESCAPE_SPACE;\r\nbreak;\r\ndefault:\r\nfound = false;\r\nbreak;\r\n}\r\n} while (found);\r\nif (!flags)\r\nflags = ESCAPE_ANY_NP;\r\nlen = spec.field_width < 0 ? 1 : spec.field_width;\r\nstring_escape_mem(addr, len, &buf, end - buf, flags, NULL);\r\nreturn buf;\r\n}\r\nstatic noinline_for_stack\r\nchar *uuid_string(char *buf, char *end, const u8 *addr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nchar uuid[sizeof("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")];\r\nchar *p = uuid;\r\nint i;\r\nstatic const u8 be[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\r\nstatic const u8 le[16] = {3,2,1,0,5,4,7,6,8,9,10,11,12,13,14,15};\r\nconst u8 *index = be;\r\nbool uc = false;\r\nswitch (*(++fmt)) {\r\ncase 'L':\r\nuc = true;\r\ncase 'l':\r\nindex = le;\r\nbreak;\r\ncase 'B':\r\nuc = true;\r\nbreak;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\np = hex_byte_pack(p, addr[index[i]]);\r\nswitch (i) {\r\ncase 3:\r\ncase 5:\r\ncase 7:\r\ncase 9:\r\n*p++ = '-';\r\nbreak;\r\n}\r\n}\r\n*p = 0;\r\nif (uc) {\r\np = uuid;\r\ndo {\r\n*p = toupper(*p);\r\n} while (*(++p));\r\n}\r\nreturn string(buf, end, uuid, spec);\r\n}\r\nstatic\r\nchar *netdev_feature_string(char *buf, char *end, const u8 *addr,\r\nstruct printf_spec spec)\r\n{\r\nspec.flags |= SPECIAL | SMALL | ZEROPAD;\r\nif (spec.field_width == -1)\r\nspec.field_width = 2 + 2 * sizeof(netdev_features_t);\r\nspec.base = 16;\r\nreturn number(buf, end, *(const netdev_features_t *)addr, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *address_val(char *buf, char *end, const void *addr,\r\nstruct printf_spec spec, const char *fmt)\r\n{\r\nunsigned long long num;\r\nspec.flags |= SPECIAL | SMALL | ZEROPAD;\r\nspec.base = 16;\r\nswitch (fmt[1]) {\r\ncase 'd':\r\nnum = *(const dma_addr_t *)addr;\r\nspec.field_width = sizeof(dma_addr_t) * 2 + 2;\r\nbreak;\r\ncase 'p':\r\ndefault:\r\nnum = *(const phys_addr_t *)addr;\r\nspec.field_width = sizeof(phys_addr_t) * 2 + 2;\r\nbreak;\r\n}\r\nreturn number(buf, end, num, spec);\r\n}\r\nstatic noinline_for_stack\r\nchar *pointer(const char *fmt, char *buf, char *end, void *ptr,\r\nstruct printf_spec spec)\r\n{\r\nint default_width = 2 * sizeof(void *) + (spec.flags & SPECIAL ? 2 : 0);\r\nif (!ptr && *fmt != 'K') {\r\nif (spec.field_width == -1)\r\nspec.field_width = default_width;\r\nreturn string(buf, end, "(null)", spec);\r\n}\r\nswitch (*fmt) {\r\ncase 'F':\r\ncase 'f':\r\nptr = dereference_function_descriptor(ptr);\r\ncase 'S':\r\ncase 's':\r\ncase 'B':\r\nreturn symbol_string(buf, end, ptr, spec, fmt);\r\ncase 'R':\r\ncase 'r':\r\nreturn resource_string(buf, end, ptr, spec, fmt);\r\ncase 'h':\r\nreturn hex_string(buf, end, ptr, spec, fmt);\r\ncase 'M':\r\ncase 'm':\r\nreturn mac_address_string(buf, end, ptr, spec, fmt);\r\ncase 'I':\r\ncase 'i':\r\nswitch (fmt[1]) {\r\ncase '6':\r\nreturn ip6_addr_string(buf, end, ptr, spec, fmt);\r\ncase '4':\r\nreturn ip4_addr_string(buf, end, ptr, spec, fmt);\r\ncase 'S': {\r\nconst union {\r\nstruct sockaddr raw;\r\nstruct sockaddr_in v4;\r\nstruct sockaddr_in6 v6;\r\n} *sa = ptr;\r\nswitch (sa->raw.sa_family) {\r\ncase AF_INET:\r\nreturn ip4_addr_string_sa(buf, end, &sa->v4, spec, fmt);\r\ncase AF_INET6:\r\nreturn ip6_addr_string_sa(buf, end, &sa->v6, spec, fmt);\r\ndefault:\r\nreturn string(buf, end, "(invalid address)", spec);\r\n}}\r\n}\r\nbreak;\r\ncase 'E':\r\nreturn escaped_string(buf, end, ptr, spec, fmt);\r\ncase 'U':\r\nreturn uuid_string(buf, end, ptr, spec, fmt);\r\ncase 'V':\r\n{\r\nva_list va;\r\nva_copy(va, *((struct va_format *)ptr)->va);\r\nbuf += vsnprintf(buf, end > buf ? end - buf : 0,\r\n((struct va_format *)ptr)->fmt, va);\r\nva_end(va);\r\nreturn buf;\r\n}\r\ncase 'K':\r\nif (kptr_restrict && (in_irq() || in_serving_softirq() ||\r\nin_nmi())) {\r\nif (spec.field_width == -1)\r\nspec.field_width = default_width;\r\nreturn string(buf, end, "pK-error", spec);\r\n}\r\nswitch (kptr_restrict) {\r\ncase 0:\r\nbreak;\r\ncase 1: {\r\nconst struct cred *cred = current_cred();\r\nif (!has_capability_noaudit(current, CAP_SYSLOG) ||\r\n!uid_eq(cred->euid, cred->uid) ||\r\n!gid_eq(cred->egid, cred->gid))\r\nptr = NULL;\r\nbreak;\r\n}\r\ncase 2:\r\ndefault:\r\nptr = NULL;\r\nbreak;\r\n}\r\nbreak;\r\ncase 'N':\r\nswitch (fmt[1]) {\r\ncase 'F':\r\nreturn netdev_feature_string(buf, end, ptr, spec);\r\n}\r\nbreak;\r\ncase 'a':\r\nreturn address_val(buf, end, ptr, spec, fmt);\r\ncase 'd':\r\nreturn dentry_name(buf, end, ptr, spec, fmt);\r\ncase 'D':\r\nreturn dentry_name(buf, end,\r\n((const struct file *)ptr)->f_path.dentry,\r\nspec, fmt);\r\n}\r\nspec.flags |= SMALL;\r\nif (spec.field_width == -1) {\r\nspec.field_width = default_width;\r\nspec.flags |= ZEROPAD;\r\n}\r\nspec.base = 16;\r\nreturn number(buf, end, (unsigned long) ptr, spec);\r\n}\r\nstatic noinline_for_stack\r\nint format_decode(const char *fmt, struct printf_spec *spec)\r\n{\r\nconst char *start = fmt;\r\nif (spec->type == FORMAT_TYPE_WIDTH) {\r\nif (spec->field_width < 0) {\r\nspec->field_width = -spec->field_width;\r\nspec->flags |= LEFT;\r\n}\r\nspec->type = FORMAT_TYPE_NONE;\r\ngoto precision;\r\n}\r\nif (spec->type == FORMAT_TYPE_PRECISION) {\r\nif (spec->precision < 0)\r\nspec->precision = 0;\r\nspec->type = FORMAT_TYPE_NONE;\r\ngoto qualifier;\r\n}\r\nspec->type = FORMAT_TYPE_NONE;\r\nfor (; *fmt ; ++fmt) {\r\nif (*fmt == '%')\r\nbreak;\r\n}\r\nif (fmt != start || !*fmt)\r\nreturn fmt - start;\r\nspec->flags = 0;\r\nwhile (1) {\r\nbool found = true;\r\n++fmt;\r\nswitch (*fmt) {\r\ncase '-': spec->flags |= LEFT; break;\r\ncase '+': spec->flags |= PLUS; break;\r\ncase ' ': spec->flags |= SPACE; break;\r\ncase '#': spec->flags |= SPECIAL; break;\r\ncase '0': spec->flags |= ZEROPAD; break;\r\ndefault: found = false;\r\n}\r\nif (!found)\r\nbreak;\r\n}\r\nspec->field_width = -1;\r\nif (isdigit(*fmt))\r\nspec->field_width = skip_atoi(&fmt);\r\nelse if (*fmt == '*') {\r\nspec->type = FORMAT_TYPE_WIDTH;\r\nreturn ++fmt - start;\r\n}\r\nprecision:\r\nspec->precision = -1;\r\nif (*fmt == '.') {\r\n++fmt;\r\nif (isdigit(*fmt)) {\r\nspec->precision = skip_atoi(&fmt);\r\nif (spec->precision < 0)\r\nspec->precision = 0;\r\n} else if (*fmt == '*') {\r\nspec->type = FORMAT_TYPE_PRECISION;\r\nreturn ++fmt - start;\r\n}\r\n}\r\nqualifier:\r\nspec->qualifier = -1;\r\nif (*fmt == 'h' || _tolower(*fmt) == 'l' ||\r\n_tolower(*fmt) == 'z' || *fmt == 't') {\r\nspec->qualifier = *fmt++;\r\nif (unlikely(spec->qualifier == *fmt)) {\r\nif (spec->qualifier == 'l') {\r\nspec->qualifier = 'L';\r\n++fmt;\r\n} else if (spec->qualifier == 'h') {\r\nspec->qualifier = 'H';\r\n++fmt;\r\n}\r\n}\r\n}\r\nspec->base = 10;\r\nswitch (*fmt) {\r\ncase 'c':\r\nspec->type = FORMAT_TYPE_CHAR;\r\nreturn ++fmt - start;\r\ncase 's':\r\nspec->type = FORMAT_TYPE_STR;\r\nreturn ++fmt - start;\r\ncase 'p':\r\nspec->type = FORMAT_TYPE_PTR;\r\nreturn fmt - start;\r\ncase '%':\r\nspec->type = FORMAT_TYPE_PERCENT_CHAR;\r\nreturn ++fmt - start;\r\ncase 'o':\r\nspec->base = 8;\r\nbreak;\r\ncase 'x':\r\nspec->flags |= SMALL;\r\ncase 'X':\r\nspec->base = 16;\r\nbreak;\r\ncase 'd':\r\ncase 'i':\r\nspec->flags |= SIGN;\r\ncase 'u':\r\nbreak;\r\ncase 'n':\r\nWARN_ONCE(1, "Please remove ignored %%n in '%s'\n", fmt);\r\ndefault:\r\nspec->type = FORMAT_TYPE_INVALID;\r\nreturn fmt - start;\r\n}\r\nif (spec->qualifier == 'L')\r\nspec->type = FORMAT_TYPE_LONG_LONG;\r\nelse if (spec->qualifier == 'l') {\r\nif (spec->flags & SIGN)\r\nspec->type = FORMAT_TYPE_LONG;\r\nelse\r\nspec->type = FORMAT_TYPE_ULONG;\r\n} else if (_tolower(spec->qualifier) == 'z') {\r\nspec->type = FORMAT_TYPE_SIZE_T;\r\n} else if (spec->qualifier == 't') {\r\nspec->type = FORMAT_TYPE_PTRDIFF;\r\n} else if (spec->qualifier == 'H') {\r\nif (spec->flags & SIGN)\r\nspec->type = FORMAT_TYPE_BYTE;\r\nelse\r\nspec->type = FORMAT_TYPE_UBYTE;\r\n} else if (spec->qualifier == 'h') {\r\nif (spec->flags & SIGN)\r\nspec->type = FORMAT_TYPE_SHORT;\r\nelse\r\nspec->type = FORMAT_TYPE_USHORT;\r\n} else {\r\nif (spec->flags & SIGN)\r\nspec->type = FORMAT_TYPE_INT;\r\nelse\r\nspec->type = FORMAT_TYPE_UINT;\r\n}\r\nreturn ++fmt - start;\r\n}\r\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args)\r\n{\r\nunsigned long long num;\r\nchar *str, *end;\r\nstruct printf_spec spec = {0};\r\nif (WARN_ON_ONCE((int) size < 0))\r\nreturn 0;\r\nstr = buf;\r\nend = buf + size;\r\nif (end < buf) {\r\nend = ((void *)-1);\r\nsize = end - buf;\r\n}\r\nwhile (*fmt) {\r\nconst char *old_fmt = fmt;\r\nint read = format_decode(fmt, &spec);\r\nfmt += read;\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_NONE: {\r\nint copy = read;\r\nif (str < end) {\r\nif (copy > end - str)\r\ncopy = end - str;\r\nmemcpy(str, old_fmt, copy);\r\n}\r\nstr += read;\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_WIDTH:\r\nspec.field_width = va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_PRECISION:\r\nspec.precision = va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_CHAR: {\r\nchar c;\r\nif (!(spec.flags & LEFT)) {\r\nwhile (--spec.field_width > 0) {\r\nif (str < end)\r\n*str = ' ';\r\n++str;\r\n}\r\n}\r\nc = (unsigned char) va_arg(args, int);\r\nif (str < end)\r\n*str = c;\r\n++str;\r\nwhile (--spec.field_width > 0) {\r\nif (str < end)\r\n*str = ' ';\r\n++str;\r\n}\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_STR:\r\nstr = string(str, end, va_arg(args, char *), spec);\r\nbreak;\r\ncase FORMAT_TYPE_PTR:\r\nstr = pointer(fmt+1, str, end, va_arg(args, void *),\r\nspec);\r\nwhile (isalnum(*fmt))\r\nfmt++;\r\nbreak;\r\ncase FORMAT_TYPE_PERCENT_CHAR:\r\nif (str < end)\r\n*str = '%';\r\n++str;\r\nbreak;\r\ncase FORMAT_TYPE_INVALID:\r\nif (str < end)\r\n*str = '%';\r\n++str;\r\nbreak;\r\ndefault:\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_LONG_LONG:\r\nnum = va_arg(args, long long);\r\nbreak;\r\ncase FORMAT_TYPE_ULONG:\r\nnum = va_arg(args, unsigned long);\r\nbreak;\r\ncase FORMAT_TYPE_LONG:\r\nnum = va_arg(args, long);\r\nbreak;\r\ncase FORMAT_TYPE_SIZE_T:\r\nif (spec.flags & SIGN)\r\nnum = va_arg(args, ssize_t);\r\nelse\r\nnum = va_arg(args, size_t);\r\nbreak;\r\ncase FORMAT_TYPE_PTRDIFF:\r\nnum = va_arg(args, ptrdiff_t);\r\nbreak;\r\ncase FORMAT_TYPE_UBYTE:\r\nnum = (unsigned char) va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_BYTE:\r\nnum = (signed char) va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_USHORT:\r\nnum = (unsigned short) va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_SHORT:\r\nnum = (short) va_arg(args, int);\r\nbreak;\r\ncase FORMAT_TYPE_INT:\r\nnum = (int) va_arg(args, int);\r\nbreak;\r\ndefault:\r\nnum = va_arg(args, unsigned int);\r\n}\r\nstr = number(str, end, num, spec);\r\n}\r\n}\r\nif (size > 0) {\r\nif (str < end)\r\n*str = '\0';\r\nelse\r\nend[-1] = '\0';\r\n}\r\nreturn str-buf;\r\n}\r\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args)\r\n{\r\nint i;\r\ni = vsnprintf(buf, size, fmt, args);\r\nif (likely(i < size))\r\nreturn i;\r\nif (size != 0)\r\nreturn size - 1;\r\nreturn 0;\r\n}\r\nint snprintf(char *buf, size_t size, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args, fmt);\r\ni = vsnprintf(buf, size, fmt, args);\r\nva_end(args);\r\nreturn i;\r\n}\r\nint scnprintf(char *buf, size_t size, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args, fmt);\r\ni = vscnprintf(buf, size, fmt, args);\r\nva_end(args);\r\nreturn i;\r\n}\r\nint vsprintf(char *buf, const char *fmt, va_list args)\r\n{\r\nreturn vsnprintf(buf, INT_MAX, fmt, args);\r\n}\r\nint sprintf(char *buf, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args, fmt);\r\ni = vsnprintf(buf, INT_MAX, fmt, args);\r\nva_end(args);\r\nreturn i;\r\n}\r\nint vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args)\r\n{\r\nstruct printf_spec spec = {0};\r\nchar *str, *end;\r\nstr = (char *)bin_buf;\r\nend = (char *)(bin_buf + size);\r\n#define save_arg(type) \\r\ndo { \\r\nif (sizeof(type) == 8) { \\r\nunsigned long long value; \\r\nstr = PTR_ALIGN(str, sizeof(u32)); \\r\nvalue = va_arg(args, unsigned long long); \\r\nif (str + sizeof(type) <= end) { \\r\n*(u32 *)str = *(u32 *)&value; \\r\n*(u32 *)(str + 4) = *((u32 *)&value + 1); \\r\n} \\r\n} else { \\r\nunsigned long value; \\r\nstr = PTR_ALIGN(str, sizeof(type)); \\r\nvalue = va_arg(args, int); \\r\nif (str + sizeof(type) <= end) \\r\n*(typeof(type) *)str = (type)value; \\r\n} \\r\nstr += sizeof(type); \\r\n} while (0)\r\nwhile (*fmt) {\r\nint read = format_decode(fmt, &spec);\r\nfmt += read;\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_NONE:\r\ncase FORMAT_TYPE_INVALID:\r\ncase FORMAT_TYPE_PERCENT_CHAR:\r\nbreak;\r\ncase FORMAT_TYPE_WIDTH:\r\ncase FORMAT_TYPE_PRECISION:\r\nsave_arg(int);\r\nbreak;\r\ncase FORMAT_TYPE_CHAR:\r\nsave_arg(char);\r\nbreak;\r\ncase FORMAT_TYPE_STR: {\r\nconst char *save_str = va_arg(args, char *);\r\nsize_t len;\r\nif ((unsigned long)save_str > (unsigned long)-PAGE_SIZE\r\n|| (unsigned long)save_str < PAGE_SIZE)\r\nsave_str = "(null)";\r\nlen = strlen(save_str) + 1;\r\nif (str + len < end)\r\nmemcpy(str, save_str, len);\r\nstr += len;\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_PTR:\r\nsave_arg(void *);\r\nwhile (isalnum(*fmt))\r\nfmt++;\r\nbreak;\r\ndefault:\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_LONG_LONG:\r\nsave_arg(long long);\r\nbreak;\r\ncase FORMAT_TYPE_ULONG:\r\ncase FORMAT_TYPE_LONG:\r\nsave_arg(unsigned long);\r\nbreak;\r\ncase FORMAT_TYPE_SIZE_T:\r\nsave_arg(size_t);\r\nbreak;\r\ncase FORMAT_TYPE_PTRDIFF:\r\nsave_arg(ptrdiff_t);\r\nbreak;\r\ncase FORMAT_TYPE_UBYTE:\r\ncase FORMAT_TYPE_BYTE:\r\nsave_arg(char);\r\nbreak;\r\ncase FORMAT_TYPE_USHORT:\r\ncase FORMAT_TYPE_SHORT:\r\nsave_arg(short);\r\nbreak;\r\ndefault:\r\nsave_arg(int);\r\n}\r\n}\r\n}\r\nreturn (u32 *)(PTR_ALIGN(str, sizeof(u32))) - bin_buf;\r\n#undef save_arg\r\n}\r\nint bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf)\r\n{\r\nstruct printf_spec spec = {0};\r\nchar *str, *end;\r\nconst char *args = (const char *)bin_buf;\r\nif (WARN_ON_ONCE((int) size < 0))\r\nreturn 0;\r\nstr = buf;\r\nend = buf + size;\r\n#define get_arg(type) \\r\n({ \\r\ntypeof(type) value; \\r\nif (sizeof(type) == 8) { \\r\nargs = PTR_ALIGN(args, sizeof(u32)); \\r\n*(u32 *)&value = *(u32 *)args; \\r\n*((u32 *)&value + 1) = *(u32 *)(args + 4); \\r\n} else { \\r\nargs = PTR_ALIGN(args, sizeof(type)); \\r\nvalue = *(typeof(type) *)args; \\r\n} \\r\nargs += sizeof(type); \\r\nvalue; \\r\n})\r\nif (end < buf) {\r\nend = ((void *)-1);\r\nsize = end - buf;\r\n}\r\nwhile (*fmt) {\r\nconst char *old_fmt = fmt;\r\nint read = format_decode(fmt, &spec);\r\nfmt += read;\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_NONE: {\r\nint copy = read;\r\nif (str < end) {\r\nif (copy > end - str)\r\ncopy = end - str;\r\nmemcpy(str, old_fmt, copy);\r\n}\r\nstr += read;\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_WIDTH:\r\nspec.field_width = get_arg(int);\r\nbreak;\r\ncase FORMAT_TYPE_PRECISION:\r\nspec.precision = get_arg(int);\r\nbreak;\r\ncase FORMAT_TYPE_CHAR: {\r\nchar c;\r\nif (!(spec.flags & LEFT)) {\r\nwhile (--spec.field_width > 0) {\r\nif (str < end)\r\n*str = ' ';\r\n++str;\r\n}\r\n}\r\nc = (unsigned char) get_arg(char);\r\nif (str < end)\r\n*str = c;\r\n++str;\r\nwhile (--spec.field_width > 0) {\r\nif (str < end)\r\n*str = ' ';\r\n++str;\r\n}\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_STR: {\r\nconst char *str_arg = args;\r\nargs += strlen(str_arg) + 1;\r\nstr = string(str, end, (char *)str_arg, spec);\r\nbreak;\r\n}\r\ncase FORMAT_TYPE_PTR:\r\nstr = pointer(fmt+1, str, end, get_arg(void *), spec);\r\nwhile (isalnum(*fmt))\r\nfmt++;\r\nbreak;\r\ncase FORMAT_TYPE_PERCENT_CHAR:\r\ncase FORMAT_TYPE_INVALID:\r\nif (str < end)\r\n*str = '%';\r\n++str;\r\nbreak;\r\ndefault: {\r\nunsigned long long num;\r\nswitch (spec.type) {\r\ncase FORMAT_TYPE_LONG_LONG:\r\nnum = get_arg(long long);\r\nbreak;\r\ncase FORMAT_TYPE_ULONG:\r\ncase FORMAT_TYPE_LONG:\r\nnum = get_arg(unsigned long);\r\nbreak;\r\ncase FORMAT_TYPE_SIZE_T:\r\nnum = get_arg(size_t);\r\nbreak;\r\ncase FORMAT_TYPE_PTRDIFF:\r\nnum = get_arg(ptrdiff_t);\r\nbreak;\r\ncase FORMAT_TYPE_UBYTE:\r\nnum = get_arg(unsigned char);\r\nbreak;\r\ncase FORMAT_TYPE_BYTE:\r\nnum = get_arg(signed char);\r\nbreak;\r\ncase FORMAT_TYPE_USHORT:\r\nnum = get_arg(unsigned short);\r\nbreak;\r\ncase FORMAT_TYPE_SHORT:\r\nnum = get_arg(short);\r\nbreak;\r\ncase FORMAT_TYPE_UINT:\r\nnum = get_arg(unsigned int);\r\nbreak;\r\ndefault:\r\nnum = get_arg(int);\r\n}\r\nstr = number(str, end, num, spec);\r\n}\r\n}\r\n}\r\nif (size > 0) {\r\nif (str < end)\r\n*str = '\0';\r\nelse\r\nend[-1] = '\0';\r\n}\r\n#undef get_arg\r\nreturn str - buf;\r\n}\r\nint bprintf(u32 *bin_buf, size_t size, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint ret;\r\nva_start(args, fmt);\r\nret = vbin_printf(bin_buf, size, fmt, args);\r\nva_end(args);\r\nreturn ret;\r\n}\r\nint vsscanf(const char *buf, const char *fmt, va_list args)\r\n{\r\nconst char *str = buf;\r\nchar *next;\r\nchar digit;\r\nint num = 0;\r\nu8 qualifier;\r\nunsigned int base;\r\nunion {\r\nlong long s;\r\nunsigned long long u;\r\n} val;\r\ns16 field_width;\r\nbool is_sign;\r\nwhile (*fmt) {\r\nif (isspace(*fmt)) {\r\nfmt = skip_spaces(++fmt);\r\nstr = skip_spaces(str);\r\n}\r\nif (*fmt != '%' && *fmt) {\r\nif (*fmt++ != *str++)\r\nbreak;\r\ncontinue;\r\n}\r\nif (!*fmt)\r\nbreak;\r\n++fmt;\r\nif (*fmt == '*') {\r\nif (!*str)\r\nbreak;\r\nwhile (!isspace(*fmt) && *fmt != '%' && *fmt)\r\nfmt++;\r\nwhile (!isspace(*str) && *str)\r\nstr++;\r\ncontinue;\r\n}\r\nfield_width = -1;\r\nif (isdigit(*fmt)) {\r\nfield_width = skip_atoi(&fmt);\r\nif (field_width <= 0)\r\nbreak;\r\n}\r\nqualifier = -1;\r\nif (*fmt == 'h' || _tolower(*fmt) == 'l' ||\r\n_tolower(*fmt) == 'z') {\r\nqualifier = *fmt++;\r\nif (unlikely(qualifier == *fmt)) {\r\nif (qualifier == 'h') {\r\nqualifier = 'H';\r\nfmt++;\r\n} else if (qualifier == 'l') {\r\nqualifier = 'L';\r\nfmt++;\r\n}\r\n}\r\n}\r\nif (!*fmt)\r\nbreak;\r\nif (*fmt == 'n') {\r\n*va_arg(args, int *) = str - buf;\r\n++fmt;\r\ncontinue;\r\n}\r\nif (!*str)\r\nbreak;\r\nbase = 10;\r\nis_sign = false;\r\nswitch (*fmt++) {\r\ncase 'c':\r\n{\r\nchar *s = (char *)va_arg(args, char*);\r\nif (field_width == -1)\r\nfield_width = 1;\r\ndo {\r\n*s++ = *str++;\r\n} while (--field_width > 0 && *str);\r\nnum++;\r\n}\r\ncontinue;\r\ncase 's':\r\n{\r\nchar *s = (char *)va_arg(args, char *);\r\nif (field_width == -1)\r\nfield_width = SHRT_MAX;\r\nstr = skip_spaces(str);\r\nwhile (*str && !isspace(*str) && field_width--)\r\n*s++ = *str++;\r\n*s = '\0';\r\nnum++;\r\n}\r\ncontinue;\r\ncase 'o':\r\nbase = 8;\r\nbreak;\r\ncase 'x':\r\ncase 'X':\r\nbase = 16;\r\nbreak;\r\ncase 'i':\r\nbase = 0;\r\ncase 'd':\r\nis_sign = true;\r\ncase 'u':\r\nbreak;\r\ncase '%':\r\nif (*str++ != '%')\r\nreturn num;\r\ncontinue;\r\ndefault:\r\nreturn num;\r\n}\r\nstr = skip_spaces(str);\r\ndigit = *str;\r\nif (is_sign && digit == '-')\r\ndigit = *(str + 1);\r\nif (!digit\r\n|| (base == 16 && !isxdigit(digit))\r\n|| (base == 10 && !isdigit(digit))\r\n|| (base == 8 && (!isdigit(digit) || digit > '7'))\r\n|| (base == 0 && !isdigit(digit)))\r\nbreak;\r\nif (is_sign)\r\nval.s = qualifier != 'L' ?\r\nsimple_strtol(str, &next, base) :\r\nsimple_strtoll(str, &next, base);\r\nelse\r\nval.u = qualifier != 'L' ?\r\nsimple_strtoul(str, &next, base) :\r\nsimple_strtoull(str, &next, base);\r\nif (field_width > 0 && next - str > field_width) {\r\nif (base == 0)\r\n_parse_integer_fixup_radix(str, &base);\r\nwhile (next - str > field_width) {\r\nif (is_sign)\r\nval.s = div_s64(val.s, base);\r\nelse\r\nval.u = div_u64(val.u, base);\r\n--next;\r\n}\r\n}\r\nswitch (qualifier) {\r\ncase 'H':\r\nif (is_sign)\r\n*va_arg(args, signed char *) = val.s;\r\nelse\r\n*va_arg(args, unsigned char *) = val.u;\r\nbreak;\r\ncase 'h':\r\nif (is_sign)\r\n*va_arg(args, short *) = val.s;\r\nelse\r\n*va_arg(args, unsigned short *) = val.u;\r\nbreak;\r\ncase 'l':\r\nif (is_sign)\r\n*va_arg(args, long *) = val.s;\r\nelse\r\n*va_arg(args, unsigned long *) = val.u;\r\nbreak;\r\ncase 'L':\r\nif (is_sign)\r\n*va_arg(args, long long *) = val.s;\r\nelse\r\n*va_arg(args, unsigned long long *) = val.u;\r\nbreak;\r\ncase 'Z':\r\ncase 'z':\r\n*va_arg(args, size_t *) = val.u;\r\nbreak;\r\ndefault:\r\nif (is_sign)\r\n*va_arg(args, int *) = val.s;\r\nelse\r\n*va_arg(args, unsigned int *) = val.u;\r\nbreak;\r\n}\r\nnum++;\r\nif (!next)\r\nbreak;\r\nstr = next;\r\n}\r\nreturn num;\r\n}\r\nint sscanf(const char *buf, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args, fmt);\r\ni = vsscanf(buf, fmt, args);\r\nva_end(args);\r\nreturn i;\r\n}
