static void mb862xxfb_write_fifo(u32 count, u32 *data, struct fb_info *info)\r\n{\r\nstruct mb862xxfb_par *par = info->par;\r\nstatic u32 free;\r\nu32 total = 0;\r\nwhile (total < count) {\r\nif (free) {\r\noutreg(geo, GDC_GEO_REG_INPUT_FIFO, data[total]);\r\ntotal++;\r\nfree--;\r\n} else {\r\nfree = (u32) inreg(draw, GDC_REG_FIFO_COUNT);\r\n}\r\n}\r\n}\r\nstatic void mb86290fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\n__u32 cmd[6];\r\ncmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\r\ncmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\r\ncmd[2] = GDC_TYPE_BLTCOPYP << 24;\r\nif (area->sx >= area->dx && area->sy >= area->dy)\r\ncmd[2] |= GDC_CMD_BLTCOPY_TOP_LEFT << 16;\r\nelse if (area->sx >= area->dx && area->sy <= area->dy)\r\ncmd[2] |= GDC_CMD_BLTCOPY_BOTTOM_LEFT << 16;\r\nelse if (area->sx <= area->dx && area->sy >= area->dy)\r\ncmd[2] |= GDC_CMD_BLTCOPY_TOP_RIGHT << 16;\r\nelse\r\ncmd[2] |= GDC_CMD_BLTCOPY_BOTTOM_RIGHT << 16;\r\ncmd[3] = (area->sy << 16) | area->sx;\r\ncmd[4] = (area->dy << 16) | area->dx;\r\ncmd[5] = (area->height << 16) | area->width;\r\nmb862xxfb_write_fifo(6, cmd, info);\r\n}\r\nstatic void mb86290fb_imageblit1(u32 *cmd, u16 step, u16 dx, u16 dy,\r\nu16 width, u16 height, u32 fgcolor,\r\nu32 bgcolor, const struct fb_image *image,\r\nstruct fb_info *info)\r\n{\r\nint i;\r\nunsigned const char *line;\r\nu16 bytes;\r\ncmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\r\ncmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\r\ncmd[2] =\r\n(GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_FORE_COLOR << 16);\r\ncmd[3] = fgcolor;\r\ncmd[4] =\r\n(GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_BACK_COLOR << 16);\r\ncmd[5] = bgcolor;\r\ni = 0;\r\nline = image->data;\r\nbytes = (image->width + 7) >> 3;\r\ncmd[6] = (GDC_TYPE_DRAWBITMAPP << 24) |\r\n(GDC_CMD_BITMAP << 16) | (2 + (step * height));\r\ncmd[7] = (dy << 16) | dx;\r\ncmd[8] = (height << 16) | width;\r\nwhile (i < height) {\r\nmemcpy(&cmd[9 + i * step], line, step << 2);\r\n#ifdef __LITTLE_ENDIAN\r\n{\r\nint k = 0;\r\nfor (k = 0; k < step; k++)\r\ncmd[9 + i * step + k] =\r\ncpu_to_be32(cmd[9 + i * step + k]);\r\n}\r\n#endif\r\nline += bytes;\r\ni++;\r\n}\r\n}\r\nstatic void mb86290fb_imageblit8(u32 *cmd, u16 step, u16 dx, u16 dy,\r\nu16 width, u16 height, u32 fgcolor,\r\nu32 bgcolor, const struct fb_image *image,\r\nstruct fb_info *info)\r\n{\r\nint i, j;\r\nunsigned const char *line, *ptr;\r\nu16 bytes;\r\ncmd[0] = (GDC_TYPE_DRAWBITMAPP << 24) |\r\n(GDC_CMD_BLT_DRAW << 16) | (2 + (height * step));\r\ncmd[1] = (dy << 16) | dx;\r\ncmd[2] = (height << 16) | width;\r\ni = 0;\r\nline = ptr = image->data;\r\nbytes = image->width;\r\nwhile (i < height) {\r\nptr = line;\r\nfor (j = 0; j < step; j++) {\r\ncmd[3 + i * step + j] =\r\n(((u32 *) (info->pseudo_palette))[*ptr]) & 0xffff;\r\nptr++;\r\ncmd[3 + i * step + j] |=\r\n((((u32 *) (info->\r\npseudo_palette))[*ptr]) & 0xffff) << 16;\r\nptr++;\r\n}\r\nline += bytes;\r\ni++;\r\n}\r\n}\r\nstatic void mb86290fb_imageblit16(u32 *cmd, u16 step, u16 dx, u16 dy,\r\nu16 width, u16 height, u32 fgcolor,\r\nu32 bgcolor, const struct fb_image *image,\r\nstruct fb_info *info)\r\n{\r\nint i;\r\nunsigned const char *line;\r\nu16 bytes;\r\ni = 0;\r\nline = image->data;\r\nbytes = image->width << 1;\r\ncmd[0] = (GDC_TYPE_DRAWBITMAPP << 24) |\r\n(GDC_CMD_BLT_DRAW << 16) | (2 + step * height);\r\ncmd[1] = (dy << 16) | dx;\r\ncmd[2] = (height << 16) | width;\r\nwhile (i < height) {\r\nmemcpy(&cmd[3 + i * step], line, step);\r\nline += bytes;\r\ni++;\r\n}\r\n}\r\nstatic void mb86290fb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nint mdr;\r\nu32 *cmd = NULL;\r\nvoid (*cmdfn) (u32 *, u16, u16, u16, u16, u16, u32, u32,\r\nconst struct fb_image *, struct fb_info *) = NULL;\r\nu32 cmdlen;\r\nu32 fgcolor = 0, bgcolor = 0;\r\nu16 step;\r\nu16 width = image->width, height = image->height;\r\nu16 dx = image->dx, dy = image->dy;\r\nint x2, y2, vxres, vyres;\r\nmdr = (GDC_ROP_COPY << 9);\r\nx2 = image->dx + image->width;\r\ny2 = image->dy + image->height;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nx2 = min(x2, vxres);\r\ny2 = min(y2, vyres);\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nswitch (image->depth) {\r\ncase 1:\r\nstep = (width + 31) >> 5;\r\ncmdlen = 9 + height * step;\r\ncmdfn = mb86290fb_imageblit1;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nfgcolor =\r\n((u32 *) (info->pseudo_palette))[image->fg_color];\r\nbgcolor =\r\n((u32 *) (info->pseudo_palette))[image->bg_color];\r\n} else {\r\nfgcolor = image->fg_color;\r\nbgcolor = image->bg_color;\r\n}\r\nbreak;\r\ncase 8:\r\nstep = (width + 1) >> 1;\r\ncmdlen = 3 + height * step;\r\ncmdfn = mb86290fb_imageblit8;\r\nbreak;\r\ncase 16:\r\nstep = (width + 1) >> 1;\r\ncmdlen = 3 + height * step;\r\ncmdfn = mb86290fb_imageblit16;\r\nbreak;\r\ndefault:\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\ncmd = kmalloc(cmdlen * 4, GFP_DMA);\r\nif (!cmd)\r\nreturn cfb_imageblit(info, image);\r\ncmdfn(cmd, step, dx, dy, width, height, fgcolor, bgcolor, image, info);\r\nmb862xxfb_write_fifo(cmdlen, cmd, info);\r\nkfree(cmd);\r\n}\r\nstatic void mb86290fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nu32 x2, y2, vxres, vyres, height, width, fg;\r\nu32 cmd[7];\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (!rect->width || !rect->height || rect->dx > vxres\r\n|| rect->dy > vyres)\r\nreturn;\r\nx2 = rect->dx + rect->width;\r\ny2 = rect->dy + rect->height;\r\nx2 = min(x2, vxres);\r\ny2 = min(y2, vyres);\r\nwidth = x2 - rect->dx;\r\nheight = y2 - rect->dy;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\nfg = ((u32 *) (info->pseudo_palette))[rect->color];\r\nelse\r\nfg = rect->color;\r\nswitch (rect->rop) {\r\ncase ROP_XOR:\r\ncmd[1] = (2 << 7) | (GDC_ROP_XOR << 9);\r\nbreak;\r\ncase ROP_COPY:\r\ncmd[1] = (2 << 7) | (GDC_ROP_COPY << 9);\r\nbreak;\r\n}\r\ncmd[0] = (GDC_TYPE_SETREGISTER << 24) | (1 << 16) | GDC_REG_MODE_BITMAP;\r\ncmd[2] =\r\n(GDC_TYPE_SETCOLORREGISTER << 24) | (GDC_CMD_BODY_FORE_COLOR << 16);\r\ncmd[3] = fg;\r\ncmd[4] = (GDC_TYPE_DRAWRECTP << 24) | (GDC_CMD_BLT_FILL << 16);\r\ncmd[5] = (rect->dy << 16) | (rect->dx);\r\ncmd[6] = (height << 16) | width;\r\nmb862xxfb_write_fifo(7, cmd, info);\r\n}\r\nvoid mb862xxfb_init_accel(struct fb_info *info, int xres)\r\n{\r\nstruct mb862xxfb_par *par = info->par;\r\nif (info->var.bits_per_pixel == 32) {\r\ninfo->fbops->fb_fillrect = cfb_fillrect;\r\ninfo->fbops->fb_copyarea = cfb_copyarea;\r\ninfo->fbops->fb_imageblit = cfb_imageblit;\r\n} else {\r\noutreg(disp, GC_L0EM, 3);\r\ninfo->fbops->fb_fillrect = mb86290fb_fillrect;\r\ninfo->fbops->fb_copyarea = mb86290fb_copyarea;\r\ninfo->fbops->fb_imageblit = mb86290fb_imageblit;\r\n}\r\noutreg(draw, GDC_REG_DRAW_BASE, 0);\r\noutreg(draw, GDC_REG_MODE_MISC, 0x8000);\r\noutreg(draw, GDC_REG_X_RESOLUTION, xres);\r\ninfo->flags |=\r\nFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\ninfo->fix.accel = 0xff;\r\n}
