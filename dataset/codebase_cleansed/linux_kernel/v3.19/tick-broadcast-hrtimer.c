static void bc_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *bc)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nhrtimer_try_to_cancel(&bctimer);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int bc_set_next(ktime_t expires, struct clock_event_device *bc)\r\n{\r\nif (hrtimer_try_to_cancel(&bctimer) >= 0) {\r\nhrtimer_start(&bctimer, expires, HRTIMER_MODE_ABS_PINNED);\r\nbc->bound_on = smp_processor_id();\r\n} else if (bc->bound_on == smp_processor_id()) {\r\nhrtimer_set_expires(&bctimer, expires);\r\n}\r\nreturn 0;\r\n}\r\nstatic enum hrtimer_restart bc_handler(struct hrtimer *t)\r\n{\r\nce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);\r\nif (ce_broadcast_hrtimer.next_event.tv64 == KTIME_MAX)\r\nreturn HRTIMER_NORESTART;\r\nreturn HRTIMER_RESTART;\r\n}\r\nvoid tick_setup_hrtimer_broadcast(void)\r\n{\r\nhrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nbctimer.function = bc_handler;\r\nclockevents_register_device(&ce_broadcast_hrtimer);\r\n}
