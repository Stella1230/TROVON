static acpi_status\r\nacpi_ex_add_table(u32 table_index,\r\nstruct acpi_namespace_node *parent_node,\r\nunion acpi_operand_object **ddb_handle)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nacpi_status status;\r\nacpi_owner_id owner_id;\r\nACPI_FUNCTION_TRACE(ex_add_table);\r\nobj_desc = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nobj_desc->common.flags |= AOPOBJ_DATA_VALID;\r\nobj_desc->reference.class = ACPI_REFCLASS_TABLE;\r\n*ddb_handle = obj_desc;\r\nobj_desc->reference.value = table_index;\r\nstatus = acpi_ns_load_table(table_index, parent_node);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_remove_reference(obj_desc);\r\n*ddb_handle = NULL;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ex_exit_interpreter();\r\nacpi_ns_exec_module_code_list();\r\nacpi_ex_enter_interpreter();\r\nstatus = acpi_tb_get_owner_id(table_index, &owner_id);\r\nif (ACPI_SUCCESS(status)) {\r\nacpi_ev_update_gpes(owner_id);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ex_load_table_op(struct acpi_walk_state *walk_state,\r\nunion acpi_operand_object **return_desc)\r\n{\r\nacpi_status status;\r\nunion acpi_operand_object **operand = &walk_state->operands[0];\r\nstruct acpi_namespace_node *parent_node;\r\nstruct acpi_namespace_node *start_node;\r\nstruct acpi_namespace_node *parameter_node = NULL;\r\nunion acpi_operand_object *ddb_handle;\r\nstruct acpi_table_header *table;\r\nu32 table_index;\r\nACPI_FUNCTION_TRACE(ex_load_table_op);\r\nif ((operand[0]->string.length > ACPI_NAME_SIZE) ||\r\n(operand[1]->string.length > ACPI_OEM_ID_SIZE) ||\r\n(operand[2]->string.length > ACPI_OEM_TABLE_ID_SIZE)) {\r\nreturn_ACPI_STATUS(AE_AML_STRING_LIMIT);\r\n}\r\nstatus = acpi_tb_find_table(operand[0]->string.pointer,\r\noperand[1]->string.pointer,\r\noperand[2]->string.pointer, &table_index);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nddb_handle = acpi_ut_create_integer_object((u64) 0);\r\nif (!ddb_handle) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\n*return_desc = ddb_handle;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstart_node = walk_state->scope_info->scope.node;\r\nparent_node = acpi_gbl_root_node;\r\nif (operand[3]->string.length > 0) {\r\nstatus =\r\nacpi_ns_get_node(start_node, operand[3]->string.pointer,\r\nACPI_NS_SEARCH_PARENT, &parent_node);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (operand[4]->string.length > 0) {\r\nif ((operand[4]->string.pointer[0] != AML_ROOT_PREFIX) &&\r\n(operand[4]->string.pointer[0] != AML_PARENT_PREFIX)) {\r\nstart_node = parent_node;\r\n}\r\nstatus =\r\nacpi_ns_get_node(start_node, operand[4]->string.pointer,\r\nACPI_NS_SEARCH_PARENT, &parameter_node);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_ex_add_table(table_index, parent_node, &ddb_handle);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (parameter_node) {\r\nstatus = acpi_ex_store(operand[5],\r\nACPI_CAST_PTR(union acpi_operand_object,\r\nparameter_node),\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\n(void)acpi_ex_unload_table(ddb_handle);\r\nacpi_ut_remove_reference(ddb_handle);\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_get_table_by_index(table_index, &table);\r\nif (ACPI_SUCCESS(status)) {\r\nACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));\r\nacpi_tb_print_table_header(0, table);\r\n}\r\nif (acpi_gbl_table_handler) {\r\n(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_LOAD, table,\r\nacpi_gbl_table_handler_context);\r\n}\r\n*return_desc = ddb_handle;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ex_region_read(union acpi_operand_object *obj_desc, u32 length, u8 *buffer)\r\n{\r\nacpi_status status;\r\nu64 value;\r\nu32 region_offset = 0;\r\nu32 i;\r\nfor (i = 0; i < length; i++) {\r\nstatus =\r\nacpi_ev_address_space_dispatch(obj_desc, NULL, ACPI_READ,\r\nregion_offset, 8, &value);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*buffer = (u8)value;\r\nbuffer++;\r\nregion_offset++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ex_load_op(union acpi_operand_object *obj_desc,\r\nunion acpi_operand_object *target,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nunion acpi_operand_object *ddb_handle;\r\nstruct acpi_table_header *table_header;\r\nstruct acpi_table_header *table;\r\nu32 table_index;\r\nacpi_status status;\r\nu32 length;\r\nACPI_FUNCTION_TRACE(ex_load_op);\r\nswitch (obj_desc->common.type) {\r\ncase ACPI_TYPE_REGION:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Load table from Region %p\n", obj_desc));\r\nif (obj_desc->region.space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nif (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {\r\nstatus = acpi_ds_get_region_arguments(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\ntable_header = ACPI_ALLOCATE(sizeof(struct acpi_table_header));\r\nif (!table_header) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus =\r\nacpi_ex_region_read(obj_desc,\r\nsizeof(struct acpi_table_header),\r\nACPI_CAST_PTR(u8, table_header));\r\nlength = table_header->length;\r\nACPI_FREE(table_header);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (length < sizeof(struct acpi_table_header)) {\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable = ACPI_ALLOCATE(length);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_ex_region_read(obj_desc, length,\r\nACPI_CAST_PTR(u8, table));\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(table);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Load table from Buffer or Field %p\n",\r\nobj_desc));\r\nif (obj_desc->buffer.length < sizeof(struct acpi_table_header)) {\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable_header =\r\nACPI_CAST_PTR(struct acpi_table_header,\r\nobj_desc->buffer.pointer);\r\nlength = table_header->length;\r\nif (length > obj_desc->buffer.length) {\r\nreturn_ACPI_STATUS(AE_AML_BUFFER_LIMIT);\r\n}\r\nif (length < sizeof(struct acpi_table_header)) {\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable = ACPI_ALLOCATE(length);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nACPI_MEMCPY(table, table_header, length);\r\nbreak;\r\ndefault:\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\nACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nstatus = acpi_tb_install_standard_table(ACPI_PTR_TO_PHYSADDR(table),\r\nACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,\r\nTRUE, TRUE, &table_index);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(table);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_tb_validate_table(&acpi_gbl_root_table_list.\r\ntables[table_index]);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_ex_add_table(table_index, acpi_gbl_root_node, &ddb_handle);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ex_store(ddb_handle, target, walk_state);\r\nif (ACPI_FAILURE(status)) {\r\n(void)acpi_ex_unload_table(ddb_handle);\r\nacpi_ut_remove_reference(ddb_handle);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ut_remove_reference(ddb_handle);\r\nif (acpi_gbl_table_handler) {\r\n(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_LOAD, table,\r\nacpi_gbl_table_handler_context);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ex_unload_table(union acpi_operand_object *ddb_handle)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_operand_object *table_desc = ddb_handle;\r\nu32 table_index;\r\nstruct acpi_table_header *table;\r\nACPI_FUNCTION_TRACE(ex_unload_table);\r\nACPI_WARNING((AE_INFO, "Received request to unload an ACPI table"));\r\nif ((!ddb_handle) ||\r\n(ACPI_GET_DESCRIPTOR_TYPE(ddb_handle) != ACPI_DESC_TYPE_OPERAND) ||\r\n(ddb_handle->common.type != ACPI_TYPE_LOCAL_REFERENCE) ||\r\n(!(ddb_handle->common.flags & AOPOBJ_DATA_VALID))) {\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_TYPE);\r\n}\r\ntable_index = table_desc->reference.value;\r\nif (!acpi_tb_is_table_loaded(table_index)) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (acpi_gbl_table_handler) {\r\nstatus = acpi_get_table_by_index(table_index, &table);\r\nif (ACPI_SUCCESS(status)) {\r\n(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,\r\ntable,\r\nacpi_gbl_table_handler_context);\r\n}\r\n}\r\nstatus = acpi_tb_delete_namespace_by_owner(table_index);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n(void)acpi_tb_release_owner_id(table_index);\r\nacpi_tb_set_table_loaded_flag(table_index, FALSE);\r\nddb_handle->common.flags &= ~AOPOBJ_DATA_VALID;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
