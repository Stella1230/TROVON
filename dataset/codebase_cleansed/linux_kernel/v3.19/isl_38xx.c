void\r\nisl38xx_disable_interrupts(void __iomem *device)\r\n{\r\nisl38xx_w32_flush(device, 0x00000000, ISL38XX_INT_EN_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n}\r\nvoid\r\nisl38xx_handle_sleep_request(isl38xx_control_block *control_block,\r\nint *powerstate, void __iomem *device_base)\r\n{\r\nif (isl38xx_in_queue(control_block, ISL38XX_CB_TX_DATA_LQ))\r\nreturn;\r\nif (isl38xx_in_queue(control_block, ISL38XX_CB_TX_MGMTQ))\r\nreturn;\r\nif (isl38xx_in_queue(control_block, ISL38XX_CB_RX_DATA_LQ))\r\nreturn;\r\nif (isl38xx_in_queue(control_block, ISL38XX_CB_RX_MGMTQ))\r\nreturn;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Device going to sleep mode\n");\r\n#endif\r\n*powerstate = ISL38XX_PSM_POWERSAVE_STATE;\r\nisl38xx_w32_flush(device_base, ISL38XX_DEV_INT_SLEEP,\r\nISL38XX_DEV_INT_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n}\r\nvoid\r\nisl38xx_handle_wakeup(isl38xx_control_block *control_block,\r\nint *powerstate, void __iomem *device_base)\r\n{\r\n*powerstate = ISL38XX_PSM_ACTIVE_STATE;\r\nif (!isl38xx_in_queue(control_block, ISL38XX_CB_TX_DATA_LQ)\r\n&& !isl38xx_in_queue(control_block, ISL38XX_CB_TX_MGMTQ))\r\nreturn;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_ANYTHING, "Wake up handler trigger the device\n");\r\n#endif\r\nisl38xx_w32_flush(device_base, ISL38XX_DEV_INT_UPDATE,\r\nISL38XX_DEV_INT_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n}\r\nvoid\r\nisl38xx_trigger_device(int asleep, void __iomem *device_base)\r\n{\r\nu32 reg;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nu32 counter = 0;\r\nstruct timeval current_time;\r\nDEBUG(SHOW_FUNCTION_CALLS, "isl38xx trigger device\n");\r\n#endif\r\nif (asleep) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\ndo_gettimeofday(&current_time);\r\nDEBUG(SHOW_TRACING, "%08li.%08li Device wakeup triggered\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec);\r\nDEBUG(SHOW_TRACING, "%08li.%08li Device register read %08x\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec,\r\nreadl(device_base + ISL38XX_CTRL_STAT_REG));\r\n#endif\r\nreg = readl(device_base + ISL38XX_INT_IDENT_REG);\r\nif (reg == 0xabadface) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\ndo_gettimeofday(&current_time);\r\nDEBUG(SHOW_TRACING,\r\n"%08li.%08li Device register abadface\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec);\r\n#endif\r\nwhile (reg = readl(device_base + ISL38XX_CTRL_STAT_REG),\r\n(reg & ISL38XX_CTRL_STAT_SLEEPMODE) == 0) {\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\ncounter++;\r\n#endif\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"%08li.%08li Device register read %08x\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec,\r\nreadl(device_base + ISL38XX_CTRL_STAT_REG));\r\ndo_gettimeofday(&current_time);\r\nDEBUG(SHOW_TRACING,\r\n"%08li.%08li Device asleep counter %i\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec,\r\ncounter);\r\n#endif\r\n}\r\nisl38xx_w32_flush(device_base, ISL38XX_DEV_INT_WAKEUP,\r\nISL38XX_DEV_INT_REG);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg = readl(device_base + ISL38XX_CTRL_STAT_REG);\r\ndo_gettimeofday(&current_time);\r\nDEBUG(SHOW_TRACING, "%08li.%08li Device register read %08x\n",\r\ncurrent_time.tv_sec, (long)current_time.tv_usec, reg);\r\n#endif\r\n} else {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Device is in active state\n");\r\n#endif\r\nisl38xx_w32_flush(device_base, ISL38XX_DEV_INT_UPDATE,\r\nISL38XX_DEV_INT_REG);\r\n}\r\n}\r\nvoid\r\nisl38xx_interface_reset(void __iomem *device_base, dma_addr_t host_address)\r\n{\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "isl38xx_interface_reset\n");\r\n#endif\r\nisl38xx_w32_flush(device_base, host_address, ISL38XX_CTRL_BLK_BASE_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nisl38xx_w32_flush(device_base, ISL38XX_DEV_INT_RESET, ISL38XX_DEV_INT_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nisl38xx_w32_flush(device_base, ISL38XX_INT_IDENT_INIT, ISL38XX_INT_EN_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n}\r\nvoid\r\nisl38xx_enable_common_interrupts(void __iomem *device_base)\r\n{\r\nu32 reg;\r\nreg = ISL38XX_INT_IDENT_UPDATE | ISL38XX_INT_IDENT_SLEEP |\r\nISL38XX_INT_IDENT_WAKEUP;\r\nisl38xx_w32_flush(device_base, reg, ISL38XX_INT_EN_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\n}\r\nint\r\nisl38xx_in_queue(isl38xx_control_block *cb, int queue)\r\n{\r\nconst s32 delta = (le32_to_cpu(cb->driver_curr_frag[queue]) -\r\nle32_to_cpu(cb->device_curr_frag[queue]));\r\nBUG_ON(delta < 0);\r\nswitch (queue) {\r\ncase ISL38XX_CB_TX_MGMTQ:\r\nBUG_ON(delta > ISL38XX_CB_MGMT_QSIZE);\r\ncase ISL38XX_CB_TX_DATA_LQ:\r\ncase ISL38XX_CB_TX_DATA_HQ:\r\nBUG_ON(delta > ISL38XX_CB_TX_QSIZE);\r\nreturn delta;\r\ncase ISL38XX_CB_RX_MGMTQ:\r\nBUG_ON(delta > ISL38XX_CB_MGMT_QSIZE);\r\nreturn ISL38XX_CB_MGMT_QSIZE - delta;\r\ncase ISL38XX_CB_RX_DATA_LQ:\r\ncase ISL38XX_CB_RX_DATA_HQ:\r\nBUG_ON(delta > ISL38XX_CB_RX_QSIZE);\r\nreturn ISL38XX_CB_RX_QSIZE - delta;\r\n}\r\nBUG();\r\nreturn 0;\r\n}
