static inline int __iio_allocate_kfifo(struct iio_kfifo *buf,\r\nint bytes_per_datum, int length)\r\n{\r\nif ((length == 0) || (bytes_per_datum == 0))\r\nreturn -EINVAL;\r\nreturn __kfifo_alloc((struct __kfifo *)&buf->kf, length,\r\nbytes_per_datum, GFP_KERNEL);\r\n}\r\nstatic int iio_request_update_kfifo(struct iio_buffer *r)\r\n{\r\nint ret = 0;\r\nstruct iio_kfifo *buf = iio_to_kfifo(r);\r\nmutex_lock(&buf->user_lock);\r\nif (buf->update_needed) {\r\nkfifo_free(&buf->kf);\r\nret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,\r\nbuf->buffer.length);\r\nbuf->update_needed = false;\r\n} else {\r\nkfifo_reset_out(&buf->kf);\r\n}\r\nmutex_unlock(&buf->user_lock);\r\nreturn ret;\r\n}\r\nstatic int iio_get_length_kfifo(struct iio_buffer *r)\r\n{\r\nreturn r->length;\r\n}\r\nstatic int iio_get_bytes_per_datum_kfifo(struct iio_buffer *r)\r\n{\r\nreturn r->bytes_per_datum;\r\n}\r\nstatic int iio_mark_update_needed_kfifo(struct iio_buffer *r)\r\n{\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nkf->update_needed = true;\r\nreturn 0;\r\n}\r\nstatic int iio_set_bytes_per_datum_kfifo(struct iio_buffer *r, size_t bpd)\r\n{\r\nif (r->bytes_per_datum != bpd) {\r\nr->bytes_per_datum = bpd;\r\niio_mark_update_needed_kfifo(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_set_length_kfifo(struct iio_buffer *r, int length)\r\n{\r\nif (length < 2)\r\nlength = 2;\r\nif (r->length != length) {\r\nr->length = length;\r\niio_mark_update_needed_kfifo(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_store_to_kfifo(struct iio_buffer *r,\r\nconst void *data)\r\n{\r\nint ret;\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nret = kfifo_in(&kf->kf, data, 1);\r\nif (ret != 1)\r\nreturn -EBUSY;\r\nwake_up_interruptible_poll(&r->pollq, POLLIN | POLLRDNORM);\r\nreturn 0;\r\n}\r\nstatic int iio_read_first_n_kfifo(struct iio_buffer *r,\r\nsize_t n, char __user *buf)\r\n{\r\nint ret, copied;\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nif (mutex_lock_interruptible(&kf->user_lock))\r\nreturn -ERESTARTSYS;\r\nif (!kfifo_initialized(&kf->kf) || n < kfifo_esize(&kf->kf))\r\nret = -EINVAL;\r\nelse\r\nret = kfifo_to_user(&kf->kf, buf, n, &copied);\r\nmutex_unlock(&kf->user_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn copied;\r\n}\r\nstatic bool iio_kfifo_buf_data_available(struct iio_buffer *r)\r\n{\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nbool empty;\r\nmutex_lock(&kf->user_lock);\r\nempty = kfifo_is_empty(&kf->kf);\r\nmutex_unlock(&kf->user_lock);\r\nreturn !empty;\r\n}\r\nstatic void iio_kfifo_buffer_release(struct iio_buffer *buffer)\r\n{\r\nstruct iio_kfifo *kf = iio_to_kfifo(buffer);\r\nmutex_destroy(&kf->user_lock);\r\nkfifo_free(&kf->kf);\r\nkfree(kf);\r\n}\r\nstruct iio_buffer *iio_kfifo_allocate(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_kfifo *kf;\r\nkf = kzalloc(sizeof *kf, GFP_KERNEL);\r\nif (!kf)\r\nreturn NULL;\r\nkf->update_needed = true;\r\niio_buffer_init(&kf->buffer);\r\nkf->buffer.attrs = &iio_kfifo_attribute_group;\r\nkf->buffer.access = &kfifo_access_funcs;\r\nkf->buffer.length = 2;\r\nmutex_init(&kf->user_lock);\r\nreturn &kf->buffer;\r\n}\r\nvoid iio_kfifo_free(struct iio_buffer *r)\r\n{\r\niio_buffer_put(r);\r\n}
