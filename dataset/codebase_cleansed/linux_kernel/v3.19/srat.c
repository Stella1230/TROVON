static __init int setup_node(int pxm)\r\n{\r\nreturn acpi_map_pxm_to_node(pxm);\r\n}\r\nstatic __init void bad_srat(void)\r\n{\r\nprintk(KERN_ERR "SRAT: SRAT not used.\n");\r\nacpi_numa = -1;\r\n}\r\nstatic __init inline int srat_disabled(void)\r\n{\r\nreturn acpi_numa < 0;\r\n}\r\nvoid __init acpi_numa_slit_init(struct acpi_table_slit *slit)\r\n{\r\nint i, j;\r\nfor (i = 0; i < slit->locality_count; i++) {\r\nconst int from_node = pxm_to_node(i);\r\nif (from_node == NUMA_NO_NODE)\r\ncontinue;\r\nfor (j = 0; j < slit->locality_count; j++) {\r\nconst int to_node = pxm_to_node(j);\r\nif (to_node == NUMA_NO_NODE)\r\ncontinue;\r\nnuma_set_distance(from_node, to_node,\r\nslit->entry[slit->locality_count * i + j]);\r\n}\r\n}\r\n}\r\nvoid __init\r\nacpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa)\r\n{\r\nint pxm, node;\r\nint apic_id;\r\nif (srat_disabled())\r\nreturn;\r\nif (pa->header.length < sizeof(struct acpi_srat_x2apic_cpu_affinity)) {\r\nbad_srat();\r\nreturn;\r\n}\r\nif ((pa->flags & ACPI_SRAT_CPU_ENABLED) == 0)\r\nreturn;\r\npxm = pa->proximity_domain;\r\napic_id = pa->apic_id;\r\nif (!apic->apic_id_valid(apic_id)) {\r\nprintk(KERN_INFO "SRAT: PXM %u -> X2APIC 0x%04x ignored\n",\r\npxm, apic_id);\r\nreturn;\r\n}\r\nnode = setup_node(pxm);\r\nif (node < 0) {\r\nprintk(KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);\r\nbad_srat();\r\nreturn;\r\n}\r\nif (apic_id >= MAX_LOCAL_APIC) {\r\nprintk(KERN_INFO "SRAT: PXM %u -> APIC 0x%04x -> Node %u skipped apicid that is too big\n", pxm, apic_id, node);\r\nreturn;\r\n}\r\nset_apicid_to_node(apic_id, node);\r\nnode_set(node, numa_nodes_parsed);\r\nacpi_numa = 1;\r\nprintk(KERN_INFO "SRAT: PXM %u -> APIC 0x%04x -> Node %u\n",\r\npxm, apic_id, node);\r\n}\r\nvoid __init\r\nacpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa)\r\n{\r\nint pxm, node;\r\nint apic_id;\r\nif (srat_disabled())\r\nreturn;\r\nif (pa->header.length != sizeof(struct acpi_srat_cpu_affinity)) {\r\nbad_srat();\r\nreturn;\r\n}\r\nif ((pa->flags & ACPI_SRAT_CPU_ENABLED) == 0)\r\nreturn;\r\npxm = pa->proximity_domain_lo;\r\nif (acpi_srat_revision >= 2)\r\npxm |= *((unsigned int*)pa->proximity_domain_hi) << 8;\r\nnode = setup_node(pxm);\r\nif (node < 0) {\r\nprintk(KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);\r\nbad_srat();\r\nreturn;\r\n}\r\nif (get_uv_system_type() >= UV_X2APIC)\r\napic_id = (pa->apic_id << 8) | pa->local_sapic_eid;\r\nelse\r\napic_id = pa->apic_id;\r\nif (apic_id >= MAX_LOCAL_APIC) {\r\nprintk(KERN_INFO "SRAT: PXM %u -> APIC 0x%02x -> Node %u skipped apicid that is too big\n", pxm, apic_id, node);\r\nreturn;\r\n}\r\nset_apicid_to_node(apic_id, node);\r\nnode_set(node, numa_nodes_parsed);\r\nacpi_numa = 1;\r\nprintk(KERN_INFO "SRAT: PXM %u -> APIC 0x%02x -> Node %u\n",\r\npxm, apic_id, node);\r\n}\r\nstatic inline int save_add_info(void) {return 1;}\r\nstatic inline int save_add_info(void) {return 0;}\r\nint __init\r\nacpi_numa_memory_affinity_init(struct acpi_srat_mem_affinity *ma)\r\n{\r\nu64 start, end;\r\nu32 hotpluggable;\r\nint node, pxm;\r\nif (srat_disabled())\r\ngoto out_err;\r\nif (ma->header.length != sizeof(struct acpi_srat_mem_affinity))\r\ngoto out_err_bad_srat;\r\nif ((ma->flags & ACPI_SRAT_MEM_ENABLED) == 0)\r\ngoto out_err;\r\nhotpluggable = ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE;\r\nif (hotpluggable && !save_add_info())\r\ngoto out_err;\r\nstart = ma->base_address;\r\nend = start + ma->length;\r\npxm = ma->proximity_domain;\r\nif (acpi_srat_revision <= 1)\r\npxm &= 0xff;\r\nnode = setup_node(pxm);\r\nif (node < 0) {\r\nprintk(KERN_ERR "SRAT: Too many proximity domains.\n");\r\ngoto out_err_bad_srat;\r\n}\r\nif (numa_add_memblk(node, start, end) < 0)\r\ngoto out_err_bad_srat;\r\nnode_set(node, numa_nodes_parsed);\r\npr_info("SRAT: Node %u PXM %u [mem %#010Lx-%#010Lx]%s\n",\r\nnode, pxm,\r\n(unsigned long long) start, (unsigned long long) end - 1,\r\nhotpluggable ? " hotplug" : "");\r\nif (hotpluggable && memblock_mark_hotplug(start, ma->length))\r\npr_warn("SRAT: Failed to mark hotplug range [mem %#010Lx-%#010Lx] in memblock\n",\r\n(unsigned long long)start, (unsigned long long)end - 1);\r\nreturn 0;\r\nout_err_bad_srat:\r\nbad_srat();\r\nout_err:\r\nreturn -1;\r\n}\r\nvoid __init acpi_numa_arch_fixup(void) {}\r\nint __init x86_acpi_numa_init(void)\r\n{\r\nint ret;\r\nret = acpi_numa_init();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn srat_disabled() ? -EINVAL : 0;\r\n}
