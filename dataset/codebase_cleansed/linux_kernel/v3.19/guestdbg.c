static void extend_address_range(u64 *start, u64 *stop, u64 estart, int len)\r\n{\r\nu64 estop;\r\nif (len > 0)\r\nlen--;\r\nelse\r\nlen = 0;\r\nestop = estart + len;\r\nif ((*start == 0) && (*stop == 0)) {\r\n*start = estart;\r\n*stop = estop;\r\n} else if (*start <= *stop) {\r\nif (estart < *start)\r\n*start = estart;\r\nif (estop > *stop)\r\n*stop = estop;\r\n} else {\r\nif (estart <= *stop) {\r\nif (estop > *stop)\r\n*stop = estop;\r\n} else if (estop > *start) {\r\nif (estart < *start)\r\n*start = estart;\r\n}\r\nelse if ((estop - *stop) < (*start - estart))\r\n*stop = estop;\r\nelse\r\n*start = estart;\r\n}\r\n}\r\nstatic void enable_all_hw_bp(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long start, len;\r\nu64 *cr9 = &vcpu->arch.sie_block->gcr[9];\r\nu64 *cr10 = &vcpu->arch.sie_block->gcr[10];\r\nu64 *cr11 = &vcpu->arch.sie_block->gcr[11];\r\nint i;\r\nif (vcpu->arch.guestdbg.nr_hw_bp <= 0 ||\r\nvcpu->arch.guestdbg.hw_bp_info == NULL)\r\nreturn;\r\nif (!(*cr9 & PER_EVENT_BRANCH))\r\n*cr9 |= PER_CONTROL_BRANCH_ADDRESS;\r\n*cr9 |= PER_EVENT_IFETCH | PER_EVENT_BRANCH;\r\nfor (i = 0; i < vcpu->arch.guestdbg.nr_hw_bp; i++) {\r\nstart = vcpu->arch.guestdbg.hw_bp_info[i].addr;\r\nlen = vcpu->arch.guestdbg.hw_bp_info[i].len;\r\nif (start < MAX_INST_SIZE) {\r\nlen += start;\r\nstart = 0;\r\n} else {\r\nstart -= MAX_INST_SIZE;\r\nlen += MAX_INST_SIZE;\r\n}\r\nextend_address_range(cr10, cr11, start, len);\r\n}\r\n}\r\nstatic void enable_all_hw_wp(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long start, len;\r\nu64 *cr9 = &vcpu->arch.sie_block->gcr[9];\r\nu64 *cr10 = &vcpu->arch.sie_block->gcr[10];\r\nu64 *cr11 = &vcpu->arch.sie_block->gcr[11];\r\nint i;\r\nif (vcpu->arch.guestdbg.nr_hw_wp <= 0 ||\r\nvcpu->arch.guestdbg.hw_wp_info == NULL)\r\nreturn;\r\nif (*cr9 & PER_EVENT_STORE && *cr9 & PER_CONTROL_ALTERATION) {\r\n*cr9 &= ~PER_CONTROL_ALTERATION;\r\n*cr10 = 0;\r\n*cr11 = PSW_ADDR_INSN;\r\n} else {\r\n*cr9 &= ~PER_CONTROL_ALTERATION;\r\n*cr9 |= PER_EVENT_STORE;\r\nfor (i = 0; i < vcpu->arch.guestdbg.nr_hw_wp; i++) {\r\nstart = vcpu->arch.guestdbg.hw_wp_info[i].addr;\r\nlen = vcpu->arch.guestdbg.hw_wp_info[i].len;\r\nextend_address_range(cr10, cr11, start, len);\r\n}\r\n}\r\n}\r\nvoid kvm_s390_backup_guest_per_regs(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.guestdbg.cr0 = vcpu->arch.sie_block->gcr[0];\r\nvcpu->arch.guestdbg.cr9 = vcpu->arch.sie_block->gcr[9];\r\nvcpu->arch.guestdbg.cr10 = vcpu->arch.sie_block->gcr[10];\r\nvcpu->arch.guestdbg.cr11 = vcpu->arch.sie_block->gcr[11];\r\n}\r\nvoid kvm_s390_restore_guest_per_regs(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.sie_block->gcr[0] = vcpu->arch.guestdbg.cr0;\r\nvcpu->arch.sie_block->gcr[9] = vcpu->arch.guestdbg.cr9;\r\nvcpu->arch.sie_block->gcr[10] = vcpu->arch.guestdbg.cr10;\r\nvcpu->arch.sie_block->gcr[11] = vcpu->arch.guestdbg.cr11;\r\n}\r\nvoid kvm_s390_patch_guest_per_regs(struct kvm_vcpu *vcpu)\r\n{\r\nif (guestdbg_sstep_enabled(vcpu)) {\r\nvcpu->arch.sie_block->gcr[0] &= ~0x800ul;\r\nvcpu->arch.sie_block->gcr[9] |= PER_EVENT_IFETCH;\r\nvcpu->arch.sie_block->gcr[10] = 0;\r\nvcpu->arch.sie_block->gcr[11] = PSW_ADDR_INSN;\r\n}\r\nif (guestdbg_hw_bp_enabled(vcpu)) {\r\nenable_all_hw_bp(vcpu);\r\nenable_all_hw_wp(vcpu);\r\n}\r\nif (vcpu->arch.sie_block->gcr[9] & PER_EVENT_NULLIFICATION)\r\nvcpu->arch.sie_block->gcr[9] &= ~PER_EVENT_NULLIFICATION;\r\n}\r\nstatic int __import_wp_info(struct kvm_vcpu *vcpu,\r\nstruct kvm_hw_breakpoint *bp_data,\r\nstruct kvm_hw_wp_info_arch *wp_info)\r\n{\r\nint ret = 0;\r\nwp_info->len = bp_data->len;\r\nwp_info->addr = bp_data->addr;\r\nwp_info->phys_addr = bp_data->phys_addr;\r\nwp_info->old_data = NULL;\r\nif (wp_info->len < 0 || wp_info->len > MAX_WP_SIZE)\r\nreturn -EINVAL;\r\nwp_info->old_data = kmalloc(bp_data->len, GFP_KERNEL);\r\nif (!wp_info->old_data)\r\nreturn -ENOMEM;\r\nret = read_guest(vcpu, wp_info->phys_addr, wp_info->old_data,\r\nwp_info->len);\r\nif (ret) {\r\nkfree(wp_info->old_data);\r\nwp_info->old_data = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint kvm_s390_import_bp_data(struct kvm_vcpu *vcpu,\r\nstruct kvm_guest_debug *dbg)\r\n{\r\nint ret = 0, nr_wp = 0, nr_bp = 0, i, size;\r\nstruct kvm_hw_breakpoint *bp_data = NULL;\r\nstruct kvm_hw_wp_info_arch *wp_info = NULL;\r\nstruct kvm_hw_bp_info_arch *bp_info = NULL;\r\nif (dbg->arch.nr_hw_bp <= 0 || !dbg->arch.hw_bp)\r\nreturn 0;\r\nelse if (dbg->arch.nr_hw_bp > MAX_BP_COUNT)\r\nreturn -EINVAL;\r\nsize = dbg->arch.nr_hw_bp * sizeof(struct kvm_hw_breakpoint);\r\nbp_data = kmalloc(size, GFP_KERNEL);\r\nif (!bp_data) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (copy_from_user(bp_data, dbg->arch.hw_bp, size)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nfor (i = 0; i < dbg->arch.nr_hw_bp; i++) {\r\nswitch (bp_data[i].type) {\r\ncase KVM_HW_WP_WRITE:\r\nnr_wp++;\r\nbreak;\r\ncase KVM_HW_BP:\r\nnr_bp++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsize = nr_wp * sizeof(struct kvm_hw_wp_info_arch);\r\nif (size > 0) {\r\nwp_info = kmalloc(size, GFP_KERNEL);\r\nif (!wp_info) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nsize = nr_bp * sizeof(struct kvm_hw_bp_info_arch);\r\nif (size > 0) {\r\nbp_info = kmalloc(size, GFP_KERNEL);\r\nif (!bp_info) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nfor (nr_wp = 0, nr_bp = 0, i = 0; i < dbg->arch.nr_hw_bp; i++) {\r\nswitch (bp_data[i].type) {\r\ncase KVM_HW_WP_WRITE:\r\nret = __import_wp_info(vcpu, &bp_data[i],\r\n&wp_info[nr_wp]);\r\nif (ret)\r\ngoto error;\r\nnr_wp++;\r\nbreak;\r\ncase KVM_HW_BP:\r\nbp_info[nr_bp].len = bp_data[i].len;\r\nbp_info[nr_bp].addr = bp_data[i].addr;\r\nnr_bp++;\r\nbreak;\r\n}\r\n}\r\nvcpu->arch.guestdbg.nr_hw_bp = nr_bp;\r\nvcpu->arch.guestdbg.hw_bp_info = bp_info;\r\nvcpu->arch.guestdbg.nr_hw_wp = nr_wp;\r\nvcpu->arch.guestdbg.hw_wp_info = wp_info;\r\nreturn 0;\r\nerror:\r\nkfree(bp_data);\r\nkfree(wp_info);\r\nkfree(bp_info);\r\nreturn ret;\r\n}\r\nvoid kvm_s390_clear_bp_data(struct kvm_vcpu *vcpu)\r\n{\r\nint i;\r\nstruct kvm_hw_wp_info_arch *hw_wp_info = NULL;\r\nfor (i = 0; i < vcpu->arch.guestdbg.nr_hw_wp; i++) {\r\nhw_wp_info = &vcpu->arch.guestdbg.hw_wp_info[i];\r\nkfree(hw_wp_info->old_data);\r\nhw_wp_info->old_data = NULL;\r\n}\r\nkfree(vcpu->arch.guestdbg.hw_wp_info);\r\nvcpu->arch.guestdbg.hw_wp_info = NULL;\r\nkfree(vcpu->arch.guestdbg.hw_bp_info);\r\nvcpu->arch.guestdbg.hw_bp_info = NULL;\r\nvcpu->arch.guestdbg.nr_hw_wp = 0;\r\nvcpu->arch.guestdbg.nr_hw_bp = 0;\r\n}\r\nstatic inline int in_addr_range(u64 addr, u64 a, u64 b)\r\n{\r\nif (a <= b)\r\nreturn (addr >= a) && (addr <= b);\r\nelse\r\nreturn (addr <= a) && (addr >= b);\r\n}\r\nstatic struct kvm_hw_bp_info_arch *find_hw_bp(struct kvm_vcpu *vcpu,\r\nunsigned long addr)\r\n{\r\nstruct kvm_hw_bp_info_arch *bp_info = vcpu->arch.guestdbg.hw_bp_info;\r\nint i;\r\nif (vcpu->arch.guestdbg.nr_hw_bp == 0)\r\nreturn NULL;\r\nfor (i = 0; i < vcpu->arch.guestdbg.nr_hw_bp; i++) {\r\nif (addr == bp_info->addr)\r\ngoto found;\r\nif (bp_info->len > 0 &&\r\nin_addr_range(addr, bp_info->addr, end_of_range(bp_info)))\r\ngoto found;\r\nbp_info++;\r\n}\r\nreturn NULL;\r\nfound:\r\nreturn bp_info;\r\n}\r\nstatic struct kvm_hw_wp_info_arch *any_wp_changed(struct kvm_vcpu *vcpu)\r\n{\r\nint i;\r\nstruct kvm_hw_wp_info_arch *wp_info = NULL;\r\nvoid *temp = NULL;\r\nif (vcpu->arch.guestdbg.nr_hw_wp == 0)\r\nreturn NULL;\r\nfor (i = 0; i < vcpu->arch.guestdbg.nr_hw_wp; i++) {\r\nwp_info = &vcpu->arch.guestdbg.hw_wp_info[i];\r\nif (!wp_info || !wp_info->old_data || wp_info->len <= 0)\r\ncontinue;\r\ntemp = kmalloc(wp_info->len, GFP_KERNEL);\r\nif (!temp)\r\ncontinue;\r\nif (!read_guest(vcpu, wp_info->phys_addr, temp,\r\nwp_info->len)) {\r\nif (memcmp(temp, wp_info->old_data, wp_info->len)) {\r\nkfree(temp);\r\nreturn wp_info;\r\n}\r\n}\r\nkfree(temp);\r\ntemp = NULL;\r\n}\r\nreturn NULL;\r\n}\r\nvoid kvm_s390_prepare_debug_exit(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->run->exit_reason = KVM_EXIT_DEBUG;\r\nvcpu->guest_debug &= ~KVM_GUESTDBG_EXIT_PENDING;\r\n}\r\nstatic int debug_exit_required(struct kvm_vcpu *vcpu)\r\n{\r\nu32 perc = (vcpu->arch.sie_block->perc << 24);\r\nstruct kvm_debug_exit_arch *debug_exit = &vcpu->run->debug.arch;\r\nstruct kvm_hw_wp_info_arch *wp_info = NULL;\r\nstruct kvm_hw_bp_info_arch *bp_info = NULL;\r\nunsigned long addr = vcpu->arch.sie_block->gpsw.addr;\r\nunsigned long peraddr = vcpu->arch.sie_block->peraddr;\r\nif (guestdbg_hw_bp_enabled(vcpu)) {\r\nif (per_write_wp_event(perc) &&\r\nvcpu->arch.guestdbg.nr_hw_wp > 0) {\r\nwp_info = any_wp_changed(vcpu);\r\nif (wp_info) {\r\ndebug_exit->addr = wp_info->addr;\r\ndebug_exit->type = KVM_HW_WP_WRITE;\r\ngoto exit_required;\r\n}\r\n}\r\nif (per_bp_event(perc) &&\r\nvcpu->arch.guestdbg.nr_hw_bp > 0) {\r\nbp_info = find_hw_bp(vcpu, addr);\r\nif (bp_info && (addr != peraddr)) {\r\ndebug_exit->addr = addr;\r\ndebug_exit->type = KVM_HW_BP;\r\nvcpu->arch.guestdbg.last_bp = addr;\r\ngoto exit_required;\r\n}\r\nbp_info = find_hw_bp(vcpu, peraddr);\r\nif (bp_info && vcpu->arch.guestdbg.last_bp != peraddr) {\r\ndebug_exit->addr = peraddr;\r\ndebug_exit->type = KVM_HW_BP;\r\ngoto exit_required;\r\n}\r\n}\r\n}\r\nif (guestdbg_sstep_enabled(vcpu) && per_bp_event(perc)) {\r\ndebug_exit->addr = addr;\r\ndebug_exit->type = KVM_SINGLESTEP;\r\ngoto exit_required;\r\n}\r\nreturn 0;\r\nexit_required:\r\nreturn 1;\r\n}\r\nstatic void filter_guest_per_event(struct kvm_vcpu *vcpu)\r\n{\r\nu32 perc = vcpu->arch.sie_block->perc << 24;\r\nu64 peraddr = vcpu->arch.sie_block->peraddr;\r\nu64 addr = vcpu->arch.sie_block->gpsw.addr;\r\nu64 cr9 = vcpu->arch.sie_block->gcr[9];\r\nu64 cr10 = vcpu->arch.sie_block->gcr[10];\r\nu64 cr11 = vcpu->arch.sie_block->gcr[11];\r\nu32 guest_perc = perc & cr9 & PER_EVENT_MASK;\r\nif (!guest_per_enabled(vcpu))\r\nguest_perc = 0;\r\nif (guest_perc & PER_EVENT_BRANCH &&\r\ncr9 & PER_CONTROL_BRANCH_ADDRESS &&\r\n!in_addr_range(addr, cr10, cr11))\r\nguest_perc &= ~PER_EVENT_BRANCH;\r\nif (guest_perc & PER_EVENT_IFETCH &&\r\n!in_addr_range(peraddr, cr10, cr11))\r\nguest_perc &= ~PER_EVENT_IFETCH;\r\nvcpu->arch.sie_block->perc = guest_perc >> 24;\r\nif (!guest_perc)\r\nvcpu->arch.sie_block->iprcc &= ~PGM_PER;\r\n}\r\nvoid kvm_s390_handle_per_event(struct kvm_vcpu *vcpu)\r\n{\r\nif (debug_exit_required(vcpu))\r\nvcpu->guest_debug |= KVM_GUESTDBG_EXIT_PENDING;\r\nfilter_guest_per_event(vcpu);\r\n}
