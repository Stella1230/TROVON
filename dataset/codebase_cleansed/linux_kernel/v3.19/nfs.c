static struct inode *fat_dget(struct super_block *sb, int i_logstart)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nstruct hlist_head *head;\r\nstruct msdos_inode_info *i;\r\nstruct inode *inode = NULL;\r\nhead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\r\nspin_lock(&sbi->dir_hash_lock);\r\nhlist_for_each_entry(i, head, i_dir_hash) {\r\nBUG_ON(i->vfs_inode.i_sb != sb);\r\nif (i->i_logstart != i_logstart)\r\ncontinue;\r\ninode = igrab(&i->vfs_inode);\r\nif (inode)\r\nbreak;\r\n}\r\nspin_unlock(&sbi->dir_hash_lock);\r\nreturn inode;\r\n}\r\nstatic struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\r\n{\r\nif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\r\nreturn fat_iget(sb, i_pos);\r\nelse {\r\nif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\r\nreturn NULL;\r\nreturn ilookup(sb, ino);\r\n}\r\n}\r\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\r\nu64 ino, u32 generation, loff_t i_pos)\r\n{\r\nstruct inode *inode = fat_ilookup(sb, ino, i_pos);\r\nif (inode && generation && (inode->i_generation != generation)) {\r\niput(inode);\r\ninode = NULL;\r\n}\r\nif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\r\nstruct buffer_head *bh = NULL;\r\nstruct msdos_dir_entry *de ;\r\nsector_t blocknr;\r\nint offset;\r\nfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\r\nbh = sb_bread(sb, blocknr);\r\nif (!bh) {\r\nfat_msg(sb, KERN_ERR,\r\n"unable to read block(%llu) for building NFS inode",\r\n(llu)blocknr);\r\nreturn inode;\r\n}\r\nde = (struct msdos_dir_entry *)bh->b_data;\r\nif (IS_FREE(de[offset].name))\r\ninode = NULL;\r\nelse\r\ninode = fat_build_inode(sb, &de[offset], i_pos);\r\nbrelse(bh);\r\n}\r\nreturn inode;\r\n}\r\nstatic struct inode *fat_nfs_get_inode(struct super_block *sb,\r\nu64 ino, u32 generation)\r\n{\r\nreturn __fat_nfs_get_inode(sb, ino, generation, 0);\r\n}\r\nstatic int\r\nfat_encode_fh_nostale(struct inode *inode, __u32 *fh, int *lenp,\r\nstruct inode *parent)\r\n{\r\nint len = *lenp;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\r\nstruct fat_fid *fid = (struct fat_fid *) fh;\r\nloff_t i_pos;\r\nint type = FILEID_FAT_WITHOUT_PARENT;\r\nif (parent) {\r\nif (len < FAT_FID_SIZE_WITH_PARENT) {\r\n*lenp = FAT_FID_SIZE_WITH_PARENT;\r\nreturn FILEID_INVALID;\r\n}\r\n} else {\r\nif (len < FAT_FID_SIZE_WITHOUT_PARENT) {\r\n*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\r\nreturn FILEID_INVALID;\r\n}\r\n}\r\ni_pos = fat_i_pos_read(sbi, inode);\r\n*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\r\nfid->i_gen = inode->i_generation;\r\nfid->i_pos_low = i_pos & 0xFFFFFFFF;\r\nfid->i_pos_hi = (i_pos >> 32) & 0xFFFF;\r\nif (parent) {\r\ni_pos = fat_i_pos_read(sbi, parent);\r\nfid->parent_i_pos_hi = (i_pos >> 32) & 0xFFFF;\r\nfid->parent_i_pos_low = i_pos & 0xFFFFFFFF;\r\nfid->parent_i_gen = parent->i_generation;\r\ntype = FILEID_FAT_WITH_PARENT;\r\n*lenp = FAT_FID_SIZE_WITH_PARENT;\r\n}\r\nreturn type;\r\n}\r\nstatic struct dentry *fat_fh_to_dentry(struct super_block *sb, struct fid *fid,\r\nint fh_len, int fh_type)\r\n{\r\nreturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\r\nfat_nfs_get_inode);\r\n}\r\nstatic struct dentry *fat_fh_to_dentry_nostale(struct super_block *sb,\r\nstruct fid *fh, int fh_len,\r\nint fh_type)\r\n{\r\nstruct inode *inode = NULL;\r\nstruct fat_fid *fid = (struct fat_fid *)fh;\r\nloff_t i_pos;\r\nswitch (fh_type) {\r\ncase FILEID_FAT_WITHOUT_PARENT:\r\nif (fh_len < FAT_FID_SIZE_WITHOUT_PARENT)\r\nreturn NULL;\r\nbreak;\r\ncase FILEID_FAT_WITH_PARENT:\r\nif (fh_len < FAT_FID_SIZE_WITH_PARENT)\r\nreturn NULL;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\ni_pos = fid->i_pos_hi;\r\ni_pos = (i_pos << 32) | (fid->i_pos_low);\r\ninode = __fat_nfs_get_inode(sb, 0, fid->i_gen, i_pos);\r\nreturn d_obtain_alias(inode);\r\n}\r\nstatic struct dentry *fat_fh_to_parent(struct super_block *sb, struct fid *fid,\r\nint fh_len, int fh_type)\r\n{\r\nreturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\r\nfat_nfs_get_inode);\r\n}\r\nstatic struct dentry *fat_fh_to_parent_nostale(struct super_block *sb,\r\nstruct fid *fh, int fh_len,\r\nint fh_type)\r\n{\r\nstruct inode *inode = NULL;\r\nstruct fat_fid *fid = (struct fat_fid *)fh;\r\nloff_t i_pos;\r\nif (fh_len < FAT_FID_SIZE_WITH_PARENT)\r\nreturn NULL;\r\nswitch (fh_type) {\r\ncase FILEID_FAT_WITH_PARENT:\r\ni_pos = fid->parent_i_pos_hi;\r\ni_pos = (i_pos << 32) | (fid->parent_i_pos_low);\r\ninode = __fat_nfs_get_inode(sb, 0, fid->parent_i_gen, i_pos);\r\nbreak;\r\n}\r\nreturn d_obtain_alias(inode);\r\n}\r\nstatic\r\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\r\n{\r\nint search_clus, clus_to_match;\r\nstruct msdos_dir_entry *de;\r\nstruct inode *parent = NULL;\r\nstruct inode *dummy_grand_parent = NULL;\r\nstruct fat_slot_info sinfo;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\r\nstruct buffer_head *parent_bh = sb_bread(sb, blknr);\r\nif (!parent_bh) {\r\nfat_msg(sb, KERN_ERR,\r\n"unable to read cluster of parent directory");\r\nreturn NULL;\r\n}\r\nde = (struct msdos_dir_entry *) parent_bh->b_data;\r\nclus_to_match = fat_get_start(sbi, &de[0]);\r\nsearch_clus = fat_get_start(sbi, &de[1]);\r\ndummy_grand_parent = fat_dget(sb, search_clus);\r\nif (!dummy_grand_parent) {\r\ndummy_grand_parent = new_inode(sb);\r\nif (!dummy_grand_parent) {\r\nbrelse(parent_bh);\r\nreturn parent;\r\n}\r\ndummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\r\nfat_fill_inode(dummy_grand_parent, &de[1]);\r\nMSDOS_I(dummy_grand_parent)->i_pos = -1;\r\n}\r\nif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\r\nparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(parent_bh);\r\niput(dummy_grand_parent);\r\nreturn parent;\r\n}\r\nstatic struct dentry *fat_get_parent(struct dentry *child_dir)\r\n{\r\nstruct super_block *sb = child_dir->d_sb;\r\nstruct buffer_head *bh = NULL;\r\nstruct msdos_dir_entry *de;\r\nstruct inode *parent_inode = NULL;\r\nstruct msdos_sb_info *sbi = MSDOS_SB(sb);\r\nif (!fat_get_dotdot_entry(child_dir->d_inode, &bh, &de)) {\r\nint parent_logstart = fat_get_start(sbi, de);\r\nparent_inode = fat_dget(sb, parent_logstart);\r\nif (!parent_inode && sbi->options.nfs == FAT_NFS_NOSTALE_RO)\r\nparent_inode = fat_rebuild_parent(sb, parent_logstart);\r\n}\r\nbrelse(bh);\r\nreturn d_obtain_alias(parent_inode);\r\n}
