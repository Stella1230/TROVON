static void gio_bus_release(struct device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nconst struct gio_device_id *gio_match_device(const struct gio_device_id *match,\r\nconst struct gio_device *dev)\r\n{\r\nconst struct gio_device_id *ids;\r\nfor (ids = match; ids->id != 0xff; ids++)\r\nif (ids->id == dev->id.id)\r\nreturn ids;\r\nreturn NULL;\r\n}\r\nstruct gio_device *gio_dev_get(struct gio_device *dev)\r\n{\r\nstruct device *tmp;\r\nif (!dev)\r\nreturn NULL;\r\ntmp = get_device(&dev->dev);\r\nif (tmp)\r\nreturn to_gio_device(tmp);\r\nelse\r\nreturn NULL;\r\n}\r\nvoid gio_dev_put(struct gio_device *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->dev);\r\n}\r\nvoid gio_release_dev(struct device *dev)\r\n{\r\nstruct gio_device *giodev;\r\ngiodev = to_gio_device(dev);\r\nkfree(giodev);\r\n}\r\nint gio_device_register(struct gio_device *giodev)\r\n{\r\ngiodev->dev.bus = &gio_bus_type;\r\ngiodev->dev.parent = &gio_bus;\r\nreturn device_register(&giodev->dev);\r\n}\r\nvoid gio_device_unregister(struct gio_device *giodev)\r\n{\r\ndevice_unregister(&giodev->dev);\r\n}\r\nstatic int gio_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nstruct gio_driver *gio_drv = to_gio_driver(drv);\r\nreturn gio_match_device(gio_drv->id_table, gio_dev) != NULL;\r\n}\r\nstatic int gio_device_probe(struct device *dev)\r\n{\r\nint error = -ENODEV;\r\nstruct gio_driver *drv;\r\nstruct gio_device *gio_dev;\r\nconst struct gio_device_id *match;\r\ndrv = to_gio_driver(dev->driver);\r\ngio_dev = to_gio_device(dev);\r\nif (!drv->probe)\r\nreturn error;\r\ngio_dev_get(gio_dev);\r\nmatch = gio_match_device(drv->id_table, gio_dev);\r\nif (match)\r\nerror = drv->probe(gio_dev, match);\r\nif (error)\r\ngio_dev_put(gio_dev);\r\nreturn error;\r\n}\r\nstatic int gio_device_remove(struct device *dev)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nstruct gio_driver *drv = to_gio_driver(dev->driver);\r\nif (dev->driver && drv->remove)\r\ndrv->remove(gio_dev);\r\nreturn 0;\r\n}\r\nstatic int gio_device_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nstruct gio_driver *drv = to_gio_driver(dev->driver);\r\nint error = 0;\r\nif (dev->driver && drv->suspend)\r\nerror = drv->suspend(gio_dev, state);\r\nreturn error;\r\n}\r\nstatic int gio_device_resume(struct device *dev)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nstruct gio_driver *drv = to_gio_driver(dev->driver);\r\nint error = 0;\r\nif (dev->driver && drv->resume)\r\nerror = drv->resume(gio_dev);\r\nreturn error;\r\n}\r\nstatic void gio_device_shutdown(struct device *dev)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nstruct gio_driver *drv = to_gio_driver(dev->driver);\r\nif (dev->driver && drv->shutdown)\r\ndrv->shutdown(gio_dev);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nint len = snprintf(buf, PAGE_SIZE, "gio:%x\n", gio_dev->id.id);\r\nreturn (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gio_device *giodev;\r\ngiodev = to_gio_device(dev);\r\nreturn sprintf(buf, "%s", giodev->name);\r\n}\r\nstatic ssize_t id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gio_device *giodev;\r\ngiodev = to_gio_device(dev);\r\nreturn sprintf(buf, "%x", giodev->id.id);\r\n}\r\nstatic int gio_device_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct gio_device *gio_dev = to_gio_device(dev);\r\nadd_uevent_var(env, "MODALIAS=gio:%x", gio_dev->id.id);\r\nreturn 0;\r\n}\r\nint gio_register_driver(struct gio_driver *drv)\r\n{\r\nif (!drv->driver.name)\r\ndrv->driver.name = drv->name;\r\nif (!drv->driver.owner)\r\ndrv->driver.owner = drv->owner;\r\ndrv->driver.bus = &gio_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid gio_unregister_driver(struct gio_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nvoid gio_set_master(struct gio_device *dev)\r\n{\r\nu32 tmp = sgimc->giopar;\r\nswitch (dev->slotno) {\r\ncase 0:\r\ntmp |= SGIMC_GIOPAR_MASTERGFX;\r\nbreak;\r\ncase 1:\r\ntmp |= SGIMC_GIOPAR_MASTEREXP0;\r\nbreak;\r\ncase 2:\r\ntmp |= SGIMC_GIOPAR_MASTEREXP1;\r\nbreak;\r\n}\r\nsgimc->giopar = tmp;\r\n}\r\nvoid ip22_gio_set_64bit(int slotno)\r\n{\r\nu32 tmp = sgimc->giopar;\r\nswitch (slotno) {\r\ncase 0:\r\ntmp |= SGIMC_GIOPAR_GFX64;\r\nbreak;\r\ncase 1:\r\ntmp |= SGIMC_GIOPAR_EXP064;\r\nbreak;\r\ncase 2:\r\ntmp |= SGIMC_GIOPAR_EXP164;\r\nbreak;\r\n}\r\nsgimc->giopar = tmp;\r\n}\r\nstatic int ip22_gio_id(unsigned long addr, u32 *res)\r\n{\r\nu8 tmp8;\r\nu8 tmp16;\r\nu32 tmp32;\r\nu8 *ptr8;\r\nu16 *ptr16;\r\nu32 *ptr32;\r\nptr32 = (void *)CKSEG1ADDR(addr);\r\nif (!get_dbe(tmp32, ptr32)) {\r\nptr8 = (void *)CKSEG1ADDR(addr + 3);\r\nif (get_dbe(tmp8, ptr8)) {\r\n*res = tmp32;\r\nreturn 1;\r\n}\r\nptr16 = (void *)CKSEG1ADDR(addr + 2);\r\nget_dbe(tmp16, ptr16);\r\nif (tmp8 == (tmp16 & 0xff) &&\r\ntmp8 == (tmp32 & 0xff) &&\r\ntmp16 == (tmp32 & 0xffff)) {\r\n*res = tmp32;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip22_is_gr2(unsigned long addr)\r\n{\r\nu32 tmp;\r\nu32 *ptr;\r\nptr = (void *)CKSEG1ADDR(addr + HQ2_MYSTERY_OFFS);\r\nif (!get_dbe(tmp, ptr)) {\r\nif (tmp == 0xdeadbeef)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip22_check_gio(int slotno, unsigned long addr, int irq)\r\n{\r\nconst char *name = "Unknown";\r\nstruct gio_device *gio_dev;\r\nu32 tmp;\r\n__u8 id;\r\nint i;\r\nif (ip22_is_gr2(addr))\r\ntmp = 0x7f;\r\nelse {\r\nif (!ip22_gio_id(addr, &tmp)) {\r\nif (ip22_gio_id(addr + NEWPORT_USTATUS_OFFS, &tmp))\r\ntmp = 0x7e;\r\nelse\r\ntmp = 0;\r\n}\r\n}\r\nif (tmp) {\r\nid = GIO_ID(tmp);\r\nif (tmp & GIO_32BIT_ID) {\r\nif (tmp & GIO_64BIT_IFACE)\r\nip22_gio_set_64bit(slotno);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(gio_name_table); i++) {\r\nif (id == gio_name_table[i].id) {\r\nname = gio_name_table[i].name;\r\nbreak;\r\n}\r\n}\r\nprintk(KERN_INFO "GIO: slot %d : %s (id %x)\n",\r\nslotno, name, id);\r\ngio_dev = kzalloc(sizeof *gio_dev, GFP_KERNEL);\r\ngio_dev->name = name;\r\ngio_dev->slotno = slotno;\r\ngio_dev->id.id = id;\r\ngio_dev->resource.start = addr;\r\ngio_dev->resource.end = addr + 0x3fffff;\r\ngio_dev->resource.flags = IORESOURCE_MEM;\r\ngio_dev->irq = irq;\r\ndev_set_name(&gio_dev->dev, "%d", slotno);\r\ngio_device_register(gio_dev);\r\n} else\r\nprintk(KERN_INFO "GIO: slot %d : Empty\n", slotno);\r\n}\r\nint __init ip22_gio_init(void)\r\n{\r\nunsigned int pbdma __maybe_unused;\r\nint ret;\r\nret = device_register(&gio_bus);\r\nif (ret) {\r\nput_device(&gio_bus);\r\nreturn ret;\r\n}\r\nret = bus_register(&gio_bus_type);\r\nif (!ret) {\r\nrequest_resource(&iomem_resource, &gio_bus_resource);\r\nprintk(KERN_INFO "GIO: Probing bus...\n");\r\nif (ip22_is_fullhouse()) {\r\nip22_check_gio(0, GIO_SLOT_GFX_BASE, SGI_GIO_1_IRQ);\r\nip22_check_gio(1, GIO_SLOT_EXP0_BASE, SGI_GIO_1_IRQ);\r\n} else {\r\nif (get_dbe(pbdma, (unsigned int *)&hpc3c1->pbdma[1]))\r\nip22_check_gio(0, GIO_SLOT_GFX_BASE,\r\nSGI_GIO_0_IRQ);\r\nip22_check_gio(1, GIO_SLOT_EXP0_BASE, SGI_GIOEXP0_IRQ);\r\nip22_check_gio(2, GIO_SLOT_EXP1_BASE, SGI_GIOEXP1_IRQ);\r\n}\r\n} else\r\ndevice_unregister(&gio_bus);\r\nreturn ret;\r\n}
