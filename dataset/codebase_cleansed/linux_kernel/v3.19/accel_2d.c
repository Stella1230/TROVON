void psb_spank(struct drm_psb_private *dev_priv)\r\n{\r\nPSB_WSGX32(_PSB_CS_RESET_BIF_RESET | _PSB_CS_RESET_DPM_RESET |\r\n_PSB_CS_RESET_TA_RESET | _PSB_CS_RESET_USE_RESET |\r\n_PSB_CS_RESET_ISP_RESET | _PSB_CS_RESET_TSP_RESET |\r\n_PSB_CS_RESET_TWOD_RESET, PSB_CR_SOFT_RESET);\r\nPSB_RSGX32(PSB_CR_SOFT_RESET);\r\nmsleep(1);\r\nPSB_WSGX32(0, PSB_CR_SOFT_RESET);\r\nwmb();\r\nPSB_WSGX32(PSB_RSGX32(PSB_CR_BIF_CTRL) | _PSB_CB_CTRL_CLEAR_FAULT,\r\nPSB_CR_BIF_CTRL);\r\nwmb();\r\n(void) PSB_RSGX32(PSB_CR_BIF_CTRL);\r\nmsleep(1);\r\nPSB_WSGX32(PSB_RSGX32(PSB_CR_BIF_CTRL) & ~_PSB_CB_CTRL_CLEAR_FAULT,\r\nPSB_CR_BIF_CTRL);\r\n(void) PSB_RSGX32(PSB_CR_BIF_CTRL);\r\nPSB_WSGX32(dev_priv->gtt.gatt_start, PSB_CR_BIF_TWOD_REQ_BASE);\r\n}\r\nstatic int psb_2d_wait_available(struct drm_psb_private *dev_priv,\r\nunsigned size)\r\n{\r\nuint32_t avail = PSB_RSGX32(PSB_CR_2D_SOCIF);\r\nunsigned long t = jiffies + HZ;\r\nwhile (avail < size) {\r\navail = PSB_RSGX32(PSB_CR_2D_SOCIF);\r\nif (time_after(jiffies, t)) {\r\npsb_spank(dev_priv);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int psbfb_2d_submit(struct drm_psb_private *dev_priv, uint32_t *cmdbuf,\r\nunsigned size)\r\n{\r\nint ret = 0;\r\nint i;\r\nunsigned submit_size;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->lock_2d, flags);\r\nwhile (size > 0) {\r\nsubmit_size = (size < 0x60) ? size : 0x60;\r\nsize -= submit_size;\r\nret = psb_2d_wait_available(dev_priv, submit_size);\r\nif (ret)\r\nbreak;\r\nsubmit_size <<= 2;\r\nfor (i = 0; i < submit_size; i += 4)\r\nPSB_WSGX32(*cmdbuf++, PSB_SGX_2D_SLAVE_PORT + i);\r\n(void)PSB_RSGX32(PSB_SGX_2D_SLAVE_PORT + i - 4);\r\n}\r\nspin_unlock_irqrestore(&dev_priv->lock_2d, flags);\r\nreturn ret;\r\n}\r\nstatic u32 psb_accel_2d_copy_direction(int xdir, int ydir)\r\n{\r\nif (xdir < 0)\r\nreturn (ydir < 0) ? PSB_2D_COPYORDER_BR2TL :\r\nPSB_2D_COPYORDER_TR2BL;\r\nelse\r\nreturn (ydir < 0) ? PSB_2D_COPYORDER_BL2TR :\r\nPSB_2D_COPYORDER_TL2BR;\r\n}\r\nstatic int psb_accel_2d_copy(struct drm_psb_private *dev_priv,\r\nuint32_t src_offset, uint32_t src_stride,\r\nuint32_t src_format, uint32_t dst_offset,\r\nuint32_t dst_stride, uint32_t dst_format,\r\nuint16_t src_x, uint16_t src_y,\r\nuint16_t dst_x, uint16_t dst_y,\r\nuint16_t size_x, uint16_t size_y)\r\n{\r\nuint32_t blit_cmd;\r\nuint32_t buffer[10];\r\nuint32_t *buf;\r\nuint32_t direction;\r\nbuf = buffer;\r\ndirection =\r\npsb_accel_2d_copy_direction(src_x - dst_x, src_y - dst_y);\r\nif (direction == PSB_2D_COPYORDER_BR2TL ||\r\ndirection == PSB_2D_COPYORDER_TR2BL) {\r\nsrc_x += size_x - 1;\r\ndst_x += size_x - 1;\r\n}\r\nif (direction == PSB_2D_COPYORDER_BR2TL ||\r\ndirection == PSB_2D_COPYORDER_BL2TR) {\r\nsrc_y += size_y - 1;\r\ndst_y += size_y - 1;\r\n}\r\nblit_cmd =\r\nPSB_2D_BLIT_BH |\r\nPSB_2D_ROT_NONE |\r\nPSB_2D_DSTCK_DISABLE |\r\nPSB_2D_SRCCK_DISABLE |\r\nPSB_2D_USE_PAT | PSB_2D_ROP3_SRCCOPY | direction;\r\n*buf++ = PSB_2D_FENCE_BH;\r\n*buf++ =\r\nPSB_2D_DST_SURF_BH | dst_format | (dst_stride <<\r\nPSB_2D_DST_STRIDE_SHIFT);\r\n*buf++ = dst_offset;\r\n*buf++ =\r\nPSB_2D_SRC_SURF_BH | src_format | (src_stride <<\r\nPSB_2D_SRC_STRIDE_SHIFT);\r\n*buf++ = src_offset;\r\n*buf++ =\r\nPSB_2D_SRC_OFF_BH | (src_x << PSB_2D_SRCOFF_XSTART_SHIFT) |\r\n(src_y << PSB_2D_SRCOFF_YSTART_SHIFT);\r\n*buf++ = blit_cmd;\r\n*buf++ =\r\n(dst_x << PSB_2D_DST_XSTART_SHIFT) | (dst_y <<\r\nPSB_2D_DST_YSTART_SHIFT);\r\n*buf++ =\r\n(size_x << PSB_2D_DST_XSIZE_SHIFT) | (size_y <<\r\nPSB_2D_DST_YSIZE_SHIFT);\r\n*buf++ = PSB_2D_FLUSH_BH;\r\nreturn psbfb_2d_submit(dev_priv, buffer, buf - buffer);\r\n}\r\nstatic void psbfb_copyarea_accel(struct fb_info *info,\r\nconst struct fb_copyarea *a)\r\n{\r\nstruct psb_fbdev *fbdev = info->par;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nstruct drm_device *dev = psbfb->base.dev;\r\nstruct drm_framebuffer *fb = fbdev->psb_fb_helper.fb;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nuint32_t offset;\r\nuint32_t stride;\r\nuint32_t src_format;\r\nuint32_t dst_format;\r\nif (!fb)\r\nreturn;\r\noffset = psbfb->gtt->offset;\r\nstride = fb->pitches[0];\r\nswitch (fb->depth) {\r\ncase 8:\r\nsrc_format = PSB_2D_SRC_332RGB;\r\ndst_format = PSB_2D_DST_332RGB;\r\nbreak;\r\ncase 15:\r\nsrc_format = PSB_2D_SRC_555RGB;\r\ndst_format = PSB_2D_DST_555RGB;\r\nbreak;\r\ncase 16:\r\nsrc_format = PSB_2D_SRC_565RGB;\r\ndst_format = PSB_2D_DST_565RGB;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nsrc_format = PSB_2D_SRC_8888ARGB;\r\ndst_format = PSB_2D_DST_8888ARGB;\r\nbreak;\r\ndefault:\r\ncfb_copyarea(info, a);\r\nreturn;\r\n}\r\nif (!gma_power_begin(dev, false)) {\r\ncfb_copyarea(info, a);\r\nreturn;\r\n}\r\npsb_accel_2d_copy(dev_priv,\r\noffset, stride, src_format,\r\noffset, stride, dst_format,\r\na->sx, a->sy, a->dx, a->dy, a->width, a->height);\r\ngma_power_end(dev);\r\n}\r\nvoid psbfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *region)\r\n{\r\nif (unlikely(info->state != FBINFO_STATE_RUNNING))\r\nreturn;\r\nif (region->width == 8 || region->height == 8 ||\r\n(info->flags & FBINFO_HWACCEL_DISABLED))\r\nreturn cfb_copyarea(info, region);\r\npsbfb_copyarea_accel(info, region);\r\n}\r\nint psbfb_sync(struct fb_info *info)\r\n{\r\nstruct psb_fbdev *fbdev = info->par;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nstruct drm_device *dev = psbfb->base.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long _end = jiffies + HZ;\r\nint busy = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->lock_2d, flags);\r\nif ((PSB_RSGX32(PSB_CR_2D_SOCIF) == _PSB_C2_SOCIF_EMPTY) &&\r\n((PSB_RSGX32(PSB_CR_2D_BLIT_STATUS) & _PSB_C2B_STATUS_BUSY) == 0))\r\ngoto out;\r\ndo {\r\nbusy = (PSB_RSGX32(PSB_CR_2D_SOCIF) != _PSB_C2_SOCIF_EMPTY);\r\ncpu_relax();\r\n} while (busy && !time_after_eq(jiffies, _end));\r\nif (busy)\r\nbusy = (PSB_RSGX32(PSB_CR_2D_SOCIF) != _PSB_C2_SOCIF_EMPTY);\r\nif (busy)\r\ngoto out;\r\ndo {\r\nbusy = ((PSB_RSGX32(PSB_CR_2D_BLIT_STATUS) &\r\n_PSB_C2B_STATUS_BUSY) != 0);\r\ncpu_relax();\r\n} while (busy && !time_after_eq(jiffies, _end));\r\nif (busy)\r\nbusy = ((PSB_RSGX32(PSB_CR_2D_BLIT_STATUS) &\r\n_PSB_C2B_STATUS_BUSY) != 0);\r\nout:\r\nspin_unlock_irqrestore(&dev_priv->lock_2d, flags);\r\nreturn (busy) ? -EBUSY : 0;\r\n}
