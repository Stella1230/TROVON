unsigned int __weak __init serial8250_early_in(struct uart_port *port, int offset)\r\n{\r\nswitch (port->iotype) {\r\ncase UPIO_MEM:\r\nreturn readb(port->membase + offset);\r\ncase UPIO_MEM32:\r\nreturn readl(port->membase + (offset << 2));\r\ncase UPIO_PORT:\r\nreturn inb(port->iobase + offset);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid __weak __init serial8250_early_out(struct uart_port *port, int offset, int value)\r\n{\r\nswitch (port->iotype) {\r\ncase UPIO_MEM:\r\nwriteb(value, port->membase + offset);\r\nbreak;\r\ncase UPIO_MEM32:\r\nwritel(value, port->membase + (offset << 2));\r\nbreak;\r\ncase UPIO_PORT:\r\noutb(value, port->iobase + offset);\r\nbreak;\r\n}\r\n}\r\nstatic void __init wait_for_xmitr(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nfor (;;) {\r\nstatus = serial8250_early_in(port, UART_LSR);\r\nif ((status & BOTH_EMPTY) == BOTH_EMPTY)\r\nreturn;\r\ncpu_relax();\r\n}\r\n}\r\nstatic void __init serial_putc(struct uart_port *port, int c)\r\n{\r\nwait_for_xmitr(port);\r\nserial8250_early_out(port, UART_TX, c);\r\n}\r\nstatic void __init early_serial8250_write(struct console *console,\r\nconst char *s, unsigned int count)\r\n{\r\nstruct uart_port *port = &early_device->port;\r\nunsigned int ier;\r\nier = serial8250_early_in(port, UART_IER);\r\nserial8250_early_out(port, UART_IER, 0);\r\nuart_console_write(port, s, count, serial_putc);\r\nwait_for_xmitr(port);\r\nserial8250_early_out(port, UART_IER, ier);\r\n}\r\nstatic unsigned int __init probe_baud(struct uart_port *port)\r\n{\r\nunsigned char lcr, dll, dlm;\r\nunsigned int quot;\r\nlcr = serial8250_early_in(port, UART_LCR);\r\nserial8250_early_out(port, UART_LCR, lcr | UART_LCR_DLAB);\r\ndll = serial8250_early_in(port, UART_DLL);\r\ndlm = serial8250_early_in(port, UART_DLM);\r\nserial8250_early_out(port, UART_LCR, lcr);\r\nquot = (dlm << 8) | dll;\r\nreturn (port->uartclk / 16) / quot;\r\n}\r\nstatic void __init init_port(struct earlycon_device *device)\r\n{\r\nstruct uart_port *port = &device->port;\r\nunsigned int divisor;\r\nunsigned char c;\r\nserial8250_early_out(port, UART_LCR, 0x3);\r\nserial8250_early_out(port, UART_IER, 0);\r\nserial8250_early_out(port, UART_FCR, 0);\r\nserial8250_early_out(port, UART_MCR, 0x3);\r\ndivisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * device->baud);\r\nc = serial8250_early_in(port, UART_LCR);\r\nserial8250_early_out(port, UART_LCR, c | UART_LCR_DLAB);\r\nserial8250_early_out(port, UART_DLL, divisor & 0xff);\r\nserial8250_early_out(port, UART_DLM, (divisor >> 8) & 0xff);\r\nserial8250_early_out(port, UART_LCR, c & ~UART_LCR_DLAB);\r\n}\r\nstatic int __init early_serial8250_setup(struct earlycon_device *device,\r\nconst char *options)\r\n{\r\nif (!(device->port.membase || device->port.iobase))\r\nreturn 0;\r\nif (!device->baud) {\r\ndevice->baud = probe_baud(&device->port);\r\nsnprintf(device->options, sizeof(device->options), "%u",\r\ndevice->baud);\r\n}\r\ninit_port(device);\r\nearly_device = device;\r\ndevice->con->write = early_serial8250_write;\r\nreturn 0;\r\n}\r\nint __init setup_early_serial8250_console(char *cmdline)\r\n{\r\nchar match[] = "uart8250";\r\nif (cmdline && cmdline[4] == ',')\r\nmatch[4] = '\0';\r\nreturn setup_earlycon(cmdline, match, early_serial8250_setup);\r\n}\r\nint serial8250_find_port_for_earlycon(void)\r\n{\r\nstruct earlycon_device *device = early_device;\r\nstruct uart_port *port = device ? &device->port : NULL;\r\nint line;\r\nint ret;\r\nif (!port || (!port->membase && !port->iobase))\r\nreturn -ENODEV;\r\nline = serial8250_find_port(port);\r\nif (line < 0)\r\nreturn -ENODEV;\r\nret = update_console_cmdline("uart", 8250,\r\n"ttyS", line, device->options);\r\nif (ret < 0)\r\nret = update_console_cmdline("uart", 0,\r\n"ttyS", line, device->options);\r\nreturn ret;\r\n}
