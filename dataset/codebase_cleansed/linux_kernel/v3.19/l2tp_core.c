static inline struct l2tp_tunnel *l2tp_tunnel(struct sock *sk)\r\n{\r\nreturn sk->sk_user_data;\r\n}\r\nstatic inline struct l2tp_net *l2tp_pernet(struct net *net)\r\n{\r\nBUG_ON(!net);\r\nreturn net_generic(net, l2tp_net_id);\r\n}\r\nstatic inline void l2tp_tunnel_inc_refcount_1(struct l2tp_tunnel *tunnel)\r\n{\r\natomic_inc(&tunnel->ref_count);\r\n}\r\nstatic inline void l2tp_tunnel_dec_refcount_1(struct l2tp_tunnel *tunnel)\r\n{\r\nif (atomic_dec_and_test(&tunnel->ref_count))\r\nl2tp_tunnel_free(tunnel);\r\n}\r\nstatic inline struct hlist_head *\r\nl2tp_session_id_hash_2(struct l2tp_net *pn, u32 session_id)\r\n{\r\nreturn &pn->l2tp_session_hlist[hash_32(session_id, L2TP_HASH_BITS_2)];\r\n}\r\nstatic struct sock *l2tp_tunnel_sock_lookup(struct l2tp_tunnel *tunnel)\r\n{\r\nint err = 0;\r\nstruct socket *sock = NULL;\r\nstruct sock *sk = NULL;\r\nif (!tunnel)\r\ngoto out;\r\nif (tunnel->fd >= 0) {\r\nsock = sockfd_lookup(tunnel->fd, &err);\r\nif (sock)\r\nsk = sock->sk;\r\n} else {\r\nsk = tunnel->sock;\r\nsock_hold(sk);\r\n}\r\nout:\r\nreturn sk;\r\n}\r\nstatic void l2tp_tunnel_sock_put(struct sock *sk)\r\n{\r\nstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\r\nif (tunnel) {\r\nif (tunnel->fd >= 0) {\r\nsockfd_put(sk->sk_socket);\r\n}\r\nsock_put(sk);\r\n}\r\nsock_put(sk);\r\n}\r\nstatic struct l2tp_session *l2tp_session_find_2(struct net *net, u32 session_id)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nstruct hlist_head *session_list =\r\nl2tp_session_id_hash_2(pn, session_id);\r\nstruct l2tp_session *session;\r\nrcu_read_lock_bh();\r\nhlist_for_each_entry_rcu(session, session_list, global_hlist) {\r\nif (session->session_id == session_id) {\r\nrcu_read_unlock_bh();\r\nreturn session;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstatic inline struct hlist_head *\r\nl2tp_session_id_hash(struct l2tp_tunnel *tunnel, u32 session_id)\r\n{\r\nreturn &tunnel->session_hlist[hash_32(session_id, L2TP_HASH_BITS)];\r\n}\r\nstruct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id)\r\n{\r\nstruct hlist_head *session_list;\r\nstruct l2tp_session *session;\r\nif (tunnel == NULL)\r\nreturn l2tp_session_find_2(net, session_id);\r\nsession_list = l2tp_session_id_hash(tunnel, session_id);\r\nread_lock_bh(&tunnel->hlist_lock);\r\nhlist_for_each_entry(session, session_list, hlist) {\r\nif (session->session_id == session_id) {\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn session;\r\n}\r\n}\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn NULL;\r\n}\r\nstruct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth)\r\n{\r\nint hash;\r\nstruct l2tp_session *session;\r\nint count = 0;\r\nread_lock_bh(&tunnel->hlist_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\r\nhlist_for_each_entry(session, &tunnel->session_hlist[hash], hlist) {\r\nif (++count > nth) {\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn session;\r\n}\r\n}\r\n}\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn NULL;\r\n}\r\nstruct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nint hash;\r\nstruct l2tp_session *session;\r\nrcu_read_lock_bh();\r\nfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++) {\r\nhlist_for_each_entry_rcu(session, &pn->l2tp_session_hlist[hash], global_hlist) {\r\nif (!strcmp(session->ifname, ifname)) {\r\nrcu_read_unlock_bh();\r\nreturn session;\r\n}\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstruct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nrcu_read_lock_bh();\r\nlist_for_each_entry_rcu(tunnel, &pn->l2tp_tunnel_list, list) {\r\nif (tunnel->tunnel_id == tunnel_id) {\r\nrcu_read_unlock_bh();\r\nreturn tunnel;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstruct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nstruct l2tp_tunnel *tunnel;\r\nint count = 0;\r\nrcu_read_lock_bh();\r\nlist_for_each_entry_rcu(tunnel, &pn->l2tp_tunnel_list, list) {\r\nif (++count > nth) {\r\nrcu_read_unlock_bh();\r\nreturn tunnel;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstatic void l2tp_recv_queue_skb(struct l2tp_session *session, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbp;\r\nstruct sk_buff *tmp;\r\nu32 ns = L2TP_SKB_CB(skb)->ns;\r\nspin_lock_bh(&session->reorder_q.lock);\r\nskb_queue_walk_safe(&session->reorder_q, skbp, tmp) {\r\nif (L2TP_SKB_CB(skbp)->ns > ns) {\r\n__skb_queue_before(&session->reorder_q, skbp, skb);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: pkt %hu, inserted before %hu, reorder_q len=%d\n",\r\nsession->name, ns, L2TP_SKB_CB(skbp)->ns,\r\nskb_queue_len(&session->reorder_q));\r\natomic_long_inc(&session->stats.rx_oos_packets);\r\ngoto out;\r\n}\r\n}\r\n__skb_queue_tail(&session->reorder_q, skb);\r\nout:\r\nspin_unlock_bh(&session->reorder_q.lock);\r\n}\r\nstatic void l2tp_recv_dequeue_skb(struct l2tp_session *session, struct sk_buff *skb)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nint length = L2TP_SKB_CB(skb)->length;\r\nskb_orphan(skb);\r\natomic_long_inc(&tunnel->stats.rx_packets);\r\natomic_long_add(length, &tunnel->stats.rx_bytes);\r\natomic_long_inc(&session->stats.rx_packets);\r\natomic_long_add(length, &session->stats.rx_bytes);\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nsession->nr++;\r\nsession->nr &= session->nr_max;\r\nl2tp_dbg(session, L2TP_MSG_SEQ, "%s: updated nr to %hu\n",\r\nsession->name, session->nr);\r\n}\r\nif (session->recv_skb != NULL)\r\n(*session->recv_skb)(session, skb, L2TP_SKB_CB(skb)->length);\r\nelse\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\n}\r\nstatic void l2tp_recv_dequeue(struct l2tp_session *session)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *tmp;\r\nstart:\r\nspin_lock_bh(&session->reorder_q.lock);\r\nskb_queue_walk_safe(&session->reorder_q, skb, tmp) {\r\nif (time_after(jiffies, L2TP_SKB_CB(skb)->expires)) {\r\natomic_long_inc(&session->stats.rx_seq_discards);\r\natomic_long_inc(&session->stats.rx_errors);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: oos pkt %u len %d discarded (too old), waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\nsession->reorder_skip = 1;\r\n__skb_unlink(skb, &session->reorder_q);\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\ncontinue;\r\n}\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif (session->reorder_skip) {\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: advancing nr to next pkt: %u -> %u",\r\nsession->name, session->nr,\r\nL2TP_SKB_CB(skb)->ns);\r\nsession->reorder_skip = 0;\r\nsession->nr = L2TP_SKB_CB(skb)->ns;\r\n}\r\nif (L2TP_SKB_CB(skb)->ns != session->nr) {\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: holding oos pkt %u len %d, waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\ngoto out;\r\n}\r\n}\r\n__skb_unlink(skb, &session->reorder_q);\r\nspin_unlock_bh(&session->reorder_q.lock);\r\nl2tp_recv_dequeue_skb(session, skb);\r\ngoto start;\r\n}\r\nout:\r\nspin_unlock_bh(&session->reorder_q.lock);\r\n}\r\nstatic int l2tp_seq_check_rx_window(struct l2tp_session *session, u32 nr)\r\n{\r\nu32 nws;\r\nif (nr >= session->nr)\r\nnws = nr - session->nr;\r\nelse\r\nnws = (session->nr_max + 1) - (session->nr - nr);\r\nreturn nws < session->nr_window_size;\r\n}\r\nstatic int l2tp_recv_data_seq(struct l2tp_session *session, struct sk_buff *skb)\r\n{\r\nif (!l2tp_seq_check_rx_window(session, L2TP_SKB_CB(skb)->ns)) {\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: pkt %u len %d discarded, outside window, nr=%u\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr);\r\ngoto discard;\r\n}\r\nif (session->reorder_timeout != 0) {\r\nl2tp_recv_queue_skb(session, skb);\r\ngoto out;\r\n}\r\nif (L2TP_SKB_CB(skb)->ns == session->nr) {\r\nskb_queue_tail(&session->reorder_q, skb);\r\n} else {\r\nu32 nr_oos = L2TP_SKB_CB(skb)->ns;\r\nu32 nr_next = (session->nr_oos + 1) & session->nr_max;\r\nif (nr_oos == nr_next)\r\nsession->nr_oos_count++;\r\nelse\r\nsession->nr_oos_count = 0;\r\nsession->nr_oos = nr_oos;\r\nif (session->nr_oos_count > session->nr_oos_count_max) {\r\nsession->reorder_skip = 1;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: %d oos packets received. Resetting sequence numbers\n",\r\nsession->name, session->nr_oos_count);\r\n}\r\nif (!session->reorder_skip) {\r\natomic_long_inc(&session->stats.rx_seq_discards);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: oos pkt %u len %d discarded, waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\ngoto discard;\r\n}\r\nskb_queue_tail(&session->reorder_q, skb);\r\n}\r\nout:\r\nreturn 0;\r\ndiscard:\r\nreturn 1;\r\n}\r\nvoid l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,\r\nunsigned char *ptr, unsigned char *optr, u16 hdrflags,\r\nint length, int (*payload_hook)(struct sk_buff *skb))\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nint offset;\r\nu32 ns, nr;\r\nl2tp_session_inc_refcount(session);\r\nif (session->ref)\r\n(*session->ref)(session);\r\nif (session->peer_cookie_len > 0) {\r\nif (memcmp(ptr, &session->peer_cookie[0], session->peer_cookie_len)) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: cookie mismatch (%u/%u). Discarding.\n",\r\ntunnel->name, tunnel->tunnel_id,\r\nsession->session_id);\r\natomic_long_inc(&session->stats.rx_cookie_discards);\r\ngoto discard;\r\n}\r\nptr += session->peer_cookie_len;\r\n}\r\nns = nr = 0;\r\nL2TP_SKB_CB(skb)->has_seq = 0;\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_S) {\r\nns = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nnr = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nL2TP_SKB_CB(skb)->ns = ns;\r\nL2TP_SKB_CB(skb)->has_seq = 1;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: recv data ns=%u, nr=%u, session nr=%u\n",\r\nsession->name, ns, nr, session->nr);\r\n}\r\n} else if (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\r\nu32 l2h = ntohl(*(__be32 *) ptr);\r\nif (l2h & 0x40000000) {\r\nns = l2h & 0x00ffffff;\r\nL2TP_SKB_CB(skb)->ns = ns;\r\nL2TP_SKB_CB(skb)->has_seq = 1;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: recv data ns=%u, session nr=%u\n",\r\nsession->name, ns, session->nr);\r\n}\r\n}\r\nptr += session->l2specific_len;\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif ((!session->lns_mode) && (!session->send_seq)) {\r\nl2tp_info(session, L2TP_MSG_SEQ,\r\n"%s: requested to enable seq numbers by LNS\n",\r\nsession->name);\r\nsession->send_seq = -1;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\n}\r\n} else {\r\nif (session->recv_seq) {\r\nl2tp_warn(session, L2TP_MSG_SEQ,\r\n"%s: recv data has no seq numbers when required. Discarding.\n",\r\nsession->name);\r\natomic_long_inc(&session->stats.rx_seq_discards);\r\ngoto discard;\r\n}\r\nif ((!session->lns_mode) && (session->send_seq)) {\r\nl2tp_info(session, L2TP_MSG_SEQ,\r\n"%s: requested to disable seq numbers by LNS\n",\r\nsession->name);\r\nsession->send_seq = 0;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\n} else if (session->send_seq) {\r\nl2tp_warn(session, L2TP_MSG_SEQ,\r\n"%s: recv data has no seq numbers when required. Discarding.\n",\r\nsession->name);\r\natomic_long_inc(&session->stats.rx_seq_discards);\r\ngoto discard;\r\n}\r\n}\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_O) {\r\noffset = ntohs(*(__be16 *)ptr);\r\nptr += 2 + offset;\r\n}\r\n} else\r\nptr += session->offset;\r\noffset = ptr - optr;\r\nif (!pskb_may_pull(skb, offset))\r\ngoto discard;\r\n__skb_pull(skb, offset);\r\nif (payload_hook)\r\nif ((*payload_hook)(skb))\r\ngoto discard;\r\nL2TP_SKB_CB(skb)->length = length;\r\nL2TP_SKB_CB(skb)->expires = jiffies +\r\n(session->reorder_timeout ? session->reorder_timeout : HZ);\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif (l2tp_recv_data_seq(session, skb))\r\ngoto discard;\r\n} else {\r\nskb_queue_tail(&session->reorder_q, skb);\r\n}\r\nl2tp_recv_dequeue(session);\r\nl2tp_session_dec_refcount(session);\r\nreturn;\r\ndiscard:\r\natomic_long_inc(&session->stats.rx_errors);\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\nl2tp_session_dec_refcount(session);\r\n}\r\nint l2tp_session_queue_purge(struct l2tp_session *session)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nBUG_ON(!session);\r\nBUG_ON(session->magic != L2TP_SESSION_MAGIC);\r\nwhile ((skb = skb_dequeue(&session->reorder_q))) {\r\natomic_long_inc(&session->stats.rx_errors);\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,\r\nint (*payload_hook)(struct sk_buff *skb))\r\n{\r\nstruct l2tp_session *session = NULL;\r\nunsigned char *ptr, *optr;\r\nu16 hdrflags;\r\nu32 tunnel_id, session_id;\r\nu16 version;\r\nint length;\r\n__skb_pull(skb, sizeof(struct udphdr));\r\nif (!pskb_may_pull(skb, L2TP_HDR_SIZE_SEQ)) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: recv short packet (len=%d)\n",\r\ntunnel->name, skb->len);\r\ngoto error;\r\n}\r\nif (tunnel->debug & L2TP_MSG_DATA) {\r\nlength = min(32u, skb->len);\r\nif (!pskb_may_pull(skb, length))\r\ngoto error;\r\npr_debug("%s: recv\n", tunnel->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET, skb->data, length);\r\n}\r\noptr = ptr = skb->data;\r\nhdrflags = ntohs(*(__be16 *) ptr);\r\nversion = hdrflags & L2TP_HDR_VER_MASK;\r\nif (version != tunnel->version) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: recv protocol version mismatch: got %d expected %d\n",\r\ntunnel->name, version, tunnel->version);\r\ngoto error;\r\n}\r\nlength = skb->len;\r\nif (hdrflags & L2TP_HDRFLAG_T) {\r\nl2tp_dbg(tunnel, L2TP_MSG_DATA,\r\n"%s: recv control packet, len=%d\n",\r\ntunnel->name, length);\r\ngoto error;\r\n}\r\nptr += 2;\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_L)\r\nptr += 2;\r\ntunnel_id = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nsession_id = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\n} else {\r\nptr += 2;\r\ntunnel_id = tunnel->tunnel_id;\r\nsession_id = ntohl(*(__be32 *) ptr);\r\nptr += 4;\r\n}\r\nsession = l2tp_session_find(tunnel->l2tp_net, tunnel, session_id);\r\nif (!session || !session->recv_skb) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: no session found (%u/%u). Passing up.\n",\r\ntunnel->name, tunnel_id, session_id);\r\ngoto error;\r\n}\r\nl2tp_recv_common(session, skb, ptr, optr, hdrflags, length, payload_hook);\r\nreturn 0;\r\nerror:\r\n__skb_push(skb, sizeof(struct udphdr));\r\nreturn 1;\r\n}\r\nint l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\ntunnel = l2tp_sock_to_tunnel(sk);\r\nif (tunnel == NULL)\r\ngoto pass_up;\r\nl2tp_dbg(tunnel, L2TP_MSG_DATA, "%s: received %d bytes\n",\r\ntunnel->name, skb->len);\r\nif (l2tp_udp_recv_core(tunnel, skb, tunnel->recv_payload_hook))\r\ngoto pass_up_put;\r\nsock_put(sk);\r\nreturn 0;\r\npass_up_put:\r\nsock_put(sk);\r\npass_up:\r\nreturn 1;\r\n}\r\nstatic int l2tp_build_l2tpv2_header(struct l2tp_session *session, void *buf)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\n__be16 *bufp = buf;\r\n__be16 *optr = buf;\r\nu16 flags = L2TP_HDR_VER_2;\r\nu32 tunnel_id = tunnel->peer_tunnel_id;\r\nu32 session_id = session->peer_session_id;\r\nif (session->send_seq)\r\nflags |= L2TP_HDRFLAG_S;\r\n*bufp++ = htons(flags);\r\n*bufp++ = htons(tunnel_id);\r\n*bufp++ = htons(session_id);\r\nif (session->send_seq) {\r\n*bufp++ = htons(session->ns);\r\n*bufp++ = 0;\r\nsession->ns++;\r\nsession->ns &= 0xffff;\r\nl2tp_dbg(session, L2TP_MSG_SEQ, "%s: updated ns to %u\n",\r\nsession->name, session->ns);\r\n}\r\nreturn bufp - optr;\r\n}\r\nstatic int l2tp_build_l2tpv3_header(struct l2tp_session *session, void *buf)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nchar *bufp = buf;\r\nchar *optr = bufp;\r\nif (tunnel->encap == L2TP_ENCAPTYPE_UDP) {\r\nu16 flags = L2TP_HDR_VER_3;\r\n*((__be16 *) bufp) = htons(flags);\r\nbufp += 2;\r\n*((__be16 *) bufp) = 0;\r\nbufp += 2;\r\n}\r\n*((__be32 *) bufp) = htonl(session->peer_session_id);\r\nbufp += 4;\r\nif (session->cookie_len) {\r\nmemcpy(bufp, &session->cookie[0], session->cookie_len);\r\nbufp += session->cookie_len;\r\n}\r\nif (session->l2specific_len) {\r\nif (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\r\nu32 l2h = 0;\r\nif (session->send_seq) {\r\nl2h = 0x40000000 | session->ns;\r\nsession->ns++;\r\nsession->ns &= 0xffffff;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: updated ns to %u\n",\r\nsession->name, session->ns);\r\n}\r\n*((__be32 *) bufp) = htonl(l2h);\r\n}\r\nbufp += session->l2specific_len;\r\n}\r\nif (session->offset)\r\nbufp += session->offset;\r\nreturn bufp - optr;\r\n}\r\nstatic int l2tp_xmit_core(struct l2tp_session *session, struct sk_buff *skb,\r\nstruct flowi *fl, size_t data_len)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nunsigned int len = skb->len;\r\nint error;\r\nif (session->send_seq)\r\nl2tp_dbg(session, L2TP_MSG_DATA, "%s: send %Zd bytes, ns=%u\n",\r\nsession->name, data_len, session->ns - 1);\r\nelse\r\nl2tp_dbg(session, L2TP_MSG_DATA, "%s: send %Zd bytes\n",\r\nsession->name, data_len);\r\nif (session->debug & L2TP_MSG_DATA) {\r\nint uhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nunsigned char *datap = skb->data + uhlen;\r\npr_debug("%s: xmit\n", session->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET,\r\ndatap, min_t(size_t, 32, len - uhlen));\r\n}\r\nskb->ignore_df = 1;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tunnel->sock->sk_family == PF_INET6 && !tunnel->v4mapped)\r\nerror = inet6_csk_xmit(tunnel->sock, skb, NULL);\r\nelse\r\n#endif\r\nerror = ip_queue_xmit(tunnel->sock, skb, fl);\r\nif (error >= 0) {\r\natomic_long_inc(&tunnel->stats.tx_packets);\r\natomic_long_add(len, &tunnel->stats.tx_bytes);\r\natomic_long_inc(&session->stats.tx_packets);\r\natomic_long_add(len, &session->stats.tx_bytes);\r\n} else {\r\natomic_long_inc(&tunnel->stats.tx_errors);\r\natomic_long_inc(&session->stats.tx_errors);\r\n}\r\nreturn 0;\r\n}\r\nint l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len)\r\n{\r\nint data_len = skb->len;\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nstruct sock *sk = tunnel->sock;\r\nstruct flowi *fl;\r\nstruct udphdr *uh;\r\nstruct inet_sock *inet;\r\nint headroom;\r\nint uhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nint udp_len;\r\nint ret = NET_XMIT_SUCCESS;\r\nheadroom = NET_SKB_PAD + sizeof(struct iphdr) +\r\nuhlen + hdr_len;\r\nif (skb_cow_head(skb, headroom)) {\r\nkfree_skb(skb);\r\nreturn NET_XMIT_DROP;\r\n}\r\nsession->build_header(session, __skb_push(skb, hdr_len));\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\r\nIPSKB_REROUTED);\r\nnf_reset(skb);\r\nbh_lock_sock(sk);\r\nif (sock_owned_by_user(sk)) {\r\nkfree_skb(skb);\r\nret = NET_XMIT_DROP;\r\ngoto out_unlock;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst_clone(__sk_dst_check(sk, 0)));\r\ninet = inet_sk(sk);\r\nfl = &inet->cork.fl;\r\nswitch (tunnel->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\n__skb_push(skb, sizeof(*uh));\r\nskb_reset_transport_header(skb);\r\nuh = udp_hdr(skb);\r\nuh->source = inet->inet_sport;\r\nuh->dest = inet->inet_dport;\r\nudp_len = uhlen + hdr_len + data_len;\r\nuh->len = htons(udp_len);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET6 && !tunnel->v4mapped)\r\nudp6_set_csum(udp_get_no_check6_tx(sk),\r\nskb, &inet6_sk(sk)->saddr,\r\n&sk->sk_v6_daddr, udp_len);\r\nelse\r\n#endif\r\nudp_set_csum(sk->sk_no_check_tx, skb, inet->inet_saddr,\r\ninet->inet_daddr, udp_len);\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nbreak;\r\n}\r\nl2tp_xmit_core(session, skb, fl, data_len);\r\nout_unlock:\r\nbh_unlock_sock(sk);\r\nreturn ret;\r\n}\r\nstatic void l2tp_tunnel_destruct(struct sock *sk)\r\n{\r\nstruct l2tp_tunnel *tunnel = l2tp_tunnel(sk);\r\nstruct l2tp_net *pn;\r\nif (tunnel == NULL)\r\ngoto end;\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: closing...\n", tunnel->name);\r\nswitch (tunnel->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\n(udp_sk(sk))->encap_type = 0;\r\n(udp_sk(sk))->encap_rcv = NULL;\r\n(udp_sk(sk))->encap_destroy = NULL;\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nbreak;\r\n}\r\nsk->sk_destruct = tunnel->old_sk_destruct;\r\nsk->sk_user_data = NULL;\r\ntunnel->sock = NULL;\r\npn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_tunnel_list_lock);\r\nlist_del_rcu(&tunnel->list);\r\nspin_unlock_bh(&pn->l2tp_tunnel_list_lock);\r\natomic_dec(&l2tp_tunnel_count);\r\nl2tp_tunnel_closeall(tunnel);\r\nl2tp_tunnel_dec_refcount(tunnel);\r\nif (sk->sk_destruct)\r\n(*sk->sk_destruct)(sk);\r\nend:\r\nreturn;\r\n}\r\nvoid l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\r\n{\r\nint hash;\r\nstruct hlist_node *walk;\r\nstruct hlist_node *tmp;\r\nstruct l2tp_session *session;\r\nBUG_ON(tunnel == NULL);\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: closing all sessions...\n",\r\ntunnel->name);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\r\nagain:\r\nhlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\r\nsession = hlist_entry(walk, struct l2tp_session, hlist);\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: closing session\n", session->name);\r\nhlist_del_init(&session->hlist);\r\nif (session->ref != NULL)\r\n(*session->ref)(session);\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\n__l2tp_session_unhash(session);\r\nl2tp_session_queue_purge(session);\r\nif (session->session_close != NULL)\r\n(*session->session_close)(session);\r\nif (session->deref != NULL)\r\n(*session->deref)(session);\r\nl2tp_session_dec_refcount(session);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\ngoto again;\r\n}\r\n}\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\n}\r\nstatic void l2tp_udp_encap_destroy(struct sock *sk)\r\n{\r\nstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\r\nif (tunnel) {\r\nl2tp_tunnel_closeall(tunnel);\r\nsock_put(sk);\r\n}\r\n}\r\nstatic void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)\r\n{\r\nBUG_ON(atomic_read(&tunnel->ref_count) != 0);\r\nBUG_ON(tunnel->sock != NULL);\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: free...\n", tunnel->name);\r\nkfree_rcu(tunnel, rcu);\r\n}\r\nstatic void l2tp_tunnel_del_work(struct work_struct *work)\r\n{\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nstruct socket *sock = NULL;\r\nstruct sock *sk = NULL;\r\ntunnel = container_of(work, struct l2tp_tunnel, del_work);\r\nsk = l2tp_tunnel_sock_lookup(tunnel);\r\nif (!sk)\r\nreturn;\r\nsock = sk->sk_socket;\r\nif (tunnel->fd >= 0) {\r\nif (sock)\r\ninet_shutdown(sock, 2);\r\n} else {\r\nif (sock)\r\nkernel_sock_shutdown(sock, SHUT_RDWR);\r\nsk_release_kernel(sk);\r\n}\r\nl2tp_tunnel_sock_put(sk);\r\n}\r\nstatic int l2tp_tunnel_sock_create(struct net *net,\r\nu32 tunnel_id,\r\nu32 peer_tunnel_id,\r\nstruct l2tp_tunnel_cfg *cfg,\r\nstruct socket **sockp)\r\n{\r\nint err = -EINVAL;\r\nstruct socket *sock = NULL;\r\nstruct udp_port_cfg udp_conf;\r\nswitch (cfg->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\nmemset(&udp_conf, 0, sizeof(udp_conf));\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (cfg->local_ip6 && cfg->peer_ip6) {\r\nudp_conf.family = AF_INET6;\r\nmemcpy(&udp_conf.local_ip6, cfg->local_ip6,\r\nsizeof(udp_conf.local_ip6));\r\nmemcpy(&udp_conf.peer_ip6, cfg->peer_ip6,\r\nsizeof(udp_conf.peer_ip6));\r\nudp_conf.use_udp6_tx_checksums =\r\ncfg->udp6_zero_tx_checksums;\r\nudp_conf.use_udp6_rx_checksums =\r\ncfg->udp6_zero_rx_checksums;\r\n} else\r\n#endif\r\n{\r\nudp_conf.family = AF_INET;\r\nudp_conf.local_ip = cfg->local_ip;\r\nudp_conf.peer_ip = cfg->peer_ip;\r\nudp_conf.use_udp_checksums = cfg->use_udp_checksums;\r\n}\r\nudp_conf.local_udp_port = htons(cfg->local_udp_port);\r\nudp_conf.peer_udp_port = htons(cfg->peer_udp_port);\r\nerr = udp_sock_create(net, &udp_conf, &sock);\r\nif (err < 0)\r\ngoto out;\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (cfg->local_ip6 && cfg->peer_ip6) {\r\nstruct sockaddr_l2tpip6 ip6_addr = {0};\r\nerr = sock_create_kern(AF_INET6, SOCK_DGRAM,\r\nIPPROTO_L2TP, &sock);\r\nif (err < 0)\r\ngoto out;\r\nsk_change_net(sock->sk, net);\r\nip6_addr.l2tp_family = AF_INET6;\r\nmemcpy(&ip6_addr.l2tp_addr, cfg->local_ip6,\r\nsizeof(ip6_addr.l2tp_addr));\r\nip6_addr.l2tp_conn_id = tunnel_id;\r\nerr = kernel_bind(sock, (struct sockaddr *) &ip6_addr,\r\nsizeof(ip6_addr));\r\nif (err < 0)\r\ngoto out;\r\nip6_addr.l2tp_family = AF_INET6;\r\nmemcpy(&ip6_addr.l2tp_addr, cfg->peer_ip6,\r\nsizeof(ip6_addr.l2tp_addr));\r\nip6_addr.l2tp_conn_id = peer_tunnel_id;\r\nerr = kernel_connect(sock,\r\n(struct sockaddr *) &ip6_addr,\r\nsizeof(ip6_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n} else\r\n#endif\r\n{\r\nstruct sockaddr_l2tpip ip_addr = {0};\r\nerr = sock_create_kern(AF_INET, SOCK_DGRAM,\r\nIPPROTO_L2TP, &sock);\r\nif (err < 0)\r\ngoto out;\r\nsk_change_net(sock->sk, net);\r\nip_addr.l2tp_family = AF_INET;\r\nip_addr.l2tp_addr = cfg->local_ip;\r\nip_addr.l2tp_conn_id = tunnel_id;\r\nerr = kernel_bind(sock, (struct sockaddr *) &ip_addr,\r\nsizeof(ip_addr));\r\nif (err < 0)\r\ngoto out;\r\nip_addr.l2tp_family = AF_INET;\r\nip_addr.l2tp_addr = cfg->peer_ip;\r\nip_addr.l2tp_conn_id = peer_tunnel_id;\r\nerr = kernel_connect(sock, (struct sockaddr *) &ip_addr,\r\nsizeof(ip_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nout:\r\n*sockp = sock;\r\nif ((err < 0) && sock) {\r\nkernel_sock_shutdown(sock, SHUT_RDWR);\r\nsk_release_kernel(sock->sk);\r\n*sockp = NULL;\r\n}\r\nreturn err;\r\n}\r\nint l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp)\r\n{\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nint err;\r\nstruct socket *sock = NULL;\r\nstruct sock *sk = NULL;\r\nstruct l2tp_net *pn;\r\nenum l2tp_encap_type encap = L2TP_ENCAPTYPE_UDP;\r\nif (fd < 0) {\r\nerr = l2tp_tunnel_sock_create(net, tunnel_id, peer_tunnel_id,\r\ncfg, &sock);\r\nif (err < 0)\r\ngoto err;\r\n} else {\r\nsock = sockfd_lookup(fd, &err);\r\nif (!sock) {\r\npr_err("tunl %u: sockfd_lookup(fd=%d) returned %d\n",\r\ntunnel_id, fd, err);\r\nerr = -EBADF;\r\ngoto err;\r\n}\r\nif (!net_eq(sock_net(sock->sk), net)) {\r\npr_err("tunl %u: netns mismatch\n", tunnel_id);\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nsk = sock->sk;\r\nif (cfg != NULL)\r\nencap = cfg->encap;\r\nswitch (encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\nerr = -EPROTONOSUPPORT;\r\nif (sk->sk_protocol != IPPROTO_UDP) {\r\npr_err("tunl %hu: fd %d wrong protocol, got %d, expected %d\n",\r\ntunnel_id, fd, sk->sk_protocol, IPPROTO_UDP);\r\ngoto err;\r\n}\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nerr = -EPROTONOSUPPORT;\r\nif (sk->sk_protocol != IPPROTO_L2TP) {\r\npr_err("tunl %hu: fd %d wrong protocol, got %d, expected %d\n",\r\ntunnel_id, fd, sk->sk_protocol, IPPROTO_L2TP);\r\ngoto err;\r\n}\r\nbreak;\r\n}\r\ntunnel = l2tp_tunnel(sk);\r\nif (tunnel != NULL) {\r\nerr = -EBUSY;\r\ngoto err;\r\n}\r\ntunnel = kzalloc(sizeof(struct l2tp_tunnel), GFP_KERNEL);\r\nif (tunnel == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ntunnel->version = version;\r\ntunnel->tunnel_id = tunnel_id;\r\ntunnel->peer_tunnel_id = peer_tunnel_id;\r\ntunnel->debug = L2TP_DEFAULT_DEBUG_FLAGS;\r\ntunnel->magic = L2TP_TUNNEL_MAGIC;\r\nsprintf(&tunnel->name[0], "tunl %u", tunnel_id);\r\nrwlock_init(&tunnel->hlist_lock);\r\ntunnel->l2tp_net = net;\r\npn = l2tp_pernet(net);\r\nif (cfg != NULL)\r\ntunnel->debug = cfg->debug;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET6) {\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nif (ipv6_addr_v4mapped(&np->saddr) &&\r\nipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\ntunnel->v4mapped = true;\r\ninet->inet_saddr = np->saddr.s6_addr32[3];\r\ninet->inet_rcv_saddr = sk->sk_v6_rcv_saddr.s6_addr32[3];\r\ninet->inet_daddr = sk->sk_v6_daddr.s6_addr32[3];\r\n} else {\r\ntunnel->v4mapped = false;\r\n}\r\n}\r\n#endif\r\ntunnel->encap = encap;\r\nif (encap == L2TP_ENCAPTYPE_UDP) {\r\nstruct udp_tunnel_sock_cfg udp_cfg;\r\nudp_cfg.sk_user_data = tunnel;\r\nudp_cfg.encap_type = UDP_ENCAP_L2TPINUDP;\r\nudp_cfg.encap_rcv = l2tp_udp_encap_recv;\r\nudp_cfg.encap_destroy = l2tp_udp_encap_destroy;\r\nsetup_udp_tunnel_sock(net, sock, &udp_cfg);\r\n} else {\r\nsk->sk_user_data = tunnel;\r\n}\r\ntunnel->old_sk_destruct = sk->sk_destruct;\r\nsk->sk_destruct = &l2tp_tunnel_destruct;\r\ntunnel->sock = sk;\r\ntunnel->fd = fd;\r\nlockdep_set_class_and_name(&sk->sk_lock.slock, &l2tp_socket_class, "l2tp_sock");\r\nsk->sk_allocation = GFP_ATOMIC;\r\nINIT_WORK(&tunnel->del_work, l2tp_tunnel_del_work);\r\nINIT_LIST_HEAD(&tunnel->list);\r\natomic_inc(&l2tp_tunnel_count);\r\nl2tp_tunnel_inc_refcount(tunnel);\r\nspin_lock_bh(&pn->l2tp_tunnel_list_lock);\r\nlist_add_rcu(&tunnel->list, &pn->l2tp_tunnel_list);\r\nspin_unlock_bh(&pn->l2tp_tunnel_list_lock);\r\nerr = 0;\r\nerr:\r\nif (tunnelp)\r\n*tunnelp = tunnel;\r\nif (sock && sock->file)\r\nsockfd_put(sock);\r\nreturn err;\r\n}\r\nint l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)\r\n{\r\nl2tp_tunnel_closeall(tunnel);\r\nreturn (false == queue_work(l2tp_wq, &tunnel->del_work));\r\n}\r\nvoid l2tp_session_free(struct l2tp_session *session)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nBUG_ON(atomic_read(&session->ref_count) != 0);\r\nif (tunnel) {\r\nBUG_ON(tunnel->magic != L2TP_TUNNEL_MAGIC);\r\nif (session->session_id != 0)\r\natomic_dec(&l2tp_session_count);\r\nsock_put(tunnel->sock);\r\nsession->tunnel = NULL;\r\nl2tp_tunnel_dec_refcount(tunnel);\r\n}\r\nkfree(session);\r\n}\r\nvoid __l2tp_session_unhash(struct l2tp_session *session)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nif (tunnel) {\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nhlist_del_init(&session->hlist);\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\nif (tunnel->version != L2TP_HDR_VER_2) {\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_session_hlist_lock);\r\nhlist_del_init_rcu(&session->global_hlist);\r\nspin_unlock_bh(&pn->l2tp_session_hlist_lock);\r\nsynchronize_rcu();\r\n}\r\n}\r\n}\r\nint l2tp_session_delete(struct l2tp_session *session)\r\n{\r\nif (session->ref)\r\n(*session->ref)(session);\r\n__l2tp_session_unhash(session);\r\nl2tp_session_queue_purge(session);\r\nif (session->session_close != NULL)\r\n(*session->session_close)(session);\r\nif (session->deref)\r\n(*session->deref)(session);\r\nl2tp_session_dec_refcount(session);\r\nreturn 0;\r\n}\r\nvoid l2tp_session_set_header_len(struct l2tp_session *session, int version)\r\n{\r\nif (version == L2TP_HDR_VER_2) {\r\nsession->hdr_len = 6;\r\nif (session->send_seq)\r\nsession->hdr_len += 4;\r\n} else {\r\nsession->hdr_len = 4 + session->cookie_len + session->l2specific_len + session->offset;\r\nif (session->tunnel->encap == L2TP_ENCAPTYPE_UDP)\r\nsession->hdr_len += 4;\r\n}\r\n}\r\nstruct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\r\n{\r\nstruct l2tp_session *session;\r\nsession = kzalloc(sizeof(struct l2tp_session) + priv_size, GFP_KERNEL);\r\nif (session != NULL) {\r\nsession->magic = L2TP_SESSION_MAGIC;\r\nsession->tunnel = tunnel;\r\nsession->session_id = session_id;\r\nsession->peer_session_id = peer_session_id;\r\nsession->nr = 0;\r\nif (tunnel->version == L2TP_HDR_VER_2)\r\nsession->nr_max = 0xffff;\r\nelse\r\nsession->nr_max = 0xffffff;\r\nsession->nr_window_size = session->nr_max / 2;\r\nsession->nr_oos_count_max = 4;\r\nsession->reorder_skip = 1;\r\nsprintf(&session->name[0], "sess %u/%u",\r\ntunnel->tunnel_id, session->session_id);\r\nskb_queue_head_init(&session->reorder_q);\r\nINIT_HLIST_NODE(&session->hlist);\r\nINIT_HLIST_NODE(&session->global_hlist);\r\nsession->debug = tunnel->debug;\r\nif (cfg) {\r\nsession->pwtype = cfg->pw_type;\r\nsession->debug = cfg->debug;\r\nsession->mtu = cfg->mtu;\r\nsession->mru = cfg->mru;\r\nsession->send_seq = cfg->send_seq;\r\nsession->recv_seq = cfg->recv_seq;\r\nsession->lns_mode = cfg->lns_mode;\r\nsession->reorder_timeout = cfg->reorder_timeout;\r\nsession->offset = cfg->offset;\r\nsession->l2specific_type = cfg->l2specific_type;\r\nsession->l2specific_len = cfg->l2specific_len;\r\nsession->cookie_len = cfg->cookie_len;\r\nmemcpy(&session->cookie[0], &cfg->cookie[0], cfg->cookie_len);\r\nsession->peer_cookie_len = cfg->peer_cookie_len;\r\nmemcpy(&session->peer_cookie[0], &cfg->peer_cookie[0], cfg->peer_cookie_len);\r\n}\r\nif (tunnel->version == L2TP_HDR_VER_2)\r\nsession->build_header = l2tp_build_l2tpv2_header;\r\nelse\r\nsession->build_header = l2tp_build_l2tpv3_header;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\nl2tp_session_inc_refcount(session);\r\nl2tp_tunnel_inc_refcount(tunnel);\r\nsock_hold(tunnel->sock);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nhlist_add_head(&session->hlist,\r\nl2tp_session_id_hash(tunnel, session_id));\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\nif (tunnel->version != L2TP_HDR_VER_2) {\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_session_hlist_lock);\r\nhlist_add_head_rcu(&session->global_hlist,\r\nl2tp_session_id_hash_2(pn, session_id));\r\nspin_unlock_bh(&pn->l2tp_session_hlist_lock);\r\n}\r\nif (session->session_id != 0)\r\natomic_inc(&l2tp_session_count);\r\n}\r\nreturn session;\r\n}\r\nstatic __net_init int l2tp_init_net(struct net *net)\r\n{\r\nstruct l2tp_net *pn = net_generic(net, l2tp_net_id);\r\nint hash;\r\nINIT_LIST_HEAD(&pn->l2tp_tunnel_list);\r\nspin_lock_init(&pn->l2tp_tunnel_list_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++)\r\nINIT_HLIST_HEAD(&pn->l2tp_session_hlist[hash]);\r\nspin_lock_init(&pn->l2tp_session_hlist_lock);\r\nreturn 0;\r\n}\r\nstatic __net_exit void l2tp_exit_net(struct net *net)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nrcu_read_lock_bh();\r\nlist_for_each_entry_rcu(tunnel, &pn->l2tp_tunnel_list, list) {\r\n(void)l2tp_tunnel_delete(tunnel);\r\n}\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int __init l2tp_init(void)\r\n{\r\nint rc = 0;\r\nrc = register_pernet_device(&l2tp_net_ops);\r\nif (rc)\r\ngoto out;\r\nl2tp_wq = alloc_workqueue("l2tp", WQ_UNBOUND, 0);\r\nif (!l2tp_wq) {\r\npr_err("alloc_workqueue failed\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npr_info("L2TP core driver, %s\n", L2TP_DRV_VERSION);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit l2tp_exit(void)\r\n{\r\nunregister_pernet_device(&l2tp_net_ops);\r\nif (l2tp_wq) {\r\ndestroy_workqueue(l2tp_wq);\r\nl2tp_wq = NULL;\r\n}\r\n}
