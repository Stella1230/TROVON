static int vhci_open_dev(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int vhci_close_dev(struct hci_dev *hdev)\r\n{\r\nstruct vhci_data *data = hci_get_drvdata(hdev);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nskb_queue_purge(&data->readq);\r\nreturn 0;\r\n}\r\nstatic int vhci_flush(struct hci_dev *hdev)\r\n{\r\nstruct vhci_data *data = hci_get_drvdata(hdev);\r\nskb_queue_purge(&data->readq);\r\nreturn 0;\r\n}\r\nstatic int vhci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct vhci_data *data = hci_get_drvdata(hdev);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&data->readq, skb);\r\nwake_up_interruptible(&data->read_wait);\r\nreturn 0;\r\n}\r\nstatic int vhci_create_device(struct vhci_data *data, __u8 opcode)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct sk_buff *skb;\r\n__u8 dev_type;\r\ndev_type = opcode & 0x03;\r\nif (dev_type != HCI_BREDR && dev_type != HCI_AMP)\r\nreturn -EINVAL;\r\nif (opcode & 0x3c)\r\nreturn -EINVAL;\r\nskb = bt_skb_alloc(4, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\ndata->hdev = hdev;\r\nhdev->bus = HCI_VIRTUAL;\r\nhdev->dev_type = dev_type;\r\nhci_set_drvdata(hdev, data);\r\nhdev->open = vhci_open_dev;\r\nhdev->close = vhci_close_dev;\r\nhdev->flush = vhci_flush;\r\nhdev->send = vhci_send_frame;\r\nif (opcode & 0x40)\r\nset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\r\nif (opcode & 0x80)\r\nset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hdev);\r\ndata->hdev = NULL;\r\nkfree_skb(skb);\r\nreturn -EBUSY;\r\n}\r\nbt_cb(skb)->pkt_type = HCI_VENDOR_PKT;\r\n*skb_put(skb, 1) = 0xff;\r\n*skb_put(skb, 1) = opcode;\r\nput_unaligned_le16(hdev->id, skb_put(skb, 2));\r\nskb_queue_tail(&data->readq, skb);\r\nwake_up_interruptible(&data->read_wait);\r\nreturn 0;\r\n}\r\nstatic inline ssize_t vhci_get_user(struct vhci_data *data,\r\nstruct iov_iter *from)\r\n{\r\nsize_t len = iov_iter_count(from);\r\nstruct sk_buff *skb;\r\n__u8 pkt_type, opcode;\r\nint ret;\r\nif (len < 2 || len > HCI_MAX_FRAME_SIZE)\r\nreturn -EINVAL;\r\nskb = bt_skb_alloc(len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (copy_from_iter(skb_put(skb, len), len, from) != len) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\npkt_type = *((__u8 *) skb->data);\r\nskb_pull(skb, 1);\r\nswitch (pkt_type) {\r\ncase HCI_EVENT_PKT:\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_SCODATA_PKT:\r\nif (!data->hdev) {\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\nbt_cb(skb)->pkt_type = pkt_type;\r\nret = hci_recv_frame(data->hdev, skb);\r\nbreak;\r\ncase HCI_VENDOR_PKT:\r\nif (data->hdev) {\r\nkfree_skb(skb);\r\nreturn -EBADFD;\r\n}\r\ncancel_delayed_work_sync(&data->open_timeout);\r\nopcode = *((__u8 *) skb->data);\r\nskb_pull(skb, 1);\r\nif (skb->len > 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nkfree_skb(skb);\r\nret = vhci_create_device(data, opcode);\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nreturn (ret < 0) ? ret : len;\r\n}\r\nstatic inline ssize_t vhci_put_user(struct vhci_data *data,\r\nstruct sk_buff *skb,\r\nchar __user *buf, int count)\r\n{\r\nchar __user *ptr = buf;\r\nint len;\r\nlen = min_t(unsigned int, skb->len, count);\r\nif (copy_to_user(ptr, skb->data, len))\r\nreturn -EFAULT;\r\nif (!data->hdev)\r\nreturn len;\r\ndata->hdev->stat.byte_tx += len;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\ndata->hdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ndata->hdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\ndata->hdev->stat.sco_tx++;\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t vhci_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *pos)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\nstruct sk_buff *skb;\r\nssize_t ret = 0;\r\nwhile (count) {\r\nskb = skb_dequeue(&data->readq);\r\nif (skb) {\r\nret = vhci_put_user(data, skb, buf, count);\r\nif (ret < 0)\r\nskb_queue_head(&data->readq, skb);\r\nelse\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nret = wait_event_interruptible(data->read_wait,\r\n!skb_queue_empty(&data->readq));\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t vhci_write(struct kiocb *iocb, struct iov_iter *from)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nstruct vhci_data *data = file->private_data;\r\nreturn vhci_get_user(data, from);\r\n}\r\nstatic unsigned int vhci_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\npoll_wait(file, &data->read_wait, wait);\r\nif (!skb_queue_empty(&data->readq))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn POLLOUT | POLLWRNORM;\r\n}\r\nstatic void vhci_open_timeout(struct work_struct *work)\r\n{\r\nstruct vhci_data *data = container_of(work, struct vhci_data,\r\nopen_timeout.work);\r\nvhci_create_device(data, amp ? HCI_AMP : HCI_BREDR);\r\n}\r\nstatic int vhci_open(struct inode *inode, struct file *file)\r\n{\r\nstruct vhci_data *data;\r\ndata = kzalloc(sizeof(struct vhci_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&data->readq);\r\ninit_waitqueue_head(&data->read_wait);\r\nINIT_DELAYED_WORK(&data->open_timeout, vhci_open_timeout);\r\nfile->private_data = data;\r\nnonseekable_open(inode, file);\r\nschedule_delayed_work(&data->open_timeout, msecs_to_jiffies(1000));\r\nreturn 0;\r\n}\r\nstatic int vhci_release(struct inode *inode, struct file *file)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\nstruct hci_dev *hdev = data->hdev;\r\ncancel_delayed_work_sync(&data->open_timeout);\r\nif (hdev) {\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\n}\r\nfile->private_data = NULL;\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init vhci_init(void)\r\n{\r\nBT_INFO("Virtual HCI driver ver %s", VERSION);\r\nreturn misc_register(&vhci_miscdev);\r\n}\r\nstatic void __exit vhci_exit(void)\r\n{\r\nmisc_deregister(&vhci_miscdev);\r\n}
