static int get_bridge_ifindices(struct net *net, int *indices, int num)\r\n{\r\nstruct net_device *dev;\r\nint i = 0;\r\nfor_each_netdev(net, dev) {\r\nif (i >= num)\r\nbreak;\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nindices[i++] = dev->ifindex;\r\n}\r\nreturn i;\r\n}\r\nstatic void get_port_ifindices(struct net_bridge *br, int *ifindices, int num)\r\n{\r\nstruct net_bridge_port *p;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (p->port_no < num)\r\nifindices[p->port_no] = p->dev->ifindex;\r\n}\r\n}\r\nstatic int get_fdb_entries(struct net_bridge *br, void __user *userbuf,\r\nunsigned long maxnum, unsigned long offset)\r\n{\r\nint num;\r\nvoid *buf;\r\nsize_t size;\r\nif (maxnum > PAGE_SIZE/sizeof(struct __fdb_entry))\r\nmaxnum = PAGE_SIZE/sizeof(struct __fdb_entry);\r\nsize = maxnum * sizeof(struct __fdb_entry);\r\nbuf = kmalloc(size, GFP_USER);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nnum = br_fdb_fillbuf(br, buf, maxnum, offset);\r\nif (num > 0) {\r\nif (copy_to_user(userbuf, buf, num*sizeof(struct __fdb_entry)))\r\nnum = -EFAULT;\r\n}\r\nkfree(buf);\r\nreturn num;\r\n}\r\nstatic int add_del_if(struct net_bridge *br, int ifindex, int isadd)\r\n{\r\nstruct net *net = dev_net(br->dev);\r\nstruct net_device *dev;\r\nint ret;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (dev == NULL)\r\nreturn -EINVAL;\r\nif (isadd)\r\nret = br_add_if(br, dev);\r\nelse\r\nret = br_del_if(br, dev);\r\nreturn ret;\r\n}\r\nstatic int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nunsigned long args[4];\r\nif (copy_from_user(args, rq->ifr_data, sizeof(args)))\r\nreturn -EFAULT;\r\nswitch (args[0]) {\r\ncase BRCTL_ADD_IF:\r\ncase BRCTL_DEL_IF:\r\nreturn add_del_if(br, args[1], args[0] == BRCTL_ADD_IF);\r\ncase BRCTL_GET_BRIDGE_INFO:\r\n{\r\nstruct __bridge_info b;\r\nmemset(&b, 0, sizeof(struct __bridge_info));\r\nrcu_read_lock();\r\nmemcpy(&b.designated_root, &br->designated_root, 8);\r\nmemcpy(&b.bridge_id, &br->bridge_id, 8);\r\nb.root_path_cost = br->root_path_cost;\r\nb.max_age = jiffies_to_clock_t(br->max_age);\r\nb.hello_time = jiffies_to_clock_t(br->hello_time);\r\nb.forward_delay = br->forward_delay;\r\nb.bridge_max_age = br->bridge_max_age;\r\nb.bridge_hello_time = br->bridge_hello_time;\r\nb.bridge_forward_delay = jiffies_to_clock_t(br->bridge_forward_delay);\r\nb.topology_change = br->topology_change;\r\nb.topology_change_detected = br->topology_change_detected;\r\nb.root_port = br->root_port;\r\nb.stp_enabled = (br->stp_enabled != BR_NO_STP);\r\nb.ageing_time = jiffies_to_clock_t(br->ageing_time);\r\nb.hello_timer_value = br_timer_value(&br->hello_timer);\r\nb.tcn_timer_value = br_timer_value(&br->tcn_timer);\r\nb.topology_change_timer_value = br_timer_value(&br->topology_change_timer);\r\nb.gc_timer_value = br_timer_value(&br->gc_timer);\r\nrcu_read_unlock();\r\nif (copy_to_user((void __user *)args[1], &b, sizeof(b)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase BRCTL_GET_PORT_LIST:\r\n{\r\nint num, *indices;\r\nnum = args[2];\r\nif (num < 0)\r\nreturn -EINVAL;\r\nif (num == 0)\r\nnum = 256;\r\nif (num > BR_MAX_PORTS)\r\nnum = BR_MAX_PORTS;\r\nindices = kcalloc(num, sizeof(int), GFP_KERNEL);\r\nif (indices == NULL)\r\nreturn -ENOMEM;\r\nget_port_ifindices(br, indices, num);\r\nif (copy_to_user((void __user *)args[1], indices, num*sizeof(int)))\r\nnum = -EFAULT;\r\nkfree(indices);\r\nreturn num;\r\n}\r\ncase BRCTL_SET_BRIDGE_FORWARD_DELAY:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn br_set_forward_delay(br, args[1]);\r\ncase BRCTL_SET_BRIDGE_HELLO_TIME:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn br_set_hello_time(br, args[1]);\r\ncase BRCTL_SET_BRIDGE_MAX_AGE:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn br_set_max_age(br, args[1]);\r\ncase BRCTL_SET_AGEING_TIME:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbr->ageing_time = clock_t_to_jiffies(args[1]);\r\nreturn 0;\r\ncase BRCTL_GET_PORT_INFO:\r\n{\r\nstruct __port_info p;\r\nstruct net_bridge_port *pt;\r\nrcu_read_lock();\r\nif ((pt = br_get_port(br, args[2])) == NULL) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nmemset(&p, 0, sizeof(struct __port_info));\r\nmemcpy(&p.designated_root, &pt->designated_root, 8);\r\nmemcpy(&p.designated_bridge, &pt->designated_bridge, 8);\r\np.port_id = pt->port_id;\r\np.designated_port = pt->designated_port;\r\np.path_cost = pt->path_cost;\r\np.designated_cost = pt->designated_cost;\r\np.state = pt->state;\r\np.top_change_ack = pt->topology_change_ack;\r\np.config_pending = pt->config_pending;\r\np.message_age_timer_value = br_timer_value(&pt->message_age_timer);\r\np.forward_delay_timer_value = br_timer_value(&pt->forward_delay_timer);\r\np.hold_timer_value = br_timer_value(&pt->hold_timer);\r\nrcu_read_unlock();\r\nif (copy_to_user((void __user *)args[1], &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase BRCTL_SET_BRIDGE_STP_STATE:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbr_stp_set_enabled(br, args[1]);\r\nreturn 0;\r\ncase BRCTL_SET_BRIDGE_PRIORITY:\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_bh(&br->lock);\r\nbr_stp_set_bridge_priority(br, args[1]);\r\nspin_unlock_bh(&br->lock);\r\nreturn 0;\r\ncase BRCTL_SET_PORT_PRIORITY:\r\n{\r\nstruct net_bridge_port *p;\r\nint ret;\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_bh(&br->lock);\r\nif ((p = br_get_port(br, args[1])) == NULL)\r\nret = -EINVAL;\r\nelse\r\nret = br_stp_set_port_priority(p, args[2]);\r\nspin_unlock_bh(&br->lock);\r\nreturn ret;\r\n}\r\ncase BRCTL_SET_PATH_COST:\r\n{\r\nstruct net_bridge_port *p;\r\nint ret;\r\nif (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_bh(&br->lock);\r\nif ((p = br_get_port(br, args[1])) == NULL)\r\nret = -EINVAL;\r\nelse\r\nret = br_stp_set_path_cost(p, args[2]);\r\nspin_unlock_bh(&br->lock);\r\nreturn ret;\r\n}\r\ncase BRCTL_GET_FDB_ENTRIES:\r\nreturn get_fdb_entries(br, (void __user *)args[1],\r\nargs[2], args[3]);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int old_deviceless(struct net *net, void __user *uarg)\r\n{\r\nunsigned long args[3];\r\nif (copy_from_user(args, uarg, sizeof(args)))\r\nreturn -EFAULT;\r\nswitch (args[0]) {\r\ncase BRCTL_GET_VERSION:\r\nreturn BRCTL_VERSION;\r\ncase BRCTL_GET_BRIDGES:\r\n{\r\nint *indices;\r\nint ret = 0;\r\nif (args[2] >= 2048)\r\nreturn -ENOMEM;\r\nindices = kcalloc(args[2], sizeof(int), GFP_KERNEL);\r\nif (indices == NULL)\r\nreturn -ENOMEM;\r\nargs[2] = get_bridge_ifindices(net, indices, args[2]);\r\nret = copy_to_user((void __user *)args[1], indices, args[2]*sizeof(int))\r\n? -EFAULT : args[2];\r\nkfree(indices);\r\nreturn ret;\r\n}\r\ncase BRCTL_ADD_BRIDGE:\r\ncase BRCTL_DEL_BRIDGE:\r\n{\r\nchar buf[IFNAMSIZ];\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(buf, (void __user *)args[1], IFNAMSIZ))\r\nreturn -EFAULT;\r\nbuf[IFNAMSIZ-1] = 0;\r\nif (args[0] == BRCTL_ADD_BRIDGE)\r\nreturn br_add_bridge(net, buf);\r\nreturn br_del_bridge(net, buf);\r\n}\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nint br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *uarg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGIFBR:\r\ncase SIOCSIFBR:\r\nreturn old_deviceless(net, uarg);\r\ncase SIOCBRADDBR:\r\ncase SIOCBRDELBR:\r\n{\r\nchar buf[IFNAMSIZ];\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(buf, uarg, IFNAMSIZ))\r\nreturn -EFAULT;\r\nbuf[IFNAMSIZ-1] = 0;\r\nif (cmd == SIOCBRADDBR)\r\nreturn br_add_bridge(net, buf);\r\nreturn br_del_bridge(net, buf);\r\n}\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nint br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nswitch (cmd) {\r\ncase SIOCDEVPRIVATE:\r\nreturn old_dev_ioctl(dev, rq, cmd);\r\ncase SIOCBRADDIF:\r\ncase SIOCBRDELIF:\r\nreturn add_del_if(br, rq->ifr_ifindex, cmd == SIOCBRADDIF);\r\n}\r\nbr_debug(br, "Bridge does not support ioctl 0x%x\n", cmd);\r\nreturn -EOPNOTSUPP;\r\n}
