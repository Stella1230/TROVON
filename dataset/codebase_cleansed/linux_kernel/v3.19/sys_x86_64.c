static unsigned long get_align_mask(void)\r\n{\r\nif (va_align.flags < 0 || !(va_align.flags & (2 - mmap_is_ia32())))\r\nreturn 0;\r\nif (!(current->flags & PF_RANDOMIZE))\r\nreturn 0;\r\nreturn va_align.mask;\r\n}\r\nunsigned long align_vdso_addr(unsigned long addr)\r\n{\r\nunsigned long align_mask = get_align_mask();\r\nreturn (addr + align_mask) & ~align_mask;\r\n}\r\nstatic int __init control_va_addr_alignment(char *str)\r\n{\r\nif (va_align.flags < 0)\r\nreturn 1;\r\nif (*str == 0)\r\nreturn 1;\r\nif (*str == '=')\r\nstr++;\r\nif (!strcmp(str, "32"))\r\nva_align.flags = ALIGN_VA_32;\r\nelse if (!strcmp(str, "64"))\r\nva_align.flags = ALIGN_VA_64;\r\nelse if (!strcmp(str, "off"))\r\nva_align.flags = 0;\r\nelse if (!strcmp(str, "on"))\r\nva_align.flags = ALIGN_VA_32 | ALIGN_VA_64;\r\nelse\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void find_start_end(unsigned long flags, unsigned long *begin,\r\nunsigned long *end)\r\n{\r\nif (!test_thread_flag(TIF_ADDR32) && (flags & MAP_32BIT)) {\r\nunsigned long new_begin;\r\n*begin = 0x40000000;\r\n*end = 0x80000000;\r\nif (current->flags & PF_RANDOMIZE) {\r\nnew_begin = randomize_range(*begin, *begin + 0x02000000, 0);\r\nif (new_begin)\r\n*begin = new_begin;\r\n}\r\n} else {\r\n*begin = current->mm->mmap_legacy_base;\r\n*end = TASK_SIZE;\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area(struct file *filp, unsigned long addr,\r\nunsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nstruct vm_unmapped_area_info info;\r\nunsigned long begin, end;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nfind_start_end(flags, &begin, &end);\r\nif (len > end)\r\nreturn -ENOMEM;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (end - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\ninfo.flags = 0;\r\ninfo.length = len;\r\ninfo.low_limit = begin;\r\ninfo.high_limit = end;\r\ninfo.align_mask = filp ? get_align_mask() : 0;\r\ninfo.align_offset = pgoff << PAGE_SHIFT;\r\nreturn vm_unmapped_area(&info);\r\n}\r\nunsigned long\r\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\r\nconst unsigned long len, const unsigned long pgoff,\r\nconst unsigned long flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr = addr0;\r\nstruct vm_unmapped_area_info info;\r\nif (len > TASK_SIZE)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nif (!test_thread_flag(TIF_ADDR32) && (flags & MAP_32BIT))\r\ngoto bottomup;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (TASK_SIZE - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\ninfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\r\ninfo.length = len;\r\ninfo.low_limit = PAGE_SIZE;\r\ninfo.high_limit = mm->mmap_base;\r\ninfo.align_mask = filp ? get_align_mask() : 0;\r\ninfo.align_offset = pgoff << PAGE_SHIFT;\r\naddr = vm_unmapped_area(&info);\r\nif (!(addr & ~PAGE_MASK))\r\nreturn addr;\r\nVM_BUG_ON(addr != -ENOMEM);\r\nbottomup:\r\nreturn arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\r\n}
