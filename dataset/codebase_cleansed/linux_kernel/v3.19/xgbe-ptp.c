static cycle_t xgbe_cc_read(const struct cyclecounter *cc)\r\n{\r\nstruct xgbe_prv_data *pdata = container_of(cc,\r\nstruct xgbe_prv_data,\r\ntstamp_cc);\r\nu64 nsec;\r\nnsec = pdata->hw_if.get_tstamp_time(pdata);\r\nreturn nsec;\r\n}\r\nstatic int xgbe_adjfreq(struct ptp_clock_info *info, s32 delta)\r\n{\r\nstruct xgbe_prv_data *pdata = container_of(info,\r\nstruct xgbe_prv_data,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 adjust;\r\nu32 addend, diff;\r\nunsigned int neg_adjust = 0;\r\nif (delta < 0) {\r\nneg_adjust = 1;\r\ndelta = -delta;\r\n}\r\nadjust = pdata->tstamp_addend;\r\nadjust *= delta;\r\ndiff = div_u64(adjust, 1000000000UL);\r\naddend = (neg_adjust) ? pdata->tstamp_addend - diff :\r\npdata->tstamp_addend + diff;\r\nspin_lock_irqsave(&pdata->tstamp_lock, flags);\r\npdata->hw_if.update_tstamp_addend(pdata, addend);\r\nspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xgbe_adjtime(struct ptp_clock_info *info, s64 delta)\r\n{\r\nstruct xgbe_prv_data *pdata = container_of(info,\r\nstruct xgbe_prv_data,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 nsec;\r\nspin_lock_irqsave(&pdata->tstamp_lock, flags);\r\nnsec = timecounter_read(&pdata->tstamp_tc);\r\nnsec += delta;\r\ntimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc, nsec);\r\nspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xgbe_gettime(struct ptp_clock_info *info, struct timespec *ts)\r\n{\r\nstruct xgbe_prv_data *pdata = container_of(info,\r\nstruct xgbe_prv_data,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 nsec;\r\nspin_lock_irqsave(&pdata->tstamp_lock, flags);\r\nnsec = timecounter_read(&pdata->tstamp_tc);\r\nspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\r\n*ts = ns_to_timespec(nsec);\r\nreturn 0;\r\n}\r\nstatic int xgbe_settime(struct ptp_clock_info *info, const struct timespec *ts)\r\n{\r\nstruct xgbe_prv_data *pdata = container_of(info,\r\nstruct xgbe_prv_data,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 nsec;\r\nnsec = timespec_to_ns(ts);\r\nspin_lock_irqsave(&pdata->tstamp_lock, flags);\r\ntimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc, nsec);\r\nspin_unlock_irqrestore(&pdata->tstamp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable(struct ptp_clock_info *info,\r\nstruct ptp_clock_request *request, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid xgbe_ptp_register(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ptp_clock_info *info = &pdata->ptp_clock_info;\r\nstruct ptp_clock *clock;\r\nstruct cyclecounter *cc = &pdata->tstamp_cc;\r\nu64 dividend;\r\nsnprintf(info->name, sizeof(info->name), "%s",\r\nnetdev_name(pdata->netdev));\r\ninfo->owner = THIS_MODULE;\r\ninfo->max_adj = clk_get_rate(pdata->ptpclk);\r\ninfo->adjfreq = xgbe_adjfreq;\r\ninfo->adjtime = xgbe_adjtime;\r\ninfo->gettime = xgbe_gettime;\r\ninfo->settime = xgbe_settime;\r\ninfo->enable = xgbe_enable;\r\nclock = ptp_clock_register(info, pdata->dev);\r\nif (IS_ERR(clock)) {\r\ndev_err(pdata->dev, "ptp_clock_register failed\n");\r\nreturn;\r\n}\r\npdata->ptp_clock = clock;\r\ndividend = 50000000;\r\ndividend <<= 32;\r\npdata->tstamp_addend = div_u64(dividend, clk_get_rate(pdata->ptpclk));\r\ncc->read = xgbe_cc_read;\r\ncc->mask = CLOCKSOURCE_MASK(64);\r\ncc->mult = 1;\r\ncc->shift = 0;\r\ntimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,\r\nktime_to_ns(ktime_get_real()));\r\nXGMAC_IOWRITE(pdata, MAC_TCR, 0);\r\npdata->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\npdata->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\n}\r\nvoid xgbe_ptp_unregister(struct xgbe_prv_data *pdata)\r\n{\r\nif (pdata->ptp_clock)\r\nptp_clock_unregister(pdata->ptp_clock);\r\n}
