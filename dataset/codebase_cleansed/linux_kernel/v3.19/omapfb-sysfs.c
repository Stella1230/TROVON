static ssize_t show_rotate_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ofbi->rotation_type);\r\n}\r\nstatic ssize_t store_rotate_type(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_mem_region *rg;\r\nint rot_type;\r\nint r;\r\nr = kstrtoint(buf, 0, &rot_type);\r\nif (r)\r\nreturn r;\r\nif (rot_type != OMAP_DSS_ROT_DMA && rot_type != OMAP_DSS_ROT_VRFB)\r\nreturn -EINVAL;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nr = 0;\r\nif (rot_type == ofbi->rotation_type)\r\ngoto out;\r\nrg = omapfb_get_mem_region(ofbi->region);\r\nif (rg->size) {\r\nr = -EBUSY;\r\ngoto put_region;\r\n}\r\nofbi->rotation_type = rot_type;\r\nput_region:\r\nomapfb_put_mem_region(rg);\r\nout:\r\nunlock_fb_info(fbi);\r\nreturn r ? r : count;\r\n}\r\nstatic ssize_t show_mirror(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ofbi->mirror);\r\n}\r\nstatic ssize_t store_mirror(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nbool mirror;\r\nint r;\r\nstruct fb_var_screeninfo new_var;\r\nr = strtobool(buf, &mirror);\r\nif (r)\r\nreturn r;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nofbi->mirror = mirror;\r\nomapfb_get_mem_region(ofbi->region);\r\nmemcpy(&new_var, &fbi->var, sizeof(new_var));\r\nr = check_fb_var(fbi, &new_var);\r\nif (r)\r\ngoto out;\r\nmemcpy(&fbi->var, &new_var, sizeof(fbi->var));\r\nset_fb_fix(fbi);\r\nr = omapfb_apply_changes(fbi, 0);\r\nif (r)\r\ngoto out;\r\nr = count;\r\nout:\r\nomapfb_put_mem_region(ofbi->region);\r\nunlock_fb_info(fbi);\r\nreturn r;\r\n}\r\nstatic ssize_t show_overlays(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nssize_t l = 0;\r\nint t;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nomapfb_lock(fbdev);\r\nfor (t = 0; t < ofbi->num_overlays; t++) {\r\nstruct omap_overlay *ovl = ofbi->overlays[t];\r\nint ovlnum;\r\nfor (ovlnum = 0; ovlnum < fbdev->num_overlays; ++ovlnum)\r\nif (ovl == fbdev->overlays[ovlnum])\r\nbreak;\r\nl += snprintf(buf + l, PAGE_SIZE - l, "%s%d",\r\nt == 0 ? "" : ",", ovlnum);\r\n}\r\nl += snprintf(buf + l, PAGE_SIZE - l, "\n");\r\nomapfb_unlock(fbdev);\r\nunlock_fb_info(fbi);\r\nreturn l;\r\n}\r\nstatic struct omapfb_info *get_overlay_fb(struct omapfb2_device *fbdev,\r\nstruct omap_overlay *ovl)\r\n{\r\nint i, t;\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\r\nfor (t = 0; t < ofbi->num_overlays; t++) {\r\nif (ofbi->overlays[t] == ovl)\r\nreturn ofbi;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t store_overlays(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_overlay *ovls[OMAPFB_MAX_OVL_PER_FB];\r\nstruct omap_overlay *ovl;\r\nint num_ovls, r, i;\r\nint len;\r\nbool added = false;\r\nnum_ovls = 0;\r\nlen = strlen(buf);\r\nif (buf[len - 1] == '\n')\r\nlen = len - 1;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nomapfb_lock(fbdev);\r\nif (len > 0) {\r\nchar *p = (char *)buf;\r\nint ovlnum;\r\nwhile (p < buf + len) {\r\nint found;\r\nif (num_ovls == OMAPFB_MAX_OVL_PER_FB) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\novlnum = simple_strtoul(p, &p, 0);\r\nif (ovlnum > fbdev->num_overlays) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nfound = 0;\r\nfor (i = 0; i < num_ovls; ++i) {\r\nif (ovls[i] == fbdev->overlays[ovlnum]) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\novls[num_ovls++] = fbdev->overlays[ovlnum];\r\np++;\r\n}\r\n}\r\nfor (i = 0; i < num_ovls; ++i) {\r\nstruct omapfb_info *ofbi2 = get_overlay_fb(fbdev, ovls[i]);\r\nif (ofbi2 && ofbi2 != ofbi) {\r\ndev_err(fbdev->dev, "overlay already in use\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < ofbi->num_overlays; ++i) {\r\nint t, found;\r\novl = ofbi->overlays[i];\r\nfound = 0;\r\nfor (t = 0; t < num_ovls; ++t) {\r\nif (ovl == ovls[t]) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\ncontinue;\r\nDBG("detaching %d\n", ofbi->overlays[i]->id);\r\nomapfb_get_mem_region(ofbi->region);\r\nomapfb_overlay_enable(ovl, 0);\r\nif (ovl->manager)\r\novl->manager->apply(ovl->manager);\r\nomapfb_put_mem_region(ofbi->region);\r\nfor (t = i + 1; t < ofbi->num_overlays; t++) {\r\nofbi->rotation[t-1] = ofbi->rotation[t];\r\nofbi->overlays[t-1] = ofbi->overlays[t];\r\n}\r\nofbi->num_overlays--;\r\ni--;\r\n}\r\nfor (i = 0; i < num_ovls; ++i) {\r\nint t, found;\r\novl = ovls[i];\r\nfound = 0;\r\nfor (t = 0; t < ofbi->num_overlays; ++t) {\r\nif (ovl == ofbi->overlays[t]) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\ncontinue;\r\nofbi->rotation[ofbi->num_overlays] = 0;\r\nofbi->overlays[ofbi->num_overlays++] = ovl;\r\nadded = true;\r\n}\r\nif (added) {\r\nomapfb_get_mem_region(ofbi->region);\r\nr = omapfb_apply_changes(fbi, 0);\r\nomapfb_put_mem_region(ofbi->region);\r\nif (r)\r\ngoto out;\r\n}\r\nr = count;\r\nout:\r\nomapfb_unlock(fbdev);\r\nunlock_fb_info(fbi);\r\nreturn r;\r\n}\r\nstatic ssize_t show_overlays_rotate(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nssize_t l = 0;\r\nint t;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nfor (t = 0; t < ofbi->num_overlays; t++) {\r\nl += snprintf(buf + l, PAGE_SIZE - l, "%s%d",\r\nt == 0 ? "" : ",", ofbi->rotation[t]);\r\n}\r\nl += snprintf(buf + l, PAGE_SIZE - l, "\n");\r\nunlock_fb_info(fbi);\r\nreturn l;\r\n}\r\nstatic ssize_t store_overlays_rotate(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nint num_ovls = 0, r, i;\r\nint len;\r\nbool changed = false;\r\nu8 rotation[OMAPFB_MAX_OVL_PER_FB];\r\nlen = strlen(buf);\r\nif (buf[len - 1] == '\n')\r\nlen = len - 1;\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nif (len > 0) {\r\nchar *p = (char *)buf;\r\nwhile (p < buf + len) {\r\nint rot;\r\nif (num_ovls == ofbi->num_overlays) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nrot = simple_strtoul(p, &p, 0);\r\nif (rot < 0 || rot > 3) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (ofbi->rotation[num_ovls] != rot)\r\nchanged = true;\r\nrotation[num_ovls++] = rot;\r\np++;\r\n}\r\n}\r\nif (num_ovls != ofbi->num_overlays) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (changed) {\r\nfor (i = 0; i < num_ovls; ++i)\r\nofbi->rotation[i] = rotation[i];\r\nomapfb_get_mem_region(ofbi->region);\r\nr = omapfb_apply_changes(fbi, 0);\r\nomapfb_put_mem_region(ofbi->region);\r\nif (r)\r\ngoto out;\r\n}\r\nr = count;\r\nout:\r\nunlock_fb_info(fbi);\r\nreturn r;\r\n}\r\nstatic ssize_t show_size(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", ofbi->region->size);\r\n}\r\nstatic ssize_t store_size(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb2_mem_region *rg;\r\nunsigned long size;\r\nint r;\r\nint i;\r\nr = kstrtoul(buf, 0, &size);\r\nif (r)\r\nreturn r;\r\nsize = PAGE_ALIGN(size);\r\nif (!lock_fb_info(fbi))\r\nreturn -ENODEV;\r\nif (display && display->driver->sync)\r\ndisplay->driver->sync(display);\r\nrg = ofbi->region;\r\ndown_write_nested(&rg->lock, rg->id);\r\natomic_inc(&rg->lock_count);\r\nif (atomic_read(&rg->map_count)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);\r\nint j;\r\nif (ofbi2->region != rg)\r\ncontinue;\r\nfor (j = 0; j < ofbi2->num_overlays; j++) {\r\nstruct omap_overlay *ovl;\r\novl = ofbi2->overlays[j];\r\nif (ovl->is_enabled(ovl)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (size != ofbi->region->size) {\r\nr = omapfb_realloc_fbmem(fbi, size, ofbi->region->type);\r\nif (r) {\r\ndev_err(dev, "realloc fbmem failed\n");\r\ngoto out;\r\n}\r\n}\r\nr = count;\r\nout:\r\natomic_dec(&rg->lock_count);\r\nup_write(&rg->lock);\r\nunlock_fb_info(fbi);\r\nreturn r;\r\n}\r\nstatic ssize_t show_phys(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nreturn snprintf(buf, PAGE_SIZE, "%0x\n", ofbi->region->paddr);\r\n}\r\nstatic ssize_t show_virt(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nreturn snprintf(buf, PAGE_SIZE, "%p\n", ofbi->region->vaddr);\r\n}\r\nstatic ssize_t show_upd_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nenum omapfb_update_mode mode;\r\nint r;\r\nr = omapfb_get_update_mode(fbi, &mode);\r\nif (r)\r\nreturn r;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", (unsigned)mode);\r\n}\r\nstatic ssize_t store_upd_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *fbi = dev_get_drvdata(dev);\r\nunsigned mode;\r\nint r;\r\nr = kstrtouint(buf, 0, &mode);\r\nif (r)\r\nreturn r;\r\nr = omapfb_set_update_mode(fbi, mode);\r\nif (r)\r\nreturn r;\r\nreturn count;\r\n}\r\nint omapfb_create_sysfs(struct omapfb2_device *fbdev)\r\n{\r\nint i;\r\nint r;\r\nDBG("create sysfs for fbs\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nint t;\r\nfor (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++) {\r\nr = device_create_file(fbdev->fbs[i]->dev,\r\n&omapfb_attrs[t]);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to create sysfs "\r\n"file\n");\r\nreturn r;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid omapfb_remove_sysfs(struct omapfb2_device *fbdev)\r\n{\r\nint i, t;\r\nDBG("remove sysfs for fbs\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nfor (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)\r\ndevice_remove_file(fbdev->fbs[i]->dev,\r\n&omapfb_attrs[t]);\r\n}\r\n}
