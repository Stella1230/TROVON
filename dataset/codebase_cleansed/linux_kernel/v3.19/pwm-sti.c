static inline struct sti_pwm_chip *to_sti_pwmchip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct sti_pwm_chip, chip);\r\n}\r\nstatic int sti_pwm_get_prescale(struct sti_pwm_chip *pc, unsigned long period,\r\nunsigned int *prescale)\r\n{\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nunsigned long val;\r\nunsigned int ps;\r\nval = NSEC_PER_SEC / pc->clk_rate;\r\nval *= cdata->max_pwm_cnt + 1;\r\nif (period % val) {\r\nreturn -EINVAL;\r\n} else {\r\nps = period / val - 1;\r\nif (ps > cdata->max_prescale)\r\nreturn -EINVAL;\r\n}\r\n*prescale = ps;\r\nreturn 0;\r\n}\r\nstatic unsigned int sti_pwm_count_configured(struct pwm_chip *chip)\r\n{\r\nstruct pwm_device *pwm;\r\nunsigned int ncfg = 0;\r\nunsigned int i;\r\nfor (i = 0; i < chip->npwm; i++) {\r\npwm = &chip->pwms[i];\r\nif (test_bit(PWMF_REQUESTED, &pwm->flags)) {\r\nif (pwm_get_period(pwm))\r\nncfg++;\r\n}\r\n}\r\nreturn ncfg;\r\n}\r\nstatic int sti_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nstruct pwm_device *cur = pc->cur;\r\nstruct device *dev = pc->dev;\r\nunsigned int prescale = 0, pwmvalx;\r\nint ret;\r\nunsigned int ncfg;\r\nbool period_same = false;\r\nncfg = sti_pwm_count_configured(chip);\r\nif (ncfg)\r\nperiod_same = (period_ns == pwm_get_period(cur));\r\nif (!ncfg ||\r\n((ncfg == 1) && (pwm->hwpwm == cur->hwpwm)) ||\r\n((ncfg == 1) && (pwm->hwpwm != cur->hwpwm) && period_same) ||\r\n((ncfg > 1) && period_same)) {\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\nif (!period_same) {\r\nret = sti_pwm_get_prescale(pc, period_ns, &prescale);\r\nif (ret)\r\ngoto clk_dis;\r\nret =\r\nregmap_field_write(pc->prescale_low,\r\nprescale & PWM_PRESCALE_LOW_MASK);\r\nif (ret)\r\ngoto clk_dis;\r\nret =\r\nregmap_field_write(pc->prescale_high,\r\n(prescale & PWM_PRESCALE_HIGH_MASK) >> 4);\r\nif (ret)\r\ngoto clk_dis;\r\n}\r\npwmvalx = cdata->max_pwm_cnt * duty_ns / period_ns;\r\nret = regmap_write(pc->regmap, STI_DS_REG(pwm->hwpwm), pwmvalx);\r\nif (ret)\r\ngoto clk_dis;\r\nret = regmap_field_write(pc->pwm_int_en, 0);\r\npc->cur = pwm;\r\ndev_dbg(dev, "prescale:%u, period:%i, duty:%i, pwmvalx:%u\n",\r\nprescale, period_ns, duty_ns, pwmvalx);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nclk_dis:\r\nclk_disable(pc->clk);\r\nreturn ret;\r\n}\r\nstatic int sti_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nstruct device *dev = pc->dev;\r\nint ret = 0;\r\nmutex_lock(&pc->sti_pwm_lock);\r\nif (!pc->en_count) {\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\ngoto out;\r\nret = regmap_field_write(pc->pwm_en, 1);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PWM device:%d\n",\r\npwm->hwpwm);\r\ngoto out;\r\n}\r\n}\r\npc->en_count++;\r\nout:\r\nmutex_unlock(&pc->sti_pwm_lock);\r\nreturn ret;\r\n}\r\nstatic void sti_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nmutex_lock(&pc->sti_pwm_lock);\r\nif (--pc->en_count) {\r\nmutex_unlock(&pc->sti_pwm_lock);\r\nreturn;\r\n}\r\nregmap_field_write(pc->pwm_en, 0);\r\nclk_disable(pc->clk);\r\nmutex_unlock(&pc->sti_pwm_lock);\r\n}\r\nstatic int sti_pwm_probe_dt(struct sti_pwm_chip *pc)\r\n{\r\nstruct device *dev = pc->dev;\r\nconst struct reg_field *reg_fields;\r\nstruct device_node *np = dev->of_node;\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nu32 num_chan;\r\nof_property_read_u32(np, "st,pwm-num-chan", &num_chan);\r\nif (num_chan)\r\ncdata->num_chan = num_chan;\r\nreg_fields = cdata->reg_fields;\r\npc->prescale_low = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWMCLK_PRESCALE_LOW]);\r\nif (IS_ERR(pc->prescale_low))\r\nreturn PTR_ERR(pc->prescale_low);\r\npc->prescale_high = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWMCLK_PRESCALE_HIGH]);\r\nif (IS_ERR(pc->prescale_high))\r\nreturn PTR_ERR(pc->prescale_high);\r\npc->pwm_en = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_EN]);\r\nif (IS_ERR(pc->pwm_en))\r\nreturn PTR_ERR(pc->pwm_en);\r\npc->pwm_int_en = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_INT_EN]);\r\nif (IS_ERR(pc->pwm_int_en))\r\nreturn PTR_ERR(pc->pwm_int_en);\r\nreturn 0;\r\n}\r\nstatic int sti_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_pwm_compat_data *cdata;\r\nstruct sti_pwm_chip *pc;\r\nstruct resource *res;\r\nint ret;\r\npc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\ncdata = devm_kzalloc(dev, sizeof(*cdata), GFP_KERNEL);\r\nif (!cdata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npc->mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pc->mmio))\r\nreturn PTR_ERR(pc->mmio);\r\npc->regmap = devm_regmap_init_mmio(dev, pc->mmio,\r\n&sti_pwm_regmap_config);\r\nif (IS_ERR(pc->regmap))\r\nreturn PTR_ERR(pc->regmap);\r\ncdata->reg_fields = &sti_pwm_regfields[0];\r\ncdata->max_prescale = 0xff;\r\ncdata->max_pwm_cnt = 255;\r\ncdata->num_chan = 1;\r\npc->cdata = cdata;\r\npc->dev = dev;\r\npc->en_count = 0;\r\nmutex_init(&pc->sti_pwm_lock);\r\nret = sti_pwm_probe_dt(pc);\r\nif (ret)\r\nreturn ret;\r\npc->clk = of_clk_get_by_name(dev->of_node, "pwm");\r\nif (IS_ERR(pc->clk)) {\r\ndev_err(dev, "failed to get PWM clock\n");\r\nreturn PTR_ERR(pc->clk);\r\n}\r\npc->clk_rate = clk_get_rate(pc->clk);\r\nif (!pc->clk_rate) {\r\ndev_err(dev, "failed to get clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare(pc->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare clock\n");\r\nreturn ret;\r\n}\r\npc->chip.dev = dev;\r\npc->chip.ops = &sti_pwm_ops;\r\npc->chip.base = -1;\r\npc->chip.npwm = pc->cdata->num_chan;\r\npc->chip.can_sleep = true;\r\nret = pwmchip_add(&pc->chip);\r\nif (ret < 0) {\r\nclk_unprepare(pc->clk);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pc);\r\nreturn 0;\r\n}\r\nstatic int sti_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct sti_pwm_chip *pc = platform_get_drvdata(pdev);\r\nunsigned int i;\r\nfor (i = 0; i < pc->cdata->num_chan; i++)\r\npwm_disable(&pc->chip.pwms[i]);\r\nclk_unprepare(pc->clk);\r\nreturn pwmchip_remove(&pc->chip);\r\n}
