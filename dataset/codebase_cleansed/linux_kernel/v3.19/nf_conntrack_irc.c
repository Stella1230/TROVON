static int parse_dcc(char *data, const char *data_end, __be32 *ip,\r\nu_int16_t *port, char **ad_beg_p, char **ad_end_p)\r\n{\r\nchar *tmp;\r\nwhile (*data++ != ' ')\r\nif (data > data_end - 12)\r\nreturn -1;\r\nfor (tmp = data; tmp <= data_end; tmp++)\r\nif (*tmp == '\n')\r\nbreak;\r\nif (tmp > data_end || *tmp != '\n')\r\nreturn -1;\r\n*ad_beg_p = data;\r\n*ip = cpu_to_be32(simple_strtoul(data, &data, 10));\r\nwhile (*data == ' ') {\r\nif (data >= data_end)\r\nreturn -1;\r\ndata++;\r\n}\r\n*port = simple_strtoul(data, &data, 10);\r\n*ad_end_p = data;\r\nreturn 0;\r\n}\r\nstatic int help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dataoff;\r\nconst struct iphdr *iph;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nconst char *data_limit;\r\nchar *data, *ib_ptr;\r\nint dir = CTINFO2DIR(ctinfo);\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple *tuple;\r\n__be32 dcc_ip;\r\nu_int16_t dcc_port;\r\n__be16 port;\r\nint i, ret = NF_ACCEPT;\r\nchar *addr_beg_p, *addr_end_p;\r\ntypeof(nf_nat_irc_hook) nf_nat_irc;\r\nif (dir == IP_CT_DIR_REPLY)\r\nreturn NF_ACCEPT;\r\nif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn NF_ACCEPT;\r\ndataoff = protoff + th->doff*4;\r\nif (dataoff >= skb->len)\r\nreturn NF_ACCEPT;\r\nspin_lock_bh(&irc_buffer_lock);\r\nib_ptr = skb_header_pointer(skb, dataoff, skb->len - dataoff,\r\nirc_buffer);\r\nBUG_ON(ib_ptr == NULL);\r\ndata = ib_ptr;\r\ndata_limit = ib_ptr + skb->len - dataoff;\r\nwhile (data < data_limit - (19 + MINMATCHLEN)) {\r\nif (memcmp(data, "\1DCC ", 5)) {\r\ndata++;\r\ncontinue;\r\n}\r\ndata += 5;\r\niph = ip_hdr(skb);\r\npr_debug("DCC found in master %pI4:%u %pI4:%u\n",\r\n&iph->saddr, ntohs(th->source),\r\n&iph->daddr, ntohs(th->dest));\r\nfor (i = 0; i < ARRAY_SIZE(dccprotos); i++) {\r\nif (memcmp(data, dccprotos[i], strlen(dccprotos[i]))) {\r\ncontinue;\r\n}\r\ndata += strlen(dccprotos[i]);\r\npr_debug("DCC %s detected\n", dccprotos[i]);\r\nif (parse_dcc(data, data_limit, &dcc_ip,\r\n&dcc_port, &addr_beg_p, &addr_end_p)) {\r\npr_debug("unable to parse dcc command\n");\r\ncontinue;\r\n}\r\npr_debug("DCC bound ip/port: %pI4:%u\n",\r\n&dcc_ip, dcc_port);\r\ntuple = &ct->tuplehash[dir].tuple;\r\nif (tuple->src.u3.ip != dcc_ip &&\r\ntuple->dst.u3.ip != dcc_ip) {\r\nnet_warn_ratelimited("Forged DCC command from %pI4: %pI4:%u\n",\r\n&tuple->src.u3.ip,\r\n&dcc_ip, dcc_port);\r\ncontinue;\r\n}\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nnf_ct_helper_log(skb, ct,\r\n"cannot alloc expectation");\r\nret = NF_DROP;\r\ngoto out;\r\n}\r\ntuple = &ct->tuplehash[!dir].tuple;\r\nport = htons(dcc_port);\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\r\ntuple->src.l3num,\r\nNULL, &tuple->dst.u3,\r\nIPPROTO_TCP, NULL, &port);\r\nnf_nat_irc = rcu_dereference(nf_nat_irc_hook);\r\nif (nf_nat_irc && ct->status & IPS_NAT_MASK)\r\nret = nf_nat_irc(skb, ctinfo, protoff,\r\naddr_beg_p - ib_ptr,\r\naddr_end_p - addr_beg_p,\r\nexp);\r\nelse if (nf_ct_expect_related(exp) != 0) {\r\nnf_ct_helper_log(skb, ct,\r\n"cannot add expectation");\r\nret = NF_DROP;\r\n}\r\nnf_ct_expect_put(exp);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_bh(&irc_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int __init nf_conntrack_irc_init(void)\r\n{\r\nint i, ret;\r\nif (max_dcc_channels < 1) {\r\nprintk(KERN_ERR "nf_ct_irc: max_dcc_channels must not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nirc_exp_policy.max_expected = max_dcc_channels;\r\nirc_exp_policy.timeout = dcc_timeout;\r\nirc_buffer = kmalloc(65536, GFP_KERNEL);\r\nif (!irc_buffer)\r\nreturn -ENOMEM;\r\nif (ports_c == 0)\r\nports[ports_c++] = IRC_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nirc[i].tuple.src.l3num = AF_INET;\r\nirc[i].tuple.src.u.tcp.port = htons(ports[i]);\r\nirc[i].tuple.dst.protonum = IPPROTO_TCP;\r\nirc[i].expect_policy = &irc_exp_policy;\r\nirc[i].me = THIS_MODULE;\r\nirc[i].help = help;\r\nif (ports[i] == IRC_PORT)\r\nsprintf(irc[i].name, "irc");\r\nelse\r\nsprintf(irc[i].name, "irc-%u", i);\r\nret = nf_conntrack_helper_register(&irc[i]);\r\nif (ret) {\r\nprintk(KERN_ERR "nf_ct_irc: failed to register helper "\r\n"for pf: %u port: %u\n",\r\nirc[i].tuple.src.l3num, ports[i]);\r\nnf_conntrack_irc_fini();\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_irc_fini(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ports_c; i++)\r\nnf_conntrack_helper_unregister(&irc[i]);\r\nkfree(irc_buffer);\r\n}
