static inline __le64 build_ctob(u32 td_cmd, u32 td_offset, unsigned int size,\r\nu32 td_tag)\r\n{\r\nreturn cpu_to_le64(I40E_TX_DESC_DTYPE_DATA |\r\n((u64)td_cmd << I40E_TXD_QW1_CMD_SHIFT) |\r\n((u64)td_offset << I40E_TXD_QW1_OFFSET_SHIFT) |\r\n((u64)size << I40E_TXD_QW1_TX_BUF_SZ_SHIFT) |\r\n((u64)td_tag << I40E_TXD_QW1_L2TAG1_SHIFT));\r\n}\r\nstatic void i40e_unmap_and_free_tx_resource(struct i40e_ring *ring,\r\nstruct i40e_tx_buffer *tx_buffer)\r\n{\r\nif (tx_buffer->skb) {\r\nif (tx_buffer->tx_flags & I40E_TX_FLAGS_FD_SB)\r\nkfree(tx_buffer->raw_buf);\r\nelse\r\ndev_kfree_skb_any(tx_buffer->skb);\r\nif (dma_unmap_len(tx_buffer, len))\r\ndma_unmap_single(ring->dev,\r\ndma_unmap_addr(tx_buffer, dma),\r\ndma_unmap_len(tx_buffer, len),\r\nDMA_TO_DEVICE);\r\n} else if (dma_unmap_len(tx_buffer, len)) {\r\ndma_unmap_page(ring->dev,\r\ndma_unmap_addr(tx_buffer, dma),\r\ndma_unmap_len(tx_buffer, len),\r\nDMA_TO_DEVICE);\r\n}\r\ntx_buffer->next_to_watch = NULL;\r\ntx_buffer->skb = NULL;\r\ndma_unmap_len_set(tx_buffer, len, 0);\r\n}\r\nvoid i40evf_clean_tx_ring(struct i40e_ring *tx_ring)\r\n{\r\nunsigned long bi_size;\r\nu16 i;\r\nif (!tx_ring->tx_bi)\r\nreturn;\r\nfor (i = 0; i < tx_ring->count; i++)\r\ni40e_unmap_and_free_tx_resource(tx_ring, &tx_ring->tx_bi[i]);\r\nbi_size = sizeof(struct i40e_tx_buffer) * tx_ring->count;\r\nmemset(tx_ring->tx_bi, 0, bi_size);\r\nmemset(tx_ring->desc, 0, tx_ring->size);\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\nif (!tx_ring->netdev)\r\nreturn;\r\nnetdev_tx_reset_queue(netdev_get_tx_queue(tx_ring->netdev,\r\ntx_ring->queue_index));\r\n}\r\nvoid i40evf_free_tx_resources(struct i40e_ring *tx_ring)\r\n{\r\ni40evf_clean_tx_ring(tx_ring);\r\nkfree(tx_ring->tx_bi);\r\ntx_ring->tx_bi = NULL;\r\nif (tx_ring->desc) {\r\ndma_free_coherent(tx_ring->dev, tx_ring->size,\r\ntx_ring->desc, tx_ring->dma);\r\ntx_ring->desc = NULL;\r\n}\r\n}\r\nstatic u32 i40e_get_tx_pending(struct i40e_ring *ring)\r\n{\r\nu32 ntu = ((ring->next_to_clean <= ring->next_to_use)\r\n? ring->next_to_use\r\n: ring->next_to_use + ring->count);\r\nreturn ntu - ring->next_to_clean;\r\n}\r\nstatic bool i40e_check_tx_hang(struct i40e_ring *tx_ring)\r\n{\r\nu32 tx_pending = i40e_get_tx_pending(tx_ring);\r\nbool ret = false;\r\nclear_check_for_tx_hang(tx_ring);\r\nif ((tx_ring->tx_stats.tx_done_old == tx_ring->stats.packets) &&\r\n(tx_pending >= I40E_MIN_DESC_PENDING)) {\r\nret = test_and_set_bit(__I40E_HANG_CHECK_ARMED,\r\n&tx_ring->state);\r\n} else if (!(tx_ring->tx_stats.tx_done_old == tx_ring->stats.packets) ||\r\n!(tx_pending < I40E_MIN_DESC_PENDING) ||\r\n!(tx_pending > 0)) {\r\ntx_ring->tx_stats.tx_done_old = tx_ring->stats.packets;\r\nclear_bit(__I40E_HANG_CHECK_ARMED, &tx_ring->state);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline u32 i40e_get_head(struct i40e_ring *tx_ring)\r\n{\r\nvoid *head = (struct i40e_tx_desc *)tx_ring->desc + tx_ring->count;\r\nreturn le32_to_cpu(*(volatile __le32 *)head);\r\n}\r\nstatic bool i40e_clean_tx_irq(struct i40e_ring *tx_ring, int budget)\r\n{\r\nu16 i = tx_ring->next_to_clean;\r\nstruct i40e_tx_buffer *tx_buf;\r\nstruct i40e_tx_desc *tx_head;\r\nstruct i40e_tx_desc *tx_desc;\r\nunsigned int total_packets = 0;\r\nunsigned int total_bytes = 0;\r\ntx_buf = &tx_ring->tx_bi[i];\r\ntx_desc = I40E_TX_DESC(tx_ring, i);\r\ni -= tx_ring->count;\r\ntx_head = I40E_TX_DESC(tx_ring, i40e_get_head(tx_ring));\r\ndo {\r\nstruct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;\r\nif (!eop_desc)\r\nbreak;\r\nread_barrier_depends();\r\nif (tx_head == tx_desc)\r\nbreak;\r\ntx_buf->next_to_watch = NULL;\r\ntotal_bytes += tx_buf->bytecount;\r\ntotal_packets += tx_buf->gso_segs;\r\ndev_kfree_skb_any(tx_buf->skb);\r\ndma_unmap_single(tx_ring->dev,\r\ndma_unmap_addr(tx_buf, dma),\r\ndma_unmap_len(tx_buf, len),\r\nDMA_TO_DEVICE);\r\ntx_buf->skb = NULL;\r\ndma_unmap_len_set(tx_buf, len, 0);\r\nwhile (tx_desc != eop_desc) {\r\ntx_buf++;\r\ntx_desc++;\r\ni++;\r\nif (unlikely(!i)) {\r\ni -= tx_ring->count;\r\ntx_buf = tx_ring->tx_bi;\r\ntx_desc = I40E_TX_DESC(tx_ring, 0);\r\n}\r\nif (dma_unmap_len(tx_buf, len)) {\r\ndma_unmap_page(tx_ring->dev,\r\ndma_unmap_addr(tx_buf, dma),\r\ndma_unmap_len(tx_buf, len),\r\nDMA_TO_DEVICE);\r\ndma_unmap_len_set(tx_buf, len, 0);\r\n}\r\n}\r\ntx_buf++;\r\ntx_desc++;\r\ni++;\r\nif (unlikely(!i)) {\r\ni -= tx_ring->count;\r\ntx_buf = tx_ring->tx_bi;\r\ntx_desc = I40E_TX_DESC(tx_ring, 0);\r\n}\r\nbudget--;\r\n} while (likely(budget));\r\ni += tx_ring->count;\r\ntx_ring->next_to_clean = i;\r\nu64_stats_update_begin(&tx_ring->syncp);\r\ntx_ring->stats.bytes += total_bytes;\r\ntx_ring->stats.packets += total_packets;\r\nu64_stats_update_end(&tx_ring->syncp);\r\ntx_ring->q_vector->tx.total_bytes += total_bytes;\r\ntx_ring->q_vector->tx.total_packets += total_packets;\r\nif (check_for_tx_hang(tx_ring) && i40e_check_tx_hang(tx_ring)) {\r\ndev_info(tx_ring->dev, "Detected Tx Unit Hang\n"\r\n" VSI <%d>\n"\r\n" Tx Queue <%d>\n"\r\n" next_to_use <%x>\n"\r\n" next_to_clean <%x>\n",\r\ntx_ring->vsi->seid,\r\ntx_ring->queue_index,\r\ntx_ring->next_to_use, i);\r\ndev_info(tx_ring->dev, "tx_bi[next_to_clean]\n"\r\n" time_stamp <%lx>\n"\r\n" jiffies <%lx>\n",\r\ntx_ring->tx_bi[i].time_stamp, jiffies);\r\nnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\r\ndev_info(tx_ring->dev,\r\n"tx hang detected on queue %d, resetting adapter\n",\r\ntx_ring->queue_index);\r\ntx_ring->netdev->netdev_ops->ndo_tx_timeout(tx_ring->netdev);\r\nreturn true;\r\n}\r\nnetdev_tx_completed_queue(netdev_get_tx_queue(tx_ring->netdev,\r\ntx_ring->queue_index),\r\ntotal_packets, total_bytes);\r\n#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)\r\nif (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&\r\n(I40E_DESC_UNUSED(tx_ring) >= TX_WAKE_THRESHOLD))) {\r\nsmp_mb();\r\nif (__netif_subqueue_stopped(tx_ring->netdev,\r\ntx_ring->queue_index) &&\r\n!test_bit(__I40E_DOWN, &tx_ring->vsi->state)) {\r\nnetif_wake_subqueue(tx_ring->netdev,\r\ntx_ring->queue_index);\r\n++tx_ring->tx_stats.restart_queue;\r\n}\r\n}\r\nreturn budget > 0;\r\n}\r\nstatic void i40e_set_new_dynamic_itr(struct i40e_ring_container *rc)\r\n{\r\nenum i40e_latency_range new_latency_range = rc->latency_range;\r\nu32 new_itr = rc->itr;\r\nint bytes_per_int;\r\nif (rc->total_packets == 0 || !rc->itr)\r\nreturn;\r\nbytes_per_int = rc->total_bytes / rc->itr;\r\nswitch (rc->itr) {\r\ncase I40E_LOWEST_LATENCY:\r\nif (bytes_per_int > 10)\r\nnew_latency_range = I40E_LOW_LATENCY;\r\nbreak;\r\ncase I40E_LOW_LATENCY:\r\nif (bytes_per_int > 20)\r\nnew_latency_range = I40E_BULK_LATENCY;\r\nelse if (bytes_per_int <= 10)\r\nnew_latency_range = I40E_LOWEST_LATENCY;\r\nbreak;\r\ncase I40E_BULK_LATENCY:\r\nif (bytes_per_int <= 20)\r\nrc->latency_range = I40E_LOW_LATENCY;\r\nbreak;\r\n}\r\nswitch (new_latency_range) {\r\ncase I40E_LOWEST_LATENCY:\r\nnew_itr = I40E_ITR_100K;\r\nbreak;\r\ncase I40E_LOW_LATENCY:\r\nnew_itr = I40E_ITR_20K;\r\nbreak;\r\ncase I40E_BULK_LATENCY:\r\nnew_itr = I40E_ITR_8K;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (new_itr != rc->itr) {\r\nnew_itr = (10 * new_itr * rc->itr) /\r\n((9 * new_itr) + rc->itr);\r\nrc->itr = new_itr & I40E_MAX_ITR;\r\n}\r\nrc->total_bytes = 0;\r\nrc->total_packets = 0;\r\n}\r\nstatic void i40e_update_dynamic_itr(struct i40e_q_vector *q_vector)\r\n{\r\nu16 vector = q_vector->vsi->base_vector + q_vector->v_idx;\r\nstruct i40e_hw *hw = &q_vector->vsi->back->hw;\r\nu32 reg_addr;\r\nu16 old_itr;\r\nreg_addr = I40E_VFINT_ITRN1(I40E_RX_ITR, vector - 1);\r\nold_itr = q_vector->rx.itr;\r\ni40e_set_new_dynamic_itr(&q_vector->rx);\r\nif (old_itr != q_vector->rx.itr)\r\nwr32(hw, reg_addr, q_vector->rx.itr);\r\nreg_addr = I40E_VFINT_ITRN1(I40E_TX_ITR, vector - 1);\r\nold_itr = q_vector->tx.itr;\r\ni40e_set_new_dynamic_itr(&q_vector->tx);\r\nif (old_itr != q_vector->tx.itr)\r\nwr32(hw, reg_addr, q_vector->tx.itr);\r\n}\r\nint i40evf_setup_tx_descriptors(struct i40e_ring *tx_ring)\r\n{\r\nstruct device *dev = tx_ring->dev;\r\nint bi_size;\r\nif (!dev)\r\nreturn -ENOMEM;\r\nbi_size = sizeof(struct i40e_tx_buffer) * tx_ring->count;\r\ntx_ring->tx_bi = kzalloc(bi_size, GFP_KERNEL);\r\nif (!tx_ring->tx_bi)\r\ngoto err;\r\ntx_ring->size = tx_ring->count * sizeof(struct i40e_tx_desc);\r\ntx_ring->size += sizeof(u32);\r\ntx_ring->size = ALIGN(tx_ring->size, 4096);\r\ntx_ring->desc = dma_alloc_coherent(dev, tx_ring->size,\r\n&tx_ring->dma, GFP_KERNEL);\r\nif (!tx_ring->desc) {\r\ndev_info(dev, "Unable to allocate memory for the Tx descriptor ring, size=%d\n",\r\ntx_ring->size);\r\ngoto err;\r\n}\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\nreturn 0;\r\nerr:\r\nkfree(tx_ring->tx_bi);\r\ntx_ring->tx_bi = NULL;\r\nreturn -ENOMEM;\r\n}\r\nvoid i40evf_clean_rx_ring(struct i40e_ring *rx_ring)\r\n{\r\nstruct device *dev = rx_ring->dev;\r\nstruct i40e_rx_buffer *rx_bi;\r\nunsigned long bi_size;\r\nu16 i;\r\nif (!rx_ring->rx_bi)\r\nreturn;\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nrx_bi = &rx_ring->rx_bi[i];\r\nif (rx_bi->dma) {\r\ndma_unmap_single(dev,\r\nrx_bi->dma,\r\nrx_ring->rx_buf_len,\r\nDMA_FROM_DEVICE);\r\nrx_bi->dma = 0;\r\n}\r\nif (rx_bi->skb) {\r\ndev_kfree_skb(rx_bi->skb);\r\nrx_bi->skb = NULL;\r\n}\r\nif (rx_bi->page) {\r\nif (rx_bi->page_dma) {\r\ndma_unmap_page(dev,\r\nrx_bi->page_dma,\r\nPAGE_SIZE / 2,\r\nDMA_FROM_DEVICE);\r\nrx_bi->page_dma = 0;\r\n}\r\n__free_page(rx_bi->page);\r\nrx_bi->page = NULL;\r\nrx_bi->page_offset = 0;\r\n}\r\n}\r\nbi_size = sizeof(struct i40e_rx_buffer) * rx_ring->count;\r\nmemset(rx_ring->rx_bi, 0, bi_size);\r\nmemset(rx_ring->desc, 0, rx_ring->size);\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\n}\r\nvoid i40evf_free_rx_resources(struct i40e_ring *rx_ring)\r\n{\r\ni40evf_clean_rx_ring(rx_ring);\r\nkfree(rx_ring->rx_bi);\r\nrx_ring->rx_bi = NULL;\r\nif (rx_ring->desc) {\r\ndma_free_coherent(rx_ring->dev, rx_ring->size,\r\nrx_ring->desc, rx_ring->dma);\r\nrx_ring->desc = NULL;\r\n}\r\n}\r\nint i40evf_setup_rx_descriptors(struct i40e_ring *rx_ring)\r\n{\r\nstruct device *dev = rx_ring->dev;\r\nint bi_size;\r\nbi_size = sizeof(struct i40e_rx_buffer) * rx_ring->count;\r\nrx_ring->rx_bi = kzalloc(bi_size, GFP_KERNEL);\r\nif (!rx_ring->rx_bi)\r\ngoto err;\r\nrx_ring->size = ring_is_16byte_desc_enabled(rx_ring)\r\n? rx_ring->count * sizeof(union i40e_16byte_rx_desc)\r\n: rx_ring->count * sizeof(union i40e_32byte_rx_desc);\r\nrx_ring->size = ALIGN(rx_ring->size, 4096);\r\nrx_ring->desc = dma_alloc_coherent(dev, rx_ring->size,\r\n&rx_ring->dma, GFP_KERNEL);\r\nif (!rx_ring->desc) {\r\ndev_info(dev, "Unable to allocate memory for the Rx descriptor ring, size=%d\n",\r\nrx_ring->size);\r\ngoto err;\r\n}\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\nreturn 0;\r\nerr:\r\nkfree(rx_ring->rx_bi);\r\nrx_ring->rx_bi = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic inline void i40e_release_rx_desc(struct i40e_ring *rx_ring, u32 val)\r\n{\r\nrx_ring->next_to_use = val;\r\nwmb();\r\nwritel(val, rx_ring->tail);\r\n}\r\nvoid i40evf_alloc_rx_buffers(struct i40e_ring *rx_ring, u16 cleaned_count)\r\n{\r\nu16 i = rx_ring->next_to_use;\r\nunion i40e_rx_desc *rx_desc;\r\nstruct i40e_rx_buffer *bi;\r\nstruct sk_buff *skb;\r\nif (!rx_ring->netdev || !cleaned_count)\r\nreturn;\r\nwhile (cleaned_count--) {\r\nrx_desc = I40E_RX_DESC(rx_ring, i);\r\nbi = &rx_ring->rx_bi[i];\r\nskb = bi->skb;\r\nif (!skb) {\r\nskb = netdev_alloc_skb_ip_align(rx_ring->netdev,\r\nrx_ring->rx_buf_len);\r\nif (!skb) {\r\nrx_ring->rx_stats.alloc_buff_failed++;\r\ngoto no_buffers;\r\n}\r\nskb_record_rx_queue(skb, rx_ring->queue_index);\r\nbi->skb = skb;\r\n}\r\nif (!bi->dma) {\r\nbi->dma = dma_map_single(rx_ring->dev,\r\nskb->data,\r\nrx_ring->rx_buf_len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(rx_ring->dev, bi->dma)) {\r\nrx_ring->rx_stats.alloc_buff_failed++;\r\nbi->dma = 0;\r\ngoto no_buffers;\r\n}\r\n}\r\nif (ring_is_ps_enabled(rx_ring)) {\r\nif (!bi->page) {\r\nbi->page = alloc_page(GFP_ATOMIC);\r\nif (!bi->page) {\r\nrx_ring->rx_stats.alloc_page_failed++;\r\ngoto no_buffers;\r\n}\r\n}\r\nif (!bi->page_dma) {\r\nbi->page_offset ^= PAGE_SIZE / 2;\r\nbi->page_dma = dma_map_page(rx_ring->dev,\r\nbi->page,\r\nbi->page_offset,\r\nPAGE_SIZE / 2,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(rx_ring->dev,\r\nbi->page_dma)) {\r\nrx_ring->rx_stats.alloc_page_failed++;\r\nbi->page_dma = 0;\r\ngoto no_buffers;\r\n}\r\n}\r\nrx_desc->read.pkt_addr = cpu_to_le64(bi->page_dma);\r\nrx_desc->read.hdr_addr = cpu_to_le64(bi->dma);\r\n} else {\r\nrx_desc->read.pkt_addr = cpu_to_le64(bi->dma);\r\nrx_desc->read.hdr_addr = 0;\r\n}\r\ni++;\r\nif (i == rx_ring->count)\r\ni = 0;\r\n}\r\nno_buffers:\r\nif (rx_ring->next_to_use != i)\r\ni40e_release_rx_desc(rx_ring, i);\r\n}\r\nstatic void i40e_receive_skb(struct i40e_ring *rx_ring,\r\nstruct sk_buff *skb, u16 vlan_tag)\r\n{\r\nstruct i40e_q_vector *q_vector = rx_ring->q_vector;\r\nstruct i40e_vsi *vsi = rx_ring->vsi;\r\nu64 flags = vsi->back->flags;\r\nif (vlan_tag & VLAN_VID_MASK)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);\r\nif (flags & I40E_FLAG_IN_NETPOLL)\r\nnetif_rx(skb);\r\nelse\r\nnapi_gro_receive(&q_vector->napi, skb);\r\n}\r\nstatic inline void i40e_rx_checksum(struct i40e_vsi *vsi,\r\nstruct sk_buff *skb,\r\nu32 rx_status,\r\nu32 rx_error,\r\nu16 rx_ptype)\r\n{\r\nstruct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype(rx_ptype);\r\nbool ipv4 = false, ipv6 = false;\r\nbool ipv4_tunnel, ipv6_tunnel;\r\n__wsum rx_udp_csum;\r\nstruct iphdr *iph;\r\n__sum16 csum;\r\nipv4_tunnel = (rx_ptype > I40E_RX_PTYPE_GRENAT4_MAC_PAY3) &&\r\n(rx_ptype < I40E_RX_PTYPE_GRENAT4_MACVLAN_IPV6_ICMP_PAY4);\r\nipv6_tunnel = (rx_ptype > I40E_RX_PTYPE_GRENAT6_MAC_PAY3) &&\r\n(rx_ptype < I40E_RX_PTYPE_GRENAT6_MACVLAN_IPV6_ICMP_PAY4);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif (!(vsi->netdev->features & NETIF_F_RXCSUM))\r\nreturn;\r\nif (!(rx_status & (1 << I40E_RX_DESC_STATUS_L3L4P_SHIFT)))\r\nreturn;\r\nif (!(decoded.known && decoded.outer_ip))\r\nreturn;\r\nif (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP &&\r\ndecoded.outer_ip_ver == I40E_RX_PTYPE_OUTER_IPV4)\r\nipv4 = true;\r\nelse if (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP &&\r\ndecoded.outer_ip_ver == I40E_RX_PTYPE_OUTER_IPV6)\r\nipv6 = true;\r\nif (ipv4 &&\r\n(rx_error & ((1 << I40E_RX_DESC_ERROR_IPE_SHIFT) |\r\n(1 << I40E_RX_DESC_ERROR_EIPE_SHIFT))))\r\ngoto checksum_fail;\r\nif (ipv6 &&\r\nrx_status & (1 << I40E_RX_DESC_STATUS_IPV6EXADD_SHIFT))\r\nreturn;\r\nif (rx_error & (1 << I40E_RX_DESC_ERROR_L4E_SHIFT))\r\ngoto checksum_fail;\r\nif (rx_error & (1 << I40E_RX_DESC_ERROR_PPRS_SHIFT))\r\nreturn;\r\nif (ipv4_tunnel &&\r\n(decoded.inner_prot != I40E_RX_PTYPE_INNER_PROT_UDP) &&\r\n!(rx_status & (1 << I40E_RX_DESC_STATUS_UDP_0_SHIFT))) {\r\nskb->transport_header = skb->mac_header +\r\nsizeof(struct ethhdr) +\r\n(ip_hdr(skb)->ihl * 4);\r\nskb->transport_header += (skb->protocol == htons(ETH_P_8021Q) ||\r\nskb->protocol == htons(ETH_P_8021AD))\r\n? VLAN_HLEN : 0;\r\nrx_udp_csum = udp_csum(skb);\r\niph = ip_hdr(skb);\r\ncsum = csum_tcpudp_magic(\r\niph->saddr, iph->daddr,\r\n(skb->len - skb_transport_offset(skb)),\r\nIPPROTO_UDP, rx_udp_csum);\r\nif (udp_hdr(skb)->check != csum)\r\ngoto checksum_fail;\r\n}\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->csum_level = ipv4_tunnel || ipv6_tunnel;\r\nreturn;\r\nchecksum_fail:\r\nvsi->back->hw_csum_rx_error++;\r\n}\r\nstatic inline u32 i40e_rx_hash(struct i40e_ring *ring,\r\nunion i40e_rx_desc *rx_desc)\r\n{\r\nconst __le64 rss_mask =\r\ncpu_to_le64((u64)I40E_RX_DESC_FLTSTAT_RSS_HASH <<\r\nI40E_RX_DESC_STATUS_FLTSTAT_SHIFT);\r\nif ((ring->netdev->features & NETIF_F_RXHASH) &&\r\n(rx_desc->wb.qword1.status_error_len & rss_mask) == rss_mask)\r\nreturn le32_to_cpu(rx_desc->wb.qword0.hi_dword.rss);\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline enum pkt_hash_types i40e_ptype_to_hash(u8 ptype)\r\n{\r\nstruct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype(ptype);\r\nif (!decoded.known)\r\nreturn PKT_HASH_TYPE_NONE;\r\nif (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP &&\r\ndecoded.payload_layer == I40E_RX_PTYPE_PAYLOAD_LAYER_PAY4)\r\nreturn PKT_HASH_TYPE_L4;\r\nelse if (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP &&\r\ndecoded.payload_layer == I40E_RX_PTYPE_PAYLOAD_LAYER_PAY3)\r\nreturn PKT_HASH_TYPE_L3;\r\nelse\r\nreturn PKT_HASH_TYPE_L2;\r\n}\r\nstatic int i40e_clean_rx_irq(struct i40e_ring *rx_ring, int budget)\r\n{\r\nunsigned int total_rx_bytes = 0, total_rx_packets = 0;\r\nu16 rx_packet_len, rx_header_len, rx_sph, rx_hbo;\r\nu16 cleaned_count = I40E_DESC_UNUSED(rx_ring);\r\nconst int current_node = numa_node_id();\r\nstruct i40e_vsi *vsi = rx_ring->vsi;\r\nu16 i = rx_ring->next_to_clean;\r\nunion i40e_rx_desc *rx_desc;\r\nu32 rx_error, rx_status;\r\nu8 rx_ptype;\r\nu64 qword;\r\nrx_desc = I40E_RX_DESC(rx_ring, i);\r\nqword = le64_to_cpu(rx_desc->wb.qword1.status_error_len);\r\nrx_status = (qword & I40E_RXD_QW1_STATUS_MASK) >>\r\nI40E_RXD_QW1_STATUS_SHIFT;\r\nwhile (rx_status & (1 << I40E_RX_DESC_STATUS_DD_SHIFT)) {\r\nunion i40e_rx_desc *next_rxd;\r\nstruct i40e_rx_buffer *rx_bi;\r\nstruct sk_buff *skb;\r\nu16 vlan_tag;\r\nrx_bi = &rx_ring->rx_bi[i];\r\nskb = rx_bi->skb;\r\nprefetch(skb->data);\r\nrx_packet_len = (qword & I40E_RXD_QW1_LENGTH_PBUF_MASK) >>\r\nI40E_RXD_QW1_LENGTH_PBUF_SHIFT;\r\nrx_header_len = (qword & I40E_RXD_QW1_LENGTH_HBUF_MASK) >>\r\nI40E_RXD_QW1_LENGTH_HBUF_SHIFT;\r\nrx_sph = (qword & I40E_RXD_QW1_LENGTH_SPH_MASK) >>\r\nI40E_RXD_QW1_LENGTH_SPH_SHIFT;\r\nrx_error = (qword & I40E_RXD_QW1_ERROR_MASK) >>\r\nI40E_RXD_QW1_ERROR_SHIFT;\r\nrx_hbo = rx_error & (1 << I40E_RX_DESC_ERROR_HBO_SHIFT);\r\nrx_error &= ~(1 << I40E_RX_DESC_ERROR_HBO_SHIFT);\r\nrx_ptype = (qword & I40E_RXD_QW1_PTYPE_MASK) >>\r\nI40E_RXD_QW1_PTYPE_SHIFT;\r\nrx_bi->skb = NULL;\r\nrmb();\r\nif (rx_bi->dma) {\r\nu16 len;\r\nif (rx_hbo)\r\nlen = I40E_RX_HDR_SIZE;\r\nelse if (rx_sph)\r\nlen = rx_header_len;\r\nelse if (rx_packet_len)\r\nlen = rx_packet_len;\r\nelse\r\nlen = rx_header_len;\r\nskb_put(skb, len);\r\ndma_unmap_single(rx_ring->dev,\r\nrx_bi->dma,\r\nrx_ring->rx_buf_len,\r\nDMA_FROM_DEVICE);\r\nrx_bi->dma = 0;\r\n}\r\nif (ring_is_ps_enabled(rx_ring) && rx_packet_len) {\r\nskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags,\r\nrx_bi->page,\r\nrx_bi->page_offset,\r\nrx_packet_len);\r\nskb->len += rx_packet_len;\r\nskb->data_len += rx_packet_len;\r\nskb->truesize += rx_packet_len;\r\nif ((page_count(rx_bi->page) == 1) &&\r\n(page_to_nid(rx_bi->page) == current_node))\r\nget_page(rx_bi->page);\r\nelse\r\nrx_bi->page = NULL;\r\ndma_unmap_page(rx_ring->dev,\r\nrx_bi->page_dma,\r\nPAGE_SIZE / 2,\r\nDMA_FROM_DEVICE);\r\nrx_bi->page_dma = 0;\r\n}\r\nI40E_RX_NEXT_DESC_PREFETCH(rx_ring, i, next_rxd);\r\nif (unlikely(\r\n!(rx_status & (1 << I40E_RX_DESC_STATUS_EOF_SHIFT)))) {\r\nstruct i40e_rx_buffer *next_buffer;\r\nnext_buffer = &rx_ring->rx_bi[i];\r\nif (ring_is_ps_enabled(rx_ring)) {\r\nrx_bi->skb = next_buffer->skb;\r\nrx_bi->dma = next_buffer->dma;\r\nnext_buffer->skb = skb;\r\nnext_buffer->dma = 0;\r\n}\r\nrx_ring->rx_stats.non_eop_descs++;\r\ngoto next_desc;\r\n}\r\nif (unlikely(rx_error & (1 << I40E_RX_DESC_ERROR_RXE_SHIFT))) {\r\ndev_kfree_skb_any(skb);\r\ngoto next_desc;\r\n}\r\nskb_set_hash(skb, i40e_rx_hash(rx_ring, rx_desc),\r\ni40e_ptype_to_hash(rx_ptype));\r\ntotal_rx_bytes += skb->len;\r\ntotal_rx_packets++;\r\nskb->protocol = eth_type_trans(skb, rx_ring->netdev);\r\ni40e_rx_checksum(vsi, skb, rx_status, rx_error, rx_ptype);\r\nvlan_tag = rx_status & (1 << I40E_RX_DESC_STATUS_L2TAG1P_SHIFT)\r\n? le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1)\r\n: 0;\r\ni40e_receive_skb(rx_ring, skb, vlan_tag);\r\nrx_ring->netdev->last_rx = jiffies;\r\nbudget--;\r\nnext_desc:\r\nrx_desc->wb.qword1.status_error_len = 0;\r\nif (!budget)\r\nbreak;\r\ncleaned_count++;\r\nif (cleaned_count >= I40E_RX_BUFFER_WRITE) {\r\ni40evf_alloc_rx_buffers(rx_ring, cleaned_count);\r\ncleaned_count = 0;\r\n}\r\nrx_desc = next_rxd;\r\nqword = le64_to_cpu(rx_desc->wb.qword1.status_error_len);\r\nrx_status = (qword & I40E_RXD_QW1_STATUS_MASK) >>\r\nI40E_RXD_QW1_STATUS_SHIFT;\r\n}\r\nrx_ring->next_to_clean = i;\r\nu64_stats_update_begin(&rx_ring->syncp);\r\nrx_ring->stats.packets += total_rx_packets;\r\nrx_ring->stats.bytes += total_rx_bytes;\r\nu64_stats_update_end(&rx_ring->syncp);\r\nrx_ring->q_vector->rx.total_packets += total_rx_packets;\r\nrx_ring->q_vector->rx.total_bytes += total_rx_bytes;\r\nif (cleaned_count)\r\ni40evf_alloc_rx_buffers(rx_ring, cleaned_count);\r\nreturn budget > 0;\r\n}\r\nint i40evf_napi_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct i40e_q_vector *q_vector =\r\ncontainer_of(napi, struct i40e_q_vector, napi);\r\nstruct i40e_vsi *vsi = q_vector->vsi;\r\nstruct i40e_ring *ring;\r\nbool clean_complete = true;\r\nint budget_per_ring;\r\nif (test_bit(__I40E_DOWN, &vsi->state)) {\r\nnapi_complete(napi);\r\nreturn 0;\r\n}\r\ni40e_for_each_ring(ring, q_vector->tx)\r\nclean_complete &= i40e_clean_tx_irq(ring, vsi->work_limit);\r\nbudget_per_ring = max(budget/q_vector->num_ringpairs, 1);\r\ni40e_for_each_ring(ring, q_vector->rx)\r\nclean_complete &= i40e_clean_rx_irq(ring, budget_per_ring);\r\nif (!clean_complete)\r\nreturn budget;\r\nnapi_complete(napi);\r\nif (ITR_IS_DYNAMIC(vsi->rx_itr_setting) ||\r\nITR_IS_DYNAMIC(vsi->tx_itr_setting))\r\ni40e_update_dynamic_itr(q_vector);\r\nif (!test_bit(__I40E_DOWN, &vsi->state))\r\ni40evf_irq_enable_queues(vsi->back, 1 << q_vector->v_idx);\r\nreturn 0;\r\n}\r\nstatic int i40e_tx_prepare_vlan_flags(struct sk_buff *skb,\r\nstruct i40e_ring *tx_ring,\r\nu32 *flags)\r\n{\r\n__be16 protocol = skb->protocol;\r\nu32 tx_flags = 0;\r\nif (vlan_tx_tag_present(skb)) {\r\ntx_flags |= vlan_tx_tag_get(skb) << I40E_TX_FLAGS_VLAN_SHIFT;\r\ntx_flags |= I40E_TX_FLAGS_HW_VLAN;\r\n} else if (protocol == htons(ETH_P_8021Q)) {\r\nstruct vlan_hdr *vhdr, _vhdr;\r\nvhdr = skb_header_pointer(skb, ETH_HLEN, sizeof(_vhdr), &_vhdr);\r\nif (!vhdr)\r\nreturn -EINVAL;\r\nprotocol = vhdr->h_vlan_encapsulated_proto;\r\ntx_flags |= ntohs(vhdr->h_vlan_TCI) << I40E_TX_FLAGS_VLAN_SHIFT;\r\ntx_flags |= I40E_TX_FLAGS_SW_VLAN;\r\n}\r\n*flags = tx_flags;\r\nreturn 0;\r\n}\r\nstatic int i40e_tso(struct i40e_ring *tx_ring, struct sk_buff *skb,\r\nu32 tx_flags, __be16 protocol, u8 *hdr_len,\r\nu64 *cd_type_cmd_tso_mss, u32 *cd_tunneling)\r\n{\r\nu32 cd_cmd, cd_tso_len, cd_mss;\r\nstruct ipv6hdr *ipv6h;\r\nstruct tcphdr *tcph;\r\nstruct iphdr *iph;\r\nu32 l4len;\r\nint err;\r\nif (!skb_is_gso(skb))\r\nreturn 0;\r\nerr = skb_cow_head(skb, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (protocol == htons(ETH_P_IP)) {\r\niph = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);\r\ntcph = skb->encapsulation ? inner_tcp_hdr(skb) : tcp_hdr(skb);\r\niph->tot_len = 0;\r\niph->check = 0;\r\ntcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\n0, IPPROTO_TCP, 0);\r\n} else if (skb_is_gso_v6(skb)) {\r\nipv6h = skb->encapsulation ? inner_ipv6_hdr(skb)\r\n: ipv6_hdr(skb);\r\ntcph = skb->encapsulation ? inner_tcp_hdr(skb) : tcp_hdr(skb);\r\nipv6h->payload_len = 0;\r\ntcph->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,\r\n0, IPPROTO_TCP, 0);\r\n}\r\nl4len = skb->encapsulation ? inner_tcp_hdrlen(skb) : tcp_hdrlen(skb);\r\n*hdr_len = (skb->encapsulation\r\n? (skb_inner_transport_header(skb) - skb->data)\r\n: skb_transport_offset(skb)) + l4len;\r\ncd_cmd = I40E_TX_CTX_DESC_TSO;\r\ncd_tso_len = skb->len - *hdr_len;\r\ncd_mss = skb_shinfo(skb)->gso_size;\r\n*cd_type_cmd_tso_mss |= ((u64)cd_cmd << I40E_TXD_CTX_QW1_CMD_SHIFT) |\r\n((u64)cd_tso_len <<\r\nI40E_TXD_CTX_QW1_TSO_LEN_SHIFT) |\r\n((u64)cd_mss << I40E_TXD_CTX_QW1_MSS_SHIFT);\r\nreturn 1;\r\n}\r\nstatic void i40e_tx_enable_csum(struct sk_buff *skb, u32 tx_flags,\r\nu32 *td_cmd, u32 *td_offset,\r\nstruct i40e_ring *tx_ring,\r\nu32 *cd_tunneling)\r\n{\r\nstruct ipv6hdr *this_ipv6_hdr;\r\nunsigned int this_tcp_hdrlen;\r\nstruct iphdr *this_ip_hdr;\r\nu32 network_hdr_len;\r\nu8 l4_hdr = 0;\r\nif (skb->encapsulation) {\r\nnetwork_hdr_len = skb_inner_network_header_len(skb);\r\nthis_ip_hdr = inner_ip_hdr(skb);\r\nthis_ipv6_hdr = inner_ipv6_hdr(skb);\r\nthis_tcp_hdrlen = inner_tcp_hdrlen(skb);\r\nif (tx_flags & I40E_TX_FLAGS_IPV4) {\r\nif (tx_flags & I40E_TX_FLAGS_TSO) {\r\n*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV4;\r\nip_hdr(skb)->check = 0;\r\n} else {\r\n*cd_tunneling |=\r\nI40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;\r\n}\r\n} else if (tx_flags & I40E_TX_FLAGS_IPV6) {\r\nif (tx_flags & I40E_TX_FLAGS_TSO) {\r\n*cd_tunneling |= I40E_TX_CTX_EXT_IP_IPV6;\r\nip_hdr(skb)->check = 0;\r\n} else {\r\n*cd_tunneling |=\r\nI40E_TX_CTX_EXT_IP_IPV4_NO_CSUM;\r\n}\r\n}\r\n*cd_tunneling |= (skb_network_header_len(skb) >> 2) <<\r\nI40E_TXD_CTX_QW0_EXT_IPLEN_SHIFT |\r\nI40E_TXD_CTX_UDP_TUNNELING |\r\n((skb_inner_network_offset(skb) -\r\nskb_transport_offset(skb)) >> 1) <<\r\nI40E_TXD_CTX_QW0_NATLEN_SHIFT;\r\n} else {\r\nnetwork_hdr_len = skb_network_header_len(skb);\r\nthis_ip_hdr = ip_hdr(skb);\r\nthis_ipv6_hdr = ipv6_hdr(skb);\r\nthis_tcp_hdrlen = tcp_hdrlen(skb);\r\n}\r\nif (tx_flags & I40E_TX_FLAGS_IPV4) {\r\nl4_hdr = this_ip_hdr->protocol;\r\nif (tx_flags & I40E_TX_FLAGS_TSO) {\r\n*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV4_CSUM;\r\nthis_ip_hdr->check = 0;\r\n} else {\r\n*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV4;\r\n}\r\n*td_offset = (network_hdr_len >> 2) <<\r\nI40E_TX_DESC_LENGTH_IPLEN_SHIFT;\r\n} else if (tx_flags & I40E_TX_FLAGS_IPV6) {\r\nl4_hdr = this_ipv6_hdr->nexthdr;\r\n*td_cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;\r\n*td_offset = (network_hdr_len >> 2) <<\r\nI40E_TX_DESC_LENGTH_IPLEN_SHIFT;\r\n}\r\n*td_offset |= (skb_network_offset(skb) >> 1) <<\r\nI40E_TX_DESC_LENGTH_MACLEN_SHIFT;\r\nswitch (l4_hdr) {\r\ncase IPPROTO_TCP:\r\n*td_cmd |= I40E_TX_DESC_CMD_L4T_EOFT_TCP;\r\n*td_offset |= (this_tcp_hdrlen >> 2) <<\r\nI40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;\r\nbreak;\r\ncase IPPROTO_SCTP:\r\n*td_cmd |= I40E_TX_DESC_CMD_L4T_EOFT_SCTP;\r\n*td_offset |= (sizeof(struct sctphdr) >> 2) <<\r\nI40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;\r\nbreak;\r\ncase IPPROTO_UDP:\r\n*td_cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;\r\n*td_offset |= (sizeof(struct udphdr) >> 2) <<\r\nI40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i40e_create_tx_ctx(struct i40e_ring *tx_ring,\r\nconst u64 cd_type_cmd_tso_mss,\r\nconst u32 cd_tunneling, const u32 cd_l2tag2)\r\n{\r\nstruct i40e_tx_context_desc *context_desc;\r\nint i = tx_ring->next_to_use;\r\nif ((cd_type_cmd_tso_mss == I40E_TX_DESC_DTYPE_CONTEXT) &&\r\n!cd_tunneling && !cd_l2tag2)\r\nreturn;\r\ncontext_desc = I40E_TX_CTXTDESC(tx_ring, i);\r\ni++;\r\ntx_ring->next_to_use = (i < tx_ring->count) ? i : 0;\r\ncontext_desc->tunneling_params = cpu_to_le32(cd_tunneling);\r\ncontext_desc->l2tag2 = cpu_to_le16(cd_l2tag2);\r\ncontext_desc->rsvd = cpu_to_le16(0);\r\ncontext_desc->type_cmd_tso_mss = cpu_to_le64(cd_type_cmd_tso_mss);\r\n}\r\nstatic void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,\r\nstruct i40e_tx_buffer *first, u32 tx_flags,\r\nconst u8 hdr_len, u32 td_cmd, u32 td_offset)\r\n{\r\nunsigned int data_len = skb->data_len;\r\nunsigned int size = skb_headlen(skb);\r\nstruct skb_frag_struct *frag;\r\nstruct i40e_tx_buffer *tx_bi;\r\nstruct i40e_tx_desc *tx_desc;\r\nu16 i = tx_ring->next_to_use;\r\nu32 td_tag = 0;\r\ndma_addr_t dma;\r\nu16 gso_segs;\r\nif (tx_flags & I40E_TX_FLAGS_HW_VLAN) {\r\ntd_cmd |= I40E_TX_DESC_CMD_IL2TAG1;\r\ntd_tag = (tx_flags & I40E_TX_FLAGS_VLAN_MASK) >>\r\nI40E_TX_FLAGS_VLAN_SHIFT;\r\n}\r\nif (tx_flags & (I40E_TX_FLAGS_TSO | I40E_TX_FLAGS_FSO))\r\ngso_segs = skb_shinfo(skb)->gso_segs;\r\nelse\r\ngso_segs = 1;\r\nfirst->bytecount = skb->len - hdr_len + (gso_segs * hdr_len);\r\nfirst->gso_segs = gso_segs;\r\nfirst->skb = skb;\r\nfirst->tx_flags = tx_flags;\r\ndma = dma_map_single(tx_ring->dev, skb->data, size, DMA_TO_DEVICE);\r\ntx_desc = I40E_TX_DESC(tx_ring, i);\r\ntx_bi = first;\r\nfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\r\nif (dma_mapping_error(tx_ring->dev, dma))\r\ngoto dma_error;\r\ndma_unmap_len_set(tx_bi, len, size);\r\ndma_unmap_addr_set(tx_bi, dma, dma);\r\ntx_desc->buffer_addr = cpu_to_le64(dma);\r\nwhile (unlikely(size > I40E_MAX_DATA_PER_TXD)) {\r\ntx_desc->cmd_type_offset_bsz =\r\nbuild_ctob(td_cmd, td_offset,\r\nI40E_MAX_DATA_PER_TXD, td_tag);\r\ntx_desc++;\r\ni++;\r\nif (i == tx_ring->count) {\r\ntx_desc = I40E_TX_DESC(tx_ring, 0);\r\ni = 0;\r\n}\r\ndma += I40E_MAX_DATA_PER_TXD;\r\nsize -= I40E_MAX_DATA_PER_TXD;\r\ntx_desc->buffer_addr = cpu_to_le64(dma);\r\n}\r\nif (likely(!data_len))\r\nbreak;\r\ntx_desc->cmd_type_offset_bsz = build_ctob(td_cmd, td_offset,\r\nsize, td_tag);\r\ntx_desc++;\r\ni++;\r\nif (i == tx_ring->count) {\r\ntx_desc = I40E_TX_DESC(tx_ring, 0);\r\ni = 0;\r\n}\r\nsize = skb_frag_size(frag);\r\ndata_len -= size;\r\ndma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\r\nDMA_TO_DEVICE);\r\ntx_bi = &tx_ring->tx_bi[i];\r\n}\r\n#define WB_STRIDE 0x3\r\nif (((i & WB_STRIDE) != WB_STRIDE) &&\r\n(first <= &tx_ring->tx_bi[i]) &&\r\n(first >= &tx_ring->tx_bi[i & ~WB_STRIDE])) {\r\ntx_desc->cmd_type_offset_bsz =\r\nbuild_ctob(td_cmd, td_offset, size, td_tag) |\r\ncpu_to_le64((u64)I40E_TX_DESC_CMD_EOP <<\r\nI40E_TXD_QW1_CMD_SHIFT);\r\n} else {\r\ntx_desc->cmd_type_offset_bsz =\r\nbuild_ctob(td_cmd, td_offset, size, td_tag) |\r\ncpu_to_le64((u64)I40E_TXD_CMD <<\r\nI40E_TXD_QW1_CMD_SHIFT);\r\n}\r\nnetdev_tx_sent_queue(netdev_get_tx_queue(tx_ring->netdev,\r\ntx_ring->queue_index),\r\nfirst->bytecount);\r\nfirst->time_stamp = jiffies;\r\nwmb();\r\nfirst->next_to_watch = tx_desc;\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\ntx_ring->next_to_use = i;\r\nwritel(i, tx_ring->tail);\r\nreturn;\r\ndma_error:\r\ndev_info(tx_ring->dev, "TX DMA map failed\n");\r\nfor (;;) {\r\ntx_bi = &tx_ring->tx_bi[i];\r\ni40e_unmap_and_free_tx_resource(tx_ring, tx_bi);\r\nif (tx_bi == first)\r\nbreak;\r\nif (i == 0)\r\ni = tx_ring->count;\r\ni--;\r\n}\r\ntx_ring->next_to_use = i;\r\n}\r\nstatic inline int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)\r\n{\r\nnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\r\nsmp_mb();\r\nif (likely(I40E_DESC_UNUSED(tx_ring) < size))\r\nreturn -EBUSY;\r\nnetif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);\r\n++tx_ring->tx_stats.restart_queue;\r\nreturn 0;\r\n}\r\nstatic int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)\r\n{\r\nif (likely(I40E_DESC_UNUSED(tx_ring) >= size))\r\nreturn 0;\r\nreturn __i40e_maybe_stop_tx(tx_ring, size);\r\n}\r\nstatic int i40e_xmit_descriptor_count(struct sk_buff *skb,\r\nstruct i40e_ring *tx_ring)\r\n{\r\nunsigned int f;\r\nint count = 0;\r\nfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\r\ncount += TXD_USE_COUNT(skb_shinfo(skb)->frags[f].size);\r\ncount += TXD_USE_COUNT(skb_headlen(skb));\r\nif (i40e_maybe_stop_tx(tx_ring, count + 4 + 1)) {\r\ntx_ring->tx_stats.tx_busy++;\r\nreturn 0;\r\n}\r\nreturn count;\r\n}\r\nstatic netdev_tx_t i40e_xmit_frame_ring(struct sk_buff *skb,\r\nstruct i40e_ring *tx_ring)\r\n{\r\nu64 cd_type_cmd_tso_mss = I40E_TX_DESC_DTYPE_CONTEXT;\r\nu32 cd_tunneling = 0, cd_l2tag2 = 0;\r\nstruct i40e_tx_buffer *first;\r\nu32 td_offset = 0;\r\nu32 tx_flags = 0;\r\n__be16 protocol;\r\nu32 td_cmd = 0;\r\nu8 hdr_len = 0;\r\nint tso;\r\nif (0 == i40e_xmit_descriptor_count(skb, tx_ring))\r\nreturn NETDEV_TX_BUSY;\r\nif (i40e_tx_prepare_vlan_flags(skb, tx_ring, &tx_flags))\r\ngoto out_drop;\r\nprotocol = vlan_get_protocol(skb);\r\nfirst = &tx_ring->tx_bi[tx_ring->next_to_use];\r\nif (protocol == htons(ETH_P_IP))\r\ntx_flags |= I40E_TX_FLAGS_IPV4;\r\nelse if (protocol == htons(ETH_P_IPV6))\r\ntx_flags |= I40E_TX_FLAGS_IPV6;\r\ntso = i40e_tso(tx_ring, skb, tx_flags, protocol, &hdr_len,\r\n&cd_type_cmd_tso_mss, &cd_tunneling);\r\nif (tso < 0)\r\ngoto out_drop;\r\nelse if (tso)\r\ntx_flags |= I40E_TX_FLAGS_TSO;\r\nskb_tx_timestamp(skb);\r\ntd_cmd |= I40E_TX_DESC_CMD_ICRC;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\ntx_flags |= I40E_TX_FLAGS_CSUM;\r\ni40e_tx_enable_csum(skb, tx_flags, &td_cmd, &td_offset,\r\ntx_ring, &cd_tunneling);\r\n}\r\ni40e_create_tx_ctx(tx_ring, cd_type_cmd_tso_mss,\r\ncd_tunneling, cd_l2tag2);\r\ni40e_tx_map(tx_ring, skb, first, tx_flags, hdr_len,\r\ntd_cmd, td_offset);\r\ni40e_maybe_stop_tx(tx_ring, DESC_NEEDED);\r\nreturn NETDEV_TX_OK;\r\nout_drop:\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetdev_tx_t i40evf_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct i40evf_adapter *adapter = netdev_priv(netdev);\r\nstruct i40e_ring *tx_ring = adapter->tx_rings[skb->queue_mapping];\r\nif (unlikely(skb->len < I40E_MIN_TX_LEN)) {\r\nif (skb_pad(skb, I40E_MIN_TX_LEN - skb->len))\r\nreturn NETDEV_TX_OK;\r\nskb->len = I40E_MIN_TX_LEN;\r\nskb_set_tail_pointer(skb, I40E_MIN_TX_LEN);\r\n}\r\nreturn i40e_xmit_frame_ring(skb, tx_ring);\r\n}
