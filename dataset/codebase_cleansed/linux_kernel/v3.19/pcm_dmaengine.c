static inline struct dmaengine_pcm_runtime_data *substream_to_prtd(\r\nconst struct snd_pcm_substream *substream)\r\n{\r\nreturn substream->runtime->private_data;\r\n}\r\nstruct dma_chan *snd_dmaengine_pcm_get_chan(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nreturn prtd->dma_chan;\r\n}\r\nint snd_hwparams_to_dma_slave_config(const struct snd_pcm_substream *substream,\r\nconst struct snd_pcm_hw_params *params,\r\nstruct dma_slave_config *slave_config)\r\n{\r\nenum dma_slave_buswidth buswidth;\r\nint bits;\r\nbits = params_physical_width(params);\r\nif (bits < 8 || bits > 64)\r\nreturn -EINVAL;\r\nelse if (bits == 8)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nelse if (bits == 16)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nelse if (bits == 24)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_3_BYTES;\r\nelse if (bits <= 32)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nelse\r\nbuswidth = DMA_SLAVE_BUSWIDTH_8_BYTES;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nslave_config->direction = DMA_MEM_TO_DEV;\r\nslave_config->dst_addr_width = buswidth;\r\n} else {\r\nslave_config->direction = DMA_DEV_TO_MEM;\r\nslave_config->src_addr_width = buswidth;\r\n}\r\nslave_config->device_fc = false;\r\nreturn 0;\r\n}\r\nvoid snd_dmaengine_pcm_set_config_from_dai_data(\r\nconst struct snd_pcm_substream *substream,\r\nconst struct snd_dmaengine_dai_dma_data *dma_data,\r\nstruct dma_slave_config *slave_config)\r\n{\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nslave_config->dst_addr = dma_data->addr;\r\nslave_config->dst_maxburst = dma_data->maxburst;\r\nif (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)\r\nslave_config->dst_addr_width = dma_data->addr_width;\r\n} else {\r\nslave_config->src_addr = dma_data->addr;\r\nslave_config->src_maxburst = dma_data->maxburst;\r\nif (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)\r\nslave_config->src_addr_width = dma_data->addr_width;\r\n}\r\nslave_config->slave_id = dma_data->slave_id;\r\n}\r\nstatic void dmaengine_pcm_dma_complete(void *arg)\r\n{\r\nstruct snd_pcm_substream *substream = arg;\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nprtd->pos += snd_pcm_lib_period_bytes(substream);\r\nif (prtd->pos >= snd_pcm_lib_buffer_bytes(substream))\r\nprtd->pos = 0;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nstruct dma_chan *chan = prtd->dma_chan;\r\nstruct dma_async_tx_descriptor *desc;\r\nenum dma_transfer_direction direction;\r\nunsigned long flags = DMA_CTRL_ACK;\r\ndirection = snd_pcm_substream_to_dma_direction(substream);\r\nif (!substream->runtime->no_period_wakeup)\r\nflags |= DMA_PREP_INTERRUPT;\r\nprtd->pos = 0;\r\ndesc = dmaengine_prep_dma_cyclic(chan,\r\nsubstream->runtime->dma_addr,\r\nsnd_pcm_lib_buffer_bytes(substream),\r\nsnd_pcm_lib_period_bytes(substream), direction, flags);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->callback = dmaengine_pcm_dma_complete;\r\ndesc->callback_param = substream;\r\nprtd->cookie = dmaengine_submit(desc);\r\nreturn 0;\r\n}\r\nint snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nret = dmaengine_pcm_prepare_and_submit(substream);\r\nif (ret)\r\nreturn ret;\r\ndma_async_issue_pending(prtd->dma_chan);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndmaengine_resume(prtd->dma_chan);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (runtime->info & SNDRV_PCM_INFO_PAUSE)\r\ndmaengine_pause(prtd->dma_chan);\r\nelse\r\ndmaengine_terminate_all(prtd->dma_chan);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndmaengine_pause(prtd->dma_chan);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndmaengine_terminate_all(prtd->dma_chan);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nsnd_pcm_uframes_t snd_dmaengine_pcm_pointer_no_residue(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nreturn bytes_to_frames(substream->runtime, prtd->pos);\r\n}\r\nsnd_pcm_uframes_t snd_dmaengine_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nunsigned int buf_size;\r\nunsigned int pos = 0;\r\nstatus = dmaengine_tx_status(prtd->dma_chan, prtd->cookie, &state);\r\nif (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {\r\nbuf_size = snd_pcm_lib_buffer_bytes(substream);\r\nif (state.residue > 0 && state.residue <= buf_size)\r\npos = buf_size - state.residue;\r\n}\r\nreturn bytes_to_frames(substream->runtime, pos);\r\n}\r\nstruct dma_chan *snd_dmaengine_pcm_request_channel(dma_filter_fn filter_fn,\r\nvoid *filter_data)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_CYCLIC, mask);\r\nreturn dma_request_channel(mask, filter_fn, filter_data);\r\n}\r\nint snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,\r\nstruct dma_chan *chan)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd;\r\nint ret;\r\nif (!chan)\r\nreturn -ENXIO;\r\nret = snd_pcm_hw_constraint_integer(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\r\nif (!prtd)\r\nreturn -ENOMEM;\r\nprtd->dma_chan = chan;\r\nsubstream->runtime->private_data = prtd;\r\nreturn 0;\r\n}\r\nint snd_dmaengine_pcm_open_request_chan(struct snd_pcm_substream *substream,\r\ndma_filter_fn filter_fn, void *filter_data)\r\n{\r\nreturn snd_dmaengine_pcm_open(substream,\r\nsnd_dmaengine_pcm_request_channel(filter_fn, filter_data));\r\n}\r\nint snd_dmaengine_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\nkfree(prtd);\r\nreturn 0;\r\n}\r\nint snd_dmaengine_pcm_close_release_chan(struct snd_pcm_substream *substream)\r\n{\r\nstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\r\ndma_release_channel(prtd->dma_chan);\r\nreturn snd_dmaengine_pcm_close(substream);\r\n}
