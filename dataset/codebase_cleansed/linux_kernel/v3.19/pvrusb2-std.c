static const struct std_name *find_std_name(const struct std_name *arrPtr,\r\nunsigned int arrSize,\r\nconst char *bufPtr,\r\nunsigned int bufSize)\r\n{\r\nunsigned int idx;\r\nconst struct std_name *p;\r\nfor (idx = 0; idx < arrSize; idx++) {\r\np = arrPtr + idx;\r\nif (strlen(p->name) != bufSize) continue;\r\nif (!memcmp(bufPtr,p->name,bufSize)) return p;\r\n}\r\nreturn NULL;\r\n}\r\nint pvr2_std_str_to_id(v4l2_std_id *idPtr,const char *bufPtr,\r\nunsigned int bufSize)\r\n{\r\nv4l2_std_id id = 0;\r\nv4l2_std_id cmsk = 0;\r\nv4l2_std_id t;\r\nint mMode = 0;\r\nunsigned int cnt;\r\nchar ch;\r\nconst struct std_name *sp;\r\nwhile (bufSize) {\r\nif (!mMode) {\r\ncnt = 0;\r\nwhile ((cnt < bufSize) && (bufPtr[cnt] != '-')) cnt++;\r\nif (cnt >= bufSize) return 0;\r\nsp = find_std_name(std_groups, ARRAY_SIZE(std_groups),\r\nbufPtr,cnt);\r\nif (!sp) return 0;\r\ncnt++;\r\nbufPtr += cnt;\r\nbufSize -= cnt;\r\nmMode = !0;\r\ncmsk = sp->id;\r\ncontinue;\r\n}\r\ncnt = 0;\r\nwhile (cnt < bufSize) {\r\nch = bufPtr[cnt];\r\nif (ch == ';') {\r\nmMode = 0;\r\nbreak;\r\n}\r\nif (ch == '/') break;\r\ncnt++;\r\n}\r\nsp = find_std_name(std_items, ARRAY_SIZE(std_items),\r\nbufPtr,cnt);\r\nif (!sp) return 0;\r\nt = sp->id & cmsk;\r\nif (!t) return 0;\r\nid |= t;\r\nif (cnt < bufSize) cnt++;\r\nbufPtr += cnt;\r\nbufSize -= cnt;\r\n}\r\nif (idPtr) *idPtr = id;\r\nreturn !0;\r\n}\r\nunsigned int pvr2_std_id_to_str(char *bufPtr, unsigned int bufSize,\r\nv4l2_std_id id)\r\n{\r\nunsigned int idx1,idx2;\r\nconst struct std_name *ip,*gp;\r\nint gfl,cfl;\r\nunsigned int c1,c2;\r\ncfl = 0;\r\nc1 = 0;\r\nfor (idx1 = 0; idx1 < ARRAY_SIZE(std_groups); idx1++) {\r\ngp = std_groups + idx1;\r\ngfl = 0;\r\nfor (idx2 = 0; idx2 < ARRAY_SIZE(std_items); idx2++) {\r\nip = std_items + idx2;\r\nif (!(gp->id & ip->id & id)) continue;\r\nif (!gfl) {\r\nif (cfl) {\r\nc2 = scnprintf(bufPtr,bufSize,";");\r\nc1 += c2;\r\nbufSize -= c2;\r\nbufPtr += c2;\r\n}\r\ncfl = !0;\r\nc2 = scnprintf(bufPtr,bufSize,\r\n"%s-",gp->name);\r\ngfl = !0;\r\n} else {\r\nc2 = scnprintf(bufPtr,bufSize,"/");\r\n}\r\nc1 += c2;\r\nbufSize -= c2;\r\nbufPtr += c2;\r\nc2 = scnprintf(bufPtr,bufSize,\r\nip->name);\r\nc1 += c2;\r\nbufSize -= c2;\r\nbufPtr += c2;\r\n}\r\n}\r\nreturn c1;\r\n}\r\nstatic struct v4l2_standard *match_std(v4l2_std_id id)\r\n{\r\nunsigned int idx;\r\nfor (idx = 0; idx < ARRAY_SIZE(generic_standards); idx++) {\r\nif (generic_standards[idx].id & id) {\r\nreturn generic_standards + idx;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pvr2_std_fill(struct v4l2_standard *std,v4l2_std_id id)\r\n{\r\nstruct v4l2_standard *template;\r\nint idx;\r\nunsigned int bcnt;\r\ntemplate = match_std(id);\r\nif (!template) return 0;\r\nidx = std->index;\r\nmemcpy(std,template,sizeof(*template));\r\nstd->index = idx;\r\nstd->id = id;\r\nbcnt = pvr2_std_id_to_str(std->name,sizeof(std->name)-1,id);\r\nstd->name[bcnt] = 0;\r\npvr2_trace(PVR2_TRACE_STD,"Set up standard idx=%u name=%s",\r\nstd->index,std->name);\r\nreturn !0;\r\n}\r\nstruct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr,\r\nv4l2_std_id id)\r\n{\r\nunsigned int std_cnt = 0;\r\nunsigned int idx,bcnt,idx2;\r\nv4l2_std_id idmsk,cmsk,fmsk;\r\nstruct v4l2_standard *stddefs;\r\nif (pvrusb2_debug & PVR2_TRACE_STD) {\r\nchar buf[100];\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),id);\r\npvr2_trace(\r\nPVR2_TRACE_STD,"Mapping standards mask=0x%x (%.*s)",\r\n(int)id,bcnt,buf);\r\n}\r\n*countptr = 0;\r\nstd_cnt = 0;\r\nfmsk = 0;\r\nfor (idmsk = 1, cmsk = id; cmsk; idmsk <<= 1) {\r\nif (!(idmsk & cmsk)) continue;\r\ncmsk &= ~idmsk;\r\nif (match_std(idmsk)) {\r\nstd_cnt++;\r\ncontinue;\r\n}\r\nfmsk |= idmsk;\r\n}\r\nfor (idx2 = 0; idx2 < ARRAY_SIZE(std_mixes); idx2++) {\r\nif ((id & std_mixes[idx2]) == std_mixes[idx2]) std_cnt++;\r\n}\r\nfmsk &= ~CSTD_ATSC;\r\nif (fmsk) {\r\nchar buf[100];\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),fmsk);\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"WARNING:"\r\n" Failed to classify the following standard(s): %.*s",\r\nbcnt,buf);\r\n}\r\npvr2_trace(PVR2_TRACE_STD,"Setting up %u unique standard(s)",\r\nstd_cnt);\r\nif (!std_cnt) return NULL;\r\nstddefs = kzalloc(sizeof(struct v4l2_standard) * std_cnt,\r\nGFP_KERNEL);\r\nif (!stddefs)\r\nreturn NULL;\r\nfor (idx = 0; idx < std_cnt; idx++)\r\nstddefs[idx].index = idx;\r\nidx = 0;\r\nfor (idx2 = 0; (idx2 < ARRAY_SIZE(std_mixes)) && (idx < std_cnt);\r\nidx2++) {\r\nif (!(id & std_mixes[idx2])) continue;\r\nif (pvr2_std_fill(stddefs+idx,std_mixes[idx2])) idx++;\r\n}\r\nfor (idmsk = 1, cmsk = id; cmsk && (idx < std_cnt); idmsk <<= 1) {\r\nif (!(idmsk & cmsk)) continue;\r\ncmsk &= ~idmsk;\r\nif (!pvr2_std_fill(stddefs+idx,idmsk)) continue;\r\nidx++;\r\n}\r\n*countptr = std_cnt;\r\nreturn stddefs;\r\n}\r\nv4l2_std_id pvr2_std_get_usable(void)\r\n{\r\nreturn CSTD_ALL;\r\n}
