int __init db1000_board_setup(void)\r\n{\r\nbcsr_init(DB1000_BCSR_PHYS_ADDR,\r\nDB1000_BCSR_PHYS_ADDR + DB1000_BCSR_HEXLED_OFS);\r\nswitch (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI))) {\r\ncase BCSR_WHOAMI_DB1000:\r\ncase BCSR_WHOAMI_DB1500:\r\ncase BCSR_WHOAMI_DB1100:\r\ncase BCSR_WHOAMI_PB1500:\r\ncase BCSR_WHOAMI_PB1500R2:\r\ncase BCSR_WHOAMI_PB1100:\r\npr_info("AMD Alchemy %s Board\n", get_system_type());\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int db1500_map_pci_irq(const struct pci_dev *d, u8 slot, u8 pin)\r\n{\r\nif ((slot < 12) || (slot > 13) || pin == 0)\r\nreturn -1;\r\nif (slot == 12)\r\nreturn (pin == 1) ? AU1500_PCI_INTA : 0xff;\r\nif (slot == 13) {\r\nswitch (pin) {\r\ncase 1: return AU1500_PCI_INTA;\r\ncase 2: return AU1500_PCI_INTB;\r\ncase 3: return AU1500_PCI_INTC;\r\ncase 4: return AU1500_PCI_INTD;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint __init db1500_pci_setup(void)\r\n{\r\nreturn platform_device_register(&db1500_pci_host_dev);\r\n}\r\nstatic irqreturn_t db1100_mmc_cd(int irq, void *ptr)\r\n{\r\nvoid (*mmc_cd)(struct mmc_host *, unsigned long);\r\nmmc_cd = symbol_get(mmc_detect_change);\r\nmmc_cd(ptr, msecs_to_jiffies(500));\r\nsymbol_put(mmc_detect_change);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int db1100_mmc_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret = 0, irq;\r\nif (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI)) == BCSR_WHOAMI_DB1100)\r\nirq = AU1100_GPIO19_INT;\r\nelse\r\nirq = AU1100_GPIO14_INT;\r\nif (en) {\r\nirq_set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(irq, db1100_mmc_cd, 0,\r\n"sd0_cd", mmc_host);\r\n} else\r\nfree_irq(irq, mmc_host);\r\nreturn ret;\r\n}\r\nstatic int db1100_mmc1_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret = 0, irq;\r\nif (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI)) == BCSR_WHOAMI_DB1100)\r\nirq = AU1100_GPIO20_INT;\r\nelse\r\nirq = AU1100_GPIO15_INT;\r\nif (en) {\r\nirq_set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(irq, db1100_mmc_cd, 0,\r\n"sd1_cd", mmc_host);\r\n} else\r\nfree_irq(irq, mmc_host);\r\nreturn ret;\r\n}\r\nstatic int db1100_mmc_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_STATUS) & BCSR_STATUS_SD0WP) ? 0 : 1;\r\n}\r\nstatic int db1100_mmc_card_inserted(void *mmc_host)\r\n{\r\nreturn !alchemy_gpio_get_value(19);\r\n}\r\nstatic void db1100_mmc_set_power(void *mmc_host, int state)\r\n{\r\nint bit;\r\nif (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI)) == BCSR_WHOAMI_DB1100)\r\nbit = BCSR_BOARD_SD0PWR;\r\nelse\r\nbit = BCSR_BOARD_PB1100_SD0PWR;\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, bit);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, bit, 0);\r\n}\r\nstatic void db1100_mmcled_set(struct led_classdev *led, enum led_brightness b)\r\n{\r\nif (b != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED0, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED0);\r\n}\r\nstatic int db1100_mmc1_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_BOARD) & BCSR_BOARD_SD1WP) ? 1 : 0;\r\n}\r\nstatic int db1100_mmc1_card_inserted(void *mmc_host)\r\n{\r\nreturn !alchemy_gpio_get_value(20);\r\n}\r\nstatic void db1100_mmc1_set_power(void *mmc_host, int state)\r\n{\r\nint bit;\r\nif (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI)) == BCSR_WHOAMI_DB1100)\r\nbit = BCSR_BOARD_SD1PWR;\r\nelse\r\nbit = BCSR_BOARD_PB1100_SD1PWR;\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, bit);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, bit, 0);\r\n}\r\nstatic void db1100_mmc1led_set(struct led_classdev *led, enum led_brightness b)\r\n{\r\nif (b != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED1, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED1);\r\n}\r\nstatic void db1000_irda_set_phy_mode(int mode)\r\n{\r\nunsigned short mask = BCSR_RESETS_IRDA_MODE_MASK | BCSR_RESETS_FIR_SEL;\r\nswitch (mode) {\r\ncase AU1000_IRDA_PHY_MODE_OFF:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_OFF);\r\nbreak;\r\ncase AU1000_IRDA_PHY_MODE_SIR:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_FULL);\r\nbreak;\r\ncase AU1000_IRDA_PHY_MODE_FIR:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_FULL |\r\nBCSR_RESETS_FIR_SEL);\r\nbreak;\r\n}\r\n}\r\nint __init db1000_dev_setup(void)\r\n{\r\nint board = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\r\nint c0, c1, d0, d1, s0, s1, flashsize = 32, twosocks = 1;\r\nunsigned long pfc;\r\nstruct clk *c, *p;\r\nif (board == BCSR_WHOAMI_DB1500) {\r\nc0 = AU1500_GPIO2_INT;\r\nc1 = AU1500_GPIO5_INT;\r\nd0 = AU1500_GPIO0_INT;\r\nd1 = AU1500_GPIO3_INT;\r\ns0 = AU1500_GPIO1_INT;\r\ns1 = AU1500_GPIO4_INT;\r\n} else if (board == BCSR_WHOAMI_DB1100) {\r\nc0 = AU1100_GPIO2_INT;\r\nc1 = AU1100_GPIO5_INT;\r\nd0 = AU1100_GPIO0_INT;\r\nd1 = AU1100_GPIO3_INT;\r\ns0 = AU1100_GPIO1_INT;\r\ns1 = AU1100_GPIO4_INT;\r\ngpio_request(19, "sd0_cd");\r\ngpio_request(20, "sd1_cd");\r\ngpio_direction_input(19);\r\ngpio_direction_input(20);\r\npfc = alchemy_rdsys(AU1000_SYS_PINFUNC);\r\npfc |= (1 << 0);\r\nalchemy_wrsys(pfc, AU1000_SYS_PINFUNC);\r\nspi_register_board_info(db1100_spi_info,\r\nARRAY_SIZE(db1100_spi_info));\r\np = clk_get(NULL, "auxpll_clk");\r\nc = clk_get(NULL, "lcd_intclk");\r\nif (!IS_ERR(c) && !IS_ERR(p)) {\r\nclk_set_parent(c, p);\r\nclk_set_rate(c, clk_get_rate(p));\r\n}\r\nif (!IS_ERR(c))\r\nclk_put(c);\r\nif (!IS_ERR(p))\r\nclk_put(p);\r\nplatform_add_devices(db1100_devs, ARRAY_SIZE(db1100_devs));\r\nplatform_device_register(&db1100_spi_dev);\r\n} else if (board == BCSR_WHOAMI_DB1000) {\r\nc0 = AU1000_GPIO2_INT;\r\nc1 = AU1000_GPIO5_INT;\r\nd0 = AU1000_GPIO0_INT;\r\nd1 = AU1000_GPIO3_INT;\r\ns0 = AU1000_GPIO1_INT;\r\ns1 = AU1000_GPIO4_INT;\r\nplatform_add_devices(db1000_devs, ARRAY_SIZE(db1000_devs));\r\n} else if ((board == BCSR_WHOAMI_PB1500) ||\r\n(board == BCSR_WHOAMI_PB1500R2)) {\r\nc0 = AU1500_GPIO203_INT;\r\nd0 = AU1500_GPIO201_INT;\r\ns0 = AU1500_GPIO202_INT;\r\ntwosocks = 0;\r\nflashsize = 64;\r\nirq_set_irq_type(AU1500_GPIO204_INT, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(AU1500_GPIO205_INT, IRQ_TYPE_LEVEL_LOW);\r\n} else if (board == BCSR_WHOAMI_PB1100) {\r\nc0 = AU1100_GPIO11_INT;\r\nd0 = AU1100_GPIO9_INT;\r\ns0 = AU1100_GPIO10_INT;\r\ntwosocks = 0;\r\nflashsize = 64;\r\nirq_set_irq_type(AU1100_GPIO8_INT, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(AU1100_GPIO12_INT, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(AU1100_GPIO13_INT, IRQ_TYPE_LEVEL_LOW);\r\nplatform_add_devices(db1100_devs, ARRAY_SIZE(db1100_devs));\r\n} else\r\nreturn 0;\r\nirq_set_irq_type(d0, IRQ_TYPE_EDGE_BOTH);\r\nirq_set_irq_type(c0, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(s0, IRQ_TYPE_LEVEL_LOW);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x000010000 - 1,\r\nc0, d0, 0, 0, 0);\r\nif (twosocks) {\r\nirq_set_irq_type(d1, IRQ_TYPE_EDGE_BOTH);\r\nirq_set_irq_type(c1, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(s1, IRQ_TYPE_LEVEL_LOW);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004010000 - 1,\r\nc1, d1, 0, 0, 1);\r\n}\r\nplatform_add_devices(db1x00_devs, ARRAY_SIZE(db1x00_devs));\r\ndb1x_register_norflash(flashsize << 20, 4 , F_SWAPPED);\r\nreturn 0;\r\n}
