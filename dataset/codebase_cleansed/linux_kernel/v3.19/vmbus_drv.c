static int vmbus_exists(void)\r\n{\r\nif (hv_acpi_dev == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void print_alias_name(struct hv_device *hv_dev, char *alias_name)\r\n{\r\nint i;\r\nfor (i = 0; i < VMBUS_ALIAS_LEN; i += 2)\r\nsprintf(&alias_name[i], "%02x", hv_dev->dev_type.b[i/2]);\r\n}\r\nstatic u8 channel_monitor_group(struct vmbus_channel *channel)\r\n{\r\nreturn (u8)channel->offermsg.monitorid / 32;\r\n}\r\nstatic u8 channel_monitor_offset(struct vmbus_channel *channel)\r\n{\r\nreturn (u8)channel->offermsg.monitorid % 32;\r\n}\r\nstatic u32 channel_pending(struct vmbus_channel *channel,\r\nstruct hv_monitor_page *monitor_page)\r\n{\r\nu8 monitor_group = channel_monitor_group(channel);\r\nreturn monitor_page->trigger_group[monitor_group].pending;\r\n}\r\nstatic u32 channel_latency(struct vmbus_channel *channel,\r\nstruct hv_monitor_page *monitor_page)\r\n{\r\nu8 monitor_group = channel_monitor_group(channel);\r\nu8 monitor_offset = channel_monitor_offset(channel);\r\nreturn monitor_page->latency[monitor_group][monitor_offset];\r\n}\r\nstatic u32 channel_conn_id(struct vmbus_channel *channel,\r\nstruct hv_monitor_page *monitor_page)\r\n{\r\nu8 monitor_group = channel_monitor_group(channel);\r\nu8 monitor_offset = channel_monitor_offset(channel);\r\nreturn monitor_page->parameter[monitor_group][monitor_offset].connectionid.u.id;\r\n}\r\nstatic ssize_t id_show(struct device *dev, struct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n", hv_dev->channel->offermsg.child_relid);\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n", hv_dev->channel->state);\r\n}\r\nstatic ssize_t monitor_id_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n", hv_dev->channel->offermsg.monitorid);\r\n}\r\nstatic ssize_t class_id_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "{%pUl}\n",\r\nhv_dev->channel->offermsg.offer.if_type.b);\r\n}\r\nstatic ssize_t device_id_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "{%pUl}\n",\r\nhv_dev->channel->offermsg.offer.if_instance.b);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nchar alias_name[VMBUS_ALIAS_LEN + 1];\r\nprint_alias_name(hv_dev, alias_name);\r\nreturn sprintf(buf, "vmbus:%s\n", alias_name);\r\n}\r\nstatic ssize_t server_monitor_pending_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_pending(hv_dev->channel,\r\nvmbus_connection.monitor_pages[1]));\r\n}\r\nstatic ssize_t client_monitor_pending_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_pending(hv_dev->channel,\r\nvmbus_connection.monitor_pages[1]));\r\n}\r\nstatic ssize_t server_monitor_latency_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_latency(hv_dev->channel,\r\nvmbus_connection.monitor_pages[0]));\r\n}\r\nstatic ssize_t client_monitor_latency_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_latency(hv_dev->channel,\r\nvmbus_connection.monitor_pages[1]));\r\n}\r\nstatic ssize_t server_monitor_conn_id_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_conn_id(hv_dev->channel,\r\nvmbus_connection.monitor_pages[0]));\r\n}\r\nstatic ssize_t client_monitor_conn_id_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n",\r\nchannel_conn_id(hv_dev->channel,\r\nvmbus_connection.monitor_pages[1]));\r\n}\r\nstatic ssize_t out_intr_mask_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info outbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);\r\nreturn sprintf(buf, "%d\n", outbound.current_interrupt_mask);\r\n}\r\nstatic ssize_t out_read_index_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info outbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);\r\nreturn sprintf(buf, "%d\n", outbound.current_read_index);\r\n}\r\nstatic ssize_t out_write_index_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info outbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);\r\nreturn sprintf(buf, "%d\n", outbound.current_write_index);\r\n}\r\nstatic ssize_t out_read_bytes_avail_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info outbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);\r\nreturn sprintf(buf, "%d\n", outbound.bytes_avail_toread);\r\n}\r\nstatic ssize_t out_write_bytes_avail_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info outbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);\r\nreturn sprintf(buf, "%d\n", outbound.bytes_avail_towrite);\r\n}\r\nstatic ssize_t in_intr_mask_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info inbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);\r\nreturn sprintf(buf, "%d\n", inbound.current_interrupt_mask);\r\n}\r\nstatic ssize_t in_read_index_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info inbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);\r\nreturn sprintf(buf, "%d\n", inbound.current_read_index);\r\n}\r\nstatic ssize_t in_write_index_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info inbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);\r\nreturn sprintf(buf, "%d\n", inbound.current_write_index);\r\n}\r\nstatic ssize_t in_read_bytes_avail_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info inbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);\r\nreturn sprintf(buf, "%d\n", inbound.bytes_avail_toread);\r\n}\r\nstatic ssize_t in_write_bytes_avail_show(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_ring_buffer_debug_info inbound;\r\nif (!hv_dev->channel)\r\nreturn -ENODEV;\r\nhv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);\r\nreturn sprintf(buf, "%d\n", inbound.bytes_avail_towrite);\r\n}\r\nstatic int vmbus_uevent(struct device *device, struct kobj_uevent_env *env)\r\n{\r\nstruct hv_device *dev = device_to_hv_device(device);\r\nint ret;\r\nchar alias_name[VMBUS_ALIAS_LEN + 1];\r\nprint_alias_name(dev, alias_name);\r\nret = add_uevent_var(env, "MODALIAS=vmbus:%s", alias_name);\r\nreturn ret;\r\n}\r\nstatic inline bool is_null_guid(const __u8 *guid)\r\n{\r\nif (memcmp(guid, &null_guid, sizeof(uuid_le)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic const struct hv_vmbus_device_id *hv_vmbus_get_id(\r\nconst struct hv_vmbus_device_id *id,\r\nconst __u8 *guid)\r\n{\r\nfor (; !is_null_guid(id->guid); id++)\r\nif (!memcmp(&id->guid, guid, sizeof(uuid_le)))\r\nreturn id;\r\nreturn NULL;\r\n}\r\nstatic int vmbus_match(struct device *device, struct device_driver *driver)\r\n{\r\nstruct hv_driver *drv = drv_to_hv_drv(driver);\r\nstruct hv_device *hv_dev = device_to_hv_device(device);\r\nif (hv_vmbus_get_id(drv->id_table, hv_dev->dev_type.b))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vmbus_probe(struct device *child_device)\r\n{\r\nint ret = 0;\r\nstruct hv_driver *drv =\r\ndrv_to_hv_drv(child_device->driver);\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nconst struct hv_vmbus_device_id *dev_id;\r\ndev_id = hv_vmbus_get_id(drv->id_table, dev->dev_type.b);\r\nif (drv->probe) {\r\nret = drv->probe(dev, dev_id);\r\nif (ret != 0)\r\npr_err("probe failed for device %s (%d)\n",\r\ndev_name(child_device), ret);\r\n} else {\r\npr_err("probe not set for driver %s\n",\r\ndev_name(child_device));\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vmbus_remove(struct device *child_device)\r\n{\r\nstruct hv_driver *drv = drv_to_hv_drv(child_device->driver);\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nif (drv->remove)\r\ndrv->remove(dev);\r\nelse\r\npr_err("remove not set for driver %s\n",\r\ndev_name(child_device));\r\nreturn 0;\r\n}\r\nstatic void vmbus_shutdown(struct device *child_device)\r\n{\r\nstruct hv_driver *drv;\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nif (!child_device->driver)\r\nreturn;\r\ndrv = drv_to_hv_drv(child_device->driver);\r\nif (drv->shutdown)\r\ndrv->shutdown(dev);\r\nreturn;\r\n}\r\nstatic void vmbus_device_release(struct device *device)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(device);\r\nkfree(hv_dev);\r\n}\r\nstatic void vmbus_onmessage_work(struct work_struct *work)\r\n{\r\nstruct onmessage_work_context *ctx;\r\nctx = container_of(work, struct onmessage_work_context,\r\nwork);\r\nvmbus_onmessage(&ctx->msg);\r\nkfree(ctx);\r\n}\r\nstatic void vmbus_on_msg_dpc(unsigned long data)\r\n{\r\nint cpu = smp_processor_id();\r\nvoid *page_addr = hv_context.synic_message_page[cpu];\r\nstruct hv_message *msg = (struct hv_message *)page_addr +\r\nVMBUS_MESSAGE_SINT;\r\nstruct onmessage_work_context *ctx;\r\nwhile (1) {\r\nif (msg->header.message_type == HVMSG_NONE) {\r\nbreak;\r\n} else {\r\nctx = kmalloc(sizeof(*ctx), GFP_ATOMIC);\r\nif (ctx == NULL)\r\ncontinue;\r\nINIT_WORK(&ctx->work, vmbus_onmessage_work);\r\nmemcpy(&ctx->msg, msg, sizeof(*msg));\r\nqueue_work(vmbus_connection.work_queue, &ctx->work);\r\n}\r\nmsg->header.message_type = HVMSG_NONE;\r\nmb();\r\nif (msg->header.message_flags.msg_pending) {\r\nwrmsrl(HV_X64_MSR_EOM, 0);\r\n}\r\n}\r\n}\r\nstatic void vmbus_isr(void)\r\n{\r\nint cpu = smp_processor_id();\r\nvoid *page_addr;\r\nstruct hv_message *msg;\r\nunion hv_synic_event_flags *event;\r\nbool handled = false;\r\npage_addr = hv_context.synic_event_page[cpu];\r\nif (page_addr == NULL)\r\nreturn;\r\nevent = (union hv_synic_event_flags *)page_addr +\r\nVMBUS_MESSAGE_SINT;\r\nif ((vmbus_proto_version == VERSION_WS2008) ||\r\n(vmbus_proto_version == VERSION_WIN7)) {\r\nif (sync_test_and_clear_bit(0,\r\n(unsigned long *) &event->flags32[0])) {\r\nhandled = true;\r\n}\r\n} else {\r\nhandled = true;\r\n}\r\nif (handled)\r\ntasklet_schedule(hv_context.event_dpc[cpu]);\r\npage_addr = hv_context.synic_message_page[cpu];\r\nmsg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;\r\nif (msg->header.message_type != HVMSG_NONE)\r\ntasklet_schedule(&msg_dpc);\r\n}\r\nstatic int vmbus_bus_init(int irq)\r\n{\r\nint ret;\r\nret = hv_init();\r\nif (ret != 0) {\r\npr_err("Unable to initialize the hypervisor - 0x%x\n", ret);\r\nreturn ret;\r\n}\r\ntasklet_init(&msg_dpc, vmbus_on_msg_dpc, 0);\r\nret = bus_register(&hv_bus);\r\nif (ret)\r\ngoto err_cleanup;\r\nhv_setup_vmbus_irq(vmbus_isr);\r\nret = hv_synic_alloc();\r\nif (ret)\r\ngoto err_alloc;\r\non_each_cpu(hv_synic_init, NULL, 1);\r\nret = vmbus_connect();\r\nif (ret)\r\ngoto err_alloc;\r\nvmbus_request_offers();\r\nreturn 0;\r\nerr_alloc:\r\nhv_synic_free();\r\nhv_remove_vmbus_irq();\r\nbus_unregister(&hv_bus);\r\nerr_cleanup:\r\nhv_cleanup();\r\nreturn ret;\r\n}\r\nint __vmbus_driver_register(struct hv_driver *hv_driver, struct module *owner, const char *mod_name)\r\n{\r\nint ret;\r\npr_info("registering driver %s\n", hv_driver->name);\r\nret = vmbus_exists();\r\nif (ret < 0)\r\nreturn ret;\r\nhv_driver->driver.name = hv_driver->name;\r\nhv_driver->driver.owner = owner;\r\nhv_driver->driver.mod_name = mod_name;\r\nhv_driver->driver.bus = &hv_bus;\r\nret = driver_register(&hv_driver->driver);\r\nreturn ret;\r\n}\r\nvoid vmbus_driver_unregister(struct hv_driver *hv_driver)\r\n{\r\npr_info("unregistering driver %s\n", hv_driver->name);\r\nif (!vmbus_exists())\r\ndriver_unregister(&hv_driver->driver);\r\n}\r\nstruct hv_device *vmbus_device_create(const uuid_le *type,\r\nconst uuid_le *instance,\r\nstruct vmbus_channel *channel)\r\n{\r\nstruct hv_device *child_device_obj;\r\nchild_device_obj = kzalloc(sizeof(struct hv_device), GFP_KERNEL);\r\nif (!child_device_obj) {\r\npr_err("Unable to allocate device object for child device\n");\r\nreturn NULL;\r\n}\r\nchild_device_obj->channel = channel;\r\nmemcpy(&child_device_obj->dev_type, type, sizeof(uuid_le));\r\nmemcpy(&child_device_obj->dev_instance, instance,\r\nsizeof(uuid_le));\r\nreturn child_device_obj;\r\n}\r\nint vmbus_device_register(struct hv_device *child_device_obj)\r\n{\r\nint ret = 0;\r\nstatic atomic_t device_num = ATOMIC_INIT(0);\r\ndev_set_name(&child_device_obj->device, "vmbus_0_%d",\r\natomic_inc_return(&device_num));\r\nchild_device_obj->device.bus = &hv_bus;\r\nchild_device_obj->device.parent = &hv_acpi_dev->dev;\r\nchild_device_obj->device.release = vmbus_device_release;\r\nret = device_register(&child_device_obj->device);\r\nif (ret)\r\npr_err("Unable to register child device\n");\r\nelse\r\npr_debug("child device %s registered\n",\r\ndev_name(&child_device_obj->device));\r\nreturn ret;\r\n}\r\nvoid vmbus_device_unregister(struct hv_device *device_obj)\r\n{\r\npr_debug("child device %s unregistered\n",\r\ndev_name(&device_obj->device));\r\ndevice_unregister(&device_obj->device);\r\n}\r\nstatic acpi_status vmbus_walk_resources(struct acpi_resource *res, void *ctx)\r\n{\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\nirq = res->data.irq.interrupts[0];\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_ADDRESS64:\r\nhyperv_mmio.start = res->data.address64.minimum;\r\nhyperv_mmio.end = res->data.address64.maximum;\r\nbreak;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int vmbus_acpi_add(struct acpi_device *device)\r\n{\r\nacpi_status result;\r\nint ret_val = -ENODEV;\r\nhv_acpi_dev = device;\r\nresult = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nvmbus_walk_resources, NULL);\r\nif (ACPI_FAILURE(result))\r\ngoto acpi_walk_err;\r\nif (device->parent) {\r\nresult = acpi_walk_resources(device->parent->handle,\r\nMETHOD_NAME__CRS,\r\nvmbus_walk_resources, NULL);\r\nif (ACPI_FAILURE(result))\r\ngoto acpi_walk_err;\r\nif (hyperv_mmio.start && hyperv_mmio.end)\r\nrequest_resource(&iomem_resource, &hyperv_mmio);\r\n}\r\nret_val = 0;\r\nacpi_walk_err:\r\ncomplete(&probe_event);\r\nreturn ret_val;\r\n}\r\nstatic int __init hv_acpi_init(void)\r\n{\r\nint ret, t;\r\nif (x86_hyper != &x86_hyper_ms_hyperv)\r\nreturn -ENODEV;\r\ninit_completion(&probe_event);\r\nret = acpi_bus_register_driver(&vmbus_acpi_driver);\r\nif (ret)\r\nreturn ret;\r\nt = wait_for_completion_timeout(&probe_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (irq <= 0) {\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\nret = vmbus_bus_init(irq);\r\nif (ret)\r\ngoto cleanup;\r\nreturn 0;\r\ncleanup:\r\nacpi_bus_unregister_driver(&vmbus_acpi_driver);\r\nhv_acpi_dev = NULL;\r\nreturn ret;\r\n}\r\nstatic void __exit vmbus_exit(void)\r\n{\r\nhv_remove_vmbus_irq();\r\nvmbus_free_channels();\r\nbus_unregister(&hv_bus);\r\nhv_cleanup();\r\nacpi_bus_unregister_driver(&vmbus_acpi_driver);\r\n}
