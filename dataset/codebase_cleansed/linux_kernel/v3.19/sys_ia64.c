unsigned long\r\narch_get_unmapped_area (struct file *filp, unsigned long addr, unsigned long len,\r\nunsigned long pgoff, unsigned long flags)\r\n{\r\nlong map_shared = (flags & MAP_SHARED);\r\nunsigned long align_mask = 0;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_unmapped_area_info info;\r\nif (len > RGN_MAP_LIMIT)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED) {\r\nif (is_hugepage_only_range(mm, addr, len))\r\nreturn -EINVAL;\r\nreturn addr;\r\n}\r\n#ifdef CONFIG_HUGETLB_PAGE\r\nif (REGION_NUMBER(addr) == RGN_HPAGE)\r\naddr = 0;\r\n#endif\r\nif (!addr)\r\naddr = TASK_UNMAPPED_BASE;\r\nif (map_shared && (TASK_SIZE > 0xfffffffful))\r\nalign_mask = PAGE_MASK & (SHMLBA - 1);\r\ninfo.flags = 0;\r\ninfo.length = len;\r\ninfo.low_limit = addr;\r\ninfo.high_limit = TASK_SIZE;\r\ninfo.align_mask = align_mask;\r\ninfo.align_offset = 0;\r\nreturn vm_unmapped_area(&info);\r\n}\r\nasmlinkage long\r\nia64_getpriority (int which, int who)\r\n{\r\nlong prio;\r\nprio = sys_getpriority(which, who);\r\nif (prio >= 0) {\r\nforce_successful_syscall_return();\r\nprio = 20 - prio;\r\n}\r\nreturn prio;\r\n}\r\nasmlinkage unsigned long\r\nsys_getpagesize (void)\r\n{\r\nreturn PAGE_SIZE;\r\n}\r\nasmlinkage unsigned long\r\nia64_brk (unsigned long brk)\r\n{\r\nunsigned long retval = sys_brk(brk);\r\nforce_successful_syscall_return();\r\nreturn retval;\r\n}\r\nasmlinkage long\r\nsys_ia64_pipe (void)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nint fd[2];\r\nint retval;\r\nretval = do_pipe_flags(fd, 0);\r\nif (retval)\r\ngoto out;\r\nretval = fd[0];\r\nregs->r9 = fd[1];\r\nout:\r\nreturn retval;\r\n}\r\nint ia64_mmap_check(unsigned long addr, unsigned long len,\r\nunsigned long flags)\r\n{\r\nunsigned long roff;\r\nroff = REGION_OFFSET(addr);\r\nif ((len > RGN_MAP_LIMIT) || (roff > (RGN_MAP_LIMIT - len)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nasmlinkage unsigned long\r\nsys_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, long pgoff)\r\n{\r\naddr = sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\r\nif (!IS_ERR((void *) addr))\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage unsigned long\r\nsys_mmap (unsigned long addr, unsigned long len, int prot, int flags, int fd, long off)\r\n{\r\nif (offset_in_page(off) != 0)\r\nreturn -EINVAL;\r\naddr = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\r\nif (!IS_ERR((void *) addr))\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage unsigned long\r\nia64_mremap (unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags,\r\nunsigned long new_addr)\r\n{\r\naddr = sys_mremap(addr, old_len, new_len, flags, new_addr);\r\nif (!IS_ERR((void *) addr))\r\nforce_successful_syscall_return();\r\nreturn addr;\r\n}\r\nasmlinkage long\r\nsys_pciconfig_read (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,\r\nvoid *buf)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage long\r\nsys_pciconfig_write (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,\r\nvoid *buf)\r\n{\r\nreturn -ENOSYS;\r\n}
