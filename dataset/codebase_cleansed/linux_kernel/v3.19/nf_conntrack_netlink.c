static inline int\r\nctnetlink_dump_tuples_proto(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nint ret = 0;\r\nstruct nlattr *nest_parms;\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_PROTO | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, CTA_PROTO_NUM, tuple->dst.protonum))\r\ngoto nla_put_failure;\r\nif (likely(l4proto->tuple_to_nlattr))\r\nret = l4proto->tuple_to_nlattr(skb, tuple);\r\nnla_nest_end(skb, nest_parms);\r\nreturn ret;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_tuples_ip(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple,\r\nstruct nf_conntrack_l3proto *l3proto)\r\n{\r\nint ret = 0;\r\nstruct nlattr *nest_parms;\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_IP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (likely(l3proto->tuple_to_nlattr))\r\nret = l3proto->tuple_to_nlattr(skb, tuple);\r\nnla_nest_end(skb, nest_parms);\r\nreturn ret;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_dump_tuples(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nint ret;\r\nstruct nf_conntrack_l3proto *l3proto;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nrcu_read_lock();\r\nl3proto = __nf_ct_l3proto_find(tuple->src.l3num);\r\nret = ctnetlink_dump_tuples_ip(skb, tuple, l3proto);\r\nif (ret >= 0) {\r\nl4proto = __nf_ct_l4proto_find(tuple->src.l3num,\r\ntuple->dst.protonum);\r\nret = ctnetlink_dump_tuples_proto(skb, tuple, l4proto);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic inline int\r\nctnetlink_dump_status(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nif (nla_put_be32(skb, CTA_STATUS, htonl(ct->status)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_timeout(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nlong timeout = ((long)ct->timeout.expires - (long)jiffies) / HZ;\r\nif (timeout < 0)\r\ntimeout = 0;\r\nif (nla_put_be32(skb, CTA_TIMEOUT, htonl(timeout)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_protoinfo(struct sk_buff *skb, struct nf_conn *ct)\r\n{\r\nstruct nf_conntrack_l4proto *l4proto;\r\nstruct nlattr *nest_proto;\r\nint ret;\r\nl4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nif (!l4proto->to_nlattr)\r\nreturn 0;\r\nnest_proto = nla_nest_start(skb, CTA_PROTOINFO | NLA_F_NESTED);\r\nif (!nest_proto)\r\ngoto nla_put_failure;\r\nret = l4proto->to_nlattr(skb, nest_proto, ct);\r\nnla_nest_end(skb, nest_proto);\r\nreturn ret;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_helpinfo(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_helper;\r\nconst struct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_helper *helper;\r\nif (!help)\r\nreturn 0;\r\nhelper = rcu_dereference(help->helper);\r\nif (!helper)\r\ngoto out;\r\nnest_helper = nla_nest_start(skb, CTA_HELP | NLA_F_NESTED);\r\nif (!nest_helper)\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, CTA_HELP_NAME, helper->name))\r\ngoto nla_put_failure;\r\nif (helper->to_nlattr)\r\nhelper->to_nlattr(skb, ct);\r\nnla_nest_end(skb, nest_helper);\r\nout:\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\ndump_counters(struct sk_buff *skb, struct nf_conn_acct *acct,\r\nenum ip_conntrack_dir dir, int type)\r\n{\r\nenum ctattr_type attr = dir ? CTA_COUNTERS_REPLY: CTA_COUNTERS_ORIG;\r\nstruct nf_conn_counter *counter = acct->counter;\r\nstruct nlattr *nest_count;\r\nu64 pkts, bytes;\r\nif (type == IPCTNL_MSG_CT_GET_CTRZERO) {\r\npkts = atomic64_xchg(&counter[dir].packets, 0);\r\nbytes = atomic64_xchg(&counter[dir].bytes, 0);\r\n} else {\r\npkts = atomic64_read(&counter[dir].packets);\r\nbytes = atomic64_read(&counter[dir].bytes);\r\n}\r\nnest_count = nla_nest_start(skb, attr | NLA_F_NESTED);\r\nif (!nest_count)\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, CTA_COUNTERS_PACKETS, cpu_to_be64(pkts)) ||\r\nnla_put_be64(skb, CTA_COUNTERS_BYTES, cpu_to_be64(bytes)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_count);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_dump_acct(struct sk_buff *skb, const struct nf_conn *ct, int type)\r\n{\r\nstruct nf_conn_acct *acct = nf_conn_acct_find(ct);\r\nif (!acct)\r\nreturn 0;\r\nif (dump_counters(skb, acct, IP_CT_DIR_ORIGINAL, type) < 0)\r\nreturn -1;\r\nif (dump_counters(skb, acct, IP_CT_DIR_REPLY, type) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_dump_timestamp(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_count;\r\nconst struct nf_conn_tstamp *tstamp;\r\ntstamp = nf_conn_tstamp_find(ct);\r\nif (!tstamp)\r\nreturn 0;\r\nnest_count = nla_nest_start(skb, CTA_TIMESTAMP | NLA_F_NESTED);\r\nif (!nest_count)\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, CTA_TIMESTAMP_START, cpu_to_be64(tstamp->start)) ||\r\n(tstamp->stop != 0 && nla_put_be64(skb, CTA_TIMESTAMP_STOP,\r\ncpu_to_be64(tstamp->stop))))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_count);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_mark(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nif (nla_put_be32(skb, CTA_MARK, htonl(ct->mark)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_secctx;\r\nint len, ret;\r\nchar *secctx;\r\nret = security_secid_to_secctx(ct->secmark, &secctx, &len);\r\nif (ret)\r\nreturn 0;\r\nret = -1;\r\nnest_secctx = nla_nest_start(skb, CTA_SECCTX | NLA_F_NESTED);\r\nif (!nest_secctx)\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, CTA_SECCTX_NAME, secctx))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_secctx);\r\nret = 0;\r\nnla_put_failure:\r\nsecurity_release_secctx(secctx, len);\r\nreturn ret;\r\n}\r\nstatic int ctnetlink_label_size(const struct nf_conn *ct)\r\n{\r\nstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\r\nif (!labels)\r\nreturn 0;\r\nreturn nla_total_size(labels->words * sizeof(long));\r\n}\r\nstatic int\r\nctnetlink_dump_labels(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\r\nunsigned int len, i;\r\nif (!labels)\r\nreturn 0;\r\nlen = labels->words * sizeof(long);\r\ni = 0;\r\ndo {\r\nif (labels->bits[i] != 0)\r\nreturn nla_put(skb, CTA_LABELS, len, labels->bits);\r\ni++;\r\n} while (i < labels->words);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nctnetlink_dump_master(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nif (!(ct->status & IPS_EXPECTED))\r\nreturn 0;\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_MASTER | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, master_tuple(ct)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\ndump_ct_seq_adj(struct sk_buff *skb, const struct nf_ct_seqadj *seq, int type)\r\n{\r\nstruct nlattr *nest_parms;\r\nnest_parms = nla_nest_start(skb, type | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, CTA_SEQADJ_CORRECTION_POS,\r\nhtonl(seq->correction_pos)) ||\r\nnla_put_be32(skb, CTA_SEQADJ_OFFSET_BEFORE,\r\nhtonl(seq->offset_before)) ||\r\nnla_put_be32(skb, CTA_SEQADJ_OFFSET_AFTER,\r\nhtonl(seq->offset_after)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_ct_seq_adj(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\nstruct nf_ct_seqadj *seq;\r\nif (!(ct->status & IPS_SEQ_ADJUST) || !seqadj)\r\nreturn 0;\r\nseq = &seqadj->seq[IP_CT_DIR_ORIGINAL];\r\nif (dump_ct_seq_adj(skb, seq, CTA_SEQ_ADJ_ORIG) == -1)\r\nreturn -1;\r\nseq = &seqadj->seq[IP_CT_DIR_REPLY];\r\nif (dump_ct_seq_adj(skb, seq, CTA_SEQ_ADJ_REPLY) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nctnetlink_dump_id(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nif (nla_put_be32(skb, CTA_ID, htonl((unsigned long)ct)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_dump_use(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nif (nla_put_be32(skb, CTA_USE, htonl(atomic_read(&ct->ct_general.use))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlattr *nest_parms;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0, event;\r\nevent = (NFNL_SUBSYS_CTNETLINK << 8 | IPCTNL_MSG_CT_NEW);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = nf_ct_l3num(ct);\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nif (nf_ct_zone(ct) &&\r\nnla_put_be16(skb, CTA_ZONE, htons(nf_ct_zone(ct))))\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_status(skb, ct) < 0 ||\r\nctnetlink_dump_timeout(skb, ct) < 0 ||\r\nctnetlink_dump_acct(skb, ct, type) < 0 ||\r\nctnetlink_dump_timestamp(skb, ct) < 0 ||\r\nctnetlink_dump_protoinfo(skb, ct) < 0 ||\r\nctnetlink_dump_helpinfo(skb, ct) < 0 ||\r\nctnetlink_dump_mark(skb, ct) < 0 ||\r\nctnetlink_dump_secctx(skb, ct) < 0 ||\r\nctnetlink_dump_labels(skb, ct) < 0 ||\r\nctnetlink_dump_id(skb, ct) < 0 ||\r\nctnetlink_dump_use(skb, ct) < 0 ||\r\nctnetlink_dump_master(skb, ct) < 0 ||\r\nctnetlink_dump_ct_seq_adj(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic inline size_t\r\nctnetlink_proto_size(const struct nf_conn *ct)\r\n{\r\nstruct nf_conntrack_l3proto *l3proto;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nsize_t len = 0;\r\nrcu_read_lock();\r\nl3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));\r\nlen += l3proto->nla_size;\r\nl4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nlen += l4proto->nla_size;\r\nrcu_read_unlock();\r\nreturn len;\r\n}\r\nstatic inline size_t\r\nctnetlink_acct_size(const struct nf_conn *ct)\r\n{\r\nif (!nf_ct_ext_exist(ct, NF_CT_EXT_ACCT))\r\nreturn 0;\r\nreturn 2 * nla_total_size(0)\r\n+ 2 * nla_total_size(sizeof(uint64_t))\r\n+ 2 * nla_total_size(sizeof(uint64_t))\r\n;\r\n}\r\nstatic inline int\r\nctnetlink_secctx_size(const struct nf_conn *ct)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\nint len, ret;\r\nret = security_secid_to_secctx(ct->secmark, NULL, &len);\r\nif (ret)\r\nreturn 0;\r\nreturn nla_total_size(0)\r\n+ nla_total_size(sizeof(char) * len);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline size_t\r\nctnetlink_timestamp_size(const struct nf_conn *ct)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\r\nif (!nf_ct_ext_exist(ct, NF_CT_EXT_TSTAMP))\r\nreturn 0;\r\nreturn nla_total_size(0) + 2 * nla_total_size(sizeof(uint64_t));\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline size_t\r\nctnetlink_nlmsg_size(const struct nf_conn *ct)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct nfgenmsg))\r\n+ 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(sizeof(u_int8_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ ctnetlink_acct_size(ct)\r\n+ ctnetlink_timestamp_size(ct)\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(0)\r\n+ nla_total_size(0)\r\n+ nla_total_size(NF_CT_HELPER_NAME_LEN)\r\n+ ctnetlink_secctx_size(ct)\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\n+ 2 * nla_total_size(0)\r\n+ 6 * nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_ZONES\r\n+ nla_total_size(sizeof(u_int16_t))\r\n#endif\r\n+ ctnetlink_proto_size(ct)\r\n+ ctnetlink_label_size(ct)\r\n;\r\n}\r\nstatic int\r\nctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)\r\n{\r\nstruct net *net;\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlattr *nest_parms;\r\nstruct nf_conn *ct = item->ct;\r\nstruct sk_buff *skb;\r\nunsigned int type;\r\nunsigned int flags = 0, group;\r\nint err;\r\nif (nf_ct_is_untracked(ct))\r\nreturn 0;\r\nif (events & (1 << IPCT_DESTROY)) {\r\ntype = IPCTNL_MSG_CT_DELETE;\r\ngroup = NFNLGRP_CONNTRACK_DESTROY;\r\n} else if (events & ((1 << IPCT_NEW) | (1 << IPCT_RELATED))) {\r\ntype = IPCTNL_MSG_CT_NEW;\r\nflags = NLM_F_CREATE|NLM_F_EXCL;\r\ngroup = NFNLGRP_CONNTRACK_NEW;\r\n} else if (events) {\r\ntype = IPCTNL_MSG_CT_NEW;\r\ngroup = NFNLGRP_CONNTRACK_UPDATE;\r\n} else\r\nreturn 0;\r\nnet = nf_ct_net(ct);\r\nif (!item->report && !nfnetlink_has_listeners(net, group))\r\nreturn 0;\r\nskb = nlmsg_new(ctnetlink_nlmsg_size(ct), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\ntype |= NFNL_SUBSYS_CTNETLINK << 8;\r\nnlh = nlmsg_put(skb, item->portid, 0, type, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = nf_ct_l3num(ct);\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nrcu_read_lock();\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nif (nf_ct_zone(ct) &&\r\nnla_put_be16(skb, CTA_ZONE, htons(nf_ct_zone(ct))))\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_id(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_status(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (events & (1 << IPCT_DESTROY)) {\r\nif (ctnetlink_dump_acct(skb, ct, type) < 0 ||\r\nctnetlink_dump_timestamp(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n} else {\r\nif (ctnetlink_dump_timeout(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (events & (1 << IPCT_PROTOINFO)\r\n&& ctnetlink_dump_protoinfo(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif ((events & (1 << IPCT_HELPER) || nfct_help(ct))\r\n&& ctnetlink_dump_helpinfo(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\nif ((events & (1 << IPCT_SECMARK) || ct->secmark)\r\n&& ctnetlink_dump_secctx(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nif (events & (1 << IPCT_LABEL) &&\r\nctnetlink_dump_labels(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (events & (1 << IPCT_RELATED) &&\r\nctnetlink_dump_master(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (events & (1 << IPCT_SEQADJ) &&\r\nctnetlink_dump_ct_seq_adj(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n}\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nif ((events & (1 << IPCT_MARK) || ct->mark)\r\n&& ctnetlink_dump_mark(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nrcu_read_unlock();\r\nnlmsg_end(skb, nlh);\r\nerr = nfnetlink_send(skb, net, item->portid, group, item->report,\r\nGFP_ATOMIC);\r\nif (err == -ENOBUFS || err == -EAGAIN)\r\nreturn -ENOBUFS;\r\nreturn 0;\r\nnla_put_failure:\r\nrcu_read_unlock();\r\nnlmsg_cancel(skb, nlh);\r\nnlmsg_failure:\r\nkfree_skb(skb);\r\nerrout:\r\nif (nfnetlink_set_err(net, 0, group, -ENOBUFS) > 0)\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nstatic int ctnetlink_done(struct netlink_callback *cb)\r\n{\r\nif (cb->args[1])\r\nnf_ct_put((struct nf_conn *)cb->args[1]);\r\nkfree(cb->data);\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nf_conn *ct, *last;\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct hlist_nulls_node *n;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nu_int8_t l3proto = nfmsg->nfgen_family;\r\nint res;\r\nspinlock_t *lockp;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nconst struct ctnetlink_dump_filter *filter = cb->data;\r\n#endif\r\nlast = (struct nf_conn *)cb->args[1];\r\nlocal_bh_disable();\r\nfor (; cb->args[0] < net->ct.htable_size; cb->args[0]++) {\r\nrestart:\r\nlockp = &nf_conntrack_locks[cb->args[0] % CONNTRACK_LOCKS];\r\nspin_lock(lockp);\r\nif (cb->args[0] >= net->ct.htable_size) {\r\nspin_unlock(lockp);\r\ngoto out;\r\n}\r\nhlist_nulls_for_each_entry(h, n, &net->ct.hash[cb->args[0]],\r\nhnnode) {\r\nif (NF_CT_DIRECTION(h) != IP_CT_DIR_ORIGINAL)\r\ncontinue;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nif (l3proto && nf_ct_l3num(ct) != l3proto)\r\ncontinue;\r\nif (cb->args[1]) {\r\nif (ct != last)\r\ncontinue;\r\ncb->args[1] = 0;\r\n}\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nif (filter && !((ct->mark & filter->mark.mask) ==\r\nfilter->mark.val)) {\r\ncontinue;\r\n}\r\n#endif\r\nrcu_read_lock();\r\nres =\r\nctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nct);\r\nrcu_read_unlock();\r\nif (res < 0) {\r\nnf_conntrack_get(&ct->ct_general);\r\ncb->args[1] = (unsigned long)ct;\r\nspin_unlock(lockp);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock(lockp);\r\nif (cb->args[1]) {\r\ncb->args[1] = 0;\r\ngoto restart;\r\n}\r\n}\r\nout:\r\nlocal_bh_enable();\r\nif (last)\r\nnf_ct_put(last);\r\nreturn skb->len;\r\n}\r\nstatic inline int\r\nctnetlink_parse_tuple_ip(struct nlattr *attr, struct nf_conntrack_tuple *tuple)\r\n{\r\nstruct nlattr *tb[CTA_IP_MAX+1];\r\nstruct nf_conntrack_l3proto *l3proto;\r\nint ret = 0;\r\nret = nla_parse_nested(tb, CTA_IP_MAX, attr, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nrcu_read_lock();\r\nl3proto = __nf_ct_l3proto_find(tuple->src.l3num);\r\nif (likely(l3proto->nlattr_to_tuple)) {\r\nret = nla_validate_nested(attr, CTA_IP_MAX,\r\nl3proto->nla_policy);\r\nif (ret == 0)\r\nret = l3proto->nlattr_to_tuple(tb, tuple);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic inline int\r\nctnetlink_parse_tuple_proto(struct nlattr *attr,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nstruct nlattr *tb[CTA_PROTO_MAX+1];\r\nstruct nf_conntrack_l4proto *l4proto;\r\nint ret = 0;\r\nret = nla_parse_nested(tb, CTA_PROTO_MAX, attr, proto_nla_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[CTA_PROTO_NUM])\r\nreturn -EINVAL;\r\ntuple->dst.protonum = nla_get_u8(tb[CTA_PROTO_NUM]);\r\nrcu_read_lock();\r\nl4proto = __nf_ct_l4proto_find(tuple->src.l3num, tuple->dst.protonum);\r\nif (likely(l4proto->nlattr_to_tuple)) {\r\nret = nla_validate_nested(attr, CTA_PROTO_MAX,\r\nl4proto->nla_policy);\r\nif (ret == 0)\r\nret = l4proto->nlattr_to_tuple(tb, tuple);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int\r\nctnetlink_parse_tuple(const struct nlattr * const cda[],\r\nstruct nf_conntrack_tuple *tuple,\r\nenum ctattr_type type, u_int8_t l3num)\r\n{\r\nstruct nlattr *tb[CTA_TUPLE_MAX+1];\r\nint err;\r\nmemset(tuple, 0, sizeof(*tuple));\r\nerr = nla_parse_nested(tb, CTA_TUPLE_MAX, cda[type], tuple_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_TUPLE_IP])\r\nreturn -EINVAL;\r\ntuple->src.l3num = l3num;\r\nerr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_TUPLE_PROTO])\r\nreturn -EINVAL;\r\nerr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple);\r\nif (err < 0)\r\nreturn err;\r\nif (type == CTA_TUPLE_REPLY)\r\ntuple->dst.dir = IP_CT_DIR_REPLY;\r\nelse\r\ntuple->dst.dir = IP_CT_DIR_ORIGINAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_parse_zone(const struct nlattr *attr, u16 *zone)\r\n{\r\nif (attr)\r\n#ifdef CONFIG_NF_CONNTRACK_ZONES\r\n*zone = ntohs(nla_get_be16(attr));\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nelse\r\n*zone = 0;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nctnetlink_parse_help(const struct nlattr *attr, char **helper_name,\r\nstruct nlattr **helpinfo)\r\n{\r\nint err;\r\nstruct nlattr *tb[CTA_HELP_MAX+1];\r\nerr = nla_parse_nested(tb, CTA_HELP_MAX, attr, help_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_HELP_NAME])\r\nreturn -EINVAL;\r\n*helper_name = nla_data(tb[CTA_HELP_NAME]);\r\nif (tb[CTA_HELP_INFO])\r\n*helpinfo = tb[CTA_HELP_INFO];\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_del_conntrack(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nf_conn *ct;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nu16 zone;\r\nint err;\r\nerr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_TUPLE_ORIG])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_ORIG, u3);\r\nelse if (cda[CTA_TUPLE_REPLY])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_REPLY, u3);\r\nelse {\r\nnf_conntrack_flush_report(net,\r\nNETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\nreturn 0;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nh = nf_conntrack_find_get(net, zone, &tuple);\r\nif (!h)\r\nreturn -ENOENT;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nif (cda[CTA_ID]) {\r\nu_int32_t id = ntohl(nla_get_be32(cda[CTA_ID]));\r\nif (id != (u32)(unsigned long)ct) {\r\nnf_ct_put(ct);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (del_timer(&ct->timeout))\r\nnf_ct_delete(ct, NETLINK_CB(skb).portid, nlmsg_report(nlh));\r\nnf_ct_put(ct);\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_get_conntrack(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nf_conn *ct;\r\nstruct sk_buff *skb2 = NULL;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nu16 zone;\r\nint err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_dump_table,\r\n.done = ctnetlink_done,\r\n};\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nif (cda[CTA_MARK] && cda[CTA_MARK_MASK]) {\r\nstruct ctnetlink_dump_filter *filter;\r\nfilter = kzalloc(sizeof(struct ctnetlink_dump_filter),\r\nGFP_ATOMIC);\r\nif (filter == NULL)\r\nreturn -ENOMEM;\r\nfilter->mark.val = ntohl(nla_get_be32(cda[CTA_MARK]));\r\nfilter->mark.mask =\r\nntohl(nla_get_be32(cda[CTA_MARK_MASK]));\r\nc.data = filter;\r\n}\r\n#endif\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nerr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_TUPLE_ORIG])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_ORIG, u3);\r\nelse if (cda[CTA_TUPLE_REPLY])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_TUPLE_REPLY, u3);\r\nelse\r\nreturn -EINVAL;\r\nif (err < 0)\r\nreturn err;\r\nh = nf_conntrack_find_get(net, zone, &tuple);\r\nif (!h)\r\nreturn -ENOENT;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nerr = -ENOMEM;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nnf_ct_put(ct);\r\nreturn -ENOMEM;\r\n}\r\nrcu_read_lock();\r\nerr = ctnetlink_fill_info(skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type), ct);\r\nrcu_read_unlock();\r\nnf_ct_put(ct);\r\nif (err <= 0)\r\ngoto free;\r\nerr = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (err < 0)\r\ngoto out;\r\nreturn 0;\r\nfree:\r\nkfree_skb(skb2);\r\nout:\r\nreturn err == -EAGAIN ? -ENOBUFS : err;\r\n}\r\nstatic int ctnetlink_done_list(struct netlink_callback *cb)\r\n{\r\nif (cb->args[1])\r\nnf_ct_put((struct nf_conn *)cb->args[1]);\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_dump_list(struct sk_buff *skb, struct netlink_callback *cb, bool dying)\r\n{\r\nstruct nf_conn *ct, *last;\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct hlist_nulls_node *n;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nu_int8_t l3proto = nfmsg->nfgen_family;\r\nint res;\r\nint cpu;\r\nstruct hlist_nulls_head *list;\r\nstruct net *net = sock_net(skb->sk);\r\nif (cb->args[2])\r\nreturn 0;\r\nlast = (struct nf_conn *)cb->args[1];\r\nfor (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {\r\nstruct ct_pcpu *pcpu;\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\npcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);\r\nspin_lock_bh(&pcpu->lock);\r\nlist = dying ? &pcpu->dying : &pcpu->unconfirmed;\r\nrestart:\r\nhlist_nulls_for_each_entry(h, n, list, hnnode) {\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nif (l3proto && nf_ct_l3num(ct) != l3proto)\r\ncontinue;\r\nif (cb->args[1]) {\r\nif (ct != last)\r\ncontinue;\r\ncb->args[1] = 0;\r\n}\r\nrcu_read_lock();\r\nres = ctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nct);\r\nrcu_read_unlock();\r\nif (res < 0) {\r\nif (!atomic_inc_not_zero(&ct->ct_general.use))\r\ncontinue;\r\ncb->args[0] = cpu;\r\ncb->args[1] = (unsigned long)ct;\r\nspin_unlock_bh(&pcpu->lock);\r\ngoto out;\r\n}\r\n}\r\nif (cb->args[1]) {\r\ncb->args[1] = 0;\r\ngoto restart;\r\n}\r\nspin_unlock_bh(&pcpu->lock);\r\n}\r\ncb->args[2] = 1;\r\nout:\r\nif (last)\r\nnf_ct_put(last);\r\nreturn skb->len;\r\n}\r\nstatic int\r\nctnetlink_dump_dying(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nreturn ctnetlink_dump_list(skb, cb, true);\r\n}\r\nstatic int\r\nctnetlink_get_ct_dying(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_dump_dying,\r\n.done = ctnetlink_done_list,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nctnetlink_dump_unconfirmed(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nreturn ctnetlink_dump_list(skb, cb, false);\r\n}\r\nstatic int\r\nctnetlink_get_ct_unconfirmed(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_dump_unconfirmed,\r\n.done = ctnetlink_done_list,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nctnetlink_parse_nat_setup(struct nf_conn *ct,\r\nenum nf_nat_manip_type manip,\r\nconst struct nlattr *attr)\r\n{\r\ntypeof(nfnetlink_parse_nat_setup_hook) parse_nat_setup;\r\nint err;\r\nparse_nat_setup = rcu_dereference(nfnetlink_parse_nat_setup_hook);\r\nif (!parse_nat_setup) {\r\n#ifdef CONFIG_MODULES\r\nrcu_read_unlock();\r\nnfnl_unlock(NFNL_SUBSYS_CTNETLINK);\r\nif (request_module("nf-nat") < 0) {\r\nnfnl_lock(NFNL_SUBSYS_CTNETLINK);\r\nrcu_read_lock();\r\nreturn -EOPNOTSUPP;\r\n}\r\nnfnl_lock(NFNL_SUBSYS_CTNETLINK);\r\nrcu_read_lock();\r\nif (nfnetlink_parse_nat_setup_hook)\r\nreturn -EAGAIN;\r\n#endif\r\nreturn -EOPNOTSUPP;\r\n}\r\nerr = parse_nat_setup(ct, manip, attr);\r\nif (err == -EAGAIN) {\r\n#ifdef CONFIG_MODULES\r\nrcu_read_unlock();\r\nnfnl_unlock(NFNL_SUBSYS_CTNETLINK);\r\nif (request_module("nf-nat-%u", nf_ct_l3num(ct)) < 0) {\r\nnfnl_lock(NFNL_SUBSYS_CTNETLINK);\r\nrcu_read_lock();\r\nreturn -EOPNOTSUPP;\r\n}\r\nnfnl_lock(NFNL_SUBSYS_CTNETLINK);\r\nrcu_read_lock();\r\n#else\r\nerr = -EOPNOTSUPP;\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nctnetlink_change_status(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\nunsigned long d;\r\nunsigned int status = ntohl(nla_get_be32(cda[CTA_STATUS]));\r\nd = ct->status ^ status;\r\nif (d & (IPS_EXPECTED|IPS_CONFIRMED|IPS_DYING))\r\nreturn -EBUSY;\r\nif (d & IPS_SEEN_REPLY && !(status & IPS_SEEN_REPLY))\r\nreturn -EBUSY;\r\nif (d & IPS_ASSURED && !(status & IPS_ASSURED))\r\nreturn -EBUSY;\r\nct->status |= status & ~(IPS_NAT_DONE_MASK | IPS_NAT_MASK);\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_setup_nat(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\nint ret;\r\nif (!cda[CTA_NAT_DST] && !cda[CTA_NAT_SRC])\r\nreturn 0;\r\nret = ctnetlink_parse_nat_setup(ct, NF_NAT_MANIP_DST,\r\ncda[CTA_NAT_DST]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ctnetlink_parse_nat_setup(ct, NF_NAT_MANIP_SRC,\r\ncda[CTA_NAT_SRC]);\r\nreturn ret;\r\n#else\r\nif (!cda[CTA_NAT_DST] && !cda[CTA_NAT_SRC])\r\nreturn 0;\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic inline int\r\nctnetlink_change_helper(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\nstruct nf_conntrack_helper *helper;\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nchar *helpname = NULL;\r\nstruct nlattr *helpinfo = NULL;\r\nint err;\r\nif (ct->master)\r\nreturn -EBUSY;\r\nerr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\r\nif (err < 0)\r\nreturn err;\r\nif (!strcmp(helpname, "")) {\r\nif (help && help->helper) {\r\nnf_ct_remove_expectations(ct);\r\nRCU_INIT_POINTER(help->helper, NULL);\r\n}\r\nreturn 0;\r\n}\r\nhelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\r\nnf_ct_protonum(ct));\r\nif (helper == NULL) {\r\n#ifdef CONFIG_MODULES\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nif (request_module("nfct-helper-%s", helpname) < 0) {\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nhelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\r\nnf_ct_protonum(ct));\r\nif (helper)\r\nreturn -EAGAIN;\r\n#endif\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (help) {\r\nif (help->helper == helper) {\r\nif (helper->from_nlattr)\r\nhelper->from_nlattr(helpinfo, ct);\r\nreturn 0;\r\n} else\r\nreturn -EBUSY;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic inline int\r\nctnetlink_change_timeout(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\nu_int32_t timeout = ntohl(nla_get_be32(cda[CTA_TIMEOUT]));\r\nif (!del_timer(&ct->timeout))\r\nreturn -ETIME;\r\nct->timeout.expires = jiffies + timeout * HZ;\r\nadd_timer(&ct->timeout);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nctnetlink_change_protoinfo(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\nconst struct nlattr *attr = cda[CTA_PROTOINFO];\r\nstruct nlattr *tb[CTA_PROTOINFO_MAX+1];\r\nstruct nf_conntrack_l4proto *l4proto;\r\nint err = 0;\r\nerr = nla_parse_nested(tb, CTA_PROTOINFO_MAX, attr, protoinfo_policy);\r\nif (err < 0)\r\nreturn err;\r\nrcu_read_lock();\r\nl4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nif (l4proto->from_nlattr)\r\nerr = l4proto->from_nlattr(tb, ct);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic inline int\r\nchange_seq_adj(struct nf_ct_seqadj *seq, const struct nlattr * const attr)\r\n{\r\nint err;\r\nstruct nlattr *cda[CTA_SEQADJ_MAX+1];\r\nerr = nla_parse_nested(cda, CTA_SEQADJ_MAX, attr, seqadj_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!cda[CTA_SEQADJ_CORRECTION_POS])\r\nreturn -EINVAL;\r\nseq->correction_pos =\r\nntohl(nla_get_be32(cda[CTA_SEQADJ_CORRECTION_POS]));\r\nif (!cda[CTA_SEQADJ_OFFSET_BEFORE])\r\nreturn -EINVAL;\r\nseq->offset_before =\r\nntohl(nla_get_be32(cda[CTA_SEQADJ_OFFSET_BEFORE]));\r\nif (!cda[CTA_SEQADJ_OFFSET_AFTER])\r\nreturn -EINVAL;\r\nseq->offset_after =\r\nntohl(nla_get_be32(cda[CTA_SEQADJ_OFFSET_AFTER]));\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_change_seq_adj(struct nf_conn *ct,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct nf_conn_seqadj *seqadj = nfct_seqadj(ct);\r\nint ret = 0;\r\nif (!seqadj)\r\nreturn 0;\r\nif (cda[CTA_SEQ_ADJ_ORIG]) {\r\nret = change_seq_adj(&seqadj->seq[IP_CT_DIR_ORIGINAL],\r\ncda[CTA_SEQ_ADJ_ORIG]);\r\nif (ret < 0)\r\nreturn ret;\r\nct->status |= IPS_SEQ_ADJUST;\r\n}\r\nif (cda[CTA_SEQ_ADJ_REPLY]) {\r\nret = change_seq_adj(&seqadj->seq[IP_CT_DIR_REPLY],\r\ncda[CTA_SEQ_ADJ_REPLY]);\r\nif (ret < 0)\r\nreturn ret;\r\nct->status |= IPS_SEQ_ADJUST;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_attach_labels(struct nf_conn *ct, const struct nlattr * const cda[])\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_LABELS\r\nsize_t len = nla_len(cda[CTA_LABELS]);\r\nconst void *mask = cda[CTA_LABELS_MASK];\r\nif (len & (sizeof(u32)-1))\r\nreturn -EINVAL;\r\nif (mask) {\r\nif (nla_len(cda[CTA_LABELS_MASK]) == 0 ||\r\nnla_len(cda[CTA_LABELS_MASK]) != len)\r\nreturn -EINVAL;\r\nmask = nla_data(cda[CTA_LABELS_MASK]);\r\n}\r\nlen /= sizeof(u32);\r\nreturn nf_connlabels_replace(ct, nla_data(cda[CTA_LABELS]), mask, len);\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic int\r\nctnetlink_change_conntrack(struct nf_conn *ct,\r\nconst struct nlattr * const cda[])\r\n{\r\nint err;\r\nif (cda[CTA_NAT_SRC] || cda[CTA_NAT_DST] || cda[CTA_TUPLE_MASTER])\r\nreturn -EOPNOTSUPP;\r\nif (cda[CTA_HELP]) {\r\nerr = ctnetlink_change_helper(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_TIMEOUT]) {\r\nerr = ctnetlink_change_timeout(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_STATUS]) {\r\nerr = ctnetlink_change_status(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_PROTOINFO]) {\r\nerr = ctnetlink_change_protoinfo(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#if defined(CONFIG_NF_CONNTRACK_MARK)\r\nif (cda[CTA_MARK])\r\nct->mark = ntohl(nla_get_be32(cda[CTA_MARK]));\r\n#endif\r\nif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\r\nerr = ctnetlink_change_seq_adj(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_LABELS]) {\r\nerr = ctnetlink_attach_labels(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct nf_conn *\r\nctnetlink_create_conntrack(struct net *net, u16 zone,\r\nconst struct nlattr * const cda[],\r\nstruct nf_conntrack_tuple *otuple,\r\nstruct nf_conntrack_tuple *rtuple,\r\nu8 u3)\r\n{\r\nstruct nf_conn *ct;\r\nint err = -EINVAL;\r\nstruct nf_conntrack_helper *helper;\r\nstruct nf_conn_tstamp *tstamp;\r\nct = nf_conntrack_alloc(net, zone, otuple, rtuple, GFP_ATOMIC);\r\nif (IS_ERR(ct))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (!cda[CTA_TIMEOUT])\r\ngoto err1;\r\nct->timeout.expires = ntohl(nla_get_be32(cda[CTA_TIMEOUT]));\r\nct->timeout.expires = jiffies + ct->timeout.expires * HZ;\r\nrcu_read_lock();\r\nif (cda[CTA_HELP]) {\r\nchar *helpname = NULL;\r\nstruct nlattr *helpinfo = NULL;\r\nerr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\r\nif (err < 0)\r\ngoto err2;\r\nhelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\r\nnf_ct_protonum(ct));\r\nif (helper == NULL) {\r\nrcu_read_unlock();\r\n#ifdef CONFIG_MODULES\r\nif (request_module("nfct-helper-%s", helpname) < 0) {\r\nerr = -EOPNOTSUPP;\r\ngoto err1;\r\n}\r\nrcu_read_lock();\r\nhelper = __nf_conntrack_helper_find(helpname,\r\nnf_ct_l3num(ct),\r\nnf_ct_protonum(ct));\r\nif (helper) {\r\nerr = -EAGAIN;\r\ngoto err2;\r\n}\r\nrcu_read_unlock();\r\n#endif\r\nerr = -EOPNOTSUPP;\r\ngoto err1;\r\n} else {\r\nstruct nf_conn_help *help;\r\nhelp = nf_ct_helper_ext_add(ct, helper, GFP_ATOMIC);\r\nif (help == NULL) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\nif (helper->from_nlattr)\r\nhelper->from_nlattr(helpinfo, ct);\r\nRCU_INIT_POINTER(help->helper, helper);\r\n}\r\n} else {\r\nerr = __nf_ct_try_assign_helper(ct, NULL, GFP_ATOMIC);\r\nif (err < 0)\r\ngoto err2;\r\n}\r\nerr = ctnetlink_setup_nat(ct, cda);\r\nif (err < 0)\r\ngoto err2;\r\nnf_ct_acct_ext_add(ct, GFP_ATOMIC);\r\nnf_ct_tstamp_ext_add(ct, GFP_ATOMIC);\r\nnf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);\r\nnf_ct_labels_ext_add(ct);\r\nct->status |= IPS_CONFIRMED;\r\nif (cda[CTA_STATUS]) {\r\nerr = ctnetlink_change_status(ct, cda);\r\nif (err < 0)\r\ngoto err2;\r\n}\r\nif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\r\nerr = ctnetlink_change_seq_adj(ct, cda);\r\nif (err < 0)\r\ngoto err2;\r\n}\r\nmemset(&ct->proto, 0, sizeof(ct->proto));\r\nif (cda[CTA_PROTOINFO]) {\r\nerr = ctnetlink_change_protoinfo(ct, cda);\r\nif (err < 0)\r\ngoto err2;\r\n}\r\n#if defined(CONFIG_NF_CONNTRACK_MARK)\r\nif (cda[CTA_MARK])\r\nct->mark = ntohl(nla_get_be32(cda[CTA_MARK]));\r\n#endif\r\nif (cda[CTA_TUPLE_MASTER]) {\r\nstruct nf_conntrack_tuple master;\r\nstruct nf_conntrack_tuple_hash *master_h;\r\nstruct nf_conn *master_ct;\r\nerr = ctnetlink_parse_tuple(cda, &master, CTA_TUPLE_MASTER, u3);\r\nif (err < 0)\r\ngoto err2;\r\nmaster_h = nf_conntrack_find_get(net, zone, &master);\r\nif (master_h == NULL) {\r\nerr = -ENOENT;\r\ngoto err2;\r\n}\r\nmaster_ct = nf_ct_tuplehash_to_ctrack(master_h);\r\n__set_bit(IPS_EXPECTED_BIT, &ct->status);\r\nct->master = master_ct;\r\n}\r\ntstamp = nf_conn_tstamp_find(ct);\r\nif (tstamp)\r\ntstamp->start = ktime_get_real_ns();\r\nerr = nf_conntrack_hash_check_insert(ct);\r\nif (err < 0)\r\ngoto err2;\r\nrcu_read_unlock();\r\nreturn ct;\r\nerr2:\r\nrcu_read_unlock();\r\nerr1:\r\nnf_conntrack_free(ct);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\nctnetlink_new_conntrack(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_tuple otuple, rtuple;\r\nstruct nf_conntrack_tuple_hash *h = NULL;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nf_conn *ct;\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nu16 zone;\r\nint err;\r\nerr = ctnetlink_parse_zone(cda[CTA_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_TUPLE_ORIG]) {\r\nerr = ctnetlink_parse_tuple(cda, &otuple, CTA_TUPLE_ORIG, u3);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_TUPLE_REPLY]) {\r\nerr = ctnetlink_parse_tuple(cda, &rtuple, CTA_TUPLE_REPLY, u3);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_TUPLE_ORIG])\r\nh = nf_conntrack_find_get(net, zone, &otuple);\r\nelse if (cda[CTA_TUPLE_REPLY])\r\nh = nf_conntrack_find_get(net, zone, &rtuple);\r\nif (h == NULL) {\r\nerr = -ENOENT;\r\nif (nlh->nlmsg_flags & NLM_F_CREATE) {\r\nenum ip_conntrack_events events;\r\nif (!cda[CTA_TUPLE_ORIG] || !cda[CTA_TUPLE_REPLY])\r\nreturn -EINVAL;\r\nct = ctnetlink_create_conntrack(net, zone, cda, &otuple,\r\n&rtuple, u3);\r\nif (IS_ERR(ct))\r\nreturn PTR_ERR(ct);\r\nerr = 0;\r\nif (test_bit(IPS_EXPECTED_BIT, &ct->status))\r\nevents = IPCT_RELATED;\r\nelse\r\nevents = IPCT_NEW;\r\nif (cda[CTA_LABELS] &&\r\nctnetlink_attach_labels(ct, cda) == 0)\r\nevents |= (1 << IPCT_LABEL);\r\nnf_conntrack_eventmask_report((1 << IPCT_REPLY) |\r\n(1 << IPCT_ASSURED) |\r\n(1 << IPCT_HELPER) |\r\n(1 << IPCT_PROTOINFO) |\r\n(1 << IPCT_SEQADJ) |\r\n(1 << IPCT_MARK) | events,\r\nct, NETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\nnf_ct_put(ct);\r\n}\r\nreturn err;\r\n}\r\nerr = -EEXIST;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nif (!(nlh->nlmsg_flags & NLM_F_EXCL)) {\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nerr = ctnetlink_change_conntrack(ct, cda);\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nif (err == 0) {\r\nnf_conntrack_eventmask_report((1 << IPCT_REPLY) |\r\n(1 << IPCT_ASSURED) |\r\n(1 << IPCT_HELPER) |\r\n(1 << IPCT_LABEL) |\r\n(1 << IPCT_PROTOINFO) |\r\n(1 << IPCT_SEQADJ) |\r\n(1 << IPCT_MARK),\r\nct, NETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\n}\r\n}\r\nnf_ct_put(ct);\r\nreturn err;\r\n}\r\nstatic int\r\nctnetlink_ct_stat_cpu_fill_info(struct sk_buff *skb, u32 portid, u32 seq,\r\n__u16 cpu, const struct ip_conntrack_stat *st)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0, event;\r\nevent = (NFNL_SUBSYS_CTNETLINK << 8 | IPCTNL_MSG_CT_GET_STATS_CPU);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(cpu);\r\nif (nla_put_be32(skb, CTA_STATS_SEARCHED, htonl(st->searched)) ||\r\nnla_put_be32(skb, CTA_STATS_FOUND, htonl(st->found)) ||\r\nnla_put_be32(skb, CTA_STATS_NEW, htonl(st->new)) ||\r\nnla_put_be32(skb, CTA_STATS_INVALID, htonl(st->invalid)) ||\r\nnla_put_be32(skb, CTA_STATS_IGNORE, htonl(st->ignore)) ||\r\nnla_put_be32(skb, CTA_STATS_DELETE, htonl(st->delete)) ||\r\nnla_put_be32(skb, CTA_STATS_DELETE_LIST, htonl(st->delete_list)) ||\r\nnla_put_be32(skb, CTA_STATS_INSERT, htonl(st->insert)) ||\r\nnla_put_be32(skb, CTA_STATS_INSERT_FAILED,\r\nhtonl(st->insert_failed)) ||\r\nnla_put_be32(skb, CTA_STATS_DROP, htonl(st->drop)) ||\r\nnla_put_be32(skb, CTA_STATS_EARLY_DROP, htonl(st->early_drop)) ||\r\nnla_put_be32(skb, CTA_STATS_ERROR, htonl(st->error)) ||\r\nnla_put_be32(skb, CTA_STATS_SEARCH_RESTART,\r\nhtonl(st->search_restart)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_ct_stat_cpu_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint cpu;\r\nstruct net *net = sock_net(skb->sk);\r\nif (cb->args[0] == nr_cpu_ids)\r\nreturn 0;\r\nfor (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {\r\nconst struct ip_conntrack_stat *st;\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\nst = per_cpu_ptr(net->ct.stat, cpu);\r\nif (ctnetlink_ct_stat_cpu_fill_info(skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\ncpu, st) < 0)\r\nbreak;\r\n}\r\ncb->args[0] = cpu;\r\nreturn skb->len;\r\n}\r\nstatic int\r\nctnetlink_stat_ct_cpu(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_ct_stat_cpu_dump,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_stat_ct_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nstruct net *net)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0, event;\r\nunsigned int nr_conntracks = atomic_read(&net->ct.count);\r\nevent = (NFNL_SUBSYS_CTNETLINK << 8 | IPCTNL_MSG_CT_GET_STATS);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_be32(skb, CTA_STATS_GLOBAL_ENTRIES, htonl(nr_conntracks)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_stat_ct(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct sk_buff *skb2;\r\nint err;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nerr = ctnetlink_stat_ct_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nsock_net(skb->sk));\r\nif (err <= 0)\r\ngoto free;\r\nerr = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (err < 0)\r\ngoto out;\r\nreturn 0;\r\nfree:\r\nkfree_skb(skb2);\r\nout:\r\nreturn err == -EAGAIN ? -ENOBUFS : err;\r\n}\r\nstatic size_t\r\nctnetlink_nfqueue_build_size(const struct nf_conn *ct)\r\n{\r\nreturn 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(0)\r\n+ 3 * nla_total_size(sizeof(u_int8_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(0)\r\n+ nla_total_size(0)\r\n+ nla_total_size(NF_CT_HELPER_NAME_LEN)\r\n+ ctnetlink_secctx_size(ct)\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\n+ 2 * nla_total_size(0)\r\n+ 6 * nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_ZONES\r\n+ nla_total_size(sizeof(u_int16_t))\r\n#endif\r\n+ ctnetlink_proto_size(ct)\r\n;\r\n}\r\nstatic int\r\nctnetlink_nfqueue_build(struct sk_buff *skb, struct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nrcu_read_lock();\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_ORIG | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_ORIGINAL)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nnest_parms = nla_nest_start(skb, CTA_TUPLE_REPLY | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, nf_ct_tuple(ct, IP_CT_DIR_REPLY)) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nif (nf_ct_zone(ct)) {\r\nif (nla_put_be16(skb, CTA_ZONE, htons(nf_ct_zone(ct))))\r\ngoto nla_put_failure;\r\n}\r\nif (ctnetlink_dump_id(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_status(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_timeout(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_protoinfo(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_helpinfo(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\nif (ct->secmark && ctnetlink_dump_secctx(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nif (ct->master && ctnetlink_dump_master(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nif ((ct->status & IPS_SEQ_ADJUST) &&\r\nctnetlink_dump_ct_seq_adj(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nif (ct->mark && ctnetlink_dump_mark(skb, ct) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nif (ctnetlink_dump_labels(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nrcu_read_unlock();\r\nreturn 0;\r\nnla_put_failure:\r\nrcu_read_unlock();\r\nreturn -ENOSPC;\r\n}\r\nstatic int\r\nctnetlink_nfqueue_parse_ct(const struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nint err;\r\nif (cda[CTA_TIMEOUT]) {\r\nerr = ctnetlink_change_timeout(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_STATUS]) {\r\nerr = ctnetlink_change_status(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_HELP]) {\r\nerr = ctnetlink_change_helper(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cda[CTA_LABELS]) {\r\nerr = ctnetlink_attach_labels(ct, cda);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#if defined(CONFIG_NF_CONNTRACK_MARK)\r\nif (cda[CTA_MARK]) {\r\nu32 mask = 0, mark, newmark;\r\nif (cda[CTA_MARK_MASK])\r\nmask = ~ntohl(nla_get_be32(cda[CTA_MARK_MASK]));\r\nmark = ntohl(nla_get_be32(cda[CTA_MARK]));\r\nnewmark = (ct->mark & mask) ^ mark;\r\nif (newmark != ct->mark)\r\nct->mark = newmark;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_nfqueue_parse(const struct nlattr *attr, struct nf_conn *ct)\r\n{\r\nstruct nlattr *cda[CTA_MAX+1];\r\nint ret;\r\nret = nla_parse_nested(cda, CTA_MAX, attr, ct_nla_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nret = ctnetlink_nfqueue_parse_ct((const struct nlattr **)cda, ct);\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nreturn ret;\r\n}\r\nstatic int ctnetlink_nfqueue_exp_parse(const struct nlattr * const *cda,\r\nconst struct nf_conn *ct,\r\nstruct nf_conntrack_tuple *tuple,\r\nstruct nf_conntrack_tuple *mask)\r\n{\r\nint err;\r\nerr = ctnetlink_parse_tuple(cda, tuple, CTA_EXPECT_TUPLE,\r\nnf_ct_l3num(ct));\r\nif (err < 0)\r\nreturn err;\r\nreturn ctnetlink_parse_tuple(cda, mask, CTA_EXPECT_MASK,\r\nnf_ct_l3num(ct));\r\n}\r\nstatic int\r\nctnetlink_nfqueue_attach_expect(const struct nlattr *attr, struct nf_conn *ct,\r\nu32 portid, u32 report)\r\n{\r\nstruct nlattr *cda[CTA_EXPECT_MAX+1];\r\nstruct nf_conntrack_tuple tuple, mask;\r\nstruct nf_conntrack_helper *helper = NULL;\r\nstruct nf_conntrack_expect *exp;\r\nint err;\r\nerr = nla_parse_nested(cda, CTA_EXPECT_MAX, attr, exp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nerr = ctnetlink_nfqueue_exp_parse((const struct nlattr * const *)cda,\r\nct, &tuple, &mask);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_EXPECT_HELP_NAME]) {\r\nconst char *helpname = nla_data(cda[CTA_EXPECT_HELP_NAME]);\r\nhelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\r\nnf_ct_protonum(ct));\r\nif (helper == NULL)\r\nreturn -EOPNOTSUPP;\r\n}\r\nexp = ctnetlink_alloc_expect((const struct nlattr * const *)cda, ct,\r\nhelper, &tuple, &mask);\r\nif (IS_ERR(exp))\r\nreturn PTR_ERR(exp);\r\nerr = nf_ct_expect_related_report(exp, portid, report);\r\nif (err < 0) {\r\nnf_ct_expect_put(exp);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nctnetlink_exp_dump_tuple(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum ctattr_expect type)\r\n{\r\nstruct nlattr *nest_parms;\r\nnest_parms = nla_nest_start(skb, type | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (ctnetlink_dump_tuples(skb, tuple) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int\r\nctnetlink_exp_dump_mask(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple_mask *mask)\r\n{\r\nint ret;\r\nstruct nf_conntrack_l3proto *l3proto;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nstruct nf_conntrack_tuple m;\r\nstruct nlattr *nest_parms;\r\nmemset(&m, 0xFF, sizeof(m));\r\nmemcpy(&m.src.u3, &mask->src.u3, sizeof(m.src.u3));\r\nm.src.u.all = mask->src.u.all;\r\nm.dst.protonum = tuple->dst.protonum;\r\nnest_parms = nla_nest_start(skb, CTA_EXPECT_MASK | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nrcu_read_lock();\r\nl3proto = __nf_ct_l3proto_find(tuple->src.l3num);\r\nret = ctnetlink_dump_tuples_ip(skb, &m, l3proto);\r\nif (ret >= 0) {\r\nl4proto = __nf_ct_l4proto_find(tuple->src.l3num,\r\ntuple->dst.protonum);\r\nret = ctnetlink_dump_tuples_proto(skb, &m, l4proto);\r\n}\r\nrcu_read_unlock();\r\nif (unlikely(ret < 0))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_exp_dump_expect(struct sk_buff *skb,\r\nconst struct nf_conntrack_expect *exp)\r\n{\r\nstruct nf_conn *master = exp->master;\r\nlong timeout = ((long)exp->timeout.expires - (long)jiffies) / HZ;\r\nstruct nf_conn_help *help;\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\nstruct nlattr *nest_parms;\r\nstruct nf_conntrack_tuple nat_tuple = {};\r\n#endif\r\nstruct nf_ct_helper_expectfn *expfn;\r\nif (timeout < 0)\r\ntimeout = 0;\r\nif (ctnetlink_exp_dump_tuple(skb, &exp->tuple, CTA_EXPECT_TUPLE) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_exp_dump_mask(skb, &exp->tuple, &exp->mask) < 0)\r\ngoto nla_put_failure;\r\nif (ctnetlink_exp_dump_tuple(skb,\r\n&master->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\r\nCTA_EXPECT_MASTER) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\nif (!nf_inet_addr_cmp(&exp->saved_addr, &any_addr) ||\r\nexp->saved_proto.all) {\r\nnest_parms = nla_nest_start(skb, CTA_EXPECT_NAT | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, CTA_EXPECT_NAT_DIR, htonl(exp->dir)))\r\ngoto nla_put_failure;\r\nnat_tuple.src.l3num = nf_ct_l3num(master);\r\nnat_tuple.src.u3 = exp->saved_addr;\r\nnat_tuple.dst.protonum = nf_ct_protonum(master);\r\nnat_tuple.src.u = exp->saved_proto;\r\nif (ctnetlink_exp_dump_tuple(skb, &nat_tuple,\r\nCTA_EXPECT_NAT_TUPLE) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\n}\r\n#endif\r\nif (nla_put_be32(skb, CTA_EXPECT_TIMEOUT, htonl(timeout)) ||\r\nnla_put_be32(skb, CTA_EXPECT_ID, htonl((unsigned long)exp)) ||\r\nnla_put_be32(skb, CTA_EXPECT_FLAGS, htonl(exp->flags)) ||\r\nnla_put_be32(skb, CTA_EXPECT_CLASS, htonl(exp->class)))\r\ngoto nla_put_failure;\r\nhelp = nfct_help(master);\r\nif (help) {\r\nstruct nf_conntrack_helper *helper;\r\nhelper = rcu_dereference(help->helper);\r\nif (helper &&\r\nnla_put_string(skb, CTA_EXPECT_HELP_NAME, helper->name))\r\ngoto nla_put_failure;\r\n}\r\nexpfn = nf_ct_helper_expectfn_find_by_symbol(exp->expectfn);\r\nif (expfn != NULL &&\r\nnla_put_string(skb, CTA_EXPECT_FN, expfn->name))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_exp_fill_info(struct sk_buff *skb, u32 portid, u32 seq,\r\nint event, const struct nf_conntrack_expect *exp)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nevent |= NFNL_SUBSYS_CTNETLINK_EXP << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = exp->tuple.src.l3num;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (ctnetlink_exp_dump_expect(skb, exp) < 0)\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_expect_event(unsigned int events, struct nf_exp_event *item)\r\n{\r\nstruct nf_conntrack_expect *exp = item->exp;\r\nstruct net *net = nf_ct_exp_net(exp);\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nstruct sk_buff *skb;\r\nunsigned int type, group;\r\nint flags = 0;\r\nif (events & (1 << IPEXP_DESTROY)) {\r\ntype = IPCTNL_MSG_EXP_DELETE;\r\ngroup = NFNLGRP_CONNTRACK_EXP_DESTROY;\r\n} else if (events & (1 << IPEXP_NEW)) {\r\ntype = IPCTNL_MSG_EXP_NEW;\r\nflags = NLM_F_CREATE|NLM_F_EXCL;\r\ngroup = NFNLGRP_CONNTRACK_EXP_NEW;\r\n} else\r\nreturn 0;\r\nif (!item->report && !nfnetlink_has_listeners(net, group))\r\nreturn 0;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\ntype |= NFNL_SUBSYS_CTNETLINK_EXP << 8;\r\nnlh = nlmsg_put(skb, item->portid, 0, type, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = exp->tuple.src.l3num;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nrcu_read_lock();\r\nif (ctnetlink_exp_dump_expect(skb, exp) < 0)\r\ngoto nla_put_failure;\r\nrcu_read_unlock();\r\nnlmsg_end(skb, nlh);\r\nnfnetlink_send(skb, net, item->portid, group, item->report, GFP_ATOMIC);\r\nreturn 0;\r\nnla_put_failure:\r\nrcu_read_unlock();\r\nnlmsg_cancel(skb, nlh);\r\nnlmsg_failure:\r\nkfree_skb(skb);\r\nerrout:\r\nnfnetlink_set_err(net, 0, 0, -ENOBUFS);\r\nreturn 0;\r\n}\r\nstatic int ctnetlink_exp_done(struct netlink_callback *cb)\r\n{\r\nif (cb->args[1])\r\nnf_ct_expect_put((struct nf_conntrack_expect *)cb->args[1]);\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_exp_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nf_conntrack_expect *exp, *last;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nu_int8_t l3proto = nfmsg->nfgen_family;\r\nrcu_read_lock();\r\nlast = (struct nf_conntrack_expect *)cb->args[1];\r\nfor (; cb->args[0] < nf_ct_expect_hsize; cb->args[0]++) {\r\nrestart:\r\nhlist_for_each_entry(exp, &net->ct.expect_hash[cb->args[0]],\r\nhnode) {\r\nif (l3proto && exp->tuple.src.l3num != l3proto)\r\ncontinue;\r\nif (cb->args[1]) {\r\nif (exp != last)\r\ncontinue;\r\ncb->args[1] = 0;\r\n}\r\nif (ctnetlink_exp_fill_info(skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nIPCTNL_MSG_EXP_NEW,\r\nexp) < 0) {\r\nif (!atomic_inc_not_zero(&exp->use))\r\ncontinue;\r\ncb->args[1] = (unsigned long)exp;\r\ngoto out;\r\n}\r\n}\r\nif (cb->args[1]) {\r\ncb->args[1] = 0;\r\ngoto restart;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\nif (last)\r\nnf_ct_expect_put(last);\r\nreturn skb->len;\r\n}\r\nstatic int\r\nctnetlink_exp_ct_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nf_conntrack_expect *exp, *last;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nstruct nf_conn *ct = cb->data;\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nu_int8_t l3proto = nfmsg->nfgen_family;\r\nif (cb->args[0])\r\nreturn 0;\r\nrcu_read_lock();\r\nlast = (struct nf_conntrack_expect *)cb->args[1];\r\nrestart:\r\nhlist_for_each_entry(exp, &help->expectations, lnode) {\r\nif (l3proto && exp->tuple.src.l3num != l3proto)\r\ncontinue;\r\nif (cb->args[1]) {\r\nif (exp != last)\r\ncontinue;\r\ncb->args[1] = 0;\r\n}\r\nif (ctnetlink_exp_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nIPCTNL_MSG_EXP_NEW,\r\nexp) < 0) {\r\nif (!atomic_inc_not_zero(&exp->use))\r\ncontinue;\r\ncb->args[1] = (unsigned long)exp;\r\ngoto out;\r\n}\r\n}\r\nif (cb->args[1]) {\r\ncb->args[1] = 0;\r\ngoto restart;\r\n}\r\ncb->args[0] = 1;\r\nout:\r\nrcu_read_unlock();\r\nif (last)\r\nnf_ct_expect_put(last);\r\nreturn skb->len;\r\n}\r\nstatic int ctnetlink_dump_exp_ct(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nint err;\r\nstruct net *net = sock_net(ctnl);\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct nf_conn *ct;\r\nu16 zone = 0;\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_exp_ct_dump_table,\r\n.done = ctnetlink_exp_done,\r\n};\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_MASTER, u3);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_EXPECT_ZONE]) {\r\nerr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nh = nf_conntrack_find_get(net, zone, &tuple);\r\nif (!h)\r\nreturn -ENOENT;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nc.data = ct;\r\nerr = netlink_dump_start(ctnl, skb, nlh, &c);\r\nnf_ct_put(ct);\r\nreturn err;\r\n}\r\nstatic int\r\nctnetlink_get_expect(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nf_conntrack_expect *exp;\r\nstruct sk_buff *skb2;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nu16 zone;\r\nint err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nif (cda[CTA_EXPECT_MASTER])\r\nreturn ctnetlink_dump_exp_ct(ctnl, skb, nlh, cda);\r\nelse {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_exp_dump_table,\r\n.done = ctnetlink_exp_done,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\n}\r\nerr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nif (cda[CTA_EXPECT_TUPLE])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE, u3);\r\nelse if (cda[CTA_EXPECT_MASTER])\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_MASTER, u3);\r\nelse\r\nreturn -EINVAL;\r\nif (err < 0)\r\nreturn err;\r\nexp = nf_ct_expect_find_get(net, zone, &tuple);\r\nif (!exp)\r\nreturn -ENOENT;\r\nif (cda[CTA_EXPECT_ID]) {\r\n__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);\r\nif (ntohl(id) != (u32)(unsigned long)exp) {\r\nnf_ct_expect_put(exp);\r\nreturn -ENOENT;\r\n}\r\n}\r\nerr = -ENOMEM;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nnf_ct_expect_put(exp);\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nerr = ctnetlink_exp_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq, IPCTNL_MSG_EXP_NEW, exp);\r\nrcu_read_unlock();\r\nnf_ct_expect_put(exp);\r\nif (err <= 0)\r\ngoto free;\r\nerr = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (err < 0)\r\ngoto out;\r\nreturn 0;\r\nfree:\r\nkfree_skb(skb2);\r\nout:\r\nreturn err == -EAGAIN ? -ENOBUFS : err;\r\n}\r\nstatic int\r\nctnetlink_del_expect(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct hlist_node *next;\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nunsigned int i;\r\nu16 zone;\r\nint err;\r\nif (cda[CTA_EXPECT_TUPLE]) {\r\nerr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE, u3);\r\nif (err < 0)\r\nreturn err;\r\nexp = nf_ct_expect_find_get(net, zone, &tuple);\r\nif (!exp)\r\nreturn -ENOENT;\r\nif (cda[CTA_EXPECT_ID]) {\r\n__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);\r\nif (ntohl(id) != (u32)(unsigned long)exp) {\r\nnf_ct_expect_put(exp);\r\nreturn -ENOENT;\r\n}\r\n}\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nif (del_timer(&exp->timeout)) {\r\nnf_ct_unlink_expect_report(exp, NETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\nnf_ct_expect_put(exp);\r\n}\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nnf_ct_expect_put(exp);\r\n} else if (cda[CTA_EXPECT_HELP_NAME]) {\r\nchar *name = nla_data(cda[CTA_EXPECT_HELP_NAME]);\r\nstruct nf_conn_help *m_help;\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nfor (i = 0; i < nf_ct_expect_hsize; i++) {\r\nhlist_for_each_entry_safe(exp, next,\r\n&net->ct.expect_hash[i],\r\nhnode) {\r\nm_help = nfct_help(exp->master);\r\nif (!strcmp(m_help->helper->name, name) &&\r\ndel_timer(&exp->timeout)) {\r\nnf_ct_unlink_expect_report(exp,\r\nNETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\nnf_ct_expect_put(exp);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\n} else {\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nfor (i = 0; i < nf_ct_expect_hsize; i++) {\r\nhlist_for_each_entry_safe(exp, next,\r\n&net->ct.expect_hash[i],\r\nhnode) {\r\nif (del_timer(&exp->timeout)) {\r\nnf_ct_unlink_expect_report(exp,\r\nNETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\nnf_ct_expect_put(exp);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_change_expect(struct nf_conntrack_expect *x,\r\nconst struct nlattr * const cda[])\r\n{\r\nif (cda[CTA_EXPECT_TIMEOUT]) {\r\nif (!del_timer(&x->timeout))\r\nreturn -ETIME;\r\nx->timeout.expires = jiffies +\r\nntohl(nla_get_be32(cda[CTA_EXPECT_TIMEOUT])) * HZ;\r\nadd_timer(&x->timeout);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nctnetlink_parse_expect_nat(const struct nlattr *attr,\r\nstruct nf_conntrack_expect *exp,\r\nu_int8_t u3)\r\n{\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\nstruct nlattr *tb[CTA_EXPECT_NAT_MAX+1];\r\nstruct nf_conntrack_tuple nat_tuple = {};\r\nint err;\r\nerr = nla_parse_nested(tb, CTA_EXPECT_NAT_MAX, attr, exp_nat_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_EXPECT_NAT_DIR] || !tb[CTA_EXPECT_NAT_TUPLE])\r\nreturn -EINVAL;\r\nerr = ctnetlink_parse_tuple((const struct nlattr * const *)tb,\r\n&nat_tuple, CTA_EXPECT_NAT_TUPLE, u3);\r\nif (err < 0)\r\nreturn err;\r\nexp->saved_addr = nat_tuple.src.u3;\r\nexp->saved_proto = nat_tuple.src.u;\r\nexp->dir = ntohl(nla_get_be32(tb[CTA_EXPECT_NAT_DIR]));\r\nreturn 0;\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic struct nf_conntrack_expect *\r\nctnetlink_alloc_expect(const struct nlattr * const cda[], struct nf_conn *ct,\r\nstruct nf_conntrack_helper *helper,\r\nstruct nf_conntrack_tuple *tuple,\r\nstruct nf_conntrack_tuple *mask)\r\n{\r\nu_int32_t class = 0;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conn_help *help;\r\nint err;\r\nif (cda[CTA_EXPECT_CLASS] && helper) {\r\nclass = ntohl(nla_get_be32(cda[CTA_EXPECT_CLASS]));\r\nif (class > helper->expect_class_max)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nexp = nf_ct_expect_alloc(ct);\r\nif (!exp)\r\nreturn ERR_PTR(-ENOMEM);\r\nhelp = nfct_help(ct);\r\nif (!help) {\r\nif (!cda[CTA_EXPECT_TIMEOUT]) {\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nexp->timeout.expires =\r\njiffies + ntohl(nla_get_be32(cda[CTA_EXPECT_TIMEOUT])) * HZ;\r\nexp->flags = NF_CT_EXPECT_USERSPACE;\r\nif (cda[CTA_EXPECT_FLAGS]) {\r\nexp->flags |=\r\nntohl(nla_get_be32(cda[CTA_EXPECT_FLAGS]));\r\n}\r\n} else {\r\nif (cda[CTA_EXPECT_FLAGS]) {\r\nexp->flags = ntohl(nla_get_be32(cda[CTA_EXPECT_FLAGS]));\r\nexp->flags &= ~NF_CT_EXPECT_USERSPACE;\r\n} else\r\nexp->flags = 0;\r\n}\r\nif (cda[CTA_EXPECT_FN]) {\r\nconst char *name = nla_data(cda[CTA_EXPECT_FN]);\r\nstruct nf_ct_helper_expectfn *expfn;\r\nexpfn = nf_ct_helper_expectfn_find_by_name(name);\r\nif (expfn == NULL) {\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nexp->expectfn = expfn->expectfn;\r\n} else\r\nexp->expectfn = NULL;\r\nexp->class = class;\r\nexp->master = ct;\r\nexp->helper = helper;\r\nexp->tuple = *tuple;\r\nexp->mask.src.u3 = mask->src.u3;\r\nexp->mask.src.u.all = mask->src.u.all;\r\nif (cda[CTA_EXPECT_NAT]) {\r\nerr = ctnetlink_parse_expect_nat(cda[CTA_EXPECT_NAT],\r\nexp, nf_ct_l3num(ct));\r\nif (err < 0)\r\ngoto err_out;\r\n}\r\nreturn exp;\r\nerr_out:\r\nnf_ct_expect_put(exp);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\nctnetlink_create_expect(struct net *net, u16 zone,\r\nconst struct nlattr * const cda[],\r\nu_int8_t u3, u32 portid, int report)\r\n{\r\nstruct nf_conntrack_tuple tuple, mask, master_tuple;\r\nstruct nf_conntrack_tuple_hash *h = NULL;\r\nstruct nf_conntrack_helper *helper = NULL;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conn *ct;\r\nint err;\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE, u3);\r\nif (err < 0)\r\nreturn err;\r\nerr = ctnetlink_parse_tuple(cda, &mask, CTA_EXPECT_MASK, u3);\r\nif (err < 0)\r\nreturn err;\r\nerr = ctnetlink_parse_tuple(cda, &master_tuple, CTA_EXPECT_MASTER, u3);\r\nif (err < 0)\r\nreturn err;\r\nh = nf_conntrack_find_get(net, zone, &master_tuple);\r\nif (!h)\r\nreturn -ENOENT;\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nif (cda[CTA_EXPECT_HELP_NAME]) {\r\nconst char *helpname = nla_data(cda[CTA_EXPECT_HELP_NAME]);\r\nhelper = __nf_conntrack_helper_find(helpname, u3,\r\nnf_ct_protonum(ct));\r\nif (helper == NULL) {\r\n#ifdef CONFIG_MODULES\r\nif (request_module("nfct-helper-%s", helpname) < 0) {\r\nerr = -EOPNOTSUPP;\r\ngoto err_ct;\r\n}\r\nhelper = __nf_conntrack_helper_find(helpname, u3,\r\nnf_ct_protonum(ct));\r\nif (helper) {\r\nerr = -EAGAIN;\r\ngoto err_ct;\r\n}\r\n#endif\r\nerr = -EOPNOTSUPP;\r\ngoto err_ct;\r\n}\r\n}\r\nexp = ctnetlink_alloc_expect(cda, ct, helper, &tuple, &mask);\r\nif (IS_ERR(exp)) {\r\nerr = PTR_ERR(exp);\r\ngoto err_ct;\r\n}\r\nerr = nf_ct_expect_related_report(exp, portid, report);\r\nif (err < 0)\r\ngoto err_exp;\r\nreturn 0;\r\nerr_exp:\r\nnf_ct_expect_put(exp);\r\nerr_ct:\r\nnf_ct_put(ct);\r\nreturn err;\r\n}\r\nstatic int\r\nctnetlink_new_expect(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct net *net = sock_net(ctnl);\r\nstruct nf_conntrack_tuple tuple;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int8_t u3 = nfmsg->nfgen_family;\r\nu16 zone;\r\nint err;\r\nif (!cda[CTA_EXPECT_TUPLE]\r\n|| !cda[CTA_EXPECT_MASK]\r\n|| !cda[CTA_EXPECT_MASTER])\r\nreturn -EINVAL;\r\nerr = ctnetlink_parse_zone(cda[CTA_EXPECT_ZONE], &zone);\r\nif (err < 0)\r\nreturn err;\r\nerr = ctnetlink_parse_tuple(cda, &tuple, CTA_EXPECT_TUPLE, u3);\r\nif (err < 0)\r\nreturn err;\r\nspin_lock_bh(&nf_conntrack_expect_lock);\r\nexp = __nf_ct_expect_find(net, zone, &tuple);\r\nif (!exp) {\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nerr = -ENOENT;\r\nif (nlh->nlmsg_flags & NLM_F_CREATE) {\r\nerr = ctnetlink_create_expect(net, zone, cda,\r\nu3,\r\nNETLINK_CB(skb).portid,\r\nnlmsg_report(nlh));\r\n}\r\nreturn err;\r\n}\r\nerr = -EEXIST;\r\nif (!(nlh->nlmsg_flags & NLM_F_EXCL))\r\nerr = ctnetlink_change_expect(exp, cda);\r\nspin_unlock_bh(&nf_conntrack_expect_lock);\r\nreturn err;\r\n}\r\nstatic int\r\nctnetlink_exp_stat_fill_info(struct sk_buff *skb, u32 portid, u32 seq, int cpu,\r\nconst struct ip_conntrack_stat *st)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0, event;\r\nevent = (NFNL_SUBSYS_CTNETLINK << 8 | IPCTNL_MSG_EXP_GET_STATS_CPU);\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(cpu);\r\nif (nla_put_be32(skb, CTA_STATS_EXP_NEW, htonl(st->expect_new)) ||\r\nnla_put_be32(skb, CTA_STATS_EXP_CREATE, htonl(st->expect_create)) ||\r\nnla_put_be32(skb, CTA_STATS_EXP_DELETE, htonl(st->expect_delete)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nctnetlink_exp_stat_cpu_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint cpu;\r\nstruct net *net = sock_net(skb->sk);\r\nif (cb->args[0] == nr_cpu_ids)\r\nreturn 0;\r\nfor (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {\r\nconst struct ip_conntrack_stat *st;\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\nst = per_cpu_ptr(net->ct.stat, cpu);\r\nif (ctnetlink_exp_stat_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\ncpu, st) < 0)\r\nbreak;\r\n}\r\ncb->args[0] = cpu;\r\nreturn skb->len;\r\n}\r\nstatic int\r\nctnetlink_stat_exp_cpu(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnetlink_exp_stat_cpu_dump,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __net_init ctnetlink_net_init(struct net *net)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\r\nint ret;\r\nret = nf_conntrack_register_notifier(net, &ctnl_notifier);\r\nif (ret < 0) {\r\npr_err("ctnetlink_init: cannot register notifier.\n");\r\ngoto err_out;\r\n}\r\nret = nf_ct_expect_register_notifier(net, &ctnl_notifier_exp);\r\nif (ret < 0) {\r\npr_err("ctnetlink_init: cannot expect register notifier.\n");\r\ngoto err_unreg_notifier;\r\n}\r\n#endif\r\nreturn 0;\r\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\r\nerr_unreg_notifier:\r\nnf_conntrack_unregister_notifier(net, &ctnl_notifier);\r\nerr_out:\r\nreturn ret;\r\n#endif\r\n}\r\nstatic void ctnetlink_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\r\nnf_ct_expect_unregister_notifier(net, &ctnl_notifier_exp);\r\nnf_conntrack_unregister_notifier(net, &ctnl_notifier);\r\n#endif\r\n}\r\nstatic void __net_exit ctnetlink_net_exit_batch(struct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nctnetlink_net_exit(net);\r\n}\r\nstatic int __init ctnetlink_init(void)\r\n{\r\nint ret;\r\npr_info("ctnetlink v%s: registering with nfnetlink.\n", version);\r\nret = nfnetlink_subsys_register(&ctnl_subsys);\r\nif (ret < 0) {\r\npr_err("ctnetlink_init: cannot register with nfnetlink.\n");\r\ngoto err_out;\r\n}\r\nret = nfnetlink_subsys_register(&ctnl_exp_subsys);\r\nif (ret < 0) {\r\npr_err("ctnetlink_init: cannot register exp with nfnetlink.\n");\r\ngoto err_unreg_subsys;\r\n}\r\nret = register_pernet_subsys(&ctnetlink_net_ops);\r\nif (ret < 0) {\r\npr_err("ctnetlink_init: cannot register pernet operations\n");\r\ngoto err_unreg_exp_subsys;\r\n}\r\n#ifdef CONFIG_NETFILTER_NETLINK_QUEUE_CT\r\nRCU_INIT_POINTER(nfq_ct_hook, &ctnetlink_nfqueue_hook);\r\n#endif\r\nreturn 0;\r\nerr_unreg_exp_subsys:\r\nnfnetlink_subsys_unregister(&ctnl_exp_subsys);\r\nerr_unreg_subsys:\r\nnfnetlink_subsys_unregister(&ctnl_subsys);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit ctnetlink_exit(void)\r\n{\r\npr_info("ctnetlink: unregistering from nfnetlink.\n");\r\nunregister_pernet_subsys(&ctnetlink_net_ops);\r\nnfnetlink_subsys_unregister(&ctnl_exp_subsys);\r\nnfnetlink_subsys_unregister(&ctnl_subsys);\r\n#ifdef CONFIG_NETFILTER_NETLINK_QUEUE_CT\r\nRCU_INIT_POINTER(nfq_ct_hook, NULL);\r\n#endif\r\n}
