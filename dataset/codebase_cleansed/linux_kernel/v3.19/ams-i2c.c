static s32 ams_i2c_read(u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(ams_info.i2c_client, reg);\r\n}\r\nstatic int ams_i2c_write(u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(ams_info.i2c_client, reg, value);\r\n}\r\nstatic int ams_i2c_cmd(enum ams_i2c_cmd cmd)\r\n{\r\ns32 result;\r\nint count = 3;\r\nams_i2c_write(AMS_COMMAND, cmd);\r\nmsleep(5);\r\nwhile (count--) {\r\nresult = ams_i2c_read(AMS_COMMAND);\r\nif (result == 0 || result & 0x80)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(HZ / 20);\r\n}\r\nreturn -1;\r\n}\r\nstatic void ams_i2c_set_irq(enum ams_irq reg, char enable)\r\n{\r\nif (reg & AMS_IRQ_FREEFALL) {\r\nu8 val = ams_i2c_read(AMS_CTRLX);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_i2c_write(AMS_CTRLX, val);\r\n}\r\nif (reg & AMS_IRQ_SHOCK) {\r\nu8 val = ams_i2c_read(AMS_CTRLY);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_i2c_write(AMS_CTRLY, val);\r\n}\r\nif (reg & AMS_IRQ_GLOBAL) {\r\nu8 val = ams_i2c_read(AMS_CTRLZ);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_i2c_write(AMS_CTRLZ, val);\r\n}\r\n}\r\nstatic void ams_i2c_clear_irq(enum ams_irq reg)\r\n{\r\nif (reg & AMS_IRQ_FREEFALL)\r\nams_i2c_write(AMS_FREEFALL, 0);\r\nif (reg & AMS_IRQ_SHOCK)\r\nams_i2c_write(AMS_SHOCK, 0);\r\n}\r\nstatic u8 ams_i2c_get_vendor(void)\r\n{\r\nreturn ams_i2c_read(AMS_VENDOR);\r\n}\r\nstatic void ams_i2c_get_xyz(s8 *x, s8 *y, s8 *z)\r\n{\r\n*x = ams_i2c_read(AMS_DATAX);\r\n*y = ams_i2c_read(AMS_DATAY);\r\n*z = ams_i2c_read(AMS_DATAZ);\r\n}\r\nstatic int ams_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint vmaj, vmin;\r\nint result;\r\nif (unlikely(ams_info.has_device))\r\nreturn -ENODEV;\r\nams_info.i2c_client = client;\r\nif (ams_i2c_cmd(AMS_CMD_RESET)) {\r\nprintk(KERN_INFO "ams: Failed to reset the device\n");\r\nreturn -ENODEV;\r\n}\r\nif (ams_i2c_cmd(AMS_CMD_START)) {\r\nprintk(KERN_INFO "ams: Failed to start the device\n");\r\nreturn -ENODEV;\r\n}\r\nams_i2c_write(AMS_CTRL1, 0x02);\r\nams_i2c_write(AMS_CTRL2, 0x85);\r\nams_i2c_write(AMS_CTRL3, 0x01);\r\nams_i2c_cmd(AMS_CMD_READMEM);\r\nvmaj = ams_i2c_read(AMS_DATA1);\r\nvmin = ams_i2c_read(AMS_DATA2);\r\nif (vmaj != 1 || vmin != 52) {\r\nprintk(KERN_INFO "ams: Incorrect device version (%d.%d)\n",\r\nvmaj, vmin);\r\nreturn -ENODEV;\r\n}\r\nams_i2c_cmd(AMS_CMD_VERSION);\r\nvmaj = ams_i2c_read(AMS_DATA1);\r\nvmin = ams_i2c_read(AMS_DATA2);\r\nif (vmaj != 0 || vmin != 1) {\r\nprintk(KERN_INFO "ams: Incorrect firmware version (%d.%d)\n",\r\nvmaj, vmin);\r\nreturn -ENODEV;\r\n}\r\nams_i2c_set_irq(AMS_IRQ_ALL, 0);\r\nresult = ams_sensor_attach();\r\nif (result < 0)\r\nreturn result;\r\nams_i2c_write(AMS_SENSLOW, 0x15);\r\nams_i2c_write(AMS_SENSHIGH, 0x60);\r\nams_i2c_write(AMS_CTRLX, 0x08);\r\nams_i2c_write(AMS_CTRLY, 0x0F);\r\nams_i2c_write(AMS_CTRLZ, 0x4F);\r\nams_i2c_write(AMS_UNKNOWN1, 0x14);\r\nams_i2c_clear_irq(AMS_IRQ_ALL);\r\nams_info.has_device = 1;\r\nams_i2c_set_irq(AMS_IRQ_ALL, 1);\r\nprintk(KERN_INFO "ams: Found I2C based motion sensor\n");\r\nreturn 0;\r\n}\r\nstatic int ams_i2c_remove(struct i2c_client *client)\r\n{\r\nif (ams_info.has_device) {\r\nams_sensor_detach();\r\nams_i2c_set_irq(AMS_IRQ_ALL, 0);\r\nams_i2c_clear_irq(AMS_IRQ_ALL);\r\nprintk(KERN_INFO "ams: Unloading\n");\r\nams_info.has_device = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ams_i2c_exit(void)\r\n{\r\ni2c_del_driver(&ams_i2c_driver);\r\n}\r\nint __init ams_i2c_init(struct device_node *np)\r\n{\r\nint result;\r\nams_info.of_node = np;\r\nams_info.exit = ams_i2c_exit;\r\nams_info.get_vendor = ams_i2c_get_vendor;\r\nams_info.get_xyz = ams_i2c_get_xyz;\r\nams_info.clear_irq = ams_i2c_clear_irq;\r\nams_info.bustype = BUS_I2C;\r\nresult = i2c_add_driver(&ams_i2c_driver);\r\nreturn result;\r\n}
