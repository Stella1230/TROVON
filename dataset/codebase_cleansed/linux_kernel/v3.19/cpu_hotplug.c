static void enable_hotplug_cpu(int cpu)\r\n{\r\nif (!cpu_present(cpu))\r\narch_register_cpu(cpu);\r\nset_cpu_present(cpu, true);\r\n}\r\nstatic void disable_hotplug_cpu(int cpu)\r\n{\r\nif (cpu_present(cpu))\r\narch_unregister_cpu(cpu);\r\nset_cpu_present(cpu, false);\r\n}\r\nstatic int vcpu_online(unsigned int cpu)\r\n{\r\nint err;\r\nchar dir[16], state[16];\r\nsprintf(dir, "cpu/%u", cpu);\r\nerr = xenbus_scanf(XBT_NIL, dir, "availability", "%15s", state);\r\nif (err != 1) {\r\nif (!xen_initial_domain())\r\npr_err("Unable to read cpu state\n");\r\nreturn err;\r\n}\r\nif (strcmp(state, "online") == 0)\r\nreturn 1;\r\nelse if (strcmp(state, "offline") == 0)\r\nreturn 0;\r\npr_err("unknown state(%s) on CPU%d\n", state, cpu);\r\nreturn -EINVAL;\r\n}\r\nstatic void vcpu_hotplug(unsigned int cpu)\r\n{\r\nif (!cpu_possible(cpu))\r\nreturn;\r\nswitch (vcpu_online(cpu)) {\r\ncase 1:\r\nenable_hotplug_cpu(cpu);\r\nbreak;\r\ncase 0:\r\n(void)cpu_down(cpu);\r\ndisable_hotplug_cpu(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void handle_vcpu_hotplug_event(struct xenbus_watch *watch,\r\nconst char **vec, unsigned int len)\r\n{\r\nunsigned int cpu;\r\nchar *cpustr;\r\nconst char *node = vec[XS_WATCH_PATH];\r\ncpustr = strstr(node, "cpu/");\r\nif (cpustr != NULL) {\r\nsscanf(cpustr, "cpu/%u", &cpu);\r\nvcpu_hotplug(cpu);\r\n}\r\n}\r\nstatic int setup_cpu_watcher(struct notifier_block *notifier,\r\nunsigned long event, void *data)\r\n{\r\nint cpu;\r\nstatic struct xenbus_watch cpu_watch = {\r\n.node = "cpu",\r\n.callback = handle_vcpu_hotplug_event};\r\n(void)register_xenbus_watch(&cpu_watch);\r\nfor_each_possible_cpu(cpu) {\r\nif (vcpu_online(cpu) == 0) {\r\n(void)cpu_down(cpu);\r\nset_cpu_present(cpu, false);\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init setup_vcpu_hotplug_event(void)\r\n{\r\nstatic struct notifier_block xsn_cpu = {\r\n.notifier_call = setup_cpu_watcher };\r\nif (!xen_pv_domain())\r\nreturn -ENODEV;\r\nregister_xenstore_notifier(&xsn_cpu);\r\nreturn 0;\r\n}
