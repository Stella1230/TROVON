void cvmx_pko_initialize_global(void)\r\n{\r\nint i;\r\nuint64_t priority = 8;\r\nunion cvmx_pko_reg_cmd_buf config;\r\nconfig.u64 = 0;\r\nconfig.s.pool = CVMX_FPA_OUTPUT_BUFFER_POOL;\r\nconfig.s.size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE / 8 - 1;\r\ncvmx_write_csr(CVMX_PKO_REG_CMD_BUF, config.u64);\r\nfor (i = 0; i < CVMX_PKO_MAX_OUTPUT_QUEUES; i++)\r\ncvmx_pko_config_port(CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID, i, 1,\r\n&priority);\r\nif (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN56XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN52XX)) {\r\nint num_interfaces = cvmx_helper_get_number_of_interfaces();\r\nint last_port =\r\ncvmx_helper_get_last_ipd_port(num_interfaces - 1);\r\nint max_queues =\r\ncvmx_pko_get_base_queue(last_port) +\r\ncvmx_pko_get_num_queues(last_port);\r\nif (OCTEON_IS_MODEL(OCTEON_CN38XX)) {\r\nif (max_queues <= 32)\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);\r\nelse if (max_queues <= 64)\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);\r\n} else {\r\nif (max_queues <= 64)\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);\r\nelse if (max_queues <= 128)\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);\r\n}\r\n}\r\n}\r\nint cvmx_pko_initialize_local(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid cvmx_pko_enable(void)\r\n{\r\nunion cvmx_pko_reg_flags flags;\r\nflags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);\r\nif (flags.s.ena_pko)\r\ncvmx_dprintf\r\n("Warning: Enabling PKO when PKO already enabled.\n");\r\nflags.s.ena_dwb = 1;\r\nflags.s.ena_pko = 1;\r\nflags.s.store_be = 1;\r\ncvmx_write_csr(CVMX_PKO_REG_FLAGS, flags.u64);\r\n}\r\nvoid cvmx_pko_disable(void)\r\n{\r\nunion cvmx_pko_reg_flags pko_reg_flags;\r\npko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);\r\npko_reg_flags.s.ena_pko = 0;\r\ncvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);\r\n}\r\nstatic void __cvmx_pko_reset(void)\r\n{\r\nunion cvmx_pko_reg_flags pko_reg_flags;\r\npko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);\r\npko_reg_flags.s.reset = 1;\r\ncvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);\r\n}\r\nvoid cvmx_pko_shutdown(void)\r\n{\r\nunion cvmx_pko_mem_queue_ptrs config;\r\nint queue;\r\ncvmx_pko_disable();\r\nfor (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {\r\nconfig.u64 = 0;\r\nconfig.s.tail = 1;\r\nconfig.s.index = 0;\r\nconfig.s.port = CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID;\r\nconfig.s.queue = queue & 0x7f;\r\nconfig.s.qos_mask = 0;\r\nconfig.s.buf_ptr = 0;\r\nif (!OCTEON_IS_MODEL(OCTEON_CN3XXX)) {\r\nunion cvmx_pko_reg_queue_ptrs1 config1;\r\nconfig1.u64 = 0;\r\nconfig1.s.qid7 = queue >> 7;\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);\r\n}\r\ncvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);\r\ncvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));\r\n}\r\n__cvmx_pko_reset();\r\n}\r\ncvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,\r\nuint64_t num_queues,\r\nconst uint64_t priority[])\r\n{\r\ncvmx_pko_status_t result_code;\r\nuint64_t queue;\r\nunion cvmx_pko_mem_queue_ptrs config;\r\nunion cvmx_pko_reg_queue_ptrs1 config1;\r\nint static_priority_base = -1;\r\nint static_priority_end = -1;\r\nif ((port >= CVMX_PKO_NUM_OUTPUT_PORTS)\r\n&& (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID)) {\r\ncvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid port %llu\n",\r\n(unsigned long long)port);\r\nreturn CVMX_PKO_INVALID_PORT;\r\n}\r\nif (base_queue + num_queues > CVMX_PKO_MAX_OUTPUT_QUEUES) {\r\ncvmx_dprintf\r\n("ERROR: cvmx_pko_config_port: Invalid queue range %llu\n",\r\n(unsigned long long)(base_queue + num_queues));\r\nreturn CVMX_PKO_INVALID_QUEUE;\r\n}\r\nif (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID) {\r\nfor (queue = 0; queue < num_queues; queue++) {\r\nif (static_priority_base == -1\r\n&& priority[queue] ==\r\nCVMX_PKO_QUEUE_STATIC_PRIORITY)\r\nstatic_priority_base = queue;\r\nif (static_priority_base != -1\r\n&& static_priority_end == -1\r\n&& priority[queue] != CVMX_PKO_QUEUE_STATIC_PRIORITY\r\n&& queue)\r\nstatic_priority_end = queue - 1;\r\nelse if (static_priority_base != -1\r\n&& static_priority_end == -1\r\n&& queue == num_queues - 1)\r\nstatic_priority_end = queue;\r\nif (static_priority_end != -1\r\n&& (int)queue > static_priority_end\r\n&& priority[queue] ==\r\nCVMX_PKO_QUEUE_STATIC_PRIORITY) {\r\ncvmx_dprintf("ERROR: cvmx_pko_config_port: "\r\n"Static priority queues aren't "\r\n"contiguous or don't start at "\r\n"base queue. q: %d, eq: %d\n",\r\n(int)queue, static_priority_end);\r\nreturn CVMX_PKO_INVALID_PRIORITY;\r\n}\r\n}\r\nif (static_priority_base > 0) {\r\ncvmx_dprintf("ERROR: cvmx_pko_config_port: Static "\r\n"priority queues don't start at base "\r\n"queue. sq: %d\n",\r\nstatic_priority_base);\r\nreturn CVMX_PKO_INVALID_PRIORITY;\r\n}\r\n#if 0\r\ncvmx_dprintf("Port %d: Static priority queue base: %d, "\r\n"end: %d\n", port,\r\nstatic_priority_base, static_priority_end);\r\n#endif\r\n}\r\nresult_code = CVMX_PKO_SUCCESS;\r\n#ifdef PKO_DEBUG\r\ncvmx_dprintf("num queues: %d (%lld,%lld)\n", num_queues,\r\nCVMX_PKO_QUEUES_PER_PORT_INTERFACE0,\r\nCVMX_PKO_QUEUES_PER_PORT_INTERFACE1);\r\n#endif\r\nfor (queue = 0; queue < num_queues; queue++) {\r\nuint64_t *buf_ptr = NULL;\r\nconfig1.u64 = 0;\r\nconfig1.s.idx3 = queue >> 3;\r\nconfig1.s.qid7 = (base_queue + queue) >> 7;\r\nconfig.u64 = 0;\r\nconfig.s.tail = queue == (num_queues - 1);\r\nconfig.s.index = queue;\r\nconfig.s.port = port;\r\nconfig.s.queue = base_queue + queue;\r\nif (!cvmx_octeon_is_pass1()) {\r\nconfig.s.static_p = static_priority_base >= 0;\r\nconfig.s.static_q = (int)queue <= static_priority_end;\r\nconfig.s.s_tail = (int)queue == static_priority_end;\r\n}\r\nswitch ((int)priority[queue]) {\r\ncase 0:\r\nconfig.s.qos_mask = 0x00;\r\nbreak;\r\ncase 1:\r\nconfig.s.qos_mask = 0x01;\r\nbreak;\r\ncase 2:\r\nconfig.s.qos_mask = 0x11;\r\nbreak;\r\ncase 3:\r\nconfig.s.qos_mask = 0x49;\r\nbreak;\r\ncase 4:\r\nconfig.s.qos_mask = 0x55;\r\nbreak;\r\ncase 5:\r\nconfig.s.qos_mask = 0x57;\r\nbreak;\r\ncase 6:\r\nconfig.s.qos_mask = 0x77;\r\nbreak;\r\ncase 7:\r\nconfig.s.qos_mask = 0x7f;\r\nbreak;\r\ncase 8:\r\nconfig.s.qos_mask = 0xff;\r\nbreak;\r\ncase CVMX_PKO_QUEUE_STATIC_PRIORITY:\r\nif (!cvmx_octeon_is_pass1()) {\r\nconfig.s.qos_mask = 0xff;\r\nbreak;\r\n}\r\ndefault:\r\ncvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid "\r\n"priority %llu\n",\r\n(unsigned long long)priority[queue]);\r\nconfig.s.qos_mask = 0xff;\r\nresult_code = CVMX_PKO_INVALID_PRIORITY;\r\nbreak;\r\n}\r\nif (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID) {\r\ncvmx_cmd_queue_result_t cmd_res =\r\ncvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_PKO\r\n(base_queue + queue),\r\nCVMX_PKO_MAX_QUEUE_DEPTH,\r\nCVMX_FPA_OUTPUT_BUFFER_POOL,\r\nCVMX_FPA_OUTPUT_BUFFER_POOL_SIZE\r\n-\r\nCVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST\r\n* 8);\r\nif (cmd_res != CVMX_CMD_QUEUE_SUCCESS) {\r\nswitch (cmd_res) {\r\ncase CVMX_CMD_QUEUE_NO_MEMORY:\r\ncvmx_dprintf("ERROR: "\r\n"cvmx_pko_config_port: "\r\n"Unable to allocate "\r\n"output buffer.\n");\r\nreturn CVMX_PKO_NO_MEMORY;\r\ncase CVMX_CMD_QUEUE_ALREADY_SETUP:\r\ncvmx_dprintf\r\n("ERROR: cvmx_pko_config_port: Port already setup.\n");\r\nreturn CVMX_PKO_PORT_ALREADY_SETUP;\r\ncase CVMX_CMD_QUEUE_INVALID_PARAM:\r\ndefault:\r\ncvmx_dprintf\r\n("ERROR: cvmx_pko_config_port: Command queue initialization failed.\n");\r\nreturn CVMX_PKO_CMD_QUEUE_INIT_ERROR;\r\n}\r\n}\r\nbuf_ptr =\r\n(uint64_t *)\r\ncvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_PKO\r\n(base_queue + queue));\r\nconfig.s.buf_ptr = cvmx_ptr_to_phys(buf_ptr);\r\n} else\r\nconfig.s.buf_ptr = 0;\r\nCVMX_SYNCWS;\r\nif (!OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\ncvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);\r\ncvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);\r\n}\r\nreturn result_code;\r\n}\r\nvoid cvmx_pko_show_queue_map()\r\n{\r\nint core, port;\r\nint pko_output_ports = 36;\r\ncvmx_dprintf("port");\r\nfor (port = 0; port < pko_output_ports; port++)\r\ncvmx_dprintf("%3d ", port);\r\ncvmx_dprintf("\n");\r\nfor (core = 0; core < CVMX_MAX_CORES; core++) {\r\ncvmx_dprintf("\n%2d: ", core);\r\nfor (port = 0; port < pko_output_ports; port++) {\r\ncvmx_dprintf("%3d ",\r\ncvmx_pko_get_base_queue_per_core(port,\r\ncore));\r\n}\r\n}\r\ncvmx_dprintf("\n");\r\n}\r\nint cvmx_pko_rate_limit_packets(int port, int packets_s, int burst)\r\n{\r\nunion cvmx_pko_mem_port_rate0 pko_mem_port_rate0;\r\nunion cvmx_pko_mem_port_rate1 pko_mem_port_rate1;\r\npko_mem_port_rate0.u64 = 0;\r\npko_mem_port_rate0.s.pid = port;\r\npko_mem_port_rate0.s.rate_pkt =\r\ncvmx_sysinfo_get()->cpu_clock_hz / packets_s / 16;\r\npko_mem_port_rate0.s.rate_word = 0;\r\npko_mem_port_rate1.u64 = 0;\r\npko_mem_port_rate1.s.pid = port;\r\npko_mem_port_rate1.s.rate_lim =\r\n((uint64_t) pko_mem_port_rate0.s.rate_pkt * burst) >> 8;\r\ncvmx_write_csr(CVMX_PKO_MEM_PORT_RATE0, pko_mem_port_rate0.u64);\r\ncvmx_write_csr(CVMX_PKO_MEM_PORT_RATE1, pko_mem_port_rate1.u64);\r\nreturn 0;\r\n}\r\nint cvmx_pko_rate_limit_bits(int port, uint64_t bits_s, int burst)\r\n{\r\nunion cvmx_pko_mem_port_rate0 pko_mem_port_rate0;\r\nunion cvmx_pko_mem_port_rate1 pko_mem_port_rate1;\r\nuint64_t clock_rate = cvmx_sysinfo_get()->cpu_clock_hz;\r\nuint64_t tokens_per_bit = clock_rate * 16 / bits_s;\r\npko_mem_port_rate0.u64 = 0;\r\npko_mem_port_rate0.s.pid = port;\r\npko_mem_port_rate0.s.rate_pkt = (12 + 8 + 4) * 8 * tokens_per_bit / 256;\r\npko_mem_port_rate0.s.rate_word = 64 * tokens_per_bit;\r\npko_mem_port_rate1.u64 = 0;\r\npko_mem_port_rate1.s.pid = port;\r\npko_mem_port_rate1.s.rate_lim = tokens_per_bit * burst / 256;\r\ncvmx_write_csr(CVMX_PKO_MEM_PORT_RATE0, pko_mem_port_rate0.u64);\r\ncvmx_write_csr(CVMX_PKO_MEM_PORT_RATE1, pko_mem_port_rate1.u64);\r\nreturn 0;\r\n}
