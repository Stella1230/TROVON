static struct tcf_ematch_ops *tcf_em_lookup(u16 kind)\r\n{\r\nstruct tcf_ematch_ops *e = NULL;\r\nread_lock(&ematch_mod_lock);\r\nlist_for_each_entry(e, &ematch_ops, link) {\r\nif (kind == e->kind) {\r\nif (!try_module_get(e->owner))\r\ne = NULL;\r\nread_unlock(&ematch_mod_lock);\r\nreturn e;\r\n}\r\n}\r\nread_unlock(&ematch_mod_lock);\r\nreturn NULL;\r\n}\r\nint tcf_em_register(struct tcf_ematch_ops *ops)\r\n{\r\nint err = -EEXIST;\r\nstruct tcf_ematch_ops *e;\r\nif (ops->match == NULL)\r\nreturn -EINVAL;\r\nwrite_lock(&ematch_mod_lock);\r\nlist_for_each_entry(e, &ematch_ops, link)\r\nif (ops->kind == e->kind)\r\ngoto errout;\r\nlist_add_tail(&ops->link, &ematch_ops);\r\nerr = 0;\r\nerrout:\r\nwrite_unlock(&ematch_mod_lock);\r\nreturn err;\r\n}\r\nvoid tcf_em_unregister(struct tcf_ematch_ops *ops)\r\n{\r\nwrite_lock(&ematch_mod_lock);\r\nlist_del(&ops->link);\r\nwrite_unlock(&ematch_mod_lock);\r\n}\r\nstatic inline struct tcf_ematch *tcf_em_get_match(struct tcf_ematch_tree *tree,\r\nint index)\r\n{\r\nreturn &tree->matches[index];\r\n}\r\nstatic int tcf_em_validate(struct tcf_proto *tp,\r\nstruct tcf_ematch_tree_hdr *tree_hdr,\r\nstruct tcf_ematch *em, struct nlattr *nla, int idx)\r\n{\r\nint err = -EINVAL;\r\nstruct tcf_ematch_hdr *em_hdr = nla_data(nla);\r\nint data_len = nla_len(nla) - sizeof(*em_hdr);\r\nvoid *data = (void *) em_hdr + sizeof(*em_hdr);\r\nstruct net *net = dev_net(qdisc_dev(tp->q));\r\nif (!TCF_EM_REL_VALID(em_hdr->flags))\r\ngoto errout;\r\nif (em_hdr->kind == TCF_EM_CONTAINER) {\r\nu32 ref;\r\nif (data_len < sizeof(ref))\r\ngoto errout;\r\nref = *(u32 *) data;\r\nif (ref >= tree_hdr->nmatches)\r\ngoto errout;\r\nif (ref <= idx)\r\ngoto errout;\r\nem->data = ref;\r\n} else {\r\nem->ops = tcf_em_lookup(em_hdr->kind);\r\nif (em->ops == NULL) {\r\nerr = -ENOENT;\r\n#ifdef CONFIG_MODULES\r\n__rtnl_unlock();\r\nrequest_module("ematch-kind-%u", em_hdr->kind);\r\nrtnl_lock();\r\nem->ops = tcf_em_lookup(em_hdr->kind);\r\nif (em->ops) {\r\nmodule_put(em->ops->owner);\r\nerr = -EAGAIN;\r\n}\r\n#endif\r\ngoto errout;\r\n}\r\nif (em->ops->datalen && data_len < em->ops->datalen)\r\ngoto errout;\r\nif (em->ops->change) {\r\nerr = em->ops->change(net, data, data_len, em);\r\nif (err < 0)\r\ngoto errout;\r\n} else if (data_len > 0) {\r\nif (em_hdr->flags & TCF_EM_SIMPLE) {\r\nif (data_len < sizeof(u32))\r\ngoto errout;\r\nem->data = *(u32 *) data;\r\n} else {\r\nvoid *v = kmemdup(data, data_len, GFP_KERNEL);\r\nif (v == NULL) {\r\nerr = -ENOBUFS;\r\ngoto errout;\r\n}\r\nem->data = (unsigned long) v;\r\n}\r\n}\r\n}\r\nem->matchid = em_hdr->matchid;\r\nem->flags = em_hdr->flags;\r\nem->datalen = data_len;\r\nem->net = net;\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nint tcf_em_tree_validate(struct tcf_proto *tp, struct nlattr *nla,\r\nstruct tcf_ematch_tree *tree)\r\n{\r\nint idx, list_len, matches_len, err;\r\nstruct nlattr *tb[TCA_EMATCH_TREE_MAX + 1];\r\nstruct nlattr *rt_match, *rt_hdr, *rt_list;\r\nstruct tcf_ematch_tree_hdr *tree_hdr;\r\nstruct tcf_ematch *em;\r\nmemset(tree, 0, sizeof(*tree));\r\nif (!nla)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, TCA_EMATCH_TREE_MAX, nla, em_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nrt_hdr = tb[TCA_EMATCH_TREE_HDR];\r\nrt_list = tb[TCA_EMATCH_TREE_LIST];\r\nif (rt_hdr == NULL || rt_list == NULL)\r\ngoto errout;\r\ntree_hdr = nla_data(rt_hdr);\r\nmemcpy(&tree->hdr, tree_hdr, sizeof(*tree_hdr));\r\nrt_match = nla_data(rt_list);\r\nlist_len = nla_len(rt_list);\r\nmatches_len = tree_hdr->nmatches * sizeof(*em);\r\ntree->matches = kzalloc(matches_len, GFP_KERNEL);\r\nif (tree->matches == NULL)\r\ngoto errout;\r\nfor (idx = 0; nla_ok(rt_match, list_len); idx++) {\r\nerr = -EINVAL;\r\nif (rt_match->nla_type != (idx + 1))\r\ngoto errout_abort;\r\nif (idx >= tree_hdr->nmatches)\r\ngoto errout_abort;\r\nif (nla_len(rt_match) < sizeof(struct tcf_ematch_hdr))\r\ngoto errout_abort;\r\nem = tcf_em_get_match(tree, idx);\r\nerr = tcf_em_validate(tp, tree_hdr, em, rt_match, idx);\r\nif (err < 0)\r\ngoto errout_abort;\r\nrt_match = nla_next(rt_match, &list_len);\r\n}\r\nif (idx != tree_hdr->nmatches) {\r\nerr = -EINVAL;\r\ngoto errout_abort;\r\n}\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\nerrout_abort:\r\ntcf_em_tree_destroy(tree);\r\nreturn err;\r\n}\r\nvoid tcf_em_tree_destroy(struct tcf_ematch_tree *tree)\r\n{\r\nint i;\r\nif (tree->matches == NULL)\r\nreturn;\r\nfor (i = 0; i < tree->hdr.nmatches; i++) {\r\nstruct tcf_ematch *em = tcf_em_get_match(tree, i);\r\nif (em->ops) {\r\nif (em->ops->destroy)\r\nem->ops->destroy(em);\r\nelse if (!tcf_em_is_simple(em))\r\nkfree((void *) em->data);\r\nmodule_put(em->ops->owner);\r\n}\r\n}\r\ntree->hdr.nmatches = 0;\r\nkfree(tree->matches);\r\ntree->matches = NULL;\r\n}\r\nint tcf_em_tree_dump(struct sk_buff *skb, struct tcf_ematch_tree *tree, int tlv)\r\n{\r\nint i;\r\nu8 *tail;\r\nstruct nlattr *top_start;\r\nstruct nlattr *list_start;\r\ntop_start = nla_nest_start(skb, tlv);\r\nif (top_start == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put(skb, TCA_EMATCH_TREE_HDR, sizeof(tree->hdr), &tree->hdr))\r\ngoto nla_put_failure;\r\nlist_start = nla_nest_start(skb, TCA_EMATCH_TREE_LIST);\r\nif (list_start == NULL)\r\ngoto nla_put_failure;\r\ntail = skb_tail_pointer(skb);\r\nfor (i = 0; i < tree->hdr.nmatches; i++) {\r\nstruct nlattr *match_start = (struct nlattr *)tail;\r\nstruct tcf_ematch *em = tcf_em_get_match(tree, i);\r\nstruct tcf_ematch_hdr em_hdr = {\r\n.kind = em->ops ? em->ops->kind : TCF_EM_CONTAINER,\r\n.matchid = em->matchid,\r\n.flags = em->flags\r\n};\r\nif (nla_put(skb, i + 1, sizeof(em_hdr), &em_hdr))\r\ngoto nla_put_failure;\r\nif (em->ops && em->ops->dump) {\r\nif (em->ops->dump(skb, em) < 0)\r\ngoto nla_put_failure;\r\n} else if (tcf_em_is_container(em) || tcf_em_is_simple(em)) {\r\nu32 u = em->data;\r\nnla_put_nohdr(skb, sizeof(u), &u);\r\n} else if (em->datalen > 0)\r\nnla_put_nohdr(skb, em->datalen, (void *) em->data);\r\ntail = skb_tail_pointer(skb);\r\nmatch_start->nla_len = tail - (u8 *)match_start;\r\n}\r\nnla_nest_end(skb, list_start);\r\nnla_nest_end(skb, top_start);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline int tcf_em_match(struct sk_buff *skb, struct tcf_ematch *em,\r\nstruct tcf_pkt_info *info)\r\n{\r\nint r = em->ops->match(skb, em, info);\r\nreturn tcf_em_is_inverted(em) ? !r : r;\r\n}\r\nint __tcf_em_tree_match(struct sk_buff *skb, struct tcf_ematch_tree *tree,\r\nstruct tcf_pkt_info *info)\r\n{\r\nint stackp = 0, match_idx = 0, res = 0;\r\nstruct tcf_ematch *cur_match;\r\nint stack[CONFIG_NET_EMATCH_STACK];\r\nproceed:\r\nwhile (match_idx < tree->hdr.nmatches) {\r\ncur_match = tcf_em_get_match(tree, match_idx);\r\nif (tcf_em_is_container(cur_match)) {\r\nif (unlikely(stackp >= CONFIG_NET_EMATCH_STACK))\r\ngoto stack_overflow;\r\nstack[stackp++] = match_idx;\r\nmatch_idx = cur_match->data;\r\ngoto proceed;\r\n}\r\nres = tcf_em_match(skb, cur_match, info);\r\nif (tcf_em_early_end(cur_match, res))\r\nbreak;\r\nmatch_idx++;\r\n}\r\npop_stack:\r\nif (stackp > 0) {\r\nmatch_idx = stack[--stackp];\r\ncur_match = tcf_em_get_match(tree, match_idx);\r\nif (tcf_em_is_inverted(cur_match))\r\nres = !res;\r\nif (tcf_em_early_end(cur_match, res)) {\r\ngoto pop_stack;\r\n} else {\r\nmatch_idx++;\r\ngoto proceed;\r\n}\r\n}\r\nreturn res;\r\nstack_overflow:\r\nnet_warn_ratelimited("tc ematch: local stack overflow, increase NET_EMATCH_STACK\n");\r\nreturn -1;\r\n}
