static int macio_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nconst struct of_device_id * matches = drv->of_match_table;\r\nif (!matches)\r\nreturn 0;\r\nreturn of_match_device(matches, dev) != NULL;\r\n}\r\nstruct macio_dev *macio_dev_get(struct macio_dev *dev)\r\n{\r\nstruct device *tmp;\r\nif (!dev)\r\nreturn NULL;\r\ntmp = get_device(&dev->ofdev.dev);\r\nif (tmp)\r\nreturn to_macio_device(tmp);\r\nelse\r\nreturn NULL;\r\n}\r\nvoid macio_dev_put(struct macio_dev *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->ofdev.dev);\r\n}\r\nstatic int macio_device_probe(struct device *dev)\r\n{\r\nint error = -ENODEV;\r\nstruct macio_driver *drv;\r\nstruct macio_dev *macio_dev;\r\nconst struct of_device_id *match;\r\ndrv = to_macio_driver(dev->driver);\r\nmacio_dev = to_macio_device(dev);\r\nif (!drv->probe)\r\nreturn error;\r\nmacio_dev_get(macio_dev);\r\nmatch = of_match_device(drv->driver.of_match_table, dev);\r\nif (match)\r\nerror = drv->probe(macio_dev, match);\r\nif (error)\r\nmacio_dev_put(macio_dev);\r\nreturn error;\r\n}\r\nstatic int macio_device_remove(struct device *dev)\r\n{\r\nstruct macio_dev * macio_dev = to_macio_device(dev);\r\nstruct macio_driver * drv = to_macio_driver(dev->driver);\r\nif (dev->driver && drv->remove)\r\ndrv->remove(macio_dev);\r\nmacio_dev_put(macio_dev);\r\nreturn 0;\r\n}\r\nstatic void macio_device_shutdown(struct device *dev)\r\n{\r\nstruct macio_dev * macio_dev = to_macio_device(dev);\r\nstruct macio_driver * drv = to_macio_driver(dev->driver);\r\nif (dev->driver && drv->shutdown)\r\ndrv->shutdown(macio_dev);\r\n}\r\nstatic int macio_device_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct macio_dev * macio_dev = to_macio_device(dev);\r\nstruct macio_driver * drv = to_macio_driver(dev->driver);\r\nif (dev->driver && drv->suspend)\r\nreturn drv->suspend(macio_dev, state);\r\nreturn 0;\r\n}\r\nstatic int macio_device_resume(struct device * dev)\r\n{\r\nstruct macio_dev * macio_dev = to_macio_device(dev);\r\nstruct macio_driver * drv = to_macio_driver(dev->driver);\r\nif (dev->driver && drv->resume)\r\nreturn drv->resume(macio_dev);\r\nreturn 0;\r\n}\r\nstatic int __init macio_bus_driver_init(void)\r\n{\r\nreturn bus_register(&macio_bus_type);\r\n}\r\nstatic void macio_release_dev(struct device *dev)\r\n{\r\nstruct macio_dev *mdev;\r\nmdev = to_macio_device(dev);\r\nkfree(mdev);\r\n}\r\nstatic int macio_resource_quirks(struct device_node *np, struct resource *res,\r\nint index)\r\n{\r\nif ((res->flags & IORESOURCE_MEM) == 0)\r\nreturn 0;\r\nif (index == 0 && !strcmp(np->name, "gc"))\r\nres->end = res->start + 0x1ffff;\r\nif (index >= 2 && !strcmp(np->name, "radio"))\r\nreturn 1;\r\n#ifndef CONFIG_PPC64\r\nif ((res->start & 0x0001f000) == 0x00008000)\r\nres->end = res->start + 0xff;\r\n#endif\r\nif (!strcmp(np->name, "escc"))\r\nreturn 1;\r\nif (index >= 3 && !(strcmp(np->name, "ch-a") &&\r\nstrcmp(np->name, "ch-b")))\r\nreturn 1;\r\nif (index > 0 && !strcmp(np->name, "media-bay"))\r\nreturn 1;\r\nif (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&\r\nstrcmp(np->type, "ide") && strcmp(np->type, "ata"))) {\r\nif (index == 0 && (res->end - res->start) > 0xfff)\r\nres->end = res->start + 0xfff;\r\nif (index == 1 && (res->end - res->start) > 0xff)\r\nres->end = res->start + 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic void macio_create_fixup_irq(struct macio_dev *dev, int index,\r\nunsigned int line)\r\n{\r\nunsigned int irq;\r\nirq = irq_create_mapping(NULL, line);\r\nif (irq != NO_IRQ) {\r\ndev->interrupt[index].start = irq;\r\ndev->interrupt[index].flags = IORESOURCE_IRQ;\r\ndev->interrupt[index].name = dev_name(&dev->ofdev.dev);\r\n}\r\nif (dev->n_interrupts <= index)\r\ndev->n_interrupts = index + 1;\r\n}\r\nstatic void macio_add_missing_resources(struct macio_dev *dev)\r\n{\r\nstruct device_node *np = dev->ofdev.dev.of_node;\r\nunsigned int irq_base;\r\nif (dev->bus->chip->type != macio_gatwick)\r\nreturn;\r\nirq_base = 64;\r\nif (strcmp(np->name, "ch-a") == 0) {\r\nmacio_create_fixup_irq(dev, 0, 15 + irq_base);\r\nmacio_create_fixup_irq(dev, 1, 4 + irq_base);\r\nmacio_create_fixup_irq(dev, 2, 5 + irq_base);\r\nprintk(KERN_INFO "macio: fixed SCC irqs on gatwick\n");\r\n}\r\nif (strcmp(np->name, "media-bay") == 0) {\r\nmacio_create_fixup_irq(dev, 0, 29 + irq_base);\r\nprintk(KERN_INFO "macio: fixed media-bay irq on gatwick\n");\r\n}\r\nif (dev->media_bay != NULL && strcmp(np->name, "floppy") == 0) {\r\nmacio_create_fixup_irq(dev, 0, 19 + irq_base);\r\nmacio_create_fixup_irq(dev, 1, 1 + irq_base);\r\nprintk(KERN_INFO "macio: fixed left floppy irqs\n");\r\n}\r\nif (dev->media_bay != NULL && strcasecmp(np->name, "ata4") == 0) {\r\nmacio_create_fixup_irq(dev, 0, 14 + irq_base);\r\nmacio_create_fixup_irq(dev, 0, 3 + irq_base);\r\nprintk(KERN_INFO "macio: fixed left ide irqs\n");\r\n}\r\n}\r\nstatic void macio_setup_interrupts(struct macio_dev *dev)\r\n{\r\nstruct device_node *np = dev->ofdev.dev.of_node;\r\nunsigned int irq;\r\nint i = 0, j = 0;\r\nfor (;;) {\r\nstruct resource *res;\r\nif (j >= MACIO_DEV_COUNT_IRQS)\r\nbreak;\r\nres = &dev->interrupt[j];\r\nirq = irq_of_parse_and_map(np, i++);\r\nif (irq == NO_IRQ)\r\nbreak;\r\nres->start = irq;\r\nres->flags = IORESOURCE_IRQ;\r\nres->name = dev_name(&dev->ofdev.dev);\r\nif (macio_resource_quirks(np, res, i - 1)) {\r\nmemset(res, 0, sizeof(struct resource));\r\ncontinue;\r\n} else\r\nj++;\r\n}\r\ndev->n_interrupts = j;\r\n}\r\nstatic void macio_setup_resources(struct macio_dev *dev,\r\nstruct resource *parent_res)\r\n{\r\nstruct device_node *np = dev->ofdev.dev.of_node;\r\nstruct resource r;\r\nint index;\r\nfor (index = 0; of_address_to_resource(np, index, &r) == 0; index++) {\r\nstruct resource *res;\r\nif (index >= MACIO_DEV_COUNT_RESOURCES)\r\nbreak;\r\nres = &dev->resource[index];\r\n*res = r;\r\nres->name = dev_name(&dev->ofdev.dev);\r\nif (macio_resource_quirks(np, res, index)) {\r\nmemset(res, 0, sizeof(struct resource));\r\ncontinue;\r\n}\r\nif (insert_resource(parent_res, res)) {\r\nprintk(KERN_WARNING "Can't request resource "\r\n"%d for MacIO device %s\n",\r\nindex, dev_name(&dev->ofdev.dev));\r\n}\r\n}\r\ndev->n_resources = index;\r\n}\r\nstatic struct macio_dev * macio_add_one_device(struct macio_chip *chip,\r\nstruct device *parent,\r\nstruct device_node *np,\r\nstruct macio_dev *in_bay,\r\nstruct resource *parent_res)\r\n{\r\nstruct macio_dev *dev;\r\nconst u32 *reg;\r\nif (np == NULL)\r\nreturn NULL;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\ndev->bus = &chip->lbus;\r\ndev->media_bay = in_bay;\r\ndev->ofdev.dev.of_node = np;\r\ndev->ofdev.archdata.dma_mask = 0xffffffffUL;\r\ndev->ofdev.dev.dma_mask = &dev->ofdev.archdata.dma_mask;\r\ndev->ofdev.dev.parent = parent;\r\ndev->ofdev.dev.bus = &macio_bus_type;\r\ndev->ofdev.dev.release = macio_release_dev;\r\ndev->ofdev.dev.dma_parms = &dev->dma_parms;\r\ndma_set_max_seg_size(&dev->ofdev.dev, 65536);\r\ndma_set_seg_boundary(&dev->ofdev.dev, 0xffffffff);\r\n#ifdef CONFIG_PCI\r\ndev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;\r\n#endif\r\n#ifdef DEBUG\r\nprintk("preparing mdev @%p, ofdev @%p, dev @%p, kobj @%p\n",\r\ndev, &dev->ofdev, &dev->ofdev.dev, &dev->ofdev.dev.kobj);\r\n#endif\r\nif (np == chip->of_node) {\r\ndev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",\r\nchip->lbus.index,\r\n#ifdef CONFIG_PCI\r\n(unsigned int)pci_resource_start(chip->lbus.pdev, 0),\r\n#else\r\n0,\r\n#endif\r\nMAX_NODE_NAME_SIZE, np->name);\r\n} else {\r\nreg = of_get_property(np, "reg", NULL);\r\ndev_set_name(&dev->ofdev.dev, "%1d.%08x:%.*s",\r\nchip->lbus.index,\r\nreg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);\r\n}\r\nmacio_setup_interrupts(dev);\r\nmacio_setup_resources(dev, parent_res);\r\nmacio_add_missing_resources(dev);\r\nif (of_device_register(&dev->ofdev) != 0) {\r\nprintk(KERN_DEBUG"macio: device registration error for %s!\n",\r\ndev_name(&dev->ofdev.dev));\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic int macio_skip_device(struct device_node *np)\r\n{\r\nif (strncmp(np->name, "battery", 7) == 0)\r\nreturn 1;\r\nif (strncmp(np->name, "escc-legacy", 11) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void macio_pci_add_devices(struct macio_chip *chip)\r\n{\r\nstruct device_node *np, *pnode;\r\nstruct macio_dev *rdev, *mdev, *mbdev = NULL, *sdev = NULL;\r\nstruct device *parent = NULL;\r\nstruct resource *root_res = &iomem_resource;\r\n#ifdef CONFIG_PCI\r\nif (chip->lbus.pdev) {\r\nparent = &chip->lbus.pdev->dev;\r\nroot_res = &chip->lbus.pdev->resource[0];\r\n}\r\n#endif\r\npnode = of_node_get(chip->of_node);\r\nif (pnode == NULL)\r\nreturn;\r\nrdev = macio_add_one_device(chip, parent, pnode, NULL, root_res);\r\nif (rdev == NULL)\r\nreturn;\r\nroot_res = &rdev->resource[0];\r\nfor (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {\r\nif (macio_skip_device(np))\r\ncontinue;\r\nof_node_get(np);\r\nmdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL,\r\nroot_res);\r\nif (mdev == NULL)\r\nof_node_put(np);\r\nelse if (strncmp(np->name, "media-bay", 9) == 0)\r\nmbdev = mdev;\r\nelse if (strncmp(np->name, "escc", 4) == 0)\r\nsdev = mdev;\r\n}\r\nif (mbdev) {\r\npnode = mbdev->ofdev.dev.of_node;\r\nfor (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {\r\nif (macio_skip_device(np))\r\ncontinue;\r\nof_node_get(np);\r\nif (macio_add_one_device(chip, &mbdev->ofdev.dev, np,\r\nmbdev, root_res) == NULL)\r\nof_node_put(np);\r\n}\r\n}\r\nif (sdev) {\r\npnode = sdev->ofdev.dev.of_node;\r\nfor (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {\r\nif (macio_skip_device(np))\r\ncontinue;\r\nof_node_get(np);\r\nif (macio_add_one_device(chip, &sdev->ofdev.dev, np,\r\nNULL, root_res) == NULL)\r\nof_node_put(np);\r\n}\r\n}\r\n}\r\nint macio_register_driver(struct macio_driver *drv)\r\n{\r\ndrv->driver.bus = &macio_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid macio_unregister_driver(struct macio_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic void maciom_release(struct device *gendev, void *res)\r\n{\r\nstruct macio_dev *dev = to_macio_device(gendev);\r\nstruct macio_devres *dr = res;\r\nint i, max;\r\nmax = min(dev->n_resources, 32);\r\nfor (i = 0; i < max; i++) {\r\nif (dr->res_mask & (1 << i))\r\nmacio_release_resource(dev, i);\r\n}\r\n}\r\nint macio_enable_devres(struct macio_dev *dev)\r\n{\r\nstruct macio_devres *dr;\r\ndr = devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);\r\nif (!dr) {\r\ndr = devres_alloc(maciom_release, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\n}\r\nreturn devres_get(&dev->ofdev.dev, dr, NULL, NULL) != NULL;\r\n}\r\nstatic struct macio_devres * find_macio_dr(struct macio_dev *dev)\r\n{\r\nreturn devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);\r\n}\r\nint macio_request_resource(struct macio_dev *dev, int resource_no,\r\nconst char *name)\r\n{\r\nstruct macio_devres *dr = find_macio_dr(dev);\r\nif (macio_resource_len(dev, resource_no) == 0)\r\nreturn 0;\r\nif (!request_mem_region(macio_resource_start(dev, resource_no),\r\nmacio_resource_len(dev, resource_no),\r\nname))\r\ngoto err_out;\r\nif (dr && resource_no < 32)\r\ndr->res_mask |= 1 << resource_no;\r\nreturn 0;\r\nerr_out:\r\nprintk (KERN_WARNING "MacIO: Unable to reserve resource #%d:%lx@%lx"\r\n" for device %s\n",\r\nresource_no,\r\nmacio_resource_len(dev, resource_no),\r\nmacio_resource_start(dev, resource_no),\r\ndev_name(&dev->ofdev.dev));\r\nreturn -EBUSY;\r\n}\r\nvoid macio_release_resource(struct macio_dev *dev, int resource_no)\r\n{\r\nstruct macio_devres *dr = find_macio_dr(dev);\r\nif (macio_resource_len(dev, resource_no) == 0)\r\nreturn;\r\nrelease_mem_region(macio_resource_start(dev, resource_no),\r\nmacio_resource_len(dev, resource_no));\r\nif (dr && resource_no < 32)\r\ndr->res_mask &= ~(1 << resource_no);\r\n}\r\nint macio_request_resources(struct macio_dev *dev, const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->n_resources; i++)\r\nif (macio_request_resource(dev, i, name))\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nwhile(--i >= 0)\r\nmacio_release_resource(dev, i);\r\nreturn -EBUSY;\r\n}\r\nvoid macio_release_resources(struct macio_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->n_resources; i++)\r\nmacio_release_resource(dev, i);\r\n}\r\nstatic int macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct device_node* np;\r\nstruct macio_chip* chip;\r\nif (ent->vendor != PCI_VENDOR_ID_APPLE)\r\nreturn -ENODEV;\r\nnp = pci_device_to_OF_node(pdev);\r\nif (np == NULL)\r\nreturn -ENODEV;\r\nof_node_get(np);\r\nchip = macio_find(np, macio_unknown);\r\nof_node_put(np);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (chip->lbus.pdev == NULL) {\r\nchip->lbus.pdev = pdev;\r\nchip->lbus.chip = chip;\r\npci_set_drvdata(pdev, &chip->lbus);\r\npci_set_master(pdev);\r\n}\r\nprintk(KERN_INFO "MacIO PCI driver attached to %s chipset\n",\r\nchip->name);\r\nif (chip->type == macio_gatwick || chip->type == macio_ohareII)\r\nif (macio_chips[0].lbus.pdev == NULL) {\r\nmacio_on_hold = chip;\r\nreturn 0;\r\n}\r\nmacio_pci_add_devices(chip);\r\nif (macio_on_hold && macio_chips[0].lbus.pdev != NULL) {\r\nmacio_pci_add_devices(macio_on_hold);\r\nmacio_on_hold = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void macio_pci_remove(struct pci_dev* pdev)\r\n{\r\npanic("removing of macio-asic not supported !\n");\r\n}\r\nstatic int __init macio_module_init (void)\r\n{\r\n#ifdef CONFIG_PCI\r\nint rc;\r\nrc = pci_register_driver(&macio_pci_driver);\r\nif (rc)\r\nreturn rc;\r\n#endif\r\nreturn 0;\r\n}
