static int tpk_printk(const unsigned char *buf, int count)\r\n{\r\nstatic char tmp[TPK_STR_SIZE + 4];\r\nint i = tpk_curr;\r\nif (buf == NULL) {\r\nif (tpk_curr > 0) {\r\ntmp[tpk_curr + 0] = '\n';\r\ntmp[tpk_curr + 1] = '\0';\r\nprintk(KERN_INFO "%s%s", tpk_tag, tmp);\r\ntpk_curr = 0;\r\n}\r\nreturn i;\r\n}\r\nfor (i = 0; i < count; i++) {\r\ntmp[tpk_curr] = buf[i];\r\nif (tpk_curr < TPK_STR_SIZE) {\r\nswitch (buf[i]) {\r\ncase '\r':\r\ntmp[tpk_curr + 0] = '\n';\r\ntmp[tpk_curr + 1] = '\0';\r\nprintk(KERN_INFO "%s%s", tpk_tag, tmp);\r\ntpk_curr = 0;\r\nif ((i + 1) < count && buf[i + 1] == '\n')\r\ni++;\r\nbreak;\r\ncase '\n':\r\ntmp[tpk_curr + 1] = '\0';\r\nprintk(KERN_INFO "%s%s", tpk_tag, tmp);\r\ntpk_curr = 0;\r\nbreak;\r\ndefault:\r\ntpk_curr++;\r\n}\r\n} else {\r\ntmp[tpk_curr + 1] = '\\';\r\ntmp[tpk_curr + 2] = '\n';\r\ntmp[tpk_curr + 3] = '\0';\r\nprintk(KERN_INFO "%s%s", tpk_tag, tmp);\r\ntpk_curr = 0;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int tpk_open(struct tty_struct *tty, struct file *filp)\r\n{\r\ntty->driver_data = &tpk_port;\r\nreturn tty_port_open(&tpk_port.port, tty, filp);\r\n}\r\nstatic void tpk_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct ttyprintk_port *tpkp = tty->driver_data;\r\nmutex_lock(&tpkp->port_write_mutex);\r\ntpk_printk(NULL, 0);\r\nmutex_unlock(&tpkp->port_write_mutex);\r\ntty_port_close(&tpkp->port, tty, filp);\r\n}\r\nstatic int tpk_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct ttyprintk_port *tpkp = tty->driver_data;\r\nint ret;\r\nmutex_lock(&tpkp->port_write_mutex);\r\nret = tpk_printk(buf, count);\r\nmutex_unlock(&tpkp->port_write_mutex);\r\nreturn ret;\r\n}\r\nstatic int tpk_write_room(struct tty_struct *tty)\r\n{\r\nreturn TPK_MAX_ROOM;\r\n}\r\nstatic int tpk_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ttyprintk_port *tpkp = tty->driver_data;\r\nif (!tpkp)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase TIOCCONS:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ttyprintk_init(void)\r\n{\r\nint ret = -ENOMEM;\r\nmutex_init(&tpk_port.port_write_mutex);\r\nttyprintk_driver = tty_alloc_driver(1,\r\nTTY_DRIVER_RESET_TERMIOS |\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_UNNUMBERED_NODE);\r\nif (IS_ERR(ttyprintk_driver))\r\nreturn PTR_ERR(ttyprintk_driver);\r\ntty_port_init(&tpk_port.port);\r\ntpk_port.port.ops = &null_ops;\r\nttyprintk_driver->driver_name = "ttyprintk";\r\nttyprintk_driver->name = "ttyprintk";\r\nttyprintk_driver->major = TTYAUX_MAJOR;\r\nttyprintk_driver->minor_start = 3;\r\nttyprintk_driver->type = TTY_DRIVER_TYPE_CONSOLE;\r\nttyprintk_driver->init_termios = tty_std_termios;\r\nttyprintk_driver->init_termios.c_oflag = OPOST | OCRNL | ONOCR | ONLRET;\r\ntty_set_operations(ttyprintk_driver, &ttyprintk_ops);\r\ntty_port_link_device(&tpk_port.port, ttyprintk_driver, 0);\r\nret = tty_register_driver(ttyprintk_driver);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Couldn't register ttyprintk driver\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nput_tty_driver(ttyprintk_driver);\r\ntty_port_destroy(&tpk_port.port);\r\nreturn ret;\r\n}\r\nstatic void __exit ttyprintk_exit(void)\r\n{\r\ntty_unregister_driver(ttyprintk_driver);\r\nput_tty_driver(ttyprintk_driver);\r\ntty_port_destroy(&tpk_port.port);\r\n}
