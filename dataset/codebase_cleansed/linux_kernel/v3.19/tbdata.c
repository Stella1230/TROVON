void\r\nacpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,\r\nacpi_physical_address address,\r\nu8 flags, struct acpi_table_header *table)\r\n{\r\nACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));\r\ntable_desc->address = address;\r\ntable_desc->length = table->length;\r\ntable_desc->flags = flags;\r\nACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);\r\n}\r\nacpi_status\r\nacpi_tb_acquire_table(struct acpi_table_desc *table_desc,\r\nstruct acpi_table_header **table_ptr,\r\nu32 *table_length, u8 *table_flags)\r\n{\r\nstruct acpi_table_header *table = NULL;\r\nswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\r\ntable =\r\nacpi_os_map_memory(table_desc->address, table_desc->length);\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\r\ncase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\r\ntable =\r\nACPI_CAST_PTR(struct acpi_table_header,\r\ntable_desc->address);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!table) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\n*table_ptr = table;\r\n*table_length = table_desc->length;\r\n*table_flags = table_desc->flags;\r\nreturn (AE_OK);\r\n}\r\nvoid\r\nacpi_tb_release_table(struct acpi_table_header *table,\r\nu32 table_length, u8 table_flags)\r\n{\r\nswitch (table_flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\r\nacpi_os_unmap_memory(table, table_length);\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\r\ncase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nacpi_status\r\nacpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,\r\nacpi_physical_address address, u8 flags)\r\n{\r\nstruct acpi_table_header *table_header;\r\nswitch (flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\r\ntable_header =\r\nacpi_os_map_memory(address,\r\nsizeof(struct acpi_table_header));\r\nif (!table_header) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nacpi_tb_init_table_descriptor(table_desc, address, flags,\r\ntable_header);\r\nacpi_os_unmap_memory(table_header,\r\nsizeof(struct acpi_table_header));\r\nreturn (AE_OK);\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\r\ncase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\r\ntable_header = ACPI_CAST_PTR(struct acpi_table_header, address);\r\nif (!table_header) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nacpi_tb_init_table_descriptor(table_desc, address, flags,\r\ntable_header);\r\nreturn (AE_OK);\r\ndefault:\r\nbreak;\r\n}\r\nreturn (AE_NO_MEMORY);\r\n}\r\nvoid acpi_tb_release_temp_table(struct acpi_table_desc *table_desc)\r\n{\r\nacpi_tb_invalidate_table(table_desc);\r\n}\r\nacpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(tb_validate_table);\r\nif (!table_desc->pointer) {\r\nstatus = acpi_tb_acquire_table(table_desc, &table_desc->pointer,\r\n&table_desc->length,\r\n&table_desc->flags);\r\nif (!table_desc->pointer) {\r\nstatus = AE_NO_MEMORY;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)\r\n{\r\nACPI_FUNCTION_TRACE(tb_invalidate_table);\r\nif (!table_desc->pointer) {\r\nreturn_VOID;\r\n}\r\nacpi_tb_release_table(table_desc->pointer, table_desc->length,\r\ntable_desc->flags);\r\ntable_desc->pointer = NULL;\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_tb_validate_temp_table(struct acpi_table_desc *table_desc)\r\n{\r\nif (!table_desc->pointer && !acpi_gbl_verify_table_checksum) {\r\ntable_desc->length = sizeof(struct acpi_table_header);\r\n}\r\nreturn (acpi_tb_validate_table(table_desc));\r\n}\r\nacpi_status\r\nacpi_tb_verify_temp_table(struct acpi_table_desc * table_desc, char *signature)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(tb_verify_temp_table);\r\nstatus = acpi_tb_validate_temp_table(table_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (signature && !ACPI_COMPARE_NAME(&table_desc->signature, signature)) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Invalid signature 0x%X for ACPI table, expected [%s]",\r\ntable_desc->signature.integer, signature));\r\nstatus = AE_BAD_SIGNATURE;\r\ngoto invalidate_and_exit;\r\n}\r\nif (acpi_gbl_verify_table_checksum) {\r\nstatus =\r\nacpi_tb_verify_checksum(table_desc->pointer,\r\ntable_desc->length);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,\r\n"%4.4s " ACPI_PRINTF_UINT\r\n" Attempted table install failed",\r\nacpi_ut_valid_acpi_name(table_desc->\r\nsignature.\r\nascii) ?\r\ntable_desc->signature.ascii : "????",\r\nACPI_FORMAT_TO_UINT(table_desc->\r\naddress)));\r\ngoto invalidate_and_exit;\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\ninvalidate_and_exit:\r\nacpi_tb_invalidate_table(table_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_resize_root_table_list(void)\r\n{\r\nstruct acpi_table_desc *tables;\r\nu32 table_count;\r\nACPI_FUNCTION_TRACE(tb_resize_root_table_list);\r\nif (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {\r\nACPI_ERROR((AE_INFO,\r\n"Resize of Root Table Array is not allowed"));\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\ntable_count = acpi_gbl_root_table_list.max_table_count;\r\n} else {\r\ntable_count = acpi_gbl_root_table_list.current_table_count;\r\n}\r\ntables = ACPI_ALLOCATE_ZEROED(((acpi_size) table_count +\r\nACPI_ROOT_TABLE_SIZE_INCREMENT) *\r\nsizeof(struct acpi_table_desc));\r\nif (!tables) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate new root table array"));\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (acpi_gbl_root_table_list.tables) {\r\nACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,\r\n(acpi_size) table_count *\r\nsizeof(struct acpi_table_desc));\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\n}\r\nacpi_gbl_root_table_list.tables = tables;\r\nacpi_gbl_root_table_list.max_table_count =\r\ntable_count + ACPI_ROOT_TABLE_SIZE_INCREMENT;\r\nacpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_tb_get_next_root_index(u32 *table_index)\r\n{\r\nacpi_status status;\r\nif (acpi_gbl_root_table_list.current_table_count >=\r\nacpi_gbl_root_table_list.max_table_count) {\r\nstatus = acpi_tb_resize_root_table_list();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n*table_index = acpi_gbl_root_table_list.current_table_count;\r\nacpi_gbl_root_table_list.current_table_count++;\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_tb_terminate(void)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_TRACE(tb_terminate);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nacpi_tb_uninstall_table(&acpi_gbl_root_table_list.tables[i]);\r\n}\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\nacpi_gbl_root_table_list.tables = NULL;\r\nacpi_gbl_root_table_list.flags = 0;\r\nacpi_gbl_root_table_list.current_table_count = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)\r\n{\r\nacpi_owner_id owner_id;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nowner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nstatus = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);\r\nacpi_ns_delete_namespace_by_owner(owner_id);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_allocate_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_allocate_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nstatus =\r\nacpi_ut_allocate_owner_id(&\r\n(acpi_gbl_root_table_list.\r\ntables[table_index].owner_id));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_release_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_release_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nacpi_ut_release_owner_id(&\r\n(acpi_gbl_root_table_list.\r\ntables[table_index].owner_id));\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_get_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\n*owner_id =\r\nacpi_gbl_root_table_list.tables[table_index].owner_id;\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nu8 acpi_tb_is_table_loaded(u32 table_index)\r\n{\r\nu8 is_loaded = FALSE;\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nis_loaded = (u8)\r\n(acpi_gbl_root_table_list.tables[table_index].flags &\r\nACPI_TABLE_IS_LOADED);\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn (is_loaded);\r\n}\r\nvoid acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)\r\n{\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nif (is_loaded) {\r\nacpi_gbl_root_table_list.tables[table_index].flags |=\r\nACPI_TABLE_IS_LOADED;\r\n} else {\r\nacpi_gbl_root_table_list.tables[table_index].flags &=\r\n~ACPI_TABLE_IS_LOADED;\r\n}\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n}
