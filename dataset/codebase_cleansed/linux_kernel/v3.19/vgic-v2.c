static struct vgic_lr vgic_v2_get_lr(const struct kvm_vcpu *vcpu, int lr)\r\n{\r\nstruct vgic_lr lr_desc;\r\nu32 val = vcpu->arch.vgic_cpu.vgic_v2.vgic_lr[lr];\r\nlr_desc.irq = val & GICH_LR_VIRTUALID;\r\nif (lr_desc.irq <= 15)\r\nlr_desc.source = (val >> GICH_LR_PHYSID_CPUID_SHIFT) & 0x7;\r\nelse\r\nlr_desc.source = 0;\r\nlr_desc.state = 0;\r\nif (val & GICH_LR_PENDING_BIT)\r\nlr_desc.state |= LR_STATE_PENDING;\r\nif (val & GICH_LR_ACTIVE_BIT)\r\nlr_desc.state |= LR_STATE_ACTIVE;\r\nif (val & GICH_LR_EOI)\r\nlr_desc.state |= LR_EOI_INT;\r\nreturn lr_desc;\r\n}\r\nstatic void vgic_v2_set_lr(struct kvm_vcpu *vcpu, int lr,\r\nstruct vgic_lr lr_desc)\r\n{\r\nu32 lr_val = (lr_desc.source << GICH_LR_PHYSID_CPUID_SHIFT) | lr_desc.irq;\r\nif (lr_desc.state & LR_STATE_PENDING)\r\nlr_val |= GICH_LR_PENDING_BIT;\r\nif (lr_desc.state & LR_STATE_ACTIVE)\r\nlr_val |= GICH_LR_ACTIVE_BIT;\r\nif (lr_desc.state & LR_EOI_INT)\r\nlr_val |= GICH_LR_EOI;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_lr[lr] = lr_val;\r\n}\r\nstatic void vgic_v2_sync_lr_elrsr(struct kvm_vcpu *vcpu, int lr,\r\nstruct vgic_lr lr_desc)\r\n{\r\nif (!(lr_desc.state & LR_STATE_MASK))\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_elrsr |= (1ULL << lr);\r\n}\r\nstatic u64 vgic_v2_get_elrsr(const struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.vgic_cpu.vgic_v2.vgic_elrsr;\r\n}\r\nstatic u64 vgic_v2_get_eisr(const struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.vgic_cpu.vgic_v2.vgic_eisr;\r\n}\r\nstatic u32 vgic_v2_get_interrupt_status(const struct kvm_vcpu *vcpu)\r\n{\r\nu32 misr = vcpu->arch.vgic_cpu.vgic_v2.vgic_misr;\r\nu32 ret = 0;\r\nif (misr & GICH_MISR_EOI)\r\nret |= INT_STATUS_EOI;\r\nif (misr & GICH_MISR_U)\r\nret |= INT_STATUS_UNDERFLOW;\r\nreturn ret;\r\n}\r\nstatic void vgic_v2_enable_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_hcr |= GICH_HCR_UIE;\r\n}\r\nstatic void vgic_v2_disable_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_hcr &= ~GICH_HCR_UIE;\r\n}\r\nstatic void vgic_v2_get_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nu32 vmcr = vcpu->arch.vgic_cpu.vgic_v2.vgic_vmcr;\r\nvmcrp->ctlr = (vmcr & GICH_VMCR_CTRL_MASK) >> GICH_VMCR_CTRL_SHIFT;\r\nvmcrp->abpr = (vmcr & GICH_VMCR_ALIAS_BINPOINT_MASK) >> GICH_VMCR_ALIAS_BINPOINT_SHIFT;\r\nvmcrp->bpr = (vmcr & GICH_VMCR_BINPOINT_MASK) >> GICH_VMCR_BINPOINT_SHIFT;\r\nvmcrp->pmr = (vmcr & GICH_VMCR_PRIMASK_MASK) >> GICH_VMCR_PRIMASK_SHIFT;\r\n}\r\nstatic void vgic_v2_set_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nu32 vmcr;\r\nvmcr = (vmcrp->ctlr << GICH_VMCR_CTRL_SHIFT) & GICH_VMCR_CTRL_MASK;\r\nvmcr |= (vmcrp->abpr << GICH_VMCR_ALIAS_BINPOINT_SHIFT) & GICH_VMCR_ALIAS_BINPOINT_MASK;\r\nvmcr |= (vmcrp->bpr << GICH_VMCR_BINPOINT_SHIFT) & GICH_VMCR_BINPOINT_MASK;\r\nvmcr |= (vmcrp->pmr << GICH_VMCR_PRIMASK_SHIFT) & GICH_VMCR_PRIMASK_MASK;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_vmcr = vmcr;\r\n}\r\nstatic void vgic_v2_enable(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_vmcr = 0;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_hcr = GICH_HCR_EN;\r\n}\r\nint vgic_v2_probe(struct device_node *vgic_node,\r\nconst struct vgic_ops **ops,\r\nconst struct vgic_params **params)\r\n{\r\nint ret;\r\nstruct resource vctrl_res;\r\nstruct resource vcpu_res;\r\nstruct vgic_params *vgic = &vgic_v2_params;\r\nvgic->maint_irq = irq_of_parse_and_map(vgic_node, 0);\r\nif (!vgic->maint_irq) {\r\nkvm_err("error getting vgic maintenance irq from DT\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nret = of_address_to_resource(vgic_node, 2, &vctrl_res);\r\nif (ret) {\r\nkvm_err("Cannot obtain GICH resource\n");\r\ngoto out;\r\n}\r\nvgic->vctrl_base = of_iomap(vgic_node, 2);\r\nif (!vgic->vctrl_base) {\r\nkvm_err("Cannot ioremap GICH\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nvgic->nr_lr = readl_relaxed(vgic->vctrl_base + GICH_VTR);\r\nvgic->nr_lr = (vgic->nr_lr & 0x3f) + 1;\r\nret = create_hyp_io_mappings(vgic->vctrl_base,\r\nvgic->vctrl_base + resource_size(&vctrl_res),\r\nvctrl_res.start);\r\nif (ret) {\r\nkvm_err("Cannot map VCTRL into hyp\n");\r\ngoto out_unmap;\r\n}\r\nif (of_address_to_resource(vgic_node, 3, &vcpu_res)) {\r\nkvm_err("Cannot obtain GICV resource\n");\r\nret = -ENXIO;\r\ngoto out_unmap;\r\n}\r\nif (!PAGE_ALIGNED(vcpu_res.start)) {\r\nkvm_err("GICV physical address 0x%llx not page aligned\n",\r\n(unsigned long long)vcpu_res.start);\r\nret = -ENXIO;\r\ngoto out_unmap;\r\n}\r\nif (!PAGE_ALIGNED(resource_size(&vcpu_res))) {\r\nkvm_err("GICV size 0x%llx not a multiple of page size 0x%lx\n",\r\n(unsigned long long)resource_size(&vcpu_res),\r\nPAGE_SIZE);\r\nret = -ENXIO;\r\ngoto out_unmap;\r\n}\r\nvgic->vcpu_base = vcpu_res.start;\r\nkvm_info("%s@%llx IRQ%d\n", vgic_node->name,\r\nvctrl_res.start, vgic->maint_irq);\r\nvgic->type = VGIC_V2;\r\n*ops = &vgic_v2_ops;\r\n*params = vgic;\r\ngoto out;\r\nout_unmap:\r\niounmap(vgic->vctrl_base);\r\nout:\r\nof_node_put(vgic_node);\r\nreturn ret;\r\n}
