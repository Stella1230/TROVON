static void rt2x00pci_free_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nkfree(rt2x00dev->rf);\r\nrt2x00dev->rf = NULL;\r\nkfree(rt2x00dev->eeprom);\r\nrt2x00dev->eeprom = NULL;\r\nif (rt2x00dev->csr.base) {\r\niounmap(rt2x00dev->csr.base);\r\nrt2x00dev->csr.base = NULL;\r\n}\r\n}\r\nstatic int rt2x00pci_alloc_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(rt2x00dev->dev);\r\nrt2x00dev->csr.base = pci_ioremap_bar(pci_dev, 0);\r\nif (!rt2x00dev->csr.base)\r\ngoto exit;\r\nrt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\r\nif (!rt2x00dev->eeprom)\r\ngoto exit;\r\nrt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\r\nif (!rt2x00dev->rf)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nrt2x00_probe_err("Failed to allocate registers\n");\r\nrt2x00pci_free_reg(rt2x00dev);\r\nreturn -ENOMEM;\r\n}\r\nint rt2x00pci_probe(struct pci_dev *pci_dev, const struct rt2x00_ops *ops)\r\n{\r\nstruct ieee80211_hw *hw;\r\nstruct rt2x00_dev *rt2x00dev;\r\nint retval;\r\nu16 chip;\r\nretval = pci_enable_device(pci_dev);\r\nif (retval) {\r\nrt2x00_probe_err("Enable device failed\n");\r\nreturn retval;\r\n}\r\nretval = pci_request_regions(pci_dev, pci_name(pci_dev));\r\nif (retval) {\r\nrt2x00_probe_err("PCI request regions failed\n");\r\ngoto exit_disable_device;\r\n}\r\npci_set_master(pci_dev);\r\nif (pci_set_mwi(pci_dev))\r\nrt2x00_probe_err("MWI not available\n");\r\nif (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {\r\nrt2x00_probe_err("PCI DMA not supported\n");\r\nretval = -EIO;\r\ngoto exit_release_regions;\r\n}\r\nhw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\r\nif (!hw) {\r\nrt2x00_probe_err("Failed to allocate hardware\n");\r\nretval = -ENOMEM;\r\ngoto exit_release_regions;\r\n}\r\npci_set_drvdata(pci_dev, hw);\r\nrt2x00dev = hw->priv;\r\nrt2x00dev->dev = &pci_dev->dev;\r\nrt2x00dev->ops = ops;\r\nrt2x00dev->hw = hw;\r\nrt2x00dev->irq = pci_dev->irq;\r\nrt2x00dev->name = ops->name;\r\nif (pci_is_pcie(pci_dev))\r\nrt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);\r\nelse\r\nrt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCI);\r\nretval = rt2x00pci_alloc_reg(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_device;\r\npci_read_config_word(pci_dev, PCI_DEVICE_ID, &chip);\r\nrt2x00dev->chip.rt = chip;\r\nretval = rt2x00lib_probe_dev(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_reg;\r\nreturn 0;\r\nexit_free_reg:\r\nrt2x00pci_free_reg(rt2x00dev);\r\nexit_free_device:\r\nieee80211_free_hw(hw);\r\nexit_release_regions:\r\npci_release_regions(pci_dev);\r\nexit_disable_device:\r\npci_disable_device(pci_dev);\r\nreturn retval;\r\n}\r\nvoid rt2x00pci_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nrt2x00lib_remove_dev(rt2x00dev);\r\nrt2x00pci_free_reg(rt2x00dev);\r\nieee80211_free_hw(hw);\r\npci_disable_device(pci_dev);\r\npci_release_regions(pci_dev);\r\n}\r\nint rt2x00pci_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nint retval;\r\nretval = rt2x00lib_suspend(rt2x00dev, state);\r\nif (retval)\r\nreturn retval;\r\npci_save_state(pci_dev);\r\npci_disable_device(pci_dev);\r\nreturn pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));\r\n}\r\nint rt2x00pci_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nif (pci_set_power_state(pci_dev, PCI_D0) ||\r\npci_enable_device(pci_dev)) {\r\nrt2x00_err(rt2x00dev, "Failed to resume device\n");\r\nreturn -EIO;\r\n}\r\npci_restore_state(pci_dev);\r\nreturn rt2x00lib_resume(rt2x00dev);\r\n}
