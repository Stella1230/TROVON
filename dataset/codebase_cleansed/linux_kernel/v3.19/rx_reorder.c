static inline int seq_less(u16 sq1, u16 sq2)\r\n{\r\nreturn ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);\r\n}\r\nstatic inline u16 seq_inc(u16 sq)\r\n{\r\nreturn (sq + 1) & SEQ_MASK;\r\n}\r\nstatic inline u16 seq_sub(u16 sq1, u16 sq2)\r\n{\r\nreturn (sq1 - sq2) & SEQ_MASK;\r\n}\r\nstatic inline int reorder_index(struct wil_tid_ampdu_rx *r, u16 seq)\r\n{\r\nreturn seq_sub(seq, r->ssn) % r->buf_size;\r\n}\r\nstatic void wil_release_reorder_frame(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r,\r\nint index)\r\n{\r\nstruct net_device *ndev = wil_to_ndev(wil);\r\nstruct sk_buff *skb = r->reorder_buf[index];\r\nif (!skb)\r\ngoto no_frame;\r\nr->stored_mpdu_num--;\r\nr->reorder_buf[index] = NULL;\r\nwil_netif_rx_any(skb, ndev);\r\nno_frame:\r\nr->head_seq_num = seq_inc(r->head_seq_num);\r\n}\r\nstatic void wil_release_reorder_frames(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r,\r\nu16 hseq)\r\n{\r\nint index;\r\nwhile (seq_less(r->head_seq_num, hseq) && r->stored_mpdu_num) {\r\nindex = reorder_index(r, r->head_seq_num);\r\nwil_release_reorder_frame(wil, r, index);\r\n}\r\nr->head_seq_num = hseq;\r\n}\r\nstatic void wil_reorder_release(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r)\r\n{\r\nint index = reorder_index(r, r->head_seq_num);\r\nwhile (r->reorder_buf[index]) {\r\nwil_release_reorder_frame(wil, r, index);\r\nindex = reorder_index(r, r->head_seq_num);\r\n}\r\n}\r\nvoid wil_rx_reorder(struct wil6210_priv *wil, struct sk_buff *skb)\r\n{\r\nstruct net_device *ndev = wil_to_ndev(wil);\r\nstruct vring_rx_desc *d = wil_skb_rxdesc(skb);\r\nint tid = wil_rxdesc_tid(d);\r\nint cid = wil_rxdesc_cid(d);\r\nint mid = wil_rxdesc_mid(d);\r\nu16 seq = wil_rxdesc_seq(d);\r\nstruct wil_sta_info *sta = &wil->sta[cid];\r\nstruct wil_tid_ampdu_rx *r;\r\nu16 hseq;\r\nint index;\r\nunsigned long flags;\r\nwil_dbg_txrx(wil, "MID %d CID %d TID %d Seq 0x%03x\n",\r\nmid, cid, tid, seq);\r\nspin_lock_irqsave(&sta->tid_rx_lock, flags);\r\nr = sta->tid_rx[tid];\r\nif (!r) {\r\nspin_unlock_irqrestore(&sta->tid_rx_lock, flags);\r\nwil_netif_rx_any(skb, ndev);\r\nreturn;\r\n}\r\nhseq = r->head_seq_num;\r\nif (r->first_time) {\r\nr->first_time = false;\r\nif (seq != r->head_seq_num) {\r\nwil_err(wil, "Error: 1-st frame with wrong sequence"\r\n" %d, should be %d. Fixing...\n", seq,\r\nr->head_seq_num);\r\nr->head_seq_num = seq;\r\nr->ssn = seq;\r\n}\r\n}\r\nif (seq_less(seq, r->head_seq_num)) {\r\nr->ssn_last_drop = seq;\r\ndev_kfree_skb(skb);\r\ngoto out;\r\n}\r\nif (!seq_less(seq, r->head_seq_num + r->buf_size)) {\r\nhseq = seq_inc(seq_sub(seq, r->buf_size));\r\nwil_release_reorder_frames(wil, r, hseq);\r\n}\r\nindex = reorder_index(r, seq);\r\nif (r->reorder_buf[index]) {\r\ndev_kfree_skb(skb);\r\ngoto out;\r\n}\r\nif (seq == r->head_seq_num && r->stored_mpdu_num == 0) {\r\nr->head_seq_num = seq_inc(r->head_seq_num);\r\nwil_netif_rx_any(skb, ndev);\r\ngoto out;\r\n}\r\nr->reorder_buf[index] = skb;\r\nr->reorder_time[index] = jiffies;\r\nr->stored_mpdu_num++;\r\nwil_reorder_release(wil, r);\r\nout:\r\nspin_unlock_irqrestore(&sta->tid_rx_lock, flags);\r\n}\r\nstruct wil_tid_ampdu_rx *wil_tid_ampdu_rx_alloc(struct wil6210_priv *wil,\r\nint size, u16 ssn)\r\n{\r\nstruct wil_tid_ampdu_rx *r = kzalloc(sizeof(*r), GFP_KERNEL);\r\nif (!r)\r\nreturn NULL;\r\nr->reorder_buf =\r\nkcalloc(size, sizeof(struct sk_buff *), GFP_KERNEL);\r\nr->reorder_time =\r\nkcalloc(size, sizeof(unsigned long), GFP_KERNEL);\r\nif (!r->reorder_buf || !r->reorder_time) {\r\nkfree(r->reorder_buf);\r\nkfree(r->reorder_time);\r\nkfree(r);\r\nreturn NULL;\r\n}\r\nr->ssn = ssn;\r\nr->head_seq_num = ssn;\r\nr->buf_size = size;\r\nr->stored_mpdu_num = 0;\r\nr->first_time = true;\r\nreturn r;\r\n}\r\nvoid wil_tid_ampdu_rx_free(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r)\r\n{\r\nif (!r)\r\nreturn;\r\nwil_release_reorder_frames(wil, r, r->head_seq_num + r->buf_size);\r\nkfree(r->reorder_buf);\r\nkfree(r->reorder_time);\r\nkfree(r);\r\n}
