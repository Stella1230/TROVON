static struct vgic_lr vgic_v3_get_lr(const struct kvm_vcpu *vcpu, int lr)\r\n{\r\nstruct vgic_lr lr_desc;\r\nu64 val = vcpu->arch.vgic_cpu.vgic_v3.vgic_lr[LR_INDEX(lr)];\r\nlr_desc.irq = val & GICH_LR_VIRTUALID;\r\nif (lr_desc.irq <= 15)\r\nlr_desc.source = (val >> GICH_LR_PHYSID_CPUID_SHIFT) & 0x7;\r\nelse\r\nlr_desc.source = 0;\r\nlr_desc.state = 0;\r\nif (val & ICH_LR_PENDING_BIT)\r\nlr_desc.state |= LR_STATE_PENDING;\r\nif (val & ICH_LR_ACTIVE_BIT)\r\nlr_desc.state |= LR_STATE_ACTIVE;\r\nif (val & ICH_LR_EOI)\r\nlr_desc.state |= LR_EOI_INT;\r\nreturn lr_desc;\r\n}\r\nstatic void vgic_v3_set_lr(struct kvm_vcpu *vcpu, int lr,\r\nstruct vgic_lr lr_desc)\r\n{\r\nu64 lr_val = (((u32)lr_desc.source << GICH_LR_PHYSID_CPUID_SHIFT) |\r\nlr_desc.irq);\r\nif (lr_desc.state & LR_STATE_PENDING)\r\nlr_val |= ICH_LR_PENDING_BIT;\r\nif (lr_desc.state & LR_STATE_ACTIVE)\r\nlr_val |= ICH_LR_ACTIVE_BIT;\r\nif (lr_desc.state & LR_EOI_INT)\r\nlr_val |= ICH_LR_EOI;\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_lr[LR_INDEX(lr)] = lr_val;\r\n}\r\nstatic void vgic_v3_sync_lr_elrsr(struct kvm_vcpu *vcpu, int lr,\r\nstruct vgic_lr lr_desc)\r\n{\r\nif (!(lr_desc.state & LR_STATE_MASK))\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_elrsr |= (1U << lr);\r\n}\r\nstatic u64 vgic_v3_get_elrsr(const struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.vgic_cpu.vgic_v3.vgic_elrsr;\r\n}\r\nstatic u64 vgic_v3_get_eisr(const struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.vgic_cpu.vgic_v3.vgic_eisr;\r\n}\r\nstatic u32 vgic_v3_get_interrupt_status(const struct kvm_vcpu *vcpu)\r\n{\r\nu32 misr = vcpu->arch.vgic_cpu.vgic_v3.vgic_misr;\r\nu32 ret = 0;\r\nif (misr & ICH_MISR_EOI)\r\nret |= INT_STATUS_EOI;\r\nif (misr & ICH_MISR_U)\r\nret |= INT_STATUS_UNDERFLOW;\r\nreturn ret;\r\n}\r\nstatic void vgic_v3_get_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nu32 vmcr = vcpu->arch.vgic_cpu.vgic_v3.vgic_vmcr;\r\nvmcrp->ctlr = (vmcr & ICH_VMCR_CTLR_MASK) >> ICH_VMCR_CTLR_SHIFT;\r\nvmcrp->abpr = (vmcr & ICH_VMCR_BPR1_MASK) >> ICH_VMCR_BPR1_SHIFT;\r\nvmcrp->bpr = (vmcr & ICH_VMCR_BPR0_MASK) >> ICH_VMCR_BPR0_SHIFT;\r\nvmcrp->pmr = (vmcr & ICH_VMCR_PMR_MASK) >> ICH_VMCR_PMR_SHIFT;\r\n}\r\nstatic void vgic_v3_enable_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_hcr |= ICH_HCR_UIE;\r\n}\r\nstatic void vgic_v3_disable_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_hcr &= ~ICH_HCR_UIE;\r\n}\r\nstatic void vgic_v3_set_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nu32 vmcr;\r\nvmcr = (vmcrp->ctlr << ICH_VMCR_CTLR_SHIFT) & ICH_VMCR_CTLR_MASK;\r\nvmcr |= (vmcrp->abpr << ICH_VMCR_BPR1_SHIFT) & ICH_VMCR_BPR1_MASK;\r\nvmcr |= (vmcrp->bpr << ICH_VMCR_BPR0_SHIFT) & ICH_VMCR_BPR0_MASK;\r\nvmcr |= (vmcrp->pmr << ICH_VMCR_PMR_SHIFT) & ICH_VMCR_PMR_MASK;\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_vmcr = vmcr;\r\n}\r\nstatic void vgic_v3_enable(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_vmcr = 0;\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_hcr = ICH_HCR_EN;\r\n}\r\nint vgic_v3_probe(struct device_node *vgic_node,\r\nconst struct vgic_ops **ops,\r\nconst struct vgic_params **params)\r\n{\r\nint ret = 0;\r\nu32 gicv_idx;\r\nstruct resource vcpu_res;\r\nstruct vgic_params *vgic = &vgic_v3_params;\r\nvgic->maint_irq = irq_of_parse_and_map(vgic_node, 0);\r\nif (!vgic->maint_irq) {\r\nkvm_err("error getting vgic maintenance irq from DT\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nich_vtr_el2 = kvm_call_hyp(__vgic_v3_get_ich_vtr_el2);\r\nvgic->nr_lr = (ich_vtr_el2 & 0xf) + 1;\r\nif (of_property_read_u32(vgic_node, "#redistributor-regions", &gicv_idx))\r\ngicv_idx = 1;\r\ngicv_idx += 3;\r\nif (of_address_to_resource(vgic_node, gicv_idx, &vcpu_res)) {\r\nkvm_err("Cannot obtain GICV region\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!PAGE_ALIGNED(vcpu_res.start)) {\r\nkvm_err("GICV physical address 0x%llx not page aligned\n",\r\n(unsigned long long)vcpu_res.start);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!PAGE_ALIGNED(resource_size(&vcpu_res))) {\r\nkvm_err("GICV size 0x%llx not a multiple of page size 0x%lx\n",\r\n(unsigned long long)resource_size(&vcpu_res),\r\nPAGE_SIZE);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nvgic->vcpu_base = vcpu_res.start;\r\nvgic->vctrl_base = NULL;\r\nvgic->type = VGIC_V3;\r\nkvm_info("%s@%llx IRQ%d\n", vgic_node->name,\r\nvcpu_res.start, vgic->maint_irq);\r\n*ops = &vgic_v3_ops;\r\n*params = vgic;\r\nout:\r\nof_node_put(vgic_node);\r\nreturn ret;\r\n}
