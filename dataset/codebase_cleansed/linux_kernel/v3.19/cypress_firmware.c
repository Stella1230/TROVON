static int usb_cypress_writemem(struct usb_device *udev, u16 addr, u8 *data,\r\nu8 len)\r\n{\r\nreturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\r\n}\r\nstatic int cypress_get_hexline(const struct firmware *fw,\r\nstruct hexline *hx, int *pos)\r\n{\r\nu8 *b = (u8 *) &fw->data[*pos];\r\nint data_offs = 4;\r\nif (*pos >= fw->size)\r\nreturn 0;\r\nmemset(hx, 0, sizeof(struct hexline));\r\nhx->len = b[0];\r\nif ((*pos + hx->len + 4) >= fw->size)\r\nreturn -EINVAL;\r\nhx->addr = b[1] | (b[2] << 8);\r\nhx->type = b[3];\r\nif (hx->type == 0x04) {\r\nhx->addr |= (b[4] << 24) | (b[5] << 16);\r\n}\r\nmemcpy(hx->data, &b[data_offs], hx->len);\r\nhx->chk = b[hx->len + data_offs];\r\n*pos += hx->len + 5;\r\nreturn *pos;\r\n}\r\nint cypress_load_firmware(struct usb_device *udev,\r\nconst struct firmware *fw, int type)\r\n{\r\nstruct hexline *hx;\r\nint ret, pos = 0;\r\nhx = kmalloc(sizeof(struct hexline), GFP_KERNEL);\r\nif (!hx) {\r\ndev_err(&udev->dev, "%s: kmalloc() failed\n", KBUILD_MODNAME);\r\nreturn -ENOMEM;\r\n}\r\nhx->data[0] = 1;\r\nret = usb_cypress_writemem(udev, cypress[type].cs_reg, hx->data, 1);\r\nif (ret != 1) {\r\ndev_err(&udev->dev, "%s: CPU stop failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nret = -EIO;\r\ngoto err_kfree;\r\n}\r\nfor (;;) {\r\nret = cypress_get_hexline(fw, hx, &pos);\r\nif (ret < 0)\r\ngoto err_kfree;\r\nelse if (ret == 0)\r\nbreak;\r\nret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\r\nif (ret < 0) {\r\ngoto err_kfree;\r\n} else if (ret != hx->len) {\r\ndev_err(&udev->dev,\r\n"%s: error while transferring firmware (transferred size=%d, block size=%d)\n",\r\nKBUILD_MODNAME, ret, hx->len);\r\nret = -EIO;\r\ngoto err_kfree;\r\n}\r\n}\r\nhx->data[0] = 0;\r\nret = usb_cypress_writemem(udev, cypress[type].cs_reg, hx->data, 1);\r\nif (ret != 1) {\r\ndev_err(&udev->dev, "%s: CPU start failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nret = -EIO;\r\ngoto err_kfree;\r\n}\r\nret = 0;\r\nerr_kfree:\r\nkfree(hx);\r\nreturn ret;\r\n}
