static int ak09911_set_mode(struct i2c_client *client, u8 mode)\r\n{\r\nint ret;\r\nswitch (mode) {\r\ncase AK09911_MODE_SNG_MEASURE:\r\ncase AK09911_MODE_SELF_TEST:\r\ncase AK09911_MODE_FUSE_ACCESS:\r\ncase AK09911_MODE_POWERDOWN:\r\nret = i2c_smbus_write_byte_data(client,\r\nAK09911_REG_CNTL2, mode);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "set_mode error\n");\r\nreturn ret;\r\n}\r\nusleep_range(100, 500);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"%s: Unknown mode(%d).", __func__, mode);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ak09911_get_asa(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak09911_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = ak09911_set_mode(client, AK09911_MODE_FUSE_ACCESS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_i2c_block_data(client, AK09911_REG_ASAX,\r\n3, data->asa);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Not able to read asa data\n");\r\nreturn ret;\r\n}\r\nret = ak09911_set_mode(client, AK09911_MODE_POWERDOWN);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->raw_to_gauss[0] = AK09911_RAW_TO_GAUSS(data->asa[0]);\r\ndata->raw_to_gauss[1] = AK09911_RAW_TO_GAUSS(data->asa[1]);\r\ndata->raw_to_gauss[2] = AK09911_RAW_TO_GAUSS(data->asa[2]);\r\nreturn 0;\r\n}\r\nstatic int ak09911_verify_chip_id(struct i2c_client *client)\r\n{\r\nu8 wia_val[2];\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(client, AK09911_REG_WIA1,\r\n2, wia_val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error reading WIA\n");\r\nreturn ret;\r\n}\r\ndev_dbg(&client->dev, "WIA %02x %02x\n", wia_val[0], wia_val[1]);\r\nif (wia_val[0] != AK09911_WIA1_VALUE ||\r\nwia_val[1] != AK09911_WIA2_VALUE) {\r\ndev_err(&client->dev, "Device ak09911 not found\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wait_conversion_complete_polled(struct ak09911_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu8 read_status;\r\nu32 timeout_ms = AK09911_MAX_CONVERSION_TIMEOUT_MS;\r\nint ret;\r\nwhile (timeout_ms) {\r\nmsleep_interruptible(AK09911_CONVERSION_DONE_POLL_TIME_MS);\r\nret = i2c_smbus_read_byte_data(client, AK09911_REG_ST1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST1\n");\r\nreturn ret;\r\n}\r\nread_status = ret & 0x01;\r\nif (read_status)\r\nbreak;\r\ntimeout_ms -= AK09911_CONVERSION_DONE_POLL_TIME_MS;\r\n}\r\nif (!timeout_ms) {\r\ndev_err(&client->dev, "Conversion timeout happened\n");\r\nreturn -EIO;\r\n}\r\nreturn read_status;\r\n}\r\nstatic int ak09911_read_axis(struct iio_dev *indio_dev, int index, int *val)\r\n{\r\nstruct ak09911_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = ak09911_set_mode(client, AK09911_MODE_SNG_MEASURE);\r\nif (ret < 0)\r\ngoto fn_exit;\r\nret = wait_conversion_complete_polled(data);\r\nif (ret < 0)\r\ngoto fn_exit;\r\nret = i2c_smbus_read_word_data(client, ak09911_index_to_reg[index]);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Read axis data fails\n");\r\ngoto fn_exit;\r\n}\r\nmutex_unlock(&data->lock);\r\n*val = sign_extend32(clamp_t(s16, ret, -8192, 8191), 13);\r\nreturn IIO_VAL_INT;\r\nfn_exit:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int ak09911_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ak09911_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn ak09911_read_axis(indio_dev, chan->address, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = data->raw_to_gauss[chan->address];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ak09911_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ak09911_data *data;\r\nconst char *name;\r\nint ret;\r\nret = ak09911_verify_chip_id(client);\r\nif (ret) {\r\ndev_err(&client->dev, "AK00911 not detected\n");\r\nreturn -ENODEV;\r\n}\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\nret = ak09911_get_asa(client);\r\nif (ret)\r\nreturn ret;\r\nif (id)\r\nname = id->name;\r\nelse if (ACPI_HANDLE(&client->dev))\r\nname = dev_name(&client->dev);\r\nelse\r\nreturn -ENODEV;\r\ndev_dbg(&client->dev, "Asahi compass chip %s\n", name);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = ak09911_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ak09911_channels);\r\nindio_dev->info = &ak09911_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = name;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
