static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\r\n{\r\nif (a->proto != b->proto)\r\nreturn 0;\r\nif (a->vid != b->vid)\r\nreturn 0;\r\nswitch (a->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn a->u.ip4 == b->u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip,\r\n__u16 vid)\r\n{\r\nreturn jhash_2words((__force u32)ip, vid, mdb->secret) & (mdb->max - 1);\r\n}\r\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\r\nconst struct in6_addr *ip,\r\n__u16 vid)\r\n{\r\nreturn jhash_2words(ipv6_addr_hash(ip), vid,\r\nmdb->secret) & (mdb->max - 1);\r\n}\r\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\r\nstruct br_ip *ip)\r\n{\r\nswitch (ip->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn __br_ip4_hash(mdb, ip->u.ip4, ip->vid);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn __br_ip6_hash(mdb, &ip->u.ip6, ip->vid);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\r\nstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nhlist_for_each_entry_rcu(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\r\nif (br_ip_equal(&mp->addr, dst))\r\nreturn mp;\r\n}\r\nreturn NULL;\r\n}\r\nstruct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge_mdb_htable *mdb,\r\nstruct br_ip *dst)\r\n{\r\nif (!mdb)\r\nreturn NULL;\r\nreturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\r\n}\r\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\r\nstruct net_bridge_mdb_htable *mdb, __be32 dst, __u16 vid)\r\n{\r\nstruct br_ip br_dst;\r\nbr_dst.u.ip4 = dst;\r\nbr_dst.proto = htons(ETH_P_IP);\r\nbr_dst.vid = vid;\r\nreturn br_mdb_ip_get(mdb, &br_dst);\r\n}\r\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\r\nstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_dst;\r\nbr_dst.u.ip6 = *dst;\r\nbr_dst.proto = htons(ETH_P_IPV6);\r\nbr_dst.vid = vid;\r\nreturn br_mdb_ip_get(mdb, &br_dst);\r\n}\r\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\r\nstruct sk_buff *skb, u16 vid)\r\n{\r\nstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\r\nstruct br_ip ip;\r\nif (br->multicast_disabled)\r\nreturn NULL;\r\nif (BR_INPUT_SKB_CB(skb)->igmp)\r\nreturn NULL;\r\nip.proto = skb->protocol;\r\nip.vid = vid;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nip.u.ip4 = ip_hdr(skb)->daddr;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nip.u.ip6 = ipv6_hdr(skb)->daddr;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn br_mdb_ip_get(mdb, &ip);\r\n}\r\nstatic void br_mdb_free(struct rcu_head *head)\r\n{\r\nstruct net_bridge_mdb_htable *mdb =\r\ncontainer_of(head, struct net_bridge_mdb_htable, rcu);\r\nstruct net_bridge_mdb_htable *old = mdb->old;\r\nmdb->old = NULL;\r\nkfree(old->mhash);\r\nkfree(old);\r\n}\r\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\r\nstruct net_bridge_mdb_htable *old,\r\nint elasticity)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nint maxlen;\r\nint len;\r\nint i;\r\nfor (i = 0; i < old->max; i++)\r\nhlist_for_each_entry(mp, &old->mhash[i], hlist[old->ver])\r\nhlist_add_head(&mp->hlist[new->ver],\r\n&new->mhash[br_ip_hash(new, &mp->addr)]);\r\nif (!elasticity)\r\nreturn 0;\r\nmaxlen = 0;\r\nfor (i = 0; i < new->max; i++) {\r\nlen = 0;\r\nhlist_for_each_entry(mp, &new->mhash[i], hlist[new->ver])\r\nlen++;\r\nif (len > maxlen)\r\nmaxlen = len;\r\n}\r\nreturn maxlen > elasticity ? -EINVAL : 0;\r\n}\r\nvoid br_multicast_free_pg(struct rcu_head *head)\r\n{\r\nstruct net_bridge_port_group *p =\r\ncontainer_of(head, struct net_bridge_port_group, rcu);\r\nkfree(p);\r\n}\r\nstatic void br_multicast_free_group(struct rcu_head *head)\r\n{\r\nstruct net_bridge_mdb_entry *mp =\r\ncontainer_of(head, struct net_bridge_mdb_entry, rcu);\r\nkfree(mp);\r\n}\r\nstatic void br_multicast_group_expired(unsigned long data)\r\n{\r\nstruct net_bridge_mdb_entry *mp = (void *)data;\r\nstruct net_bridge *br = mp->br;\r\nstruct net_bridge_mdb_htable *mdb;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || timer_pending(&mp->timer))\r\ngoto out;\r\nmp->mglist = false;\r\nif (mp->ports)\r\ngoto out;\r\nmdb = mlock_dereference(br->mdb, br);\r\nhlist_del_rcu(&mp->hlist[mdb->ver]);\r\nmdb->size--;\r\ncall_rcu_bh(&mp->rcu, br_multicast_free_group);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_multicast_del_pg(struct net_bridge *br,\r\nstruct net_bridge_port_group *pg)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, &pg->addr);\r\nif (WARN_ON(!mp))\r\nreturn;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p != pg)\r\ncontinue;\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\nreturn;\r\n}\r\nWARN_ON(1);\r\n}\r\nstatic void br_multicast_port_group_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port_group *pg = (void *)data;\r\nstruct net_bridge *br = pg->port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\r\nhlist_unhashed(&pg->mglist) || pg->state & MDB_PERMANENT)\r\ngoto out;\r\nbr_multicast_del_pg(br, pg);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\r\nint elasticity)\r\n{\r\nstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\r\nstruct net_bridge_mdb_htable *mdb;\r\nint err;\r\nmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\r\nif (!mdb)\r\nreturn -ENOMEM;\r\nmdb->max = max;\r\nmdb->old = old;\r\nmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\r\nif (!mdb->mhash) {\r\nkfree(mdb);\r\nreturn -ENOMEM;\r\n}\r\nmdb->size = old ? old->size : 0;\r\nmdb->ver = old ? old->ver ^ 1 : 0;\r\nif (!old || elasticity)\r\nget_random_bytes(&mdb->secret, sizeof(mdb->secret));\r\nelse\r\nmdb->secret = old->secret;\r\nif (!old)\r\ngoto out;\r\nerr = br_mdb_copy(mdb, old, elasticity);\r\nif (err) {\r\nkfree(mdb->mhash);\r\nkfree(mdb);\r\nreturn err;\r\n}\r\nbr_mdb_rehash_seq++;\r\ncall_rcu_bh(&mdb->rcu, br_mdb_free);\r\nout:\r\nrcu_assign_pointer(*mdbp, mdb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\r\n__be32 group)\r\n{\r\nstruct sk_buff *skb;\r\nstruct igmphdr *ih;\r\nstruct ethhdr *eth;\r\nstruct iphdr *iph;\r\nskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\r\nsizeof(*ih) + 4);\r\nif (!skb)\r\ngoto out;\r\nskb->protocol = htons(ETH_P_IP);\r\nskb_reset_mac_header(skb);\r\neth = eth_hdr(skb);\r\nether_addr_copy(eth->h_source, br->dev->dev_addr);\r\neth->h_dest[0] = 1;\r\neth->h_dest[1] = 0;\r\neth->h_dest[2] = 0x5e;\r\neth->h_dest[3] = 0;\r\neth->h_dest[4] = 0;\r\neth->h_dest[5] = 1;\r\neth->h_proto = htons(ETH_P_IP);\r\nskb_put(skb, sizeof(*eth));\r\nskb_set_network_header(skb, skb->len);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = 6;\r\niph->tos = 0xc0;\r\niph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\r\niph->id = 0;\r\niph->frag_off = htons(IP_DF);\r\niph->ttl = 1;\r\niph->protocol = IPPROTO_IGMP;\r\niph->saddr = br->multicast_query_use_ifaddr ?\r\ninet_select_addr(br->dev, 0, RT_SCOPE_LINK) : 0;\r\niph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\r\n((u8 *)&iph[1])[0] = IPOPT_RA;\r\n((u8 *)&iph[1])[1] = 4;\r\n((u8 *)&iph[1])[2] = 0;\r\n((u8 *)&iph[1])[3] = 0;\r\nip_send_check(iph);\r\nskb_put(skb, 24);\r\nskb_set_transport_header(skb, skb->len);\r\nih = igmp_hdr(skb);\r\nih->type = IGMP_HOST_MEMBERSHIP_QUERY;\r\nih->code = (group ? br->multicast_last_member_interval :\r\nbr->multicast_query_response_interval) /\r\n(HZ / IGMP_TIMER_SCALE);\r\nih->group = group;\r\nih->csum = 0;\r\nih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\r\nskb_put(skb, sizeof(*ih));\r\n__skb_pull(skb, sizeof(*eth));\r\nout:\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\r\nconst struct in6_addr *group)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ipv6hdr *ip6h;\r\nstruct mld_msg *mldq;\r\nstruct ethhdr *eth;\r\nu8 *hopopt;\r\nunsigned long interval;\r\nskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\r\n8 + sizeof(*mldq));\r\nif (!skb)\r\ngoto out;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb_reset_mac_header(skb);\r\neth = eth_hdr(skb);\r\nether_addr_copy(eth->h_source, br->dev->dev_addr);\r\neth->h_proto = htons(ETH_P_IPV6);\r\nskb_put(skb, sizeof(*eth));\r\nskb_set_network_header(skb, skb->len);\r\nip6h = ipv6_hdr(skb);\r\n*(__force __be32 *)ip6h = htonl(0x60000000);\r\nip6h->payload_len = htons(8 + sizeof(*mldq));\r\nip6h->nexthdr = IPPROTO_HOPOPTS;\r\nip6h->hop_limit = 1;\r\nipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\r\nif (ipv6_dev_get_saddr(dev_net(br->dev), br->dev, &ip6h->daddr, 0,\r\n&ip6h->saddr)) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\r\nhopopt = (u8 *)(ip6h + 1);\r\nhopopt[0] = IPPROTO_ICMPV6;\r\nhopopt[1] = 0;\r\nhopopt[2] = IPV6_TLV_ROUTERALERT;\r\nhopopt[3] = 2;\r\nhopopt[4] = 0;\r\nhopopt[5] = 0;\r\nhopopt[6] = IPV6_TLV_PAD1;\r\nhopopt[7] = IPV6_TLV_PAD1;\r\nskb_put(skb, sizeof(*ip6h) + 8);\r\nskb_set_transport_header(skb, skb->len);\r\nmldq = (struct mld_msg *) icmp6_hdr(skb);\r\ninterval = ipv6_addr_any(group) ?\r\nbr->multicast_query_response_interval :\r\nbr->multicast_last_member_interval;\r\nmldq->mld_type = ICMPV6_MGM_QUERY;\r\nmldq->mld_code = 0;\r\nmldq->mld_cksum = 0;\r\nmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\r\nmldq->mld_reserved = 0;\r\nmldq->mld_mca = *group;\r\nmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\nsizeof(*mldq), IPPROTO_ICMPV6,\r\ncsum_partial(mldq,\r\nsizeof(*mldq), 0));\r\nskb_put(skb, sizeof(*mldq));\r\n__skb_pull(skb, sizeof(*eth));\r\nout:\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\r\nstruct br_ip *addr)\r\n{\r\nswitch (addr->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn br_ip4_multicast_alloc_query(br, addr->u.ip4);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn br_ip6_multicast_alloc_query(br, &addr->u.ip6);\r\n#endif\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\r\nstruct net_bridge *br, struct net_bridge_port *port,\r\nstruct br_ip *group, int hash)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nunsigned int count = 0;\r\nunsigned int max;\r\nint elasticity;\r\nint err;\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nhlist_for_each_entry(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\r\ncount++;\r\nif (unlikely(br_ip_equal(group, &mp->addr)))\r\nreturn mp;\r\n}\r\nelasticity = 0;\r\nmax = mdb->max;\r\nif (unlikely(count > br->hash_elasticity && count)) {\r\nif (net_ratelimit())\r\nbr_info(br, "Multicast hash table "\r\n"chain limit reached: %s\n",\r\nport ? port->dev->name : br->dev->name);\r\nelasticity = br->hash_elasticity;\r\n}\r\nif (mdb->size >= max) {\r\nmax *= 2;\r\nif (unlikely(max > br->hash_max)) {\r\nbr_warn(br, "Multicast hash table maximum of %d "\r\n"reached, disabling snooping: %s\n",\r\nbr->hash_max,\r\nport ? port->dev->name : br->dev->name);\r\nerr = -E2BIG;\r\ndisable:\r\nbr->multicast_disabled = 1;\r\ngoto err;\r\n}\r\n}\r\nif (max > mdb->max || elasticity) {\r\nif (mdb->old) {\r\nif (net_ratelimit())\r\nbr_info(br, "Multicast hash table "\r\n"on fire: %s\n",\r\nport ? port->dev->name : br->dev->name);\r\nerr = -EEXIST;\r\ngoto err;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, max, elasticity);\r\nif (err) {\r\nbr_warn(br, "Cannot rehash multicast "\r\n"hash table, disabling snooping: %s, %d, %d\n",\r\nport ? port->dev->name : br->dev->name,\r\nmdb->size, err);\r\ngoto disable;\r\n}\r\nerr = -EAGAIN;\r\ngoto err;\r\n}\r\nreturn NULL;\r\nerr:\r\nmp = ERR_PTR(err);\r\nreturn mp;\r\n}\r\nstruct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,\r\nstruct net_bridge_port *port, struct br_ip *group)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nint hash;\r\nint err;\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nif (!mdb) {\r\nerr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\ngoto rehash;\r\n}\r\nhash = br_ip_hash(mdb, group);\r\nmp = br_multicast_get_group(br, port, group, hash);\r\nswitch (PTR_ERR(mp)) {\r\ncase 0:\r\nbreak;\r\ncase -EAGAIN:\r\nrehash:\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nhash = br_ip_hash(mdb, group);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\r\nif (unlikely(!mp))\r\nreturn ERR_PTR(-ENOMEM);\r\nmp->br = br;\r\nmp->addr = *group;\r\nsetup_timer(&mp->timer, br_multicast_group_expired,\r\n(unsigned long)mp);\r\nhlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\r\nmdb->size++;\r\nout:\r\nreturn mp;\r\n}\r\nstruct net_bridge_port_group *br_multicast_new_port_group(\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group,\r\nstruct net_bridge_port_group __rcu *next,\r\nunsigned char state)\r\n{\r\nstruct net_bridge_port_group *p;\r\np = kzalloc(sizeof(*p), GFP_ATOMIC);\r\nif (unlikely(!p))\r\nreturn NULL;\r\np->addr = *group;\r\np->port = port;\r\np->state = state;\r\nrcu_assign_pointer(p->next, next);\r\nhlist_add_head(&p->mglist, &port->mglist);\r\nsetup_timer(&p->timer, br_multicast_port_group_expired,\r\n(unsigned long)p);\r\nreturn p;\r\n}\r\nstatic int br_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nunsigned long now = jiffies;\r\nint err;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\nmp = br_multicast_new_group(br, port, group);\r\nerr = PTR_ERR(mp);\r\nif (IS_ERR(mp))\r\ngoto err;\r\nif (!port) {\r\nmp->mglist = true;\r\nmod_timer(&mp->timer, now + br->multicast_membership_interval);\r\ngoto out;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p->port == port)\r\ngoto found;\r\nif ((unsigned long)p->port < (unsigned long)port)\r\nbreak;\r\n}\r\np = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY);\r\nif (unlikely(!p))\r\ngoto err;\r\nrcu_assign_pointer(*pp, p);\r\nbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\r\nfound:\r\nmod_timer(&p->timer, now + br->multicast_membership_interval);\r\nout:\r\nerr = 0;\r\nerr:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 group,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_group;\r\nif (ipv4_is_local_multicast(group))\r\nreturn 0;\r\nbr_group.u.ip4 = group;\r\nbr_group.proto = htons(ETH_P_IP);\r\nbr_group.vid = vid;\r\nreturn br_multicast_add_group(br, port, &br_group);\r\n}\r\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nconst struct in6_addr *group,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_group;\r\nif (ipv6_addr_is_ll_all_nodes(group))\r\nreturn 0;\r\nbr_group.u.ip6 = *group;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\nbr_group.vid = vid;\r\nreturn br_multicast_add_group(br, port, &br_group);\r\n}\r\nstatic void br_multicast_router_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (port->multicast_router != 1 ||\r\ntimer_pending(&port->multicast_router_timer) ||\r\nhlist_unhashed(&port->rlist))\r\ngoto out;\r\nhlist_del_init_rcu(&port->rlist);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_multicast_local_router_expired(unsigned long data)\r\n{\r\n}\r\nstatic void br_multicast_querier_expired(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\ngoto out;\r\nbr_multicast_start_querier(br, query);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_querier_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_querier_expired(br, &br->ip4_own_query);\r\n}\r\nstatic void br_ip6_multicast_querier_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_querier_expired(br, &br->ip6_own_query);\r\n}\r\nstatic void br_multicast_select_own_querier(struct net_bridge *br,\r\nstruct br_ip *ip,\r\nstruct sk_buff *skb)\r\n{\r\nif (ip->proto == htons(ETH_P_IP))\r\nbr->ip4_querier.addr.u.ip4 = ip_hdr(skb)->saddr;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nbr->ip6_querier.addr.u.ip6 = ipv6_hdr(skb)->saddr;\r\n#endif\r\n}\r\nstatic void __br_multicast_send_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *ip)\r\n{\r\nstruct sk_buff *skb;\r\nskb = br_multicast_alloc_query(br, ip);\r\nif (!skb)\r\nreturn;\r\nif (port) {\r\nskb->dev = port->dev;\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\r\nbr_dev_queue_push_xmit);\r\n} else {\r\nbr_multicast_select_own_querier(br, ip, skb);\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void br_multicast_send_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct bridge_mcast_own_query *own_query)\r\n{\r\nunsigned long time;\r\nstruct br_ip br_group;\r\nstruct bridge_mcast_other_query *other_query = NULL;\r\nif (!netif_running(br->dev) || br->multicast_disabled ||\r\n!br->multicast_querier)\r\nreturn;\r\nmemset(&br_group.u, 0, sizeof(br_group.u));\r\nif (port ? (own_query == &port->ip4_own_query) :\r\n(own_query == &br->ip4_own_query)) {\r\nother_query = &br->ip4_other_query;\r\nbr_group.proto = htons(ETH_P_IP);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nother_query = &br->ip6_other_query;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\n#endif\r\n}\r\nif (!other_query || timer_pending(&other_query->timer))\r\nreturn;\r\n__br_multicast_send_query(br, port, &br_group);\r\ntime = jiffies;\r\ntime += own_query->startup_sent < br->multicast_startup_query_count ?\r\nbr->multicast_startup_query_interval :\r\nbr->multicast_query_interval;\r\nmod_timer(&own_query->timer, time);\r\n}\r\nstatic void\r\nbr_multicast_port_query_expired(struct net_bridge_port *port,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (port->state == BR_STATE_DISABLED ||\r\nport->state == BR_STATE_BLOCKING)\r\ngoto out;\r\nif (query->startup_sent < br->multicast_startup_query_count)\r\nquery->startup_sent++;\r\nbr_multicast_send_query(port->br, port, query);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_port_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nbr_multicast_port_query_expired(port, &port->ip4_own_query);\r\n}\r\nstatic void br_ip6_multicast_port_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nbr_multicast_port_query_expired(port, &port->ip6_own_query);\r\n}\r\nvoid br_multicast_add_port(struct net_bridge_port *port)\r\n{\r\nport->multicast_router = 1;\r\nsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\r\n(unsigned long)port);\r\nsetup_timer(&port->ip4_own_query.timer,\r\nbr_ip4_multicast_port_query_expired, (unsigned long)port);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nsetup_timer(&port->ip6_own_query.timer,\r\nbr_ip6_multicast_port_query_expired, (unsigned long)port);\r\n#endif\r\n}\r\nvoid br_multicast_del_port(struct net_bridge_port *port)\r\n{\r\ndel_timer_sync(&port->multicast_router_timer);\r\n}\r\nstatic void br_multicast_enable(struct bridge_mcast_own_query *query)\r\n{\r\nquery->startup_sent = 0;\r\nif (try_to_del_timer_sync(&query->timer) >= 0 ||\r\ndel_timer(&query->timer))\r\nmod_timer(&query->timer, jiffies);\r\n}\r\nvoid br_multicast_enable_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (br->multicast_disabled || !netif_running(br->dev))\r\ngoto out;\r\nbr_multicast_enable(&port->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbr_multicast_enable(&port->ip6_own_query);\r\n#endif\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nvoid br_multicast_disable_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nstruct net_bridge_port_group *pg;\r\nstruct hlist_node *n;\r\nspin_lock(&br->multicast_lock);\r\nhlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\r\nbr_multicast_del_pg(br, pg);\r\nif (!hlist_unhashed(&port->rlist))\r\nhlist_del_init_rcu(&port->rlist);\r\ndel_timer(&port->multicast_router_timer);\r\ndel_timer(&port->ip4_own_query.timer);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ndel_timer(&port->ip6_own_query.timer);\r\n#endif\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct igmpv3_report *ih;\r\nstruct igmpv3_grec *grec;\r\nint i;\r\nint len;\r\nint num;\r\nint type;\r\nint err = 0;\r\n__be32 group;\r\nif (!pskb_may_pull(skb, sizeof(*ih)))\r\nreturn -EINVAL;\r\nih = igmpv3_report_hdr(skb);\r\nnum = ntohs(ih->ngrec);\r\nlen = sizeof(*ih);\r\nfor (i = 0; i < num; i++) {\r\nlen += sizeof(*grec);\r\nif (!pskb_may_pull(skb, len))\r\nreturn -EINVAL;\r\ngrec = (void *)(skb->data + len - sizeof(*grec));\r\ngroup = grec->grec_mca;\r\ntype = grec->grec_type;\r\nlen += ntohs(grec->grec_nsrcs) * 4;\r\nif (!pskb_may_pull(skb, len))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase IGMPV3_MODE_IS_INCLUDE:\r\ncase IGMPV3_MODE_IS_EXCLUDE:\r\ncase IGMPV3_CHANGE_TO_INCLUDE:\r\ncase IGMPV3_CHANGE_TO_EXCLUDE:\r\ncase IGMPV3_ALLOW_NEW_SOURCES:\r\ncase IGMPV3_BLOCK_OLD_SOURCES:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nerr = br_ip4_multicast_add_group(br, port, group, vid);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct icmp6hdr *icmp6h;\r\nstruct mld2_grec *grec;\r\nint i;\r\nint len;\r\nint num;\r\nint err = 0;\r\nif (!pskb_may_pull(skb, sizeof(*icmp6h)))\r\nreturn -EINVAL;\r\nicmp6h = icmp6_hdr(skb);\r\nnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\r\nlen = sizeof(*icmp6h);\r\nfor (i = 0; i < num; i++) {\r\n__be16 *nsrcs, _nsrcs;\r\nnsrcs = skb_header_pointer(skb,\r\nlen + offsetof(struct mld2_grec,\r\ngrec_nsrcs),\r\nsizeof(_nsrcs), &_nsrcs);\r\nif (!nsrcs)\r\nreturn -EINVAL;\r\nif (!pskb_may_pull(skb,\r\nlen + sizeof(*grec) +\r\nsizeof(struct in6_addr) * ntohs(*nsrcs)))\r\nreturn -EINVAL;\r\ngrec = (struct mld2_grec *)(skb->data + len);\r\nlen += sizeof(*grec) +\r\nsizeof(struct in6_addr) * ntohs(*nsrcs);\r\nswitch (grec->grec_type) {\r\ncase MLD2_MODE_IS_INCLUDE:\r\ncase MLD2_MODE_IS_EXCLUDE:\r\ncase MLD2_CHANGE_TO_INCLUDE:\r\ncase MLD2_CHANGE_TO_EXCLUDE:\r\ncase MLD2_ALLOW_NEW_SOURCES:\r\ncase MLD2_BLOCK_OLD_SOURCES:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nerr = br_ip6_multicast_add_group(br, port, &grec->grec_mca,\r\nvid);\r\nif (!err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic bool br_ip4_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 saddr)\r\n{\r\nif (!timer_pending(&br->ip4_own_query.timer) &&\r\n!timer_pending(&br->ip4_other_query.timer))\r\ngoto update;\r\nif (!br->ip4_querier.addr.u.ip4)\r\ngoto update;\r\nif (ntohl(saddr) <= ntohl(br->ip4_querier.addr.u.ip4))\r\ngoto update;\r\nreturn false;\r\nupdate:\r\nbr->ip4_querier.addr.u.ip4 = saddr;\r\nrcu_assign_pointer(br->ip4_querier.port, port);\r\nreturn true;\r\n}\r\nstatic bool br_ip6_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct in6_addr *saddr)\r\n{\r\nif (!timer_pending(&br->ip6_own_query.timer) &&\r\n!timer_pending(&br->ip6_other_query.timer))\r\ngoto update;\r\nif (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.u.ip6) <= 0)\r\ngoto update;\r\nreturn false;\r\nupdate:\r\nbr->ip6_querier.addr.u.ip6 = *saddr;\r\nrcu_assign_pointer(br->ip6_querier.port, port);\r\nreturn true;\r\n}\r\nstatic bool br_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *saddr)\r\n{\r\nswitch (saddr->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn br_ip4_multicast_select_querier(br, port, saddr->u.ip4);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn br_ip6_multicast_select_querier(br, port, &saddr->u.ip6);\r\n#endif\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nbr_multicast_update_query_timer(struct net_bridge *br,\r\nstruct bridge_mcast_other_query *query,\r\nunsigned long max_delay)\r\n{\r\nif (!timer_pending(&query->timer))\r\nquery->delay_time = jiffies + max_delay;\r\nmod_timer(&query->timer, jiffies + br->multicast_querier_interval);\r\n}\r\nstatic void br_multicast_add_router(struct net_bridge *br,\r\nstruct net_bridge_port *port)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct hlist_node *slot = NULL;\r\nhlist_for_each_entry(p, &br->router_list, rlist) {\r\nif ((unsigned long) port >= (unsigned long) p)\r\nbreak;\r\nslot = &p->rlist;\r\n}\r\nif (slot)\r\nhlist_add_behind_rcu(&port->rlist, slot);\r\nelse\r\nhlist_add_head_rcu(&port->rlist, &br->router_list);\r\n}\r\nstatic void br_multicast_mark_router(struct net_bridge *br,\r\nstruct net_bridge_port *port)\r\n{\r\nunsigned long now = jiffies;\r\nif (!port) {\r\nif (br->multicast_router == 1)\r\nmod_timer(&br->multicast_router_timer,\r\nnow + br->multicast_querier_interval);\r\nreturn;\r\n}\r\nif (port->multicast_router != 1)\r\nreturn;\r\nif (!hlist_unhashed(&port->rlist))\r\ngoto timer;\r\nbr_multicast_add_router(br, port);\r\ntimer:\r\nmod_timer(&port->multicast_router_timer,\r\nnow + br->multicast_querier_interval);\r\n}\r\nstatic void br_multicast_query_received(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct bridge_mcast_other_query *query,\r\nstruct br_ip *saddr,\r\nunsigned long max_delay)\r\n{\r\nif (!br_multicast_select_querier(br, port, saddr))\r\nreturn;\r\nbr_multicast_update_query_timer(br, query, max_delay);\r\nbr_multicast_mark_router(br, port);\r\n}\r\nstatic int br_ip4_multicast_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct igmphdr *ih = igmp_hdr(skb);\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct igmpv3_query *ih3;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip saddr;\r\nunsigned long max_delay;\r\nunsigned long now = jiffies;\r\n__be32 group;\r\nint err = 0;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\ngroup = ih->group;\r\nif (skb->len == sizeof(*ih)) {\r\nmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\r\nif (!max_delay) {\r\nmax_delay = 10 * HZ;\r\ngroup = 0;\r\n}\r\n} else {\r\nif (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nih3 = igmpv3_query_hdr(skb);\r\nif (ih3->nsrcs)\r\ngoto out;\r\nmax_delay = ih3->code ?\r\nIGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\r\n}\r\nif (!group && iph->daddr != htonl(INADDR_ALLHOSTS_GROUP)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!group) {\r\nsaddr.proto = htons(ETH_P_IP);\r\nsaddr.u.ip4 = iph->saddr;\r\nbr_multicast_query_received(br, port, &br->ip4_other_query,\r\n&saddr, max_delay);\r\ngoto out;\r\n}\r\nmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group, vid);\r\nif (!mp)\r\ngoto out;\r\nmax_delay *= br->multicast_last_member_count;\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0))\r\nmod_timer(&mp->timer, now + max_delay);\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)\r\nmod_timer(&p->timer, now + max_delay);\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_ip6_multicast_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct mld_msg *mld;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct mld2_query *mld2q;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip saddr;\r\nunsigned long max_delay;\r\nunsigned long now = jiffies;\r\nconst struct in6_addr *group = NULL;\r\nbool is_general_query;\r\nint err = 0;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\nif (!(ipv6_addr_type(&ip6h->saddr) & IPV6_ADDR_LINKLOCAL)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (skb->len == sizeof(*mld)) {\r\nif (!pskb_may_pull(skb, sizeof(*mld))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld = (struct mld_msg *) icmp6_hdr(skb);\r\nmax_delay = msecs_to_jiffies(ntohs(mld->mld_maxdelay));\r\nif (max_delay)\r\ngroup = &mld->mld_mca;\r\n} else {\r\nif (!pskb_may_pull(skb, sizeof(*mld2q))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld2q = (struct mld2_query *)icmp6_hdr(skb);\r\nif (!mld2q->mld2q_nsrcs)\r\ngroup = &mld2q->mld2q_mca;\r\nmax_delay = max(msecs_to_jiffies(mldv2_mrc(mld2q)), 1UL);\r\n}\r\nis_general_query = group && ipv6_addr_any(group);\r\nif (is_general_query && !ipv6_addr_is_ll_all_nodes(&ip6h->daddr)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (is_general_query) {\r\nsaddr.proto = htons(ETH_P_IPV6);\r\nsaddr.u.ip6 = ip6h->saddr;\r\nbr_multicast_query_received(br, port, &br->ip6_other_query,\r\n&saddr, max_delay);\r\ngoto out;\r\n} else if (!group) {\r\ngoto out;\r\n}\r\nmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group, vid);\r\nif (!mp)\r\ngoto out;\r\nmax_delay *= br->multicast_last_member_count;\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0))\r\nmod_timer(&mp->timer, now + max_delay);\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)\r\nmod_timer(&p->timer, now + max_delay);\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic void\r\nbr_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group,\r\nstruct bridge_mcast_other_query *other_query,\r\nstruct bridge_mcast_own_query *own_query)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nunsigned long now;\r\nunsigned long time;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED) ||\r\ntimer_pending(&other_query->timer))\r\ngoto out;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, group);\r\nif (!mp)\r\ngoto out;\r\nif (br->multicast_querier) {\r\n__br_multicast_send_query(br, port, &mp->addr);\r\ntime = jiffies + br->multicast_last_member_count *\r\nbr->multicast_last_member_interval;\r\nmod_timer(&own_query->timer, time);\r\nfor (p = mlock_dereference(mp->ports, br);\r\np != NULL;\r\np = mlock_dereference(p->next, br)) {\r\nif (p->port != port)\r\ncontinue;\r\nif (!hlist_unhashed(&p->mglist) &&\r\n(timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, time) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)) {\r\nmod_timer(&p->timer, time);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (port && (port->flags & BR_MULTICAST_FAST_LEAVE)) {\r\nstruct net_bridge_port_group __rcu **pp;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p->port != port)\r\ncontinue;\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nbr_mdb_notify(br->dev, port, group, RTM_DELMDB);\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\n}\r\ngoto out;\r\n}\r\nnow = jiffies;\r\ntime = now + br->multicast_last_member_count *\r\nbr->multicast_last_member_interval;\r\nif (!port) {\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, time) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0)) {\r\nmod_timer(&mp->timer, time);\r\n}\r\ngoto out;\r\n}\r\nfor (p = mlock_dereference(mp->ports, br);\r\np != NULL;\r\np = mlock_dereference(p->next, br)) {\r\nif (p->port != port)\r\ncontinue;\r\nif (!hlist_unhashed(&p->mglist) &&\r\n(timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, time) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)) {\r\nmod_timer(&p->timer, time);\r\n}\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 group,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_group;\r\nstruct bridge_mcast_own_query *own_query;\r\nif (ipv4_is_local_multicast(group))\r\nreturn;\r\nown_query = port ? &port->ip4_own_query : &br->ip4_own_query;\r\nbr_group.u.ip4 = group;\r\nbr_group.proto = htons(ETH_P_IP);\r\nbr_group.vid = vid;\r\nbr_multicast_leave_group(br, port, &br_group, &br->ip4_other_query,\r\nown_query);\r\n}\r\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nconst struct in6_addr *group,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_group;\r\nstruct bridge_mcast_own_query *own_query;\r\nif (ipv6_addr_is_ll_all_nodes(group))\r\nreturn;\r\nown_query = port ? &port->ip6_own_query : &br->ip6_own_query;\r\nbr_group.u.ip6 = *group;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\nbr_group.vid = vid;\r\nbr_multicast_leave_group(br, port, &br_group, &br->ip6_other_query,\r\nown_query);\r\n}\r\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct sk_buff *skb2 = skb;\r\nconst struct iphdr *iph;\r\nstruct igmphdr *ih;\r\nunsigned int len;\r\nunsigned int offset;\r\nint err;\r\nif (!pskb_may_pull(skb, sizeof(*iph)))\r\nreturn -EINVAL;\r\niph = ip_hdr(skb);\r\nif (iph->ihl < 5 || iph->version != 4)\r\nreturn -EINVAL;\r\nif (!pskb_may_pull(skb, ip_hdrlen(skb)))\r\nreturn -EINVAL;\r\niph = ip_hdr(skb);\r\nif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\r\nreturn -EINVAL;\r\nif (iph->protocol != IPPROTO_IGMP) {\r\nif (!ipv4_is_local_multicast(iph->daddr))\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nreturn 0;\r\n}\r\nlen = ntohs(iph->tot_len);\r\nif (skb->len < len || len < ip_hdrlen(skb))\r\nreturn -EINVAL;\r\nif (skb->len > len) {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn -ENOMEM;\r\nerr = pskb_trim_rcsum(skb2, len);\r\nif (err)\r\ngoto err_out;\r\n}\r\nlen -= ip_hdrlen(skb2);\r\noffset = skb_network_offset(skb2) + ip_hdrlen(skb2);\r\n__skb_pull(skb2, offset);\r\nskb_reset_transport_header(skb2);\r\nerr = -EINVAL;\r\nif (!pskb_may_pull(skb2, sizeof(*ih)))\r\ngoto out;\r\nswitch (skb2->ip_summed) {\r\ncase CHECKSUM_COMPLETE:\r\nif (!csum_fold(skb2->csum))\r\nbreak;\r\ncase CHECKSUM_NONE:\r\nskb2->csum = 0;\r\nif (skb_checksum_complete(skb2))\r\ngoto out;\r\n}\r\nerr = 0;\r\nBR_INPUT_SKB_CB(skb)->igmp = 1;\r\nih = igmp_hdr(skb2);\r\nswitch (ih->type) {\r\ncase IGMP_HOST_MEMBERSHIP_REPORT:\r\ncase IGMPV2_HOST_MEMBERSHIP_REPORT:\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nerr = br_ip4_multicast_add_group(br, port, ih->group, vid);\r\nbreak;\r\ncase IGMPV3_HOST_MEMBERSHIP_REPORT:\r\nerr = br_ip4_multicast_igmp3_report(br, port, skb2, vid);\r\nbreak;\r\ncase IGMP_HOST_MEMBERSHIP_QUERY:\r\nerr = br_ip4_multicast_query(br, port, skb2, vid);\r\nbreak;\r\ncase IGMP_HOST_LEAVE_MESSAGE:\r\nbr_ip4_multicast_leave_group(br, port, ih->group, vid);\r\nbreak;\r\n}\r\nout:\r\n__skb_push(skb2, offset);\r\nerr_out:\r\nif (skb2 != skb)\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct sk_buff *skb2;\r\nconst struct ipv6hdr *ip6h;\r\nu8 icmp6_type;\r\nu8 nexthdr;\r\n__be16 frag_off;\r\nunsigned int len;\r\nint offset;\r\nint err;\r\nif (!pskb_may_pull(skb, sizeof(*ip6h)))\r\nreturn -EINVAL;\r\nip6h = ipv6_hdr(skb);\r\nif (ip6h->version != 6)\r\nreturn 0;\r\nif (!ipv6_addr_is_ll_all_nodes(&ip6h->daddr))\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nif (ip6h->nexthdr != IPPROTO_HOPOPTS ||\r\nip6h->payload_len == 0)\r\nreturn 0;\r\nlen = ntohs(ip6h->payload_len) + sizeof(*ip6h);\r\nif (skb->len < len)\r\nreturn -EINVAL;\r\nnexthdr = ip6h->nexthdr;\r\noffset = ipv6_skip_exthdr(skb, sizeof(*ip6h), &nexthdr, &frag_off);\r\nif (offset < 0 || nexthdr != IPPROTO_ICMPV6)\r\nreturn 0;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn -ENOMEM;\r\nerr = -EINVAL;\r\nif (!pskb_may_pull(skb2, offset + sizeof(struct icmp6hdr)))\r\ngoto out;\r\nlen -= offset - skb_network_offset(skb2);\r\n__skb_pull(skb2, offset);\r\nskb_reset_transport_header(skb2);\r\nskb_postpull_rcsum(skb2, skb_network_header(skb2),\r\nskb_network_header_len(skb2));\r\nicmp6_type = icmp6_hdr(skb2)->icmp6_type;\r\nswitch (icmp6_type) {\r\ncase ICMPV6_MGM_QUERY:\r\ncase ICMPV6_MGM_REPORT:\r\ncase ICMPV6_MGM_REDUCTION:\r\ncase ICMPV6_MLD2_REPORT:\r\nbreak;\r\ndefault:\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (skb2->len > len) {\r\nerr = pskb_trim_rcsum(skb2, len);\r\nif (err)\r\ngoto out;\r\nerr = -EINVAL;\r\n}\r\nip6h = ipv6_hdr(skb2);\r\nswitch (skb2->ip_summed) {\r\ncase CHECKSUM_COMPLETE:\r\nif (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, skb2->len,\r\nIPPROTO_ICMPV6, skb2->csum))\r\nbreak;\r\ncase CHECKSUM_NONE:\r\nskb2->csum = ~csum_unfold(csum_ipv6_magic(&ip6h->saddr,\r\n&ip6h->daddr,\r\nskb2->len,\r\nIPPROTO_ICMPV6, 0));\r\nif (__skb_checksum_complete(skb2))\r\ngoto out;\r\n}\r\nerr = 0;\r\nBR_INPUT_SKB_CB(skb)->igmp = 1;\r\nswitch (icmp6_type) {\r\ncase ICMPV6_MGM_REPORT:\r\n{\r\nstruct mld_msg *mld;\r\nif (!pskb_may_pull(skb2, sizeof(*mld))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld = (struct mld_msg *)skb_transport_header(skb2);\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nerr = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);\r\nbreak;\r\n}\r\ncase ICMPV6_MLD2_REPORT:\r\nerr = br_ip6_multicast_mld2_report(br, port, skb2, vid);\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\nerr = br_ip6_multicast_query(br, port, skb2, vid);\r\nbreak;\r\ncase ICMPV6_MGM_REDUCTION:\r\n{\r\nstruct mld_msg *mld;\r\nif (!pskb_may_pull(skb2, sizeof(*mld))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld = (struct mld_msg *)skb_transport_header(skb2);\r\nbr_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);\r\n}\r\n}\r\nout:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\r\nstruct sk_buff *skb, u16 vid)\r\n{\r\nBR_INPUT_SKB_CB(skb)->igmp = 0;\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\r\nif (br->multicast_disabled)\r\nreturn 0;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nreturn br_multicast_ipv4_rcv(br, port, skb, vid);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn br_multicast_ipv6_rcv(br, port, skb, vid);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void br_multicast_query_expired(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query,\r\nstruct bridge_mcast_querier *querier)\r\n{\r\nspin_lock(&br->multicast_lock);\r\nif (query->startup_sent < br->multicast_startup_query_count)\r\nquery->startup_sent++;\r\nRCU_INIT_POINTER(querier, NULL);\r\nbr_multicast_send_query(br, NULL, query);\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_query_expired(br, &br->ip4_own_query, &br->ip4_querier);\r\n}\r\nstatic void br_ip6_multicast_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_query_expired(br, &br->ip6_own_query, &br->ip6_querier);\r\n}\r\nvoid br_multicast_init(struct net_bridge *br)\r\n{\r\nbr->hash_elasticity = 4;\r\nbr->hash_max = 512;\r\nbr->multicast_router = 1;\r\nbr->multicast_querier = 0;\r\nbr->multicast_query_use_ifaddr = 0;\r\nbr->multicast_last_member_count = 2;\r\nbr->multicast_startup_query_count = 2;\r\nbr->multicast_last_member_interval = HZ;\r\nbr->multicast_query_response_interval = 10 * HZ;\r\nbr->multicast_startup_query_interval = 125 * HZ / 4;\r\nbr->multicast_query_interval = 125 * HZ;\r\nbr->multicast_querier_interval = 255 * HZ;\r\nbr->multicast_membership_interval = 260 * HZ;\r\nbr->ip4_other_query.delay_time = 0;\r\nbr->ip4_querier.port = NULL;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbr->ip6_other_query.delay_time = 0;\r\nbr->ip6_querier.port = NULL;\r\n#endif\r\nspin_lock_init(&br->multicast_lock);\r\nsetup_timer(&br->multicast_router_timer,\r\nbr_multicast_local_router_expired, 0);\r\nsetup_timer(&br->ip4_other_query.timer,\r\nbr_ip4_multicast_querier_expired, (unsigned long)br);\r\nsetup_timer(&br->ip4_own_query.timer, br_ip4_multicast_query_expired,\r\n(unsigned long)br);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nsetup_timer(&br->ip6_other_query.timer,\r\nbr_ip6_multicast_querier_expired, (unsigned long)br);\r\nsetup_timer(&br->ip6_own_query.timer, br_ip6_multicast_query_expired,\r\n(unsigned long)br);\r\n#endif\r\n}\r\nstatic void __br_multicast_open(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nquery->startup_sent = 0;\r\nif (br->multicast_disabled)\r\nreturn;\r\nmod_timer(&query->timer, jiffies);\r\n}\r\nvoid br_multicast_open(struct net_bridge *br)\r\n{\r\n__br_multicast_open(br, &br->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n__br_multicast_open(br, &br->ip6_own_query);\r\n#endif\r\n}\r\nvoid br_multicast_stop(struct net_bridge *br)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct hlist_node *n;\r\nu32 ver;\r\nint i;\r\ndel_timer_sync(&br->multicast_router_timer);\r\ndel_timer_sync(&br->ip4_other_query.timer);\r\ndel_timer_sync(&br->ip4_own_query.timer);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ndel_timer_sync(&br->ip6_other_query.timer);\r\ndel_timer_sync(&br->ip6_own_query.timer);\r\n#endif\r\nspin_lock_bh(&br->multicast_lock);\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (!mdb)\r\ngoto out;\r\nbr->mdb = NULL;\r\nver = mdb->ver;\r\nfor (i = 0; i < mdb->max; i++) {\r\nhlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\r\nhlist[ver]) {\r\ndel_timer(&mp->timer);\r\ncall_rcu_bh(&mp->rcu, br_multicast_free_group);\r\n}\r\n}\r\nif (mdb->old) {\r\nspin_unlock_bh(&br->multicast_lock);\r\nrcu_barrier_bh();\r\nspin_lock_bh(&br->multicast_lock);\r\nWARN_ON(mdb->old);\r\n}\r\nmdb->old = mdb;\r\ncall_rcu_bh(&mdb->rcu, br_mdb_free);\r\nout:\r\nspin_unlock_bh(&br->multicast_lock);\r\n}\r\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\r\n{\r\nint err = -ENOENT;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (!netif_running(br->dev))\r\ngoto unlock;\r\nswitch (val) {\r\ncase 0:\r\ncase 2:\r\ndel_timer(&br->multicast_router_timer);\r\ncase 1:\r\nbr->multicast_router = val;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\r\n{\r\nstruct net_bridge *br = p->br;\r\nint err = -ENOENT;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)\r\ngoto unlock;\r\nswitch (val) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\np->multicast_router = val;\r\nerr = 0;\r\nif (val < 2 && !hlist_unhashed(&p->rlist))\r\nhlist_del_init_rcu(&p->rlist);\r\nif (val == 1)\r\nbreak;\r\ndel_timer(&p->multicast_router_timer);\r\nif (val == 0)\r\nbreak;\r\nbr_multicast_add_router(br, p);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nunlock:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic void br_multicast_start_querier(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nstruct net_bridge_port *port;\r\n__br_multicast_open(br, query);\r\nlist_for_each_entry(port, &br->port_list, list) {\r\nif (port->state == BR_STATE_DISABLED ||\r\nport->state == BR_STATE_BLOCKING)\r\ncontinue;\r\nif (query == &br->ip4_own_query)\r\nbr_multicast_enable(&port->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nbr_multicast_enable(&port->ip6_own_query);\r\n#endif\r\n}\r\n}\r\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\r\n{\r\nint err = 0;\r\nstruct net_bridge_mdb_htable *mdb;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (br->multicast_disabled == !val)\r\ngoto unlock;\r\nbr->multicast_disabled = !val;\r\nif (br->multicast_disabled)\r\ngoto unlock;\r\nif (!netif_running(br->dev))\r\ngoto unlock;\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (mdb) {\r\nif (mdb->old) {\r\nerr = -EEXIST;\r\nrollback:\r\nbr->multicast_disabled = !!val;\r\ngoto unlock;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, mdb->max,\r\nbr->hash_elasticity);\r\nif (err)\r\ngoto rollback;\r\n}\r\nbr_multicast_start_querier(br, &br->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbr_multicast_start_querier(br, &br->ip6_own_query);\r\n#endif\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nint br_multicast_set_querier(struct net_bridge *br, unsigned long val)\r\n{\r\nunsigned long max_delay;\r\nval = !!val;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (br->multicast_querier == val)\r\ngoto unlock;\r\nbr->multicast_querier = val;\r\nif (!val)\r\ngoto unlock;\r\nmax_delay = br->multicast_query_response_interval;\r\nif (!timer_pending(&br->ip4_other_query.timer))\r\nbr->ip4_other_query.delay_time = jiffies + max_delay;\r\nbr_multicast_start_querier(br, &br->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (!timer_pending(&br->ip6_other_query.timer))\r\nbr->ip6_other_query.delay_time = jiffies + max_delay;\r\nbr_multicast_start_querier(br, &br->ip6_own_query);\r\n#endif\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn 0;\r\n}\r\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\r\n{\r\nint err = -ENOENT;\r\nu32 old;\r\nstruct net_bridge_mdb_htable *mdb;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (!netif_running(br->dev))\r\ngoto unlock;\r\nerr = -EINVAL;\r\nif (!is_power_of_2(val))\r\ngoto unlock;\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (mdb && val < mdb->size)\r\ngoto unlock;\r\nerr = 0;\r\nold = br->hash_max;\r\nbr->hash_max = val;\r\nif (mdb) {\r\nif (mdb->old) {\r\nerr = -EEXIST;\r\nrollback:\r\nbr->hash_max = old;\r\ngoto unlock;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, br->hash_max,\r\nbr->hash_elasticity);\r\nif (err)\r\ngoto rollback;\r\n}\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nint br_multicast_list_adjacent(struct net_device *dev,\r\nstruct list_head *br_ip_list)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nstruct net_bridge_port_group *group;\r\nstruct br_ip_list *entry;\r\nint count = 0;\r\nrcu_read_lock();\r\nif (!br_ip_list || !br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nlist_for_each_entry_rcu(port, &br->port_list, list) {\r\nif (!port->dev || port->dev == dev)\r\ncontinue;\r\nhlist_for_each_entry_rcu(group, &port->mglist, mglist) {\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\ngoto unlock;\r\nentry->addr = group->addr;\r\nlist_add(&entry->list, br_ip_list);\r\ncount++;\r\n}\r\n}\r\nunlock:\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nbool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nstruct ethhdr eth;\r\nbool ret = false;\r\nrcu_read_lock();\r\nif (!br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nmemset(&eth, 0, sizeof(eth));\r\neth.h_proto = htons(proto);\r\nret = br_multicast_querier_exists(br, &eth);\r\nunlock:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nbool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nbool ret = false;\r\nrcu_read_lock();\r\nif (!br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nswitch (proto) {\r\ncase ETH_P_IP:\r\nif (!timer_pending(&br->ip4_other_query.timer) ||\r\nrcu_dereference(br->ip4_querier.port) == port)\r\ngoto unlock;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase ETH_P_IPV6:\r\nif (!timer_pending(&br->ip6_other_query.timer) ||\r\nrcu_dereference(br->ip6_querier.port) == port)\r\ngoto unlock;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto unlock;\r\n}\r\nret = true;\r\nunlock:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}
