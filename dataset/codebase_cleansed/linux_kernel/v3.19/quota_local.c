static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\r\n{\r\nreturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\r\nsizeof(struct ocfs2_local_disk_dqblk));\r\n}\r\nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\r\n{\r\nreturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\r\nOCFS2_QBLK_RESERVED_SPACE) << 3) /\r\nol_quota_entries_per_block(sb);\r\n}\r\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\r\n{\r\nreturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\r\n}\r\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\r\n{\r\nreturn 1 + (ol_chunk_blocks(sb) + 1) * c;\r\n}\r\nstatic unsigned int ol_dqblk_block(struct super_block *sb, int c, int off)\r\n{\r\nint epb = ol_quota_entries_per_block(sb);\r\nreturn ol_quota_chunk_block(sb, c) + 1 + off / epb;\r\n}\r\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\r\n{\r\nint epb = ol_quota_entries_per_block(sb);\r\nreturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\r\n}\r\nstatic loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\r\n{\r\nreturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\r\nol_dqblk_block_off(sb, c, off);\r\n}\r\nstatic inline unsigned int ol_dqblk_file_block(struct super_block *sb, loff_t off)\r\n{\r\nreturn off >> sb->s_blocksize_bits;\r\n}\r\nstatic inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\r\n{\r\nreturn off & ((1 << sb->s_blocksize_bits) - 1);\r\n}\r\nstatic int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\r\n{\r\nint epb = ol_quota_entries_per_block(sb);\r\nreturn ((off >> sb->s_blocksize_bits) -\r\nol_quota_chunk_block(sb, c) - 1) * epb\r\n+ ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\r\nsizeof(struct ocfs2_local_disk_dqblk);\r\n}\r\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\r\nvoid (*modify)(struct buffer_head *, void *), void *private)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nhandle_t *handle;\r\nint status;\r\nhandle = ocfs2_start_trans(OCFS2_SB(sb),\r\nOCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\nocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nreturn status;\r\n}\r\nlock_buffer(bh);\r\nmodify(bh, private);\r\nunlock_buffer(bh);\r\nocfs2_journal_dirty(handle, bh);\r\nstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nif (status < 0) {\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\r\nstruct buffer_head **bh)\r\n{\r\nint rc = 0;\r\nstruct buffer_head *tmp = *bh;\r\nif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\r\nocfs2_error(inode->i_sb,\r\n"Quota file %llu is probably corrupted! Requested "\r\n"to read block %Lu but file has size only %Lu\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\n(unsigned long long)v_block,\r\n(unsigned long long)i_size_read(inode));\r\nreturn -EIO;\r\n}\r\nrc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\r\nocfs2_validate_quota_block);\r\nif (rc)\r\nmlog_errno(rc);\r\nif (!rc && !*bh)\r\n*bh = tmp;\r\nreturn rc;\r\n}\r\nstatic int ocfs2_local_check_quota_file(struct super_block *sb, int type)\r\n{\r\nunsigned int lmagics[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QMAGICS;\r\nunsigned int lversions[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QVERSIONS;\r\nunsigned int gmagics[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QMAGICS;\r\nunsigned int gversions[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QVERSIONS;\r\nunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\r\nGROUP_QUOTA_SYSTEM_INODE };\r\nstruct buffer_head *bh = NULL;\r\nstruct inode *linode = sb_dqopt(sb)->files[type];\r\nstruct inode *ginode = NULL;\r\nstruct ocfs2_disk_dqheader *dqhead;\r\nint status, ret = 0;\r\nstatus = ocfs2_read_quota_block(linode, 0, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR, "failed to read quota file header (type=%d)\n",\r\ntype);\r\ngoto out_err;\r\n}\r\ndqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\r\nif (le32_to_cpu(dqhead->dqh_magic) != lmagics[type]) {\r\nmlog(ML_ERROR, "quota file magic does not match (%u != %u),"\r\n" type=%d\n", le32_to_cpu(dqhead->dqh_magic),\r\nlmagics[type], type);\r\ngoto out_err;\r\n}\r\nif (le32_to_cpu(dqhead->dqh_version) != lversions[type]) {\r\nmlog(ML_ERROR, "quota file version does not match (%u != %u),"\r\n" type=%d\n", le32_to_cpu(dqhead->dqh_version),\r\nlversions[type], type);\r\ngoto out_err;\r\n}\r\nbrelse(bh);\r\nbh = NULL;\r\nginode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\r\nOCFS2_INVALID_SLOT);\r\nif (!ginode) {\r\nmlog(ML_ERROR, "cannot get global quota file inode "\r\n"(type=%d)\n", type);\r\ngoto out_err;\r\n}\r\nstatus = ocfs2_read_quota_block(ginode, 0, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR, "failed to read global quota file header "\r\n"(type=%d)\n", type);\r\ngoto out_err;\r\n}\r\ndqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\r\nif (le32_to_cpu(dqhead->dqh_magic) != gmagics[type]) {\r\nmlog(ML_ERROR, "global quota file magic does not match "\r\n"(%u != %u), type=%d\n",\r\nle32_to_cpu(dqhead->dqh_magic), gmagics[type], type);\r\ngoto out_err;\r\n}\r\nif (le32_to_cpu(dqhead->dqh_version) != gversions[type]) {\r\nmlog(ML_ERROR, "global quota file version does not match "\r\n"(%u != %u), type=%d\n",\r\nle32_to_cpu(dqhead->dqh_version), gversions[type],\r\ntype);\r\ngoto out_err;\r\n}\r\nret = 1;\r\nout_err:\r\nbrelse(bh);\r\niput(ginode);\r\nreturn ret;\r\n}\r\nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\r\n{\r\nstruct ocfs2_quota_chunk *pos, *next;\r\nlist_for_each_entry_safe(pos, next, head, qc_chunk) {\r\nlist_del(&pos->qc_chunk);\r\nbrelse(pos->qc_headerbh);\r\nkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\r\n}\r\n}\r\nstatic int ocfs2_load_local_quota_bitmaps(struct inode *inode,\r\nstruct ocfs2_local_disk_dqinfo *ldinfo,\r\nstruct list_head *head)\r\n{\r\nstruct ocfs2_quota_chunk *newchunk;\r\nint i, status;\r\nINIT_LIST_HEAD(head);\r\nfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\r\nnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\r\nif (!newchunk) {\r\nocfs2_release_local_quota_bitmaps(head);\r\nreturn -ENOMEM;\r\n}\r\nnewchunk->qc_num = i;\r\nnewchunk->qc_headerbh = NULL;\r\nstatus = ocfs2_read_quota_block(inode,\r\nol_quota_chunk_block(inode->i_sb, i),\r\n&newchunk->qc_headerbh);\r\nif (status) {\r\nmlog_errno(status);\r\nkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\r\nocfs2_release_local_quota_bitmaps(head);\r\nreturn status;\r\n}\r\nlist_add_tail(&newchunk->qc_chunk, head);\r\n}\r\nreturn 0;\r\n}\r\nstatic void olq_update_info(struct buffer_head *bh, void *private)\r\n{\r\nstruct mem_dqinfo *info = private;\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct ocfs2_local_disk_dqinfo *ldinfo;\r\nldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\r\nOCFS2_LOCAL_INFO_OFF);\r\nspin_lock(&dq_data_lock);\r\nldinfo->dqi_flags = cpu_to_le32(info->dqi_flags & DQF_MASK);\r\nldinfo->dqi_chunks = cpu_to_le32(oinfo->dqi_chunks);\r\nldinfo->dqi_blocks = cpu_to_le32(oinfo->dqi_blocks);\r\nspin_unlock(&dq_data_lock);\r\n}\r\nstatic int ocfs2_add_recovery_chunk(struct super_block *sb,\r\nstruct ocfs2_local_disk_chunk *dchunk,\r\nint chunk,\r\nstruct list_head *head)\r\n{\r\nstruct ocfs2_recovery_chunk *rc;\r\nrc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\r\nif (!rc)\r\nreturn -ENOMEM;\r\nrc->rc_chunk = chunk;\r\nrc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\r\nif (!rc->rc_bitmap) {\r\nkfree(rc);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\r\n(ol_chunk_entries(sb) + 7) >> 3);\r\nlist_add_tail(&rc->rc_list, head);\r\nreturn 0;\r\n}\r\nstatic void free_recovery_list(struct list_head *head)\r\n{\r\nstruct ocfs2_recovery_chunk *next;\r\nstruct ocfs2_recovery_chunk *rchunk;\r\nlist_for_each_entry_safe(rchunk, next, head, rc_list) {\r\nlist_del(&rchunk->rc_list);\r\nkfree(rchunk->rc_bitmap);\r\nkfree(rchunk);\r\n}\r\n}\r\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\r\n{\r\nint type;\r\nfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\r\nfree_recovery_list(&(rec->r_list[type]));\r\nkfree(rec);\r\n}\r\nstatic int ocfs2_recovery_load_quota(struct inode *lqinode,\r\nstruct ocfs2_local_disk_dqinfo *ldinfo,\r\nint type,\r\nstruct list_head *head)\r\n{\r\nstruct super_block *sb = lqinode->i_sb;\r\nstruct buffer_head *hbh;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\r\nint status = 0;\r\nfor (i = 0; i < chunks; i++) {\r\nhbh = NULL;\r\nstatus = ocfs2_read_quota_block(lqinode,\r\nol_quota_chunk_block(sb, i),\r\n&hbh);\r\nif (status) {\r\nmlog_errno(status);\r\nbreak;\r\n}\r\ndchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\r\nif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\r\nstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\r\nbrelse(hbh);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (status < 0)\r\nfree_recovery_list(head);\r\nreturn status;\r\n}\r\nstatic struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\r\n{\r\nint type;\r\nstruct ocfs2_quota_recovery *rec;\r\nrec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\r\nif (!rec)\r\nreturn NULL;\r\nfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\r\nINIT_LIST_HEAD(&(rec->r_list[type]));\r\nreturn rec;\r\n}\r\nstruct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\r\nstruct ocfs2_super *osb,\r\nint slot_num)\r\n{\r\nunsigned int feature[OCFS2_MAXQUOTAS] = {\r\nOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\r\nOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\r\nunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\r\nLOCAL_GROUP_QUOTA_SYSTEM_INODE };\r\nstruct super_block *sb = osb->sb;\r\nstruct ocfs2_local_disk_dqinfo *ldinfo;\r\nstruct inode *lqinode;\r\nstruct buffer_head *bh;\r\nint type;\r\nint status = 0;\r\nstruct ocfs2_quota_recovery *rec;\r\nprintk(KERN_NOTICE "ocfs2: Beginning quota recovery on device (%s) for "\r\n"slot %u\n", osb->dev_str, slot_num);\r\nrec = ocfs2_alloc_quota_recovery();\r\nif (!rec)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\r\nif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\r\ncontinue;\r\nlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\r\nif (!lqinode) {\r\nstatus = -ENOENT;\r\ngoto out;\r\n}\r\nstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\r\nOCFS2_META_LOCK_RECOVERY);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_put;\r\n}\r\nbh = NULL;\r\nstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR, "failed to read quota file info header "\r\n"(slot=%d type=%d)\n", slot_num, type);\r\ngoto out_lock;\r\n}\r\nldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\r\nOCFS2_LOCAL_INFO_OFF);\r\nstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\r\n&rec->r_list[type]);\r\nbrelse(bh);\r\nout_lock:\r\nocfs2_inode_unlock(lqinode, 1);\r\nout_put:\r\niput(lqinode);\r\nif (status < 0)\r\nbreak;\r\n}\r\nout:\r\nif (status < 0) {\r\nocfs2_free_quota_recovery(rec);\r\nrec = ERR_PTR(status);\r\n}\r\nreturn rec;\r\n}\r\nstatic int ocfs2_recover_local_quota_file(struct inode *lqinode,\r\nint type,\r\nstruct ocfs2_quota_recovery *rec)\r\n{\r\nstruct super_block *sb = lqinode->i_sb;\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nstruct ocfs2_local_disk_dqblk *dqblk;\r\nstruct dquot *dquot;\r\nhandle_t *handle;\r\nstruct buffer_head *hbh = NULL, *qbh = NULL;\r\nint status = 0;\r\nint bit, chunk;\r\nstruct ocfs2_recovery_chunk *rchunk, *next;\r\nqsize_t spacechange, inodechange;\r\ntrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\r\nlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\r\nchunk = rchunk->rc_chunk;\r\nhbh = NULL;\r\nstatus = ocfs2_read_quota_block(lqinode,\r\nol_quota_chunk_block(sb, chunk),\r\n&hbh);\r\nif (status) {\r\nmlog_errno(status);\r\nbreak;\r\n}\r\ndchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\r\nfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\r\nqbh = NULL;\r\nstatus = ocfs2_read_quota_block(lqinode,\r\nol_dqblk_block(sb, chunk, bit),\r\n&qbh);\r\nif (status) {\r\nmlog_errno(status);\r\nbreak;\r\n}\r\ndqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\r\nol_dqblk_block_off(sb, chunk, bit));\r\ndquot = dqget(sb,\r\nmake_kqid(&init_user_ns, type,\r\nle64_to_cpu(dqblk->dqb_id)));\r\nif (!dquot) {\r\nstatus = -EIO;\r\nmlog(ML_ERROR, "Failed to get quota structure "\r\n"for id %u, type %d. Cannot finish quota "\r\n"file recovery.\n",\r\n(unsigned)le64_to_cpu(dqblk->dqb_id),\r\ntype);\r\ngoto out_put_bh;\r\n}\r\nstatus = ocfs2_lock_global_qf(oinfo, 1);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_put_dquot;\r\n}\r\nhandle = ocfs2_start_trans(OCFS2_SB(sb),\r\nOCFS2_QSYNC_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_drop_lock;\r\n}\r\nmutex_lock(&sb_dqopt(sb)->dqio_mutex);\r\nspin_lock(&dq_data_lock);\r\nspacechange = le64_to_cpu(dqblk->dqb_spacemod);\r\ninodechange = le64_to_cpu(dqblk->dqb_inodemod);\r\ndquot->dq_dqb.dqb_curspace += spacechange;\r\ndquot->dq_dqb.dqb_curinodes += inodechange;\r\nspin_unlock(&dq_data_lock);\r\nstatus = ocfs2_global_release_dquot(dquot);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_commit;\r\n}\r\nstatus = ocfs2_journal_access_dq(handle,\r\nINODE_CACHE(lqinode),\r\nqbh, OCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_commit;\r\n}\r\nlock_buffer(qbh);\r\nWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\r\nocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\r\nle32_add_cpu(&dchunk->dqc_free, 1);\r\nunlock_buffer(qbh);\r\nocfs2_journal_dirty(handle, qbh);\r\nout_commit:\r\nmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\r\nocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nout_drop_lock:\r\nocfs2_unlock_global_qf(oinfo, 1);\r\nout_put_dquot:\r\ndqput(dquot);\r\nout_put_bh:\r\nbrelse(qbh);\r\nif (status < 0)\r\nbreak;\r\n}\r\nbrelse(hbh);\r\nlist_del(&rchunk->rc_list);\r\nkfree(rchunk->rc_bitmap);\r\nkfree(rchunk);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (status < 0)\r\nfree_recovery_list(&(rec->r_list[type]));\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nint ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\r\nstruct ocfs2_quota_recovery *rec,\r\nint slot_num)\r\n{\r\nunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\r\nLOCAL_GROUP_QUOTA_SYSTEM_INODE };\r\nstruct super_block *sb = osb->sb;\r\nstruct ocfs2_local_disk_dqinfo *ldinfo;\r\nstruct buffer_head *bh;\r\nhandle_t *handle;\r\nint type;\r\nint status = 0;\r\nstruct inode *lqinode;\r\nunsigned int flags;\r\nprintk(KERN_NOTICE "ocfs2: Finishing quota recovery on device (%s) for "\r\n"slot %u\n", osb->dev_str, slot_num);\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\r\nif (list_empty(&(rec->r_list[type])))\r\ncontinue;\r\ntrace_ocfs2_finish_quota_recovery(slot_num);\r\nlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\r\nif (!lqinode) {\r\nstatus = -ENOENT;\r\ngoto out;\r\n}\r\nstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\r\nOCFS2_META_LOCK_NOQUEUE);\r\nif (status == -EAGAIN) {\r\nprintk(KERN_NOTICE "ocfs2: Skipping quota recovery on "\r\n"device (%s) for slot %d because quota file is "\r\n"locked.\n", osb->dev_str, slot_num);\r\nstatus = 0;\r\ngoto out_put;\r\n} else if (status < 0) {\r\nmlog_errno(status);\r\ngoto out_put;\r\n}\r\nbh = NULL;\r\nstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR, "failed to read quota file info header "\r\n"(slot=%d type=%d)\n", slot_num, type);\r\ngoto out_lock;\r\n}\r\nldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\r\nOCFS2_LOCAL_INFO_OFF);\r\nflags = le32_to_cpu(ldinfo->dqi_flags);\r\nif (!(flags & OLQF_CLEAN))\r\nstatus = ocfs2_recover_local_quota_file(lqinode,\r\ntype,\r\nrec);\r\nif (slot_num == osb->slot_num)\r\ngoto out_bh;\r\nhandle = ocfs2_start_trans(osb,\r\nOCFS2_LOCAL_QINFO_WRITE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_bh;\r\n}\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\r\nbh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nlock_buffer(bh);\r\nldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\r\nunlock_buffer(bh);\r\nocfs2_journal_dirty(handle, bh);\r\nout_trans:\r\nocfs2_commit_trans(osb, handle);\r\nout_bh:\r\nbrelse(bh);\r\nout_lock:\r\nocfs2_inode_unlock(lqinode, 1);\r\nout_put:\r\niput(lqinode);\r\nif (status < 0)\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nkfree(rec);\r\nreturn status;\r\n}\r\nstatic int ocfs2_local_read_info(struct super_block *sb, int type)\r\n{\r\nstruct ocfs2_local_disk_dqinfo *ldinfo;\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo;\r\nstruct inode *lqinode = sb_dqopt(sb)->files[type];\r\nint status;\r\nstruct buffer_head *bh = NULL;\r\nstruct ocfs2_quota_recovery *rec;\r\nint locked = 0;\r\nmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\r\ninfo->dqi_maxblimit = 0x7fffffffffffffffLL;\r\ninfo->dqi_maxilimit = 0x7fffffffffffffffLL;\r\noinfo = kmalloc(sizeof(struct ocfs2_mem_dqinfo), GFP_NOFS);\r\nif (!oinfo) {\r\nmlog(ML_ERROR, "failed to allocate memory for ocfs2 quota"\r\n" info.");\r\ngoto out_err;\r\n}\r\ninfo->dqi_priv = oinfo;\r\noinfo->dqi_type = type;\r\nINIT_LIST_HEAD(&oinfo->dqi_chunk);\r\noinfo->dqi_rec = NULL;\r\noinfo->dqi_lqi_bh = NULL;\r\noinfo->dqi_libh = NULL;\r\nstatus = ocfs2_global_read_info(sb, type);\r\nif (status < 0)\r\ngoto out_err;\r\nstatus = ocfs2_inode_lock(lqinode, &oinfo->dqi_lqi_bh, 1);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\nlocked = 1;\r\nstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR, "failed to read quota file info header "\r\n"(type=%d)\n", type);\r\ngoto out_err;\r\n}\r\nldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\r\nOCFS2_LOCAL_INFO_OFF);\r\ninfo->dqi_flags = le32_to_cpu(ldinfo->dqi_flags);\r\noinfo->dqi_chunks = le32_to_cpu(ldinfo->dqi_chunks);\r\noinfo->dqi_blocks = le32_to_cpu(ldinfo->dqi_blocks);\r\noinfo->dqi_libh = bh;\r\nif (!(info->dqi_flags & OLQF_CLEAN)) {\r\nrec = OCFS2_SB(sb)->quota_rec;\r\nif (!rec) {\r\nrec = ocfs2_alloc_quota_recovery();\r\nif (!rec) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\nOCFS2_SB(sb)->quota_rec = rec;\r\n}\r\nstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\r\n&rec->r_list[type]);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\n}\r\nstatus = ocfs2_load_local_quota_bitmaps(lqinode,\r\nldinfo,\r\n&oinfo->dqi_chunk);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\ninfo->dqi_flags &= ~OLQF_CLEAN;\r\nstatus = ocfs2_modify_bh(lqinode, bh, olq_update_info, info);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\nmutex_lock(&sb_dqopt(sb)->dqio_mutex);\r\nreturn 0;\r\nout_err:\r\nif (oinfo) {\r\niput(oinfo->dqi_gqinode);\r\nocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\r\nocfs2_lock_res_free(&oinfo->dqi_gqlock);\r\nbrelse(oinfo->dqi_lqi_bh);\r\nif (locked)\r\nocfs2_inode_unlock(lqinode, 1);\r\nocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\r\nkfree(oinfo);\r\n}\r\nbrelse(bh);\r\nmutex_lock(&sb_dqopt(sb)->dqio_mutex);\r\nreturn -1;\r\n}\r\nstatic int ocfs2_local_write_info(struct super_block *sb, int type)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\r\n->dqi_libh;\r\nint status;\r\nstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\r\ninfo);\r\nif (status < 0) {\r\nmlog_errno(status);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocfs2_local_free_info(struct super_block *sb, int type)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct ocfs2_quota_chunk *chunk;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint mark_clean = 1, len;\r\nint status;\r\niput(oinfo->dqi_gqinode);\r\nocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\r\nocfs2_lock_res_free(&oinfo->dqi_gqlock);\r\nlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\r\ndchunk = (struct ocfs2_local_disk_chunk *)\r\n(chunk->qc_headerbh->b_data);\r\nif (chunk->qc_num < oinfo->dqi_chunks - 1) {\r\nlen = ol_chunk_entries(sb);\r\n} else {\r\nlen = (oinfo->dqi_blocks -\r\nol_quota_chunk_block(sb, chunk->qc_num) - 1)\r\n* ol_quota_entries_per_block(sb);\r\n}\r\nif (le32_to_cpu(dchunk->dqc_free) != len) {\r\nmlog(ML_ERROR, "releasing quota file with used "\r\n"entries (type=%d)\n", type);\r\nmark_clean = 0;\r\n}\r\n}\r\nocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\r\nif (oinfo->dqi_rec) {\r\nocfs2_free_quota_recovery(oinfo->dqi_rec);\r\nmark_clean = 0;\r\n}\r\nif (!mark_clean)\r\ngoto out;\r\ninfo->dqi_flags |= OLQF_CLEAN;\r\nstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\r\noinfo->dqi_libh,\r\nolq_update_info,\r\ninfo);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nout:\r\nocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\r\nbrelse(oinfo->dqi_libh);\r\nbrelse(oinfo->dqi_lqi_bh);\r\nkfree(oinfo);\r\nreturn 0;\r\n}\r\nstatic void olq_set_dquot(struct buffer_head *bh, void *private)\r\n{\r\nstruct ocfs2_dquot *od = private;\r\nstruct ocfs2_local_disk_dqblk *dqblk;\r\nstruct super_block *sb = od->dq_dquot.dq_sb;\r\ndqblk = (struct ocfs2_local_disk_dqblk *)(bh->b_data\r\n+ ol_dqblk_block_offset(sb, od->dq_local_off));\r\ndqblk->dqb_id = cpu_to_le64(from_kqid(&init_user_ns,\r\nod->dq_dquot.dq_id));\r\nspin_lock(&dq_data_lock);\r\ndqblk->dqb_spacemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curspace -\r\nod->dq_origspace);\r\ndqblk->dqb_inodemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curinodes -\r\nod->dq_originodes);\r\nspin_unlock(&dq_data_lock);\r\ntrace_olq_set_dquot(\r\n(unsigned long long)le64_to_cpu(dqblk->dqb_spacemod),\r\n(unsigned long long)le64_to_cpu(dqblk->dqb_inodemod),\r\nfrom_kqid(&init_user_ns, od->dq_dquot.dq_id));\r\n}\r\nint ocfs2_local_write_dquot(struct dquot *dquot)\r\n{\r\nstruct super_block *sb = dquot->dq_sb;\r\nstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\r\nstruct buffer_head *bh;\r\nstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\r\nint status;\r\nstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\r\n&bh);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nout:\r\nbrelse(bh);\r\nreturn status;\r\n}\r\nstatic struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\r\nint type,\r\nint *offset)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct ocfs2_quota_chunk *chunk;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint found = 0, len;\r\nlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\r\ndchunk = (struct ocfs2_local_disk_chunk *)\r\nchunk->qc_headerbh->b_data;\r\nif (le32_to_cpu(dchunk->dqc_free) > 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn NULL;\r\nif (chunk->qc_num < oinfo->dqi_chunks - 1) {\r\nlen = ol_chunk_entries(sb);\r\n} else {\r\nlen = (oinfo->dqi_blocks -\r\nol_quota_chunk_block(sb, chunk->qc_num) - 1)\r\n* ol_quota_entries_per_block(sb);\r\n}\r\nfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\r\nif (found == len) {\r\nmlog(ML_ERROR, "Did not find empty entry in chunk %d with %u"\r\n" entries free (type=%d)\n", chunk->qc_num,\r\nle32_to_cpu(dchunk->dqc_free), type);\r\nreturn ERR_PTR(-EIO);\r\n}\r\n*offset = found;\r\nreturn chunk;\r\n}\r\nstatic struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\r\nstruct super_block *sb,\r\nint type,\r\nint *offset)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct inode *lqinode = sb_dqopt(sb)->files[type];\r\nstruct ocfs2_quota_chunk *chunk = NULL;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint status;\r\nhandle_t *handle;\r\nstruct buffer_head *bh = NULL, *dbh = NULL;\r\nu64 p_blkno;\r\nstatus = ocfs2_extend_no_holes(lqinode, NULL,\r\ni_size_read(lqinode) + 2 * sb->s_blocksize,\r\ni_size_read(lqinode));\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\r\ni_size_read(lqinode) + 2 * sb->s_blocksize);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\r\nif (!chunk) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nhandle = ocfs2_start_trans(OCFS2_SB(sb),\r\nOCFS2_LOCAL_QINFO_WRITE_CREDITS +\r\n2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\r\n&p_blkno, NULL, NULL);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nbh = sb_getblk(sb, p_blkno);\r\nif (!bh) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\ndchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\r\nocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nlock_buffer(bh);\r\ndchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\r\nmemset(dchunk->dqc_bitmap, 0,\r\nsb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\r\nOCFS2_QBLK_RESERVED_SPACE);\r\nunlock_buffer(bh);\r\nocfs2_journal_dirty(handle, bh);\r\nstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\r\n&p_blkno, NULL, NULL);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\ndbh = sb_getblk(sb, p_blkno);\r\nif (!dbh) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nlock_buffer(dbh);\r\nmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\r\nunlock_buffer(dbh);\r\nocfs2_journal_dirty(handle, dbh);\r\noinfo->dqi_blocks += 2;\r\noinfo->dqi_chunks++;\r\nstatus = ocfs2_local_write_info(sb, type);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\r\nchunk->qc_num = list_entry(chunk->qc_chunk.prev,\r\nstruct ocfs2_quota_chunk,\r\nqc_chunk)->qc_num + 1;\r\nchunk->qc_headerbh = bh;\r\n*offset = 0;\r\nreturn chunk;\r\nout_trans:\r\nocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nout:\r\nbrelse(bh);\r\nbrelse(dbh);\r\nkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\r\nreturn ERR_PTR(status);\r\n}\r\nstatic struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\r\nstruct super_block *sb,\r\nint type,\r\nint *offset)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct ocfs2_quota_chunk *chunk;\r\nstruct inode *lqinode = sb_dqopt(sb)->files[type];\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint epb = ol_quota_entries_per_block(sb);\r\nunsigned int chunk_blocks;\r\nstruct buffer_head *bh;\r\nu64 p_blkno;\r\nint status;\r\nhandle_t *handle;\r\nif (list_empty(&oinfo->dqi_chunk))\r\nreturn ocfs2_local_quota_add_chunk(sb, type, offset);\r\nchunk = list_entry(oinfo->dqi_chunk.prev,\r\nstruct ocfs2_quota_chunk, qc_chunk);\r\nchunk_blocks = oinfo->dqi_blocks -\r\nol_quota_chunk_block(sb, chunk->qc_num) - 1;\r\nif (ol_chunk_blocks(sb) == chunk_blocks)\r\nreturn ocfs2_local_quota_add_chunk(sb, type, offset);\r\nstatus = ocfs2_extend_no_holes(lqinode, NULL,\r\ni_size_read(lqinode) + sb->s_blocksize,\r\ni_size_read(lqinode));\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\r\ni_size_read(lqinode) + sb->s_blocksize);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\r\n&p_blkno, NULL, NULL);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nbh = sb_getblk(sb, p_blkno);\r\nif (!bh) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\r\nhandle = ocfs2_start_trans(OCFS2_SB(sb),\r\nOCFS2_LOCAL_QINFO_WRITE_CREDITS +\r\n2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nlock_buffer(bh);\r\nmemset(bh->b_data, 0, sb->s_blocksize);\r\nunlock_buffer(bh);\r\nocfs2_journal_dirty(handle, bh);\r\nstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\r\nchunk->qc_headerbh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\ndchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\r\nlock_buffer(chunk->qc_headerbh);\r\nle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\r\nunlock_buffer(chunk->qc_headerbh);\r\nocfs2_journal_dirty(handle, chunk->qc_headerbh);\r\noinfo->dqi_blocks++;\r\nstatus = ocfs2_local_write_info(sb, type);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\n*offset = chunk_blocks * epb;\r\nreturn chunk;\r\nout_trans:\r\nocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nout:\r\nreturn ERR_PTR(status);\r\n}\r\nstatic void olq_alloc_dquot(struct buffer_head *bh, void *private)\r\n{\r\nint *offset = private;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\ndchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\r\nocfs2_set_bit_unaligned(*offset, dchunk->dqc_bitmap);\r\nle32_add_cpu(&dchunk->dqc_free, -1);\r\n}\r\nint ocfs2_create_local_dquot(struct dquot *dquot)\r\n{\r\nstruct super_block *sb = dquot->dq_sb;\r\nint type = dquot->dq_id.type;\r\nstruct inode *lqinode = sb_dqopt(sb)->files[type];\r\nstruct ocfs2_quota_chunk *chunk;\r\nstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\r\nint offset;\r\nint status;\r\nu64 pcount;\r\ndown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\r\nchunk = ocfs2_find_free_entry(sb, type, &offset);\r\nif (!chunk) {\r\nchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\r\nif (IS_ERR(chunk)) {\r\nstatus = PTR_ERR(chunk);\r\ngoto out;\r\n}\r\n} else if (IS_ERR(chunk)) {\r\nstatus = PTR_ERR(chunk);\r\ngoto out;\r\n}\r\nod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\r\nod->dq_chunk = chunk;\r\nstatus = ocfs2_extent_map_get_blocks(lqinode,\r\nol_dqblk_block(sb, chunk->qc_num, offset),\r\n&od->dq_local_phys_blk,\r\n&pcount,\r\nNULL);\r\nstatus = ocfs2_local_write_dquot(dquot);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\r\n&offset);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nout:\r\nup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\r\nreturn status;\r\n}\r\nint ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\r\n{\r\nint status;\r\nint type = dquot->dq_id.type;\r\nstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\r\nstruct super_block *sb = dquot->dq_sb;\r\nstruct ocfs2_local_disk_chunk *dchunk;\r\nint offset;\r\nstatus = ocfs2_journal_access_dq(handle,\r\nINODE_CACHE(sb_dqopt(sb)->files[type]),\r\nod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\noffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\r\nod->dq_local_off);\r\ndchunk = (struct ocfs2_local_disk_chunk *)\r\n(od->dq_chunk->qc_headerbh->b_data);\r\nlock_buffer(od->dq_chunk->qc_headerbh);\r\nocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\r\nle32_add_cpu(&dchunk->dqc_free, 1);\r\nunlock_buffer(od->dq_chunk->qc_headerbh);\r\nocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\r\nout:\r\nreturn status;\r\n}
