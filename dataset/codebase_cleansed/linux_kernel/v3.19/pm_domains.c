static int exynos_pd_power(struct generic_pm_domain *domain, bool power_on)\r\n{\r\nstruct exynos_pm_domain *pd;\r\nvoid __iomem *base;\r\nu32 timeout, pwr;\r\nchar *op;\r\npd = container_of(domain, struct exynos_pm_domain, pd);\r\nbase = pd->base;\r\nif (!power_on) {\r\nint i;\r\nfor (i = 0; i < MAX_CLK_PER_DOMAIN; i++) {\r\nif (IS_ERR(pd->clk[i]))\r\nbreak;\r\nif (clk_set_parent(pd->clk[i], pd->oscclk))\r\npr_err("%s: error setting oscclk as parent to clock %d\n",\r\npd->name, i);\r\n}\r\n}\r\npwr = power_on ? INT_LOCAL_PWR_EN : 0;\r\n__raw_writel(pwr, base);\r\ntimeout = 10;\r\nwhile ((__raw_readl(base + 0x4) & INT_LOCAL_PWR_EN) != pwr) {\r\nif (!timeout) {\r\nop = (power_on) ? "enable" : "disable";\r\npr_err("Power domain %s %s failed\n", domain->name, op);\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\ncpu_relax();\r\nusleep_range(80, 100);\r\n}\r\nif (power_on) {\r\nint i;\r\nfor (i = 0; i < MAX_CLK_PER_DOMAIN; i++) {\r\nif (IS_ERR(pd->clk[i]))\r\nbreak;\r\nif (clk_set_parent(pd->clk[i], pd->pclk[i]))\r\npr_err("%s: error setting parent to clock%d\n",\r\npd->name, i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_pd_power_on(struct generic_pm_domain *domain)\r\n{\r\nreturn exynos_pd_power(domain, true);\r\n}\r\nstatic int exynos_pd_power_off(struct generic_pm_domain *domain)\r\n{\r\nreturn exynos_pd_power(domain, false);\r\n}\r\nstatic __init int exynos4_pm_init_power_domain(void)\r\n{\r\nstruct platform_device *pdev;\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "samsung,exynos4210-pd") {\r\nstruct exynos_pm_domain *pd;\r\nint on, i;\r\nstruct device *dev;\r\npdev = of_find_device_by_node(np);\r\ndev = &pdev->dev;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd) {\r\npr_err("%s: failed to allocate memory for domain\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\npd->pd.name = kstrdup(np->name, GFP_KERNEL);\r\npd->name = pd->pd.name;\r\npd->base = of_iomap(np, 0);\r\npd->pd.power_off = exynos_pd_power_off;\r\npd->pd.power_on = exynos_pd_power_on;\r\npd->oscclk = clk_get(dev, "oscclk");\r\nif (IS_ERR(pd->oscclk))\r\ngoto no_clk;\r\nfor (i = 0; i < MAX_CLK_PER_DOMAIN; i++) {\r\nchar clk_name[8];\r\nsnprintf(clk_name, sizeof(clk_name), "clk%d", i);\r\npd->clk[i] = clk_get(dev, clk_name);\r\nif (IS_ERR(pd->clk[i]))\r\nbreak;\r\nsnprintf(clk_name, sizeof(clk_name), "pclk%d", i);\r\npd->pclk[i] = clk_get(dev, clk_name);\r\nif (IS_ERR(pd->pclk[i])) {\r\nclk_put(pd->clk[i]);\r\npd->clk[i] = ERR_PTR(-EINVAL);\r\nbreak;\r\n}\r\n}\r\nif (IS_ERR(pd->clk[0]))\r\nclk_put(pd->oscclk);\r\nno_clk:\r\non = __raw_readl(pd->base + 0x4) & INT_LOCAL_PWR_EN;\r\npm_genpd_init(&pd->pd, NULL, !on);\r\nof_genpd_add_provider_simple(np, &pd->pd);\r\n}\r\nreturn 0;\r\n}
