int ast_load_dp501_microcode(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nstatic char *fw_name = "ast_dp501_fw.bin";\r\nint err;\r\nerr = request_firmware(&ast->dp501_fw, fw_name, dev->dev);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void send_ack(struct ast_private *ast)\r\n{\r\nu8 sendack;\r\nsendack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0xff);\r\nsendack |= 0x80;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0x00, sendack);\r\n}\r\nstatic void send_nack(struct ast_private *ast)\r\n{\r\nu8 sendack;\r\nsendack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0xff);\r\nsendack &= ~0x80;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, 0x00, sendack);\r\n}\r\nstatic bool wait_ack(struct ast_private *ast)\r\n{\r\nu8 waitack;\r\nu32 retry = 0;\r\ndo {\r\nwaitack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd2, 0xff);\r\nwaitack &= 0x80;\r\nudelay(100);\r\n} while ((!waitack) && (retry++ < 1000));\r\nif (retry < 1000)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool wait_nack(struct ast_private *ast)\r\n{\r\nu8 waitack;\r\nu32 retry = 0;\r\ndo {\r\nwaitack = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd2, 0xff);\r\nwaitack &= 0x80;\r\nudelay(100);\r\n} while ((waitack) && (retry++ < 1000));\r\nif (retry < 1000)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void set_cmd_trigger(struct ast_private *ast)\r\n{\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, ~0x40, 0x40);\r\n}\r\nstatic void clear_cmd_trigger(struct ast_private *ast)\r\n{\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9b, ~0x40, 0x00);\r\n}\r\nstatic bool ast_write_cmd(struct drm_device *dev, u8 data)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nint retry = 0;\r\nif (wait_nack(ast)) {\r\nsend_nack(ast);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9a, 0x00, data);\r\nsend_ack(ast);\r\nset_cmd_trigger(ast);\r\ndo {\r\nif (wait_ack(ast)) {\r\nclear_cmd_trigger(ast);\r\nsend_nack(ast);\r\nreturn true;\r\n}\r\n} while (retry++ < 100);\r\n}\r\nclear_cmd_trigger(ast);\r\nsend_nack(ast);\r\nreturn false;\r\n}\r\nstatic bool ast_write_data(struct drm_device *dev, u8 data)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nif (wait_nack(ast)) {\r\nsend_nack(ast);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x9a, 0x00, data);\r\nsend_ack(ast);\r\nif (wait_ack(ast)) {\r\nsend_nack(ast);\r\nreturn true;\r\n}\r\n}\r\nsend_nack(ast);\r\nreturn false;\r\n}\r\nvoid ast_set_dp501_video_output(struct drm_device *dev, u8 mode)\r\n{\r\nast_write_cmd(dev, 0x40);\r\nast_write_data(dev, mode);\r\nmsleep(10);\r\n}\r\nstatic u32 get_fw_base(struct ast_private *ast)\r\n{\r\nreturn ast_mindwm(ast, 0x1e6e2104) & 0x7fffffff;\r\n}\r\nbool ast_backup_fw(struct drm_device *dev, u8 *addr, u32 size)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu32 i, data;\r\nu32 boot_address;\r\ndata = ast_mindwm(ast, 0x1e6e2100) & 0x01;\r\nif (data) {\r\nboot_address = get_fw_base(ast);\r\nfor (i = 0; i < size; i += 4)\r\n*(u32 *)(addr + i) = ast_mindwm(ast, boot_address + i);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool ast_launch_m68k(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu32 i, data, len = 0;\r\nu32 boot_address;\r\nu8 *fw_addr = NULL;\r\nu8 jreg;\r\ndata = ast_mindwm(ast, 0x1e6e2100) & 0x01;\r\nif (!data) {\r\nif (ast->dp501_fw_addr) {\r\nfw_addr = ast->dp501_fw_addr;\r\nlen = 32*1024;\r\n} else if (ast->dp501_fw) {\r\nfw_addr = (u8 *)ast->dp501_fw->data;\r\nlen = ast->dp501_fw->size;\r\n}\r\nast_moutdwm(ast, 0x1e6e2000, 0x1688a8a8);\r\ndata = ast_mindwm(ast, 0x1e6e0004);\r\nswitch (data & 0x03) {\r\ncase 0:\r\nboot_address = 0x44000000;\r\nbreak;\r\ndefault:\r\ncase 1:\r\nboot_address = 0x48000000;\r\nbreak;\r\ncase 2:\r\nboot_address = 0x50000000;\r\nbreak;\r\ncase 3:\r\nboot_address = 0x60000000;\r\nbreak;\r\n}\r\nboot_address -= 0x200000;\r\nfor (i = 0; i < len; i += 4) {\r\ndata = *(u32 *)(fw_addr + i);\r\nast_moutdwm(ast, boot_address + i, data);\r\n}\r\nast_moutdwm(ast, 0x1e6e2000, 0x1688a8a8);\r\nast_moutdwm(ast, 0x1e6e2104, 0x80000000 + boot_address);\r\nast_moutdwm(ast, 0x1e6e2100, 1);\r\ndata = ast_mindwm(ast, 0x1e6e2040) & 0xfffff1ff;\r\ndata |= 0x800;\r\nast_moutdwm(ast, 0x1e6e2040, data);\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x99, 0xfc);\r\njreg |= 0x02;\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x99, jreg);\r\n}\r\nreturn true;\r\n}\r\nu8 ast_get_dp501_max_clk(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu32 boot_address, offset, data;\r\nu8 linkcap[4], linkrate, linklanes, maxclk = 0xff;\r\nboot_address = get_fw_base(ast);\r\noffset = 0xf000;\r\ndata = ast_mindwm(ast, boot_address + offset);\r\nif ((data & 0xf0) != 0x10)\r\nreturn maxclk;\r\noffset = 0xf014;\r\n*(u32 *)linkcap = ast_mindwm(ast, boot_address + offset);\r\nif (linkcap[2] == 0) {\r\nlinkrate = linkcap[0];\r\nlinklanes = linkcap[1];\r\ndata = (linkrate == 0x0a) ? (90 * linklanes) : (54 * linklanes);\r\nif (data > 0xff)\r\ndata = 0xff;\r\nmaxclk = (u8)data;\r\n}\r\nreturn maxclk;\r\n}\r\nbool ast_dp501_read_edid(struct drm_device *dev, u8 *ediddata)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu32 i, boot_address, offset, data;\r\nboot_address = get_fw_base(ast);\r\noffset = 0xf000;\r\ndata = ast_mindwm(ast, boot_address + offset);\r\nif ((data & 0xf0) != 0x10)\r\nreturn false;\r\noffset = 0xf010;\r\ndata = ast_mindwm(ast, boot_address + offset);\r\nif (!(data & 0x01))\r\nreturn false;\r\noffset = 0xf020;\r\nfor (i = 0; i < 128; i += 4) {\r\ndata = ast_mindwm(ast, boot_address + offset + i);\r\n*(u32 *)(ediddata + i) = data;\r\n}\r\nreturn true;\r\n}\r\nstatic bool ast_init_dvo(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 jreg;\r\nu32 data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x12000, 0x1688a8a8);\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\nif (!(jreg & 0x80)) {\r\ndata = ast_read32(ast, 0x12008);\r\ndata &= 0xfffff8ff;\r\ndata |= 0x00000500;\r\nast_write32(ast, 0x12008, data);\r\nif (ast->chip == AST2300) {\r\ndata = ast_read32(ast, 0x12084);\r\ndata |= 0xfffe0000;\r\nast_write32(ast, 0x12084, data);\r\ndata = ast_read32(ast, 0x12088);\r\ndata |= 0x000fffff;\r\nast_write32(ast, 0x12088, data);\r\ndata = ast_read32(ast, 0x12090);\r\ndata &= 0xffffffcf;\r\ndata |= 0x00000020;\r\nast_write32(ast, 0x12090, data);\r\n} else {\r\ndata = ast_read32(ast, 0x12088);\r\ndata |= 0x30000000;\r\nast_write32(ast, 0x12088, data);\r\ndata = ast_read32(ast, 0x1208c);\r\ndata |= 0x000000cf;\r\nast_write32(ast, 0x1208c, data);\r\ndata = ast_read32(ast, 0x120a4);\r\ndata |= 0xffff0000;\r\nast_write32(ast, 0x120a4, data);\r\ndata = ast_read32(ast, 0x120a8);\r\ndata |= 0x0000000f;\r\nast_write32(ast, 0x120a8, data);\r\ndata = ast_read32(ast, 0x12094);\r\ndata |= 0x00000002;\r\nast_write32(ast, 0x12094, data);\r\n}\r\n}\r\ndata = ast_read32(ast, 0x1202c);\r\ndata &= 0xfffbffff;\r\nast_write32(ast, 0x1202c, data);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x80);\r\nreturn true;\r\n}\r\nstatic void ast_init_analog(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu32 data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x12000, 0x1688a8a8);\r\nast_write32(ast, 0x12000, 0x1688a8a8);\r\nast_write32(ast, 0x12000, 0x1688a8a8);\r\ndata = ast_read32(ast, 0x1202c);\r\ndata &= 0xfffcffff;\r\nast_write32(ast, 0, data);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x00);\r\n}\r\nvoid ast_init_3rdtx(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 jreg;\r\nif (ast->chip == AST2300 || ast->chip == AST2400) {\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\r\nswitch (jreg & 0x0e) {\r\ncase 0x04:\r\nast_init_dvo(dev);\r\nbreak;\r\ncase 0x08:\r\nast_launch_m68k(dev);\r\nbreak;\r\ncase 0x0c:\r\nast_init_dvo(dev);\r\nbreak;\r\ndefault:\r\nif (ast->tx_chip_type == AST_TX_SIL164)\r\nast_init_dvo(dev);\r\nelse\r\nast_init_analog(dev);\r\n}\r\n}\r\n}
