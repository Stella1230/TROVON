int atl1e_check_eeprom_exist(struct atl1e_hw *hw)\r\n{\r\nu32 value;\r\nvalue = AT_READ_REG(hw, REG_SPI_FLASH_CTRL);\r\nif (value & SPI_FLASH_CTRL_EN_VPD) {\r\nvalue &= ~SPI_FLASH_CTRL_EN_VPD;\r\nAT_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\r\n}\r\nvalue = AT_READ_REGW(hw, REG_PCIE_CAP_LIST);\r\nreturn ((value & 0xFF00) == 0x6C00) ? 0 : 1;\r\n}\r\nvoid atl1e_hw_set_mac_addr(struct atl1e_hw *hw)\r\n{\r\nu32 value;\r\nvalue = (((u32)hw->mac_addr[2]) << 24) |\r\n(((u32)hw->mac_addr[3]) << 16) |\r\n(((u32)hw->mac_addr[4]) << 8) |\r\n(((u32)hw->mac_addr[5])) ;\r\nAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\r\nvalue = (((u32)hw->mac_addr[0]) << 8) |\r\n(((u32)hw->mac_addr[1])) ;\r\nAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\r\n}\r\nstatic int atl1e_get_permanent_address(struct atl1e_hw *hw)\r\n{\r\nu32 addr[2];\r\nu32 i;\r\nu32 twsi_ctrl_data;\r\nu8 eth_addr[ETH_ALEN];\r\nif (is_valid_ether_addr(hw->perm_mac_addr))\r\nreturn 0;\r\naddr[0] = addr[1] = 0;\r\nif (!atl1e_check_eeprom_exist(hw)) {\r\ntwsi_ctrl_data = AT_READ_REG(hw, REG_TWSI_CTRL);\r\ntwsi_ctrl_data |= TWSI_CTRL_SW_LDSTART;\r\nAT_WRITE_REG(hw, REG_TWSI_CTRL, twsi_ctrl_data);\r\nfor (i = 0; i < AT_TWSI_EEPROM_TIMEOUT; i++) {\r\nmsleep(10);\r\ntwsi_ctrl_data = AT_READ_REG(hw, REG_TWSI_CTRL);\r\nif ((twsi_ctrl_data & TWSI_CTRL_SW_LDSTART) == 0)\r\nbreak;\r\n}\r\nif (i >= AT_TWSI_EEPROM_TIMEOUT)\r\nreturn AT_ERR_TIMEOUT;\r\n}\r\naddr[0] = AT_READ_REG(hw, REG_MAC_STA_ADDR);\r\naddr[1] = AT_READ_REG(hw, REG_MAC_STA_ADDR + 4);\r\n*(u32 *) &eth_addr[2] = swab32(addr[0]);\r\n*(u16 *) &eth_addr[0] = swab16(*(u16 *)&addr[1]);\r\nif (is_valid_ether_addr(eth_addr)) {\r\nmemcpy(hw->perm_mac_addr, eth_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nreturn AT_ERR_EEPROM;\r\n}\r\nbool atl1e_write_eeprom(struct atl1e_hw *hw, u32 offset, u32 value)\r\n{\r\nreturn true;\r\n}\r\nbool atl1e_read_eeprom(struct atl1e_hw *hw, u32 offset, u32 *p_value)\r\n{\r\nint i;\r\nu32 control;\r\nif (offset & 3)\r\nreturn false;\r\nAT_WRITE_REG(hw, REG_VPD_DATA, 0);\r\ncontrol = (offset & VPD_CAP_VPD_ADDR_MASK) << VPD_CAP_VPD_ADDR_SHIFT;\r\nAT_WRITE_REG(hw, REG_VPD_CAP, control);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(2);\r\ncontrol = AT_READ_REG(hw, REG_VPD_CAP);\r\nif (control & VPD_CAP_VPD_FLAG)\r\nbreak;\r\n}\r\nif (control & VPD_CAP_VPD_FLAG) {\r\n*p_value = AT_READ_REG(hw, REG_VPD_DATA);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid atl1e_force_ps(struct atl1e_hw *hw)\r\n{\r\nAT_WRITE_REGW(hw, REG_GPHY_CTRL,\r\nGPHY_CTRL_PW_WOL_DIS | GPHY_CTRL_EXT_RESET);\r\n}\r\nint atl1e_read_mac_addr(struct atl1e_hw *hw)\r\n{\r\nint err = 0;\r\nerr = atl1e_get_permanent_address(hw);\r\nif (err)\r\nreturn AT_ERR_EEPROM;\r\nmemcpy(hw->mac_addr, hw->perm_mac_addr, sizeof(hw->perm_mac_addr));\r\nreturn 0;\r\n}\r\nu32 atl1e_hash_mc_addr(struct atl1e_hw *hw, u8 *mc_addr)\r\n{\r\nu32 crc32;\r\nu32 value = 0;\r\nint i;\r\ncrc32 = ether_crc_le(6, mc_addr);\r\nfor (i = 0; i < 32; i++)\r\nvalue |= (((crc32 >> i) & 1) << (31 - i));\r\nreturn value;\r\n}\r\nvoid atl1e_hash_set(struct atl1e_hw *hw, u32 hash_value)\r\n{\r\nu32 hash_bit, hash_reg;\r\nu32 mta;\r\nhash_reg = (hash_value >> 31) & 0x1;\r\nhash_bit = (hash_value >> 26) & 0x1F;\r\nmta = AT_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\r\nmta |= (1 << hash_bit);\r\nAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\r\n}\r\nint atl1e_read_phy_reg(struct atl1e_hw *hw, u16 reg_addr, u16 *phy_data)\r\n{\r\nu32 val;\r\nint i;\r\nval = ((u32)(reg_addr & MDIO_REG_ADDR_MASK)) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_START | MDIO_SUP_PREAMBLE | MDIO_RW |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nwmb();\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nval = AT_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\nwmb();\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY))) {\r\n*phy_data = (u16)val;\r\nreturn 0;\r\n}\r\nreturn AT_ERR_PHY;\r\n}\r\nint atl1e_write_phy_reg(struct atl1e_hw *hw, u32 reg_addr, u16 phy_data)\r\n{\r\nint i;\r\nu32 val;\r\nval = ((u32)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |\r\n(reg_addr&MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_SUP_PREAMBLE |\r\nMDIO_START |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nwmb();\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nval = AT_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\nwmb();\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nreturn 0;\r\nreturn AT_ERR_PHY;\r\n}\r\nstatic void atl1e_init_pcie(struct atl1e_hw *hw)\r\n{\r\nu32 value;\r\nvalue = AT_READ_REG(hw, 0x1008);\r\nvalue |= 0x8000;\r\nAT_WRITE_REG(hw, 0x1008, value);\r\n}\r\nstatic int atl1e_phy_setup_autoneg_adv(struct atl1e_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 mii_autoneg_adv_reg;\r\nu16 mii_1000t_ctrl_reg;\r\nif (0 != hw->mii_autoneg_adv_reg)\r\nreturn 0;\r\nmii_autoneg_adv_reg = MII_AR_DEFAULT_CAP_MASK;\r\nmii_1000t_ctrl_reg = MII_AT001_CR_1000T_DEFAULT_CAP_MASK;\r\nmii_autoneg_adv_reg &= ~ADVERTISE_ALL;\r\nmii_1000t_ctrl_reg &= ~MII_AT001_CR_1000T_SPEED_MASK;\r\nswitch (hw->media_type) {\r\ncase MEDIA_TYPE_AUTO_SENSOR:\r\nmii_autoneg_adv_reg |= ADVERTISE_ALL;\r\nhw->autoneg_advertised = ADVERTISE_ALL;\r\nif (hw->nic_type == athr_l1e) {\r\nmii_1000t_ctrl_reg |= ADVERTISE_1000FULL;\r\nhw->autoneg_advertised |= ADVERTISE_1000_FULL;\r\n}\r\nbreak;\r\ncase MEDIA_TYPE_100M_FULL:\r\nmii_autoneg_adv_reg |= ADVERTISE_100FULL;\r\nhw->autoneg_advertised = ADVERTISE_100_FULL;\r\nbreak;\r\ncase MEDIA_TYPE_100M_HALF:\r\nmii_autoneg_adv_reg |= ADVERTISE_100_HALF;\r\nhw->autoneg_advertised = ADVERTISE_100_HALF;\r\nbreak;\r\ncase MEDIA_TYPE_10M_FULL:\r\nmii_autoneg_adv_reg |= ADVERTISE_10_FULL;\r\nhw->autoneg_advertised = ADVERTISE_10_FULL;\r\nbreak;\r\ndefault:\r\nmii_autoneg_adv_reg |= ADVERTISE_10_HALF;\r\nhw->autoneg_advertised = ADVERTISE_10_HALF;\r\nbreak;\r\n}\r\nmii_autoneg_adv_reg |= (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\r\nhw->mii_autoneg_adv_reg = mii_autoneg_adv_reg;\r\nhw->mii_1000t_ctrl_reg = mii_1000t_ctrl_reg;\r\nret_val = atl1e_write_phy_reg(hw, MII_ADVERTISE, mii_autoneg_adv_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->nic_type == athr_l1e || hw->nic_type == athr_l2e_revA) {\r\nret_val = atl1e_write_phy_reg(hw, MII_CTRL1000,\r\nmii_1000t_ctrl_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn 0;\r\n}\r\nint atl1e_phy_commit(struct atl1e_hw *hw)\r\n{\r\nstruct atl1e_adapter *adapter = hw->adapter;\r\nint ret_val;\r\nu16 phy_data;\r\nphy_data = BMCR_RESET | BMCR_ANENABLE | BMCR_ANRESTART;\r\nret_val = atl1e_write_phy_reg(hw, MII_BMCR, phy_data);\r\nif (ret_val) {\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < 25; i++) {\r\nmsleep(1);\r\nval = AT_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\n}\r\nif (0 != (val & (MDIO_START | MDIO_BUSY))) {\r\nnetdev_err(adapter->netdev,\r\n"pcie linkdown at least for 25ms\n");\r\nreturn ret_val;\r\n}\r\nnetdev_err(adapter->netdev, "pcie linkup after %d ms\n", i);\r\n}\r\nreturn 0;\r\n}\r\nint atl1e_phy_init(struct atl1e_hw *hw)\r\n{\r\nstruct atl1e_adapter *adapter = hw->adapter;\r\ns32 ret_val;\r\nu16 phy_val;\r\nif (hw->phy_configured) {\r\nif (hw->re_autoneg) {\r\nhw->re_autoneg = false;\r\nreturn atl1e_restart_autoneg(hw);\r\n}\r\nreturn 0;\r\n}\r\nAT_WRITE_REGW(hw, REG_GPHY_CTRL, GPHY_CTRL_DEFAULT);\r\nmsleep(2);\r\nAT_WRITE_REGW(hw, REG_GPHY_CTRL, GPHY_CTRL_DEFAULT |\r\nGPHY_CTRL_EXT_RESET);\r\nmsleep(2);\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0xB);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0xBC00);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_val = 0x02ef;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, phy_val);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x12);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x4C04);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x4);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x8BBB);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x5);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x2C46);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(1);\r\nret_val = atl1e_write_phy_reg(hw, MII_INT_CTRL, 0xC00);\r\nif (ret_val) {\r\nnetdev_err(adapter->netdev,\r\n"Error enable PHY linkChange Interrupt\n");\r\nreturn ret_val;\r\n}\r\nret_val = atl1e_phy_setup_autoneg_adv(hw);\r\nif (ret_val) {\r\nnetdev_err(adapter->netdev,\r\n"Error Setting up Auto-Negotiation\n");\r\nreturn ret_val;\r\n}\r\nnetdev_dbg(adapter->netdev, "Restarting Auto-Negotiation\n");\r\nret_val = atl1e_phy_commit(hw);\r\nif (ret_val) {\r\nnetdev_err(adapter->netdev, "Error resetting the phy\n");\r\nreturn ret_val;\r\n}\r\nhw->phy_configured = true;\r\nreturn 0;\r\n}\r\nint atl1e_reset_hw(struct atl1e_hw *hw)\r\n{\r\nstruct atl1e_adapter *adapter = hw->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 idle_status_data = 0;\r\nu16 pci_cfg_cmd_word = 0;\r\nint timeout = 0;\r\npci_read_config_word(pdev, PCI_REG_COMMAND, &pci_cfg_cmd_word);\r\nif ((pci_cfg_cmd_word & (CMD_IO_SPACE |\r\nCMD_MEMORY_SPACE | CMD_BUS_MASTER))\r\n!= (CMD_IO_SPACE | CMD_MEMORY_SPACE | CMD_BUS_MASTER)) {\r\npci_cfg_cmd_word |= (CMD_IO_SPACE |\r\nCMD_MEMORY_SPACE | CMD_BUS_MASTER);\r\npci_write_config_word(pdev, PCI_REG_COMMAND, pci_cfg_cmd_word);\r\n}\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL,\r\nMASTER_CTRL_LED_MODE | MASTER_CTRL_SOFT_RST);\r\nwmb();\r\nmsleep(1);\r\nfor (timeout = 0; timeout < AT_HW_MAX_IDLE_DELAY; timeout++) {\r\nidle_status_data = AT_READ_REG(hw, REG_IDLE_STATUS);\r\nif (idle_status_data == 0)\r\nbreak;\r\nmsleep(1);\r\ncpu_relax();\r\n}\r\nif (timeout >= AT_HW_MAX_IDLE_DELAY) {\r\nnetdev_err(adapter->netdev,\r\n"MAC state machine can't be idle since disabled for 10ms second\n");\r\nreturn AT_ERR_TIMEOUT;\r\n}\r\nreturn 0;\r\n}\r\nint atl1e_init_hw(struct atl1e_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\natl1e_init_pcie(hw);\r\nAT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\r\nAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\r\nret_val = atl1e_phy_init(hw);\r\nreturn ret_val;\r\n}\r\nint atl1e_get_speed_and_duplex(struct atl1e_hw *hw, u16 *speed, u16 *duplex)\r\n{\r\nint err;\r\nu16 phy_data;\r\nerr = atl1e_read_phy_reg(hw, MII_AT001_PSSR, &phy_data);\r\nif (err)\r\nreturn err;\r\nif (!(phy_data & MII_AT001_PSSR_SPD_DPLX_RESOLVED))\r\nreturn AT_ERR_PHY_RES;\r\nswitch (phy_data & MII_AT001_PSSR_SPEED) {\r\ncase MII_AT001_PSSR_1000MBS:\r\n*speed = SPEED_1000;\r\nbreak;\r\ncase MII_AT001_PSSR_100MBS:\r\n*speed = SPEED_100;\r\nbreak;\r\ncase MII_AT001_PSSR_10MBS:\r\n*speed = SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn AT_ERR_PHY_SPEED;\r\n}\r\nif (phy_data & MII_AT001_PSSR_DPLX)\r\n*duplex = FULL_DUPLEX;\r\nelse\r\n*duplex = HALF_DUPLEX;\r\nreturn 0;\r\n}\r\nint atl1e_restart_autoneg(struct atl1e_hw *hw)\r\n{\r\nint err = 0;\r\nerr = atl1e_write_phy_reg(hw, MII_ADVERTISE, hw->mii_autoneg_adv_reg);\r\nif (err)\r\nreturn err;\r\nif (hw->nic_type == athr_l1e || hw->nic_type == athr_l2e_revA) {\r\nerr = atl1e_write_phy_reg(hw, MII_CTRL1000,\r\nhw->mii_1000t_ctrl_reg);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = atl1e_write_phy_reg(hw, MII_BMCR,\r\nBMCR_RESET | BMCR_ANENABLE | BMCR_ANRESTART);\r\nreturn err;\r\n}
