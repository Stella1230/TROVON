static void\r\nlpfc_jedec_to_ascii(int incr, char hdw[])\r\n{\r\nint i, j;\r\nfor (i = 0; i < 8; i++) {\r\nj = (incr & 0xf);\r\nif (j <= 9)\r\nhdw[7 - i] = 0x30 + j;\r\nelse\r\nhdw[7 - i] = 0x61 + j - 10;\r\nincr = (incr >> 4);\r\n}\r\nhdw[8] = 0;\r\nreturn;\r\n}\r\nstatic ssize_t\r\nlpfc_drvr_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, LPFC_MODULE_DESC "\n");\r\n}\r\nstatic ssize_t\r\nlpfc_enable_fip_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (phba->hba_flag & HBA_FIP_SUPPORT)\r\nreturn snprintf(buf, PAGE_SIZE, "1\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "0\n");\r\n}\r\nstatic ssize_t\r\nlpfc_bg_info_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (phba->cfg_enable_bg)\r\nif (phba->sli3_options & LPFC_SLI3_BG_ENABLED)\r\nreturn snprintf(buf, PAGE_SIZE, "BlockGuard Enabled\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"BlockGuard Not Supported\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"BlockGuard Disabled\n");\r\n}\r\nstatic ssize_t\r\nlpfc_bg_guard_err_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n",\r\n(unsigned long long)phba->bg_guard_err_cnt);\r\n}\r\nstatic ssize_t\r\nlpfc_bg_apptag_err_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n",\r\n(unsigned long long)phba->bg_apptag_err_cnt);\r\n}\r\nstatic ssize_t\r\nlpfc_bg_reftag_err_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n",\r\n(unsigned long long)phba->bg_reftag_err_cnt);\r\n}\r\nstatic ssize_t\r\nlpfc_info_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",lpfc_info(host));\r\n}\r\nstatic ssize_t\r\nlpfc_serialnum_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",phba->SerialNumber);\r\n}\r\nstatic ssize_t\r\nlpfc_temp_sensor_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",phba->temp_sensor_support);\r\n}\r\nstatic ssize_t\r\nlpfc_modeldesc_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",phba->ModelDesc);\r\n}\r\nstatic ssize_t\r\nlpfc_modelname_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",phba->ModelName);\r\n}\r\nstatic ssize_t\r\nlpfc_programtype_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",phba->ProgramType);\r\n}\r\nstatic ssize_t\r\nlpfc_mlomgmt_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\n(phba->sli.sli_flag & LPFC_MENLO_MAINT));\r\n}\r\nstatic ssize_t\r\nlpfc_vportnum_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",phba->Port);\r\n}\r\nstatic ssize_t\r\nlpfc_fwrev_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t if_type;\r\nuint8_t sli_family;\r\nchar fwrev[FW_REV_STR_SIZE];\r\nint len;\r\nlpfc_decode_firmware_rev(phba, fwrev, 1);\r\nif_type = phba->sli4_hba.pc_sli4_params.if_type;\r\nsli_family = phba->sli4_hba.pc_sli4_params.sli_family;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nlen = snprintf(buf, PAGE_SIZE, "%s, sli-%d\n",\r\nfwrev, phba->sli_rev);\r\nelse\r\nlen = snprintf(buf, PAGE_SIZE, "%s, sli-%d:%d:%x\n",\r\nfwrev, phba->sli_rev, if_type, sli_family);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nlpfc_hdw_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar hdw[9];\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nlpfc_jedec_to_ascii(vp->rev.biuRev, hdw);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", hdw);\r\n}\r\nstatic ssize_t\r\nlpfc_option_rom_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", phba->OptionROMVersion);\r\n}\r\nstatic ssize_t\r\nlpfc_link_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint len = 0;\r\nswitch (phba->link_state) {\r\ncase LPFC_LINK_UNKNOWN:\r\ncase LPFC_WARM_START:\r\ncase LPFC_INIT_START:\r\ncase LPFC_INIT_MBX_CMDS:\r\ncase LPFC_LINK_DOWN:\r\ncase LPFC_HBA_ERROR:\r\nif (phba->hba_flag & LINK_DISABLED)\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"Link Down - User disabled\n");\r\nelse\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"Link Down\n");\r\nbreak;\r\ncase LPFC_LINK_UP:\r\ncase LPFC_CLEAR_LA:\r\ncase LPFC_HBA_READY:\r\nlen += snprintf(buf + len, PAGE_SIZE-len, "Link Up - ");\r\nswitch (vport->port_state) {\r\ncase LPFC_LOCAL_CFG_LINK:\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"Configuring Link\n");\r\nbreak;\r\ncase LPFC_FDISC:\r\ncase LPFC_FLOGI:\r\ncase LPFC_FABRIC_CFG_LINK:\r\ncase LPFC_NS_REG:\r\ncase LPFC_NS_QRY:\r\ncase LPFC_BUILD_DISC_LIST:\r\ncase LPFC_DISC_AUTH:\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"Discovery\n");\r\nbreak;\r\ncase LPFC_VPORT_READY:\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "Ready\n");\r\nbreak;\r\ncase LPFC_VPORT_FAILED:\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "Failed\n");\r\nbreak;\r\ncase LPFC_VPORT_UNKNOWN:\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"Unknown\n");\r\nbreak;\r\n}\r\nif (phba->sli.sli_flag & LPFC_MENLO_MAINT)\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n" Menlo Maint Mode\n");\r\nelse if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nif (vport->fc_flag & FC_PUBLIC_LOOP)\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n" Public Loop\n");\r\nelse\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n" Private Loop\n");\r\n} else {\r\nif (vport->fc_flag & FC_FABRIC)\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n" Fabric\n");\r\nelse\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n" Point-2-Point\n");\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nlpfc_sli4_protocol_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nreturn snprintf(buf, PAGE_SIZE, "fc\n");\r\nif (phba->sli4_hba.lnk_info.lnk_dv == LPFC_LNK_DAT_VAL) {\r\nif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_GE)\r\nreturn snprintf(buf, PAGE_SIZE, "fcoe\n");\r\nif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC)\r\nreturn snprintf(buf, PAGE_SIZE, "fc\n");\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_oas_supported_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nphba->sli4_hba.pc_sli4_params.oas_supported);\r\n}\r\nstatic ssize_t\r\nlpfc_link_state_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint status = -EINVAL;\r\nif ((strncmp(buf, "up", sizeof("up") - 1) == 0) &&\r\n(phba->link_state == LPFC_LINK_DOWN))\r\nstatus = phba->lpfc_hba_init_link(phba, MBX_NOWAIT);\r\nelse if ((strncmp(buf, "down", sizeof("down") - 1) == 0) &&\r\n(phba->link_state >= LPFC_LINK_UP))\r\nstatus = phba->lpfc_hba_down_link(phba, MBX_NOWAIT);\r\nif (status == 0)\r\nreturn strlen(buf);\r\nelse\r\nreturn status;\r\n}\r\nstatic ssize_t\r\nlpfc_num_discovered_ports_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nvport->fc_map_cnt + vport->fc_unmap_cnt);\r\n}\r\nstatic int\r\nlpfc_issue_lip(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *pmboxq;\r\nint mbxstatus = MBXERR_ERROR;\r\nif ((vport->fc_flag & FC_OFFLINE_MODE) ||\r\n(phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO))\r\nreturn -EPERM;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool,GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn -ENOMEM;\r\nmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\r\npmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;\r\npmboxq->u.mb.mbxOwner = OWN_HOST;\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO * 2);\r\nif ((mbxstatus == MBX_SUCCESS) &&\r\n(pmboxq->u.mb.mbxStatus == 0 ||\r\npmboxq->u.mb.mbxStatus == MBXERR_LINK_DOWN)) {\r\nmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\r\nlpfc_init_link(phba, pmboxq, phba->cfg_topology,\r\nphba->cfg_link_speed);\r\nmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,\r\nphba->fc_ratov * 2);\r\nif ((mbxstatus == MBX_SUCCESS) &&\r\n(pmboxq->u.mb.mbxStatus == MBXERR_SEC_NO_PERMISSION))\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,\r\n"2859 SLI authentication is required "\r\n"for INIT_LINK but has not done yet\n");\r\n}\r\nlpfc_set_loopback_flag(phba);\r\nif (mbxstatus != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nif (mbxstatus == MBXERR_ERROR)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_do_offline(struct lpfc_hba *phba, uint32_t type)\r\n{\r\nstruct completion online_compl;\r\nstruct lpfc_sli_ring *pring;\r\nstruct lpfc_sli *psli;\r\nint status = 0;\r\nint cnt = 0;\r\nint i;\r\nint rc;\r\ninit_completion(&online_compl);\r\nrc = lpfc_workq_post_event(phba, &status, &online_compl,\r\nLPFC_EVT_OFFLINE_PREP);\r\nif (rc == 0)\r\nreturn -ENOMEM;\r\nwait_for_completion(&online_compl);\r\nif (status != 0)\r\nreturn -EIO;\r\npsli = &phba->sli;\r\nfor (i = 0; i < psli->num_rings; i++) {\r\npring = &psli->ring[i];\r\nwhile (!list_empty(&pring->txcmplq)) {\r\nmsleep(10);\r\nif (cnt++ > 500) {\r\nlpfc_printf_log(phba,\r\nKERN_WARNING, LOG_INIT,\r\n"0466 Outstanding IO when "\r\n"bringing Adapter offline\n");\r\nbreak;\r\n}\r\n}\r\n}\r\ninit_completion(&online_compl);\r\nrc = lpfc_workq_post_event(phba, &status, &online_compl, type);\r\nif (rc == 0)\r\nreturn -ENOMEM;\r\nwait_for_completion(&online_compl);\r\nif (status != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint\r\nlpfc_selective_reset(struct lpfc_hba *phba)\r\n{\r\nstruct completion online_compl;\r\nint status = 0;\r\nint rc;\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn -EACCES;\r\nif (!(phba->pport->fc_flag & FC_OFFLINE_MODE)) {\r\nstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\r\nif (status != 0)\r\nreturn status;\r\n}\r\ninit_completion(&online_compl);\r\nrc = lpfc_workq_post_event(phba, &status, &online_compl,\r\nLPFC_EVT_ONLINE);\r\nif (rc == 0)\r\nreturn -ENOMEM;\r\nwait_for_completion(&online_compl);\r\nif (status != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlpfc_issue_reset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint status = -EINVAL;\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn -EACCES;\r\nif (strncmp(buf, "selective", sizeof("selective") - 1) == 0)\r\nstatus = phba->lpfc_selective_reset(phba);\r\nif (status == 0)\r\nreturn strlen(buf);\r\nelse\r\nreturn status;\r\n}\r\nint\r\nlpfc_sli4_pdev_status_reg_wait(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_register portstat_reg = {0};\r\nint i;\r\nmsleep(100);\r\nlpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\r\n&portstat_reg.word0);\r\nif (!bf_get(lpfc_sliport_status_rn, &portstat_reg) &&\r\n!bf_get(lpfc_sliport_status_err, &portstat_reg))\r\nreturn -EPERM;\r\nfor (i = 0; i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT; i++) {\r\nmsleep(10);\r\nlpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\r\n&portstat_reg.word0);\r\nif (!bf_get(lpfc_sliport_status_err, &portstat_reg))\r\ncontinue;\r\nif (!bf_get(lpfc_sliport_status_rn, &portstat_reg))\r\ncontinue;\r\nif (!bf_get(lpfc_sliport_status_rdy, &portstat_reg))\r\ncontinue;\r\nbreak;\r\n}\r\nif (i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic ssize_t\r\nlpfc_sli4_pdev_reg_request(struct lpfc_hba *phba, uint32_t opcode)\r\n{\r\nstruct completion online_compl;\r\nstruct pci_dev *pdev = phba->pcidev;\r\nuint32_t before_fc_flag;\r\nuint32_t sriov_nr_virtfn;\r\nuint32_t reg_val;\r\nint status = 0, rc = 0;\r\nint job_posted = 1, sriov_err;\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn -EACCES;\r\nif ((phba->sli_rev < LPFC_SLI_REV4) ||\r\n(bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\r\nLPFC_SLI_INTF_IF_TYPE_2))\r\nreturn -EPERM;\r\nbefore_fc_flag = phba->pport->fc_flag;\r\nsriov_nr_virtfn = phba->cfg_sriov_nr_virtfn;\r\nif (phba->cfg_sriov_nr_virtfn) {\r\npci_disable_sriov(pdev);\r\nphba->cfg_sriov_nr_virtfn = 0;\r\n}\r\nif (opcode == LPFC_FW_DUMP)\r\nphba->hba_flag |= HBA_FW_DUMP_OP;\r\nstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\r\nif (status != 0) {\r\nphba->hba_flag &= ~HBA_FW_DUMP_OP;\r\nreturn status;\r\n}\r\nmsleep(100);\r\nreg_val = readl(phba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PDEV_CTL_OFFSET);\r\nif (opcode == LPFC_FW_DUMP)\r\nreg_val |= LPFC_FW_DUMP_REQUEST;\r\nelse if (opcode == LPFC_FW_RESET)\r\nreg_val |= LPFC_CTL_PDEV_CTL_FRST;\r\nelse if (opcode == LPFC_DV_RESET)\r\nreg_val |= LPFC_CTL_PDEV_CTL_DRST;\r\nwritel(reg_val, phba->sli4_hba.conf_regs_memmap_p +\r\nLPFC_CTL_PDEV_CTL_OFFSET);\r\nreadl(phba->sli4_hba.conf_regs_memmap_p + LPFC_CTL_PDEV_CTL_OFFSET);\r\nrc = lpfc_sli4_pdev_status_reg_wait(phba);\r\nif (rc == -EPERM) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"3150 No privilege to perform the requested "\r\n"access: x%x\n", reg_val);\r\n} else if (rc == -EIO) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\r\n"3153 Fail to perform the requested "\r\n"access: x%x\n", reg_val);\r\nreturn rc;\r\n}\r\nif (before_fc_flag & FC_OFFLINE_MODE)\r\ngoto out;\r\ninit_completion(&online_compl);\r\njob_posted = lpfc_workq_post_event(phba, &status, &online_compl,\r\nLPFC_EVT_ONLINE);\r\nif (!job_posted)\r\ngoto out;\r\nwait_for_completion(&online_compl);\r\nout:\r\nif (sriov_nr_virtfn) {\r\nsriov_err =\r\nlpfc_sli_probe_sriov_nr_virtfn(phba, sriov_nr_virtfn);\r\nif (!sriov_err)\r\nphba->cfg_sriov_nr_virtfn = sriov_nr_virtfn;\r\n}\r\nif (!rc) {\r\nif (!job_posted)\r\nrc = -ENOMEM;\r\nelse if (status)\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nlpfc_nport_evt_cnt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->nport_event_cnt);\r\n}\r\nstatic ssize_t\r\nlpfc_board_mode_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nchar * state;\r\nif (phba->link_state == LPFC_HBA_ERROR)\r\nstate = "error";\r\nelse if (phba->link_state == LPFC_WARM_START)\r\nstate = "warm start";\r\nelse if (phba->link_state == LPFC_INIT_START)\r\nstate = "offline";\r\nelse\r\nstate = "online";\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", state);\r\n}\r\nstatic ssize_t\r\nlpfc_board_mode_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct completion online_compl;\r\nchar *board_mode_str = NULL;\r\nint status = 0;\r\nint rc;\r\nif (!phba->cfg_enable_hba_reset) {\r\nstatus = -EACCES;\r\ngoto board_mode_out;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3050 lpfc_board_mode set to %s\n", buf);\r\ninit_completion(&online_compl);\r\nif(strncmp(buf, "online", sizeof("online") - 1) == 0) {\r\nrc = lpfc_workq_post_event(phba, &status, &online_compl,\r\nLPFC_EVT_ONLINE);\r\nif (rc == 0) {\r\nstatus = -ENOMEM;\r\ngoto board_mode_out;\r\n}\r\nwait_for_completion(&online_compl);\r\n} else if (strncmp(buf, "offline", sizeof("offline") - 1) == 0)\r\nstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\r\nelse if (strncmp(buf, "warm", sizeof("warm") - 1) == 0)\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nstatus = -EINVAL;\r\nelse\r\nstatus = lpfc_do_offline(phba, LPFC_EVT_WARM_START);\r\nelse if (strncmp(buf, "error", sizeof("error") - 1) == 0)\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nstatus = -EINVAL;\r\nelse\r\nstatus = lpfc_do_offline(phba, LPFC_EVT_KILL);\r\nelse if (strncmp(buf, "dump", sizeof("dump") - 1) == 0)\r\nstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_DUMP);\r\nelse if (strncmp(buf, "fw_reset", sizeof("fw_reset") - 1) == 0)\r\nstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_RESET);\r\nelse if (strncmp(buf, "dv_reset", sizeof("dv_reset") - 1) == 0)\r\nstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_DV_RESET);\r\nelse\r\nstatus = -EINVAL;\r\nboard_mode_out:\r\nif (!status)\r\nreturn strlen(buf);\r\nelse {\r\nboard_mode_str = strchr(buf, '\n');\r\nif (board_mode_str)\r\n*board_mode_str = '\0';\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3097 Failed \"%s\", status(%d), "\r\n"fc_flag(x%x)\n",\r\nbuf, status, phba->pport->fc_flag);\r\nreturn status;\r\n}\r\n}\r\nstatic int\r\nlpfc_get_hba_info(struct lpfc_hba *phba,\r\nuint32_t *mxri, uint32_t *axri,\r\nuint32_t *mrpi, uint32_t *arpi,\r\nuint32_t *mvpi, uint32_t *avpi)\r\n{\r\nstruct lpfc_mbx_read_config *rd_config;\r\nLPFC_MBOXQ_t *pmboxq;\r\nMAILBOX_t *pmb;\r\nint rc = 0;\r\nuint32_t max_vpi;\r\nif (phba->link_state < LPFC_LINK_DOWN ||\r\n!phba->mbox_mem_pool ||\r\n(phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\r\nreturn 0;\r\nif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\r\nreturn 0;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn 0;\r\nmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\r\npmb = &pmboxq->u.mb;\r\npmb->mbxCommand = MBX_READ_CONFIG;\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->context1 = NULL;\r\nif (phba->pport->fc_flag & FC_OFFLINE_MODE)\r\nrc = MBX_NOT_FINISHED;\r\nelse\r\nrc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\r\nif (rc != MBX_SUCCESS) {\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn 0;\r\n}\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nrd_config = &pmboxq->u.mqe.un.rd_config;\r\nif (mrpi)\r\n*mrpi = bf_get(lpfc_mbx_rd_conf_rpi_count, rd_config);\r\nif (arpi)\r\n*arpi = bf_get(lpfc_mbx_rd_conf_rpi_count, rd_config) -\r\nphba->sli4_hba.max_cfg_param.rpi_used;\r\nif (mxri)\r\n*mxri = bf_get(lpfc_mbx_rd_conf_xri_count, rd_config);\r\nif (axri)\r\n*axri = bf_get(lpfc_mbx_rd_conf_xri_count, rd_config) -\r\nphba->sli4_hba.max_cfg_param.xri_used;\r\nmax_vpi = (bf_get(lpfc_mbx_rd_conf_vpi_count, rd_config) > 0) ?\r\n(bf_get(lpfc_mbx_rd_conf_vpi_count, rd_config) - 1) : 0;\r\nif (mvpi)\r\n*mvpi = max_vpi;\r\nif (avpi)\r\n*avpi = max_vpi - phba->sli4_hba.max_cfg_param.vpi_used;\r\n} else {\r\nif (mrpi)\r\n*mrpi = pmb->un.varRdConfig.max_rpi;\r\nif (arpi)\r\n*arpi = pmb->un.varRdConfig.avail_rpi;\r\nif (mxri)\r\n*mxri = pmb->un.varRdConfig.max_xri;\r\nif (axri)\r\n*axri = pmb->un.varRdConfig.avail_xri;\r\nif (mvpi)\r\n*mvpi = pmb->un.varRdConfig.max_vpi;\r\nif (avpi)\r\n*avpi = pmb->un.varRdConfig.avail_vpi;\r\n}\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn 1;\r\n}\r\nstatic ssize_t\r\nlpfc_max_rpi_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt;\r\nif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, NULL, NULL, NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", cnt);\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_used_rpi_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt, acnt;\r\nif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, &acnt, NULL, NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", (cnt - acnt));\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_max_xri_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt;\r\nif (lpfc_get_hba_info(phba, &cnt, NULL, NULL, NULL, NULL, NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", cnt);\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_used_xri_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt, acnt;\r\nif (lpfc_get_hba_info(phba, &cnt, &acnt, NULL, NULL, NULL, NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", (cnt - acnt));\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_max_vpi_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt;\r\nif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, NULL))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", cnt);\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_used_vpi_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t cnt, acnt;\r\nif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, &acnt))\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", (cnt - acnt));\r\nreturn snprintf(buf, PAGE_SIZE, "Unknown\n");\r\n}\r\nstatic ssize_t\r\nlpfc_npiv_info_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (!(phba->max_vpi))\r\nreturn snprintf(buf, PAGE_SIZE, "NPIV Not Supported\n");\r\nif (vport->port_type == LPFC_PHYSICAL_PORT)\r\nreturn snprintf(buf, PAGE_SIZE, "NPIV Physical\n");\r\nreturn snprintf(buf, PAGE_SIZE, "NPIV Virtual (VPI %d)\n", vport->vpi);\r\n}\r\nstatic ssize_t\r\nlpfc_poll_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%#x\n", phba->cfg_poll);\r\n}\r\nstatic ssize_t\r\nlpfc_poll_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t creg_val;\r\nuint32_t old_val;\r\nint val=0;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif ((val & 0x3) != val)\r\nreturn -EINVAL;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nval = 0;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3051 lpfc_poll changed from %d to %d\n",\r\nphba->cfg_poll, val);\r\nspin_lock_irq(&phba->hbalock);\r\nold_val = phba->cfg_poll;\r\nif (val & ENABLE_FCP_RING_POLLING) {\r\nif ((val & DISABLE_FCP_RING_INT) &&\r\n!(old_val & DISABLE_FCP_RING_INT)) {\r\nif (lpfc_readl(phba->HCregaddr, &creg_val)) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn -EINVAL;\r\n}\r\ncreg_val &= ~(HC_R0INT_ENA << LPFC_FCP_RING);\r\nwritel(creg_val, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\nlpfc_poll_start_timer(phba);\r\n}\r\n} else if (val != 0x0) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn -EINVAL;\r\n}\r\nif (!(val & DISABLE_FCP_RING_INT) &&\r\n(old_val & DISABLE_FCP_RING_INT))\r\n{\r\nspin_unlock_irq(&phba->hbalock);\r\ndel_timer(&phba->fcp_poll_timer);\r\nspin_lock_irq(&phba->hbalock);\r\nif (lpfc_readl(phba->HCregaddr, &creg_val)) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn -EINVAL;\r\n}\r\ncreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\r\nwritel(creg_val, phba->HCregaddr);\r\nreadl(phba->HCregaddr);\r\n}\r\nphba->cfg_poll = val;\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nlpfc_fips_level_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->fips_level);\r\n}\r\nstatic ssize_t\r\nlpfc_fips_rev_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->fips_spec_rev);\r\n}\r\nstatic ssize_t\r\nlpfc_dss_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%s - %sOperational\n",\r\n(phba->cfg_enable_dss) ? "Enabled" : "Disabled",\r\n(phba->sli3_options & LPFC_SLI3_DSS_ENABLED) ?\r\n"" : "Not ");\r\n}\r\nstatic ssize_t\r\nlpfc_sriov_hw_max_virtfn_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint16_t max_nr_virtfn;\r\nmax_nr_virtfn = lpfc_sli_sriov_nr_virtfn_get(phba);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", max_nr_virtfn);\r\n}\r\nstatic size_t\r\nlpfc_wwn_set(const char *buf, size_t cnt, char wwn[])\r\n{\r\nunsigned int i, j;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif ((cnt < 16) || (cnt > 18) || ((cnt == 17) && (*buf++ != 'x')) ||\r\n((cnt == 18) && ((*buf++ != '0') || (*buf++ != 'x'))))\r\nreturn -EINVAL;\r\nmemset(wwn, 0, WWN_SZ);\r\nfor (i = 0, j = 0; i < 16; i++) {\r\nif ((*buf >= 'a') && (*buf <= 'f'))\r\nj = ((j << 4) | ((*buf++ - 'a') + 10));\r\nelse if ((*buf >= 'A') && (*buf <= 'F'))\r\nj = ((j << 4) | ((*buf++ - 'A') + 10));\r\nelse if ((*buf >= '0') && (*buf <= '9'))\r\nj = ((j << 4) | (*buf++ - '0'));\r\nelse\r\nreturn -EINVAL;\r\nif (i % 2) {\r\nwwn[i/2] = j & 0xff;\r\nj = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlpfc_soft_wwn_enable_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nunsigned int cnt = count;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif ((cnt != strlen(lpfc_soft_wwn_key)) ||\r\n(strncmp(buf, lpfc_soft_wwn_key, strlen(lpfc_soft_wwn_key)) != 0))\r\nreturn -EINVAL;\r\nphba->soft_wwn_enable = 1;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlpfc_soft_wwpn_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%llx\n",\r\n(unsigned long long)phba->cfg_soft_wwpn);\r\n}\r\nstatic ssize_t\r\nlpfc_soft_wwpn_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct completion online_compl;\r\nint stat1 = 0, stat2 = 0;\r\nunsigned int cnt = count;\r\nu8 wwpn[WWN_SZ];\r\nint rc;\r\nif (!phba->cfg_enable_hba_reset)\r\nreturn -EACCES;\r\nspin_lock_irq(&phba->hbalock);\r\nif (phba->over_temp_state == HBA_OVER_TEMP) {\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn -EACCES;\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif (!phba->soft_wwn_enable)\r\nreturn -EINVAL;\r\nphba->soft_wwn_enable = 0;\r\nrc = lpfc_wwn_set(buf, cnt, wwpn);\r\nif (!rc) {\r\nphba->soft_wwn_enable = 1;\r\nreturn rc;\r\n}\r\nphba->cfg_soft_wwpn = wwn_to_u64(wwpn);\r\nfc_host_port_name(shost) = phba->cfg_soft_wwpn;\r\nif (phba->cfg_soft_wwnn)\r\nfc_host_node_name(shost) = phba->cfg_soft_wwnn;\r\ndev_printk(KERN_NOTICE, &phba->pcidev->dev,\r\n"lpfc%d: Reinitializing to use soft_wwpn\n", phba->brd_no);\r\nstat1 = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\r\nif (stat1)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0463 lpfc_soft_wwpn attribute set failed to "\r\n"reinit adapter - %d\n", stat1);\r\ninit_completion(&online_compl);\r\nrc = lpfc_workq_post_event(phba, &stat2, &online_compl,\r\nLPFC_EVT_ONLINE);\r\nif (rc == 0)\r\nreturn -ENOMEM;\r\nwait_for_completion(&online_compl);\r\nif (stat2)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0464 lpfc_soft_wwpn attribute set failed to "\r\n"reinit adapter - %d\n", stat2);\r\nreturn (stat1 || stat2) ? -EIO : count;\r\n}\r\nstatic ssize_t\r\nlpfc_soft_wwnn_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%llx\n",\r\n(unsigned long long)phba->cfg_soft_wwnn);\r\n}\r\nstatic ssize_t\r\nlpfc_soft_wwnn_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nunsigned int cnt = count;\r\nu8 wwnn[WWN_SZ];\r\nint rc;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif (!phba->soft_wwn_enable)\r\nreturn -EINVAL;\r\nrc = lpfc_wwn_set(buf, cnt, wwnn);\r\nif (!rc) {\r\nreturn rc;\r\n}\r\nphba->cfg_soft_wwnn = wwn_to_u64(wwnn);\r\ndev_printk(KERN_NOTICE, &phba->pcidev->dev,\r\n"lpfc%d: soft_wwnn set. Value will take effect upon "\r\n"setting of the soft_wwpn\n", phba->brd_no);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_tgt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%llx\n",\r\nwwn_to_u64(phba->cfg_oas_tgt_wwpn));\r\n}\r\nstatic ssize_t\r\nlpfc_oas_tgt_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nunsigned int cnt = count;\r\nuint8_t wwpn[WWN_SZ];\r\nint rc;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nrc = lpfc_wwn_set(buf, cnt, wwpn);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(phba->cfg_oas_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\r\nmemcpy(phba->sli4_hba.oas_next_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\r\nif (wwn_to_u64(wwpn) == 0)\r\nphba->cfg_oas_flags |= OAS_FIND_ANY_TARGET;\r\nelse\r\nphba->cfg_oas_flags &= ~OAS_FIND_ANY_TARGET;\r\nphba->cfg_oas_flags &= ~OAS_LUN_VALID;\r\nphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_vpt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%llx\n",\r\nwwn_to_u64(phba->cfg_oas_vpt_wwpn));\r\n}\r\nstatic ssize_t\r\nlpfc_oas_vpt_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nunsigned int cnt = count;\r\nuint8_t wwpn[WWN_SZ];\r\nint rc;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nrc = lpfc_wwn_set(buf, cnt, wwpn);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(phba->cfg_oas_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\r\nmemcpy(phba->sli4_hba.oas_next_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\r\nif (wwn_to_u64(wwpn) == 0)\r\nphba->cfg_oas_flags |= OAS_FIND_ANY_VPORT;\r\nelse\r\nphba->cfg_oas_flags &= ~OAS_FIND_ANY_VPORT;\r\nphba->cfg_oas_flags &= ~OAS_LUN_VALID;\r\nphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->cfg_oas_lun_state);\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_state_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nint val = 0;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif ((val != 0) && (val != 1))\r\nreturn -EINVAL;\r\nphba->cfg_oas_lun_state = val;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_status_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nif (!(phba->cfg_oas_flags & OAS_LUN_VALID))\r\nreturn -EFAULT;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->cfg_oas_lun_status);\r\n}\r\nstatic size_t\r\nlpfc_oas_lun_state_set(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\r\nuint8_t tgt_wwpn[], uint64_t lun, uint32_t oas_state)\r\n{\r\nint rc = 0;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (oas_state) {\r\nif (!lpfc_enable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\r\n(struct lpfc_name *)tgt_wwpn, lun))\r\nrc = -ENOMEM;\r\n} else {\r\nlpfc_disable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\r\n(struct lpfc_name *)tgt_wwpn, lun);\r\n}\r\nreturn rc;\r\n}\r\nstatic uint64_t\r\nlpfc_oas_lun_get_next(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\r\nuint8_t tgt_wwpn[], uint32_t *lun_status)\r\n{\r\nuint64_t found_lun;\r\nif (unlikely(!phba) || !vpt_wwpn || !tgt_wwpn)\r\nreturn NOT_OAS_ENABLED_LUN;\r\nif (lpfc_find_next_oas_lun(phba, (struct lpfc_name *)\r\nphba->sli4_hba.oas_next_vpt_wwpn,\r\n(struct lpfc_name *)\r\nphba->sli4_hba.oas_next_tgt_wwpn,\r\n&phba->sli4_hba.oas_next_lun,\r\n(struct lpfc_name *)vpt_wwpn,\r\n(struct lpfc_name *)tgt_wwpn,\r\n&found_lun, lun_status))\r\nreturn found_lun;\r\nelse\r\nreturn NOT_OAS_ENABLED_LUN;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_state_change(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\r\nuint8_t tgt_wwpn[], uint64_t lun,\r\nuint32_t oas_state)\r\n{\r\nint rc;\r\nrc = lpfc_oas_lun_state_set(phba, vpt_wwpn, tgt_wwpn, lun,\r\noas_state);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nuint64_t oas_lun;\r\nint len = 0;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\r\nif (!(phba->cfg_oas_flags & OAS_FIND_ANY_VPORT))\r\nreturn -EFAULT;\r\nif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\r\nif (!(phba->cfg_oas_flags & OAS_FIND_ANY_TARGET))\r\nreturn -EFAULT;\r\noas_lun = lpfc_oas_lun_get_next(phba, phba->cfg_oas_vpt_wwpn,\r\nphba->cfg_oas_tgt_wwpn,\r\n&phba->cfg_oas_lun_status);\r\nif (oas_lun != NOT_OAS_ENABLED_LUN)\r\nphba->cfg_oas_flags |= OAS_LUN_VALID;\r\nlen += snprintf(buf + len, PAGE_SIZE-len, "0x%llx", oas_lun);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nlpfc_oas_lun_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\r\nuint64_t scsi_lun;\r\nssize_t rc;\r\nif (!phba->cfg_fof)\r\nreturn -EPERM;\r\nif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\r\nreturn -EFAULT;\r\nif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\r\nreturn -EFAULT;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "0x%llx", &scsi_lun) != 1)\r\nreturn -EINVAL;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\r\n"3372 Try to set vport 0x%llx target 0x%llx lun:%lld "\r\n"with oas set to %d\n",\r\nwwn_to_u64(phba->cfg_oas_vpt_wwpn),\r\nwwn_to_u64(phba->cfg_oas_tgt_wwpn), scsi_lun,\r\nphba->cfg_oas_lun_state);\r\nrc = lpfc_oas_lun_state_change(phba, phba->cfg_oas_vpt_wwpn,\r\nphba->cfg_oas_tgt_wwpn, scsi_lun,\r\nphba->cfg_oas_lun_state);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nlpfc_iocb_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", phba->iocb_max);\r\n}\r\nstatic ssize_t\r\nlpfc_txq_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nphba->sli.ring[LPFC_ELS_RING].txq_max);\r\n}\r\nstatic ssize_t\r\nlpfc_txcmplq_hw_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_hba *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nphba->sli.ring[LPFC_ELS_RING].txcmplq_max);\r\n}\r\nstatic ssize_t\r\nlpfc_nodev_tmo_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", vport->cfg_devloss_tmo);\r\n}\r\nstatic int\r\nlpfc_nodev_tmo_init(struct lpfc_vport *vport, int val)\r\n{\r\nif (vport->cfg_devloss_tmo != LPFC_DEF_DEVLOSS_TMO) {\r\nvport->cfg_nodev_tmo = vport->cfg_devloss_tmo;\r\nif (val != LPFC_DEF_DEVLOSS_TMO)\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0407 Ignoring nodev_tmo module "\r\n"parameter because devloss_tmo is "\r\n"set.\n");\r\nreturn 0;\r\n}\r\nif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\r\nvport->cfg_nodev_tmo = val;\r\nvport->cfg_devloss_tmo = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0400 lpfc_nodev_tmo attribute cannot be set to"\r\n" %d, allowed range is [%d, %d]\n",\r\nval, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\r\nvport->cfg_nodev_tmo = LPFC_DEF_DEVLOSS_TMO;\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nlpfc_update_rport_devloss_tmo(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_nodelist *ndlp;\r\nshost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp)\r\nif (NLP_CHK_NODE_ACT(ndlp) && ndlp->rport)\r\nndlp->rport->dev_loss_tmo = vport->cfg_devloss_tmo;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic int\r\nlpfc_nodev_tmo_set(struct lpfc_vport *vport, int val)\r\n{\r\nif (vport->dev_loss_tmo_changed ||\r\n(lpfc_devloss_tmo != LPFC_DEF_DEVLOSS_TMO)) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0401 Ignoring change to nodev_tmo "\r\n"because devloss_tmo is set.\n");\r\nreturn 0;\r\n}\r\nif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\r\nvport->cfg_nodev_tmo = val;\r\nvport->cfg_devloss_tmo = val;\r\nfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\r\nlpfc_update_rport_devloss_tmo(vport);\r\nreturn 0;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0403 lpfc_nodev_tmo attribute cannot be set to"\r\n"%d, allowed range is [%d, %d]\n",\r\nval, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nlpfc_devloss_tmo_set(struct lpfc_vport *vport, int val)\r\n{\r\nif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\r\nvport->cfg_nodev_tmo = val;\r\nvport->cfg_devloss_tmo = val;\r\nvport->dev_loss_tmo_changed = 1;\r\nfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\r\nlpfc_update_rport_devloss_tmo(vport);\r\nreturn 0;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0404 lpfc_devloss_tmo attribute cannot be set to"\r\n" %d, allowed range is [%d, %d]\n",\r\nval, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nlpfc_restrict_login_init(struct lpfc_vport *vport, int val)\r\n{\r\nif (val < 0 || val > 1) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0422 lpfc_restrict_login attribute cannot "\r\n"be set to %d, allowed range is [0, 1]\n",\r\nval);\r\nvport->cfg_restrict_login = 1;\r\nreturn -EINVAL;\r\n}\r\nif (vport->port_type == LPFC_PHYSICAL_PORT) {\r\nvport->cfg_restrict_login = 0;\r\nreturn 0;\r\n}\r\nvport->cfg_restrict_login = val;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_restrict_login_set(struct lpfc_vport *vport, int val)\r\n{\r\nif (val < 0 || val > 1) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0425 lpfc_restrict_login attribute cannot "\r\n"be set to %d, allowed range is [0, 1]\n",\r\nval);\r\nvport->cfg_restrict_login = 1;\r\nreturn -EINVAL;\r\n}\r\nif (vport->port_type == LPFC_PHYSICAL_PORT && val != 0) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"0468 lpfc_restrict_login must be 0 for "\r\n"Physical ports.\n");\r\nvport->cfg_restrict_login = 0;\r\nreturn 0;\r\n}\r\nvport->cfg_restrict_login = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlpfc_topology_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val = 0;\r\nint nolip = 0;\r\nconst char *val_buf = buf;\r\nint err;\r\nuint32_t prev_val;\r\nif (!strncmp(buf, "nolip ", strlen("nolip "))) {\r\nnolip = 1;\r\nval_buf = &buf[strlen("nolip ")];\r\n}\r\nif (!isdigit(val_buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(val_buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif (val >= 0 && val <= 6) {\r\nprev_val = phba->cfg_topology;\r\nphba->cfg_topology = val;\r\nif (phba->cfg_link_speed == LPFC_USER_LINK_SPEED_16G &&\r\nval == 4) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3113 Loop mode not supported at speed %d\n",\r\nphba->cfg_link_speed);\r\nphba->cfg_topology = prev_val;\r\nreturn -EINVAL;\r\n}\r\nif (nolip)\r\nreturn strlen(buf);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3054 lpfc_topology changed from %d to %d\n",\r\nprev_val, val);\r\nif (prev_val != val && phba->sli_rev == LPFC_SLI_REV4)\r\nphba->fc_topology_changed = 1;\r\nerr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\r\nif (err) {\r\nphba->cfg_topology = prev_val;\r\nreturn -EINVAL;\r\n} else\r\nreturn strlen(buf);\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"%d:0467 lpfc_topology attribute cannot be set to %d, "\r\n"allowed range is [0, 6]\n",\r\nphba->brd_no, val);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_static_vport_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nif (vport->vport_flag & STATIC_VPORT)\r\nsprintf(buf, "1\n");\r\nelse\r\nsprintf(buf, "0\n");\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nlpfc_stat_data_ctrl_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\n#define LPFC_MAX_DATA_CTRL_LEN 1024\r\nstatic char bucket_data[LPFC_MAX_DATA_CTRL_LEN];\r\nunsigned long i;\r\nchar *str_ptr, *token;\r\nstruct lpfc_vport **vports;\r\nstruct Scsi_Host *v_shost;\r\nchar *bucket_type_str, *base_str, *step_str;\r\nunsigned long base, step, bucket_type;\r\nif (!strncmp(buf, "setbucket", strlen("setbucket"))) {\r\nif (strlen(buf) > (LPFC_MAX_DATA_CTRL_LEN - 1))\r\nreturn -EINVAL;\r\nstrncpy(bucket_data, buf, LPFC_MAX_DATA_CTRL_LEN);\r\nstr_ptr = &bucket_data[0];\r\ntoken = strsep(&str_ptr, "\t ");\r\nif (!token)\r\nreturn -EINVAL;\r\nbucket_type_str = strsep(&str_ptr, "\t ");\r\nif (!bucket_type_str)\r\nreturn -EINVAL;\r\nif (!strncmp(bucket_type_str, "linear", strlen("linear")))\r\nbucket_type = LPFC_LINEAR_BUCKET;\r\nelse if (!strncmp(bucket_type_str, "power2", strlen("power2")))\r\nbucket_type = LPFC_POWER2_BUCKET;\r\nelse\r\nreturn -EINVAL;\r\nbase_str = strsep(&str_ptr, "\t ");\r\nif (!base_str)\r\nreturn -EINVAL;\r\nbase = simple_strtoul(base_str, NULL, 0);\r\nstep_str = strsep(&str_ptr, "\t ");\r\nif (!step_str)\r\nreturn -EINVAL;\r\nstep = simple_strtoul(step_str, NULL, 0);\r\nif (!step)\r\nreturn -EINVAL;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nv_shost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(v_shost->host_lock);\r\nvports[i]->stat_data_blocked = 1;\r\nif (vports[i]->stat_data_enabled)\r\nlpfc_vport_reset_stat_data(vports[i]);\r\nspin_unlock_irq(v_shost->host_lock);\r\n}\r\nphba->bucket_type = bucket_type;\r\nphba->bucket_base = base;\r\nphba->bucket_step = step;\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nv_shost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(v_shost->host_lock);\r\nvports[i]->stat_data_blocked = 0;\r\nspin_unlock_irq(v_shost->host_lock);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nreturn strlen(buf);\r\n}\r\nif (!strncmp(buf, "destroybucket", strlen("destroybucket"))) {\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nv_shost = lpfc_shost_from_vport(vports[i]);\r\nspin_lock_irq(shost->host_lock);\r\nvports[i]->stat_data_blocked = 1;\r\nlpfc_free_bucket(vport);\r\nvport->stat_data_enabled = 0;\r\nvports[i]->stat_data_blocked = 0;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\nphba->bucket_type = LPFC_NO_BUCKET;\r\nphba->bucket_base = 0;\r\nphba->bucket_step = 0;\r\nreturn strlen(buf);\r\n}\r\nif (!strncmp(buf, "start", strlen("start"))) {\r\nif (phba->bucket_type == LPFC_NO_BUCKET)\r\nreturn -EINVAL;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->stat_data_enabled) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn strlen(buf);\r\n}\r\nlpfc_alloc_bucket(vport);\r\nvport->stat_data_enabled = 1;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn strlen(buf);\r\n}\r\nif (!strncmp(buf, "stop", strlen("stop"))) {\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->stat_data_enabled == 0) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn strlen(buf);\r\n}\r\nlpfc_free_bucket(vport);\r\nvport->stat_data_enabled = 0;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn strlen(buf);\r\n}\r\nif (!strncmp(buf, "reset", strlen("reset"))) {\r\nif ((phba->bucket_type == LPFC_NO_BUCKET)\r\n|| !vport->stat_data_enabled)\r\nreturn strlen(buf);\r\nspin_lock_irq(shost->host_lock);\r\nvport->stat_data_blocked = 1;\r\nlpfc_vport_reset_stat_data(vport);\r\nvport->stat_data_blocked = 0;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn strlen(buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_stat_data_ctrl_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint index = 0;\r\nint i;\r\nchar *bucket_type;\r\nunsigned long bucket_value;\r\nswitch (phba->bucket_type) {\r\ncase LPFC_LINEAR_BUCKET:\r\nbucket_type = "linear";\r\nbreak;\r\ncase LPFC_POWER2_BUCKET:\r\nbucket_type = "power2";\r\nbreak;\r\ndefault:\r\nbucket_type = "No Bucket";\r\nbreak;\r\n}\r\nsprintf(&buf[index], "Statistical Data enabled :%d, "\r\n"blocked :%d, Bucket type :%s, Bucket base :%d,"\r\n" Bucket step :%d\nLatency Ranges :",\r\nvport->stat_data_enabled, vport->stat_data_blocked,\r\nbucket_type, phba->bucket_base, phba->bucket_step);\r\nindex = strlen(buf);\r\nif (phba->bucket_type != LPFC_NO_BUCKET) {\r\nfor (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {\r\nif (phba->bucket_type == LPFC_LINEAR_BUCKET)\r\nbucket_value = phba->bucket_base +\r\nphba->bucket_step * i;\r\nelse\r\nbucket_value = phba->bucket_base +\r\n(1 << i) * phba->bucket_step;\r\nif (index + 10 > PAGE_SIZE)\r\nbreak;\r\nsprintf(&buf[index], "%08ld ", bucket_value);\r\nindex = strlen(buf);\r\n}\r\n}\r\nsprintf(&buf[index], "\n");\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nsysfs_drvr_stat_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device,\r\nkobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint i = 0, index = 0;\r\nunsigned long nport_index;\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nnport_index = (unsigned long)off /\r\nMAX_STAT_DATA_SIZE_PER_TARGET;\r\nif (!vport->stat_data_enabled || vport->stat_data_blocked\r\n|| (phba->bucket_type == LPFC_NO_BUCKET))\r\nreturn 0;\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp) || !ndlp->lat_data)\r\ncontinue;\r\nif (nport_index > 0) {\r\nnport_index--;\r\ncontinue;\r\n}\r\nif ((index + MAX_STAT_DATA_SIZE_PER_TARGET)\r\n> count)\r\nbreak;\r\nif (!ndlp->lat_data)\r\ncontinue;\r\nsprintf(&buf[index], "%02x%02x%02x%02x%02x%02x%02x%02x:",\r\nndlp->nlp_portname.u.wwn[0],\r\nndlp->nlp_portname.u.wwn[1],\r\nndlp->nlp_portname.u.wwn[2],\r\nndlp->nlp_portname.u.wwn[3],\r\nndlp->nlp_portname.u.wwn[4],\r\nndlp->nlp_portname.u.wwn[5],\r\nndlp->nlp_portname.u.wwn[6],\r\nndlp->nlp_portname.u.wwn[7]);\r\nindex = strlen(buf);\r\nfor (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {\r\nsprintf(&buf[index], "%010u,",\r\nndlp->lat_data[i].cmd_count);\r\nindex = strlen(buf);\r\n}\r\nsprintf(&buf[index], "\n");\r\nindex = strlen(buf);\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nreturn index;\r\n}\r\nstatic ssize_t\r\nlpfc_link_speed_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val = LPFC_USER_LINK_SPEED_AUTO;\r\nint nolip = 0;\r\nconst char *val_buf = buf;\r\nint err;\r\nuint32_t prev_val;\r\nif (!strncmp(buf, "nolip ", strlen("nolip "))) {\r\nnolip = 1;\r\nval_buf = &buf[strlen("nolip ")];\r\n}\r\nif (!isdigit(val_buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(val_buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\r\n"3055 lpfc_link_speed changed from %d to %d %s\n",\r\nphba->cfg_link_speed, val, nolip ? "(nolip)" : "(lip)");\r\nif (((val == LPFC_USER_LINK_SPEED_1G) && !(phba->lmt & LMT_1Gb)) ||\r\n((val == LPFC_USER_LINK_SPEED_2G) && !(phba->lmt & LMT_2Gb)) ||\r\n((val == LPFC_USER_LINK_SPEED_4G) && !(phba->lmt & LMT_4Gb)) ||\r\n((val == LPFC_USER_LINK_SPEED_8G) && !(phba->lmt & LMT_8Gb)) ||\r\n((val == LPFC_USER_LINK_SPEED_10G) && !(phba->lmt & LMT_10Gb)) ||\r\n((val == LPFC_USER_LINK_SPEED_16G) && !(phba->lmt & LMT_16Gb))) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2879 lpfc_link_speed attribute cannot be set "\r\n"to %d. Speed is not supported by this port.\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nif (val == LPFC_USER_LINK_SPEED_16G &&\r\nphba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3112 lpfc_link_speed attribute cannot be set "\r\n"to %d. Speed is not supported in loop mode.\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nif ((val >= 0) && (val <= LPFC_USER_LINK_SPEED_MAX) &&\r\n(LPFC_USER_LINK_SPEED_BITMAP & (1 << val))) {\r\nprev_val = phba->cfg_link_speed;\r\nphba->cfg_link_speed = val;\r\nif (nolip)\r\nreturn strlen(buf);\r\nerr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\r\nif (err) {\r\nphba->cfg_link_speed = prev_val;\r\nreturn -EINVAL;\r\n} else\r\nreturn strlen(buf);\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0469 lpfc_link_speed attribute cannot be set to %d, "\r\n"allowed values are ["LPFC_LINK_SPEED_STRING"]\n", val);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nlpfc_link_speed_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (val == LPFC_USER_LINK_SPEED_16G && phba->cfg_topology == 4) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3111 lpfc_link_speed of %d cannot "\r\n"support loop mode, setting topology to default.\n",\r\nval);\r\nphba->cfg_topology = 0;\r\n}\r\nif ((val >= 0) && (val <= LPFC_USER_LINK_SPEED_MAX) &&\r\n(LPFC_USER_LINK_SPEED_BITMAP & (1 << val))) {\r\nphba->cfg_link_speed = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0405 lpfc_link_speed attribute cannot "\r\n"be set to %d, allowed values are "\r\n"["LPFC_LINK_SPEED_STRING"]\n", val);\r\nphba->cfg_link_speed = LPFC_USER_LINK_SPEED_AUTO;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_aer_support_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val = 0, rc = -EINVAL;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase 0:\r\nif (phba->hba_flag & HBA_AER_ENABLED) {\r\nrc = pci_disable_pcie_error_reporting(phba->pcidev);\r\nif (!rc) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag &= ~HBA_AER_ENABLED;\r\nspin_unlock_irq(&phba->hbalock);\r\nphba->cfg_aer_support = 0;\r\nrc = strlen(buf);\r\n} else\r\nrc = -EPERM;\r\n} else {\r\nphba->cfg_aer_support = 0;\r\nrc = strlen(buf);\r\n}\r\nbreak;\r\ncase 1:\r\nif (!(phba->hba_flag & HBA_AER_ENABLED)) {\r\nrc = pci_enable_pcie_error_reporting(phba->pcidev);\r\nif (!rc) {\r\nspin_lock_irq(&phba->hbalock);\r\nphba->hba_flag |= HBA_AER_ENABLED;\r\nspin_unlock_irq(&phba->hbalock);\r\nphba->cfg_aer_support = 1;\r\nrc = strlen(buf);\r\n} else\r\nrc = -EPERM;\r\n} else {\r\nphba->cfg_aer_support = 1;\r\nrc = strlen(buf);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_aer_support_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (val == 0 || val == 1) {\r\nphba->cfg_aer_support = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"2712 lpfc_aer_support attribute value %d out "\r\n"of range, allowed values are 0|1, setting it "\r\n"to default value of 1\n", val);\r\nphba->cfg_aer_support = 1;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_aer_cleanup_state(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val, rc = -1;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif (val != 1)\r\nreturn -EINVAL;\r\nif (phba->hba_flag & HBA_AER_ENABLED)\r\nrc = pci_cleanup_aer_uncorrect_error_status(phba->pcidev);\r\nif (rc == 0)\r\nreturn strlen(buf);\r\nelse\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t\r\nlpfc_sriov_nr_virtfn_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct pci_dev *pdev = phba->pcidev;\r\nint val = 0, rc = -EINVAL;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nif (val == 0) {\r\nif (phba->cfg_sriov_nr_virtfn > 0) {\r\npci_disable_sriov(pdev);\r\nphba->cfg_sriov_nr_virtfn = 0;\r\n}\r\nreturn strlen(buf);\r\n}\r\nif (phba->cfg_sriov_nr_virtfn > 0) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3018 There are %d virtual functions "\r\n"enabled on physical function.\n",\r\nphba->cfg_sriov_nr_virtfn);\r\nreturn -EEXIST;\r\n}\r\nif (val <= LPFC_MAX_VFN_PER_PFN)\r\nphba->cfg_sriov_nr_virtfn = val;\r\nelse {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3019 Enabling %d virtual functions is not "\r\n"allowed.\n", val);\r\nreturn -EINVAL;\r\n}\r\nrc = lpfc_sli_probe_sriov_nr_virtfn(phba, phba->cfg_sriov_nr_virtfn);\r\nif (rc) {\r\nphba->cfg_sriov_nr_virtfn = 0;\r\nrc = -EPERM;\r\n} else\r\nrc = strlen(buf);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sriov_nr_virtfn_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (val >= 0 && val <= LPFC_MAX_VFN_PER_PFN) {\r\nphba->cfg_sriov_nr_virtfn = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3017 Enabling %d virtual functions is not "\r\n"allowed.\n", val);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_request_firmware_upgrade_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val = 0, rc = -EINVAL;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif (val != 1)\r\nreturn -EINVAL;\r\nrc = lpfc_sli4_request_firmware_update(phba, RUN_FW_UPGRADE);\r\nif (rc)\r\nrc = -EPERM;\r\nelse\r\nrc = strlen(buf);\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_request_firmware_upgrade_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (val >= 0 && val <= 1) {\r\nphba->cfg_request_firmware_upgrade = val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nlpfc_fcp_imax_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint val = 0, i;\r\nif (phba->sli_rev != LPFC_SLI_REV4)\r\nreturn -EINVAL;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &val) != 1)\r\nreturn -EINVAL;\r\nif (val < LPFC_MIN_IMAX || val > LPFC_MAX_IMAX)\r\nreturn -EINVAL;\r\nphba->cfg_fcp_imax = (uint32_t)val;\r\nfor (i = 0; i < phba->cfg_fcp_io_channel; i += LPFC_MAX_EQ_DELAY)\r\nlpfc_modify_fcp_eq_delay(phba, i);\r\nreturn strlen(buf);\r\n}\r\nstatic int\r\nlpfc_fcp_imax_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (phba->sli_rev != LPFC_SLI_REV4) {\r\nphba->cfg_fcp_imax = 0;\r\nreturn 0;\r\n}\r\nif (val >= LPFC_MIN_IMAX && val <= LPFC_MAX_IMAX) {\r\nphba->cfg_fcp_imax = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3016 fcp_imax: %d out of range, using default\n", val);\r\nphba->cfg_fcp_imax = LPFC_DEF_IMAX;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlpfc_fcp_cpu_map_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_vector_map_info *cpup;\r\nint len = 0;\r\nif ((phba->sli_rev != LPFC_SLI_REV4) ||\r\n(phba->intr_type != MSIX))\r\nreturn len;\r\nswitch (phba->cfg_fcp_cpu_map) {\r\ncase 0:\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"fcp_cpu_map: No mapping (%d)\n",\r\nphba->cfg_fcp_cpu_map);\r\nreturn len;\r\ncase 1:\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"fcp_cpu_map: HBA centric mapping (%d): "\r\n"%d online CPUs\n",\r\nphba->cfg_fcp_cpu_map,\r\nphba->sli4_hba.num_online_cpu);\r\nbreak;\r\ncase 2:\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"fcp_cpu_map: Driver centric mapping (%d): "\r\n"%d online CPUs\n",\r\nphba->cfg_fcp_cpu_map,\r\nphba->sli4_hba.num_online_cpu);\r\nbreak;\r\n}\r\nwhile (phba->sli4_hba.curr_disp_cpu < phba->sli4_hba.num_present_cpu) {\r\ncpup = &phba->sli4_hba.cpu_map[phba->sli4_hba.curr_disp_cpu];\r\nif (cpup->irq == LPFC_VECTOR_MAP_EMPTY)\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"CPU %02d io_chan %02d "\r\n"physid %d coreid %d\n",\r\nphba->sli4_hba.curr_disp_cpu,\r\ncpup->channel_id, cpup->phys_id,\r\ncpup->core_id);\r\nelse\r\nlen += snprintf(buf + len, PAGE_SIZE-len,\r\n"CPU %02d io_chan %02d "\r\n"physid %d coreid %d IRQ %d\n",\r\nphba->sli4_hba.curr_disp_cpu,\r\ncpup->channel_id, cpup->phys_id,\r\ncpup->core_id, cpup->irq);\r\nphba->sli4_hba.curr_disp_cpu++;\r\nif (phba->sli4_hba.curr_disp_cpu <\r\nphba->sli4_hba.num_present_cpu &&\r\n(len >= (PAGE_SIZE - 64))) {\r\nlen += snprintf(buf + len, PAGE_SIZE-len, "more...\n");\r\nbreak;\r\n}\r\n}\r\nif (phba->sli4_hba.curr_disp_cpu == phba->sli4_hba.num_present_cpu)\r\nphba->sli4_hba.curr_disp_cpu = 0;\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nlpfc_fcp_cpu_map_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint status = -EINVAL;\r\nreturn status;\r\n}\r\nstatic int\r\nlpfc_fcp_cpu_map_init(struct lpfc_hba *phba, int val)\r\n{\r\nif (phba->sli_rev != LPFC_SLI_REV4) {\r\nphba->cfg_fcp_cpu_map = 0;\r\nreturn 0;\r\n}\r\nif (val >= LPFC_MIN_CPU_MAP && val <= LPFC_MAX_CPU_MAP) {\r\nphba->cfg_fcp_cpu_map = val;\r\nreturn 0;\r\n}\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"3326 fcp_cpu_map: %d out of range, using default\n",\r\nval);\r\nphba->cfg_fcp_cpu_map = LPFC_DRIVER_CPU_MAP;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_max_scsicmpl_time_set(struct lpfc_vport *vport, int val)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nif (val == vport->cfg_max_scsicmpl_time)\r\nreturn 0;\r\nif ((val < 0) || (val > 60000))\r\nreturn -EINVAL;\r\nvport->cfg_max_scsicmpl_time = val;\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp))\r\ncontinue;\r\nif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\r\ncontinue;\r\nndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsysfs_ctlreg_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nsize_t buf_off;\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (phba->sli_rev >= LPFC_SLI_REV4)\r\nreturn -EPERM;\r\nif ((off + count) > FF_REG_AREA_SIZE)\r\nreturn -ERANGE;\r\nif (count <= LPFC_REG_WRITE_KEY_SIZE)\r\nreturn 0;\r\nif (off % 4 || count % 4 || (unsigned long)buf % 4)\r\nreturn -EINVAL;\r\nif (memcmp(buf, LPFC_REG_WRITE_KEY, LPFC_REG_WRITE_KEY_SIZE))\r\nreturn -EINVAL;\r\nif (!(vport->fc_flag & FC_OFFLINE_MODE))\r\nreturn -EPERM;\r\nspin_lock_irq(&phba->hbalock);\r\nfor (buf_off = 0; buf_off < count - LPFC_REG_WRITE_KEY_SIZE;\r\nbuf_off += sizeof(uint32_t))\r\nwritel(*((uint32_t *)(buf + buf_off + LPFC_REG_WRITE_KEY_SIZE)),\r\nphba->ctrl_regs_memmap_p + off + buf_off);\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsysfs_ctlreg_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nsize_t buf_off;\r\nuint32_t * tmp_ptr;\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (phba->sli_rev >= LPFC_SLI_REV4)\r\nreturn -EPERM;\r\nif (off > FF_REG_AREA_SIZE)\r\nreturn -ERANGE;\r\nif ((off + count) > FF_REG_AREA_SIZE)\r\ncount = FF_REG_AREA_SIZE - off;\r\nif (count == 0) return 0;\r\nif (off % 4 || count % 4 || (unsigned long)buf % 4)\r\nreturn -EINVAL;\r\nspin_lock_irq(&phba->hbalock);\r\nfor (buf_off = 0; buf_off < count; buf_off += sizeof(uint32_t)) {\r\ntmp_ptr = (uint32_t *)(buf + buf_off);\r\n*tmp_ptr = readl(phba->ctrl_regs_memmap_p + off + buf_off);\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsysfs_mbox_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t\r\nsysfs_mbox_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nreturn -EPERM;\r\n}\r\nint\r\nlpfc_alloc_sysfs_attr(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nint error;\r\nerror = sysfs_create_bin_file(&shost->shost_dev.kobj,\r\n&sysfs_drvr_stat_data_attr);\r\nif (error || vport->port_type == LPFC_NPIV_PORT)\r\ngoto out;\r\nerror = sysfs_create_bin_file(&shost->shost_dev.kobj,\r\n&sysfs_ctlreg_attr);\r\nif (error)\r\ngoto out_remove_stat_attr;\r\nerror = sysfs_create_bin_file(&shost->shost_dev.kobj,\r\n&sysfs_mbox_attr);\r\nif (error)\r\ngoto out_remove_ctlreg_attr;\r\nreturn 0;\r\nout_remove_ctlreg_attr:\r\nsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\r\nout_remove_stat_attr:\r\nsysfs_remove_bin_file(&shost->shost_dev.kobj,\r\n&sysfs_drvr_stat_data_attr);\r\nout:\r\nreturn error;\r\n}\r\nvoid\r\nlpfc_free_sysfs_attr(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nsysfs_remove_bin_file(&shost->shost_dev.kobj,\r\n&sysfs_drvr_stat_data_attr);\r\nif (vport->port_type == LPFC_NPIV_PORT)\r\nreturn;\r\nsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_mbox_attr);\r\nsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\r\n}\r\nstatic void\r\nlpfc_get_host_port_id(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nfc_host_port_id(shost) = vport->fc_myDID;\r\n}\r\nstatic void\r\nlpfc_get_host_port_type(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->port_type == LPFC_NPIV_PORT) {\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\r\n} else if (lpfc_is_link_up(phba)) {\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nif (vport->fc_flag & FC_PUBLIC_LOOP)\r\nfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\r\nelse\r\nfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\r\n} else {\r\nif (vport->fc_flag & FC_FABRIC)\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\r\nelse\r\nfc_host_port_type(shost) = FC_PORTTYPE_PTP;\r\n}\r\n} else\r\nfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic void\r\nlpfc_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->fc_flag & FC_OFFLINE_MODE)\r\nfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\r\nelse {\r\nswitch (phba->link_state) {\r\ncase LPFC_LINK_UNKNOWN:\r\ncase LPFC_LINK_DOWN:\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nbreak;\r\ncase LPFC_LINK_UP:\r\ncase LPFC_CLEAR_LA:\r\ncase LPFC_HBA_READY:\r\nif (vport->port_state < LPFC_VPORT_READY)\r\nfc_host_port_state(shost) =\r\nFC_PORTSTATE_BYPASSED;\r\nelse\r\nfc_host_port_state(shost) =\r\nFC_PORTSTATE_ONLINE;\r\nbreak;\r\ncase LPFC_HBA_ERROR:\r\nfc_host_port_state(shost) = FC_PORTSTATE_ERROR;\r\nbreak;\r\ndefault:\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic void\r\nlpfc_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nspin_lock_irq(shost->host_lock);\r\nif (lpfc_is_link_up(phba)) {\r\nswitch(phba->fc_linkspeed) {\r\ncase LPFC_LINK_SPEED_1GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_2GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_4GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_8GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_10GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ncase LPFC_LINK_SPEED_16GHZ:\r\nfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\r\nbreak;\r\ndefault:\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\n} else\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic void\r\nlpfc_get_host_fabric_name (struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nu64 node_name;\r\nspin_lock_irq(shost->host_lock);\r\nif ((vport->port_state > LPFC_FLOGI) &&\r\n((vport->fc_flag & FC_FABRIC) ||\r\n((phba->fc_topology == LPFC_TOPOLOGY_LOOP) &&\r\n(vport->fc_flag & FC_PUBLIC_LOOP))))\r\nnode_name = wwn_to_u64(phba->fc_fabparam.nodeName.u.wwn);\r\nelse\r\nnode_name = 0;\r\nspin_unlock_irq(shost->host_lock);\r\nfc_host_fabric_name(shost) = node_name;\r\n}\r\nstatic struct fc_host_statistics *\r\nlpfc_get_stats(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct fc_host_statistics *hs = &phba->link_stats;\r\nstruct lpfc_lnk_stat * lso = &psli->lnk_stat_offsets;\r\nLPFC_MBOXQ_t *pmboxq;\r\nMAILBOX_t *pmb;\r\nunsigned long seconds;\r\nint rc = 0;\r\nif (phba->link_state < LPFC_LINK_DOWN ||\r\n!phba->mbox_mem_pool ||\r\n(phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\r\nreturn NULL;\r\nif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\r\nreturn NULL;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn NULL;\r\nmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\r\npmb = &pmboxq->u.mb;\r\npmb->mbxCommand = MBX_READ_STATUS;\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->context1 = NULL;\r\npmboxq->vport = vport;\r\nif (vport->fc_flag & FC_OFFLINE_MODE)\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nelse\r\nrc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\r\nif (rc != MBX_SUCCESS) {\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn NULL;\r\n}\r\nmemset(hs, 0, sizeof (struct fc_host_statistics));\r\nhs->tx_frames = pmb->un.varRdStatus.xmitFrameCnt;\r\nhs->tx_words = (uint64_t)\r\n((uint64_t)pmb->un.varRdStatus.xmitByteCnt\r\n* (uint64_t)256);\r\nhs->rx_frames = pmb->un.varRdStatus.rcvFrameCnt;\r\nhs->rx_words = (uint64_t)\r\n((uint64_t)pmb->un.varRdStatus.rcvByteCnt\r\n* (uint64_t)256);\r\nmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\r\npmb->mbxCommand = MBX_READ_LNK_STAT;\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->context1 = NULL;\r\npmboxq->vport = vport;\r\nif (vport->fc_flag & FC_OFFLINE_MODE)\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nelse\r\nrc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\r\nif (rc != MBX_SUCCESS) {\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn NULL;\r\n}\r\nhs->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\r\nhs->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\r\nhs->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\r\nhs->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\r\nhs->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\r\nhs->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\r\nhs->error_frames = pmb->un.varRdLnk.crcCnt;\r\nhs->link_failure_count -= lso->link_failure_count;\r\nhs->loss_of_sync_count -= lso->loss_of_sync_count;\r\nhs->loss_of_signal_count -= lso->loss_of_signal_count;\r\nhs->prim_seq_protocol_err_count -= lso->prim_seq_protocol_err_count;\r\nhs->invalid_tx_word_count -= lso->invalid_tx_word_count;\r\nhs->invalid_crc_count -= lso->invalid_crc_count;\r\nhs->error_frames -= lso->error_frames;\r\nif (phba->hba_flag & HBA_FCOE_MODE) {\r\nhs->lip_count = -1;\r\nhs->nos_count = (phba->link_events >> 1);\r\nhs->nos_count -= lso->link_events;\r\n} else if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nhs->lip_count = (phba->fc_eventTag >> 1);\r\nhs->lip_count -= lso->link_events;\r\nhs->nos_count = -1;\r\n} else {\r\nhs->lip_count = -1;\r\nhs->nos_count = (phba->fc_eventTag >> 1);\r\nhs->nos_count -= lso->link_events;\r\n}\r\nhs->dumped_frames = -1;\r\nseconds = get_seconds();\r\nif (seconds < psli->stats_start)\r\nhs->seconds_since_last_reset = seconds +\r\n((unsigned long)-1 - psli->stats_start);\r\nelse\r\nhs->seconds_since_last_reset = seconds - psli->stats_start;\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn hs;\r\n}\r\nstatic void\r\nlpfc_reset_stats(struct Scsi_Host *shost)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_lnk_stat *lso = &psli->lnk_stat_offsets;\r\nLPFC_MBOXQ_t *pmboxq;\r\nMAILBOX_t *pmb;\r\nint rc = 0;\r\nif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\r\nreturn;\r\npmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!pmboxq)\r\nreturn;\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npmb = &pmboxq->u.mb;\r\npmb->mbxCommand = MBX_READ_STATUS;\r\npmb->mbxOwner = OWN_HOST;\r\npmb->un.varWords[0] = 0x1;\r\npmboxq->context1 = NULL;\r\npmboxq->vport = vport;\r\nif ((vport->fc_flag & FC_OFFLINE_MODE) ||\r\n(!(psli->sli_flag & LPFC_SLI_ACTIVE)))\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nelse\r\nrc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\r\nif (rc != MBX_SUCCESS) {\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\r\npmb->mbxCommand = MBX_READ_LNK_STAT;\r\npmb->mbxOwner = OWN_HOST;\r\npmboxq->context1 = NULL;\r\npmboxq->vport = vport;\r\nif ((vport->fc_flag & FC_OFFLINE_MODE) ||\r\n(!(psli->sli_flag & LPFC_SLI_ACTIVE)))\r\nrc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\r\nelse\r\nrc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\r\nif (rc != MBX_SUCCESS) {\r\nif (rc != MBX_TIMEOUT)\r\nmempool_free( pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nlso->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\r\nlso->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\r\nlso->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\r\nlso->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\r\nlso->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\r\nlso->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\r\nlso->error_frames = pmb->un.varRdLnk.crcCnt;\r\nif (phba->hba_flag & HBA_FCOE_MODE)\r\nlso->link_events = (phba->link_events >> 1);\r\nelse\r\nlso->link_events = (phba->fc_eventTag >> 1);\r\npsli->stats_start = get_seconds();\r\nmempool_free(pmboxq, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nstatic struct lpfc_nodelist *\r\nlpfc_get_node_by_target(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_nodelist *ndlp;\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (NLP_CHK_NODE_ACT(ndlp) &&\r\nndlp->nlp_state == NLP_STE_MAPPED_NODE &&\r\nstarget->id == ndlp->nlp_sid) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn ndlp;\r\n}\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\nlpfc_get_starget_port_id(struct scsi_target *starget)\r\n{\r\nstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\r\nfc_starget_port_id(starget) = ndlp ? ndlp->nlp_DID : -1;\r\n}\r\nstatic void\r\nlpfc_get_starget_node_name(struct scsi_target *starget)\r\n{\r\nstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\r\nfc_starget_node_name(starget) =\r\nndlp ? wwn_to_u64(ndlp->nlp_nodename.u.wwn) : 0;\r\n}\r\nstatic void\r\nlpfc_get_starget_port_name(struct scsi_target *starget)\r\n{\r\nstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\r\nfc_starget_port_name(starget) =\r\nndlp ? wwn_to_u64(ndlp->nlp_portname.u.wwn) : 0;\r\n}\r\nstatic void\r\nlpfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic void\r\nlpfc_set_vport_symbolic_name(struct fc_vport *fc_vport)\r\n{\r\nstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\r\nif (vport->port_state == LPFC_VPORT_READY)\r\nlpfc_ns_cmd(vport, SLI_CTNS_RSPN_ID, 0, 0);\r\n}\r\nstatic void\r\nlpfc_hba_log_verbose_init(struct lpfc_hba *phba, uint32_t verbose)\r\n{\r\nphba->cfg_log_verbose = verbose;\r\n}\r\nvoid\r\nlpfc_get_cfgparam(struct lpfc_hba *phba)\r\n{\r\nlpfc_fcp_io_sched_init(phba, lpfc_fcp_io_sched);\r\nlpfc_fcp2_no_tgt_reset_init(phba, lpfc_fcp2_no_tgt_reset);\r\nlpfc_cr_delay_init(phba, lpfc_cr_delay);\r\nlpfc_cr_count_init(phba, lpfc_cr_count);\r\nlpfc_multi_ring_support_init(phba, lpfc_multi_ring_support);\r\nlpfc_multi_ring_rctl_init(phba, lpfc_multi_ring_rctl);\r\nlpfc_multi_ring_type_init(phba, lpfc_multi_ring_type);\r\nlpfc_ack0_init(phba, lpfc_ack0);\r\nlpfc_topology_init(phba, lpfc_topology);\r\nlpfc_link_speed_init(phba, lpfc_link_speed);\r\nlpfc_poll_tmo_init(phba, lpfc_poll_tmo);\r\nlpfc_task_mgmt_tmo_init(phba, lpfc_task_mgmt_tmo);\r\nlpfc_enable_npiv_init(phba, lpfc_enable_npiv);\r\nlpfc_fcf_failover_policy_init(phba, lpfc_fcf_failover_policy);\r\nlpfc_enable_rrq_init(phba, lpfc_enable_rrq);\r\nlpfc_use_msi_init(phba, lpfc_use_msi);\r\nlpfc_fcp_imax_init(phba, lpfc_fcp_imax);\r\nlpfc_fcp_cpu_map_init(phba, lpfc_fcp_cpu_map);\r\nlpfc_fcp_io_channel_init(phba, lpfc_fcp_io_channel);\r\nlpfc_enable_hba_reset_init(phba, lpfc_enable_hba_reset);\r\nlpfc_enable_hba_heartbeat_init(phba, lpfc_enable_hba_heartbeat);\r\nlpfc_EnableXLane_init(phba, lpfc_EnableXLane);\r\nif (phba->sli_rev != LPFC_SLI_REV4)\r\nphba->cfg_EnableXLane = 0;\r\nlpfc_XLanePriority_init(phba, lpfc_XLanePriority);\r\nmemset(phba->cfg_oas_tgt_wwpn, 0, (8 * sizeof(uint8_t)));\r\nmemset(phba->cfg_oas_vpt_wwpn, 0, (8 * sizeof(uint8_t)));\r\nphba->cfg_oas_lun_state = 0;\r\nphba->cfg_oas_lun_status = 0;\r\nphba->cfg_oas_flags = 0;\r\nlpfc_enable_bg_init(phba, lpfc_enable_bg);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nphba->cfg_poll = 0;\r\nelse\r\nphba->cfg_poll = lpfc_poll;\r\nphba->cfg_soft_wwnn = 0L;\r\nphba->cfg_soft_wwpn = 0L;\r\nlpfc_sg_seg_cnt_init(phba, lpfc_sg_seg_cnt);\r\nlpfc_prot_sg_seg_cnt_init(phba, lpfc_prot_sg_seg_cnt);\r\nlpfc_hba_queue_depth_init(phba, lpfc_hba_queue_depth);\r\nlpfc_hba_log_verbose_init(phba, lpfc_log_verbose);\r\nlpfc_aer_support_init(phba, lpfc_aer_support);\r\nlpfc_sriov_nr_virtfn_init(phba, lpfc_sriov_nr_virtfn);\r\nlpfc_request_firmware_upgrade_init(phba, lpfc_req_fw_upgrade);\r\nlpfc_suppress_link_up_init(phba, lpfc_suppress_link_up);\r\nlpfc_iocb_cnt_init(phba, lpfc_iocb_cnt);\r\nphba->cfg_enable_dss = 1;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_get_vport_cfgparam(struct lpfc_vport *vport)\r\n{\r\nlpfc_log_verbose_init(vport, lpfc_log_verbose);\r\nlpfc_lun_queue_depth_init(vport, lpfc_lun_queue_depth);\r\nlpfc_tgt_queue_depth_init(vport, lpfc_tgt_queue_depth);\r\nlpfc_devloss_tmo_init(vport, lpfc_devloss_tmo);\r\nlpfc_nodev_tmo_init(vport, lpfc_nodev_tmo);\r\nlpfc_peer_port_login_init(vport, lpfc_peer_port_login);\r\nlpfc_restrict_login_init(vport, lpfc_restrict_login);\r\nlpfc_fcp_class_init(vport, lpfc_fcp_class);\r\nlpfc_use_adisc_init(vport, lpfc_use_adisc);\r\nlpfc_first_burst_size_init(vport, lpfc_first_burst_size);\r\nlpfc_max_scsicmpl_time_init(vport, lpfc_max_scsicmpl_time);\r\nlpfc_fdmi_on_init(vport, lpfc_fdmi_on);\r\nlpfc_discovery_threads_init(vport, lpfc_discovery_threads);\r\nlpfc_max_luns_init(vport, lpfc_max_luns);\r\nlpfc_scan_down_init(vport, lpfc_scan_down);\r\nlpfc_enable_da_id_init(vport, lpfc_enable_da_id);\r\nreturn;\r\n}
