int hex_to_bin(char ch)\r\n{\r\nif ((ch >= '0') && (ch <= '9'))\r\nreturn ch - '0';\r\nch = tolower(ch);\r\nif ((ch >= 'a') && (ch <= 'f'))\r\nreturn ch - 'a' + 10;\r\nreturn -1;\r\n}\r\nint hex2bin(u8 *dst, const char *src, size_t count)\r\n{\r\nwhile (count--) {\r\nint hi = hex_to_bin(*src++);\r\nint lo = hex_to_bin(*src++);\r\nif ((hi < 0) || (lo < 0))\r\nreturn -1;\r\n*dst++ = (hi << 4) | lo;\r\n}\r\nreturn 0;\r\n}\r\nchar *bin2hex(char *dst, const void *src, size_t count)\r\n{\r\nconst unsigned char *_src = src;\r\nwhile (count--)\r\ndst = hex_byte_pack(dst, *_src++);\r\nreturn dst;\r\n}\r\nvoid hex_dump_to_buffer(const void *buf, size_t len, int rowsize,\r\nint groupsize, char *linebuf, size_t linebuflen,\r\nbool ascii)\r\n{\r\nconst u8 *ptr = buf;\r\nu8 ch;\r\nint j, lx = 0;\r\nint ascii_column;\r\nif (rowsize != 16 && rowsize != 32)\r\nrowsize = 16;\r\nif (!len)\r\ngoto nil;\r\nif (len > rowsize)\r\nlen = rowsize;\r\nif ((len % groupsize) != 0)\r\ngroupsize = 1;\r\nswitch (groupsize) {\r\ncase 8: {\r\nconst u64 *ptr8 = buf;\r\nint ngroups = len / groupsize;\r\nfor (j = 0; j < ngroups; j++)\r\nlx += scnprintf(linebuf + lx, linebuflen - lx,\r\n"%s%16.16llx", j ? " " : "",\r\n(unsigned long long)*(ptr8 + j));\r\nascii_column = 17 * ngroups + 2;\r\nbreak;\r\n}\r\ncase 4: {\r\nconst u32 *ptr4 = buf;\r\nint ngroups = len / groupsize;\r\nfor (j = 0; j < ngroups; j++)\r\nlx += scnprintf(linebuf + lx, linebuflen - lx,\r\n"%s%8.8x", j ? " " : "", *(ptr4 + j));\r\nascii_column = 9 * ngroups + 2;\r\nbreak;\r\n}\r\ncase 2: {\r\nconst u16 *ptr2 = buf;\r\nint ngroups = len / groupsize;\r\nfor (j = 0; j < ngroups; j++)\r\nlx += scnprintf(linebuf + lx, linebuflen - lx,\r\n"%s%4.4x", j ? " " : "", *(ptr2 + j));\r\nascii_column = 5 * ngroups + 2;\r\nbreak;\r\n}\r\ndefault:\r\nfor (j = 0; (j < len) && (lx + 3) <= linebuflen; j++) {\r\nch = ptr[j];\r\nlinebuf[lx++] = hex_asc_hi(ch);\r\nlinebuf[lx++] = hex_asc_lo(ch);\r\nlinebuf[lx++] = ' ';\r\n}\r\nif (j)\r\nlx--;\r\nascii_column = 3 * rowsize + 2;\r\nbreak;\r\n}\r\nif (!ascii)\r\ngoto nil;\r\nwhile (lx < (linebuflen - 1) && lx < (ascii_column - 1))\r\nlinebuf[lx++] = ' ';\r\nfor (j = 0; (j < len) && (lx + 2) < linebuflen; j++) {\r\nch = ptr[j];\r\nlinebuf[lx++] = (isascii(ch) && isprint(ch)) ? ch : '.';\r\n}\r\nnil:\r\nlinebuf[lx++] = '\0';\r\n}\r\nvoid print_hex_dump(const char *level, const char *prefix_str, int prefix_type,\r\nint rowsize, int groupsize,\r\nconst void *buf, size_t len, bool ascii)\r\n{\r\nconst u8 *ptr = buf;\r\nint i, linelen, remaining = len;\r\nunsigned char linebuf[32 * 3 + 2 + 32 + 1];\r\nif (rowsize != 16 && rowsize != 32)\r\nrowsize = 16;\r\nfor (i = 0; i < len; i += rowsize) {\r\nlinelen = min(remaining, rowsize);\r\nremaining -= rowsize;\r\nhex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\r\nlinebuf, sizeof(linebuf), ascii);\r\nswitch (prefix_type) {\r\ncase DUMP_PREFIX_ADDRESS:\r\nprintk("%s%s%p: %s\n",\r\nlevel, prefix_str, ptr + i, linebuf);\r\nbreak;\r\ncase DUMP_PREFIX_OFFSET:\r\nprintk("%s%s%.8x: %s\n", level, prefix_str, i, linebuf);\r\nbreak;\r\ndefault:\r\nprintk("%s%s%s\n", level, prefix_str, linebuf);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid print_hex_dump_bytes(const char *prefix_str, int prefix_type,\r\nconst void *buf, size_t len)\r\n{\r\nprint_hex_dump(KERN_DEBUG, prefix_str, prefix_type, 16, 1,\r\nbuf, len, true);\r\n}
