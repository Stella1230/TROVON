static inline int\r\nnouveau_engctx_exists(struct nouveau_object *parent,\r\nstruct nouveau_engine *engine, void **pobject)\r\n{\r\nstruct nouveau_engctx *engctx;\r\nstruct nouveau_object *parctx;\r\nlist_for_each_entry(engctx, &engine->contexts, head) {\r\nparctx = nv_pclass(nv_object(engctx), NV_PARENT_CLASS);\r\nif (parctx == parent) {\r\natomic_inc(&nv_object(engctx)->refcount);\r\n*pobject = engctx;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_engctx_create_(struct nouveau_object *parent,\r\nstruct nouveau_object *engobj,\r\nstruct nouveau_oclass *oclass,\r\nstruct nouveau_object *pargpu,\r\nu32 size, u32 align, u32 flags,\r\nint length, void **pobject)\r\n{\r\nstruct nouveau_client *client = nouveau_client(parent);\r\nstruct nouveau_engine *engine = nv_engine(engobj);\r\nstruct nouveau_object *engctx;\r\nunsigned long save;\r\nint ret;\r\nspin_lock_irqsave(&engine->lock, save);\r\nret = nouveau_engctx_exists(parent, engine, pobject);\r\nspin_unlock_irqrestore(&engine->lock, save);\r\nif (ret)\r\nreturn ret;\r\nif (size) {\r\nret = nouveau_gpuobj_create_(parent, engobj, oclass,\r\nNV_ENGCTX_CLASS,\r\npargpu, size, align, flags,\r\nlength, pobject);\r\n} else {\r\nret = nouveau_object_create_(parent, engobj, oclass,\r\nNV_ENGCTX_CLASS, length, pobject);\r\n}\r\nengctx = *pobject;\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&engine->lock, save);\r\nret = nouveau_engctx_exists(parent, engine, pobject);\r\nif (ret) {\r\nspin_unlock_irqrestore(&engine->lock, save);\r\nnouveau_object_ref(NULL, &engctx);\r\nreturn ret;\r\n}\r\nif (client->vm)\r\natomic_inc(&client->vm->engref[nv_engidx(engobj)]);\r\nlist_add(&nv_engctx(engctx)->head, &engine->contexts);\r\nnv_engctx(engctx)->addr = ~0ULL;\r\nspin_unlock_irqrestore(&engine->lock, save);\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_engctx_destroy(struct nouveau_engctx *engctx)\r\n{\r\nstruct nouveau_object *engobj = nv_object(engctx)->engine;\r\nstruct nouveau_engine *engine = nv_engine(engobj);\r\nstruct nouveau_client *client = nouveau_client(engctx);\r\nunsigned long save;\r\nnouveau_gpuobj_unmap(&engctx->vma);\r\nspin_lock_irqsave(&engine->lock, save);\r\nlist_del(&engctx->head);\r\nspin_unlock_irqrestore(&engine->lock, save);\r\nif (client->vm)\r\natomic_dec(&client->vm->engref[nv_engidx(engobj)]);\r\nif (engctx->base.size)\r\nnouveau_gpuobj_destroy(&engctx->base);\r\nelse\r\nnouveau_object_destroy(&engctx->base.base);\r\n}\r\nint\r\nnouveau_engctx_init(struct nouveau_engctx *engctx)\r\n{\r\nstruct nouveau_object *object = nv_object(engctx);\r\nstruct nouveau_subdev *subdev = nv_subdev(object->engine);\r\nstruct nouveau_object *parent;\r\nstruct nouveau_subdev *pardev;\r\nint ret;\r\nret = nouveau_gpuobj_init(&engctx->base);\r\nif (ret)\r\nreturn ret;\r\nparent = nv_pclass(object->parent, NV_PARENT_CLASS);\r\npardev = nv_subdev(parent->engine);\r\nif (nv_parent(parent)->context_attach) {\r\nmutex_lock(&pardev->mutex);\r\nret = nv_parent(parent)->context_attach(parent, object);\r\nmutex_unlock(&pardev->mutex);\r\n}\r\nif (ret) {\r\nnv_error(parent, "failed to attach %s context, %d\n",\r\nsubdev->name, ret);\r\nreturn ret;\r\n}\r\nnv_debug(parent, "attached %s context\n", subdev->name);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_engctx_fini(struct nouveau_engctx *engctx, bool suspend)\r\n{\r\nstruct nouveau_object *object = nv_object(engctx);\r\nstruct nouveau_subdev *subdev = nv_subdev(object->engine);\r\nstruct nouveau_object *parent;\r\nstruct nouveau_subdev *pardev;\r\nint ret = 0;\r\nparent = nv_pclass(object->parent, NV_PARENT_CLASS);\r\npardev = nv_subdev(parent->engine);\r\nif (nv_parent(parent)->context_detach) {\r\nmutex_lock(&pardev->mutex);\r\nret = nv_parent(parent)->context_detach(parent, suspend, object);\r\nmutex_unlock(&pardev->mutex);\r\n}\r\nif (ret) {\r\nnv_error(parent, "failed to detach %s context, %d\n",\r\nsubdev->name, ret);\r\nreturn ret;\r\n}\r\nnv_debug(parent, "detached %s context\n", subdev->name);\r\nreturn nouveau_gpuobj_fini(&engctx->base, suspend);\r\n}\r\nint\r\n_nouveau_engctx_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_engctx *engctx;\r\nint ret;\r\nret = nouveau_engctx_create(parent, engine, oclass, NULL, 256, 256,\r\nNVOBJ_FLAG_ZERO_ALLOC, &engctx);\r\n*pobject = nv_object(engctx);\r\nreturn ret;\r\n}\r\nvoid\r\n_nouveau_engctx_dtor(struct nouveau_object *object)\r\n{\r\nnouveau_engctx_destroy(nv_engctx(object));\r\n}\r\nint\r\n_nouveau_engctx_init(struct nouveau_object *object)\r\n{\r\nreturn nouveau_engctx_init(nv_engctx(object));\r\n}\r\nint\r\n_nouveau_engctx_fini(struct nouveau_object *object, bool suspend)\r\n{\r\nreturn nouveau_engctx_fini(nv_engctx(object), suspend);\r\n}\r\nstruct nouveau_object *\r\nnouveau_engctx_get(struct nouveau_engine *engine, u64 addr)\r\n{\r\nstruct nouveau_engctx *engctx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&engine->lock, flags);\r\nlist_for_each_entry(engctx, &engine->contexts, head) {\r\nif (engctx->addr == addr) {\r\nengctx->save = flags;\r\nreturn nv_object(engctx);\r\n}\r\n}\r\nspin_unlock_irqrestore(&engine->lock, flags);\r\nreturn NULL;\r\n}\r\nvoid\r\nnouveau_engctx_put(struct nouveau_object *object)\r\n{\r\nif (object) {\r\nstruct nouveau_engine *engine = nv_engine(object->engine);\r\nstruct nouveau_engctx *engctx = nv_engctx(object);\r\nspin_unlock_irqrestore(&engine->lock, engctx->save);\r\n}\r\n}
