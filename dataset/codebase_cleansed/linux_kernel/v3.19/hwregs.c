acpi_status\r\nacpi_hw_validate_register(struct acpi_generic_address *reg,\r\nu8 max_bit_width, u64 *address)\r\n{\r\nif (!reg) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nACPI_MOVE_64_TO_64(address, &reg->address);\r\nif (!(*address)) {\r\nreturn (AE_BAD_ADDRESS);\r\n}\r\nif ((reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\r\n(reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\r\nACPI_ERROR((AE_INFO,\r\n"Unsupported address space: 0x%X", reg->space_id));\r\nreturn (AE_SUPPORT);\r\n}\r\nif ((reg->bit_width != 8) &&\r\n(reg->bit_width != 16) &&\r\n(reg->bit_width != 32) && (reg->bit_width != max_bit_width)) {\r\nACPI_ERROR((AE_INFO,\r\n"Unsupported register bit width: 0x%X",\r\nreg->bit_width));\r\nreturn (AE_SUPPORT);\r\n}\r\nif (reg->bit_offset != 0) {\r\nACPI_WARNING((AE_INFO,\r\n"Unsupported register bit offset: 0x%X",\r\nreg->bit_offset));\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_hw_read(u32 *value, struct acpi_generic_address *reg)\r\n{\r\nu64 address;\r\nu64 value64;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(hw_read);\r\nstatus = acpi_hw_validate_register(reg, 32, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*value = 0;\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_read_memory((acpi_physical_address)\r\naddress, &value64, reg->bit_width);\r\n*value = (u32)value64;\r\n} else {\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\naddress, value, reg->bit_width);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Read: %8.8X width %2d from %8.8X%8.8X (%s)\n",\r\n*value, reg->bit_width, ACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_hw_write(u32 value, struct acpi_generic_address *reg)\r\n{\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(hw_write);\r\nstatus = acpi_hw_validate_register(reg, 32, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_write_memory((acpi_physical_address)\r\naddress, (u64)value,\r\nreg->bit_width);\r\n} else {\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\naddress, value, reg->bit_width);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Wrote: %8.8X width %2d to %8.8X%8.8X (%s)\n",\r\nvalue, reg->bit_width, ACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_hw_clear_acpi_status(void)\r\n{\r\nacpi_status status;\r\nacpi_cpu_flags lock_flags = 0;\r\nACPI_FUNCTION_TRACE(hw_clear_acpi_status);\r\nACPI_DEBUG_PRINT((ACPI_DB_IO, "About to write %04X to %8.8X%8.8X\n",\r\nACPI_BITMASK_ALL_FIXED_STATUS,\r\nACPI_FORMAT_UINT64(acpi_gbl_xpm1a_status.address)));\r\nlock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);\r\nstatus = acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\r\nACPI_BITMASK_ALL_FIXED_STATUS);\r\nacpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nstatus = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);\r\nexit:\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstruct acpi_bit_register_info *acpi_hw_get_bit_register_info(u32 register_id)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif (register_id > ACPI_BITREG_MAX) {\r\nACPI_ERROR((AE_INFO, "Invalid BitRegister ID: 0x%X",\r\nregister_id));\r\nreturn (NULL);\r\n}\r\nreturn (&acpi_gbl_bit_register_info[register_id]);\r\n}\r\nacpi_status acpi_hw_write_pm1_control(u32 pm1a_control, u32 pm1b_control)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(hw_write_pm1_control);\r\nstatus =\r\nacpi_hw_write(pm1a_control, &acpi_gbl_FADT.xpm1a_control_block);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_FADT.xpm1b_control_block.address) {\r\nstatus =\r\nacpi_hw_write(pm1b_control,\r\n&acpi_gbl_FADT.xpm1b_control_block);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_hw_register_read(u32 register_id, u32 *return_value)\r\n{\r\nu32 value = 0;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(hw_register_read);\r\nswitch (register_id) {\r\ncase ACPI_REGISTER_PM1_STATUS:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_xpm1a_status,\r\n&acpi_gbl_xpm1b_status);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_ENABLE:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_xpm1a_enable,\r\n&acpi_gbl_xpm1b_enable);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_CONTROL:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nvalue &= ~ACPI_PM1_CONTROL_WRITEONLY_BITS;\r\nbreak;\r\ncase ACPI_REGISTER_PM2_CONTROL:\r\nstatus =\r\nacpi_hw_read(&value, &acpi_gbl_FADT.xpm2_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM_TIMER:\r\nstatus = acpi_hw_read(&value, &acpi_gbl_FADT.xpm_timer_block);\r\nbreak;\r\ncase ACPI_REGISTER_SMI_COMMAND_BLOCK:\r\nstatus =\r\nacpi_hw_read_port(acpi_gbl_FADT.smi_command, &value, 8);\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nif (ACPI_SUCCESS(status)) {\r\n*return_value = value;\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_hw_register_write(u32 register_id, u32 value)\r\n{\r\nacpi_status status;\r\nu32 read_value;\r\nACPI_FUNCTION_TRACE(hw_register_write);\r\nswitch (register_id) {\r\ncase ACPI_REGISTER_PM1_STATUS:\r\nvalue &= ~ACPI_PM1_STATUS_PRESERVED_BITS;\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_xpm1a_status,\r\n&acpi_gbl_xpm1b_status);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_ENABLE:\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_xpm1a_enable,\r\n&acpi_gbl_xpm1b_enable);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_CONTROL:\r\nstatus = acpi_hw_read_multiple(&read_value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nACPI_INSERT_BITS(value, ACPI_PM1_CONTROL_PRESERVED_BITS,\r\nread_value);\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM2_CONTROL:\r\nstatus =\r\nacpi_hw_read(&read_value,\r\n&acpi_gbl_FADT.xpm2_control_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nACPI_INSERT_BITS(value, ACPI_PM2_CONTROL_PRESERVED_BITS,\r\nread_value);\r\nstatus =\r\nacpi_hw_write(value, &acpi_gbl_FADT.xpm2_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM_TIMER:\r\nstatus = acpi_hw_write(value, &acpi_gbl_FADT.xpm_timer_block);\r\nbreak;\r\ncase ACPI_REGISTER_SMI_COMMAND_BLOCK:\r\nstatus =\r\nacpi_hw_write_port(acpi_gbl_FADT.smi_command, value, 8);\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nexit:\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_hw_read_multiple(u32 *value,\r\nstruct acpi_generic_address *register_a,\r\nstruct acpi_generic_address *register_b)\r\n{\r\nu32 value_a = 0;\r\nu32 value_b = 0;\r\nacpi_status status;\r\nstatus = acpi_hw_read(&value_a, register_a);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (register_b->address) {\r\nstatus = acpi_hw_read(&value_b, register_b);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n*value = (value_a | value_b);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_hw_write_multiple(u32 value,\r\nstruct acpi_generic_address *register_a,\r\nstruct acpi_generic_address *register_b)\r\n{\r\nacpi_status status;\r\nstatus = acpi_hw_write(value, register_a);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (register_b->address) {\r\nstatus = acpi_hw_write(value, register_b);\r\n}\r\nreturn (status);\r\n}
