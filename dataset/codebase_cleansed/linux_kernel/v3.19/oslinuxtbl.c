static acpi_status osl_get_last_status(acpi_status default_status)\r\n{\r\nswitch (errno) {\r\ncase EACCES:\r\ncase EPERM:\r\nreturn (AE_ACCESS);\r\ncase ENOENT:\r\nreturn (AE_NOT_FOUND);\r\ncase ENOMEM:\r\nreturn (AE_NO_MEMORY);\r\ndefault:\r\nreturn (default_status);\r\n}\r\n}\r\nacpi_status\r\nacpi_os_get_table_by_address(acpi_physical_address address,\r\nstruct acpi_table_header ** table)\r\n{\r\nu32 table_length;\r\nstruct acpi_table_header *mapped_table;\r\nstruct acpi_table_header *local_table = NULL;\r\nacpi_status status = AE_OK;\r\nstatus = osl_table_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nstatus = osl_map_table(address, NULL, &mapped_table);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ntable_length = ap_get_table_length(mapped_table);\r\nif (table_length == 0) {\r\nstatus = AE_BAD_HEADER;\r\ngoto exit;\r\n}\r\nlocal_table = calloc(1, table_length);\r\nif (!local_table) {\r\nstatus = AE_NO_MEMORY;\r\ngoto exit;\r\n}\r\nACPI_MEMCPY(local_table, mapped_table, table_length);\r\nexit:\r\nosl_unmap_table(mapped_table);\r\n*table = local_table;\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_os_get_table_by_name(char *signature,\r\nu32 instance,\r\nstruct acpi_table_header ** table,\r\nacpi_physical_address * address)\r\n{\r\nacpi_status status;\r\nstatus = osl_table_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (!gbl_dump_customized_tables) {\r\nstatus =\r\nosl_get_bios_table(signature, instance, table, address);\r\n} else {\r\nstatus = osl_get_customized_table(STATIC_TABLE_DIR, signature,\r\ninstance, table, address);\r\n}\r\nif (ACPI_FAILURE(status) && status == AE_LIMIT) {\r\nif (gbl_dump_dynamic_tables) {\r\nstatus =\r\nosl_get_customized_table(DYNAMIC_TABLE_DIR,\r\nsignature, instance, table,\r\naddress);\r\n}\r\n}\r\nreturn (status);\r\n}\r\nstatic acpi_status osl_add_table_to_list(char *signature, u32 instance)\r\n{\r\nstruct osl_table_info *new_info;\r\nstruct osl_table_info *next;\r\nu32 next_instance = 0;\r\nu8 found = FALSE;\r\nnew_info = calloc(1, sizeof(struct osl_table_info));\r\nif (!new_info) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nACPI_MOVE_NAME(new_info->signature, signature);\r\nif (!gbl_table_list_head) {\r\ngbl_table_list_head = new_info;\r\n} else {\r\nnext = gbl_table_list_head;\r\nwhile (1) {\r\nif (ACPI_COMPARE_NAME(next->signature, signature)) {\r\nif (next->instance == instance) {\r\nfound = TRUE;\r\n}\r\nif (next->instance >= next_instance) {\r\nnext_instance = next->instance + 1;\r\n}\r\n}\r\nif (!next->next) {\r\nbreak;\r\n}\r\nnext = next->next;\r\n}\r\nnext->next = new_info;\r\n}\r\nif (found) {\r\nif (instance) {\r\nfprintf(stderr,\r\n"%4.4s: Warning unmatched table instance %d, expected %d\n",\r\nsignature, instance, next_instance);\r\n}\r\ninstance = next_instance;\r\n}\r\nnew_info->instance = instance;\r\ngbl_table_count++;\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_get_table_by_index(u32 index,\r\nstruct acpi_table_header ** table,\r\nu32 *instance, acpi_physical_address * address)\r\n{\r\nstruct osl_table_info *info;\r\nacpi_status status;\r\nu32 i;\r\nstatus = osl_table_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (index >= gbl_table_count) {\r\nreturn (AE_LIMIT);\r\n}\r\ninfo = gbl_table_list_head;\r\nfor (i = 0; i < index; i++) {\r\ninfo = info->next;\r\n}\r\nstatus = acpi_os_get_table_by_name(info->signature, info->instance,\r\ntable, address);\r\nif (ACPI_SUCCESS(status)) {\r\n*instance = info->instance;\r\n}\r\nreturn (status);\r\n}\r\nstatic acpi_physical_address\r\nosl_find_rsdp_via_efi_by_keyword(FILE * file, const char *keyword)\r\n{\r\nchar buffer[80];\r\nunsigned long long address = 0;\r\nchar format[32];\r\nsnprintf(format, 32, "%s=%s", keyword, "%llx");\r\nfseek(file, 0, SEEK_SET);\r\nwhile (fgets(buffer, 80, file)) {\r\nif (sscanf(buffer, format, &address) == 1) {\r\nbreak;\r\n}\r\n}\r\nreturn ((acpi_physical_address) (address));\r\n}\r\nstatic acpi_physical_address osl_find_rsdp_via_efi(void)\r\n{\r\nFILE *file;\r\nacpi_physical_address address = 0;\r\nfile = fopen(EFI_SYSTAB, "r");\r\nif (file) {\r\naddress = osl_find_rsdp_via_efi_by_keyword(file, "ACPI20");\r\nif (!address) {\r\naddress =\r\nosl_find_rsdp_via_efi_by_keyword(file, "ACPI");\r\n}\r\nfclose(file);\r\n}\r\nreturn (address);\r\n}\r\nstatic acpi_status osl_load_rsdp(void)\r\n{\r\nstruct acpi_table_header *mapped_table;\r\nu8 *rsdp_address;\r\nacpi_physical_address rsdp_base;\r\nacpi_size rsdp_size;\r\nrsdp_size = sizeof(struct acpi_table_rsdp);\r\nif (gbl_rsdp_base) {\r\nrsdp_base = gbl_rsdp_base;\r\n} else {\r\nrsdp_base = osl_find_rsdp_via_efi();\r\n}\r\nif (!rsdp_base) {\r\nrsdp_base = ACPI_HI_RSDP_WINDOW_BASE;\r\nrsdp_size = ACPI_HI_RSDP_WINDOW_SIZE;\r\n}\r\nrsdp_address = acpi_os_map_memory(rsdp_base, rsdp_size);\r\nif (!rsdp_address) {\r\nreturn (osl_get_last_status(AE_BAD_ADDRESS));\r\n}\r\nmapped_table = ACPI_CAST_PTR(struct acpi_table_header,\r\nacpi_tb_scan_memory_for_rsdp(rsdp_address,\r\nrsdp_size));\r\nif (!mapped_table) {\r\nacpi_os_unmap_memory(rsdp_address, rsdp_size);\r\nreturn (AE_NOT_FOUND);\r\n}\r\ngbl_rsdp_address =\r\nrsdp_base + (ACPI_CAST8(mapped_table) - rsdp_address);\r\nACPI_MEMCPY(&gbl_rsdp, mapped_table, sizeof(struct acpi_table_rsdp));\r\nacpi_os_unmap_memory(rsdp_address, rsdp_size);\r\nreturn (AE_OK);\r\n}\r\nstatic u8 osl_can_use_xsdt(void)\r\n{\r\nif (gbl_revision && !acpi_gbl_do_not_use_xsdt) {\r\nreturn (TRUE);\r\n} else {\r\nreturn (FALSE);\r\n}\r\n}\r\nstatic acpi_status osl_table_initialize(void)\r\n{\r\nacpi_status status;\r\nacpi_physical_address address;\r\nif (gbl_table_list_initialized) {\r\nreturn (AE_OK);\r\n}\r\nstatus = osl_load_rsdp();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (gbl_rsdp.revision && !gbl_do_not_dump_xsdt) {\r\nif (gbl_xsdt) {\r\nfree(gbl_xsdt);\r\ngbl_xsdt = NULL;\r\n}\r\ngbl_revision = 2;\r\nstatus = osl_get_bios_table(ACPI_SIG_XSDT, 0,\r\nACPI_CAST_PTR(struct\r\nacpi_table_header *,\r\n&gbl_xsdt), &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nif (gbl_rsdp.rsdt_physical_address) {\r\nif (gbl_rsdt) {\r\nfree(gbl_rsdt);\r\ngbl_rsdt = NULL;\r\n}\r\nstatus = osl_get_bios_table(ACPI_SIG_RSDT, 0,\r\nACPI_CAST_PTR(struct\r\nacpi_table_header *,\r\n&gbl_rsdt), &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nif (gbl_fadt) {\r\nfree(gbl_fadt);\r\ngbl_fadt = NULL;\r\n}\r\nstatus = osl_get_bios_table(ACPI_SIG_FADT, 0,\r\nACPI_CAST_PTR(struct acpi_table_header *,\r\n&gbl_fadt),\r\n&gbl_fadt_address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (!gbl_dump_customized_tables) {\r\nstatus = osl_add_table_to_list(ACPI_RSDP_NAME, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nstatus = osl_add_table_to_list(ACPI_SIG_RSDT, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (gbl_revision == 2) {\r\nstatus = osl_add_table_to_list(ACPI_SIG_XSDT, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nstatus = osl_add_table_to_list(ACPI_SIG_DSDT, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nstatus = osl_add_table_to_list(ACPI_SIG_FACS, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nstatus = osl_list_bios_tables();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nstatus = osl_list_customized_tables(STATIC_TABLE_DIR);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nif (gbl_dump_dynamic_tables) {\r\nstatus = osl_list_customized_tables(DYNAMIC_TABLE_DIR);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\ngbl_table_list_initialized = TRUE;\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status osl_list_bios_tables(void)\r\n{\r\nstruct acpi_table_header *mapped_table = NULL;\r\nu8 *table_data;\r\nu8 number_of_tables;\r\nu8 item_size;\r\nacpi_physical_address table_address = 0;\r\nacpi_status status = AE_OK;\r\nu32 i;\r\nif (osl_can_use_xsdt()) {\r\nitem_size = sizeof(u64);\r\ntable_data =\r\nACPI_CAST8(gbl_xsdt) + sizeof(struct acpi_table_header);\r\nnumber_of_tables =\r\n(u8)((gbl_xsdt->header.length -\r\nsizeof(struct acpi_table_header))\r\n/ item_size);\r\n} else {\r\nitem_size = sizeof(u32);\r\ntable_data =\r\nACPI_CAST8(gbl_rsdt) + sizeof(struct acpi_table_header);\r\nnumber_of_tables =\r\n(u8)((gbl_rsdt->header.length -\r\nsizeof(struct acpi_table_header))\r\n/ item_size);\r\n}\r\nfor (i = 0; i < number_of_tables; ++i, table_data += item_size) {\r\nif (osl_can_use_xsdt()) {\r\ntable_address =\r\n(acpi_physical_address) (*ACPI_CAST64(table_data));\r\n} else {\r\ntable_address =\r\n(acpi_physical_address) (*ACPI_CAST32(table_data));\r\n}\r\nif (!table_address) {\r\ncontinue;\r\n}\r\nstatus = osl_map_table(table_address, NULL, &mapped_table);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nosl_add_table_to_list(mapped_table->signature, 0);\r\nosl_unmap_table(mapped_table);\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nosl_get_bios_table(char *signature,\r\nu32 instance,\r\nstruct acpi_table_header **table,\r\nacpi_physical_address * address)\r\n{\r\nstruct acpi_table_header *local_table = NULL;\r\nstruct acpi_table_header *mapped_table = NULL;\r\nu8 *table_data;\r\nu8 number_of_tables;\r\nu8 item_size;\r\nu32 current_instance = 0;\r\nacpi_physical_address table_address = 0;\r\nu32 table_length = 0;\r\nacpi_status status = AE_OK;\r\nu32 i;\r\nif (ACPI_COMPARE_NAME(signature, ACPI_RSDP_NAME) ||\r\nACPI_COMPARE_NAME(signature, ACPI_SIG_RSDT) ||\r\nACPI_COMPARE_NAME(signature, ACPI_SIG_XSDT) ||\r\nACPI_COMPARE_NAME(signature, ACPI_SIG_DSDT) ||\r\nACPI_COMPARE_NAME(signature, ACPI_SIG_FACS)) {\r\nif (instance > 0) {\r\nreturn (AE_LIMIT);\r\n}\r\nif (ACPI_COMPARE_NAME(signature, ACPI_SIG_DSDT)) {\r\nif ((gbl_fadt->header.length >= MIN_FADT_FOR_XDSDT) &&\r\ngbl_fadt->Xdsdt) {\r\ntable_address =\r\n(acpi_physical_address) gbl_fadt->Xdsdt;\r\n} else\r\nif ((gbl_fadt->header.length >= MIN_FADT_FOR_DSDT)\r\n&& gbl_fadt->dsdt) {\r\ntable_address =\r\n(acpi_physical_address) gbl_fadt->dsdt;\r\n}\r\n} else if (ACPI_COMPARE_NAME(signature, ACPI_SIG_FACS)) {\r\nif ((gbl_fadt->header.length >= MIN_FADT_FOR_XFACS) &&\r\ngbl_fadt->Xfacs) {\r\ntable_address =\r\n(acpi_physical_address) gbl_fadt->Xfacs;\r\n} else\r\nif ((gbl_fadt->header.length >= MIN_FADT_FOR_FACS)\r\n&& gbl_fadt->facs) {\r\ntable_address =\r\n(acpi_physical_address) gbl_fadt->facs;\r\n}\r\n} else if (ACPI_COMPARE_NAME(signature, ACPI_SIG_XSDT)) {\r\nif (!gbl_revision) {\r\nreturn (AE_BAD_SIGNATURE);\r\n}\r\ntable_address =\r\n(acpi_physical_address) gbl_rsdp.\r\nxsdt_physical_address;\r\n} else if (ACPI_COMPARE_NAME(signature, ACPI_SIG_RSDT)) {\r\ntable_address =\r\n(acpi_physical_address) gbl_rsdp.\r\nrsdt_physical_address;\r\n} else {\r\ntable_address =\r\n(acpi_physical_address) gbl_rsdp_address;\r\nsignature = ACPI_SIG_RSDP;\r\n}\r\nstatus = osl_map_table(table_address, signature, &mapped_table);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ntable_length = ap_get_table_length(mapped_table);\r\n} else {\r\nif (osl_can_use_xsdt()) {\r\nitem_size = sizeof(u64);\r\ntable_data =\r\nACPI_CAST8(gbl_xsdt) +\r\nsizeof(struct acpi_table_header);\r\nnumber_of_tables =\r\n(u8)((gbl_xsdt->header.length -\r\nsizeof(struct acpi_table_header))\r\n/ item_size);\r\n} else {\r\nitem_size = sizeof(u32);\r\ntable_data =\r\nACPI_CAST8(gbl_rsdt) +\r\nsizeof(struct acpi_table_header);\r\nnumber_of_tables =\r\n(u8)((gbl_rsdt->header.length -\r\nsizeof(struct acpi_table_header))\r\n/ item_size);\r\n}\r\nfor (i = 0; i < number_of_tables; ++i, table_data += item_size) {\r\nif (osl_can_use_xsdt()) {\r\ntable_address =\r\n(acpi_physical_address) (*ACPI_CAST64\r\n(table_data));\r\n} else {\r\ntable_address =\r\n(acpi_physical_address) (*ACPI_CAST32\r\n(table_data));\r\n}\r\nif (!table_address) {\r\ncontinue;\r\n}\r\nstatus =\r\nosl_map_table(table_address, NULL, &mapped_table);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ntable_length = mapped_table->length;\r\nif (!ACPI_COMPARE_NAME\r\n(mapped_table->signature, signature)) {\r\nosl_unmap_table(mapped_table);\r\nmapped_table = NULL;\r\ncontinue;\r\n}\r\nif (current_instance != instance) {\r\nosl_unmap_table(mapped_table);\r\nmapped_table = NULL;\r\ncurrent_instance++;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!mapped_table) {\r\nreturn (AE_LIMIT);\r\n}\r\nif (table_length == 0) {\r\nstatus = AE_BAD_HEADER;\r\ngoto exit;\r\n}\r\nlocal_table = calloc(1, table_length);\r\nif (!local_table) {\r\nstatus = AE_NO_MEMORY;\r\ngoto exit;\r\n}\r\nACPI_MEMCPY(local_table, mapped_table, table_length);\r\n*address = table_address;\r\n*table = local_table;\r\nexit:\r\nosl_unmap_table(mapped_table);\r\nreturn (status);\r\n}\r\nstatic acpi_status osl_list_customized_tables(char *directory)\r\n{\r\nvoid *table_dir;\r\nu32 instance;\r\nchar temp_name[ACPI_NAME_SIZE];\r\nchar *filename;\r\nacpi_status status = AE_OK;\r\ntable_dir = acpi_os_open_directory(directory, "*", REQUEST_FILE_ONLY);\r\nif (!table_dir) {\r\nreturn (osl_get_last_status(AE_NOT_FOUND));\r\n}\r\nwhile ((filename = acpi_os_get_next_filename(table_dir))) {\r\nstatus =\r\nosl_table_name_from_file(filename, temp_name, &instance);\r\nif (ACPI_FAILURE(status)) {\r\ncontinue;\r\n}\r\nstatus = osl_add_table_to_list(temp_name, instance);\r\nif (ACPI_FAILURE(status)) {\r\nbreak;\r\n}\r\n}\r\nacpi_os_close_directory(table_dir);\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nosl_map_table(acpi_size address,\r\nchar *signature, struct acpi_table_header **table)\r\n{\r\nstruct acpi_table_header *mapped_table;\r\nu32 length;\r\nif (!address) {\r\nreturn (AE_BAD_ADDRESS);\r\n}\r\nmapped_table =\r\nacpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!mapped_table) {\r\nfprintf(stderr, "Could not map table header at 0x%8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(address));\r\nreturn (osl_get_last_status(AE_BAD_ADDRESS));\r\n}\r\nif (signature) {\r\nif (ACPI_VALIDATE_RSDP_SIG(signature)) {\r\nif (!ACPI_VALIDATE_RSDP_SIG(mapped_table->signature)) {\r\nacpi_os_unmap_memory(mapped_table,\r\nsizeof(struct\r\nacpi_table_header));\r\nreturn (AE_BAD_SIGNATURE);\r\n}\r\n} else\r\nif (!ACPI_COMPARE_NAME(signature, mapped_table->signature))\r\n{\r\nacpi_os_unmap_memory(mapped_table,\r\nsizeof(struct acpi_table_header));\r\nreturn (AE_BAD_SIGNATURE);\r\n}\r\n}\r\nlength = ap_get_table_length(mapped_table);\r\nacpi_os_unmap_memory(mapped_table, sizeof(struct acpi_table_header));\r\nif (length == 0) {\r\nreturn (AE_BAD_HEADER);\r\n}\r\nmapped_table = acpi_os_map_memory(address, length);\r\nif (!mapped_table) {\r\nfprintf(stderr,\r\n"Could not map table at 0x%8.8X%8.8X length %8.8X\n",\r\nACPI_FORMAT_UINT64(address), length);\r\nreturn (osl_get_last_status(AE_INVALID_TABLE_LENGTH));\r\n}\r\n(void)ap_is_valid_checksum(mapped_table);\r\n*table = mapped_table;\r\nreturn (AE_OK);\r\n}\r\nstatic void osl_unmap_table(struct acpi_table_header *table)\r\n{\r\nif (table) {\r\nacpi_os_unmap_memory(table, ap_get_table_length(table));\r\n}\r\n}\r\nstatic acpi_status\r\nosl_table_name_from_file(char *filename, char *signature, u32 *instance)\r\n{\r\nif (strlen(filename) < ACPI_NAME_SIZE) {\r\nreturn (AE_BAD_SIGNATURE);\r\n}\r\nif (isdigit((int)filename[ACPI_NAME_SIZE])) {\r\nsscanf(&filename[ACPI_NAME_SIZE], "%d", instance);\r\n} else if (strlen(filename) != ACPI_NAME_SIZE) {\r\nreturn (AE_BAD_SIGNATURE);\r\n} else {\r\n*instance = 0;\r\n}\r\nACPI_MOVE_NAME(signature, filename);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nosl_read_table_from_file(char *filename,\r\nacpi_size file_offset,\r\nchar *signature, struct acpi_table_header **table)\r\n{\r\nFILE *table_file;\r\nstruct acpi_table_header header;\r\nstruct acpi_table_header *local_table = NULL;\r\nu32 table_length;\r\ns32 count;\r\nacpi_status status = AE_OK;\r\ntable_file = fopen(filename, "rb");\r\nif (table_file == NULL) {\r\nfprintf(stderr, "Could not open table file: %s\n", filename);\r\nreturn (osl_get_last_status(AE_NOT_FOUND));\r\n}\r\nfseek(table_file, file_offset, SEEK_SET);\r\ncount = fread(&header, 1, sizeof(struct acpi_table_header), table_file);\r\nif (count != sizeof(struct acpi_table_header)) {\r\nfprintf(stderr, "Could not read table header: %s\n", filename);\r\nstatus = AE_BAD_HEADER;\r\ngoto exit;\r\n}\r\nif (signature) {\r\nif (ACPI_VALIDATE_RSDP_SIG(signature)) {\r\nif (!ACPI_VALIDATE_RSDP_SIG(header.signature)) {\r\nfprintf(stderr,\r\n"Incorrect RSDP signature: found %8.8s\n",\r\nheader.signature);\r\nstatus = AE_BAD_SIGNATURE;\r\ngoto exit;\r\n}\r\n} else if (!ACPI_COMPARE_NAME(signature, header.signature)) {\r\nfprintf(stderr,\r\n"Incorrect signature: Expecting %4.4s, found %4.4s\n",\r\nsignature, header.signature);\r\nstatus = AE_BAD_SIGNATURE;\r\ngoto exit;\r\n}\r\n}\r\ntable_length = ap_get_table_length(&header);\r\nif (table_length == 0) {\r\nstatus = AE_BAD_HEADER;\r\ngoto exit;\r\n}\r\nlocal_table = calloc(1, table_length);\r\nif (!local_table) {\r\nfprintf(stderr,\r\n"%4.4s: Could not allocate buffer for table of length %X\n",\r\nheader.signature, table_length);\r\nstatus = AE_NO_MEMORY;\r\ngoto exit;\r\n}\r\nfseek(table_file, file_offset, SEEK_SET);\r\ncount = fread(local_table, 1, table_length, table_file);\r\nif (count != table_length) {\r\nfprintf(stderr, "%4.4s: Could not read table content\n",\r\nheader.signature);\r\nstatus = AE_INVALID_TABLE_LENGTH;\r\ngoto exit;\r\n}\r\n(void)ap_is_valid_checksum(local_table);\r\nexit:\r\nfclose(table_file);\r\n*table = local_table;\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nosl_get_customized_table(char *pathname,\r\nchar *signature,\r\nu32 instance,\r\nstruct acpi_table_header **table,\r\nacpi_physical_address * address)\r\n{\r\nvoid *table_dir;\r\nu32 current_instance = 0;\r\nchar temp_name[ACPI_NAME_SIZE];\r\nchar table_filename[PATH_MAX];\r\nchar *filename;\r\nacpi_status status;\r\ntable_dir = acpi_os_open_directory(pathname, "*", REQUEST_FILE_ONLY);\r\nif (!table_dir) {\r\nreturn (osl_get_last_status(AE_NOT_FOUND));\r\n}\r\nwhile ((filename = acpi_os_get_next_filename(table_dir))) {\r\nif (!ACPI_COMPARE_NAME(filename, signature)) {\r\ncontinue;\r\n}\r\nstatus =\r\nosl_table_name_from_file(filename, temp_name,\r\n&current_instance);\r\nif (ACPI_FAILURE(status) || current_instance != instance) {\r\ncontinue;\r\n}\r\nif (instance != 0) {\r\nsprintf(table_filename, "%s/%4.4s%d", pathname,\r\ntemp_name, instance);\r\n} else {\r\nsprintf(table_filename, "%s/%4.4s", pathname,\r\ntemp_name);\r\n}\r\nbreak;\r\n}\r\nacpi_os_close_directory(table_dir);\r\nif (!filename) {\r\nreturn (AE_LIMIT);\r\n}\r\n*address = 0;\r\nstatus = osl_read_table_from_file(table_filename, 0, NULL, table);\r\nreturn (status);\r\n}
