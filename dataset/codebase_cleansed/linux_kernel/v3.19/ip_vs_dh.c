static inline unsigned int ip_vs_dh_hashkey(int af, const union nf_inet_addr *addr)\r\n{\r\n__be32 addr_fold = addr->ip;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\naddr_fold = addr->ip6[0]^addr->ip6[1]^\r\naddr->ip6[2]^addr->ip6[3];\r\n#endif\r\nreturn (ntohl(addr_fold)*2654435761UL) & IP_VS_DH_TAB_MASK;\r\n}\r\nstatic inline struct ip_vs_dest *\r\nip_vs_dh_get(int af, struct ip_vs_dh_state *s, const union nf_inet_addr *addr)\r\n{\r\nreturn rcu_dereference(s->buckets[ip_vs_dh_hashkey(af, addr)].dest);\r\n}\r\nstatic int\r\nip_vs_dh_reassign(struct ip_vs_dh_state *s, struct ip_vs_service *svc)\r\n{\r\nint i;\r\nstruct ip_vs_dh_bucket *b;\r\nstruct list_head *p;\r\nstruct ip_vs_dest *dest;\r\nbool empty;\r\nb = &s->buckets[0];\r\np = &svc->destinations;\r\nempty = list_empty(p);\r\nfor (i=0; i<IP_VS_DH_TAB_SIZE; i++) {\r\ndest = rcu_dereference_protected(b->dest, 1);\r\nif (dest)\r\nip_vs_dest_put(dest);\r\nif (empty)\r\nRCU_INIT_POINTER(b->dest, NULL);\r\nelse {\r\nif (p == &svc->destinations)\r\np = p->next;\r\ndest = list_entry(p, struct ip_vs_dest, n_list);\r\nip_vs_dest_hold(dest);\r\nRCU_INIT_POINTER(b->dest, dest);\r\np = p->next;\r\n}\r\nb++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip_vs_dh_flush(struct ip_vs_dh_state *s)\r\n{\r\nint i;\r\nstruct ip_vs_dh_bucket *b;\r\nstruct ip_vs_dest *dest;\r\nb = &s->buckets[0];\r\nfor (i=0; i<IP_VS_DH_TAB_SIZE; i++) {\r\ndest = rcu_dereference_protected(b->dest, 1);\r\nif (dest) {\r\nip_vs_dest_put(dest);\r\nRCU_INIT_POINTER(b->dest, NULL);\r\n}\r\nb++;\r\n}\r\n}\r\nstatic int ip_vs_dh_init_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dh_state *s;\r\ns = kzalloc(sizeof(struct ip_vs_dh_state), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn -ENOMEM;\r\nsvc->sched_data = s;\r\nIP_VS_DBG(6, "DH hash table (memory=%Zdbytes) allocated for "\r\n"current service\n",\r\nsizeof(struct ip_vs_dh_bucket)*IP_VS_DH_TAB_SIZE);\r\nip_vs_dh_reassign(s, svc);\r\nreturn 0;\r\n}\r\nstatic void ip_vs_dh_done_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dh_state *s = svc->sched_data;\r\nip_vs_dh_flush(s);\r\nkfree_rcu(s, rcu_head);\r\nIP_VS_DBG(6, "DH hash table (memory=%Zdbytes) released\n",\r\nsizeof(struct ip_vs_dh_bucket)*IP_VS_DH_TAB_SIZE);\r\n}\r\nstatic int ip_vs_dh_dest_changed(struct ip_vs_service *svc,\r\nstruct ip_vs_dest *dest)\r\n{\r\nstruct ip_vs_dh_state *s = svc->sched_data;\r\nip_vs_dh_reassign(s, svc);\r\nreturn 0;\r\n}\r\nstatic inline int is_overloaded(struct ip_vs_dest *dest)\r\n{\r\nreturn dest->flags & IP_VS_DEST_F_OVERLOAD;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_dh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_dh_state *s;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\ns = (struct ip_vs_dh_state *) svc->sched_data;\r\ndest = ip_vs_dh_get(svc->af, s, &iph->daddr);\r\nif (!dest\r\n|| !(dest->flags & IP_VS_DEST_F_AVAILABLE)\r\n|| atomic_read(&dest->weight) <= 0\r\n|| is_overloaded(dest)) {\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\n}\r\nIP_VS_DBG_BUF(6, "DH: destination IP address %s --> server %s:%d\n",\r\nIP_VS_DBG_ADDR(svc->af, &iph->daddr),\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr),\r\nntohs(dest->port));\r\nreturn dest;\r\n}\r\nstatic int __init ip_vs_dh_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_dh_scheduler);\r\n}\r\nstatic void __exit ip_vs_dh_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_dh_scheduler);\r\nsynchronize_rcu();\r\n}
