static struct msm_bus_scale_pdata *wil_platform_get_pdata(\r\nstruct device *dev,\r\nstruct device_node *of_node)\r\n{\r\nstruct msm_bus_scale_pdata *pdata;\r\nstruct msm_bus_paths *usecase;\r\nint i, j, ret, len;\r\nunsigned int num_usecases, num_paths, mem_size;\r\nconst uint32_t *vec_arr;\r\nstruct msm_bus_vectors *vectors;\r\nret = of_property_read_u32(of_node, "qcom,msm-bus,num-cases",\r\n&num_usecases);\r\nif (ret) {\r\ndev_err(dev, "Error: num-usecases not found\n");\r\nreturn NULL;\r\n}\r\nret = of_property_read_u32(of_node, "qcom,msm-bus,num-paths",\r\n&num_paths);\r\nif (ret) {\r\ndev_err(dev, "Error: num_paths not found\n");\r\nreturn NULL;\r\n}\r\nmem_size = sizeof(struct msm_bus_scale_pdata) +\r\nsizeof(struct msm_bus_paths) * num_usecases +\r\nsizeof(struct msm_bus_vectors) * num_usecases * num_paths;\r\npdata = kzalloc(mem_size, GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nret = of_property_read_string(of_node, "qcom,msm-bus,name",\r\n&pdata->name);\r\nif (ret) {\r\ndev_err(dev, "Error: Client name not found\n");\r\ngoto err;\r\n}\r\nif (of_property_read_bool(of_node, "qcom,msm-bus,active-only")) {\r\npdata->active_only = 1;\r\n} else {\r\ndev_info(dev, "active_only flag absent.\n");\r\ndev_info(dev, "Using dual context by default\n");\r\n}\r\npdata->num_usecases = num_usecases;\r\npdata->usecase = (struct msm_bus_paths *)(pdata + 1);\r\nvec_arr = of_get_property(of_node, "qcom,msm-bus,vectors-KBps", &len);\r\nif (vec_arr == NULL) {\r\ndev_err(dev, "Error: Vector array not found\n");\r\ngoto err;\r\n}\r\nif (len != num_usecases * num_paths * sizeof(uint32_t) * 4) {\r\ndev_err(dev, "Error: Length-error on getting vectors\n");\r\ngoto err;\r\n}\r\nvectors = (struct msm_bus_vectors *)(pdata->usecase + num_usecases);\r\nfor (i = 0; i < num_usecases; i++) {\r\nusecase = &pdata->usecase[i];\r\nusecase->num_paths = num_paths;\r\nusecase->vectors = &vectors[i];\r\nfor (j = 0; j < num_paths; j++) {\r\nint index = ((i * num_paths) + j) * 4;\r\nusecase->vectors[j].src = be32_to_cpu(vec_arr[index]);\r\nusecase->vectors[j].dst =\r\nbe32_to_cpu(vec_arr[index + 1]);\r\nusecase->vectors[j].ab = (uint64_t)\r\nKBTOB(be32_to_cpu(vec_arr[index + 2]));\r\nusecase->vectors[j].ib = (uint64_t)\r\nKBTOB(be32_to_cpu(vec_arr[index + 3]));\r\n}\r\n}\r\nreturn pdata;\r\nerr:\r\nkfree(pdata);\r\nreturn NULL;\r\n}\r\nstatic int wil_platform_bus_request(void *handle,\r\nuint32_t kbps )\r\n{\r\nint rc, i;\r\nstruct wil_platform_msm *msm = (struct wil_platform_msm *)handle;\r\nint vote = 0;\r\nstruct msm_bus_paths *usecase;\r\nuint32_t usecase_kbps;\r\nuint32_t min_kbps = ~0;\r\nfor (i = 0; i < msm->pdata->num_usecases; i++) {\r\nusecase = &msm->pdata->usecase[i];\r\nusecase_kbps = div64_u64(usecase->vectors[0].ib, 1000);\r\nif (usecase_kbps >= kbps && usecase_kbps < min_kbps) {\r\nmin_kbps = usecase_kbps;\r\nvote = i;\r\n}\r\n}\r\nrc = msm_bus_scale_client_update_request(msm->msm_bus_handle, vote);\r\nif (rc)\r\ndev_err(msm->dev, "Failed msm_bus voting. kbps=%d vote=%d, rc=%d\n",\r\nkbps, vote, rc);\r\nelse\r\ndev_info(msm->dev, "msm_bus_scale_client_update_request succeeded. kbps=%d vote=%d\n",\r\nkbps, vote);\r\nreturn rc;\r\n}\r\nstatic void wil_platform_uninit(void *handle)\r\n{\r\nstruct wil_platform_msm *msm = (struct wil_platform_msm *)handle;\r\ndev_info(msm->dev, "wil_platform_uninit\n");\r\nif (msm->msm_bus_handle)\r\nmsm_bus_scale_unregister_client(msm->msm_bus_handle);\r\nkfree(msm->pdata);\r\nkfree(msm);\r\n}\r\nstatic int wil_platform_msm_bus_register(struct wil_platform_msm *msm,\r\nstruct device_node *node)\r\n{\r\nmsm->pdata = wil_platform_get_pdata(msm->dev, node);\r\nif (!msm->pdata) {\r\ndev_err(msm->dev, "Failed getting DT info\n");\r\nreturn -EINVAL;\r\n}\r\nmsm->msm_bus_handle = msm_bus_scale_register_client(msm->pdata);\r\nif (!msm->msm_bus_handle) {\r\ndev_err(msm->dev, "Failed msm_bus registration\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(msm->dev, "msm_bus registration succeeded! handle 0x%x\n",\r\nmsm->msm_bus_handle);\r\nreturn 0;\r\n}\r\nvoid *wil_platform_msm_init(struct device *dev, struct wil_platform_ops *ops)\r\n{\r\nstruct device_node *of_node;\r\nstruct wil_platform_msm *msm;\r\nint rc;\r\nof_node = of_find_compatible_node(NULL, NULL, "qcom,wil6210");\r\nif (!of_node) {\r\ndev_err(dev, "DT node not found\n");\r\nreturn NULL;\r\n}\r\nmsm = kzalloc(sizeof(*msm), GFP_KERNEL);\r\nif (!msm)\r\nreturn NULL;\r\nmsm->dev = dev;\r\nrc = wil_platform_msm_bus_register(msm, of_node);\r\nif (rc)\r\ngoto cleanup;\r\nmemset(ops, 0, sizeof(*ops));\r\nops->bus_request = wil_platform_bus_request;\r\nops->uninit = wil_platform_uninit;\r\nreturn (void *)msm;\r\ncleanup:\r\nkfree(msm);\r\nreturn NULL;\r\n}
