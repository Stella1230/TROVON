static inline int val_seg(int val)\r\n{\r\nint r = 0;\r\nval >>= 7;\r\nif (val & 0xf0) {\r\nval >>= 4;\r\nr += 4;\r\n}\r\nif (val & 0x0c) {\r\nval >>= 2;\r\nr += 2;\r\n}\r\nif (val & 0x02)\r\nr += 1;\r\nreturn r;\r\n}\r\nstatic unsigned char linear2ulaw(int pcm_val)\r\n{\r\nint mask;\r\nint seg;\r\nunsigned char uval;\r\nif (pcm_val < 0) {\r\npcm_val = BIAS - pcm_val;\r\nmask = 0x7F;\r\n} else {\r\npcm_val += BIAS;\r\nmask = 0xFF;\r\n}\r\nif (pcm_val > 0x7FFF)\r\npcm_val = 0x7FFF;\r\nseg = val_seg(pcm_val);\r\nuval = (seg << 4) | ((pcm_val >> (seg + 3)) & 0xF);\r\nreturn uval ^ mask;\r\n}\r\nstatic int ulaw2linear(unsigned char u_val)\r\n{\r\nint t;\r\nu_val = ~u_val;\r\nt = ((u_val & QUANT_MASK) << 3) + BIAS;\r\nt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\r\nreturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\r\n}\r\nstatic inline void cvt_s16_to_native(struct mulaw_priv *data,\r\nunsigned char *dst, u16 sample)\r\n{\r\nsample ^= data->flip;\r\nif (data->cvt_endian)\r\nsample = swab16(sample);\r\nif (data->native_bytes > data->copy_bytes)\r\nmemset(dst, 0, data->native_bytes);\r\nmemcpy(dst + data->native_ofs, (char *)&sample + data->copy_ofs,\r\ndata->copy_bytes);\r\n}\r\nstatic void mulaw_decode(struct snd_pcm_plugin *plugin,\r\nconst struct snd_pcm_plugin_channel *src_channels,\r\nstruct snd_pcm_plugin_channel *dst_channels,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;\r\nint channel;\r\nint nchannels = plugin->src_format.channels;\r\nfor (channel = 0; channel < nchannels; ++channel) {\r\nchar *src;\r\nchar *dst;\r\nint src_step, dst_step;\r\nsnd_pcm_uframes_t frames1;\r\nif (!src_channels[channel].enabled) {\r\nif (dst_channels[channel].wanted)\r\nsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\r\ndst_channels[channel].enabled = 0;\r\ncontinue;\r\n}\r\ndst_channels[channel].enabled = 1;\r\nsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\r\ndst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\r\nsrc_step = src_channels[channel].area.step / 8;\r\ndst_step = dst_channels[channel].area.step / 8;\r\nframes1 = frames;\r\nwhile (frames1-- > 0) {\r\nsigned short sample = ulaw2linear(*src);\r\ncvt_s16_to_native(data, dst, sample);\r\nsrc += src_step;\r\ndst += dst_step;\r\n}\r\n}\r\n}\r\nstatic inline signed short cvt_native_to_s16(struct mulaw_priv *data,\r\nunsigned char *src)\r\n{\r\nu16 sample = 0;\r\nmemcpy((char *)&sample + data->copy_ofs, src + data->native_ofs,\r\ndata->copy_bytes);\r\nif (data->cvt_endian)\r\nsample = swab16(sample);\r\nsample ^= data->flip;\r\nreturn (signed short)sample;\r\n}\r\nstatic void mulaw_encode(struct snd_pcm_plugin *plugin,\r\nconst struct snd_pcm_plugin_channel *src_channels,\r\nstruct snd_pcm_plugin_channel *dst_channels,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;\r\nint channel;\r\nint nchannels = plugin->src_format.channels;\r\nfor (channel = 0; channel < nchannels; ++channel) {\r\nchar *src;\r\nchar *dst;\r\nint src_step, dst_step;\r\nsnd_pcm_uframes_t frames1;\r\nif (!src_channels[channel].enabled) {\r\nif (dst_channels[channel].wanted)\r\nsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\r\ndst_channels[channel].enabled = 0;\r\ncontinue;\r\n}\r\ndst_channels[channel].enabled = 1;\r\nsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\r\ndst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\r\nsrc_step = src_channels[channel].area.step / 8;\r\ndst_step = dst_channels[channel].area.step / 8;\r\nframes1 = frames;\r\nwhile (frames1-- > 0) {\r\nsigned short sample = cvt_native_to_s16(data, src);\r\n*dst = linear2ulaw(sample);\r\nsrc += src_step;\r\ndst += dst_step;\r\n}\r\n}\r\n}\r\nstatic snd_pcm_sframes_t mulaw_transfer(struct snd_pcm_plugin *plugin,\r\nconst struct snd_pcm_plugin_channel *src_channels,\r\nstruct snd_pcm_plugin_channel *dst_channels,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct mulaw_priv *data;\r\nif (snd_BUG_ON(!plugin || !src_channels || !dst_channels))\r\nreturn -ENXIO;\r\nif (frames == 0)\r\nreturn 0;\r\n#ifdef CONFIG_SND_DEBUG\r\n{\r\nunsigned int channel;\r\nfor (channel = 0; channel < plugin->src_format.channels; channel++) {\r\nif (snd_BUG_ON(src_channels[channel].area.first % 8 ||\r\nsrc_channels[channel].area.step % 8))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(dst_channels[channel].area.first % 8 ||\r\ndst_channels[channel].area.step % 8))\r\nreturn -ENXIO;\r\n}\r\n}\r\n#endif\r\ndata = (struct mulaw_priv *)plugin->extra_data;\r\ndata->func(plugin, src_channels, dst_channels, frames);\r\nreturn frames;\r\n}\r\nstatic void init_data(struct mulaw_priv *data, snd_pcm_format_t format)\r\n{\r\n#ifdef SNDRV_LITTLE_ENDIAN\r\ndata->cvt_endian = snd_pcm_format_big_endian(format) > 0;\r\n#else\r\ndata->cvt_endian = snd_pcm_format_little_endian(format) > 0;\r\n#endif\r\nif (!snd_pcm_format_signed(format))\r\ndata->flip = 0x8000;\r\ndata->native_bytes = snd_pcm_format_physical_width(format) / 8;\r\ndata->copy_bytes = data->native_bytes < 2 ? 1 : 2;\r\nif (snd_pcm_format_little_endian(format)) {\r\ndata->native_ofs = data->native_bytes - data->copy_bytes;\r\ndata->copy_ofs = 2 - data->copy_bytes;\r\n} else {\r\ndata->native_ofs = data->native_bytes -\r\nsnd_pcm_format_width(format) / 8;\r\n}\r\n}\r\nint snd_pcm_plugin_build_mulaw(struct snd_pcm_substream *plug,\r\nstruct snd_pcm_plugin_format *src_format,\r\nstruct snd_pcm_plugin_format *dst_format,\r\nstruct snd_pcm_plugin **r_plugin)\r\n{\r\nint err;\r\nstruct mulaw_priv *data;\r\nstruct snd_pcm_plugin *plugin;\r\nstruct snd_pcm_plugin_format *format;\r\nmulaw_f func;\r\nif (snd_BUG_ON(!r_plugin))\r\nreturn -ENXIO;\r\n*r_plugin = NULL;\r\nif (snd_BUG_ON(src_format->rate != dst_format->rate))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(src_format->channels != dst_format->channels))\r\nreturn -ENXIO;\r\nif (dst_format->format == SNDRV_PCM_FORMAT_MU_LAW) {\r\nformat = src_format;\r\nfunc = mulaw_encode;\r\n}\r\nelse if (src_format->format == SNDRV_PCM_FORMAT_MU_LAW) {\r\nformat = dst_format;\r\nfunc = mulaw_decode;\r\n}\r\nelse {\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nif (snd_BUG_ON(!snd_pcm_format_linear(format->format)))\r\nreturn -ENXIO;\r\nerr = snd_pcm_plugin_build(plug, "Mu-Law<->linear conversion",\r\nsrc_format, dst_format,\r\nsizeof(struct mulaw_priv), &plugin);\r\nif (err < 0)\r\nreturn err;\r\ndata = (struct mulaw_priv *)plugin->extra_data;\r\ndata->func = func;\r\ninit_data(data, format->format);\r\nplugin->transfer = mulaw_transfer;\r\n*r_plugin = plugin;\r\nreturn 0;\r\n}
