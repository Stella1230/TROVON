static struct i2o_exec_wait *i2o_exec_wait_alloc(void)\r\n{\r\nstruct i2o_exec_wait *wait;\r\nwait = kzalloc(sizeof(*wait), GFP_KERNEL);\r\nif (!wait)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&wait->list);\r\nspin_lock_init(&wait->lock);\r\nreturn wait;\r\n}\r\nstatic void i2o_exec_wait_free(struct i2o_exec_wait *wait)\r\n{\r\nkfree(wait);\r\n}\r\nint i2o_msg_post_wait_mem(struct i2o_controller *c, struct i2o_message *msg,\r\nunsigned long timeout, struct i2o_dma *dma)\r\n{\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\r\nstruct i2o_exec_wait *wait;\r\nstatic u32 tcntxt = 0x80000000;\r\nunsigned long flags;\r\nint rc = 0;\r\nwait = i2o_exec_wait_alloc();\r\nif (!wait) {\r\ni2o_msg_nop(c, msg);\r\nreturn -ENOMEM;\r\n}\r\nif (tcntxt == 0xffffffff)\r\ntcntxt = 0x80000000;\r\nif (dma)\r\nwait->dma = *dma;\r\nmsg->u.s.icntxt = cpu_to_le32(i2o_exec_driver.context);\r\nwait->tcntxt = tcntxt++;\r\nmsg->u.s.tcntxt = cpu_to_le32(wait->tcntxt);\r\nwait->wq = &wq;\r\nlist_add(&wait->list, &i2o_exec_wait_list);\r\ni2o_msg_post(c, msg);\r\nwait_event_interruptible_timeout(wq, wait->complete, timeout * HZ);\r\nspin_lock_irqsave(&wait->lock, flags);\r\nwait->wq = NULL;\r\nif (wait->complete)\r\nrc = le32_to_cpu(wait->msg->body[0]) >> 24;\r\nelse {\r\nif (dma)\r\ndma->virt = NULL;\r\nrc = -ETIMEDOUT;\r\n}\r\nspin_unlock_irqrestore(&wait->lock, flags);\r\nif (rc != -ETIMEDOUT) {\r\ni2o_flush_reply(c, wait->m);\r\ni2o_exec_wait_free(wait);\r\n}\r\nreturn rc;\r\n}\r\nstatic int i2o_msg_post_wait_complete(struct i2o_controller *c, u32 m,\r\nstruct i2o_message *msg, u32 context)\r\n{\r\nstruct i2o_exec_wait *wait, *tmp;\r\nunsigned long flags;\r\nint rc = 1;\r\nlist_for_each_entry_safe(wait, tmp, &i2o_exec_wait_list, list) {\r\nif (wait->tcntxt == context) {\r\nspin_lock_irqsave(&wait->lock, flags);\r\nlist_del(&wait->list);\r\nwait->m = m;\r\nwait->msg = msg;\r\nwait->complete = 1;\r\nif (wait->wq)\r\nrc = 0;\r\nelse\r\nrc = -1;\r\nspin_unlock_irqrestore(&wait->lock, flags);\r\nif (rc) {\r\nstruct device *dev;\r\ndev = &c->pdev->dev;\r\npr_debug("%s: timedout reply received!\n",\r\nc->name);\r\ni2o_dma_free(dev, &wait->dma);\r\ni2o_exec_wait_free(wait);\r\n} else\r\nwake_up_interruptible(wait->wq);\r\nreturn rc;\r\n}\r\n}\r\nosm_warn("%s: Bogus reply in POST WAIT (tr-context: %08x)!\n", c->name,\r\ncontext);\r\nreturn -1;\r\n}\r\nstatic ssize_t i2o_exec_show_vendor_id(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2o_device *dev = to_i2o_device(d);\r\nu16 id;\r\nif (!i2o_parm_field_get(dev, 0x0000, 0, &id, 2)) {\r\nsprintf(buf, "0x%04x", le16_to_cpu(id));\r\nreturn strlen(buf) + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t i2o_exec_show_product_id(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2o_device *dev = to_i2o_device(d);\r\nu16 id;\r\nif (!i2o_parm_field_get(dev, 0x0000, 1, &id, 2)) {\r\nsprintf(buf, "0x%04x", le16_to_cpu(id));\r\nreturn strlen(buf) + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_exec_probe(struct device *dev)\r\n{\r\nstruct i2o_device *i2o_dev = to_i2o_device(dev);\r\nint rc;\r\nrc = i2o_event_register(i2o_dev, &i2o_exec_driver, 0, 0xffffffff);\r\nif (rc) goto err_out;\r\nrc = device_create_file(dev, &dev_attr_vendor_id);\r\nif (rc) goto err_evtreg;\r\nrc = device_create_file(dev, &dev_attr_product_id);\r\nif (rc) goto err_vid;\r\ni2o_dev->iop->exec = i2o_dev;\r\nreturn 0;\r\nerr_vid:\r\ndevice_remove_file(dev, &dev_attr_vendor_id);\r\nerr_evtreg:\r\ni2o_event_register(to_i2o_device(dev), &i2o_exec_driver, 0, 0);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int i2o_exec_remove(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_product_id);\r\ndevice_remove_file(dev, &dev_attr_vendor_id);\r\ni2o_event_register(to_i2o_device(dev), &i2o_exec_driver, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int i2o_exec_lct_notify(struct i2o_controller *c, u32 change_ind)\r\n{\r\ni2o_status_block *sb = c->status_block.virt;\r\nstruct device *dev;\r\nstruct i2o_message *msg;\r\nmutex_lock(&c->lct_lock);\r\ndev = &c->pdev->dev;\r\nif (i2o_dma_realloc(dev, &c->dlct,\r\nle32_to_cpu(sb->expected_lct_size))) {\r\nmutex_unlock(&c->lct_lock);\r\nreturn -ENOMEM;\r\n}\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg)) {\r\nmutex_unlock(&c->lct_lock);\r\nreturn PTR_ERR(msg);\r\n}\r\nmsg->u.head[0] = cpu_to_le32(EIGHT_WORD_MSG_SIZE | SGL_OFFSET_6);\r\nmsg->u.head[1] = cpu_to_le32(I2O_CMD_LCT_NOTIFY << 24 | HOST_TID << 12 |\r\nADAPTER_TID);\r\nmsg->u.s.icntxt = cpu_to_le32(i2o_exec_driver.context);\r\nmsg->u.s.tcntxt = cpu_to_le32(0x00000000);\r\nmsg->body[0] = cpu_to_le32(0xffffffff);\r\nmsg->body[1] = cpu_to_le32(change_ind);\r\nmsg->body[2] = cpu_to_le32(0xd0000000 | c->dlct.len);\r\nmsg->body[3] = cpu_to_le32(c->dlct.phys);\r\ni2o_msg_post(c, msg);\r\nmutex_unlock(&c->lct_lock);\r\nreturn 0;\r\n}\r\nstatic void i2o_exec_lct_modified(struct work_struct *_work)\r\n{\r\nstruct i2o_exec_lct_notify_work *work =\r\ncontainer_of(_work, struct i2o_exec_lct_notify_work, work);\r\nu32 change_ind = 0;\r\nstruct i2o_controller *c = work->c;\r\nkfree(work);\r\nif (i2o_device_parse_lct(c) != -EAGAIN)\r\nchange_ind = c->lct->change_ind + 1;\r\n#ifdef CONFIG_I2O_LCT_NOTIFY_ON_CHANGES\r\ni2o_exec_lct_notify(c, change_ind);\r\n#endif\r\n}\r\nstatic int i2o_exec_reply(struct i2o_controller *c, u32 m,\r\nstruct i2o_message *msg)\r\n{\r\nu32 context;\r\nif (le32_to_cpu(msg->u.head[0]) & MSG_FAIL) {\r\nstruct i2o_message __iomem *pmsg;\r\nu32 pm;\r\npm = le32_to_cpu(msg->body[3]);\r\npmsg = i2o_msg_in_to_virt(c, pm);\r\ncontext = readl(&pmsg->u.s.tcntxt);\r\ni2o_report_status(KERN_INFO, "i2o_core", msg);\r\ni2o_msg_nop_mfa(c, pm);\r\n} else\r\ncontext = le32_to_cpu(msg->u.s.tcntxt);\r\nif (context & 0x80000000)\r\nreturn i2o_msg_post_wait_complete(c, m, msg, context);\r\nif ((le32_to_cpu(msg->u.head[1]) >> 24) == I2O_CMD_LCT_NOTIFY) {\r\nstruct i2o_exec_lct_notify_work *work;\r\npr_debug("%s: LCT notify received\n", c->name);\r\nwork = kmalloc(sizeof(*work), GFP_ATOMIC);\r\nif (!work)\r\nreturn -ENOMEM;\r\nwork->c = c;\r\nINIT_WORK(&work->work, i2o_exec_lct_modified);\r\nqueue_work(i2o_exec_driver.event_queue, &work->work);\r\nreturn 1;\r\n}\r\nprintk(KERN_WARNING "%s: Unsolicited message reply sent to core!"\r\n"Message dumped to syslog\n", c->name);\r\ni2o_dump_message(msg);\r\nreturn -EFAULT;\r\n}\r\nstatic void i2o_exec_event(struct work_struct *work)\r\n{\r\nstruct i2o_event *evt = container_of(work, struct i2o_event, work);\r\nif (likely(evt->i2o_dev))\r\nosm_debug("Event received from device: %d\n",\r\nevt->i2o_dev->lct_data.tid);\r\nkfree(evt);\r\n}\r\nint i2o_exec_lct_get(struct i2o_controller *c)\r\n{\r\nstruct i2o_message *msg;\r\nint i = 0;\r\nint rc = -EAGAIN;\r\nfor (i = 1; i <= I2O_LCT_GET_TRIES; i++) {\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nmsg->u.head[0] =\r\ncpu_to_le32(EIGHT_WORD_MSG_SIZE | SGL_OFFSET_6);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_LCT_NOTIFY << 24 | HOST_TID << 12 |\r\nADAPTER_TID);\r\nmsg->body[0] = cpu_to_le32(0xffffffff);\r\nmsg->body[1] = cpu_to_le32(0x00000000);\r\nmsg->body[2] = cpu_to_le32(0xd0000000 | c->dlct.len);\r\nmsg->body[3] = cpu_to_le32(c->dlct.phys);\r\nrc = i2o_msg_post_wait(c, msg, I2O_TIMEOUT_LCT_GET);\r\nif (rc < 0)\r\nbreak;\r\nrc = i2o_device_parse_lct(c);\r\nif (rc != -EAGAIN)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint __init i2o_exec_init(void)\r\n{\r\nreturn i2o_driver_register(&i2o_exec_driver);\r\n}\r\nvoid i2o_exec_exit(void)\r\n{\r\ni2o_driver_unregister(&i2o_exec_driver);\r\n}
