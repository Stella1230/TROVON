static void update_crtc2(struct matrox_fb_info *minfo, unsigned int pos)\r\n{\r\nstruct matroxfb_dh_fb_info *info = minfo->crtc2.info;\r\nif (info && (info->fbcon.var.bits_per_pixel == minfo->fbcon.var.bits_per_pixel)\r\n&& (info->fbcon.var.xres_virtual == minfo->fbcon.var.xres_virtual)\r\n&& (info->fbcon.var.green.length == minfo->fbcon.var.green.length)\r\n) {\r\nswitch (minfo->fbcon.var.bits_per_pixel) {\r\ncase 16:\r\ncase 32:\r\npos = pos * 8;\r\nif (info->interlaced) {\r\nmga_outl(0x3C2C, pos);\r\nmga_outl(0x3C28, pos + minfo->fbcon.var.xres_virtual * minfo->fbcon.var.bits_per_pixel / 8);\r\n} else {\r\nmga_outl(0x3C28, pos);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void matroxfb_crtc1_panpos(struct matrox_fb_info *minfo)\r\n{\r\nif (minfo->crtc1.panpos >= 0) {\r\nunsigned long flags;\r\nint panpos;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\npanpos = minfo->crtc1.panpos;\r\nif (panpos >= 0) {\r\nunsigned int extvga_reg;\r\nminfo->crtc1.panpos = -1;\r\nextvga_reg = mga_inb(M_EXTVGA_INDEX);\r\nmga_setr(M_EXTVGA_INDEX, 0x00, panpos);\r\nif (extvga_reg != 0x00) {\r\nmga_outb(M_EXTVGA_INDEX, extvga_reg);\r\n}\r\n}\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\n}\r\nstatic irqreturn_t matrox_irq(int irq, void *dev_id)\r\n{\r\nu_int32_t status;\r\nint handled = 0;\r\nstruct matrox_fb_info *minfo = dev_id;\r\nstatus = mga_inl(M_STATUS);\r\nif (status & 0x20) {\r\nmga_outl(M_ICLEAR, 0x20);\r\nminfo->crtc1.vsync.cnt++;\r\nmatroxfb_crtc1_panpos(minfo);\r\nwake_up_interruptible(&minfo->crtc1.vsync.wait);\r\nhandled = 1;\r\n}\r\nif (status & 0x200) {\r\nmga_outl(M_ICLEAR, 0x200);\r\nminfo->crtc2.vsync.cnt++;\r\nwake_up_interruptible(&minfo->crtc2.vsync.wait);\r\nhandled = 1;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nint matroxfb_enable_irq(struct matrox_fb_info *minfo, int reenable)\r\n{\r\nu_int32_t bm;\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\r\nbm = 0x220;\r\nelse\r\nbm = 0x020;\r\nif (!test_and_set_bit(0, &minfo->irq_flags)) {\r\nif (request_irq(minfo->pcidev->irq, matrox_irq,\r\nIRQF_SHARED, "matroxfb", minfo)) {\r\nclear_bit(0, &minfo->irq_flags);\r\nreturn -EINVAL;\r\n}\r\nmga_outl(M_ICLEAR, bm);\r\nmga_outl(M_IEN, mga_inl(M_IEN) | bm);\r\n} else if (reenable) {\r\nu_int32_t ien;\r\nien = mga_inl(M_IEN);\r\nif ((ien & bm) != bm) {\r\nprintk(KERN_DEBUG "matroxfb: someone disabled IRQ [%08X]\n", ien);\r\nmga_outl(M_IEN, ien | bm);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void matroxfb_disable_irq(struct matrox_fb_info *minfo)\r\n{\r\nif (test_and_clear_bit(0, &minfo->irq_flags)) {\r\nmatroxfb_crtc1_panpos(minfo);\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\r\nmga_outl(M_IEN, mga_inl(M_IEN) & ~0x220);\r\nelse\r\nmga_outl(M_IEN, mga_inl(M_IEN) & ~0x20);\r\nfree_irq(minfo->pcidev->irq, minfo);\r\n}\r\n}\r\nint matroxfb_wait_for_sync(struct matrox_fb_info *minfo, u_int32_t crtc)\r\n{\r\nstruct matrox_vsync *vs;\r\nunsigned int cnt;\r\nint ret;\r\nswitch (crtc) {\r\ncase 0:\r\nvs = &minfo->crtc1.vsync;\r\nbreak;\r\ncase 1:\r\nif (minfo->devflags.accelerator != FB_ACCEL_MATROX_MGAG400) {\r\nreturn -ENODEV;\r\n}\r\nvs = &minfo->crtc2.vsync;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nret = matroxfb_enable_irq(minfo, 0);\r\nif (ret) {\r\nreturn ret;\r\n}\r\ncnt = vs->cnt;\r\nret = wait_event_interruptible_timeout(vs->wait, cnt != vs->cnt, HZ/10);\r\nif (ret < 0) {\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\nmatroxfb_enable_irq(minfo, 1);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void matrox_pan_var(struct matrox_fb_info *minfo,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nunsigned int pos;\r\nunsigned short p0, p1, p2;\r\nunsigned int p3;\r\nint vbl;\r\nunsigned long flags;\r\nCRITFLAGS\r\nDBG(__func__)\r\nif (minfo->dead)\r\nreturn;\r\nminfo->fbcon.var.xoffset = var->xoffset;\r\nminfo->fbcon.var.yoffset = var->yoffset;\r\npos = (minfo->fbcon.var.yoffset * minfo->fbcon.var.xres_virtual + minfo->fbcon.var.xoffset) * minfo->curr.final_bppShift / 32;\r\npos += minfo->curr.ydstorg.chunks;\r\np0 = minfo->hw.CRTC[0x0D] = pos & 0xFF;\r\np1 = minfo->hw.CRTC[0x0C] = (pos & 0xFF00) >> 8;\r\np2 = minfo->hw.CRTCEXT[0] = (minfo->hw.CRTCEXT[0] & 0xB0) | ((pos >> 16) & 0x0F) | ((pos >> 14) & 0x40);\r\np3 = minfo->hw.CRTCEXT[8] = pos >> 21;\r\nvbl = (var->activate & FB_ACTIVATE_VBL) && (matroxfb_enable_irq(minfo, 0) == 0);\r\nCRITBEGIN\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nmga_setr(M_CRTC_INDEX, 0x0D, p0);\r\nmga_setr(M_CRTC_INDEX, 0x0C, p1);\r\nif (minfo->devflags.support32MB)\r\nmga_setr(M_EXTVGA_INDEX, 0x08, p3);\r\nif (vbl) {\r\nminfo->crtc1.panpos = p2;\r\n} else {\r\nminfo->crtc1.panpos = -1;\r\nmga_setr(M_EXTVGA_INDEX, 0x00, p2);\r\n}\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\nupdate_crtc2(minfo, pos);\r\nCRITEND\r\n}\r\nstatic void matroxfb_remove(struct matrox_fb_info *minfo, int dummy)\r\n{\r\nminfo->dead = 1;\r\nif (minfo->usecount) {\r\nreturn;\r\n}\r\nmatroxfb_unregister_device(minfo);\r\nunregister_framebuffer(&minfo->fbcon);\r\nmatroxfb_g450_shutdown(minfo);\r\n#ifdef CONFIG_MTRR\r\nif (minfo->mtrr.vram_valid)\r\nmtrr_del(minfo->mtrr.vram, minfo->video.base, minfo->video.len);\r\n#endif\r\nmga_iounmap(minfo->mmio.vbase);\r\nmga_iounmap(minfo->video.vbase);\r\nrelease_mem_region(minfo->video.base, minfo->video.len_maximum);\r\nrelease_mem_region(minfo->mmio.base, 16384);\r\nkfree(minfo);\r\n}\r\nstatic int matroxfb_open(struct fb_info *info, int user)\r\n{\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG_LOOP(__func__)\r\nif (minfo->dead) {\r\nreturn -ENXIO;\r\n}\r\nminfo->usecount++;\r\nif (user) {\r\nminfo->userusecount++;\r\n}\r\nreturn(0);\r\n}\r\nstatic int matroxfb_release(struct fb_info *info, int user)\r\n{\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG_LOOP(__func__)\r\nif (user) {\r\nif (0 == --minfo->userusecount) {\r\nmatroxfb_disable_irq(minfo);\r\n}\r\n}\r\nif (!(--minfo->usecount) && minfo->dead) {\r\nmatroxfb_remove(minfo, 0);\r\n}\r\nreturn(0);\r\n}\r\nstatic int matroxfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info* info) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG(__func__)\r\nmatrox_pan_var(minfo, var);\r\nreturn 0;\r\n}\r\nstatic int matroxfb_get_final_bppShift(const struct matrox_fb_info *minfo,\r\nint bpp)\r\n{\r\nint bppshft2;\r\nDBG(__func__)\r\nbppshft2 = bpp;\r\nif (!bppshft2) {\r\nreturn 8;\r\n}\r\nif (isInterleave(minfo))\r\nbppshft2 >>= 1;\r\nif (minfo->devflags.video64bits)\r\nbppshft2 >>= 1;\r\nreturn bppshft2;\r\n}\r\nstatic int matroxfb_test_and_set_rounding(const struct matrox_fb_info *minfo,\r\nint xres, int bpp)\r\n{\r\nint over;\r\nint rounding;\r\nDBG(__func__)\r\nswitch (bpp) {\r\ncase 0: return xres;\r\ncase 4: rounding = 128;\r\nbreak;\r\ncase 8: rounding = 64;\r\nbreak;\r\ncase 16: rounding = 32;\r\nbreak;\r\ncase 24: rounding = 64;\r\nbreak;\r\ndefault: rounding = 16;\r\nif (minfo->devflags.accelerator == FB_ACCEL_MATROX_MGAG400)\r\nrounding = 32;\r\nbreak;\r\n}\r\nif (isInterleave(minfo)) {\r\nrounding *= 2;\r\n}\r\nover = xres % rounding;\r\nif (over)\r\nxres += rounding-over;\r\nreturn xres;\r\n}\r\nstatic int matroxfb_pitch_adjust(const struct matrox_fb_info *minfo, int xres,\r\nint bpp)\r\n{\r\nconst int* width;\r\nint xres_new;\r\nDBG(__func__)\r\nif (!bpp) return xres;\r\nwidth = minfo->capable.vxres;\r\nif (minfo->devflags.precise_width) {\r\nwhile (*width) {\r\nif ((*width >= xres) && (matroxfb_test_and_set_rounding(minfo, *width, bpp) == *width)) {\r\nbreak;\r\n}\r\nwidth++;\r\n}\r\nxres_new = *width;\r\n} else {\r\nxres_new = matroxfb_test_and_set_rounding(minfo, xres, bpp);\r\n}\r\nreturn xres_new;\r\n}\r\nstatic int matroxfb_get_cmap_len(struct fb_var_screeninfo *var) {\r\nDBG(__func__)\r\nswitch (var->bits_per_pixel) {\r\ncase 4:\r\nreturn 16;\r\ncase 8:\r\nreturn 256;\r\ncase 16:\r\nreturn 16;\r\ncase 24:\r\nreturn 16;\r\ncase 32:\r\nreturn 16;\r\n}\r\nreturn 16;\r\n}\r\nstatic int matroxfb_decode_var(const struct matrox_fb_info *minfo,\r\nstruct fb_var_screeninfo *var, int *visual,\r\nint *video_cmap_len, unsigned int* ydstorg)\r\n{\r\nstruct RGBT {\r\nunsigned char bpp;\r\nstruct {\r\nunsigned char offset,\r\nlength;\r\n} red,\r\ngreen,\r\nblue,\r\ntransp;\r\nsigned char visual;\r\n};\r\nstatic const struct RGBT table[]= {\r\n{ 8,{ 0,8},{0,8},{0,8},{ 0,0},MX_VISUAL_PSEUDOCOLOR},\r\n{15,{10,5},{5,5},{0,5},{15,1},MX_VISUAL_DIRECTCOLOR},\r\n{16,{11,5},{5,6},{0,5},{ 0,0},MX_VISUAL_DIRECTCOLOR},\r\n{24,{16,8},{8,8},{0,8},{ 0,0},MX_VISUAL_DIRECTCOLOR},\r\n{32,{16,8},{8,8},{0,8},{24,8},MX_VISUAL_DIRECTCOLOR}\r\n};\r\nstruct RGBT const *rgbt;\r\nunsigned int bpp = var->bits_per_pixel;\r\nunsigned int vramlen;\r\nunsigned int memlen;\r\nDBG(__func__)\r\nswitch (bpp) {\r\ncase 4: if (!minfo->capable.cfb4) return -EINVAL;\r\nbreak;\r\ncase 8: break;\r\ncase 16: break;\r\ncase 24: break;\r\ncase 32: break;\r\ndefault: return -EINVAL;\r\n}\r\n*ydstorg = 0;\r\nvramlen = minfo->video.len_usable;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nvar->xres_virtual = matroxfb_pitch_adjust(minfo, var->xres_virtual, bpp);\r\nmemlen = var->xres_virtual * bpp * var->yres_virtual / 8;\r\nif (memlen > vramlen) {\r\nvar->yres_virtual = vramlen * 8 / (var->xres_virtual * bpp);\r\nmemlen = var->xres_virtual * bpp * var->yres_virtual / 8;\r\n}\r\nif (!minfo->capable.cross4MB && (memlen > 0x400000)) {\r\nif (bpp == 24) {\r\n} else {\r\nunsigned int linelen;\r\nunsigned int m1 = linelen = var->xres_virtual * bpp / 8;\r\nunsigned int m2 = PAGE_SIZE;\r\nunsigned int max_yres;\r\nwhile (m1) {\r\nint t;\r\nwhile (m2 >= m1) m2 -= m1;\r\nt = m1;\r\nm1 = m2;\r\nm2 = t;\r\n}\r\nm2 = linelen * PAGE_SIZE / m2;\r\n*ydstorg = m2 = 0x400000 % m2;\r\nmax_yres = (vramlen - m2) / linelen;\r\nif (var->yres_virtual > max_yres)\r\nvar->yres_virtual = max_yres;\r\n}\r\n}\r\nif (var->yres_virtual > 32767)\r\nvar->yres_virtual = 32767;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres = var->yres_virtual;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres = var->xres_virtual;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nif (bpp == 16 && var->green.length == 5) {\r\nbpp--;\r\n}\r\nfor (rgbt = table; rgbt->bpp < bpp; rgbt++);\r\n#define SETCLR(clr)\\r\nvar->clr.offset = rgbt->clr.offset;\\r\nvar->clr.length = rgbt->clr.length\r\nSETCLR(red);\r\nSETCLR(green);\r\nSETCLR(blue);\r\nSETCLR(transp);\r\n#undef SETCLR\r\n*visual = rgbt->visual;\r\nif (bpp > 8)\r\ndprintk("matroxfb: truecolor: "\r\n"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",\r\nvar->transp.length, var->red.length, var->green.length, var->blue.length,\r\nvar->transp.offset, var->red.offset, var->green.offset, var->blue.offset);\r\n*video_cmap_len = matroxfb_get_cmap_len(var);\r\ndprintk(KERN_INFO "requested %d*%d/%dbpp (%d*%d)\n", var->xres, var->yres, var->bits_per_pixel,\r\nvar->xres_virtual, var->yres_virtual);\r\nreturn 0;\r\n}\r\nstatic int matroxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *fb_info)\r\n{\r\nstruct matrox_fb_info* minfo = container_of(fb_info, struct matrox_fb_info, fbcon);\r\nDBG(__func__)\r\nif (regno >= minfo->curr.cmap_len)\r\nreturn 1;\r\nif (minfo->fbcon.var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nred = CNVT_TOHW(red, minfo->fbcon.var.red.length);\r\ngreen = CNVT_TOHW(green, minfo->fbcon.var.green.length);\r\nblue = CNVT_TOHW(blue, minfo->fbcon.var.blue.length);\r\ntransp = CNVT_TOHW(transp, minfo->fbcon.var.transp.length);\r\nswitch (minfo->fbcon.var.bits_per_pixel) {\r\ncase 4:\r\ncase 8:\r\nmga_outb(M_DAC_REG, regno);\r\nmga_outb(M_DAC_VAL, red);\r\nmga_outb(M_DAC_VAL, green);\r\nmga_outb(M_DAC_VAL, blue);\r\nbreak;\r\ncase 16:\r\nif (regno >= 16)\r\nbreak;\r\n{\r\nu_int16_t col =\r\n(red << minfo->fbcon.var.red.offset) |\r\n(green << minfo->fbcon.var.green.offset) |\r\n(blue << minfo->fbcon.var.blue.offset) |\r\n(transp << minfo->fbcon.var.transp.offset);\r\nminfo->cmap[regno] = col | (col << 16);\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nif (regno >= 16)\r\nbreak;\r\nminfo->cmap[regno] =\r\n(red << minfo->fbcon.var.red.offset) |\r\n(green << minfo->fbcon.var.green.offset) |\r\n(blue << minfo->fbcon.var.blue.offset) |\r\n(transp << minfo->fbcon.var.transp.offset);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void matroxfb_init_fix(struct matrox_fb_info *minfo)\r\n{\r\nstruct fb_fix_screeninfo *fix = &minfo->fbcon.fix;\r\nDBG(__func__)\r\nstrcpy(fix->id,"MATROX");\r\nfix->xpanstep = 8;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->mmio_start = minfo->mmio.base;\r\nfix->mmio_len = minfo->mmio.len;\r\nfix->accel = minfo->devflags.accelerator;\r\n}\r\nstatic void matroxfb_update_fix(struct matrox_fb_info *minfo)\r\n{\r\nstruct fb_fix_screeninfo *fix = &minfo->fbcon.fix;\r\nDBG(__func__)\r\nmutex_lock(&minfo->fbcon.mm_lock);\r\nfix->smem_start = minfo->video.base + minfo->curr.ydstorg.bytes;\r\nfix->smem_len = minfo->video.len_usable - minfo->curr.ydstorg.bytes;\r\nmutex_unlock(&minfo->fbcon.mm_lock);\r\n}\r\nstatic int matroxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint err;\r\nint visual;\r\nint cmap_len;\r\nunsigned int ydstorg;\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nif (minfo->dead) {\r\nreturn -ENXIO;\r\n}\r\nif ((err = matroxfb_decode_var(minfo, var, &visual, &cmap_len, &ydstorg)) != 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int matroxfb_set_par(struct fb_info *info)\r\n{\r\nint err;\r\nint visual;\r\nint cmap_len;\r\nunsigned int ydstorg;\r\nstruct fb_var_screeninfo *var;\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG(__func__)\r\nif (minfo->dead) {\r\nreturn -ENXIO;\r\n}\r\nvar = &info->var;\r\nif ((err = matroxfb_decode_var(minfo, var, &visual, &cmap_len, &ydstorg)) != 0)\r\nreturn err;\r\nminfo->fbcon.screen_base = vaddr_va(minfo->video.vbase) + ydstorg;\r\nmatroxfb_update_fix(minfo);\r\nminfo->fbcon.fix.visual = visual;\r\nminfo->fbcon.fix.type = FB_TYPE_PACKED_PIXELS;\r\nminfo->fbcon.fix.type_aux = 0;\r\nminfo->fbcon.fix.line_length = (var->xres_virtual * var->bits_per_pixel) >> 3;\r\n{\r\nunsigned int pos;\r\nminfo->curr.cmap_len = cmap_len;\r\nydstorg += minfo->devflags.ydstorg;\r\nminfo->curr.ydstorg.bytes = ydstorg;\r\nminfo->curr.ydstorg.chunks = ydstorg >> (isInterleave(minfo) ? 3 : 2);\r\nif (var->bits_per_pixel == 4)\r\nminfo->curr.ydstorg.pixels = ydstorg;\r\nelse\r\nminfo->curr.ydstorg.pixels = (ydstorg * 8) / var->bits_per_pixel;\r\nminfo->curr.final_bppShift = matroxfb_get_final_bppShift(minfo, var->bits_per_pixel);\r\n{ struct my_timming mt;\r\nstruct matrox_hw_state* hw;\r\nint out;\r\nmatroxfb_var2my(var, &mt);\r\nmt.crtc = MATROXFB_SRC_CRTC1;\r\nswitch (var->bits_per_pixel) {\r\ncase 0: mt.delay = 31 + 0; break;\r\ncase 16: mt.delay = 21 + 8; break;\r\ncase 24: mt.delay = 17 + 8; break;\r\ncase 32: mt.delay = 16 + 8; break;\r\ndefault: mt.delay = 31 + 8; break;\r\n}\r\nhw = &minfo->hw;\r\ndown_read(&minfo->altout.lock);\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\r\nminfo->outputs[out].output->compute) {\r\nminfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);\r\n}\r\n}\r\nup_read(&minfo->altout.lock);\r\nminfo->crtc1.pixclock = mt.pixclock;\r\nminfo->crtc1.mnp = mt.mnp;\r\nminfo->hw_switch->init(minfo, &mt);\r\npos = (var->yoffset * var->xres_virtual + var->xoffset) * minfo->curr.final_bppShift / 32;\r\npos += minfo->curr.ydstorg.chunks;\r\nhw->CRTC[0x0D] = pos & 0xFF;\r\nhw->CRTC[0x0C] = (pos & 0xFF00) >> 8;\r\nhw->CRTCEXT[0] = (hw->CRTCEXT[0] & 0xF0) | ((pos >> 16) & 0x0F) | ((pos >> 14) & 0x40);\r\nhw->CRTCEXT[8] = pos >> 21;\r\nminfo->hw_switch->restore(minfo);\r\nupdate_crtc2(minfo, pos);\r\ndown_read(&minfo->altout.lock);\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\r\nminfo->outputs[out].output->program) {\r\nminfo->outputs[out].output->program(minfo->outputs[out].data);\r\n}\r\n}\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&\r\nminfo->outputs[out].output->start) {\r\nminfo->outputs[out].output->start(minfo->outputs[out].data);\r\n}\r\n}\r\nup_read(&minfo->altout.lock);\r\nmatrox_cfbX_init(minfo);\r\n}\r\n}\r\nminfo->initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int matroxfb_get_vblank(struct matrox_fb_info *minfo,\r\nstruct fb_vblank *vblank)\r\n{\r\nunsigned int sts1;\r\nmatroxfb_enable_irq(minfo, 0);\r\nmemset(vblank, 0, sizeof(*vblank));\r\nvblank->flags = FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC |\r\nFB_VBLANK_HAVE_VBLANK | FB_VBLANK_HAVE_HBLANK;\r\nsts1 = mga_inb(M_INSTS1);\r\nvblank->vcount = mga_inl(M_VCOUNT);\r\nif (sts1 & 1)\r\nvblank->flags |= FB_VBLANK_HBLANKING;\r\nif (sts1 & 8)\r\nvblank->flags |= FB_VBLANK_VSYNCING;\r\nif (vblank->vcount >= minfo->fbcon.var.yres)\r\nvblank->flags |= FB_VBLANK_VBLANKING;\r\nif (test_bit(0, &minfo->irq_flags)) {\r\nvblank->flags |= FB_VBLANK_HAVE_COUNT;\r\nvblank->count = minfo->crtc1.vsync.cnt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int matroxfb_ioctl(struct fb_info *info,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG(__func__)\r\nif (minfo->dead) {\r\nreturn -ENXIO;\r\n}\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK:\r\n{\r\nstruct fb_vblank vblank;\r\nint err;\r\nerr = matroxfb_get_vblank(minfo, &vblank);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(argp, &vblank, sizeof(vblank)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase FBIO_WAITFORVSYNC:\r\n{\r\nu_int32_t crt;\r\nif (get_user(crt, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn matroxfb_wait_for_sync(minfo, crt);\r\n}\r\ncase MATROXFB_SET_OUTPUT_MODE:\r\n{\r\nstruct matroxioc_output_mode mom;\r\nstruct matrox_altout *oproc;\r\nint val;\r\nif (copy_from_user(&mom, argp, sizeof(mom)))\r\nreturn -EFAULT;\r\nif (mom.output >= MATROXFB_MAX_OUTPUTS)\r\nreturn -ENXIO;\r\ndown_read(&minfo->altout.lock);\r\noproc = minfo->outputs[mom.output].output;\r\nif (!oproc) {\r\nval = -ENXIO;\r\n} else if (!oproc->verifymode) {\r\nif (mom.mode == MATROXFB_OUTPUT_MODE_MONITOR) {\r\nval = 0;\r\n} else {\r\nval = -EINVAL;\r\n}\r\n} else {\r\nval = oproc->verifymode(minfo->outputs[mom.output].data, mom.mode);\r\n}\r\nif (!val) {\r\nif (minfo->outputs[mom.output].mode != mom.mode) {\r\nminfo->outputs[mom.output].mode = mom.mode;\r\nval = 1;\r\n}\r\n}\r\nup_read(&minfo->altout.lock);\r\nif (val != 1)\r\nreturn val;\r\nswitch (minfo->outputs[mom.output].src) {\r\ncase MATROXFB_SRC_CRTC1:\r\nmatroxfb_set_par(info);\r\nbreak;\r\ncase MATROXFB_SRC_CRTC2:\r\n{\r\nstruct matroxfb_dh_fb_info* crtc2;\r\ndown_read(&minfo->crtc2.lock);\r\ncrtc2 = minfo->crtc2.info;\r\nif (crtc2)\r\ncrtc2->fbcon.fbops->fb_set_par(&crtc2->fbcon);\r\nup_read(&minfo->crtc2.lock);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_OUTPUT_MODE:\r\n{\r\nstruct matroxioc_output_mode mom;\r\nstruct matrox_altout *oproc;\r\nint val;\r\nif (copy_from_user(&mom, argp, sizeof(mom)))\r\nreturn -EFAULT;\r\nif (mom.output >= MATROXFB_MAX_OUTPUTS)\r\nreturn -ENXIO;\r\ndown_read(&minfo->altout.lock);\r\noproc = minfo->outputs[mom.output].output;\r\nif (!oproc) {\r\nval = -ENXIO;\r\n} else {\r\nmom.mode = minfo->outputs[mom.output].mode;\r\nval = 0;\r\n}\r\nup_read(&minfo->altout.lock);\r\nif (val)\r\nreturn val;\r\nif (copy_to_user(argp, &mom, sizeof(mom)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase MATROXFB_SET_OUTPUT_CONNECTION:\r\n{\r\nu_int32_t tmp;\r\nint i;\r\nint changes;\r\nif (copy_from_user(&tmp, argp, sizeof(tmp)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 32; i++) {\r\nif (tmp & (1 << i)) {\r\nif (i >= MATROXFB_MAX_OUTPUTS)\r\nreturn -ENXIO;\r\nif (!minfo->outputs[i].output)\r\nreturn -ENXIO;\r\nswitch (minfo->outputs[i].src) {\r\ncase MATROXFB_SRC_NONE:\r\ncase MATROXFB_SRC_CRTC1:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nif (minfo->devflags.panellink) {\r\nif (tmp & MATROXFB_OUTPUT_CONN_DFP) {\r\nif (tmp & MATROXFB_OUTPUT_CONN_SECONDARY)\r\nreturn -EINVAL;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nif (minfo->outputs[i].src == MATROXFB_SRC_CRTC2) {\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\n}\r\nchanges = 0;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nif (tmp & (1 << i)) {\r\nif (minfo->outputs[i].src != MATROXFB_SRC_CRTC1) {\r\nchanges = 1;\r\nminfo->outputs[i].src = MATROXFB_SRC_CRTC1;\r\n}\r\n} else if (minfo->outputs[i].src == MATROXFB_SRC_CRTC1) {\r\nchanges = 1;\r\nminfo->outputs[i].src = MATROXFB_SRC_NONE;\r\n}\r\n}\r\nif (!changes)\r\nreturn 0;\r\nmatroxfb_set_par(info);\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_OUTPUT_CONNECTION:\r\n{\r\nu_int32_t conn = 0;\r\nint i;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nif (minfo->outputs[i].src == MATROXFB_SRC_CRTC1) {\r\nconn |= 1 << i;\r\n}\r\n}\r\nif (put_user(conn, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_AVAILABLE_OUTPUTS:\r\n{\r\nu_int32_t conn = 0;\r\nint i;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nif (minfo->outputs[i].output) {\r\nswitch (minfo->outputs[i].src) {\r\ncase MATROXFB_SRC_NONE:\r\ncase MATROXFB_SRC_CRTC1:\r\nconn |= 1 << i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (minfo->devflags.panellink) {\r\nif (conn & MATROXFB_OUTPUT_CONN_DFP)\r\nconn &= ~MATROXFB_OUTPUT_CONN_SECONDARY;\r\nif (conn & MATROXFB_OUTPUT_CONN_SECONDARY)\r\nconn &= ~MATROXFB_OUTPUT_CONN_DFP;\r\n}\r\nif (put_user(conn, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_ALL_OUTPUTS:\r\n{\r\nu_int32_t conn = 0;\r\nint i;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nif (minfo->outputs[i].output) {\r\nconn |= 1 << i;\r\n}\r\n}\r\nif (put_user(conn, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase VIDIOC_QUERYCAP:\r\n{\r\nstruct v4l2_capability r;\r\nmemset(&r, 0, sizeof(r));\r\nstrcpy(r.driver, "matroxfb");\r\nstrcpy(r.card, "Matrox");\r\nsprintf(r.bus_info, "PCI:%s", pci_name(minfo->pcidev));\r\nr.version = KERNEL_VERSION(1,0,0);\r\nr.capabilities = V4L2_CAP_VIDEO_OUTPUT;\r\nif (copy_to_user(argp, &r, sizeof(r)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct v4l2_queryctrl qctrl;\r\nint err;\r\nif (copy_from_user(&qctrl, argp, sizeof(qctrl)))\r\nreturn -EFAULT;\r\ndown_read(&minfo->altout.lock);\r\nif (!minfo->outputs[1].output) {\r\nerr = -ENXIO;\r\n} else if (minfo->outputs[1].output->getqueryctrl) {\r\nerr = minfo->outputs[1].output->getqueryctrl(minfo->outputs[1].data, &qctrl);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nup_read(&minfo->altout.lock);\r\nif (err >= 0 &&\r\ncopy_to_user(argp, &qctrl, sizeof(qctrl)))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control ctrl;\r\nint err;\r\nif (copy_from_user(&ctrl, argp, sizeof(ctrl)))\r\nreturn -EFAULT;\r\ndown_read(&minfo->altout.lock);\r\nif (!minfo->outputs[1].output) {\r\nerr = -ENXIO;\r\n} else if (minfo->outputs[1].output->getctrl) {\r\nerr = minfo->outputs[1].output->getctrl(minfo->outputs[1].data, &ctrl);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nup_read(&minfo->altout.lock);\r\nif (err >= 0 &&\r\ncopy_to_user(argp, &ctrl, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control ctrl;\r\nint err;\r\nif (copy_from_user(&ctrl, argp, sizeof(ctrl)))\r\nreturn -EFAULT;\r\ndown_read(&minfo->altout.lock);\r\nif (!minfo->outputs[1].output) {\r\nerr = -ENXIO;\r\n} else if (minfo->outputs[1].output->setctrl) {\r\nerr = minfo->outputs[1].output->setctrl(minfo->outputs[1].data, &ctrl);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nup_read(&minfo->altout.lock);\r\nreturn err;\r\n}\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int matroxfb_blank(int blank, struct fb_info *info)\r\n{\r\nint seq;\r\nint crtc;\r\nCRITFLAGS\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG(__func__)\r\nif (minfo->dead)\r\nreturn 1;\r\nswitch (blank) {\r\ncase FB_BLANK_NORMAL: seq = 0x20; crtc = 0x00; break;\r\ncase FB_BLANK_VSYNC_SUSPEND: seq = 0x20; crtc = 0x10; break;\r\ncase FB_BLANK_HSYNC_SUSPEND: seq = 0x20; crtc = 0x20; break;\r\ncase FB_BLANK_POWERDOWN: seq = 0x20; crtc = 0x30; break;\r\ndefault: seq = 0x00; crtc = 0x00; break;\r\n}\r\nCRITBEGIN\r\nmga_outb(M_SEQ_INDEX, 1);\r\nmga_outb(M_SEQ_DATA, (mga_inb(M_SEQ_DATA) & ~0x20) | seq);\r\nmga_outb(M_EXTVGA_INDEX, 1);\r\nmga_outb(M_EXTVGA_DATA, (mga_inb(M_EXTVGA_DATA) & ~0x30) | crtc);\r\nCRITEND\r\nreturn 0;\r\n}\r\nstatic int matroxfb_getmemory(struct matrox_fb_info *minfo,\r\nunsigned int maxSize, unsigned int *realSize)\r\n{\r\nvaddr_t vm;\r\nunsigned int offs;\r\nunsigned int offs2;\r\nunsigned char orig;\r\nunsigned char bytes[32];\r\nunsigned char* tmp;\r\nDBG(__func__)\r\nvm = minfo->video.vbase;\r\nmaxSize &= ~0x1FFFFF;\r\nif (maxSize < 0x0200000) return 0;\r\nif (maxSize > 0x2000000) maxSize = 0x2000000;\r\nmga_outb(M_EXTVGA_INDEX, 0x03);\r\norig = mga_inb(M_EXTVGA_DATA);\r\nmga_outb(M_EXTVGA_DATA, orig | 0x80);\r\ntmp = bytes;\r\nfor (offs = 0x100000; offs < maxSize; offs += 0x200000)\r\n*tmp++ = mga_readb(vm, offs);\r\nfor (offs = 0x100000; offs < maxSize; offs += 0x200000)\r\nmga_writeb(vm, offs, 0x02);\r\nmga_outb(M_CACHEFLUSH, 0x00);\r\nfor (offs = 0x100000; offs < maxSize; offs += 0x200000) {\r\nif (mga_readb(vm, offs) != 0x02)\r\nbreak;\r\nmga_writeb(vm, offs, mga_readb(vm, offs) - 0x02);\r\nif (mga_readb(vm, offs))\r\nbreak;\r\n}\r\ntmp = bytes;\r\nfor (offs2 = 0x100000; offs2 < maxSize; offs2 += 0x200000)\r\nmga_writeb(vm, offs2, *tmp++);\r\nmga_outb(M_EXTVGA_INDEX, 0x03);\r\nmga_outb(M_EXTVGA_DATA, orig);\r\n*realSize = offs - 0x100000;\r\n#ifdef CONFIG_FB_MATROX_MILLENIUM\r\nminfo->interleave = !(!isMillenium(minfo) || ((offs - 0x100000) & 0x3FFFFF));\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void setDefaultOutputs(struct matrox_fb_info *minfo)\r\n{\r\nunsigned int i;\r\nconst char* ptr;\r\nminfo->outputs[0].default_src = MATROXFB_SRC_CRTC1;\r\nif (minfo->devflags.g450dac) {\r\nminfo->outputs[1].default_src = MATROXFB_SRC_CRTC1;\r\nminfo->outputs[2].default_src = MATROXFB_SRC_CRTC1;\r\n} else if (dfp) {\r\nminfo->outputs[2].default_src = MATROXFB_SRC_CRTC1;\r\n}\r\nptr = outputs;\r\nfor (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {\r\nchar c = *ptr++;\r\nif (c == 0) {\r\nbreak;\r\n}\r\nif (c == '0') {\r\nminfo->outputs[i].default_src = MATROXFB_SRC_NONE;\r\n} else if (c == '1') {\r\nminfo->outputs[i].default_src = MATROXFB_SRC_CRTC1;\r\n} else if (c == '2' && minfo->devflags.crtc2) {\r\nminfo->outputs[i].default_src = MATROXFB_SRC_CRTC2;\r\n} else {\r\nprintk(KERN_ERR "matroxfb: Unknown outputs setting\n");\r\nbreak;\r\n}\r\n}\r\noutputs[0] = 0;\r\n}\r\nstatic int initMatrox2(struct matrox_fb_info *minfo, struct board *b)\r\n{\r\nunsigned long ctrlptr_phys = 0;\r\nunsigned long video_base_phys = 0;\r\nunsigned int memsize;\r\nint err;\r\nstatic struct pci_device_id intel_82437[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437) },\r\n{ },\r\n};\r\nDBG(__func__)\r\nvesafb_defined.accel_flags = FB_ACCELF_TEXT;\r\nminfo->hw_switch = b->base->lowlevel;\r\nminfo->devflags.accelerator = b->base->accelID;\r\nminfo->max_pixel_clock = b->maxclk;\r\nprintk(KERN_INFO "matroxfb: Matrox %s detected\n", b->name);\r\nminfo->capable.plnwt = 1;\r\nminfo->chip = b->chip;\r\nminfo->capable.srcorg = b->flags & DEVF_SRCORG;\r\nminfo->devflags.video64bits = b->flags & DEVF_VIDEO64BIT;\r\nif (b->flags & DEVF_TEXT4B) {\r\nminfo->devflags.vgastep = 4;\r\nminfo->devflags.textmode = 4;\r\nminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP16;\r\n} else if (b->flags & DEVF_TEXT16B) {\r\nminfo->devflags.vgastep = 16;\r\nminfo->devflags.textmode = 1;\r\nminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP16;\r\n} else {\r\nminfo->devflags.vgastep = 8;\r\nminfo->devflags.textmode = 1;\r\nminfo->devflags.text_type_aux = FB_AUX_TEXT_MGA_STEP8;\r\n}\r\nminfo->devflags.support32MB = (b->flags & DEVF_SUPPORT32MB) != 0;\r\nminfo->devflags.precise_width = !(b->flags & DEVF_ANY_VXRES);\r\nminfo->devflags.crtc2 = (b->flags & DEVF_CRTC2) != 0;\r\nminfo->devflags.maven_capable = (b->flags & DEVF_MAVEN_CAPABLE) != 0;\r\nminfo->devflags.dualhead = (b->flags & DEVF_DUALHEAD) != 0;\r\nminfo->devflags.dfp_type = dfp_type;\r\nminfo->devflags.g450dac = (b->flags & DEVF_G450DAC) != 0;\r\nminfo->devflags.textstep = minfo->devflags.vgastep * minfo->devflags.textmode;\r\nminfo->devflags.textvram = 65536 / minfo->devflags.textmode;\r\nsetDefaultOutputs(minfo);\r\nif (b->flags & DEVF_PANELLINK_CAPABLE) {\r\nminfo->outputs[2].data = minfo;\r\nminfo->outputs[2].output = &panellink_output;\r\nminfo->outputs[2].src = minfo->outputs[2].default_src;\r\nminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nminfo->devflags.panellink = 1;\r\n}\r\nif (minfo->capable.cross4MB < 0)\r\nminfo->capable.cross4MB = b->flags & DEVF_CROSS4MB;\r\nif (b->flags & DEVF_SWAPS) {\r\nctrlptr_phys = pci_resource_start(minfo->pcidev, 1);\r\nvideo_base_phys = pci_resource_start(minfo->pcidev, 0);\r\nminfo->devflags.fbResource = PCI_BASE_ADDRESS_0;\r\n} else {\r\nctrlptr_phys = pci_resource_start(minfo->pcidev, 0);\r\nvideo_base_phys = pci_resource_start(minfo->pcidev, 1);\r\nminfo->devflags.fbResource = PCI_BASE_ADDRESS_1;\r\n}\r\nerr = -EINVAL;\r\nif (!ctrlptr_phys) {\r\nprintk(KERN_ERR "matroxfb: control registers are not available, matroxfb disabled\n");\r\ngoto fail;\r\n}\r\nif (!video_base_phys) {\r\nprintk(KERN_ERR "matroxfb: video RAM is not available in PCI address space, matroxfb disabled\n");\r\ngoto fail;\r\n}\r\nmemsize = b->base->maxvram;\r\nif (!request_mem_region(ctrlptr_phys, 16384, "matroxfb MMIO")) {\r\ngoto fail;\r\n}\r\nif (!request_mem_region(video_base_phys, memsize, "matroxfb FB")) {\r\ngoto failCtrlMR;\r\n}\r\nminfo->video.len_maximum = memsize;\r\nif (mem < 1024) mem *= 1024;\r\nif (mem < 0x00100000) mem *= 1024;\r\nif (mem && (mem < memsize))\r\nmemsize = mem;\r\nerr = -ENOMEM;\r\nif (mga_ioremap(ctrlptr_phys, 16384, MGA_IOREMAP_MMIO, &minfo->mmio.vbase)) {\r\nprintk(KERN_ERR "matroxfb: cannot ioremap(%lX, 16384), matroxfb disabled\n", ctrlptr_phys);\r\ngoto failVideoMR;\r\n}\r\nminfo->mmio.base = ctrlptr_phys;\r\nminfo->mmio.len = 16384;\r\nminfo->video.base = video_base_phys;\r\nif (mga_ioremap(video_base_phys, memsize, MGA_IOREMAP_FB, &minfo->video.vbase)) {\r\nprintk(KERN_ERR "matroxfb: cannot ioremap(%lX, %d), matroxfb disabled\n",\r\nvideo_base_phys, memsize);\r\ngoto failCtrlIO;\r\n}\r\n{\r\nu_int32_t cmd;\r\nu_int32_t mga_option;\r\npci_read_config_dword(minfo->pcidev, PCI_OPTION_REG, &mga_option);\r\npci_read_config_dword(minfo->pcidev, PCI_COMMAND, &cmd);\r\nmga_option &= 0x7FFFFFFF;\r\nmga_option |= MX_OPTION_BSWAP;\r\ncmd &= ~PCI_COMMAND_VGA_PALETTE;\r\nif (pci_dev_present(intel_82437)) {\r\nif (!(mga_option & 0x20000000) && !minfo->devflags.nopciretry) {\r\nprintk(KERN_WARNING "matroxfb: Disabling PCI retries due to i82437 present\n");\r\n}\r\nmga_option |= 0x20000000;\r\nminfo->devflags.nopciretry = 1;\r\n}\r\npci_write_config_dword(minfo->pcidev, PCI_COMMAND, cmd);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, mga_option);\r\nminfo->hw.MXoptionReg = mga_option;\r\npci_write_config_dword(minfo->pcidev, PCI_MGA_INDEX, 0x00003C00);\r\n}\r\nerr = -ENXIO;\r\nmatroxfb_read_pins(minfo);\r\nif (minfo->hw_switch->preinit(minfo)) {\r\ngoto failVideoIO;\r\n}\r\nerr = -ENOMEM;\r\nif (!matroxfb_getmemory(minfo, memsize, &minfo->video.len) || !minfo->video.len) {\r\nprintk(KERN_ERR "matroxfb: cannot determine memory size\n");\r\ngoto failVideoIO;\r\n}\r\nminfo->devflags.ydstorg = 0;\r\nminfo->video.base = video_base_phys;\r\nminfo->video.len_usable = minfo->video.len;\r\nif (minfo->video.len_usable > b->base->maxdisplayable)\r\nminfo->video.len_usable = b->base->maxdisplayable;\r\n#ifdef CONFIG_MTRR\r\nif (mtrr) {\r\nminfo->mtrr.vram = mtrr_add(video_base_phys, minfo->video.len, MTRR_TYPE_WRCOMB, 1);\r\nminfo->mtrr.vram_valid = 1;\r\nprintk(KERN_INFO "matroxfb: MTRR's turned on\n");\r\n}\r\n#endif\r\nif (!minfo->devflags.novga)\r\nrequest_region(0x3C0, 32, "matrox");\r\nmatroxfb_g450_connect(minfo);\r\nminfo->hw_switch->reset(minfo);\r\nminfo->fbcon.monspecs.hfmin = 0;\r\nminfo->fbcon.monspecs.hfmax = fh;\r\nminfo->fbcon.monspecs.vfmin = 0;\r\nminfo->fbcon.monspecs.vfmax = fv;\r\nminfo->fbcon.monspecs.dpms = 0;\r\nvesafb_defined.red = colors[depth-1].red;\r\nvesafb_defined.green = colors[depth-1].green;\r\nvesafb_defined.blue = colors[depth-1].blue;\r\nvesafb_defined.bits_per_pixel = colors[depth-1].bits_per_pixel;\r\nvesafb_defined.grayscale = grayscale;\r\nvesafb_defined.vmode = 0;\r\nif (noaccel)\r\nvesafb_defined.accel_flags &= ~FB_ACCELF_TEXT;\r\nminfo->fbops = matroxfb_ops;\r\nminfo->fbcon.fbops = &minfo->fbops;\r\nminfo->fbcon.pseudo_palette = minfo->cmap;\r\nminfo->fbcon.flags = hotplug ? FBINFO_FLAG_MODULE : FBINFO_FLAG_DEFAULT;\r\nminfo->fbcon.flags |= FBINFO_PARTIAL_PAN_OK |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_XPAN |\r\nFBINFO_HWACCEL_YPAN |\r\nFBINFO_READS_FAST;\r\nminfo->video.len_usable &= PAGE_MASK;\r\nfb_alloc_cmap(&minfo->fbcon.cmap, 256, 1);\r\n#ifndef MODULE\r\nif (!hotplug) {\r\nfb_find_mode(&vesafb_defined, &minfo->fbcon, videomode[0] ? videomode : NULL,\r\nNULL, 0, &defaultmode, vesafb_defined.bits_per_pixel);\r\n}\r\n#endif\r\nif (hslen)\r\nvesafb_defined.hsync_len = hslen;\r\nif (vslen)\r\nvesafb_defined.vsync_len = vslen;\r\nif (left != ~0)\r\nvesafb_defined.left_margin = left;\r\nif (right != ~0)\r\nvesafb_defined.right_margin = right;\r\nif (upper != ~0)\r\nvesafb_defined.upper_margin = upper;\r\nif (lower != ~0)\r\nvesafb_defined.lower_margin = lower;\r\nif (xres)\r\nvesafb_defined.xres = xres;\r\nif (yres)\r\nvesafb_defined.yres = yres;\r\nif (sync != -1)\r\nvesafb_defined.sync = sync;\r\nelse if (vesafb_defined.sync == ~0) {\r\nvesafb_defined.sync = 0;\r\nif (yres < 400)\r\nvesafb_defined.sync |= FB_SYNC_HOR_HIGH_ACT;\r\nelse if (yres < 480)\r\nvesafb_defined.sync |= FB_SYNC_VERT_HIGH_ACT;\r\n}\r\n{\r\nunsigned int tmp;\r\nif (fv) {\r\ntmp = fv * (vesafb_defined.upper_margin + vesafb_defined.yres\r\n+ vesafb_defined.lower_margin + vesafb_defined.vsync_len);\r\nif ((tmp < fh) || (fh == 0)) fh = tmp;\r\n}\r\nif (fh) {\r\ntmp = fh * (vesafb_defined.left_margin + vesafb_defined.xres\r\n+ vesafb_defined.right_margin + vesafb_defined.hsync_len);\r\nif ((tmp < maxclk) || (maxclk == 0)) maxclk = tmp;\r\n}\r\ntmp = (maxclk + 499) / 500;\r\nif (tmp) {\r\ntmp = (2000000000 + tmp) / tmp;\r\nif (tmp > pixclock) pixclock = tmp;\r\n}\r\n}\r\nif (pixclock) {\r\nif (pixclock < 2000)\r\npixclock = 4000;\r\nif (pixclock > 1000000)\r\npixclock = 1000000;\r\nvesafb_defined.pixclock = pixclock;\r\n}\r\n#if defined(CONFIG_PPC_PMAC)\r\n#ifndef MODULE\r\nif (machine_is(powermac)) {\r\nstruct fb_var_screeninfo var;\r\nif (default_vmode <= 0 || default_vmode > VMODE_MAX)\r\ndefault_vmode = VMODE_640_480_60;\r\n#ifdef CONFIG_NVRAM\r\nif (default_cmode == CMODE_NVRAM)\r\ndefault_cmode = nvram_read_byte(NV_CMODE);\r\n#endif\r\nif (default_cmode < CMODE_8 || default_cmode > CMODE_32)\r\ndefault_cmode = CMODE_8;\r\nif (!mac_vmode_to_var(default_vmode, default_cmode, &var)) {\r\nvar.accel_flags = vesafb_defined.accel_flags;\r\nvar.xoffset = var.yoffset = 0;\r\nvesafb_defined = var;\r\n}\r\n}\r\n#endif\r\n#endif\r\nvesafb_defined.xres_virtual = vesafb_defined.xres;\r\nif (nopan) {\r\nvesafb_defined.yres_virtual = vesafb_defined.yres;\r\n} else {\r\nvesafb_defined.yres_virtual = 65536;\r\n}\r\nmatroxfb_init_fix(minfo);\r\nminfo->fbcon.screen_base = vaddr_va(minfo->video.vbase);\r\nmatroxfb_check_var(&vesafb_defined, &minfo->fbcon);\r\nminfo->fbcon.var = vesafb_defined;\r\nerr = -EINVAL;\r\nprintk(KERN_INFO "matroxfb: %dx%dx%dbpp (virtual: %dx%d)\n",\r\nvesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel,\r\nvesafb_defined.xres_virtual, vesafb_defined.yres_virtual);\r\nprintk(KERN_INFO "matroxfb: framebuffer at 0x%lX, mapped to 0x%p, size %d\n",\r\nminfo->video.base, vaddr_va(minfo->video.vbase), minfo->video.len);\r\nminfo->fbcon.device = &minfo->pcidev->dev;\r\nif (register_framebuffer(&minfo->fbcon) < 0) {\r\ngoto failVideoIO;\r\n}\r\nfb_info(&minfo->fbcon, "%s frame buffer device\n", minfo->fbcon.fix.id);\r\nif (!minfo->initialized) {\r\nfb_info(&minfo->fbcon, "initializing hardware\n");\r\nvesafb_defined.activate |= FB_ACTIVATE_FORCE;\r\nfb_set_var(&minfo->fbcon, &vesafb_defined);\r\n}\r\nreturn 0;\r\nfailVideoIO:;\r\nmatroxfb_g450_shutdown(minfo);\r\nmga_iounmap(minfo->video.vbase);\r\nfailCtrlIO:;\r\nmga_iounmap(minfo->mmio.vbase);\r\nfailVideoMR:;\r\nrelease_mem_region(video_base_phys, minfo->video.len_maximum);\r\nfailCtrlMR:;\r\nrelease_mem_region(ctrlptr_phys, 16384);\r\nfail:;\r\nreturn err;\r\n}\r\nint matroxfb_register_driver(struct matroxfb_driver* drv) {\r\nstruct matrox_fb_info* minfo;\r\nlist_add(&drv->node, &matroxfb_driver_list);\r\nfor (minfo = matroxfb_l(matroxfb_list.next);\r\nminfo != matroxfb_l(&matroxfb_list);\r\nminfo = matroxfb_l(minfo->next_fb.next)) {\r\nvoid* p;\r\nif (minfo->drivers_count == MATROXFB_MAX_FB_DRIVERS)\r\ncontinue;\r\np = drv->probe(minfo);\r\nif (p) {\r\nminfo->drivers_data[minfo->drivers_count] = p;\r\nminfo->drivers[minfo->drivers_count++] = drv;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid matroxfb_unregister_driver(struct matroxfb_driver* drv) {\r\nstruct matrox_fb_info* minfo;\r\nlist_del(&drv->node);\r\nfor (minfo = matroxfb_l(matroxfb_list.next);\r\nminfo != matroxfb_l(&matroxfb_list);\r\nminfo = matroxfb_l(minfo->next_fb.next)) {\r\nint i;\r\nfor (i = 0; i < minfo->drivers_count; ) {\r\nif (minfo->drivers[i] == drv) {\r\nif (drv && drv->remove)\r\ndrv->remove(minfo, minfo->drivers_data[i]);\r\nminfo->drivers[i] = minfo->drivers[--minfo->drivers_count];\r\nminfo->drivers_data[i] = minfo->drivers_data[minfo->drivers_count];\r\n} else\r\ni++;\r\n}\r\n}\r\n}\r\nstatic void matroxfb_register_device(struct matrox_fb_info* minfo) {\r\nstruct matroxfb_driver* drv;\r\nint i = 0;\r\nlist_add(&minfo->next_fb, &matroxfb_list);\r\nfor (drv = matroxfb_driver_l(matroxfb_driver_list.next);\r\ndrv != matroxfb_driver_l(&matroxfb_driver_list);\r\ndrv = matroxfb_driver_l(drv->node.next)) {\r\nif (drv && drv->probe) {\r\nvoid *p = drv->probe(minfo);\r\nif (p) {\r\nminfo->drivers_data[i] = p;\r\nminfo->drivers[i++] = drv;\r\nif (i == MATROXFB_MAX_FB_DRIVERS)\r\nbreak;\r\n}\r\n}\r\n}\r\nminfo->drivers_count = i;\r\n}\r\nstatic void matroxfb_unregister_device(struct matrox_fb_info* minfo) {\r\nint i;\r\nlist_del(&minfo->next_fb);\r\nfor (i = 0; i < minfo->drivers_count; i++) {\r\nstruct matroxfb_driver* drv = minfo->drivers[i];\r\nif (drv && drv->remove)\r\ndrv->remove(minfo, minfo->drivers_data[i]);\r\n}\r\n}\r\nstatic int matroxfb_probe(struct pci_dev* pdev, const struct pci_device_id* dummy) {\r\nstruct board* b;\r\nu_int16_t svid;\r\nu_int16_t sid;\r\nstruct matrox_fb_info* minfo;\r\nint err;\r\nu_int32_t cmd;\r\nDBG(__func__)\r\nsvid = pdev->subsystem_vendor;\r\nsid = pdev->subsystem_device;\r\nfor (b = dev_list; b->vendor; b++) {\r\nif ((b->vendor != pdev->vendor) || (b->device != pdev->device) || (b->rev < pdev->revision)) continue;\r\nif (b->svid)\r\nif ((b->svid != svid) || (b->sid != sid)) continue;\r\nbreak;\r\n}\r\nif (!b->vendor)\r\nreturn -ENODEV;\r\nif (dev > 0) {\r\ndev--;\r\nreturn -ENODEV;\r\n}\r\npci_read_config_dword(pdev, PCI_COMMAND, &cmd);\r\nif (pci_enable_device(pdev)) {\r\nreturn -1;\r\n}\r\nminfo = kzalloc(sizeof(*minfo), GFP_KERNEL);\r\nif (!minfo)\r\nreturn -1;\r\nminfo->pcidev = pdev;\r\nminfo->dead = 0;\r\nminfo->usecount = 0;\r\nminfo->userusecount = 0;\r\npci_set_drvdata(pdev, minfo);\r\nminfo->devflags.memtype = memtype;\r\nif (memtype != -1)\r\nnoinit = 0;\r\nif (cmd & PCI_COMMAND_MEMORY) {\r\nminfo->devflags.novga = novga;\r\nminfo->devflags.nobios = nobios;\r\nminfo->devflags.noinit = noinit;\r\nnovga = 1;\r\nnobios = 1;\r\nnoinit = 0;\r\n} else {\r\nminfo->devflags.novga = 1;\r\nminfo->devflags.nobios = 1;\r\nminfo->devflags.noinit = 0;\r\n}\r\nminfo->devflags.nopciretry = no_pci_retry;\r\nminfo->devflags.mga_24bpp_fix = inv24;\r\nminfo->devflags.precise_width = option_precise_width;\r\nminfo->devflags.sgram = sgram;\r\nminfo->capable.cross4MB = cross4MB;\r\nspin_lock_init(&minfo->lock.DAC);\r\nspin_lock_init(&minfo->lock.accel);\r\ninit_rwsem(&minfo->crtc2.lock);\r\ninit_rwsem(&minfo->altout.lock);\r\nmutex_init(&minfo->fbcon.mm_lock);\r\nminfo->irq_flags = 0;\r\ninit_waitqueue_head(&minfo->crtc1.vsync.wait);\r\ninit_waitqueue_head(&minfo->crtc2.vsync.wait);\r\nminfo->crtc1.panpos = -1;\r\nerr = initMatrox2(minfo, b);\r\nif (!err) {\r\nmatroxfb_register_device(minfo);\r\nreturn 0;\r\n}\r\nkfree(minfo);\r\nreturn -1;\r\n}\r\nstatic void pci_remove_matrox(struct pci_dev* pdev) {\r\nstruct matrox_fb_info* minfo;\r\nminfo = pci_get_drvdata(pdev);\r\nmatroxfb_remove(minfo, 1);\r\n}\r\nstatic void __init matroxfb_init_params(void) {\r\nif (fh < 1000)\r\nfh *= 1000;\r\nif (maxclk < 1000) maxclk *= 1000;\r\nif (maxclk < 1000000) maxclk *= 1000;\r\nif (vesa != ~0)\r\nvesa &= 0x1DFF;\r\nfor (RSptr = vesamap; RSptr->vesa; RSptr++) {\r\nif (RSptr->vesa == vesa) break;\r\n}\r\nif (!RSptr->vesa) {\r\nprintk(KERN_ERR "Invalid vesa mode 0x%04X\n", vesa);\r\nRSptr = vesamap;\r\n}\r\n{\r\nint res = RSResolution(RSptr->info)-1;\r\nif (left == ~0)\r\nleft = timmings[res].left;\r\nif (!xres)\r\nxres = timmings[res].xres;\r\nif (right == ~0)\r\nright = timmings[res].right;\r\nif (!hslen)\r\nhslen = timmings[res].hslen;\r\nif (upper == ~0)\r\nupper = timmings[res].upper;\r\nif (!yres)\r\nyres = timmings[res].yres;\r\nif (lower == ~0)\r\nlower = timmings[res].lower;\r\nif (!vslen)\r\nvslen = timmings[res].vslen;\r\nif (!(fv||fh||maxclk||pixclock))\r\nfv = timmings[res].vfreq;\r\nif (depth == -1)\r\ndepth = RSDepth(RSptr->info);\r\n}\r\n}\r\nstatic int __init matrox_init(void) {\r\nint err;\r\nmatroxfb_init_params();\r\nerr = pci_register_driver(&matroxfb_driver);\r\ndev = -1;\r\nreturn err;\r\n}\r\nstatic void __exit matrox_done(void) {\r\npci_unregister_driver(&matroxfb_driver);\r\n}\r\nstatic int __init matroxfb_setup(char *options) {\r\nchar *this_opt;\r\nDBG(__func__)\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\ndprintk("matroxfb_setup: option %s\n", this_opt);\r\nif (!strncmp(this_opt, "dev:", 4))\r\ndev = simple_strtoul(this_opt+4, NULL, 0);\r\nelse if (!strncmp(this_opt, "depth:", 6)) {\r\nswitch (simple_strtoul(this_opt+6, NULL, 0)) {\r\ncase 0: depth = RSText; break;\r\ncase 4: depth = RS4bpp; break;\r\ncase 8: depth = RS8bpp; break;\r\ncase 15:depth = RS15bpp; break;\r\ncase 16:depth = RS16bpp; break;\r\ncase 24:depth = RS24bpp; break;\r\ncase 32:depth = RS32bpp; break;\r\ndefault:\r\nprintk(KERN_ERR "matroxfb: unsupported color depth\n");\r\n}\r\n} else if (!strncmp(this_opt, "xres:", 5))\r\nxres = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "yres:", 5))\r\nyres = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "vslen:", 6))\r\nvslen = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "hslen:", 6))\r\nhslen = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "left:", 5))\r\nleft = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "right:", 6))\r\nright = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "upper:", 6))\r\nupper = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "lower:", 6))\r\nlower = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "pixclock:", 9))\r\npixclock = simple_strtoul(this_opt+9, NULL, 0);\r\nelse if (!strncmp(this_opt, "sync:", 5))\r\nsync = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "vesa:", 5))\r\nvesa = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "maxclk:", 7))\r\nmaxclk = simple_strtoul(this_opt+7, NULL, 0);\r\nelse if (!strncmp(this_opt, "fh:", 3))\r\nfh = simple_strtoul(this_opt+3, NULL, 0);\r\nelse if (!strncmp(this_opt, "fv:", 3))\r\nfv = simple_strtoul(this_opt+3, NULL, 0);\r\nelse if (!strncmp(this_opt, "mem:", 4))\r\nmem = simple_strtoul(this_opt+4, NULL, 0);\r\nelse if (!strncmp(this_opt, "mode:", 5))\r\nstrlcpy(videomode, this_opt+5, sizeof(videomode));\r\nelse if (!strncmp(this_opt, "outputs:", 8))\r\nstrlcpy(outputs, this_opt+8, sizeof(outputs));\r\nelse if (!strncmp(this_opt, "dfp:", 4)) {\r\ndfp_type = simple_strtoul(this_opt+4, NULL, 0);\r\ndfp = 1;\r\n}\r\n#ifdef CONFIG_PPC_PMAC\r\nelse if (!strncmp(this_opt, "vmode:", 6)) {\r\nunsigned int vmode = simple_strtoul(this_opt+6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX)\r\ndefault_vmode = vmode;\r\n} else if (!strncmp(this_opt, "cmode:", 6)) {\r\nunsigned int cmode = simple_strtoul(this_opt+6, NULL, 0);\r\nswitch (cmode) {\r\ncase 0:\r\ncase 8:\r\ndefault_cmode = CMODE_8;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndefault_cmode = CMODE_16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault_cmode = CMODE_32;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nelse if (!strcmp(this_opt, "disabled"))\r\ndisabled = 1;\r\nelse if (!strcmp(this_opt, "enabled"))\r\ndisabled = 0;\r\nelse if (!strcmp(this_opt, "sgram"))\r\nsgram = 1;\r\nelse if (!strcmp(this_opt, "sdram"))\r\nsgram = 0;\r\nelse if (!strncmp(this_opt, "memtype:", 8))\r\nmemtype = simple_strtoul(this_opt+8, NULL, 0);\r\nelse {\r\nint value = 1;\r\nif (!strncmp(this_opt, "no", 2)) {\r\nvalue = 0;\r\nthis_opt += 2;\r\n}\r\nif (! strcmp(this_opt, "inverse"))\r\ninverse = value;\r\nelse if (!strcmp(this_opt, "accel"))\r\nnoaccel = !value;\r\nelse if (!strcmp(this_opt, "pan"))\r\nnopan = !value;\r\nelse if (!strcmp(this_opt, "pciretry"))\r\nno_pci_retry = !value;\r\nelse if (!strcmp(this_opt, "vga"))\r\nnovga = !value;\r\nelse if (!strcmp(this_opt, "bios"))\r\nnobios = !value;\r\nelse if (!strcmp(this_opt, "init"))\r\nnoinit = !value;\r\n#ifdef CONFIG_MTRR\r\nelse if (!strcmp(this_opt, "mtrr"))\r\nmtrr = value;\r\n#endif\r\nelse if (!strcmp(this_opt, "inv24"))\r\ninv24 = value;\r\nelse if (!strcmp(this_opt, "cross4MB"))\r\ncross4MB = value;\r\nelse if (!strcmp(this_opt, "grayscale"))\r\ngrayscale = value;\r\nelse if (!strcmp(this_opt, "dfp"))\r\ndfp = value;\r\nelse {\r\nstrlcpy(videomode, this_opt, sizeof(videomode));\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init matroxfb_init(void)\r\n{\r\nchar *option = NULL;\r\nint err = 0;\r\nDBG(__func__)\r\nif (fb_get_options("matroxfb", &option))\r\nreturn -ENODEV;\r\nmatroxfb_setup(option);\r\nif (disabled)\r\nreturn -ENXIO;\r\nif (!initialized) {\r\ninitialized = 1;\r\nerr = matrox_init();\r\n}\r\nhotplug = 1;\r\nreturn err;\r\n}\r\nint __init init_module(void){\r\nDBG(__func__)\r\nif (disabled)\r\nreturn -ENXIO;\r\nif (depth == 0)\r\ndepth = RSText;\r\nelse if (depth == 4)\r\ndepth = RS4bpp;\r\nelse if (depth == 8)\r\ndepth = RS8bpp;\r\nelse if (depth == 15)\r\ndepth = RS15bpp;\r\nelse if (depth == 16)\r\ndepth = RS16bpp;\r\nelse if (depth == 24)\r\ndepth = RS24bpp;\r\nelse if (depth == 32)\r\ndepth = RS32bpp;\r\nelse if (depth != -1) {\r\nprintk(KERN_ERR "matroxfb: depth %d is not supported, using default\n", depth);\r\ndepth = -1;\r\n}\r\nmatrox_init();\r\nreturn 0;\r\n}
