static inline void prandom_state_selftest(void)\r\n{\r\n}\r\nu32 prandom_u32_state(struct rnd_state *state)\r\n{\r\n#define TAUSWORTHE(s, a, b, c, d) ((s & c) << d) ^ (((s << a) ^ s) >> b)\r\nstate->s1 = TAUSWORTHE(state->s1, 6U, 13U, 4294967294U, 18U);\r\nstate->s2 = TAUSWORTHE(state->s2, 2U, 27U, 4294967288U, 2U);\r\nstate->s3 = TAUSWORTHE(state->s3, 13U, 21U, 4294967280U, 7U);\r\nstate->s4 = TAUSWORTHE(state->s4, 3U, 12U, 4294967168U, 13U);\r\nreturn (state->s1 ^ state->s2 ^ state->s3 ^ state->s4);\r\n}\r\nu32 prandom_u32(void)\r\n{\r\nstruct rnd_state *state = &get_cpu_var(net_rand_state);\r\nu32 res;\r\nres = prandom_u32_state(state);\r\nput_cpu_var(state);\r\nreturn res;\r\n}\r\nvoid prandom_bytes_state(struct rnd_state *state, void *buf, size_t bytes)\r\n{\r\nu8 *ptr = buf;\r\nwhile (bytes >= sizeof(u32)) {\r\nput_unaligned(prandom_u32_state(state), (u32 *) ptr);\r\nptr += sizeof(u32);\r\nbytes -= sizeof(u32);\r\n}\r\nif (bytes > 0) {\r\nu32 rem = prandom_u32_state(state);\r\ndo {\r\n*ptr++ = (u8) rem;\r\nbytes--;\r\nrem >>= BITS_PER_BYTE;\r\n} while (bytes > 0);\r\n}\r\n}\r\nvoid prandom_bytes(void *buf, size_t bytes)\r\n{\r\nstruct rnd_state *state = &get_cpu_var(net_rand_state);\r\nprandom_bytes_state(state, buf, bytes);\r\nput_cpu_var(state);\r\n}\r\nstatic void prandom_warmup(struct rnd_state *state)\r\n{\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\nprandom_u32_state(state);\r\n}\r\nstatic u32 __extract_hwseed(void)\r\n{\r\nunsigned int val = 0;\r\n(void)(arch_get_random_seed_int(&val) ||\r\narch_get_random_int(&val));\r\nreturn val;\r\n}\r\nstatic void prandom_seed_early(struct rnd_state *state, u32 seed,\r\nbool mix_with_hwseed)\r\n{\r\n#define LCG(x) ((x) * 69069U)\r\n#define HWSEED() (mix_with_hwseed ? __extract_hwseed() : 0)\r\nstate->s1 = __seed(HWSEED() ^ LCG(seed), 2U);\r\nstate->s2 = __seed(HWSEED() ^ LCG(state->s1), 8U);\r\nstate->s3 = __seed(HWSEED() ^ LCG(state->s2), 16U);\r\nstate->s4 = __seed(HWSEED() ^ LCG(state->s3), 128U);\r\n}\r\nvoid prandom_seed(u32 entropy)\r\n{\r\nint i;\r\nfor_each_possible_cpu (i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state, i);\r\nstate->s1 = __seed(state->s1 ^ entropy, 2U);\r\nprandom_warmup(state);\r\n}\r\n}\r\nstatic int __init prandom_init(void)\r\n{\r\nint i;\r\nprandom_state_selftest();\r\nfor_each_possible_cpu(i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state,i);\r\nu32 weak_seed = (i + jiffies) ^ random_get_entropy();\r\nprandom_seed_early(state, weak_seed, true);\r\nprandom_warmup(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __prandom_timer(unsigned long dontcare)\r\n{\r\nu32 entropy;\r\nunsigned long expires;\r\nget_random_bytes(&entropy, sizeof(entropy));\r\nprandom_seed(entropy);\r\nexpires = 40 + prandom_u32_max(40);\r\nseed_timer.expires = jiffies + msecs_to_jiffies(expires * MSEC_PER_SEC);\r\nadd_timer(&seed_timer);\r\n}\r\nstatic void __init __prandom_start_seed_timer(void)\r\n{\r\nset_timer_slack(&seed_timer, HZ);\r\nseed_timer.expires = jiffies + msecs_to_jiffies(40 * MSEC_PER_SEC);\r\nadd_timer(&seed_timer);\r\n}\r\nstatic void __prandom_reseed(bool late)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstatic bool latch = false;\r\nstatic DEFINE_SPINLOCK(lock);\r\nif (!spin_trylock_irqsave(&lock, flags))\r\nreturn;\r\nif (latch && !late)\r\ngoto out;\r\nlatch = true;\r\nfor_each_possible_cpu(i) {\r\nstruct rnd_state *state = &per_cpu(net_rand_state,i);\r\nu32 seeds[4];\r\nget_random_bytes(&seeds, sizeof(seeds));\r\nstate->s1 = __seed(seeds[0], 2U);\r\nstate->s2 = __seed(seeds[1], 8U);\r\nstate->s3 = __seed(seeds[2], 16U);\r\nstate->s4 = __seed(seeds[3], 128U);\r\nprandom_warmup(state);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nvoid prandom_reseed_late(void)\r\n{\r\n__prandom_reseed(true);\r\n}\r\nstatic int __init prandom_reseed(void)\r\n{\r\n__prandom_reseed(false);\r\n__prandom_start_seed_timer();\r\nreturn 0;\r\n}\r\nstatic void __init prandom_state_selftest(void)\r\n{\r\nint i, j, errors = 0, runs = 0;\r\nbool error = false;\r\nfor (i = 0; i < ARRAY_SIZE(test1); i++) {\r\nstruct rnd_state state;\r\nprandom_seed_early(&state, test1[i].seed, false);\r\nprandom_warmup(&state);\r\nif (test1[i].result != prandom_u32_state(&state))\r\nerror = true;\r\n}\r\nif (error)\r\npr_warn("prandom: seed boundary self test failed\n");\r\nelse\r\npr_info("prandom: seed boundary self test passed\n");\r\nfor (i = 0; i < ARRAY_SIZE(test2); i++) {\r\nstruct rnd_state state;\r\nprandom_seed_early(&state, test2[i].seed, false);\r\nprandom_warmup(&state);\r\nfor (j = 0; j < test2[i].iteration - 1; j++)\r\nprandom_u32_state(&state);\r\nif (test2[i].result != prandom_u32_state(&state))\r\nerrors++;\r\nruns++;\r\ncond_resched();\r\n}\r\nif (errors)\r\npr_warn("prandom: %d/%d self tests failed\n", errors, runs);\r\nelse\r\npr_info("prandom: %d self tests passed\n", runs);\r\n}
