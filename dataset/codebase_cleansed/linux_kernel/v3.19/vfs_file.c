int v9fs_file_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nstruct v9fs_inode *v9inode;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nint omode;\r\np9_debug(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, file);\r\nv9inode = V9FS_I(inode);\r\nv9ses = v9fs_inode2v9ses(inode);\r\nif (v9fs_proto_dotl(v9ses))\r\nomode = v9fs_open_to_dotl_flags(file->f_flags);\r\nelse\r\nomode = v9fs_uflags2omode(file->f_flags,\r\nv9fs_proto_dotu(v9ses));\r\nfid = file->private_data;\r\nif (!fid) {\r\nfid = v9fs_fid_clone(file->f_path.dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nerr = p9_client_open(fid, omode);\r\nif (err < 0) {\r\np9_client_clunk(fid);\r\nreturn err;\r\n}\r\nif ((file->f_flags & O_APPEND) &&\r\n(!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)))\r\ngeneric_file_llseek(file, 0, SEEK_END);\r\n}\r\nfile->private_data = fid;\r\nmutex_lock(&v9inode->v_mutex);\r\nif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\r\n!v9inode->writeback_fid &&\r\n((file->f_flags & O_ACCMODE) != O_RDONLY)) {\r\nfid = v9fs_writeback_fid(file->f_path.dentry);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\nmutex_unlock(&v9inode->v_mutex);\r\ngoto out_error;\r\n}\r\nv9inode->writeback_fid = (void *) fid;\r\n}\r\nmutex_unlock(&v9inode->v_mutex);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\nv9fs_cache_inode_set_cookie(inode, file);\r\nreturn 0;\r\nout_error:\r\np9_client_clunk(file->private_data);\r\nfile->private_data = NULL;\r\nreturn err;\r\n}\r\nstatic int v9fs_file_lock(struct file *filp, int cmd, struct file_lock *fl)\r\n{\r\nint res = 0;\r\nstruct inode *inode = file_inode(filp);\r\np9_debug(P9_DEBUG_VFS, "filp: %p lock: %p\n", filp, fl);\r\nif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\r\nreturn -ENOLCK;\r\nif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\r\nfilemap_write_and_wait(inode->i_mapping);\r\ninvalidate_mapping_pages(&inode->i_data, 0, -1);\r\n}\r\nreturn res;\r\n}\r\nstatic int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\r\n{\r\nstruct p9_flock flock;\r\nstruct p9_fid *fid;\r\nuint8_t status;\r\nint res = 0;\r\nunsigned char fl_type;\r\nfid = filp->private_data;\r\nBUG_ON(fid == NULL);\r\nif ((fl->fl_flags & FL_POSIX) != FL_POSIX)\r\nBUG();\r\nres = posix_lock_file_wait(filp, fl);\r\nif (res < 0)\r\ngoto out;\r\nmemset(&flock, 0, sizeof(flock));\r\nswitch (fl->fl_type) {\r\ncase F_RDLCK:\r\nflock.type = P9_LOCK_TYPE_RDLCK;\r\nbreak;\r\ncase F_WRLCK:\r\nflock.type = P9_LOCK_TYPE_WRLCK;\r\nbreak;\r\ncase F_UNLCK:\r\nflock.type = P9_LOCK_TYPE_UNLCK;\r\nbreak;\r\n}\r\nflock.start = fl->fl_start;\r\nif (fl->fl_end == OFFSET_MAX)\r\nflock.length = 0;\r\nelse\r\nflock.length = fl->fl_end - fl->fl_start + 1;\r\nflock.proc_id = fl->fl_pid;\r\nflock.client_id = fid->clnt->name;\r\nif (IS_SETLKW(cmd))\r\nflock.flags = P9_LOCK_FLAGS_BLOCK;\r\nfor (;;) {\r\nres = p9_client_lock_dotl(fid, &flock, &status);\r\nif (res < 0)\r\nbreak;\r\nif (status != P9_LOCK_BLOCKED)\r\nbreak;\r\nif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\r\nbreak;\r\nif (schedule_timeout_interruptible(P9_LOCK_TIMEOUT) != 0)\r\nbreak;\r\n}\r\nswitch (status) {\r\ncase P9_LOCK_SUCCESS:\r\nres = 0;\r\nbreak;\r\ncase P9_LOCK_BLOCKED:\r\nres = -EAGAIN;\r\nbreak;\r\ncase P9_LOCK_ERROR:\r\ncase P9_LOCK_GRACE:\r\nres = -ENOLCK;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (res < 0 && fl->fl_type != F_UNLCK) {\r\nfl_type = fl->fl_type;\r\nfl->fl_type = F_UNLCK;\r\nres = posix_lock_file_wait(filp, fl);\r\nfl->fl_type = fl_type;\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\r\n{\r\nstruct p9_getlock glock;\r\nstruct p9_fid *fid;\r\nint res = 0;\r\nfid = filp->private_data;\r\nBUG_ON(fid == NULL);\r\nposix_test_lock(filp, fl);\r\nif (fl->fl_type != F_UNLCK)\r\nreturn res;\r\nmemset(&glock, 0, sizeof(glock));\r\nglock.type = P9_LOCK_TYPE_UNLCK;\r\nglock.start = fl->fl_start;\r\nif (fl->fl_end == OFFSET_MAX)\r\nglock.length = 0;\r\nelse\r\nglock.length = fl->fl_end - fl->fl_start + 1;\r\nglock.proc_id = fl->fl_pid;\r\nglock.client_id = fid->clnt->name;\r\nres = p9_client_getlock_dotl(fid, &glock);\r\nif (res < 0)\r\nreturn res;\r\nswitch (glock.type) {\r\ncase P9_LOCK_TYPE_RDLCK:\r\nfl->fl_type = F_RDLCK;\r\nbreak;\r\ncase P9_LOCK_TYPE_WRLCK:\r\nfl->fl_type = F_WRLCK;\r\nbreak;\r\ncase P9_LOCK_TYPE_UNLCK:\r\nfl->fl_type = F_UNLCK;\r\nbreak;\r\n}\r\nif (glock.type != P9_LOCK_TYPE_UNLCK) {\r\nfl->fl_start = glock.start;\r\nif (glock.length == 0)\r\nfl->fl_end = OFFSET_MAX;\r\nelse\r\nfl->fl_end = glock.start + glock.length - 1;\r\nfl->fl_pid = glock.proc_id;\r\n}\r\nreturn res;\r\n}\r\nstatic int v9fs_file_lock_dotl(struct file *filp, int cmd, struct file_lock *fl)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nint ret = -ENOLCK;\r\np9_debug(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %pD\n",\r\nfilp, cmd, fl, filp);\r\nif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\r\ngoto out_err;\r\nif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\r\nfilemap_write_and_wait(inode->i_mapping);\r\ninvalidate_mapping_pages(&inode->i_data, 0, -1);\r\n}\r\nif (IS_SETLK(cmd) || IS_SETLKW(cmd))\r\nret = v9fs_file_do_lock(filp, cmd, fl);\r\nelse if (IS_GETLK(cmd))\r\nret = v9fs_file_getlock(filp, fl);\r\nelse\r\nret = -EINVAL;\r\nout_err:\r\nreturn ret;\r\n}\r\nstatic int v9fs_file_flock_dotl(struct file *filp, int cmd,\r\nstruct file_lock *fl)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nint ret = -ENOLCK;\r\np9_debug(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %pD\n",\r\nfilp, cmd, fl, filp);\r\nif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\r\ngoto out_err;\r\nif (!(fl->fl_flags & FL_FLOCK))\r\ngoto out_err;\r\nif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\r\nfilemap_write_and_wait(inode->i_mapping);\r\ninvalidate_mapping_pages(&inode->i_data, 0, -1);\r\n}\r\nfl->fl_flags |= FL_POSIX;\r\nfl->fl_flags ^= FL_FLOCK;\r\nif (IS_SETLK(cmd) | IS_SETLKW(cmd))\r\nret = v9fs_file_do_lock(filp, cmd, fl);\r\nelse\r\nret = -EINVAL;\r\nout_err:\r\nreturn ret;\r\n}\r\nssize_t\r\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\r\nu64 offset)\r\n{\r\nint n, total, size;\r\np9_debug(P9_DEBUG_VFS, "fid %d offset %llu count %d\n",\r\nfid->fid, (long long unsigned)offset, count);\r\nn = 0;\r\ntotal = 0;\r\nsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\r\ndo {\r\nn = p9_client_read(fid, data, udata, offset, count);\r\nif (n <= 0)\r\nbreak;\r\nif (data)\r\ndata += n;\r\nif (udata)\r\nudata += n;\r\noffset += n;\r\ncount -= n;\r\ntotal += n;\r\n} while (count > 0 && n == size);\r\nif (n < 0)\r\ntotal = n;\r\nreturn total;\r\n}\r\nssize_t\r\nv9fs_file_readn(struct file *filp, char *data, char __user *udata, u32 count,\r\nu64 offset)\r\n{\r\nreturn v9fs_fid_readn(filp->private_data, data, udata, count, offset);\r\n}\r\nstatic ssize_t\r\nv9fs_file_read(struct file *filp, char __user *udata, size_t count,\r\nloff_t * offset)\r\n{\r\nint ret;\r\nstruct p9_fid *fid;\r\nsize_t size;\r\np9_debug(P9_DEBUG_VFS, "count %zu offset %lld\n", count, *offset);\r\nfid = filp->private_data;\r\nsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\r\nif (count > size)\r\nret = v9fs_file_readn(filp, NULL, udata, count, *offset);\r\nelse\r\nret = p9_client_read(fid, NULL, udata, *offset, count);\r\nif (ret > 0)\r\n*offset += ret;\r\nreturn ret;\r\n}\r\nssize_t\r\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\r\nconst char __user *data, size_t count,\r\nloff_t *offset, int invalidate)\r\n{\r\nint n;\r\nloff_t i_size;\r\nsize_t total = 0;\r\nloff_t origin = *offset;\r\nunsigned long pg_start, pg_end;\r\np9_debug(P9_DEBUG_VFS, "data %p count %d offset %x\n",\r\ndata, (int)count, (int)*offset);\r\ndo {\r\nn = p9_client_write(fid, NULL, data+total, origin+total, count);\r\nif (n <= 0)\r\nbreak;\r\ncount -= n;\r\ntotal += n;\r\n} while (count > 0);\r\nif (invalidate && (total > 0)) {\r\npg_start = origin >> PAGE_CACHE_SHIFT;\r\npg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\r\nif (inode->i_mapping && inode->i_mapping->nrpages)\r\ninvalidate_inode_pages2_range(inode->i_mapping,\r\npg_start, pg_end);\r\n*offset += total;\r\ni_size = i_size_read(inode);\r\nif (*offset > i_size) {\r\ninode_add_bytes(inode, *offset - i_size);\r\ni_size_write(inode, *offset);\r\n}\r\n}\r\nif (n < 0)\r\nreturn n;\r\nreturn total;\r\n}\r\nstatic ssize_t\r\nv9fs_file_write(struct file *filp, const char __user * data,\r\nsize_t count, loff_t *offset)\r\n{\r\nssize_t retval = 0;\r\nloff_t origin = *offset;\r\nretval = generic_write_checks(filp, &origin, &count, 0);\r\nif (retval)\r\ngoto out;\r\nretval = -EINVAL;\r\nif ((ssize_t) count < 0)\r\ngoto out;\r\nretval = 0;\r\nif (!count)\r\ngoto out;\r\nretval = v9fs_file_write_internal(file_inode(filp),\r\nfilp->private_data,\r\ndata, count, &origin, 1);\r\nif (retval > 0)\r\n*offset = origin;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int v9fs_file_fsync(struct file *filp, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct p9_fid *fid;\r\nstruct inode *inode = filp->f_mapping->host;\r\nstruct p9_wstat wstat;\r\nint retval;\r\nretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (retval)\r\nreturn retval;\r\nmutex_lock(&inode->i_mutex);\r\np9_debug(P9_DEBUG_VFS, "filp %p datasync %x\n", filp, datasync);\r\nfid = filp->private_data;\r\nv9fs_blank_wstat(&wstat);\r\nretval = p9_client_wstat(fid, &wstat);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn retval;\r\n}\r\nint v9fs_file_fsync_dotl(struct file *filp, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct p9_fid *fid;\r\nstruct inode *inode = filp->f_mapping->host;\r\nint retval;\r\nretval = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (retval)\r\nreturn retval;\r\nmutex_lock(&inode->i_mutex);\r\np9_debug(P9_DEBUG_VFS, "filp %p datasync %x\n", filp, datasync);\r\nfid = filp->private_data;\r\nretval = p9_client_fsync(fid, datasync);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn retval;\r\n}\r\nstatic int\r\nv9fs_file_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint retval;\r\nretval = generic_file_mmap(filp, vma);\r\nif (!retval)\r\nvma->vm_ops = &v9fs_file_vm_ops;\r\nreturn retval;\r\n}\r\nstatic int\r\nv9fs_mmap_file_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint retval;\r\nstruct inode *inode;\r\nstruct v9fs_inode *v9inode;\r\nstruct p9_fid *fid;\r\ninode = file_inode(filp);\r\nv9inode = V9FS_I(inode);\r\nmutex_lock(&v9inode->v_mutex);\r\nif (!v9inode->writeback_fid &&\r\n(vma->vm_flags & VM_WRITE)) {\r\nfid = v9fs_writeback_fid(filp->f_path.dentry);\r\nif (IS_ERR(fid)) {\r\nretval = PTR_ERR(fid);\r\nmutex_unlock(&v9inode->v_mutex);\r\nreturn retval;\r\n}\r\nv9inode->writeback_fid = (void *) fid;\r\n}\r\nmutex_unlock(&v9inode->v_mutex);\r\nretval = generic_file_mmap(filp, vma);\r\nif (!retval)\r\nvma->vm_ops = &v9fs_mmap_file_vm_ops;\r\nreturn retval;\r\n}\r\nstatic int\r\nv9fs_vm_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct v9fs_inode *v9inode;\r\nstruct page *page = vmf->page;\r\nstruct file *filp = vma->vm_file;\r\nstruct inode *inode = file_inode(filp);\r\np9_debug(P9_DEBUG_VFS, "page %p fid %lx\n",\r\npage, (unsigned long)filp->private_data);\r\nfile_update_time(filp);\r\nv9inode = V9FS_I(inode);\r\nv9fs_fscache_wait_on_page_write(inode, page);\r\nBUG_ON(!v9inode->writeback_fid);\r\nlock_page(page);\r\nif (page->mapping != inode->i_mapping)\r\ngoto out_unlock;\r\nwait_for_stable_page(page);\r\nreturn VM_FAULT_LOCKED;\r\nout_unlock:\r\nunlock_page(page);\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nstatic ssize_t\r\nv9fs_direct_read(struct file *filp, char __user *udata, size_t count,\r\nloff_t *offsetp)\r\n{\r\nloff_t size, offset;\r\nstruct inode *inode;\r\nstruct address_space *mapping;\r\noffset = *offsetp;\r\nmapping = filp->f_mapping;\r\ninode = mapping->host;\r\nif (!count)\r\nreturn 0;\r\nsize = i_size_read(inode);\r\nif (offset < size)\r\nfilemap_write_and_wait_range(mapping, offset,\r\noffset + count - 1);\r\nreturn v9fs_file_read(filp, udata, count, offsetp);\r\n}\r\nstatic ssize_t\r\nv9fs_cached_file_read(struct file *filp, char __user *data, size_t count,\r\nloff_t *offset)\r\n{\r\nif (filp->f_flags & O_DIRECT)\r\nreturn v9fs_direct_read(filp, data, count, offset);\r\nreturn new_sync_read(filp, data, count, offset);\r\n}\r\nstatic ssize_t\r\nv9fs_mmap_file_read(struct file *filp, char __user *data, size_t count,\r\nloff_t *offset)\r\n{\r\nreturn v9fs_file_read(filp, data, count, offset);\r\n}\r\nstatic ssize_t\r\nv9fs_direct_write(struct file *filp, const char __user * data,\r\nsize_t count, loff_t *offsetp)\r\n{\r\nloff_t offset;\r\nssize_t retval;\r\nstruct inode *inode;\r\nstruct address_space *mapping;\r\noffset = *offsetp;\r\nmapping = filp->f_mapping;\r\ninode = mapping->host;\r\nif (!count)\r\nreturn 0;\r\nmutex_lock(&inode->i_mutex);\r\nretval = filemap_write_and_wait_range(mapping, offset,\r\noffset + count - 1);\r\nif (retval)\r\ngoto err_out;\r\nif (mapping->nrpages) {\r\npgoff_t pg_start = offset >> PAGE_CACHE_SHIFT;\r\npgoff_t pg_end = (offset + count - 1) >> PAGE_CACHE_SHIFT;\r\nretval = invalidate_inode_pages2_range(mapping,\r\npg_start, pg_end);\r\nif (retval) {\r\nif (retval == -EBUSY)\r\ngoto buff_write;\r\ngoto err_out;\r\n}\r\n}\r\nretval = v9fs_file_write(filp, data, count, offsetp);\r\nerr_out:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn retval;\r\nbuff_write:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn new_sync_write(filp, data, count, offsetp);\r\n}\r\nstatic ssize_t\r\nv9fs_cached_file_write(struct file *filp, const char __user * data,\r\nsize_t count, loff_t *offset)\r\n{\r\nif (filp->f_flags & O_DIRECT)\r\nreturn v9fs_direct_write(filp, data, count, offset);\r\nreturn new_sync_write(filp, data, count, offset);\r\n}\r\nstatic ssize_t\r\nv9fs_mmap_file_write(struct file *filp, const char __user *data,\r\nsize_t count, loff_t *offset)\r\n{\r\nreturn v9fs_file_write(filp, data, count, offset);\r\n}\r\nstatic void v9fs_mmap_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct inode *inode;\r\nstruct writeback_control wbc = {\r\n.nr_to_write = LONG_MAX,\r\n.sync_mode = WB_SYNC_ALL,\r\n.range_start = vma->vm_pgoff * PAGE_SIZE,\r\n.range_end = vma->vm_pgoff * PAGE_SIZE +\r\n(vma->vm_end - vma->vm_start - 1),\r\n};\r\np9_debug(P9_DEBUG_VFS, "9p VMA close, %p, flushing", vma);\r\ninode = file_inode(vma->vm_file);\r\nif (!mapping_cap_writeback_dirty(inode->i_mapping))\r\nwbc.nr_to_write = 0;\r\nmight_sleep();\r\nsync_inode(inode, &wbc);\r\n}
