static int of_get_phy_id(struct device_node *device, u32 *phy_id)\r\n{\r\nstruct property *prop;\r\nconst char *cp;\r\nunsigned int upper, lower;\r\nof_property_for_each_string(device, "compatible", prop, cp) {\r\nif (sscanf(cp, "ethernet-phy-id%4x.%4x", &upper, &lower) == 2) {\r\n*phy_id = ((upper & 0xFFFF) << 16) | (lower & 0xFFFF);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,\r\nu32 addr)\r\n{\r\nstruct phy_device *phy;\r\nbool is_c45;\r\nint rc;\r\nu32 phy_id;\r\nis_c45 = of_device_is_compatible(child,\r\n"ethernet-phy-ieee802.3-c45");\r\nif (!is_c45 && !of_get_phy_id(child, &phy_id))\r\nphy = phy_device_create(mdio, addr, phy_id, 0, NULL);\r\nelse\r\nphy = get_phy_device(mdio, addr, is_c45);\r\nif (!phy || IS_ERR(phy))\r\nreturn 1;\r\nrc = irq_of_parse_and_map(child, 0);\r\nif (rc > 0) {\r\nphy->irq = rc;\r\nif (mdio->irq)\r\nmdio->irq[addr] = rc;\r\n} else {\r\nif (mdio->irq)\r\nphy->irq = mdio->irq[addr];\r\n}\r\nof_node_get(child);\r\nphy->dev.of_node = child;\r\nrc = phy_device_register(phy);\r\nif (rc) {\r\nphy_device_free(phy);\r\nof_node_put(child);\r\nreturn 1;\r\n}\r\ndev_dbg(&mdio->dev, "registered phy %s at address %i\n",\r\nchild->name, addr);\r\nreturn 0;\r\n}\r\nstatic int of_mdio_parse_addr(struct device *dev, const struct device_node *np)\r\n{\r\nu32 addr;\r\nint ret;\r\nret = of_property_read_u32(np, "reg", &addr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s has invalid PHY address\n", np->full_name);\r\nreturn ret;\r\n}\r\nif (addr >= PHY_MAX_ADDR) {\r\ndev_err(dev, "%s PHY address %i is too large\n",\r\nnp->full_name, addr);\r\nreturn -EINVAL;\r\n}\r\nreturn addr;\r\n}\r\nint of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)\r\n{\r\nstruct device_node *child;\r\nconst __be32 *paddr;\r\nbool scanphys = false;\r\nint addr, rc, i;\r\nmdio->phy_mask = ~0;\r\nif (mdio->irq)\r\nfor (i=0; i<PHY_MAX_ADDR; i++)\r\nmdio->irq[i] = PHY_POLL;\r\nmdio->dev.of_node = np;\r\nrc = mdiobus_register(mdio);\r\nif (rc)\r\nreturn rc;\r\nfor_each_available_child_of_node(np, child) {\r\naddr = of_mdio_parse_addr(&mdio->dev, child);\r\nif (addr < 0) {\r\nscanphys = true;\r\ncontinue;\r\n}\r\nrc = of_mdiobus_register_phy(mdio, child, addr);\r\nif (rc)\r\ncontinue;\r\n}\r\nif (!scanphys)\r\nreturn 0;\r\nfor_each_available_child_of_node(np, child) {\r\npaddr = of_get_property(child, "reg", NULL);\r\nif (paddr)\r\ncontinue;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nif (mdio->phy_map[addr])\r\ncontinue;\r\ndev_info(&mdio->dev, "scan phy %s at address %i\n",\r\nchild->name, addr);\r\nrc = of_mdiobus_register_phy(mdio, child, addr);\r\nif (rc)\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_phy_match(struct device *dev, void *phy_np)\r\n{\r\nreturn dev->of_node == phy_np;\r\n}\r\nstruct phy_device *of_phy_find_device(struct device_node *phy_np)\r\n{\r\nstruct device *d;\r\nif (!phy_np)\r\nreturn NULL;\r\nd = bus_find_device(&mdio_bus_type, NULL, phy_np, of_phy_match);\r\nreturn d ? to_phy_device(d) : NULL;\r\n}\r\nstruct phy_device *of_phy_connect(struct net_device *dev,\r\nstruct device_node *phy_np,\r\nvoid (*hndlr)(struct net_device *), u32 flags,\r\nphy_interface_t iface)\r\n{\r\nstruct phy_device *phy = of_phy_find_device(phy_np);\r\nif (!phy)\r\nreturn NULL;\r\nphy->dev_flags = flags;\r\nreturn phy_connect_direct(dev, phy, hndlr, iface) ? NULL : phy;\r\n}\r\nstruct phy_device *of_phy_attach(struct net_device *dev,\r\nstruct device_node *phy_np, u32 flags,\r\nphy_interface_t iface)\r\n{\r\nstruct phy_device *phy = of_phy_find_device(phy_np);\r\nif (!phy)\r\nreturn NULL;\r\nreturn phy_attach_direct(dev, phy, flags, iface) ? NULL : phy;\r\n}\r\nbool of_phy_is_fixed_link(struct device_node *np)\r\n{\r\nstruct device_node *dn;\r\nint len;\r\ndn = of_get_child_by_name(np, "fixed-link");\r\nif (dn) {\r\nof_node_put(dn);\r\nreturn true;\r\n}\r\nif (of_get_property(np, "fixed-link", &len) &&\r\nlen == (5 * sizeof(__be32)))\r\nreturn true;\r\nreturn false;\r\n}\r\nint of_phy_register_fixed_link(struct device_node *np)\r\n{\r\nstruct fixed_phy_status status = {};\r\nstruct device_node *fixed_link_node;\r\nconst __be32 *fixed_link_prop;\r\nint len;\r\nstruct phy_device *phy;\r\nfixed_link_node = of_get_child_by_name(np, "fixed-link");\r\nif (fixed_link_node) {\r\nstatus.link = 1;\r\nstatus.duplex = of_property_read_bool(fixed_link_node,\r\n"full-duplex");\r\nif (of_property_read_u32(fixed_link_node, "speed", &status.speed))\r\nreturn -EINVAL;\r\nstatus.pause = of_property_read_bool(fixed_link_node, "pause");\r\nstatus.asym_pause = of_property_read_bool(fixed_link_node,\r\n"asym-pause");\r\nof_node_put(fixed_link_node);\r\nphy = fixed_phy_register(PHY_POLL, &status, np);\r\nreturn IS_ERR(phy) ? PTR_ERR(phy) : 0;\r\n}\r\nfixed_link_prop = of_get_property(np, "fixed-link", &len);\r\nif (fixed_link_prop && len == (5 * sizeof(__be32))) {\r\nstatus.link = 1;\r\nstatus.duplex = be32_to_cpu(fixed_link_prop[1]);\r\nstatus.speed = be32_to_cpu(fixed_link_prop[2]);\r\nstatus.pause = be32_to_cpu(fixed_link_prop[3]);\r\nstatus.asym_pause = be32_to_cpu(fixed_link_prop[4]);\r\nphy = fixed_phy_register(PHY_POLL, &status, np);\r\nreturn IS_ERR(phy) ? PTR_ERR(phy) : 0;\r\n}\r\nreturn -ENODEV;\r\n}
