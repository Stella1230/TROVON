void hostap_dump_tx_80211(const char *name, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nprintk(KERN_DEBUG "%s: TX len=%d jiffies=%ld\n",\r\nname, skb->len, jiffies);\r\nif (skb->len < 2)\r\nreturn;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nprintk(KERN_DEBUG " FC=0x%04x (type=%d:%d)%s%s",\r\nfc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\r\n(fc & IEEE80211_FCTL_STYPE) >> 4,\r\nfc & IEEE80211_FCTL_TODS ? " [ToDS]" : "",\r\nfc & IEEE80211_FCTL_FROMDS ? " [FromDS]" : "");\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN) {\r\nprintk("\n");\r\nreturn;\r\n}\r\nprintk(" dur=0x%04x seq=0x%04x\n", le16_to_cpu(hdr->duration_id),\r\nle16_to_cpu(hdr->seq_ctrl));\r\nprintk(KERN_DEBUG " A1=%pM", hdr->addr1);\r\nprintk(" A2=%pM", hdr->addr2);\r\nprintk(" A3=%pM", hdr->addr3);\r\nif (skb->len >= 30)\r\nprintk(" A4=%pM", hdr->addr4);\r\nprintk("\n");\r\n}\r\nnetdev_tx_t hostap_data_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint need_headroom, need_tailroom = 0;\r\nstruct ieee80211_hdr hdr;\r\nu16 fc, ethertype = 0;\r\nenum {\r\nWDS_NO = 0, WDS_OWN_FRAME, WDS_COMPLIANT_FRAME\r\n} use_wds = WDS_NO;\r\nu8 *encaps_data;\r\nint hdr_len, encaps_len, skip_header_bytes;\r\nint to_assoc_ap = 0;\r\nstruct hostap_skb_tx_data *meta;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (skb->len < ETH_HLEN) {\r\nprintk(KERN_DEBUG "%s: hostap_data_start_xmit: short skb "\r\n"(len=%d)\n", dev->name, skb->len);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (local->ddev != dev) {\r\nuse_wds = (local->iw_mode == IW_MODE_MASTER &&\r\n!(local->wds_type & HOSTAP_WDS_STANDARD_FRAME)) ?\r\nWDS_OWN_FRAME : WDS_COMPLIANT_FRAME;\r\nif (dev == local->stadev) {\r\nto_assoc_ap = 1;\r\nuse_wds = WDS_NO;\r\n} else if (dev == local->apdev) {\r\nprintk(KERN_DEBUG "%s: prism2_tx: trying to use "\r\n"AP device with Ethernet net dev\n", dev->name);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n} else {\r\nif (local->iw_mode == IW_MODE_REPEAT) {\r\nprintk(KERN_DEBUG "%s: prism2_tx: trying to use "\r\n"non-WDS link in Repeater mode\n", dev->name);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else if (local->iw_mode == IW_MODE_INFRA &&\r\n(local->wds_type & HOSTAP_WDS_AP_CLIENT) &&\r\n!ether_addr_equal(skb->data + ETH_ALEN, dev->dev_addr)) {\r\nuse_wds = WDS_COMPLIANT_FRAME;\r\n}\r\n}\r\nethertype = (skb->data[12] << 8) | skb->data[13];\r\nmemset(&hdr, 0, sizeof(hdr));\r\nencaps_data = NULL;\r\nencaps_len = 0;\r\nskip_header_bytes = ETH_HLEN;\r\nif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\r\nencaps_data = bridge_tunnel_header;\r\nencaps_len = sizeof(bridge_tunnel_header);\r\nskip_header_bytes -= 2;\r\n} else if (ethertype >= 0x600) {\r\nencaps_data = rfc1042_header;\r\nencaps_len = sizeof(rfc1042_header);\r\nskip_header_bytes -= 2;\r\n}\r\nfc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA;\r\nhdr_len = IEEE80211_DATA_HDR3_LEN;\r\nif (use_wds != WDS_NO) {\r\nif (use_wds == WDS_COMPLIANT_FRAME) {\r\nfc |= IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS;\r\nskb_copy_from_linear_data_offset(skb, ETH_ALEN,\r\n&hdr.addr4, ETH_ALEN);\r\nhdr_len += ETH_ALEN;\r\n} else {\r\nfc |= IEEE80211_FCTL_TODS;\r\nskb_copy_from_linear_data_offset(skb, ETH_ALEN,\r\n&hdr.addr4, ETH_ALEN);\r\nneed_tailroom += ETH_ALEN;\r\n}\r\nif ((local->wds_type & HOSTAP_WDS_BROADCAST_RA) &&\r\nskb->data[0] & 0x01)\r\nmemset(&hdr.addr1, 0xff, ETH_ALEN);\r\nelse if (iface->type == HOSTAP_INTERFACE_WDS)\r\nmemcpy(&hdr.addr1, iface->u.wds.remote_addr,\r\nETH_ALEN);\r\nelse\r\nmemcpy(&hdr.addr1, local->bssid, ETH_ALEN);\r\nmemcpy(&hdr.addr2, dev->dev_addr, ETH_ALEN);\r\nskb_copy_from_linear_data(skb, &hdr.addr3, ETH_ALEN);\r\n} else if (local->iw_mode == IW_MODE_MASTER && !to_assoc_ap) {\r\nfc |= IEEE80211_FCTL_FROMDS;\r\nskb_copy_from_linear_data(skb, &hdr.addr1, ETH_ALEN);\r\nmemcpy(&hdr.addr2, dev->dev_addr, ETH_ALEN);\r\nskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr3,\r\nETH_ALEN);\r\n} else if (local->iw_mode == IW_MODE_INFRA || to_assoc_ap) {\r\nfc |= IEEE80211_FCTL_TODS;\r\nmemcpy(&hdr.addr1, to_assoc_ap ?\r\nlocal->assoc_ap_addr : local->bssid, ETH_ALEN);\r\nskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr2,\r\nETH_ALEN);\r\nskb_copy_from_linear_data(skb, &hdr.addr3, ETH_ALEN);\r\n} else if (local->iw_mode == IW_MODE_ADHOC) {\r\nskb_copy_from_linear_data(skb, &hdr.addr1, ETH_ALEN);\r\nskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr2,\r\nETH_ALEN);\r\nmemcpy(&hdr.addr3, local->bssid, ETH_ALEN);\r\n}\r\nhdr.frame_control = cpu_to_le16(fc);\r\nskb_pull(skb, skip_header_bytes);\r\nneed_headroom = local->func->need_tx_headroom + hdr_len + encaps_len;\r\nif (skb_tailroom(skb) < need_tailroom) {\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL) {\r\niface->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (pskb_expand_head(skb, need_headroom, need_tailroom,\r\nGFP_ATOMIC)) {\r\nkfree_skb(skb);\r\niface->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\n} else if (skb_headroom(skb) < need_headroom) {\r\nstruct sk_buff *tmp = skb;\r\nskb = skb_realloc_headroom(skb, need_headroom);\r\nkfree_skb(tmp);\r\nif (skb == NULL) {\r\niface->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\n} else {\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL) {\r\niface->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nif (encaps_data)\r\nmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\r\nmemcpy(skb_push(skb, hdr_len), &hdr, hdr_len);\r\nif (use_wds == WDS_OWN_FRAME) {\r\nmemcpy(skb_put(skb, ETH_ALEN), &hdr.addr4, ETH_ALEN);\r\n}\r\niface->stats.tx_packets++;\r\niface->stats.tx_bytes += skb->len;\r\nskb_reset_mac_header(skb);\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nmemset(meta, 0, sizeof(*meta));\r\nmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\r\nif (use_wds)\r\nmeta->flags |= HOSTAP_TX_FLAGS_WDS;\r\nmeta->ethertype = ethertype;\r\nmeta->iface = iface;\r\nskb->dev = local->dev;\r\ndev_queue_xmit(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetdev_tx_t hostap_mgmt_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hostap_skb_tx_data *meta;\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (skb->len < 10) {\r\nprintk(KERN_DEBUG "%s: hostap_mgmt_start_xmit: short skb "\r\n"(len=%d)\n", dev->name, skb->len);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\niface->stats.tx_packets++;\r\niface->stats.tx_bytes += skb->len;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nmemset(meta, 0, sizeof(*meta));\r\nmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\r\nmeta->iface = iface;\r\nif (skb->len >= IEEE80211_DATA_HDR3_LEN + sizeof(rfc1042_header) + 2) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nif (ieee80211_is_data(hdr->frame_control) &&\r\n(fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_DATA) {\r\nu8 *pos = &skb->data[IEEE80211_DATA_HDR3_LEN +\r\nsizeof(rfc1042_header)];\r\nmeta->ethertype = (pos[0] << 8) | pos[1];\r\n}\r\n}\r\nskb->dev = local->dev;\r\ndev_queue_xmit(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct sk_buff * hostap_tx_encrypt(struct sk_buff *skb,\r\nstruct lib80211_crypt_data *crypt)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct ieee80211_hdr *hdr;\r\nint prefix_len, postfix_len, hdr_len, res;\r\niface = netdev_priv(skb->dev);\r\nlocal = iface->local;\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nif (local->tkip_countermeasures &&\r\nstrcmp(crypt->ops->name, "TKIP") == 0) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: TKIP countermeasures: dropped "\r\n"TX packet to %pM\n",\r\nlocal->dev->name, hdr->addr1);\r\n}\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn NULL;\r\nprefix_len = crypt->ops->extra_mpdu_prefix_len +\r\ncrypt->ops->extra_msdu_prefix_len;\r\npostfix_len = crypt->ops->extra_mpdu_postfix_len +\r\ncrypt->ops->extra_msdu_postfix_len;\r\nif ((skb_headroom(skb) < prefix_len ||\r\nskb_tailroom(skb) < postfix_len) &&\r\npskb_expand_head(skb, prefix_len, postfix_len, GFP_ATOMIC)) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nhdr_len = hostap_80211_get_hdrlen(hdr->frame_control);\r\natomic_inc(&crypt->refcnt);\r\nres = 0;\r\nif (crypt->ops->encrypt_msdu)\r\nres = crypt->ops->encrypt_msdu(skb, hdr_len, crypt->priv);\r\nif (res == 0 && crypt->ops->encrypt_mpdu)\r\nres = crypt->ops->encrypt_mpdu(skb, hdr_len, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nreturn skb;\r\n}\r\nnetdev_tx_t hostap_master_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nnetdev_tx_t ret = NETDEV_TX_BUSY;\r\nu16 fc;\r\nstruct hostap_tx_data tx;\r\nap_tx_ret tx_ret;\r\nstruct hostap_skb_tx_data *meta;\r\nint no_encrypt = 0;\r\nstruct ieee80211_hdr *hdr;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ntx.skb = skb;\r\ntx.sta_ptr = NULL;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nif (meta->magic != HOSTAP_SKB_TX_DATA_MAGIC) {\r\nprintk(KERN_DEBUG "%s: invalid skb->cb magic (0x%08x, "\r\n"expected 0x%08x)\n",\r\ndev->name, meta->magic, HOSTAP_SKB_TX_DATA_MAGIC);\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\ngoto fail;\r\n}\r\nif (local->host_encrypt) {\r\ntx.crypt = local->crypt_info.crypt[local->crypt_info.tx_keyidx];\r\ntx.host_encrypt = 1;\r\n} else {\r\ntx.crypt = NULL;\r\ntx.host_encrypt = 0;\r\n}\r\nif (skb->len < 24) {\r\nprintk(KERN_DEBUG "%s: hostap_master_start_xmit: short skb "\r\n"(len=%d)\n", dev->name, skb->len);\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\ngoto fail;\r\n}\r\ntx_ret = hostap_handle_sta_tx(local, &tx);\r\nskb = tx.skb;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nswitch (tx_ret) {\r\ncase AP_TX_CONTINUE:\r\nbreak;\r\ncase AP_TX_CONTINUE_NOT_AUTHORIZED:\r\nif (local->ieee_802_1x &&\r\nieee80211_is_data(hdr->frame_control) &&\r\nmeta->ethertype != ETH_P_PAE &&\r\n!(meta->flags & HOSTAP_TX_FLAGS_WDS)) {\r\nprintk(KERN_DEBUG "%s: dropped frame to unauthorized "\r\n"port (IEEE 802.1X): ethertype=0x%04x\n",\r\ndev->name, meta->ethertype);\r\nhostap_dump_tx_80211(dev->name, skb);\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\ngoto fail;\r\n}\r\nbreak;\r\ncase AP_TX_DROP:\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\ngoto fail;\r\ncase AP_TX_RETRY:\r\ngoto fail;\r\ncase AP_TX_BUFFERED:\r\nret = NETDEV_TX_OK;\r\ngoto tx_exit;\r\n}\r\nif (((fc & IEEE80211_FCTL_VERS) == BIT(1)) &&\r\nlocal->ap && local->ap->tx_callback_idx && meta->tx_cb_idx == 0) {\r\nmeta->tx_cb_idx = local->ap->tx_callback_idx;\r\nfc &= ~IEEE80211_FCTL_VERS;\r\nhdr->frame_control = cpu_to_le16(fc);\r\n}\r\nif (!ieee80211_is_data(hdr->frame_control)) {\r\nno_encrypt = 1;\r\ntx.crypt = NULL;\r\n}\r\nif (local->ieee_802_1x && meta->ethertype == ETH_P_PAE && tx.crypt &&\r\n!(fc & IEEE80211_FCTL_PROTECTED)) {\r\nno_encrypt = 1;\r\nPDEBUG(DEBUG_EXTRA2, "%s: TX: IEEE 802.1X - passing "\r\n"unencrypted EAPOL frame\n", dev->name);\r\ntx.crypt = NULL;\r\n}\r\nif (tx.crypt && (!tx.crypt->ops || !tx.crypt->ops->encrypt_mpdu))\r\ntx.crypt = NULL;\r\nelse if ((tx.crypt ||\r\nlocal->crypt_info.crypt[local->crypt_info.tx_keyidx]) &&\r\n!no_encrypt) {\r\nfc |= IEEE80211_FCTL_PROTECTED;\r\nhdr->frame_control = cpu_to_le16(fc);\r\n} else if (local->drop_unencrypted &&\r\nieee80211_is_data(hdr->frame_control) &&\r\nmeta->ethertype != ETH_P_PAE) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: dropped unencrypted TX data "\r\n"frame (drop_unencrypted=1)\n", dev->name);\r\n}\r\niface->stats.tx_dropped++;\r\nret = NETDEV_TX_OK;\r\ngoto fail;\r\n}\r\nif (tx.crypt) {\r\nskb = hostap_tx_encrypt(skb, tx.crypt);\r\nif (skb == NULL) {\r\nprintk(KERN_DEBUG "%s: TX - encryption failed\n",\r\ndev->name);\r\nret = NETDEV_TX_OK;\r\ngoto fail;\r\n}\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nif (meta->magic != HOSTAP_SKB_TX_DATA_MAGIC) {\r\nprintk(KERN_DEBUG "%s: invalid skb->cb magic (0x%08x, "\r\n"expected 0x%08x) after hostap_tx_encrypt\n",\r\ndev->name, meta->magic,\r\nHOSTAP_SKB_TX_DATA_MAGIC);\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\ngoto fail;\r\n}\r\n}\r\nif (local->func->tx == NULL || local->func->tx(skb, dev)) {\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_dropped++;\r\n} else {\r\nret = NETDEV_TX_OK;\r\niface->stats.tx_packets++;\r\niface->stats.tx_bytes += skb->len;\r\n}\r\nfail:\r\nif (ret == NETDEV_TX_OK && skb)\r\ndev_kfree_skb(skb);\r\ntx_exit:\r\nif (tx.sta_ptr)\r\nhostap_handle_sta_release(tx.sta_ptr);\r\nreturn ret;\r\n}
