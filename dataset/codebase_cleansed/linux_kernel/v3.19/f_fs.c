static struct ffs_function *ffs_func_from_usb(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct ffs_function, function);\r\n}\r\nstatic inline enum ffs_setup_state\r\nffs_setup_state_clear_cancelled(struct ffs_data *ffs)\r\n{\r\nreturn (enum ffs_setup_state)\r\ncmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);\r\n}\r\nstatic void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ffs_data *ffs = req->context;\r\ncomplete_all(&ffs->ep0req_completion);\r\n}\r\nstatic int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)\r\n{\r\nstruct usb_request *req = ffs->ep0req;\r\nint ret;\r\nreq->zero = len < le16_to_cpu(ffs->ev.setup.wLength);\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nreq->buf = data;\r\nreq->length = len;\r\nif (req->buf == NULL)\r\nreq->buf = (void *)0xDEADBABE;\r\nreinit_completion(&ffs->ep0req_completion);\r\nret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nret = wait_for_completion_interruptible(&ffs->ep0req_completion);\r\nif (unlikely(ret)) {\r\nusb_ep_dequeue(ffs->gadget->ep0, req);\r\nreturn -EINTR;\r\n}\r\nffs->setup_state = FFS_NO_SETUP;\r\nreturn req->status ? req->status : req->actual;\r\n}\r\nstatic int __ffs_ep0_stall(struct ffs_data *ffs)\r\n{\r\nif (ffs->ev.can_stall) {\r\npr_vdebug("ep0 stall\n");\r\nusb_ep_set_halt(ffs->gadget->ep0);\r\nffs->setup_state = FFS_NO_SETUP;\r\nreturn -EL2HLT;\r\n} else {\r\npr_debug("bogus ep0 stall!\n");\r\nreturn -ESRCH;\r\n}\r\n}\r\nstatic ssize_t ffs_ep0_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ptr)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nssize_t ret;\r\nchar *data;\r\nENTER();\r\nif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\r\nreturn -EIDRM;\r\nret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nswitch (ffs->state) {\r\ncase FFS_READ_DESCRIPTORS:\r\ncase FFS_READ_STRINGS:\r\nif (unlikely(len < 16)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata = ffs_prepare_buffer(buf, len);\r\nif (IS_ERR(data)) {\r\nret = PTR_ERR(data);\r\nbreak;\r\n}\r\nif (ffs->state == FFS_READ_DESCRIPTORS) {\r\npr_info("read descriptors\n");\r\nret = __ffs_data_got_descs(ffs, data, len);\r\nif (unlikely(ret < 0))\r\nbreak;\r\nffs->state = FFS_READ_STRINGS;\r\nret = len;\r\n} else {\r\npr_info("read strings\n");\r\nret = __ffs_data_got_strings(ffs, data, len);\r\nif (unlikely(ret < 0))\r\nbreak;\r\nret = ffs_epfiles_create(ffs);\r\nif (unlikely(ret)) {\r\nffs->state = FFS_CLOSING;\r\nbreak;\r\n}\r\nffs->state = FFS_ACTIVE;\r\nmutex_unlock(&ffs->mutex);\r\nret = ffs_ready(ffs);\r\nif (unlikely(ret < 0)) {\r\nffs->state = FFS_CLOSING;\r\nreturn ret;\r\n}\r\nset_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);\r\nreturn len;\r\n}\r\nbreak;\r\ncase FFS_ACTIVE:\r\ndata = NULL;\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nswitch (ffs_setup_state_clear_cancelled(ffs)) {\r\ncase FFS_SETUP_CANCELLED:\r\nret = -EIDRM;\r\ngoto done_spin;\r\ncase FFS_NO_SETUP:\r\nret = -ESRCH;\r\ngoto done_spin;\r\ncase FFS_SETUP_PENDING:\r\nbreak;\r\n}\r\nif (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nret = __ffs_ep0_stall(ffs);\r\nbreak;\r\n}\r\nlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\ndata = ffs_prepare_buffer(buf, len);\r\nif (IS_ERR(data)) {\r\nret = PTR_ERR(data);\r\nbreak;\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nif (ffs_setup_state_clear_cancelled(ffs) ==\r\nFFS_SETUP_CANCELLED) {\r\nret = -EIDRM;\r\ndone_spin:\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\n} else {\r\nret = __ffs_ep0_queue_wait(ffs, data, len);\r\n}\r\nkfree(data);\r\nbreak;\r\ndefault:\r\nret = -EBADFD;\r\nbreak;\r\n}\r\nmutex_unlock(&ffs->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf,\r\nsize_t n)\r\n{\r\nstruct usb_functionfs_event events[n];\r\nunsigned i = 0;\r\nmemset(events, 0, sizeof events);\r\ndo {\r\nevents[i].type = ffs->ev.types[i];\r\nif (events[i].type == FUNCTIONFS_SETUP) {\r\nevents[i].u.setup = ffs->ev.setup;\r\nffs->setup_state = FFS_SETUP_PENDING;\r\n}\r\n} while (++i < n);\r\nif (n < ffs->ev.count) {\r\nffs->ev.count -= n;\r\nmemmove(ffs->ev.types, ffs->ev.types + n,\r\nffs->ev.count * sizeof *ffs->ev.types);\r\n} else {\r\nffs->ev.count = 0;\r\n}\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nmutex_unlock(&ffs->mutex);\r\nreturn unlikely(__copy_to_user(buf, events, sizeof events))\r\n? -EFAULT : sizeof events;\r\n}\r\nstatic ssize_t ffs_ep0_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ptr)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nchar *data = NULL;\r\nsize_t n;\r\nint ret;\r\nENTER();\r\nif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\r\nreturn -EIDRM;\r\nret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nif (ffs->state != FFS_ACTIVE) {\r\nret = -EBADFD;\r\ngoto done_mutex;\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nswitch (ffs_setup_state_clear_cancelled(ffs)) {\r\ncase FFS_SETUP_CANCELLED:\r\nret = -EIDRM;\r\nbreak;\r\ncase FFS_NO_SETUP:\r\nn = len / sizeof(struct usb_functionfs_event);\r\nif (unlikely(!n)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,\r\nffs->ev.count)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\nreturn __ffs_ep0_read_events(ffs, buf,\r\nmin(n, (size_t)ffs->ev.count));\r\ncase FFS_SETUP_PENDING:\r\nif (ffs->ev.setup.bRequestType & USB_DIR_IN) {\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nret = __ffs_ep0_stall(ffs);\r\ngoto done_mutex;\r\n}\r\nlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nif (likely(len)) {\r\ndata = kmalloc(len, GFP_KERNEL);\r\nif (unlikely(!data)) {\r\nret = -ENOMEM;\r\ngoto done_mutex;\r\n}\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nif (ffs_setup_state_clear_cancelled(ffs) ==\r\nFFS_SETUP_CANCELLED) {\r\nret = -EIDRM;\r\nbreak;\r\n}\r\nret = __ffs_ep0_queue_wait(ffs, data, len);\r\nif (likely(ret > 0) && unlikely(__copy_to_user(buf, data, len)))\r\nret = -EFAULT;\r\ngoto done_mutex;\r\ndefault:\r\nret = -EBADFD;\r\nbreak;\r\n}\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\ndone_mutex:\r\nmutex_unlock(&ffs->mutex);\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ffs_ep0_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_data *ffs = inode->i_private;\r\nENTER();\r\nif (unlikely(ffs->state == FFS_CLOSING))\r\nreturn -EBUSY;\r\nfile->private_data = ffs;\r\nffs_data_opened(ffs);\r\nreturn 0;\r\n}\r\nstatic int ffs_ep0_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nENTER();\r\nffs_data_closed(ffs);\r\nreturn 0;\r\n}\r\nstatic long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nstruct usb_gadget *gadget = ffs->gadget;\r\nlong ret;\r\nENTER();\r\nif (code == FUNCTIONFS_INTERFACE_REVMAP) {\r\nstruct ffs_function *func = ffs->func;\r\nret = func ? ffs_func_revmap_intf(func, value) : -ENODEV;\r\n} else if (gadget && gadget->ops->ioctl) {\r\nret = gadget->ops->ioctl(gadget, code, value);\r\n} else {\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int ffs_ep0_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nunsigned int mask = POLLWRNORM;\r\nint ret;\r\npoll_wait(file, &ffs->ev.waitq, wait);\r\nret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret < 0))\r\nreturn mask;\r\nswitch (ffs->state) {\r\ncase FFS_READ_DESCRIPTORS:\r\ncase FFS_READ_STRINGS:\r\nmask |= POLLOUT;\r\nbreak;\r\ncase FFS_ACTIVE:\r\nswitch (ffs->setup_state) {\r\ncase FFS_NO_SETUP:\r\nif (ffs->ev.count)\r\nmask |= POLLIN;\r\nbreak;\r\ncase FFS_SETUP_PENDING:\r\ncase FFS_SETUP_CANCELLED:\r\nmask |= (POLLIN | POLLOUT);\r\nbreak;\r\n}\r\ncase FFS_CLOSING:\r\nbreak;\r\n}\r\nmutex_unlock(&ffs->mutex);\r\nreturn mask;\r\n}\r\nstatic void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)\r\n{\r\nENTER();\r\nif (likely(req->context)) {\r\nstruct ffs_ep *ep = _ep->driver_data;\r\nep->status = req->status ? req->status : req->actual;\r\ncomplete(req->context);\r\n}\r\n}\r\nstatic void ffs_user_copy_worker(struct work_struct *work)\r\n{\r\nstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\r\nwork);\r\nint ret = io_data->req->status ? io_data->req->status :\r\nio_data->req->actual;\r\nif (io_data->read && ret > 0) {\r\nint i;\r\nsize_t pos = 0;\r\nret = min_t(int, ret, io_data->len);\r\nuse_mm(io_data->mm);\r\nfor (i = 0; i < io_data->nr_segs; i++) {\r\nsize_t len = min_t(size_t, ret - pos,\r\nio_data->iovec[i].iov_len);\r\nif (!len)\r\nbreak;\r\nif (unlikely(copy_to_user(io_data->iovec[i].iov_base,\r\n&io_data->buf[pos], len))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\npos += len;\r\n}\r\nunuse_mm(io_data->mm);\r\n}\r\naio_complete(io_data->kiocb, ret, ret);\r\nusb_ep_free_request(io_data->ep, io_data->req);\r\nio_data->kiocb->private = NULL;\r\nif (io_data->read)\r\nkfree(io_data->iovec);\r\nkfree(io_data->buf);\r\nkfree(io_data);\r\n}\r\nstatic void ffs_epfile_async_io_complete(struct usb_ep *_ep,\r\nstruct usb_request *req)\r\n{\r\nstruct ffs_io_data *io_data = req->context;\r\nENTER();\r\nINIT_WORK(&io_data->work, ffs_user_copy_worker);\r\nschedule_work(&io_data->work);\r\n}\r\nstatic ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)\r\n{\r\nstruct ffs_epfile *epfile = file->private_data;\r\nstruct ffs_ep *ep;\r\nchar *data = NULL;\r\nssize_t ret, data_len = -EINVAL;\r\nint halt;\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE)) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nep = epfile->ep;\r\nif (!ep) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nret = wait_event_interruptible(epfile->wait, (ep = epfile->ep));\r\nif (ret) {\r\nret = -EINTR;\r\ngoto error;\r\n}\r\n}\r\nhalt = (!io_data->read == !epfile->in);\r\nif (halt && epfile->isoc) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (!halt) {\r\nstruct usb_gadget *gadget = epfile->ffs->gadget;\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\nif (epfile->ep != ep) {\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nreturn -ESHUTDOWN;\r\n}\r\ndata_len = io_data->read ?\r\nusb_ep_align_maybe(gadget, ep->ep, io_data->len) :\r\nio_data->len;\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\ndata = kmalloc(data_len, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn -ENOMEM;\r\nif (io_data->aio && !io_data->read) {\r\nint i;\r\nsize_t pos = 0;\r\nfor (i = 0; i < io_data->nr_segs; i++) {\r\nif (unlikely(copy_from_user(&data[pos],\r\nio_data->iovec[i].iov_base,\r\nio_data->iovec[i].iov_len))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\npos += io_data->iovec[i].iov_len;\r\n}\r\n} else {\r\nif (!io_data->read &&\r\nunlikely(__copy_from_user(data, io_data->buf,\r\nio_data->len))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\n}\r\nret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret))\r\ngoto error;\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\nif (epfile->ep != ep) {\r\nret = -ESHUTDOWN;\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\n} else if (halt) {\r\nif (likely(epfile->ep == ep) && !WARN_ON(!ep->ep))\r\nusb_ep_set_halt(ep->ep);\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nret = -EBADMSG;\r\n} else {\r\nstruct usb_request *req;\r\nif (unlikely(data_len == -EINVAL)) {\r\nWARN(1, "%s: data_len == -EINVAL\n", __func__);\r\nret = -EINVAL;\r\ngoto error_lock;\r\n}\r\nif (io_data->aio) {\r\nreq = usb_ep_alloc_request(ep->ep, GFP_KERNEL);\r\nif (unlikely(!req))\r\ngoto error_lock;\r\nreq->buf = data;\r\nreq->length = data_len;\r\nio_data->buf = data;\r\nio_data->ep = ep->ep;\r\nio_data->req = req;\r\nreq->context = io_data;\r\nreq->complete = ffs_epfile_async_io_complete;\r\nret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\r\nif (unlikely(ret)) {\r\nusb_ep_free_request(ep->ep, req);\r\ngoto error_lock;\r\n}\r\nret = -EIOCBQUEUED;\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\n} else {\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nreq = ep->req;\r\nreq->buf = data;\r\nreq->length = data_len;\r\nreq->context = &done;\r\nreq->complete = ffs_epfile_io_complete;\r\nret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nif (unlikely(ret < 0)) {\r\n} else if (unlikely(\r\nwait_for_completion_interruptible(&done))) {\r\nret = -EINTR;\r\nusb_ep_dequeue(ep->ep, req);\r\n} else {\r\nret = ep->status;\r\nif (io_data->read && ret > 0) {\r\nret = min_t(size_t, ret, io_data->len);\r\nif (unlikely(copy_to_user(io_data->buf,\r\ndata, ret)))\r\nret = -EFAULT;\r\n}\r\n}\r\nkfree(data);\r\n}\r\n}\r\nmutex_unlock(&epfile->mutex);\r\nreturn ret;\r\nerror_lock:\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nmutex_unlock(&epfile->mutex);\r\nerror:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nffs_epfile_write(struct file *file, const char __user *buf, size_t len,\r\nloff_t *ptr)\r\n{\r\nstruct ffs_io_data io_data;\r\nENTER();\r\nio_data.aio = false;\r\nio_data.read = false;\r\nio_data.buf = (char * __user)buf;\r\nio_data.len = len;\r\nreturn ffs_epfile_io(file, &io_data);\r\n}\r\nstatic ssize_t\r\nffs_epfile_read(struct file *file, char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nstruct ffs_io_data io_data;\r\nENTER();\r\nio_data.aio = false;\r\nio_data.read = true;\r\nio_data.buf = buf;\r\nio_data.len = len;\r\nreturn ffs_epfile_io(file, &io_data);\r\n}\r\nstatic int\r\nffs_epfile_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_epfile *epfile = inode->i_private;\r\nENTER();\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\r\nreturn -ENODEV;\r\nfile->private_data = epfile;\r\nffs_data_opened(epfile->ffs);\r\nreturn 0;\r\n}\r\nstatic int ffs_aio_cancel(struct kiocb *kiocb)\r\n{\r\nstruct ffs_io_data *io_data = kiocb->private;\r\nstruct ffs_epfile *epfile = kiocb->ki_filp->private_data;\r\nint value;\r\nENTER();\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\nif (likely(io_data && io_data->ep && io_data->req))\r\nvalue = usb_ep_dequeue(io_data->ep, io_data->req);\r\nelse\r\nvalue = -EINVAL;\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nreturn value;\r\n}\r\nstatic ssize_t ffs_epfile_aio_write(struct kiocb *kiocb,\r\nconst struct iovec *iovec,\r\nunsigned long nr_segs, loff_t loff)\r\n{\r\nstruct ffs_io_data *io_data;\r\nENTER();\r\nio_data = kmalloc(sizeof(*io_data), GFP_KERNEL);\r\nif (unlikely(!io_data))\r\nreturn -ENOMEM;\r\nio_data->aio = true;\r\nio_data->read = false;\r\nio_data->kiocb = kiocb;\r\nio_data->iovec = iovec;\r\nio_data->nr_segs = nr_segs;\r\nio_data->len = kiocb->ki_nbytes;\r\nio_data->mm = current->mm;\r\nkiocb->private = io_data;\r\nkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\r\nreturn ffs_epfile_io(kiocb->ki_filp, io_data);\r\n}\r\nstatic ssize_t ffs_epfile_aio_read(struct kiocb *kiocb,\r\nconst struct iovec *iovec,\r\nunsigned long nr_segs, loff_t loff)\r\n{\r\nstruct ffs_io_data *io_data;\r\nstruct iovec *iovec_copy;\r\nENTER();\r\niovec_copy = kmalloc_array(nr_segs, sizeof(*iovec_copy), GFP_KERNEL);\r\nif (unlikely(!iovec_copy))\r\nreturn -ENOMEM;\r\nmemcpy(iovec_copy, iovec, sizeof(struct iovec)*nr_segs);\r\nio_data = kmalloc(sizeof(*io_data), GFP_KERNEL);\r\nif (unlikely(!io_data)) {\r\nkfree(iovec_copy);\r\nreturn -ENOMEM;\r\n}\r\nio_data->aio = true;\r\nio_data->read = true;\r\nio_data->kiocb = kiocb;\r\nio_data->iovec = iovec_copy;\r\nio_data->nr_segs = nr_segs;\r\nio_data->len = kiocb->ki_nbytes;\r\nio_data->mm = current->mm;\r\nkiocb->private = io_data;\r\nkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\r\nreturn ffs_epfile_io(kiocb->ki_filp, io_data);\r\n}\r\nstatic int\r\nffs_epfile_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_epfile *epfile = inode->i_private;\r\nENTER();\r\nffs_data_closed(epfile->ffs);\r\nreturn 0;\r\n}\r\nstatic long ffs_epfile_ioctl(struct file *file, unsigned code,\r\nunsigned long value)\r\n{\r\nstruct ffs_epfile *epfile = file->private_data;\r\nint ret;\r\nENTER();\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\r\nreturn -ENODEV;\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\nif (likely(epfile->ep)) {\r\nswitch (code) {\r\ncase FUNCTIONFS_FIFO_STATUS:\r\nret = usb_ep_fifo_status(epfile->ep->ep);\r\nbreak;\r\ncase FUNCTIONFS_FIFO_FLUSH:\r\nusb_ep_fifo_flush(epfile->ep->ep);\r\nret = 0;\r\nbreak;\r\ncase FUNCTIONFS_CLEAR_HALT:\r\nret = usb_ep_clear_halt(epfile->ep->ep);\r\nbreak;\r\ncase FUNCTIONFS_ENDPOINT_REVMAP:\r\nret = epfile->ep->num;\r\nbreak;\r\ncase FUNCTIONFS_ENDPOINT_DESC:\r\n{\r\nint desc_idx;\r\nstruct usb_endpoint_descriptor *desc;\r\nswitch (epfile->ffs->gadget->speed) {\r\ncase USB_SPEED_SUPER:\r\ndesc_idx = 2;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ndesc_idx = 1;\r\nbreak;\r\ndefault:\r\ndesc_idx = 0;\r\n}\r\ndesc = epfile->ep->descs[desc_idx];\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nret = copy_to_user((void *)value, desc, sizeof(*desc));\r\nif (ret)\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\n} else {\r\nret = -ENODEV;\r\n}\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nreturn ret;\r\n}\r\nstatic struct inode *__must_check\r\nffs_sb_make_inode(struct super_block *sb, void *data,\r\nconst struct file_operations *fops,\r\nconst struct inode_operations *iops,\r\nstruct ffs_file_perms *perms)\r\n{\r\nstruct inode *inode;\r\nENTER();\r\ninode = new_inode(sb);\r\nif (likely(inode)) {\r\nstruct timespec current_time = CURRENT_TIME;\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = perms->mode;\r\ninode->i_uid = perms->uid;\r\ninode->i_gid = perms->gid;\r\ninode->i_atime = current_time;\r\ninode->i_mtime = current_time;\r\ninode->i_ctime = current_time;\r\ninode->i_private = data;\r\nif (fops)\r\ninode->i_fop = fops;\r\nif (iops)\r\ninode->i_op = iops;\r\n}\r\nreturn inode;\r\n}\r\nstatic struct dentry *ffs_sb_create_file(struct super_block *sb,\r\nconst char *name, void *data,\r\nconst struct file_operations *fops)\r\n{\r\nstruct ffs_data *ffs = sb->s_fs_info;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nENTER();\r\ndentry = d_alloc_name(sb->s_root, name);\r\nif (unlikely(!dentry))\r\nreturn NULL;\r\ninode = ffs_sb_make_inode(sb, data, fops, NULL, &ffs->file_perms);\r\nif (unlikely(!inode)) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\nd_add(dentry, inode);\r\nreturn dentry;\r\n}\r\nstatic int ffs_sb_fill(struct super_block *sb, void *_data, int silent)\r\n{\r\nstruct ffs_sb_fill_data *data = _data;\r\nstruct inode *inode;\r\nstruct ffs_data *ffs = data->ffs_data;\r\nENTER();\r\nffs->sb = sb;\r\ndata->ffs_data = NULL;\r\nsb->s_fs_info = ffs;\r\nsb->s_blocksize = PAGE_CACHE_SIZE;\r\nsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\r\nsb->s_magic = FUNCTIONFS_MAGIC;\r\nsb->s_op = &ffs_sb_operations;\r\nsb->s_time_gran = 1;\r\ndata->perms.mode = data->root_mode;\r\ninode = ffs_sb_make_inode(sb, NULL,\r\n&simple_dir_operations,\r\n&simple_dir_inode_operations,\r\n&data->perms);\r\nsb->s_root = d_make_root(inode);\r\nif (unlikely(!sb->s_root))\r\nreturn -ENOMEM;\r\nif (unlikely(!ffs_sb_create_file(sb, "ep0", ffs,\r\n&ffs_ep0_operations)))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)\r\n{\r\nENTER();\r\nif (!opts || !*opts)\r\nreturn 0;\r\nfor (;;) {\r\nunsigned long value;\r\nchar *eq, *comma;\r\ncomma = strchr(opts, ',');\r\nif (comma)\r\n*comma = 0;\r\neq = strchr(opts, '=');\r\nif (unlikely(!eq)) {\r\npr_err("'=' missing in %s\n", opts);\r\nreturn -EINVAL;\r\n}\r\n*eq = 0;\r\nif (kstrtoul(eq + 1, 0, &value)) {\r\npr_err("%s: invalid value: %s\n", opts, eq + 1);\r\nreturn -EINVAL;\r\n}\r\nswitch (eq - opts) {\r\ncase 5:\r\nif (!memcmp(opts, "rmode", 5))\r\ndata->root_mode = (value & 0555) | S_IFDIR;\r\nelse if (!memcmp(opts, "fmode", 5))\r\ndata->perms.mode = (value & 0666) | S_IFREG;\r\nelse\r\ngoto invalid;\r\nbreak;\r\ncase 4:\r\nif (!memcmp(opts, "mode", 4)) {\r\ndata->root_mode = (value & 0555) | S_IFDIR;\r\ndata->perms.mode = (value & 0666) | S_IFREG;\r\n} else {\r\ngoto invalid;\r\n}\r\nbreak;\r\ncase 3:\r\nif (!memcmp(opts, "uid", 3)) {\r\ndata->perms.uid = make_kuid(current_user_ns(), value);\r\nif (!uid_valid(data->perms.uid)) {\r\npr_err("%s: unmapped value: %lu\n", opts, value);\r\nreturn -EINVAL;\r\n}\r\n} else if (!memcmp(opts, "gid", 3)) {\r\ndata->perms.gid = make_kgid(current_user_ns(), value);\r\nif (!gid_valid(data->perms.gid)) {\r\npr_err("%s: unmapped value: %lu\n", opts, value);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ngoto invalid;\r\n}\r\nbreak;\r\ndefault:\r\ninvalid:\r\npr_err("%s: invalid option\n", opts);\r\nreturn -EINVAL;\r\n}\r\nif (!comma)\r\nbreak;\r\nopts = comma + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dentry *\r\nffs_fs_mount(struct file_system_type *t, int flags,\r\nconst char *dev_name, void *opts)\r\n{\r\nstruct ffs_sb_fill_data data = {\r\n.perms = {\r\n.mode = S_IFREG | 0600,\r\n.uid = GLOBAL_ROOT_UID,\r\n.gid = GLOBAL_ROOT_GID,\r\n},\r\n.root_mode = S_IFDIR | 0500,\r\n};\r\nstruct dentry *rv;\r\nint ret;\r\nvoid *ffs_dev;\r\nstruct ffs_data *ffs;\r\nENTER();\r\nret = ffs_fs_parse_opts(&data, opts);\r\nif (unlikely(ret < 0))\r\nreturn ERR_PTR(ret);\r\nffs = ffs_data_new();\r\nif (unlikely(!ffs))\r\nreturn ERR_PTR(-ENOMEM);\r\nffs->file_perms = data.perms;\r\nffs->dev_name = kstrdup(dev_name, GFP_KERNEL);\r\nif (unlikely(!ffs->dev_name)) {\r\nffs_data_put(ffs);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nffs_dev = ffs_acquire_dev(dev_name);\r\nif (IS_ERR(ffs_dev)) {\r\nffs_data_put(ffs);\r\nreturn ERR_CAST(ffs_dev);\r\n}\r\nffs->private_data = ffs_dev;\r\ndata.ffs_data = ffs;\r\nrv = mount_nodev(t, flags, &data, ffs_sb_fill);\r\nif (IS_ERR(rv) && data.ffs_data) {\r\nffs_release_dev(data.ffs_data);\r\nffs_data_put(data.ffs_data);\r\n}\r\nreturn rv;\r\n}\r\nstatic void\r\nffs_fs_kill_sb(struct super_block *sb)\r\n{\r\nENTER();\r\nkill_litter_super(sb);\r\nif (sb->s_fs_info) {\r\nffs_release_dev(sb->s_fs_info);\r\nffs_data_put(sb->s_fs_info);\r\n}\r\n}\r\nstatic int functionfs_init(void)\r\n{\r\nint ret;\r\nENTER();\r\nret = register_filesystem(&ffs_fs_type);\r\nif (likely(!ret))\r\npr_info("file system registered\n");\r\nelse\r\npr_err("failed registering file system (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void functionfs_cleanup(void)\r\n{\r\nENTER();\r\npr_info("unloading\n");\r\nunregister_filesystem(&ffs_fs_type);\r\n}\r\nstatic void ffs_data_get(struct ffs_data *ffs)\r\n{\r\nENTER();\r\natomic_inc(&ffs->ref);\r\n}\r\nstatic void ffs_data_opened(struct ffs_data *ffs)\r\n{\r\nENTER();\r\natomic_inc(&ffs->ref);\r\natomic_inc(&ffs->opened);\r\n}\r\nstatic void ffs_data_put(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (unlikely(atomic_dec_and_test(&ffs->ref))) {\r\npr_info("%s(): freeing\n", __func__);\r\nffs_data_clear(ffs);\r\nBUG_ON(waitqueue_active(&ffs->ev.waitq) ||\r\nwaitqueue_active(&ffs->ep0req_completion.wait));\r\nkfree(ffs->dev_name);\r\nkfree(ffs);\r\n}\r\n}\r\nstatic void ffs_data_closed(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (atomic_dec_and_test(&ffs->opened)) {\r\nffs->state = FFS_CLOSING;\r\nffs_data_reset(ffs);\r\n}\r\nffs_data_put(ffs);\r\n}\r\nstatic struct ffs_data *ffs_data_new(void)\r\n{\r\nstruct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);\r\nif (unlikely(!ffs))\r\nreturn NULL;\r\nENTER();\r\natomic_set(&ffs->ref, 1);\r\natomic_set(&ffs->opened, 0);\r\nffs->state = FFS_READ_DESCRIPTORS;\r\nmutex_init(&ffs->mutex);\r\nspin_lock_init(&ffs->eps_lock);\r\ninit_waitqueue_head(&ffs->ev.waitq);\r\ninit_completion(&ffs->ep0req_completion);\r\nffs->ev.can_stall = 1;\r\nreturn ffs;\r\n}\r\nstatic void ffs_data_clear(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags))\r\nffs_closed(ffs);\r\nBUG_ON(ffs->gadget);\r\nif (ffs->epfiles)\r\nffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);\r\nkfree(ffs->raw_descs_data);\r\nkfree(ffs->raw_strings);\r\nkfree(ffs->stringtabs);\r\n}\r\nstatic void ffs_data_reset(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nffs_data_clear(ffs);\r\nffs->epfiles = NULL;\r\nffs->raw_descs_data = NULL;\r\nffs->raw_descs = NULL;\r\nffs->raw_strings = NULL;\r\nffs->stringtabs = NULL;\r\nffs->raw_descs_length = 0;\r\nffs->fs_descs_count = 0;\r\nffs->hs_descs_count = 0;\r\nffs->ss_descs_count = 0;\r\nffs->strings_count = 0;\r\nffs->interfaces_count = 0;\r\nffs->eps_count = 0;\r\nffs->ev.count = 0;\r\nffs->state = FFS_READ_DESCRIPTORS;\r\nffs->setup_state = FFS_NO_SETUP;\r\nffs->flags = 0;\r\n}\r\nstatic int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget_strings **lang;\r\nint first_id;\r\nENTER();\r\nif (WARN_ON(ffs->state != FFS_ACTIVE\r\n|| test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))\r\nreturn -EBADFD;\r\nfirst_id = usb_string_ids_n(cdev, ffs->strings_count);\r\nif (unlikely(first_id < 0))\r\nreturn first_id;\r\nffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\r\nif (unlikely(!ffs->ep0req))\r\nreturn -ENOMEM;\r\nffs->ep0req->complete = ffs_ep0_complete;\r\nffs->ep0req->context = ffs;\r\nlang = ffs->stringtabs;\r\nif (lang) {\r\nfor (; *lang; ++lang) {\r\nstruct usb_string *str = (*lang)->strings;\r\nint id = first_id;\r\nfor (; str->s; ++id, ++str)\r\nstr->id = id;\r\n}\r\n}\r\nffs->gadget = cdev->gadget;\r\nffs_data_get(ffs);\r\nreturn 0;\r\n}\r\nstatic void functionfs_unbind(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (!WARN_ON(!ffs->gadget)) {\r\nusb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);\r\nffs->ep0req = NULL;\r\nffs->gadget = NULL;\r\nclear_bit(FFS_FL_BOUND, &ffs->flags);\r\nffs_data_put(ffs);\r\n}\r\n}\r\nstatic int ffs_epfiles_create(struct ffs_data *ffs)\r\n{\r\nstruct ffs_epfile *epfile, *epfiles;\r\nunsigned i, count;\r\nENTER();\r\ncount = ffs->eps_count;\r\nepfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);\r\nif (!epfiles)\r\nreturn -ENOMEM;\r\nepfile = epfiles;\r\nfor (i = 1; i <= count; ++i, ++epfile) {\r\nepfile->ffs = ffs;\r\nmutex_init(&epfile->mutex);\r\ninit_waitqueue_head(&epfile->wait);\r\nif (ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\r\nsprintf(epfiles->name, "ep%02x", ffs->eps_addrmap[i]);\r\nelse\r\nsprintf(epfiles->name, "ep%u", i);\r\nepfile->dentry = ffs_sb_create_file(ffs->sb, epfiles->name,\r\nepfile,\r\n&ffs_epfile_operations);\r\nif (unlikely(!epfile->dentry)) {\r\nffs_epfiles_destroy(epfiles, i - 1);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nffs->epfiles = epfiles;\r\nreturn 0;\r\n}\r\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\r\n{\r\nstruct ffs_epfile *epfile = epfiles;\r\nENTER();\r\nfor (; count; --count, ++epfile) {\r\nBUG_ON(mutex_is_locked(&epfile->mutex) ||\r\nwaitqueue_active(&epfile->wait));\r\nif (epfile->dentry) {\r\nd_delete(epfile->dentry);\r\ndput(epfile->dentry);\r\nepfile->dentry = NULL;\r\n}\r\n}\r\nkfree(epfiles);\r\n}\r\nstatic void ffs_func_eps_disable(struct ffs_function *func)\r\n{\r\nstruct ffs_ep *ep = func->eps;\r\nstruct ffs_epfile *epfile = func->ffs->epfiles;\r\nunsigned count = func->ffs->eps_count;\r\nunsigned long flags;\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nif (likely(ep->ep))\r\nusb_ep_disable(ep->ep);\r\nepfile->ep = NULL;\r\n++ep;\r\n++epfile;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\n}\r\nstatic int ffs_func_eps_enable(struct ffs_function *func)\r\n{\r\nstruct ffs_data *ffs = func->ffs;\r\nstruct ffs_ep *ep = func->eps;\r\nstruct ffs_epfile *epfile = ffs->epfiles;\r\nunsigned count = ffs->eps_count;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nstruct usb_endpoint_descriptor *ds;\r\nint desc_idx;\r\nif (ffs->gadget->speed == USB_SPEED_SUPER)\r\ndesc_idx = 2;\r\nelse if (ffs->gadget->speed == USB_SPEED_HIGH)\r\ndesc_idx = 1;\r\nelse\r\ndesc_idx = 0;\r\ndo {\r\nds = ep->descs[desc_idx];\r\n} while (!ds && --desc_idx >= 0);\r\nif (!ds) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nep->ep->driver_data = ep;\r\nep->ep->desc = ds;\r\nret = usb_ep_enable(ep->ep);\r\nif (likely(!ret)) {\r\nepfile->ep = ep;\r\nepfile->in = usb_endpoint_dir_in(ds);\r\nepfile->isoc = usb_endpoint_xfer_isoc(ds);\r\n} else {\r\nbreak;\r\n}\r\nwake_up(&epfile->wait);\r\n++ep;\r\n++epfile;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __must_check ffs_do_single_desc(char *data, unsigned len,\r\nffs_entity_callback entity,\r\nvoid *priv)\r\n{\r\nstruct usb_descriptor_header *_ds = (void *)data;\r\nu8 length;\r\nint ret;\r\nENTER();\r\nif (len < 2) {\r\npr_vdebug("descriptor too short\n");\r\nreturn -EINVAL;\r\n}\r\nlength = _ds->bLength;\r\nif (len < length) {\r\npr_vdebug("descriptor longer then available data\n");\r\nreturn -EINVAL;\r\n}\r\n#define __entity_check_INTERFACE(val) 1\r\n#define __entity_check_STRING(val) (val)\r\n#define __entity_check_ENDPOINT(val) ((val) & USB_ENDPOINT_NUMBER_MASK)\r\n#define __entity(type, val) do { \\r\npr_vdebug("entity " #type "(%02x)\n", (val)); \\r\nif (unlikely(!__entity_check_ ##type(val))) { \\r\npr_vdebug("invalid entity's value\n"); \\r\nreturn -EINVAL; \\r\n} \\r\nret = entity(FFS_ ##type, &val, _ds, priv); \\r\nif (unlikely(ret < 0)) { \\r\npr_debug("entity " #type "(%02x); ret = %d\n", \\r\n(val), ret); \\r\nreturn ret; \\r\n} \\r\n} while (0)\r\nswitch (_ds->bDescriptorType) {\r\ncase USB_DT_DEVICE:\r\ncase USB_DT_CONFIG:\r\ncase USB_DT_STRING:\r\ncase USB_DT_DEVICE_QUALIFIER:\r\npr_vdebug("descriptor reserved for gadget: %d\n",\r\n_ds->bDescriptorType);\r\nreturn -EINVAL;\r\ncase USB_DT_INTERFACE: {\r\nstruct usb_interface_descriptor *ds = (void *)_ds;\r\npr_vdebug("interface descriptor\n");\r\nif (length != sizeof *ds)\r\ngoto inv_length;\r\n__entity(INTERFACE, ds->bInterfaceNumber);\r\nif (ds->iInterface)\r\n__entity(STRING, ds->iInterface);\r\n}\r\nbreak;\r\ncase USB_DT_ENDPOINT: {\r\nstruct usb_endpoint_descriptor *ds = (void *)_ds;\r\npr_vdebug("endpoint descriptor\n");\r\nif (length != USB_DT_ENDPOINT_SIZE &&\r\nlength != USB_DT_ENDPOINT_AUDIO_SIZE)\r\ngoto inv_length;\r\n__entity(ENDPOINT, ds->bEndpointAddress);\r\n}\r\nbreak;\r\ncase HID_DT_HID:\r\npr_vdebug("hid descriptor\n");\r\nif (length != sizeof(struct hid_descriptor))\r\ngoto inv_length;\r\nbreak;\r\ncase USB_DT_OTG:\r\nif (length != sizeof(struct usb_otg_descriptor))\r\ngoto inv_length;\r\nbreak;\r\ncase USB_DT_INTERFACE_ASSOCIATION: {\r\nstruct usb_interface_assoc_descriptor *ds = (void *)_ds;\r\npr_vdebug("interface association descriptor\n");\r\nif (length != sizeof *ds)\r\ngoto inv_length;\r\nif (ds->iFunction)\r\n__entity(STRING, ds->iFunction);\r\n}\r\nbreak;\r\ncase USB_DT_SS_ENDPOINT_COMP:\r\npr_vdebug("EP SS companion descriptor\n");\r\nif (length != sizeof(struct usb_ss_ep_comp_descriptor))\r\ngoto inv_length;\r\nbreak;\r\ncase USB_DT_OTHER_SPEED_CONFIG:\r\ncase USB_DT_INTERFACE_POWER:\r\ncase USB_DT_DEBUG:\r\ncase USB_DT_SECURITY:\r\ncase USB_DT_CS_RADIO_CONTROL:\r\npr_vdebug("unimplemented descriptor: %d\n", _ds->bDescriptorType);\r\nreturn -EINVAL;\r\ndefault:\r\npr_vdebug("unknown descriptor: %d\n", _ds->bDescriptorType);\r\nreturn -EINVAL;\r\ninv_length:\r\npr_vdebug("invalid length: %d (descriptor %d)\n",\r\n_ds->bLength, _ds->bDescriptorType);\r\nreturn -EINVAL;\r\n}\r\n#undef __entity\r\n#undef __entity_check_DESCRIPTOR\r\n#undef __entity_check_INTERFACE\r\n#undef __entity_check_STRING\r\n#undef __entity_check_ENDPOINT\r\nreturn length;\r\n}\r\nstatic int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,\r\nffs_entity_callback entity, void *priv)\r\n{\r\nconst unsigned _len = len;\r\nunsigned long num = 0;\r\nENTER();\r\nfor (;;) {\r\nint ret;\r\nif (num == count)\r\ndata = NULL;\r\nret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);\r\nif (unlikely(ret < 0)) {\r\npr_debug("entity DESCRIPTOR(%02lx); ret = %d\n",\r\nnum, ret);\r\nreturn ret;\r\n}\r\nif (!data)\r\nreturn _len - len;\r\nret = ffs_do_single_desc(data, len, entity, priv);\r\nif (unlikely(ret < 0)) {\r\npr_debug("%s returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nlen -= ret;\r\ndata += ret;\r\n++num;\r\n}\r\n}\r\nstatic int __ffs_data_do_entity(enum ffs_entity_type type,\r\nu8 *valuep, struct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct ffs_desc_helper *helper = priv;\r\nstruct usb_endpoint_descriptor *d;\r\nENTER();\r\nswitch (type) {\r\ncase FFS_DESCRIPTOR:\r\nbreak;\r\ncase FFS_INTERFACE:\r\nif (*valuep >= helper->interfaces_count)\r\nhelper->interfaces_count = *valuep + 1;\r\nbreak;\r\ncase FFS_STRING:\r\nif (*valuep > helper->ffs->strings_count)\r\nhelper->ffs->strings_count = *valuep;\r\nbreak;\r\ncase FFS_ENDPOINT:\r\nd = (void *)desc;\r\nhelper->eps_count++;\r\nif (helper->eps_count >= 15)\r\nreturn -EINVAL;\r\nif (!helper->ffs->eps_count && !helper->ffs->interfaces_count)\r\nhelper->ffs->eps_addrmap[helper->eps_count] =\r\nd->bEndpointAddress;\r\nelse if (helper->ffs->eps_addrmap[helper->eps_count] !=\r\nd->bEndpointAddress)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __ffs_do_os_desc_header(enum ffs_os_desc_type *next_type,\r\nstruct usb_os_desc_header *desc)\r\n{\r\nu16 bcd_version = le16_to_cpu(desc->bcdVersion);\r\nu16 w_index = le16_to_cpu(desc->wIndex);\r\nif (bcd_version != 1) {\r\npr_vdebug("unsupported os descriptors version: %d",\r\nbcd_version);\r\nreturn -EINVAL;\r\n}\r\nswitch (w_index) {\r\ncase 0x4:\r\n*next_type = FFS_OS_DESC_EXT_COMPAT;\r\nbreak;\r\ncase 0x5:\r\n*next_type = FFS_OS_DESC_EXT_PROP;\r\nbreak;\r\ndefault:\r\npr_vdebug("unsupported os descriptor type: %d", w_index);\r\nreturn -EINVAL;\r\n}\r\nreturn sizeof(*desc);\r\n}\r\nstatic int __must_check ffs_do_single_os_desc(char *data, unsigned len,\r\nenum ffs_os_desc_type type,\r\nu16 feature_count,\r\nffs_os_desc_callback entity,\r\nvoid *priv,\r\nstruct usb_os_desc_header *h)\r\n{\r\nint ret;\r\nconst unsigned _len = len;\r\nENTER();\r\nwhile (feature_count--) {\r\nret = entity(type, h, data, len, priv);\r\nif (unlikely(ret < 0)) {\r\npr_debug("bad OS descriptor, type: %d\n", type);\r\nreturn ret;\r\n}\r\ndata += ret;\r\nlen -= ret;\r\n}\r\nreturn _len - len;\r\n}\r\nstatic int __must_check ffs_do_os_descs(unsigned count,\r\nchar *data, unsigned len,\r\nffs_os_desc_callback entity, void *priv)\r\n{\r\nconst unsigned _len = len;\r\nunsigned long num = 0;\r\nENTER();\r\nfor (num = 0; num < count; ++num) {\r\nint ret;\r\nenum ffs_os_desc_type type;\r\nu16 feature_count;\r\nstruct usb_os_desc_header *desc = (void *)data;\r\nif (len < sizeof(*desc))\r\nreturn -EINVAL;\r\nif (le32_to_cpu(desc->dwLength) > len)\r\nreturn -EINVAL;\r\nret = __ffs_do_os_desc_header(&type, desc);\r\nif (unlikely(ret < 0)) {\r\npr_debug("entity OS_DESCRIPTOR(%02lx); ret = %d\n",\r\nnum, ret);\r\nreturn ret;\r\n}\r\nfeature_count = le16_to_cpu(desc->wCount);\r\nif (type == FFS_OS_DESC_EXT_COMPAT &&\r\n(feature_count > 255 || desc->Reserved))\r\nreturn -EINVAL;\r\nlen -= ret;\r\ndata += ret;\r\nret = ffs_do_single_os_desc(data, len, type,\r\nfeature_count, entity, priv, desc);\r\nif (unlikely(ret < 0)) {\r\npr_debug("%s returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nlen -= ret;\r\ndata += ret;\r\n}\r\nreturn _len - len;\r\n}\r\nstatic int __ffs_data_do_os_desc(enum ffs_os_desc_type type,\r\nstruct usb_os_desc_header *h, void *data,\r\nunsigned len, void *priv)\r\n{\r\nstruct ffs_data *ffs = priv;\r\nu8 length;\r\nENTER();\r\nswitch (type) {\r\ncase FFS_OS_DESC_EXT_COMPAT: {\r\nstruct usb_ext_compat_desc *d = data;\r\nint i;\r\nif (len < sizeof(*d) ||\r\nd->bFirstInterfaceNumber >= ffs->interfaces_count ||\r\nd->Reserved1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(d->Reserved2); ++i)\r\nif (d->Reserved2[i])\r\nreturn -EINVAL;\r\nlength = sizeof(struct usb_ext_compat_desc);\r\n}\r\nbreak;\r\ncase FFS_OS_DESC_EXT_PROP: {\r\nstruct usb_ext_prop_desc *d = data;\r\nu32 type, pdl;\r\nu16 pnl;\r\nif (len < sizeof(*d) || h->interface >= ffs->interfaces_count)\r\nreturn -EINVAL;\r\nlength = le32_to_cpu(d->dwSize);\r\ntype = le32_to_cpu(d->dwPropertyDataType);\r\nif (type < USB_EXT_PROP_UNICODE ||\r\ntype > USB_EXT_PROP_UNICODE_MULTI) {\r\npr_vdebug("unsupported os descriptor property type: %d",\r\ntype);\r\nreturn -EINVAL;\r\n}\r\npnl = le16_to_cpu(d->wPropertyNameLength);\r\npdl = le32_to_cpu(*(u32 *)((u8 *)data + 10 + pnl));\r\nif (length != 14 + pnl + pdl) {\r\npr_vdebug("invalid os descriptor length: %d pnl:%d pdl:%d (descriptor %d)\n",\r\nlength, pnl, pdl, type);\r\nreturn -EINVAL;\r\n}\r\n++ffs->ms_os_descs_ext_prop_count;\r\nffs->ms_os_descs_ext_prop_name_len += pnl * 2;\r\nffs->ms_os_descs_ext_prop_data_len += pdl;\r\n}\r\nbreak;\r\ndefault:\r\npr_vdebug("unknown descriptor: %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nreturn length;\r\n}\r\nstatic int __ffs_data_got_descs(struct ffs_data *ffs,\r\nchar *const _data, size_t len)\r\n{\r\nchar *data = _data, *raw_descs;\r\nunsigned os_descs_count = 0, counts[3], flags;\r\nint ret = -EINVAL, i;\r\nstruct ffs_desc_helper helper;\r\nENTER();\r\nif (get_unaligned_le32(data + 4) != len)\r\ngoto error;\r\nswitch (get_unaligned_le32(data)) {\r\ncase FUNCTIONFS_DESCRIPTORS_MAGIC:\r\nflags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;\r\ndata += 8;\r\nlen -= 8;\r\nbreak;\r\ncase FUNCTIONFS_DESCRIPTORS_MAGIC_V2:\r\nflags = get_unaligned_le32(data + 8);\r\nffs->user_flags = flags;\r\nif (flags & ~(FUNCTIONFS_HAS_FS_DESC |\r\nFUNCTIONFS_HAS_HS_DESC |\r\nFUNCTIONFS_HAS_SS_DESC |\r\nFUNCTIONFS_HAS_MS_OS_DESC |\r\nFUNCTIONFS_VIRTUAL_ADDR)) {\r\nret = -ENOSYS;\r\ngoto error;\r\n}\r\ndata += 12;\r\nlen -= 12;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nfor (i = 0; i < 3; ++i) {\r\nif (!(flags & (1 << i))) {\r\ncounts[i] = 0;\r\n} else if (len < 4) {\r\ngoto error;\r\n} else {\r\ncounts[i] = get_unaligned_le32(data);\r\ndata += 4;\r\nlen -= 4;\r\n}\r\n}\r\nif (flags & (1 << i)) {\r\nos_descs_count = get_unaligned_le32(data);\r\ndata += 4;\r\nlen -= 4;\r\n};\r\nraw_descs = data;\r\nhelper.ffs = ffs;\r\nfor (i = 0; i < 3; ++i) {\r\nif (!counts[i])\r\ncontinue;\r\nhelper.interfaces_count = 0;\r\nhelper.eps_count = 0;\r\nret = ffs_do_descs(counts[i], data, len,\r\n__ffs_data_do_entity, &helper);\r\nif (ret < 0)\r\ngoto error;\r\nif (!ffs->eps_count && !ffs->interfaces_count) {\r\nffs->eps_count = helper.eps_count;\r\nffs->interfaces_count = helper.interfaces_count;\r\n} else {\r\nif (ffs->eps_count != helper.eps_count) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (ffs->interfaces_count != helper.interfaces_count) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\ndata += ret;\r\nlen -= ret;\r\n}\r\nif (os_descs_count) {\r\nret = ffs_do_os_descs(os_descs_count, data, len,\r\n__ffs_data_do_os_desc, ffs);\r\nif (ret < 0)\r\ngoto error;\r\ndata += ret;\r\nlen -= ret;\r\n}\r\nif (raw_descs == data || len) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nffs->raw_descs_data = _data;\r\nffs->raw_descs = raw_descs;\r\nffs->raw_descs_length = data - raw_descs;\r\nffs->fs_descs_count = counts[0];\r\nffs->hs_descs_count = counts[1];\r\nffs->ss_descs_count = counts[2];\r\nffs->ms_os_descs_count = os_descs_count;\r\nreturn 0;\r\nerror:\r\nkfree(_data);\r\nreturn ret;\r\n}\r\nstatic int __ffs_data_got_strings(struct ffs_data *ffs,\r\nchar *const _data, size_t len)\r\n{\r\nu32 str_count, needed_count, lang_count;\r\nstruct usb_gadget_strings **stringtabs, *t;\r\nstruct usb_string *strings, *s;\r\nconst char *data = _data;\r\nENTER();\r\nif (unlikely(get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||\r\nget_unaligned_le32(data + 4) != len))\r\ngoto error;\r\nstr_count = get_unaligned_le32(data + 8);\r\nlang_count = get_unaligned_le32(data + 12);\r\nif (unlikely(!str_count != !lang_count))\r\ngoto error;\r\nneeded_count = ffs->strings_count;\r\nif (unlikely(str_count < needed_count))\r\ngoto error;\r\nif (!needed_count) {\r\nkfree(_data);\r\nreturn 0;\r\n}\r\n{\r\nunsigned i = 0;\r\nvla_group(d);\r\nvla_item(d, struct usb_gadget_strings *, stringtabs,\r\nlang_count + 1);\r\nvla_item(d, struct usb_gadget_strings, stringtab, lang_count);\r\nvla_item(d, struct usb_string, strings,\r\nlang_count*(needed_count+1));\r\nchar *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);\r\nif (unlikely(!vlabuf)) {\r\nkfree(_data);\r\nreturn -ENOMEM;\r\n}\r\nstringtabs = vla_ptr(vlabuf, d, stringtabs);\r\nt = vla_ptr(vlabuf, d, stringtab);\r\ni = lang_count;\r\ndo {\r\n*stringtabs++ = t++;\r\n} while (--i);\r\n*stringtabs = NULL;\r\nstringtabs = vla_ptr(vlabuf, d, stringtabs);\r\nt = vla_ptr(vlabuf, d, stringtab);\r\ns = vla_ptr(vlabuf, d, strings);\r\nstrings = s;\r\n}\r\ndata += 16;\r\nlen -= 16;\r\ndo {\r\nunsigned needed = needed_count;\r\nif (unlikely(len < 3))\r\ngoto error_free;\r\nt->language = get_unaligned_le16(data);\r\nt->strings = s;\r\n++t;\r\ndata += 2;\r\nlen -= 2;\r\ndo {\r\nsize_t length = strnlen(data, len);\r\nif (unlikely(length == len))\r\ngoto error_free;\r\nif (likely(needed)) {\r\ns->s = data;\r\n--needed;\r\n++s;\r\n}\r\ndata += length + 1;\r\nlen -= length + 1;\r\n} while (--str_count);\r\ns->id = 0;\r\ns->s = NULL;\r\n++s;\r\n} while (--lang_count);\r\nif (unlikely(len))\r\ngoto error_free;\r\nffs->stringtabs = stringtabs;\r\nffs->raw_strings = _data;\r\nreturn 0;\r\nerror_free:\r\nkfree(stringtabs);\r\nerror:\r\nkfree(_data);\r\nreturn -EINVAL;\r\n}\r\nstatic void __ffs_event_add(struct ffs_data *ffs,\r\nenum usb_functionfs_event_type type)\r\n{\r\nenum usb_functionfs_event_type rem_type1, rem_type2 = type;\r\nint neg = 0;\r\nif (ffs->setup_state == FFS_SETUP_PENDING)\r\nffs->setup_state = FFS_SETUP_CANCELLED;\r\nswitch (type) {\r\ncase FUNCTIONFS_RESUME:\r\nrem_type2 = FUNCTIONFS_SUSPEND;\r\ncase FUNCTIONFS_SUSPEND:\r\ncase FUNCTIONFS_SETUP:\r\nrem_type1 = type;\r\nbreak;\r\ncase FUNCTIONFS_BIND:\r\ncase FUNCTIONFS_UNBIND:\r\ncase FUNCTIONFS_DISABLE:\r\ncase FUNCTIONFS_ENABLE:\r\nrem_type1 = FUNCTIONFS_SUSPEND;\r\nrem_type2 = FUNCTIONFS_RESUME;\r\nneg = 1;\r\nbreak;\r\ndefault:\r\nWARN(1, "%d: unknown event, this should not happen\n", type);\r\nreturn;\r\n}\r\n{\r\nu8 *ev = ffs->ev.types, *out = ev;\r\nunsigned n = ffs->ev.count;\r\nfor (; n; --n, ++ev)\r\nif ((*ev == rem_type1 || *ev == rem_type2) == neg)\r\n*out++ = *ev;\r\nelse\r\npr_vdebug("purging event %d\n", *ev);\r\nffs->ev.count = out - ffs->ev.types;\r\n}\r\npr_vdebug("adding event %d\n", type);\r\nffs->ev.types[ffs->ev.count++] = type;\r\nwake_up_locked(&ffs->ev.waitq);\r\n}\r\nstatic void ffs_event_add(struct ffs_data *ffs,\r\nenum usb_functionfs_event_type type)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\r\n__ffs_event_add(ffs, type);\r\nspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\r\n}\r\nstatic int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)\r\n{\r\nint i;\r\nfor (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)\r\nif (ffs->eps_addrmap[i] == endpoint_address)\r\nreturn i;\r\nreturn -ENOENT;\r\n}\r\nstatic int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,\r\nstruct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct usb_endpoint_descriptor *ds = (void *)desc;\r\nstruct ffs_function *func = priv;\r\nstruct ffs_ep *ffs_ep;\r\nunsigned ep_desc_id;\r\nint idx;\r\nstatic const char *speed_names[] = { "full", "high", "super" };\r\nif (type != FFS_DESCRIPTOR)\r\nreturn 0;\r\nif (func->function.ss_descriptors) {\r\nep_desc_id = 2;\r\nfunc->function.ss_descriptors[(long)valuep] = desc;\r\n} else if (func->function.hs_descriptors) {\r\nep_desc_id = 1;\r\nfunc->function.hs_descriptors[(long)valuep] = desc;\r\n} else {\r\nep_desc_id = 0;\r\nfunc->function.fs_descriptors[(long)valuep] = desc;\r\n}\r\nif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn 0;\r\nidx = ffs_ep_addr2idx(func->ffs, ds->bEndpointAddress) - 1;\r\nif (idx < 0)\r\nreturn idx;\r\nffs_ep = func->eps + idx;\r\nif (unlikely(ffs_ep->descs[ep_desc_id])) {\r\npr_err("two %sspeed descriptors for EP %d\n",\r\nspeed_names[ep_desc_id],\r\nds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\nreturn -EINVAL;\r\n}\r\nffs_ep->descs[ep_desc_id] = ds;\r\nffs_dump_mem(": Original ep desc", ds, ds->bLength);\r\nif (ffs_ep->ep) {\r\nds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;\r\nif (!ds->wMaxPacketSize)\r\nds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;\r\n} else {\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\nu8 bEndpointAddress;\r\nbEndpointAddress = ds->bEndpointAddress;\r\npr_vdebug("autoconfig\n");\r\nep = usb_ep_autoconfig(func->gadget, ds);\r\nif (unlikely(!ep))\r\nreturn -ENOTSUPP;\r\nep->driver_data = func->eps + idx;\r\nreq = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (unlikely(!req))\r\nreturn -ENOMEM;\r\nffs_ep->ep = ep;\r\nffs_ep->req = req;\r\nfunc->eps_revmap[ds->bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK] = idx + 1;\r\nif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\r\nds->bEndpointAddress = bEndpointAddress;\r\n}\r\nffs_dump_mem(": Rewritten ep desc", ds, ds->bLength);\r\nreturn 0;\r\n}\r\nstatic int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,\r\nstruct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct ffs_function *func = priv;\r\nunsigned idx;\r\nu8 newValue;\r\nswitch (type) {\r\ndefault:\r\ncase FFS_DESCRIPTOR:\r\nreturn 0;\r\ncase FFS_INTERFACE:\r\nidx = *valuep;\r\nif (func->interfaces_nums[idx] < 0) {\r\nint id = usb_interface_id(func->conf, &func->function);\r\nif (unlikely(id < 0))\r\nreturn id;\r\nfunc->interfaces_nums[idx] = id;\r\n}\r\nnewValue = func->interfaces_nums[idx];\r\nbreak;\r\ncase FFS_STRING:\r\nnewValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;\r\nbreak;\r\ncase FFS_ENDPOINT:\r\nif (desc->bDescriptorType == USB_DT_ENDPOINT)\r\nreturn 0;\r\nidx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;\r\nif (unlikely(!func->eps[idx].ep))\r\nreturn -EINVAL;\r\n{\r\nstruct usb_endpoint_descriptor **descs;\r\ndescs = func->eps[idx].descs;\r\nnewValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;\r\n}\r\nbreak;\r\n}\r\npr_vdebug("%02x -> %02x\n", *valuep, newValue);\r\n*valuep = newValue;\r\nreturn 0;\r\n}\r\nstatic int __ffs_func_bind_do_os_desc(enum ffs_os_desc_type type,\r\nstruct usb_os_desc_header *h, void *data,\r\nunsigned len, void *priv)\r\n{\r\nstruct ffs_function *func = priv;\r\nu8 length = 0;\r\nswitch (type) {\r\ncase FFS_OS_DESC_EXT_COMPAT: {\r\nstruct usb_ext_compat_desc *desc = data;\r\nstruct usb_os_desc_table *t;\r\nt = &func->function.os_desc_table[desc->bFirstInterfaceNumber];\r\nt->if_id = func->interfaces_nums[desc->bFirstInterfaceNumber];\r\nmemcpy(t->os_desc->ext_compat_id, &desc->CompatibleID,\r\nARRAY_SIZE(desc->CompatibleID) +\r\nARRAY_SIZE(desc->SubCompatibleID));\r\nlength = sizeof(*desc);\r\n}\r\nbreak;\r\ncase FFS_OS_DESC_EXT_PROP: {\r\nstruct usb_ext_prop_desc *desc = data;\r\nstruct usb_os_desc_table *t;\r\nstruct usb_os_desc_ext_prop *ext_prop;\r\nchar *ext_prop_name;\r\nchar *ext_prop_data;\r\nt = &func->function.os_desc_table[h->interface];\r\nt->if_id = func->interfaces_nums[h->interface];\r\next_prop = func->ffs->ms_os_descs_ext_prop_avail;\r\nfunc->ffs->ms_os_descs_ext_prop_avail += sizeof(*ext_prop);\r\next_prop->type = le32_to_cpu(desc->dwPropertyDataType);\r\next_prop->name_len = le16_to_cpu(desc->wPropertyNameLength);\r\next_prop->data_len = le32_to_cpu(*(u32 *)\r\nusb_ext_prop_data_len_ptr(data, ext_prop->name_len));\r\nlength = ext_prop->name_len + ext_prop->data_len + 14;\r\next_prop_name = func->ffs->ms_os_descs_ext_prop_name_avail;\r\nfunc->ffs->ms_os_descs_ext_prop_name_avail +=\r\next_prop->name_len;\r\next_prop_data = func->ffs->ms_os_descs_ext_prop_data_avail;\r\nfunc->ffs->ms_os_descs_ext_prop_data_avail +=\r\next_prop->data_len;\r\nmemcpy(ext_prop_data,\r\nusb_ext_prop_data_ptr(data, ext_prop->name_len),\r\next_prop->data_len);\r\nswitch (ext_prop->type) {\r\ncase USB_EXT_PROP_UNICODE:\r\ncase USB_EXT_PROP_UNICODE_ENV:\r\ncase USB_EXT_PROP_UNICODE_LINK:\r\ncase USB_EXT_PROP_UNICODE_MULTI:\r\next_prop->data_len *= 2;\r\nbreak;\r\n}\r\next_prop->data = ext_prop_data;\r\nmemcpy(ext_prop_name, usb_ext_prop_name_ptr(data),\r\next_prop->name_len);\r\next_prop->name_len *= 2;\r\next_prop->name = ext_prop_name;\r\nt->os_desc->ext_prop_len +=\r\next_prop->name_len + ext_prop->data_len + 14;\r\n++t->os_desc->ext_prop_count;\r\nlist_add_tail(&ext_prop->entry, &t->os_desc->ext_prop);\r\n}\r\nbreak;\r\ndefault:\r\npr_vdebug("unknown descriptor: %d\n", type);\r\n}\r\nreturn length;\r\n}\r\nstatic inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct f_fs_opts *ffs_opts =\r\ncontainer_of(f->fi, struct f_fs_opts, func_inst);\r\nint ret;\r\nENTER();\r\nif (!ffs_opts->no_configfs)\r\nffs_dev_lock();\r\nret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;\r\nfunc->ffs = ffs_opts->dev->ffs_data;\r\nif (!ffs_opts->no_configfs)\r\nffs_dev_unlock();\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nfunc->conf = c;\r\nfunc->gadget = c->cdev->gadget;\r\nif (!ffs_opts->refcnt) {\r\nret = functionfs_bind(func->ffs, c->cdev);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\nffs_opts->refcnt++;\r\nfunc->function.strings = func->ffs->stringtabs;\r\nreturn ffs_opts;\r\n}\r\nstatic int _ffs_func_bind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nconst int full = !!func->ffs->fs_descs_count;\r\nconst int high = gadget_is_dualspeed(func->gadget) &&\r\nfunc->ffs->hs_descs_count;\r\nconst int super = gadget_is_superspeed(func->gadget) &&\r\nfunc->ffs->ss_descs_count;\r\nint fs_len, hs_len, ss_len, ret, i;\r\nvla_group(d);\r\nvla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);\r\nvla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,\r\nfull ? ffs->fs_descs_count + 1 : 0);\r\nvla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,\r\nhigh ? ffs->hs_descs_count + 1 : 0);\r\nvla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,\r\nsuper ? ffs->ss_descs_count + 1 : 0);\r\nvla_item_with_sz(d, short, inums, ffs->interfaces_count);\r\nvla_item_with_sz(d, struct usb_os_desc_table, os_desc_table,\r\nc->cdev->use_os_string ? ffs->interfaces_count : 0);\r\nvla_item_with_sz(d, char[16], ext_compat,\r\nc->cdev->use_os_string ? ffs->interfaces_count : 0);\r\nvla_item_with_sz(d, struct usb_os_desc, os_desc,\r\nc->cdev->use_os_string ? ffs->interfaces_count : 0);\r\nvla_item_with_sz(d, struct usb_os_desc_ext_prop, ext_prop,\r\nffs->ms_os_descs_ext_prop_count);\r\nvla_item_with_sz(d, char, ext_prop_name,\r\nffs->ms_os_descs_ext_prop_name_len);\r\nvla_item_with_sz(d, char, ext_prop_data,\r\nffs->ms_os_descs_ext_prop_data_len);\r\nvla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);\r\nchar *vlabuf;\r\nENTER();\r\nif (unlikely(!(full | high | super)))\r\nreturn -ENOTSUPP;\r\nvlabuf = kzalloc(vla_group_size(d), GFP_KERNEL);\r\nif (unlikely(!vlabuf))\r\nreturn -ENOMEM;\r\nffs->ms_os_descs_ext_prop_avail = vla_ptr(vlabuf, d, ext_prop);\r\nffs->ms_os_descs_ext_prop_name_avail =\r\nvla_ptr(vlabuf, d, ext_prop_name);\r\nffs->ms_os_descs_ext_prop_data_avail =\r\nvla_ptr(vlabuf, d, ext_prop_data);\r\nmemcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs,\r\nffs->raw_descs_length);\r\nmemset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);\r\nfor (ret = ffs->eps_count; ret; --ret) {\r\nstruct ffs_ep *ptr;\r\nptr = vla_ptr(vlabuf, d, eps);\r\nptr[ret].num = -1;\r\n}\r\nfunc->eps = vla_ptr(vlabuf, d, eps);\r\nfunc->interfaces_nums = vla_ptr(vlabuf, d, inums);\r\nif (likely(full)) {\r\nfunc->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);\r\nfs_len = ffs_do_descs(ffs->fs_descs_count,\r\nvla_ptr(vlabuf, d, raw_descs),\r\nd_raw_descs__sz,\r\n__ffs_func_bind_do_descs, func);\r\nif (unlikely(fs_len < 0)) {\r\nret = fs_len;\r\ngoto error;\r\n}\r\n} else {\r\nfs_len = 0;\r\n}\r\nif (likely(high)) {\r\nfunc->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);\r\nhs_len = ffs_do_descs(ffs->hs_descs_count,\r\nvla_ptr(vlabuf, d, raw_descs) + fs_len,\r\nd_raw_descs__sz - fs_len,\r\n__ffs_func_bind_do_descs, func);\r\nif (unlikely(hs_len < 0)) {\r\nret = hs_len;\r\ngoto error;\r\n}\r\n} else {\r\nhs_len = 0;\r\n}\r\nif (likely(super)) {\r\nfunc->function.ss_descriptors = vla_ptr(vlabuf, d, ss_descs);\r\nss_len = ffs_do_descs(ffs->ss_descs_count,\r\nvla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,\r\nd_raw_descs__sz - fs_len - hs_len,\r\n__ffs_func_bind_do_descs, func);\r\nif (unlikely(ss_len < 0)) {\r\nret = ss_len;\r\ngoto error;\r\n}\r\n} else {\r\nss_len = 0;\r\n}\r\nret = ffs_do_descs(ffs->fs_descs_count +\r\n(high ? ffs->hs_descs_count : 0) +\r\n(super ? ffs->ss_descs_count : 0),\r\nvla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,\r\n__ffs_func_bind_do_nums, func);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nfunc->function.os_desc_table = vla_ptr(vlabuf, d, os_desc_table);\r\nif (c->cdev->use_os_string)\r\nfor (i = 0; i < ffs->interfaces_count; ++i) {\r\nstruct usb_os_desc *desc;\r\ndesc = func->function.os_desc_table[i].os_desc =\r\nvla_ptr(vlabuf, d, os_desc) +\r\ni * sizeof(struct usb_os_desc);\r\ndesc->ext_compat_id =\r\nvla_ptr(vlabuf, d, ext_compat) + i * 16;\r\nINIT_LIST_HEAD(&desc->ext_prop);\r\n}\r\nret = ffs_do_os_descs(ffs->ms_os_descs_count,\r\nvla_ptr(vlabuf, d, raw_descs) +\r\nfs_len + hs_len + ss_len,\r\nd_raw_descs__sz - fs_len - hs_len - ss_len,\r\n__ffs_func_bind_do_os_desc, func);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nfunc->function.os_desc_n =\r\nc->cdev->use_os_string ? ffs->interfaces_count : 0;\r\nffs_event_add(ffs, FUNCTIONFS_BIND);\r\nreturn 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int ffs_func_bind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);\r\nif (IS_ERR(ffs_opts))\r\nreturn PTR_ERR(ffs_opts);\r\nreturn _ffs_func_bind(c, f);\r\n}\r\nstatic int ffs_func_set_alt(struct usb_function *f,\r\nunsigned interface, unsigned alt)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nint ret = 0, intf;\r\nif (alt != (unsigned)-1) {\r\nintf = ffs_func_revmap_intf(func, interface);\r\nif (unlikely(intf < 0))\r\nreturn intf;\r\n}\r\nif (ffs->func)\r\nffs_func_eps_disable(ffs->func);\r\nif (ffs->state != FFS_ACTIVE)\r\nreturn -ENODEV;\r\nif (alt == (unsigned)-1) {\r\nffs->func = NULL;\r\nffs_event_add(ffs, FUNCTIONFS_DISABLE);\r\nreturn 0;\r\n}\r\nffs->func = func;\r\nret = ffs_func_eps_enable(func);\r\nif (likely(ret >= 0))\r\nffs_event_add(ffs, FUNCTIONFS_ENABLE);\r\nreturn ret;\r\n}\r\nstatic void ffs_func_disable(struct usb_function *f)\r\n{\r\nffs_func_set_alt(f, 0, (unsigned)-1);\r\n}\r\nstatic int ffs_func_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *creq)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nunsigned long flags;\r\nint ret;\r\nENTER();\r\npr_vdebug("creq->bRequestType = %02x\n", creq->bRequestType);\r\npr_vdebug("creq->bRequest = %02x\n", creq->bRequest);\r\npr_vdebug("creq->wValue = %04x\n", le16_to_cpu(creq->wValue));\r\npr_vdebug("creq->wIndex = %04x\n", le16_to_cpu(creq->wIndex));\r\npr_vdebug("creq->wLength = %04x\n", le16_to_cpu(creq->wLength));\r\nif (ffs->state != FFS_ACTIVE)\r\nreturn -ENODEV;\r\nswitch (creq->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\r\nret = func->ffs->eps_addrmap[ret];\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\r\nffs->ev.setup = *creq;\r\nffs->ev.setup.wIndex = cpu_to_le16(ret);\r\n__ffs_event_add(ffs, FUNCTIONFS_SETUP);\r\nspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ffs_func_suspend(struct usb_function *f)\r\n{\r\nENTER();\r\nffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);\r\n}\r\nstatic void ffs_func_resume(struct usb_function *f)\r\n{\r\nENTER();\r\nffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);\r\n}\r\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num)\r\n{\r\nnum = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];\r\nreturn num ? num : -EDOM;\r\n}\r\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\r\n{\r\nshort *nums = func->interfaces_nums;\r\nunsigned count = func->ffs->interfaces_count;\r\nfor (; count; --count, ++nums) {\r\nif (*nums >= 0 && *nums == intf)\r\nreturn nums - func->interfaces_nums;\r\n}\r\nreturn -EDOM;\r\n}\r\nstatic struct ffs_dev *_ffs_do_find_dev(const char *name)\r\n{\r\nstruct ffs_dev *dev;\r\nlist_for_each_entry(dev, &ffs_devices, entry) {\r\nif (!dev->name || !name)\r\ncontinue;\r\nif (strcmp(dev->name, name) == 0)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ffs_dev *_ffs_get_single_dev(void)\r\n{\r\nstruct ffs_dev *dev;\r\nif (list_is_singular(&ffs_devices)) {\r\ndev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\r\nif (dev->single)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ffs_dev *_ffs_find_dev(const char *name)\r\n{\r\nstruct ffs_dev *dev;\r\ndev = _ffs_get_single_dev();\r\nif (dev)\r\nreturn dev;\r\nreturn _ffs_do_find_dev(name);\r\n}\r\nstatic inline struct f_fs_opts *to_ffs_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_fs_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void ffs_attr_release(struct config_item *item)\r\n{\r\nstruct f_fs_opts *opts = to_ffs_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic void ffs_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_fs_opts *opts;\r\nopts = to_f_fs_opts(f);\r\nffs_dev_lock();\r\n_ffs_free_dev(opts->dev);\r\nffs_dev_unlock();\r\nkfree(opts);\r\n}\r\nstatic int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)\r\n{\r\nstruct f_fs_opts *opts;\r\nchar *ptr;\r\nconst char *tmp;\r\nint name_len, ret;\r\nname_len = strlen(name) + 1;\r\nif (name_len > MAX_INST_NAME_LEN)\r\nreturn -ENAMETOOLONG;\r\nptr = kstrndup(name, name_len, GFP_KERNEL);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\nopts = to_f_fs_opts(fi);\r\ntmp = NULL;\r\nffs_dev_lock();\r\ntmp = opts->dev->name_allocated ? opts->dev->name : NULL;\r\nret = _ffs_name_dev(opts->dev, ptr);\r\nif (ret) {\r\nkfree(ptr);\r\nffs_dev_unlock();\r\nreturn ret;\r\n}\r\nopts->dev->name_allocated = true;\r\nffs_dev_unlock();\r\nkfree(tmp);\r\nreturn 0;\r\n}\r\nstatic struct usb_function_instance *ffs_alloc_inst(void)\r\n{\r\nstruct f_fs_opts *opts;\r\nstruct ffs_dev *dev;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts->func_inst.set_inst_name = ffs_set_inst_name;\r\nopts->func_inst.free_func_inst = ffs_free_inst;\r\nffs_dev_lock();\r\ndev = _ffs_alloc_dev();\r\nffs_dev_unlock();\r\nif (IS_ERR(dev)) {\r\nkfree(opts);\r\nreturn ERR_CAST(dev);\r\n}\r\nopts->dev = dev;\r\ndev->opts = opts;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&ffs_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void ffs_free(struct usb_function *f)\r\n{\r\nkfree(ffs_func_from_usb(f));\r\n}\r\nstatic void ffs_func_unbind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nstruct f_fs_opts *opts =\r\ncontainer_of(f->fi, struct f_fs_opts, func_inst);\r\nstruct ffs_ep *ep = func->eps;\r\nunsigned count = ffs->eps_count;\r\nunsigned long flags;\r\nENTER();\r\nif (ffs->func == func) {\r\nffs_func_eps_disable(func);\r\nffs->func = NULL;\r\n}\r\nif (!--opts->refcnt)\r\nfunctionfs_unbind(ffs);\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nif (ep->ep && ep->req)\r\nusb_ep_free_request(ep->ep, ep->req);\r\nep->req = NULL;\r\n++ep;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\nkfree(func->eps);\r\nfunc->eps = NULL;\r\nfunc->function.fs_descriptors = NULL;\r\nfunc->function.hs_descriptors = NULL;\r\nfunc->function.ss_descriptors = NULL;\r\nfunc->interfaces_nums = NULL;\r\nffs_event_add(ffs, FUNCTIONFS_UNBIND);\r\n}\r\nstatic struct usb_function *ffs_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct ffs_function *func;\r\nENTER();\r\nfunc = kzalloc(sizeof(*func), GFP_KERNEL);\r\nif (unlikely(!func))\r\nreturn ERR_PTR(-ENOMEM);\r\nfunc->function.name = "Function FS Gadget";\r\nfunc->function.bind = ffs_func_bind;\r\nfunc->function.unbind = ffs_func_unbind;\r\nfunc->function.set_alt = ffs_func_set_alt;\r\nfunc->function.disable = ffs_func_disable;\r\nfunc->function.setup = ffs_func_setup;\r\nfunc->function.suspend = ffs_func_suspend;\r\nfunc->function.resume = ffs_func_resume;\r\nfunc->function.free_func = ffs_free;\r\nreturn &func->function;\r\n}\r\nstatic struct ffs_dev *_ffs_alloc_dev(void)\r\n{\r\nstruct ffs_dev *dev;\r\nint ret;\r\nif (_ffs_get_single_dev())\r\nreturn ERR_PTR(-EBUSY);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (list_empty(&ffs_devices)) {\r\nret = functionfs_init();\r\nif (ret) {\r\nkfree(dev);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nlist_add(&dev->entry, &ffs_devices);\r\nreturn dev;\r\n}\r\nstatic int _ffs_name_dev(struct ffs_dev *dev, const char *name)\r\n{\r\nstruct ffs_dev *existing;\r\nexisting = _ffs_do_find_dev(name);\r\nif (existing)\r\nreturn -EBUSY;\r\ndev->name = name;\r\nreturn 0;\r\n}\r\nint ffs_name_dev(struct ffs_dev *dev, const char *name)\r\n{\r\nint ret;\r\nffs_dev_lock();\r\nret = _ffs_name_dev(dev, name);\r\nffs_dev_unlock();\r\nreturn ret;\r\n}\r\nint ffs_single_dev(struct ffs_dev *dev)\r\n{\r\nint ret;\r\nret = 0;\r\nffs_dev_lock();\r\nif (!list_is_singular(&ffs_devices))\r\nret = -EBUSY;\r\nelse\r\ndev->single = true;\r\nffs_dev_unlock();\r\nreturn ret;\r\n}\r\nstatic void _ffs_free_dev(struct ffs_dev *dev)\r\n{\r\nlist_del(&dev->entry);\r\nif (dev->name_allocated)\r\nkfree(dev->name);\r\nkfree(dev);\r\nif (list_empty(&ffs_devices))\r\nfunctionfs_cleanup();\r\n}\r\nstatic void *ffs_acquire_dev(const char *dev_name)\r\n{\r\nstruct ffs_dev *ffs_dev;\r\nENTER();\r\nffs_dev_lock();\r\nffs_dev = _ffs_find_dev(dev_name);\r\nif (!ffs_dev)\r\nffs_dev = ERR_PTR(-ENOENT);\r\nelse if (ffs_dev->mounted)\r\nffs_dev = ERR_PTR(-EBUSY);\r\nelse if (ffs_dev->ffs_acquire_dev_callback &&\r\nffs_dev->ffs_acquire_dev_callback(ffs_dev))\r\nffs_dev = ERR_PTR(-ENOENT);\r\nelse\r\nffs_dev->mounted = true;\r\nffs_dev_unlock();\r\nreturn ffs_dev;\r\n}\r\nstatic void ffs_release_dev(struct ffs_data *ffs_data)\r\n{\r\nstruct ffs_dev *ffs_dev;\r\nENTER();\r\nffs_dev_lock();\r\nffs_dev = ffs_data->private_data;\r\nif (ffs_dev) {\r\nffs_dev->mounted = false;\r\nif (ffs_dev->ffs_release_dev_callback)\r\nffs_dev->ffs_release_dev_callback(ffs_dev);\r\n}\r\nffs_dev_unlock();\r\n}\r\nstatic int ffs_ready(struct ffs_data *ffs)\r\n{\r\nstruct ffs_dev *ffs_obj;\r\nint ret = 0;\r\nENTER();\r\nffs_dev_lock();\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (WARN_ON(ffs_obj->desc_ready)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nffs_obj->desc_ready = true;\r\nffs_obj->ffs_data = ffs;\r\nif (ffs_obj->ffs_ready_callback)\r\nret = ffs_obj->ffs_ready_callback(ffs);\r\ndone:\r\nffs_dev_unlock();\r\nreturn ret;\r\n}\r\nstatic void ffs_closed(struct ffs_data *ffs)\r\n{\r\nstruct ffs_dev *ffs_obj;\r\nENTER();\r\nffs_dev_lock();\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj)\r\ngoto done;\r\nffs_obj->desc_ready = false;\r\nif (ffs_obj->ffs_closed_callback)\r\nffs_obj->ffs_closed_callback(ffs);\r\nif (!ffs_obj->opts || ffs_obj->opts->no_configfs\r\n|| !ffs_obj->opts->func_inst.group.cg_item.ci_parent)\r\ngoto done;\r\nunregister_gadget_item(ffs_obj->opts->\r\nfunc_inst.group.cg_item.ci_parent->ci_parent);\r\ndone:\r\nffs_dev_unlock();\r\n}\r\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\r\n{\r\nreturn nonblock\r\n? likely(mutex_trylock(mutex)) ? 0 : -EAGAIN\r\n: mutex_lock_interruptible(mutex);\r\n}\r\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\r\n{\r\nchar *data;\r\nif (unlikely(!len))\r\nreturn NULL;\r\ndata = kmalloc(len, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unlikely(__copy_from_user(data, buf, len))) {\r\nkfree(data);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\npr_vdebug("Buffer from user space:\n");\r\nffs_dump_mem("", data, len);\r\nreturn data;\r\n}
