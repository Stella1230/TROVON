static int mperf_get_tsc(unsigned long long *tsc)\r\n{\r\nint ret;\r\nret = read_msr(0, MSR_TSC, tsc);\r\nif (ret)\r\ndprint("Reading TSC MSR failed, returning %llu\n", *tsc);\r\nreturn ret;\r\n}\r\nstatic int mperf_init_stats(unsigned int cpu)\r\n{\r\nunsigned long long val;\r\nint ret;\r\nret = read_msr(cpu, MSR_APERF, &val);\r\naperf_previous_count[cpu] = val;\r\nret |= read_msr(cpu, MSR_MPERF, &val);\r\nmperf_previous_count[cpu] = val;\r\nis_valid[cpu] = !ret;\r\nreturn 0;\r\n}\r\nstatic int mperf_measure_stats(unsigned int cpu)\r\n{\r\nunsigned long long val;\r\nint ret;\r\nret = read_msr(cpu, MSR_APERF, &val);\r\naperf_current_count[cpu] = val;\r\nret |= read_msr(cpu, MSR_MPERF, &val);\r\nmperf_current_count[cpu] = val;\r\nis_valid[cpu] = !ret;\r\nreturn 0;\r\n}\r\nstatic int mperf_get_count_percent(unsigned int id, double *percent,\r\nunsigned int cpu)\r\n{\r\nunsigned long long aperf_diff, mperf_diff, tsc_diff;\r\nunsigned long long timediff;\r\nif (!is_valid[cpu])\r\nreturn -1;\r\nif (id != C0 && id != Cx)\r\nreturn -1;\r\nmperf_diff = mperf_current_count[cpu] - mperf_previous_count[cpu];\r\naperf_diff = aperf_current_count[cpu] - aperf_previous_count[cpu];\r\nif (max_freq_mode == MAX_FREQ_TSC_REF) {\r\ntsc_diff = tsc_at_measure_end - tsc_at_measure_start;\r\n*percent = 100.0 * mperf_diff / tsc_diff;\r\ndprint("%s: TSC Ref - mperf_diff: %llu, tsc_diff: %llu\n",\r\nmperf_cstates[id].name, mperf_diff, tsc_diff);\r\n} else if (max_freq_mode == MAX_FREQ_SYSFS) {\r\ntimediff = timespec_diff_us(time_start, time_end);\r\n*percent = 100.0 * mperf_diff / timediff;\r\ndprint("%s: MAXFREQ - mperf_diff: %llu, time_diff: %llu\n",\r\nmperf_cstates[id].name, mperf_diff, timediff);\r\n} else\r\nreturn -1;\r\nif (id == Cx)\r\n*percent = 100.0 - *percent;\r\ndprint("%s: previous: %llu - current: %llu - (%u)\n",\r\nmperf_cstates[id].name, mperf_diff, aperf_diff, cpu);\r\ndprint("%s: %f\n", mperf_cstates[id].name, *percent);\r\nreturn 0;\r\n}\r\nstatic int mperf_get_count_freq(unsigned int id, unsigned long long *count,\r\nunsigned int cpu)\r\n{\r\nunsigned long long aperf_diff, mperf_diff, time_diff, tsc_diff;\r\nif (id != AVG_FREQ)\r\nreturn 1;\r\nif (!is_valid[cpu])\r\nreturn -1;\r\nmperf_diff = mperf_current_count[cpu] - mperf_previous_count[cpu];\r\naperf_diff = aperf_current_count[cpu] - aperf_previous_count[cpu];\r\nif (max_freq_mode == MAX_FREQ_TSC_REF) {\r\ntsc_diff = tsc_at_measure_end - tsc_at_measure_start;\r\ntime_diff = timespec_diff_us(time_start, time_end);\r\nmax_frequency = tsc_diff / time_diff;\r\n}\r\n*count = max_frequency * ((double)aperf_diff / mperf_diff);\r\ndprint("%s: Average freq based on %s maximum frequency:\n",\r\nmperf_cstates[id].name,\r\n(max_freq_mode == MAX_FREQ_TSC_REF) ? "TSC calculated" : "sysfs read");\r\ndprint("%max_frequency: %lu", max_frequency);\r\ndprint("aperf_diff: %llu\n", aperf_diff);\r\ndprint("mperf_diff: %llu\n", mperf_diff);\r\ndprint("avg freq: %llu\n", *count);\r\nreturn 0;\r\n}\r\nstatic int mperf_start(void)\r\n{\r\nint cpu;\r\nunsigned long long dbg;\r\nclock_gettime(CLOCK_REALTIME, &time_start);\r\nmperf_get_tsc(&tsc_at_measure_start);\r\nfor (cpu = 0; cpu < cpu_count; cpu++)\r\nmperf_init_stats(cpu);\r\nmperf_get_tsc(&dbg);\r\ndprint("TSC diff: %llu\n", dbg - tsc_at_measure_start);\r\nreturn 0;\r\n}\r\nstatic int mperf_stop(void)\r\n{\r\nunsigned long long dbg;\r\nint cpu;\r\nfor (cpu = 0; cpu < cpu_count; cpu++)\r\nmperf_measure_stats(cpu);\r\nmperf_get_tsc(&tsc_at_measure_end);\r\nclock_gettime(CLOCK_REALTIME, &time_end);\r\nmperf_get_tsc(&dbg);\r\ndprint("TSC diff: %llu\n", dbg - tsc_at_measure_end);\r\nreturn 0;\r\n}\r\nstatic int init_maxfreq_mode(void)\r\n{\r\nint ret;\r\nunsigned long long hwcr;\r\nunsigned long min;\r\nif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_INV_TSC))\r\ngoto use_sysfs;\r\nif (cpupower_cpu_info.vendor == X86_VENDOR_AMD) {\r\nret = read_msr(0, MSR_AMD_HWCR, &hwcr);\r\nif (ret != 0) {\r\ndprint("TSC read 0x%x failed - assume TSC working\n",\r\nMSR_AMD_HWCR);\r\nreturn 0;\r\n} else if (1 & (hwcr >> 24)) {\r\nmax_freq_mode = MAX_FREQ_TSC_REF;\r\nreturn 0;\r\n} else { }\r\n} else if (cpupower_cpu_info.vendor == X86_VENDOR_INTEL) {\r\nmax_freq_mode = MAX_FREQ_TSC_REF;\r\nreturn 0;\r\n}\r\nuse_sysfs:\r\nif (cpufreq_get_hardware_limits(0, &min, &max_frequency)) {\r\ndprint("Cannot retrieve max freq from cpufreq kernel "\r\n"subsystem\n");\r\nreturn -1;\r\n}\r\nmax_freq_mode = MAX_FREQ_SYSFS;\r\nreturn 0;\r\n}\r\nstruct cpuidle_monitor *mperf_register(void)\r\n{\r\nif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_APERF))\r\nreturn NULL;\r\nif (init_maxfreq_mode())\r\nreturn NULL;\r\nis_valid = calloc(cpu_count, sizeof(int));\r\nmperf_previous_count = calloc(cpu_count, sizeof(unsigned long long));\r\naperf_previous_count = calloc(cpu_count, sizeof(unsigned long long));\r\nmperf_current_count = calloc(cpu_count, sizeof(unsigned long long));\r\naperf_current_count = calloc(cpu_count, sizeof(unsigned long long));\r\nmperf_monitor.name_len = strlen(mperf_monitor.name);\r\nreturn &mperf_monitor;\r\n}\r\nvoid mperf_unregister(void)\r\n{\r\nfree(mperf_previous_count);\r\nfree(aperf_previous_count);\r\nfree(mperf_current_count);\r\nfree(aperf_current_count);\r\nfree(is_valid);\r\n}
