static struct trinity_ps *trinity_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct trinity_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstatic struct trinity_power_info *trinity_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic void trinity_gfx_powergating_initialize(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 p, u;\r\nu32 value;\r\nstruct atom_clock_dividers dividers;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nu32 sssd = 1;\r\nint ret;\r\nu32 hw_rev = (RREG32(HW_REV) & ATI_REV_ID_MASK) >> ATI_REV_ID_SHIFT;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\n25000, false, &dividers);\r\nif (ret)\r\nreturn;\r\nvalue = RREG32_SMC(GFX_POWER_GATING_CNTL);\r\nvalue &= ~(SSSD_MASK | PDS_DIV_MASK);\r\nif (sssd)\r\nvalue |= SSSD(1);\r\nvalue |= PDS_DIV(dividers.post_div);\r\nWREG32_SMC(GFX_POWER_GATING_CNTL, value);\r\nr600_calculate_u_and_p(500, xclk, 16, &p, &u);\r\nWREG32(CG_PG_CTRL, SP(p) | SU(u));\r\nWREG32_P(CG_GIPOTS, CG_GIPOT(p), ~CG_GIPOT_MASK);\r\nif (pi->override_dynamic_mgpg && (hw_rev == 0))\r\ntrinity_override_dynamic_mg_powergating(rdev);\r\n}\r\nstatic void trinity_mg_clockgating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 local0;\r\nu32 local1;\r\nif (enable) {\r\nlocal0 = RREG32_CG(CG_CGTT_LOCAL_0);\r\nlocal1 = RREG32_CG(CG_CGTT_LOCAL_1);\r\nWREG32_CG(CG_CGTT_LOCAL_0,\r\n(0x00380000 & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\r\nWREG32_CG(CG_CGTT_LOCAL_1,\r\n(0x0E000000 & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\r\nWREG32(CGTS_SM_CTRL_REG, CGTS_SM_CTRL_REG_ENABLE);\r\n} else {\r\nWREG32(CGTS_SM_CTRL_REG, CGTS_SM_CTRL_REG_DISABLE);\r\nlocal0 = RREG32_CG(CG_CGTT_LOCAL_0);\r\nlocal1 = RREG32_CG(CG_CGTT_LOCAL_1);\r\nWREG32_CG(CG_CGTT_LOCAL_0,\r\nCGCG_CGTT_LOCAL0_MASK | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\r\nWREG32_CG(CG_CGTT_LOCAL_1,\r\nCGCG_CGTT_LOCAL1_MASK | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\r\n}\r\n}\r\nstatic void trinity_mg_clockgating_initialize(struct radeon_device *rdev)\r\n{\r\nu32 count;\r\nconst u32 *seq = NULL;\r\nseq = &trinity_mgcg_shls_default[0];\r\ncount = sizeof(trinity_mgcg_shls_default) / (3 * sizeof(u32));\r\ntrinity_program_clk_gating_hw_sequence(rdev, seq, count);\r\n}\r\nstatic void trinity_gfx_clockgating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable) {\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\n} else {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\r\nWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\r\nRREG32(GB_ADDR_CONFIG);\r\n}\r\n}\r\nstatic void trinity_program_clk_gating_hw_sequence(struct radeon_device *rdev,\r\nconst u32 *seq, u32 count)\r\n{\r\nu32 i, length = count * 3;\r\nfor (i = 0; i < length; i += 3)\r\nWREG32_P(seq[i], seq[i+1], ~seq[i+2]);\r\n}\r\nstatic void trinity_program_override_mgpg_sequences(struct radeon_device *rdev,\r\nconst u32 *seq, u32 count)\r\n{\r\nu32 i, length = count * 2;\r\nfor (i = 0; i < length; i += 2)\r\nWREG32(seq[i], seq[i+1]);\r\n}\r\nstatic void trinity_override_dynamic_mg_powergating(struct radeon_device *rdev)\r\n{\r\nu32 count;\r\nconst u32 *seq = NULL;\r\nseq = &trinity_override_mgpg_sequences[0];\r\ncount = sizeof(trinity_override_mgpg_sequences) / (2 * sizeof(u32));\r\ntrinity_program_override_mgpg_sequences(rdev, seq, count);\r\n}\r\nstatic void trinity_ls_clockgating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 count;\r\nconst u32 *seq = NULL;\r\nif (enable) {\r\nseq = &trinity_sysls_enable[0];\r\ncount = sizeof(trinity_sysls_enable) / (3 * sizeof(u32));\r\n} else {\r\nseq = &trinity_sysls_disable[0];\r\ncount = sizeof(trinity_sysls_disable) / (3 * sizeof(u32));\r\n}\r\ntrinity_program_clk_gating_hw_sequence(rdev, seq, count);\r\n}\r\nstatic void trinity_gfx_powergating_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nif (enable) {\r\nif (RREG32_SMC(CC_SMU_TST_EFUSE1_MISC) & RB_BACKEND_DISABLE_MASK)\r\nWREG32_SMC(SMU_SCRATCH_A, (RREG32_SMC(SMU_SCRATCH_A) | 0x01));\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_PWR_DOWN_EN, ~DYN_PWR_DOWN_EN);\r\n} else {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_PWR_DOWN_EN);\r\nRREG32(GB_ADDR_CONFIG);\r\n}\r\n}\r\nstatic void trinity_gfx_dynamic_mgpg_enable(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 value;\r\nif (enable) {\r\nvalue = RREG32_SMC(PM_I_CNTL_1);\r\nvalue &= ~DS_PG_CNTL_MASK;\r\nvalue |= DS_PG_CNTL(1);\r\nWREG32_SMC(PM_I_CNTL_1, value);\r\nvalue = RREG32_SMC(SMU_S_PG_CNTL);\r\nvalue &= ~DS_PG_EN_MASK;\r\nvalue |= DS_PG_EN(1);\r\nWREG32_SMC(SMU_S_PG_CNTL, value);\r\n} else {\r\nvalue = RREG32_SMC(SMU_S_PG_CNTL);\r\nvalue &= ~DS_PG_EN_MASK;\r\nWREG32_SMC(SMU_S_PG_CNTL, value);\r\nvalue = RREG32_SMC(PM_I_CNTL_1);\r\nvalue &= ~DS_PG_CNTL_MASK;\r\nWREG32_SMC(PM_I_CNTL_1, value);\r\n}\r\ntrinity_gfx_dynamic_mgpg_config(rdev);\r\n}\r\nstatic void trinity_enable_clock_power_gating(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (pi->enable_gfx_clock_gating)\r\nsumo_gfx_clockgating_initialize(rdev);\r\nif (pi->enable_mg_clock_gating)\r\ntrinity_mg_clockgating_initialize(rdev);\r\nif (pi->enable_gfx_power_gating)\r\ntrinity_gfx_powergating_initialize(rdev);\r\nif (pi->enable_mg_clock_gating) {\r\ntrinity_ls_clockgating_enable(rdev, true);\r\ntrinity_mg_clockgating_enable(rdev, true);\r\n}\r\nif (pi->enable_gfx_clock_gating)\r\ntrinity_gfx_clockgating_enable(rdev, true);\r\nif (pi->enable_gfx_dynamic_mgpg)\r\ntrinity_gfx_dynamic_mgpg_enable(rdev, true);\r\nif (pi->enable_gfx_power_gating)\r\ntrinity_gfx_powergating_enable(rdev, true);\r\n}\r\nstatic void trinity_disable_clock_power_gating(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (pi->enable_gfx_power_gating)\r\ntrinity_gfx_powergating_enable(rdev, false);\r\nif (pi->enable_gfx_dynamic_mgpg)\r\ntrinity_gfx_dynamic_mgpg_enable(rdev, false);\r\nif (pi->enable_gfx_clock_gating)\r\ntrinity_gfx_clockgating_enable(rdev, false);\r\nif (pi->enable_mg_clock_gating) {\r\ntrinity_mg_clockgating_enable(rdev, false);\r\ntrinity_ls_clockgating_enable(rdev, false);\r\n}\r\n}\r\nstatic void trinity_set_divider_value(struct radeon_device *rdev,\r\nu32 index, u32 sclk)\r\n{\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\nsclk, false, &dividers);\r\nif (ret)\r\nreturn;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\r\nvalue &= ~CLK_DIVIDER_MASK;\r\nvalue |= CLK_DIVIDER(dividers.post_div);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\nsclk/2, false, &dividers);\r\nif (ret)\r\nreturn;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_PG_CNTL + ix);\r\nvalue &= ~PD_SCLK_DIVIDER_MASK;\r\nvalue |= PD_SCLK_DIVIDER(dividers.post_div);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_PG_CNTL + ix, value);\r\n}\r\nstatic void trinity_set_ds_dividers(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\r\nvalue &= ~DS_DIV_MASK;\r\nvalue |= DS_DIV(divider);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\r\n}\r\nstatic void trinity_set_ss_dividers(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\r\nvalue &= ~DS_SH_DIV_MASK;\r\nvalue |= DS_SH_DIV(divider);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\r\n}\r\nstatic void trinity_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid);\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\r\nvalue &= ~VID_MASK;\r\nvalue |= VID(vid_7bit);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\r\nvalue &= ~LVRT_MASK;\r\nvalue |= LVRT(0);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\r\n}\r\nstatic void trinity_set_allos_gnb_slow(struct radeon_device *rdev,\r\nu32 index, u32 gnb_slow)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix);\r\nvalue &= ~GNB_SLOW_MASK;\r\nvalue |= GNB_SLOW(gnb_slow);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix, value);\r\n}\r\nstatic void trinity_set_force_nbp_state(struct radeon_device *rdev,\r\nu32 index, u32 force_nbp_state)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix);\r\nvalue &= ~FORCE_NBPS1_MASK;\r\nvalue |= FORCE_NBPS1(force_nbp_state);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix, value);\r\n}\r\nstatic void trinity_set_display_wm(struct radeon_device *rdev,\r\nu32 index, u32 wm)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\r\nvalue &= ~DISPLAY_WM_MASK;\r\nvalue |= DISPLAY_WM(wm);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\r\n}\r\nstatic void trinity_set_vce_wm(struct radeon_device *rdev,\r\nu32 index, u32 wm)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\r\nvalue &= ~VCE_WM_MASK;\r\nvalue |= VCE_WM(wm);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\r\n}\r\nstatic void trinity_set_at(struct radeon_device *rdev,\r\nu32 index, u32 at)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_AT + ix);\r\nvalue &= ~AT_MASK;\r\nvalue |= AT(at);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_AT + ix, value);\r\n}\r\nstatic void trinity_program_power_level(struct radeon_device *rdev,\r\nstruct trinity_pl *pl, u32 index)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (index >= SUMO_MAX_HARDWARE_POWERLEVELS)\r\nreturn;\r\ntrinity_set_divider_value(rdev, index, pl->sclk);\r\ntrinity_set_vid(rdev, index, pl->vddc_index);\r\ntrinity_set_ss_dividers(rdev, index, pl->ss_divider_index);\r\ntrinity_set_ds_dividers(rdev, index, pl->ds_divider_index);\r\ntrinity_set_allos_gnb_slow(rdev, index, pl->allow_gnb_slow);\r\ntrinity_set_force_nbp_state(rdev, index, pl->force_nbp_state);\r\ntrinity_set_display_wm(rdev, index, pl->display_wm);\r\ntrinity_set_vce_wm(rdev, index, pl->vce_wm);\r\ntrinity_set_at(rdev, index, pi->at[index]);\r\n}\r\nstatic void trinity_power_level_enable_disable(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nu32 value;\r\nu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\r\nvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\r\nvalue &= ~STATE_VALID_MASK;\r\nif (enable)\r\nvalue |= STATE_VALID(1);\r\nWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\r\n}\r\nstatic bool trinity_dpm_enabled(struct radeon_device *rdev)\r\n{\r\nif (RREG32_SMC(SMU_SCLK_DPM_CNTL) & SCLK_DPM_EN(1))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void trinity_start_dpm(struct radeon_device *rdev)\r\n{\r\nu32 value = RREG32_SMC(SMU_SCLK_DPM_CNTL);\r\nvalue &= ~(SCLK_DPM_EN_MASK | SCLK_DPM_BOOT_STATE_MASK | VOLTAGE_CHG_EN_MASK);\r\nvalue |= SCLK_DPM_EN(1) | SCLK_DPM_BOOT_STATE(0) | VOLTAGE_CHG_EN(1);\r\nWREG32_SMC(SMU_SCLK_DPM_CNTL, value);\r\nWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\r\nWREG32_P(CG_CG_VOLTAGE_CNTL, 0, ~EN);\r\ntrinity_dpm_config(rdev, true);\r\n}\r\nstatic void trinity_wait_for_dpm_enabled(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(SCLK_PWRMGT_CNTL) & DYNAMIC_PM_EN)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & TARGET_STATE_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void trinity_stop_dpm(struct radeon_device *rdev)\r\n{\r\nu32 sclk_dpm_cntl;\r\nWREG32_P(CG_CG_VOLTAGE_CNTL, EN, ~EN);\r\nsclk_dpm_cntl = RREG32_SMC(SMU_SCLK_DPM_CNTL);\r\nsclk_dpm_cntl &= ~(SCLK_DPM_EN_MASK | VOLTAGE_CHG_EN_MASK);\r\nWREG32_SMC(SMU_SCLK_DPM_CNTL, sclk_dpm_cntl);\r\ntrinity_dpm_config(rdev, false);\r\n}\r\nstatic void trinity_start_am(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~(RESET_SCLK_CNT | RESET_BUSY_CNT));\r\n}\r\nstatic void trinity_reset_am(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SCLK_PWRMGT_CNTL, RESET_SCLK_CNT | RESET_BUSY_CNT,\r\n~(RESET_SCLK_CNT | RESET_BUSY_CNT));\r\n}\r\nstatic void trinity_wait_for_level_0(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void trinity_enable_power_level_0(struct radeon_device *rdev)\r\n{\r\ntrinity_power_level_enable_disable(rdev, 0, true);\r\n}\r\nstatic void trinity_force_level_0(struct radeon_device *rdev)\r\n{\r\ntrinity_dpm_force_state(rdev, 0);\r\n}\r\nstatic void trinity_unforce_levels(struct radeon_device *rdev)\r\n{\r\ntrinity_dpm_no_forced_level(rdev);\r\n}\r\nstatic void trinity_program_power_levels_0_to_n(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\r\nstruct trinity_ps *old_ps = trinity_get_ps(old_rps);\r\nu32 i;\r\nu32 n_current_state_levels = (old_ps == NULL) ? 1 : old_ps->num_levels;\r\nfor (i = 0; i < new_ps->num_levels; i++) {\r\ntrinity_program_power_level(rdev, &new_ps->levels[i], i);\r\ntrinity_power_level_enable_disable(rdev, i, true);\r\n}\r\nfor (i = new_ps->num_levels; i < n_current_state_levels; i++)\r\ntrinity_power_level_enable_disable(rdev, i, false);\r\n}\r\nstatic void trinity_program_bootup_state(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 i;\r\ntrinity_program_power_level(rdev, &pi->boot_pl, 0);\r\ntrinity_power_level_enable_disable(rdev, 0, true);\r\nfor (i = 1; i < 8; i++)\r\ntrinity_power_level_enable_disable(rdev, i, false);\r\n}\r\nstatic void trinity_setup_uvd_clock_table(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nu32 uvdstates = (ps->vclk_low_divider |\r\nps->vclk_high_divider << 8 |\r\nps->dclk_low_divider << 16 |\r\nps->dclk_high_divider << 24);\r\nWREG32_SMC(SMU_UVD_DPM_STATES, uvdstates);\r\n}\r\nstatic void trinity_setup_uvd_dpm_interval(struct radeon_device *rdev,\r\nu32 interval)\r\n{\r\nu32 p, u;\r\nu32 tp = RREG32_SMC(PM_TP);\r\nu32 val;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nr600_calculate_u_and_p(interval, xclk, 16, &p, &u);\r\nval = (p + tp - 1) / tp;\r\nWREG32_SMC(SMU_UVD_DPM_CNTL, val);\r\n}\r\nstatic bool trinity_uvd_clocks_zero(struct radeon_ps *rps)\r\n{\r\nif ((rps->vclk == 0) && (rps->dclk == 0))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool trinity_uvd_clocks_equal(struct radeon_ps *rps1,\r\nstruct radeon_ps *rps2)\r\n{\r\nstruct trinity_ps *ps1 = trinity_get_ps(rps1);\r\nstruct trinity_ps *ps2 = trinity_get_ps(rps2);\r\nif ((rps1->vclk == rps2->vclk) &&\r\n(rps1->dclk == rps2->dclk) &&\r\n(ps1->vclk_low_divider == ps2->vclk_low_divider) &&\r\n(ps1->vclk_high_divider == ps2->vclk_high_divider) &&\r\n(ps1->dclk_low_divider == ps2->dclk_low_divider) &&\r\n(ps1->dclk_high_divider == ps2->dclk_high_divider))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void trinity_setup_uvd_clocks(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (pi->enable_gfx_power_gating) {\r\ntrinity_gfx_powergating_enable(rdev, false);\r\n}\r\nif (pi->uvd_dpm) {\r\nif (trinity_uvd_clocks_zero(new_rps) &&\r\n!trinity_uvd_clocks_zero(old_rps)) {\r\ntrinity_setup_uvd_dpm_interval(rdev, 0);\r\n} else if (!trinity_uvd_clocks_zero(new_rps)) {\r\ntrinity_setup_uvd_clock_table(rdev, new_rps);\r\nif (trinity_uvd_clocks_zero(old_rps)) {\r\nu32 tmp = RREG32(CG_MISC_REG);\r\ntmp &= 0xfffffffd;\r\nWREG32(CG_MISC_REG, tmp);\r\nradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\r\ntrinity_setup_uvd_dpm_interval(rdev, 3000);\r\n}\r\n}\r\ntrinity_uvd_dpm_config(rdev);\r\n} else {\r\nif (trinity_uvd_clocks_zero(new_rps) ||\r\ntrinity_uvd_clocks_equal(new_rps, old_rps))\r\nreturn;\r\nradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\r\n}\r\nif (pi->enable_gfx_power_gating) {\r\ntrinity_gfx_powergating_enable(rdev, true);\r\n}\r\n}\r\nstatic void trinity_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\r\nstruct trinity_ps *current_ps = trinity_get_ps(new_rps);\r\nif (new_ps->levels[new_ps->num_levels - 1].sclk >=\r\ncurrent_ps->levels[current_ps->num_levels - 1].sclk)\r\nreturn;\r\ntrinity_setup_uvd_clocks(rdev, new_rps, old_rps);\r\n}\r\nstatic void trinity_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\r\nstruct trinity_ps *current_ps = trinity_get_ps(old_rps);\r\nif (new_ps->levels[new_ps->num_levels - 1].sclk <\r\ncurrent_ps->levels[current_ps->num_levels - 1].sclk)\r\nreturn;\r\ntrinity_setup_uvd_clocks(rdev, new_rps, old_rps);\r\n}\r\nstatic void trinity_program_ttt(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 value = RREG32_SMC(SMU_SCLK_DPM_TTT);\r\nvalue &= ~(HT_MASK | LT_MASK);\r\nvalue |= HT((pi->thermal_auto_throttling + 49) * 8);\r\nvalue |= LT((pi->thermal_auto_throttling + 49 - pi->sys_info.htc_hyst_lmt) * 8);\r\nWREG32_SMC(SMU_SCLK_DPM_TTT, value);\r\n}\r\nstatic void trinity_enable_att(struct radeon_device *rdev)\r\n{\r\nu32 value = RREG32_SMC(SMU_SCLK_DPM_TT_CNTL);\r\nvalue &= ~SCLK_TT_EN_MASK;\r\nvalue |= SCLK_TT_EN(1);\r\nWREG32_SMC(SMU_SCLK_DPM_TT_CNTL, value);\r\n}\r\nstatic void trinity_program_sclk_dpm(struct radeon_device *rdev)\r\n{\r\nu32 p, u;\r\nu32 tp = RREG32_SMC(PM_TP);\r\nu32 ni;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nu32 value;\r\nr600_calculate_u_and_p(400, xclk, 16, &p, &u);\r\nni = (p + tp - 1) / tp;\r\nvalue = RREG32_SMC(PM_I_CNTL_1);\r\nvalue &= ~SCLK_DPM_MASK;\r\nvalue |= SCLK_DPM(ni);\r\nWREG32_SMC(PM_I_CNTL_1, value);\r\n}\r\nstatic int trinity_set_thermal_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\nWREG32_P(CG_THERMAL_INT_CTRL, DIG_THERM_INTH(49 + (high_temp / 1000)), ~DIG_THERM_INTH_MASK);\r\nWREG32_P(CG_THERMAL_INT_CTRL, DIG_THERM_INTL(49 + (low_temp / 1000)), ~DIG_THERM_INTL_MASK);\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nstatic void trinity_update_current_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_ps *new_ps = trinity_get_ps(rps);\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\npi->current_rps = *rps;\r\npi->current_ps = *new_ps;\r\npi->current_rps.ps_priv = &pi->current_ps;\r\n}\r\nstatic void trinity_update_requested_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_ps *new_ps = trinity_get_ps(rps);\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\npi->requested_rps = *rps;\r\npi->requested_ps = *new_ps;\r\npi->requested_rps.ps_priv = &pi->requested_ps;\r\n}\r\nvoid trinity_dpm_enable_bapm(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (pi->enable_bapm) {\r\ntrinity_acquire_mutex(rdev);\r\ntrinity_dpm_bapm_enable(rdev, enable);\r\ntrinity_release_mutex(rdev);\r\n}\r\n}\r\nint trinity_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\ntrinity_acquire_mutex(rdev);\r\nif (trinity_dpm_enabled(rdev)) {\r\ntrinity_release_mutex(rdev);\r\nreturn -EINVAL;\r\n}\r\ntrinity_program_bootup_state(rdev);\r\nsumo_program_vc(rdev, 0x00C00033);\r\ntrinity_start_am(rdev);\r\nif (pi->enable_auto_thermal_throttling) {\r\ntrinity_program_ttt(rdev);\r\ntrinity_enable_att(rdev);\r\n}\r\ntrinity_program_sclk_dpm(rdev);\r\ntrinity_start_dpm(rdev);\r\ntrinity_wait_for_dpm_enabled(rdev);\r\ntrinity_dpm_bapm_enable(rdev, false);\r\ntrinity_release_mutex(rdev);\r\ntrinity_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\nreturn 0;\r\n}\r\nint trinity_dpm_late_enable(struct radeon_device *rdev)\r\n{\r\nint ret;\r\ntrinity_acquire_mutex(rdev);\r\ntrinity_enable_clock_power_gating(rdev);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nret = trinity_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret) {\r\ntrinity_release_mutex(rdev);\r\nreturn ret;\r\n}\r\nrdev->irq.dpm_thermal = true;\r\nradeon_irq_set(rdev);\r\n}\r\ntrinity_release_mutex(rdev);\r\nreturn 0;\r\n}\r\nvoid trinity_dpm_disable(struct radeon_device *rdev)\r\n{\r\ntrinity_acquire_mutex(rdev);\r\nif (!trinity_dpm_enabled(rdev)) {\r\ntrinity_release_mutex(rdev);\r\nreturn;\r\n}\r\ntrinity_dpm_bapm_enable(rdev, false);\r\ntrinity_disable_clock_power_gating(rdev);\r\nsumo_clear_vc(rdev);\r\ntrinity_wait_for_level_0(rdev);\r\ntrinity_stop_dpm(rdev);\r\ntrinity_reset_am(rdev);\r\ntrinity_release_mutex(rdev);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\ntrinity_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\n}\r\nstatic void trinity_get_min_sclk_divider(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\npi->min_sclk_did =\r\n(RREG32_SMC(CC_SMU_MISC_FUSES) & MinSClkDid_MASK) >> MinSClkDid_SHIFT;\r\n}\r\nstatic void trinity_setup_nbp_sim(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct trinity_ps *new_ps = trinity_get_ps(rps);\r\nu32 nbpsconfig;\r\nif (pi->sys_info.nb_dpm_enable) {\r\nnbpsconfig = RREG32_SMC(NB_PSTATE_CONFIG);\r\nnbpsconfig &= ~(Dpm0PgNbPsLo_MASK | Dpm0PgNbPsHi_MASK | DpmXNbPsLo_MASK | DpmXNbPsHi_MASK);\r\nnbpsconfig |= (Dpm0PgNbPsLo(new_ps->Dpm0PgNbPsLo) |\r\nDpm0PgNbPsHi(new_ps->Dpm0PgNbPsHi) |\r\nDpmXNbPsLo(new_ps->DpmXNbPsLo) |\r\nDpmXNbPsHi(new_ps->DpmXNbPsHi));\r\nWREG32_SMC(NB_PSTATE_CONFIG, nbpsconfig);\r\n}\r\n}\r\nint trinity_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_ps *rps = &pi->current_rps;\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nint i, ret;\r\nif (ps->num_levels <= 1)\r\nreturn 0;\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\nreturn -EINVAL;\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\nret = trinity_dpm_n_levels_disabled(rdev, ps->num_levels - 1);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nret = trinity_dpm_n_levels_disabled(rdev, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}\r\nint trinity_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *new_ps = &requested_ps;\r\ntrinity_update_requested_ps(rdev, new_ps);\r\ntrinity_apply_state_adjust_rules(rdev,\r\n&pi->requested_rps,\r\n&pi->current_rps);\r\nreturn 0;\r\n}\r\nint trinity_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nstruct radeon_ps *old_ps = &pi->current_rps;\r\ntrinity_acquire_mutex(rdev);\r\nif (pi->enable_dpm) {\r\nif (pi->enable_bapm)\r\ntrinity_dpm_bapm_enable(rdev, rdev->pm.dpm.ac_power);\r\ntrinity_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\ntrinity_enable_power_level_0(rdev);\r\ntrinity_force_level_0(rdev);\r\ntrinity_wait_for_level_0(rdev);\r\ntrinity_setup_nbp_sim(rdev, new_ps);\r\ntrinity_program_power_levels_0_to_n(rdev, new_ps, old_ps);\r\ntrinity_force_level_0(rdev);\r\ntrinity_unforce_levels(rdev);\r\ntrinity_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\n}\r\ntrinity_release_mutex(rdev);\r\nreturn 0;\r\n}\r\nvoid trinity_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\ntrinity_update_current_ps(rdev, new_ps);\r\n}\r\nvoid trinity_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\ntrinity_acquire_mutex(rdev);\r\nsumo_program_sstp(rdev);\r\nsumo_take_smu_control(rdev, true);\r\ntrinity_get_min_sclk_divider(rdev);\r\ntrinity_release_mutex(rdev);\r\n}\r\nvoid trinity_dpm_reset_asic(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\ntrinity_acquire_mutex(rdev);\r\nif (pi->enable_dpm) {\r\ntrinity_enable_power_level_0(rdev);\r\ntrinity_force_level_0(rdev);\r\ntrinity_wait_for_level_0(rdev);\r\ntrinity_program_bootup_state(rdev);\r\ntrinity_force_level_0(rdev);\r\ntrinity_unforce_levels(rdev);\r\n}\r\ntrinity_release_mutex(rdev);\r\n}\r\nstatic u16 trinity_convert_voltage_index_to_value(struct radeon_device *rdev,\r\nu32 vid_2bit)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid_2bit);\r\nu32 svi_mode = (RREG32_SMC(PM_CONFIG) & SVI_Mode) ? 1 : 0;\r\nu32 step = (svi_mode == 0) ? 1250 : 625;\r\nu32 delta = vid_7bit * step + 50;\r\nif (delta > 155000)\r\nreturn 0;\r\nreturn (155000 - delta) / 100;\r\n}\r\nstatic void trinity_patch_boot_state(struct radeon_device *rdev,\r\nstruct trinity_ps *ps)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nps->num_levels = 1;\r\nps->nbps_flags = 0;\r\nps->bapm_flags = 0;\r\nps->levels[0] = pi->boot_pl;\r\n}\r\nstatic u8 trinity_calculate_vce_wm(struct radeon_device *rdev, u32 sclk)\r\n{\r\nif (sclk < 20000)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void trinity_construct_boot_state(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\npi->boot_pl.sclk = pi->sys_info.bootup_sclk;\r\npi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\r\npi->boot_pl.ds_divider_index = 0;\r\npi->boot_pl.ss_divider_index = 0;\r\npi->boot_pl.allow_gnb_slow = 1;\r\npi->boot_pl.force_nbp_state = 0;\r\npi->boot_pl.display_wm = 0;\r\npi->boot_pl.vce_wm = 0;\r\npi->current_ps.num_levels = 1;\r\npi->current_ps.levels[0] = pi->boot_pl;\r\n}\r\nstatic u8 trinity_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\r\nu32 sclk, u32 min_sclk_in_sr)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 i;\r\nu32 temp;\r\nu32 min = (min_sclk_in_sr > TRINITY_MINIMUM_ENGINE_CLOCK) ?\r\nmin_sclk_in_sr : TRINITY_MINIMUM_ENGINE_CLOCK;\r\nif (sclk < min)\r\nreturn 0;\r\nif (!pi->enable_sclk_ds)\r\nreturn 0;\r\nfor (i = TRINITY_MAX_DEEPSLEEP_DIVIDER_ID; ; i--) {\r\ntemp = sclk / sumo_get_sleep_divider_from_id(i);\r\nif (temp >= min || i == 0)\r\nbreak;\r\n}\r\nreturn (u8)i;\r\n}\r\nstatic u32 trinity_get_valid_engine_clock(struct radeon_device *rdev,\r\nu32 lower_limit)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 i;\r\nfor (i = 0; i < pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries; i++) {\r\nif (pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency >= lower_limit)\r\nreturn pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency;\r\n}\r\nif (i == pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries)\r\nDRM_ERROR("engine clock out of range!");\r\nreturn 0;\r\n}\r\nstatic void trinity_patch_thermal_state(struct radeon_device *rdev,\r\nstruct trinity_ps *ps,\r\nstruct trinity_ps *current_ps)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 sclk_in_sr = pi->sys_info.min_sclk;\r\nu32 current_vddc;\r\nu32 current_sclk;\r\nu32 current_index = 0;\r\nif (current_ps) {\r\ncurrent_vddc = current_ps->levels[current_index].vddc_index;\r\ncurrent_sclk = current_ps->levels[current_index].sclk;\r\n} else {\r\ncurrent_vddc = pi->boot_pl.vddc_index;\r\ncurrent_sclk = pi->boot_pl.sclk;\r\n}\r\nps->levels[0].vddc_index = current_vddc;\r\nif (ps->levels[0].sclk > current_sclk)\r\nps->levels[0].sclk = current_sclk;\r\nps->levels[0].ds_divider_index =\r\ntrinity_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, sclk_in_sr);\r\nps->levels[0].ss_divider_index = ps->levels[0].ds_divider_index;\r\nps->levels[0].allow_gnb_slow = 1;\r\nps->levels[0].force_nbp_state = 0;\r\nps->levels[0].display_wm = 0;\r\nps->levels[0].vce_wm =\r\ntrinity_calculate_vce_wm(rdev, ps->levels[0].sclk);\r\n}\r\nstatic u8 trinity_calculate_display_wm(struct radeon_device *rdev,\r\nstruct trinity_ps *ps, u32 index)\r\n{\r\nif (ps == NULL || ps->num_levels <= 1)\r\nreturn 0;\r\nelse if (ps->num_levels == 2) {\r\nif (index == 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n} else {\r\nif (index == 0)\r\nreturn 0;\r\nelse if (ps->levels[index].sclk < 30000)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\n}\r\nstatic u32 trinity_get_uvd_clock_index(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 i = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif ((rps->vclk == pi->sys_info.uvd_clock_table_entries[i].vclk) &&\r\n(rps->dclk == pi->sys_info.uvd_clock_table_entries[i].dclk))\r\nbreak;\r\n}\r\nif (i >= 4) {\r\nDRM_ERROR("UVD clock index not found!\n");\r\ni = 3;\r\n}\r\nreturn i;\r\n}\r\nstatic void trinity_adjust_uvd_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 high_index = 0;\r\nu32 low_index = 0;\r\nif (pi->uvd_dpm && r600_is_uvd_state(rps->class, rps->class2)) {\r\nhigh_index = trinity_get_uvd_clock_index(rdev, rps);\r\nswitch(high_index) {\r\ncase 3:\r\ncase 2:\r\nlow_index = 1;\r\nbreak;\r\ncase 1:\r\ncase 0:\r\ndefault:\r\nlow_index = 0;\r\nbreak;\r\n}\r\nps->vclk_low_divider =\r\npi->sys_info.uvd_clock_table_entries[high_index].vclk_did;\r\nps->dclk_low_divider =\r\npi->sys_info.uvd_clock_table_entries[high_index].dclk_did;\r\nps->vclk_high_divider =\r\npi->sys_info.uvd_clock_table_entries[low_index].vclk_did;\r\nps->dclk_high_divider =\r\npi->sys_info.uvd_clock_table_entries[low_index].dclk_did;\r\n}\r\n}\r\nstatic void trinity_apply_state_adjust_rules(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct trinity_ps *ps = trinity_get_ps(new_rps);\r\nstruct trinity_ps *current_ps = trinity_get_ps(old_rps);\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 min_voltage = 0;\r\nu32 min_sclk = pi->sys_info.min_sclk;\r\nu32 sclk_in_sr = pi->sys_info.min_sclk;\r\nu32 i;\r\nbool force_high;\r\nu32 num_active_displays = rdev->pm.dpm.new_active_crtc_count;\r\nif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nreturn trinity_patch_thermal_state(rdev, ps, current_ps);\r\ntrinity_adjust_uvd_state(rdev, new_rps);\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nif (ps->levels[i].vddc_index < min_voltage)\r\nps->levels[i].vddc_index = min_voltage;\r\nif (ps->levels[i].sclk < min_sclk)\r\nps->levels[i].sclk =\r\ntrinity_get_valid_engine_clock(rdev, min_sclk);\r\nps->levels[i].ds_divider_index =\r\nsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, sclk_in_sr);\r\nps->levels[i].ss_divider_index = ps->levels[i].ds_divider_index;\r\nps->levels[i].allow_gnb_slow = 1;\r\nps->levels[i].force_nbp_state = 0;\r\nps->levels[i].display_wm =\r\ntrinity_calculate_display_wm(rdev, ps, i);\r\nps->levels[i].vce_wm =\r\ntrinity_calculate_vce_wm(rdev, ps->levels[0].sclk);\r\n}\r\nif ((new_rps->class & (ATOM_PPLIB_CLASSIFICATION_HDSTATE | ATOM_PPLIB_CLASSIFICATION_SDSTATE)) ||\r\n((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY))\r\nps->bapm_flags |= TRINITY_POWERSTATE_FLAGS_BAPM_DISABLE;\r\nif (pi->sys_info.nb_dpm_enable) {\r\nps->Dpm0PgNbPsLo = 0x1;\r\nps->Dpm0PgNbPsHi = 0x0;\r\nps->DpmXNbPsLo = 0x2;\r\nps->DpmXNbPsHi = 0x1;\r\nif ((new_rps->class & (ATOM_PPLIB_CLASSIFICATION_HDSTATE | ATOM_PPLIB_CLASSIFICATION_SDSTATE)) ||\r\n((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)) {\r\nforce_high = ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE) ||\r\n((new_rps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE) &&\r\n(pi->sys_info.uma_channel_number == 1)));\r\nforce_high = (num_active_displays >= 3) || force_high;\r\nps->Dpm0PgNbPsLo = force_high ? 0x2 : 0x3;\r\nps->Dpm0PgNbPsHi = 0x1;\r\nps->DpmXNbPsLo = force_high ? 0x2 : 0x3;\r\nps->DpmXNbPsHi = 0x2;\r\nps->levels[ps->num_levels - 1].allow_gnb_slow = 0;\r\n}\r\n}\r\n}\r\nstatic void trinity_cleanup_asic(struct radeon_device *rdev)\r\n{\r\nsumo_take_smu_control(rdev, false);\r\n}\r\nstatic void trinity_add_dccac_value(struct radeon_device *rdev)\r\n{\r\nu32 gpu_cac_avrg_cntl_window_size;\r\nu32 num_active_displays = rdev->pm.dpm.new_active_crtc_count;\r\nu64 disp_clk = rdev->clock.default_dispclk / 100;\r\nu32 dc_cac_value;\r\ngpu_cac_avrg_cntl_window_size =\r\n(RREG32_SMC(GPU_CAC_AVRG_CNTL) & WINDOW_SIZE_MASK) >> WINDOW_SIZE_SHIFT;\r\ndc_cac_value = (u32)((14213 * disp_clk * disp_clk * (u64)num_active_displays) >>\r\n(32 - gpu_cac_avrg_cntl_window_size));\r\nWREG32_SMC(DC_CAC_VALUE, dc_cac_value);\r\n}\r\nvoid trinity_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nif (pi->voltage_drop_in_dce)\r\ntrinity_dce_enable_voltage_adjustment(rdev, true);\r\ntrinity_add_dccac_value(rdev);\r\n}\r\nstatic void trinity_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nrdev->pm.dpm.boot_ps = rps;\r\ntrinity_patch_boot_state(rdev, ps);\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void trinity_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nstruct trinity_pl *pl = &ps->levels[index];\r\nu32 sclk;\r\nsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\r\nsclk |= clock_info->sumo.ucEngineClockHigh << 16;\r\npl->sclk = sclk;\r\npl->vddc_index = clock_info->sumo.vddcIndex;\r\nps->num_levels = index + 1;\r\nif (pi->enable_sclk_ds) {\r\npl->ds_divider_index = 5;\r\npl->ss_divider_index = 5;\r\n}\r\n}\r\nstatic int trinity_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, k, non_clock_array_index, clock_array_index;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nstruct sumo_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\npower_state_offset = (u8 *)state_array->states;\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nu8 *idx;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn -EINVAL;\r\nps = kzalloc(sizeof(struct sumo_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nk = 0;\r\nidx = (u8 *)&power_state->v2.clockInfoIndex[0];\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = idx[j];\r\nif (clock_array_index >= clock_info_array->ucNumEntries)\r\ncontinue;\r\nif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\r\nbreak;\r\nclock_info = (union pplib_clock_info *)\r\n((u8 *)&clock_info_array->clockInfo[0] +\r\n(clock_array_index * clock_info_array->ucEntrySize));\r\ntrinity_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], k,\r\nclock_info);\r\nk++;\r\n}\r\ntrinity_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info,\r\nnon_clock_info_array->ucEntrySize);\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nrdev->pm.dpm.num_ps = state_array->ucNumEntries;\r\nreturn 0;\r\n}\r\nstatic u32 trinity_convert_did_to_freq(struct radeon_device *rdev, u8 did)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nu32 divider;\r\nif (did >= 8 && did <= 0x3f)\r\ndivider = did * 25;\r\nelse if (did > 0x3f && did <= 0x5f)\r\ndivider = (did - 64) * 50 + 1600;\r\nelse if (did > 0x5f && did <= 0x7e)\r\ndivider = (did - 96) * 100 + 3200;\r\nelse if (did == 0x7f)\r\ndivider = 128 * 100;\r\nelse\r\nreturn 10000;\r\nreturn ((pi->sys_info.dentist_vco_freq * 100) + (divider - 1)) / divider;\r\n}\r\nstatic int trinity_parse_sys_info_table(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\r\nunion igp_info *igp_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nint i;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nigp_info = (union igp_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nif (crev != 7) {\r\nDRM_ERROR("Unsupported IGP table: %d %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\npi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_7.ulBootUpEngineClock);\r\npi->sys_info.min_sclk = le32_to_cpu(igp_info->info_7.ulMinEngineClock);\r\npi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_7.ulBootUpUMAClock);\r\npi->sys_info.dentist_vco_freq = le32_to_cpu(igp_info->info_7.ulDentistVCOFreq);\r\npi->sys_info.bootup_nb_voltage_index =\r\nle16_to_cpu(igp_info->info_7.usBootUpNBVoltage);\r\nif (igp_info->info_7.ucHtcTmpLmt == 0)\r\npi->sys_info.htc_tmp_lmt = 203;\r\nelse\r\npi->sys_info.htc_tmp_lmt = igp_info->info_7.ucHtcTmpLmt;\r\nif (igp_info->info_7.ucHtcHystLmt == 0)\r\npi->sys_info.htc_hyst_lmt = 5;\r\nelse\r\npi->sys_info.htc_hyst_lmt = igp_info->info_7.ucHtcHystLmt;\r\nif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\r\nDRM_ERROR("The htcTmpLmt should be larger than htcHystLmt.\n");\r\n}\r\nif (pi->enable_nbps_policy)\r\npi->sys_info.nb_dpm_enable = igp_info->info_7.ucNBDPMEnable;\r\nelse\r\npi->sys_info.nb_dpm_enable = 0;\r\nfor (i = 0; i < TRINITY_NUM_NBPSTATES; i++) {\r\npi->sys_info.nbp_mclk[i] = le32_to_cpu(igp_info->info_7.ulNbpStateMemclkFreq[i]);\r\npi->sys_info.nbp_nclk[i] = le32_to_cpu(igp_info->info_7.ulNbpStateNClkFreq[i]);\r\n}\r\npi->sys_info.nbp_voltage_index[0] = le16_to_cpu(igp_info->info_7.usNBP0Voltage);\r\npi->sys_info.nbp_voltage_index[1] = le16_to_cpu(igp_info->info_7.usNBP1Voltage);\r\npi->sys_info.nbp_voltage_index[2] = le16_to_cpu(igp_info->info_7.usNBP2Voltage);\r\npi->sys_info.nbp_voltage_index[3] = le16_to_cpu(igp_info->info_7.usNBP3Voltage);\r\nif (!pi->sys_info.nb_dpm_enable) {\r\nfor (i = 1; i < TRINITY_NUM_NBPSTATES; i++) {\r\npi->sys_info.nbp_mclk[i] = pi->sys_info.nbp_mclk[0];\r\npi->sys_info.nbp_nclk[i] = pi->sys_info.nbp_nclk[0];\r\npi->sys_info.nbp_voltage_index[i] = pi->sys_info.nbp_voltage_index[0];\r\n}\r\n}\r\npi->sys_info.uma_channel_number = igp_info->info_7.ucUMAChannelNumber;\r\nsumo_construct_sclk_voltage_mapping_table(rdev,\r\n&pi->sys_info.sclk_voltage_mapping_table,\r\nigp_info->info_7.sAvail_SCLK);\r\nsumo_construct_vid_mapping_table(rdev, &pi->sys_info.vid_mapping_table,\r\nigp_info->info_7.sAvail_SCLK);\r\npi->sys_info.uvd_clock_table_entries[0].vclk_did =\r\nigp_info->info_7.ucDPMState0VclkFid;\r\npi->sys_info.uvd_clock_table_entries[1].vclk_did =\r\nigp_info->info_7.ucDPMState1VclkFid;\r\npi->sys_info.uvd_clock_table_entries[2].vclk_did =\r\nigp_info->info_7.ucDPMState2VclkFid;\r\npi->sys_info.uvd_clock_table_entries[3].vclk_did =\r\nigp_info->info_7.ucDPMState3VclkFid;\r\npi->sys_info.uvd_clock_table_entries[0].dclk_did =\r\nigp_info->info_7.ucDPMState0DclkFid;\r\npi->sys_info.uvd_clock_table_entries[1].dclk_did =\r\nigp_info->info_7.ucDPMState1DclkFid;\r\npi->sys_info.uvd_clock_table_entries[2].dclk_did =\r\nigp_info->info_7.ucDPMState2DclkFid;\r\npi->sys_info.uvd_clock_table_entries[3].dclk_did =\r\nigp_info->info_7.ucDPMState3DclkFid;\r\nfor (i = 0; i < 4; i++) {\r\npi->sys_info.uvd_clock_table_entries[i].vclk =\r\ntrinity_convert_did_to_freq(rdev,\r\npi->sys_info.uvd_clock_table_entries[i].vclk_did);\r\npi->sys_info.uvd_clock_table_entries[i].dclk =\r\ntrinity_convert_did_to_freq(rdev,\r\npi->sys_info.uvd_clock_table_entries[i].dclk_did);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint trinity_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct trinity_power_info *pi;\r\nint ret, i;\r\npi = kzalloc(sizeof(struct trinity_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\nfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++)\r\npi->at[i] = TRINITY_AT_DFLT;\r\nif (radeon_bapm == -1) {\r\nif (rdev->pdev->subsystem_vendor == 0x1462)\r\npi->enable_bapm = true;\r\nelse\r\npi->enable_bapm = false;\r\n} else if (radeon_bapm == 0) {\r\npi->enable_bapm = false;\r\n} else {\r\npi->enable_bapm = true;\r\n}\r\npi->enable_nbps_policy = true;\r\npi->enable_sclk_ds = true;\r\npi->enable_gfx_power_gating = true;\r\npi->enable_gfx_clock_gating = true;\r\npi->enable_mg_clock_gating = false;\r\npi->enable_gfx_dynamic_mgpg = false;\r\npi->override_dynamic_mgpg = false;\r\npi->enable_auto_thermal_throttling = true;\r\npi->voltage_drop_in_dce = false;\r\npi->uvd_dpm = true;\r\nret = trinity_parse_sys_info_table(rdev);\r\nif (ret)\r\nreturn ret;\r\ntrinity_construct_boot_state(rdev);\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = trinity_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\npi->thermal_auto_throttling = pi->sys_info.htc_tmp_lmt;\r\npi->enable_dpm = true;\r\nreturn 0;\r\n}\r\nvoid trinity_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nint i;\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nstruct trinity_pl *pl = &ps->levels[i];\r\nprintk("\t\tpower level %d sclk: %u vddc: %u\n",\r\ni, pl->sclk,\r\ntrinity_convert_voltage_index_to_value(rdev, pl->vddc_index));\r\n}\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nvoid trinity_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct radeon_ps *rps = &pi->current_rps;\r\nstruct trinity_ps *ps = trinity_get_ps(rps);\r\nstruct trinity_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) >>\r\nCURRENT_STATE_SHIFT;\r\nif (current_index >= ps->num_levels) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\npl = &ps->levels[current_index];\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nseq_printf(m, "power level %d sclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk,\r\ntrinity_convert_voltage_index_to_value(rdev, pl->vddc_index));\r\n}\r\n}\r\nvoid trinity_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\ntrinity_cleanup_asic(rdev);\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\n}\r\nu32 trinity_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nstruct trinity_ps *requested_state = trinity_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->levels[0].sclk;\r\nelse\r\nreturn requested_state->levels[requested_state->num_levels - 1].sclk;\r\n}\r\nu32 trinity_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct trinity_power_info *pi = trinity_get_pi(rdev);\r\nreturn pi->sys_info.bootup_uma_clk;\r\n}
