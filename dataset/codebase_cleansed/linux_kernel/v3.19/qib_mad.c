static int reply(struct ib_smp *smp)\r\n{\r\nsmp->method = IB_MGMT_METHOD_GET_RESP;\r\nif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\r\nsmp->status |= IB_SMP_DIRECTION;\r\nreturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\r\n}\r\nstatic int reply_failure(struct ib_smp *smp)\r\n{\r\nsmp->method = IB_MGMT_METHOD_GET_RESP;\r\nif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\r\nsmp->status |= IB_SMP_DIRECTION;\r\nreturn IB_MAD_RESULT_FAILURE | IB_MAD_RESULT_REPLY;\r\n}\r\nstatic void qib_send_trap(struct qib_ibport *ibp, void *data, unsigned len)\r\n{\r\nstruct ib_mad_send_buf *send_buf;\r\nstruct ib_mad_agent *agent;\r\nstruct ib_smp *smp;\r\nint ret;\r\nunsigned long flags;\r\nunsigned long timeout;\r\nagent = ibp->send_agent;\r\nif (!agent)\r\nreturn;\r\nif (!(ppd_from_ibp(ibp)->lflags & QIBL_LINKACTIVE))\r\nreturn;\r\nif (ibp->trap_timeout && time_before(jiffies, ibp->trap_timeout))\r\nreturn;\r\nsend_buf = ib_create_send_mad(agent, 0, 0, 0, IB_MGMT_MAD_HDR,\r\nIB_MGMT_MAD_DATA, GFP_ATOMIC);\r\nif (IS_ERR(send_buf))\r\nreturn;\r\nsmp = send_buf->mad;\r\nsmp->base_version = IB_MGMT_BASE_VERSION;\r\nsmp->mgmt_class = IB_MGMT_CLASS_SUBN_LID_ROUTED;\r\nsmp->class_version = 1;\r\nsmp->method = IB_MGMT_METHOD_TRAP;\r\nibp->tid++;\r\nsmp->tid = cpu_to_be64(ibp->tid);\r\nsmp->attr_id = IB_SMP_ATTR_NOTICE;\r\nmemcpy(smp->data, data, len);\r\nspin_lock_irqsave(&ibp->lock, flags);\r\nif (!ibp->sm_ah) {\r\nif (ibp->sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {\r\nstruct ib_ah *ah;\r\nah = qib_create_qp0_ah(ibp, ibp->sm_lid);\r\nif (IS_ERR(ah))\r\nret = PTR_ERR(ah);\r\nelse {\r\nsend_buf->ah = ah;\r\nibp->sm_ah = to_iah(ah);\r\nret = 0;\r\n}\r\n} else\r\nret = -EINVAL;\r\n} else {\r\nsend_buf->ah = &ibp->sm_ah->ibah;\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nif (!ret)\r\nret = ib_post_send_mad(send_buf, NULL);\r\nif (!ret) {\r\ntimeout = (4096 * (1UL << ibp->subnet_timeout)) / 1000;\r\nibp->trap_timeout = jiffies + usecs_to_jiffies(timeout);\r\n} else {\r\nib_free_send_mad(send_buf);\r\nibp->trap_timeout = 0;\r\n}\r\n}\r\nvoid qib_bad_pqkey(struct qib_ibport *ibp, __be16 trap_num, u32 key, u32 sl,\r\nu32 qp1, u32 qp2, __be16 lid1, __be16 lid2)\r\n{\r\nstruct ib_mad_notice_attr data;\r\nif (trap_num == IB_NOTICE_TRAP_BAD_PKEY)\r\nibp->pkey_violations++;\r\nelse\r\nibp->qkey_violations++;\r\nibp->n_pkt_drops++;\r\ndata.generic_type = IB_NOTICE_TYPE_SECURITY;\r\ndata.prod_type_msb = 0;\r\ndata.prod_type_lsb = IB_NOTICE_PROD_CA;\r\ndata.trap_num = trap_num;\r\ndata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\r\ndata.toggle_count = 0;\r\nmemset(&data.details, 0, sizeof data.details);\r\ndata.details.ntc_257_258.lid1 = lid1;\r\ndata.details.ntc_257_258.lid2 = lid2;\r\ndata.details.ntc_257_258.key = cpu_to_be32(key);\r\ndata.details.ntc_257_258.sl_qp1 = cpu_to_be32((sl << 28) | qp1);\r\ndata.details.ntc_257_258.qp2 = cpu_to_be32(qp2);\r\nqib_send_trap(ibp, &data, sizeof data);\r\n}\r\nstatic void qib_bad_mkey(struct qib_ibport *ibp, struct ib_smp *smp)\r\n{\r\nstruct ib_mad_notice_attr data;\r\ndata.generic_type = IB_NOTICE_TYPE_SECURITY;\r\ndata.prod_type_msb = 0;\r\ndata.prod_type_lsb = IB_NOTICE_PROD_CA;\r\ndata.trap_num = IB_NOTICE_TRAP_BAD_MKEY;\r\ndata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\r\ndata.toggle_count = 0;\r\nmemset(&data.details, 0, sizeof data.details);\r\ndata.details.ntc_256.lid = data.issuer_lid;\r\ndata.details.ntc_256.method = smp->method;\r\ndata.details.ntc_256.attr_id = smp->attr_id;\r\ndata.details.ntc_256.attr_mod = smp->attr_mod;\r\ndata.details.ntc_256.mkey = smp->mkey;\r\nif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) {\r\nu8 hop_cnt;\r\ndata.details.ntc_256.dr_slid = smp->dr_slid;\r\ndata.details.ntc_256.dr_trunc_hop = IB_NOTICE_TRAP_DR_NOTICE;\r\nhop_cnt = smp->hop_cnt;\r\nif (hop_cnt > ARRAY_SIZE(data.details.ntc_256.dr_rtn_path)) {\r\ndata.details.ntc_256.dr_trunc_hop |=\r\nIB_NOTICE_TRAP_DR_TRUNC;\r\nhop_cnt = ARRAY_SIZE(data.details.ntc_256.dr_rtn_path);\r\n}\r\ndata.details.ntc_256.dr_trunc_hop |= hop_cnt;\r\nmemcpy(data.details.ntc_256.dr_rtn_path, smp->return_path,\r\nhop_cnt);\r\n}\r\nqib_send_trap(ibp, &data, sizeof data);\r\n}\r\nvoid qib_cap_mask_chg(struct qib_ibport *ibp)\r\n{\r\nstruct ib_mad_notice_attr data;\r\ndata.generic_type = IB_NOTICE_TYPE_INFO;\r\ndata.prod_type_msb = 0;\r\ndata.prod_type_lsb = IB_NOTICE_PROD_CA;\r\ndata.trap_num = IB_NOTICE_TRAP_CAP_MASK_CHG;\r\ndata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\r\ndata.toggle_count = 0;\r\nmemset(&data.details, 0, sizeof data.details);\r\ndata.details.ntc_144.lid = data.issuer_lid;\r\ndata.details.ntc_144.new_cap_mask = cpu_to_be32(ibp->port_cap_flags);\r\nqib_send_trap(ibp, &data, sizeof data);\r\n}\r\nvoid qib_sys_guid_chg(struct qib_ibport *ibp)\r\n{\r\nstruct ib_mad_notice_attr data;\r\ndata.generic_type = IB_NOTICE_TYPE_INFO;\r\ndata.prod_type_msb = 0;\r\ndata.prod_type_lsb = IB_NOTICE_PROD_CA;\r\ndata.trap_num = IB_NOTICE_TRAP_SYS_GUID_CHG;\r\ndata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\r\ndata.toggle_count = 0;\r\nmemset(&data.details, 0, sizeof data.details);\r\ndata.details.ntc_145.lid = data.issuer_lid;\r\ndata.details.ntc_145.new_sys_guid = ib_qib_sys_image_guid;\r\nqib_send_trap(ibp, &data, sizeof data);\r\n}\r\nvoid qib_node_desc_chg(struct qib_ibport *ibp)\r\n{\r\nstruct ib_mad_notice_attr data;\r\ndata.generic_type = IB_NOTICE_TYPE_INFO;\r\ndata.prod_type_msb = 0;\r\ndata.prod_type_lsb = IB_NOTICE_PROD_CA;\r\ndata.trap_num = IB_NOTICE_TRAP_CAP_MASK_CHG;\r\ndata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\r\ndata.toggle_count = 0;\r\nmemset(&data.details, 0, sizeof data.details);\r\ndata.details.ntc_144.lid = data.issuer_lid;\r\ndata.details.ntc_144.local_changes = 1;\r\ndata.details.ntc_144.change_flags = IB_NOTICE_TRAP_NODE_DESC_CHG;\r\nqib_send_trap(ibp, &data, sizeof data);\r\n}\r\nstatic int subn_get_nodedescription(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nif (smp->attr_mod)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nmemcpy(smp->data, ibdev->node_desc, sizeof(smp->data));\r\nreturn reply(smp);\r\n}\r\nstatic int subn_get_nodeinfo(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct ib_node_info *nip = (struct ib_node_info *)&smp->data;\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nu32 vendor, majrev, minrev;\r\nunsigned pidx = port - 1;\r\nif (smp->attr_mod || pidx >= dd->num_pports ||\r\ndd->pport[pidx].guid == 0)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse\r\nnip->port_guid = dd->pport[pidx].guid;\r\nnip->base_version = 1;\r\nnip->class_version = 1;\r\nnip->node_type = 1;\r\nnip->num_ports = ibdev->phys_port_cnt;\r\nnip->sys_guid = ib_qib_sys_image_guid;\r\nnip->node_guid = dd->pport->guid;\r\nnip->partition_cap = cpu_to_be16(qib_get_npkeys(dd));\r\nnip->device_id = cpu_to_be16(dd->deviceid);\r\nmajrev = dd->majrev;\r\nminrev = dd->minrev;\r\nnip->revision = cpu_to_be32((majrev << 16) | minrev);\r\nnip->local_port_num = port;\r\nvendor = dd->vendorid;\r\nnip->vendor_id[0] = QIB_SRC_OUI_1;\r\nnip->vendor_id[1] = QIB_SRC_OUI_2;\r\nnip->vendor_id[2] = QIB_SRC_OUI_3;\r\nreturn reply(smp);\r\n}\r\nstatic int subn_get_guidinfo(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nu32 startgx = 8 * be32_to_cpu(smp->attr_mod);\r\n__be64 *p = (__be64 *) smp->data;\r\nunsigned pidx = port - 1;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (startgx == 0 && pidx < dd->num_pports) {\r\nstruct qib_pportdata *ppd = dd->pport + pidx;\r\nstruct qib_ibport *ibp = &ppd->ibport_data;\r\n__be64 g = ppd->guid;\r\nunsigned i;\r\nif (g == 0)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse {\r\np[0] = g;\r\nfor (i = 1; i < QIB_GUIDS_PER_PORT; i++)\r\np[i] = ibp->guids[i - 1];\r\n}\r\n} else\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn reply(smp);\r\n}\r\nstatic void set_link_width_enabled(struct qib_pportdata *ppd, u32 w)\r\n{\r\n(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LWID_ENB, w);\r\n}\r\nstatic void set_link_speed_enabled(struct qib_pportdata *ppd, u32 s)\r\n{\r\n(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_SPD_ENB, s);\r\n}\r\nstatic int get_overrunthreshold(struct qib_pportdata *ppd)\r\n{\r\nreturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_OVERRUN_THRESH);\r\n}\r\nstatic int set_overrunthreshold(struct qib_pportdata *ppd, unsigned n)\r\n{\r\n(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_OVERRUN_THRESH,\r\n(u32)n);\r\nreturn 0;\r\n}\r\nstatic int get_phyerrthreshold(struct qib_pportdata *ppd)\r\n{\r\nreturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_PHYERR_THRESH);\r\n}\r\nstatic int set_phyerrthreshold(struct qib_pportdata *ppd, unsigned n)\r\n{\r\n(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PHYERR_THRESH,\r\n(u32)n);\r\nreturn 0;\r\n}\r\nstatic int get_linkdowndefaultstate(struct qib_pportdata *ppd)\r\n{\r\nreturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT) ==\r\nIB_LINKINITCMD_SLEEP;\r\n}\r\nstatic int check_mkey(struct qib_ibport *ibp, struct ib_smp *smp, int mad_flags)\r\n{\r\nint valid_mkey = 0;\r\nint ret = 0;\r\nif (ibp->mkey_lease_timeout &&\r\ntime_after_eq(jiffies, ibp->mkey_lease_timeout)) {\r\nibp->mkey_lease_timeout = 0;\r\nibp->mkeyprot = 0;\r\n}\r\nif ((mad_flags & IB_MAD_IGNORE_MKEY) || ibp->mkey == 0 ||\r\nibp->mkey == smp->mkey)\r\nvalid_mkey = 1;\r\nif (valid_mkey && ibp->mkey_lease_timeout &&\r\n(smp->method == IB_MGMT_METHOD_GET ||\r\nsmp->method == IB_MGMT_METHOD_SET ||\r\nsmp->method == IB_MGMT_METHOD_TRAP_REPRESS))\r\nibp->mkey_lease_timeout = 0;\r\nif (!valid_mkey) {\r\nswitch (smp->method) {\r\ncase IB_MGMT_METHOD_GET:\r\nif (ibp->mkeyprot < 2)\r\nbreak;\r\ncase IB_MGMT_METHOD_SET:\r\ncase IB_MGMT_METHOD_TRAP_REPRESS:\r\nif (ibp->mkey_violations != 0xFFFF)\r\n++ibp->mkey_violations;\r\nif (!ibp->mkey_lease_timeout && ibp->mkey_lease_period)\r\nibp->mkey_lease_timeout = jiffies +\r\nibp->mkey_lease_period * HZ;\r\nqib_bad_mkey(ibp, smp);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int subn_get_portinfo(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct qib_devdata *dd;\r\nstruct qib_pportdata *ppd;\r\nstruct qib_ibport *ibp;\r\nstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\r\nu8 mtu;\r\nint ret;\r\nu32 state;\r\nu32 port_num = be32_to_cpu(smp->attr_mod);\r\nif (port_num == 0)\r\nport_num = port;\r\nelse {\r\nif (port_num > ibdev->phys_port_cnt) {\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\nif (port_num != port) {\r\nibp = to_iport(ibdev, port_num);\r\nret = check_mkey(ibp, smp, 0);\r\nif (ret) {\r\nret = IB_MAD_RESULT_FAILURE;\r\ngoto bail;\r\n}\r\n}\r\n}\r\ndd = dd_from_ibdev(ibdev);\r\nppd = dd->pport + (port_num - 1);\r\nibp = &ppd->ibport_data;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (!(smp->method == IB_MGMT_METHOD_GET &&\r\nibp->mkey != smp->mkey &&\r\nibp->mkeyprot == 1))\r\npip->mkey = ibp->mkey;\r\npip->gid_prefix = ibp->gid_prefix;\r\npip->lid = cpu_to_be16(ppd->lid);\r\npip->sm_lid = cpu_to_be16(ibp->sm_lid);\r\npip->cap_mask = cpu_to_be32(ibp->port_cap_flags);\r\npip->mkey_lease_period = cpu_to_be16(ibp->mkey_lease_period);\r\npip->local_port_num = port;\r\npip->link_width_enabled = ppd->link_width_enabled;\r\npip->link_width_supported = ppd->link_width_supported;\r\npip->link_width_active = ppd->link_width_active;\r\nstate = dd->f_iblink_state(ppd->lastibcstat);\r\npip->linkspeed_portstate = ppd->link_speed_supported << 4 | state;\r\npip->portphysstate_linkdown =\r\n(dd->f_ibphys_portstate(ppd->lastibcstat) << 4) |\r\n(get_linkdowndefaultstate(ppd) ? 1 : 2);\r\npip->mkeyprot_resv_lmc = (ibp->mkeyprot << 6) | ppd->lmc;\r\npip->linkspeedactive_enabled = (ppd->link_speed_active << 4) |\r\nppd->link_speed_enabled;\r\nswitch (ppd->ibmtu) {\r\ndefault:\r\ncase 4096:\r\nmtu = IB_MTU_4096;\r\nbreak;\r\ncase 2048:\r\nmtu = IB_MTU_2048;\r\nbreak;\r\ncase 1024:\r\nmtu = IB_MTU_1024;\r\nbreak;\r\ncase 512:\r\nmtu = IB_MTU_512;\r\nbreak;\r\ncase 256:\r\nmtu = IB_MTU_256;\r\nbreak;\r\n}\r\npip->neighbormtu_mastersmsl = (mtu << 4) | ibp->sm_sl;\r\npip->vlcap_inittype = ppd->vls_supported << 4;\r\npip->vl_high_limit = ibp->vl_high_limit;\r\npip->vl_arb_high_cap =\r\ndd->f_get_ib_cfg(ppd, QIB_IB_CFG_VL_HIGH_CAP);\r\npip->vl_arb_low_cap =\r\ndd->f_get_ib_cfg(ppd, QIB_IB_CFG_VL_LOW_CAP);\r\npip->inittypereply_mtucap = qib_ibmtu ? qib_ibmtu : IB_MTU_4096;\r\npip->operationalvl_pei_peo_fpi_fpo =\r\ndd->f_get_ib_cfg(ppd, QIB_IB_CFG_OP_VLS) << 4;\r\npip->mkey_violations = cpu_to_be16(ibp->mkey_violations);\r\npip->pkey_violations = cpu_to_be16(ibp->pkey_violations);\r\npip->qkey_violations = cpu_to_be16(ibp->qkey_violations);\r\npip->guid_cap = QIB_GUIDS_PER_PORT;\r\npip->clientrereg_resv_subnetto = ibp->subnet_timeout;\r\npip->resv_resptimevalue = 3;\r\npip->localphyerrors_overrunerrors =\r\n(get_phyerrthreshold(ppd) << 4) |\r\nget_overrunthreshold(ppd);\r\nif (ibp->port_cap_flags & IB_PORT_LINK_LATENCY_SUP) {\r\nu32 v;\r\nv = dd->f_get_ib_cfg(ppd, QIB_IB_CFG_LINKLATENCY);\r\npip->link_roundtrip_latency[0] = v >> 16;\r\npip->link_roundtrip_latency[1] = v >> 8;\r\npip->link_roundtrip_latency[2] = v;\r\n}\r\nret = reply(smp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int get_pkeys(struct qib_devdata *dd, u8 port, u16 *pkeys)\r\n{\r\nstruct qib_pportdata *ppd = dd->pport + port - 1;\r\nstruct qib_ctxtdata *rcd = dd->rcd[ppd->hw_pidx];\r\nmemcpy(pkeys, rcd->pkeys, sizeof(rcd->pkeys));\r\nreturn 0;\r\n}\r\nstatic int subn_get_pkeytable(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\r\nu16 *p = (u16 *) smp->data;\r\n__be16 *q = (__be16 *) smp->data;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (startpx == 0) {\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nunsigned i, n = qib_get_npkeys(dd);\r\nget_pkeys(dd, port, p);\r\nfor (i = 0; i < n; i++)\r\nq[i] = cpu_to_be16(p[i]);\r\n} else\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn reply(smp);\r\n}\r\nstatic int subn_set_guidinfo(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nu32 startgx = 8 * be32_to_cpu(smp->attr_mod);\r\n__be64 *p = (__be64 *) smp->data;\r\nunsigned pidx = port - 1;\r\nif (startgx == 0 && pidx < dd->num_pports) {\r\nstruct qib_pportdata *ppd = dd->pport + pidx;\r\nstruct qib_ibport *ibp = &ppd->ibport_data;\r\nunsigned i;\r\nfor (i = 1; i < QIB_GUIDS_PER_PORT; i++)\r\nibp->guids[i - 1] = p[i];\r\n} else\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn subn_get_guidinfo(smp, ibdev, port);\r\n}\r\nstatic int subn_set_portinfo(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\r\nstruct ib_event event;\r\nstruct qib_devdata *dd;\r\nstruct qib_pportdata *ppd;\r\nstruct qib_ibport *ibp;\r\nu8 clientrereg = (pip->clientrereg_resv_subnetto & 0x80);\r\nunsigned long flags;\r\nu16 lid, smlid;\r\nu8 lwe;\r\nu8 lse;\r\nu8 state;\r\nu8 vls;\r\nu8 msl;\r\nu16 lstate;\r\nint ret, ore, mtu;\r\nu32 port_num = be32_to_cpu(smp->attr_mod);\r\nif (port_num == 0)\r\nport_num = port;\r\nelse {\r\nif (port_num > ibdev->phys_port_cnt)\r\ngoto err;\r\nif (port_num != port)\r\ngoto get_only;\r\n}\r\ndd = dd_from_ibdev(ibdev);\r\nppd = dd->pport + (port_num - 1);\r\nibp = &ppd->ibport_data;\r\nevent.device = ibdev;\r\nevent.element.port_num = port;\r\nibp->mkey = pip->mkey;\r\nibp->gid_prefix = pip->gid_prefix;\r\nibp->mkey_lease_period = be16_to_cpu(pip->mkey_lease_period);\r\nlid = be16_to_cpu(pip->lid);\r\nif (lid == 0 || lid >= QIB_MULTICAST_LID_BASE)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse if (ppd->lid != lid || ppd->lmc != (pip->mkeyprot_resv_lmc & 7)) {\r\nif (ppd->lid != lid)\r\nqib_set_uevent_bits(ppd, _QIB_EVENT_LID_CHANGE_BIT);\r\nif (ppd->lmc != (pip->mkeyprot_resv_lmc & 7))\r\nqib_set_uevent_bits(ppd, _QIB_EVENT_LMC_CHANGE_BIT);\r\nqib_set_lid(ppd, lid, pip->mkeyprot_resv_lmc & 7);\r\nevent.event = IB_EVENT_LID_CHANGE;\r\nib_dispatch_event(&event);\r\n}\r\nsmlid = be16_to_cpu(pip->sm_lid);\r\nmsl = pip->neighbormtu_mastersmsl & 0xF;\r\nif (smlid == 0 || smlid >= QIB_MULTICAST_LID_BASE)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse if (smlid != ibp->sm_lid || msl != ibp->sm_sl) {\r\nspin_lock_irqsave(&ibp->lock, flags);\r\nif (ibp->sm_ah) {\r\nif (smlid != ibp->sm_lid)\r\nibp->sm_ah->attr.dlid = smlid;\r\nif (msl != ibp->sm_sl)\r\nibp->sm_ah->attr.sl = msl;\r\n}\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nif (smlid != ibp->sm_lid)\r\nibp->sm_lid = smlid;\r\nif (msl != ibp->sm_sl)\r\nibp->sm_sl = msl;\r\nevent.event = IB_EVENT_SM_CHANGE;\r\nib_dispatch_event(&event);\r\n}\r\nlwe = pip->link_width_enabled;\r\nif (lwe) {\r\nif (lwe == 0xFF)\r\nset_link_width_enabled(ppd, ppd->link_width_supported);\r\nelse if (lwe >= 16 || (lwe & ~ppd->link_width_supported))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse if (lwe != ppd->link_width_enabled)\r\nset_link_width_enabled(ppd, lwe);\r\n}\r\nlse = pip->linkspeedactive_enabled & 0xF;\r\nif (lse) {\r\nif (lse == 15)\r\nset_link_speed_enabled(ppd,\r\nppd->link_speed_supported);\r\nelse if (lse >= 8 || (lse & ~ppd->link_speed_supported))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse if (lse != ppd->link_speed_enabled)\r\nset_link_speed_enabled(ppd, lse);\r\n}\r\nswitch (pip->portphysstate_linkdown & 0xF) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\n(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT,\r\nIB_LINKINITCMD_SLEEP);\r\nbreak;\r\ncase 2:\r\n(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT,\r\nIB_LINKINITCMD_POLL);\r\nbreak;\r\ndefault:\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\n}\r\nibp->mkeyprot = pip->mkeyprot_resv_lmc >> 6;\r\nibp->vl_high_limit = pip->vl_high_limit;\r\n(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_VL_HIGH_LIMIT,\r\nibp->vl_high_limit);\r\nmtu = ib_mtu_enum_to_int((pip->neighbormtu_mastersmsl >> 4) & 0xF);\r\nif (mtu == -1)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse\r\nqib_set_mtu(ppd, mtu);\r\nvls = (pip->operationalvl_pei_peo_fpi_fpo >> 4) & 0xF;\r\nif (vls) {\r\nif (vls > ppd->vls_supported)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse\r\n(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_OP_VLS, vls);\r\n}\r\nif (pip->mkey_violations == 0)\r\nibp->mkey_violations = 0;\r\nif (pip->pkey_violations == 0)\r\nibp->pkey_violations = 0;\r\nif (pip->qkey_violations == 0)\r\nibp->qkey_violations = 0;\r\nore = pip->localphyerrors_overrunerrors;\r\nif (set_phyerrthreshold(ppd, (ore >> 4) & 0xF))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nif (set_overrunthreshold(ppd, (ore & 0xF)))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nibp->subnet_timeout = pip->clientrereg_resv_subnetto & 0x1F;\r\nstate = pip->linkspeed_portstate & 0xF;\r\nlstate = (pip->portphysstate_linkdown >> 4) & 0xF;\r\nif (lstate && !(state == IB_PORT_DOWN || state == IB_PORT_NOP))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nswitch (state) {\r\ncase IB_PORT_NOP:\r\nif (lstate == 0)\r\nbreak;\r\ncase IB_PORT_DOWN:\r\nif (lstate == 0)\r\nlstate = QIB_IB_LINKDOWN_ONLY;\r\nelse if (lstate == 1)\r\nlstate = QIB_IB_LINKDOWN_SLEEP;\r\nelse if (lstate == 2)\r\nlstate = QIB_IB_LINKDOWN;\r\nelse if (lstate == 3)\r\nlstate = QIB_IB_LINKDOWN_DISABLE;\r\nelse {\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_LINKV;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nqib_set_linkstate(ppd, lstate);\r\nif (lstate == QIB_IB_LINKDOWN_DISABLE && smp->hop_cnt) {\r\nret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\r\ngoto done;\r\n}\r\nqib_wait_linkstate(ppd, QIBL_LINKV, 10);\r\nbreak;\r\ncase IB_PORT_ARMED:\r\nqib_set_linkstate(ppd, QIB_IB_LINKARM);\r\nbreak;\r\ncase IB_PORT_ACTIVE:\r\nqib_set_linkstate(ppd, QIB_IB_LINKACTIVE);\r\nbreak;\r\ndefault:\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\n}\r\nif (clientrereg) {\r\nevent.event = IB_EVENT_CLIENT_REREGISTER;\r\nib_dispatch_event(&event);\r\n}\r\nret = subn_get_portinfo(smp, ibdev, port);\r\npip->clientrereg_resv_subnetto |= clientrereg;\r\ngoto get_only;\r\nerr:\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nget_only:\r\nret = subn_get_portinfo(smp, ibdev, port);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int rm_pkey(struct qib_pportdata *ppd, u16 key)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\r\nif (ppd->pkeys[i] != key)\r\ncontinue;\r\nif (atomic_dec_and_test(&ppd->pkeyrefs[i])) {\r\nppd->pkeys[i] = 0;\r\nret = 1;\r\ngoto bail;\r\n}\r\nbreak;\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int add_pkey(struct qib_pportdata *ppd, u16 key)\r\n{\r\nint i;\r\nu16 lkey = key & 0x7FFF;\r\nint any = 0;\r\nint ret;\r\nif (lkey == 0x7FFF) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\r\nif (!ppd->pkeys[i]) {\r\nany++;\r\ncontinue;\r\n}\r\nif (ppd->pkeys[i] == key) {\r\nif (atomic_inc_return(&ppd->pkeyrefs[i]) > 1) {\r\nret = 0;\r\ngoto bail;\r\n}\r\natomic_dec(&ppd->pkeyrefs[i]);\r\nany++;\r\n}\r\nif ((ppd->pkeys[i] & 0x7FFF) == lkey) {\r\nret = -EEXIST;\r\ngoto bail;\r\n}\r\n}\r\nif (!any) {\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\r\nif (!ppd->pkeys[i] &&\r\natomic_inc_return(&ppd->pkeyrefs[i]) == 1) {\r\nppd->pkeys[i] = key;\r\nret = 1;\r\ngoto bail;\r\n}\r\n}\r\nret = -EBUSY;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int set_pkeys(struct qib_devdata *dd, u8 port, u16 *pkeys)\r\n{\r\nstruct qib_pportdata *ppd;\r\nstruct qib_ctxtdata *rcd;\r\nint i;\r\nint changed = 0;\r\nppd = dd->pport + (port - 1);\r\nrcd = dd->rcd[ppd->hw_pidx];\r\nfor (i = 0; i < ARRAY_SIZE(rcd->pkeys); i++) {\r\nu16 key = pkeys[i];\r\nu16 okey = rcd->pkeys[i];\r\nif (key == okey)\r\ncontinue;\r\nif (okey & 0x7FFF)\r\nchanged |= rm_pkey(ppd, okey);\r\nif (key & 0x7FFF) {\r\nint ret = add_pkey(ppd, key);\r\nif (ret < 0)\r\nkey = 0;\r\nelse\r\nchanged |= ret;\r\n}\r\nrcd->pkeys[i] = key;\r\n}\r\nif (changed) {\r\nstruct ib_event event;\r\n(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PKEYS, 0);\r\nevent.event = IB_EVENT_PKEY_CHANGE;\r\nevent.device = &dd->verbs_dev.ibdev;\r\nevent.element.port_num = port;\r\nib_dispatch_event(&event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int subn_set_pkeytable(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\r\n__be16 *p = (__be16 *) smp->data;\r\nu16 *q = (u16 *) smp->data;\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nunsigned i, n = qib_get_npkeys(dd);\r\nfor (i = 0; i < n; i++)\r\nq[i] = be16_to_cpu(p[i]);\r\nif (startpx != 0 || set_pkeys(dd, port, q) != 0)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn subn_get_pkeytable(smp, ibdev, port);\r\n}\r\nstatic int subn_get_sl_to_vl(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nu8 *p = (u8 *) smp->data;\r\nunsigned i;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (!(ibp->port_cap_flags & IB_PORT_SL_MAP_SUP))\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nelse\r\nfor (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2)\r\n*p++ = (ibp->sl_to_vl[i] << 4) | ibp->sl_to_vl[i + 1];\r\nreturn reply(smp);\r\n}\r\nstatic int subn_set_sl_to_vl(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nu8 *p = (u8 *) smp->data;\r\nunsigned i;\r\nif (!(ibp->port_cap_flags & IB_PORT_SL_MAP_SUP)) {\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nreturn reply(smp);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2, p++) {\r\nibp->sl_to_vl[i] = *p >> 4;\r\nibp->sl_to_vl[i + 1] = *p & 0xF;\r\n}\r\nqib_set_uevent_bits(ppd_from_ibp(to_iport(ibdev, port)),\r\n_QIB_EVENT_SL2VL_CHANGE_BIT);\r\nreturn subn_get_sl_to_vl(smp, ibdev, port);\r\n}\r\nstatic int subn_get_vl_arb(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nunsigned which = be32_to_cpu(smp->attr_mod) >> 16;\r\nstruct qib_pportdata *ppd = ppd_from_ibp(to_iport(ibdev, port));\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (ppd->vls_supported == IB_VL_VL0)\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nelse if (which == IB_VLARB_LOWPRI_0_31)\r\n(void) ppd->dd->f_get_ib_table(ppd, QIB_IB_TBL_VL_LOW_ARB,\r\nsmp->data);\r\nelse if (which == IB_VLARB_HIGHPRI_0_31)\r\n(void) ppd->dd->f_get_ib_table(ppd, QIB_IB_TBL_VL_HIGH_ARB,\r\nsmp->data);\r\nelse\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn reply(smp);\r\n}\r\nstatic int subn_set_vl_arb(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nunsigned which = be32_to_cpu(smp->attr_mod) >> 16;\r\nstruct qib_pportdata *ppd = ppd_from_ibp(to_iport(ibdev, port));\r\nif (ppd->vls_supported == IB_VL_VL0)\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nelse if (which == IB_VLARB_LOWPRI_0_31)\r\n(void) ppd->dd->f_set_ib_table(ppd, QIB_IB_TBL_VL_LOW_ARB,\r\nsmp->data);\r\nelse if (which == IB_VLARB_HIGHPRI_0_31)\r\n(void) ppd->dd->f_set_ib_table(ppd, QIB_IB_TBL_VL_HIGH_ARB,\r\nsmp->data);\r\nelse\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn subn_get_vl_arb(smp, ibdev, port);\r\n}\r\nstatic int subn_trap_repress(struct ib_smp *smp, struct ib_device *ibdev,\r\nu8 port)\r\n{\r\nreturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\r\n}\r\nstatic int pma_get_classportinfo(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev)\r\n{\r\nstruct ib_class_port_info *p =\r\n(struct ib_class_port_info *)pmp->data;\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\nif (pmp->mad_hdr.attr_mod != 0)\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\np->base_version = 1;\r\np->class_version = 1;\r\np->capability_mask = IB_PMA_CLASS_CAP_EXT_WIDTH;\r\np->reserved[0] = dd->psxmitwait_supported << 7;\r\np->resp_time_value = 18;\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_get_portsamplescontrol(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplescontrol *p =\r\n(struct ib_pma_portsamplescontrol *)pmp->data;\r\nstruct qib_ibdev *dev = to_idev(ibdev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nunsigned long flags;\r\nu8 port_select = p->port_select;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 || port_select != port) {\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&ibp->lock, flags);\r\np->tick = dd->f_get_ib_cfg(ppd, QIB_IB_CFG_PMA_TICKS);\r\np->sample_status = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\r\np->counter_width = 4;\r\np->counter_mask0_9 = COUNTER_MASK0_9;\r\np->sample_start = cpu_to_be32(ibp->pma_sample_start);\r\np->sample_interval = cpu_to_be32(ibp->pma_sample_interval);\r\np->tag = cpu_to_be16(ibp->pma_tag);\r\np->counter_select[0] = ibp->pma_counter_select[0];\r\np->counter_select[1] = ibp->pma_counter_select[1];\r\np->counter_select[2] = ibp->pma_counter_select[2];\r\np->counter_select[3] = ibp->pma_counter_select[3];\r\np->counter_select[4] = ibp->pma_counter_select[4];\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nbail:\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_set_portsamplescontrol(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplescontrol *p =\r\n(struct ib_pma_portsamplescontrol *)pmp->data;\r\nstruct qib_ibdev *dev = to_idev(ibdev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nunsigned long flags;\r\nu8 status, xmit_flags;\r\nint ret;\r\nif (pmp->mad_hdr.attr_mod != 0 || p->port_select != port) {\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&ibp->lock, flags);\r\nxmit_flags = ppd->cong_stats.flags;\r\nppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_SAMPLE;\r\nstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\r\nif (status == IB_PMA_SAMPLE_STATUS_DONE ||\r\n(status == IB_PMA_SAMPLE_STATUS_RUNNING &&\r\nxmit_flags == IB_PMA_CONG_HW_CONTROL_TIMER)) {\r\nibp->pma_sample_start = be32_to_cpu(p->sample_start);\r\nibp->pma_sample_interval = be32_to_cpu(p->sample_interval);\r\nibp->pma_tag = be16_to_cpu(p->tag);\r\nibp->pma_counter_select[0] = p->counter_select[0];\r\nibp->pma_counter_select[1] = p->counter_select[1];\r\nibp->pma_counter_select[2] = p->counter_select[2];\r\nibp->pma_counter_select[3] = p->counter_select[3];\r\nibp->pma_counter_select[4] = p->counter_select[4];\r\ndd->f_set_cntr_sample(ppd, ibp->pma_sample_interval,\r\nibp->pma_sample_start);\r\n}\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nret = pma_get_portsamplescontrol(pmp, ibdev, port);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic u64 get_counter(struct qib_ibport *ibp, struct qib_pportdata *ppd,\r\n__be16 sel)\r\n{\r\nu64 ret;\r\nswitch (sel) {\r\ncase IB_PMA_PORT_XMIT_DATA:\r\nret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITDATA);\r\nbreak;\r\ncase IB_PMA_PORT_RCV_DATA:\r\nret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSRCVDATA);\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_PKTS:\r\nret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITPKTS);\r\nbreak;\r\ncase IB_PMA_PORT_RCV_PKTS:\r\nret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSRCVPKTS);\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_WAIT:\r\nret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITWAIT);\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u64 xmit_wait_get_value_delta(struct qib_pportdata *ppd)\r\n{\r\nu32 delta;\r\ndelta = get_counter(&ppd->ibport_data, ppd,\r\nIB_PMA_PORT_XMIT_WAIT);\r\nreturn ppd->cong_stats.counter + delta;\r\n}\r\nstatic void cache_hw_sample_counters(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_ibport *ibp = &ppd->ibport_data;\r\nppd->cong_stats.counter_cache.psxmitdata =\r\nget_counter(ibp, ppd, IB_PMA_PORT_XMIT_DATA);\r\nppd->cong_stats.counter_cache.psrcvdata =\r\nget_counter(ibp, ppd, IB_PMA_PORT_RCV_DATA);\r\nppd->cong_stats.counter_cache.psxmitpkts =\r\nget_counter(ibp, ppd, IB_PMA_PORT_XMIT_PKTS);\r\nppd->cong_stats.counter_cache.psrcvpkts =\r\nget_counter(ibp, ppd, IB_PMA_PORT_RCV_PKTS);\r\nppd->cong_stats.counter_cache.psxmitwait =\r\nget_counter(ibp, ppd, IB_PMA_PORT_XMIT_WAIT);\r\n}\r\nstatic u64 get_cache_hw_sample_counters(struct qib_pportdata *ppd,\r\n__be16 sel)\r\n{\r\nu64 ret;\r\nswitch (sel) {\r\ncase IB_PMA_PORT_XMIT_DATA:\r\nret = ppd->cong_stats.counter_cache.psxmitdata;\r\nbreak;\r\ncase IB_PMA_PORT_RCV_DATA:\r\nret = ppd->cong_stats.counter_cache.psrcvdata;\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_PKTS:\r\nret = ppd->cong_stats.counter_cache.psxmitpkts;\r\nbreak;\r\ncase IB_PMA_PORT_RCV_PKTS:\r\nret = ppd->cong_stats.counter_cache.psrcvpkts;\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_WAIT:\r\nret = ppd->cong_stats.counter_cache.psxmitwait;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pma_get_portsamplesresult(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplesresult *p =\r\n(struct ib_pma_portsamplesresult *)pmp->data;\r\nstruct qib_ibdev *dev = to_idev(ibdev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nunsigned long flags;\r\nu8 status;\r\nint i;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\nspin_lock_irqsave(&ibp->lock, flags);\r\np->tag = cpu_to_be16(ibp->pma_tag);\r\nif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_TIMER)\r\np->sample_status = IB_PMA_SAMPLE_STATUS_DONE;\r\nelse {\r\nstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\r\np->sample_status = cpu_to_be16(status);\r\nif (status == IB_PMA_SAMPLE_STATUS_DONE) {\r\ncache_hw_sample_counters(ppd);\r\nppd->cong_stats.counter =\r\nxmit_wait_get_value_delta(ppd);\r\ndd->f_set_cntr_sample(ppd,\r\nQIB_CONG_TIMER_PSINTERVAL, 0);\r\nppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ibp->pma_counter_select); i++)\r\np->counter[i] = cpu_to_be32(\r\nget_cache_hw_sample_counters(\r\nppd, ibp->pma_counter_select[i]));\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_get_portsamplesresult_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplesresult_ext *p =\r\n(struct ib_pma_portsamplesresult_ext *)pmp->data;\r\nstruct qib_ibdev *dev = to_idev(ibdev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nunsigned long flags;\r\nu8 status;\r\nint i;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\nspin_lock_irqsave(&ibp->lock, flags);\r\np->tag = cpu_to_be16(ibp->pma_tag);\r\nif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_TIMER)\r\np->sample_status = IB_PMA_SAMPLE_STATUS_DONE;\r\nelse {\r\nstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\r\np->sample_status = cpu_to_be16(status);\r\np->extended_width = cpu_to_be32(0x80000000);\r\nif (status == IB_PMA_SAMPLE_STATUS_DONE) {\r\ncache_hw_sample_counters(ppd);\r\nppd->cong_stats.counter =\r\nxmit_wait_get_value_delta(ppd);\r\ndd->f_set_cntr_sample(ppd,\r\nQIB_CONG_TIMER_PSINTERVAL, 0);\r\nppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ibp->pma_counter_select); i++)\r\np->counter[i] = cpu_to_be64(\r\nget_cache_hw_sample_counters(\r\nppd, ibp->pma_counter_select[i]));\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_get_portcounters(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nstruct qib_verbs_counters cntrs;\r\nu8 port_select = p->port_select;\r\nqib_get_counters(ppd, &cntrs);\r\ncntrs.symbol_error_counter -= ibp->z_symbol_error_counter;\r\ncntrs.link_error_recovery_counter -=\r\nibp->z_link_error_recovery_counter;\r\ncntrs.link_downed_counter -= ibp->z_link_downed_counter;\r\ncntrs.port_rcv_errors -= ibp->z_port_rcv_errors;\r\ncntrs.port_rcv_remphys_errors -= ibp->z_port_rcv_remphys_errors;\r\ncntrs.port_xmit_discards -= ibp->z_port_xmit_discards;\r\ncntrs.port_xmit_data -= ibp->z_port_xmit_data;\r\ncntrs.port_rcv_data -= ibp->z_port_rcv_data;\r\ncntrs.port_xmit_packets -= ibp->z_port_xmit_packets;\r\ncntrs.port_rcv_packets -= ibp->z_port_rcv_packets;\r\ncntrs.local_link_integrity_errors -=\r\nibp->z_local_link_integrity_errors;\r\ncntrs.excessive_buffer_overrun_errors -=\r\nibp->z_excessive_buffer_overrun_errors;\r\ncntrs.vl15_dropped -= ibp->z_vl15_dropped;\r\ncntrs.vl15_dropped += ibp->n_vl15_dropped;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 || port_select != port)\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nif (cntrs.symbol_error_counter > 0xFFFFUL)\r\np->symbol_error_counter = cpu_to_be16(0xFFFF);\r\nelse\r\np->symbol_error_counter =\r\ncpu_to_be16((u16)cntrs.symbol_error_counter);\r\nif (cntrs.link_error_recovery_counter > 0xFFUL)\r\np->link_error_recovery_counter = 0xFF;\r\nelse\r\np->link_error_recovery_counter =\r\n(u8)cntrs.link_error_recovery_counter;\r\nif (cntrs.link_downed_counter > 0xFFUL)\r\np->link_downed_counter = 0xFF;\r\nelse\r\np->link_downed_counter = (u8)cntrs.link_downed_counter;\r\nif (cntrs.port_rcv_errors > 0xFFFFUL)\r\np->port_rcv_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_errors =\r\ncpu_to_be16((u16) cntrs.port_rcv_errors);\r\nif (cntrs.port_rcv_remphys_errors > 0xFFFFUL)\r\np->port_rcv_remphys_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_remphys_errors =\r\ncpu_to_be16((u16)cntrs.port_rcv_remphys_errors);\r\nif (cntrs.port_xmit_discards > 0xFFFFUL)\r\np->port_xmit_discards = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_xmit_discards =\r\ncpu_to_be16((u16)cntrs.port_xmit_discards);\r\nif (cntrs.local_link_integrity_errors > 0xFUL)\r\ncntrs.local_link_integrity_errors = 0xFUL;\r\nif (cntrs.excessive_buffer_overrun_errors > 0xFUL)\r\ncntrs.excessive_buffer_overrun_errors = 0xFUL;\r\np->link_overrun_errors = (cntrs.local_link_integrity_errors << 4) |\r\ncntrs.excessive_buffer_overrun_errors;\r\nif (cntrs.vl15_dropped > 0xFFFFUL)\r\np->vl15_dropped = cpu_to_be16(0xFFFF);\r\nelse\r\np->vl15_dropped = cpu_to_be16((u16)cntrs.vl15_dropped);\r\nif (cntrs.port_xmit_data > 0xFFFFFFFFUL)\r\np->port_xmit_data = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_xmit_data = cpu_to_be32((u32)cntrs.port_xmit_data);\r\nif (cntrs.port_rcv_data > 0xFFFFFFFFUL)\r\np->port_rcv_data = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_rcv_data = cpu_to_be32((u32)cntrs.port_rcv_data);\r\nif (cntrs.port_xmit_packets > 0xFFFFFFFFUL)\r\np->port_xmit_packets = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_xmit_packets =\r\ncpu_to_be32((u32)cntrs.port_xmit_packets);\r\nif (cntrs.port_rcv_packets > 0xFFFFFFFFUL)\r\np->port_rcv_packets = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_rcv_packets =\r\ncpu_to_be32((u32) cntrs.port_rcv_packets);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_get_portcounters_cong(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters_cong *p =\r\n(struct ib_pma_portcounters_cong *)pmp->reserved;\r\nstruct qib_verbs_counters cntrs;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nstruct qib_devdata *dd = dd_from_ppd(ppd);\r\nu32 port_select = be32_to_cpu(pmp->mad_hdr.attr_mod) & 0xFF;\r\nu64 xmit_wait_counter;\r\nunsigned long flags;\r\nif (!dd->psxmitwait_supported)\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\r\nif (port_select != port)\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nqib_get_counters(ppd, &cntrs);\r\nspin_lock_irqsave(&ppd->ibport_data.lock, flags);\r\nxmit_wait_counter = xmit_wait_get_value_delta(ppd);\r\nspin_unlock_irqrestore(&ppd->ibport_data.lock, flags);\r\ncntrs.symbol_error_counter -= ibp->z_symbol_error_counter;\r\ncntrs.link_error_recovery_counter -=\r\nibp->z_link_error_recovery_counter;\r\ncntrs.link_downed_counter -= ibp->z_link_downed_counter;\r\ncntrs.port_rcv_errors -= ibp->z_port_rcv_errors;\r\ncntrs.port_rcv_remphys_errors -=\r\nibp->z_port_rcv_remphys_errors;\r\ncntrs.port_xmit_discards -= ibp->z_port_xmit_discards;\r\ncntrs.local_link_integrity_errors -=\r\nibp->z_local_link_integrity_errors;\r\ncntrs.excessive_buffer_overrun_errors -=\r\nibp->z_excessive_buffer_overrun_errors;\r\ncntrs.vl15_dropped -= ibp->z_vl15_dropped;\r\ncntrs.vl15_dropped += ibp->n_vl15_dropped;\r\ncntrs.port_xmit_data -= ibp->z_port_xmit_data;\r\ncntrs.port_rcv_data -= ibp->z_port_rcv_data;\r\ncntrs.port_xmit_packets -= ibp->z_port_xmit_packets;\r\ncntrs.port_rcv_packets -= ibp->z_port_rcv_packets;\r\nmemset(pmp->reserved, 0, sizeof(pmp->reserved) +\r\nsizeof(pmp->data));\r\np->port_check_rate =\r\ncpu_to_be16((QIB_XMIT_RATE_PICO << 13) |\r\n(dd->psxmitwait_check_rate &\r\n~(QIB_XMIT_RATE_PICO << 13)));\r\np->port_adr_events = cpu_to_be64(0);\r\np->port_xmit_wait = cpu_to_be64(xmit_wait_counter);\r\np->port_xmit_data = cpu_to_be64(cntrs.port_xmit_data);\r\np->port_rcv_data = cpu_to_be64(cntrs.port_rcv_data);\r\np->port_xmit_packets =\r\ncpu_to_be64(cntrs.port_xmit_packets);\r\np->port_rcv_packets =\r\ncpu_to_be64(cntrs.port_rcv_packets);\r\nif (cntrs.symbol_error_counter > 0xFFFFUL)\r\np->symbol_error_counter = cpu_to_be16(0xFFFF);\r\nelse\r\np->symbol_error_counter =\r\ncpu_to_be16(\r\n(u16)cntrs.symbol_error_counter);\r\nif (cntrs.link_error_recovery_counter > 0xFFUL)\r\np->link_error_recovery_counter = 0xFF;\r\nelse\r\np->link_error_recovery_counter =\r\n(u8)cntrs.link_error_recovery_counter;\r\nif (cntrs.link_downed_counter > 0xFFUL)\r\np->link_downed_counter = 0xFF;\r\nelse\r\np->link_downed_counter =\r\n(u8)cntrs.link_downed_counter;\r\nif (cntrs.port_rcv_errors > 0xFFFFUL)\r\np->port_rcv_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_errors =\r\ncpu_to_be16((u16) cntrs.port_rcv_errors);\r\nif (cntrs.port_rcv_remphys_errors > 0xFFFFUL)\r\np->port_rcv_remphys_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_remphys_errors =\r\ncpu_to_be16(\r\n(u16)cntrs.port_rcv_remphys_errors);\r\nif (cntrs.port_xmit_discards > 0xFFFFUL)\r\np->port_xmit_discards = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_xmit_discards =\r\ncpu_to_be16((u16)cntrs.port_xmit_discards);\r\nif (cntrs.local_link_integrity_errors > 0xFUL)\r\ncntrs.local_link_integrity_errors = 0xFUL;\r\nif (cntrs.excessive_buffer_overrun_errors > 0xFUL)\r\ncntrs.excessive_buffer_overrun_errors = 0xFUL;\r\np->link_overrun_errors = (cntrs.local_link_integrity_errors << 4) |\r\ncntrs.excessive_buffer_overrun_errors;\r\nif (cntrs.vl15_dropped > 0xFFFFUL)\r\np->vl15_dropped = cpu_to_be16(0xFFFF);\r\nelse\r\np->vl15_dropped = cpu_to_be16((u16)cntrs.vl15_dropped);\r\nreturn reply((struct ib_smp *)pmp);\r\n}\r\nstatic void qib_snapshot_pmacounters(\r\nstruct qib_ibport *ibp,\r\nstruct qib_pma_counters *pmacounters)\r\n{\r\nstruct qib_pma_counters *p;\r\nint cpu;\r\nmemset(pmacounters, 0, sizeof(*pmacounters));\r\nfor_each_possible_cpu(cpu) {\r\np = per_cpu_ptr(ibp->pmastats, cpu);\r\npmacounters->n_unicast_xmit += p->n_unicast_xmit;\r\npmacounters->n_unicast_rcv += p->n_unicast_rcv;\r\npmacounters->n_multicast_xmit += p->n_multicast_xmit;\r\npmacounters->n_multicast_rcv += p->n_multicast_rcv;\r\n}\r\n}\r\nstatic int pma_get_portcounters_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters_ext *p =\r\n(struct ib_pma_portcounters_ext *)pmp->data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nu64 swords, rwords, spkts, rpkts, xwait;\r\nstruct qib_pma_counters pma;\r\nu8 port_select = p->port_select;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 || port_select != port) {\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\ngoto bail;\r\n}\r\nqib_snapshot_counters(ppd, &swords, &rwords, &spkts, &rpkts, &xwait);\r\nswords -= ibp->z_port_xmit_data;\r\nrwords -= ibp->z_port_rcv_data;\r\nspkts -= ibp->z_port_xmit_packets;\r\nrpkts -= ibp->z_port_rcv_packets;\r\np->port_xmit_data = cpu_to_be64(swords);\r\np->port_rcv_data = cpu_to_be64(rwords);\r\np->port_xmit_packets = cpu_to_be64(spkts);\r\np->port_rcv_packets = cpu_to_be64(rpkts);\r\nqib_snapshot_pmacounters(ibp, &pma);\r\np->port_unicast_xmit_packets = cpu_to_be64(pma.n_unicast_xmit\r\n- ibp->z_unicast_xmit);\r\np->port_unicast_rcv_packets = cpu_to_be64(pma.n_unicast_rcv\r\n- ibp->z_unicast_rcv);\r\np->port_multicast_xmit_packets = cpu_to_be64(pma.n_multicast_xmit\r\n- ibp->z_multicast_xmit);\r\np->port_multicast_rcv_packets = cpu_to_be64(pma.n_multicast_rcv\r\n- ibp->z_multicast_rcv);\r\nbail:\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int pma_set_portcounters(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nstruct qib_verbs_counters cntrs;\r\nqib_get_counters(ppd, &cntrs);\r\nif (p->counter_select & IB_PMA_SEL_SYMBOL_ERROR)\r\nibp->z_symbol_error_counter = cntrs.symbol_error_counter;\r\nif (p->counter_select & IB_PMA_SEL_LINK_ERROR_RECOVERY)\r\nibp->z_link_error_recovery_counter =\r\ncntrs.link_error_recovery_counter;\r\nif (p->counter_select & IB_PMA_SEL_LINK_DOWNED)\r\nibp->z_link_downed_counter = cntrs.link_downed_counter;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_ERRORS)\r\nibp->z_port_rcv_errors = cntrs.port_rcv_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_REMPHYS_ERRORS)\r\nibp->z_port_rcv_remphys_errors =\r\ncntrs.port_rcv_remphys_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DISCARDS)\r\nibp->z_port_xmit_discards = cntrs.port_xmit_discards;\r\nif (p->counter_select & IB_PMA_SEL_LOCAL_LINK_INTEGRITY_ERRORS)\r\nibp->z_local_link_integrity_errors =\r\ncntrs.local_link_integrity_errors;\r\nif (p->counter_select & IB_PMA_SEL_EXCESSIVE_BUFFER_OVERRUNS)\r\nibp->z_excessive_buffer_overrun_errors =\r\ncntrs.excessive_buffer_overrun_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_VL15_DROPPED) {\r\nibp->n_vl15_dropped = 0;\r\nibp->z_vl15_dropped = cntrs.vl15_dropped;\r\n}\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DATA)\r\nibp->z_port_xmit_data = cntrs.port_xmit_data;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_DATA)\r\nibp->z_port_rcv_data = cntrs.port_rcv_data;\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_PACKETS)\r\nibp->z_port_xmit_packets = cntrs.port_xmit_packets;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_PACKETS)\r\nibp->z_port_rcv_packets = cntrs.port_rcv_packets;\r\nreturn pma_get_portcounters(pmp, ibdev, port);\r\n}\r\nstatic int pma_set_portcounters_cong(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nstruct qib_devdata *dd = dd_from_ppd(ppd);\r\nstruct qib_verbs_counters cntrs;\r\nu32 counter_select = (be32_to_cpu(pmp->mad_hdr.attr_mod) >> 24) & 0xFF;\r\nint ret = 0;\r\nunsigned long flags;\r\nqib_get_counters(ppd, &cntrs);\r\nret = pma_get_portcounters_cong(pmp, ibdev, port);\r\nif (counter_select & IB_PMA_SEL_CONG_XMIT) {\r\nspin_lock_irqsave(&ppd->ibport_data.lock, flags);\r\nppd->cong_stats.counter = 0;\r\ndd->f_set_cntr_sample(ppd, QIB_CONG_TIMER_PSINTERVAL,\r\n0x0);\r\nspin_unlock_irqrestore(&ppd->ibport_data.lock, flags);\r\n}\r\nif (counter_select & IB_PMA_SEL_CONG_PORT_DATA) {\r\nibp->z_port_xmit_data = cntrs.port_xmit_data;\r\nibp->z_port_rcv_data = cntrs.port_rcv_data;\r\nibp->z_port_xmit_packets = cntrs.port_xmit_packets;\r\nibp->z_port_rcv_packets = cntrs.port_rcv_packets;\r\n}\r\nif (counter_select & IB_PMA_SEL_CONG_ALL) {\r\nibp->z_symbol_error_counter =\r\ncntrs.symbol_error_counter;\r\nibp->z_link_error_recovery_counter =\r\ncntrs.link_error_recovery_counter;\r\nibp->z_link_downed_counter =\r\ncntrs.link_downed_counter;\r\nibp->z_port_rcv_errors = cntrs.port_rcv_errors;\r\nibp->z_port_rcv_remphys_errors =\r\ncntrs.port_rcv_remphys_errors;\r\nibp->z_port_xmit_discards =\r\ncntrs.port_xmit_discards;\r\nibp->z_local_link_integrity_errors =\r\ncntrs.local_link_integrity_errors;\r\nibp->z_excessive_buffer_overrun_errors =\r\ncntrs.excessive_buffer_overrun_errors;\r\nibp->n_vl15_dropped = 0;\r\nibp->z_vl15_dropped = cntrs.vl15_dropped;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pma_set_portcounters_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nu64 swords, rwords, spkts, rpkts, xwait;\r\nstruct qib_pma_counters pma;\r\nqib_snapshot_counters(ppd, &swords, &rwords, &spkts, &rpkts, &xwait);\r\nif (p->counter_select & IB_PMA_SELX_PORT_XMIT_DATA)\r\nibp->z_port_xmit_data = swords;\r\nif (p->counter_select & IB_PMA_SELX_PORT_RCV_DATA)\r\nibp->z_port_rcv_data = rwords;\r\nif (p->counter_select & IB_PMA_SELX_PORT_XMIT_PACKETS)\r\nibp->z_port_xmit_packets = spkts;\r\nif (p->counter_select & IB_PMA_SELX_PORT_RCV_PACKETS)\r\nibp->z_port_rcv_packets = rpkts;\r\nqib_snapshot_pmacounters(ibp, &pma);\r\nif (p->counter_select & IB_PMA_SELX_PORT_UNI_XMIT_PACKETS)\r\nibp->z_unicast_xmit = pma.n_unicast_xmit;\r\nif (p->counter_select & IB_PMA_SELX_PORT_UNI_RCV_PACKETS)\r\nibp->z_unicast_rcv = pma.n_unicast_rcv;\r\nif (p->counter_select & IB_PMA_SELX_PORT_MULTI_XMIT_PACKETS)\r\nibp->z_multicast_xmit = pma.n_multicast_xmit;\r\nif (p->counter_select & IB_PMA_SELX_PORT_MULTI_RCV_PACKETS)\r\nibp->z_multicast_rcv = pma.n_multicast_rcv;\r\nreturn pma_get_portcounters_ext(pmp, ibdev, port);\r\n}\r\nstatic int process_subn(struct ib_device *ibdev, int mad_flags,\r\nu8 port, struct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nstruct ib_smp *smp = (struct ib_smp *)out_mad;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nint ret;\r\n*out_mad = *in_mad;\r\nif (smp->class_version != 1) {\r\nsmp->status |= IB_SMP_UNSUP_VERSION;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\nret = check_mkey(ibp, smp, mad_flags);\r\nif (ret) {\r\nu32 port_num = be32_to_cpu(smp->attr_mod);\r\nif (in_mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&\r\n(smp->method == IB_MGMT_METHOD_GET ||\r\nsmp->method == IB_MGMT_METHOD_SET) &&\r\nport_num && port_num <= ibdev->phys_port_cnt &&\r\nport != port_num)\r\n(void) check_mkey(to_iport(ibdev, port_num), smp, 0);\r\nret = IB_MAD_RESULT_FAILURE;\r\ngoto bail;\r\n}\r\nswitch (smp->method) {\r\ncase IB_MGMT_METHOD_GET:\r\nswitch (smp->attr_id) {\r\ncase IB_SMP_ATTR_NODE_DESC:\r\nret = subn_get_nodedescription(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_NODE_INFO:\r\nret = subn_get_nodeinfo(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_GUID_INFO:\r\nret = subn_get_guidinfo(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PORT_INFO:\r\nret = subn_get_portinfo(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PKEY_TABLE:\r\nret = subn_get_pkeytable(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SL_TO_VL_TABLE:\r\nret = subn_get_sl_to_vl(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_VL_ARB_TABLE:\r\nret = subn_get_vl_arb(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SM_INFO:\r\nif (ibp->port_cap_flags & IB_PORT_SM_DISABLED) {\r\nret = IB_MAD_RESULT_SUCCESS |\r\nIB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n}\r\nif (ibp->port_cap_flags & IB_PORT_SM) {\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\n}\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_SET:\r\nswitch (smp->attr_id) {\r\ncase IB_SMP_ATTR_GUID_INFO:\r\nret = subn_set_guidinfo(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PORT_INFO:\r\nret = subn_set_portinfo(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PKEY_TABLE:\r\nret = subn_set_pkeytable(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SL_TO_VL_TABLE:\r\nret = subn_set_sl_to_vl(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_VL_ARB_TABLE:\r\nret = subn_set_vl_arb(smp, ibdev, port);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SM_INFO:\r\nif (ibp->port_cap_flags & IB_PORT_SM_DISABLED) {\r\nret = IB_MAD_RESULT_SUCCESS |\r\nIB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n}\r\nif (ibp->port_cap_flags & IB_PORT_SM) {\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\n}\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_TRAP_REPRESS:\r\nif (smp->attr_id == IB_SMP_ATTR_NOTICE)\r\nret = subn_trap_repress(smp, ibdev, port);\r\nelse {\r\nsmp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply(smp);\r\n}\r\ngoto bail;\r\ncase IB_MGMT_METHOD_TRAP:\r\ncase IB_MGMT_METHOD_REPORT:\r\ncase IB_MGMT_METHOD_REPORT_RESP:\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ncase IB_MGMT_METHOD_SEND:\r\nif (ib_get_smp_direction(smp) &&\r\nsmp->attr_id == QIB_VENDOR_IPG) {\r\nppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PORT,\r\nsmp->data[0]);\r\nret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\r\n} else\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nret = reply(smp);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int process_perf(struct ib_device *ibdev, u8 port,\r\nstruct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nstruct ib_pma_mad *pmp = (struct ib_pma_mad *)out_mad;\r\nint ret;\r\n*out_mad = *in_mad;\r\nif (pmp->mad_hdr.class_version != 1) {\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_VERSION;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\nswitch (pmp->mad_hdr.method) {\r\ncase IB_MGMT_METHOD_GET:\r\nswitch (pmp->mad_hdr.attr_id) {\r\ncase IB_PMA_CLASS_PORT_INFO:\r\nret = pma_get_classportinfo(pmp, ibdev);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_CONTROL:\r\nret = pma_get_portsamplescontrol(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_RESULT:\r\nret = pma_get_portsamplesresult(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_RESULT_EXT:\r\nret = pma_get_portsamplesresult_ext(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS:\r\nret = pma_get_portcounters(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_EXT:\r\nret = pma_get_portcounters_ext(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_CONG:\r\nret = pma_get_portcounters_cong(pmp, ibdev, port);\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_SET:\r\nswitch (pmp->mad_hdr.attr_id) {\r\ncase IB_PMA_PORT_SAMPLES_CONTROL:\r\nret = pma_set_portsamplescontrol(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS:\r\nret = pma_set_portcounters(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_EXT:\r\nret = pma_set_portcounters_ext(pmp, ibdev, port);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_CONG:\r\nret = pma_set_portcounters_cong(pmp, ibdev, port);\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_TRAP:\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METHOD;\r\nret = reply((struct ib_smp *) pmp);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int cc_get_classportinfo(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev)\r\n{\r\nstruct ib_cc_classportinfo_attr *p =\r\n(struct ib_cc_classportinfo_attr *)ccp->mgmt_data;\r\nmemset(ccp->mgmt_data, 0, sizeof(ccp->mgmt_data));\r\np->base_version = 1;\r\np->class_version = 1;\r\np->cap_mask = 0;\r\np->resp_time_value = 18;\r\nreturn reply((struct ib_smp *) ccp);\r\n}\r\nstatic int cc_get_congestion_info(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_cc_info_attr *p =\r\n(struct ib_cc_info_attr *)ccp->mgmt_data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nmemset(ccp->mgmt_data, 0, sizeof(ccp->mgmt_data));\r\np->congestion_info = 0;\r\np->control_table_cap = ppd->cc_max_table_entries;\r\nreturn reply((struct ib_smp *) ccp);\r\n}\r\nstatic int cc_get_congestion_setting(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nint i;\r\nstruct ib_cc_congestion_setting_attr *p =\r\n(struct ib_cc_congestion_setting_attr *)ccp->mgmt_data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nstruct ib_cc_congestion_entry_shadow *entries;\r\nmemset(ccp->mgmt_data, 0, sizeof(ccp->mgmt_data));\r\nspin_lock(&ppd->cc_shadow_lock);\r\nentries = ppd->congestion_entries_shadow->entries;\r\np->port_control = cpu_to_be16(\r\nppd->congestion_entries_shadow->port_control);\r\np->control_map = cpu_to_be16(\r\nppd->congestion_entries_shadow->control_map);\r\nfor (i = 0; i < IB_CC_CCS_ENTRIES; i++) {\r\np->entries[i].ccti_increase = entries[i].ccti_increase;\r\np->entries[i].ccti_timer = cpu_to_be16(entries[i].ccti_timer);\r\np->entries[i].trigger_threshold = entries[i].trigger_threshold;\r\np->entries[i].ccti_min = entries[i].ccti_min;\r\n}\r\nspin_unlock(&ppd->cc_shadow_lock);\r\nreturn reply((struct ib_smp *) ccp);\r\n}\r\nstatic int cc_get_congestion_control_table(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_cc_table_attr *p =\r\n(struct ib_cc_table_attr *)ccp->mgmt_data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nu32 cct_block_index = be32_to_cpu(ccp->attr_mod);\r\nu32 max_cct_block;\r\nu32 cct_entry;\r\nstruct ib_cc_table_entry_shadow *entries;\r\nint i;\r\nif (cct_block_index > IB_CC_TABLE_CAP_DEFAULT - 1)\r\ngoto bail;\r\nmemset(ccp->mgmt_data, 0, sizeof(ccp->mgmt_data));\r\nspin_lock(&ppd->cc_shadow_lock);\r\nmax_cct_block =\r\n(ppd->ccti_entries_shadow->ccti_last_entry + 1)/IB_CCT_ENTRIES;\r\nmax_cct_block = max_cct_block ? max_cct_block - 1 : 0;\r\nif (cct_block_index > max_cct_block) {\r\nspin_unlock(&ppd->cc_shadow_lock);\r\ngoto bail;\r\n}\r\nccp->attr_mod = cpu_to_be32(cct_block_index);\r\ncct_entry = IB_CCT_ENTRIES * (cct_block_index + 1);\r\ncct_entry--;\r\np->ccti_limit = cpu_to_be16(cct_entry);\r\nentries = &ppd->ccti_entries_shadow->\r\nentries[IB_CCT_ENTRIES * cct_block_index];\r\ncct_entry %= IB_CCT_ENTRIES;\r\nfor (i = 0; i <= cct_entry; i++)\r\np->ccti_entries[i].entry = cpu_to_be16(entries[i].entry);\r\nspin_unlock(&ppd->cc_shadow_lock);\r\nreturn reply((struct ib_smp *) ccp);\r\nbail:\r\nreturn reply_failure((struct ib_smp *) ccp);\r\n}\r\nstatic int cc_set_congestion_setting(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_cc_congestion_setting_attr *p =\r\n(struct ib_cc_congestion_setting_attr *)ccp->mgmt_data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nint i;\r\nppd->cc_sl_control_map = be16_to_cpu(p->control_map);\r\nfor (i = 0; i < IB_CC_CCS_ENTRIES; i++) {\r\nppd->congestion_entries[i].ccti_increase =\r\np->entries[i].ccti_increase;\r\nppd->congestion_entries[i].ccti_timer =\r\nbe16_to_cpu(p->entries[i].ccti_timer);\r\nppd->congestion_entries[i].trigger_threshold =\r\np->entries[i].trigger_threshold;\r\nppd->congestion_entries[i].ccti_min =\r\np->entries[i].ccti_min;\r\n}\r\nreturn reply((struct ib_smp *) ccp);\r\n}\r\nstatic int cc_set_congestion_control_table(struct ib_cc_mad *ccp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_cc_table_attr *p =\r\n(struct ib_cc_table_attr *)ccp->mgmt_data;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nu32 cct_block_index = be32_to_cpu(ccp->attr_mod);\r\nu32 cct_entry;\r\nstruct ib_cc_table_entry_shadow *entries;\r\nint i;\r\nif (cct_block_index > IB_CC_TABLE_CAP_DEFAULT - 1)\r\ngoto bail;\r\nif (be16_to_cpu(p->ccti_limit) < IB_CCT_ENTRIES)\r\nppd->total_cct_entry = 0;\r\ncct_entry = (be16_to_cpu(p->ccti_limit))%IB_CCT_ENTRIES;\r\nppd->total_cct_entry += (cct_entry + 1);\r\nif (ppd->total_cct_entry > ppd->cc_supported_table_entries)\r\ngoto bail;\r\nppd->ccti_limit = be16_to_cpu(p->ccti_limit);\r\nentries = ppd->ccti_entries + (IB_CCT_ENTRIES * cct_block_index);\r\nfor (i = 0; i <= cct_entry; i++)\r\nentries[i].entry = be16_to_cpu(p->ccti_entries[i].entry);\r\nspin_lock(&ppd->cc_shadow_lock);\r\nppd->ccti_entries_shadow->ccti_last_entry = ppd->total_cct_entry - 1;\r\nmemcpy(ppd->ccti_entries_shadow->entries, ppd->ccti_entries,\r\n(ppd->total_cct_entry * sizeof(struct ib_cc_table_entry)));\r\nppd->congestion_entries_shadow->port_control = IB_CC_CCS_PC_SL_BASED;\r\nppd->congestion_entries_shadow->control_map = ppd->cc_sl_control_map;\r\nmemcpy(ppd->congestion_entries_shadow->entries, ppd->congestion_entries,\r\nIB_CC_CCS_ENTRIES * sizeof(struct ib_cc_congestion_entry));\r\nspin_unlock(&ppd->cc_shadow_lock);\r\nreturn reply((struct ib_smp *) ccp);\r\nbail:\r\nreturn reply_failure((struct ib_smp *) ccp);\r\n}\r\nstatic int check_cc_key(struct qib_ibport *ibp,\r\nstruct ib_cc_mad *ccp, int mad_flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int process_cc(struct ib_device *ibdev, int mad_flags,\r\nu8 port, struct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nstruct ib_cc_mad *ccp = (struct ib_cc_mad *)out_mad;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nint ret;\r\n*out_mad = *in_mad;\r\nif (ccp->class_version != 2) {\r\nccp->status |= IB_SMP_UNSUP_VERSION;\r\nret = reply((struct ib_smp *)ccp);\r\ngoto bail;\r\n}\r\nret = check_cc_key(ibp, ccp, mad_flags);\r\nif (ret)\r\ngoto bail;\r\nswitch (ccp->method) {\r\ncase IB_MGMT_METHOD_GET:\r\nswitch (ccp->attr_id) {\r\ncase IB_CC_ATTR_CLASSPORTINFO:\r\nret = cc_get_classportinfo(ccp, ibdev);\r\ngoto bail;\r\ncase IB_CC_ATTR_CONGESTION_INFO:\r\nret = cc_get_congestion_info(ccp, ibdev, port);\r\ngoto bail;\r\ncase IB_CC_ATTR_CA_CONGESTION_SETTING:\r\nret = cc_get_congestion_setting(ccp, ibdev, port);\r\ngoto bail;\r\ncase IB_CC_ATTR_CONGESTION_CONTROL_TABLE:\r\nret = cc_get_congestion_control_table(ccp, ibdev, port);\r\ngoto bail;\r\ndefault:\r\nccp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) ccp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_SET:\r\nswitch (ccp->attr_id) {\r\ncase IB_CC_ATTR_CA_CONGESTION_SETTING:\r\nret = cc_set_congestion_setting(ccp, ibdev, port);\r\ngoto bail;\r\ncase IB_CC_ATTR_CONGESTION_CONTROL_TABLE:\r\nret = cc_set_congestion_control_table(ccp, ibdev, port);\r\ngoto bail;\r\ndefault:\r\nccp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) ccp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ncase IB_MGMT_METHOD_TRAP:\r\ndefault:\r\nccp->status |= IB_SMP_UNSUP_METHOD;\r\nret = reply((struct ib_smp *) ccp);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nint qib_process_mad(struct ib_device *ibdev, int mad_flags, u8 port,\r\nstruct ib_wc *in_wc, struct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nint ret;\r\nstruct qib_ibport *ibp = to_iport(ibdev, port);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nswitch (in_mad->mad_hdr.mgmt_class) {\r\ncase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\r\ncase IB_MGMT_CLASS_SUBN_LID_ROUTED:\r\nret = process_subn(ibdev, mad_flags, port, in_mad, out_mad);\r\ngoto bail;\r\ncase IB_MGMT_CLASS_PERF_MGMT:\r\nret = process_perf(ibdev, port, in_mad, out_mad);\r\ngoto bail;\r\ncase IB_MGMT_CLASS_CONG_MGMT:\r\nif (!ppd->congestion_entries_shadow ||\r\n!qib_cc_table_size) {\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\n}\r\nret = process_cc(ibdev, mad_flags, port, in_mad, out_mad);\r\ngoto bail;\r\ndefault:\r\nret = IB_MAD_RESULT_SUCCESS;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void send_handler(struct ib_mad_agent *agent,\r\nstruct ib_mad_send_wc *mad_send_wc)\r\n{\r\nib_free_send_mad(mad_send_wc->send_buf);\r\n}\r\nstatic void xmit_wait_timer_func(unsigned long opaque)\r\n{\r\nstruct qib_pportdata *ppd = (struct qib_pportdata *)opaque;\r\nstruct qib_devdata *dd = dd_from_ppd(ppd);\r\nunsigned long flags;\r\nu8 status;\r\nspin_lock_irqsave(&ppd->ibport_data.lock, flags);\r\nif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_SAMPLE) {\r\nstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\r\nif (status == IB_PMA_SAMPLE_STATUS_DONE) {\r\ncache_hw_sample_counters(ppd);\r\nppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\r\n} else\r\ngoto done;\r\n}\r\nppd->cong_stats.counter = xmit_wait_get_value_delta(ppd);\r\ndd->f_set_cntr_sample(ppd, QIB_CONG_TIMER_PSINTERVAL, 0x0);\r\ndone:\r\nspin_unlock_irqrestore(&ppd->ibport_data.lock, flags);\r\nmod_timer(&ppd->cong_stats.timer, jiffies + HZ);\r\n}\r\nint qib_create_agents(struct qib_ibdev *dev)\r\n{\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct ib_mad_agent *agent;\r\nstruct qib_ibport *ibp;\r\nint p;\r\nint ret;\r\nfor (p = 0; p < dd->num_pports; p++) {\r\nibp = &dd->pport[p].ibport_data;\r\nagent = ib_register_mad_agent(&dev->ibdev, p + 1, IB_QPT_SMI,\r\nNULL, 0, send_handler,\r\nNULL, NULL, 0);\r\nif (IS_ERR(agent)) {\r\nret = PTR_ERR(agent);\r\ngoto err;\r\n}\r\ndd->pport[p].cong_stats.counter = 0;\r\ninit_timer(&dd->pport[p].cong_stats.timer);\r\ndd->pport[p].cong_stats.timer.function = xmit_wait_timer_func;\r\ndd->pport[p].cong_stats.timer.data =\r\n(unsigned long)(&dd->pport[p]);\r\ndd->pport[p].cong_stats.timer.expires = 0;\r\nadd_timer(&dd->pport[p].cong_stats.timer);\r\nibp->send_agent = agent;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (p = 0; p < dd->num_pports; p++) {\r\nibp = &dd->pport[p].ibport_data;\r\nif (ibp->send_agent) {\r\nagent = ibp->send_agent;\r\nibp->send_agent = NULL;\r\nib_unregister_mad_agent(agent);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid qib_free_agents(struct qib_ibdev *dev)\r\n{\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nstruct ib_mad_agent *agent;\r\nstruct qib_ibport *ibp;\r\nint p;\r\nfor (p = 0; p < dd->num_pports; p++) {\r\nibp = &dd->pport[p].ibport_data;\r\nif (ibp->send_agent) {\r\nagent = ibp->send_agent;\r\nibp->send_agent = NULL;\r\nib_unregister_mad_agent(agent);\r\n}\r\nif (ibp->sm_ah) {\r\nib_destroy_ah(&ibp->sm_ah->ibah);\r\nibp->sm_ah = NULL;\r\n}\r\nif (dd->pport[p].cong_stats.timer.data)\r\ndel_timer_sync(&dd->pport[p].cong_stats.timer);\r\n}\r\n}
