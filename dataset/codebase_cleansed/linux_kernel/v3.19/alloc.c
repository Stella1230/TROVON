uint8_t bch_inc_gen(struct cache *ca, struct bucket *b)\r\n{\r\nuint8_t ret = ++b->gen;\r\nca->set->need_gc = max(ca->set->need_gc, bucket_gc_gen(b));\r\nWARN_ON_ONCE(ca->set->need_gc > BUCKET_GC_GEN_MAX);\r\nreturn ret;\r\n}\r\nvoid bch_rescale_priorities(struct cache_set *c, int sectors)\r\n{\r\nstruct cache *ca;\r\nstruct bucket *b;\r\nunsigned next = c->nbuckets * c->sb.bucket_size / 1024;\r\nunsigned i;\r\nint r;\r\natomic_sub(sectors, &c->rescale);\r\ndo {\r\nr = atomic_read(&c->rescale);\r\nif (r >= 0)\r\nreturn;\r\n} while (atomic_cmpxchg(&c->rescale, r, r + next) != r);\r\nmutex_lock(&c->bucket_lock);\r\nc->min_prio = USHRT_MAX;\r\nfor_each_cache(ca, c, i)\r\nfor_each_bucket(b, ca)\r\nif (b->prio &&\r\nb->prio != BTREE_PRIO &&\r\n!atomic_read(&b->pin)) {\r\nb->prio--;\r\nc->min_prio = min(c->min_prio, b->prio);\r\n}\r\nmutex_unlock(&c->bucket_lock);\r\n}\r\nstatic inline bool can_inc_bucket_gen(struct bucket *b)\r\n{\r\nreturn bucket_gc_gen(b) < BUCKET_GC_GEN_MAX;\r\n}\r\nbool bch_can_invalidate_bucket(struct cache *ca, struct bucket *b)\r\n{\r\nBUG_ON(!ca->set->gc_mark_valid);\r\nreturn (!GC_MARK(b) ||\r\nGC_MARK(b) == GC_MARK_RECLAIMABLE) &&\r\n!atomic_read(&b->pin) &&\r\ncan_inc_bucket_gen(b);\r\n}\r\nvoid __bch_invalidate_one_bucket(struct cache *ca, struct bucket *b)\r\n{\r\nlockdep_assert_held(&ca->set->bucket_lock);\r\nBUG_ON(GC_MARK(b) && GC_MARK(b) != GC_MARK_RECLAIMABLE);\r\nif (GC_SECTORS_USED(b))\r\ntrace_bcache_invalidate(ca, b - ca->buckets);\r\nbch_inc_gen(ca, b);\r\nb->prio = INITIAL_PRIO;\r\natomic_inc(&b->pin);\r\n}\r\nstatic void bch_invalidate_one_bucket(struct cache *ca, struct bucket *b)\r\n{\r\n__bch_invalidate_one_bucket(ca, b);\r\nfifo_push(&ca->free_inc, b - ca->buckets);\r\n}\r\nstatic void invalidate_buckets_lru(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nssize_t i;\r\nca->heap.used = 0;\r\nfor_each_bucket(b, ca) {\r\nif (!bch_can_invalidate_bucket(ca, b))\r\ncontinue;\r\nif (!heap_full(&ca->heap))\r\nheap_add(&ca->heap, b, bucket_max_cmp);\r\nelse if (bucket_max_cmp(b, heap_peek(&ca->heap))) {\r\nca->heap.data[0] = b;\r\nheap_sift(&ca->heap, 0, bucket_max_cmp);\r\n}\r\n}\r\nfor (i = ca->heap.used / 2 - 1; i >= 0; --i)\r\nheap_sift(&ca->heap, i, bucket_min_cmp);\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nif (!heap_pop(&ca->heap, b, bucket_min_cmp)) {\r\nca->invalidate_needs_gc = 1;\r\nwake_up_gc(ca->set);\r\nreturn;\r\n}\r\nbch_invalidate_one_bucket(ca, b);\r\n}\r\n}\r\nstatic void invalidate_buckets_fifo(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nsize_t checked = 0;\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nif (ca->fifo_last_bucket < ca->sb.first_bucket ||\r\nca->fifo_last_bucket >= ca->sb.nbuckets)\r\nca->fifo_last_bucket = ca->sb.first_bucket;\r\nb = ca->buckets + ca->fifo_last_bucket++;\r\nif (bch_can_invalidate_bucket(ca, b))\r\nbch_invalidate_one_bucket(ca, b);\r\nif (++checked >= ca->sb.nbuckets) {\r\nca->invalidate_needs_gc = 1;\r\nwake_up_gc(ca->set);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void invalidate_buckets_random(struct cache *ca)\r\n{\r\nstruct bucket *b;\r\nsize_t checked = 0;\r\nwhile (!fifo_full(&ca->free_inc)) {\r\nsize_t n;\r\nget_random_bytes(&n, sizeof(n));\r\nn %= (size_t) (ca->sb.nbuckets - ca->sb.first_bucket);\r\nn += ca->sb.first_bucket;\r\nb = ca->buckets + n;\r\nif (bch_can_invalidate_bucket(ca, b))\r\nbch_invalidate_one_bucket(ca, b);\r\nif (++checked >= ca->sb.nbuckets / 2) {\r\nca->invalidate_needs_gc = 1;\r\nwake_up_gc(ca->set);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void invalidate_buckets(struct cache *ca)\r\n{\r\nBUG_ON(ca->invalidate_needs_gc);\r\nswitch (CACHE_REPLACEMENT(&ca->sb)) {\r\ncase CACHE_REPLACEMENT_LRU:\r\ninvalidate_buckets_lru(ca);\r\nbreak;\r\ncase CACHE_REPLACEMENT_FIFO:\r\ninvalidate_buckets_fifo(ca);\r\nbreak;\r\ncase CACHE_REPLACEMENT_RANDOM:\r\ninvalidate_buckets_random(ca);\r\nbreak;\r\n}\r\n}\r\nstatic int bch_allocator_push(struct cache *ca, long bucket)\r\n{\r\nunsigned i;\r\nif (fifo_push(&ca->free[RESERVE_PRIO], bucket))\r\nreturn true;\r\nfor (i = 0; i < RESERVE_NR; i++)\r\nif (fifo_push(&ca->free[i], bucket))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int bch_allocator_thread(void *arg)\r\n{\r\nstruct cache *ca = arg;\r\nmutex_lock(&ca->set->bucket_lock);\r\nwhile (1) {\r\nwhile (!fifo_empty(&ca->free_inc)) {\r\nlong bucket;\r\nfifo_pop(&ca->free_inc, bucket);\r\nif (ca->discard) {\r\nmutex_unlock(&ca->set->bucket_lock);\r\nblkdev_issue_discard(ca->bdev,\r\nbucket_to_sector(ca->set, bucket),\r\nca->sb.bucket_size, GFP_KERNEL, 0);\r\nmutex_lock(&ca->set->bucket_lock);\r\n}\r\nallocator_wait(ca, bch_allocator_push(ca, bucket));\r\nwake_up(&ca->set->btree_cache_wait);\r\nwake_up(&ca->set->bucket_wait);\r\n}\r\nretry_invalidate:\r\nallocator_wait(ca, ca->set->gc_mark_valid &&\r\n!ca->invalidate_needs_gc);\r\ninvalidate_buckets(ca);\r\nallocator_wait(ca, !atomic_read(&ca->set->prio_blocked));\r\nif (CACHE_SYNC(&ca->set->sb)) {\r\nif (!fifo_full(&ca->free_inc))\r\ngoto retry_invalidate;\r\nbch_prio_write(ca);\r\n}\r\n}\r\n}\r\nlong bch_bucket_alloc(struct cache *ca, unsigned reserve, bool wait)\r\n{\r\nDEFINE_WAIT(w);\r\nstruct bucket *b;\r\nlong r;\r\nif (fifo_pop(&ca->free[RESERVE_NONE], r) ||\r\nfifo_pop(&ca->free[reserve], r))\r\ngoto out;\r\nif (!wait) {\r\ntrace_bcache_alloc_fail(ca, reserve);\r\nreturn -1;\r\n}\r\ndo {\r\nprepare_to_wait(&ca->set->bucket_wait, &w,\r\nTASK_UNINTERRUPTIBLE);\r\nmutex_unlock(&ca->set->bucket_lock);\r\nschedule();\r\nmutex_lock(&ca->set->bucket_lock);\r\n} while (!fifo_pop(&ca->free[RESERVE_NONE], r) &&\r\n!fifo_pop(&ca->free[reserve], r));\r\nfinish_wait(&ca->set->bucket_wait, &w);\r\nout:\r\nwake_up_process(ca->alloc_thread);\r\ntrace_bcache_alloc(ca, reserve);\r\nif (expensive_debug_checks(ca->set)) {\r\nsize_t iter;\r\nlong i;\r\nunsigned j;\r\nfor (iter = 0; iter < prio_buckets(ca) * 2; iter++)\r\nBUG_ON(ca->prio_buckets[iter] == (uint64_t) r);\r\nfor (j = 0; j < RESERVE_NR; j++)\r\nfifo_for_each(i, &ca->free[j], iter)\r\nBUG_ON(i == r);\r\nfifo_for_each(i, &ca->free_inc, iter)\r\nBUG_ON(i == r);\r\n}\r\nb = ca->buckets + r;\r\nBUG_ON(atomic_read(&b->pin) != 1);\r\nSET_GC_SECTORS_USED(b, ca->sb.bucket_size);\r\nif (reserve <= RESERVE_PRIO) {\r\nSET_GC_MARK(b, GC_MARK_METADATA);\r\nSET_GC_MOVE(b, 0);\r\nb->prio = BTREE_PRIO;\r\n} else {\r\nSET_GC_MARK(b, GC_MARK_RECLAIMABLE);\r\nSET_GC_MOVE(b, 0);\r\nb->prio = INITIAL_PRIO;\r\n}\r\nreturn r;\r\n}\r\nvoid __bch_bucket_free(struct cache *ca, struct bucket *b)\r\n{\r\nSET_GC_MARK(b, 0);\r\nSET_GC_SECTORS_USED(b, 0);\r\n}\r\nvoid bch_bucket_free(struct cache_set *c, struct bkey *k)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < KEY_PTRS(k); i++)\r\n__bch_bucket_free(PTR_CACHE(c, k, i),\r\nPTR_BUCKET(c, k, i));\r\n}\r\nint __bch_bucket_alloc_set(struct cache_set *c, unsigned reserve,\r\nstruct bkey *k, int n, bool wait)\r\n{\r\nint i;\r\nlockdep_assert_held(&c->bucket_lock);\r\nBUG_ON(!n || n > c->caches_loaded || n > 8);\r\nbkey_init(k);\r\nfor (i = 0; i < n; i++) {\r\nstruct cache *ca = c->cache_by_alloc[i];\r\nlong b = bch_bucket_alloc(ca, reserve, wait);\r\nif (b == -1)\r\ngoto err;\r\nk->ptr[i] = PTR(ca->buckets[b].gen,\r\nbucket_to_sector(c, b),\r\nca->sb.nr_this_dev);\r\nSET_KEY_PTRS(k, i + 1);\r\n}\r\nreturn 0;\r\nerr:\r\nbch_bucket_free(c, k);\r\nbkey_put(c, k);\r\nreturn -1;\r\n}\r\nint bch_bucket_alloc_set(struct cache_set *c, unsigned reserve,\r\nstruct bkey *k, int n, bool wait)\r\n{\r\nint ret;\r\nmutex_lock(&c->bucket_lock);\r\nret = __bch_bucket_alloc_set(c, reserve, k, n, wait);\r\nmutex_unlock(&c->bucket_lock);\r\nreturn ret;\r\n}\r\nstatic struct open_bucket *pick_data_bucket(struct cache_set *c,\r\nconst struct bkey *search,\r\nunsigned write_point,\r\nstruct bkey *alloc)\r\n{\r\nstruct open_bucket *ret, *ret_task = NULL;\r\nlist_for_each_entry_reverse(ret, &c->data_buckets, list)\r\nif (!bkey_cmp(&ret->key, search))\r\ngoto found;\r\nelse if (ret->last_write_point == write_point)\r\nret_task = ret;\r\nret = ret_task ?: list_first_entry(&c->data_buckets,\r\nstruct open_bucket, list);\r\nfound:\r\nif (!ret->sectors_free && KEY_PTRS(alloc)) {\r\nret->sectors_free = c->sb.bucket_size;\r\nbkey_copy(&ret->key, alloc);\r\nbkey_init(alloc);\r\n}\r\nif (!ret->sectors_free)\r\nret = NULL;\r\nreturn ret;\r\n}\r\nbool bch_alloc_sectors(struct cache_set *c, struct bkey *k, unsigned sectors,\r\nunsigned write_point, unsigned write_prio, bool wait)\r\n{\r\nstruct open_bucket *b;\r\nBKEY_PADDED(key) alloc;\r\nunsigned i;\r\nbkey_init(&alloc.key);\r\nspin_lock(&c->data_bucket_lock);\r\nwhile (!(b = pick_data_bucket(c, k, write_point, &alloc.key))) {\r\nunsigned watermark = write_prio\r\n? RESERVE_MOVINGGC\r\n: RESERVE_NONE;\r\nspin_unlock(&c->data_bucket_lock);\r\nif (bch_bucket_alloc_set(c, watermark, &alloc.key, 1, wait))\r\nreturn false;\r\nspin_lock(&c->data_bucket_lock);\r\n}\r\nif (KEY_PTRS(&alloc.key))\r\nbkey_put(c, &alloc.key);\r\nfor (i = 0; i < KEY_PTRS(&b->key); i++)\r\nEBUG_ON(ptr_stale(c, &b->key, i));\r\nfor (i = 0; i < KEY_PTRS(&b->key); i++)\r\nk->ptr[i] = b->key.ptr[i];\r\nsectors = min(sectors, b->sectors_free);\r\nSET_KEY_OFFSET(k, KEY_OFFSET(k) + sectors);\r\nSET_KEY_SIZE(k, sectors);\r\nSET_KEY_PTRS(k, KEY_PTRS(&b->key));\r\nlist_move_tail(&b->list, &c->data_buckets);\r\nbkey_copy_key(&b->key, k);\r\nb->last_write_point = write_point;\r\nb->sectors_free -= sectors;\r\nfor (i = 0; i < KEY_PTRS(&b->key); i++) {\r\nSET_PTR_OFFSET(&b->key, i, PTR_OFFSET(&b->key, i) + sectors);\r\natomic_long_add(sectors,\r\n&PTR_CACHE(c, &b->key, i)->sectors_written);\r\n}\r\nif (b->sectors_free < c->sb.block_size)\r\nb->sectors_free = 0;\r\nif (b->sectors_free)\r\nfor (i = 0; i < KEY_PTRS(&b->key); i++)\r\natomic_inc(&PTR_BUCKET(c, &b->key, i)->pin);\r\nspin_unlock(&c->data_bucket_lock);\r\nreturn true;\r\n}\r\nvoid bch_open_buckets_free(struct cache_set *c)\r\n{\r\nstruct open_bucket *b;\r\nwhile (!list_empty(&c->data_buckets)) {\r\nb = list_first_entry(&c->data_buckets,\r\nstruct open_bucket, list);\r\nlist_del(&b->list);\r\nkfree(b);\r\n}\r\n}\r\nint bch_open_buckets_alloc(struct cache_set *c)\r\n{\r\nint i;\r\nspin_lock_init(&c->data_bucket_lock);\r\nfor (i = 0; i < 6; i++) {\r\nstruct open_bucket *b = kzalloc(sizeof(*b), GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nlist_add(&b->list, &c->data_buckets);\r\n}\r\nreturn 0;\r\n}\r\nint bch_cache_allocator_start(struct cache *ca)\r\n{\r\nstruct task_struct *k = kthread_run(bch_allocator_thread,\r\nca, "bcache_allocator");\r\nif (IS_ERR(k))\r\nreturn PTR_ERR(k);\r\nca->alloc_thread = k;\r\nreturn 0;\r\n}
