void tmio_mmc_enable_dma(struct tmio_mmc_host *host, bool enable)\r\n{\r\nif (!host->chan_tx || !host->chan_rx)\r\nreturn;\r\nif (host->pdata->flags & TMIO_MMC_HAVE_CTL_DMA_REG)\r\nsd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? 2 : 0);\r\n}\r\nvoid tmio_mmc_abort_dma(struct tmio_mmc_host *host)\r\n{\r\ntmio_mmc_enable_dma(host, false);\r\nif (host->chan_rx)\r\ndmaengine_terminate_all(host->chan_rx);\r\nif (host->chan_tx)\r\ndmaengine_terminate_all(host->chan_tx);\r\ntmio_mmc_enable_dma(host, true);\r\n}\r\nstatic void tmio_mmc_start_dma_rx(struct tmio_mmc_host *host)\r\n{\r\nstruct scatterlist *sg = host->sg_ptr, *sg_tmp;\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\nstruct dma_chan *chan = host->chan_rx;\r\nstruct tmio_mmc_data *pdata = host->pdata;\r\ndma_cookie_t cookie;\r\nint ret, i;\r\nbool aligned = true, multiple = true;\r\nunsigned int align = (1 << pdata->dma->alignment_shift) - 1;\r\nfor_each_sg(sg, sg_tmp, host->sg_len, i) {\r\nif (sg_tmp->offset & align)\r\naligned = false;\r\nif (sg_tmp->length & align) {\r\nmultiple = false;\r\nbreak;\r\n}\r\n}\r\nif ((!aligned && (host->sg_len > 1 || sg->length > PAGE_CACHE_SIZE ||\r\n(align & PAGE_MASK))) || !multiple) {\r\nret = -EINVAL;\r\ngoto pio;\r\n}\r\nif (sg->length < TMIO_MMC_MIN_DMA_LEN) {\r\nhost->force_pio = true;\r\nreturn;\r\n}\r\ntmio_mmc_disable_mmc_irqs(host, TMIO_STAT_RXRDY);\r\nif (!aligned) {\r\nsg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);\r\nhost->sg_ptr = &host->bounce_sg;\r\nsg = host->sg_ptr;\r\n}\r\nret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_FROM_DEVICE);\r\nif (ret > 0)\r\ndesc = dmaengine_prep_slave_sg(chan, sg, ret,\r\nDMA_DEV_TO_MEM, DMA_CTRL_ACK);\r\nif (desc) {\r\ncookie = dmaengine_submit(desc);\r\nif (cookie < 0) {\r\ndesc = NULL;\r\nret = cookie;\r\n}\r\n}\r\ndev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",\r\n__func__, host->sg_len, ret, cookie, host->mrq);\r\npio:\r\nif (!desc) {\r\ntmio_mmc_enable_dma(host, false);\r\nif (ret >= 0)\r\nret = -EIO;\r\nhost->chan_rx = NULL;\r\ndma_release_channel(chan);\r\nchan = host->chan_tx;\r\nif (chan) {\r\nhost->chan_tx = NULL;\r\ndma_release_channel(chan);\r\n}\r\ndev_warn(&host->pdev->dev,\r\n"DMA failed: %d, falling back to PIO\n", ret);\r\n}\r\ndev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,\r\ndesc, cookie, host->sg_len);\r\n}\r\nstatic void tmio_mmc_start_dma_tx(struct tmio_mmc_host *host)\r\n{\r\nstruct scatterlist *sg = host->sg_ptr, *sg_tmp;\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\nstruct dma_chan *chan = host->chan_tx;\r\nstruct tmio_mmc_data *pdata = host->pdata;\r\ndma_cookie_t cookie;\r\nint ret, i;\r\nbool aligned = true, multiple = true;\r\nunsigned int align = (1 << pdata->dma->alignment_shift) - 1;\r\nfor_each_sg(sg, sg_tmp, host->sg_len, i) {\r\nif (sg_tmp->offset & align)\r\naligned = false;\r\nif (sg_tmp->length & align) {\r\nmultiple = false;\r\nbreak;\r\n}\r\n}\r\nif ((!aligned && (host->sg_len > 1 || sg->length > PAGE_CACHE_SIZE ||\r\n(align & PAGE_MASK))) || !multiple) {\r\nret = -EINVAL;\r\ngoto pio;\r\n}\r\nif (sg->length < TMIO_MMC_MIN_DMA_LEN) {\r\nhost->force_pio = true;\r\nreturn;\r\n}\r\ntmio_mmc_disable_mmc_irqs(host, TMIO_STAT_TXRQ);\r\nif (!aligned) {\r\nunsigned long flags;\r\nvoid *sg_vaddr = tmio_mmc_kmap_atomic(sg, &flags);\r\nsg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);\r\nmemcpy(host->bounce_buf, sg_vaddr, host->bounce_sg.length);\r\ntmio_mmc_kunmap_atomic(sg, &flags, sg_vaddr);\r\nhost->sg_ptr = &host->bounce_sg;\r\nsg = host->sg_ptr;\r\n}\r\nret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_TO_DEVICE);\r\nif (ret > 0)\r\ndesc = dmaengine_prep_slave_sg(chan, sg, ret,\r\nDMA_MEM_TO_DEV, DMA_CTRL_ACK);\r\nif (desc) {\r\ncookie = dmaengine_submit(desc);\r\nif (cookie < 0) {\r\ndesc = NULL;\r\nret = cookie;\r\n}\r\n}\r\ndev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",\r\n__func__, host->sg_len, ret, cookie, host->mrq);\r\npio:\r\nif (!desc) {\r\ntmio_mmc_enable_dma(host, false);\r\nif (ret >= 0)\r\nret = -EIO;\r\nhost->chan_tx = NULL;\r\ndma_release_channel(chan);\r\nchan = host->chan_rx;\r\nif (chan) {\r\nhost->chan_rx = NULL;\r\ndma_release_channel(chan);\r\n}\r\ndev_warn(&host->pdev->dev,\r\n"DMA failed: %d, falling back to PIO\n", ret);\r\n}\r\ndev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d\n", __func__,\r\ndesc, cookie);\r\n}\r\nvoid tmio_mmc_start_dma(struct tmio_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nif (data->flags & MMC_DATA_READ) {\r\nif (host->chan_rx)\r\ntmio_mmc_start_dma_rx(host);\r\n} else {\r\nif (host->chan_tx)\r\ntmio_mmc_start_dma_tx(host);\r\n}\r\n}\r\nstatic void tmio_mmc_issue_tasklet_fn(unsigned long priv)\r\n{\r\nstruct tmio_mmc_host *host = (struct tmio_mmc_host *)priv;\r\nstruct dma_chan *chan = NULL;\r\nspin_lock_irq(&host->lock);\r\nif (host && host->data) {\r\nif (host->data->flags & MMC_DATA_READ)\r\nchan = host->chan_rx;\r\nelse\r\nchan = host->chan_tx;\r\n}\r\nspin_unlock_irq(&host->lock);\r\ntmio_mmc_enable_mmc_irqs(host, TMIO_STAT_DATAEND);\r\nif (chan)\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void tmio_mmc_tasklet_fn(unsigned long arg)\r\n{\r\nstruct tmio_mmc_host *host = (struct tmio_mmc_host *)arg;\r\nspin_lock_irq(&host->lock);\r\nif (!host->data)\r\ngoto out;\r\nif (host->data->flags & MMC_DATA_READ)\r\ndma_unmap_sg(host->chan_rx->device->dev,\r\nhost->sg_ptr, host->sg_len,\r\nDMA_FROM_DEVICE);\r\nelse\r\ndma_unmap_sg(host->chan_tx->device->dev,\r\nhost->sg_ptr, host->sg_len,\r\nDMA_TO_DEVICE);\r\ntmio_mmc_do_data_irq(host);\r\nout:\r\nspin_unlock_irq(&host->lock);\r\n}\r\nvoid tmio_mmc_request_dma(struct tmio_mmc_host *host, struct tmio_mmc_data *pdata)\r\n{\r\nif (!pdata->dma || (!host->pdev->dev.of_node &&\r\n(!pdata->dma->chan_priv_tx || !pdata->dma->chan_priv_rx)))\r\nreturn;\r\nif (!host->chan_tx && !host->chan_rx) {\r\nstruct resource *res = platform_get_resource(host->pdev,\r\nIORESOURCE_MEM, 0);\r\nstruct dma_slave_config cfg = {};\r\ndma_cap_mask_t mask;\r\nint ret;\r\nif (!res)\r\nreturn;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->chan_tx = dma_request_slave_channel_compat(mask,\r\npdata->dma->filter, pdata->dma->chan_priv_tx,\r\n&host->pdev->dev, "tx");\r\ndev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,\r\nhost->chan_tx);\r\nif (!host->chan_tx)\r\nreturn;\r\nif (pdata->dma->chan_priv_tx)\r\ncfg.slave_id = pdata->dma->slave_id_tx;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\ncfg.dst_addr = res->start + (CTL_SD_DATA_PORT << host->pdata->bus_shift);\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\ncfg.src_addr = 0;\r\nret = dmaengine_slave_config(host->chan_tx, &cfg);\r\nif (ret < 0)\r\ngoto ecfgtx;\r\nhost->chan_rx = dma_request_slave_channel_compat(mask,\r\npdata->dma->filter, pdata->dma->chan_priv_rx,\r\n&host->pdev->dev, "rx");\r\ndev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,\r\nhost->chan_rx);\r\nif (!host->chan_rx)\r\ngoto ereqrx;\r\nif (pdata->dma->chan_priv_rx)\r\ncfg.slave_id = pdata->dma->slave_id_rx;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\ncfg.src_addr = cfg.dst_addr + pdata->dma->dma_rx_offset;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\ncfg.dst_addr = 0;\r\nret = dmaengine_slave_config(host->chan_rx, &cfg);\r\nif (ret < 0)\r\ngoto ecfgrx;\r\nhost->bounce_buf = (u8 *)__get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!host->bounce_buf)\r\ngoto ebouncebuf;\r\ntasklet_init(&host->dma_complete, tmio_mmc_tasklet_fn, (unsigned long)host);\r\ntasklet_init(&host->dma_issue, tmio_mmc_issue_tasklet_fn, (unsigned long)host);\r\n}\r\ntmio_mmc_enable_dma(host, true);\r\nreturn;\r\nebouncebuf:\r\necfgrx:\r\ndma_release_channel(host->chan_rx);\r\nhost->chan_rx = NULL;\r\nereqrx:\r\necfgtx:\r\ndma_release_channel(host->chan_tx);\r\nhost->chan_tx = NULL;\r\n}\r\nvoid tmio_mmc_release_dma(struct tmio_mmc_host *host)\r\n{\r\nif (host->chan_tx) {\r\nstruct dma_chan *chan = host->chan_tx;\r\nhost->chan_tx = NULL;\r\ndma_release_channel(chan);\r\n}\r\nif (host->chan_rx) {\r\nstruct dma_chan *chan = host->chan_rx;\r\nhost->chan_rx = NULL;\r\ndma_release_channel(chan);\r\n}\r\nif (host->bounce_buf) {\r\nfree_pages((unsigned long)host->bounce_buf, 0);\r\nhost->bounce_buf = NULL;\r\n}\r\n}
