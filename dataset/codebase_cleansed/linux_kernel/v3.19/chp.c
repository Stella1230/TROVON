static void set_chp_logically_online(struct chp_id chpid, int onoff)\r\n{\r\nchpid_to_chp(chpid)->state = onoff;\r\n}\r\nint chp_get_status(struct chp_id chpid)\r\n{\r\nreturn (chpid_to_chp(chpid) ? chpid_to_chp(chpid)->state : -ENODEV);\r\n}\r\nu8 chp_get_sch_opm(struct subchannel *sch)\r\n{\r\nstruct chp_id chpid;\r\nint opm;\r\nint i;\r\nopm = 0;\r\nchp_id_init(&chpid);\r\nfor (i = 0; i < 8; i++) {\r\nopm <<= 1;\r\nchpid.id = sch->schib.pmcw.chpid[i];\r\nif (chp_get_status(chpid) != 0)\r\nopm |= 1;\r\n}\r\nreturn opm;\r\n}\r\nint chp_is_registered(struct chp_id chpid)\r\n{\r\nreturn chpid_to_chp(chpid) != NULL;\r\n}\r\nstatic int s390_vary_chpid(struct chp_id chpid, int on)\r\n{\r\nchar dbf_text[15];\r\nint status;\r\nsprintf(dbf_text, on?"varyon%x.%02x":"varyoff%x.%02x", chpid.cssid,\r\nchpid.id);\r\nCIO_TRACE_EVENT(2, dbf_text);\r\nstatus = chp_get_status(chpid);\r\nif (!on && !status)\r\nreturn 0;\r\nset_chp_logically_online(chpid, on);\r\nchsc_chp_vary(chpid, on);\r\nreturn 0;\r\n}\r\nstatic ssize_t chp_measurement_chars_read(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct channel_path *chp;\r\nstruct device *device;\r\ndevice = container_of(kobj, struct device, kobj);\r\nchp = to_channelpath(device);\r\nif (!chp->cmg_chars)\r\nreturn 0;\r\nreturn memory_read_from_buffer(buf, count, &off,\r\nchp->cmg_chars, sizeof(struct cmg_chars));\r\n}\r\nstatic void chp_measurement_copy_block(struct cmg_entry *buf,\r\nstruct channel_subsystem *css,\r\nstruct chp_id chpid)\r\n{\r\nvoid *area;\r\nstruct cmg_entry *entry, reference_buf;\r\nint idx;\r\nif (chpid.id < 128) {\r\narea = css->cub_addr1;\r\nidx = chpid.id;\r\n} else {\r\narea = css->cub_addr2;\r\nidx = chpid.id - 128;\r\n}\r\nentry = area + (idx * sizeof(struct cmg_entry));\r\ndo {\r\nmemcpy(buf, entry, sizeof(*entry));\r\nmemcpy(&reference_buf, entry, sizeof(*entry));\r\n} while (reference_buf.values[0] != buf->values[0]);\r\n}\r\nstatic ssize_t chp_measurement_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct channel_path *chp;\r\nstruct channel_subsystem *css;\r\nstruct device *device;\r\nunsigned int size;\r\ndevice = container_of(kobj, struct device, kobj);\r\nchp = to_channelpath(device);\r\ncss = to_css(chp->dev.parent);\r\nsize = sizeof(struct cmg_entry);\r\nif (off || count < size)\r\nreturn 0;\r\nchp_measurement_copy_block((struct cmg_entry *)buf, css, chp->chpid);\r\ncount = size;\r\nreturn count;\r\n}\r\nvoid chp_remove_cmg_attr(struct channel_path *chp)\r\n{\r\ndevice_remove_bin_file(&chp->dev, &chp_measurement_chars_attr);\r\ndevice_remove_bin_file(&chp->dev, &chp_measurement_attr);\r\n}\r\nint chp_add_cmg_attr(struct channel_path *chp)\r\n{\r\nint ret;\r\nret = device_create_bin_file(&chp->dev, &chp_measurement_chars_attr);\r\nif (ret)\r\nreturn ret;\r\nret = device_create_bin_file(&chp->dev, &chp_measurement_attr);\r\nif (ret)\r\ndevice_remove_bin_file(&chp->dev, &chp_measurement_chars_attr);\r\nreturn ret;\r\n}\r\nstatic ssize_t chp_status_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nint status;\r\nmutex_lock(&chp->lock);\r\nstatus = chp->state;\r\nmutex_unlock(&chp->lock);\r\nreturn status ? sprintf(buf, "online\n") : sprintf(buf, "offline\n");\r\n}\r\nstatic ssize_t chp_status_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct channel_path *cp = to_channelpath(dev);\r\nchar cmd[10];\r\nint num_args;\r\nint error;\r\nnum_args = sscanf(buf, "%5s", cmd);\r\nif (!num_args)\r\nreturn count;\r\nif (!strncasecmp(cmd, "on", 2) || !strcmp(cmd, "1")) {\r\nmutex_lock(&cp->lock);\r\nerror = s390_vary_chpid(cp->chpid, 1);\r\nmutex_unlock(&cp->lock);\r\n} else if (!strncasecmp(cmd, "off", 3) || !strcmp(cmd, "0")) {\r\nmutex_lock(&cp->lock);\r\nerror = s390_vary_chpid(cp->chpid, 0);\r\nmutex_unlock(&cp->lock);\r\n} else\r\nerror = -EINVAL;\r\nreturn error < 0 ? error : count;\r\n}\r\nstatic ssize_t chp_configure_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct channel_path *cp;\r\nint status;\r\ncp = to_channelpath(dev);\r\nstatus = chp_info_get_status(cp->chpid);\r\nif (status < 0)\r\nreturn status;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", status);\r\n}\r\nstatic ssize_t chp_configure_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct channel_path *cp;\r\nint val;\r\nchar delim;\r\nif (sscanf(buf, "%d %c", &val, &delim) != 1)\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\ncp = to_channelpath(dev);\r\nchp_cfg_schedule(cp->chpid, val);\r\ncfg_wait_idle();\r\nreturn count;\r\n}\r\nstatic ssize_t chp_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nu8 type;\r\nmutex_lock(&chp->lock);\r\ntype = chp->desc.desc;\r\nmutex_unlock(&chp->lock);\r\nreturn sprintf(buf, "%x\n", type);\r\n}\r\nstatic ssize_t chp_cmg_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nif (!chp)\r\nreturn 0;\r\nif (chp->cmg == -1)\r\nreturn sprintf(buf, "unknown\n");\r\nreturn sprintf(buf, "%x\n", chp->cmg);\r\n}\r\nstatic ssize_t chp_shared_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nif (!chp)\r\nreturn 0;\r\nif (chp->shared == -1)\r\nreturn sprintf(buf, "unknown\n");\r\nreturn sprintf(buf, "%x\n", chp->shared);\r\n}\r\nstatic ssize_t chp_chid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nssize_t rc;\r\nmutex_lock(&chp->lock);\r\nif (chp->desc_fmt1.flags & 0x10)\r\nrc = sprintf(buf, "%04x\n", chp->desc_fmt1.chid);\r\nelse\r\nrc = 0;\r\nmutex_unlock(&chp->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t chp_chid_external_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct channel_path *chp = to_channelpath(dev);\r\nssize_t rc;\r\nmutex_lock(&chp->lock);\r\nif (chp->desc_fmt1.flags & 0x10)\r\nrc = sprintf(buf, "%x\n", chp->desc_fmt1.flags & 0x8 ? 1 : 0);\r\nelse\r\nrc = 0;\r\nmutex_unlock(&chp->lock);\r\nreturn rc;\r\n}\r\nstatic void chp_release(struct device *dev)\r\n{\r\nstruct channel_path *cp;\r\ncp = to_channelpath(dev);\r\nkfree(cp);\r\n}\r\nint chp_update_desc(struct channel_path *chp)\r\n{\r\nint rc;\r\nrc = chsc_determine_base_channel_path_desc(chp->chpid, &chp->desc);\r\nif (rc)\r\nreturn rc;\r\nrc = chsc_determine_fmt1_channel_path_desc(chp->chpid, &chp->desc_fmt1);\r\nreturn rc;\r\n}\r\nint chp_new(struct chp_id chpid)\r\n{\r\nstruct channel_path *chp;\r\nint ret;\r\nif (chp_is_registered(chpid))\r\nreturn 0;\r\nchp = kzalloc(sizeof(struct channel_path), GFP_KERNEL);\r\nif (!chp)\r\nreturn -ENOMEM;\r\nchp->chpid = chpid;\r\nchp->state = 1;\r\nchp->dev.parent = &channel_subsystems[chpid.cssid]->device;\r\nchp->dev.groups = chp_attr_groups;\r\nchp->dev.release = chp_release;\r\nmutex_init(&chp->lock);\r\nret = chp_update_desc(chp);\r\nif (ret)\r\ngoto out_free;\r\nif ((chp->desc.flags & 0x80) == 0) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (css_chsc_characteristics.scmc && css_chsc_characteristics.secm) {\r\nret = chsc_get_channel_measurement_chars(chp);\r\nif (ret)\r\ngoto out_free;\r\n} else {\r\nchp->cmg = -1;\r\n}\r\ndev_set_name(&chp->dev, "chp%x.%02x", chpid.cssid, chpid.id);\r\nret = device_register(&chp->dev);\r\nif (ret) {\r\nCIO_MSG_EVENT(0, "Could not register chp%x.%02x: %d\n",\r\nchpid.cssid, chpid.id, ret);\r\nput_device(&chp->dev);\r\ngoto out;\r\n}\r\nmutex_lock(&channel_subsystems[chpid.cssid]->mutex);\r\nif (channel_subsystems[chpid.cssid]->cm_enabled) {\r\nret = chp_add_cmg_attr(chp);\r\nif (ret) {\r\ndevice_unregister(&chp->dev);\r\nmutex_unlock(&channel_subsystems[chpid.cssid]->mutex);\r\ngoto out;\r\n}\r\n}\r\nchannel_subsystems[chpid.cssid]->chps[chpid.id] = chp;\r\nmutex_unlock(&channel_subsystems[chpid.cssid]->mutex);\r\ngoto out;\r\nout_free:\r\nkfree(chp);\r\nout:\r\nreturn ret;\r\n}\r\nstruct channel_path_desc *chp_get_chp_desc(struct chp_id chpid)\r\n{\r\nstruct channel_path *chp;\r\nstruct channel_path_desc *desc;\r\nchp = chpid_to_chp(chpid);\r\nif (!chp)\r\nreturn NULL;\r\ndesc = kmalloc(sizeof(struct channel_path_desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn NULL;\r\nmutex_lock(&chp->lock);\r\nmemcpy(desc, &chp->desc, sizeof(struct channel_path_desc));\r\nmutex_unlock(&chp->lock);\r\nreturn desc;\r\n}\r\nstatic void chp_process_crw(struct crw *crw0, struct crw *crw1,\r\nint overflow)\r\n{\r\nstruct chp_id chpid;\r\nif (overflow) {\r\ncss_schedule_eval_all();\r\nreturn;\r\n}\r\nCIO_CRW_EVENT(2, "CRW reports slct=%d, oflw=%d, "\r\n"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\n",\r\ncrw0->slct, crw0->oflw, crw0->chn, crw0->rsc, crw0->anc,\r\ncrw0->erc, crw0->rsid);\r\nif (crw0->slct) {\r\nCIO_CRW_EVENT(2, "solicited machine check for "\r\n"channel path %02X\n", crw0->rsid);\r\nreturn;\r\n}\r\nchp_id_init(&chpid);\r\nchpid.id = crw0->rsid;\r\nswitch (crw0->erc) {\r\ncase CRW_ERC_IPARM:\r\nif (!chp_is_registered(chpid))\r\nchp_new(chpid);\r\nchsc_chp_online(chpid);\r\nbreak;\r\ncase CRW_ERC_PERRI:\r\ncase CRW_ERC_PERRN:\r\nchsc_chp_offline(chpid);\r\nbreak;\r\ndefault:\r\nCIO_CRW_EVENT(2, "Don't know how to handle erc=%x\n",\r\ncrw0->erc);\r\n}\r\n}\r\nint chp_ssd_get_mask(struct chsc_ssd_info *ssd, struct chp_link *link)\r\n{\r\nint i;\r\nint mask;\r\nfor (i = 0; i < 8; i++) {\r\nmask = 0x80 >> i;\r\nif (!(ssd->path_mask & mask))\r\ncontinue;\r\nif (!chp_id_is_equal(&ssd->chpid[i], &link->chpid))\r\ncontinue;\r\nif ((ssd->fla_valid_mask & mask) &&\r\n((ssd->fla[i] & link->fla_mask) != link->fla))\r\ncontinue;\r\nreturn mask;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int info_bit_num(struct chp_id id)\r\n{\r\nreturn id.id + id.cssid * (__MAX_CHPID + 1);\r\n}\r\nstatic void info_expire(void)\r\n{\r\nmutex_lock(&info_lock);\r\nchp_info_expires = jiffies - 1;\r\nmutex_unlock(&info_lock);\r\n}\r\nstatic int info_update(void)\r\n{\r\nint rc;\r\nmutex_lock(&info_lock);\r\nrc = 0;\r\nif (time_after(jiffies, chp_info_expires)) {\r\nrc = sclp_chp_read_info(&chp_info);\r\nchp_info_expires = jiffies + CHP_INFO_UPDATE_INTERVAL ;\r\n}\r\nmutex_unlock(&info_lock);\r\nreturn rc;\r\n}\r\nint chp_info_get_status(struct chp_id chpid)\r\n{\r\nint rc;\r\nint bit;\r\nrc = info_update();\r\nif (rc)\r\nreturn rc;\r\nbit = info_bit_num(chpid);\r\nmutex_lock(&info_lock);\r\nif (!chp_test_bit(chp_info.recognized, bit))\r\nrc = CHP_STATUS_NOT_RECOGNIZED;\r\nelse if (chp_test_bit(chp_info.configured, bit))\r\nrc = CHP_STATUS_CONFIGURED;\r\nelse if (chp_test_bit(chp_info.standby, bit))\r\nrc = CHP_STATUS_STANDBY;\r\nelse\r\nrc = CHP_STATUS_RESERVED;\r\nmutex_unlock(&info_lock);\r\nreturn rc;\r\n}\r\nstatic enum cfg_task_t cfg_get_task(struct chp_id chpid)\r\n{\r\nreturn chp_cfg_task[chpid.cssid][chpid.id];\r\n}\r\nstatic void cfg_set_task(struct chp_id chpid, enum cfg_task_t cfg)\r\n{\r\nchp_cfg_task[chpid.cssid][chpid.id] = cfg;\r\n}\r\nstatic void cfg_func(struct work_struct *work)\r\n{\r\nstruct chp_id chpid;\r\nenum cfg_task_t t;\r\nint rc;\r\nmutex_lock(&cfg_lock);\r\nt = cfg_none;\r\nchp_id_for_each(&chpid) {\r\nt = cfg_get_task(chpid);\r\nif (t != cfg_none) {\r\ncfg_set_task(chpid, cfg_none);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&cfg_lock);\r\nswitch (t) {\r\ncase cfg_configure:\r\nrc = sclp_chp_configure(chpid);\r\nif (rc)\r\nCIO_MSG_EVENT(2, "chp: sclp_chp_configure(%x.%02x)="\r\n"%d\n", chpid.cssid, chpid.id, rc);\r\nelse {\r\ninfo_expire();\r\nchsc_chp_online(chpid);\r\n}\r\nbreak;\r\ncase cfg_deconfigure:\r\nrc = sclp_chp_deconfigure(chpid);\r\nif (rc)\r\nCIO_MSG_EVENT(2, "chp: sclp_chp_deconfigure(%x.%02x)="\r\n"%d\n", chpid.cssid, chpid.id, rc);\r\nelse {\r\ninfo_expire();\r\nchsc_chp_offline(chpid);\r\n}\r\nbreak;\r\ncase cfg_none:\r\ninfo_update();\r\nmutex_lock(&cfg_lock);\r\ncfg_busy = 0;\r\nmutex_unlock(&cfg_lock);\r\nwake_up_interruptible(&cfg_wait_queue);\r\nreturn;\r\n}\r\nqueue_work(chp_wq, &cfg_work);\r\n}\r\nvoid chp_cfg_schedule(struct chp_id chpid, int configure)\r\n{\r\nCIO_MSG_EVENT(2, "chp_cfg_sched%x.%02x=%d\n", chpid.cssid, chpid.id,\r\nconfigure);\r\nmutex_lock(&cfg_lock);\r\ncfg_set_task(chpid, configure ? cfg_configure : cfg_deconfigure);\r\ncfg_busy = 1;\r\nmutex_unlock(&cfg_lock);\r\nqueue_work(chp_wq, &cfg_work);\r\n}\r\nvoid chp_cfg_cancel_deconfigure(struct chp_id chpid)\r\n{\r\nCIO_MSG_EVENT(2, "chp_cfg_cancel:%x.%02x\n", chpid.cssid, chpid.id);\r\nmutex_lock(&cfg_lock);\r\nif (cfg_get_task(chpid) == cfg_deconfigure)\r\ncfg_set_task(chpid, cfg_none);\r\nmutex_unlock(&cfg_lock);\r\n}\r\nstatic int cfg_wait_idle(void)\r\n{\r\nif (wait_event_interruptible(cfg_wait_queue, !cfg_busy))\r\nreturn -ERESTARTSYS;\r\nreturn 0;\r\n}\r\nstatic int __init chp_init(void)\r\n{\r\nstruct chp_id chpid;\r\nint ret;\r\nret = crw_register_handler(CRW_RSC_CPATH, chp_process_crw);\r\nif (ret)\r\nreturn ret;\r\nchp_wq = create_singlethread_workqueue("cio_chp");\r\nif (!chp_wq) {\r\ncrw_unregister_handler(CRW_RSC_CPATH);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&cfg_work, cfg_func);\r\ninit_waitqueue_head(&cfg_wait_queue);\r\nif (info_update())\r\nreturn 0;\r\nchp_id_for_each(&chpid) {\r\nif (chp_info_get_status(chpid) != CHP_STATUS_NOT_RECOGNIZED)\r\nchp_new(chpid);\r\n}\r\nreturn 0;\r\n}
