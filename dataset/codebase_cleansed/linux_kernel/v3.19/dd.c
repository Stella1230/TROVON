static void deferred_probe_work_func(struct work_struct *work)\r\n{\r\nstruct device *dev;\r\nstruct device_private *private;\r\nmutex_lock(&deferred_probe_mutex);\r\nwhile (!list_empty(&deferred_probe_active_list)) {\r\nprivate = list_first_entry(&deferred_probe_active_list,\r\ntypeof(*dev->p), deferred_probe);\r\ndev = private->device;\r\nlist_del_init(&private->deferred_probe);\r\nget_device(dev);\r\nmutex_unlock(&deferred_probe_mutex);\r\ndevice_pm_lock();\r\ndevice_pm_move_last(dev);\r\ndevice_pm_unlock();\r\ndev_dbg(dev, "Retrying from deferred list\n");\r\nbus_probe_device(dev);\r\nmutex_lock(&deferred_probe_mutex);\r\nput_device(dev);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nstatic void driver_deferred_probe_add(struct device *dev)\r\n{\r\nmutex_lock(&deferred_probe_mutex);\r\nif (list_empty(&dev->p->deferred_probe)) {\r\ndev_dbg(dev, "Added to deferred list\n");\r\nlist_add_tail(&dev->p->deferred_probe, &deferred_probe_pending_list);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nvoid driver_deferred_probe_del(struct device *dev)\r\n{\r\nmutex_lock(&deferred_probe_mutex);\r\nif (!list_empty(&dev->p->deferred_probe)) {\r\ndev_dbg(dev, "Removed from deferred list\n");\r\nlist_del_init(&dev->p->deferred_probe);\r\n}\r\nmutex_unlock(&deferred_probe_mutex);\r\n}\r\nstatic void driver_deferred_probe_trigger(void)\r\n{\r\nif (!driver_deferred_probe_enable)\r\nreturn;\r\nmutex_lock(&deferred_probe_mutex);\r\natomic_inc(&deferred_trigger_count);\r\nlist_splice_tail_init(&deferred_probe_pending_list,\r\n&deferred_probe_active_list);\r\nmutex_unlock(&deferred_probe_mutex);\r\nqueue_work(deferred_wq, &deferred_probe_work);\r\n}\r\nstatic int deferred_probe_initcall(void)\r\n{\r\ndeferred_wq = create_singlethread_workqueue("deferwq");\r\nif (WARN_ON(!deferred_wq))\r\nreturn -ENOMEM;\r\ndriver_deferred_probe_enable = true;\r\ndriver_deferred_probe_trigger();\r\nflush_workqueue(deferred_wq);\r\nreturn 0;\r\n}\r\nstatic void driver_bound(struct device *dev)\r\n{\r\nif (klist_node_attached(&dev->p->knode_driver)) {\r\nprintk(KERN_WARNING "%s: device %s already bound\n",\r\n__func__, kobject_name(&dev->kobj));\r\nreturn;\r\n}\r\npr_debug("driver: '%s': %s: bound to device '%s'\n", dev->driver->name,\r\n__func__, dev_name(dev));\r\nklist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);\r\ndriver_deferred_probe_del(dev);\r\ndriver_deferred_probe_trigger();\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BOUND_DRIVER, dev);\r\n}\r\nstatic int driver_sysfs_add(struct device *dev)\r\n{\r\nint ret;\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_BIND_DRIVER, dev);\r\nret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,\r\nkobject_name(&dev->kobj));\r\nif (ret == 0) {\r\nret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,\r\n"driver");\r\nif (ret)\r\nsysfs_remove_link(&dev->driver->p->kobj,\r\nkobject_name(&dev->kobj));\r\n}\r\nreturn ret;\r\n}\r\nstatic void driver_sysfs_remove(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (drv) {\r\nsysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));\r\nsysfs_remove_link(&dev->kobj, "driver");\r\n}\r\n}\r\nint device_bind_driver(struct device *dev)\r\n{\r\nint ret;\r\nret = driver_sysfs_add(dev);\r\nif (!ret)\r\ndriver_bound(dev);\r\nreturn ret;\r\n}\r\nstatic int really_probe(struct device *dev, struct device_driver *drv)\r\n{\r\nint ret = 0;\r\nint local_trigger_count = atomic_read(&deferred_trigger_count);\r\natomic_inc(&probe_count);\r\npr_debug("bus: '%s': %s: probing driver %s with device %s\n",\r\ndrv->bus->name, __func__, drv->name, dev_name(dev));\r\nWARN_ON(!list_empty(&dev->devres_head));\r\ndev->driver = drv;\r\nret = pinctrl_bind_pins(dev);\r\nif (ret)\r\ngoto probe_failed;\r\nif (driver_sysfs_add(dev)) {\r\nprintk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",\r\n__func__, dev_name(dev));\r\ngoto probe_failed;\r\n}\r\nif (dev->bus->probe) {\r\nret = dev->bus->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n} else if (drv->probe) {\r\nret = drv->probe(dev);\r\nif (ret)\r\ngoto probe_failed;\r\n}\r\ndriver_bound(dev);\r\nret = 1;\r\npr_debug("bus: '%s': %s: bound device %s to driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\ngoto done;\r\nprobe_failed:\r\ndevres_release_all(dev);\r\ndriver_sysfs_remove(dev);\r\ndev->driver = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nif (ret == -EPROBE_DEFER) {\r\ndev_info(dev, "Driver %s requests probe deferral\n", drv->name);\r\ndriver_deferred_probe_add(dev);\r\nif (local_trigger_count != atomic_read(&deferred_trigger_count))\r\ndriver_deferred_probe_trigger();\r\n} else if (ret != -ENODEV && ret != -ENXIO) {\r\nprintk(KERN_WARNING\r\n"%s: probe of %s failed with error %d\n",\r\ndrv->name, dev_name(dev), ret);\r\n} else {\r\npr_debug("%s: probe of %s rejects match %d\n",\r\ndrv->name, dev_name(dev), ret);\r\n}\r\nret = 0;\r\ndone:\r\natomic_dec(&probe_count);\r\nwake_up(&probe_waitqueue);\r\nreturn ret;\r\n}\r\nint driver_probe_done(void)\r\n{\r\npr_debug("%s: probe_count = %d\n", __func__,\r\natomic_read(&probe_count));\r\nif (atomic_read(&probe_count))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nvoid wait_for_device_probe(void)\r\n{\r\nwait_event(probe_waitqueue, atomic_read(&probe_count) == 0);\r\nasync_synchronize_full();\r\n}\r\nint driver_probe_device(struct device_driver *drv, struct device *dev)\r\n{\r\nint ret = 0;\r\nif (!device_is_registered(dev))\r\nreturn -ENODEV;\r\npr_debug("bus: '%s': %s: matched device %s with driver %s\n",\r\ndrv->bus->name, __func__, dev_name(dev), drv->name);\r\npm_runtime_barrier(dev);\r\nret = really_probe(dev, drv);\r\npm_request_idle(dev);\r\nreturn ret;\r\n}\r\nstatic int __device_attach(struct device_driver *drv, void *data)\r\n{\r\nstruct device *dev = data;\r\nif (!driver_match_device(drv, dev))\r\nreturn 0;\r\nreturn driver_probe_device(drv, dev);\r\n}\r\nint device_attach(struct device *dev)\r\n{\r\nint ret = 0;\r\ndevice_lock(dev);\r\nif (dev->driver) {\r\nif (klist_node_attached(&dev->p->knode_driver)) {\r\nret = 1;\r\ngoto out_unlock;\r\n}\r\nret = device_bind_driver(dev);\r\nif (ret == 0)\r\nret = 1;\r\nelse {\r\ndev->driver = NULL;\r\nret = 0;\r\n}\r\n} else {\r\nret = bus_for_each_drv(dev->bus, NULL, dev, __device_attach);\r\npm_request_idle(dev);\r\n}\r\nout_unlock:\r\ndevice_unlock(dev);\r\nreturn ret;\r\n}\r\nstatic int __driver_attach(struct device *dev, void *data)\r\n{\r\nstruct device_driver *drv = data;\r\nif (!driver_match_device(drv, dev))\r\nreturn 0;\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (!dev->driver)\r\ndriver_probe_device(drv, dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nreturn 0;\r\n}\r\nint driver_attach(struct device_driver *drv)\r\n{\r\nreturn bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\r\n}\r\nstatic void __device_release_driver(struct device *dev)\r\n{\r\nstruct device_driver *drv;\r\ndrv = dev->driver;\r\nif (drv) {\r\npm_runtime_get_sync(dev);\r\ndriver_sysfs_remove(dev);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBIND_DRIVER,\r\ndev);\r\npm_runtime_put_sync(dev);\r\nif (dev->bus && dev->bus->remove)\r\ndev->bus->remove(dev);\r\nelse if (drv->remove)\r\ndrv->remove(dev);\r\ndevres_release_all(dev);\r\ndev->driver = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nklist_remove(&dev->p->knode_driver);\r\nif (dev->bus)\r\nblocking_notifier_call_chain(&dev->bus->p->bus_notifier,\r\nBUS_NOTIFY_UNBOUND_DRIVER,\r\ndev);\r\n}\r\n}\r\nvoid device_release_driver(struct device *dev)\r\n{\r\ndevice_lock(dev);\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\n}\r\nvoid driver_detach(struct device_driver *drv)\r\n{\r\nstruct device_private *dev_prv;\r\nstruct device *dev;\r\nfor (;;) {\r\nspin_lock(&drv->p->klist_devices.k_lock);\r\nif (list_empty(&drv->p->klist_devices.k_list)) {\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nbreak;\r\n}\r\ndev_prv = list_entry(drv->p->klist_devices.k_list.prev,\r\nstruct device_private,\r\nknode_driver.n_node);\r\ndev = dev_prv->device;\r\nget_device(dev);\r\nspin_unlock(&drv->p->klist_devices.k_lock);\r\nif (dev->parent)\r\ndevice_lock(dev->parent);\r\ndevice_lock(dev);\r\nif (dev->driver == drv)\r\n__device_release_driver(dev);\r\ndevice_unlock(dev);\r\nif (dev->parent)\r\ndevice_unlock(dev->parent);\r\nput_device(dev);\r\n}\r\n}
