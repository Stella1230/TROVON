static int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\nstruct page *page = buf->page;\r\nstruct address_space *mapping;\r\nlock_page(page);\r\nmapping = page_mapping(page);\r\nif (mapping) {\r\nWARN_ON(!PageUptodate(page));\r\nwait_on_page_writeback(page);\r\nif (page_has_private(page) &&\r\n!try_to_release_page(page, GFP_KERNEL))\r\ngoto out_unlock;\r\nif (remove_mapping(mapping, page)) {\r\nbuf->flags |= PIPE_BUF_FLAG_LRU;\r\nreturn 0;\r\n}\r\n}\r\nout_unlock:\r\nunlock_page(page);\r\nreturn 1;\r\n}\r\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\npage_cache_release(buf->page);\r\nbuf->flags &= ~PIPE_BUF_FLAG_LRU;\r\n}\r\nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\nstruct page *page = buf->page;\r\nint err;\r\nif (!PageUptodate(page)) {\r\nlock_page(page);\r\nif (!page->mapping) {\r\nerr = -ENODATA;\r\ngoto error;\r\n}\r\nif (!PageUptodate(page)) {\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nunlock_page(page);\r\n}\r\nreturn 0;\r\nerror:\r\nunlock_page(page);\r\nreturn err;\r\n}\r\nstatic int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\nif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\r\nreturn 1;\r\nbuf->flags |= PIPE_BUF_FLAG_LRU;\r\nreturn generic_pipe_buf_steal(pipe, buf);\r\n}\r\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\r\n{\r\nsmp_mb();\r\nif (waitqueue_active(&pipe->wait))\r\nwake_up_interruptible(&pipe->wait);\r\nkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\r\n}\r\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\r\nstruct splice_pipe_desc *spd)\r\n{\r\nunsigned int spd_pages = spd->nr_pages;\r\nint ret, do_wakeup, page_nr;\r\nret = 0;\r\ndo_wakeup = 0;\r\npage_nr = 0;\r\npipe_lock(pipe);\r\nfor (;;) {\r\nif (!pipe->readers) {\r\nsend_sig(SIGPIPE, current, 0);\r\nif (!ret)\r\nret = -EPIPE;\r\nbreak;\r\n}\r\nif (pipe->nrbufs < pipe->buffers) {\r\nint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\r\nstruct pipe_buffer *buf = pipe->bufs + newbuf;\r\nbuf->page = spd->pages[page_nr];\r\nbuf->offset = spd->partial[page_nr].offset;\r\nbuf->len = spd->partial[page_nr].len;\r\nbuf->private = spd->partial[page_nr].private;\r\nbuf->ops = spd->ops;\r\nif (spd->flags & SPLICE_F_GIFT)\r\nbuf->flags |= PIPE_BUF_FLAG_GIFT;\r\npipe->nrbufs++;\r\npage_nr++;\r\nret += buf->len;\r\nif (pipe->files)\r\ndo_wakeup = 1;\r\nif (!--spd->nr_pages)\r\nbreak;\r\nif (pipe->nrbufs < pipe->buffers)\r\ncontinue;\r\nbreak;\r\n}\r\nif (spd->flags & SPLICE_F_NONBLOCK) {\r\nif (!ret)\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nif (!ret)\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (do_wakeup) {\r\nsmp_mb();\r\nif (waitqueue_active(&pipe->wait))\r\nwake_up_interruptible_sync(&pipe->wait);\r\nkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\r\ndo_wakeup = 0;\r\n}\r\npipe->waiting_writers++;\r\npipe_wait(pipe);\r\npipe->waiting_writers--;\r\n}\r\npipe_unlock(pipe);\r\nif (do_wakeup)\r\nwakeup_pipe_readers(pipe);\r\nwhile (page_nr < spd_pages)\r\nspd->spd_release(spd, page_nr++);\r\nreturn ret;\r\n}\r\nvoid spd_release_page(struct splice_pipe_desc *spd, unsigned int i)\r\n{\r\npage_cache_release(spd->pages[i]);\r\n}\r\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\r\n{\r\nunsigned int buffers = ACCESS_ONCE(pipe->buffers);\r\nspd->nr_pages_max = buffers;\r\nif (buffers <= PIPE_DEF_BUFFERS)\r\nreturn 0;\r\nspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\r\nspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\r\nif (spd->pages && spd->partial)\r\nreturn 0;\r\nkfree(spd->pages);\r\nkfree(spd->partial);\r\nreturn -ENOMEM;\r\n}\r\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\r\n{\r\nif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\r\nreturn;\r\nkfree(spd->pages);\r\nkfree(spd->partial);\r\n}\r\nstatic int\r\n__generic_file_splice_read(struct file *in, loff_t *ppos,\r\nstruct pipe_inode_info *pipe, size_t len,\r\nunsigned int flags)\r\n{\r\nstruct address_space *mapping = in->f_mapping;\r\nunsigned int loff, nr_pages, req_pages;\r\nstruct page *pages[PIPE_DEF_BUFFERS];\r\nstruct partial_page partial[PIPE_DEF_BUFFERS];\r\nstruct page *page;\r\npgoff_t index, end_index;\r\nloff_t isize;\r\nint error, page_nr;\r\nstruct splice_pipe_desc spd = {\r\n.pages = pages,\r\n.partial = partial,\r\n.nr_pages_max = PIPE_DEF_BUFFERS,\r\n.flags = flags,\r\n.ops = &page_cache_pipe_buf_ops,\r\n.spd_release = spd_release_page,\r\n};\r\nif (splice_grow_spd(pipe, &spd))\r\nreturn -ENOMEM;\r\nindex = *ppos >> PAGE_CACHE_SHIFT;\r\nloff = *ppos & ~PAGE_CACHE_MASK;\r\nreq_pages = (len + loff + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nnr_pages = min(req_pages, spd.nr_pages_max);\r\nspd.nr_pages = find_get_pages_contig(mapping, index, nr_pages, spd.pages);\r\nindex += spd.nr_pages;\r\nif (spd.nr_pages < nr_pages)\r\npage_cache_sync_readahead(mapping, &in->f_ra, in,\r\nindex, req_pages - spd.nr_pages);\r\nerror = 0;\r\nwhile (spd.nr_pages < nr_pages) {\r\npage = find_get_page(mapping, index);\r\nif (!page) {\r\npage = page_cache_alloc_cold(mapping);\r\nif (!page)\r\nbreak;\r\nerror = add_to_page_cache_lru(page, mapping, index,\r\nGFP_KERNEL);\r\nif (unlikely(error)) {\r\npage_cache_release(page);\r\nif (error == -EEXIST)\r\ncontinue;\r\nbreak;\r\n}\r\nunlock_page(page);\r\n}\r\nspd.pages[spd.nr_pages++] = page;\r\nindex++;\r\n}\r\nindex = *ppos >> PAGE_CACHE_SHIFT;\r\nnr_pages = spd.nr_pages;\r\nspd.nr_pages = 0;\r\nfor (page_nr = 0; page_nr < nr_pages; page_nr++) {\r\nunsigned int this_len;\r\nif (!len)\r\nbreak;\r\nthis_len = min_t(unsigned long, len, PAGE_CACHE_SIZE - loff);\r\npage = spd.pages[page_nr];\r\nif (PageReadahead(page))\r\npage_cache_async_readahead(mapping, &in->f_ra, in,\r\npage, index, req_pages - page_nr);\r\nif (!PageUptodate(page)) {\r\nlock_page(page);\r\nif (!page->mapping) {\r\nunlock_page(page);\r\npage = find_or_create_page(mapping, index,\r\nmapping_gfp_mask(mapping));\r\nif (!page) {\r\nerror = -ENOMEM;\r\nbreak;\r\n}\r\npage_cache_release(spd.pages[page_nr]);\r\nspd.pages[page_nr] = page;\r\n}\r\nif (PageUptodate(page)) {\r\nunlock_page(page);\r\ngoto fill_it;\r\n}\r\nerror = mapping->a_ops->readpage(in, page);\r\nif (unlikely(error)) {\r\nif (error == AOP_TRUNCATED_PAGE)\r\nerror = 0;\r\nbreak;\r\n}\r\n}\r\nfill_it:\r\nisize = i_size_read(mapping->host);\r\nend_index = (isize - 1) >> PAGE_CACHE_SHIFT;\r\nif (unlikely(!isize || index > end_index))\r\nbreak;\r\nif (end_index == index) {\r\nunsigned int plen;\r\nplen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;\r\nif (plen <= loff)\r\nbreak;\r\nthis_len = min(this_len, plen - loff);\r\nlen = this_len;\r\n}\r\nspd.partial[page_nr].offset = loff;\r\nspd.partial[page_nr].len = this_len;\r\nlen -= this_len;\r\nloff = 0;\r\nspd.nr_pages++;\r\nindex++;\r\n}\r\nwhile (page_nr < nr_pages)\r\npage_cache_release(spd.pages[page_nr++]);\r\nin->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\r\nif (spd.nr_pages)\r\nerror = splice_to_pipe(pipe, &spd);\r\nsplice_shrink_spd(&spd);\r\nreturn error;\r\n}\r\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\r\nstruct pipe_inode_info *pipe, size_t len,\r\nunsigned int flags)\r\n{\r\nloff_t isize, left;\r\nint ret;\r\nisize = i_size_read(in->f_mapping->host);\r\nif (unlikely(*ppos >= isize))\r\nreturn 0;\r\nleft = isize - *ppos;\r\nif (unlikely(left < len))\r\nlen = left;\r\nret = __generic_file_splice_read(in, ppos, pipe, len, flags);\r\nif (ret > 0) {\r\n*ppos += ret;\r\nfile_accessed(in);\r\n}\r\nreturn ret;\r\n}\r\nstatic int generic_pipe_buf_nosteal(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\nreturn 1;\r\n}\r\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\r\nunsigned long vlen, loff_t offset)\r\n{\r\nmm_segment_t old_fs;\r\nloff_t pos = offset;\r\nssize_t res;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\r\nset_fs(old_fs);\r\nreturn res;\r\n}\r\nssize_t kernel_write(struct file *file, const char *buf, size_t count,\r\nloff_t pos)\r\n{\r\nmm_segment_t old_fs;\r\nssize_t res;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nres = vfs_write(file, (__force const char __user *)buf, count, &pos);\r\nset_fs(old_fs);\r\nreturn res;\r\n}\r\nssize_t default_file_splice_read(struct file *in, loff_t *ppos,\r\nstruct pipe_inode_info *pipe, size_t len,\r\nunsigned int flags)\r\n{\r\nunsigned int nr_pages;\r\nunsigned int nr_freed;\r\nsize_t offset;\r\nstruct page *pages[PIPE_DEF_BUFFERS];\r\nstruct partial_page partial[PIPE_DEF_BUFFERS];\r\nstruct iovec *vec, __vec[PIPE_DEF_BUFFERS];\r\nssize_t res;\r\nsize_t this_len;\r\nint error;\r\nint i;\r\nstruct splice_pipe_desc spd = {\r\n.pages = pages,\r\n.partial = partial,\r\n.nr_pages_max = PIPE_DEF_BUFFERS,\r\n.flags = flags,\r\n.ops = &default_pipe_buf_ops,\r\n.spd_release = spd_release_page,\r\n};\r\nif (splice_grow_spd(pipe, &spd))\r\nreturn -ENOMEM;\r\nres = -ENOMEM;\r\nvec = __vec;\r\nif (spd.nr_pages_max > PIPE_DEF_BUFFERS) {\r\nvec = kmalloc(spd.nr_pages_max * sizeof(struct iovec), GFP_KERNEL);\r\nif (!vec)\r\ngoto shrink_ret;\r\n}\r\noffset = *ppos & ~PAGE_CACHE_MASK;\r\nnr_pages = (len + offset + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nfor (i = 0; i < nr_pages && i < spd.nr_pages_max && len; i++) {\r\nstruct page *page;\r\npage = alloc_page(GFP_USER);\r\nerror = -ENOMEM;\r\nif (!page)\r\ngoto err;\r\nthis_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);\r\nvec[i].iov_base = (void __user *) page_address(page);\r\nvec[i].iov_len = this_len;\r\nspd.pages[i] = page;\r\nspd.nr_pages++;\r\nlen -= this_len;\r\noffset = 0;\r\n}\r\nres = kernel_readv(in, vec, spd.nr_pages, *ppos);\r\nif (res < 0) {\r\nerror = res;\r\ngoto err;\r\n}\r\nerror = 0;\r\nif (!res)\r\ngoto err;\r\nnr_freed = 0;\r\nfor (i = 0; i < spd.nr_pages; i++) {\r\nthis_len = min_t(size_t, vec[i].iov_len, res);\r\nspd.partial[i].offset = 0;\r\nspd.partial[i].len = this_len;\r\nif (!this_len) {\r\n__free_page(spd.pages[i]);\r\nspd.pages[i] = NULL;\r\nnr_freed++;\r\n}\r\nres -= this_len;\r\n}\r\nspd.nr_pages -= nr_freed;\r\nres = splice_to_pipe(pipe, &spd);\r\nif (res > 0)\r\n*ppos += res;\r\nshrink_ret:\r\nif (vec != __vec)\r\nkfree(vec);\r\nsplice_shrink_spd(&spd);\r\nreturn res;\r\nerr:\r\nfor (i = 0; i < spd.nr_pages; i++)\r\n__free_page(spd.pages[i]);\r\nres = error;\r\ngoto shrink_ret;\r\n}\r\nstatic int pipe_to_sendpage(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf, struct splice_desc *sd)\r\n{\r\nstruct file *file = sd->u.file;\r\nloff_t pos = sd->pos;\r\nint more;\r\nif (!likely(file->f_op->sendpage))\r\nreturn -EINVAL;\r\nmore = (sd->flags & SPLICE_F_MORE) ? MSG_MORE : 0;\r\nif (sd->len < sd->total_len && pipe->nrbufs > 1)\r\nmore |= MSG_SENDPAGE_NOTLAST;\r\nreturn file->f_op->sendpage(file, buf->page, buf->offset,\r\nsd->len, &pos, more);\r\n}\r\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\r\n{\r\nsmp_mb();\r\nif (waitqueue_active(&pipe->wait))\r\nwake_up_interruptible(&pipe->wait);\r\nkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\r\n}\r\nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\r\nsplice_actor *actor)\r\n{\r\nint ret;\r\nwhile (pipe->nrbufs) {\r\nstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\r\nconst struct pipe_buf_operations *ops = buf->ops;\r\nsd->len = buf->len;\r\nif (sd->len > sd->total_len)\r\nsd->len = sd->total_len;\r\nret = buf->ops->confirm(pipe, buf);\r\nif (unlikely(ret)) {\r\nif (ret == -ENODATA)\r\nret = 0;\r\nreturn ret;\r\n}\r\nret = actor(pipe, buf, sd);\r\nif (ret <= 0)\r\nreturn ret;\r\nbuf->offset += ret;\r\nbuf->len -= ret;\r\nsd->num_spliced += ret;\r\nsd->len -= ret;\r\nsd->pos += ret;\r\nsd->total_len -= ret;\r\nif (!buf->len) {\r\nbuf->ops = NULL;\r\nops->release(pipe, buf);\r\npipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\r\npipe->nrbufs--;\r\nif (pipe->files)\r\nsd->need_wakeup = true;\r\n}\r\nif (!sd->total_len)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\r\n{\r\nwhile (!pipe->nrbufs) {\r\nif (!pipe->writers)\r\nreturn 0;\r\nif (!pipe->waiting_writers && sd->num_spliced)\r\nreturn 0;\r\nif (sd->flags & SPLICE_F_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nif (sd->need_wakeup) {\r\nwakeup_pipe_writers(pipe);\r\nsd->need_wakeup = false;\r\n}\r\npipe_wait(pipe);\r\n}\r\nreturn 1;\r\n}\r\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\r\n{\r\nsd->num_spliced = 0;\r\nsd->need_wakeup = false;\r\n}\r\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\r\n{\r\nif (sd->need_wakeup)\r\nwakeup_pipe_writers(pipe);\r\n}\r\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\r\nsplice_actor *actor)\r\n{\r\nint ret;\r\nsplice_from_pipe_begin(sd);\r\ndo {\r\nret = splice_from_pipe_next(pipe, sd);\r\nif (ret > 0)\r\nret = splice_from_pipe_feed(pipe, sd, actor);\r\n} while (ret > 0);\r\nsplice_from_pipe_end(pipe, sd);\r\nreturn sd->num_spliced ? sd->num_spliced : ret;\r\n}\r\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\r\nloff_t *ppos, size_t len, unsigned int flags,\r\nsplice_actor *actor)\r\n{\r\nssize_t ret;\r\nstruct splice_desc sd = {\r\n.total_len = len,\r\n.flags = flags,\r\n.pos = *ppos,\r\n.u.file = out,\r\n};\r\npipe_lock(pipe);\r\nret = __splice_from_pipe(pipe, &sd, actor);\r\npipe_unlock(pipe);\r\nreturn ret;\r\n}\r\nssize_t\r\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\r\nloff_t *ppos, size_t len, unsigned int flags)\r\n{\r\nstruct splice_desc sd = {\r\n.total_len = len,\r\n.flags = flags,\r\n.pos = *ppos,\r\n.u.file = out,\r\n};\r\nint nbufs = pipe->buffers;\r\nstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\r\nGFP_KERNEL);\r\nssize_t ret;\r\nif (unlikely(!array))\r\nreturn -ENOMEM;\r\npipe_lock(pipe);\r\nsplice_from_pipe_begin(&sd);\r\nwhile (sd.total_len) {\r\nstruct iov_iter from;\r\nstruct kiocb kiocb;\r\nsize_t left;\r\nint n, idx;\r\nret = splice_from_pipe_next(pipe, &sd);\r\nif (ret <= 0)\r\nbreak;\r\nif (unlikely(nbufs < pipe->buffers)) {\r\nkfree(array);\r\nnbufs = pipe->buffers;\r\narray = kcalloc(nbufs, sizeof(struct bio_vec),\r\nGFP_KERNEL);\r\nif (!array) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nleft = sd.total_len;\r\nfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\r\nstruct pipe_buffer *buf = pipe->bufs + idx;\r\nsize_t this_len = buf->len;\r\nif (this_len > left)\r\nthis_len = left;\r\nif (idx == pipe->buffers - 1)\r\nidx = -1;\r\nret = buf->ops->confirm(pipe, buf);\r\nif (unlikely(ret)) {\r\nif (ret == -ENODATA)\r\nret = 0;\r\ngoto done;\r\n}\r\narray[n].bv_page = buf->page;\r\narray[n].bv_len = this_len;\r\narray[n].bv_offset = buf->offset;\r\nleft -= this_len;\r\n}\r\nfrom.type = ITER_BVEC | WRITE;\r\nfrom.bvec = array;\r\nfrom.nr_segs = n;\r\nfrom.count = sd.total_len - left;\r\nfrom.iov_offset = 0;\r\ninit_sync_kiocb(&kiocb, out);\r\nkiocb.ki_pos = sd.pos;\r\nkiocb.ki_nbytes = sd.total_len - left;\r\nret = out->f_op->write_iter(&kiocb, &from);\r\nif (-EIOCBQUEUED == ret)\r\nret = wait_on_sync_kiocb(&kiocb);\r\nif (ret <= 0)\r\nbreak;\r\nsd.num_spliced += ret;\r\nsd.total_len -= ret;\r\n*ppos = sd.pos = kiocb.ki_pos;\r\nwhile (ret) {\r\nstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\r\nif (ret >= buf->len) {\r\nconst struct pipe_buf_operations *ops = buf->ops;\r\nret -= buf->len;\r\nbuf->len = 0;\r\nbuf->ops = NULL;\r\nops->release(pipe, buf);\r\npipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\r\npipe->nrbufs--;\r\nif (pipe->files)\r\nsd.need_wakeup = true;\r\n} else {\r\nbuf->offset += ret;\r\nbuf->len -= ret;\r\nret = 0;\r\n}\r\n}\r\n}\r\ndone:\r\nkfree(array);\r\nsplice_from_pipe_end(pipe, &sd);\r\npipe_unlock(pipe);\r\nif (sd.num_spliced)\r\nret = sd.num_spliced;\r\nreturn ret;\r\n}\r\nstatic int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\r\nstruct splice_desc *sd)\r\n{\r\nint ret;\r\nvoid *data;\r\nloff_t tmp = sd->pos;\r\ndata = kmap(buf->page);\r\nret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);\r\nkunmap(buf->page);\r\nreturn ret;\r\n}\r\nstatic ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\r\nstruct file *out, loff_t *ppos,\r\nsize_t len, unsigned int flags)\r\n{\r\nssize_t ret;\r\nret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\r\nif (ret > 0)\r\n*ppos += ret;\r\nreturn ret;\r\n}\r\nssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,\r\nloff_t *ppos, size_t len, unsigned int flags)\r\n{\r\nreturn splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);\r\n}\r\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\r\nloff_t *ppos, size_t len, unsigned int flags)\r\n{\r\nssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\r\nloff_t *, size_t, unsigned int);\r\nif (out->f_op->splice_write)\r\nsplice_write = out->f_op->splice_write;\r\nelse\r\nsplice_write = default_file_splice_write;\r\nreturn splice_write(pipe, out, ppos, len, flags);\r\n}\r\nstatic long do_splice_to(struct file *in, loff_t *ppos,\r\nstruct pipe_inode_info *pipe, size_t len,\r\nunsigned int flags)\r\n{\r\nssize_t (*splice_read)(struct file *, loff_t *,\r\nstruct pipe_inode_info *, size_t, unsigned int);\r\nint ret;\r\nif (unlikely(!(in->f_mode & FMODE_READ)))\r\nreturn -EBADF;\r\nret = rw_verify_area(READ, in, ppos, len);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nif (in->f_op->splice_read)\r\nsplice_read = in->f_op->splice_read;\r\nelse\r\nsplice_read = default_file_splice_read;\r\nreturn splice_read(in, ppos, pipe, len, flags);\r\n}\r\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\r\nsplice_direct_actor *actor)\r\n{\r\nstruct pipe_inode_info *pipe;\r\nlong ret, bytes;\r\numode_t i_mode;\r\nsize_t len;\r\nint i, flags;\r\ni_mode = file_inode(in)->i_mode;\r\nif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\r\nreturn -EINVAL;\r\npipe = current->splice_pipe;\r\nif (unlikely(!pipe)) {\r\npipe = alloc_pipe_info();\r\nif (!pipe)\r\nreturn -ENOMEM;\r\npipe->readers = 1;\r\ncurrent->splice_pipe = pipe;\r\n}\r\nret = 0;\r\nbytes = 0;\r\nlen = sd->total_len;\r\nflags = sd->flags;\r\nsd->flags &= ~SPLICE_F_NONBLOCK;\r\nwhile (len) {\r\nsize_t read_len;\r\nloff_t pos = sd->pos, prev_pos = pos;\r\nret = do_splice_to(in, &pos, pipe, len, flags);\r\nif (unlikely(ret <= 0))\r\ngoto out_release;\r\nread_len = ret;\r\nsd->total_len = read_len;\r\nret = actor(pipe, sd);\r\nif (unlikely(ret <= 0)) {\r\nsd->pos = prev_pos;\r\ngoto out_release;\r\n}\r\nbytes += ret;\r\nlen -= ret;\r\nsd->pos = pos;\r\nif (ret < read_len) {\r\nsd->pos = prev_pos + ret;\r\ngoto out_release;\r\n}\r\n}\r\ndone:\r\npipe->nrbufs = pipe->curbuf = 0;\r\nfile_accessed(in);\r\nreturn bytes;\r\nout_release:\r\nfor (i = 0; i < pipe->buffers; i++) {\r\nstruct pipe_buffer *buf = pipe->bufs + i;\r\nif (buf->ops) {\r\nbuf->ops->release(pipe, buf);\r\nbuf->ops = NULL;\r\n}\r\n}\r\nif (!bytes)\r\nbytes = ret;\r\ngoto done;\r\n}\r\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\r\nstruct splice_desc *sd)\r\n{\r\nstruct file *file = sd->u.file;\r\nreturn do_splice_from(pipe, file, sd->opos, sd->total_len,\r\nsd->flags);\r\n}\r\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\r\nloff_t *opos, size_t len, unsigned int flags)\r\n{\r\nstruct splice_desc sd = {\r\n.len = len,\r\n.total_len = len,\r\n.flags = flags,\r\n.pos = *ppos,\r\n.u.file = out,\r\n.opos = opos,\r\n};\r\nlong ret;\r\nif (unlikely(!(out->f_mode & FMODE_WRITE)))\r\nreturn -EBADF;\r\nif (unlikely(out->f_flags & O_APPEND))\r\nreturn -EINVAL;\r\nret = rw_verify_area(WRITE, out, opos, len);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nret = splice_direct_to_actor(in, &sd, direct_splice_actor);\r\nif (ret > 0)\r\n*ppos = sd.pos;\r\nreturn ret;\r\n}\r\nstatic long do_splice(struct file *in, loff_t __user *off_in,\r\nstruct file *out, loff_t __user *off_out,\r\nsize_t len, unsigned int flags)\r\n{\r\nstruct pipe_inode_info *ipipe;\r\nstruct pipe_inode_info *opipe;\r\nloff_t offset;\r\nlong ret;\r\nipipe = get_pipe_info(in);\r\nopipe = get_pipe_info(out);\r\nif (ipipe && opipe) {\r\nif (off_in || off_out)\r\nreturn -ESPIPE;\r\nif (!(in->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nif (!(out->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif (ipipe == opipe)\r\nreturn -EINVAL;\r\nreturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\r\n}\r\nif (ipipe) {\r\nif (off_in)\r\nreturn -ESPIPE;\r\nif (off_out) {\r\nif (!(out->f_mode & FMODE_PWRITE))\r\nreturn -EINVAL;\r\nif (copy_from_user(&offset, off_out, sizeof(loff_t)))\r\nreturn -EFAULT;\r\n} else {\r\noffset = out->f_pos;\r\n}\r\nif (unlikely(!(out->f_mode & FMODE_WRITE)))\r\nreturn -EBADF;\r\nif (unlikely(out->f_flags & O_APPEND))\r\nreturn -EINVAL;\r\nret = rw_verify_area(WRITE, out, &offset, len);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nfile_start_write(out);\r\nret = do_splice_from(ipipe, out, &offset, len, flags);\r\nfile_end_write(out);\r\nif (!off_out)\r\nout->f_pos = offset;\r\nelse if (copy_to_user(off_out, &offset, sizeof(loff_t)))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nif (opipe) {\r\nif (off_out)\r\nreturn -ESPIPE;\r\nif (off_in) {\r\nif (!(in->f_mode & FMODE_PREAD))\r\nreturn -EINVAL;\r\nif (copy_from_user(&offset, off_in, sizeof(loff_t)))\r\nreturn -EFAULT;\r\n} else {\r\noffset = in->f_pos;\r\n}\r\nret = do_splice_to(in, &offset, opipe, len, flags);\r\nif (!off_in)\r\nin->f_pos = offset;\r\nelse if (copy_to_user(off_in, &offset, sizeof(loff_t)))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_iovec_page_array(const struct iovec __user *iov,\r\nunsigned int nr_vecs, struct page **pages,\r\nstruct partial_page *partial, bool aligned,\r\nunsigned int pipe_buffers)\r\n{\r\nint buffers = 0, error = 0;\r\nwhile (nr_vecs) {\r\nunsigned long off, npages;\r\nstruct iovec entry;\r\nvoid __user *base;\r\nsize_t len;\r\nint i;\r\nerror = -EFAULT;\r\nif (copy_from_user(&entry, iov, sizeof(entry)))\r\nbreak;\r\nbase = entry.iov_base;\r\nlen = entry.iov_len;\r\nerror = 0;\r\nif (unlikely(!len))\r\nbreak;\r\nerror = -EFAULT;\r\nif (!access_ok(VERIFY_READ, base, len))\r\nbreak;\r\noff = (unsigned long) base & ~PAGE_MASK;\r\nerror = -EINVAL;\r\nif (aligned && (off || len & ~PAGE_MASK))\r\nbreak;\r\nnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (npages > pipe_buffers - buffers)\r\nnpages = pipe_buffers - buffers;\r\nerror = get_user_pages_fast((unsigned long)base, npages,\r\n0, &pages[buffers]);\r\nif (unlikely(error <= 0))\r\nbreak;\r\nfor (i = 0; i < error; i++) {\r\nconst int plen = min_t(size_t, len, PAGE_SIZE - off);\r\npartial[buffers].offset = off;\r\npartial[buffers].len = plen;\r\noff = 0;\r\nlen -= plen;\r\nbuffers++;\r\n}\r\nif (len)\r\nbreak;\r\nif (error < npages || buffers == pipe_buffers)\r\nbreak;\r\nnr_vecs--;\r\niov++;\r\n}\r\nif (buffers)\r\nreturn buffers;\r\nreturn error;\r\n}\r\nstatic int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\r\nstruct splice_desc *sd)\r\n{\r\nint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\r\nreturn n == sd->len ? n : -EFAULT;\r\n}\r\nstatic long vmsplice_to_user(struct file *file, const struct iovec __user *uiov,\r\nunsigned long nr_segs, unsigned int flags)\r\n{\r\nstruct pipe_inode_info *pipe;\r\nstruct splice_desc sd;\r\nlong ret;\r\nstruct iovec iovstack[UIO_FASTIOV];\r\nstruct iovec *iov = iovstack;\r\nstruct iov_iter iter;\r\nssize_t count;\r\npipe = get_pipe_info(file);\r\nif (!pipe)\r\nreturn -EBADF;\r\nret = rw_copy_check_uvector(READ, uiov, nr_segs,\r\nARRAY_SIZE(iovstack), iovstack, &iov);\r\nif (ret <= 0)\r\ngoto out;\r\ncount = ret;\r\niov_iter_init(&iter, READ, iov, nr_segs, count);\r\nsd.len = 0;\r\nsd.total_len = count;\r\nsd.flags = flags;\r\nsd.u.data = &iter;\r\nsd.pos = 0;\r\npipe_lock(pipe);\r\nret = __splice_from_pipe(pipe, &sd, pipe_to_user);\r\npipe_unlock(pipe);\r\nout:\r\nif (iov != iovstack)\r\nkfree(iov);\r\nreturn ret;\r\n}\r\nstatic long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,\r\nunsigned long nr_segs, unsigned int flags)\r\n{\r\nstruct pipe_inode_info *pipe;\r\nstruct page *pages[PIPE_DEF_BUFFERS];\r\nstruct partial_page partial[PIPE_DEF_BUFFERS];\r\nstruct splice_pipe_desc spd = {\r\n.pages = pages,\r\n.partial = partial,\r\n.nr_pages_max = PIPE_DEF_BUFFERS,\r\n.flags = flags,\r\n.ops = &user_page_pipe_buf_ops,\r\n.spd_release = spd_release_page,\r\n};\r\nlong ret;\r\npipe = get_pipe_info(file);\r\nif (!pipe)\r\nreturn -EBADF;\r\nif (splice_grow_spd(pipe, &spd))\r\nreturn -ENOMEM;\r\nspd.nr_pages = get_iovec_page_array(iov, nr_segs, spd.pages,\r\nspd.partial, false,\r\nspd.nr_pages_max);\r\nif (spd.nr_pages <= 0)\r\nret = spd.nr_pages;\r\nelse\r\nret = splice_to_pipe(pipe, &spd);\r\nsplice_shrink_spd(&spd);\r\nreturn ret;\r\n}\r\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\r\n{\r\nint ret;\r\nif (pipe->nrbufs)\r\nreturn 0;\r\nret = 0;\r\npipe_lock(pipe);\r\nwhile (!pipe->nrbufs) {\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!pipe->writers)\r\nbreak;\r\nif (!pipe->waiting_writers) {\r\nif (flags & SPLICE_F_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\n}\r\npipe_wait(pipe);\r\n}\r\npipe_unlock(pipe);\r\nreturn ret;\r\n}\r\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\r\n{\r\nint ret;\r\nif (pipe->nrbufs < pipe->buffers)\r\nreturn 0;\r\nret = 0;\r\npipe_lock(pipe);\r\nwhile (pipe->nrbufs >= pipe->buffers) {\r\nif (!pipe->readers) {\r\nsend_sig(SIGPIPE, current, 0);\r\nret = -EPIPE;\r\nbreak;\r\n}\r\nif (flags & SPLICE_F_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\npipe->waiting_writers++;\r\npipe_wait(pipe);\r\npipe->waiting_writers--;\r\n}\r\npipe_unlock(pipe);\r\nreturn ret;\r\n}\r\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\r\nstruct pipe_inode_info *opipe,\r\nsize_t len, unsigned int flags)\r\n{\r\nstruct pipe_buffer *ibuf, *obuf;\r\nint ret = 0, nbuf;\r\nbool input_wakeup = false;\r\nretry:\r\nret = ipipe_prep(ipipe, flags);\r\nif (ret)\r\nreturn ret;\r\nret = opipe_prep(opipe, flags);\r\nif (ret)\r\nreturn ret;\r\npipe_double_lock(ipipe, opipe);\r\ndo {\r\nif (!opipe->readers) {\r\nsend_sig(SIGPIPE, current, 0);\r\nif (!ret)\r\nret = -EPIPE;\r\nbreak;\r\n}\r\nif (!ipipe->nrbufs && !ipipe->writers)\r\nbreak;\r\nif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\r\nif (ret)\r\nbreak;\r\nif (flags & SPLICE_F_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\npipe_unlock(ipipe);\r\npipe_unlock(opipe);\r\ngoto retry;\r\n}\r\nibuf = ipipe->bufs + ipipe->curbuf;\r\nnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\r\nobuf = opipe->bufs + nbuf;\r\nif (len >= ibuf->len) {\r\n*obuf = *ibuf;\r\nibuf->ops = NULL;\r\nopipe->nrbufs++;\r\nipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\r\nipipe->nrbufs--;\r\ninput_wakeup = true;\r\n} else {\r\nibuf->ops->get(ipipe, ibuf);\r\n*obuf = *ibuf;\r\nobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\r\nobuf->len = len;\r\nopipe->nrbufs++;\r\nibuf->offset += obuf->len;\r\nibuf->len -= obuf->len;\r\n}\r\nret += obuf->len;\r\nlen -= obuf->len;\r\n} while (len);\r\npipe_unlock(ipipe);\r\npipe_unlock(opipe);\r\nif (ret > 0)\r\nwakeup_pipe_readers(opipe);\r\nif (input_wakeup)\r\nwakeup_pipe_writers(ipipe);\r\nreturn ret;\r\n}\r\nstatic int link_pipe(struct pipe_inode_info *ipipe,\r\nstruct pipe_inode_info *opipe,\r\nsize_t len, unsigned int flags)\r\n{\r\nstruct pipe_buffer *ibuf, *obuf;\r\nint ret = 0, i = 0, nbuf;\r\npipe_double_lock(ipipe, opipe);\r\ndo {\r\nif (!opipe->readers) {\r\nsend_sig(SIGPIPE, current, 0);\r\nif (!ret)\r\nret = -EPIPE;\r\nbreak;\r\n}\r\nif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\r\nbreak;\r\nibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\r\nnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\r\nibuf->ops->get(ipipe, ibuf);\r\nobuf = opipe->bufs + nbuf;\r\n*obuf = *ibuf;\r\nobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\r\nif (obuf->len > len)\r\nobuf->len = len;\r\nopipe->nrbufs++;\r\nret += obuf->len;\r\nlen -= obuf->len;\r\ni++;\r\n} while (len);\r\nif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\r\nret = -EAGAIN;\r\npipe_unlock(ipipe);\r\npipe_unlock(opipe);\r\nif (ret > 0)\r\nwakeup_pipe_readers(opipe);\r\nreturn ret;\r\n}\r\nstatic long do_tee(struct file *in, struct file *out, size_t len,\r\nunsigned int flags)\r\n{\r\nstruct pipe_inode_info *ipipe = get_pipe_info(in);\r\nstruct pipe_inode_info *opipe = get_pipe_info(out);\r\nint ret = -EINVAL;\r\nif (ipipe && opipe && ipipe != opipe) {\r\nret = ipipe_prep(ipipe, flags);\r\nif (!ret) {\r\nret = opipe_prep(opipe, flags);\r\nif (!ret)\r\nret = link_pipe(ipipe, opipe, len, flags);\r\n}\r\n}\r\nreturn ret;\r\n}
