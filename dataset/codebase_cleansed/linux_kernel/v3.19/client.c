static struct nfs_subversion *find_nfs_version(unsigned int version)\r\n{\r\nstruct nfs_subversion *nfs;\r\nspin_lock(&nfs_version_lock);\r\nlist_for_each_entry(nfs, &nfs_versions, list) {\r\nif (nfs->rpc_ops->version == version) {\r\nspin_unlock(&nfs_version_lock);\r\nreturn nfs;\r\n}\r\n}\r\nspin_unlock(&nfs_version_lock);\r\nreturn ERR_PTR(-EPROTONOSUPPORT);\r\n}\r\nstruct nfs_subversion *get_nfs_version(unsigned int version)\r\n{\r\nstruct nfs_subversion *nfs = find_nfs_version(version);\r\nif (IS_ERR(nfs)) {\r\nmutex_lock(&nfs_version_mutex);\r\nrequest_module("nfsv%d", version);\r\nnfs = find_nfs_version(version);\r\nmutex_unlock(&nfs_version_mutex);\r\n}\r\nif (!IS_ERR(nfs) && !try_module_get(nfs->owner))\r\nreturn ERR_PTR(-EAGAIN);\r\nreturn nfs;\r\n}\r\nvoid put_nfs_version(struct nfs_subversion *nfs)\r\n{\r\nmodule_put(nfs->owner);\r\n}\r\nvoid register_nfs_version(struct nfs_subversion *nfs)\r\n{\r\nspin_lock(&nfs_version_lock);\r\nlist_add(&nfs->list, &nfs_versions);\r\nnfs_version[nfs->rpc_ops->version] = nfs->rpc_vers;\r\nspin_unlock(&nfs_version_lock);\r\n}\r\nvoid unregister_nfs_version(struct nfs_subversion *nfs)\r\n{\r\nspin_lock(&nfs_version_lock);\r\nnfs_version[nfs->rpc_ops->version] = NULL;\r\nlist_del(&nfs->list);\r\nspin_unlock(&nfs_version_lock);\r\n}\r\nstruct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *cl_init)\r\n{\r\nstruct nfs_client *clp;\r\nstruct rpc_cred *cred;\r\nint err = -ENOMEM;\r\nif ((clp = kzalloc(sizeof(*clp), GFP_KERNEL)) == NULL)\r\ngoto error_0;\r\nclp->cl_nfs_mod = cl_init->nfs_mod;\r\nif (!try_module_get(clp->cl_nfs_mod->owner))\r\ngoto error_dealloc;\r\nclp->rpc_ops = clp->cl_nfs_mod->rpc_ops;\r\natomic_set(&clp->cl_count, 1);\r\nclp->cl_cons_state = NFS_CS_INITING;\r\nmemcpy(&clp->cl_addr, cl_init->addr, cl_init->addrlen);\r\nclp->cl_addrlen = cl_init->addrlen;\r\nif (cl_init->hostname) {\r\nerr = -ENOMEM;\r\nclp->cl_hostname = kstrdup(cl_init->hostname, GFP_KERNEL);\r\nif (!clp->cl_hostname)\r\ngoto error_cleanup;\r\n}\r\nINIT_LIST_HEAD(&clp->cl_superblocks);\r\nclp->cl_rpcclient = ERR_PTR(-EINVAL);\r\nclp->cl_proto = cl_init->proto;\r\nclp->cl_net = get_net(cl_init->net);\r\ncred = rpc_lookup_machine_cred("*");\r\nif (!IS_ERR(cred))\r\nclp->cl_machine_cred = cred;\r\nnfs_fscache_get_client_cookie(clp);\r\nreturn clp;\r\nerror_cleanup:\r\nput_nfs_version(clp->cl_nfs_mod);\r\nerror_dealloc:\r\nkfree(clp);\r\nerror_0:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid nfs_cleanup_cb_ident_idr(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nidr_destroy(&nn->cb_ident_idr);\r\n}\r\nstatic void nfs_cb_idr_remove_locked(struct nfs_client *clp)\r\n{\r\nstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\r\nif (clp->cl_cb_ident)\r\nidr_remove(&nn->cb_ident_idr, clp->cl_cb_ident);\r\n}\r\nstatic void pnfs_init_server(struct nfs_server *server)\r\n{\r\nrpc_init_wait_queue(&server->roc_rpcwaitq, "pNFS ROC");\r\n}\r\nvoid nfs_cleanup_cb_ident_idr(struct net *net)\r\n{\r\n}\r\nstatic void nfs_cb_idr_remove_locked(struct nfs_client *clp)\r\n{\r\n}\r\nstatic void pnfs_init_server(struct nfs_server *server)\r\n{\r\n}\r\nvoid nfs_free_client(struct nfs_client *clp)\r\n{\r\ndprintk("--> nfs_free_client(%u)\n", clp->rpc_ops->version);\r\nnfs_fscache_release_client_cookie(clp);\r\nif (!IS_ERR(clp->cl_rpcclient))\r\nrpc_shutdown_client(clp->cl_rpcclient);\r\nif (clp->cl_machine_cred != NULL)\r\nput_rpccred(clp->cl_machine_cred);\r\nput_net(clp->cl_net);\r\nput_nfs_version(clp->cl_nfs_mod);\r\nkfree(clp->cl_hostname);\r\nkfree(clp->cl_acceptor);\r\nkfree(clp);\r\ndprintk("<-- nfs_free_client()\n");\r\n}\r\nvoid nfs_put_client(struct nfs_client *clp)\r\n{\r\nstruct nfs_net *nn;\r\nif (!clp)\r\nreturn;\r\ndprintk("--> nfs_put_client({%d})\n", atomic_read(&clp->cl_count));\r\nnn = net_generic(clp->cl_net, nfs_net_id);\r\nif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\r\nlist_del(&clp->cl_share_link);\r\nnfs_cb_idr_remove_locked(clp);\r\nspin_unlock(&nn->nfs_client_lock);\r\nWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\r\nclp->rpc_ops->free_client(clp);\r\n}\r\n}\r\nstatic int nfs_sockaddr_match_ipaddr6(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nconst struct sockaddr_in6 *sin1 = (const struct sockaddr_in6 *)sa1;\r\nconst struct sockaddr_in6 *sin2 = (const struct sockaddr_in6 *)sa2;\r\nif (!ipv6_addr_equal(&sin1->sin6_addr, &sin2->sin6_addr))\r\nreturn 0;\r\nelse if (ipv6_addr_type(&sin1->sin6_addr) & IPV6_ADDR_LINKLOCAL)\r\nreturn sin1->sin6_scope_id == sin2->sin6_scope_id;\r\nreturn 1;\r\n}\r\nstatic int nfs_sockaddr_match_ipaddr6(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nfs_sockaddr_match_ipaddr4(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nconst struct sockaddr_in *sin1 = (const struct sockaddr_in *)sa1;\r\nconst struct sockaddr_in *sin2 = (const struct sockaddr_in *)sa2;\r\nreturn sin1->sin_addr.s_addr == sin2->sin_addr.s_addr;\r\n}\r\nstatic int nfs_sockaddr_cmp_ip6(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nconst struct sockaddr_in6 *sin1 = (const struct sockaddr_in6 *)sa1;\r\nconst struct sockaddr_in6 *sin2 = (const struct sockaddr_in6 *)sa2;\r\nreturn nfs_sockaddr_match_ipaddr6(sa1, sa2) &&\r\n(sin1->sin6_port == sin2->sin6_port);\r\n}\r\nstatic int nfs_sockaddr_cmp_ip4(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nconst struct sockaddr_in *sin1 = (const struct sockaddr_in *)sa1;\r\nconst struct sockaddr_in *sin2 = (const struct sockaddr_in *)sa2;\r\nreturn nfs_sockaddr_match_ipaddr4(sa1, sa2) &&\r\n(sin1->sin_port == sin2->sin_port);\r\n}\r\nint nfs_sockaddr_match_ipaddr(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nif (sa1->sa_family != sa2->sa_family)\r\nreturn 0;\r\nswitch (sa1->sa_family) {\r\ncase AF_INET:\r\nreturn nfs_sockaddr_match_ipaddr4(sa1, sa2);\r\ncase AF_INET6:\r\nreturn nfs_sockaddr_match_ipaddr6(sa1, sa2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfs_sockaddr_cmp(const struct sockaddr *sa1,\r\nconst struct sockaddr *sa2)\r\n{\r\nif (sa1->sa_family != sa2->sa_family)\r\nreturn 0;\r\nswitch (sa1->sa_family) {\r\ncase AF_INET:\r\nreturn nfs_sockaddr_cmp_ip4(sa1, sa2);\r\ncase AF_INET6:\r\nreturn nfs_sockaddr_cmp_ip6(sa1, sa2);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct nfs_client *nfs_match_client(const struct nfs_client_initdata *data)\r\n{\r\nstruct nfs_client *clp;\r\nconst struct sockaddr *sap = data->addr;\r\nstruct nfs_net *nn = net_generic(data->net, nfs_net_id);\r\nlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\r\nconst struct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\r\nif (clp->cl_cons_state < 0)\r\ncontinue;\r\nif (clp->rpc_ops != data->nfs_mod->rpc_ops)\r\ncontinue;\r\nif (clp->cl_proto != data->proto)\r\ncontinue;\r\nif (clp->cl_minorversion != data->minorversion)\r\ncontinue;\r\nif (!nfs_sockaddr_cmp(sap, clap))\r\ncontinue;\r\natomic_inc(&clp->cl_count);\r\nreturn clp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool nfs_client_init_is_complete(const struct nfs_client *clp)\r\n{\r\nreturn clp->cl_cons_state != NFS_CS_INITING;\r\n}\r\nint nfs_wait_client_init_complete(const struct nfs_client *clp)\r\n{\r\nreturn wait_event_killable(nfs_client_active_wq,\r\nnfs_client_init_is_complete(clp));\r\n}\r\nstatic struct nfs_client *\r\nnfs_found_client(const struct nfs_client_initdata *cl_init,\r\nstruct nfs_client *clp)\r\n{\r\nint error;\r\nerror = nfs_wait_client_init_complete(clp);\r\nif (error < 0) {\r\nnfs_put_client(clp);\r\nreturn ERR_PTR(-ERESTARTSYS);\r\n}\r\nif (clp->cl_cons_state < NFS_CS_READY) {\r\nerror = clp->cl_cons_state;\r\nnfs_put_client(clp);\r\nreturn ERR_PTR(error);\r\n}\r\nsmp_rmb();\r\ndprintk("<-- %s found nfs_client %p for %s\n",\r\n__func__, clp, cl_init->hostname ?: "");\r\nreturn clp;\r\n}\r\nstruct nfs_client *\r\nnfs_get_client(const struct nfs_client_initdata *cl_init,\r\nconst struct rpc_timeout *timeparms,\r\nconst char *ip_addr,\r\nrpc_authflavor_t authflavour)\r\n{\r\nstruct nfs_client *clp, *new = NULL;\r\nstruct nfs_net *nn = net_generic(cl_init->net, nfs_net_id);\r\nconst struct nfs_rpc_ops *rpc_ops = cl_init->nfs_mod->rpc_ops;\r\nif (cl_init->hostname == NULL) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\ndprintk("--> nfs_get_client(%s,v%u)\n",\r\ncl_init->hostname, rpc_ops->version);\r\ndo {\r\nspin_lock(&nn->nfs_client_lock);\r\nclp = nfs_match_client(cl_init);\r\nif (clp) {\r\nspin_unlock(&nn->nfs_client_lock);\r\nif (new)\r\nnew->rpc_ops->free_client(new);\r\nreturn nfs_found_client(cl_init, clp);\r\n}\r\nif (new) {\r\nlist_add_tail(&new->cl_share_link,\r\n&nn->nfs_client_list);\r\nspin_unlock(&nn->nfs_client_lock);\r\nnew->cl_flags = cl_init->init_flags;\r\nreturn rpc_ops->init_client(new, timeparms, ip_addr);\r\n}\r\nspin_unlock(&nn->nfs_client_lock);\r\nnew = rpc_ops->alloc_client(cl_init);\r\n} while (!IS_ERR(new));\r\ndprintk("<-- nfs_get_client() Failed to find %s (%ld)\n",\r\ncl_init->hostname, PTR_ERR(new));\r\nreturn new;\r\n}\r\nvoid nfs_mark_client_ready(struct nfs_client *clp, int state)\r\n{\r\nsmp_wmb();\r\nclp->cl_cons_state = state;\r\nwake_up_all(&nfs_client_active_wq);\r\n}\r\nvoid nfs_init_timeout_values(struct rpc_timeout *to, int proto,\r\nunsigned int timeo, unsigned int retrans)\r\n{\r\nto->to_initval = timeo * HZ / 10;\r\nto->to_retries = retrans;\r\nswitch (proto) {\r\ncase XPRT_TRANSPORT_TCP:\r\ncase XPRT_TRANSPORT_RDMA:\r\nif (to->to_retries == 0)\r\nto->to_retries = NFS_DEF_TCP_RETRANS;\r\nif (to->to_initval == 0)\r\nto->to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;\r\nif (to->to_initval > NFS_MAX_TCP_TIMEOUT)\r\nto->to_initval = NFS_MAX_TCP_TIMEOUT;\r\nto->to_increment = to->to_initval;\r\nto->to_maxval = to->to_initval + (to->to_increment * to->to_retries);\r\nif (to->to_maxval > NFS_MAX_TCP_TIMEOUT)\r\nto->to_maxval = NFS_MAX_TCP_TIMEOUT;\r\nif (to->to_maxval < to->to_initval)\r\nto->to_maxval = to->to_initval;\r\nto->to_exponential = 0;\r\nbreak;\r\ncase XPRT_TRANSPORT_UDP:\r\nif (to->to_retries == 0)\r\nto->to_retries = NFS_DEF_UDP_RETRANS;\r\nif (!to->to_initval)\r\nto->to_initval = NFS_DEF_UDP_TIMEO * HZ / 10;\r\nif (to->to_initval > NFS_MAX_UDP_TIMEOUT)\r\nto->to_initval = NFS_MAX_UDP_TIMEOUT;\r\nto->to_maxval = NFS_MAX_UDP_TIMEOUT;\r\nto->to_exponential = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nint nfs_create_rpc_client(struct nfs_client *clp,\r\nconst struct rpc_timeout *timeparms,\r\nrpc_authflavor_t flavor)\r\n{\r\nstruct rpc_clnt *clnt = NULL;\r\nstruct rpc_create_args args = {\r\n.net = clp->cl_net,\r\n.protocol = clp->cl_proto,\r\n.address = (struct sockaddr *)&clp->cl_addr,\r\n.addrsize = clp->cl_addrlen,\r\n.timeout = timeparms,\r\n.servername = clp->cl_hostname,\r\n.program = &nfs_program,\r\n.version = clp->rpc_ops->version,\r\n.authflavor = flavor,\r\n};\r\nif (test_bit(NFS_CS_DISCRTRY, &clp->cl_flags))\r\nargs.flags |= RPC_CLNT_CREATE_DISCRTRY;\r\nif (test_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags))\r\nargs.flags |= RPC_CLNT_CREATE_NO_RETRANS_TIMEOUT;\r\nif (test_bit(NFS_CS_NORESVPORT, &clp->cl_flags))\r\nargs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\r\nif (test_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags))\r\nargs.flags |= RPC_CLNT_CREATE_INFINITE_SLOTS;\r\nif (!IS_ERR(clp->cl_rpcclient))\r\nreturn 0;\r\nclnt = rpc_create(&args);\r\nif (IS_ERR(clnt)) {\r\ndprintk("%s: cannot create RPC client. Error = %ld\n",\r\n__func__, PTR_ERR(clnt));\r\nreturn PTR_ERR(clnt);\r\n}\r\nclp->cl_rpcclient = clnt;\r\nreturn 0;\r\n}\r\nstatic void nfs_destroy_server(struct nfs_server *server)\r\n{\r\nif (server->nlm_host)\r\nnlmclnt_done(server->nlm_host);\r\n}\r\nstatic int nfs_start_lockd(struct nfs_server *server)\r\n{\r\nstruct nlm_host *host;\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nlmclnt_initdata nlm_init = {\r\n.hostname = clp->cl_hostname,\r\n.address = (struct sockaddr *)&clp->cl_addr,\r\n.addrlen = clp->cl_addrlen,\r\n.nfs_version = clp->rpc_ops->version,\r\n.noresvport = server->flags & NFS_MOUNT_NORESVPORT ?\r\n1 : 0,\r\n.net = clp->cl_net,\r\n};\r\nif (nlm_init.nfs_version > 3)\r\nreturn 0;\r\nif ((server->flags & NFS_MOUNT_LOCAL_FLOCK) &&\r\n(server->flags & NFS_MOUNT_LOCAL_FCNTL))\r\nreturn 0;\r\nswitch (clp->cl_proto) {\r\ndefault:\r\nnlm_init.protocol = IPPROTO_TCP;\r\nbreak;\r\ncase XPRT_TRANSPORT_UDP:\r\nnlm_init.protocol = IPPROTO_UDP;\r\n}\r\nhost = nlmclnt_init(&nlm_init);\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\nserver->nlm_host = host;\r\nserver->destroy = nfs_destroy_server;\r\nreturn 0;\r\n}\r\nint nfs_init_server_rpcclient(struct nfs_server *server,\r\nconst struct rpc_timeout *timeo,\r\nrpc_authflavor_t pseudoflavour)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nserver->client = rpc_clone_client_set_auth(clp->cl_rpcclient,\r\npseudoflavour);\r\nif (IS_ERR(server->client)) {\r\ndprintk("%s: couldn't create rpc_client!\n", __func__);\r\nreturn PTR_ERR(server->client);\r\n}\r\nmemcpy(&server->client->cl_timeout_default,\r\ntimeo,\r\nsizeof(server->client->cl_timeout_default));\r\nserver->client->cl_timeout = &server->client->cl_timeout_default;\r\nserver->client->cl_softrtry = 0;\r\nif (server->flags & NFS_MOUNT_SOFT)\r\nserver->client->cl_softrtry = 1;\r\nreturn 0;\r\n}\r\nstruct nfs_client *nfs_init_client(struct nfs_client *clp,\r\nconst struct rpc_timeout *timeparms,\r\nconst char *ip_addr)\r\n{\r\nint error;\r\nif (clp->cl_cons_state == NFS_CS_READY) {\r\ndprintk("<-- nfs_init_client() = 0 [already %p]\n", clp);\r\nreturn clp;\r\n}\r\nerror = nfs_create_rpc_client(clp, timeparms, RPC_AUTH_UNIX);\r\nif (error < 0)\r\ngoto error;\r\nnfs_mark_client_ready(clp, NFS_CS_READY);\r\nreturn clp;\r\nerror:\r\nnfs_mark_client_ready(clp, error);\r\nnfs_put_client(clp);\r\ndprintk("<-- nfs_init_client() = xerror %d\n", error);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int nfs_init_server(struct nfs_server *server,\r\nconst struct nfs_parsed_mount_data *data,\r\nstruct nfs_subversion *nfs_mod)\r\n{\r\nstruct nfs_client_initdata cl_init = {\r\n.hostname = data->nfs_server.hostname,\r\n.addr = (const struct sockaddr *)&data->nfs_server.address,\r\n.addrlen = data->nfs_server.addrlen,\r\n.nfs_mod = nfs_mod,\r\n.proto = data->nfs_server.protocol,\r\n.net = data->net,\r\n};\r\nstruct rpc_timeout timeparms;\r\nstruct nfs_client *clp;\r\nint error;\r\ndprintk("--> nfs_init_server()\n");\r\nnfs_init_timeout_values(&timeparms, data->nfs_server.protocol,\r\ndata->timeo, data->retrans);\r\nif (data->flags & NFS_MOUNT_NORESVPORT)\r\nset_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\r\nclp = nfs_get_client(&cl_init, &timeparms, NULL, RPC_AUTH_UNIX);\r\nif (IS_ERR(clp)) {\r\ndprintk("<-- nfs_init_server() = error %ld\n", PTR_ERR(clp));\r\nreturn PTR_ERR(clp);\r\n}\r\nserver->nfs_client = clp;\r\nserver->flags = data->flags;\r\nserver->options = data->options;\r\nserver->caps |= NFS_CAP_HARDLINKS|NFS_CAP_SYMLINKS|NFS_CAP_FILEID|\r\nNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|NFS_CAP_OWNER_GROUP|\r\nNFS_CAP_ATIME|NFS_CAP_CTIME|NFS_CAP_MTIME|NFS_CAP_CHANGE_ATTR;\r\nif (data->rsize)\r\nserver->rsize = nfs_block_size(data->rsize, NULL);\r\nif (data->wsize)\r\nserver->wsize = nfs_block_size(data->wsize, NULL);\r\nserver->acregmin = data->acregmin * HZ;\r\nserver->acregmax = data->acregmax * HZ;\r\nserver->acdirmin = data->acdirmin * HZ;\r\nserver->acdirmax = data->acdirmax * HZ;\r\nerror = nfs_start_lockd(server);\r\nif (error < 0)\r\ngoto error;\r\nserver->port = data->nfs_server.port;\r\nserver->auth_info = data->auth_info;\r\nerror = nfs_init_server_rpcclient(server, &timeparms,\r\ndata->selected_flavor);\r\nif (error < 0)\r\ngoto error;\r\nif (data->mount_server.addrlen) {\r\nmemcpy(&server->mountd_address, &data->mount_server.address,\r\ndata->mount_server.addrlen);\r\nserver->mountd_addrlen = data->mount_server.addrlen;\r\n}\r\nserver->mountd_version = data->mount_server.version;\r\nserver->mountd_port = data->mount_server.port;\r\nserver->mountd_protocol = data->mount_server.protocol;\r\nserver->namelen = data->namlen;\r\ndprintk("<-- nfs_init_server() = 0 [new %p]\n", clp);\r\nreturn 0;\r\nerror:\r\nserver->nfs_client = NULL;\r\nnfs_put_client(clp);\r\ndprintk("<-- nfs_init_server() = xerror %d\n", error);\r\nreturn error;\r\n}\r\nstatic void nfs_server_set_fsinfo(struct nfs_server *server,\r\nstruct nfs_fh *mntfh,\r\nstruct nfs_fsinfo *fsinfo)\r\n{\r\nunsigned long max_rpc_payload;\r\nif (server->rsize == 0)\r\nserver->rsize = nfs_block_size(fsinfo->rtpref, NULL);\r\nif (server->wsize == 0)\r\nserver->wsize = nfs_block_size(fsinfo->wtpref, NULL);\r\nif (fsinfo->rtmax >= 512 && server->rsize > fsinfo->rtmax)\r\nserver->rsize = nfs_block_size(fsinfo->rtmax, NULL);\r\nif (fsinfo->wtmax >= 512 && server->wsize > fsinfo->wtmax)\r\nserver->wsize = nfs_block_size(fsinfo->wtmax, NULL);\r\nmax_rpc_payload = nfs_block_size(rpc_max_payload(server->client), NULL);\r\nif (server->rsize > max_rpc_payload)\r\nserver->rsize = max_rpc_payload;\r\nif (server->rsize > NFS_MAX_FILE_IO_SIZE)\r\nserver->rsize = NFS_MAX_FILE_IO_SIZE;\r\nserver->rpages = (server->rsize + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nserver->backing_dev_info.name = "nfs";\r\nserver->backing_dev_info.ra_pages = server->rpages * NFS_MAX_READAHEAD;\r\nif (server->wsize > max_rpc_payload)\r\nserver->wsize = max_rpc_payload;\r\nif (server->wsize > NFS_MAX_FILE_IO_SIZE)\r\nserver->wsize = NFS_MAX_FILE_IO_SIZE;\r\nserver->wpages = (server->wsize + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nserver->wtmult = nfs_block_bits(fsinfo->wtmult, NULL);\r\nserver->dtsize = nfs_block_size(fsinfo->dtpref, NULL);\r\nif (server->dtsize > PAGE_CACHE_SIZE * NFS_MAX_READDIR_PAGES)\r\nserver->dtsize = PAGE_CACHE_SIZE * NFS_MAX_READDIR_PAGES;\r\nif (server->dtsize > server->rsize)\r\nserver->dtsize = server->rsize;\r\nif (server->flags & NFS_MOUNT_NOAC) {\r\nserver->acregmin = server->acregmax = 0;\r\nserver->acdirmin = server->acdirmax = 0;\r\n}\r\nserver->maxfilesize = fsinfo->maxfilesize;\r\nserver->time_delta = fsinfo->time_delta;\r\nrpc_setbufsize(server->client, server->wsize + 100, server->rsize + 100);\r\n}\r\nint nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *mntfh, struct nfs_fattr *fattr)\r\n{\r\nstruct nfs_fsinfo fsinfo;\r\nstruct nfs_client *clp = server->nfs_client;\r\nint error;\r\ndprintk("--> nfs_probe_fsinfo()\n");\r\nif (clp->rpc_ops->set_capabilities != NULL) {\r\nerror = clp->rpc_ops->set_capabilities(server, mntfh);\r\nif (error < 0)\r\ngoto out_error;\r\n}\r\nfsinfo.fattr = fattr;\r\nfsinfo.layouttype = 0;\r\nerror = clp->rpc_ops->fsinfo(server, mntfh, &fsinfo);\r\nif (error < 0)\r\ngoto out_error;\r\nnfs_server_set_fsinfo(server, mntfh, &fsinfo);\r\nif (server->namelen == 0) {\r\nstruct nfs_pathconf pathinfo;\r\npathinfo.fattr = fattr;\r\nnfs_fattr_init(fattr);\r\nif (clp->rpc_ops->pathconf(server, mntfh, &pathinfo) >= 0)\r\nserver->namelen = pathinfo.max_namelen;\r\n}\r\ndprintk("<-- nfs_probe_fsinfo() = 0\n");\r\nreturn 0;\r\nout_error:\r\ndprintk("nfs_probe_fsinfo: error = %d\n", -error);\r\nreturn error;\r\n}\r\nvoid nfs_server_copy_userdata(struct nfs_server *target, struct nfs_server *source)\r\n{\r\ntarget->flags = source->flags;\r\ntarget->rsize = source->rsize;\r\ntarget->wsize = source->wsize;\r\ntarget->acregmin = source->acregmin;\r\ntarget->acregmax = source->acregmax;\r\ntarget->acdirmin = source->acdirmin;\r\ntarget->acdirmax = source->acdirmax;\r\ntarget->caps = source->caps;\r\ntarget->options = source->options;\r\ntarget->auth_info = source->auth_info;\r\n}\r\nvoid nfs_server_insert_lists(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\r\nspin_lock(&nn->nfs_client_lock);\r\nlist_add_tail_rcu(&server->client_link, &clp->cl_superblocks);\r\nlist_add_tail(&server->master_link, &nn->nfs_volume_list);\r\nclear_bit(NFS_CS_STOP_RENEW, &clp->cl_res_state);\r\nspin_unlock(&nn->nfs_client_lock);\r\n}\r\nvoid nfs_server_remove_lists(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs_net *nn;\r\nif (clp == NULL)\r\nreturn;\r\nnn = net_generic(clp->cl_net, nfs_net_id);\r\nspin_lock(&nn->nfs_client_lock);\r\nlist_del_rcu(&server->client_link);\r\nif (list_empty(&clp->cl_superblocks))\r\nset_bit(NFS_CS_STOP_RENEW, &clp->cl_res_state);\r\nlist_del(&server->master_link);\r\nspin_unlock(&nn->nfs_client_lock);\r\nsynchronize_rcu();\r\n}\r\nstruct nfs_server *nfs_alloc_server(void)\r\n{\r\nstruct nfs_server *server;\r\nserver = kzalloc(sizeof(struct nfs_server), GFP_KERNEL);\r\nif (!server)\r\nreturn NULL;\r\nserver->client = server->client_acl = ERR_PTR(-EINVAL);\r\nINIT_LIST_HEAD(&server->client_link);\r\nINIT_LIST_HEAD(&server->master_link);\r\nINIT_LIST_HEAD(&server->delegations);\r\nINIT_LIST_HEAD(&server->layouts);\r\nINIT_LIST_HEAD(&server->state_owners_lru);\r\natomic_set(&server->active, 0);\r\nserver->io_stats = nfs_alloc_iostats();\r\nif (!server->io_stats) {\r\nkfree(server);\r\nreturn NULL;\r\n}\r\nif (bdi_init(&server->backing_dev_info)) {\r\nnfs_free_iostats(server->io_stats);\r\nkfree(server);\r\nreturn NULL;\r\n}\r\nida_init(&server->openowner_id);\r\nida_init(&server->lockowner_id);\r\npnfs_init_server(server);\r\nreturn server;\r\n}\r\nvoid nfs_free_server(struct nfs_server *server)\r\n{\r\ndprintk("--> nfs_free_server()\n");\r\nnfs_server_remove_lists(server);\r\nif (server->destroy != NULL)\r\nserver->destroy(server);\r\nif (!IS_ERR(server->client_acl))\r\nrpc_shutdown_client(server->client_acl);\r\nif (!IS_ERR(server->client))\r\nrpc_shutdown_client(server->client);\r\nnfs_put_client(server->nfs_client);\r\nida_destroy(&server->lockowner_id);\r\nida_destroy(&server->openowner_id);\r\nnfs_free_iostats(server->io_stats);\r\nbdi_destroy(&server->backing_dev_info);\r\nkfree(server);\r\nnfs_release_automount_timer();\r\ndprintk("<-- nfs_free_server()\n");\r\n}\r\nstruct nfs_server *nfs_create_server(struct nfs_mount_info *mount_info,\r\nstruct nfs_subversion *nfs_mod)\r\n{\r\nstruct nfs_server *server;\r\nstruct nfs_fattr *fattr;\r\nint error;\r\nserver = nfs_alloc_server();\r\nif (!server)\r\nreturn ERR_PTR(-ENOMEM);\r\nerror = -ENOMEM;\r\nfattr = nfs_alloc_fattr();\r\nif (fattr == NULL)\r\ngoto error;\r\nerror = nfs_init_server(server, mount_info->parsed, nfs_mod);\r\nif (error < 0)\r\ngoto error;\r\nerror = nfs_probe_fsinfo(server, mount_info->mntfh, fattr);\r\nif (error < 0)\r\ngoto error;\r\nif (server->nfs_client->rpc_ops->version == 3) {\r\nif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\r\nserver->namelen = NFS3_MAXNAMLEN;\r\nif (!(mount_info->parsed->flags & NFS_MOUNT_NORDIRPLUS))\r\nserver->caps |= NFS_CAP_READDIRPLUS;\r\n} else {\r\nif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\r\nserver->namelen = NFS2_MAXNAMLEN;\r\n}\r\nif (!(fattr->valid & NFS_ATTR_FATTR)) {\r\nerror = nfs_mod->rpc_ops->getattr(server, mount_info->mntfh, fattr, NULL);\r\nif (error < 0) {\r\ndprintk("nfs_create_server: getattr error = %d\n", -error);\r\ngoto error;\r\n}\r\n}\r\nmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\r\ndprintk("Server FSID: %llx:%llx\n",\r\n(unsigned long long) server->fsid.major,\r\n(unsigned long long) server->fsid.minor);\r\nnfs_server_insert_lists(server);\r\nserver->mount_time = jiffies;\r\nnfs_free_fattr(fattr);\r\nreturn server;\r\nerror:\r\nnfs_free_fattr(fattr);\r\nnfs_free_server(server);\r\nreturn ERR_PTR(error);\r\n}\r\nstruct nfs_server *nfs_clone_server(struct nfs_server *source,\r\nstruct nfs_fh *fh,\r\nstruct nfs_fattr *fattr,\r\nrpc_authflavor_t flavor)\r\n{\r\nstruct nfs_server *server;\r\nstruct nfs_fattr *fattr_fsinfo;\r\nint error;\r\ndprintk("--> nfs_clone_server(,%llx:%llx,)\n",\r\n(unsigned long long) fattr->fsid.major,\r\n(unsigned long long) fattr->fsid.minor);\r\nserver = nfs_alloc_server();\r\nif (!server)\r\nreturn ERR_PTR(-ENOMEM);\r\nerror = -ENOMEM;\r\nfattr_fsinfo = nfs_alloc_fattr();\r\nif (fattr_fsinfo == NULL)\r\ngoto out_free_server;\r\nserver->nfs_client = source->nfs_client;\r\nserver->destroy = source->destroy;\r\natomic_inc(&server->nfs_client->cl_count);\r\nnfs_server_copy_userdata(server, source);\r\nserver->fsid = fattr->fsid;\r\nerror = nfs_init_server_rpcclient(server,\r\nsource->client->cl_timeout,\r\nflavor);\r\nif (error < 0)\r\ngoto out_free_server;\r\nerror = nfs_probe_fsinfo(server, fh, fattr_fsinfo);\r\nif (error < 0)\r\ngoto out_free_server;\r\nif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\r\nserver->namelen = NFS4_MAXNAMLEN;\r\ndprintk("Cloned FSID: %llx:%llx\n",\r\n(unsigned long long) server->fsid.major,\r\n(unsigned long long) server->fsid.minor);\r\nerror = nfs_start_lockd(server);\r\nif (error < 0)\r\ngoto out_free_server;\r\nnfs_server_insert_lists(server);\r\nserver->mount_time = jiffies;\r\nnfs_free_fattr(fattr_fsinfo);\r\ndprintk("<-- nfs_clone_server() = %p\n", server);\r\nreturn server;\r\nout_free_server:\r\nnfs_free_fattr(fattr_fsinfo);\r\nnfs_free_server(server);\r\ndprintk("<-- nfs_clone_server() = error %d\n", error);\r\nreturn ERR_PTR(error);\r\n}\r\nvoid nfs_clients_init(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nINIT_LIST_HEAD(&nn->nfs_client_list);\r\nINIT_LIST_HEAD(&nn->nfs_volume_list);\r\n#if IS_ENABLED(CONFIG_NFS_V4)\r\nidr_init(&nn->cb_ident_idr);\r\n#endif\r\nspin_lock_init(&nn->nfs_client_lock);\r\nnn->boot_time = CURRENT_TIME;\r\n}\r\nstatic int nfs_server_list_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nfs_server_list_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic void *nfs_server_list_start(struct seq_file *m, loff_t *_pos)\r\n__acquires(&nn->nfs_client_lock\r\nstatic void *nfs_server_list_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\r\nreturn seq_list_next(v, &nn->nfs_client_list, pos);\r\n}\r\nstatic void nfs_server_list_stop(struct seq_file *p, void *v)\r\n__releases(&nn->nfs_client_lock\r\nstatic int nfs_server_list_show(struct seq_file *m, void *v)\r\n{\r\nstruct nfs_client *clp;\r\nstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\r\nif (v == &nn->nfs_client_list) {\r\nseq_puts(m, "NV SERVER PORT USE HOSTNAME\n");\r\nreturn 0;\r\n}\r\nclp = list_entry(v, struct nfs_client, cl_share_link);\r\nif (clp->cl_cons_state != NFS_CS_READY)\r\nreturn 0;\r\nrcu_read_lock();\r\nseq_printf(m, "v%u %s %s %3d %s\n",\r\nclp->rpc_ops->version,\r\nrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_ADDR),\r\nrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_PORT),\r\natomic_read(&clp->cl_count),\r\nclp->cl_hostname);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int nfs_volume_list_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nfs_volume_list_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic void *nfs_volume_list_start(struct seq_file *m, loff_t *_pos)\r\n__acquires(&nn->nfs_client_lock\r\nstatic void *nfs_volume_list_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nstruct nfs_net *nn = net_generic(seq_file_net(p), nfs_net_id);\r\nreturn seq_list_next(v, &nn->nfs_volume_list, pos);\r\n}\r\nstatic void nfs_volume_list_stop(struct seq_file *p, void *v)\r\n__releases(&nn->nfs_client_lock\r\nstatic int nfs_volume_list_show(struct seq_file *m, void *v)\r\n{\r\nstruct nfs_server *server;\r\nstruct nfs_client *clp;\r\nchar dev[8], fsid[17];\r\nstruct nfs_net *nn = net_generic(seq_file_net(m), nfs_net_id);\r\nif (v == &nn->nfs_volume_list) {\r\nseq_puts(m, "NV SERVER PORT DEV FSID FSC\n");\r\nreturn 0;\r\n}\r\nserver = list_entry(v, struct nfs_server, master_link);\r\nclp = server->nfs_client;\r\nsnprintf(dev, 8, "%u:%u",\r\nMAJOR(server->s_dev), MINOR(server->s_dev));\r\nsnprintf(fsid, 17, "%llx:%llx",\r\n(unsigned long long) server->fsid.major,\r\n(unsigned long long) server->fsid.minor);\r\nrcu_read_lock();\r\nseq_printf(m, "v%u %s %s %-7s %-17s %s\n",\r\nclp->rpc_ops->version,\r\nrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_ADDR),\r\nrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_HEX_PORT),\r\ndev,\r\nfsid,\r\nnfs_server_fscache_state(server));\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint nfs_fs_proc_net_init(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct proc_dir_entry *p;\r\nnn->proc_nfsfs = proc_net_mkdir(net, "nfsfs", net->proc_net);\r\nif (!nn->proc_nfsfs)\r\ngoto error_0;\r\np = proc_create("servers", S_IFREG|S_IRUGO,\r\nnn->proc_nfsfs, &nfs_server_list_fops);\r\nif (!p)\r\ngoto error_1;\r\np = proc_create("volumes", S_IFREG|S_IRUGO,\r\nnn->proc_nfsfs, &nfs_volume_list_fops);\r\nif (!p)\r\ngoto error_1;\r\nreturn 0;\r\nerror_1:\r\nremove_proc_subtree("nfsfs", net->proc_net);\r\nerror_0:\r\nreturn -ENOMEM;\r\n}\r\nvoid nfs_fs_proc_net_exit(struct net *net)\r\n{\r\nremove_proc_subtree("nfsfs", net->proc_net);\r\n}\r\nint __init nfs_fs_proc_init(void)\r\n{\r\nstruct proc_dir_entry *p;\r\nproc_fs_nfs = proc_mkdir("fs/nfsfs", NULL);\r\nif (!proc_fs_nfs)\r\ngoto error_0;\r\np = proc_symlink("servers", proc_fs_nfs, "../../net/nfsfs/servers");\r\nif (!p)\r\ngoto error_1;\r\np = proc_symlink("volumes", proc_fs_nfs, "../../net/nfsfs/volumes");\r\nif (!p)\r\ngoto error_2;\r\nreturn 0;\r\nerror_2:\r\nremove_proc_entry("servers", proc_fs_nfs);\r\nerror_1:\r\nremove_proc_entry("fs/nfsfs", NULL);\r\nerror_0:\r\nreturn -ENOMEM;\r\n}\r\nvoid nfs_fs_proc_exit(void)\r\n{\r\nremove_proc_entry("volumes", proc_fs_nfs);\r\nremove_proc_entry("servers", proc_fs_nfs);\r\nremove_proc_entry("fs/nfsfs", NULL);\r\n}
