static bool wm8753_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == WM8753_RESET;\r\n}\r\nstatic bool wm8753_writeable(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg <= WM8753_ADCTL2;\r\n}\r\nstatic int wm8753_get_dai(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = wm8753->dai_func;\r\nreturn 0;\r\n}\r\nstatic int wm8753_set_dai(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nu16 ioctl;\r\nif (wm8753->dai_func == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (snd_soc_codec_is_active(codec))\r\nreturn -EBUSY;\r\nioctl = snd_soc_read(codec, WM8753_IOCTL);\r\nwm8753->dai_func = ucontrol->value.integer.value[0];\r\nif (((ioctl >> 2) & 0x3) == wm8753->dai_func)\r\nreturn 1;\r\nioctl = (ioctl & 0x1f3) | (wm8753->dai_func << 2);\r\nsnd_soc_write(codec, WM8753_IOCTL, ioctl);\r\nwm8753_hifi_write_dai_fmt(codec, wm8753->hifi_fmt);\r\nwm8753_voice_write_dai_fmt(codec, wm8753->voice_fmt);\r\nreturn 1;\r\n}\r\nstatic void pll_factors(struct _pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div->div2 = 1;\r\nNdiv = target / source;\r\n} else\r\npll_div->div2 = 0;\r\nif ((Ndiv < 6) || (Ndiv > 12))\r\nprintk(KERN_WARNING\r\n"wm8753: unsupported N = %u\n", Ndiv);\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\n}\r\nstatic int wm8753_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nu16 reg, enable;\r\nint offset;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nif (pll_id < WM8753_PLL1 || pll_id > WM8753_PLL2)\r\nreturn -ENODEV;\r\nif (pll_id == WM8753_PLL1) {\r\noffset = 0;\r\nenable = 0x10;\r\nreg = snd_soc_read(codec, WM8753_CLOCK) & 0xffef;\r\n} else {\r\noffset = 4;\r\nenable = 0x8;\r\nreg = snd_soc_read(codec, WM8753_CLOCK) & 0xfff7;\r\n}\r\nif (!freq_in || !freq_out) {\r\nsnd_soc_write(codec, WM8753_PLL1CTL1 + offset, 0x0026);\r\nsnd_soc_write(codec, WM8753_CLOCK, reg);\r\nreturn 0;\r\n} else {\r\nu16 value = 0;\r\nstruct _pll_div pll_div;\r\npll_factors(&pll_div, freq_out * 8, freq_in);\r\nvalue = (pll_div.n << 5) + ((pll_div.k & 0x3c0000) >> 18);\r\nsnd_soc_write(codec, WM8753_PLL1CTL2 + offset, value);\r\nvalue = (pll_div.k & 0x03fe00) >> 9;\r\nsnd_soc_write(codec, WM8753_PLL1CTL3 + offset, value);\r\nvalue = pll_div.k & 0x0001ff;\r\nsnd_soc_write(codec, WM8753_PLL1CTL4 + offset, value);\r\nsnd_soc_write(codec, WM8753_PLL1CTL1 + offset, 0x0027 |\r\n(pll_div.div2 << 3));\r\nsnd_soc_write(codec, WM8753_CLOCK, reg | enable);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_coeff(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\r\nif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8753_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 11289600:\r\ncase 12000000:\r\ncase 12288000:\r\ncase 16934400:\r\ncase 18432000:\r\nif (clk_id == WM8753_MCLK) {\r\nwm8753->sysclk = freq;\r\nreturn 0;\r\n} else if (clk_id == WM8753_PCMCLK) {\r\nwm8753->pcmclk = freq;\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8753_vdac_adc_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 voice = snd_soc_read(codec, WM8753_PCM) & 0x01ec;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nvoice |= 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nvoice |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nvoice |= 0x0003;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nvoice |= 0x0013;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8753_PCM, voice);\r\nreturn 0;\r\n}\r\nstatic int wm8753_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nu16 voice = snd_soc_read(codec, WM8753_PCM) & 0x01f3;\r\nu16 srate = snd_soc_read(codec, WM8753_SRATE1) & 0x017f;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nvoice |= 0x0004;\r\nbreak;\r\ncase 24:\r\nvoice |= 0x0008;\r\nbreak;\r\ncase 32:\r\nvoice |= 0x000c;\r\nbreak;\r\n}\r\nif (params_rate(params) * 384 == wm8753->pcmclk)\r\nsrate |= 0x80;\r\nsnd_soc_write(codec, WM8753_SRATE1, srate);\r\nsnd_soc_write(codec, WM8753_PCM, voice);\r\nreturn 0;\r\n}\r\nstatic int wm8753_pcm_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 voice, ioctl;\r\nvoice = snd_soc_read(codec, WM8753_PCM) & 0x011f;\r\nioctl = snd_soc_read(codec, WM8753_IOCTL) & 0x015d;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nioctl |= 0x2;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nvoice |= 0x0040;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nvoice |= 0x0080;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nvoice &= ~0x0010;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nvoice |= 0x0090;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nvoice |= 0x0080;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nvoice |= 0x0010;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8753_PCM, voice);\r\nsnd_soc_write(codec, WM8753_IOCTL, ioctl);\r\nreturn 0;\r\n}\r\nstatic int wm8753_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8753_PCMDIV:\r\nreg = snd_soc_read(codec, WM8753_CLOCK) & 0x003f;\r\nsnd_soc_write(codec, WM8753_CLOCK, reg | div);\r\nbreak;\r\ncase WM8753_BCLKDIV:\r\nreg = snd_soc_read(codec, WM8753_SRATE2) & 0x01c7;\r\nsnd_soc_write(codec, WM8753_SRATE2, reg | div);\r\nbreak;\r\ncase WM8753_VXCLKDIV:\r\nreg = snd_soc_read(codec, WM8753_SRATE2) & 0x003f;\r\nsnd_soc_write(codec, WM8753_SRATE2, reg | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8753_hdac_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 hifi = snd_soc_read(codec, WM8753_HIFI) & 0x01e0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nhifi |= 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nhifi |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nhifi |= 0x0003;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nhifi |= 0x0013;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8753_HIFI, hifi);\r\nreturn 0;\r\n}\r\nstatic int wm8753_i2s_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 ioctl, hifi;\r\nhifi = snd_soc_read(codec, WM8753_HIFI) & 0x011f;\r\nioctl = snd_soc_read(codec, WM8753_IOCTL) & 0x00ae;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nioctl |= 0x1;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nhifi |= 0x0040;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nhifi |= 0x0080;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nhifi &= ~0x0010;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nhifi |= 0x0090;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nhifi |= 0x0080;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nhifi |= 0x0010;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8753_HIFI, hifi);\r\nsnd_soc_write(codec, WM8753_IOCTL, ioctl);\r\nreturn 0;\r\n}\r\nstatic int wm8753_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nu16 srate = snd_soc_read(codec, WM8753_SRATE1) & 0x01c0;\r\nu16 hifi = snd_soc_read(codec, WM8753_HIFI) & 0x01f3;\r\nint coeff;\r\ncoeff = get_coeff(wm8753->sysclk, params_rate(params));\r\nif (coeff < 0) {\r\nprintk(KERN_ERR "wm8753 invalid MCLK or rate\n");\r\nreturn coeff;\r\n}\r\nsnd_soc_write(codec, WM8753_SRATE1, srate | (coeff_div[coeff].sr << 1) |\r\ncoeff_div[coeff].usb);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nhifi |= 0x0004;\r\nbreak;\r\ncase 24:\r\nhifi |= 0x0008;\r\nbreak;\r\ncase 32:\r\nhifi |= 0x000c;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8753_HIFI, hifi);\r\nreturn 0;\r\n}\r\nstatic int wm8753_mode1v_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 clock;\r\nclock = snd_soc_read(codec, WM8753_CLOCK) & 0xfffb;\r\nsnd_soc_write(codec, WM8753_CLOCK, clock);\r\nreturn wm8753_vdac_adc_set_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_mode1h_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nreturn wm8753_hdac_set_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_mode2_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 clock;\r\nclock = snd_soc_read(codec, WM8753_CLOCK) & 0xfffb;\r\nsnd_soc_write(codec, WM8753_CLOCK, clock);\r\nreturn wm8753_vdac_adc_set_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_mode3_4_set_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nu16 clock;\r\nclock = snd_soc_read(codec, WM8753_CLOCK) & 0xfffb;\r\nsnd_soc_write(codec, WM8753_CLOCK, clock | 0x4);\r\nif (wm8753_hdac_set_dai_fmt(codec, fmt) < 0)\r\nreturn -EINVAL;\r\nreturn wm8753_vdac_adc_set_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_hifi_write_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (wm8753->dai_func) {\r\ncase 0:\r\nret = wm8753_mode1h_set_dai_fmt(codec, fmt);\r\nbreak;\r\ncase 1:\r\nret = wm8753_mode2_set_dai_fmt(codec, fmt);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nret = wm8753_mode3_4_set_dai_fmt(codec, fmt);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn wm8753_i2s_set_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_hifi_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nwm8753->hifi_fmt = fmt;\r\nreturn wm8753_hifi_write_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_voice_write_dai_fmt(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif (wm8753->dai_func != 0)\r\nreturn 0;\r\nret = wm8753_mode1v_set_dai_fmt(codec, fmt);\r\nif (ret)\r\nreturn ret;\r\nret = wm8753_pcm_set_dai_fmt(codec, fmt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int wm8753_voice_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nwm8753->voice_fmt = fmt;\r\nreturn wm8753_voice_write_dai_fmt(codec, fmt);\r\n}\r\nstatic int wm8753_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 mute_reg = snd_soc_read(codec, WM8753_DAC) & 0xfff7;\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nif (mute && wm8753->dai_func == 1) {\r\nif (!snd_soc_codec_is_active(codec))\r\nsnd_soc_write(codec, WM8753_DAC, mute_reg | 0x8);\r\n} else {\r\nif (mute)\r\nsnd_soc_write(codec, WM8753_DAC, mute_reg | 0x8);\r\nelse\r\nsnd_soc_write(codec, WM8753_DAC, mute_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8753_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 pwr_reg = snd_soc_read(codec, WM8753_PWR1) & 0xfe3e;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_write(codec, WM8753_PWR1, pwr_reg | 0x00c0);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_write(codec, WM8753_PWR1, pwr_reg | 0x01c1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec, WM8753_PWR1, pwr_reg | 0x0141);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8753_PWR1, 0x0001);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic void wm8753_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_dapm_context *dapm =\r\ncontainer_of(work, struct snd_soc_dapm_context,\r\ndelayed_work.work);\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);\r\nwm8753_set_bias_level(codec, dapm->bias_level);\r\n}\r\nstatic int wm8753_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8753_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(wm8753->regmap);\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (codec->dapm.suspend_bias_level == SND_SOC_BIAS_ON) {\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_PREPARE);\r\ncodec->dapm.bias_level = SND_SOC_BIAS_ON;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&codec->dapm.delayed_work,\r\nmsecs_to_jiffies(caps_charge));\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8753_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8753_priv *wm8753 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nINIT_DELAYED_WORK(&codec->dapm.delayed_work, wm8753_work);\r\nret = wm8753_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nwm8753->dai_func = 0;\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_PREPARE);\r\nschedule_delayed_work(&codec->dapm.delayed_work,\r\nmsecs_to_jiffies(caps_charge));\r\nsnd_soc_update_bits(codec, WM8753_LDAC, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_RDAC, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_LADC, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_RADC, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_LOUT1V, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_ROUT1V, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_LOUT2V, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_ROUT2V, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_LINVOL, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec, WM8753_RINVOL, 0x0100, 0x0100);\r\nreturn 0;\r\n}\r\nstatic int wm8753_remove(struct snd_soc_codec *codec)\r\n{\r\nflush_delayed_work(&codec->dapm.delayed_work);\r\nwm8753_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8753_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8753_priv *wm8753;\r\nint ret;\r\nwm8753 = devm_kzalloc(&spi->dev, sizeof(struct wm8753_priv),\r\nGFP_KERNEL);\r\nif (wm8753 == NULL)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, wm8753);\r\nwm8753->regmap = devm_regmap_init_spi(spi, &wm8753_regmap);\r\nif (IS_ERR(wm8753->regmap)) {\r\nret = PTR_ERR(wm8753->regmap);\r\ndev_err(&spi->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&spi->dev, &soc_codec_dev_wm8753,\r\nwm8753_dai, ARRAY_SIZE(wm8753_dai));\r\nif (ret != 0)\r\ndev_err(&spi->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int wm8753_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int wm8753_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8753_priv *wm8753;\r\nint ret;\r\nwm8753 = devm_kzalloc(&i2c->dev, sizeof(struct wm8753_priv),\r\nGFP_KERNEL);\r\nif (wm8753 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8753);\r\nwm8753->regmap = devm_regmap_init_i2c(i2c, &wm8753_regmap);\r\nif (IS_ERR(wm8753->regmap)) {\r\nret = PTR_ERR(wm8753->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_wm8753,\r\nwm8753_dai, ARRAY_SIZE(wm8753_dai));\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int wm8753_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8753_modinit(void)\r\n{\r\nint ret = 0;\r\n#if IS_ENABLED(CONFIG_I2C)\r\nret = i2c_add_driver(&wm8753_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8753 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8753_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8753 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8753_exit(void)\r\n{\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_driver(&wm8753_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8753_spi_driver);\r\n#endif\r\n}
