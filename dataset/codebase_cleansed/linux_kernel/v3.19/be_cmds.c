static bool be_cmd_allowed(struct be_adapter *adapter, u8 opcode, u8 subsystem)\r\n{\r\nint i;\r\nint num_entries = sizeof(cmd_priv_map)/sizeof(struct be_cmd_priv_map);\r\nu32 cmd_privileges = adapter->cmd_privileges;\r\nfor (i = 0; i < num_entries; i++)\r\nif (opcode == cmd_priv_map[i].opcode &&\r\nsubsystem == cmd_priv_map[i].subsystem)\r\nif (!(cmd_privileges & cmd_priv_map[i].priv_mask))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline void *embedded_payload(struct be_mcc_wrb *wrb)\r\n{\r\nreturn wrb->payload.embedded_payload;\r\n}\r\nstatic void be_mcc_notify(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mccq = &adapter->mcc_obj.q;\r\nu32 val = 0;\r\nif (be_error(adapter))\r\nreturn;\r\nval |= mccq->id & DB_MCCQ_RING_ID_MASK;\r\nval |= 1 << DB_MCCQ_NUM_POSTED_SHIFT;\r\nwmb();\r\niowrite32(val, adapter->db + DB_MCCQ_OFFSET);\r\n}\r\nstatic inline bool be_mcc_compl_is_new(struct be_mcc_compl *compl)\r\n{\r\nu32 flags;\r\nif (compl->flags != 0) {\r\nflags = le32_to_cpu(compl->flags);\r\nif (flags & CQE_FLAGS_VALID_MASK) {\r\ncompl->flags = flags;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic inline void be_mcc_compl_use(struct be_mcc_compl *compl)\r\n{\r\ncompl->flags = 0;\r\n}\r\nstatic struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0, u32 tag1)\r\n{\r\nunsigned long addr;\r\naddr = tag1;\r\naddr = ((addr << 16) << 16) | tag0;\r\nreturn (void *)addr;\r\n}\r\nstatic bool be_skip_err_log(u8 opcode, u16 base_status, u16 addl_status)\r\n{\r\nif (base_status == MCC_STATUS_NOT_SUPPORTED ||\r\nbase_status == MCC_STATUS_ILLEGAL_REQUEST ||\r\naddl_status == MCC_ADDL_STATUS_TOO_MANY_INTERFACES ||\r\n(opcode == OPCODE_COMMON_WRITE_FLASHROM &&\r\n(base_status == MCC_STATUS_ILLEGAL_FIELD ||\r\naddl_status == MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH)))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void be_async_cmd_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl,\r\nstruct be_cmd_resp_hdr *resp_hdr)\r\n{\r\nenum mcc_base_status base_status = base_status(compl->status);\r\nu8 opcode = 0, subsystem = 0;\r\nif (resp_hdr) {\r\nopcode = resp_hdr->opcode;\r\nsubsystem = resp_hdr->subsystem;\r\n}\r\nif (opcode == OPCODE_LOWLEVEL_LOOPBACK_TEST &&\r\nsubsystem == CMD_SUBSYSTEM_LOWLEVEL) {\r\ncomplete(&adapter->et_cmd_compl);\r\nreturn;\r\n}\r\nif ((opcode == OPCODE_COMMON_WRITE_FLASHROM ||\r\nopcode == OPCODE_COMMON_WRITE_OBJECT) &&\r\nsubsystem == CMD_SUBSYSTEM_COMMON) {\r\nadapter->flash_status = compl->status;\r\ncomplete(&adapter->et_cmd_compl);\r\nreturn;\r\n}\r\nif ((opcode == OPCODE_ETH_GET_STATISTICS ||\r\nopcode == OPCODE_ETH_GET_PPORT_STATS) &&\r\nsubsystem == CMD_SUBSYSTEM_ETH &&\r\nbase_status == MCC_STATUS_SUCCESS) {\r\nbe_parse_stats(adapter);\r\nadapter->stats_cmd_sent = false;\r\nreturn;\r\n}\r\nif (opcode == OPCODE_COMMON_GET_CNTL_ADDITIONAL_ATTRIBUTES &&\r\nsubsystem == CMD_SUBSYSTEM_COMMON) {\r\nif (base_status == MCC_STATUS_SUCCESS) {\r\nstruct be_cmd_resp_get_cntl_addnl_attribs *resp =\r\n(void *)resp_hdr;\r\nadapter->drv_stats.be_on_die_temperature =\r\nresp->on_die_temperature;\r\n} else {\r\nadapter->be_get_temp_freq = 0;\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic int be_mcc_compl_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nenum mcc_base_status base_status;\r\nenum mcc_addl_status addl_status;\r\nstruct be_cmd_resp_hdr *resp_hdr;\r\nu8 opcode = 0, subsystem = 0;\r\nbe_dws_le_to_cpu(compl, 4);\r\nbase_status = base_status(compl->status);\r\naddl_status = addl_status(compl->status);\r\nresp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);\r\nif (resp_hdr) {\r\nopcode = resp_hdr->opcode;\r\nsubsystem = resp_hdr->subsystem;\r\n}\r\nbe_async_cmd_process(adapter, compl, resp_hdr);\r\nif (base_status != MCC_STATUS_SUCCESS &&\r\n!be_skip_err_log(opcode, base_status, addl_status)) {\r\nif (base_status == MCC_STATUS_UNAUTHORIZED_REQUEST) {\r\ndev_warn(&adapter->pdev->dev,\r\n"VF is not privileged to issue opcode %d-%d\n",\r\nopcode, subsystem);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"opcode %d-%d failed:status %d-%d\n",\r\nopcode, subsystem, base_status, addl_status);\r\n}\r\n}\r\nreturn compl->status;\r\n}\r\nstatic void be_async_link_state_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_link_state *evt =\r\n(struct be_async_event_link_state *)compl;\r\nadapter->phy.link_speed = -1;\r\nif (!BEx_chip(adapter) &&\r\n!(evt->port_link_status & LOGICAL_LINK_STATUS_MASK))\r\nreturn;\r\nif (adapter->flags & BE_FLAGS_LINK_STATUS_INIT)\r\nbe_link_status_update(adapter,\r\nevt->port_link_status & LINK_STATUS_MASK);\r\n}\r\nstatic void be_async_grp5_cos_priority_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_cos_priority *evt =\r\n(struct be_async_event_grp5_cos_priority *)compl;\r\nif (evt->valid) {\r\nadapter->vlan_prio_bmap = evt->available_priority_bmap;\r\nadapter->recommended_prio &= ~VLAN_PRIO_MASK;\r\nadapter->recommended_prio =\r\nevt->reco_default_priority << VLAN_PRIO_SHIFT;\r\n}\r\n}\r\nstatic void be_async_grp5_qos_speed_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_qos_link_speed *evt =\r\n(struct be_async_event_grp5_qos_link_speed *)compl;\r\nif (adapter->phy.link_speed >= 0 &&\r\nevt->physical_port == adapter->port_num)\r\nadapter->phy.link_speed = le16_to_cpu(evt->qos_link_speed) * 10;\r\n}\r\nstatic void be_async_grp5_pvid_state_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_pvid_state *evt =\r\n(struct be_async_event_grp5_pvid_state *)compl;\r\nif (evt->enabled) {\r\nadapter->pvid = le16_to_cpu(evt->tag) & VLAN_VID_MASK;\r\ndev_info(&adapter->pdev->dev, "LPVID: %d\n", adapter->pvid);\r\n} else {\r\nadapter->pvid = 0;\r\n}\r\n}\r\nstatic void be_async_grp5_evt_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nu8 event_type = (compl->flags >> ASYNC_EVENT_TYPE_SHIFT) &\r\nASYNC_EVENT_TYPE_MASK;\r\nswitch (event_type) {\r\ncase ASYNC_EVENT_COS_PRIORITY:\r\nbe_async_grp5_cos_priority_process(adapter, compl);\r\nbreak;\r\ncase ASYNC_EVENT_QOS_SPEED:\r\nbe_async_grp5_qos_speed_process(adapter, compl);\r\nbreak;\r\ncase ASYNC_EVENT_PVID_STATE:\r\nbe_async_grp5_pvid_state_process(adapter, compl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void be_async_dbg_evt_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *cmp)\r\n{\r\nu8 event_type = 0;\r\nstruct be_async_event_qnq *evt = (struct be_async_event_qnq *)cmp;\r\nevent_type = (cmp->flags >> ASYNC_EVENT_TYPE_SHIFT) &\r\nASYNC_EVENT_TYPE_MASK;\r\nswitch (event_type) {\r\ncase ASYNC_DEBUG_EVENT_TYPE_QNQ:\r\nif (evt->valid)\r\nadapter->qnq_vid = le16_to_cpu(evt->vlan_tag);\r\nadapter->flags |= BE_FLAGS_QNQ_ASYNC_EVT_RCVD;\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->pdev->dev, "Unknown debug event 0x%x!\n",\r\nevent_type);\r\nbreak;\r\n}\r\n}\r\nstatic inline bool is_link_state_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_LINK_STATE;\r\n}\r\nstatic inline bool is_grp5_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_GRP_5;\r\n}\r\nstatic inline bool is_dbg_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_QNQ;\r\n}\r\nstatic void be_mcc_event_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nif (is_link_state_evt(compl->flags))\r\nbe_async_link_state_process(adapter, compl);\r\nelse if (is_grp5_evt(compl->flags))\r\nbe_async_grp5_evt_process(adapter, compl);\r\nelse if (is_dbg_evt(compl->flags))\r\nbe_async_dbg_evt_process(adapter, compl);\r\n}\r\nstatic struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mcc_cq = &adapter->mcc_obj.cq;\r\nstruct be_mcc_compl *compl = queue_tail_node(mcc_cq);\r\nif (be_mcc_compl_is_new(compl)) {\r\nqueue_tail_inc(mcc_cq);\r\nreturn compl;\r\n}\r\nreturn NULL;\r\n}\r\nvoid be_async_mcc_enable(struct be_adapter *adapter)\r\n{\r\nspin_lock_bh(&adapter->mcc_cq_lock);\r\nbe_cq_notify(adapter, adapter->mcc_obj.cq.id, true, 0);\r\nadapter->mcc_obj.rearm_cq = true;\r\nspin_unlock_bh(&adapter->mcc_cq_lock);\r\n}\r\nvoid be_async_mcc_disable(struct be_adapter *adapter)\r\n{\r\nspin_lock_bh(&adapter->mcc_cq_lock);\r\nadapter->mcc_obj.rearm_cq = false;\r\nbe_cq_notify(adapter, adapter->mcc_obj.cq.id, false, 0);\r\nspin_unlock_bh(&adapter->mcc_cq_lock);\r\n}\r\nint be_process_mcc(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_compl *compl;\r\nint num = 0, status = 0;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nspin_lock(&adapter->mcc_cq_lock);\r\nwhile ((compl = be_mcc_compl_get(adapter))) {\r\nif (compl->flags & CQE_FLAGS_ASYNC_MASK) {\r\nbe_mcc_event_process(adapter, compl);\r\n} else if (compl->flags & CQE_FLAGS_COMPLETED_MASK) {\r\nstatus = be_mcc_compl_process(adapter, compl);\r\natomic_dec(&mcc_obj->q.used);\r\n}\r\nbe_mcc_compl_use(compl);\r\nnum++;\r\n}\r\nif (num)\r\nbe_cq_notify(adapter, mcc_obj->cq.id, mcc_obj->rearm_cq, num);\r\nspin_unlock(&adapter->mcc_cq_lock);\r\nreturn status;\r\n}\r\nstatic int be_mcc_wait_compl(struct be_adapter *adapter)\r\n{\r\n#define mcc_timeout 120000\r\nint i, status = 0;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nfor (i = 0; i < mcc_timeout; i++) {\r\nif (be_error(adapter))\r\nreturn -EIO;\r\nlocal_bh_disable();\r\nstatus = be_process_mcc(adapter);\r\nlocal_bh_enable();\r\nif (atomic_read(&mcc_obj->q.used) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (i == mcc_timeout) {\r\ndev_err(&adapter->pdev->dev, "FW not responding\n");\r\nadapter->fw_timeout = true;\r\nreturn -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int be_mcc_notify_wait(struct be_adapter *adapter)\r\n{\r\nint status;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nu16 index = mcc_obj->q.head;\r\nstruct be_cmd_resp_hdr *resp;\r\nindex_dec(&index, mcc_obj->q.len);\r\nwrb = queue_index_node(&mcc_obj->q, index);\r\nresp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);\r\nbe_mcc_notify(adapter);\r\nstatus = be_mcc_wait_compl(adapter);\r\nif (status == -EIO)\r\ngoto out;\r\nstatus = (resp->base_status |\r\n((resp->addl_status & CQE_ADDL_STATUS_MASK) <<\r\nCQE_ADDL_STATUS_SHIFT));\r\nout:\r\nreturn status;\r\n}\r\nstatic int be_mbox_db_ready_wait(struct be_adapter *adapter, void __iomem *db)\r\n{\r\nint msecs = 0;\r\nu32 ready;\r\ndo {\r\nif (be_error(adapter))\r\nreturn -EIO;\r\nready = ioread32(db);\r\nif (ready == 0xffffffff)\r\nreturn -1;\r\nready &= MPU_MAILBOX_DB_RDY_MASK;\r\nif (ready)\r\nbreak;\r\nif (msecs > 4000) {\r\ndev_err(&adapter->pdev->dev, "FW not responding\n");\r\nadapter->fw_timeout = true;\r\nbe_detect_error(adapter);\r\nreturn -1;\r\n}\r\nmsleep(1);\r\nmsecs++;\r\n} while (true);\r\nreturn 0;\r\n}\r\nstatic int be_mbox_notify_wait(struct be_adapter *adapter)\r\n{\r\nint status;\r\nu32 val = 0;\r\nvoid __iomem *db = adapter->db + MPU_MAILBOX_DB_OFFSET;\r\nstruct be_dma_mem *mbox_mem = &adapter->mbox_mem;\r\nstruct be_mcc_mailbox *mbox = mbox_mem->va;\r\nstruct be_mcc_compl *compl = &mbox->compl;\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nval |= MPU_MAILBOX_DB_HI_MASK;\r\nval |= (upper_32_bits(mbox_mem->dma) >> 2) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nval = 0;\r\nval |= (u32)(mbox_mem->dma >> 4) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nif (be_mcc_compl_is_new(compl)) {\r\nstatus = be_mcc_compl_process(adapter, &mbox->compl);\r\nbe_mcc_compl_use(compl);\r\nif (status)\r\nreturn status;\r\n} else {\r\ndev_err(&adapter->pdev->dev, "invalid mailbox completion\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 be_POST_stage_get(struct be_adapter *adapter)\r\n{\r\nu32 sem;\r\nif (BEx_chip(adapter))\r\nsem = ioread32(adapter->csr + SLIPORT_SEMAPHORE_OFFSET_BEx);\r\nelse\r\npci_read_config_dword(adapter->pdev,\r\nSLIPORT_SEMAPHORE_OFFSET_SH, &sem);\r\nreturn sem & POST_STAGE_MASK;\r\n}\r\nstatic int lancer_wait_ready(struct be_adapter *adapter)\r\n{\r\n#define SLIPORT_READY_TIMEOUT 30\r\nu32 sliport_status;\r\nint status = 0, i;\r\nfor (i = 0; i < SLIPORT_READY_TIMEOUT; i++) {\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nif (sliport_status & SLIPORT_STATUS_RDY_MASK)\r\nbreak;\r\nmsleep(1000);\r\n}\r\nif (i == SLIPORT_READY_TIMEOUT)\r\nstatus = -1;\r\nreturn status;\r\n}\r\nstatic bool lancer_provisioning_error(struct be_adapter *adapter)\r\n{\r\nu32 sliport_status = 0, sliport_err1 = 0, sliport_err2 = 0;\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nif (sliport_status & SLIPORT_STATUS_ERR_MASK) {\r\nsliport_err1 = ioread32(adapter->db + SLIPORT_ERROR1_OFFSET);\r\nsliport_err2 = ioread32(adapter->db + SLIPORT_ERROR2_OFFSET);\r\nif (sliport_err1 == SLIPORT_ERROR_NO_RESOURCE1 &&\r\nsliport_err2 == SLIPORT_ERROR_NO_RESOURCE2)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint lancer_test_and_set_rdy_state(struct be_adapter *adapter)\r\n{\r\nint status;\r\nu32 sliport_status, err, reset_needed;\r\nbool resource_error;\r\nresource_error = lancer_provisioning_error(adapter);\r\nif (resource_error)\r\nreturn -EAGAIN;\r\nstatus = lancer_wait_ready(adapter);\r\nif (!status) {\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nerr = sliport_status & SLIPORT_STATUS_ERR_MASK;\r\nreset_needed = sliport_status & SLIPORT_STATUS_RN_MASK;\r\nif (err && reset_needed) {\r\niowrite32(SLI_PORT_CONTROL_IP_MASK,\r\nadapter->db + SLIPORT_CONTROL_OFFSET);\r\nstatus = lancer_wait_ready(adapter);\r\nsliport_status = ioread32(adapter->db +\r\nSLIPORT_STATUS_OFFSET);\r\nsliport_status &= (SLIPORT_STATUS_ERR_MASK |\r\nSLIPORT_STATUS_RN_MASK);\r\nif (status || sliport_status)\r\nstatus = -1;\r\n} else if (err || reset_needed) {\r\nstatus = -1;\r\n}\r\n}\r\nresource_error = lancer_provisioning_error(adapter);\r\nif (resource_error)\r\nstatus = -EAGAIN;\r\nreturn status;\r\n}\r\nint be_fw_wait_ready(struct be_adapter *adapter)\r\n{\r\nu16 stage;\r\nint status, timeout = 0;\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (lancer_chip(adapter)) {\r\nstatus = lancer_wait_ready(adapter);\r\nreturn status;\r\n}\r\ndo {\r\nstage = be_POST_stage_get(adapter);\r\nif (stage == POST_STAGE_ARMFW_RDY)\r\nreturn 0;\r\ndev_info(dev, "Waiting for POST, %ds elapsed\n", timeout);\r\nif (msleep_interruptible(2000)) {\r\ndev_err(dev, "Waiting for POST aborted\n");\r\nreturn -EINTR;\r\n}\r\ntimeout += 2;\r\n} while (timeout < 60);\r\ndev_err(dev, "POST timeout; stage=0x%x\n", stage);\r\nreturn -1;\r\n}\r\nstatic inline struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb)\r\n{\r\nreturn &wrb->payload.sgl[0];\r\n}\r\nstatic inline void fill_wrb_tags(struct be_mcc_wrb *wrb, unsigned long addr)\r\n{\r\nwrb->tag0 = addr & 0xFFFFFFFF;\r\nwrb->tag1 = upper_32_bits(addr);\r\n}\r\nstatic void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr,\r\nu8 subsystem, u8 opcode, int cmd_len,\r\nstruct be_mcc_wrb *wrb,\r\nstruct be_dma_mem *mem)\r\n{\r\nstruct be_sge *sge;\r\nreq_hdr->opcode = opcode;\r\nreq_hdr->subsystem = subsystem;\r\nreq_hdr->request_length = cpu_to_le32(cmd_len - sizeof(*req_hdr));\r\nreq_hdr->version = 0;\r\nfill_wrb_tags(wrb, (ulong) req_hdr);\r\nwrb->payload_length = cmd_len;\r\nif (mem) {\r\nwrb->embedded |= (1 & MCC_WRB_SGE_CNT_MASK) <<\r\nMCC_WRB_SGE_CNT_SHIFT;\r\nsge = nonembedded_sgl(wrb);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(mem->dma));\r\nsge->pa_lo = cpu_to_le32(mem->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(mem->size);\r\n} else\r\nwrb->embedded |= MCC_WRB_EMBEDDED_MASK;\r\nbe_dws_cpu_to_le(wrb, 8);\r\n}\r\nstatic void be_cmd_page_addrs_prepare(struct phys_addr *pages, u32 max_pages,\r\nstruct be_dma_mem *mem)\r\n{\r\nint i, buf_pages = min(PAGES_4K_SPANNED(mem->va, mem->size), max_pages);\r\nu64 dma = (u64)mem->dma;\r\nfor (i = 0; i < buf_pages; i++) {\r\npages[i].lo = cpu_to_le32(dma & 0xFFFFFFFF);\r\npages[i].hi = cpu_to_le32(upper_32_bits(dma));\r\ndma += PAGE_SIZE_4K;\r\n}\r\n}\r\nstatic inline struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter)\r\n{\r\nstruct be_dma_mem *mbox_mem = &adapter->mbox_mem;\r\nstruct be_mcc_wrb *wrb\r\n= &((struct be_mcc_mailbox *)(mbox_mem->va))->wrb;\r\nmemset(wrb, 0, sizeof(*wrb));\r\nreturn wrb;\r\n}\r\nstatic struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mccq = &adapter->mcc_obj.q;\r\nstruct be_mcc_wrb *wrb;\r\nif (!mccq->created)\r\nreturn NULL;\r\nif (atomic_read(&mccq->used) >= mccq->len)\r\nreturn NULL;\r\nwrb = queue_head_node(mccq);\r\nqueue_head_inc(mccq);\r\natomic_inc(&mccq->used);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nreturn wrb;\r\n}\r\nstatic bool use_mcc(struct be_adapter *adapter)\r\n{\r\nreturn adapter->mcc_obj.q.created;\r\n}\r\nstatic int be_cmd_lock(struct be_adapter *adapter)\r\n{\r\nif (use_mcc(adapter)) {\r\nspin_lock_bh(&adapter->mcc_lock);\r\nreturn 0;\r\n} else {\r\nreturn mutex_lock_interruptible(&adapter->mbox_lock);\r\n}\r\n}\r\nstatic void be_cmd_unlock(struct be_adapter *adapter)\r\n{\r\nif (use_mcc(adapter))\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nelse\r\nreturn mutex_unlock(&adapter->mbox_lock);\r\n}\r\nstatic struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter,\r\nstruct be_mcc_wrb *wrb)\r\n{\r\nstruct be_mcc_wrb *dest_wrb;\r\nif (use_mcc(adapter)) {\r\ndest_wrb = wrb_from_mccq(adapter);\r\nif (!dest_wrb)\r\nreturn NULL;\r\n} else {\r\ndest_wrb = wrb_from_mbox(adapter);\r\n}\r\nmemcpy(dest_wrb, wrb, sizeof(*wrb));\r\nif (wrb->embedded & cpu_to_le32(MCC_WRB_EMBEDDED_MASK))\r\nfill_wrb_tags(dest_wrb, (ulong) embedded_payload(wrb));\r\nreturn dest_wrb;\r\n}\r\nstatic int be_cmd_notify_wait(struct be_adapter *adapter,\r\nstruct be_mcc_wrb *wrb)\r\n{\r\nstruct be_mcc_wrb *dest_wrb;\r\nint status;\r\nstatus = be_cmd_lock(adapter);\r\nif (status)\r\nreturn status;\r\ndest_wrb = be_cmd_copy(adapter, wrb);\r\nif (!dest_wrb)\r\nreturn -EBUSY;\r\nif (use_mcc(adapter))\r\nstatus = be_mcc_notify_wait(adapter);\r\nelse\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status)\r\nmemcpy(wrb, dest_wrb, sizeof(*wrb));\r\nbe_cmd_unlock(adapter);\r\nreturn status;\r\n}\r\nint be_cmd_fw_init(struct be_adapter *adapter)\r\n{\r\nu8 *wrb;\r\nint status;\r\nif (lancer_chip(adapter))\r\nreturn 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = (u8 *)wrb_from_mbox(adapter);\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0x12;\r\n*wrb++ = 0x34;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0x56;\r\n*wrb++ = 0x78;\r\n*wrb = 0xFF;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_fw_clean(struct be_adapter *adapter)\r\n{\r\nu8 *wrb;\r\nint status;\r\nif (lancer_chip(adapter))\r\nreturn 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = (u8 *)wrb_from_mbox(adapter);\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xAA;\r\n*wrb++ = 0xBB;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xCC;\r\n*wrb++ = 0xDD;\r\n*wrb = 0xFF;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_eq_create *req;\r\nstruct be_dma_mem *q_mem = &eqo->q.dma_mem;\r\nint status, ver = 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_EQ_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nif (!(BEx_chip(adapter) || lancer_chip(adapter)))\r\nver = 2;\r\nreq->hdr.version = ver;\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nAMAP_SET_BITS(struct amap_eq_context, valid, req->context, 1);\r\nAMAP_SET_BITS(struct amap_eq_context, size, req->context, 0);\r\nAMAP_SET_BITS(struct amap_eq_context, count, req->context,\r\n__ilog2_u32(eqo->q.len / 256));\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_eq_create *resp = embedded_payload(wrb);\r\neqo->q.id = le16_to_cpu(resp->eq_id);\r\neqo->msix_idx =\r\n(ver == 2) ? le16_to_cpu(resp->msix_idx) : eqo->idx;\r\neqo->q.created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,\r\nbool permanent, u32 if_handle, u32 pmac_id)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mac_query *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_MAC_QUERY, sizeof(*req), wrb,\r\nNULL);\r\nreq->type = MAC_ADDRESS_TYPE_NETWORK;\r\nif (permanent) {\r\nreq->permanent = 1;\r\n} else {\r\nreq->if_id = cpu_to_le16((u16)if_handle);\r\nreq->pmac_id = cpu_to_le32(pmac_id);\r\nreq->permanent = 0;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mac_query *resp = embedded_payload(wrb);\r\nmemcpy(mac_addr, resp->mac.addr, ETH_ALEN);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,\r\nu32 if_id, u32 *pmac_id, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_pmac_add *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_PMAC_ADD, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nreq->if_id = cpu_to_le32(if_id);\r\nmemcpy(req->mac_address, mac_addr, ETH_ALEN);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_pmac_add *resp = embedded_payload(wrb);\r\n*pmac_id = le32_to_cpu(resp->pmac_id);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nif (status == MCC_STATUS_UNAUTHORIZED_REQUEST)\r\nstatus = -EPERM;\r\nreturn status;\r\n}\r\nint be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id, u32 dom)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_pmac_del *req;\r\nint status;\r\nif (pmac_id == -1)\r\nreturn 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_PMAC_DEL, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = dom;\r\nreq->if_id = cpu_to_le32(if_id);\r\nreq->pmac_id = cpu_to_le32(pmac_id);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,\r\nstruct be_queue_info *eq, bool no_delay, int coalesce_wm)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_cq_create *req;\r\nstruct be_dma_mem *q_mem = &cq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_CQ_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nif (BEx_chip(adapter)) {\r\nAMAP_SET_BITS(struct amap_cq_context_be, coalescwm, ctxt,\r\ncoalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context_be, nodelay,\r\nctxt, no_delay);\r\nAMAP_SET_BITS(struct amap_cq_context_be, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_be, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_be, eqid, ctxt, eq->id);\r\n} else {\r\nreq->hdr.version = 2;\r\nreq->page_size = 1;\r\nif (!lancer_chip(adapter))\r\nAMAP_SET_BITS(struct amap_cq_context_v2, coalescwm,\r\nctxt, coalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, nodelay, ctxt,\r\nno_delay);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context_v2, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eqid, ctxt, eq->id);\r\n}\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_cq_create *resp = embedded_payload(wrb);\r\ncq->id = le16_to_cpu(resp->cq_id);\r\ncq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic u32 be_encoded_q_len(int q_len)\r\n{\r\nu32 len_encoded = fls(q_len);\r\nif (len_encoded == 16)\r\nlen_encoded = 0;\r\nreturn len_encoded;\r\n}\r\nstatic int be_cmd_mccq_ext_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq,\r\nstruct be_queue_info *cq)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mcc_ext_create *req;\r\nstruct be_dma_mem *q_mem = &mccq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MCC_CREATE_EXT, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nif (BEx_chip(adapter)) {\r\nAMAP_SET_BITS(struct amap_mcc_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_be, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, cq_id, ctxt, cq->id);\r\n} else {\r\nreq->hdr.version = 1;\r\nreq->cq_id = cpu_to_le16(cq->id);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, async_cq_id,\r\nctxt, cq->id);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, async_cq_valid,\r\nctxt, 1);\r\n}\r\nreq->async_event_bitmap[0] = cpu_to_le32(0x00000022);\r\nreq->async_event_bitmap[0] |= cpu_to_le32(1 << ASYNC_EVENT_CODE_QNQ);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\r\nmccq->id = le16_to_cpu(resp->id);\r\nmccq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic int be_cmd_mccq_org_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq,\r\nstruct be_queue_info *cq)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mcc_create *req;\r\nstruct be_dma_mem *q_mem = &mccq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MCC_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_be, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, cq_id, ctxt, cq->id);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\r\nmccq->id = le16_to_cpu(resp->id);\r\nmccq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_mccq_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq, struct be_queue_info *cq)\r\n{\r\nint status;\r\nstatus = be_cmd_mccq_ext_create(adapter, mccq, cq);\r\nif (status && BEx_chip(adapter)) {\r\ndev_warn(&adapter->pdev->dev, "Upgrade to F/W ver 2.102.235.0 "\r\n"or newer to avoid conflicting priorities between NIC "\r\n"and FCoE traffic");\r\nstatus = be_cmd_mccq_org_create(adapter, mccq, cq);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_eth_tx_create *req;\r\nstruct be_queue_info *txq = &txo->q;\r\nstruct be_queue_info *cq = &txo->cq;\r\nstruct be_dma_mem *q_mem = &txq->dma_mem;\r\nint status, ver = 0;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_TX_CREATE, sizeof(*req), &wrb, NULL);\r\nif (lancer_chip(adapter)) {\r\nreq->hdr.version = 1;\r\n} else if (BEx_chip(adapter)) {\r\nif (adapter->function_caps & BE_FUNCTION_CAPS_SUPER_NIC)\r\nreq->hdr.version = 2;\r\n} else {\r\nreq->hdr.version = 2;\r\n}\r\nif (req->hdr.version > 0)\r\nreq->if_id = cpu_to_le16(adapter->if_handle);\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nreq->ulp_num = BE_ULP1_NUM;\r\nreq->type = BE_ETH_TX_RING_TYPE_STANDARD;\r\nreq->cq_id = cpu_to_le16(cq->id);\r\nreq->queue_size = be_encoded_q_len(txq->len);\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nver = req->hdr.version;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (!status) {\r\nstruct be_cmd_resp_eth_tx_create *resp = embedded_payload(&wrb);\r\ntxq->id = le16_to_cpu(resp->cid);\r\nif (ver == 2)\r\ntxo->db_offset = le32_to_cpu(resp->db_offset);\r\nelse\r\ntxo->db_offset = DB_TXULP1_OFFSET;\r\ntxq->created = true;\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_rxq_create(struct be_adapter *adapter,\r\nstruct be_queue_info *rxq, u16 cq_id, u16 frag_size,\r\nu32 if_id, u32 rss, u8 *rss_id)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_eth_rx_create *req;\r\nstruct be_dma_mem *q_mem = &rxq->dma_mem;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RX_CREATE, sizeof(*req), wrb, NULL);\r\nreq->cq_id = cpu_to_le16(cq_id);\r\nreq->frag_size = fls(frag_size) - 1;\r\nreq->num_pages = 2;\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nreq->interface_id = cpu_to_le32(if_id);\r\nreq->max_frame_size = cpu_to_le16(BE_MAX_JUMBO_FRAME_SIZE);\r\nreq->rss_queue = cpu_to_le32(rss);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_eth_rx_create *resp = embedded_payload(wrb);\r\nrxq->id = le16_to_cpu(resp->id);\r\nrxq->created = true;\r\n*rss_id = resp->rss_id;\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,\r\nint queue_type)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_q_destroy *req;\r\nu8 subsys = 0, opcode = 0;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nswitch (queue_type) {\r\ncase QTYPE_EQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_EQ_DESTROY;\r\nbreak;\r\ncase QTYPE_CQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_CQ_DESTROY;\r\nbreak;\r\ncase QTYPE_TXQ:\r\nsubsys = CMD_SUBSYSTEM_ETH;\r\nopcode = OPCODE_ETH_TX_DESTROY;\r\nbreak;\r\ncase QTYPE_RXQ:\r\nsubsys = CMD_SUBSYSTEM_ETH;\r\nopcode = OPCODE_ETH_RX_DESTROY;\r\nbreak;\r\ncase QTYPE_MCCQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_MCC_DESTROY;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, subsys, opcode, sizeof(*req), wrb,\r\nNULL);\r\nreq->id = cpu_to_le16(q->id);\r\nstatus = be_mbox_notify_wait(adapter);\r\nq->created = false;\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_q_destroy *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RX_DESTROY, sizeof(*req), wrb, NULL);\r\nreq->id = cpu_to_le16(q->id);\r\nstatus = be_mcc_notify_wait(adapter);\r\nq->created = false;\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,\r\nu32 *if_handle, u32 domain)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_if_create *req;\r\nint status;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_INTERFACE_CREATE,\r\nsizeof(*req), &wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->capability_flags = cpu_to_le32(cap_flags);\r\nreq->enable_flags = cpu_to_le32(en_flags);\r\nreq->pmac_invalid = true;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (!status) {\r\nstruct be_cmd_resp_if_create *resp = embedded_payload(&wrb);\r\n*if_handle = le32_to_cpu(resp->interface_id);\r\nif (BE3_chip(adapter) && !be_physfn(adapter))\r\nadapter->pmac_id[0] = le32_to_cpu(resp->pmac_id);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_if_destroy(struct be_adapter *adapter, int interface_id, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_if_destroy *req;\r\nint status;\r\nif (interface_id == -1)\r\nreturn 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_INTERFACE_DESTROY,\r\nsizeof(*req), wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->interface_id = cpu_to_le32(interface_id);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *hdr;\r\nint status = 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nhdr = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_GET_STATISTICS, nonemb_cmd->size, wrb,\r\nnonemb_cmd);\r\nif (BE2_chip(adapter))\r\nhdr->version = 0;\r\nif (BE3_chip(adapter) || lancer_chip(adapter))\r\nhdr->version = 1;\r\nelse\r\nhdr->version = 2;\r\nbe_mcc_notify(adapter);\r\nadapter->stats_cmd_sent = true;\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint lancer_cmd_get_pport_stats(struct be_adapter *adapter,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_pport_stats *req;\r\nint status = 0;\r\nif (!be_cmd_allowed(adapter, OPCODE_ETH_GET_PPORT_STATS,\r\nCMD_SUBSYSTEM_ETH))\r\nreturn -EPERM;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_GET_PPORT_STATS, nonemb_cmd->size,\r\nwrb, nonemb_cmd);\r\nreq->cmd_params.params.pport_num = cpu_to_le16(adapter->hba_port_num);\r\nreq->cmd_params.params.reset_stats = 0;\r\nbe_mcc_notify(adapter);\r\nadapter->stats_cmd_sent = true;\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int be_mac_to_link_speed(int mac_speed)\r\n{\r\nswitch (mac_speed) {\r\ncase PHY_LINK_SPEED_ZERO:\r\nreturn 0;\r\ncase PHY_LINK_SPEED_10MBPS:\r\nreturn 10;\r\ncase PHY_LINK_SPEED_100MBPS:\r\nreturn 100;\r\ncase PHY_LINK_SPEED_1GBPS:\r\nreturn 1000;\r\ncase PHY_LINK_SPEED_10GBPS:\r\nreturn 10000;\r\ncase PHY_LINK_SPEED_20GBPS:\r\nreturn 20000;\r\ncase PHY_LINK_SPEED_25GBPS:\r\nreturn 25000;\r\ncase PHY_LINK_SPEED_40GBPS:\r\nreturn 40000;\r\n}\r\nreturn 0;\r\n}\r\nint be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,\r\nu8 *link_status, u32 dom)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_link_status *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nif (link_status)\r\n*link_status = LINK_DOWN;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_LINK_STATUS_QUERY,\r\nsizeof(*req), wrb, NULL);\r\nif (!BE2_chip(adapter))\r\nreq->hdr.version = 1;\r\nreq->hdr.domain = dom;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_link_status *resp = embedded_payload(wrb);\r\nif (link_speed) {\r\n*link_speed = resp->link_speed ?\r\nle16_to_cpu(resp->link_speed) * 10 :\r\nbe_mac_to_link_speed(resp->mac_speed);\r\nif (!resp->logical_link_status)\r\n*link_speed = 0;\r\n}\r\nif (link_status)\r\n*link_status = resp->logical_link_status;\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_die_temperature(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_cntl_addnl_attribs *req;\r\nint status = 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ADDITIONAL_ATTRIBUTES,\r\nsizeof(*req), wrb, NULL);\r\nbe_mcc_notify(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fat *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_FAT, sizeof(*req), wrb,\r\nNULL);\r\nreq->fat_operation = cpu_to_le32(QUERY_FAT);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fat *resp = embedded_payload(wrb);\r\nif (log_size && resp->log_size)\r\n*log_size = le32_to_cpu(resp->log_size) -\r\nsizeof(u32);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)\r\n{\r\nstruct be_dma_mem get_fat_cmd;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fat *req;\r\nu32 offset = 0, total_size, buf_size,\r\nlog_offset = sizeof(u32), payload_len;\r\nint status = 0;\r\nif (buf_len == 0)\r\nreturn -EIO;\r\ntotal_size = buf_len;\r\nget_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;\r\nget_fat_cmd.va = pci_alloc_consistent(adapter->pdev,\r\nget_fat_cmd.size,\r\n&get_fat_cmd.dma);\r\nif (!get_fat_cmd.va) {\r\ndev_err(&adapter->pdev->dev,\r\n"Memory allocation failure while reading FAT data\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwhile (total_size) {\r\nbuf_size = min(total_size, (u32)60*1024);\r\ntotal_size -= buf_size;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = get_fat_cmd.va;\r\npayload_len = sizeof(struct be_cmd_req_get_fat) + buf_size;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_FAT, payload_len,\r\nwrb, &get_fat_cmd);\r\nreq->fat_operation = cpu_to_le32(RETRIEVE_FAT);\r\nreq->read_log_offset = cpu_to_le32(log_offset);\r\nreq->read_log_length = cpu_to_le32(buf_size);\r\nreq->data_buffer_size = cpu_to_le32(buf_size);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fat *resp = get_fat_cmd.va;\r\nmemcpy(buf + offset,\r\nresp->data_buffer,\r\nle32_to_cpu(resp->read_log_length));\r\n} else {\r\ndev_err(&adapter->pdev->dev, "FAT Table Retrieve error\n");\r\ngoto err;\r\n}\r\noffset += buf_size;\r\nlog_offset += buf_size;\r\n}\r\nerr:\r\npci_free_consistent(adapter->pdev, get_fat_cmd.size,\r\nget_fat_cmd.va, get_fat_cmd.dma);\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_fw_ver(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fw_version *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FW_VERSION, sizeof(*req), wrb,\r\nNULL);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fw_version *resp = embedded_payload(wrb);\r\nstrlcpy(adapter->fw_ver, resp->firmware_version_string,\r\nsizeof(adapter->fw_ver));\r\nstrlcpy(adapter->fw_on_flash, resp->fw_on_flash_version_string,\r\nsizeof(adapter->fw_on_flash));\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int __be_cmd_modify_eqd(struct be_adapter *adapter,\r\nstruct be_set_eqd *set_eqd, int num)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_modify_eq_delay *req;\r\nint status = 0, i;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_eq = cpu_to_le32(num);\r\nfor (i = 0; i < num; i++) {\r\nreq->set_eqd[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);\r\nreq->set_eqd[i].phase = 0;\r\nreq->set_eqd[i].delay_multiplier =\r\ncpu_to_le32(set_eqd[i].delay_multiplier);\r\n}\r\nbe_mcc_notify(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *set_eqd,\r\nint num)\r\n{\r\nint num_eqs, i = 0;\r\nif (lancer_chip(adapter) && num > 8) {\r\nwhile (num) {\r\nnum_eqs = min(num, 8);\r\n__be_cmd_modify_eqd(adapter, &set_eqd[i], num_eqs);\r\ni += num_eqs;\r\nnum -= num_eqs;\r\n}\r\n} else {\r\n__be_cmd_modify_eqd(adapter, set_eqd, num);\r\n}\r\nreturn 0;\r\n}\r\nint be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,\r\nu32 num)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_vlan_config *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_VLAN_CONFIG, sizeof(*req),\r\nwrb, NULL);\r\nreq->interface_id = if_id;\r\nreq->untagged = BE_IF_FLAGS_UNTAGGED & be_if_cap_flags(adapter) ? 1 : 0;\r\nreq->num_vlan = num;\r\nmemcpy(req->normal_vlan, vtag_array,\r\nreq->num_vlan * sizeof(vtag_array[0]));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 value)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_dma_mem *mem = &adapter->rx_filter;\r\nstruct be_cmd_req_rx_filter *req = mem->va;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nmemset(req, 0, sizeof(*req));\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_RX_FILTER, sizeof(*req),\r\nwrb, mem);\r\nreq->if_id = cpu_to_le32(adapter->if_handle);\r\nif (flags & IFF_PROMISC) {\r\nreq->if_flags_mask = cpu_to_le32(BE_IF_FLAGS_PROMISCUOUS |\r\nBE_IF_FLAGS_VLAN_PROMISCUOUS |\r\nBE_IF_FLAGS_MCAST_PROMISCUOUS);\r\nif (value == ON)\r\nreq->if_flags =\r\ncpu_to_le32(BE_IF_FLAGS_PROMISCUOUS |\r\nBE_IF_FLAGS_VLAN_PROMISCUOUS |\r\nBE_IF_FLAGS_MCAST_PROMISCUOUS);\r\n} else if (flags & IFF_ALLMULTI) {\r\nreq->if_flags_mask = cpu_to_le32(BE_IF_FLAGS_MCAST_PROMISCUOUS);\r\nreq->if_flags = cpu_to_le32(BE_IF_FLAGS_MCAST_PROMISCUOUS);\r\n} else if (flags & BE_FLAGS_VLAN_PROMISC) {\r\nreq->if_flags_mask = cpu_to_le32(BE_IF_FLAGS_VLAN_PROMISCUOUS);\r\nif (value == ON)\r\nreq->if_flags =\r\ncpu_to_le32(BE_IF_FLAGS_VLAN_PROMISCUOUS);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nint i = 0;\r\nreq->if_flags_mask = cpu_to_le32(BE_IF_FLAGS_MULTICAST);\r\nreq->if_flags = cpu_to_le32(BE_IF_FLAGS_MULTICAST);\r\nreq->if_flags_mask |=\r\ncpu_to_le32(BE_IF_FLAGS_MCAST_PROMISCUOUS &\r\nbe_if_cap_flags(adapter));\r\nreq->mcast_num = cpu_to_le32(netdev_mc_count(adapter->netdev));\r\nnetdev_for_each_mc_addr(ha, adapter->netdev)\r\nmemcpy(req->mcast_mac[i++].byte, ha->addr, ETH_ALEN);\r\n}\r\nif ((req->if_flags_mask & cpu_to_le32(be_if_cap_flags(adapter))) !=\r\nreq->if_flags_mask) {\r\ndev_warn(&adapter->pdev->dev,\r\n"Cannot set rx filter flags 0x%x\n",\r\nreq->if_flags_mask);\r\ndev_warn(&adapter->pdev->dev,\r\n"Interface is capable of 0x%x flags only\n",\r\nbe_if_cap_flags(adapter));\r\n}\r\nreq->if_flags_mask &= cpu_to_le32(be_if_cap_flags(adapter));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_flow_control *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_SET_FLOW_CONTROL,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FLOW_CONTROL, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.version = 1;\r\nreq->tx_flow_control = cpu_to_le16((u16)tx_fc);\r\nreq->rx_flow_control = cpu_to_le16((u16)rx_fc);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nif (base_status(status) == MCC_STATUS_FEATURE_NOT_SUPPORTED)\r\nreturn -EOPNOTSUPP;\r\nreturn status;\r\n}\r\nint be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_flow_control *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_GET_FLOW_CONTROL,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FLOW_CONTROL, sizeof(*req),\r\nwrb, NULL);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_flow_control *resp =\r\nembedded_payload(wrb);\r\n*tx_fc = le16_to_cpu(resp->tx_flow_control);\r\n*rx_fc = le16_to_cpu(resp->rx_flow_control);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_fw_cfg(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_query_fw_cfg *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG,\r\nsizeof(*req), wrb, NULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_query_fw_cfg *resp = embedded_payload(wrb);\r\nadapter->port_num = le32_to_cpu(resp->phys_port);\r\nadapter->function_mode = le32_to_cpu(resp->function_mode);\r\nadapter->function_caps = le32_to_cpu(resp->function_caps);\r\nadapter->asic_rev = le32_to_cpu(resp->asic_revision) & 0xFF;\r\ndev_info(&adapter->pdev->dev,\r\n"FW config: function_mode=0x%x, function_caps=0x%x\n",\r\nadapter->function_mode, adapter->function_caps);\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_reset_function(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *req;\r\nint status;\r\nif (lancer_chip(adapter)) {\r\nstatus = lancer_wait_ready(adapter);\r\nif (!status) {\r\niowrite32(SLI_PORT_CONTROL_IP_MASK,\r\nadapter->db + SLIPORT_CONTROL_OFFSET);\r\nstatus = lancer_test_and_set_rdy_state(adapter);\r\n}\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"Adapter in non recoverable error\n");\r\n}\r\nreturn status;\r\n}\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(req, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_FUNCTION_RESET, sizeof(*req), wrb,\r\nNULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,\r\nu32 rss_hash_opts, u16 table_size, const u8 *rss_hkey)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_rss_config *req;\r\nint status;\r\nif (!(be_if_cap_flags(adapter) & BE_IF_FLAGS_RSS))\r\nreturn 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RSS_CONFIG, sizeof(*req), wrb, NULL);\r\nreq->if_id = cpu_to_le32(adapter->if_handle);\r\nreq->enable_rss = cpu_to_le16(rss_hash_opts);\r\nreq->cpu_table_size_log2 = cpu_to_le16(fls(table_size) - 1);\r\nif (!BEx_chip(adapter))\r\nreq->hdr.version = 1;\r\nmemcpy(req->cpu_table, rsstable, table_size);\r\nmemcpy(req->hash, rss_hkey, RSS_HASH_KEY_LEN);\r\nbe_dws_cpu_to_le(req->hash, sizeof(req->hash));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num,\r\nu8 bcn, u8 sts, u8 state)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_enable_disable_beacon *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_ENABLE_DISABLE_BEACON,\r\nsizeof(*req), wrb, NULL);\r\nreq->port_num = port_num;\r\nreq->beacon_state = state;\r\nreq->beacon_duration = bcn;\r\nreq->status_duration = sts;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num, u32 *state)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_beacon_state *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_BEACON_STATE, sizeof(*req),\r\nwrb, NULL);\r\nreq->port_num = port_num;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_beacon_state *resp =\r\nembedded_payload(wrb);\r\n*state = resp->beacon_state;\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_read_port_transceiver_data(struct be_adapter *adapter,\r\nu8 page_num, u8 *data)\r\n{\r\nstruct be_dma_mem cmd;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_port_type *req;\r\nint status;\r\nif (page_num > TR_PAGE_A2)\r\nreturn -EINVAL;\r\ncmd.size = sizeof(struct be_cmd_resp_port_type);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd.va, 0, cmd.size);\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_TRANSRECV_DATA,\r\ncmd.size, wrb, &cmd);\r\nreq->port = cpu_to_le32(adapter->hba_port_num);\r\nreq->page_num = cpu_to_le32(page_num);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_port_type *resp = cmd.va;\r\nmemcpy(data, resp->page_data, PAGE_DATA_LEN);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nint lancer_cmd_write_object(struct be_adapter *adapter, struct be_dma_mem *cmd,\r\nu32 data_size, u32 data_offset,\r\nconst char *obj_name, u32 *data_written,\r\nu8 *change_status, u8 *addn_status)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_write_object *req;\r\nstruct lancer_cmd_resp_write_object *resp;\r\nvoid *ctxt = NULL;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nadapter->flash_status = 0;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_WRITE_OBJECT,\r\nsizeof(struct lancer_cmd_req_write_object), wrb,\r\nNULL);\r\nctxt = &req->context;\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\nwrite_length, ctxt, data_size);\r\nif (data_size == 0)\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\neof, ctxt, 1);\r\nelse\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\neof, ctxt, 0);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nreq->write_offset = cpu_to_le32(data_offset);\r\nstrlcpy(req->object_name, obj_name, sizeof(req->object_name));\r\nreq->descriptor_count = cpu_to_le32(1);\r\nreq->buf_len = cpu_to_le32(data_size);\r\nreq->addr_low = cpu_to_le32((cmd->dma +\r\nsizeof(struct lancer_cmd_req_write_object))\r\n& 0xFFFFFFFF);\r\nreq->addr_high = cpu_to_le32(upper_32_bits(cmd->dma +\r\nsizeof(struct lancer_cmd_req_write_object)));\r\nbe_mcc_notify(adapter);\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nif (!wait_for_completion_timeout(&adapter->et_cmd_compl,\r\nmsecs_to_jiffies(60000)))\r\nstatus = -ETIMEDOUT;\r\nelse\r\nstatus = adapter->flash_status;\r\nresp = embedded_payload(wrb);\r\nif (!status) {\r\n*data_written = le32_to_cpu(resp->actual_write_len);\r\n*change_status = resp->change_status;\r\n} else {\r\n*addn_status = resp->additional_status;\r\n}\r\nreturn status;\r\nerr_unlock:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_cable_type(struct be_adapter *adapter)\r\n{\r\nu8 page_data[PAGE_DATA_LEN];\r\nint status;\r\nstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\r\npage_data);\r\nif (!status) {\r\nswitch (adapter->phy.interface_type) {\r\ncase PHY_TYPE_QSFP:\r\nadapter->phy.cable_type =\r\npage_data[QSFP_PLUS_CABLE_TYPE_OFFSET];\r\nbreak;\r\ncase PHY_TYPE_SFP_PLUS_10GB:\r\nadapter->phy.cable_type =\r\npage_data[SFP_PLUS_CABLE_TYPE_OFFSET];\r\nbreak;\r\ndefault:\r\nadapter->phy.cable_type = 0;\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint lancer_cmd_delete_object(struct be_adapter *adapter, const char *obj_name)\r\n{\r\nstruct lancer_cmd_req_delete_object *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_DELETE_OBJECT,\r\nsizeof(*req), wrb, NULL);\r\nstrlcpy(req->object_name, obj_name, sizeof(req->object_name));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,\r\nu32 data_size, u32 data_offset, const char *obj_name,\r\nu32 *data_read, u32 *eof, u8 *addn_status)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_read_object *req;\r\nstruct lancer_cmd_resp_read_object *resp;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_OBJECT,\r\nsizeof(struct lancer_cmd_req_read_object), wrb,\r\nNULL);\r\nreq->desired_read_len = cpu_to_le32(data_size);\r\nreq->read_offset = cpu_to_le32(data_offset);\r\nstrcpy(req->object_name, obj_name);\r\nreq->descriptor_count = cpu_to_le32(1);\r\nreq->buf_len = cpu_to_le32(data_size);\r\nreq->addr_low = cpu_to_le32((cmd->dma & 0xFFFFFFFF));\r\nreq->addr_high = cpu_to_le32(upper_32_bits(cmd->dma));\r\nstatus = be_mcc_notify_wait(adapter);\r\nresp = embedded_payload(wrb);\r\nif (!status) {\r\n*data_read = le32_to_cpu(resp->actual_read_len);\r\n*eof = le32_to_cpu(resp->eof);\r\n} else {\r\n*addn_status = resp->additional_status;\r\n}\r\nerr_unlock:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_write_flashrom(struct be_adapter *adapter, struct be_dma_mem *cmd,\r\nu32 flash_type, u32 flash_opcode, u32 buf_size)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_write_flashrom *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nadapter->flash_status = 0;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_WRITE_FLASHROM, cmd->size, wrb,\r\ncmd);\r\nreq->params.op_type = cpu_to_le32(flash_type);\r\nreq->params.op_code = cpu_to_le32(flash_opcode);\r\nreq->params.data_buf_size = cpu_to_le32(buf_size);\r\nbe_mcc_notify(adapter);\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nif (!wait_for_completion_timeout(&adapter->et_cmd_compl,\r\nmsecs_to_jiffies(40000)))\r\nstatus = -ETIMEDOUT;\r\nelse\r\nstatus = adapter->flash_status;\r\nreturn status;\r\nerr_unlock:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,\r\nu16 optype, int offset)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_read_flash_crc *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_FLASHROM, sizeof(*req),\r\nwrb, NULL);\r\nreq->params.op_type = cpu_to_le32(optype);\r\nreq->params.op_code = cpu_to_le32(FLASHROM_OPER_REPORT);\r\nreq->params.offset = cpu_to_le32(offset);\r\nreq->params.data_buf_size = cpu_to_le32(0x4);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status)\r\nmemcpy(flashed_crc, req->crc, 4);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_acpi_wol_magic_config *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_ACPI_WOL_MAGIC_CONFIG, sizeof(*req),\r\nwrb, nonemb_cmd);\r\nmemcpy(req->magic_mac, mac, ETH_ALEN);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,\r\nu8 loopback_type, u8 enable)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_lmode *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_SET_LOOPBACK_MODE, sizeof(*req),\r\nwrb, NULL);\r\nreq->src_port = port_num;\r\nreq->dest_port = port_num;\r\nreq->loopback_type = loopback_type;\r\nreq->loopback_state = enable;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,\r\nu32 loopback_type, u32 pkt_size, u32 num_pkts,\r\nu64 pattern)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_loopback_test *req;\r\nstruct be_cmd_resp_loopback_test *resp;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_LOOPBACK_TEST, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.timeout = cpu_to_le32(15);\r\nreq->pattern = cpu_to_le64(pattern);\r\nreq->src_port = cpu_to_le32(port_num);\r\nreq->dest_port = cpu_to_le32(port_num);\r\nreq->pkt_size = cpu_to_le32(pkt_size);\r\nreq->num_pkts = cpu_to_le32(num_pkts);\r\nreq->loopback_type = cpu_to_le32(loopback_type);\r\nbe_mcc_notify(adapter);\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nwait_for_completion(&adapter->et_cmd_compl);\r\nresp = embedded_payload(wrb);\r\nstatus = le32_to_cpu(resp->status);\r\nreturn status;\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,\r\nu32 byte_cnt, struct be_dma_mem *cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_ddrdma_test *req;\r\nint status;\r\nint i, j = 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_HOST_DDR_DMA, cmd->size, wrb,\r\ncmd);\r\nreq->pattern = cpu_to_le64(pattern);\r\nreq->byte_count = cpu_to_le32(byte_cnt);\r\nfor (i = 0; i < byte_cnt; i++) {\r\nreq->snd_buff[i] = (u8)(pattern >> (j*8));\r\nj++;\r\nif (j > 7)\r\nj = 0;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_ddrdma_test *resp;\r\nresp = cmd->va;\r\nif ((memcmp(resp->rcv_buff, req->snd_buff, byte_cnt) != 0) ||\r\nresp->snd_err) {\r\nstatus = -1;\r\n}\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_seeprom_data(struct be_adapter *adapter,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_seeprom_read *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SEEPROM_READ, sizeof(*req), wrb,\r\nnonemb_cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_phy_info(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_phy_info *req;\r\nstruct be_dma_mem cmd;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_GET_PHY_DETAILS,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\ncmd.size = sizeof(struct be_cmd_req_get_phy_info);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory alloc failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PHY_DETAILS, sizeof(*req),\r\nwrb, &cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_phy_info *resp_phy_info =\r\ncmd.va + sizeof(struct be_cmd_req_hdr);\r\nadapter->phy.phy_type = le16_to_cpu(resp_phy_info->phy_type);\r\nadapter->phy.interface_type =\r\nle16_to_cpu(resp_phy_info->interface_type);\r\nadapter->phy.auto_speeds_supported =\r\nle16_to_cpu(resp_phy_info->auto_speeds_supported);\r\nadapter->phy.fixed_speeds_supported =\r\nle16_to_cpu(resp_phy_info->fixed_speeds_supported);\r\nadapter->phy.misc_params =\r\nle32_to_cpu(resp_phy_info->misc_params);\r\nif (BE2_chip(adapter)) {\r\nadapter->phy.fixed_speeds_supported =\r\nBE_SUPPORTED_SPEED_10GBPS |\r\nBE_SUPPORTED_SPEED_1GBPS;\r\n}\r\n}\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_qos *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_QOS, sizeof(*req), wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->valid_bits = cpu_to_le32(BE_QOS_BITS_NIC);\r\nreq->max_bps_nic = cpu_to_le32(bps);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_cntl_attributes(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_cntl_attribs *req;\r\nstruct be_cmd_resp_cntl_attribs *resp;\r\nint status;\r\nint payload_len = max(sizeof(*req), sizeof(*resp));\r\nstruct mgmt_controller_attrib *attribs;\r\nstruct be_dma_mem attribs_cmd;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&attribs_cmd, 0, sizeof(struct be_dma_mem));\r\nattribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);\r\nattribs_cmd.va = pci_alloc_consistent(adapter->pdev, attribs_cmd.size,\r\n&attribs_cmd.dma);\r\nif (!attribs_cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = attribs_cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, payload_len,\r\nwrb, &attribs_cmd);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nattribs = attribs_cmd.va + sizeof(struct be_cmd_resp_hdr);\r\nadapter->hba_port_num = attribs->hba_attribs.phy_port;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (attribs_cmd.va)\r\npci_free_consistent(adapter->pdev, attribs_cmd.size,\r\nattribs_cmd.va, attribs_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_req_native_mode(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_func_cap *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_DRIVER_FUNCTION_CAP,\r\nsizeof(*req), wrb, NULL);\r\nreq->valid_cap_flags = cpu_to_le32(CAPABILITY_SW_TIMESTAMPS |\r\nCAPABILITY_BE3_NATIVE_ERX_API);\r\nreq->cap_flags = cpu_to_le32(CAPABILITY_BE3_NATIVE_ERX_API);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_set_func_cap *resp = embedded_payload(wrb);\r\nadapter->be3_native = le32_to_cpu(resp->cap_flags) &\r\nCAPABILITY_BE3_NATIVE_ERX_API;\r\nif (!adapter->be3_native)\r\ndev_warn(&adapter->pdev->dev,\r\n"adapter not in advanced mode\n");\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,\r\nu32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fn_privileges *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FN_PRIVILEGES, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fn_privileges *resp =\r\nembedded_payload(wrb);\r\n*privilege = le32_to_cpu(resp->privilege_mask);\r\nif (BEx_chip(adapter) && be_is_mc(adapter) &&\r\nbe_physfn(adapter))\r\n*privilege = MAX_PRIVILEGES;\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,\r\nu32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_fn_privileges *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FN_PRIVILEGES, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nif (lancer_chip(adapter))\r\nreq->privileges_lancer = cpu_to_le32(privileges);\r\nelse\r\nreq->privileges = cpu_to_le32(privileges);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,\r\nbool *pmac_id_valid, u32 *pmac_id, u32 if_handle,\r\nu8 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_mac_list *req;\r\nint status;\r\nint mac_count;\r\nstruct be_dma_mem get_mac_list_cmd;\r\nint i;\r\nmemset(&get_mac_list_cmd, 0, sizeof(struct be_dma_mem));\r\nget_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);\r\nget_mac_list_cmd.va = pci_alloc_consistent(adapter->pdev,\r\nget_mac_list_cmd.size,\r\n&get_mac_list_cmd.dma);\r\nif (!get_mac_list_cmd.va) {\r\ndev_err(&adapter->pdev->dev,\r\n"Memory allocation failure during GET_MAC_LIST\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto out;\r\n}\r\nreq = get_mac_list_cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_MAC_LIST,\r\nget_mac_list_cmd.size, wrb, &get_mac_list_cmd);\r\nreq->hdr.domain = domain;\r\nreq->mac_type = MAC_ADDRESS_TYPE_NETWORK;\r\nif (*pmac_id_valid) {\r\nreq->mac_id = cpu_to_le32(*pmac_id);\r\nreq->iface_id = cpu_to_le16(if_handle);\r\nreq->perm_override = 0;\r\n} else {\r\nreq->perm_override = 1;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_mac_list *resp =\r\nget_mac_list_cmd.va;\r\nif (*pmac_id_valid) {\r\nmemcpy(mac, resp->macid_macaddr.mac_addr_id.macaddr,\r\nETH_ALEN);\r\ngoto out;\r\n}\r\nmac_count = resp->true_mac_count + resp->pseudo_mac_count;\r\nfor (i = 0; i < mac_count; i++) {\r\nstruct get_list_macaddr *mac_entry;\r\nu16 mac_addr_size;\r\nu32 mac_id;\r\nmac_entry = &resp->macaddr_list[i];\r\nmac_addr_size = le16_to_cpu(mac_entry->mac_addr_size);\r\nif (mac_addr_size == sizeof(u32)) {\r\n*pmac_id_valid = true;\r\nmac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;\r\n*pmac_id = le32_to_cpu(mac_id);\r\ngoto out;\r\n}\r\n}\r\n*pmac_id_valid = false;\r\nmemcpy(mac, resp->macaddr_list[0].mac_addr_id.macaddr,\r\nETH_ALEN);\r\n}\r\nout:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\npci_free_consistent(adapter->pdev, get_mac_list_cmd.size,\r\nget_mac_list_cmd.va, get_mac_list_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_get_active_mac(struct be_adapter *adapter, u32 curr_pmac_id,\r\nu8 *mac, u32 if_handle, bool active, u32 domain)\r\n{\r\nif (!active)\r\nbe_cmd_get_mac_from_list(adapter, mac, &active, &curr_pmac_id,\r\nif_handle, domain);\r\nif (BEx_chip(adapter))\r\nreturn be_cmd_mac_addr_query(adapter, mac, false,\r\nif_handle, curr_pmac_id);\r\nelse\r\nreturn be_cmd_get_mac_from_list(adapter, mac, &active,\r\n&curr_pmac_id,\r\nif_handle, domain);\r\n}\r\nint be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac)\r\n{\r\nint status;\r\nbool pmac_valid = false;\r\nmemset(mac, 0, ETH_ALEN);\r\nif (BEx_chip(adapter)) {\r\nif (be_physfn(adapter))\r\nstatus = be_cmd_mac_addr_query(adapter, mac, true, 0,\r\n0);\r\nelse\r\nstatus = be_cmd_mac_addr_query(adapter, mac, false,\r\nadapter->if_handle, 0);\r\n} else {\r\nstatus = be_cmd_get_mac_from_list(adapter, mac, &pmac_valid,\r\nNULL, adapter->if_handle, 0);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,\r\nu8 mac_count, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_mac_list *req;\r\nint status;\r\nstruct be_dma_mem cmd;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_req_set_mac_list);\r\ncmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size,\r\n&cmd.dma, GFP_KERNEL);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_MAC_LIST, sizeof(*req),\r\nwrb, &cmd);\r\nreq->hdr.domain = domain;\r\nreq->mac_count = mac_count;\r\nif (mac_count)\r\nmemcpy(req->mac, mac_array, ETH_ALEN*mac_count);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom)\r\n{\r\nbool active_mac = false;\r\nu8 old_mac[ETH_ALEN];\r\nu32 pmac_id;\r\nint status;\r\nstatus = be_cmd_get_mac_from_list(adapter, old_mac, &active_mac,\r\n&pmac_id, if_id, dom);\r\nif (!status && active_mac)\r\nbe_cmd_pmac_del(adapter, if_id, pmac_id, dom);\r\nreturn be_cmd_set_mac_list(adapter, mac, mac ? 1 : 0, dom);\r\n}\r\nint be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,\r\nu32 domain, u16 intf_id, u16 hsw_mode)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_hsw_config *req;\r\nvoid *ctxt;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_HSW_CONFIG, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nAMAP_SET_BITS(struct amap_set_hsw_context, interface_id, ctxt, intf_id);\r\nif (pvid) {\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pvid_valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pvid, ctxt, pvid);\r\n}\r\nif (!BEx_chip(adapter) && hsw_mode) {\r\nAMAP_SET_BITS(struct amap_set_hsw_context, interface_id,\r\nctxt, adapter->hba_port_num);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pport, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, port_fwd_type,\r\nctxt, hsw_mode);\r\n}\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,\r\nu32 domain, u16 intf_id, u8 *mode)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_hsw_config *req;\r\nvoid *ctxt;\r\nint status;\r\nu16 vid;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_HSW_CONFIG, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, interface_id,\r\nctxt, intf_id);\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, pvid_valid, ctxt, 1);\r\nif (!BEx_chip(adapter) && mode) {\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, interface_id,\r\nctxt, adapter->hba_port_num);\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, pport, ctxt, 1);\r\n}\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_hsw_config *resp =\r\nembedded_payload(wrb);\r\nbe_dws_le_to_cpu(&resp->context, sizeof(resp->context));\r\nvid = AMAP_GET_BITS(struct amap_get_hsw_resp_context,\r\npvid, &resp->context);\r\nif (pvid)\r\n*pvid = le16_to_cpu(vid);\r\nif (mode)\r\n*mode = AMAP_GET_BITS(struct amap_get_hsw_resp_context,\r\nport_fwd_type, &resp->context);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_acpi_wol_magic_config_v1 *req;\r\nint status = 0;\r\nstruct be_dma_mem cmd;\r\nif (!be_cmd_allowed(adapter, OPCODE_ETH_ACPI_WOL_MAGIC_CONFIG,\r\nCMD_SUBSYSTEM_ETH))\r\nreturn -EPERM;\r\nif (be_is_wol_excluded(adapter))\r\nreturn status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_ACPI_WOL_MAGIC_CONFIG,\r\nsizeof(*req), wrb, &cmd);\r\nreq->hdr.version = 1;\r\nreq->query_options = BE_GET_WOL_CAP;\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_acpi_wol_magic_config_v1 *resp;\r\nresp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;\r\nadapter->wol_cap = resp->wol_settings;\r\nif (adapter->wol_cap & BE_WOL_CAP)\r\nadapter->wol_en = true;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (cmd.va)\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)\r\n{\r\nstruct be_dma_mem extfat_cmd;\r\nstruct be_fat_conf_params *cfgs;\r\nint status;\r\nint i, j;\r\nmemset(&extfat_cmd, 0, sizeof(struct be_dma_mem));\r\nextfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);\r\nextfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,\r\n&extfat_cmd.dma);\r\nif (!extfat_cmd.va)\r\nreturn -ENOMEM;\r\nstatus = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);\r\nif (status)\r\ngoto err;\r\ncfgs = (struct be_fat_conf_params *)\r\n(extfat_cmd.va + sizeof(struct be_cmd_resp_hdr));\r\nfor (i = 0; i < le32_to_cpu(cfgs->num_modules); i++) {\r\nu32 num_modes = le32_to_cpu(cfgs->module[i].num_modes);\r\nfor (j = 0; j < num_modes; j++) {\r\nif (cfgs->module[i].trace_lvl[j].mode == MODE_UART)\r\ncfgs->module[i].trace_lvl[j].dbg_lvl =\r\ncpu_to_le32(level);\r\n}\r\n}\r\nstatus = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd, cfgs);\r\nerr:\r\npci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,\r\nextfat_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_get_fw_log_level(struct be_adapter *adapter)\r\n{\r\nstruct be_dma_mem extfat_cmd;\r\nstruct be_fat_conf_params *cfgs;\r\nint status, j;\r\nint level = 0;\r\nmemset(&extfat_cmd, 0, sizeof(struct be_dma_mem));\r\nextfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);\r\nextfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,\r\n&extfat_cmd.dma);\r\nif (!extfat_cmd.va) {\r\ndev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",\r\n__func__);\r\ngoto err;\r\n}\r\nstatus = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);\r\nif (!status) {\r\ncfgs = (struct be_fat_conf_params *)(extfat_cmd.va +\r\nsizeof(struct be_cmd_resp_hdr));\r\nfor (j = 0; j < le32_to_cpu(cfgs->module[0].num_modes); j++) {\r\nif (cfgs->module[0].trace_lvl[j].mode == MODE_UART)\r\nlevel = cfgs->module[0].trace_lvl[j].dbg_lvl;\r\n}\r\n}\r\npci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,\r\nextfat_cmd.dma);\r\nerr:\r\nreturn level;\r\n}\r\nint be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_ext_fat_caps *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_EXT_FAT_CAPABILITES,\r\ncmd->size, wrb, cmd);\r\nreq->parameter_type = cpu_to_le32(1);\r\nstatus = be_mbox_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd,\r\nstruct be_fat_conf_params *configs)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_ext_fat_caps *req;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nmemcpy(&req->set_params, configs, sizeof(struct be_fat_conf_params));\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_EXT_FAT_CAPABILITES,\r\ncmd->size, wrb, cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_port_name *req;\r\nint status;\r\nif (!lancer_chip(adapter)) {\r\n*port_name = adapter->hba_port_num + '0';\r\nreturn 0;\r\n}\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PORT_NAME, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.version = 1;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_port_name *resp = embedded_payload(wrb);\r\n*port_name = resp->port_name[adapter->hba_port_num];\r\n} else {\r\n*port_name = adapter->hba_port_num + '0';\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic struct be_nic_res_desc *be_get_nic_desc(u8 *buf, u32 desc_count,\r\nint desc_type)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nstruct be_nic_res_desc *nic;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == NIC_RESOURCE_DESC_TYPE_V0 ||\r\nhdr->desc_type == NIC_RESOURCE_DESC_TYPE_V1) {\r\nnic = (struct be_nic_res_desc *)hdr;\r\nif (desc_type == FUNC_DESC ||\r\n(desc_type == VFT_DESC &&\r\nnic->flags & (1 << VFT_SHIFT)))\r\nreturn nic;\r\n}\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct be_nic_res_desc *be_get_vft_desc(u8 *buf, u32 desc_count)\r\n{\r\nreturn be_get_nic_desc(buf, desc_count, VFT_DESC);\r\n}\r\nstatic struct be_nic_res_desc *be_get_func_nic_desc(u8 *buf, u32 desc_count)\r\n{\r\nreturn be_get_nic_desc(buf, desc_count, FUNC_DESC);\r\n}\r\nstatic struct be_pcie_res_desc *be_get_pcie_desc(u8 devfn, u8 *buf,\r\nu32 desc_count)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nstruct be_pcie_res_desc *pcie;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif ((hdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V0 ||\r\nhdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V1)) {\r\npcie = (struct be_pcie_res_desc *)hdr;\r\nif (pcie->pf_num == devfn)\r\nreturn pcie;\r\n}\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct be_port_res_desc *be_get_port_desc(u8 *buf, u32 desc_count)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == PORT_RESOURCE_DESC_TYPE_V1)\r\nreturn (struct be_port_res_desc *)hdr;\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void be_copy_nic_desc(struct be_resources *res,\r\nstruct be_nic_res_desc *desc)\r\n{\r\nres->max_uc_mac = le16_to_cpu(desc->unicast_mac_count);\r\nres->max_vlans = le16_to_cpu(desc->vlan_count);\r\nres->max_mcast_mac = le16_to_cpu(desc->mcast_mac_count);\r\nres->max_tx_qs = le16_to_cpu(desc->txq_count);\r\nres->max_rss_qs = le16_to_cpu(desc->rssq_count);\r\nres->max_rx_qs = le16_to_cpu(desc->rq_count);\r\nres->max_evt_qs = le16_to_cpu(desc->eq_count);\r\nres->if_cap_flags = le32_to_cpu(desc->cap_flags) &\r\nBE_IF_CAP_FLAGS_WANT;\r\nif (res->max_rss_qs && res->max_rss_qs == res->max_rx_qs)\r\nres->max_rss_qs -= 1;\r\n}\r\nint be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_func_config *req;\r\nint status;\r\nstruct be_dma_mem cmd;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_get_func_config);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory alloc failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FUNC_CONFIG,\r\ncmd.size, wrb, &cmd);\r\nif (skyhawk_chip(adapter))\r\nreq->hdr.version = 1;\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_func_config *resp = cmd.va;\r\nu32 desc_count = le32_to_cpu(resp->desc_count);\r\nstruct be_nic_res_desc *desc;\r\ndesc = be_get_func_nic_desc(resp->func_param, desc_count);\r\nif (!desc) {\r\nstatus = -EINVAL;\r\ngoto err;\r\n}\r\nadapter->pf_number = desc->pf_num;\r\nbe_copy_nic_desc(res, desc);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (cmd.va)\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_get_profile_config(struct be_adapter *adapter,\r\nstruct be_resources *res, u8 domain)\r\n{\r\nstruct be_cmd_resp_get_profile_config *resp;\r\nstruct be_cmd_req_get_profile_config *req;\r\nstruct be_nic_res_desc *vf_res;\r\nstruct be_pcie_res_desc *pcie;\r\nstruct be_port_res_desc *port;\r\nstruct be_nic_res_desc *nic;\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_dma_mem cmd;\r\nu32 desc_count;\r\nint status;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_get_profile_config);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PROFILE_CONFIG,\r\ncmd.size, &wrb, &cmd);\r\nreq->hdr.domain = domain;\r\nif (!lancer_chip(adapter))\r\nreq->hdr.version = 1;\r\nreq->type = ACTIVE_PROFILE_TYPE;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (status)\r\ngoto err;\r\nresp = cmd.va;\r\ndesc_count = le32_to_cpu(resp->desc_count);\r\npcie = be_get_pcie_desc(adapter->pdev->devfn, resp->func_param,\r\ndesc_count);\r\nif (pcie)\r\nres->max_vfs = le16_to_cpu(pcie->num_vfs);\r\nport = be_get_port_desc(resp->func_param, desc_count);\r\nif (port)\r\nadapter->mc_type = port->mc_type;\r\nnic = be_get_func_nic_desc(resp->func_param, desc_count);\r\nif (nic)\r\nbe_copy_nic_desc(res, nic);\r\nvf_res = be_get_vft_desc(resp->func_param, desc_count);\r\nif (vf_res)\r\nres->vf_if_cap_flags = vf_res->cap_flags;\r\nerr:\r\nif (cmd.va)\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nstatic int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,\r\nint size, int count, u8 version, u8 domain)\r\n{\r\nstruct be_cmd_req_set_profile_config *req;\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_dma_mem cmd;\r\nint status;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_req_set_profile_config);\r\ncmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_PROFILE_CONFIG, cmd.size,\r\n&wrb, &cmd);\r\nreq->hdr.version = version;\r\nreq->hdr.domain = domain;\r\nreq->desc_count = cpu_to_le32(count);\r\nmemcpy(req->desc, desc, size);\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (cmd.va)\r\npci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nstatic void be_reset_nic_desc(struct be_nic_res_desc *nic)\r\n{\r\nmemset(nic, 0, sizeof(*nic));\r\nnic->unicast_mac_count = 0xFFFF;\r\nnic->mcc_count = 0xFFFF;\r\nnic->vlan_count = 0xFFFF;\r\nnic->mcast_mac_count = 0xFFFF;\r\nnic->txq_count = 0xFFFF;\r\nnic->rq_count = 0xFFFF;\r\nnic->rssq_count = 0xFFFF;\r\nnic->lro_count = 0xFFFF;\r\nnic->cq_count = 0xFFFF;\r\nnic->toe_conn_count = 0xFFFF;\r\nnic->eq_count = 0xFFFF;\r\nnic->iface_count = 0xFFFF;\r\nnic->link_param = 0xFF;\r\nnic->channel_id_param = cpu_to_le16(0xF000);\r\nnic->acpi_params = 0xFF;\r\nnic->wol_param = 0x0F;\r\nnic->tunnel_iface_count = 0xFFFF;\r\nnic->direct_tenant_iface_count = 0xFFFF;\r\nnic->bw_min = 0xFFFFFFFF;\r\nnic->bw_max = 0xFFFFFFFF;\r\n}\r\nstatic void be_reset_pcie_desc(struct be_pcie_res_desc *pcie)\r\n{\r\nmemset(pcie, 0, sizeof(*pcie));\r\npcie->sriov_state = 0xFF;\r\npcie->pf_state = 0xFF;\r\npcie->pf_type = 0xFF;\r\npcie->num_vfs = 0xFFFF;\r\n}\r\nint be_cmd_config_qos(struct be_adapter *adapter, u32 max_rate, u16 link_speed,\r\nu8 domain)\r\n{\r\nstruct be_nic_res_desc nic_desc;\r\nu32 bw_percent;\r\nu16 version = 0;\r\nif (BE3_chip(adapter))\r\nreturn be_cmd_set_qos(adapter, max_rate / 10, domain);\r\nbe_reset_nic_desc(&nic_desc);\r\nnic_desc.pf_num = adapter->pf_number;\r\nnic_desc.vf_num = domain;\r\nif (lancer_chip(adapter)) {\r\nnic_desc.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V0;\r\nnic_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V0;\r\nnic_desc.flags = (1 << QUN_SHIFT) | (1 << IMM_SHIFT) |\r\n(1 << NOSV_SHIFT);\r\nnic_desc.bw_max = cpu_to_le32(max_rate / 10);\r\n} else {\r\nversion = 1;\r\nnic_desc.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V1;\r\nnic_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\nnic_desc.flags = (1 << IMM_SHIFT) | (1 << NOSV_SHIFT);\r\nbw_percent = max_rate ? (max_rate * 100) / link_speed : 100;\r\nnic_desc.bw_max = cpu_to_le32(bw_percent);\r\n}\r\nreturn be_cmd_set_profile_config(adapter, &nic_desc,\r\nnic_desc.hdr.desc_len,\r\n1, version, domain);\r\n}\r\nint be_cmd_set_sriov_config(struct be_adapter *adapter,\r\nstruct be_resources res, u16 num_vfs)\r\n{\r\nstruct {\r\nstruct be_pcie_res_desc pcie;\r\nstruct be_nic_res_desc nic_vft;\r\n} __packed desc;\r\nu16 vf_q_count;\r\nif (BEx_chip(adapter) || lancer_chip(adapter))\r\nreturn 0;\r\nbe_reset_pcie_desc(&desc.pcie);\r\ndesc.pcie.hdr.desc_type = PCIE_RESOURCE_DESC_TYPE_V1;\r\ndesc.pcie.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\ndesc.pcie.flags = (1 << IMM_SHIFT) | (1 << NOSV_SHIFT);\r\ndesc.pcie.pf_num = adapter->pdev->devfn;\r\ndesc.pcie.sriov_state = num_vfs ? 1 : 0;\r\ndesc.pcie.num_vfs = cpu_to_le16(num_vfs);\r\nbe_reset_nic_desc(&desc.nic_vft);\r\ndesc.nic_vft.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V1;\r\ndesc.nic_vft.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\ndesc.nic_vft.flags = (1 << VFT_SHIFT) | (1 << IMM_SHIFT) |\r\n(1 << NOSV_SHIFT);\r\ndesc.nic_vft.pf_num = adapter->pdev->devfn;\r\ndesc.nic_vft.vf_num = 0;\r\nif (num_vfs && res.vf_if_cap_flags & BE_IF_FLAGS_RSS) {\r\nif (num_vfs < (be_max_vfs(adapter) - 8))\r\nvf_q_count = (res.max_rss_qs - 8) / num_vfs;\r\nelse\r\nvf_q_count = res.max_rss_qs / num_vfs;\r\ndesc.nic_vft.rq_count = cpu_to_le16(vf_q_count);\r\ndesc.nic_vft.txq_count = cpu_to_le16(vf_q_count);\r\ndesc.nic_vft.rssq_count = cpu_to_le16(vf_q_count - 1);\r\ndesc.nic_vft.cq_count = cpu_to_le16(3 * vf_q_count);\r\n} else {\r\ndesc.nic_vft.txq_count = cpu_to_le16(1);\r\ndesc.nic_vft.rq_count = cpu_to_le16(1);\r\ndesc.nic_vft.rssq_count = cpu_to_le16(0);\r\ndesc.nic_vft.cq_count = cpu_to_le16(3);\r\n}\r\nreturn be_cmd_set_profile_config(adapter, &desc,\r\n2 * RESOURCE_DESC_SIZE_V1, 2, 1, 0);\r\n}\r\nint be_cmd_manage_iface(struct be_adapter *adapter, u32 iface, u8 op)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_manage_iface_filters *req;\r\nint status;\r\nif (iface == 0xFFFFFFFF)\r\nreturn -1;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_IFACE_FILTERS, sizeof(*req),\r\nwrb, NULL);\r\nreq->op = op;\r\nreq->target_iface_id = cpu_to_le32(iface);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_vxlan_port(struct be_adapter *adapter, __be16 port)\r\n{\r\nstruct be_port_res_desc port_desc;\r\nmemset(&port_desc, 0, sizeof(port_desc));\r\nport_desc.hdr.desc_type = PORT_RESOURCE_DESC_TYPE_V1;\r\nport_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\nport_desc.flags = (1 << IMM_SHIFT) | (1 << NOSV_SHIFT);\r\nport_desc.link_num = adapter->hba_port_num;\r\nif (port) {\r\nport_desc.nv_flags = NV_TYPE_VXLAN | (1 << SOCVID_SHIFT) |\r\n(1 << RCVID_SHIFT);\r\nport_desc.nv_port = swab16(port);\r\n} else {\r\nport_desc.nv_flags = NV_TYPE_DISABLED;\r\nport_desc.nv_port = 0;\r\n}\r\nreturn be_cmd_set_profile_config(adapter, &port_desc,\r\nRESOURCE_DESC_SIZE_V1, 1, 1, 0);\r\n}\r\nint be_cmd_get_if_id(struct be_adapter *adapter, struct be_vf_cfg *vf_cfg,\r\nint vf_num)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_iface_list *req;\r\nstruct be_cmd_resp_get_iface_list *resp;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_IFACE_LIST, sizeof(*resp),\r\nwrb, NULL);\r\nreq->hdr.domain = vf_num + 1;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nresp = (struct be_cmd_resp_get_iface_list *)req;\r\nvf_cfg->if_handle = le32_to_cpu(resp->if_desc.if_id);\r\n}\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int lancer_wait_idle(struct be_adapter *adapter)\r\n{\r\n#define SLIPORT_IDLE_TIMEOUT 30\r\nu32 reg_val;\r\nint status = 0, i;\r\nfor (i = 0; i < SLIPORT_IDLE_TIMEOUT; i++) {\r\nreg_val = ioread32(adapter->db + PHYSDEV_CONTROL_OFFSET);\r\nif ((reg_val & PHYSDEV_CONTROL_INP_MASK) == 0)\r\nbreak;\r\nssleep(1);\r\n}\r\nif (i == SLIPORT_IDLE_TIMEOUT)\r\nstatus = -1;\r\nreturn status;\r\n}\r\nint lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask)\r\n{\r\nint status = 0;\r\nstatus = lancer_wait_idle(adapter);\r\nif (status)\r\nreturn status;\r\niowrite32(mask, adapter->db + PHYSDEV_CONTROL_OFFSET);\r\nreturn status;\r\n}\r\nbool dump_present(struct be_adapter *adapter)\r\n{\r\nu32 sliport_status = 0;\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nreturn !!(sliport_status & SLIPORT_STATUS_DIP_MASK);\r\n}\r\nint lancer_initiate_dump(struct be_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nint status;\r\nif (dump_present(adapter)) {\r\ndev_info(dev, "Previous dump not cleared, not forcing dump\n");\r\nreturn -EEXIST;\r\n}\r\nstatus = lancer_physdev_ctrl(adapter, PHYSDEV_CONTROL_FW_RESET_MASK |\r\nPHYSDEV_CONTROL_DD_MASK);\r\nif (status < 0) {\r\ndev_err(dev, "FW reset failed\n");\r\nreturn status;\r\n}\r\nstatus = lancer_wait_idle(adapter);\r\nif (status)\r\nreturn status;\r\nif (!dump_present(adapter)) {\r\ndev_err(dev, "FW dump not generated\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint lancer_delete_dump(struct be_adapter *adapter)\r\n{\r\nint status;\r\nstatus = lancer_cmd_delete_object(adapter, LANCER_FW_DUMP_FILE);\r\nreturn be_cmd_status(status);\r\n}\r\nint be_cmd_enable_vf(struct be_adapter *adapter, u8 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_enable_disable_vf *req;\r\nint status;\r\nif (BEx_chip(adapter))\r\nreturn 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_ENABLE_DISABLE_VF, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->enable = 1;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_intr_set(struct be_adapter *adapter, bool intr_enable)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_intr_set *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_INTERRUPT_ENABLE, sizeof(*req),\r\nwrb, NULL);\r\nreq->intr_enabled = intr_enable;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_active_profile(struct be_adapter *adapter, u16 *profile_id)\r\n{\r\nstruct be_cmd_req_get_active_profile *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_ACTIVE_PROFILE, sizeof(*req),\r\nwrb, NULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_active_profile *resp =\r\nembedded_payload(wrb);\r\n*profile_id = le16_to_cpu(resp->active_profile_id);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_logical_link_config(struct be_adapter *adapter,\r\nint link_state, u8 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_ll_link *req;\r\nint status;\r\nif (BEx_chip(adapter) || lancer_chip(adapter))\r\nreturn 0;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_LOGICAL_LINK_CONFIG,\r\nsizeof(*req), wrb, NULL);\r\nreq->hdr.version = 1;\r\nreq->hdr.domain = domain;\r\nif (link_state == IFLA_VF_LINK_STATE_ENABLE)\r\nreq->link_config |= 1;\r\nif (link_state == IFLA_VF_LINK_STATE_AUTO)\r\nreq->link_config |= 1 << PLINK_TRACK_SHIFT;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_roce_mcc_cmd(void *netdev_handle, void *wrb_payload,\r\nint wrb_payload_size, u16 *cmd_status, u16 *ext_status)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev_handle);\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *hdr = (struct be_cmd_req_hdr *)wrb_payload;\r\nstruct be_cmd_req_hdr *req;\r\nstruct be_cmd_resp_hdr *resp;\r\nint status;\r\nspin_lock_bh(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nresp = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(req, hdr->subsystem,\r\nhdr->opcode, wrb_payload_size, wrb, NULL);\r\nmemcpy(req, wrb_payload, wrb_payload_size);\r\nbe_dws_cpu_to_le(req, wrb_payload_size);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (cmd_status)\r\n*cmd_status = (status & 0xffff);\r\nif (ext_status)\r\n*ext_status = 0;\r\nmemcpy(wrb_payload, resp, sizeof(*resp) + resp->response_length);\r\nbe_dws_le_to_cpu(wrb_payload, sizeof(*resp) + resp->response_length);\r\nerr:\r\nspin_unlock_bh(&adapter->mcc_lock);\r\nreturn status;\r\n}
