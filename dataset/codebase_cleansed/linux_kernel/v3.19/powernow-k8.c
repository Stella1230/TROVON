static inline const struct cpumask *cpu_core_mask(int cpu)\r\n{\r\nreturn cpumask_of(0);\r\n}\r\nstatic u32 find_freq_from_fid(u32 fid)\r\n{\r\nreturn 800 + (fid * 100);\r\n}\r\nstatic u32 find_khz_freq_from_fid(u32 fid)\r\n{\r\nreturn 1000 * find_freq_from_fid(fid);\r\n}\r\nstatic u32 convert_fid_to_vco_fid(u32 fid)\r\n{\r\nif (fid < HI_FID_TABLE_BOTTOM)\r\nreturn 8 + (2 * fid);\r\nelse\r\nreturn fid;\r\n}\r\nstatic int pending_bit_stuck(void)\r\n{\r\nu32 lo, hi;\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\nreturn lo & MSR_S_LO_CHANGE_PENDING ? 1 : 0;\r\n}\r\nstatic int query_current_values_with_pending_wait(struct powernow_k8_data *data)\r\n{\r\nu32 lo, hi;\r\nu32 i = 0;\r\ndo {\r\nif (i++ > 10000) {\r\npr_debug("detected change pending stuck\n");\r\nreturn 1;\r\n}\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\n} while (lo & MSR_S_LO_CHANGE_PENDING);\r\ndata->currvid = hi & MSR_S_HI_CURRENT_VID;\r\ndata->currfid = lo & MSR_S_LO_CURRENT_FID;\r\nreturn 0;\r\n}\r\nstatic void count_off_irt(struct powernow_k8_data *data)\r\n{\r\nudelay((1 << data->irt) * 10);\r\nreturn;\r\n}\r\nstatic void count_off_vst(struct powernow_k8_data *data)\r\n{\r\nudelay(data->vstable * VST_UNITS_20US);\r\nreturn;\r\n}\r\nstatic void fidvid_msr_init(void)\r\n{\r\nu32 lo, hi;\r\nu8 fid, vid;\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\nvid = hi & MSR_S_HI_CURRENT_VID;\r\nfid = lo & MSR_S_LO_CURRENT_FID;\r\nlo = fid | (vid << MSR_C_LO_VID_SHIFT);\r\nhi = MSR_C_HI_STP_GNT_BENIGN;\r\npr_debug("cpu%d, init lo 0x%x, hi 0x%x\n", smp_processor_id(), lo, hi);\r\nwrmsr(MSR_FIDVID_CTL, lo, hi);\r\n}\r\nstatic int write_new_fid(struct powernow_k8_data *data, u32 fid)\r\n{\r\nu32 lo;\r\nu32 savevid = data->currvid;\r\nu32 i = 0;\r\nif ((fid & INVALID_FID_MASK) || (data->currvid & INVALID_VID_MASK)) {\r\npr_err("internal error - overflow on fid write\n");\r\nreturn 1;\r\n}\r\nlo = fid;\r\nlo |= (data->currvid << MSR_C_LO_VID_SHIFT);\r\nlo |= MSR_C_LO_INIT_FID_VID;\r\npr_debug("writing fid 0x%x, lo 0x%x, hi 0x%x\n",\r\nfid, lo, data->plllock * PLL_LOCK_CONVERSION);\r\ndo {\r\nwrmsr(MSR_FIDVID_CTL, lo, data->plllock * PLL_LOCK_CONVERSION);\r\nif (i++ > 100) {\r\npr_err("Hardware error - pending bit very stuck - no further pstate changes possible\n");\r\nreturn 1;\r\n}\r\n} while (query_current_values_with_pending_wait(data));\r\ncount_off_irt(data);\r\nif (savevid != data->currvid) {\r\npr_err("vid change on fid trans, old 0x%x, new 0x%x\n",\r\nsavevid, data->currvid);\r\nreturn 1;\r\n}\r\nif (fid != data->currfid) {\r\npr_err("fid trans failed, fid 0x%x, curr 0x%x\n", fid,\r\ndata->currfid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_new_vid(struct powernow_k8_data *data, u32 vid)\r\n{\r\nu32 lo;\r\nu32 savefid = data->currfid;\r\nint i = 0;\r\nif ((data->currfid & INVALID_FID_MASK) || (vid & INVALID_VID_MASK)) {\r\npr_err("internal error - overflow on vid write\n");\r\nreturn 1;\r\n}\r\nlo = data->currfid;\r\nlo |= (vid << MSR_C_LO_VID_SHIFT);\r\nlo |= MSR_C_LO_INIT_FID_VID;\r\npr_debug("writing vid 0x%x, lo 0x%x, hi 0x%x\n",\r\nvid, lo, STOP_GRANT_5NS);\r\ndo {\r\nwrmsr(MSR_FIDVID_CTL, lo, STOP_GRANT_5NS);\r\nif (i++ > 100) {\r\npr_err("internal error - pending bit very stuck - no further pstate changes possible\n");\r\nreturn 1;\r\n}\r\n} while (query_current_values_with_pending_wait(data));\r\nif (savefid != data->currfid) {\r\npr_err("fid changed on vid trans, old 0x%x new 0x%x\n",\r\nsavefid, data->currfid);\r\nreturn 1;\r\n}\r\nif (vid != data->currvid) {\r\npr_err("vid trans failed, vid 0x%x, curr 0x%x\n",\r\nvid, data->currvid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int decrease_vid_code_by_step(struct powernow_k8_data *data,\r\nu32 reqvid, u32 step)\r\n{\r\nif ((data->currvid - reqvid) > step)\r\nreqvid = data->currvid - step;\r\nif (write_new_vid(data, reqvid))\r\nreturn 1;\r\ncount_off_vst(data);\r\nreturn 0;\r\n}\r\nstatic int transition_fid_vid(struct powernow_k8_data *data,\r\nu32 reqfid, u32 reqvid)\r\n{\r\nif (core_voltage_pre_transition(data, reqvid, reqfid))\r\nreturn 1;\r\nif (core_frequency_transition(data, reqfid))\r\nreturn 1;\r\nif (core_voltage_post_transition(data, reqvid))\r\nreturn 1;\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif ((reqfid != data->currfid) || (reqvid != data->currvid)) {\r\npr_err("failed (cpu%d): req 0x%x 0x%x, curr 0x%x 0x%x\n",\r\nsmp_processor_id(),\r\nreqfid, reqvid, data->currfid, data->currvid);\r\nreturn 1;\r\n}\r\npr_debug("transitioned (cpu%d): new fid 0x%x, vid 0x%x\n",\r\nsmp_processor_id(), data->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_voltage_pre_transition(struct powernow_k8_data *data,\r\nu32 reqvid, u32 reqfid)\r\n{\r\nu32 rvosteps = data->rvo;\r\nu32 savefid = data->currfid;\r\nu32 maxvid, lo, rvomult = 1;\r\npr_debug("ph1 (cpu%d): start, currfid 0x%x, currvid 0x%x, reqvid 0x%x, rvo 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid, reqvid, data->rvo);\r\nif ((savefid < LO_FID_TABLE_TOP) && (reqfid < LO_FID_TABLE_TOP))\r\nrvomult = 2;\r\nrvosteps *= rvomult;\r\nrdmsr(MSR_FIDVID_STATUS, lo, maxvid);\r\nmaxvid = 0x1f & (maxvid >> 16);\r\npr_debug("ph1 maxvid=0x%x\n", maxvid);\r\nif (reqvid < maxvid)\r\nreqvid = maxvid;\r\nwhile (data->currvid > reqvid) {\r\npr_debug("ph1: curr 0x%x, req vid 0x%x\n",\r\ndata->currvid, reqvid);\r\nif (decrease_vid_code_by_step(data, reqvid, data->vidmvs))\r\nreturn 1;\r\n}\r\nwhile ((rvosteps > 0) &&\r\n((rvomult * data->rvo + data->currvid) > reqvid)) {\r\nif (data->currvid == maxvid) {\r\nrvosteps = 0;\r\n} else {\r\npr_debug("ph1: changing vid for rvo, req 0x%x\n",\r\ndata->currvid - 1);\r\nif (decrease_vid_code_by_step(data, data->currvid-1, 1))\r\nreturn 1;\r\nrvosteps--;\r\n}\r\n}\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (savefid != data->currfid) {\r\npr_err("ph1 err, currfid changed 0x%x\n", data->currfid);\r\nreturn 1;\r\n}\r\npr_debug("ph1 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_frequency_transition(struct powernow_k8_data *data, u32 reqfid)\r\n{\r\nu32 vcoreqfid, vcocurrfid, vcofiddiff;\r\nu32 fid_interval, savevid = data->currvid;\r\nif (data->currfid == reqfid) {\r\npr_err("ph2 null fid transition 0x%x\n", data->currfid);\r\nreturn 0;\r\n}\r\npr_debug("ph2 (cpu%d): starting, currfid 0x%x, currvid 0x%x, reqfid 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid, reqfid);\r\nvcoreqfid = convert_fid_to_vco_fid(reqfid);\r\nvcocurrfid = convert_fid_to_vco_fid(data->currfid);\r\nvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\r\n: vcoreqfid - vcocurrfid;\r\nif ((reqfid <= LO_FID_TABLE_TOP) && (data->currfid <= LO_FID_TABLE_TOP))\r\nvcofiddiff = 0;\r\nwhile (vcofiddiff > 2) {\r\n(data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);\r\nif (reqfid > data->currfid) {\r\nif (data->currfid > LO_FID_TABLE_TOP) {\r\nif (write_new_fid(data,\r\ndata->currfid + fid_interval))\r\nreturn 1;\r\n} else {\r\nif (write_new_fid\r\n(data,\r\n2 + convert_fid_to_vco_fid(data->currfid)))\r\nreturn 1;\r\n}\r\n} else {\r\nif (write_new_fid(data, data->currfid - fid_interval))\r\nreturn 1;\r\n}\r\nvcocurrfid = convert_fid_to_vco_fid(data->currfid);\r\nvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\r\n: vcoreqfid - vcocurrfid;\r\n}\r\nif (write_new_fid(data, reqfid))\r\nreturn 1;\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (data->currfid != reqfid) {\r\npr_err("ph2: mismatch, failed fid transition, curr 0x%x, req 0x%x\n",\r\ndata->currfid, reqfid);\r\nreturn 1;\r\n}\r\nif (savevid != data->currvid) {\r\npr_err("ph2: vid changed, save 0x%x, curr 0x%x\n",\r\nsavevid, data->currvid);\r\nreturn 1;\r\n}\r\npr_debug("ph2 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_voltage_post_transition(struct powernow_k8_data *data,\r\nu32 reqvid)\r\n{\r\nu32 savefid = data->currfid;\r\nu32 savereqvid = reqvid;\r\npr_debug("ph3 (cpu%d): starting, currfid 0x%x, currvid 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid);\r\nif (reqvid != data->currvid) {\r\nif (write_new_vid(data, reqvid))\r\nreturn 1;\r\nif (savefid != data->currfid) {\r\npr_err("ph3: bad fid change, save 0x%x, curr 0x%x\n",\r\nsavefid, data->currfid);\r\nreturn 1;\r\n}\r\nif (data->currvid != reqvid) {\r\npr_err("ph3: failed vid transition\n, req 0x%x, curr 0x%x",\r\nreqvid, data->currvid);\r\nreturn 1;\r\n}\r\n}\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (savereqvid != data->currvid) {\r\npr_debug("ph3 failed, currvid 0x%x\n", data->currvid);\r\nreturn 1;\r\n}\r\nif (savefid != data->currfid) {\r\npr_debug("ph3 failed, currfid changed 0x%x\n",\r\ndata->currfid);\r\nreturn 1;\r\n}\r\npr_debug("ph3 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic void check_supported_cpu(void *_rc)\r\n{\r\nu32 eax, ebx, ecx, edx;\r\nint *rc = _rc;\r\n*rc = -ENODEV;\r\neax = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\r\nif ((eax & CPUID_XFAM) == CPUID_XFAM_K8) {\r\nif (((eax & CPUID_USE_XFAM_XMOD) != CPUID_USE_XFAM_XMOD) ||\r\n((eax & CPUID_XMOD) > CPUID_XMOD_REV_MASK)) {\r\npr_info("Processor cpuid %x not supported\n", eax);\r\nreturn;\r\n}\r\neax = cpuid_eax(CPUID_GET_MAX_CAPABILITIES);\r\nif (eax < CPUID_FREQ_VOLT_CAPABILITIES) {\r\npr_info("No frequency change capabilities detected\n");\r\nreturn;\r\n}\r\ncpuid(CPUID_FREQ_VOLT_CAPABILITIES, &eax, &ebx, &ecx, &edx);\r\nif ((edx & P_STATE_TRANSITION_CAPABLE)\r\n!= P_STATE_TRANSITION_CAPABLE) {\r\npr_info("Power state transitions not supported\n");\r\nreturn;\r\n}\r\n*rc = 0;\r\n}\r\n}\r\nstatic int check_pst_table(struct powernow_k8_data *data, struct pst_s *pst,\r\nu8 maxvid)\r\n{\r\nunsigned int j;\r\nu8 lastfid = 0xff;\r\nfor (j = 0; j < data->numps; j++) {\r\nif (pst[j].vid > LEAST_VID) {\r\npr_err(FW_BUG "vid %d invalid : 0x%x\n", j,\r\npst[j].vid);\r\nreturn -EINVAL;\r\n}\r\nif (pst[j].vid < data->rvo) {\r\npr_err(FW_BUG "0 vid exceeded with pstate %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (pst[j].vid < maxvid + data->rvo) {\r\npr_err(FW_BUG "maxvid exceeded with pstate %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (pst[j].fid > MAX_FID) {\r\npr_err(FW_BUG "maxfid exceeded with pstate %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (j && (pst[j].fid < HI_FID_TABLE_BOTTOM)) {\r\npr_err(FW_BUG "two low fids - %d : 0x%x\n", j,\r\npst[j].fid);\r\nreturn -EINVAL;\r\n}\r\nif (pst[j].fid < lastfid)\r\nlastfid = pst[j].fid;\r\n}\r\nif (lastfid & 1) {\r\npr_err(FW_BUG "lastfid invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (lastfid > LO_FID_TABLE_TOP)\r\npr_info(FW_BUG "first fid not from lo freq table\n");\r\nreturn 0;\r\n}\r\nstatic void invalidate_entry(struct cpufreq_frequency_table *powernow_table,\r\nunsigned int entry)\r\n{\r\npowernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nstatic void print_basics(struct powernow_k8_data *data)\r\n{\r\nint j;\r\nfor (j = 0; j < data->numps; j++) {\r\nif (data->powernow_table[j].frequency !=\r\nCPUFREQ_ENTRY_INVALID) {\r\npr_info("fid 0x%x (%d MHz), vid 0x%x\n",\r\ndata->powernow_table[j].driver_data & 0xff,\r\ndata->powernow_table[j].frequency/1000,\r\ndata->powernow_table[j].driver_data >> 8);\r\n}\r\n}\r\nif (data->batps)\r\npr_info("Only %d pstates on battery\n", data->batps);\r\n}\r\nstatic int fill_powernow_table(struct powernow_k8_data *data,\r\nstruct pst_s *pst, u8 maxvid)\r\n{\r\nstruct cpufreq_frequency_table *powernow_table;\r\nunsigned int j;\r\nif (data->batps) {\r\npr_warn("Only %d pstates usable (use ACPI driver for full range\n",\r\ndata->batps);\r\ndata->numps = data->batps;\r\n}\r\nfor (j = 1; j < data->numps; j++) {\r\nif (pst[j-1].fid >= pst[j].fid) {\r\npr_err("PST out of sequence\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data->numps < 2) {\r\npr_err("no p states to transition\n");\r\nreturn -ENODEV;\r\n}\r\nif (check_pst_table(data, pst, maxvid))\r\nreturn -EINVAL;\r\npowernow_table = kzalloc((sizeof(*powernow_table)\r\n* (data->numps + 1)), GFP_KERNEL);\r\nif (!powernow_table) {\r\npr_err("powernow_table memory alloc failure\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < data->numps; j++) {\r\nint freq;\r\npowernow_table[j].driver_data = pst[j].fid;\r\npowernow_table[j].driver_data |= (pst[j].vid << 8);\r\nfreq = find_khz_freq_from_fid(pst[j].fid);\r\npowernow_table[j].frequency = freq;\r\n}\r\npowernow_table[data->numps].frequency = CPUFREQ_TABLE_END;\r\npowernow_table[data->numps].driver_data = 0;\r\nif (query_current_values_with_pending_wait(data)) {\r\nkfree(powernow_table);\r\nreturn -EIO;\r\n}\r\npr_debug("cfid 0x%x, cvid 0x%x\n", data->currfid, data->currvid);\r\ndata->powernow_table = powernow_table;\r\nif (cpumask_first(cpu_core_mask(data->cpu)) == data->cpu)\r\nprint_basics(data);\r\nfor (j = 0; j < data->numps; j++)\r\nif ((pst[j].fid == data->currfid) &&\r\n(pst[j].vid == data->currvid))\r\nreturn 0;\r\npr_debug("currfid/vid do not match PST, ignoring\n");\r\nreturn 0;\r\n}\r\nstatic int find_psb_table(struct powernow_k8_data *data)\r\n{\r\nstruct psb_s *psb;\r\nunsigned int i;\r\nu32 mvs;\r\nu8 maxvid;\r\nu32 cpst = 0;\r\nu32 thiscpuid;\r\nfor (i = 0xc0000; i < 0xffff0; i += 0x10) {\r\npsb = phys_to_virt(i);\r\nif (memcmp(psb, PSB_ID_STRING, PSB_ID_STRING_LEN) != 0)\r\ncontinue;\r\npr_debug("found PSB header at 0x%p\n", psb);\r\npr_debug("table vers: 0x%x\n", psb->tableversion);\r\nif (psb->tableversion != PSB_VERSION_1_4) {\r\npr_err(FW_BUG "PSB table is not v1.4\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("flags: 0x%x\n", psb->flags1);\r\nif (psb->flags1) {\r\npr_err(FW_BUG "unknown flags\n");\r\nreturn -ENODEV;\r\n}\r\ndata->vstable = psb->vstable;\r\npr_debug("voltage stabilization time: %d(*20us)\n",\r\ndata->vstable);\r\npr_debug("flags2: 0x%x\n", psb->flags2);\r\ndata->rvo = psb->flags2 & 3;\r\ndata->irt = ((psb->flags2) >> 2) & 3;\r\nmvs = ((psb->flags2) >> 4) & 3;\r\ndata->vidmvs = 1 << mvs;\r\ndata->batps = ((psb->flags2) >> 6) & 3;\r\npr_debug("ramp voltage offset: %d\n", data->rvo);\r\npr_debug("isochronous relief time: %d\n", data->irt);\r\npr_debug("maximum voltage step: %d - 0x%x\n", mvs, data->vidmvs);\r\npr_debug("numpst: 0x%x\n", psb->num_tables);\r\ncpst = psb->num_tables;\r\nif ((psb->cpuid == 0x00000fc0) ||\r\n(psb->cpuid == 0x00000fe0)) {\r\nthiscpuid = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\r\nif ((thiscpuid == 0x00000fc0) ||\r\n(thiscpuid == 0x00000fe0))\r\ncpst = 1;\r\n}\r\nif (cpst != 1) {\r\npr_err(FW_BUG "numpst must be 1\n");\r\nreturn -ENODEV;\r\n}\r\ndata->plllock = psb->plllocktime;\r\npr_debug("plllocktime: 0x%x (units 1us)\n", psb->plllocktime);\r\npr_debug("maxfid: 0x%x\n", psb->maxfid);\r\npr_debug("maxvid: 0x%x\n", psb->maxvid);\r\nmaxvid = psb->maxvid;\r\ndata->numps = psb->numps;\r\npr_debug("numpstates: 0x%x\n", data->numps);\r\nreturn fill_powernow_table(data,\r\n(struct pst_s *)(psb+1), maxvid);\r\n}\r\npr_err(FW_BUG "No PSB or ACPI _PSS objects\n");\r\npr_err("Make sure that your BIOS is up to date and Cool'N'Quiet support is enabled in BIOS setup\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void powernow_k8_acpi_pst_values(struct powernow_k8_data *data,\r\nunsigned int index)\r\n{\r\nu64 control;\r\nif (!data->acpi_data.state_count)\r\nreturn;\r\ncontrol = data->acpi_data.states[index].control;\r\ndata->irt = (control >> IRT_SHIFT) & IRT_MASK;\r\ndata->rvo = (control >> RVO_SHIFT) & RVO_MASK;\r\ndata->exttype = (control >> EXT_TYPE_SHIFT) & EXT_TYPE_MASK;\r\ndata->plllock = (control >> PLL_L_SHIFT) & PLL_L_MASK;\r\ndata->vidmvs = 1 << ((control >> MVS_SHIFT) & MVS_MASK);\r\ndata->vstable = (control >> VST_SHIFT) & VST_MASK;\r\n}\r\nstatic int powernow_k8_cpu_init_acpi(struct powernow_k8_data *data)\r\n{\r\nstruct cpufreq_frequency_table *powernow_table;\r\nint ret_val = -ENODEV;\r\nu64 control, status;\r\nif (acpi_processor_register_performance(&data->acpi_data, data->cpu)) {\r\npr_debug("register performance failed: bad ACPI data\n");\r\nreturn -EIO;\r\n}\r\nif (data->acpi_data.state_count <= 1) {\r\npr_debug("No ACPI P-States\n");\r\ngoto err_out;\r\n}\r\ncontrol = data->acpi_data.control_register.space_id;\r\nstatus = data->acpi_data.status_register.space_id;\r\nif ((control != ACPI_ADR_SPACE_FIXED_HARDWARE) ||\r\n(status != ACPI_ADR_SPACE_FIXED_HARDWARE)) {\r\npr_debug("Invalid control/status registers (%llx - %llx)\n",\r\ncontrol, status);\r\ngoto err_out;\r\n}\r\npowernow_table = kzalloc((sizeof(*powernow_table)\r\n* (data->acpi_data.state_count + 1)), GFP_KERNEL);\r\nif (!powernow_table) {\r\npr_debug("powernow_table memory alloc failure\n");\r\ngoto err_out;\r\n}\r\ndata->numps = data->acpi_data.state_count;\r\npowernow_k8_acpi_pst_values(data, 0);\r\nret_val = fill_powernow_table_fidvid(data, powernow_table);\r\nif (ret_val)\r\ngoto err_out_mem;\r\npowernow_table[data->acpi_data.state_count].frequency =\r\nCPUFREQ_TABLE_END;\r\ndata->powernow_table = powernow_table;\r\nif (cpumask_first(cpu_core_mask(data->cpu)) == data->cpu)\r\nprint_basics(data);\r\nacpi_processor_notify_smm(THIS_MODULE);\r\nif (!zalloc_cpumask_var(&data->acpi_data.shared_cpu_map, GFP_KERNEL)) {\r\npr_err("unable to alloc powernow_k8_data cpumask\n");\r\nret_val = -ENOMEM;\r\ngoto err_out_mem;\r\n}\r\nreturn 0;\r\nerr_out_mem:\r\nkfree(powernow_table);\r\nerr_out:\r\nacpi_processor_unregister_performance(&data->acpi_data, data->cpu);\r\ndata->acpi_data.state_count = 0;\r\nreturn ret_val;\r\n}\r\nstatic int fill_powernow_table_fidvid(struct powernow_k8_data *data,\r\nstruct cpufreq_frequency_table *powernow_table)\r\n{\r\nint i;\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nu32 fid;\r\nu32 vid;\r\nu32 freq, index;\r\nu64 status, control;\r\nif (data->exttype) {\r\nstatus = data->acpi_data.states[i].status;\r\nfid = status & EXT_FID_MASK;\r\nvid = (status >> VID_SHIFT) & EXT_VID_MASK;\r\n} else {\r\ncontrol = data->acpi_data.states[i].control;\r\nfid = control & FID_MASK;\r\nvid = (control >> VID_SHIFT) & VID_MASK;\r\n}\r\npr_debug(" %d : fid 0x%x, vid 0x%x\n", i, fid, vid);\r\nindex = fid | (vid<<8);\r\npowernow_table[i].driver_data = index;\r\nfreq = find_khz_freq_from_fid(fid);\r\npowernow_table[i].frequency = freq;\r\nif ((freq > (MAX_FREQ * 1000)) || (freq < (MIN_FREQ * 1000))) {\r\npr_debug("invalid freq %u kHz, ignoring\n", freq);\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\nif (vid == VID_OFF) {\r\npr_debug("invalid vid %u, ignoring\n", vid);\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\nif (freq != (data->acpi_data.states[i].core_frequency * 1000)) {\r\npr_info("invalid freq entries %u kHz vs. %u kHz\n",\r\nfreq, (unsigned int)\r\n(data->acpi_data.states[i].core_frequency\r\n* 1000));\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void powernow_k8_cpu_exit_acpi(struct powernow_k8_data *data)\r\n{\r\nif (data->acpi_data.state_count)\r\nacpi_processor_unregister_performance(&data->acpi_data,\r\ndata->cpu);\r\nfree_cpumask_var(data->acpi_data.shared_cpu_map);\r\n}\r\nstatic int get_transition_latency(struct powernow_k8_data *data)\r\n{\r\nint max_latency = 0;\r\nint i;\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nint cur_latency = data->acpi_data.states[i].transition_latency\r\n+ data->acpi_data.states[i].bus_master_latency;\r\nif (cur_latency > max_latency)\r\nmax_latency = cur_latency;\r\n}\r\nif (max_latency == 0) {\r\npr_err(FW_WARN "Invalid zero transition latency\n");\r\nmax_latency = 1;\r\n}\r\nreturn 1000 * max_latency;\r\n}\r\nstatic int transition_frequency_fidvid(struct powernow_k8_data *data,\r\nunsigned int index)\r\n{\r\nstruct cpufreq_policy *policy;\r\nu32 fid = 0;\r\nu32 vid = 0;\r\nint res;\r\nstruct cpufreq_freqs freqs;\r\npr_debug("cpu %d transition to index %u\n", smp_processor_id(), index);\r\nfid = data->powernow_table[index].driver_data & 0xFF;\r\nvid = (data->powernow_table[index].driver_data & 0xFF00) >> 8;\r\npr_debug("table matched fid 0x%x, giving vid 0x%x\n", fid, vid);\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif ((data->currvid == vid) && (data->currfid == fid)) {\r\npr_debug("target matches current values (fid 0x%x, vid 0x%x)\n",\r\nfid, vid);\r\nreturn 0;\r\n}\r\npr_debug("cpu %d, changing to fid 0x%x, vid 0x%x\n",\r\nsmp_processor_id(), fid, vid);\r\nfreqs.old = find_khz_freq_from_fid(data->currfid);\r\nfreqs.new = find_khz_freq_from_fid(fid);\r\npolicy = cpufreq_cpu_get(smp_processor_id());\r\ncpufreq_cpu_put(policy);\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\nres = transition_fid_vid(data, fid, vid);\r\ncpufreq_freq_transition_end(policy, &freqs, res);\r\nreturn res;\r\n}\r\nstatic long powernowk8_target_fn(void *arg)\r\n{\r\nstruct powernowk8_target_arg *pta = arg;\r\nstruct cpufreq_policy *pol = pta->pol;\r\nunsigned newstate = pta->newstate;\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\r\nu32 checkfid;\r\nu32 checkvid;\r\nint ret;\r\nif (!data)\r\nreturn -EINVAL;\r\ncheckfid = data->currfid;\r\ncheckvid = data->currvid;\r\nif (pending_bit_stuck()) {\r\npr_err("failing targ, change pending bit set\n");\r\nreturn -EIO;\r\n}\r\npr_debug("targ: cpu %d, %d kHz, min %d, max %d\n",\r\npol->cpu, data->powernow_table[newstate].frequency, pol->min,\r\npol->max);\r\nif (query_current_values_with_pending_wait(data))\r\nreturn -EIO;\r\npr_debug("targ: curr fid 0x%x, vid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nif ((checkvid != data->currvid) ||\r\n(checkfid != data->currfid)) {\r\npr_info("error - out of sync, fix 0x%x 0x%x, vid 0x%x 0x%x\n",\r\ncheckfid, data->currfid,\r\ncheckvid, data->currvid);\r\n}\r\nmutex_lock(&fidvid_mutex);\r\npowernow_k8_acpi_pst_values(data, newstate);\r\nret = transition_frequency_fidvid(data, newstate);\r\nif (ret) {\r\npr_err("transition frequency failed\n");\r\nmutex_unlock(&fidvid_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&fidvid_mutex);\r\npol->cur = find_khz_freq_from_fid(data->currfid);\r\nreturn 0;\r\n}\r\nstatic int powernowk8_target(struct cpufreq_policy *pol, unsigned index)\r\n{\r\nstruct powernowk8_target_arg pta = { .pol = pol, .newstate = index };\r\nreturn work_on_cpu(pol->cpu, powernowk8_target_fn, &pta);\r\n}\r\nstatic void powernowk8_cpu_init_on_cpu(void *_init_on_cpu)\r\n{\r\nstruct init_on_cpu *init_on_cpu = _init_on_cpu;\r\nif (pending_bit_stuck()) {\r\npr_err("failing init, change pending bit set\n");\r\ninit_on_cpu->rc = -ENODEV;\r\nreturn;\r\n}\r\nif (query_current_values_with_pending_wait(init_on_cpu->data)) {\r\ninit_on_cpu->rc = -ENODEV;\r\nreturn;\r\n}\r\nfidvid_msr_init();\r\ninit_on_cpu->rc = 0;\r\n}\r\nstatic int powernowk8_cpu_init(struct cpufreq_policy *pol)\r\n{\r\nstruct powernow_k8_data *data;\r\nstruct init_on_cpu init_on_cpu;\r\nint rc, cpu;\r\nsmp_call_function_single(pol->cpu, check_supported_cpu, &rc, 1);\r\nif (rc)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\npr_err("unable to alloc powernow_k8_data");\r\nreturn -ENOMEM;\r\n}\r\ndata->cpu = pol->cpu;\r\nif (powernow_k8_cpu_init_acpi(data)) {\r\nif (num_online_cpus() != 1) {\r\npr_err_once(MISSING_PSS_MSG);\r\ngoto err_out;\r\n}\r\nif (pol->cpu != 0) {\r\npr_err(FW_BUG "No ACPI _PSS objects for CPU other than CPU0. Complain to your BIOS vendor.\n");\r\ngoto err_out;\r\n}\r\nrc = find_psb_table(data);\r\nif (rc)\r\ngoto err_out;\r\npol->cpuinfo.transition_latency = (\r\n((data->rvo + 8) * data->vstable * VST_UNITS_20US) +\r\n((1 << data->irt) * 30)) * 1000;\r\n} else\r\npol->cpuinfo.transition_latency = get_transition_latency(data);\r\ninit_on_cpu.data = data;\r\nsmp_call_function_single(data->cpu, powernowk8_cpu_init_on_cpu,\r\n&init_on_cpu, 1);\r\nrc = init_on_cpu.rc;\r\nif (rc != 0)\r\ngoto err_out_exit_acpi;\r\ncpumask_copy(pol->cpus, cpu_core_mask(pol->cpu));\r\ndata->available_cores = pol->cpus;\r\nif (cpufreq_table_validate_and_show(pol, data->powernow_table)) {\r\npr_err(FW_BUG "invalid powernow_table\n");\r\npowernow_k8_cpu_exit_acpi(data);\r\nkfree(data->powernow_table);\r\nkfree(data);\r\nreturn -EINVAL;\r\n}\r\npr_debug("cpu_init done, current fid 0x%x, vid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nfor_each_cpu(cpu, pol->cpus)\r\nper_cpu(powernow_data, cpu) = data;\r\nreturn 0;\r\nerr_out_exit_acpi:\r\npowernow_k8_cpu_exit_acpi(data);\r\nerr_out:\r\nkfree(data);\r\nreturn -ENODEV;\r\n}\r\nstatic int powernowk8_cpu_exit(struct cpufreq_policy *pol)\r\n{\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\r\nint cpu;\r\nif (!data)\r\nreturn -EINVAL;\r\npowernow_k8_cpu_exit_acpi(data);\r\nkfree(data->powernow_table);\r\nkfree(data);\r\nfor_each_cpu(cpu, pol->cpus)\r\nper_cpu(powernow_data, cpu) = NULL;\r\nreturn 0;\r\n}\r\nstatic void query_values_on_cpu(void *_err)\r\n{\r\nint *err = _err;\r\nstruct powernow_k8_data *data = __this_cpu_read(powernow_data);\r\n*err = query_current_values_with_pending_wait(data);\r\n}\r\nstatic unsigned int powernowk8_get(unsigned int cpu)\r\n{\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, cpu);\r\nunsigned int khz = 0;\r\nint err;\r\nif (!data)\r\nreturn 0;\r\nsmp_call_function_single(cpu, query_values_on_cpu, &err, true);\r\nif (err)\r\ngoto out;\r\nkhz = find_khz_freq_from_fid(data->currfid);\r\nout:\r\nreturn khz;\r\n}\r\nstatic void __request_acpi_cpufreq(void)\r\n{\r\nconst char *cur_drv, *drv = "acpi-cpufreq";\r\ncur_drv = cpufreq_get_current_driver();\r\nif (!cur_drv)\r\ngoto request;\r\nif (strncmp(cur_drv, drv, min_t(size_t, strlen(cur_drv), strlen(drv))))\r\npr_warn("WTF driver: %s\n", cur_drv);\r\nreturn;\r\nrequest:\r\npr_warn("This CPU is not supported anymore, using acpi-cpufreq instead.\n");\r\nrequest_module(drv);\r\n}\r\nstatic int powernowk8_init(void)\r\n{\r\nunsigned int i, supported_cpus = 0;\r\nint ret;\r\nif (static_cpu_has(X86_FEATURE_HW_PSTATE)) {\r\n__request_acpi_cpufreq();\r\nreturn -ENODEV;\r\n}\r\nif (!x86_match_cpu(powernow_k8_ids))\r\nreturn -ENODEV;\r\nget_online_cpus();\r\nfor_each_online_cpu(i) {\r\nsmp_call_function_single(i, check_supported_cpu, &ret, 1);\r\nif (!ret)\r\nsupported_cpus++;\r\n}\r\nif (supported_cpus != num_online_cpus()) {\r\nput_online_cpus();\r\nreturn -ENODEV;\r\n}\r\nput_online_cpus();\r\nret = cpufreq_register_driver(&cpufreq_amd64_driver);\r\nif (ret)\r\nreturn ret;\r\npr_info("Found %d %s (%d cpu cores) (" VERSION ")\n",\r\nnum_online_nodes(), boot_cpu_data.x86_model_id, supported_cpus);\r\nreturn ret;\r\n}\r\nstatic void __exit powernowk8_exit(void)\r\n{\r\npr_debug("exit\n");\r\ncpufreq_unregister_driver(&cpufreq_amd64_driver);\r\n}
