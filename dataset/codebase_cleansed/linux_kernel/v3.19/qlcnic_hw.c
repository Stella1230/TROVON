static inline u64 readq(void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64) readl(addr + 4)) << 32LL);\r\n}\r\nstatic inline void writeq(u64 val, void __iomem *addr)\r\n{\r\nwritel(((u32) (val)), (addr));\r\nwritel(((u32) (val >> 32)), (addr + 4));\r\n}\r\nstatic void qlcnic_read_window_reg(u32 addr, void __iomem *bar0, u32 *data)\r\n{\r\nu32 dest;\r\nvoid __iomem *val;\r\ndest = addr & 0xFFFF0000;\r\nval = bar0 + QLCNIC_FW_DUMP_REG1;\r\nwritel(dest, val);\r\nreadl(val);\r\nval = bar0 + QLCNIC_FW_DUMP_REG2 + LSW(addr);\r\n*data = readl(val);\r\n}\r\nstatic void qlcnic_write_window_reg(u32 addr, void __iomem *bar0, u32 data)\r\n{\r\nu32 dest;\r\nvoid __iomem *val;\r\ndest = addr & 0xFFFF0000;\r\nval = bar0 + QLCNIC_FW_DUMP_REG1;\r\nwritel(dest, val);\r\nreadl(val);\r\nval = bar0 + QLCNIC_FW_DUMP_REG2 + LSW(addr);\r\nwritel(data, val);\r\nreadl(val);\r\n}\r\nint\r\nqlcnic_pcie_sem_lock(struct qlcnic_adapter *adapter, int sem, u32 id_reg)\r\n{\r\nint timeout = 0, err = 0, done = 0;\r\nwhile (!done) {\r\ndone = QLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_LOCK(sem)),\r\n&err);\r\nif (done == 1)\r\nbreak;\r\nif (++timeout >= QLCNIC_PCIE_SEM_TIMEOUT) {\r\nif (id_reg) {\r\ndone = QLCRD32(adapter, id_reg, &err);\r\nif (done != -1)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to acquire sem=%d lock held by=%d\n",\r\nsem, done);\r\nelse\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to acquire sem=%d lock",\r\nsem);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to acquire sem=%d lock", sem);\r\n}\r\nreturn -EIO;\r\n}\r\nusleep_range(1000, 1500);\r\n}\r\nif (id_reg)\r\nQLCWR32(adapter, id_reg, adapter->portnum);\r\nreturn 0;\r\n}\r\nvoid\r\nqlcnic_pcie_sem_unlock(struct qlcnic_adapter *adapter, int sem)\r\n{\r\nint err = 0;\r\nQLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_UNLOCK(sem)), &err);\r\n}\r\nint qlcnic_ind_rd(struct qlcnic_adapter *adapter, u32 addr)\r\n{\r\nint err = 0;\r\nu32 data;\r\nif (qlcnic_82xx_check(adapter))\r\nqlcnic_read_window_reg(addr, adapter->ahw->pci_base0, &data);\r\nelse {\r\ndata = QLCRD32(adapter, addr, &err);\r\nif (err == -EIO)\r\nreturn err;\r\n}\r\nreturn data;\r\n}\r\nint qlcnic_ind_wr(struct qlcnic_adapter *adapter, u32 addr, u32 data)\r\n{\r\nint ret = 0;\r\nif (qlcnic_82xx_check(adapter))\r\nqlcnic_write_window_reg(addr, adapter->ahw->pci_base0, data);\r\nelse\r\nret = qlcnic_83xx_wrt_reg_indirect(adapter, addr, data);\r\nreturn ret;\r\n}\r\nstatic int\r\nqlcnic_send_cmd_descs(struct qlcnic_adapter *adapter,\r\nstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\r\n{\r\nu32 i, producer;\r\nstruct qlcnic_cmd_buffer *pbuf;\r\nstruct cmd_desc_type0 *cmd_desc;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\ni = 0;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn -EIO;\r\ntx_ring = &adapter->tx_ring[0];\r\n__netif_tx_lock_bh(tx_ring->txq);\r\nproducer = tx_ring->producer;\r\nif (nr_desc >= qlcnic_tx_avail(tx_ring)) {\r\nnetif_tx_stop_queue(tx_ring->txq);\r\nsmp_mb();\r\nif (qlcnic_tx_avail(tx_ring) > nr_desc) {\r\nif (qlcnic_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_tx_wake_queue(tx_ring->txq);\r\n} else {\r\nadapter->stats.xmit_off++;\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndo {\r\ncmd_desc = &cmd_desc_arr[i];\r\npbuf = &tx_ring->cmd_buf_arr[producer];\r\npbuf->skb = NULL;\r\npbuf->frag_count = 0;\r\nmemcpy(&tx_ring->desc_head[producer],\r\ncmd_desc, sizeof(struct cmd_desc_type0));\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\ni++;\r\n} while (i != nr_desc);\r\ntx_ring->producer = producer;\r\nqlcnic_update_cmd_producer(tx_ring);\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_sre_macaddr_change(struct qlcnic_adapter *adapter, u8 *addr,\r\nu16 vlan_id, u8 op)\r\n{\r\nstruct qlcnic_nic_req req;\r\nstruct qlcnic_mac_req *mac_req;\r\nstruct qlcnic_vlan_req *vlan_req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_REQUEST << 23);\r\nword = QLCNIC_MAC_EVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nmac_req = (struct qlcnic_mac_req *)&req.words[0];\r\nmac_req->op = op;\r\nmemcpy(mac_req->mac_addr, addr, ETH_ALEN);\r\nvlan_req = (struct qlcnic_vlan_req *)&req.words[1];\r\nvlan_req->vlan_id = cpu_to_le16(vlan_id);\r\nreturn qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\n}\r\nint qlcnic_nic_del_mac(struct qlcnic_adapter *adapter, const u8 *addr)\r\n{\r\nstruct qlcnic_mac_vlan_list *cur;\r\nstruct list_head *head;\r\nint err = -EINVAL;\r\nlist_for_each(head, &adapter->mac_list) {\r\ncur = list_entry(head, struct qlcnic_mac_vlan_list, list);\r\nif (ether_addr_equal(addr, cur->mac_addr)) {\r\nerr = qlcnic_sre_macaddr_change(adapter, cur->mac_addr,\r\n0, QLCNIC_MAC_DEL);\r\nif (err)\r\nreturn err;\r\nlist_del(&cur->list);\r\nkfree(cur);\r\nreturn err;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_nic_add_mac(struct qlcnic_adapter *adapter, const u8 *addr, u16 vlan)\r\n{\r\nstruct qlcnic_mac_vlan_list *cur;\r\nstruct list_head *head;\r\nlist_for_each(head, &adapter->mac_list) {\r\ncur = list_entry(head, struct qlcnic_mac_vlan_list, list);\r\nif (ether_addr_equal(addr, cur->mac_addr) &&\r\ncur->vlan_id == vlan)\r\nreturn 0;\r\n}\r\ncur = kzalloc(sizeof(*cur), GFP_ATOMIC);\r\nif (cur == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(cur->mac_addr, addr, ETH_ALEN);\r\nif (qlcnic_sre_macaddr_change(adapter,\r\ncur->mac_addr, vlan, QLCNIC_MAC_ADD)) {\r\nkfree(cur);\r\nreturn -EIO;\r\n}\r\ncur->vlan_id = vlan;\r\nlist_add_tail(&cur->list, &adapter->mac_list);\r\nreturn 0;\r\n}\r\nstatic void __qlcnic_set_multi(struct net_device *netdev, u16 vlan)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct netdev_hw_addr *ha;\r\nstatic const u8 bcast_addr[ETH_ALEN] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nu32 mode = VPORT_MISS_MODE_DROP;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn;\r\nqlcnic_nic_add_mac(adapter, adapter->mac_addr, vlan);\r\nqlcnic_nic_add_mac(adapter, bcast_addr, vlan);\r\nif (netdev->flags & IFF_PROMISC) {\r\nif (!(adapter->flags & QLCNIC_PROMISC_DISABLED))\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\n} else if ((netdev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(netdev) > ahw->max_mc_count)) {\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\n} else if (!netdev_mc_empty(netdev)) {\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nqlcnic_nic_add_mac(adapter, ha->addr, vlan);\r\n}\r\nif (netdev_uc_count(netdev) > ahw->max_uc_count) {\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\n} else if (!netdev_uc_empty(netdev)) {\r\nnetdev_for_each_uc_addr(ha, netdev)\r\nqlcnic_nic_add_mac(adapter, ha->addr, vlan);\r\n}\r\nif (mode == VPORT_MISS_MODE_ACCEPT_ALL &&\r\n!adapter->fdb_mac_learn) {\r\nqlcnic_alloc_lb_filters_mem(adapter);\r\nadapter->drv_mac_learn = 1;\r\nif (adapter->flags & QLCNIC_ESWITCH_ENABLED)\r\nadapter->rx_mac_learn = true;\r\n} else {\r\nadapter->drv_mac_learn = 0;\r\nadapter->rx_mac_learn = false;\r\n}\r\nqlcnic_nic_set_promisc(adapter, mode);\r\n}\r\nvoid qlcnic_set_multi(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn;\r\nif (qlcnic_sriov_vf_check(adapter))\r\nqlcnic_sriov_vf_set_multi(netdev);\r\nelse\r\n__qlcnic_set_multi(netdev, 0);\r\n}\r\nint qlcnic_82xx_nic_set_promisc(struct qlcnic_adapter *adapter, u32 mode)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_SET_MAC_RECEIVE_MODE |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(mode);\r\nreturn qlcnic_send_cmd_descs(adapter,\r\n(struct cmd_desc_type0 *)&req, 1);\r\n}\r\nvoid qlcnic_82xx_free_mac_list(struct qlcnic_adapter *adapter)\r\n{\r\nstruct list_head *head = &adapter->mac_list;\r\nstruct qlcnic_mac_vlan_list *cur;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, struct qlcnic_mac_vlan_list, list);\r\nqlcnic_sre_macaddr_change(adapter,\r\ncur->mac_addr, 0, QLCNIC_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nvoid qlcnic_prune_lb_filters(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_filter *tmp_fil;\r\nstruct hlist_node *n;\r\nstruct hlist_head *head;\r\nint i;\r\nunsigned long expires;\r\nu8 cmd;\r\nfor (i = 0; i < adapter->fhash.fbucket_size; i++) {\r\nhead = &(adapter->fhash.fhead[i]);\r\nhlist_for_each_entry_safe(tmp_fil, n, head, fnode) {\r\ncmd = tmp_fil->vlan_id ? QLCNIC_MAC_VLAN_DEL :\r\nQLCNIC_MAC_DEL;\r\nexpires = tmp_fil->ftime + QLCNIC_FILTER_AGE * HZ;\r\nif (time_before(expires, jiffies)) {\r\nqlcnic_sre_macaddr_change(adapter,\r\ntmp_fil->faddr,\r\ntmp_fil->vlan_id,\r\ncmd);\r\nspin_lock_bh(&adapter->mac_learn_lock);\r\nadapter->fhash.fnum--;\r\nhlist_del(&tmp_fil->fnode);\r\nspin_unlock_bh(&adapter->mac_learn_lock);\r\nkfree(tmp_fil);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < adapter->rx_fhash.fbucket_size; i++) {\r\nhead = &(adapter->rx_fhash.fhead[i]);\r\nhlist_for_each_entry_safe(tmp_fil, n, head, fnode)\r\n{\r\nexpires = tmp_fil->ftime + QLCNIC_FILTER_AGE * HZ;\r\nif (time_before(expires, jiffies)) {\r\nspin_lock_bh(&adapter->rx_mac_learn_lock);\r\nadapter->rx_fhash.fnum--;\r\nhlist_del(&tmp_fil->fnode);\r\nspin_unlock_bh(&adapter->rx_mac_learn_lock);\r\nkfree(tmp_fil);\r\n}\r\n}\r\n}\r\n}\r\nvoid qlcnic_delete_lb_filters(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_filter *tmp_fil;\r\nstruct hlist_node *n;\r\nstruct hlist_head *head;\r\nint i;\r\nu8 cmd;\r\nfor (i = 0; i < adapter->fhash.fbucket_size; i++) {\r\nhead = &(adapter->fhash.fhead[i]);\r\nhlist_for_each_entry_safe(tmp_fil, n, head, fnode) {\r\ncmd = tmp_fil->vlan_id ? QLCNIC_MAC_VLAN_DEL :\r\nQLCNIC_MAC_DEL;\r\nqlcnic_sre_macaddr_change(adapter,\r\ntmp_fil->faddr,\r\ntmp_fil->vlan_id,\r\ncmd);\r\nspin_lock_bh(&adapter->mac_learn_lock);\r\nadapter->fhash.fnum--;\r\nhlist_del(&tmp_fil->fnode);\r\nspin_unlock_bh(&adapter->mac_learn_lock);\r\nkfree(tmp_fil);\r\n}\r\n}\r\n}\r\nstatic int qlcnic_set_fw_loopback(struct qlcnic_adapter *adapter, u8 flag)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nreq.req_hdr = cpu_to_le64(QLCNIC_H2C_OPCODE_CONFIG_LOOPBACK |\r\n((u64) adapter->portnum << 16) | ((u64) 0x1 << 32));\r\nreq.words[0] = cpu_to_le64(flag);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->pdev->dev, "%sting loopback mode failed\n",\r\nflag ? "Set" : "Reset");\r\nreturn rv;\r\n}\r\nint qlcnic_82xx_set_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nif (qlcnic_set_fw_loopback(adapter, mode))\r\nreturn -EIO;\r\nif (qlcnic_nic_set_promisc(adapter,\r\nVPORT_MISS_MODE_ACCEPT_ALL)) {\r\nqlcnic_set_fw_loopback(adapter, 0);\r\nreturn -EIO;\r\n}\r\nmsleep(1000);\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_clear_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nmode = VPORT_MISS_MODE_DROP;\r\nqlcnic_set_fw_loopback(adapter, 0);\r\nif (netdev->flags & IFF_PROMISC)\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\nelse if (netdev->flags & IFF_ALLMULTI)\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\nqlcnic_nic_set_promisc(adapter, mode);\r\nmsleep(1000);\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_read_phys_port_id(struct qlcnic_adapter *adapter)\r\n{\r\nu8 mac[ETH_ALEN];\r\nint ret;\r\nret = qlcnic_get_mac_address(adapter, mac,\r\nadapter->ahw->physical_port);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(adapter->ahw->phys_port_id, mac, ETH_ALEN);\r\nadapter->flags |= QLCNIC_HAS_PHYS_PORT_ID;\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_set_rx_coalesce(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nreq.req_hdr = cpu_to_le64(QLCNIC_CONFIG_INTR_COALESCE |\r\n((u64) adapter->portnum << 16));\r\nreq.words[0] = cpu_to_le64(((u64) adapter->ahw->coal.flag) << 32);\r\nreq.words[2] = cpu_to_le64(adapter->ahw->coal.rx_packets |\r\n((u64) adapter->ahw->coal.rx_time_us) << 16);\r\nreq.words[5] = cpu_to_le64(adapter->ahw->coal.timer_out |\r\n((u64) adapter->ahw->coal.type) << 32 |\r\n((u64) adapter->ahw->coal.sts_ring_mask) << 40);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send interrupt coalescing parameters\n");\r\nreturn rv;\r\n}\r\nint qlcnic_82xx_config_intr_coalesce(struct qlcnic_adapter *adapter,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\r\nint rv;\r\ncoal->flag = QLCNIC_INTR_DEFAULT;\r\ncoal->rx_time_us = ethcoal->rx_coalesce_usecs;\r\ncoal->rx_packets = ethcoal->rx_max_coalesced_frames;\r\nrv = qlcnic_82xx_set_rx_coalesce(adapter);\r\nif (rv)\r\nnetdev_err(adapter->netdev,\r\n"Failed to set Rx coalescing parametrs\n");\r\nreturn rv;\r\n}\r\nint qlcnic_82xx_config_hw_lro(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nword = 0;\r\nif (enable) {\r\nword = QLCNIC_ENABLE_IPV4_LRO;\r\nif (adapter->ahw->extra_capability[0] &\r\nQLCNIC_FW_CAP2_HW_LRO_IPV6)\r\nword |= QLCNIC_ENABLE_IPV6_LRO;\r\n}\r\nreq.words[0] = cpu_to_le64(word);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send configure hw lro request\n");\r\nreturn rv;\r\n}\r\nint qlcnic_config_bridged_mode(struct qlcnic_adapter *adapter, u32 enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!!(adapter->flags & QLCNIC_BRIDGE_ENABLED) == enable)\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_BRIDGING |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send configure bridge mode request\n");\r\nadapter->flags ^= QLCNIC_BRIDGE_ENABLED;\r\nreturn rv;\r\n}\r\nint qlcnic_82xx_config_rss(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint i, rv;\r\nstatic const u64 key[] = {\r\n0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\r\n0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\r\n0x255b0ec26d5a56daULL\r\n};\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nword = ((u64)(QLCNIC_RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\r\n((u64)(QLCNIC_RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\r\n((u64)(enable & 0x1) << 8) |\r\n((u64)QLCNIC_RSS_IND_TABLE_MASK << 48) |\r\n(u64)QLCNIC_ENABLE_TYPE_C_RSS |\r\n(u64)QLCNIC_RSS_FEATURE_FLAG;\r\nreq.words[0] = cpu_to_le64(word);\r\nfor (i = 0; i < 5; i++)\r\nreq.words[i+1] = cpu_to_le64(key[i]);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev, "could not configure RSS\n");\r\nreturn rv;\r\n}\r\nvoid qlcnic_82xx_config_ipaddr(struct qlcnic_adapter *adapter,\r\n__be32 ip, int cmd)\r\n{\r\nstruct qlcnic_nic_req req;\r\nstruct qlcnic_ipaddr *ipa;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(cmd);\r\nipa = (struct qlcnic_ipaddr *)&req.words[1];\r\nipa->ipv4 = ip;\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not notify %s IP 0x%x request\n",\r\n(cmd == QLCNIC_IP_UP) ? "Add" : "Remove", ip);\r\n}\r\nint qlcnic_82xx_linkevent_request(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable | (enable << 8));\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not configure link notification\n");\r\nreturn rv;\r\n}\r\nstatic int qlcnic_send_lro_cleanup(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_LRO_REQUEST |\r\n((u64)adapter->portnum << 16) |\r\n((u64)QLCNIC_LRO_REQUEST_CLEANUP << 56) ;\r\nreq.req_hdr = cpu_to_le64(word);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not cleanup lro flows\n");\r\nreturn rv;\r\n}\r\nint qlcnic_change_mtu(struct net_device *netdev, int mtu)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint rc = 0;\r\nif (mtu < P3P_MIN_MTU || mtu > P3P_MAX_MTU) {\r\ndev_err(&adapter->netdev->dev, "%d bytes < mtu < %d bytes"\r\n" not supported\n", P3P_MAX_MTU, P3P_MIN_MTU);\r\nreturn -EINVAL;\r\n}\r\nrc = qlcnic_fw_cmd_set_mtu(adapter, mtu);\r\nif (!rc)\r\nnetdev->mtu = mtu;\r\nreturn rc;\r\n}\r\nstatic netdev_features_t qlcnic_process_flags(struct qlcnic_adapter *adapter,\r\nnetdev_features_t features)\r\n{\r\nu32 offload_flags = adapter->offload_flags;\r\nif (offload_flags & BIT_0) {\r\nfeatures |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM;\r\nadapter->rx_csum = 1;\r\nif (QLCNIC_IS_TSO_CAPABLE(adapter)) {\r\nif (!(offload_flags & BIT_1))\r\nfeatures &= ~NETIF_F_TSO;\r\nelse\r\nfeatures |= NETIF_F_TSO;\r\nif (!(offload_flags & BIT_2))\r\nfeatures &= ~NETIF_F_TSO6;\r\nelse\r\nfeatures |= NETIF_F_TSO6;\r\n}\r\n} else {\r\nfeatures &= ~(NETIF_F_RXCSUM |\r\nNETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM);\r\nif (QLCNIC_IS_TSO_CAPABLE(adapter))\r\nfeatures &= ~(NETIF_F_TSO | NETIF_F_TSO6);\r\nadapter->rx_csum = 0;\r\n}\r\nreturn features;\r\n}\r\nnetdev_features_t qlcnic_fix_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nnetdev_features_t changed;\r\nif (qlcnic_82xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_ESWITCH_ENABLED)) {\r\nif (adapter->flags & QLCNIC_APP_CHANGED_FLAGS) {\r\nfeatures = qlcnic_process_flags(adapter, features);\r\n} else {\r\nchanged = features ^ netdev->features;\r\nfeatures ^= changed & (NETIF_F_RXCSUM |\r\nNETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6);\r\n}\r\n}\r\nif (!(features & NETIF_F_RXCSUM))\r\nfeatures &= ~NETIF_F_LRO;\r\nreturn features;\r\n}\r\nint qlcnic_set_features(struct net_device *netdev, netdev_features_t features)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nnetdev_features_t changed = netdev->features ^ features;\r\nint hw_lro = (features & NETIF_F_LRO) ? QLCNIC_LRO_ENABLED : 0;\r\nif (!(changed & NETIF_F_LRO))\r\nreturn 0;\r\nnetdev->features ^= NETIF_F_LRO;\r\nif (qlcnic_config_hw_lro(adapter, hw_lro))\r\nreturn -EIO;\r\nif (!hw_lro && qlcnic_82xx_check(adapter)) {\r\nif (qlcnic_send_lro_cleanup(adapter))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_pci_get_crb_addr_2M(struct qlcnic_hardware_context *ahw,\r\nulong off, void __iomem **addr)\r\n{\r\nconst struct crb_128M_2M_sub_block_map *m;\r\nif ((off >= QLCNIC_CRB_MAX) || (off < QLCNIC_PCI_CRBSPACE))\r\nreturn -EINVAL;\r\noff -= QLCNIC_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\r\nif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\r\n*addr = ahw->pci_base0 + m->start_2M +\r\n(off - m->start_128M);\r\nreturn 0;\r\n}\r\n*addr = ahw->pci_base0 + CRB_INDIRECT_2M + (off & MASK(16));\r\nreturn 1;\r\n}\r\nstatic int\r\nqlcnic_pci_set_crbwindow_2M(struct qlcnic_adapter *adapter, ulong off)\r\n{\r\nu32 window;\r\nvoid __iomem *addr = adapter->ahw->pci_base0 + CRB_WINDOW_2M;\r\noff -= QLCNIC_PCI_CRBSPACE;\r\nwindow = CRB_HI(off);\r\nif (window == 0) {\r\ndev_err(&adapter->pdev->dev, "Invalid offset 0x%lx\n", off);\r\nreturn -EIO;\r\n}\r\nwritel(window, addr);\r\nif (readl(addr) != window) {\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d off 0x%lx\n",\r\nwindow, off);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_hw_write_wx_2M(struct qlcnic_adapter *adapter, ulong off,\r\nu32 data)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nvoid __iomem *addr = NULL;\r\nrv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, &addr);\r\nif (rv == 0) {\r\nwritel(data, addr);\r\nreturn 0;\r\n}\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nrv = qlcnic_pci_set_crbwindow_2M(adapter, off);\r\nif (!rv)\r\nwritel(data, addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\r\nreturn rv;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -EIO;\r\n}\r\nint qlcnic_82xx_hw_read_wx_2M(struct qlcnic_adapter *adapter, ulong off,\r\nint *err)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nu32 data = -1;\r\nvoid __iomem *addr = NULL;\r\nrv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, &addr);\r\nif (rv == 0)\r\nreturn readl(addr);\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nif (!qlcnic_pci_set_crbwindow_2M(adapter, off))\r\ndata = readl(addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\r\nreturn data;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -1;\r\n}\r\nvoid __iomem *qlcnic_get_ioaddr(struct qlcnic_hardware_context *ahw,\r\nu32 offset)\r\n{\r\nvoid __iomem *addr = NULL;\r\nWARN_ON(qlcnic_pci_get_crb_addr_2M(ahw, offset, &addr));\r\nreturn addr;\r\n}\r\nstatic int qlcnic_pci_mem_access_direct(struct qlcnic_adapter *adapter,\r\nu32 window, u64 off, u64 *data, int op)\r\n{\r\nvoid __iomem *addr;\r\nu32 start;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwritel(window, adapter->ahw->ocm_win_crb);\r\nreadl(adapter->ahw->ocm_win_crb);\r\nstart = QLCNIC_PCI_OCM0_2M + off;\r\naddr = adapter->ahw->pci_base0 + start;\r\nif (op == 0)\r\n*data = readq(addr);\r\nelse\r\nwriteq(*data, addr);\r\nwritel(0, adapter->ahw->ocm_win_crb);\r\nreadl(adapter->ahw->ocm_win_crb);\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_pci_camqm_read_2M(struct qlcnic_adapter *adapter, u64 off, u64 *data)\r\n{\r\nvoid __iomem *addr = adapter->ahw->pci_base0 +\r\nQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\r\nmutex_lock(&adapter->ahw->mem_lock);\r\n*data = readq(addr);\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\n}\r\nstatic void\r\nqlcnic_pci_camqm_write_2M(struct qlcnic_adapter *adapter, u64 off, u64 data)\r\n{\r\nvoid __iomem *addr = adapter->ahw->pci_base0 +\r\nQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwriteq(data, addr);\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\n}\r\nstatic void qlcnic_set_ms_controls(struct qlcnic_adapter *adapter, u64 off,\r\nstruct qlcnic_ms_reg_ctrl *ms)\r\n{\r\nms->control = QLCNIC_MS_CTRL;\r\nms->low = QLCNIC_MS_ADDR_LO;\r\nms->hi = QLCNIC_MS_ADDR_HI;\r\nif (off & 0xf) {\r\nms->wd[0] = QLCNIC_MS_WRTDATA_LO;\r\nms->rd[0] = QLCNIC_MS_RDDATA_LO;\r\nms->wd[1] = QLCNIC_MS_WRTDATA_HI;\r\nms->rd[1] = QLCNIC_MS_RDDATA_HI;\r\nms->wd[2] = QLCNIC_MS_WRTDATA_ULO;\r\nms->wd[3] = QLCNIC_MS_WRTDATA_UHI;\r\nms->rd[2] = QLCNIC_MS_RDDATA_ULO;\r\nms->rd[3] = QLCNIC_MS_RDDATA_UHI;\r\n} else {\r\nms->wd[0] = QLCNIC_MS_WRTDATA_ULO;\r\nms->rd[0] = QLCNIC_MS_RDDATA_ULO;\r\nms->wd[1] = QLCNIC_MS_WRTDATA_UHI;\r\nms->rd[1] = QLCNIC_MS_RDDATA_UHI;\r\nms->wd[2] = QLCNIC_MS_WRTDATA_LO;\r\nms->wd[3] = QLCNIC_MS_WRTDATA_HI;\r\nms->rd[2] = QLCNIC_MS_RDDATA_LO;\r\nms->rd[3] = QLCNIC_MS_RDDATA_HI;\r\n}\r\nms->ocm_window = OCM_WIN_P3P(off);\r\nms->off = GET_MEM_OFFS_2M(off);\r\n}\r\nint qlcnic_pci_mem_write_2M(struct qlcnic_adapter *adapter, u64 off, u64 data)\r\n{\r\nint j, ret = 0;\r\nu32 temp, off8;\r\nstruct qlcnic_ms_reg_ctrl ms;\r\nif (off & 7)\r\nreturn -EIO;\r\nmemset(&ms, 0, sizeof(struct qlcnic_ms_reg_ctrl));\r\nif (!(ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\r\nQLCNIC_ADDR_QDR_NET_MAX) ||\r\nADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET,\r\nQLCNIC_ADDR_DDR_NET_MAX)))\r\nreturn -EIO;\r\nqlcnic_set_ms_controls(adapter, off, &ms);\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX))\r\nreturn qlcnic_pci_mem_access_direct(adapter, ms.ocm_window,\r\nms.off, &data, 1);\r\noff8 = off & ~0xf;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nqlcnic_ind_wr(adapter, ms.low, off8);\r\nqlcnic_ind_wr(adapter, ms.hi, 0);\r\nqlcnic_ind_wr(adapter, ms.control, TA_CTL_ENABLE);\r\nqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_START_ENABLE);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qlcnic_ind_rd(adapter, ms.control);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nqlcnic_ind_wr(adapter, ms.wd[0], qlcnic_ind_rd(adapter, ms.rd[0]));\r\nqlcnic_ind_wr(adapter, ms.wd[1], qlcnic_ind_rd(adapter, ms.rd[1]));\r\nqlcnic_ind_wr(adapter, ms.wd[2], data & 0xffffffff);\r\nqlcnic_ind_wr(adapter, ms.wd[3], (data >> 32) & 0xffffffff);\r\nqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_WRITE_ENABLE);\r\nqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_WRITE_START);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qlcnic_ind_rd(adapter, ms.control);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\ndone:\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nint qlcnic_pci_mem_read_2M(struct qlcnic_adapter *adapter, u64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nu64 val;\r\nstruct qlcnic_ms_reg_ctrl ms;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (!(ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\r\nQLCNIC_ADDR_QDR_NET_MAX) ||\r\nADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET,\r\nQLCNIC_ADDR_DDR_NET_MAX)))\r\nreturn -EIO;\r\nmemset(&ms, 0, sizeof(struct qlcnic_ms_reg_ctrl));\r\nqlcnic_set_ms_controls(adapter, off, &ms);\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX))\r\nreturn qlcnic_pci_mem_access_direct(adapter, ms.ocm_window,\r\nms.off, data, 0);\r\nmutex_lock(&adapter->ahw->mem_lock);\r\noff8 = off & ~0xf;\r\nqlcnic_ind_wr(adapter, ms.low, off8);\r\nqlcnic_ind_wr(adapter, ms.hi, 0);\r\nqlcnic_ind_wr(adapter, ms.control, TA_CTL_ENABLE);\r\nqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_START_ENABLE);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qlcnic_ind_rd(adapter, ms.control);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\ntemp = qlcnic_ind_rd(adapter, ms.rd[3]);\r\nval = (u64)temp << 32;\r\nval |= qlcnic_ind_rd(adapter, ms.rd[2]);\r\n*data = val;\r\nret = 0;\r\n}\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nint qlcnic_82xx_get_board_info(struct qlcnic_adapter *adapter)\r\n{\r\nint offset, board_type, magic, err = 0;\r\nstruct pci_dev *pdev = adapter->pdev;\r\noffset = QLCNIC_FW_MAGIC_OFFSET;\r\nif (qlcnic_rom_fast_read(adapter, offset, &magic))\r\nreturn -EIO;\r\nif (magic != QLCNIC_BDINFO_MAGIC) {\r\ndev_err(&pdev->dev, "invalid board config, magic=%08x\n",\r\nmagic);\r\nreturn -EIO;\r\n}\r\noffset = QLCNIC_BRDTYPE_OFFSET;\r\nif (qlcnic_rom_fast_read(adapter, offset, &board_type))\r\nreturn -EIO;\r\nadapter->ahw->board_type = board_type;\r\nif (board_type == QLCNIC_BRDTYPE_P3P_4_GB_MM) {\r\nu32 gpio = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_PAD_GPIO_I, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif ((gpio & 0x8000) == 0)\r\nboard_type = QLCNIC_BRDTYPE_P3P_10G_TP;\r\n}\r\nswitch (board_type) {\r\ncase QLCNIC_BRDTYPE_P3P_HMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_XG_LOM:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\r\ncase QLCNIC_BRDTYPE_P3P_IMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_XFP:\r\ncase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\r\nadapter->ahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_REF_QG:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB_MM:\r\nadapter->ahw->port_type = QLCNIC_GBE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_TP:\r\nadapter->ahw->port_type = (adapter->portnum < 2) ?\r\nQLCNIC_XGBE : QLCNIC_GBE;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unknown board type %x\n", board_type);\r\nadapter->ahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_wol_supported(struct qlcnic_adapter *adapter)\r\n{\r\nu32 wol_cfg;\r\nint err = 0;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\r\nif (wol_cfg & (1UL << adapter->portnum)) {\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (wol_cfg & (1 << adapter->portnum))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_config_led(struct qlcnic_adapter *adapter, u32 state, u32 rate)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_LED | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(((u64)rate << 32) | adapter->portnum);\r\nreq.words[1] = cpu_to_le64(state);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv)\r\ndev_err(&adapter->pdev->dev, "LED configuration failed.\n");\r\nreturn rv;\r\n}\r\nvoid qlcnic_82xx_get_beacon_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 beacon_state;\r\nint err = 0;\r\nif (ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_2_BEACON) {\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_GET_LED_STATUS);\r\nif (!err) {\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to get current beacon state, err=%d\n",\r\nerr);\r\n} else {\r\nbeacon_state = cmd.rsp.arg[1];\r\nif (beacon_state == QLCNIC_BEACON_DISABLE)\r\nahw->beacon_state = QLCNIC_BEACON_OFF;\r\nelse if (beacon_state == QLCNIC_BEACON_EANBLE)\r\nahw->beacon_state = QLCNIC_BEACON_ON;\r\n}\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nreturn;\r\n}\r\nvoid qlcnic_82xx_get_func_no(struct qlcnic_adapter *adapter)\r\n{\r\nvoid __iomem *msix_base_addr;\r\nu32 func;\r\nu32 msix_base;\r\npci_read_config_dword(adapter->pdev, QLCNIC_MSIX_TABLE_OFFSET, &func);\r\nmsix_base_addr = adapter->ahw->pci_base0 + QLCNIC_MSIX_BASE;\r\nmsix_base = readl(msix_base_addr);\r\nfunc = (func - msix_base) / QLCNIC_MSIX_TBL_PGSIZE;\r\nadapter->ahw->pci_func = func;\r\n}\r\nvoid qlcnic_82xx_read_crb(struct qlcnic_adapter *adapter, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nint err = 0;\r\nu32 data;\r\nu64 qmdata;\r\nif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM, QLCNIC_PCI_CAMQM_END)) {\r\nqlcnic_pci_camqm_read_2M(adapter, offset, &qmdata);\r\nmemcpy(buf, &qmdata, size);\r\n} else {\r\ndata = QLCRD32(adapter, offset, &err);\r\nmemcpy(buf, &data, size);\r\n}\r\n}\r\nvoid qlcnic_82xx_write_crb(struct qlcnic_adapter *adapter, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nu32 data;\r\nu64 qmdata;\r\nif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM, QLCNIC_PCI_CAMQM_END)) {\r\nmemcpy(&qmdata, buf, size);\r\nqlcnic_pci_camqm_write_2M(adapter, offset, qmdata);\r\n} else {\r\nmemcpy(&data, buf, size);\r\nQLCWR32(adapter, offset, data);\r\n}\r\n}\r\nint qlcnic_82xx_api_lock(struct qlcnic_adapter *adapter)\r\n{\r\nreturn qlcnic_pcie_sem_lock(adapter, 5, 0);\r\n}\r\nvoid qlcnic_82xx_api_unlock(struct qlcnic_adapter *adapter)\r\n{\r\nqlcnic_pcie_sem_unlock(adapter, 5);\r\n}\r\nint qlcnic_82xx_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = adapter->netdev;\r\nint retval;\r\nnetif_device_detach(netdev);\r\nqlcnic_cancel_idc_work(adapter);\r\nif (netif_running(netdev))\r\nqlcnic_down(adapter, netdev);\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nretval = pci_save_state(pdev);\r\nif (retval)\r\nreturn retval;\r\nif (qlcnic_wol_supported(adapter)) {\r\npci_enable_wake(pdev, PCI_D3cold, 1);\r\npci_enable_wake(pdev, PCI_D3hot, 1);\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_resume(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nerr = qlcnic_start_firmware(adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev, "failed to start firmware\n");\r\nreturn err;\r\n}\r\nif (netif_running(netdev)) {\r\nerr = qlcnic_up(adapter, netdev);\r\nif (!err)\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\nnetif_device_attach(netdev);\r\nqlcnic_schedule_work(adapter, qlcnic_fw_poll_work, FW_POLL_DELAY);\r\nreturn err;\r\n}
