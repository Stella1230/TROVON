u8 cpci_get_attention_status(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nreturn hs_csr & 0x0008 ? 1 : 0;\r\n}\r\nint cpci_set_attention_status(struct slot *slot, int status)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (status)\r\nhs_csr |= HS_CSR_LOO;\r\nelse\r\nhs_csr &= ~HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nu16 cpci_get_hs_csr(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0xFFFF;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0xFFFF;\r\nreturn hs_csr;\r\n}\r\nint cpci_check_and_clear_ins(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nint ins = 0;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (hs_csr & HS_CSR_INS) {\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nins = 0;\r\nelse\r\nins = 1;\r\n}\r\nreturn ins;\r\n}\r\nint cpci_check_ext(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nint ext = 0;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (hs_csr & HS_CSR_EXT)\r\next = 1;\r\nreturn ext;\r\n}\r\nint cpci_clear_ext(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif (hs_csr & HS_CSR_EXT) {\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint cpci_led_on(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif ((hs_csr & HS_CSR_LOO) != HS_CSR_LOO) {\r\nhs_csr |= HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr)) {\r\nerr("Could not set LOO for slot %s",\r\nhotplug_slot_name(slot->hotplug_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpci_led_off(struct slot *slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif (hs_csr & HS_CSR_LOO) {\r\nhs_csr &= ~HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr)) {\r\nerr("Could not clear LOO for slot %s",\r\nhotplug_slot_name(slot->hotplug_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpci_configure_slot(struct slot *slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *parent;\r\nint ret = 0;\r\ndbg("%s - enter", __func__);\r\npci_lock_rescan_remove();\r\nif (slot->dev == NULL) {\r\ndbg("pci_dev null, finding %02x:%02x:%x",\r\nslot->bus->number, PCI_SLOT(slot->devfn), PCI_FUNC(slot->devfn));\r\nslot->dev = pci_get_slot(slot->bus, slot->devfn);\r\n}\r\nif (slot->dev == NULL) {\r\nint n;\r\ndbg("pci_dev still null");\r\nn = pci_scan_slot(slot->bus, slot->devfn);\r\ndbg("%s: pci_scan_slot returned %d", __func__, n);\r\nslot->dev = pci_get_slot(slot->bus, slot->devfn);\r\nif (slot->dev == NULL) {\r\nerr("Could not find PCI device for slot %02x", slot->number);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nparent = slot->dev->bus;\r\nlist_for_each_entry(dev, &parent->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) != PCI_SLOT(slot->devfn))\r\ncontinue;\r\nif (pci_is_bridge(dev))\r\npci_hp_add_bridge(dev);\r\npci_assign_unassigned_bridge_resources(parent->self);\r\npci_bus_add_devices(parent);\r\nout:\r\npci_unlock_rescan_remove();\r\ndbg("%s - exit", __func__);\r\nreturn ret;\r\n}\r\nint cpci_unconfigure_slot(struct slot *slot)\r\n{\r\nstruct pci_dev *dev, *temp;\r\ndbg("%s - enter", __func__);\r\nif (!slot->dev) {\r\nerr("No device for slot %02x\n", slot->number);\r\nreturn -ENODEV;\r\n}\r\npci_lock_rescan_remove();\r\nlist_for_each_entry_safe(dev, temp, &slot->bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != PCI_SLOT(slot->devfn))\r\ncontinue;\r\npci_dev_get(dev);\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\npci_dev_put(slot->dev);\r\nslot->dev = NULL;\r\npci_unlock_rescan_remove();\r\ndbg("%s - exit", __func__);\r\nreturn 0;\r\n}
