void ttm_lock_init(struct ttm_lock *lock)\r\n{\r\nspin_lock_init(&lock->lock);\r\ninit_waitqueue_head(&lock->queue);\r\nlock->rw = 0;\r\nlock->flags = 0;\r\nlock->kill_takers = false;\r\nlock->signal = SIGKILL;\r\n}\r\nvoid ttm_read_unlock(struct ttm_lock *lock)\r\n{\r\nspin_lock(&lock->lock);\r\nif (--lock->rw == 0)\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\n}\r\nstatic bool __ttm_read_lock(struct ttm_lock *lock)\r\n{\r\nbool locked = false;\r\nspin_lock(&lock->lock);\r\nif (unlikely(lock->kill_takers)) {\r\nsend_sig(lock->signal, current, 0);\r\nspin_unlock(&lock->lock);\r\nreturn false;\r\n}\r\nif (lock->rw >= 0 && lock->flags == 0) {\r\n++lock->rw;\r\nlocked = true;\r\n}\r\nspin_unlock(&lock->lock);\r\nreturn locked;\r\n}\r\nint ttm_read_lock(struct ttm_lock *lock, bool interruptible)\r\n{\r\nint ret = 0;\r\nif (interruptible)\r\nret = wait_event_interruptible(lock->queue,\r\n__ttm_read_lock(lock));\r\nelse\r\nwait_event(lock->queue, __ttm_read_lock(lock));\r\nreturn ret;\r\n}\r\nstatic bool __ttm_read_trylock(struct ttm_lock *lock, bool *locked)\r\n{\r\nbool block = true;\r\n*locked = false;\r\nspin_lock(&lock->lock);\r\nif (unlikely(lock->kill_takers)) {\r\nsend_sig(lock->signal, current, 0);\r\nspin_unlock(&lock->lock);\r\nreturn false;\r\n}\r\nif (lock->rw >= 0 && lock->flags == 0) {\r\n++lock->rw;\r\nblock = false;\r\n*locked = true;\r\n} else if (lock->flags == 0) {\r\nblock = false;\r\n}\r\nspin_unlock(&lock->lock);\r\nreturn !block;\r\n}\r\nint ttm_read_trylock(struct ttm_lock *lock, bool interruptible)\r\n{\r\nint ret = 0;\r\nbool locked;\r\nif (interruptible)\r\nret = wait_event_interruptible\r\n(lock->queue, __ttm_read_trylock(lock, &locked));\r\nelse\r\nwait_event(lock->queue, __ttm_read_trylock(lock, &locked));\r\nif (unlikely(ret != 0)) {\r\nBUG_ON(locked);\r\nreturn ret;\r\n}\r\nreturn (locked) ? 0 : -EBUSY;\r\n}\r\nvoid ttm_write_unlock(struct ttm_lock *lock)\r\n{\r\nspin_lock(&lock->lock);\r\nlock->rw = 0;\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\n}\r\nstatic bool __ttm_write_lock(struct ttm_lock *lock)\r\n{\r\nbool locked = false;\r\nspin_lock(&lock->lock);\r\nif (unlikely(lock->kill_takers)) {\r\nsend_sig(lock->signal, current, 0);\r\nspin_unlock(&lock->lock);\r\nreturn false;\r\n}\r\nif (lock->rw == 0 && ((lock->flags & ~TTM_WRITE_LOCK_PENDING) == 0)) {\r\nlock->rw = -1;\r\nlock->flags &= ~TTM_WRITE_LOCK_PENDING;\r\nlocked = true;\r\n} else {\r\nlock->flags |= TTM_WRITE_LOCK_PENDING;\r\n}\r\nspin_unlock(&lock->lock);\r\nreturn locked;\r\n}\r\nint ttm_write_lock(struct ttm_lock *lock, bool interruptible)\r\n{\r\nint ret = 0;\r\nif (interruptible) {\r\nret = wait_event_interruptible(lock->queue,\r\n__ttm_write_lock(lock));\r\nif (unlikely(ret != 0)) {\r\nspin_lock(&lock->lock);\r\nlock->flags &= ~TTM_WRITE_LOCK_PENDING;\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\n}\r\n} else\r\nwait_event(lock->queue, __ttm_read_lock(lock));\r\nreturn ret;\r\n}\r\nstatic int __ttm_vt_unlock(struct ttm_lock *lock)\r\n{\r\nint ret = 0;\r\nspin_lock(&lock->lock);\r\nif (unlikely(!(lock->flags & TTM_VT_LOCK)))\r\nret = -EINVAL;\r\nlock->flags &= ~TTM_VT_LOCK;\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\nreturn ret;\r\n}\r\nstatic void ttm_vt_lock_remove(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct ttm_lock *lock = container_of(base, struct ttm_lock, base);\r\nint ret;\r\n*p_base = NULL;\r\nret = __ttm_vt_unlock(lock);\r\nBUG_ON(ret != 0);\r\n}\r\nstatic bool __ttm_vt_lock(struct ttm_lock *lock)\r\n{\r\nbool locked = false;\r\nspin_lock(&lock->lock);\r\nif (lock->rw == 0) {\r\nlock->flags &= ~TTM_VT_LOCK_PENDING;\r\nlock->flags |= TTM_VT_LOCK;\r\nlocked = true;\r\n} else {\r\nlock->flags |= TTM_VT_LOCK_PENDING;\r\n}\r\nspin_unlock(&lock->lock);\r\nreturn locked;\r\n}\r\nint ttm_vt_lock(struct ttm_lock *lock,\r\nbool interruptible,\r\nstruct ttm_object_file *tfile)\r\n{\r\nint ret = 0;\r\nif (interruptible) {\r\nret = wait_event_interruptible(lock->queue,\r\n__ttm_vt_lock(lock));\r\nif (unlikely(ret != 0)) {\r\nspin_lock(&lock->lock);\r\nlock->flags &= ~TTM_VT_LOCK_PENDING;\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\nreturn ret;\r\n}\r\n} else\r\nwait_event(lock->queue, __ttm_vt_lock(lock));\r\nret = ttm_base_object_init(tfile, &lock->base, false,\r\nttm_lock_type, &ttm_vt_lock_remove, NULL);\r\nif (ret)\r\n(void)__ttm_vt_unlock(lock);\r\nelse\r\nlock->vt_holder = tfile;\r\nreturn ret;\r\n}\r\nint ttm_vt_unlock(struct ttm_lock *lock)\r\n{\r\nreturn ttm_ref_object_base_unref(lock->vt_holder,\r\nlock->base.hash.key, TTM_REF_USAGE);\r\n}\r\nvoid ttm_suspend_unlock(struct ttm_lock *lock)\r\n{\r\nspin_lock(&lock->lock);\r\nlock->flags &= ~TTM_SUSPEND_LOCK;\r\nwake_up_all(&lock->queue);\r\nspin_unlock(&lock->lock);\r\n}\r\nstatic bool __ttm_suspend_lock(struct ttm_lock *lock)\r\n{\r\nbool locked = false;\r\nspin_lock(&lock->lock);\r\nif (lock->rw == 0) {\r\nlock->flags &= ~TTM_SUSPEND_LOCK_PENDING;\r\nlock->flags |= TTM_SUSPEND_LOCK;\r\nlocked = true;\r\n} else {\r\nlock->flags |= TTM_SUSPEND_LOCK_PENDING;\r\n}\r\nspin_unlock(&lock->lock);\r\nreturn locked;\r\n}\r\nvoid ttm_suspend_lock(struct ttm_lock *lock)\r\n{\r\nwait_event(lock->queue, __ttm_suspend_lock(lock));\r\n}
