int ovl_copy_xattr(struct dentry *old, struct dentry *new)\r\n{\r\nssize_t list_size, size;\r\nchar *buf, *name, *value;\r\nint error;\r\nif (!old->d_inode->i_op->getxattr ||\r\n!new->d_inode->i_op->getxattr)\r\nreturn 0;\r\nlist_size = vfs_listxattr(old, NULL, 0);\r\nif (list_size <= 0) {\r\nif (list_size == -EOPNOTSUPP)\r\nreturn 0;\r\nreturn list_size;\r\n}\r\nbuf = kzalloc(list_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerror = -ENOMEM;\r\nvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\r\nif (!value)\r\ngoto out;\r\nlist_size = vfs_listxattr(old, buf, list_size);\r\nif (list_size <= 0) {\r\nerror = list_size;\r\ngoto out_free_value;\r\n}\r\nfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\r\nsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\r\nif (size <= 0) {\r\nerror = size;\r\ngoto out_free_value;\r\n}\r\nerror = vfs_setxattr(new, name, value, size, 0);\r\nif (error)\r\ngoto out_free_value;\r\n}\r\nout_free_value:\r\nkfree(value);\r\nout:\r\nkfree(buf);\r\nreturn error;\r\n}\r\nstatic int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\r\n{\r\nstruct file *old_file;\r\nstruct file *new_file;\r\nloff_t old_pos = 0;\r\nloff_t new_pos = 0;\r\nint error = 0;\r\nif (len == 0)\r\nreturn 0;\r\nold_file = ovl_path_open(old, O_RDONLY);\r\nif (IS_ERR(old_file))\r\nreturn PTR_ERR(old_file);\r\nnew_file = ovl_path_open(new, O_WRONLY);\r\nif (IS_ERR(new_file)) {\r\nerror = PTR_ERR(new_file);\r\ngoto out_fput;\r\n}\r\nwhile (len) {\r\nsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\r\nlong bytes;\r\nif (len < this_len)\r\nthis_len = len;\r\nif (signal_pending_state(TASK_KILLABLE, current)) {\r\nerror = -EINTR;\r\nbreak;\r\n}\r\nbytes = do_splice_direct(old_file, &old_pos,\r\nnew_file, &new_pos,\r\nthis_len, SPLICE_F_MOVE);\r\nif (bytes <= 0) {\r\nerror = bytes;\r\nbreak;\r\n}\r\nWARN_ON(old_pos != new_pos);\r\nlen -= bytes;\r\n}\r\nfput(new_file);\r\nout_fput:\r\nfput(old_file);\r\nreturn error;\r\n}\r\nstatic char *ovl_read_symlink(struct dentry *realdentry)\r\n{\r\nint res;\r\nchar *buf;\r\nstruct inode *inode = realdentry->d_inode;\r\nmm_segment_t old_fs;\r\nres = -EINVAL;\r\nif (!inode->i_op->readlink)\r\ngoto err;\r\nres = -ENOMEM;\r\nbuf = (char *) __get_free_page(GFP_KERNEL);\r\nif (!buf)\r\ngoto err;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nres = inode->i_op->readlink(realdentry,\r\n(char __user *)buf, PAGE_SIZE - 1);\r\nset_fs(old_fs);\r\nif (res < 0) {\r\nfree_page((unsigned long) buf);\r\ngoto err;\r\n}\r\nbuf[res] = '\0';\r\nreturn buf;\r\nerr:\r\nreturn ERR_PTR(res);\r\n}\r\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\r\n{\r\nstruct iattr attr = {\r\n.ia_valid =\r\nATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\r\n.ia_atime = stat->atime,\r\n.ia_mtime = stat->mtime,\r\n};\r\nreturn notify_change(upperdentry, &attr, NULL);\r\n}\r\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\r\n{\r\nint err = 0;\r\nif (!S_ISLNK(stat->mode)) {\r\nstruct iattr attr = {\r\n.ia_valid = ATTR_MODE,\r\n.ia_mode = stat->mode,\r\n};\r\nerr = notify_change(upperdentry, &attr, NULL);\r\n}\r\nif (!err) {\r\nstruct iattr attr = {\r\n.ia_valid = ATTR_UID | ATTR_GID,\r\n.ia_uid = stat->uid,\r\n.ia_gid = stat->gid,\r\n};\r\nerr = notify_change(upperdentry, &attr, NULL);\r\n}\r\nif (!err)\r\novl_set_timestamps(upperdentry, stat);\r\nreturn err;\r\n}\r\nstatic int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\r\nstruct dentry *dentry, struct path *lowerpath,\r\nstruct kstat *stat, struct iattr *attr,\r\nconst char *link)\r\n{\r\nstruct inode *wdir = workdir->d_inode;\r\nstruct inode *udir = upperdir->d_inode;\r\nstruct dentry *newdentry = NULL;\r\nstruct dentry *upper = NULL;\r\numode_t mode = stat->mode;\r\nint err;\r\nnewdentry = ovl_lookup_temp(workdir, dentry);\r\nerr = PTR_ERR(newdentry);\r\nif (IS_ERR(newdentry))\r\ngoto out;\r\nupper = lookup_one_len(dentry->d_name.name, upperdir,\r\ndentry->d_name.len);\r\nerr = PTR_ERR(upper);\r\nif (IS_ERR(upper))\r\ngoto out1;\r\nstat->mode &= S_IFMT;\r\nerr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\r\nstat->mode = mode;\r\nif (err)\r\ngoto out2;\r\nif (S_ISREG(stat->mode)) {\r\nstruct path upperpath;\r\novl_path_upper(dentry, &upperpath);\r\nBUG_ON(upperpath.dentry != NULL);\r\nupperpath.dentry = newdentry;\r\nerr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\r\nif (err)\r\ngoto out_cleanup;\r\n}\r\nerr = ovl_copy_xattr(lowerpath->dentry, newdentry);\r\nif (err)\r\ngoto out_cleanup;\r\nmutex_lock(&newdentry->d_inode->i_mutex);\r\nerr = ovl_set_attr(newdentry, stat);\r\nif (!err && attr)\r\nerr = notify_change(newdentry, attr, NULL);\r\nmutex_unlock(&newdentry->d_inode->i_mutex);\r\nif (err)\r\ngoto out_cleanup;\r\nerr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\r\nif (err)\r\ngoto out_cleanup;\r\novl_dentry_update(dentry, newdentry);\r\nnewdentry = NULL;\r\nif (!S_ISDIR(stat->mode))\r\novl_dentry_set_opaque(dentry, true);\r\nout2:\r\ndput(upper);\r\nout1:\r\ndput(newdentry);\r\nout:\r\nreturn err;\r\nout_cleanup:\r\novl_cleanup(wdir, newdentry);\r\ngoto out;\r\n}\r\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\r\nstruct path *lowerpath, struct kstat *stat,\r\nstruct iattr *attr)\r\n{\r\nstruct dentry *workdir = ovl_workdir(dentry);\r\nint err;\r\nstruct kstat pstat;\r\nstruct path parentpath;\r\nstruct dentry *upperdir;\r\nstruct dentry *upperdentry;\r\nconst struct cred *old_cred;\r\nstruct cred *override_cred;\r\nchar *link = NULL;\r\novl_path_upper(parent, &parentpath);\r\nupperdir = parentpath.dentry;\r\nerr = vfs_getattr(&parentpath, &pstat);\r\nif (err)\r\nreturn err;\r\nif (S_ISLNK(stat->mode)) {\r\nlink = ovl_read_symlink(lowerpath->dentry);\r\nif (IS_ERR(link))\r\nreturn PTR_ERR(link);\r\n}\r\nerr = -ENOMEM;\r\noverride_cred = prepare_creds();\r\nif (!override_cred)\r\ngoto out_free_link;\r\noverride_cred->fsuid = stat->uid;\r\noverride_cred->fsgid = stat->gid;\r\ncap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\r\ncap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\r\ncap_raise(override_cred->cap_effective, CAP_FOWNER);\r\ncap_raise(override_cred->cap_effective, CAP_FSETID);\r\ncap_raise(override_cred->cap_effective, CAP_CHOWN);\r\ncap_raise(override_cred->cap_effective, CAP_MKNOD);\r\nold_cred = override_creds(override_cred);\r\nerr = -EIO;\r\nif (lock_rename(workdir, upperdir) != NULL) {\r\npr_err("overlayfs: failed to lock workdir+upperdir\n");\r\ngoto out_unlock;\r\n}\r\nupperdentry = ovl_dentry_upper(dentry);\r\nif (upperdentry) {\r\nunlock_rename(workdir, upperdir);\r\nerr = 0;\r\nif (attr) {\r\nmutex_lock(&upperdentry->d_inode->i_mutex);\r\nerr = notify_change(upperdentry, attr, NULL);\r\nmutex_unlock(&upperdentry->d_inode->i_mutex);\r\n}\r\ngoto out_put_cred;\r\n}\r\nerr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\r\nstat, attr, link);\r\nif (!err) {\r\novl_set_timestamps(upperdir, &pstat);\r\n}\r\nout_unlock:\r\nunlock_rename(workdir, upperdir);\r\nout_put_cred:\r\nrevert_creds(old_cred);\r\nput_cred(override_cred);\r\nout_free_link:\r\nif (link)\r\nfree_page((unsigned long) link);\r\nreturn err;\r\n}\r\nint ovl_copy_up(struct dentry *dentry)\r\n{\r\nint err;\r\nerr = 0;\r\nwhile (!err) {\r\nstruct dentry *next;\r\nstruct dentry *parent;\r\nstruct path lowerpath;\r\nstruct kstat stat;\r\nenum ovl_path_type type = ovl_path_type(dentry);\r\nif (type != OVL_PATH_LOWER)\r\nbreak;\r\nnext = dget(dentry);\r\nfor (;;) {\r\nparent = dget_parent(next);\r\ntype = ovl_path_type(parent);\r\nif (type != OVL_PATH_LOWER)\r\nbreak;\r\ndput(next);\r\nnext = parent;\r\n}\r\novl_path_lower(next, &lowerpath);\r\nerr = vfs_getattr(&lowerpath, &stat);\r\nif (!err)\r\nerr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\r\ndput(parent);\r\ndput(next);\r\n}\r\nreturn err;\r\n}
