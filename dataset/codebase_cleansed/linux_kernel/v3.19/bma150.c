static int bma150_write_byte(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\ns32 ret;\r\nif (client->irq)\r\ndisable_irq_nosync(client->irq);\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (client->irq)\r\nenable_irq(client->irq);\r\nreturn ret;\r\n}\r\nstatic int bma150_set_reg_bits(struct i2c_client *client,\r\nint val, int shift, u8 mask, u8 reg)\r\n{\r\nint data;\r\ndata = i2c_smbus_read_byte_data(client, reg);\r\nif (data < 0)\r\nreturn data;\r\ndata = (data & ~mask) | ((val << shift) & mask);\r\nreturn bma150_write_byte(client, reg, data);\r\n}\r\nstatic int bma150_set_mode(struct bma150_data *bma150, u8 mode)\r\n{\r\nint error;\r\nerror = bma150_set_reg_bits(bma150->client, mode, BMA150_WAKE_UP_POS,\r\nBMA150_WAKE_UP_MSK, BMA150_WAKE_UP_REG);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_reg_bits(bma150->client, mode, BMA150_SLEEP_POS,\r\nBMA150_SLEEP_MSK, BMA150_SLEEP_REG);\r\nif (error)\r\nreturn error;\r\nif (mode == BMA150_MODE_NORMAL)\r\nmsleep(2);\r\nbma150->mode = mode;\r\nreturn 0;\r\n}\r\nstatic int bma150_soft_reset(struct bma150_data *bma150)\r\n{\r\nint error;\r\nerror = bma150_set_reg_bits(bma150->client, 1, BMA150_SW_RES_POS,\r\nBMA150_SW_RES_MSK, BMA150_SW_RES_REG);\r\nif (error)\r\nreturn error;\r\nmsleep(2);\r\nreturn 0;\r\n}\r\nstatic int bma150_set_range(struct bma150_data *bma150, u8 range)\r\n{\r\nreturn bma150_set_reg_bits(bma150->client, range, BMA150_RANGE_POS,\r\nBMA150_RANGE_MSK, BMA150_RANGE_REG);\r\n}\r\nstatic int bma150_set_bandwidth(struct bma150_data *bma150, u8 bw)\r\n{\r\nreturn bma150_set_reg_bits(bma150->client, bw, BMA150_BANDWIDTH_POS,\r\nBMA150_BANDWIDTH_MSK, BMA150_BANDWIDTH_REG);\r\n}\r\nstatic int bma150_set_low_g_interrupt(struct bma150_data *bma150,\r\nu8 enable, u8 hyst, u8 dur, u8 thres)\r\n{\r\nint error;\r\nerror = bma150_set_reg_bits(bma150->client, hyst,\r\nBMA150_LOW_G_HYST_POS, BMA150_LOW_G_HYST_MSK,\r\nBMA150_LOW_G_HYST_REG);\r\nif (error)\r\nreturn error;\r\nerror = bma150_write_byte(bma150->client, BMA150_LOW_G_DUR_REG, dur);\r\nif (error)\r\nreturn error;\r\nerror = bma150_write_byte(bma150->client, BMA150_LOW_G_THRES_REG, thres);\r\nif (error)\r\nreturn error;\r\nreturn bma150_set_reg_bits(bma150->client, !!enable,\r\nBMA150_LOW_G_EN_POS, BMA150_LOW_G_EN_MSK,\r\nBMA150_LOW_G_EN_REG);\r\n}\r\nstatic int bma150_set_high_g_interrupt(struct bma150_data *bma150,\r\nu8 enable, u8 hyst, u8 dur, u8 thres)\r\n{\r\nint error;\r\nerror = bma150_set_reg_bits(bma150->client, hyst,\r\nBMA150_HIGH_G_HYST_POS, BMA150_HIGH_G_HYST_MSK,\r\nBMA150_HIGH_G_HYST_REG);\r\nif (error)\r\nreturn error;\r\nerror = bma150_write_byte(bma150->client,\r\nBMA150_HIGH_G_DUR_REG, dur);\r\nif (error)\r\nreturn error;\r\nerror = bma150_write_byte(bma150->client,\r\nBMA150_HIGH_G_THRES_REG, thres);\r\nif (error)\r\nreturn error;\r\nreturn bma150_set_reg_bits(bma150->client, !!enable,\r\nBMA150_HIGH_G_EN_POS, BMA150_HIGH_G_EN_MSK,\r\nBMA150_HIGH_G_EN_REG);\r\n}\r\nstatic int bma150_set_any_motion_interrupt(struct bma150_data *bma150,\r\nu8 enable, u8 dur, u8 thres)\r\n{\r\nint error;\r\nerror = bma150_set_reg_bits(bma150->client, dur,\r\nBMA150_ANY_MOTION_DUR_POS,\r\nBMA150_ANY_MOTION_DUR_MSK,\r\nBMA150_ANY_MOTION_DUR_REG);\r\nif (error)\r\nreturn error;\r\nerror = bma150_write_byte(bma150->client,\r\nBMA150_ANY_MOTION_THRES_REG, thres);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_reg_bits(bma150->client, !!enable,\r\nBMA150_ADV_INT_EN_POS, BMA150_ADV_INT_EN_MSK,\r\nBMA150_ADV_INT_EN_REG);\r\nif (error)\r\nreturn error;\r\nreturn bma150_set_reg_bits(bma150->client, !!enable,\r\nBMA150_ANY_MOTION_EN_POS,\r\nBMA150_ANY_MOTION_EN_MSK,\r\nBMA150_ANY_MOTION_EN_REG);\r\n}\r\nstatic void bma150_report_xyz(struct bma150_data *bma150)\r\n{\r\nu8 data[BMA150_XYZ_DATA_SIZE];\r\ns16 x, y, z;\r\ns32 ret;\r\nret = i2c_smbus_read_i2c_block_data(bma150->client,\r\nBMA150_ACC_X_LSB_REG, BMA150_XYZ_DATA_SIZE, data);\r\nif (ret != BMA150_XYZ_DATA_SIZE)\r\nreturn;\r\nx = ((0xc0 & data[0]) >> 6) | (data[1] << 2);\r\ny = ((0xc0 & data[2]) >> 6) | (data[3] << 2);\r\nz = ((0xc0 & data[4]) >> 6) | (data[5] << 2);\r\nx = (s16) (x << 6) >> 6;\r\ny = (s16) (y << 6) >> 6;\r\nz = (s16) (z << 6) >> 6;\r\ninput_report_abs(bma150->input, ABS_X, x);\r\ninput_report_abs(bma150->input, ABS_Y, y);\r\ninput_report_abs(bma150->input, ABS_Z, z);\r\ninput_sync(bma150->input);\r\n}\r\nstatic irqreturn_t bma150_irq_thread(int irq, void *dev)\r\n{\r\nbma150_report_xyz(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bma150_poll(struct input_polled_dev *dev)\r\n{\r\nbma150_report_xyz(dev->private);\r\n}\r\nstatic int bma150_open(struct bma150_data *bma150)\r\n{\r\nint error;\r\nerror = pm_runtime_get_sync(&bma150->client->dev);\r\nif (error < 0 && error != -ENOSYS)\r\nreturn error;\r\nif (bma150->mode != BMA150_MODE_NORMAL) {\r\nerror = bma150_set_mode(bma150, BMA150_MODE_NORMAL);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bma150_close(struct bma150_data *bma150)\r\n{\r\npm_runtime_put_sync(&bma150->client->dev);\r\nif (bma150->mode != BMA150_MODE_SLEEP)\r\nbma150_set_mode(bma150, BMA150_MODE_SLEEP);\r\n}\r\nstatic int bma150_irq_open(struct input_dev *input)\r\n{\r\nstruct bma150_data *bma150 = input_get_drvdata(input);\r\nreturn bma150_open(bma150);\r\n}\r\nstatic void bma150_irq_close(struct input_dev *input)\r\n{\r\nstruct bma150_data *bma150 = input_get_drvdata(input);\r\nbma150_close(bma150);\r\n}\r\nstatic void bma150_poll_open(struct input_polled_dev *ipoll_dev)\r\n{\r\nstruct bma150_data *bma150 = ipoll_dev->private;\r\nbma150_open(bma150);\r\n}\r\nstatic void bma150_poll_close(struct input_polled_dev *ipoll_dev)\r\n{\r\nstruct bma150_data *bma150 = ipoll_dev->private;\r\nbma150_close(bma150);\r\n}\r\nstatic int bma150_initialize(struct bma150_data *bma150,\r\nconst struct bma150_cfg *cfg)\r\n{\r\nint error;\r\nerror = bma150_soft_reset(bma150);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_bandwidth(bma150, cfg->bandwidth);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_range(bma150, cfg->range);\r\nif (error)\r\nreturn error;\r\nif (bma150->client->irq) {\r\nerror = bma150_set_any_motion_interrupt(bma150,\r\ncfg->any_motion_int,\r\ncfg->any_motion_dur,\r\ncfg->any_motion_thres);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_high_g_interrupt(bma150,\r\ncfg->hg_int, cfg->hg_hyst,\r\ncfg->hg_dur, cfg->hg_thres);\r\nif (error)\r\nreturn error;\r\nerror = bma150_set_low_g_interrupt(bma150,\r\ncfg->lg_int, cfg->lg_hyst,\r\ncfg->lg_dur, cfg->lg_thres);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn bma150_set_mode(bma150, BMA150_MODE_SLEEP);\r\n}\r\nstatic void bma150_init_input_device(struct bma150_data *bma150,\r\nstruct input_dev *idev)\r\n{\r\nidev->name = BMA150_DRIVER;\r\nidev->phys = BMA150_DRIVER "/input0";\r\nidev->id.bustype = BUS_I2C;\r\nidev->dev.parent = &bma150->client->dev;\r\nidev->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\r\ninput_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\r\n}\r\nstatic int bma150_register_input_device(struct bma150_data *bma150)\r\n{\r\nstruct input_dev *idev;\r\nint error;\r\nidev = input_allocate_device();\r\nif (!idev)\r\nreturn -ENOMEM;\r\nbma150_init_input_device(bma150, idev);\r\nidev->open = bma150_irq_open;\r\nidev->close = bma150_irq_close;\r\ninput_set_drvdata(idev, bma150);\r\nerror = input_register_device(idev);\r\nif (error) {\r\ninput_free_device(idev);\r\nreturn error;\r\n}\r\nbma150->input = idev;\r\nreturn 0;\r\n}\r\nstatic int bma150_register_polled_device(struct bma150_data *bma150)\r\n{\r\nstruct input_polled_dev *ipoll_dev;\r\nint error;\r\nipoll_dev = input_allocate_polled_device();\r\nif (!ipoll_dev)\r\nreturn -ENOMEM;\r\nipoll_dev->private = bma150;\r\nipoll_dev->open = bma150_poll_open;\r\nipoll_dev->close = bma150_poll_close;\r\nipoll_dev->poll = bma150_poll;\r\nipoll_dev->poll_interval = BMA150_POLL_INTERVAL;\r\nipoll_dev->poll_interval_min = BMA150_POLL_MIN;\r\nipoll_dev->poll_interval_max = BMA150_POLL_MAX;\r\nbma150_init_input_device(bma150, ipoll_dev->input);\r\nerror = input_register_polled_device(ipoll_dev);\r\nif (error) {\r\ninput_free_polled_device(ipoll_dev);\r\nreturn error;\r\n}\r\nbma150->input_polled = ipoll_dev;\r\nbma150->input = ipoll_dev->input;\r\nreturn 0;\r\n}\r\nstatic int bma150_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct bma150_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nconst struct bma150_cfg *cfg;\r\nstruct bma150_data *bma150;\r\nint chip_id;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c_check_functionality error\n");\r\nreturn -EIO;\r\n}\r\nchip_id = i2c_smbus_read_byte_data(client, BMA150_CHIP_ID_REG);\r\nif (chip_id != BMA150_CHIP_ID && chip_id != BMA180_CHIP_ID) {\r\ndev_err(&client->dev, "BMA150 chip id error: %d\n", chip_id);\r\nreturn -EINVAL;\r\n}\r\nbma150 = kzalloc(sizeof(struct bma150_data), GFP_KERNEL);\r\nif (!bma150)\r\nreturn -ENOMEM;\r\nbma150->client = client;\r\nif (pdata) {\r\nif (pdata->irq_gpio_cfg) {\r\nerror = pdata->irq_gpio_cfg();\r\nif (error) {\r\ndev_err(&client->dev,\r\n"IRQ GPIO conf. error %d, error %d\n",\r\nclient->irq, error);\r\ngoto err_free_mem;\r\n}\r\n}\r\ncfg = &pdata->cfg;\r\n} else {\r\ncfg = &default_cfg;\r\n}\r\nerror = bma150_initialize(bma150, cfg);\r\nif (error)\r\ngoto err_free_mem;\r\nif (client->irq > 0) {\r\nerror = bma150_register_input_device(bma150);\r\nif (error)\r\ngoto err_free_mem;\r\nerror = request_threaded_irq(client->irq,\r\nNULL, bma150_irq_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\nBMA150_DRIVER, bma150);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"irq request failed %d, error %d\n",\r\nclient->irq, error);\r\ninput_unregister_device(bma150->input);\r\ngoto err_free_mem;\r\n}\r\n} else {\r\nerror = bma150_register_polled_device(bma150);\r\nif (error)\r\ngoto err_free_mem;\r\n}\r\ni2c_set_clientdata(client, bma150);\r\npm_runtime_enable(&client->dev);\r\nreturn 0;\r\nerr_free_mem:\r\nkfree(bma150);\r\nreturn error;\r\n}\r\nstatic int bma150_remove(struct i2c_client *client)\r\n{\r\nstruct bma150_data *bma150 = i2c_get_clientdata(client);\r\npm_runtime_disable(&client->dev);\r\nif (client->irq > 0) {\r\nfree_irq(client->irq, bma150);\r\ninput_unregister_device(bma150->input);\r\n} else {\r\ninput_unregister_polled_device(bma150->input_polled);\r\ninput_free_polled_device(bma150->input_polled);\r\n}\r\nkfree(bma150);\r\nreturn 0;\r\n}\r\nstatic int bma150_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bma150_data *bma150 = i2c_get_clientdata(client);\r\nreturn bma150_set_mode(bma150, BMA150_MODE_SLEEP);\r\n}\r\nstatic int bma150_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bma150_data *bma150 = i2c_get_clientdata(client);\r\nreturn bma150_set_mode(bma150, BMA150_MODE_NORMAL);\r\n}
