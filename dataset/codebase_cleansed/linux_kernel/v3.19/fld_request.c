static int fld_req_avail(struct client_obd *cli, struct mdc_cache_waiter *mcw)\r\n{\r\nint rc;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nrc = list_empty(&mcw->mcw_entry);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn rc;\r\n}\r\nstatic void fld_enter_request(struct client_obd *cli)\r\n{\r\nstruct mdc_cache_waiter mcw;\r\nstruct l_wait_info lwi = { 0 };\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (cli->cl_r_in_flight >= cli->cl_max_rpcs_in_flight) {\r\nlist_add_tail(&mcw.mcw_entry, &cli->cl_cache_waiters);\r\ninit_waitqueue_head(&mcw.mcw_waitq);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nl_wait_event(mcw.mcw_waitq, fld_req_avail(cli, &mcw), &lwi);\r\n} else {\r\ncli->cl_r_in_flight++;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\n}\r\nstatic void fld_exit_request(struct client_obd *cli)\r\n{\r\nstruct list_head *l, *tmp;\r\nstruct mdc_cache_waiter *mcw;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\ncli->cl_r_in_flight--;\r\nlist_for_each_safe(l, tmp, &cli->cl_cache_waiters) {\r\nif (cli->cl_r_in_flight >= cli->cl_max_rpcs_in_flight) {\r\nbreak;\r\n}\r\nmcw = list_entry(l, struct mdc_cache_waiter, mcw_entry);\r\nlist_del_init(&mcw->mcw_entry);\r\ncli->cl_r_in_flight++;\r\nwake_up(&mcw->mcw_waitq);\r\n}\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nstatic int fld_rrb_hash(struct lu_client_fld *fld, u64 seq)\r\n{\r\nLASSERT(fld->lcf_count > 0);\r\nreturn do_div(seq, fld->lcf_count);\r\n}\r\nstatic struct lu_fld_target *\r\nfld_rrb_scan(struct lu_client_fld *fld, u64 seq)\r\n{\r\nstruct lu_fld_target *target;\r\nint hash;\r\nif (fid_seq_is_norm(seq))\r\nhash = fld_rrb_hash(fld, seq);\r\nelse\r\nhash = 0;\r\nlist_for_each_entry(target, &fld->lcf_targets, ft_chain) {\r\nif (target->ft_idx == hash)\r\nreturn target;\r\n}\r\nCERROR("%s: Can't find target by hash %d (seq %#llx). Targets (%d):\n",\r\nfld->lcf_name, hash, seq, fld->lcf_count);\r\nlist_for_each_entry(target, &fld->lcf_targets, ft_chain) {\r\nconst char *srv_name = target->ft_srv != NULL ?\r\ntarget->ft_srv->lsf_name : "<null>";\r\nconst char *exp_name = target->ft_exp != NULL ?\r\n(char *)target->ft_exp->exp_obd->obd_uuid.uuid :\r\n"<null>";\r\nCERROR(" exp: 0x%p (%s), srv: 0x%p (%s), idx: %llu\n",\r\ntarget->ft_exp, exp_name, target->ft_srv,\r\nsrv_name, target->ft_idx);\r\n}\r\nLBUG();\r\nreturn NULL;\r\n}\r\nstatic struct lu_fld_target *\r\nfld_client_get_target(struct lu_client_fld *fld, u64 seq)\r\n{\r\nstruct lu_fld_target *target;\r\nLASSERT(fld->lcf_hash != NULL);\r\nspin_lock(&fld->lcf_lock);\r\ntarget = fld->lcf_hash->fh_scan_func(fld, seq);\r\nspin_unlock(&fld->lcf_lock);\r\nif (target != NULL) {\r\nCDEBUG(D_INFO, "%s: Found target (idx %llu) by seq %#llx\n",\r\nfld->lcf_name, target->ft_idx, seq);\r\n}\r\nreturn target;\r\n}\r\nint fld_client_add_target(struct lu_client_fld *fld,\r\nstruct lu_fld_target *tar)\r\n{\r\nconst char *name;\r\nstruct lu_fld_target *target, *tmp;\r\nLASSERT(tar != NULL);\r\nname = fld_target_name(tar);\r\nLASSERT(name != NULL);\r\nLASSERT(tar->ft_srv != NULL || tar->ft_exp != NULL);\r\nif (fld->lcf_flags != LUSTRE_FLD_INIT) {\r\nCERROR("%s: Attempt to add target %s (idx %llu) on fly - skip it\n",\r\nfld->lcf_name, name, tar->ft_idx);\r\nreturn 0;\r\n} else {\r\nCDEBUG(D_INFO, "%s: Adding target %s (idx %llu)\n",\r\nfld->lcf_name, name, tar->ft_idx);\r\n}\r\nOBD_ALLOC_PTR(target);\r\nif (target == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry(tmp, &fld->lcf_targets, ft_chain) {\r\nif (tmp->ft_idx == tar->ft_idx) {\r\nspin_unlock(&fld->lcf_lock);\r\nOBD_FREE_PTR(target);\r\nCERROR("Target %s exists in FLD and known as %s:#%llu\n",\r\nname, fld_target_name(tmp), tmp->ft_idx);\r\nreturn -EEXIST;\r\n}\r\n}\r\ntarget->ft_exp = tar->ft_exp;\r\nif (target->ft_exp != NULL)\r\nclass_export_get(target->ft_exp);\r\ntarget->ft_srv = tar->ft_srv;\r\ntarget->ft_idx = tar->ft_idx;\r\nlist_add_tail(&target->ft_chain,\r\n&fld->lcf_targets);\r\nfld->lcf_count++;\r\nspin_unlock(&fld->lcf_lock);\r\nreturn 0;\r\n}\r\nint fld_client_del_target(struct lu_client_fld *fld, __u64 idx)\r\n{\r\nstruct lu_fld_target *target, *tmp;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry_safe(target, tmp,\r\n&fld->lcf_targets, ft_chain) {\r\nif (target->ft_idx == idx) {\r\nfld->lcf_count--;\r\nlist_del(&target->ft_chain);\r\nspin_unlock(&fld->lcf_lock);\r\nif (target->ft_exp != NULL)\r\nclass_export_put(target->ft_exp);\r\nOBD_FREE_PTR(target);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&fld->lcf_lock);\r\nreturn -ENOENT;\r\n}\r\nstatic int fld_client_proc_init(struct lu_client_fld *fld)\r\n{\r\nint rc;\r\nfld->lcf_proc_dir = lprocfs_register(fld->lcf_name,\r\nfld_type_proc_dir,\r\nNULL, NULL);\r\nif (IS_ERR(fld->lcf_proc_dir)) {\r\nCERROR("%s: LProcFS failed in fld-init\n",\r\nfld->lcf_name);\r\nrc = PTR_ERR(fld->lcf_proc_dir);\r\nreturn rc;\r\n}\r\nrc = lprocfs_add_vars(fld->lcf_proc_dir,\r\nfld_client_proc_list, fld);\r\nif (rc) {\r\nCERROR("%s: Can't init FLD proc, rc %d\n",\r\nfld->lcf_name, rc);\r\ngoto out_cleanup;\r\n}\r\nreturn 0;\r\nout_cleanup:\r\nfld_client_proc_fini(fld);\r\nreturn rc;\r\n}\r\nvoid fld_client_proc_fini(struct lu_client_fld *fld)\r\n{\r\nif (fld->lcf_proc_dir) {\r\nif (!IS_ERR(fld->lcf_proc_dir))\r\nlprocfs_remove(&fld->lcf_proc_dir);\r\nfld->lcf_proc_dir = NULL;\r\n}\r\n}\r\nstatic int fld_client_proc_init(struct lu_client_fld *fld)\r\n{\r\nreturn 0;\r\n}\r\nvoid fld_client_proc_fini(struct lu_client_fld *fld)\r\n{\r\nreturn;\r\n}\r\nstatic inline int hash_is_sane(int hash)\r\n{\r\nreturn (hash >= 0 && hash < ARRAY_SIZE(fld_hash));\r\n}\r\nint fld_client_init(struct lu_client_fld *fld,\r\nconst char *prefix, int hash)\r\n{\r\nint cache_size, cache_threshold;\r\nint rc;\r\nLASSERT(fld != NULL);\r\nsnprintf(fld->lcf_name, sizeof(fld->lcf_name),\r\n"cli-%s", prefix);\r\nif (!hash_is_sane(hash)) {\r\nCERROR("%s: Wrong hash function %#x\n",\r\nfld->lcf_name, hash);\r\nreturn -EINVAL;\r\n}\r\nfld->lcf_count = 0;\r\nspin_lock_init(&fld->lcf_lock);\r\nfld->lcf_hash = &fld_hash[hash];\r\nfld->lcf_flags = LUSTRE_FLD_INIT;\r\nINIT_LIST_HEAD(&fld->lcf_targets);\r\ncache_size = FLD_CLIENT_CACHE_SIZE /\r\nsizeof(struct fld_cache_entry);\r\ncache_threshold = cache_size *\r\nFLD_CLIENT_CACHE_THRESHOLD / 100;\r\nfld->lcf_cache = fld_cache_init(fld->lcf_name,\r\ncache_size, cache_threshold);\r\nif (IS_ERR(fld->lcf_cache)) {\r\nrc = PTR_ERR(fld->lcf_cache);\r\nfld->lcf_cache = NULL;\r\ngoto out;\r\n}\r\nrc = fld_client_proc_init(fld);\r\nif (rc)\r\ngoto out;\r\nout:\r\nif (rc)\r\nfld_client_fini(fld);\r\nelse\r\nCDEBUG(D_INFO, "%s: Using \"%s\" hash\n",\r\nfld->lcf_name, fld->lcf_hash->fh_name);\r\nreturn rc;\r\n}\r\nvoid fld_client_fini(struct lu_client_fld *fld)\r\n{\r\nstruct lu_fld_target *target, *tmp;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry_safe(target, tmp,\r\n&fld->lcf_targets, ft_chain) {\r\nfld->lcf_count--;\r\nlist_del(&target->ft_chain);\r\nif (target->ft_exp != NULL)\r\nclass_export_put(target->ft_exp);\r\nOBD_FREE_PTR(target);\r\n}\r\nspin_unlock(&fld->lcf_lock);\r\nif (fld->lcf_cache != NULL) {\r\nif (!IS_ERR(fld->lcf_cache))\r\nfld_cache_fini(fld->lcf_cache);\r\nfld->lcf_cache = NULL;\r\n}\r\n}\r\nint fld_client_rpc(struct obd_export *exp,\r\nstruct lu_seq_range *range, __u32 fld_op)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct lu_seq_range *prange;\r\n__u32 *op;\r\nint rc;\r\nstruct obd_import *imp;\r\nLASSERT(exp != NULL);\r\nimp = class_exp2cliimp(exp);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_FLD_QUERY, LUSTRE_MDS_VERSION,\r\nFLD_QUERY);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nop = req_capsule_client_get(&req->rq_pill, &RMF_FLD_OPC);\r\n*op = fld_op;\r\nprange = req_capsule_client_get(&req->rq_pill, &RMF_FLD_MDFLD);\r\n*prange = *range;\r\nptlrpc_request_set_replen(req);\r\nreq->rq_request_portal = FLD_REQUEST_PORTAL;\r\nreq->rq_reply_portal = MDC_REPLY_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nif (fld_op == FLD_LOOKUP &&\r\nimp->imp_connect_flags_orig & OBD_CONNECT_MDS_MDS)\r\nreq->rq_allow_replay = 1;\r\nif (fld_op != FLD_LOOKUP)\r\nmdc_get_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nfld_enter_request(&exp->exp_obd->u.cli);\r\nrc = ptlrpc_queue_wait(req);\r\nfld_exit_request(&exp->exp_obd->u.cli);\r\nif (fld_op != FLD_LOOKUP)\r\nmdc_put_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nif (rc)\r\ngoto out_req;\r\nprange = req_capsule_server_get(&req->rq_pill, &RMF_FLD_MDFLD);\r\nif (prange == NULL) {\r\nrc = -EFAULT;\r\ngoto out_req;\r\n}\r\n*range = *prange;\r\nout_req:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint fld_client_lookup(struct lu_client_fld *fld, u64 seq, u32 *mds,\r\n__u32 flags, const struct lu_env *env)\r\n{\r\nstruct lu_seq_range res = { 0 };\r\nstruct lu_fld_target *target;\r\nint rc;\r\nfld->lcf_flags |= LUSTRE_FLD_RUN;\r\nrc = fld_cache_lookup(fld->lcf_cache, seq, &res);\r\nif (rc == 0) {\r\n*mds = res.lsr_index;\r\nreturn 0;\r\n}\r\ntarget = fld_client_get_target(fld, seq);\r\nLASSERT(target != NULL);\r\nCDEBUG(D_INFO, "%s: Lookup fld entry (seq: %#llx) on target %s (idx %llu)\n",\r\nfld->lcf_name, seq, fld_target_name(target), target->ft_idx);\r\nres.lsr_start = seq;\r\nfld_range_set_type(&res, flags);\r\nrc = fld_client_rpc(target->ft_exp, &res, FLD_LOOKUP);\r\nif (rc == 0) {\r\n*mds = res.lsr_index;\r\nfld_cache_insert(fld->lcf_cache, &res);\r\n}\r\nreturn rc;\r\n}\r\nvoid fld_client_flush(struct lu_client_fld *fld)\r\n{\r\nfld_cache_flush(fld->lcf_cache);\r\n}\r\nstatic int __init fld_mod_init(void)\r\n{\r\nfld_type_proc_dir = lprocfs_register(LUSTRE_FLD_NAME,\r\nproc_lustre_root,\r\nNULL, NULL);\r\nreturn PTR_ERR_OR_ZERO(fld_type_proc_dir);\r\n}\r\nstatic void __exit fld_mod_exit(void)\r\n{\r\nif (fld_type_proc_dir != NULL && !IS_ERR(fld_type_proc_dir)) {\r\nlprocfs_remove(&fld_type_proc_dir);\r\nfld_type_proc_dir = NULL;\r\n}\r\n}
