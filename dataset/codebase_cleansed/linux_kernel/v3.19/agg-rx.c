static void ieee80211_free_tid_rx(struct rcu_head *h)\r\n{\r\nstruct tid_ampdu_rx *tid_rx =\r\ncontainer_of(h, struct tid_ampdu_rx, rcu_head);\r\nint i;\r\ndel_timer_sync(&tid_rx->reorder_timer);\r\nfor (i = 0; i < tid_rx->buf_size; i++)\r\n__skb_queue_purge(&tid_rx->reorder_buf[i]);\r\nkfree(tid_rx->reorder_buf);\r\nkfree(tid_rx->reorder_time);\r\nkfree(tid_rx);\r\n}\r\nvoid ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\r\nu16 initiator, u16 reason, bool tx)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct tid_ampdu_rx *tid_rx;\r\nlockdep_assert_held(&sta->ampdu_mlme.mtx);\r\ntid_rx = rcu_dereference_protected(sta->ampdu_mlme.tid_rx[tid],\r\nlockdep_is_held(&sta->ampdu_mlme.mtx));\r\nif (!tid_rx)\r\nreturn;\r\nRCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);\r\nht_dbg(sta->sdata,\r\n"Rx BA session stop requested for %pM tid %u %s reason: %d\n",\r\nsta->sta.addr, tid,\r\ninitiator == WLAN_BACK_RECIPIENT ? "recipient" : "inititator",\r\n(int)reason);\r\nif (drv_ampdu_action(local, sta->sdata, IEEE80211_AMPDU_RX_STOP,\r\n&sta->sta, tid, NULL, 0))\r\nsdata_info(sta->sdata,\r\n"HW problem - can not stop rx aggregation for %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nif (initiator == WLAN_BACK_RECIPIENT && tx)\r\nieee80211_send_delba(sta->sdata, sta->sta.addr,\r\ntid, WLAN_BACK_RECIPIENT, reason);\r\ndel_timer_sync(&tid_rx->session_timer);\r\ncall_rcu(&tid_rx->rcu_head, ieee80211_free_tid_rx);\r\n}\r\nvoid __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\r\nu16 initiator, u16 reason, bool tx)\r\n{\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\n___ieee80211_stop_rx_ba_session(sta, tid, initiator, reason, tx);\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\n}\r\nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\r\nconst u8 *addr)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct sta_info *sta;\r\nint i;\r\nrcu_read_lock();\r\nsta = sta_info_get_bss(sdata, addr);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\r\nif (ba_rx_bitmap & BIT(i))\r\nset_bit(i, sta->ampdu_mlme.tid_rx_stop_requested);\r\nieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);\r\nrcu_read_unlock();\r\n}\r\nstatic void sta_rx_agg_session_timer_expired(unsigned long data)\r\n{\r\nu8 *ptid = (u8 *)data;\r\nu8 *timer_to_id = ptid - *ptid;\r\nstruct sta_info *sta = container_of(timer_to_id, struct sta_info,\r\ntimer_to_tid[0]);\r\nstruct tid_ampdu_rx *tid_rx;\r\nunsigned long timeout;\r\nrcu_read_lock();\r\ntid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[*ptid]);\r\nif (!tid_rx) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\ntimeout = tid_rx->last_rx + TU_TO_JIFFIES(tid_rx->timeout);\r\nif (time_is_after_jiffies(timeout)) {\r\nmod_timer(&tid_rx->session_timer, timeout);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\nht_dbg(sta->sdata, "RX session timer expired on %pM tid %d\n",\r\nsta->sta.addr, (u16)*ptid);\r\nset_bit(*ptid, sta->ampdu_mlme.tid_rx_timer_expired);\r\nieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);\r\n}\r\nstatic void sta_rx_agg_reorder_timer_expired(unsigned long data)\r\n{\r\nu8 *ptid = (u8 *)data;\r\nu8 *timer_to_id = ptid - *ptid;\r\nstruct sta_info *sta = container_of(timer_to_id, struct sta_info,\r\ntimer_to_tid[0]);\r\nrcu_read_lock();\r\nieee80211_release_reorder_timeout(sta, *ptid);\r\nrcu_read_unlock();\r\n}\r\nstatic void ieee80211_send_addba_resp(struct ieee80211_sub_if_data *sdata, u8 *da, u16 tid,\r\nu8 dialog_token, u16 status, u16 policy,\r\nu16 buf_size, u16 timeout)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *mgmt;\r\nu16 capab;\r\nskb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);\r\nmemset(mgmt, 0, 24);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT)\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_STATION)\r\nmemcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\r\nmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nskb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));\r\nmgmt->u.action.category = WLAN_CATEGORY_BACK;\r\nmgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;\r\nmgmt->u.action.u.addba_resp.dialog_token = dialog_token;\r\ncapab = (u16)(policy << 1);\r\ncapab |= (u16)(tid << 2);\r\ncapab |= (u16)(buf_size << 6);\r\nmgmt->u.action.u.addba_resp.capab = cpu_to_le16(capab);\r\nmgmt->u.action.u.addba_resp.timeout = cpu_to_le16(timeout);\r\nmgmt->u.action.u.addba_resp.status = cpu_to_le16(status);\r\nieee80211_tx_skb(sdata, skb);\r\n}\r\nvoid __ieee80211_start_rx_ba_session(struct sta_info *sta,\r\nu8 dialog_token, u16 timeout,\r\nu16 start_seq_num, u16 ba_policy, u16 tid,\r\nu16 buf_size, bool tx, bool auto_seq)\r\n{\r\nstruct ieee80211_local *local = sta->sdata->local;\r\nstruct tid_ampdu_rx *tid_agg_rx;\r\nint i, ret = -EOPNOTSUPP;\r\nu16 status = WLAN_STATUS_REQUEST_DECLINED;\r\nif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\r\nht_dbg(sta->sdata,\r\n"Suspend in progress - Denying ADDBA request (%pM tid %d)\n",\r\nsta->sta.addr, tid);\r\ngoto end_no_lock;\r\n}\r\nif (((ba_policy != 1) &&\r\n(!(sta->sta.ht_cap.cap & IEEE80211_HT_CAP_DELAY_BA))) ||\r\n(buf_size > IEEE80211_MAX_AMPDU_BUF)) {\r\nstatus = WLAN_STATUS_INVALID_QOS_PARAM;\r\nht_dbg_ratelimited(sta->sdata,\r\n"AddBA Req with bad params from %pM on tid %u. policy %d, buffer size %d\n",\r\nsta->sta.addr, tid, ba_policy, buf_size);\r\ngoto end_no_lock;\r\n}\r\nif (buf_size == 0)\r\nbuf_size = IEEE80211_MAX_AMPDU_BUF;\r\nif (buf_size > local->hw.max_rx_aggregation_subframes)\r\nbuf_size = local->hw.max_rx_aggregation_subframes;\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\nif (sta->ampdu_mlme.tid_rx[tid]) {\r\nht_dbg_ratelimited(sta->sdata,\r\n"unexpected AddBA Req from %pM on tid %u\n",\r\nsta->sta.addr, tid);\r\n___ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,\r\nWLAN_STATUS_UNSPECIFIED_QOS,\r\nfalse);\r\n}\r\ntid_agg_rx = kmalloc(sizeof(struct tid_ampdu_rx), GFP_KERNEL);\r\nif (!tid_agg_rx)\r\ngoto end;\r\nspin_lock_init(&tid_agg_rx->reorder_lock);\r\ntid_agg_rx->session_timer.function = sta_rx_agg_session_timer_expired;\r\ntid_agg_rx->session_timer.data = (unsigned long)&sta->timer_to_tid[tid];\r\ninit_timer_deferrable(&tid_agg_rx->session_timer);\r\ntid_agg_rx->reorder_timer.function = sta_rx_agg_reorder_timer_expired;\r\ntid_agg_rx->reorder_timer.data = (unsigned long)&sta->timer_to_tid[tid];\r\ninit_timer(&tid_agg_rx->reorder_timer);\r\ntid_agg_rx->reorder_buf =\r\nkcalloc(buf_size, sizeof(struct sk_buff_head), GFP_KERNEL);\r\ntid_agg_rx->reorder_time =\r\nkcalloc(buf_size, sizeof(unsigned long), GFP_KERNEL);\r\nif (!tid_agg_rx->reorder_buf || !tid_agg_rx->reorder_time) {\r\nkfree(tid_agg_rx->reorder_buf);\r\nkfree(tid_agg_rx->reorder_time);\r\nkfree(tid_agg_rx);\r\ngoto end;\r\n}\r\nfor (i = 0; i < buf_size; i++)\r\n__skb_queue_head_init(&tid_agg_rx->reorder_buf[i]);\r\nret = drv_ampdu_action(local, sta->sdata, IEEE80211_AMPDU_RX_START,\r\n&sta->sta, tid, &start_seq_num, 0);\r\nht_dbg(sta->sdata, "Rx A-MPDU request on %pM tid %d result %d\n",\r\nsta->sta.addr, tid, ret);\r\nif (ret) {\r\nkfree(tid_agg_rx->reorder_buf);\r\nkfree(tid_agg_rx->reorder_time);\r\nkfree(tid_agg_rx);\r\ngoto end;\r\n}\r\ntid_agg_rx->dialog_token = dialog_token;\r\ntid_agg_rx->ssn = start_seq_num;\r\ntid_agg_rx->head_seq_num = start_seq_num;\r\ntid_agg_rx->buf_size = buf_size;\r\ntid_agg_rx->timeout = timeout;\r\ntid_agg_rx->stored_mpdu_num = 0;\r\ntid_agg_rx->auto_seq = auto_seq;\r\nstatus = WLAN_STATUS_SUCCESS;\r\nrcu_assign_pointer(sta->ampdu_mlme.tid_rx[tid], tid_agg_rx);\r\nif (timeout) {\r\nmod_timer(&tid_agg_rx->session_timer, TU_TO_EXP_TIME(timeout));\r\ntid_agg_rx->last_rx = jiffies;\r\n}\r\nend:\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\nend_no_lock:\r\nif (tx)\r\nieee80211_send_addba_resp(sta->sdata, sta->sta.addr, tid,\r\ndialog_token, status, 1, buf_size,\r\ntimeout);\r\n}\r\nvoid ieee80211_process_addba_request(struct ieee80211_local *local,\r\nstruct sta_info *sta,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len)\r\n{\r\nu16 capab, tid, timeout, ba_policy, buf_size, start_seq_num;\r\nu8 dialog_token;\r\ndialog_token = mgmt->u.action.u.addba_req.dialog_token;\r\ntimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\r\nstart_seq_num =\r\nle16_to_cpu(mgmt->u.action.u.addba_req.start_seq_num) >> 4;\r\ncapab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\r\nba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;\r\ntid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\r\nbuf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;\r\n__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,\r\nstart_seq_num, ba_policy, tid,\r\nbuf_size, true, false);\r\n}\r\nvoid ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,\r\nconst u8 *addr, u16 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_rx_agg *rx_agg;\r\nstruct sk_buff *skb = dev_alloc_skb(0);\r\nif (unlikely(!skb))\r\nreturn;\r\nrx_agg = (struct ieee80211_rx_agg *) &skb->cb;\r\nmemcpy(&rx_agg->addr, addr, ETH_ALEN);\r\nrx_agg->tid = tid;\r\nskb->pkt_type = IEEE80211_SDATA_QUEUE_RX_AGG_START;\r\nskb_queue_tail(&sdata->skb_queue, skb);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nvoid ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,\r\nconst u8 *addr, u16 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_rx_agg *rx_agg;\r\nstruct sk_buff *skb = dev_alloc_skb(0);\r\nif (unlikely(!skb))\r\nreturn;\r\nrx_agg = (struct ieee80211_rx_agg *) &skb->cb;\r\nmemcpy(&rx_agg->addr, addr, ETH_ALEN);\r\nrx_agg->tid = tid;\r\nskb->pkt_type = IEEE80211_SDATA_QUEUE_RX_AGG_STOP;\r\nskb_queue_tail(&sdata->skb_queue, skb);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}
