bool vsp1_entity_is_streaming(struct vsp1_entity *entity)\r\n{\r\nbool streaming;\r\nmutex_lock(&entity->lock);\r\nstreaming = entity->streaming;\r\nmutex_unlock(&entity->lock);\r\nreturn streaming;\r\n}\r\nint vsp1_entity_set_streaming(struct vsp1_entity *entity, bool streaming)\r\n{\r\nint ret;\r\nmutex_lock(&entity->lock);\r\nentity->streaming = streaming;\r\nmutex_unlock(&entity->lock);\r\nif (!streaming)\r\nreturn 0;\r\nif (!entity->subdev.ctrl_handler)\r\nreturn 0;\r\nret = v4l2_ctrl_handler_setup(entity->subdev.ctrl_handler);\r\nif (ret < 0) {\r\nmutex_lock(&entity->lock);\r\nentity->streaming = false;\r\nmutex_unlock(&entity->lock);\r\n}\r\nreturn ret;\r\n}\r\nstruct v4l2_mbus_framefmt *\r\nvsp1_entity_get_pad_format(struct vsp1_entity *entity,\r\nstruct v4l2_subdev_fh *fh,\r\nunsigned int pad, u32 which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &entity->formats[pad];\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nvoid vsp1_entity_init_formats(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nunsigned int pad;\r\nfor (pad = 0; pad < subdev->entity.num_pads - 1; ++pad) {\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = pad;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY\r\n: V4L2_SUBDEV_FORMAT_ACTIVE;\r\nv4l2_subdev_call(subdev, pad, set_fmt, fh, &format);\r\n}\r\n}\r\nstatic int vsp1_entity_open(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nvsp1_entity_init_formats(subdev, fh);\r\nreturn 0;\r\n}\r\nstatic int vsp1_entity_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct vsp1_entity *source;\r\nif (!(local->flags & MEDIA_PAD_FL_SOURCE))\r\nreturn 0;\r\nsource = container_of(local->entity, struct vsp1_entity, subdev.entity);\r\nif (!source->route)\r\nreturn 0;\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (source->sink)\r\nreturn -EBUSY;\r\nsource->sink = remote->entity;\r\nsource->sink_pad = remote->index;\r\n} else {\r\nsource->sink = NULL;\r\nsource->sink_pad = 0;\r\n}\r\nreturn 0;\r\n}\r\nint vsp1_entity_init(struct vsp1_device *vsp1, struct vsp1_entity *entity,\r\nunsigned int num_pads)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(vsp1_routes); ++i) {\r\nif (vsp1_routes[i].type == entity->type &&\r\nvsp1_routes[i].index == entity->index) {\r\nentity->route = &vsp1_routes[i];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(vsp1_routes))\r\nreturn -EINVAL;\r\nmutex_init(&entity->lock);\r\nentity->vsp1 = vsp1;\r\nentity->source_pad = num_pads - 1;\r\nentity->formats = devm_kzalloc(vsp1->dev,\r\nnum_pads * sizeof(*entity->formats),\r\nGFP_KERNEL);\r\nif (entity->formats == NULL)\r\nreturn -ENOMEM;\r\nentity->pads = devm_kzalloc(vsp1->dev, num_pads * sizeof(*entity->pads),\r\nGFP_KERNEL);\r\nif (entity->pads == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pads - 1; ++i)\r\nentity->pads[i].flags = MEDIA_PAD_FL_SINK;\r\nentity->pads[num_pads - 1].flags = MEDIA_PAD_FL_SOURCE;\r\nreturn media_entity_init(&entity->subdev.entity, num_pads,\r\nentity->pads, 0);\r\n}\r\nvoid vsp1_entity_destroy(struct vsp1_entity *entity)\r\n{\r\nif (entity->video)\r\nvsp1_video_cleanup(entity->video);\r\nif (entity->subdev.ctrl_handler)\r\nv4l2_ctrl_handler_free(entity->subdev.ctrl_handler);\r\nmedia_entity_cleanup(&entity->subdev.entity);\r\nmutex_destroy(&entity->lock);\r\n}
