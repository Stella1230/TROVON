static int __init get_mux_port_count(struct parisc_device *dev)\r\n{\r\nint status;\r\nu8 iodc_data[32];\r\nunsigned long bytecnt;\r\nif(dev->id.hversion == 0x15)\r\nreturn 1;\r\nstatus = pdc_iodc_read(&bytecnt, dev->hpa.start, 0, iodc_data, 32);\r\nBUG_ON(status != PDC_OK);\r\nreturn ((((iodc_data)[4] & 0xf0) >> 4) * 8) + 8;\r\n}\r\nstatic unsigned int mux_tx_empty(struct uart_port *port)\r\n{\r\nreturn UART_GET_FIFO_CNT(port) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic void mux_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int mux_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void mux_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void mux_start_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void mux_stop_rx(struct uart_port *port)\r\n{\r\n}\r\nstatic void mux_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic void mux_write(struct uart_port *port)\r\n{\r\nint count;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif(port->x_char) {\r\nUART_PUT_CHAR(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif(uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nmux_stop_tx(port);\r\nreturn;\r\n}\r\ncount = (port->fifosize) - UART_GET_FIFO_CNT(port);\r\ndo {\r\nUART_PUT_CHAR(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif(uart_circ_empty(xmit))\r\nbreak;\r\n} while(--count > 0);\r\nwhile(UART_GET_FIFO_CNT(port))\r\nudelay(1);\r\nif(uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nmux_stop_tx(port);\r\n}\r\nstatic void mux_read(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nint data;\r\n__u32 start_count = port->icount.rx;\r\nwhile(1) {\r\ndata = __raw_readl(port->membase + IO_DATA_REG_OFFSET);\r\nif (MUX_STATUS(data))\r\ncontinue;\r\nif (MUX_EOFIFO(data))\r\nbreak;\r\nport->icount.rx++;\r\nif (MUX_BREAK(data)) {\r\nport->icount.brk++;\r\nif(uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (uart_handle_sysrq_char(port, data & 0xffu))\r\ncontinue;\r\ntty_insert_flip_char(tport, data & 0xFF, TTY_NORMAL);\r\n}\r\nif (start_count != port->icount.rx)\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic int mux_startup(struct uart_port *port)\r\n{\r\nmux_ports[port->line].enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void mux_shutdown(struct uart_port *port)\r\n{\r\nmux_ports[port->line].enabled = 0;\r\n}\r\nstatic void\r\nmux_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\n}\r\nstatic const char *mux_type(struct uart_port *port)\r\n{\r\nreturn "Mux";\r\n}\r\nstatic void mux_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int mux_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mux_config_port(struct uart_port *port, int type)\r\n{\r\nport->type = PORT_MUX;\r\n}\r\nstatic int mux_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif(port->membase == NULL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void mux_poll(unsigned long unused)\r\n{\r\nint i;\r\nfor(i = 0; i < port_cnt; ++i) {\r\nif(!mux_ports[i].enabled)\r\ncontinue;\r\nmux_read(&mux_ports[i].port);\r\nmux_write(&mux_ports[i].port);\r\n}\r\nmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\r\n}\r\nstatic void mux_console_write(struct console *co, const char *s, unsigned count)\r\n{\r\nwhile(UART_GET_FIFO_CNT(&mux_ports[0].port))\r\nudelay(1);\r\nwhile(count--) {\r\nif(*s == '\n') {\r\nUART_PUT_CHAR(&mux_ports[0].port, '\r');\r\n}\r\nUART_PUT_CHAR(&mux_ports[0].port, *s++);\r\n}\r\n}\r\nstatic int mux_console_setup(struct console *co, char *options)\r\n{\r\nreturn 0;\r\n}\r\nstruct tty_driver *mux_console_device(struct console *co, int *index)\r\n{\r\n*index = co->index;\r\nreturn mux_driver.tty_driver;\r\n}\r\nstatic int __init mux_probe(struct parisc_device *dev)\r\n{\r\nint i, status;\r\nint port_count = get_mux_port_count(dev);\r\nprintk(KERN_INFO "Serial mux driver (%d ports) Revision: 0.6\n", port_count);\r\ndev_set_drvdata(&dev->dev, (void *)(long)port_count);\r\nrequest_mem_region(dev->hpa.start + MUX_OFFSET,\r\nport_count * MUX_LINE_OFFSET, "Mux");\r\nif(!port_cnt) {\r\nmux_driver.cons = MUX_CONSOLE;\r\nstatus = uart_register_driver(&mux_driver);\r\nif(status) {\r\nprintk(KERN_ERR "Serial mux: Unable to register driver.\n");\r\nreturn 1;\r\n}\r\n}\r\nfor(i = 0; i < port_count; ++i, ++port_cnt) {\r\nstruct uart_port *port = &mux_ports[port_cnt].port;\r\nport->iobase = 0;\r\nport->mapbase = dev->hpa.start + MUX_OFFSET +\r\n(i * MUX_LINE_OFFSET);\r\nport->membase = ioremap_nocache(port->mapbase, MUX_LINE_OFFSET);\r\nport->iotype = UPIO_MEM;\r\nport->type = PORT_MUX;\r\nport->irq = 0;\r\nport->uartclk = 0;\r\nport->fifosize = MUX_FIFO_SIZE;\r\nport->ops = &mux_pops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->line = port_cnt;\r\nport->timeout = HZ / 50;\r\nspin_lock_init(&port->lock);\r\nstatus = uart_add_one_port(&mux_driver, port);\r\nBUG_ON(status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mux_remove(struct parisc_device *dev)\r\n{\r\nint i, j;\r\nint port_count = (long)dev_get_drvdata(&dev->dev);\r\nfor(i = 0; i < port_cnt; ++i) {\r\nif(mux_ports[i].port.mapbase == dev->hpa.start + MUX_OFFSET)\r\nbreak;\r\n}\r\nBUG_ON(i + port_count > port_cnt);\r\nfor(j = 0; j < port_count; ++j, ++i) {\r\nstruct uart_port *port = &mux_ports[i].port;\r\nuart_remove_one_port(&mux_driver, port);\r\nif(port->membase)\r\niounmap(port->membase);\r\n}\r\nrelease_mem_region(dev->hpa.start + MUX_OFFSET, port_count * MUX_LINE_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int __init mux_init(void)\r\n{\r\nregister_parisc_driver(&builtin_serial_mux_driver);\r\nregister_parisc_driver(&serial_mux_driver);\r\nif(port_cnt > 0) {\r\ninit_timer(&mux_timer);\r\nmux_timer.function = mux_poll;\r\nmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\r\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\r\nregister_console(&mux_console);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mux_exit(void)\r\n{\r\nif(port_cnt > 0) {\r\ndel_timer_sync(&mux_timer);\r\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\r\nunregister_console(&mux_console);\r\n#endif\r\n}\r\nunregister_parisc_driver(&builtin_serial_mux_driver);\r\nunregister_parisc_driver(&serial_mux_driver);\r\nuart_unregister_driver(&mux_driver);\r\n}
