static irqreturn_t pm860x_irq(int irq, void *data)\r\n{\r\nstruct pm860x_chip *chip = data;\r\nstruct pm860x_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nint read_reg = -1, value = 0;\r\nint i;\r\ni2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\nfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\r\nirq_data = &pm860x_irqs[i];\r\nif (read_reg != irq_data->reg) {\r\nread_reg = irq_data->reg;\r\nvalue = pm860x_reg_read(i2c, irq_data->reg);\r\n}\r\nif (value & irq_data->enable)\r\nhandle_nested_irq(chip->irq_base + i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pm860x_irq_lock(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&chip->irq_lock);\r\n}\r\nstatic void pm860x_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct pm860x_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct pm860x_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nstatic unsigned char cached[3] = {0x0, 0x0, 0x0};\r\nunsigned char mask[3];\r\nint i;\r\ni2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\nfor (i = 0; i < 3; i++)\r\nmask[i] = cached[i];\r\nfor (i = 0; i < ARRAY_SIZE(pm860x_irqs); i++) {\r\nirq_data = &pm860x_irqs[i];\r\nswitch (irq_data->mask_reg) {\r\ncase PM8607_INT_MASK_1:\r\nmask[0] &= ~irq_data->offs;\r\nmask[0] |= irq_data->enable;\r\nbreak;\r\ncase PM8607_INT_MASK_2:\r\nmask[1] &= ~irq_data->offs;\r\nmask[1] |= irq_data->enable;\r\nbreak;\r\ncase PM8607_INT_MASK_3:\r\nmask[2] &= ~irq_data->offs;\r\nmask[2] |= irq_data->enable;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "wrong IRQ\n");\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (mask[i] != cached[i]) {\r\ncached[i] = mask[i];\r\npm860x_reg_write(i2c, PM8607_INT_MASK_1 + i, mask[i]);\r\n}\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic void pm860x_irq_enable(struct irq_data *data)\r\n{\r\npm860x_irqs[data->hwirq].enable = pm860x_irqs[data->hwirq].offs;\r\n}\r\nstatic void pm860x_irq_disable(struct irq_data *data)\r\n{\r\npm860x_irqs[data->hwirq].enable = 0;\r\n}\r\nstatic int pm860x_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_data(virq, d->host_data);\r\nirq_set_chip_and_handler(virq, &pm860x_irq_chip, handle_edge_irq);\r\nirq_set_nested_thread(virq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int device_irq_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ?\r\nchip->client : chip->companion;\r\nunsigned char status_buf[INT_STATUS_NUM];\r\nunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\r\nint data, mask, ret = -EINVAL;\r\nint nr_irqs, irq_base = -1;\r\nstruct device_node *node = i2c->dev.of_node;\r\nmask = PM8607_B0_MISC1_INV_INT | PM8607_B0_MISC1_INT_CLEAR\r\n| PM8607_B0_MISC1_INT_MASK;\r\ndata = 0;\r\nchip->irq_mode = 0;\r\nif (pdata && pdata->irq_mode) {\r\ndata |= PM8607_B0_MISC1_INT_CLEAR;\r\nchip->irq_mode = 1;\r\n}\r\nret = pm860x_set_bits(i2c, PM8607_B0_MISC1, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\nmemset(status_buf, 0, INT_STATUS_NUM);\r\nret = pm860x_bulk_write(i2c, PM8607_INT_MASK_1,\r\nINT_STATUS_NUM, status_buf);\r\nif (ret < 0)\r\ngoto out;\r\nif (chip->irq_mode) {\r\nmemset(status_buf, 0xFF, INT_STATUS_NUM);\r\nret = pm860x_bulk_write(i2c, PM8607_INT_STATUS1,\r\nINT_STATUS_NUM, status_buf);\r\n} else {\r\nret = pm860x_bulk_read(i2c, PM8607_INT_STATUS1,\r\nINT_STATUS_NUM, status_buf);\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nmutex_init(&chip->irq_lock);\r\nif (pdata && pdata->irq_base)\r\nirq_base = pdata->irq_base;\r\nnr_irqs = ARRAY_SIZE(pm860x_irqs);\r\nchip->irq_base = irq_alloc_descs(irq_base, 0, nr_irqs, 0);\r\nif (chip->irq_base < 0) {\r\ndev_err(&i2c->dev, "Failed to allocate interrupts, ret:%d\n",\r\nchip->irq_base);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nirq_domain_add_legacy(node, nr_irqs, chip->irq_base, 0,\r\n&pm860x_irq_domain_ops, chip);\r\nchip->core_irq = i2c->irq;\r\nif (!chip->core_irq)\r\ngoto out;\r\nret = request_threaded_irq(chip->core_irq, NULL, pm860x_irq,\r\nflags | IRQF_ONESHOT, "88pm860x", chip);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to request IRQ: %d\n", ret);\r\nchip->core_irq = 0;\r\n}\r\nreturn 0;\r\nout:\r\nchip->core_irq = 0;\r\nreturn ret;\r\n}\r\nstatic void device_irq_exit(struct pm860x_chip *chip)\r\n{\r\nif (chip->core_irq)\r\nfree_irq(chip->core_irq, chip);\r\n}\r\nint pm8606_osc_enable(struct pm860x_chip *chip, unsigned short client)\r\n{\r\nint ret = -EIO;\r\nstruct i2c_client *i2c = (chip->id == CHIP_PM8606) ?\r\nchip->client : chip->companion;\r\ndev_dbg(chip->dev, "%s(B): client=0x%x\n", __func__, client);\r\ndev_dbg(chip->dev, "%s(B): vote=0x%x status=%d\n",\r\n__func__, chip->osc_vote,\r\nchip->osc_status);\r\nmutex_lock(&chip->osc_lock);\r\nchip->osc_vote |= client;\r\nif (chip->osc_status != PM8606_REF_GP_OSC_ON) {\r\nchip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;\r\nif (pm860x_set_bits(i2c, PM8606_VSYS,\r\nPM8606_VSYS_EN, PM8606_VSYS_EN))\r\ngoto out;\r\nif (pm860x_set_bits(i2c, PM8606_MISC,\r\nPM8606_MISC_OSC_EN, PM8606_MISC_OSC_EN))\r\ngoto out;\r\nchip->osc_status = PM8606_REF_GP_OSC_ON;\r\n}\r\nmutex_unlock(&chip->osc_lock);\r\ndev_dbg(chip->dev, "%s(A): vote=0x%x status=%d ret=%d\n",\r\n__func__, chip->osc_vote,\r\nchip->osc_status, ret);\r\nreturn 0;\r\nout:\r\nmutex_unlock(&chip->osc_lock);\r\nreturn ret;\r\n}\r\nint pm8606_osc_disable(struct pm860x_chip *chip, unsigned short client)\r\n{\r\nint ret = -EIO;\r\nstruct i2c_client *i2c = (chip->id == CHIP_PM8606) ?\r\nchip->client : chip->companion;\r\ndev_dbg(chip->dev, "%s(B): client=0x%x\n", __func__, client);\r\ndev_dbg(chip->dev, "%s(B): vote=0x%x status=%d\n",\r\n__func__, chip->osc_vote,\r\nchip->osc_status);\r\nmutex_lock(&chip->osc_lock);\r\nchip->osc_vote &= ~(client);\r\nif ((chip->osc_status != PM8606_REF_GP_OSC_OFF) &&\r\n(chip->osc_vote == REF_GP_NO_CLIENTS)) {\r\nchip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;\r\nif (pm860x_set_bits(i2c, PM8606_VSYS, PM8606_VSYS_EN, 0))\r\ngoto out;\r\nif (pm860x_set_bits(i2c, PM8606_MISC, PM8606_MISC_OSC_EN, 0))\r\ngoto out;\r\nchip->osc_status = PM8606_REF_GP_OSC_OFF;\r\n}\r\nmutex_unlock(&chip->osc_lock);\r\ndev_dbg(chip->dev, "%s(A): vote=0x%x status=%d ret=%d\n",\r\n__func__, chip->osc_vote,\r\nchip->osc_status, ret);\r\nreturn 0;\r\nout:\r\nmutex_unlock(&chip->osc_lock);\r\nreturn ret;\r\n}\r\nstatic void device_osc_init(struct i2c_client *i2c)\r\n{\r\nstruct pm860x_chip *chip = i2c_get_clientdata(i2c);\r\nmutex_init(&chip->osc_lock);\r\npm860x_set_bits(i2c, PM8606_VSYS, PM8606_VSYS_EN, 0);\r\npm860x_set_bits(i2c, PM8606_MISC, PM8606_MISC_OSC_EN, 0);\r\nchip->osc_vote = REF_GP_NO_CLIENTS;\r\nchip->osc_status = PM8606_REF_GP_OSC_OFF;\r\n}\r\nstatic void device_bk_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret, i;\r\nif (pdata && pdata->backlight) {\r\nif (pdata->num_backlights > ARRAY_SIZE(bk_devs))\r\npdata->num_backlights = ARRAY_SIZE(bk_devs);\r\nfor (i = 0; i < pdata->num_backlights; i++) {\r\nbk_devs[i].platform_data = &pdata->backlight[i];\r\nbk_devs[i].pdata_size =\r\nsizeof(struct pm860x_backlight_pdata);\r\n}\r\n}\r\nret = mfd_add_devices(chip->dev, 0, bk_devs,\r\nARRAY_SIZE(bk_devs), NULL, 0, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add backlight subdev\n");\r\n}\r\nstatic void device_led_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret, i;\r\nif (pdata && pdata->led) {\r\nif (pdata->num_leds > ARRAY_SIZE(led_devs))\r\npdata->num_leds = ARRAY_SIZE(led_devs);\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_devs[i].platform_data = &pdata->led[i];\r\nled_devs[i].pdata_size =\r\nsizeof(struct pm860x_led_pdata);\r\n}\r\n}\r\nret = mfd_add_devices(chip->dev, 0, led_devs,\r\nARRAY_SIZE(led_devs), NULL, 0, NULL);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add led subdev\n");\r\nreturn;\r\n}\r\n}\r\nstatic void device_regulator_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata == NULL)\r\nreturn;\r\nif (pdata->buck1) {\r\nreg_devs[0].platform_data = pdata->buck1;\r\nreg_devs[0].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->buck2) {\r\nreg_devs[1].platform_data = pdata->buck2;\r\nreg_devs[1].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->buck3) {\r\nreg_devs[2].platform_data = pdata->buck3;\r\nreg_devs[2].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo1) {\r\nreg_devs[3].platform_data = pdata->ldo1;\r\nreg_devs[3].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo2) {\r\nreg_devs[4].platform_data = pdata->ldo2;\r\nreg_devs[4].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo3) {\r\nreg_devs[5].platform_data = pdata->ldo3;\r\nreg_devs[5].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo4) {\r\nreg_devs[6].platform_data = pdata->ldo4;\r\nreg_devs[6].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo5) {\r\nreg_devs[7].platform_data = pdata->ldo5;\r\nreg_devs[7].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo6) {\r\nreg_devs[8].platform_data = pdata->ldo6;\r\nreg_devs[8].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo7) {\r\nreg_devs[9].platform_data = pdata->ldo7;\r\nreg_devs[9].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo8) {\r\nreg_devs[10].platform_data = pdata->ldo8;\r\nreg_devs[10].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo9) {\r\nreg_devs[11].platform_data = pdata->ldo9;\r\nreg_devs[11].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo10) {\r\nreg_devs[12].platform_data = pdata->ldo10;\r\nreg_devs[12].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo12) {\r\nreg_devs[13].platform_data = pdata->ldo12;\r\nreg_devs[13].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo_vibrator) {\r\nreg_devs[14].platform_data = pdata->ldo_vibrator;\r\nreg_devs[14].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nif (pdata->ldo14) {\r\nreg_devs[15].platform_data = pdata->ldo14;\r\nreg_devs[15].pdata_size = sizeof(struct regulator_init_data);\r\n}\r\nret = mfd_add_devices(chip->dev, 0, reg_devs,\r\nARRAY_SIZE(reg_devs), NULL, 0, NULL);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add regulator subdev\n");\r\nreturn;\r\n}\r\n}\r\nstatic void device_rtc_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (!pdata)\r\nreturn;\r\nrtc_devs[0].platform_data = pdata->rtc;\r\nrtc_devs[0].pdata_size = sizeof(struct pm860x_rtc_pdata);\r\nrtc_devs[0].num_resources = ARRAY_SIZE(rtc_resources);\r\nrtc_devs[0].resources = &rtc_resources[0];\r\nret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\r\nARRAY_SIZE(rtc_devs), &rtc_resources[0],\r\nchip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\n}\r\nstatic void device_touch_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata == NULL)\r\nreturn;\r\ntouch_devs[0].platform_data = pdata->touch;\r\ntouch_devs[0].pdata_size = sizeof(struct pm860x_touch_pdata);\r\ntouch_devs[0].num_resources = ARRAY_SIZE(touch_resources);\r\ntouch_devs[0].resources = &touch_resources[0];\r\nret = mfd_add_devices(chip->dev, 0, &touch_devs[0],\r\nARRAY_SIZE(touch_devs), &touch_resources[0],\r\nchip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add touch subdev\n");\r\n}\r\nstatic void device_power_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata == NULL)\r\nreturn;\r\npower_devs[0].platform_data = pdata->power;\r\npower_devs[0].pdata_size = sizeof(struct pm860x_power_pdata);\r\npower_devs[0].num_resources = ARRAY_SIZE(battery_resources);\r\npower_devs[0].resources = &battery_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[0], 1,\r\n&battery_resources[0], chip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add battery subdev\n");\r\npower_devs[1].platform_data = pdata->power;\r\npower_devs[1].pdata_size = sizeof(struct pm860x_power_pdata);\r\npower_devs[1].num_resources = ARRAY_SIZE(charger_resources);\r\npower_devs[1].resources = &charger_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[1], 1,\r\n&charger_resources[0], chip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add charger subdev\n");\r\npower_devs[2].platform_data = &preg_init_data;\r\npower_devs[2].pdata_size = sizeof(struct regulator_init_data);\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[2], 1,\r\nNULL, chip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add preg subdev\n");\r\nif (pdata->chg_desc) {\r\npdata->chg_desc->charger_regulators =\r\n&chg_desc_regulator_data[0];\r\npdata->chg_desc->num_charger_regulators =\r\nARRAY_SIZE(chg_desc_regulator_data),\r\npower_devs[3].platform_data = pdata->chg_desc;\r\npower_devs[3].pdata_size = sizeof(*pdata->chg_desc);\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[3], 1,\r\nNULL, chip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add chg-manager subdev\n");\r\n}\r\n}\r\nstatic void device_onkey_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nonkey_devs[0].num_resources = ARRAY_SIZE(onkey_resources);\r\nonkey_devs[0].resources = &onkey_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\r\nARRAY_SIZE(onkey_devs), &onkey_resources[0],\r\nchip->irq_base, NULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\n}\r\nstatic void device_codec_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\ncodec_devs[0].num_resources = ARRAY_SIZE(codec_resources);\r\ncodec_devs[0].resources = &codec_resources[0],\r\nret = mfd_add_devices(chip->dev, 0, &codec_devs[0],\r\nARRAY_SIZE(codec_devs), &codec_resources[0], 0,\r\nNULL);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to add codec subdev\n");\r\n}\r\nstatic void device_8607_init(struct pm860x_chip *chip,\r\nstruct i2c_client *i2c,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint data, ret;\r\nret = pm860x_reg_read(i2c, PM8607_CHIP_ID);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);\r\ngoto out;\r\n}\r\nswitch (ret & PM8607_VERSION_MASK) {\r\ncase 0x40:\r\ncase 0x50:\r\ndev_info(chip->dev, "Marvell 88PM8607 (ID: %02x) detected\n",\r\nret);\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev,\r\n"Failed to detect Marvell 88PM8607. Chip ID: %02x\n",\r\nret);\r\ngoto out;\r\n}\r\nret = pm860x_reg_read(i2c, PM8607_BUCK3);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read BUCK3 register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (ret & PM8607_BUCK3_DOUBLE)\r\nchip->buck3_double = 1;\r\nret = pm860x_reg_read(i2c, PM8607_B0_MISC1);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read MISC1 register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (pdata && (pdata->i2c_port == PI2C_PORT))\r\ndata = PM8607_B0_MISC1_PI2C;\r\nelse\r\ndata = 0;\r\nret = pm860x_set_bits(i2c, PM8607_B0_MISC1, PM8607_B0_MISC1_PI2C, data);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to access MISC1:%d\n", ret);\r\ngoto out;\r\n}\r\nret = device_irq_init(chip, pdata);\r\nif (ret < 0)\r\ngoto out;\r\ndevice_regulator_init(chip, pdata);\r\ndevice_rtc_init(chip, pdata);\r\ndevice_onkey_init(chip, pdata);\r\ndevice_touch_init(chip, pdata);\r\ndevice_power_init(chip, pdata);\r\ndevice_codec_init(chip, pdata);\r\nout:\r\nreturn;\r\n}\r\nstatic void device_8606_init(struct pm860x_chip *chip,\r\nstruct i2c_client *i2c,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\ndevice_osc_init(i2c);\r\ndevice_bk_init(chip, pdata);\r\ndevice_led_init(chip, pdata);\r\n}\r\nstatic int pm860x_device_init(struct pm860x_chip *chip,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nchip->core_irq = 0;\r\nswitch (chip->id) {\r\ncase CHIP_PM8606:\r\ndevice_8606_init(chip, chip->client, pdata);\r\nbreak;\r\ncase CHIP_PM8607:\r\ndevice_8607_init(chip, chip->client, pdata);\r\nbreak;\r\n}\r\nif (chip->companion) {\r\nswitch (chip->id) {\r\ncase CHIP_PM8607:\r\ndevice_8606_init(chip, chip->companion, pdata);\r\nbreak;\r\ncase CHIP_PM8606:\r\ndevice_8607_init(chip, chip->companion, pdata);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pm860x_device_exit(struct pm860x_chip *chip)\r\n{\r\ndevice_irq_exit(chip);\r\nmfd_remove_devices(chip->dev);\r\n}\r\nstatic int verify_addr(struct i2c_client *i2c)\r\n{\r\nunsigned short addr_8607[] = {0x30, 0x34};\r\nunsigned short addr_8606[] = {0x10, 0x11};\r\nint size, i;\r\nif (i2c == NULL)\r\nreturn 0;\r\nsize = ARRAY_SIZE(addr_8606);\r\nfor (i = 0; i < size; i++) {\r\nif (i2c->addr == *(addr_8606 + i))\r\nreturn CHIP_PM8606;\r\n}\r\nsize = ARRAY_SIZE(addr_8607);\r\nfor (i = 0; i < size; i++) {\r\nif (i2c->addr == *(addr_8607 + i))\r\nreturn CHIP_PM8607;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_dt_init(struct device_node *np,\r\nstruct device *dev,\r\nstruct pm860x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (of_get_property(np, "marvell,88pm860x-irq-read-clr", NULL))\r\npdata->irq_mode = 1;\r\nret = of_property_read_u32(np, "marvell,88pm860x-slave-addr",\r\n&pdata->companion_addr);\r\nif (ret) {\r\ndev_err(dev,\r\n"Not found \"marvell,88pm860x-slave-addr\" property\n");\r\npdata->companion_addr = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pm860x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *node = client->dev.of_node;\r\nstruct pm860x_chip *chip;\r\nint ret;\r\nif (node && !pdata) {\r\npdata = devm_kzalloc(&client->dev,\r\nsizeof(struct pm860x_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = pm860x_dt_init(node, &client->dev, pdata);\r\nif (ret)\r\nreturn ret;\r\n} else if (!pdata) {\r\npr_info("No platform data in %s!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nchip = devm_kzalloc(&client->dev,\r\nsizeof(struct pm860x_chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->id = verify_addr(client);\r\nchip->regmap = devm_regmap_init_i2c(client, &pm860x_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nret = PTR_ERR(chip->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nchip->client = client;\r\ni2c_set_clientdata(client, chip);\r\nchip->dev = &client->dev;\r\ndev_set_drvdata(chip->dev, chip);\r\nif (pdata->companion_addr && (pdata->companion_addr != client->addr)) {\r\nchip->companion_addr = pdata->companion_addr;\r\nchip->companion = i2c_new_dummy(chip->client->adapter,\r\nchip->companion_addr);\r\nif (!chip->companion) {\r\ndev_err(&client->dev,\r\n"Failed to allocate I2C companion device\n");\r\nreturn -ENODEV;\r\n}\r\nchip->regmap_companion = regmap_init_i2c(chip->companion,\r\n&pm860x_regmap_config);\r\nif (IS_ERR(chip->regmap_companion)) {\r\nret = PTR_ERR(chip->regmap_companion);\r\ndev_err(&chip->companion->dev,\r\n"Failed to allocate register map: %d\n", ret);\r\ni2c_unregister_device(chip->companion);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(chip->companion, chip);\r\n}\r\npm860x_device_init(chip, pdata);\r\nreturn 0;\r\n}\r\nstatic int pm860x_remove(struct i2c_client *client)\r\n{\r\nstruct pm860x_chip *chip = i2c_get_clientdata(client);\r\npm860x_device_exit(chip);\r\nif (chip->companion) {\r\nregmap_exit(chip->regmap_companion);\r\ni2c_unregister_device(chip->companion);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct pm860x_chip *chip = i2c_get_clientdata(client);\r\nif (device_may_wakeup(dev) && chip->wakeup_flag)\r\nenable_irq_wake(chip->core_irq);\r\nreturn 0;\r\n}\r\nstatic int pm860x_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct pm860x_chip *chip = i2c_get_clientdata(client);\r\nif (device_may_wakeup(dev) && chip->wakeup_flag)\r\ndisable_irq_wake(chip->core_irq);\r\nreturn 0;\r\n}\r\nstatic int __init pm860x_i2c_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&pm860x_driver);\r\nif (ret != 0)\r\npr_err("Failed to register 88PM860x I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit pm860x_i2c_exit(void)\r\n{\r\ni2c_del_driver(&pm860x_driver);\r\n}
