static int ahci_platform_enable_phys(struct ahci_host_priv *hpriv)\r\n{\r\nint rc, i;\r\nfor (i = 0; i < hpriv->nports; i++) {\r\nif (!hpriv->phys[i])\r\ncontinue;\r\nrc = phy_init(hpriv->phys[i]);\r\nif (rc)\r\ngoto disable_phys;\r\nrc = phy_power_on(hpriv->phys[i]);\r\nif (rc) {\r\nphy_exit(hpriv->phys[i]);\r\ngoto disable_phys;\r\n}\r\n}\r\nreturn 0;\r\ndisable_phys:\r\nwhile (--i >= 0) {\r\nphy_power_off(hpriv->phys[i]);\r\nphy_exit(hpriv->phys[i]);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ahci_platform_disable_phys(struct ahci_host_priv *hpriv)\r\n{\r\nint i;\r\nfor (i = 0; i < hpriv->nports; i++) {\r\nif (!hpriv->phys[i])\r\ncontinue;\r\nphy_power_off(hpriv->phys[i]);\r\nphy_exit(hpriv->phys[i]);\r\n}\r\n}\r\nint ahci_platform_enable_clks(struct ahci_host_priv *hpriv)\r\n{\r\nint c, rc;\r\nfor (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++) {\r\nrc = clk_prepare_enable(hpriv->clks[c]);\r\nif (rc)\r\ngoto disable_unprepare_clk;\r\n}\r\nreturn 0;\r\ndisable_unprepare_clk:\r\nwhile (--c >= 0)\r\nclk_disable_unprepare(hpriv->clks[c]);\r\nreturn rc;\r\n}\r\nvoid ahci_platform_disable_clks(struct ahci_host_priv *hpriv)\r\n{\r\nint c;\r\nfor (c = AHCI_MAX_CLKS - 1; c >= 0; c--)\r\nif (hpriv->clks[c])\r\nclk_disable_unprepare(hpriv->clks[c]);\r\n}\r\nint ahci_platform_enable_resources(struct ahci_host_priv *hpriv)\r\n{\r\nint rc;\r\nif (hpriv->target_pwr) {\r\nrc = regulator_enable(hpriv->target_pwr);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = ahci_platform_enable_clks(hpriv);\r\nif (rc)\r\ngoto disable_regulator;\r\nrc = ahci_platform_enable_phys(hpriv);\r\nif (rc)\r\ngoto disable_clks;\r\nreturn 0;\r\ndisable_clks:\r\nahci_platform_disable_clks(hpriv);\r\ndisable_regulator:\r\nif (hpriv->target_pwr)\r\nregulator_disable(hpriv->target_pwr);\r\nreturn rc;\r\n}\r\nvoid ahci_platform_disable_resources(struct ahci_host_priv *hpriv)\r\n{\r\nahci_platform_disable_phys(hpriv);\r\nahci_platform_disable_clks(hpriv);\r\nif (hpriv->target_pwr)\r\nregulator_disable(hpriv->target_pwr);\r\n}\r\nstatic void ahci_platform_put_resources(struct device *dev, void *res)\r\n{\r\nstruct ahci_host_priv *hpriv = res;\r\nint c;\r\nif (hpriv->got_runtime_pm) {\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\n}\r\nfor (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++)\r\nclk_put(hpriv->clks[c]);\r\n}\r\nstruct ahci_host_priv *ahci_platform_get_resources(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct clk *clk;\r\nstruct device_node *child;\r\nint i, enabled_ports = 0, rc = -ENOMEM;\r\nu32 mask_port_map = 0;\r\nif (!devres_open_group(dev, NULL, GFP_KERNEL))\r\nreturn ERR_PTR(-ENOMEM);\r\nhpriv = devres_alloc(ahci_platform_put_resources, sizeof(*hpriv),\r\nGFP_KERNEL);\r\nif (!hpriv)\r\ngoto err_out;\r\ndevres_add(dev, hpriv);\r\nhpriv->mmio = devm_ioremap_resource(dev,\r\nplatform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nif (IS_ERR(hpriv->mmio)) {\r\ndev_err(dev, "no mmio space\n");\r\nrc = PTR_ERR(hpriv->mmio);\r\ngoto err_out;\r\n}\r\nhpriv->target_pwr = devm_regulator_get_optional(dev, "target");\r\nif (IS_ERR(hpriv->target_pwr)) {\r\nrc = PTR_ERR(hpriv->target_pwr);\r\nif (rc == -EPROBE_DEFER)\r\ngoto err_out;\r\nhpriv->target_pwr = NULL;\r\n}\r\nfor (i = 0; i < AHCI_MAX_CLKS; i++) {\r\nif (i == 0)\r\nclk = clk_get(dev, NULL);\r\nelse\r\nclk = of_clk_get(dev->of_node, i);\r\nif (IS_ERR(clk)) {\r\nrc = PTR_ERR(clk);\r\nif (rc == -EPROBE_DEFER)\r\ngoto err_out;\r\nbreak;\r\n}\r\nhpriv->clks[i] = clk;\r\n}\r\nhpriv->nports = of_get_child_count(dev->of_node);\r\nif (hpriv->nports) {\r\nhpriv->phys = devm_kzalloc(dev,\r\nhpriv->nports * sizeof(*hpriv->phys),\r\nGFP_KERNEL);\r\nif (!hpriv->phys) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfor_each_child_of_node(dev->of_node, child) {\r\nu32 port;\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nif (of_property_read_u32(child, "reg", &port)) {\r\nrc = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (port >= hpriv->nports) {\r\ndev_warn(dev, "invalid port number %d\n", port);\r\ncontinue;\r\n}\r\nmask_port_map |= BIT(port);\r\nhpriv->phys[port] = devm_of_phy_get(dev, child, NULL);\r\nif (IS_ERR(hpriv->phys[port])) {\r\nrc = PTR_ERR(hpriv->phys[port]);\r\ndev_err(dev,\r\n"couldn't get PHY in node %s: %d\n",\r\nchild->name, rc);\r\ngoto err_out;\r\n}\r\nenabled_ports++;\r\n}\r\nif (!enabled_ports) {\r\ndev_warn(dev, "No port enabled\n");\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nif (!hpriv->mask_port_map)\r\nhpriv->mask_port_map = mask_port_map;\r\n} else {\r\nstruct phy *phy = devm_phy_get(dev, "sata-phy");\r\nif (!IS_ERR(phy)) {\r\nhpriv->phys = devm_kzalloc(dev, sizeof(*hpriv->phys),\r\nGFP_KERNEL);\r\nif (!hpriv->phys) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nhpriv->phys[0] = phy;\r\nhpriv->nports = 1;\r\n} else {\r\nrc = PTR_ERR(phy);\r\nswitch (rc) {\r\ncase -ENOSYS:\r\nif (of_find_property(dev->of_node, "phys", NULL)) {\r\ndev_err(dev, "couldn't get sata-phy: ENOSYS\n");\r\ngoto err_out;\r\n}\r\ncase -ENODEV:\r\nhpriv->phys = NULL;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\n}\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nhpriv->got_runtime_pm = true;\r\ndevres_remove_group(dev, NULL);\r\nreturn hpriv;\r\nerr_out:\r\ndevres_release_group(dev, NULL);\r\nreturn ERR_PTR(rc);\r\n}\r\nint ahci_platform_init_host(struct platform_device *pdev,\r\nstruct ahci_host_priv *hpriv,\r\nconst struct ata_port_info *pi_template)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ata_port_info pi = *pi_template;\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct ata_host *host;\r\nint i, irq, n_ports, rc;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -EINVAL;\r\n}\r\npi.private_data = (void *)(unsigned long)hpriv->flags;\r\nahci_save_initial_config(dev, hpriv);\r\nif (hpriv->cap & HOST_CAP_NCQ)\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(dev, ppi, n_ports);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nelse\r\ndev_info(dev, "SSS flag set, parallel bus scan disabled\n");\r\nif (pi.flags & ATA_FLAG_EM)\r\nahci_reset_em(host);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_desc(ap, "mmio %pR",\r\nplatform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nif (hpriv->cap & HOST_CAP_64) {\r\nrc = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = dma_coerce_mask_and_coherent(dev,\r\nDMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(dev, "Failed to enable 64-bit DMA.\n");\r\nreturn rc;\r\n}\r\ndev_warn(dev, "Enable 32-bit DMA instead of 64-bit.\n");\r\n}\r\n}\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\nahci_print_info(host, "platform");\r\nreturn ahci_host_activate(host, irq, &ahci_platform_sht);\r\n}\r\nstatic void ahci_host_stop(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nahci_platform_disable_resources(hpriv);\r\n}\r\nint ahci_platform_suspend_host(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(dev, "firmware update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\nreturn ata_host_suspend(host, PMSG_SUSPEND);\r\n}\r\nint ahci_platform_resume_host(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nint rc;\r\nif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nint ahci_platform_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint rc;\r\nrc = ahci_platform_suspend_host(dev);\r\nif (rc)\r\nreturn rc;\r\nahci_platform_disable_resources(hpriv);\r\nreturn 0;\r\n}\r\nint ahci_platform_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint rc;\r\nrc = ahci_platform_enable_resources(hpriv);\r\nif (rc)\r\nreturn rc;\r\nrc = ahci_platform_resume_host(dev);\r\nif (rc)\r\ngoto disable_resources;\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\ndisable_resources:\r\nahci_platform_disable_resources(hpriv);\r\nreturn rc;\r\n}
