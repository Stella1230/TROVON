static int cap_syslog(int type)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_quotactl(int cmds, int type, int id, struct super_block *sb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_quota_on(struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_bprm_check_security(struct linux_binprm *bprm)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_bprm_committing_creds(struct linux_binprm *bprm)\r\n{\r\n}\r\nstatic void cap_bprm_committed_creds(struct linux_binprm *bprm)\r\n{\r\n}\r\nstatic int cap_sb_alloc_security(struct super_block *sb)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_sb_free_security(struct super_block *sb)\r\n{\r\n}\r\nstatic int cap_sb_copy_data(char *orig, char *copy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_remount(struct super_block *sb, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_kern_mount(struct super_block *sb, int flags, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_show_options(struct seq_file *m, struct super_block *sb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_statfs(struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_mount(const char *dev_name, struct path *path,\r\nconst char *type, unsigned long flags, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_umount(struct vfsmount *mnt, int flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_pivotroot(struct path *old_path, struct path *new_path)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_set_mnt_opts(struct super_block *sb,\r\nstruct security_mnt_opts *opts,\r\nunsigned long kern_flags,\r\nunsigned long *set_kern_flags)\r\n{\r\nif (unlikely(opts->num_mnt_opts))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int cap_sb_clone_mnt_opts(const struct super_block *oldsb,\r\nstruct super_block *newsb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_dentry_init_security(struct dentry *dentry, int mode,\r\nstruct qstr *name, void **ctx,\r\nu32 *ctxlen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_inode_alloc_security(struct inode *inode)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_inode_free_security(struct inode *inode)\r\n{\r\n}\r\nstatic int cap_inode_init_security(struct inode *inode, struct inode *dir,\r\nconst struct qstr *qstr, const char **name,\r\nvoid **value, size_t *len)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_inode_create(struct inode *inode, struct dentry *dentry,\r\numode_t mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_link(struct dentry *old_dentry, struct inode *inode,\r\nstruct dentry *new_dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_unlink(struct inode *inode, struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_symlink(struct inode *inode, struct dentry *dentry,\r\nconst char *name)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_mkdir(struct inode *inode, struct dentry *dentry,\r\numode_t mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_rmdir(struct inode *inode, struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_mknod(struct inode *inode, struct dentry *dentry,\r\numode_t mode, dev_t dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_rename(struct inode *old_inode, struct dentry *old_dentry,\r\nstruct inode *new_inode, struct dentry *new_dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_readlink(struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_follow_link(struct dentry *dentry,\r\nstruct nameidata *nameidata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_permission(struct inode *inode, int mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_inode_post_setxattr(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\n}\r\nstatic int cap_inode_getxattr(struct dentry *dentry, const char *name)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_listxattr(struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_getsecurity(const struct inode *inode, const char *name,\r\nvoid **buffer, bool alloc)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_inode_setsecurity(struct inode *inode, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_inode_listsecurity(struct inode *inode, char *buffer,\r\nsize_t buffer_size)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_inode_getsecid(const struct inode *inode, u32 *secid)\r\n{\r\n*secid = 0;\r\n}\r\nstatic int cap_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,\r\nunsigned int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_rmdir(struct path *dir, struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_unlink(struct path *dir, struct dentry *dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_symlink(struct path *dir, struct dentry *dentry,\r\nconst char *old_name)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_link(struct dentry *old_dentry, struct path *new_dir,\r\nstruct dentry *new_dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_rename(struct path *old_path, struct dentry *old_dentry,\r\nstruct path *new_path, struct dentry *new_dentry)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_truncate(struct path *path)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_chmod(struct path *path, umode_t mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_chown(struct path *path, kuid_t uid, kgid_t gid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_path_chroot(struct path *root)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_permission(struct file *file, int mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_alloc_security(struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_file_free_security(struct file *file)\r\n{\r\n}\r\nstatic int cap_file_ioctl(struct file *file, unsigned int command,\r\nunsigned long arg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\r\nunsigned long prot)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_lock(struct file *file, unsigned int cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_fcntl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_file_set_fowner(struct file *file)\r\n{\r\nreturn;\r\n}\r\nstatic int cap_file_send_sigiotask(struct task_struct *tsk,\r\nstruct fown_struct *fown, int sig)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_receive(struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_file_open(struct file *file, const struct cred *cred)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_create(unsigned long clone_flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_task_free(struct task_struct *task)\r\n{\r\n}\r\nstatic int cap_cred_alloc_blank(struct cred *cred, gfp_t gfp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_cred_free(struct cred *cred)\r\n{\r\n}\r\nstatic int cap_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_cred_transfer(struct cred *new, const struct cred *old)\r\n{\r\n}\r\nstatic int cap_kernel_act_as(struct cred *new, u32 secid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_kernel_create_files_as(struct cred *new, struct inode *inode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_kernel_fw_from_file(struct file *file, char *buf, size_t size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_kernel_module_request(char *kmod_name)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_kernel_module_from_file(struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_setpgid(struct task_struct *p, pid_t pgid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_getpgid(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_getsid(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_task_getsecid(struct task_struct *p, u32 *secid)\r\n{\r\n*secid = 0;\r\n}\r\nstatic int cap_task_getioprio(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_setrlimit(struct task_struct *p, unsigned int resource,\r\nstruct rlimit *new_rlim)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_getscheduler(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_movememory(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_wait(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_task_kill(struct task_struct *p, struct siginfo *info,\r\nint sig, u32 secid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_task_to_inode(struct task_struct *p, struct inode *inode)\r\n{\r\n}\r\nstatic int cap_ipc_permission(struct kern_ipc_perm *ipcp, short flag)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)\r\n{\r\n*secid = 0;\r\n}\r\nstatic int cap_msg_msg_alloc_security(struct msg_msg *msg)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_msg_msg_free_security(struct msg_msg *msg)\r\n{\r\n}\r\nstatic int cap_msg_queue_alloc_security(struct msg_queue *msq)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_msg_queue_free_security(struct msg_queue *msq)\r\n{\r\n}\r\nstatic int cap_msg_queue_associate(struct msg_queue *msq, int msqflg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_msg_queue_msgctl(struct msg_queue *msq, int cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,\r\nint msgflg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,\r\nstruct task_struct *target, long type, int mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_shm_alloc_security(struct shmid_kernel *shp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_shm_free_security(struct shmid_kernel *shp)\r\n{\r\n}\r\nstatic int cap_shm_associate(struct shmid_kernel *shp, int shmflg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_shm_shmctl(struct shmid_kernel *shp, int cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,\r\nint shmflg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sem_alloc_security(struct sem_array *sma)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_sem_free_security(struct sem_array *sma)\r\n{\r\n}\r\nstatic int cap_sem_associate(struct sem_array *sma, int semflg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sem_semctl(struct sem_array *sma, int cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_sem_semop(struct sem_array *sma, struct sembuf *sops,\r\nunsigned nsops, int alter)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_unix_stream_connect(struct sock *sock, struct sock *other,\r\nstruct sock *newsk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_unix_may_send(struct socket *sock, struct socket *other)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_create(int family, int type, int protocol, int kern)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_post_create(struct socket *sock, int family, int type,\r\nint protocol, int kern)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_bind(struct socket *sock, struct sockaddr *address,\r\nint addrlen)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_connect(struct socket *sock, struct sockaddr *address,\r\nint addrlen)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_listen(struct socket *sock, int backlog)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_accept(struct socket *sock, struct socket *newsock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_recvmsg(struct socket *sock, struct msghdr *msg,\r\nint size, int flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_getsockname(struct socket *sock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_getpeername(struct socket *sock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_setsockopt(struct socket *sock, int level, int optname)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_getsockopt(struct socket *sock, int level, int optname)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_shutdown(struct socket *sock, int how)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_socket_getpeersec_stream(struct socket *sock,\r\nchar __user *optval,\r\nint __user *optlen, unsigned len)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int cap_socket_getpeersec_dgram(struct socket *sock,\r\nstruct sk_buff *skb, u32 *secid)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int cap_sk_alloc_security(struct sock *sk, int family, gfp_t priority)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_sk_free_security(struct sock *sk)\r\n{\r\n}\r\nstatic void cap_sk_clone_security(const struct sock *sk, struct sock *newsk)\r\n{\r\n}\r\nstatic void cap_sk_getsecid(struct sock *sk, u32 *secid)\r\n{\r\n}\r\nstatic void cap_sock_graft(struct sock *sk, struct socket *parent)\r\n{\r\n}\r\nstatic int cap_inet_conn_request(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_inet_csk_clone(struct sock *newsk,\r\nconst struct request_sock *req)\r\n{\r\n}\r\nstatic void cap_inet_conn_established(struct sock *sk, struct sk_buff *skb)\r\n{\r\n}\r\nstatic int cap_secmark_relabel_packet(u32 secid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_secmark_refcount_inc(void)\r\n{\r\n}\r\nstatic void cap_secmark_refcount_dec(void)\r\n{\r\n}\r\nstatic void cap_req_classify_flow(const struct request_sock *req,\r\nstruct flowi *fl)\r\n{\r\n}\r\nstatic int cap_tun_dev_alloc_security(void **security)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_tun_dev_free_security(void *security)\r\n{\r\n}\r\nstatic int cap_tun_dev_create(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_tun_dev_attach_queue(void *security)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_tun_dev_attach(struct sock *sk, void *security)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_tun_dev_open(void *security)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_skb_owned_by(struct sk_buff *skb, struct sock *sk)\r\n{\r\n}\r\nstatic int cap_xfrm_policy_alloc_security(struct xfrm_sec_ctx **ctxp,\r\nstruct xfrm_user_sec_ctx *sec_ctx,\r\ngfp_t gfp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_xfrm_policy_clone_security(struct xfrm_sec_ctx *old_ctx,\r\nstruct xfrm_sec_ctx **new_ctxp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_xfrm_policy_free_security(struct xfrm_sec_ctx *ctx)\r\n{\r\n}\r\nstatic int cap_xfrm_policy_delete_security(struct xfrm_sec_ctx *ctx)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_xfrm_state_alloc(struct xfrm_state *x,\r\nstruct xfrm_user_sec_ctx *sec_ctx)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_xfrm_state_alloc_acquire(struct xfrm_state *x,\r\nstruct xfrm_sec_ctx *polsec,\r\nu32 secid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_xfrm_state_free_security(struct xfrm_state *x)\r\n{\r\n}\r\nstatic int cap_xfrm_state_delete_security(struct xfrm_state *x)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 sk_sid, u8 dir)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_xfrm_state_pol_flow_match(struct xfrm_state *x,\r\nstruct xfrm_policy *xp,\r\nconst struct flowi *fl)\r\n{\r\nreturn 1;\r\n}\r\nstatic int cap_xfrm_decode_session(struct sk_buff *skb, u32 *fl, int ckall)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_d_instantiate(struct dentry *dentry, struct inode *inode)\r\n{\r\n}\r\nstatic int cap_getprocattr(struct task_struct *p, char *name, char **value)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int cap_setprocattr(struct task_struct *p, char *name, void *value,\r\nsize_t size)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int cap_ismaclabel(const char *name)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\r\n{\r\n*secid = 0;\r\nreturn 0;\r\n}\r\nstatic void cap_release_secctx(char *secdata, u32 seclen)\r\n{\r\n}\r\nstatic int cap_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cap_key_alloc(struct key *key, const struct cred *cred,\r\nunsigned long flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_key_free(struct key *key)\r\n{\r\n}\r\nstatic int cap_key_permission(key_ref_t key_ref, const struct cred *cred,\r\nunsigned perm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_key_getsecurity(struct key *key, char **_buffer)\r\n{\r\n*_buffer = NULL;\r\nreturn 0;\r\n}\r\nstatic int cap_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_audit_rule_known(struct audit_krule *krule)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,\r\nstruct audit_context *actx)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cap_audit_rule_free(void *lsmrule)\r\n{\r\n}\r\nvoid __init security_fixup_ops(struct security_operations *ops)\r\n{\r\nset_to_cap_if_null(ops, ptrace_access_check);\r\nset_to_cap_if_null(ops, ptrace_traceme);\r\nset_to_cap_if_null(ops, capget);\r\nset_to_cap_if_null(ops, capset);\r\nset_to_cap_if_null(ops, capable);\r\nset_to_cap_if_null(ops, quotactl);\r\nset_to_cap_if_null(ops, quota_on);\r\nset_to_cap_if_null(ops, syslog);\r\nset_to_cap_if_null(ops, settime);\r\nset_to_cap_if_null(ops, vm_enough_memory);\r\nset_to_cap_if_null(ops, bprm_set_creds);\r\nset_to_cap_if_null(ops, bprm_committing_creds);\r\nset_to_cap_if_null(ops, bprm_committed_creds);\r\nset_to_cap_if_null(ops, bprm_check_security);\r\nset_to_cap_if_null(ops, bprm_secureexec);\r\nset_to_cap_if_null(ops, sb_alloc_security);\r\nset_to_cap_if_null(ops, sb_free_security);\r\nset_to_cap_if_null(ops, sb_copy_data);\r\nset_to_cap_if_null(ops, sb_remount);\r\nset_to_cap_if_null(ops, sb_kern_mount);\r\nset_to_cap_if_null(ops, sb_show_options);\r\nset_to_cap_if_null(ops, sb_statfs);\r\nset_to_cap_if_null(ops, sb_mount);\r\nset_to_cap_if_null(ops, sb_umount);\r\nset_to_cap_if_null(ops, sb_pivotroot);\r\nset_to_cap_if_null(ops, sb_set_mnt_opts);\r\nset_to_cap_if_null(ops, sb_clone_mnt_opts);\r\nset_to_cap_if_null(ops, sb_parse_opts_str);\r\nset_to_cap_if_null(ops, dentry_init_security);\r\nset_to_cap_if_null(ops, inode_alloc_security);\r\nset_to_cap_if_null(ops, inode_free_security);\r\nset_to_cap_if_null(ops, inode_init_security);\r\nset_to_cap_if_null(ops, inode_create);\r\nset_to_cap_if_null(ops, inode_link);\r\nset_to_cap_if_null(ops, inode_unlink);\r\nset_to_cap_if_null(ops, inode_symlink);\r\nset_to_cap_if_null(ops, inode_mkdir);\r\nset_to_cap_if_null(ops, inode_rmdir);\r\nset_to_cap_if_null(ops, inode_mknod);\r\nset_to_cap_if_null(ops, inode_rename);\r\nset_to_cap_if_null(ops, inode_readlink);\r\nset_to_cap_if_null(ops, inode_follow_link);\r\nset_to_cap_if_null(ops, inode_permission);\r\nset_to_cap_if_null(ops, inode_setattr);\r\nset_to_cap_if_null(ops, inode_getattr);\r\nset_to_cap_if_null(ops, inode_setxattr);\r\nset_to_cap_if_null(ops, inode_post_setxattr);\r\nset_to_cap_if_null(ops, inode_getxattr);\r\nset_to_cap_if_null(ops, inode_listxattr);\r\nset_to_cap_if_null(ops, inode_removexattr);\r\nset_to_cap_if_null(ops, inode_need_killpriv);\r\nset_to_cap_if_null(ops, inode_killpriv);\r\nset_to_cap_if_null(ops, inode_getsecurity);\r\nset_to_cap_if_null(ops, inode_setsecurity);\r\nset_to_cap_if_null(ops, inode_listsecurity);\r\nset_to_cap_if_null(ops, inode_getsecid);\r\n#ifdef CONFIG_SECURITY_PATH\r\nset_to_cap_if_null(ops, path_mknod);\r\nset_to_cap_if_null(ops, path_mkdir);\r\nset_to_cap_if_null(ops, path_rmdir);\r\nset_to_cap_if_null(ops, path_unlink);\r\nset_to_cap_if_null(ops, path_symlink);\r\nset_to_cap_if_null(ops, path_link);\r\nset_to_cap_if_null(ops, path_rename);\r\nset_to_cap_if_null(ops, path_truncate);\r\nset_to_cap_if_null(ops, path_chmod);\r\nset_to_cap_if_null(ops, path_chown);\r\nset_to_cap_if_null(ops, path_chroot);\r\n#endif\r\nset_to_cap_if_null(ops, file_permission);\r\nset_to_cap_if_null(ops, file_alloc_security);\r\nset_to_cap_if_null(ops, file_free_security);\r\nset_to_cap_if_null(ops, file_ioctl);\r\nset_to_cap_if_null(ops, mmap_addr);\r\nset_to_cap_if_null(ops, mmap_file);\r\nset_to_cap_if_null(ops, file_mprotect);\r\nset_to_cap_if_null(ops, file_lock);\r\nset_to_cap_if_null(ops, file_fcntl);\r\nset_to_cap_if_null(ops, file_set_fowner);\r\nset_to_cap_if_null(ops, file_send_sigiotask);\r\nset_to_cap_if_null(ops, file_receive);\r\nset_to_cap_if_null(ops, file_open);\r\nset_to_cap_if_null(ops, task_create);\r\nset_to_cap_if_null(ops, task_free);\r\nset_to_cap_if_null(ops, cred_alloc_blank);\r\nset_to_cap_if_null(ops, cred_free);\r\nset_to_cap_if_null(ops, cred_prepare);\r\nset_to_cap_if_null(ops, cred_transfer);\r\nset_to_cap_if_null(ops, kernel_act_as);\r\nset_to_cap_if_null(ops, kernel_create_files_as);\r\nset_to_cap_if_null(ops, kernel_fw_from_file);\r\nset_to_cap_if_null(ops, kernel_module_request);\r\nset_to_cap_if_null(ops, kernel_module_from_file);\r\nset_to_cap_if_null(ops, task_fix_setuid);\r\nset_to_cap_if_null(ops, task_setpgid);\r\nset_to_cap_if_null(ops, task_getpgid);\r\nset_to_cap_if_null(ops, task_getsid);\r\nset_to_cap_if_null(ops, task_getsecid);\r\nset_to_cap_if_null(ops, task_setnice);\r\nset_to_cap_if_null(ops, task_setioprio);\r\nset_to_cap_if_null(ops, task_getioprio);\r\nset_to_cap_if_null(ops, task_setrlimit);\r\nset_to_cap_if_null(ops, task_setscheduler);\r\nset_to_cap_if_null(ops, task_getscheduler);\r\nset_to_cap_if_null(ops, task_movememory);\r\nset_to_cap_if_null(ops, task_wait);\r\nset_to_cap_if_null(ops, task_kill);\r\nset_to_cap_if_null(ops, task_prctl);\r\nset_to_cap_if_null(ops, task_to_inode);\r\nset_to_cap_if_null(ops, ipc_permission);\r\nset_to_cap_if_null(ops, ipc_getsecid);\r\nset_to_cap_if_null(ops, msg_msg_alloc_security);\r\nset_to_cap_if_null(ops, msg_msg_free_security);\r\nset_to_cap_if_null(ops, msg_queue_alloc_security);\r\nset_to_cap_if_null(ops, msg_queue_free_security);\r\nset_to_cap_if_null(ops, msg_queue_associate);\r\nset_to_cap_if_null(ops, msg_queue_msgctl);\r\nset_to_cap_if_null(ops, msg_queue_msgsnd);\r\nset_to_cap_if_null(ops, msg_queue_msgrcv);\r\nset_to_cap_if_null(ops, shm_alloc_security);\r\nset_to_cap_if_null(ops, shm_free_security);\r\nset_to_cap_if_null(ops, shm_associate);\r\nset_to_cap_if_null(ops, shm_shmctl);\r\nset_to_cap_if_null(ops, shm_shmat);\r\nset_to_cap_if_null(ops, sem_alloc_security);\r\nset_to_cap_if_null(ops, sem_free_security);\r\nset_to_cap_if_null(ops, sem_associate);\r\nset_to_cap_if_null(ops, sem_semctl);\r\nset_to_cap_if_null(ops, sem_semop);\r\nset_to_cap_if_null(ops, netlink_send);\r\nset_to_cap_if_null(ops, d_instantiate);\r\nset_to_cap_if_null(ops, getprocattr);\r\nset_to_cap_if_null(ops, setprocattr);\r\nset_to_cap_if_null(ops, ismaclabel);\r\nset_to_cap_if_null(ops, secid_to_secctx);\r\nset_to_cap_if_null(ops, secctx_to_secid);\r\nset_to_cap_if_null(ops, release_secctx);\r\nset_to_cap_if_null(ops, inode_notifysecctx);\r\nset_to_cap_if_null(ops, inode_setsecctx);\r\nset_to_cap_if_null(ops, inode_getsecctx);\r\n#ifdef CONFIG_SECURITY_NETWORK\r\nset_to_cap_if_null(ops, unix_stream_connect);\r\nset_to_cap_if_null(ops, unix_may_send);\r\nset_to_cap_if_null(ops, socket_create);\r\nset_to_cap_if_null(ops, socket_post_create);\r\nset_to_cap_if_null(ops, socket_bind);\r\nset_to_cap_if_null(ops, socket_connect);\r\nset_to_cap_if_null(ops, socket_listen);\r\nset_to_cap_if_null(ops, socket_accept);\r\nset_to_cap_if_null(ops, socket_sendmsg);\r\nset_to_cap_if_null(ops, socket_recvmsg);\r\nset_to_cap_if_null(ops, socket_getsockname);\r\nset_to_cap_if_null(ops, socket_getpeername);\r\nset_to_cap_if_null(ops, socket_setsockopt);\r\nset_to_cap_if_null(ops, socket_getsockopt);\r\nset_to_cap_if_null(ops, socket_shutdown);\r\nset_to_cap_if_null(ops, socket_sock_rcv_skb);\r\nset_to_cap_if_null(ops, socket_getpeersec_stream);\r\nset_to_cap_if_null(ops, socket_getpeersec_dgram);\r\nset_to_cap_if_null(ops, sk_alloc_security);\r\nset_to_cap_if_null(ops, sk_free_security);\r\nset_to_cap_if_null(ops, sk_clone_security);\r\nset_to_cap_if_null(ops, sk_getsecid);\r\nset_to_cap_if_null(ops, sock_graft);\r\nset_to_cap_if_null(ops, inet_conn_request);\r\nset_to_cap_if_null(ops, inet_csk_clone);\r\nset_to_cap_if_null(ops, inet_conn_established);\r\nset_to_cap_if_null(ops, secmark_relabel_packet);\r\nset_to_cap_if_null(ops, secmark_refcount_inc);\r\nset_to_cap_if_null(ops, secmark_refcount_dec);\r\nset_to_cap_if_null(ops, req_classify_flow);\r\nset_to_cap_if_null(ops, tun_dev_alloc_security);\r\nset_to_cap_if_null(ops, tun_dev_free_security);\r\nset_to_cap_if_null(ops, tun_dev_create);\r\nset_to_cap_if_null(ops, tun_dev_open);\r\nset_to_cap_if_null(ops, tun_dev_attach_queue);\r\nset_to_cap_if_null(ops, tun_dev_attach);\r\nset_to_cap_if_null(ops, skb_owned_by);\r\n#endif\r\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\r\nset_to_cap_if_null(ops, xfrm_policy_alloc_security);\r\nset_to_cap_if_null(ops, xfrm_policy_clone_security);\r\nset_to_cap_if_null(ops, xfrm_policy_free_security);\r\nset_to_cap_if_null(ops, xfrm_policy_delete_security);\r\nset_to_cap_if_null(ops, xfrm_state_alloc);\r\nset_to_cap_if_null(ops, xfrm_state_alloc_acquire);\r\nset_to_cap_if_null(ops, xfrm_state_free_security);\r\nset_to_cap_if_null(ops, xfrm_state_delete_security);\r\nset_to_cap_if_null(ops, xfrm_policy_lookup);\r\nset_to_cap_if_null(ops, xfrm_state_pol_flow_match);\r\nset_to_cap_if_null(ops, xfrm_decode_session);\r\n#endif\r\n#ifdef CONFIG_KEYS\r\nset_to_cap_if_null(ops, key_alloc);\r\nset_to_cap_if_null(ops, key_free);\r\nset_to_cap_if_null(ops, key_permission);\r\nset_to_cap_if_null(ops, key_getsecurity);\r\n#endif\r\n#ifdef CONFIG_AUDIT\r\nset_to_cap_if_null(ops, audit_rule_init);\r\nset_to_cap_if_null(ops, audit_rule_known);\r\nset_to_cap_if_null(ops, audit_rule_match);\r\nset_to_cap_if_null(ops, audit_rule_free);\r\n#endif\r\n}
