static void __init zynq_clk_register_fclk(enum zynq_clk fclk,\r\nconst char *clk_name, void __iomem *fclk_ctrl_reg,\r\nconst char **parents, int enable)\r\n{\r\nstruct clk *clk;\r\nu32 enable_reg;\r\nchar *mux_name;\r\nchar *div0_name;\r\nchar *div1_name;\r\nspinlock_t *fclk_lock;\r\nspinlock_t *fclk_gate_lock;\r\nvoid __iomem *fclk_gate_reg = fclk_ctrl_reg + 8;\r\nfclk_lock = kmalloc(sizeof(*fclk_lock), GFP_KERNEL);\r\nif (!fclk_lock)\r\ngoto err;\r\nfclk_gate_lock = kmalloc(sizeof(*fclk_gate_lock), GFP_KERNEL);\r\nif (!fclk_gate_lock)\r\ngoto err_fclk_gate_lock;\r\nspin_lock_init(fclk_lock);\r\nspin_lock_init(fclk_gate_lock);\r\nmux_name = kasprintf(GFP_KERNEL, "%s_mux", clk_name);\r\nif (!mux_name)\r\ngoto err_mux_name;\r\ndiv0_name = kasprintf(GFP_KERNEL, "%s_div0", clk_name);\r\nif (!div0_name)\r\ngoto err_div0_name;\r\ndiv1_name = kasprintf(GFP_KERNEL, "%s_div1", clk_name);\r\nif (!div1_name)\r\ngoto err_div1_name;\r\nclk = clk_register_mux(NULL, mux_name, parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, fclk_ctrl_reg, 4, 2, 0,\r\nfclk_lock);\r\nclk = clk_register_divider(NULL, div0_name, mux_name,\r\n0, fclk_ctrl_reg, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, fclk_lock);\r\nclk = clk_register_divider(NULL, div1_name, div0_name,\r\nCLK_SET_RATE_PARENT, fclk_ctrl_reg, 20, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\nfclk_lock);\r\nclks[fclk] = clk_register_gate(NULL, clk_name,\r\ndiv1_name, CLK_SET_RATE_PARENT, fclk_gate_reg,\r\n0, CLK_GATE_SET_TO_DISABLE, fclk_gate_lock);\r\nenable_reg = clk_readl(fclk_gate_reg) & 1;\r\nif (enable && !enable_reg) {\r\nif (clk_prepare_enable(clks[fclk]))\r\npr_warn("%s: FCLK%u enable failed\n", __func__,\r\nfclk - fclk0);\r\n}\r\nkfree(mux_name);\r\nkfree(div0_name);\r\nkfree(div1_name);\r\nreturn;\r\nerr_div1_name:\r\nkfree(div0_name);\r\nerr_div0_name:\r\nkfree(mux_name);\r\nerr_mux_name:\r\nkfree(fclk_gate_lock);\r\nerr_fclk_gate_lock:\r\nkfree(fclk_lock);\r\nerr:\r\nclks[fclk] = ERR_PTR(-ENOMEM);\r\n}\r\nstatic void __init zynq_clk_register_periph_clk(enum zynq_clk clk0,\r\nenum zynq_clk clk1, const char *clk_name0,\r\nconst char *clk_name1, void __iomem *clk_ctrl,\r\nconst char **parents, unsigned int two_gates)\r\n{\r\nstruct clk *clk;\r\nchar *mux_name;\r\nchar *div_name;\r\nspinlock_t *lock;\r\nlock = kmalloc(sizeof(*lock), GFP_KERNEL);\r\nif (!lock)\r\ngoto err;\r\nspin_lock_init(lock);\r\nmux_name = kasprintf(GFP_KERNEL, "%s_mux", clk_name0);\r\ndiv_name = kasprintf(GFP_KERNEL, "%s_div", clk_name0);\r\nclk = clk_register_mux(NULL, mux_name, parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, clk_ctrl, 4, 2, 0, lock);\r\nclk = clk_register_divider(NULL, div_name, mux_name, 0, clk_ctrl, 8, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO, lock);\r\nclks[clk0] = clk_register_gate(NULL, clk_name0, div_name,\r\nCLK_SET_RATE_PARENT, clk_ctrl, 0, 0, lock);\r\nif (two_gates)\r\nclks[clk1] = clk_register_gate(NULL, clk_name1, div_name,\r\nCLK_SET_RATE_PARENT, clk_ctrl, 1, 0, lock);\r\nkfree(mux_name);\r\nkfree(div_name);\r\nreturn;\r\nerr:\r\nclks[clk0] = ERR_PTR(-ENOMEM);\r\nif (two_gates)\r\nclks[clk1] = ERR_PTR(-ENOMEM);\r\n}\r\nstatic void __init zynq_clk_setup(struct device_node *np)\r\n{\r\nint i;\r\nu32 tmp;\r\nint ret;\r\nstruct clk *clk;\r\nchar *clk_name;\r\nunsigned int fclk_enable = 0;\r\nconst char *clk_output_name[clk_max];\r\nconst char *cpu_parents[4];\r\nconst char *periph_parents[4];\r\nconst char *swdt_ext_clk_mux_parents[2];\r\nconst char *can_mio_mux_parents[NUM_MIO_PINS];\r\nconst char *dummy_nm = "dummy_name";\r\npr_info("Zynq clock init\n");\r\nfor (i = 0; i < clk_max; i++) {\r\nif (of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_output_name[i])) {\r\npr_err("%s: clock output name not in DT\n", __func__);\r\nBUG();\r\n}\r\n}\r\ncpu_parents[0] = clk_output_name[armpll];\r\ncpu_parents[1] = clk_output_name[armpll];\r\ncpu_parents[2] = clk_output_name[ddrpll];\r\ncpu_parents[3] = clk_output_name[iopll];\r\nperiph_parents[0] = clk_output_name[iopll];\r\nperiph_parents[1] = clk_output_name[iopll];\r\nperiph_parents[2] = clk_output_name[armpll];\r\nperiph_parents[3] = clk_output_name[ddrpll];\r\nof_property_read_u32(np, "fclk-enable", &fclk_enable);\r\nret = of_property_read_u32(np, "ps-clk-frequency", &tmp);\r\nif (ret) {\r\npr_warn("ps_clk frequency not specified, using 33 MHz.\n");\r\ntmp = 33333333;\r\n}\r\nps_clk = clk_register_fixed_rate(NULL, "ps_clk", NULL, CLK_IS_ROOT,\r\ntmp);\r\nclk = clk_register_zynq_pll("armpll_int", "ps_clk", SLCR_ARMPLL_CTRL,\r\nSLCR_PLL_STATUS, 0, &armpll_lock);\r\nclks[armpll] = clk_register_mux(NULL, clk_output_name[armpll],\r\narmpll_parents, 2, CLK_SET_RATE_NO_REPARENT,\r\nSLCR_ARMPLL_CTRL, 4, 1, 0, &armpll_lock);\r\nclk = clk_register_zynq_pll("ddrpll_int", "ps_clk", SLCR_DDRPLL_CTRL,\r\nSLCR_PLL_STATUS, 1, &ddrpll_lock);\r\nclks[ddrpll] = clk_register_mux(NULL, clk_output_name[ddrpll],\r\nddrpll_parents, 2, CLK_SET_RATE_NO_REPARENT,\r\nSLCR_DDRPLL_CTRL, 4, 1, 0, &ddrpll_lock);\r\nclk = clk_register_zynq_pll("iopll_int", "ps_clk", SLCR_IOPLL_CTRL,\r\nSLCR_PLL_STATUS, 2, &iopll_lock);\r\nclks[iopll] = clk_register_mux(NULL, clk_output_name[iopll],\r\niopll_parents, 2, CLK_SET_RATE_NO_REPARENT,\r\nSLCR_IOPLL_CTRL, 4, 1, 0, &iopll_lock);\r\ntmp = clk_readl(SLCR_621_TRUE) & 1;\r\nclk = clk_register_mux(NULL, "cpu_mux", cpu_parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_ARM_CLK_CTRL, 4, 2, 0,\r\n&armclk_lock);\r\nclk = clk_register_divider(NULL, "cpu_div", "cpu_mux", 0,\r\nSLCR_ARM_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &armclk_lock);\r\nclks[cpu_6or4x] = clk_register_gate(NULL, clk_output_name[cpu_6or4x],\r\n"cpu_div", CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,\r\nSLCR_ARM_CLK_CTRL, 24, 0, &armclk_lock);\r\nclk = clk_register_fixed_factor(NULL, "cpu_3or2x_div", "cpu_div", 0,\r\n1, 2);\r\nclks[cpu_3or2x] = clk_register_gate(NULL, clk_output_name[cpu_3or2x],\r\n"cpu_3or2x_div", CLK_IGNORE_UNUSED,\r\nSLCR_ARM_CLK_CTRL, 25, 0, &armclk_lock);\r\nclk = clk_register_fixed_factor(NULL, "cpu_2x_div", "cpu_div", 0, 1,\r\n2 + tmp);\r\nclks[cpu_2x] = clk_register_gate(NULL, clk_output_name[cpu_2x],\r\n"cpu_2x_div", CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL,\r\n26, 0, &armclk_lock);\r\nclk = clk_register_fixed_factor(NULL, "cpu_1x_div", "cpu_div", 0, 1,\r\n4 + 2 * tmp);\r\nclks[cpu_1x] = clk_register_gate(NULL, clk_output_name[cpu_1x],\r\n"cpu_1x_div", CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL, 27,\r\n0, &armclk_lock);\r\nswdt_ext_clk_mux_parents[0] = clk_output_name[cpu_1x];\r\nfor (i = 0; i < ARRAY_SIZE(swdt_ext_clk_input_names); i++) {\r\nint idx = of_property_match_string(np, "clock-names",\r\nswdt_ext_clk_input_names[i]);\r\nif (idx >= 0)\r\nswdt_ext_clk_mux_parents[i + 1] =\r\nof_clk_get_parent_name(np, idx);\r\nelse\r\nswdt_ext_clk_mux_parents[i + 1] = dummy_nm;\r\n}\r\nclks[swdt] = clk_register_mux(NULL, clk_output_name[swdt],\r\nswdt_ext_clk_mux_parents, 2, CLK_SET_RATE_PARENT |\r\nCLK_SET_RATE_NO_REPARENT, SLCR_SWDT_CLK_SEL, 0, 1, 0,\r\n&swdtclk_lock);\r\nclk = clk_register_divider(NULL, "ddr2x_div", "ddrpll", 0,\r\nSLCR_DDR_CLK_CTRL, 26, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &ddrclk_lock);\r\nclks[ddr2x] = clk_register_gate(NULL, clk_output_name[ddr2x],\r\n"ddr2x_div", 0, SLCR_DDR_CLK_CTRL, 1, 0, &ddrclk_lock);\r\nclk_prepare_enable(clks[ddr2x]);\r\nclk = clk_register_divider(NULL, "ddr3x_div", "ddrpll", 0,\r\nSLCR_DDR_CLK_CTRL, 20, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &ddrclk_lock);\r\nclks[ddr3x] = clk_register_gate(NULL, clk_output_name[ddr3x],\r\n"ddr3x_div", 0, SLCR_DDR_CLK_CTRL, 0, 0, &ddrclk_lock);\r\nclk_prepare_enable(clks[ddr3x]);\r\nclk = clk_register_divider(NULL, "dci_div0", "ddrpll", 0,\r\nSLCR_DCI_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &dciclk_lock);\r\nclk = clk_register_divider(NULL, "dci_div1", "dci_div0",\r\nCLK_SET_RATE_PARENT, SLCR_DCI_CLK_CTRL, 20, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&dciclk_lock);\r\nclks[dci] = clk_register_gate(NULL, clk_output_name[dci], "dci_div1",\r\nCLK_SET_RATE_PARENT, SLCR_DCI_CLK_CTRL, 0, 0,\r\n&dciclk_lock);\r\nclk_prepare_enable(clks[dci]);\r\nfor (i = fclk0; i <= fclk3; i++) {\r\nint enable = !!(fclk_enable & BIT(i - fclk0));\r\nzynq_clk_register_fclk(i, clk_output_name[i],\r\nSLCR_FPGA0_CLK_CTRL + 0x10 * (i - fclk0),\r\nperiph_parents, enable);\r\n}\r\nzynq_clk_register_periph_clk(lqspi, 0, clk_output_name[lqspi], NULL,\r\nSLCR_LQSPI_CLK_CTRL, periph_parents, 0);\r\nzynq_clk_register_periph_clk(smc, 0, clk_output_name[smc], NULL,\r\nSLCR_SMC_CLK_CTRL, periph_parents, 0);\r\nzynq_clk_register_periph_clk(pcap, 0, clk_output_name[pcap], NULL,\r\nSLCR_PCAP_CLK_CTRL, periph_parents, 0);\r\nzynq_clk_register_periph_clk(sdio0, sdio1, clk_output_name[sdio0],\r\nclk_output_name[sdio1], SLCR_SDIO_CLK_CTRL,\r\nperiph_parents, 1);\r\nzynq_clk_register_periph_clk(uart0, uart1, clk_output_name[uart0],\r\nclk_output_name[uart1], SLCR_UART_CLK_CTRL,\r\nperiph_parents, 1);\r\nzynq_clk_register_periph_clk(spi0, spi1, clk_output_name[spi0],\r\nclk_output_name[spi1], SLCR_SPI_CLK_CTRL,\r\nperiph_parents, 1);\r\nfor (i = 0; i < ARRAY_SIZE(gem0_emio_input_names); i++) {\r\nint idx = of_property_match_string(np, "clock-names",\r\ngem0_emio_input_names[i]);\r\nif (idx >= 0)\r\ngem0_mux_parents[i + 1] = of_clk_get_parent_name(np,\r\nidx);\r\n}\r\nclk = clk_register_mux(NULL, "gem0_mux", periph_parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_GEM0_CLK_CTRL, 4, 2, 0,\r\n&gem0clk_lock);\r\nclk = clk_register_divider(NULL, "gem0_div0", "gem0_mux", 0,\r\nSLCR_GEM0_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &gem0clk_lock);\r\nclk = clk_register_divider(NULL, "gem0_div1", "gem0_div0",\r\nCLK_SET_RATE_PARENT, SLCR_GEM0_CLK_CTRL, 20, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&gem0clk_lock);\r\nclk = clk_register_mux(NULL, "gem0_emio_mux", gem0_mux_parents, 2,\r\nCLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,\r\nSLCR_GEM0_CLK_CTRL, 6, 1, 0,\r\n&gem0clk_lock);\r\nclks[gem0] = clk_register_gate(NULL, clk_output_name[gem0],\r\n"gem0_emio_mux", CLK_SET_RATE_PARENT,\r\nSLCR_GEM0_CLK_CTRL, 0, 0, &gem0clk_lock);\r\nfor (i = 0; i < ARRAY_SIZE(gem1_emio_input_names); i++) {\r\nint idx = of_property_match_string(np, "clock-names",\r\ngem1_emio_input_names[i]);\r\nif (idx >= 0)\r\ngem1_mux_parents[i + 1] = of_clk_get_parent_name(np,\r\nidx);\r\n}\r\nclk = clk_register_mux(NULL, "gem1_mux", periph_parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_GEM1_CLK_CTRL, 4, 2, 0,\r\n&gem1clk_lock);\r\nclk = clk_register_divider(NULL, "gem1_div0", "gem1_mux", 0,\r\nSLCR_GEM1_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &gem1clk_lock);\r\nclk = clk_register_divider(NULL, "gem1_div1", "gem1_div0",\r\nCLK_SET_RATE_PARENT, SLCR_GEM1_CLK_CTRL, 20, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&gem1clk_lock);\r\nclk = clk_register_mux(NULL, "gem1_emio_mux", gem1_mux_parents, 2,\r\nCLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,\r\nSLCR_GEM1_CLK_CTRL, 6, 1, 0,\r\n&gem1clk_lock);\r\nclks[gem1] = clk_register_gate(NULL, clk_output_name[gem1],\r\n"gem1_emio_mux", CLK_SET_RATE_PARENT,\r\nSLCR_GEM1_CLK_CTRL, 0, 0, &gem1clk_lock);\r\ntmp = strlen("mio_clk_00x");\r\nclk_name = kmalloc(tmp, GFP_KERNEL);\r\nfor (i = 0; i < NUM_MIO_PINS; i++) {\r\nint idx;\r\nsnprintf(clk_name, tmp, "mio_clk_%2.2d", i);\r\nidx = of_property_match_string(np, "clock-names", clk_name);\r\nif (idx >= 0)\r\ncan_mio_mux_parents[i] = of_clk_get_parent_name(np,\r\nidx);\r\nelse\r\ncan_mio_mux_parents[i] = dummy_nm;\r\n}\r\nkfree(clk_name);\r\nclk = clk_register_mux(NULL, "can_mux", periph_parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_CAN_CLK_CTRL, 4, 2, 0,\r\n&canclk_lock);\r\nclk = clk_register_divider(NULL, "can_div0", "can_mux", 0,\r\nSLCR_CAN_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &canclk_lock);\r\nclk = clk_register_divider(NULL, "can_div1", "can_div0",\r\nCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 20, 6,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&canclk_lock);\r\nclk = clk_register_gate(NULL, "can0_gate", "can_div1",\r\nCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 0, 0,\r\n&canclk_lock);\r\nclk = clk_register_gate(NULL, "can1_gate", "can_div1",\r\nCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 1, 0,\r\n&canclk_lock);\r\nclk = clk_register_mux(NULL, "can0_mio_mux",\r\ncan_mio_mux_parents, 54, CLK_SET_RATE_PARENT |\r\nCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 0, 6, 0,\r\n&canmioclk_lock);\r\nclk = clk_register_mux(NULL, "can1_mio_mux",\r\ncan_mio_mux_parents, 54, CLK_SET_RATE_PARENT |\r\nCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 16, 6,\r\n0, &canmioclk_lock);\r\nclks[can0] = clk_register_mux(NULL, clk_output_name[can0],\r\ncan0_mio_mux2_parents, 2, CLK_SET_RATE_PARENT |\r\nCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 6, 1, 0,\r\n&canmioclk_lock);\r\nclks[can1] = clk_register_mux(NULL, clk_output_name[can1],\r\ncan1_mio_mux2_parents, 2, CLK_SET_RATE_PARENT |\r\nCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 22, 1,\r\n0, &canmioclk_lock);\r\nfor (i = 0; i < ARRAY_SIZE(dbgtrc_emio_input_names); i++) {\r\nint idx = of_property_match_string(np, "clock-names",\r\ndbgtrc_emio_input_names[i]);\r\nif (idx >= 0)\r\ndbg_emio_mux_parents[i + 1] = of_clk_get_parent_name(np,\r\nidx);\r\n}\r\nclk = clk_register_mux(NULL, "dbg_mux", periph_parents, 4,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_DBG_CLK_CTRL, 4, 2, 0,\r\n&dbgclk_lock);\r\nclk = clk_register_divider(NULL, "dbg_div", "dbg_mux", 0,\r\nSLCR_DBG_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ALLOW_ZERO, &dbgclk_lock);\r\nclk = clk_register_mux(NULL, "dbg_emio_mux", dbg_emio_mux_parents, 2,\r\nCLK_SET_RATE_NO_REPARENT, SLCR_DBG_CLK_CTRL, 6, 1, 0,\r\n&dbgclk_lock);\r\nclks[dbg_trc] = clk_register_gate(NULL, clk_output_name[dbg_trc],\r\n"dbg_emio_mux", CLK_SET_RATE_PARENT, SLCR_DBG_CLK_CTRL,\r\n0, 0, &dbgclk_lock);\r\nclks[dbg_apb] = clk_register_gate(NULL, clk_output_name[dbg_apb],\r\nclk_output_name[cpu_1x], 0, SLCR_DBG_CLK_CTRL, 1, 0,\r\n&dbgclk_lock);\r\ntmp = clk_readl(SLCR_DBG_CLK_CTRL);\r\nif (tmp & DBG_CLK_CTRL_CLKACT_TRC)\r\nif (clk_prepare_enable(clks[dbg_trc]))\r\npr_warn("%s: trace clk enable failed\n", __func__);\r\nif (tmp & DBG_CLK_CTRL_CPU_1XCLKACT)\r\nif (clk_prepare_enable(clks[dbg_apb]))\r\npr_warn("%s: debug APB clk enable failed\n", __func__);\r\nclks[dma] = clk_register_gate(NULL, clk_output_name[dma],\r\nclk_output_name[cpu_2x], 0, SLCR_APER_CLK_CTRL, 0, 0,\r\n&aperclk_lock);\r\nclks[usb0_aper] = clk_register_gate(NULL, clk_output_name[usb0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 2, 0,\r\n&aperclk_lock);\r\nclks[usb1_aper] = clk_register_gate(NULL, clk_output_name[usb1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 3, 0,\r\n&aperclk_lock);\r\nclks[gem0_aper] = clk_register_gate(NULL, clk_output_name[gem0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 6, 0,\r\n&aperclk_lock);\r\nclks[gem1_aper] = clk_register_gate(NULL, clk_output_name[gem1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 7, 0,\r\n&aperclk_lock);\r\nclks[sdio0_aper] = clk_register_gate(NULL, clk_output_name[sdio0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 10, 0,\r\n&aperclk_lock);\r\nclks[sdio1_aper] = clk_register_gate(NULL, clk_output_name[sdio1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 11, 0,\r\n&aperclk_lock);\r\nclks[spi0_aper] = clk_register_gate(NULL, clk_output_name[spi0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 14, 0,\r\n&aperclk_lock);\r\nclks[spi1_aper] = clk_register_gate(NULL, clk_output_name[spi1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 15, 0,\r\n&aperclk_lock);\r\nclks[can0_aper] = clk_register_gate(NULL, clk_output_name[can0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 16, 0,\r\n&aperclk_lock);\r\nclks[can1_aper] = clk_register_gate(NULL, clk_output_name[can1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 17, 0,\r\n&aperclk_lock);\r\nclks[i2c0_aper] = clk_register_gate(NULL, clk_output_name[i2c0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 18, 0,\r\n&aperclk_lock);\r\nclks[i2c1_aper] = clk_register_gate(NULL, clk_output_name[i2c1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 19, 0,\r\n&aperclk_lock);\r\nclks[uart0_aper] = clk_register_gate(NULL, clk_output_name[uart0_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 20, 0,\r\n&aperclk_lock);\r\nclks[uart1_aper] = clk_register_gate(NULL, clk_output_name[uart1_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 21, 0,\r\n&aperclk_lock);\r\nclks[gpio_aper] = clk_register_gate(NULL, clk_output_name[gpio_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 22, 0,\r\n&aperclk_lock);\r\nclks[lqspi_aper] = clk_register_gate(NULL, clk_output_name[lqspi_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 23, 0,\r\n&aperclk_lock);\r\nclks[smc_aper] = clk_register_gate(NULL, clk_output_name[smc_aper],\r\nclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 24, 0,\r\n&aperclk_lock);\r\nfor (i = 0; i < ARRAY_SIZE(clks); i++) {\r\nif (IS_ERR(clks[i])) {\r\npr_err("Zynq clk %d: register failed with %ld\n",\r\ni, PTR_ERR(clks[i]));\r\nBUG();\r\n}\r\n}\r\nclk_data.clks = clks;\r\nclk_data.clk_num = ARRAY_SIZE(clks);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\n}\r\nvoid __init zynq_clock_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct device_node *slcr;\r\nstruct resource res;\r\nnp = of_find_compatible_node(NULL, NULL, "xlnx,ps7-clkc");\r\nif (!np) {\r\npr_err("%s: clkc node not found\n", __func__);\r\ngoto np_err;\r\n}\r\nif (of_address_to_resource(np, 0, &res)) {\r\npr_err("%s: failed to get resource\n", np->name);\r\ngoto np_err;\r\n}\r\nslcr = of_get_parent(np);\r\nif (slcr->data) {\r\nzynq_clkc_base = (__force void __iomem *)slcr->data + res.start;\r\n} else {\r\npr_err("%s: Unable to get I/O memory\n", np->name);\r\nof_node_put(slcr);\r\ngoto np_err;\r\n}\r\npr_info("%s: clkc starts at %p\n", __func__, zynq_clkc_base);\r\nof_node_put(slcr);\r\nof_node_put(np);\r\nreturn;\r\nnp_err:\r\nof_node_put(np);\r\nBUG();\r\n}
