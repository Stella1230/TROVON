static struct llc_sap *llc_sap_alloc(void)\r\n{\r\nstruct llc_sap *sap = kzalloc(sizeof(*sap), GFP_ATOMIC);\r\nint i;\r\nif (sap) {\r\nsap->state = LLC_SAP_STATE_ACTIVE;\r\nspin_lock_init(&sap->sk_lock);\r\nfor (i = 0; i < LLC_SK_LADDR_HASH_ENTRIES; i++)\r\nINIT_HLIST_NULLS_HEAD(&sap->sk_laddr_hash[i], i);\r\natomic_set(&sap->refcnt, 1);\r\n}\r\nreturn sap;\r\n}\r\nstatic struct llc_sap *__llc_sap_find(unsigned char sap_value)\r\n{\r\nstruct llc_sap *sap;\r\nlist_for_each_entry(sap, &llc_sap_list, node)\r\nif (sap->laddr.lsap == sap_value)\r\ngoto out;\r\nsap = NULL;\r\nout:\r\nreturn sap;\r\n}\r\nstruct llc_sap *llc_sap_find(unsigned char sap_value)\r\n{\r\nstruct llc_sap *sap;\r\nrcu_read_lock_bh();\r\nsap = __llc_sap_find(sap_value);\r\nif (sap)\r\nllc_sap_hold(sap);\r\nrcu_read_unlock_bh();\r\nreturn sap;\r\n}\r\nstruct llc_sap *llc_sap_open(unsigned char lsap,\r\nint (*func)(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nstruct packet_type *pt,\r\nstruct net_device *orig_dev))\r\n{\r\nstruct llc_sap *sap = NULL;\r\nspin_lock_bh(&llc_sap_list_lock);\r\nif (__llc_sap_find(lsap))\r\ngoto out;\r\nsap = llc_sap_alloc();\r\nif (!sap)\r\ngoto out;\r\nsap->laddr.lsap = lsap;\r\nsap->rcv_func = func;\r\nlist_add_tail_rcu(&sap->node, &llc_sap_list);\r\nout:\r\nspin_unlock_bh(&llc_sap_list_lock);\r\nreturn sap;\r\n}\r\nvoid llc_sap_close(struct llc_sap *sap)\r\n{\r\nWARN_ON(sap->sk_count);\r\nspin_lock_bh(&llc_sap_list_lock);\r\nlist_del_rcu(&sap->node);\r\nspin_unlock_bh(&llc_sap_list_lock);\r\nsynchronize_rcu();\r\nkfree(sap);\r\n}\r\nstatic int __init llc_init(void)\r\n{\r\ndev_add_pack(&llc_packet_type);\r\ndev_add_pack(&llc_tr_packet_type);\r\nreturn 0;\r\n}\r\nstatic void __exit llc_exit(void)\r\n{\r\ndev_remove_pack(&llc_packet_type);\r\ndev_remove_pack(&llc_tr_packet_type);\r\n}
