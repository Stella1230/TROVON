unsigned int snd_ca0106_ptr_read(struct snd_ca0106 * emu,\r\nunsigned int reg,\r\nunsigned int chn)\r\n{\r\nunsigned long flags;\r\nunsigned int regptr, val;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + PTR);\r\nval = inl(emu->port + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nreturn val;\r\n}\r\nvoid snd_ca0106_ptr_write(struct snd_ca0106 *emu,\r\nunsigned int reg,\r\nunsigned int chn,\r\nunsigned int data)\r\n{\r\nunsigned int regptr;\r\nunsigned long flags;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + PTR);\r\noutl(data, emu->port + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nint snd_ca0106_spi_write(struct snd_ca0106 * emu,\r\nunsigned int data)\r\n{\r\nunsigned int reset, set;\r\nunsigned int reg, tmp;\r\nint n, result;\r\nreg = SPI;\r\nif (data > 0xffff)\r\nreturn 1;\r\ntmp = snd_ca0106_ptr_read(emu, reg, 0);\r\nreset = (tmp & ~0x3ffff) | 0x20000;\r\nset = reset | 0x10000;\r\nsnd_ca0106_ptr_write(emu, reg, 0, reset | data);\r\ntmp = snd_ca0106_ptr_read(emu, reg, 0);\r\nsnd_ca0106_ptr_write(emu, reg, 0, set | data);\r\nresult = 1;\r\nfor (n = 0; n < 100; n++) {\r\nudelay(10);\r\ntmp = snd_ca0106_ptr_read(emu, reg, 0);\r\nif (!(tmp & 0x10000)) {\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\nif (result)\r\nreturn 1;\r\nsnd_ca0106_ptr_write(emu, reg, 0, reset | data);\r\ntmp = snd_ca0106_ptr_read(emu, reg, 0);\r\nreturn 0;\r\n}\r\nint snd_ca0106_i2c_write(struct snd_ca0106 *emu,\r\nu32 reg,\r\nu32 value)\r\n{\r\nu32 tmp;\r\nint timeout = 0;\r\nint status;\r\nint retry;\r\nif ((reg > 0x7f) || (value > 0x1ff)) {\r\ndev_err(emu->card->dev, "i2c_write: invalid values.\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = reg << 25 | value << 16;\r\nsnd_ca0106_ptr_write(emu, I2C_D1, 0, tmp);\r\nfor (retry = 0; retry < 10; retry++) {\r\ntmp = 0;\r\ntmp = tmp | (I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD);\r\nsnd_ca0106_ptr_write(emu, I2C_A, 0, tmp);\r\nwhile (1) {\r\nstatus = snd_ca0106_ptr_read(emu, I2C_A, 0);\r\ntimeout++;\r\nif ((status & I2C_A_ADC_START) == 0)\r\nbreak;\r\nif (timeout > 1000)\r\nbreak;\r\n}\r\nif ((status & I2C_A_ADC_ABORT) == 0)\r\nbreak;\r\n}\r\nif (retry == 10) {\r\ndev_err(emu->card->dev, "Writing to ADC failed!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ca0106_intr_enable(struct snd_ca0106 *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int intr_enable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nintr_enable = inl(emu->port + INTE) | intrenb;\r\noutl(intr_enable, emu->port + INTE);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_ca0106_intr_disable(struct snd_ca0106 *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int intr_enable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nintr_enable = inl(emu->port + INTE) & ~intrenb;\r\noutl(intr_enable, emu->port + INTE);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_ca0106_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic void restore_spdif_bits(struct snd_ca0106 *chip, int idx)\r\n{\r\nif (chip->spdif_str_bits[idx] != chip->spdif_bits[idx]) {\r\nchip->spdif_str_bits[idx] = chip->spdif_bits[idx];\r\nsnd_ca0106_ptr_write(chip, SPCS0 + idx, 0,\r\nchip->spdif_str_bits[idx]);\r\n}\r\n}\r\nstatic int snd_ca0106_channel_dac(struct snd_ca0106 *chip,\r\nstruct snd_ca0106_details *details,\r\nint channel_id)\r\n{\r\nswitch (channel_id) {\r\ncase PCM_FRONT_CHANNEL:\r\nreturn (details->spi_dac & 0xf000) >> (4 * 3);\r\ncase PCM_REAR_CHANNEL:\r\nreturn (details->spi_dac & 0x0f00) >> (4 * 2);\r\ncase PCM_CENTER_LFE_CHANNEL:\r\nreturn (details->spi_dac & 0x00f0) >> (4 * 1);\r\ncase PCM_UNKNOWN_CHANNEL:\r\nreturn (details->spi_dac & 0x000f) >> (4 * 0);\r\ndefault:\r\ndev_dbg(chip->card->dev, "ca0106: unknown channel_id %d\n",\r\nchannel_id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_power_dac(struct snd_ca0106 *chip, int channel_id,\r\nint power)\r\n{\r\nif (chip->details->spi_dac) {\r\nconst int dac = snd_ca0106_channel_dac(chip, chip->details,\r\nchannel_id);\r\nconst int reg = spi_dacd_reg[dac];\r\nconst int bit = spi_dacd_bit[dac];\r\nif (power)\r\nchip->spi_dac_reg[reg] &= ~bit;\r\nelse\r\nchip->spi_dac_reg[reg] |= bit;\r\nreturn snd_ca0106_spi_write(chip, chip->spi_dac_reg[reg]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_open_playback_channel(struct snd_pcm_substream *substream,\r\nint channel_id)\r\n{\r\nstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_ca0106_channel *channel = &(chip->playback_channels[channel_id]);\r\nstruct snd_ca0106_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = chip;\r\nepcm->substream = substream;\r\nepcm->channel_id=channel_id;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_ca0106_pcm_free_substream;\r\nruntime->hw = snd_ca0106_playback_hw;\r\nchannel->emu = chip;\r\nchannel->number = channel_id;\r\nchannel->use = 1;\r\nchannel->epcm = epcm;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)\r\nreturn err;\r\nsnd_pcm_set_sync(substream);\r\nif (channel_id != PCM_FRONT_CHANNEL) {\r\nerr = snd_ca0106_pcm_power_dac(chip, channel_id, 1);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nrestore_spdif_bits(chip, channel_id);\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_close_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nchip->playback_channels[epcm->channel_id].use = 0;\r\nrestore_spdif_bits(chip, epcm->channel_id);\r\nif (epcm->channel_id != PCM_FRONT_CHANNEL) {\r\nint err;\r\nerr = snd_ca0106_pcm_power_dac(chip, epcm->channel_id, 0);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_open_playback_front(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);\r\n}\r\nstatic int snd_ca0106_pcm_open_playback_center_lfe(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_playback_channel(substream, PCM_CENTER_LFE_CHANNEL);\r\n}\r\nstatic int snd_ca0106_pcm_open_playback_unknown(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_playback_channel(substream, PCM_UNKNOWN_CHANNEL);\r\n}\r\nstatic int snd_ca0106_pcm_open_playback_rear(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_playback_channel(substream, PCM_REAR_CHANNEL);\r\n}\r\nstatic int snd_ca0106_pcm_open_capture_channel(struct snd_pcm_substream *substream,\r\nint channel_id)\r\n{\r\nstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_ca0106_channel *channel = &(chip->capture_channels[channel_id]);\r\nstruct snd_ca0106_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL) {\r\ndev_err(chip->card->dev,\r\n"open_capture_channel: failed epcm alloc\n");\r\nreturn -ENOMEM;\r\n}\r\nepcm->emu = chip;\r\nepcm->substream = substream;\r\nepcm->channel_id=channel_id;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_ca0106_pcm_free_substream;\r\nruntime->hw = snd_ca0106_capture_hw;\r\nchannel->emu = chip;\r\nchannel->number = channel_id;\r\nchannel->use = 1;\r\nchannel->epcm = epcm;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_close_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nchip->capture_channels[epcm->channel_id].use = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_open_0_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_capture_channel(substream, 0);\r\n}\r\nstatic int snd_ca0106_pcm_open_1_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_capture_channel(substream, 1);\r\n}\r\nstatic int snd_ca0106_pcm_open_2_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_capture_channel(substream, 2);\r\n}\r\nstatic int snd_ca0106_pcm_open_3_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ca0106_pcm_open_capture_channel(substream, 3);\r\n}\r\nstatic int snd_ca0106_pcm_hw_params_playback(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ca0106_pcm_hw_free_playback(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ca0106_pcm_hw_params_capture(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ca0106_pcm_hw_free_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ca0106_pcm_prepare_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nint channel = epcm->channel_id;\r\nu32 *table_base = (u32 *)(emu->buffer.area+(8*16*channel));\r\nu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\r\nu32 hcfg_mask = HCFG_PLAYBACK_S32_LE;\r\nu32 hcfg_set = 0x00000000;\r\nu32 hcfg;\r\nu32 reg40_mask = 0x30000 << (channel<<1);\r\nu32 reg40_set = 0;\r\nu32 reg40;\r\nu32 reg71_mask = 0x03030000 ;\r\nu32 reg71_set = 0;\r\nu32 reg71;\r\nint i;\r\n#if 0\r\ndev_dbg(emu->card->dev,\r\n"prepare:channel_number=%d, rate=%d, format=0x%x, "\r\n"channels=%d, buffer_size=%ld, period_size=%ld, "\r\n"periods=%u, frames_to_bytes=%d\n",\r\nchannel, runtime->rate, runtime->format,\r\nruntime->channels, runtime->buffer_size,\r\nruntime->period_size, runtime->periods,\r\nframes_to_bytes(runtime, 1));\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, table_base=%p\n",\r\nruntime->dma_addr, runtime->dma_area, table_base);\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\n",\r\nemu->buffer.addr, emu->buffer.area, emu->buffer.bytes);\r\n#endif\r\nswitch (runtime->rate) {\r\ncase 44100:\r\nreg40_set = 0x10000 << (channel<<1);\r\nreg71_set = 0x01010000;\r\nbreak;\r\ncase 48000:\r\nreg40_set = 0;\r\nreg71_set = 0;\r\nbreak;\r\ncase 96000:\r\nreg40_set = 0x20000 << (channel<<1);\r\nreg71_set = 0x02020000;\r\nbreak;\r\ncase 192000:\r\nreg40_set = 0x30000 << (channel<<1);\r\nreg71_set = 0x03030000;\r\nbreak;\r\ndefault:\r\nreg40_set = 0;\r\nreg71_set = 0;\r\nbreak;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nhcfg_set = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nhcfg_set = HCFG_PLAYBACK_S32_LE;\r\nbreak;\r\ndefault:\r\nhcfg_set = 0;\r\nbreak;\r\n}\r\nhcfg = inl(emu->port + HCFG) ;\r\nhcfg = (hcfg & ~hcfg_mask) | hcfg_set;\r\noutl(hcfg, emu->port + HCFG);\r\nreg40 = snd_ca0106_ptr_read(emu, 0x40, 0);\r\nreg40 = (reg40 & ~reg40_mask) | reg40_set;\r\nsnd_ca0106_ptr_write(emu, 0x40, 0, reg40);\r\nreg71 = snd_ca0106_ptr_read(emu, 0x71, 0);\r\nreg71 = (reg71 & ~reg71_mask) | reg71_set;\r\nsnd_ca0106_ptr_write(emu, 0x71, 0, reg71);\r\nfor(i=0; i < runtime->periods; i++) {\r\ntable_base[i*2] = runtime->dma_addr + (i * period_size_bytes);\r\ntable_base[i*2+1] = period_size_bytes << 16;\r\n}\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_ADDR, channel, emu->buffer.addr+(8*16*channel));\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_SIZE, channel, (runtime->periods - 1) << 19);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_PTR, channel, 0);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_DMA_ADDR, channel, runtime->dma_addr);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_PERIOD_SIZE, channel, frames_to_bytes(runtime, runtime->period_size)<<16);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_PERIOD_SIZE, channel, 0);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_POINTER, channel, 0);\r\nsnd_ca0106_ptr_write(emu, 0x07, channel, 0x0);\r\nsnd_ca0106_ptr_write(emu, 0x08, channel, 0);\r\nsnd_ca0106_ptr_write(emu, PLAYBACK_MUTE, 0x0, 0x0);\r\n#if 0\r\nsnd_ca0106_ptr_write(emu, SPCS0, 0,\r\nSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\r\nSPCS_GENERATIONSTATUS | 0x00001200 |\r\n0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT );\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_prepare_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nint channel = epcm->channel_id;\r\nu32 hcfg_mask = HCFG_CAPTURE_S32_LE;\r\nu32 hcfg_set = 0x00000000;\r\nu32 hcfg;\r\nu32 over_sampling=0x2;\r\nu32 reg71_mask = 0x0000c000 ;\r\nu32 reg71_set = 0;\r\nu32 reg71;\r\n#if 0\r\ndev_dbg(emu->card->dev,\r\n"prepare:channel_number=%d, rate=%d, format=0x%x, "\r\n"channels=%d, buffer_size=%ld, period_size=%ld, "\r\n"periods=%u, frames_to_bytes=%d\n",\r\nchannel, runtime->rate, runtime->format,\r\nruntime->channels, runtime->buffer_size,\r\nruntime->period_size, runtime->periods,\r\nframes_to_bytes(runtime, 1));\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, table_base=%p\n",\r\nruntime->dma_addr, runtime->dma_area, table_base);\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\n",\r\nemu->buffer.addr, emu->buffer.area, emu->buffer.bytes);\r\n#endif\r\nswitch (runtime->rate) {\r\ncase 44100:\r\nreg71_set = 0x00004000;\r\nbreak;\r\ncase 48000:\r\nreg71_set = 0;\r\nbreak;\r\ncase 96000:\r\nreg71_set = 0x00008000;\r\nover_sampling=0xa;\r\nbreak;\r\ncase 192000:\r\nreg71_set = 0x0000c000;\r\nover_sampling=0xa;\r\nbreak;\r\ndefault:\r\nreg71_set = 0;\r\nbreak;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nhcfg_set = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nhcfg_set = HCFG_CAPTURE_S32_LE;\r\nbreak;\r\ndefault:\r\nhcfg_set = 0;\r\nbreak;\r\n}\r\nhcfg = inl(emu->port + HCFG) ;\r\nhcfg = (hcfg & ~hcfg_mask) | hcfg_set;\r\noutl(hcfg, emu->port + HCFG);\r\nreg71 = snd_ca0106_ptr_read(emu, 0x71, 0);\r\nreg71 = (reg71 & ~reg71_mask) | reg71_set;\r\nsnd_ca0106_ptr_write(emu, 0x71, 0, reg71);\r\nif (emu->details->i2c_adc == 1) {\r\nsnd_ca0106_i2c_write(emu, ADC_MASTER, over_sampling);\r\n}\r\nsnd_ca0106_ptr_write(emu, 0x13, channel, 0);\r\nsnd_ca0106_ptr_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);\r\nsnd_ca0106_ptr_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size)<<16);\r\nsnd_ca0106_ptr_write(emu, CAPTURE_POINTER, channel, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_pcm_trigger_playback(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_ca0106_pcm *epcm;\r\nint channel;\r\nint result = 0;\r\nstruct snd_pcm_substream *s;\r\nu32 basic = 0;\r\nu32 extended = 0;\r\nu32 bits;\r\nint running = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nrunning = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndefault:\r\nrunning = 0;\r\nbreak;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (snd_pcm_substream_chip(s) != emu ||\r\ns->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\ncontinue;\r\nruntime = s->runtime;\r\nepcm = runtime->private_data;\r\nchannel = epcm->channel_id;\r\nepcm->running = running;\r\nbasic |= (0x1 << channel);\r\nextended |= (0x10 << channel);\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nbits = snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0);\r\nbits |= extended;\r\nsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, bits);\r\nbits = snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0);\r\nbits |= basic;\r\nsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, bits);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nbits = snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0);\r\nbits &= ~basic;\r\nsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, bits);\r\nbits = snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0);\r\nbits &= ~extended;\r\nsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, bits);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_ca0106_pcm_trigger_capture(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nint channel = epcm->channel_id;\r\nint result = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));\r\nsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0)|(0x100<<channel));\r\nepcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0) & ~(0x100<<channel));\r\nsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) & ~(0x110000<<channel));\r\nepcm->running = 0;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_ca0106_pcm_pointer_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nunsigned int ptr, prev_ptr;\r\nint channel = epcm->channel_id;\r\nint timeout = 10;\r\nif (!epcm->running)\r\nreturn 0;\r\nprev_ptr = -1;\r\ndo {\r\nptr = snd_ca0106_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\r\nptr = (ptr >> 3) * runtime->period_size;\r\nptr += bytes_to_frames(runtime,\r\nsnd_ca0106_ptr_read(emu, PLAYBACK_POINTER, channel));\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nif (prev_ptr == ptr)\r\nreturn ptr;\r\nprev_ptr = ptr;\r\n} while (--timeout);\r\ndev_warn(emu->card->dev, "ca0106: unstable DMA pointer!\n");\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_ca0106_pcm_pointer_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ca0106_pcm *epcm = runtime->private_data;\r\nsnd_pcm_uframes_t ptr, ptr1, ptr2 = 0;\r\nint channel = epcm->channel_id;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr1 = snd_ca0106_ptr_read(emu, CAPTURE_POINTER, channel);\r\nptr2 = bytes_to_frames(runtime, ptr1);\r\nptr=ptr2;\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nreturn ptr;\r\n}\r\nstatic unsigned short snd_ca0106_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct snd_ca0106 *emu = ac97->private_data;\r\nunsigned long flags;\r\nunsigned short val;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutb(reg, emu->port + AC97ADDRESS);\r\nval = inw(emu->port + AC97DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nreturn val;\r\n}\r\nstatic void snd_ca0106_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct snd_ca0106 *emu = ac97->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutb(reg, emu->port + AC97ADDRESS);\r\noutw(val, emu->port + AC97DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic int snd_ca0106_ac97(struct snd_ca0106 *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_ca0106_ac97_write,\r\n.read = snd_ca0106_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\npbus->no_vra = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.scaps = AC97_SCAP_NO_SPDIF;\r\nreturn snd_ac97_mixer(pbus, &ac97, &chip->ac97);\r\n}\r\nstatic int snd_ca0106_free(struct snd_ca0106 *chip)\r\n{\r\nif (chip->res_port != NULL) {\r\nca0106_stop_chip(chip);\r\n}\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\n#if 1\r\nif (chip->buffer.area)\r\nsnd_dma_free_pages(&chip->buffer);\r\n#endif\r\nrelease_and_free_resource(chip->res_port);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ca0106 *chip = device->device_data;\r\nreturn snd_ca0106_free(chip);\r\n}\r\nstatic irqreturn_t snd_ca0106_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned int status;\r\nstruct snd_ca0106 *chip = dev_id;\r\nint i;\r\nint mask;\r\nunsigned int stat76;\r\nstruct snd_ca0106_channel *pchannel;\r\nstatus = inl(chip->port + IPR);\r\nif (! status)\r\nreturn IRQ_NONE;\r\nstat76 = snd_ca0106_ptr_read(chip, EXTENDED_INT, 0);\r\nmask = 0x11;\r\nfor(i = 0; i < 4; i++) {\r\npchannel = &(chip->playback_channels[i]);\r\nif (stat76 & mask) {\r\nif(pchannel->use) {\r\nsnd_pcm_period_elapsed(pchannel->epcm->substream);\r\n}\r\n}\r\nmask <<= 1;\r\n}\r\nmask = 0x110000;\r\nfor(i = 0; i < 4; i++) {\r\npchannel = &(chip->capture_channels[i]);\r\nif (stat76 & mask) {\r\nif(pchannel->use) {\r\nsnd_pcm_period_elapsed(pchannel->epcm->substream);\r\n}\r\n}\r\nmask <<= 1;\r\n}\r\nsnd_ca0106_ptr_write(chip, EXTENDED_INT, 0, stat76);\r\nif (chip->midi.dev_id &&\r\n(status & (chip->midi.ipr_tx|chip->midi.ipr_rx))) {\r\nif (chip->midi.interrupt)\r\nchip->midi.interrupt(&chip->midi, status);\r\nelse\r\nchip->midi.interrupt_disable(&chip->midi, chip->midi.tx_enable | chip->midi.rx_enable);\r\n}\r\noutl(status, chip->port+IPR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_ca0106_pcm(struct snd_ca0106 *emu, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nconst struct snd_pcm_chmap_elem *map = NULL;\r\nint err;\r\nerr = snd_pcm_new(emu->card, "ca0106", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nswitch (device) {\r\ncase 0:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_front_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_0_ops);\r\nmap = snd_pcm_std_chmaps;\r\nbreak;\r\ncase 1:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_rear_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_1_ops);\r\nmap = surround_map;\r\nbreak;\r\ncase 2:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_center_lfe_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_2_ops);\r\nmap = clfe_map;\r\nbreak;\r\ncase 3:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_unknown_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_3_ops);\r\nmap = side_map;\r\nbreak;\r\n}\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CA0106");\r\nfor(substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nsubstream;\r\nsubstream = substream->next) {\r\nif ((err = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(emu->pci),\r\n64*1024, 64*1024)) < 0)\r\nreturn err;\r\n}\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nsubstream;\r\nsubstream = substream->next) {\r\nif ((err = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(emu->pci),\r\n64*1024, 64*1024)) < 0)\r\nreturn err;\r\n}\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK, map, 2,\r\n1 << 2, NULL);\r\nif (err < 0)\r\nreturn err;\r\nemu->pcm[device] = pcm;\r\nreturn 0;\r\n}\r\nstatic void ca0106_init_chip(struct snd_ca0106 *chip, int resume)\r\n{\r\nint ch;\r\nunsigned int def_bits;\r\noutl(0, chip->port + INTE);\r\ndef_bits =\r\nSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\r\nSPCS_GENERATIONSTATUS | 0x00001200 |\r\n0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT;\r\nif (!resume) {\r\nchip->spdif_str_bits[0] = chip->spdif_bits[0] = def_bits;\r\nchip->spdif_str_bits[1] = chip->spdif_bits[1] = def_bits;\r\nchip->spdif_str_bits[2] = chip->spdif_bits[2] = def_bits;\r\nchip->spdif_str_bits[3] = chip->spdif_bits[3] = def_bits;\r\n}\r\nsnd_ca0106_ptr_write(chip, SPCS1, 0, chip->spdif_str_bits[1]);\r\nsnd_ca0106_ptr_write(chip, SPCS0, 0, chip->spdif_str_bits[0]);\r\nsnd_ca0106_ptr_write(chip, SPCS2, 0, chip->spdif_str_bits[2]);\r\nsnd_ca0106_ptr_write(chip, SPCS3, 0, chip->spdif_str_bits[3]);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_MUTE, 0, 0x00fc0000);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_MUTE, 0, 0x00fc0000);\r\noutb(AC97_REC_GAIN, chip->port + AC97ADDRESS);\r\noutw(0x8000, chip->port + AC97DATA);\r\n#if 0\r\nsnd_ca0106_ptr_write(chip, SPCS0, 0, 0x2108006);\r\nsnd_ca0106_ptr_write(chip, 0x42, 0, 0x2108006);\r\nsnd_ca0106_ptr_write(chip, 0x43, 0, 0x2108006);\r\nsnd_ca0106_ptr_write(chip, 0x44, 0, 0x2108006);\r\n#endif\r\nsnd_ca0106_ptr_write(chip, SPDIF_SELECT1, 0, 0xf);\r\nsnd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000f0000);\r\nchip->spdif_enable = 0;\r\nsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 0, 0x40c81000);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 1, 0xffffffff);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 2, 0x30300000);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 3, 0x00700000);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_ROUTING1, 0, 0x32765410);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_ROUTING2, 0, 0x76767676);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_ROUTING1, 0, 0x32765410);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_ROUTING2, 0, 0x76767676);\r\nfor (ch = 0; ch < 4; ch++) {\r\nsnd_ca0106_ptr_write(chip, CAPTURE_VOLUME1, ch, 0x30303030);\r\nsnd_ca0106_ptr_write(chip, CAPTURE_VOLUME2, ch, 0x30303030);\r\n#if 0\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0x40404040);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0x40404040);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0xffffffff);\r\nsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0xffffffff);\r\n#endif\r\n}\r\nif (chip->details->i2c_adc == 1) {\r\nsnd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);\r\nif (!resume)\r\nchip->capture_source = 3;\r\n} else if (chip->details->ac97 == 1) {\r\nsnd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x444400e4);\r\nif (!resume)\r\nchip->capture_source = 4;\r\n} else {\r\nsnd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);\r\nif (!resume)\r\nchip->capture_source = 3;\r\n}\r\nif (chip->details->gpio_type == 2) {\r\noutl(0x0, chip->port+GPIO);\r\noutl(0x005f5301, chip->port+GPIO);\r\n} else if (chip->details->gpio_type == 1) {\r\noutl(0x0, chip->port+GPIO);\r\noutl(0x005f5301, chip->port+GPIO);\r\n} else {\r\noutl(0x0, chip->port+GPIO);\r\noutl(0x005f03a3, chip->port+GPIO);\r\n}\r\nsnd_ca0106_intr_enable(chip, 0x105);\r\noutl(HCFG_AC97 | HCFG_AUDIOENABLE, chip->port+HCFG);\r\nif (chip->details->i2c_adc == 1) {\r\nint size, n;\r\nsize = ARRAY_SIZE(i2c_adc_init);\r\nfor (n = 0; n < size; n++)\r\nsnd_ca0106_i2c_write(chip, i2c_adc_init[n][0],\r\ni2c_adc_init[n][1]);\r\nfor (n = 0; n < 4; n++) {\r\nchip->i2c_capture_volume[n][0] = 0xcf;\r\nchip->i2c_capture_volume[n][1] = 0xcf;\r\n}\r\nchip->i2c_capture_source = 2;\r\n}\r\nif (chip->details->spi_dac) {\r\nint size, n;\r\nsize = ARRAY_SIZE(spi_dac_init);\r\nfor (n = 0; n < size; n++) {\r\nint reg = spi_dac_init[n] >> SPI_REG_SHIFT;\r\nsnd_ca0106_spi_write(chip, spi_dac_init[n]);\r\nif (reg < ARRAY_SIZE(chip->spi_dac_reg))\r\nchip->spi_dac_reg[reg] = spi_dac_init[n];\r\n}\r\nsnd_ca0106_pcm_power_dac(chip, PCM_FRONT_CHANNEL, 1);\r\n}\r\n}\r\nstatic void ca0106_stop_chip(struct snd_ca0106 *chip)\r\n{\r\nsnd_ca0106_ptr_write(chip, BASIC_INTERRUPT, 0, 0);\r\noutl(0, chip->port + INTE);\r\nsnd_ca0106_ptr_write(chip, EXTENDED_INT_MASK, 0, 0);\r\nudelay(1000);\r\noutl(0, chip->port + HCFG);\r\n}\r\nstatic int snd_ca0106_create(int dev, struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct snd_ca0106 **rchip)\r\n{\r\nstruct snd_ca0106 *chip;\r\nstruct snd_ca0106_details *c;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ca0106_dev_free,\r\n};\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {\r\ndev_err(card->dev, "error to set 32bit mask DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->emu_lock);\r\nchip->port = pci_resource_start(pci, 0);\r\nchip->res_port = request_region(chip->port, 0x20, "snd_ca0106");\r\nif (!chip->res_port) {\r\nsnd_ca0106_free(chip);\r\ndev_err(card->dev, "cannot allocate the port\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(pci->irq, snd_ca0106_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\nsnd_ca0106_free(chip);\r\ndev_err(card->dev, "cannot grab irq\n");\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\n1024, &chip->buffer) < 0) {\r\nsnd_ca0106_free(chip);\r\nreturn -ENOMEM;\r\n}\r\npci_set_master(pci);\r\npci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);\r\npci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);\r\ndev_info(card->dev, "Model %04x Rev %08x Serial %08x\n",\r\nchip->model, pci->revision, chip->serial);\r\nstrcpy(card->driver, "CA0106");\r\nstrcpy(card->shortname, "CA0106");\r\nfor (c = ca0106_chip_details; c->serial; c++) {\r\nif (subsystem[dev]) {\r\nif (c->serial == subsystem[dev])\r\nbreak;\r\n} else if (c->serial == chip->serial)\r\nbreak;\r\n}\r\nchip->details = c;\r\nif (subsystem[dev]) {\r\ndev_info(card->dev, "Sound card name=%s, "\r\n"subsystem=0x%x. Forced to subsystem=0x%x\n",\r\nc->name, chip->serial, subsystem[dev]);\r\n}\r\nsprintf(card->longname, "%s at 0x%lx irq %i",\r\nc->name, chip->port, chip->irq);\r\nca0106_init_chip(chip, 0);\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_ca0106_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic void ca0106_midi_interrupt_enable(struct snd_ca_midi *midi, int intr)\r\n{\r\nsnd_ca0106_intr_enable((struct snd_ca0106 *)(midi->dev_id), intr);\r\n}\r\nstatic void ca0106_midi_interrupt_disable(struct snd_ca_midi *midi, int intr)\r\n{\r\nsnd_ca0106_intr_disable((struct snd_ca0106 *)(midi->dev_id), intr);\r\n}\r\nstatic unsigned char ca0106_midi_read(struct snd_ca_midi *midi, int idx)\r\n{\r\nreturn (unsigned char)snd_ca0106_ptr_read((struct snd_ca0106 *)(midi->dev_id),\r\nmidi->port + idx, 0);\r\n}\r\nstatic void ca0106_midi_write(struct snd_ca_midi *midi, int data, int idx)\r\n{\r\nsnd_ca0106_ptr_write((struct snd_ca0106 *)(midi->dev_id), midi->port + idx, 0, data);\r\n}\r\nstatic struct snd_card *ca0106_dev_id_card(void *dev_id)\r\n{\r\nreturn ((struct snd_ca0106 *)dev_id)->card;\r\n}\r\nstatic int ca0106_dev_id_port(void *dev_id)\r\n{\r\nreturn ((struct snd_ca0106 *)dev_id)->port;\r\n}\r\nstatic int snd_ca0106_midi(struct snd_ca0106 *chip, unsigned int channel)\r\n{\r\nstruct snd_ca_midi *midi;\r\nchar *name;\r\nint err;\r\nif (channel == CA0106_MIDI_CHAN_B) {\r\nname = "CA0106 MPU-401 (UART) B";\r\nmidi = &chip->midi2;\r\nmidi->tx_enable = INTE_MIDI_TX_B;\r\nmidi->rx_enable = INTE_MIDI_RX_B;\r\nmidi->ipr_tx = IPR_MIDI_TX_B;\r\nmidi->ipr_rx = IPR_MIDI_RX_B;\r\nmidi->port = MIDI_UART_B_DATA;\r\n} else {\r\nname = "CA0106 MPU-401 (UART)";\r\nmidi = &chip->midi;\r\nmidi->tx_enable = INTE_MIDI_TX_A;\r\nmidi->rx_enable = INTE_MIDI_TX_B;\r\nmidi->ipr_tx = IPR_MIDI_TX_A;\r\nmidi->ipr_rx = IPR_MIDI_RX_A;\r\nmidi->port = MIDI_UART_A_DATA;\r\n}\r\nmidi->reset = CA0106_MPU401_RESET;\r\nmidi->enter_uart = CA0106_MPU401_ENTER_UART;\r\nmidi->ack = CA0106_MPU401_ACK;\r\nmidi->input_avail = CA0106_MIDI_INPUT_AVAIL;\r\nmidi->output_ready = CA0106_MIDI_OUTPUT_READY;\r\nmidi->channel = channel;\r\nmidi->interrupt_enable = ca0106_midi_interrupt_enable;\r\nmidi->interrupt_disable = ca0106_midi_interrupt_disable;\r\nmidi->read = ca0106_midi_read;\r\nmidi->write = ca0106_midi_write;\r\nmidi->get_dev_id_card = ca0106_dev_id_card;\r\nmidi->get_dev_id_port = ca0106_dev_id_port;\r\nmidi->dev_id = chip;\r\nif ((err = ca_midi_init(chip, midi, 0, name)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_ca0106 *chip;\r\nint i, err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ca0106_create(dev, card, pci, &chip);\r\nif (err < 0)\r\ngoto error;\r\ncard->private_data = chip;\r\nfor (i = 0; i < 4; i++) {\r\nerr = snd_ca0106_pcm(chip, i);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nif (chip->details->ac97 == 1) {\r\nerr = snd_ca0106_ac97(chip);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nerr = snd_ca0106_mixer(chip);\r\nif (err < 0)\r\ngoto error;\r\ndev_dbg(card->dev, "probe for MIDI channel A ...");\r\nerr = snd_ca0106_midi(chip, CA0106_MIDI_CHAN_A);\r\nif (err < 0)\r\ngoto error;\r\ndev_dbg(card->dev, " done.\n");\r\n#ifdef CONFIG_PROC_FS\r\nsnd_ca0106_proc_init(chip);\r\n#endif\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_ca0106_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int snd_ca0106_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ca0106 *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < 4; i++)\r\nsnd_pcm_suspend_all(chip->pcm[i]);\r\nif (chip->details->ac97)\r\nsnd_ac97_suspend(chip->ac97);\r\nsnd_ca0106_mixer_suspend(chip);\r\nca0106_stop_chip(chip);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_ca0106_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ca0106 *chip = card->private_data;\r\nint i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nca0106_init_chip(chip, 1);\r\nif (chip->details->ac97)\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_ca0106_mixer_resume(chip);\r\nif (chip->details->spi_dac) {\r\nfor (i = 0; i < ARRAY_SIZE(chip->spi_dac_reg); i++)\r\nsnd_ca0106_spi_write(chip, chip->spi_dac_reg[i]);\r\n}\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
