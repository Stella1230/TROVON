static bool tb_cap_is_basic(struct tb_cap_any *cap)\r\n{\r\nreturn cap->basic.cap != 5;\r\n}\r\nstatic bool tb_cap_is_long(struct tb_cap_any *cap)\r\n{\r\nreturn !tb_cap_is_basic(cap)\r\n&& cap->extended_short.next == 0\r\n&& cap->extended_short.length == 0;\r\n}\r\nstatic enum tb_cap tb_cap(struct tb_cap_any *cap)\r\n{\r\nif (tb_cap_is_basic(cap))\r\nreturn cap->basic.cap;\r\nelse\r\nreturn cap->extended_short.cap;\r\n}\r\nstatic u32 tb_cap_next(struct tb_cap_any *cap, u32 offset)\r\n{\r\nint next;\r\nif (offset == 1) {\r\nnext = cap->basic.next;\r\n} else {\r\nif (tb_cap_is_basic(cap))\r\nnext = cap->basic.next;\r\nelse if (!tb_cap_is_long(cap))\r\nnext = cap->extended_short.next;\r\nelse\r\nnext = cap->extended_long.next;\r\n}\r\nif (next == offset)\r\nreturn 0;\r\nreturn next;\r\n}\r\nint tb_find_cap(struct tb_port *port, enum tb_cfg_space space, enum tb_cap cap)\r\n{\r\nu32 offset = 1;\r\nstruct tb_cap_any header;\r\nint res;\r\nint retries = 10;\r\nwhile (retries--) {\r\nres = tb_port_read(port, &header, space, offset, 1);\r\nif (res) {\r\nif (space == TB_CFG_PORT && offset == 0xa\r\n&& port->config.type == TB_TYPE_DP_HDMI_OUT) {\r\noffset = 0x39;\r\ncontinue;\r\n}\r\nreturn res;\r\n}\r\nif (offset != 1) {\r\nif (tb_cap(&header) == cap)\r\nreturn offset;\r\nif (tb_cap_is_long(&header)) {\r\nres = tb_port_read(port, &header, space,\r\noffset, 2);\r\nif (res)\r\nreturn res;\r\n}\r\n}\r\noffset = tb_cap_next(&header, offset);\r\nif (!offset)\r\nreturn 0;\r\n}\r\ntb_port_WARN(port,\r\n"run out of retries while looking for cap %#x in config space %d, last offset: %#x\n",\r\ncap, space, offset);\r\nreturn -EIO;\r\n}
