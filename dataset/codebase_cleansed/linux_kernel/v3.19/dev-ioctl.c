static int check_name(const char *name)\r\n{\r\nif (!strchr(name, '/'))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int invalid_str(char *str, size_t size)\r\n{\r\nif (memchr(str, 0, size))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\r\n{\r\nint err = 0;\r\nif ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||\r\n(AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {\r\nAUTOFS_WARN("ioctl control interface version mismatch: "\r\n"kernel(%u.%u), user(%u.%u), cmd(%d)",\r\nAUTOFS_DEV_IOCTL_VERSION_MAJOR,\r\nAUTOFS_DEV_IOCTL_VERSION_MINOR,\r\nparam->ver_major, param->ver_minor, cmd);\r\nerr = -EINVAL;\r\n}\r\nparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\r\nparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\r\nreturn err;\r\n}\r\nstatic struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)\r\n{\r\nstruct autofs_dev_ioctl tmp;\r\nif (copy_from_user(&tmp, in, sizeof(tmp)))\r\nreturn ERR_PTR(-EFAULT);\r\nif (tmp.size < sizeof(tmp))\r\nreturn ERR_PTR(-EINVAL);\r\nif (tmp.size > (PATH_MAX + sizeof(tmp)))\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn memdup_user(in, tmp.size);\r\n}\r\nstatic inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\r\n{\r\nkfree(param);\r\nreturn;\r\n}\r\nstatic int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\r\n{\r\nint err;\r\nerr = check_dev_ioctl_version(cmd, param);\r\nif (err) {\r\nAUTOFS_WARN("invalid device control module version "\r\n"supplied for cmd(0x%08x)", cmd);\r\ngoto out;\r\n}\r\nif (param->size > sizeof(*param)) {\r\nerr = invalid_str(param->path, param->size - sizeof(*param));\r\nif (err) {\r\nAUTOFS_WARN(\r\n"path string terminator missing for cmd(0x%08x)",\r\ncmd);\r\ngoto out;\r\n}\r\nerr = check_name(param->path);\r\nif (err) {\r\nAUTOFS_WARN("invalid path supplied for cmd(0x%08x)",\r\ncmd);\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic struct autofs_sb_info *autofs_dev_ioctl_sbi(struct file *f)\r\n{\r\nstruct autofs_sb_info *sbi = NULL;\r\nstruct inode *inode;\r\nif (f) {\r\ninode = file_inode(f);\r\nsbi = autofs4_sbi(inode->i_sb);\r\n}\r\nreturn sbi;\r\n}\r\nstatic int autofs_dev_ioctl_protover(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nparam->protover.version = sbi->version;\r\nreturn 0;\r\n}\r\nstatic int autofs_dev_ioctl_protosubver(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nparam->protosubver.sub_version = sbi->sub_version;\r\nreturn 0;\r\n}\r\nstatic int find_autofs_mount(const char *pathname,\r\nstruct path *res,\r\nint test(struct path *path, void *data),\r\nvoid *data)\r\n{\r\nstruct path path;\r\nint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\r\nif (err)\r\nreturn err;\r\nerr = -ENOENT;\r\nwhile (path.dentry == path.mnt->mnt_root) {\r\nif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\r\nif (test(&path, data)) {\r\npath_get(&path);\r\n*res = path;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (!follow_up(&path))\r\nbreak;\r\n}\r\npath_put(&path);\r\nreturn err;\r\n}\r\nstatic int test_by_dev(struct path *path, void *p)\r\n{\r\nreturn path->dentry->d_sb->s_dev == *(dev_t *)p;\r\n}\r\nstatic int test_by_type(struct path *path, void *p)\r\n{\r\nstruct autofs_info *ino = autofs4_dentry_ino(path->dentry);\r\nreturn ino && ino->sbi->type & *(unsigned *)p;\r\n}\r\nstatic int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\r\n{\r\nint err, fd;\r\nfd = get_unused_fd_flags(O_CLOEXEC);\r\nif (likely(fd >= 0)) {\r\nstruct file *filp;\r\nstruct path path;\r\nerr = find_autofs_mount(name, &path, test_by_dev, &devid);\r\nif (err)\r\ngoto out;\r\nfilp = dentry_open(&path, O_RDONLY, current_cred());\r\npath_put(&path);\r\nif (IS_ERR(filp)) {\r\nerr = PTR_ERR(filp);\r\ngoto out;\r\n}\r\nfd_install(fd, filp);\r\n}\r\nreturn fd;\r\nout:\r\nput_unused_fd(fd);\r\nreturn err;\r\n}\r\nstatic int autofs_dev_ioctl_openmount(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nconst char *path;\r\ndev_t devid;\r\nint err, fd;\r\nif (!param->openmount.devid)\r\nreturn -EINVAL;\r\nparam->ioctlfd = -1;\r\npath = param->path;\r\ndevid = new_decode_dev(param->openmount.devid);\r\nerr = 0;\r\nfd = autofs_dev_ioctl_open_mountpoint(path, devid);\r\nif (unlikely(fd < 0)) {\r\nerr = fd;\r\ngoto out;\r\n}\r\nparam->ioctlfd = fd;\r\nout:\r\nreturn err;\r\n}\r\nstatic int autofs_dev_ioctl_closemount(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nreturn sys_close(param->ioctlfd);\r\n}\r\nstatic int autofs_dev_ioctl_ready(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nautofs_wqt_t token;\r\ntoken = (autofs_wqt_t) param->ready.token;\r\nreturn autofs4_wait_release(sbi, token, 0);\r\n}\r\nstatic int autofs_dev_ioctl_fail(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nautofs_wqt_t token;\r\nint status;\r\ntoken = (autofs_wqt_t) param->fail.token;\r\nstatus = param->fail.status ? param->fail.status : -ENOENT;\r\nreturn autofs4_wait_release(sbi, token, status);\r\n}\r\nstatic int autofs_dev_ioctl_setpipefd(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nint pipefd;\r\nint err = 0;\r\nstruct pid *new_pid = NULL;\r\nif (param->setpipefd.pipefd == -1)\r\nreturn -EINVAL;\r\npipefd = param->setpipefd.pipefd;\r\nmutex_lock(&sbi->wq_mutex);\r\nif (!sbi->catatonic) {\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn -EBUSY;\r\n} else {\r\nstruct file *pipe;\r\nnew_pid = get_task_pid(current, PIDTYPE_PGID);\r\nif (ns_of_pid(new_pid) != ns_of_pid(sbi->oz_pgrp)) {\r\nAUTOFS_WARN("Not allowed to change PID namespace");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\npipe = fget(pipefd);\r\nif (!pipe) {\r\nerr = -EBADF;\r\ngoto out;\r\n}\r\nif (autofs_prepare_pipe(pipe) < 0) {\r\nerr = -EPIPE;\r\nfput(pipe);\r\ngoto out;\r\n}\r\nswap(sbi->oz_pgrp, new_pid);\r\nsbi->pipefd = pipefd;\r\nsbi->pipe = pipe;\r\nsbi->catatonic = 0;\r\n}\r\nout:\r\nput_pid(new_pid);\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn err;\r\n}\r\nstatic int autofs_dev_ioctl_catatonic(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nautofs4_catatonic_mode(sbi);\r\nreturn 0;\r\n}\r\nstatic int autofs_dev_ioctl_timeout(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nunsigned long timeout;\r\ntimeout = param->timeout.timeout;\r\nparam->timeout.timeout = sbi->exp_timeout / HZ;\r\nsbi->exp_timeout = timeout * HZ;\r\nreturn 0;\r\n}\r\nstatic int autofs_dev_ioctl_requester(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nstruct autofs_info *ino;\r\nstruct path path;\r\ndev_t devid;\r\nint err = -ENOENT;\r\nif (param->size <= sizeof(*param)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ndevid = sbi->sb->s_dev;\r\nparam->requester.uid = param->requester.gid = -1;\r\nerr = find_autofs_mount(param->path, &path, test_by_dev, &devid);\r\nif (err)\r\ngoto out;\r\nino = autofs4_dentry_ino(path.dentry);\r\nif (ino) {\r\nerr = 0;\r\nautofs4_expire_wait(path.dentry, 0);\r\nspin_lock(&sbi->fs_lock);\r\nparam->requester.uid = from_kuid_munged(current_user_ns(), ino->uid);\r\nparam->requester.gid = from_kgid_munged(current_user_ns(), ino->gid);\r\nspin_unlock(&sbi->fs_lock);\r\n}\r\npath_put(&path);\r\nout:\r\nreturn err;\r\n}\r\nstatic int autofs_dev_ioctl_expire(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nstruct vfsmount *mnt;\r\nint how;\r\nhow = param->expire.how;\r\nmnt = fp->f_path.mnt;\r\nreturn autofs4_do_expire_multi(sbi->sb, mnt, sbi, how);\r\n}\r\nstatic int autofs_dev_ioctl_askumount(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nparam->askumount.may_umount = 0;\r\nif (may_umount(fp->f_path.mnt))\r\nparam->askumount.may_umount = 1;\r\nreturn 0;\r\n}\r\nstatic int autofs_dev_ioctl_ismountpoint(struct file *fp,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_dev_ioctl *param)\r\n{\r\nstruct path path;\r\nconst char *name;\r\nunsigned int type;\r\nunsigned int devid, magic;\r\nint err = -ENOENT;\r\nif (param->size <= sizeof(*param)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nname = param->path;\r\ntype = param->ismountpoint.in.type;\r\nparam->ismountpoint.out.devid = devid = 0;\r\nparam->ismountpoint.out.magic = magic = 0;\r\nif (!fp || param->ioctlfd == -1) {\r\nif (autofs_type_any(type))\r\nerr = kern_path_mountpoint(AT_FDCWD,\r\nname, &path, LOOKUP_FOLLOW);\r\nelse\r\nerr = find_autofs_mount(name, &path,\r\ntest_by_type, &type);\r\nif (err)\r\ngoto out;\r\ndevid = new_encode_dev(path.dentry->d_sb->s_dev);\r\nerr = 0;\r\nif (path.mnt->mnt_root == path.dentry) {\r\nerr = 1;\r\nmagic = path.dentry->d_sb->s_magic;\r\n}\r\n} else {\r\ndev_t dev = sbi->sb->s_dev;\r\nerr = find_autofs_mount(name, &path, test_by_dev, &dev);\r\nif (err)\r\ngoto out;\r\ndevid = new_encode_dev(dev);\r\nerr = have_submounts(path.dentry);\r\nif (follow_down_one(&path))\r\nmagic = path.dentry->d_sb->s_magic;\r\n}\r\nparam->ismountpoint.out.devid = devid;\r\nparam->ismountpoint.out.magic = magic;\r\npath_put(&path);\r\nout:\r\nreturn err;\r\n}\r\nstatic ioctl_fn lookup_dev_ioctl(unsigned int cmd)\r\n{\r\nstatic struct {\r\nint cmd;\r\nioctl_fn fn;\r\n} _ioctls[] = {\r\n{cmd_idx(AUTOFS_DEV_IOCTL_VERSION_CMD), NULL},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_PROTOVER_CMD),\r\nautofs_dev_ioctl_protover},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD),\r\nautofs_dev_ioctl_protosubver},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_OPENMOUNT_CMD),\r\nautofs_dev_ioctl_openmount},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD),\r\nautofs_dev_ioctl_closemount},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_READY_CMD),\r\nautofs_dev_ioctl_ready},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_FAIL_CMD),\r\nautofs_dev_ioctl_fail},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_SETPIPEFD_CMD),\r\nautofs_dev_ioctl_setpipefd},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_CATATONIC_CMD),\r\nautofs_dev_ioctl_catatonic},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_TIMEOUT_CMD),\r\nautofs_dev_ioctl_timeout},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_REQUESTER_CMD),\r\nautofs_dev_ioctl_requester},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_EXPIRE_CMD),\r\nautofs_dev_ioctl_expire},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD),\r\nautofs_dev_ioctl_askumount},\r\n{cmd_idx(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD),\r\nautofs_dev_ioctl_ismountpoint}\r\n};\r\nunsigned int idx = cmd_idx(cmd);\r\nreturn (idx >= ARRAY_SIZE(_ioctls)) ? NULL : _ioctls[idx].fn;\r\n}\r\nstatic int _autofs_dev_ioctl(unsigned int command, struct autofs_dev_ioctl __user *user)\r\n{\r\nstruct autofs_dev_ioctl *param;\r\nstruct file *fp;\r\nstruct autofs_sb_info *sbi;\r\nunsigned int cmd_first, cmd;\r\nioctl_fn fn = NULL;\r\nint err = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ncmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\r\ncmd = _IOC_NR(command);\r\nif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\r\ncmd - cmd_first >= AUTOFS_DEV_IOCTL_IOC_COUNT) {\r\nreturn -ENOTTY;\r\n}\r\nparam = copy_dev_ioctl(user);\r\nif (IS_ERR(param))\r\nreturn PTR_ERR(param);\r\nerr = validate_dev_ioctl(command, param);\r\nif (err)\r\ngoto out;\r\nif (cmd == AUTOFS_DEV_IOCTL_VERSION_CMD)\r\ngoto done;\r\nfn = lookup_dev_ioctl(cmd);\r\nif (!fn) {\r\nAUTOFS_WARN("unknown command 0x%08x", command);\r\nreturn -ENOTTY;\r\n}\r\nfp = NULL;\r\nsbi = NULL;\r\nif (cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\r\ncmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\r\nfp = fget(param->ioctlfd);\r\nif (!fp) {\r\nif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\r\ngoto cont;\r\nerr = -EBADF;\r\ngoto out;\r\n}\r\nsbi = autofs_dev_ioctl_sbi(fp);\r\nif (!sbi || sbi->magic != AUTOFS_SBI_MAGIC) {\r\nerr = -EINVAL;\r\nfput(fp);\r\ngoto out;\r\n}\r\nif (!autofs4_oz_mode(sbi) &&\r\ncmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\r\nerr = -EACCES;\r\nfput(fp);\r\ngoto out;\r\n}\r\n}\r\ncont:\r\nerr = fn(fp, sbi, param);\r\nif (fp)\r\nfput(fp);\r\ndone:\r\nif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\r\nerr = -EFAULT;\r\nout:\r\nfree_dev_ioctl(param);\r\nreturn err;\r\n}\r\nstatic long autofs_dev_ioctl(struct file *file, uint command, ulong u)\r\n{\r\nint err;\r\nerr = _autofs_dev_ioctl(command, (struct autofs_dev_ioctl __user *) u);\r\nreturn (long) err;\r\n}\r\nstatic long autofs_dev_ioctl_compat(struct file *file, uint command, ulong u)\r\n{\r\nreturn (long) autofs_dev_ioctl(file, command, (ulong) compat_ptr(u));\r\n}\r\nint __init autofs_dev_ioctl_init(void)\r\n{\r\nint r;\r\nr = misc_register(&_autofs_dev_ioctl_misc);\r\nif (r) {\r\nAUTOFS_ERROR("misc_register failed for control device");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid autofs_dev_ioctl_exit(void)\r\n{\r\nmisc_deregister(&_autofs_dev_ioctl_misc);\r\nreturn;\r\n}
