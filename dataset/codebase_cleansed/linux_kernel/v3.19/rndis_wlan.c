static struct rndis_wlan_private *get_rndis_wlan_priv(struct usbnet *dev)\r\n{\r\nreturn (struct rndis_wlan_private *)dev->driver_priv;\r\n}\r\nstatic u32 get_bcm4320_power_dbm(struct rndis_wlan_private *priv)\r\n{\r\nswitch (priv->param_power_output) {\r\ndefault:\r\ncase 3:\r\nreturn BCM4320_DEFAULT_TXPOWER_DBM_100;\r\ncase 2:\r\nreturn BCM4320_DEFAULT_TXPOWER_DBM_75;\r\ncase 1:\r\nreturn BCM4320_DEFAULT_TXPOWER_DBM_50;\r\ncase 0:\r\nreturn BCM4320_DEFAULT_TXPOWER_DBM_25;\r\n}\r\n}\r\nstatic bool is_wpa_key(struct rndis_wlan_private *priv, u8 idx)\r\n{\r\nint cipher = priv->encr_keys[idx].cipher;\r\nreturn (cipher == WLAN_CIPHER_SUITE_CCMP ||\r\ncipher == WLAN_CIPHER_SUITE_TKIP);\r\n}\r\nstatic int rndis_cipher_to_alg(u32 cipher)\r\n{\r\nswitch (cipher) {\r\ndefault:\r\nreturn RNDIS_WLAN_ALG_NONE;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nreturn RNDIS_WLAN_ALG_WEP;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nreturn RNDIS_WLAN_ALG_TKIP;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nreturn RNDIS_WLAN_ALG_CCMP;\r\n}\r\n}\r\nstatic int rndis_akm_suite_to_key_mgmt(u32 akm_suite)\r\n{\r\nswitch (akm_suite) {\r\ndefault:\r\nreturn RNDIS_WLAN_KEY_MGMT_NONE;\r\ncase WLAN_AKM_SUITE_8021X:\r\nreturn RNDIS_WLAN_KEY_MGMT_802_1X;\r\ncase WLAN_AKM_SUITE_PSK:\r\nreturn RNDIS_WLAN_KEY_MGMT_PSK;\r\n}\r\n}\r\nstatic const char *oid_to_string(u32 oid)\r\n{\r\nswitch (oid) {\r\n#define OID_STR(oid) case oid: return(#oid)\r\nOID_STR(RNDIS_OID_802_3_PERMANENT_ADDRESS);\r\nOID_STR(RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE);\r\nOID_STR(RNDIS_OID_GEN_CURRENT_PACKET_FILTER);\r\nOID_STR(RNDIS_OID_GEN_PHYSICAL_MEDIUM);\r\nOID_STR(RNDIS_OID_GEN_LINK_SPEED);\r\nOID_STR(RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER);\r\nOID_STR(RNDIS_OID_GEN_XMIT_OK);\r\nOID_STR(RNDIS_OID_GEN_RCV_OK);\r\nOID_STR(RNDIS_OID_GEN_XMIT_ERROR);\r\nOID_STR(RNDIS_OID_GEN_RCV_ERROR);\r\nOID_STR(RNDIS_OID_GEN_RCV_NO_BUFFER);\r\nOID_STR(RNDIS_OID_802_3_CURRENT_ADDRESS);\r\nOID_STR(RNDIS_OID_802_3_MULTICAST_LIST);\r\nOID_STR(RNDIS_OID_802_3_MAXIMUM_LIST_SIZE);\r\nOID_STR(RNDIS_OID_802_11_BSSID);\r\nOID_STR(RNDIS_OID_802_11_SSID);\r\nOID_STR(RNDIS_OID_802_11_INFRASTRUCTURE_MODE);\r\nOID_STR(RNDIS_OID_802_11_ADD_WEP);\r\nOID_STR(RNDIS_OID_802_11_REMOVE_WEP);\r\nOID_STR(RNDIS_OID_802_11_DISASSOCIATE);\r\nOID_STR(RNDIS_OID_802_11_AUTHENTICATION_MODE);\r\nOID_STR(RNDIS_OID_802_11_PRIVACY_FILTER);\r\nOID_STR(RNDIS_OID_802_11_BSSID_LIST_SCAN);\r\nOID_STR(RNDIS_OID_802_11_ENCRYPTION_STATUS);\r\nOID_STR(RNDIS_OID_802_11_ADD_KEY);\r\nOID_STR(RNDIS_OID_802_11_REMOVE_KEY);\r\nOID_STR(RNDIS_OID_802_11_ASSOCIATION_INFORMATION);\r\nOID_STR(RNDIS_OID_802_11_CAPABILITY);\r\nOID_STR(RNDIS_OID_802_11_PMKID);\r\nOID_STR(RNDIS_OID_802_11_NETWORK_TYPES_SUPPORTED);\r\nOID_STR(RNDIS_OID_802_11_NETWORK_TYPE_IN_USE);\r\nOID_STR(RNDIS_OID_802_11_TX_POWER_LEVEL);\r\nOID_STR(RNDIS_OID_802_11_RSSI);\r\nOID_STR(RNDIS_OID_802_11_RSSI_TRIGGER);\r\nOID_STR(RNDIS_OID_802_11_FRAGMENTATION_THRESHOLD);\r\nOID_STR(RNDIS_OID_802_11_RTS_THRESHOLD);\r\nOID_STR(RNDIS_OID_802_11_SUPPORTED_RATES);\r\nOID_STR(RNDIS_OID_802_11_CONFIGURATION);\r\nOID_STR(RNDIS_OID_802_11_POWER_MODE);\r\nOID_STR(RNDIS_OID_802_11_BSSID_LIST);\r\n#undef OID_STR\r\n}\r\nreturn "?";\r\n}\r\nstatic const char *oid_to_string(u32 oid)\r\n{\r\nreturn "?";\r\n}\r\nstatic int rndis_error_status(__le32 rndis_status)\r\n{\r\nint ret = -EINVAL;\r\nswitch (le32_to_cpu(rndis_status)) {\r\ncase RNDIS_STATUS_SUCCESS:\r\nret = 0;\r\nbreak;\r\ncase RNDIS_STATUS_FAILURE:\r\ncase RNDIS_STATUS_INVALID_DATA:\r\nret = -EINVAL;\r\nbreak;\r\ncase RNDIS_STATUS_NOT_SUPPORTED:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase RNDIS_STATUS_ADAPTER_NOT_READY:\r\ncase RNDIS_STATUS_ADAPTER_NOT_OPEN:\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rndis_query_oid(struct usbnet *dev, u32 oid, void *data, int *len)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(dev);\r\nunion {\r\nvoid *buf;\r\nstruct rndis_msg_hdr *header;\r\nstruct rndis_query *get;\r\nstruct rndis_query_c *get_c;\r\n} u;\r\nint ret, buflen;\r\nint resplen, respoffs, copylen;\r\nbuflen = *len + sizeof(*u.get);\r\nif (buflen < CONTROL_BUFFER_SIZE)\r\nbuflen = CONTROL_BUFFER_SIZE;\r\nif (buflen > COMMAND_BUFFER_SIZE) {\r\nu.buf = kmalloc(buflen, GFP_KERNEL);\r\nif (!u.buf)\r\nreturn -ENOMEM;\r\n} else {\r\nu.buf = priv->command_buffer;\r\n}\r\nmutex_lock(&priv->command_lock);\r\nmemset(u.get, 0, sizeof *u.get);\r\nu.get->msg_type = cpu_to_le32(RNDIS_MSG_QUERY);\r\nu.get->msg_len = cpu_to_le32(sizeof *u.get);\r\nu.get->oid = cpu_to_le32(oid);\r\npriv->current_command_oid = oid;\r\nret = rndis_command(dev, u.header, buflen);\r\npriv->current_command_oid = 0;\r\nif (ret < 0)\r\nnetdev_dbg(dev->net, "%s(%s): rndis_command() failed, %d (%08x)\n",\r\n__func__, oid_to_string(oid), ret,\r\nle32_to_cpu(u.get_c->status));\r\nif (ret == 0) {\r\nresplen = le32_to_cpu(u.get_c->len);\r\nrespoffs = le32_to_cpu(u.get_c->offset) + 8;\r\nif (respoffs > buflen) {\r\nnetdev_dbg(dev->net, "%s(%s): received invalid "\r\n"data offset: %d > %d\n", __func__,\r\noid_to_string(oid), respoffs, buflen);\r\nret = -EINVAL;\r\ngoto exit_unlock;\r\n}\r\nif ((resplen + respoffs) > buflen) {\r\ncopylen = buflen - respoffs;\r\n} else {\r\ncopylen = resplen;\r\n}\r\nif (copylen > *len)\r\ncopylen = *len;\r\nmemcpy(data, u.buf + respoffs, copylen);\r\n*len = resplen;\r\nret = rndis_error_status(u.get_c->status);\r\nif (ret < 0)\r\nnetdev_dbg(dev->net, "%s(%s): device returned error, 0x%08x (%d)\n",\r\n__func__, oid_to_string(oid),\r\nle32_to_cpu(u.get_c->status), ret);\r\n}\r\nexit_unlock:\r\nmutex_unlock(&priv->command_lock);\r\nif (u.buf != priv->command_buffer)\r\nkfree(u.buf);\r\nreturn ret;\r\n}\r\nstatic int rndis_set_oid(struct usbnet *dev, u32 oid, const void *data,\r\nint len)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(dev);\r\nunion {\r\nvoid *buf;\r\nstruct rndis_msg_hdr *header;\r\nstruct rndis_set *set;\r\nstruct rndis_set_c *set_c;\r\n} u;\r\nint ret, buflen;\r\nbuflen = len + sizeof(*u.set);\r\nif (buflen < CONTROL_BUFFER_SIZE)\r\nbuflen = CONTROL_BUFFER_SIZE;\r\nif (buflen > COMMAND_BUFFER_SIZE) {\r\nu.buf = kmalloc(buflen, GFP_KERNEL);\r\nif (!u.buf)\r\nreturn -ENOMEM;\r\n} else {\r\nu.buf = priv->command_buffer;\r\n}\r\nmutex_lock(&priv->command_lock);\r\nmemset(u.set, 0, sizeof *u.set);\r\nu.set->msg_type = cpu_to_le32(RNDIS_MSG_SET);\r\nu.set->msg_len = cpu_to_le32(sizeof(*u.set) + len);\r\nu.set->oid = cpu_to_le32(oid);\r\nu.set->len = cpu_to_le32(len);\r\nu.set->offset = cpu_to_le32(sizeof(*u.set) - 8);\r\nu.set->handle = cpu_to_le32(0);\r\nmemcpy(u.buf + sizeof(*u.set), data, len);\r\npriv->current_command_oid = oid;\r\nret = rndis_command(dev, u.header, buflen);\r\npriv->current_command_oid = 0;\r\nif (ret < 0)\r\nnetdev_dbg(dev->net, "%s(%s): rndis_command() failed, %d (%08x)\n",\r\n__func__, oid_to_string(oid), ret,\r\nle32_to_cpu(u.set_c->status));\r\nif (ret == 0) {\r\nret = rndis_error_status(u.set_c->status);\r\nif (ret < 0)\r\nnetdev_dbg(dev->net, "%s(%s): device returned error, 0x%08x (%d)\n",\r\n__func__, oid_to_string(oid),\r\nle32_to_cpu(u.set_c->status), ret);\r\n}\r\nmutex_unlock(&priv->command_lock);\r\nif (u.buf != priv->command_buffer)\r\nkfree(u.buf);\r\nreturn ret;\r\n}\r\nstatic int rndis_reset(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct rndis_reset *reset;\r\nint ret;\r\nmutex_lock(&priv->command_lock);\r\nreset = (void *)priv->command_buffer;\r\nmemset(reset, 0, sizeof(*reset));\r\nreset->msg_type = cpu_to_le32(RNDIS_MSG_RESET);\r\nreset->msg_len = cpu_to_le32(sizeof(*reset));\r\npriv->current_command_oid = 0;\r\nret = rndis_command(usbdev, (void *)reset, CONTROL_BUFFER_SIZE);\r\nmutex_unlock(&priv->command_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rndis_set_config_parameter(struct usbnet *dev, char *param,\r\nint value_type, void *value)\r\n{\r\nstruct ndis_config_param *infobuf;\r\nint value_len, info_len, param_len, ret, i;\r\n__le16 *unibuf;\r\n__le32 *dst_value;\r\nif (value_type == 0)\r\nvalue_len = sizeof(__le32);\r\nelse if (value_type == 2)\r\nvalue_len = strlen(value) * sizeof(__le16);\r\nelse\r\nreturn -EINVAL;\r\nparam_len = strlen(param) * sizeof(__le16);\r\ninfo_len = sizeof(*infobuf) + param_len + value_len;\r\n#ifdef DEBUG\r\ninfo_len += 12;\r\n#endif\r\ninfobuf = kmalloc(info_len, GFP_KERNEL);\r\nif (!infobuf)\r\nreturn -ENOMEM;\r\n#ifdef DEBUG\r\ninfo_len -= 12;\r\nmemset(infobuf, 0xCC, info_len + 12);\r\n#endif\r\nif (value_type == 2)\r\nnetdev_dbg(dev->net, "setting config parameter: %s, value: %s\n",\r\nparam, (u8 *)value);\r\nelse\r\nnetdev_dbg(dev->net, "setting config parameter: %s, value: %d\n",\r\nparam, *(u32 *)value);\r\ninfobuf->name_offs = cpu_to_le32(sizeof(*infobuf));\r\ninfobuf->name_length = cpu_to_le32(param_len);\r\ninfobuf->type = cpu_to_le32(value_type);\r\ninfobuf->value_offs = cpu_to_le32(sizeof(*infobuf) + param_len);\r\ninfobuf->value_length = cpu_to_le32(value_len);\r\nunibuf = (void *)infobuf + sizeof(*infobuf);\r\nfor (i = 0; i < param_len / sizeof(__le16); i++)\r\nunibuf[i] = cpu_to_le16(param[i]);\r\nif (value_type == 2) {\r\nunibuf = (void *)infobuf + sizeof(*infobuf) + param_len;\r\nfor (i = 0; i < value_len / sizeof(__le16); i++)\r\nunibuf[i] = cpu_to_le16(((u8 *)value)[i]);\r\n} else {\r\ndst_value = (void *)infobuf + sizeof(*infobuf) + param_len;\r\n*dst_value = cpu_to_le32(*(u32 *)value);\r\n}\r\n#ifdef DEBUG\r\nnetdev_dbg(dev->net, "info buffer (len: %d)\n", info_len);\r\nfor (i = 0; i < info_len; i += 12) {\r\nu32 *tmp = (u32 *)((u8 *)infobuf + i);\r\nnetdev_dbg(dev->net, "%08X:%08X:%08X\n",\r\ncpu_to_be32(tmp[0]),\r\ncpu_to_be32(tmp[1]),\r\ncpu_to_be32(tmp[2]));\r\n}\r\n#endif\r\nret = rndis_set_oid(dev, RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER,\r\ninfobuf, info_len);\r\nif (ret != 0)\r\nnetdev_dbg(dev->net, "setting rndis config parameter failed, %d\n",\r\nret);\r\nkfree(infobuf);\r\nreturn ret;\r\n}\r\nstatic int rndis_set_config_parameter_str(struct usbnet *dev,\r\nchar *param, char *value)\r\n{\r\nreturn rndis_set_config_parameter(dev, param, 2, value);\r\n}\r\nstatic int level_to_qual(int level)\r\n{\r\nint qual = 100 * (level - WL_NOISE) / (WL_SIGMAX - WL_NOISE);\r\nreturn qual >= 0 ? (qual <= 100 ? qual : 100) : 0;\r\n}\r\nstatic int rndis_start_bssid_list_scan(struct usbnet *usbdev)\r\n{\r\n__le32 tmp;\r\ntmp = cpu_to_le32(1);\r\nreturn rndis_set_oid(usbdev, RNDIS_OID_802_11_BSSID_LIST_SCAN, &tmp,\r\nsizeof(tmp));\r\n}\r\nstatic int set_essid(struct usbnet *usbdev, struct ndis_80211_ssid *ssid)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nint ret;\r\nret = rndis_set_oid(usbdev, RNDIS_OID_802_11_SSID,\r\nssid, sizeof(*ssid));\r\nif (ret < 0) {\r\nnetdev_warn(usbdev->net, "setting SSID failed (%08X)\n", ret);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\npriv->radio_on = true;\r\nnetdev_dbg(usbdev->net, "%s(): radio_on = true\n", __func__);\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_bssid(struct usbnet *usbdev, const u8 *bssid)\r\n{\r\nint ret;\r\nret = rndis_set_oid(usbdev, RNDIS_OID_802_11_BSSID,\r\nbssid, ETH_ALEN);\r\nif (ret < 0) {\r\nnetdev_warn(usbdev->net, "setting BSSID[%pM] failed (%08X)\n",\r\nbssid, ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int clear_bssid(struct usbnet *usbdev)\r\n{\r\nstatic const u8 broadcast_mac[ETH_ALEN] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nreturn set_bssid(usbdev, broadcast_mac);\r\n}\r\nstatic int get_bssid(struct usbnet *usbdev, u8 bssid[ETH_ALEN])\r\n{\r\nint ret, len;\r\nlen = ETH_ALEN;\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_BSSID,\r\nbssid, &len);\r\nif (ret != 0)\r\nmemset(bssid, 0, ETH_ALEN);\r\nreturn ret;\r\n}\r\nstatic int get_association_info(struct usbnet *usbdev,\r\nstruct ndis_80211_assoc_info *info, int len)\r\n{\r\nreturn rndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_ASSOCIATION_INFORMATION,\r\ninfo, &len);\r\n}\r\nstatic bool is_associated(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nu8 bssid[ETH_ALEN];\r\nint ret;\r\nif (!priv->radio_on)\r\nreturn false;\r\nret = get_bssid(usbdev, bssid);\r\nreturn (ret == 0 && !is_zero_ether_addr(bssid));\r\n}\r\nstatic int disassociate(struct usbnet *usbdev, bool reset_ssid)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_ssid ssid;\r\nint i, ret = 0;\r\nif (priv->radio_on) {\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_DISASSOCIATE,\r\nNULL, 0);\r\nif (ret == 0) {\r\npriv->radio_on = false;\r\nnetdev_dbg(usbdev->net, "%s(): radio_on = false\n",\r\n__func__);\r\nif (reset_ssid)\r\nmsleep(100);\r\n}\r\n}\r\nif (reset_ssid) {\r\nset_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\r\nssid.length = cpu_to_le32(sizeof(ssid.essid));\r\nget_random_bytes(&ssid.essid[2], sizeof(ssid.essid)-2);\r\nssid.essid[0] = 0x1;\r\nssid.essid[1] = 0xff;\r\nfor (i = 2; i < sizeof(ssid.essid); i++)\r\nssid.essid[i] = 0x1 + (ssid.essid[i] * 0xfe / 0xff);\r\nret = set_essid(usbdev, &ssid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_auth_mode(struct usbnet *usbdev, u32 wpa_version,\r\nenum nl80211_auth_type auth_type, int keymgmt)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\n__le32 tmp;\r\nint auth_mode, ret;\r\nnetdev_dbg(usbdev->net, "%s(): wpa_version=0x%x authalg=0x%x keymgmt=0x%x\n",\r\n__func__, wpa_version, auth_type, keymgmt);\r\nif (wpa_version & NL80211_WPA_VERSION_2) {\r\nif (keymgmt & RNDIS_WLAN_KEY_MGMT_802_1X)\r\nauth_mode = NDIS_80211_AUTH_WPA2;\r\nelse\r\nauth_mode = NDIS_80211_AUTH_WPA2_PSK;\r\n} else if (wpa_version & NL80211_WPA_VERSION_1) {\r\nif (keymgmt & RNDIS_WLAN_KEY_MGMT_802_1X)\r\nauth_mode = NDIS_80211_AUTH_WPA;\r\nelse if (keymgmt & RNDIS_WLAN_KEY_MGMT_PSK)\r\nauth_mode = NDIS_80211_AUTH_WPA_PSK;\r\nelse\r\nauth_mode = NDIS_80211_AUTH_WPA_NONE;\r\n} else if (auth_type == NL80211_AUTHTYPE_SHARED_KEY)\r\nauth_mode = NDIS_80211_AUTH_SHARED;\r\nelse if (auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM)\r\nauth_mode = NDIS_80211_AUTH_OPEN;\r\nelse if (auth_type == NL80211_AUTHTYPE_AUTOMATIC)\r\nauth_mode = NDIS_80211_AUTH_AUTO_SWITCH;\r\nelse\r\nreturn -ENOTSUPP;\r\ntmp = cpu_to_le32(auth_mode);\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_AUTHENTICATION_MODE,\r\n&tmp, sizeof(tmp));\r\nif (ret != 0) {\r\nnetdev_warn(usbdev->net, "setting auth mode failed (%08X)\n",\r\nret);\r\nreturn ret;\r\n}\r\npriv->wpa_version = wpa_version;\r\nreturn 0;\r\n}\r\nstatic int set_priv_filter(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\n__le32 tmp;\r\nnetdev_dbg(usbdev->net, "%s(): wpa_version=0x%x\n",\r\n__func__, priv->wpa_version);\r\nif (priv->wpa_version & NL80211_WPA_VERSION_2 ||\r\npriv->wpa_version & NL80211_WPA_VERSION_1)\r\ntmp = cpu_to_le32(NDIS_80211_PRIV_8021X_WEP);\r\nelse\r\ntmp = cpu_to_le32(NDIS_80211_PRIV_ACCEPT_ALL);\r\nreturn rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_PRIVACY_FILTER, &tmp,\r\nsizeof(tmp));\r\n}\r\nstatic int set_encr_mode(struct usbnet *usbdev, int pairwise, int groupwise)\r\n{\r\n__le32 tmp;\r\nint encr_mode, ret;\r\nnetdev_dbg(usbdev->net, "%s(): cipher_pair=0x%x cipher_group=0x%x\n",\r\n__func__, pairwise, groupwise);\r\nif (pairwise & RNDIS_WLAN_ALG_CCMP)\r\nencr_mode = NDIS_80211_ENCR_CCMP_ENABLED;\r\nelse if (pairwise & RNDIS_WLAN_ALG_TKIP)\r\nencr_mode = NDIS_80211_ENCR_TKIP_ENABLED;\r\nelse if (pairwise & RNDIS_WLAN_ALG_WEP)\r\nencr_mode = NDIS_80211_ENCR_WEP_ENABLED;\r\nelse if (groupwise & RNDIS_WLAN_ALG_CCMP)\r\nencr_mode = NDIS_80211_ENCR_CCMP_ENABLED;\r\nelse if (groupwise & RNDIS_WLAN_ALG_TKIP)\r\nencr_mode = NDIS_80211_ENCR_TKIP_ENABLED;\r\nelse\r\nencr_mode = NDIS_80211_ENCR_DISABLED;\r\ntmp = cpu_to_le32(encr_mode);\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_ENCRYPTION_STATUS, &tmp,\r\nsizeof(tmp));\r\nif (ret != 0) {\r\nnetdev_warn(usbdev->net, "setting encr mode failed (%08X)\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_infra_mode(struct usbnet *usbdev, int mode)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\n__le32 tmp;\r\nint ret;\r\nnetdev_dbg(usbdev->net, "%s(): infra_mode=0x%x\n",\r\n__func__, priv->infra_mode);\r\ntmp = cpu_to_le32(mode);\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_INFRASTRUCTURE_MODE,\r\n&tmp, sizeof(tmp));\r\nif (ret != 0) {\r\nnetdev_warn(usbdev->net, "setting infra mode failed (%08X)\n",\r\nret);\r\nreturn ret;\r\n}\r\nrestore_keys(usbdev);\r\npriv->infra_mode = mode;\r\nreturn 0;\r\n}\r\nstatic int set_rts_threshold(struct usbnet *usbdev, u32 rts_threshold)\r\n{\r\n__le32 tmp;\r\nnetdev_dbg(usbdev->net, "%s(): %i\n", __func__, rts_threshold);\r\nif (rts_threshold < 0 || rts_threshold > 2347)\r\nrts_threshold = 2347;\r\ntmp = cpu_to_le32(rts_threshold);\r\nreturn rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_RTS_THRESHOLD,\r\n&tmp, sizeof(tmp));\r\n}\r\nstatic int set_frag_threshold(struct usbnet *usbdev, u32 frag_threshold)\r\n{\r\n__le32 tmp;\r\nnetdev_dbg(usbdev->net, "%s(): %i\n", __func__, frag_threshold);\r\nif (frag_threshold < 256 || frag_threshold > 2346)\r\nfrag_threshold = 2346;\r\ntmp = cpu_to_le32(frag_threshold);\r\nreturn rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_FRAGMENTATION_THRESHOLD,\r\n&tmp, sizeof(tmp));\r\n}\r\nstatic void set_default_iw_params(struct usbnet *usbdev)\r\n{\r\nset_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\r\nset_auth_mode(usbdev, 0, NL80211_AUTHTYPE_OPEN_SYSTEM,\r\nRNDIS_WLAN_KEY_MGMT_NONE);\r\nset_priv_filter(usbdev);\r\nset_encr_mode(usbdev, RNDIS_WLAN_ALG_NONE, RNDIS_WLAN_ALG_NONE);\r\n}\r\nstatic int deauthenticate(struct usbnet *usbdev)\r\n{\r\nint ret;\r\nret = disassociate(usbdev, true);\r\nset_default_iw_params(usbdev);\r\nreturn ret;\r\n}\r\nstatic int set_channel(struct usbnet *usbdev, int channel)\r\n{\r\nstruct ndis_80211_conf config;\r\nunsigned int dsconfig;\r\nint len, ret;\r\nnetdev_dbg(usbdev->net, "%s(%d)\n", __func__, channel);\r\nif (is_associated(usbdev))\r\nreturn 0;\r\ndsconfig = 1000 *\r\nieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);\r\nlen = sizeof(config);\r\nret = rndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_CONFIGURATION,\r\n&config, &len);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "%s(): querying configuration failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nconfig.ds_config = cpu_to_le32(dsconfig);\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_CONFIGURATION,\r\n&config, sizeof(config));\r\nnetdev_dbg(usbdev->net, "%s(): %d -> %d\n", __func__, channel, ret);\r\nreturn ret;\r\n}\r\nstatic struct ieee80211_channel *get_current_channel(struct usbnet *usbdev,\r\nu32 *beacon_period)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ieee80211_channel *channel;\r\nstruct ndis_80211_conf config;\r\nint len, ret;\r\nlen = sizeof(config);\r\nret = rndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_CONFIGURATION,\r\n&config, &len);\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_CONFIGURATION -> %d\n",\r\n__func__, ret);\r\nif (ret < 0)\r\nreturn NULL;\r\nchannel = ieee80211_get_channel(priv->wdev.wiphy,\r\nKHZ_TO_MHZ(le32_to_cpu(config.ds_config)));\r\nif (!channel)\r\nreturn NULL;\r\nif (beacon_period)\r\n*beacon_period = le32_to_cpu(config.beacon_period);\r\nreturn channel;\r\n}\r\nstatic int add_wep_key(struct usbnet *usbdev, const u8 *key, int key_len,\r\nu8 index)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_wep_key ndis_key;\r\nu32 cipher;\r\nint ret;\r\nnetdev_dbg(usbdev->net, "%s(idx: %d, len: %d)\n",\r\n__func__, index, key_len);\r\nif (index >= RNDIS_WLAN_NUM_KEYS)\r\nreturn -EINVAL;\r\nif (key_len == 5)\r\ncipher = WLAN_CIPHER_SUITE_WEP40;\r\nelse if (key_len == 13)\r\ncipher = WLAN_CIPHER_SUITE_WEP104;\r\nelse\r\nreturn -EINVAL;\r\nmemset(&ndis_key, 0, sizeof(ndis_key));\r\nndis_key.size = cpu_to_le32(sizeof(ndis_key));\r\nndis_key.length = cpu_to_le32(key_len);\r\nndis_key.index = cpu_to_le32(index);\r\nmemcpy(&ndis_key.material, key, key_len);\r\nif (index == priv->encr_tx_key_index) {\r\nndis_key.index |= NDIS_80211_ADDWEP_TRANSMIT_KEY;\r\nret = set_encr_mode(usbdev, RNDIS_WLAN_ALG_WEP,\r\nRNDIS_WLAN_ALG_NONE);\r\nif (ret)\r\nnetdev_warn(usbdev->net, "encryption couldn't be enabled (%08X)\n",\r\nret);\r\n}\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_ADD_WEP, &ndis_key,\r\nsizeof(ndis_key));\r\nif (ret != 0) {\r\nnetdev_warn(usbdev->net, "adding encryption key %d failed (%08X)\n",\r\nindex + 1, ret);\r\nreturn ret;\r\n}\r\npriv->encr_keys[index].len = key_len;\r\npriv->encr_keys[index].cipher = cipher;\r\nmemcpy(&priv->encr_keys[index].material, key, key_len);\r\nmemset(&priv->encr_keys[index].bssid, 0xff, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int add_wpa_key(struct usbnet *usbdev, const u8 *key, int key_len,\r\nu8 index, const u8 *addr, const u8 *rx_seq,\r\nint seq_len, u32 cipher, __le32 flags)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_key ndis_key;\r\nbool is_addr_ok;\r\nint ret;\r\nif (index >= RNDIS_WLAN_NUM_KEYS) {\r\nnetdev_dbg(usbdev->net, "%s(): index out of range (%i)\n",\r\n__func__, index);\r\nreturn -EINVAL;\r\n}\r\nif (key_len > sizeof(ndis_key.material) || key_len < 0) {\r\nnetdev_dbg(usbdev->net, "%s(): key length out of range (%i)\n",\r\n__func__, key_len);\r\nreturn -EINVAL;\r\n}\r\nif (flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ) {\r\nif (!rx_seq || seq_len <= 0) {\r\nnetdev_dbg(usbdev->net, "%s(): recv seq flag without buffer\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (rx_seq && seq_len > sizeof(ndis_key.rsc)) {\r\nnetdev_dbg(usbdev->net, "%s(): too big recv seq buffer\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nis_addr_ok = addr && !is_zero_ether_addr(addr) &&\r\n!is_broadcast_ether_addr(addr);\r\nif ((flags & NDIS_80211_ADDKEY_PAIRWISE_KEY) && !is_addr_ok) {\r\nnetdev_dbg(usbdev->net, "%s(): pairwise but bssid invalid (%pM)\n",\r\n__func__, addr);\r\nreturn -EINVAL;\r\n}\r\nnetdev_dbg(usbdev->net, "%s(%i): flags:%i%i%i\n",\r\n__func__, index,\r\n!!(flags & NDIS_80211_ADDKEY_TRANSMIT_KEY),\r\n!!(flags & NDIS_80211_ADDKEY_PAIRWISE_KEY),\r\n!!(flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ));\r\nmemset(&ndis_key, 0, sizeof(ndis_key));\r\nndis_key.size = cpu_to_le32(sizeof(ndis_key) -\r\nsizeof(ndis_key.material) + key_len);\r\nndis_key.length = cpu_to_le32(key_len);\r\nndis_key.index = cpu_to_le32(index) | flags;\r\nif (cipher == WLAN_CIPHER_SUITE_TKIP && key_len == 32) {\r\nmemcpy(ndis_key.material, key, 16);\r\nmemcpy(ndis_key.material + 16, key + 24, 8);\r\nmemcpy(ndis_key.material + 24, key + 16, 8);\r\n} else\r\nmemcpy(ndis_key.material, key, key_len);\r\nif (flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ)\r\nmemcpy(ndis_key.rsc, rx_seq, seq_len);\r\nif (flags & NDIS_80211_ADDKEY_PAIRWISE_KEY) {\r\nmemcpy(ndis_key.bssid, addr, ETH_ALEN);\r\n} else {\r\nif (priv->infra_mode == NDIS_80211_INFRA_ADHOC)\r\nmemset(ndis_key.bssid, 0xff, ETH_ALEN);\r\nelse\r\nget_bssid(usbdev, ndis_key.bssid);\r\n}\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_ADD_KEY, &ndis_key,\r\nle32_to_cpu(ndis_key.size));\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_ADD_KEY -> %08X\n",\r\n__func__, ret);\r\nif (ret != 0)\r\nreturn ret;\r\nmemset(&priv->encr_keys[index], 0, sizeof(priv->encr_keys[index]));\r\npriv->encr_keys[index].len = key_len;\r\npriv->encr_keys[index].cipher = cipher;\r\nmemcpy(&priv->encr_keys[index].material, key, key_len);\r\nif (flags & NDIS_80211_ADDKEY_PAIRWISE_KEY)\r\nmemcpy(&priv->encr_keys[index].bssid, ndis_key.bssid, ETH_ALEN);\r\nelse\r\nmemset(&priv->encr_keys[index].bssid, 0xff, ETH_ALEN);\r\nif (flags & NDIS_80211_ADDKEY_TRANSMIT_KEY)\r\npriv->encr_tx_key_index = index;\r\nreturn 0;\r\n}\r\nstatic int restore_key(struct usbnet *usbdev, u8 key_idx)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct rndis_wlan_encr_key key;\r\nif (is_wpa_key(priv, key_idx))\r\nreturn 0;\r\nkey = priv->encr_keys[key_idx];\r\nnetdev_dbg(usbdev->net, "%s(): %i:%i\n", __func__, key_idx, key.len);\r\nif (key.len == 0)\r\nreturn 0;\r\nreturn add_wep_key(usbdev, key.material, key.len, key_idx);\r\n}\r\nstatic void restore_keys(struct usbnet *usbdev)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nrestore_key(usbdev, i);\r\n}\r\nstatic void clear_key(struct rndis_wlan_private *priv, u8 idx)\r\n{\r\nmemset(&priv->encr_keys[idx], 0, sizeof(priv->encr_keys[idx]));\r\n}\r\nstatic int remove_key(struct usbnet *usbdev, u8 index, const u8 *bssid)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_remove_key remove_key;\r\n__le32 keyindex;\r\nbool is_wpa;\r\nint ret;\r\nif (index >= RNDIS_WLAN_NUM_KEYS)\r\nreturn -ENOENT;\r\nif (priv->encr_keys[index].len == 0)\r\nreturn 0;\r\nis_wpa = is_wpa_key(priv, index);\r\nnetdev_dbg(usbdev->net, "%s(): %i:%s:%i\n",\r\n__func__, index, is_wpa ? "wpa" : "wep",\r\npriv->encr_keys[index].len);\r\nclear_key(priv, index);\r\nif (is_wpa) {\r\nremove_key.size = cpu_to_le32(sizeof(remove_key));\r\nremove_key.index = cpu_to_le32(index);\r\nif (bssid) {\r\nif (!is_broadcast_ether_addr(bssid))\r\nremove_key.index |=\r\nNDIS_80211_ADDKEY_PAIRWISE_KEY;\r\nmemcpy(remove_key.bssid, bssid,\r\nsizeof(remove_key.bssid));\r\n} else\r\nmemset(remove_key.bssid, 0xff,\r\nsizeof(remove_key.bssid));\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_REMOVE_KEY,\r\n&remove_key, sizeof(remove_key));\r\nif (ret != 0)\r\nreturn ret;\r\n} else {\r\nkeyindex = cpu_to_le32(index);\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_REMOVE_WEP,\r\n&keyindex, sizeof(keyindex));\r\nif (ret != 0) {\r\nnetdev_warn(usbdev->net,\r\n"removing encryption key %d failed (%08X)\n",\r\nindex, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (index == priv->encr_tx_key_index)\r\nset_encr_mode(usbdev, RNDIS_WLAN_ALG_NONE, RNDIS_WLAN_ALG_NONE);\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct netdev_hw_addr *ha;\r\n__le32 filter, basefilter;\r\nint ret;\r\nchar *mc_addrs = NULL;\r\nint mc_count;\r\nbasefilter = filter = cpu_to_le32(RNDIS_PACKET_TYPE_DIRECTED |\r\nRNDIS_PACKET_TYPE_BROADCAST);\r\nif (usbdev->net->flags & IFF_PROMISC) {\r\nfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_PROMISCUOUS |\r\nRNDIS_PACKET_TYPE_ALL_LOCAL);\r\n} else if (usbdev->net->flags & IFF_ALLMULTI) {\r\nfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\r\n}\r\nif (filter != basefilter)\r\ngoto set_filter;\r\nnetif_addr_lock_bh(usbdev->net);\r\nmc_count = netdev_mc_count(usbdev->net);\r\nif (mc_count > priv->multicast_size) {\r\nfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\r\n} else if (mc_count) {\r\nint i = 0;\r\nmc_addrs = kmalloc_array(mc_count, ETH_ALEN, GFP_ATOMIC);\r\nif (!mc_addrs) {\r\nnetif_addr_unlock_bh(usbdev->net);\r\nreturn;\r\n}\r\nnetdev_for_each_mc_addr(ha, usbdev->net)\r\nmemcpy(mc_addrs + i++ * ETH_ALEN,\r\nha->addr, ETH_ALEN);\r\n}\r\nnetif_addr_unlock_bh(usbdev->net);\r\nif (filter != basefilter)\r\ngoto set_filter;\r\nif (mc_count) {\r\nret = rndis_set_oid(usbdev,\r\nRNDIS_OID_802_3_MULTICAST_LIST,\r\nmc_addrs, mc_count * ETH_ALEN);\r\nkfree(mc_addrs);\r\nif (ret == 0)\r\nfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_MULTICAST);\r\nelse\r\nfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\r\nnetdev_dbg(usbdev->net, "RNDIS_OID_802_3_MULTICAST_LIST(%d, max: %d) -> %d\n",\r\nmc_count, priv->multicast_size, ret);\r\n}\r\nset_filter:\r\nret = rndis_set_oid(usbdev, RNDIS_OID_GEN_CURRENT_PACKET_FILTER, &filter,\r\nsizeof(filter));\r\nif (ret < 0) {\r\nnetdev_warn(usbdev->net, "couldn't set packet filter: %08x\n",\r\nle32_to_cpu(filter));\r\n}\r\nnetdev_dbg(usbdev->net, "RNDIS_OID_GEN_CURRENT_PACKET_FILTER(%08x) -> %d\n",\r\nle32_to_cpu(filter), ret);\r\n}\r\nstatic void debug_print_pmkids(struct usbnet *usbdev,\r\nstruct ndis_80211_pmkid *pmkids,\r\nconst char *func_str)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nint i, len, count, max_pmkids, entry_len;\r\nmax_pmkids = priv->wdev.wiphy->max_num_pmkids;\r\nlen = le32_to_cpu(pmkids->length);\r\ncount = le32_to_cpu(pmkids->bssid_info_count);\r\nentry_len = (count > 0) ? (len - sizeof(*pmkids)) / count : -1;\r\nnetdev_dbg(usbdev->net, "%s(): %d PMKIDs (data len: %d, entry len: "\r\n"%d)\n", func_str, count, len, entry_len);\r\nif (count > max_pmkids)\r\ncount = max_pmkids;\r\nfor (i = 0; i < count; i++) {\r\nu32 *tmp = (u32 *)pmkids->bssid_info[i].pmkid;\r\nnetdev_dbg(usbdev->net, "%s(): bssid: %pM, "\r\n"pmkid: %08X:%08X:%08X:%08X\n",\r\nfunc_str, pmkids->bssid_info[i].bssid,\r\ncpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\r\ncpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\r\n}\r\n}\r\nstatic void debug_print_pmkids(struct usbnet *usbdev,\r\nstruct ndis_80211_pmkid *pmkids,\r\nconst char *func_str)\r\n{\r\nreturn;\r\n}\r\nstatic struct ndis_80211_pmkid *get_device_pmkids(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_pmkid *pmkids;\r\nint len, ret, max_pmkids;\r\nmax_pmkids = priv->wdev.wiphy->max_num_pmkids;\r\nlen = sizeof(*pmkids) + max_pmkids * sizeof(pmkids->bssid_info[0]);\r\npmkids = kzalloc(len, GFP_KERNEL);\r\nif (!pmkids)\r\nreturn ERR_PTR(-ENOMEM);\r\npmkids->length = cpu_to_le32(len);\r\npmkids->bssid_info_count = cpu_to_le32(max_pmkids);\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_PMKID,\r\npmkids, &len);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_PMKID(%d, %d)"\r\n" -> %d\n", __func__, len, max_pmkids, ret);\r\nkfree(pmkids);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (le32_to_cpu(pmkids->bssid_info_count) > max_pmkids)\r\npmkids->bssid_info_count = cpu_to_le32(max_pmkids);\r\ndebug_print_pmkids(usbdev, pmkids, __func__);\r\nreturn pmkids;\r\n}\r\nstatic int set_device_pmkids(struct usbnet *usbdev,\r\nstruct ndis_80211_pmkid *pmkids)\r\n{\r\nint ret, len, num_pmkids;\r\nnum_pmkids = le32_to_cpu(pmkids->bssid_info_count);\r\nlen = sizeof(*pmkids) + num_pmkids * sizeof(pmkids->bssid_info[0]);\r\npmkids->length = cpu_to_le32(len);\r\ndebug_print_pmkids(usbdev, pmkids, __func__);\r\nret = rndis_set_oid(usbdev, RNDIS_OID_802_11_PMKID, pmkids,\r\nle32_to_cpu(pmkids->length));\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_PMKID(%d, %d) -> %d"\r\n"\n", __func__, len, num_pmkids, ret);\r\n}\r\nkfree(pmkids);\r\nreturn ret;\r\n}\r\nstatic struct ndis_80211_pmkid *remove_pmkid(struct usbnet *usbdev,\r\nstruct ndis_80211_pmkid *pmkids,\r\nstruct cfg80211_pmksa *pmksa,\r\nint max_pmkids)\r\n{\r\nint i, newlen, err;\r\nunsigned int count;\r\ncount = le32_to_cpu(pmkids->bssid_info_count);\r\nif (count > max_pmkids)\r\ncount = max_pmkids;\r\nfor (i = 0; i < count; i++)\r\nif (ether_addr_equal(pmkids->bssid_info[i].bssid,\r\npmksa->bssid))\r\nbreak;\r\nif (i == count) {\r\nnetdev_dbg(usbdev->net, "%s(): bssid not found (%pM)\n",\r\n__func__, pmksa->bssid);\r\nerr = -ENOENT;\r\ngoto error;\r\n}\r\nfor (; i + 1 < count; i++)\r\npmkids->bssid_info[i] = pmkids->bssid_info[i + 1];\r\ncount--;\r\nnewlen = sizeof(*pmkids) + count * sizeof(pmkids->bssid_info[0]);\r\npmkids->length = cpu_to_le32(newlen);\r\npmkids->bssid_info_count = cpu_to_le32(count);\r\nreturn pmkids;\r\nerror:\r\nkfree(pmkids);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct ndis_80211_pmkid *update_pmkid(struct usbnet *usbdev,\r\nstruct ndis_80211_pmkid *pmkids,\r\nstruct cfg80211_pmksa *pmksa,\r\nint max_pmkids)\r\n{\r\nstruct ndis_80211_pmkid *new_pmkids;\r\nint i, err, newlen;\r\nunsigned int count;\r\ncount = le32_to_cpu(pmkids->bssid_info_count);\r\nif (count > max_pmkids)\r\ncount = max_pmkids;\r\nfor (i = 0; i < count; i++) {\r\nif (!ether_addr_equal(pmkids->bssid_info[i].bssid,\r\npmksa->bssid))\r\ncontinue;\r\nmemcpy(pmkids->bssid_info[i].pmkid, pmksa->pmkid,\r\nWLAN_PMKID_LEN);\r\nreturn pmkids;\r\n}\r\nif (i == max_pmkids) {\r\nnetdev_dbg(usbdev->net, "%s(): out of space\n", __func__);\r\nerr = -ENOSPC;\r\ngoto error;\r\n}\r\nnewlen = sizeof(*pmkids) + (count + 1) * sizeof(pmkids->bssid_info[0]);\r\nnew_pmkids = krealloc(pmkids, newlen, GFP_KERNEL);\r\nif (!new_pmkids) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\npmkids = new_pmkids;\r\npmkids->length = cpu_to_le32(newlen);\r\npmkids->bssid_info_count = cpu_to_le32(count + 1);\r\nmemcpy(pmkids->bssid_info[count].bssid, pmksa->bssid, ETH_ALEN);\r\nmemcpy(pmkids->bssid_info[count].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\r\nreturn pmkids;\r\nerror:\r\nkfree(pmkids);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int rndis_change_virtual_intf(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nint mode;\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nmode = NDIS_80211_INFRA_ADHOC;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nmode = NDIS_80211_INFRA_INFRA;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->wdev.iftype = type;\r\nreturn set_infra_mode(usbdev, mode);\r\n}\r\nstatic int rndis_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nint err;\r\nif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\r\nerr = set_frag_threshold(usbdev, wiphy->frag_threshold);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\r\nerr = set_rts_threshold(usbdev, wiphy->rts_threshold);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rndis_set_tx_power(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type,\r\nint mbm)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nnetdev_dbg(usbdev->net, "%s(): type:0x%x mbm:%i\n",\r\n__func__, type, mbm);\r\nif (mbm < 0 || (mbm % 100))\r\nreturn -ENOTSUPP;\r\nif (type == NL80211_TX_POWER_AUTOMATIC ||\r\nMBM_TO_DBM(mbm) == get_bcm4320_power_dbm(priv)) {\r\nif (!priv->radio_on)\r\ndisassociate(usbdev, true);\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int rndis_get_tx_power(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nint *dbm)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\n*dbm = get_bcm4320_power_dbm(priv);\r\nnetdev_dbg(usbdev->net, "%s(): dbm:%i\n", __func__, *dbm);\r\nreturn 0;\r\n}\r\nstatic int rndis_scan(struct wiphy *wiphy,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nstruct net_device *dev = request->wdev->netdev;\r\nstruct usbnet *usbdev = netdev_priv(dev);\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nint ret;\r\nint delay = SCAN_DELAY_JIFFIES;\r\nnetdev_dbg(usbdev->net, "cfg80211.scan\n");\r\nrndis_check_bssid_list(usbdev, NULL, NULL);\r\nif (priv->scan_request && priv->scan_request != request)\r\nreturn -EBUSY;\r\npriv->scan_request = request;\r\nret = rndis_start_bssid_list_scan(usbdev);\r\nif (ret == 0) {\r\nif (priv->device_type == RNDIS_BCM4320A)\r\ndelay = HZ;\r\nqueue_delayed_work(priv->workqueue, &priv->scan_work, delay);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool rndis_bss_info_update(struct usbnet *usbdev,\r\nstruct ndis_80211_bssid_ex *bssid)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ieee80211_channel *channel;\r\nstruct cfg80211_bss *bss;\r\ns32 signal;\r\nu64 timestamp;\r\nu16 capability;\r\nu16 beacon_interval;\r\nstruct ndis_80211_fixed_ies *fixed;\r\nint ie_len, bssid_len;\r\nu8 *ie;\r\nnetdev_dbg(usbdev->net, " found bssid: '%.32s' [%pM], len: %d\n",\r\nbssid->ssid.essid, bssid->mac, le32_to_cpu(bssid->length));\r\nbssid_len = le32_to_cpu(bssid->length);\r\nif (bssid_len < sizeof(struct ndis_80211_bssid_ex) +\r\nsizeof(struct ndis_80211_fixed_ies))\r\nreturn NULL;\r\nfixed = (struct ndis_80211_fixed_ies *)bssid->ies;\r\nie = (void *)(bssid->ies + sizeof(struct ndis_80211_fixed_ies));\r\nie_len = min(bssid_len - (int)sizeof(*bssid),\r\n(int)le32_to_cpu(bssid->ie_length));\r\nie_len -= sizeof(struct ndis_80211_fixed_ies);\r\nif (ie_len < 0)\r\nreturn NULL;\r\nchannel = ieee80211_get_channel(priv->wdev.wiphy,\r\nKHZ_TO_MHZ(le32_to_cpu(bssid->config.ds_config)));\r\nif (!channel)\r\nreturn NULL;\r\nsignal = level_to_qual(le32_to_cpu(bssid->rssi));\r\ntimestamp = le64_to_cpu(*(__le64 *)fixed->timestamp);\r\ncapability = le16_to_cpu(fixed->capabilities);\r\nbeacon_interval = le16_to_cpu(fixed->beacon_interval);\r\nbss = cfg80211_inform_bss(priv->wdev.wiphy, channel,\r\nCFG80211_BSS_FTYPE_UNKNOWN, bssid->mac,\r\ntimestamp, capability, beacon_interval,\r\nie, ie_len, signal, GFP_KERNEL);\r\ncfg80211_put_bss(priv->wdev.wiphy, bss);\r\nreturn (bss != NULL);\r\n}\r\nstatic struct ndis_80211_bssid_ex *next_bssid_list_item(\r\nstruct ndis_80211_bssid_ex *bssid,\r\nint *bssid_len, void *buf, int len)\r\n{\r\nvoid *buf_end, *bssid_end;\r\nbuf_end = (char *)buf + len;\r\nbssid_end = (char *)bssid + *bssid_len;\r\nif ((int)(buf_end - bssid_end) < sizeof(bssid->length)) {\r\n*bssid_len = 0;\r\nreturn NULL;\r\n} else {\r\nbssid = (void *)((char *)bssid + *bssid_len);\r\n*bssid_len = le32_to_cpu(bssid->length);\r\nreturn bssid;\r\n}\r\n}\r\nstatic bool check_bssid_list_item(struct ndis_80211_bssid_ex *bssid,\r\nint bssid_len, void *buf, int len)\r\n{\r\nvoid *buf_end, *bssid_end;\r\nif (!bssid || bssid_len <= 0 || bssid_len > len)\r\nreturn false;\r\nbuf_end = (char *)buf + len;\r\nbssid_end = (char *)bssid + bssid_len;\r\nreturn (int)(buf_end - bssid_end) >= 0 && (int)(bssid_end - buf) >= 0;\r\n}\r\nstatic int rndis_check_bssid_list(struct usbnet *usbdev, u8 *match_bssid,\r\nbool *matched)\r\n{\r\nvoid *buf = NULL;\r\nstruct ndis_80211_bssid_list_ex *bssid_list;\r\nstruct ndis_80211_bssid_ex *bssid;\r\nint ret = -EINVAL, len, count, bssid_len, real_count, new_len;\r\nnetdev_dbg(usbdev->net, "%s()\n", __func__);\r\nlen = CONTROL_BUFFER_SIZE;\r\nresize_buf:\r\nbuf = kzalloc(len, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnew_len = len;\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_BSSID_LIST,\r\nbuf, &new_len);\r\nif (ret != 0 || new_len < sizeof(struct ndis_80211_bssid_list_ex))\r\ngoto out;\r\nif (new_len > len) {\r\nlen = new_len;\r\nkfree(buf);\r\ngoto resize_buf;\r\n}\r\nlen = new_len;\r\nbssid_list = buf;\r\ncount = le32_to_cpu(bssid_list->num_items);\r\nreal_count = 0;\r\nnetdev_dbg(usbdev->net, "%s(): buflen: %d\n", __func__, len);\r\nbssid_len = 0;\r\nbssid = next_bssid_list_item(bssid_list->bssid, &bssid_len, buf, len);\r\nwhile (check_bssid_list_item(bssid, bssid_len, buf, len)) {\r\nif (rndis_bss_info_update(usbdev, bssid) && match_bssid &&\r\nmatched) {\r\nif (ether_addr_equal(bssid->mac, match_bssid))\r\n*matched = true;\r\n}\r\nreal_count++;\r\nbssid = next_bssid_list_item(bssid, &bssid_len, buf, len);\r\n}\r\nnetdev_dbg(usbdev->net, "%s(): num_items from device: %d, really found:"\r\n" %d\n", __func__, count, real_count);\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void rndis_get_scan_results(struct work_struct *work)\r\n{\r\nstruct rndis_wlan_private *priv =\r\ncontainer_of(work, struct rndis_wlan_private, scan_work.work);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nint ret;\r\nnetdev_dbg(usbdev->net, "get_scan_results\n");\r\nif (!priv->scan_request)\r\nreturn;\r\nret = rndis_check_bssid_list(usbdev, NULL, NULL);\r\ncfg80211_scan_done(priv->scan_request, ret < 0);\r\npriv->scan_request = NULL;\r\n}\r\nstatic int rndis_connect(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct ieee80211_channel *channel = sme->channel;\r\nstruct ndis_80211_ssid ssid;\r\nint pairwise = RNDIS_WLAN_ALG_NONE;\r\nint groupwise = RNDIS_WLAN_ALG_NONE;\r\nint keymgmt = RNDIS_WLAN_KEY_MGMT_NONE;\r\nint length, i, ret, chan = -1;\r\nif (channel)\r\nchan = ieee80211_frequency_to_channel(channel->center_freq);\r\ngroupwise = rndis_cipher_to_alg(sme->crypto.cipher_group);\r\nfor (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)\r\npairwise |=\r\nrndis_cipher_to_alg(sme->crypto.ciphers_pairwise[i]);\r\nif (sme->crypto.n_ciphers_pairwise > 0 &&\r\npairwise == RNDIS_WLAN_ALG_NONE) {\r\nnetdev_err(usbdev->net, "Unsupported pairwise cipher\n");\r\nreturn -ENOTSUPP;\r\n}\r\nfor (i = 0; i < sme->crypto.n_akm_suites; i++)\r\nkeymgmt |=\r\nrndis_akm_suite_to_key_mgmt(sme->crypto.akm_suites[i]);\r\nif (sme->crypto.n_akm_suites > 0 &&\r\nkeymgmt == RNDIS_WLAN_KEY_MGMT_NONE) {\r\nnetdev_err(usbdev->net, "Invalid keymgmt\n");\r\nreturn -ENOTSUPP;\r\n}\r\nnetdev_dbg(usbdev->net, "cfg80211.connect('%.32s':[%pM]:%d:[%d,0x%x:0x%x]:[0x%x:0x%x]:0x%x)\n",\r\nsme->ssid, sme->bssid, chan,\r\nsme->privacy, sme->crypto.wpa_versions, sme->auth_type,\r\ngroupwise, pairwise, keymgmt);\r\nif (is_associated(usbdev))\r\ndisassociate(usbdev, false);\r\nret = set_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: set_infra_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nret = set_auth_mode(usbdev, sme->crypto.wpa_versions, sme->auth_type,\r\nkeymgmt);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: set_auth_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nset_priv_filter(usbdev);\r\nret = set_encr_mode(usbdev, pairwise, groupwise);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: set_encr_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nif (channel) {\r\nret = set_channel(usbdev, chan);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: set_channel failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\n}\r\nif (sme->key && ((groupwise | pairwise) & RNDIS_WLAN_ALG_WEP)) {\r\npriv->encr_tx_key_index = sme->key_idx;\r\nret = add_wep_key(usbdev, sme->key, sme->key_len, sme->key_idx);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: add_wep_key failed, %d (%d, %d)\n",\r\nret, sme->key_len, sme->key_idx);\r\ngoto err_turn_radio_on;\r\n}\r\n}\r\nif (sme->bssid && !is_zero_ether_addr(sme->bssid) &&\r\n!is_broadcast_ether_addr(sme->bssid)) {\r\nret = set_bssid(usbdev, sme->bssid);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "connect: set_bssid failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\n} else\r\nclear_bssid(usbdev);\r\nlength = sme->ssid_len;\r\nif (length > NDIS_802_11_LENGTH_SSID)\r\nlength = NDIS_802_11_LENGTH_SSID;\r\nmemset(&ssid, 0, sizeof(ssid));\r\nssid.length = cpu_to_le32(length);\r\nmemcpy(ssid.essid, sme->ssid, length);\r\nusbnet_pause_rx(usbdev);\r\nusbnet_purge_paused_rxq(usbdev);\r\nret = set_essid(usbdev, &ssid);\r\nif (ret < 0)\r\nnetdev_dbg(usbdev->net, "connect: set_essid failed, %d\n", ret);\r\nreturn ret;\r\nerr_turn_radio_on:\r\ndisassociate(usbdev, true);\r\nreturn ret;\r\n}\r\nstatic int rndis_disconnect(struct wiphy *wiphy, struct net_device *dev,\r\nu16 reason_code)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nnetdev_dbg(usbdev->net, "cfg80211.disconnect(%d)\n", reason_code);\r\npriv->connected = false;\r\nmemset(priv->bssid, 0, ETH_ALEN);\r\nreturn deauthenticate(usbdev);\r\n}\r\nstatic int rndis_join_ibss(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct ieee80211_channel *channel = params->chandef.chan;\r\nstruct ndis_80211_ssid ssid;\r\nenum nl80211_auth_type auth_type;\r\nint ret, alg, length, chan = -1;\r\nif (channel)\r\nchan = ieee80211_frequency_to_channel(channel->center_freq);\r\nif (params->privacy) {\r\nauth_type = NL80211_AUTHTYPE_SHARED_KEY;\r\nalg = RNDIS_WLAN_ALG_WEP;\r\n} else {\r\nauth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;\r\nalg = RNDIS_WLAN_ALG_NONE;\r\n}\r\nnetdev_dbg(usbdev->net, "cfg80211.join_ibss('%.32s':[%pM]:%d:%d)\n",\r\nparams->ssid, params->bssid, chan, params->privacy);\r\nif (is_associated(usbdev))\r\ndisassociate(usbdev, false);\r\nret = set_infra_mode(usbdev, NDIS_80211_INFRA_ADHOC);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "join_ibss: set_infra_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nret = set_auth_mode(usbdev, 0, auth_type, RNDIS_WLAN_KEY_MGMT_NONE);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "join_ibss: set_auth_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nset_priv_filter(usbdev);\r\nret = set_encr_mode(usbdev, alg, RNDIS_WLAN_ALG_NONE);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "join_ibss: set_encr_mode failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\nif (channel) {\r\nret = set_channel(usbdev, chan);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "join_ibss: set_channel failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\n}\r\nif (params->bssid && !is_zero_ether_addr(params->bssid) &&\r\n!is_broadcast_ether_addr(params->bssid)) {\r\nret = set_bssid(usbdev, params->bssid);\r\nif (ret < 0) {\r\nnetdev_dbg(usbdev->net, "join_ibss: set_bssid failed, %d\n",\r\nret);\r\ngoto err_turn_radio_on;\r\n}\r\n} else\r\nclear_bssid(usbdev);\r\nlength = params->ssid_len;\r\nif (length > NDIS_802_11_LENGTH_SSID)\r\nlength = NDIS_802_11_LENGTH_SSID;\r\nmemset(&ssid, 0, sizeof(ssid));\r\nssid.length = cpu_to_le32(length);\r\nmemcpy(ssid.essid, params->ssid, length);\r\nusbnet_purge_paused_rxq(usbdev);\r\nusbnet_resume_rx(usbdev);\r\nret = set_essid(usbdev, &ssid);\r\nif (ret < 0)\r\nnetdev_dbg(usbdev->net, "join_ibss: set_essid failed, %d\n",\r\nret);\r\nreturn ret;\r\nerr_turn_radio_on:\r\ndisassociate(usbdev, true);\r\nreturn ret;\r\n}\r\nstatic int rndis_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nnetdev_dbg(usbdev->net, "cfg80211.leave_ibss()\n");\r\npriv->connected = false;\r\nmemset(priv->bssid, 0, ETH_ALEN);\r\nreturn deauthenticate(usbdev);\r\n}\r\nstatic int rndis_add_key(struct wiphy *wiphy, struct net_device *netdev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\n__le32 flags;\r\nnetdev_dbg(usbdev->net, "%s(%i, %pM, %08x)\n",\r\n__func__, key_index, mac_addr, params->cipher);\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nreturn add_wep_key(usbdev, params->key, params->key_len,\r\nkey_index);\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nflags = 0;\r\nif (params->seq && params->seq_len > 0)\r\nflags |= NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ;\r\nif (mac_addr)\r\nflags |= NDIS_80211_ADDKEY_PAIRWISE_KEY |\r\nNDIS_80211_ADDKEY_TRANSMIT_KEY;\r\nreturn add_wpa_key(usbdev, params->key, params->key_len,\r\nkey_index, mac_addr, params->seq,\r\nparams->seq_len, params->cipher, flags);\r\ndefault:\r\nnetdev_dbg(usbdev->net, "%s(): unsupported cipher %08x\n",\r\n__func__, params->cipher);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nstatic int rndis_del_key(struct wiphy *wiphy, struct net_device *netdev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nnetdev_dbg(usbdev->net, "%s(%i, %pM)\n", __func__, key_index, mac_addr);\r\nreturn remove_key(usbdev, key_index, mac_addr);\r\n}\r\nstatic int rndis_set_default_key(struct wiphy *wiphy, struct net_device *netdev,\r\nu8 key_index, bool unicast, bool multicast)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct rndis_wlan_encr_key key;\r\nnetdev_dbg(usbdev->net, "%s(%i)\n", __func__, key_index);\r\nif (key_index >= RNDIS_WLAN_NUM_KEYS)\r\nreturn -ENOENT;\r\npriv->encr_tx_key_index = key_index;\r\nif (is_wpa_key(priv, key_index))\r\nreturn 0;\r\nkey = priv->encr_keys[key_index];\r\nreturn add_wep_key(usbdev, key.material, key.len, key_index);\r\n}\r\nstatic void rndis_fill_station_info(struct usbnet *usbdev,\r\nstruct station_info *sinfo)\r\n{\r\n__le32 linkspeed, rssi;\r\nint ret, len;\r\nmemset(sinfo, 0, sizeof(*sinfo));\r\nlen = sizeof(linkspeed);\r\nret = rndis_query_oid(usbdev, RNDIS_OID_GEN_LINK_SPEED, &linkspeed, &len);\r\nif (ret == 0) {\r\nsinfo->txrate.legacy = le32_to_cpu(linkspeed) / 1000;\r\nsinfo->filled |= STATION_INFO_TX_BITRATE;\r\n}\r\nlen = sizeof(rssi);\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\r\n&rssi, &len);\r\nif (ret == 0) {\r\nsinfo->signal = level_to_qual(le32_to_cpu(rssi));\r\nsinfo->filled |= STATION_INFO_SIGNAL;\r\n}\r\n}\r\nstatic int rndis_get_station(struct wiphy *wiphy, struct net_device *dev,\r\nconst u8 *mac, struct station_info *sinfo)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nif (!ether_addr_equal(priv->bssid, mac))\r\nreturn -ENOENT;\r\nrndis_fill_station_info(usbdev, sinfo);\r\nreturn 0;\r\n}\r\nstatic int rndis_dump_station(struct wiphy *wiphy, struct net_device *dev,\r\nint idx, u8 *mac, struct station_info *sinfo)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nif (idx != 0)\r\nreturn -ENOENT;\r\nmemcpy(mac, priv->bssid, ETH_ALEN);\r\nrndis_fill_station_info(usbdev, sinfo);\r\nreturn 0;\r\n}\r\nstatic int rndis_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct ndis_80211_pmkid *pmkids;\r\nu32 *tmp = (u32 *)pmksa->pmkid;\r\nnetdev_dbg(usbdev->net, "%s(%pM, %08X:%08X:%08X:%08X)\n", __func__,\r\npmksa->bssid,\r\ncpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\r\ncpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\r\npmkids = get_device_pmkids(usbdev);\r\nif (IS_ERR(pmkids)) {\r\nreturn PTR_ERR(pmkids);\r\n}\r\npmkids = update_pmkid(usbdev, pmkids, pmksa, wiphy->max_num_pmkids);\r\nif (IS_ERR(pmkids)) {\r\nreturn PTR_ERR(pmkids);\r\n}\r\nreturn set_device_pmkids(usbdev, pmkids);\r\n}\r\nstatic int rndis_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct ndis_80211_pmkid *pmkids;\r\nu32 *tmp = (u32 *)pmksa->pmkid;\r\nnetdev_dbg(usbdev->net, "%s(%pM, %08X:%08X:%08X:%08X)\n", __func__,\r\npmksa->bssid,\r\ncpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\r\ncpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\r\npmkids = get_device_pmkids(usbdev);\r\nif (IS_ERR(pmkids)) {\r\nreturn PTR_ERR(pmkids);\r\n}\r\npmkids = remove_pmkid(usbdev, pmkids, pmksa, wiphy->max_num_pmkids);\r\nif (IS_ERR(pmkids)) {\r\nreturn PTR_ERR(pmkids);\r\n}\r\nreturn set_device_pmkids(usbdev, pmkids);\r\n}\r\nstatic int rndis_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nstruct ndis_80211_pmkid pmkid;\r\nnetdev_dbg(usbdev->net, "%s()\n", __func__);\r\nmemset(&pmkid, 0, sizeof(pmkid));\r\npmkid.length = cpu_to_le32(sizeof(pmkid));\r\npmkid.bssid_info_count = cpu_to_le32(0);\r\nreturn rndis_set_oid(usbdev, RNDIS_OID_802_11_PMKID,\r\n&pmkid, sizeof(pmkid));\r\n}\r\nstatic int rndis_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\r\nbool enabled, int timeout)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nint power_mode;\r\n__le32 mode;\r\nint ret;\r\nif (priv->device_type != RNDIS_BCM4320B)\r\nreturn -ENOTSUPP;\r\nnetdev_dbg(usbdev->net, "%s(): %s, %d\n", __func__,\r\nenabled ? "enabled" : "disabled",\r\ntimeout);\r\nif (enabled)\r\npower_mode = NDIS_80211_POWER_MODE_FAST_PSP;\r\nelse\r\npower_mode = NDIS_80211_POWER_MODE_CAM;\r\nif (power_mode == priv->power_mode)\r\nreturn 0;\r\npriv->power_mode = power_mode;\r\nmode = cpu_to_le32(power_mode);\r\nret = rndis_set_oid(usbdev, RNDIS_OID_802_11_POWER_MODE,\r\n&mode, sizeof(mode));\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_POWER_MODE -> %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rndis_set_cqm_rssi_config(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\ns32 rssi_thold, u32 rssi_hyst)\r\n{\r\nstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\r\npriv->cqm_rssi_thold = rssi_thold;\r\npriv->cqm_rssi_hyst = rssi_hyst;\r\npriv->last_cqm_event_rssi = 0;\r\nreturn 0;\r\n}\r\nstatic void rndis_wlan_craft_connected_bss(struct usbnet *usbdev, u8 *bssid,\r\nstruct ndis_80211_assoc_info *info)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ieee80211_channel *channel;\r\nstruct ndis_80211_ssid ssid;\r\nstruct cfg80211_bss *bss;\r\ns32 signal;\r\nu64 timestamp;\r\nu16 capability;\r\nu32 beacon_period = 0;\r\n__le32 rssi;\r\nu8 ie_buf[34];\r\nint len, ret, ie_len;\r\nlen = sizeof(rssi);\r\nrssi = 0;\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\r\n&rssi, &len);\r\nsignal = level_to_qual(le32_to_cpu(rssi));\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_RSSI -> %d, "\r\n"rssi:%d, qual: %d\n", __func__, ret, le32_to_cpu(rssi),\r\nlevel_to_qual(le32_to_cpu(rssi)));\r\nif (info) {\r\ncapability = le16_to_cpu(info->resp_ie.capa);\r\n} else {\r\ncapability = (priv->infra_mode == NDIS_80211_INFRA_INFRA) ?\r\nWLAN_CAPABILITY_ESS : WLAN_CAPABILITY_IBSS;\r\n}\r\nchannel = get_current_channel(usbdev, &beacon_period);\r\nif (!channel) {\r\nnetdev_warn(usbdev->net, "%s(): could not get channel.\n",\r\n__func__);\r\nreturn;\r\n}\r\nlen = sizeof(ssid);\r\nmemset(&ssid, 0, sizeof(ssid));\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_SSID,\r\n&ssid, &len);\r\nnetdev_dbg(usbdev->net, "%s(): RNDIS_OID_802_11_SSID -> %d, len: %d, ssid: "\r\n"'%.32s'\n", __func__, ret,\r\nle32_to_cpu(ssid.length), ssid.essid);\r\nif (le32_to_cpu(ssid.length) > 32)\r\nssid.length = cpu_to_le32(32);\r\nie_buf[0] = WLAN_EID_SSID;\r\nie_buf[1] = le32_to_cpu(ssid.length);\r\nmemcpy(&ie_buf[2], ssid.essid, le32_to_cpu(ssid.length));\r\nie_len = le32_to_cpu(ssid.length) + 2;\r\ntimestamp = 0;\r\nnetdev_dbg(usbdev->net, "%s(): channel:%d(freq), bssid:[%pM], tsf:%d, "\r\n"capa:%x, beacon int:%d, resp_ie(len:%d, essid:'%.32s'), "\r\n"signal:%d\n", __func__, (channel ? channel->center_freq : -1),\r\nbssid, (u32)timestamp, capability, beacon_period, ie_len,\r\nssid.essid, signal);\r\nbss = cfg80211_inform_bss(priv->wdev.wiphy, channel,\r\nCFG80211_BSS_FTYPE_UNKNOWN, bssid,\r\ntimestamp, capability, beacon_period,\r\nie_buf, ie_len, signal, GFP_KERNEL);\r\ncfg80211_put_bss(priv->wdev.wiphy, bss);\r\n}\r\nstatic void rndis_wlan_do_link_up_work(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct ndis_80211_assoc_info *info = NULL;\r\nu8 bssid[ETH_ALEN];\r\nunsigned int resp_ie_len, req_ie_len;\r\nunsigned int offset;\r\nu8 *req_ie, *resp_ie;\r\nint ret;\r\nbool roamed = false;\r\nbool match_bss;\r\nif (priv->infra_mode == NDIS_80211_INFRA_INFRA && priv->connected) {\r\nroamed = true;\r\n}\r\nreq_ie_len = 0;\r\nresp_ie_len = 0;\r\nreq_ie = NULL;\r\nresp_ie = NULL;\r\nif (priv->infra_mode == NDIS_80211_INFRA_INFRA) {\r\ninfo = kzalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\r\nif (!info) {\r\nset_bit(WORK_LINK_UP, &priv->work_pending);\r\nqueue_work(priv->workqueue, &priv->work);\r\nreturn;\r\n}\r\nret = get_association_info(usbdev, info, CONTROL_BUFFER_SIZE);\r\nif (!ret) {\r\nreq_ie_len = le32_to_cpu(info->req_ie_length);\r\nif (req_ie_len > CONTROL_BUFFER_SIZE)\r\nreq_ie_len = CONTROL_BUFFER_SIZE;\r\nif (req_ie_len != 0) {\r\noffset = le32_to_cpu(info->offset_req_ies);\r\nif (offset > CONTROL_BUFFER_SIZE)\r\noffset = CONTROL_BUFFER_SIZE;\r\nreq_ie = (u8 *)info + offset;\r\nif (offset + req_ie_len > CONTROL_BUFFER_SIZE)\r\nreq_ie_len =\r\nCONTROL_BUFFER_SIZE - offset;\r\n}\r\nresp_ie_len = le32_to_cpu(info->resp_ie_length);\r\nif (resp_ie_len > CONTROL_BUFFER_SIZE)\r\nresp_ie_len = CONTROL_BUFFER_SIZE;\r\nif (resp_ie_len != 0) {\r\noffset = le32_to_cpu(info->offset_resp_ies);\r\nif (offset > CONTROL_BUFFER_SIZE)\r\noffset = CONTROL_BUFFER_SIZE;\r\nresp_ie = (u8 *)info + offset;\r\nif (offset + resp_ie_len > CONTROL_BUFFER_SIZE)\r\nresp_ie_len =\r\nCONTROL_BUFFER_SIZE - offset;\r\n}\r\n} else {\r\nkfree(info);\r\ninfo = NULL;\r\n}\r\n} else if (WARN_ON(priv->infra_mode != NDIS_80211_INFRA_ADHOC))\r\nreturn;\r\nret = get_bssid(usbdev, bssid);\r\nif (ret < 0)\r\nmemset(bssid, 0, sizeof(bssid));\r\nnetdev_dbg(usbdev->net, "link up work: [%pM]%s\n",\r\nbssid, roamed ? " roamed" : "");\r\nmatch_bss = false;\r\nrndis_check_bssid_list(usbdev, bssid, &match_bss);\r\nif (!is_zero_ether_addr(bssid) && !match_bss) {\r\nrndis_wlan_craft_connected_bss(usbdev, bssid, info);\r\n}\r\nif (priv->infra_mode == NDIS_80211_INFRA_INFRA) {\r\nif (!roamed)\r\ncfg80211_connect_result(usbdev->net, bssid, req_ie,\r\nreq_ie_len, resp_ie,\r\nresp_ie_len, 0, GFP_KERNEL);\r\nelse\r\ncfg80211_roamed(usbdev->net,\r\nget_current_channel(usbdev, NULL),\r\nbssid, req_ie, req_ie_len,\r\nresp_ie, resp_ie_len, GFP_KERNEL);\r\n} else if (priv->infra_mode == NDIS_80211_INFRA_ADHOC)\r\ncfg80211_ibss_joined(usbdev->net, bssid,\r\nget_current_channel(usbdev, NULL),\r\nGFP_KERNEL);\r\nkfree(info);\r\npriv->connected = true;\r\nmemcpy(priv->bssid, bssid, ETH_ALEN);\r\nusbnet_resume_rx(usbdev);\r\nnetif_carrier_on(usbdev->net);\r\n}\r\nstatic void rndis_wlan_do_link_down_work(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nif (priv->connected) {\r\npriv->connected = false;\r\nmemset(priv->bssid, 0, ETH_ALEN);\r\ndeauthenticate(usbdev);\r\ncfg80211_disconnected(usbdev->net, 0, NULL, 0, GFP_KERNEL);\r\n}\r\nnetif_carrier_off(usbdev->net);\r\n}\r\nstatic void rndis_wlan_worker(struct work_struct *work)\r\n{\r\nstruct rndis_wlan_private *priv =\r\ncontainer_of(work, struct rndis_wlan_private, work);\r\nstruct usbnet *usbdev = priv->usbdev;\r\nif (test_and_clear_bit(WORK_LINK_UP, &priv->work_pending))\r\nrndis_wlan_do_link_up_work(usbdev);\r\nif (test_and_clear_bit(WORK_LINK_DOWN, &priv->work_pending))\r\nrndis_wlan_do_link_down_work(usbdev);\r\nif (test_and_clear_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending))\r\nset_multicast_list(usbdev);\r\n}\r\nstatic void rndis_wlan_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct usbnet *usbdev = netdev_priv(dev);\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nif (test_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending))\r\nreturn;\r\nset_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending);\r\nqueue_work(priv->workqueue, &priv->work);\r\n}\r\nstatic void rndis_wlan_auth_indication(struct usbnet *usbdev,\r\nstruct ndis_80211_status_indication *indication,\r\nint len)\r\n{\r\nu8 *buf;\r\nconst char *type;\r\nint flags, buflen, key_id;\r\nbool pairwise_error, group_error;\r\nstruct ndis_80211_auth_request *auth_req;\r\nenum nl80211_key_type key_type;\r\nif (len < offsetof(struct ndis_80211_status_indication, u) +\r\nsizeof(struct ndis_80211_auth_request)) {\r\nnetdev_info(usbdev->net, "authentication indication: too short message (%i)\n",\r\nlen);\r\nreturn;\r\n}\r\nbuf = (void *)&indication->u.auth_request[0];\r\nbuflen = len - offsetof(struct ndis_80211_status_indication, u);\r\nwhile (buflen >= sizeof(*auth_req)) {\r\nauth_req = (void *)buf;\r\ntype = "unknown";\r\nflags = le32_to_cpu(auth_req->flags);\r\npairwise_error = false;\r\ngroup_error = false;\r\nif (flags & 0x1)\r\ntype = "reauth request";\r\nif (flags & 0x2)\r\ntype = "key update request";\r\nif (flags & 0x6) {\r\npairwise_error = true;\r\ntype = "pairwise_error";\r\n}\r\nif (flags & 0xe) {\r\ngroup_error = true;\r\ntype = "group_error";\r\n}\r\nnetdev_info(usbdev->net, "authentication indication: %s (0x%08x)\n",\r\ntype, le32_to_cpu(auth_req->flags));\r\nif (pairwise_error) {\r\nkey_type = NL80211_KEYTYPE_PAIRWISE;\r\nkey_id = -1;\r\ncfg80211_michael_mic_failure(usbdev->net,\r\nauth_req->bssid,\r\nkey_type, key_id, NULL,\r\nGFP_KERNEL);\r\n}\r\nif (group_error) {\r\nkey_type = NL80211_KEYTYPE_GROUP;\r\nkey_id = -1;\r\ncfg80211_michael_mic_failure(usbdev->net,\r\nauth_req->bssid,\r\nkey_type, key_id, NULL,\r\nGFP_KERNEL);\r\n}\r\nbuflen -= le32_to_cpu(auth_req->length);\r\nbuf += le32_to_cpu(auth_req->length);\r\n}\r\n}\r\nstatic void rndis_wlan_pmkid_cand_list_indication(struct usbnet *usbdev,\r\nstruct ndis_80211_status_indication *indication,\r\nint len)\r\n{\r\nstruct ndis_80211_pmkid_cand_list *cand_list;\r\nint list_len, expected_len, i;\r\nif (len < offsetof(struct ndis_80211_status_indication, u) +\r\nsizeof(struct ndis_80211_pmkid_cand_list)) {\r\nnetdev_info(usbdev->net, "pmkid candidate list indication: too short message (%i)\n",\r\nlen);\r\nreturn;\r\n}\r\nlist_len = le32_to_cpu(indication->u.cand_list.num_candidates) *\r\nsizeof(struct ndis_80211_pmkid_candidate);\r\nexpected_len = sizeof(struct ndis_80211_pmkid_cand_list) + list_len +\r\noffsetof(struct ndis_80211_status_indication, u);\r\nif (len < expected_len) {\r\nnetdev_info(usbdev->net, "pmkid candidate list indication: list larger than buffer (%i < %i)\n",\r\nlen, expected_len);\r\nreturn;\r\n}\r\ncand_list = &indication->u.cand_list;\r\nnetdev_info(usbdev->net, "pmkid candidate list indication: version %i, candidates %i\n",\r\nle32_to_cpu(cand_list->version),\r\nle32_to_cpu(cand_list->num_candidates));\r\nif (le32_to_cpu(cand_list->version) != 1)\r\nreturn;\r\nfor (i = 0; i < le32_to_cpu(cand_list->num_candidates); i++) {\r\nstruct ndis_80211_pmkid_candidate *cand =\r\n&cand_list->candidate_list[i];\r\nbool preauth = !!(cand->flags & NDIS_80211_PMKID_CAND_PREAUTH);\r\nnetdev_dbg(usbdev->net, "cand[%i]: flags: 0x%08x, preauth: %d, bssid: %pM\n",\r\ni, le32_to_cpu(cand->flags), preauth, cand->bssid);\r\ncfg80211_pmksa_candidate_notify(usbdev->net, i, cand->bssid,\r\npreauth, GFP_ATOMIC);\r\n}\r\n}\r\nstatic void rndis_wlan_media_specific_indication(struct usbnet *usbdev,\r\nstruct rndis_indicate *msg, int buflen)\r\n{\r\nstruct ndis_80211_status_indication *indication;\r\nunsigned int len, offset;\r\noffset = offsetof(struct rndis_indicate, status) +\r\nle32_to_cpu(msg->offset);\r\nlen = le32_to_cpu(msg->length);\r\nif (len < 8) {\r\nnetdev_info(usbdev->net, "media specific indication, ignore too short message (%i < 8)\n",\r\nlen);\r\nreturn;\r\n}\r\nif (len > buflen || offset > buflen || offset + len > buflen) {\r\nnetdev_info(usbdev->net, "media specific indication, too large to fit to buffer (%i > %i)\n",\r\noffset + len, buflen);\r\nreturn;\r\n}\r\nindication = (void *)((u8 *)msg + offset);\r\nswitch (le32_to_cpu(indication->status_type)) {\r\ncase NDIS_80211_STATUSTYPE_RADIOSTATE:\r\nnetdev_info(usbdev->net, "radio state indication: %i\n",\r\nle32_to_cpu(indication->u.radio_status));\r\nreturn;\r\ncase NDIS_80211_STATUSTYPE_MEDIASTREAMMODE:\r\nnetdev_info(usbdev->net, "media stream mode indication: %i\n",\r\nle32_to_cpu(indication->u.media_stream_mode));\r\nreturn;\r\ncase NDIS_80211_STATUSTYPE_AUTHENTICATION:\r\nrndis_wlan_auth_indication(usbdev, indication, len);\r\nreturn;\r\ncase NDIS_80211_STATUSTYPE_PMKID_CANDIDATELIST:\r\nrndis_wlan_pmkid_cand_list_indication(usbdev, indication, len);\r\nreturn;\r\ndefault:\r\nnetdev_info(usbdev->net, "media specific indication: unknown status type 0x%08x\n",\r\nle32_to_cpu(indication->status_type));\r\n}\r\n}\r\nstatic void rndis_wlan_indication(struct usbnet *usbdev, void *ind, int buflen)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nstruct rndis_indicate *msg = ind;\r\nswitch (le32_to_cpu(msg->status)) {\r\ncase RNDIS_STATUS_MEDIA_CONNECT:\r\nif (priv->current_command_oid == RNDIS_OID_802_11_ADD_KEY) {\r\nnetdev_dbg(usbdev->net, "ignored RNDIS_OID_802_11_ADD_KEY triggered 'media connect'\n");\r\nreturn;\r\n}\r\nusbnet_pause_rx(usbdev);\r\nnetdev_info(usbdev->net, "media connect\n");\r\nset_bit(WORK_LINK_UP, &priv->work_pending);\r\nqueue_work(priv->workqueue, &priv->work);\r\nbreak;\r\ncase RNDIS_STATUS_MEDIA_DISCONNECT:\r\nnetdev_info(usbdev->net, "media disconnect\n");\r\nset_bit(WORK_LINK_DOWN, &priv->work_pending);\r\nqueue_work(priv->workqueue, &priv->work);\r\nbreak;\r\ncase RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION:\r\nrndis_wlan_media_specific_indication(usbdev, msg, buflen);\r\nbreak;\r\ndefault:\r\nnetdev_info(usbdev->net, "indication: 0x%08x\n",\r\nle32_to_cpu(msg->status));\r\nbreak;\r\n}\r\n}\r\nstatic int rndis_wlan_get_caps(struct usbnet *usbdev, struct wiphy *wiphy)\r\n{\r\nstruct {\r\n__le32 num_items;\r\n__le32 items[8];\r\n} networks_supported;\r\nstruct ndis_80211_capability *caps;\r\nu8 caps_buf[sizeof(*caps) + sizeof(caps->auth_encr_pair) * 16];\r\nint len, retval, i, n;\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nlen = sizeof(networks_supported);\r\nretval = rndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_NETWORK_TYPES_SUPPORTED,\r\n&networks_supported, &len);\r\nif (retval >= 0) {\r\nn = le32_to_cpu(networks_supported.num_items);\r\nif (n > 8)\r\nn = 8;\r\nfor (i = 0; i < n; i++) {\r\nswitch (le32_to_cpu(networks_supported.items[i])) {\r\ncase NDIS_80211_TYPE_FREQ_HOP:\r\ncase NDIS_80211_TYPE_DIRECT_SEQ:\r\npriv->caps |= CAP_MODE_80211B;\r\nbreak;\r\ncase NDIS_80211_TYPE_OFDM_A:\r\npriv->caps |= CAP_MODE_80211A;\r\nbreak;\r\ncase NDIS_80211_TYPE_OFDM_G:\r\npriv->caps |= CAP_MODE_80211G;\r\nbreak;\r\n}\r\n}\r\n}\r\ncaps = (struct ndis_80211_capability *)caps_buf;\r\nlen = sizeof(caps_buf);\r\nretval = rndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_CAPABILITY,\r\ncaps, &len);\r\nif (retval >= 0) {\r\nnetdev_dbg(usbdev->net, "RNDIS_OID_802_11_CAPABILITY -> len %d, "\r\n"ver %d, pmkids %d, auth-encr-pairs %d\n",\r\nle32_to_cpu(caps->length),\r\nle32_to_cpu(caps->version),\r\nle32_to_cpu(caps->num_pmkids),\r\nle32_to_cpu(caps->num_auth_encr_pair));\r\nwiphy->max_num_pmkids = le32_to_cpu(caps->num_pmkids);\r\n} else\r\nwiphy->max_num_pmkids = 0;\r\nreturn retval;\r\n}\r\nstatic void rndis_do_cqm(struct usbnet *usbdev, s32 rssi)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nenum nl80211_cqm_rssi_threshold_event event;\r\nint thold, hyst, last_event;\r\nif (priv->cqm_rssi_thold >= 0 || rssi >= 0)\r\nreturn;\r\nif (priv->infra_mode != NDIS_80211_INFRA_INFRA)\r\nreturn;\r\nlast_event = priv->last_cqm_event_rssi;\r\nthold = priv->cqm_rssi_thold;\r\nhyst = priv->cqm_rssi_hyst;\r\nif (rssi < thold && (last_event == 0 || rssi < last_event - hyst))\r\nevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\r\nelse if (rssi > thold && (last_event == 0 || rssi > last_event + hyst))\r\nevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\r\nelse\r\nreturn;\r\npriv->last_cqm_event_rssi = rssi;\r\ncfg80211_cqm_rssi_notify(usbdev->net, event, GFP_KERNEL);\r\n}\r\nstatic void rndis_device_poller(struct work_struct *work)\r\n{\r\nstruct rndis_wlan_private *priv =\r\ncontainer_of(work, struct rndis_wlan_private,\r\ndev_poller_work.work);\r\nstruct usbnet *usbdev = priv->usbdev;\r\n__le32 rssi, tmp;\r\nint len, ret, j;\r\nint update_jiffies = DEVICE_POLLER_JIFFIES;\r\nvoid *buf;\r\nif (!is_associated(usbdev)) {\r\nif (priv->device_type == RNDIS_BCM4320A && priv->radio_on &&\r\n!priv->scan_request) {\r\nrndis_check_bssid_list(usbdev, NULL, NULL);\r\nrndis_start_bssid_list_scan(usbdev);\r\n}\r\ngoto end;\r\n}\r\nlen = sizeof(rssi);\r\nret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\r\n&rssi, &len);\r\nif (ret == 0) {\r\npriv->last_qual = level_to_qual(le32_to_cpu(rssi));\r\nrndis_do_cqm(usbdev, le32_to_cpu(rssi));\r\n}\r\nnetdev_dbg(usbdev->net, "dev-poller: RNDIS_OID_802_11_RSSI -> %d, rssi:%d, qual: %d\n",\r\nret, le32_to_cpu(rssi), level_to_qual(le32_to_cpu(rssi)));\r\nif (priv->param_workaround_interval > 0 && priv->last_qual <= 25) {\r\nj = msecs_to_jiffies(priv->param_workaround_interval);\r\nif (j > DEVICE_POLLER_JIFFIES)\r\nj = DEVICE_POLLER_JIFFIES;\r\nelse if (j <= 0)\r\nj = 1;\r\nupdate_jiffies = j;\r\ntmp = cpu_to_le32(1);\r\nrndis_set_oid(usbdev,\r\nRNDIS_OID_802_11_BSSID_LIST_SCAN,\r\n&tmp, sizeof(tmp));\r\nlen = CONTROL_BUFFER_SIZE;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\ngoto end;\r\nrndis_query_oid(usbdev,\r\nRNDIS_OID_802_11_BSSID_LIST,\r\nbuf, &len);\r\nkfree(buf);\r\n}\r\nend:\r\nif (update_jiffies >= HZ)\r\nupdate_jiffies = round_jiffies_relative(update_jiffies);\r\nelse {\r\nj = round_jiffies_relative(update_jiffies);\r\nif (abs(j - update_jiffies) <= 10)\r\nupdate_jiffies = j;\r\n}\r\nqueue_delayed_work(priv->workqueue, &priv->dev_poller_work,\r\nupdate_jiffies);\r\n}\r\nstatic void rndis_copy_module_params(struct usbnet *usbdev, int device_type)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\npriv->device_type = device_type;\r\npriv->param_country[0] = modparam_country[0];\r\npriv->param_country[1] = modparam_country[1];\r\npriv->param_country[2] = 0;\r\npriv->param_frameburst = modparam_frameburst;\r\npriv->param_afterburner = modparam_afterburner;\r\npriv->param_power_save = modparam_power_save;\r\npriv->param_power_output = modparam_power_output;\r\npriv->param_roamtrigger = modparam_roamtrigger;\r\npriv->param_roamdelta = modparam_roamdelta;\r\npriv->param_country[0] = toupper(priv->param_country[0]);\r\npriv->param_country[1] = toupper(priv->param_country[1]);\r\nif (!strcmp(priv->param_country, "EU"))\r\nstrcpy(priv->param_country, "FI");\r\nif (priv->param_power_save < 0)\r\npriv->param_power_save = 0;\r\nelse if (priv->param_power_save > 2)\r\npriv->param_power_save = 2;\r\nif (priv->param_power_output < 0)\r\npriv->param_power_output = 0;\r\nelse if (priv->param_power_output > 3)\r\npriv->param_power_output = 3;\r\nif (priv->param_roamtrigger < -80)\r\npriv->param_roamtrigger = -80;\r\nelse if (priv->param_roamtrigger > -60)\r\npriv->param_roamtrigger = -60;\r\nif (priv->param_roamdelta < 0)\r\npriv->param_roamdelta = 0;\r\nelse if (priv->param_roamdelta > 2)\r\npriv->param_roamdelta = 2;\r\nif (modparam_workaround_interval < 0)\r\npriv->param_workaround_interval = 500;\r\nelse\r\npriv->param_workaround_interval = modparam_workaround_interval;\r\n}\r\nstatic int unknown_early_init(struct usbnet *usbdev)\r\n{\r\nrndis_copy_module_params(usbdev, RNDIS_UNKNOWN);\r\nreturn 0;\r\n}\r\nstatic int bcm4320a_early_init(struct usbnet *usbdev)\r\n{\r\nrndis_copy_module_params(usbdev, RNDIS_BCM4320A);\r\nreturn 0;\r\n}\r\nstatic int bcm4320b_early_init(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nchar buf[8];\r\nrndis_copy_module_params(usbdev, RNDIS_BCM4320B);\r\nrndis_set_config_parameter_str(usbdev, "Country", priv->param_country);\r\nrndis_set_config_parameter_str(usbdev, "FrameBursting",\r\npriv->param_frameburst ? "1" : "0");\r\nrndis_set_config_parameter_str(usbdev, "Afterburner",\r\npriv->param_afterburner ? "1" : "0");\r\nsprintf(buf, "%d", priv->param_power_save);\r\nrndis_set_config_parameter_str(usbdev, "PowerSaveMode", buf);\r\nsprintf(buf, "%d", priv->param_power_output);\r\nrndis_set_config_parameter_str(usbdev, "PwrOut", buf);\r\nsprintf(buf, "%d", priv->param_roamtrigger);\r\nrndis_set_config_parameter_str(usbdev, "RoamTrigger", buf);\r\nsprintf(buf, "%d", priv->param_roamdelta);\r\nrndis_set_config_parameter_str(usbdev, "RoamDelta", buf);\r\nreturn 0;\r\n}\r\nstatic int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf)\r\n{\r\nstruct wiphy *wiphy;\r\nstruct rndis_wlan_private *priv;\r\nint retval, len;\r\n__le32 tmp;\r\nwiphy = wiphy_new(&rndis_config_ops, sizeof(struct rndis_wlan_private));\r\nif (!wiphy)\r\nreturn -ENOMEM;\r\npriv = wiphy_priv(wiphy);\r\nusbdev->net->ieee80211_ptr = &priv->wdev;\r\npriv->wdev.wiphy = wiphy;\r\npriv->wdev.iftype = NL80211_IFTYPE_STATION;\r\nusbdev->driver_priv = priv;\r\npriv->usbdev = usbdev;\r\nmutex_init(&priv->command_lock);\r\npriv->workqueue = create_singlethread_workqueue("rndis_wlan");\r\nINIT_WORK(&priv->work, rndis_wlan_worker);\r\nINIT_DELAYED_WORK(&priv->dev_poller_work, rndis_device_poller);\r\nINIT_DELAYED_WORK(&priv->scan_work, rndis_get_scan_results);\r\nretval = generic_rndis_bind(usbdev, intf, FLAG_RNDIS_PHYM_WIRELESS);\r\nif (retval < 0)\r\ngoto fail;\r\nusbdev->net->netdev_ops = &rndis_wlan_netdev_ops;\r\ntmp = cpu_to_le32(RNDIS_PACKET_TYPE_DIRECTED | RNDIS_PACKET_TYPE_BROADCAST);\r\nretval = rndis_set_oid(usbdev,\r\nRNDIS_OID_GEN_CURRENT_PACKET_FILTER,\r\n&tmp, sizeof(tmp));\r\nlen = sizeof(tmp);\r\nretval = rndis_query_oid(usbdev,\r\nRNDIS_OID_802_3_MAXIMUM_LIST_SIZE,\r\n&tmp, &len);\r\npriv->multicast_size = le32_to_cpu(tmp);\r\nif (retval < 0 || priv->multicast_size < 0)\r\npriv->multicast_size = 0;\r\nif (priv->multicast_size > 0)\r\nusbdev->net->flags |= IFF_MULTICAST;\r\nelse\r\nusbdev->net->flags &= ~IFF_MULTICAST;\r\nmemcpy(wiphy->perm_addr, usbdev->net->dev_addr, ETH_ALEN);\r\nwiphy->privid = rndis_wiphy_privid;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\r\n| BIT(NL80211_IFTYPE_ADHOC);\r\nwiphy->max_scan_ssids = 1;\r\nrndis_wlan_get_caps(usbdev, wiphy);\r\nmemcpy(priv->channels, rndis_channels, sizeof(rndis_channels));\r\nmemcpy(priv->rates, rndis_rates, sizeof(rndis_rates));\r\npriv->band.channels = priv->channels;\r\npriv->band.n_channels = ARRAY_SIZE(rndis_channels);\r\npriv->band.bitrates = priv->rates;\r\npriv->band.n_bitrates = ARRAY_SIZE(rndis_rates);\r\nwiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band;\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;\r\nmemcpy(priv->cipher_suites, rndis_cipher_suites,\r\nsizeof(rndis_cipher_suites));\r\nwiphy->cipher_suites = priv->cipher_suites;\r\nwiphy->n_cipher_suites = ARRAY_SIZE(rndis_cipher_suites);\r\nset_wiphy_dev(wiphy, &usbdev->udev->dev);\r\nif (wiphy_register(wiphy)) {\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nset_default_iw_params(usbdev);\r\npriv->power_mode = -1;\r\nrndis_set_wiphy_params(wiphy,\r\nWIPHY_PARAM_FRAG_THRESHOLD | WIPHY_PARAM_RTS_THRESHOLD);\r\npriv->radio_on = false;\r\ndisassociate(usbdev, false);\r\nnetif_carrier_off(usbdev->net);\r\nreturn 0;\r\nfail:\r\ncancel_delayed_work_sync(&priv->dev_poller_work);\r\ncancel_delayed_work_sync(&priv->scan_work);\r\ncancel_work_sync(&priv->work);\r\nflush_workqueue(priv->workqueue);\r\ndestroy_workqueue(priv->workqueue);\r\nwiphy_free(wiphy);\r\nreturn retval;\r\n}\r\nstatic void rndis_wlan_unbind(struct usbnet *usbdev, struct usb_interface *intf)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\ndisassociate(usbdev, false);\r\ncancel_delayed_work_sync(&priv->dev_poller_work);\r\ncancel_delayed_work_sync(&priv->scan_work);\r\ncancel_work_sync(&priv->work);\r\nflush_workqueue(priv->workqueue);\r\ndestroy_workqueue(priv->workqueue);\r\nrndis_unbind(usbdev, intf);\r\nwiphy_unregister(priv->wdev.wiphy);\r\nwiphy_free(priv->wdev.wiphy);\r\n}\r\nstatic int rndis_wlan_reset(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nint retval;\r\nnetdev_dbg(usbdev->net, "%s()\n", __func__);\r\nretval = rndis_reset(usbdev);\r\nif (retval)\r\nnetdev_warn(usbdev->net, "rndis_reset failed: %d\n", retval);\r\nset_multicast_list(usbdev);\r\nqueue_delayed_work(priv->workqueue, &priv->dev_poller_work,\r\nround_jiffies_relative(DEVICE_POLLER_JIFFIES));\r\nreturn deauthenticate(usbdev);\r\n}\r\nstatic int rndis_wlan_stop(struct usbnet *usbdev)\r\n{\r\nstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\r\nint retval;\r\n__le32 filter;\r\nnetdev_dbg(usbdev->net, "%s()\n", __func__);\r\nretval = disassociate(usbdev, false);\r\npriv->work_pending = 0;\r\ncancel_delayed_work_sync(&priv->dev_poller_work);\r\ncancel_delayed_work_sync(&priv->scan_work);\r\ncancel_work_sync(&priv->work);\r\nflush_workqueue(priv->workqueue);\r\nif (priv->scan_request) {\r\ncfg80211_scan_done(priv->scan_request, true);\r\npriv->scan_request = NULL;\r\n}\r\nfilter = 0;\r\nrndis_set_oid(usbdev, RNDIS_OID_GEN_CURRENT_PACKET_FILTER, &filter,\r\nsizeof(filter));\r\nreturn retval;\r\n}
