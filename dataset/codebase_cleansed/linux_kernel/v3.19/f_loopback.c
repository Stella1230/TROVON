static inline struct f_loopback *func_to_loop(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_loopback, function);\r\n}\r\nstatic int loopback_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_loopback *loop = func_to_loop(f);\r\nint id;\r\nint ret;\r\nid = usb_interface_id(c, f);\r\nif (id < 0)\r\nreturn id;\r\nloopback_intf.bInterfaceNumber = id;\r\nid = usb_string_id(cdev);\r\nif (id < 0)\r\nreturn id;\r\nstrings_loopback[0].id = id;\r\nloopback_intf.iInterface = id;\r\nloop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);\r\nif (!loop->in_ep) {\r\nautoconf_fail:\r\nERROR(cdev, "%s: can't autoconfigure on %s\n",\r\nf->name, cdev->gadget->name);\r\nreturn -ENODEV;\r\n}\r\nloop->in_ep->driver_data = cdev;\r\nloop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);\r\nif (!loop->out_ep)\r\ngoto autoconf_fail;\r\nloop->out_ep->driver_data = cdev;\r\nhs_loop_source_desc.bEndpointAddress =\r\nfs_loop_source_desc.bEndpointAddress;\r\nhs_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;\r\nss_loop_source_desc.bEndpointAddress =\r\nfs_loop_source_desc.bEndpointAddress;\r\nss_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, fs_loopback_descs, hs_loopback_descs,\r\nss_loopback_descs);\r\nif (ret)\r\nreturn ret;\r\nDBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",\r\n(gadget_is_superspeed(c->cdev->gadget) ? "super" :\r\n(gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),\r\nf->name, loop->in_ep->name, loop->out_ep->name);\r\nreturn 0;\r\n}\r\nstatic void lb_free_func(struct usb_function *f)\r\n{\r\nstruct f_lb_opts *opts;\r\nopts = container_of(f->fi, struct f_lb_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\nusb_free_all_descriptors(f);\r\nkfree(func_to_loop(f));\r\n}\r\nstatic void loopback_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_loopback *loop = ep->driver_data;\r\nstruct usb_composite_dev *cdev = loop->function.config->cdev;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nif (ep == loop->out_ep) {\r\nreq->zero = (req->actual < req->length);\r\nreq->length = req->actual;\r\n}\r\nreq->length = buflen;\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (status == 0)\r\nreturn;\r\ndefault:\r\nERROR(cdev, "%s loop complete --> %d, %d/%d\n", ep->name,\r\nstatus, req->actual, req->length);\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nfree_ep_req(ep, req);\r\nreturn;\r\n}\r\n}\r\nstatic void disable_loopback(struct f_loopback *loop)\r\n{\r\nstruct usb_composite_dev *cdev;\r\ncdev = loop->function.config->cdev;\r\ndisable_endpoints(cdev, loop->in_ep, loop->out_ep, NULL, NULL, NULL,\r\nNULL);\r\nVDBG(cdev, "%s disabled\n", loop->function.name);\r\n}\r\nstatic inline struct usb_request *lb_alloc_ep_req(struct usb_ep *ep, int len)\r\n{\r\nreturn alloc_ep_req(ep, len, buflen);\r\n}\r\nstatic int enable_endpoint(struct usb_composite_dev *cdev, struct f_loopback *loop,\r\nstruct usb_ep *ep)\r\n{\r\nstruct usb_request *req;\r\nunsigned i;\r\nint result;\r\nresult = config_ep_by_speed(cdev->gadget, &(loop->function), ep);\r\nif (result)\r\ngoto fail0;\r\nresult = usb_ep_enable(ep);\r\nif (result < 0)\r\ngoto fail0;\r\nep->driver_data = loop;\r\nfor (i = 0; i < qlen && result == 0; i++) {\r\nreq = lb_alloc_ep_req(ep, 0);\r\nif (!req)\r\ngoto fail1;\r\nreq->complete = loopback_complete;\r\nresult = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (result) {\r\nERROR(cdev, "%s queue req --> %d\n",\r\nep->name, result);\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\nusb_ep_disable(ep);\r\nfail0:\r\nreturn result;\r\n}\r\nstatic int\r\nenable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)\r\n{\r\nint result = 0;\r\nresult = enable_endpoint(cdev, loop, loop->in_ep);\r\nif (result)\r\nreturn result;\r\nresult = enable_endpoint(cdev, loop, loop->out_ep);\r\nif (result)\r\nreturn result;\r\nDBG(cdev, "%s enabled\n", loop->function.name);\r\nreturn result;\r\n}\r\nstatic int loopback_set_alt(struct usb_function *f,\r\nunsigned intf, unsigned alt)\r\n{\r\nstruct f_loopback *loop = func_to_loop(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (loop->in_ep->driver_data)\r\ndisable_loopback(loop);\r\nreturn enable_loopback(cdev, loop);\r\n}\r\nstatic void loopback_disable(struct usb_function *f)\r\n{\r\nstruct f_loopback *loop = func_to_loop(f);\r\ndisable_loopback(loop);\r\n}\r\nstatic struct usb_function *loopback_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_loopback *loop;\r\nstruct f_lb_opts *lb_opts;\r\nloop = kzalloc(sizeof *loop, GFP_KERNEL);\r\nif (!loop)\r\nreturn ERR_PTR(-ENOMEM);\r\nlb_opts = container_of(fi, struct f_lb_opts, func_inst);\r\nmutex_lock(&lb_opts->lock);\r\nlb_opts->refcnt++;\r\nmutex_unlock(&lb_opts->lock);\r\nbuflen = lb_opts->bulk_buflen;\r\nqlen = lb_opts->qlen;\r\nif (!qlen)\r\nqlen = 32;\r\nloop->function.name = "loopback";\r\nloop->function.bind = loopback_bind;\r\nloop->function.set_alt = loopback_set_alt;\r\nloop->function.disable = loopback_disable;\r\nloop->function.strings = loopback_strings;\r\nloop->function.free_func = lb_free_func;\r\nreturn &loop->function;\r\n}\r\nstatic inline struct f_lb_opts *to_f_lb_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_lb_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void lb_attr_release(struct config_item *item)\r\n{\r\nstruct f_lb_opts *lb_opts = to_f_lb_opts(item);\r\nusb_put_function_instance(&lb_opts->func_inst);\r\n}\r\nstatic ssize_t f_lb_opts_qlen_show(struct f_lb_opts *opts, char *page)\r\n{\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%d", opts->qlen);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_lb_opts_qlen_store(struct f_lb_opts *opts,\r\nconst char *page, size_t len)\r\n{\r\nint ret;\r\nu32 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou32(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->qlen = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_lb_opts_bulk_buflen_show(struct f_lb_opts *opts, char *page)\r\n{\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%d", opts->bulk_buflen);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_lb_opts_bulk_buflen_store(struct f_lb_opts *opts,\r\nconst char *page, size_t len)\r\n{\r\nint ret;\r\nu32 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou32(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->bulk_buflen = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic void lb_free_instance(struct usb_function_instance *fi)\r\n{\r\nstruct f_lb_opts *lb_opts;\r\nlb_opts = container_of(fi, struct f_lb_opts, func_inst);\r\nkfree(lb_opts);\r\n}\r\nstatic struct usb_function_instance *loopback_alloc_instance(void)\r\n{\r\nstruct f_lb_opts *lb_opts;\r\nlb_opts = kzalloc(sizeof(*lb_opts), GFP_KERNEL);\r\nif (!lb_opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&lb_opts->lock);\r\nlb_opts->func_inst.free_func_inst = lb_free_instance;\r\nlb_opts->bulk_buflen = GZERO_BULK_BUFLEN;\r\nlb_opts->qlen = GZERO_QLEN;\r\nconfig_group_init_type_name(&lb_opts->func_inst.group, "",\r\n&lb_func_type);\r\nreturn &lb_opts->func_inst;\r\n}\r\nint __init lb_modinit(void)\r\n{\r\nint ret;\r\nret = usb_function_register(&Loopbackusb_func);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nvoid __exit lb_modexit(void)\r\n{\r\nusb_function_unregister(&Loopbackusb_func);\r\n}
