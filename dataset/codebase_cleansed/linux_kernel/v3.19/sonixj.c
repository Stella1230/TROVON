static void reg_r(struct gspca_dev *gspca_dev,\r\nu16 value, int len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (len > USB_BUF_SZ) {\r\nPERR("reg_r: buffer overflow\n");\r\nreturn;\r\n}\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue, 0,\r\ngspca_dev->usb_buf, len,\r\n500);\r\nPDEBUG(D_USBI, "reg_r [%02x] -> %02x", value, gspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w1(struct gspca_dev *gspca_dev,\r\nu16 value,\r\nu8 data)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "reg_w1 [%04x] = %02x", value, data);\r\ngspca_dev->usb_buf[0] = data;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue,\r\n0,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w1 err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu16 value,\r\nconst u8 *buffer,\r\nint len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "reg_w [%04x] = %02x %02x ..",\r\nvalue, buffer[0], buffer[1]);\r\nif (len > USB_BUF_SZ) {\r\nPERR("reg_w: buffer overflow\n");\r\nreturn;\r\n}\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue, 0,\r\ngspca_dev->usb_buf, len,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void i2c_w1(struct gspca_dev *gspca_dev, u8 reg, u8 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "i2c_w1 [%02x] = %02x", reg, val);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_OM6802:\r\ncase SENSOR_GC0307:\r\ngspca_dev->usb_buf[0] = 0x80 | (2 << 4);\r\nbreak;\r\ndefault:\r\ngspca_dev->usb_buf[0] = 0x81 | (2 << 4);\r\nbreak;\r\n}\r\ngspca_dev->usb_buf[1] = sd->i2c_addr;\r\ngspca_dev->usb_buf[2] = reg;\r\ngspca_dev->usb_buf[3] = val;\r\ngspca_dev->usb_buf[4] = 0;\r\ngspca_dev->usb_buf[5] = 0;\r\ngspca_dev->usb_buf[6] = 0;\r\ngspca_dev->usb_buf[7] = 0x10;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x08,\r\n0,\r\ngspca_dev->usb_buf, 8,\r\n500);\r\nmsleep(2);\r\nif (ret < 0) {\r\npr_err("i2c_w1 err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void i2c_w8(struct gspca_dev *gspca_dev,\r\nconst u8 *buffer)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "i2c_w8 [%02x] = %02x ..",\r\nbuffer[2], buffer[3]);\r\nmemcpy(gspca_dev->usb_buf, buffer, 8);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x08, 0,\r\ngspca_dev->usb_buf, 8,\r\n500);\r\nmsleep(2);\r\nif (ret < 0) {\r\npr_err("i2c_w8 err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void i2c_r(struct gspca_dev *gspca_dev, u8 reg, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 mode[8];\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_OM6802:\r\ncase SENSOR_GC0307:\r\nmode[0] = 0x80 | 0x10;\r\nbreak;\r\ndefault:\r\nmode[0] = 0x81 | 0x10;\r\nbreak;\r\n}\r\nmode[1] = sd->i2c_addr;\r\nmode[2] = reg;\r\nmode[3] = 0;\r\nmode[4] = 0;\r\nmode[5] = 0;\r\nmode[6] = 0;\r\nmode[7] = 0x10;\r\ni2c_w8(gspca_dev, mode);\r\nmsleep(2);\r\nmode[0] = (mode[0] & 0x81) | (len << 4) | 0x02;\r\nmode[2] = 0;\r\ni2c_w8(gspca_dev, mode);\r\nmsleep(2);\r\nreg_r(gspca_dev, 0x0a, 5);\r\n}\r\nstatic void hv7131r_probe(struct gspca_dev *gspca_dev)\r\n{\r\ni2c_w1(gspca_dev, 0x02, 0);\r\nmsleep(10);\r\nreg_w1(gspca_dev, 0x02, 0x66);\r\nmsleep(10);\r\ni2c_r(gspca_dev, 0, 5);\r\nif (gspca_dev->usb_buf[0] == 0x02\r\n&& gspca_dev->usb_buf[1] == 0x09\r\n&& gspca_dev->usb_buf[2] == 0x01) {\r\nPDEBUG(D_PROBE, "Sensor HV7131R found");\r\nreturn;\r\n}\r\npr_warn("Erroneous HV7131R ID 0x%02x 0x%02x 0x%02x\n",\r\ngspca_dev->usb_buf[0], gspca_dev->usb_buf[1],\r\ngspca_dev->usb_buf[2]);\r\n}\r\nstatic void mi0360_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, j;\r\nu16 val = 0;\r\nstatic const u8 probe_tb[][4][8] = {\r\n{\r\n{0xb0, 0x5d, 0x07, 0x00, 0x02, 0x00, 0x00, 0x10},\r\n{0x90, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},\r\n{0xa2, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},\r\n{0xb0, 0x5d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10}\r\n},\r\n{\r\n{0xb0, 0x5c, 0x01, 0x00, 0x04, 0x00, 0x00, 0x10},\r\n{0x90, 0x5c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x10},\r\n{0xa2, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},\r\n{}\r\n},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(probe_tb); i++) {\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x08);\r\nfor (j = 0; j < 3; j++)\r\ni2c_w8(gspca_dev, probe_tb[i][j]);\r\nmsleep(2);\r\nreg_r(gspca_dev, 0x0a, 5);\r\nval = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nif (probe_tb[i][3][0] != 0)\r\ni2c_w8(gspca_dev, probe_tb[i][3]);\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif (val != 0xffff)\r\nbreak;\r\n}\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nswitch (val) {\r\ncase 0x8221:\r\nPDEBUG(D_PROBE, "Sensor mi0360b");\r\nsd->sensor = SENSOR_MI0360B;\r\nbreak;\r\ncase 0x823a:\r\nPDEBUG(D_PROBE, "Sensor mt9v111");\r\nsd->sensor = SENSOR_MT9V111;\r\nbreak;\r\ncase 0x8243:\r\nPDEBUG(D_PROBE, "Sensor mi0360");\r\nbreak;\r\ndefault:\r\nPDEBUG(D_PROBE, "Unknown sensor %04x - forced to mi0360", val);\r\nbreak;\r\n}\r\n}\r\nstatic void ov7630_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 val;\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x08);\r\nsd->i2c_addr = 0x21;\r\ni2c_r(gspca_dev, 0x0a, 2);\r\nval = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (val == 0x7628) {\r\nsd->sensor = SENSOR_SOI768;\r\ngspca_dev->cam.input_flags =\r\nV4L2_IN_ST_VFLIP | V4L2_IN_ST_HFLIP;\r\nPDEBUG(D_PROBE, "Sensor soi768");\r\nreturn;\r\n}\r\nPDEBUG(D_PROBE, "Sensor ov%04x", val);\r\n}\r\nstatic void ov7648_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 val;\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x08);\r\nsd->i2c_addr = 0x21;\r\ni2c_r(gspca_dev, 0x0a, 2);\r\nval = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif ((val & 0xff00) == 0x7600) {\r\nPDEBUG(D_PROBE, "Sensor ov%04x", val);\r\nreturn;\r\n}\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x08);\r\nsd->i2c_addr = 0x6e;\r\ni2c_r(gspca_dev, 0x00, 2);\r\nval = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (val == 0x1030) {\r\nPDEBUG(D_PROBE, "Sensor po1030");\r\nsd->sensor = SENSOR_PO1030;\r\nreturn;\r\n}\r\npr_err("Unknown sensor %04x\n", val);\r\n}\r\nstatic void po2030n_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 val;\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x08);\r\nreg_w1(gspca_dev, 0x02, 0x22);\r\nsd->i2c_addr = 0x21;\r\ni2c_r(gspca_dev, 0x00, 1);\r\nval = gspca_dev->usb_buf[4];\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif (val == 0x99) {\r\nPDEBUG(D_PROBE, "Sensor gc0307");\r\nsd->sensor = SENSOR_GC0307;\r\nreturn;\r\n}\r\nreg_w1(gspca_dev, 0x17, 0x62);\r\nreg_w1(gspca_dev, 0x01, 0x0a);\r\nsd->i2c_addr = 0x6e;\r\ni2c_r(gspca_dev, 0x00, 2);\r\nval = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nreg_w1(gspca_dev, 0x01, 0x29);\r\nreg_w1(gspca_dev, 0x17, 0x42);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (val == 0x2030) {\r\nPDEBUG(D_PROBE, "Sensor po2030n");\r\n} else {\r\npr_err("Unknown sensor ID %04x\n", val);\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nsd->bridge = id->driver_info >> 16;\r\nsd->sensor = id->driver_info >> 8;\r\nsd->flags = id->driver_info;\r\ncam = &gspca_dev->cam;\r\nif (sd->sensor == SENSOR_ADCM1700) {\r\ncam->cam_mode = cif_mode;\r\ncam->nmodes = ARRAY_SIZE(cif_mode);\r\n} else {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\n}\r\ncam->npkt = 24;\r\nsd->ag_cnt = -1;\r\nsd->quality = QUALITY_DEF;\r\nINIT_WORK(&sd->work, qual_upd);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst u8 *sn9c1xx;\r\nu8 regGpio[] = { 0x29, 0x70 };\r\nu8 regF1;\r\nreg_w1(gspca_dev, 0xf1, 0x01);\r\nreg_r(gspca_dev, 0x00, 1);\r\nreg_w1(gspca_dev, 0xf1, 0x00);\r\nreg_r(gspca_dev, 0x00, 1);\r\nregF1 = gspca_dev->usb_buf[0];\r\nif (gspca_dev->usb_err < 0)\r\nreturn gspca_dev->usb_err;\r\nPDEBUG(D_PROBE, "Sonix chip id: %02x", regF1);\r\nif (gspca_dev->audio)\r\nregGpio[1] |= 0x04;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SN9C102P:\r\ncase BRIDGE_SN9C105:\r\nif (regF1 != 0x11)\r\nreturn -ENODEV;\r\nbreak;\r\ndefault:\r\nif (regF1 != 0x12)\r\nreturn -ENODEV;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_MI0360:\r\nmi0360_probe(gspca_dev);\r\nbreak;\r\ncase SENSOR_OV7630:\r\nov7630_probe(gspca_dev);\r\nbreak;\r\ncase SENSOR_OV7648:\r\nov7648_probe(gspca_dev);\r\nbreak;\r\ncase SENSOR_PO2030N:\r\npo2030n_probe(gspca_dev);\r\nbreak;\r\n}\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SN9C102P:\r\nreg_w1(gspca_dev, 0x02, regGpio[1]);\r\nbreak;\r\ndefault:\r\nreg_w(gspca_dev, 0x01, regGpio, 2);\r\nbreak;\r\n}\r\nreg_w1(gspca_dev, 0xf1, 0x00);\r\nsn9c1xx = sn_tb[sd->sensor];\r\nsd->i2c_addr = sn9c1xx[9];\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 14);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\n#define CONTRAST_MAX 127\r\nsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, CONTRAST_MAX, 1, 20);\r\n#define COLORS_DEF 25\r\nsd->saturation = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 40, 1, COLORS_DEF);\r\nsd->red_bal = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 24, 40, 1, 32);\r\nsd->blue_bal = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 24, 40, 1, 32);\r\n#define GAMMA_DEF 20\r\nsd->gamma = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, 40, 1, GAMMA_DEF);\r\nif (sd->sensor == SENSOR_OM6802)\r\nsd->sharpness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 255, 1, 16);\r\nelse\r\nsd->sharpness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 255, 1, 90);\r\nif (sd->flags & F_ILLUM)\r\nsd->illum = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_ILLUMINATORS_1, 0, 1, 1, 0);\r\nif (sd->sensor == SENSOR_PO2030N) {\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 500, 1500, 1, 1024);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 4, 49, 1, 15);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\n}\r\nif (sd->sensor != SENSOR_ADCM1700 && sd->sensor != SENSOR_OV7660 &&\r\nsd->sensor != SENSOR_PO1030 && sd->sensor != SENSOR_SOI768 &&\r\nsd->sensor != SENSOR_SP80708)\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nif (sd->sensor == SENSOR_HV7131R || sd->sensor == SENSOR_OV7630 ||\r\nsd->sensor == SENSOR_OV7648 || sd->sensor == SENSOR_PO2030N)\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (sd->sensor == SENSOR_OV7630 || sd->sensor == SENSOR_OV7648 ||\r\nsd->sensor == SENSOR_OV7660)\r\nsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(2, &sd->red_bal);\r\nif (sd->sensor == SENSOR_PO2030N) {\r\nv4l2_ctrl_cluster(2, &sd->vflip);\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 expo_adjust(struct gspca_dev *gspca_dev,\r\nu32 expo)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_GC0307: {\r\nint a, b;\r\na = 19 + expo * 25 / 256;\r\ni2c_w1(gspca_dev, 0x68, a);\r\na -= 12;\r\nb = a * a * 4;\r\ni2c_w1(gspca_dev, 0x03, b >> 8);\r\ni2c_w1(gspca_dev, 0x04, b);\r\nbreak;\r\n}\r\ncase SENSOR_HV7131R: {\r\nu8 Expodoit[] =\r\n{ 0xc1, 0x11, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16 };\r\nExpodoit[3] = expo >> 16;\r\nExpodoit[4] = expo >> 8;\r\nExpodoit[5] = expo;\r\ni2c_w8(gspca_dev, Expodoit);\r\nbreak;\r\n}\r\ncase SENSOR_MI0360:\r\ncase SENSOR_MI0360B: {\r\nu8 expoMi[] =\r\n{ 0xb1, 0x5d, 0x09, 0x00, 0x00, 0x00, 0x00, 0x16 };\r\nstatic const u8 doit[] =\r\n{ 0xb1, 0x5d, 0x07, 0x00, 0x03, 0x00, 0x00, 0x10 };\r\nstatic const u8 sensorgo[] =\r\n{ 0xb1, 0x5d, 0x07, 0x00, 0x02, 0x00, 0x00, 0x10 };\r\nif (expo > 0x0635)\r\nexpo = 0x0635;\r\nelse if (expo < 0x0001)\r\nexpo = 0x0001;\r\nexpoMi[3] = expo >> 8;\r\nexpoMi[4] = expo;\r\ni2c_w8(gspca_dev, expoMi);\r\ni2c_w8(gspca_dev, doit);\r\ni2c_w8(gspca_dev, sensorgo);\r\nbreak;\r\n}\r\ncase SENSOR_MO4000: {\r\nu8 expoMof[] =\r\n{ 0xa1, 0x21, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x10 };\r\nu8 expoMo10[] =\r\n{ 0xa1, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10 };\r\nstatic const u8 gainMo[] =\r\n{ 0xa1, 0x21, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1d };\r\nif (expo > 0x1fff)\r\nexpo = 0x1fff;\r\nelse if (expo < 0x0001)\r\nexpo = 0x0001;\r\nexpoMof[3] = (expo & 0x03fc) >> 2;\r\ni2c_w8(gspca_dev, expoMof);\r\nexpoMo10[3] = ((expo & 0x1c00) >> 10)\r\n| ((expo & 0x0003) << 4);\r\ni2c_w8(gspca_dev, expoMo10);\r\ni2c_w8(gspca_dev, gainMo);\r\nPDEBUG(D_FRAM, "set exposure %d",\r\n((expoMo10[3] & 0x07) << 10)\r\n| (expoMof[3] << 2)\r\n| ((expoMo10[3] & 0x30) >> 4));\r\nbreak;\r\n}\r\ncase SENSOR_MT9V111: {\r\nu8 expo_c1[] =\r\n{ 0xb1, 0x5c, 0x09, 0x00, 0x00, 0x00, 0x00, 0x10 };\r\nif (expo > 0x0390)\r\nexpo = 0x0390;\r\nelse if (expo < 0x0060)\r\nexpo = 0x0060;\r\nexpo_c1[3] = expo >> 8;\r\nexpo_c1[4] = expo;\r\ni2c_w8(gspca_dev, expo_c1);\r\nbreak;\r\n}\r\ncase SENSOR_OM6802: {\r\nu8 gainOm[] =\r\n{ 0xa0, 0x34, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x10 };\r\nif (expo > 0x03ff)\r\nexpo = 0x03ff;\r\nif (expo < 0x0001)\r\nexpo = 0x0001;\r\ngainOm[3] = expo >> 2;\r\ni2c_w8(gspca_dev, gainOm);\r\nreg_w1(gspca_dev, 0x96, expo >> 5);\r\nPDEBUG(D_FRAM, "set exposure %d", gainOm[3]);\r\nbreak;\r\n}\r\n}\r\nreturn expo;\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned int expo;\r\nint brightness = sd->brightness->val;\r\nu8 k2;\r\nk2 = (brightness - 0x80) >> 2;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\nif (k2 > 0x1f)\r\nk2 = 0;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nexpo = brightness << 12;\r\nif (expo > 0x002dc6c0)\r\nexpo = 0x002dc6c0;\r\nelse if (expo < 0x02a0)\r\nexpo = 0x02a0;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nbreak;\r\ncase SENSOR_MI0360:\r\ncase SENSOR_MO4000:\r\nexpo = brightness << 4;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nbreak;\r\ncase SENSOR_MI0360B:\r\nexpo = brightness << 2;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nbreak;\r\ncase SENSOR_GC0307:\r\nexpo = brightness;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nreturn;\r\ncase SENSOR_MT9V111:\r\nexpo = brightness << 2;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nreturn;\r\ncase SENSOR_OM6802:\r\nexpo = brightness << 2;\r\nsd->exposure = expo_adjust(gspca_dev, expo);\r\nreturn;\r\n}\r\nreg_w1(gspca_dev, 0x96, k2);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 k2;\r\nu8 contrast[6];\r\nk2 = sd->contrast->val * 37 / (CONTRAST_MAX + 1)\r\n+ 37;\r\ncontrast[0] = (k2 + 1) / 2;\r\ncontrast[1] = 0;\r\ncontrast[2] = k2;\r\ncontrast[3] = 0;\r\ncontrast[4] = k2 / 5;\r\ncontrast[5] = 0;\r\nreg_w(gspca_dev, 0x84, contrast, sizeof contrast);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, v, colors;\r\nconst s16 *uv;\r\nu8 reg8a[12];\r\nstatic const s16 uv_com[6] = {\r\n-24, -38, 64,\r\n62, -51, -9\r\n};\r\nstatic const s16 uv_mi0360b[6] = {\r\n-20, -38, 64,\r\n60, -51, -9\r\n};\r\ncolors = sd->saturation->val;\r\nif (sd->sensor == SENSOR_MI0360B)\r\nuv = uv_mi0360b;\r\nelse\r\nuv = uv_com;\r\nfor (i = 0; i < 6; i++) {\r\nv = uv[i] * colors / COLORS_DEF;\r\nreg8a[i * 2] = v;\r\nreg8a[i * 2 + 1] = (v >> 8) & 0x0f;\r\n}\r\nreg_w(gspca_dev, 0x8a, reg8a, sizeof reg8a);\r\n}\r\nstatic void setredblue(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PO2030N) {\r\nu8 rg1b[] =\r\n{0xc1, 0x6e, 0x16, 0x00, 0x40, 0x00, 0x00, 0x10};\r\nrg1b[3] = sd->red_bal->val * 2;\r\nrg1b[5] = sd->blue_bal->val * 2;\r\ni2c_w8(gspca_dev, rg1b);\r\nreturn;\r\n}\r\nreg_w1(gspca_dev, 0x05, sd->red_bal->val);\r\nreg_w1(gspca_dev, 0x06, sd->blue_bal->val);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, val;\r\nu8 gamma[17];\r\nconst u8 *gamma_base;\r\nstatic const u8 delta[17] = {\r\n0x00, 0x14, 0x1c, 0x1c, 0x1c, 0x1c, 0x1b, 0x1a,\r\n0x18, 0x13, 0x10, 0x0e, 0x08, 0x07, 0x04, 0x02, 0x00\r\n};\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ngamma_base = gamma_spec_0;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_MI0360B:\r\ncase SENSOR_MT9V111:\r\ngamma_base = gamma_spec_1;\r\nbreak;\r\ncase SENSOR_GC0307:\r\ngamma_base = gamma_spec_2;\r\nbreak;\r\ncase SENSOR_SP80708:\r\ngamma_base = gamma_spec_3;\r\nbreak;\r\ndefault:\r\ngamma_base = gamma_def;\r\nbreak;\r\n}\r\nval = sd->gamma->val;\r\nfor (i = 0; i < sizeof gamma; i++)\r\ngamma[i] = gamma_base[i]\r\n+ delta[i] * (val - GAMMA_DEF) / 32;\r\nreg_w(gspca_dev, 0x20, gamma, sizeof gamma);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PO2030N) {\r\nu8 rexpo[] =\r\n{0xa1, 0x6e, 0x1a, 0x00, 0x40, 0x00, 0x00, 0x10};\r\nrexpo[3] = gspca_dev->exposure->val >> 8;\r\ni2c_w8(gspca_dev, rexpo);\r\nmsleep(6);\r\nrexpo[2] = 0x1b;\r\nrexpo[3] = gspca_dev->exposure->val;\r\ni2c_w8(gspca_dev, rexpo);\r\n}\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7630:\r\ncase SENSOR_OV7648: {\r\nu8 comb;\r\nif (sd->sensor == SENSOR_OV7630)\r\ncomb = 0xc0;\r\nelse\r\ncomb = 0xa0;\r\nif (gspca_dev->autogain->val)\r\ncomb |= 0x03;\r\ni2c_w1(&sd->gspca_dev, 0x13, comb);\r\nreturn;\r\n}\r\n}\r\nif (gspca_dev->autogain->val)\r\nsd->ag_cnt = AG_CNT_START;\r\nelse\r\nsd->ag_cnt = -1;\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PO2030N) {\r\nu8 rgain[] =\r\n{0xa1, 0x6e, 0x15, 0x00, 0x40, 0x00, 0x00, 0x15};\r\nrgain[3] = gspca_dev->gain->val;\r\ni2c_w8(gspca_dev, rgain);\r\n}\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 comn;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\ncomn = 0x18;\r\nif (sd->vflip->val)\r\ncomn |= 0x01;\r\ni2c_w1(gspca_dev, 0x01, comn);\r\nbreak;\r\ncase SENSOR_OV7630:\r\ncomn = 0x02;\r\nif (!sd->vflip->val)\r\ncomn |= 0x80;\r\ni2c_w1(gspca_dev, 0x75, comn);\r\nbreak;\r\ncase SENSOR_OV7648:\r\ncomn = 0x06;\r\nif (sd->vflip->val)\r\ncomn |= 0x80;\r\ni2c_w1(gspca_dev, 0x75, comn);\r\nbreak;\r\ncase SENSOR_PO2030N:\r\ncomn = 0x0a;\r\nif (sd->hflip->val)\r\ncomn |= 0x80;\r\nif (sd->vflip->val)\r\ncomn |= 0x40;\r\ni2c_w1(&sd->gspca_dev, 0x1e, comn);\r\nbreak;\r\n}\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w1(gspca_dev, 0x99, sd->sharpness->val);\r\n}\r\nstatic void setillum(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\nreg_w1(gspca_dev, 0x02,\r\nsd->illum->val ? 0x64 : 0x60);\r\nbreak;\r\ncase SENSOR_MT9V111:\r\nreg_w1(gspca_dev, 0x02,\r\nsd->illum->val ? 0x77 : 0x74);\r\nbreak;\r\n}\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV7660) {\r\nu8 com8;\r\ncom8 = 0xdf;\r\nswitch (sd->freq->val) {\r\ncase 0:\r\ni2c_w1(gspca_dev, 0x13, com8 | 0x20);\r\nbreak;\r\ncase 1:\r\ni2c_w1(gspca_dev, 0x13, com8);\r\ni2c_w1(gspca_dev, 0x3b, 0x0a);\r\nbreak;\r\ncase 2:\r\ni2c_w1(gspca_dev, 0x13, com8);\r\ni2c_w1(gspca_dev, 0x3b, 0x02);\r\nbreak;\r\n}\r\n} else {\r\nu8 reg2a = 0, reg2b = 0, reg2d = 0;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7630:\r\nreg2a = 0x08;\r\nreg2d = 0x01;\r\nbreak;\r\ncase SENSOR_OV7648:\r\nreg2a = 0x11;\r\nreg2d = 0x81;\r\nbreak;\r\n}\r\nswitch (sd->freq->val) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nreg2a |= 0x80;\r\nreg2b = 0xac;\r\nreg2d |= 0x04;\r\nbreak;\r\ncase 2:\r\nreg2a |= 0x80;\r\nreg2d |= 0x04;\r\nbreak;\r\n}\r\ni2c_w1(gspca_dev, 0x2a, reg2a);\r\ni2c_w1(gspca_dev, 0x2b, reg2b);\r\ni2c_w1(gspca_dev, 0x2d, reg2d);\r\n}\r\n}\r\nstatic void setjpegqual(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\n#if USB_BUF_SZ < 64\r\n#error "No room enough in usb_buf for quantization table"\r\n#endif\r\nmemcpy(gspca_dev->usb_buf, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x0100, 0,\r\ngspca_dev->usb_buf, 64,\r\n500);\r\nmemcpy(gspca_dev->usb_buf, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x0140, 0,\r\ngspca_dev->usb_buf, 64,\r\n500);\r\nsd->reg18 ^= 0x40;\r\nreg_w1(gspca_dev, 0x18, sd->reg18);\r\n}\r\nstatic void qual_upd(struct work_struct *work)\r\n{\r\nstruct sd *sd = container_of(work, struct sd, work);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nmutex_lock(&gspca_dev->usb_lock);\r\nPDEBUG(D_STREAM, "qual_upd %d%%", sd->quality);\r\ngspca_dev->usb_err = 0;\r\nsetjpegqual(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu8 reg01, reg17;\r\nu8 reg0102[2];\r\nconst u8 *sn9c1xx;\r\nconst u8 (*init)[8];\r\nconst u8 *reg9a;\r\nint mode;\r\nstatic const u8 reg9a_def[] =\r\n{0x00, 0x40, 0x20, 0x00, 0x00, 0x00};\r\nstatic const u8 reg9a_spec[] =\r\n{0x00, 0x40, 0x38, 0x30, 0x00, 0x20};\r\nstatic const u8 regd4[] = {0x60, 0x00, 0x00};\r\nstatic const u8 C0[] = { 0x2d, 0x2d, 0x3a, 0x05, 0x04, 0x3f };\r\nstatic const u8 CA[] = { 0x28, 0xd8, 0x14, 0xec };\r\nstatic const u8 CA_adcm1700[] =\r\n{ 0x14, 0xec, 0x0a, 0xf6 };\r\nstatic const u8 CA_po2030n[] =\r\n{ 0x1e, 0xe2, 0x14, 0xec };\r\nstatic const u8 CE[] = { 0x32, 0xdd, 0x2d, 0xdd };\r\nstatic const u8 CE_gc0307[] =\r\n{ 0x32, 0xce, 0x2d, 0xd3 };\r\nstatic const u8 CE_ov76xx[] =\r\n{ 0x32, 0xdd, 0x32, 0xdd };\r\nstatic const u8 CE_po2030n[] =\r\n{ 0x14, 0xe7, 0x1e, 0xdd };\r\njpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\r\ngspca_dev->pixfmt.width,\r\n0x21);\r\nsn9c1xx = sn_tb[sd->sensor];\r\nreg01 = sn9c1xx[1];\r\nif (sd->flags & F_PDN_INV)\r\nreg01 ^= S_PDN_INV;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg0102[0] = reg01;\r\nreg0102[1] = sn9c1xx[2];\r\nif (gspca_dev->audio)\r\nreg0102[1] |= 0x04;\r\nreg_w(gspca_dev, 0x01, reg0102, 2);\r\nreg_w(gspca_dev, 0x08, &sn9c1xx[8], 2);\r\nreg_w(gspca_dev, 0x17, &sn9c1xx[0x17], 5);\r\nswitch (sd->sensor) {\r\ncase SENSOR_GC0307:\r\ncase SENSOR_OV7660:\r\ncase SENSOR_PO1030:\r\ncase SENSOR_PO2030N:\r\ncase SENSOR_SOI768:\r\ncase SENSOR_SP80708:\r\nreg9a = reg9a_spec;\r\nbreak;\r\ndefault:\r\nreg9a = reg9a_def;\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0x9a, reg9a, 6);\r\nreg_w(gspca_dev, 0xd4, regd4, sizeof regd4);\r\nreg_w(gspca_dev, 0x03, &sn9c1xx[3], 0x0f);\r\nreg17 = sn9c1xx[0x17];\r\nswitch (sd->sensor) {\r\ncase SENSOR_GC0307:\r\nmsleep(50);\r\nbreak;\r\ncase SENSOR_OM6802:\r\nmsleep(10);\r\nreg_w1(gspca_dev, 0x02, 0x73);\r\nreg17 |= SEN_CLK_EN;\r\nreg_w1(gspca_dev, 0x17, reg17);\r\nreg_w1(gspca_dev, 0x01, 0x22);\r\nmsleep(100);\r\nreg01 = SCL_SEL_OD | S_PDN_INV;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x04;\r\nbreak;\r\n}\r\nreg01 |= SYS_SEL_48M;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg17 |= SEN_CLK_EN;\r\nreg_w1(gspca_dev, 0x17, reg17);\r\nreg01 &= ~S_PWR_DN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg01 &= ~SCL_SEL_OD;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\nhv7131r_probe(gspca_dev);\r\nbreak;\r\ncase SENSOR_OM6802:\r\nmsleep(10);\r\nreg_w1(gspca_dev, 0x01, reg01);\r\ni2c_w8(gspca_dev, om6802_init0[0]);\r\ni2c_w8(gspca_dev, om6802_init0[1]);\r\nmsleep(15);\r\nreg_w1(gspca_dev, 0x02, 0x71);\r\nmsleep(150);\r\nbreak;\r\ncase SENSOR_SP80708:\r\nmsleep(100);\r\nreg_w1(gspca_dev, 0x02, 0x62);\r\nbreak;\r\n}\r\ni2c_w_seq(gspca_dev, sensor_init[sd->sensor]);\r\nreg_w1(gspca_dev, 0x15, sn9c1xx[0x15]);\r\nreg_w1(gspca_dev, 0x16, sn9c1xx[0x16]);\r\nreg_w1(gspca_dev, 0x12, sn9c1xx[0x12]);\r\nreg_w1(gspca_dev, 0x13, sn9c1xx[0x13]);\r\nreg_w1(gspca_dev, 0x18, sn9c1xx[0x18]);\r\nif (sd->sensor == SENSOR_ADCM1700) {\r\nreg_w1(gspca_dev, 0xd2, 0x3a);\r\nreg_w1(gspca_dev, 0xd3, 0x30);\r\n} else {\r\nreg_w1(gspca_dev, 0xd2, 0x6a);\r\nreg_w1(gspca_dev, 0xd3, 0x50);\r\n}\r\nreg_w1(gspca_dev, 0xc6, 0x00);\r\nreg_w1(gspca_dev, 0xc7, 0x00);\r\nif (sd->sensor == SENSOR_ADCM1700) {\r\nreg_w1(gspca_dev, 0xc8, 0x2c);\r\nreg_w1(gspca_dev, 0xc9, 0x24);\r\n} else {\r\nreg_w1(gspca_dev, 0xc8, 0x50);\r\nreg_w1(gspca_dev, 0xc9, 0x3c);\r\n}\r\nreg_w1(gspca_dev, 0x18, sn9c1xx[0x18]);\r\nswitch (sd->sensor) {\r\ncase SENSOR_OM6802:\r\nbreak;\r\ndefault:\r\nreg17 |= DEF_EN;\r\nbreak;\r\n}\r\nreg_w1(gspca_dev, 0x17, reg17);\r\nreg_w1(gspca_dev, 0x05, 0x00);\r\nreg_w1(gspca_dev, 0x07, 0x00);\r\nreg_w1(gspca_dev, 0x06, 0x00);\r\nreg_w1(gspca_dev, 0x14, sn9c1xx[0x14]);\r\nsetgamma(gspca_dev);\r\nfor (i = 0; i < 8; i++)\r\nreg_w(gspca_dev, 0x84, reg84, sizeof reg84);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_OV7660:\r\ncase SENSOR_SP80708:\r\nreg_w1(gspca_dev, 0x9a, 0x05);\r\nbreak;\r\ncase SENSOR_GC0307:\r\ncase SENSOR_MT9V111:\r\ncase SENSOR_MI0360B:\r\nreg_w1(gspca_dev, 0x9a, 0x07);\r\nbreak;\r\ncase SENSOR_OV7630:\r\ncase SENSOR_OV7648:\r\nreg_w1(gspca_dev, 0x9a, 0x0a);\r\nbreak;\r\ncase SENSOR_PO2030N:\r\ncase SENSOR_SOI768:\r\nreg_w1(gspca_dev, 0x9a, 0x06);\r\nbreak;\r\ndefault:\r\nreg_w1(gspca_dev, 0x9a, 0x08);\r\nbreak;\r\n}\r\nsetsharpness(gspca_dev);\r\nreg_w(gspca_dev, 0x84, reg84, sizeof reg84);\r\nreg_w1(gspca_dev, 0x05, 0x20);\r\nreg_w1(gspca_dev, 0x07, 0x20);\r\nreg_w1(gspca_dev, 0x06, 0x20);\r\ninit = NULL;\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nreg01 |= SYS_SEL_48M | V_TX_EN;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x02;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ninit = adcm1700_sensor_param1;\r\nbreak;\r\ncase SENSOR_GC0307:\r\ninit = gc0307_sensor_param1;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_MI0360:\r\nif (!mode)\r\nreg01 &= ~SYS_SEL_48M;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x01;\r\nbreak;\r\ncase SENSOR_MI0360B:\r\ninit = mi0360b_sensor_param1;\r\nbreak;\r\ncase SENSOR_MO4000:\r\nif (mode) {\r\nreg01 &= ~SYS_SEL_48M;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x01;\r\n}\r\nbreak;\r\ncase SENSOR_MT9V111:\r\ninit = mt9v111_sensor_param1;\r\nbreak;\r\ncase SENSOR_OM6802:\r\ninit = om6802_sensor_param1;\r\nif (!mode) {\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x04;\r\n} else {\r\nreg01 &= ~SYS_SEL_48M;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x02;\r\n}\r\nbreak;\r\ncase SENSOR_OV7630:\r\ninit = ov7630_sensor_param1;\r\nbreak;\r\ncase SENSOR_OV7648:\r\ninit = ov7648_sensor_param1;\r\nreg17 &= ~MCK_SIZE_MASK;\r\nreg17 |= 0x01;\r\nbreak;\r\ncase SENSOR_OV7660:\r\ninit = ov7660_sensor_param1;\r\nbreak;\r\ncase SENSOR_PO1030:\r\ninit = po1030_sensor_param1;\r\nbreak;\r\ncase SENSOR_PO2030N:\r\ninit = po2030n_sensor_param1;\r\nbreak;\r\ncase SENSOR_SOI768:\r\ninit = soi768_sensor_param1;\r\nbreak;\r\ncase SENSOR_SP80708:\r\ninit = sp80708_sensor_param1;\r\nbreak;\r\n}\r\nif (init != NULL) {\r\ni2c_w_seq(gspca_dev, init);\r\n}\r\nreg_w(gspca_dev, 0xc0, C0, 6);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_GC0307:\r\ncase SENSOR_SOI768:\r\nreg_w(gspca_dev, 0xca, CA_adcm1700, 4);\r\nbreak;\r\ncase SENSOR_PO2030N:\r\nreg_w(gspca_dev, 0xca, CA_po2030n, 4);\r\nbreak;\r\ndefault:\r\nreg_w(gspca_dev, 0xca, CA, 4);\r\nbreak;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_OV7630:\r\ncase SENSOR_OV7648:\r\ncase SENSOR_OV7660:\r\ncase SENSOR_SOI768:\r\nreg_w(gspca_dev, 0xce, CE_ov76xx, 4);\r\nbreak;\r\ncase SENSOR_GC0307:\r\nreg_w(gspca_dev, 0xce, CE_gc0307, 4);\r\nbreak;\r\ncase SENSOR_PO2030N:\r\nreg_w(gspca_dev, 0xce, CE_po2030n, 4);\r\nbreak;\r\ndefault:\r\nreg_w(gspca_dev, 0xce, CE, 4);\r\nbreak;\r\n}\r\nsd->reg18 = sn9c1xx[0x18] | (mode << 4) | 0x40;\r\nreg_w1(gspca_dev, 0x18, sd->reg18);\r\nsetjpegqual(gspca_dev);\r\nreg_w1(gspca_dev, 0x17, reg17);\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nsd->reg01 = reg01;\r\nsd->reg17 = reg17;\r\nsd->pktsz = sd->npkt = 0;\r\nsd->nchg = sd->short_mark = 0;\r\nsd->work_thread = create_singlethread_workqueue(MODULE_NAME);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstatic const u8 stophv7131[] =\r\n{ 0xa1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10 };\r\nstatic const u8 stopmi0360[] =\r\n{ 0xb1, 0x5d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10 };\r\nstatic const u8 stopov7648[] =\r\n{ 0xa1, 0x21, 0x76, 0x20, 0x00, 0x00, 0x00, 0x10 };\r\nstatic const u8 stopsoi768[] =\r\n{ 0xa1, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10 };\r\nu8 reg01;\r\nu8 reg17;\r\nreg01 = sd->reg01;\r\nreg17 = sd->reg17 & ~SEN_CLK_EN;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM1700:\r\ncase SENSOR_GC0307:\r\ncase SENSOR_PO2030N:\r\ncase SENSOR_SP80708:\r\nreg01 |= LED;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg01 &= ~(LED | V_TX_EN);\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nreg01 &= ~V_TX_EN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\ni2c_w8(gspca_dev, stophv7131);\r\nbreak;\r\ncase SENSOR_MI0360:\r\ncase SENSOR_MI0360B:\r\nreg01 &= ~V_TX_EN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\ni2c_w8(gspca_dev, stopmi0360);\r\nbreak;\r\ncase SENSOR_MT9V111:\r\ncase SENSOR_OM6802:\r\ncase SENSOR_PO1030:\r\nreg01 &= ~V_TX_EN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nbreak;\r\ncase SENSOR_OV7630:\r\ncase SENSOR_OV7648:\r\nreg01 &= ~V_TX_EN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\ni2c_w8(gspca_dev, stopov7648);\r\nbreak;\r\ncase SENSOR_OV7660:\r\nreg01 &= ~V_TX_EN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nbreak;\r\ncase SENSOR_SOI768:\r\ni2c_w8(gspca_dev, stopsoi768);\r\nbreak;\r\n}\r\nreg01 |= SCL_SEL_OD;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg01 |= S_PWR_DN;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg_w1(gspca_dev, 0x17, reg17);\r\nreg01 &= ~SYS_SEL_48M;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\nreg01 |= LED;\r\nreg_w1(gspca_dev, 0x01, reg01);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->work_thread != NULL) {\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(sd->work_thread);\r\nmutex_lock(&gspca_dev->usb_lock);\r\nsd->work_thread = NULL;\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint delta;\r\nint expotimes;\r\nu8 luma_mean = 130;\r\nu8 luma_delta = 20;\r\nif (sd->ag_cnt < 0)\r\nreturn;\r\nif (--sd->ag_cnt >= 0)\r\nreturn;\r\nsd->ag_cnt = AG_CNT_START;\r\ndelta = atomic_read(&sd->avg_lum);\r\nPDEBUG(D_FRAM, "mean lum %d", delta);\r\nif (sd->sensor == SENSOR_PO2030N) {\r\ngspca_expo_autogain(gspca_dev, delta, luma_mean, luma_delta,\r\n15, 1024);\r\nreturn;\r\n}\r\nif (delta < luma_mean - luma_delta ||\r\ndelta > luma_mean + luma_delta) {\r\nswitch (sd->sensor) {\r\ncase SENSOR_GC0307:\r\nexpotimes = sd->exposure;\r\nexpotimes += (luma_mean - delta) >> 6;\r\nif (expotimes < 0)\r\nexpotimes = 0;\r\nsd->exposure = expo_adjust(gspca_dev,\r\n(unsigned int) expotimes);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nexpotimes = sd->exposure >> 8;\r\nexpotimes += (luma_mean - delta) >> 4;\r\nif (expotimes < 0)\r\nexpotimes = 0;\r\nsd->exposure = expo_adjust(gspca_dev,\r\n(unsigned int) (expotimes << 8));\r\nbreak;\r\ncase SENSOR_OM6802:\r\ncase SENSOR_MT9V111:\r\nexpotimes = sd->exposure;\r\nexpotimes += (luma_mean - delta) >> 2;\r\nif (expotimes < 0)\r\nexpotimes = 0;\r\nsd->exposure = expo_adjust(gspca_dev,\r\n(unsigned int) expotimes);\r\nsetredblue(gspca_dev);\r\nbreak;\r\ndefault:\r\nexpotimes = sd->exposure;\r\nexpotimes += (luma_mean - delta) >> 6;\r\nif (expotimes < 0)\r\nexpotimes = 0;\r\nsd->exposure = expo_adjust(gspca_dev,\r\n(unsigned int) expotimes);\r\nsetredblue(gspca_dev);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void set_lum(struct sd *sd,\r\nu8 *data)\r\n{\r\nint avg_lum;\r\navg_lum = (data[27] << 8) + data[28]\r\n+ (data[31] << 8) + data[32]\r\n+ (data[23] << 8) + data[24]\r\n+ (data[35] << 8) + data[36]\r\n+ (data[29] << 10) + (data[30] << 2);\r\navg_lum >>= 10;\r\natomic_set(&sd->avg_lum, avg_lum);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, new_qual;\r\nsd->npkt++;\r\nsd->pktsz += len;\r\ni = sd->short_mark;\r\nif (i != 0) {\r\nsd->short_mark = 0;\r\nif (i < 0\r\n&& data[0] == 0xff\r\n&& data[1] == 0x00)\r\ngoto marker_found;\r\nif (data[0] == 0xff && data[1] == 0xff) {\r\ni = 0;\r\ngoto marker_found;\r\n}\r\nlen -= i;\r\nif (len <= 0)\r\nreturn;\r\ndata += i;\r\n}\r\nfor (i = len - 1; --i >= 0; ) {\r\nif (data[i] != 0xff) {\r\ni--;\r\ncontinue;\r\n}\r\nif (data[i + 1] == 0xff) {\r\nif (i + 2 >= len || data[i + 2] == 0x00)\r\ngoto marker_found;\r\n}\r\n}\r\nif (data[len - 1] == 0xff)\r\nsd->short_mark = -1;\r\nif (gspca_dev->last_packet_type == LAST_PACKET)\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nreturn;\r\nmarker_found:\r\nnew_qual = 0;\r\nif (i > 2) {\r\nif (data[i - 2] != 0xff || data[i - 1] != 0xd9) {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nnew_qual = -3;\r\n}\r\n} else if (i + 6 < len) {\r\nif (data[i + 6] & 0x08) {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nnew_qual = -5;\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET, data, i);\r\nif (new_qual == 0) {\r\nint r;\r\nr = (sd->pktsz * 100) /\r\n(sd->npkt *\r\ngspca_dev->urb[0]->iso_frame_desc[0].length);\r\nif (r >= 85)\r\nnew_qual = -3;\r\nelse if (r < 75)\r\nnew_qual = 2;\r\n}\r\nif (new_qual != 0) {\r\nsd->nchg += new_qual;\r\nif (sd->nchg < -6 || sd->nchg >= 12) {\r\nsd->nchg = 0;\r\nnew_qual += sd->quality;\r\nif (new_qual < QUALITY_MIN)\r\nnew_qual = QUALITY_MIN;\r\nelse if (new_qual > QUALITY_MAX)\r\nnew_qual = QUALITY_MAX;\r\nif (new_qual != sd->quality) {\r\nsd->quality = new_qual;\r\nqueue_work(sd->work_thread, &sd->work);\r\n}\r\n}\r\n} else {\r\nsd->nchg = 0;\r\n}\r\nsd->pktsz = sd->npkt = 0;\r\nif (i + 62 > len) {\r\nsd->short_mark = i + 62 - len;\r\nreturn;\r\n}\r\nif (sd->ag_cnt >= 0)\r\nset_lum(sd, data + i);\r\ni += 62;\r\nif (i < len) {\r\ndata += i;\r\nlen -= i;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nsetredblue(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nsetgamma(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nsetautogain(gspca_dev);\r\nsetexposure(gspca_dev);\r\nsetgain(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nsethvflip(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_ILLUMINATORS_1:\r\nsetillum(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetfreq(gspca_dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nif (len == 1 && data[0] == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
