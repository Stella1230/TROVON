static int twl4030_madc_read(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct twl4030_madc_data *madc = iio_priv(iio_dev);\r\nstruct twl4030_madc_request req;\r\nint ret;\r\nreq.method = madc->use_second_irq ? TWL4030_MADC_SW2 : TWL4030_MADC_SW1;\r\nreq.channels = BIT(chan->channel);\r\nreq.active = false;\r\nreq.func_cb = NULL;\r\nreq.type = TWL4030_MADC_WAIT;\r\nreq.raw = !(mask == IIO_CHAN_INFO_PROCESSED);\r\nreq.do_avg = (mask == IIO_CHAN_INFO_AVERAGE_RAW);\r\nret = twl4030_madc_conversion(&req);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = req.rbuf[chan->channel];\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int twl4030_madc_channel_raw_read(struct twl4030_madc_data *madc, u8 reg)\r\n{\r\nu16 val;\r\nint ret;\r\nret = twl_i2c_read_u16(TWL4030_MODULE_MADC, &val, reg);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read register 0x%X\n", reg);\r\nreturn ret;\r\n}\r\nreturn (int)(val >> 6);\r\n}\r\nstatic int twl4030battery_temperature(int raw_volt)\r\n{\r\nu8 val;\r\nint temp, curr, volt, res, ret;\r\nvolt = (raw_volt * TEMP_STEP_SIZE) / TEMP_PSR_R;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, &val,\r\nREG_BCICTL2);\r\nif (ret < 0)\r\nreturn ret;\r\ncurr = ((val & TWL4030_BCI_ITHEN) + 1) * 10;\r\nres = volt * 1000 / curr;\r\nfor (temp = 58; temp >= 0; temp--) {\r\nint actual = twl4030_therm_tbl[temp];\r\nif ((actual - res) >= 0)\r\nbreak;\r\n}\r\nreturn temp + 1;\r\n}\r\nstatic int twl4030battery_current(int raw_volt)\r\n{\r\nint ret;\r\nu8 val;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, &val,\r\nTWL4030_BCI_BCICTL1);\r\nif (ret)\r\nreturn ret;\r\nif (val & TWL4030_BCI_CGAIN)\r\nreturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R1;\r\nelse\r\nreturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R2;\r\n}\r\nstatic int twl4030_madc_read_channels(struct twl4030_madc_data *madc,\r\nu8 reg_base, unsigned\r\nlong channels, int *buf,\r\nbool raw)\r\n{\r\nint count = 0;\r\nint i;\r\nu8 reg;\r\nfor_each_set_bit(i, &channels, TWL4030_MADC_MAX_CHANNELS) {\r\nreg = reg_base + (2 * i);\r\nbuf[i] = twl4030_madc_channel_raw_read(madc, reg);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev, "Unable to read register 0x%X\n",\r\nreg);\r\nreturn buf[i];\r\n}\r\nif (raw) {\r\ncount++;\r\ncontinue;\r\n}\r\nswitch (i) {\r\ncase 10:\r\nbuf[i] = twl4030battery_current(buf[i]);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev, "err reading current\n");\r\nreturn buf[i];\r\n} else {\r\ncount++;\r\nbuf[i] = buf[i] - 750;\r\n}\r\nbreak;\r\ncase 1:\r\nbuf[i] = twl4030battery_temperature(buf[i]);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev, "err reading temperature\n");\r\nreturn buf[i];\r\n} else {\r\nbuf[i] -= 3;\r\ncount++;\r\n}\r\nbreak;\r\ndefault:\r\ncount++;\r\nbuf[i] = (buf[i] * 3 * 1000 *\r\ntwl4030_divider_ratios[i].denominator)\r\n/ (2 * 1023 *\r\ntwl4030_divider_ratios[i].numerator);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int twl4030_madc_enable_irq(struct twl4030_madc_data *madc, u8 id)\r\n{\r\nu8 val;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\nreturn ret;\r\n}\r\nval &= ~(1 << id);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to write imr register 0x%X\n", madc->imr);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_disable_irq(struct twl4030_madc_data *madc, u8 id)\r\n{\r\nu8 val;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\nreturn ret;\r\n}\r\nval |= (1 << id);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to write imr register 0x%X\n", madc->imr);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t twl4030_madc_threaded_irq_handler(int irq, void *_madc)\r\n{\r\nstruct twl4030_madc_data *madc = _madc;\r\nconst struct twl4030_madc_conversion_method *method;\r\nu8 isr_val, imr_val;\r\nint i, len, ret;\r\nstruct twl4030_madc_request *r;\r\nmutex_lock(&madc->lock);\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &isr_val, madc->isr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read isr register 0x%X\n",\r\nmadc->isr);\r\ngoto err_i2c;\r\n}\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &imr_val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\ngoto err_i2c;\r\n}\r\nisr_val &= ~imr_val;\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nif (!(isr_val & (1 << i)))\r\ncontinue;\r\nret = twl4030_madc_disable_irq(madc, i);\r\nif (ret < 0)\r\ndev_dbg(madc->dev, "Disable interrupt failed %d\n", i);\r\nmadc->requests[i].result_pending = 1;\r\n}\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nr = &madc->requests[i];\r\nif (!r->result_pending)\r\ncontinue;\r\nmethod = &twl4030_conversion_methods[r->method];\r\nlen = twl4030_madc_read_channels(madc, method->rbase,\r\nr->channels, r->rbuf, r->raw);\r\nif (r->func_cb != NULL) {\r\nr->func_cb(len, r->channels, r->rbuf);\r\nr->func_cb = NULL;\r\n}\r\nr->result_pending = 0;\r\nr->active = 0;\r\n}\r\nmutex_unlock(&madc->lock);\r\nreturn IRQ_HANDLED;\r\nerr_i2c:\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nr = &madc->requests[i];\r\nif (r->active == 0)\r\ncontinue;\r\nmethod = &twl4030_conversion_methods[r->method];\r\nlen = twl4030_madc_read_channels(madc, method->rbase,\r\nr->channels, r->rbuf, r->raw);\r\nif (r->func_cb != NULL) {\r\nr->func_cb(len, r->channels, r->rbuf);\r\nr->func_cb = NULL;\r\n}\r\nr->result_pending = 0;\r\nr->active = 0;\r\n}\r\nmutex_unlock(&madc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl4030_madc_set_irq(struct twl4030_madc_data *madc,\r\nstruct twl4030_madc_request *req)\r\n{\r\nstruct twl4030_madc_request *p;\r\nint ret;\r\np = &madc->requests[req->method];\r\nmemcpy(p, req, sizeof(*req));\r\nret = twl4030_madc_enable_irq(madc, req->method);\r\nif (ret < 0) {\r\ndev_err(madc->dev, "enable irq failed!!\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_start_conversion(struct twl4030_madc_data *madc,\r\nint conv_method)\r\n{\r\nconst struct twl4030_madc_conversion_method *method;\r\nint ret = 0;\r\nif (conv_method != TWL4030_MADC_SW1 && conv_method != TWL4030_MADC_SW2)\r\nreturn -ENOTSUPP;\r\nmethod = &twl4030_conversion_methods[conv_method];\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, TWL4030_MADC_SW_START,\r\nmethod->ctrl);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to write ctrl register 0x%X\n",\r\nmethod->ctrl);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_wait_conversion_ready(struct twl4030_madc_data *madc,\r\nunsigned int timeout_ms,\r\nu8 status_reg)\r\n{\r\nunsigned long timeout;\r\nint ret;\r\ntimeout = jiffies + msecs_to_jiffies(timeout_ms);\r\ndo {\r\nu8 reg;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &reg, status_reg);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to read status register 0x%X\n",\r\nstatus_reg);\r\nreturn ret;\r\n}\r\nif (!(reg & TWL4030_MADC_BUSY) && (reg & TWL4030_MADC_EOC_SW))\r\nreturn 0;\r\nusleep_range(500, 2000);\r\n} while (!time_after(jiffies, timeout));\r\ndev_err(madc->dev, "conversion timeout!\n");\r\nreturn -EAGAIN;\r\n}\r\nint twl4030_madc_conversion(struct twl4030_madc_request *req)\r\n{\r\nconst struct twl4030_madc_conversion_method *method;\r\nint ret;\r\nif (!req || !twl4030_madc)\r\nreturn -EINVAL;\r\nmutex_lock(&twl4030_madc->lock);\r\nif (req->method < TWL4030_MADC_RT || req->method > TWL4030_MADC_SW2) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (twl4030_madc->requests[req->method].active) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmethod = &twl4030_conversion_methods[req->method];\r\nret = twl_i2c_write_u16(TWL4030_MODULE_MADC, req->channels, method->sel);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write sel register 0x%X\n", method->sel);\r\ngoto out;\r\n}\r\nif (req->do_avg) {\r\nret = twl_i2c_write_u16(TWL4030_MODULE_MADC, req->channels,\r\nmethod->avg);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write avg register 0x%X\n",\r\nmethod->avg);\r\ngoto out;\r\n}\r\n}\r\nif (req->type == TWL4030_MADC_IRQ_ONESHOT && req->func_cb != NULL) {\r\nret = twl4030_madc_set_irq(twl4030_madc, req);\r\nif (ret < 0)\r\ngoto out;\r\nret = twl4030_madc_start_conversion(twl4030_madc, req->method);\r\nif (ret < 0)\r\ngoto out;\r\ntwl4030_madc->requests[req->method].active = 1;\r\nret = 0;\r\ngoto out;\r\n}\r\nif (req->method == TWL4030_MADC_RT) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = twl4030_madc_start_conversion(twl4030_madc, req->method);\r\nif (ret < 0)\r\ngoto out;\r\ntwl4030_madc->requests[req->method].active = 1;\r\nret = twl4030_madc_wait_conversion_ready(twl4030_madc, 5, method->ctrl);\r\nif (ret) {\r\ntwl4030_madc->requests[req->method].active = 0;\r\ngoto out;\r\n}\r\nret = twl4030_madc_read_channels(twl4030_madc, method->rbase,\r\nreq->channels, req->rbuf, req->raw);\r\ntwl4030_madc->requests[req->method].active = 0;\r\nout:\r\nmutex_unlock(&twl4030_madc->lock);\r\nreturn ret;\r\n}\r\nint twl4030_get_madc_conversion(int channel_no)\r\n{\r\nstruct twl4030_madc_request req;\r\nint temp = 0;\r\nint ret;\r\nreq.channels = (1 << channel_no);\r\nreq.method = TWL4030_MADC_SW2;\r\nreq.active = 0;\r\nreq.raw = 0;\r\nreq.func_cb = NULL;\r\nret = twl4030_madc_conversion(&req);\r\nif (ret < 0)\r\nreturn ret;\r\nif (req.rbuf[channel_no] > 0)\r\ntemp = req.rbuf[channel_no];\r\nreturn temp;\r\n}\r\nstatic int twl4030_madc_set_current_generator(struct twl4030_madc_data *madc,\r\nint chan, int on)\r\n{\r\nint ret;\r\nint regmask;\r\nu8 regval;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read BCICTL1 reg 0x%X",\r\nTWL4030_BCI_BCICTL1);\r\nreturn ret;\r\n}\r\nregmask = chan ? TWL4030_BCI_ITHEN : TWL4030_BCI_TYPEN;\r\nif (on)\r\nregval |= regmask;\r\nelse\r\nregval &= ~regmask;\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nregval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to write BCICTL1 reg 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_set_power(struct twl4030_madc_data *madc, int on)\r\n{\r\nu8 regval;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_MADC_CTRL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read madc ctrl1 reg 0x%X\n",\r\nTWL4030_MADC_CTRL1);\r\nreturn ret;\r\n}\r\nif (on)\r\nregval |= TWL4030_MADC_MADCON;\r\nelse\r\nregval &= ~TWL4030_MADC_MADCON;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, regval, TWL4030_MADC_CTRL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to write madc ctrl1 reg 0x%X\n",\r\nTWL4030_MADC_CTRL1);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_madc_data *madc;\r\nstruct twl4030_madc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nint irq, ret;\r\nu8 regval;\r\nstruct iio_dev *iio_dev = NULL;\r\nif (!pdata && !np) {\r\ndev_err(&pdev->dev, "neither platform data nor Device Tree node available\n");\r\nreturn -EINVAL;\r\n}\r\niio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*madc));\r\nif (!iio_dev) {\r\ndev_err(&pdev->dev, "failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nmadc = iio_priv(iio_dev);\r\nmadc->dev = &pdev->dev;\r\niio_dev->name = dev_name(&pdev->dev);\r\niio_dev->dev.parent = &pdev->dev;\r\niio_dev->dev.of_node = pdev->dev.of_node;\r\niio_dev->info = &twl4030_madc_iio_info;\r\niio_dev->modes = INDIO_DIRECT_MODE;\r\niio_dev->channels = twl4030_madc_iio_channels;\r\niio_dev->num_channels = ARRAY_SIZE(twl4030_madc_iio_channels);\r\nif (pdata)\r\nmadc->use_second_irq = (pdata->irq_line != 1);\r\nelse\r\nmadc->use_second_irq = of_property_read_bool(np,\r\n"ti,system-uses-second-madc-irq");\r\nmadc->imr = madc->use_second_irq ? TWL4030_MADC_IMR2 :\r\nTWL4030_MADC_IMR1;\r\nmadc->isr = madc->use_second_irq ? TWL4030_MADC_ISR2 :\r\nTWL4030_MADC_ISR1;\r\nret = twl4030_madc_set_power(madc, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl4030_madc_set_current_generator(madc, 0, 1);\r\nif (ret < 0)\r\ngoto err_current_generator;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to read reg BCI CTL1 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\ngoto err_i2c;\r\n}\r\nregval |= TWL4030_BCI_MESBAT;\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nregval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to write reg BCI Ctl1 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\ngoto err_i2c;\r\n}\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &regval, TWL4030_REG_GPBR1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to read reg GPBR1 0x%X\n",\r\nTWL4030_REG_GPBR1);\r\ngoto err_i2c;\r\n}\r\nif (!(regval & TWL4030_GPBR1_MADC_HFCLK_EN)) {\r\ndev_info(&pdev->dev, "clk disabled, enabling\n");\r\nregval |= TWL4030_GPBR1_MADC_HFCLK_EN;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, regval,\r\nTWL4030_REG_GPBR1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to write reg GPBR1 0x%X\n",\r\nTWL4030_REG_GPBR1);\r\ngoto err_i2c;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, iio_dev);\r\nmutex_init(&madc->lock);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\ntwl4030_madc_threaded_irq_handler,\r\nIRQF_TRIGGER_RISING, "twl4030_madc", madc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not request irq\n");\r\ngoto err_i2c;\r\n}\r\ntwl4030_madc = madc;\r\nret = iio_device_register(iio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register iio device\n");\r\ngoto err_i2c;\r\n}\r\nreturn 0;\r\nerr_i2c:\r\ntwl4030_madc_set_current_generator(madc, 0, 0);\r\nerr_current_generator:\r\ntwl4030_madc_set_power(madc, 0);\r\nreturn ret;\r\n}\r\nstatic int twl4030_madc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *iio_dev = platform_get_drvdata(pdev);\r\nstruct twl4030_madc_data *madc = iio_priv(iio_dev);\r\niio_device_unregister(iio_dev);\r\ntwl4030_madc_set_current_generator(madc, 0, 0);\r\ntwl4030_madc_set_power(madc, 0);\r\nreturn 0;\r\n}
