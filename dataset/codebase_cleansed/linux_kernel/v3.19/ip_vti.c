static int vti_input(struct sk_buff *skb, int nexthdr, __be32 spi,\r\nint encap_type)\r\n{\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn = net_generic(net, vti_net_id);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->saddr, iph->daddr, 0);\r\nif (tunnel != NULL) {\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto drop;\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = tunnel;\r\nskb->mark = be32_to_cpu(tunnel->parms.i_key);\r\nreturn xfrm_input(skb, nexthdr, spi, encap_type);\r\n}\r\nreturn -EINVAL;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int vti_rcv(struct sk_buff *skb)\r\n{\r\nXFRM_SPI_SKB_CB(skb)->family = AF_INET;\r\nXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\r\nreturn vti_input(skb, ip_hdr(skb)->protocol, 0, 0);\r\n}\r\nstatic int vti_rcv_cb(struct sk_buff *skb, int err)\r\n{\r\nunsigned short family;\r\nstruct net_device *dev;\r\nstruct pcpu_sw_netstats *tstats;\r\nstruct xfrm_state *x;\r\nstruct ip_tunnel *tunnel = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4;\r\nif (!tunnel)\r\nreturn 1;\r\ndev = tunnel->dev;\r\nif (err) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nx = xfrm_input_state(skb);\r\nfamily = x->inner_mode->afinfo->family;\r\nif (!xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family))\r\nreturn -EPERM;\r\nskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(skb->dev)));\r\nskb->dev = dev;\r\ntstats = this_cpu_ptr(dev->tstats);\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&tstats->syncp);\r\nreturn 0;\r\n}\r\nstatic bool vti_state_check(const struct xfrm_state *x, __be32 dst, __be32 src)\r\n{\r\nxfrm_address_t *daddr = (xfrm_address_t *)&dst;\r\nxfrm_address_t *saddr = (xfrm_address_t *)&src;\r\nif (!x || x->props.mode != XFRM_MODE_TUNNEL ||\r\nx->props.family != AF_INET)\r\nreturn false;\r\nif (!dst)\r\nreturn xfrm_addr_equal(saddr, &x->props.saddr, AF_INET);\r\nif (!xfrm_state_addr_check(x, daddr, saddr, AF_INET))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,\r\nstruct flowi *fl)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct ip_tunnel_parm *parms = &tunnel->parms;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct net_device *tdev;\r\nint err;\r\nif (!dst) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\ndst_hold(dst);\r\ndst = xfrm_lookup(tunnel->net, dst, fl, NULL, 0);\r\nif (IS_ERR(dst)) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\nif (!vti_state_check(dst->xfrm, parms->iph.daddr, parms->iph.saddr)) {\r\ndev->stats.tx_carrier_errors++;\r\ndst_release(dst);\r\ngoto tx_error_icmp;\r\n}\r\ntdev = dst->dev;\r\nif (tdev == dev) {\r\ndst_release(dst);\r\ndev->stats.collisions++;\r\ngoto tx_error;\r\n}\r\nif (tunnel->err_count > 0) {\r\nif (time_before(jiffies,\r\ntunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\r\ntunnel->err_count--;\r\ndst_link_failure(skb);\r\n} else\r\ntunnel->err_count = 0;\r\n}\r\nskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(dev)));\r\nskb_dst_set(skb, dst);\r\nskb->dev = skb_dst(skb)->dev;\r\nerr = dst_output(skb);\r\nif (net_xmit_eval(err) == 0)\r\nerr = skb->len;\r\niptunnel_xmit_stats(err, &dev->stats, dev->tstats);\r\nreturn NETDEV_TX_OK;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\ndev->stats.tx_errors++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct flowi fl;\r\nmemset(&fl, 0, sizeof(fl));\r\nskb->mark = be32_to_cpu(tunnel->parms.o_key);\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nxfrm_decode_session(skb, &fl, AF_INET);\r\nmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nxfrm_decode_session(skb, &fl, AF_INET6);\r\nmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\r\nbreak;\r\ndefault:\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nreturn vti_xmit(skb, dev, &fl);\r\n}\r\nstatic int vti4_err(struct sk_buff *skb, u32 info)\r\n{\r\n__be32 spi;\r\n__u32 mark;\r\nstruct xfrm_state *x;\r\nstruct ip_tunnel *tunnel;\r\nstruct ip_esp_hdr *esph;\r\nstruct ip_auth_hdr *ah ;\r\nstruct ip_comp_hdr *ipch;\r\nstruct net *net = dev_net(skb->dev);\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nint protocol = iph->protocol;\r\nstruct ip_tunnel_net *itn = net_generic(net, vti_net_id);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->daddr, iph->saddr, 0);\r\nif (!tunnel)\r\nreturn -1;\r\nmark = be32_to_cpu(tunnel->parms.o_key);\r\nswitch (protocol) {\r\ncase IPPROTO_ESP:\r\nesph = (struct ip_esp_hdr *)(skb->data+(iph->ihl<<2));\r\nspi = esph->spi;\r\nbreak;\r\ncase IPPROTO_AH:\r\nah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));\r\nspi = ah->spi;\r\nbreak;\r\ncase IPPROTO_COMP:\r\nipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));\r\nspi = htonl(ntohs(ipch->cpi));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (icmp_hdr(skb)->type) {\r\ncase ICMP_DEST_UNREACH:\r\nif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\r\nreturn 0;\r\ncase ICMP_REDIRECT:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nx = xfrm_state_lookup(net, mark, (const xfrm_address_t *)&iph->daddr,\r\nspi, protocol, AF_INET);\r\nif (!x)\r\nreturn 0;\r\nif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\r\nipv4_update_pmtu(skb, net, info, 0, 0, protocol, 0);\r\nelse\r\nipv4_redirect(skb, net, 0, 0, protocol, 0);\r\nxfrm_state_put(x);\r\nreturn 0;\r\n}\r\nstatic int\r\nvti_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nreturn -EFAULT;\r\nif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\r\np.iph.ihl != 5)\r\nreturn -EINVAL;\r\n}\r\nif (!(p.i_flags & GRE_KEY))\r\np.i_key = 0;\r\nif (!(p.o_flags & GRE_KEY))\r\np.o_key = 0;\r\np.i_flags = VTI_ISVTI;\r\nerr = ip_tunnel_ioctl(dev, &p, cmd);\r\nif (err)\r\nreturn err;\r\nif (cmd != SIOCDELTUNNEL) {\r\np.i_flags |= GRE_KEY;\r\np.o_flags |= GRE_KEY;\r\n}\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void vti_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &vti_netdev_ops;\r\ndev->type = ARPHRD_TUNNEL;\r\nip_tunnel_setup(dev, vti_net_id);\r\n}\r\nstatic int vti_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\nmemcpy(dev->dev_addr, &iph->saddr, 4);\r\nmemcpy(dev->broadcast, &iph->daddr, 4);\r\ndev->hard_header_len = LL_MAX_HEADER + sizeof(struct iphdr);\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->flags = IFF_NOARP;\r\ndev->iflink = 0;\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_LLTX;\r\nnetif_keep_dst(dev);\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic void __net_init vti_fb_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\niph->version = 4;\r\niph->protocol = IPPROTO_IPIP;\r\niph->ihl = 5;\r\n}\r\nstatic int __net_init vti_init_net(struct net *net)\r\n{\r\nint err;\r\nstruct ip_tunnel_net *itn;\r\nerr = ip_tunnel_init_net(net, vti_net_id, &vti_link_ops, "ip_vti0");\r\nif (err)\r\nreturn err;\r\nitn = net_generic(net, vti_net_id);\r\nvti_fb_tunnel_init(itn->fb_tunnel_dev);\r\nreturn 0;\r\n}\r\nstatic void __net_exit vti_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, vti_net_id);\r\nip_tunnel_delete_net(itn, &vti_link_ops);\r\n}\r\nstatic int vti_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nreturn 0;\r\n}\r\nstatic void vti_netlink_parms(struct nlattr *data[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.protocol = IPPROTO_IPIP;\r\nif (!data)\r\nreturn;\r\nparms->i_flags = VTI_ISVTI;\r\nif (data[IFLA_VTI_LINK])\r\nparms->link = nla_get_u32(data[IFLA_VTI_LINK]);\r\nif (data[IFLA_VTI_IKEY])\r\nparms->i_key = nla_get_be32(data[IFLA_VTI_IKEY]);\r\nif (data[IFLA_VTI_OKEY])\r\nparms->o_key = nla_get_be32(data[IFLA_VTI_OKEY]);\r\nif (data[IFLA_VTI_LOCAL])\r\nparms->iph.saddr = nla_get_be32(data[IFLA_VTI_LOCAL]);\r\nif (data[IFLA_VTI_REMOTE])\r\nparms->iph.daddr = nla_get_be32(data[IFLA_VTI_REMOTE]);\r\n}\r\nstatic int vti_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm parms;\r\nvti_netlink_parms(data, &parms);\r\nreturn ip_tunnel_newlink(dev, tb, &parms);\r\n}\r\nstatic int vti_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nvti_netlink_parms(data, &p);\r\nreturn ip_tunnel_changelink(dev, tb, &p);\r\n}\r\nstatic size_t vti_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\n0;\r\n}\r\nstatic int vti_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm *p = &t->parms;\r\nnla_put_u32(skb, IFLA_VTI_LINK, p->link);\r\nnla_put_be32(skb, IFLA_VTI_IKEY, p->i_key);\r\nnla_put_be32(skb, IFLA_VTI_OKEY, p->o_key);\r\nnla_put_be32(skb, IFLA_VTI_LOCAL, p->iph.saddr);\r\nnla_put_be32(skb, IFLA_VTI_REMOTE, p->iph.daddr);\r\nreturn 0;\r\n}\r\nstatic int __init vti_init(void)\r\n{\r\nconst char *msg;\r\nint err;\r\npr_info("IPv4 over IPsec tunneling driver\n");\r\nmsg = "tunnel device";\r\nerr = register_pernet_device(&vti_net_ops);\r\nif (err < 0)\r\ngoto pernet_dev_failed;\r\nmsg = "tunnel protocols";\r\nerr = xfrm4_protocol_register(&vti_esp4_protocol, IPPROTO_ESP);\r\nif (err < 0)\r\ngoto xfrm_proto_esp_failed;\r\nerr = xfrm4_protocol_register(&vti_ah4_protocol, IPPROTO_AH);\r\nif (err < 0)\r\ngoto xfrm_proto_ah_failed;\r\nerr = xfrm4_protocol_register(&vti_ipcomp4_protocol, IPPROTO_COMP);\r\nif (err < 0)\r\ngoto xfrm_proto_comp_failed;\r\nmsg = "netlink interface";\r\nerr = rtnl_link_register(&vti_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nreturn err;\r\nrtnl_link_failed:\r\nxfrm4_protocol_deregister(&vti_ipcomp4_protocol, IPPROTO_COMP);\r\nxfrm_proto_comp_failed:\r\nxfrm4_protocol_deregister(&vti_ah4_protocol, IPPROTO_AH);\r\nxfrm_proto_ah_failed:\r\nxfrm4_protocol_deregister(&vti_esp4_protocol, IPPROTO_ESP);\r\nxfrm_proto_esp_failed:\r\nunregister_pernet_device(&vti_net_ops);\r\npernet_dev_failed:\r\npr_err("vti init: failed to register %s\n", msg);\r\nreturn err;\r\n}\r\nstatic void __exit vti_fini(void)\r\n{\r\nrtnl_link_unregister(&vti_link_ops);\r\nxfrm4_protocol_deregister(&vti_ipcomp4_protocol, IPPROTO_COMP);\r\nxfrm4_protocol_deregister(&vti_ah4_protocol, IPPROTO_AH);\r\nxfrm4_protocol_deregister(&vti_esp4_protocol, IPPROTO_ESP);\r\nunregister_pernet_device(&vti_net_ops);\r\n}
