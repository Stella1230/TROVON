static int isl29018_set_range(struct isl29018_chip *chip, unsigned long range,\r\nunsigned int *new_range)\r\n{\r\nstatic const unsigned long supp_ranges[] = {1000, 4000, 16000, 64000};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supp_ranges); ++i) {\r\nif (range <= supp_ranges[i]) {\r\n*new_range = (unsigned int)supp_ranges[i];\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(supp_ranges))\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,\r\nCOMMANDII_RANGE_MASK, i << COMMANDII_RANGE_SHIFT);\r\n}\r\nstatic int isl29018_set_resolution(struct isl29018_chip *chip,\r\nunsigned long adcbit, unsigned int *conf_adc_bit)\r\n{\r\nstatic const unsigned long supp_adcbit[] = {16, 12, 8, 4};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supp_adcbit); ++i) {\r\nif (adcbit >= supp_adcbit[i]) {\r\n*conf_adc_bit = (unsigned int)supp_adcbit[i];\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(supp_adcbit))\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,\r\nCOMMANDII_RESOLUTION_MASK,\r\ni << COMMANDII_RESOLUTION_SHIFT);\r\n}\r\nstatic int isl29018_read_sensor_input(struct isl29018_chip *chip, int mode)\r\n{\r\nint status;\r\nunsigned int lsb;\r\nunsigned int msb;\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1,\r\nmode << COMMMAND1_OPMODE_SHIFT);\r\nif (status) {\r\ndev_err(chip->dev,\r\n"Error in setting operating mode err %d\n", status);\r\nreturn status;\r\n}\r\nmsleep(CONVERSION_TIME_MS);\r\nstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_LSB, &lsb);\r\nif (status < 0) {\r\ndev_err(chip->dev,\r\n"Error in reading LSB DATA with err %d\n", status);\r\nreturn status;\r\n}\r\nstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_MSB, &msb);\r\nif (status < 0) {\r\ndev_err(chip->dev,\r\n"Error in reading MSB DATA with error %d\n", status);\r\nreturn status;\r\n}\r\ndev_vdbg(chip->dev, "MSB 0x%x and LSB 0x%x\n", msb, lsb);\r\nreturn (msb << 8) | lsb;\r\n}\r\nstatic int isl29018_read_lux(struct isl29018_chip *chip, int *lux)\r\n{\r\nint lux_data;\r\nunsigned int data_x_range, lux_unshifted;\r\nlux_data = isl29018_read_sensor_input(chip, COMMMAND1_OPMODE_ALS_ONCE);\r\nif (lux_data < 0)\r\nreturn lux_data;\r\ndata_x_range = lux_data * chip->range;\r\nlux_unshifted = data_x_range * chip->lux_scale;\r\nlux_unshifted += data_x_range / 1000 * chip->lux_uscale / 1000;\r\n*lux = lux_unshifted >> chip->adc_bit;\r\nreturn 0;\r\n}\r\nstatic int isl29018_read_ir(struct isl29018_chip *chip, int *ir)\r\n{\r\nint ir_data;\r\nir_data = isl29018_read_sensor_input(chip, COMMMAND1_OPMODE_IR_ONCE);\r\nif (ir_data < 0)\r\nreturn ir_data;\r\n*ir = ir_data;\r\nreturn 0;\r\n}\r\nstatic int isl29018_read_proximity_ir(struct isl29018_chip *chip, int scheme,\r\nint *near_ir)\r\n{\r\nint status;\r\nint prox_data = -1;\r\nint ir_data = -1;\r\nstatus = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,\r\nCOMMANDII_SCHEME_MASK,\r\nscheme << COMMANDII_SCHEME_SHIFT);\r\nif (status) {\r\ndev_err(chip->dev, "Error in setting operating mode\n");\r\nreturn status;\r\n}\r\nprox_data = isl29018_read_sensor_input(chip,\r\nCOMMMAND1_OPMODE_PROX_ONCE);\r\nif (prox_data < 0)\r\nreturn prox_data;\r\nif (scheme == 1) {\r\n*near_ir = prox_data;\r\nreturn 0;\r\n}\r\nir_data = isl29018_read_sensor_input(chip, COMMMAND1_OPMODE_IR_ONCE);\r\nif (ir_data < 0)\r\nreturn ir_data;\r\nif (prox_data >= ir_data)\r\n*near_ir = prox_data - ir_data;\r\nelse\r\n*near_ir = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_range(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", chip->range);\r\n}\r\nstatic ssize_t store_range(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint status;\r\nunsigned long lval;\r\nunsigned int new_range;\r\nif (kstrtoul(buf, 10, &lval))\r\nreturn -EINVAL;\r\nif (!(lval == 1000UL || lval == 4000UL ||\r\nlval == 16000UL || lval == 64000UL)) {\r\ndev_err(dev, "The range is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->lock);\r\nstatus = isl29018_set_range(chip, lval, &new_range);\r\nif (status < 0) {\r\nmutex_unlock(&chip->lock);\r\ndev_err(dev,\r\n"Error in setting max range with err %d\n", status);\r\nreturn status;\r\n}\r\nchip->range = new_range;\r\nmutex_unlock(&chip->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_resolution(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", chip->adc_bit);\r\n}\r\nstatic ssize_t store_resolution(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint status;\r\nunsigned int val;\r\nunsigned int new_adc_bit;\r\nif (kstrtouint(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (!(val == 4 || val == 8 || val == 12 || val == 16)) {\r\ndev_err(dev, "The resolution is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->lock);\r\nstatus = isl29018_set_resolution(chip, val, &new_adc_bit);\r\nif (status < 0) {\r\nmutex_unlock(&chip->lock);\r\ndev_err(dev, "Error in setting resolution\n");\r\nreturn status;\r\n}\r\nchip->adc_bit = new_adc_bit;\r\nmutex_unlock(&chip->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_prox_infrared_suppression(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->prox_scheme);\r\n}\r\nstatic ssize_t store_prox_infrared_suppression(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint val;\r\nif (kstrtoint(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (!(val == 0 || val == 1)) {\r\ndev_err(dev, "The mode is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->lock);\r\nchip->prox_scheme = val;\r\nmutex_unlock(&chip->lock);\r\nreturn count;\r\n}\r\nstatic int isl29018_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nmutex_lock(&chip->lock);\r\nif (mask == IIO_CHAN_INFO_CALIBSCALE && chan->type == IIO_LIGHT) {\r\nchip->lux_scale = val;\r\nchip->lux_uscale = val2;\r\nret = 0;\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int isl29018_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret = -EINVAL;\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nmutex_lock(&chip->lock);\r\nif (chip->suspended) {\r\nmutex_unlock(&chip->lock);\r\nreturn -EBUSY;\r\n}\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = isl29018_read_lux(chip, val);\r\nbreak;\r\ncase IIO_INTENSITY:\r\nret = isl29018_read_ir(chip, val);\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nret = isl29018_read_proximity_ir(chip,\r\nchip->prox_scheme, val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!ret)\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = chip->lux_scale;\r\n*val2 = chip->lux_uscale;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int isl29035_detect(struct isl29018_chip *chip)\r\n{\r\nint status;\r\nunsigned int id;\r\nstatus = regmap_read(chip->regmap, ISL29035_REG_DEVICE_ID, &id);\r\nif (status < 0) {\r\ndev_err(chip->dev,\r\n"Error reading ID register with error %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nid = (id & ISL29035_DEVICE_ID_MASK) >> ISL29035_DEVICE_ID_SHIFT;\r\nif (id != ISL29035_DEVICE_ID)\r\nreturn -ENODEV;\r\nreturn regmap_update_bits(chip->regmap, ISL29035_REG_DEVICE_ID,\r\nISL29035_BOUT_MASK, 0);\r\n}\r\nstatic int isl29018_chip_init(struct isl29018_chip *chip)\r\n{\r\nint status;\r\nunsigned int new_adc_bit;\r\nunsigned int new_range;\r\nif (chip->type == isl29035) {\r\nstatus = isl29035_detect(chip);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_TEST, 0x0);\r\nif (status < 0) {\r\ndev_err(chip->dev, "Failed to clear isl29018 TEST reg.(%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1, 0);\r\nif (status < 0) {\r\ndev_err(chip->dev, "Failed to clear isl29018 CMD1 reg.(%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\nusleep_range(1000, 2000);\r\nstatus = isl29018_set_range(chip, chip->range, &new_range);\r\nif (status < 0) {\r\ndev_err(chip->dev, "Init of isl29018 fails\n");\r\nreturn status;\r\n}\r\nstatus = isl29018_set_resolution(chip, chip->adc_bit,\r\n&new_adc_bit);\r\nreturn 0;\r\n}\r\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ISL29018_REG_ADD_DATA_LSB:\r\ncase ISL29018_REG_ADD_DATA_MSB:\r\ncase ISL29018_REG_ADD_COMMAND1:\r\ncase ISL29018_REG_TEST:\r\ncase ISL29035_REG_DEVICE_ID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic const char *isl29018_match_acpi_device(struct device *dev, int *data)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\n*data = (int) id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic int isl29018_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct isl29018_chip *chip;\r\nstruct iio_dev *indio_dev;\r\nint err;\r\nconst char *name = NULL;\r\nint dev_id = 0;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (indio_dev == NULL) {\r\ndev_err(&client->dev, "iio allocation fails\n");\r\nreturn -ENOMEM;\r\n}\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nchip->dev = &client->dev;\r\nif (id) {\r\nname = id->name;\r\ndev_id = id->driver_data;\r\n}\r\nif (ACPI_HANDLE(&client->dev))\r\nname = isl29018_match_acpi_device(&client->dev, &dev_id);\r\nmutex_init(&chip->lock);\r\nchip->type = dev_id;\r\nchip->lux_scale = 1;\r\nchip->lux_uscale = 0;\r\nchip->range = 1000;\r\nchip->adc_bit = 16;\r\nchip->suspended = false;\r\nchip->regmap = devm_regmap_init_i2c(client,\r\nchip_info_tbl[dev_id].regmap_cfg);\r\nif (IS_ERR(chip->regmap)) {\r\nerr = PTR_ERR(chip->regmap);\r\ndev_err(chip->dev, "regmap initialization failed: %d\n", err);\r\nreturn err;\r\n}\r\nerr = isl29018_chip_init(chip);\r\nif (err)\r\nreturn err;\r\nindio_dev->info = chip_info_tbl[dev_id].indio_info;\r\nindio_dev->channels = chip_info_tbl[dev_id].channels;\r\nindio_dev->num_channels = chip_info_tbl[dev_id].num_channels;\r\nindio_dev->name = name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nerr = devm_iio_device_register(&client->dev, indio_dev);\r\nif (err) {\r\ndev_err(&client->dev, "iio registration fails\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isl29018_suspend(struct device *dev)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\r\nmutex_lock(&chip->lock);\r\nchip->suspended = true;\r\nmutex_unlock(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int isl29018_resume(struct device *dev)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\r\nint err;\r\nmutex_lock(&chip->lock);\r\nerr = isl29018_chip_init(chip);\r\nif (!err)\r\nchip->suspended = false;\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}
