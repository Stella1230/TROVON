void pi_write_regr(PIA * pi, int cont, int regr, int val)\r\n{\r\npi->proto->write_regr(pi, cont, regr, val);\r\n}\r\nint pi_read_regr(PIA * pi, int cont, int regr)\r\n{\r\nreturn pi->proto->read_regr(pi, cont, regr);\r\n}\r\nvoid pi_write_block(PIA * pi, char *buf, int count)\r\n{\r\npi->proto->write_block(pi, buf, count);\r\n}\r\nvoid pi_read_block(PIA * pi, char *buf, int count)\r\n{\r\npi->proto->read_block(pi, buf, count);\r\n}\r\nstatic void pi_wake_up(void *p)\r\n{\r\nPIA *pi = (PIA *) p;\r\nunsigned long flags;\r\nvoid (*cont) (void) = NULL;\r\nspin_lock_irqsave(&pi_spinlock, flags);\r\nif (pi->claim_cont && !parport_claim(pi->pardev)) {\r\ncont = pi->claim_cont;\r\npi->claim_cont = NULL;\r\npi->claimed = 1;\r\n}\r\nspin_unlock_irqrestore(&pi_spinlock, flags);\r\nwake_up(&(pi->parq));\r\nif (cont)\r\ncont();\r\n}\r\nint pi_schedule_claimed(PIA * pi, void (*cont) (void))\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pi_spinlock, flags);\r\nif (pi->pardev && parport_claim(pi->pardev)) {\r\npi->claim_cont = cont;\r\nspin_unlock_irqrestore(&pi_spinlock, flags);\r\nreturn 0;\r\n}\r\npi->claimed = 1;\r\nspin_unlock_irqrestore(&pi_spinlock, flags);\r\nreturn 1;\r\n}\r\nvoid pi_do_claimed(PIA * pi, void (*cont) (void))\r\n{\r\nif (pi_schedule_claimed(pi, cont))\r\ncont();\r\n}\r\nstatic void pi_claim(PIA * pi)\r\n{\r\nif (pi->claimed)\r\nreturn;\r\npi->claimed = 1;\r\nif (pi->pardev)\r\nwait_event(pi->parq,\r\n!parport_claim((struct pardevice *) pi->pardev));\r\n}\r\nstatic void pi_unclaim(PIA * pi)\r\n{\r\npi->claimed = 0;\r\nif (pi->pardev)\r\nparport_release((struct pardevice *) (pi->pardev));\r\n}\r\nvoid pi_connect(PIA * pi)\r\n{\r\npi_claim(pi);\r\npi->proto->connect(pi);\r\n}\r\nvoid pi_disconnect(PIA * pi)\r\n{\r\npi->proto->disconnect(pi);\r\npi_unclaim(pi);\r\n}\r\nstatic void pi_unregister_parport(PIA * pi)\r\n{\r\nif (pi->pardev) {\r\nparport_unregister_device((struct pardevice *) (pi->pardev));\r\npi->pardev = NULL;\r\n}\r\n}\r\nvoid pi_release(PIA * pi)\r\n{\r\npi_unregister_parport(pi);\r\nif (pi->proto->release_proto)\r\npi->proto->release_proto(pi);\r\nmodule_put(pi->proto->owner);\r\n}\r\nstatic int default_test_proto(PIA * pi, char *scratch, int verbose)\r\n{\r\nint j, k;\r\nint e[2] = { 0, 0 };\r\npi->proto->connect(pi);\r\nfor (j = 0; j < 2; j++) {\r\npi_write_regr(pi, 0, 6, 0xa0 + j * 0x10);\r\nfor (k = 0; k < 256; k++) {\r\npi_write_regr(pi, 0, 2, k ^ 0xaa);\r\npi_write_regr(pi, 0, 3, k ^ 0x55);\r\nif (pi_read_regr(pi, 0, 2) != (k ^ 0xaa))\r\ne[j]++;\r\n}\r\n}\r\npi->proto->disconnect(pi);\r\nif (verbose)\r\nprintk("%s: %s: port 0x%x, mode %d, test=(%d,%d)\n",\r\npi->device, pi->proto->name, pi->port,\r\npi->mode, e[0], e[1]);\r\nreturn (e[0] && e[1]);\r\n}\r\nstatic int pi_test_proto(PIA * pi, char *scratch, int verbose)\r\n{\r\nint res;\r\npi_claim(pi);\r\nif (pi->proto->test_proto)\r\nres = pi->proto->test_proto(pi, scratch, verbose);\r\nelse\r\nres = default_test_proto(pi, scratch, verbose);\r\npi_unclaim(pi);\r\nreturn res;\r\n}\r\nint paride_register(PIP * pr)\r\n{\r\nint k;\r\nfor (k = 0; k < MAX_PROTOS; k++)\r\nif (protocols[k] && !strcmp(pr->name, protocols[k]->name)) {\r\nprintk("paride: %s protocol already registered\n",\r\npr->name);\r\nreturn -1;\r\n}\r\nk = 0;\r\nwhile ((k < MAX_PROTOS) && (protocols[k]))\r\nk++;\r\nif (k == MAX_PROTOS) {\r\nprintk("paride: protocol table full\n");\r\nreturn -1;\r\n}\r\nprotocols[k] = pr;\r\npr->index = k;\r\nprintk("paride: %s registered as protocol %d\n", pr->name, k);\r\nreturn 0;\r\n}\r\nvoid paride_unregister(PIP * pr)\r\n{\r\nif (!pr)\r\nreturn;\r\nif (protocols[pr->index] != pr) {\r\nprintk("paride: %s not registered\n", pr->name);\r\nreturn;\r\n}\r\nprotocols[pr->index] = NULL;\r\n}\r\nstatic int pi_register_parport(PIA * pi, int verbose)\r\n{\r\nstruct parport *port;\r\nport = parport_find_base(pi->port);\r\nif (!port)\r\nreturn 0;\r\npi->pardev = parport_register_device(port,\r\npi->device, NULL,\r\npi_wake_up, NULL, 0, (void *) pi);\r\nparport_put_port(port);\r\nif (!pi->pardev)\r\nreturn 0;\r\ninit_waitqueue_head(&pi->parq);\r\nif (verbose)\r\nprintk("%s: 0x%x is %s\n", pi->device, pi->port, port->name);\r\npi->parname = (char *) port->name;\r\nreturn 1;\r\n}\r\nstatic int pi_probe_mode(PIA * pi, int max, char *scratch, int verbose)\r\n{\r\nint best, range;\r\nif (pi->mode != -1) {\r\nif (pi->mode >= max)\r\nreturn 0;\r\nrange = 3;\r\nif (pi->mode >= pi->proto->epp_first)\r\nrange = 8;\r\nif ((range == 8) && (pi->port % 8))\r\nreturn 0;\r\npi->reserved = range;\r\nreturn (!pi_test_proto(pi, scratch, verbose));\r\n}\r\nbest = -1;\r\nfor (pi->mode = 0; pi->mode < max; pi->mode++) {\r\nrange = 3;\r\nif (pi->mode >= pi->proto->epp_first)\r\nrange = 8;\r\nif ((range == 8) && (pi->port % 8))\r\nbreak;\r\npi->reserved = range;\r\nif (!pi_test_proto(pi, scratch, verbose))\r\nbest = pi->mode;\r\n}\r\npi->mode = best;\r\nreturn (best > -1);\r\n}\r\nstatic int pi_probe_unit(PIA * pi, int unit, char *scratch, int verbose)\r\n{\r\nint max, s, e;\r\ns = unit;\r\ne = s + 1;\r\nif (s == -1) {\r\ns = 0;\r\ne = pi->proto->max_units;\r\n}\r\nif (!pi_register_parport(pi, verbose))\r\nreturn 0;\r\nif (pi->proto->test_port) {\r\npi_claim(pi);\r\nmax = pi->proto->test_port(pi);\r\npi_unclaim(pi);\r\n} else\r\nmax = pi->proto->max_mode;\r\nif (pi->proto->probe_unit) {\r\npi_claim(pi);\r\nfor (pi->unit = s; pi->unit < e; pi->unit++)\r\nif (pi->proto->probe_unit(pi)) {\r\npi_unclaim(pi);\r\nif (pi_probe_mode(pi, max, scratch, verbose))\r\nreturn 1;\r\npi_unregister_parport(pi);\r\nreturn 0;\r\n}\r\npi_unclaim(pi);\r\npi_unregister_parport(pi);\r\nreturn 0;\r\n}\r\nif (!pi_probe_mode(pi, max, scratch, verbose)) {\r\npi_unregister_parport(pi);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint pi_init(PIA * pi, int autoprobe, int port, int mode,\r\nint unit, int protocol, int delay, char *scratch,\r\nint devtype, int verbose, char *device)\r\n{\r\nint p, k, s, e;\r\nint lpts[7] = { 0x3bc, 0x378, 0x278, 0x268, 0x27c, 0x26c, 0 };\r\ns = protocol;\r\ne = s + 1;\r\nif (!protocols[0])\r\nrequest_module("paride_protocol");\r\nif (autoprobe) {\r\ns = 0;\r\ne = MAX_PROTOS;\r\n} else if ((s < 0) || (s >= MAX_PROTOS) || (port <= 0) ||\r\n(!protocols[s]) || (unit < 0) ||\r\n(unit >= protocols[s]->max_units)) {\r\nprintk("%s: Invalid parameters\n", device);\r\nreturn 0;\r\n}\r\nfor (p = s; p < e; p++) {\r\nstruct pi_protocol *proto = protocols[p];\r\nif (!proto)\r\ncontinue;\r\nif (!try_module_get(proto->owner))\r\ncontinue;\r\npi->proto = proto;\r\npi->private = 0;\r\nif (proto->init_proto && proto->init_proto(pi) < 0) {\r\npi->proto = NULL;\r\nmodule_put(proto->owner);\r\ncontinue;\r\n}\r\nif (delay == -1)\r\npi->delay = pi->proto->default_delay;\r\nelse\r\npi->delay = delay;\r\npi->devtype = devtype;\r\npi->device = device;\r\npi->parname = NULL;\r\npi->pardev = NULL;\r\ninit_waitqueue_head(&pi->parq);\r\npi->claimed = 0;\r\npi->claim_cont = NULL;\r\npi->mode = mode;\r\nif (port != -1) {\r\npi->port = port;\r\nif (pi_probe_unit(pi, unit, scratch, verbose))\r\nbreak;\r\npi->port = 0;\r\n} else {\r\nk = 0;\r\nwhile ((pi->port = lpts[k++]))\r\nif (pi_probe_unit\r\n(pi, unit, scratch, verbose))\r\nbreak;\r\nif (pi->port)\r\nbreak;\r\n}\r\nif (pi->proto->release_proto)\r\npi->proto->release_proto(pi);\r\nmodule_put(proto->owner);\r\n}\r\nif (!pi->port) {\r\nif (autoprobe)\r\nprintk("%s: Autoprobe failed\n", device);\r\nelse\r\nprintk("%s: Adapter not found\n", device);\r\nreturn 0;\r\n}\r\nif (pi->parname)\r\nprintk("%s: Sharing %s at 0x%x\n", pi->device,\r\npi->parname, pi->port);\r\npi->proto->log_adapter(pi, scratch, verbose);\r\nreturn 1;\r\n}
