static inline int alloc_level(int cpu, int irq)\r\n{\r\nstruct hub_data *hub = hub_data(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nint level;\r\nlevel = find_first_zero_bit(hub->irq_alloc_mask, LEVELS_PER_SLICE);\r\nif (level >= LEVELS_PER_SLICE)\r\npanic("Cpu %d flooded with devices", cpu);\r\n__set_bit(level, hub->irq_alloc_mask);\r\nsi->level_to_irq[level] = irq;\r\nreturn level;\r\n}\r\nstatic inline int find_level(cpuid_t *cpunum, int irq)\r\n{\r\nint cpu, i;\r\nfor_each_online_cpu(cpu) {\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nfor (i = BASE_PCI_IRQ; i < LEVELS_PER_SLICE; i++)\r\nif (si->level_to_irq[i] == irq) {\r\n*cpunum = cpu;\r\nreturn i;\r\n}\r\n}\r\npanic("Could not identify cpu/level for irq %d", irq);\r\n}\r\nstatic int intr_connect_level(int cpu, int bit)\r\n{\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nset_bit(bit, si->irq_enable_mask);\r\nif (!cputoslice(cpu)) {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int intr_disconnect_level(int cpu, int bit)\r\n{\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nclear_bit(bit, si->irq_enable_mask);\r\nif (!cputoslice(cpu)) {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int startup_bridge_irq(struct irq_data *d)\r\n{\r\nstruct bridge_controller *bc;\r\nbridgereg_t device;\r\nbridge_t *bridge;\r\nint pin, swlevel;\r\ncpuid_t cpu;\r\npin = SLOT_FROM_PCI_IRQ(d->irq);\r\nbc = IRQ_TO_BRIDGE(d->irq);\r\nbridge = bc->base;\r\npr_debug("bridge_startup(): irq= 0x%x pin=%d\n", d->irq, pin);\r\nswlevel = find_level(&cpu, d->irq);\r\nbridge->b_int_addr[pin].addr = (0x20000 | swlevel | (bc->nasid << 8));\r\nbridge->b_int_enable |= (1 << pin);\r\nbridge->b_int_enable |= 0x7ffffe00;\r\nbridge->b_int_mode |= (1UL << pin);\r\ndevice = bridge->b_int_device;\r\ndevice &= ~(7 << (pin*3));\r\ndevice |= (pin << (pin*3));\r\nbridge->b_int_device = device;\r\nbridge->b_wid_tflush;\r\nintr_connect_level(cpu, swlevel);\r\nreturn 0;\r\n}\r\nstatic void shutdown_bridge_irq(struct irq_data *d)\r\n{\r\nstruct bridge_controller *bc = IRQ_TO_BRIDGE(d->irq);\r\nbridge_t *bridge = bc->base;\r\nint pin, swlevel;\r\ncpuid_t cpu;\r\npr_debug("bridge_shutdown: irq 0x%x\n", d->irq);\r\npin = SLOT_FROM_PCI_IRQ(d->irq);\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_disconnect_level(cpu, swlevel);\r\nbridge->b_int_enable &= ~(1 << pin);\r\nbridge->b_wid_tflush;\r\n}\r\nstatic inline void enable_bridge_irq(struct irq_data *d)\r\n{\r\ncpuid_t cpu;\r\nint swlevel;\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_connect_level(cpu, swlevel);\r\n}\r\nstatic inline void disable_bridge_irq(struct irq_data *d)\r\n{\r\ncpuid_t cpu;\r\nint swlevel;\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_disconnect_level(cpu, swlevel);\r\n}\r\nvoid register_bridge_irq(unsigned int irq)\r\n{\r\nirq_set_chip_and_handler(irq, &bridge_irq_type, handle_level_irq);\r\n}\r\nint request_bridge_irq(struct bridge_controller *bc)\r\n{\r\nint irq = allocate_irqno();\r\nint swlevel, cpu;\r\nnasid_t nasid;\r\nif (irq < 0)\r\nreturn irq;\r\ncpu = bc->irq_cpu;\r\nswlevel = alloc_level(cpu, irq);\r\nif (unlikely(swlevel < 0)) {\r\nfree_irqno(irq);\r\nreturn -EAGAIN;\r\n}\r\nnasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nREMOTE_HUB_CLR_INTR(nasid, swlevel);\r\nintr_connect_level(cpu, swlevel);\r\nregister_bridge_irq(irq);\r\nreturn irq;\r\n}
