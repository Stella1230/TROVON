static int ad5933_i2c_write(struct i2c_client *client,\r\nu8 reg, u8 len, u8 *data)\r\n{\r\nint ret;\r\nwhile (len--) {\r\nret = i2c_smbus_write_byte_data(client, reg++, *data++);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "I2C write error\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5933_i2c_read(struct i2c_client *client,\r\nu8 reg, u8 len, u8 *data)\r\n{\r\nint ret;\r\nwhile (len--) {\r\nret = i2c_smbus_read_byte_data(client, reg++);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "I2C read error\n");\r\nreturn ret;\r\n}\r\n*data++ = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5933_cmd(struct ad5933_state *st, unsigned char cmd)\r\n{\r\nunsigned char dat = st->ctrl_hb | cmd;\r\nreturn ad5933_i2c_write(st->client,\r\nAD5933_REG_CONTROL_HB, 1, &dat);\r\n}\r\nstatic int ad5933_reset(struct ad5933_state *st)\r\n{\r\nunsigned char dat = st->ctrl_lb | AD5933_CTRL_RESET;\r\nreturn ad5933_i2c_write(st->client,\r\nAD5933_REG_CONTROL_LB, 1, &dat);\r\n}\r\nstatic int ad5933_wait_busy(struct ad5933_state *st, unsigned char event)\r\n{\r\nunsigned char val, timeout = AD5933_MAX_RETRIES;\r\nint ret;\r\nwhile (timeout--) {\r\nret = ad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & event)\r\nreturn val;\r\ncpu_relax();\r\nmdelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int ad5933_set_freq(struct ad5933_state *st,\r\nunsigned reg, unsigned long freq)\r\n{\r\nunsigned long long freqreg;\r\nunion {\r\n__be32 d32;\r\nu8 d8[4];\r\n} dat;\r\nfreqreg = (u64) freq * (u64) (1 << 27);\r\ndo_div(freqreg, st->mclk_hz / 4);\r\nswitch (reg) {\r\ncase AD5933_REG_FREQ_START:\r\nst->freq_start = freq;\r\nbreak;\r\ncase AD5933_REG_FREQ_INC:\r\nst->freq_inc = freq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndat.d32 = cpu_to_be32(freqreg);\r\nreturn ad5933_i2c_write(st->client, reg, 3, &dat.d8[1]);\r\n}\r\nstatic int ad5933_setup(struct ad5933_state *st)\r\n{\r\n__be16 dat;\r\nint ret;\r\nret = ad5933_reset(st);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad5933_set_freq(st, AD5933_REG_FREQ_START, 10000);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad5933_set_freq(st, AD5933_REG_FREQ_INC, 200);\r\nif (ret < 0)\r\nreturn ret;\r\nst->settling_cycles = 10;\r\ndat = cpu_to_be16(st->settling_cycles);\r\nret = ad5933_i2c_write(st->client,\r\nAD5933_REG_SETTLING_CYCLES, 2, (u8 *)&dat);\r\nif (ret < 0)\r\nreturn ret;\r\nst->freq_points = 100;\r\ndat = cpu_to_be16(st->freq_points);\r\nreturn ad5933_i2c_write(st->client, AD5933_REG_INC_NUM, 2, (u8 *)&dat);\r\n}\r\nstatic void ad5933_calc_out_ranges(struct ad5933_state *st)\r\n{\r\nint i;\r\nunsigned normalized_3v3[4] = {1980, 198, 383, 970};\r\nfor (i = 0; i < 4; i++)\r\nst->range_avail[i] = normalized_3v3[i] * st->vref_mv / 3300;\r\n}\r\nstatic ssize_t ad5933_show_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nunsigned long long freqreg;\r\nunion {\r\n__be32 d32;\r\nu8 d8[4];\r\n} dat;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5933_i2c_read(st->client, this_attr->address, 3, &dat.d8[1]);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\nfreqreg = be32_to_cpu(dat.d32) & 0xFFFFFF;\r\nfreqreg = (u64) freqreg * (u64) (st->mclk_hz / 4);\r\ndo_div(freqreg, 1 << 27);\r\nreturn sprintf(buf, "%d\n", (int) freqreg);\r\n}\r\nstatic ssize_t ad5933_store_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val > AD5933_MAX_OUTPUT_FREQ_Hz)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5933_set_freq(st, this_attr->address, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t ad5933_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret = 0, len = 0;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32) this_attr->address) {\r\ncase AD5933_OUT_RANGE:\r\nlen = sprintf(buf, "%d\n",\r\nst->range_avail[(st->ctrl_hb >> 1) & 0x3]);\r\nbreak;\r\ncase AD5933_OUT_RANGE_AVAIL:\r\nlen = sprintf(buf, "%d %d %d %d\n", st->range_avail[0],\r\nst->range_avail[3], st->range_avail[2],\r\nst->range_avail[1]);\r\nbreak;\r\ncase AD5933_OUT_SETTLING_CYCLES:\r\nlen = sprintf(buf, "%d\n", st->settling_cycles);\r\nbreak;\r\ncase AD5933_IN_PGA_GAIN:\r\nlen = sprintf(buf, "%s\n",\r\n(st->ctrl_hb & AD5933_CTRL_PGA_GAIN_1) ?\r\n"1" : "0.2");\r\nbreak;\r\ncase AD5933_IN_PGA_GAIN_AVAIL:\r\nlen = sprintf(buf, "1 0.2\n");\r\nbreak;\r\ncase AD5933_FREQ_POINTS:\r\nlen = sprintf(buf, "%d\n", st->freq_points);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t ad5933_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nu16 val;\r\nint i, ret = 0;\r\n__be16 dat;\r\nif (this_attr->address != AD5933_IN_PGA_GAIN) {\r\nret = kstrtou16(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32) this_attr->address) {\r\ncase AD5933_OUT_RANGE:\r\nfor (i = 0; i < 4; i++)\r\nif (val == st->range_avail[i]) {\r\nst->ctrl_hb &= ~AD5933_CTRL_RANGE(0x3);\r\nst->ctrl_hb |= AD5933_CTRL_RANGE(i);\r\nret = ad5933_cmd(st, 0);\r\nbreak;\r\n}\r\nret = -EINVAL;\r\nbreak;\r\ncase AD5933_IN_PGA_GAIN:\r\nif (sysfs_streq(buf, "1")) {\r\nst->ctrl_hb |= AD5933_CTRL_PGA_GAIN_1;\r\n} else if (sysfs_streq(buf, "0.2")) {\r\nst->ctrl_hb &= ~AD5933_CTRL_PGA_GAIN_1;\r\n} else {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = ad5933_cmd(st, 0);\r\nbreak;\r\ncase AD5933_OUT_SETTLING_CYCLES:\r\nval = clamp(val, (u16)0, (u16)0x7FF);\r\nst->settling_cycles = val;\r\nif (val > 511)\r\nval = (val >> 1) | (1 << 9);\r\nelse if (val > 1022)\r\nval = (val >> 2) | (3 << 9);\r\ndat = cpu_to_be16(val);\r\nret = ad5933_i2c_write(st->client,\r\nAD5933_REG_SETTLING_CYCLES, 2, (u8 *)&dat);\r\nbreak;\r\ncase AD5933_FREQ_POINTS:\r\nval = clamp(val, (u16)0, (u16)511);\r\nst->freq_points = val;\r\ndat = cpu_to_be16(val);\r\nret = ad5933_i2c_write(st->client, AD5933_REG_INC_NUM, 2,\r\n(u8 *)&dat);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int ad5933_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\n__be16 dat;\r\nint ret = -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nif (iio_buffer_enabled(indio_dev)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = ad5933_cmd(st, AD5933_CTRL_MEASURE_TEMP);\r\nif (ret < 0)\r\ngoto out;\r\nret = ad5933_wait_busy(st, AD5933_STAT_TEMP_VALID);\r\nif (ret < 0)\r\ngoto out;\r\nret = ad5933_i2c_read(st->client,\r\nAD5933_REG_TEMP_DATA, 2,\r\n(u8 *)&dat);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_unlock(&indio_dev->mlock);\r\nret = be16_to_cpu(dat);\r\nif (ret < 8192)\r\n*val = ret * 1000 / 32;\r\nelse\r\n*val = (ret - 16384) * 1000 / 32;\r\nreturn IIO_VAL_INT;\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5933_ring_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nint ret;\r\nif (bitmap_empty(indio_dev->active_scan_mask, indio_dev->masklength))\r\nreturn -EINVAL;\r\nret = ad5933_reset(st);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad5933_cmd(st, AD5933_CTRL_STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad5933_cmd(st, AD5933_CTRL_INIT_START_FREQ);\r\nif (ret < 0)\r\nreturn ret;\r\nst->state = AD5933_CTRL_INIT_START_FREQ;\r\nreturn 0;\r\n}\r\nstatic int ad5933_ring_postenable(struct iio_dev *indio_dev)\r\n{\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\nschedule_delayed_work(&st->work,\r\nmsecs_to_jiffies(AD5933_INIT_EXCITATION_TIME_ms));\r\nreturn 0;\r\n}\r\nstatic int ad5933_ring_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\ncancel_delayed_work_sync(&st->work);\r\nreturn ad5933_cmd(st, AD5933_CTRL_POWER_DOWN);\r\n}\r\nstatic int ad5933_register_ring_funcs_and_init(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_buffer *buffer;\r\nbuffer = iio_kfifo_allocate(indio_dev);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\niio_device_attach_buffer(indio_dev, buffer);\r\nindio_dev->setup_ops = &ad5933_ring_setup_ops;\r\nindio_dev->modes |= INDIO_BUFFER_HARDWARE;\r\nreturn 0;\r\n}\r\nstatic void ad5933_work(struct work_struct *work)\r\n{\r\nstruct ad5933_state *st = container_of(work,\r\nstruct ad5933_state, work.work);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(st->client);\r\nsigned short buf[2];\r\nunsigned char status;\r\nmutex_lock(&indio_dev->mlock);\r\nif (st->state == AD5933_CTRL_INIT_START_FREQ) {\r\nad5933_cmd(st, AD5933_CTRL_START_SWEEP);\r\nst->state = AD5933_CTRL_START_SWEEP;\r\nschedule_delayed_work(&st->work, st->poll_time_jiffies);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn;\r\n}\r\nad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &status);\r\nif (status & AD5933_STAT_DATA_VALID) {\r\nint scan_count = bitmap_weight(indio_dev->active_scan_mask,\r\nindio_dev->masklength);\r\nad5933_i2c_read(st->client,\r\ntest_bit(1, indio_dev->active_scan_mask) ?\r\nAD5933_REG_REAL_DATA : AD5933_REG_IMAG_DATA,\r\nscan_count * 2, (u8 *)buf);\r\nif (scan_count == 2) {\r\nbuf[0] = be16_to_cpu(buf[0]);\r\nbuf[1] = be16_to_cpu(buf[1]);\r\n} else {\r\nbuf[0] = be16_to_cpu(buf[0]);\r\n}\r\niio_push_to_buffers(indio_dev, buf);\r\n} else {\r\nschedule_delayed_work(&st->work, st->poll_time_jiffies);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn;\r\n}\r\nif (status & AD5933_STAT_SWEEP_DONE) {\r\nad5933_cmd(st, AD5933_CTRL_POWER_DOWN);\r\n} else {\r\nad5933_cmd(st, AD5933_CTRL_INC_FREQ);\r\nschedule_delayed_work(&st->work, st->poll_time_jiffies);\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\n}\r\nstatic int ad5933_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret, voltage_uv = 0;\r\nstruct ad5933_platform_data *pdata = client->dev.platform_data;\r\nstruct ad5933_state *st;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nst->client = client;\r\nif (!pdata)\r\nst->pdata = &ad5933_default_pdata;\r\nelse\r\nst->pdata = pdata;\r\nst->reg = devm_regulator_get(&client->dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\nvoltage_uv = regulator_get_voltage(st->reg);\r\n}\r\nif (voltage_uv)\r\nst->vref_mv = voltage_uv / 1000;\r\nelse\r\nst->vref_mv = st->pdata->vref_mv;\r\nif (st->pdata->ext_clk_Hz) {\r\nst->mclk_hz = st->pdata->ext_clk_Hz;\r\nst->ctrl_lb = AD5933_CTRL_EXT_SYSCLK;\r\n} else {\r\nst->mclk_hz = AD5933_INT_OSC_FREQ_Hz;\r\nst->ctrl_lb = AD5933_CTRL_INT_SYSCLK;\r\n}\r\nad5933_calc_out_ranges(st);\r\nINIT_DELAYED_WORK(&st->work, ad5933_work);\r\nst->poll_time_jiffies = msecs_to_jiffies(AD5933_POLL_TIME_ms);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ad5933_info;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = ad5933_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad5933_channels);\r\nret = ad5933_register_ring_funcs_and_init(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = iio_buffer_register(indio_dev, ad5933_channels,\r\nARRAY_SIZE(ad5933_channels));\r\nif (ret)\r\ngoto error_unreg_ring;\r\niio_scan_mask_set(indio_dev, indio_dev->buffer, 0);\r\niio_scan_mask_set(indio_dev, indio_dev->buffer, 1);\r\nret = ad5933_setup(st);\r\nif (ret)\r\ngoto error_uninitialize_ring;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_uninitialize_ring;\r\nreturn 0;\r\nerror_uninitialize_ring:\r\niio_buffer_unregister(indio_dev);\r\nerror_unreg_ring:\r\niio_kfifo_free(indio_dev->buffer);\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int ad5933_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ad5933_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_buffer_unregister(indio_dev);\r\niio_kfifo_free(indio_dev->buffer);\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
