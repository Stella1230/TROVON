static int msmfb_open(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int msmfb_release(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic void msmfb_handle_dma_interrupt(struct msmfb_callback *callback)\r\n{\r\nunsigned long irq_flags;\r\nstruct msmfb_info *msmfb = container_of(callback, struct msmfb_info,\r\ndma_callback);\r\nspin_lock_irqsave(&msmfb->update_lock, irq_flags);\r\nmsmfb->frame_done = msmfb->frame_requested;\r\nif (msmfb->sleeping == UPDATING &&\r\nmsmfb->frame_done == msmfb->update_frame) {\r\nDLOG(SUSPEND_RESUME, "full update completed\n");\r\nschedule_work(&msmfb->resume_work);\r\n}\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nwake_up(&msmfb->frame_wq);\r\n}\r\nstatic int msmfb_start_dma(struct msmfb_info *msmfb)\r\n{\r\nuint32_t x, y, w, h;\r\nunsigned addr;\r\nunsigned long irq_flags;\r\nuint32_t yoffset;\r\ns64 time_since_request;\r\nstruct msm_panel_data *panel = msmfb->panel;\r\nspin_lock_irqsave(&msmfb->update_lock, irq_flags);\r\ntime_since_request = ktime_to_ns(ktime_sub(ktime_get(),\r\nmsmfb->vsync_request_time));\r\nif (time_since_request > 20 * NSEC_PER_MSEC) {\r\nuint32_t us;\r\nus = do_div(time_since_request, NSEC_PER_MSEC) / NSEC_PER_USEC;\r\nprintk(KERN_WARNING "msmfb_start_dma %lld.%03u ms after vsync "\r\n"request\n", time_since_request, us);\r\n}\r\nif (msmfb->frame_done == msmfb->frame_requested) {\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nreturn -1;\r\n}\r\nif (msmfb->sleeping == SLEEPING) {\r\nDLOG(SUSPEND_RESUME, "tried to start dma while asleep\n");\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nreturn -1;\r\n}\r\nx = msmfb->update_info.left;\r\ny = msmfb->update_info.top;\r\nw = msmfb->update_info.eright - x;\r\nh = msmfb->update_info.ebottom - y;\r\nyoffset = msmfb->yoffset;\r\nmsmfb->update_info.left = msmfb->xres + 1;\r\nmsmfb->update_info.top = msmfb->yres + 1;\r\nmsmfb->update_info.eright = 0;\r\nmsmfb->update_info.ebottom = 0;\r\nif (unlikely(w > msmfb->xres || h > msmfb->yres ||\r\nw == 0 || h == 0)) {\r\nprintk(KERN_INFO "invalid update: %d %d %d "\r\n"%d\n", x, y, w, h);\r\nmsmfb->frame_done = msmfb->frame_requested;\r\ngoto error;\r\n}\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\naddr = ((msmfb->xres * (yoffset + y) + x) * 2);\r\nmdp->dma(mdp, addr + msmfb->fb->fix.smem_start,\r\nmsmfb->xres * 2, w, h, x, y, &msmfb->dma_callback,\r\npanel->interface_type);\r\nreturn 0;\r\nerror:\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nif (panel->clear_vsync)\r\npanel->clear_vsync(panel);\r\nwake_up(&msmfb->frame_wq);\r\nreturn 0;\r\n}\r\nstatic void msmfb_handle_vsync_interrupt(struct msmfb_callback *callback)\r\n{\r\nstruct msmfb_info *msmfb = container_of(callback, struct msmfb_info,\r\nvsync_callback);\r\nmsmfb_start_dma(msmfb);\r\n}\r\nstatic enum hrtimer_restart msmfb_fake_vsync(struct hrtimer *timer)\r\n{\r\nstruct msmfb_info *msmfb = container_of(timer, struct msmfb_info,\r\nfake_vsync);\r\nmsmfb_start_dma(msmfb);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void msmfb_pan_update(struct fb_info *info, uint32_t left, uint32_t top,\r\nuint32_t eright, uint32_t ebottom,\r\nuint32_t yoffset, int pan_display)\r\n{\r\nstruct msmfb_info *msmfb = info->par;\r\nstruct msm_panel_data *panel = msmfb->panel;\r\nunsigned long irq_flags;\r\nint sleeping;\r\nint retry = 1;\r\nDLOG(SHOW_UPDATES, "update %d %d %d %d %d %d\n",\r\nleft, top, eright, ebottom, yoffset, pan_display);\r\nrestart:\r\nspin_lock_irqsave(&msmfb->update_lock, irq_flags);\r\nif (msmfb->sleeping == SLEEPING) {\r\nDLOG(SUSPEND_RESUME, "drawing while asleep\n");\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nif (pan_display)\r\nwait_event_interruptible_timeout(msmfb->frame_wq,\r\nmsmfb->sleeping != SLEEPING, HZ/10);\r\nreturn;\r\n}\r\nsleeping = msmfb->sleeping;\r\nif ((pan_display && msmfb->frame_requested != msmfb->frame_done) ||\r\nsleeping == UPDATING) {\r\nint ret;\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nret = wait_event_interruptible_timeout(msmfb->frame_wq,\r\nmsmfb->frame_done == msmfb->frame_requested &&\r\nmsmfb->sleeping != UPDATING, 5 * HZ);\r\nif (ret <= 0 && (msmfb->frame_requested != msmfb->frame_done ||\r\nmsmfb->sleeping == UPDATING)) {\r\nif (retry && panel->request_vsync &&\r\n(sleeping == AWAKE)) {\r\npanel->request_vsync(panel,\r\n&msmfb->vsync_callback);\r\nretry = 0;\r\nprintk(KERN_WARNING "msmfb_pan_display timeout "\r\n"rerequest vsync\n");\r\n} else {\r\nprintk(KERN_WARNING "msmfb_pan_display timeout "\r\n"waiting for frame start, %d %d\n",\r\nmsmfb->frame_requested,\r\nmsmfb->frame_done);\r\nreturn;\r\n}\r\n}\r\ngoto restart;\r\n}\r\nmsmfb->frame_requested++;\r\nif (pan_display) {\r\nmsmfb->yoffset = yoffset;\r\nif (left == 0 && top == 0 && eright == info->var.xres &&\r\nebottom == info->var.yres) {\r\nif (sleeping == WAKING) {\r\nmsmfb->update_frame = msmfb->frame_requested;\r\nDLOG(SUSPEND_RESUME, "full update starting\n");\r\nmsmfb->sleeping = UPDATING;\r\n}\r\n}\r\n}\r\nif (left < msmfb->update_info.left)\r\nmsmfb->update_info.left = left;\r\nif (top < msmfb->update_info.top)\r\nmsmfb->update_info.top = top;\r\nif (eright > msmfb->update_info.eright)\r\nmsmfb->update_info.eright = eright;\r\nif (ebottom > msmfb->update_info.ebottom)\r\nmsmfb->update_info.ebottom = ebottom;\r\nDLOG(SHOW_UPDATES, "update queued %d %d %d %d %d\n",\r\nmsmfb->update_info.left, msmfb->update_info.top,\r\nmsmfb->update_info.eright, msmfb->update_info.ebottom,\r\nmsmfb->yoffset);\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\nmsmfb->vsync_request_time = ktime_get();\r\nif (panel->request_vsync && (sleeping == AWAKE)) {\r\npanel->request_vsync(panel, &msmfb->vsync_callback);\r\n} else {\r\nif (!hrtimer_active(&msmfb->fake_vsync)) {\r\nhrtimer_start(&msmfb->fake_vsync,\r\nktime_set(0, NSEC_PER_SEC/60),\r\nHRTIMER_MODE_REL);\r\n}\r\n}\r\n}\r\nstatic void msmfb_update(struct fb_info *info, uint32_t left, uint32_t top,\r\nuint32_t eright, uint32_t ebottom)\r\n{\r\nmsmfb_pan_update(info, left, top, eright, ebottom, 0, 0);\r\n}\r\nstatic void power_on_panel(struct work_struct *work)\r\n{\r\nstruct msmfb_info *msmfb =\r\ncontainer_of(work, struct msmfb_info, resume_work);\r\nstruct msm_panel_data *panel = msmfb->panel;\r\nunsigned long irq_flags;\r\nmutex_lock(&msmfb->panel_init_lock);\r\nDLOG(SUSPEND_RESUME, "turning on panel\n");\r\nif (msmfb->sleeping == UPDATING) {\r\nif (panel->unblank(panel)) {\r\nprintk(KERN_INFO "msmfb: panel unblank failed,"\r\n"not starting drawing\n");\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&msmfb->update_lock, irq_flags);\r\nmsmfb->sleeping = AWAKE;\r\nwake_up(&msmfb->frame_wq);\r\nspin_unlock_irqrestore(&msmfb->update_lock, irq_flags);\r\n}\r\nerror:\r\nmutex_unlock(&msmfb->panel_init_lock);\r\n}\r\nstatic int msmfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif ((var->xres != info->var.xres) ||\r\n(var->yres != info->var.yres) ||\r\n(var->xres_virtual != info->var.xres_virtual) ||\r\n(var->yres_virtual != info->var.yres_virtual) ||\r\n(var->xoffset != info->var.xoffset) ||\r\n(var->bits_per_pixel != info->var.bits_per_pixel) ||\r\n(var->grayscale != info->var.grayscale))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint msmfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct msmfb_info *msmfb = info->par;\r\nstruct msm_panel_data *panel = msmfb->panel;\r\nif ((panel->caps & MSMFB_CAP_PARTIAL_UPDATES) &&\r\n(var->reserved[0] == 0x54445055)) {\r\nmsmfb_pan_update(info, var->reserved[1] & 0xffff,\r\nvar->reserved[1] >> 16,\r\nvar->reserved[2] & 0xffff,\r\nvar->reserved[2] >> 16, var->yoffset, 1);\r\n} else {\r\nmsmfb_pan_update(info, 0, 0, info->var.xres, info->var.yres,\r\nvar->yoffset, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void msmfb_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\r\n{\r\ncfb_fillrect(p, rect);\r\nmsmfb_update(p, rect->dx, rect->dy, rect->dx + rect->width,\r\nrect->dy + rect->height);\r\n}\r\nstatic void msmfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\r\n{\r\ncfb_copyarea(p, area);\r\nmsmfb_update(p, area->dx, area->dy, area->dx + area->width,\r\narea->dy + area->height);\r\n}\r\nstatic void msmfb_imageblit(struct fb_info *p, const struct fb_image *image)\r\n{\r\ncfb_imageblit(p, image);\r\nmsmfb_update(p, image->dx, image->dy, image->dx + image->width,\r\nimage->dy + image->height);\r\n}\r\nstatic int msmfb_blit(struct fb_info *info,\r\nvoid __user *p)\r\n{\r\nstruct mdp_blit_req req;\r\nstruct mdp_blit_req_list req_list;\r\nint i;\r\nint ret;\r\nif (copy_from_user(&req_list, p, sizeof(req_list)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < req_list.count; i++) {\r\nstruct mdp_blit_req_list *list =\r\n(struct mdp_blit_req_list *)p;\r\nif (copy_from_user(&req, &list->req[i], sizeof(req)))\r\nreturn -EFAULT;\r\nret = mdp->blit(mdp, info, &req);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msmfb_ioctl(struct fb_info *p, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nswitch (cmd) {\r\ncase MSMFB_GRP_DISP:\r\nmdp->set_grp_disp(mdp, arg);\r\nbreak;\r\ncase MSMFB_BLIT:\r\nret = msmfb_blit(p, argp);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "msmfb unknown ioctl: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void setup_fb_info(struct msmfb_info *msmfb)\r\n{\r\nstruct fb_info *fb_info = msmfb->fb;\r\nint r;\r\nstrncpy(fb_info->fix.id, "msmfb", 16);\r\nfb_info->fix.ypanstep = 1;\r\nfb_info->fbops = &msmfb_ops;\r\nfb_info->flags = FBINFO_DEFAULT;\r\nfb_info->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb_info->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfb_info->fix.line_length = msmfb->xres * 2;\r\nfb_info->var.xres = msmfb->xres;\r\nfb_info->var.yres = msmfb->yres;\r\nfb_info->var.width = msmfb->panel->fb_data->width;\r\nfb_info->var.height = msmfb->panel->fb_data->height;\r\nfb_info->var.xres_virtual = msmfb->xres;\r\nfb_info->var.yres_virtual = msmfb->yres * 2;\r\nfb_info->var.bits_per_pixel = BITS_PER_PIXEL;\r\nfb_info->var.accel_flags = 0;\r\nfb_info->var.yoffset = 0;\r\nif (msmfb->panel->caps & MSMFB_CAP_PARTIAL_UPDATES) {\r\nfb_info->fix.reserved[0] = 0x5444;\r\nfb_info->fix.reserved[1] = 0x5055;\r\nfb_info->var.reserved[0] = 0x54445055;\r\nfb_info->var.reserved[1] = 0;\r\nfb_info->var.reserved[2] = (uint16_t)msmfb->xres |\r\n((uint32_t)msmfb->yres << 16);\r\n}\r\nfb_info->var.red.offset = 11;\r\nfb_info->var.red.length = 5;\r\nfb_info->var.red.msb_right = 0;\r\nfb_info->var.green.offset = 5;\r\nfb_info->var.green.length = 6;\r\nfb_info->var.green.msb_right = 0;\r\nfb_info->var.blue.offset = 0;\r\nfb_info->var.blue.length = 5;\r\nfb_info->var.blue.msb_right = 0;\r\nr = fb_alloc_cmap(&fb_info->cmap, 16, 0);\r\nfb_info->pseudo_palette = PP;\r\nPP[0] = 0;\r\nfor (r = 1; r < 16; r++)\r\nPP[r] = 0xffffffff;\r\n}\r\nstatic int setup_fbmem(struct msmfb_info *msmfb, struct platform_device *pdev)\r\n{\r\nstruct fb_info *fb = msmfb->fb;\r\nstruct resource *resource;\r\nunsigned long size = msmfb->xres * msmfb->yres *\r\n(BITS_PER_PIXEL >> 3) * 2;\r\nunsigned char *fbram;\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!resource)\r\nreturn -EINVAL;\r\nif (resource->end - resource->start < size) {\r\nprintk(KERN_ERR "allocated resource is too small for "\r\n"fb\n");\r\nreturn -ENOMEM;\r\n}\r\nfb->fix.smem_start = resource->start;\r\nfb->fix.smem_len = resource_size(resource);\r\nfbram = ioremap(resource->start, resource_size(resource));\r\nif (fbram == NULL) {\r\nprintk(KERN_ERR "msmfb: cannot allocate fbram!\n");\r\nreturn -ENOMEM;\r\n}\r\nfb->screen_base = fbram;\r\nreturn 0;\r\n}\r\nstatic int msmfb_probe(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fb;\r\nstruct msmfb_info *msmfb;\r\nstruct msm_panel_data *panel = pdev->dev.platform_data;\r\nint ret;\r\nif (!panel) {\r\npr_err("msmfb_probe: no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!panel->fb_data) {\r\npr_err("msmfb_probe: no fb_data\n");\r\nreturn -EINVAL;\r\n}\r\nfb = framebuffer_alloc(sizeof(struct msmfb_info), &pdev->dev);\r\nif (!fb)\r\nreturn -ENOMEM;\r\nmsmfb = fb->par;\r\nmsmfb->fb = fb;\r\nmsmfb->panel = panel;\r\nmsmfb->xres = panel->fb_data->xres;\r\nmsmfb->yres = panel->fb_data->yres;\r\nret = setup_fbmem(msmfb, pdev);\r\nif (ret)\r\ngoto error_setup_fbmem;\r\nsetup_fb_info(msmfb);\r\nspin_lock_init(&msmfb->update_lock);\r\nmutex_init(&msmfb->panel_init_lock);\r\ninit_waitqueue_head(&msmfb->frame_wq);\r\nINIT_WORK(&msmfb->resume_work, power_on_panel);\r\nmsmfb->black = devm_kzalloc(&pdev->dev,\r\nmsmfb->fb->var.bits_per_pixel*msmfb->xres,\r\nGFP_KERNEL);\r\nif (!msmfb->black) {\r\nret = -ENOMEM;\r\ngoto error_register_framebuffer;\r\n}\r\nprintk(KERN_INFO "msmfb_probe() installing %d x %d panel\n",\r\nmsmfb->xres, msmfb->yres);\r\nmsmfb->dma_callback.func = msmfb_handle_dma_interrupt;\r\nmsmfb->vsync_callback.func = msmfb_handle_vsync_interrupt;\r\nhrtimer_init(&msmfb->fake_vsync, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\nmsmfb->fake_vsync.function = msmfb_fake_vsync;\r\nret = register_framebuffer(fb);\r\nif (ret)\r\ngoto error_register_framebuffer;\r\nmsmfb->sleeping = WAKING;\r\nplatform_set_drvdata(pdev, msmfb);\r\nreturn 0;\r\nerror_register_framebuffer:\r\niounmap(fb->screen_base);\r\nerror_setup_fbmem:\r\nframebuffer_release(msmfb->fb);\r\nreturn ret;\r\n}\r\nstatic int msmfb_remove(struct platform_device *pdev)\r\n{\r\nstruct msmfb_info *msmfb;\r\nmsmfb = platform_get_drvdata(pdev);\r\nunregister_framebuffer(msmfb->fb);\r\niounmap(msmfb->fb->screen_base);\r\nframebuffer_release(msmfb->fb);\r\nreturn 0;\r\n}\r\nstatic int msmfb_add_mdp_device(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nif (mdp)\r\nreturn 0;\r\nmdp = container_of(dev, struct mdp_device, dev);\r\nreturn platform_driver_register(&msm_panel_driver);\r\n}\r\nstatic void msmfb_remove_mdp_device(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nif (dev != &mdp->dev)\r\nreturn;\r\nplatform_driver_unregister(&msm_panel_driver);\r\nmdp = NULL;\r\n}\r\nstatic int __init msmfb_init(void)\r\n{\r\nreturn register_mdp_client(&msm_fb_interface);\r\n}
