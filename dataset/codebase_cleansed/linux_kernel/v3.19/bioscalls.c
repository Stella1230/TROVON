static inline u16 call_pnp_bios(u16 func, u16 arg1, u16 arg2, u16 arg3,\r\nu16 arg4, u16 arg5, u16 arg6, u16 arg7,\r\nvoid *ts1_base, u32 ts1_size,\r\nvoid *ts2_base, u32 ts2_size)\r\n{\r\nunsigned long flags;\r\nu16 status;\r\nstruct desc_struct save_desc_40;\r\nint cpu;\r\nif (pnp_bios_is_utter_crap)\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\ncpu = get_cpu();\r\nsave_desc_40 = get_cpu_gdt_table(cpu)[0x40 / 8];\r\nget_cpu_gdt_table(cpu)[0x40 / 8] = bad_bios_desc;\r\nspin_lock_irqsave(&pnp_bios_lock, flags);\r\nif (ts1_size)\r\nQ2_SET_SEL(smp_processor_id(), PNP_TS1, ts1_base, ts1_size);\r\nif (ts2_size)\r\nQ2_SET_SEL(smp_processor_id(), PNP_TS2, ts2_base, ts2_size);\r\n__asm__ __volatile__("pushl %%ebp\n\t"\r\n"pushl %%edi\n\t"\r\n"pushl %%esi\n\t"\r\n"pushl %%ds\n\t"\r\n"pushl %%es\n\t"\r\n"pushl %%fs\n\t"\r\n"pushl %%gs\n\t"\r\n"pushfl\n\t"\r\n"movl %%esp, pnp_bios_fault_esp\n\t"\r\n"movl $1f, pnp_bios_fault_eip\n\t"\r\n"lcall %5,%6\n\t"\r\n"1:popfl\n\t"\r\n"popl %%gs\n\t"\r\n"popl %%fs\n\t"\r\n"popl %%es\n\t"\r\n"popl %%ds\n\t"\r\n"popl %%esi\n\t"\r\n"popl %%edi\n\t"\r\n"popl %%ebp\n\t":"=a"(status)\r\n:"0"((func) | (((u32) arg1) << 16)),\r\n"b"((arg2) | (((u32) arg3) << 16)),\r\n"c"((arg4) | (((u32) arg5) << 16)),\r\n"d"((arg6) | (((u32) arg7) << 16)),\r\n"i"(PNP_CS32), "i"(0)\r\n:"memory");\r\nspin_unlock_irqrestore(&pnp_bios_lock, flags);\r\nget_cpu_gdt_table(cpu)[0x40 / 8] = save_desc_40;\r\nput_cpu();\r\nif (pnp_bios_is_utter_crap) {\r\nprintk(KERN_ERR\r\n"PnPBIOS: Warning! Your PnP BIOS caused a fatal error. Attempting to continue\n");\r\nprintk(KERN_ERR\r\n"PnPBIOS: You may need to reboot with the \"pnpbios=off\" option to operate stably\n");\r\nprintk(KERN_ERR\r\n"PnPBIOS: Check with your vendor for an updated BIOS\n");\r\n}\r\nreturn status;\r\n}\r\nvoid pnpbios_print_status(const char *module, u16 status)\r\n{\r\nswitch (status) {\r\ncase PNP_SUCCESS:\r\nprintk(KERN_ERR "PnPBIOS: %s: function successful\n", module);\r\nbreak;\r\ncase PNP_NOT_SET_STATICALLY:\r\nprintk(KERN_ERR "PnPBIOS: %s: unable to set static resources\n",\r\nmodule);\r\nbreak;\r\ncase PNP_UNKNOWN_FUNCTION:\r\nprintk(KERN_ERR "PnPBIOS: %s: invalid function number passed\n",\r\nmodule);\r\nbreak;\r\ncase PNP_FUNCTION_NOT_SUPPORTED:\r\nprintk(KERN_ERR\r\n"PnPBIOS: %s: function not supported on this system\n",\r\nmodule);\r\nbreak;\r\ncase PNP_INVALID_HANDLE:\r\nprintk(KERN_ERR "PnPBIOS: %s: invalid handle\n", module);\r\nbreak;\r\ncase PNP_BAD_PARAMETER:\r\nprintk(KERN_ERR "PnPBIOS: %s: invalid parameters were passed\n",\r\nmodule);\r\nbreak;\r\ncase PNP_SET_FAILED:\r\nprintk(KERN_ERR "PnPBIOS: %s: unable to set resources\n",\r\nmodule);\r\nbreak;\r\ncase PNP_EVENTS_NOT_PENDING:\r\nprintk(KERN_ERR "PnPBIOS: %s: no events are pending\n", module);\r\nbreak;\r\ncase PNP_SYSTEM_NOT_DOCKED:\r\nprintk(KERN_ERR "PnPBIOS: %s: the system is not docked\n",\r\nmodule);\r\nbreak;\r\ncase PNP_NO_ISA_PNP_CARDS:\r\nprintk(KERN_ERR\r\n"PnPBIOS: %s: no isapnp cards are installed on this system\n",\r\nmodule);\r\nbreak;\r\ncase PNP_UNABLE_TO_DETERMINE_DOCK_CAPABILITIES:\r\nprintk(KERN_ERR\r\n"PnPBIOS: %s: cannot determine the capabilities of the docking station\n",\r\nmodule);\r\nbreak;\r\ncase PNP_CONFIG_CHANGE_FAILED_NO_BATTERY:\r\nprintk(KERN_ERR\r\n"PnPBIOS: %s: unable to undock, the system does not have a battery\n",\r\nmodule);\r\nbreak;\r\ncase PNP_CONFIG_CHANGE_FAILED_RESOURCE_CONFLICT:\r\nprintk(KERN_ERR\r\n"PnPBIOS: %s: could not dock due to resource conflicts\n",\r\nmodule);\r\nbreak;\r\ncase PNP_BUFFER_TOO_SMALL:\r\nprintk(KERN_ERR "PnPBIOS: %s: the buffer passed is too small\n",\r\nmodule);\r\nbreak;\r\ncase PNP_USE_ESCD_SUPPORT:\r\nprintk(KERN_ERR "PnPBIOS: %s: use ESCD instead\n", module);\r\nbreak;\r\ncase PNP_MESSAGE_NOT_SUPPORTED:\r\nprintk(KERN_ERR "PnPBIOS: %s: the message is unsupported\n",\r\nmodule);\r\nbreak;\r\ncase PNP_HARDWARE_ERROR:\r\nprintk(KERN_ERR "PnPBIOS: %s: a hardware failure has occurred\n",\r\nmodule);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "PnPBIOS: %s: unexpected status 0x%x\n", module,\r\nstatus);\r\nbreak;\r\n}\r\n}\r\nstatic int __pnp_bios_dev_node_info(struct pnp_dev_node_info *data)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_GET_NUM_SYS_DEV_NODES, 0, PNP_TS1, 2,\r\nPNP_TS1, PNP_DS, 0, 0, data,\r\nsizeof(struct pnp_dev_node_info), NULL, 0);\r\ndata->no_nodes &= 0xff;\r\nreturn status;\r\n}\r\nint pnp_bios_dev_node_info(struct pnp_dev_node_info *data)\r\n{\r\nint status = __pnp_bios_dev_node_info(data);\r\nif (status)\r\npnpbios_print_status("dev_node_info", status);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_get_dev_node(u8 *nodenum, char boot,\r\nstruct pnp_bios_node *data)\r\n{\r\nu16 status;\r\nu16 tmp_nodenum;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nif (!boot && pnpbios_dont_use_current_config)\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\ntmp_nodenum = *nodenum;\r\nstatus = call_pnp_bios(PNP_GET_SYS_DEV_NODE, 0, PNP_TS1, 0, PNP_TS2,\r\nboot ? 2 : 1, PNP_DS, 0, &tmp_nodenum,\r\nsizeof(tmp_nodenum), data, 65536);\r\n*nodenum = tmp_nodenum;\r\nreturn status;\r\n}\r\nint pnp_bios_get_dev_node(u8 *nodenum, char boot, struct pnp_bios_node *data)\r\n{\r\nint status;\r\nstatus = __pnp_bios_get_dev_node(nodenum, boot, data);\r\nif (status)\r\npnpbios_print_status("get_dev_node", status);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_set_dev_node(u8 nodenum, char boot,\r\nstruct pnp_bios_node *data)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nif (!boot && pnpbios_dont_use_current_config)\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_SET_SYS_DEV_NODE, nodenum, 0, PNP_TS1,\r\nboot ? 2 : 1, PNP_DS, 0, 0, data, 65536, NULL,\r\n0);\r\nreturn status;\r\n}\r\nint pnp_bios_set_dev_node(u8 nodenum, char boot, struct pnp_bios_node *data)\r\n{\r\nint status;\r\nstatus = __pnp_bios_set_dev_node(nodenum, boot, data);\r\nif (status) {\r\npnpbios_print_status("set_dev_node", status);\r\nreturn status;\r\n}\r\nif (!boot) {\r\nstatus = pnp_bios_get_dev_node(&nodenum, boot, data);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nint pnp_bios_dock_station_info(struct pnp_docking_station_info *data)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_GET_DOCKING_STATION_INFORMATION, 0, PNP_TS1,\r\nPNP_DS, 0, 0, 0, 0, data,\r\nsizeof(struct pnp_docking_station_info), NULL,\r\n0);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_get_stat_res(char *info)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_GET_STATIC_ALLOCED_RES_INFO, 0, PNP_TS1,\r\nPNP_DS, 0, 0, 0, 0, info, 65536, NULL, 0);\r\nreturn status;\r\n}\r\nint pnp_bios_get_stat_res(char *info)\r\n{\r\nint status;\r\nstatus = __pnp_bios_get_stat_res(info);\r\nif (status)\r\npnpbios_print_status("get_stat_res", status);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_isapnp_config(struct pnp_isa_config_struc *data)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn PNP_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_GET_PNP_ISA_CONFIG_STRUC, 0, PNP_TS1, PNP_DS,\r\n0, 0, 0, 0, data,\r\nsizeof(struct pnp_isa_config_struc), NULL, 0);\r\nreturn status;\r\n}\r\nint pnp_bios_isapnp_config(struct pnp_isa_config_struc *data)\r\n{\r\nint status;\r\nstatus = __pnp_bios_isapnp_config(data);\r\nif (status)\r\npnpbios_print_status("isapnp_config", status);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_escd_info(struct escd_info_struc *data)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn ESCD_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_GET_ESCD_INFO, 0, PNP_TS1, 2, PNP_TS1, 4,\r\nPNP_TS1, PNP_DS, data,\r\nsizeof(struct escd_info_struc), NULL, 0);\r\nreturn status;\r\n}\r\nint pnp_bios_escd_info(struct escd_info_struc *data)\r\n{\r\nint status;\r\nstatus = __pnp_bios_escd_info(data);\r\nif (status)\r\npnpbios_print_status("escd_info", status);\r\nreturn status;\r\n}\r\nstatic int __pnp_bios_read_escd(char *data, u32 nvram_base)\r\n{\r\nu16 status;\r\nif (!pnp_bios_present())\r\nreturn ESCD_FUNCTION_NOT_SUPPORTED;\r\nstatus = call_pnp_bios(PNP_READ_ESCD, 0, PNP_TS1, PNP_TS2, PNP_DS, 0, 0,\r\n0, data, 65536, __va(nvram_base), 65536);\r\nreturn status;\r\n}\r\nint pnp_bios_read_escd(char *data, u32 nvram_base)\r\n{\r\nint status;\r\nstatus = __pnp_bios_read_escd(data, nvram_base);\r\nif (status)\r\npnpbios_print_status("read_escd", status);\r\nreturn status;\r\n}\r\nvoid pnpbios_calls_init(union pnp_bios_install_struct *header)\r\n{\r\nint i;\r\nspin_lock_init(&pnp_bios_lock);\r\npnp_bios_callpoint.offset = header->fields.pm16offset;\r\npnp_bios_callpoint.segment = PNP_CS16;\r\nfor_each_possible_cpu(i) {\r\nstruct desc_struct *gdt = get_cpu_gdt_table(i);\r\nif (!gdt)\r\ncontinue;\r\nset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_CS32],\r\n(unsigned long)&pnp_bios_callfunc);\r\nset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_CS16],\r\n(unsigned long)__va(header->fields.pm16cseg));\r\nset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_DS],\r\n(unsigned long)__va(header->fields.pm16dseg));\r\n}\r\n}
