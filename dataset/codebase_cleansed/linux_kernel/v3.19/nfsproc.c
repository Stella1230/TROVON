static __be32\r\nnfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32\r\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\r\n{\r\nif (err) return err;\r\nreturn fh_getattr(&resp->fh, &resp->stat);\r\n}\r\nstatic __be32\r\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\r\n{\r\nif (err) return err;\r\nreturn fh_getattr(&resp->fh, &resp->stat);\r\n}\r\nstatic __be32\r\nnfsd_proc_getattr(struct svc_rqst *rqstp, struct nfsd_fhandle *argp,\r\nstruct nfsd_attrstat *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: GETATTR %s\n", SVCFH_fmt(&argp->fh));\r\nfh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0,\r\nNFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\r\nreturn nfsd_return_attrs(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_setattr(struct svc_rqst *rqstp, struct nfsd_sattrargs *argp,\r\nstruct nfsd_attrstat *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: SETATTR %s, valid=%x, size=%ld\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->attrs.ia_valid, (long) argp->attrs.ia_size);\r\nfh_copy(&resp->fh, &argp->fh);\r\nnfserr = nfsd_setattr(rqstp, &resp->fh, &argp->attrs,0, (time_t)0);\r\nreturn nfsd_return_attrs(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_lookup(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\r\nstruct nfsd_diropres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: LOOKUP %s %.*s\n",\r\nSVCFH_fmt(&argp->fh), argp->len, argp->name);\r\nfh_init(&resp->fh, NFS_FHSIZE);\r\nnfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\r\n&resp->fh);\r\nfh_put(&argp->fh);\r\nreturn nfsd_return_dirop(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_readlink(struct svc_rqst *rqstp, struct nfsd_readlinkargs *argp,\r\nstruct nfsd_readlinkres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: READLINK %s\n", SVCFH_fmt(&argp->fh));\r\nresp->len = NFS_MAXPATHLEN;\r\nnfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);\r\nfh_put(&argp->fh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,\r\nstruct nfsd_readres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: READ %s %d bytes at %d\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->count, argp->offset);\r\nif (NFSSVC_MAXBLKSIZE_V2 < argp->count) {\r\nchar buf[RPC_MAX_ADDRBUFLEN];\r\nprintk(KERN_NOTICE\r\n"oversized read request from %s (%d bytes)\n",\r\nsvc_print_addr(rqstp, buf, sizeof(buf)),\r\nargp->count);\r\nargp->count = NFSSVC_MAXBLKSIZE_V2;\r\n}\r\nsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\r\nresp->count = argp->count;\r\nnfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),\r\nargp->offset,\r\nrqstp->rq_vec, argp->vlen,\r\n&resp->count);\r\nif (nfserr) return nfserr;\r\nreturn fh_getattr(&resp->fh, &resp->stat);\r\n}\r\nstatic __be32\r\nnfsd_proc_write(struct svc_rqst *rqstp, struct nfsd_writeargs *argp,\r\nstruct nfsd_attrstat *resp)\r\n{\r\n__be32 nfserr;\r\nint stable = 1;\r\nunsigned long cnt = argp->len;\r\ndprintk("nfsd: WRITE %s %d bytes at %d\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->len, argp->offset);\r\nnfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh), NULL,\r\nargp->offset,\r\nrqstp->rq_vec, argp->vlen,\r\n&cnt,\r\n&stable);\r\nreturn nfsd_return_attrs(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\r\nstruct nfsd_diropres *resp)\r\n{\r\nsvc_fh *dirfhp = &argp->fh;\r\nsvc_fh *newfhp = &resp->fh;\r\nstruct iattr *attr = &argp->attrs;\r\nstruct inode *inode;\r\nstruct dentry *dchild;\r\nint type, mode;\r\n__be32 nfserr;\r\nint hosterr;\r\ndev_t rdev = 0, wanted = new_decode_dev(attr->ia_size);\r\ndprintk("nfsd: CREATE %s %.*s\n",\r\nSVCFH_fmt(dirfhp), argp->len, argp->name);\r\nnfserr = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\r\nif (nfserr)\r\ngoto done;\r\nnfserr = nfserr_acces;\r\nif (!argp->len)\r\ngoto done;\r\nnfserr = nfserr_exist;\r\nif (isdotent(argp->name, argp->len))\r\ngoto done;\r\nhosterr = fh_want_write(dirfhp);\r\nif (hosterr) {\r\nnfserr = nfserrno(hosterr);\r\ngoto done;\r\n}\r\nfh_lock_nested(dirfhp, I_MUTEX_PARENT);\r\ndchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\r\nif (IS_ERR(dchild)) {\r\nnfserr = nfserrno(PTR_ERR(dchild));\r\ngoto out_unlock;\r\n}\r\nfh_init(newfhp, NFS_FHSIZE);\r\nnfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\r\nif (!nfserr && !dchild->d_inode)\r\nnfserr = nfserr_noent;\r\ndput(dchild);\r\nif (nfserr) {\r\nif (nfserr != nfserr_noent)\r\ngoto out_unlock;\r\nnfserr = nfserr_acces;\r\nif (!newfhp->fh_dentry) {\r\nprintk(KERN_WARNING\r\n"nfsd_proc_create: file handle not verified\n");\r\ngoto out_unlock;\r\n}\r\n}\r\ninode = newfhp->fh_dentry->d_inode;\r\nif (attr->ia_valid & ATTR_MODE) {\r\ntype = attr->ia_mode & S_IFMT;\r\nmode = attr->ia_mode & ~S_IFMT;\r\nif (!type) {\r\nif (inode) {\r\ntype = inode->i_mode & S_IFMT;\r\nswitch(type) {\r\ncase S_IFCHR:\r\ncase S_IFBLK:\r\nrdev = inode->i_rdev;\r\nattr->ia_valid |= ATTR_SIZE;\r\ncase S_IFIFO:\r\nnfserr = nfsd_permission(rqstp,\r\nnewfhp->fh_export,\r\nnewfhp->fh_dentry,\r\nNFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\r\nif (nfserr && nfserr != nfserr_rofs)\r\ngoto out_unlock;\r\n}\r\n} else\r\ntype = S_IFREG;\r\n}\r\n} else if (inode) {\r\ntype = inode->i_mode & S_IFMT;\r\nmode = inode->i_mode & ~S_IFMT;\r\n} else {\r\ntype = S_IFREG;\r\nmode = 0;\r\n}\r\nattr->ia_valid |= ATTR_MODE;\r\nattr->ia_mode = mode;\r\nif (type != S_IFREG) {\r\nif (type != S_IFBLK && type != S_IFCHR) {\r\nrdev = 0;\r\n} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\r\ntype = S_IFIFO;\r\n} else {\r\nif (!rdev)\r\nrdev = wanted;\r\n}\r\nattr->ia_valid &= ~ATTR_SIZE;\r\nnfserr = nfserr_exist;\r\nif (inode && type != (inode->i_mode & S_IFMT))\r\ngoto out_unlock;\r\n}\r\nnfserr = 0;\r\nif (!inode) {\r\nnfserr = nfsd_create(rqstp, dirfhp, argp->name, argp->len,\r\nattr, type, rdev, newfhp);\r\n} else if (type == S_IFREG) {\r\ndprintk("nfsd: existing %s, valid=%x, size=%ld\n",\r\nargp->name, attr->ia_valid, (long) attr->ia_size);\r\nattr->ia_valid &= ATTR_SIZE;\r\nif (attr->ia_valid)\r\nnfserr = nfsd_setattr(rqstp, newfhp, attr, 0, (time_t)0);\r\n}\r\nout_unlock:\r\nfh_unlock(dirfhp);\r\nfh_drop_write(dirfhp);\r\ndone:\r\nfh_put(dirfhp);\r\nreturn nfsd_return_dirop(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_remove(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\r\nvoid *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: REMOVE %s %.*s\n", SVCFH_fmt(&argp->fh),\r\nargp->len, argp->name);\r\nnfserr = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR, argp->name, argp->len);\r\nfh_put(&argp->fh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_rename(struct svc_rqst *rqstp, struct nfsd_renameargs *argp,\r\nvoid *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: RENAME %s %.*s -> \n",\r\nSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\r\ndprintk("nfsd: -> %s %.*s\n",\r\nSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\r\nnfserr = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\r\n&argp->tfh, argp->tname, argp->tlen);\r\nfh_put(&argp->ffh);\r\nfh_put(&argp->tfh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_link(struct svc_rqst *rqstp, struct nfsd_linkargs *argp,\r\nvoid *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: LINK %s ->\n",\r\nSVCFH_fmt(&argp->ffh));\r\ndprintk("nfsd: %s %.*s\n",\r\nSVCFH_fmt(&argp->tfh),\r\nargp->tlen,\r\nargp->tname);\r\nnfserr = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\r\n&argp->ffh);\r\nfh_put(&argp->ffh);\r\nfh_put(&argp->tfh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_symlink(struct svc_rqst *rqstp, struct nfsd_symlinkargs *argp,\r\nvoid *resp)\r\n{\r\nstruct svc_fh newfh;\r\n__be32 nfserr;\r\ndprintk("nfsd: SYMLINK %s %.*s -> %.*s\n",\r\nSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\r\nargp->tlen, argp->tname);\r\nfh_init(&newfh, NFS_FHSIZE);\r\nargp->tname[argp->tlen] = '\0';\r\nnfserr = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\r\nargp->tname, &newfh);\r\nfh_put(&argp->ffh);\r\nfh_put(&newfh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_mkdir(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\r\nstruct nfsd_diropres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: MKDIR %s %.*s\n", SVCFH_fmt(&argp->fh), argp->len, argp->name);\r\nif (resp->fh.fh_dentry) {\r\nprintk(KERN_WARNING\r\n"nfsd_proc_mkdir: response already verified??\n");\r\n}\r\nargp->attrs.ia_valid &= ~ATTR_SIZE;\r\nfh_init(&resp->fh, NFS_FHSIZE);\r\nnfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\r\n&argp->attrs, S_IFDIR, 0, &resp->fh);\r\nfh_put(&argp->fh);\r\nreturn nfsd_return_dirop(nfserr, resp);\r\n}\r\nstatic __be32\r\nnfsd_proc_rmdir(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\r\nvoid *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: RMDIR %s %.*s\n", SVCFH_fmt(&argp->fh), argp->len, argp->name);\r\nnfserr = nfsd_unlink(rqstp, &argp->fh, S_IFDIR, argp->name, argp->len);\r\nfh_put(&argp->fh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_readdir(struct svc_rqst *rqstp, struct nfsd_readdirargs *argp,\r\nstruct nfsd_readdirres *resp)\r\n{\r\nint count;\r\n__be32 nfserr;\r\nloff_t offset;\r\ndprintk("nfsd: READDIR %s %d bytes at %d\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->count, argp->cookie);\r\ncount = (argp->count >> 2) - 2;\r\ncount -= 2;\r\nif (count < 0)\r\ncount = 0;\r\nresp->buffer = argp->buffer;\r\nresp->offset = NULL;\r\nresp->buflen = count;\r\nresp->common.err = nfs_ok;\r\noffset = argp->cookie;\r\nnfserr = nfsd_readdir(rqstp, &argp->fh, &offset,\r\n&resp->common, nfssvc_encode_entry);\r\nresp->count = resp->buffer - argp->buffer;\r\nif (resp->offset)\r\n*resp->offset = htonl(offset);\r\nfh_put(&argp->fh);\r\nreturn nfserr;\r\n}\r\nstatic __be32\r\nnfsd_proc_statfs(struct svc_rqst * rqstp, struct nfsd_fhandle *argp,\r\nstruct nfsd_statfsres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: STATFS %s\n", SVCFH_fmt(&argp->fh));\r\nnfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\r\nNFSD_MAY_BYPASS_GSS_ON_ROOT);\r\nfh_put(&argp->fh);\r\nreturn nfserr;\r\n}\r\n__be32\r\nnfserrno (int errno)\r\n{\r\nstatic struct {\r\n__be32 nfserr;\r\nint syserr;\r\n} nfs_errtbl[] = {\r\n{ nfs_ok, 0 },\r\n{ nfserr_perm, -EPERM },\r\n{ nfserr_noent, -ENOENT },\r\n{ nfserr_io, -EIO },\r\n{ nfserr_nxio, -ENXIO },\r\n{ nfserr_fbig, -E2BIG },\r\n{ nfserr_acces, -EACCES },\r\n{ nfserr_exist, -EEXIST },\r\n{ nfserr_xdev, -EXDEV },\r\n{ nfserr_mlink, -EMLINK },\r\n{ nfserr_nodev, -ENODEV },\r\n{ nfserr_notdir, -ENOTDIR },\r\n{ nfserr_isdir, -EISDIR },\r\n{ nfserr_inval, -EINVAL },\r\n{ nfserr_fbig, -EFBIG },\r\n{ nfserr_nospc, -ENOSPC },\r\n{ nfserr_rofs, -EROFS },\r\n{ nfserr_mlink, -EMLINK },\r\n{ nfserr_nametoolong, -ENAMETOOLONG },\r\n{ nfserr_notempty, -ENOTEMPTY },\r\n#ifdef EDQUOT\r\n{ nfserr_dquot, -EDQUOT },\r\n#endif\r\n{ nfserr_stale, -ESTALE },\r\n{ nfserr_jukebox, -ETIMEDOUT },\r\n{ nfserr_jukebox, -ERESTARTSYS },\r\n{ nfserr_jukebox, -EAGAIN },\r\n{ nfserr_jukebox, -EWOULDBLOCK },\r\n{ nfserr_jukebox, -ENOMEM },\r\n{ nfserr_io, -ETXTBSY },\r\n{ nfserr_notsupp, -EOPNOTSUPP },\r\n{ nfserr_toosmall, -ETOOSMALL },\r\n{ nfserr_serverfault, -ESERVERFAULT },\r\n{ nfserr_serverfault, -ENFILE },\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\r\nif (nfs_errtbl[i].syserr == errno)\r\nreturn nfs_errtbl[i].nfserr;\r\n}\r\nWARN(1, "nfsd: non-standard errno: %d\n", errno);\r\nreturn nfserr_io;\r\n}
