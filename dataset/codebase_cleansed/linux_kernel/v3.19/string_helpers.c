int string_get_size(u64 size, const enum string_size_units units,\r\nchar *buf, int len)\r\n{\r\nstatic const char *const units_10[] = {\r\n"B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB", NULL\r\n};\r\nstatic const char *const units_2[] = {\r\n"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB",\r\nNULL\r\n};\r\nstatic const char *const *const units_str[] = {\r\n[STRING_UNITS_10] = units_10,\r\n[STRING_UNITS_2] = units_2,\r\n};\r\nstatic const unsigned int divisor[] = {\r\n[STRING_UNITS_10] = 1000,\r\n[STRING_UNITS_2] = 1024,\r\n};\r\nint i, j;\r\nu64 remainder = 0, sf_cap;\r\nchar tmp[8];\r\ntmp[0] = '\0';\r\ni = 0;\r\nif (size >= divisor[units]) {\r\nwhile (size >= divisor[units] && units_str[units][i]) {\r\nremainder = do_div(size, divisor[units]);\r\ni++;\r\n}\r\nsf_cap = size;\r\nfor (j = 0; sf_cap*10 < 1000; j++)\r\nsf_cap *= 10;\r\nif (j) {\r\nremainder *= 1000;\r\ndo_div(remainder, divisor[units]);\r\nsnprintf(tmp, sizeof(tmp), ".%03lld",\r\n(unsigned long long)remainder);\r\ntmp[j+1] = '\0';\r\n}\r\n}\r\nsnprintf(buf, len, "%lld%s %s", (unsigned long long)size,\r\ntmp, units_str[units][i]);\r\nreturn 0;\r\n}\r\nstatic bool unescape_space(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase 'n':\r\n*p = '\n';\r\nbreak;\r\ncase 'r':\r\n*p = '\r';\r\nbreak;\r\ncase 't':\r\n*p = '\t';\r\nbreak;\r\ncase 'v':\r\n*p = '\v';\r\nbreak;\r\ncase 'f':\r\n*p = '\f';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nstatic bool unescape_octal(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nu8 num;\r\nif (isodigit(*q) == 0)\r\nreturn false;\r\nnum = (*q++) & 7;\r\nwhile (num < 32 && isodigit(*q) && (q - *src < 3)) {\r\nnum <<= 3;\r\nnum += (*q++) & 7;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_hex(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nint digit;\r\nu8 num;\r\nif (*q++ != 'x')\r\nreturn false;\r\nnum = digit = hex_to_bin(*q++);\r\nif (digit < 0)\r\nreturn false;\r\ndigit = hex_to_bin(*q);\r\nif (digit >= 0) {\r\nq++;\r\nnum = (num << 4) | digit;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_special(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase '\"':\r\n*p = '\"';\r\nbreak;\r\ncase '\\':\r\n*p = '\\';\r\nbreak;\r\ncase 'a':\r\n*p = '\a';\r\nbreak;\r\ncase 'e':\r\n*p = '\e';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nint string_unescape(char *src, char *dst, size_t size, unsigned int flags)\r\n{\r\nchar *out = dst;\r\nwhile (*src && --size) {\r\nif (src[0] == '\\' && src[1] != '\0' && size > 1) {\r\nsrc++;\r\nsize--;\r\nif (flags & UNESCAPE_SPACE &&\r\nunescape_space(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_OCTAL &&\r\nunescape_octal(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_HEX &&\r\nunescape_hex(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_SPECIAL &&\r\nunescape_special(&src, &out))\r\ncontinue;\r\n*out++ = '\\';\r\n}\r\n*out++ = *src++;\r\n}\r\n*out = '\0';\r\nreturn out - dst;\r\n}\r\nstatic int escape_passthrough(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nif (*osz < 1)\r\nreturn -ENOMEM;\r\n*out++ = c;\r\n*dst = out;\r\n*osz -= 1;\r\nreturn 1;\r\n}\r\nstatic int escape_space(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nunsigned char to;\r\nif (*osz < 2)\r\nreturn -ENOMEM;\r\nswitch (c) {\r\ncase '\n':\r\nto = 'n';\r\nbreak;\r\ncase '\r':\r\nto = 'r';\r\nbreak;\r\ncase '\t':\r\nto = 't';\r\nbreak;\r\ncase '\v':\r\nto = 'v';\r\nbreak;\r\ncase '\f':\r\nto = 'f';\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n*out++ = '\\';\r\n*out++ = to;\r\n*dst = out;\r\n*osz -= 2;\r\nreturn 1;\r\n}\r\nstatic int escape_special(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nunsigned char to;\r\nif (*osz < 2)\r\nreturn -ENOMEM;\r\nswitch (c) {\r\ncase '\\':\r\nto = '\\';\r\nbreak;\r\ncase '\a':\r\nto = 'a';\r\nbreak;\r\ncase '\e':\r\nto = 'e';\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n*out++ = '\\';\r\n*out++ = to;\r\n*dst = out;\r\n*osz -= 2;\r\nreturn 1;\r\n}\r\nstatic int escape_null(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nif (*osz < 2)\r\nreturn -ENOMEM;\r\nif (c)\r\nreturn 0;\r\n*out++ = '\\';\r\n*out++ = '0';\r\n*dst = out;\r\n*osz -= 2;\r\nreturn 1;\r\n}\r\nstatic int escape_octal(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nif (*osz < 4)\r\nreturn -ENOMEM;\r\n*out++ = '\\';\r\n*out++ = ((c >> 6) & 0x07) + '0';\r\n*out++ = ((c >> 3) & 0x07) + '0';\r\n*out++ = ((c >> 0) & 0x07) + '0';\r\n*dst = out;\r\n*osz -= 4;\r\nreturn 1;\r\n}\r\nstatic int escape_hex(unsigned char c, char **dst, size_t *osz)\r\n{\r\nchar *out = *dst;\r\nif (*osz < 4)\r\nreturn -ENOMEM;\r\n*out++ = '\\';\r\n*out++ = 'x';\r\n*out++ = hex_asc_hi(c);\r\n*out++ = hex_asc_lo(c);\r\n*dst = out;\r\n*osz -= 4;\r\nreturn 1;\r\n}\r\nint string_escape_mem(const char *src, size_t isz, char **dst, size_t osz,\r\nunsigned int flags, const char *esc)\r\n{\r\nchar *out = *dst, *p = out;\r\nbool is_dict = esc && *esc;\r\nint ret = 0;\r\nwhile (isz--) {\r\nunsigned char c = *src++;\r\nif ((flags & ESCAPE_NP && isprint(c)) ||\r\n(is_dict && !strchr(esc, c))) {\r\n} else {\r\nif (flags & ESCAPE_SPACE) {\r\nret = escape_space(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ncontinue;\r\n}\r\nif (flags & ESCAPE_SPECIAL) {\r\nret = escape_special(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ncontinue;\r\n}\r\nif (flags & ESCAPE_NULL) {\r\nret = escape_null(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ncontinue;\r\n}\r\nif (flags & ESCAPE_OCTAL) {\r\nret = escape_octal(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\ncontinue;\r\n}\r\nif (flags & ESCAPE_HEX) {\r\nret = escape_hex(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\ncontinue;\r\n}\r\n}\r\nret = escape_passthrough(c, &p, &osz);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n*dst = p;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn p - out;\r\n}
