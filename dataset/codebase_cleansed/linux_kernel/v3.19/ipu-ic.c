static inline u32 ipu_ic_read(struct ipu_ic *ic, unsigned offset)\r\n{\r\nreturn readl(ic->priv->base + offset);\r\n}\r\nstatic inline void ipu_ic_write(struct ipu_ic *ic, u32 value, unsigned offset)\r\n{\r\nwritel(value, ic->priv->base + offset);\r\n}\r\nstatic int init_csc(struct ipu_ic *ic,\r\nenum ipu_color_space inf,\r\nenum ipu_color_space outf,\r\nint csc_index)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nconst struct ic_csc_params *params;\r\nu32 __iomem *base;\r\nconst u16 (*c)[3];\r\nconst u16 *a;\r\nu32 param;\r\nbase = (u32 __iomem *)\r\n(priv->tpmem_base + ic->reg->tpmem_csc[csc_index]);\r\nif (inf == IPUV3_COLORSPACE_YUV && outf == IPUV3_COLORSPACE_RGB)\r\nparams = &ic_csc_ycbcr2rgb;\r\nelse if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_YUV)\r\nparams = &ic_csc_rgb2ycbcr;\r\nelse if (inf == IPUV3_COLORSPACE_RGB && outf == IPUV3_COLORSPACE_RGB)\r\nparams = &ic_csc_rgb2rgb;\r\nelse {\r\ndev_err(priv->ipu->dev, "Unsupported color space conversion\n");\r\nreturn -EINVAL;\r\n}\r\nc = (const u16 (*)[3])params->coeff;\r\na = (const u16 *)params->offset;\r\nparam = ((a[0] & 0x1f) << 27) | ((c[0][0] & 0x1ff) << 18) |\r\n((c[1][1] & 0x1ff) << 9) | (c[2][2] & 0x1ff);\r\nwritel(param, base++);\r\nparam = ((a[0] & 0x1fe0) >> 5) | (params->scale << 8) |\r\n(params->sat << 9);\r\nwritel(param, base++);\r\nparam = ((a[1] & 0x1f) << 27) | ((c[0][1] & 0x1ff) << 18) |\r\n((c[1][0] & 0x1ff) << 9) | (c[2][0] & 0x1ff);\r\nwritel(param, base++);\r\nparam = ((a[1] & 0x1fe0) >> 5);\r\nwritel(param, base++);\r\nparam = ((a[2] & 0x1f) << 27) | ((c[0][2] & 0x1ff) << 18) |\r\n((c[1][2] & 0x1ff) << 9) | (c[2][1] & 0x1ff);\r\nwritel(param, base++);\r\nparam = ((a[2] & 0x1fe0) >> 5);\r\nwritel(param, base++);\r\nreturn 0;\r\n}\r\nstatic int calc_resize_coeffs(struct ipu_ic *ic,\r\nu32 in_size, u32 out_size,\r\nu32 *resize_coeff,\r\nu32 *downsize_coeff)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nstruct ipu_soc *ipu = priv->ipu;\r\nu32 temp_size, temp_downsize;\r\nif (in_size > 4096) {\r\ndev_err(ipu->dev, "Unsupported resize (in_size > 4096)\n");\r\nreturn -EINVAL;\r\n}\r\nif (out_size > 1024) {\r\ndev_err(ipu->dev, "Unsupported resize (out_size > 1024)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((out_size << 3) < in_size) {\r\ndev_err(ipu->dev, "Unsupported downsize\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_downsize = 0;\r\ntemp_size = in_size;\r\nwhile (((temp_size > 1024) || (temp_size >= out_size * 2)) &&\r\n(temp_downsize < 2)) {\r\ntemp_size >>= 1;\r\ntemp_downsize++;\r\n}\r\n*downsize_coeff = temp_downsize;\r\n*resize_coeff = (8192L * (temp_size - 1)) / (out_size - 1);\r\nif (*resize_coeff >= 16384L) {\r\ndev_err(ipu->dev, "Warning! Overflow on resize coeff.\n");\r\n*resize_coeff = 0x3FFF;\r\n}\r\nreturn 0;\r\n}\r\nvoid ipu_ic_task_enable(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nu32 ic_conf;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nic_conf = ipu_ic_read(ic, IC_CONF);\r\nic_conf |= ic->bit->ic_conf_en;\r\nif (ic->rotation)\r\nic_conf |= ic->bit->ic_conf_rot_en;\r\nif (ic->in_cs != ic->out_cs)\r\nic_conf |= ic->bit->ic_conf_csc1_en;\r\nif (ic->graphics) {\r\nic_conf |= ic->bit->ic_conf_cmb_en;\r\nic_conf |= ic->bit->ic_conf_csc1_en;\r\nif (ic->g_in_cs != ic->out_cs)\r\nic_conf |= ic->bit->ic_conf_csc2_en;\r\n}\r\nipu_ic_write(ic, ic_conf, IC_CONF);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nvoid ipu_ic_task_disable(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nu32 ic_conf;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nic_conf = ipu_ic_read(ic, IC_CONF);\r\nic_conf &= ~(ic->bit->ic_conf_en |\r\nic->bit->ic_conf_csc1_en |\r\nic->bit->ic_conf_rot_en);\r\nif (ic->bit->ic_conf_csc2_en)\r\nic_conf &= ~ic->bit->ic_conf_csc2_en;\r\nif (ic->bit->ic_conf_cmb_en)\r\nic_conf &= ~ic->bit->ic_conf_cmb_en;\r\nipu_ic_write(ic, ic_conf, IC_CONF);\r\nic->rotation = ic->graphics = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nint ipu_ic_task_graphics_init(struct ipu_ic *ic,\r\nenum ipu_color_space in_g_cs,\r\nbool galpha_en, u32 galpha,\r\nbool colorkey_en, u32 colorkey)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nu32 reg, ic_conf;\r\nint ret = 0;\r\nif (ic->task == IC_TASK_ENCODER)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nic_conf = ipu_ic_read(ic, IC_CONF);\r\nif (!(ic_conf & ic->bit->ic_conf_csc1_en)) {\r\nret = init_csc(ic, IPUV3_COLORSPACE_RGB,\r\nIPUV3_COLORSPACE_RGB, 0);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nic->g_in_cs = in_g_cs;\r\nif (ic->g_in_cs != ic->out_cs) {\r\nret = init_csc(ic, ic->g_in_cs, ic->out_cs, 1);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nif (galpha_en) {\r\nic_conf |= IC_CONF_IC_GLB_LOC_A;\r\nreg = ipu_ic_read(ic, IC_CMBP_1);\r\nreg &= ~(0xff << ic->bit->ic_cmb_galpha_bit);\r\nreg |= (galpha << ic->bit->ic_cmb_galpha_bit);\r\nipu_ic_write(ic, reg, IC_CMBP_1);\r\n} else\r\nic_conf &= ~IC_CONF_IC_GLB_LOC_A;\r\nif (colorkey_en) {\r\nic_conf |= IC_CONF_KEY_COLOR_EN;\r\nipu_ic_write(ic, colorkey, IC_CMBP_2);\r\n} else\r\nic_conf &= ~IC_CONF_KEY_COLOR_EN;\r\nipu_ic_write(ic, ic_conf, IC_CONF);\r\nic->graphics = true;\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nint ipu_ic_task_init(struct ipu_ic *ic,\r\nint in_width, int in_height,\r\nint out_width, int out_height,\r\nenum ipu_color_space in_cs,\r\nenum ipu_color_space out_cs)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nu32 reg, downsize_coeff, resize_coeff;\r\nunsigned long flags;\r\nint ret = 0;\r\nret = calc_resize_coeffs(ic, in_height, out_height,\r\n&resize_coeff, &downsize_coeff);\r\nif (ret)\r\nreturn ret;\r\nreg = (downsize_coeff << 30) | (resize_coeff << 16);\r\nret = calc_resize_coeffs(ic, in_width, out_width,\r\n&resize_coeff, &downsize_coeff);\r\nif (ret)\r\nreturn ret;\r\nreg |= (downsize_coeff << 14) | resize_coeff;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nipu_ic_write(ic, reg, ic->reg->rsc);\r\nic->in_cs = in_cs;\r\nic->out_cs = out_cs;\r\nif (ic->in_cs != ic->out_cs) {\r\nret = init_csc(ic, ic->in_cs, ic->out_cs, 0);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nint ipu_ic_task_idma_init(struct ipu_ic *ic, struct ipuv3_channel *channel,\r\nu32 width, u32 height, int burst_size,\r\nenum ipu_rotate_mode rot)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nstruct ipu_soc *ipu = priv->ipu;\r\nu32 ic_idmac_1, ic_idmac_2, ic_idmac_3;\r\nu32 temp_rot = bitrev8(rot) >> 5;\r\nbool need_hor_flip = false;\r\nunsigned long flags;\r\nint ret = 0;\r\nif ((burst_size != 8) && (burst_size != 16)) {\r\ndev_err(ipu->dev, "Illegal burst length for IC\n");\r\nreturn -EINVAL;\r\n}\r\nwidth--;\r\nheight--;\r\nif (temp_rot & 0x2)\r\nneed_hor_flip = true;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nic_idmac_1 = ipu_ic_read(ic, IC_IDMAC_1);\r\nic_idmac_2 = ipu_ic_read(ic, IC_IDMAC_2);\r\nic_idmac_3 = ipu_ic_read(ic, IC_IDMAC_3);\r\nswitch (channel->num) {\r\ncase IPUV3_CHANNEL_IC_PP_MEM:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB2_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB2_BURST_16;\r\nif (need_hor_flip)\r\nic_idmac_1 |= IC_IDMAC_1_PP_FLIP_RS;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_PP_FLIP_RS;\r\nic_idmac_2 &= ~IC_IDMAC_2_PP_HEIGHT_MASK;\r\nic_idmac_2 |= height << IC_IDMAC_2_PP_HEIGHT_OFFSET;\r\nic_idmac_3 &= ~IC_IDMAC_3_PP_WIDTH_MASK;\r\nic_idmac_3 |= width << IC_IDMAC_3_PP_WIDTH_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_MEM_IC_PP:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB5_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB5_BURST_16;\r\nbreak;\r\ncase IPUV3_CHANNEL_MEM_ROT_PP:\r\nic_idmac_1 &= ~IC_IDMAC_1_PP_ROT_MASK;\r\nic_idmac_1 |= temp_rot << IC_IDMAC_1_PP_ROT_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_MEM_IC_PRP_VF:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB6_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB6_BURST_16;\r\nbreak;\r\ncase IPUV3_CHANNEL_IC_PRP_ENC_MEM:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB0_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB0_BURST_16;\r\nif (need_hor_flip)\r\nic_idmac_1 |= IC_IDMAC_1_PRPENC_FLIP_RS;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_PRPENC_FLIP_RS;\r\nic_idmac_2 &= ~IC_IDMAC_2_PRPENC_HEIGHT_MASK;\r\nic_idmac_2 |= height << IC_IDMAC_2_PRPENC_HEIGHT_OFFSET;\r\nic_idmac_3 &= ~IC_IDMAC_3_PRPENC_WIDTH_MASK;\r\nic_idmac_3 |= width << IC_IDMAC_3_PRPENC_WIDTH_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_MEM_ROT_ENC:\r\nic_idmac_1 &= ~IC_IDMAC_1_PRPENC_ROT_MASK;\r\nic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPENC_ROT_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_IC_PRP_VF_MEM:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB1_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB1_BURST_16;\r\nif (need_hor_flip)\r\nic_idmac_1 |= IC_IDMAC_1_PRPVF_FLIP_RS;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_PRPVF_FLIP_RS;\r\nic_idmac_2 &= ~IC_IDMAC_2_PRPVF_HEIGHT_MASK;\r\nic_idmac_2 |= height << IC_IDMAC_2_PRPVF_HEIGHT_OFFSET;\r\nic_idmac_3 &= ~IC_IDMAC_3_PRPVF_WIDTH_MASK;\r\nic_idmac_3 |= width << IC_IDMAC_3_PRPVF_WIDTH_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_MEM_ROT_VF:\r\nic_idmac_1 &= ~IC_IDMAC_1_PRPVF_ROT_MASK;\r\nic_idmac_1 |= temp_rot << IC_IDMAC_1_PRPVF_ROT_OFFSET;\r\nbreak;\r\ncase IPUV3_CHANNEL_G_MEM_IC_PRP_VF:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB3_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB3_BURST_16;\r\nbreak;\r\ncase IPUV3_CHANNEL_G_MEM_IC_PP:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB4_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB4_BURST_16;\r\nbreak;\r\ncase IPUV3_CHANNEL_VDI_MEM_IC_VF:\r\nif (burst_size == 16)\r\nic_idmac_1 |= IC_IDMAC_1_CB7_BURST_16;\r\nelse\r\nic_idmac_1 &= ~IC_IDMAC_1_CB7_BURST_16;\r\nbreak;\r\ndefault:\r\ngoto unlock;\r\n}\r\nipu_ic_write(ic, ic_idmac_1, IC_IDMAC_1);\r\nipu_ic_write(ic, ic_idmac_2, IC_IDMAC_2);\r\nipu_ic_write(ic, ic_idmac_3, IC_IDMAC_3);\r\nif (rot >= IPU_ROTATE_90_RIGHT)\r\nic->rotation = true;\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nint ipu_ic_enable(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nu32 module = IPU_CONF_IC_EN;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (ic->rotation)\r\nmodule |= IPU_CONF_ROT_EN;\r\nif (!priv->use_count)\r\nipu_module_enable(priv->ipu, module);\r\npriv->use_count++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_ic_disable(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nu32 module = IPU_CONF_IC_EN | IPU_CONF_ROT_EN;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->use_count--;\r\nif (!priv->use_count)\r\nipu_module_disable(priv->ipu, module);\r\nif (priv->use_count < 0)\r\npriv->use_count = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstruct ipu_ic *ipu_ic_get(struct ipu_soc *ipu, enum ipu_ic_task task)\r\n{\r\nstruct ipu_ic_priv *priv = ipu->ic_priv;\r\nunsigned long flags;\r\nstruct ipu_ic *ic, *ret;\r\nif (task >= IC_NUM_TASKS)\r\nreturn ERR_PTR(-EINVAL);\r\nic = &priv->task[task];\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (ic->in_use) {\r\nret = ERR_PTR(-EBUSY);\r\ngoto unlock;\r\n}\r\nic->in_use = true;\r\nret = ic;\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nvoid ipu_ic_put(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nic->in_use = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nint ipu_ic_init(struct ipu_soc *ipu, struct device *dev,\r\nunsigned long base, unsigned long tpmem_base)\r\n{\r\nstruct ipu_ic_priv *priv;\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nipu->ic_priv = priv;\r\nspin_lock_init(&priv->lock);\r\npriv->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!priv->base)\r\nreturn -ENOMEM;\r\npriv->tpmem_base = devm_ioremap(dev, tpmem_base, SZ_64K);\r\nif (!priv->tpmem_base)\r\nreturn -ENOMEM;\r\ndev_dbg(dev, "IC base: 0x%08lx remapped to %p\n", base, priv->base);\r\npriv->ipu = ipu;\r\nfor (i = 0; i < IC_NUM_TASKS; i++) {\r\npriv->task[i].task = i;\r\npriv->task[i].priv = priv;\r\npriv->task[i].reg = &ic_task_reg[i];\r\npriv->task[i].bit = &ic_task_bit[i];\r\n}\r\nreturn 0;\r\n}\r\nvoid ipu_ic_exit(struct ipu_soc *ipu)\r\n{\r\n}\r\nvoid ipu_ic_dump(struct ipu_ic *ic)\r\n{\r\nstruct ipu_ic_priv *priv = ic->priv;\r\nstruct ipu_soc *ipu = priv->ipu;\r\ndev_dbg(ipu->dev, "IC_CONF = \t0x%08X\n",\r\nipu_ic_read(ic, IC_CONF));\r\ndev_dbg(ipu->dev, "IC_PRP_ENC_RSC = \t0x%08X\n",\r\nipu_ic_read(ic, IC_PRP_ENC_RSC));\r\ndev_dbg(ipu->dev, "IC_PRP_VF_RSC = \t0x%08X\n",\r\nipu_ic_read(ic, IC_PRP_VF_RSC));\r\ndev_dbg(ipu->dev, "IC_PP_RSC = \t0x%08X\n",\r\nipu_ic_read(ic, IC_PP_RSC));\r\ndev_dbg(ipu->dev, "IC_CMBP_1 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_CMBP_1));\r\ndev_dbg(ipu->dev, "IC_CMBP_2 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_CMBP_2));\r\ndev_dbg(ipu->dev, "IC_IDMAC_1 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_IDMAC_1));\r\ndev_dbg(ipu->dev, "IC_IDMAC_2 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_IDMAC_2));\r\ndev_dbg(ipu->dev, "IC_IDMAC_3 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_IDMAC_3));\r\ndev_dbg(ipu->dev, "IC_IDMAC_4 = \t0x%08X\n",\r\nipu_ic_read(ic, IC_IDMAC_4));\r\n}
