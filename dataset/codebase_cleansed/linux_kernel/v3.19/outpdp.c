int\r\nnvkm_output_dp_train(struct nvkm_output *base, u32 datarate, bool wait)\r\n{\r\nstruct nvkm_output_dp *outp = (void *)base;\r\nbool retrain = true;\r\nu8 link[2], stat[3];\r\nu32 linkrate;\r\nint ret, i;\r\nret = nv_rdaux(outp->base.edid, DPCD_LC00_LINK_BW_SET, link, 2);\r\nif (ret) {\r\nDBG("failed to read link config, assuming no sink\n");\r\ngoto done;\r\n}\r\nlinkrate = link[0] * 27000 * (link[1] & DPCD_LC01_LANE_COUNT_SET);\r\nlinkrate = (linkrate * 8) / 10;\r\ndatarate = (datarate + 9) / 10;\r\nif (linkrate < datarate) {\r\nDBG("link not trained at sufficient rate\n");\r\ngoto done;\r\n}\r\nret = nv_rdaux(outp->base.edid, DPCD_LS02, stat, 3);\r\nif (ret) {\r\nDBG("failed to read link status, assuming no sink\n");\r\ngoto done;\r\n}\r\nif (stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE) {\r\nfor (i = 0; i < (link[1] & DPCD_LC01_LANE_COUNT_SET); i++) {\r\nu8 lane = (stat[i >> 1] >> ((i & 1) * 4)) & 0x0f;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED)) {\r\nDBG("lane %d not equalised\n", lane);\r\ngoto done;\r\n}\r\n}\r\nretrain = false;\r\n} else {\r\nDBG("no inter-lane alignment\n");\r\n}\r\ndone:\r\nif (retrain || !atomic_read(&outp->lt.done)) {\r\nif (outp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {\r\noutp->dpcd[DPCD_RC01_MAX_LINK_RATE] =\r\noutp->base.info.dpconf.link_bw;\r\noutp->dpcd[DPCD_RC02] =\r\noutp->base.info.dpconf.link_nr;\r\n}\r\natomic_set(&outp->lt.done, 0);\r\nschedule_work(&outp->lt.work);\r\n} else {\r\nnvkm_notify_get(&outp->irq);\r\n}\r\nif (wait) {\r\nif (!wait_event_timeout(outp->lt.wait,\r\natomic_read(&outp->lt.done),\r\nmsecs_to_jiffies(2000)))\r\nret = -ETIMEDOUT;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnvkm_output_dp_enable(struct nvkm_output_dp *outp, bool present)\r\n{\r\nstruct nouveau_i2c_port *port = outp->base.edid;\r\nif (present) {\r\nif (!outp->present) {\r\nnouveau_i2c(port)->acquire_pad(port, 0);\r\nDBG("aux power -> always\n");\r\noutp->present = true;\r\n}\r\nnvkm_output_dp_train(&outp->base, 0, true);\r\n} else {\r\nif (outp->present) {\r\nnouveau_i2c(port)->release_pad(port);\r\nDBG("aux power -> demand\n");\r\noutp->present = false;\r\n}\r\natomic_set(&outp->lt.done, 0);\r\n}\r\n}\r\nstatic void\r\nnvkm_output_dp_detect(struct nvkm_output_dp *outp)\r\n{\r\nstruct nouveau_i2c_port *port = outp->base.edid;\r\nint ret = nouveau_i2c(port)->acquire_pad(port, 0);\r\nif (ret == 0) {\r\nret = nv_rdaux(outp->base.edid, DPCD_RC00_DPCD_REV,\r\noutp->dpcd, sizeof(outp->dpcd));\r\nnvkm_output_dp_enable(outp, ret == 0);\r\nnouveau_i2c(port)->release_pad(port);\r\n}\r\n}\r\nstatic int\r\nnvkm_output_dp_hpd(struct nvkm_notify *notify)\r\n{\r\nstruct nvkm_connector *conn = container_of(notify, typeof(*conn), hpd);\r\nstruct nvkm_output_dp *outp;\r\nstruct nouveau_disp *disp = nouveau_disp(conn);\r\nconst struct nvkm_i2c_ntfy_rep *line = notify->data;\r\nstruct nvif_notify_conn_rep_v0 rep = {};\r\nlist_for_each_entry(outp, &disp->outp, base.head) {\r\nif (outp->base.conn == conn &&\r\noutp->info.type == DCB_OUTPUT_DP) {\r\nDBG("HPD: %d\n", line->mask);\r\nnvkm_output_dp_detect(outp);\r\nif (line->mask & NVKM_I2C_UNPLUG)\r\nrep.mask |= NVIF_NOTIFY_CONN_V0_UNPLUG;\r\nif (line->mask & NVKM_I2C_PLUG)\r\nrep.mask |= NVIF_NOTIFY_CONN_V0_PLUG;\r\nnvkm_event_send(&disp->hpd, rep.mask, conn->index,\r\n&rep, sizeof(rep));\r\nreturn NVKM_NOTIFY_KEEP;\r\n}\r\n}\r\nWARN_ON(1);\r\nreturn NVKM_NOTIFY_DROP;\r\n}\r\nstatic int\r\nnvkm_output_dp_irq(struct nvkm_notify *notify)\r\n{\r\nstruct nvkm_output_dp *outp = container_of(notify, typeof(*outp), irq);\r\nstruct nouveau_disp *disp = nouveau_disp(outp);\r\nconst struct nvkm_i2c_ntfy_rep *line = notify->data;\r\nstruct nvif_notify_conn_rep_v0 rep = {\r\n.mask = NVIF_NOTIFY_CONN_V0_IRQ,\r\n};\r\nint index = outp->base.info.connector;\r\nDBG("IRQ: %d\n", line->mask);\r\nnvkm_output_dp_train(&outp->base, 0, true);\r\nnvkm_event_send(&disp->hpd, rep.mask, index, &rep, sizeof(rep));\r\nreturn NVKM_NOTIFY_DROP;\r\n}\r\nint\r\n_nvkm_output_dp_fini(struct nouveau_object *object, bool suspend)\r\n{\r\nstruct nvkm_output_dp *outp = (void *)object;\r\nnvkm_notify_put(&outp->irq);\r\nnvkm_output_dp_enable(outp, false);\r\nreturn nvkm_output_fini(&outp->base, suspend);\r\n}\r\nint\r\n_nvkm_output_dp_init(struct nouveau_object *object)\r\n{\r\nstruct nvkm_output_dp *outp = (void *)object;\r\nnvkm_output_dp_detect(outp);\r\nreturn nvkm_output_init(&outp->base);\r\n}\r\nvoid\r\n_nvkm_output_dp_dtor(struct nouveau_object *object)\r\n{\r\nstruct nvkm_output_dp *outp = (void *)object;\r\nnvkm_notify_fini(&outp->irq);\r\nnvkm_output_destroy(&outp->base);\r\n}\r\nint\r\nnvkm_output_dp_create_(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass,\r\nstruct dcb_output *info, int index,\r\nint length, void **pobject)\r\n{\r\nstruct nouveau_bios *bios = nouveau_bios(parent);\r\nstruct nouveau_i2c *i2c = nouveau_i2c(parent);\r\nstruct nvkm_output_dp *outp;\r\nu8 hdr, cnt, len;\r\nu32 data;\r\nint ret;\r\nret = nvkm_output_create_(parent, engine, oclass, info, index,\r\nlength, pobject);\r\noutp = *pobject;\r\nif (ret)\r\nreturn ret;\r\nnvkm_notify_fini(&outp->base.conn->hpd);\r\nif (!outp->base.edid) {\r\nERR("aux channel not found\n");\r\nreturn -ENODEV;\r\n}\r\ndata = nvbios_dpout_match(bios, outp->base.info.hasht,\r\noutp->base.info.hashm, &outp->version,\r\n&hdr, &cnt, &len, &outp->info);\r\nif (!data) {\r\nERR("no bios dp data\n");\r\nreturn -ENODEV;\r\n}\r\nDBG("bios dp %02x %02x %02x %02x\n", outp->version, hdr, cnt, len);\r\nINIT_WORK(&outp->lt.work, nouveau_dp_train);\r\ninit_waitqueue_head(&outp->lt.wait);\r\natomic_set(&outp->lt.done, 0);\r\nret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_irq, true,\r\n&(struct nvkm_i2c_ntfy_req) {\r\n.mask = NVKM_I2C_IRQ,\r\n.port = outp->base.edid->index,\r\n},\r\nsizeof(struct nvkm_i2c_ntfy_req),\r\nsizeof(struct nvkm_i2c_ntfy_rep),\r\n&outp->irq);\r\nif (ret) {\r\nERR("error monitoring aux irq event: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_hpd, true,\r\n&(struct nvkm_i2c_ntfy_req) {\r\n.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG,\r\n.port = outp->base.edid->index,\r\n},\r\nsizeof(struct nvkm_i2c_ntfy_req),\r\nsizeof(struct nvkm_i2c_ntfy_rep),\r\n&outp->base.conn->hpd);\r\nif (ret) {\r\nERR("error monitoring aux hpd events: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint\r\n_nvkm_output_dp_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *info, u32 index,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nvkm_output_dp *outp;\r\nint ret;\r\nret = nvkm_output_dp_create(parent, engine, oclass, info, index, &outp);\r\n*pobject = nv_object(outp);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
