static void\r\nstart_spi_intr_handling(struct qcaspi *qca, u16 *intr_cause)\r\n{\r\n*intr_cause = 0;\r\nqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, 0);\r\nqcaspi_read_register(qca, SPI_REG_INTR_CAUSE, intr_cause);\r\nnetdev_dbg(qca->net_dev, "interrupts: 0x%04x\n", *intr_cause);\r\n}\r\nstatic void\r\nend_spi_intr_handling(struct qcaspi *qca, u16 intr_cause)\r\n{\r\nu16 intr_enable = (SPI_INT_CPU_ON |\r\nSPI_INT_PKT_AVLBL |\r\nSPI_INT_RDBUF_ERR |\r\nSPI_INT_WRBUF_ERR);\r\nqcaspi_write_register(qca, SPI_REG_INTR_CAUSE, intr_cause);\r\nqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, intr_enable);\r\nnetdev_dbg(qca->net_dev, "acking int: 0x%04x\n", intr_cause);\r\n}\r\nstatic u32\r\nqcaspi_write_burst(struct qcaspi *qca, u8 *src, u32 len)\r\n{\r\n__be16 cmd;\r\nstruct spi_message *msg = &qca->spi_msg2;\r\nstruct spi_transfer *transfer = &qca->spi_xfer2[0];\r\nint ret;\r\ncmd = cpu_to_be16(QCA7K_SPI_WRITE | QCA7K_SPI_EXTERNAL);\r\ntransfer->tx_buf = &cmd;\r\ntransfer->rx_buf = NULL;\r\ntransfer->len = QCASPI_CMD_LEN;\r\ntransfer = &qca->spi_xfer2[1];\r\ntransfer->tx_buf = src;\r\ntransfer->rx_buf = NULL;\r\ntransfer->len = len;\r\nret = spi_sync(qca->spi_dev, msg);\r\nif (ret || (msg->actual_length != QCASPI_CMD_LEN + len)) {\r\nqcaspi_spi_error(qca);\r\nreturn 0;\r\n}\r\nreturn len;\r\n}\r\nstatic u32\r\nqcaspi_write_legacy(struct qcaspi *qca, u8 *src, u32 len)\r\n{\r\nstruct spi_message *msg = &qca->spi_msg1;\r\nstruct spi_transfer *transfer = &qca->spi_xfer1;\r\nint ret;\r\ntransfer->tx_buf = src;\r\ntransfer->rx_buf = NULL;\r\ntransfer->len = len;\r\nret = spi_sync(qca->spi_dev, msg);\r\nif (ret || (msg->actual_length != len)) {\r\nqcaspi_spi_error(qca);\r\nreturn 0;\r\n}\r\nreturn len;\r\n}\r\nstatic u32\r\nqcaspi_read_burst(struct qcaspi *qca, u8 *dst, u32 len)\r\n{\r\nstruct spi_message *msg = &qca->spi_msg2;\r\n__be16 cmd;\r\nstruct spi_transfer *transfer = &qca->spi_xfer2[0];\r\nint ret;\r\ncmd = cpu_to_be16(QCA7K_SPI_READ | QCA7K_SPI_EXTERNAL);\r\ntransfer->tx_buf = &cmd;\r\ntransfer->rx_buf = NULL;\r\ntransfer->len = QCASPI_CMD_LEN;\r\ntransfer = &qca->spi_xfer2[1];\r\ntransfer->tx_buf = NULL;\r\ntransfer->rx_buf = dst;\r\ntransfer->len = len;\r\nret = spi_sync(qca->spi_dev, msg);\r\nif (ret || (msg->actual_length != QCASPI_CMD_LEN + len)) {\r\nqcaspi_spi_error(qca);\r\nreturn 0;\r\n}\r\nreturn len;\r\n}\r\nstatic u32\r\nqcaspi_read_legacy(struct qcaspi *qca, u8 *dst, u32 len)\r\n{\r\nstruct spi_message *msg = &qca->spi_msg1;\r\nstruct spi_transfer *transfer = &qca->spi_xfer1;\r\nint ret;\r\ntransfer->tx_buf = NULL;\r\ntransfer->rx_buf = dst;\r\ntransfer->len = len;\r\nret = spi_sync(qca->spi_dev, msg);\r\nif (ret || (msg->actual_length != len)) {\r\nqcaspi_spi_error(qca);\r\nreturn 0;\r\n}\r\nreturn len;\r\n}\r\nstatic int\r\nqcaspi_tx_frame(struct qcaspi *qca, struct sk_buff *skb)\r\n{\r\nu32 count;\r\nu32 written;\r\nu32 offset;\r\nu32 len;\r\nlen = skb->len;\r\nqcaspi_write_register(qca, SPI_REG_BFR_SIZE, len);\r\nif (qca->legacy_mode)\r\nqcaspi_tx_cmd(qca, QCA7K_SPI_WRITE | QCA7K_SPI_EXTERNAL);\r\noffset = 0;\r\nwhile (len) {\r\ncount = len;\r\nif (count > qca->burst_len)\r\ncount = qca->burst_len;\r\nif (qca->legacy_mode) {\r\nwritten = qcaspi_write_legacy(qca,\r\nskb->data + offset,\r\ncount);\r\n} else {\r\nwritten = qcaspi_write_burst(qca,\r\nskb->data + offset,\r\ncount);\r\n}\r\nif (written != count)\r\nreturn -1;\r\noffset += count;\r\nlen -= count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqcaspi_transmit(struct qcaspi *qca)\r\n{\r\nstruct net_device_stats *n_stats = &qca->net_dev->stats;\r\nu16 available = 0;\r\nu32 pkt_len;\r\nu16 new_head;\r\nu16 packets = 0;\r\nif (qca->txr.skb[qca->txr.head] == NULL)\r\nreturn 0;\r\nqcaspi_read_register(qca, SPI_REG_WRBUF_SPC_AVA, &available);\r\nwhile (qca->txr.skb[qca->txr.head]) {\r\npkt_len = qca->txr.skb[qca->txr.head]->len + QCASPI_HW_PKT_LEN;\r\nif (available < pkt_len) {\r\nif (packets == 0)\r\nqca->stats.write_buf_miss++;\r\nbreak;\r\n}\r\nif (qcaspi_tx_frame(qca, qca->txr.skb[qca->txr.head]) == -1) {\r\nqca->stats.write_err++;\r\nreturn -1;\r\n}\r\npackets++;\r\nn_stats->tx_packets++;\r\nn_stats->tx_bytes += qca->txr.skb[qca->txr.head]->len;\r\navailable -= pkt_len;\r\nnetif_tx_lock_bh(qca->net_dev);\r\ndev_kfree_skb(qca->txr.skb[qca->txr.head]);\r\nqca->txr.skb[qca->txr.head] = NULL;\r\nqca->txr.size -= pkt_len;\r\nnew_head = qca->txr.head + 1;\r\nif (new_head >= qca->txr.count)\r\nnew_head = 0;\r\nqca->txr.head = new_head;\r\nif (netif_queue_stopped(qca->net_dev))\r\nnetif_wake_queue(qca->net_dev);\r\nnetif_tx_unlock_bh(qca->net_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqcaspi_receive(struct qcaspi *qca)\r\n{\r\nstruct net_device *net_dev = qca->net_dev;\r\nstruct net_device_stats *n_stats = &net_dev->stats;\r\nu16 available = 0;\r\nu32 bytes_read;\r\nu8 *cp;\r\nif (!qca->rx_skb) {\r\nqca->rx_skb = netdev_alloc_skb(net_dev,\r\nnet_dev->mtu + VLAN_ETH_HLEN);\r\nif (!qca->rx_skb) {\r\nnetdev_dbg(net_dev, "out of RX resources\n");\r\nqca->stats.out_of_mem++;\r\nreturn -1;\r\n}\r\n}\r\nqcaspi_read_register(qca, SPI_REG_RDBUF_BYTE_AVA, &available);\r\nnetdev_dbg(net_dev, "qcaspi_receive: SPI_REG_RDBUF_BYTE_AVA: Value: %08x\n",\r\navailable);\r\nif (available == 0) {\r\nnetdev_dbg(net_dev, "qcaspi_receive called without any data being available!\n");\r\nreturn -1;\r\n}\r\nqcaspi_write_register(qca, SPI_REG_BFR_SIZE, available);\r\nif (qca->legacy_mode)\r\nqcaspi_tx_cmd(qca, QCA7K_SPI_READ | QCA7K_SPI_EXTERNAL);\r\nwhile (available) {\r\nu32 count = available;\r\nif (count > qca->burst_len)\r\ncount = qca->burst_len;\r\nif (qca->legacy_mode) {\r\nbytes_read = qcaspi_read_legacy(qca, qca->rx_buffer,\r\ncount);\r\n} else {\r\nbytes_read = qcaspi_read_burst(qca, qca->rx_buffer,\r\ncount);\r\n}\r\nnetdev_dbg(net_dev, "available: %d, byte read: %d\n",\r\navailable, bytes_read);\r\nif (bytes_read) {\r\navailable -= bytes_read;\r\n} else {\r\nqca->stats.read_err++;\r\nreturn -1;\r\n}\r\ncp = qca->rx_buffer;\r\nwhile ((bytes_read--) && (qca->rx_skb)) {\r\ns32 retcode;\r\nretcode = qcafrm_fsm_decode(&qca->frm_handle,\r\nqca->rx_skb->data,\r\nskb_tailroom(qca->rx_skb),\r\n*cp);\r\ncp++;\r\nswitch (retcode) {\r\ncase QCAFRM_GATHER:\r\ncase QCAFRM_NOHEAD:\r\nbreak;\r\ncase QCAFRM_NOTAIL:\r\nnetdev_dbg(net_dev, "no RX tail\n");\r\nn_stats->rx_errors++;\r\nn_stats->rx_dropped++;\r\nbreak;\r\ncase QCAFRM_INVLEN:\r\nnetdev_dbg(net_dev, "invalid RX length\n");\r\nn_stats->rx_errors++;\r\nn_stats->rx_dropped++;\r\nbreak;\r\ndefault:\r\nqca->rx_skb->dev = qca->net_dev;\r\nn_stats->rx_packets++;\r\nn_stats->rx_bytes += retcode;\r\nskb_put(qca->rx_skb, retcode);\r\nqca->rx_skb->protocol = eth_type_trans(\r\nqca->rx_skb, qca->rx_skb->dev);\r\nqca->rx_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_rx_ni(qca->rx_skb);\r\nqca->rx_skb = netdev_alloc_skb(net_dev,\r\nnet_dev->mtu + VLAN_ETH_HLEN);\r\nif (!qca->rx_skb) {\r\nnetdev_dbg(net_dev, "out of RX resources\n");\r\nn_stats->rx_errors++;\r\nqca->stats.out_of_mem++;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqcaspi_tx_ring_has_space(struct tx_ring *txr)\r\n{\r\nif (txr->skb[txr->tail])\r\nreturn 0;\r\nreturn (txr->size + QCAFRM_ETHMAXLEN < QCASPI_HW_BUF_LEN) ? 1 : 0;\r\n}\r\nstatic void\r\nqcaspi_flush_tx_ring(struct qcaspi *qca)\r\n{\r\nint i;\r\nnetif_tx_lock_bh(qca->net_dev);\r\nfor (i = 0; i < TX_RING_MAX_LEN; i++) {\r\nif (qca->txr.skb[i]) {\r\ndev_kfree_skb(qca->txr.skb[i]);\r\nqca->txr.skb[i] = NULL;\r\nqca->net_dev->stats.tx_dropped++;\r\n}\r\n}\r\nqca->txr.tail = 0;\r\nqca->txr.head = 0;\r\nqca->txr.size = 0;\r\nnetif_tx_unlock_bh(qca->net_dev);\r\n}\r\nstatic void\r\nqcaspi_qca7k_sync(struct qcaspi *qca, int event)\r\n{\r\nu16 signature = 0;\r\nu16 spi_config;\r\nu16 wrbuf_space = 0;\r\nstatic u16 reset_count;\r\nif (event == QCASPI_EVENT_CPUON) {\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nif (signature != QCASPI_GOOD_SIGNATURE) {\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\nnetdev_dbg(qca->net_dev, "sync: got CPU on, but signature was invalid, restart\n");\r\n} else {\r\nqcaspi_read_register(qca, SPI_REG_WRBUF_SPC_AVA,\r\n&wrbuf_space);\r\nif (wrbuf_space != QCASPI_HW_BUF_LEN) {\r\nnetdev_dbg(qca->net_dev, "sync: got CPU on, but wrbuf not empty. reset!\n");\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\n} else {\r\nnetdev_dbg(qca->net_dev, "sync: got CPU on, now in sync\n");\r\nqca->sync = QCASPI_SYNC_READY;\r\nreturn;\r\n}\r\n}\r\n}\r\nswitch (qca->sync) {\r\ncase QCASPI_SYNC_READY:\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nif (signature != QCASPI_GOOD_SIGNATURE) {\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\nnetdev_dbg(qca->net_dev, "sync: bad signature, restart\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase QCASPI_SYNC_UNKNOWN:\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nif (signature != QCASPI_GOOD_SIGNATURE) {\r\nnetdev_dbg(qca->net_dev, "sync: could not read signature to reset device, retry.\n");\r\nreturn;\r\n}\r\nnetdev_dbg(qca->net_dev, "sync: resetting device.\n");\r\nqcaspi_read_register(qca, SPI_REG_SPI_CONFIG, &spi_config);\r\nspi_config |= QCASPI_SLAVE_RESET_BIT;\r\nqcaspi_write_register(qca, SPI_REG_SPI_CONFIG, spi_config);\r\nqca->sync = QCASPI_SYNC_RESET;\r\nqca->stats.trig_reset++;\r\nreset_count = 0;\r\nbreak;\r\ncase QCASPI_SYNC_RESET:\r\nreset_count++;\r\nnetdev_dbg(qca->net_dev, "sync: waiting for CPU on, count %u.\n",\r\nreset_count);\r\nif (reset_count >= QCASPI_RESET_TIMEOUT) {\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\nqca->stats.reset_timeout++;\r\nnetdev_dbg(qca->net_dev, "sync: reset timeout, restarting process.\n");\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqcaspi_spi_thread(void *data)\r\n{\r\nstruct qcaspi *qca = data;\r\nu16 intr_cause = 0;\r\nnetdev_info(qca->net_dev, "SPI thread created\n");\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif ((qca->intr_req == qca->intr_svc) &&\r\n(qca->txr.skb[qca->txr.head] == NULL) &&\r\n(qca->sync == QCASPI_SYNC_READY))\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nnetdev_dbg(qca->net_dev, "have work to do. int: %d, tx_skb: %p\n",\r\nqca->intr_req - qca->intr_svc,\r\nqca->txr.skb[qca->txr.head]);\r\nqcaspi_qca7k_sync(qca, QCASPI_EVENT_UPDATE);\r\nif (qca->sync != QCASPI_SYNC_READY) {\r\nnetdev_dbg(qca->net_dev, "sync: not ready %u, turn off carrier and flush\n",\r\n(unsigned int)qca->sync);\r\nnetif_stop_queue(qca->net_dev);\r\nnetif_carrier_off(qca->net_dev);\r\nqcaspi_flush_tx_ring(qca);\r\nmsleep(QCASPI_QCA7K_REBOOT_TIME_MS);\r\n}\r\nif (qca->intr_svc != qca->intr_req) {\r\nqca->intr_svc = qca->intr_req;\r\nstart_spi_intr_handling(qca, &intr_cause);\r\nif (intr_cause & SPI_INT_CPU_ON) {\r\nqcaspi_qca7k_sync(qca, QCASPI_EVENT_CPUON);\r\nif (qca->sync != QCASPI_SYNC_READY)\r\ncontinue;\r\nqca->stats.device_reset++;\r\nnetif_wake_queue(qca->net_dev);\r\nnetif_carrier_on(qca->net_dev);\r\n}\r\nif (intr_cause & SPI_INT_RDBUF_ERR) {\r\nnetdev_dbg(qca->net_dev, "===> rdbuf error!\n");\r\nqca->stats.read_buf_err++;\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\ncontinue;\r\n}\r\nif (intr_cause & SPI_INT_WRBUF_ERR) {\r\nnetdev_dbg(qca->net_dev, "===> wrbuf error!\n");\r\nqca->stats.write_buf_err++;\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\ncontinue;\r\n}\r\nif (qca->sync == QCASPI_SYNC_READY) {\r\nif (intr_cause & SPI_INT_PKT_AVLBL)\r\nqcaspi_receive(qca);\r\n}\r\nend_spi_intr_handling(qca, intr_cause);\r\n}\r\nif (qca->sync == QCASPI_SYNC_READY)\r\nqcaspi_transmit(qca);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nnetdev_info(qca->net_dev, "SPI thread exit\n");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nqcaspi_intr_handler(int irq, void *data)\r\n{\r\nstruct qcaspi *qca = data;\r\nqca->intr_req++;\r\nif (qca->spi_thread &&\r\nqca->spi_thread->state != TASK_RUNNING)\r\nwake_up_process(qca->spi_thread);\r\nreturn IRQ_HANDLED;\r\n}\r\nint\r\nqcaspi_netdev_open(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nint ret = 0;\r\nif (!qca)\r\nreturn -EINVAL;\r\nqca->intr_req = 1;\r\nqca->intr_svc = 0;\r\nqca->sync = QCASPI_SYNC_UNKNOWN;\r\nqcafrm_fsm_init(&qca->frm_handle);\r\nqca->spi_thread = kthread_run((void *)qcaspi_spi_thread,\r\nqca, "%s", dev->name);\r\nif (IS_ERR(qca->spi_thread)) {\r\nnetdev_err(dev, "%s: unable to start kernel thread.\n",\r\nQCASPI_DRV_NAME);\r\nreturn PTR_ERR(qca->spi_thread);\r\n}\r\nret = request_irq(qca->spi_dev->irq, qcaspi_intr_handler, 0,\r\ndev->name, qca);\r\nif (ret) {\r\nnetdev_err(dev, "%s: unable to get IRQ %d (irqval=%d).\n",\r\nQCASPI_DRV_NAME, qca->spi_dev->irq, ret);\r\nkthread_stop(qca->spi_thread);\r\nreturn ret;\r\n}\r\nnetif_start_queue(qca->net_dev);\r\nreturn 0;\r\n}\r\nint\r\nqcaspi_netdev_close(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, 0);\r\nfree_irq(qca->spi_dev->irq, qca);\r\nkthread_stop(qca->spi_thread);\r\nqca->spi_thread = NULL;\r\nqcaspi_flush_tx_ring(qca);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\nqcaspi_netdev_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nu32 frame_len;\r\nu8 *ptmp;\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nu16 new_tail;\r\nstruct sk_buff *tskb;\r\nu8 pad_len = 0;\r\nif (skb->len < QCAFRM_ETHMINLEN)\r\npad_len = QCAFRM_ETHMINLEN - skb->len;\r\nif (qca->txr.skb[qca->txr.tail]) {\r\nnetdev_warn(qca->net_dev, "queue was unexpectedly full!\n");\r\nnetif_stop_queue(qca->net_dev);\r\nqca->stats.ring_full++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif ((skb_headroom(skb) < QCAFRM_HEADER_LEN) ||\r\n(skb_tailroom(skb) < QCAFRM_FOOTER_LEN + pad_len)) {\r\ntskb = skb_copy_expand(skb, QCAFRM_HEADER_LEN,\r\nQCAFRM_FOOTER_LEN + pad_len, GFP_ATOMIC);\r\nif (!tskb) {\r\nnetdev_dbg(qca->net_dev, "could not allocate tx_buff\n");\r\nqca->stats.out_of_mem++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndev_kfree_skb(skb);\r\nskb = tskb;\r\n}\r\nframe_len = skb->len + pad_len;\r\nptmp = skb_push(skb, QCAFRM_HEADER_LEN);\r\nqcafrm_create_header(ptmp, frame_len);\r\nif (pad_len) {\r\nptmp = skb_put(skb, pad_len);\r\nmemset(ptmp, 0, pad_len);\r\n}\r\nptmp = skb_put(skb, QCAFRM_FOOTER_LEN);\r\nqcafrm_create_footer(ptmp);\r\nnetdev_dbg(qca->net_dev, "Tx-ing packet: Size: 0x%08x\n",\r\nskb->len);\r\nqca->txr.size += skb->len + QCASPI_HW_PKT_LEN;\r\nnew_tail = qca->txr.tail + 1;\r\nif (new_tail >= qca->txr.count)\r\nnew_tail = 0;\r\nqca->txr.skb[qca->txr.tail] = skb;\r\nqca->txr.tail = new_tail;\r\nif (!qcaspi_tx_ring_has_space(&qca->txr)) {\r\nnetif_stop_queue(qca->net_dev);\r\nqca->stats.ring_full++;\r\n}\r\ndev->trans_start = jiffies;\r\nif (qca->spi_thread &&\r\nqca->spi_thread->state != TASK_RUNNING)\r\nwake_up_process(qca->spi_thread);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nqcaspi_netdev_tx_timeout(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nnetdev_info(qca->net_dev, "Transmit timeout at %ld, latency %ld\n",\r\njiffies, jiffies - dev->trans_start);\r\nqca->net_dev->stats.tx_errors++;\r\nif (qcaspi_tx_ring_has_space(&qca->txr))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nqcaspi_netdev_init(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\ndev->mtu = QCASPI_MTU;\r\ndev->type = ARPHRD_ETHER;\r\nqca->clkspeed = qcaspi_clkspeed;\r\nqca->burst_len = qcaspi_burst_len;\r\nqca->spi_thread = NULL;\r\nqca->buffer_size = (dev->mtu + VLAN_ETH_HLEN + QCAFRM_HEADER_LEN +\r\nQCAFRM_FOOTER_LEN + 4) * 4;\r\nmemset(&qca->stats, 0, sizeof(struct qcaspi_stats));\r\nqca->rx_buffer = kmalloc(qca->buffer_size, GFP_KERNEL);\r\nif (!qca->rx_buffer)\r\nreturn -ENOBUFS;\r\nqca->rx_skb = netdev_alloc_skb(dev, qca->net_dev->mtu + VLAN_ETH_HLEN);\r\nif (!qca->rx_skb) {\r\nkfree(qca->rx_buffer);\r\nnetdev_info(qca->net_dev, "Failed to allocate RX sk_buff.\n");\r\nreturn -ENOBUFS;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqcaspi_netdev_uninit(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nkfree(qca->rx_buffer);\r\nqca->buffer_size = 0;\r\nif (qca->rx_skb)\r\ndev_kfree_skb(qca->rx_skb);\r\n}\r\nstatic int\r\nqcaspi_netdev_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < QCAFRM_ETHMINMTU) || (new_mtu > QCAFRM_ETHMAXMTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void\r\nqcaspi_netdev_setup(struct net_device *dev)\r\n{\r\nstruct qcaspi *qca = NULL;\r\ndev->netdev_ops = &qcaspi_netdev_ops;\r\nqcaspi_set_ethtool_ops(dev);\r\ndev->watchdog_timeo = QCASPI_TX_TIMEOUT;\r\ndev->flags = IFF_MULTICAST;\r\ndev->tx_queue_len = 100;\r\nqca = netdev_priv(dev);\r\nmemset(qca, 0, sizeof(struct qcaspi));\r\nmemset(&qca->spi_xfer1, 0, sizeof(struct spi_transfer));\r\nmemset(&qca->spi_xfer2, 0, sizeof(struct spi_transfer) * 2);\r\nspi_message_init(&qca->spi_msg1);\r\nspi_message_add_tail(&qca->spi_xfer1, &qca->spi_msg1);\r\nspi_message_init(&qca->spi_msg2);\r\nspi_message_add_tail(&qca->spi_xfer2[0], &qca->spi_msg2);\r\nspi_message_add_tail(&qca->spi_xfer2[1], &qca->spi_msg2);\r\nmemset(&qca->txr, 0, sizeof(qca->txr));\r\nqca->txr.count = TX_RING_MAX_LEN;\r\n}\r\nstatic int\r\nqca_spi_probe(struct spi_device *spi_device)\r\n{\r\nstruct qcaspi *qca = NULL;\r\nstruct net_device *qcaspi_devs = NULL;\r\nu8 legacy_mode = 0;\r\nu16 signature;\r\nconst char *mac;\r\nif (!spi_device->dev.of_node) {\r\ndev_err(&spi_device->dev, "Missing device tree\n");\r\nreturn -EINVAL;\r\n}\r\nlegacy_mode = of_property_read_bool(spi_device->dev.of_node,\r\n"qca,legacy-mode");\r\nif (qcaspi_clkspeed == 0) {\r\nif (spi_device->max_speed_hz)\r\nqcaspi_clkspeed = spi_device->max_speed_hz;\r\nelse\r\nqcaspi_clkspeed = QCASPI_CLK_SPEED;\r\n}\r\nif ((qcaspi_clkspeed < QCASPI_CLK_SPEED_MIN) ||\r\n(qcaspi_clkspeed > QCASPI_CLK_SPEED_MAX)) {\r\ndev_info(&spi_device->dev, "Invalid clkspeed: %d\n",\r\nqcaspi_clkspeed);\r\nreturn -EINVAL;\r\n}\r\nif ((qcaspi_burst_len < QCASPI_BURST_LEN_MIN) ||\r\n(qcaspi_burst_len > QCASPI_BURST_LEN_MAX)) {\r\ndev_info(&spi_device->dev, "Invalid burst len: %d\n",\r\nqcaspi_burst_len);\r\nreturn -EINVAL;\r\n}\r\nif ((qcaspi_pluggable < QCASPI_PLUGGABLE_MIN) ||\r\n(qcaspi_pluggable > QCASPI_PLUGGABLE_MAX)) {\r\ndev_info(&spi_device->dev, "Invalid pluggable: %d\n",\r\nqcaspi_pluggable);\r\nreturn -EINVAL;\r\n}\r\ndev_info(&spi_device->dev, "ver=%s, clkspeed=%d, burst_len=%d, pluggable=%d\n",\r\nQCASPI_DRV_VERSION,\r\nqcaspi_clkspeed,\r\nqcaspi_burst_len,\r\nqcaspi_pluggable);\r\nspi_device->mode = SPI_MODE_3;\r\nspi_device->max_speed_hz = qcaspi_clkspeed;\r\nif (spi_setup(spi_device) < 0) {\r\ndev_err(&spi_device->dev, "Unable to setup SPI device\n");\r\nreturn -EFAULT;\r\n}\r\nqcaspi_devs = alloc_etherdev(sizeof(struct qcaspi));\r\nif (!qcaspi_devs)\r\nreturn -ENOMEM;\r\nqcaspi_netdev_setup(qcaspi_devs);\r\nqca = netdev_priv(qcaspi_devs);\r\nif (!qca) {\r\nfree_netdev(qcaspi_devs);\r\ndev_err(&spi_device->dev, "Fail to retrieve private structure\n");\r\nreturn -ENOMEM;\r\n}\r\nqca->net_dev = qcaspi_devs;\r\nqca->spi_dev = spi_device;\r\nqca->legacy_mode = legacy_mode;\r\nmac = of_get_mac_address(spi_device->dev.of_node);\r\nif (mac)\r\nether_addr_copy(qca->net_dev->dev_addr, mac);\r\nif (!is_valid_ether_addr(qca->net_dev->dev_addr)) {\r\neth_hw_addr_random(qca->net_dev);\r\ndev_info(&spi_device->dev, "Using random MAC address: %pM\n",\r\nqca->net_dev->dev_addr);\r\n}\r\nnetif_carrier_off(qca->net_dev);\r\nif (!qcaspi_pluggable) {\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\r\nif (signature != QCASPI_GOOD_SIGNATURE) {\r\ndev_err(&spi_device->dev, "Invalid signature (0x%04X)\n",\r\nsignature);\r\nfree_netdev(qcaspi_devs);\r\nreturn -EFAULT;\r\n}\r\n}\r\nif (register_netdev(qcaspi_devs)) {\r\ndev_info(&spi_device->dev, "Unable to register net device %s\n",\r\nqcaspi_devs->name);\r\nfree_netdev(qcaspi_devs);\r\nreturn -EFAULT;\r\n}\r\nspi_set_drvdata(spi_device, qcaspi_devs);\r\nqcaspi_init_device_debugfs(qca);\r\nreturn 0;\r\n}\r\nstatic int\r\nqca_spi_remove(struct spi_device *spi_device)\r\n{\r\nstruct net_device *qcaspi_devs = spi_get_drvdata(spi_device);\r\nstruct qcaspi *qca = netdev_priv(qcaspi_devs);\r\nqcaspi_remove_device_debugfs(qca);\r\nunregister_netdev(qcaspi_devs);\r\nfree_netdev(qcaspi_devs);\r\nreturn 0;\r\n}
