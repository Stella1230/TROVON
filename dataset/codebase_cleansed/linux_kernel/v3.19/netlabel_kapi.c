int netlbl_cfg_map_del(const char *domain,\r\nu16 family,\r\nconst void *addr,\r\nconst void *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nif (addr == NULL && mask == NULL) {\r\nreturn netlbl_domhsh_remove(domain, audit_info);\r\n} else if (addr != NULL && mask != NULL) {\r\nswitch (family) {\r\ncase AF_INET:\r\nreturn netlbl_domhsh_remove_af4(domain, addr, mask,\r\naudit_info);\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\n} else\r\nreturn -EINVAL;\r\n}\r\nint netlbl_cfg_unlbl_map_add(const char *domain,\r\nu16 family,\r\nconst void *addr,\r\nconst void *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct netlbl_dom_map *entry;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct netlbl_domaddr4_map *map4 = NULL;\r\nstruct netlbl_domaddr6_map *map6 = NULL;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nif (domain != NULL) {\r\nentry->domain = kstrdup(domain, GFP_ATOMIC);\r\nif (entry->domain == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\n}\r\nif (addr == NULL && mask == NULL)\r\nentry->def.type = NETLBL_NLTYPE_UNLABELED;\r\nelse if (addr != NULL && mask != NULL) {\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\r\nif (addrmap == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nswitch (family) {\r\ncase AF_INET: {\r\nconst struct in_addr *addr4 = addr;\r\nconst struct in_addr *mask4 = mask;\r\nmap4 = kzalloc(sizeof(*map4), GFP_ATOMIC);\r\nif (map4 == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nmap4->def.type = NETLBL_NLTYPE_UNLABELED;\r\nmap4->list.addr = addr4->s_addr & mask4->s_addr;\r\nmap4->list.mask = mask4->s_addr;\r\nmap4->list.valid = 1;\r\nret_val = netlbl_af4list_add(&map4->list,\r\n&addrmap->list4);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nbreak;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6: {\r\nconst struct in6_addr *addr6 = addr;\r\nconst struct in6_addr *mask6 = mask;\r\nmap6 = kzalloc(sizeof(*map6), GFP_ATOMIC);\r\nif (map6 == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nmap6->def.type = NETLBL_NLTYPE_UNLABELED;\r\nmap6->list.addr = *addr6;\r\nmap6->list.addr.s6_addr32[0] &= mask6->s6_addr32[0];\r\nmap6->list.addr.s6_addr32[1] &= mask6->s6_addr32[1];\r\nmap6->list.addr.s6_addr32[2] &= mask6->s6_addr32[2];\r\nmap6->list.addr.s6_addr32[3] &= mask6->s6_addr32[3];\r\nmap6->list.mask = *mask6;\r\nmap6->list.valid = 1;\r\nret_val = netlbl_af6list_add(&map6->list,\r\n&addrmap->list6);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\ngoto cfg_unlbl_map_add_failure;\r\n}\r\nentry->def.addrsel = addrmap;\r\nentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\r\n} else {\r\nret_val = -EINVAL;\r\ngoto cfg_unlbl_map_add_failure;\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nreturn 0;\r\ncfg_unlbl_map_add_failure:\r\nkfree(entry->domain);\r\nkfree(entry);\r\nkfree(addrmap);\r\nkfree(map4);\r\nkfree(map6);\r\nreturn ret_val;\r\n}\r\nint netlbl_cfg_unlbl_static_add(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu16 family,\r\nu32 secid,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nu32 addr_len;\r\nswitch (family) {\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\nreturn netlbl_unlhsh_add(net,\r\ndev_name, addr, mask, addr_len,\r\nsecid, audit_info);\r\n}\r\nint netlbl_cfg_unlbl_static_del(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu16 family,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nu32 addr_len;\r\nswitch (family) {\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\nreturn netlbl_unlhsh_remove(net,\r\ndev_name, addr, mask, addr_len,\r\naudit_info);\r\n}\r\nint netlbl_cfg_cipsov4_add(struct cipso_v4_doi *doi_def,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nreturn cipso_v4_doi_add(doi_def, audit_info);\r\n}\r\nvoid netlbl_cfg_cipsov4_del(u32 doi, struct netlbl_audit *audit_info)\r\n{\r\ncipso_v4_doi_remove(doi, audit_info);\r\n}\r\nint netlbl_cfg_cipsov4_map_add(u32 doi,\r\nconst char *domain,\r\nconst struct in_addr *addr,\r\nconst struct in_addr *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct cipso_v4_doi *doi_def;\r\nstruct netlbl_dom_map *entry;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct netlbl_domaddr4_map *addrinfo = NULL;\r\ndoi_def = cipso_v4_doi_getdef(doi);\r\nif (doi_def == NULL)\r\nreturn -ENOENT;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\ngoto out_entry;\r\nif (domain != NULL) {\r\nentry->domain = kstrdup(domain, GFP_ATOMIC);\r\nif (entry->domain == NULL)\r\ngoto out_domain;\r\n}\r\nif (addr == NULL && mask == NULL) {\r\nentry->def.cipso = doi_def;\r\nentry->def.type = NETLBL_NLTYPE_CIPSOV4;\r\n} else if (addr != NULL && mask != NULL) {\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\r\nif (addrmap == NULL)\r\ngoto out_addrmap;\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\naddrinfo = kzalloc(sizeof(*addrinfo), GFP_ATOMIC);\r\nif (addrinfo == NULL)\r\ngoto out_addrinfo;\r\naddrinfo->def.cipso = doi_def;\r\naddrinfo->def.type = NETLBL_NLTYPE_CIPSOV4;\r\naddrinfo->list.addr = addr->s_addr & mask->s_addr;\r\naddrinfo->list.mask = mask->s_addr;\r\naddrinfo->list.valid = 1;\r\nret_val = netlbl_af4list_add(&addrinfo->list, &addrmap->list4);\r\nif (ret_val != 0)\r\ngoto cfg_cipsov4_map_add_failure;\r\nentry->def.addrsel = addrmap;\r\nentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\r\n} else {\r\nret_val = -EINVAL;\r\ngoto out_addrmap;\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto cfg_cipsov4_map_add_failure;\r\nreturn 0;\r\ncfg_cipsov4_map_add_failure:\r\nkfree(addrinfo);\r\nout_addrinfo:\r\nkfree(addrmap);\r\nout_addrmap:\r\nkfree(entry->domain);\r\nout_domain:\r\nkfree(entry);\r\nout_entry:\r\ncipso_v4_doi_putdef(doi_def);\r\nreturn ret_val;\r\n}\r\nstatic struct netlbl_lsm_catmap *_netlbl_catmap_getnode(\r\nstruct netlbl_lsm_catmap **catmap,\r\nu32 offset,\r\nunsigned int cm_flags,\r\ngfp_t gfp_flags)\r\n{\r\nstruct netlbl_lsm_catmap *iter = *catmap;\r\nstruct netlbl_lsm_catmap *prev = NULL;\r\nif (iter == NULL)\r\ngoto catmap_getnode_alloc;\r\nif (offset < iter->startbit)\r\ngoto catmap_getnode_walk;\r\nwhile (iter && offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {\r\nprev = iter;\r\niter = iter->next;\r\n}\r\nif (iter == NULL || offset < iter->startbit)\r\ngoto catmap_getnode_walk;\r\nreturn iter;\r\ncatmap_getnode_walk:\r\nif (cm_flags & _CM_F_WALK)\r\nreturn iter;\r\ncatmap_getnode_alloc:\r\nif (!(cm_flags & _CM_F_ALLOC))\r\nreturn NULL;\r\niter = netlbl_catmap_alloc(gfp_flags);\r\nif (iter == NULL)\r\nreturn NULL;\r\niter->startbit = offset & ~(NETLBL_CATMAP_SIZE - 1);\r\nif (prev == NULL) {\r\niter->next = *catmap;\r\n*catmap = iter;\r\n} else {\r\niter->next = prev->next;\r\nprev->next = iter;\r\n}\r\nreturn iter;\r\n}\r\nint netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset)\r\n{\r\nstruct netlbl_lsm_catmap *iter = catmap;\r\nu32 idx;\r\nu32 bit;\r\nNETLBL_CATMAP_MAPTYPE bitmap;\r\niter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);\r\nif (iter == NULL)\r\nreturn -ENOENT;\r\nif (offset > iter->startbit) {\r\noffset -= iter->startbit;\r\nidx = offset / NETLBL_CATMAP_MAPSIZE;\r\nbit = offset % NETLBL_CATMAP_MAPSIZE;\r\n} else {\r\nidx = 0;\r\nbit = 0;\r\n}\r\nbitmap = iter->bitmap[idx] >> bit;\r\nfor (;;) {\r\nif (bitmap != 0) {\r\nwhile ((bitmap & NETLBL_CATMAP_BIT) == 0) {\r\nbitmap >>= 1;\r\nbit++;\r\n}\r\nreturn iter->startbit +\r\n(NETLBL_CATMAP_MAPSIZE * idx) + bit;\r\n}\r\nif (++idx >= NETLBL_CATMAP_MAPCNT) {\r\nif (iter->next != NULL) {\r\niter = iter->next;\r\nidx = 0;\r\n} else\r\nreturn -ENOENT;\r\n}\r\nbitmap = iter->bitmap[idx];\r\nbit = 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset)\r\n{\r\nstruct netlbl_lsm_catmap *iter;\r\nstruct netlbl_lsm_catmap *prev = NULL;\r\nu32 idx;\r\nu32 bit;\r\nNETLBL_CATMAP_MAPTYPE bitmask;\r\nNETLBL_CATMAP_MAPTYPE bitmap;\r\niter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);\r\nif (iter == NULL)\r\nreturn -ENOENT;\r\nif (offset > iter->startbit) {\r\noffset -= iter->startbit;\r\nidx = offset / NETLBL_CATMAP_MAPSIZE;\r\nbit = offset % NETLBL_CATMAP_MAPSIZE;\r\n} else {\r\nidx = 0;\r\nbit = 0;\r\n}\r\nbitmask = NETLBL_CATMAP_BIT << bit;\r\nfor (;;) {\r\nbitmap = iter->bitmap[idx];\r\nwhile (bitmask != 0 && (bitmap & bitmask) != 0) {\r\nbitmask <<= 1;\r\nbit++;\r\n}\r\nif (prev && idx == 0 && bit == 0)\r\nreturn prev->startbit + NETLBL_CATMAP_SIZE - 1;\r\nelse if (bitmask != 0)\r\nreturn iter->startbit +\r\n(NETLBL_CATMAP_MAPSIZE * idx) + bit - 1;\r\nelse if (++idx >= NETLBL_CATMAP_MAPCNT) {\r\nif (iter->next == NULL)\r\nreturn iter->startbit + NETLBL_CATMAP_SIZE - 1;\r\nprev = iter;\r\niter = iter->next;\r\nidx = 0;\r\n}\r\nbitmask = NETLBL_CATMAP_BIT;\r\nbit = 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,\r\nu32 *offset,\r\nunsigned long *bitmap)\r\n{\r\nstruct netlbl_lsm_catmap *iter;\r\nu32 off = *offset;\r\nu32 idx;\r\nif ((off & (BITS_PER_LONG - 1)) != 0)\r\nreturn -EINVAL;\r\nif (off < catmap->startbit) {\r\noff = catmap->startbit;\r\n*offset = off;\r\n}\r\niter = _netlbl_catmap_getnode(&catmap, off, _CM_F_NONE, 0);\r\nif (iter == NULL) {\r\n*offset = (u32)-1;\r\nreturn 0;\r\n}\r\nif (off < iter->startbit) {\r\noff = iter->startbit;\r\n*offset = off;\r\n} else\r\noff -= iter->startbit;\r\nidx = off / NETLBL_CATMAP_MAPSIZE;\r\n*bitmap = iter->bitmap[idx] >> (off % NETLBL_CATMAP_SIZE);\r\nreturn 0;\r\n}\r\nint netlbl_catmap_setbit(struct netlbl_lsm_catmap **catmap,\r\nu32 bit,\r\ngfp_t flags)\r\n{\r\nstruct netlbl_lsm_catmap *iter;\r\nu32 idx;\r\niter = _netlbl_catmap_getnode(catmap, bit, _CM_F_ALLOC, flags);\r\nif (iter == NULL)\r\nreturn -ENOMEM;\r\nbit -= iter->startbit;\r\nidx = bit / NETLBL_CATMAP_MAPSIZE;\r\niter->bitmap[idx] |= NETLBL_CATMAP_BIT << (bit % NETLBL_CATMAP_MAPSIZE);\r\nreturn 0;\r\n}\r\nint netlbl_catmap_setrng(struct netlbl_lsm_catmap **catmap,\r\nu32 start,\r\nu32 end,\r\ngfp_t flags)\r\n{\r\nint rc = 0;\r\nu32 spot = start;\r\nwhile (rc == 0 && spot <= end) {\r\nif (((spot & (BITS_PER_LONG - 1)) != 0) &&\r\n((end - spot) > BITS_PER_LONG)) {\r\nrc = netlbl_catmap_setlong(catmap,\r\nspot,\r\n(unsigned long)-1,\r\nflags);\r\nspot += BITS_PER_LONG;\r\n} else\r\nrc = netlbl_catmap_setbit(catmap, spot++, flags);\r\n}\r\nreturn rc;\r\n}\r\nint netlbl_catmap_setlong(struct netlbl_lsm_catmap **catmap,\r\nu32 offset,\r\nunsigned long bitmap,\r\ngfp_t flags)\r\n{\r\nstruct netlbl_lsm_catmap *iter;\r\nu32 idx;\r\nif ((offset & (BITS_PER_LONG - 1)) != 0)\r\nreturn -EINVAL;\r\niter = _netlbl_catmap_getnode(catmap, offset, _CM_F_ALLOC, flags);\r\nif (iter == NULL)\r\nreturn -ENOMEM;\r\noffset -= iter->startbit;\r\nidx = offset / NETLBL_CATMAP_MAPSIZE;\r\niter->bitmap[idx] |= bitmap << (offset % NETLBL_CATMAP_MAPSIZE);\r\nreturn 0;\r\n}\r\nint netlbl_enabled(void)\r\n{\r\nreturn (atomic_read(&netlabel_mgmt_protocount) > 0);\r\n}\r\nint netlbl_sock_setattr(struct sock *sk,\r\nu16 family,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct netlbl_dom_map *dom_entry;\r\nrcu_read_lock();\r\ndom_entry = netlbl_domhsh_getentry(secattr->domain);\r\nif (dom_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto socket_setattr_return;\r\n}\r\nswitch (family) {\r\ncase AF_INET:\r\nswitch (dom_entry->def.type) {\r\ncase NETLBL_NLTYPE_ADDRSELECT:\r\nret_val = -EDESTADDRREQ;\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_sock_setattr(sk,\r\ndom_entry->def.cipso,\r\nsecattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nsocket_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nvoid netlbl_sock_delattr(struct sock *sk)\r\n{\r\ncipso_v4_sock_delattr(sk);\r\n}\r\nint netlbl_sock_getattr(struct sock *sk,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\nret_val = cipso_v4_sock_getattr(sk, secattr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = -ENOMSG;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nreturn ret_val;\r\n}\r\nint netlbl_conn_setattr(struct sock *sk,\r\nstruct sockaddr *addr,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct sockaddr_in *addr4;\r\nstruct netlbl_dommap_def *entry;\r\nrcu_read_lock();\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\naddr4 = (struct sockaddr_in *)addr;\r\nentry = netlbl_domhsh_getentry_af4(secattr->domain,\r\naddr4->sin_addr.s_addr);\r\nif (entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto conn_setattr_return;\r\n}\r\nswitch (entry->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_sock_setattr(sk,\r\nentry->cipso, secattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\ncipso_v4_sock_delattr(sk);\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nconn_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nint netlbl_req_setattr(struct request_sock *req,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct netlbl_dommap_def *entry;\r\nrcu_read_lock();\r\nswitch (req->rsk_ops->family) {\r\ncase AF_INET:\r\nentry = netlbl_domhsh_getentry_af4(secattr->domain,\r\ninet_rsk(req)->ir_rmt_addr);\r\nif (entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto req_setattr_return;\r\n}\r\nswitch (entry->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_req_setattr(req,\r\nentry->cipso, secattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\ncipso_v4_req_delattr(req);\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nreq_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nvoid netlbl_req_delattr(struct request_sock *req)\r\n{\r\ncipso_v4_req_delattr(req);\r\n}\r\nint netlbl_skbuff_setattr(struct sk_buff *skb,\r\nu16 family,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct iphdr *hdr4;\r\nstruct netlbl_dommap_def *entry;\r\nrcu_read_lock();\r\nswitch (family) {\r\ncase AF_INET:\r\nhdr4 = ip_hdr(skb);\r\nentry = netlbl_domhsh_getentry_af4(secattr->domain,hdr4->daddr);\r\nif (entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto skbuff_setattr_return;\r\n}\r\nswitch (entry->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_skbuff_setattr(skb, entry->cipso,\r\nsecattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = cipso_v4_skbuff_delattr(skb);\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nskbuff_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nint netlbl_skbuff_getattr(const struct sk_buff *skb,\r\nu16 family,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\nif (CIPSO_V4_OPTEXIST(skb) &&\r\ncipso_v4_skbuff_getattr(skb, secattr) == 0)\r\nreturn 0;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nbreak;\r\n#endif\r\n}\r\nreturn netlbl_unlabel_getattr(skb, family, secattr);\r\n}\r\nvoid netlbl_skbuff_err(struct sk_buff *skb, int error, int gateway)\r\n{\r\nif (CIPSO_V4_OPTEXIST(skb))\r\ncipso_v4_error(skb, error, gateway);\r\n}\r\nvoid netlbl_cache_invalidate(void)\r\n{\r\ncipso_v4_cache_invalidate();\r\n}\r\nint netlbl_cache_add(const struct sk_buff *skb,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nif ((secattr->flags & NETLBL_SECATTR_CACHE) == 0)\r\nreturn -ENOMSG;\r\nif (CIPSO_V4_OPTEXIST(skb))\r\nreturn cipso_v4_cache_add(skb, secattr);\r\nreturn -ENOMSG;\r\n}\r\nstruct audit_buffer *netlbl_audit_start(int type,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nreturn netlbl_audit_start_common(type, audit_info);\r\n}\r\nstatic int __init netlbl_init(void)\r\n{\r\nint ret_val;\r\nprintk(KERN_INFO "NetLabel: Initializing\n");\r\nprintk(KERN_INFO "NetLabel: domain hash size = %u\n",\r\n(1 << NETLBL_DOMHSH_BITSIZE));\r\nprintk(KERN_INFO "NetLabel: protocols ="\r\n" UNLABELED"\r\n" CIPSOv4"\r\n"\n");\r\nret_val = netlbl_domhsh_init(NETLBL_DOMHSH_BITSIZE);\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_unlabel_init(NETLBL_UNLHSH_BITSIZE);\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_netlink_init();\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_unlabel_defconf();\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nprintk(KERN_INFO "NetLabel: unlabeled traffic allowed by default\n");\r\nreturn 0;\r\ninit_failure:\r\npanic("NetLabel: failed to initialize properly (%d)\n", ret_val);\r\n}
