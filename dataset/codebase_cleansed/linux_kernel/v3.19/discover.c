static void tipc_disc_init_msg(struct sk_buff *buf, u32 type,\r\nstruct tipc_bearer *b_ptr)\r\n{\r\nstruct tipc_msg *msg;\r\nu32 dest_domain = b_ptr->domain;\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(msg, LINK_CONFIG, type, INT_H_SIZE, dest_domain);\r\nmsg_set_non_seq(msg, 1);\r\nmsg_set_node_sig(msg, tipc_random);\r\nmsg_set_dest_domain(msg, dest_domain);\r\nmsg_set_bc_netid(msg, tipc_net_id);\r\nb_ptr->media->addr2msg(msg_media_addr(msg), &b_ptr->addr);\r\n}\r\nstatic void disc_dupl_alert(struct tipc_bearer *b_ptr, u32 node_addr,\r\nstruct tipc_media_addr *media_addr)\r\n{\r\nchar node_addr_str[16];\r\nchar media_addr_str[64];\r\ntipc_addr_string_fill(node_addr_str, node_addr);\r\ntipc_media_addr_printf(media_addr_str, sizeof(media_addr_str),\r\nmedia_addr);\r\npr_warn("Duplicate %s using %s seen on <%s>\n", node_addr_str,\r\nmedia_addr_str, b_ptr->name);\r\n}\r\nvoid tipc_disc_rcv(struct sk_buff *buf, struct tipc_bearer *bearer)\r\n{\r\nstruct tipc_node *node;\r\nstruct tipc_link *link;\r\nstruct tipc_media_addr maddr;\r\nstruct sk_buff *rbuf;\r\nstruct tipc_msg *msg = buf_msg(buf);\r\nu32 ddom = msg_dest_domain(msg);\r\nu32 onode = msg_prevnode(msg);\r\nu32 net_id = msg_bc_netid(msg);\r\nu32 mtyp = msg_type(msg);\r\nu32 signature = msg_node_sig(msg);\r\nbool addr_match = false;\r\nbool sign_match = false;\r\nbool link_up = false;\r\nbool accept_addr = false;\r\nbool accept_sign = false;\r\nbool respond = false;\r\nbearer->media->msg2addr(bearer, &maddr, msg_media_addr(msg));\r\nkfree_skb(buf);\r\nif (net_id != tipc_net_id)\r\nreturn;\r\nif (maddr.broadcast)\r\nreturn;\r\nif (!tipc_addr_domain_valid(ddom))\r\nreturn;\r\nif (!tipc_addr_node_valid(onode))\r\nreturn;\r\nif (in_own_node(onode)) {\r\nif (memcmp(&maddr, &bearer->addr, sizeof(maddr)))\r\ndisc_dupl_alert(bearer, tipc_own_addr, &maddr);\r\nreturn;\r\n}\r\nif (!tipc_in_scope(ddom, tipc_own_addr))\r\nreturn;\r\nif (!tipc_in_scope(bearer->domain, onode))\r\nreturn;\r\nnode = tipc_node_find(onode);\r\nif (!node)\r\nnode = tipc_node_create(onode);\r\nif (!node)\r\nreturn;\r\ntipc_node_lock(node);\r\nlink = node->links[bearer->identity];\r\nsign_match = (signature == node->signature);\r\naddr_match = link && !memcmp(&link->media_addr, &maddr, sizeof(maddr));\r\nlink_up = link && tipc_link_is_up(link);\r\nif (sign_match && addr_match && link_up) {\r\n} else if (sign_match && addr_match && !link_up) {\r\nrespond = true;\r\n} else if (sign_match && !addr_match && link_up) {\r\ndisc_dupl_alert(bearer, onode, &maddr);\r\n} else if (sign_match && !addr_match && !link_up) {\r\naccept_addr = true;\r\nrespond = true;\r\n} else if (!sign_match && addr_match && link_up) {\r\naccept_sign = true;\r\n} else if (!sign_match && addr_match && !link_up) {\r\naccept_sign = true;\r\nrespond = true;\r\n} else if (!sign_match && !addr_match && link_up) {\r\ndisc_dupl_alert(bearer, onode, &maddr);\r\n} else if (!sign_match && !addr_match && !link_up) {\r\naccept_sign = true;\r\naccept_addr = true;\r\nrespond = true;\r\n}\r\nif (accept_sign)\r\nnode->signature = signature;\r\nif (accept_addr) {\r\nif (!link)\r\nlink = tipc_link_create(node, bearer, &maddr);\r\nif (link) {\r\nmemcpy(&link->media_addr, &maddr, sizeof(maddr));\r\ntipc_link_reset(link);\r\n} else {\r\nrespond = false;\r\n}\r\n}\r\nif (respond && (mtyp == DSC_REQ_MSG)) {\r\nrbuf = tipc_buf_acquire(INT_H_SIZE);\r\nif (rbuf) {\r\ntipc_disc_init_msg(rbuf, DSC_RESP_MSG, bearer);\r\ntipc_bearer_send(bearer->identity, rbuf, &maddr);\r\nkfree_skb(rbuf);\r\n}\r\n}\r\ntipc_node_unlock(node);\r\n}\r\nstatic void disc_update(struct tipc_link_req *req)\r\n{\r\nif (!req->num_nodes) {\r\nif ((req->timer_intv == TIPC_LINK_REQ_INACTIVE) ||\r\n(req->timer_intv > TIPC_LINK_REQ_FAST)) {\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_start_timer(&req->timer, req->timer_intv);\r\n}\r\n}\r\n}\r\nvoid tipc_disc_add_dest(struct tipc_link_req *req)\r\n{\r\nspin_lock_bh(&req->lock);\r\nreq->num_nodes++;\r\nspin_unlock_bh(&req->lock);\r\n}\r\nvoid tipc_disc_remove_dest(struct tipc_link_req *req)\r\n{\r\nspin_lock_bh(&req->lock);\r\nreq->num_nodes--;\r\ndisc_update(req);\r\nspin_unlock_bh(&req->lock);\r\n}\r\nstatic void disc_timeout(struct tipc_link_req *req)\r\n{\r\nint max_delay;\r\nspin_lock_bh(&req->lock);\r\nif (tipc_node(req->domain) && req->num_nodes) {\r\nreq->timer_intv = TIPC_LINK_REQ_INACTIVE;\r\ngoto exit;\r\n}\r\ntipc_bearer_send(req->bearer_id, req->buf, &req->dest);\r\nreq->timer_intv *= 2;\r\nif (req->num_nodes)\r\nmax_delay = TIPC_LINK_REQ_SLOW;\r\nelse\r\nmax_delay = TIPC_LINK_REQ_FAST;\r\nif (req->timer_intv > max_delay)\r\nreq->timer_intv = max_delay;\r\nk_start_timer(&req->timer, req->timer_intv);\r\nexit:\r\nspin_unlock_bh(&req->lock);\r\n}\r\nint tipc_disc_create(struct tipc_bearer *b_ptr, struct tipc_media_addr *dest)\r\n{\r\nstruct tipc_link_req *req;\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->buf = tipc_buf_acquire(INT_H_SIZE);\r\nif (!req->buf) {\r\nkfree(req);\r\nreturn -ENOMEM;\r\n}\r\ntipc_disc_init_msg(req->buf, DSC_REQ_MSG, b_ptr);\r\nmemcpy(&req->dest, dest, sizeof(*dest));\r\nreq->bearer_id = b_ptr->identity;\r\nreq->domain = b_ptr->domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nspin_lock_init(&req->lock);\r\nk_init_timer(&req->timer, (Handler)disc_timeout, (unsigned long)req);\r\nk_start_timer(&req->timer, req->timer_intv);\r\nb_ptr->link_req = req;\r\ntipc_bearer_send(req->bearer_id, req->buf, &req->dest);\r\nreturn 0;\r\n}\r\nvoid tipc_disc_delete(struct tipc_link_req *req)\r\n{\r\nk_cancel_timer(&req->timer);\r\nk_term_timer(&req->timer);\r\nkfree_skb(req->buf);\r\nkfree(req);\r\n}\r\nvoid tipc_disc_reset(struct tipc_bearer *b_ptr)\r\n{\r\nstruct tipc_link_req *req = b_ptr->link_req;\r\nspin_lock_bh(&req->lock);\r\ntipc_disc_init_msg(req->buf, DSC_REQ_MSG, b_ptr);\r\nreq->bearer_id = b_ptr->identity;\r\nreq->domain = b_ptr->domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_start_timer(&req->timer, req->timer_intv);\r\ntipc_bearer_send(req->bearer_id, req->buf, &req->dest);\r\nspin_unlock_bh(&req->lock);\r\n}
