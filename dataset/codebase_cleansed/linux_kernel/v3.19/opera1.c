static int opera1_xilinx_rw(struct usb_device *dev, u8 request, u16 value,\r\nu8 * data, u16 len, int flags)\r\n{\r\nint ret;\r\nu8 tmp;\r\nu8 *buf;\r\nunsigned int pipe = (flags == OPERA_READ_MSG) ?\r\nusb_rcvctrlpipe(dev,0) : usb_sndctrlpipe(dev, 0);\r\nu8 request_type = (flags == OPERA_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (flags == OPERA_WRITE_MSG)\r\nmemcpy(buf, data, len);\r\nret = usb_control_msg(dev, pipe, request,\r\nrequest_type | USB_TYPE_VENDOR, value, 0x0,\r\nbuf, len, 2000);\r\nif (request == OPERA_TUNER_REQ) {\r\ntmp = buf[0];\r\nif (usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nOPERA_TUNER_REQ, USB_DIR_IN | USB_TYPE_VENDOR,\r\n0x01, 0x0, buf, 1, 2000) < 1 || buf[0] != 0x08) {\r\nret = 0;\r\ngoto out;\r\n}\r\nbuf[0] = tmp;\r\n}\r\nif (flags == OPERA_READ_MSG)\r\nmemcpy(data, buf, len);\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int opera1_usb_i2c_msgxfer(struct dvb_usb_device *dev, u16 addr,\r\nu8 * buf, u16 len)\r\n{\r\nint ret = 0;\r\nu8 request;\r\nu16 value;\r\nif (!dev) {\r\ninfo("no usb_device");\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&dev->usb_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (addr>>1){\r\ncase ADDR_B600_VOLTAGE_13V:\r\nrequest=0xb6;\r\nvalue=0x00;\r\nbreak;\r\ncase ADDR_B601_VOLTAGE_18V:\r\nrequest=0xb6;\r\nvalue=0x01;\r\nbreak;\r\ncase ADDR_B1A6_STREAM_CTRL:\r\nrequest=0xb1;\r\nvalue=0xa6;\r\nbreak;\r\ncase ADDR_B880_READ_REMOTE:\r\nrequest=0xb8;\r\nvalue=0x80;\r\nbreak;\r\ndefault:\r\nrequest=0xb1;\r\nvalue=addr;\r\n}\r\nret = opera1_xilinx_rw(dev->udev, request,\r\nvalue, buf, len,\r\naddr&0x01?OPERA_READ_MSG:OPERA_WRITE_MSG);\r\nmutex_unlock(&dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int opera1_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i = 0, tmp = 0;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif ((tmp = opera1_usb_i2c_msgxfer(d,\r\n(msg[i].addr<<1)|(msg[i].flags&I2C_M_RD?0x01:0),\r\nmsg[i].buf,\r\nmsg[i].len\r\n)) != msg[i].len) {\r\nbreak;\r\n}\r\nif (dvb_usb_opera1_debug & 0x10)\r\ninfo("sending i2c message %d %d", tmp, msg[i].len);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic u32 opera1_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int opera1_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstatic u8 command_13v[1]={0x00};\r\nstatic u8 command_18v[1]={0x01};\r\nstruct i2c_msg msg[] = {\r\n{.addr = ADDR_B600_VOLTAGE_13V,.flags = 0,.buf = command_13v,.len = 1},\r\n};\r\nstruct dvb_usb_adapter *udev_adap =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nif (voltage == SEC_VOLTAGE_18) {\r\nmsg[0].addr = ADDR_B601_VOLTAGE_18V;\r\nmsg[0].buf = command_18v;\r\n}\r\ni2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);\r\nreturn 0;\r\n}\r\nstatic int opera1_stv0299_set_symbol_rate(struct dvb_frontend *fe, u32 srate,\r\nu32 ratio)\r\n{\r\nstv0299_writereg(fe, 0x13, 0x98);\r\nstv0299_writereg(fe, 0x14, 0x95);\r\nstv0299_writereg(fe, REG_1F_SYMBOLRATE_BYTE0, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, REG_20_SYMBOLRATE_BYTE1, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, REG_21_SYMBOLRATE_BYTE2, (ratio) & 0xf0);\r\nreturn 0;\r\n}\r\nstatic int opera1_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nd->fe_adap[0].fe = dvb_attach(stv0299_attach, &opera1_stv0299_config,\r\n&d->dev->i2c_adap);\r\nif ((d->fe_adap[0].fe) != NULL) {\r\nd->fe_adap[0].fe->ops.set_voltage = opera1_set_voltage;\r\nreturn 0;\r\n}\r\ninfo("not attached stv0299");\r\nreturn -EIO;\r\n}\r\nstatic int opera1_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(\r\ndvb_pll_attach, adap->fe_adap[0].fe, 0xc0>>1,\r\n&adap->dev->i2c_adap, DVB_PLL_OPERA1\r\n);\r\nreturn 0;\r\n}\r\nstatic int opera1_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 val = onoff ? 0x01 : 0x00;\r\nif (dvb_usb_opera1_debug)\r\ninfo("power %s", onoff ? "on" : "off");\r\nreturn opera1_xilinx_rw(d->udev, 0xb7, val,\r\n&val, 1, OPERA_WRITE_MSG);\r\n}\r\nstatic int opera1_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstatic u8 buf_start[2] = { 0xff, 0x03 };\r\nstatic u8 buf_stop[2] = { 0xff, 0x00 };\r\nstruct i2c_msg start_tuner[] = {\r\n{.addr = ADDR_B1A6_STREAM_CTRL,.buf = onoff ? buf_start : buf_stop,.len = 2},\r\n};\r\nif (dvb_usb_opera1_debug)\r\ninfo("streaming %s", onoff ? "on" : "off");\r\ni2c_transfer(&adap->dev->i2c_adap, start_tuner, 1);\r\nreturn 0;\r\n}\r\nstatic int opera1_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nu8 b_pid[3];\r\nstruct i2c_msg msg[] = {\r\n{.addr = ADDR_B1A6_STREAM_CTRL,.buf = b_pid,.len = 3},\r\n};\r\nif (dvb_usb_opera1_debug)\r\ninfo("pidfilter index: %d pid: %d %s", index, pid,\r\nonoff ? "on" : "off");\r\nb_pid[0] = (2 * index) + 4;\r\nb_pid[1] = onoff ? (pid & 0xff) : (0x00);\r\nb_pid[2] = onoff ? ((pid >> 8) & 0xff) : (0x00);\r\ni2c_transfer(&adap->dev->i2c_adap, msg, 1);\r\nreturn 0;\r\n}\r\nstatic int opera1_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint u = 0x04;\r\nu8 b_pid[3];\r\nstruct i2c_msg msg[] = {\r\n{.addr = ADDR_B1A6_STREAM_CTRL,.buf = b_pid,.len = 3},\r\n};\r\nif (dvb_usb_opera1_debug)\r\ninfo("%s hw-pidfilter", onoff ? "enable" : "disable");\r\nfor (; u < 0x7e; u += 2) {\r\nb_pid[0] = u;\r\nb_pid[1] = 0;\r\nb_pid[2] = 0x80;\r\ni2c_transfer(&adap->dev->i2c_adap, msg, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int opera1_rc_query(struct dvb_usb_device *dev, u32 * event, int *state)\r\n{\r\nstruct opera1_state *opst = dev->priv;\r\nu8 rcbuffer[32];\r\nconst u16 startmarker1 = 0x10ed;\r\nconst u16 startmarker2 = 0x11ec;\r\nstruct i2c_msg read_remote[] = {\r\n{.addr = ADDR_B880_READ_REMOTE,.buf = rcbuffer,.flags = I2C_M_RD,.len = 32},\r\n};\r\nint i = 0;\r\nu32 send_key = 0;\r\nif (i2c_transfer(&dev->i2c_adap, read_remote, 1) == 1) {\r\nfor (i = 0; i < 32; i++) {\r\nif (rcbuffer[i])\r\nsend_key |= 1;\r\nif (i < 31)\r\nsend_key = send_key << 1;\r\n}\r\nif (send_key & 0x8000)\r\nsend_key = (send_key << 1) | (send_key >> 15 & 0x01);\r\nif (send_key == 0xffff && opst->last_key_pressed != 0) {\r\n*state = REMOTE_KEY_REPEAT;\r\n*event = opst->last_key_pressed;\r\nreturn 0;\r\n}\r\nfor (; send_key != 0;) {\r\nif (send_key >> 16 == startmarker2) {\r\nbreak;\r\n} else if (send_key >> 16 == startmarker1) {\r\nsend_key =\r\n(send_key & 0xfffeffff) | (startmarker1 << 16);\r\nbreak;\r\n} else\r\nsend_key >>= 1;\r\n}\r\nif (send_key == 0)\r\nreturn 0;\r\nsend_key = (send_key & 0xffff) | 0x0100;\r\nfor (i = 0; i < ARRAY_SIZE(rc_map_opera1_table); i++) {\r\nif (rc5_scan(&rc_map_opera1_table[i]) == (send_key & 0xffff)) {\r\n*state = REMOTE_KEY_PRESSED;\r\n*event = rc_map_opera1_table[i].keycode;\r\nopst->last_key_pressed =\r\nrc_map_opera1_table[i].keycode;\r\nbreak;\r\n}\r\nopst->last_key_pressed = 0;\r\n}\r\n} else\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nreturn 0;\r\n}\r\nstatic int opera1_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nu8 command[] = { READ_MAC_ADDR };\r\nopera1_xilinx_rw(d->udev, 0xb1, 0xa0, command, 1, OPERA_WRITE_MSG);\r\nopera1_xilinx_rw(d->udev, 0xb1, 0xa1, mac, 6, OPERA_READ_MSG);\r\nreturn 0;\r\n}\r\nstatic int opera1_xilinx_load_firmware(struct usb_device *dev,\r\nconst char *filename)\r\n{\r\nconst struct firmware *fw = NULL;\r\nu8 *b, *p;\r\nint ret = 0, i,fpgasize=40;\r\nu8 testval;\r\ninfo("start downloading fpga firmware %s",filename);\r\nif ((ret = request_firmware(&fw, filename, &dev->dev)) != 0) {\r\nerr("did not find the firmware file. (%s) "\r\n"Please see linux/Documentation/dvb/ for more details on firmware-problems.",\r\nfilename);\r\nreturn ret;\r\n} else {\r\np = kmalloc(fw->size, GFP_KERNEL);\r\nopera1_xilinx_rw(dev, 0xbc, 0x00, &testval, 1, OPERA_READ_MSG);\r\nif (p != NULL && testval != 0x67) {\r\nu8 reset = 0, fpga_command = 0;\r\nmemcpy(p, fw->data, fw->size);\r\nopera1_xilinx_rw(dev, 0xbc, 0xaa, &fpga_command, 1,\r\nOPERA_WRITE_MSG);\r\nfor (i = 0; i < fw->size;) {\r\nif ( (fw->size - i) <fpgasize){\r\nfpgasize=fw->size-i;\r\n}\r\nb = (u8 *) p + i;\r\nif (opera1_xilinx_rw\r\n(dev, OPERA_WRITE_FX2, 0x0, b , fpgasize,\r\nOPERA_WRITE_MSG) != fpgasize\r\n) {\r\nerr("error while transferring firmware");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ni = i + fpgasize;\r\n}\r\nif (ret || opera1_xilinx_rw\r\n(dev, 0xa0, 0xe600, &reset, 1,\r\nOPERA_WRITE_MSG) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\n}\r\n}\r\nkfree(p);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int opera1_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (le16_to_cpu(udev->descriptor.idProduct) == USB_PID_OPERA1_WARM &&\r\nle16_to_cpu(udev->descriptor.idVendor) == USB_VID_OPERA1 &&\r\nopera1_xilinx_load_firmware(udev, "dvb-usb-opera1-fpga-01.fw") != 0\r\n) {\r\nreturn -EINVAL;\r\n}\r\nif (0 != dvb_usb_device_init(intf, &opera1_properties,\r\nTHIS_MODULE, NULL, adapter_nr))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
