void PHY_SetRF8256Bandwidth(struct net_device *dev , HT_CHANNEL_WIDTH Bandwidth)\r\n{\r\nu8 eRFPath;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nfor (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\ncontinue;\r\nswitch (Bandwidth) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nif (priv->card_8192_version == VERSION_819xU_A\r\n|| priv->card_8192_version\r\n== VERSION_819xU_B) {\r\nrtl8192_phy_SetRFReg(dev,\r\n(RF90_RADIO_PATH_E)eRFPath,\r\n0x0b, bMask12Bits, 0x100);\r\nrtl8192_phy_SetRFReg(dev,\r\n(RF90_RADIO_PATH_E)eRFPath,\r\n0x2c, bMask12Bits, 0x3d7);\r\nrtl8192_phy_SetRFReg(dev,\r\n(RF90_RADIO_PATH_E)eRFPath,\r\n0x0e, bMask12Bits, 0x021);\r\nrtl8192_phy_SetRFReg(dev,\r\n(RF90_RADIO_PATH_E)eRFPath,\r\n0x14, bMask12Bits, 0x5ab);\r\n} else {\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown hardware version\n");\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nif (priv->card_8192_version == VERSION_819xU_A || priv->card_8192_version == VERSION_819xU_B) {\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x0b, bMask12Bits, 0x300);\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x2c, bMask12Bits, 0x3df);\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x0e, bMask12Bits, 0x0a1);\r\nif (priv->chan == 3 || priv->chan == 9)\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x14, bMask12Bits, 0x59b);\r\nelse\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x14, bMask12Bits, 0x5ab);\r\n} else {\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown hardware version\n");\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown Bandwidth: %#X\n", Bandwidth);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid PHY_RF8256_Config(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->NumTotalRFPath = RTL819X_TOTAL_RF_PATH;\r\nphy_RF8256_Config_ParaFile(dev);\r\n}\r\nvoid phy_RF8256_Config_ParaFile(struct net_device *dev)\r\n{\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nBB_REGISTER_DEFINITION_T *pPhyReg;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 RegOffSetToBeCheck = 0x3;\r\nu32 RegValueToBeCheck = 0x7f1;\r\nu32 RF3_Final_Value = 0;\r\nu8 ConstRetryTimes = 5, RetryTimes = 5;\r\nu8 ret = 0;\r\nfor (eRFPath = (RF90_RADIO_PATH_E)RF90_PATH_A; eRFPath < priv->NumTotalRFPath; eRFPath++) {\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\ncontinue;\r\npPhyReg = &priv->PHYRegDef[eRFPath];\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs, bRFSI_RFENV);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs, bRFSI_RFENV<<16);\r\nbreak;\r\n}\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, b3WireAddressLength, 0x0);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, b3WireDataLength, 0x0);\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E) eRFPath, 0x0, bMask12Bits, 0xbf);\r\nif (rtl8192_phy_checkBBAndRF(dev, HW90_BLOCK_RF, (RF90_RADIO_PATH_E)eRFPath)) {\r\nRT_TRACE(COMP_ERR, "PHY_RF8256_Config():Check Radio[%d] Fail!!\n", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\nRetryTimes = ConstRetryTimes;\r\nRF3_Final_Value = 0;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\nwhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nwhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nwhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nwhile (RF3_Final_Value != RegValueToBeCheck && RetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev, (RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\n}\r\n;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV, u4RegValue);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV<<16, u4RegValue);\r\nbreak;\r\n}\r\nif (ret) {\r\nRT_TRACE(COMP_ERR, "phy_RF8256_Config_ParaFile():Radio[%d] Fail!!", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\n}\r\nRT_TRACE(COMP_PHY, "PHY Initialization Success\n");\r\nreturn;\r\nphy_RF8256_Config_ParaFile_Fail:\r\nRT_TRACE(COMP_ERR, "PHY Initialization failed\n");\r\n}\r\nvoid PHY_SetRF8256CCKTxPower(struct net_device *dev, u8 powerlevel)\r\n{\r\nu32 TxAGC = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nTxAGC = powerlevel;\r\nif (priv->bDynamicTxLowPower == TRUE) {\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\nTxAGC = 0x22;\r\nelse\r\nTxAGC += priv->CckPwEnl;\r\n}\r\nif (TxAGC > 0x24)\r\nTxAGC = 0x24;\r\nrtl8192_setBBreg(dev, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\r\n}\r\nvoid PHY_SetRF8256OFDMTxPower(struct net_device *dev, u8 powerlevel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\r\nu8 index = 0;\r\nu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\r\nu8 byte0, byte1, byte2, byte3;\r\npowerBase0 = powerlevel + priv->TxPowerDiff;\r\npowerBase0 = (powerBase0<<24) | (powerBase0<<16) | (powerBase0<<8) | powerBase0;\r\npowerBase1 = powerlevel;\r\npowerBase1 = (powerBase1<<24) | (powerBase1<<16) | (powerBase1<<8) | powerBase1;\r\nfor (index = 0; index < 6; index++) {\r\nwriteVal = priv->MCSTxPowerLevelOriginalOffset[index] + ((index < 2)?powerBase0:powerBase1);\r\nbyte0 = (u8)(writeVal & 0x7f);\r\nbyte1 = (u8)((writeVal & 0x7f00)>>8);\r\nbyte2 = (u8)((writeVal & 0x7f0000)>>16);\r\nbyte3 = (u8)((writeVal & 0x7f000000)>>24);\r\nif (byte0 > 0x24)\r\nbyte0 = 0x24;\r\nif (byte1 > 0x24)\r\nbyte1 = 0x24;\r\nif (byte2 > 0x24)\r\nbyte2 = 0x24;\r\nif (byte3 > 0x24)\r\nbyte3 = 0x24;\r\nif (index == 3) {\r\nwriteVal_tmp = (byte3<<24) | (byte2<<16) | (byte1<<8) | byte0;\r\npriv->Pwr_Track = writeVal_tmp;\r\n}\r\nif (priv->bDynamicTxHighPower == TRUE) {\r\nwriteVal = 0x03030303;\r\n} else {\r\nwriteVal = (byte3<<24) | (byte2<<16) | (byte1<<8) | byte0;\r\n}\r\nrtl8192_setBBreg(dev, RegOffset[index], 0x7f7f7f7f, writeVal);\r\n}\r\nreturn;\r\n}
