static int\r\nnfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)\r\n{\r\nint res;\r\ndo {\r\nres = rpc_call_sync(clnt, msg, flags);\r\nif (res != -EJUKEBOX)\r\nbreak;\r\nfreezable_schedule_timeout_killable_unsafe(NFS_JUKEBOX_RETRY_TIME);\r\nres = -ERESTARTSYS;\r\n} while (!fatal_signal_pending(current));\r\nreturn res;\r\n}\r\nstatic int\r\nnfs3_async_handle_jukebox(struct rpc_task *task, struct inode *inode)\r\n{\r\nif (task->tk_status != -EJUKEBOX)\r\nreturn 0;\r\nif (task->tk_status == -EJUKEBOX)\r\nnfs_inc_stats(inode, NFSIOS_DELAY);\r\ntask->tk_status = 0;\r\nrpc_restart_call(task);\r\nrpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\r\nreturn 1;\r\n}\r\nstatic int\r\ndo_proc_get_root(struct rpc_clnt *client, struct nfs_fh *fhandle,\r\nstruct nfs_fsinfo *info)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_FSINFO],\r\n.rpc_argp = fhandle,\r\n.rpc_resp = info,\r\n};\r\nint status;\r\ndprintk("%s: call fsinfo\n", __func__);\r\nnfs_fattr_init(info->fattr);\r\nstatus = rpc_call_sync(client, &msg, 0);\r\ndprintk("%s: reply fsinfo: %d\n", __func__, status);\r\nif (status == 0 && !(info->fattr->valid & NFS_ATTR_FATTR)) {\r\nmsg.rpc_proc = &nfs3_procedures[NFS3PROC_GETATTR];\r\nmsg.rpc_resp = info->fattr;\r\nstatus = rpc_call_sync(client, &msg, 0);\r\ndprintk("%s: reply getattr: %d\n", __func__, status);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,\r\nstruct nfs_fsinfo *info)\r\n{\r\nint status;\r\nstatus = do_proc_get_root(server->client, fhandle, info);\r\nif (status && server->nfs_client->cl_rpcclient != server->client)\r\nstatus = do_proc_get_root(server->nfs_client->cl_rpcclient, fhandle, info);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\r\nstruct nfs_fattr *fattr, struct nfs4_label *label)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_GETATTR],\r\n.rpc_argp = fhandle,\r\n.rpc_resp = fattr,\r\n};\r\nint status;\r\ndprintk("NFS call getattr\n");\r\nnfs_fattr_init(fattr);\r\nstatus = rpc_call_sync(server->client, &msg, 0);\r\ndprintk("NFS reply getattr: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\r\nstruct iattr *sattr)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct nfs3_sattrargs arg = {\r\n.fh = NFS_FH(inode),\r\n.sattr = sattr,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_SETATTR],\r\n.rpc_argp = &arg,\r\n.rpc_resp = fattr,\r\n};\r\nint status;\r\ndprintk("NFS call setattr\n");\r\nif (sattr->ia_valid & ATTR_FILE)\r\nmsg.rpc_cred = nfs_file_cred(sattr->ia_file);\r\nnfs_fattr_init(fattr);\r\nstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\r\nif (status == 0)\r\nnfs_setattr_update_inode(inode, sattr);\r\ndprintk("NFS reply setattr: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_lookup(struct inode *dir, struct qstr *name,\r\nstruct nfs_fh *fhandle, struct nfs_fattr *fattr,\r\nstruct nfs4_label *label)\r\n{\r\nstruct nfs3_diropargs arg = {\r\n.fh = NFS_FH(dir),\r\n.name = name->name,\r\n.len = name->len\r\n};\r\nstruct nfs3_diropres res = {\r\n.fh = fhandle,\r\n.fattr = fattr\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_LOOKUP],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n};\r\nint status;\r\ndprintk("NFS call lookup %s\n", name->name);\r\nres.dir_attr = nfs_alloc_fattr();\r\nif (res.dir_attr == NULL)\r\nreturn -ENOMEM;\r\nnfs_fattr_init(fattr);\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\r\nnfs_refresh_inode(dir, res.dir_attr);\r\nif (status >= 0 && !(fattr->valid & NFS_ATTR_FATTR)) {\r\nmsg.rpc_proc = &nfs3_procedures[NFS3PROC_GETATTR];\r\nmsg.rpc_argp = fhandle;\r\nmsg.rpc_resp = fattr;\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\r\n}\r\nnfs_free_fattr(res.dir_attr);\r\ndprintk("NFS reply lookup: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int nfs3_proc_access(struct inode *inode, struct nfs_access_entry *entry)\r\n{\r\nstruct nfs3_accessargs arg = {\r\n.fh = NFS_FH(inode),\r\n};\r\nstruct nfs3_accessres res;\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_ACCESS],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n.rpc_cred = entry->cred,\r\n};\r\nint mode = entry->mask;\r\nint status = -ENOMEM;\r\ndprintk("NFS call access\n");\r\nif (mode & MAY_READ)\r\narg.access |= NFS3_ACCESS_READ;\r\nif (S_ISDIR(inode->i_mode)) {\r\nif (mode & MAY_WRITE)\r\narg.access |= NFS3_ACCESS_MODIFY | NFS3_ACCESS_EXTEND | NFS3_ACCESS_DELETE;\r\nif (mode & MAY_EXEC)\r\narg.access |= NFS3_ACCESS_LOOKUP;\r\n} else {\r\nif (mode & MAY_WRITE)\r\narg.access |= NFS3_ACCESS_MODIFY | NFS3_ACCESS_EXTEND;\r\nif (mode & MAY_EXEC)\r\narg.access |= NFS3_ACCESS_EXECUTE;\r\n}\r\nres.fattr = nfs_alloc_fattr();\r\nif (res.fattr == NULL)\r\ngoto out;\r\nstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\r\nnfs_refresh_inode(inode, res.fattr);\r\nif (status == 0) {\r\nentry->mask = 0;\r\nif (res.access & NFS3_ACCESS_READ)\r\nentry->mask |= MAY_READ;\r\nif (res.access & (NFS3_ACCESS_MODIFY | NFS3_ACCESS_EXTEND | NFS3_ACCESS_DELETE))\r\nentry->mask |= MAY_WRITE;\r\nif (res.access & (NFS3_ACCESS_LOOKUP|NFS3_ACCESS_EXECUTE))\r\nentry->mask |= MAY_EXEC;\r\n}\r\nnfs_free_fattr(res.fattr);\r\nout:\r\ndprintk("NFS reply access: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int nfs3_proc_readlink(struct inode *inode, struct page *page,\r\nunsigned int pgbase, unsigned int pglen)\r\n{\r\nstruct nfs_fattr *fattr;\r\nstruct nfs3_readlinkargs args = {\r\n.fh = NFS_FH(inode),\r\n.pgbase = pgbase,\r\n.pglen = pglen,\r\n.pages = &page\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_READLINK],\r\n.rpc_argp = &args,\r\n};\r\nint status = -ENOMEM;\r\ndprintk("NFS call readlink\n");\r\nfattr = nfs_alloc_fattr();\r\nif (fattr == NULL)\r\ngoto out;\r\nmsg.rpc_resp = fattr;\r\nstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\r\nnfs_refresh_inode(inode, fattr);\r\nnfs_free_fattr(fattr);\r\nout:\r\ndprintk("NFS reply readlink: %d\n", status);\r\nreturn status;\r\n}\r\nstatic struct nfs3_createdata *nfs3_alloc_createdata(void)\r\n{\r\nstruct nfs3_createdata *data;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data != NULL) {\r\ndata->msg.rpc_argp = &data->arg;\r\ndata->msg.rpc_resp = &data->res;\r\ndata->res.fh = &data->fh;\r\ndata->res.fattr = &data->fattr;\r\ndata->res.dir_attr = &data->dir_attr;\r\nnfs_fattr_init(data->res.fattr);\r\nnfs_fattr_init(data->res.dir_attr);\r\n}\r\nreturn data;\r\n}\r\nstatic int nfs3_do_create(struct inode *dir, struct dentry *dentry, struct nfs3_createdata *data)\r\n{\r\nint status;\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &data->msg, 0);\r\nnfs_post_op_update_inode(dir, data->res.dir_attr);\r\nif (status == 0)\r\nstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr, NULL);\r\nreturn status;\r\n}\r\nstatic void nfs3_free_createdata(struct nfs3_createdata *data)\r\n{\r\nkfree(data);\r\n}\r\nstatic int\r\nnfs3_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\r\nint flags)\r\n{\r\nstruct posix_acl *default_acl, *acl;\r\nstruct nfs3_createdata *data;\r\nint status = -ENOMEM;\r\ndprintk("NFS call create %pd\n", dentry);\r\ndata = nfs3_alloc_createdata();\r\nif (data == NULL)\r\ngoto out;\r\ndata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_CREATE];\r\ndata->arg.create.fh = NFS_FH(dir);\r\ndata->arg.create.name = dentry->d_name.name;\r\ndata->arg.create.len = dentry->d_name.len;\r\ndata->arg.create.sattr = sattr;\r\ndata->arg.create.createmode = NFS3_CREATE_UNCHECKED;\r\nif (flags & O_EXCL) {\r\ndata->arg.create.createmode = NFS3_CREATE_EXCLUSIVE;\r\ndata->arg.create.verifier[0] = cpu_to_be32(jiffies);\r\ndata->arg.create.verifier[1] = cpu_to_be32(current->pid);\r\n}\r\nstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\r\nif (status)\r\ngoto out;\r\nfor (;;) {\r\nstatus = nfs3_do_create(dir, dentry, data);\r\nif (status != -ENOTSUPP)\r\nbreak;\r\nswitch (data->arg.create.createmode) {\r\ncase NFS3_CREATE_EXCLUSIVE:\r\ndata->arg.create.createmode = NFS3_CREATE_GUARDED;\r\nbreak;\r\ncase NFS3_CREATE_GUARDED:\r\ndata->arg.create.createmode = NFS3_CREATE_UNCHECKED;\r\nbreak;\r\ncase NFS3_CREATE_UNCHECKED:\r\ngoto out;\r\n}\r\nnfs_fattr_init(data->res.dir_attr);\r\nnfs_fattr_init(data->res.fattr);\r\n}\r\nif (status != 0)\r\ngoto out_release_acls;\r\nif (data->arg.create.createmode == NFS3_CREATE_EXCLUSIVE) {\r\ndprintk("NFS call setattr (post-create)\n");\r\nif (!(sattr->ia_valid & ATTR_ATIME_SET))\r\nsattr->ia_valid |= ATTR_ATIME;\r\nif (!(sattr->ia_valid & ATTR_MTIME_SET))\r\nsattr->ia_valid |= ATTR_MTIME;\r\nstatus = nfs3_proc_setattr(dentry, data->res.fattr, sattr);\r\nnfs_post_op_update_inode(dentry->d_inode, data->res.fattr);\r\ndprintk("NFS reply setattr (post-create): %d\n", status);\r\nif (status != 0)\r\ngoto out_release_acls;\r\n}\r\nstatus = nfs3_proc_setacls(dentry->d_inode, acl, default_acl);\r\nout_release_acls:\r\nposix_acl_release(acl);\r\nposix_acl_release(default_acl);\r\nout:\r\nnfs3_free_createdata(data);\r\ndprintk("NFS reply create: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_remove(struct inode *dir, struct qstr *name)\r\n{\r\nstruct nfs_removeargs arg = {\r\n.fh = NFS_FH(dir),\r\n.name = *name,\r\n};\r\nstruct nfs_removeres res;\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n};\r\nint status = -ENOMEM;\r\ndprintk("NFS call remove %s\n", name->name);\r\nres.dir_attr = nfs_alloc_fattr();\r\nif (res.dir_attr == NULL)\r\ngoto out;\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\r\nnfs_post_op_update_inode(dir, res.dir_attr);\r\nnfs_free_fattr(res.dir_attr);\r\nout:\r\ndprintk("NFS reply remove: %d\n", status);\r\nreturn status;\r\n}\r\nstatic void\r\nnfs3_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\r\n{\r\nmsg->rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE];\r\n}\r\nstatic void nfs3_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\r\n{\r\nrpc_call_start(task);\r\n}\r\nstatic int\r\nnfs3_proc_unlink_done(struct rpc_task *task, struct inode *dir)\r\n{\r\nstruct nfs_removeres *res;\r\nif (nfs3_async_handle_jukebox(task, dir))\r\nreturn 0;\r\nres = task->tk_msg.rpc_resp;\r\nnfs_post_op_update_inode(dir, res->dir_attr);\r\nreturn 1;\r\n}\r\nstatic void\r\nnfs3_proc_rename_setup(struct rpc_message *msg, struct inode *dir)\r\n{\r\nmsg->rpc_proc = &nfs3_procedures[NFS3PROC_RENAME];\r\n}\r\nstatic void nfs3_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\r\n{\r\nrpc_call_start(task);\r\n}\r\nstatic int\r\nnfs3_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\r\nstruct inode *new_dir)\r\n{\r\nstruct nfs_renameres *res;\r\nif (nfs3_async_handle_jukebox(task, old_dir))\r\nreturn 0;\r\nres = task->tk_msg.rpc_resp;\r\nnfs_post_op_update_inode(old_dir, res->old_fattr);\r\nnfs_post_op_update_inode(new_dir, res->new_fattr);\r\nreturn 1;\r\n}\r\nstatic int\r\nnfs3_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\r\n{\r\nstruct nfs3_linkargs arg = {\r\n.fromfh = NFS_FH(inode),\r\n.tofh = NFS_FH(dir),\r\n.toname = name->name,\r\n.tolen = name->len\r\n};\r\nstruct nfs3_linkres res;\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_LINK],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n};\r\nint status = -ENOMEM;\r\ndprintk("NFS call link %s\n", name->name);\r\nres.fattr = nfs_alloc_fattr();\r\nres.dir_attr = nfs_alloc_fattr();\r\nif (res.fattr == NULL || res.dir_attr == NULL)\r\ngoto out;\r\nstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\r\nnfs_post_op_update_inode(dir, res.dir_attr);\r\nnfs_post_op_update_inode(inode, res.fattr);\r\nout:\r\nnfs_free_fattr(res.dir_attr);\r\nnfs_free_fattr(res.fattr);\r\ndprintk("NFS reply link: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_symlink(struct inode *dir, struct dentry *dentry, struct page *page,\r\nunsigned int len, struct iattr *sattr)\r\n{\r\nstruct nfs3_createdata *data;\r\nint status = -ENOMEM;\r\nif (len > NFS3_MAXPATHLEN)\r\nreturn -ENAMETOOLONG;\r\ndprintk("NFS call symlink %pd\n", dentry);\r\ndata = nfs3_alloc_createdata();\r\nif (data == NULL)\r\ngoto out;\r\ndata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_SYMLINK];\r\ndata->arg.symlink.fromfh = NFS_FH(dir);\r\ndata->arg.symlink.fromname = dentry->d_name.name;\r\ndata->arg.symlink.fromlen = dentry->d_name.len;\r\ndata->arg.symlink.pages = &page;\r\ndata->arg.symlink.pathlen = len;\r\ndata->arg.symlink.sattr = sattr;\r\nstatus = nfs3_do_create(dir, dentry, data);\r\nnfs3_free_createdata(data);\r\nout:\r\ndprintk("NFS reply symlink: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_mkdir(struct inode *dir, struct dentry *dentry, struct iattr *sattr)\r\n{\r\nstruct posix_acl *default_acl, *acl;\r\nstruct nfs3_createdata *data;\r\nint status = -ENOMEM;\r\ndprintk("NFS call mkdir %pd\n", dentry);\r\ndata = nfs3_alloc_createdata();\r\nif (data == NULL)\r\ngoto out;\r\nstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\r\nif (status)\r\ngoto out;\r\ndata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_MKDIR];\r\ndata->arg.mkdir.fh = NFS_FH(dir);\r\ndata->arg.mkdir.name = dentry->d_name.name;\r\ndata->arg.mkdir.len = dentry->d_name.len;\r\ndata->arg.mkdir.sattr = sattr;\r\nstatus = nfs3_do_create(dir, dentry, data);\r\nif (status != 0)\r\ngoto out_release_acls;\r\nstatus = nfs3_proc_setacls(dentry->d_inode, acl, default_acl);\r\nout_release_acls:\r\nposix_acl_release(acl);\r\nposix_acl_release(default_acl);\r\nout:\r\nnfs3_free_createdata(data);\r\ndprintk("NFS reply mkdir: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_rmdir(struct inode *dir, struct qstr *name)\r\n{\r\nstruct nfs_fattr *dir_attr;\r\nstruct nfs3_diropargs arg = {\r\n.fh = NFS_FH(dir),\r\n.name = name->name,\r\n.len = name->len\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_RMDIR],\r\n.rpc_argp = &arg,\r\n};\r\nint status = -ENOMEM;\r\ndprintk("NFS call rmdir %s\n", name->name);\r\ndir_attr = nfs_alloc_fattr();\r\nif (dir_attr == NULL)\r\ngoto out;\r\nmsg.rpc_resp = dir_attr;\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\r\nnfs_post_op_update_inode(dir, dir_attr);\r\nnfs_free_fattr(dir_attr);\r\nout:\r\ndprintk("NFS reply rmdir: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\r\nu64 cookie, struct page **pages, unsigned int count, int plus)\r\n{\r\nstruct inode *dir = dentry->d_inode;\r\n__be32 *verf = NFS_I(dir)->cookieverf;\r\nstruct nfs3_readdirargs arg = {\r\n.fh = NFS_FH(dir),\r\n.cookie = cookie,\r\n.verf = {verf[0], verf[1]},\r\n.plus = plus,\r\n.count = count,\r\n.pages = pages\r\n};\r\nstruct nfs3_readdirres res = {\r\n.verf = verf,\r\n.plus = plus\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_READDIR],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n.rpc_cred = cred\r\n};\r\nint status = -ENOMEM;\r\nif (plus)\r\nmsg.rpc_proc = &nfs3_procedures[NFS3PROC_READDIRPLUS];\r\ndprintk("NFS call readdir%s %d\n",\r\nplus? "plus" : "", (unsigned int) cookie);\r\nres.dir_attr = nfs_alloc_fattr();\r\nif (res.dir_attr == NULL)\r\ngoto out;\r\nstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\r\nnfs_invalidate_atime(dir);\r\nnfs_refresh_inode(dir, res.dir_attr);\r\nnfs_free_fattr(res.dir_attr);\r\nout:\r\ndprintk("NFS reply readdir%s: %d\n",\r\nplus? "plus" : "", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_mknod(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\r\ndev_t rdev)\r\n{\r\nstruct posix_acl *default_acl, *acl;\r\nstruct nfs3_createdata *data;\r\nint status = -ENOMEM;\r\ndprintk("NFS call mknod %pd %u:%u\n", dentry,\r\nMAJOR(rdev), MINOR(rdev));\r\ndata = nfs3_alloc_createdata();\r\nif (data == NULL)\r\ngoto out;\r\nstatus = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);\r\nif (status)\r\ngoto out;\r\ndata->msg.rpc_proc = &nfs3_procedures[NFS3PROC_MKNOD];\r\ndata->arg.mknod.fh = NFS_FH(dir);\r\ndata->arg.mknod.name = dentry->d_name.name;\r\ndata->arg.mknod.len = dentry->d_name.len;\r\ndata->arg.mknod.sattr = sattr;\r\ndata->arg.mknod.rdev = rdev;\r\nswitch (sattr->ia_mode & S_IFMT) {\r\ncase S_IFBLK:\r\ndata->arg.mknod.type = NF3BLK;\r\nbreak;\r\ncase S_IFCHR:\r\ndata->arg.mknod.type = NF3CHR;\r\nbreak;\r\ncase S_IFIFO:\r\ndata->arg.mknod.type = NF3FIFO;\r\nbreak;\r\ncase S_IFSOCK:\r\ndata->arg.mknod.type = NF3SOCK;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nstatus = nfs3_do_create(dir, dentry, data);\r\nif (status != 0)\r\ngoto out_release_acls;\r\nstatus = nfs3_proc_setacls(dentry->d_inode, acl, default_acl);\r\nout_release_acls:\r\nposix_acl_release(acl);\r\nposix_acl_release(default_acl);\r\nout:\r\nnfs3_free_createdata(data);\r\ndprintk("NFS reply mknod: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\r\nstruct nfs_fsstat *stat)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_FSSTAT],\r\n.rpc_argp = fhandle,\r\n.rpc_resp = stat,\r\n};\r\nint status;\r\ndprintk("NFS call fsstat\n");\r\nnfs_fattr_init(stat->fattr);\r\nstatus = rpc_call_sync(server->client, &msg, 0);\r\ndprintk("NFS reply fsstat: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\ndo_proc_fsinfo(struct rpc_clnt *client, struct nfs_fh *fhandle,\r\nstruct nfs_fsinfo *info)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_FSINFO],\r\n.rpc_argp = fhandle,\r\n.rpc_resp = info,\r\n};\r\nint status;\r\ndprintk("NFS call fsinfo\n");\r\nnfs_fattr_init(info->fattr);\r\nstatus = rpc_call_sync(client, &msg, 0);\r\ndprintk("NFS reply fsinfo: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\r\nstruct nfs_fsinfo *info)\r\n{\r\nint status;\r\nstatus = do_proc_fsinfo(server->client, fhandle, info);\r\nif (status && server->nfs_client->cl_rpcclient != server->client)\r\nstatus = do_proc_fsinfo(server->nfs_client->cl_rpcclient, fhandle, info);\r\nreturn status;\r\n}\r\nstatic int\r\nnfs3_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\r\nstruct nfs_pathconf *info)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs3_procedures[NFS3PROC_PATHCONF],\r\n.rpc_argp = fhandle,\r\n.rpc_resp = info,\r\n};\r\nint status;\r\ndprintk("NFS call pathconf\n");\r\nnfs_fattr_init(info->fattr);\r\nstatus = rpc_call_sync(server->client, &msg, 0);\r\ndprintk("NFS reply pathconf: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int nfs3_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\r\n{\r\nstruct inode *inode = hdr->inode;\r\nif (nfs3_async_handle_jukebox(task, inode))\r\nreturn -EAGAIN;\r\nnfs_invalidate_atime(inode);\r\nnfs_refresh_inode(inode, &hdr->fattr);\r\nreturn 0;\r\n}\r\nstatic void nfs3_proc_read_setup(struct nfs_pgio_header *hdr,\r\nstruct rpc_message *msg)\r\n{\r\nmsg->rpc_proc = &nfs3_procedures[NFS3PROC_READ];\r\n}\r\nstatic int nfs3_proc_pgio_rpc_prepare(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nrpc_call_start(task);\r\nreturn 0;\r\n}\r\nstatic int nfs3_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\r\n{\r\nstruct inode *inode = hdr->inode;\r\nif (nfs3_async_handle_jukebox(task, inode))\r\nreturn -EAGAIN;\r\nif (task->tk_status >= 0)\r\nnfs_post_op_update_inode_force_wcc(inode, hdr->res.fattr);\r\nreturn 0;\r\n}\r\nstatic void nfs3_proc_write_setup(struct nfs_pgio_header *hdr,\r\nstruct rpc_message *msg)\r\n{\r\nmsg->rpc_proc = &nfs3_procedures[NFS3PROC_WRITE];\r\n}\r\nstatic void nfs3_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\r\n{\r\nrpc_call_start(task);\r\n}\r\nstatic int nfs3_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\r\n{\r\nif (nfs3_async_handle_jukebox(task, data->inode))\r\nreturn -EAGAIN;\r\nnfs_refresh_inode(data->inode, data->res.fattr);\r\nreturn 0;\r\n}\r\nstatic void nfs3_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg)\r\n{\r\nmsg->rpc_proc = &nfs3_procedures[NFS3PROC_COMMIT];\r\n}\r\nstatic int\r\nnfs3_proc_lock(struct file *filp, int cmd, struct file_lock *fl)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nreturn nlmclnt_proc(NFS_SERVER(inode)->nlm_host, cmd, fl);\r\n}\r\nstatic int nfs3_have_delegation(struct inode *inode, fmode_t flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nfs3_return_delegation(struct inode *inode)\r\n{\r\nnfs_wb_all(inode);\r\nreturn 0;\r\n}
