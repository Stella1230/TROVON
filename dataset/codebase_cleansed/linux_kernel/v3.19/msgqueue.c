static struct msgqueue_entry *mqe_alloc(MsgQueue_t *msgq)\r\n{\r\nstruct msgqueue_entry *mq;\r\nif ((mq = msgq->free) != NULL)\r\nmsgq->free = mq->next;\r\nreturn mq;\r\n}\r\nstatic void mqe_free(MsgQueue_t *msgq, struct msgqueue_entry *mq)\r\n{\r\nif (mq) {\r\nmq->next = msgq->free;\r\nmsgq->free = mq;\r\n}\r\n}\r\nvoid msgqueue_initialise(MsgQueue_t *msgq)\r\n{\r\nint i;\r\nmsgq->qe = NULL;\r\nmsgq->free = &msgq->entries[0];\r\nfor (i = 0; i < NR_MESSAGES; i++)\r\nmsgq->entries[i].next = &msgq->entries[i + 1];\r\nmsgq->entries[NR_MESSAGES - 1].next = NULL;\r\n}\r\nvoid msgqueue_free(MsgQueue_t *msgq)\r\n{\r\n}\r\nint msgqueue_msglength(MsgQueue_t *msgq)\r\n{\r\nstruct msgqueue_entry *mq = msgq->qe;\r\nint length = 0;\r\nfor (mq = msgq->qe; mq; mq = mq->next)\r\nlength += mq->msg.length;\r\nreturn length;\r\n}\r\nstruct message *msgqueue_getmsg(MsgQueue_t *msgq, int msgno)\r\n{\r\nstruct msgqueue_entry *mq;\r\nfor (mq = msgq->qe; mq && msgno; mq = mq->next, msgno--);\r\nreturn mq ? &mq->msg : NULL;\r\n}\r\nint msgqueue_addmsg(MsgQueue_t *msgq, int length, ...)\r\n{\r\nstruct msgqueue_entry *mq = mqe_alloc(msgq);\r\nva_list ap;\r\nif (mq) {\r\nstruct msgqueue_entry **mqp;\r\nint i;\r\nva_start(ap, length);\r\nfor (i = 0; i < length; i++)\r\nmq->msg.msg[i] = va_arg(ap, unsigned int);\r\nva_end(ap);\r\nmq->msg.length = length;\r\nmq->msg.fifo = 0;\r\nmq->next = NULL;\r\nmqp = &msgq->qe;\r\nwhile (*mqp)\r\nmqp = &(*mqp)->next;\r\n*mqp = mq;\r\n}\r\nreturn mq != NULL;\r\n}\r\nvoid msgqueue_flush(MsgQueue_t *msgq)\r\n{\r\nstruct msgqueue_entry *mq, *mqnext;\r\nfor (mq = msgq->qe; mq; mq = mqnext) {\r\nmqnext = mq->next;\r\nmqe_free(msgq, mq);\r\n}\r\nmsgq->qe = NULL;\r\n}
