static int get_ctrl_id(__u32 v4l2_id) {\r\nint i;\r\nfor (i = 0; i < G450CTRLS; i++) {\r\nif (v4l2_id < g450_controls[i].desc.id) {\r\nif (g450_controls[i].desc.id == 0x08000000) {\r\nreturn -EINVAL;\r\n}\r\nreturn -ENOENT;\r\n}\r\nif (v4l2_id == g450_controls[i].desc.id) {\r\nreturn i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int *get_ctrl_ptr(struct matrox_fb_info *minfo, unsigned int idx)\r\n{\r\nreturn (int*)((char*)minfo + g450_controls[idx].control);\r\n}\r\nstatic void tvo_fill_defaults(struct matrox_fb_info *minfo)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < G450CTRLS; i++) {\r\n*get_ctrl_ptr(minfo, i) = g450_controls[i].desc.default_value;\r\n}\r\n}\r\nstatic int cve2_get_reg(struct matrox_fb_info *minfo, int reg)\r\n{\r\nunsigned long flags;\r\nint val;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nmatroxfb_DAC_out(minfo, 0x87, reg);\r\nval = matroxfb_DAC_in(minfo, 0x88);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\nreturn val;\r\n}\r\nstatic void cve2_set_reg(struct matrox_fb_info *minfo, int reg, int val)\r\n{\r\nunsigned long flags;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nmatroxfb_DAC_out(minfo, 0x87, reg);\r\nmatroxfb_DAC_out(minfo, 0x88, val);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\nstatic void cve2_set_reg10(struct matrox_fb_info *minfo, int reg, int val)\r\n{\r\nunsigned long flags;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nmatroxfb_DAC_out(minfo, 0x87, reg);\r\nmatroxfb_DAC_out(minfo, 0x88, val >> 2);\r\nmatroxfb_DAC_out(minfo, 0x87, reg + 1);\r\nmatroxfb_DAC_out(minfo, 0x88, val & 3);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\nstatic void g450_compute_bwlevel(const struct matrox_fb_info *minfo, int *bl,\r\nint *wl)\r\n{\r\nconst int b = minfo->altout.tvo_params.brightness + BLMIN;\r\nconst int c = minfo->altout.tvo_params.contrast;\r\n*bl = max(b - c, BLMIN);\r\n*wl = min(b + c, WLMAX);\r\n}\r\nstatic int g450_query_ctrl(void* md, struct v4l2_queryctrl *p) {\r\nint i;\r\ni = get_ctrl_id(p->id);\r\nif (i >= 0) {\r\n*p = g450_controls[i].desc;\r\nreturn 0;\r\n}\r\nif (i == -ENOENT) {\r\nstatic const struct v4l2_queryctrl disctrl =\r\n{ .flags = V4L2_CTRL_FLAG_DISABLED };\r\ni = p->id;\r\n*p = disctrl;\r\np->id = i;\r\nsprintf(p->name, "Ctrl #%08X", i);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int g450_set_ctrl(void* md, struct v4l2_control *p) {\r\nint i;\r\nstruct matrox_fb_info *minfo = md;\r\ni = get_ctrl_id(p->id);\r\nif (i < 0) return -EINVAL;\r\nif (p->value == *get_ctrl_ptr(minfo, i)) return 0;\r\nif (p->value > g450_controls[i].desc.maximum) return -EINVAL;\r\nif (p->value < g450_controls[i].desc.minimum) return -EINVAL;\r\n*get_ctrl_ptr(minfo, i) = p->value;\r\nswitch (p->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\n{\r\nint blacklevel, whitelevel;\r\ng450_compute_bwlevel(minfo, &blacklevel, &whitelevel);\r\ncve2_set_reg10(minfo, 0x0e, blacklevel);\r\ncve2_set_reg10(minfo, 0x1e, whitelevel);\r\n}\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ncve2_set_reg(minfo, 0x20, p->value);\r\ncve2_set_reg(minfo, 0x22, p->value);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ncve2_set_reg(minfo, 0x25, p->value);\r\nbreak;\r\ncase MATROXFB_CID_TESTOUT:\r\n{\r\nunsigned char val = cve2_get_reg(minfo, 0x05);\r\nif (p->value) val |= 0x02;\r\nelse val &= ~0x02;\r\ncve2_set_reg(minfo, 0x05, val);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int g450_get_ctrl(void* md, struct v4l2_control *p) {\r\nint i;\r\nstruct matrox_fb_info *minfo = md;\r\ni = get_ctrl_id(p->id);\r\nif (i < 0) return -EINVAL;\r\np->value = *get_ctrl_ptr(minfo, i);\r\nreturn 0;\r\n}\r\nstatic void computeRegs(struct matrox_fb_info *minfo, struct mavenregs *r,\r\nstruct my_timming *mt, const struct output_desc *outd)\r\n{\r\nu_int32_t chromasc;\r\nu_int32_t hlen;\r\nu_int32_t hsl;\r\nu_int32_t hbp;\r\nu_int32_t hfp;\r\nu_int32_t hvis;\r\nunsigned int pixclock;\r\nunsigned long long piic;\r\nint mnp;\r\nint over;\r\nr->regs[0x80] = 0x03;\r\nhvis = ((mt->HDisplay << 1) + 3) & ~3;\r\nif (hvis >= 2048) {\r\nhvis = 2044;\r\n}\r\npiic = 1000000000ULL * hvis;\r\ndo_div(piic, outd->h_vis);\r\ndprintk(KERN_DEBUG "Want %u kHz pixclock\n", (unsigned int)piic);\r\nmnp = matroxfb_g450_setclk(minfo, piic, M_VIDEO_PLL);\r\nmt->mnp = mnp;\r\nmt->pixclock = g450_mnp2f(minfo, mnp);\r\ndprintk(KERN_DEBUG "MNP=%08X\n", mnp);\r\npixclock = 1000000000U / mt->pixclock;\r\ndprintk(KERN_DEBUG "Got %u ps pixclock\n", pixclock);\r\npiic = outd->chromasc;\r\ndo_div(piic, mt->pixclock);\r\nchromasc = piic;\r\ndprintk(KERN_DEBUG "Chroma is %08X\n", chromasc);\r\nr->regs[0] = piic >> 24;\r\nr->regs[1] = piic >> 16;\r\nr->regs[2] = piic >> 8;\r\nr->regs[3] = piic >> 0;\r\nhbp = (((outd->h_b_porch + pixclock) / pixclock)) & ~1;\r\nhfp = (((outd->h_f_porch + pixclock) / pixclock)) & ~1;\r\nhsl = (((outd->h_sync + pixclock) / pixclock)) & ~1;\r\nhlen = hvis + hfp + hsl + hbp;\r\nover = hlen & 0x0F;\r\ndprintk(KERN_DEBUG "WL: vis=%u, hf=%u, hs=%u, hb=%u, total=%u\n", hvis, hfp, hsl, hbp, hlen);\r\nif (over) {\r\nhfp -= over;\r\nhlen -= over;\r\nif (over <= 2) {\r\n} else if (over < 10) {\r\nhfp += 4;\r\nhlen += 4;\r\n} else {\r\nhfp += 16;\r\nhlen += 16;\r\n}\r\n}\r\nr->regs[0x08] = hsl;\r\nr->regs[0x09] = (outd->burst + pixclock - 1) / pixclock;\r\nr->regs[0x0A] = hbp;\r\nr->regs[0x2C] = hfp;\r\nr->regs[0x31] = hvis / 8;\r\nr->regs[0x32] = hvis & 7;\r\ndprintk(KERN_DEBUG "PG: vis=%04X, hf=%02X, hs=%02X, hb=%02X, total=%04X\n", hvis, hfp, hsl, hbp, hlen);\r\nr->regs[0x84] = 1;\r\nr->regs[0x85] = 0;\r\nhvis = hvis >> 1;\r\nhlen = hlen >> 1;\r\ndprintk(KERN_DEBUG "hlen=%u hvis=%u\n", hlen, hvis);\r\nmt->interlaced = 1;\r\nmt->HDisplay = hvis & ~7;\r\nmt->HSyncStart = mt->HDisplay + 8;\r\nmt->HSyncEnd = (hlen & ~7) - 8;\r\nmt->HTotal = hlen;\r\n{\r\nint upper;\r\nunsigned int vtotal;\r\nunsigned int vsyncend;\r\nunsigned int vdisplay;\r\nvtotal = mt->VTotal;\r\nvsyncend = mt->VSyncEnd;\r\nvdisplay = mt->VDisplay;\r\nif (vtotal < outd->v_total) {\r\nunsigned int yovr = outd->v_total - vtotal;\r\nvsyncend += yovr >> 1;\r\n} else if (vtotal > outd->v_total) {\r\nvdisplay = outd->v_total - 4;\r\nvsyncend = outd->v_total;\r\n}\r\nupper = (outd->v_total - vsyncend) >> 1;\r\nr->regs[0x17] = outd->v_total / 4;\r\nr->regs[0x18] = outd->v_total & 3;\r\nr->regs[0x33] = upper - 1;\r\nr->regs[0x82] = upper;\r\nr->regs[0x83] = upper >> 8;\r\nmt->VDisplay = vdisplay;\r\nmt->VSyncStart = outd->v_total - 2;\r\nmt->VSyncEnd = outd->v_total;\r\nmt->VTotal = outd->v_total;\r\n}\r\n}\r\nstatic void cve2_init_TVdata(int norm, struct mavenregs* data, const struct output_desc** outd) {\r\nstatic const struct output_desc paloutd = {\r\n.h_vis = 52148148,\r\n.h_f_porch = 1407407,\r\n.h_sync = 4666667,\r\n.h_b_porch = 5777778,\r\n.chromasc = 19042247534182ULL,\r\n.burst = 2518518,\r\n.v_total = 625,\r\n};\r\nstatic const struct output_desc ntscoutd = {\r\n.h_vis = 52888889,\r\n.h_f_porch = 1333333,\r\n.h_sync = 4666667,\r\n.h_b_porch = 4666667,\r\n.chromasc = 15374030659475ULL,\r\n.burst = 2418418,\r\n.v_total = 525,\r\n};\r\nstatic const struct mavenregs palregs = { {\r\n0x2A, 0x09, 0x8A, 0xCB,\r\n0x00,\r\n0x00,\r\n0xF9,\r\n0x00,\r\n0x7E,\r\n0x44,\r\n0x9C,\r\n0x2E,\r\n0x21,\r\n0x00,\r\n0x3C, 0x03,\r\n0x3C, 0x03,\r\n0x1A,\r\n0x2A,\r\n0x1C, 0x3D, 0x14,\r\n0x9C, 0x01,\r\n0x00,\r\n0xFE,\r\n0x7E,\r\n0x60,\r\n0x05,\r\n0xAD, 0x03,\r\n0xA5,\r\n0x07,\r\n0xA5,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x08,\r\n0x04,\r\n0x00,\r\n0x1A,\r\n0x55, 0x01,\r\n0x26,\r\n0x07, 0x7E,\r\n0x02, 0x54,\r\n0xB0, 0x00,\r\n0x14,\r\n0x49,\r\n0x00,\r\n0x00,\r\n0xA3,\r\n0xC8,\r\n0x22,\r\n0x02,\r\n0x22,\r\n0x3F, 0x03,\r\n0x00,\r\n0x00,\r\n} };\r\nstatic struct mavenregs ntscregs = { {\r\n0x21, 0xF0, 0x7C, 0x1F,\r\n0x00,\r\n0x00,\r\n0xF9,\r\n0x00,\r\n0x7E,\r\n0x43,\r\n0x7E,\r\n0x3D,\r\n0x00,\r\n0x00,\r\n0x41, 0x00,\r\n0x3C, 0x00,\r\n0x17,\r\n0x21,\r\n0x1B, 0x1B, 0x24,\r\n0x83, 0x01,\r\n0x00,\r\n0x0F,\r\n0x0F,\r\n0x60,\r\n0x05,\r\n0xC0, 0x02,\r\n0x9C,\r\n0x04,\r\n0x9C,\r\n0x01,\r\n0x02,\r\n0x00,\r\n0x0A,\r\n0x05,\r\n0x00,\r\n0x10,\r\n0xFF, 0x03,\r\n0x24,\r\n0x0F, 0x78,\r\n0x00, 0x00,\r\n0xB2, 0x04,\r\n0x14,\r\n0x02,\r\n0x00,\r\n0x00,\r\n0xA3,\r\n0xC8,\r\n0x15,\r\n0x05,\r\n0x3B,\r\n0x3C, 0x00,\r\n0x00,\r\n0x00,\r\n} };\r\nif (norm == MATROXFB_OUTPUT_MODE_PAL) {\r\n*data = palregs;\r\n*outd = &paloutd;\r\n} else {\r\n*data = ntscregs;\r\n*outd = &ntscoutd;\r\n}\r\nreturn;\r\n}\r\nstatic void cve2_init_TV(struct matrox_fb_info *minfo,\r\nconst struct mavenregs *m)\r\n{\r\nint i;\r\nLR(0x80);\r\nLR(0x82); LR(0x83);\r\nLR(0x84); LR(0x85);\r\ncve2_set_reg(minfo, 0x3E, 0x01);\r\nfor (i = 0; i < 0x3E; i++) {\r\nLR(i);\r\n}\r\ncve2_set_reg(minfo, 0x3E, 0x00);\r\n}\r\nstatic int matroxfb_g450_compute(void* md, struct my_timming* mt) {\r\nstruct matrox_fb_info *minfo = md;\r\ndprintk(KERN_DEBUG "Computing, mode=%u\n", minfo->outputs[1].mode);\r\nif (mt->crtc == MATROXFB_SRC_CRTC2 &&\r\nminfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\r\nconst struct output_desc* outd;\r\ncve2_init_TVdata(minfo->outputs[1].mode, &minfo->hw.maven, &outd);\r\n{\r\nint blacklevel, whitelevel;\r\ng450_compute_bwlevel(minfo, &blacklevel, &whitelevel);\r\nminfo->hw.maven.regs[0x0E] = blacklevel >> 2;\r\nminfo->hw.maven.regs[0x0F] = blacklevel & 3;\r\nminfo->hw.maven.regs[0x1E] = whitelevel >> 2;\r\nminfo->hw.maven.regs[0x1F] = whitelevel & 3;\r\nminfo->hw.maven.regs[0x20] =\r\nminfo->hw.maven.regs[0x22] = minfo->altout.tvo_params.saturation;\r\nminfo->hw.maven.regs[0x25] = minfo->altout.tvo_params.hue;\r\nif (minfo->altout.tvo_params.testout) {\r\nminfo->hw.maven.regs[0x05] |= 0x02;\r\n}\r\n}\r\ncomputeRegs(minfo, &minfo->hw.maven, mt, outd);\r\n} else if (mt->mnp < 0) {\r\nmt->mnp = matroxfb_g450_setclk(minfo, mt->pixclock, (mt->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\r\nmt->pixclock = g450_mnp2f(minfo, mt->mnp);\r\n}\r\ndprintk(KERN_DEBUG "Pixclock = %u\n", mt->pixclock);\r\nreturn 0;\r\n}\r\nstatic int matroxfb_g450_program(void* md) {\r\nstruct matrox_fb_info *minfo = md;\r\nif (minfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\r\ncve2_init_TV(minfo, &minfo->hw.maven);\r\n}\r\nreturn 0;\r\n}\r\nstatic int matroxfb_g450_verify_mode(void* md, u_int32_t arg) {\r\nswitch (arg) {\r\ncase MATROXFB_OUTPUT_MODE_PAL:\r\ncase MATROXFB_OUTPUT_MODE_NTSC:\r\ncase MATROXFB_OUTPUT_MODE_MONITOR:\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int g450_dvi_compute(void* md, struct my_timming* mt) {\r\nstruct matrox_fb_info *minfo = md;\r\nif (mt->mnp < 0) {\r\nmt->mnp = matroxfb_g450_setclk(minfo, mt->pixclock, (mt->crtc == MATROXFB_SRC_CRTC1) ? M_PIXEL_PLL_C : M_VIDEO_PLL);\r\nmt->pixclock = g450_mnp2f(minfo, mt->mnp);\r\n}\r\nreturn 0;\r\n}\r\nvoid matroxfb_g450_connect(struct matrox_fb_info *minfo)\r\n{\r\nif (minfo->devflags.g450dac) {\r\ndown_write(&minfo->altout.lock);\r\ntvo_fill_defaults(minfo);\r\nminfo->outputs[1].src = minfo->outputs[1].default_src;\r\nminfo->outputs[1].data = minfo;\r\nminfo->outputs[1].output = &matroxfb_g450_altout;\r\nminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nminfo->outputs[2].src = minfo->outputs[2].default_src;\r\nminfo->outputs[2].data = minfo;\r\nminfo->outputs[2].output = &matroxfb_g450_dvi;\r\nminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nup_write(&minfo->altout.lock);\r\n}\r\n}\r\nvoid matroxfb_g450_shutdown(struct matrox_fb_info *minfo)\r\n{\r\nif (minfo->devflags.g450dac) {\r\ndown_write(&minfo->altout.lock);\r\nminfo->outputs[1].src = MATROXFB_SRC_NONE;\r\nminfo->outputs[1].output = NULL;\r\nminfo->outputs[1].data = NULL;\r\nminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nminfo->outputs[2].src = MATROXFB_SRC_NONE;\r\nminfo->outputs[2].output = NULL;\r\nminfo->outputs[2].data = NULL;\r\nminfo->outputs[2].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nup_write(&minfo->altout.lock);\r\n}\r\n}
