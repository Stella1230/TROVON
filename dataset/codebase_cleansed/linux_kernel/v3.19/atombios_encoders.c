static u8\r\nradeon_atom_get_backlight_level_from_reg(struct radeon_device *rdev)\r\n{\r\nu8 backlight_level;\r\nu32 bios_2_scratch;\r\nif (rdev->family >= CHIP_R600)\r\nbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\r\nelse\r\nbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\r\nbacklight_level = ((bios_2_scratch & ATOM_S2_CURRENT_BL_LEVEL_MASK) >>\r\nATOM_S2_CURRENT_BL_LEVEL_SHIFT);\r\nreturn backlight_level;\r\n}\r\nstatic void\r\nradeon_atom_set_backlight_level_to_reg(struct radeon_device *rdev,\r\nu8 backlight_level)\r\n{\r\nu32 bios_2_scratch;\r\nif (rdev->family >= CHIP_R600)\r\nbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\r\nelse\r\nbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\r\nbios_2_scratch &= ~ATOM_S2_CURRENT_BL_LEVEL_MASK;\r\nbios_2_scratch |= ((backlight_level << ATOM_S2_CURRENT_BL_LEVEL_SHIFT) &\r\nATOM_S2_CURRENT_BL_LEVEL_MASK);\r\nif (rdev->family >= CHIP_R600)\r\nWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\r\nelse\r\nWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\r\n}\r\nu8\r\natombios_get_backlight_level(struct radeon_encoder *radeon_encoder)\r\n{\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\r\nreturn 0;\r\nreturn radeon_atom_get_backlight_level_from_reg(rdev);\r\n}\r\nvoid\r\natombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)\r\n{\r\nstruct drm_encoder *encoder = &radeon_encoder->base;\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder_atom_dig *dig;\r\nDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION args;\r\nint index;\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\r\nreturn;\r\nif ((radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\r\nradeon_encoder->enc_priv) {\r\ndig = radeon_encoder->enc_priv;\r\ndig->backlight_level = level;\r\nradeon_atom_set_backlight_level_to_reg(rdev, dig->backlight_level);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\r\nif (dig->backlight_level == 0) {\r\nargs.ucAction = ATOM_LCD_BLOFF;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n} else {\r\nargs.ucAction = ATOM_LCD_BL_BRIGHTNESS_CONTROL;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nargs.ucAction = ATOM_LCD_BLON;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nif (dig->backlight_level == 0)\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);\r\nelse {\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_BL_BRIGHTNESS_CONTROL, 0, 0);\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u8 radeon_atom_bl_level(struct backlight_device *bd)\r\n{\r\nu8 level;\r\nif (bd->props.brightness < 0)\r\nlevel = 0;\r\nelse if (bd->props.brightness > RADEON_MAX_BL_LEVEL)\r\nlevel = RADEON_MAX_BL_LEVEL;\r\nelse\r\nlevel = bd->props.brightness;\r\nreturn level;\r\n}\r\nstatic int radeon_atom_backlight_update_status(struct backlight_device *bd)\r\n{\r\nstruct radeon_backlight_privdata *pdata = bl_get_data(bd);\r\nstruct radeon_encoder *radeon_encoder = pdata->encoder;\r\natombios_set_backlight_level(radeon_encoder, radeon_atom_bl_level(bd));\r\nreturn 0;\r\n}\r\nstatic int radeon_atom_backlight_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct radeon_backlight_privdata *pdata = bl_get_data(bd);\r\nstruct radeon_encoder *radeon_encoder = pdata->encoder;\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nreturn radeon_atom_get_backlight_level_from_reg(rdev);\r\n}\r\nvoid radeon_atom_backlight_init(struct radeon_encoder *radeon_encoder,\r\nstruct drm_connector *drm_connector)\r\n{\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nstruct radeon_backlight_privdata *pdata;\r\nstruct radeon_encoder_atom_dig *dig;\r\nchar bl_name[16];\r\nif ((rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&\r\n(rdev->pdev->device == 0x6741))\r\nreturn;\r\nif (!radeon_encoder->enc_priv)\r\nreturn;\r\nif (!rdev->is_atom_bios)\r\nreturn;\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\r\nreturn;\r\npdata = kmalloc(sizeof(struct radeon_backlight_privdata), GFP_KERNEL);\r\nif (!pdata) {\r\nDRM_ERROR("Memory allocation failed\n");\r\ngoto error;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.max_brightness = RADEON_MAX_BL_LEVEL;\r\nprops.type = BACKLIGHT_RAW;\r\nsnprintf(bl_name, sizeof(bl_name),\r\n"radeon_bl%d", dev->primary->index);\r\nbd = backlight_device_register(bl_name, drm_connector->kdev,\r\npdata, &radeon_atom_backlight_ops, &props);\r\nif (IS_ERR(bd)) {\r\nDRM_ERROR("Backlight registration failed\n");\r\ngoto error;\r\n}\r\npdata->encoder = radeon_encoder;\r\ndig = radeon_encoder->enc_priv;\r\ndig->bl_dev = bd;\r\nbd->props.brightness = radeon_atom_backlight_get_brightness(bd);\r\nif (bd->props.brightness == 0)\r\nbd->props.brightness = RADEON_MAX_BL_LEVEL;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nDRM_INFO("radeon atom DIG backlight initialized\n");\r\nreturn;\r\nerror:\r\nkfree(pdata);\r\nreturn;\r\n}\r\nstatic void radeon_atom_backlight_exit(struct radeon_encoder *radeon_encoder)\r\n{\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct backlight_device *bd = NULL;\r\nstruct radeon_encoder_atom_dig *dig;\r\nif (!radeon_encoder->enc_priv)\r\nreturn;\r\nif (!rdev->is_atom_bios)\r\nreturn;\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\r\nreturn;\r\ndig = radeon_encoder->enc_priv;\r\nbd = dig->bl_dev;\r\ndig->bl_dev = NULL;\r\nif (bd) {\r\nstruct radeon_legacy_backlight_privdata *pdata;\r\npdata = bl_get_data(bd);\r\nbacklight_device_unregister(bd);\r\nkfree(pdata);\r\nDRM_INFO("radeon atom LVDS backlight unloaded\n");\r\n}\r\n}\r\nvoid radeon_atom_backlight_init(struct radeon_encoder *encoder)\r\n{\r\n}\r\nstatic void radeon_atom_backlight_exit(struct radeon_encoder *encoder)\r\n{\r\n}\r\nstatic bool radeon_atom_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nradeon_encoder_set_active_device(encoder);\r\ndrm_mode_set_crtcinfo(adjusted_mode, 0);\r\nif ((mode->flags & DRM_MODE_FLAG_INTERLACE)\r\n&& (mode->crtc_vsync_start < (mode->crtc_vdisplay + 2)))\r\nadjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vdisplay + 2;\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nradeon_panel_mode_fixup(encoder, adjusted_mode);\r\n} else if (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT)) {\r\nstruct radeon_encoder_atom_dac *tv_dac = radeon_encoder->enc_priv;\r\nif (tv_dac) {\r\nif (tv_dac->tv_std == TV_STD_NTSC ||\r\ntv_dac->tv_std == TV_STD_NTSC_J ||\r\ntv_dac->tv_std == TV_STD_PAL_M)\r\nradeon_atom_get_tv_timings(rdev, 0, adjusted_mode);\r\nelse\r\nradeon_atom_get_tv_timings(rdev, 1, adjusted_mode);\r\n}\r\n} else if (radeon_encoder->rmx_type != RMX_OFF) {\r\nradeon_panel_mode_fixup(encoder, adjusted_mode);\r\n}\r\nif (ASIC_IS_DCE3(rdev) &&\r\n((radeon_encoder->active_device & (ATOM_DEVICE_DFP_SUPPORT | ATOM_DEVICE_LCD_SUPPORT)) ||\r\n(radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE))) {\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nradeon_dp_set_link_config(connector, adjusted_mode);\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\natombios_dac_setup(struct drm_encoder *encoder, int action)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nDAC_ENCODER_CONTROL_PS_ALLOCATION args;\r\nint index = 0;\r\nstruct radeon_encoder_atom_dac *dac_info = radeon_encoder->enc_priv;\r\nmemset(&args, 0, sizeof(args));\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\nindex = GetIndexIntoMasterTable(COMMAND, DAC1EncoderControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\nindex = GetIndexIntoMasterTable(COMMAND, DAC2EncoderControl);\r\nbreak;\r\n}\r\nargs.ucAction = action;\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_CRT_SUPPORT))\r\nargs.ucDacStandard = ATOM_DAC1_PS2;\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.ucDacStandard = ATOM_DAC1_CV;\r\nelse {\r\nswitch (dac_info->tv_std) {\r\ncase TV_STD_PAL:\r\ncase TV_STD_PAL_M:\r\ncase TV_STD_SCART_PAL:\r\ncase TV_STD_SECAM:\r\ncase TV_STD_PAL_CN:\r\nargs.ucDacStandard = ATOM_DAC1_PAL;\r\nbreak;\r\ncase TV_STD_NTSC:\r\ncase TV_STD_NTSC_J:\r\ncase TV_STD_PAL_60:\r\ndefault:\r\nargs.ucDacStandard = ATOM_DAC1_NTSC;\r\nbreak;\r\n}\r\n}\r\nargs.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void\r\natombios_tv_setup(struct drm_encoder *encoder, int action)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nTV_ENCODER_CONTROL_PS_ALLOCATION args;\r\nint index = 0;\r\nstruct radeon_encoder_atom_dac *dac_info = radeon_encoder->enc_priv;\r\nmemset(&args, 0, sizeof(args));\r\nindex = GetIndexIntoMasterTable(COMMAND, TVEncoderControl);\r\nargs.sTVEncoder.ucAction = action;\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_CV;\r\nelse {\r\nswitch (dac_info->tv_std) {\r\ncase TV_STD_NTSC:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_NTSC;\r\nbreak;\r\ncase TV_STD_PAL:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_PAL;\r\nbreak;\r\ncase TV_STD_PAL_M:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_PALM;\r\nbreak;\r\ncase TV_STD_PAL_60:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_PAL60;\r\nbreak;\r\ncase TV_STD_NTSC_J:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_NTSCJ;\r\nbreak;\r\ncase TV_STD_SCART_PAL:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_PAL;\r\nbreak;\r\ncase TV_STD_SECAM:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_SECAM;\r\nbreak;\r\ncase TV_STD_PAL_CN:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_PALCN;\r\nbreak;\r\ndefault:\r\nargs.sTVEncoder.ucTvStandard = ATOM_TV_NTSC;\r\nbreak;\r\n}\r\n}\r\nargs.sTVEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic u8 radeon_atom_get_bpc(struct drm_encoder *encoder)\r\n{\r\nint bpc = 8;\r\nif (encoder->crtc) {\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nbpc = radeon_crtc->bpc;\r\n}\r\nswitch (bpc) {\r\ncase 0:\r\nreturn PANEL_BPC_UNDEFINE;\r\ncase 6:\r\nreturn PANEL_6BIT_PER_COLOR;\r\ncase 8:\r\ndefault:\r\nreturn PANEL_8BIT_PER_COLOR;\r\ncase 10:\r\nreturn PANEL_10BIT_PER_COLOR;\r\ncase 12:\r\nreturn PANEL_12BIT_PER_COLOR;\r\ncase 16:\r\nreturn PANEL_16BIT_PER_COLOR;\r\n}\r\n}\r\nvoid\r\natombios_dvo_setup(struct drm_encoder *encoder, int action)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nunion dvo_encoder_control args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);\r\nuint8_t frev, crev;\r\nmemset(&args, 0, sizeof(args));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nif (rdev->family <= CHIP_RV410)\r\nfrev = 1;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\nargs.ext_tmds.sXTmdsEncoder.ucEnable = action;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.ext_tmds.sXTmdsEncoder.ucMisc |= PANEL_ENCODER_MISC_DUAL;\r\nargs.ext_tmds.sXTmdsEncoder.ucMisc |= ATOM_PANEL_MISC_888RGB;\r\nbreak;\r\ncase 2:\r\nargs.dvo.sDVOEncoder.ucAction = action;\r\nargs.dvo.sDVOEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.dvo.sDVOEncoder.ucDeviceType = ATOM_DEVICE_DFP1_INDEX;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.dvo.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute |= PANEL_ENCODER_MISC_DUAL;\r\nbreak;\r\ncase 3:\r\nargs.dvo_v3.ucAction = action;\r\nargs.dvo_v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.dvo_v3.ucDVOConfig = 0;\r\nbreak;\r\ncase 4:\r\nargs.dvo_v4.ucAction = action;\r\nargs.dvo_v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.dvo_v4.ucDVOConfig = 0;\r\nargs.dvo_v4.ucBitPerColor = radeon_atom_get_bpc(encoder);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid\r\natombios_digital_setup(struct drm_encoder *encoder, int action)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nunion lvds_encoder_control args;\r\nint index = 0;\r\nint hdmi_detected = 0;\r\nuint8_t frev, crev;\r\nif (!dig)\r\nreturn;\r\nif (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI)\r\nhdmi_detected = 1;\r\nmemset(&args, 0, sizeof(args));\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\nindex = GetIndexIntoMasterTable(COMMAND, LVDSEncoderControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nindex = GetIndexIntoMasterTable(COMMAND, TMDS1EncoderControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, LVDSEncoderControl);\r\nelse\r\nindex = GetIndexIntoMasterTable(COMMAND, TMDS2EncoderControl);\r\nbreak;\r\n}\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nargs.v1.ucMisc = 0;\r\nargs.v1.ucAction = action;\r\nif (hdmi_detected)\r\nargs.v1.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;\r\nargs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_DUAL)\r\nargs.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\r\nargs.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;\r\n} else {\r\nif (dig->linkb)\r\nargs.v1.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;\r\nargs.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;\r\n}\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nargs.v2.ucMisc = 0;\r\nargs.v2.ucAction = action;\r\nif (crev == 3) {\r\nif (dig->coherent_mode)\r\nargs.v2.ucMisc |= PANEL_ENCODER_MISC_COHERENT;\r\n}\r\nif (hdmi_detected)\r\nargs.v2.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;\r\nargs.v2.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.v2.ucTruncate = 0;\r\nargs.v2.ucSpatial = 0;\r\nargs.v2.ucTemporal = 0;\r\nargs.v2.ucFRC = 0;\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_DUAL)\r\nargs.v2.ucMisc |= PANEL_ENCODER_MISC_DUAL;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_SPATIAL) {\r\nargs.v2.ucSpatial = PANEL_ENCODER_SPATIAL_DITHER_EN;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\r\nargs.v2.ucSpatial |= PANEL_ENCODER_SPATIAL_DITHER_DEPTH;\r\n}\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_TEMPORAL) {\r\nargs.v2.ucTemporal = PANEL_ENCODER_TEMPORAL_DITHER_EN;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\r\nargs.v2.ucTemporal |= PANEL_ENCODER_TEMPORAL_DITHER_DEPTH;\r\nif (((dig->lcd_misc >> ATOM_PANEL_MISC_GREY_LEVEL_SHIFT) & 0x3) == 2)\r\nargs.v2.ucTemporal |= PANEL_ENCODER_TEMPORAL_LEVEL_4;\r\n}\r\n} else {\r\nif (dig->linkb)\r\nargs.v2.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v2.ucMisc |= PANEL_ENCODER_MISC_DUAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nint\r\natombios_get_encoder_mode(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nif (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)\r\nreturn ATOM_ENCODER_MODE_DP;\r\nif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DVO1) ||\r\n(radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1))\r\nreturn ATOM_ENCODER_MODE_DVO;\r\nconnector = radeon_get_connector_for_encoder(encoder);\r\nif (!connector)\r\nconnector = radeon_get_connector_for_encoder_init(encoder);\r\nradeon_connector = to_radeon_connector(connector);\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\nif (radeon_audio != 0) {\r\nif (radeon_connector->use_digital &&\r\n(radeon_connector->audio == RADEON_AUDIO_ENABLE))\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\r\n(radeon_connector->audio == RADEON_AUDIO_AUTO))\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse if (radeon_connector->use_digital)\r\nreturn ATOM_ENCODER_MODE_DVI;\r\nelse\r\nreturn ATOM_ENCODER_MODE_CRT;\r\n} else if (radeon_connector->use_digital) {\r\nreturn ATOM_ENCODER_MODE_DVI;\r\n} else {\r\nreturn ATOM_ENCODER_MODE_CRT;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ndefault:\r\nif (radeon_audio != 0) {\r\nif (radeon_connector->audio == RADEON_AUDIO_ENABLE)\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\r\n(radeon_connector->audio == RADEON_AUDIO_AUTO))\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse\r\nreturn ATOM_ENCODER_MODE_DVI;\r\n} else {\r\nreturn ATOM_ENCODER_MODE_DVI;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\nreturn ATOM_ENCODER_MODE_LVDS;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ndig_connector = radeon_connector->con_priv;\r\nif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\r\nreturn ATOM_ENCODER_MODE_DP;\r\n} else if (radeon_audio != 0) {\r\nif (radeon_connector->audio == RADEON_AUDIO_ENABLE)\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\r\n(radeon_connector->audio == RADEON_AUDIO_AUTO))\r\nreturn ATOM_ENCODER_MODE_HDMI;\r\nelse\r\nreturn ATOM_ENCODER_MODE_DVI;\r\n} else {\r\nreturn ATOM_ENCODER_MODE_DVI;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_eDP:\r\nreturn ATOM_ENCODER_MODE_DP;\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ncase DRM_MODE_CONNECTOR_VGA:\r\nreturn ATOM_ENCODER_MODE_CRT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\nreturn ATOM_ENCODER_MODE_TV;\r\nbreak;\r\n}\r\n}\r\nvoid\r\natombios_dig_encoder_setup(struct drm_encoder *encoder, int action, int panel_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nunion dig_encoder_control args;\r\nint index = 0;\r\nuint8_t frev, crev;\r\nint dp_clock = 0;\r\nint dp_lane_count = 0;\r\nint hpd_id = RADEON_HPD_NONE;\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\ndp_clock = dig_connector->dp_clock;\r\ndp_lane_count = dig_connector->dp_lane_count;\r\nhpd_id = radeon_connector->hpd.hpd;\r\n}\r\nif (dig->dig_encoder == -1)\r\nreturn;\r\nmemset(&args, 0, sizeof(args));\r\nif (ASIC_IS_DCE4(rdev))\r\nindex = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);\r\nelse {\r\nif (dig->dig_encoder)\r\nindex = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);\r\nelse\r\nindex = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);\r\n}\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\nargs.v1.ucAction = action;\r\nargs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\r\nargs.v3.ucPanelMode = panel_mode;\r\nelse\r\nargs.v1.ucEncoderMode = atombios_get_encoder_mode(encoder);\r\nif (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode))\r\nargs.v1.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v1.ucLaneNum = 8;\r\nelse\r\nargs.v1.ucLaneNum = 4;\r\nif (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) && (dp_clock == 270000))\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nargs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nargs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER2;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nargs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER3;\r\nbreak;\r\n}\r\nif (dig->linkb)\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;\r\nelse\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nargs.v3.ucAction = action;\r\nargs.v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\r\nargs.v3.ucPanelMode = panel_mode;\r\nelse\r\nargs.v3.ucEncoderMode = atombios_get_encoder_mode(encoder);\r\nif (ENCODER_MODE_IS_DP(args.v3.ucEncoderMode))\r\nargs.v3.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v3.ucLaneNum = 8;\r\nelse\r\nargs.v3.ucLaneNum = 4;\r\nif (ENCODER_MODE_IS_DP(args.v3.ucEncoderMode) && (dp_clock == 270000))\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V3_DPLINKRATE_2_70GHZ;\r\nargs.v3.acConfig.ucDigSel = dig->dig_encoder;\r\nargs.v3.ucBitPerColor = radeon_atom_get_bpc(encoder);\r\nbreak;\r\ncase 4:\r\nargs.v4.ucAction = action;\r\nargs.v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\r\nargs.v4.ucPanelMode = panel_mode;\r\nelse\r\nargs.v4.ucEncoderMode = atombios_get_encoder_mode(encoder);\r\nif (ENCODER_MODE_IS_DP(args.v4.ucEncoderMode))\r\nargs.v4.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v4.ucLaneNum = 8;\r\nelse\r\nargs.v4.ucLaneNum = 4;\r\nif (ENCODER_MODE_IS_DP(args.v4.ucEncoderMode)) {\r\nif (dp_clock == 540000)\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_5_40GHZ;\r\nelse if (dp_clock == 324000)\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_3_24GHZ;\r\nelse if (dp_clock == 270000)\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_2_70GHZ;\r\nelse\r\nargs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_1_62GHZ;\r\n}\r\nargs.v4.acConfig.ucDigSel = dig->dig_encoder;\r\nargs.v4.ucBitPerColor = radeon_atom_get_bpc(encoder);\r\nif (hpd_id == RADEON_HPD_NONE)\r\nargs.v4.ucHPD_ID = 0;\r\nelse\r\nargs.v4.ucHPD_ID = hpd_id + 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid\r\natombios_dig_transmitter_setup(struct drm_encoder *encoder, int action, uint8_t lane_num, uint8_t lane_set)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct drm_connector *connector;\r\nunion dig_transmitter_control args;\r\nint index = 0;\r\nuint8_t frev, crev;\r\nbool is_dp = false;\r\nint pll_id = 0;\r\nint dp_clock = 0;\r\nint dp_lane_count = 0;\r\nint connector_object_id = 0;\r\nint igp_lane_info = 0;\r\nint dig_encoder = dig->dig_encoder;\r\nint hpd_id = RADEON_HPD_NONE;\r\nif (action == ATOM_TRANSMITTER_ACTION_INIT) {\r\nconnector = radeon_get_connector_for_encoder_init(encoder);\r\ndig_encoder = 0;\r\n} else\r\nconnector = radeon_get_connector_for_encoder(encoder);\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\nhpd_id = radeon_connector->hpd.hpd;\r\ndp_clock = dig_connector->dp_clock;\r\ndp_lane_count = dig_connector->dp_lane_count;\r\nconnector_object_id =\r\n(radeon_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\r\nigp_lane_info = dig_connector->igp_lane_info;\r\n}\r\nif (encoder->crtc) {\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\npll_id = radeon_crtc->pll_id;\r\n}\r\nif (dig_encoder == -1)\r\nreturn;\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)))\r\nis_dp = true;\r\nmemset(&args, 0, sizeof(args));\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nindex = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\nindex = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nindex = GetIndexIntoMasterTable(COMMAND, LVTMATransmitterControl);\r\nbreak;\r\n}\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\nargs.v1.ucAction = action;\r\nif (action == ATOM_TRANSMITTER_ACTION_INIT) {\r\nargs.v1.usInitInfo = cpu_to_le16(connector_object_id);\r\n} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\r\nargs.v1.asMode.ucLaneSel = lane_num;\r\nargs.v1.asMode.ucLaneSet = lane_set;\r\n} else {\r\nif (is_dp)\r\nargs.v1.usPixelClock = cpu_to_le16(dp_clock / 10);\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v1.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\r\nelse\r\nargs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\n}\r\nargs.v1.ucConfig = ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;\r\nif (dig_encoder)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG2_ENCODER;\r\nelse\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG1_ENCODER;\r\nif ((rdev->flags & RADEON_IS_IGP) &&\r\n(radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_UNIPHY)) {\r\nif (is_dp ||\r\n!radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock)) {\r\nif (igp_lane_info & 0x1)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_3;\r\nelse if (igp_lane_info & 0x2)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_4_7;\r\nelse if (igp_lane_info & 0x4)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_8_11;\r\nelse if (igp_lane_info & 0x8)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_12_15;\r\n} else {\r\nif (igp_lane_info & 0x3)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_7;\r\nelse if (igp_lane_info & 0xc)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_8_15;\r\n}\r\n}\r\nif (dig->linkb)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKB;\r\nelse\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKA;\r\nif (is_dp)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;\r\nelse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (dig->coherent_mode)\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_8LANE_LINK;\r\n}\r\nbreak;\r\ncase 2:\r\nargs.v2.ucAction = action;\r\nif (action == ATOM_TRANSMITTER_ACTION_INIT) {\r\nargs.v2.usInitInfo = cpu_to_le16(connector_object_id);\r\n} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\r\nargs.v2.asMode.ucLaneSel = lane_num;\r\nargs.v2.asMode.ucLaneSet = lane_set;\r\n} else {\r\nif (is_dp)\r\nargs.v2.usPixelClock = cpu_to_le16(dp_clock / 10);\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v2.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\r\nelse\r\nargs.v2.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\n}\r\nargs.v2.acConfig.ucEncoderSel = dig_encoder;\r\nif (dig->linkb)\r\nargs.v2.acConfig.ucLinkSel = 1;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nargs.v2.acConfig.ucTransmitterSel = 0;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nargs.v2.acConfig.ucTransmitterSel = 1;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nargs.v2.acConfig.ucTransmitterSel = 2;\r\nbreak;\r\n}\r\nif (is_dp) {\r\nargs.v2.acConfig.fCoherentMode = 1;\r\nargs.v2.acConfig.fDPConnector = 1;\r\n} else if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (dig->coherent_mode)\r\nargs.v2.acConfig.fCoherentMode = 1;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v2.acConfig.fDualLinkConnector = 1;\r\n}\r\nbreak;\r\ncase 3:\r\nargs.v3.ucAction = action;\r\nif (action == ATOM_TRANSMITTER_ACTION_INIT) {\r\nargs.v3.usInitInfo = cpu_to_le16(connector_object_id);\r\n} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\r\nargs.v3.asMode.ucLaneSel = lane_num;\r\nargs.v3.asMode.ucLaneSet = lane_set;\r\n} else {\r\nif (is_dp)\r\nargs.v3.usPixelClock = cpu_to_le16(dp_clock / 10);\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v3.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\r\nelse\r\nargs.v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\n}\r\nif (is_dp)\r\nargs.v3.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v3.ucLaneNum = 8;\r\nelse\r\nargs.v3.ucLaneNum = 4;\r\nif (dig->linkb)\r\nargs.v3.acConfig.ucLinkSel = 1;\r\nif (dig_encoder & 1)\r\nargs.v3.acConfig.ucEncoderSel = 1;\r\nif (is_dp && rdev->clock.dp_extclk)\r\nargs.v3.acConfig.ucRefClkSource = 2;\r\nelse\r\nargs.v3.acConfig.ucRefClkSource = pll_id;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nargs.v3.acConfig.ucTransmitterSel = 0;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nargs.v3.acConfig.ucTransmitterSel = 1;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nargs.v3.acConfig.ucTransmitterSel = 2;\r\nbreak;\r\n}\r\nif (is_dp)\r\nargs.v3.acConfig.fCoherentMode = 1;\r\nelse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (dig->coherent_mode)\r\nargs.v3.acConfig.fCoherentMode = 1;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v3.acConfig.fDualLinkConnector = 1;\r\n}\r\nbreak;\r\ncase 4:\r\nargs.v4.ucAction = action;\r\nif (action == ATOM_TRANSMITTER_ACTION_INIT) {\r\nargs.v4.usInitInfo = cpu_to_le16(connector_object_id);\r\n} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\r\nargs.v4.asMode.ucLaneSel = lane_num;\r\nargs.v4.asMode.ucLaneSet = lane_set;\r\n} else {\r\nif (is_dp)\r\nargs.v4.usPixelClock = cpu_to_le16(dp_clock / 10);\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v4.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\r\nelse\r\nargs.v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\n}\r\nif (is_dp)\r\nargs.v4.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v4.ucLaneNum = 8;\r\nelse\r\nargs.v4.ucLaneNum = 4;\r\nif (dig->linkb)\r\nargs.v4.acConfig.ucLinkSel = 1;\r\nif (dig_encoder & 1)\r\nargs.v4.acConfig.ucEncoderSel = 1;\r\nif (is_dp) {\r\nif (rdev->clock.dp_extclk)\r\nargs.v4.acConfig.ucRefClkSource = ENCODER_REFCLK_SRC_EXTCLK;\r\nelse\r\nargs.v4.acConfig.ucRefClkSource = ENCODER_REFCLK_SRC_DCPLL;\r\n} else\r\nargs.v4.acConfig.ucRefClkSource = pll_id;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nargs.v4.acConfig.ucTransmitterSel = 0;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nargs.v4.acConfig.ucTransmitterSel = 1;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nargs.v4.acConfig.ucTransmitterSel = 2;\r\nbreak;\r\n}\r\nif (is_dp)\r\nargs.v4.acConfig.fCoherentMode = 1;\r\nelse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (dig->coherent_mode)\r\nargs.v4.acConfig.fCoherentMode = 1;\r\nif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v4.acConfig.fDualLinkConnector = 1;\r\n}\r\nbreak;\r\ncase 5:\r\nargs.v5.ucAction = action;\r\nif (is_dp)\r\nargs.v5.usSymClock = cpu_to_le16(dp_clock / 10);\r\nelse\r\nargs.v5.usSymClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nif (dig->linkb)\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYB;\r\nelse\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYA;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nif (dig->linkb)\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYD;\r\nelse\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYC;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nif (dig->linkb)\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYF;\r\nelse\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYE;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\nargs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYG;\r\nbreak;\r\n}\r\nif (is_dp)\r\nargs.v5.ucLaneNum = dp_lane_count;\r\nelse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v5.ucLaneNum = 8;\r\nelse\r\nargs.v5.ucLaneNum = 4;\r\nargs.v5.ucConnObjId = connector_object_id;\r\nargs.v5.ucDigMode = atombios_get_encoder_mode(encoder);\r\nif (is_dp && rdev->clock.dp_extclk)\r\nargs.v5.asConfig.ucPhyClkSrcId = ENCODER_REFCLK_SRC_EXTCLK;\r\nelse\r\nargs.v5.asConfig.ucPhyClkSrcId = pll_id;\r\nif (is_dp)\r\nargs.v5.asConfig.ucCoherentMode = 1;\r\nelse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nif (dig->coherent_mode)\r\nargs.v5.asConfig.ucCoherentMode = 1;\r\n}\r\nif (hpd_id == RADEON_HPD_NONE)\r\nargs.v5.asConfig.ucHPDSel = 0;\r\nelse\r\nargs.v5.asConfig.ucHPDSel = hpd_id + 1;\r\nargs.v5.ucDigEncoderSel = 1 << dig_encoder;\r\nargs.v5.ucDPLaneSet = lane_set;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nbreak;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nbool\r\natombios_set_edp_panel_power(struct drm_connector *connector, int action)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_device *dev = radeon_connector->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nunion dig_transmitter_control args;\r\nint index = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);\r\nuint8_t frev, crev;\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_eDP)\r\ngoto done;\r\nif (!ASIC_IS_DCE4(rdev))\r\ngoto done;\r\nif ((action != ATOM_TRANSMITTER_ACTION_POWER_ON) &&\r\n(action != ATOM_TRANSMITTER_ACTION_POWER_OFF))\r\ngoto done;\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\ngoto done;\r\nmemset(&args, 0, sizeof(args));\r\nargs.v1.ucAction = action;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nif (action == ATOM_TRANSMITTER_ACTION_POWER_ON) {\r\nint i;\r\nfor (i = 0; i < 300; i++) {\r\nif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd))\r\nreturn true;\r\nmdelay(1);\r\n}\r\nreturn false;\r\n}\r\ndone:\r\nreturn true;\r\n}\r\nstatic void\r\natombios_external_encoder_setup(struct drm_encoder *encoder,\r\nstruct drm_encoder *ext_encoder,\r\nint action)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder *ext_radeon_encoder = to_radeon_encoder(ext_encoder);\r\nunion external_encoder_control args;\r\nstruct drm_connector *connector;\r\nint index = GetIndexIntoMasterTable(COMMAND, ExternalEncoderControl);\r\nu8 frev, crev;\r\nint dp_clock = 0;\r\nint dp_lane_count = 0;\r\nint connector_object_id = 0;\r\nu32 ext_enum = (ext_radeon_encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\r\nif (action == EXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT)\r\nconnector = radeon_get_connector_for_encoder_init(encoder);\r\nelse\r\nconnector = radeon_get_connector_for_encoder(encoder);\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\ndp_clock = dig_connector->dp_clock;\r\ndp_lane_count = dig_connector->dp_lane_count;\r\nconnector_object_id =\r\n(radeon_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\r\n}\r\nmemset(&args, 0, sizeof(args));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\ncase 2:\r\nargs.v1.sDigEncoder.ucAction = action;\r\nargs.v1.sDigEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.v1.sDigEncoder.ucEncoderMode = atombios_get_encoder_mode(encoder);\r\nif (ENCODER_MODE_IS_DP(args.v1.sDigEncoder.ucEncoderMode)) {\r\nif (dp_clock == 270000)\r\nargs.v1.sDigEncoder.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;\r\nargs.v1.sDigEncoder.ucLaneNum = dp_lane_count;\r\n} else if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v1.sDigEncoder.ucLaneNum = 8;\r\nelse\r\nargs.v1.sDigEncoder.ucLaneNum = 4;\r\nbreak;\r\ncase 3:\r\nargs.v3.sExtEncoder.ucAction = action;\r\nif (action == EXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT)\r\nargs.v3.sExtEncoder.usConnectorId = cpu_to_le16(connector_object_id);\r\nelse\r\nargs.v3.sExtEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\r\nargs.v3.sExtEncoder.ucEncoderMode = atombios_get_encoder_mode(encoder);\r\nif (ENCODER_MODE_IS_DP(args.v3.sExtEncoder.ucEncoderMode)) {\r\nif (dp_clock == 270000)\r\nargs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_DPLINKRATE_2_70GHZ;\r\nelse if (dp_clock == 540000)\r\nargs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_DPLINKRATE_5_40GHZ;\r\nargs.v3.sExtEncoder.ucLaneNum = dp_lane_count;\r\n} else if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\r\nargs.v3.sExtEncoder.ucLaneNum = 8;\r\nelse\r\nargs.v3.sExtEncoder.ucLaneNum = 4;\r\nswitch (ext_enum) {\r\ncase GRAPH_OBJECT_ENUM_ID1:\r\nargs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER1;\r\nbreak;\r\ncase GRAPH_OBJECT_ENUM_ID2:\r\nargs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER2;\r\nbreak;\r\ncase GRAPH_OBJECT_ENUM_ID3:\r\nargs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER3;\r\nbreak;\r\n}\r\nargs.v3.sExtEncoder.ucBitPerColor = radeon_atom_get_bpc(encoder);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version: %d, %d\n", frev, crev);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version: %d, %d\n", frev, crev);\r\nreturn;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void\r\natombios_yuv_setup(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nENABLE_YUV_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableYUV);\r\nuint32_t temp, reg;\r\nmemset(&args, 0, sizeof(args));\r\nif (rdev->family >= CHIP_R600)\r\nreg = R600_BIOS_3_SCRATCH;\r\nelse\r\nreg = RADEON_BIOS_3_SCRATCH;\r\ntemp = RREG32(reg);\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nWREG32(reg, (ATOM_S3_TV1_ACTIVE |\r\n(radeon_crtc->crtc_id << 18)));\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nWREG32(reg, (ATOM_S3_CV_ACTIVE | (radeon_crtc->crtc_id << 24)));\r\nelse\r\nWREG32(reg, 0);\r\nif (enable)\r\nargs.ucEnable = ATOM_ENABLE;\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nWREG32(reg, temp);\r\n}\r\nstatic void\r\nradeon_atom_encoder_dpms_avivo(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION args;\r\nint index = 0;\r\nmemset(&args, 0, sizeof(args));\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nindex = GetIndexIntoMasterTable(COMMAND, TMDSAOutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nindex = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\nindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\r\nelse\r\nindex = GetIndexIntoMasterTable(COMMAND, LVTMAOutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, TV1OutputControl);\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, CV1OutputControl);\r\nelse\r\nindex = GetIndexIntoMasterTable(COMMAND, DAC1OutputControl);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, TV1OutputControl);\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nindex = GetIndexIntoMasterTable(COMMAND, CV1OutputControl);\r\nelse\r\nindex = GetIndexIntoMasterTable(COMMAND, DAC2OutputControl);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nargs.ucAction = ATOM_ENABLE;\r\nif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DDI) {\r\nu32 reg = RREG32(RADEON_BIOS_3_SCRATCH);\r\nWREG32(RADEON_BIOS_3_SCRATCH, reg & ~ATOM_S3_DFP2I_ACTIVE);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nWREG32(RADEON_BIOS_3_SCRATCH, reg);\r\n} else\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nargs.ucAction = ATOM_LCD_BLON;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nargs.ucAction = ATOM_DISABLE;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nargs.ucAction = ATOM_LCD_BLOFF;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nradeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nstruct radeon_connector *radeon_connector = NULL;\r\nstruct radeon_connector_atom_dig *radeon_dig_connector = NULL;\r\nbool travis_quirk = false;\r\nif (connector) {\r\nradeon_connector = to_radeon_connector(connector);\r\nradeon_dig_connector = radeon_connector->con_priv;\r\nif ((radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==\r\nENCODER_OBJECT_ID_TRAVIS) &&\r\n(radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\r\n!ASIC_IS_DCE5(rdev))\r\ntravis_quirk = true;\r\n}\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE5(rdev)) {\r\nif (!connector)\r\ndig->panel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\r\nelse\r\ndig->panel_mode = radeon_dp_get_panel_mode(encoder, connector);\r\natombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_SETUP, 0);\r\natombios_dig_encoder_setup(encoder,\r\nATOM_ENCODER_CMD_SETUP_PANEL_MODE,\r\ndig->panel_mode);\r\nif (ext_encoder) {\r\nif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev))\r\natombios_external_encoder_setup(encoder, ext_encoder,\r\nEXTERNAL_ENCODER_ACTION_V3_ENCODER_SETUP);\r\n}\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\natombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_SETUP, 0);\r\n} else {\r\natombios_dig_encoder_setup(encoder, ATOM_ENABLE, 0);\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0);\r\n}\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\nradeon_dig_connector->edp_on = true;\r\n}\r\n}\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0);\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\r\nradeon_dp_link_train(encoder, connector);\r\nif (ASIC_IS_DCE4(rdev))\r\natombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON, 0);\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\natombios_dig_transmitter_setup(encoder,\r\nATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);\r\nif (ext_encoder)\r\natombios_external_encoder_setup(encoder, ext_encoder, ATOM_ENABLE);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nif (ASIC_IS_DCE4(rdev)) {\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector)\r\natombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_OFF, 0);\r\n}\r\nif (ext_encoder)\r\natombios_external_encoder_setup(encoder, ext_encoder, ATOM_DISABLE);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\natombios_dig_transmitter_setup(encoder,\r\nATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) &&\r\nconnector && !travis_quirk)\r\nradeon_dp_set_rx_power_state(connector, DP_SET_POWER_D3);\r\nif (ASIC_IS_DCE4(rdev)) {\r\natombios_dig_transmitter_setup(encoder,\r\nATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);\r\n} else {\r\natombios_dig_transmitter_setup(encoder,\r\nATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);\r\natombios_dig_encoder_setup(encoder, ATOM_DISABLE, 0);\r\n}\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\r\nif (travis_quirk)\r\nradeon_dp_set_rx_power_state(connector, DP_SET_POWER_D3);\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_OFF);\r\nradeon_dig_connector->edp_on = false;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nradeon_atom_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nDRM_DEBUG_KMS("encoder dpms %d to mode %d, devices %08x, active_devices %08x\n",\r\nradeon_encoder->encoder_id, mode, radeon_encoder->devices,\r\nradeon_encoder->active_device);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\nradeon_atom_encoder_dpms_avivo(encoder, mode);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nradeon_atom_encoder_dpms_dig(encoder, mode);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nif (ASIC_IS_DCE5(rdev)) {\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\natombios_dvo_setup(encoder, ATOM_ENABLE);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\natombios_dvo_setup(encoder, ATOM_DISABLE);\r\nbreak;\r\n}\r\n} else if (ASIC_IS_DCE3(rdev))\r\nradeon_atom_encoder_dpms_dig(encoder, mode);\r\nelse\r\nradeon_atom_encoder_dpms_avivo(encoder, mode);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\nif (ASIC_IS_DCE5(rdev)) {\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\natombios_dac_setup(encoder, ATOM_ENABLE);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\natombios_dac_setup(encoder, ATOM_DISABLE);\r\nbreak;\r\n}\r\n} else\r\nradeon_atom_encoder_dpms_avivo(encoder, mode);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nradeon_atombios_encoder_dpms_scratch_regs(encoder, (mode == DRM_MODE_DPMS_ON) ? true : false);\r\n}\r\nstatic void\r\natombios_set_encoder_crtc_source(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nunion crtc_source_param args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SelectCRTC_Source);\r\nuint8_t frev, crev;\r\nstruct radeon_encoder_atom_dig *dig;\r\nmemset(&args, 0, sizeof(args));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\ndefault:\r\nif (ASIC_IS_AVIVO(rdev))\r\nargs.v1.ucCRTC = radeon_crtc->crtc_id;\r\nelse {\r\nif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1) {\r\nargs.v1.ucCRTC = radeon_crtc->crtc_id;\r\n} else {\r\nargs.v1.ucCRTC = radeon_crtc->crtc_id << 2;\r\n}\r\n}\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nargs.v1.ucDevice = ATOM_DEVICE_DFP1_INDEX;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT)\r\nargs.v1.ucDevice = ATOM_DEVICE_LCD1_INDEX;\r\nelse\r\nargs.v1.ucDevice = ATOM_DEVICE_DFP3_INDEX;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nargs.v1.ucDevice = ATOM_DEVICE_DFP2_INDEX;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nargs.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.v1.ucDevice = ATOM_DEVICE_CV_INDEX;\r\nelse\r\nargs.v1.ucDevice = ATOM_DEVICE_CRT1_INDEX;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nargs.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.v1.ucDevice = ATOM_DEVICE_CV_INDEX;\r\nelse\r\nargs.v1.ucDevice = ATOM_DEVICE_CRT2_INDEX;\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nargs.v2.ucCRTC = radeon_crtc->crtc_id;\r\nif (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE) {\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\r\nargs.v2.ucEncodeMode = ATOM_ENCODER_MODE_LVDS;\r\nelse if (connector->connector_type == DRM_MODE_CONNECTOR_VGA)\r\nargs.v2.ucEncodeMode = ATOM_ENCODER_MODE_CRT;\r\nelse\r\nargs.v2.ucEncodeMode = atombios_get_encoder_mode(encoder);\r\n} else if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nargs.v2.ucEncodeMode = ATOM_ENCODER_MODE_LVDS;\r\n} else {\r\nargs.v2.ucEncodeMode = atombios_get_encoder_mode(encoder);\r\n}\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\ndig = radeon_encoder->enc_priv;\r\nswitch (dig->dig_encoder) {\r\ncase 0:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG1_ENCODER_ID;\r\nbreak;\r\ncase 1:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG2_ENCODER_ID;\r\nbreak;\r\ncase 2:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG3_ENCODER_ID;\r\nbreak;\r\ncase 3:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG4_ENCODER_ID;\r\nbreak;\r\ncase 4:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG5_ENCODER_ID;\r\nbreak;\r\ncase 5:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG6_ENCODER_ID;\r\nbreak;\r\ncase 6:\r\nargs.v2.ucEncoderID = ASIC_INT_DIG7_ENCODER_ID;\r\nbreak;\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nargs.v2.ucEncoderID = ASIC_INT_DVO_ENCODER_ID;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nargs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\r\nelse\r\nargs.v2.ucEncoderID = ASIC_INT_DAC1_ENCODER_ID;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nargs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\r\nelse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\r\nargs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\r\nelse\r\nargs.v2.ucEncoderID = ASIC_INT_DAC2_ENCODER_ID;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version: %d, %d\n", frev, crev);\r\nreturn;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nradeon_atombios_encoder_crtc_scratch_regs(encoder, radeon_crtc->crtc_id);\r\n}\r\nstatic void\r\natombios_apply_encoder_quirks(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nif ((dev->pdev->device == 0x71C5) &&\r\n(dev->pdev->subsystem_vendor == 0x106b) &&\r\n(dev->pdev->subsystem_device == 0x0080)) {\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\r\nuint32_t lvtma_bit_depth_control = RREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL);\r\nlvtma_bit_depth_control &= ~AVIVO_LVTMA_BIT_DEPTH_CONTROL_TRUNCATE_EN;\r\nlvtma_bit_depth_control &= ~AVIVO_LVTMA_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN;\r\nWREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL, lvtma_bit_depth_control);\r\n}\r\n}\r\nif (ASIC_IS_AVIVO(rdev) &&\r\n(!(radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT)))) {\r\nif (ASIC_IS_DCE8(rdev)) {\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nWREG32(CIK_LB_DATA_FORMAT + radeon_crtc->crtc_offset,\r\nCIK_INTERLEAVE_EN);\r\nelse\r\nWREG32(CIK_LB_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nWREG32(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset,\r\nEVERGREEN_INTERLEAVE_EN);\r\nelse\r\nWREG32(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\r\n} else {\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nWREG32(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,\r\nAVIVO_D1MODE_INTERLEAVE_EN);\r\nelse\r\nWREG32(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\r\n}\r\n}\r\n}\r\nstatic int radeon_atom_pick_dig_encoder(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_encoder *test_encoder;\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t dig_enc_in_use = 0;\r\nif (ASIC_IS_DCE6(rdev)) {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nif (dig->linkb)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nif (dig->linkb)\r\nreturn 3;\r\nelse\r\nreturn 2;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nif (dig->linkb)\r\nreturn 5;\r\nelse\r\nreturn 4;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\nreturn 6;\r\nbreak;\r\n}\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\nif (ASIC_IS_DCE41(rdev) && !ASIC_IS_DCE61(rdev)) {\r\nif (rdev->family == CHIP_PALM) {\r\nif (dig->linkb)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n} else\r\nreturn radeon_crtc->crtc_id;\r\n} else {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\nif (dig->linkb)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\nif (dig->linkb)\r\nreturn 3;\r\nelse\r\nreturn 2;\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nif (dig->linkb)\r\nreturn 5;\r\nelse\r\nreturn 4;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ASIC_IS_DCE32(rdev)) {\r\nreturn radeon_crtc->crtc_id;\r\n}\r\nlist_for_each_entry(test_encoder, &dev->mode_config.encoder_list, head) {\r\nstruct radeon_encoder *radeon_test_encoder;\r\nif (encoder == test_encoder)\r\ncontinue;\r\nif (!radeon_encoder_is_digital(test_encoder))\r\ncontinue;\r\nradeon_test_encoder = to_radeon_encoder(test_encoder);\r\ndig = radeon_test_encoder->enc_priv;\r\nif (dig->dig_encoder >= 0)\r\ndig_enc_in_use |= (1 << dig->dig_encoder);\r\n}\r\nif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA) {\r\nif (dig_enc_in_use & 0x2)\r\nDRM_ERROR("LVDS required digital encoder 2 but it was in use - stealing\n");\r\nreturn 1;\r\n}\r\nif (!(dig_enc_in_use & 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid\r\nradeon_atom_encoder_init(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\natombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_INIT, 0, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ext_encoder && (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev)))\r\natombios_external_encoder_setup(encoder, ext_encoder,\r\nEXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT);\r\n}\r\n}\r\nstatic void\r\nradeon_atom_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nradeon_encoder->pixel_clock = adjusted_mode->clock;\r\nradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\nif (ASIC_IS_AVIVO(rdev) && !ASIC_IS_DCE4(rdev)) {\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT))\r\natombios_yuv_setup(encoder, true);\r\nelse\r\natombios_yuv_setup(encoder, false);\r\n}\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\natombios_digital_setup(encoder, PANEL_ENCODER_ACTION_ENABLE);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\natombios_dvo_setup(encoder, ATOM_ENABLE);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\natombios_dac_setup(encoder, ATOM_ENABLE);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\r\natombios_tv_setup(encoder, ATOM_ENABLE);\r\nelse\r\natombios_tv_setup(encoder, ATOM_DISABLE);\r\n}\r\nbreak;\r\n}\r\natombios_apply_encoder_quirks(encoder, adjusted_mode);\r\nif (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI) {\r\nif (rdev->asic->display.hdmi_enable)\r\nradeon_hdmi_enable(rdev, encoder, true);\r\nif (rdev->asic->display.hdmi_setmode)\r\nradeon_hdmi_setmode(rdev, encoder, adjusted_mode);\r\n}\r\n}\r\nstatic bool\r\natombios_dac_load_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT |\r\nATOM_DEVICE_CV_SUPPORT |\r\nATOM_DEVICE_CRT_SUPPORT)) {\r\nDAC_LOAD_DETECTION_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DAC_LoadDetection);\r\nuint8_t frev, crev;\r\nmemset(&args, 0, sizeof(args));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn false;\r\nargs.sDacload.ucMisc = 0;\r\nif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1) ||\r\n(radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1))\r\nargs.sDacload.ucDacType = ATOM_DAC_A;\r\nelse\r\nargs.sDacload.ucDacType = ATOM_DAC_B;\r\nif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT)\r\nargs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT1_SUPPORT);\r\nelse if (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT)\r\nargs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT2_SUPPORT);\r\nelse if (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\r\nargs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CV_SUPPORT);\r\nif (crev >= 3)\r\nargs.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;\r\n} else if (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nargs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_TV1_SUPPORT);\r\nif (crev >= 3)\r\nargs.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_atom_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nuint32_t bios_0_scratch;\r\nif (!atombios_dac_load_detect(encoder, connector)) {\r\nDRM_DEBUG_KMS("detect returned false \n");\r\nreturn connector_status_unknown;\r\n}\r\nif (rdev->family >= CHIP_R600)\r\nbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\r\nelse\r\nbios_0_scratch = RREG32(RADEON_BIOS_0_SCRATCH);\r\nDRM_DEBUG_KMS("Bios 0 scratch %x %08x\n", bios_0_scratch, radeon_encoder->devices);\r\nif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT) {\r\nif (bios_0_scratch & ATOM_S0_CRT1_MASK)\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT) {\r\nif (bios_0_scratch & ATOM_S0_CRT2_MASK)\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\r\nif (bios_0_scratch & (ATOM_S0_CV_MASK|ATOM_S0_CV_MASK_A))\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nif (bios_0_scratch & (ATOM_S0_TV1_COMPOSITE | ATOM_S0_TV1_COMPOSITE_A))\r\nreturn connector_status_connected;\r\nelse if (bios_0_scratch & (ATOM_S0_TV1_SVIDEO | ATOM_S0_TV1_SVIDEO_A))\r\nreturn connector_status_connected;\r\n}\r\nreturn connector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_atom_dig_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\r\nu32 bios_0_scratch;\r\nif (!ASIC_IS_DCE4(rdev))\r\nreturn connector_status_unknown;\r\nif (!ext_encoder)\r\nreturn connector_status_unknown;\r\nif ((radeon_connector->devices & ATOM_DEVICE_CRT_SUPPORT) == 0)\r\nreturn connector_status_unknown;\r\natombios_external_encoder_setup(encoder, ext_encoder,\r\nEXTERNAL_ENCODER_ACTION_V3_DACLOAD_DETECTION);\r\nbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\r\nDRM_DEBUG_KMS("Bios 0 scratch %x %08x\n", bios_0_scratch, radeon_encoder->devices);\r\nif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT) {\r\nif (bios_0_scratch & ATOM_S0_CRT1_MASK)\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT) {\r\nif (bios_0_scratch & ATOM_S0_CRT2_MASK)\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\r\nif (bios_0_scratch & (ATOM_S0_CV_MASK|ATOM_S0_CV_MASK_A))\r\nreturn connector_status_connected;\r\n}\r\nif (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nif (bios_0_scratch & (ATOM_S0_TV1_COMPOSITE | ATOM_S0_TV1_COMPOSITE_A))\r\nreturn connector_status_connected;\r\nelse if (bios_0_scratch & (ATOM_S0_TV1_SVIDEO | ATOM_S0_TV1_SVIDEO_A))\r\nreturn connector_status_connected;\r\n}\r\nreturn connector_status_disconnected;\r\n}\r\nvoid\r\nradeon_atom_ext_encoder_setup_ddc(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\r\nif (ext_encoder)\r\natombios_external_encoder_setup(encoder, ext_encoder,\r\nEXTERNAL_ENCODER_ACTION_V3_DDC_SETUP);\r\n}\r\nstatic void radeon_atom_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nif ((radeon_encoder->active_device &\r\n(ATOM_DEVICE_DFP_SUPPORT | ATOM_DEVICE_LCD_SUPPORT)) ||\r\n(radeon_encoder_get_dp_bridge_encoder_id(encoder) !=\r\nENCODER_OBJECT_ID_NONE)) {\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (dig) {\r\ndig->dig_encoder = radeon_atom_pick_dig_encoder(encoder);\r\nif (radeon_encoder->active_device & ATOM_DEVICE_DFP_SUPPORT) {\r\nif (rdev->family >= CHIP_R600)\r\ndig->afmt = rdev->mode_info.afmt[dig->dig_encoder];\r\nelse\r\ndig->afmt = rdev->mode_info.afmt[0];\r\n}\r\n}\r\n}\r\nradeon_atom_output_lock(encoder, true);\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->router.cd_valid)\r\nradeon_router_select_cd_port(radeon_connector);\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_eDP)\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\n}\r\natombios_set_encoder_crtc_source(encoder);\r\nif (ASIC_IS_DCE8(rdev))\r\ndce8_program_fmt(encoder);\r\nelse if (ASIC_IS_DCE4(rdev))\r\ndce4_program_fmt(encoder);\r\nelse if (ASIC_IS_DCE3(rdev))\r\ndce3_program_fmt(encoder);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\navivo_program_fmt(encoder);\r\n}\r\nstatic void radeon_atom_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\nradeon_atom_output_lock(encoder, false);\r\n}\r\nstatic void radeon_atom_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig;\r\nif (!ASIC_IS_DCE3(rdev)) {\r\nstruct drm_encoder *other_encoder;\r\nstruct radeon_encoder *other_radeon_encoder;\r\nlist_for_each_entry(other_encoder, &dev->mode_config.encoder_list, head) {\r\nother_radeon_encoder = to_radeon_encoder(other_encoder);\r\nif ((radeon_encoder->encoder_id == other_radeon_encoder->encoder_id) &&\r\ndrm_helper_encoder_in_use(other_encoder))\r\ngoto disable_done;\r\n}\r\n}\r\nradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\natombios_digital_setup(encoder, PANEL_ENCODER_ACTION_DISABLE);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\natombios_dvo_setup(encoder, ATOM_DISABLE);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\natombios_dac_setup(encoder, ATOM_DISABLE);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\r\natombios_tv_setup(encoder, ATOM_DISABLE);\r\nbreak;\r\n}\r\ndisable_done:\r\nif (radeon_encoder_is_digital(encoder)) {\r\nif (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI) {\r\nif (rdev->asic->display.hdmi_enable)\r\nradeon_hdmi_enable(rdev, encoder, false);\r\n}\r\ndig = radeon_encoder->enc_priv;\r\ndig->dig_encoder = -1;\r\n}\r\nradeon_encoder->active_device = 0;\r\n}\r\nstatic void radeon_atom_ext_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void radeon_atom_ext_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nradeon_atom_ext_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void radeon_atom_ext_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nradeon_atom_ext_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool radeon_atom_ext_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nvoid radeon_enc_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\nradeon_atom_backlight_exit(radeon_encoder);\r\nkfree(radeon_encoder->enc_priv);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(radeon_encoder);\r\n}\r\nstatic struct radeon_encoder_atom_dac *\r\nradeon_atombios_set_dac_info(struct radeon_encoder *radeon_encoder)\r\n{\r\nstruct drm_device *dev = radeon_encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder_atom_dac *dac = kzalloc(sizeof(struct radeon_encoder_atom_dac), GFP_KERNEL);\r\nif (!dac)\r\nreturn NULL;\r\ndac->tv_std = radeon_atombios_get_tv_info(rdev);\r\nreturn dac;\r\n}\r\nstatic struct radeon_encoder_atom_dig *\r\nradeon_atombios_set_dig_info(struct radeon_encoder *radeon_encoder)\r\n{\r\nint encoder_enum = (radeon_encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\r\nstruct radeon_encoder_atom_dig *dig = kzalloc(sizeof(struct radeon_encoder_atom_dig), GFP_KERNEL);\r\nif (!dig)\r\nreturn NULL;\r\ndig->coherent_mode = true;\r\ndig->dig_encoder = -1;\r\nif (encoder_enum == 2)\r\ndig->linkb = true;\r\nelse\r\ndig->linkb = false;\r\nreturn dig;\r\n}\r\nvoid\r\nradeon_add_atom_encoder(struct drm_device *dev,\r\nuint32_t encoder_enum,\r\nuint32_t supported_device,\r\nu16 caps)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->encoder_enum == encoder_enum) {\r\nradeon_encoder->devices |= supported_device;\r\nreturn;\r\n}\r\n}\r\nradeon_encoder = kzalloc(sizeof(struct radeon_encoder), GFP_KERNEL);\r\nif (!radeon_encoder)\r\nreturn;\r\nencoder = &radeon_encoder->base;\r\nswitch (rdev->num_crtc) {\r\ncase 1:\r\nencoder->possible_crtcs = 0x1;\r\nbreak;\r\ncase 2:\r\ndefault:\r\nencoder->possible_crtcs = 0x3;\r\nbreak;\r\ncase 4:\r\nencoder->possible_crtcs = 0xf;\r\nbreak;\r\ncase 6:\r\nencoder->possible_crtcs = 0x3f;\r\nbreak;\r\n}\r\nradeon_encoder->enc_priv = NULL;\r\nradeon_encoder->encoder_enum = encoder_enum;\r\nradeon_encoder->encoder_id = (encoder_enum & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\r\nradeon_encoder->devices = supported_device;\r\nradeon_encoder->rmx_type = RMX_OFF;\r\nradeon_encoder->underscan_type = UNDERSCAN_OFF;\r\nradeon_encoder->is_ext_encoder = false;\r\nradeon_encoder->caps = caps;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nradeon_encoder->rmx_type = RMX_FULL;\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);\r\nradeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);\r\n} else {\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);\r\nradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\r\n}\r\ndrm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC1:\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);\r\nradeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);\r\ndrm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DAC2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TVDAC);\r\nradeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);\r\ndrm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nradeon_encoder->rmx_type = RMX_FULL;\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);\r\nradeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);\r\n} else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);\r\nradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\r\n} else {\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);\r\nradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\r\n}\r\ndrm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_SI170B:\r\ncase ENCODER_OBJECT_ID_CH7303:\r\ncase ENCODER_OBJECT_ID_EXTERNAL_SDVOA:\r\ncase ENCODER_OBJECT_ID_EXTERNAL_SDVOB:\r\ncase ENCODER_OBJECT_ID_TITFP513:\r\ncase ENCODER_OBJECT_ID_VT1623:\r\ncase ENCODER_OBJECT_ID_HDMI_SI1930:\r\ncase ENCODER_OBJECT_ID_TRAVIS:\r\ncase ENCODER_OBJECT_ID_NUTMEG:\r\nradeon_encoder->is_ext_encoder = true;\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);\r\nelse if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);\r\nelse\r\ndrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(encoder, &radeon_atom_ext_helper_funcs);\r\nbreak;\r\n}\r\n}
