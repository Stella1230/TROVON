static inline struct ipoctal *chan_to_ipoctal(struct ipoctal_channel *chan,\r\nunsigned int index)\r\n{\r\nreturn container_of(chan, struct ipoctal, channel[index]);\r\n}\r\nstatic void ipoctal_reset_channel(struct ipoctal_channel *channel)\r\n{\r\niowrite8(CR_DISABLE_RX | CR_DISABLE_TX, &channel->regs->w.cr);\r\nchannel->rx_enable = 0;\r\niowrite8(CR_CMD_RESET_RX, &channel->regs->w.cr);\r\niowrite8(CR_CMD_RESET_TX, &channel->regs->w.cr);\r\niowrite8(CR_CMD_RESET_ERR_STATUS, &channel->regs->w.cr);\r\niowrite8(CR_CMD_RESET_MR, &channel->regs->w.cr);\r\n}\r\nstatic int ipoctal_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct ipoctal_channel *channel;\r\nchannel = dev_get_drvdata(tty->dev);\r\niowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\r\nchannel->rx_enable = 1;\r\nreturn 0;\r\n}\r\nstatic int ipoctal_open(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct ipoctal_channel *channel = dev_get_drvdata(tty->dev);\r\nstruct ipoctal *ipoctal = chan_to_ipoctal(channel, tty->index);\r\nint err;\r\ntty->driver_data = channel;\r\nif (!ipack_get_carrier(ipoctal->dev))\r\nreturn -EBUSY;\r\nerr = tty_port_open(&channel->tty_port, tty, file);\r\nif (err)\r\nipack_put_carrier(ipoctal->dev);\r\nreturn err;\r\n}\r\nstatic void ipoctal_reset_stats(struct ipoctal_stats *stats)\r\n{\r\nstats->tx = 0;\r\nstats->rx = 0;\r\nstats->rcv_break = 0;\r\nstats->framing_err = 0;\r\nstats->overrun_err = 0;\r\nstats->parity_err = 0;\r\n}\r\nstatic void ipoctal_free_channel(struct ipoctal_channel *channel)\r\n{\r\nipoctal_reset_stats(&channel->stats);\r\nchannel->pointer_read = 0;\r\nchannel->pointer_write = 0;\r\nchannel->nb_bytes = 0;\r\n}\r\nstatic void ipoctal_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\ntty_port_close(&channel->tty_port, tty, filp);\r\nipoctal_free_channel(channel);\r\n}\r\nstatic int ipoctal_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nicount->cts = 0;\r\nicount->dsr = 0;\r\nicount->rng = 0;\r\nicount->dcd = 0;\r\nicount->rx = channel->stats.rx;\r\nicount->tx = channel->stats.tx;\r\nicount->frame = channel->stats.framing_err;\r\nicount->parity = channel->stats.parity_err;\r\nicount->brk = channel->stats.rcv_break;\r\nreturn 0;\r\n}\r\nstatic void ipoctal_irq_rx(struct ipoctal_channel *channel, u8 sr)\r\n{\r\nstruct tty_port *port = &channel->tty_port;\r\nunsigned char value;\r\nunsigned char flag;\r\nu8 isr;\r\ndo {\r\nvalue = ioread8(&channel->regs->r.rhr);\r\nflag = TTY_NORMAL;\r\nif (sr & SR_ERROR) {\r\niowrite8(CR_CMD_RESET_ERR_STATUS, &channel->regs->w.cr);\r\nif (sr & SR_OVERRUN_ERROR) {\r\nchannel->stats.overrun_err++;\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\n}\r\nif (sr & SR_PARITY_ERROR) {\r\nchannel->stats.parity_err++;\r\nflag = TTY_PARITY;\r\n}\r\nif (sr & SR_FRAMING_ERROR) {\r\nchannel->stats.framing_err++;\r\nflag = TTY_FRAME;\r\n}\r\nif (sr & SR_RECEIVED_BREAK) {\r\nchannel->stats.rcv_break++;\r\nflag = TTY_BREAK;\r\n}\r\n}\r\ntty_insert_flip_char(port, value, flag);\r\nisr = ioread8(&channel->block_regs->r.isr);\r\nsr = ioread8(&channel->regs->r.sr);\r\n} while (isr & channel->isr_rx_rdy_mask);\r\ntty_flip_buffer_push(port);\r\n}\r\nstatic void ipoctal_irq_tx(struct ipoctal_channel *channel)\r\n{\r\nunsigned char value;\r\nunsigned int *pointer_write = &channel->pointer_write;\r\nif (channel->nb_bytes == 0)\r\nreturn;\r\nspin_lock(&channel->lock);\r\nvalue = channel->tty_port.xmit_buf[*pointer_write];\r\niowrite8(value, &channel->regs->w.thr);\r\nchannel->stats.tx++;\r\n(*pointer_write)++;\r\n*pointer_write = *pointer_write % PAGE_SIZE;\r\nchannel->nb_bytes--;\r\nspin_unlock(&channel->lock);\r\n}\r\nstatic void ipoctal_irq_channel(struct ipoctal_channel *channel)\r\n{\r\nu8 isr, sr;\r\nisr = ioread8(&channel->block_regs->r.isr);\r\nsr = ioread8(&channel->regs->r.sr);\r\nif (isr & (IMR_DELTA_BREAK_A | IMR_DELTA_BREAK_B))\r\niowrite8(CR_CMD_RESET_BREAK_CHANGE, &channel->regs->w.cr);\r\nif ((sr & SR_TX_EMPTY) && (channel->nb_bytes == 0)) {\r\niowrite8(CR_DISABLE_TX, &channel->regs->w.cr);\r\nif (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {\r\niowrite8(CR_CMD_NEGATE_RTSN, &channel->regs->w.cr);\r\niowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\r\nchannel->rx_enable = 1;\r\n}\r\n}\r\nif ((isr & channel->isr_rx_rdy_mask) && (sr & SR_RX_READY))\r\nipoctal_irq_rx(channel, sr);\r\nif ((isr & channel->isr_tx_rdy_mask) && (sr & SR_TX_READY))\r\nipoctal_irq_tx(channel);\r\n}\r\nstatic irqreturn_t ipoctal_irq_handler(void *arg)\r\n{\r\nunsigned int i;\r\nstruct ipoctal *ipoctal = (struct ipoctal *) arg;\r\nreadw(ipoctal->int_space + ACK_INT_REQ0);\r\nreadw(ipoctal->int_space + ACK_INT_REQ1);\r\nfor (i = 0; i < NR_CHANNELS; i++)\r\nipoctal_irq_channel(&ipoctal->channel[i]);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ipoctal_inst_slot(struct ipoctal *ipoctal, unsigned int bus_nr,\r\nunsigned int slot)\r\n{\r\nint res;\r\nint i;\r\nstruct tty_driver *tty;\r\nchar name[20];\r\nstruct ipoctal_channel *channel;\r\nstruct ipack_region *region;\r\nvoid __iomem *addr;\r\nunion scc2698_channel __iomem *chan_regs;\r\nunion scc2698_block __iomem *block_regs;\r\nipoctal->board_id = ipoctal->dev->id_device;\r\nregion = &ipoctal->dev->region[IPACK_IO_SPACE];\r\naddr = devm_ioremap_nocache(&ipoctal->dev->dev,\r\nregion->start, region->size);\r\nif (!addr) {\r\ndev_err(&ipoctal->dev->dev,\r\n"Unable to map slot [%d:%d] IO space!\n",\r\nbus_nr, slot);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nchan_regs =\r\n(union scc2698_channel __iomem *) addr;\r\nblock_regs =\r\n(union scc2698_block __iomem *) addr;\r\nregion = &ipoctal->dev->region[IPACK_INT_SPACE];\r\nipoctal->int_space =\r\ndevm_ioremap_nocache(&ipoctal->dev->dev,\r\nregion->start, region->size);\r\nif (!ipoctal->int_space) {\r\ndev_err(&ipoctal->dev->dev,\r\n"Unable to map slot [%d:%d] INT space!\n",\r\nbus_nr, slot);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nregion = &ipoctal->dev->region[IPACK_MEM8_SPACE];\r\nipoctal->mem8_space =\r\ndevm_ioremap_nocache(&ipoctal->dev->dev,\r\nregion->start, 0x8000);\r\nif (!ipoctal->mem8_space) {\r\ndev_err(&ipoctal->dev->dev,\r\n"Unable to map slot [%d:%d] MEM8 space!\n",\r\nbus_nr, slot);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nfor (i = 0; i < NR_CHANNELS ; i++) {\r\nstruct ipoctal_channel *channel = &ipoctal->channel[i];\r\nchannel->regs = chan_regs + i;\r\nchannel->block_regs = block_regs + (i >> 1);\r\nchannel->board_id = ipoctal->board_id;\r\nif (i & 1) {\r\nchannel->isr_tx_rdy_mask = ISR_TxRDY_B;\r\nchannel->isr_rx_rdy_mask = ISR_RxRDY_FFULL_B;\r\n} else {\r\nchannel->isr_tx_rdy_mask = ISR_TxRDY_A;\r\nchannel->isr_rx_rdy_mask = ISR_RxRDY_FFULL_A;\r\n}\r\nipoctal_reset_channel(channel);\r\niowrite8(MR1_CHRL_8_BITS | MR1_ERROR_CHAR | MR1_RxINT_RxRDY,\r\n&channel->regs->w.mr);\r\niowrite8(0, &channel->regs->w.mr);\r\niowrite8(TX_CLK_9600 | RX_CLK_9600, &channel->regs->w.csr);\r\n}\r\nfor (i = 0; i < IP_OCTAL_NB_BLOCKS; i++) {\r\niowrite8(ACR_BRG_SET2, &block_regs[i].w.acr);\r\niowrite8(OPCR_MPP_OUTPUT | OPCR_MPOa_RTSN | OPCR_MPOb_RTSN,\r\n&block_regs[i].w.opcr);\r\niowrite8(IMR_TxRDY_A | IMR_RxRDY_FFULL_A | IMR_DELTA_BREAK_A |\r\nIMR_TxRDY_B | IMR_RxRDY_FFULL_B | IMR_DELTA_BREAK_B,\r\n&block_regs[i].w.imr);\r\n}\r\niowrite8(1, ipoctal->mem8_space + 1);\r\ntty = alloc_tty_driver(NR_CHANNELS);\r\nif (!tty)\r\nreturn -ENOMEM;\r\ntty->owner = THIS_MODULE;\r\ntty->driver_name = KBUILD_MODNAME;\r\nsprintf(name, KBUILD_MODNAME ".%d.%d.", bus_nr, slot);\r\ntty->name = name;\r\ntty->major = 0;\r\ntty->minor_start = 0;\r\ntty->type = TTY_DRIVER_TYPE_SERIAL;\r\ntty->subtype = SERIAL_TYPE_NORMAL;\r\ntty->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty->init_termios = tty_std_termios;\r\ntty->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\ntty->init_termios.c_ispeed = 9600;\r\ntty->init_termios.c_ospeed = 9600;\r\ntty_set_operations(tty, &ipoctal_fops);\r\nres = tty_register_driver(tty);\r\nif (res) {\r\ndev_err(&ipoctal->dev->dev, "Can't register tty driver.\n");\r\nput_tty_driver(tty);\r\nreturn res;\r\n}\r\nipoctal->tty_drv = tty;\r\nfor (i = 0; i < NR_CHANNELS; i++) {\r\nstruct device *tty_dev;\r\nchannel = &ipoctal->channel[i];\r\ntty_port_init(&channel->tty_port);\r\ntty_port_alloc_xmit_buf(&channel->tty_port);\r\nchannel->tty_port.ops = &ipoctal_tty_port_ops;\r\nipoctal_reset_stats(&channel->stats);\r\nchannel->nb_bytes = 0;\r\nspin_lock_init(&channel->lock);\r\nchannel->pointer_read = 0;\r\nchannel->pointer_write = 0;\r\ntty_dev = tty_port_register_device(&channel->tty_port, tty, i, NULL);\r\nif (IS_ERR(tty_dev)) {\r\ndev_err(&ipoctal->dev->dev, "Failed to register tty device.\n");\r\ntty_port_destroy(&channel->tty_port);\r\ncontinue;\r\n}\r\ndev_set_drvdata(tty_dev, channel);\r\n}\r\nipoctal->dev->bus->ops->request_irq(ipoctal->dev,\r\nipoctal_irq_handler, ipoctal);\r\nreturn 0;\r\n}\r\nstatic inline int ipoctal_copy_write_buffer(struct ipoctal_channel *channel,\r\nconst unsigned char *buf,\r\nint count)\r\n{\r\nunsigned long flags;\r\nint i;\r\nunsigned int *pointer_read = &channel->pointer_read;\r\nfor (i = 0; i < count; i++) {\r\nif (i <= (PAGE_SIZE - channel->nb_bytes)) {\r\nspin_lock_irqsave(&channel->lock, flags);\r\nchannel->tty_port.xmit_buf[*pointer_read] = buf[i];\r\n*pointer_read = (*pointer_read + 1) % PAGE_SIZE;\r\nchannel->nb_bytes++;\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int ipoctal_write_tty(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nunsigned int char_copied;\r\nchar_copied = ipoctal_copy_write_buffer(channel, buf, count);\r\nif (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {\r\niowrite8(CR_DISABLE_RX, &channel->regs->w.cr);\r\nchannel->rx_enable = 0;\r\niowrite8(CR_CMD_ASSERT_RTSN, &channel->regs->w.cr);\r\n}\r\niowrite8(CR_ENABLE_TX, &channel->regs->w.cr);\r\nreturn char_copied;\r\n}\r\nstatic int ipoctal_write_room(struct tty_struct *tty)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nreturn PAGE_SIZE - channel->nb_bytes;\r\n}\r\nstatic int ipoctal_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nreturn channel->nb_bytes;\r\n}\r\nstatic void ipoctal_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nunsigned int cflag;\r\nunsigned char mr1 = 0;\r\nunsigned char mr2 = 0;\r\nunsigned char csr = 0;\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nspeed_t baud;\r\ncflag = tty->termios.c_cflag;\r\nipoctal_reset_channel(channel);\r\nswitch (cflag & CSIZE) {\r\ncase CS6:\r\nmr1 |= MR1_CHRL_6_BITS;\r\nbreak;\r\ncase CS7:\r\nmr1 |= MR1_CHRL_7_BITS;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmr1 |= MR1_CHRL_8_BITS;\r\ntty->termios.c_cflag = (cflag & ~CSIZE) | CS8;\r\nbreak;\r\n}\r\nif (cflag & PARENB)\r\nif (cflag & PARODD)\r\nmr1 |= MR1_PARITY_ON | MR1_PARITY_ODD;\r\nelse\r\nmr1 |= MR1_PARITY_ON | MR1_PARITY_EVEN;\r\nelse\r\nmr1 |= MR1_PARITY_OFF;\r\ntty->termios.c_cflag &= ~CMSPAR;\r\nif (cflag & CSTOPB)\r\nmr2 |= MR2_STOP_BITS_LENGTH_2;\r\nelse\r\nmr2 |= MR2_STOP_BITS_LENGTH_1;\r\nswitch (channel->board_id) {\r\ncase IPACK1_DEVICE_ID_SBS_OCTAL_232:\r\nif (cflag & CRTSCTS) {\r\nmr1 |= MR1_RxRTS_CONTROL_ON;\r\nmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_ON;\r\n} else {\r\nmr1 |= MR1_RxRTS_CONTROL_OFF;\r\nmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_OFF;\r\n}\r\nbreak;\r\ncase IPACK1_DEVICE_ID_SBS_OCTAL_422:\r\nmr1 |= MR1_RxRTS_CONTROL_OFF;\r\nmr2 |= MR2_TxRTS_CONTROL_OFF | MR2_CTS_ENABLE_TX_OFF;\r\nbreak;\r\ncase IPACK1_DEVICE_ID_SBS_OCTAL_485:\r\nmr1 |= MR1_RxRTS_CONTROL_OFF;\r\nmr2 |= MR2_TxRTS_CONTROL_ON | MR2_CTS_ENABLE_TX_OFF;\r\nbreak;\r\ndefault:\r\nreturn;\r\nbreak;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\ntty_termios_encode_baud_rate(&tty->termios, baud, baud);\r\nswitch (baud) {\r\ncase 75:\r\ncsr |= TX_CLK_75 | RX_CLK_75;\r\nbreak;\r\ncase 110:\r\ncsr |= TX_CLK_110 | RX_CLK_110;\r\nbreak;\r\ncase 150:\r\ncsr |= TX_CLK_150 | RX_CLK_150;\r\nbreak;\r\ncase 300:\r\ncsr |= TX_CLK_300 | RX_CLK_300;\r\nbreak;\r\ncase 600:\r\ncsr |= TX_CLK_600 | RX_CLK_600;\r\nbreak;\r\ncase 1200:\r\ncsr |= TX_CLK_1200 | RX_CLK_1200;\r\nbreak;\r\ncase 1800:\r\ncsr |= TX_CLK_1800 | RX_CLK_1800;\r\nbreak;\r\ncase 2000:\r\ncsr |= TX_CLK_2000 | RX_CLK_2000;\r\nbreak;\r\ncase 2400:\r\ncsr |= TX_CLK_2400 | RX_CLK_2400;\r\nbreak;\r\ncase 4800:\r\ncsr |= TX_CLK_4800 | RX_CLK_4800;\r\nbreak;\r\ncase 9600:\r\ncsr |= TX_CLK_9600 | RX_CLK_9600;\r\nbreak;\r\ncase 19200:\r\ncsr |= TX_CLK_19200 | RX_CLK_19200;\r\nbreak;\r\ncase 38400:\r\ndefault:\r\ncsr |= TX_CLK_38400 | RX_CLK_38400;\r\ntty_termios_encode_baud_rate(&tty->termios, 38400, 38400);\r\nbreak;\r\n}\r\nmr1 |= MR1_ERROR_CHAR;\r\nmr1 |= MR1_RxINT_RxRDY;\r\niowrite8(mr1, &channel->regs->w.mr);\r\niowrite8(mr2, &channel->regs->w.mr);\r\niowrite8(csr, &channel->regs->w.csr);\r\nif (channel->rx_enable)\r\niowrite8(CR_ENABLE_RX, &channel->regs->w.cr);\r\n}\r\nstatic void ipoctal_hangup(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nif (channel == NULL)\r\nreturn;\r\nspin_lock_irqsave(&channel->lock, flags);\r\nchannel->nb_bytes = 0;\r\nchannel->pointer_read = 0;\r\nchannel->pointer_write = 0;\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\ntty_port_hangup(&channel->tty_port);\r\nipoctal_reset_channel(channel);\r\nclear_bit(ASYNCB_INITIALIZED, &channel->tty_port.flags);\r\nwake_up_interruptible(&channel->tty_port.open_wait);\r\n}\r\nstatic void ipoctal_shutdown(struct tty_struct *tty)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nif (channel == NULL)\r\nreturn;\r\nipoctal_reset_channel(channel);\r\nclear_bit(ASYNCB_INITIALIZED, &channel->tty_port.flags);\r\n}\r\nstatic void ipoctal_cleanup(struct tty_struct *tty)\r\n{\r\nstruct ipoctal_channel *channel = tty->driver_data;\r\nstruct ipoctal *ipoctal = chan_to_ipoctal(channel, tty->index);\r\nipack_put_carrier(ipoctal->dev);\r\n}\r\nstatic int ipoctal_probe(struct ipack_device *dev)\r\n{\r\nint res;\r\nstruct ipoctal *ipoctal;\r\nipoctal = kzalloc(sizeof(struct ipoctal), GFP_KERNEL);\r\nif (ipoctal == NULL)\r\nreturn -ENOMEM;\r\nipoctal->dev = dev;\r\nres = ipoctal_inst_slot(ipoctal, dev->bus->bus_nr, dev->slot);\r\nif (res)\r\ngoto out_uninst;\r\ndev_set_drvdata(&dev->dev, ipoctal);\r\nreturn 0;\r\nout_uninst:\r\nkfree(ipoctal);\r\nreturn res;\r\n}\r\nstatic void __ipoctal_remove(struct ipoctal *ipoctal)\r\n{\r\nint i;\r\nipoctal->dev->bus->ops->free_irq(ipoctal->dev);\r\nfor (i = 0; i < NR_CHANNELS; i++) {\r\nstruct ipoctal_channel *channel = &ipoctal->channel[i];\r\ntty_unregister_device(ipoctal->tty_drv, i);\r\ntty_port_free_xmit_buf(&channel->tty_port);\r\ntty_port_destroy(&channel->tty_port);\r\n}\r\ntty_unregister_driver(ipoctal->tty_drv);\r\nput_tty_driver(ipoctal->tty_drv);\r\nkfree(ipoctal);\r\n}\r\nstatic void ipoctal_remove(struct ipack_device *idev)\r\n{\r\n__ipoctal_remove(dev_get_drvdata(&idev->dev));\r\n}\r\nstatic int __init ipoctal_init(void)\r\n{\r\nreturn ipack_driver_register(&driver, THIS_MODULE, KBUILD_MODNAME);\r\n}\r\nstatic void __exit ipoctal_exit(void)\r\n{\r\nipack_driver_unregister(&driver);\r\n}
