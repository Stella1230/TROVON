static inline void D_L1L2(struct isac *isac, int pr, void *arg)\r\n{\r\nstruct hisax_if *ifc = (struct hisax_if *) &isac->hisax_d_if;\r\nDBG(DBG_PR, "pr %#x", pr);\r\nifc->l1l2(ifc, pr, arg);\r\n}\r\nstatic void ph_command(struct isac *isac, unsigned int command)\r\n{\r\nDBG(DBG_L1M, "ph_command %#x", command);\r\nswitch (isac->type) {\r\ncase TYPE_ISAC:\r\nisac->write_isac(isac, ISAC_CIX0, (command << 2) | 3);\r\nbreak;\r\ncase TYPE_ISACSX:\r\nisac->write_isac(isac, ISACSX_CIX0, (command << 4) | (7 << 1));\r\nbreak;\r\n}\r\n}\r\nstatic void l1_di(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_RESET);\r\nph_command(isac, ISAC_CMD_DI);\r\n}\r\nstatic void l1_di_deact_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_RESET);\r\nD_L1L2(isac, PH_DEACTIVATE | INDICATION, NULL);\r\nph_command(isac, ISAC_CMD_DI);\r\n}\r\nstatic void l1_go_f3pdown(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F3_PDOWN);\r\n}\r\nstatic void l1_go_f3pend_deact_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F3_PEND_DEACT);\r\nD_L1L2(isac, PH_DEACTIVATE | INDICATION, NULL);\r\nph_command(isac, ISAC_CMD_DI);\r\n}\r\nstatic void l1_go_f3pend(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F3_PEND_DEACT);\r\nph_command(isac, ISAC_CMD_DI);\r\n}\r\nstatic void l1_go_f4(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F4);\r\n}\r\nstatic void l1_go_f5(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F5);\r\n}\r\nstatic void l1_go_f6(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F6);\r\n}\r\nstatic void l1_go_f6_deact_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F6);\r\nD_L1L2(isac, PH_DEACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void l1_go_f7_act_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmDelTimer(&isac->timer, 0);\r\nFsmChangeState(fi, ST_L1_F7);\r\nph_command(isac, ISAC_CMD_AR8);\r\nD_L1L2(isac, PH_ACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void l1_go_f8(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F8);\r\n}\r\nstatic void l1_go_f8_deact_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F8);\r\nD_L1L2(isac, PH_DEACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void l1_ar8(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nFsmRestartTimer(&isac->timer, TIMER3_VALUE, EV_TIMER3, NULL, 2);\r\nph_command(isac, ISAC_CMD_AR8);\r\n}\r\nstatic void l1_timer3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct isac *isac = fi->userdata;\r\nph_command(isac, ISAC_CMD_DI);\r\nD_L1L2(isac, PH_DEACTIVATE | INDICATION, NULL);\r\n}\r\nstatic void l1m_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[256];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nDBG(DBG_L1M, "%s", buf);\r\nva_end(args);\r\n}\r\nstatic void isac_version(struct isac *cs)\r\n{\r\nint val;\r\nval = cs->read_isac(cs, ISAC_RBCH);\r\nDBG(1, "ISAC version (%x): %s", val, ISACVer[(val >> 5) & 3]);\r\n}\r\nstatic void isac_empty_fifo(struct isac *isac, int count)\r\n{\r\nu_char *ptr;\r\nDBG(DBG_IRQ, "count %d", count);\r\nif ((isac->rcvidx + count) >= MAX_DFRAME_LEN_L1) {\r\nDBG(DBG_WARN, "overrun %d", isac->rcvidx + count);\r\nisac->write_isac(isac, ISAC_CMDR, ISAC_CMDR_RMC);\r\nisac->rcvidx = 0;\r\nreturn;\r\n}\r\nptr = isac->rcvbuf + isac->rcvidx;\r\nisac->rcvidx += count;\r\nisac->read_isac_fifo(isac, ptr, count);\r\nisac->write_isac(isac, ISAC_CMDR, ISAC_CMDR_RMC);\r\nDBG_PACKET(DBG_RFIFO, ptr, count);\r\n}\r\nstatic void isac_fill_fifo(struct isac *isac)\r\n{\r\nint count;\r\nunsigned char cmd;\r\nu_char *ptr;\r\nBUG_ON(!isac->tx_skb);\r\ncount = isac->tx_skb->len;\r\nBUG_ON(count <= 0);\r\nDBG(DBG_IRQ, "count %d", count);\r\nif (count > 0x20) {\r\ncount = 0x20;\r\ncmd = ISAC_CMDR_XTF;\r\n} else {\r\ncmd = ISAC_CMDR_XTF | ISAC_CMDR_XME;\r\n}\r\nptr = isac->tx_skb->data;\r\nskb_pull(isac->tx_skb, count);\r\nisac->tx_cnt += count;\r\nDBG_PACKET(DBG_XFIFO, ptr, count);\r\nisac->write_isac_fifo(isac, ptr, count);\r\nisac->write_isac(isac, ISAC_CMDR, cmd);\r\n}\r\nstatic void isac_retransmit(struct isac *isac)\r\n{\r\nif (!isac->tx_skb) {\r\nDBG(DBG_WARN, "no skb");\r\nreturn;\r\n}\r\nskb_push(isac->tx_skb, isac->tx_cnt);\r\nisac->tx_cnt = 0;\r\n}\r\nstatic inline void isac_cisq_interrupt(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISAC_CIR0);\r\nDBG(DBG_IRQ, "CIR0 %#x", val);\r\nif (val & ISAC_CIR0_CIC0) {\r\nDBG(DBG_IRQ, "CODR0 %#x", (val >> 2) & 0xf);\r\nFsmEvent(&isac->l1m, (val >> 2) & 0xf, NULL);\r\n}\r\nif (val & ISAC_CIR0_CIC1) {\r\nval = isac->read_isac(isac, ISAC_CIR1);\r\nDBG(DBG_WARN, "ISAC CIR1 %#x", val);\r\n}\r\n}\r\nstatic inline void isac_rme_interrupt(struct isac *isac)\r\n{\r\nunsigned char val;\r\nint count;\r\nstruct sk_buff *skb;\r\nval = isac->read_isac(isac, ISAC_RSTA);\r\nif ((val & (ISAC_RSTA_RDO | ISAC_RSTA_CRC | ISAC_RSTA_RAB))\r\n!= ISAC_RSTA_CRC) {\r\nDBG(DBG_WARN, "RSTA %#x, dropped", val);\r\nisac->write_isac(isac, ISAC_CMDR, ISAC_CMDR_RMC);\r\ngoto out;\r\n}\r\ncount = isac->read_isac(isac, ISAC_RBCL) & 0x1f;\r\nDBG(DBG_IRQ, "RBCL %#x", count);\r\nif (count == 0)\r\ncount = 0x20;\r\nisac_empty_fifo(isac, count);\r\ncount = isac->rcvidx;\r\nif (count < 1) {\r\nDBG(DBG_WARN, "count %d < 1", count);\r\ngoto out;\r\n}\r\nskb = alloc_skb(count, GFP_ATOMIC);\r\nif (!skb) {\r\nDBG(DBG_WARN, "no memory, dropping\n");\r\ngoto out;\r\n}\r\nmemcpy(skb_put(skb, count), isac->rcvbuf, count);\r\nDBG_SKB(DBG_RPACKET, skb);\r\nD_L1L2(isac, PH_DATA | INDICATION, skb);\r\nout:\r\nisac->rcvidx = 0;\r\n}\r\nstatic inline void isac_xpr_interrupt(struct isac *isac)\r\n{\r\nif (!isac->tx_skb)\r\nreturn;\r\nif (isac->tx_skb->len > 0) {\r\nisac_fill_fifo(isac);\r\nreturn;\r\n}\r\ndev_kfree_skb_irq(isac->tx_skb);\r\nisac->tx_cnt = 0;\r\nisac->tx_skb = NULL;\r\nD_L1L2(isac, PH_DATA | CONFIRM, NULL);\r\n}\r\nstatic inline void isac_exi_interrupt(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISAC_EXIR);\r\nDBG(2, "EXIR %#x", val);\r\nif (val & ISAC_EXIR_XMR) {\r\nDBG(DBG_WARN, "ISAC XMR");\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISAC_EXIR_XDU) {\r\nDBG(DBG_WARN, "ISAC XDU");\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISAC_EXIR_MOS) {\r\nDBG(DBG_WARN, "MOS");\r\nval = isac->read_isac(isac, ISAC_MOSR);\r\nDBG(2, "ISAC MOSR %#x", val);\r\n}\r\n}\r\nvoid isac_irq(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISAC_ISTA);\r\nDBG(DBG_IRQ, "ISTA %#x", val);\r\nif (val & ISAC_ISTA_EXI) {\r\nDBG(DBG_IRQ, "EXI");\r\nisac_exi_interrupt(isac);\r\n}\r\nif (val & ISAC_ISTA_XPR) {\r\nDBG(DBG_IRQ, "XPR");\r\nisac_xpr_interrupt(isac);\r\n}\r\nif (val & ISAC_ISTA_RME) {\r\nDBG(DBG_IRQ, "RME");\r\nisac_rme_interrupt(isac);\r\n}\r\nif (val & ISAC_ISTA_RPF) {\r\nDBG(DBG_IRQ, "RPF");\r\nisac_empty_fifo(isac, 0x20);\r\n}\r\nif (val & ISAC_ISTA_CISQ) {\r\nDBG(DBG_IRQ, "CISQ");\r\nisac_cisq_interrupt(isac);\r\n}\r\nif (val & ISAC_ISTA_RSC) {\r\nDBG(DBG_WARN, "RSC");\r\n}\r\nif (val & ISAC_ISTA_SIN) {\r\nDBG(DBG_WARN, "SIN");\r\n}\r\nisac->write_isac(isac, ISAC_MASK, 0xff);\r\nisac->write_isac(isac, ISAC_MASK, 0x00);\r\n}\r\nstatic inline void isacsx_cic_interrupt(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISACSX_CIR0);\r\nDBG(DBG_IRQ, "CIR0 %#x", val);\r\nif (val & ISACSX_CIR0_CIC0) {\r\nDBG(DBG_IRQ, "CODR0 %#x", val >> 4);\r\nFsmEvent(&isac->l1m, val >> 4, NULL);\r\n}\r\n}\r\nstatic inline void isacsx_rme_interrupt(struct isac *isac)\r\n{\r\nint count;\r\nstruct sk_buff *skb;\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISACSX_RSTAD);\r\nif ((val & (ISACSX_RSTAD_VFR |\r\nISACSX_RSTAD_RDO |\r\nISACSX_RSTAD_CRC |\r\nISACSX_RSTAD_RAB))\r\n!= (ISACSX_RSTAD_VFR | ISACSX_RSTAD_CRC)) {\r\nDBG(DBG_WARN, "RSTAD %#x, dropped", val);\r\nisac->write_isac(isac, ISACSX_CMDRD, ISACSX_CMDRD_RMC);\r\ngoto out;\r\n}\r\ncount = isac->read_isac(isac, ISACSX_RBCLD) & 0x1f;\r\nDBG(DBG_IRQ, "RBCLD %#x", count);\r\nif (count == 0)\r\ncount = 0x20;\r\nisac_empty_fifo(isac, count);\r\ncount = isac->rcvidx - 1;\r\nif (count < 1) {\r\nDBG(DBG_WARN, "count %d < 1", count);\r\ngoto out;\r\n}\r\nskb = dev_alloc_skb(count);\r\nif (!skb) {\r\nDBG(DBG_WARN, "no memory, dropping");\r\ngoto out;\r\n}\r\nmemcpy(skb_put(skb, count), isac->rcvbuf, count);\r\nDBG_SKB(DBG_RPACKET, skb);\r\nD_L1L2(isac, PH_DATA | INDICATION, skb);\r\nout:\r\nisac->rcvidx = 0;\r\n}\r\nstatic inline void isacsx_xpr_interrupt(struct isac *isac)\r\n{\r\nif (!isac->tx_skb)\r\nreturn;\r\nif (isac->tx_skb->len > 0) {\r\nisac_fill_fifo(isac);\r\nreturn;\r\n}\r\ndev_kfree_skb_irq(isac->tx_skb);\r\nisac->tx_skb = NULL;\r\nisac->tx_cnt = 0;\r\nD_L1L2(isac, PH_DATA | CONFIRM, NULL);\r\n}\r\nstatic inline void isacsx_icd_interrupt(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISACSX_ISTAD);\r\nDBG(DBG_IRQ, "ISTAD %#x", val);\r\nif (val & ISACSX_ISTAD_XDU) {\r\nDBG(DBG_WARN, "ISTAD XDU");\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISACSX_ISTAD_XMR) {\r\nDBG(DBG_WARN, "ISTAD XMR");\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISACSX_ISTAD_XPR) {\r\nDBG(DBG_IRQ, "ISTAD XPR");\r\nisacsx_xpr_interrupt(isac);\r\n}\r\nif (val & ISACSX_ISTAD_RFO) {\r\nDBG(DBG_WARN, "ISTAD RFO");\r\nisac->write_isac(isac, ISACSX_CMDRD, ISACSX_CMDRD_RMC);\r\n}\r\nif (val & ISACSX_ISTAD_RME) {\r\nDBG(DBG_IRQ, "ISTAD RME");\r\nisacsx_rme_interrupt(isac);\r\n}\r\nif (val & ISACSX_ISTAD_RPF) {\r\nDBG(DBG_IRQ, "ISTAD RPF");\r\nisac_empty_fifo(isac, 0x20);\r\n}\r\n}\r\nvoid isacsx_irq(struct isac *isac)\r\n{\r\nunsigned char val;\r\nval = isac->read_isac(isac, ISACSX_ISTA);\r\nDBG(DBG_IRQ, "ISTA %#x", val);\r\nif (val & ISACSX_ISTA_ICD)\r\nisacsx_icd_interrupt(isac);\r\nif (val & ISACSX_ISTA_CIC)\r\nisacsx_cic_interrupt(isac);\r\n}\r\nvoid isac_init(struct isac *isac)\r\n{\r\nisac->tx_skb = NULL;\r\nisac->l1m.fsm = &l1fsm;\r\nisac->l1m.state = ST_L1_RESET;\r\n#ifdef CONFIG_HISAX_DEBUG\r\nisac->l1m.debug = 1;\r\n#else\r\nisac->l1m.debug = 0;\r\n#endif\r\nisac->l1m.userdata = isac;\r\nisac->l1m.printdebug = l1m_debug;\r\nFsmInitTimer(&isac->l1m, &isac->timer);\r\n}\r\nvoid isac_setup(struct isac *isac)\r\n{\r\nint val, eval;\r\nisac->type = TYPE_ISAC;\r\nisac_version(isac);\r\nph_command(isac, ISAC_CMD_RES);\r\nisac->write_isac(isac, ISAC_MASK, 0xff);\r\nisac->mocr = 0xaa;\r\nif (test_bit(ISAC_IOM1, &isac->flags)) {\r\nisac->write_isac(isac, ISAC_ADF2, 0x0);\r\nisac->write_isac(isac, ISAC_SPCR, 0xa);\r\nisac->write_isac(isac, ISAC_ADF1, 0x2);\r\nisac->write_isac(isac, ISAC_STCR, 0x70);\r\nisac->write_isac(isac, ISAC_MODE, 0xc9);\r\n} else {\r\nif (!isac->adf2)\r\nisac->adf2 = 0x80;\r\nisac->write_isac(isac, ISAC_ADF2, isac->adf2);\r\nisac->write_isac(isac, ISAC_SQXR, 0x2f);\r\nisac->write_isac(isac, ISAC_SPCR, 0x00);\r\nisac->write_isac(isac, ISAC_STCR, 0x70);\r\nisac->write_isac(isac, ISAC_MODE, 0xc9);\r\nisac->write_isac(isac, ISAC_TIMR, 0x00);\r\nisac->write_isac(isac, ISAC_ADF1, 0x00);\r\n}\r\nval = isac->read_isac(isac, ISAC_STAR);\r\nDBG(2, "ISAC STAR %x", val);\r\nval = isac->read_isac(isac, ISAC_MODE);\r\nDBG(2, "ISAC MODE %x", val);\r\nval = isac->read_isac(isac, ISAC_ADF2);\r\nDBG(2, "ISAC ADF2 %x", val);\r\nval = isac->read_isac(isac, ISAC_ISTA);\r\nDBG(2, "ISAC ISTA %x", val);\r\nif (val & 0x01) {\r\neval = isac->read_isac(isac, ISAC_EXIR);\r\nDBG(2, "ISAC EXIR %x", eval);\r\n}\r\nval = isac->read_isac(isac, ISAC_CIR0);\r\nDBG(2, "ISAC CIR0 %x", val);\r\nFsmEvent(&isac->l1m, (val >> 2) & 0xf, NULL);\r\nisac->write_isac(isac, ISAC_MASK, 0x0);\r\nisac->write_isac(isac, ISAC_CMDR, ISAC_CMDR_XRES | ISAC_CMDR_RRES);\r\n}\r\nvoid isacsx_setup(struct isac *isac)\r\n{\r\nisac->type = TYPE_ISACSX;\r\nisac->write_isac(isac, ISACSX_TR_CONF0, 0x00);\r\nisac->write_isac(isac, ISACSX_TR_CONF2, 0x00);\r\nisac->write_isac(isac, ISACSX_MODED, 0xc9);\r\nisac->write_isac(isac, ISACSX_MASKD, 0x03);\r\nisac->write_isac(isac, ISACSX_MASK,\r\n~(ISACSX_ISTA_ICD | ISACSX_ISTA_CIC));\r\n}\r\nvoid isac_d_l2l1(struct hisax_if *hisax_d_if, int pr, void *arg)\r\n{\r\nstruct isac *isac = hisax_d_if->priv;\r\nstruct sk_buff *skb = arg;\r\nDBG(DBG_PR, "pr %#x", pr);\r\nswitch (pr) {\r\ncase PH_ACTIVATE | REQUEST:\r\nFsmEvent(&isac->l1m, EV_PH_ACTIVATE_REQ, NULL);\r\nbreak;\r\ncase PH_DEACTIVATE | REQUEST:\r\nFsmEvent(&isac->l1m, EV_PH_DEACTIVATE_REQ, NULL);\r\nbreak;\r\ncase PH_DATA | REQUEST:\r\nDBG(DBG_PR, "PH_DATA REQUEST len %d", skb->len);\r\nDBG_SKB(DBG_XPACKET, skb);\r\nif (isac->l1m.state != ST_L1_F7) {\r\nDBG(1, "L1 wrong state %d\n", isac->l1m.state);\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\nBUG_ON(isac->tx_skb);\r\nisac->tx_skb = skb;\r\nisac_fill_fifo(isac);\r\nbreak;\r\n}\r\n}\r\nstatic int __init hisax_isac_init(void)\r\n{\r\nprintk(KERN_INFO "hisax_isac: ISAC-S/ISAC-SX ISDN driver v0.1.0\n");\r\nl1fsm.state_count = L1_STATE_COUNT;\r\nl1fsm.event_count = L1_EVENT_COUNT;\r\nl1fsm.strState = strL1State;\r\nl1fsm.strEvent = strL1Event;\r\nreturn FsmNew(&l1fsm, L1FnList, ARRAY_SIZE(L1FnList));\r\n}\r\nstatic void __exit hisax_isac_exit(void)\r\n{\r\nFsmFree(&l1fsm);\r\n}
