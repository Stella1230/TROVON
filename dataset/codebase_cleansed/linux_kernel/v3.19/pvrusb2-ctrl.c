static int pvr2_ctrl_range_check(struct pvr2_ctrl *cptr,int val)\r\n{\r\nif (cptr->info->check_value) {\r\nif (!cptr->info->check_value(cptr,val)) return -ERANGE;\r\n} else if (cptr->info->type == pvr2_ctl_enum) {\r\nif (val < 0) return -ERANGE;\r\nif (val >= cptr->info->def.type_enum.count) return -ERANGE;\r\n} else {\r\nint lim;\r\nlim = cptr->info->def.type_int.min_value;\r\nif (cptr->info->get_min_value) {\r\ncptr->info->get_min_value(cptr,&lim);\r\n}\r\nif (val < lim) return -ERANGE;\r\nlim = cptr->info->def.type_int.max_value;\r\nif (cptr->info->get_max_value) {\r\ncptr->info->get_max_value(cptr,&lim);\r\n}\r\nif (val > lim) return -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nint pvr2_ctrl_set_value(struct pvr2_ctrl *cptr,int val)\r\n{\r\nreturn pvr2_ctrl_set_mask_value(cptr,~0,val);\r\n}\r\nint pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr,int mask,int val)\r\n{\r\nint ret = 0;\r\nif (!cptr) return -EINVAL;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->set_value) {\r\nif (cptr->info->type == pvr2_ctl_bitmask) {\r\nmask &= cptr->info->def.type_bitmask.valid_bits;\r\n} else if ((cptr->info->type == pvr2_ctl_int)||\r\n(cptr->info->type == pvr2_ctl_enum)) {\r\nret = pvr2_ctrl_range_check(cptr,val);\r\nif (ret < 0) break;\r\n} else if (cptr->info->type != pvr2_ctl_bool) {\r\nbreak;\r\n}\r\nret = cptr->info->set_value(cptr,mask,val);\r\n} else {\r\nret = -EPERM;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_value(struct pvr2_ctrl *cptr,int *valptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return -EINVAL;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nret = cptr->info->get_value(cptr,valptr);\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nenum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return pvr2_ctl_int;\r\nreturn cptr->info->type;\r\n}\r\nint pvr2_ctrl_get_max(struct pvr2_ctrl *cptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return 0;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->get_max_value) {\r\ncptr->info->get_max_value(cptr,&ret);\r\n} else if (cptr->info->type == pvr2_ctl_int) {\r\nret = cptr->info->def.type_int.max_value;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_min(struct pvr2_ctrl *cptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return 0;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->get_min_value) {\r\ncptr->info->get_min_value(cptr,&ret);\r\n} else if (cptr->info->type == pvr2_ctl_int) {\r\nret = cptr->info->def.type_int.min_value;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_def(struct pvr2_ctrl *cptr, int *valptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return -EINVAL;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->get_def_value) {\r\nret = cptr->info->get_def_value(cptr, valptr);\r\n} else {\r\n*valptr = cptr->info->default_value;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return 0;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->type == pvr2_ctl_enum) {\r\nret = cptr->info->def.type_enum.count;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr)\r\n{\r\nint ret = 0;\r\nif (!cptr) return 0;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->type == pvr2_ctl_bitmask) {\r\nret = cptr->info->def.type_bitmask.valid_bits;\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nconst char *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return NULL;\r\nreturn cptr->info->name;\r\n}\r\nconst char *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return NULL;\r\nreturn cptr->info->desc;\r\n}\r\nint pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr,int val,\r\nchar *bptr,unsigned int bmax,\r\nunsigned int *blen)\r\n{\r\nint ret = -EINVAL;\r\nif (!cptr) return 0;\r\n*blen = 0;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->type == pvr2_ctl_enum) {\r\nconst char * const *names;\r\nnames = cptr->info->def.type_enum.value_names;\r\nif (pvr2_ctrl_range_check(cptr,val) == 0) {\r\nif (names[val]) {\r\n*blen = scnprintf(\r\nbptr,bmax,"%s",\r\nnames[val]);\r\n} else {\r\n*blen = 0;\r\n}\r\nret = 0;\r\n}\r\n} else if (cptr->info->type == pvr2_ctl_bitmask) {\r\nconst char **names;\r\nunsigned int idx;\r\nint msk;\r\nnames = cptr->info->def.type_bitmask.bit_names;\r\nval &= cptr->info->def.type_bitmask.valid_bits;\r\nfor (idx = 0, msk = 1; val; idx++, msk <<= 1) {\r\nif (val & msk) {\r\n*blen = scnprintf(bptr,bmax,"%s",\r\nnames[idx]);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return 0;\r\nreturn cptr->info->v4l_id;\r\n}\r\nunsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr)\r\n{\r\nunsigned int flags = 0;\r\nif (cptr->info->get_v4lflags) {\r\nflags = cptr->info->get_v4lflags(cptr);\r\n}\r\nif (cptr->info->set_value) {\r\nflags &= ~V4L2_CTRL_FLAG_READ_ONLY;\r\n} else {\r\nflags |= V4L2_CTRL_FLAG_READ_ONLY;\r\n}\r\nreturn flags;\r\n}\r\nint pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return 0;\r\nreturn cptr->info->set_value != NULL;\r\n}\r\nint pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr)\r\n{\r\nif (!cptr) return 0;\r\nif (!cptr->info->val_to_sym) return 0;\r\nif (!cptr->info->sym_to_val) return 0;\r\nreturn !0;\r\n}\r\nint pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr,\r\nint mask,int val,\r\nchar *buf,unsigned int maxlen,\r\nunsigned int *len)\r\n{\r\nif (!cptr) return -EINVAL;\r\nif (!cptr->info->val_to_sym) return -EINVAL;\r\nreturn cptr->info->val_to_sym(cptr,mask,val,buf,maxlen,len);\r\n}\r\nint pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr,\r\nconst char *buf,unsigned int len,\r\nint *maskptr,int *valptr)\r\n{\r\nif (!cptr) return -EINVAL;\r\nif (!cptr->info->sym_to_val) return -EINVAL;\r\nreturn cptr->info->sym_to_val(cptr,buf,len,maskptr,valptr);\r\n}\r\nstatic unsigned int gen_bitmask_string(int msk,int val,int msk_only,\r\nconst char **names,\r\nchar *ptr,unsigned int len)\r\n{\r\nunsigned int idx;\r\nlong sm,um;\r\nint spcFl;\r\nunsigned int uc,cnt;\r\nconst char *idStr;\r\nspcFl = 0;\r\nuc = 0;\r\num = 0;\r\nfor (idx = 0, sm = 1; msk; idx++, sm <<= 1) {\r\nif (sm & msk) {\r\nmsk &= ~sm;\r\nidStr = names[idx];\r\nif (idStr) {\r\ncnt = scnprintf(ptr,len,"%s%s%s",\r\n(spcFl ? " " : ""),\r\n(msk_only ? "" :\r\n((val & sm) ? "+" : "-")),\r\nidStr);\r\nptr += cnt; len -= cnt; uc += cnt;\r\nspcFl = !0;\r\n} else {\r\num |= sm;\r\n}\r\n}\r\n}\r\nif (um) {\r\nif (msk_only) {\r\ncnt = scnprintf(ptr,len,"%s0x%lx",\r\n(spcFl ? " " : ""),\r\num);\r\nptr += cnt; len -= cnt; uc += cnt;\r\nspcFl = !0;\r\n} else if (um & val) {\r\ncnt = scnprintf(ptr,len,"%s+0x%lx",\r\n(spcFl ? " " : ""),\r\num & val);\r\nptr += cnt; len -= cnt; uc += cnt;\r\nspcFl = !0;\r\n} else if (um & ~val) {\r\ncnt = scnprintf(ptr,len,"%s+0x%lx",\r\n(spcFl ? " " : ""),\r\num & ~val);\r\nptr += cnt; len -= cnt; uc += cnt;\r\nspcFl = !0;\r\n}\r\n}\r\nreturn uc;\r\n}\r\nstatic int parse_token(const char *ptr,unsigned int len,\r\nint *valptr,\r\nconst char * const *names, unsigned int namecnt)\r\n{\r\nchar buf[33];\r\nunsigned int slen;\r\nunsigned int idx;\r\nint negfl;\r\nchar *p2;\r\n*valptr = 0;\r\nif (!names) namecnt = 0;\r\nfor (idx = 0; idx < namecnt; idx++) {\r\nif (!names[idx]) continue;\r\nslen = strlen(names[idx]);\r\nif (slen != len) continue;\r\nif (memcmp(names[idx],ptr,slen)) continue;\r\n*valptr = idx;\r\nreturn 0;\r\n}\r\nnegfl = 0;\r\nif ((*ptr == '-') || (*ptr == '+')) {\r\nnegfl = (*ptr == '-');\r\nptr++; len--;\r\n}\r\nif (len >= sizeof(buf)) return -EINVAL;\r\nmemcpy(buf,ptr,len);\r\nbuf[len] = 0;\r\n*valptr = simple_strtol(buf,&p2,0);\r\nif (negfl) *valptr = -(*valptr);\r\nif (*p2) return -EINVAL;\r\nreturn 1;\r\n}\r\nstatic int parse_mtoken(const char *ptr,unsigned int len,\r\nint *valptr,\r\nconst char **names,int valid_bits)\r\n{\r\nchar buf[33];\r\nunsigned int slen;\r\nunsigned int idx;\r\nchar *p2;\r\nint msk;\r\n*valptr = 0;\r\nfor (idx = 0, msk = 1; valid_bits; idx++, msk <<= 1) {\r\nif (!(msk & valid_bits)) continue;\r\nvalid_bits &= ~msk;\r\nif (!names[idx]) continue;\r\nslen = strlen(names[idx]);\r\nif (slen != len) continue;\r\nif (memcmp(names[idx],ptr,slen)) continue;\r\n*valptr = msk;\r\nreturn 0;\r\n}\r\nif (len >= sizeof(buf)) return -EINVAL;\r\nmemcpy(buf,ptr,len);\r\nbuf[len] = 0;\r\n*valptr = simple_strtol(buf,&p2,0);\r\nif (*p2) return -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int parse_tlist(const char *ptr,unsigned int len,\r\nint *maskptr,int *valptr,\r\nconst char **names,int valid_bits)\r\n{\r\nunsigned int cnt;\r\nint mask,val,kv,mode,ret;\r\nmask = 0;\r\nval = 0;\r\nret = 0;\r\nwhile (len) {\r\ncnt = 0;\r\nwhile ((cnt < len) &&\r\n((ptr[cnt] <= 32) ||\r\n(ptr[cnt] >= 127))) cnt++;\r\nptr += cnt;\r\nlen -= cnt;\r\nmode = 0;\r\nif ((*ptr == '-') || (*ptr == '+')) {\r\nmode = (*ptr == '-') ? -1 : 1;\r\nptr++;\r\nlen--;\r\n}\r\ncnt = 0;\r\nwhile (cnt < len) {\r\nif (ptr[cnt] <= 32) break;\r\nif (ptr[cnt] >= 127) break;\r\ncnt++;\r\n}\r\nif (!cnt) break;\r\nif (parse_mtoken(ptr,cnt,&kv,names,valid_bits)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nptr += cnt;\r\nlen -= cnt;\r\nswitch (mode) {\r\ncase 0:\r\nmask = valid_bits;\r\nval |= kv;\r\nbreak;\r\ncase -1:\r\nmask |= kv;\r\nval &= ~kv;\r\nbreak;\r\ncase 1:\r\nmask |= kv;\r\nval |= kv;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n*maskptr = mask;\r\n*valptr = val;\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr,\r\nconst char *ptr,unsigned int len,\r\nint *maskptr,int *valptr)\r\n{\r\nint ret = -EINVAL;\r\nunsigned int cnt;\r\n*maskptr = 0;\r\n*valptr = 0;\r\ncnt = 0;\r\nwhile ((cnt < len) && ((ptr[cnt] <= 32) || (ptr[cnt] >= 127))) cnt++;\r\nlen -= cnt; ptr += cnt;\r\ncnt = 0;\r\nwhile ((cnt < len) && ((ptr[len-(cnt+1)] <= 32) ||\r\n(ptr[len-(cnt+1)] >= 127))) cnt++;\r\nlen -= cnt;\r\nif (!len) return -EINVAL;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nif (cptr->info->type == pvr2_ctl_int) {\r\nret = parse_token(ptr,len,valptr,NULL,0);\r\nif (ret >= 0) {\r\nret = pvr2_ctrl_range_check(cptr,*valptr);\r\n}\r\n*maskptr = ~0;\r\n} else if (cptr->info->type == pvr2_ctl_bool) {\r\nret = parse_token(ptr,len,valptr,boolNames,\r\nARRAY_SIZE(boolNames));\r\nif (ret == 1) {\r\n*valptr = *valptr ? !0 : 0;\r\n} else if (ret == 0) {\r\n*valptr = (*valptr & 1) ? !0 : 0;\r\n}\r\n*maskptr = 1;\r\n} else if (cptr->info->type == pvr2_ctl_enum) {\r\nret = parse_token(\r\nptr,len,valptr,\r\ncptr->info->def.type_enum.value_names,\r\ncptr->info->def.type_enum.count);\r\nif (ret >= 0) {\r\nret = pvr2_ctrl_range_check(cptr,*valptr);\r\n}\r\n*maskptr = ~0;\r\n} else if (cptr->info->type == pvr2_ctl_bitmask) {\r\nret = parse_tlist(\r\nptr,len,maskptr,valptr,\r\ncptr->info->def.type_bitmask.bit_names,\r\ncptr->info->def.type_bitmask.valid_bits);\r\n}\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr,\r\nint mask,int val,\r\nchar *buf,unsigned int maxlen,\r\nunsigned int *len)\r\n{\r\nint ret = -EINVAL;\r\n*len = 0;\r\nif (cptr->info->type == pvr2_ctl_int) {\r\n*len = scnprintf(buf,maxlen,"%d",val);\r\nret = 0;\r\n} else if (cptr->info->type == pvr2_ctl_bool) {\r\n*len = scnprintf(buf,maxlen,"%s",val ? "true" : "false");\r\nret = 0;\r\n} else if (cptr->info->type == pvr2_ctl_enum) {\r\nconst char * const *names;\r\nnames = cptr->info->def.type_enum.value_names;\r\nif ((val >= 0) &&\r\n(val < cptr->info->def.type_enum.count)) {\r\nif (names[val]) {\r\n*len = scnprintf(\r\nbuf,maxlen,"%s",\r\nnames[val]);\r\n} else {\r\n*len = 0;\r\n}\r\nret = 0;\r\n}\r\n} else if (cptr->info->type == pvr2_ctl_bitmask) {\r\n*len = gen_bitmask_string(\r\nval & mask & cptr->info->def.type_bitmask.valid_bits,\r\n~0,!0,\r\ncptr->info->def.type_bitmask.bit_names,\r\nbuf,maxlen);\r\n}\r\nreturn ret;\r\n}\r\nint pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr,\r\nint mask,int val,\r\nchar *buf,unsigned int maxlen,\r\nunsigned int *len)\r\n{\r\nint ret;\r\nLOCK_TAKE(cptr->hdw->big_lock); do {\r\nret = pvr2_ctrl_value_to_sym_internal(cptr,mask,val,\r\nbuf,maxlen,len);\r\n} while(0); LOCK_GIVE(cptr->hdw->big_lock);\r\nreturn ret;\r\n}
