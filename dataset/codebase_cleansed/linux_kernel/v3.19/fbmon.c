static void copy_string(unsigned char *c, unsigned char *s)\r\n{\r\nint i;\r\nc = c + 5;\r\nfor (i = 0; (i < 13 && *c != 0x0A); i++)\r\n*(s++) = *(c++);\r\n*s = 0;\r\nwhile (i-- && (*--s == 0x20)) *s = 0;\r\n}\r\nstatic int edid_is_serial_block(unsigned char *block)\r\n{\r\nif ((block[0] == 0x00) && (block[1] == 0x00) &&\r\n(block[2] == 0x00) && (block[3] == 0xff) &&\r\n(block[4] == 0x00))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int edid_is_ascii_block(unsigned char *block)\r\n{\r\nif ((block[0] == 0x00) && (block[1] == 0x00) &&\r\n(block[2] == 0x00) && (block[3] == 0xfe) &&\r\n(block[4] == 0x00))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int edid_is_limits_block(unsigned char *block)\r\n{\r\nif ((block[0] == 0x00) && (block[1] == 0x00) &&\r\n(block[2] == 0x00) && (block[3] == 0xfd) &&\r\n(block[4] == 0x00))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int edid_is_monitor_block(unsigned char *block)\r\n{\r\nif ((block[0] == 0x00) && (block[1] == 0x00) &&\r\n(block[2] == 0x00) && (block[3] == 0xfc) &&\r\n(block[4] == 0x00))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int edid_is_timing_block(unsigned char *block)\r\n{\r\nif ((block[0] != 0x00) || (block[1] != 0x00) ||\r\n(block[2] != 0x00) || (block[4] != 0x00))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int check_edid(unsigned char *edid)\r\n{\r\nunsigned char *block = edid + ID_MANUFACTURER_NAME, manufacturer[4];\r\nunsigned char *b;\r\nu32 model;\r\nint i, fix = 0, ret = 0;\r\nmanufacturer[0] = ((block[0] & 0x7c) >> 2) + '@';\r\nmanufacturer[1] = ((block[0] & 0x03) << 3) +\r\n((block[1] & 0xe0) >> 5) + '@';\r\nmanufacturer[2] = (block[1] & 0x1f) + '@';\r\nmanufacturer[3] = 0;\r\nmodel = block[2] + (block[3] << 8);\r\nfor (i = 0; i < ARRAY_SIZE(brokendb); i++) {\r\nif (!strncmp(manufacturer, brokendb[i].manufacturer, 4) &&\r\nbrokendb[i].model == model) {\r\nfix = brokendb[i].fix;\r\nbreak;\r\n}\r\n}\r\nswitch (fix) {\r\ncase FBMON_FIX_HEADER:\r\nfor (i = 0; i < 8; i++) {\r\nif (edid[i] != edid_v1_header[i]) {\r\nret = fix;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase FBMON_FIX_INPUT:\r\nb = edid + EDID_STRUCT_DISPLAY;\r\nif (b[4] & 0x01 && b[0] & 0x80)\r\nret = fix;\r\nbreak;\r\ncase FBMON_FIX_TIMINGS:\r\nb = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nret = fix;\r\nfor (i = 0; i < 4; i++) {\r\nif (edid_is_limits_block(b)) {\r\nret = 0;\r\nbreak;\r\n}\r\nb += DETAILED_TIMING_DESCRIPTION_SIZE;\r\n}\r\nbreak;\r\n}\r\nif (ret)\r\nprintk("fbmon: The EDID Block of "\r\n"Manufacturer: %s Model: 0x%x is known to "\r\n"be broken,\n", manufacturer, model);\r\nreturn ret;\r\n}\r\nstatic void fix_edid(unsigned char *edid, int fix)\r\n{\r\nint i;\r\nunsigned char *b, csum = 0;\r\nswitch (fix) {\r\ncase FBMON_FIX_HEADER:\r\nprintk("fbmon: trying a header reconstruct\n");\r\nmemcpy(edid, edid_v1_header, 8);\r\nbreak;\r\ncase FBMON_FIX_INPUT:\r\nprintk("fbmon: trying to fix input type\n");\r\nb = edid + EDID_STRUCT_DISPLAY;\r\nb[0] &= ~0x80;\r\nedid[127] += 0x80;\r\nbreak;\r\ncase FBMON_FIX_TIMINGS:\r\nprintk("fbmon: trying to fix monitor timings\n");\r\nb = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < 4; i++) {\r\nif (!(edid_is_serial_block(b) ||\r\nedid_is_ascii_block(b) ||\r\nedid_is_monitor_block(b) ||\r\nedid_is_timing_block(b))) {\r\nb[0] = 0x00;\r\nb[1] = 0x00;\r\nb[2] = 0x00;\r\nb[3] = 0xfd;\r\nb[4] = 0x00;\r\nb[5] = 60;\r\nb[6] = 60;\r\nb[7] = 30;\r\nb[8] = 75;\r\nb[9] = 17;\r\nb[10] = 0;\r\nbreak;\r\n}\r\nb += DETAILED_TIMING_DESCRIPTION_SIZE;\r\n}\r\nfor (i = 0; i < EDID_LENGTH - 1; i++)\r\ncsum += edid[i];\r\nedid[127] = 256 - csum;\r\nbreak;\r\n}\r\n}\r\nstatic int edid_checksum(unsigned char *edid)\r\n{\r\nunsigned char csum = 0, all_null = 0;\r\nint i, err = 0, fix = check_edid(edid);\r\nif (fix)\r\nfix_edid(edid, fix);\r\nfor (i = 0; i < EDID_LENGTH; i++) {\r\ncsum += edid[i];\r\nall_null |= edid[i];\r\n}\r\nif (csum == 0x00 && all_null) {\r\nerr = 1;\r\n}\r\nreturn err;\r\n}\r\nstatic int edid_check_header(unsigned char *edid)\r\n{\r\nint i, err = 1, fix = check_edid(edid);\r\nif (fix)\r\nfix_edid(edid, fix);\r\nfor (i = 0; i < 8; i++) {\r\nif (edid[i] != edid_v1_header[i])\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void parse_vendor_block(unsigned char *block, struct fb_monspecs *specs)\r\n{\r\nspecs->manufacturer[0] = ((block[0] & 0x7c) >> 2) + '@';\r\nspecs->manufacturer[1] = ((block[0] & 0x03) << 3) +\r\n((block[1] & 0xe0) >> 5) + '@';\r\nspecs->manufacturer[2] = (block[1] & 0x1f) + '@';\r\nspecs->manufacturer[3] = 0;\r\nspecs->model = block[2] + (block[3] << 8);\r\nspecs->serial = block[4] + (block[5] << 8) +\r\n(block[6] << 16) + (block[7] << 24);\r\nspecs->year = block[9] + 1990;\r\nspecs->week = block[8];\r\nDPRINTK(" Manufacturer: %s\n", specs->manufacturer);\r\nDPRINTK(" Model: %x\n", specs->model);\r\nDPRINTK(" Serial#: %u\n", specs->serial);\r\nDPRINTK(" Year: %u Week %u\n", specs->year, specs->week);\r\n}\r\nstatic void get_dpms_capabilities(unsigned char flags,\r\nstruct fb_monspecs *specs)\r\n{\r\nspecs->dpms = 0;\r\nif (flags & DPMS_ACTIVE_OFF)\r\nspecs->dpms |= FB_DPMS_ACTIVE_OFF;\r\nif (flags & DPMS_SUSPEND)\r\nspecs->dpms |= FB_DPMS_SUSPEND;\r\nif (flags & DPMS_STANDBY)\r\nspecs->dpms |= FB_DPMS_STANDBY;\r\nDPRINTK(" DPMS: Active %s, Suspend %s, Standby %s\n",\r\n(flags & DPMS_ACTIVE_OFF) ? "yes" : "no",\r\n(flags & DPMS_SUSPEND) ? "yes" : "no",\r\n(flags & DPMS_STANDBY) ? "yes" : "no");\r\n}\r\nstatic void get_chroma(unsigned char *block, struct fb_monspecs *specs)\r\n{\r\nint tmp;\r\nDPRINTK(" Chroma\n");\r\ntmp = ((block[5] & (3 << 6)) >> 6) | (block[0x7] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.redx = tmp/1024;\r\nDPRINTK(" RedX: 0.%03d ", specs->chroma.redx);\r\ntmp = ((block[5] & (3 << 4)) >> 4) | (block[0x8] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.redy = tmp/1024;\r\nDPRINTK("RedY: 0.%03d\n", specs->chroma.redy);\r\ntmp = ((block[5] & (3 << 2)) >> 2) | (block[0x9] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.greenx = tmp/1024;\r\nDPRINTK(" GreenX: 0.%03d ", specs->chroma.greenx);\r\ntmp = (block[5] & 3) | (block[0xa] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.greeny = tmp/1024;\r\nDPRINTK("GreenY: 0.%03d\n", specs->chroma.greeny);\r\ntmp = ((block[6] & (3 << 6)) >> 6) | (block[0xb] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.bluex = tmp/1024;\r\nDPRINTK(" BlueX: 0.%03d ", specs->chroma.bluex);\r\ntmp = ((block[6] & (3 << 4)) >> 4) | (block[0xc] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.bluey = tmp/1024;\r\nDPRINTK("BlueY: 0.%03d\n", specs->chroma.bluey);\r\ntmp = ((block[6] & (3 << 2)) >> 2) | (block[0xd] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.whitex = tmp/1024;\r\nDPRINTK(" WhiteX: 0.%03d ", specs->chroma.whitex);\r\ntmp = (block[6] & 3) | (block[0xe] << 2);\r\ntmp *= 1000;\r\ntmp += 512;\r\nspecs->chroma.whitey = tmp/1024;\r\nDPRINTK("WhiteY: 0.%03d\n", specs->chroma.whitey);\r\n}\r\nstatic void calc_mode_timings(int xres, int yres, int refresh,\r\nstruct fb_videomode *mode)\r\n{\r\nstruct fb_var_screeninfo *var;\r\nvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\r\nif (var) {\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,\r\nrefresh, var, NULL);\r\nmode->xres = xres;\r\nmode->yres = yres;\r\nmode->pixclock = var->pixclock;\r\nmode->refresh = refresh;\r\nmode->left_margin = var->left_margin;\r\nmode->right_margin = var->right_margin;\r\nmode->upper_margin = var->upper_margin;\r\nmode->lower_margin = var->lower_margin;\r\nmode->hsync_len = var->hsync_len;\r\nmode->vsync_len = var->vsync_len;\r\nmode->vmode = 0;\r\nmode->sync = 0;\r\nkfree(var);\r\n}\r\n}\r\nstatic int get_est_timing(unsigned char *block, struct fb_videomode *mode)\r\n{\r\nint num = 0;\r\nunsigned char c;\r\nc = block[0];\r\nif (c&0x80) {\r\ncalc_mode_timings(720, 400, 70, &mode[num]);\r\nmode[num++].flag = FB_MODE_IS_CALCULATED;\r\nDPRINTK(" 720x400@70Hz\n");\r\n}\r\nif (c&0x40) {\r\ncalc_mode_timings(720, 400, 88, &mode[num]);\r\nmode[num++].flag = FB_MODE_IS_CALCULATED;\r\nDPRINTK(" 720x400@88Hz\n");\r\n}\r\nif (c&0x20) {\r\nmode[num++] = vesa_modes[3];\r\nDPRINTK(" 640x480@60Hz\n");\r\n}\r\nif (c&0x10) {\r\ncalc_mode_timings(640, 480, 67, &mode[num]);\r\nmode[num++].flag = FB_MODE_IS_CALCULATED;\r\nDPRINTK(" 640x480@67Hz\n");\r\n}\r\nif (c&0x08) {\r\nmode[num++] = vesa_modes[4];\r\nDPRINTK(" 640x480@72Hz\n");\r\n}\r\nif (c&0x04) {\r\nmode[num++] = vesa_modes[5];\r\nDPRINTK(" 640x480@75Hz\n");\r\n}\r\nif (c&0x02) {\r\nmode[num++] = vesa_modes[7];\r\nDPRINTK(" 800x600@56Hz\n");\r\n}\r\nif (c&0x01) {\r\nmode[num++] = vesa_modes[8];\r\nDPRINTK(" 800x600@60Hz\n");\r\n}\r\nc = block[1];\r\nif (c&0x80) {\r\nmode[num++] = vesa_modes[9];\r\nDPRINTK(" 800x600@72Hz\n");\r\n}\r\nif (c&0x40) {\r\nmode[num++] = vesa_modes[10];\r\nDPRINTK(" 800x600@75Hz\n");\r\n}\r\nif (c&0x20) {\r\ncalc_mode_timings(832, 624, 75, &mode[num]);\r\nmode[num++].flag = FB_MODE_IS_CALCULATED;\r\nDPRINTK(" 832x624@75Hz\n");\r\n}\r\nif (c&0x10) {\r\nmode[num++] = vesa_modes[12];\r\nDPRINTK(" 1024x768@87Hz Interlaced\n");\r\n}\r\nif (c&0x08) {\r\nmode[num++] = vesa_modes[13];\r\nDPRINTK(" 1024x768@60Hz\n");\r\n}\r\nif (c&0x04) {\r\nmode[num++] = vesa_modes[14];\r\nDPRINTK(" 1024x768@70Hz\n");\r\n}\r\nif (c&0x02) {\r\nmode[num++] = vesa_modes[15];\r\nDPRINTK(" 1024x768@75Hz\n");\r\n}\r\nif (c&0x01) {\r\nmode[num++] = vesa_modes[21];\r\nDPRINTK(" 1280x1024@75Hz\n");\r\n}\r\nc = block[2];\r\nif (c&0x80) {\r\nmode[num++] = vesa_modes[17];\r\nDPRINTK(" 1152x870@75Hz\n");\r\n}\r\nDPRINTK(" Manufacturer's mask: %x\n",c&0x7F);\r\nreturn num;\r\n}\r\nstatic int get_std_timing(unsigned char *block, struct fb_videomode *mode,\r\nint ver, int rev)\r\n{\r\nint xres, yres = 0, refresh, ratio, i;\r\nxres = (block[0] + 31) * 8;\r\nif (xres <= 256)\r\nreturn 0;\r\nratio = (block[1] & 0xc0) >> 6;\r\nswitch (ratio) {\r\ncase 0:\r\nif (ver < 1 || (ver == 1 && rev < 3))\r\nyres = xres;\r\nelse\r\nyres = (xres * 10)/16;\r\nbreak;\r\ncase 1:\r\nyres = (xres * 3)/4;\r\nbreak;\r\ncase 2:\r\nyres = (xres * 4)/5;\r\nbreak;\r\ncase 3:\r\nyres = (xres * 9)/16;\r\nbreak;\r\n}\r\nrefresh = (block[1] & 0x3f) + 60;\r\nDPRINTK(" %dx%d@%dHz\n", xres, yres, refresh);\r\nfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\r\nif (vesa_modes[i].xres == xres &&\r\nvesa_modes[i].yres == yres &&\r\nvesa_modes[i].refresh == refresh) {\r\n*mode = vesa_modes[i];\r\nmode->flag |= FB_MODE_IS_STANDARD;\r\nreturn 1;\r\n}\r\n}\r\ncalc_mode_timings(xres, yres, refresh, mode);\r\nreturn 1;\r\n}\r\nstatic int get_dst_timing(unsigned char *block,\r\nstruct fb_videomode *mode, int ver, int rev)\r\n{\r\nint j, num = 0;\r\nfor (j = 0; j < 6; j++, block += STD_TIMING_DESCRIPTION_SIZE)\r\nnum += get_std_timing(block, &mode[num], ver, rev);\r\nreturn num;\r\n}\r\nstatic void get_detailed_timing(unsigned char *block,\r\nstruct fb_videomode *mode)\r\n{\r\nmode->xres = H_ACTIVE;\r\nmode->yres = V_ACTIVE;\r\nmode->pixclock = PIXEL_CLOCK;\r\nmode->pixclock /= 1000;\r\nmode->pixclock = KHZ2PICOS(mode->pixclock);\r\nmode->right_margin = H_SYNC_OFFSET;\r\nmode->left_margin = (H_ACTIVE + H_BLANKING) -\r\n(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);\r\nmode->upper_margin = V_BLANKING - V_SYNC_OFFSET -\r\nV_SYNC_WIDTH;\r\nmode->lower_margin = V_SYNC_OFFSET;\r\nmode->hsync_len = H_SYNC_WIDTH;\r\nmode->vsync_len = V_SYNC_WIDTH;\r\nif (HSYNC_POSITIVE)\r\nmode->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (VSYNC_POSITIVE)\r\nmode->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nmode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *\r\n(V_ACTIVE + V_BLANKING));\r\nif (INTERLACED) {\r\nmode->yres *= 2;\r\nmode->upper_margin *= 2;\r\nmode->lower_margin *= 2;\r\nmode->vsync_len *= 2;\r\nmode->vmode |= FB_VMODE_INTERLACED;\r\n}\r\nmode->flag = FB_MODE_IS_DETAILED;\r\nDPRINTK(" %d MHz ", PIXEL_CLOCK/1000000);\r\nDPRINTK("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,\r\nH_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);\r\nDPRINTK("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,\r\nV_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);\r\nDPRINTK("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",\r\n(VSYNC_POSITIVE) ? "+" : "-");\r\n}\r\nstatic struct fb_videomode *fb_create_modedb(unsigned char *edid, int *dbsize)\r\n{\r\nstruct fb_videomode *mode, *m;\r\nunsigned char *block;\r\nint num = 0, i, first = 1;\r\nint ver, rev;\r\nver = edid[EDID_STRUCT_VERSION];\r\nrev = edid[EDID_STRUCT_REVISION];\r\nmode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);\r\nif (mode == NULL)\r\nreturn NULL;\r\nif (edid == NULL || !edid_checksum(edid) ||\r\n!edid_check_header(edid)) {\r\nkfree(mode);\r\nreturn NULL;\r\n}\r\n*dbsize = 0;\r\nDPRINTK(" Detailed Timings\n");\r\nblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {\r\nif (!(block[0] == 0x00 && block[1] == 0x00)) {\r\nget_detailed_timing(block, &mode[num]);\r\nif (first) {\r\nmode[num].flag |= FB_MODE_IS_FIRST;\r\nfirst = 0;\r\n}\r\nnum++;\r\n}\r\n}\r\nDPRINTK(" Supported VESA Modes\n");\r\nblock = edid + ESTABLISHED_TIMING_1;\r\nnum += get_est_timing(block, &mode[num]);\r\nDPRINTK(" Standard Timings\n");\r\nblock = edid + STD_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < STD_TIMING; i++, block += STD_TIMING_DESCRIPTION_SIZE)\r\nnum += get_std_timing(block, &mode[num], ver, rev);\r\nblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {\r\nif (block[0] == 0x00 && block[1] == 0x00 && block[3] == 0xfa)\r\nnum += get_dst_timing(block + 5, &mode[num], ver, rev);\r\n}\r\nif (!num) {\r\nkfree(mode);\r\nreturn NULL;\r\n}\r\n*dbsize = num;\r\nm = kmalloc(num * sizeof(struct fb_videomode), GFP_KERNEL);\r\nif (!m)\r\nreturn mode;\r\nmemmove(m, mode, num * sizeof(struct fb_videomode));\r\nkfree(mode);\r\nreturn m;\r\n}\r\nvoid fb_destroy_modedb(struct fb_videomode *modedb)\r\n{\r\nkfree(modedb);\r\n}\r\nstatic int fb_get_monitor_limits(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\nint i, retval = 1;\r\nunsigned char *block;\r\nblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nDPRINTK(" Monitor Operating Limits: ");\r\nfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\r\nif (edid_is_limits_block(block)) {\r\nspecs->hfmin = H_MIN_RATE * 1000;\r\nspecs->hfmax = H_MAX_RATE * 1000;\r\nspecs->vfmin = V_MIN_RATE;\r\nspecs->vfmax = V_MAX_RATE;\r\nspecs->dclkmax = MAX_PIXEL_CLOCK * 1000000;\r\nspecs->gtf = (GTF_SUPPORT) ? 1 : 0;\r\nretval = 0;\r\nDPRINTK("From EDID\n");\r\nbreak;\r\n}\r\n}\r\nif (retval) {\r\nstruct fb_videomode *modes, *mode;\r\nint num_modes, hz, hscan, pixclock;\r\nint vtotal, htotal;\r\nmodes = fb_create_modedb(edid, &num_modes);\r\nif (!modes) {\r\nDPRINTK("None Available\n");\r\nreturn 1;\r\n}\r\nretval = 0;\r\nfor (i = 0; i < num_modes; i++) {\r\nmode = &modes[i];\r\npixclock = PICOS2KHZ(modes[i].pixclock) * 1000;\r\nhtotal = mode->xres + mode->right_margin + mode->hsync_len\r\n+ mode->left_margin;\r\nvtotal = mode->yres + mode->lower_margin + mode->vsync_len\r\n+ mode->upper_margin;\r\nif (mode->vmode & FB_VMODE_INTERLACED)\r\nvtotal /= 2;\r\nif (mode->vmode & FB_VMODE_DOUBLE)\r\nvtotal *= 2;\r\nhscan = (pixclock + htotal / 2) / htotal;\r\nhscan = (hscan + 500) / 1000 * 1000;\r\nhz = (hscan + vtotal / 2) / vtotal;\r\nif (specs->dclkmax == 0 || specs->dclkmax < pixclock)\r\nspecs->dclkmax = pixclock;\r\nif (specs->dclkmin == 0 || specs->dclkmin > pixclock)\r\nspecs->dclkmin = pixclock;\r\nif (specs->hfmax == 0 || specs->hfmax < hscan)\r\nspecs->hfmax = hscan;\r\nif (specs->hfmin == 0 || specs->hfmin > hscan)\r\nspecs->hfmin = hscan;\r\nif (specs->vfmax == 0 || specs->vfmax < hz)\r\nspecs->vfmax = hz;\r\nif (specs->vfmin == 0 || specs->vfmin > hz)\r\nspecs->vfmin = hz;\r\n}\r\nDPRINTK("Extrapolated\n");\r\nfb_destroy_modedb(modes);\r\n}\r\nDPRINTK(" H: %d-%dKHz V: %d-%dHz DCLK: %dMHz\n",\r\nspecs->hfmin/1000, specs->hfmax/1000, specs->vfmin,\r\nspecs->vfmax, specs->dclkmax/1000000);\r\nreturn retval;\r\n}\r\nstatic void get_monspecs(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\nunsigned char c, *block;\r\nblock = edid + EDID_STRUCT_DISPLAY;\r\nfb_get_monitor_limits(edid, specs);\r\nc = block[0] & 0x80;\r\nspecs->input = 0;\r\nif (c) {\r\nspecs->input |= FB_DISP_DDI;\r\nDPRINTK(" Digital Display Input");\r\n} else {\r\nDPRINTK(" Analog Display Input: Input Voltage - ");\r\nswitch ((block[0] & 0x60) >> 5) {\r\ncase 0:\r\nDPRINTK("0.700V/0.300V");\r\nspecs->input |= FB_DISP_ANA_700_300;\r\nbreak;\r\ncase 1:\r\nDPRINTK("0.714V/0.286V");\r\nspecs->input |= FB_DISP_ANA_714_286;\r\nbreak;\r\ncase 2:\r\nDPRINTK("1.000V/0.400V");\r\nspecs->input |= FB_DISP_ANA_1000_400;\r\nbreak;\r\ncase 3:\r\nDPRINTK("0.700V/0.000V");\r\nspecs->input |= FB_DISP_ANA_700_000;\r\nbreak;\r\n}\r\n}\r\nDPRINTK("\n Sync: ");\r\nc = block[0] & 0x10;\r\nif (c)\r\nDPRINTK(" Configurable signal level\n");\r\nc = block[0] & 0x0f;\r\nspecs->signal = 0;\r\nif (c & 0x10) {\r\nDPRINTK("Blank to Blank ");\r\nspecs->signal |= FB_SIGNAL_BLANK_BLANK;\r\n}\r\nif (c & 0x08) {\r\nDPRINTK("Separate ");\r\nspecs->signal |= FB_SIGNAL_SEPARATE;\r\n}\r\nif (c & 0x04) {\r\nDPRINTK("Composite ");\r\nspecs->signal |= FB_SIGNAL_COMPOSITE;\r\n}\r\nif (c & 0x02) {\r\nDPRINTK("Sync on Green ");\r\nspecs->signal |= FB_SIGNAL_SYNC_ON_GREEN;\r\n}\r\nif (c & 0x01) {\r\nDPRINTK("Serration on ");\r\nspecs->signal |= FB_SIGNAL_SERRATION_ON;\r\n}\r\nDPRINTK("\n");\r\nspecs->max_x = block[1];\r\nspecs->max_y = block[2];\r\nDPRINTK(" Max H-size in cm: ");\r\nif (specs->max_x)\r\nDPRINTK("%d\n", specs->max_x);\r\nelse\r\nDPRINTK("variable\n");\r\nDPRINTK(" Max V-size in cm: ");\r\nif (specs->max_y)\r\nDPRINTK("%d\n", specs->max_y);\r\nelse\r\nDPRINTK("variable\n");\r\nc = block[3];\r\nspecs->gamma = c+100;\r\nDPRINTK(" Gamma: ");\r\nDPRINTK("%d.%d\n", specs->gamma/100, specs->gamma % 100);\r\nget_dpms_capabilities(block[4], specs);\r\nswitch ((block[4] & 0x18) >> 3) {\r\ncase 0:\r\nDPRINTK(" Monochrome/Grayscale\n");\r\nspecs->input |= FB_DISP_MONO;\r\nbreak;\r\ncase 1:\r\nDPRINTK(" RGB Color Display\n");\r\nspecs->input |= FB_DISP_RGB;\r\nbreak;\r\ncase 2:\r\nDPRINTK(" Non-RGB Multicolor Display\n");\r\nspecs->input |= FB_DISP_MULTI;\r\nbreak;\r\ndefault:\r\nDPRINTK(" Unknown\n");\r\nspecs->input |= FB_DISP_UNKNOWN;\r\nbreak;\r\n}\r\nget_chroma(block, specs);\r\nspecs->misc = 0;\r\nc = block[4] & 0x7;\r\nif (c & 0x04) {\r\nDPRINTK(" Default color format is primary\n");\r\nspecs->misc |= FB_MISC_PRIM_COLOR;\r\n}\r\nif (c & 0x02) {\r\nDPRINTK(" First DETAILED Timing is preferred\n");\r\nspecs->misc |= FB_MISC_1ST_DETAIL;\r\n}\r\nif (c & 0x01) {\r\nprintk(" Display is GTF capable\n");\r\nspecs->gtf = 1;\r\n}\r\n}\r\nint fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var)\r\n{\r\nint i;\r\nunsigned char *block;\r\nif (edid == NULL || var == NULL)\r\nreturn 1;\r\nif (!(edid_checksum(edid)))\r\nreturn 1;\r\nif (!(edid_check_header(edid)))\r\nreturn 1;\r\nblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\r\nif (edid_is_timing_block(block)) {\r\nvar->xres = var->xres_virtual = H_ACTIVE;\r\nvar->yres = var->yres_virtual = V_ACTIVE;\r\nvar->height = var->width = 0;\r\nvar->right_margin = H_SYNC_OFFSET;\r\nvar->left_margin = (H_ACTIVE + H_BLANKING) -\r\n(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);\r\nvar->upper_margin = V_BLANKING - V_SYNC_OFFSET -\r\nV_SYNC_WIDTH;\r\nvar->lower_margin = V_SYNC_OFFSET;\r\nvar->hsync_len = H_SYNC_WIDTH;\r\nvar->vsync_len = V_SYNC_WIDTH;\r\nvar->pixclock = PIXEL_CLOCK;\r\nvar->pixclock /= 1000;\r\nvar->pixclock = KHZ2PICOS(var->pixclock);\r\nif (HSYNC_POSITIVE)\r\nvar->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (VSYNC_POSITIVE)\r\nvar->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid fb_edid_to_monspecs(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\nunsigned char *block;\r\nint i, found = 0;\r\nif (edid == NULL)\r\nreturn;\r\nif (!(edid_checksum(edid)))\r\nreturn;\r\nif (!(edid_check_header(edid)))\r\nreturn;\r\nmemset(specs, 0, sizeof(struct fb_monspecs));\r\nspecs->version = edid[EDID_STRUCT_VERSION];\r\nspecs->revision = edid[EDID_STRUCT_REVISION];\r\nDPRINTK("========================================\n");\r\nDPRINTK("Display Information (EDID)\n");\r\nDPRINTK("========================================\n");\r\nDPRINTK(" EDID Version %d.%d\n", (int) specs->version,\r\n(int) specs->revision);\r\nparse_vendor_block(edid + ID_MANUFACTURER_NAME, specs);\r\nblock = edid + DETAILED_TIMING_DESCRIPTIONS_START;\r\nfor (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {\r\nif (edid_is_serial_block(block)) {\r\ncopy_string(block, specs->serial_no);\r\nDPRINTK(" Serial Number: %s\n", specs->serial_no);\r\n} else if (edid_is_ascii_block(block)) {\r\ncopy_string(block, specs->ascii);\r\nDPRINTK(" ASCII Block: %s\n", specs->ascii);\r\n} else if (edid_is_monitor_block(block)) {\r\ncopy_string(block, specs->monitor);\r\nDPRINTK(" Monitor Name: %s\n", specs->monitor);\r\n}\r\n}\r\nDPRINTK(" Display Characteristics:\n");\r\nget_monspecs(edid, specs);\r\nspecs->modedb = fb_create_modedb(edid, &specs->modedb_len);\r\nfor (i = 0; i < specs->modedb_len; i++) {\r\nif (specs->modedb[i].flag & FB_MODE_IS_DETAILED) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nspecs->misc &= ~FB_MISC_1ST_DETAIL;\r\nDPRINTK("========================================\n");\r\n}\r\nvoid fb_edid_add_monspecs(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\nunsigned char *block;\r\nstruct fb_videomode *m;\r\nint num = 0, i;\r\nu8 svd[64], edt[(128 - 4) / DETAILED_TIMING_DESCRIPTION_SIZE];\r\nu8 pos = 4, svd_n = 0;\r\nif (!edid)\r\nreturn;\r\nif (!edid_checksum(edid))\r\nreturn;\r\nif (edid[0] != 0x2 ||\r\nedid[2] < 4 || edid[2] > 128 - DETAILED_TIMING_DESCRIPTION_SIZE)\r\nreturn;\r\nDPRINTK(" Short Video Descriptors\n");\r\nwhile (pos < edid[2]) {\r\nu8 len = edid[pos] & 0x1f, type = (edid[pos] >> 5) & 7;\r\npr_debug("Data block %u of %u bytes\n", type, len);\r\nif (type == 2) {\r\nfor (i = pos; i < pos + len; i++) {\r\nu8 idx = edid[pos + i] & 0x7f;\r\nsvd[svd_n++] = idx;\r\npr_debug("N%sative mode #%d\n",\r\nedid[pos + i] & 0x80 ? "" : "on-n", idx);\r\n}\r\n} else if (type == 3 && len >= 3) {\r\nif (edid[pos + 1] == 3 && edid[pos + 2] == 0xc &&\r\nedid[pos + 3] == 0)\r\nspecs->misc |= FB_MISC_HDMI;\r\n}\r\npos += len + 1;\r\n}\r\nblock = edid + edid[2];\r\nDPRINTK(" Extended Detailed Timings\n");\r\nfor (i = 0; i < (128 - edid[2]) / DETAILED_TIMING_DESCRIPTION_SIZE;\r\ni++, block += DETAILED_TIMING_DESCRIPTION_SIZE)\r\nif (PIXEL_CLOCK)\r\nedt[num++] = block - edid;\r\nif (!(num + svd_n))\r\nreturn;\r\nm = kzalloc((specs->modedb_len + num + svd_n) *\r\nsizeof(struct fb_videomode), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nmemcpy(m, specs->modedb, specs->modedb_len * sizeof(struct fb_videomode));\r\nfor (i = specs->modedb_len; i < specs->modedb_len + num; i++) {\r\nget_detailed_timing(edid + edt[i - specs->modedb_len], &m[i]);\r\nif (i == specs->modedb_len)\r\nm[i].flag |= FB_MODE_IS_FIRST;\r\npr_debug("Adding %ux%u@%u\n", m[i].xres, m[i].yres, m[i].refresh);\r\n}\r\nfor (i = specs->modedb_len + num; i < specs->modedb_len + num + svd_n; i++) {\r\nint idx = svd[i - specs->modedb_len - num];\r\nif (!idx || idx > 63) {\r\npr_warning("Reserved SVD code %d\n", idx);\r\n} else if (idx > ARRAY_SIZE(cea_modes) || !cea_modes[idx].xres) {\r\npr_warning("Unimplemented SVD code %d\n", idx);\r\n} else {\r\nmemcpy(&m[i], cea_modes + idx, sizeof(m[i]));\r\npr_debug("Adding SVD #%d: %ux%u@%u\n", idx,\r\nm[i].xres, m[i].yres, m[i].refresh);\r\n}\r\n}\r\nkfree(specs->modedb);\r\nspecs->modedb = m;\r\nspecs->modedb_len = specs->modedb_len + num + svd_n;\r\n}\r\nstatic u32 fb_get_vblank(u32 hfreq)\r\n{\r\nu32 vblank;\r\nvblank = (hfreq * FLYBACK)/1000;\r\nvblank = (vblank + 500)/1000;\r\nreturn (vblank + V_FRONTPORCH);\r\n}\r\nstatic u32 fb_get_hblank_by_hfreq(u32 hfreq, u32 xres)\r\n{\r\nu32 c_val, m_val, duty_cycle, hblank;\r\nc_val = (((H_OFFSET - H_SCALEFACTOR) * H_BLANKSCALE)/256 +\r\nH_SCALEFACTOR) * 1000;\r\nm_val = (H_BLANKSCALE * H_GRADIENT)/256;\r\nm_val = (m_val * 1000000)/hfreq;\r\nduty_cycle = c_val - m_val;\r\nhblank = (xres * duty_cycle)/(100000 - duty_cycle);\r\nreturn (hblank);\r\n}\r\nstatic u32 fb_get_hblank_by_dclk(u32 dclk, u32 xres)\r\n{\r\nu32 duty_cycle, h_period, hblank;\r\ndclk /= 1000;\r\nh_period = 100 - C_VAL;\r\nh_period *= h_period;\r\nh_period += (M_VAL * xres * 2 * 1000)/(5 * dclk);\r\nh_period *= 10000;\r\nh_period = int_sqrt(h_period);\r\nh_period -= (100 - C_VAL) * 100;\r\nh_period *= 1000;\r\nh_period /= 2 * M_VAL;\r\nduty_cycle = C_VAL * 1000 - (M_VAL * h_period)/100;\r\nhblank = (xres * duty_cycle)/(100000 - duty_cycle) + 8;\r\nhblank &= ~15;\r\nreturn (hblank);\r\n}\r\nstatic u32 fb_get_hfreq(u32 vfreq, u32 yres)\r\n{\r\nu32 divisor, hfreq;\r\ndivisor = (1000000 - (vfreq * FLYBACK))/1000;\r\nhfreq = (yres + V_FRONTPORCH) * vfreq * 1000;\r\nreturn (hfreq/divisor);\r\n}\r\nstatic void fb_timings_vfreq(struct __fb_timings *timings)\r\n{\r\ntimings->hfreq = fb_get_hfreq(timings->vfreq, timings->vactive);\r\ntimings->vblank = fb_get_vblank(timings->hfreq);\r\ntimings->vtotal = timings->vactive + timings->vblank;\r\ntimings->hblank = fb_get_hblank_by_hfreq(timings->hfreq,\r\ntimings->hactive);\r\ntimings->htotal = timings->hactive + timings->hblank;\r\ntimings->dclk = timings->htotal * timings->hfreq;\r\n}\r\nstatic void fb_timings_hfreq(struct __fb_timings *timings)\r\n{\r\ntimings->vblank = fb_get_vblank(timings->hfreq);\r\ntimings->vtotal = timings->vactive + timings->vblank;\r\ntimings->vfreq = timings->hfreq/timings->vtotal;\r\ntimings->hblank = fb_get_hblank_by_hfreq(timings->hfreq,\r\ntimings->hactive);\r\ntimings->htotal = timings->hactive + timings->hblank;\r\ntimings->dclk = timings->htotal * timings->hfreq;\r\n}\r\nstatic void fb_timings_dclk(struct __fb_timings *timings)\r\n{\r\ntimings->hblank = fb_get_hblank_by_dclk(timings->dclk,\r\ntimings->hactive);\r\ntimings->htotal = timings->hactive + timings->hblank;\r\ntimings->hfreq = timings->dclk/timings->htotal;\r\ntimings->vblank = fb_get_vblank(timings->hfreq);\r\ntimings->vtotal = timings->vactive + timings->vblank;\r\ntimings->vfreq = timings->hfreq/timings->vtotal;\r\n}\r\nint fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct __fb_timings *timings;\r\nu32 interlace = 1, dscan = 1;\r\nu32 hfmin, hfmax, vfmin, vfmax, dclkmin, dclkmax, err = 0;\r\ntimings = kzalloc(sizeof(struct __fb_timings), GFP_KERNEL);\r\nif (!timings)\r\nreturn -ENOMEM;\r\nif (!info || !info->monspecs.hfmax || !info->monspecs.vfmax ||\r\n!info->monspecs.dclkmax ||\r\ninfo->monspecs.hfmax < info->monspecs.hfmin ||\r\ninfo->monspecs.vfmax < info->monspecs.vfmin ||\r\ninfo->monspecs.dclkmax < info->monspecs.dclkmin) {\r\nhfmin = 29000; hfmax = 30000;\r\nvfmin = 60; vfmax = 60;\r\ndclkmin = 0; dclkmax = 25000000;\r\n} else {\r\nhfmin = info->monspecs.hfmin;\r\nhfmax = info->monspecs.hfmax;\r\nvfmin = info->monspecs.vfmin;\r\nvfmax = info->monspecs.vfmax;\r\ndclkmin = info->monspecs.dclkmin;\r\ndclkmax = info->monspecs.dclkmax;\r\n}\r\ntimings->hactive = var->xres;\r\ntimings->vactive = var->yres;\r\nif (var->vmode & FB_VMODE_INTERLACED) {\r\ntimings->vactive /= 2;\r\ninterlace = 2;\r\n}\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\ntimings->vactive *= 2;\r\ndscan = 2;\r\n}\r\nswitch (flags & ~FB_IGNOREMON) {\r\ncase FB_MAXTIMINGS:\r\ntimings->hfreq = hfmax;\r\nfb_timings_hfreq(timings);\r\nif (timings->vfreq > vfmax) {\r\ntimings->vfreq = vfmax;\r\nfb_timings_vfreq(timings);\r\n}\r\nif (timings->dclk > dclkmax) {\r\ntimings->dclk = dclkmax;\r\nfb_timings_dclk(timings);\r\n}\r\nbreak;\r\ncase FB_VSYNCTIMINGS:\r\ntimings->vfreq = val;\r\nfb_timings_vfreq(timings);\r\nbreak;\r\ncase FB_HSYNCTIMINGS:\r\ntimings->hfreq = val;\r\nfb_timings_hfreq(timings);\r\nbreak;\r\ncase FB_DCLKTIMINGS:\r\ntimings->dclk = PICOS2KHZ(val) * 1000;\r\nfb_timings_dclk(timings);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (err || (!(flags & FB_IGNOREMON) &&\r\n(timings->vfreq < vfmin || timings->vfreq > vfmax ||\r\ntimings->hfreq < hfmin || timings->hfreq > hfmax ||\r\ntimings->dclk < dclkmin || timings->dclk > dclkmax))) {\r\nerr = -EINVAL;\r\n} else {\r\nvar->pixclock = KHZ2PICOS(timings->dclk/1000);\r\nvar->hsync_len = (timings->htotal * 8)/100;\r\nvar->right_margin = (timings->hblank/2) - var->hsync_len;\r\nvar->left_margin = timings->hblank - var->right_margin -\r\nvar->hsync_len;\r\nvar->vsync_len = (3 * interlace)/dscan;\r\nvar->lower_margin = (1 * interlace)/dscan;\r\nvar->upper_margin = (timings->vblank * interlace)/dscan -\r\n(var->vsync_len + var->lower_margin);\r\n}\r\nkfree(timings);\r\nreturn err;\r\n}\r\nint fb_videomode_from_videomode(const struct videomode *vm,\r\nstruct fb_videomode *fbmode)\r\n{\r\nunsigned int htotal, vtotal;\r\nfbmode->xres = vm->hactive;\r\nfbmode->left_margin = vm->hback_porch;\r\nfbmode->right_margin = vm->hfront_porch;\r\nfbmode->hsync_len = vm->hsync_len;\r\nfbmode->yres = vm->vactive;\r\nfbmode->upper_margin = vm->vback_porch;\r\nfbmode->lower_margin = vm->vfront_porch;\r\nfbmode->vsync_len = vm->vsync_len;\r\nfbmode->pixclock = vm->pixelclock ?\r\nKHZ2PICOS(vm->pixelclock / 1000) : 0;\r\nfbmode->sync = 0;\r\nfbmode->vmode = 0;\r\nif (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\nfbmode->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\nfbmode->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nif (vm->flags & DISPLAY_FLAGS_INTERLACED)\r\nfbmode->vmode |= FB_VMODE_INTERLACED;\r\nif (vm->flags & DISPLAY_FLAGS_DOUBLESCAN)\r\nfbmode->vmode |= FB_VMODE_DOUBLE;\r\nfbmode->flag = 0;\r\nhtotal = vm->hactive + vm->hfront_porch + vm->hback_porch +\r\nvm->hsync_len;\r\nvtotal = vm->vactive + vm->vfront_porch + vm->vback_porch +\r\nvm->vsync_len;\r\nif (htotal && vtotal) {\r\nfbmode->refresh = vm->pixelclock / (htotal * vtotal);\r\n} else {\r\nfbmode->refresh = 0;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void dump_fb_videomode(const struct fb_videomode *m)\r\n{\r\npr_debug("fb_videomode = %ux%u@%uHz (%ukHz) %u %u %u %u %u %u %u %u %u\n",\r\nm->xres, m->yres, m->refresh, m->pixclock, m->left_margin,\r\nm->right_margin, m->upper_margin, m->lower_margin,\r\nm->hsync_len, m->vsync_len, m->sync, m->vmode, m->flag);\r\n}\r\nint of_get_fb_videomode(struct device_node *np, struct fb_videomode *fb,\r\nint index)\r\n{\r\nstruct videomode vm;\r\nint ret;\r\nret = of_get_videomode(np, &vm, index);\r\nif (ret)\r\nreturn ret;\r\nfb_videomode_from_videomode(&vm, fb);\r\npr_debug("%s: got %dx%d display mode from %s\n",\r\nof_node_full_name(np), vm.hactive, vm.vactive, np->name);\r\ndump_fb_videomode(fb);\r\nreturn 0;\r\n}\r\nint fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var)\r\n{\r\nreturn 1;\r\n}\r\nvoid fb_edid_to_monspecs(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\nspecs = NULL;\r\n}\r\nvoid fb_edid_add_monspecs(unsigned char *edid, struct fb_monspecs *specs)\r\n{\r\n}\r\nvoid fb_destroy_modedb(struct fb_videomode *modedb)\r\n{\r\n}\r\nint fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint fb_validate_mode(const struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu32 hfreq, vfreq, htotal, vtotal, pixclock;\r\nu32 hfmin, hfmax, vfmin, vfmax, dclkmin, dclkmax;\r\nif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\r\n!info->monspecs.dclkmax ||\r\ninfo->monspecs.hfmax < info->monspecs.hfmin ||\r\ninfo->monspecs.vfmax < info->monspecs.vfmin ||\r\ninfo->monspecs.dclkmax < info->monspecs.dclkmin) {\r\nhfmin = 29000; hfmax = 30000;\r\nvfmin = 60; vfmax = 60;\r\ndclkmin = 0; dclkmax = 25000000;\r\n} else {\r\nhfmin = info->monspecs.hfmin;\r\nhfmax = info->monspecs.hfmax;\r\nvfmin = info->monspecs.vfmin;\r\nvfmax = info->monspecs.vfmax;\r\ndclkmin = info->monspecs.dclkmin;\r\ndclkmax = info->monspecs.dclkmax;\r\n}\r\nif (!var->pixclock)\r\nreturn -EINVAL;\r\npixclock = PICOS2KHZ(var->pixclock) * 1000;\r\nhtotal = var->xres + var->right_margin + var->hsync_len +\r\nvar->left_margin;\r\nvtotal = var->yres + var->lower_margin + var->vsync_len +\r\nvar->upper_margin;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvtotal /= 2;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\nvtotal *= 2;\r\nhfreq = pixclock/htotal;\r\nhfreq = (hfreq + 500) / 1000 * 1000;\r\nvfreq = hfreq/vtotal;\r\nreturn (vfreq < vfmin || vfreq > vfmax ||\r\nhfreq < hfmin || hfreq > hfmax ||\r\npixclock < dclkmin || pixclock > dclkmax) ?\r\n-EINVAL : 0;\r\n}\r\nconst unsigned char *fb_firmware_edid(struct device *device)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nstruct resource *res = NULL;\r\nunsigned char *edid = NULL;\r\nif (device)\r\ndev = to_pci_dev(device);\r\nif (dev)\r\nres = &dev->resource[PCI_ROM_RESOURCE];\r\nif (res && res->flags & IORESOURCE_ROM_SHADOW)\r\nedid = edid_info.dummy;\r\nreturn edid;\r\n}\r\nconst unsigned char *fb_firmware_edid(struct device *device)\r\n{\r\nreturn NULL;\r\n}
