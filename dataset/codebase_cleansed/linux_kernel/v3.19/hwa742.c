static u8 hwa742_read_reg(u8 reg)\r\n{\r\nu8 data;\r\nhwa742.extif->set_bits_per_cycle(8);\r\nhwa742.extif->write_command(&reg, 1);\r\nhwa742.extif->read_data(&data, 1);\r\nreturn data;\r\n}\r\nstatic void hwa742_write_reg(u8 reg, u8 data)\r\n{\r\nhwa742.extif->set_bits_per_cycle(8);\r\nhwa742.extif->write_command(&reg, 1);\r\nhwa742.extif->write_data(&data, 1);\r\n}\r\nstatic void set_window_regs(int x_start, int y_start, int x_end, int y_end)\r\n{\r\nu8 tmp[8];\r\nu8 cmd;\r\nx_end--;\r\ny_end--;\r\ntmp[0] = x_start;\r\ntmp[1] = x_start >> 8;\r\ntmp[2] = y_start;\r\ntmp[3] = y_start >> 8;\r\ntmp[4] = x_end;\r\ntmp[5] = x_end >> 8;\r\ntmp[6] = y_end;\r\ntmp[7] = y_end >> 8;\r\nhwa742.extif->set_bits_per_cycle(8);\r\ncmd = HWA742_WINDOW_X_START_0;\r\nhwa742.extif->write_command(&cmd, 1);\r\nhwa742.extif->write_data(tmp, 8);\r\n}\r\nstatic void set_format_regs(int conv, int transl, int flags)\r\n{\r\nif (flags & OMAPFB_FORMAT_FLAG_DOUBLE) {\r\nhwa742.window_type = ((hwa742.window_type & 0xfc) | 0x01);\r\n#ifdef VERBOSE\r\ndev_dbg(hwa742.fbdev->dev, "hwa742: enabled pixel doubling\n");\r\n#endif\r\n} else {\r\nhwa742.window_type = (hwa742.window_type & 0xfc);\r\n#ifdef VERBOSE\r\ndev_dbg(hwa742.fbdev->dev, "hwa742: disabled pixel doubling\n");\r\n#endif\r\n}\r\nhwa742_write_reg(HWA742_INPUT_MODE_REG, conv);\r\nhwa742_write_reg(HWA742_TRANSL_MODE_REG1, transl);\r\nhwa742_write_reg(HWA742_WINDOW_TYPE, hwa742.window_type);\r\n}\r\nstatic void enable_tearsync(int y, int width, int height, int screen_height,\r\nint force_vsync)\r\n{\r\nu8 b;\r\nb = hwa742_read_reg(HWA742_NDP_CTRL);\r\nb |= 1 << 2;\r\nhwa742_write_reg(HWA742_NDP_CTRL, b);\r\nif (likely(hwa742.vsync_only || force_vsync)) {\r\nhwa742.extif->enable_tearsync(1, 0);\r\nreturn;\r\n}\r\nif (width * hwa742.pix_tx_time < hwa742.line_upd_time) {\r\nhwa742.extif->enable_tearsync(1, 0);\r\nreturn;\r\n}\r\nif ((width * hwa742.pix_tx_time / 1000) * height <\r\n(y + height) * (hwa742.line_upd_time / 1000)) {\r\nhwa742.extif->enable_tearsync(1, 0);\r\nreturn;\r\n}\r\nhwa742.extif->enable_tearsync(1, y + 1);\r\n}\r\nstatic void disable_tearsync(void)\r\n{\r\nu8 b;\r\nhwa742.extif->enable_tearsync(0, 0);\r\nb = hwa742_read_reg(HWA742_NDP_CTRL);\r\nb &= ~(1 << 2);\r\nhwa742_write_reg(HWA742_NDP_CTRL, b);\r\n}\r\nstatic inline struct hwa742_request *alloc_req(void)\r\n{\r\nunsigned long flags;\r\nstruct hwa742_request *req;\r\nint req_flags = 0;\r\nif (!in_interrupt())\r\ndown(&hwa742.req_sema);\r\nelse\r\nreq_flags = REQ_FROM_IRQ_POOL;\r\nspin_lock_irqsave(&hwa742.req_lock, flags);\r\nBUG_ON(list_empty(&hwa742.free_req_list));\r\nreq = list_entry(hwa742.free_req_list.next,\r\nstruct hwa742_request, entry);\r\nlist_del(&req->entry);\r\nspin_unlock_irqrestore(&hwa742.req_lock, flags);\r\nINIT_LIST_HEAD(&req->entry);\r\nreq->flags = req_flags;\r\nreturn req;\r\n}\r\nstatic inline void free_req(struct hwa742_request *req)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwa742.req_lock, flags);\r\nlist_move(&req->entry, &hwa742.free_req_list);\r\nif (!(req->flags & REQ_FROM_IRQ_POOL))\r\nup(&hwa742.req_sema);\r\nspin_unlock_irqrestore(&hwa742.req_lock, flags);\r\n}\r\nstatic void process_pending_requests(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwa742.req_lock, flags);\r\nwhile (!list_empty(&hwa742.pending_req_list)) {\r\nstruct hwa742_request *req;\r\nvoid (*complete)(void *);\r\nvoid *complete_data;\r\nreq = list_entry(hwa742.pending_req_list.next,\r\nstruct hwa742_request, entry);\r\nspin_unlock_irqrestore(&hwa742.req_lock, flags);\r\nif (req->handler(req) == REQ_PENDING)\r\nreturn;\r\ncomplete = req->complete;\r\ncomplete_data = req->complete_data;\r\nfree_req(req);\r\nif (complete)\r\ncomplete(complete_data);\r\nspin_lock_irqsave(&hwa742.req_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&hwa742.req_lock, flags);\r\n}\r\nstatic void submit_req_list(struct list_head *head)\r\n{\r\nunsigned long flags;\r\nint process = 1;\r\nspin_lock_irqsave(&hwa742.req_lock, flags);\r\nif (likely(!list_empty(&hwa742.pending_req_list)))\r\nprocess = 0;\r\nlist_splice_init(head, hwa742.pending_req_list.prev);\r\nspin_unlock_irqrestore(&hwa742.req_lock, flags);\r\nif (process)\r\nprocess_pending_requests();\r\n}\r\nstatic void request_complete(void *data)\r\n{\r\nstruct hwa742_request *req = (struct hwa742_request *)data;\r\nvoid (*complete)(void *);\r\nvoid *complete_data;\r\ncomplete = req->complete;\r\ncomplete_data = req->complete_data;\r\nfree_req(req);\r\nif (complete)\r\ncomplete(complete_data);\r\nprocess_pending_requests();\r\n}\r\nstatic int send_frame_handler(struct hwa742_request *req)\r\n{\r\nstruct update_param *par = &req->par.update;\r\nint x = par->x;\r\nint y = par->y;\r\nint w = par->width;\r\nint h = par->height;\r\nint bpp;\r\nint conv, transl;\r\nunsigned long offset;\r\nint color_mode = par->color_mode;\r\nint flags = par->flags;\r\nint scr_width = hwa742.fbdev->panel->x_res;\r\nint scr_height = hwa742.fbdev->panel->y_res;\r\n#ifdef VERBOSE\r\ndev_dbg(hwa742.fbdev->dev, "x %d y %d w %d h %d scr_width %d "\r\n"color_mode %d flags %d\n",\r\nx, y, w, h, scr_width, color_mode, flags);\r\n#endif\r\nswitch (color_mode) {\r\ncase OMAPFB_COLOR_YUV422:\r\nbpp = 16;\r\nconv = 0x08;\r\ntransl = 0x25;\r\nbreak;\r\ncase OMAPFB_COLOR_YUV420:\r\nbpp = 12;\r\nconv = 0x09;\r\ntransl = 0x25;\r\nbreak;\r\ncase OMAPFB_COLOR_RGB565:\r\nbpp = 16;\r\nconv = 0x01;\r\ntransl = 0x05;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (hwa742.prev_flags != flags ||\r\nhwa742.prev_color_mode != color_mode) {\r\nset_format_regs(conv, transl, flags);\r\nhwa742.prev_color_mode = color_mode;\r\nhwa742.prev_flags = flags;\r\n}\r\nflags = req->par.update.flags;\r\nif (flags & OMAPFB_FORMAT_FLAG_TEARSYNC)\r\nenable_tearsync(y, scr_width, h, scr_height,\r\nflags & OMAPFB_FORMAT_FLAG_FORCE_VSYNC);\r\nelse\r\ndisable_tearsync();\r\nset_window_regs(x, y, x + w, y + h);\r\noffset = (scr_width * y + x) * bpp / 8;\r\nhwa742.int_ctrl->setup_plane(OMAPFB_PLANE_GFX,\r\nOMAPFB_CHANNEL_OUT_LCD, offset, scr_width, 0, 0, w, h,\r\ncolor_mode);\r\nhwa742.extif->set_bits_per_cycle(16);\r\nhwa742.int_ctrl->enable_plane(OMAPFB_PLANE_GFX, 1);\r\nhwa742.extif->transfer_area(w, h, request_complete, req);\r\nreturn REQ_PENDING;\r\n}\r\nstatic void send_frame_complete(void *data)\r\n{\r\nhwa742.int_ctrl->enable_plane(OMAPFB_PLANE_GFX, 0);\r\n}\r\nstatic void create_req_list(struct omapfb_update_window *win,\r\nstruct list_head *req_head)\r\n{\r\nstruct hwa742_request *req;\r\nint x = win->x;\r\nint y = win->y;\r\nint width = win->width;\r\nint height = win->height;\r\nint color_mode;\r\nint flags;\r\nflags = win->format & ~OMAPFB_FORMAT_MASK;\r\ncolor_mode = win->format & OMAPFB_FORMAT_MASK;\r\nif (x & 1) {\r\nADD_PREQ(x, y, 1, height);\r\nwidth--;\r\nx++;\r\nflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\r\n}\r\nif (width & ~1) {\r\nunsigned int xspan = width & ~1;\r\nunsigned int ystart = y;\r\nunsigned int yspan = height;\r\nif (xspan * height * 2 > hwa742.max_transmit_size) {\r\nyspan = hwa742.max_transmit_size / (xspan * 2);\r\nADD_PREQ(x, ystart, xspan, yspan);\r\nystart += yspan;\r\nyspan = height - yspan;\r\nflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\r\n}\r\nADD_PREQ(x, ystart, xspan, yspan);\r\nx += xspan;\r\nwidth -= xspan;\r\nflags &= ~OMAPFB_FORMAT_FLAG_TEARSYNC;\r\n}\r\nif (width)\r\nADD_PREQ(x, y, 1, height);\r\n}\r\nstatic void auto_update_complete(void *data)\r\n{\r\nif (!hwa742.stop_auto_update)\r\nmod_timer(&hwa742.auto_update_timer,\r\njiffies + HWA742_AUTO_UPDATE_TIME);\r\n}\r\nstatic void hwa742_update_window_auto(unsigned long arg)\r\n{\r\nLIST_HEAD(req_list);\r\nstruct hwa742_request *last;\r\ncreate_req_list(&hwa742.auto_update_window, &req_list);\r\nlast = list_entry(req_list.prev, struct hwa742_request, entry);\r\nlast->complete = auto_update_complete;\r\nlast->complete_data = NULL;\r\nsubmit_req_list(&req_list);\r\n}\r\nint hwa742_update_window_async(struct fb_info *fbi,\r\nstruct omapfb_update_window *win,\r\nvoid (*complete_callback)(void *arg),\r\nvoid *complete_callback_data)\r\n{\r\nLIST_HEAD(req_list);\r\nstruct hwa742_request *last;\r\nint r = 0;\r\nif (hwa742.update_mode != OMAPFB_MANUAL_UPDATE) {\r\ndev_dbg(hwa742.fbdev->dev, "invalid update mode\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely(win->format &\r\n~(0x03 | OMAPFB_FORMAT_FLAG_DOUBLE |\r\nOMAPFB_FORMAT_FLAG_TEARSYNC | OMAPFB_FORMAT_FLAG_FORCE_VSYNC))) {\r\ndev_dbg(hwa742.fbdev->dev, "invalid window flag\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\ncreate_req_list(win, &req_list);\r\nlast = list_entry(req_list.prev, struct hwa742_request, entry);\r\nlast->complete = complete_callback;\r\nlast->complete_data = (void *)complete_callback_data;\r\nsubmit_req_list(&req_list);\r\nout:\r\nreturn r;\r\n}\r\nstatic int hwa742_setup_plane(int plane, int channel_out,\r\nunsigned long offset, int screen_width,\r\nint pos_x, int pos_y, int width, int height,\r\nint color_mode)\r\n{\r\nif (plane != OMAPFB_PLANE_GFX ||\r\nchannel_out != OMAPFB_CHANNEL_OUT_LCD)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hwa742_enable_plane(int plane, int enable)\r\n{\r\nif (plane != 0)\r\nreturn -EINVAL;\r\nhwa742.int_ctrl->enable_plane(plane, enable);\r\nreturn 0;\r\n}\r\nstatic int sync_handler(struct hwa742_request *req)\r\n{\r\ncomplete(req->par.sync);\r\nreturn REQ_COMPLETE;\r\n}\r\nstatic void hwa742_sync(void)\r\n{\r\nLIST_HEAD(req_list);\r\nstruct hwa742_request *req;\r\nstruct completion comp;\r\nreq = alloc_req();\r\nreq->handler = sync_handler;\r\nreq->complete = NULL;\r\ninit_completion(&comp);\r\nreq->par.sync = &comp;\r\nlist_add(&req->entry, &req_list);\r\nsubmit_req_list(&req_list);\r\nwait_for_completion(&comp);\r\n}\r\nstatic void hwa742_bind_client(struct omapfb_notifier_block *nb)\r\n{\r\ndev_dbg(hwa742.fbdev->dev, "update_mode %d\n", hwa742.update_mode);\r\nif (hwa742.update_mode == OMAPFB_MANUAL_UPDATE) {\r\nomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_READY);\r\n}\r\n}\r\nstatic int hwa742_set_update_mode(enum omapfb_update_mode mode)\r\n{\r\nif (mode != OMAPFB_MANUAL_UPDATE && mode != OMAPFB_AUTO_UPDATE &&\r\nmode != OMAPFB_UPDATE_DISABLED)\r\nreturn -EINVAL;\r\nif (mode == hwa742.update_mode)\r\nreturn 0;\r\ndev_info(hwa742.fbdev->dev, "HWA742: setting update mode to %s\n",\r\nmode == OMAPFB_UPDATE_DISABLED ? "disabled" :\r\n(mode == OMAPFB_AUTO_UPDATE ? "auto" : "manual"));\r\nswitch (hwa742.update_mode) {\r\ncase OMAPFB_MANUAL_UPDATE:\r\nomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_DISABLED);\r\nbreak;\r\ncase OMAPFB_AUTO_UPDATE:\r\nhwa742.stop_auto_update = 1;\r\ndel_timer_sync(&hwa742.auto_update_timer);\r\nbreak;\r\ncase OMAPFB_UPDATE_DISABLED:\r\nbreak;\r\n}\r\nhwa742.update_mode = mode;\r\nhwa742_sync();\r\nhwa742.stop_auto_update = 0;\r\nswitch (mode) {\r\ncase OMAPFB_MANUAL_UPDATE:\r\nomapfb_notify_clients(hwa742.fbdev, OMAPFB_EVENT_READY);\r\nbreak;\r\ncase OMAPFB_AUTO_UPDATE:\r\nhwa742_update_window_auto(0);\r\nbreak;\r\ncase OMAPFB_UPDATE_DISABLED:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum omapfb_update_mode hwa742_get_update_mode(void)\r\n{\r\nreturn hwa742.update_mode;\r\n}\r\nstatic unsigned long round_to_extif_ticks(unsigned long ps, int div)\r\n{\r\nint bus_tick = hwa742.extif_clk_period * div;\r\nreturn (ps + bus_tick - 1) / bus_tick * bus_tick;\r\n}\r\nstatic int calc_reg_timing(unsigned long sysclk, int div)\r\n{\r\nstruct extif_timings *t;\r\nunsigned long systim;\r\nsystim = 1000000000 / (sysclk / 1000);\r\ndev_dbg(hwa742.fbdev->dev, "HWA742 systim %lu ps extif_clk_period %u ps"\r\n"extif_clk_div %d\n", systim, hwa742.extif_clk_period, div);\r\nt = &hwa742.reg_timings;\r\nmemset(t, 0, sizeof(*t));\r\nt->clk_div = div;\r\nt->cs_on_time = 0;\r\nt->we_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\r\nt->re_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\r\nt->access_time = round_to_extif_ticks(t->re_on_time + 12200, div);\r\nt->we_off_time = round_to_extif_ticks(t->we_on_time + 1000, div);\r\nt->re_off_time = round_to_extif_ticks(t->re_on_time + 16000, div);\r\nt->cs_off_time = round_to_extif_ticks(t->re_off_time + 1000, div);\r\nt->we_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\r\nif (t->we_cycle_time < t->we_off_time)\r\nt->we_cycle_time = t->we_off_time;\r\nt->re_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\r\nif (t->re_cycle_time < t->re_off_time)\r\nt->re_cycle_time = t->re_off_time;\r\nt->cs_pulse_width = 0;\r\ndev_dbg(hwa742.fbdev->dev, "[reg]cson %d csoff %d reon %d reoff %d\n",\r\nt->cs_on_time, t->cs_off_time, t->re_on_time, t->re_off_time);\r\ndev_dbg(hwa742.fbdev->dev, "[reg]weon %d weoff %d recyc %d wecyc %d\n",\r\nt->we_on_time, t->we_off_time, t->re_cycle_time,\r\nt->we_cycle_time);\r\ndev_dbg(hwa742.fbdev->dev, "[reg]rdaccess %d cspulse %d\n",\r\nt->access_time, t->cs_pulse_width);\r\nreturn hwa742.extif->convert_timings(t);\r\n}\r\nstatic int calc_lut_timing(unsigned long sysclk, int div)\r\n{\r\nstruct extif_timings *t;\r\nunsigned long systim;\r\nsystim = 1000000000 / (sysclk / 1000);\r\ndev_dbg(hwa742.fbdev->dev, "HWA742 systim %lu ps extif_clk_period %u ps"\r\n"extif_clk_div %d\n", systim, hwa742.extif_clk_period, div);\r\nt = &hwa742.lut_timings;\r\nmemset(t, 0, sizeof(*t));\r\nt->clk_div = div;\r\nt->cs_on_time = 0;\r\nt->we_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\r\nt->re_on_time = round_to_extif_ticks(t->cs_on_time + 2000, div);\r\nt->access_time = round_to_extif_ticks(t->re_on_time + 4 * systim +\r\n26000, div);\r\nt->we_off_time = round_to_extif_ticks(t->we_on_time + 1000, div);\r\nt->re_off_time = round_to_extif_ticks(t->re_on_time + 4 * systim +\r\n26000, div);\r\nt->cs_off_time = round_to_extif_ticks(t->re_off_time + 1000, div);\r\nt->we_cycle_time = round_to_extif_ticks(2 * systim + 2000, div);\r\nif (t->we_cycle_time < t->we_off_time)\r\nt->we_cycle_time = t->we_off_time;\r\nt->re_cycle_time = round_to_extif_ticks(2000 + 4 * systim + 26000, div);\r\nif (t->re_cycle_time < t->re_off_time)\r\nt->re_cycle_time = t->re_off_time;\r\nt->cs_pulse_width = 0;\r\ndev_dbg(hwa742.fbdev->dev, "[lut]cson %d csoff %d reon %d reoff %d\n",\r\nt->cs_on_time, t->cs_off_time, t->re_on_time, t->re_off_time);\r\ndev_dbg(hwa742.fbdev->dev, "[lut]weon %d weoff %d recyc %d wecyc %d\n",\r\nt->we_on_time, t->we_off_time, t->re_cycle_time,\r\nt->we_cycle_time);\r\ndev_dbg(hwa742.fbdev->dev, "[lut]rdaccess %d cspulse %d\n",\r\nt->access_time, t->cs_pulse_width);\r\nreturn hwa742.extif->convert_timings(t);\r\n}\r\nstatic int calc_extif_timings(unsigned long sysclk, int *extif_mem_div)\r\n{\r\nint max_clk_div;\r\nint div;\r\nhwa742.extif->get_clk_info(&hwa742.extif_clk_period, &max_clk_div);\r\nfor (div = 1; div < max_clk_div; div++) {\r\nif (calc_reg_timing(sysclk, div) == 0)\r\nbreak;\r\n}\r\nif (div >= max_clk_div)\r\ngoto err;\r\n*extif_mem_div = div;\r\nfor (div = 1; div < max_clk_div; div++) {\r\nif (calc_lut_timing(sysclk, div) == 0)\r\nbreak;\r\n}\r\nif (div >= max_clk_div)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_err(hwa742.fbdev->dev, "can't setup timings\n");\r\nreturn -1;\r\n}\r\nstatic void calc_hwa742_clk_rates(unsigned long ext_clk,\r\nunsigned long *sys_clk, unsigned long *pix_clk)\r\n{\r\nint pix_clk_src;\r\nint sys_div = 0, sys_mul = 0;\r\nint pix_div;\r\npix_clk_src = hwa742_read_reg(HWA742_CLK_SRC_REG);\r\npix_div = ((pix_clk_src >> 3) & 0x1f) + 1;\r\nif ((pix_clk_src & (0x3 << 1)) == 0) {\r\nsys_div = (hwa742_read_reg(HWA742_PLL_DIV_REG) & 0x3f) + 1;\r\nsys_mul = (hwa742_read_reg(HWA742_PLL_4_REG) & 0x7f) + 1;\r\n*sys_clk = ext_clk * sys_mul / sys_div;\r\n} else\r\n*sys_clk = ext_clk;\r\n*pix_clk = *sys_clk / pix_div;\r\ndev_dbg(hwa742.fbdev->dev,\r\n"ext_clk %ld pix_src %d pix_div %d sys_div %d sys_mul %d\n",\r\next_clk, pix_clk_src & (0x3 << 1), pix_div, sys_div, sys_mul);\r\ndev_dbg(hwa742.fbdev->dev, "sys_clk %ld pix_clk %ld\n",\r\n*sys_clk, *pix_clk);\r\n}\r\nstatic int setup_tearsync(unsigned long pix_clk, int extif_div)\r\n{\r\nint hdisp, vdisp;\r\nint hndp, vndp;\r\nint hsw, vsw;\r\nint hs, vs;\r\nint hs_pol_inv, vs_pol_inv;\r\nint use_hsvs, use_ndp;\r\nu8 b;\r\nhsw = hwa742_read_reg(HWA742_HS_W_REG);\r\nvsw = hwa742_read_reg(HWA742_VS_W_REG);\r\nhs_pol_inv = !(hsw & 0x80);\r\nvs_pol_inv = !(vsw & 0x80);\r\nhsw = hsw & 0x7f;\r\nvsw = vsw & 0x3f;\r\nhdisp = (hwa742_read_reg(HWA742_H_DISP_REG) & 0x7f) * 8;\r\nvdisp = hwa742_read_reg(HWA742_V_DISP_1_REG) +\r\n((hwa742_read_reg(HWA742_V_DISP_2_REG) & 0x3) << 8);\r\nhndp = hwa742_read_reg(HWA742_H_NDP_REG) & 0x7f;\r\nvndp = hwa742_read_reg(HWA742_V_NDP_REG);\r\nhwa742.pix_tx_time = hwa742.reg_timings.we_cycle_time;\r\nif (hwa742.extif->get_max_tx_rate != NULL) {\r\nunsigned long min_tx_time;\r\nunsigned long max_tx_rate = hwa742.extif->get_max_tx_rate();\r\ndev_dbg(hwa742.fbdev->dev, "max_tx_rate %ld HZ\n",\r\nmax_tx_rate);\r\nmin_tx_time = 1000000000 / (max_tx_rate / 1000);\r\nif (hwa742.pix_tx_time < min_tx_time)\r\nhwa742.pix_tx_time = min_tx_time;\r\n}\r\nhwa742.line_upd_time = (hdisp + hndp) * 1000000 / (pix_clk / 1000);\r\nhwa742.line_upd_time *= 1000;\r\nif (hdisp * hwa742.pix_tx_time > hwa742.line_upd_time)\r\nuse_hsvs = 1;\r\nelse\r\nuse_hsvs = 0;\r\nif (use_hsvs && (hs_pol_inv || vs_pol_inv)) {\r\nuse_ndp = 1;\r\nhs_pol_inv = 0;\r\nvs_pol_inv = 0;\r\nhs = hndp;\r\nvs = vndp;\r\n} else {\r\nuse_ndp = 0;\r\nhs = hsw;\r\nvs = vsw;\r\nif (!use_hsvs) {\r\nhs_pol_inv = 0;\r\nvs_pol_inv = 0;\r\n}\r\n}\r\nhs = hs * 1000000 / (pix_clk / 1000);\r\nhs *= 1000;\r\nvs = vs * (hdisp + hndp) * 1000000 / (pix_clk / 1000);\r\nvs *= 1000;\r\nif (vs <= hs)\r\nreturn -EDOM;\r\nvs = hs * 12 / 10;\r\nhs = 10000;\r\nb = hwa742_read_reg(HWA742_NDP_CTRL);\r\nb &= ~0x3;\r\nb |= use_hsvs ? 1 : 0;\r\nb |= (use_ndp && use_hsvs) ? 0 : 2;\r\nhwa742_write_reg(HWA742_NDP_CTRL, b);\r\nhwa742.vsync_only = !use_hsvs;\r\ndev_dbg(hwa742.fbdev->dev,\r\n"pix_clk %ld HZ pix_tx_time %ld ps line_upd_time %ld ps\n",\r\npix_clk, hwa742.pix_tx_time, hwa742.line_upd_time);\r\ndev_dbg(hwa742.fbdev->dev,\r\n"hs %d ps vs %d ps mode %d vsync_only %d\n",\r\nhs, vs, (b & 0x3), !use_hsvs);\r\nreturn hwa742.extif->setup_tearsync(1, hs, vs,\r\nhs_pol_inv, vs_pol_inv, extif_div);\r\n}\r\nstatic void hwa742_get_caps(int plane, struct omapfb_caps *caps)\r\n{\r\nhwa742.int_ctrl->get_caps(plane, caps);\r\ncaps->ctrl |= OMAPFB_CAPS_MANUAL_UPDATE |\r\nOMAPFB_CAPS_WINDOW_PIXEL_DOUBLE;\r\nif (hwa742.te_connected)\r\ncaps->ctrl |= OMAPFB_CAPS_TEARSYNC;\r\ncaps->wnd_color |= (1 << OMAPFB_COLOR_RGB565) |\r\n(1 << OMAPFB_COLOR_YUV420);\r\n}\r\nstatic void hwa742_suspend(void)\r\n{\r\nhwa742.update_mode_before_suspend = hwa742.update_mode;\r\nhwa742_set_update_mode(OMAPFB_UPDATE_DISABLED);\r\nhwa742_write_reg(HWA742_POWER_SAVE, 1 << 1);\r\nclk_disable(hwa742.sys_ck);\r\n}\r\nstatic void hwa742_resume(void)\r\n{\r\nclk_enable(hwa742.sys_ck);\r\nhwa742_write_reg(HWA742_POWER_SAVE, 0);\r\nwhile (1) {\r\nif (hwa742_read_reg(HWA742_PLL_DIV_REG) & (1 << 7))\r\nbreak;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(5));\r\n}\r\nhwa742_set_update_mode(hwa742.update_mode_before_suspend);\r\n}\r\nstatic int hwa742_init(struct omapfb_device *fbdev, int ext_mode,\r\nstruct omapfb_mem_desc *req_vram)\r\n{\r\nint r = 0, i;\r\nu8 rev, conf;\r\nunsigned long ext_clk;\r\nunsigned long sys_clk, pix_clk;\r\nint extif_mem_div;\r\nstruct omapfb_platform_data *omapfb_conf;\r\nBUG_ON(!fbdev->ext_if || !fbdev->int_ctrl);\r\nhwa742.fbdev = fbdev;\r\nhwa742.extif = fbdev->ext_if;\r\nhwa742.int_ctrl = fbdev->int_ctrl;\r\nomapfb_conf = dev_get_platdata(fbdev->dev);\r\nhwa742.sys_ck = clk_get(NULL, "hwa_sys_ck");\r\nspin_lock_init(&hwa742.req_lock);\r\nif ((r = hwa742.int_ctrl->init(fbdev, 1, req_vram)) < 0)\r\ngoto err1;\r\nif ((r = hwa742.extif->init(fbdev)) < 0)\r\ngoto err2;\r\next_clk = clk_get_rate(hwa742.sys_ck);\r\nif ((r = calc_extif_timings(ext_clk, &extif_mem_div)) < 0)\r\ngoto err3;\r\nhwa742.extif->set_timings(&hwa742.reg_timings);\r\nclk_enable(hwa742.sys_ck);\r\ncalc_hwa742_clk_rates(ext_clk, &sys_clk, &pix_clk);\r\nif ((r = calc_extif_timings(sys_clk, &extif_mem_div)) < 0)\r\ngoto err4;\r\nhwa742.extif->set_timings(&hwa742.reg_timings);\r\nrev = hwa742_read_reg(HWA742_REV_CODE_REG);\r\nif ((rev & 0xfc) != 0x80) {\r\ndev_err(fbdev->dev, "HWA742: invalid revision %02x\n", rev);\r\nr = -ENODEV;\r\ngoto err4;\r\n}\r\nif (!(hwa742_read_reg(HWA742_PLL_DIV_REG) & 0x80)) {\r\ndev_err(fbdev->dev,\r\n"HWA742: controller not initialized by the bootloader\n");\r\nr = -ENODEV;\r\ngoto err4;\r\n}\r\nif ((r = setup_tearsync(pix_clk, extif_mem_div)) < 0) {\r\ndev_err(hwa742.fbdev->dev,\r\n"HWA742: can't setup tearing synchronization\n");\r\ngoto err4;\r\n}\r\nhwa742.te_connected = 1;\r\nhwa742.max_transmit_size = hwa742.extif->max_transmit_size;\r\nhwa742.update_mode = OMAPFB_UPDATE_DISABLED;\r\nhwa742.auto_update_window.x = 0;\r\nhwa742.auto_update_window.y = 0;\r\nhwa742.auto_update_window.width = fbdev->panel->x_res;\r\nhwa742.auto_update_window.height = fbdev->panel->y_res;\r\nhwa742.auto_update_window.format = 0;\r\ninit_timer(&hwa742.auto_update_timer);\r\nhwa742.auto_update_timer.function = hwa742_update_window_auto;\r\nhwa742.auto_update_timer.data = 0;\r\nhwa742.prev_color_mode = -1;\r\nhwa742.prev_flags = 0;\r\nhwa742.fbdev = fbdev;\r\nINIT_LIST_HEAD(&hwa742.free_req_list);\r\nINIT_LIST_HEAD(&hwa742.pending_req_list);\r\nfor (i = 0; i < ARRAY_SIZE(hwa742.req_pool); i++)\r\nlist_add(&hwa742.req_pool[i].entry, &hwa742.free_req_list);\r\nBUG_ON(i <= IRQ_REQ_POOL_SIZE);\r\nsema_init(&hwa742.req_sema, i - IRQ_REQ_POOL_SIZE);\r\nconf = hwa742_read_reg(HWA742_CONFIG_REG);\r\ndev_info(fbdev->dev, ": Epson HWA742 LCD controller rev %d "\r\n"initialized (CNF pins %x)\n", rev & 0x03, conf & 0x07);\r\nreturn 0;\r\nerr4:\r\nclk_disable(hwa742.sys_ck);\r\nerr3:\r\nhwa742.extif->cleanup();\r\nerr2:\r\nhwa742.int_ctrl->cleanup();\r\nerr1:\r\nreturn r;\r\n}\r\nstatic void hwa742_cleanup(void)\r\n{\r\nhwa742_set_update_mode(OMAPFB_UPDATE_DISABLED);\r\nhwa742.extif->cleanup();\r\nhwa742.int_ctrl->cleanup();\r\nclk_disable(hwa742.sys_ck);\r\n}
