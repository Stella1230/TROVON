static void aafb_set_cursor(struct aafb_info *info, int on)\r\n{\r\nstruct aafb_cursor *c = &info->cursor;\r\nif (on) {\r\nbt431_position_cursor(info->bt431, c->x, c->y);\r\nbt431_enable_cursor(info->bt431);\r\n} else\r\nbt431_erase_cursor(info->bt431);\r\n}\r\nstatic void aafbcon_cursor(struct display *disp, int mode, int x, int y)\r\n{\r\nstruct aafb_info *info = (struct aafb_info *)disp->fb_info;\r\nstruct aafb_cursor *c = &info->cursor;\r\nx *= fontwidth(disp);\r\ny *= fontheight(disp);\r\nif (c->x == x && c->y == y && (mode == CM_ERASE) == !c->enable)\r\nreturn;\r\nc->enable = 0;\r\nif (c->on)\r\naafb_set_cursor(info, 0);\r\nc->x = x - disp->var.xoffset;\r\nc->y = y - disp->var.yoffset;\r\nswitch (mode) {\r\ncase CM_ERASE:\r\nc->on = 0;\r\nbreak;\r\ncase CM_DRAW:\r\ncase CM_MOVE:\r\nif (c->on)\r\naafb_set_cursor(info, c->on);\r\nelse\r\nc->vbl_cnt = CURSOR_DRAW_DELAY;\r\nc->enable = 1;\r\nbreak;\r\n}\r\n}\r\nstatic int aafbcon_set_font(struct display *disp, int width, int height)\r\n{\r\nstruct aafb_info *info = (struct aafb_info *)disp->fb_info;\r\nstruct aafb_cursor *c = &info->cursor;\r\nu8 fgc = ~attr_bgcol_ec(disp, disp->conp, &info->info);\r\nif (width > 64 || height > 64 || width < 0 || height < 0)\r\nreturn -EINVAL;\r\nc->height = height;\r\nc->width = width;\r\nbt431_set_font(info->bt431, fgc, width, height);\r\nreturn 1;\r\n}\r\nstatic void aafb_cursor_timer_handler(unsigned long data)\r\n{\r\nstruct aafb_info *info = (struct aafb_info *)data;\r\nstruct aafb_cursor *c = &info->cursor;\r\nif (!c->enable)\r\ngoto out;\r\nif (c->vbl_cnt && --c->vbl_cnt == 0) {\r\nc->on ^= 1;\r\naafb_set_cursor(info, c->on);\r\nc->vbl_cnt = c->blink_rate;\r\n}\r\nout:\r\nc->timer.expires = jiffies + CURSOR_TIMER_FREQ;\r\nadd_timer(&c->timer);\r\n}\r\nstatic void __init aafb_cursor_init(struct aafb_info *info)\r\n{\r\nstruct aafb_cursor *c = &info->cursor;\r\nc->enable = 1;\r\nc->on = 1;\r\nc->x = c->y = 0;\r\nc->width = c->height = 0;\r\nc->vbl_cnt = CURSOR_DRAW_DELAY;\r\nc->blink_rate = CURSOR_BLINK_RATE;\r\ninit_timer(&c->timer);\r\nc->timer.data = (unsigned long)info;\r\nc->timer.function = aafb_cursor_timer_handler;\r\nmod_timer(&c->timer, jiffies + CURSOR_TIMER_FREQ);\r\n}\r\nstatic void __exit aafb_cursor_exit(struct aafb_info *info)\r\n{\r\nstruct aafb_cursor *c = &info->cursor;\r\ndel_timer_sync(&c->timer);\r\n}\r\nstatic void aafb_get_par(struct aafb_par *par)\r\n{\r\n*par = current_par;\r\n}\r\nstatic int aafb_get_fix(struct fb_fix_screeninfo *fix, int con,\r\nstruct fb_info *info)\r\n{\r\nstruct aafb_info *ip = (struct aafb_info *)info;\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrcpy(fix->id, "PMAG-AA");\r\nfix->smem_start = ip->fb_start;\r\nfix->smem_len = ip->fb_size;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 1;\r\nfix->visual = FB_VISUAL_MONO10;\r\nfix->line_length = 1280;\r\nfix->accel = FB_ACCEL_NONE;\r\nreturn 0;\r\n}\r\nstatic void aafb_set_disp(struct display *disp, int con,\r\nstruct aafb_info *info)\r\n{\r\nstruct fb_fix_screeninfo fix;\r\ndisp->fb_info = &info->info;\r\naafb_set_var(&disp->var, con, &info->info);\r\nif (disp->conp && disp->conp->vc_sw && disp->conp->vc_sw->con_cursor)\r\ndisp->conp->vc_sw->con_cursor(disp->conp, CM_ERASE);\r\ndisp->dispsw = &aafb_switch8;\r\ndisp->dispsw_data = 0;\r\naafb_get_fix(&fix, con, &info->info);\r\ndisp->screen_base = (u8 *) fix.smem_start;\r\ndisp->visual = fix.visual;\r\ndisp->type = fix.type;\r\ndisp->type_aux = fix.type_aux;\r\ndisp->ypanstep = fix.ypanstep;\r\ndisp->ywrapstep = fix.ywrapstep;\r\ndisp->line_length = fix.line_length;\r\ndisp->next_line = 2048;\r\ndisp->can_soft_blank = 1;\r\ndisp->inverse = 0;\r\ndisp->scrollmode = SCROLL_YREDRAW;\r\naafbcon_set_font(disp, fontwidth(disp), fontheight(disp));\r\n}\r\nstatic int aafb_get_cmap(struct fb_cmap *cmap, int kspc, int con,\r\nstruct fb_info *info)\r\n{\r\nstatic u16 color[2] = {0x0000, 0x000f};\r\nstatic struct fb_cmap aafb_cmap = {0, 2, color, color, color, NULL};\r\nfb_copy_cmap(&aafb_cmap, cmap, kspc ? 0 : 2);\r\nreturn 0;\r\n}\r\nstatic int aafb_set_cmap(struct fb_cmap *cmap, int kspc, int con,\r\nstruct fb_info *info)\r\n{\r\nu16 color[2] = {0x0000, 0x000f};\r\nif (cmap->start == 0\r\n&& cmap->len == 2\r\n&& memcmp(cmap->red, color, sizeof(color)) == 0\r\n&& memcmp(cmap->green, color, sizeof(color)) == 0\r\n&& memcmp(cmap->blue, color, sizeof(color)) == 0\r\n&& cmap->transp == NULL)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int aafb_ioctl(struct fb_info *info, u32 cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int aafb_switch(int con, struct fb_info *info)\r\n{\r\nstruct aafb_info *ip = (struct aafb_info *)info;\r\nstruct display *old = (currcon < 0) ? &ip->disp : (fb_display + currcon);\r\nstruct display *new = (con < 0) ? &ip->disp : (fb_display + con);\r\nif (old->conp && old->conp->vc_sw && old->conp->vc_sw->con_cursor)\r\nold->conp->vc_sw->con_cursor(old->conp, CM_ERASE);\r\ncurrcon = con;\r\naafb_set_disp(new, con, ip);\r\nreturn 0;\r\n}\r\nstatic void aafb_encode_var(struct fb_var_screeninfo *var,\r\nstruct aafb_par *par)\r\n{\r\nvar->xres = 1280;\r\nvar->yres = 1024;\r\nvar->xres_virtual = 2048;\r\nvar->yres_virtual = 1024;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->bits_per_pixel = 8;\r\nvar->grayscale = 1;\r\nvar->red.offset = 0;\r\nvar->red.length = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.offset = 0;\r\nvar->green.length = 1;\r\nvar->green.msb_right = 0;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->nonstd = 0;\r\nvar->activate &= ~FB_ACTIVATE_MASK & FB_ACTIVATE_NOW;\r\nvar->accel_flags = 0;\r\nvar->sync = FB_SYNC_ON_GREEN;\r\nvar->vmode &= ~FB_VMODE_MASK & FB_VMODE_NONINTERLACED;\r\n}\r\nstatic int aafb_get_var(struct fb_var_screeninfo *var, int con,\r\nstruct fb_info *info)\r\n{\r\nif (con < 0) {\r\nstruct aafb_par par;\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\naafb_get_par(&par);\r\naafb_encode_var(var, &par);\r\n} else\r\n*var = info->var;\r\nreturn 0;\r\n}\r\nstatic int aafb_set_var(struct fb_var_screeninfo *var, int con,\r\nstruct fb_info *info)\r\n{\r\nstruct aafb_par par;\r\naafb_get_par(&par);\r\naafb_encode_var(var, &par);\r\ninfo->var = *var;\r\nreturn 0;\r\n}\r\nstatic int aafb_update_var(int con, struct fb_info *info)\r\n{\r\nstruct aafb_info *ip = (struct aafb_info *)info;\r\nstruct display *disp = (con < 0) ? &ip->disp : (fb_display + con);\r\nif (con == currcon)\r\naafbcon_cursor(disp, CM_ERASE, ip->cursor.x, ip->cursor.y);\r\nreturn 0;\r\n}\r\nstatic void aafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct aafb_info *ip = (struct aafb_info *)info;\r\nu8 val = blank ? 0x00 : 0x0f;\r\nbt455_write_cmap_entry(ip->bt455, 1, val, val, val);\r\naafbcon_cursor(&ip->disp, CM_ERASE, ip->cursor.x, ip->cursor.y);\r\n}\r\nstatic int __init init_one(int slot)\r\n{\r\nunsigned long base_addr = CKSEG1ADDR(get_tc_base_addr(slot));\r\nstruct aafb_info *ip = &my_fb_info[slot];\r\nmemset(ip, 0, sizeof(struct aafb_info));\r\nip->bt455 = (struct bt455_regs *) (base_addr + PMAG_AA_BT455_OFFSET);\r\nip->bt431 = (struct bt431_regs *) (base_addr + PMAG_AA_BT431_OFFSET);\r\nip->fb_start = base_addr + PMAG_AA_ONBOARD_FBMEM_OFFSET;\r\nip->fb_size = 2048 * 1024;\r\nip->fb_line_length = 2048;\r\nstrcpy(ip->info.modename, "PMAG-AA");\r\nip->info.node = -1;\r\nip->info.flags = FBINFO_FLAG_DEFAULT;\r\nip->info.fbops = &aafb_ops;\r\nip->info.disp = &ip->disp;\r\nip->info.changevar = NULL;\r\nip->info.switch_con = &aafb_switch;\r\nip->info.updatevar = &aafb_update_var;\r\nip->info.blank = &aafb_blank;\r\naafb_set_disp(&ip->disp, currcon, ip);\r\nbt455_erase_cursor(ip->bt455);\r\nbt455_write_cmap_entry(ip->bt455, 0, 0x00, 0x00, 0x00);\r\nbt455_write_cmap_entry(ip->bt455, 1, 0x0f, 0x0f, 0x0f);\r\nbt431_init_cursor(ip->bt431);\r\naafb_cursor_init(ip);\r\nmemset ((void *)ip->fb_start, 0, ip->fb_size);\r\nif (register_framebuffer(&ip->info) < 0)\r\nreturn -EINVAL;\r\nprintk(KERN_INFO "fb%d: %s frame buffer in TC slot %d\n",\r\nGET_FB_IDX(ip->info.node), ip->info.modename, slot);\r\nreturn 0;\r\n}\r\nstatic int __exit exit_one(int slot)\r\n{\r\nstruct aafb_info *ip = &my_fb_info[slot];\r\nif (unregister_framebuffer(&ip->info) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint __init pmagaafb_init(void)\r\n{\r\nint sid;\r\nint found = 0;\r\nwhile ((sid = search_tc_card("PMAG-AA")) >= 0) {\r\nfound = 1;\r\nclaim_tc_card(sid);\r\ninit_one(sid);\r\n}\r\nreturn found ? 0 : -ENXIO;\r\n}\r\nstatic void __exit pmagaafb_exit(void)\r\n{\r\nint sid;\r\nwhile ((sid = search_tc_card("PMAG-AA")) >= 0) {\r\nexit_one(sid);\r\nrelease_tc_card(sid);\r\n}\r\n}
