static int rds_waitread(struct snd_miro_aci *aci)\r\n{\r\nu8 byte;\r\nint i = 2000;\r\ndo {\r\nbyte = inb(aci->aci_port + ACI_REG_RDS);\r\ni--;\r\n} while ((byte & RDS_BUSYMASK) && i);\r\nudelay(1);\r\nreturn i ? byte : -1;\r\n}\r\nstatic int rds_rawwrite(struct snd_miro_aci *aci, u8 byte)\r\n{\r\nif (rds_waitread(aci) >= 0) {\r\noutb(byte, aci->aci_port + ACI_REG_RDS);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int rds_write(struct snd_miro_aci *aci, u8 byte)\r\n{\r\nu8 sendbuffer[8];\r\nint i;\r\nfor (i = 7; i >= 0; i--)\r\nsendbuffer[7 - i] = (byte & (1 << i)) ? RDS_DATAMASK : 0;\r\nsendbuffer[0] |= RDS_CLOCKMASK;\r\nfor (i = 0; i < 8; i++)\r\nrds_rawwrite(aci, sendbuffer[i]);\r\nreturn 0;\r\n}\r\nstatic int rds_readcycle_nowait(struct snd_miro_aci *aci)\r\n{\r\noutb(0, aci->aci_port + ACI_REG_RDS);\r\nreturn rds_waitread(aci);\r\n}\r\nstatic int rds_readcycle(struct snd_miro_aci *aci)\r\n{\r\nif (rds_rawwrite(aci, 0) < 0)\r\nreturn -1;\r\nreturn rds_waitread(aci);\r\n}\r\nstatic int rds_ack(struct snd_miro_aci *aci)\r\n{\r\nint i = rds_readcycle(aci);\r\nif (i < 0)\r\nreturn -1;\r\nif (i & RDS_DATAMASK)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int rds_cmd(struct snd_miro_aci *aci, u8 cmd, u8 databuffer[], u8 datasize)\r\n{\r\nint i, j;\r\nrds_write(aci, cmd);\r\nif (cmd == RDS_RESET)\r\nreturn 0;\r\nif (rds_ack(aci))\r\nreturn -EIO;\r\nif (datasize == 0)\r\nreturn 0;\r\nif (rds_waitread(aci) < 0)\r\nreturn -1;\r\nmemset(databuffer, 0, datasize);\r\nfor (i = 0; i < 8 * datasize; i++) {\r\nj = rds_readcycle_nowait(aci);\r\nif (j < 0)\r\nreturn -EIO;\r\ndatabuffer[i / 8] |= RDS_DATA(j) << (7 - (i % 8));\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm20_setfreq(struct pcm20 *dev, unsigned long freq)\r\n{\r\nunsigned char freql;\r\nunsigned char freqh;\r\nstruct snd_miro_aci *aci = dev->aci;\r\nfreq /= 160;\r\nif (!(aci->aci_version == 0x07 || aci->aci_version >= 0xb0))\r\nfreq /= 10;\r\nfreql = freq & 0xff;\r\nfreqh = freq >> 8;\r\nrds_cmd(aci, RDS_RESET, NULL, 0);\r\nreturn snd_aci_cmd(aci, ACI_WRITE_TUNE, freql, freqh);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nstrlcpy(v->driver, "Miro PCM20", sizeof(v->driver));\r\nstrlcpy(v->card, "Miro PCM20", sizeof(v->card));\r\nsnprintf(v->bus_info, sizeof(v->bus_info), "ISA:%s", dev->v4l2_dev.name);\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic bool sanitize(char *p, int size)\r\n{\r\nint i;\r\nbool ret = true;\r\nfor (i = 0; i < size; i++) {\r\nif (p[i] < 32) {\r\np[i] = ' ';\r\nret = false;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nint res;\r\nu8 buf;\r\nif (v->index)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = 87*16000;\r\nv->rangehigh = 108*16000;\r\nres = snd_aci_cmd(dev->aci, ACI_READ_TUNERSTATION, -1, -1);\r\nv->signal = (res & 0x80) ? 0 : 0xffff;\r\nres = snd_aci_cmd(dev->aci, ACI_READ_TUNERSTEREO, -1, -1);\r\nv->rxsubchans = (res & 0x40) ? V4L2_TUNER_SUB_MONO :\r\nV4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_CONTROLS;\r\nv->audmode = dev->audmode;\r\nres = rds_cmd(dev->aci, RDS_RXVALUE, &buf, 1);\r\nif (res >= 0 && buf)\r\nv->rxsubchans |= V4L2_TUNER_SUB_RDS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nif (v->index)\r\nreturn -EINVAL;\r\nif (v->audmode > V4L2_TUNER_MODE_STEREO)\r\ndev->audmode = V4L2_TUNER_MODE_STEREO;\r\nelse\r\ndev->audmode = v->audmode;\r\nsnd_aci_cmd(dev->aci, ACI_SET_TUNERMONO,\r\ndev->audmode == V4L2_TUNER_MODE_MONO, -1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = dev->freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\ndev->freq = clamp_t(u32, f->frequency, 87 * 16000U, 108 * 16000U);\r\npcm20_setfreq(dev, dev->freq);\r\nreturn 0;\r\n}\r\nstatic int pcm20_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct pcm20 *dev = container_of(ctrl->handler, struct pcm20, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nsnd_aci_cmd(dev->aci, ACI_SET_TUNERMUTE, ctrl->val, -1);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pcm20_thread(void *data)\r\n{\r\nstruct pcm20 *dev = data;\r\nconst unsigned no_rds_start_counter = 5;\r\nconst unsigned sleep_msecs = 2000;\r\nunsigned no_rds_counter = no_rds_start_counter;\r\nfor (;;) {\r\nchar text_buffer[66];\r\nu8 buf;\r\nint res;\r\nmsleep_interruptible(sleep_msecs);\r\nif (kthread_should_stop())\r\nbreak;\r\nres = rds_cmd(dev->aci, RDS_RXVALUE, &buf, 1);\r\nif (res)\r\ncontinue;\r\nif (buf == 0) {\r\nif (no_rds_counter == 0)\r\ncontinue;\r\nno_rds_counter--;\r\nif (no_rds_counter)\r\ncontinue;\r\nv4l2_ctrl_s_ctrl_string(dev->rds_ps_name, "");\r\nv4l2_ctrl_s_ctrl(dev->rds_ms, 1);\r\nv4l2_ctrl_s_ctrl(dev->rds_ta, 0);\r\nv4l2_ctrl_s_ctrl(dev->rds_tp, 0);\r\nv4l2_ctrl_s_ctrl(dev->rds_pty, 0);\r\nv4l2_ctrl_s_ctrl_string(dev->rds_radio_test, "");\r\ncontinue;\r\n}\r\nno_rds_counter = no_rds_start_counter;\r\nres = rds_cmd(dev->aci, RDS_STATUS, &buf, 1);\r\nif (res)\r\ncontinue;\r\nif ((buf >> 3) & 1) {\r\nres = rds_cmd(dev->aci, RDS_STATIONNAME, text_buffer, 8);\r\ntext_buffer[8] = 0;\r\nif (!res && sanitize(text_buffer, 8))\r\nv4l2_ctrl_s_ctrl_string(dev->rds_ps_name, text_buffer);\r\n}\r\nif ((buf >> 6) & 1) {\r\nu8 pty;\r\nres = rds_cmd(dev->aci, RDS_PTYTATP, &pty, 1);\r\nif (!res) {\r\nv4l2_ctrl_s_ctrl(dev->rds_ms, !!(pty & 0x01));\r\nv4l2_ctrl_s_ctrl(dev->rds_ta, !!(pty & 0x02));\r\nv4l2_ctrl_s_ctrl(dev->rds_tp, !!(pty & 0x80));\r\nv4l2_ctrl_s_ctrl(dev->rds_pty, (pty >> 2) & 0x1f);\r\n}\r\n}\r\nif ((buf >> 4) & 1) {\r\nres = rds_cmd(dev->aci, RDS_TEXT, text_buffer, 65);\r\ntext_buffer[65] = 0;\r\nif (!res && sanitize(text_buffer + 1, 64))\r\nv4l2_ctrl_s_ctrl_string(dev->rds_radio_test, text_buffer + 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm20_open(struct file *file)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nint res = v4l2_fh_open(file);\r\nif (!res && v4l2_fh_is_singular_file(file) &&\r\nIS_ERR_OR_NULL(dev->kthread)) {\r\ndev->kthread = kthread_run(pcm20_thread, dev, "%s",\r\ndev->v4l2_dev.name);\r\nif (IS_ERR(dev->kthread)) {\r\nv4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");\r\nv4l2_fh_release(file);\r\nreturn PTR_ERR(dev->kthread);\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int pcm20_release(struct file *file)\r\n{\r\nstruct pcm20 *dev = video_drvdata(file);\r\nif (v4l2_fh_is_singular_file(file) && !IS_ERR_OR_NULL(dev->kthread)) {\r\nkthread_stop(dev->kthread);\r\ndev->kthread = NULL;\r\n}\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic int __init pcm20_init(void)\r\n{\r\nstruct pcm20 *dev = &pcm20_card;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint res;\r\ndev->aci = snd_aci_get_aci();\r\nif (dev->aci == NULL) {\r\nv4l2_err(v4l2_dev,\r\n"you must load the snd-miro driver first!\n");\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(v4l2_dev->name, "radio-miropcm20", sizeof(v4l2_dev->name));\r\nmutex_init(&dev->lock);\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "could not register v4l2_device\n");\r\nreturn -EINVAL;\r\n}\r\nhdl = &dev->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 7);\r\nv4l2_ctrl_new_std(hdl, &pcm20_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\ndev->rds_pty = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_PTY, 0, 0x1f, 1, 0);\r\ndev->rds_ps_name = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_PS_NAME, 0, 8, 8, 0);\r\ndev->rds_radio_test = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_RADIO_TEXT, 0, 64, 64, 0);\r\ndev->rds_ta = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT, 0, 1, 1, 0);\r\ndev->rds_tp = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_TRAFFIC_PROGRAM, 0, 1, 1, 0);\r\ndev->rds_ms = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_RDS_RX_MUSIC_SPEECH, 0, 1, 1, 1);\r\nv4l2_dev->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nres = hdl->error;\r\nv4l2_err(v4l2_dev, "Could not register control\n");\r\ngoto err_hdl;\r\n}\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &pcm20_fops;\r\ndev->vdev.ioctl_ops = &pcm20_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\ndev->vdev.lock = &dev->lock;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nsnd_aci_cmd(dev->aci, ACI_SET_TUNERMONO,\r\ndev->audmode == V4L2_TUNER_MODE_MONO, -1);\r\npcm20_setfreq(dev, dev->freq);\r\nif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0)\r\ngoto err_hdl;\r\nv4l2_info(v4l2_dev, "Mirosound PCM20 Radio tuner\n");\r\nreturn 0;\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(v4l2_dev);\r\nreturn -EINVAL;\r\n}\r\nstatic void __exit pcm20_cleanup(void)\r\n{\r\nstruct pcm20 *dev = &pcm20_card;\r\nvideo_unregister_device(&dev->vdev);\r\nsnd_aci_cmd(dev->aci, ACI_SET_TUNERMUTE, 1, -1);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\n}
