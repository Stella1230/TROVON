static void appledisplay_complete(struct urb *urb)\r\n{\r\nstruct appledisplay *pdata = urb->context;\r\nstruct device *dev = &pdata->udev->dev;\r\nunsigned long flags;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev_err(dev,\r\n"OVERFLOW with data length %d, actual length is %d\n",\r\nACD_URB_BUFFER_LEN, pdata->urb->actual_length);\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shuttingdown with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nspin_lock_irqsave(&pdata->lock, flags);\r\nswitch(pdata->urbdata[1]) {\r\ncase ACD_BTN_BRIGHT_UP:\r\ncase ACD_BTN_BRIGHT_DOWN:\r\npdata->button_pressed = 1;\r\nqueue_delayed_work(wq, &pdata->work, 0);\r\nbreak;\r\ncase ACD_BTN_NONE:\r\ndefault:\r\npdata->button_pressed = 0;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pdata->lock, flags);\r\nexit:\r\nretval = usb_submit_urb(pdata->urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\n}\r\nstatic int appledisplay_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct appledisplay *pdata = bl_get_data(bd);\r\nint retval;\r\nmutex_lock(&pdata->sysfslock);\r\npdata->msgdata[0] = 0x10;\r\npdata->msgdata[1] = bd->props.brightness;\r\nretval = usb_control_msg(\r\npdata->udev,\r\nusb_sndctrlpipe(pdata->udev, 0),\r\nUSB_REQ_SET_REPORT,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nACD_USB_BRIGHTNESS,\r\n0,\r\npdata->msgdata, 2,\r\nACD_USB_TIMEOUT);\r\nmutex_unlock(&pdata->sysfslock);\r\nreturn retval;\r\n}\r\nstatic int appledisplay_bl_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct appledisplay *pdata = bl_get_data(bd);\r\nint retval, brightness;\r\nmutex_lock(&pdata->sysfslock);\r\nretval = usb_control_msg(\r\npdata->udev,\r\nusb_rcvctrlpipe(pdata->udev, 0),\r\nUSB_REQ_GET_REPORT,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nACD_USB_BRIGHTNESS,\r\n0,\r\npdata->msgdata, 2,\r\nACD_USB_TIMEOUT);\r\nbrightness = pdata->msgdata[1];\r\nmutex_unlock(&pdata->sysfslock);\r\nif (retval < 0)\r\nreturn retval;\r\nelse\r\nreturn brightness;\r\n}\r\nstatic void appledisplay_work(struct work_struct *work)\r\n{\r\nstruct appledisplay *pdata =\r\ncontainer_of(work, struct appledisplay, work.work);\r\nint retval;\r\nretval = appledisplay_bl_get_brightness(pdata->bd);\r\nif (retval >= 0)\r\npdata->bd->props.brightness = retval;\r\nif (pdata->button_pressed)\r\nschedule_delayed_work(&pdata->work, HZ / 8);\r\n}\r\nstatic int appledisplay_probe(struct usb_interface *iface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct backlight_properties props;\r\nstruct appledisplay *pdata;\r\nstruct usb_device *udev = interface_to_usbdev(iface);\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint int_in_endpointAddr = 0;\r\nint i, retval = -ENOMEM, brightness;\r\nchar bl_name[20];\r\niface_desc = iface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!int_in_endpointAddr && usb_endpoint_is_int_in(endpoint)) {\r\nint_in_endpointAddr = endpoint->bEndpointAddress;\r\nbreak;\r\n}\r\n}\r\nif (!int_in_endpointAddr) {\r\ndev_err(&iface->dev, "Could not find int-in endpoint\n");\r\nreturn -EIO;\r\n}\r\npdata = kzalloc(sizeof(struct appledisplay), GFP_KERNEL);\r\nif (!pdata) {\r\nretval = -ENOMEM;\r\ndev_err(&iface->dev, "Out of memory\n");\r\ngoto error;\r\n}\r\npdata->udev = udev;\r\nspin_lock_init(&pdata->lock);\r\nINIT_DELAYED_WORK(&pdata->work, appledisplay_work);\r\nmutex_init(&pdata->sysfslock);\r\npdata->msgdata = kmalloc(ACD_MSG_BUFFER_LEN, GFP_KERNEL);\r\nif (!pdata->msgdata) {\r\nretval = -ENOMEM;\r\ndev_err(&iface->dev,\r\n"Allocating buffer for control messages failed\n");\r\ngoto error;\r\n}\r\npdata->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pdata->urb) {\r\nretval = -ENOMEM;\r\ndev_err(&iface->dev, "Allocating URB failed\n");\r\ngoto error;\r\n}\r\npdata->urbdata = usb_alloc_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\r\nGFP_KERNEL, &pdata->urb->transfer_dma);\r\nif (!pdata->urbdata) {\r\nretval = -ENOMEM;\r\ndev_err(&iface->dev, "Allocating URB buffer failed\n");\r\ngoto error;\r\n}\r\nusb_fill_int_urb(pdata->urb, udev,\r\nusb_rcvintpipe(udev, int_in_endpointAddr),\r\npdata->urbdata, ACD_URB_BUFFER_LEN, appledisplay_complete,\r\npdata, 1);\r\nif (usb_submit_urb(pdata->urb, GFP_KERNEL)) {\r\nretval = -EIO;\r\ndev_err(&iface->dev, "Submitting URB failed\n");\r\ngoto error;\r\n}\r\nsnprintf(bl_name, sizeof(bl_name), "appledisplay%d",\r\natomic_inc_return(&count_displays) - 1);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 0xff;\r\npdata->bd = backlight_device_register(bl_name, NULL, pdata,\r\n&appledisplay_bl_data, &props);\r\nif (IS_ERR(pdata->bd)) {\r\ndev_err(&iface->dev, "Backlight registration failed\n");\r\nretval = PTR_ERR(pdata->bd);\r\ngoto error;\r\n}\r\nbrightness = appledisplay_bl_get_brightness(pdata->bd);\r\nif (brightness < 0) {\r\nretval = brightness;\r\ndev_err(&iface->dev,\r\n"Error while getting initial brightness: %d\n", retval);\r\ngoto error;\r\n}\r\npdata->bd->props.brightness = brightness;\r\nusb_set_intfdata(iface, pdata);\r\nprintk(KERN_INFO "appledisplay: Apple Cinema Display connected\n");\r\nreturn 0;\r\nerror:\r\nif (pdata) {\r\nif (pdata->urb) {\r\nusb_kill_urb(pdata->urb);\r\nif (pdata->urbdata)\r\nusb_free_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\r\npdata->urbdata, pdata->urb->transfer_dma);\r\nusb_free_urb(pdata->urb);\r\n}\r\nif (pdata->bd && !IS_ERR(pdata->bd))\r\nbacklight_device_unregister(pdata->bd);\r\nkfree(pdata->msgdata);\r\n}\r\nusb_set_intfdata(iface, NULL);\r\nkfree(pdata);\r\nreturn retval;\r\n}\r\nstatic void appledisplay_disconnect(struct usb_interface *iface)\r\n{\r\nstruct appledisplay *pdata = usb_get_intfdata(iface);\r\nif (pdata) {\r\nusb_kill_urb(pdata->urb);\r\ncancel_delayed_work(&pdata->work);\r\nbacklight_device_unregister(pdata->bd);\r\nusb_free_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\r\npdata->urbdata, pdata->urb->transfer_dma);\r\nusb_free_urb(pdata->urb);\r\nkfree(pdata->msgdata);\r\nkfree(pdata);\r\n}\r\nprintk(KERN_INFO "appledisplay: Apple Cinema Display disconnected\n");\r\n}\r\nstatic int __init appledisplay_init(void)\r\n{\r\nwq = create_singlethread_workqueue("appledisplay");\r\nif (!wq) {\r\nprintk(KERN_ERR "appledisplay: Could not create work queue\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn usb_register(&appledisplay_driver);\r\n}\r\nstatic void __exit appledisplay_exit(void)\r\n{\r\nflush_workqueue(wq);\r\ndestroy_workqueue(wq);\r\nusb_deregister(&appledisplay_driver);\r\n}
