static int serport_serio_write(struct serio *serio, unsigned char data)\r\n{\r\nstruct serport *serport = serio->port_data;\r\nreturn -(serport->tty->ops->write(serport->tty, &data, 1) != 1);\r\n}\r\nstatic int serport_serio_open(struct serio *serio)\r\n{\r\nstruct serport *serport = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serport->lock, flags);\r\nset_bit(SERPORT_ACTIVE, &serport->flags);\r\nspin_unlock_irqrestore(&serport->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void serport_serio_close(struct serio *serio)\r\n{\r\nstruct serport *serport = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serport->lock, flags);\r\nclear_bit(SERPORT_ACTIVE, &serport->flags);\r\nset_bit(SERPORT_DEAD, &serport->flags);\r\nspin_unlock_irqrestore(&serport->lock, flags);\r\nwake_up_interruptible(&serport->wait);\r\n}\r\nstatic int serport_ldisc_open(struct tty_struct *tty)\r\n{\r\nstruct serport *serport;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nserport = kzalloc(sizeof(struct serport), GFP_KERNEL);\r\nif (!serport)\r\nreturn -ENOMEM;\r\nserport->tty = tty;\r\nspin_lock_init(&serport->lock);\r\ninit_waitqueue_head(&serport->wait);\r\ntty->disc_data = serport;\r\ntty->receive_room = 256;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nreturn 0;\r\n}\r\nstatic void serport_ldisc_close(struct tty_struct *tty)\r\n{\r\nstruct serport *serport = (struct serport *) tty->disc_data;\r\nkfree(serport);\r\n}\r\nstatic void serport_ldisc_receive(struct tty_struct *tty, const unsigned char *cp, char *fp, int count)\r\n{\r\nstruct serport *serport = (struct serport*) tty->disc_data;\r\nunsigned long flags;\r\nunsigned int ch_flags = 0;\r\nint i;\r\nspin_lock_irqsave(&serport->lock, flags);\r\nif (!test_bit(SERPORT_ACTIVE, &serport->flags))\r\ngoto out;\r\nfor (i = 0; i < count; i++) {\r\nif (fp) {\r\nswitch (fp[i]) {\r\ncase TTY_FRAME:\r\nch_flags = SERIO_FRAME;\r\nbreak;\r\ncase TTY_PARITY:\r\nch_flags = SERIO_PARITY;\r\nbreak;\r\ndefault:\r\nch_flags = 0;\r\nbreak;\r\n}\r\n}\r\nserio_interrupt(serport->serio, cp[i], ch_flags);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&serport->lock, flags);\r\n}\r\nstatic ssize_t serport_ldisc_read(struct tty_struct * tty, struct file * file, unsigned char __user * buf, size_t nr)\r\n{\r\nstruct serport *serport = (struct serport*) tty->disc_data;\r\nstruct serio *serio;\r\nchar name[64];\r\nif (test_and_set_bit(SERPORT_BUSY, &serport->flags))\r\nreturn -EBUSY;\r\nserport->serio = serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio)\r\nreturn -ENOMEM;\r\nstrlcpy(serio->name, "Serial port", sizeof(serio->name));\r\nsnprintf(serio->phys, sizeof(serio->phys), "%s/serio0", tty_name(tty, name));\r\nserio->id = serport->id;\r\nserio->id.type = SERIO_RS232;\r\nserio->write = serport_serio_write;\r\nserio->open = serport_serio_open;\r\nserio->close = serport_serio_close;\r\nserio->port_data = serport;\r\nserio->dev.parent = tty->dev;\r\nserio_register_port(serport->serio);\r\nprintk(KERN_INFO "serio: Serial port %s\n", tty_name(tty, name));\r\nwait_event_interruptible(serport->wait, test_bit(SERPORT_DEAD, &serport->flags));\r\nserio_unregister_port(serport->serio);\r\nserport->serio = NULL;\r\nclear_bit(SERPORT_DEAD, &serport->flags);\r\nclear_bit(SERPORT_BUSY, &serport->flags);\r\nreturn 0;\r\n}\r\nstatic void serport_set_type(struct tty_struct *tty, unsigned long type)\r\n{\r\nstruct serport *serport = tty->disc_data;\r\nserport->id.proto = type & 0x000000ff;\r\nserport->id.id = (type & 0x0000ff00) >> 8;\r\nserport->id.extra = (type & 0x00ff0000) >> 16;\r\n}\r\nstatic int serport_ldisc_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == SPIOCSTYPE) {\r\nunsigned long type;\r\nif (get_user(type, (unsigned long __user *) arg))\r\nreturn -EFAULT;\r\nserport_set_type(tty, type);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long serport_ldisc_compat_ioctl(struct tty_struct *tty,\r\nstruct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == COMPAT_SPIOCSTYPE) {\r\nvoid __user *uarg = compat_ptr(arg);\r\ncompat_ulong_t compat_type;\r\nif (get_user(compat_type, (compat_ulong_t __user *)uarg))\r\nreturn -EFAULT;\r\nserport_set_type(tty, compat_type);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void serport_ldisc_write_wakeup(struct tty_struct * tty)\r\n{\r\nstruct serport *serport = (struct serport *) tty->disc_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serport->lock, flags);\r\nif (test_bit(SERPORT_ACTIVE, &serport->flags))\r\nserio_drv_write_wakeup(serport->serio);\r\nspin_unlock_irqrestore(&serport->lock, flags);\r\n}\r\nstatic int __init serport_init(void)\r\n{\r\nint retval;\r\nretval = tty_register_ldisc(N_MOUSE, &serport_ldisc);\r\nif (retval)\r\nprintk(KERN_ERR "serport.c: Error registering line discipline.\n");\r\nreturn retval;\r\n}\r\nstatic void __exit serport_exit(void)\r\n{\r\ntty_unregister_ldisc(N_MOUSE);\r\n}
