static bool wm8770_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8770_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int vout12supply_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, WM8770_OUTMUX1, 0x180, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, WM8770_OUTMUX1, 0x180, 0x180);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vout34supply_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, WM8770_OUTMUX2, 0x180, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, WM8770_OUTMUX2, 0x180, 0x180);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8770_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, WM8770_RESET, 0);\r\n}\r\nstatic int wm8770_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec;\r\nint iface, master;\r\ncodec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = 0x100;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0xc;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8770_IFACECTRL, 0xf, iface);\r\nsnd_soc_update_bits(codec, WM8770_MSTRCTRL, 0x100, master);\r\nreturn 0;\r\n}\r\nstatic int wm8770_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8770_priv *wm8770;\r\nint i;\r\nint iface;\r\nint shift;\r\nint ratio;\r\ncodec = dai->codec;\r\nwm8770 = snd_soc_codec_get_drvdata(codec);\r\niface = 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\niface |= 0x10;\r\nbreak;\r\ncase 24:\r\niface |= 0x20;\r\nbreak;\r\ncase 32:\r\niface |= 0x30;\r\nbreak;\r\n}\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\ni = 0;\r\nshift = 4;\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\ni = 2;\r\nshift = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (snd_soc_read(codec, WM8770_MSTRCTRL) & 0x100) {\r\nfor (; i < ARRAY_SIZE(mclk_ratios); ++i) {\r\nratio = wm8770->sysclk / params_rate(params);\r\nif (ratio == mclk_ratios[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(mclk_ratios)) {\r\ndev_err(codec->dev,\r\n"Unable to configure MCLK ratio %d/%d\n",\r\nwm8770->sysclk, params_rate(params));\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "MCLK is %dfs\n", mclk_ratios[i]);\r\nsnd_soc_update_bits(codec, WM8770_MSTRCTRL, 0x7 << shift,\r\ni << shift);\r\n}\r\nsnd_soc_update_bits(codec, WM8770_IFACECTRL, 0x30, iface);\r\nreturn 0;\r\n}\r\nstatic int wm8770_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = dai->codec;\r\nreturn snd_soc_update_bits(codec, WM8770_DACMUTE, 0x10,\r\n!!mute << 4);\r\n}\r\nstatic int wm8770_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8770_priv *wm8770;\r\ncodec = dai->codec;\r\nwm8770 = snd_soc_codec_get_drvdata(codec);\r\nwm8770->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int wm8770_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nstruct wm8770_priv *wm8770;\r\nwm8770 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8770->supplies),\r\nwm8770->supplies);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregcache_sync(wm8770->regmap);\r\nsnd_soc_write(codec, WM8770_PWDNCTRL, 0);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8770_PWDNCTRL, 1);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8770->supplies),\r\nwm8770->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8770_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8770_priv *wm8770;\r\nint ret;\r\nwm8770 = snd_soc_codec_get_drvdata(codec);\r\nwm8770->codec = codec;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8770->supplies),\r\nwm8770->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wm8770_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nsnd_soc_update_bits(codec, WM8770_MSDIGVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_MSALGVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_VOUT1RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_VOUT2RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_VOUT3RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_VOUT4RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_DAC1RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_DAC2RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_DAC3RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_DAC4RVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8770_DACMUTE, 0x10, 0x10);\r\nerr_reg_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8770->supplies), wm8770->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8770_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8770_priv *wm8770;\r\nint ret, i;\r\nwm8770 = devm_kzalloc(&spi->dev, sizeof(struct wm8770_priv),\r\nGFP_KERNEL);\r\nif (!wm8770)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(wm8770->supplies); i++)\r\nwm8770->supplies[i].supply = wm8770_supply_names[i];\r\nret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8770->supplies),\r\nwm8770->supplies);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8770->disable_nb[0].notifier_call = wm8770_regulator_event_0;\r\nwm8770->disable_nb[1].notifier_call = wm8770_regulator_event_1;\r\nwm8770->disable_nb[2].notifier_call = wm8770_regulator_event_2;\r\nfor (i = 0; i < ARRAY_SIZE(wm8770->supplies); i++) {\r\nret = regulator_register_notifier(wm8770->supplies[i].consumer,\r\n&wm8770->disable_nb[i]);\r\nif (ret) {\r\ndev_err(&spi->dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nwm8770->regmap = devm_regmap_init_spi(spi, &wm8770_regmap);\r\nif (IS_ERR(wm8770->regmap))\r\nreturn PTR_ERR(wm8770->regmap);\r\nspi_set_drvdata(spi, wm8770);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8770, &wm8770_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8770_spi_remove(struct spi_device *spi)\r\n{\r\nstruct wm8770_priv *wm8770 = spi_get_drvdata(spi);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm8770->supplies); ++i)\r\nregulator_unregister_notifier(wm8770->supplies[i].consumer,\r\n&wm8770->disable_nb[i]);\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}
