int uwb_est_create(void)\r\n{\r\nint result;\r\nuwb_est_size = 2;\r\nuwb_est_used = 0;\r\nuwb_est = kcalloc(uwb_est_size, sizeof(uwb_est[0]), GFP_KERNEL);\r\nif (uwb_est == NULL)\r\nreturn -ENOMEM;\r\nresult = uwb_est_register(UWB_RC_CET_GENERAL, 0, 0xffff, 0xffff,\r\nuwb_est_00_00xx, ARRAY_SIZE(uwb_est_00_00xx));\r\nif (result < 0)\r\ngoto out;\r\nresult = uwb_est_register(UWB_RC_CET_EX_TYPE_1, 0, 0xffff, 0xffff,\r\nuwb_est_01_00xx, ARRAY_SIZE(uwb_est_01_00xx));\r\nout:\r\nreturn result;\r\n}\r\nvoid uwb_est_destroy(void)\r\n{\r\nkfree(uwb_est);\r\nuwb_est = NULL;\r\nuwb_est_size = uwb_est_used = 0;\r\n}\r\nstatic\r\nint uwb_est_grow(void)\r\n{\r\nsize_t actual_size = uwb_est_size * sizeof(uwb_est[0]);\r\nvoid *new = kmalloc(2 * actual_size, GFP_ATOMIC);\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(new, uwb_est, actual_size);\r\nmemset(new + actual_size, 0, actual_size);\r\nkfree(uwb_est);\r\nuwb_est = new;\r\nuwb_est_size *= 2;\r\nreturn 0;\r\n}\r\nint uwb_est_register(u8 type, u8 event_high, u16 vendor, u16 product,\r\nconst struct uwb_est_entry *entry, size_t entries)\r\n{\r\nunsigned long flags;\r\nunsigned itr;\r\nint result = 0;\r\nwrite_lock_irqsave(&uwb_est_lock, flags);\r\nif (uwb_est_used == uwb_est_size) {\r\nresult = uwb_est_grow();\r\nif (result < 0)\r\ngoto out;\r\n}\r\nfor (itr = 0; itr < uwb_est_used; itr++)\r\nif (uwb_est[itr].type_event_high < type\r\n&& uwb_est[itr].vendor < vendor\r\n&& uwb_est[itr].product < product)\r\nbreak;\r\nif (itr < uwb_est_used)\r\nmemmove(&uwb_est[itr+1], &uwb_est[itr], uwb_est_used - itr);\r\nuwb_est[itr].type_event_high = type << 8 | event_high;\r\nuwb_est[itr].vendor = vendor;\r\nuwb_est[itr].product = product;\r\nuwb_est[itr].entry = entry;\r\nuwb_est[itr].entries = entries;\r\nuwb_est_used++;\r\nout:\r\nwrite_unlock_irqrestore(&uwb_est_lock, flags);\r\nreturn result;\r\n}\r\nint uwb_est_unregister(u8 type, u8 event_high, u16 vendor, u16 product,\r\nconst struct uwb_est_entry *entry, size_t entries)\r\n{\r\nunsigned long flags;\r\nunsigned itr;\r\nstruct uwb_est est_cmp = {\r\n.type_event_high = type << 8 | event_high,\r\n.vendor = vendor,\r\n.product = product,\r\n.entry = entry,\r\n.entries = entries\r\n};\r\nwrite_lock_irqsave(&uwb_est_lock, flags);\r\nfor (itr = 0; itr < uwb_est_used; itr++)\r\nif (!memcmp(&uwb_est[itr], &est_cmp, sizeof(est_cmp)))\r\ngoto found;\r\nwrite_unlock_irqrestore(&uwb_est_lock, flags);\r\nreturn -ENOENT;\r\nfound:\r\nif (itr < uwb_est_used - 1)\r\nmemmove(&uwb_est[itr], &uwb_est[itr+1], uwb_est_used - itr - 1);\r\nuwb_est_used--;\r\nwrite_unlock_irqrestore(&uwb_est_lock, flags);\r\nreturn 0;\r\n}\r\nstatic\r\nssize_t uwb_est_get_size(struct uwb_rc *uwb_rc, struct uwb_est *est,\r\nu8 event_low, const struct uwb_rceb *rceb,\r\nsize_t rceb_size)\r\n{\r\nunsigned offset;\r\nssize_t size;\r\nstruct device *dev = &uwb_rc->uwb_dev.dev;\r\nconst struct uwb_est_entry *entry;\r\nsize = -ENOENT;\r\nif (event_low >= est->entries) {\r\ndev_err(dev, "EST %p 0x%04x/%04x/%04x[%u]: event %u out of range\n",\r\nest, est->type_event_high, est->vendor, est->product,\r\nest->entries, event_low);\r\ngoto out;\r\n}\r\nsize = -ENOENT;\r\nentry = &est->entry[event_low];\r\nif (entry->size == 0 && entry->offset == 0) {\r\ndev_err(dev, "EST %p 0x%04x/%04x/%04x[%u]: event %u unknown\n",\r\nest, est->type_event_high, est->vendor, est->product,\r\nest->entries, event_low);\r\ngoto out;\r\n}\r\noffset = entry->offset;\r\nif (offset == 0)\r\nsize = entry->size;\r\nelse {\r\nconst void *ptr = rceb;\r\nsize_t type_size = 0;\r\noffset--;\r\nsize = -ENOSPC;\r\nswitch (entry->type) {\r\ncase UWB_EST_16: type_size = sizeof(__le16); break;\r\ncase UWB_EST_8: type_size = sizeof(u8); break;\r\ndefault: BUG();\r\n}\r\nif (offset + type_size > rceb_size) {\r\ndev_err(dev, "EST %p 0x%04x/%04x/%04x[%u]: "\r\n"not enough data to read extra size\n",\r\nest, est->type_event_high, est->vendor,\r\nest->product, est->entries);\r\ngoto out;\r\n}\r\nsize = entry->size;\r\nptr += offset;\r\nswitch (entry->type) {\r\ncase UWB_EST_16: size += le16_to_cpu(*(__le16 *)ptr); break;\r\ncase UWB_EST_8: size += *(u8 *)ptr; break;\r\ndefault: BUG();\r\n}\r\n}\r\nout:\r\nreturn size;\r\n}\r\nssize_t uwb_est_find_size(struct uwb_rc *rc, const struct uwb_rceb *rceb,\r\nsize_t rceb_size)\r\n{\r\nssize_t size;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nunsigned long flags;\r\nunsigned itr;\r\nu16 type_event_high, event;\r\nread_lock_irqsave(&uwb_est_lock, flags);\r\nsize = -ENOSPC;\r\nif (rceb_size < sizeof(*rceb))\r\ngoto out;\r\nevent = le16_to_cpu(rceb->wEvent);\r\ntype_event_high = rceb->bEventType << 8 | (event & 0xff00) >> 8;\r\nfor (itr = 0; itr < uwb_est_used; itr++) {\r\nif (uwb_est[itr].type_event_high != type_event_high)\r\ncontinue;\r\nsize = uwb_est_get_size(rc, &uwb_est[itr],\r\nevent & 0x00ff, rceb, rceb_size);\r\nif (size != -ENOENT)\r\ngoto out;\r\n}\r\ndev_dbg(dev,\r\n"event 0x%02x/%04x/%02x: no handlers available; RCEB %4ph\n",\r\n(unsigned) rceb->bEventType,\r\n(unsigned) le16_to_cpu(rceb->wEvent),\r\n(unsigned) rceb->bEventContext,\r\nrceb);\r\nsize = -ENOENT;\r\nout:\r\nread_unlock_irqrestore(&uwb_est_lock, flags);\r\nreturn size;\r\n}
