void radeon_connector_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->hpd.hpd == RADEON_HPD_NONE)\r\nreturn;\r\nradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\r\nif (connector->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\nif (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT)\r\nreturn;\r\ndig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);\r\nif (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\r\nint saved_dpms = connector->dpms;\r\nif (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\n} else if (radeon_dp_needs_link_train(radeon_connector)) {\r\nconnector->dpms = DRM_MODE_DPMS_OFF;\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\r\n}\r\nconnector->dpms = saved_dpms;\r\n}\r\n}\r\n}\r\nstatic void radeon_property_change_mode(struct drm_encoder *encoder)\r\n{\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nif (crtc && crtc->enabled) {\r\ndrm_crtc_helper_set_mode(crtc, &crtc->mode,\r\ncrtc->x, crtc->y, crtc->primary->fb);\r\n}\r\n}\r\nint radeon_get_monitor_bpc(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nint bpc = 8;\r\nint mode_clock, max_tmds_clock;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\nif (radeon_connector->use_digital) {\r\nif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\nif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ndig_connector = radeon_connector->con_priv;\r\nif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) ||\r\ndrm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\nelse if (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE5(rdev)) {\r\nstruct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nstruct drm_encoder *encoder = connector_funcs->best_encoder(connector);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_V13_6BIT_PER_COLOR)\r\nbpc = 6;\r\nelse if (dig->lcd_misc & ATOM_PANEL_MISC_V13_8BIT_PER_COLOR)\r\nbpc = 8;\r\n}\r\nbreak;\r\n}\r\nif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif ((bpc > 8) && !ASIC_IS_DCE4(rdev)) {\r\nDRM_DEBUG("%s: HDMI deep color %d bpc unsupported. Using 8 bpc.\n",\r\nconnector->name, bpc);\r\nbpc = 8;\r\n}\r\nif (bpc > 12) {\r\nDRM_DEBUG("%s: HDMI deep color %d bpc unsupported. Using 12 bpc.\n",\r\nconnector->name, bpc);\r\nbpc = 12;\r\n}\r\nif (connector->max_tmds_clock > 0) {\r\nmode_clock = radeon_connector->pixelclock_for_modeset;\r\nmax_tmds_clock = connector->max_tmds_clock * 1000;\r\nDRM_DEBUG("%s: hdmi mode dotclock %d kHz, max tmds input clock %d kHz.\n",\r\nconnector->name, mode_clock, max_tmds_clock);\r\nif ((bpc == 12) && (mode_clock * 3/2 > max_tmds_clock)) {\r\nif ((connector->display_info.edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30) &&\r\n(mode_clock * 5/4 <= max_tmds_clock))\r\nbpc = 10;\r\nelse\r\nbpc = 8;\r\nDRM_DEBUG("%s: HDMI deep color 12 bpc exceeds max tmds clock. Using %d bpc.\n",\r\nconnector->name, bpc);\r\n}\r\nif ((bpc == 10) && (mode_clock * 5/4 > max_tmds_clock)) {\r\nbpc = 8;\r\nDRM_DEBUG("%s: HDMI deep color 10 bpc exceeds max tmds clock. Using %d bpc.\n",\r\nconnector->name, bpc);\r\n}\r\n}\r\nelse if (bpc > 8) {\r\nDRM_DEBUG("%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\n",\r\nconnector->name);\r\nbpc = 8;\r\n}\r\n}\r\nif ((radeon_deep_color == 0) && (bpc > 8)) {\r\nDRM_DEBUG("%s: Deep color disabled. Set radeon module param deep_color=1 to enable.\n",\r\nconnector->name);\r\nbpc = 8;\r\n}\r\nDRM_DEBUG("%s: Display bpc=%d, returned bpc=%d\n",\r\nconnector->name, connector->display_info.bpc, bpc);\r\nreturn bpc;\r\n}\r\nstatic void\r\nradeon_connector_update_scratch_regs(struct drm_connector *connector, enum drm_connector_status status)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *best_encoder = NULL;\r\nstruct drm_encoder *encoder = NULL;\r\nstruct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\nbool connected;\r\nint i;\r\nbest_encoder = connector_funcs->best_encoder(connector);\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif ((encoder == best_encoder) && (status == connector_status_connected))\r\nconnected = true;\r\nelse\r\nconnected = false;\r\nif (rdev->is_atom_bios)\r\nradeon_atombios_connected_scratch_regs(connector, encoder, connected);\r\nelse\r\nradeon_combios_connected_scratch_regs(connector, encoder, connected);\r\n}\r\n}\r\nstatic struct drm_encoder *radeon_find_encoder(struct drm_connector *connector, int encoder_type)\r\n{\r\nstruct drm_encoder *encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (encoder->encoder_type == encoder_type)\r\nreturn encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstruct edid *radeon_connector_edid(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_property_blob *edid_blob = connector->edid_blob_ptr;\r\nif (radeon_connector->edid) {\r\nreturn radeon_connector->edid;\r\n} else if (edid_blob) {\r\nstruct edid *edid = kmemdup(edid_blob->data, edid_blob->length, GFP_KERNEL);\r\nif (edid)\r\nradeon_connector->edid = edid;\r\n}\r\nreturn radeon_connector->edid;\r\n}\r\nstatic void radeon_connector_get_edid(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->edid)\r\nreturn;\r\nif (radeon_connector->router.ddc_valid)\r\nradeon_router_select_ddc_port(radeon_connector);\r\nif ((radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) &&\r\nradeon_connector->ddc_bus->has_aux) {\r\nradeon_connector->edid = drm_get_edid(connector,\r\n&radeon_connector->ddc_bus->aux.ddc);\r\n} else if ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\r\nstruct radeon_connector_atom_dig *dig = radeon_connector->con_priv;\r\nif ((dig->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT ||\r\ndig->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) &&\r\nradeon_connector->ddc_bus->has_aux)\r\nradeon_connector->edid = drm_get_edid(&radeon_connector->base,\r\n&radeon_connector->ddc_bus->aux.ddc);\r\nelse if (radeon_connector->ddc_bus)\r\nradeon_connector->edid = drm_get_edid(&radeon_connector->base,\r\n&radeon_connector->ddc_bus->adapter);\r\n} else if (radeon_connector->ddc_bus) {\r\nradeon_connector->edid = drm_get_edid(&radeon_connector->base,\r\n&radeon_connector->ddc_bus->adapter);\r\n}\r\nif (!radeon_connector->edid) {\r\nif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\r\nreturn;\r\nif (rdev->is_atom_bios) {\r\nif (((connector->connector_type == DRM_MODE_CONNECTOR_LVDS) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_eDP)))\r\nradeon_connector->edid = radeon_bios_get_hardcoded_edid(rdev);\r\n} else {\r\nradeon_connector->edid = radeon_bios_get_hardcoded_edid(rdev);\r\n}\r\n}\r\n}\r\nstatic void radeon_connector_free_edid(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->edid) {\r\nkfree(radeon_connector->edid);\r\nradeon_connector->edid = NULL;\r\n}\r\n}\r\nstatic int radeon_ddc_get_modes(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nint ret;\r\nif (radeon_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, radeon_connector->edid);\r\nret = drm_add_edid_modes(connector, radeon_connector->edid);\r\ndrm_edid_to_eld(connector, radeon_connector->edid);\r\nreturn ret;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *radeon_best_single_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void radeon_get_native_mode(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nstruct radeon_encoder *radeon_encoder;\r\nif (encoder == NULL)\r\nreturn;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (!list_empty(&connector->probed_modes)) {\r\nstruct drm_display_mode *preferred_mode =\r\nlist_first_entry(&connector->probed_modes,\r\nstruct drm_display_mode, head);\r\nradeon_encoder->native_mode = *preferred_mode;\r\n} else {\r\nradeon_encoder->native_mode.clock = 0;\r\n}\r\n}\r\nstatic enum drm_connector_status\r\nradeon_connector_analog_encoder_conflict_solve(struct drm_connector *connector,\r\nstruct drm_encoder *encoder,\r\nenum drm_connector_status current_status,\r\nbool priority)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_connector *conflict;\r\nstruct radeon_connector *radeon_conflict;\r\nint i;\r\nlist_for_each_entry(conflict, &dev->mode_config.connector_list, head) {\r\nif (conflict == connector)\r\ncontinue;\r\nradeon_conflict = to_radeon_connector(conflict);\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (conflict->encoder_ids[i] == 0)\r\nbreak;\r\nif (conflict->encoder_ids[i] == encoder->base.id) {\r\nif (conflict->status != connector_status_connected)\r\ncontinue;\r\nif (radeon_conflict->use_digital)\r\ncontinue;\r\nif (priority == true) {\r\nDRM_DEBUG_KMS("1: conflicting encoders switching off %s\n",\r\nconflict->name);\r\nDRM_DEBUG_KMS("in favor of %s\n",\r\nconnector->name);\r\nconflict->status = connector_status_disconnected;\r\nradeon_connector_update_scratch_regs(conflict, connector_status_disconnected);\r\n} else {\r\nDRM_DEBUG_KMS("2: conflicting encoders switching off %s\n",\r\nconnector->name);\r\nDRM_DEBUG_KMS("in favor of %s\n",\r\nconflict->name);\r\ncurrent_status = connector_status_disconnected;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn current_status;\r\n}\r\nstatic struct drm_display_mode *radeon_fp_native_mode(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nif (native_mode->hdisplay != 0 &&\r\nnative_mode->vdisplay != 0 &&\r\nnative_mode->clock != 0) {\r\nmode = drm_mode_duplicate(dev, native_mode);\r\nmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\r\ndrm_mode_set_name(mode);\r\nDRM_DEBUG_KMS("Adding native panel mode %s\n", mode->name);\r\n} else if (native_mode->hdisplay != 0 &&\r\nnative_mode->vdisplay != 0) {\r\nmode = drm_cvt_mode(dev, native_mode->hdisplay, native_mode->vdisplay, 60, true, false, false);\r\nmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\r\nDRM_DEBUG_KMS("Adding cvt approximation of native panel mode %s\n", mode->name);\r\n}\r\nreturn mode;\r\n}\r\nstatic void radeon_add_common_modes(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nint i;\r\nstruct mode_size {\r\nint w;\r\nint h;\r\n} common_modes[17] = {\r\n{ 640, 480},\r\n{ 720, 480},\r\n{ 800, 600},\r\n{ 848, 480},\r\n{1024, 768},\r\n{1152, 768},\r\n{1280, 720},\r\n{1280, 800},\r\n{1280, 854},\r\n{1280, 960},\r\n{1280, 1024},\r\n{1440, 900},\r\n{1400, 1050},\r\n{1680, 1050},\r\n{1600, 1200},\r\n{1920, 1080},\r\n{1920, 1200}\r\n};\r\nfor (i = 0; i < 17; i++) {\r\nif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT)) {\r\nif (common_modes[i].w > 1024 ||\r\ncommon_modes[i].h > 768)\r\ncontinue;\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (common_modes[i].w > native_mode->hdisplay ||\r\ncommon_modes[i].h > native_mode->vdisplay ||\r\n(common_modes[i].w == native_mode->hdisplay &&\r\ncommon_modes[i].h == native_mode->vdisplay))\r\ncontinue;\r\n}\r\nif (common_modes[i].w < 320 || common_modes[i].h < 200)\r\ncontinue;\r\nmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\n}\r\nstatic int radeon_connector_set_property(struct drm_connector *connector, struct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nif (property == rdev->mode_info.coherent_mode_property) {\r\nstruct radeon_encoder_atom_dig *dig;\r\nbool new_coherent_mode;\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (!radeon_encoder->enc_priv)\r\nreturn 0;\r\ndig = radeon_encoder->enc_priv;\r\nnew_coherent_mode = val ? true : false;\r\nif (dig->coherent_mode != new_coherent_mode) {\r\ndig->coherent_mode = new_coherent_mode;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.audio_property) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_connector->audio != val) {\r\nradeon_connector->audio = val;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.dither_property) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_connector->dither != val) {\r\nradeon_connector->dither = val;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.underscan_property) {\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->underscan_type != val) {\r\nradeon_encoder->underscan_type = val;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.underscan_hborder_property) {\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->underscan_hborder != val) {\r\nradeon_encoder->underscan_hborder = val;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.underscan_vborder_property) {\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->underscan_vborder != val) {\r\nradeon_encoder->underscan_vborder = val;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\n}\r\nif (property == rdev->mode_info.tv_std_property) {\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TVDAC);\r\nif (!encoder) {\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_DAC);\r\n}\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (!radeon_encoder->enc_priv)\r\nreturn 0;\r\nif (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom) {\r\nstruct radeon_encoder_atom_dac *dac_int;\r\ndac_int = radeon_encoder->enc_priv;\r\ndac_int->tv_std = val;\r\n} else {\r\nstruct radeon_encoder_tv_dac *dac_int;\r\ndac_int = radeon_encoder->enc_priv;\r\ndac_int->tv_std = val;\r\n}\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\nif (property == rdev->mode_info.load_detect_property) {\r\nstruct radeon_connector *radeon_connector =\r\nto_radeon_connector(connector);\r\nif (val == 0)\r\nradeon_connector->dac_load_detect = false;\r\nelse\r\nradeon_connector->dac_load_detect = true;\r\n}\r\nif (property == rdev->mode_info.tmds_pll_property) {\r\nstruct radeon_encoder_int_tmds *tmds = NULL;\r\nbool ret = false;\r\nencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\ntmds = radeon_encoder->enc_priv;\r\nif (!tmds)\r\nreturn 0;\r\nif (val == 0) {\r\nif (rdev->is_atom_bios)\r\nret = radeon_atombios_get_tmds_info(radeon_encoder, tmds);\r\nelse\r\nret = radeon_legacy_get_tmds_info_from_combios(radeon_encoder, tmds);\r\n}\r\nif (val == 1 || ret == false) {\r\nradeon_legacy_get_tmds_info_from_table(radeon_encoder, tmds);\r\n}\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\nif (property == dev->mode_config.scaling_mode_property) {\r\nenum radeon_rmx_type rmx_type;\r\nif (connector->encoder)\r\nradeon_encoder = to_radeon_encoder(connector->encoder);\r\nelse {\r\nstruct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\nradeon_encoder = to_radeon_encoder(connector_funcs->best_encoder(connector));\r\n}\r\nswitch (val) {\r\ndefault:\r\ncase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\r\ncase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\r\ncase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\r\ncase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\r\n}\r\nif (radeon_encoder->rmx_type == rmx_type)\r\nreturn 0;\r\nif ((rmx_type != DRM_MODE_SCALE_NONE) &&\r\n(radeon_encoder->native_mode.clock == 0))\r\nreturn 0;\r\nradeon_encoder->rmx_type = rmx_type;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_fixup_lvds_native_mode(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nstruct drm_display_mode *t, *mode;\r\nlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED) {\r\nif (mode->hdisplay != native_mode->hdisplay ||\r\nmode->vdisplay != native_mode->vdisplay)\r\nmemcpy(native_mode, mode, sizeof(*mode));\r\n}\r\n}\r\nif (!native_mode->clock) {\r\nlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\r\nif (mode->hdisplay == native_mode->hdisplay &&\r\nmode->vdisplay == native_mode->vdisplay) {\r\n*native_mode = *mode;\r\ndrm_mode_set_crtcinfo(native_mode, CRTC_INTERLACE_HALVE_V);\r\nDRM_DEBUG_KMS("Determined LVDS native mode details from EDID\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!native_mode->clock) {\r\nDRM_DEBUG_KMS("No LVDS native mode details, disabling RMX\n");\r\nradeon_encoder->rmx_type = RMX_OFF;\r\n}\r\n}\r\nstatic int radeon_lvds_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nint ret = 0;\r\nstruct drm_display_mode *mode;\r\nradeon_connector_get_edid(connector);\r\nret = radeon_ddc_get_modes(connector);\r\nif (ret > 0) {\r\nencoder = radeon_best_single_encoder(connector);\r\nif (encoder) {\r\nradeon_fixup_lvds_native_mode(encoder, connector);\r\nradeon_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nencoder = radeon_best_single_encoder(connector);\r\nif (!encoder)\r\nreturn 0;\r\nmode = radeon_fp_native_mode(encoder);\r\nif (mode) {\r\nret = 1;\r\ndrm_mode_probed_add(connector, mode);\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nradeon_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nstatic int radeon_lvds_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\r\nreturn MODE_PANEL;\r\nif (encoder) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nif ((mode->hdisplay > native_mode->hdisplay) ||\r\n(mode->vdisplay > native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nif (radeon_encoder->rmx_type == RMX_OFF) {\r\nif ((mode->hdisplay != native_mode->hdisplay) ||\r\n(mode->vdisplay != native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\n}\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_lvds_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (encoder) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\r\nret = connector_status_connected;\r\nif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\r\nret = connector_status_disconnected;\r\n}\r\nradeon_connector_get_edid(connector);\r\nif (radeon_connector->edid)\r\nret = connector_status_connected;\r\nradeon_connector_update_scratch_regs(connector, ret);\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic void radeon_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nradeon_connector_free_edid(connector);\r\nkfree(radeon_connector->con_priv);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int radeon_lvds_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_encoder *radeon_encoder;\r\nenum radeon_rmx_type rmx_type;\r\nDRM_DEBUG_KMS("\n");\r\nif (property != dev->mode_config.scaling_mode_property)\r\nreturn 0;\r\nif (connector->encoder)\r\nradeon_encoder = to_radeon_encoder(connector->encoder);\r\nelse {\r\nstruct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\nradeon_encoder = to_radeon_encoder(connector_funcs->best_encoder(connector));\r\n}\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\r\ncase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\r\ncase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\r\ndefault:\r\ncase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\r\n}\r\nif (radeon_encoder->rmx_type == rmx_type)\r\nreturn 0;\r\nradeon_encoder->rmx_type = rmx_type;\r\nradeon_property_change_mode(&radeon_encoder->base);\r\nreturn 0;\r\n}\r\nstatic int radeon_vga_get_modes(struct drm_connector *connector)\r\n{\r\nint ret;\r\nradeon_connector_get_edid(connector);\r\nret = radeon_ddc_get_modes(connector);\r\nradeon_get_native_mode(connector);\r\nreturn ret;\r\n}\r\nstatic int radeon_vga_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif ((mode->clock / 10) > rdev->clock.max_pixel_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_vga_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_encoder *encoder;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nbool dret = false;\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nencoder = radeon_best_single_encoder(connector);\r\nif (!encoder)\r\nret = connector_status_disconnected;\r\nif (radeon_connector->ddc_bus)\r\ndret = radeon_ddc_probe(radeon_connector, false);\r\nif (dret) {\r\nradeon_connector->detected_by_load = false;\r\nradeon_connector_free_edid(connector);\r\nradeon_connector_get_edid(connector);\r\nif (!radeon_connector->edid) {\r\nDRM_ERROR("%s: probed a monitor but no|invalid EDID\n",\r\nconnector->name);\r\nret = connector_status_connected;\r\n} else {\r\nradeon_connector->use_digital =\r\n!!(radeon_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\r\nif (radeon_connector->use_digital && radeon_connector->shared_ddc) {\r\nradeon_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n} else {\r\nret = connector_status_connected;\r\n}\r\n}\r\n} else {\r\nif (!force) {\r\nif (radeon_connector->detected_by_load)\r\nret = connector->status;\r\ngoto out;\r\n}\r\nif (radeon_connector->dac_load_detect && encoder) {\r\nencoder_funcs = encoder->helper_private;\r\nret = encoder_funcs->detect(encoder, connector);\r\nif (ret != connector_status_disconnected)\r\nradeon_connector->detected_by_load = true;\r\n}\r\n}\r\nif (ret == connector_status_connected)\r\nret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, true);\r\nif ((!rdev->is_atom_bios) &&\r\n(ret == connector_status_disconnected) &&\r\nrdev->mode_info.bios_hardcoded_edid_size) {\r\nret = connector_status_connected;\r\n}\r\nradeon_connector_update_scratch_regs(connector, ret);\r\nout:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic int radeon_tv_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_display_mode *tv_mode;\r\nstruct drm_encoder *encoder;\r\nencoder = radeon_best_single_encoder(connector);\r\nif (!encoder)\r\nreturn 0;\r\nif (rdev->family >= CHIP_RS600)\r\nradeon_add_common_modes(encoder, connector);\r\nelse {\r\ntv_mode = drm_cvt_mode(dev, 800, 600, 60, false, false, false);\r\ntv_mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, tv_mode);\r\n}\r\nreturn 1;\r\n}\r\nstatic int radeon_tv_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif ((mode->hdisplay > 1024) || (mode->vdisplay > 768))\r\nreturn MODE_CLOCK_RANGE;\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_tv_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nint r;\r\nif (!radeon_connector->dac_load_detect)\r\nreturn ret;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nencoder = radeon_best_single_encoder(connector);\r\nif (!encoder)\r\nret = connector_status_disconnected;\r\nelse {\r\nencoder_funcs = encoder->helper_private;\r\nret = encoder_funcs->detect(encoder, connector);\r\n}\r\nif (ret == connector_status_connected)\r\nret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, false);\r\nradeon_connector_update_scratch_regs(connector, ret);\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic bool radeon_check_hpd_status_unchanged(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nenum drm_connector_status status;\r\nif (rdev->family >= CHIP_R600\r\n&& radeon_connector->hpd.hpd != RADEON_HPD_NONE) {\r\nif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\nif (connector->status == status)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_dvi_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_encoder *encoder = NULL;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nint i, r;\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nbool dret = false, broken_edid = false;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (!force && radeon_check_hpd_status_unchanged(connector)) {\r\nret = connector->status;\r\ngoto exit;\r\n}\r\nif (radeon_connector->ddc_bus)\r\ndret = radeon_ddc_probe(radeon_connector, false);\r\nif (dret) {\r\nradeon_connector->detected_by_load = false;\r\nradeon_connector_free_edid(connector);\r\nradeon_connector_get_edid(connector);\r\nif (!radeon_connector->edid) {\r\nDRM_ERROR("%s: probed a monitor but no|invalid EDID\n",\r\nconnector->name);\r\nif ((rdev->family == CHIP_RS690 || rdev->family == CHIP_RS740) &&\r\nradeon_connector->base.null_edid_counter) {\r\nret = connector_status_disconnected;\r\nDRM_ERROR("%s: detected RS690 floating bus bug, stopping ddc detect\n",\r\nconnector->name);\r\nradeon_connector->ddc_bus = NULL;\r\n} else {\r\nret = connector_status_connected;\r\nbroken_edid = true;\r\n}\r\n} else {\r\nradeon_connector->use_digital =\r\n!!(radeon_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\r\nif ((!radeon_connector->use_digital) && radeon_connector->shared_ddc) {\r\nradeon_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n} else {\r\nret = connector_status_connected;\r\n}\r\nif (radeon_connector->shared_ddc && (ret == connector_status_connected)) {\r\nstruct drm_connector *list_connector;\r\nstruct radeon_connector *list_radeon_connector;\r\nlist_for_each_entry(list_connector, &dev->mode_config.connector_list, head) {\r\nif (connector == list_connector)\r\ncontinue;\r\nlist_radeon_connector = to_radeon_connector(list_connector);\r\nif (list_radeon_connector->shared_ddc &&\r\n(list_radeon_connector->ddc_bus->rec.i2c_id ==\r\nradeon_connector->ddc_bus->rec.i2c_id)) {\r\nif (list_connector->connector_type != DRM_MODE_CONNECTOR_VGA) {\r\nif (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {\r\nradeon_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif ((ret == connector_status_connected) && (radeon_connector->use_digital == true))\r\ngoto out;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_DVID) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))\r\ngoto out;\r\nif (!force) {\r\nif (radeon_connector->detected_by_load)\r\nret = connector->status;\r\ngoto out;\r\n}\r\nif (radeon_connector->dac_load_detect) {\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (encoder->encoder_type != DRM_MODE_ENCODER_DAC &&\r\nencoder->encoder_type != DRM_MODE_ENCODER_TVDAC)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->detect) {\r\nif (!broken_edid) {\r\nif (ret != connector_status_connected) {\r\nret = encoder_funcs->detect(encoder, connector);\r\nif (ret == connector_status_connected) {\r\nradeon_connector->use_digital = false;\r\n}\r\nif (ret != connector_status_disconnected)\r\nradeon_connector->detected_by_load = true;\r\n}\r\n} else {\r\nenum drm_connector_status lret;\r\nradeon_connector->use_digital = true;\r\nlret = encoder_funcs->detect(encoder, connector);\r\nDRM_DEBUG_KMS("load_detect %x returned: %x\n",encoder->encoder_type,lret);\r\nif (lret == connector_status_connected)\r\nradeon_connector->use_digital = false;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((ret == connector_status_connected) && (radeon_connector->use_digital == false) &&\r\nencoder) {\r\nret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, true);\r\n}\r\nout:\r\nif ((!rdev->is_atom_bios) &&\r\n(ret == connector_status_disconnected) &&\r\nrdev->mode_info.bios_hardcoded_edid_size) {\r\nradeon_connector->use_digital = true;\r\nret = connector_status_connected;\r\n}\r\nradeon_connector_update_scratch_regs(connector, ret);\r\nexit:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic struct drm_encoder *radeon_dvi_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct drm_encoder *encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (radeon_connector->use_digital == true) {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\r\nreturn encoder;\r\n} else {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_DAC ||\r\nencoder->encoder_type == DRM_MODE_ENCODER_TVDAC)\r\nreturn encoder;\r\n}\r\n}\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void radeon_dvi_force(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (connector->force == DRM_FORCE_ON)\r\nradeon_connector->use_digital = false;\r\nif (connector->force == DRM_FORCE_ON_DIGITAL)\r\nradeon_connector->use_digital = true;\r\n}\r\nstatic int radeon_dvi_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->use_digital &&\r\n(rdev->family == CHIP_RV100) &&\r\n(mode->clock > 135000))\r\nreturn MODE_CLOCK_HIGH;\r\nif (radeon_connector->use_digital && (mode->clock > 165000)) {\r\nif ((radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I) ||\r\n(radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D) ||\r\n(radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_HDMI_TYPE_B))\r\nreturn MODE_OK;\r\nelse if (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif (mode->clock > 340000)\r\nreturn MODE_CLOCK_HIGH;\r\nelse\r\nreturn MODE_OK;\r\n} else {\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\n}\r\nif ((mode->clock / 10) > rdev->clock.max_pixel_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic int radeon_dp_get_modes(struct drm_connector *connector)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nint ret;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nstruct drm_display_mode *mode;\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\r\nif (!radeon_dig_connector->edp_on)\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\nradeon_connector_get_edid(connector);\r\nret = radeon_ddc_get_modes(connector);\r\nif (!radeon_dig_connector->edp_on)\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_OFF);\r\n} else {\r\nif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\nif (encoder)\r\nradeon_atom_ext_encoder_setup_ddc(encoder);\r\n}\r\nradeon_connector_get_edid(connector);\r\nret = radeon_ddc_get_modes(connector);\r\n}\r\nif (ret > 0) {\r\nif (encoder) {\r\nradeon_fixup_lvds_native_mode(encoder, connector);\r\nradeon_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nif (!encoder)\r\nreturn 0;\r\nmode = radeon_fp_native_mode(encoder);\r\nif (mode) {\r\nret = 1;\r\ndrm_mode_probed_add(connector, mode);\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nradeon_add_common_modes(encoder, connector);\r\n}\r\n} else {\r\nif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\nif (encoder)\r\nradeon_atom_ext_encoder_setup_ddc(encoder);\r\n}\r\nradeon_connector_get_edid(connector);\r\nret = radeon_ddc_get_modes(connector);\r\nradeon_get_native_mode(connector);\r\n}\r\nreturn ret;\r\n}\r\nu16 radeon_connector_encoder_get_dp_bridge_encoder_id(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_TRAVIS:\r\ncase ENCODER_OBJECT_ID_NUTMEG:\r\nreturn radeon_encoder->encoder_id;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn ENCODER_OBJECT_ID_NONE;\r\n}\r\nstatic bool radeon_connector_encoder_is_hbr2(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nint i;\r\nbool found = false;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->caps & ATOM_ENCODER_CAP_RECORD_HBR2)\r\nfound = true;\r\n}\r\nreturn found;\r\n}\r\nbool radeon_connector_is_dp12_capable(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (ASIC_IS_DCE5(rdev) &&\r\n(rdev->clock.default_dispclk >= 53900) &&\r\nradeon_connector_encoder_is_hbr2(connector)) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\nradeon_dp_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (!force && radeon_check_hpd_status_unchanged(connector)) {\r\nret = connector->status;\r\ngoto out;\r\n}\r\nradeon_connector_free_edid(connector);\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nif (encoder) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\r\nret = connector_status_connected;\r\nif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\r\nret = connector_status_disconnected;\r\n}\r\nradeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\r\nif (!radeon_dig_connector->edp_on)\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\nif (radeon_dp_getdpcd(radeon_connector))\r\nret = connector_status_connected;\r\nif (!radeon_dig_connector->edp_on)\r\natombios_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_OFF);\r\n} else if (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\nradeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\r\nradeon_dp_getdpcd(radeon_connector);\r\nif (encoder) {\r\nradeon_atom_ext_encoder_setup_ddc(encoder);\r\nif (radeon_ddc_probe(radeon_connector, true))\r\nret = connector_status_connected;\r\nelse if (radeon_connector->dac_load_detect) {\r\nstruct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nret = encoder_funcs->detect(encoder, connector);\r\n}\r\n}\r\n} else {\r\nradeon_dig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);\r\nif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {\r\nret = connector_status_connected;\r\nif (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)\r\nradeon_dp_getdpcd(radeon_connector);\r\n} else {\r\nif (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\r\nif (radeon_dp_getdpcd(radeon_connector))\r\nret = connector_status_connected;\r\n} else {\r\nif (radeon_ddc_probe(radeon_connector, false))\r\nret = connector_status_connected;\r\n}\r\n}\r\n}\r\nradeon_connector_update_scratch_regs(connector, ret);\r\nout:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic int radeon_dp_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\r\nif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\r\nreturn MODE_PANEL;\r\nif (encoder) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\r\nif ((mode->hdisplay > native_mode->hdisplay) ||\r\n(mode->vdisplay > native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nif (radeon_encoder->rmx_type == RMX_OFF) {\r\nif ((mode->hdisplay != native_mode->hdisplay) ||\r\n(mode->vdisplay != native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\n}\r\n}\r\n} else {\r\nif ((radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\r\nreturn radeon_dp_mode_valid_helper(connector, mode);\r\n} else {\r\nif (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\r\nif (mode->clock > 340000)\r\nreturn MODE_CLOCK_HIGH;\r\n} else {\r\nif (mode->clock > 165000)\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\n}\r\n}\r\nreturn MODE_OK;\r\n}\r\nvoid\r\nradeon_add_atom_connector(struct drm_device *dev,\r\nuint32_t connector_id,\r\nuint32_t supported_device,\r\nint connector_type,\r\nstruct radeon_i2c_bus_rec *i2c_bus,\r\nuint32_t igp_lane_info,\r\nuint16_t connector_object_id,\r\nstruct radeon_hpd *hpd,\r\nstruct radeon_router *router)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nstruct radeon_connector_atom_dig *radeon_dig_connector;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nuint32_t subpixel_order = SubPixelNone;\r\nbool shared_ddc = false;\r\nbool is_dp_bridge = false;\r\nbool has_aux = false;\r\nif (connector_type == DRM_MODE_CONNECTOR_Unknown)\r\nreturn;\r\nif (((connector_type == DRM_MODE_CONNECTOR_SVIDEO) ||\r\n(connector_type == DRM_MODE_CONNECTOR_Composite) ||\r\n(connector_type == DRM_MODE_CONNECTOR_9PinDIN)) &&\r\n(radeon_tv == 0))\r\nreturn;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nradeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->connector_id == connector_id) {\r\nradeon_connector->devices |= supported_device;\r\nreturn;\r\n}\r\nif (radeon_connector->ddc_bus && i2c_bus->valid) {\r\nif (radeon_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {\r\nradeon_connector->shared_ddc = true;\r\nshared_ddc = true;\r\n}\r\nif (radeon_connector->router_bus && router->ddc_valid &&\r\n(radeon_connector->router.router_id == router->router_id)) {\r\nradeon_connector->shared_ddc = false;\r\nshared_ddc = false;\r\n}\r\n}\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nif (radeon_encoder->devices & supported_device) {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_TRAVIS:\r\ncase ENCODER_OBJECT_ID_NUTMEG:\r\nis_dp_bridge = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nradeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);\r\nif (!radeon_connector)\r\nreturn;\r\nconnector = &radeon_connector->base;\r\nradeon_connector->connector_id = connector_id;\r\nradeon_connector->devices = supported_device;\r\nradeon_connector->shared_ddc = shared_ddc;\r\nradeon_connector->connector_object_id = connector_object_id;\r\nradeon_connector->hpd = *hpd;\r\nradeon_connector->router = *router;\r\nif (router->ddc_valid || router->cd_valid) {\r\nradeon_connector->router_bus = radeon_i2c_lookup(rdev, &router->i2c_info);\r\nif (!radeon_connector->router_bus)\r\nDRM_ERROR("Failed to assign router i2c bus! Check dmesg for i2c errors.\n");\r\n}\r\nif (is_dp_bridge) {\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (radeon_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nswitch (connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ndefault:\r\ndrm_connector_init(dev, &radeon_connector->base,\r\n&radeon_dp_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base,\r\n&radeon_dp_connector_helper_funcs);\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ndrm_connector_init(dev, &radeon_connector->base,\r\n&radeon_dp_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base,\r\n&radeon_dp_connector_helper_funcs);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.dither_property,\r\nRADEON_FMT_DITHER_DISABLE);\r\nif (radeon_audio != 0)\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.audio_property,\r\nRADEON_AUDIO_AUTO);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII) {\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ndrm_connector_init(dev, &radeon_connector->base,\r\n&radeon_lvds_bridge_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base,\r\n&radeon_dp_connector_helper_funcs);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\n}\r\n} else {\r\nswitch (connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\nif (ASIC_IS_AVIVO(rdev))\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\nif (ASIC_IS_AVIVO(rdev))\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_dvi_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.coherent_mode_property,\r\n1);\r\nif (ASIC_IS_AVIVO(rdev)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.dither_property,\r\nRADEON_FMT_DITHER_DISABLE);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\n}\r\nif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.audio_property,\r\nRADEON_AUDIO_AUTO);\r\n}\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII) {\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\n}\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_dvi_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.coherent_mode_property,\r\n1);\r\nif (ASIC_IS_AVIVO(rdev)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.dither_property,\r\nRADEON_FMT_DITHER_DISABLE);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\n}\r\nif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.audio_property,\r\nRADEON_AUDIO_AUTO);\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_dp_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_dp_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (radeon_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.coherent_mode_property,\r\n1);\r\nif (ASIC_IS_AVIVO(rdev)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.dither_property,\r\nRADEON_FMT_DITHER_DISABLE);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\n}\r\nif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.audio_property,\r\nRADEON_AUDIO_AUTO);\r\n}\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_eDP:\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_edp_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_dp_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (radeon_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_tv_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_tv_connector_helper_funcs);\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.tv_std_property,\r\nradeon_atombios_get_tv_info(rdev));\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\nradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\r\nif (!radeon_dig_connector)\r\ngoto failed;\r\nradeon_dig_connector->igp_lane_info = igp_lane_info;\r\nradeon_connector->con_priv = radeon_dig_connector;\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_lvds_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_lvds_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\n}\r\n}\r\nif (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {\r\nif (i2c_bus->valid)\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\n} else\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nconnector->display_info.subpixel_order = subpixel_order;\r\ndrm_connector_register(connector);\r\nif (has_aux)\r\nradeon_dp_aux_init(radeon_connector);\r\nreturn;\r\nfailed:\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nvoid\r\nradeon_add_legacy_connector(struct drm_device *dev,\r\nuint32_t connector_id,\r\nuint32_t supported_device,\r\nint connector_type,\r\nstruct radeon_i2c_bus_rec *i2c_bus,\r\nuint16_t connector_object_id,\r\nstruct radeon_hpd *hpd)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nuint32_t subpixel_order = SubPixelNone;\r\nif (connector_type == DRM_MODE_CONNECTOR_Unknown)\r\nreturn;\r\nif (((connector_type == DRM_MODE_CONNECTOR_SVIDEO) ||\r\n(connector_type == DRM_MODE_CONNECTOR_Composite) ||\r\n(connector_type == DRM_MODE_CONNECTOR_9PinDIN)) &&\r\n(radeon_tv == 0))\r\nreturn;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nradeon_connector = to_radeon_connector(connector);\r\nif (radeon_connector->connector_id == connector_id) {\r\nradeon_connector->devices |= supported_device;\r\nreturn;\r\n}\r\n}\r\nradeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);\r\nif (!radeon_connector)\r\nreturn;\r\nconnector = &radeon_connector->base;\r\nradeon_connector->connector_id = connector_id;\r\nradeon_connector->devices = supported_device;\r\nradeon_connector->connector_object_id = connector_object_id;\r\nradeon_connector->hpd = *hpd;\r\nswitch (connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_vga_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_dvi_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII) {\r\nradeon_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\n1);\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_tv_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_tv_connector_helper_funcs);\r\nradeon_connector->dac_load_detect = true;\r\nif (rdev->family == CHIP_RS400 || rdev->family == CHIP_RS480)\r\nradeon_connector->dac_load_detect = false;\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.load_detect_property,\r\nradeon_connector->dac_load_detect);\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\nrdev->mode_info.tv_std_property,\r\nradeon_combios_get_tv_info(rdev));\r\nradeon_connector->hpd.hpd = RADEON_HPD_NONE;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\ndrm_connector_init(dev, &radeon_connector->base, &radeon_lvds_connector_funcs, connector_type);\r\ndrm_connector_helper_add(&radeon_connector->base, &radeon_lvds_connector_helper_funcs);\r\nif (i2c_bus->valid) {\r\nradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\r\nif (!radeon_connector->ddc_bus)\r\nDRM_ERROR("LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&radeon_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\n}\r\nif (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {\r\nif (i2c_bus->valid)\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\n} else\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nconnector->display_info.subpixel_order = subpixel_order;\r\ndrm_connector_register(connector);\r\n}
