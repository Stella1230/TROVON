static void __init pf_init_units(void)\r\n{\r\nstruct pf_unit *pf;\r\nint unit;\r\npf_drive_count = 0;\r\nfor (unit = 0, pf = units; unit < PF_UNITS; unit++, pf++) {\r\nstruct gendisk *disk = alloc_disk(1);\r\nif (!disk)\r\ncontinue;\r\npf->disk = disk;\r\npf->pi = &pf->pia;\r\npf->media_status = PF_NM;\r\npf->drive = (*drives[unit])[D_SLV];\r\npf->lun = (*drives[unit])[D_LUN];\r\nsnprintf(pf->name, PF_NAMELEN, "%s%d", name, unit);\r\ndisk->major = major;\r\ndisk->first_minor = unit;\r\nstrcpy(disk->disk_name, pf->name);\r\ndisk->fops = &pf_fops;\r\nif (!(*drives[unit])[D_PRT])\r\npf_drive_count++;\r\n}\r\n}\r\nstatic int pf_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct pf_unit *pf = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&pf_mutex);\r\npf_identify(pf);\r\nret = -ENODEV;\r\nif (pf->media_status == PF_NM)\r\ngoto out;\r\nret = -EROFS;\r\nif ((pf->media_status == PF_RO) && (mode & FMODE_WRITE))\r\ngoto out;\r\nret = 0;\r\npf->access++;\r\nif (pf->removable)\r\npf_lock(pf, 1);\r\nout:\r\nmutex_unlock(&pf_mutex);\r\nreturn ret;\r\n}\r\nstatic int pf_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct pf_unit *pf = bdev->bd_disk->private_data;\r\nsector_t capacity = get_capacity(pf->disk);\r\nif (capacity < PF_FD_MAX) {\r\ngeo->cylinders = sector_div(capacity, PF_FD_HDS * PF_FD_SPT);\r\ngeo->heads = PF_FD_HDS;\r\ngeo->sectors = PF_FD_SPT;\r\n} else {\r\ngeo->cylinders = sector_div(capacity, PF_HD_HDS * PF_HD_SPT);\r\ngeo->heads = PF_HD_HDS;\r\ngeo->sectors = PF_HD_SPT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pf_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct pf_unit *pf = bdev->bd_disk->private_data;\r\nif (cmd != CDROMEJECT)\r\nreturn -EINVAL;\r\nif (pf->access != 1)\r\nreturn -EBUSY;\r\nmutex_lock(&pf_mutex);\r\npf_eject(pf);\r\nmutex_unlock(&pf_mutex);\r\nreturn 0;\r\n}\r\nstatic void pf_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct pf_unit *pf = disk->private_data;\r\nmutex_lock(&pf_mutex);\r\nif (pf->access <= 0) {\r\nmutex_unlock(&pf_mutex);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npf->access--;\r\nif (!pf->access && pf->removable)\r\npf_lock(pf, 0);\r\nmutex_unlock(&pf_mutex);\r\n}\r\nstatic unsigned int pf_check_events(struct gendisk *disk, unsigned int clearing)\r\n{\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nstatic inline int status_reg(struct pf_unit *pf)\r\n{\r\nreturn pi_read_regr(pf->pi, 1, 6);\r\n}\r\nstatic inline int read_reg(struct pf_unit *pf, int reg)\r\n{\r\nreturn pi_read_regr(pf->pi, 0, reg);\r\n}\r\nstatic inline void write_reg(struct pf_unit *pf, int reg, int val)\r\n{\r\npi_write_regr(pf->pi, 0, reg, val);\r\n}\r\nstatic int pf_wait(struct pf_unit *pf, int go, int stop, char *fun, char *msg)\r\n{\r\nint j, r, e, s, p;\r\nj = 0;\r\nwhile ((((r = status_reg(pf)) & go) || (stop && (!(r & stop))))\r\n&& (j++ < PF_SPIN))\r\nudelay(PF_SPIN_DEL);\r\nif ((r & (STAT_ERR & stop)) || (j > PF_SPIN)) {\r\ns = read_reg(pf, 7);\r\ne = read_reg(pf, 1);\r\np = read_reg(pf, 2);\r\nif (j > PF_SPIN)\r\ne |= 0x100;\r\nif (fun)\r\nprintk("%s: %s %s: alt=0x%x stat=0x%x err=0x%x"\r\n" loop=%d phase=%d\n",\r\npf->name, fun, msg, r, s, e, j, p);\r\nreturn (e << 8) + s;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pf_command(struct pf_unit *pf, char *cmd, int dlen, char *fun)\r\n{\r\npi_connect(pf->pi);\r\nwrite_reg(pf, 6, 0xa0+0x10*pf->drive);\r\nif (pf_wait(pf, STAT_BUSY | STAT_DRQ, 0, fun, "before command")) {\r\npi_disconnect(pf->pi);\r\nreturn -1;\r\n}\r\nwrite_reg(pf, 4, dlen % 256);\r\nwrite_reg(pf, 5, dlen / 256);\r\nwrite_reg(pf, 7, 0xa0);\r\nif (pf_wait(pf, STAT_BUSY, STAT_DRQ, fun, "command DRQ")) {\r\npi_disconnect(pf->pi);\r\nreturn -1;\r\n}\r\nif (read_reg(pf, 2) != 1) {\r\nprintk("%s: %s: command phase error\n", pf->name, fun);\r\npi_disconnect(pf->pi);\r\nreturn -1;\r\n}\r\npi_write_block(pf->pi, cmd, 12);\r\nreturn 0;\r\n}\r\nstatic int pf_completion(struct pf_unit *pf, char *buf, char *fun)\r\n{\r\nint r, s, n;\r\nr = pf_wait(pf, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\r\nfun, "completion");\r\nif ((read_reg(pf, 2) & 2) && (read_reg(pf, 7) & STAT_DRQ)) {\r\nn = (((read_reg(pf, 4) + 256 * read_reg(pf, 5)) +\r\n3) & 0xfffc);\r\npi_read_block(pf->pi, buf, n);\r\n}\r\ns = pf_wait(pf, STAT_BUSY, STAT_READY | STAT_ERR, fun, "data done");\r\npi_disconnect(pf->pi);\r\nreturn (r ? r : s);\r\n}\r\nstatic void pf_req_sense(struct pf_unit *pf, int quiet)\r\n{\r\nchar rs_cmd[12] =\r\n{ ATAPI_REQ_SENSE, pf->lun << 5, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[16];\r\nint r;\r\nr = pf_command(pf, rs_cmd, 16, "Request sense");\r\nmdelay(1);\r\nif (!r)\r\npf_completion(pf, buf, "Request sense");\r\nif ((!r) && (!quiet))\r\nprintk("%s: Sense key: %x, ASC: %x, ASQ: %x\n",\r\npf->name, buf[2] & 0xf, buf[12], buf[13]);\r\n}\r\nstatic int pf_atapi(struct pf_unit *pf, char *cmd, int dlen, char *buf, char *fun)\r\n{\r\nint r;\r\nr = pf_command(pf, cmd, dlen, fun);\r\nmdelay(1);\r\nif (!r)\r\nr = pf_completion(pf, buf, fun);\r\nif (r)\r\npf_req_sense(pf, !fun);\r\nreturn r;\r\n}\r\nstatic void pf_lock(struct pf_unit *pf, int func)\r\n{\r\nchar lo_cmd[12] = { ATAPI_LOCK, pf->lun << 5, 0, 0, func, 0, 0, 0, 0, 0, 0, 0 };\r\npf_atapi(pf, lo_cmd, 0, pf_scratch, func ? "lock" : "unlock");\r\n}\r\nstatic void pf_eject(struct pf_unit *pf)\r\n{\r\nchar ej_cmd[12] = { ATAPI_DOOR, pf->lun << 5, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 };\r\npf_lock(pf, 0);\r\npf_atapi(pf, ej_cmd, 0, pf_scratch, "eject");\r\n}\r\nstatic void pf_sleep(int cs)\r\n{\r\nschedule_timeout_interruptible(cs);\r\n}\r\nstatic int pf_reset(struct pf_unit *pf)\r\n{\r\nint i, k, flg;\r\nint expect[5] = { 1, 1, 1, 0x14, 0xeb };\r\npi_connect(pf->pi);\r\nwrite_reg(pf, 6, 0xa0+0x10*pf->drive);\r\nwrite_reg(pf, 7, 8);\r\npf_sleep(20 * HZ / 1000);\r\nk = 0;\r\nwhile ((k++ < PF_RESET_TMO) && (status_reg(pf) & STAT_BUSY))\r\npf_sleep(HZ / 10);\r\nflg = 1;\r\nfor (i = 0; i < 5; i++)\r\nflg &= (read_reg(pf, i + 1) == expect[i]);\r\nif (verbose) {\r\nprintk("%s: Reset (%d) signature = ", pf->name, k);\r\nfor (i = 0; i < 5; i++)\r\nprintk("%3x", read_reg(pf, i + 1));\r\nif (!flg)\r\nprintk(" (incorrect)");\r\nprintk("\n");\r\n}\r\npi_disconnect(pf->pi);\r\nreturn flg - 1;\r\n}\r\nstatic void pf_mode_sense(struct pf_unit *pf)\r\n{\r\nchar ms_cmd[12] =\r\n{ ATAPI_MODE_SENSE, pf->lun << 5, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0 };\r\nchar buf[8];\r\npf_atapi(pf, ms_cmd, 8, buf, "mode sense");\r\npf->media_status = PF_RW;\r\nif (buf[3] & 0x80)\r\npf->media_status = PF_RO;\r\n}\r\nstatic void xs(char *buf, char *targ, int offs, int len)\r\n{\r\nint j, k, l;\r\nj = 0;\r\nl = 0;\r\nfor (k = 0; k < len; k++)\r\nif ((buf[k + offs] != 0x20) || (buf[k + offs] != l))\r\nl = targ[j++] = buf[k + offs];\r\nif (l == 0x20)\r\nj--;\r\ntarg[j] = 0;\r\n}\r\nstatic int xl(char *buf, int offs)\r\n{\r\nint v, k;\r\nv = 0;\r\nfor (k = 0; k < 4; k++)\r\nv = v * 256 + (buf[k + offs] & 0xff);\r\nreturn v;\r\n}\r\nstatic void pf_get_capacity(struct pf_unit *pf)\r\n{\r\nchar rc_cmd[12] = { ATAPI_CAPACITY, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[8];\r\nint bs;\r\nif (pf_atapi(pf, rc_cmd, 8, buf, "get capacity")) {\r\npf->media_status = PF_NM;\r\nreturn;\r\n}\r\nset_capacity(pf->disk, xl(buf, 0) + 1);\r\nbs = xl(buf, 4);\r\nif (bs != 512) {\r\nset_capacity(pf->disk, 0);\r\nif (verbose)\r\nprintk("%s: Drive %d, LUN %d,"\r\n" unsupported block size %d\n",\r\npf->name, pf->drive, pf->lun, bs);\r\n}\r\n}\r\nstatic int pf_identify(struct pf_unit *pf)\r\n{\r\nint dt, s;\r\nchar *ms[2] = { "master", "slave" };\r\nchar mf[10], id[18];\r\nchar id_cmd[12] =\r\n{ ATAPI_IDENTIFY, pf->lun << 5, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[36];\r\ns = pf_atapi(pf, id_cmd, 36, buf, "identify");\r\nif (s)\r\nreturn -1;\r\ndt = buf[0] & 0x1f;\r\nif ((dt != 0) && (dt != 7)) {\r\nif (verbose)\r\nprintk("%s: Drive %d, LUN %d, unsupported type %d\n",\r\npf->name, pf->drive, pf->lun, dt);\r\nreturn -1;\r\n}\r\nxs(buf, mf, 8, 8);\r\nxs(buf, id, 16, 16);\r\npf->removable = (buf[1] & 0x80);\r\npf_mode_sense(pf);\r\npf_mode_sense(pf);\r\npf_mode_sense(pf);\r\npf_get_capacity(pf);\r\nprintk("%s: %s %s, %s LUN %d, type %d",\r\npf->name, mf, id, ms[pf->drive], pf->lun, dt);\r\nif (pf->removable)\r\nprintk(", removable");\r\nif (pf->media_status == PF_NM)\r\nprintk(", no media\n");\r\nelse {\r\nif (pf->media_status == PF_RO)\r\nprintk(", RO");\r\nprintk(", %llu blocks\n",\r\n(unsigned long long)get_capacity(pf->disk));\r\n}\r\nreturn 0;\r\n}\r\nstatic int pf_probe(struct pf_unit *pf)\r\n{\r\nif (pf->drive == -1) {\r\nfor (pf->drive = 0; pf->drive <= 1; pf->drive++)\r\nif (!pf_reset(pf)) {\r\nif (pf->lun != -1)\r\nreturn pf_identify(pf);\r\nelse\r\nfor (pf->lun = 0; pf->lun < 8; pf->lun++)\r\nif (!pf_identify(pf))\r\nreturn 0;\r\n}\r\n} else {\r\nif (pf_reset(pf))\r\nreturn -1;\r\nif (pf->lun != -1)\r\nreturn pf_identify(pf);\r\nfor (pf->lun = 0; pf->lun < 8; pf->lun++)\r\nif (!pf_identify(pf))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int pf_detect(void)\r\n{\r\nstruct pf_unit *pf = units;\r\nint k, unit;\r\nprintk("%s: %s version %s, major %d, cluster %d, nice %d\n",\r\nname, name, PF_VERSION, major, cluster, nice);\r\nk = 0;\r\nif (pf_drive_count == 0) {\r\nif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\r\nverbose, pf->name)) {\r\nif (!pf_probe(pf) && pf->disk) {\r\npf->present = 1;\r\nk++;\r\n} else\r\npi_release(pf->pi);\r\n}\r\n} else\r\nfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\r\nint *conf = *drives[unit];\r\nif (!conf[D_PRT])\r\ncontinue;\r\nif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\r\nconf[D_UNI], conf[D_PRO], conf[D_DLY],\r\npf_scratch, PI_PF, verbose, pf->name)) {\r\nif (pf->disk && !pf_probe(pf)) {\r\npf->present = 1;\r\nk++;\r\n} else\r\npi_release(pf->pi);\r\n}\r\n}\r\nif (k)\r\nreturn 0;\r\nprintk("%s: No ATAPI disk detected\n", name);\r\nfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\r\nput_disk(pf->disk);\r\nreturn -1;\r\n}\r\nstatic int pf_start(struct pf_unit *pf, int cmd, int b, int c)\r\n{\r\nint i;\r\nchar io_cmd[12] = { cmd, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nfor (i = 0; i < 4; i++) {\r\nio_cmd[5 - i] = b & 0xff;\r\nb = b >> 8;\r\n}\r\nio_cmd[8] = c & 0xff;\r\nio_cmd[7] = (c >> 8) & 0xff;\r\ni = pf_command(pf, io_cmd, c * 512, "start i/o");\r\nmdelay(1);\r\nreturn i;\r\n}\r\nstatic int pf_ready(void)\r\n{\r\nreturn (((status_reg(pf_current) & (STAT_BUSY | pf_mask)) == pf_mask));\r\n}\r\nstatic void pf_end_request(int err)\r\n{\r\nif (pf_req && !__blk_end_request_cur(pf_req, err))\r\npf_req = NULL;\r\n}\r\nstatic void do_pf_request(struct request_queue * q)\r\n{\r\nif (pf_busy)\r\nreturn;\r\nrepeat:\r\nif (!pf_req) {\r\npf_req = blk_fetch_request(q);\r\nif (!pf_req)\r\nreturn;\r\n}\r\npf_current = pf_req->rq_disk->private_data;\r\npf_block = blk_rq_pos(pf_req);\r\npf_run = blk_rq_sectors(pf_req);\r\npf_count = blk_rq_cur_sectors(pf_req);\r\nif (pf_block + pf_count > get_capacity(pf_req->rq_disk)) {\r\npf_end_request(-EIO);\r\ngoto repeat;\r\n}\r\npf_cmd = rq_data_dir(pf_req);\r\npf_buf = bio_data(pf_req->bio);\r\npf_retries = 0;\r\npf_busy = 1;\r\nif (pf_cmd == READ)\r\npi_do_claimed(pf_current->pi, do_pf_read);\r\nelse if (pf_cmd == WRITE)\r\npi_do_claimed(pf_current->pi, do_pf_write);\r\nelse {\r\npf_busy = 0;\r\npf_end_request(-EIO);\r\ngoto repeat;\r\n}\r\n}\r\nstatic int pf_next_buf(void)\r\n{\r\nunsigned long saved_flags;\r\npf_count--;\r\npf_run--;\r\npf_buf += 512;\r\npf_block++;\r\nif (!pf_run)\r\nreturn 1;\r\nif (!pf_count) {\r\nspin_lock_irqsave(&pf_spin_lock, saved_flags);\r\npf_end_request(0);\r\nspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\r\nif (!pf_req)\r\nreturn 1;\r\npf_count = blk_rq_cur_sectors(pf_req);\r\npf_buf = bio_data(pf_req->bio);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void next_request(int err)\r\n{\r\nunsigned long saved_flags;\r\nspin_lock_irqsave(&pf_spin_lock, saved_flags);\r\npf_end_request(err);\r\npf_busy = 0;\r\ndo_pf_request(pf_queue);\r\nspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\r\n}\r\nstatic void do_pf_read(void)\r\n{\r\nps_set_intr(do_pf_read_start, NULL, 0, nice);\r\n}\r\nstatic void do_pf_read_start(void)\r\n{\r\npf_busy = 1;\r\nif (pf_start(pf_current, ATAPI_READ_10, pf_block, pf_run)) {\r\npi_disconnect(pf_current->pi);\r\nif (pf_retries < PF_MAX_RETRIES) {\r\npf_retries++;\r\npi_do_claimed(pf_current->pi, do_pf_read_start);\r\nreturn;\r\n}\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\npf_mask = STAT_DRQ;\r\nps_set_intr(do_pf_read_drq, pf_ready, PF_TMO, nice);\r\n}\r\nstatic void do_pf_read_drq(void)\r\n{\r\nwhile (1) {\r\nif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\r\n"read block", "completion") & STAT_ERR) {\r\npi_disconnect(pf_current->pi);\r\nif (pf_retries < PF_MAX_RETRIES) {\r\npf_req_sense(pf_current, 0);\r\npf_retries++;\r\npi_do_claimed(pf_current->pi, do_pf_read_start);\r\nreturn;\r\n}\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\npi_read_block(pf_current->pi, pf_buf, 512);\r\nif (pf_next_buf())\r\nbreak;\r\n}\r\npi_disconnect(pf_current->pi);\r\nnext_request(0);\r\n}\r\nstatic void do_pf_write(void)\r\n{\r\nps_set_intr(do_pf_write_start, NULL, 0, nice);\r\n}\r\nstatic void do_pf_write_start(void)\r\n{\r\npf_busy = 1;\r\nif (pf_start(pf_current, ATAPI_WRITE_10, pf_block, pf_run)) {\r\npi_disconnect(pf_current->pi);\r\nif (pf_retries < PF_MAX_RETRIES) {\r\npf_retries++;\r\npi_do_claimed(pf_current->pi, do_pf_write_start);\r\nreturn;\r\n}\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\nwhile (1) {\r\nif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\r\n"write block", "data wait") & STAT_ERR) {\r\npi_disconnect(pf_current->pi);\r\nif (pf_retries < PF_MAX_RETRIES) {\r\npf_retries++;\r\npi_do_claimed(pf_current->pi, do_pf_write_start);\r\nreturn;\r\n}\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\npi_write_block(pf_current->pi, pf_buf, 512);\r\nif (pf_next_buf())\r\nbreak;\r\n}\r\npf_mask = 0;\r\nps_set_intr(do_pf_write_done, pf_ready, PF_TMO, nice);\r\n}\r\nstatic void do_pf_write_done(void)\r\n{\r\nif (pf_wait(pf_current, STAT_BUSY, 0, "write block", "done") & STAT_ERR) {\r\npi_disconnect(pf_current->pi);\r\nif (pf_retries < PF_MAX_RETRIES) {\r\npf_retries++;\r\npi_do_claimed(pf_current->pi, do_pf_write_start);\r\nreturn;\r\n}\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\npi_disconnect(pf_current->pi);\r\nnext_request(0);\r\n}\r\nstatic int __init pf_init(void)\r\n{\r\nstruct pf_unit *pf;\r\nint unit;\r\nif (disable)\r\nreturn -EINVAL;\r\npf_init_units();\r\nif (pf_detect())\r\nreturn -ENODEV;\r\npf_busy = 0;\r\nif (register_blkdev(major, name)) {\r\nfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\r\nput_disk(pf->disk);\r\nreturn -EBUSY;\r\n}\r\npf_queue = blk_init_queue(do_pf_request, &pf_spin_lock);\r\nif (!pf_queue) {\r\nunregister_blkdev(major, name);\r\nfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\r\nput_disk(pf->disk);\r\nreturn -ENOMEM;\r\n}\r\nblk_queue_max_segments(pf_queue, cluster);\r\nfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\r\nstruct gendisk *disk = pf->disk;\r\nif (!pf->present)\r\ncontinue;\r\ndisk->private_data = pf;\r\ndisk->queue = pf_queue;\r\nadd_disk(disk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pf_exit(void)\r\n{\r\nstruct pf_unit *pf;\r\nint unit;\r\nunregister_blkdev(major, name);\r\nfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\r\nif (!pf->present)\r\ncontinue;\r\ndel_gendisk(pf->disk);\r\nput_disk(pf->disk);\r\npi_release(pf->pi);\r\n}\r\nblk_cleanup_queue(pf_queue);\r\n}
