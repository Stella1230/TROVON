static unsigned long clk_cpu_recalc_rate(struct clk_hw *hwclk,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\r\nu32 reg, div;\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\r\ndiv = (reg >> (cpuclk->cpu * 8)) & SYS_CTRL_CLK_DIVIDER_MASK;\r\nreturn parent_rate / div;\r\n}\r\nstatic long clk_cpu_round_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 div;\r\ndiv = *parent_rate / rate;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > 3)\r\ndiv = 3;\r\nreturn *parent_rate / div;\r\n}\r\nstatic int clk_cpu_off_set_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\r\nu32 reg, div;\r\nu32 reload_mask;\r\ndiv = parent_rate / rate;\r\nreg = (readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET)\r\n& (~(SYS_CTRL_CLK_DIVIDER_MASK << (cpuclk->cpu * 8))))\r\n| (div << (cpuclk->cpu * 8));\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\r\nreload_mask = 1 << (20 + cpuclk->cpu);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\r\n| reload_mask;\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\r\n| 1 << 24;\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nudelay(1000);\r\nreg &= ~(reload_mask | 1 << 24);\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nstatic int clk_cpu_on_set_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu32 reg;\r\nunsigned long fabric_div, target_div, cur_rate;\r\nstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\r\nif (!cpuclk->pmu_dfs)\r\nreturn -ENODEV;\r\ncur_rate = __clk_get_rate(hwclk->clk);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL2_OFFSET);\r\nfabric_div = (reg >> SYS_CTRL_CLK_DIVIDER_CTRL2_NBCLK_RATIO_SHIFT) &\r\nSYS_CTRL_CLK_DIVIDER_MASK;\r\nif (rate == 2 * cur_rate)\r\ntarget_div = fabric_div / 2;\r\nelse\r\ntarget_div = fabric_div;\r\nif (target_div == 0)\r\ntarget_div = 1;\r\nreg = readl(cpuclk->pmu_dfs);\r\nreg &= ~(PMU_DFS_RATIO_MASK << PMU_DFS_RATIO_SHIFT);\r\nreg |= (target_div << PMU_DFS_RATIO_SHIFT);\r\nwritel(reg, cpuclk->pmu_dfs);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nreg |= (SYS_CTRL_CLK_DIVIDER_CTRL_RESET_ALL <<\r\nSYS_CTRL_CLK_DIVIDER_CTRL_RESET_SHIFT);\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nreturn mvebu_pmsu_dfs_request(cpuclk->cpu);\r\n}\r\nstatic int clk_cpu_set_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nif (__clk_is_enabled(hwclk->clk))\r\nreturn clk_cpu_on_set_rate(hwclk, rate, parent_rate);\r\nelse\r\nreturn clk_cpu_off_set_rate(hwclk, rate, parent_rate);\r\n}\r\nstatic void __init of_cpu_clk_setup(struct device_node *node)\r\n{\r\nstruct cpu_clk *cpuclk;\r\nvoid __iomem *clock_complex_base = of_iomap(node, 0);\r\nvoid __iomem *pmu_dfs_base = of_iomap(node, 1);\r\nint ncpus = 0;\r\nstruct device_node *dn;\r\nif (clock_complex_base == NULL) {\r\npr_err("%s: clock-complex base register not set\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (pmu_dfs_base == NULL)\r\npr_warn("%s: pmu-dfs base register not set, dynamic frequency scaling not available\n",\r\n__func__);\r\nfor_each_node_by_type(dn, "cpu")\r\nncpus++;\r\ncpuclk = kzalloc(ncpus * sizeof(*cpuclk), GFP_KERNEL);\r\nif (WARN_ON(!cpuclk))\r\ngoto cpuclk_out;\r\nclks = kzalloc(ncpus * sizeof(*clks), GFP_KERNEL);\r\nif (WARN_ON(!clks))\r\ngoto clks_out;\r\nfor_each_node_by_type(dn, "cpu") {\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nstruct clk *parent_clk;\r\nchar *clk_name = kzalloc(5, GFP_KERNEL);\r\nint cpu, err;\r\nif (WARN_ON(!clk_name))\r\ngoto bail_out;\r\nerr = of_property_read_u32(dn, "reg", &cpu);\r\nif (WARN_ON(err))\r\ngoto bail_out;\r\nsprintf(clk_name, "cpu%d", cpu);\r\nparent_clk = of_clk_get(node, 0);\r\ncpuclk[cpu].parent_name = __clk_get_name(parent_clk);\r\ncpuclk[cpu].clk_name = clk_name;\r\ncpuclk[cpu].cpu = cpu;\r\ncpuclk[cpu].reg_base = clock_complex_base;\r\nif (pmu_dfs_base)\r\ncpuclk[cpu].pmu_dfs = pmu_dfs_base + 4 * cpu;\r\ncpuclk[cpu].hw.init = &init;\r\ninit.name = cpuclk[cpu].clk_name;\r\ninit.ops = &cpu_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &cpuclk[cpu].parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(NULL, &cpuclk[cpu].hw);\r\nif (WARN_ON(IS_ERR(clk)))\r\ngoto bail_out;\r\nclks[cpu] = clk;\r\n}\r\nclk_data.clk_num = MAX_CPU;\r\nclk_data.clks = clks;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, &clk_data);\r\nreturn;\r\nbail_out:\r\nkfree(clks);\r\nwhile(ncpus--)\r\nkfree(cpuclk[ncpus].clk_name);\r\nclks_out:\r\nkfree(cpuclk);\r\ncpuclk_out:\r\niounmap(clock_complex_base);\r\n}
