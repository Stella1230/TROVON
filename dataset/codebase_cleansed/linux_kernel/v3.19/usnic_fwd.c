static int usnic_fwd_devcmd_locked(struct usnic_fwd_dev *ufdev, int vnic_idx,\r\nenum vnic_devcmd_cmd cmd, u64 *a0,\r\nu64 *a1)\r\n{\r\nint status;\r\nstruct net_device *netdev = ufdev->netdev;\r\nlockdep_assert_held(&ufdev->lock);\r\nstatus = enic_api_devcmd_proxy_by_index(netdev,\r\nvnic_idx,\r\ncmd,\r\na0, a1,\r\n1000);\r\nif (status) {\r\nif (status == ERR_EINVAL && cmd == CMD_DEL_FILTER) {\r\nusnic_dbg("Dev %s vnic idx %u cmd %u already deleted",\r\nufdev->name, vnic_idx, cmd);\r\n} else {\r\nusnic_err("Dev %s vnic idx %u cmd %u failed with status %d\n",\r\nufdev->name, vnic_idx, cmd,\r\nstatus);\r\n}\r\n} else {\r\nusnic_dbg("Dev %s vnic idx %u cmd %u success",\r\nufdev->name, vnic_idx, cmd);\r\n}\r\nreturn status;\r\n}\r\nstatic int usnic_fwd_devcmd(struct usnic_fwd_dev *ufdev, int vnic_idx,\r\nenum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1)\r\n{\r\nint status;\r\nspin_lock(&ufdev->lock);\r\nstatus = usnic_fwd_devcmd_locked(ufdev, vnic_idx, cmd, a0, a1);\r\nspin_unlock(&ufdev->lock);\r\nreturn status;\r\n}\r\nstruct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)\r\n{\r\nstruct usnic_fwd_dev *ufdev;\r\nufdev = kzalloc(sizeof(*ufdev), GFP_KERNEL);\r\nif (!ufdev)\r\nreturn NULL;\r\nufdev->pdev = pdev;\r\nufdev->netdev = pci_get_drvdata(pdev);\r\nspin_lock_init(&ufdev->lock);\r\nstrncpy(ufdev->name, netdev_name(ufdev->netdev),\r\nsizeof(ufdev->name) - 1);\r\nreturn ufdev;\r\n}\r\nvoid usnic_fwd_dev_free(struct usnic_fwd_dev *ufdev)\r\n{\r\nkfree(ufdev);\r\n}\r\nvoid usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN])\r\n{\r\nspin_lock(&ufdev->lock);\r\nmemcpy(&ufdev->mac, mac, sizeof(ufdev->mac));\r\nspin_unlock(&ufdev->lock);\r\n}\r\nint usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)\r\n{\r\nint status;\r\nspin_lock(&ufdev->lock);\r\nif (ufdev->inaddr == 0) {\r\nufdev->inaddr = inaddr;\r\nstatus = 0;\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nspin_unlock(&ufdev->lock);\r\nreturn status;\r\n}\r\nvoid usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev)\r\n{\r\nspin_lock(&ufdev->lock);\r\nufdev->inaddr = 0;\r\nspin_unlock(&ufdev->lock);\r\n}\r\nvoid usnic_fwd_carrier_up(struct usnic_fwd_dev *ufdev)\r\n{\r\nspin_lock(&ufdev->lock);\r\nufdev->link_up = 1;\r\nspin_unlock(&ufdev->lock);\r\n}\r\nvoid usnic_fwd_carrier_down(struct usnic_fwd_dev *ufdev)\r\n{\r\nspin_lock(&ufdev->lock);\r\nufdev->link_up = 0;\r\nspin_unlock(&ufdev->lock);\r\n}\r\nvoid usnic_fwd_set_mtu(struct usnic_fwd_dev *ufdev, unsigned int mtu)\r\n{\r\nspin_lock(&ufdev->lock);\r\nufdev->mtu = mtu;\r\nspin_unlock(&ufdev->lock);\r\n}\r\nstatic int usnic_fwd_dev_ready_locked(struct usnic_fwd_dev *ufdev)\r\n{\r\nlockdep_assert_held(&ufdev->lock);\r\nif (!ufdev->link_up)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int validate_filter_locked(struct usnic_fwd_dev *ufdev,\r\nstruct filter *filter)\r\n{\r\nlockdep_assert_held(&ufdev->lock);\r\nif (filter->type == FILTER_IPV4_5TUPLE) {\r\nif (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_AD))\r\nreturn -EACCES;\r\nif (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_PT))\r\nreturn -EBUSY;\r\nelse if (ufdev->inaddr == 0)\r\nreturn -EINVAL;\r\nelse if (filter->u.ipv4.dst_port == 0)\r\nreturn -ERANGE;\r\nelse if (ntohl(ufdev->inaddr) != filter->u.ipv4.dst_addr)\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fill_tlv(struct filter_tlv *tlv, struct filter *filter,\r\nstruct filter_action *action)\r\n{\r\ntlv->type = CLSF_TLV_FILTER;\r\ntlv->length = sizeof(struct filter);\r\n*((struct filter *)&tlv->val) = *filter;\r\ntlv = (struct filter_tlv *)((char *)tlv + sizeof(struct filter_tlv) +\r\nsizeof(struct filter));\r\ntlv->type = CLSF_TLV_ACTION;\r\ntlv->length = sizeof(struct filter_action);\r\n*((struct filter_action *)&tlv->val) = *action;\r\n}\r\nstruct usnic_fwd_flow*\r\nusnic_fwd_alloc_flow(struct usnic_fwd_dev *ufdev, struct filter *filter,\r\nstruct usnic_filter_action *uaction)\r\n{\r\nstruct filter_tlv *tlv;\r\nstruct pci_dev *pdev;\r\nstruct usnic_fwd_flow *flow;\r\nuint64_t a0, a1;\r\nuint64_t tlv_size;\r\ndma_addr_t tlv_pa;\r\nint status;\r\npdev = ufdev->pdev;\r\ntlv_size = (2*sizeof(struct filter_tlv) + sizeof(struct filter) +\r\nsizeof(struct filter_action));\r\nflow = kzalloc(sizeof(*flow), GFP_ATOMIC);\r\nif (!flow)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = pci_alloc_consistent(pdev, tlv_size, &tlv_pa);\r\nif (!tlv) {\r\nusnic_err("Failed to allocate memory\n");\r\nstatus = -ENOMEM;\r\ngoto out_free_flow;\r\n}\r\nfill_tlv(tlv, filter, &uaction->action);\r\nspin_lock(&ufdev->lock);\r\nstatus = usnic_fwd_dev_ready_locked(ufdev);\r\nif (status) {\r\nusnic_err("Forwarding dev %s not ready with status %d\n",\r\nufdev->name, status);\r\ngoto out_free_tlv;\r\n}\r\nstatus = validate_filter_locked(ufdev, filter);\r\nif (status) {\r\nusnic_err("Failed to validate filter with status %d\n",\r\nstatus);\r\ngoto out_free_tlv;\r\n}\r\na0 = tlv_pa;\r\na1 = tlv_size;\r\nstatus = usnic_fwd_devcmd_locked(ufdev, uaction->vnic_idx,\r\nCMD_ADD_FILTER, &a0, &a1);\r\nif (status) {\r\nusnic_err("VF %s Filter add failed with status:%d",\r\nufdev->name, status);\r\nstatus = -EFAULT;\r\ngoto out_free_tlv;\r\n} else {\r\nusnic_dbg("VF %s FILTER ID:%llu", ufdev->name, a0);\r\n}\r\nflow->flow_id = (uint32_t) a0;\r\nflow->vnic_idx = uaction->vnic_idx;\r\nflow->ufdev = ufdev;\r\nout_free_tlv:\r\nspin_unlock(&ufdev->lock);\r\npci_free_consistent(pdev, tlv_size, tlv, tlv_pa);\r\nif (!status)\r\nreturn flow;\r\nout_free_flow:\r\nkfree(flow);\r\nreturn ERR_PTR(status);\r\n}\r\nint usnic_fwd_dealloc_flow(struct usnic_fwd_flow *flow)\r\n{\r\nint status;\r\nu64 a0, a1;\r\na0 = flow->flow_id;\r\nstatus = usnic_fwd_devcmd(flow->ufdev, flow->vnic_idx,\r\nCMD_DEL_FILTER, &a0, &a1);\r\nif (status) {\r\nif (status == ERR_EINVAL) {\r\nusnic_dbg("Filter %u already deleted for VF Idx %u pf: %s status: %d",\r\nflow->flow_id, flow->vnic_idx,\r\nflow->ufdev->name, status);\r\n} else {\r\nusnic_err("PF %s VF Idx %u Filter: %u FILTER DELETE failed with status %d",\r\nflow->ufdev->name, flow->vnic_idx,\r\nflow->flow_id, status);\r\n}\r\nstatus = 0;\r\n} else {\r\nusnic_dbg("PF %s VF Idx %u Filter: %u FILTER DELETED",\r\nflow->ufdev->name, flow->vnic_idx,\r\nflow->flow_id);\r\n}\r\nkfree(flow);\r\nreturn status;\r\n}\r\nint usnic_fwd_enable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)\r\n{\r\nint status;\r\nstruct net_device *pf_netdev;\r\nu64 a0, a1;\r\npf_netdev = ufdev->netdev;\r\na0 = qp_idx;\r\na1 = CMD_QP_RQWQ;\r\nstatus = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_ENABLE,\r\n&a0, &a1);\r\nif (status) {\r\nusnic_err("PF %s VNIC Index %u RQ Index: %u ENABLE Failed with status %d",\r\nnetdev_name(pf_netdev),\r\nvnic_idx,\r\nqp_idx,\r\nstatus);\r\n} else {\r\nusnic_dbg("PF %s VNIC Index %u RQ Index: %u ENABLED",\r\nnetdev_name(pf_netdev),\r\nvnic_idx, qp_idx);\r\n}\r\nreturn status;\r\n}\r\nint usnic_fwd_disable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)\r\n{\r\nint status;\r\nu64 a0, a1;\r\nstruct net_device *pf_netdev;\r\npf_netdev = ufdev->netdev;\r\na0 = qp_idx;\r\na1 = CMD_QP_RQWQ;\r\nstatus = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_DISABLE,\r\n&a0, &a1);\r\nif (status) {\r\nusnic_err("PF %s VNIC Index %u RQ Index: %u DISABLE Failed with status %d",\r\nnetdev_name(pf_netdev),\r\nvnic_idx,\r\nqp_idx,\r\nstatus);\r\n} else {\r\nusnic_dbg("PF %s VNIC Index %u RQ Index: %u DISABLED",\r\nnetdev_name(pf_netdev),\r\nvnic_idx,\r\nqp_idx);\r\n}\r\nreturn status;\r\n}
