void efi_printk(efi_system_table_t *sys_table_arg, char *str)\r\n{\r\nchar *s8;\r\nfor (s8 = str; *s8; s8++) {\r\nefi_char16_t ch[2] = { 0 };\r\nch[0] = *s8;\r\nif (*s8 == '\n') {\r\nefi_char16_t nl[2] = { '\r', 0 };\r\nefi_char16_printk(sys_table_arg, nl);\r\n}\r\nefi_char16_printk(sys_table_arg, ch);\r\n}\r\n}\r\nefi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,\r\nefi_memory_desc_t **map,\r\nunsigned long *map_size,\r\nunsigned long *desc_size,\r\nu32 *desc_ver,\r\nunsigned long *key_ptr)\r\n{\r\nefi_memory_desc_t *m = NULL;\r\nefi_status_t status;\r\nunsigned long key;\r\nu32 desc_version;\r\n*map_size = sizeof(*m) * 32;\r\nagain:\r\n*map_size += sizeof(*m);\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\n*map_size, (void **)&m);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\n*desc_size = 0;\r\nkey = 0;\r\nstatus = efi_call_early(get_memory_map, map_size, m,\r\n&key, desc_size, &desc_version);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_early(free_pool, m);\r\ngoto again;\r\n}\r\nif (status != EFI_SUCCESS)\r\nefi_call_early(free_pool, m);\r\nif (key_ptr && status == EFI_SUCCESS)\r\n*key_ptr = key;\r\nif (desc_ver && status == EFI_SUCCESS)\r\n*desc_ver = desc_version;\r\nfail:\r\n*map = m;\r\nreturn status;\r\n}\r\nunsigned long __init get_dram_base(efi_system_table_t *sys_table_arg)\r\n{\r\nefi_status_t status;\r\nunsigned long map_size;\r\nunsigned long membase = EFI_ERROR;\r\nstruct efi_memory_map map;\r\nefi_memory_desc_t *md;\r\nstatus = efi_get_memory_map(sys_table_arg, (efi_memory_desc_t **)&map.map,\r\n&map_size, &map.desc_size, NULL, NULL);\r\nif (status != EFI_SUCCESS)\r\nreturn membase;\r\nmap.map_end = map.map + map_size;\r\nfor_each_efi_memory_desc(&map, md)\r\nif (md->attribute & EFI_MEMORY_WB)\r\nif (membase > md->phys_addr)\r\nmembase = md->phys_addr;\r\nefi_call_early(free_pool, map.map);\r\nreturn membase;\r\n}\r\nefi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,\r\nunsigned long size, unsigned long align,\r\nunsigned long *addr, unsigned long max)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nu64 max_addr = 0;\r\nint i;\r\nstatus = efi_get_memory_map(sys_table_arg, &map, &map_size, &desc_size,\r\nNULL, NULL);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nif (align < EFI_PAGE_SIZE)\r\nalign = EFI_PAGE_SIZE;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nagain:\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif ((start + size) > end || (start + size) > max)\r\ncontinue;\r\nif (end - size > max)\r\nend = max;\r\nif (round_down(end - size, align) < start)\r\ncontinue;\r\nstart = round_down(end - size, align);\r\nif (start == 0x0)\r\ncontinue;\r\nif (start > max_addr)\r\nmax_addr = start;\r\n}\r\nif (!max_addr)\r\nstatus = EFI_NOT_FOUND;\r\nelse {\r\nstatus = efi_call_early(allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &max_addr);\r\nif (status != EFI_SUCCESS) {\r\nmax = max_addr;\r\nmax_addr = 0;\r\ngoto again;\r\n}\r\n*addr = max_addr;\r\n}\r\nefi_call_early(free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nefi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,\r\nunsigned long size, unsigned long align,\r\nunsigned long *addr)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nint i;\r\nstatus = efi_get_memory_map(sys_table_arg, &map, &map_size, &desc_size,\r\nNULL, NULL);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nif (align < EFI_PAGE_SIZE)\r\nalign = EFI_PAGE_SIZE;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif (start == 0x0)\r\nstart += 8;\r\nstart = round_up(start, align);\r\nif ((start + size) > end)\r\ncontinue;\r\nstatus = efi_call_early(allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &start);\r\nif (status == EFI_SUCCESS) {\r\n*addr = start;\r\nbreak;\r\n}\r\n}\r\nif (i == map_size / desc_size)\r\nstatus = EFI_NOT_FOUND;\r\nefi_call_early(free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nvoid efi_free(efi_system_table_t *sys_table_arg, unsigned long size,\r\nunsigned long addr)\r\n{\r\nunsigned long nr_pages;\r\nif (!size)\r\nreturn;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nefi_call_early(free_pages, addr, nr_pages);\r\n}\r\nefi_status_t efi_parse_options(char *cmdline)\r\n{\r\nchar *str;\r\nstr = strstr(cmdline, "efi=");\r\nif (!str)\r\nreturn EFI_SUCCESS;\r\nstr += strlen("efi=");\r\nwhile (*str) {\r\nif (!strncmp(str, "nochunk", 7)) {\r\nstr += strlen("nochunk");\r\n__chunk_size = -1UL;\r\n}\r\nwhile (*str && *str != ',')\r\nstr++;\r\nif (*str == ',')\r\nstr++;\r\n}\r\nreturn EFI_SUCCESS;\r\n}\r\nefi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,\r\nefi_loaded_image_t *image,\r\nchar *cmd_line, char *option_string,\r\nunsigned long max_addr,\r\nunsigned long *load_addr,\r\nunsigned long *load_size)\r\n{\r\nstruct file_info *files;\r\nunsigned long file_addr;\r\nu64 file_size_total;\r\nefi_file_handle_t *fh = NULL;\r\nefi_status_t status;\r\nint nr_files;\r\nchar *str;\r\nint i, j, k;\r\nfile_addr = 0;\r\nfile_size_total = 0;\r\nstr = cmd_line;\r\nj = 0;\r\nif (!load_addr || !load_size)\r\nreturn EFI_INVALID_PARAMETER;\r\n*load_addr = 0;\r\n*load_size = 0;\r\nif (!str || !*str)\r\nreturn EFI_SUCCESS;\r\nfor (nr_files = 0; *str; nr_files++) {\r\nstr = strstr(str, option_string);\r\nif (!str)\r\nbreak;\r\nstr += strlen(option_string);\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n')\r\nstr++;\r\n}\r\nif (!nr_files)\r\nreturn EFI_SUCCESS;\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\nnr_files * sizeof(*files), (void **)&files);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "Failed to alloc mem for file handle list\n");\r\ngoto fail;\r\n}\r\nstr = cmd_line;\r\nfor (i = 0; i < nr_files; i++) {\r\nstruct file_info *file;\r\nefi_char16_t filename_16[256];\r\nefi_char16_t *p;\r\nstr = strstr(str, option_string);\r\nif (!str)\r\nbreak;\r\nstr += strlen(option_string);\r\nfile = &files[i];\r\np = filename_16;\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n') {\r\nif ((u8 *)p >= (u8 *)filename_16 + sizeof(filename_16))\r\nbreak;\r\nif (*str == '/') {\r\n*p++ = '\\';\r\nstr++;\r\n} else {\r\n*p++ = *str++;\r\n}\r\n}\r\n*p = '\0';\r\nif (!i) {\r\nstatus = efi_open_volume(sys_table_arg, image,\r\n(void **)&fh);\r\nif (status != EFI_SUCCESS)\r\ngoto free_files;\r\n}\r\nstatus = efi_file_size(sys_table_arg, fh, filename_16,\r\n(void **)&file->handle, &file->size);\r\nif (status != EFI_SUCCESS)\r\ngoto close_handles;\r\nfile_size_total += file->size;\r\n}\r\nif (file_size_total) {\r\nunsigned long addr;\r\nstatus = efi_high_alloc(sys_table_arg, file_size_total, 0x1000,\r\n&file_addr, max_addr);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "Failed to alloc highmem for files\n");\r\ngoto close_handles;\r\n}\r\nif (file_addr > max_addr) {\r\npr_efi_err(sys_table_arg, "We've run out of free low memory\n");\r\nstatus = EFI_INVALID_PARAMETER;\r\ngoto free_file_total;\r\n}\r\naddr = file_addr;\r\nfor (j = 0; j < nr_files; j++) {\r\nunsigned long size;\r\nsize = files[j].size;\r\nwhile (size) {\r\nunsigned long chunksize;\r\nif (size > __chunk_size)\r\nchunksize = __chunk_size;\r\nelse\r\nchunksize = size;\r\nstatus = efi_file_read(files[j].handle,\r\n&chunksize,\r\n(void *)addr);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "Failed to read file\n");\r\ngoto free_file_total;\r\n}\r\naddr += chunksize;\r\nsize -= chunksize;\r\n}\r\nefi_file_close(files[j].handle);\r\n}\r\n}\r\nefi_call_early(free_pool, files);\r\n*load_addr = file_addr;\r\n*load_size = file_size_total;\r\nreturn status;\r\nfree_file_total:\r\nefi_free(sys_table_arg, file_size_total, file_addr);\r\nclose_handles:\r\nfor (k = j; k < i; k++)\r\nefi_file_close(files[k].handle);\r\nfree_files:\r\nefi_call_early(free_pool, files);\r\nfail:\r\n*load_addr = 0;\r\n*load_size = 0;\r\nreturn status;\r\n}\r\nefi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,\r\nunsigned long *image_addr,\r\nunsigned long image_size,\r\nunsigned long alloc_size,\r\nunsigned long preferred_addr,\r\nunsigned long alignment)\r\n{\r\nunsigned long cur_image_addr;\r\nunsigned long new_addr = 0;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nefi_physical_addr_t efi_addr = preferred_addr;\r\nif (!image_addr || !image_size || !alloc_size)\r\nreturn EFI_INVALID_PARAMETER;\r\nif (alloc_size < image_size)\r\nreturn EFI_INVALID_PARAMETER;\r\ncur_image_addr = *image_addr;\r\nnr_pages = round_up(alloc_size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nstatus = efi_call_early(allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &efi_addr);\r\nnew_addr = efi_addr;\r\nif (status != EFI_SUCCESS) {\r\nstatus = efi_low_alloc(sys_table_arg, alloc_size, alignment,\r\n&new_addr);\r\n}\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "Failed to allocate usable memory for kernel.\n");\r\nreturn status;\r\n}\r\nmemcpy((void *)new_addr, (void *)cur_image_addr, image_size);\r\n*image_addr = new_addr;\r\nreturn status;\r\n}\r\nstatic int efi_utf8_bytes(u16 c)\r\n{\r\nreturn 1 + (c >= 0x80) + (c >= 0x800);\r\n}\r\nstatic u8 *efi_utf16_to_utf8(u8 *dst, const u16 *src, int n)\r\n{\r\nunsigned int c;\r\nwhile (n--) {\r\nc = *src++;\r\nif (n && c >= 0xd800 && c <= 0xdbff &&\r\n*src >= 0xdc00 && *src <= 0xdfff) {\r\nc = 0x10000 + ((c & 0x3ff) << 10) + (*src & 0x3ff);\r\nsrc++;\r\nn--;\r\n}\r\nif (c >= 0xd800 && c <= 0xdfff)\r\nc = 0xfffd;\r\nif (c < 0x80) {\r\n*dst++ = c;\r\ncontinue;\r\n}\r\nif (c < 0x800) {\r\n*dst++ = 0xc0 + (c >> 6);\r\ngoto t1;\r\n}\r\nif (c < 0x10000) {\r\n*dst++ = 0xe0 + (c >> 12);\r\ngoto t2;\r\n}\r\n*dst++ = 0xf0 + (c >> 18);\r\n*dst++ = 0x80 + ((c >> 12) & 0x3f);\r\nt2:\r\n*dst++ = 0x80 + ((c >> 6) & 0x3f);\r\nt1:\r\n*dst++ = 0x80 + (c & 0x3f);\r\n}\r\nreturn dst;\r\n}\r\nchar *efi_convert_cmdline(efi_system_table_t *sys_table_arg,\r\nefi_loaded_image_t *image,\r\nint *cmd_line_len)\r\n{\r\nconst u16 *s2;\r\nu8 *s1 = NULL;\r\nunsigned long cmdline_addr = 0;\r\nint load_options_chars = image->load_options_size / 2;\r\nconst u16 *options = image->load_options;\r\nint options_bytes = 0;\r\nint options_chars = 0;\r\nefi_status_t status;\r\nu16 zero = 0;\r\nif (options) {\r\ns2 = options;\r\nwhile (*s2 && *s2 != '\n'\r\n&& options_chars < load_options_chars) {\r\noptions_bytes += efi_utf8_bytes(*s2++);\r\noptions_chars++;\r\n}\r\n}\r\nif (!options_chars) {\r\noptions = &zero;\r\n}\r\noptions_bytes++;\r\nstatus = efi_low_alloc(sys_table_arg, options_bytes, 0, &cmdline_addr);\r\nif (status != EFI_SUCCESS)\r\nreturn NULL;\r\ns1 = (u8 *)cmdline_addr;\r\ns2 = (const u16 *)options;\r\ns1 = efi_utf16_to_utf8(s1, s2, options_chars);\r\n*s1 = '\0';\r\n*cmd_line_len = options_bytes;\r\nreturn (char *)cmdline_addr;\r\n}
