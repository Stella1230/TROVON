static void print_stat(struct intel_dsi *intel_dsi)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 val;\r\nval = I915_READ(MIPI_INTR_STAT(pipe));\r\n#define STAT_BIT(val, bit) (val) & (bit) ? " " #bit : ""\r\nDRM_DEBUG_KMS("MIPI_INTR_STAT(%d) = %08x"\r\n"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"\r\n"\n", pipe, val,\r\nSTAT_BIT(val, TEARING_EFFECT),\r\nSTAT_BIT(val, SPL_PKT_SENT_INTERRUPT),\r\nSTAT_BIT(val, GEN_READ_DATA_AVAIL),\r\nSTAT_BIT(val, LP_GENERIC_WR_FIFO_FULL),\r\nSTAT_BIT(val, HS_GENERIC_WR_FIFO_FULL),\r\nSTAT_BIT(val, RX_PROT_VIOLATION),\r\nSTAT_BIT(val, RX_INVALID_TX_LENGTH),\r\nSTAT_BIT(val, ACK_WITH_NO_ERROR),\r\nSTAT_BIT(val, TURN_AROUND_ACK_TIMEOUT),\r\nSTAT_BIT(val, LP_RX_TIMEOUT),\r\nSTAT_BIT(val, HS_TX_TIMEOUT),\r\nSTAT_BIT(val, DPI_FIFO_UNDERRUN),\r\nSTAT_BIT(val, LOW_CONTENTION),\r\nSTAT_BIT(val, HIGH_CONTENTION),\r\nSTAT_BIT(val, TXDSI_VC_ID_INVALID),\r\nSTAT_BIT(val, TXDSI_DATA_TYPE_NOT_RECOGNISED),\r\nSTAT_BIT(val, TXCHECKSUM_ERROR),\r\nSTAT_BIT(val, TXECC_MULTIBIT_ERROR),\r\nSTAT_BIT(val, TXECC_SINGLE_BIT_ERROR),\r\nSTAT_BIT(val, TXFALSE_CONTROL_ERROR),\r\nSTAT_BIT(val, RXDSI_VC_ID_INVALID),\r\nSTAT_BIT(val, RXDSI_DATA_TYPE_NOT_REGOGNISED),\r\nSTAT_BIT(val, RXCHECKSUM_ERROR),\r\nSTAT_BIT(val, RXECC_MULTIBIT_ERROR),\r\nSTAT_BIT(val, RXECC_SINGLE_BIT_ERROR),\r\nSTAT_BIT(val, RXFALSE_CONTROL_ERROR),\r\nSTAT_BIT(val, RXHS_RECEIVE_TIMEOUT_ERROR),\r\nSTAT_BIT(val, RX_LP_TX_SYNC_ERROR),\r\nSTAT_BIT(val, RXEXCAPE_MODE_ENTRY_ERROR),\r\nSTAT_BIT(val, RXEOT_SYNC_ERROR),\r\nSTAT_BIT(val, RXSOT_SYNC_ERROR),\r\nSTAT_BIT(val, RXSOT_ERROR));\r\n#undef STAT_BIT\r\n}\r\nvoid dsi_hs_mode_enable(struct intel_dsi *intel_dsi, bool enable)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 temp;\r\nu32 mask = DBI_FIFO_EMPTY;\r\nif (wait_for((I915_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == mask, 50))\r\nDRM_ERROR("Timeout waiting for DBI FIFO empty\n");\r\ntemp = I915_READ(MIPI_HS_LP_DBI_ENABLE(pipe));\r\ntemp &= DBI_HS_LP_MODE_MASK;\r\nI915_WRITE(MIPI_HS_LP_DBI_ENABLE(pipe), enable ? DBI_HS_MODE : DBI_LP_MODE);\r\nintel_dsi->hs = enable;\r\n}\r\nstatic int dsi_vc_send_short(struct intel_dsi *intel_dsi, int channel,\r\nu8 data_type, u16 data)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 ctrl_reg;\r\nu32 ctrl;\r\nu32 mask;\r\nDRM_DEBUG_KMS("channel %d, data_type %d, data %04x\n",\r\nchannel, data_type, data);\r\nif (intel_dsi->hs) {\r\nctrl_reg = MIPI_HS_GEN_CTRL(pipe);\r\nmask = HS_CTRL_FIFO_FULL;\r\n} else {\r\nctrl_reg = MIPI_LP_GEN_CTRL(pipe);\r\nmask = LP_CTRL_FIFO_FULL;\r\n}\r\nif (wait_for((I915_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == 0, 50)) {\r\nDRM_ERROR("Timeout waiting for HS/LP CTRL FIFO !full\n");\r\nprint_stat(intel_dsi);\r\n}\r\nctrl = data << SHORT_PACKET_PARAM_SHIFT |\r\nchannel << VIRTUAL_CHANNEL_SHIFT |\r\ndata_type << DATA_TYPE_SHIFT;\r\nI915_WRITE(ctrl_reg, ctrl);\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_send_long(struct intel_dsi *intel_dsi, int channel,\r\nu8 data_type, const u8 *data, int len)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 data_reg;\r\nint i, j, n;\r\nu32 mask;\r\nDRM_DEBUG_KMS("channel %d, data_type %d, len %04x\n",\r\nchannel, data_type, len);\r\nif (intel_dsi->hs) {\r\ndata_reg = MIPI_HS_GEN_DATA(pipe);\r\nmask = HS_DATA_FIFO_FULL;\r\n} else {\r\ndata_reg = MIPI_LP_GEN_DATA(pipe);\r\nmask = LP_DATA_FIFO_FULL;\r\n}\r\nif (wait_for((I915_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == 0, 50))\r\nDRM_ERROR("Timeout waiting for HS/LP DATA FIFO !full\n");\r\nfor (i = 0; i < len; i += n) {\r\nu32 val = 0;\r\nn = min_t(int, len - i, 4);\r\nfor (j = 0; j < n; j++)\r\nval |= *data++ << 8 * j;\r\nI915_WRITE(data_reg, val);\r\n}\r\nreturn dsi_vc_send_short(intel_dsi, channel, data_type, len);\r\n}\r\nstatic int dsi_vc_write_common(struct intel_dsi *intel_dsi,\r\nint channel, const u8 *data, int len,\r\nenum dsi_type type)\r\n{\r\nint ret;\r\nif (len == 0) {\r\nBUG_ON(type == DSI_GENERIC);\r\nret = dsi_vc_send_short(intel_dsi, channel,\r\nMIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM,\r\n0);\r\n} else if (len == 1) {\r\nret = dsi_vc_send_short(intel_dsi, channel,\r\ntype == DSI_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE, data[0]);\r\n} else if (len == 2) {\r\nret = dsi_vc_send_short(intel_dsi, channel,\r\ntype == DSI_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE_PARAM,\r\n(data[1] << 8) | data[0]);\r\n} else {\r\nret = dsi_vc_send_long(intel_dsi, channel,\r\ntype == DSI_GENERIC ?\r\nMIPI_DSI_GENERIC_LONG_WRITE :\r\nMIPI_DSI_DCS_LONG_WRITE, data, len);\r\n}\r\nreturn ret;\r\n}\r\nint dsi_vc_dcs_write(struct intel_dsi *intel_dsi, int channel,\r\nconst u8 *data, int len)\r\n{\r\nreturn dsi_vc_write_common(intel_dsi, channel, data, len, DSI_DCS);\r\n}\r\nint dsi_vc_generic_write(struct intel_dsi *intel_dsi, int channel,\r\nconst u8 *data, int len)\r\n{\r\nreturn dsi_vc_write_common(intel_dsi, channel, data, len, DSI_GENERIC);\r\n}\r\nstatic int dsi_vc_dcs_send_read_request(struct intel_dsi *intel_dsi,\r\nint channel, u8 dcs_cmd)\r\n{\r\nreturn dsi_vc_send_short(intel_dsi, channel, MIPI_DSI_DCS_READ,\r\ndcs_cmd);\r\n}\r\nstatic int dsi_vc_generic_send_read_request(struct intel_dsi *intel_dsi,\r\nint channel, u8 *reqdata,\r\nint reqlen)\r\n{\r\nu16 data;\r\nu8 data_type;\r\nswitch (reqlen) {\r\ncase 0:\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\r\ndata = 0;\r\nbreak;\r\ncase 1:\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\r\ndata = reqdata[0];\r\nbreak;\r\ncase 2:\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\r\ndata = (reqdata[1] << 8) | reqdata[0];\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn dsi_vc_send_short(intel_dsi, channel, data_type, data);\r\n}\r\nstatic int dsi_read_data_return(struct intel_dsi *intel_dsi,\r\nu8 *buf, int buflen)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nint i, len = 0;\r\nu32 data_reg, val;\r\nif (intel_dsi->hs) {\r\ndata_reg = MIPI_HS_GEN_DATA(pipe);\r\n} else {\r\ndata_reg = MIPI_LP_GEN_DATA(pipe);\r\n}\r\nwhile (len < buflen) {\r\nval = I915_READ(data_reg);\r\nfor (i = 0; i < 4 && len < buflen; i++, len++)\r\nbuf[len] = val >> 8 * i;\r\n}\r\nreturn len;\r\n}\r\nint dsi_vc_dcs_read(struct intel_dsi *intel_dsi, int channel, u8 dcs_cmd,\r\nu8 *buf, int buflen)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 mask;\r\nint ret;\r\nI915_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);\r\nret = dsi_vc_dcs_send_read_request(intel_dsi, channel, dcs_cmd);\r\nif (ret)\r\nreturn ret;\r\nmask = GEN_READ_DATA_AVAIL;\r\nif (wait_for((I915_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))\r\nDRM_ERROR("Timeout waiting for read data.\n");\r\nret = dsi_read_data_return(intel_dsi, buf, buflen);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != buflen)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint dsi_vc_generic_read(struct intel_dsi *intel_dsi, int channel,\r\nu8 *reqdata, int reqlen, u8 *buf, int buflen)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 mask;\r\nint ret;\r\nI915_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);\r\nret = dsi_vc_generic_send_read_request(intel_dsi, channel, reqdata,\r\nreqlen);\r\nif (ret)\r\nreturn ret;\r\nmask = GEN_READ_DATA_AVAIL;\r\nif (wait_for((I915_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))\r\nDRM_ERROR("Timeout waiting for read data.\n");\r\nret = dsi_read_data_return(intel_dsi, buf, buflen);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != buflen)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint dpi_send_cmd(struct intel_dsi *intel_dsi, u32 cmd, bool hs)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 mask;\r\nif (hs)\r\ncmd &= ~DPI_LP_MODE;\r\nelse\r\ncmd |= DPI_LP_MODE;\r\nI915_WRITE(MIPI_INTR_STAT(pipe), SPL_PKT_SENT_INTERRUPT);\r\nif (cmd == I915_READ(MIPI_DPI_CONTROL(pipe)))\r\nDRM_ERROR("Same special packet %02x twice in a row.\n", cmd);\r\nI915_WRITE(MIPI_DPI_CONTROL(pipe), cmd);\r\nmask = SPL_PKT_SENT_INTERRUPT;\r\nif (wait_for((I915_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 100))\r\nDRM_ERROR("Video mode command 0x%08x send failed.\n", cmd);\r\nreturn 0;\r\n}\r\nvoid wait_for_dsi_fifo_empty(struct intel_dsi *intel_dsi)\r\n{\r\nstruct drm_encoder *encoder = &intel_dsi->base.base;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 mask;\r\nmask = LP_CTRL_FIFO_EMPTY | HS_CTRL_FIFO_EMPTY |\r\nLP_DATA_FIFO_EMPTY | HS_DATA_FIFO_EMPTY;\r\nif (wait_for((I915_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == mask, 100))\r\nDRM_ERROR("DPI FIFOs are not empty\n");\r\n}
