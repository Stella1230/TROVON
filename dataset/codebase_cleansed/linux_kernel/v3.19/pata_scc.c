static void scc_set_piomode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int pio = adev->pio_mode - XFER_PIO_0;\r\nvoid __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];\r\nvoid __iomem *cckctrl_port = ctrl_base + SCC_CTL_CCKCTRL;\r\nvoid __iomem *piosht_port = ctrl_base + SCC_CTL_PIOSHT;\r\nvoid __iomem *pioct_port = ctrl_base + SCC_CTL_PIOCT;\r\nunsigned long reg;\r\nint offset;\r\nreg = in_be32(cckctrl_port);\r\nif (reg & CCKCTRL_ATACLKOEN)\r\noffset = 1;\r\nelse\r\noffset = 0;\r\nreg = JCHSTtbl[offset][pio] << 16 | JCHHTtbl[offset][pio];\r\nout_be32(piosht_port, reg);\r\nreg = JCHCTtbl[offset][pio];\r\nout_be32(pioct_port, reg);\r\n}\r\nstatic void scc_set_dmamode (struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int udma = adev->dma_mode;\r\nunsigned int is_slave = (adev->devno != 0);\r\nu8 speed = udma;\r\nvoid __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];\r\nvoid __iomem *cckctrl_port = ctrl_base + SCC_CTL_CCKCTRL;\r\nvoid __iomem *mdmact_port = ctrl_base + SCC_CTL_MDMACT;\r\nvoid __iomem *mcrcst_port = ctrl_base + SCC_CTL_MCRCST;\r\nvoid __iomem *sdmact_port = ctrl_base + SCC_CTL_SDMACT;\r\nvoid __iomem *scrcst_port = ctrl_base + SCC_CTL_SCRCST;\r\nvoid __iomem *udenvt_port = ctrl_base + SCC_CTL_UDENVT;\r\nvoid __iomem *tdvhsel_port = ctrl_base + SCC_CTL_TDVHSEL;\r\nint offset, idx;\r\nif (in_be32(cckctrl_port) & CCKCTRL_ATACLKOEN)\r\noffset = 1;\r\nelse\r\noffset = 0;\r\nif (speed >= XFER_UDMA_0)\r\nidx = speed - XFER_UDMA_0;\r\nelse\r\nreturn;\r\nif (is_slave) {\r\nout_be32(sdmact_port, JCHDCTxtbl[offset][idx]);\r\nout_be32(scrcst_port, JCSTWTxtbl[offset][idx]);\r\nout_be32(tdvhsel_port,\r\n(in_be32(tdvhsel_port) & ~TDVHSEL_SLAVE) | (JCACTSELtbl[offset][idx] << 2));\r\n} else {\r\nout_be32(mdmact_port, JCHDCTxtbl[offset][idx]);\r\nout_be32(mcrcst_port, JCSTWTxtbl[offset][idx]);\r\nout_be32(tdvhsel_port,\r\n(in_be32(tdvhsel_port) & ~TDVHSEL_MASTER) | JCACTSELtbl[offset][idx]);\r\n}\r\nout_be32(udenvt_port,\r\nJCTSStbl[offset][idx] << 16 | JCENVTtbl[offset][idx]);\r\n}\r\nunsigned long scc_mode_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (adev->class == ATA_DEV_ATAPI &&\r\n(mask & (0xE0 << ATA_SHIFT_UDMA))) {\r\nprintk(KERN_INFO "%s: limit ATAPI UDMA to UDMA4\n", DRV_NAME);\r\nmask &= ~(0xE0 << ATA_SHIFT_UDMA);\r\n}\r\nreturn mask;\r\n}\r\nstatic void scc_tf_load (struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nif (tf->ctl != ap->last_ctl) {\r\nout_be32(ioaddr->ctl_addr, tf->ctl);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\nout_be32(ioaddr->feature_addr, tf->hob_feature);\r\nout_be32(ioaddr->nsect_addr, tf->hob_nsect);\r\nout_be32(ioaddr->lbal_addr, tf->hob_lbal);\r\nout_be32(ioaddr->lbam_addr, tf->hob_lbam);\r\nout_be32(ioaddr->lbah_addr, tf->hob_lbah);\r\nVPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",\r\ntf->hob_feature,\r\ntf->hob_nsect,\r\ntf->hob_lbal,\r\ntf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nif (is_addr) {\r\nout_be32(ioaddr->feature_addr, tf->feature);\r\nout_be32(ioaddr->nsect_addr, tf->nsect);\r\nout_be32(ioaddr->lbal_addr, tf->lbal);\r\nout_be32(ioaddr->lbam_addr, tf->lbam);\r\nout_be32(ioaddr->lbah_addr, tf->lbah);\r\nVPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",\r\ntf->feature,\r\ntf->nsect,\r\ntf->lbal,\r\ntf->lbam,\r\ntf->lbah);\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE) {\r\nout_be32(ioaddr->device_addr, tf->device);\r\nVPRINTK("device 0x%X\n", tf->device);\r\n}\r\nata_wait_idle(ap);\r\n}\r\nstatic u8 scc_check_status (struct ata_port *ap)\r\n{\r\nreturn in_be32(ap->ioaddr.status_addr);\r\n}\r\nstatic void scc_tf_read (struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\ntf->command = scc_check_status(ap);\r\ntf->feature = in_be32(ioaddr->error_addr);\r\ntf->nsect = in_be32(ioaddr->nsect_addr);\r\ntf->lbal = in_be32(ioaddr->lbal_addr);\r\ntf->lbam = in_be32(ioaddr->lbam_addr);\r\ntf->lbah = in_be32(ioaddr->lbah_addr);\r\ntf->device = in_be32(ioaddr->device_addr);\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\nout_be32(ioaddr->ctl_addr, tf->ctl | ATA_HOB);\r\ntf->hob_feature = in_be32(ioaddr->error_addr);\r\ntf->hob_nsect = in_be32(ioaddr->nsect_addr);\r\ntf->hob_lbal = in_be32(ioaddr->lbal_addr);\r\ntf->hob_lbam = in_be32(ioaddr->lbam_addr);\r\ntf->hob_lbah = in_be32(ioaddr->lbah_addr);\r\nout_be32(ioaddr->ctl_addr, tf->ctl);\r\nap->last_ctl = tf->ctl;\r\n}\r\n}\r\nstatic void scc_exec_command (struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nDPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);\r\nout_be32(ap->ioaddr.command_addr, tf->command);\r\nata_sff_pause(ap);\r\n}\r\nstatic u8 scc_check_altstatus (struct ata_port *ap)\r\n{\r\nreturn in_be32(ap->ioaddr.altstatus_addr);\r\n}\r\nstatic void scc_dev_select (struct ata_port *ap, unsigned int device)\r\n{\r\nu8 tmp;\r\nif (device == 0)\r\ntmp = ATA_DEVICE_OBS;\r\nelse\r\ntmp = ATA_DEVICE_OBS | ATA_DEV1;\r\nout_be32(ap->ioaddr.device_addr, tmp);\r\nata_sff_pause(ap);\r\n}\r\nstatic void scc_set_devctl(struct ata_port *ap, u8 ctl)\r\n{\r\nout_be32(ap->ioaddr.ctl_addr, ctl);\r\n}\r\nstatic void scc_bmdma_setup (struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\r\nu8 dmactl;\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\nout_be32(mmio + SCC_DMA_TABLE_OFS, ap->bmdma_prd_dma);\r\ndmactl = in_be32(mmio + SCC_DMA_CMD);\r\ndmactl &= ~(ATA_DMA_WR | ATA_DMA_START);\r\nif (!rw)\r\ndmactl |= ATA_DMA_WR;\r\nout_be32(mmio + SCC_DMA_CMD, dmactl);\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\n}\r\nstatic void scc_bmdma_start (struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nu8 dmactl;\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\ndmactl = in_be32(mmio + SCC_DMA_CMD);\r\nout_be32(mmio + SCC_DMA_CMD, dmactl | ATA_DMA_START);\r\n}\r\nstatic unsigned int scc_devchk (struct ata_port *ap,\r\nunsigned int device)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nu8 nsect, lbal;\r\nap->ops->sff_dev_select(ap, device);\r\nout_be32(ioaddr->nsect_addr, 0x55);\r\nout_be32(ioaddr->lbal_addr, 0xaa);\r\nout_be32(ioaddr->nsect_addr, 0xaa);\r\nout_be32(ioaddr->lbal_addr, 0x55);\r\nout_be32(ioaddr->nsect_addr, 0x55);\r\nout_be32(ioaddr->lbal_addr, 0xaa);\r\nnsect = in_be32(ioaddr->nsect_addr);\r\nlbal = in_be32(ioaddr->lbal_addr);\r\nif ((nsect == 0x55) && (lbal == 0xaa))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int scc_wait_after_reset(struct ata_link *link, unsigned int devmask,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nunsigned int dev0 = devmask & (1 << 0);\r\nunsigned int dev1 = devmask & (1 << 1);\r\nint rc, ret = 0;\r\nata_msleep(ap, 150);\r\nrc = ata_sff_wait_ready(link, deadline);\r\nif (rc)\r\nreturn rc;\r\nif (dev1) {\r\nint i;\r\nap->ops->sff_dev_select(ap, 1);\r\nfor (i = 0; i < 2; i++) {\r\nu8 nsect, lbal;\r\nnsect = in_be32(ioaddr->nsect_addr);\r\nlbal = in_be32(ioaddr->lbal_addr);\r\nif ((nsect == 1) && (lbal == 1))\r\nbreak;\r\nata_msleep(ap, 50);\r\n}\r\nrc = ata_sff_wait_ready(link, deadline);\r\nif (rc) {\r\nif (rc != -ENODEV)\r\nreturn rc;\r\nret = rc;\r\n}\r\n}\r\nap->ops->sff_dev_select(ap, 0);\r\nif (dev1)\r\nap->ops->sff_dev_select(ap, 1);\r\nif (dev0)\r\nap->ops->sff_dev_select(ap, 0);\r\nreturn ret;\r\n}\r\nstatic int scc_bus_softreset(struct ata_port *ap, unsigned int devmask,\r\nunsigned long deadline)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nDPRINTK("ata%u: bus reset via SRST\n", ap->print_id);\r\nout_be32(ioaddr->ctl_addr, ap->ctl);\r\nudelay(20);\r\nout_be32(ioaddr->ctl_addr, ap->ctl | ATA_SRST);\r\nudelay(20);\r\nout_be32(ioaddr->ctl_addr, ap->ctl);\r\nreturn scc_wait_after_reset(&ap->link, devmask, deadline);\r\n}\r\nstatic int scc_softreset(struct ata_link *link, unsigned int *classes,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nunsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;\r\nunsigned int devmask = 0;\r\nint rc;\r\nu8 err;\r\nDPRINTK("ENTER\n");\r\nif (scc_devchk(ap, 0))\r\ndevmask |= (1 << 0);\r\nif (slave_possible && scc_devchk(ap, 1))\r\ndevmask |= (1 << 1);\r\nap->ops->sff_dev_select(ap, 0);\r\nDPRINTK("about to softreset, devmask=%x\n", devmask);\r\nrc = scc_bus_softreset(ap, devmask, deadline);\r\nif (rc) {\r\nata_port_err(ap, "SRST failed (err_mask=0x%x)\n", rc);\r\nreturn -EIO;\r\n}\r\nclasses[0] = ata_sff_dev_classify(&ap->link.device[0],\r\ndevmask & (1 << 0), &err);\r\nif (slave_possible && err != 0x81)\r\nclasses[1] = ata_sff_dev_classify(&ap->link.device[1],\r\ndevmask & (1 << 1), &err);\r\nDPRINTK("EXIT, classes[0]=%u [1]=%u\n", classes[0], classes[1]);\r\nreturn 0;\r\n}\r\nstatic void scc_bmdma_stop (struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nvoid __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];\r\nvoid __iomem *bmid_base = ap->host->iomap[SCC_BMID_BAR];\r\nu32 reg;\r\nwhile (1) {\r\nreg = in_be32(bmid_base + SCC_DMA_INTST);\r\nif (reg & INTSTS_SERROR) {\r\nprintk(KERN_WARNING "%s: SERROR\n", DRV_NAME);\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_SERROR|INTSTS_BMSINT);\r\nout_be32(bmid_base + SCC_DMA_CMD,\r\nin_be32(bmid_base + SCC_DMA_CMD) & ~ATA_DMA_START);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_PRERR) {\r\nu32 maea0, maec0;\r\nmaea0 = in_be32(ctrl_base + SCC_CTL_MAEA0);\r\nmaec0 = in_be32(ctrl_base + SCC_CTL_MAEC0);\r\nprintk(KERN_WARNING "%s: PRERR [addr:%x cmd:%x]\n", DRV_NAME, maea0, maec0);\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_PRERR|INTSTS_BMSINT);\r\nout_be32(bmid_base + SCC_DMA_CMD,\r\nin_be32(bmid_base + SCC_DMA_CMD) & ~ATA_DMA_START);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_RERR) {\r\nprintk(KERN_WARNING "%s: Response Error\n", DRV_NAME);\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_RERR|INTSTS_BMSINT);\r\nout_be32(bmid_base + SCC_DMA_CMD,\r\nin_be32(bmid_base + SCC_DMA_CMD) & ~ATA_DMA_START);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_ICERR) {\r\nout_be32(bmid_base + SCC_DMA_CMD,\r\nin_be32(bmid_base + SCC_DMA_CMD) & ~ATA_DMA_START);\r\nprintk(KERN_WARNING "%s: Illegal Configuration\n", DRV_NAME);\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_ICERR|INTSTS_BMSINT);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_BMSINT) {\r\nunsigned int classes;\r\nunsigned long deadline = ata_deadline(jiffies, ATA_TMOUT_BOOT);\r\nprintk(KERN_WARNING "%s: Internal Bus Error\n", DRV_NAME);\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_BMSINT);\r\nscc_softreset(&ap->link, &classes, deadline);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_BMHE) {\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_BMHE);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_ACTEINT) {\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_ACTEINT);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_IOIRQS) {\r\nout_be32(bmid_base + SCC_DMA_INTST, INTSTS_IOIRQS);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nout_be32(bmid_base + SCC_DMA_CMD,\r\nin_be32(bmid_base + SCC_DMA_CMD) & ~ATA_DMA_START);\r\nata_sff_dma_pause(ap);\r\n}\r\nstatic u8 scc_bmdma_status (struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\nu8 host_stat = in_be32(mmio + SCC_DMA_STATUS);\r\nu32 int_status = in_be32(mmio + SCC_DMA_INTST);\r\nstruct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nstatic int retry = 0;\r\nif (!(in_be32(mmio + SCC_DMA_CMD) & ATA_DMA_START))\r\nreturn host_stat;\r\nif ((scc_check_altstatus(ap) & ATA_ERR)\r\n&& (int_status & INTSTS_INTRQ))\r\nreturn (host_stat | ATA_DMA_INTR);\r\nif (int_status & INTSTS_IOIRQS) {\r\nhost_stat |= ATA_DMA_INTR;\r\nif ((qc->tf.protocol == ATA_PROT_DMA &&\r\nqc->dev->xfer_mode > XFER_UDMA_4)) {\r\nif (!(int_status & INTSTS_ACTEINT)) {\r\nprintk(KERN_WARNING "ata%u: operation failed (transfer data loss)\n",\r\nap->print_id);\r\nhost_stat |= ATA_DMA_ERR;\r\nif (retry++)\r\nap->udma_mask &= ~(1 << qc->dev->xfer_mode);\r\n} else\r\nretry = 0;\r\n}\r\n}\r\nreturn host_stat;\r\n}\r\nstatic unsigned int scc_data_xfer (struct ata_device *dev, unsigned char *buf,\r\nunsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nunsigned int words = buflen >> 1;\r\nunsigned int i;\r\n__le16 *buf16 = (__le16 *) buf;\r\nvoid __iomem *mmio = ap->ioaddr.data_addr;\r\nif (rw == READ)\r\nfor (i = 0; i < words; i++)\r\nbuf16[i] = cpu_to_le16(in_be32(mmio));\r\nelse\r\nfor (i = 0; i < words; i++)\r\nout_be32(mmio, le16_to_cpu(buf16[i]));\r\nif (unlikely(buflen & 0x01)) {\r\n__le16 align_buf[1] = { 0 };\r\nunsigned char *trailing_buf = buf + buflen - 1;\r\nif (rw == READ) {\r\nalign_buf[0] = cpu_to_le16(in_be32(mmio));\r\nmemcpy(trailing_buf, align_buf, 1);\r\n} else {\r\nmemcpy(align_buf, trailing_buf, 1);\r\nout_be32(mmio, le16_to_cpu(align_buf[0]));\r\n}\r\nwords++;\r\n}\r\nreturn words << 1;\r\n}\r\nstatic void scc_postreset(struct ata_link *link, unsigned int *classes)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nDPRINTK("ENTER\n");\r\nif (classes[0] != ATA_DEV_NONE)\r\nap->ops->sff_dev_select(ap, 1);\r\nif (classes[1] != ATA_DEV_NONE)\r\nap->ops->sff_dev_select(ap, 0);\r\nif (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {\r\nDPRINTK("EXIT, no device\n");\r\nreturn;\r\n}\r\nout_be32(ap->ioaddr.ctl_addr, ap->ctl);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void scc_irq_clear (struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\nif (!mmio)\r\nreturn;\r\nout_be32(mmio + SCC_DMA_STATUS, in_be32(mmio + SCC_DMA_STATUS));\r\n}\r\nstatic int scc_port_start (struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\nint rc;\r\nrc = ata_bmdma_port_start(ap);\r\nif (rc)\r\nreturn rc;\r\nout_be32(mmio + SCC_DMA_PTERADD, ap->bmdma_prd_dma);\r\nreturn 0;\r\n}\r\nstatic void scc_port_stop (struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\r\nout_be32(mmio + SCC_DMA_PTERADD, 0);\r\n}\r\nstatic int scc_reset_controller(struct ata_host *host)\r\n{\r\nvoid __iomem *ctrl_base = host->iomap[SCC_CTRL_BAR];\r\nvoid __iomem *bmid_base = host->iomap[SCC_BMID_BAR];\r\nvoid __iomem *cckctrl_port = ctrl_base + SCC_CTL_CCKCTRL;\r\nvoid __iomem *mode_port = ctrl_base + SCC_CTL_MODEREG;\r\nvoid __iomem *ecmode_port = ctrl_base + SCC_CTL_ECMODE;\r\nvoid __iomem *intmask_port = bmid_base + SCC_DMA_INTMASK;\r\nvoid __iomem *dmastatus_port = bmid_base + SCC_DMA_STATUS;\r\nu32 reg = 0;\r\nout_be32(cckctrl_port, reg);\r\nreg |= CCKCTRL_ATACLKOEN;\r\nout_be32(cckctrl_port, reg);\r\nreg |= CCKCTRL_LCLKEN | CCKCTRL_OCLKEN;\r\nout_be32(cckctrl_port, reg);\r\nreg |= CCKCTRL_CRST;\r\nout_be32(cckctrl_port, reg);\r\nfor (;;) {\r\nreg = in_be32(cckctrl_port);\r\nif (reg & CCKCTRL_CRST)\r\nbreak;\r\nudelay(5000);\r\n}\r\nreg |= CCKCTRL_ATARESET;\r\nout_be32(cckctrl_port, reg);\r\nout_be32(ecmode_port, ECMODE_VALUE);\r\nout_be32(mode_port, MODE_JCUSFEN);\r\nout_be32(intmask_port, INTMASK_MSK);\r\nif (in_be32(dmastatus_port) & QCHSD_STPDIAG) {\r\nprintk(KERN_WARNING "%s: failed to detect 80c cable. (PDIAG# is high)\n", DRV_NAME);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void scc_setup_ports (struct ata_ioports *ioaddr, void __iomem *base)\r\n{\r\nioaddr->cmd_addr = base + SCC_REG_CMD_ADDR;\r\nioaddr->altstatus_addr = ioaddr->cmd_addr + SCC_REG_ALTSTATUS;\r\nioaddr->ctl_addr = ioaddr->cmd_addr + SCC_REG_ALTSTATUS;\r\nioaddr->bmdma_addr = base;\r\nioaddr->data_addr = ioaddr->cmd_addr + SCC_REG_DATA;\r\nioaddr->error_addr = ioaddr->cmd_addr + SCC_REG_ERR;\r\nioaddr->feature_addr = ioaddr->cmd_addr + SCC_REG_FEATURE;\r\nioaddr->nsect_addr = ioaddr->cmd_addr + SCC_REG_NSECT;\r\nioaddr->lbal_addr = ioaddr->cmd_addr + SCC_REG_LBAL;\r\nioaddr->lbam_addr = ioaddr->cmd_addr + SCC_REG_LBAM;\r\nioaddr->lbah_addr = ioaddr->cmd_addr + SCC_REG_LBAH;\r\nioaddr->device_addr = ioaddr->cmd_addr + SCC_REG_DEVICE;\r\nioaddr->status_addr = ioaddr->cmd_addr + SCC_REG_STATUS;\r\nioaddr->command_addr = ioaddr->cmd_addr + SCC_REG_CMD;\r\n}\r\nstatic int scc_host_init(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nint rc;\r\nrc = scc_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nscc_setup_ports(&host->ports[0]->ioaddr, host->iomap[SCC_BMID_BAR]);\r\npci_set_master(pdev);\r\nreturn 0;\r\n}\r\nstatic int scc_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int board_idx = (unsigned int) ent->driver_data;\r\nconst struct ata_port_info *ppi[] = { &scc_port_info[board_idx], NULL };\r\nstruct ata_host *host;\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev, (1 << SCC_CTRL_BAR) | (1 << SCC_BMID_BAR), DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nata_port_pbar_desc(host->ports[0], SCC_CTRL_BAR, -1, "ctrl");\r\nata_port_pbar_desc(host->ports[0], SCC_BMID_BAR, -1, "bmid");\r\nrc = scc_host_init(host);\r\nif (rc)\r\nreturn rc;\r\nreturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &scc_sht);\r\n}
