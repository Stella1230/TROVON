static struct usbip_imported_device *\r\nimported_device_init(struct usbip_imported_device *idev, char *busid)\r\n{\r\nstruct udev_device *sudev;\r\nsudev = udev_device_new_from_subsystem_sysname(udev_context,\r\n"usb", busid);\r\nif (!sudev) {\r\ndbg("udev_device_new_from_subsystem_sysname failed: %s", busid);\r\ngoto err;\r\n}\r\nread_usb_device(sudev, &idev->udev);\r\nudev_device_unref(sudev);\r\nreturn idev;\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic int parse_status(const char *value)\r\n{\r\nint ret = 0;\r\nchar *c;\r\nfor (int i = 0; i < vhci_driver->nports; i++)\r\nmemset(&vhci_driver->idev[i], 0, sizeof(vhci_driver->idev[i]));\r\nc = strchr(value, '\n');\r\nif (!c)\r\nreturn -1;\r\nc++;\r\nwhile (*c != '\0') {\r\nint port, status, speed, devid;\r\nunsigned long socket;\r\nchar lbusid[SYSFS_BUS_ID_SIZE];\r\nret = sscanf(c, "%d %d %d %x %lx %31s\n",\r\n&port, &status, &speed,\r\n&devid, &socket, lbusid);\r\nif (ret < 5) {\r\ndbg("sscanf failed: %d", ret);\r\nBUG();\r\n}\r\ndbg("port %d status %d speed %d devid %x",\r\nport, status, speed, devid);\r\ndbg("socket %lx lbusid %s", socket, lbusid);\r\n{\r\nstruct usbip_imported_device *idev = &vhci_driver->idev[port];\r\nidev->port = port;\r\nidev->status = status;\r\nidev->devid = devid;\r\nidev->busnum = (devid >> 16);\r\nidev->devnum = (devid & 0x0000ffff);\r\nif (idev->status != VDEV_ST_NULL\r\n&& idev->status != VDEV_ST_NOTASSIGNED) {\r\nidev = imported_device_init(idev, lbusid);\r\nif (!idev) {\r\ndbg("imported_device_init failed");\r\nreturn -1;\r\n}\r\n}\r\n}\r\nc = strchr(c, '\n');\r\nif (!c)\r\nbreak;\r\nc++;\r\n}\r\ndbg("exit");\r\nreturn 0;\r\n}\r\nstatic int refresh_imported_device_list(void)\r\n{\r\nconst char *attr_status;\r\nattr_status = udev_device_get_sysattr_value(vhci_driver->hc_device,\r\n"status");\r\nif (!attr_status) {\r\nerr("udev_device_get_sysattr_value failed");\r\nreturn -1;\r\n}\r\nreturn parse_status(attr_status);\r\n}\r\nstatic int get_nports(void)\r\n{\r\nchar *c;\r\nint nports = 0;\r\nconst char *attr_status;\r\nattr_status = udev_device_get_sysattr_value(vhci_driver->hc_device,\r\n"status");\r\nif (!attr_status) {\r\nerr("udev_device_get_sysattr_value failed");\r\nreturn -1;\r\n}\r\nc = strchr(attr_status, '\n');\r\nif (!c)\r\nreturn 0;\r\nc++;\r\nwhile (*c != '\0') {\r\nc = strchr(c, '\n');\r\nif (!c)\r\nreturn nports;\r\nc++;\r\nnports += 1;\r\n}\r\nreturn nports;\r\n}\r\nstatic int read_record(int rhport, char *host, unsigned long host_len,\r\nchar *port, unsigned long port_len, char *busid)\r\n{\r\nint part;\r\nFILE *file;\r\nchar path[PATH_MAX+1];\r\nchar *buffer, *start, *end;\r\nchar delim[] = {' ', ' ', '\n'};\r\nint max_len[] = {(int)host_len, (int)port_len, SYSFS_BUS_ID_SIZE};\r\nsize_t buffer_len = host_len + port_len + SYSFS_BUS_ID_SIZE + 4;\r\nbuffer = malloc(buffer_len);\r\nif (!buffer)\r\nreturn -1;\r\nsnprintf(path, PATH_MAX, VHCI_STATE_PATH"/port%d", rhport);\r\nfile = fopen(path, "r");\r\nif (!file) {\r\nerr("fopen");\r\nfree(buffer);\r\nreturn -1;\r\n}\r\nif (fgets(buffer, buffer_len, file) == NULL) {\r\nerr("fgets");\r\nfree(buffer);\r\nfclose(file);\r\nreturn -1;\r\n}\r\nfclose(file);\r\nstart = buffer;\r\nfor (part = 0; part < 3; part++) {\r\nend = strchr(start, delim[part]);\r\nif (end == NULL || (end - start) > max_len[part]) {\r\nfree(buffer);\r\nreturn -1;\r\n}\r\nstart = end + 1;\r\n}\r\nif (sscanf(buffer, "%s %s %s\n", host, port, busid) != 3) {\r\nerr("sscanf");\r\nfree(buffer);\r\nreturn -1;\r\n}\r\nfree(buffer);\r\nreturn 0;\r\n}\r\nint usbip_vhci_driver_open(void)\r\n{\r\nudev_context = udev_new();\r\nif (!udev_context) {\r\nerr("udev_new failed");\r\nreturn -1;\r\n}\r\nvhci_driver = calloc(1, sizeof(struct usbip_vhci_driver));\r\nvhci_driver->hc_device =\r\nudev_device_new_from_subsystem_sysname(udev_context,\r\nUSBIP_VHCI_BUS_TYPE,\r\nUSBIP_VHCI_DRV_NAME);\r\nif (!vhci_driver->hc_device) {\r\nerr("udev_device_new_from_subsystem_sysname failed");\r\ngoto err;\r\n}\r\nvhci_driver->nports = get_nports();\r\ndbg("available ports: %d", vhci_driver->nports);\r\nif (refresh_imported_device_list())\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nudev_device_unref(vhci_driver->hc_device);\r\nif (vhci_driver)\r\nfree(vhci_driver);\r\nvhci_driver = NULL;\r\nudev_unref(udev_context);\r\nreturn -1;\r\n}\r\nvoid usbip_vhci_driver_close(void)\r\n{\r\nif (!vhci_driver)\r\nreturn;\r\nudev_device_unref(vhci_driver->hc_device);\r\nfree(vhci_driver);\r\nvhci_driver = NULL;\r\nudev_unref(udev_context);\r\n}\r\nint usbip_vhci_refresh_device_list(void)\r\n{\r\nif (refresh_imported_device_list())\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndbg("failed to refresh device list");\r\nreturn -1;\r\n}\r\nint usbip_vhci_get_free_port(void)\r\n{\r\nfor (int i = 0; i < vhci_driver->nports; i++) {\r\nif (vhci_driver->idev[i].status == VDEV_ST_NULL)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint usbip_vhci_attach_device2(uint8_t port, int sockfd, uint32_t devid,\r\nuint32_t speed) {\r\nchar buff[200];\r\nchar attach_attr_path[SYSFS_PATH_MAX];\r\nchar attr_attach[] = "attach";\r\nconst char *path;\r\nint ret;\r\nsnprintf(buff, sizeof(buff), "%u %d %u %u",\r\nport, sockfd, devid, speed);\r\ndbg("writing: %s", buff);\r\npath = udev_device_get_syspath(vhci_driver->hc_device);\r\nsnprintf(attach_attr_path, sizeof(attach_attr_path), "%s/%s",\r\npath, attr_attach);\r\ndbg("attach attribute path: %s", attach_attr_path);\r\nret = write_sysfs_attribute(attach_attr_path, buff, strlen(buff));\r\nif (ret < 0) {\r\ndbg("write_sysfs_attribute failed");\r\nreturn -1;\r\n}\r\ndbg("attached port: %d", port);\r\nreturn 0;\r\n}\r\nstatic unsigned long get_devid(uint8_t busnum, uint8_t devnum)\r\n{\r\nreturn (busnum << 16) | devnum;\r\n}\r\nint usbip_vhci_attach_device(uint8_t port, int sockfd, uint8_t busnum,\r\nuint8_t devnum, uint32_t speed)\r\n{\r\nint devid = get_devid(busnum, devnum);\r\nreturn usbip_vhci_attach_device2(port, sockfd, devid, speed);\r\n}\r\nint usbip_vhci_detach_device(uint8_t port)\r\n{\r\nchar detach_attr_path[SYSFS_PATH_MAX];\r\nchar attr_detach[] = "detach";\r\nchar buff[200];\r\nconst char *path;\r\nint ret;\r\nsnprintf(buff, sizeof(buff), "%u", port);\r\ndbg("writing: %s", buff);\r\npath = udev_device_get_syspath(vhci_driver->hc_device);\r\nsnprintf(detach_attr_path, sizeof(detach_attr_path), "%s/%s",\r\npath, attr_detach);\r\ndbg("detach attribute path: %s", detach_attr_path);\r\nret = write_sysfs_attribute(detach_attr_path, buff, strlen(buff));\r\nif (ret < 0) {\r\ndbg("write_sysfs_attribute failed");\r\nreturn -1;\r\n}\r\ndbg("detached port: %d", port);\r\nreturn 0;\r\n}\r\nint usbip_vhci_imported_device_dump(struct usbip_imported_device *idev)\r\n{\r\nchar product_name[100];\r\nchar host[NI_MAXHOST] = "unknown host";\r\nchar serv[NI_MAXSERV] = "unknown port";\r\nchar remote_busid[SYSFS_BUS_ID_SIZE];\r\nint ret;\r\nint read_record_error = 0;\r\nif (idev->status == VDEV_ST_NULL || idev->status == VDEV_ST_NOTASSIGNED)\r\nreturn 0;\r\nret = read_record(idev->port, host, sizeof(host), serv, sizeof(serv),\r\nremote_busid);\r\nif (ret) {\r\nerr("read_record");\r\nread_record_error = 1;\r\n}\r\nprintf("Port %02d: <%s> at %s\n", idev->port,\r\nusbip_status_string(idev->status),\r\nusbip_speed_string(idev->udev.speed));\r\nusbip_names_get_product(product_name, sizeof(product_name),\r\nidev->udev.idVendor, idev->udev.idProduct);\r\nprintf(" %s\n", product_name);\r\nif (!read_record_error) {\r\nprintf("%10s -> usbip://%s:%s/%s\n", idev->udev.busid,\r\nhost, serv, remote_busid);\r\nprintf("%10s -> remote bus/dev %03d/%03d\n", " ",\r\nidev->busnum, idev->devnum);\r\n} else {\r\nprintf("%10s -> unknown host, remote port and remote busid\n",\r\nidev->udev.busid);\r\nprintf("%10s -> remote bus/dev %03d/%03d\n", " ",\r\nidev->busnum, idev->devnum);\r\n}\r\nreturn 0;\r\n}
