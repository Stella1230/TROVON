static inline\r\nstruct b43_dfs_file *fops_to_dfs_file(struct b43_wldev *dev,\r\nconst struct b43_debugfs_fops *dfops)\r\n{\r\nvoid *p;\r\np = dev->dfsentry;\r\np += dfops->file_struct_offset;\r\nreturn p;\r\n}\r\nstatic ssize_t shm16read__read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nssize_t count = 0;\r\nunsigned int routing, addr;\r\nu16 val;\r\nrouting = dev->dfsentry->shm16read_routing_next;\r\naddr = dev->dfsentry->shm16read_addr_next;\r\nif ((routing > B43_MAX_SHM_ROUTING) ||\r\n(addr > B43_MAX_SHM_ADDR))\r\nreturn -EDESTADDRREQ;\r\nval = b43_shm_read16(dev, routing, addr);\r\nfappend("0x%04X\n", val);\r\nreturn count;\r\n}\r\nstatic int shm16read__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int routing, addr;\r\nint res;\r\nres = sscanf(buf, "0x%X 0x%X", &routing, &addr);\r\nif (res != 2)\r\nreturn -EINVAL;\r\nif (routing > B43_MAX_SHM_ROUTING)\r\nreturn -EADDRNOTAVAIL;\r\nif (addr > B43_MAX_SHM_ADDR)\r\nreturn -EADDRNOTAVAIL;\r\nif (routing == B43_SHM_SHARED) {\r\nif ((addr % 2) != 0)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\ndev->dfsentry->shm16read_routing_next = routing;\r\ndev->dfsentry->shm16read_addr_next = addr;\r\nreturn 0;\r\n}\r\nstatic int shm16write__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int routing, addr, mask, set;\r\nu16 val;\r\nint res;\r\nres = sscanf(buf, "0x%X 0x%X 0x%X 0x%X",\r\n&routing, &addr, &mask, &set);\r\nif (res != 4)\r\nreturn -EINVAL;\r\nif (routing > B43_MAX_SHM_ROUTING)\r\nreturn -EADDRNOTAVAIL;\r\nif (addr > B43_MAX_SHM_ADDR)\r\nreturn -EADDRNOTAVAIL;\r\nif (routing == B43_SHM_SHARED) {\r\nif ((addr % 2) != 0)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif ((mask > 0xFFFF) || (set > 0xFFFF))\r\nreturn -E2BIG;\r\nif (mask == 0)\r\nval = 0;\r\nelse\r\nval = b43_shm_read16(dev, routing, addr);\r\nval &= mask;\r\nval |= set;\r\nb43_shm_write16(dev, routing, addr, val);\r\nreturn 0;\r\n}\r\nstatic ssize_t shm32read__read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nssize_t count = 0;\r\nunsigned int routing, addr;\r\nu32 val;\r\nrouting = dev->dfsentry->shm32read_routing_next;\r\naddr = dev->dfsentry->shm32read_addr_next;\r\nif ((routing > B43_MAX_SHM_ROUTING) ||\r\n(addr > B43_MAX_SHM_ADDR))\r\nreturn -EDESTADDRREQ;\r\nval = b43_shm_read32(dev, routing, addr);\r\nfappend("0x%08X\n", val);\r\nreturn count;\r\n}\r\nstatic int shm32read__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int routing, addr;\r\nint res;\r\nres = sscanf(buf, "0x%X 0x%X", &routing, &addr);\r\nif (res != 2)\r\nreturn -EINVAL;\r\nif (routing > B43_MAX_SHM_ROUTING)\r\nreturn -EADDRNOTAVAIL;\r\nif (addr > B43_MAX_SHM_ADDR)\r\nreturn -EADDRNOTAVAIL;\r\nif (routing == B43_SHM_SHARED) {\r\nif ((addr % 2) != 0)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\ndev->dfsentry->shm32read_routing_next = routing;\r\ndev->dfsentry->shm32read_addr_next = addr;\r\nreturn 0;\r\n}\r\nstatic int shm32write__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int routing, addr, mask, set;\r\nu32 val;\r\nint res;\r\nres = sscanf(buf, "0x%X 0x%X 0x%X 0x%X",\r\n&routing, &addr, &mask, &set);\r\nif (res != 4)\r\nreturn -EINVAL;\r\nif (routing > B43_MAX_SHM_ROUTING)\r\nreturn -EADDRNOTAVAIL;\r\nif (addr > B43_MAX_SHM_ADDR)\r\nreturn -EADDRNOTAVAIL;\r\nif (routing == B43_SHM_SHARED) {\r\nif ((addr % 2) != 0)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif ((mask > 0xFFFFFFFF) || (set > 0xFFFFFFFF))\r\nreturn -E2BIG;\r\nif (mask == 0)\r\nval = 0;\r\nelse\r\nval = b43_shm_read32(dev, routing, addr);\r\nval &= mask;\r\nval |= set;\r\nb43_shm_write32(dev, routing, addr, val);\r\nreturn 0;\r\n}\r\nstatic ssize_t mmio16read__read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nssize_t count = 0;\r\nunsigned int addr;\r\nu16 val;\r\naddr = dev->dfsentry->mmio16read_next;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EDESTADDRREQ;\r\nval = b43_read16(dev, addr);\r\nfappend("0x%04X\n", val);\r\nreturn count;\r\n}\r\nstatic int mmio16read__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int addr;\r\nint res;\r\nres = sscanf(buf, "0x%X", &addr);\r\nif (res != 1)\r\nreturn -EINVAL;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EADDRNOTAVAIL;\r\nif ((addr % 2) != 0)\r\nreturn -EINVAL;\r\ndev->dfsentry->mmio16read_next = addr;\r\nreturn 0;\r\n}\r\nstatic int mmio16write__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int addr, mask, set;\r\nint res;\r\nu16 val;\r\nres = sscanf(buf, "0x%X 0x%X 0x%X", &addr, &mask, &set);\r\nif (res != 3)\r\nreturn -EINVAL;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EADDRNOTAVAIL;\r\nif ((mask > 0xFFFF) || (set > 0xFFFF))\r\nreturn -E2BIG;\r\nif ((addr % 2) != 0)\r\nreturn -EINVAL;\r\nif (mask == 0)\r\nval = 0;\r\nelse\r\nval = b43_read16(dev, addr);\r\nval &= mask;\r\nval |= set;\r\nb43_write16(dev, addr, val);\r\nreturn 0;\r\n}\r\nstatic ssize_t mmio32read__read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nssize_t count = 0;\r\nunsigned int addr;\r\nu32 val;\r\naddr = dev->dfsentry->mmio32read_next;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EDESTADDRREQ;\r\nval = b43_read32(dev, addr);\r\nfappend("0x%08X\n", val);\r\nreturn count;\r\n}\r\nstatic int mmio32read__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int addr;\r\nint res;\r\nres = sscanf(buf, "0x%X", &addr);\r\nif (res != 1)\r\nreturn -EINVAL;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EADDRNOTAVAIL;\r\nif ((addr % 4) != 0)\r\nreturn -EINVAL;\r\ndev->dfsentry->mmio32read_next = addr;\r\nreturn 0;\r\n}\r\nstatic int mmio32write__write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int addr, mask, set;\r\nint res;\r\nu32 val;\r\nres = sscanf(buf, "0x%X 0x%X 0x%X", &addr, &mask, &set);\r\nif (res != 3)\r\nreturn -EINVAL;\r\nif (addr > B43_MAX_MMIO_ACCESS)\r\nreturn -EADDRNOTAVAIL;\r\nif ((mask > 0xFFFFFFFF) || (set > 0xFFFFFFFF))\r\nreturn -E2BIG;\r\nif ((addr % 4) != 0)\r\nreturn -EINVAL;\r\nif (mask == 0)\r\nval = 0;\r\nelse\r\nval = b43_read32(dev, addr);\r\nval &= mask;\r\nval |= set;\r\nb43_write32(dev, addr, val);\r\nreturn 0;\r\n}\r\nstatic ssize_t txstat_read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nstruct b43_txstatus_log *log = &dev->dfsentry->txstatlog;\r\nssize_t count = 0;\r\nint i, idx;\r\nstruct b43_txstatus *stat;\r\nif (log->end < 0) {\r\nfappend("Nothing transmitted, yet\n");\r\ngoto out;\r\n}\r\nfappend("b43 TX status reports:\n\n"\r\n"index | cookie | seq | phy_stat | frame_count | "\r\n"rts_count | supp_reason | pm_indicated | "\r\n"intermediate | for_ampdu | acked\n" "---\n");\r\ni = log->end + 1;\r\nidx = 0;\r\nwhile (1) {\r\nif (i == B43_NR_LOGGED_TXSTATUS)\r\ni = 0;\r\nstat = &(log->log[i]);\r\nif (stat->cookie) {\r\nfappend("%03d | "\r\n"0x%04X | 0x%04X | 0x%02X | "\r\n"0x%X | 0x%X | "\r\n"%u | %u | "\r\n"%u | %u | %u\n",\r\nidx,\r\nstat->cookie, stat->seq, stat->phy_stat,\r\nstat->frame_count, stat->rts_count,\r\nstat->supp_reason, stat->pm_indicated,\r\nstat->intermediate, stat->for_ampdu,\r\nstat->acked);\r\nidx++;\r\n}\r\nif (i == log->end)\r\nbreak;\r\ni++;\r\n}\r\nout:\r\nreturn count;\r\n}\r\nstatic int restart_write_file(struct b43_wldev *dev,\r\nconst char *buf, size_t count)\r\n{\r\nint err = 0;\r\nif (count > 0 && buf[0] == '1') {\r\nb43_controller_restart(dev, "manually restarted");\r\n} else\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic unsigned long calc_expire_secs(unsigned long now,\r\nunsigned long time,\r\nunsigned long expire)\r\n{\r\nexpire = time + expire;\r\nif (time_after(now, expire))\r\nreturn 0;\r\nif (expire < now) {\r\nexpire -= MAX_JIFFY_OFFSET;\r\nnow -= MAX_JIFFY_OFFSET;\r\n}\r\nB43_WARN_ON(expire < now);\r\nreturn (expire - now) / HZ;\r\n}\r\nstatic ssize_t loctls_read_file(struct b43_wldev *dev,\r\nchar *buf, size_t bufsize)\r\n{\r\nssize_t count = 0;\r\nstruct b43_txpower_lo_control *lo;\r\nint i, err = 0;\r\nstruct b43_lo_calib *cal;\r\nunsigned long now = jiffies;\r\nstruct b43_phy *phy = &dev->phy;\r\nif (phy->type != B43_PHYTYPE_G) {\r\nfappend("Device is not a G-PHY\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nlo = phy->g->lo_control;\r\nfappend("-- Local Oscillator calibration data --\n\n");\r\nfappend("HW-power-control enabled: %d\n",\r\ndev->phy.hardware_power_control);\r\nfappend("TX Bias: 0x%02X, TX Magn: 0x%02X (expire in %lu sec)\n",\r\nlo->tx_bias, lo->tx_magn,\r\ncalc_expire_secs(now, lo->txctl_measured_time,\r\nB43_LO_TXCTL_EXPIRE));\r\nfappend("Power Vector: 0x%08X%08X (expires in %lu sec)\n",\r\n(unsigned int)((lo->power_vector & 0xFFFFFFFF00000000ULL) >> 32),\r\n(unsigned int)(lo->power_vector & 0x00000000FFFFFFFFULL),\r\ncalc_expire_secs(now, lo->pwr_vec_read_time,\r\nB43_LO_PWRVEC_EXPIRE));\r\nfappend("\nCalibrated settings:\n");\r\nlist_for_each_entry(cal, &lo->calib_list, list) {\r\nbool active;\r\nactive = (b43_compare_bbatt(&cal->bbatt, &phy->g->bbatt) &&\r\nb43_compare_rfatt(&cal->rfatt, &phy->g->rfatt));\r\nfappend("BB(%d), RF(%d,%d) -> I=%d, Q=%d "\r\n"(expires in %lu sec)%s\n",\r\ncal->bbatt.att,\r\ncal->rfatt.att, cal->rfatt.with_padmix,\r\ncal->ctl.i, cal->ctl.q,\r\ncalc_expire_secs(now, cal->calib_time,\r\nB43_LO_CALIB_EXPIRE),\r\nactive ? " ACTIVE" : "");\r\n}\r\nfappend("\nUsed RF attenuation values: Value(WithPadmix flag)\n");\r\nfor (i = 0; i < lo->rfatt_list.len; i++) {\r\nfappend("%u(%d), ",\r\nlo->rfatt_list.list[i].att,\r\nlo->rfatt_list.list[i].with_padmix);\r\n}\r\nfappend("\n");\r\nfappend("\nUsed Baseband attenuation values:\n");\r\nfor (i = 0; i < lo->bbatt_list.len; i++) {\r\nfappend("%u, ",\r\nlo->bbatt_list.list[i].att);\r\n}\r\nfappend("\n");\r\nout:\r\nreturn err ? err : count;\r\n}\r\nstatic ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct b43_wldev *dev;\r\nstruct b43_debugfs_fops *dfops;\r\nstruct b43_dfs_file *dfile;\r\nssize_t uninitialized_var(ret);\r\nchar *buf;\r\nconst size_t bufsize = 1024 * 16;\r\nconst size_t buforder = get_order(bufsize);\r\nint err = 0;\r\nif (!count)\r\nreturn 0;\r\ndev = file->private_data;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->wl->mutex);\r\nif (b43_status(dev) < B43_STAT_INITIALIZED) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\ndfops = container_of(file->f_op, struct b43_debugfs_fops, fops);\r\nif (!dfops->read) {\r\nerr = -ENOSYS;\r\ngoto out_unlock;\r\n}\r\ndfile = fops_to_dfs_file(dev, dfops);\r\nif (!dfile->buffer) {\r\nbuf = (char *)__get_free_pages(GFP_KERNEL, buforder);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nmemset(buf, 0, bufsize);\r\nret = dfops->read(dev, buf, bufsize);\r\nif (ret <= 0) {\r\nfree_pages((unsigned long)buf, buforder);\r\nerr = ret;\r\ngoto out_unlock;\r\n}\r\ndfile->data_len = ret;\r\ndfile->buffer = buf;\r\n}\r\nret = simple_read_from_buffer(userbuf, count, ppos,\r\ndfile->buffer,\r\ndfile->data_len);\r\nif (*ppos >= dfile->data_len) {\r\nfree_pages((unsigned long)dfile->buffer, buforder);\r\ndfile->buffer = NULL;\r\ndfile->data_len = 0;\r\n}\r\nout_unlock:\r\nmutex_unlock(&dev->wl->mutex);\r\nreturn err ? err : ret;\r\n}\r\nstatic ssize_t b43_debugfs_write(struct file *file,\r\nconst char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct b43_wldev *dev;\r\nstruct b43_debugfs_fops *dfops;\r\nchar *buf;\r\nint err = 0;\r\nif (!count)\r\nreturn 0;\r\nif (count > PAGE_SIZE)\r\nreturn -E2BIG;\r\ndev = file->private_data;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->wl->mutex);\r\nif (b43_status(dev) < B43_STAT_INITIALIZED) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\ndfops = container_of(file->f_op, struct b43_debugfs_fops, fops);\r\nif (!dfops->write) {\r\nerr = -ENOSYS;\r\ngoto out_unlock;\r\n}\r\nbuf = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nif (copy_from_user(buf, userbuf, count)) {\r\nerr = -EFAULT;\r\ngoto out_freepage;\r\n}\r\nerr = dfops->write(dev, buf, count);\r\nif (err)\r\ngoto out_freepage;\r\nout_freepage:\r\nfree_page((unsigned long)buf);\r\nout_unlock:\r\nmutex_unlock(&dev->wl->mutex);\r\nreturn err ? err : count;\r\n}\r\nbool b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature)\r\n{\r\nbool enabled;\r\nenabled = (dev->dfsentry && dev->dfsentry->dyn_debug[feature]);\r\nif (unlikely(enabled)) {\r\nb43_modparam_verbose = B43_VERBOSITY_MAX;\r\n}\r\nreturn enabled;\r\n}\r\nstatic void b43_remove_dynamic_debug(struct b43_wldev *dev)\r\n{\r\nstruct b43_dfsentry *e = dev->dfsentry;\r\nint i;\r\nfor (i = 0; i < __B43_NR_DYNDBG; i++)\r\ndebugfs_remove(e->dyn_debug_dentries[i]);\r\n}\r\nstatic void b43_add_dynamic_debug(struct b43_wldev *dev)\r\n{\r\nstruct b43_dfsentry *e = dev->dfsentry;\r\nstruct dentry *d;\r\n#define add_dyn_dbg(name, id, initstate) do { \\r\ne->dyn_debug[id] = (initstate); \\r\nd = debugfs_create_bool(name, 0600, e->subdir, \\r\n&(e->dyn_debug[id])); \\r\nif (!IS_ERR(d)) \\r\ne->dyn_debug_dentries[id] = d; \\r\n} while (0)\r\nadd_dyn_dbg("debug_xmitpower", B43_DBG_XMITPOWER, 0);\r\nadd_dyn_dbg("debug_dmaoverflow", B43_DBG_DMAOVERFLOW, 0);\r\nadd_dyn_dbg("debug_dmaverbose", B43_DBG_DMAVERBOSE, 0);\r\nadd_dyn_dbg("debug_pwork_fast", B43_DBG_PWORK_FAST, 0);\r\nadd_dyn_dbg("debug_pwork_stop", B43_DBG_PWORK_STOP, 0);\r\nadd_dyn_dbg("debug_lo", B43_DBG_LO, 0);\r\nadd_dyn_dbg("debug_firmware", B43_DBG_FIRMWARE, 0);\r\nadd_dyn_dbg("debug_keys", B43_DBG_KEYS, 0);\r\nadd_dyn_dbg("debug_verbose_stats", B43_DBG_VERBOSESTATS, 0);\r\n#undef add_dyn_dbg\r\n}\r\nvoid b43_debugfs_add_device(struct b43_wldev *dev)\r\n{\r\nstruct b43_dfsentry *e;\r\nstruct b43_txstatus_log *log;\r\nchar devdir[16];\r\nB43_WARN_ON(!dev);\r\ne = kzalloc(sizeof(*e), GFP_KERNEL);\r\nif (!e) {\r\nb43err(dev->wl, "debugfs: add device OOM\n");\r\nreturn;\r\n}\r\ne->dev = dev;\r\nlog = &e->txstatlog;\r\nlog->log = kcalloc(B43_NR_LOGGED_TXSTATUS,\r\nsizeof(struct b43_txstatus), GFP_KERNEL);\r\nif (!log->log) {\r\nb43err(dev->wl, "debugfs: add device txstatus OOM\n");\r\nkfree(e);\r\nreturn;\r\n}\r\nlog->end = -1;\r\ndev->dfsentry = e;\r\nsnprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));\r\ne->subdir = debugfs_create_dir(devdir, rootdir);\r\nif (!e->subdir || IS_ERR(e->subdir)) {\r\nif (e->subdir == ERR_PTR(-ENODEV)) {\r\nb43dbg(dev->wl, "DebugFS (CONFIG_DEBUG_FS) not "\r\n"enabled in kernel config\n");\r\n} else {\r\nb43err(dev->wl, "debugfs: cannot create %s directory\n",\r\ndevdir);\r\n}\r\ndev->dfsentry = NULL;\r\nkfree(log->log);\r\nkfree(e);\r\nreturn;\r\n}\r\ne->mmio16read_next = 0xFFFF;\r\ne->mmio32read_next = 0xFFFF;\r\ne->shm16read_routing_next = 0xFFFFFFFF;\r\ne->shm16read_addr_next = 0xFFFFFFFF;\r\ne->shm32read_routing_next = 0xFFFFFFFF;\r\ne->shm32read_addr_next = 0xFFFFFFFF;\r\n#define ADD_FILE(name, mode) \\r\ndo { \\r\nstruct dentry *d; \\r\nd = debugfs_create_file(__stringify(name), \\r\nmode, e->subdir, dev, \\r\n&fops_##name.fops); \\r\ne->file_##name.dentry = NULL; \\r\nif (!IS_ERR(d)) \\r\ne->file_##name.dentry = d; \\r\n} while (0)\r\nADD_FILE(shm16read, 0600);\r\nADD_FILE(shm16write, 0200);\r\nADD_FILE(shm32read, 0600);\r\nADD_FILE(shm32write, 0200);\r\nADD_FILE(mmio16read, 0600);\r\nADD_FILE(mmio16write, 0200);\r\nADD_FILE(mmio32read, 0600);\r\nADD_FILE(mmio32write, 0200);\r\nADD_FILE(txstat, 0400);\r\nADD_FILE(restart, 0200);\r\nADD_FILE(loctls, 0400);\r\n#undef ADD_FILE\r\nb43_add_dynamic_debug(dev);\r\n}\r\nvoid b43_debugfs_remove_device(struct b43_wldev *dev)\r\n{\r\nstruct b43_dfsentry *e;\r\nif (!dev)\r\nreturn;\r\ne = dev->dfsentry;\r\nif (!e)\r\nreturn;\r\nb43_remove_dynamic_debug(dev);\r\ndebugfs_remove(e->file_shm16read.dentry);\r\ndebugfs_remove(e->file_shm16write.dentry);\r\ndebugfs_remove(e->file_shm32read.dentry);\r\ndebugfs_remove(e->file_shm32write.dentry);\r\ndebugfs_remove(e->file_mmio16read.dentry);\r\ndebugfs_remove(e->file_mmio16write.dentry);\r\ndebugfs_remove(e->file_mmio32read.dentry);\r\ndebugfs_remove(e->file_mmio32write.dentry);\r\ndebugfs_remove(e->file_txstat.dentry);\r\ndebugfs_remove(e->file_restart.dentry);\r\ndebugfs_remove(e->file_loctls.dentry);\r\ndebugfs_remove(e->subdir);\r\nkfree(e->txstatlog.log);\r\nkfree(e);\r\n}\r\nvoid b43_debugfs_log_txstat(struct b43_wldev *dev,\r\nconst struct b43_txstatus *status)\r\n{\r\nstruct b43_dfsentry *e = dev->dfsentry;\r\nstruct b43_txstatus_log *log;\r\nstruct b43_txstatus *cur;\r\nint i;\r\nif (!e)\r\nreturn;\r\nlog = &e->txstatlog;\r\ni = log->end + 1;\r\nif (i == B43_NR_LOGGED_TXSTATUS)\r\ni = 0;\r\nlog->end = i;\r\ncur = &(log->log[i]);\r\nmemcpy(cur, status, sizeof(*cur));\r\n}\r\nvoid b43_debugfs_init(void)\r\n{\r\nrootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nif (IS_ERR(rootdir))\r\nrootdir = NULL;\r\n}\r\nvoid b43_debugfs_exit(void)\r\n{\r\ndebugfs_remove(rootdir);\r\n}
