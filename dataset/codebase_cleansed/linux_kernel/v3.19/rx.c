static u32 wlcore_rx_get_buf_size(struct wl1271 *wl,\r\nu32 rx_pkt_desc)\r\n{\r\nif (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN)\r\nreturn (rx_pkt_desc & ALIGNED_RX_BUF_SIZE_MASK) >>\r\nALIGNED_RX_BUF_SIZE_SHIFT;\r\nreturn (rx_pkt_desc & RX_BUF_SIZE_MASK) >> RX_BUF_SIZE_SHIFT_DIV;\r\n}\r\nstatic u32 wlcore_rx_get_align_buf_size(struct wl1271 *wl, u32 pkt_len)\r\n{\r\nif (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN)\r\nreturn ALIGN(pkt_len, WL12XX_BUS_BLOCK_SIZE);\r\nreturn pkt_len;\r\n}\r\nstatic void wl1271_rx_status(struct wl1271 *wl,\r\nstruct wl1271_rx_descriptor *desc,\r\nstruct ieee80211_rx_status *status,\r\nu8 beacon)\r\n{\r\nmemset(status, 0, sizeof(struct ieee80211_rx_status));\r\nif ((desc->flags & WL1271_RX_DESC_BAND_MASK) == WL1271_RX_DESC_BAND_BG)\r\nstatus->band = IEEE80211_BAND_2GHZ;\r\nelse\r\nstatus->band = IEEE80211_BAND_5GHZ;\r\nstatus->rate_idx = wlcore_rate_to_idx(wl, desc->rate, status->band);\r\nif (desc->rate <= wl->hw_min_ht_rate)\r\nstatus->flag |= RX_FLAG_HT;\r\nstatus->signal = desc->rssi;\r\nwl->noise = desc->rssi - (desc->snr >> 1);\r\nstatus->freq = ieee80211_channel_to_frequency(desc->channel,\r\nstatus->band);\r\nif (desc->flags & WL1271_RX_DESC_ENCRYPT_MASK) {\r\nu8 desc_err_code = desc->status & WL1271_RX_DESC_STATUS_MASK;\r\nstatus->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED |\r\nRX_FLAG_DECRYPTED;\r\nif (unlikely(desc_err_code & WL1271_RX_DESC_MIC_FAIL)) {\r\nstatus->flag |= RX_FLAG_MMIC_ERROR;\r\nwl1271_warning("Michael MIC error. Desc: 0x%x",\r\ndesc_err_code);\r\n}\r\n}\r\nif (beacon)\r\nwlcore_set_pending_regdomain_ch(wl, (u16)desc->channel,\r\nstatus->band);\r\n}\r\nstatic int wl1271_rx_handle_data(struct wl1271 *wl, u8 *data, u32 length,\r\nenum wl_rx_buf_align rx_align, u8 *hlid)\r\n{\r\nstruct wl1271_rx_descriptor *desc;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nu8 *buf;\r\nu8 beacon = 0;\r\nu8 is_data = 0;\r\nu8 reserved = 0, offset_to_data = 0;\r\nu16 seq_num;\r\nu32 pkt_data_len;\r\nif (unlikely(wl->plt))\r\nreturn -EINVAL;\r\npkt_data_len = wlcore_hw_get_rx_packet_len(wl, data, length);\r\nif (!pkt_data_len) {\r\nwl1271_error("Invalid packet arrived from HW. length %d",\r\nlength);\r\nreturn -EINVAL;\r\n}\r\nif (rx_align == WLCORE_RX_BUF_UNALIGNED)\r\nreserved = RX_BUF_ALIGN;\r\nelse if (rx_align == WLCORE_RX_BUF_PADDED)\r\noffset_to_data = RX_BUF_ALIGN;\r\ndesc = (struct wl1271_rx_descriptor *) data;\r\nif (desc->packet_class == WL12XX_RX_CLASS_LOGGER) {\r\nsize_t len = length - sizeof(*desc);\r\nwl12xx_copy_fwlog(wl, data + sizeof(*desc), len);\r\nwake_up_interruptible(&wl->fwlog_waitq);\r\nreturn 0;\r\n}\r\nif (desc->status & WL1271_RX_DESC_DECRYPT_FAIL) {\r\nhdr = (void *)(data + sizeof(*desc) + offset_to_data);\r\nwl1271_warning("corrupted packet in RX: status: 0x%x len: %d",\r\ndesc->status & WL1271_RX_DESC_STATUS_MASK,\r\npkt_data_len);\r\nwl1271_dump((DEBUG_RX|DEBUG_CMD), "PKT: ", data + sizeof(*desc),\r\nmin(pkt_data_len,\r\nieee80211_hdrlen(hdr->frame_control)));\r\nreturn -EINVAL;\r\n}\r\nskb = __dev_alloc_skb(pkt_data_len + reserved, GFP_KERNEL);\r\nif (!skb) {\r\nwl1271_error("Couldn't allocate RX frame");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, reserved);\r\nbuf = skb_put(skb, pkt_data_len);\r\nmemcpy(buf, data + sizeof(*desc), pkt_data_len);\r\nif (rx_align == WLCORE_RX_BUF_PADDED)\r\nskb_pull(skb, RX_BUF_ALIGN);\r\n*hlid = desc->hlid;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (ieee80211_is_beacon(hdr->frame_control))\r\nbeacon = 1;\r\nif (ieee80211_is_data_present(hdr->frame_control))\r\nis_data = 1;\r\nwl1271_rx_status(wl, desc, IEEE80211_SKB_RXCB(skb), beacon);\r\nwlcore_hw_set_rx_csum(wl, desc, skb);\r\nseq_num = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\r\nwl1271_debug(DEBUG_RX, "rx skb 0x%p: %d B %s seq %d hlid %d", skb,\r\nskb->len - desc->pad_len,\r\nbeacon ? "beacon" : "",\r\nseq_num, *hlid);\r\nskb_queue_tail(&wl->deferred_rx_queue, skb);\r\nqueue_work(wl->freezable_wq, &wl->netstack_work);\r\nreturn is_data;\r\n}\r\nint wlcore_rx(struct wl1271 *wl, struct wl_fw_status *status)\r\n{\r\nunsigned long active_hlids[BITS_TO_LONGS(WLCORE_MAX_LINKS)] = {0};\r\nu32 buf_size;\r\nu32 fw_rx_counter = status->fw_rx_counter % wl->num_rx_desc;\r\nu32 drv_rx_counter = wl->rx_counter % wl->num_rx_desc;\r\nu32 rx_counter;\r\nu32 pkt_len, align_pkt_len;\r\nu32 pkt_offset, des;\r\nu8 hlid;\r\nenum wl_rx_buf_align rx_align;\r\nint ret = 0;\r\nwhile (drv_rx_counter != fw_rx_counter) {\r\nbuf_size = 0;\r\nrx_counter = drv_rx_counter;\r\nwhile (rx_counter != fw_rx_counter) {\r\ndes = le32_to_cpu(status->rx_pkt_descs[rx_counter]);\r\npkt_len = wlcore_rx_get_buf_size(wl, des);\r\nalign_pkt_len = wlcore_rx_get_align_buf_size(wl,\r\npkt_len);\r\nif (buf_size + align_pkt_len > wl->aggr_buf_size)\r\nbreak;\r\nbuf_size += align_pkt_len;\r\nrx_counter++;\r\nrx_counter %= wl->num_rx_desc;\r\n}\r\nif (buf_size == 0) {\r\nwl1271_warning("received empty data");\r\nbreak;\r\n}\r\ndes = le32_to_cpu(status->rx_pkt_descs[drv_rx_counter]);\r\nret = wlcore_hw_prepare_read(wl, des, buf_size);\r\nif (ret < 0)\r\ngoto out;\r\nret = wlcore_read_data(wl, REG_SLV_MEM_DATA, wl->aggr_buf,\r\nbuf_size, true);\r\nif (ret < 0)\r\ngoto out;\r\npkt_offset = 0;\r\nwhile (pkt_offset < buf_size) {\r\ndes = le32_to_cpu(status->rx_pkt_descs[drv_rx_counter]);\r\npkt_len = wlcore_rx_get_buf_size(wl, des);\r\nrx_align = wlcore_hw_get_rx_buf_align(wl, des);\r\nif (wl1271_rx_handle_data(wl,\r\nwl->aggr_buf + pkt_offset,\r\npkt_len, rx_align,\r\n&hlid) == 1) {\r\nif (hlid < wl->num_links)\r\n__set_bit(hlid, active_hlids);\r\nelse\r\nWARN(1,\r\n"hlid (%d) exceeded MAX_LINKS\n",\r\nhlid);\r\n}\r\nwl->rx_counter++;\r\ndrv_rx_counter++;\r\ndrv_rx_counter %= wl->num_rx_desc;\r\npkt_offset += wlcore_rx_get_align_buf_size(wl, pkt_len);\r\n}\r\n}\r\nif (wl->quirks & WLCORE_QUIRK_END_OF_TRANSACTION) {\r\nret = wlcore_write32(wl, WL12XX_REG_RX_DRIVER_COUNTER,\r\nwl->rx_counter);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nwl12xx_rearm_rx_streaming(wl, active_hlids);\r\nout:\r\nreturn ret;\r\n}\r\nint wl1271_rx_filter_enable(struct wl1271 *wl,\r\nint index, bool enable,\r\nstruct wl12xx_rx_filter *filter)\r\n{\r\nint ret;\r\nif (!!test_bit(index, wl->rx_filter_enabled) == enable) {\r\nwl1271_warning("Request to enable an already "\r\n"enabled rx filter %d", index);\r\nreturn 0;\r\n}\r\nret = wl1271_acx_set_rx_filter(wl, index, enable, filter);\r\nif (ret) {\r\nwl1271_error("Failed to %s rx data filter %d (err=%d)",\r\nenable ? "enable" : "disable", index, ret);\r\nreturn ret;\r\n}\r\nif (enable)\r\n__set_bit(index, wl->rx_filter_enabled);\r\nelse\r\n__clear_bit(index, wl->rx_filter_enabled);\r\nreturn 0;\r\n}\r\nint wl1271_rx_filter_clear_all(struct wl1271 *wl)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < WL1271_MAX_RX_FILTERS; i++) {\r\nif (!test_bit(i, wl->rx_filter_enabled))\r\ncontinue;\r\nret = wl1271_rx_filter_enable(wl, i, 0, NULL);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}
