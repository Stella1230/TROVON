static void ar5523_read_reply(struct ar5523 *ar, struct ar5523_cmd_hdr *hdr,\r\nstruct ar5523_tx_cmd *cmd)\r\n{\r\nint dlen, olen;\r\n__be32 *rp;\r\ndlen = be32_to_cpu(hdr->len) - sizeof(*hdr);\r\nif (dlen < 0) {\r\nWARN_ON(1);\r\ngoto out;\r\n}\r\nar5523_dbg(ar, "Code = %d len = %d\n", be32_to_cpu(hdr->code) & 0xff,\r\ndlen);\r\nrp = (__be32 *)(hdr + 1);\r\nif (dlen >= sizeof(u32)) {\r\nolen = be32_to_cpu(rp[0]);\r\ndlen -= sizeof(u32);\r\nif (olen == 0) {\r\nolen = sizeof(u32);\r\n}\r\n} else\r\nolen = 0;\r\nif (cmd->odata) {\r\nif (cmd->olen < olen) {\r\nar5523_err(ar, "olen to small %d < %d\n",\r\ncmd->olen, olen);\r\ncmd->olen = 0;\r\ncmd->res = -EOVERFLOW;\r\n} else {\r\ncmd->olen = olen;\r\nmemcpy(cmd->odata, &rp[1], olen);\r\ncmd->res = 0;\r\n}\r\n}\r\nout:\r\ncomplete(&cmd->done);\r\n}\r\nstatic void ar5523_cmd_rx_cb(struct urb *urb)\r\n{\r\nstruct ar5523 *ar = urb->context;\r\nstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\r\nstruct ar5523_cmd_hdr *hdr = ar->rx_cmd_buf;\r\nint dlen;\r\nu32 code, hdrlen;\r\nif (urb->status) {\r\nif (urb->status != -ESHUTDOWN)\r\nar5523_err(ar, "RX USB error %d.\n", urb->status);\r\ngoto skip;\r\n}\r\nif (urb->actual_length < sizeof(struct ar5523_cmd_hdr)) {\r\nar5523_err(ar, "RX USB to short.\n");\r\ngoto skip;\r\n}\r\nar5523_dbg(ar, "%s code %02x priv %d\n", __func__,\r\nbe32_to_cpu(hdr->code) & 0xff, hdr->priv);\r\ncode = be32_to_cpu(hdr->code);\r\nhdrlen = be32_to_cpu(hdr->len);\r\nswitch (code & 0xff) {\r\ndefault:\r\nif (hdr->priv != AR5523_CMD_ID) {\r\nar5523_err(ar, "Unexpected command id: %02x\n",\r\ncode & 0xff);\r\ngoto skip;\r\n}\r\nar5523_read_reply(ar, hdr, cmd);\r\nbreak;\r\ncase WDCMSG_DEVICE_AVAIL:\r\nar5523_dbg(ar, "WDCMSG_DEVICE_AVAIL\n");\r\ncmd->res = 0;\r\ncmd->olen = 0;\r\ncomplete(&cmd->done);\r\nbreak;\r\ncase WDCMSG_SEND_COMPLETE:\r\nar5523_dbg(ar, "WDCMSG_SEND_COMPLETE: %d pending\n",\r\natomic_read(&ar->tx_nr_pending));\r\nif (!test_bit(AR5523_HW_UP, &ar->flags))\r\nar5523_dbg(ar, "Unexpected WDCMSG_SEND_COMPLETE\n");\r\nelse {\r\nmod_timer(&ar->tx_wd_timer,\r\njiffies + AR5523_TX_WD_TIMEOUT);\r\nar5523_data_tx_pkt_put(ar);\r\n}\r\nbreak;\r\ncase WDCMSG_TARGET_START:\r\ndlen = hdrlen - sizeof(*hdr);\r\nif (dlen != (int)sizeof(u32)) {\r\nar5523_err(ar, "Invalid reply to WDCMSG_TARGET_START");\r\nreturn;\r\n}\r\nmemcpy(cmd->odata, hdr + 1, sizeof(u32));\r\ncmd->olen = sizeof(u32);\r\ncmd->res = 0;\r\ncomplete(&cmd->done);\r\nbreak;\r\ncase WDCMSG_STATS_UPDATE:\r\nar5523_dbg(ar, "WDCMSG_STATS_UPDATE\n");\r\nbreak;\r\n}\r\nskip:\r\nar5523_submit_rx_cmd(ar);\r\n}\r\nstatic int ar5523_alloc_rx_cmd(struct ar5523 *ar)\r\n{\r\nar->rx_cmd_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ar->rx_cmd_urb)\r\nreturn -ENOMEM;\r\nar->rx_cmd_buf = usb_alloc_coherent(ar->dev, AR5523_MAX_RXCMDSZ,\r\nGFP_KERNEL,\r\n&ar->rx_cmd_urb->transfer_dma);\r\nif (!ar->rx_cmd_buf) {\r\nusb_free_urb(ar->rx_cmd_urb);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ar5523_cancel_rx_cmd(struct ar5523 *ar)\r\n{\r\nusb_kill_urb(ar->rx_cmd_urb);\r\n}\r\nstatic void ar5523_free_rx_cmd(struct ar5523 *ar)\r\n{\r\nusb_free_coherent(ar->dev, AR5523_MAX_RXCMDSZ,\r\nar->rx_cmd_buf, ar->rx_cmd_urb->transfer_dma);\r\nusb_free_urb(ar->rx_cmd_urb);\r\n}\r\nstatic int ar5523_submit_rx_cmd(struct ar5523 *ar)\r\n{\r\nint error;\r\nusb_fill_bulk_urb(ar->rx_cmd_urb, ar->dev,\r\nar5523_cmd_rx_pipe(ar->dev), ar->rx_cmd_buf,\r\nAR5523_MAX_RXCMDSZ, ar5523_cmd_rx_cb, ar);\r\nar->rx_cmd_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = usb_submit_urb(ar->rx_cmd_urb, GFP_ATOMIC);\r\nif (error) {\r\nif (error != -ENODEV)\r\nar5523_err(ar, "error %d when submitting rx urb\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ar5523_cmd_tx_cb(struct urb *urb)\r\n{\r\nstruct ar5523_tx_cmd *cmd = urb->context;\r\nstruct ar5523 *ar = cmd->ar;\r\nif (urb->status) {\r\nar5523_err(ar, "Failed to TX command. Status = %d\n",\r\nurb->status);\r\ncmd->res = urb->status;\r\ncomplete(&cmd->done);\r\nreturn;\r\n}\r\nif (!(cmd->flags & AR5523_CMD_FLAG_READ)) {\r\ncmd->res = 0;\r\ncomplete(&cmd->done);\r\n}\r\n}\r\nstatic int ar5523_cmd(struct ar5523 *ar, u32 code, const void *idata,\r\nint ilen, void *odata, int olen, int flags)\r\n{\r\nstruct ar5523_cmd_hdr *hdr;\r\nstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\r\nint xferlen, error;\r\nxferlen = (sizeof(struct ar5523_cmd_hdr) + ilen + 3) & ~3;\r\nhdr = (struct ar5523_cmd_hdr *)cmd->buf_tx;\r\nmemset(hdr, 0, sizeof(struct ar5523_cmd_hdr));\r\nhdr->len = cpu_to_be32(xferlen);\r\nhdr->code = cpu_to_be32(code);\r\nhdr->priv = AR5523_CMD_ID;\r\nif (flags & AR5523_CMD_FLAG_MAGIC)\r\nhdr->magic = cpu_to_be32(1 << 24);\r\nmemcpy(hdr + 1, idata, ilen);\r\ncmd->odata = odata;\r\ncmd->olen = olen;\r\ncmd->flags = flags;\r\nar5523_dbg(ar, "do cmd %02x\n", code);\r\nusb_fill_bulk_urb(cmd->urb_tx, ar->dev, ar5523_cmd_tx_pipe(ar->dev),\r\ncmd->buf_tx, xferlen, ar5523_cmd_tx_cb, cmd);\r\ncmd->urb_tx->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = usb_submit_urb(cmd->urb_tx, GFP_KERNEL);\r\nif (error) {\r\nar5523_err(ar, "could not send command 0x%x, error=%d\n",\r\ncode, error);\r\nreturn error;\r\n}\r\nif (!wait_for_completion_timeout(&cmd->done, 2 * HZ)) {\r\ncmd->odata = NULL;\r\nar5523_err(ar, "timeout waiting for command %02x reply\n",\r\ncode);\r\ncmd->res = -ETIMEDOUT;\r\n}\r\nreturn cmd->res;\r\n}\r\nstatic int ar5523_cmd_write(struct ar5523 *ar, u32 code, const void *data,\r\nint len, int flags)\r\n{\r\nflags &= ~AR5523_CMD_FLAG_READ;\r\nreturn ar5523_cmd(ar, code, data, len, NULL, 0, flags);\r\n}\r\nstatic int ar5523_cmd_read(struct ar5523 *ar, u32 code, const void *idata,\r\nint ilen, void *odata, int olen, int flags)\r\n{\r\nflags |= AR5523_CMD_FLAG_READ;\r\nreturn ar5523_cmd(ar, code, idata, ilen, odata, olen, flags);\r\n}\r\nstatic int ar5523_config(struct ar5523 *ar, u32 reg, u32 val)\r\n{\r\nstruct ar5523_write_mac write;\r\nint error;\r\nwrite.reg = cpu_to_be32(reg);\r\nwrite.len = cpu_to_be32(0);\r\n*(__be32 *)write.data = cpu_to_be32(val);\r\nerror = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,\r\n3 * sizeof(u32), 0);\r\nif (error != 0)\r\nar5523_err(ar, "could not write register 0x%02x\n", reg);\r\nreturn error;\r\n}\r\nstatic int ar5523_config_multi(struct ar5523 *ar, u32 reg, const void *data,\r\nint len)\r\n{\r\nstruct ar5523_write_mac write;\r\nint error;\r\nwrite.reg = cpu_to_be32(reg);\r\nwrite.len = cpu_to_be32(len);\r\nmemcpy(write.data, data, len);\r\nerror = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,\r\n(len == 0) ? sizeof(u32) : 2 * sizeof(u32) + len, 0);\r\nif (error != 0)\r\nar5523_err(ar, "could not write %d bytes to register 0x%02x\n",\r\nlen, reg);\r\nreturn error;\r\n}\r\nstatic int ar5523_get_status(struct ar5523 *ar, u32 which, void *odata,\r\nint olen)\r\n{\r\nint error;\r\n__be32 which_be;\r\nwhich_be = cpu_to_be32(which);\r\nerror = ar5523_cmd_read(ar, WDCMSG_TARGET_GET_STATUS,\r\n&which_be, sizeof(which_be), odata, olen, AR5523_CMD_FLAG_MAGIC);\r\nif (error != 0)\r\nar5523_err(ar, "could not read EEPROM offset 0x%02x\n", which);\r\nreturn error;\r\n}\r\nstatic int ar5523_get_capability(struct ar5523 *ar, u32 cap, u32 *val)\r\n{\r\nint error;\r\n__be32 cap_be, val_be;\r\ncap_be = cpu_to_be32(cap);\r\nerror = ar5523_cmd_read(ar, WDCMSG_TARGET_GET_CAPABILITY, &cap_be,\r\nsizeof(cap_be), &val_be, sizeof(__be32),\r\nAR5523_CMD_FLAG_MAGIC);\r\nif (error != 0) {\r\nar5523_err(ar, "could not read capability %u\n", cap);\r\nreturn error;\r\n}\r\n*val = be32_to_cpu(val_be);\r\nreturn error;\r\n}\r\nstatic int ar5523_get_devcap(struct ar5523 *ar)\r\n{\r\n#define GETCAP(x) do { \\r\nerror = ar5523_get_capability(ar, x, &cap); \\r\nif (error != 0) \\r\nreturn error; \\r\nar5523_info(ar, "Cap: " \\r\n"%s=0x%08x\n", #x, cap); \\r\n} while (0)\r\nint error;\r\nu32 cap;\r\nGETCAP(CAP_TARGET_VERSION);\r\nGETCAP(CAP_TARGET_REVISION);\r\nGETCAP(CAP_MAC_VERSION);\r\nGETCAP(CAP_MAC_REVISION);\r\nGETCAP(CAP_PHY_REVISION);\r\nGETCAP(CAP_ANALOG_5GHz_REVISION);\r\nGETCAP(CAP_ANALOG_2GHz_REVISION);\r\nGETCAP(CAP_REG_DOMAIN);\r\nGETCAP(CAP_REG_CAP_BITS);\r\nGETCAP(CAP_WIRELESS_MODES);\r\nGETCAP(CAP_CHAN_SPREAD_SUPPORT);\r\nGETCAP(CAP_COMPRESS_SUPPORT);\r\nGETCAP(CAP_BURST_SUPPORT);\r\nGETCAP(CAP_FAST_FRAMES_SUPPORT);\r\nGETCAP(CAP_CHAP_TUNING_SUPPORT);\r\nGETCAP(CAP_TURBOG_SUPPORT);\r\nGETCAP(CAP_TURBO_PRIME_SUPPORT);\r\nGETCAP(CAP_DEVICE_TYPE);\r\nGETCAP(CAP_WME_SUPPORT);\r\nGETCAP(CAP_TOTAL_QUEUES);\r\nGETCAP(CAP_CONNECTION_ID_MAX);\r\nGETCAP(CAP_LOW_5GHZ_CHAN);\r\nGETCAP(CAP_HIGH_5GHZ_CHAN);\r\nGETCAP(CAP_LOW_2GHZ_CHAN);\r\nGETCAP(CAP_HIGH_2GHZ_CHAN);\r\nGETCAP(CAP_TWICE_ANTENNAGAIN_5G);\r\nGETCAP(CAP_TWICE_ANTENNAGAIN_2G);\r\nGETCAP(CAP_CIPHER_AES_CCM);\r\nGETCAP(CAP_CIPHER_TKIP);\r\nGETCAP(CAP_MIC_TKIP);\r\nreturn 0;\r\n}\r\nstatic int ar5523_set_ledsteady(struct ar5523 *ar, int lednum, int ledmode)\r\n{\r\nstruct ar5523_cmd_ledsteady led;\r\nled.lednum = cpu_to_be32(lednum);\r\nled.ledmode = cpu_to_be32(ledmode);\r\nar5523_dbg(ar, "set %s led %s (steady)\n",\r\n(lednum == UATH_LED_LINK) ? "link" : "activity",\r\nledmode ? "on" : "off");\r\nreturn ar5523_cmd_write(ar, WDCMSG_SET_LED_STEADY, &led, sizeof(led),\r\n0);\r\n}\r\nstatic int ar5523_set_rxfilter(struct ar5523 *ar, u32 bits, u32 op)\r\n{\r\nstruct ar5523_cmd_rx_filter rxfilter;\r\nrxfilter.bits = cpu_to_be32(bits);\r\nrxfilter.op = cpu_to_be32(op);\r\nar5523_dbg(ar, "setting Rx filter=0x%x flags=0x%x\n", bits, op);\r\nreturn ar5523_cmd_write(ar, WDCMSG_RX_FILTER, &rxfilter,\r\nsizeof(rxfilter), 0);\r\n}\r\nstatic int ar5523_reset_tx_queues(struct ar5523 *ar)\r\n{\r\n__be32 qid = cpu_to_be32(0);\r\nar5523_dbg(ar, "resetting Tx queue\n");\r\nreturn ar5523_cmd_write(ar, WDCMSG_RELEASE_TX_QUEUE,\r\n&qid, sizeof(qid), 0);\r\n}\r\nstatic int ar5523_set_chan(struct ar5523 *ar)\r\n{\r\nstruct ieee80211_conf *conf = &ar->hw->conf;\r\nstruct ar5523_cmd_reset reset;\r\nmemset(&reset, 0, sizeof(reset));\r\nreset.flags |= cpu_to_be32(UATH_CHAN_2GHZ);\r\nreset.flags |= cpu_to_be32(UATH_CHAN_OFDM);\r\nreset.freq = cpu_to_be32(conf->chandef.chan->center_freq);\r\nreset.maxrdpower = cpu_to_be32(50);\r\nreset.channelchange = cpu_to_be32(1);\r\nreset.keeprccontent = cpu_to_be32(0);\r\nar5523_dbg(ar, "set chan flags 0x%x freq %d\n",\r\nbe32_to_cpu(reset.flags),\r\nconf->chandef.chan->center_freq);\r\nreturn ar5523_cmd_write(ar, WDCMSG_RESET, &reset, sizeof(reset), 0);\r\n}\r\nstatic int ar5523_queue_init(struct ar5523 *ar)\r\n{\r\nstruct ar5523_cmd_txq_setup qinfo;\r\nar5523_dbg(ar, "setting up Tx queue\n");\r\nqinfo.qid = cpu_to_be32(0);\r\nqinfo.len = cpu_to_be32(sizeof(qinfo.attr));\r\nqinfo.attr.priority = cpu_to_be32(0);\r\nqinfo.attr.aifs = cpu_to_be32(3);\r\nqinfo.attr.logcwmin = cpu_to_be32(4);\r\nqinfo.attr.logcwmax = cpu_to_be32(10);\r\nqinfo.attr.bursttime = cpu_to_be32(0);\r\nqinfo.attr.mode = cpu_to_be32(0);\r\nqinfo.attr.qflags = cpu_to_be32(1);\r\nreturn ar5523_cmd_write(ar, WDCMSG_SETUP_TX_QUEUE, &qinfo,\r\nsizeof(qinfo), 0);\r\n}\r\nstatic int ar5523_switch_chan(struct ar5523 *ar)\r\n{\r\nint error;\r\nerror = ar5523_set_chan(ar);\r\nif (error) {\r\nar5523_err(ar, "could not set chan, error %d\n", error);\r\ngoto out_err;\r\n}\r\nerror = ar5523_reset_tx_queues(ar);\r\nif (error) {\r\nar5523_err(ar, "could not reset Tx queues, error %d\n",\r\nerror);\r\ngoto out_err;\r\n}\r\nerror = ar5523_queue_init(ar);\r\nif (error)\r\nar5523_err(ar, "could not init wme, error %d\n", error);\r\nout_err:\r\nreturn error;\r\n}\r\nstatic void ar5523_rx_data_put(struct ar5523 *ar,\r\nstruct ar5523_rx_data *data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ar->rx_data_list_lock, flags);\r\nlist_move(&data->list, &ar->rx_data_free);\r\nspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\r\n}\r\nstatic void ar5523_data_rx_cb(struct urb *urb)\r\n{\r\nstruct ar5523_rx_data *data = urb->context;\r\nstruct ar5523 *ar = data->ar;\r\nstruct ar5523_rx_desc *desc;\r\nstruct ar5523_chunk *chunk;\r\nstruct ieee80211_hw *hw = ar->hw;\r\nstruct ieee80211_rx_status *rx_status;\r\nu32 rxlen;\r\nint usblen = urb->actual_length;\r\nint hdrlen, pad;\r\nar5523_dbg(ar, "%s\n", __func__);\r\nif (urb->status) {\r\nif (urb->status != -ESHUTDOWN)\r\nar5523_err(ar, "%s: USB err: %d\n", __func__,\r\nurb->status);\r\ngoto skip;\r\n}\r\nif (usblen < AR5523_MIN_RXBUFSZ) {\r\nar5523_err(ar, "RX: wrong xfer size (usblen=%d)\n", usblen);\r\ngoto skip;\r\n}\r\nchunk = (struct ar5523_chunk *) data->skb->data;\r\nif (((chunk->flags & UATH_CFLAGS_FINAL) == 0) ||\r\nchunk->seqnum != 0) {\r\nar5523_dbg(ar, "RX: No final flag. s: %d f: %02x l: %d\n",\r\nchunk->seqnum, chunk->flags,\r\nbe16_to_cpu(chunk->length));\r\ngoto skip;\r\n}\r\ndesc = (struct ar5523_rx_desc *)\r\n(data->skb->data + usblen - sizeof(struct ar5523_rx_desc));\r\nrxlen = be32_to_cpu(desc->len);\r\nif (rxlen > ar->rxbufsz) {\r\nar5523_dbg(ar, "RX: Bad descriptor (len=%d)\n",\r\nbe32_to_cpu(desc->len));\r\ngoto skip;\r\n}\r\nif (!rxlen) {\r\nar5523_dbg(ar, "RX: rxlen is 0\n");\r\ngoto skip;\r\n}\r\nif (be32_to_cpu(desc->status) != 0) {\r\nar5523_dbg(ar, "Bad RX status (0x%x len = %d). Skip\n",\r\nbe32_to_cpu(desc->status), be32_to_cpu(desc->len));\r\ngoto skip;\r\n}\r\nskb_reserve(data->skb, sizeof(*chunk));\r\nskb_put(data->skb, rxlen - sizeof(struct ar5523_rx_desc));\r\nhdrlen = ieee80211_get_hdrlen_from_skb(data->skb);\r\nif (!IS_ALIGNED(hdrlen, 4)) {\r\nar5523_dbg(ar, "eek, alignment workaround activated\n");\r\npad = ALIGN(hdrlen, 4) - hdrlen;\r\nmemmove(data->skb->data + pad, data->skb->data, hdrlen);\r\nskb_pull(data->skb, pad);\r\nskb_put(data->skb, pad);\r\n}\r\nrx_status = IEEE80211_SKB_RXCB(data->skb);\r\nmemset(rx_status, 0, sizeof(*rx_status));\r\nrx_status->freq = be32_to_cpu(desc->channel);\r\nrx_status->band = hw->conf.chandef.chan->band;\r\nrx_status->signal = -95 + be32_to_cpu(desc->rssi);\r\nieee80211_rx_irqsafe(hw, data->skb);\r\ndata->skb = NULL;\r\nskip:\r\nif (data->skb) {\r\ndev_kfree_skb_irq(data->skb);\r\ndata->skb = NULL;\r\n}\r\nar5523_rx_data_put(ar, data);\r\nif (atomic_inc_return(&ar->rx_data_free_cnt) >=\r\nAR5523_RX_DATA_REFILL_COUNT &&\r\ntest_bit(AR5523_HW_UP, &ar->flags))\r\nqueue_work(ar->wq, &ar->rx_refill_work);\r\n}\r\nstatic void ar5523_rx_refill_work(struct work_struct *work)\r\n{\r\nstruct ar5523 *ar = container_of(work, struct ar5523, rx_refill_work);\r\nstruct ar5523_rx_data *data;\r\nunsigned long flags;\r\nint error;\r\nar5523_dbg(ar, "%s\n", __func__);\r\ndo {\r\nspin_lock_irqsave(&ar->rx_data_list_lock, flags);\r\nif (!list_empty(&ar->rx_data_free))\r\ndata = (struct ar5523_rx_data *) ar->rx_data_free.next;\r\nelse\r\ndata = NULL;\r\nspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\r\nif (!data)\r\ngoto done;\r\ndata->skb = alloc_skb(ar->rxbufsz, GFP_KERNEL);\r\nif (!data->skb) {\r\nar5523_err(ar, "could not allocate rx skbuff\n");\r\nreturn;\r\n}\r\nusb_fill_bulk_urb(data->urb, ar->dev,\r\nar5523_data_rx_pipe(ar->dev), data->skb->data,\r\nar->rxbufsz, ar5523_data_rx_cb, data);\r\nspin_lock_irqsave(&ar->rx_data_list_lock, flags);\r\nlist_move(&data->list, &ar->rx_data_used);\r\nspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\r\natomic_dec(&ar->rx_data_free_cnt);\r\nerror = usb_submit_urb(data->urb, GFP_KERNEL);\r\nif (error) {\r\nkfree_skb(data->skb);\r\nif (error != -ENODEV)\r\nar5523_err(ar, "Err sending rx data urb %d\n",\r\nerror);\r\nar5523_rx_data_put(ar, data);\r\natomic_inc(&ar->rx_data_free_cnt);\r\nreturn;\r\n}\r\n} while (true);\r\ndone:\r\nreturn;\r\n}\r\nstatic void ar5523_cancel_rx_bufs(struct ar5523 *ar)\r\n{\r\nstruct ar5523_rx_data *data;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&ar->rx_data_list_lock, flags);\r\nif (!list_empty(&ar->rx_data_used))\r\ndata = (struct ar5523_rx_data *) ar->rx_data_used.next;\r\nelse\r\ndata = NULL;\r\nspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\r\nif (!data)\r\nbreak;\r\nusb_kill_urb(data->urb);\r\nlist_move(&data->list, &ar->rx_data_free);\r\natomic_inc(&ar->rx_data_free_cnt);\r\n} while (data);\r\n}\r\nstatic void ar5523_free_rx_bufs(struct ar5523 *ar)\r\n{\r\nstruct ar5523_rx_data *data;\r\nar5523_cancel_rx_bufs(ar);\r\nwhile (!list_empty(&ar->rx_data_free)) {\r\ndata = (struct ar5523_rx_data *) ar->rx_data_free.next;\r\nlist_del(&data->list);\r\nusb_free_urb(data->urb);\r\n}\r\n}\r\nstatic int ar5523_alloc_rx_bufs(struct ar5523 *ar)\r\n{\r\nint i;\r\nfor (i = 0; i < AR5523_RX_DATA_COUNT; i++) {\r\nstruct ar5523_rx_data *data = &ar->rx_data[i];\r\ndata->ar = ar;\r\ndata->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!data->urb) {\r\nar5523_err(ar, "could not allocate rx data urb\n");\r\ngoto err;\r\n}\r\nlist_add_tail(&data->list, &ar->rx_data_free);\r\natomic_inc(&ar->rx_data_free_cnt);\r\n}\r\nreturn 0;\r\nerr:\r\nar5523_free_rx_bufs(ar);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ar5523_data_tx_pkt_put(struct ar5523 *ar)\r\n{\r\natomic_dec(&ar->tx_nr_total);\r\nif (!atomic_dec_return(&ar->tx_nr_pending)) {\r\ndel_timer(&ar->tx_wd_timer);\r\nwake_up(&ar->tx_flush_waitq);\r\n}\r\nif (atomic_read(&ar->tx_nr_total) < AR5523_TX_DATA_RESTART_COUNT) {\r\nar5523_dbg(ar, "restart tx queue\n");\r\nieee80211_wake_queues(ar->hw);\r\n}\r\n}\r\nstatic void ar5523_data_tx_cb(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = urb->context;\r\nstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\r\nstruct ar5523_tx_data *data = (struct ar5523_tx_data *)\r\ntxi->driver_data;\r\nstruct ar5523 *ar = data->ar;\r\nunsigned long flags;\r\nar5523_dbg(ar, "data tx urb completed: %d\n", urb->status);\r\nspin_lock_irqsave(&ar->tx_data_list_lock, flags);\r\nlist_del(&data->list);\r\nspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\r\nif (urb->status) {\r\nar5523_dbg(ar, "%s: urb status: %d\n", __func__, urb->status);\r\nar5523_data_tx_pkt_put(ar);\r\nieee80211_free_txskb(ar->hw, skb);\r\n} else {\r\nskb_pull(skb, sizeof(struct ar5523_tx_desc) + sizeof(__be32));\r\nieee80211_tx_status_irqsafe(ar->hw, skb);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nstatic void ar5523_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\r\nstruct ar5523_tx_data *data = (struct ar5523_tx_data *)\r\ntxi->driver_data;\r\nstruct ar5523 *ar = hw->priv;\r\nunsigned long flags;\r\nar5523_dbg(ar, "tx called\n");\r\nif (atomic_inc_return(&ar->tx_nr_total) >= AR5523_TX_DATA_COUNT) {\r\nar5523_dbg(ar, "tx queue full\n");\r\nar5523_dbg(ar, "stop queues (tot %d pend %d)\n",\r\natomic_read(&ar->tx_nr_total),\r\natomic_read(&ar->tx_nr_pending));\r\nieee80211_stop_queues(hw);\r\n}\r\ndata->skb = skb;\r\nspin_lock_irqsave(&ar->tx_data_list_lock, flags);\r\nlist_add_tail(&data->list, &ar->tx_queue_pending);\r\nspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\r\nieee80211_queue_work(ar->hw, &ar->tx_work);\r\n}\r\nstatic void ar5523_tx_work_locked(struct ar5523 *ar)\r\n{\r\nstruct ar5523_tx_data *data;\r\nstruct ar5523_tx_desc *desc;\r\nstruct ar5523_chunk *chunk;\r\nstruct ieee80211_tx_info *txi;\r\nstruct urb *urb;\r\nstruct sk_buff *skb;\r\nint error = 0, paylen;\r\nu32 txqid;\r\nunsigned long flags;\r\nBUILD_BUG_ON(sizeof(struct ar5523_tx_data) >\r\nIEEE80211_TX_INFO_DRIVER_DATA_SIZE);\r\nar5523_dbg(ar, "%s\n", __func__);\r\ndo {\r\nspin_lock_irqsave(&ar->tx_data_list_lock, flags);\r\nif (!list_empty(&ar->tx_queue_pending)) {\r\ndata = (struct ar5523_tx_data *)\r\nar->tx_queue_pending.next;\r\nlist_del(&data->list);\r\n} else\r\ndata = NULL;\r\nspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\r\nif (!data)\r\nbreak;\r\nskb = data->skb;\r\ntxqid = 0;\r\ntxi = IEEE80211_SKB_CB(skb);\r\npaylen = skb->len;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nar5523_err(ar, "Failed to allocate TX urb\n");\r\nieee80211_free_txskb(ar->hw, skb);\r\ncontinue;\r\n}\r\ndata->ar = ar;\r\ndata->urb = urb;\r\ndesc = (struct ar5523_tx_desc *)skb_push(skb, sizeof(*desc));\r\nchunk = (struct ar5523_chunk *)skb_push(skb, sizeof(*chunk));\r\nchunk->seqnum = 0;\r\nchunk->flags = UATH_CFLAGS_FINAL;\r\nchunk->length = cpu_to_be16(skb->len);\r\ndesc->msglen = cpu_to_be32(skb->len);\r\ndesc->msgid = AR5523_DATA_ID;\r\ndesc->buflen = cpu_to_be32(paylen);\r\ndesc->type = cpu_to_be32(WDCMSG_SEND);\r\ndesc->flags = cpu_to_be32(UATH_TX_NOTIFY);\r\nif (test_bit(AR5523_CONNECTED, &ar->flags))\r\ndesc->connid = cpu_to_be32(AR5523_ID_BSS);\r\nelse\r\ndesc->connid = cpu_to_be32(AR5523_ID_BROADCAST);\r\nif (txi->flags & IEEE80211_TX_CTL_USE_MINRATE)\r\ntxqid |= UATH_TXQID_MINRATE;\r\ndesc->txqid = cpu_to_be32(txqid);\r\nurb->transfer_flags = URB_ZERO_PACKET;\r\nusb_fill_bulk_urb(urb, ar->dev, ar5523_data_tx_pipe(ar->dev),\r\nskb->data, skb->len, ar5523_data_tx_cb, skb);\r\nspin_lock_irqsave(&ar->tx_data_list_lock, flags);\r\nlist_add_tail(&data->list, &ar->tx_queue_submitted);\r\nspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\r\nmod_timer(&ar->tx_wd_timer, jiffies + AR5523_TX_WD_TIMEOUT);\r\natomic_inc(&ar->tx_nr_pending);\r\nar5523_dbg(ar, "TX Frame (%d pending)\n",\r\natomic_read(&ar->tx_nr_pending));\r\nerror = usb_submit_urb(urb, GFP_KERNEL);\r\nif (error) {\r\nar5523_err(ar, "error %d when submitting tx urb\n",\r\nerror);\r\nspin_lock_irqsave(&ar->tx_data_list_lock, flags);\r\nlist_del(&data->list);\r\nspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\r\natomic_dec(&ar->tx_nr_pending);\r\nar5523_data_tx_pkt_put(ar);\r\nusb_free_urb(urb);\r\nieee80211_free_txskb(ar->hw, skb);\r\n}\r\n} while (true);\r\n}\r\nstatic void ar5523_tx_work(struct work_struct *work)\r\n{\r\nstruct ar5523 *ar = container_of(work, struct ar5523, tx_work);\r\nar5523_dbg(ar, "%s\n", __func__);\r\nmutex_lock(&ar->mutex);\r\nar5523_tx_work_locked(ar);\r\nmutex_unlock(&ar->mutex);\r\n}\r\nstatic void ar5523_tx_wd_timer(unsigned long arg)\r\n{\r\nstruct ar5523 *ar = (struct ar5523 *) arg;\r\nar5523_dbg(ar, "TX watchdog timer triggered\n");\r\nieee80211_queue_work(ar->hw, &ar->tx_wd_work);\r\n}\r\nstatic void ar5523_tx_wd_work(struct work_struct *work)\r\n{\r\nstruct ar5523 *ar = container_of(work, struct ar5523, tx_wd_work);\r\nmutex_lock(&ar->mutex);\r\nar5523_err(ar, "TX queue stuck (tot %d pend %d)\n",\r\natomic_read(&ar->tx_nr_total),\r\natomic_read(&ar->tx_nr_pending));\r\nar5523_err(ar, "Will restart dongle.\n");\r\nar5523_cmd_write(ar, WDCMSG_TARGET_RESET, NULL, 0, 0);\r\nmutex_unlock(&ar->mutex);\r\n}\r\nstatic void ar5523_flush_tx(struct ar5523 *ar)\r\n{\r\nar5523_tx_work_locked(ar);\r\nif (test_bit(AR5523_USB_DISCONNECTED, &ar->flags))\r\nreturn;\r\nif (!wait_event_timeout(ar->tx_flush_waitq,\r\n!atomic_read(&ar->tx_nr_pending), AR5523_FLUSH_TIMEOUT))\r\nar5523_err(ar, "flush timeout (tot %d pend %d)\n",\r\natomic_read(&ar->tx_nr_total),\r\natomic_read(&ar->tx_nr_pending));\r\n}\r\nstatic void ar5523_free_tx_cmd(struct ar5523 *ar)\r\n{\r\nstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\r\nusb_free_coherent(ar->dev, AR5523_MAX_RXCMDSZ, cmd->buf_tx,\r\ncmd->urb_tx->transfer_dma);\r\nusb_free_urb(cmd->urb_tx);\r\n}\r\nstatic int ar5523_alloc_tx_cmd(struct ar5523 *ar)\r\n{\r\nstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\r\ncmd->ar = ar;\r\ninit_completion(&cmd->done);\r\ncmd->urb_tx = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!cmd->urb_tx) {\r\nar5523_err(ar, "could not allocate urb\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->buf_tx = usb_alloc_coherent(ar->dev, AR5523_MAX_TXCMDSZ,\r\nGFP_KERNEL,\r\n&cmd->urb_tx->transfer_dma);\r\nif (!cmd->buf_tx) {\r\nusb_free_urb(cmd->urb_tx);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ar5523_stat_work(struct work_struct *work)\r\n{\r\nstruct ar5523 *ar = container_of(work, struct ar5523, stat_work.work);\r\nint error;\r\nar5523_dbg(ar, "%s\n", __func__);\r\nmutex_lock(&ar->mutex);\r\nerror = ar5523_cmd_write(ar, WDCMSG_TARGET_GET_STATS, NULL, 0, 0);\r\nif (error)\r\nar5523_err(ar, "could not query stats, error %d\n", error);\r\nmutex_unlock(&ar->mutex);\r\nieee80211_queue_delayed_work(ar->hw, &ar->stat_work, HZ);\r\n}\r\nstatic int ar5523_start(struct ieee80211_hw *hw)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nint error;\r\n__be32 val;\r\nar5523_dbg(ar, "start called\n");\r\nmutex_lock(&ar->mutex);\r\nval = cpu_to_be32(0);\r\nar5523_cmd_write(ar, WDCMSG_BIND, &val, sizeof(val), 0);\r\nar5523_config_multi(ar, CFG_MAC_ADDR, &ar->hw->wiphy->perm_addr,\r\nETH_ALEN);\r\nar5523_config(ar, CFG_RATE_CONTROL_ENABLE, 0x00000001);\r\nar5523_config(ar, CFG_DIVERSITY_CTL, 0x00000001);\r\nar5523_config(ar, CFG_ABOLT, 0x0000003f);\r\nar5523_config(ar, CFG_WME_ENABLED, 0x00000000);\r\nar5523_config(ar, CFG_SERVICE_TYPE, 1);\r\nar5523_config(ar, CFG_TP_SCALE, 0x00000000);\r\nar5523_config(ar, CFG_TPC_HALF_DBM5, 0x0000003c);\r\nar5523_config(ar, CFG_TPC_HALF_DBM2, 0x0000003c);\r\nar5523_config(ar, CFG_OVERRD_TX_POWER, 0x00000000);\r\nar5523_config(ar, CFG_GMODE_PROTECTION, 0x00000000);\r\nar5523_config(ar, CFG_GMODE_PROTECT_RATE_INDEX, 0x00000003);\r\nar5523_config(ar, CFG_PROTECTION_TYPE, 0x00000000);\r\nar5523_config(ar, CFG_MODE_CTS, 0x00000002);\r\nerror = ar5523_cmd_read(ar, WDCMSG_TARGET_START, NULL, 0,\r\n&val, sizeof(val), AR5523_CMD_FLAG_MAGIC);\r\nif (error) {\r\nar5523_dbg(ar, "could not start target, error %d\n", error);\r\ngoto err;\r\n}\r\nar5523_dbg(ar, "WDCMSG_TARGET_START returns handle: 0x%x\n",\r\nbe32_to_cpu(val));\r\nar5523_switch_chan(ar);\r\nval = cpu_to_be32(TARGET_DEVICE_AWAKE);\r\nar5523_cmd_write(ar, WDCMSG_SET_PWR_MODE, &val, sizeof(val), 0);\r\nar5523_cmd_write(ar, WDCMSG_RESET_KEY_CACHE, NULL, 0, 0);\r\nset_bit(AR5523_HW_UP, &ar->flags);\r\nqueue_work(ar->wq, &ar->rx_refill_work);\r\nar5523_set_rxfilter(ar, 0, UATH_FILTER_OP_INIT);\r\nar5523_set_rxfilter(ar,\r\nUATH_FILTER_RX_UCAST | UATH_FILTER_RX_MCAST |\r\nUATH_FILTER_RX_BCAST | UATH_FILTER_RX_BEACON,\r\nUATH_FILTER_OP_SET);\r\nar5523_set_ledsteady(ar, UATH_LED_ACTIVITY, UATH_LED_ON);\r\nar5523_dbg(ar, "start OK\n");\r\nerr:\r\nmutex_unlock(&ar->mutex);\r\nreturn error;\r\n}\r\nstatic void ar5523_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "stop called\n");\r\ncancel_delayed_work_sync(&ar->stat_work);\r\nmutex_lock(&ar->mutex);\r\nclear_bit(AR5523_HW_UP, &ar->flags);\r\nar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_OFF);\r\nar5523_set_ledsteady(ar, UATH_LED_ACTIVITY, UATH_LED_OFF);\r\nar5523_cmd_write(ar, WDCMSG_TARGET_STOP, NULL, 0, 0);\r\ndel_timer_sync(&ar->tx_wd_timer);\r\ncancel_work_sync(&ar->tx_wd_work);\r\ncancel_work_sync(&ar->rx_refill_work);\r\nar5523_cancel_rx_bufs(ar);\r\nmutex_unlock(&ar->mutex);\r\n}\r\nstatic int ar5523_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nint ret;\r\nar5523_dbg(ar, "set_rts_threshold called\n");\r\nmutex_lock(&ar->mutex);\r\nret = ar5523_config(ar, CFG_USER_RTS_THRESHOLD, value);\r\nmutex_unlock(&ar->mutex);\r\nreturn ret;\r\n}\r\nstatic void ar5523_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu32 queues, bool drop)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "flush called\n");\r\nar5523_flush_tx(ar);\r\n}\r\nstatic int ar5523_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "add interface called\n");\r\nif (ar->vif) {\r\nar5523_dbg(ar, "invalid add_interface\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nar->vif = vif;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ar5523_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "remove interface called\n");\r\nar->vif = NULL;\r\n}\r\nstatic int ar5523_hwconfig(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "config called\n");\r\nmutex_lock(&ar->mutex);\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nar5523_dbg(ar, "Do channel switch\n");\r\nar5523_flush_tx(ar);\r\nar5523_switch_chan(ar);\r\n}\r\nmutex_unlock(&ar->mutex);\r\nreturn 0;\r\n}\r\nstatic int ar5523_get_wlan_mode(struct ar5523 *ar,\r\nstruct ieee80211_bss_conf *bss_conf)\r\n{\r\nstruct ieee80211_supported_band *band;\r\nint bit;\r\nstruct ieee80211_sta *sta;\r\nu32 sta_rate_set;\r\nband = ar->hw->wiphy->bands[ar->hw->conf.chandef.chan->band];\r\nsta = ieee80211_find_sta(ar->vif, bss_conf->bssid);\r\nif (!sta) {\r\nar5523_info(ar, "STA not found!\n");\r\nreturn WLAN_MODE_11b;\r\n}\r\nsta_rate_set = sta->supp_rates[ar->hw->conf.chandef.chan->band];\r\nfor (bit = 0; bit < band->n_bitrates; bit++) {\r\nif (sta_rate_set & 1) {\r\nint rate = band->bitrates[bit].bitrate;\r\nswitch (rate) {\r\ncase 60:\r\ncase 90:\r\ncase 120:\r\ncase 180:\r\ncase 240:\r\ncase 360:\r\ncase 480:\r\ncase 540:\r\nreturn WLAN_MODE_11g;\r\n}\r\n}\r\nsta_rate_set >>= 1;\r\n}\r\nreturn WLAN_MODE_11b;\r\n}\r\nstatic void ar5523_create_rateset(struct ar5523 *ar,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nstruct ar5523_cmd_rateset *rs,\r\nbool basic)\r\n{\r\nstruct ieee80211_supported_band *band;\r\nstruct ieee80211_sta *sta;\r\nint bit, i = 0;\r\nu32 sta_rate_set, basic_rate_set;\r\nsta = ieee80211_find_sta(ar->vif, bss_conf->bssid);\r\nbasic_rate_set = bss_conf->basic_rates;\r\nif (!sta) {\r\nar5523_info(ar, "STA not found. Cannot set rates\n");\r\nsta_rate_set = bss_conf->basic_rates;\r\n} else\r\nsta_rate_set = sta->supp_rates[ar->hw->conf.chandef.chan->band];\r\nar5523_dbg(ar, "sta rate_set = %08x\n", sta_rate_set);\r\nband = ar->hw->wiphy->bands[ar->hw->conf.chandef.chan->band];\r\nfor (bit = 0; bit < band->n_bitrates; bit++) {\r\nBUG_ON(i >= AR5523_MAX_NRATES);\r\nar5523_dbg(ar, "Considering rate %d : %d\n",\r\nband->bitrates[bit].hw_value, sta_rate_set & 1);\r\nif (sta_rate_set & 1) {\r\nrs->set[i] = band->bitrates[bit].hw_value;\r\nif (basic_rate_set & 1 && basic)\r\nrs->set[i] |= 0x80;\r\ni++;\r\n}\r\nsta_rate_set >>= 1;\r\nbasic_rate_set >>= 1;\r\n}\r\nrs->length = i;\r\n}\r\nstatic int ar5523_set_basic_rates(struct ar5523 *ar,\r\nstruct ieee80211_bss_conf *bss)\r\n{\r\nstruct ar5523_cmd_rates rates;\r\nmemset(&rates, 0, sizeof(rates));\r\nrates.connid = cpu_to_be32(2);\r\nrates.size = cpu_to_be32(sizeof(struct ar5523_cmd_rateset));\r\nar5523_create_rateset(ar, bss, &rates.rateset, true);\r\nreturn ar5523_cmd_write(ar, WDCMSG_SET_BASIC_RATE, &rates,\r\nsizeof(rates), 0);\r\n}\r\nstatic int ar5523_create_connection(struct ar5523 *ar,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss)\r\n{\r\nstruct ar5523_cmd_create_connection create;\r\nint wlan_mode;\r\nmemset(&create, 0, sizeof(create));\r\ncreate.connid = cpu_to_be32(2);\r\ncreate.bssid = cpu_to_be32(0);\r\ncreate.size = cpu_to_be32(sizeof(struct ar5523_cmd_rateset));\r\nar5523_create_rateset(ar, bss, &create.connattr.rateset, false);\r\nwlan_mode = ar5523_get_wlan_mode(ar, bss);\r\ncreate.connattr.wlanmode = cpu_to_be32(wlan_mode);\r\nreturn ar5523_cmd_write(ar, WDCMSG_CREATE_CONNECTION, &create,\r\nsizeof(create), 0);\r\n}\r\nstatic int ar5523_write_associd(struct ar5523 *ar,\r\nstruct ieee80211_bss_conf *bss)\r\n{\r\nstruct ar5523_cmd_set_associd associd;\r\nmemset(&associd, 0, sizeof(associd));\r\nassocid.defaultrateix = cpu_to_be32(0);\r\nassocid.associd = cpu_to_be32(bss->aid);\r\nassocid.timoffset = cpu_to_be32(0x3b);\r\nmemcpy(associd.bssid, bss->bssid, ETH_ALEN);\r\nreturn ar5523_cmd_write(ar, WDCMSG_WRITE_ASSOCID, &associd,\r\nsizeof(associd), 0);\r\n}\r\nstatic void ar5523_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss,\r\nu32 changed)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nint error;\r\nar5523_dbg(ar, "bss_info_changed called\n");\r\nmutex_lock(&ar->mutex);\r\nif (!(changed & BSS_CHANGED_ASSOC))\r\ngoto out_unlock;\r\nif (bss->assoc) {\r\nerror = ar5523_create_connection(ar, vif, bss);\r\nif (error) {\r\nar5523_err(ar, "could not create connection\n");\r\ngoto out_unlock;\r\n}\r\nerror = ar5523_set_basic_rates(ar, bss);\r\nif (error) {\r\nar5523_err(ar, "could not set negotiated rate set\n");\r\ngoto out_unlock;\r\n}\r\nerror = ar5523_write_associd(ar, bss);\r\nif (error) {\r\nar5523_err(ar, "could not set association\n");\r\ngoto out_unlock;\r\n}\r\nar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_ON);\r\nset_bit(AR5523_CONNECTED, &ar->flags);\r\nieee80211_queue_delayed_work(hw, &ar->stat_work, HZ);\r\n} else {\r\ncancel_delayed_work(&ar->stat_work);\r\nclear_bit(AR5523_CONNECTED, &ar->flags);\r\nar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_OFF);\r\n}\r\nout_unlock:\r\nmutex_unlock(&ar->mutex);\r\n}\r\nstatic void ar5523_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct ar5523 *ar = hw->priv;\r\nu32 filter = 0;\r\nar5523_dbg(ar, "configure_filter called\n");\r\nmutex_lock(&ar->mutex);\r\nar5523_flush_tx(ar);\r\n*total_flags &= AR5523_SUPPORTED_FILTERS;\r\nfilter |= UATH_FILTER_RX_UCAST | UATH_FILTER_RX_MCAST |\r\nUATH_FILTER_RX_BCAST | UATH_FILTER_RX_BEACON |\r\nUATH_FILTER_RX_PROM;\r\nar5523_set_rxfilter(ar, 0, UATH_FILTER_OP_INIT);\r\nar5523_set_rxfilter(ar, filter, UATH_FILTER_OP_SET);\r\nmutex_unlock(&ar->mutex);\r\n}\r\nstatic int ar5523_host_available(struct ar5523 *ar)\r\n{\r\nstruct ar5523_cmd_host_available setup;\r\nsetup.sw_ver_major = cpu_to_be32(ATH_SW_VER_MAJOR);\r\nsetup.sw_ver_minor = cpu_to_be32(ATH_SW_VER_MINOR);\r\nsetup.sw_ver_patch = cpu_to_be32(ATH_SW_VER_PATCH);\r\nsetup.sw_ver_build = cpu_to_be32(ATH_SW_VER_BUILD);\r\nreturn ar5523_cmd_read(ar, WDCMSG_HOST_AVAILABLE,\r\n&setup, sizeof(setup), NULL, 0, 0);\r\n}\r\nstatic int ar5523_get_devstatus(struct ar5523 *ar)\r\n{\r\nu8 macaddr[ETH_ALEN];\r\nint error;\r\nerror = ar5523_get_status(ar, ST_MAC_ADDR, macaddr, ETH_ALEN);\r\nif (error) {\r\nar5523_err(ar, "could not read MAC address\n");\r\nreturn error;\r\n}\r\nSET_IEEE80211_PERM_ADDR(ar->hw, macaddr);\r\nerror = ar5523_get_status(ar, ST_SERIAL_NUMBER,\r\n&ar->serial[0], sizeof(ar->serial));\r\nif (error) {\r\nar5523_err(ar, "could not read device serial number\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ar5523_get_max_rxsz(struct ar5523 *ar)\r\n{\r\nint error;\r\n__be32 rxsize;\r\nerror = ar5523_get_status(ar, ST_WDC_TRANSPORT_CHUNK_SIZE, &rxsize,\r\nsizeof(rxsize));\r\nif (error != 0) {\r\nar5523_err(ar, "could not read max RX size\n");\r\nreturn error;\r\n}\r\nar->rxbufsz = be32_to_cpu(rxsize);\r\nif (!ar->rxbufsz || ar->rxbufsz > AR5523_SANE_RXBUFSZ) {\r\nar5523_err(ar, "Bad rxbufsz from device. Using %d instead\n",\r\nAR5523_SANE_RXBUFSZ);\r\nar->rxbufsz = AR5523_SANE_RXBUFSZ;\r\n}\r\nar5523_dbg(ar, "Max RX buf size: %d\n", ar->rxbufsz);\r\nreturn 0;\r\n}\r\nstatic int ar5523_init_modes(struct ar5523 *ar)\r\n{\r\nBUILD_BUG_ON(sizeof(ar->channels) != sizeof(ar5523_channels));\r\nBUILD_BUG_ON(sizeof(ar->rates) != sizeof(ar5523_rates));\r\nmemcpy(ar->channels, ar5523_channels, sizeof(ar5523_channels));\r\nmemcpy(ar->rates, ar5523_rates, sizeof(ar5523_rates));\r\nar->band.band = IEEE80211_BAND_2GHZ;\r\nar->band.channels = ar->channels;\r\nar->band.n_channels = ARRAY_SIZE(ar5523_channels);\r\nar->band.bitrates = ar->rates;\r\nar->band.n_bitrates = ARRAY_SIZE(ar5523_rates);\r\nar->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &ar->band;\r\nreturn 0;\r\n}\r\nstatic int ar5523_load_firmware(struct usb_device *dev)\r\n{\r\nstruct ar5523_fwblock *txblock, *rxblock;\r\nconst struct firmware *fw;\r\nvoid *fwbuf;\r\nint len, offset;\r\nint foolen;\r\nint error = -ENXIO;\r\nif (request_firmware(&fw, AR5523_FIRMWARE_FILE, &dev->dev)) {\r\ndev_err(&dev->dev, "no firmware found: %s\n",\r\nAR5523_FIRMWARE_FILE);\r\nreturn -ENOENT;\r\n}\r\ntxblock = kmalloc(sizeof(*txblock), GFP_KERNEL);\r\nif (!txblock)\r\ngoto out;\r\nrxblock = kmalloc(sizeof(*rxblock), GFP_KERNEL);\r\nif (!rxblock)\r\ngoto out_free_txblock;\r\nfwbuf = kmalloc(AR5523_MAX_FWBLOCK_SIZE, GFP_KERNEL);\r\nif (!fwbuf)\r\ngoto out_free_rxblock;\r\nmemset(txblock, 0, sizeof(struct ar5523_fwblock));\r\ntxblock->flags = cpu_to_be32(AR5523_WRITE_BLOCK);\r\ntxblock->total = cpu_to_be32(fw->size);\r\noffset = 0;\r\nlen = fw->size;\r\nwhile (len > 0) {\r\nint mlen = min(len, AR5523_MAX_FWBLOCK_SIZE);\r\ntxblock->remain = cpu_to_be32(len - mlen);\r\ntxblock->len = cpu_to_be32(mlen);\r\nerror = usb_bulk_msg(dev, ar5523_cmd_tx_pipe(dev),\r\ntxblock, sizeof(*txblock), &foolen,\r\nAR5523_CMD_TIMEOUT);\r\nif (error) {\r\ndev_err(&dev->dev,\r\n"could not send firmware block info\n");\r\ngoto out_free_fwbuf;\r\n}\r\nmemcpy(fwbuf, fw->data + offset, mlen);\r\nerror = usb_bulk_msg(dev, ar5523_data_tx_pipe(dev),\r\nfwbuf, mlen, &foolen,\r\nAR5523_DATA_TIMEOUT);\r\nif (error) {\r\ndev_err(&dev->dev,\r\n"could not send firmware block data\n");\r\ngoto out_free_fwbuf;\r\n}\r\nerror = usb_bulk_msg(dev, ar5523_cmd_rx_pipe(dev),\r\nrxblock, sizeof(*rxblock), &foolen,\r\nAR5523_CMD_TIMEOUT);\r\nif (error) {\r\ndev_err(&dev->dev,\r\n"could not read firmware answer\n");\r\ngoto out_free_fwbuf;\r\n}\r\nlen -= mlen;\r\noffset += mlen;\r\n}\r\nerror = -ENXIO;\r\nout_free_fwbuf:\r\nkfree(fwbuf);\r\nout_free_rxblock:\r\nkfree(rxblock);\r\nout_free_txblock:\r\nkfree(txblock);\r\nout:\r\nrelease_firmware(fw);\r\nreturn error;\r\n}\r\nstatic int ar5523_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct ieee80211_hw *hw;\r\nstruct ar5523 *ar;\r\nint error = -ENOMEM;\r\nif (id->driver_info & AR5523_FLAG_PRE_FIRMWARE)\r\nreturn ar5523_load_firmware(dev);\r\nhw = ieee80211_alloc_hw(sizeof(*ar), &ar5523_ops);\r\nif (!hw)\r\ngoto out;\r\nSET_IEEE80211_DEV(hw, &intf->dev);\r\nar = hw->priv;\r\nar->hw = hw;\r\nar->dev = dev;\r\nmutex_init(&ar->mutex);\r\nINIT_DELAYED_WORK(&ar->stat_work, ar5523_stat_work);\r\ninit_timer(&ar->tx_wd_timer);\r\nsetup_timer(&ar->tx_wd_timer, ar5523_tx_wd_timer, (unsigned long) ar);\r\nINIT_WORK(&ar->tx_wd_work, ar5523_tx_wd_work);\r\nINIT_WORK(&ar->tx_work, ar5523_tx_work);\r\nINIT_LIST_HEAD(&ar->tx_queue_pending);\r\nINIT_LIST_HEAD(&ar->tx_queue_submitted);\r\nspin_lock_init(&ar->tx_data_list_lock);\r\natomic_set(&ar->tx_nr_total, 0);\r\natomic_set(&ar->tx_nr_pending, 0);\r\ninit_waitqueue_head(&ar->tx_flush_waitq);\r\natomic_set(&ar->rx_data_free_cnt, 0);\r\nINIT_WORK(&ar->rx_refill_work, ar5523_rx_refill_work);\r\nINIT_LIST_HEAD(&ar->rx_data_free);\r\nINIT_LIST_HEAD(&ar->rx_data_used);\r\nspin_lock_init(&ar->rx_data_list_lock);\r\nar->wq = create_singlethread_workqueue("ar5523");\r\nif (!ar->wq) {\r\nar5523_err(ar, "Could not create wq\n");\r\ngoto out_free_ar;\r\n}\r\nerror = ar5523_alloc_rx_bufs(ar);\r\nif (error) {\r\nar5523_err(ar, "Could not allocate rx buffers\n");\r\ngoto out_free_wq;\r\n}\r\nerror = ar5523_alloc_rx_cmd(ar);\r\nif (error) {\r\nar5523_err(ar, "Could not allocate rx command buffers\n");\r\ngoto out_free_rx_bufs;\r\n}\r\nerror = ar5523_alloc_tx_cmd(ar);\r\nif (error) {\r\nar5523_err(ar, "Could not allocate tx command buffers\n");\r\ngoto out_free_rx_cmd;\r\n}\r\nerror = ar5523_submit_rx_cmd(ar);\r\nif (error) {\r\nar5523_err(ar, "Failed to submit rx cmd\n");\r\ngoto out_free_tx_cmd;\r\n}\r\nerror = ar5523_host_available(ar);\r\nif (error) {\r\nar5523_err(ar, "could not initialize adapter\n");\r\ngoto out_cancel_rx_cmd;\r\n}\r\nerror = ar5523_get_max_rxsz(ar);\r\nif (error) {\r\nar5523_err(ar, "could not get caps from adapter\n");\r\ngoto out_cancel_rx_cmd;\r\n}\r\nerror = ar5523_get_devcap(ar);\r\nif (error) {\r\nar5523_err(ar, "could not get caps from adapter\n");\r\ngoto out_cancel_rx_cmd;\r\n}\r\nerror = ar5523_get_devstatus(ar);\r\nif (error != 0) {\r\nar5523_err(ar, "could not get device status\n");\r\ngoto out_cancel_rx_cmd;\r\n}\r\nar5523_info(ar, "MAC/BBP AR5523, RF AR%c112\n",\r\n(id->driver_info & AR5523_FLAG_ABG) ? '5' : '2');\r\nar->vif = NULL;\r\nhw->flags = IEEE80211_HW_RX_INCLUDES_FCS |\r\nIEEE80211_HW_SIGNAL_DBM |\r\nIEEE80211_HW_HAS_RATE_CONTROL;\r\nhw->extra_tx_headroom = sizeof(struct ar5523_tx_desc) +\r\nsizeof(struct ar5523_chunk);\r\nhw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\nhw->queues = 1;\r\nerror = ar5523_init_modes(ar);\r\nif (error)\r\ngoto out_cancel_rx_cmd;\r\nusb_set_intfdata(intf, hw);\r\nerror = ieee80211_register_hw(hw);\r\nif (error) {\r\nar5523_err(ar, "could not register device\n");\r\ngoto out_cancel_rx_cmd;\r\n}\r\nar5523_info(ar, "Found and initialized AR5523 device\n");\r\nreturn 0;\r\nout_cancel_rx_cmd:\r\nar5523_cancel_rx_cmd(ar);\r\nout_free_tx_cmd:\r\nar5523_free_tx_cmd(ar);\r\nout_free_rx_cmd:\r\nar5523_free_rx_cmd(ar);\r\nout_free_rx_bufs:\r\nar5523_free_rx_bufs(ar);\r\nout_free_wq:\r\ndestroy_workqueue(ar->wq);\r\nout_free_ar:\r\nieee80211_free_hw(hw);\r\nout:\r\nreturn error;\r\n}\r\nstatic void ar5523_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(intf);\r\nstruct ar5523 *ar = hw->priv;\r\nar5523_dbg(ar, "detaching\n");\r\nset_bit(AR5523_USB_DISCONNECTED, &ar->flags);\r\nieee80211_unregister_hw(hw);\r\nar5523_cancel_rx_cmd(ar);\r\nar5523_free_tx_cmd(ar);\r\nar5523_free_rx_cmd(ar);\r\nar5523_free_rx_bufs(ar);\r\ndestroy_workqueue(ar->wq);\r\nieee80211_free_hw(hw);\r\nusb_set_intfdata(intf, NULL);\r\n}
