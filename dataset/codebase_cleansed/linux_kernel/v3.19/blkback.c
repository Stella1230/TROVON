static inline int get_free_page(struct xen_blkif *blkif, struct page **page)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&blkif->free_pages_lock, flags);\r\nif (list_empty(&blkif->free_pages)) {\r\nBUG_ON(blkif->free_pages_num != 0);\r\nspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\r\nreturn alloc_xenballooned_pages(1, page, false);\r\n}\r\nBUG_ON(blkif->free_pages_num == 0);\r\npage[0] = list_first_entry(&blkif->free_pages, struct page, lru);\r\nlist_del(&page[0]->lru);\r\nblkif->free_pages_num--;\r\nspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void put_free_pages(struct xen_blkif *blkif, struct page **page,\r\nint num)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&blkif->free_pages_lock, flags);\r\nfor (i = 0; i < num; i++)\r\nlist_add(&page[i]->lru, &blkif->free_pages);\r\nblkif->free_pages_num += num;\r\nspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\r\n}\r\nstatic inline void shrink_free_pagepool(struct xen_blkif *blkif, int num)\r\n{\r\nstruct page *page[NUM_BATCH_FREE_PAGES];\r\nunsigned int num_pages = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&blkif->free_pages_lock, flags);\r\nwhile (blkif->free_pages_num > num) {\r\nBUG_ON(list_empty(&blkif->free_pages));\r\npage[num_pages] = list_first_entry(&blkif->free_pages,\r\nstruct page, lru);\r\nlist_del(&page[num_pages]->lru);\r\nblkif->free_pages_num--;\r\nif (++num_pages == NUM_BATCH_FREE_PAGES) {\r\nspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\r\nfree_xenballooned_pages(num_pages, page);\r\nspin_lock_irqsave(&blkif->free_pages_lock, flags);\r\nnum_pages = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\r\nif (num_pages != 0)\r\nfree_xenballooned_pages(num_pages, page);\r\n}\r\nstatic int add_persistent_gnt(struct xen_blkif *blkif,\r\nstruct persistent_gnt *persistent_gnt)\r\n{\r\nstruct rb_node **new = NULL, *parent = NULL;\r\nstruct persistent_gnt *this;\r\nif (blkif->persistent_gnt_c >= xen_blkif_max_pgrants) {\r\nif (!blkif->vbd.overflow_max_grants)\r\nblkif->vbd.overflow_max_grants = 1;\r\nreturn -EBUSY;\r\n}\r\nnew = &blkif->persistent_gnts.rb_node;\r\nwhile (*new) {\r\nthis = container_of(*new, struct persistent_gnt, node);\r\nparent = *new;\r\nif (persistent_gnt->gnt < this->gnt)\r\nnew = &((*new)->rb_left);\r\nelse if (persistent_gnt->gnt > this->gnt)\r\nnew = &((*new)->rb_right);\r\nelse {\r\npr_alert_ratelimited(DRV_PFX " trying to add a gref that's already in the tree\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbitmap_zero(persistent_gnt->flags, PERSISTENT_GNT_FLAGS_SIZE);\r\nset_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\r\nrb_link_node(&(persistent_gnt->node), parent, new);\r\nrb_insert_color(&(persistent_gnt->node), &blkif->persistent_gnts);\r\nblkif->persistent_gnt_c++;\r\natomic_inc(&blkif->persistent_gnt_in_use);\r\nreturn 0;\r\n}\r\nstatic struct persistent_gnt *get_persistent_gnt(struct xen_blkif *blkif,\r\ngrant_ref_t gref)\r\n{\r\nstruct persistent_gnt *data;\r\nstruct rb_node *node = NULL;\r\nnode = blkif->persistent_gnts.rb_node;\r\nwhile (node) {\r\ndata = container_of(node, struct persistent_gnt, node);\r\nif (gref < data->gnt)\r\nnode = node->rb_left;\r\nelse if (gref > data->gnt)\r\nnode = node->rb_right;\r\nelse {\r\nif(test_bit(PERSISTENT_GNT_ACTIVE, data->flags)) {\r\npr_alert_ratelimited(DRV_PFX " requesting a grant already in use\n");\r\nreturn NULL;\r\n}\r\nset_bit(PERSISTENT_GNT_ACTIVE, data->flags);\r\natomic_inc(&blkif->persistent_gnt_in_use);\r\nreturn data;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void put_persistent_gnt(struct xen_blkif *blkif,\r\nstruct persistent_gnt *persistent_gnt)\r\n{\r\nif(!test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\r\npr_alert_ratelimited(DRV_PFX " freeing a grant already unused");\r\nset_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\r\nclear_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\r\natomic_dec(&blkif->persistent_gnt_in_use);\r\n}\r\nstatic void free_persistent_gnts(struct xen_blkif *blkif, struct rb_root *root,\r\nunsigned int num)\r\n{\r\nstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct persistent_gnt *persistent_gnt;\r\nstruct rb_node *n;\r\nint ret = 0;\r\nint segs_to_unmap = 0;\r\nforeach_grant_safe(persistent_gnt, n, root, node) {\r\nBUG_ON(persistent_gnt->handle ==\r\nBLKBACK_INVALID_HANDLE);\r\ngnttab_set_unmap_op(&unmap[segs_to_unmap],\r\n(unsigned long) pfn_to_kaddr(page_to_pfn(\r\npersistent_gnt->page)),\r\nGNTMAP_host_map,\r\npersistent_gnt->handle);\r\npages[segs_to_unmap] = persistent_gnt->page;\r\nif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST ||\r\n!rb_next(&persistent_gnt->node)) {\r\nret = gnttab_unmap_refs(unmap, NULL, pages,\r\nsegs_to_unmap);\r\nBUG_ON(ret);\r\nput_free_pages(blkif, pages, segs_to_unmap);\r\nsegs_to_unmap = 0;\r\n}\r\nrb_erase(&persistent_gnt->node, root);\r\nkfree(persistent_gnt);\r\nnum--;\r\n}\r\nBUG_ON(num != 0);\r\n}\r\nvoid xen_blkbk_unmap_purged_grants(struct work_struct *work)\r\n{\r\nstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct persistent_gnt *persistent_gnt;\r\nint ret, segs_to_unmap = 0;\r\nstruct xen_blkif *blkif = container_of(work, typeof(*blkif), persistent_purge_work);\r\nwhile(!list_empty(&blkif->persistent_purge_list)) {\r\npersistent_gnt = list_first_entry(&blkif->persistent_purge_list,\r\nstruct persistent_gnt,\r\nremove_node);\r\nlist_del(&persistent_gnt->remove_node);\r\ngnttab_set_unmap_op(&unmap[segs_to_unmap],\r\nvaddr(persistent_gnt->page),\r\nGNTMAP_host_map,\r\npersistent_gnt->handle);\r\npages[segs_to_unmap] = persistent_gnt->page;\r\nif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST) {\r\nret = gnttab_unmap_refs(unmap, NULL, pages,\r\nsegs_to_unmap);\r\nBUG_ON(ret);\r\nput_free_pages(blkif, pages, segs_to_unmap);\r\nsegs_to_unmap = 0;\r\n}\r\nkfree(persistent_gnt);\r\n}\r\nif (segs_to_unmap > 0) {\r\nret = gnttab_unmap_refs(unmap, NULL, pages, segs_to_unmap);\r\nBUG_ON(ret);\r\nput_free_pages(blkif, pages, segs_to_unmap);\r\n}\r\n}\r\nstatic void purge_persistent_gnt(struct xen_blkif *blkif)\r\n{\r\nstruct persistent_gnt *persistent_gnt;\r\nstruct rb_node *n;\r\nunsigned int num_clean, total;\r\nbool scan_used = false, clean_used = false;\r\nstruct rb_root *root;\r\nif (blkif->persistent_gnt_c < xen_blkif_max_pgrants ||\r\n(blkif->persistent_gnt_c == xen_blkif_max_pgrants &&\r\n!blkif->vbd.overflow_max_grants)) {\r\nreturn;\r\n}\r\nif (work_pending(&blkif->persistent_purge_work)) {\r\npr_alert_ratelimited(DRV_PFX "Scheduled work from previous purge is still pending, cannot purge list\n");\r\nreturn;\r\n}\r\nnum_clean = (xen_blkif_max_pgrants / 100) * LRU_PERCENT_CLEAN;\r\nnum_clean = blkif->persistent_gnt_c - xen_blkif_max_pgrants + num_clean;\r\nnum_clean = min(blkif->persistent_gnt_c, num_clean);\r\nif ((num_clean == 0) ||\r\n(num_clean > (blkif->persistent_gnt_c - atomic_read(&blkif->persistent_gnt_in_use))))\r\nreturn;\r\ntotal = num_clean;\r\npr_debug(DRV_PFX "Going to purge %u persistent grants\n", num_clean);\r\nBUG_ON(!list_empty(&blkif->persistent_purge_list));\r\nroot = &blkif->persistent_gnts;\r\npurge_list:\r\nforeach_grant_safe(persistent_gnt, n, root, node) {\r\nBUG_ON(persistent_gnt->handle ==\r\nBLKBACK_INVALID_HANDLE);\r\nif (clean_used) {\r\nclear_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\r\ncontinue;\r\n}\r\nif (test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\r\ncontinue;\r\nif (!scan_used &&\r\n(test_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags)))\r\ncontinue;\r\nrb_erase(&persistent_gnt->node, root);\r\nlist_add(&persistent_gnt->remove_node,\r\n&blkif->persistent_purge_list);\r\nif (--num_clean == 0)\r\ngoto finished;\r\n}\r\nif (!scan_used && !clean_used) {\r\npr_debug(DRV_PFX "Still missing %u purged frames\n", num_clean);\r\nscan_used = true;\r\ngoto purge_list;\r\n}\r\nfinished:\r\nif (!clean_used) {\r\npr_debug(DRV_PFX "Finished scanning for grants to clean, removing used flag\n");\r\nclean_used = true;\r\ngoto purge_list;\r\n}\r\nblkif->persistent_gnt_c -= (total - num_clean);\r\nblkif->vbd.overflow_max_grants = 0;\r\nschedule_work(&blkif->persistent_purge_work);\r\npr_debug(DRV_PFX "Purged %u/%u\n", (total - num_clean), total);\r\nreturn;\r\n}\r\nstatic struct pending_req *alloc_req(struct xen_blkif *blkif)\r\n{\r\nstruct pending_req *req = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&blkif->pending_free_lock, flags);\r\nif (!list_empty(&blkif->pending_free)) {\r\nreq = list_entry(blkif->pending_free.next, struct pending_req,\r\nfree_list);\r\nlist_del(&req->free_list);\r\n}\r\nspin_unlock_irqrestore(&blkif->pending_free_lock, flags);\r\nreturn req;\r\n}\r\nstatic void free_req(struct xen_blkif *blkif, struct pending_req *req)\r\n{\r\nunsigned long flags;\r\nint was_empty;\r\nspin_lock_irqsave(&blkif->pending_free_lock, flags);\r\nwas_empty = list_empty(&blkif->pending_free);\r\nlist_add(&req->free_list, &blkif->pending_free);\r\nspin_unlock_irqrestore(&blkif->pending_free_lock, flags);\r\nif (was_empty)\r\nwake_up(&blkif->pending_free_wq);\r\n}\r\nstatic int xen_vbd_translate(struct phys_req *req, struct xen_blkif *blkif,\r\nint operation)\r\n{\r\nstruct xen_vbd *vbd = &blkif->vbd;\r\nint rc = -EACCES;\r\nif ((operation != READ) && vbd->readonly)\r\ngoto out;\r\nif (likely(req->nr_sects)) {\r\nblkif_sector_t end = req->sector_number + req->nr_sects;\r\nif (unlikely(end < req->sector_number))\r\ngoto out;\r\nif (unlikely(end > vbd_sz(vbd)))\r\ngoto out;\r\n}\r\nreq->dev = vbd->pdevice;\r\nreq->bdev = vbd->bdev;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void xen_vbd_resize(struct xen_blkif *blkif)\r\n{\r\nstruct xen_vbd *vbd = &blkif->vbd;\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nstruct xenbus_device *dev = xen_blkbk_xenbus(blkif->be);\r\nunsigned long long new_size = vbd_sz(vbd);\r\npr_info(DRV_PFX "VBD Resize: Domid: %d, Device: (%d, %d)\n",\r\nblkif->domid, MAJOR(vbd->pdevice), MINOR(vbd->pdevice));\r\npr_info(DRV_PFX "VBD Resize: new size %llu\n", new_size);\r\nvbd->size = new_size;\r\nagain:\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\npr_warn(DRV_PFX "Error starting transaction");\r\nreturn;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "sectors", "%llu",\r\n(unsigned long long)vbd_sz(vbd));\r\nif (err) {\r\npr_warn(DRV_PFX "Error writing new size");\r\ngoto abort;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "state", "%d", dev->state);\r\nif (err) {\r\npr_warn(DRV_PFX "Error writing the state");\r\ngoto abort;\r\n}\r\nerr = xenbus_transaction_end(xbt, 0);\r\nif (err == -EAGAIN)\r\ngoto again;\r\nif (err)\r\npr_warn(DRV_PFX "Error ending transaction");\r\nreturn;\r\nabort:\r\nxenbus_transaction_end(xbt, 1);\r\n}\r\nstatic void blkif_notify_work(struct xen_blkif *blkif)\r\n{\r\nblkif->waiting_reqs = 1;\r\nwake_up(&blkif->wq);\r\n}\r\nirqreturn_t xen_blkif_be_int(int irq, void *dev_id)\r\n{\r\nblkif_notify_work(dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void print_stats(struct xen_blkif *blkif)\r\n{\r\npr_info("xen-blkback (%s): oo %3llu | rd %4llu | wr %4llu | f %4llu"\r\n" | ds %4llu | pg: %4u/%4d\n",\r\ncurrent->comm, blkif->st_oo_req,\r\nblkif->st_rd_req, blkif->st_wr_req,\r\nblkif->st_f_req, blkif->st_ds_req,\r\nblkif->persistent_gnt_c,\r\nxen_blkif_max_pgrants);\r\nblkif->st_print = jiffies + msecs_to_jiffies(10 * 1000);\r\nblkif->st_rd_req = 0;\r\nblkif->st_wr_req = 0;\r\nblkif->st_oo_req = 0;\r\nblkif->st_ds_req = 0;\r\n}\r\nint xen_blkif_schedule(void *arg)\r\n{\r\nstruct xen_blkif *blkif = arg;\r\nstruct xen_vbd *vbd = &blkif->vbd;\r\nunsigned long timeout;\r\nint ret;\r\nxen_blkif_get(blkif);\r\nwhile (!kthread_should_stop()) {\r\nif (try_to_freeze())\r\ncontinue;\r\nif (unlikely(vbd->size != vbd_sz(vbd)))\r\nxen_vbd_resize(blkif);\r\ntimeout = msecs_to_jiffies(LRU_INTERVAL);\r\ntimeout = wait_event_interruptible_timeout(\r\nblkif->wq,\r\nblkif->waiting_reqs || kthread_should_stop(),\r\ntimeout);\r\nif (timeout == 0)\r\ngoto purge_gnt_list;\r\ntimeout = wait_event_interruptible_timeout(\r\nblkif->pending_free_wq,\r\n!list_empty(&blkif->pending_free) ||\r\nkthread_should_stop(),\r\ntimeout);\r\nif (timeout == 0)\r\ngoto purge_gnt_list;\r\nblkif->waiting_reqs = 0;\r\nsmp_mb();\r\nret = do_block_io_op(blkif);\r\nif (ret > 0)\r\nblkif->waiting_reqs = 1;\r\nif (ret == -EACCES)\r\nwait_event_interruptible(blkif->shutdown_wq,\r\nkthread_should_stop());\r\npurge_gnt_list:\r\nif (blkif->vbd.feature_gnt_persistent &&\r\ntime_after(jiffies, blkif->next_lru)) {\r\npurge_persistent_gnt(blkif);\r\nblkif->next_lru = jiffies + msecs_to_jiffies(LRU_INTERVAL);\r\n}\r\nshrink_free_pagepool(blkif, xen_blkif_max_buffer_pages);\r\nif (log_stats && time_after(jiffies, blkif->st_print))\r\nprint_stats(blkif);\r\n}\r\nflush_work(&blkif->persistent_purge_work);\r\nif (log_stats)\r\nprint_stats(blkif);\r\nblkif->xenblkd = NULL;\r\nxen_blkif_put(blkif);\r\nreturn 0;\r\n}\r\nvoid xen_blkbk_free_caches(struct xen_blkif *blkif)\r\n{\r\nif (!RB_EMPTY_ROOT(&blkif->persistent_gnts))\r\nfree_persistent_gnts(blkif, &blkif->persistent_gnts,\r\nblkif->persistent_gnt_c);\r\nBUG_ON(!RB_EMPTY_ROOT(&blkif->persistent_gnts));\r\nblkif->persistent_gnt_c = 0;\r\nshrink_free_pagepool(blkif, 0 );\r\n}\r\nstatic void xen_blkbk_unmap(struct xen_blkif *blkif,\r\nstruct grant_page *pages[],\r\nint num)\r\n{\r\nstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct page *unmap_pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nunsigned int i, invcount = 0;\r\nint ret;\r\nfor (i = 0; i < num; i++) {\r\nif (pages[i]->persistent_gnt != NULL) {\r\nput_persistent_gnt(blkif, pages[i]->persistent_gnt);\r\ncontinue;\r\n}\r\nif (pages[i]->handle == BLKBACK_INVALID_HANDLE)\r\ncontinue;\r\nunmap_pages[invcount] = pages[i]->page;\r\ngnttab_set_unmap_op(&unmap[invcount], vaddr(pages[i]->page),\r\nGNTMAP_host_map, pages[i]->handle);\r\npages[i]->handle = BLKBACK_INVALID_HANDLE;\r\nif (++invcount == BLKIF_MAX_SEGMENTS_PER_REQUEST) {\r\nret = gnttab_unmap_refs(unmap, NULL, unmap_pages,\r\ninvcount);\r\nBUG_ON(ret);\r\nput_free_pages(blkif, unmap_pages, invcount);\r\ninvcount = 0;\r\n}\r\n}\r\nif (invcount) {\r\nret = gnttab_unmap_refs(unmap, NULL, unmap_pages, invcount);\r\nBUG_ON(ret);\r\nput_free_pages(blkif, unmap_pages, invcount);\r\n}\r\n}\r\nstatic int xen_blkbk_map(struct xen_blkif *blkif,\r\nstruct grant_page *pages[],\r\nint num, bool ro)\r\n{\r\nstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\r\nstruct persistent_gnt *persistent_gnt = NULL;\r\nphys_addr_t addr = 0;\r\nint i, seg_idx, new_map_idx;\r\nint segs_to_map = 0;\r\nint ret = 0;\r\nint last_map = 0, map_until = 0;\r\nint use_persistent_gnts;\r\nuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\r\nagain:\r\nfor (i = map_until; i < num; i++) {\r\nuint32_t flags;\r\nif (use_persistent_gnts)\r\npersistent_gnt = get_persistent_gnt(\r\nblkif,\r\npages[i]->gref);\r\nif (persistent_gnt) {\r\npages[i]->page = persistent_gnt->page;\r\npages[i]->persistent_gnt = persistent_gnt;\r\n} else {\r\nif (get_free_page(blkif, &pages[i]->page))\r\ngoto out_of_memory;\r\naddr = vaddr(pages[i]->page);\r\npages_to_gnt[segs_to_map] = pages[i]->page;\r\npages[i]->persistent_gnt = NULL;\r\nflags = GNTMAP_host_map;\r\nif (!use_persistent_gnts && ro)\r\nflags |= GNTMAP_readonly;\r\ngnttab_set_map_op(&map[segs_to_map++], addr,\r\nflags, pages[i]->gref,\r\nblkif->domid);\r\n}\r\nmap_until = i + 1;\r\nif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\r\nbreak;\r\n}\r\nif (segs_to_map) {\r\nret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\r\nBUG_ON(ret);\r\n}\r\nfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\r\nif (!pages[seg_idx]->persistent_gnt) {\r\nBUG_ON(new_map_idx >= segs_to_map);\r\nif (unlikely(map[new_map_idx].status != 0)) {\r\npr_debug(DRV_PFX "invalid buffer -- could not remap it\n");\r\nput_free_pages(blkif, &pages[seg_idx]->page, 1);\r\npages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\r\nret |= 1;\r\ngoto next;\r\n}\r\npages[seg_idx]->handle = map[new_map_idx].handle;\r\n} else {\r\ncontinue;\r\n}\r\nif (use_persistent_gnts &&\r\nblkif->persistent_gnt_c < xen_blkif_max_pgrants) {\r\npersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\r\nGFP_KERNEL);\r\nif (!persistent_gnt) {\r\ngoto next;\r\n}\r\npersistent_gnt->gnt = map[new_map_idx].ref;\r\npersistent_gnt->handle = map[new_map_idx].handle;\r\npersistent_gnt->page = pages[seg_idx]->page;\r\nif (add_persistent_gnt(blkif,\r\npersistent_gnt)) {\r\nkfree(persistent_gnt);\r\npersistent_gnt = NULL;\r\ngoto next;\r\n}\r\npages[seg_idx]->persistent_gnt = persistent_gnt;\r\npr_debug(DRV_PFX " grant %u added to the tree of persistent grants, using %u/%u\n",\r\npersistent_gnt->gnt, blkif->persistent_gnt_c,\r\nxen_blkif_max_pgrants);\r\ngoto next;\r\n}\r\nif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\r\nblkif->vbd.overflow_max_grants = 1;\r\npr_debug(DRV_PFX " domain %u, device %#x is using maximum number of persistent grants\n",\r\nblkif->domid, blkif->vbd.handle);\r\n}\r\nnext:\r\nnew_map_idx++;\r\n}\r\nsegs_to_map = 0;\r\nlast_map = map_until;\r\nif (map_until != num)\r\ngoto again;\r\nreturn ret;\r\nout_of_memory:\r\npr_alert(DRV_PFX "%s: out of memory\n", __func__);\r\nput_free_pages(blkif, pages_to_gnt, segs_to_map);\r\nreturn -ENOMEM;\r\n}\r\nstatic int xen_blkbk_map_seg(struct pending_req *pending_req)\r\n{\r\nint rc;\r\nrc = xen_blkbk_map(pending_req->blkif, pending_req->segments,\r\npending_req->nr_pages,\r\n(pending_req->operation != BLKIF_OP_READ));\r\nreturn rc;\r\n}\r\nstatic int xen_blkbk_parse_indirect(struct blkif_request *req,\r\nstruct pending_req *pending_req,\r\nstruct seg_buf seg[],\r\nstruct phys_req *preq)\r\n{\r\nstruct grant_page **pages = pending_req->indirect_pages;\r\nstruct xen_blkif *blkif = pending_req->blkif;\r\nint indirect_grefs, rc, n, nseg, i;\r\nstruct blkif_request_segment *segments = NULL;\r\nnseg = pending_req->nr_pages;\r\nindirect_grefs = INDIRECT_PAGES(nseg);\r\nBUG_ON(indirect_grefs > BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST);\r\nfor (i = 0; i < indirect_grefs; i++)\r\npages[i]->gref = req->u.indirect.indirect_grefs[i];\r\nrc = xen_blkbk_map(blkif, pages, indirect_grefs, true);\r\nif (rc)\r\ngoto unmap;\r\nfor (n = 0, i = 0; n < nseg; n++) {\r\nif ((n % SEGS_PER_INDIRECT_FRAME) == 0) {\r\nif (segments)\r\nkunmap_atomic(segments);\r\nsegments = kmap_atomic(pages[n/SEGS_PER_INDIRECT_FRAME]->page);\r\n}\r\ni = n % SEGS_PER_INDIRECT_FRAME;\r\npending_req->segments[n]->gref = segments[i].gref;\r\nseg[n].nsec = segments[i].last_sect -\r\nsegments[i].first_sect + 1;\r\nseg[n].offset = (segments[i].first_sect << 9);\r\nif ((segments[i].last_sect >= (PAGE_SIZE >> 9)) ||\r\n(segments[i].last_sect < segments[i].first_sect)) {\r\nrc = -EINVAL;\r\ngoto unmap;\r\n}\r\npreq->nr_sects += seg[n].nsec;\r\n}\r\nunmap:\r\nif (segments)\r\nkunmap_atomic(segments);\r\nxen_blkbk_unmap(blkif, pages, indirect_grefs);\r\nreturn rc;\r\n}\r\nstatic int dispatch_discard_io(struct xen_blkif *blkif,\r\nstruct blkif_request *req)\r\n{\r\nint err = 0;\r\nint status = BLKIF_RSP_OKAY;\r\nstruct block_device *bdev = blkif->vbd.bdev;\r\nunsigned long secure;\r\nstruct phys_req preq;\r\nxen_blkif_get(blkif);\r\npreq.sector_number = req->u.discard.sector_number;\r\npreq.nr_sects = req->u.discard.nr_sectors;\r\nerr = xen_vbd_translate(&preq, blkif, WRITE);\r\nif (err) {\r\npr_warn(DRV_PFX "access denied: DISCARD [%llu->%llu] on dev=%04x\n",\r\npreq.sector_number,\r\npreq.sector_number + preq.nr_sects, blkif->vbd.pdevice);\r\ngoto fail_response;\r\n}\r\nblkif->st_ds_req++;\r\nsecure = (blkif->vbd.discard_secure &&\r\n(req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\r\nBLKDEV_DISCARD_SECURE : 0;\r\nerr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\r\nreq->u.discard.nr_sectors,\r\nGFP_KERNEL, secure);\r\nfail_response:\r\nif (err == -EOPNOTSUPP) {\r\npr_debug(DRV_PFX "discard op failed, not supported\n");\r\nstatus = BLKIF_RSP_EOPNOTSUPP;\r\n} else if (err)\r\nstatus = BLKIF_RSP_ERROR;\r\nmake_response(blkif, req->u.discard.id, req->operation, status);\r\nxen_blkif_put(blkif);\r\nreturn err;\r\n}\r\nstatic int dispatch_other_io(struct xen_blkif *blkif,\r\nstruct blkif_request *req,\r\nstruct pending_req *pending_req)\r\n{\r\nfree_req(blkif, pending_req);\r\nmake_response(blkif, req->u.other.id, req->operation,\r\nBLKIF_RSP_EOPNOTSUPP);\r\nreturn -EIO;\r\n}\r\nstatic void xen_blk_drain_io(struct xen_blkif *blkif)\r\n{\r\natomic_set(&blkif->drain, 1);\r\ndo {\r\nif (atomic_read(&blkif->inflight) == 0)\r\nbreak;\r\nwait_for_completion_interruptible_timeout(\r\n&blkif->drain_complete, HZ);\r\nif (!atomic_read(&blkif->drain))\r\nbreak;\r\n} while (!kthread_should_stop());\r\natomic_set(&blkif->drain, 0);\r\n}\r\nstatic void __end_block_io_op(struct pending_req *pending_req, int error)\r\n{\r\nif ((pending_req->operation == BLKIF_OP_FLUSH_DISKCACHE) &&\r\n(error == -EOPNOTSUPP)) {\r\npr_debug(DRV_PFX "flush diskcache op failed, not supported\n");\r\nxen_blkbk_flush_diskcache(XBT_NIL, pending_req->blkif->be, 0);\r\npending_req->status = BLKIF_RSP_EOPNOTSUPP;\r\n} else if ((pending_req->operation == BLKIF_OP_WRITE_BARRIER) &&\r\n(error == -EOPNOTSUPP)) {\r\npr_debug(DRV_PFX "write barrier op failed, not supported\n");\r\nxen_blkbk_barrier(XBT_NIL, pending_req->blkif->be, 0);\r\npending_req->status = BLKIF_RSP_EOPNOTSUPP;\r\n} else if (error) {\r\npr_debug(DRV_PFX "Buffer not up-to-date at end of operation,"\r\n" error=%d\n", error);\r\npending_req->status = BLKIF_RSP_ERROR;\r\n}\r\nif (atomic_dec_and_test(&pending_req->pendcnt)) {\r\nstruct xen_blkif *blkif = pending_req->blkif;\r\nxen_blkbk_unmap(blkif,\r\npending_req->segments,\r\npending_req->nr_pages);\r\nmake_response(blkif, pending_req->id,\r\npending_req->operation, pending_req->status);\r\nfree_req(blkif, pending_req);\r\nif (atomic_dec_and_test(&blkif->inflight) && atomic_read(&blkif->drain)) {\r\ncomplete(&blkif->drain_complete);\r\n}\r\nxen_blkif_put(blkif);\r\n}\r\n}\r\nstatic void end_block_io_op(struct bio *bio, int error)\r\n{\r\n__end_block_io_op(bio->bi_private, error);\r\nbio_put(bio);\r\n}\r\nstatic int\r\n__do_block_io_op(struct xen_blkif *blkif)\r\n{\r\nunion blkif_back_rings *blk_rings = &blkif->blk_rings;\r\nstruct blkif_request req;\r\nstruct pending_req *pending_req;\r\nRING_IDX rc, rp;\r\nint more_to_do = 0;\r\nrc = blk_rings->common.req_cons;\r\nrp = blk_rings->common.sring->req_prod;\r\nrmb();\r\nif (RING_REQUEST_PROD_OVERFLOW(&blk_rings->common, rp)) {\r\nrc = blk_rings->common.rsp_prod_pvt;\r\npr_warn(DRV_PFX "Frontend provided bogus ring requests (%d - %d = %d). Halting ring processing on dev=%04x\n",\r\nrp, rc, rp - rc, blkif->vbd.pdevice);\r\nreturn -EACCES;\r\n}\r\nwhile (rc != rp) {\r\nif (RING_REQUEST_CONS_OVERFLOW(&blk_rings->common, rc))\r\nbreak;\r\nif (kthread_should_stop()) {\r\nmore_to_do = 1;\r\nbreak;\r\n}\r\npending_req = alloc_req(blkif);\r\nif (NULL == pending_req) {\r\nblkif->st_oo_req++;\r\nmore_to_do = 1;\r\nbreak;\r\n}\r\nswitch (blkif->blk_protocol) {\r\ncase BLKIF_PROTOCOL_NATIVE:\r\nmemcpy(&req, RING_GET_REQUEST(&blk_rings->native, rc), sizeof(req));\r\nbreak;\r\ncase BLKIF_PROTOCOL_X86_32:\r\nblkif_get_x86_32_req(&req, RING_GET_REQUEST(&blk_rings->x86_32, rc));\r\nbreak;\r\ncase BLKIF_PROTOCOL_X86_64:\r\nblkif_get_x86_64_req(&req, RING_GET_REQUEST(&blk_rings->x86_64, rc));\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nblk_rings->common.req_cons = ++rc;\r\nbarrier();\r\nswitch (req.operation) {\r\ncase BLKIF_OP_READ:\r\ncase BLKIF_OP_WRITE:\r\ncase BLKIF_OP_WRITE_BARRIER:\r\ncase BLKIF_OP_FLUSH_DISKCACHE:\r\ncase BLKIF_OP_INDIRECT:\r\nif (dispatch_rw_block_io(blkif, &req, pending_req))\r\ngoto done;\r\nbreak;\r\ncase BLKIF_OP_DISCARD:\r\nfree_req(blkif, pending_req);\r\nif (dispatch_discard_io(blkif, &req))\r\ngoto done;\r\nbreak;\r\ndefault:\r\nif (dispatch_other_io(blkif, &req, pending_req))\r\ngoto done;\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\ndone:\r\nreturn more_to_do;\r\n}\r\nstatic int\r\ndo_block_io_op(struct xen_blkif *blkif)\r\n{\r\nunion blkif_back_rings *blk_rings = &blkif->blk_rings;\r\nint more_to_do;\r\ndo {\r\nmore_to_do = __do_block_io_op(blkif);\r\nif (more_to_do)\r\nbreak;\r\nRING_FINAL_CHECK_FOR_REQUESTS(&blk_rings->common, more_to_do);\r\n} while (more_to_do);\r\nreturn more_to_do;\r\n}\r\nstatic int dispatch_rw_block_io(struct xen_blkif *blkif,\r\nstruct blkif_request *req,\r\nstruct pending_req *pending_req)\r\n{\r\nstruct phys_req preq;\r\nstruct seg_buf *seg = pending_req->seg;\r\nunsigned int nseg;\r\nstruct bio *bio = NULL;\r\nstruct bio **biolist = pending_req->biolist;\r\nint i, nbio = 0;\r\nint operation;\r\nstruct blk_plug plug;\r\nbool drain = false;\r\nstruct grant_page **pages = pending_req->segments;\r\nunsigned short req_operation;\r\nreq_operation = req->operation == BLKIF_OP_INDIRECT ?\r\nreq->u.indirect.indirect_op : req->operation;\r\nif ((req->operation == BLKIF_OP_INDIRECT) &&\r\n(req_operation != BLKIF_OP_READ) &&\r\n(req_operation != BLKIF_OP_WRITE)) {\r\npr_debug(DRV_PFX "Invalid indirect operation (%u)\n",\r\nreq_operation);\r\ngoto fail_response;\r\n}\r\nswitch (req_operation) {\r\ncase BLKIF_OP_READ:\r\nblkif->st_rd_req++;\r\noperation = READ;\r\nbreak;\r\ncase BLKIF_OP_WRITE:\r\nblkif->st_wr_req++;\r\noperation = WRITE_ODIRECT;\r\nbreak;\r\ncase BLKIF_OP_WRITE_BARRIER:\r\ndrain = true;\r\ncase BLKIF_OP_FLUSH_DISKCACHE:\r\nblkif->st_f_req++;\r\noperation = WRITE_FLUSH;\r\nbreak;\r\ndefault:\r\noperation = 0;\r\ngoto fail_response;\r\nbreak;\r\n}\r\nnseg = req->operation == BLKIF_OP_INDIRECT ?\r\nreq->u.indirect.nr_segments : req->u.rw.nr_segments;\r\nif (unlikely(nseg == 0 && operation != WRITE_FLUSH) ||\r\nunlikely((req->operation != BLKIF_OP_INDIRECT) &&\r\n(nseg > BLKIF_MAX_SEGMENTS_PER_REQUEST)) ||\r\nunlikely((req->operation == BLKIF_OP_INDIRECT) &&\r\n(nseg > MAX_INDIRECT_SEGMENTS))) {\r\npr_debug(DRV_PFX "Bad number of segments in request (%d)\n",\r\nnseg);\r\ngoto fail_response;\r\n}\r\npreq.nr_sects = 0;\r\npending_req->blkif = blkif;\r\npending_req->id = req->u.rw.id;\r\npending_req->operation = req_operation;\r\npending_req->status = BLKIF_RSP_OKAY;\r\npending_req->nr_pages = nseg;\r\nif (req->operation != BLKIF_OP_INDIRECT) {\r\npreq.dev = req->u.rw.handle;\r\npreq.sector_number = req->u.rw.sector_number;\r\nfor (i = 0; i < nseg; i++) {\r\npages[i]->gref = req->u.rw.seg[i].gref;\r\nseg[i].nsec = req->u.rw.seg[i].last_sect -\r\nreq->u.rw.seg[i].first_sect + 1;\r\nseg[i].offset = (req->u.rw.seg[i].first_sect << 9);\r\nif ((req->u.rw.seg[i].last_sect >= (PAGE_SIZE >> 9)) ||\r\n(req->u.rw.seg[i].last_sect <\r\nreq->u.rw.seg[i].first_sect))\r\ngoto fail_response;\r\npreq.nr_sects += seg[i].nsec;\r\n}\r\n} else {\r\npreq.dev = req->u.indirect.handle;\r\npreq.sector_number = req->u.indirect.sector_number;\r\nif (xen_blkbk_parse_indirect(req, pending_req, seg, &preq))\r\ngoto fail_response;\r\n}\r\nif (xen_vbd_translate(&preq, blkif, operation) != 0) {\r\npr_debug(DRV_PFX "access denied: %s of [%llu,%llu] on dev=%04x\n",\r\noperation == READ ? "read" : "write",\r\npreq.sector_number,\r\npreq.sector_number + preq.nr_sects,\r\nblkif->vbd.pdevice);\r\ngoto fail_response;\r\n}\r\nfor (i = 0; i < nseg; i++) {\r\nif (((int)preq.sector_number|(int)seg[i].nsec) &\r\n((bdev_logical_block_size(preq.bdev) >> 9) - 1)) {\r\npr_debug(DRV_PFX "Misaligned I/O request from domain %d",\r\nblkif->domid);\r\ngoto fail_response;\r\n}\r\n}\r\nif (drain)\r\nxen_blk_drain_io(pending_req->blkif);\r\nif (xen_blkbk_map_seg(pending_req))\r\ngoto fail_flush;\r\nxen_blkif_get(blkif);\r\natomic_inc(&blkif->inflight);\r\nfor (i = 0; i < nseg; i++) {\r\nwhile ((bio == NULL) ||\r\n(bio_add_page(bio,\r\npages[i]->page,\r\nseg[i].nsec << 9,\r\nseg[i].offset) == 0)) {\r\nint nr_iovecs = min_t(int, (nseg-i), BIO_MAX_PAGES);\r\nbio = bio_alloc(GFP_KERNEL, nr_iovecs);\r\nif (unlikely(bio == NULL))\r\ngoto fail_put_bio;\r\nbiolist[nbio++] = bio;\r\nbio->bi_bdev = preq.bdev;\r\nbio->bi_private = pending_req;\r\nbio->bi_end_io = end_block_io_op;\r\nbio->bi_iter.bi_sector = preq.sector_number;\r\n}\r\npreq.sector_number += seg[i].nsec;\r\n}\r\nif (!bio) {\r\nBUG_ON(operation != WRITE_FLUSH);\r\nbio = bio_alloc(GFP_KERNEL, 0);\r\nif (unlikely(bio == NULL))\r\ngoto fail_put_bio;\r\nbiolist[nbio++] = bio;\r\nbio->bi_bdev = preq.bdev;\r\nbio->bi_private = pending_req;\r\nbio->bi_end_io = end_block_io_op;\r\n}\r\natomic_set(&pending_req->pendcnt, nbio);\r\nblk_start_plug(&plug);\r\nfor (i = 0; i < nbio; i++)\r\nsubmit_bio(operation, biolist[i]);\r\nblk_finish_plug(&plug);\r\nif (operation == READ)\r\nblkif->st_rd_sect += preq.nr_sects;\r\nelse if (operation & WRITE)\r\nblkif->st_wr_sect += preq.nr_sects;\r\nreturn 0;\r\nfail_flush:\r\nxen_blkbk_unmap(blkif, pending_req->segments,\r\npending_req->nr_pages);\r\nfail_response:\r\nmake_response(blkif, req->u.rw.id, req_operation, BLKIF_RSP_ERROR);\r\nfree_req(blkif, pending_req);\r\nmsleep(1);\r\nreturn -EIO;\r\nfail_put_bio:\r\nfor (i = 0; i < nbio; i++)\r\nbio_put(biolist[i]);\r\natomic_set(&pending_req->pendcnt, 1);\r\n__end_block_io_op(pending_req, -EINVAL);\r\nmsleep(1);\r\nreturn -EIO;\r\n}\r\nstatic void make_response(struct xen_blkif *blkif, u64 id,\r\nunsigned short op, int st)\r\n{\r\nstruct blkif_response resp;\r\nunsigned long flags;\r\nunion blkif_back_rings *blk_rings = &blkif->blk_rings;\r\nint notify;\r\nresp.id = id;\r\nresp.operation = op;\r\nresp.status = st;\r\nspin_lock_irqsave(&blkif->blk_ring_lock, flags);\r\nswitch (blkif->blk_protocol) {\r\ncase BLKIF_PROTOCOL_NATIVE:\r\nmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\r\n&resp, sizeof(resp));\r\nbreak;\r\ncase BLKIF_PROTOCOL_X86_32:\r\nmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\r\n&resp, sizeof(resp));\r\nbreak;\r\ncase BLKIF_PROTOCOL_X86_64:\r\nmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\r\n&resp, sizeof(resp));\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nblk_rings->common.rsp_prod_pvt++;\r\nRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\r\nspin_unlock_irqrestore(&blkif->blk_ring_lock, flags);\r\nif (notify)\r\nnotify_remote_via_irq(blkif->irq);\r\n}\r\nstatic int __init xen_blkif_init(void)\r\n{\r\nint rc = 0;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nrc = xen_blkif_interface_init();\r\nif (rc)\r\ngoto failed_init;\r\nrc = xen_blkif_xenbus_init();\r\nif (rc)\r\ngoto failed_init;\r\nfailed_init:\r\nreturn rc;\r\n}
