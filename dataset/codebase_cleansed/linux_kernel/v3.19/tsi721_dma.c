static inline struct tsi721_bdma_chan *to_tsi721_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct tsi721_bdma_chan, dchan);\r\n}\r\nstatic inline struct tsi721_device *to_tsi721(struct dma_device *ddev)\r\n{\r\nreturn container_of(ddev, struct rio_mport, dma)->priv;\r\n}\r\nstatic inline\r\nstruct tsi721_tx_desc *to_tsi721_desc(struct dma_async_tx_descriptor *txd)\r\n{\r\nreturn container_of(txd, struct tsi721_tx_desc, txd);\r\n}\r\nstatic inline\r\nstruct tsi721_tx_desc *tsi721_dma_first_active(\r\nstruct tsi721_bdma_chan *bdma_chan)\r\n{\r\nreturn list_first_entry(&bdma_chan->active_list,\r\nstruct tsi721_tx_desc, desc_node);\r\n}\r\nstatic int tsi721_bdma_ch_init(struct tsi721_bdma_chan *bdma_chan, int bd_num)\r\n{\r\nstruct tsi721_dma_desc *bd_ptr;\r\nstruct device *dev = bdma_chan->dchan.device->dev;\r\nu64 *sts_ptr;\r\ndma_addr_t bd_phys;\r\ndma_addr_t sts_phys;\r\nint sts_size;\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#endif\r\ndev_dbg(dev, "Init Block DMA Engine, CH%d\n", bdma_chan->id);\r\nbd_ptr = dma_zalloc_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\n&bd_phys, GFP_KERNEL);\r\nif (!bd_ptr)\r\nreturn -ENOMEM;\r\nbdma_chan->bd_num = bd_num;\r\nbdma_chan->bd_phys = bd_phys;\r\nbdma_chan->bd_base = bd_ptr;\r\ndev_dbg(dev, "DMA descriptors @ %p (phys = %llx)\n",\r\nbd_ptr, (unsigned long long)bd_phys);\r\nsts_size = ((bd_num + 1) >= TSI721_DMA_MINSTSSZ) ?\r\n(bd_num + 1) : TSI721_DMA_MINSTSSZ;\r\nsts_size = roundup_pow_of_two(sts_size);\r\nsts_ptr = dma_zalloc_coherent(dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\n&sts_phys, GFP_KERNEL);\r\nif (!sts_ptr) {\r\ndma_free_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\nbdma_chan->bd_base = NULL;\r\nreturn -ENOMEM;\r\n}\r\nbdma_chan->sts_phys = sts_phys;\r\nbdma_chan->sts_base = sts_ptr;\r\nbdma_chan->sts_size = sts_size;\r\ndev_dbg(dev,\r\n"desc status FIFO @ %p (phys = %llx) size=0x%x\n",\r\nsts_ptr, (unsigned long long)sts_phys, sts_size);\r\nbd_ptr[bd_num].type_id = cpu_to_le32(DTYPE3 << 29);\r\nbd_ptr[bd_num].next_lo = cpu_to_le32((u64)bd_phys &\r\nTSI721_DMAC_DPTRL_MASK);\r\nbd_ptr[bd_num].next_hi = cpu_to_le32((u64)bd_phys >> 32);\r\niowrite32(((u64)bd_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DPTRH);\r\niowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DPTRL);\r\niowrite32(((u64)sts_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DSBH);\r\niowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DSBL);\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\r\nbdma_chan->regs + TSI721_DMAC_DSSZ);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nint rc, idx;\r\nidx = TSI721_VECT_DMA0_DONE + bdma_chan->id;\r\nrc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\r\npriv->msix[idx].irq_name, (void *)bdma_chan);\r\nif (rc) {\r\ndev_dbg(dev, "Unable to get MSI-X for BDMA%d-DONE\n",\r\nbdma_chan->id);\r\ngoto err_out;\r\n}\r\nidx = TSI721_VECT_DMA0_INT + bdma_chan->id;\r\nrc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\r\npriv->msix[idx].irq_name, (void *)bdma_chan);\r\nif (rc) {\r\ndev_dbg(dev, "Unable to get MSI-X for BDMA%d-INT\n",\r\nbdma_chan->id);\r\nfree_irq(\r\npriv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector,\r\n(void *)bdma_chan);\r\n}\r\nerr_out:\r\nif (rc) {\r\ndma_free_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\nbdma_chan->bd_base = NULL;\r\ndma_free_coherent(dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\nsts_ptr, sts_phys);\r\nbdma_chan->sts_base = NULL;\r\nreturn -EIO;\r\n}\r\n}\r\n#endif\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\nioread32(bdma_chan->regs + TSI721_DMAC_CTL);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\r\nbdma_chan->sts_rdptr = 0;\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int tsi721_bdma_ch_free(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 ch_stat;\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#endif\r\nif (bdma_chan->bd_base == NULL)\r\nreturn 0;\r\nch_stat = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nif (ch_stat & TSI721_DMAC_STS_RUN)\r\nreturn -EFAULT;\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\n}\r\n#endif\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\n(bdma_chan->bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbdma_chan->bd_base, bdma_chan->bd_phys);\r\nbdma_chan->bd_base = NULL;\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\nbdma_chan->sts_size * sizeof(struct tsi721_dma_sts),\r\nbdma_chan->sts_base, bdma_chan->sts_phys);\r\nbdma_chan->sts_base = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\ntsi721_bdma_interrupt_enable(struct tsi721_bdma_chan *bdma_chan, int enable)\r\n{\r\nif (enable) {\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INTE);\r\n} else {\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\n}\r\n}\r\nstatic bool tsi721_dma_is_idle(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 sts;\r\nsts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nreturn ((sts & TSI721_DMAC_STS_RUN) == 0);\r\n}\r\nvoid tsi721_bdma_handler(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\nif (bdma_chan->active)\r\ntasklet_schedule(&bdma_chan->tasklet);\r\n}\r\nstatic irqreturn_t tsi721_bdma_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = ptr;\r\ntsi721_bdma_handler(bdma_chan);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsi721_start_dma(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"BUG: Attempt to start non-idle channel\n");\r\nreturn;\r\n}\r\nif (bdma_chan->wr_count == bdma_chan->wr_count_next) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"BUG: Attempt to start DMA with no BDs ready\n");\r\nreturn;\r\n}\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"%s: chan_%d (wrc=%d)\n", __func__, bdma_chan->id,\r\nbdma_chan->wr_count_next);\r\niowrite32(bdma_chan->wr_count_next,\r\nbdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next;\r\n}\r\nstatic int\r\ntsi721_desc_fill_init(struct tsi721_tx_desc *desc,\r\nstruct tsi721_dma_desc *bd_ptr,\r\nstruct scatterlist *sg, u32 sys_size)\r\n{\r\nu64 rio_addr;\r\nif (bd_ptr == NULL)\r\nreturn -EINVAL;\r\nbd_ptr->type_id = cpu_to_le32((DTYPE1 << 29) |\r\n(desc->rtype << 19) | desc->destid);\r\nbd_ptr->bcount = cpu_to_le32(((desc->rio_addr & 0x3) << 30) |\r\n(sys_size << 26));\r\nrio_addr = (desc->rio_addr >> 2) |\r\n((u64)(desc->rio_addr_u & 0x3) << 62);\r\nbd_ptr->raddr_lo = cpu_to_le32(rio_addr & 0xffffffff);\r\nbd_ptr->raddr_hi = cpu_to_le32(rio_addr >> 32);\r\nbd_ptr->t1.bufptr_lo = cpu_to_le32(\r\n(u64)sg_dma_address(sg) & 0xffffffff);\r\nbd_ptr->t1.bufptr_hi = cpu_to_le32((u64)sg_dma_address(sg) >> 32);\r\nbd_ptr->t1.s_dist = 0;\r\nbd_ptr->t1.s_size = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ntsi721_desc_fill_end(struct tsi721_dma_desc *bd_ptr, u32 bcount, bool interrupt)\r\n{\r\nif (bd_ptr == NULL)\r\nreturn -EINVAL;\r\nif (interrupt)\r\nbd_ptr->type_id |= cpu_to_le32(TSI721_DMAD_IOF);\r\nbd_ptr->bcount |= cpu_to_le32(bcount & TSI721_DMAD_BCOUNT1);\r\nreturn 0;\r\n}\r\nstatic void tsi721_dma_tx_err(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc)\r\n{\r\nstruct dma_async_tx_descriptor *txd = &desc->txd;\r\ndma_async_tx_callback callback = txd->callback;\r\nvoid *param = txd->callback_param;\r\nlist_move(&desc->desc_node, &bdma_chan->free_list);\r\nif (callback)\r\ncallback(param);\r\n}\r\nstatic void tsi721_clr_stat(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 srd_ptr;\r\nu64 *sts_ptr;\r\nint i, j;\r\nsrd_ptr = bdma_chan->sts_rdptr;\r\nsts_ptr = bdma_chan->sts_base;\r\nj = srd_ptr * 8;\r\nwhile (sts_ptr[j]) {\r\nfor (i = 0; i < 8 && sts_ptr[j]; i++, j++)\r\nsts_ptr[j] = 0;\r\n++srd_ptr;\r\nsrd_ptr %= bdma_chan->sts_size;\r\nj = srd_ptr * 8;\r\n}\r\niowrite32(srd_ptr, bdma_chan->regs + TSI721_DMAC_DSRP);\r\nbdma_chan->sts_rdptr = srd_ptr;\r\n}\r\nstatic int tsi721_submit_sg(struct tsi721_tx_desc *desc)\r\n{\r\nstruct dma_chan *dchan = desc->txd.chan;\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nu32 sys_size;\r\nu64 rio_addr;\r\ndma_addr_t next_addr;\r\nu32 bcount;\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\nint err = 0;\r\nstruct tsi721_dma_desc *bd_ptr = NULL;\r\nu32 idx, rd_idx;\r\nu32 add_count = 0;\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"BUG: Attempt to use non-idle channel\n");\r\nreturn -EIO;\r\n}\r\nrio_addr = desc->rio_addr;\r\nnext_addr = -1;\r\nbcount = 0;\r\nsys_size = dma_to_mport(bdma_chan->dchan.device)->sys_size;\r\nrd_idx = ioread32(bdma_chan->regs + TSI721_DMAC_DRDCNT);\r\nrd_idx %= (bdma_chan->bd_num + 1);\r\nidx = bdma_chan->wr_count_next % (bdma_chan->bd_num + 1);\r\nif (idx == bdma_chan->bd_num) {\r\nidx = 0;\r\nadd_count++;\r\n}\r\ndev_dbg(dchan->device->dev, "%s: BD ring status: rdi=%d wri=%d\n",\r\n__func__, rd_idx, idx);\r\nfor_each_sg(desc->sg, sg, desc->sg_len, i) {\r\ndev_dbg(dchan->device->dev, "sg%d/%d addr: 0x%llx len: %d\n",\r\ni, desc->sg_len,\r\n(unsigned long long)sg_dma_address(sg), sg_dma_len(sg));\r\nif (sg_dma_len(sg) > TSI721_BDMA_MAX_BCOUNT) {\r\ndev_err(dchan->device->dev,\r\n"%s: SG entry %d is too large\n", __func__, i);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (next_addr == sg_dma_address(sg) &&\r\nbcount + sg_dma_len(sg) <= TSI721_BDMA_MAX_BCOUNT) {\r\nbcount += sg_dma_len(sg);\r\ngoto entry_done;\r\n} else if (next_addr != -1) {\r\ntsi721_desc_fill_end(bd_ptr, bcount, 0);\r\ndev_dbg(dchan->device->dev,\r\n"%s: prev desc final len: %d\n",\r\n__func__, bcount);\r\n}\r\ndesc->rio_addr = rio_addr;\r\nif (i && idx == rd_idx) {\r\ndev_dbg(dchan->device->dev,\r\n"%s: HW descriptor ring is full @ %d\n",\r\n__func__, i);\r\ndesc->sg = sg;\r\ndesc->sg_len -= i;\r\nbreak;\r\n}\r\nbd_ptr = &((struct tsi721_dma_desc *)bdma_chan->bd_base)[idx];\r\nerr = tsi721_desc_fill_init(desc, bd_ptr, sg, sys_size);\r\nif (err) {\r\ndev_err(dchan->device->dev,\r\n"Failed to build desc: err=%d\n", err);\r\nbreak;\r\n}\r\ndev_dbg(dchan->device->dev, "bd_ptr = %p did=%d raddr=0x%llx\n",\r\nbd_ptr, desc->destid, desc->rio_addr);\r\nnext_addr = sg_dma_address(sg);\r\nbcount = sg_dma_len(sg);\r\nadd_count++;\r\nif (++idx == bdma_chan->bd_num) {\r\nidx = 0;\r\nadd_count++;\r\n}\r\nentry_done:\r\nif (sg_is_last(sg)) {\r\ntsi721_desc_fill_end(bd_ptr, bcount, 0);\r\ndev_dbg(dchan->device->dev, "%s: last desc final len: %d\n",\r\n__func__, bcount);\r\ndesc->sg_len = 0;\r\n} else {\r\nrio_addr += sg_dma_len(sg);\r\nnext_addr += sg_dma_len(sg);\r\n}\r\n}\r\nif (!err)\r\nbdma_chan->wr_count_next += add_count;\r\nreturn err;\r\n}\r\nstatic void tsi721_advance_work(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_tx_desc *desc;\r\nint err;\r\ndev_dbg(bdma_chan->dchan.device->dev, "%s: Enter\n", __func__);\r\nif (!list_empty(&bdma_chan->queue))\r\nlist_splice_init(&bdma_chan->queue, &bdma_chan->active_list);\r\nif (!list_empty(&bdma_chan->active_list)) {\r\ndesc = tsi721_dma_first_active(bdma_chan);\r\nerr = tsi721_submit_sg(desc);\r\nif (!err)\r\ntsi721_start_dma(bdma_chan);\r\nelse {\r\ntsi721_dma_tx_err(bdma_chan, desc);\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"ERR: tsi721_submit_sg failed with err=%d\n",\r\nerr);\r\n}\r\n}\r\ndev_dbg(bdma_chan->dchan.device->dev, "%s: Exit\n", __func__);\r\n}\r\nstatic void tsi721_dma_tasklet(unsigned long data)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = (struct tsi721_bdma_chan *)data;\r\nu32 dmac_int, dmac_sts;\r\ndmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\ndev_dbg(bdma_chan->dchan.device->dev, "%s: DMAC%d_INT = 0x%x\n",\r\n__func__, bdma_chan->id, dmac_int);\r\niowrite32(dmac_int, bdma_chan->regs + TSI721_DMAC_INT);\r\nif (dmac_int & TSI721_DMAC_INT_ERR) {\r\ndmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"%s: DMA ERROR - DMAC%d_STS = 0x%x\n",\r\n__func__, bdma_chan->id, dmac_sts);\r\n}\r\nif (dmac_int & TSI721_DMAC_INT_STFULL) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"%s: DMAC%d descriptor status FIFO is full\n",\r\n__func__, bdma_chan->id);\r\n}\r\nif (dmac_int & (TSI721_DMAC_INT_DONE | TSI721_DMAC_INT_IOFDONE)) {\r\nstruct tsi721_tx_desc *desc;\r\ntsi721_clr_stat(bdma_chan);\r\nspin_lock(&bdma_chan->lock);\r\ndesc = tsi721_dma_first_active(bdma_chan);\r\nif (desc->sg_len == 0) {\r\ndma_async_tx_callback callback = NULL;\r\nvoid *param = NULL;\r\ndesc->status = DMA_COMPLETE;\r\ndma_cookie_complete(&desc->txd);\r\nif (desc->txd.flags & DMA_PREP_INTERRUPT) {\r\ncallback = desc->txd.callback;\r\nparam = desc->txd.callback_param;\r\n}\r\nlist_move(&desc->desc_node, &bdma_chan->free_list);\r\nspin_unlock(&bdma_chan->lock);\r\nif (callback)\r\ncallback(param);\r\nspin_lock(&bdma_chan->lock);\r\n}\r\ntsi721_advance_work(bdma_chan);\r\nspin_unlock(&bdma_chan->lock);\r\n}\r\niowrite32(TSI721_DMAC_INT_ALL, bdma_chan->regs + TSI721_DMAC_INTE);\r\n}\r\nstatic dma_cookie_t tsi721_tx_submit(struct dma_async_tx_descriptor *txd)\r\n{\r\nstruct tsi721_tx_desc *desc = to_tsi721_desc(txd);\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(txd->chan);\r\ndma_cookie_t cookie;\r\nif (!list_empty(&desc->desc_node)) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"%s: wrong state of descriptor %p\n", __func__, txd);\r\nreturn -EIO;\r\n}\r\nspin_lock_bh(&bdma_chan->lock);\r\nif (!bdma_chan->active) {\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn -ENODEV;\r\n}\r\ncookie = dma_cookie_assign(txd);\r\ndesc->status = DMA_IN_PROGRESS;\r\nlist_add_tail(&desc->desc_node, &bdma_chan->queue);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn cookie;\r\n}\r\nstatic int tsi721_alloc_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc = NULL;\r\nint i;\r\ndev_dbg(dchan->device->dev, "%s: for channel %d\n",\r\n__func__, bdma_chan->id);\r\nif (bdma_chan->bd_base)\r\nreturn TSI721_DMA_TX_QUEUE_SZ;\r\nif (tsi721_bdma_ch_init(bdma_chan, dma_desc_per_channel)) {\r\ndev_err(dchan->device->dev, "Unable to initialize data DMA"\r\n" channel %d, aborting\n", bdma_chan->id);\r\nreturn -ENODEV;\r\n}\r\ndesc = kcalloc(TSI721_DMA_TX_QUEUE_SZ, sizeof(struct tsi721_tx_desc),\r\nGFP_KERNEL);\r\nif (!desc) {\r\ndev_err(dchan->device->dev,\r\n"Failed to allocate logical descriptors\n");\r\ntsi721_bdma_ch_free(bdma_chan);\r\nreturn -ENOMEM;\r\n}\r\nbdma_chan->tx_desc = desc;\r\nfor (i = 0; i < TSI721_DMA_TX_QUEUE_SZ; i++) {\r\ndma_async_tx_descriptor_init(&desc[i].txd, dchan);\r\ndesc[i].txd.tx_submit = tsi721_tx_submit;\r\ndesc[i].txd.flags = DMA_CTRL_ACK;\r\nlist_add(&desc[i].desc_node, &bdma_chan->free_list);\r\n}\r\ndma_cookie_init(dchan);\r\nbdma_chan->active = true;\r\ntsi721_bdma_interrupt_enable(bdma_chan, 1);\r\nreturn TSI721_DMA_TX_QUEUE_SZ;\r\n}\r\nstatic void tsi721_sync_dma_irq(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nsynchronize_irq(priv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector);\r\nsynchronize_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector);\r\n} else\r\n#endif\r\nsynchronize_irq(priv->pdev->irq);\r\n}\r\nstatic void tsi721_free_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ndev_dbg(dchan->device->dev, "%s: for channel %d\n",\r\n__func__, bdma_chan->id);\r\nif (bdma_chan->bd_base == NULL)\r\nreturn;\r\nBUG_ON(!list_empty(&bdma_chan->active_list));\r\nBUG_ON(!list_empty(&bdma_chan->queue));\r\ntsi721_bdma_interrupt_enable(bdma_chan, 0);\r\nbdma_chan->active = false;\r\ntsi721_sync_dma_irq(bdma_chan);\r\ntasklet_kill(&bdma_chan->tasklet);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\nkfree(bdma_chan->tx_desc);\r\ntsi721_bdma_ch_free(bdma_chan);\r\n}\r\nstatic\r\nenum dma_status tsi721_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nreturn dma_cookie_status(dchan, cookie, txstate);\r\n}\r\nstatic void tsi721_issue_pending(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ndev_dbg(dchan->device->dev, "%s: Enter\n", __func__);\r\nif (tsi721_dma_is_idle(bdma_chan) && bdma_chan->active) {\r\nspin_lock_bh(&bdma_chan->lock);\r\ntsi721_advance_work(bdma_chan);\r\nspin_unlock_bh(&bdma_chan->lock);\r\n}\r\n}\r\nstatic\r\nstruct dma_async_tx_descriptor *tsi721_prep_rio_sg(struct dma_chan *dchan,\r\nstruct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction dir, unsigned long flags,\r\nvoid *tinfo)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc, *_d;\r\nstruct rio_dma_ext *rext = tinfo;\r\nenum dma_rtype rtype;\r\nstruct dma_async_tx_descriptor *txd = NULL;\r\nif (!sgl || !sg_len) {\r\ndev_err(dchan->device->dev, "%s: No SG list\n", __func__);\r\nreturn NULL;\r\n}\r\ndev_dbg(dchan->device->dev, "%s: %s\n", __func__,\r\n(dir == DMA_DEV_TO_MEM)?"READ":"WRITE");\r\nif (dir == DMA_DEV_TO_MEM)\r\nrtype = NREAD;\r\nelse if (dir == DMA_MEM_TO_DEV) {\r\nswitch (rext->wr_type) {\r\ncase RDW_ALL_NWRITE:\r\nrtype = ALL_NWRITE;\r\nbreak;\r\ncase RDW_ALL_NWRITE_R:\r\nrtype = ALL_NWRITE_R;\r\nbreak;\r\ncase RDW_LAST_NWRITE_R:\r\ndefault:\r\nrtype = LAST_NWRITE_R;\r\nbreak;\r\n}\r\n} else {\r\ndev_err(dchan->device->dev,\r\n"%s: Unsupported DMA direction option\n", __func__);\r\nreturn NULL;\r\n}\r\nspin_lock_bh(&bdma_chan->lock);\r\nlist_for_each_entry_safe(desc, _d, &bdma_chan->free_list, desc_node) {\r\nif (async_tx_test_ack(&desc->txd)) {\r\nlist_del_init(&desc->desc_node);\r\ndesc->destid = rext->destid;\r\ndesc->rio_addr = rext->rio_addr;\r\ndesc->rio_addr_u = 0;\r\ndesc->rtype = rtype;\r\ndesc->sg_len = sg_len;\r\ndesc->sg = sgl;\r\ntxd = &desc->txd;\r\ntxd->flags = flags;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn txd;\r\n}\r\nstatic int tsi721_device_control(struct dma_chan *dchan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc, *_d;\r\nu32 dmac_int;\r\nLIST_HEAD(list);\r\ndev_dbg(dchan->device->dev, "%s: Entry\n", __func__);\r\nif (cmd != DMA_TERMINATE_ALL)\r\nreturn -ENOSYS;\r\nspin_lock_bh(&bdma_chan->lock);\r\nbdma_chan->active = false;\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\niowrite32(TSI721_DMAC_CTL_SUSP,\r\nbdma_chan->regs + TSI721_DMAC_CTL);\r\ndo {\r\ndmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\n} while ((dmac_int & TSI721_DMAC_INT_SUSP) == 0);\r\n}\r\nlist_splice_init(&bdma_chan->active_list, &list);\r\nlist_splice_init(&bdma_chan->queue, &list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\ntsi721_dma_tx_err(bdma_chan, desc);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn 0;\r\n}\r\nint tsi721_register_dma(struct tsi721_device *priv)\r\n{\r\nint i;\r\nint nr_channels = 0;\r\nint err;\r\nstruct rio_mport *mport = priv->mport;\r\nINIT_LIST_HEAD(&mport->dma.channels);\r\nfor (i = 0; i < TSI721_DMA_MAXCH; i++) {\r\nstruct tsi721_bdma_chan *bdma_chan = &priv->bdma[i];\r\nif (i == TSI721_DMACH_MAINT)\r\ncontinue;\r\nbdma_chan->regs = priv->regs + TSI721_DMAC_BASE(i);\r\nbdma_chan->dchan.device = &mport->dma;\r\nbdma_chan->dchan.cookie = 1;\r\nbdma_chan->dchan.chan_id = i;\r\nbdma_chan->id = i;\r\nbdma_chan->active = false;\r\nspin_lock_init(&bdma_chan->lock);\r\nINIT_LIST_HEAD(&bdma_chan->active_list);\r\nINIT_LIST_HEAD(&bdma_chan->queue);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\ntasklet_init(&bdma_chan->tasklet, tsi721_dma_tasklet,\r\n(unsigned long)bdma_chan);\r\nlist_add_tail(&bdma_chan->dchan.device_node,\r\n&mport->dma.channels);\r\nnr_channels++;\r\n}\r\nmport->dma.chancnt = nr_channels;\r\ndma_cap_zero(mport->dma.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, mport->dma.cap_mask);\r\ndma_cap_set(DMA_SLAVE, mport->dma.cap_mask);\r\nmport->dma.dev = &priv->pdev->dev;\r\nmport->dma.device_alloc_chan_resources = tsi721_alloc_chan_resources;\r\nmport->dma.device_free_chan_resources = tsi721_free_chan_resources;\r\nmport->dma.device_tx_status = tsi721_tx_status;\r\nmport->dma.device_issue_pending = tsi721_issue_pending;\r\nmport->dma.device_prep_slave_sg = tsi721_prep_rio_sg;\r\nmport->dma.device_control = tsi721_device_control;\r\nerr = dma_async_device_register(&mport->dma);\r\nif (err)\r\ndev_err(&priv->pdev->dev, "Failed to register DMA device\n");\r\nreturn err;\r\n}
