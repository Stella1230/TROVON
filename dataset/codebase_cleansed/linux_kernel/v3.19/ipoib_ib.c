struct ipoib_ah *ipoib_create_ah(struct net_device *dev,\r\nstruct ib_pd *pd, struct ib_ah_attr *attr)\r\n{\r\nstruct ipoib_ah *ah;\r\nstruct ib_ah *vah;\r\nah = kmalloc(sizeof *ah, GFP_KERNEL);\r\nif (!ah)\r\nreturn ERR_PTR(-ENOMEM);\r\nah->dev = dev;\r\nah->last_send = 0;\r\nkref_init(&ah->ref);\r\nvah = ib_create_ah(pd, attr);\r\nif (IS_ERR(vah)) {\r\nkfree(ah);\r\nah = (struct ipoib_ah *)vah;\r\n} else {\r\nah->ah = vah;\r\nipoib_dbg(netdev_priv(dev), "Created ah %p\n", ah->ah);\r\n}\r\nreturn ah;\r\n}\r\nvoid ipoib_free_ah(struct kref *kref)\r\n{\r\nstruct ipoib_ah *ah = container_of(kref, struct ipoib_ah, ref);\r\nstruct ipoib_dev_priv *priv = netdev_priv(ah->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_add_tail(&ah->list, &priv->dead_ahs);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipoib_ud_dma_unmap_rx(struct ipoib_dev_priv *priv,\r\nu64 mapping[IPOIB_UD_RX_SG])\r\n{\r\nif (ipoib_ud_need_sg(priv->max_ib_mtu)) {\r\nib_dma_unmap_single(priv->ca, mapping[0], IPOIB_UD_HEAD_SIZE,\r\nDMA_FROM_DEVICE);\r\nib_dma_unmap_page(priv->ca, mapping[1], PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\n} else\r\nib_dma_unmap_single(priv->ca, mapping[0],\r\nIPOIB_UD_BUF_SIZE(priv->max_ib_mtu),\r\nDMA_FROM_DEVICE);\r\n}\r\nstatic void ipoib_ud_skb_put_frags(struct ipoib_dev_priv *priv,\r\nstruct sk_buff *skb,\r\nunsigned int length)\r\n{\r\nif (ipoib_ud_need_sg(priv->max_ib_mtu)) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[0];\r\nunsigned int size;\r\nskb->tail += IPOIB_UD_HEAD_SIZE;\r\nskb->len += length;\r\nsize = length - IPOIB_UD_HEAD_SIZE;\r\nskb_frag_size_set(frag, size);\r\nskb->data_len += size;\r\nskb->truesize += PAGE_SIZE;\r\n} else\r\nskb_put(skb, length);\r\n}\r\nstatic int ipoib_ib_post_receive(struct net_device *dev, int id)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_recv_wr *bad_wr;\r\nint ret;\r\npriv->rx_wr.wr_id = id | IPOIB_OP_RECV;\r\npriv->rx_sge[0].addr = priv->rx_ring[id].mapping[0];\r\npriv->rx_sge[1].addr = priv->rx_ring[id].mapping[1];\r\nret = ib_post_recv(priv->qp, &priv->rx_wr, &bad_wr);\r\nif (unlikely(ret)) {\r\nipoib_warn(priv, "receive failed for buf %d (%d)\n", id, ret);\r\nipoib_ud_dma_unmap_rx(priv, priv->rx_ring[id].mapping);\r\ndev_kfree_skb_any(priv->rx_ring[id].skb);\r\npriv->rx_ring[id].skb = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *ipoib_alloc_rx_skb(struct net_device *dev, int id)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint buf_size;\r\nint tailroom;\r\nu64 *mapping;\r\nif (ipoib_ud_need_sg(priv->max_ib_mtu)) {\r\nbuf_size = IPOIB_UD_HEAD_SIZE;\r\ntailroom = 128;\r\n} else {\r\nbuf_size = IPOIB_UD_BUF_SIZE(priv->max_ib_mtu);\r\ntailroom = 0;\r\n}\r\nskb = dev_alloc_skb(buf_size + tailroom + 4);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\nskb_reserve(skb, 4);\r\nmapping = priv->rx_ring[id].mapping;\r\nmapping[0] = ib_dma_map_single(priv->ca, skb->data, buf_size,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(priv->ca, mapping[0])))\r\ngoto error;\r\nif (ipoib_ud_need_sg(priv->max_ib_mtu)) {\r\nstruct page *page = alloc_page(GFP_ATOMIC);\r\nif (!page)\r\ngoto partial_error;\r\nskb_fill_page_desc(skb, 0, page, 0, PAGE_SIZE);\r\nmapping[1] =\r\nib_dma_map_page(priv->ca, page,\r\n0, PAGE_SIZE, DMA_FROM_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(priv->ca, mapping[1])))\r\ngoto partial_error;\r\n}\r\npriv->rx_ring[id].skb = skb;\r\nreturn skb;\r\npartial_error:\r\nib_dma_unmap_single(priv->ca, mapping[0], buf_size, DMA_FROM_DEVICE);\r\nerror:\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic int ipoib_ib_post_receives(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < ipoib_recvq_size; ++i) {\r\nif (!ipoib_alloc_rx_skb(dev, i)) {\r\nipoib_warn(priv, "failed to allocate receive buffer %d\n", i);\r\nreturn -ENOMEM;\r\n}\r\nif (ipoib_ib_post_receive(dev, i)) {\r\nipoib_warn(priv, "ipoib_ib_post_receive failed for buf %d\n", i);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipoib_ib_handle_rx_wc(struct net_device *dev, struct ib_wc *wc)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nunsigned int wr_id = wc->wr_id & ~IPOIB_OP_RECV;\r\nstruct sk_buff *skb;\r\nu64 mapping[IPOIB_UD_RX_SG];\r\nunion ib_gid *dgid;\r\nipoib_dbg_data(priv, "recv completion: id %d, status: %d\n",\r\nwr_id, wc->status);\r\nif (unlikely(wr_id >= ipoib_recvq_size)) {\r\nipoib_warn(priv, "recv completion event with wrid %d (> %d)\n",\r\nwr_id, ipoib_recvq_size);\r\nreturn;\r\n}\r\nskb = priv->rx_ring[wr_id].skb;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\nipoib_warn(priv, "failed recv event "\r\n"(status=%d, wrid=%d vend_err %x)\n",\r\nwc->status, wr_id, wc->vendor_err);\r\nipoib_ud_dma_unmap_rx(priv, priv->rx_ring[wr_id].mapping);\r\ndev_kfree_skb_any(skb);\r\npriv->rx_ring[wr_id].skb = NULL;\r\nreturn;\r\n}\r\nif (wc->slid == priv->local_lid && wc->src_qp == priv->qp->qp_num)\r\ngoto repost;\r\nmemcpy(mapping, priv->rx_ring[wr_id].mapping,\r\nIPOIB_UD_RX_SG * sizeof *mapping);\r\nif (unlikely(!ipoib_alloc_rx_skb(dev, wr_id))) {\r\n++dev->stats.rx_dropped;\r\ngoto repost;\r\n}\r\nipoib_dbg_data(priv, "received %d bytes, SLID 0x%04x\n",\r\nwc->byte_len, wc->slid);\r\nipoib_ud_dma_unmap_rx(priv, mapping);\r\nipoib_ud_skb_put_frags(priv, skb, wc->byte_len);\r\ndgid = &((struct ib_grh *)skb->data)->dgid;\r\nif (!(wc->wc_flags & IB_WC_GRH) || dgid->raw[0] != 0xff)\r\nskb->pkt_type = PACKET_HOST;\r\nelse if (memcmp(dgid, dev->broadcast + 4, sizeof(union ib_gid)) == 0)\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\nskb_pull(skb, IB_GRH_BYTES);\r\nskb->protocol = ((struct ipoib_header *) skb->data)->proto;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, IPOIB_ENCAP_LEN);\r\n++dev->stats.rx_packets;\r\ndev->stats.rx_bytes += skb->len;\r\nskb->dev = dev;\r\nif ((dev->features & NETIF_F_RXCSUM) &&\r\nlikely(wc->wc_flags & IB_WC_IP_CSUM_OK))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnapi_gro_receive(&priv->napi, skb);\r\nrepost:\r\nif (unlikely(ipoib_ib_post_receive(dev, wr_id)))\r\nipoib_warn(priv, "ipoib_ib_post_receive failed "\r\n"for buf %d\n", wr_id);\r\n}\r\nstatic int ipoib_dma_map_tx(struct ib_device *ca,\r\nstruct ipoib_tx_buf *tx_req)\r\n{\r\nstruct sk_buff *skb = tx_req->skb;\r\nu64 *mapping = tx_req->mapping;\r\nint i;\r\nint off;\r\nif (skb_headlen(skb)) {\r\nmapping[0] = ib_dma_map_single(ca, skb->data, skb_headlen(skb),\r\nDMA_TO_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(ca, mapping[0])))\r\nreturn -EIO;\r\noff = 1;\r\n} else\r\noff = 0;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; ++i) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nmapping[i + off] = ib_dma_map_page(ca,\r\nskb_frag_page(frag),\r\nfrag->page_offset, skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(ca, mapping[i + off])))\r\ngoto partial_error;\r\n}\r\nreturn 0;\r\npartial_error:\r\nfor (; i > 0; --i) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i - 1];\r\nib_dma_unmap_page(ca, mapping[i - !off], skb_frag_size(frag), DMA_TO_DEVICE);\r\n}\r\nif (off)\r\nib_dma_unmap_single(ca, mapping[0], skb_headlen(skb), DMA_TO_DEVICE);\r\nreturn -EIO;\r\n}\r\nstatic void ipoib_dma_unmap_tx(struct ib_device *ca,\r\nstruct ipoib_tx_buf *tx_req)\r\n{\r\nstruct sk_buff *skb = tx_req->skb;\r\nu64 *mapping = tx_req->mapping;\r\nint i;\r\nint off;\r\nif (skb_headlen(skb)) {\r\nib_dma_unmap_single(ca, mapping[0], skb_headlen(skb), DMA_TO_DEVICE);\r\noff = 1;\r\n} else\r\noff = 0;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; ++i) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nib_dma_unmap_page(ca, mapping[i + off], skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\n}\r\n}\r\nstatic void ipoib_ib_handle_tx_wc(struct net_device *dev, struct ib_wc *wc)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nunsigned int wr_id = wc->wr_id;\r\nstruct ipoib_tx_buf *tx_req;\r\nipoib_dbg_data(priv, "send completion: id %d, status: %d\n",\r\nwr_id, wc->status);\r\nif (unlikely(wr_id >= ipoib_sendq_size)) {\r\nipoib_warn(priv, "send completion event with wrid %d (> %d)\n",\r\nwr_id, ipoib_sendq_size);\r\nreturn;\r\n}\r\ntx_req = &priv->tx_ring[wr_id];\r\nipoib_dma_unmap_tx(priv->ca, tx_req);\r\n++dev->stats.tx_packets;\r\ndev->stats.tx_bytes += tx_req->skb->len;\r\ndev_kfree_skb_any(tx_req->skb);\r\n++priv->tx_tail;\r\nif (unlikely(--priv->tx_outstanding == ipoib_sendq_size >> 1) &&\r\nnetif_queue_stopped(dev) &&\r\ntest_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))\r\nnetif_wake_queue(dev);\r\nif (wc->status != IB_WC_SUCCESS &&\r\nwc->status != IB_WC_WR_FLUSH_ERR)\r\nipoib_warn(priv, "failed send event "\r\n"(status=%d, wrid=%d vend_err %x)\n",\r\nwc->status, wr_id, wc->vendor_err);\r\n}\r\nstatic int poll_tx(struct ipoib_dev_priv *priv)\r\n{\r\nint n, i;\r\nn = ib_poll_cq(priv->send_cq, MAX_SEND_CQE, priv->send_wc);\r\nfor (i = 0; i < n; ++i)\r\nipoib_ib_handle_tx_wc(priv->dev, priv->send_wc + i);\r\nreturn n == MAX_SEND_CQE;\r\n}\r\nint ipoib_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(napi, struct ipoib_dev_priv, napi);\r\nstruct net_device *dev = priv->dev;\r\nint done;\r\nint t;\r\nint n, i;\r\ndone = 0;\r\npoll_more:\r\nwhile (done < budget) {\r\nint max = (budget - done);\r\nt = min(IPOIB_NUM_WC, max);\r\nn = ib_poll_cq(priv->recv_cq, t, priv->ibwc);\r\nfor (i = 0; i < n; i++) {\r\nstruct ib_wc *wc = priv->ibwc + i;\r\nif (wc->wr_id & IPOIB_OP_RECV) {\r\n++done;\r\nif (wc->wr_id & IPOIB_OP_CM)\r\nipoib_cm_handle_rx_wc(dev, wc);\r\nelse\r\nipoib_ib_handle_rx_wc(dev, wc);\r\n} else\r\nipoib_cm_handle_tx_wc(priv->dev, wc);\r\n}\r\nif (n != t)\r\nbreak;\r\n}\r\nif (done < budget) {\r\nnapi_complete(napi);\r\nif (unlikely(ib_req_notify_cq(priv->recv_cq,\r\nIB_CQ_NEXT_COMP |\r\nIB_CQ_REPORT_MISSED_EVENTS)) &&\r\nnapi_reschedule(napi))\r\ngoto poll_more;\r\n}\r\nreturn done;\r\n}\r\nvoid ipoib_ib_completion(struct ib_cq *cq, void *dev_ptr)\r\n{\r\nstruct net_device *dev = dev_ptr;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nnapi_schedule(&priv->napi);\r\n}\r\nstatic void drain_tx_cq(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nnetif_tx_lock(dev);\r\nwhile (poll_tx(priv))\r\n;\r\nif (netif_queue_stopped(dev))\r\nmod_timer(&priv->poll_timer, jiffies + 1);\r\nnetif_tx_unlock(dev);\r\n}\r\nvoid ipoib_send_comp_handler(struct ib_cq *cq, void *dev_ptr)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev_ptr);\r\nmod_timer(&priv->poll_timer, jiffies);\r\n}\r\nstatic inline int post_send(struct ipoib_dev_priv *priv,\r\nunsigned int wr_id,\r\nstruct ib_ah *address, u32 qpn,\r\nstruct ipoib_tx_buf *tx_req,\r\nvoid *head, int hlen)\r\n{\r\nstruct ib_send_wr *bad_wr;\r\nint i, off;\r\nstruct sk_buff *skb = tx_req->skb;\r\nskb_frag_t *frags = skb_shinfo(skb)->frags;\r\nint nr_frags = skb_shinfo(skb)->nr_frags;\r\nu64 *mapping = tx_req->mapping;\r\nif (skb_headlen(skb)) {\r\npriv->tx_sge[0].addr = mapping[0];\r\npriv->tx_sge[0].length = skb_headlen(skb);\r\noff = 1;\r\n} else\r\noff = 0;\r\nfor (i = 0; i < nr_frags; ++i) {\r\npriv->tx_sge[i + off].addr = mapping[i + off];\r\npriv->tx_sge[i + off].length = skb_frag_size(&frags[i]);\r\n}\r\npriv->tx_wr.num_sge = nr_frags + off;\r\npriv->tx_wr.wr_id = wr_id;\r\npriv->tx_wr.wr.ud.remote_qpn = qpn;\r\npriv->tx_wr.wr.ud.ah = address;\r\nif (head) {\r\npriv->tx_wr.wr.ud.mss = skb_shinfo(skb)->gso_size;\r\npriv->tx_wr.wr.ud.header = head;\r\npriv->tx_wr.wr.ud.hlen = hlen;\r\npriv->tx_wr.opcode = IB_WR_LSO;\r\n} else\r\npriv->tx_wr.opcode = IB_WR_SEND;\r\nreturn ib_post_send(priv->qp, &priv->tx_wr, &bad_wr);\r\n}\r\nvoid ipoib_send(struct net_device *dev, struct sk_buff *skb,\r\nstruct ipoib_ah *address, u32 qpn)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_tx_buf *tx_req;\r\nint hlen, rc;\r\nvoid *phead;\r\nif (skb_is_gso(skb)) {\r\nhlen = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nphead = skb->data;\r\nif (unlikely(!skb_pull(skb, hlen))) {\r\nipoib_warn(priv, "linear data too small\n");\r\n++dev->stats.tx_dropped;\r\n++dev->stats.tx_errors;\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\n} else {\r\nif (unlikely(skb->len > priv->mcast_mtu + IPOIB_ENCAP_LEN)) {\r\nipoib_warn(priv, "packet len %d (> %d) too long to send, dropping\n",\r\nskb->len, priv->mcast_mtu + IPOIB_ENCAP_LEN);\r\n++dev->stats.tx_dropped;\r\n++dev->stats.tx_errors;\r\nipoib_cm_skb_too_long(dev, skb, priv->mcast_mtu);\r\nreturn;\r\n}\r\nphead = NULL;\r\nhlen = 0;\r\n}\r\nipoib_dbg_data(priv, "sending packet, length=%d address=%p qpn=0x%06x\n",\r\nskb->len, address, qpn);\r\ntx_req = &priv->tx_ring[priv->tx_head & (ipoib_sendq_size - 1)];\r\ntx_req->skb = skb;\r\nif (unlikely(ipoib_dma_map_tx(priv->ca, tx_req))) {\r\n++dev->stats.tx_errors;\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\npriv->tx_wr.send_flags |= IB_SEND_IP_CSUM;\r\nelse\r\npriv->tx_wr.send_flags &= ~IB_SEND_IP_CSUM;\r\nif (++priv->tx_outstanding == ipoib_sendq_size) {\r\nipoib_dbg(priv, "TX ring full, stopping kernel net queue\n");\r\nif (ib_req_notify_cq(priv->send_cq, IB_CQ_NEXT_COMP))\r\nipoib_warn(priv, "request notify on send CQ failed\n");\r\nnetif_stop_queue(dev);\r\n}\r\nskb_orphan(skb);\r\nskb_dst_drop(skb);\r\nrc = post_send(priv, priv->tx_head & (ipoib_sendq_size - 1),\r\naddress->ah, qpn, tx_req, phead, hlen);\r\nif (unlikely(rc)) {\r\nipoib_warn(priv, "post_send failed, error %d\n", rc);\r\n++dev->stats.tx_errors;\r\n--priv->tx_outstanding;\r\nipoib_dma_unmap_tx(priv->ca, tx_req);\r\ndev_kfree_skb_any(skb);\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n} else {\r\ndev->trans_start = jiffies;\r\naddress->last_send = priv->tx_head;\r\n++priv->tx_head;\r\n}\r\nif (unlikely(priv->tx_outstanding > MAX_SEND_CQE))\r\nwhile (poll_tx(priv))\r\n;\r\n}\r\nstatic void __ipoib_reap_ah(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_ah *ah, *tah;\r\nLIST_HEAD(remove_list);\r\nunsigned long flags;\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_for_each_entry_safe(ah, tah, &priv->dead_ahs, list)\r\nif ((int) priv->tx_tail - (int) ah->last_send >= 0) {\r\nlist_del(&ah->list);\r\nib_destroy_ah(ah->ah);\r\nkfree(ah);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\n}\r\nvoid ipoib_reap_ah(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, ah_reap_task.work);\r\nstruct net_device *dev = priv->dev;\r\n__ipoib_reap_ah(dev);\r\nif (!test_bit(IPOIB_STOP_REAPER, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue, &priv->ah_reap_task,\r\nround_jiffies_relative(HZ));\r\n}\r\nstatic void ipoib_ib_tx_timer_func(unsigned long ctx)\r\n{\r\ndrain_tx_cq((struct net_device *)ctx);\r\n}\r\nint ipoib_ib_dev_open(struct net_device *dev, int flush)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret;\r\nipoib_pkey_dev_check_presence(dev);\r\nif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags)) {\r\nipoib_warn(priv, "P_Key 0x%04x is %s\n", priv->pkey,\r\n(!(priv->pkey & 0x7fff) ? "Invalid" : "not found"));\r\nreturn -1;\r\n}\r\nret = ipoib_init_qp(dev);\r\nif (ret) {\r\nipoib_warn(priv, "ipoib_init_qp returned %d\n", ret);\r\nreturn -1;\r\n}\r\nret = ipoib_ib_post_receives(dev);\r\nif (ret) {\r\nipoib_warn(priv, "ipoib_ib_post_receives returned %d\n", ret);\r\ngoto dev_stop;\r\n}\r\nret = ipoib_cm_dev_open(dev);\r\nif (ret) {\r\nipoib_warn(priv, "ipoib_cm_dev_open returned %d\n", ret);\r\ngoto dev_stop;\r\n}\r\nclear_bit(IPOIB_STOP_REAPER, &priv->flags);\r\nqueue_delayed_work(ipoib_workqueue, &priv->ah_reap_task,\r\nround_jiffies_relative(HZ));\r\nif (!test_and_set_bit(IPOIB_FLAG_INITIALIZED, &priv->flags))\r\nnapi_enable(&priv->napi);\r\nreturn 0;\r\ndev_stop:\r\nif (!test_and_set_bit(IPOIB_FLAG_INITIALIZED, &priv->flags))\r\nnapi_enable(&priv->napi);\r\nipoib_ib_dev_stop(dev, flush);\r\nreturn -1;\r\n}\r\nvoid ipoib_pkey_dev_check_presence(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nif (!(priv->pkey & 0x7fff) ||\r\nib_find_pkey(priv->ca, priv->port, priv->pkey,\r\n&priv->pkey_index))\r\nclear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\nelse\r\nset_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\n}\r\nint ipoib_ib_dev_up(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_pkey_dev_check_presence(dev);\r\nif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags)) {\r\nipoib_dbg(priv, "PKEY is not assigned.\n");\r\nreturn 0;\r\n}\r\nset_bit(IPOIB_FLAG_OPER_UP, &priv->flags);\r\nreturn ipoib_mcast_start_thread(dev);\r\n}\r\nint ipoib_ib_dev_down(struct net_device *dev, int flush)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg(priv, "downing ib_dev\n");\r\nclear_bit(IPOIB_FLAG_OPER_UP, &priv->flags);\r\nnetif_carrier_off(dev);\r\nipoib_mcast_stop_thread(dev, flush);\r\nipoib_mcast_dev_flush(dev);\r\nipoib_flush_paths(dev);\r\nreturn 0;\r\n}\r\nstatic int recvs_pending(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint pending = 0;\r\nint i;\r\nfor (i = 0; i < ipoib_recvq_size; ++i)\r\nif (priv->rx_ring[i].skb)\r\n++pending;\r\nreturn pending;\r\n}\r\nvoid ipoib_drain_cq(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint i, n;\r\nlocal_bh_disable();\r\ndo {\r\nn = ib_poll_cq(priv->recv_cq, IPOIB_NUM_WC, priv->ibwc);\r\nfor (i = 0; i < n; ++i) {\r\nif (priv->ibwc[i].status == IB_WC_SUCCESS)\r\npriv->ibwc[i].status = IB_WC_WR_FLUSH_ERR;\r\nif (priv->ibwc[i].wr_id & IPOIB_OP_RECV) {\r\nif (priv->ibwc[i].wr_id & IPOIB_OP_CM)\r\nipoib_cm_handle_rx_wc(dev, priv->ibwc + i);\r\nelse\r\nipoib_ib_handle_rx_wc(dev, priv->ibwc + i);\r\n} else\r\nipoib_cm_handle_tx_wc(dev, priv->ibwc + i);\r\n}\r\n} while (n == IPOIB_NUM_WC);\r\nwhile (poll_tx(priv))\r\n;\r\nlocal_bh_enable();\r\n}\r\nint ipoib_ib_dev_stop(struct net_device *dev, int flush)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_attr qp_attr;\r\nunsigned long begin;\r\nstruct ipoib_tx_buf *tx_req;\r\nint i;\r\nif (test_and_clear_bit(IPOIB_FLAG_INITIALIZED, &priv->flags))\r\nnapi_disable(&priv->napi);\r\nipoib_cm_dev_stop(dev);\r\nqp_attr.qp_state = IB_QPS_ERR;\r\nif (ib_modify_qp(priv->qp, &qp_attr, IB_QP_STATE))\r\nipoib_warn(priv, "Failed to modify QP to ERROR state\n");\r\nbegin = jiffies;\r\nwhile (priv->tx_head != priv->tx_tail || recvs_pending(dev)) {\r\nif (time_after(jiffies, begin + 5 * HZ)) {\r\nipoib_warn(priv, "timing out; %d sends %d receives not completed\n",\r\npriv->tx_head - priv->tx_tail, recvs_pending(dev));\r\nwhile ((int) priv->tx_tail - (int) priv->tx_head < 0) {\r\ntx_req = &priv->tx_ring[priv->tx_tail &\r\n(ipoib_sendq_size - 1)];\r\nipoib_dma_unmap_tx(priv->ca, tx_req);\r\ndev_kfree_skb_any(tx_req->skb);\r\n++priv->tx_tail;\r\n--priv->tx_outstanding;\r\n}\r\nfor (i = 0; i < ipoib_recvq_size; ++i) {\r\nstruct ipoib_rx_buf *rx_req;\r\nrx_req = &priv->rx_ring[i];\r\nif (!rx_req->skb)\r\ncontinue;\r\nipoib_ud_dma_unmap_rx(priv,\r\npriv->rx_ring[i].mapping);\r\ndev_kfree_skb_any(rx_req->skb);\r\nrx_req->skb = NULL;\r\n}\r\ngoto timeout;\r\n}\r\nipoib_drain_cq(dev);\r\nmsleep(1);\r\n}\r\nipoib_dbg(priv, "All sends and receives done.\n");\r\ntimeout:\r\ndel_timer_sync(&priv->poll_timer);\r\nqp_attr.qp_state = IB_QPS_RESET;\r\nif (ib_modify_qp(priv->qp, &qp_attr, IB_QP_STATE))\r\nipoib_warn(priv, "Failed to modify QP to RESET state\n");\r\nset_bit(IPOIB_STOP_REAPER, &priv->flags);\r\ncancel_delayed_work(&priv->ah_reap_task);\r\nif (flush)\r\nflush_workqueue(ipoib_workqueue);\r\nbegin = jiffies;\r\nwhile (!list_empty(&priv->dead_ahs)) {\r\n__ipoib_reap_ah(dev);\r\nif (time_after(jiffies, begin + HZ)) {\r\nipoib_warn(priv, "timing out; will leak address handles\n");\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nib_req_notify_cq(priv->recv_cq, IB_CQ_NEXT_COMP);\r\nreturn 0;\r\n}\r\nint ipoib_ib_dev_init(struct net_device *dev, struct ib_device *ca, int port)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\npriv->ca = ca;\r\npriv->port = port;\r\npriv->qp = NULL;\r\nif (ipoib_transport_dev_init(dev, ca)) {\r\nprintk(KERN_WARNING "%s: ipoib_transport_dev_init failed\n", ca->name);\r\nreturn -ENODEV;\r\n}\r\nsetup_timer(&priv->poll_timer, ipoib_ib_tx_timer_func,\r\n(unsigned long) dev);\r\nif (dev->flags & IFF_UP) {\r\nif (ipoib_ib_dev_open(dev, 1)) {\r\nipoib_transport_dev_cleanup(dev);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int update_parent_pkey(struct ipoib_dev_priv *priv)\r\n{\r\nint result;\r\nu16 prev_pkey;\r\nprev_pkey = priv->pkey;\r\nresult = ib_query_pkey(priv->ca, priv->port, 0, &priv->pkey);\r\nif (result) {\r\nipoib_warn(priv, "ib_query_pkey port %d failed (ret = %d)\n",\r\npriv->port, result);\r\nreturn result;\r\n}\r\npriv->pkey |= 0x8000;\r\nif (prev_pkey != priv->pkey) {\r\nipoib_dbg(priv, "pkey changed from 0x%x to 0x%x\n",\r\nprev_pkey, priv->pkey);\r\npriv->dev->broadcast[8] = priv->pkey >> 8;\r\npriv->dev->broadcast[9] = priv->pkey & 0xff;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int update_child_pkey(struct ipoib_dev_priv *priv)\r\n{\r\nu16 old_index = priv->pkey_index;\r\npriv->pkey_index = 0;\r\nipoib_pkey_dev_check_presence(priv->dev);\r\nif (test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags) &&\r\n(old_index == priv->pkey_index))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv,\r\nenum ipoib_flush_level level)\r\n{\r\nstruct ipoib_dev_priv *cpriv;\r\nstruct net_device *dev = priv->dev;\r\nint result;\r\ndown_read(&priv->vlan_rwsem);\r\nlist_for_each_entry(cpriv, &priv->child_intfs, list)\r\n__ipoib_ib_dev_flush(cpriv, level);\r\nup_read(&priv->vlan_rwsem);\r\nif (!test_bit(IPOIB_FLAG_INITIALIZED, &priv->flags) &&\r\nlevel != IPOIB_FLUSH_HEAVY) {\r\nipoib_dbg(priv, "Not flushing - IPOIB_FLAG_INITIALIZED not set.\n");\r\nreturn;\r\n}\r\nif (!test_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags)) {\r\nif (level == IPOIB_FLUSH_HEAVY) {\r\nif (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags))\r\nupdate_parent_pkey(priv);\r\nelse\r\nupdate_child_pkey(priv);\r\n}\r\nipoib_dbg(priv, "Not flushing - IPOIB_FLAG_ADMIN_UP not set.\n");\r\nreturn;\r\n}\r\nif (level == IPOIB_FLUSH_HEAVY) {\r\nif (test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags)) {\r\nresult = update_child_pkey(priv);\r\nif (result) {\r\nipoib_dbg(priv, "Not flushing - P_Key index not changed.\n");\r\nreturn;\r\n}\r\n} else {\r\nresult = update_parent_pkey(priv);\r\nif (result) {\r\nipoib_dbg(priv, "Not flushing - P_Key value not changed.\n");\r\nreturn;\r\n}\r\n}\r\n}\r\nif (level == IPOIB_FLUSH_LIGHT) {\r\nipoib_mark_paths_invalid(dev);\r\nipoib_mcast_dev_flush(dev);\r\n}\r\nif (level >= IPOIB_FLUSH_NORMAL)\r\nipoib_ib_dev_down(dev, 0);\r\nif (level == IPOIB_FLUSH_HEAVY) {\r\nif (test_bit(IPOIB_FLAG_INITIALIZED, &priv->flags))\r\nipoib_ib_dev_stop(dev, 0);\r\nif (ipoib_ib_dev_open(dev, 0) != 0)\r\nreturn;\r\nif (netif_queue_stopped(dev))\r\nnetif_start_queue(dev);\r\n}\r\nif (test_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags)) {\r\nif (level >= IPOIB_FLUSH_NORMAL)\r\nipoib_ib_dev_up(dev);\r\nipoib_mcast_restart_task(&priv->restart_task);\r\n}\r\n}\r\nvoid ipoib_ib_dev_flush_light(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, flush_light);\r\n__ipoib_ib_dev_flush(priv, IPOIB_FLUSH_LIGHT);\r\n}\r\nvoid ipoib_ib_dev_flush_normal(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, flush_normal);\r\n__ipoib_ib_dev_flush(priv, IPOIB_FLUSH_NORMAL);\r\n}\r\nvoid ipoib_ib_dev_flush_heavy(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, flush_heavy);\r\n__ipoib_ib_dev_flush(priv, IPOIB_FLUSH_HEAVY);\r\n}\r\nvoid ipoib_ib_dev_cleanup(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg(priv, "cleaning up ib_dev\n");\r\nipoib_flush_paths(dev);\r\nipoib_mcast_stop_thread(dev, 1);\r\nipoib_mcast_dev_flush(dev);\r\nipoib_transport_dev_cleanup(dev);\r\n}
