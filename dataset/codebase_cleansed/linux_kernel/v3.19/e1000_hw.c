static s32 e1000_set_phy_type(struct e1000_hw *hw)\r\n{\r\nif (hw->mac_type == e1000_undefined)\r\nreturn -E1000_ERR_PHY_TYPE;\r\nswitch (hw->phy_id) {\r\ncase M88E1000_E_PHY_ID:\r\ncase M88E1000_I_PHY_ID:\r\ncase M88E1011_I_PHY_ID:\r\ncase M88E1111_I_PHY_ID:\r\ncase M88E1118_E_PHY_ID:\r\nhw->phy_type = e1000_phy_m88;\r\nbreak;\r\ncase IGP01E1000_I_PHY_ID:\r\nif (hw->mac_type == e1000_82541 ||\r\nhw->mac_type == e1000_82541_rev_2 ||\r\nhw->mac_type == e1000_82547 ||\r\nhw->mac_type == e1000_82547_rev_2)\r\nhw->phy_type = e1000_phy_igp;\r\nbreak;\r\ncase RTL8211B_PHY_ID:\r\nhw->phy_type = e1000_phy_8211;\r\nbreak;\r\ncase RTL8201N_PHY_ID:\r\nhw->phy_type = e1000_phy_8201;\r\nbreak;\r\ndefault:\r\nhw->phy_type = e1000_phy_undefined;\r\nreturn -E1000_ERR_PHY_TYPE;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic void e1000_phy_init_script(struct e1000_hw *hw)\r\n{\r\nu32 ret_val;\r\nu16 phy_saved_data;\r\nif (hw->phy_init_script) {\r\nmsleep(20);\r\nret_val = e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\r\ne1000_write_phy_reg(hw, 0x2F5B, 0x0003);\r\nmsleep(20);\r\ne1000_write_phy_reg(hw, 0x0000, 0x0140);\r\nmsleep(5);\r\nswitch (hw->mac_type) {\r\ncase e1000_82541:\r\ncase e1000_82547:\r\ne1000_write_phy_reg(hw, 0x1F95, 0x0001);\r\ne1000_write_phy_reg(hw, 0x1F71, 0xBD21);\r\ne1000_write_phy_reg(hw, 0x1F79, 0x0018);\r\ne1000_write_phy_reg(hw, 0x1F30, 0x1600);\r\ne1000_write_phy_reg(hw, 0x1F31, 0x0014);\r\ne1000_write_phy_reg(hw, 0x1F32, 0x161C);\r\ne1000_write_phy_reg(hw, 0x1F94, 0x0003);\r\ne1000_write_phy_reg(hw, 0x1F96, 0x003F);\r\ne1000_write_phy_reg(hw, 0x2010, 0x0008);\r\nbreak;\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547_rev_2:\r\ne1000_write_phy_reg(hw, 0x1F73, 0x0099);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ne1000_write_phy_reg(hw, 0x0000, 0x3300);\r\nmsleep(20);\r\ne1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\r\nif (hw->mac_type == e1000_82547) {\r\nu16 fused, fine, coarse;\r\ne1000_read_phy_reg(hw,\r\nIGP01E1000_ANALOG_SPARE_FUSE_STATUS,\r\n&fused);\r\nif (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {\r\ne1000_read_phy_reg(hw,\r\nIGP01E1000_ANALOG_FUSE_STATUS,\r\n&fused);\r\nfine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;\r\ncoarse =\r\nfused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;\r\nif (coarse >\r\nIGP01E1000_ANALOG_FUSE_COARSE_THRESH) {\r\ncoarse -=\r\nIGP01E1000_ANALOG_FUSE_COARSE_10;\r\nfine -= IGP01E1000_ANALOG_FUSE_FINE_1;\r\n} else if (coarse ==\r\nIGP01E1000_ANALOG_FUSE_COARSE_THRESH)\r\nfine -= IGP01E1000_ANALOG_FUSE_FINE_10;\r\nfused =\r\n(fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |\r\n(fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |\r\n(coarse &\r\nIGP01E1000_ANALOG_FUSE_COARSE_MASK);\r\ne1000_write_phy_reg(hw,\r\nIGP01E1000_ANALOG_FUSE_CONTROL,\r\nfused);\r\ne1000_write_phy_reg(hw,\r\nIGP01E1000_ANALOG_FUSE_BYPASS,\r\nIGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);\r\n}\r\n}\r\n}\r\n}\r\ns32 e1000_set_mac_type(struct e1000_hw *hw)\r\n{\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82542:\r\nswitch (hw->revision_id) {\r\ncase E1000_82542_2_0_REV_ID:\r\nhw->mac_type = e1000_82542_rev2_0;\r\nbreak;\r\ncase E1000_82542_2_1_REV_ID:\r\nhw->mac_type = e1000_82542_rev2_1;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_MAC_TYPE;\r\n}\r\nbreak;\r\ncase E1000_DEV_ID_82543GC_FIBER:\r\ncase E1000_DEV_ID_82543GC_COPPER:\r\nhw->mac_type = e1000_82543;\r\nbreak;\r\ncase E1000_DEV_ID_82544EI_COPPER:\r\ncase E1000_DEV_ID_82544EI_FIBER:\r\ncase E1000_DEV_ID_82544GC_COPPER:\r\ncase E1000_DEV_ID_82544GC_LOM:\r\nhw->mac_type = e1000_82544;\r\nbreak;\r\ncase E1000_DEV_ID_82540EM:\r\ncase E1000_DEV_ID_82540EM_LOM:\r\ncase E1000_DEV_ID_82540EP:\r\ncase E1000_DEV_ID_82540EP_LOM:\r\ncase E1000_DEV_ID_82540EP_LP:\r\nhw->mac_type = e1000_82540;\r\nbreak;\r\ncase E1000_DEV_ID_82545EM_COPPER:\r\ncase E1000_DEV_ID_82545EM_FIBER:\r\nhw->mac_type = e1000_82545;\r\nbreak;\r\ncase E1000_DEV_ID_82545GM_COPPER:\r\ncase E1000_DEV_ID_82545GM_FIBER:\r\ncase E1000_DEV_ID_82545GM_SERDES:\r\nhw->mac_type = e1000_82545_rev_3;\r\nbreak;\r\ncase E1000_DEV_ID_82546EB_COPPER:\r\ncase E1000_DEV_ID_82546EB_FIBER:\r\ncase E1000_DEV_ID_82546EB_QUAD_COPPER:\r\nhw->mac_type = e1000_82546;\r\nbreak;\r\ncase E1000_DEV_ID_82546GB_COPPER:\r\ncase E1000_DEV_ID_82546GB_FIBER:\r\ncase E1000_DEV_ID_82546GB_SERDES:\r\ncase E1000_DEV_ID_82546GB_PCIE:\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER:\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\r\nhw->mac_type = e1000_82546_rev_3;\r\nbreak;\r\ncase E1000_DEV_ID_82541EI:\r\ncase E1000_DEV_ID_82541EI_MOBILE:\r\ncase E1000_DEV_ID_82541ER_LOM:\r\nhw->mac_type = e1000_82541;\r\nbreak;\r\ncase E1000_DEV_ID_82541ER:\r\ncase E1000_DEV_ID_82541GI:\r\ncase E1000_DEV_ID_82541GI_LF:\r\ncase E1000_DEV_ID_82541GI_MOBILE:\r\nhw->mac_type = e1000_82541_rev_2;\r\nbreak;\r\ncase E1000_DEV_ID_82547EI:\r\ncase E1000_DEV_ID_82547EI_MOBILE:\r\nhw->mac_type = e1000_82547;\r\nbreak;\r\ncase E1000_DEV_ID_82547GI:\r\nhw->mac_type = e1000_82547_rev_2;\r\nbreak;\r\ncase E1000_DEV_ID_INTEL_CE4100_GBE:\r\nhw->mac_type = e1000_ce4100;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_MAC_TYPE;\r\n}\r\nswitch (hw->mac_type) {\r\ncase e1000_82541:\r\ncase e1000_82547:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547_rev_2:\r\nhw->asf_firmware_present = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw->mac_type == e1000_82543)\r\nhw->bad_tx_carr_stats_fd = true;\r\nif (hw->mac_type > e1000_82544)\r\nhw->has_smbus = true;\r\nreturn E1000_SUCCESS;\r\n}\r\nvoid e1000_set_media_type(struct e1000_hw *hw)\r\n{\r\nu32 status;\r\nif (hw->mac_type != e1000_82543) {\r\nhw->tbi_compatibility_en = false;\r\n}\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82545GM_SERDES:\r\ncase E1000_DEV_ID_82546GB_SERDES:\r\nhw->media_type = e1000_media_type_internal_serdes;\r\nbreak;\r\ndefault:\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\nhw->media_type = e1000_media_type_fiber;\r\nbreak;\r\ncase e1000_ce4100:\r\nhw->media_type = e1000_media_type_copper;\r\nbreak;\r\ndefault:\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_TBIMODE) {\r\nhw->media_type = e1000_media_type_fiber;\r\nhw->tbi_compatibility_en = false;\r\n} else {\r\nhw->media_type = e1000_media_type_copper;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\ns32 e1000_reset_hw(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nu32 ctrl_ext;\r\nu32 icr;\r\nu32 manc;\r\nu32 led_ctrl;\r\ns32 ret_val;\r\nif (hw->mac_type == e1000_82542_rev2_0) {\r\ne_dbg("Disabling MWI on 82542 rev 2.0\n");\r\ne1000_pci_clear_mwi(hw);\r\n}\r\ne_dbg("Masking off all interrupts\n");\r\new32(IMC, 0xffffffff);\r\new32(RCTL, 0);\r\new32(TCTL, E1000_TCTL_PSP);\r\nE1000_WRITE_FLUSH();\r\nhw->tbi_compatibility_on = false;\r\nmsleep(10);\r\nctrl = er32(CTRL);\r\nif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\r\new32(CTRL, (ctrl | E1000_CTRL_PHY_RST));\r\nE1000_WRITE_FLUSH();\r\nmsleep(5);\r\n}\r\ne_dbg("Issuing a global reset to MAC\n");\r\nswitch (hw->mac_type) {\r\ncase e1000_82544:\r\ncase e1000_82540:\r\ncase e1000_82545:\r\ncase e1000_82546:\r\ncase e1000_82541:\r\ncase e1000_82541_rev_2:\r\nE1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));\r\nbreak;\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\new32(CTRL_DUP, (ctrl | E1000_CTRL_RST));\r\nbreak;\r\ncase e1000_ce4100:\r\ndefault:\r\new32(CTRL, (ctrl | E1000_CTRL_RST));\r\nbreak;\r\n}\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\ncase e1000_82544:\r\nudelay(10);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_EE_RST;\r\new32(CTRL_EXT, ctrl_ext);\r\nE1000_WRITE_FLUSH();\r\nmsleep(2);\r\nbreak;\r\ncase e1000_82541:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547:\r\ncase e1000_82547_rev_2:\r\nmsleep(20);\r\nbreak;\r\ndefault:\r\nret_val = e1000_get_auto_rd_done(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\n}\r\nif (hw->mac_type >= e1000_82540) {\r\nmanc = er32(MANC);\r\nmanc &= ~(E1000_MANC_ARP_EN);\r\new32(MANC, manc);\r\n}\r\nif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\r\ne1000_phy_init_script(hw);\r\nled_ctrl = er32(LEDCTL);\r\nled_ctrl &= IGP_ACTIVITY_LED_MASK;\r\nled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\r\new32(LEDCTL, led_ctrl);\r\n}\r\ne_dbg("Masking off all interrupts\n");\r\new32(IMC, 0xffffffff);\r\nicr = er32(ICR);\r\nif (hw->mac_type == e1000_82542_rev2_0) {\r\nif (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)\r\ne1000_pci_set_mwi(hw);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_init_hw(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nu32 i;\r\ns32 ret_val;\r\nu32 mta_size;\r\nu32 ctrl_ext;\r\nret_val = e1000_id_led_init(hw);\r\nif (ret_val) {\r\ne_dbg("Error Initializing Identification LED\n");\r\nreturn ret_val;\r\n}\r\ne1000_set_media_type(hw);\r\ne_dbg("Initializing the IEEE VLAN\n");\r\nif (hw->mac_type < e1000_82545_rev_3)\r\new32(VET, 0);\r\ne1000_clear_vfta(hw);\r\nif (hw->mac_type == e1000_82542_rev2_0) {\r\ne_dbg("Disabling MWI on 82542 rev 2.0\n");\r\ne1000_pci_clear_mwi(hw);\r\new32(RCTL, E1000_RCTL_RST);\r\nE1000_WRITE_FLUSH();\r\nmsleep(5);\r\n}\r\ne1000_init_rx_addrs(hw);\r\nif (hw->mac_type == e1000_82542_rev2_0) {\r\new32(RCTL, 0);\r\nE1000_WRITE_FLUSH();\r\nmsleep(1);\r\nif (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)\r\ne1000_pci_set_mwi(hw);\r\n}\r\ne_dbg("Zeroing the MTA\n");\r\nmta_size = E1000_MC_TBL_SIZE;\r\nfor (i = 0; i < mta_size; i++) {\r\nE1000_WRITE_REG_ARRAY(hw, MTA, i, 0);\r\nE1000_WRITE_FLUSH();\r\n}\r\nif (hw->dma_fairness && hw->mac_type <= e1000_82543) {\r\nctrl = er32(CTRL);\r\new32(CTRL, ctrl | E1000_CTRL_PRIOR);\r\n}\r\nswitch (hw->mac_type) {\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\nbreak;\r\ndefault:\r\nif (hw->bus_type == e1000_bus_type_pcix\r\n&& e1000_pcix_get_mmrbc(hw) > 2048)\r\ne1000_pcix_set_mmrbc(hw, 2048);\r\nbreak;\r\n}\r\nret_val = e1000_setup_link(hw);\r\nif (hw->mac_type > e1000_82544) {\r\nctrl = er32(TXDCTL);\r\nctrl =\r\n(ctrl & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB;\r\new32(TXDCTL, ctrl);\r\n}\r\ne1000_clear_hw_cntrs(hw);\r\nif (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||\r\nhw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3) {\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_RO_DIS;\r\new32(CTRL_EXT, ctrl_ext);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw)\r\n{\r\nu16 eeprom_data;\r\ns32 ret_val;\r\nif (hw->media_type != e1000_media_type_internal_serdes)\r\nreturn E1000_SUCCESS;\r\nswitch (hw->mac_type) {\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\nbreak;\r\ndefault:\r\nreturn E1000_SUCCESS;\r\n}\r\nret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,\r\n&eeprom_data);\r\nif (ret_val) {\r\nreturn ret_val;\r\n}\r\nif (eeprom_data != EEPROM_RESERVED_WORD) {\r\neeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_setup_link(struct e1000_hw *hw)\r\n{\r\nu32 ctrl_ext;\r\ns32 ret_val;\r\nu16 eeprom_data;\r\nif (hw->fc == E1000_FC_DEFAULT) {\r\nret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,\r\n1, &eeprom_data);\r\nif (ret_val) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nif ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)\r\nhw->fc = E1000_FC_NONE;\r\nelse if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==\r\nEEPROM_WORD0F_ASM_DIR)\r\nhw->fc = E1000_FC_TX_PAUSE;\r\nelse\r\nhw->fc = E1000_FC_FULL;\r\n}\r\nif (hw->mac_type == e1000_82542_rev2_0)\r\nhw->fc &= (~E1000_FC_TX_PAUSE);\r\nif ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))\r\nhw->fc &= (~E1000_FC_RX_PAUSE);\r\nhw->original_fc = hw->fc;\r\ne_dbg("After fix-ups FlowControl is now = %x\n", hw->fc);\r\nif (hw->mac_type == e1000_82543) {\r\nret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,\r\n1, &eeprom_data);\r\nif (ret_val) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<\r\nSWDPIO__EXT_SHIFT);\r\new32(CTRL_EXT, ctrl_ext);\r\n}\r\nret_val = (hw->media_type == e1000_media_type_copper) ?\r\ne1000_setup_copper_link(hw) : e1000_setup_fiber_serdes_link(hw);\r\ne_dbg("Initializing the Flow Control address, type and timer regs\n");\r\new32(FCT, FLOW_CONTROL_TYPE);\r\new32(FCAH, FLOW_CONTROL_ADDRESS_HIGH);\r\new32(FCAL, FLOW_CONTROL_ADDRESS_LOW);\r\new32(FCTTV, hw->fc_pause_time);\r\nif (!(hw->fc & E1000_FC_TX_PAUSE)) {\r\new32(FCRTL, 0);\r\new32(FCRTH, 0);\r\n} else {\r\nif (hw->fc_send_xon) {\r\new32(FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));\r\new32(FCRTH, hw->fc_high_water);\r\n} else {\r\new32(FCRTL, hw->fc_low_water);\r\new32(FCRTH, hw->fc_high_water);\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nu32 status;\r\nu32 txcw = 0;\r\nu32 i;\r\nu32 signal = 0;\r\ns32 ret_val;\r\nctrl = er32(CTRL);\r\nif (hw->media_type == e1000_media_type_fiber)\r\nsignal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;\r\nret_val = e1000_adjust_serdes_amplitude(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nctrl &= ~(E1000_CTRL_LRST);\r\nret_val = e1000_set_vco_speed(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ne1000_config_collision_dist(hw);\r\nswitch (hw->fc) {\r\ncase E1000_FC_NONE:\r\ntxcw = (E1000_TXCW_ANE | E1000_TXCW_FD);\r\nbreak;\r\ncase E1000_FC_RX_PAUSE:\r\ntxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\r\nbreak;\r\ncase E1000_FC_TX_PAUSE:\r\ntxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);\r\nbreak;\r\ncase E1000_FC_FULL:\r\ntxcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);\r\nbreak;\r\ndefault:\r\ne_dbg("Flow control param set incorrectly\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\ne_dbg("Auto-negotiation enabled\n");\r\new32(TXCW, txcw);\r\new32(CTRL, ctrl);\r\nE1000_WRITE_FLUSH();\r\nhw->txcw = txcw;\r\nmsleep(1);\r\nif (hw->media_type == e1000_media_type_internal_serdes ||\r\n(er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {\r\ne_dbg("Looking for Link\n");\r\nfor (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {\r\nmsleep(10);\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_LU)\r\nbreak;\r\n}\r\nif (i == (LINK_UP_TIMEOUT / 10)) {\r\ne_dbg("Never got a valid link from auto-neg!!!\n");\r\nhw->autoneg_failed = 1;\r\nret_val = e1000_check_for_link(hw);\r\nif (ret_val) {\r\ne_dbg("Error while checking for link\n");\r\nreturn ret_val;\r\n}\r\nhw->autoneg_failed = 0;\r\n} else {\r\nhw->autoneg_failed = 0;\r\ne_dbg("Valid Link Found\n");\r\n}\r\n} else {\r\ne_dbg("No Signal Detected\n");\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_rtl_setup(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_phy_reset(hw);\r\nif (ret_val) {\r\ne_dbg("Error Resetting the PHY\n");\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 gbe_dhg_phy_setup(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu32 ctrl_aux;\r\nswitch (hw->phy_type) {\r\ncase e1000_phy_8211:\r\nret_val = e1000_copper_link_rtl_setup(hw);\r\nif (ret_val) {\r\ne_dbg("e1000_copper_link_rtl_setup failed!\n");\r\nreturn ret_val;\r\n}\r\nbreak;\r\ncase e1000_phy_8201:\r\nctrl_aux = er32(CTL_AUX);\r\nctrl_aux |= E1000_CTL_AUX_RMII;\r\new32(CTL_AUX, ctrl_aux);\r\nE1000_WRITE_FLUSH();\r\nctrl_aux = er32(CTL_AUX);\r\nctrl_aux |= 0x4;\r\nctrl_aux &= ~0x2;\r\new32(CTL_AUX, ctrl_aux);\r\nE1000_WRITE_FLUSH();\r\nret_val = e1000_copper_link_rtl_setup(hw);\r\nif (ret_val) {\r\ne_dbg("e1000_copper_link_rtl_setup failed!\n");\r\nreturn ret_val;\r\n}\r\nbreak;\r\ndefault:\r\ne_dbg("Error Resetting the PHY\n");\r\nreturn E1000_ERR_PHY_TYPE;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_preconfig(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 phy_data;\r\nctrl = er32(CTRL);\r\nif (hw->mac_type > e1000_82543) {\r\nctrl |= E1000_CTRL_SLU;\r\nctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\new32(CTRL, ctrl);\r\n} else {\r\nctrl |=\r\n(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);\r\new32(CTRL, ctrl);\r\nret_val = e1000_phy_hw_reset(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000_detect_gig_phy(hw);\r\nif (ret_val) {\r\ne_dbg("Error, did not detect valid phy.\n");\r\nreturn ret_val;\r\n}\r\ne_dbg("Phy ID = %x\n", hw->phy_id);\r\nret_val = e1000_set_phy_mode(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((hw->mac_type == e1000_82545_rev_3) ||\r\n(hw->mac_type == e1000_82546_rev_3)) {\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nphy_data |= 0x00000008;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\r\n}\r\nif (hw->mac_type <= e1000_82543 ||\r\nhw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||\r\nhw->mac_type == e1000_82541_rev_2\r\n|| hw->mac_type == e1000_82547_rev_2)\r\nhw->phy_reset_disable = false;\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_igp_setup(struct e1000_hw *hw)\r\n{\r\nu32 led_ctrl;\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->phy_reset_disable)\r\nreturn E1000_SUCCESS;\r\nret_val = e1000_phy_reset(hw);\r\nif (ret_val) {\r\ne_dbg("Error Resetting the PHY\n");\r\nreturn ret_val;\r\n}\r\nmsleep(15);\r\nled_ctrl = er32(LEDCTL);\r\nled_ctrl &= IGP_ACTIVITY_LED_MASK;\r\nled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\r\new32(LEDCTL, led_ctrl);\r\nif (hw->phy_type == e1000_phy_igp) {\r\nret_val = e1000_set_d3_lplu_state(hw, false);\r\nif (ret_val) {\r\ne_dbg("Error Disabling LPLU D3\n");\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\r\nhw->dsp_config_state = e1000_dsp_config_disabled;\r\nphy_data &=\r\n~(IGP01E1000_PSCR_AUTO_MDIX |\r\nIGP01E1000_PSCR_FORCE_MDI_MDIX);\r\nhw->mdix = 1;\r\n} else {\r\nhw->dsp_config_state = e1000_dsp_config_enabled;\r\nphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\r\nswitch (hw->mdix) {\r\ncase 1:\r\nphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\r\nbreak;\r\ncase 2:\r\nphy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nphy_data |= IGP01E1000_PSCR_AUTO_MDIX;\r\nbreak;\r\n}\r\n}\r\nret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->autoneg) {\r\ne1000_ms_type phy_ms_setting = hw->master_slave;\r\nif (hw->ffe_config_state == e1000_ffe_config_active)\r\nhw->ffe_config_state = e1000_ffe_config_enabled;\r\nif (hw->dsp_config_state == e1000_dsp_config_activated)\r\nhw->dsp_config_state = e1000_dsp_config_enabled;\r\nif (hw->autoneg_advertised == ADVERTISE_1000_FULL) {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~CR_1000T_MS_ENABLE;\r\nret_val =\r\ne1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?\r\n((phy_data & CR_1000T_MS_VALUE) ?\r\ne1000_ms_force_master :\r\ne1000_ms_force_slave) : e1000_ms_auto;\r\nswitch (phy_ms_setting) {\r\ncase e1000_ms_force_master:\r\nphy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);\r\nbreak;\r\ncase e1000_ms_force_slave:\r\nphy_data |= CR_1000T_MS_ENABLE;\r\nphy_data &= ~(CR_1000T_MS_VALUE);\r\nbreak;\r\ncase e1000_ms_auto:\r\nphy_data &= ~CR_1000T_MS_ENABLE;\r\ndefault:\r\nbreak;\r\n}\r\nret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_mgp_setup(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->phy_reset_disable)\r\nreturn E1000_SUCCESS;\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\r\nphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\r\nswitch (hw->mdix) {\r\ncase 1:\r\nphy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;\r\nbreak;\r\ncase 2:\r\nphy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;\r\nbreak;\r\ncase 3:\r\nphy_data |= M88E1000_PSCR_AUTO_X_1000T;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nphy_data |= M88E1000_PSCR_AUTO_X_MODE;\r\nbreak;\r\n}\r\nphy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;\r\nif (hw->disable_polarity_correction == 1)\r\nphy_data |= M88E1000_PSCR_POLARITY_REVERSAL;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->phy_revision < M88E1011_I_REV_4) {\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= M88E1000_EPSCR_TX_CLK_25;\r\nif ((hw->phy_revision == E1000_REVISION_2) &&\r\n(hw->phy_id == M88E1111_I_PHY_ID)) {\r\nphy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);\r\nphy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;\r\nret_val = e1000_write_phy_reg(hw,\r\nM88E1000_EXT_PHY_SPEC_CTRL,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else {\r\nphy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |\r\nM88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);\r\nphy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |\r\nM88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);\r\nret_val = e1000_write_phy_reg(hw,\r\nM88E1000_EXT_PHY_SPEC_CTRL,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_phy_reset(hw);\r\nif (ret_val) {\r\ne_dbg("Error Resetting the PHY\n");\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_autoneg(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nhw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nif (hw->autoneg_advertised == 0)\r\nhw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nif (hw->phy_type == e1000_phy_8201)\r\nhw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;\r\ne_dbg("Reconfiguring auto-neg advertisement params\n");\r\nret_val = e1000_phy_setup_autoneg(hw);\r\nif (ret_val) {\r\ne_dbg("Error Setting up Auto-Negotiation\n");\r\nreturn ret_val;\r\n}\r\ne_dbg("Restarting Auto-Neg\n");\r\nret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);\r\nret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->wait_autoneg_complete) {\r\nret_val = e1000_wait_autoneg(hw);\r\nif (ret_val) {\r\ne_dbg\r\n("Error while waiting for autoneg to complete\n");\r\nreturn ret_val;\r\n}\r\n}\r\nhw->get_link_status = true;\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_copper_link_postconfig(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nif ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100)) {\r\ne1000_config_collision_dist(hw);\r\n} else {\r\nret_val = e1000_config_mac_to_phy(hw);\r\nif (ret_val) {\r\ne_dbg("Error configuring MAC to PHY settings\n");\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_config_fc_after_link_up(hw);\r\nif (ret_val) {\r\ne_dbg("Error Configuring Flow Control\n");\r\nreturn ret_val;\r\n}\r\nif (hw->phy_type == e1000_phy_igp) {\r\nret_val = e1000_config_dsp_after_link_change(hw, true);\r\nif (ret_val) {\r\ne_dbg("Error Configuring DSP after link up\n");\r\nreturn ret_val;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_setup_copper_link(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nu16 phy_data;\r\nret_val = e1000_copper_link_preconfig(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->phy_type == e1000_phy_igp) {\r\nret_val = e1000_copper_link_igp_setup(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if (hw->phy_type == e1000_phy_m88) {\r\nret_val = e1000_copper_link_mgp_setup(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else {\r\nret_val = gbe_dhg_phy_setup(hw);\r\nif (ret_val) {\r\ne_dbg("gbe_dhg_phy_setup failed!\n");\r\nreturn ret_val;\r\n}\r\n}\r\nif (hw->autoneg) {\r\nret_val = e1000_copper_link_autoneg(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else {\r\ne_dbg("Forcing speed and duplex\n");\r\nret_val = e1000_phy_force_speed_duplex(hw);\r\nif (ret_val) {\r\ne_dbg("Error Forcing Speed and Duplex\n");\r\nreturn ret_val;\r\n}\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (phy_data & MII_SR_LINK_STATUS) {\r\nret_val = e1000_copper_link_postconfig(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ne_dbg("Valid link established!!!\n");\r\nreturn E1000_SUCCESS;\r\n}\r\nudelay(10);\r\n}\r\ne_dbg("Unable to establish link!!!\n");\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_phy_setup_autoneg(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 mii_autoneg_adv_reg;\r\nu16 mii_1000t_ctrl_reg;\r\nret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nelse if (hw->phy_type == e1000_phy_8201)\r\nmii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;\r\nmii_autoneg_adv_reg &= ~REG4_SPEED_MASK;\r\nmii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;\r\ne_dbg("autoneg_advertised %x\n", hw->autoneg_advertised);\r\nif (hw->autoneg_advertised & ADVERTISE_10_HALF) {\r\ne_dbg("Advertise 10mb Half duplex\n");\r\nmii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;\r\n}\r\nif (hw->autoneg_advertised & ADVERTISE_10_FULL) {\r\ne_dbg("Advertise 10mb Full duplex\n");\r\nmii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;\r\n}\r\nif (hw->autoneg_advertised & ADVERTISE_100_HALF) {\r\ne_dbg("Advertise 100mb Half duplex\n");\r\nmii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;\r\n}\r\nif (hw->autoneg_advertised & ADVERTISE_100_FULL) {\r\ne_dbg("Advertise 100mb Full duplex\n");\r\nmii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;\r\n}\r\nif (hw->autoneg_advertised & ADVERTISE_1000_HALF) {\r\ne_dbg\r\n("Advertise 1000mb Half duplex requested, request denied!\n");\r\n}\r\nif (hw->autoneg_advertised & ADVERTISE_1000_FULL) {\r\ne_dbg("Advertise 1000mb Full duplex\n");\r\nmii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;\r\n}\r\nswitch (hw->fc) {\r\ncase E1000_FC_NONE:\r\nmii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\r\nbreak;\r\ncase E1000_FC_RX_PAUSE:\r\nmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\r\nbreak;\r\ncase E1000_FC_TX_PAUSE:\r\nmii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;\r\nmii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;\r\nbreak;\r\ncase E1000_FC_FULL:\r\nmii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);\r\nbreak;\r\ndefault:\r\ne_dbg("Flow control param set incorrectly\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\ne_dbg("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);\r\nif (hw->phy_type == e1000_phy_8201) {\r\nmii_1000t_ctrl_reg = 0;\r\n} else {\r\nret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,\r\nmii_1000t_ctrl_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 mii_ctrl_reg;\r\nu16 mii_status_reg;\r\nu16 phy_data;\r\nu16 i;\r\nhw->fc = E1000_FC_NONE;\r\ne_dbg("hw->fc = %d\n", hw->fc);\r\nctrl = er32(CTRL);\r\nctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\nctrl &= ~(DEVICE_SPEED_MASK);\r\nctrl &= ~E1000_CTRL_ASDE;\r\nret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nmii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;\r\nif (hw->forced_speed_duplex == e1000_100_full ||\r\nhw->forced_speed_duplex == e1000_10_full) {\r\nctrl |= E1000_CTRL_FD;\r\nmii_ctrl_reg |= MII_CR_FULL_DUPLEX;\r\ne_dbg("Full Duplex\n");\r\n} else {\r\nctrl &= ~E1000_CTRL_FD;\r\nmii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;\r\ne_dbg("Half Duplex\n");\r\n}\r\nif (hw->forced_speed_duplex == e1000_100_full ||\r\nhw->forced_speed_duplex == e1000_100_half) {\r\nctrl |= E1000_CTRL_SPD_100;\r\nmii_ctrl_reg |= MII_CR_SPEED_100;\r\nmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);\r\ne_dbg("Forcing 100mb ");\r\n} else {\r\nctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\r\nmii_ctrl_reg |= MII_CR_SPEED_10;\r\nmii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);\r\ne_dbg("Forcing 10mb ");\r\n}\r\ne1000_config_collision_dist(hw);\r\new32(CTRL, ctrl);\r\nif (hw->phy_type == e1000_phy_m88) {\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~M88E1000_PSCR_AUTO_X_MODE;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ne_dbg("M88E1000 PSCR: %x\n", phy_data);\r\nmii_ctrl_reg |= MII_CR_RESET;\r\n} else {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\r\nphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nudelay(1);\r\nif (hw->wait_autoneg_complete) {\r\ne_dbg("Waiting for forced speed/duplex link.\n");\r\nmii_status_reg = 0;\r\nfor (i = PHY_FORCE_TIME; i > 0; i--) {\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (mii_status_reg & MII_SR_LINK_STATUS)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif ((i == 0) && (hw->phy_type == e1000_phy_m88)) {\r\nret_val = e1000_phy_reset_dsp(hw);\r\nif (ret_val) {\r\ne_dbg("Error Resetting PHY DSP\n");\r\nreturn ret_val;\r\n}\r\n}\r\nfor (i = PHY_FORCE_TIME; i > 0; i--) {\r\nif (mii_status_reg & MII_SR_LINK_STATUS)\r\nbreak;\r\nmsleep(100);\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nif (hw->phy_type == e1000_phy_m88) {\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= M88E1000_EPSCR_TX_CLK_25;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((hw->mac_type == e1000_82544 || hw->mac_type == e1000_82543)\r\n&& (!hw->autoneg)\r\n&& (hw->forced_speed_duplex == e1000_10_full\r\n|| hw->forced_speed_duplex == e1000_10_half)) {\r\nret_val = e1000_polarity_reversal_workaround(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nvoid e1000_config_collision_dist(struct e1000_hw *hw)\r\n{\r\nu32 tctl, coll_dist;\r\nif (hw->mac_type < e1000_82543)\r\ncoll_dist = E1000_COLLISION_DISTANCE_82542;\r\nelse\r\ncoll_dist = E1000_COLLISION_DISTANCE;\r\ntctl = er32(TCTL);\r\ntctl &= ~E1000_TCTL_COLD;\r\ntctl |= coll_dist << E1000_COLD_SHIFT;\r\new32(TCTL, tctl);\r\nE1000_WRITE_FLUSH();\r\n}\r\nstatic s32 e1000_config_mac_to_phy(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 phy_data;\r\nif ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100))\r\nreturn E1000_SUCCESS;\r\nctrl = er32(CTRL);\r\nctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\nctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);\r\nswitch (hw->phy_type) {\r\ncase e1000_phy_8201:\r\nret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (phy_data & RTL_PHY_CTRL_FD)\r\nctrl |= E1000_CTRL_FD;\r\nelse\r\nctrl &= ~E1000_CTRL_FD;\r\nif (phy_data & RTL_PHY_CTRL_SPD_100)\r\nctrl |= E1000_CTRL_SPD_100;\r\nelse\r\nctrl |= E1000_CTRL_SPD_10;\r\ne1000_config_collision_dist(hw);\r\nbreak;\r\ndefault:\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (phy_data & M88E1000_PSSR_DPLX)\r\nctrl |= E1000_CTRL_FD;\r\nelse\r\nctrl &= ~E1000_CTRL_FD;\r\ne1000_config_collision_dist(hw);\r\nif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)\r\nctrl |= E1000_CTRL_SPD_1000;\r\nelse if ((phy_data & M88E1000_PSSR_SPEED) ==\r\nM88E1000_PSSR_100MBS)\r\nctrl |= E1000_CTRL_SPD_100;\r\n}\r\new32(CTRL, ctrl);\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_force_mac_fc(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nctrl = er32(CTRL);\r\nswitch (hw->fc) {\r\ncase E1000_FC_NONE:\r\nctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));\r\nbreak;\r\ncase E1000_FC_RX_PAUSE:\r\nctrl &= (~E1000_CTRL_TFCE);\r\nctrl |= E1000_CTRL_RFCE;\r\nbreak;\r\ncase E1000_FC_TX_PAUSE:\r\nctrl &= (~E1000_CTRL_RFCE);\r\nctrl |= E1000_CTRL_TFCE;\r\nbreak;\r\ncase E1000_FC_FULL:\r\nctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);\r\nbreak;\r\ndefault:\r\ne_dbg("Flow control param set incorrectly\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nif (hw->mac_type == e1000_82542_rev2_0)\r\nctrl &= (~E1000_CTRL_TFCE);\r\new32(CTRL, ctrl);\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 mii_status_reg;\r\nu16 mii_nway_adv_reg;\r\nu16 mii_nway_lp_ability_reg;\r\nu16 speed;\r\nu16 duplex;\r\nif (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed))\r\n|| ((hw->media_type == e1000_media_type_internal_serdes)\r\n&& (hw->autoneg_failed))\r\n|| ((hw->media_type == e1000_media_type_copper)\r\n&& (!hw->autoneg))) {\r\nret_val = e1000_force_mac_fc(hw);\r\nif (ret_val) {\r\ne_dbg("Error forcing flow control settings\n");\r\nreturn ret_val;\r\n}\r\n}\r\nif ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {\r\nret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,\r\n&mii_nway_adv_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,\r\n&mii_nway_lp_ability_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {\r\nif (hw->original_fc == E1000_FC_FULL) {\r\nhw->fc = E1000_FC_FULL;\r\ne_dbg("Flow Control = FULL.\n");\r\n} else {\r\nhw->fc = E1000_FC_RX_PAUSE;\r\ne_dbg\r\n("Flow Control = RX PAUSE frames only.\n");\r\n}\r\n}\r\nelse if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR))\r\n{\r\nhw->fc = E1000_FC_TX_PAUSE;\r\ne_dbg\r\n("Flow Control = TX PAUSE frames only.\n");\r\n}\r\nelse if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\r\n!(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR))\r\n{\r\nhw->fc = E1000_FC_RX_PAUSE;\r\ne_dbg\r\n("Flow Control = RX PAUSE frames only.\n");\r\n}\r\nelse if ((hw->original_fc == E1000_FC_NONE ||\r\nhw->original_fc == E1000_FC_TX_PAUSE) ||\r\nhw->fc_strict_ieee) {\r\nhw->fc = E1000_FC_NONE;\r\ne_dbg("Flow Control = NONE.\n");\r\n} else {\r\nhw->fc = E1000_FC_RX_PAUSE;\r\ne_dbg\r\n("Flow Control = RX PAUSE frames only.\n");\r\n}\r\nret_val =\r\ne1000_get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val) {\r\ne_dbg\r\n("Error getting link speed and duplex\n");\r\nreturn ret_val;\r\n}\r\nif (duplex == HALF_DUPLEX)\r\nhw->fc = E1000_FC_NONE;\r\nret_val = e1000_force_mac_fc(hw);\r\nif (ret_val) {\r\ne_dbg\r\n("Error forcing flow control settings\n");\r\nreturn ret_val;\r\n}\r\n} else {\r\ne_dbg\r\n("Copper PHY and Auto Neg has not completed.\n");\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_check_for_serdes_link_generic(struct e1000_hw *hw)\r\n{\r\nu32 rxcw;\r\nu32 ctrl;\r\nu32 status;\r\ns32 ret_val = E1000_SUCCESS;\r\nctrl = er32(CTRL);\r\nstatus = er32(STATUS);\r\nrxcw = er32(RXCW);\r\nif ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {\r\nif (hw->autoneg_failed == 0) {\r\nhw->autoneg_failed = 1;\r\ngoto out;\r\n}\r\ne_dbg("NOT RXing /C/, disable AutoNeg and force link.\n");\r\new32(TXCW, (hw->txcw & ~E1000_TXCW_ANE));\r\nctrl = er32(CTRL);\r\nctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\r\new32(CTRL, ctrl);\r\nret_val = e1000_config_fc_after_link_up(hw);\r\nif (ret_val) {\r\ne_dbg("Error configuring flow control\n");\r\ngoto out;\r\n}\r\n} else if ((ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {\r\ne_dbg("RXing /C/, enable AutoNeg and stop forcing link.\n");\r\new32(TXCW, hw->txcw);\r\new32(CTRL, (ctrl & ~E1000_CTRL_SLU));\r\nhw->serdes_has_link = true;\r\n} else if (!(E1000_TXCW_ANE & er32(TXCW))) {\r\nudelay(10);\r\nrxcw = er32(RXCW);\r\nif (rxcw & E1000_RXCW_SYNCH) {\r\nif (!(rxcw & E1000_RXCW_IV)) {\r\nhw->serdes_has_link = true;\r\ne_dbg("SERDES: Link up - forced.\n");\r\n}\r\n} else {\r\nhw->serdes_has_link = false;\r\ne_dbg("SERDES: Link down - force failed.\n");\r\n}\r\n}\r\nif (E1000_TXCW_ANE & er32(TXCW)) {\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_LU) {\r\nudelay(10);\r\nrxcw = er32(RXCW);\r\nif (rxcw & E1000_RXCW_SYNCH) {\r\nif (!(rxcw & E1000_RXCW_IV)) {\r\nhw->serdes_has_link = true;\r\ne_dbg("SERDES: Link up - autoneg "\r\n"completed successfully.\n");\r\n} else {\r\nhw->serdes_has_link = false;\r\ne_dbg("SERDES: Link down - invalid"\r\n"codewords detected in autoneg.\n");\r\n}\r\n} else {\r\nhw->serdes_has_link = false;\r\ne_dbg("SERDES: Link down - no sync.\n");\r\n}\r\n} else {\r\nhw->serdes_has_link = false;\r\ne_dbg("SERDES: Link down - autoneg failed\n");\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 e1000_check_for_link(struct e1000_hw *hw)\r\n{\r\nu32 rxcw = 0;\r\nu32 ctrl;\r\nu32 status;\r\nu32 rctl;\r\nu32 icr;\r\nu32 signal = 0;\r\ns32 ret_val;\r\nu16 phy_data;\r\nctrl = er32(CTRL);\r\nstatus = er32(STATUS);\r\nif ((hw->media_type == e1000_media_type_fiber) ||\r\n(hw->media_type == e1000_media_type_internal_serdes)) {\r\nrxcw = er32(RXCW);\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nsignal =\r\n(hw->mac_type >\r\ne1000_82544) ? E1000_CTRL_SWDPIN1 : 0;\r\nif (status & E1000_STATUS_LU)\r\nhw->get_link_status = false;\r\n}\r\n}\r\nif ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (phy_data & MII_SR_LINK_STATUS) {\r\nhw->get_link_status = false;\r\ne1000_check_downshift(hw);\r\nif ((hw->mac_type == e1000_82544\r\n|| hw->mac_type == e1000_82543) && (!hw->autoneg)\r\n&& (hw->forced_speed_duplex == e1000_10_full\r\n|| hw->forced_speed_duplex == e1000_10_half)) {\r\new32(IMC, 0xffffffff);\r\nret_val =\r\ne1000_polarity_reversal_workaround(hw);\r\nicr = er32(ICR);\r\new32(ICS, (icr & ~E1000_ICS_LSC));\r\new32(IMS, IMS_ENABLE_MASK);\r\n}\r\n} else {\r\ne1000_config_dsp_after_link_change(hw, false);\r\nreturn 0;\r\n}\r\nif (!hw->autoneg)\r\nreturn -E1000_ERR_CONFIG;\r\ne1000_config_dsp_after_link_change(hw, true);\r\nif ((hw->mac_type >= e1000_82544) &&\r\n(hw->mac_type != e1000_ce4100))\r\ne1000_config_collision_dist(hw);\r\nelse {\r\nret_val = e1000_config_mac_to_phy(hw);\r\nif (ret_val) {\r\ne_dbg\r\n("Error configuring MAC to PHY settings\n");\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_config_fc_after_link_up(hw);\r\nif (ret_val) {\r\ne_dbg("Error configuring flow control\n");\r\nreturn ret_val;\r\n}\r\nif (hw->tbi_compatibility_en) {\r\nu16 speed, duplex;\r\nret_val =\r\ne1000_get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val) {\r\ne_dbg\r\n("Error getting link speed and duplex\n");\r\nreturn ret_val;\r\n}\r\nif (speed != SPEED_1000) {\r\nif (hw->tbi_compatibility_on) {\r\nrctl = er32(RCTL);\r\nrctl &= ~E1000_RCTL_SBP;\r\new32(RCTL, rctl);\r\nhw->tbi_compatibility_on = false;\r\n}\r\n} else {\r\nif (!hw->tbi_compatibility_on) {\r\nhw->tbi_compatibility_on = true;\r\nrctl = er32(RCTL);\r\nrctl |= E1000_RCTL_SBP;\r\new32(RCTL, rctl);\r\n}\r\n}\r\n}\r\n}\r\nif ((hw->media_type == e1000_media_type_fiber) ||\r\n(hw->media_type == e1000_media_type_internal_serdes))\r\ne1000_check_for_serdes_link_generic(hw);\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_get_speed_and_duplex(struct e1000_hw *hw, u16 *speed, u16 *duplex)\r\n{\r\nu32 status;\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->mac_type >= e1000_82543) {\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_SPEED_1000) {\r\n*speed = SPEED_1000;\r\ne_dbg("1000 Mbs, ");\r\n} else if (status & E1000_STATUS_SPEED_100) {\r\n*speed = SPEED_100;\r\ne_dbg("100 Mbs, ");\r\n} else {\r\n*speed = SPEED_10;\r\ne_dbg("10 Mbs, ");\r\n}\r\nif (status & E1000_STATUS_FD) {\r\n*duplex = FULL_DUPLEX;\r\ne_dbg("Full Duplex\n");\r\n} else {\r\n*duplex = HALF_DUPLEX;\r\ne_dbg(" Half Duplex\n");\r\n}\r\n} else {\r\ne_dbg("1000 Mbs, Full Duplex\n");\r\n*speed = SPEED_1000;\r\n*duplex = FULL_DUPLEX;\r\n}\r\nif (hw->phy_type == e1000_phy_igp && hw->speed_downgraded) {\r\nret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(phy_data & NWAY_ER_LP_NWAY_CAPS))\r\n*duplex = HALF_DUPLEX;\r\nelse {\r\nret_val =\r\ne1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((*speed == SPEED_100\r\n&& !(phy_data & NWAY_LPAR_100TX_FD_CAPS))\r\n|| (*speed == SPEED_10\r\n&& !(phy_data & NWAY_LPAR_10T_FD_CAPS)))\r\n*duplex = HALF_DUPLEX;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_wait_autoneg(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nu16 phy_data;\r\ne_dbg("Waiting for Auto-Neg to complete.\n");\r\nfor (i = PHY_AUTO_NEG_TIME; i > 0; i--) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (phy_data & MII_SR_AUTONEG_COMPLETE) {\r\nreturn E1000_SUCCESS;\r\n}\r\nmsleep(100);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)\r\n{\r\new32(CTRL, (*ctrl | E1000_CTRL_MDC));\r\nE1000_WRITE_FLUSH();\r\nudelay(10);\r\n}\r\nstatic void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)\r\n{\r\new32(CTRL, (*ctrl & ~E1000_CTRL_MDC));\r\nE1000_WRITE_FLUSH();\r\nudelay(10);\r\n}\r\nstatic void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)\r\n{\r\nu32 ctrl;\r\nu32 mask;\r\nmask = 0x01;\r\nmask <<= (count - 1);\r\nctrl = er32(CTRL);\r\nctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);\r\nwhile (mask) {\r\nif (data & mask)\r\nctrl |= E1000_CTRL_MDIO;\r\nelse\r\nctrl &= ~E1000_CTRL_MDIO;\r\new32(CTRL, ctrl);\r\nE1000_WRITE_FLUSH();\r\nudelay(10);\r\ne1000_raise_mdi_clk(hw, &ctrl);\r\ne1000_lower_mdi_clk(hw, &ctrl);\r\nmask = mask >> 1;\r\n}\r\n}\r\nstatic u16 e1000_shift_in_mdi_bits(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nu16 data = 0;\r\nu8 i;\r\nctrl = er32(CTRL);\r\nctrl &= ~E1000_CTRL_MDIO_DIR;\r\nctrl &= ~E1000_CTRL_MDIO;\r\new32(CTRL, ctrl);\r\nE1000_WRITE_FLUSH();\r\ne1000_raise_mdi_clk(hw, &ctrl);\r\ne1000_lower_mdi_clk(hw, &ctrl);\r\nfor (data = 0, i = 0; i < 16; i++) {\r\ndata = data << 1;\r\ne1000_raise_mdi_clk(hw, &ctrl);\r\nctrl = er32(CTRL);\r\nif (ctrl & E1000_CTRL_MDIO)\r\ndata |= 1;\r\ne1000_lower_mdi_clk(hw, &ctrl);\r\n}\r\ne1000_raise_mdi_clk(hw, &ctrl);\r\ne1000_lower_mdi_clk(hw, &ctrl);\r\nreturn data;\r\n}\r\ns32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)\r\n{\r\nu32 ret_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&e1000_phy_lock, flags);\r\nif ((hw->phy_type == e1000_phy_igp) &&\r\n(reg_addr > MAX_PHY_MULTI_PAGE_REG)) {\r\nret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,\r\n(u16) reg_addr);\r\nif (ret_val) {\r\nspin_unlock_irqrestore(&e1000_phy_lock, flags);\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,\r\nphy_data);\r\nspin_unlock_irqrestore(&e1000_phy_lock, flags);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\r\nu16 *phy_data)\r\n{\r\nu32 i;\r\nu32 mdic = 0;\r\nconst u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;\r\nif (reg_addr > MAX_PHY_REG_ADDRESS) {\r\ne_dbg("PHY Address %d is out of range\n", reg_addr);\r\nreturn -E1000_ERR_PARAM;\r\n}\r\nif (hw->mac_type > e1000_82543) {\r\nif (hw->mac_type == e1000_ce4100) {\r\nmdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |\r\n(phy_addr << E1000_MDIC_PHY_SHIFT) |\r\n(INTEL_CE_GBE_MDIC_OP_READ) |\r\n(INTEL_CE_GBE_MDIC_GO));\r\nwritel(mdic, E1000_MDIO_CMD);\r\nfor (i = 0; i < 64; i++) {\r\nudelay(50);\r\nmdic = readl(E1000_MDIO_CMD);\r\nif (!(mdic & INTEL_CE_GBE_MDIC_GO))\r\nbreak;\r\n}\r\nif (mdic & INTEL_CE_GBE_MDIC_GO) {\r\ne_dbg("MDI Read did not complete\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\nmdic = readl(E1000_MDIO_STS);\r\nif (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {\r\ne_dbg("MDI Read Error\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\n*phy_data = (u16) mdic;\r\n} else {\r\nmdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |\r\n(phy_addr << E1000_MDIC_PHY_SHIFT) |\r\n(E1000_MDIC_OP_READ));\r\new32(MDIC, mdic);\r\nfor (i = 0; i < 64; i++) {\r\nudelay(50);\r\nmdic = er32(MDIC);\r\nif (mdic & E1000_MDIC_READY)\r\nbreak;\r\n}\r\nif (!(mdic & E1000_MDIC_READY)) {\r\ne_dbg("MDI Read did not complete\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\nif (mdic & E1000_MDIC_ERROR) {\r\ne_dbg("MDI Error\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\n*phy_data = (u16) mdic;\r\n}\r\n} else {\r\ne1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);\r\nmdic = ((reg_addr) | (phy_addr << 5) |\r\n(PHY_OP_READ << 10) | (PHY_SOF << 12));\r\ne1000_shift_out_mdi_bits(hw, mdic, 14);\r\n*phy_data = e1000_shift_in_mdi_bits(hw);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)\r\n{\r\nu32 ret_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&e1000_phy_lock, flags);\r\nif ((hw->phy_type == e1000_phy_igp) &&\r\n(reg_addr > MAX_PHY_MULTI_PAGE_REG)) {\r\nret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,\r\n(u16) reg_addr);\r\nif (ret_val) {\r\nspin_unlock_irqrestore(&e1000_phy_lock, flags);\r\nreturn ret_val;\r\n}\r\n}\r\nret_val = e1000_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,\r\nphy_data);\r\nspin_unlock_irqrestore(&e1000_phy_lock, flags);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,\r\nu16 phy_data)\r\n{\r\nu32 i;\r\nu32 mdic = 0;\r\nconst u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;\r\nif (reg_addr > MAX_PHY_REG_ADDRESS) {\r\ne_dbg("PHY Address %d is out of range\n", reg_addr);\r\nreturn -E1000_ERR_PARAM;\r\n}\r\nif (hw->mac_type > e1000_82543) {\r\nif (hw->mac_type == e1000_ce4100) {\r\nmdic = (((u32) phy_data) |\r\n(reg_addr << E1000_MDIC_REG_SHIFT) |\r\n(phy_addr << E1000_MDIC_PHY_SHIFT) |\r\n(INTEL_CE_GBE_MDIC_OP_WRITE) |\r\n(INTEL_CE_GBE_MDIC_GO));\r\nwritel(mdic, E1000_MDIO_CMD);\r\nfor (i = 0; i < 640; i++) {\r\nudelay(5);\r\nmdic = readl(E1000_MDIO_CMD);\r\nif (!(mdic & INTEL_CE_GBE_MDIC_GO))\r\nbreak;\r\n}\r\nif (mdic & INTEL_CE_GBE_MDIC_GO) {\r\ne_dbg("MDI Write did not complete\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\n} else {\r\nmdic = (((u32) phy_data) |\r\n(reg_addr << E1000_MDIC_REG_SHIFT) |\r\n(phy_addr << E1000_MDIC_PHY_SHIFT) |\r\n(E1000_MDIC_OP_WRITE));\r\new32(MDIC, mdic);\r\nfor (i = 0; i < 641; i++) {\r\nudelay(5);\r\nmdic = er32(MDIC);\r\nif (mdic & E1000_MDIC_READY)\r\nbreak;\r\n}\r\nif (!(mdic & E1000_MDIC_READY)) {\r\ne_dbg("MDI Write did not complete\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\n}\r\n} else {\r\ne1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);\r\nmdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |\r\n(PHY_OP_WRITE << 12) | (PHY_SOF << 14));\r\nmdic <<= 16;\r\nmdic |= (u32) phy_data;\r\ne1000_shift_out_mdi_bits(hw, mdic, 32);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_phy_hw_reset(struct e1000_hw *hw)\r\n{\r\nu32 ctrl, ctrl_ext;\r\nu32 led_ctrl;\r\ne_dbg("Resetting Phy...\n");\r\nif (hw->mac_type > e1000_82543) {\r\nctrl = er32(CTRL);\r\new32(CTRL, ctrl | E1000_CTRL_PHY_RST);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\new32(CTRL, ctrl);\r\nE1000_WRITE_FLUSH();\r\n} else {\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;\r\nctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;\r\new32(CTRL_EXT, ctrl_ext);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;\r\new32(CTRL_EXT, ctrl_ext);\r\nE1000_WRITE_FLUSH();\r\n}\r\nudelay(150);\r\nif ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {\r\nled_ctrl = er32(LEDCTL);\r\nled_ctrl &= IGP_ACTIVITY_LED_MASK;\r\nled_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);\r\new32(LEDCTL, led_ctrl);\r\n}\r\nreturn e1000_get_phy_cfg_done(hw);\r\n}\r\ns32 e1000_phy_reset(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nswitch (hw->phy_type) {\r\ncase e1000_phy_igp:\r\nret_val = e1000_phy_hw_reset(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\ndefault:\r\nret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= MII_CR_RESET;\r\nret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nudelay(1);\r\nbreak;\r\n}\r\nif (hw->phy_type == e1000_phy_igp)\r\ne1000_phy_init_script(hw);\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_detect_gig_phy(struct e1000_hw *hw)\r\n{\r\ns32 phy_init_status, ret_val;\r\nu16 phy_id_high, phy_id_low;\r\nbool match = false;\r\nif (hw->phy_id != 0)\r\nreturn E1000_SUCCESS;\r\nret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy_id = (u32) (phy_id_high << 16);\r\nudelay(20);\r\nret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);\r\nhw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;\r\nswitch (hw->mac_type) {\r\ncase e1000_82543:\r\nif (hw->phy_id == M88E1000_E_PHY_ID)\r\nmatch = true;\r\nbreak;\r\ncase e1000_82544:\r\nif (hw->phy_id == M88E1000_I_PHY_ID)\r\nmatch = true;\r\nbreak;\r\ncase e1000_82540:\r\ncase e1000_82545:\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546:\r\ncase e1000_82546_rev_3:\r\nif (hw->phy_id == M88E1011_I_PHY_ID)\r\nmatch = true;\r\nbreak;\r\ncase e1000_ce4100:\r\nif ((hw->phy_id == RTL8211B_PHY_ID) ||\r\n(hw->phy_id == RTL8201N_PHY_ID) ||\r\n(hw->phy_id == M88E1118_E_PHY_ID))\r\nmatch = true;\r\nbreak;\r\ncase e1000_82541:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547:\r\ncase e1000_82547_rev_2:\r\nif (hw->phy_id == IGP01E1000_I_PHY_ID)\r\nmatch = true;\r\nbreak;\r\ndefault:\r\ne_dbg("Invalid MAC type %d\n", hw->mac_type);\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nphy_init_status = e1000_set_phy_type(hw);\r\nif ((match) && (phy_init_status == E1000_SUCCESS)) {\r\ne_dbg("PHY ID 0x%X detected\n", hw->phy_id);\r\nreturn E1000_SUCCESS;\r\n}\r\ne_dbg("Invalid PHY ID 0x%X\n", hw->phy_id);\r\nreturn -E1000_ERR_PHY;\r\n}\r\nstatic s32 e1000_phy_reset_dsp(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\ndo {\r\nret_val = e1000_write_phy_reg(hw, 29, 0x001d);\r\nif (ret_val)\r\nbreak;\r\nret_val = e1000_write_phy_reg(hw, 30, 0x00c1);\r\nif (ret_val)\r\nbreak;\r\nret_val = e1000_write_phy_reg(hw, 30, 0x0000);\r\nif (ret_val)\r\nbreak;\r\nret_val = E1000_SUCCESS;\r\n} while (0);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_phy_igp_get_info(struct e1000_hw *hw,\r\nstruct e1000_phy_info *phy_info)\r\n{\r\ns32 ret_val;\r\nu16 phy_data, min_length, max_length, average;\r\ne1000_rev_polarity polarity;\r\nphy_info->downshift = (e1000_downshift) hw->speed_downgraded;\r\nphy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_normal;\r\nphy_info->polarity_correction = e1000_polarity_reversal_enabled;\r\nret_val = e1000_check_polarity(hw, &polarity);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->cable_polarity = polarity;\r\nret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->mdix_mode =\r\n(e1000_auto_x_mode) ((phy_data & IGP01E1000_PSSR_MDIX) >>\r\nIGP01E1000_PSSR_MDIX_SHIFT);\r\nif ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==\r\nIGP01E1000_PSSR_SPEED_1000MBPS) {\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>\r\nSR_1000T_LOCAL_RX_STATUS_SHIFT) ?\r\ne1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\r\nphy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>\r\nSR_1000T_REMOTE_RX_STATUS_SHIFT) ?\r\ne1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\r\nret_val = e1000_get_cable_length(hw, &min_length, &max_length);\r\nif (ret_val)\r\nreturn ret_val;\r\naverage = (max_length + min_length) / 2;\r\nif (average <= e1000_igp_cable_length_50)\r\nphy_info->cable_length = e1000_cable_length_50;\r\nelse if (average <= e1000_igp_cable_length_80)\r\nphy_info->cable_length = e1000_cable_length_50_80;\r\nelse if (average <= e1000_igp_cable_length_110)\r\nphy_info->cable_length = e1000_cable_length_80_110;\r\nelse if (average <= e1000_igp_cable_length_140)\r\nphy_info->cable_length = e1000_cable_length_110_140;\r\nelse\r\nphy_info->cable_length = e1000_cable_length_140;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_phy_m88_get_info(struct e1000_hw *hw,\r\nstruct e1000_phy_info *phy_info)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\ne1000_rev_polarity polarity;\r\nphy_info->downshift = (e1000_downshift) hw->speed_downgraded;\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->extended_10bt_distance =\r\n((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>\r\nM88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?\r\ne1000_10bt_ext_dist_enable_lower :\r\ne1000_10bt_ext_dist_enable_normal;\r\nphy_info->polarity_correction =\r\n((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>\r\nM88E1000_PSCR_POLARITY_REVERSAL_SHIFT) ?\r\ne1000_polarity_reversal_disabled : e1000_polarity_reversal_enabled;\r\nret_val = e1000_check_polarity(hw, &polarity);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->cable_polarity = polarity;\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->mdix_mode =\r\n(e1000_auto_x_mode) ((phy_data & M88E1000_PSSR_MDIX) >>\r\nM88E1000_PSSR_MDIX_SHIFT);\r\nif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {\r\nphy_info->cable_length =\r\n(e1000_cable_length) ((phy_data &\r\nM88E1000_PSSR_CABLE_LENGTH) >>\r\nM88E1000_PSSR_CABLE_LENGTH_SHIFT);\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>\r\nSR_1000T_LOCAL_RX_STATUS_SHIFT) ?\r\ne1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\r\nphy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>\r\nSR_1000T_REMOTE_RX_STATUS_SHIFT) ?\r\ne1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nphy_info->cable_length = e1000_cable_length_undefined;\r\nphy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_undefined;\r\nphy_info->cable_polarity = e1000_rev_polarity_undefined;\r\nphy_info->downshift = e1000_downshift_undefined;\r\nphy_info->polarity_correction = e1000_polarity_reversal_undefined;\r\nphy_info->mdix_mode = e1000_auto_x_mode_undefined;\r\nphy_info->local_rx = e1000_1000t_rx_status_undefined;\r\nphy_info->remote_rx = e1000_1000t_rx_status_undefined;\r\nif (hw->media_type != e1000_media_type_copper) {\r\ne_dbg("PHY info is only valid for copper media\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {\r\ne_dbg("PHY info is only valid if link is up\n");\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nif (hw->phy_type == e1000_phy_igp)\r\nreturn e1000_phy_igp_get_info(hw, phy_info);\r\nelse if ((hw->phy_type == e1000_phy_8211) ||\r\n(hw->phy_type == e1000_phy_8201))\r\nreturn E1000_SUCCESS;\r\nelse\r\nreturn e1000_phy_m88_get_info(hw, phy_info);\r\n}\r\ns32 e1000_validate_mdi_setting(struct e1000_hw *hw)\r\n{\r\nif (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {\r\ne_dbg("Invalid MDI setting detected\n");\r\nhw->mdix = 1;\r\nreturn -E1000_ERR_CONFIG;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_init_eeprom_params(struct e1000_hw *hw)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eecd = er32(EECD);\r\ns32 ret_val = E1000_SUCCESS;\r\nu16 eeprom_size;\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\ncase e1000_82544:\r\neeprom->type = e1000_eeprom_microwire;\r\neeprom->word_size = 64;\r\neeprom->opcode_bits = 3;\r\neeprom->address_bits = 6;\r\neeprom->delay_usec = 50;\r\nbreak;\r\ncase e1000_82540:\r\ncase e1000_82545:\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546:\r\ncase e1000_82546_rev_3:\r\neeprom->type = e1000_eeprom_microwire;\r\neeprom->opcode_bits = 3;\r\neeprom->delay_usec = 50;\r\nif (eecd & E1000_EECD_SIZE) {\r\neeprom->word_size = 256;\r\neeprom->address_bits = 8;\r\n} else {\r\neeprom->word_size = 64;\r\neeprom->address_bits = 6;\r\n}\r\nbreak;\r\ncase e1000_82541:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547:\r\ncase e1000_82547_rev_2:\r\nif (eecd & E1000_EECD_TYPE) {\r\neeprom->type = e1000_eeprom_spi;\r\neeprom->opcode_bits = 8;\r\neeprom->delay_usec = 1;\r\nif (eecd & E1000_EECD_ADDR_BITS) {\r\neeprom->page_size = 32;\r\neeprom->address_bits = 16;\r\n} else {\r\neeprom->page_size = 8;\r\neeprom->address_bits = 8;\r\n}\r\n} else {\r\neeprom->type = e1000_eeprom_microwire;\r\neeprom->opcode_bits = 3;\r\neeprom->delay_usec = 50;\r\nif (eecd & E1000_EECD_ADDR_BITS) {\r\neeprom->word_size = 256;\r\neeprom->address_bits = 8;\r\n} else {\r\neeprom->word_size = 64;\r\neeprom->address_bits = 6;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (eeprom->type == e1000_eeprom_spi) {\r\neeprom->word_size = 64;\r\nret_val = e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size);\r\nif (ret_val)\r\nreturn ret_val;\r\neeprom_size =\r\n(eeprom_size & EEPROM_SIZE_MASK) >> EEPROM_SIZE_SHIFT;\r\nif (eeprom_size)\r\neeprom_size++;\r\neeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd | E1000_EECD_SK;\r\new32(EECD, *eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(hw->eeprom.delay_usec);\r\n}\r\nstatic void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd & ~E1000_EECD_SK;\r\new32(EECD, *eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(hw->eeprom.delay_usec);\r\n}\r\nstatic void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eecd;\r\nu32 mask;\r\nmask = 0x01 << (count - 1);\r\neecd = er32(EECD);\r\nif (eeprom->type == e1000_eeprom_microwire) {\r\neecd &= ~E1000_EECD_DO;\r\n} else if (eeprom->type == e1000_eeprom_spi) {\r\neecd |= E1000_EECD_DO;\r\n}\r\ndo {\r\neecd &= ~E1000_EECD_DI;\r\nif (data & mask)\r\neecd |= E1000_EECD_DI;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\ne1000_raise_ee_clk(hw, &eecd);\r\ne1000_lower_ee_clk(hw, &eecd);\r\nmask = mask >> 1;\r\n} while (mask);\r\neecd &= ~E1000_EECD_DI;\r\new32(EECD, eecd);\r\n}\r\nstatic u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count)\r\n{\r\nu32 eecd;\r\nu32 i;\r\nu16 data;\r\neecd = er32(EECD);\r\neecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\r\ndata = 0;\r\nfor (i = 0; i < count; i++) {\r\ndata = data << 1;\r\ne1000_raise_ee_clk(hw, &eecd);\r\neecd = er32(EECD);\r\neecd &= ~(E1000_EECD_DI);\r\nif (eecd & E1000_EECD_DO)\r\ndata |= 1;\r\ne1000_lower_ee_clk(hw, &eecd);\r\n}\r\nreturn data;\r\n}\r\nstatic s32 e1000_acquire_eeprom(struct e1000_hw *hw)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eecd, i = 0;\r\neecd = er32(EECD);\r\nif (hw->mac_type > e1000_82544) {\r\neecd |= E1000_EECD_REQ;\r\new32(EECD, eecd);\r\neecd = er32(EECD);\r\nwhile ((!(eecd & E1000_EECD_GNT)) &&\r\n(i < E1000_EEPROM_GRANT_ATTEMPTS)) {\r\ni++;\r\nudelay(5);\r\neecd = er32(EECD);\r\n}\r\nif (!(eecd & E1000_EECD_GNT)) {\r\neecd &= ~E1000_EECD_REQ;\r\new32(EECD, eecd);\r\ne_dbg("Could not acquire EEPROM grant\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\n}\r\nif (eeprom->type == e1000_eeprom_microwire) {\r\neecd &= ~(E1000_EECD_DI | E1000_EECD_SK);\r\new32(EECD, eecd);\r\neecd |= E1000_EECD_CS;\r\new32(EECD, eecd);\r\n} else if (eeprom->type == e1000_eeprom_spi) {\r\neecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(1);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic void e1000_standby_eeprom(struct e1000_hw *hw)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eecd;\r\neecd = er32(EECD);\r\nif (eeprom->type == e1000_eeprom_microwire) {\r\neecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\neecd |= E1000_EECD_SK;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\neecd |= E1000_EECD_CS;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\neecd &= ~E1000_EECD_SK;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\n} else if (eeprom->type == e1000_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\neecd &= ~E1000_EECD_CS;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(eeprom->delay_usec);\r\n}\r\n}\r\nstatic void e1000_release_eeprom(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\neecd = er32(EECD);\r\nif (hw->eeprom.type == e1000_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\neecd &= ~E1000_EECD_SK;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(hw->eeprom.delay_usec);\r\n} else if (hw->eeprom.type == e1000_eeprom_microwire) {\r\neecd &= ~(E1000_EECD_CS | E1000_EECD_DI);\r\new32(EECD, eecd);\r\neecd |= E1000_EECD_SK;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(hw->eeprom.delay_usec);\r\neecd &= ~E1000_EECD_SK;\r\new32(EECD, eecd);\r\nE1000_WRITE_FLUSH();\r\nudelay(hw->eeprom.delay_usec);\r\n}\r\nif (hw->mac_type > e1000_82544) {\r\neecd &= ~E1000_EECD_REQ;\r\new32(EECD, eecd);\r\n}\r\n}\r\nstatic s32 e1000_spi_eeprom_ready(struct e1000_hw *hw)\r\n{\r\nu16 retry_count = 0;\r\nu8 spi_stat_reg;\r\nretry_count = 0;\r\ndo {\r\ne1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,\r\nhw->eeprom.opcode_bits);\r\nspi_stat_reg = (u8) e1000_shift_in_ee_bits(hw, 8);\r\nif (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))\r\nbreak;\r\nudelay(5);\r\nretry_count += 5;\r\ne1000_standby_eeprom(hw);\r\n} while (retry_count < EEPROM_MAX_RETRY_SPI);\r\nif (retry_count >= EEPROM_MAX_RETRY_SPI) {\r\ne_dbg("SPI EEPROM Status error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\ns32 ret;\r\nspin_lock(&e1000_eeprom_lock);\r\nret = e1000_do_read_eeprom(hw, offset, words, data);\r\nspin_unlock(&e1000_eeprom_lock);\r\nreturn ret;\r\n}\r\nstatic s32 e1000_do_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 i = 0;\r\nif (hw->mac_type == e1000_ce4100) {\r\nGBE_CONFIG_FLASH_READ(GBE_CONFIG_BASE_VIRT, offset, words,\r\ndata);\r\nreturn E1000_SUCCESS;\r\n}\r\nif (eeprom->word_size == 0)\r\ne1000_init_eeprom_params(hw);\r\nif ((offset >= eeprom->word_size)\r\n|| (words > eeprom->word_size - offset) || (words == 0)) {\r\ne_dbg("\"words\" parameter out of bounds. Words = %d,"\r\n"size = %d\n", offset, eeprom->word_size);\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nif (e1000_acquire_eeprom(hw) != E1000_SUCCESS)\r\nreturn -E1000_ERR_EEPROM;\r\nif (eeprom->type == e1000_eeprom_spi) {\r\nu16 word_in;\r\nu8 read_opcode = EEPROM_READ_OPCODE_SPI;\r\nif (e1000_spi_eeprom_ready(hw)) {\r\ne1000_release_eeprom(hw);\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\ne1000_standby_eeprom(hw);\r\nif ((eeprom->address_bits == 8) && (offset >= 128))\r\nread_opcode |= EEPROM_A8_OPCODE_SPI;\r\ne1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);\r\ne1000_shift_out_ee_bits(hw, (u16) (offset * 2),\r\neeprom->address_bits);\r\nfor (i = 0; i < words; i++) {\r\nword_in = e1000_shift_in_ee_bits(hw, 16);\r\ndata[i] = (word_in >> 8) | (word_in << 8);\r\n}\r\n} else if (eeprom->type == e1000_eeprom_microwire) {\r\nfor (i = 0; i < words; i++) {\r\ne1000_shift_out_ee_bits(hw,\r\nEEPROM_READ_OPCODE_MICROWIRE,\r\neeprom->opcode_bits);\r\ne1000_shift_out_ee_bits(hw, (u16) (offset + i),\r\neeprom->address_bits);\r\ndata[i] = e1000_shift_in_ee_bits(hw, 16);\r\ne1000_standby_eeprom(hw);\r\n}\r\n}\r\ne1000_release_eeprom(hw);\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)\r\n{\r\nu16 checksum = 0;\r\nu16 i, eeprom_data;\r\nfor (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {\r\nif (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nchecksum += eeprom_data;\r\n}\r\n#ifdef CONFIG_PARISC\r\nif ((hw->subsystem_vendor_id == 0x103C) && (eeprom_data == 0x16d6))\r\nreturn E1000_SUCCESS;\r\n#endif\r\nif (checksum == (u16) EEPROM_SUM)\r\nreturn E1000_SUCCESS;\r\nelse {\r\ne_dbg("EEPROM Checksum Invalid\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\n}\r\ns32 e1000_update_eeprom_checksum(struct e1000_hw *hw)\r\n{\r\nu16 checksum = 0;\r\nu16 i, eeprom_data;\r\nfor (i = 0; i < EEPROM_CHECKSUM_REG; i++) {\r\nif (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nchecksum += eeprom_data;\r\n}\r\nchecksum = (u16) EEPROM_SUM - checksum;\r\nif (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {\r\ne_dbg("EEPROM Write Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\ns32 ret;\r\nspin_lock(&e1000_eeprom_lock);\r\nret = e1000_do_write_eeprom(hw, offset, words, data);\r\nspin_unlock(&e1000_eeprom_lock);\r\nreturn ret;\r\n}\r\nstatic s32 e1000_do_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\ns32 status = 0;\r\nif (hw->mac_type == e1000_ce4100) {\r\nGBE_CONFIG_FLASH_WRITE(GBE_CONFIG_BASE_VIRT, offset, words,\r\ndata);\r\nreturn E1000_SUCCESS;\r\n}\r\nif (eeprom->word_size == 0)\r\ne1000_init_eeprom_params(hw);\r\nif ((offset >= eeprom->word_size)\r\n|| (words > eeprom->word_size - offset) || (words == 0)) {\r\ne_dbg("\"words\" parameter out of bounds\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nif (e1000_acquire_eeprom(hw) != E1000_SUCCESS)\r\nreturn -E1000_ERR_EEPROM;\r\nif (eeprom->type == e1000_eeprom_microwire) {\r\nstatus = e1000_write_eeprom_microwire(hw, offset, words, data);\r\n} else {\r\nstatus = e1000_write_eeprom_spi(hw, offset, words, data);\r\nmsleep(10);\r\n}\r\ne1000_release_eeprom(hw);\r\nreturn status;\r\n}\r\nstatic s32 e1000_write_eeprom_spi(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu16 widx = 0;\r\nwhile (widx < words) {\r\nu8 write_opcode = EEPROM_WRITE_OPCODE_SPI;\r\nif (e1000_spi_eeprom_ready(hw))\r\nreturn -E1000_ERR_EEPROM;\r\ne1000_standby_eeprom(hw);\r\ne1000_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,\r\neeprom->opcode_bits);\r\ne1000_standby_eeprom(hw);\r\nif ((eeprom->address_bits == 8) && (offset >= 128))\r\nwrite_opcode |= EEPROM_A8_OPCODE_SPI;\r\ne1000_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);\r\ne1000_shift_out_ee_bits(hw, (u16) ((offset + widx) * 2),\r\neeprom->address_bits);\r\nwhile (widx < words) {\r\nu16 word_out = data[widx];\r\nword_out = (word_out >> 8) | (word_out << 8);\r\ne1000_shift_out_ee_bits(hw, word_out, 16);\r\nwidx++;\r\nif ((((offset + widx) * 2) % eeprom->page_size) == 0) {\r\ne1000_standby_eeprom(hw);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_write_eeprom_microwire(struct e1000_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nstruct e1000_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eecd;\r\nu16 words_written = 0;\r\nu16 i = 0;\r\ne1000_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,\r\n(u16) (eeprom->opcode_bits + 2));\r\ne1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));\r\ne1000_standby_eeprom(hw);\r\nwhile (words_written < words) {\r\ne1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,\r\neeprom->opcode_bits);\r\ne1000_shift_out_ee_bits(hw, (u16) (offset + words_written),\r\neeprom->address_bits);\r\ne1000_shift_out_ee_bits(hw, data[words_written], 16);\r\ne1000_standby_eeprom(hw);\r\nfor (i = 0; i < 200; i++) {\r\neecd = er32(EECD);\r\nif (eecd & E1000_EECD_DO)\r\nbreak;\r\nudelay(50);\r\n}\r\nif (i == 200) {\r\ne_dbg("EEPROM Write did not complete\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\ne1000_standby_eeprom(hw);\r\nwords_written++;\r\n}\r\ne1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,\r\n(u16) (eeprom->opcode_bits + 2));\r\ne1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_read_mac_addr(struct e1000_hw *hw)\r\n{\r\nu16 offset;\r\nu16 eeprom_data, i;\r\nfor (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {\r\noffset = i >> 1;\r\nif (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nhw->perm_mac_addr[i] = (u8) (eeprom_data & 0x00FF);\r\nhw->perm_mac_addr[i + 1] = (u8) (eeprom_data >> 8);\r\n}\r\nswitch (hw->mac_type) {\r\ndefault:\r\nbreak;\r\ncase e1000_82546:\r\ncase e1000_82546_rev_3:\r\nif (er32(STATUS) & E1000_STATUS_FUNC_1)\r\nhw->perm_mac_addr[5] ^= 0x01;\r\nbreak;\r\n}\r\nfor (i = 0; i < NODE_ADDRESS_SIZE; i++)\r\nhw->mac_addr[i] = hw->perm_mac_addr[i];\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic void e1000_init_rx_addrs(struct e1000_hw *hw)\r\n{\r\nu32 i;\r\nu32 rar_num;\r\ne_dbg("Programming MAC Address into RAR[0]\n");\r\ne1000_rar_set(hw, hw->mac_addr, 0);\r\nrar_num = E1000_RAR_ENTRIES;\r\ne_dbg("Clearing RAR[1-15]\n");\r\nfor (i = 1; i < rar_num; i++) {\r\nE1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);\r\nE1000_WRITE_FLUSH();\r\nE1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);\r\nE1000_WRITE_FLUSH();\r\n}\r\n}\r\nu32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\r\n{\r\nu32 hash_value = 0;\r\nswitch (hw->mc_filter_type) {\r\ncase 0:\r\nhash_value = ((mc_addr[4] >> 4) | (((u16) mc_addr[5]) << 4));\r\nbreak;\r\ncase 1:\r\nhash_value = ((mc_addr[4] >> 3) | (((u16) mc_addr[5]) << 5));\r\nbreak;\r\ncase 2:\r\nhash_value = ((mc_addr[4] >> 2) | (((u16) mc_addr[5]) << 6));\r\nbreak;\r\ncase 3:\r\nhash_value = ((mc_addr[4]) | (((u16) mc_addr[5]) << 8));\r\nbreak;\r\n}\r\nhash_value &= 0xFFF;\r\nreturn hash_value;\r\n}\r\nvoid e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)\r\n{\r\nu32 rar_low, rar_high;\r\nrar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |\r\n((u32) addr[2] << 16) | ((u32) addr[3] << 24));\r\nrar_high = ((u32) addr[4] | ((u32) addr[5] << 8));\r\nswitch (hw->mac_type) {\r\ndefault:\r\nrar_high |= E1000_RAH_AV;\r\nbreak;\r\n}\r\nE1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);\r\nE1000_WRITE_FLUSH();\r\nE1000_WRITE_REG_ARRAY(hw, RA, ((index << 1) + 1), rar_high);\r\nE1000_WRITE_FLUSH();\r\n}\r\nvoid e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)\r\n{\r\nu32 temp;\r\nif ((hw->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {\r\ntemp = E1000_READ_REG_ARRAY(hw, VFTA, (offset - 1));\r\nE1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);\r\nE1000_WRITE_FLUSH();\r\nE1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);\r\nE1000_WRITE_FLUSH();\r\n} else {\r\nE1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);\r\nE1000_WRITE_FLUSH();\r\n}\r\n}\r\nstatic void e1000_clear_vfta(struct e1000_hw *hw)\r\n{\r\nu32 offset;\r\nu32 vfta_value = 0;\r\nu32 vfta_offset = 0;\r\nu32 vfta_bit_in_reg = 0;\r\nfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\r\nvfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;\r\nE1000_WRITE_REG_ARRAY(hw, VFTA, offset, vfta_value);\r\nE1000_WRITE_FLUSH();\r\n}\r\n}\r\nstatic s32 e1000_id_led_init(struct e1000_hw *hw)\r\n{\r\nu32 ledctl;\r\nconst u32 ledctl_mask = 0x000000FF;\r\nconst u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;\r\nconst u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;\r\nu16 eeprom_data, i, temp;\r\nconst u16 led_mask = 0x0F;\r\nif (hw->mac_type < e1000_82540) {\r\nreturn E1000_SUCCESS;\r\n}\r\nledctl = er32(LEDCTL);\r\nhw->ledctl_default = ledctl;\r\nhw->ledctl_mode1 = hw->ledctl_default;\r\nhw->ledctl_mode2 = hw->ledctl_default;\r\nif (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {\r\ne_dbg("EEPROM Read Error\n");\r\nreturn -E1000_ERR_EEPROM;\r\n}\r\nif ((eeprom_data == ID_LED_RESERVED_0000) ||\r\n(eeprom_data == ID_LED_RESERVED_FFFF)) {\r\neeprom_data = ID_LED_DEFAULT;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ntemp = (eeprom_data >> (i << 2)) & led_mask;\r\nswitch (temp) {\r\ncase ID_LED_ON1_DEF2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_ON1_OFF2:\r\nhw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\r\nhw->ledctl_mode1 |= ledctl_on << (i << 3);\r\nbreak;\r\ncase ID_LED_OFF1_DEF2:\r\ncase ID_LED_OFF1_ON2:\r\ncase ID_LED_OFF1_OFF2:\r\nhw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\r\nhw->ledctl_mode1 |= ledctl_off << (i << 3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (temp) {\r\ncase ID_LED_DEF1_ON2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_OFF1_ON2:\r\nhw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\r\nhw->ledctl_mode2 |= ledctl_on << (i << 3);\r\nbreak;\r\ncase ID_LED_DEF1_OFF2:\r\ncase ID_LED_ON1_OFF2:\r\ncase ID_LED_OFF1_OFF2:\r\nhw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\r\nhw->ledctl_mode2 |= ledctl_off << (i << 3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_setup_led(struct e1000_hw *hw)\r\n{\r\nu32 ledctl;\r\ns32 ret_val = E1000_SUCCESS;\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\ncase e1000_82544:\r\nbreak;\r\ncase e1000_82541:\r\ncase e1000_82547:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547_rev_2:\r\nret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,\r\n&hw->phy_spd_default);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\r\n(u16) (hw->phy_spd_default &\r\n~IGP01E1000_GMII_SPD));\r\nif (ret_val)\r\nreturn ret_val;\r\ndefault:\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nledctl = er32(LEDCTL);\r\nhw->ledctl_default = ledctl;\r\nledctl &= ~(E1000_LEDCTL_LED0_IVRT |\r\nE1000_LEDCTL_LED0_BLINK |\r\nE1000_LEDCTL_LED0_MODE_MASK);\r\nledctl |= (E1000_LEDCTL_MODE_LED_OFF <<\r\nE1000_LEDCTL_LED0_MODE_SHIFT);\r\new32(LEDCTL, ledctl);\r\n} else if (hw->media_type == e1000_media_type_copper)\r\new32(LEDCTL, hw->ledctl_mode1);\r\nbreak;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_cleanup_led(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = E1000_SUCCESS;\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\ncase e1000_82544:\r\nbreak;\r\ncase e1000_82541:\r\ncase e1000_82547:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547_rev_2:\r\nret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\r\nhw->phy_spd_default);\r\nif (ret_val)\r\nreturn ret_val;\r\ndefault:\r\new32(LEDCTL, hw->ledctl_default);\r\nbreak;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_led_on(struct e1000_hw *hw)\r\n{\r\nu32 ctrl = er32(CTRL);\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\nctrl |= E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\nbreak;\r\ncase e1000_82544:\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nctrl |= E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n} else {\r\nctrl &= ~E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n}\r\nbreak;\r\ndefault:\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nctrl &= ~E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n} else if (hw->media_type == e1000_media_type_copper) {\r\new32(LEDCTL, hw->ledctl_mode2);\r\nreturn E1000_SUCCESS;\r\n}\r\nbreak;\r\n}\r\new32(CTRL, ctrl);\r\nreturn E1000_SUCCESS;\r\n}\r\ns32 e1000_led_off(struct e1000_hw *hw)\r\n{\r\nu32 ctrl = er32(CTRL);\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\ncase e1000_82543:\r\nctrl &= ~E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\nbreak;\r\ncase e1000_82544:\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nctrl &= ~E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n} else {\r\nctrl |= E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n}\r\nbreak;\r\ndefault:\r\nif (hw->media_type == e1000_media_type_fiber) {\r\nctrl |= E1000_CTRL_SWDPIN0;\r\nctrl |= E1000_CTRL_SWDPIO0;\r\n} else if (hw->media_type == e1000_media_type_copper) {\r\new32(LEDCTL, hw->ledctl_mode1);\r\nreturn E1000_SUCCESS;\r\n}\r\nbreak;\r\n}\r\new32(CTRL, ctrl);\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic void e1000_clear_hw_cntrs(struct e1000_hw *hw)\r\n{\r\nvolatile u32 temp;\r\ntemp = er32(CRCERRS);\r\ntemp = er32(SYMERRS);\r\ntemp = er32(MPC);\r\ntemp = er32(SCC);\r\ntemp = er32(ECOL);\r\ntemp = er32(MCC);\r\ntemp = er32(LATECOL);\r\ntemp = er32(COLC);\r\ntemp = er32(DC);\r\ntemp = er32(SEC);\r\ntemp = er32(RLEC);\r\ntemp = er32(XONRXC);\r\ntemp = er32(XONTXC);\r\ntemp = er32(XOFFRXC);\r\ntemp = er32(XOFFTXC);\r\ntemp = er32(FCRUC);\r\ntemp = er32(PRC64);\r\ntemp = er32(PRC127);\r\ntemp = er32(PRC255);\r\ntemp = er32(PRC511);\r\ntemp = er32(PRC1023);\r\ntemp = er32(PRC1522);\r\ntemp = er32(GPRC);\r\ntemp = er32(BPRC);\r\ntemp = er32(MPRC);\r\ntemp = er32(GPTC);\r\ntemp = er32(GORCL);\r\ntemp = er32(GORCH);\r\ntemp = er32(GOTCL);\r\ntemp = er32(GOTCH);\r\ntemp = er32(RNBC);\r\ntemp = er32(RUC);\r\ntemp = er32(RFC);\r\ntemp = er32(ROC);\r\ntemp = er32(RJC);\r\ntemp = er32(TORL);\r\ntemp = er32(TORH);\r\ntemp = er32(TOTL);\r\ntemp = er32(TOTH);\r\ntemp = er32(TPR);\r\ntemp = er32(TPT);\r\ntemp = er32(PTC64);\r\ntemp = er32(PTC127);\r\ntemp = er32(PTC255);\r\ntemp = er32(PTC511);\r\ntemp = er32(PTC1023);\r\ntemp = er32(PTC1522);\r\ntemp = er32(MPTC);\r\ntemp = er32(BPTC);\r\nif (hw->mac_type < e1000_82543)\r\nreturn;\r\ntemp = er32(ALGNERRC);\r\ntemp = er32(RXERRC);\r\ntemp = er32(TNCRS);\r\ntemp = er32(CEXTERR);\r\ntemp = er32(TSCTC);\r\ntemp = er32(TSCTFC);\r\nif (hw->mac_type <= e1000_82544)\r\nreturn;\r\ntemp = er32(MGTPRC);\r\ntemp = er32(MGTPDC);\r\ntemp = er32(MGTPTC);\r\n}\r\nvoid e1000_reset_adaptive(struct e1000_hw *hw)\r\n{\r\nif (hw->adaptive_ifs) {\r\nif (!hw->ifs_params_forced) {\r\nhw->current_ifs_val = 0;\r\nhw->ifs_min_val = IFS_MIN;\r\nhw->ifs_max_val = IFS_MAX;\r\nhw->ifs_step_size = IFS_STEP;\r\nhw->ifs_ratio = IFS_RATIO;\r\n}\r\nhw->in_ifs_mode = false;\r\new32(AIT, 0);\r\n} else {\r\ne_dbg("Not in Adaptive IFS mode!\n");\r\n}\r\n}\r\nvoid e1000_update_adaptive(struct e1000_hw *hw)\r\n{\r\nif (hw->adaptive_ifs) {\r\nif ((hw->collision_delta *hw->ifs_ratio) > hw->tx_packet_delta) {\r\nif (hw->tx_packet_delta > MIN_NUM_XMITS) {\r\nhw->in_ifs_mode = true;\r\nif (hw->current_ifs_val < hw->ifs_max_val) {\r\nif (hw->current_ifs_val == 0)\r\nhw->current_ifs_val =\r\nhw->ifs_min_val;\r\nelse\r\nhw->current_ifs_val +=\r\nhw->ifs_step_size;\r\new32(AIT, hw->current_ifs_val);\r\n}\r\n}\r\n} else {\r\nif (hw->in_ifs_mode\r\n&& (hw->tx_packet_delta <= MIN_NUM_XMITS)) {\r\nhw->current_ifs_val = 0;\r\nhw->in_ifs_mode = false;\r\new32(AIT, 0);\r\n}\r\n}\r\n} else {\r\ne_dbg("Not in Adaptive IFS mode!\n");\r\n}\r\n}\r\nvoid e1000_get_bus_info(struct e1000_hw *hw)\r\n{\r\nu32 status;\r\nswitch (hw->mac_type) {\r\ncase e1000_82542_rev2_0:\r\ncase e1000_82542_rev2_1:\r\nhw->bus_type = e1000_bus_type_pci;\r\nhw->bus_speed = e1000_bus_speed_unknown;\r\nhw->bus_width = e1000_bus_width_unknown;\r\nbreak;\r\ndefault:\r\nstatus = er32(STATUS);\r\nhw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?\r\ne1000_bus_type_pcix : e1000_bus_type_pci;\r\nif (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {\r\nhw->bus_speed = (hw->bus_type == e1000_bus_type_pci) ?\r\ne1000_bus_speed_66 : e1000_bus_speed_120;\r\n} else if (hw->bus_type == e1000_bus_type_pci) {\r\nhw->bus_speed = (status & E1000_STATUS_PCI66) ?\r\ne1000_bus_speed_66 : e1000_bus_speed_33;\r\n} else {\r\nswitch (status & E1000_STATUS_PCIX_SPEED) {\r\ncase E1000_STATUS_PCIX_SPEED_66:\r\nhw->bus_speed = e1000_bus_speed_66;\r\nbreak;\r\ncase E1000_STATUS_PCIX_SPEED_100:\r\nhw->bus_speed = e1000_bus_speed_100;\r\nbreak;\r\ncase E1000_STATUS_PCIX_SPEED_133:\r\nhw->bus_speed = e1000_bus_speed_133;\r\nbreak;\r\ndefault:\r\nhw->bus_speed = e1000_bus_speed_reserved;\r\nbreak;\r\n}\r\n}\r\nhw->bus_width = (status & E1000_STATUS_BUS64) ?\r\ne1000_bus_width_64 : e1000_bus_width_32;\r\nbreak;\r\n}\r\n}\r\nstatic void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value)\r\n{\r\nunsigned long io_addr = hw->io_base;\r\nunsigned long io_data = hw->io_base + 4;\r\ne1000_io_write(hw, io_addr, offset);\r\ne1000_io_write(hw, io_data, value);\r\n}\r\nstatic s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,\r\nu16 *max_length)\r\n{\r\ns32 ret_val;\r\nu16 agc_value = 0;\r\nu16 i, phy_data;\r\nu16 cable_length;\r\n*min_length = *max_length = 0;\r\nif (hw->phy_type == e1000_phy_m88) {\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ncable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\r\nM88E1000_PSSR_CABLE_LENGTH_SHIFT;\r\nswitch (cable_length) {\r\ncase e1000_cable_length_50:\r\n*min_length = 0;\r\n*max_length = e1000_igp_cable_length_50;\r\nbreak;\r\ncase e1000_cable_length_50_80:\r\n*min_length = e1000_igp_cable_length_50;\r\n*max_length = e1000_igp_cable_length_80;\r\nbreak;\r\ncase e1000_cable_length_80_110:\r\n*min_length = e1000_igp_cable_length_80;\r\n*max_length = e1000_igp_cable_length_110;\r\nbreak;\r\ncase e1000_cable_length_110_140:\r\n*min_length = e1000_igp_cable_length_110;\r\n*max_length = e1000_igp_cable_length_140;\r\nbreak;\r\ncase e1000_cable_length_140:\r\n*min_length = e1000_igp_cable_length_140;\r\n*max_length = e1000_igp_cable_length_170;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_PHY;\r\n}\r\n} else if (hw->phy_type == e1000_phy_igp) {\r\nu16 cur_agc_value;\r\nu16 min_agc_value = IGP01E1000_AGC_LENGTH_TABLE_SIZE;\r\nstatic const u16 agc_reg_array[IGP01E1000_PHY_CHANNEL_NUM] = {\r\nIGP01E1000_PHY_AGC_A,\r\nIGP01E1000_PHY_AGC_B,\r\nIGP01E1000_PHY_AGC_C,\r\nIGP01E1000_PHY_AGC_D\r\n};\r\nfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\r\nret_val =\r\ne1000_read_phy_reg(hw, agc_reg_array[i], &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ncur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;\r\nif ((cur_agc_value >=\r\nIGP01E1000_AGC_LENGTH_TABLE_SIZE - 1)\r\n|| (cur_agc_value == 0))\r\nreturn -E1000_ERR_PHY;\r\nagc_value += cur_agc_value;\r\nif (min_agc_value > cur_agc_value)\r\nmin_agc_value = cur_agc_value;\r\n}\r\nif (agc_value <\r\nIGP01E1000_PHY_CHANNEL_NUM * e1000_igp_cable_length_50) {\r\nagc_value -= min_agc_value;\r\nagc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);\r\n} else {\r\nagc_value /= IGP01E1000_PHY_CHANNEL_NUM;\r\n}\r\n*min_length = ((e1000_igp_cable_length_table[agc_value] -\r\nIGP01E1000_AGC_RANGE) > 0) ?\r\n(e1000_igp_cable_length_table[agc_value] -\r\nIGP01E1000_AGC_RANGE) : 0;\r\n*max_length = e1000_igp_cable_length_table[agc_value] +\r\nIGP01E1000_AGC_RANGE;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_check_polarity(struct e1000_hw *hw,\r\ne1000_rev_polarity *polarity)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->phy_type == e1000_phy_m88) {\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n*polarity = ((phy_data & M88E1000_PSSR_REV_POLARITY) >>\r\nM88E1000_PSSR_REV_POLARITY_SHIFT) ?\r\ne1000_rev_polarity_reversed : e1000_rev_polarity_normal;\r\n} else if (hw->phy_type == e1000_phy_igp) {\r\nret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==\r\nIGP01E1000_PSSR_SPEED_1000MBPS) {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n*polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ?\r\ne1000_rev_polarity_reversed :\r\ne1000_rev_polarity_normal;\r\n} else {\r\n*polarity =\r\n(phy_data & IGP01E1000_PSSR_POLARITY_REVERSED) ?\r\ne1000_rev_polarity_reversed :\r\ne1000_rev_polarity_normal;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_check_downshift(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->phy_type == e1000_phy_igp) {\r\nret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->speed_downgraded =\r\n(phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;\r\n} else if (hw->phy_type == e1000_phy_m88) {\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>\r\nM88E1000_PSSR_DOWNSHIFT_SHIFT;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_1000Mb_check_cable_length(struct e1000_hw *hw)\r\n{\r\nu16 min_length, max_length;\r\nu16 phy_data, i;\r\ns32 ret_val;\r\nret_val = e1000_get_cable_length(hw, &min_length, &max_length);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->dsp_config_state != e1000_dsp_config_enabled)\r\nreturn 0;\r\nif (min_length >= e1000_igp_cable_length_50) {\r\nfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\r\nret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;\r\nret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nhw->dsp_config_state = e1000_dsp_config_activated;\r\n} else {\r\nu16 ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_20;\r\nu32 idle_errs = 0;\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (i = 0; i < ffe_idle_err_timeout; i++) {\r\nudelay(1000);\r\nret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nidle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);\r\nif (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {\r\nhw->ffe_config_state = e1000_ffe_config_active;\r\nret_val = e1000_write_phy_reg(hw,\r\nIGP01E1000_PHY_DSP_FFE,\r\nIGP01E1000_PHY_DSP_FFE_CM_CP);\r\nif (ret_val)\r\nreturn ret_val;\r\nbreak;\r\n}\r\nif (idle_errs)\r\nffe_idle_err_timeout =\r\nFFE_IDLE_ERR_COUNT_TIMEOUT_100;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw, bool link_up)\r\n{\r\ns32 ret_val;\r\nu16 phy_data, phy_saved_data, speed, duplex, i;\r\nif (hw->phy_type != e1000_phy_igp)\r\nreturn E1000_SUCCESS;\r\nif (link_up) {\r\nret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val) {\r\ne_dbg("Error getting link speed and duplex\n");\r\nreturn ret_val;\r\n}\r\nif (speed == SPEED_1000) {\r\nret_val = e1000_1000Mb_check_cable_length(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n} else {\r\nif (hw->dsp_config_state == e1000_dsp_config_activated) {\r\nret_val =\r\ne1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(20);\r\nret_val = e1000_write_phy_reg(hw, 0x0000,\r\nIGP01E1000_IEEE_FORCE_GIGA);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {\r\nret_val =\r\ne1000_read_phy_reg(hw, dsp_reg_array[i],\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;\r\nphy_data |= IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;\r\nret_val =\r\ne1000_write_phy_reg(hw, dsp_reg_array[i],\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000_write_phy_reg(hw, 0x0000,\r\nIGP01E1000_IEEE_RESTART_AUTONEG);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(20);\r\nret_val =\r\ne1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->dsp_config_state = e1000_dsp_config_enabled;\r\n}\r\nif (hw->ffe_config_state == e1000_ffe_config_active) {\r\nret_val =\r\ne1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(20);\r\nret_val = e1000_write_phy_reg(hw, 0x0000,\r\nIGP01E1000_IEEE_FORCE_GIGA);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,\r\nIGP01E1000_PHY_DSP_FFE_DEFAULT);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, 0x0000,\r\nIGP01E1000_IEEE_RESTART_AUTONEG);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(20);\r\nret_val =\r\ne1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->ffe_config_state = e1000_ffe_config_enabled;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_set_phy_mode(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 eeprom_data;\r\nif ((hw->mac_type == e1000_82545_rev_3) &&\r\n(hw->media_type == e1000_media_type_copper)) {\r\nret_val =\r\ne1000_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1,\r\n&eeprom_data);\r\nif (ret_val) {\r\nreturn ret_val;\r\n}\r\nif ((eeprom_data != EEPROM_RESERVED_WORD) &&\r\n(eeprom_data & EEPROM_PHY_CLASS_A)) {\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,\r\n0x000B);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,\r\n0x8104);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy_reset_disable = false;\r\n}\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_set_d3_lplu_state(struct e1000_hw *hw, bool active)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nif (hw->phy_type != e1000_phy_igp)\r\nreturn E1000_SUCCESS;\r\nif (hw->mac_type == e1000_82541_rev_2\r\n|| hw->mac_type == e1000_82547_rev_2) {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nif (!active) {\r\nif (hw->mac_type == e1000_82541_rev_2 ||\r\nhw->mac_type == e1000_82547_rev_2) {\r\nphy_data &= ~IGP01E1000_GMII_FLEX_SPD;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nif (hw->smart_speed == e1000_smart_speed_on) {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if (hw->smart_speed == e1000_smart_speed_off) {\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n} else if ((hw->autoneg_advertised == AUTONEG_ADVERTISE_SPEED_DEFAULT)\r\n|| (hw->autoneg_advertised == AUTONEG_ADVERTISE_10_ALL)\r\n|| (hw->autoneg_advertised ==\r\nAUTONEG_ADVERTISE_10_100_ALL)) {\r\nif (hw->mac_type == e1000_82541_rev_2 ||\r\nhw->mac_type == e1000_82547_rev_2) {\r\nphy_data |= IGP01E1000_GMII_FLEX_SPD;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val =\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val =\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\nphy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_set_vco_speed(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 default_page = 0;\r\nu16 phy_data;\r\nswitch (hw->mac_type) {\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\nbreak;\r\ndefault:\r\nreturn E1000_SUCCESS;\r\n}\r\nret_val =\r\ne1000_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~M88E1000_PHY_VCO_REG_BIT8;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data |= M88E1000_PHY_VCO_REG_BIT11;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn E1000_SUCCESS;\r\n}\r\nu32 e1000_enable_mng_pass_thru(struct e1000_hw *hw)\r\n{\r\nu32 manc;\r\nif (hw->asf_firmware_present) {\r\nmanc = er32(MANC);\r\nif (!(manc & E1000_MANC_RCV_TCO_EN) ||\r\n!(manc & E1000_MANC_EN_MAC_ADDR_FILTER))\r\nreturn false;\r\nif ((manc & E1000_MANC_SMBUS_EN) && !(manc & E1000_MANC_ASF_EN))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 mii_status_reg;\r\nu16 i;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (i = PHY_FORCE_TIME; i > 0; i--) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0)\r\nbreak;\r\nmsleep(100);\r\n}\r\nmsleep(1000);\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(50);\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(50);\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);\r\nif (ret_val)\r\nreturn ret_val;\r\nmsleep(50);\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (i = PHY_FORCE_TIME; i > 0; i--) {\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (mii_status_reg & MII_SR_LINK_STATUS)\r\nbreak;\r\nmsleep(100);\r\n}\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_get_auto_rd_done(struct e1000_hw *hw)\r\n{\r\nmsleep(5);\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_get_phy_cfg_done(struct e1000_hw *hw)\r\n{\r\nmsleep(10);\r\nreturn E1000_SUCCESS;\r\n}
