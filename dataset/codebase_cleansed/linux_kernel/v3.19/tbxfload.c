acpi_status __init acpi_load_tables(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_load_tables);\r\nstatus = acpi_tb_load_namespace();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While loading namespace from ACPI tables"));\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status acpi_tb_load_namespace(void)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nstruct acpi_table_header *new_dsdt;\r\nACPI_FUNCTION_TRACE(tb_load_namespace);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (!acpi_gbl_root_table_list.current_table_count ||\r\n!ACPI_COMPARE_NAME(&\r\n(acpi_gbl_root_table_list.\r\ntables[ACPI_TABLE_INDEX_DSDT].signature),\r\nACPI_SIG_DSDT)\r\n||\r\nACPI_FAILURE(acpi_tb_validate_table\r\n(&acpi_gbl_root_table_list.\r\ntables[ACPI_TABLE_INDEX_DSDT]))) {\r\nstatus = AE_NO_ACPI_TABLES;\r\ngoto unlock_and_exit;\r\n}\r\nacpi_gbl_DSDT =\r\nacpi_gbl_root_table_list.tables[ACPI_TABLE_INDEX_DSDT].pointer;\r\nif (acpi_gbl_copy_dsdt_locally) {\r\nnew_dsdt = acpi_tb_copy_dsdt(ACPI_TABLE_INDEX_DSDT);\r\nif (new_dsdt) {\r\nacpi_gbl_DSDT = new_dsdt;\r\n}\r\n}\r\nACPI_MEMCPY(&acpi_gbl_original_dsdt_header, acpi_gbl_DSDT,\r\nsizeof(struct acpi_table_header));\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nstatus = acpi_ns_load_table(ACPI_TABLE_INDEX_DSDT, acpi_gbl_root_node);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\r\nif ((!ACPI_COMPARE_NAME\r\n(&(acpi_gbl_root_table_list.tables[i].signature),\r\nACPI_SIG_SSDT)\r\n&&\r\n!ACPI_COMPARE_NAME(&\r\n(acpi_gbl_root_table_list.tables[i].\r\nsignature), ACPI_SIG_PSDT))\r\n||\r\nACPI_FAILURE(acpi_tb_validate_table\r\n(&acpi_gbl_root_table_list.tables[i]))) {\r\ncontinue;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n(void)acpi_ns_load_table(i, acpi_gbl_root_node);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\n}\r\nACPI_INFO((AE_INFO, "All ACPI Tables successfully acquired"));\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status __init\r\nacpi_install_table(acpi_physical_address address, u8 physical)\r\n{\r\nacpi_status status;\r\nu8 flags;\r\nu32 table_index;\r\nACPI_FUNCTION_TRACE(acpi_install_table);\r\nif (physical) {\r\nflags = ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL;\r\n} else {\r\nflags = ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL;\r\n}\r\nstatus = acpi_tb_install_standard_table(address, flags,\r\nFALSE, FALSE, &table_index);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_load_table(struct acpi_table_header *table)\r\n{\r\nacpi_status status;\r\nu32 table_index;\r\nACPI_FUNCTION_TRACE(acpi_load_table);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nACPI_INFO((AE_INFO, "Host-directed Dynamic ACPI Table Load:"));\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nstatus = acpi_tb_install_standard_table(ACPI_PTR_TO_PHYSADDR(table),\r\nACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL,\r\nTRUE, FALSE, &table_index);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nstatus =\r\nacpi_tb_validate_table(&acpi_gbl_root_table_list.\r\ntables[table_index]);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_load_table(table_index, acpi_gbl_root_node);\r\nif (acpi_gbl_table_handler) {\r\n(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_LOAD, table,\r\nacpi_gbl_table_handler_context);\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_unload_parent_table(acpi_handle object)\r\n{\r\nstruct acpi_namespace_node *node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, object);\r\nacpi_status status = AE_NOT_EXIST;\r\nacpi_owner_id owner_id;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_unload_parent_table);\r\nif (!object) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nowner_id = node->owner_id;\r\nif (!owner_id) {\r\nreturn_ACPI_STATUS(AE_TYPE);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nif (owner_id != acpi_gbl_root_table_list.tables[i].owner_id) {\r\ncontinue;\r\n}\r\nif (ACPI_COMPARE_NAME\r\n(acpi_gbl_root_table_list.tables[i].signature.ascii,\r\nACPI_SIG_DSDT)) {\r\nstatus = AE_TYPE;\r\nbreak;\r\n}\r\nif (!acpi_tb_is_table_loaded(i)) {\r\nstatus = AE_NOT_EXIST;\r\nbreak;\r\n}\r\nif (acpi_gbl_table_handler) {\r\n(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,\r\nacpi_gbl_root_table_list.\r\ntables[i].pointer,\r\nacpi_gbl_table_handler_context);\r\n}\r\nstatus = acpi_tb_delete_namespace_by_owner(i);\r\nif (ACPI_FAILURE(status)) {\r\nbreak;\r\n}\r\nstatus = acpi_tb_release_owner_id(i);\r\nacpi_tb_set_table_loaded_flag(i, FALSE);\r\nbreak;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nreturn_ACPI_STATUS(status);\r\n}
