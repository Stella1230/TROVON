static int backlight_power_set(struct pm860x_chip *chip, int port,\r\nint on)\r\n{\r\nint ret = -EINVAL;\r\nswitch (port) {\r\ncase 0:\r\nret = on ? pm8606_osc_enable(chip, WLED1_DUTY) :\r\npm8606_osc_disable(chip, WLED1_DUTY);\r\nbreak;\r\ncase 1:\r\nret = on ? pm8606_osc_enable(chip, WLED2_DUTY) :\r\npm8606_osc_disable(chip, WLED2_DUTY);\r\nbreak;\r\ncase 2:\r\nret = on ? pm8606_osc_enable(chip, WLED3_DUTY) :\r\npm8606_osc_disable(chip, WLED3_DUTY);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm860x_backlight_set(struct backlight_device *bl, int brightness)\r\n{\r\nstruct pm860x_backlight_data *data = bl_get_data(bl);\r\nstruct pm860x_chip *chip = data->chip;\r\nunsigned char value;\r\nint ret;\r\nif (brightness > MAX_BRIGHTNESS)\r\nvalue = MAX_BRIGHTNESS;\r\nelse\r\nvalue = brightness;\r\nif (brightness)\r\nbacklight_power_set(chip, data->port, 1);\r\nret = pm860x_reg_write(data->i2c, data->reg_duty_cycle, value);\r\nif (ret < 0)\r\ngoto out;\r\nif ((data->current_brightness == 0) && brightness) {\r\nif (data->iset) {\r\nret = pm860x_set_bits(data->i2c, data->reg_current,\r\nCURRENT_BITMASK, data->iset);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (data->pwm) {\r\nret = pm860x_set_bits(data->i2c, PM8606_PWM,\r\nPM8606_PWM_FREQ_MASK, data->pwm);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (brightness == MAX_BRIGHTNESS) {\r\nret = pm860x_set_bits(data->i2c, data->reg_always_on,\r\nPM8606_WLED_ON, PM8606_WLED_ON);\r\n}\r\n} else {\r\nif (brightness == MAX_BRIGHTNESS) {\r\nret = pm860x_set_bits(data->i2c, data->reg_always_on,\r\nPM8606_WLED_ON, PM8606_WLED_ON);\r\n} else {\r\nret = pm860x_set_bits(data->i2c, data->reg_always_on,\r\nPM8606_WLED_ON, 0);\r\n}\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nif (brightness == 0)\r\nbacklight_power_set(chip, data->port, 0);\r\ndev_dbg(chip->dev, "set brightness %d\n", value);\r\ndata->current_brightness = value;\r\nreturn 0;\r\nout:\r\ndev_dbg(chip->dev, "set brightness %d failure with return value: %d\n",\r\nvalue, ret);\r\nreturn ret;\r\n}\r\nstatic int pm860x_backlight_update_status(struct backlight_device *bl)\r\n{\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.state & BL_CORE_SUSPENDED)\r\nbrightness = 0;\r\nreturn pm860x_backlight_set(bl, brightness);\r\n}\r\nstatic int pm860x_backlight_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct pm860x_backlight_data *data = bl_get_data(bl);\r\nstruct pm860x_chip *chip = data->chip;\r\nint ret;\r\nret = pm860x_reg_read(data->i2c, data->reg_duty_cycle);\r\nif (ret < 0)\r\ngoto out;\r\ndata->current_brightness = ret;\r\ndev_dbg(chip->dev, "get brightness %d\n", data->current_brightness);\r\nreturn data->current_brightness;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int pm860x_backlight_dt_init(struct platform_device *pdev,\r\nstruct pm860x_backlight_data *data,\r\nchar *name)\r\n{\r\nstruct device_node *nproot, *np;\r\nint iset = 0;\r\nnproot = of_node_get(pdev->dev.parent->of_node);\r\nif (!nproot)\r\nreturn -ENODEV;\r\nnproot = of_find_node_by_name(nproot, "backlights");\r\nif (!nproot) {\r\ndev_err(&pdev->dev, "failed to find backlights node\n");\r\nreturn -ENODEV;\r\n}\r\nfor_each_child_of_node(nproot, np) {\r\nif (!of_node_cmp(np->name, name)) {\r\nof_property_read_u32(np, "marvell,88pm860x-iset",\r\n&iset);\r\ndata->iset = PM8606_WLED_CURRENT(iset);\r\nof_property_read_u32(np, "marvell,88pm860x-pwm",\r\n&data->pwm);\r\nbreak;\r\n}\r\n}\r\nof_node_put(nproot);\r\nreturn 0;\r\n}\r\nstatic int pm860x_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct pm860x_backlight_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct pm860x_backlight_data *data;\r\nstruct backlight_device *bl;\r\nstruct resource *res;\r\nstruct backlight_properties props;\r\nchar name[MFD_NAME_SIZE];\r\nint ret = 0;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_backlight_data),\r\nGFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_REG, "duty cycle");\r\nif (!res) {\r\ndev_err(&pdev->dev, "No REG resource for duty cycle\n");\r\nreturn -ENXIO;\r\n}\r\ndata->reg_duty_cycle = res->start;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_REG, "always on");\r\nif (!res) {\r\ndev_err(&pdev->dev, "No REG resource for always on\n");\r\nreturn -ENXIO;\r\n}\r\ndata->reg_always_on = res->start;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_REG, "current");\r\nif (!res) {\r\ndev_err(&pdev->dev, "No REG resource for current\n");\r\nreturn -ENXIO;\r\n}\r\ndata->reg_current = res->start;\r\nmemset(name, 0, MFD_NAME_SIZE);\r\nsprintf(name, "backlight-%d", pdev->id);\r\ndata->port = pdev->id;\r\ndata->chip = chip;\r\ndata->i2c = (chip->id == CHIP_PM8606) ? chip->client : chip->companion;\r\ndata->current_brightness = MAX_BRIGHTNESS;\r\nif (pm860x_backlight_dt_init(pdev, data, name)) {\r\nif (pdata) {\r\ndata->pwm = pdata->pwm;\r\ndata->iset = pdata->iset;\r\n}\r\n}\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nbl = devm_backlight_device_register(&pdev->dev, name, &pdev->dev, data,\r\n&pm860x_backlight_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\nbl->props.brightness = MAX_BRIGHTNESS;\r\nplatform_set_drvdata(pdev, bl);\r\nret = pm860x_backlight_get_brightness(bl);\r\nif (ret < 0)\r\nreturn ret;\r\nbacklight_update_status(bl);\r\nreturn 0;\r\n}
