struct page *balloon_page_enqueue(struct balloon_dev_info *b_dev_info)\r\n{\r\nunsigned long flags;\r\nstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\r\n__GFP_NOMEMALLOC | __GFP_NORETRY);\r\nif (!page)\r\nreturn NULL;\r\nBUG_ON(!trylock_page(page));\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nballoon_page_insert(b_dev_info, page);\r\n__count_vm_event(BALLOON_INFLATE);\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nunlock_page(page);\r\nreturn page;\r\n}\r\nstruct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\r\n{\r\nstruct page *page, *tmp;\r\nunsigned long flags;\r\nbool dequeued_page;\r\ndequeued_page = false;\r\nlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\r\nif (trylock_page(page)) {\r\n#ifdef CONFIG_BALLOON_COMPACTION\r\nif (!PagePrivate(page)) {\r\nunlock_page(page);\r\ncontinue;\r\n}\r\n#endif\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nballoon_page_delete(page);\r\n__count_vm_event(BALLOON_DEFLATE);\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nunlock_page(page);\r\ndequeued_page = true;\r\nbreak;\r\n}\r\n}\r\nif (!dequeued_page) {\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nif (unlikely(list_empty(&b_dev_info->pages) &&\r\n!b_dev_info->isolated_pages))\r\nBUG();\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\npage = NULL;\r\n}\r\nreturn page;\r\n}\r\nstatic inline void __isolate_balloon_page(struct page *page)\r\n{\r\nstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nClearPagePrivate(page);\r\nlist_del(&page->lru);\r\nb_dev_info->isolated_pages++;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\n}\r\nstatic inline void __putback_balloon_page(struct page *page)\r\n{\r\nstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nSetPagePrivate(page);\r\nlist_add(&page->lru, &b_dev_info->pages);\r\nb_dev_info->isolated_pages--;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\n}\r\nbool balloon_page_isolate(struct page *page)\r\n{\r\nif (likely(get_page_unless_zero(page))) {\r\nif (likely(trylock_page(page))) {\r\nif (balloon_page_movable(page)) {\r\n__isolate_balloon_page(page);\r\nunlock_page(page);\r\nreturn true;\r\n}\r\nunlock_page(page);\r\n}\r\nput_page(page);\r\n}\r\nreturn false;\r\n}\r\nvoid balloon_page_putback(struct page *page)\r\n{\r\nlock_page(page);\r\nif (__is_movable_balloon_page(page)) {\r\n__putback_balloon_page(page);\r\nput_page(page);\r\n} else {\r\nWARN_ON(1);\r\ndump_page(page, "not movable balloon page");\r\n}\r\nunlock_page(page);\r\n}\r\nint balloon_page_migrate(struct page *newpage,\r\nstruct page *page, enum migrate_mode mode)\r\n{\r\nstruct balloon_dev_info *balloon = balloon_page_device(page);\r\nint rc = -EAGAIN;\r\nBUG_ON(!trylock_page(newpage));\r\nif (WARN_ON(!__is_movable_balloon_page(page))) {\r\ndump_page(page, "not movable balloon page");\r\nunlock_page(newpage);\r\nreturn rc;\r\n}\r\nif (balloon && balloon->migratepage)\r\nrc = balloon->migratepage(balloon, newpage, page, mode);\r\nunlock_page(newpage);\r\nreturn rc;\r\n}
