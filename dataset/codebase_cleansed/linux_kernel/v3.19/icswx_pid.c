static int new_cop_pid(struct ida *ida, int min_id, int max_id,\r\nspinlock_t *lock)\r\n{\r\nint index;\r\nint err;\r\nagain:\r\nif (!ida_pre_get(ida, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nspin_lock(lock);\r\nerr = ida_get_new_above(ida, min_id, &index);\r\nspin_unlock(lock);\r\nif (err == -EAGAIN)\r\ngoto again;\r\nelse if (err)\r\nreturn err;\r\nif (index > max_id) {\r\nspin_lock(lock);\r\nida_remove(ida, index);\r\nspin_unlock(lock);\r\nreturn -ENOMEM;\r\n}\r\nreturn index;\r\n}\r\nint get_cop_pid(struct mm_struct *mm)\r\n{\r\nint pid;\r\nif (mm->context.cop_pid == COP_PID_NONE) {\r\npid = new_cop_pid(&cop_ida, COP_PID_MIN, COP_PID_MAX,\r\n&mmu_context_acop_lock);\r\nif (pid >= 0)\r\nmm->context.cop_pid = pid;\r\n}\r\nreturn mm->context.cop_pid;\r\n}\r\nint disable_cop_pid(struct mm_struct *mm)\r\n{\r\nint free_pid = COP_PID_NONE;\r\nif ((!mm->context.acop) && (mm->context.cop_pid != COP_PID_NONE)) {\r\nfree_pid = mm->context.cop_pid;\r\nmm->context.cop_pid = COP_PID_NONE;\r\n}\r\nreturn free_pid;\r\n}\r\nvoid free_cop_pid(int free_pid)\r\n{\r\nspin_lock(&mmu_context_acop_lock);\r\nida_remove(&cop_ida, free_pid);\r\nspin_unlock(&mmu_context_acop_lock);\r\n}
