static inline struct atmel_pwm_chip *to_atmel_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct atmel_pwm_chip, chip);\r\n}\r\nstatic inline u32 atmel_pwm_readl(struct atmel_pwm_chip *chip,\r\nunsigned long offset)\r\n{\r\nreturn readl_relaxed(chip->base + offset);\r\n}\r\nstatic inline void atmel_pwm_writel(struct atmel_pwm_chip *chip,\r\nunsigned long offset, unsigned long val)\r\n{\r\nwritel_relaxed(val, chip->base + offset);\r\n}\r\nstatic inline u32 atmel_pwm_ch_readl(struct atmel_pwm_chip *chip,\r\nunsigned int ch, unsigned long offset)\r\n{\r\nunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\r\nreturn readl_relaxed(chip->base + base + offset);\r\n}\r\nstatic inline void atmel_pwm_ch_writel(struct atmel_pwm_chip *chip,\r\nunsigned int ch, unsigned long offset,\r\nunsigned long val)\r\n{\r\nunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\r\nwritel_relaxed(val, chip->base + base + offset);\r\n}\r\nstatic int atmel_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nunsigned long prd, dty;\r\nunsigned long long div;\r\nunsigned int pres = 0;\r\nu32 val;\r\nint ret;\r\nif (test_bit(PWMF_ENABLED, &pwm->flags) && (period_ns != pwm->period)) {\r\ndev_err(chip->dev, "cannot change PWM period while enabled\n");\r\nreturn -EBUSY;\r\n}\r\ndiv = (unsigned long long)clk_get_rate(atmel_pwm->clk) * period_ns;\r\ndo_div(div, NSEC_PER_SEC);\r\nwhile (div > PWM_MAX_PRD) {\r\ndiv >>= 1;\r\npres++;\r\n}\r\nif (pres > PRD_MAX_PRES) {\r\ndev_err(chip->dev, "pres exceeds the maximum value\n");\r\nreturn -EINVAL;\r\n}\r\nprd = div;\r\ndiv *= duty_ns;\r\ndo_div(div, period_ns);\r\ndty = prd - div;\r\nret = clk_enable(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\nval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\r\nval = (val & ~PWM_CMR_CPRE_MSK) | (pres & PWM_CMR_CPRE_MSK);\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\r\natmel_pwm->config(chip, pwm, dty, prd);\r\nclk_disable(atmel_pwm->clk);\r\nreturn ret;\r\n}\r\nstatic void atmel_pwm_config_v1(struct pwm_chip *chip, struct pwm_device *pwm,\r\nunsigned long dty, unsigned long prd)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nunsigned int val;\r\nif (test_bit(PWMF_ENABLED, &pwm->flags)) {\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV1_CUPD, dty);\r\nval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\r\nval &= ~PWM_CMR_UPD_CDTY;\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\r\n} else {\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV1_CDTY, dty);\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV1_CPRD, prd);\r\n}\r\n}\r\nstatic void atmel_pwm_config_v2(struct pwm_chip *chip, struct pwm_device *pwm,\r\nunsigned long dty, unsigned long prd)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nif (test_bit(PWMF_ENABLED, &pwm->flags)) {\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV2_CDTYUPD, dty);\r\n} else {\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV2_CDTY, dty);\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWMV2_CPRD, prd);\r\n}\r\n}\r\nstatic int atmel_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nu32 val;\r\nint ret;\r\nval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\r\nif (polarity == PWM_POLARITY_NORMAL)\r\nval &= ~PWM_CMR_CPOL;\r\nelse\r\nval |= PWM_CMR_CPOL;\r\nret = clk_enable(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\r\nclk_disable(atmel_pwm->clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nint ret;\r\nret = clk_enable(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\natmel_pwm_writel(atmel_pwm, PWM_ENA, 1 << pwm->hwpwm);\r\nreturn 0;\r\n}\r\nstatic void atmel_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\natmel_pwm_writel(atmel_pwm, PWM_DIS, 1 << pwm->hwpwm);\r\nclk_disable(atmel_pwm->clk);\r\n}\r\nstatic inline const struct atmel_pwm_data *\r\natmel_pwm_get_driver_data(struct platform_device *pdev)\r\n{\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(atmel_pwm_dt_ids, &pdev->dev);\r\nif (!match)\r\nreturn NULL;\r\nreturn match->data;\r\n} else {\r\nconst struct platform_device_id *id;\r\nid = platform_get_device_id(pdev);\r\nreturn (struct atmel_pwm_data *)id->driver_data;\r\n}\r\n}\r\nstatic int atmel_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct atmel_pwm_data *data;\r\nstruct atmel_pwm_chip *atmel_pwm;\r\nstruct resource *res;\r\nint ret;\r\ndata = atmel_pwm_get_driver_data(pdev);\r\nif (!data)\r\nreturn -ENODEV;\r\natmel_pwm = devm_kzalloc(&pdev->dev, sizeof(*atmel_pwm), GFP_KERNEL);\r\nif (!atmel_pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\natmel_pwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(atmel_pwm->base))\r\nreturn PTR_ERR(atmel_pwm->base);\r\natmel_pwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(atmel_pwm->clk))\r\nreturn PTR_ERR(atmel_pwm->clk);\r\nret = clk_prepare(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to prepare PWM clock\n");\r\nreturn ret;\r\n}\r\natmel_pwm->chip.dev = &pdev->dev;\r\natmel_pwm->chip.ops = &atmel_pwm_ops;\r\nif (pdev->dev.of_node) {\r\natmel_pwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\natmel_pwm->chip.of_pwm_n_cells = 3;\r\n}\r\natmel_pwm->chip.base = -1;\r\natmel_pwm->chip.npwm = 4;\r\natmel_pwm->chip.can_sleep = true;\r\natmel_pwm->config = data->config;\r\nret = pwmchip_add(&atmel_pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip %d\n", ret);\r\ngoto unprepare_clk;\r\n}\r\nplatform_set_drvdata(pdev, atmel_pwm);\r\nreturn ret;\r\nunprepare_clk:\r\nclk_unprepare(atmel_pwm->clk);\r\nreturn ret;\r\n}\r\nstatic int atmel_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = platform_get_drvdata(pdev);\r\nclk_unprepare(atmel_pwm->clk);\r\nreturn pwmchip_remove(&atmel_pwm->chip);\r\n}
