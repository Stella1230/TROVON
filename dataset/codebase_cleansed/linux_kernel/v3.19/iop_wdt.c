static unsigned long iop_watchdog_timeout(void)\r\n{\r\nreturn (0xffffffffUL / get_iop_tick_rate());\r\n}\r\nstatic int wdt_supports_disable(void)\r\n{\r\nint can_disable;\r\nif (IOP_WDTCR_EN_ARM != IOP_WDTCR_DIS_ARM)\r\ncan_disable = 1;\r\nelse\r\ncan_disable = 0;\r\nreturn can_disable;\r\n}\r\nstatic void wdt_enable(void)\r\n{\r\nspin_lock(&wdt_lock);\r\nwrite_wdtcr(IOP_WDTCR_EN_ARM);\r\nwrite_wdtcr(IOP_WDTCR_EN);\r\nspin_unlock(&wdt_lock);\r\n}\r\nstatic int wdt_disable(void)\r\n{\r\nif (wdt_supports_disable()) {\r\nspin_lock(&wdt_lock);\r\nwrite_wdtcr(IOP_WDTCR_DIS_ARM);\r\nwrite_wdtcr(IOP_WDTCR_DIS);\r\nclear_bit(WDT_ENABLED, &wdt_status);\r\nspin_unlock(&wdt_lock);\r\npr_info("Disabled\n");\r\nreturn 0;\r\n} else\r\nreturn 1;\r\n}\r\nstatic int iop_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_IN_USE, &wdt_status))\r\nreturn -EBUSY;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nwdt_enable();\r\nset_bit(WDT_ENABLED, &wdt_status);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t iop_wdt_write(struct file *file, const char *data, size_t len,\r\nloff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\n}\r\n}\r\nwdt_enable();\r\n}\r\nreturn len;\r\n}\r\nstatic long iop_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint options;\r\nint ret = -ENOTTY;\r\nint __user *argp = (int __user *)arg;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, argp);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(boot_status, argp);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(options, (int *)arg))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nif (!nowayout) {\r\nif (wdt_disable() == 0) {\r\nset_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nret = 0;\r\n} else\r\nret = -ENXIO;\r\n} else\r\nret = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nwdt_enable();\r\nret = 0;\r\n}\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_enable();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(iop_watchdog_timeout(), argp);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int iop_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nint state = 1;\r\nif (test_bit(WDT_OK_TO_CLOSE, &wdt_status))\r\nif (test_bit(WDT_ENABLED, &wdt_status))\r\nstate = wdt_disable();\r\nif (state != 0) {\r\nwdt_enable();\r\npr_crit("Device closed unexpectedly - reset in %lu seconds\n",\r\niop_watchdog_timeout());\r\n}\r\nclear_bit(WDT_IN_USE, &wdt_status);\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic int __init iop_wdt_init(void)\r\n{\r\nint ret;\r\nboot_status = (read_rcsr() & IOP_RCSR_WDT) ? WDIOF_CARDRESET : 0;\r\nwrite_wdtsr(IOP13XX_WDTCR_IB_RESET);\r\nret = misc_register(&iop_wdt_miscdev);\r\nif (ret == 0)\r\npr_info("timeout %lu sec\n", iop_watchdog_timeout());\r\nreturn ret;\r\n}\r\nstatic void __exit iop_wdt_exit(void)\r\n{\r\nmisc_deregister(&iop_wdt_miscdev);\r\n}
