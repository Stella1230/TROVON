static s32 i2c_nuvoton_read_buf(struct i2c_client *client, u8 offset, u8 size,\r\nu8 *data)\r\n{\r\ns32 status;\r\nstatus = i2c_smbus_read_i2c_block_data(client, offset, size, data);\r\ndev_dbg(&client->dev,\r\n"%s(offset=%u size=%u data=%*ph) -> sts=%d\n", __func__,\r\noffset, size, (int)size, data, status);\r\nreturn status;\r\n}\r\nstatic s32 i2c_nuvoton_write_buf(struct i2c_client *client, u8 offset, u8 size,\r\nu8 *data)\r\n{\r\ns32 status;\r\nstatus = i2c_smbus_write_i2c_block_data(client, offset, size, data);\r\ndev_dbg(&client->dev,\r\n"%s(offset=%u size=%u data=%*ph) -> sts=%d\n", __func__,\r\noffset, size, (int)size, data, status);\r\nreturn status;\r\n}\r\nstatic u8 i2c_nuvoton_read_status(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client = to_i2c_client(chip->dev);\r\ns32 status;\r\nu8 data;\r\nstatus = i2c_nuvoton_read_buf(client, TPM_STS, 1, &data);\r\nif (status <= 0) {\r\ndev_err(chip->dev, "%s() error return %d\n", __func__,\r\nstatus);\r\ndata = TPM_STS_ERR_VAL;\r\n}\r\nreturn data;\r\n}\r\nstatic s32 i2c_nuvoton_write_status(struct i2c_client *client, u8 data)\r\n{\r\ns32 status;\r\nint i;\r\nfor (i = 0, status = -1; i < TPM_I2C_RETRY_COUNT && status < 0; i++) {\r\nstatus = i2c_nuvoton_write_buf(client, TPM_STS, 1, &data);\r\nmsleep(TPM_I2C_BUS_DELAY);\r\n}\r\nreturn status;\r\n}\r\nstatic void i2c_nuvoton_ready(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client = to_i2c_client(chip->dev);\r\ns32 status;\r\nstatus = i2c_nuvoton_write_status(client, TPM_STS_COMMAND_READY);\r\nif (status < 0)\r\ndev_err(chip->dev,\r\n"%s() fail to write TPM_STS.commandReady\n", __func__);\r\n}\r\nstatic int i2c_nuvoton_get_burstcount(struct i2c_client *client,\r\nstruct tpm_chip *chip)\r\n{\r\nunsigned long stop = jiffies + chip->vendor.timeout_d;\r\ns32 status;\r\nint burst_count = -1;\r\nu8 data;\r\ndo {\r\nstatus = i2c_nuvoton_read_buf(client, TPM_BURST_COUNT, 1,\r\n&data);\r\nif (status > 0 && data > 0) {\r\nburst_count = min_t(u8, TPM_I2C_MAX_BUF_SIZE, data);\r\nbreak;\r\n}\r\nmsleep(TPM_I2C_BUS_DELAY);\r\n} while (time_before(jiffies, stop));\r\nreturn burst_count;\r\n}\r\nstatic bool i2c_nuvoton_check_status(struct tpm_chip *chip, u8 mask, u8 value)\r\n{\r\nu8 status = i2c_nuvoton_read_status(chip);\r\nreturn (status != TPM_STS_ERR_VAL) && ((status & mask) == value);\r\n}\r\nstatic int i2c_nuvoton_wait_for_stat(struct tpm_chip *chip, u8 mask, u8 value,\r\nu32 timeout, wait_queue_head_t *queue)\r\n{\r\nif (chip->vendor.irq && queue) {\r\ns32 rc;\r\nstruct priv_data *priv = chip->vendor.priv;\r\nunsigned int cur_intrs = priv->intrs;\r\nenable_irq(chip->vendor.irq);\r\nrc = wait_event_interruptible_timeout(*queue,\r\ncur_intrs != priv->intrs,\r\ntimeout);\r\nif (rc > 0)\r\nreturn 0;\r\n} else {\r\nunsigned long ten_msec, stop;\r\nbool status_valid;\r\nstatus_valid = i2c_nuvoton_check_status(chip, mask, value);\r\nif (status_valid)\r\nreturn 0;\r\nten_msec = jiffies + msecs_to_jiffies(TPM_I2C_RETRY_DELAY_LONG);\r\nstop = jiffies + timeout;\r\ndo {\r\nif (time_before(jiffies, ten_msec))\r\nmsleep(TPM_I2C_RETRY_DELAY_SHORT);\r\nelse\r\nmsleep(TPM_I2C_RETRY_DELAY_LONG);\r\nstatus_valid = i2c_nuvoton_check_status(chip, mask,\r\nvalue);\r\nif (status_valid)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\n}\r\ndev_err(chip->dev, "%s(%02x, %02x) -> timeout\n", __func__, mask,\r\nvalue);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int i2c_nuvoton_wait_for_data_avail(struct tpm_chip *chip, u32 timeout,\r\nwait_queue_head_t *queue)\r\n{\r\nreturn i2c_nuvoton_wait_for_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\ntimeout, queue);\r\n}\r\nstatic int i2c_nuvoton_recv_data(struct i2c_client *client,\r\nstruct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\ns32 rc;\r\nint burst_count, bytes2read, size = 0;\r\nwhile (size < count &&\r\ni2c_nuvoton_wait_for_data_avail(chip,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue) == 0) {\r\nburst_count = i2c_nuvoton_get_burstcount(client, chip);\r\nif (burst_count < 0) {\r\ndev_err(chip->dev,\r\n"%s() fail to read burstCount=%d\n", __func__,\r\nburst_count);\r\nreturn -EIO;\r\n}\r\nbytes2read = min_t(size_t, burst_count, count - size);\r\nrc = i2c_nuvoton_read_buf(client, TPM_DATA_FIFO_R,\r\nbytes2read, &buf[size]);\r\nif (rc < 0) {\r\ndev_err(chip->dev,\r\n"%s() fail on i2c_nuvoton_read_buf()=%d\n",\r\n__func__, rc);\r\nreturn -EIO;\r\n}\r\ndev_dbg(chip->dev, "%s(%d):", __func__, bytes2read);\r\nsize += bytes2read;\r\n}\r\nreturn size;\r\n}\r\nstatic int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct device *dev = chip->dev;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ns32 rc;\r\nint expected, status, burst_count, retries, size = 0;\r\nif (count < TPM_HEADER_SIZE) {\r\ni2c_nuvoton_ready(chip);\r\ndev_err(dev, "%s() count < header size\n", __func__);\r\nreturn -EIO;\r\n}\r\nfor (retries = 0; retries < TPM_RETRY; retries++) {\r\nif (retries > 0) {\r\ni2c_nuvoton_write_status(client,\r\nTPM_STS_RESPONSE_RETRY);\r\n}\r\nstatus = i2c_nuvoton_wait_for_data_avail(\r\nchip, chip->vendor.timeout_c, &chip->vendor.read_queue);\r\nif (status != 0) {\r\ndev_err(dev, "%s() timeout on dataAvail\n", __func__);\r\nsize = -ETIMEDOUT;\r\ncontinue;\r\n}\r\nburst_count = i2c_nuvoton_get_burstcount(client, chip);\r\nif (burst_count < 0) {\r\ndev_err(dev, "%s() fail to get burstCount\n", __func__);\r\nsize = -EIO;\r\ncontinue;\r\n}\r\nsize = i2c_nuvoton_recv_data(client, chip, buf,\r\nburst_count);\r\nif (size < TPM_HEADER_SIZE) {\r\ndev_err(dev, "%s() fail to read header\n", __func__);\r\nsize = -EIO;\r\ncontinue;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *) (buf + 2));\r\nif (expected > count) {\r\ndev_err(dev, "%s() expected > count\n", __func__);\r\nsize = -EIO;\r\ncontinue;\r\n}\r\nrc = i2c_nuvoton_recv_data(client, chip, &buf[size],\r\nexpected - size);\r\nsize += rc;\r\nif (rc < 0 || size < expected) {\r\ndev_err(dev, "%s() fail to read remainder of result\n",\r\n__func__);\r\nsize = -EIO;\r\ncontinue;\r\n}\r\nif (i2c_nuvoton_wait_for_stat(\r\nchip, TPM_STS_VALID | TPM_STS_DATA_AVAIL,\r\nTPM_STS_VALID, chip->vendor.timeout_c,\r\nNULL)) {\r\ndev_err(dev, "%s() error left over data\n", __func__);\r\nsize = -ETIMEDOUT;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\ni2c_nuvoton_ready(chip);\r\ndev_dbg(chip->dev, "%s() -> %d\n", __func__, size);\r\nreturn size;\r\n}\r\nstatic int i2c_nuvoton_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nstruct device *dev = chip->dev;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu32 ordinal;\r\nsize_t count = 0;\r\nint burst_count, bytes2write, retries, rc = -EIO;\r\nfor (retries = 0; retries < TPM_RETRY; retries++) {\r\ni2c_nuvoton_ready(chip);\r\nif (i2c_nuvoton_wait_for_stat(chip, TPM_STS_COMMAND_READY,\r\nTPM_STS_COMMAND_READY,\r\nchip->vendor.timeout_b, NULL)) {\r\ndev_err(dev, "%s() timeout on commandReady\n",\r\n__func__);\r\nrc = -EIO;\r\ncontinue;\r\n}\r\nrc = 0;\r\nwhile (count < len - 1) {\r\nburst_count = i2c_nuvoton_get_burstcount(client,\r\nchip);\r\nif (burst_count < 0) {\r\ndev_err(dev, "%s() fail get burstCount\n",\r\n__func__);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nbytes2write = min_t(size_t, burst_count,\r\nlen - 1 - count);\r\nrc = i2c_nuvoton_write_buf(client, TPM_DATA_FIFO_W,\r\nbytes2write, &buf[count]);\r\nif (rc < 0) {\r\ndev_err(dev, "%s() fail i2cWriteBuf\n",\r\n__func__);\r\nbreak;\r\n}\r\ndev_dbg(dev, "%s(%d):", __func__, bytes2write);\r\ncount += bytes2write;\r\nrc = i2c_nuvoton_wait_for_stat(chip,\r\nTPM_STS_VALID |\r\nTPM_STS_EXPECT,\r\nTPM_STS_VALID |\r\nTPM_STS_EXPECT,\r\nchip->vendor.timeout_c,\r\nNULL);\r\nif (rc < 0) {\r\ndev_err(dev, "%s() timeout on Expect\n",\r\n__func__);\r\nrc = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nif (rc < 0)\r\ncontinue;\r\nrc = i2c_nuvoton_write_buf(client, TPM_DATA_FIFO_W, 1,\r\n&buf[count]);\r\nif (rc < 0) {\r\ndev_err(dev, "%s() fail to write last byte\n",\r\n__func__);\r\nrc = -EIO;\r\ncontinue;\r\n}\r\ndev_dbg(dev, "%s(last): %02x", __func__, buf[count]);\r\nrc = i2c_nuvoton_wait_for_stat(chip,\r\nTPM_STS_VALID | TPM_STS_EXPECT,\r\nTPM_STS_VALID,\r\nchip->vendor.timeout_c, NULL);\r\nif (rc) {\r\ndev_err(dev, "%s() timeout on Expect to clear\n",\r\n__func__);\r\nrc = -ETIMEDOUT;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (rc < 0) {\r\ni2c_nuvoton_ready(chip);\r\nreturn rc;\r\n}\r\nrc = i2c_nuvoton_write_status(client, TPM_STS_GO);\r\nif (rc < 0) {\r\ndev_err(dev, "%s() fail to write Go\n", __func__);\r\ni2c_nuvoton_ready(chip);\r\nreturn rc;\r\n}\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nrc = i2c_nuvoton_wait_for_data_avail(chip,\r\ntpm_calc_ordinal_duration(chip,\r\nordinal),\r\n&chip->vendor.read_queue);\r\nif (rc) {\r\ndev_err(dev, "%s() timeout command duration\n", __func__);\r\ni2c_nuvoton_ready(chip);\r\nreturn rc;\r\n}\r\ndev_dbg(dev, "%s() -> %zd\n", __func__, len);\r\nreturn len;\r\n}\r\nstatic bool i2c_nuvoton_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\nstatic irqreturn_t i2c_nuvoton_int_handler(int dummy, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nstruct priv_data *priv = chip->vendor.priv;\r\npriv->intrs++;\r\nwake_up(&chip->vendor.read_queue);\r\ndisable_irq_nosync(chip->vendor.irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int get_vid(struct i2c_client *client, u32 *res)\r\n{\r\nstatic const u8 vid_did_rid_value[] = { 0x50, 0x10, 0xfe };\r\nu32 temp;\r\ns32 rc;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nrc = i2c_nuvoton_read_buf(client, TPM_VID_DID_RID, 4, (u8 *)&temp);\r\nif (rc < 0)\r\nreturn rc;\r\nif (memcmp(&temp, vid_did_rid_value, sizeof(vid_did_rid_value))) {\r\nrc = i2c_nuvoton_read_buf(client, TPM_DATA_FIFO_W, 4,\r\n(u8 *) (&temp));\r\nif (rc < 0)\r\nreturn rc;\r\nif (memcmp(&temp, vid_did_rid_value,\r\nsizeof(vid_did_rid_value)))\r\nreturn -ENODEV;\r\n}\r\n*res = temp;\r\nreturn 0;\r\n}\r\nstatic int i2c_nuvoton_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint rc;\r\nstruct tpm_chip *chip;\r\nstruct device *dev = &client->dev;\r\nu32 vid = 0;\r\nrc = get_vid(client, &vid);\r\nif (rc)\r\nreturn rc;\r\ndev_info(dev, "VID: %04X DID: %02X RID: %02X\n", (u16) vid,\r\n(u8) (vid >> 16), (u8) (vid >> 24));\r\nchip = tpm_register_hardware(dev, &tpm_i2c);\r\nif (!chip) {\r\ndev_err(dev, "%s() error in tpm_register_hardware\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nchip->vendor.priv = devm_kzalloc(dev, sizeof(struct priv_data),\r\nGFP_KERNEL);\r\ninit_waitqueue_head(&chip->vendor.read_queue);\r\ninit_waitqueue_head(&chip->vendor.int_queue);\r\nchip->vendor.timeout_a = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TPM_I2C_LONG_TIMEOUT);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\r\nchip->vendor.irq = client->irq;\r\nif (chip->vendor.irq) {\r\ndev_dbg(dev, "%s() chip-vendor.irq\n", __func__);\r\nrc = devm_request_irq(dev, chip->vendor.irq,\r\ni2c_nuvoton_int_handler,\r\nIRQF_TRIGGER_LOW,\r\nchip->vendor.miscdev.name,\r\nchip);\r\nif (rc) {\r\ndev_err(dev, "%s() Unable to request irq: %d for use\n",\r\n__func__, chip->vendor.irq);\r\nchip->vendor.irq = 0;\r\n} else {\r\ni2c_nuvoton_ready(chip);\r\nrc = i2c_nuvoton_wait_for_stat(chip,\r\nTPM_STS_COMMAND_READY,\r\nTPM_STS_COMMAND_READY,\r\nchip->vendor.timeout_b,\r\nNULL);\r\nif (rc == 0) {\r\nrc = i2c_nuvoton_write_buf(client,\r\nTPM_DATA_FIFO_W,\r\n1, (u8 *) (&rc));\r\nif (rc < 0)\r\ngoto out_err;\r\ni2c_nuvoton_ready(chip);\r\n} else {\r\nif (i2c_nuvoton_read_status(chip) !=\r\nTPM_STS_VALID) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\n}\r\n}\r\nif (tpm_get_timeouts(chip)) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nif (tpm_do_selftest(chip)) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\ntpm_dev_vendor_release(chip);\r\ntpm_remove_hardware(chip->dev);\r\nreturn rc;\r\n}\r\nstatic int i2c_nuvoton_remove(struct i2c_client *client)\r\n{\r\nstruct device *dev = &(client->dev);\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip)\r\ntpm_dev_vendor_release(chip);\r\ntpm_remove_hardware(dev);\r\nkfree(chip);\r\nreturn 0;\r\n}
