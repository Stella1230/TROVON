static int lmv_numobd_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = (struct obd_device *)m->private;\r\nstruct lmv_desc *desc;\r\nLASSERT(dev != NULL);\r\ndesc = &dev->u.lmv.desc;\r\nreturn seq_printf(m, "%u\n", desc->ld_tgt_count);\r\n}\r\nstatic enum placement_policy placement_name2policy(char *name, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < PLACEMENT_MAX_POLICY; i++) {\r\nif (!strncmp(placement_name[i], name, len))\r\nreturn i;\r\n}\r\nreturn PLACEMENT_INVAL_POLICY;\r\n}\r\nstatic const char *placement_policy2name(enum placement_policy placement)\r\n{\r\nLASSERT(placement < PLACEMENT_MAX_POLICY);\r\nreturn placement_name[placement];\r\n}\r\nstatic int lmv_placement_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = (struct obd_device *)m->private;\r\nstruct lmv_obd *lmv;\r\nLASSERT(dev != NULL);\r\nlmv = &dev->u.lmv;\r\nreturn seq_printf(m, "%s\n", placement_policy2name(lmv->lmv_placement));\r\n}\r\nstatic ssize_t lmv_placement_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *dev = ((struct seq_file *)file->private_data)->private;\r\nchar dummy[MAX_POLICY_STRING_SIZE + 1];\r\nint len = count;\r\nenum placement_policy policy;\r\nstruct lmv_obd *lmv;\r\nif (copy_from_user(dummy, buffer, MAX_POLICY_STRING_SIZE))\r\nreturn -EFAULT;\r\nLASSERT(dev != NULL);\r\nlmv = &dev->u.lmv;\r\nif (len > MAX_POLICY_STRING_SIZE)\r\nlen = MAX_POLICY_STRING_SIZE;\r\nif (dummy[len - 1] == '\n')\r\nlen--;\r\ndummy[len] = '\0';\r\npolicy = placement_name2policy(dummy, len);\r\nif (policy != PLACEMENT_INVAL_POLICY) {\r\nspin_lock(&lmv->lmv_lock);\r\nlmv->lmv_placement = policy;\r\nspin_unlock(&lmv->lmv_lock);\r\n} else {\r\nCERROR("Invalid placement policy \"%s\"!\n", dummy);\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int lmv_activeobd_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = (struct obd_device *)m->private;\r\nstruct lmv_desc *desc;\r\nLASSERT(dev != NULL);\r\ndesc = &dev->u.lmv.desc;\r\nreturn seq_printf(m, "%u\n", desc->ld_active_tgt_count);\r\n}\r\nstatic int lmv_desc_uuid_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = (struct obd_device *)m->private;\r\nstruct lmv_obd *lmv;\r\nLASSERT(dev != NULL);\r\nlmv = &dev->u.lmv;\r\nreturn seq_printf(m, "%s\n", lmv->desc.ld_uuid.uuid);\r\n}\r\nstatic void *lmv_tgt_seq_start(struct seq_file *p, loff_t *pos)\r\n{\r\nstruct obd_device *dev = p->private;\r\nstruct lmv_obd *lmv = &dev->u.lmv;\r\nreturn (*pos >= lmv->desc.ld_tgt_count) ? NULL : lmv->tgts[*pos];\r\n}\r\nstatic void lmv_tgt_seq_stop(struct seq_file *p, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic void *lmv_tgt_seq_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nstruct obd_device *dev = p->private;\r\nstruct lmv_obd *lmv = &dev->u.lmv;\r\n++*pos;\r\nreturn (*pos >= lmv->desc.ld_tgt_count) ? NULL : lmv->tgts[*pos];\r\n}\r\nstatic int lmv_tgt_seq_show(struct seq_file *p, void *v)\r\n{\r\nstruct lmv_tgt_desc *tgt = v;\r\nif (tgt == NULL)\r\nreturn 0;\r\nreturn seq_printf(p, "%d: %s %sACTIVE\n", tgt->ltd_idx,\r\ntgt->ltd_uuid.uuid, tgt->ltd_active ? "" : "IN");\r\n}\r\nstatic int lmv_target_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint rc;\r\nrc = seq_open(file, &lmv_tgt_sops);\r\nif (rc)\r\nreturn rc;\r\nseq = file->private_data;\r\nseq->private = PDE_DATA(inode);\r\nreturn 0;\r\n}\r\nvoid lprocfs_lmv_init_vars(struct lprocfs_static_vars *lvars)\r\n{\r\nlvars->module_vars = lprocfs_lmv_module_vars;\r\nlvars->obd_vars = lprocfs_lmv_obd_vars;\r\n}
