static inline void fscache_done_parent_op(struct fscache_object *object)\r\n{\r\nstruct fscache_object *parent = object->parent;\r\n_enter("OBJ%x {OBJ%x,%x}",\r\nobject->debug_id, parent->debug_id, parent->n_ops);\r\nspin_lock_nested(&parent->lock, 1);\r\nparent->n_obj_ops--;\r\nparent->n_ops--;\r\nif (parent->n_ops == 0)\r\nfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&parent->lock);\r\n}\r\nstatic void fscache_object_sm_dispatcher(struct fscache_object *object)\r\n{\r\nconst struct fscache_transition *t;\r\nconst struct fscache_state *state, *new_state;\r\nunsigned long events, event_mask;\r\nint event = -1;\r\nASSERT(object != NULL);\r\n_enter("{OBJ%x,%s,%lx}",\r\nobject->debug_id, object->state->name, object->events);\r\nevent_mask = object->event_mask;\r\nrestart:\r\nobject->event_mask = 0;\r\nstate = object->state;\r\nrestart_masked:\r\nevents = object->events;\r\nif (events & object->oob_event_mask) {\r\n_debug("{OBJ%x} oob %lx",\r\nobject->debug_id, events & object->oob_event_mask);\r\nfor (t = object->oob_table; t->events; t++) {\r\nif (events & t->events) {\r\nstate = t->transit_to;\r\nASSERT(state->work != NULL);\r\nevent = fls(events & t->events) - 1;\r\n__clear_bit(event, &object->oob_event_mask);\r\nclear_bit(event, &object->events);\r\ngoto execute_work_state;\r\n}\r\n}\r\n}\r\nif (!state->work) {\r\nif (events & event_mask) {\r\nfor (t = state->transitions; t->events; t++) {\r\nif (events & t->events) {\r\nnew_state = t->transit_to;\r\nevent = fls(events & t->events) - 1;\r\nclear_bit(event, &object->events);\r\n_debug("{OBJ%x} ev %d: %s -> %s",\r\nobject->debug_id, event,\r\nstate->name, new_state->name);\r\nobject->state = state = new_state;\r\ngoto execute_work_state;\r\n}\r\n}\r\nBUG();\r\n}\r\ngoto unmask_events;\r\n}\r\nexecute_work_state:\r\n_debug("{OBJ%x} exec %s", object->debug_id, state->name);\r\nnew_state = state->work(object, event);\r\nevent = -1;\r\nif (new_state == NO_TRANSIT) {\r\n_debug("{OBJ%x} %s notrans", object->debug_id, state->name);\r\nfscache_enqueue_object(object);\r\nevent_mask = object->oob_event_mask;\r\ngoto unmask_events;\r\n}\r\n_debug("{OBJ%x} %s -> %s",\r\nobject->debug_id, state->name, new_state->name);\r\nobject->state = state = new_state;\r\nif (state->work) {\r\nif (unlikely(state->work == ((void *)2UL))) {\r\n_leave(" [dead]");\r\nreturn;\r\n}\r\ngoto restart_masked;\r\n}\r\nevent_mask = object->oob_event_mask;\r\nfor (t = state->transitions; t->events; t++)\r\nevent_mask |= t->events;\r\nunmask_events:\r\nobject->event_mask = event_mask;\r\nsmp_mb();\r\nevents = object->events;\r\nif (events & event_mask)\r\ngoto restart;\r\n_leave(" [msk %lx]", event_mask);\r\n}\r\nstatic void fscache_object_work_func(struct work_struct *work)\r\n{\r\nstruct fscache_object *object =\r\ncontainer_of(work, struct fscache_object, work);\r\nunsigned long start;\r\n_enter("{OBJ%x}", object->debug_id);\r\nstart = jiffies;\r\nfscache_object_sm_dispatcher(object);\r\nfscache_hist(fscache_objs_histogram, start);\r\nfscache_put_object(object);\r\n}\r\nvoid fscache_object_init(struct fscache_object *object,\r\nstruct fscache_cookie *cookie,\r\nstruct fscache_cache *cache)\r\n{\r\nconst struct fscache_transition *t;\r\natomic_inc(&cache->object_count);\r\nobject->state = STATE(WAIT_FOR_INIT);\r\nobject->oob_table = fscache_osm_init_oob;\r\nobject->flags = 1 << FSCACHE_OBJECT_IS_LIVE;\r\nspin_lock_init(&object->lock);\r\nINIT_LIST_HEAD(&object->cache_link);\r\nINIT_HLIST_NODE(&object->cookie_link);\r\nINIT_WORK(&object->work, fscache_object_work_func);\r\nINIT_LIST_HEAD(&object->dependents);\r\nINIT_LIST_HEAD(&object->dep_link);\r\nINIT_LIST_HEAD(&object->pending_ops);\r\nobject->n_children = 0;\r\nobject->n_ops = object->n_in_progress = object->n_exclusive = 0;\r\nobject->events = 0;\r\nobject->store_limit = 0;\r\nobject->store_limit_l = 0;\r\nobject->cache = cache;\r\nobject->cookie = cookie;\r\nobject->parent = NULL;\r\n#ifdef CONFIG_FSCACHE_OBJECT_LIST\r\nRB_CLEAR_NODE(&object->objlist_link);\r\n#endif\r\nobject->oob_event_mask = 0;\r\nfor (t = object->oob_table; t->events; t++)\r\nobject->oob_event_mask |= t->events;\r\nobject->event_mask = object->oob_event_mask;\r\nfor (t = object->state->transitions; t->events; t++)\r\nobject->event_mask |= t->events;\r\n}\r\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nobject->oob_event_mask = 0;\r\nfscache_dequeue_object(object);\r\nreturn transit_to(KILL_OBJECT);\r\n}\r\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_object *parent;\r\nbool success;\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nASSERT(list_empty(&object->dep_link));\r\nparent = object->parent;\r\nif (!parent) {\r\n_leave(" [no parent]");\r\nreturn transit_to(DROP_OBJECT);\r\n}\r\n_debug("parent: %s of:%lx", parent->state->name, parent->flags);\r\nif (fscache_object_is_dying(parent)) {\r\n_leave(" [bad parent]");\r\nreturn transit_to(DROP_OBJECT);\r\n}\r\nif (fscache_object_is_available(parent)) {\r\n_leave(" [ready]");\r\nreturn transit_to(PARENT_READY);\r\n}\r\n_debug("wait");\r\nspin_lock(&parent->lock);\r\nfscache_stat(&fscache_n_cop_grab_object);\r\nsuccess = false;\r\nif (fscache_object_is_live(parent) &&\r\nobject->cache->ops->grab_object(object)) {\r\nlist_add(&object->dep_link, &parent->dependents);\r\nsuccess = true;\r\n}\r\nfscache_stat_d(&fscache_n_cop_grab_object);\r\nspin_unlock(&parent->lock);\r\nif (!success) {\r\n_leave(" [grab failed]");\r\nreturn transit_to(DROP_OBJECT);\r\n}\r\nfscache_raise_event(parent, FSCACHE_OBJECT_EV_NEW_CHILD);\r\n_leave(" [wait]");\r\nreturn transit_to(WAIT_FOR_PARENT);\r\n}\r\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_object *parent = object->parent;\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nASSERT(parent != NULL);\r\nspin_lock(&parent->lock);\r\nparent->n_ops++;\r\nparent->n_obj_ops++;\r\nobject->lookup_jif = jiffies;\r\nspin_unlock(&parent->lock);\r\n_leave("");\r\nreturn transit_to(LOOK_UP_OBJECT);\r\n}\r\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\nstruct fscache_object *parent = object->parent;\r\nint ret;\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nobject->oob_table = fscache_osm_lookup_oob;\r\nASSERT(parent != NULL);\r\nASSERTCMP(parent->n_ops, >, 0);\r\nASSERTCMP(parent->n_obj_ops, >, 0);\r\nASSERT(fscache_object_is_available(parent));\r\nif (fscache_object_is_dying(parent) ||\r\ntest_bit(FSCACHE_IOERROR, &object->cache->flags) ||\r\n!fscache_use_cookie(object)) {\r\n_leave(" [unavailable]");\r\nreturn transit_to(LOOKUP_FAILURE);\r\n}\r\n_debug("LOOKUP \"%s\" in \"%s\"",\r\ncookie->def->name, object->cache->tag->name);\r\nfscache_stat(&fscache_n_object_lookups);\r\nfscache_stat(&fscache_n_cop_lookup_object);\r\nret = object->cache->ops->lookup_object(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_object);\r\nfscache_unuse_cookie(object);\r\nif (ret == -ETIMEDOUT) {\r\nfscache_stat(&fscache_n_object_lookups_timed_out);\r\n_leave(" [timeout]");\r\nreturn NO_TRANSIT;\r\n}\r\nif (ret < 0) {\r\n_leave(" [error]");\r\nreturn transit_to(LOOKUP_FAILURE);\r\n}\r\n_leave(" [ok]");\r\nreturn transit_to(OBJECT_AVAILABLE);\r\n}\r\nvoid fscache_object_lookup_negative(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x,%s}", object->debug_id, object->state->name);\r\nif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\r\nfscache_stat(&fscache_n_object_lookups_negative);\r\nset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\nclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\r\n_debug("wake up lookup %p", &cookie->flags);\r\nclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\r\n}\r\n_leave("");\r\n}\r\nvoid fscache_obtained_object(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x,%s}", object->debug_id, object->state->name);\r\nif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\r\nfscache_stat(&fscache_n_object_lookups_positive);\r\nclear_bit_unlock(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\nclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\r\nclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\r\n} else {\r\nfscache_stat(&fscache_n_object_created);\r\n}\r\nset_bit(FSCACHE_OBJECT_IS_AVAILABLE, &object->flags);\r\n_leave("");\r\n}\r\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nobject->oob_table = fscache_osm_run_oob;\r\nspin_lock(&object->lock);\r\nfscache_done_parent_op(object);\r\nif (object->n_in_progress == 0) {\r\nif (object->n_ops > 0) {\r\nASSERTCMP(object->n_ops, >=, object->n_obj_ops);\r\nfscache_start_operations(object);\r\n} else {\r\nASSERT(list_empty(&object->pending_ops));\r\n}\r\n}\r\nspin_unlock(&object->lock);\r\nfscache_stat(&fscache_n_cop_lookup_complete);\r\nobject->cache->ops->lookup_complete(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_complete);\r\nfscache_hist(fscache_obj_instantiate_histogram, object->lookup_jif);\r\nfscache_stat(&fscache_n_object_avail);\r\n_leave("");\r\nreturn transit_to(JUMPSTART_DEPS);\r\n}\r\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_PARENT_READY))\r\nreturn NO_TRANSIT;\r\nreturn transit_to(WAIT_FOR_CMD);\r\n}\r\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_cookie *cookie;\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nobject->oob_event_mask = 0;\r\nfscache_stat(&fscache_n_cop_lookup_complete);\r\nobject->cache->ops->lookup_complete(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_complete);\r\ncookie = object->cookie;\r\nset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\r\nif (test_and_clear_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags))\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\r\nfscache_done_parent_op(object);\r\nreturn transit_to(KILL_OBJECT);\r\n}\r\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x,%d,%d},%d",\r\nobject->debug_id, object->n_ops, object->n_children, event);\r\nclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\r\nobject->oob_event_mask = 0;\r\nif (list_empty(&object->dependents) &&\r\nobject->n_ops == 0 &&\r\nobject->n_children == 0)\r\nreturn transit_to(DROP_OBJECT);\r\nif (object->n_in_progress == 0) {\r\nspin_lock(&object->lock);\r\nif (object->n_ops > 0 && object->n_in_progress == 0)\r\nfscache_start_operations(object);\r\nspin_unlock(&object->lock);\r\n}\r\nif (!list_empty(&object->dependents))\r\nreturn transit_to(KILL_DEPENDENTS);\r\nreturn transit_to(WAIT_FOR_CLEARANCE);\r\n}\r\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nif (!fscache_enqueue_dependents(object, FSCACHE_OBJECT_EV_KILL))\r\nreturn NO_TRANSIT;\r\nreturn transit_to(WAIT_FOR_CLEARANCE);\r\n}\r\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_object *parent = object->parent;\r\nstruct fscache_cookie *cookie = object->cookie;\r\nstruct fscache_cache *cache = object->cache;\r\nbool awaken = false;\r\n_enter("{OBJ%x,%d},%d", object->debug_id, object->n_children, event);\r\nASSERT(cookie != NULL);\r\nASSERT(!hlist_unhashed(&object->cookie_link));\r\nspin_lock(&cookie->lock);\r\nhlist_del_init(&object->cookie_link);\r\nif (hlist_empty(&cookie->backing_objects) &&\r\ntest_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\r\nawaken = true;\r\nspin_unlock(&cookie->lock);\r\nif (awaken)\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\r\nspin_lock(&object->lock);\r\nspin_unlock(&object->lock);\r\nspin_lock(&cache->object_list_lock);\r\nlist_del_init(&object->cache_link);\r\nspin_unlock(&cache->object_list_lock);\r\nfscache_stat(&fscache_n_cop_drop_object);\r\ncache->ops->drop_object(object);\r\nfscache_stat_d(&fscache_n_cop_drop_object);\r\nif (parent) {\r\n_debug("release parent OBJ%x {%d}",\r\nparent->debug_id, parent->n_children);\r\nspin_lock(&parent->lock);\r\nparent->n_children--;\r\nif (parent->n_children == 0)\r\nfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&parent->lock);\r\nobject->parent = NULL;\r\n}\r\nfscache_put_object(object);\r\nfscache_stat(&fscache_n_object_dead);\r\n_leave("");\r\nreturn transit_to(OBJECT_DEAD);\r\n}\r\nstatic int fscache_get_object(struct fscache_object *object)\r\n{\r\nint ret;\r\nfscache_stat(&fscache_n_cop_grab_object);\r\nret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\r\nfscache_stat_d(&fscache_n_cop_grab_object);\r\nreturn ret;\r\n}\r\nstatic void fscache_put_object(struct fscache_object *object)\r\n{\r\nfscache_stat(&fscache_n_cop_put_object);\r\nobject->cache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\n}\r\nvoid fscache_object_destroy(struct fscache_object *object)\r\n{\r\nfscache_objlist_remove(object);\r\nfscache_cookie_put(object->cookie);\r\nobject->cookie = NULL;\r\n}\r\nvoid fscache_enqueue_object(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (fscache_get_object(object) >= 0) {\r\nwait_queue_head_t *cong_wq =\r\n&get_cpu_var(fscache_object_cong_wait);\r\nif (queue_work(fscache_object_wq, &object->work)) {\r\nif (fscache_object_congested())\r\nwake_up(cong_wq);\r\n} else\r\nfscache_put_object(object);\r\nput_cpu_var(fscache_object_cong_wait);\r\n}\r\n}\r\nbool fscache_object_sleep_till_congested(signed long *timeoutp)\r\n{\r\nwait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);\r\nDEFINE_WAIT(wait);\r\nif (fscache_object_congested())\r\nreturn true;\r\nadd_wait_queue_exclusive(cong_wq, &wait);\r\nif (!fscache_object_congested())\r\n*timeoutp = schedule_timeout(*timeoutp);\r\nfinish_wait(cong_wq, &wait);\r\nreturn fscache_object_congested();\r\n}\r\nstatic bool fscache_enqueue_dependents(struct fscache_object *object, int event)\r\n{\r\nstruct fscache_object *dep;\r\nbool ret = true;\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (list_empty(&object->dependents))\r\nreturn true;\r\nspin_lock(&object->lock);\r\nwhile (!list_empty(&object->dependents)) {\r\ndep = list_entry(object->dependents.next,\r\nstruct fscache_object, dep_link);\r\nlist_del_init(&dep->dep_link);\r\nfscache_raise_event(dep, event);\r\nfscache_put_object(dep);\r\nif (!list_empty(&object->dependents) && need_resched()) {\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&object->lock);\r\nreturn ret;\r\n}\r\nstatic void fscache_dequeue_object(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (!list_empty(&object->dep_link)) {\r\nspin_lock(&object->parent->lock);\r\nlist_del_init(&object->dep_link);\r\nspin_unlock(&object->parent->lock);\r\n}\r\n_leave("");\r\n}\r\nenum fscache_checkaux fscache_check_aux(struct fscache_object *object,\r\nconst void *data, uint16_t datalen)\r\n{\r\nenum fscache_checkaux result;\r\nif (!object->cookie->def->check_aux) {\r\nfscache_stat(&fscache_n_checkaux_none);\r\nreturn FSCACHE_CHECKAUX_OKAY;\r\n}\r\nresult = object->cookie->def->check_aux(object->cookie->netfs_data,\r\ndata, datalen);\r\nswitch (result) {\r\ncase FSCACHE_CHECKAUX_OKAY:\r\nfscache_stat(&fscache_n_checkaux_okay);\r\nbreak;\r\ncase FSCACHE_CHECKAUX_NEEDS_UPDATE:\r\nfscache_stat(&fscache_n_checkaux_update);\r\nbreak;\r\ncase FSCACHE_CHECKAUX_OBSOLETE:\r\nfscache_stat(&fscache_n_checkaux_obsolete);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn result;\r\n}\r\nstatic const struct fscache_state *_fscache_invalidate_object(struct fscache_object *object,\r\nint event)\r\n{\r\nstruct fscache_operation *op;\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nif (!fscache_use_cookie(object)) {\r\nASSERT(object->cookie->stores.rnode == NULL);\r\nset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\r\n_leave(" [no cookie]");\r\nreturn transit_to(KILL_OBJECT);\r\n}\r\nfscache_invalidate_writes(cookie);\r\nclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\r\nfscache_cancel_all_ops(object);\r\nop = kzalloc(sizeof(*op), GFP_KERNEL);\r\nif (!op)\r\ngoto nomem;\r\nfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\r\nop->flags = FSCACHE_OP_ASYNC |\r\n(1 << FSCACHE_OP_EXCLUSIVE) |\r\n(1 << FSCACHE_OP_UNUSE_COOKIE);\r\nspin_lock(&cookie->lock);\r\nif (fscache_submit_exclusive_op(object, op) < 0)\r\ngoto submit_op_failed;\r\nspin_unlock(&cookie->lock);\r\nfscache_put_operation(op);\r\nset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\nif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\r\n_leave(" [ok]");\r\nreturn transit_to(UPDATE_OBJECT);\r\nnomem:\r\nclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\r\nfscache_unuse_cookie(object);\r\n_leave(" [ENOMEM]");\r\nreturn transit_to(KILL_OBJECT);\r\nsubmit_op_failed:\r\nclear_bit(FSCACHE_OBJECT_IS_LIVE, &object->flags);\r\nspin_unlock(&cookie->lock);\r\nfscache_unuse_cookie(object);\r\nkfree(op);\r\n_leave(" [EIO]");\r\nreturn transit_to(KILL_OBJECT);\r\n}\r\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *object,\r\nint event)\r\n{\r\nconst struct fscache_state *s;\r\nfscache_stat(&fscache_n_invalidates_run);\r\nfscache_stat(&fscache_n_cop_invalidate_object);\r\ns = _fscache_invalidate_object(object, event);\r\nfscache_stat_d(&fscache_n_cop_invalidate_object);\r\nreturn s;\r\n}\r\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *object,\r\nint event)\r\n{\r\n_enter("{OBJ%x},%d", object->debug_id, event);\r\nfscache_stat(&fscache_n_updates_run);\r\nfscache_stat(&fscache_n_cop_update_object);\r\nobject->cache->ops->update_object(object);\r\nfscache_stat_d(&fscache_n_cop_update_object);\r\n_leave("");\r\nreturn transit_to(WAIT_FOR_CMD);\r\n}
