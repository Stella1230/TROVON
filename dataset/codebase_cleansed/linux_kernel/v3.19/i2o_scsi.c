static struct i2o_scsi_host *i2o_scsi_host_alloc(struct i2o_controller *c)\r\n{\r\nstruct i2o_scsi_host *i2o_shost;\r\nstruct i2o_device *i2o_dev;\r\nstruct Scsi_Host *scsi_host;\r\nint max_channel = 0;\r\nu8 type;\r\nint i;\r\nsize_t size;\r\nu16 body_size = 6;\r\n#ifdef CONFIG_I2O_EXT_ADAPTEC\r\nif (c->adaptec)\r\nbody_size = 8;\r\n#endif\r\nlist_for_each_entry(i2o_dev, &c->devices, list)\r\nif (i2o_dev->lct_data.class_id == I2O_CLASS_BUS_ADAPTER) {\r\nif (!i2o_parm_field_get(i2o_dev, 0x0000, 0, &type, 1)\r\n&& (type == 0x01))\r\nmax_channel++;\r\n}\r\nif (!max_channel) {\r\nosm_warn("no channels found on %s\n", c->name);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nsize = max_channel * sizeof(struct i2o_device *)\r\n+ sizeof(struct i2o_scsi_host);\r\nscsi_host = scsi_host_alloc(&i2o_scsi_host_template, size);\r\nif (!scsi_host) {\r\nosm_warn("Could not allocate SCSI host\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nscsi_host->max_channel = max_channel - 1;\r\nscsi_host->max_id = i2o_scsi_max_id;\r\nscsi_host->max_lun = i2o_scsi_max_lun;\r\nscsi_host->this_id = c->unit;\r\nscsi_host->sg_tablesize = i2o_sg_tablesize(c, body_size);\r\ni2o_shost = (struct i2o_scsi_host *)scsi_host->hostdata;\r\ni2o_shost->scsi_host = scsi_host;\r\ni2o_shost->iop = c;\r\ni2o_shost->lun = 1;\r\ni = 0;\r\nlist_for_each_entry(i2o_dev, &c->devices, list)\r\nif (i2o_dev->lct_data.class_id == I2O_CLASS_BUS_ADAPTER) {\r\nif (!i2o_parm_field_get(i2o_dev, 0x0000, 0, &type, 1)\r\n&& (type == 0x01))\r\ni2o_shost->channel[i++] = i2o_dev;\r\nif (i >= max_channel)\r\nbreak;\r\n}\r\nreturn i2o_shost;\r\n}\r\nstatic struct i2o_scsi_host *i2o_scsi_get_host(struct i2o_controller *c)\r\n{\r\nreturn c->driver_data[i2o_scsi_driver.context];\r\n}\r\nstatic int i2o_scsi_remove(struct device *dev)\r\n{\r\nstruct i2o_device *i2o_dev = to_i2o_device(dev);\r\nstruct i2o_controller *c = i2o_dev->iop;\r\nstruct i2o_scsi_host *i2o_shost;\r\nstruct scsi_device *scsi_dev;\r\nosm_info("device removed (TID: %03x)\n", i2o_dev->lct_data.tid);\r\ni2o_shost = i2o_scsi_get_host(c);\r\nshost_for_each_device(scsi_dev, i2o_shost->scsi_host)\r\nif (scsi_dev->hostdata == i2o_dev) {\r\nsysfs_remove_link(&i2o_dev->device.kobj, "scsi");\r\nscsi_remove_device(scsi_dev);\r\nscsi_device_put(scsi_dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_scsi_probe(struct device *dev)\r\n{\r\nstruct i2o_device *i2o_dev = to_i2o_device(dev);\r\nstruct i2o_controller *c = i2o_dev->iop;\r\nstruct i2o_scsi_host *i2o_shost;\r\nstruct Scsi_Host *scsi_host;\r\nstruct i2o_device *parent;\r\nstruct scsi_device *scsi_dev;\r\nu32 id = -1;\r\nu64 lun = -1;\r\nint channel = -1;\r\nint i, rc;\r\ni2o_shost = i2o_scsi_get_host(c);\r\nif (!i2o_shost)\r\nreturn -EFAULT;\r\nscsi_host = i2o_shost->scsi_host;\r\nswitch (i2o_dev->lct_data.class_id) {\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\ncase I2O_CLASS_EXECUTIVE:\r\n#ifdef CONFIG_I2O_EXT_ADAPTEC\r\nif (c->adaptec) {\r\nu8 type;\r\nstruct i2o_device *d = i2o_shost->channel[0];\r\nif (!i2o_parm_field_get(d, 0x0000, 0, &type, 1)\r\n&& (type == 0x01))\r\nif (!i2o_parm_field_get(d, 0x0200, 4, &id, 4)) {\r\nchannel = 0;\r\nif (i2o_dev->lct_data.class_id ==\r\nI2O_CLASS_RANDOM_BLOCK_STORAGE)\r\nlun =\r\ncpu_to_le64(i2o_shost->\r\nlun++);\r\nelse\r\nlun = 0;\r\n}\r\n}\r\n#endif\r\nbreak;\r\ncase I2O_CLASS_SCSI_PERIPHERAL:\r\nif (i2o_parm_field_get(i2o_dev, 0x0000, 3, &id, 4))\r\nreturn -EFAULT;\r\nif (i2o_parm_field_get(i2o_dev, 0x0000, 4, &lun, 8))\r\nreturn -EFAULT;\r\nparent = i2o_iop_find_device(c, i2o_dev->lct_data.parent_tid);\r\nif (!parent) {\r\nosm_warn("can not find parent of device %03x\n",\r\ni2o_dev->lct_data.tid);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i <= i2o_shost->scsi_host->max_channel; i++)\r\nif (i2o_shost->channel[i] == parent)\r\nchannel = i;\r\nbreak;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\nif (channel == -1) {\r\nosm_warn("can not find channel of device %03x\n",\r\ni2o_dev->lct_data.tid);\r\nreturn -EFAULT;\r\n}\r\nif (le32_to_cpu(id) >= scsi_host->max_id) {\r\nosm_warn("SCSI device id (%d) >= max_id of I2O host (%d)",\r\nle32_to_cpu(id), scsi_host->max_id);\r\nreturn -EFAULT;\r\n}\r\nif (le64_to_cpu(lun) >= scsi_host->max_lun) {\r\nosm_warn("SCSI device lun (%llu) >= max_lun of I2O host (%llu)",\r\nle64_to_cpu(lun), scsi_host->max_lun);\r\nreturn -EFAULT;\r\n}\r\nscsi_dev =\r\n__scsi_add_device(i2o_shost->scsi_host, channel, le32_to_cpu(id),\r\nle64_to_cpu(lun), i2o_dev);\r\nif (IS_ERR(scsi_dev)) {\r\nosm_warn("can not add SCSI device %03x\n",\r\ni2o_dev->lct_data.tid);\r\nreturn PTR_ERR(scsi_dev);\r\n}\r\nrc = sysfs_create_link(&i2o_dev->device.kobj,\r\n&scsi_dev->sdev_gendev.kobj, "scsi");\r\nif (rc)\r\ngoto err;\r\nosm_info("device added (TID: %03x) channel: %d, id: %d, lun: %llu\n",\r\ni2o_dev->lct_data.tid, channel, le32_to_cpu(id),\r\nle64_to_cpu(lun));\r\nreturn 0;\r\nerr:\r\nscsi_remove_device(scsi_dev);\r\nreturn rc;\r\n}\r\nstatic const char *i2o_scsi_info(struct Scsi_Host *SChost)\r\n{\r\nstruct i2o_scsi_host *hostdata;\r\nhostdata = (struct i2o_scsi_host *)SChost->hostdata;\r\nreturn hostdata->iop->name;\r\n}\r\nstatic int i2o_scsi_reply(struct i2o_controller *c, u32 m,\r\nstruct i2o_message *msg)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nu32 error;\r\nstruct device *dev;\r\ncmd = i2o_cntxt_list_get(c, le32_to_cpu(msg->u.s.tcntxt));\r\nif (unlikely(!cmd)) {\r\nosm_err("NULL reply received!\n");\r\nreturn -1;\r\n}\r\nerror = le32_to_cpu(msg->body[0]);\r\nosm_debug("Completed %0x%p\n", cmd);\r\ncmd->result = error & 0xff;\r\nif (cmd->result)\r\nmemcpy(cmd->sense_buffer, &msg->body[3],\r\nmin(SCSI_SENSE_BUFFERSIZE, 40));\r\nif ((error >> 8) & 0xff)\r\nosm_err("SCSI error %08x\n", error);\r\ndev = &c->pdev->dev;\r\nscsi_dma_unmap(cmd);\r\ncmd->scsi_done(cmd);\r\nreturn 1;\r\n}\r\nstatic void i2o_scsi_notify_device_add(struct i2o_device *i2o_dev)\r\n{\r\nswitch (i2o_dev->lct_data.class_id) {\r\ncase I2O_CLASS_EXECUTIVE:\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\ni2o_scsi_probe(&i2o_dev->device);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i2o_scsi_notify_device_remove(struct i2o_device *i2o_dev)\r\n{\r\nswitch (i2o_dev->lct_data.class_id) {\r\ncase I2O_CLASS_EXECUTIVE:\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\ni2o_scsi_remove(&i2o_dev->device);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i2o_scsi_notify_controller_add(struct i2o_controller *c)\r\n{\r\nstruct i2o_scsi_host *i2o_shost;\r\nint rc;\r\ni2o_shost = i2o_scsi_host_alloc(c);\r\nif (IS_ERR(i2o_shost)) {\r\nosm_err("Could not initialize SCSI host\n");\r\nreturn;\r\n}\r\nrc = scsi_add_host(i2o_shost->scsi_host, &c->device);\r\nif (rc) {\r\nosm_err("Could not add SCSI host\n");\r\nscsi_host_put(i2o_shost->scsi_host);\r\nreturn;\r\n}\r\nc->driver_data[i2o_scsi_driver.context] = i2o_shost;\r\nosm_debug("new I2O SCSI host added\n");\r\n}\r\nstatic void i2o_scsi_notify_controller_remove(struct i2o_controller *c)\r\n{\r\nstruct i2o_scsi_host *i2o_shost;\r\ni2o_shost = i2o_scsi_get_host(c);\r\nif (!i2o_shost)\r\nreturn;\r\nc->driver_data[i2o_scsi_driver.context] = NULL;\r\nscsi_remove_host(i2o_shost->scsi_host);\r\nscsi_host_put(i2o_shost->scsi_host);\r\nosm_debug("I2O SCSI host removed\n");\r\n}\r\nstatic int i2o_scsi_queuecommand_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nstruct i2o_controller *c;\r\nstruct i2o_device *i2o_dev;\r\nint tid;\r\nstruct i2o_message *msg;\r\nu32 scsi_flags = 0x20a00000;\r\nu32 sgl_offset;\r\nu32 *mptr;\r\nu32 cmd = I2O_CMD_SCSI_EXEC << 24;\r\nint rc = 0;\r\ni2o_dev = SCpnt->device->hostdata;\r\nSCpnt->scsi_done = done;\r\nif (unlikely(!i2o_dev)) {\r\nosm_warn("no I2O device in request\n");\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\ndone(SCpnt);\r\ngoto exit;\r\n}\r\nc = i2o_dev->iop;\r\ntid = i2o_dev->lct_data.tid;\r\nosm_debug("qcmd: Tid = %03x\n", tid);\r\nosm_debug("Real scsi messages.\n");\r\nswitch (SCpnt->sc_data_direction) {\r\ncase PCI_DMA_NONE:\r\nsgl_offset = SGL_OFFSET_0;\r\nbreak;\r\ncase PCI_DMA_TODEVICE:\r\nscsi_flags |= 0x80000000;\r\nsgl_offset = SGL_OFFSET_10;\r\nbreak;\r\ncase PCI_DMA_FROMDEVICE:\r\nscsi_flags |= 0x40000000;\r\nsgl_offset = SGL_OFFSET_10;\r\nbreak;\r\ndefault:\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\ndone(SCpnt);\r\ngoto exit;\r\n}\r\nmsg = i2o_msg_get(c);\r\nif (IS_ERR(msg)) {\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto exit;\r\n}\r\nmptr = &msg->body[0];\r\n#if 0\r\n#ifdef CONFIG_I2O_EXT_ADAPTEC\r\nif (c->adaptec) {\r\nu32 adpt_flags = 0;\r\nif (SCpnt->sc_request && SCpnt->sc_request->upper_private_data) {\r\ni2o_sg_io_hdr_t __user *usr_ptr =\r\n((Sg_request *) (SCpnt->sc_request->\r\nupper_private_data))->header.\r\nusr_ptr;\r\nif (usr_ptr)\r\nget_user(adpt_flags, &usr_ptr->flags);\r\n}\r\nswitch (i2o_dev->lct_data.class_id) {\r\ncase I2O_CLASS_EXECUTIVE:\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\nadpt_flags ^= I2O_DPT_SG_FLAG_INTERPRET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (sgl_offset == SGL_OFFSET_10)\r\nsgl_offset = SGL_OFFSET_12;\r\ncmd = I2O_CMD_PRIVATE << 24;\r\n*mptr++ = cpu_to_le32(I2O_VENDOR_DPT << 16 | I2O_CMD_SCSI_EXEC);\r\n*mptr++ = cpu_to_le32(adpt_flags | tid);\r\n}\r\n#endif\r\n#endif\r\nmsg->u.head[1] = cpu_to_le32(cmd | HOST_TID << 12 | tid);\r\nmsg->u.s.icntxt = cpu_to_le32(i2o_scsi_driver.context);\r\nmsg->u.s.tcntxt = cpu_to_le32(i2o_cntxt_list_add(c, SCpnt));\r\n*mptr++ = cpu_to_le32(scsi_flags | SCpnt->cmd_len);\r\nmemcpy(mptr, SCpnt->cmnd, 16);\r\nmptr += 4;\r\nif (sgl_offset != SGL_OFFSET_0) {\r\n*mptr++ = cpu_to_le32(scsi_bufflen(SCpnt));\r\nif (scsi_sg_count(SCpnt)) {\r\nif (!i2o_dma_map_sg(c, scsi_sglist(SCpnt),\r\nscsi_sg_count(SCpnt),\r\nSCpnt->sc_data_direction, &mptr))\r\ngoto nomem;\r\n}\r\n}\r\nmsg->u.head[0] =\r\ncpu_to_le32(I2O_MESSAGE_SIZE(mptr - &msg->u.head[0]) | sgl_offset);\r\ni2o_msg_post(c, msg);\r\nosm_debug("Issued %0x%p\n", SCpnt);\r\nreturn 0;\r\nnomem:\r\nrc = -ENOMEM;\r\ni2o_msg_nop(c, msg);\r\nexit:\r\nreturn rc;\r\n}\r\nint i2o_scsi_bios_param(struct scsi_device *sdev,\r\nstruct block_device *dev, sector_t capacity,\r\nint *ip)\r\n{\r\nint size;\r\nsize = capacity;\r\nip[0] = 64;\r\nip[1] = 32;\r\nif ((ip[2] = size >> 11) > 1024) {\r\nip[0] = 255;\r\nip[1] = 63;\r\nip[2] = size / (255 * 63);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init i2o_scsi_init(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO OSM_DESCRIPTION " v" OSM_VERSION "\n");\r\nrc = i2o_driver_register(&i2o_scsi_driver);\r\nif (rc) {\r\nosm_err("Could not register SCSI driver\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit i2o_scsi_exit(void)\r\n{\r\ni2o_driver_unregister(&i2o_scsi_driver);\r\n}
