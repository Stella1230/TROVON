static unsigned long\r\ntmr2ticks(int tmr_value)\r\n{\r\nunsigned long tmp;\r\nunsigned long scale;\r\ntmp = tmr_value * (1000000 / HZ);\r\nscale = (60 * 1000000) / (curr_tempo * curr_timebase);\r\nreturn (tmp + scale / 2) / scale;\r\n}\r\nstatic void\r\npoll_def_tmr(unsigned long dummy)\r\n{\r\nif (opened)\r\n{\r\n{\r\ndef_tmr.expires = (1) + jiffies;\r\nadd_timer(&def_tmr);\r\n}\r\nif (tmr_running)\r\n{\r\nspin_lock(&lock);\r\ntmr_ctr++;\r\ncurr_ticks = ticks_offs + tmr2ticks(tmr_ctr);\r\nif (curr_ticks >= next_event_time)\r\n{\r\nnext_event_time = (unsigned long) -1;\r\nsequencer_timer(0);\r\n}\r\nspin_unlock(&lock);\r\n}\r\n}\r\n}\r\nstatic void\r\ntmr_reset(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock,flags);\r\ntmr_offs = 0;\r\nticks_offs = 0;\r\ntmr_ctr = 0;\r\nnext_event_time = (unsigned long) -1;\r\nprev_event_time = 0;\r\ncurr_ticks = 0;\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic int\r\ndef_tmr_open(int dev, int mode)\r\n{\r\nif (opened)\r\nreturn -EBUSY;\r\ntmr_reset();\r\ncurr_tempo = 60;\r\ncurr_timebase = 100;\r\nopened = 1;\r\n{\r\ndef_tmr.expires = (1) + jiffies;\r\nadd_timer(&def_tmr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndef_tmr_close(int dev)\r\n{\r\nopened = tmr_running = 0;\r\ndel_timer(&def_tmr);\r\n}\r\nstatic int\r\ndef_tmr_event(int dev, unsigned char *event)\r\n{\r\nunsigned char cmd = event[1];\r\nunsigned long parm = *(int *) &event[4];\r\nswitch (cmd)\r\n{\r\ncase TMR_WAIT_REL:\r\nparm += prev_event_time;\r\ncase TMR_WAIT_ABS:\r\nif (parm > 0)\r\n{\r\nlong time;\r\nif (parm <= curr_ticks)\r\nreturn TIMER_NOT_ARMED;\r\ntime = parm;\r\nnext_event_time = prev_event_time = time;\r\nreturn TIMER_ARMED;\r\n}\r\nbreak;\r\ncase TMR_START:\r\ntmr_reset();\r\ntmr_running = 1;\r\nbreak;\r\ncase TMR_STOP:\r\ntmr_running = 0;\r\nbreak;\r\ncase TMR_CONTINUE:\r\ntmr_running = 1;\r\nbreak;\r\ncase TMR_TEMPO:\r\nif (parm)\r\n{\r\nif (parm < 8)\r\nparm = 8;\r\nif (parm > 360)\r\nparm = 360;\r\ntmr_offs = tmr_ctr;\r\nticks_offs += tmr2ticks(tmr_ctr);\r\ntmr_ctr = 0;\r\ncurr_tempo = parm;\r\n}\r\nbreak;\r\ncase TMR_ECHO:\r\nseq_copy_to_input(event, 8);\r\nbreak;\r\ndefault:;\r\n}\r\nreturn TIMER_NOT_ARMED;\r\n}\r\nstatic unsigned long\r\ndef_tmr_get_time(int dev)\r\n{\r\nif (!opened)\r\nreturn 0;\r\nreturn curr_ticks;\r\n}\r\nstatic int def_tmr_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nint __user *p = arg;\r\nint val;\r\nswitch (cmd) {\r\ncase SNDCTL_TMR_SOURCE:\r\nreturn __put_user(TMR_INTERNAL, p);\r\ncase SNDCTL_TMR_START:\r\ntmr_reset();\r\ntmr_running = 1;\r\nreturn 0;\r\ncase SNDCTL_TMR_STOP:\r\ntmr_running = 0;\r\nreturn 0;\r\ncase SNDCTL_TMR_CONTINUE:\r\ntmr_running = 1;\r\nreturn 0;\r\ncase SNDCTL_TMR_TIMEBASE:\r\nif (__get_user(val, p))\r\nreturn -EFAULT;\r\nif (val) {\r\nif (val < 1)\r\nval = 1;\r\nif (val > 1000)\r\nval = 1000;\r\ncurr_timebase = val;\r\n}\r\nreturn __put_user(curr_timebase, p);\r\ncase SNDCTL_TMR_TEMPO:\r\nif (__get_user(val, p))\r\nreturn -EFAULT;\r\nif (val) {\r\nif (val < 8)\r\nval = 8;\r\nif (val > 250)\r\nval = 250;\r\ntmr_offs = tmr_ctr;\r\nticks_offs += tmr2ticks(tmr_ctr);\r\ntmr_ctr = 0;\r\ncurr_tempo = val;\r\nreprogram_timer();\r\n}\r\nreturn __put_user(curr_tempo, p);\r\ncase SNDCTL_SEQ_CTRLRATE:\r\nif (__get_user(val, p))\r\nreturn -EFAULT;\r\nif (val != 0)\r\nreturn -EINVAL;\r\nval = ((curr_tempo * curr_timebase) + 30) / 60;\r\nreturn __put_user(val, p);\r\ncase SNDCTL_SEQ_GETTIME:\r\nreturn __put_user(curr_ticks, p);\r\ncase SNDCTL_TMR_METRONOME:\r\nbreak;\r\ndefault:;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\ndef_tmr_arm(int dev, long time)\r\n{\r\nif (time < 0)\r\ntime = curr_ticks + 1;\r\nelse if (time <= curr_ticks)\r\nreturn;\r\nnext_event_time = prev_event_time = time;\r\nreturn;\r\n}
