static inline s16\r\nframe_diff(u16 left, u16 right)\r\n{\r\nreturn ((unsigned) (left - right)) % (USB_MAX_FRAME_NUMBER + 1);\r\n}\r\nstatic inline struct max3421_hcd *\r\nhcd_to_max3421(struct usb_hcd *hcd)\r\n{\r\nreturn (struct max3421_hcd *) hcd->hcd_priv;\r\n}\r\nstatic inline struct usb_hcd *\r\nmax3421_to_hcd(struct max3421_hcd *max3421_hcd)\r\n{\r\nreturn container_of((void *) max3421_hcd, struct usb_hcd, hcd_priv);\r\n}\r\nstatic u8\r\nspi_rd8(struct usb_hcd *hcd, unsigned int reg)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct spi_transfer transfer;\r\nstruct spi_message msg;\r\nmemset(&transfer, 0, sizeof(transfer));\r\nspi_message_init(&msg);\r\nmax3421_hcd->tx->data[0] =\r\n(field(reg, MAX3421_SPI_REG_SHIFT) |\r\nfield(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\r\ntransfer.tx_buf = max3421_hcd->tx->data;\r\ntransfer.rx_buf = max3421_hcd->rx->data;\r\ntransfer.len = 2;\r\nspi_message_add_tail(&transfer, &msg);\r\nspi_sync(spi, &msg);\r\nreturn max3421_hcd->rx->data[1];\r\n}\r\nstatic void\r\nspi_wr8(struct usb_hcd *hcd, unsigned int reg, u8 val)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct spi_transfer transfer;\r\nstruct spi_message msg;\r\nmemset(&transfer, 0, sizeof(transfer));\r\nspi_message_init(&msg);\r\nmax3421_hcd->tx->data[0] =\r\n(field(reg, MAX3421_SPI_REG_SHIFT) |\r\nfield(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\r\nmax3421_hcd->tx->data[1] = val;\r\ntransfer.tx_buf = max3421_hcd->tx->data;\r\ntransfer.len = 2;\r\nspi_message_add_tail(&transfer, &msg);\r\nspi_sync(spi, &msg);\r\n}\r\nstatic void\r\nspi_rd_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct spi_transfer transfer[2];\r\nstruct spi_message msg;\r\nmemset(transfer, 0, sizeof(transfer));\r\nspi_message_init(&msg);\r\nmax3421_hcd->tx->data[0] =\r\n(field(reg, MAX3421_SPI_REG_SHIFT) |\r\nfield(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\r\ntransfer[0].tx_buf = max3421_hcd->tx->data;\r\ntransfer[0].len = 1;\r\ntransfer[1].rx_buf = buf;\r\ntransfer[1].len = len;\r\nspi_message_add_tail(&transfer[0], &msg);\r\nspi_message_add_tail(&transfer[1], &msg);\r\nspi_sync(spi, &msg);\r\n}\r\nstatic void\r\nspi_wr_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct spi_transfer transfer[2];\r\nstruct spi_message msg;\r\nmemset(transfer, 0, sizeof(transfer));\r\nspi_message_init(&msg);\r\nmax3421_hcd->tx->data[0] =\r\n(field(reg, MAX3421_SPI_REG_SHIFT) |\r\nfield(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\r\ntransfer[0].tx_buf = max3421_hcd->tx->data;\r\ntransfer[0].len = 1;\r\ntransfer[1].tx_buf = buf;\r\ntransfer[1].len = len;\r\nspi_message_add_tail(&transfer[0], &msg);\r\nspi_message_add_tail(&transfer[1], &msg);\r\nspi_sync(spi, &msg);\r\n}\r\nstatic void\r\nmax3421_set_speed(struct usb_hcd *hcd, struct usb_device *dev)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nu8 mode_lowspeed, mode_hubpre, mode = max3421_hcd->mode;\r\nmode_lowspeed = BIT(MAX3421_MODE_LOWSPEED_BIT);\r\nmode_hubpre = BIT(MAX3421_MODE_HUBPRE_BIT);\r\nif (max3421_hcd->port_status & USB_PORT_STAT_LOW_SPEED) {\r\nmode |= mode_lowspeed;\r\nmode &= ~mode_hubpre;\r\n} else if (dev->speed == USB_SPEED_LOW) {\r\nmode |= mode_lowspeed | mode_hubpre;\r\n} else {\r\nmode &= ~(mode_lowspeed | mode_hubpre);\r\n}\r\nif (mode != max3421_hcd->mode) {\r\nmax3421_hcd->mode = mode;\r\nspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\r\n}\r\n}\r\nstatic void\r\nmax3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\r\nint force_toggles)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nint old_epnum, same_ep, rcvtog, sndtog;\r\nstruct usb_device *old_dev;\r\nu8 hctl;\r\nold_dev = max3421_hcd->loaded_dev;\r\nold_epnum = max3421_hcd->loaded_epnum;\r\nsame_ep = (dev == old_dev && epnum == old_epnum);\r\nif (same_ep && !force_toggles)\r\nreturn;\r\nif (old_dev && !same_ep) {\r\nu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\r\nrcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\r\nsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\r\nusb_settoggle(old_dev, old_epnum, 0, rcvtog);\r\nusb_settoggle(old_dev, old_epnum, 1, sndtog);\r\n}\r\nrcvtog = usb_gettoggle(dev, epnum, 0);\r\nsndtog = usb_gettoggle(dev, epnum, 1);\r\nhctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\r\nBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\r\nmax3421_hcd->loaded_epnum = epnum;\r\nspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\r\nmax3421_hcd->loaded_dev = dev;\r\nspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\r\n}\r\nstatic int\r\nmax3421_ctrl_setup(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nspi_wr_buf(hcd, MAX3421_REG_SUDFIFO, urb->setup_packet, 8);\r\nreturn MAX3421_HXFR_SETUP;\r\n}\r\nstatic int\r\nmax3421_transfer_in(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nint epnum = usb_pipeendpoint(urb->pipe);\r\nmax3421_hcd->curr_len = 0;\r\nmax3421_hcd->hien |= BIT(MAX3421_HI_RCVDAV_BIT);\r\nreturn MAX3421_HXFR_BULK_IN(epnum);\r\n}\r\nstatic int\r\nmax3421_transfer_out(struct usb_hcd *hcd, struct urb *urb, int fast_retransmit)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nint epnum = usb_pipeendpoint(urb->pipe);\r\nu32 max_packet;\r\nvoid *src;\r\nsrc = urb->transfer_buffer + urb->actual_length;\r\nif (fast_retransmit) {\r\nif (max3421_hcd->rev == 0x12) {\r\nspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\r\nspi_wr8(hcd, MAX3421_REG_SNDFIFO, ((u8 *) src)[0]);\r\nspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\r\n}\r\nreturn MAX3421_HXFR_BULK_OUT(epnum);\r\n}\r\nmax_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\r\nif (max_packet > MAX3421_FIFO_SIZE) {\r\ndev_err(&spi->dev,\r\n"%s: packet-size of %u too big (limit is %u bytes)",\r\n__func__, max_packet, MAX3421_FIFO_SIZE);\r\nmax3421_hcd->urb_done = -EMSGSIZE;\r\nreturn -EMSGSIZE;\r\n}\r\nmax3421_hcd->curr_len = min((urb->transfer_buffer_length -\r\nurb->actual_length), max_packet);\r\nspi_wr_buf(hcd, MAX3421_REG_SNDFIFO, src, max3421_hcd->curr_len);\r\nspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\r\nreturn MAX3421_HXFR_BULK_OUT(epnum);\r\n}\r\nstatic void\r\nmax3421_next_transfer(struct usb_hcd *hcd, int fast_retransmit)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct urb *urb = max3421_hcd->curr_urb;\r\nstruct max3421_ep *max3421_ep;\r\nint cmd = -EINVAL;\r\nif (!urb)\r\nreturn;\r\nmax3421_ep = urb->ep->hcpriv;\r\nswitch (max3421_ep->pkt_state) {\r\ncase PKT_STATE_SETUP:\r\ncmd = max3421_ctrl_setup(hcd, urb);\r\nbreak;\r\ncase PKT_STATE_TRANSFER:\r\nif (usb_urb_dir_in(urb))\r\ncmd = max3421_transfer_in(hcd, urb);\r\nelse\r\ncmd = max3421_transfer_out(hcd, urb, fast_retransmit);\r\nbreak;\r\ncase PKT_STATE_TERMINATE:\r\nif (usb_urb_dir_in(urb))\r\ncmd = MAX3421_HXFR_HS_OUT;\r\nelse\r\ncmd = MAX3421_HXFR_HS_IN;\r\nbreak;\r\n}\r\nif (cmd < 0)\r\nreturn;\r\nspi_wr8(hcd, MAX3421_REG_HXFR, cmd);\r\nmax3421_hcd->hien |= BIT(MAX3421_HI_HXFRDN_BIT);\r\n}\r\nstatic int\r\nmax3421_select_and_start_urb(struct usb_hcd *hcd)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct urb *urb, *curr_urb = NULL;\r\nstruct max3421_ep *max3421_ep;\r\nint epnum, force_toggles = 0;\r\nstruct usb_host_endpoint *ep;\r\nstruct list_head *pos;\r\nunsigned long flags;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nfor (;\r\nmax3421_hcd->sched_pass < SCHED_PASS_DONE;\r\n++max3421_hcd->sched_pass)\r\nlist_for_each(pos, &max3421_hcd->ep_list) {\r\nurb = NULL;\r\nmax3421_ep = container_of(pos, struct max3421_ep,\r\nep_list);\r\nep = max3421_ep->ep;\r\nswitch (usb_endpoint_type(&ep->desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (max3421_hcd->sched_pass !=\r\nSCHED_PASS_PERIODIC)\r\ncontinue;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (max3421_hcd->sched_pass !=\r\nSCHED_PASS_NON_PERIODIC)\r\ncontinue;\r\nbreak;\r\n}\r\nif (list_empty(&ep->urb_list))\r\ncontinue;\r\nurb = list_first_entry(&ep->urb_list, struct urb,\r\nurb_list);\r\nif (urb->unlinked) {\r\ndev_dbg(&spi->dev, "%s: URB %p unlinked=%d",\r\n__func__, urb, urb->unlinked);\r\nmax3421_hcd->curr_urb = urb;\r\nmax3421_hcd->urb_done = 1;\r\nspin_unlock_irqrestore(&max3421_hcd->lock,\r\nflags);\r\nreturn 1;\r\n}\r\nswitch (usb_endpoint_type(&ep->desc)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nif (frame_diff(max3421_ep->last_active,\r\nmax3421_hcd->frame_number) == 0)\r\ncontinue;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (max3421_ep->retransmit\r\n&& (frame_diff(max3421_ep->last_active,\r\nmax3421_hcd->frame_number)\r\n== 0))\r\ncontinue;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (frame_diff(max3421_hcd->frame_number,\r\nmax3421_ep->last_active)\r\n< urb->interval)\r\ncontinue;\r\nbreak;\r\n}\r\nlist_move_tail(pos, &max3421_hcd->ep_list);\r\ncurr_urb = urb;\r\ngoto done;\r\n}\r\ndone:\r\nif (!curr_urb) {\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn 0;\r\n}\r\nurb = max3421_hcd->curr_urb = curr_urb;\r\nepnum = usb_endpoint_num(&urb->ep->desc);\r\nif (max3421_ep->retransmit)\r\nmax3421_ep->retransmit = 0;\r\nelse {\r\nif (usb_endpoint_xfer_control(&ep->desc)) {\r\nusb_settoggle(urb->dev, epnum, 0, 1);\r\nusb_settoggle(urb->dev, epnum, 1, 1);\r\nmax3421_ep->pkt_state = PKT_STATE_SETUP;\r\nforce_toggles = 1;\r\n} else\r\nmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nmax3421_ep->last_active = max3421_hcd->frame_number;\r\nmax3421_set_address(hcd, urb->dev, epnum, force_toggles);\r\nmax3421_set_speed(hcd, urb->dev);\r\nmax3421_next_transfer(hcd, 0);\r\nreturn 1;\r\n}\r\nstatic int\r\nmax3421_check_unlink(struct usb_hcd *hcd)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct list_head *pos, *upos, *next_upos;\r\nstruct max3421_ep *max3421_ep;\r\nstruct usb_host_endpoint *ep;\r\nstruct urb *urb;\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nlist_for_each(pos, &max3421_hcd->ep_list) {\r\nmax3421_ep = container_of(pos, struct max3421_ep, ep_list);\r\nep = max3421_ep->ep;\r\nlist_for_each_safe(upos, next_upos, &ep->urb_list) {\r\nurb = container_of(upos, struct urb, urb_list);\r\nif (urb->unlinked) {\r\nretval = 1;\r\ndev_dbg(&spi->dev, "%s: URB %p unlinked=%d",\r\n__func__, urb, urb->unlinked);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&max3421_hcd->lock,\r\nflags);\r\nusb_hcd_giveback_urb(hcd, urb, 0);\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void\r\nmax3421_slow_retransmit(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct urb *urb = max3421_hcd->curr_urb;\r\nstruct max3421_ep *max3421_ep;\r\nmax3421_ep = urb->ep->hcpriv;\r\nmax3421_ep->retransmit = 1;\r\nmax3421_hcd->curr_urb = NULL;\r\n}\r\nstatic void\r\nmax3421_recv_data_available(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct urb *urb = max3421_hcd->curr_urb;\r\nsize_t remaining, transfer_size;\r\nu8 rcvbc;\r\nrcvbc = spi_rd8(hcd, MAX3421_REG_RCVBC);\r\nif (rcvbc > MAX3421_FIFO_SIZE)\r\nrcvbc = MAX3421_FIFO_SIZE;\r\nif (urb->actual_length >= urb->transfer_buffer_length)\r\nremaining = 0;\r\nelse\r\nremaining = urb->transfer_buffer_length - urb->actual_length;\r\ntransfer_size = rcvbc;\r\nif (transfer_size > remaining)\r\ntransfer_size = remaining;\r\nif (transfer_size > 0) {\r\nvoid *dst = urb->transfer_buffer + urb->actual_length;\r\nspi_rd_buf(hcd, MAX3421_REG_RCVFIFO, dst, transfer_size);\r\nurb->actual_length += transfer_size;\r\nmax3421_hcd->curr_len = transfer_size;\r\n}\r\nspi_wr8(hcd, MAX3421_REG_HIRQ, BIT(MAX3421_HI_RCVDAV_BIT));\r\n}\r\nstatic void\r\nmax3421_handle_error(struct usb_hcd *hcd, u8 hrsl)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nu8 result_code = hrsl & MAX3421_HRSL_RESULT_MASK;\r\nstruct urb *urb = max3421_hcd->curr_urb;\r\nstruct max3421_ep *max3421_ep = urb->ep->hcpriv;\r\nint switch_sndfifo;\r\nswitch_sndfifo = (max3421_ep->pkt_state == PKT_STATE_TRANSFER &&\r\nusb_urb_dir_out(urb));\r\nswitch (result_code) {\r\ncase MAX3421_HRSL_OK:\r\nreturn;\r\ncase MAX3421_HRSL_WRONGPID:\r\ncase MAX3421_HRSL_BUSY:\r\ncase MAX3421_HRSL_BADREQ:\r\ncase MAX3421_HRSL_UNDEF:\r\ncase MAX3421_HRSL_KERR:\r\ncase MAX3421_HRSL_JERR:\r\nmax3421_hcd->urb_done = hrsl_to_error[result_code];\r\ndev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",\r\n__func__, hrsl);\r\nbreak;\r\ncase MAX3421_HRSL_TOGERR:\r\nif (usb_urb_dir_in(urb))\r\n;\r\nelse {\r\nint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\r\nsndtog ^= 1;\r\nspi_wr8(hcd, MAX3421_REG_HCTL,\r\nBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\r\n}\r\ncase MAX3421_HRSL_BADBC:\r\ncase MAX3421_HRSL_PIDERR:\r\ncase MAX3421_HRSL_PKTERR:\r\ncase MAX3421_HRSL_CRCERR:\r\ncase MAX3421_HRSL_BABBLE:\r\ncase MAX3421_HRSL_TIMEOUT:\r\nif (max3421_ep->retries++ < USB_MAX_RETRIES)\r\nmax3421_slow_retransmit(hcd);\r\nelse {\r\nmax3421_hcd->urb_done = hrsl_to_error[result_code];\r\ndev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",\r\n__func__, hrsl);\r\n}\r\nbreak;\r\ncase MAX3421_HRSL_STALL:\r\ndev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",\r\n__func__, hrsl);\r\nmax3421_hcd->urb_done = hrsl_to_error[result_code];\r\nbreak;\r\ncase MAX3421_HRSL_NAK:\r\nif (max3421_ep->naks++ < NAK_MAX_FAST_RETRANSMITS) {\r\nmax3421_next_transfer(hcd, 1);\r\nswitch_sndfifo = 0;\r\n} else\r\nmax3421_slow_retransmit(hcd);\r\nbreak;\r\n}\r\nif (switch_sndfifo)\r\nspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\r\n}\r\nstatic int\r\nmax3421_transfer_in_done(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nu32 max_packet;\r\nif (urb->actual_length >= urb->transfer_buffer_length)\r\nreturn 1;\r\nmax_packet = usb_maxpacket(urb->dev, urb->pipe, 0);\r\nif (max_packet > MAX3421_FIFO_SIZE) {\r\ndev_err(&spi->dev,\r\n"%s: packet-size of %u too big (limit is %u bytes)",\r\n__func__, max_packet, MAX3421_FIFO_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (max3421_hcd->curr_len < max_packet) {\r\nif (urb->transfer_flags & URB_SHORT_NOT_OK) {\r\nreturn -EREMOTEIO;\r\n} else\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmax3421_transfer_out_done(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nurb->actual_length += max3421_hcd->curr_len;\r\nif (urb->actual_length < urb->transfer_buffer_length)\r\nreturn 0;\r\nif (urb->transfer_flags & URB_ZERO_PACKET) {\r\nu32 max_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\r\nif (max3421_hcd->curr_len == max_packet)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nmax3421_host_transfer_done(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct urb *urb = max3421_hcd->curr_urb;\r\nstruct max3421_ep *max3421_ep;\r\nu8 result_code, hrsl;\r\nint urb_done = 0;\r\nmax3421_hcd->hien &= ~(BIT(MAX3421_HI_HXFRDN_BIT) |\r\nBIT(MAX3421_HI_RCVDAV_BIT));\r\nhrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\r\nresult_code = hrsl & MAX3421_HRSL_RESULT_MASK;\r\n#ifdef DEBUG\r\n++max3421_hcd->err_stat[result_code];\r\n#endif\r\nmax3421_ep = urb->ep->hcpriv;\r\nif (unlikely(result_code != MAX3421_HRSL_OK)) {\r\nmax3421_handle_error(hcd, hrsl);\r\nreturn;\r\n}\r\nmax3421_ep->naks = 0;\r\nmax3421_ep->retries = 0;\r\nswitch (max3421_ep->pkt_state) {\r\ncase PKT_STATE_SETUP:\r\nif (urb->transfer_buffer_length > 0)\r\nmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\r\nelse\r\nmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\r\nbreak;\r\ncase PKT_STATE_TRANSFER:\r\nif (usb_urb_dir_in(urb))\r\nurb_done = max3421_transfer_in_done(hcd, urb);\r\nelse\r\nurb_done = max3421_transfer_out_done(hcd, urb);\r\nif (urb_done > 0 && usb_pipetype(urb->pipe) == PIPE_CONTROL) {\r\nmax3421_hcd->urb_done = urb_done = 0;\r\nmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\r\n}\r\nbreak;\r\ncase PKT_STATE_TERMINATE:\r\nurb_done = 1;\r\nbreak;\r\n}\r\nif (urb_done)\r\nmax3421_hcd->urb_done = urb_done;\r\nelse\r\nmax3421_next_transfer(hcd, 0);\r\n}\r\nstatic void\r\nmax3421_detect_conn(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nunsigned int jk, have_conn = 0;\r\nu32 old_port_status, chg;\r\nunsigned long flags;\r\nu8 hrsl, mode;\r\nhrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\r\njk = ((((hrsl >> MAX3421_HRSL_JSTATUS_BIT) & 1) << 0) |\r\n(((hrsl >> MAX3421_HRSL_KSTATUS_BIT) & 1) << 1));\r\nmode = max3421_hcd->mode;\r\nswitch (jk) {\r\ncase 0x0:\r\nmode &= ~BIT(MAX3421_MODE_SOFKAENAB_BIT);\r\nbreak;\r\ncase 0x1:\r\ncase 0x2:\r\nif (jk == 0x2)\r\nmode ^= BIT(MAX3421_MODE_LOWSPEED_BIT);\r\nmode |= BIT(MAX3421_MODE_SOFKAENAB_BIT);\r\nhave_conn = 1;\r\nbreak;\r\ncase 0x3:\r\nbreak;\r\n}\r\nmax3421_hcd->mode = mode;\r\nspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nold_port_status = max3421_hcd->port_status;\r\nif (have_conn)\r\nmax3421_hcd->port_status |= USB_PORT_STAT_CONNECTION;\r\nelse\r\nmax3421_hcd->port_status &= ~USB_PORT_STAT_CONNECTION;\r\nif (mode & BIT(MAX3421_MODE_LOWSPEED_BIT))\r\nmax3421_hcd->port_status |= USB_PORT_STAT_LOW_SPEED;\r\nelse\r\nmax3421_hcd->port_status &= ~USB_PORT_STAT_LOW_SPEED;\r\nchg = (old_port_status ^ max3421_hcd->port_status);\r\nmax3421_hcd->port_status |= chg << 16;\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\n}\r\nstatic irqreturn_t\r\nmax3421_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct usb_hcd *hcd = dev_id;\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nif (max3421_hcd->spi_thread &&\r\nmax3421_hcd->spi_thread->state != TASK_RUNNING)\r\nwake_up_process(max3421_hcd->spi_thread);\r\nif (!test_and_set_bit(ENABLE_IRQ, &max3421_hcd->todo))\r\ndisable_irq_nosync(spi->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ndump_eps(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct max3421_ep *max3421_ep;\r\nstruct usb_host_endpoint *ep;\r\nstruct list_head *pos, *upos;\r\nchar ubuf[512], *dp, *end;\r\nunsigned long flags;\r\nstruct urb *urb;\r\nint epnum, ret;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nlist_for_each(pos, &max3421_hcd->ep_list) {\r\nmax3421_ep = container_of(pos, struct max3421_ep, ep_list);\r\nep = max3421_ep->ep;\r\ndp = ubuf;\r\nend = dp + sizeof(ubuf);\r\n*dp = '\0';\r\nlist_for_each(upos, &ep->urb_list) {\r\nurb = container_of(upos, struct urb, urb_list);\r\nret = snprintf(dp, end - dp, " %p(%d.%s %d/%d)", urb,\r\nusb_pipetype(urb->pipe),\r\nusb_urb_dir_in(urb) ? "IN" : "OUT",\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\nif (ret < 0 || ret >= end - dp)\r\nbreak;\r\ndp += ret;\r\n}\r\nepnum = usb_endpoint_num(&ep->desc);\r\npr_info("EP%0u %u lst %04u rtr %u nak %6u rxmt %u: %s\n",\r\nepnum, max3421_ep->pkt_state, max3421_ep->last_active,\r\nmax3421_ep->retries, max3421_ep->naks,\r\nmax3421_ep->retransmit, ubuf);\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\n}\r\nstatic int\r\nmax3421_handle_irqs(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nu32 chg, old_port_status;\r\nunsigned long flags;\r\nu8 hirq;\r\nhirq = spi_rd8(hcd, MAX3421_REG_HIRQ);\r\nhirq &= max3421_hcd->hien;\r\nif (!hirq)\r\nreturn 0;\r\nspi_wr8(hcd, MAX3421_REG_HIRQ,\r\nhirq & ~(BIT(MAX3421_HI_SNDBAV_BIT) |\r\nBIT(MAX3421_HI_RCVDAV_BIT)));\r\nif (hirq & BIT(MAX3421_HI_FRAME_BIT)) {\r\nmax3421_hcd->frame_number = ((max3421_hcd->frame_number + 1)\r\n& USB_MAX_FRAME_NUMBER);\r\nmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\r\n}\r\nif (hirq & BIT(MAX3421_HI_RCVDAV_BIT))\r\nmax3421_recv_data_available(hcd);\r\nif (hirq & BIT(MAX3421_HI_HXFRDN_BIT))\r\nmax3421_host_transfer_done(hcd);\r\nif (hirq & BIT(MAX3421_HI_CONDET_BIT))\r\nmax3421_detect_conn(hcd);\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nold_port_status = max3421_hcd->port_status;\r\nif (hirq & BIT(MAX3421_HI_BUSEVENT_BIT)) {\r\nif (max3421_hcd->port_status & USB_PORT_STAT_RESET) {\r\nmax3421_hcd->port_status &= ~USB_PORT_STAT_RESET;\r\nmax3421_hcd->port_status |= USB_PORT_STAT_ENABLE;\r\n} else {\r\npr_info("%s: BUSEVENT Bus Resume Done\n", __func__);\r\n}\r\n}\r\nif (hirq & BIT(MAX3421_HI_RWU_BIT))\r\npr_info("%s: RWU\n", __func__);\r\nif (hirq & BIT(MAX3421_HI_SUSDN_BIT))\r\npr_info("%s: SUSDN\n", __func__);\r\nchg = (old_port_status ^ max3421_hcd->port_status);\r\nmax3421_hcd->port_status |= chg << 16;\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\n#ifdef DEBUG\r\n{\r\nstatic unsigned long last_time;\r\nchar sbuf[16 * 16], *dp, *end;\r\nint i;\r\nif (jiffies - last_time > 5*HZ) {\r\ndp = sbuf;\r\nend = sbuf + sizeof(sbuf);\r\n*dp = '\0';\r\nfor (i = 0; i < 16; ++i) {\r\nint ret = snprintf(dp, end - dp, " %lu",\r\nmax3421_hcd->err_stat[i]);\r\nif (ret < 0 || ret >= end - dp)\r\nbreak;\r\ndp += ret;\r\n}\r\npr_info("%s: hrsl_stats %s\n", __func__, sbuf);\r\nmemset(max3421_hcd->err_stat, 0,\r\nsizeof(max3421_hcd->err_stat));\r\nlast_time = jiffies;\r\ndump_eps(hcd);\r\n}\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int\r\nmax3421_reset_hcd(struct usb_hcd *hcd)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nint timeout;\r\nspi_wr8(hcd, MAX3421_REG_USBCTL, BIT(MAX3421_USBCTL_CHIPRES_BIT));\r\nspi_wr8(hcd, MAX3421_REG_USBCTL, 0);\r\ntimeout = 1000;\r\nwhile (1) {\r\nif (spi_rd8(hcd, MAX3421_REG_USBIRQ)\r\n& BIT(MAX3421_USBIRQ_OSCOKIRQ_BIT))\r\nbreak;\r\nif (--timeout < 0) {\r\ndev_err(&spi->dev,\r\n"timed out waiting for oscillator OK signal");\r\nreturn 1;\r\n}\r\ncond_resched();\r\n}\r\nmax3421_hcd->mode = (BIT(MAX3421_MODE_HOST_BIT) |\r\nBIT(MAX3421_MODE_SOFKAENAB_BIT) |\r\nBIT(MAX3421_MODE_DMPULLDN_BIT) |\r\nBIT(MAX3421_MODE_DPPULLDN_BIT));\r\nspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\r\nmax3421_hcd->frame_number = USB_MAX_FRAME_NUMBER;\r\nspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_FRMRST_BIT));\r\nspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_SAMPLEBUS_BIT));\r\nmax3421_detect_conn(hcd);\r\nmax3421_hcd->hien = (BIT(MAX3421_HI_FRAME_BIT) |\r\nBIT(MAX3421_HI_CONDET_BIT) |\r\nBIT(MAX3421_HI_BUSEVENT_BIT));\r\nspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\r\nspi_wr8(hcd, MAX3421_REG_CPUCTL, BIT(MAX3421_CPUCTL_IE_BIT));\r\nreturn 1;\r\n}\r\nstatic int\r\nmax3421_urb_done(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nunsigned long flags;\r\nstruct urb *urb;\r\nint status;\r\nstatus = max3421_hcd->urb_done;\r\nmax3421_hcd->urb_done = 0;\r\nif (status > 0)\r\nstatus = 0;\r\nurb = max3421_hcd->curr_urb;\r\nif (urb) {\r\nmax3421_hcd->curr_urb = NULL;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nmax3421_spi_thread(void *dev_id)\r\n{\r\nstruct usb_hcd *hcd = dev_id;\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nint i, i_worked = 1;\r\nspi_wr8(hcd, MAX3421_REG_PINCTL,\r\n(BIT(MAX3421_PINCTL_FDUPSPI_BIT) |\r\nBIT(MAX3421_PINCTL_INTLEVEL_BIT)));\r\nwhile (!kthread_should_stop()) {\r\nmax3421_hcd->rev = spi_rd8(hcd, MAX3421_REG_REVISION);\r\nif (max3421_hcd->rev == 0x12 || max3421_hcd->rev == 0x13)\r\nbreak;\r\ndev_err(&spi->dev, "bad rev 0x%02x", max3421_hcd->rev);\r\nmsleep(10000);\r\n}\r\ndev_info(&spi->dev, "rev 0x%x, SPI clk %dHz, bpw %u, irq %d\n",\r\nmax3421_hcd->rev, spi->max_speed_hz, spi->bits_per_word,\r\nspi->irq);\r\nwhile (!kthread_should_stop()) {\r\nif (!i_worked) {\r\nspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (test_and_clear_bit(ENABLE_IRQ, &max3421_hcd->todo))\r\nenable_irq(spi->irq);\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\n}\r\ni_worked = 0;\r\nif (max3421_hcd->urb_done)\r\ni_worked |= max3421_urb_done(hcd);\r\nelse if (max3421_handle_irqs(hcd))\r\ni_worked = 1;\r\nelse if (!max3421_hcd->curr_urb)\r\ni_worked |= max3421_select_and_start_urb(hcd);\r\nif (test_and_clear_bit(RESET_HCD, &max3421_hcd->todo))\r\ni_worked |= max3421_reset_hcd(hcd);\r\nif (test_and_clear_bit(RESET_PORT, &max3421_hcd->todo)) {\r\nspi_wr8(hcd, MAX3421_REG_HCTL,\r\nBIT(MAX3421_HCTL_BUSRST_BIT));\r\ni_worked = 1;\r\n}\r\nif (test_and_clear_bit(CHECK_UNLINK, &max3421_hcd->todo))\r\ni_worked |= max3421_check_unlink(hcd);\r\nif (test_and_clear_bit(IOPIN_UPDATE, &max3421_hcd->todo)) {\r\nfor (i = 0; i < ARRAY_SIZE(max3421_hcd->iopins); ++i) {\r\nu8 val = spi_rd8(hcd, MAX3421_REG_IOPINS1);\r\nval = ((val & 0xf0) |\r\n(max3421_hcd->iopins[i] & 0x0f));\r\nspi_wr8(hcd, MAX3421_REG_IOPINS1 + i, val);\r\nmax3421_hcd->iopins[i] = val;\r\n}\r\ni_worked = 1;\r\n}\r\n}\r\nset_current_state(TASK_RUNNING);\r\ndev_info(&spi->dev, "SPI thread exiting");\r\nreturn 0;\r\n}\r\nstatic int\r\nmax3421_reset_port(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nmax3421_hcd->port_status &= ~(USB_PORT_STAT_ENABLE |\r\nUSB_PORT_STAT_LOW_SPEED);\r\nmax3421_hcd->port_status |= USB_PORT_STAT_RESET;\r\nset_bit(RESET_PORT, &max3421_hcd->todo);\r\nwake_up_process(max3421_hcd->spi_thread);\r\nreturn 0;\r\n}\r\nstatic int\r\nmax3421_reset(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nhcd->self.sg_tablesize = 0;\r\nhcd->speed = HCD_USB2;\r\nhcd->self.root_hub->speed = USB_SPEED_FULL;\r\nset_bit(RESET_HCD, &max3421_hcd->todo);\r\nwake_up_process(max3421_hcd->spi_thread);\r\nreturn 0;\r\n}\r\nstatic int\r\nmax3421_start(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nspin_lock_init(&max3421_hcd->lock);\r\nmax3421_hcd->rh_state = MAX3421_RH_RUNNING;\r\nINIT_LIST_HEAD(&max3421_hcd->ep_list);\r\nhcd->power_budget = POWER_BUDGET;\r\nhcd->state = HC_STATE_RUNNING;\r\nhcd->uses_new_polling = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nmax3421_stop(struct usb_hcd *hcd)\r\n{\r\n}\r\nstatic int\r\nmax3421_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct max3421_ep *max3421_ep;\r\nunsigned long flags;\r\nint retval;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_INTERRUPT:\r\ncase PIPE_ISOCHRONOUS:\r\nif (urb->interval < 0) {\r\ndev_err(&spi->dev,\r\n"%s: interval=%d for intr-/iso-pipe; expected > 0\n",\r\n__func__, urb->interval);\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nmax3421_ep = urb->ep->hcpriv;\r\nif (!max3421_ep) {\r\nmax3421_ep = kzalloc(sizeof(struct max3421_ep), GFP_ATOMIC);\r\nif (!max3421_ep) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nmax3421_ep->ep = urb->ep;\r\nmax3421_ep->last_active = max3421_hcd->frame_number;\r\nurb->ep->hcpriv = max3421_ep;\r\nlist_add_tail(&max3421_ep->ep_list, &max3421_hcd->ep_list);\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval == 0) {\r\nmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\r\nwake_up_process(max3421_hcd->spi_thread);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\nmax3421_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nretval = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (retval == 0) {\r\nset_bit(CHECK_UNLINK, &max3421_hcd->todo);\r\nwake_up_process(max3421_hcd->spi_thread);\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void\r\nmax3421_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nunsigned long flags;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nif (ep->hcpriv) {\r\nstruct max3421_ep *max3421_ep = ep->hcpriv;\r\nif (!list_empty(&max3421_ep->ep_list))\r\nlist_del(&max3421_ep->ep_list);\r\nkfree(max3421_ep);\r\nep->hcpriv = NULL;\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\n}\r\nstatic int\r\nmax3421_get_frame_number(struct usb_hcd *hcd)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nreturn max3421_hcd->frame_number;\r\n}\r\nstatic int\r\nmax3421_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\ngoto done;\r\n*buf = 0;\r\nif ((max3421_hcd->port_status & PORT_C_MASK) != 0) {\r\n*buf = (1 << 1);\r\ndev_dbg(hcd->self.controller,\r\n"port status 0x%08x has changes\n",\r\nmax3421_hcd->port_status);\r\nretval = 1;\r\nif (max3421_hcd->rh_state == MAX3421_RH_SUSPENDED)\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic inline void\r\nhub_descriptor(struct usb_hub_descriptor *desc)\r\n{\r\nmemset(desc, 0, sizeof(*desc));\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bDescLength = 9;\r\ndesc->wHubCharacteristics = cpu_to_le16(0x0001);\r\ndesc->bNbrPorts = 1;\r\n}\r\nstatic void\r\nmax3421_gpout_set_value(struct usb_hcd *hcd, u8 pin_number, u8 value)\r\n{\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nu8 mask, idx;\r\n--pin_number;\r\nif (pin_number > 7)\r\nreturn;\r\nmask = 1u << pin_number;\r\nidx = pin_number / 4;\r\nif (value)\r\nmax3421_hcd->iopins[idx] |= mask;\r\nelse\r\nmax3421_hcd->iopins[idx] &= ~mask;\r\nset_bit(IOPIN_UPDATE, &max3421_hcd->todo);\r\nwake_up_process(max3421_hcd->spi_thread);\r\n}\r\nstatic int\r\nmax3421_hub_control(struct usb_hcd *hcd, u16 type_req, u16 value, u16 index,\r\nchar *buf, u16 length)\r\n{\r\nstruct spi_device *spi = to_spi_device(hcd->self.controller);\r\nstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\r\nstruct max3421_hcd_platform_data *pdata;\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\npdata = spi->dev.platform_data;\r\nswitch (type_req) {\r\ncase ClearHubFeature:\r\nbreak;\r\ncase ClearPortFeature:\r\nswitch (value) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(hcd->self.controller, "power-off\n");\r\nmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\r\n!pdata->vbus_active_level);\r\ndefault:\r\nmax3421_hcd->port_status &= ~(1 << value);\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nhub_descriptor((struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\r\ncase GetPortErrorCount:\r\ncase SetHubDepth:\r\ngoto error;\r\ncase GetHubStatus:\r\n*(__le32 *) buf = cpu_to_le32(0);\r\nbreak;\r\ncase GetPortStatus:\r\nif (index != 1) {\r\nretval = -EPIPE;\r\ngoto error;\r\n}\r\n((__le16 *) buf)[0] = cpu_to_le16(max3421_hcd->port_status);\r\n((__le16 *) buf)[1] =\r\ncpu_to_le16(max3421_hcd->port_status >> 16);\r\nbreak;\r\ncase SetHubFeature:\r\nretval = -EPIPE;\r\nbreak;\r\ncase SetPortFeature:\r\nswitch (value) {\r\ncase USB_PORT_FEAT_LINK_STATE:\r\ncase USB_PORT_FEAT_U1_TIMEOUT:\r\ncase USB_PORT_FEAT_U2_TIMEOUT:\r\ncase USB_PORT_FEAT_BH_PORT_RESET:\r\ngoto error;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (max3421_hcd->active)\r\nmax3421_hcd->port_status |=\r\nUSB_PORT_STAT_SUSPEND;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(hcd->self.controller, "power-on\n");\r\nmax3421_hcd->port_status |= USB_PORT_STAT_POWER;\r\nmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\r\npdata->vbus_active_level);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nmax3421_reset_port(hcd);\r\ndefault:\r\nif ((max3421_hcd->port_status & USB_PORT_STAT_POWER)\r\n!= 0)\r\nmax3421_hcd->port_status |= (1 << value);\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(hcd->self.controller,\r\n"hub control req%04x v%04x i%04x l%d\n",\r\ntype_req, value, index, length);\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\nmax3421_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nreturn -1;\r\n}\r\nstatic int\r\nmax3421_bus_resume(struct usb_hcd *hcd)\r\n{\r\nreturn -1;\r\n}\r\nstatic int\r\nmax3421_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nmax3421_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\n}\r\nstatic int\r\nmax3421_probe(struct spi_device *spi)\r\n{\r\nstruct max3421_hcd *max3421_hcd;\r\nstruct usb_hcd *hcd = NULL;\r\nint retval = -ENOMEM;\r\nif (spi_setup(spi) < 0) {\r\ndev_err(&spi->dev, "Unable to setup SPI bus");\r\nreturn -EFAULT;\r\n}\r\nhcd = usb_create_hcd(&max3421_hcd_desc, &spi->dev,\r\ndev_name(&spi->dev));\r\nif (!hcd) {\r\ndev_err(&spi->dev, "failed to create HCD structure\n");\r\ngoto error;\r\n}\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nmax3421_hcd = hcd_to_max3421(hcd);\r\nmax3421_hcd->next = max3421_hcd_list;\r\nmax3421_hcd_list = max3421_hcd;\r\nINIT_LIST_HEAD(&max3421_hcd->ep_list);\r\nmax3421_hcd->tx = kmalloc(sizeof(*max3421_hcd->tx), GFP_KERNEL);\r\nif (!max3421_hcd->tx) {\r\ndev_err(&spi->dev, "failed to kmalloc tx buffer\n");\r\ngoto error;\r\n}\r\nmax3421_hcd->rx = kmalloc(sizeof(*max3421_hcd->rx), GFP_KERNEL);\r\nif (!max3421_hcd->rx) {\r\ndev_err(&spi->dev, "failed to kmalloc rx buffer\n");\r\ngoto error;\r\n}\r\nmax3421_hcd->spi_thread = kthread_run(max3421_spi_thread, hcd,\r\n"max3421_spi_thread");\r\nif (max3421_hcd->spi_thread == ERR_PTR(-ENOMEM)) {\r\ndev_err(&spi->dev,\r\n"failed to create SPI thread (out of memory)\n");\r\ngoto error;\r\n}\r\nretval = usb_add_hcd(hcd, 0, 0);\r\nif (retval) {\r\ndev_err(&spi->dev, "failed to add HCD\n");\r\ngoto error;\r\n}\r\nretval = request_irq(spi->irq, max3421_irq_handler,\r\nIRQF_TRIGGER_LOW, "max3421", hcd);\r\nif (retval < 0) {\r\ndev_err(&spi->dev, "failed to request irq %d\n", spi->irq);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (hcd) {\r\nkfree(max3421_hcd->tx);\r\nkfree(max3421_hcd->rx);\r\nif (max3421_hcd->spi_thread)\r\nkthread_stop(max3421_hcd->spi_thread);\r\nusb_put_hcd(hcd);\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nmax3421_remove(struct spi_device *spi)\r\n{\r\nstruct max3421_hcd *max3421_hcd = NULL, **prev;\r\nstruct usb_hcd *hcd = NULL;\r\nunsigned long flags;\r\nfor (prev = &max3421_hcd_list; *prev; prev = &(*prev)->next) {\r\nmax3421_hcd = *prev;\r\nhcd = max3421_to_hcd(max3421_hcd);\r\nif (hcd->self.controller == &spi->dev)\r\nbreak;\r\n}\r\nif (!max3421_hcd) {\r\ndev_err(&spi->dev, "no MAX3421 HCD found for SPI device %p\n",\r\nspi);\r\nreturn -ENODEV;\r\n}\r\nusb_remove_hcd(hcd);\r\nspin_lock_irqsave(&max3421_hcd->lock, flags);\r\nkthread_stop(max3421_hcd->spi_thread);\r\n*prev = max3421_hcd->next;\r\nspin_unlock_irqrestore(&max3421_hcd->lock, flags);\r\nfree_irq(spi->irq, hcd);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}
