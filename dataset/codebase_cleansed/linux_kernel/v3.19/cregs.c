static int copy_to_creg_data(struct rsxx_cardinfo *card,\r\nint cnt8,\r\nvoid *buf,\r\nunsigned int stream)\r\n{\r\nint i = 0;\r\nu32 *data = buf;\r\nif (unlikely(card->eeh_state))\r\nreturn -EIO;\r\nfor (i = 0; cnt8 > 0; i++, cnt8 -= 4) {\r\nif (LITTLE_ENDIAN && stream)\r\niowrite32be(data[i], card->regmap + CREG_DATA(i));\r\nelse\r\niowrite32(data[i], card->regmap + CREG_DATA(i));\r\n}\r\nreturn 0;\r\n}\r\nstatic int copy_from_creg_data(struct rsxx_cardinfo *card,\r\nint cnt8,\r\nvoid *buf,\r\nunsigned int stream)\r\n{\r\nint i = 0;\r\nu32 *data = buf;\r\nif (unlikely(card->eeh_state))\r\nreturn -EIO;\r\nfor (i = 0; cnt8 > 0; i++, cnt8 -= 4) {\r\nif (LITTLE_ENDIAN && stream)\r\ndata[i] = ioread32be(card->regmap + CREG_DATA(i));\r\nelse\r\ndata[i] = ioread32(card->regmap + CREG_DATA(i));\r\n}\r\nreturn 0;\r\n}\r\nstatic void creg_issue_cmd(struct rsxx_cardinfo *card, struct creg_cmd *cmd)\r\n{\r\nint st;\r\nif (unlikely(card->eeh_state))\r\nreturn;\r\niowrite32(cmd->addr, card->regmap + CREG_ADD);\r\niowrite32(cmd->cnt8, card->regmap + CREG_CNT);\r\nif (cmd->op == CREG_OP_WRITE) {\r\nif (cmd->buf) {\r\nst = copy_to_creg_data(card, cmd->cnt8,\r\ncmd->buf, cmd->stream);\r\nif (st)\r\nreturn;\r\n}\r\n}\r\nif (unlikely(card->eeh_state))\r\nreturn;\r\niowrite32(cmd->op, card->regmap + CREG_CMD);\r\n}\r\nstatic void creg_kick_queue(struct rsxx_cardinfo *card)\r\n{\r\nif (card->creg_ctrl.active || list_empty(&card->creg_ctrl.queue))\r\nreturn;\r\ncard->creg_ctrl.active = 1;\r\ncard->creg_ctrl.active_cmd = list_first_entry(&card->creg_ctrl.queue,\r\nstruct creg_cmd, list);\r\nlist_del(&card->creg_ctrl.active_cmd->list);\r\ncard->creg_ctrl.q_depth--;\r\nmod_timer(&card->creg_ctrl.cmd_timer,\r\njiffies + msecs_to_jiffies(CREG_TIMEOUT_MSEC));\r\ncreg_issue_cmd(card, card->creg_ctrl.active_cmd);\r\n}\r\nstatic int creg_queue_cmd(struct rsxx_cardinfo *card,\r\nunsigned int op,\r\nunsigned int addr,\r\nunsigned int cnt8,\r\nvoid *buf,\r\nint stream,\r\ncreg_cmd_cb callback,\r\nvoid *cb_private)\r\n{\r\nstruct creg_cmd *cmd;\r\nif (unlikely(card->halt))\r\nreturn -EINVAL;\r\nif (card->creg_ctrl.reset)\r\nreturn -EAGAIN;\r\nif (cnt8 > MAX_CREG_DATA8)\r\nreturn -EINVAL;\r\ncmd = kmem_cache_alloc(creg_cmd_pool, GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&cmd->list);\r\ncmd->op = op;\r\ncmd->addr = addr;\r\ncmd->cnt8 = cnt8;\r\ncmd->buf = buf;\r\ncmd->stream = stream;\r\ncmd->cb = callback;\r\ncmd->cb_private = cb_private;\r\ncmd->status = 0;\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\nlist_add_tail(&cmd->list, &card->creg_ctrl.queue);\r\ncard->creg_ctrl.q_depth++;\r\ncreg_kick_queue(card);\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\nreturn 0;\r\n}\r\nstatic void creg_cmd_timed_out(unsigned long data)\r\n{\r\nstruct rsxx_cardinfo *card = (struct rsxx_cardinfo *) data;\r\nstruct creg_cmd *cmd;\r\nspin_lock(&card->creg_ctrl.lock);\r\ncmd = card->creg_ctrl.active_cmd;\r\ncard->creg_ctrl.active_cmd = NULL;\r\nspin_unlock(&card->creg_ctrl.lock);\r\nif (cmd == NULL) {\r\ncard->creg_ctrl.creg_stats.creg_timeout++;\r\ndev_warn(CARD_TO_DEV(card),\r\n"No active command associated with timeout!\n");\r\nreturn;\r\n}\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, -ETIMEDOUT);\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\nspin_lock(&card->creg_ctrl.lock);\r\ncard->creg_ctrl.active = 0;\r\ncreg_kick_queue(card);\r\nspin_unlock(&card->creg_ctrl.lock);\r\n}\r\nstatic void creg_cmd_done(struct work_struct *work)\r\n{\r\nstruct rsxx_cardinfo *card;\r\nstruct creg_cmd *cmd;\r\nint st = 0;\r\ncard = container_of(work, struct rsxx_cardinfo,\r\ncreg_ctrl.done_work);\r\nif (del_timer_sync(&card->creg_ctrl.cmd_timer) == 0)\r\ncard->creg_ctrl.creg_stats.failed_cancel_timer++;\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\ncmd = card->creg_ctrl.active_cmd;\r\ncard->creg_ctrl.active_cmd = NULL;\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\nif (cmd == NULL) {\r\ndev_err(CARD_TO_DEV(card),\r\n"Spurious creg interrupt!\n");\r\nreturn;\r\n}\r\ncard->creg_ctrl.creg_stats.stat = ioread32(card->regmap + CREG_STAT);\r\ncmd->status = card->creg_ctrl.creg_stats.stat;\r\nif ((cmd->status & CREG_STAT_STATUS_MASK) == 0) {\r\ndev_err(CARD_TO_DEV(card),\r\n"Invalid status on creg command\n");\r\nst = -EIO;\r\ngoto creg_done;\r\n} else if (cmd->status & CREG_STAT_ERROR) {\r\nst = -EIO;\r\n}\r\nif ((cmd->op == CREG_OP_READ)) {\r\nunsigned int cnt8 = ioread32(card->regmap + CREG_CNT);\r\nif (!cmd->buf) {\r\ndev_err(CARD_TO_DEV(card),\r\n"Buffer not given for read.\n");\r\nst = -EIO;\r\ngoto creg_done;\r\n}\r\nif (cnt8 != cmd->cnt8) {\r\ndev_err(CARD_TO_DEV(card),\r\n"count mismatch\n");\r\nst = -EIO;\r\ngoto creg_done;\r\n}\r\nst = copy_from_creg_data(card, cnt8, cmd->buf, cmd->stream);\r\n}\r\ncreg_done:\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, st);\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\ncard->creg_ctrl.active = 0;\r\ncreg_kick_queue(card);\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\n}\r\nstatic void creg_reset(struct rsxx_cardinfo *card)\r\n{\r\nstruct creg_cmd *cmd = NULL;\r\nstruct creg_cmd *tmp;\r\nunsigned long flags;\r\nif (!mutex_trylock(&card->creg_ctrl.reset_lock))\r\nreturn;\r\ncard->creg_ctrl.reset = 1;\r\nspin_lock_irqsave(&card->irq_lock, flags);\r\nrsxx_disable_ier_and_isr(card, CR_INTR_CREG | CR_INTR_EVENT);\r\nspin_unlock_irqrestore(&card->irq_lock, flags);\r\ndev_warn(CARD_TO_DEV(card),\r\n"Resetting creg interface for recovery\n");\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\nlist_for_each_entry_safe(cmd, tmp, &card->creg_ctrl.queue, list) {\r\nlist_del(&cmd->list);\r\ncard->creg_ctrl.q_depth--;\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, -ECANCELED);\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\n}\r\ncmd = card->creg_ctrl.active_cmd;\r\ncard->creg_ctrl.active_cmd = NULL;\r\nif (cmd) {\r\nif (timer_pending(&card->creg_ctrl.cmd_timer))\r\ndel_timer_sync(&card->creg_ctrl.cmd_timer);\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, -ECANCELED);\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\ncard->creg_ctrl.active = 0;\r\n}\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\ncard->creg_ctrl.reset = 0;\r\nspin_lock_irqsave(&card->irq_lock, flags);\r\nrsxx_enable_ier_and_isr(card, CR_INTR_CREG | CR_INTR_EVENT);\r\nspin_unlock_irqrestore(&card->irq_lock, flags);\r\nmutex_unlock(&card->creg_ctrl.reset_lock);\r\n}\r\nstatic void creg_cmd_done_cb(struct rsxx_cardinfo *card,\r\nstruct creg_cmd *cmd,\r\nint st)\r\n{\r\nstruct creg_completion *cmd_completion;\r\ncmd_completion = cmd->cb_private;\r\nBUG_ON(!cmd_completion);\r\ncmd_completion->st = st;\r\ncmd_completion->creg_status = cmd->status;\r\ncomplete(cmd_completion->cmd_done);\r\n}\r\nstatic int __issue_creg_rw(struct rsxx_cardinfo *card,\r\nunsigned int op,\r\nunsigned int addr,\r\nunsigned int cnt8,\r\nvoid *buf,\r\nint stream,\r\nunsigned int *hw_stat)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(cmd_done);\r\nstruct creg_completion completion;\r\nunsigned long timeout;\r\nint st;\r\ncompletion.cmd_done = &cmd_done;\r\ncompletion.st = 0;\r\ncompletion.creg_status = 0;\r\nst = creg_queue_cmd(card, op, addr, cnt8, buf, stream, creg_cmd_done_cb,\r\n&completion);\r\nif (st)\r\nreturn st;\r\ntimeout = msecs_to_jiffies(CREG_TIMEOUT_MSEC *\r\ncard->creg_ctrl.q_depth + 20000);\r\nst = wait_for_completion_timeout(completion.cmd_done, timeout);\r\nif (st == 0) {\r\ndev_crit(CARD_TO_DEV(card),\r\n"cregs timer failed\n");\r\ncreg_reset(card);\r\nreturn -EIO;\r\n}\r\n*hw_stat = completion.creg_status;\r\nif (completion.st) {\r\nioread32(card->regmap + SCRATCH);\r\ndev_warn(CARD_TO_DEV(card),\r\n"creg command failed(%d x%08x)\n",\r\ncompletion.st, addr);\r\nreturn completion.st;\r\n}\r\nreturn 0;\r\n}\r\nstatic int issue_creg_rw(struct rsxx_cardinfo *card,\r\nu32 addr,\r\nunsigned int size8,\r\nvoid *data,\r\nint stream,\r\nint read)\r\n{\r\nunsigned int hw_stat;\r\nunsigned int xfer;\r\nunsigned int op;\r\nint st;\r\nop = read ? CREG_OP_READ : CREG_OP_WRITE;\r\ndo {\r\nxfer = min_t(unsigned int, size8, MAX_CREG_DATA8);\r\nst = __issue_creg_rw(card, op, addr, xfer,\r\ndata, stream, &hw_stat);\r\nif (st)\r\nreturn st;\r\ndata = (char *)data + xfer;\r\naddr += xfer;\r\nsize8 -= xfer;\r\n} while (size8);\r\nreturn 0;\r\n}\r\nint rsxx_creg_write(struct rsxx_cardinfo *card,\r\nu32 addr,\r\nunsigned int size8,\r\nvoid *data,\r\nint byte_stream)\r\n{\r\nreturn issue_creg_rw(card, addr, size8, data, byte_stream, 0);\r\n}\r\nint rsxx_creg_read(struct rsxx_cardinfo *card,\r\nu32 addr,\r\nunsigned int size8,\r\nvoid *data,\r\nint byte_stream)\r\n{\r\nreturn issue_creg_rw(card, addr, size8, data, byte_stream, 1);\r\n}\r\nint rsxx_get_card_state(struct rsxx_cardinfo *card, unsigned int *state)\r\n{\r\nreturn rsxx_creg_read(card, CREG_ADD_CARD_STATE,\r\nsizeof(*state), state, 0);\r\n}\r\nint rsxx_get_card_size8(struct rsxx_cardinfo *card, u64 *size8)\r\n{\r\nunsigned int size;\r\nint st;\r\nst = rsxx_creg_read(card, CREG_ADD_CARD_SIZE,\r\nsizeof(size), &size, 0);\r\nif (st)\r\nreturn st;\r\n*size8 = (u64)size * RSXX_HW_BLK_SIZE;\r\nreturn 0;\r\n}\r\nint rsxx_get_num_targets(struct rsxx_cardinfo *card,\r\nunsigned int *n_targets)\r\n{\r\nreturn rsxx_creg_read(card, CREG_ADD_NUM_TARGETS,\r\nsizeof(*n_targets), n_targets, 0);\r\n}\r\nint rsxx_get_card_capabilities(struct rsxx_cardinfo *card,\r\nu32 *capabilities)\r\n{\r\nreturn rsxx_creg_read(card, CREG_ADD_CAPABILITIES,\r\nsizeof(*capabilities), capabilities, 0);\r\n}\r\nint rsxx_issue_card_cmd(struct rsxx_cardinfo *card, u32 cmd)\r\n{\r\nreturn rsxx_creg_write(card, CREG_ADD_CARD_CMD,\r\nsizeof(cmd), &cmd, 0);\r\n}\r\nstatic void hw_log_msg(struct rsxx_cardinfo *card, const char *str, int len)\r\n{\r\nstatic char level;\r\nif ((len > 3) && (str[0] == '<') && (str[2] == '>')) {\r\nlevel = str[1];\r\nstr += 3;\r\nlen -= 3;\r\n}\r\nswitch (level) {\r\ncase '0':\r\ndev_emerg(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '1':\r\ndev_alert(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '2':\r\ndev_crit(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '3':\r\ndev_err(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '4':\r\ndev_warn(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '5':\r\ndev_notice(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '6':\r\ndev_info(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ncase '7':\r\ndev_dbg(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\ndefault:\r\ndev_info(CARD_TO_DEV(card), "HW: %.*s", len, str);\r\nbreak;\r\n}\r\n}\r\nstatic int substrncpy(char *dest, const char *src, int count)\r\n{\r\nint max_cnt = count;\r\nwhile (count) {\r\ncount--;\r\n*dest = *src;\r\nif (*dest == '\0')\r\nbreak;\r\nsrc++;\r\ndest++;\r\n}\r\nreturn max_cnt - count;\r\n}\r\nstatic void read_hw_log_done(struct rsxx_cardinfo *card,\r\nstruct creg_cmd *cmd,\r\nint st)\r\n{\r\nchar *buf;\r\nchar *log_str;\r\nint cnt;\r\nint len;\r\nint off;\r\nbuf = cmd->buf;\r\noff = 0;\r\nif (st)\r\nreturn;\r\nwhile (off < cmd->cnt8) {\r\nlog_str = &card->log.buf[card->log.buf_len];\r\ncnt = min(cmd->cnt8 - off, LOG_BUF_SIZE8 - card->log.buf_len);\r\nlen = substrncpy(log_str, &buf[off], cnt);\r\noff += len;\r\ncard->log.buf_len += len;\r\nif ((log_str[len - 1] == '\0') ||\r\n(card->log.buf_len == LOG_BUF_SIZE8)) {\r\nif (card->log.buf_len != 1)\r\nhw_log_msg(card, card->log.buf,\r\ncard->log.buf_len);\r\ncard->log.buf_len = 0;\r\n}\r\n}\r\nif (cmd->status & CREG_STAT_LOG_PENDING)\r\nrsxx_read_hw_log(card);\r\n}\r\nint rsxx_read_hw_log(struct rsxx_cardinfo *card)\r\n{\r\nint st;\r\nst = creg_queue_cmd(card, CREG_OP_READ, CREG_ADD_LOG,\r\nsizeof(card->log.tmp), card->log.tmp,\r\n1, read_hw_log_done, NULL);\r\nif (st)\r\ndev_err(CARD_TO_DEV(card),\r\n"Failed getting log text\n");\r\nreturn st;\r\n}\r\nstatic int issue_reg_cmd(struct rsxx_cardinfo *card,\r\nstruct rsxx_reg_access *cmd,\r\nint read)\r\n{\r\nunsigned int op = read ? CREG_OP_READ : CREG_OP_WRITE;\r\nreturn __issue_creg_rw(card, op, cmd->addr, cmd->cnt, cmd->data,\r\ncmd->stream, &cmd->stat);\r\n}\r\nint rsxx_reg_access(struct rsxx_cardinfo *card,\r\nstruct rsxx_reg_access __user *ucmd,\r\nint read)\r\n{\r\nstruct rsxx_reg_access cmd;\r\nint st;\r\nst = copy_from_user(&cmd, ucmd, sizeof(cmd));\r\nif (st)\r\nreturn -EFAULT;\r\nif (cmd.cnt > RSXX_MAX_REG_CNT)\r\nreturn -EFAULT;\r\nst = issue_reg_cmd(card, &cmd, read);\r\nif (st)\r\nreturn st;\r\nst = put_user(cmd.stat, &ucmd->stat);\r\nif (st)\r\nreturn -EFAULT;\r\nif (read) {\r\nst = copy_to_user(ucmd->data, cmd.data, cmd.cnt);\r\nif (st)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid rsxx_eeh_save_issued_creg(struct rsxx_cardinfo *card)\r\n{\r\nstruct creg_cmd *cmd = NULL;\r\ncmd = card->creg_ctrl.active_cmd;\r\ncard->creg_ctrl.active_cmd = NULL;\r\nif (cmd) {\r\ndel_timer_sync(&card->creg_ctrl.cmd_timer);\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\nlist_add(&cmd->list, &card->creg_ctrl.queue);\r\ncard->creg_ctrl.q_depth++;\r\ncard->creg_ctrl.active = 0;\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\n}\r\n}\r\nvoid rsxx_kick_creg_queue(struct rsxx_cardinfo *card)\r\n{\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\nif (!list_empty(&card->creg_ctrl.queue))\r\ncreg_kick_queue(card);\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\n}\r\nint rsxx_creg_setup(struct rsxx_cardinfo *card)\r\n{\r\ncard->creg_ctrl.active_cmd = NULL;\r\ncard->creg_ctrl.creg_wq =\r\ncreate_singlethread_workqueue(DRIVER_NAME"_creg");\r\nif (!card->creg_ctrl.creg_wq)\r\nreturn -ENOMEM;\r\nINIT_WORK(&card->creg_ctrl.done_work, creg_cmd_done);\r\nmutex_init(&card->creg_ctrl.reset_lock);\r\nINIT_LIST_HEAD(&card->creg_ctrl.queue);\r\nspin_lock_init(&card->creg_ctrl.lock);\r\nsetup_timer(&card->creg_ctrl.cmd_timer, creg_cmd_timed_out,\r\n(unsigned long) card);\r\nreturn 0;\r\n}\r\nvoid rsxx_creg_destroy(struct rsxx_cardinfo *card)\r\n{\r\nstruct creg_cmd *cmd;\r\nstruct creg_cmd *tmp;\r\nint cnt = 0;\r\nspin_lock_bh(&card->creg_ctrl.lock);\r\nlist_for_each_entry_safe(cmd, tmp, &card->creg_ctrl.queue, list) {\r\nlist_del(&cmd->list);\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, -ECANCELED);\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\ncnt++;\r\n}\r\nif (cnt)\r\ndev_info(CARD_TO_DEV(card),\r\n"Canceled %d queue creg commands\n", cnt);\r\ncmd = card->creg_ctrl.active_cmd;\r\ncard->creg_ctrl.active_cmd = NULL;\r\nif (cmd) {\r\nif (timer_pending(&card->creg_ctrl.cmd_timer))\r\ndel_timer_sync(&card->creg_ctrl.cmd_timer);\r\nif (cmd->cb)\r\ncmd->cb(card, cmd, -ECANCELED);\r\ndev_info(CARD_TO_DEV(card),\r\n"Canceled active creg command\n");\r\nkmem_cache_free(creg_cmd_pool, cmd);\r\n}\r\nspin_unlock_bh(&card->creg_ctrl.lock);\r\ncancel_work_sync(&card->creg_ctrl.done_work);\r\n}\r\nint rsxx_creg_init(void)\r\n{\r\ncreg_cmd_pool = KMEM_CACHE(creg_cmd, SLAB_HWCACHE_ALIGN);\r\nif (!creg_cmd_pool)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid rsxx_creg_cleanup(void)\r\n{\r\nkmem_cache_destroy(creg_cmd_pool);\r\n}
