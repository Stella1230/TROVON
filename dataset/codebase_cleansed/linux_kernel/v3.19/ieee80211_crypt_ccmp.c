static void ieee80211_ccmp_aes_encrypt(struct crypto_tfm *tfm,\r\nconst u8 pt[16], u8 ct[16])\r\n{\r\ncrypto_cipher_encrypt_one((void *)tfm, ct, pt);\r\n}\r\nstatic void *ieee80211_ccmp_init(int key_idx)\r\n{\r\nstruct ieee80211_ccmp_data *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\r\nif (priv == NULL)\r\ngoto fail;\r\npriv->key_idx = key_idx;\r\npriv->tfm = (void *)crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->tfm)) {\r\nprintk(KERN_DEBUG "ieee80211_crypt_ccmp: could not allocate "\r\n"crypto API aes\n");\r\npriv->tfm = NULL;\r\ngoto fail;\r\n}\r\nreturn priv;\r\nfail:\r\nif (priv) {\r\nif (priv->tfm)\r\ncrypto_free_cipher((void *)priv->tfm);\r\nkfree(priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ieee80211_ccmp_deinit(void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *_priv = priv;\r\nif (_priv && _priv->tfm)\r\ncrypto_free_cipher((void *)_priv->tfm);\r\nkfree(priv);\r\n}\r\nstatic inline void xor_block(u8 *b, u8 *a, size_t len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nb[i] ^= a[i];\r\n}\r\nstatic void ccmp_init_blocks(struct crypto_tfm *tfm,\r\nstruct ieee80211_hdr_4addr *hdr,\r\nu8 *pn, size_t dlen, u8 *b0, u8 *auth,\r\nu8 *s0)\r\n{\r\nu8 *pos, qc = 0;\r\nsize_t aad_len;\r\nu16 fc;\r\nint a4_included, qc_included;\r\nu8 aad[2 * AES_BLOCK_LEN];\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\na4_included = ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\n(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS));\r\nqc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&\r\n(WLAN_FC_GET_STYPE(fc) & 0x80));\r\naad_len = 22;\r\nif (a4_included)\r\naad_len += 6;\r\nif (qc_included) {\r\npos = (u8 *) &hdr->addr4;\r\nif (a4_included)\r\npos += 6;\r\nqc = *pos & 0x0f;\r\naad_len += 2;\r\n}\r\nb0[0] = 0x59;\r\nb0[1] = qc;\r\nmemcpy(b0 + 2, hdr->addr2, ETH_ALEN);\r\nmemcpy(b0 + 8, pn, CCMP_PN_LEN);\r\nb0[14] = (dlen >> 8) & 0xff;\r\nb0[15] = dlen & 0xff;\r\npos = (u8 *) hdr;\r\naad[0] = 0;\r\naad[1] = aad_len & 0xff;\r\naad[2] = pos[0] & 0x8f;\r\naad[3] = pos[1] & 0xc7;\r\nmemcpy(aad + 4, hdr->addr1, 3 * ETH_ALEN);\r\npos = (u8 *) &hdr->seq_ctl;\r\naad[22] = pos[0] & 0x0f;\r\naad[23] = 0;\r\nmemset(aad + 24, 0, 8);\r\nif (a4_included)\r\nmemcpy(aad + 24, hdr->addr4, ETH_ALEN);\r\nif (qc_included) {\r\naad[a4_included ? 30 : 24] = qc;\r\n}\r\nieee80211_ccmp_aes_encrypt(tfm, b0, auth);\r\nxor_block(auth, aad, AES_BLOCK_LEN);\r\nieee80211_ccmp_aes_encrypt(tfm, auth, auth);\r\nxor_block(auth, &aad[AES_BLOCK_LEN], AES_BLOCK_LEN);\r\nieee80211_ccmp_aes_encrypt(tfm, auth, auth);\r\nb0[0] &= 0x07;\r\nb0[14] = b0[15] = 0;\r\nieee80211_ccmp_aes_encrypt(tfm, b0, s0);\r\n}\r\nstatic int ieee80211_ccmp_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *key = priv;\r\nint data_len, i;\r\nu8 *pos;\r\nstruct ieee80211_hdr_4addr *hdr;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nif (skb_headroom(skb) < CCMP_HDR_LEN ||\r\nskb_tailroom(skb) < CCMP_MIC_LEN ||\r\nskb->len < hdr_len)\r\nreturn -1;\r\ndata_len = skb->len - hdr_len;\r\npos = skb_push(skb, CCMP_HDR_LEN);\r\nmemmove(pos, pos + CCMP_HDR_LEN, hdr_len);\r\npos += hdr_len;\r\ni = CCMP_PN_LEN - 1;\r\nwhile (i >= 0) {\r\nkey->tx_pn[i]++;\r\nif (key->tx_pn[i] != 0)\r\nbreak;\r\ni--;\r\n}\r\n*pos++ = key->tx_pn[5];\r\n*pos++ = key->tx_pn[4];\r\n*pos++ = 0;\r\n*pos++ = (key->key_idx << 6) | (1 << 5) ;\r\n*pos++ = key->tx_pn[3];\r\n*pos++ = key->tx_pn[2];\r\n*pos++ = key->tx_pn[1];\r\n*pos++ = key->tx_pn[0];\r\nhdr = (struct ieee80211_hdr_4addr *) skb->data;\r\nif (!tcb_desc->bHwSec)\r\n{\r\nint blocks, last, len;\r\nu8 *mic;\r\nu8 *b0 = key->tx_b0;\r\nu8 *b = key->tx_b;\r\nu8 *e = key->tx_e;\r\nu8 *s0 = key->tx_s0;\r\nmic = skb_put(skb, CCMP_MIC_LEN);\r\nccmp_init_blocks(key->tfm, hdr, key->tx_pn, data_len, b0, b, s0);\r\nblocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;\r\nlast = data_len % AES_BLOCK_LEN;\r\nfor (i = 1; i <= blocks; i++) {\r\nlen = (i == blocks && last) ? last : AES_BLOCK_LEN;\r\nxor_block(b, pos, len);\r\nieee80211_ccmp_aes_encrypt(key->tfm, b, b);\r\nb0[14] = (i >> 8) & 0xff;\r\nb0[15] = i & 0xff;\r\nieee80211_ccmp_aes_encrypt(key->tfm, b0, e);\r\nxor_block(pos, e, len);\r\npos += len;\r\n}\r\nfor (i = 0; i < CCMP_MIC_LEN; i++)\r\nmic[i] = b[i] ^ s0[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int ieee80211_ccmp_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *key = priv;\r\nu8 keyidx, *pos;\r\nstruct ieee80211_hdr_4addr *hdr;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nu8 pn[6];\r\nif (skb->len < hdr_len + CCMP_HDR_LEN + CCMP_MIC_LEN) {\r\nkey->dot11RSNAStatsCCMPFormatErrors++;\r\nreturn -1;\r\n}\r\nhdr = (struct ieee80211_hdr_4addr *) skb->data;\r\npos = skb->data + hdr_len;\r\nkeyidx = pos[3];\r\nif (!(keyidx & (1 << 5))) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "CCMP: received packet without ExtIV"\r\n" flag from %pM\n", hdr->addr2);\r\n}\r\nkey->dot11RSNAStatsCCMPFormatErrors++;\r\nreturn -2;\r\n}\r\nkeyidx >>= 6;\r\nif (key->key_idx != keyidx) {\r\nprintk(KERN_DEBUG "CCMP: RX tkey->key_idx=%d frame "\r\n"keyidx=%d priv=%p\n", key->key_idx, keyidx, priv);\r\nreturn -6;\r\n}\r\nif (!key->key_set) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "CCMP: received packet from %pM"\r\n" with keyid=%d that does not have a configured"\r\n" key\n", hdr->addr2, keyidx);\r\n}\r\nreturn -3;\r\n}\r\npn[0] = pos[7];\r\npn[1] = pos[6];\r\npn[2] = pos[5];\r\npn[3] = pos[4];\r\npn[4] = pos[1];\r\npn[5] = pos[0];\r\npos += 8;\r\nif (memcmp(pn, key->rx_pn, CCMP_PN_LEN) <= 0) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "CCMP: replay detected: STA=%pM"\r\n" previous PN %pm received PN %pm\n",\r\nhdr->addr2, key->rx_pn, pn);\r\n}\r\nkey->dot11RSNAStatsCCMPReplays++;\r\nreturn -4;\r\n}\r\nif (!tcb_desc->bHwSec)\r\n{\r\nsize_t data_len = skb->len - hdr_len - CCMP_HDR_LEN - CCMP_MIC_LEN;\r\nu8 *mic = skb->data + skb->len - CCMP_MIC_LEN;\r\nu8 *b0 = key->rx_b0;\r\nu8 *b = key->rx_b;\r\nu8 *a = key->rx_a;\r\nint i, blocks, last, len;\r\nccmp_init_blocks(key->tfm, hdr, pn, data_len, b0, a, b);\r\nxor_block(mic, b, CCMP_MIC_LEN);\r\nblocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;\r\nlast = data_len % AES_BLOCK_LEN;\r\nfor (i = 1; i <= blocks; i++) {\r\nlen = (i == blocks && last) ? last : AES_BLOCK_LEN;\r\nb0[14] = (i >> 8) & 0xff;\r\nb0[15] = i & 0xff;\r\nieee80211_ccmp_aes_encrypt(key->tfm, b0, b);\r\nxor_block(pos, b, len);\r\nxor_block(a, pos, len);\r\nieee80211_ccmp_aes_encrypt(key->tfm, a, a);\r\npos += len;\r\n}\r\nif (memcmp(mic, a, CCMP_MIC_LEN) != 0) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "CCMP: decrypt failed: STA="\r\n"%pM\n", hdr->addr2);\r\n}\r\nkey->dot11RSNAStatsCCMPDecryptErrors++;\r\nreturn -5;\r\n}\r\nmemcpy(key->rx_pn, pn, CCMP_PN_LEN);\r\n}\r\nmemmove(skb->data + CCMP_HDR_LEN, skb->data, hdr_len);\r\nskb_pull(skb, CCMP_HDR_LEN);\r\nskb_trim(skb, skb->len - CCMP_MIC_LEN);\r\nreturn keyidx;\r\n}\r\nstatic int ieee80211_ccmp_set_key(void *key, int len, u8 *seq, void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *data = priv;\r\nint keyidx;\r\nstruct crypto_tfm *tfm = data->tfm;\r\nkeyidx = data->key_idx;\r\nmemset(data, 0, sizeof(*data));\r\ndata->key_idx = keyidx;\r\ndata->tfm = tfm;\r\nif (len == CCMP_TK_LEN) {\r\nmemcpy(data->key, key, CCMP_TK_LEN);\r\ndata->key_set = 1;\r\nif (seq) {\r\ndata->rx_pn[0] = seq[5];\r\ndata->rx_pn[1] = seq[4];\r\ndata->rx_pn[2] = seq[3];\r\ndata->rx_pn[3] = seq[2];\r\ndata->rx_pn[4] = seq[1];\r\ndata->rx_pn[5] = seq[0];\r\n}\r\ncrypto_cipher_setkey((void *)data->tfm, data->key, CCMP_TK_LEN);\r\n} else if (len == 0)\r\ndata->key_set = 0;\r\nelse\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ieee80211_ccmp_get_key(void *key, int len, u8 *seq, void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *data = priv;\r\nif (len < CCMP_TK_LEN)\r\nreturn -1;\r\nif (!data->key_set)\r\nreturn 0;\r\nmemcpy(key, data->key, CCMP_TK_LEN);\r\nif (seq) {\r\nseq[0] = data->tx_pn[5];\r\nseq[1] = data->tx_pn[4];\r\nseq[2] = data->tx_pn[3];\r\nseq[3] = data->tx_pn[2];\r\nseq[4] = data->tx_pn[1];\r\nseq[5] = data->tx_pn[0];\r\n}\r\nreturn CCMP_TK_LEN;\r\n}\r\nstatic char *ieee80211_ccmp_print_stats(char *p, void *priv)\r\n{\r\nstruct ieee80211_ccmp_data *ccmp = priv;\r\np += sprintf(p, "key[%d] alg=CCMP key_set=%d "\r\n"tx_pn=%pm rx_pn=%pm "\r\n"format_errors=%d replays=%d decrypt_errors=%d\n",\r\nccmp->key_idx, ccmp->key_set,\r\nccmp->tx_pn, ccmp->rx_pn,\r\nccmp->dot11RSNAStatsCCMPFormatErrors,\r\nccmp->dot11RSNAStatsCCMPReplays,\r\nccmp->dot11RSNAStatsCCMPDecryptErrors);\r\nreturn p;\r\n}\r\nvoid ieee80211_ccmp_null(void)\r\n{\r\nreturn;\r\n}\r\nint __init ieee80211_crypto_ccmp_init(void)\r\n{\r\nreturn ieee80211_register_crypto_ops(&ieee80211_crypt_ccmp);\r\n}\r\nvoid __exit ieee80211_crypto_ccmp_exit(void)\r\n{\r\nieee80211_unregister_crypto_ops(&ieee80211_crypt_ccmp);\r\n}
