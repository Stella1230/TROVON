static inline struct mic_device *mbdev_to_mdev(struct mbus_device *mbdev)\r\n{\r\nreturn dev_get_drvdata(mbdev->dev.parent);\r\n}\r\nstatic dma_addr_t\r\nmic_dma_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *va = phys_to_virt(page_to_phys(page)) + offset;\r\nstruct mic_device *mdev = dev_get_drvdata(dev->parent);\r\nreturn mic_map_single(mdev, va, size);\r\n}\r\nstatic void\r\nmic_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct mic_device *mdev = dev_get_drvdata(dev->parent);\r\nmic_unmap_single(mdev, dma_addr, size);\r\n}\r\nstatic struct mic_irq *\r\n_mic_request_threaded_irq(struct mbus_device *mbdev,\r\nirq_handler_t handler, irq_handler_t thread_fn,\r\nconst char *name, void *data, int intr_src)\r\n{\r\nreturn mic_request_threaded_irq(mbdev_to_mdev(mbdev), handler,\r\nthread_fn, name, data,\r\nintr_src, MIC_INTR_DMA);\r\n}\r\nstatic void _mic_free_irq(struct mbus_device *mbdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nreturn mic_free_irq(mbdev_to_mdev(mbdev), cookie, data);\r\n}\r\nstatic void _mic_ack_interrupt(struct mbus_device *mbdev, int num)\r\n{\r\nstruct mic_device *mdev = mbdev_to_mdev(mbdev);\r\nmdev->ops->intr_workarounds(mdev);\r\n}\r\nstatic void mic_reset(struct mic_device *mdev)\r\n{\r\nint i;\r\n#define MIC_RESET_TO (45)\r\nreinit_completion(&mdev->reset_wait);\r\nmdev->ops->reset_fw_ready(mdev);\r\nmdev->ops->reset(mdev);\r\nfor (i = 0; i < MIC_RESET_TO; i++) {\r\nif (mdev->ops->is_fw_ready(mdev))\r\ngoto done;\r\nmsleep(1000);\r\n}\r\nmic_set_state(mdev, MIC_RESET_FAILED);\r\ndone:\r\ncomplete_all(&mdev->reset_wait);\r\n}\r\nvoid mic_bootparam_init(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\nbootparam->magic = cpu_to_le32(MIC_MAGIC);\r\nbootparam->c2h_shutdown_db = mdev->shutdown_db;\r\nbootparam->h2c_shutdown_db = -1;\r\nbootparam->h2c_config_db = -1;\r\nbootparam->shutdown_status = 0;\r\nbootparam->shutdown_card = 0;\r\n}\r\nint mic_start(struct mic_device *mdev, const char *buf)\r\n{\r\nint rc;\r\nmutex_lock(&mdev->mic_mutex);\r\nretry:\r\nif (MIC_OFFLINE != mdev->state) {\r\nrc = -EINVAL;\r\ngoto unlock_ret;\r\n}\r\nif (!mdev->ops->is_fw_ready(mdev)) {\r\nmic_reset(mdev);\r\ngoto retry;\r\n}\r\nmdev->dma_mbdev = mbus_register_device(mdev->sdev->parent,\r\nMBUS_DEV_DMA_HOST, &mic_dma_ops,\r\n&mbus_hw_ops, mdev->mmio.va);\r\nif (IS_ERR(mdev->dma_mbdev)) {\r\nrc = PTR_ERR(mdev->dma_mbdev);\r\ngoto unlock_ret;\r\n}\r\nmdev->dma_ch = mic_request_dma_chan(mdev);\r\nif (!mdev->dma_ch) {\r\nrc = -ENXIO;\r\ngoto dma_remove;\r\n}\r\nrc = mdev->ops->load_mic_fw(mdev, buf);\r\nif (rc)\r\ngoto dma_release;\r\nmic_smpt_restore(mdev);\r\nmic_intr_restore(mdev);\r\nmdev->intr_ops->enable_interrupts(mdev);\r\nmdev->ops->write_spad(mdev, MIC_DPLO_SPAD, mdev->dp_dma_addr);\r\nmdev->ops->write_spad(mdev, MIC_DPHI_SPAD, mdev->dp_dma_addr >> 32);\r\nmdev->ops->send_firmware_intr(mdev);\r\nmic_set_state(mdev, MIC_ONLINE);\r\ngoto unlock_ret;\r\ndma_release:\r\ndma_release_channel(mdev->dma_ch);\r\ndma_remove:\r\nmbus_unregister_device(mdev->dma_mbdev);\r\nunlock_ret:\r\nmutex_unlock(&mdev->mic_mutex);\r\nreturn rc;\r\n}\r\nvoid mic_stop(struct mic_device *mdev, bool force)\r\n{\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_OFFLINE != mdev->state || force) {\r\nmic_virtio_reset_devices(mdev);\r\nif (mdev->dma_ch) {\r\ndma_release_channel(mdev->dma_ch);\r\nmdev->dma_ch = NULL;\r\n}\r\nmbus_unregister_device(mdev->dma_mbdev);\r\nmic_bootparam_init(mdev);\r\nmic_reset(mdev);\r\nif (MIC_RESET_FAILED == mdev->state)\r\ngoto unlock;\r\nmic_set_shutdown_status(mdev, MIC_NOP);\r\nif (MIC_SUSPENDED != mdev->state)\r\nmic_set_state(mdev, MIC_OFFLINE);\r\n}\r\nunlock:\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_shutdown(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\ns8 db = bootparam->h2c_shutdown_db;\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_ONLINE == mdev->state && db != -1) {\r\nbootparam->shutdown_card = 1;\r\nmdev->ops->send_intr(mdev, db);\r\nmic_set_state(mdev, MIC_SHUTTING_DOWN);\r\n}\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_shutdown_work(struct work_struct *work)\r\n{\r\nstruct mic_device *mdev = container_of(work, struct mic_device,\r\nshutdown_work);\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_shutdown_status(mdev, bootparam->shutdown_status);\r\nbootparam->shutdown_status = 0;\r\nif (MIC_SHUTTING_DOWN != mdev->state &&\r\nMIC_SUSPENDED != mdev->state)\r\nmic_set_state(mdev, MIC_SHUTTING_DOWN);\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_reset_trigger_work(struct work_struct *work)\r\n{\r\nstruct mic_device *mdev = container_of(work, struct mic_device,\r\nreset_trigger_work);\r\nmic_stop(mdev, false);\r\n}\r\nvoid mic_complete_resume(struct mic_device *mdev)\r\n{\r\nif (mdev->state != MIC_SUSPENDED) {\r\ndev_warn(mdev->sdev->parent, "state %d should be %d\n",\r\nmdev->state, MIC_SUSPENDED);\r\nreturn;\r\n}\r\nif (!mdev->ops->is_fw_ready(mdev))\r\nmic_stop(mdev, true);\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_state(mdev, MIC_OFFLINE);\r\nmutex_unlock(&mdev->mic_mutex);\r\n}\r\nvoid mic_prepare_suspend(struct mic_device *mdev)\r\n{\r\nint rc;\r\n#define MIC_SUSPEND_TIMEOUT (60 * HZ)\r\nmutex_lock(&mdev->mic_mutex);\r\nswitch (mdev->state) {\r\ncase MIC_OFFLINE:\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\nbreak;\r\ncase MIC_ONLINE:\r\nmic_set_state(mdev, MIC_SUSPENDING);\r\nmutex_unlock(&mdev->mic_mutex);\r\nrc = wait_for_completion_timeout(&mdev->reset_wait,\r\nMIC_SUSPEND_TIMEOUT);\r\nif (!rc) {\r\nmutex_lock(&mdev->mic_mutex);\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\nmic_stop(mdev, true);\r\n}\r\nbreak;\r\ncase MIC_SHUTTING_DOWN:\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\nmutex_unlock(&mdev->mic_mutex);\r\nrc = wait_for_completion_timeout(&mdev->reset_wait,\r\nMIC_SUSPEND_TIMEOUT);\r\nif (!rc)\r\nmic_stop(mdev, true);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&mdev->mic_mutex);\r\nbreak;\r\n}\r\n}\r\nvoid mic_suspend(struct mic_device *mdev)\r\n{\r\nstruct mic_bootparam *bootparam = mdev->dp;\r\ns8 db = bootparam->h2c_shutdown_db;\r\nmutex_lock(&mdev->mic_mutex);\r\nif (MIC_SUSPENDING == mdev->state && db != -1) {\r\nbootparam->shutdown_card = 1;\r\nmdev->ops->send_intr(mdev, db);\r\nmic_set_state(mdev, MIC_SUSPENDED);\r\n}\r\nmutex_unlock(&mdev->mic_mutex);\r\n}
