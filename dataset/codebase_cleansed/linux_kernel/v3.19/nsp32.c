static void nsp32_message(const char *func, int line, char *type, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[NSP32_DEBUG_BUF_LEN];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\n#ifndef NSP32_DEBUG\r\nprintk("%snsp32: %s\n", type, buf);\r\n#else\r\nprintk("%snsp32: %s (%d): %s\n", type, func, line, buf);\r\n#endif\r\n}\r\nstatic void nsp32_dmessage(const char *func, int line, int mask, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[NSP32_DEBUG_BUF_LEN];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nif (mask & NSP32_DEBUG_MASK) {\r\nprintk("nsp32-debug: 0x%x %s (%d): %s\n", mask, func, line, buf);\r\n}\r\n}\r\nstatic void nsp32_build_identify(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nint pos = data->msgout_len;\r\nint mode = FALSE;\r\nif (disc_priv == 0) {\r\n}\r\ndata->msgoutbuf[pos] = IDENTIFY(mode, SCpnt->device->lun); pos++;\r\ndata->msgout_len = pos;\r\n}\r\nstatic void nsp32_build_sdtr(struct scsi_cmnd *SCpnt,\r\nunsigned char period,\r\nunsigned char offset)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nint pos = data->msgout_len;\r\ndata->msgoutbuf[pos] = EXTENDED_MESSAGE; pos++;\r\ndata->msgoutbuf[pos] = EXTENDED_SDTR_LEN; pos++;\r\ndata->msgoutbuf[pos] = EXTENDED_SDTR; pos++;\r\ndata->msgoutbuf[pos] = period; pos++;\r\ndata->msgoutbuf[pos] = offset; pos++;\r\ndata->msgout_len = pos;\r\n}\r\nstatic void nsp32_build_nop(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nint pos = data->msgout_len;\r\nif (pos != 0) {\r\nnsp32_msg(KERN_WARNING,\r\n"Some messages are already contained!");\r\nreturn;\r\n}\r\ndata->msgoutbuf[pos] = NOP; pos++;\r\ndata->msgout_len = pos;\r\n}\r\nstatic void nsp32_build_reject(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nint pos = data->msgout_len;\r\ndata->msgoutbuf[pos] = MESSAGE_REJECT; pos++;\r\ndata->msgout_len = pos;\r\n}\r\nstatic int nsp32_selection_autopara(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned int host_id = SCpnt->device->host->this_id;\r\nunsigned char target = scmd_id(SCpnt);\r\nnsp32_autoparam *param = data->autoparam;\r\nunsigned char phase;\r\nint i, ret;\r\nunsigned int msgout;\r\nu16_le s;\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI, "in");\r\nphase = nsp32_read1(base, SCSI_BUS_MONITOR);\r\nif (phase != BUSMON_BUS_FREE) {\r\nnsp32_msg(KERN_WARNING, "bus busy");\r\nshow_busphase(phase & BUSMON_PHASE_MASK);\r\nSCpnt->result = DID_BUS_BUSY << 16;\r\nreturn FALSE;\r\n}\r\nif (data->msgout_len == 0) {\r\nnsp32_msg(KERN_ERR, "SCSI MsgOut without any message!");\r\nSCpnt->result = DID_ERROR << 16;\r\nreturn FALSE;\r\n} else if (data->msgout_len > 0 && data->msgout_len <= 3) {\r\nmsgout = 0;\r\nfor (i = 0; i < data->msgout_len; i++) {\r\nmsgout >>= 8;\r\nmsgout |= ((unsigned int)(data->msgoutbuf[i]) << 24);\r\n}\r\nmsgout |= MV_VALID;\r\nmsgout |= (unsigned int)data->msgout_len;\r\n} else {\r\nmsgout = 0;\r\n}\r\nmemset(param, 0, sizeof(nsp32_autoparam));\r\nfor (i = 0; i < SCpnt->cmd_len; i++) {\r\nparam->cdb[4 * i] = SCpnt->cmnd[i];\r\n}\r\nparam->msgout = cpu_to_le32(msgout);\r\nparam->syncreg = data->cur_target->syncreg;\r\nparam->ackwidth = data->cur_target->ackwidth;\r\nparam->target_id = BIT(host_id) | BIT(target);\r\nparam->sample_reg = data->cur_target->sample_reg;\r\nparam->command_control = cpu_to_le16(CLEAR_CDB_FIFO_POINTER |\r\nAUTOSCSI_START |\r\nAUTO_MSGIN_00_OR_04 |\r\nAUTO_MSGIN_02 |\r\nAUTO_ATN );\r\ns = 0;\r\nswitch (data->trans_method) {\r\ncase NSP32_TRANSFER_BUSMASTER:\r\ns |= BM_START;\r\nbreak;\r\ncase NSP32_TRANSFER_MMIO:\r\ns |= CB_MMIO_MODE;\r\nbreak;\r\ncase NSP32_TRANSFER_PIO:\r\ns |= CB_IO_MODE;\r\nbreak;\r\ndefault:\r\nnsp32_msg(KERN_ERR, "unknown trans_method");\r\nbreak;\r\n}\r\ns |= (TRANSFER_GO | ALL_COUNTER_CLR);\r\nparam->transfer_control = cpu_to_le16(s);\r\nparam->sgt_pointer = cpu_to_le32(data->cur_lunt->sglun_paddr);\r\nnsp32_write4(base, SGT_ADR, data->auto_paddr);\r\nnsp32_write2(base, COMMAND_CONTROL, CLEAR_CDB_FIFO_POINTER |\r\nAUTO_PARAMETER );\r\nret = nsp32_arbitration(SCpnt, base);\r\nreturn ret;\r\n}\r\nstatic int nsp32_selection_autoscsi(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned int host_id = SCpnt->device->host->this_id;\r\nunsigned char target = scmd_id(SCpnt);\r\nunsigned char phase;\r\nint status;\r\nunsigned short command = 0;\r\nunsigned int msgout = 0;\r\nunsigned short execph;\r\nint i;\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI, "in");\r\nnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\r\nphase = nsp32_read1(base, SCSI_BUS_MONITOR);\r\nif(((phase & BUSMON_BSY) == 1) || (phase & BUSMON_SEL) == 1) {\r\nnsp32_msg(KERN_WARNING, "bus busy");\r\nSCpnt->result = DID_BUS_BUSY << 16;\r\nstatus = 1;\r\ngoto out;\r\n}\r\nexecph = nsp32_read2(base, SCSI_EXECUTE_PHASE);\r\nnsp32_write2(base, COMMAND_CONTROL, CLEAR_CDB_FIFO_POINTER);\r\nfor (i = 0; i < SCpnt->cmd_len; i++) {\r\nnsp32_write1(base, COMMAND_DATA, SCpnt->cmnd[i]);\r\n}\r\nnsp32_dbg(NSP32_DEBUG_CDB_CONTENTS, "CDB[0]=[0x%x]", SCpnt->cmnd[0]);\r\nnsp32_write1(base, SCSI_OUT_LATCH_TARGET_ID, BIT(host_id) | BIT(target));\r\nif (data->msgout_len == 0) {\r\nnsp32_msg(KERN_ERR, "SCSI MsgOut without any message!");\r\nSCpnt->result = DID_ERROR << 16;\r\nstatus = 1;\r\ngoto out;\r\n} else if (data->msgout_len > 0 && data->msgout_len <= 3) {\r\nmsgout = 0;\r\nfor (i = 0; i < data->msgout_len; i++) {\r\nmsgout >>= 8;\r\nmsgout |= ((unsigned int)(data->msgoutbuf[i]) << 24);\r\n}\r\nmsgout |= MV_VALID;\r\nmsgout |= (unsigned int)data->msgout_len;\r\nnsp32_write4(base, SCSI_MSG_OUT, msgout);\r\n} else {\r\nnsp32_write4(base, SCSI_MSG_OUT, 0);\r\n}\r\nnsp32_write2(base, SEL_TIME_OUT, SEL_TIMEOUT_TIME);\r\nnsp32_write1(base, SREQ_SMPL_RATE, data->cur_target->sample_reg);\r\nnsp32_write1(base, SET_ARBIT, ARBIT_CLEAR);\r\nnsp32_write1(base, SYNC_REG, data->cur_target->syncreg);\r\nnsp32_write1(base, ACK_WIDTH, data->cur_target->ackwidth);\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI,\r\n"syncreg=0x%x, ackwidth=0x%x, sgtpaddr=0x%x, id=0x%x",\r\nnsp32_read1(base, SYNC_REG), nsp32_read1(base, ACK_WIDTH),\r\nnsp32_read4(base, SGT_ADR), nsp32_read1(base, SCSI_OUT_LATCH_TARGET_ID));\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI, "msgout_len=%d, msgout=0x%x",\r\ndata->msgout_len, msgout);\r\nnsp32_write4(base, SGT_ADR, data->cur_lunt->sglun_paddr);\r\ncommand = 0;\r\ncommand |= (TRANSFER_GO | ALL_COUNTER_CLR);\r\nif (data->trans_method & NSP32_TRANSFER_BUSMASTER) {\r\nif (scsi_bufflen(SCpnt) > 0) {\r\ncommand |= BM_START;\r\n}\r\n} else if (data->trans_method & NSP32_TRANSFER_MMIO) {\r\ncommand |= CB_MMIO_MODE;\r\n} else if (data->trans_method & NSP32_TRANSFER_PIO) {\r\ncommand |= CB_IO_MODE;\r\n}\r\nnsp32_write2(base, TRANSFER_CONTROL, command);\r\ncommand = (CLEAR_CDB_FIFO_POINTER |\r\nAUTOSCSI_START |\r\nAUTO_MSGIN_00_OR_04 |\r\nAUTO_MSGIN_02 |\r\nAUTO_ATN );\r\nnsp32_write2(base, COMMAND_CONTROL, command);\r\nstatus = nsp32_arbitration(SCpnt, base);\r\nout:\r\nnsp32_write2(base, IRQ_CONTROL, 0);\r\nreturn status;\r\n}\r\nstatic int nsp32_arbitration(struct scsi_cmnd *SCpnt, unsigned int base)\r\n{\r\nunsigned char arbit;\r\nint status = TRUE;\r\nint time = 0;\r\ndo {\r\narbit = nsp32_read1(base, ARBIT_STATUS);\r\ntime++;\r\n} while ((arbit & (ARBIT_WIN | ARBIT_FAIL)) == 0 &&\r\n(time <= ARBIT_TIMEOUT_TIME));\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI,\r\n"arbit: 0x%x, delay time: %d", arbit, time);\r\nif (arbit & ARBIT_WIN) {\r\nSCpnt->result = DID_OK << 16;\r\nnsp32_index_write1(base, EXT_PORT, LED_ON);\r\n} else if (arbit & ARBIT_FAIL) {\r\nSCpnt->result = DID_BUS_BUSY << 16;\r\nstatus = FALSE;\r\n} else {\r\nnsp32_dbg(NSP32_DEBUG_AUTOSCSI, "arbit timeout");\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nstatus = FALSE;\r\n}\r\nnsp32_write1(base, SET_ARBIT, ARBIT_CLEAR);\r\nreturn status;\r\n}\r\nstatic int nsp32_reselection(struct scsi_cmnd *SCpnt, unsigned char newlun)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int host_id = SCpnt->device->host->this_id;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned char tmpid, newid;\r\nnsp32_dbg(NSP32_DEBUG_RESELECTION, "enter");\r\ntmpid = nsp32_read1(base, RESELECT_ID);\r\ntmpid &= (~BIT(host_id));\r\nnewid = 0;\r\nwhile (tmpid) {\r\nif (tmpid & 1) {\r\nbreak;\r\n}\r\ntmpid >>= 1;\r\nnewid++;\r\n}\r\nif (newid >= ARRAY_SIZE(data->lunt) || newlun >= ARRAY_SIZE(data->lunt[0])) {\r\nnsp32_msg(KERN_WARNING, "unknown id/lun");\r\nreturn FALSE;\r\n} else if(data->lunt[newid][newlun].SCpnt == NULL) {\r\nnsp32_msg(KERN_WARNING, "no SCSI command is processing");\r\nreturn FALSE;\r\n}\r\ndata->cur_id = newid;\r\ndata->cur_lun = newlun;\r\ndata->cur_target = &(data->target[newid]);\r\ndata->cur_lunt = &(data->lunt[newid][newlun]);\r\nnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\r\nreturn TRUE;\r\n}\r\nstatic int nsp32_setup_sg_table(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nstruct scatterlist *sg;\r\nnsp32_sgtable *sgt = data->cur_lunt->sglun->sgt;\r\nint num, i;\r\nu32_le l;\r\nif (sgt == NULL) {\r\nnsp32_dbg(NSP32_DEBUG_SGLIST, "SGT == null");\r\nreturn FALSE;\r\n}\r\nnum = scsi_dma_map(SCpnt);\r\nif (!num)\r\nreturn TRUE;\r\nelse if (num < 0)\r\nreturn FALSE;\r\nelse {\r\nscsi_for_each_sg(SCpnt, sg, num, i) {\r\nsgt[i].addr = cpu_to_le32(sg_dma_address(sg));\r\nsgt[i].len = cpu_to_le32(sg_dma_len(sg));\r\nif (le32_to_cpu(sgt[i].len) > 0x10000) {\r\nnsp32_msg(KERN_ERR,\r\n"can't transfer over 64KB at a time, size=0x%lx", le32_to_cpu(sgt[i].len));\r\nreturn FALSE;\r\n}\r\nnsp32_dbg(NSP32_DEBUG_SGLIST,\r\n"num 0x%x : addr 0x%lx len 0x%lx",\r\ni,\r\nle32_to_cpu(sgt[i].addr),\r\nle32_to_cpu(sgt[i].len ));\r\n}\r\nl = le32_to_cpu(sgt[num-1].len);\r\nsgt[num-1].len = cpu_to_le32(l | SGTEND);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int nsp32_queuecommand_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nnsp32_target *target;\r\nnsp32_lunt *cur_lunt;\r\nint ret;\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\r\n"enter. target: 0x%x LUN: 0x%llx cmnd: 0x%x cmndlen: 0x%x "\r\n"use_sg: 0x%x reqbuf: 0x%lx reqlen: 0x%x",\r\nSCpnt->device->id, SCpnt->device->lun, SCpnt->cmnd[0], SCpnt->cmd_len,\r\nscsi_sg_count(SCpnt), scsi_sglist(SCpnt), scsi_bufflen(SCpnt));\r\nif (data->CurrentSC != NULL) {\r\nnsp32_msg(KERN_ERR, "Currentsc != NULL. Cancel this command request");\r\ndata->CurrentSC = NULL;\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\nif (scmd_id(SCpnt) == SCpnt->device->host->this_id) {\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, "target==host???");\r\nSCpnt->result = DID_BAD_TARGET << 16;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\nif (SCpnt->device->lun >= MAX_LUN) {\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, "no more lun");\r\nSCpnt->result = DID_BAD_TARGET << 16;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\nshow_command(SCpnt);\r\nSCpnt->scsi_done = done;\r\ndata->CurrentSC = SCpnt;\r\nSCpnt->SCp.Status = CHECK_CONDITION;\r\nSCpnt->SCp.Message = 0;\r\nscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\r\nSCpnt->SCp.ptr = (char *)scsi_sglist(SCpnt);\r\nSCpnt->SCp.this_residual = scsi_bufflen(SCpnt);\r\nSCpnt->SCp.buffer = NULL;\r\nSCpnt->SCp.buffers_residual = 0;\r\ndata->msgout_len = 0;\r\ndata->msgin_len = 0;\r\ncur_lunt = &(data->lunt[SCpnt->device->id][SCpnt->device->lun]);\r\ncur_lunt->SCpnt = SCpnt;\r\ncur_lunt->save_datp = 0;\r\ncur_lunt->msgin03 = FALSE;\r\ndata->cur_lunt = cur_lunt;\r\ndata->cur_id = SCpnt->device->id;\r\ndata->cur_lun = SCpnt->device->lun;\r\nret = nsp32_setup_sg_table(SCpnt);\r\nif (ret == FALSE) {\r\nnsp32_msg(KERN_ERR, "SGT fail");\r\nSCpnt->result = DID_ERROR << 16;\r\nnsp32_scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nnsp32_build_identify(SCpnt);\r\ntarget = &data->target[scmd_id(SCpnt)];\r\ndata->cur_target = target;\r\nif (!(target->sync_flag & (SDTR_DONE | SDTR_INITIATOR | SDTR_TARGET))) {\r\nunsigned char period, offset;\r\nif (trans_mode != ASYNC_MODE) {\r\nnsp32_set_max_sync(data, target, &period, &offset);\r\nnsp32_build_sdtr(SCpnt, period, offset);\r\ntarget->sync_flag |= SDTR_INITIATOR;\r\n} else {\r\nnsp32_set_async(data, target);\r\ntarget->sync_flag |= SDTR_DONE;\r\n}\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\r\n"SDTR: entry: %d start_period: 0x%x offset: 0x%x\n",\r\ntarget->limit_entry, period, offset);\r\n} else if (target->sync_flag & SDTR_INITIATOR) {\r\nnsp32_set_async(data, target);\r\ntarget->sync_flag &= ~SDTR_INITIATOR;\r\ntarget->sync_flag |= SDTR_DONE;\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\r\n"SDTR_INITIATOR: fall back to async");\r\n} else if (target->sync_flag & SDTR_TARGET) {\r\nnsp32_set_async(data, target);\r\ntarget->sync_flag &= ~SDTR_TARGET;\r\ntarget->sync_flag |= SDTR_DONE;\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND,\r\n"Unknown SDTR from target is reached, fall back to async.");\r\n}\r\nnsp32_dbg(NSP32_DEBUG_TARGETFLAG,\r\n"target: %d sync_flag: 0x%x syncreg: 0x%x ackwidth: 0x%x",\r\nSCpnt->device->id, target->sync_flag, target->syncreg,\r\ntarget->ackwidth);\r\nif (auto_param == 0) {\r\nret = nsp32_selection_autopara(SCpnt);\r\n} else {\r\nret = nsp32_selection_autoscsi(SCpnt);\r\n}\r\nif (ret != TRUE) {\r\nnsp32_dbg(NSP32_DEBUG_QUEUECOMMAND, "selection fail");\r\nnsp32_scsi_done(SCpnt);\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t do_nsp32_isr(int irq, void *dev_id)\r\n{\r\nnsp32_hw_data *data = dev_id;\r\nunsigned int base = data->BaseAddress;\r\nstruct scsi_cmnd *SCpnt = data->CurrentSC;\r\nunsigned short auto_stat, irq_stat, trans_stat;\r\nunsigned char busmon, busphase;\r\nunsigned long flags;\r\nint ret;\r\nint handled = 0;\r\nstruct Scsi_Host *host = data->Host;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nirq_stat = nsp32_read2(base, IRQ_STATUS);\r\nnsp32_dbg(NSP32_DEBUG_INTR,\r\n"enter IRQ: %d, IRQstatus: 0x%x", irq, irq_stat);\r\nif ((irq_stat & IRQSTATUS_ANY_IRQ) == 0) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "shared interrupt: irq other 0x%x", irq_stat);\r\ngoto out2;\r\n}\r\nhandled = 1;\r\nnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\r\nbusmon = nsp32_read1(base, SCSI_BUS_MONITOR);\r\nbusphase = busmon & BUSMON_PHASE_MASK;\r\ntrans_stat = nsp32_read2(base, TRANSFER_STATUS);\r\nif ((irq_stat == 0xffff) && (trans_stat == 0xffff)) {\r\nnsp32_msg(KERN_INFO, "card disconnect");\r\nif (data->CurrentSC != NULL) {\r\nnsp32_msg(KERN_INFO, "clean up current SCSI command");\r\nSCpnt->result = DID_BAD_TARGET << 16;\r\nnsp32_scsi_done(SCpnt);\r\n}\r\ngoto out;\r\n}\r\nif (irq_stat & IRQSTATUS_TIMER_IRQ) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "timer stop");\r\nnsp32_write2(base, TIMER_SET, TIMER_STOP);\r\ngoto out;\r\n}\r\nif (irq_stat & IRQSTATUS_SCSIRESET_IRQ) {\r\nnsp32_msg(KERN_INFO, "detected someone do bus reset");\r\nnsp32_do_bus_reset(data);\r\nif (SCpnt != NULL) {\r\nSCpnt->result = DID_RESET << 16;\r\nnsp32_scsi_done(SCpnt);\r\n}\r\ngoto out;\r\n}\r\nif (SCpnt == NULL) {\r\nnsp32_msg(KERN_WARNING, "SCpnt==NULL this can't be happened");\r\nnsp32_msg(KERN_WARNING, "irq_stat=0x%x trans_stat=0x%x", irq_stat, trans_stat);\r\ngoto out;\r\n}\r\nif(irq_stat & IRQSTATUS_AUTOSCSI_IRQ) {\r\nauto_stat = nsp32_read2(base, SCSI_EXECUTE_PHASE);\r\nnsp32_write2(base, SCSI_EXECUTE_PHASE, 0);\r\nif (auto_stat & SELECTION_TIMEOUT) {\r\nnsp32_dbg(NSP32_DEBUG_INTR,\r\n"selection timeout occurred");\r\nSCpnt->result = DID_TIME_OUT << 16;\r\nnsp32_scsi_done(SCpnt);\r\ngoto out;\r\n}\r\nif (auto_stat & MSGOUT_PHASE) {\r\nif (!(auto_stat & MSG_IN_OCCUER) &&\r\n(data->msgout_len <= 3)) {\r\ndata->msgout_len = 0;\r\n};\r\nnsp32_dbg(NSP32_DEBUG_INTR, "MsgOut phase processed");\r\n}\r\nif ((auto_stat & DATA_IN_PHASE) &&\r\n(scsi_get_resid(SCpnt) > 0) &&\r\n((nsp32_read2(base, FIFO_REST_CNT) & FIFO_REST_MASK) != 0)) {\r\nprintk( "auto+fifo\n");\r\n}\r\nif (auto_stat & (DATA_IN_PHASE | DATA_OUT_PHASE)) {\r\nnsp32_dbg(NSP32_DEBUG_INTR,\r\n"Data in/out phase processed");\r\nnsp32_dbg(NSP32_DEBUG_INTR, "BMCNT=0x%lx",\r\nnsp32_read4(base, BM_CNT));\r\nnsp32_dbg(NSP32_DEBUG_INTR, "addr=0x%lx",\r\nnsp32_read4(base, SGT_ADR));\r\nnsp32_dbg(NSP32_DEBUG_INTR, "SACK=0x%lx",\r\nnsp32_read4(base, SACK_CNT));\r\nnsp32_dbg(NSP32_DEBUG_INTR, "SSACK=0x%lx",\r\nnsp32_read4(base, SAVED_SACK_CNT));\r\nscsi_set_resid(SCpnt, 0);\r\n}\r\nif (auto_stat & MSG_IN_OCCUER) {\r\nnsp32_msgin_occur(SCpnt, irq_stat, auto_stat);\r\n}\r\nif (auto_stat & MSG_OUT_OCCUER) {\r\nnsp32_msgout_occur(SCpnt);\r\n}\r\nif (auto_stat & BUS_FREE_OCCUER) {\r\nret = nsp32_busfree_occur(SCpnt, auto_stat);\r\nif (ret == TRUE) {\r\ngoto out;\r\n}\r\n}\r\nif (auto_stat & STATUS_PHASE) {\r\nSCpnt->result = (int)nsp32_read1(base, SCSI_CSB_IN);\r\n}\r\nif (auto_stat & ILLEGAL_PHASE) {\r\nnsp32_msg(KERN_WARNING,\r\n"AUTO SCSI ILLEGAL PHASE OCCUR!!!!");\r\nnsp32_sack_assert(data);\r\nnsp32_wait_req(data, NEGATE);\r\nnsp32_sack_negate(data);\r\n}\r\nif (auto_stat & COMMAND_PHASE) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "Command phase processed");\r\n}\r\nif (auto_stat & AUTOSCSI_BUSY) {\r\n}\r\nshow_autophase(auto_stat);\r\n}\r\nif (irq_stat & IRQSTATUS_FIFO_SHLD_IRQ) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "FIFO IRQ");\r\nswitch(busphase) {\r\ncase BUSPHASE_DATA_OUT:\r\nnsp32_dbg(NSP32_DEBUG_INTR, "fifo/write");\r\nbreak;\r\ncase BUSPHASE_DATA_IN:\r\nnsp32_dbg(NSP32_DEBUG_INTR, "fifo/read");\r\nbreak;\r\ncase BUSPHASE_STATUS:\r\nnsp32_dbg(NSP32_DEBUG_INTR, "fifo/status");\r\nSCpnt->SCp.Status = nsp32_read1(base, SCSI_CSB_IN);\r\nbreak;\r\ndefault:\r\nnsp32_dbg(NSP32_DEBUG_INTR, "fifo/other phase");\r\nnsp32_dbg(NSP32_DEBUG_INTR, "irq_stat=0x%x trans_stat=0x%x", irq_stat, trans_stat);\r\nshow_busphase(busphase);\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nif (irq_stat & IRQSTATUS_PHASE_CHANGE_IRQ) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "phase change IRQ");\r\nswitch(busphase) {\r\ncase BUSPHASE_MESSAGE_IN:\r\nnsp32_dbg(NSP32_DEBUG_INTR, "phase chg/msg in");\r\nnsp32_msgin_occur(SCpnt, irq_stat, 0);\r\nbreak;\r\ndefault:\r\nnsp32_msg(KERN_WARNING, "phase chg/other phase?");\r\nnsp32_msg(KERN_WARNING, "irq_stat=0x%x trans_stat=0x%x\n",\r\nirq_stat, trans_stat);\r\nshow_busphase(busphase);\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nif (irq_stat & IRQSTATUS_PCI_IRQ) {\r\nnsp32_dbg(NSP32_DEBUG_INTR, "PCI IRQ occurred");\r\n}\r\nif (irq_stat & IRQSTATUS_BMCNTERR_IRQ) {\r\nnsp32_msg(KERN_ERR, "Received unexpected BMCNTERR IRQ! ");\r\n}\r\n#if 0\r\nnsp32_dbg(NSP32_DEBUG_INTR,\r\n"irq_stat=0x%x trans_stat=0x%x", irq_stat, trans_stat);\r\nshow_busphase(busphase);\r\n#endif\r\nout:\r\nnsp32_write2(base, IRQ_CONTROL, 0);\r\nout2:\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nnsp32_dbg(NSP32_DEBUG_INTR, "exit");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int nsp32_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nunsigned long flags;\r\nnsp32_hw_data *data;\r\nint hostno;\r\nunsigned int base;\r\nunsigned char mode_reg;\r\nint id, speed;\r\nlong model;\r\nhostno = host->host_no;\r\ndata = (nsp32_hw_data *)host->hostdata;\r\nbase = host->io_port;\r\nSPRINTF("NinjaSCSI-32 status\n\n");\r\nSPRINTF("Driver version: %s, $Revision: 1.33 $\n", nsp32_release_version);\r\nSPRINTF("SCSI host No.: %d\n", hostno);\r\nSPRINTF("IRQ: %d\n", host->irq);\r\nSPRINTF("IO: 0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);\r\nSPRINTF("MMIO(virtual address): 0x%lx-0x%lx\n", host->base, host->base + data->MmioLength - 1);\r\nSPRINTF("sg_tablesize: %d\n", host->sg_tablesize);\r\nSPRINTF("Chip revision: 0x%x\n", (nsp32_read2(base, INDEX_REG) >> 8) & 0xff);\r\nmode_reg = nsp32_index_read1(base, CHIP_MODE);\r\nmodel = data->pci_devid->driver_data;\r\n#ifdef CONFIG_PM\r\nSPRINTF("Power Management: %s\n", (mode_reg & OPTF) ? "yes" : "no");\r\n#endif\r\nSPRINTF("OEM: %ld, %s\n", (mode_reg & (OEM0|OEM1)), nsp32_model[model]);\r\nspin_lock_irqsave(&(data->Lock), flags);\r\nSPRINTF("CurrentSC: 0x%p\n\n", data->CurrentSC);\r\nspin_unlock_irqrestore(&(data->Lock), flags);\r\nSPRINTF("SDTR status\n");\r\nfor (id = 0; id < ARRAY_SIZE(data->target); id++) {\r\nSPRINTF("id %d: ", id);\r\nif (id == host->this_id) {\r\nSPRINTF("----- NinjaSCSI-32 host adapter\n");\r\ncontinue;\r\n}\r\nif (data->target[id].sync_flag == SDTR_DONE) {\r\nif (data->target[id].period == 0 &&\r\ndata->target[id].offset == ASYNC_OFFSET ) {\r\nSPRINTF("async");\r\n} else {\r\nSPRINTF(" sync");\r\n}\r\n} else {\r\nSPRINTF(" none");\r\n}\r\nif (data->target[id].period != 0) {\r\nspeed = 1000000 / (data->target[id].period * 4);\r\nSPRINTF(" transfer %d.%dMB/s, offset %d",\r\nspeed / 1000,\r\nspeed % 1000,\r\ndata->target[id].offset\r\n);\r\n}\r\nSPRINTF("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void nsp32_scsi_done(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nscsi_dma_unmap(SCpnt);\r\nnsp32_write2(base, TRANSFER_CONTROL, 0);\r\nnsp32_write4(base, BM_CNT, 0);\r\n(*SCpnt->scsi_done)(SCpnt);\r\ndata->cur_lunt->SCpnt = NULL;\r\ndata->cur_lunt = NULL;\r\ndata->cur_target = NULL;\r\ndata->CurrentSC = NULL;\r\n}\r\nstatic int nsp32_busfree_occur(struct scsi_cmnd *SCpnt, unsigned short execph)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nnsp32_dbg(NSP32_DEBUG_BUSFREE, "enter execph=0x%x", execph);\r\nshow_autophase(execph);\r\nnsp32_write4(base, BM_CNT, 0);\r\nnsp32_write2(base, TRANSFER_CONTROL, 0);\r\nif (execph & MSGIN_02_VALID) {\r\nnsp32_dbg(NSP32_DEBUG_BUSFREE, "MsgIn02_Valid");\r\nif (!(execph & MSGIN_00_VALID) &&\r\n((execph & DATA_IN_PHASE) || (execph & DATA_OUT_PHASE))) {\r\nunsigned int sacklen, s_sacklen;\r\nsacklen = nsp32_read4(base, SACK_CNT );\r\ns_sacklen = nsp32_read4(base, SAVED_SACK_CNT);\r\nif (s_sacklen > 0) {\r\nif (sacklen != s_sacklen) {\r\ndata->cur_lunt->msgin03 = FALSE;\r\n} else {\r\ndata->cur_lunt->msgin03 = TRUE;\r\n}\r\nnsp32_adjust_busfree(SCpnt, s_sacklen);\r\n}\r\n}\r\n} else {\r\n}\r\nif (execph & MSGIN_03_VALID) {\r\n}\r\nif (data->cur_target->sync_flag & SDTR_INITIATOR) {\r\nnsp32_set_async(data, data->cur_target);\r\ndata->cur_target->sync_flag &= ~SDTR_INITIATOR;\r\ndata->cur_target->sync_flag |= SDTR_DONE;\r\n} else if (data->cur_target->sync_flag & SDTR_TARGET) {\r\nif (execph & (MSGIN_00_VALID | MSGIN_04_VALID)) {\r\n} else {\r\nnsp32_set_async(data, data->cur_target);\r\n}\r\ndata->cur_target->sync_flag &= ~SDTR_TARGET;\r\ndata->cur_target->sync_flag |= SDTR_DONE;\r\n}\r\nif (execph & MSGIN_00_VALID) {\r\nnsp32_dbg(NSP32_DEBUG_BUSFREE, "command complete");\r\nSCpnt->SCp.Status = nsp32_read1(base, SCSI_CSB_IN);\r\nSCpnt->SCp.Message = 0;\r\nnsp32_dbg(NSP32_DEBUG_BUSFREE,\r\n"normal end stat=0x%x resid=0x%x\n",\r\nSCpnt->SCp.Status, scsi_get_resid(SCpnt));\r\nSCpnt->result = (DID_OK << 16) |\r\n(SCpnt->SCp.Message << 8) |\r\n(SCpnt->SCp.Status << 0);\r\nnsp32_scsi_done(SCpnt);\r\nreturn TRUE;\r\n} else if (execph & MSGIN_04_VALID) {\r\nSCpnt->SCp.Status = nsp32_read1(base, SCSI_CSB_IN);\r\nSCpnt->SCp.Message = 4;\r\nnsp32_dbg(NSP32_DEBUG_BUSFREE, "disconnect");\r\nreturn TRUE;\r\n} else {\r\nnsp32_msg(KERN_WARNING, "unexpected bus free occurred");\r\nSCpnt->result = DID_ERROR << 16;\r\nnsp32_scsi_done(SCpnt);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void nsp32_adjust_busfree(struct scsi_cmnd *SCpnt, unsigned int s_sacklen)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nint old_entry = data->cur_entry;\r\nint new_entry;\r\nint sg_num = data->cur_lunt->sg_num;\r\nnsp32_sgtable *sgt = data->cur_lunt->sglun->sgt;\r\nunsigned int restlen, sentlen;\r\nu32_le len, addr;\r\nnsp32_dbg(NSP32_DEBUG_SGLIST, "old resid=0x%x", scsi_get_resid(SCpnt));\r\ns_sacklen -= le32_to_cpu(sgt[old_entry].addr) & 3;\r\nsentlen = 0;\r\nfor (new_entry = old_entry; new_entry < sg_num; new_entry++) {\r\nsentlen += (le32_to_cpu(sgt[new_entry].len) & ~SGTEND);\r\nif (sentlen > s_sacklen) {\r\nbreak;\r\n}\r\n}\r\nif (new_entry == sg_num) {\r\ngoto last;\r\n}\r\nif (sentlen == s_sacklen) {\r\n}\r\nrestlen = sentlen - s_sacklen;\r\nlen = le32_to_cpu(sgt[new_entry].len);\r\naddr = le32_to_cpu(sgt[new_entry].addr);\r\naddr += (len - restlen);\r\nsgt[new_entry].addr = cpu_to_le32(addr);\r\nsgt[new_entry].len = cpu_to_le32(restlen);\r\ndata->cur_entry = new_entry;\r\nreturn;\r\nlast:\r\nif (scsi_get_resid(SCpnt) < sentlen) {\r\nnsp32_msg(KERN_ERR, "resid underflow");\r\n}\r\nscsi_set_resid(SCpnt, scsi_get_resid(SCpnt) - sentlen);\r\nnsp32_dbg(NSP32_DEBUG_SGLIST, "new resid=0x%x", scsi_get_resid(SCpnt));\r\nreturn;\r\n}\r\nstatic void nsp32_msgout_occur(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nlong new_sgtp;\r\nint i;\r\nnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR,\r\n"enter: msgout_len: 0x%x", data->msgout_len);\r\nif (data->msgout_len == 0) {\r\nnsp32_build_nop(SCpnt);\r\n}\r\nnew_sgtp = data->cur_lunt->sglun_paddr +\r\n(data->cur_lunt->cur_entry * sizeof(nsp32_sgtable));\r\nfor (i = 0; i < data->msgout_len; i++) {\r\nnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR,\r\n"%d : 0x%x", i, data->msgoutbuf[i]);\r\nnsp32_wait_req(data, ASSERT);\r\nif (i == (data->msgout_len - 1)) {\r\nnsp32_write2(base, COMMAND_CONTROL,\r\n(CLEAR_CDB_FIFO_POINTER |\r\nAUTO_COMMAND_PHASE |\r\nAUTOSCSI_RESTART |\r\nAUTO_MSGIN_00_OR_04 |\r\nAUTO_MSGIN_02 ));\r\n}\r\nnsp32_write1(base, SCSI_DATA_WITH_ACK, data->msgoutbuf[i]);\r\nnsp32_wait_sack(data, NEGATE);\r\nnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR, "bus: 0x%x\n",\r\nnsp32_read1(base, SCSI_BUS_MONITOR));\r\n};\r\ndata->msgout_len = 0;\r\nnsp32_dbg(NSP32_DEBUG_MSGOUTOCCUR, "exit");\r\n}\r\nstatic void nsp32_restart_autoscsi(struct scsi_cmnd *SCpnt, unsigned short command)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = data->BaseAddress;\r\nunsigned short transfer = 0;\r\nnsp32_dbg(NSP32_DEBUG_RESTART, "enter");\r\nif (data->cur_target == NULL || data->cur_lunt == NULL) {\r\nnsp32_msg(KERN_ERR, "Target or Lun is invalid");\r\n}\r\nnsp32_write1(base, SYNC_REG, data->cur_target->syncreg);\r\nnsp32_write1(base, ACK_WIDTH, data->cur_target->ackwidth);\r\nnsp32_write1(base, SREQ_SMPL_RATE, data->cur_target->sample_reg);\r\nnsp32_write4(base, SGT_ADR, data->cur_lunt->sglun_paddr);\r\ntransfer = 0;\r\ntransfer |= (TRANSFER_GO | ALL_COUNTER_CLR);\r\nif (data->trans_method & NSP32_TRANSFER_BUSMASTER) {\r\nif (scsi_bufflen(SCpnt) > 0) {\r\ntransfer |= BM_START;\r\n}\r\n} else if (data->trans_method & NSP32_TRANSFER_MMIO) {\r\ntransfer |= CB_MMIO_MODE;\r\n} else if (data->trans_method & NSP32_TRANSFER_PIO) {\r\ntransfer |= CB_IO_MODE;\r\n}\r\nnsp32_write2(base, TRANSFER_CONTROL, transfer);\r\ncommand |= (CLEAR_CDB_FIFO_POINTER |\r\nAUTO_COMMAND_PHASE |\r\nAUTOSCSI_RESTART );\r\nnsp32_write2(base, COMMAND_CONTROL, command);\r\nnsp32_dbg(NSP32_DEBUG_RESTART, "exit");\r\n}\r\nstatic void nsp32_msgin_occur(struct scsi_cmnd *SCpnt,\r\nunsigned long irq_status,\r\nunsigned short execph)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned char msg;\r\nunsigned char msgtype;\r\nunsigned char newlun;\r\nunsigned short command = 0;\r\nint msgclear = TRUE;\r\nlong new_sgtp;\r\nint ret;\r\nmsg = nsp32_read1(base, SCSI_DATA_IN);\r\ndata->msginbuf[(unsigned char)data->msgin_len] = msg;\r\nmsgtype = data->msginbuf[0];\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR,\r\n"enter: msglen: 0x%x msgin: 0x%x msgtype: 0x%x",\r\ndata->msgin_len, msg, msgtype);\r\nnsp32_sack_assert(data);\r\nif (msgtype & 0x80) {\r\nif (!(irq_status & IRQSTATUS_RESELECT_OCCUER)) {\r\ngoto reject;\r\n}\r\nnewlun = msgtype & 0x1f;\r\nret = nsp32_reselection(SCpnt, newlun);\r\nif (ret == TRUE) {\r\ngoto restart;\r\n} else {\r\ngoto reject;\r\n}\r\n}\r\nswitch (msgtype) {\r\ncase COMMAND_COMPLETE:\r\ncase DISCONNECT:\r\nnsp32_msg(KERN_WARNING,\r\n"unexpected message of AutoSCSI MsgIn: 0x%x", msg);\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nif ((execph & DATA_IN_PHASE) || (execph & DATA_OUT_PHASE)) {\r\nunsigned int s_sacklen;\r\ns_sacklen = nsp32_read4(base, SAVED_SACK_CNT);\r\nif ((execph & MSGIN_02_VALID) && (s_sacklen > 0)) {\r\nnsp32_adjust_busfree(SCpnt, s_sacklen);\r\n} else {\r\n}\r\n}\r\ndata->cur_lunt->msgin03 = FALSE;\r\nnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\r\nnew_sgtp = data->cur_lunt->sglun_paddr +\r\n(data->cur_lunt->cur_entry * sizeof(nsp32_sgtable));\r\nnsp32_write4(base, SGT_ADR, new_sgtp);\r\nbreak;\r\ncase SAVE_POINTERS:\r\nnsp32_msg (KERN_WARNING,\r\n"unexpected message of AutoSCSI MsgIn: SAVE_POINTERS");\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nif (data->cur_target->sync_flag &\r\n(SDTR_INITIATOR | SDTR_TARGET)) {\r\nnsp32_set_async(data, data->cur_target);\r\ndata->cur_target->sync_flag &= ~SDTR_INITIATOR;\r\ndata->cur_target->sync_flag |= SDTR_DONE;\r\n}\r\nbreak;\r\ncase LINKED_CMD_COMPLETE:\r\ncase LINKED_FLG_CMD_COMPLETE:\r\nnsp32_msg (KERN_WARNING,\r\n"unsupported message: 0x%x", msgtype);\r\nbreak;\r\ncase INITIATE_RECOVERY:\r\ngoto reject;\r\ncase SIMPLE_QUEUE_TAG:\r\ncase 0x23:\r\nif (data->msgin_len >= 1) {\r\ngoto reject;\r\n}\r\nmsgclear = FALSE;\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif (data->msgin_len < 1) {\r\nmsgclear = FALSE;\r\nbreak;\r\n}\r\nif ((data->msginbuf[1] + 1) > data->msgin_len) {\r\nmsgclear = FALSE;\r\nbreak;\r\n}\r\nswitch (data->msginbuf[2]) {\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\ngoto reject;\r\nbreak;\r\ncase EXTENDED_SDTR:\r\nif (data->msgin_len != EXTENDED_SDTR_LEN + 1) {\r\ngoto reject;\r\nbreak;\r\n}\r\nnsp32_analyze_sdtr(SCpnt);\r\nbreak;\r\ncase EXTENDED_EXTENDED_IDENTIFY:\r\ngoto reject;\r\nbreak;\r\ncase EXTENDED_WDTR:\r\ngoto reject;\r\nbreak;\r\ndefault:\r\ngoto reject;\r\n}\r\nbreak;\r\ndefault:\r\ngoto reject;\r\n}\r\nrestart:\r\nif (msgclear == TRUE) {\r\ndata->msgin_len = 0;\r\nif (data->msgout_len > 0) {\r\nnsp32_write4(base, SCSI_MSG_OUT, 0);\r\ncommand |= AUTO_ATN;\r\n}\r\ncommand |= (AUTO_MSGIN_00_OR_04 | AUTO_MSGIN_02);\r\nif (data->cur_lunt->msgin03 == TRUE) {\r\ncommand |= AUTO_MSGIN_03;\r\n}\r\ndata->cur_lunt->msgin03 = FALSE;\r\n} else {\r\ndata->msgin_len++;\r\n}\r\nnsp32_restart_autoscsi(SCpnt, command);\r\nnsp32_wait_req(data, NEGATE);\r\nnsp32_sack_negate(data);\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "exit");\r\nreturn;\r\nreject:\r\nnsp32_msg(KERN_WARNING,\r\n"invalid or unsupported MessageIn, rejected. "\r\n"current msg: 0x%x (len: 0x%x), processing msg: 0x%x",\r\nmsg, data->msgin_len, msgtype);\r\nnsp32_build_reject(SCpnt);\r\ndata->msgin_len = 0;\r\ngoto restart;\r\n}\r\nstatic void nsp32_analyze_sdtr(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nnsp32_target *target = data->cur_target;\r\nnsp32_sync_table *synct;\r\nunsigned char get_period = data->msginbuf[3];\r\nunsigned char get_offset = data->msginbuf[4];\r\nint entry;\r\nint syncnum;\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "enter");\r\nsynct = data->synct;\r\nsyncnum = data->syncnum;\r\nif (target->sync_flag & SDTR_INITIATOR) {\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "target responds SDTR");\r\ntarget->sync_flag &= ~SDTR_INITIATOR;\r\ntarget->sync_flag |= SDTR_DONE;\r\nif (get_offset > SYNC_OFFSET) {\r\ngoto reject;\r\n}\r\nif (get_offset == ASYNC_OFFSET) {\r\ngoto async;\r\n}\r\nif (get_period < data->synct[0].period_num) {\r\ngoto reject;\r\n}\r\nentry = nsp32_search_period_entry(data, target, get_period);\r\nif (entry < 0) {\r\ngoto reject;\r\n}\r\nnsp32_set_sync_entry(data, target, entry, get_offset);\r\n} else {\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "target send SDTR");\r\ntarget->sync_flag |= SDTR_INITIATOR;\r\nif (get_offset > SYNC_OFFSET) {\r\nget_offset = SYNC_OFFSET;\r\n}\r\nif (get_period < data->synct[0].period_num) {\r\nget_period = data->synct[0].period_num;\r\n}\r\nentry = nsp32_search_period_entry(data, target, get_period);\r\nif (get_offset == ASYNC_OFFSET || entry < 0) {\r\nnsp32_set_async(data, target);\r\nnsp32_build_sdtr(SCpnt, 0, ASYNC_OFFSET);\r\n} else {\r\nnsp32_set_sync_entry(data, target, entry, get_offset);\r\nnsp32_build_sdtr(SCpnt, get_period, get_offset);\r\n}\r\n}\r\ntarget->period = get_period;\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "exit");\r\nreturn;\r\nreject:\r\nnsp32_build_reject(SCpnt);\r\nasync:\r\nnsp32_set_async(data, target);\r\ntarget->period = 0;\r\nnsp32_dbg(NSP32_DEBUG_MSGINOCCUR, "exit: set async");\r\nreturn;\r\n}\r\nstatic int nsp32_search_period_entry(nsp32_hw_data *data,\r\nnsp32_target *target,\r\nunsigned char period)\r\n{\r\nint i;\r\nif (target->limit_entry >= data->syncnum) {\r\nnsp32_msg(KERN_ERR, "limit_entry exceeds syncnum!");\r\ntarget->limit_entry = 0;\r\n}\r\nfor (i = target->limit_entry; i < data->syncnum; i++) {\r\nif (period >= data->synct[i].start_period &&\r\nperiod <= data->synct[i].end_period) {\r\nbreak;\r\n}\r\n}\r\nif (i == data->syncnum) {\r\ni = -1;\r\n}\r\nreturn i;\r\n}\r\nstatic void nsp32_set_async(nsp32_hw_data *data, nsp32_target *target)\r\n{\r\nunsigned char period = data->synct[target->limit_entry].period_num;\r\ntarget->offset = ASYNC_OFFSET;\r\ntarget->period = 0;\r\ntarget->syncreg = TO_SYNCREG(period, ASYNC_OFFSET);\r\ntarget->ackwidth = 0;\r\ntarget->sample_reg = 0;\r\nnsp32_dbg(NSP32_DEBUG_SYNC, "set async");\r\n}\r\nstatic void nsp32_set_max_sync(nsp32_hw_data *data,\r\nnsp32_target *target,\r\nunsigned char *period,\r\nunsigned char *offset)\r\n{\r\nunsigned char period_num, ackwidth;\r\nperiod_num = data->synct[target->limit_entry].period_num;\r\n*period = data->synct[target->limit_entry].start_period;\r\nackwidth = data->synct[target->limit_entry].ackwidth;\r\n*offset = SYNC_OFFSET;\r\ntarget->syncreg = TO_SYNCREG(period_num, *offset);\r\ntarget->ackwidth = ackwidth;\r\ntarget->offset = *offset;\r\ntarget->sample_reg = 0;\r\n}\r\nstatic void nsp32_set_sync_entry(nsp32_hw_data *data,\r\nnsp32_target *target,\r\nint entry,\r\nunsigned char offset)\r\n{\r\nunsigned char period, ackwidth, sample_rate;\r\nperiod = data->synct[entry].period_num;\r\nackwidth = data->synct[entry].ackwidth;\r\noffset = offset;\r\nsample_rate = data->synct[entry].sample_rate;\r\ntarget->syncreg = TO_SYNCREG(period, offset);\r\ntarget->ackwidth = ackwidth;\r\ntarget->offset = offset;\r\ntarget->sample_reg = sample_rate | SAMPLING_ENABLE;\r\nnsp32_dbg(NSP32_DEBUG_SYNC, "set sync");\r\n}\r\nstatic void nsp32_wait_req(nsp32_hw_data *data, int state)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nint wait_time = 0;\r\nunsigned char bus, req_bit;\r\nif (!((state == ASSERT) || (state == NEGATE))) {\r\nnsp32_msg(KERN_ERR, "unknown state designation");\r\n}\r\nreq_bit = (state == ASSERT ? BUSMON_REQ : 0);\r\ndo {\r\nbus = nsp32_read1(base, SCSI_BUS_MONITOR);\r\nif ((bus & BUSMON_REQ) == req_bit) {\r\nnsp32_dbg(NSP32_DEBUG_WAIT,\r\n"wait_time: %d", wait_time);\r\nreturn;\r\n}\r\nudelay(1);\r\nwait_time++;\r\n} while (wait_time < REQSACK_TIMEOUT_TIME);\r\nnsp32_msg(KERN_WARNING, "wait REQ timeout, req_bit: 0x%x", req_bit);\r\n}\r\nstatic void nsp32_wait_sack(nsp32_hw_data *data, int state)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nint wait_time = 0;\r\nunsigned char bus, ack_bit;\r\nif (!((state == ASSERT) || (state == NEGATE))) {\r\nnsp32_msg(KERN_ERR, "unknown state designation");\r\n}\r\nack_bit = (state == ASSERT ? BUSMON_ACK : 0);\r\ndo {\r\nbus = nsp32_read1(base, SCSI_BUS_MONITOR);\r\nif ((bus & BUSMON_ACK) == ack_bit) {\r\nnsp32_dbg(NSP32_DEBUG_WAIT,\r\n"wait_time: %d", wait_time);\r\nreturn;\r\n}\r\nudelay(1);\r\nwait_time++;\r\n} while (wait_time < REQSACK_TIMEOUT_TIME);\r\nnsp32_msg(KERN_WARNING, "wait SACK timeout, ack_bit: 0x%x", ack_bit);\r\n}\r\nstatic void nsp32_sack_assert(nsp32_hw_data *data)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nunsigned char busctrl;\r\nbusctrl = nsp32_read1(base, SCSI_BUS_CONTROL);\r\nbusctrl |= (BUSCTL_ACK | AUTODIRECTION | ACKENB);\r\nnsp32_write1(base, SCSI_BUS_CONTROL, busctrl);\r\n}\r\nstatic void nsp32_sack_negate(nsp32_hw_data *data)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nunsigned char busctrl;\r\nbusctrl = nsp32_read1(base, SCSI_BUS_CONTROL);\r\nbusctrl &= ~BUSCTL_ACK;\r\nnsp32_write1(base, SCSI_BUS_CONTROL, busctrl);\r\n}\r\nstatic int nsp32_detect(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct resource *res;\r\nnsp32_hw_data *data;\r\nint ret;\r\nint i, j;\r\nnsp32_dbg(NSP32_DEBUG_REGISTER, "enter");\r\nhost = scsi_host_alloc(&nsp32_template, sizeof(nsp32_hw_data));\r\nif (host == NULL) {\r\nnsp32_msg (KERN_ERR, "failed to scsi register");\r\ngoto err;\r\n}\r\ndata = (nsp32_hw_data *)host->hostdata;\r\nmemcpy(data, &nsp32_data_base, sizeof(nsp32_hw_data));\r\nhost->irq = data->IrqNumber;\r\nhost->io_port = data->BaseAddress;\r\nhost->unique_id = data->BaseAddress;\r\nhost->n_io_port = data->NumAddress;\r\nhost->base = (unsigned long)data->MmioAddress;\r\ndata->Host = host;\r\nspin_lock_init(&(data->Lock));\r\ndata->cur_lunt = NULL;\r\ndata->cur_target = NULL;\r\ndata->trans_method = NSP32_TRANSFER_BUSMASTER;\r\ndata->clock = CLOCK_4;\r\nswitch (data->clock) {\r\ncase CLOCK_4:\r\ndata->synct = nsp32_sync_table_40M;\r\ndata->syncnum = ARRAY_SIZE(nsp32_sync_table_40M);\r\nbreak;\r\ncase CLOCK_2:\r\ndata->synct = nsp32_sync_table_20M;\r\ndata->syncnum = ARRAY_SIZE(nsp32_sync_table_20M);\r\nbreak;\r\ncase PCICLK:\r\ndata->synct = nsp32_sync_table_pci;\r\ndata->syncnum = ARRAY_SIZE(nsp32_sync_table_pci);\r\nbreak;\r\ndefault:\r\nnsp32_msg(KERN_WARNING,\r\n"Invalid clock div is selected, set CLOCK_4.");\r\ndata->clock = CLOCK_4;\r\ndata->synct = nsp32_sync_table_40M;\r\ndata->syncnum = ARRAY_SIZE(nsp32_sync_table_40M);\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {\r\nnsp32_msg (KERN_ERR, "failed to set PCI DMA mask");\r\ngoto scsi_unregister;\r\n}\r\ndata->autoparam = pci_alloc_consistent(pdev, sizeof(nsp32_autoparam), &(data->auto_paddr));\r\nif (data->autoparam == NULL) {\r\nnsp32_msg(KERN_ERR, "failed to allocate DMA memory");\r\ngoto scsi_unregister;\r\n}\r\ndata->sg_list = pci_alloc_consistent(pdev, NSP32_SG_TABLE_SIZE,\r\n&(data->sg_paddr));\r\nif (data->sg_list == NULL) {\r\nnsp32_msg(KERN_ERR, "failed to allocate DMA memory");\r\ngoto free_autoparam;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->lunt); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(data->lunt[0]); j++) {\r\nint offset = i * ARRAY_SIZE(data->lunt[0]) + j;\r\nnsp32_lunt tmp = {\r\n.SCpnt = NULL,\r\n.save_datp = 0,\r\n.msgin03 = FALSE,\r\n.sg_num = 0,\r\n.cur_entry = 0,\r\n.sglun = &(data->sg_list[offset]),\r\n.sglun_paddr = data->sg_paddr + (offset * sizeof(nsp32_sglun)),\r\n};\r\ndata->lunt[i][j] = tmp;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->target); i++) {\r\nnsp32_target *target = &(data->target[i]);\r\ntarget->limit_entry = 0;\r\ntarget->sync_flag = 0;\r\nnsp32_set_async(data, target);\r\n}\r\nret = nsp32_getprom_param(data);\r\nif (ret == FALSE) {\r\ndata->resettime = 3;\r\n}\r\nnsp32hw_init(data);\r\nsnprintf(data->info_str, sizeof(data->info_str),\r\n"NinjaSCSI-32Bi/UDE: irq %d, io 0x%lx+0x%x",\r\nhost->irq, host->io_port, host->n_io_port);\r\nnsp32_do_bus_reset(data);\r\nret = request_irq(host->irq, do_nsp32_isr, IRQF_SHARED, "nsp32", data);\r\nif (ret < 0) {\r\nnsp32_msg(KERN_ERR, "Unable to allocate IRQ for NinjaSCSI32 "\r\n"SCSI PCI controller. Interrupt: %d", host->irq);\r\ngoto free_sg_list;\r\n}\r\nres = request_region(host->io_port, host->n_io_port, "nsp32");\r\nif (res == NULL) {\r\nnsp32_msg(KERN_ERR,\r\n"I/O region 0x%lx+0x%lx is already used",\r\ndata->BaseAddress, data->NumAddress);\r\ngoto free_irq;\r\n}\r\nret = scsi_add_host(host, &pdev->dev);\r\nif (ret) {\r\nnsp32_msg(KERN_ERR, "failed to add scsi host");\r\ngoto free_region;\r\n}\r\nscsi_scan_host(host);\r\npci_set_drvdata(pdev, host);\r\nreturn 0;\r\nfree_region:\r\nrelease_region(host->io_port, host->n_io_port);\r\nfree_irq:\r\nfree_irq(host->irq, data);\r\nfree_sg_list:\r\npci_free_consistent(pdev, NSP32_SG_TABLE_SIZE,\r\ndata->sg_list, data->sg_paddr);\r\nfree_autoparam:\r\npci_free_consistent(pdev, sizeof(nsp32_autoparam),\r\ndata->autoparam, data->auto_paddr);\r\nscsi_unregister:\r\nscsi_host_put(host);\r\nerr:\r\nreturn 1;\r\n}\r\nstatic int nsp32_release(struct Scsi_Host *host)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)host->hostdata;\r\nif (data->autoparam) {\r\npci_free_consistent(data->Pci, sizeof(nsp32_autoparam),\r\ndata->autoparam, data->auto_paddr);\r\n}\r\nif (data->sg_list) {\r\npci_free_consistent(data->Pci, NSP32_SG_TABLE_SIZE,\r\ndata->sg_list, data->sg_paddr);\r\n}\r\nif (host->irq) {\r\nfree_irq(host->irq, data);\r\n}\r\nif (host->io_port && host->n_io_port) {\r\nrelease_region(host->io_port, host->n_io_port);\r\n}\r\nif (data->MmioAddress) {\r\niounmap(data->MmioAddress);\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *nsp32_info(struct Scsi_Host *shpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)shpnt->hostdata;\r\nreturn data->info_str;\r\n}\r\nstatic int nsp32_eh_abort(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nnsp32_msg(KERN_WARNING, "abort");\r\nif (data->cur_lunt->SCpnt == NULL) {\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "abort failed");\r\nreturn FAILED;\r\n}\r\nif (data->cur_target->sync_flag & (SDTR_INITIATOR | SDTR_TARGET)) {\r\ndata->cur_target->sync_flag = 0;\r\nnsp32_set_async(data, data->cur_target);\r\n}\r\nnsp32_write2(base, TRANSFER_CONTROL, 0);\r\nnsp32_write2(base, BM_CNT, 0);\r\nSCpnt->result = DID_ABORT << 16;\r\nnsp32_scsi_done(SCpnt);\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "abort success");\r\nreturn SUCCESS;\r\n}\r\nstatic int nsp32_eh_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nnsp32_msg(KERN_INFO, "Bus Reset");\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "SCpnt=0x%x", SCpnt);\r\nnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\r\nnsp32_do_bus_reset(data);\r\nnsp32_write2(base, IRQ_CONTROL, 0);\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic void nsp32_do_bus_reset(nsp32_hw_data *data)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nunsigned short intrdat;\r\nint i;\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "in");\r\nnsp32_write2(base, TRANSFER_CONTROL, 0);\r\nnsp32_write4(base, BM_CNT, 0);\r\nnsp32_write4(base, CLR_COUNTER, CLRCOUNTER_ALLMASK);\r\nfor (i = 0; i < ARRAY_SIZE(data->target); i++) {\r\nnsp32_target *target = &data->target[i];\r\ntarget->sync_flag = 0;\r\nnsp32_set_async(data, target);\r\n}\r\nnsp32_write1(base, SCSI_BUS_CONTROL, BUSCTL_RST);\r\nmdelay(RESET_HOLD_TIME / 1000);\r\nnsp32_write1(base, SCSI_BUS_CONTROL, 0);\r\nfor(i = 0; i < 5; i++) {\r\nintrdat = nsp32_read2(base, IRQ_STATUS);\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "irq:1: 0x%x", intrdat);\r\n}\r\ndata->CurrentSC = NULL;\r\n}\r\nstatic int nsp32_eh_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nstruct Scsi_Host *host = SCpnt->device->host;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nnsp32_hw_data *data = (nsp32_hw_data *)host->hostdata;\r\nnsp32_msg(KERN_INFO, "Host Reset");\r\nnsp32_dbg(NSP32_DEBUG_BUSRESET, "SCpnt=0x%x", SCpnt);\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nnsp32hw_init(data);\r\nnsp32_write2(base, IRQ_CONTROL, IRQ_CONTROL_ALL_IRQ_MASK);\r\nnsp32_do_bus_reset(data);\r\nnsp32_write2(base, IRQ_CONTROL, 0);\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int nsp32_getprom_param(nsp32_hw_data *data)\r\n{\r\nint vendor = data->pci_devid->vendor;\r\nint device = data->pci_devid->device;\r\nint ret, val, i;\r\nret = nsp32_prom_read(data, 0x7e);\r\nif (ret != 0x55) {\r\nnsp32_msg(KERN_INFO, "No EEPROM detected: 0x%x", ret);\r\nreturn FALSE;\r\n}\r\nret = nsp32_prom_read(data, 0x7f);\r\nif (ret != 0xaa) {\r\nnsp32_msg(KERN_INFO, "Invalid number: 0x%x", ret);\r\nreturn FALSE;\r\n}\r\nif (vendor == PCI_VENDOR_ID_WORKBIT &&\r\ndevice == PCI_DEVICE_ID_WORKBIT_STANDARD) {\r\nret = nsp32_getprom_c16(data);\r\n} else if (vendor == PCI_VENDOR_ID_WORKBIT &&\r\ndevice == PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC) {\r\nret = nsp32_getprom_at24(data);\r\n} else if (vendor == PCI_VENDOR_ID_WORKBIT &&\r\ndevice == PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO ) {\r\nret = nsp32_getprom_at24(data);\r\n} else {\r\nnsp32_msg(KERN_WARNING, "Unknown EEPROM");\r\nret = FALSE;\r\n}\r\nfor (i = 0; i <= 0x1f; i++) {\r\nval = nsp32_prom_read(data, i);\r\nnsp32_dbg(NSP32_DEBUG_EEPROM,\r\n"rom address 0x%x : 0x%x", i, val);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nsp32_getprom_at24(nsp32_hw_data *data)\r\n{\r\nint ret, i;\r\nint auto_sync;\r\nnsp32_target *target;\r\nint entry;\r\ndata->resettime = nsp32_prom_read(data, 0x12);\r\nret = nsp32_prom_read(data, 0x07);\r\nswitch (ret) {\r\ncase 0:\r\nauto_sync = TRUE;\r\nbreak;\r\ncase 1:\r\nauto_sync = FALSE;\r\nbreak;\r\ndefault:\r\nnsp32_msg(KERN_WARNING,\r\n"Unsupported Auto Sync mode. Fall back to manual mode.");\r\nauto_sync = TRUE;\r\n}\r\nif (trans_mode == ULTRA20M_MODE) {\r\nauto_sync = TRUE;\r\n}\r\nfor (i = 0; i < NSP32_HOST_SCSIID; i++) {\r\ntarget = &data->target[i];\r\nif (auto_sync == TRUE) {\r\ntarget->limit_entry = 0;\r\n} else {\r\nret = nsp32_prom_read(data, i);\r\nentry = nsp32_search_period_entry(data, target, ret);\r\nif (entry < 0) {\r\nentry = 0;\r\n}\r\ntarget->limit_entry = entry;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int nsp32_getprom_c16(nsp32_hw_data *data)\r\n{\r\nint ret, i;\r\nnsp32_target *target;\r\nint entry, val;\r\ndata->resettime = nsp32_prom_read(data, 0x11);\r\nfor (i = 0; i < NSP32_HOST_SCSIID; i++) {\r\ntarget = &data->target[i];\r\nret = nsp32_prom_read(data, i);\r\nswitch (ret) {\r\ncase 0:\r\nval = 0x0c;\r\nbreak;\r\ncase 1:\r\nval = 0x19;\r\nbreak;\r\ncase 2:\r\nval = 0x32;\r\nbreak;\r\ncase 3:\r\nval = 0x00;\r\nbreak;\r\ndefault:\r\nval = 0x0c;\r\nbreak;\r\n}\r\nentry = nsp32_search_period_entry(data, target, val);\r\nif (entry < 0 || trans_mode == ULTRA20M_MODE) {\r\nentry = 0;\r\n}\r\ntarget->limit_entry = entry;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int nsp32_prom_read(nsp32_hw_data *data, int romaddr)\r\n{\r\nint i, val;\r\nnsp32_prom_start(data);\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nfor (i = 7; i >= 0; i--) {\r\nnsp32_prom_write_bit(data, ((romaddr >> i) & 1));\r\n}\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_start(data);\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 0);\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_write_bit(data, 0);\r\nval = 0;\r\nfor (i = 7; i >= 0; i--) {\r\nval += (nsp32_prom_read_bit(data) << i);\r\n}\r\nnsp32_prom_write_bit(data, 1);\r\nnsp32_prom_stop(data);\r\nreturn val;\r\n}\r\nstatic void nsp32_prom_set(nsp32_hw_data *data, int bit, int val)\r\n{\r\nint base = data->BaseAddress;\r\nint tmp;\r\ntmp = nsp32_index_read1(base, SERIAL_ROM_CTL);\r\nif (val == 0) {\r\ntmp &= ~bit;\r\n} else {\r\ntmp |= bit;\r\n}\r\nnsp32_index_write1(base, SERIAL_ROM_CTL, tmp);\r\nudelay(10);\r\n}\r\nstatic int nsp32_prom_get(nsp32_hw_data *data, int bit)\r\n{\r\nint base = data->BaseAddress;\r\nint tmp, ret;\r\nif (bit != SDA) {\r\nnsp32_msg(KERN_ERR, "return value is not appropriate");\r\nreturn 0;\r\n}\r\ntmp = nsp32_index_read1(base, SERIAL_ROM_CTL) & bit;\r\nif (tmp == 0) {\r\nret = 0;\r\n} else {\r\nret = 1;\r\n}\r\nudelay(10);\r\nreturn ret;\r\n}\r\nstatic void nsp32_prom_start (nsp32_hw_data *data)\r\n{\r\nnsp32_prom_set(data, SCL, 1);\r\nnsp32_prom_set(data, SDA, 1);\r\nnsp32_prom_set(data, ENA, 1);\r\nnsp32_prom_set(data, SDA, 0);\r\nnsp32_prom_set(data, SCL, 0);\r\n}\r\nstatic void nsp32_prom_stop (nsp32_hw_data *data)\r\n{\r\nnsp32_prom_set(data, SCL, 1);\r\nnsp32_prom_set(data, SDA, 0);\r\nnsp32_prom_set(data, ENA, 1);\r\nnsp32_prom_set(data, SDA, 1);\r\nnsp32_prom_set(data, SCL, 0);\r\n}\r\nstatic void nsp32_prom_write_bit(nsp32_hw_data *data, int val)\r\n{\r\nnsp32_prom_set(data, SDA, val);\r\nnsp32_prom_set(data, SCL, 1 );\r\nnsp32_prom_set(data, SCL, 0 );\r\n}\r\nstatic int nsp32_prom_read_bit(nsp32_hw_data *data)\r\n{\r\nint val;\r\nnsp32_prom_set(data, ENA, 0);\r\nnsp32_prom_set(data, SCL, 1);\r\nval = nsp32_prom_get(data, SDA);\r\nnsp32_prom_set(data, SCL, 0);\r\nnsp32_prom_set(data, ENA, 1);\r\nreturn val;\r\n}\r\nstatic int nsp32_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nnsp32_msg(KERN_INFO, "pci-suspend: pdev=0x%p, state=%ld, slot=%s, host=0x%p", pdev, state, pci_name(pdev), host);\r\npci_save_state (pdev);\r\npci_disable_device (pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int nsp32_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nnsp32_hw_data *data = (nsp32_hw_data *)host->hostdata;\r\nunsigned short reg;\r\nnsp32_msg(KERN_INFO, "pci-resume: pdev=0x%p, slot=%s, host=0x%p", pdev, pci_name(pdev), host);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake (pdev, PCI_D0, 0);\r\npci_restore_state (pdev);\r\nreg = nsp32_read2(data->BaseAddress, INDEX_REG);\r\nnsp32_msg(KERN_INFO, "io=0x%x reg=0x%x", data->BaseAddress, reg);\r\nif (reg == 0xffff) {\r\nnsp32_msg(KERN_INFO, "missing device. abort resume.");\r\nreturn 0;\r\n}\r\nnsp32hw_init (data);\r\nnsp32_do_bus_reset(data);\r\nnsp32_msg(KERN_INFO, "resume success");\r\nreturn 0;\r\n}\r\nstatic int nsp32_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint ret;\r\nnsp32_hw_data *data = &nsp32_data_base;\r\nnsp32_dbg(NSP32_DEBUG_REGISTER, "enter");\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\nnsp32_msg(KERN_ERR, "failed to enable pci device");\r\nreturn ret;\r\n}\r\ndata->Pci = pdev;\r\ndata->pci_devid = id;\r\ndata->IrqNumber = pdev->irq;\r\ndata->BaseAddress = pci_resource_start(pdev, 0);\r\ndata->NumAddress = pci_resource_len (pdev, 0);\r\ndata->MmioAddress = pci_ioremap_bar(pdev, 1);\r\ndata->MmioLength = pci_resource_len (pdev, 1);\r\npci_set_master(pdev);\r\nret = nsp32_detect(pdev);\r\nnsp32_msg(KERN_INFO, "irq: %i mmio: %p+0x%lx slot: %s model: %s",\r\npdev->irq,\r\ndata->MmioAddress, data->MmioLength,\r\npci_name(pdev),\r\nnsp32_model[id->driver_data]);\r\nnsp32_dbg(NSP32_DEBUG_REGISTER, "exit %d", ret);\r\nreturn ret;\r\n}\r\nstatic void nsp32_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nnsp32_dbg(NSP32_DEBUG_REGISTER, "enter");\r\nscsi_remove_host(host);\r\nnsp32_release(host);\r\nscsi_host_put(host);\r\n}\r\nstatic int __init init_nsp32(void) {\r\nnsp32_msg(KERN_INFO, "loading...");\r\nreturn pci_register_driver(&nsp32_driver);\r\n}\r\nstatic void __exit exit_nsp32(void) {\r\nnsp32_msg(KERN_INFO, "unloading...");\r\npci_unregister_driver(&nsp32_driver);\r\n}
