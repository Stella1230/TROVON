static inline int macidx(const struct cmac *mac)\r\n{\r\nreturn mac->offset / (XGMAC0_1_BASE_ADDR - XGMAC0_0_BASE_ADDR);\r\n}\r\nstatic void xaui_serdes_reset(struct cmac *mac)\r\n{\r\nstatic const unsigned int clear[] = {\r\nF_PWRDN0 | F_PWRDN1, F_RESETPLL01, F_RESET0 | F_RESET1,\r\nF_PWRDN2 | F_PWRDN3, F_RESETPLL23, F_RESET2 | F_RESET3\r\n};\r\nint i;\r\nstruct adapter *adap = mac->adapter;\r\nu32 ctrl = A_XGM_SERDES_CTRL0 + mac->offset;\r\nt3_write_reg(adap, ctrl, adap->params.vpd.xauicfg[macidx(mac)] |\r\nF_RESET3 | F_RESET2 | F_RESET1 | F_RESET0 |\r\nF_PWRDN3 | F_PWRDN2 | F_PWRDN1 | F_PWRDN0 |\r\nF_RESETPLL23 | F_RESETPLL01);\r\nt3_read_reg(adap, ctrl);\r\nudelay(15);\r\nfor (i = 0; i < ARRAY_SIZE(clear); i++) {\r\nt3_set_reg_field(adap, ctrl, clear[i], 0);\r\nudelay(15);\r\n}\r\n}\r\nvoid t3b_pcs_reset(struct cmac *mac)\r\n{\r\nt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset,\r\nF_PCS_RESET_, 0);\r\nudelay(20);\r\nt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset, 0,\r\nF_PCS_RESET_);\r\n}\r\nint t3_mac_reset(struct cmac *mac)\r\n{\r\nstatic const struct addr_val_pair mac_reset_avp[] = {\r\n{A_XGM_TX_CTRL, 0},\r\n{A_XGM_RX_CTRL, 0},\r\n{A_XGM_RX_CFG, F_DISPAUSEFRAMES | F_EN1536BFRAMES |\r\nF_RMFCS | F_ENJUMBO | F_ENHASHMCAST},\r\n{A_XGM_RX_HASH_LOW, 0},\r\n{A_XGM_RX_HASH_HIGH, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_1, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_2, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_3, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_4, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_5, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_6, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_7, 0},\r\n{A_XGM_RX_EXACT_MATCH_LOW_8, 0},\r\n{A_XGM_STAT_CTRL, F_CLRSTATS}\r\n};\r\nu32 val;\r\nstruct adapter *adap = mac->adapter;\r\nunsigned int oft = mac->offset;\r\nt3_write_reg(adap, A_XGM_RESET_CTRL + oft, F_MAC_RESET_);\r\nt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\r\nt3_write_regs(adap, mac_reset_avp, ARRAY_SIZE(mac_reset_avp), oft);\r\nt3_set_reg_field(adap, A_XGM_RXFIFO_CFG + oft,\r\nF_RXSTRFRWRD | F_DISERRFRAMES,\r\nuses_xaui(adap) ? 0 : F_RXSTRFRWRD);\r\nt3_set_reg_field(adap, A_XGM_TXFIFO_CFG + oft, 0, F_UNDERUNFIX);\r\nif (uses_xaui(adap)) {\r\nif (adap->params.rev == 0) {\r\nt3_set_reg_field(adap, A_XGM_SERDES_CTRL + oft, 0,\r\nF_RXENABLE | F_TXENABLE);\r\nif (t3_wait_op_done(adap, A_XGM_SERDES_STATUS1 + oft,\r\nF_CMULOCK, 1, 5, 2)) {\r\nCH_ERR(adap,\r\n"MAC %d XAUI SERDES CMU lock failed\n",\r\nmacidx(mac));\r\nreturn -1;\r\n}\r\nt3_set_reg_field(adap, A_XGM_SERDES_CTRL + oft, 0,\r\nF_SERDESRESET_);\r\n} else\r\nxaui_serdes_reset(mac);\r\n}\r\nt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + oft,\r\nV_RXMAXFRAMERSIZE(M_RXMAXFRAMERSIZE),\r\nV_RXMAXFRAMERSIZE(MAX_FRAME_SIZE) | F_RXENFRAMER);\r\nval = F_MAC_RESET_ | F_XGMAC_STOP_EN;\r\nif (is_10G(adap))\r\nval |= F_PCS_RESET_;\r\nelse if (uses_xaui(adap))\r\nval |= F_PCS_RESET_ | F_XG2G_RESET_;\r\nelse\r\nval |= F_RGMII_RESET_ | F_XG2G_RESET_;\r\nt3_write_reg(adap, A_XGM_RESET_CTRL + oft, val);\r\nt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\r\nif ((val & F_PCS_RESET_) && adap->params.rev) {\r\nmsleep(1);\r\nt3b_pcs_reset(mac);\r\n}\r\nmemset(&mac->stats, 0, sizeof(mac->stats));\r\nreturn 0;\r\n}\r\nstatic int t3b2_mac_reset(struct cmac *mac)\r\n{\r\nstruct adapter *adap = mac->adapter;\r\nunsigned int oft = mac->offset, store;\r\nint idx = macidx(mac);\r\nu32 val;\r\nif (!macidx(mac))\r\nt3_set_reg_field(adap, A_MPS_CFG, F_PORT0ACTIVE, 0);\r\nelse\r\nt3_set_reg_field(adap, A_MPS_CFG, F_PORT1ACTIVE, 0);\r\nt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 0);\r\nt3_set_reg_field(adap, A_XGM_TX_CFG + oft, F_TXPAUSEEN, 0);\r\nt3_write_reg(adap, A_XGM_RESET_CTRL + oft, F_MAC_RESET_);\r\nt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\r\nstore = t3_read_reg(adap, A_TP_TX_DROP_CFG_CH0 + idx);\r\nmsleep(10);\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\r\nt3_write_reg(adap, A_TP_PIO_DATA, 0xc0000011);\r\nif (t3_wait_op_done(adap, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT + oft,\r\n0x80000000, 1, 1000, 2)) {\r\nCH_ERR(adap, "MAC %d Rx fifo drain failed\n",\r\nmacidx(mac));\r\nreturn -1;\r\n}\r\nt3_write_reg(adap, A_XGM_RESET_CTRL + oft, 0);\r\nt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\r\nval = F_MAC_RESET_;\r\nif (is_10G(adap))\r\nval |= F_PCS_RESET_;\r\nelse if (uses_xaui(adap))\r\nval |= F_PCS_RESET_ | F_XG2G_RESET_;\r\nelse\r\nval |= F_RGMII_RESET_ | F_XG2G_RESET_;\r\nt3_write_reg(adap, A_XGM_RESET_CTRL + oft, val);\r\nt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\r\nif ((val & F_PCS_RESET_) && adap->params.rev) {\r\nmsleep(1);\r\nt3b_pcs_reset(mac);\r\n}\r\nt3_write_reg(adap, A_XGM_RX_CFG + oft,\r\nF_DISPAUSEFRAMES | F_EN1536BFRAMES |\r\nF_RMFCS | F_ENJUMBO | F_ENHASHMCAST);\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\r\nt3_write_reg(adap, A_TP_PIO_DATA, store);\r\nif (!idx)\r\nt3_set_reg_field(adap, A_MPS_CFG, 0, F_PORT0ACTIVE);\r\nelse\r\nt3_set_reg_field(adap, A_MPS_CFG, 0, F_PORT1ACTIVE);\r\nt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 1);\r\nt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 1);\r\nreturn 0;\r\n}\r\nstatic void set_addr_filter(struct cmac *mac, int idx, const u8 * addr)\r\n{\r\nu32 addr_lo, addr_hi;\r\nunsigned int oft = mac->offset + idx * 8;\r\naddr_lo = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\r\naddr_hi = (addr[5] << 8) | addr[4];\r\nt3_write_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1 + oft, addr_lo);\r\nt3_write_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_HIGH_1 + oft, addr_hi);\r\n}\r\nint t3_mac_set_address(struct cmac *mac, unsigned int idx, u8 addr[6])\r\n{\r\nif (idx >= mac->nucast)\r\nreturn -EINVAL;\r\nset_addr_filter(mac, idx, addr);\r\nreturn 0;\r\n}\r\nint t3_mac_set_num_ucast(struct cmac *mac, int n)\r\n{\r\nif (n > EXACT_ADDR_FILTERS)\r\nreturn -EINVAL;\r\nmac->nucast = n;\r\nreturn 0;\r\n}\r\nvoid t3_mac_disable_exact_filters(struct cmac *mac)\r\n{\r\nunsigned int i, reg = mac->offset + A_XGM_RX_EXACT_MATCH_LOW_1;\r\nfor (i = 0; i < EXACT_ADDR_FILTERS; i++, reg += 8) {\r\nu32 v = t3_read_reg(mac->adapter, reg);\r\nt3_write_reg(mac->adapter, reg, v);\r\n}\r\nt3_read_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1);\r\n}\r\nvoid t3_mac_enable_exact_filters(struct cmac *mac)\r\n{\r\nunsigned int i, reg = mac->offset + A_XGM_RX_EXACT_MATCH_HIGH_1;\r\nfor (i = 0; i < EXACT_ADDR_FILTERS; i++, reg += 8) {\r\nu32 v = t3_read_reg(mac->adapter, reg);\r\nt3_write_reg(mac->adapter, reg, v);\r\n}\r\nt3_read_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1);\r\n}\r\nstatic int hash_hw_addr(const u8 * addr)\r\n{\r\nint hash = 0, octet, bit, i = 0, c;\r\nfor (octet = 0; octet < 6; ++octet)\r\nfor (c = addr[octet], bit = 0; bit < 8; c >>= 1, ++bit) {\r\nhash ^= (c & 1) << i;\r\nif (++i == 6)\r\ni = 0;\r\n}\r\nreturn hash;\r\n}\r\nint t3_mac_set_rx_mode(struct cmac *mac, struct net_device *dev)\r\n{\r\nu32 val, hash_lo, hash_hi;\r\nstruct adapter *adap = mac->adapter;\r\nunsigned int oft = mac->offset;\r\nval = t3_read_reg(adap, A_XGM_RX_CFG + oft) & ~F_COPYALLFRAMES;\r\nif (dev->flags & IFF_PROMISC)\r\nval |= F_COPYALLFRAMES;\r\nt3_write_reg(adap, A_XGM_RX_CFG + oft, val);\r\nif (dev->flags & IFF_ALLMULTI)\r\nhash_lo = hash_hi = 0xffffffff;\r\nelse {\r\nstruct netdev_hw_addr *ha;\r\nint exact_addr_idx = mac->nucast;\r\nhash_lo = hash_hi = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nif (exact_addr_idx < EXACT_ADDR_FILTERS)\r\nset_addr_filter(mac, exact_addr_idx++,\r\nha->addr);\r\nelse {\r\nint hash = hash_hw_addr(ha->addr);\r\nif (hash < 32)\r\nhash_lo |= (1 << hash);\r\nelse\r\nhash_hi |= (1 << (hash - 32));\r\n}\r\n}\r\nt3_write_reg(adap, A_XGM_RX_HASH_LOW + oft, hash_lo);\r\nt3_write_reg(adap, A_XGM_RX_HASH_HIGH + oft, hash_hi);\r\nreturn 0;\r\n}\r\nstatic int rx_fifo_hwm(int mtu)\r\n{\r\nint hwm;\r\nhwm = max(MAC_RXFIFO_SIZE - 3 * mtu, (MAC_RXFIFO_SIZE * 38) / 100);\r\nreturn min(hwm, MAC_RXFIFO_SIZE - 8192);\r\n}\r\nint t3_mac_set_mtu(struct cmac *mac, unsigned int mtu)\r\n{\r\nint hwm, lwm, divisor;\r\nint ipg;\r\nunsigned int thres, v, reg;\r\nstruct adapter *adap = mac->adapter;\r\nmtu += 14;\r\nif (mtu > 1536)\r\nmtu += 4;\r\nif (mtu > MAX_FRAME_SIZE - 4)\r\nreturn -EINVAL;\r\nt3_write_reg(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset, mtu);\r\nif (adap->params.rev >= T3_REV_B2 &&\r\n(t3_read_reg(adap, A_XGM_RX_CTRL + mac->offset) & F_RXEN)) {\r\nt3_mac_disable_exact_filters(mac);\r\nv = t3_read_reg(adap, A_XGM_RX_CFG + mac->offset);\r\nt3_set_reg_field(adap, A_XGM_RX_CFG + mac->offset,\r\nF_ENHASHMCAST | F_COPYALLFRAMES, F_DISBCAST);\r\nreg = adap->params.rev == T3_REV_B2 ?\r\nA_XGM_RX_MAX_PKT_SIZE_ERR_CNT : A_XGM_RXFIFO_CFG;\r\nif (t3_wait_op_done(adap, reg + mac->offset,\r\nF_RXFIFO_EMPTY, 1, 20, 5)) {\r\nt3_write_reg(adap, A_XGM_RX_CFG + mac->offset, v);\r\nt3_mac_enable_exact_filters(mac);\r\nreturn -EIO;\r\n}\r\nt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset,\r\nV_RXMAXPKTSIZE(M_RXMAXPKTSIZE),\r\nV_RXMAXPKTSIZE(mtu));\r\nt3_write_reg(adap, A_XGM_RX_CFG + mac->offset, v);\r\nt3_mac_enable_exact_filters(mac);\r\n} else\r\nt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset,\r\nV_RXMAXPKTSIZE(M_RXMAXPKTSIZE),\r\nV_RXMAXPKTSIZE(mtu));\r\nhwm = rx_fifo_hwm(mtu);\r\nlwm = min(3 * (int)mtu, MAC_RXFIFO_SIZE / 4);\r\nv = t3_read_reg(adap, A_XGM_RXFIFO_CFG + mac->offset);\r\nv &= ~V_RXFIFOPAUSELWM(M_RXFIFOPAUSELWM);\r\nv |= V_RXFIFOPAUSELWM(lwm / 8);\r\nif (G_RXFIFOPAUSEHWM(v))\r\nv = (v & ~V_RXFIFOPAUSEHWM(M_RXFIFOPAUSEHWM)) |\r\nV_RXFIFOPAUSEHWM(hwm / 8);\r\nt3_write_reg(adap, A_XGM_RXFIFO_CFG + mac->offset, v);\r\nthres = (adap->params.vpd.cclk * 1000) / 15625;\r\nthres = (thres * mtu) / 1000;\r\nif (is_10G(adap))\r\nthres /= 10;\r\nthres = mtu > thres ? (mtu - thres + 7) / 8 : 0;\r\nthres = max(thres, 8U);\r\nipg = (adap->params.rev == T3_REV_C) ? 0 : 1;\r\nt3_set_reg_field(adap, A_XGM_TXFIFO_CFG + mac->offset,\r\nV_TXFIFOTHRESH(M_TXFIFOTHRESH) | V_TXIPG(M_TXIPG),\r\nV_TXFIFOTHRESH(thres) | V_TXIPG(ipg));\r\nif (adap->params.rev > 0) {\r\ndivisor = (adap->params.rev == T3_REV_C) ? 64 : 8;\r\nt3_write_reg(adap, A_XGM_PAUSE_TIMER + mac->offset,\r\n(hwm - lwm) * 4 / divisor);\r\n}\r\nt3_write_reg(adap, A_XGM_TX_PAUSE_QUANTA + mac->offset,\r\nMAC_RXFIFO_SIZE * 4 * 8 / 512);\r\nreturn 0;\r\n}\r\nint t3_mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex, int fc)\r\n{\r\nu32 val;\r\nstruct adapter *adap = mac->adapter;\r\nunsigned int oft = mac->offset;\r\nif (duplex >= 0 && duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\nif (speed >= 0) {\r\nif (speed == SPEED_10)\r\nval = V_PORTSPEED(0);\r\nelse if (speed == SPEED_100)\r\nval = V_PORTSPEED(1);\r\nelse if (speed == SPEED_1000)\r\nval = V_PORTSPEED(2);\r\nelse if (speed == SPEED_10000)\r\nval = V_PORTSPEED(3);\r\nelse\r\nreturn -EINVAL;\r\nt3_set_reg_field(adap, A_XGM_PORT_CFG + oft,\r\nV_PORTSPEED(M_PORTSPEED), val);\r\n}\r\nval = t3_read_reg(adap, A_XGM_RXFIFO_CFG + oft);\r\nval &= ~V_RXFIFOPAUSEHWM(M_RXFIFOPAUSEHWM);\r\nif (fc & PAUSE_TX) {\r\nu32 rx_max_pkt_size =\r\nG_RXMAXPKTSIZE(t3_read_reg(adap,\r\nA_XGM_RX_MAX_PKT_SIZE + oft));\r\nval |= V_RXFIFOPAUSEHWM(rx_fifo_hwm(rx_max_pkt_size) / 8);\r\n}\r\nt3_write_reg(adap, A_XGM_RXFIFO_CFG + oft, val);\r\nt3_set_reg_field(adap, A_XGM_TX_CFG + oft, F_TXPAUSEEN,\r\n(fc & PAUSE_RX) ? F_TXPAUSEEN : 0);\r\nreturn 0;\r\n}\r\nint t3_mac_enable(struct cmac *mac, int which)\r\n{\r\nint idx = macidx(mac);\r\nstruct adapter *adap = mac->adapter;\r\nunsigned int oft = mac->offset;\r\nstruct mac_stats *s = &mac->stats;\r\nif (which & MAC_DIRECTION_TX) {\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\r\nt3_write_reg(adap, A_TP_PIO_DATA,\r\nadap->params.rev == T3_REV_C ?\r\n0xc4ffff01 : 0xc0ede401);\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_MODE);\r\nt3_set_reg_field(adap, A_TP_PIO_DATA, 1 << idx,\r\nadap->params.rev == T3_REV_C ? 0 : 1 << idx);\r\nt3_write_reg(adap, A_XGM_TX_CTRL + oft, F_TXEN);\r\nt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CNT_CH0 + idx);\r\nmac->tx_mcnt = s->tx_frames;\r\nmac->tx_tcnt = (G_TXDROPCNTCH0RCVD(t3_read_reg(adap,\r\nA_TP_PIO_DATA)));\r\nmac->tx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\r\nA_XGM_TX_SPI4_SOP_EOP_CNT +\r\noft)));\r\nmac->rx_mcnt = s->rx_frames;\r\nmac->rx_pause = s->rx_pause;\r\nmac->rx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\r\nA_XGM_RX_SPI4_SOP_EOP_CNT +\r\noft)));\r\nmac->rx_ocnt = s->rx_fifo_ovfl;\r\nmac->txen = F_TXEN;\r\nmac->toggle_cnt = 0;\r\n}\r\nif (which & MAC_DIRECTION_RX)\r\nt3_write_reg(adap, A_XGM_RX_CTRL + oft, F_RXEN);\r\nreturn 0;\r\n}\r\nint t3_mac_disable(struct cmac *mac, int which)\r\n{\r\nstruct adapter *adap = mac->adapter;\r\nif (which & MAC_DIRECTION_TX) {\r\nt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, 0);\r\nmac->txen = 0;\r\n}\r\nif (which & MAC_DIRECTION_RX) {\r\nint val = F_MAC_RESET_;\r\nt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset,\r\nF_PCS_RESET_, 0);\r\nmsleep(100);\r\nt3_write_reg(adap, A_XGM_RX_CTRL + mac->offset, 0);\r\nif (is_10G(adap))\r\nval |= F_PCS_RESET_;\r\nelse if (uses_xaui(adap))\r\nval |= F_PCS_RESET_ | F_XG2G_RESET_;\r\nelse\r\nval |= F_RGMII_RESET_ | F_XG2G_RESET_;\r\nt3_write_reg(mac->adapter, A_XGM_RESET_CTRL + mac->offset, val);\r\n}\r\nreturn 0;\r\n}\r\nint t3b2_mac_watchdog_task(struct cmac *mac)\r\n{\r\nstruct adapter *adap = mac->adapter;\r\nstruct mac_stats *s = &mac->stats;\r\nunsigned int tx_tcnt, tx_xcnt;\r\nu64 tx_mcnt = s->tx_frames;\r\nint status;\r\nstatus = 0;\r\ntx_xcnt = 1;\r\ntx_tcnt = mac->tx_tcnt;\r\nif (tx_mcnt == mac->tx_mcnt && mac->rx_pause == s->rx_pause) {\r\ntx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\r\nA_XGM_TX_SPI4_SOP_EOP_CNT +\r\nmac->offset)));\r\nif (tx_xcnt == 0) {\r\nt3_write_reg(adap, A_TP_PIO_ADDR,\r\nA_TP_TX_DROP_CNT_CH0 + macidx(mac));\r\ntx_tcnt = (G_TXDROPCNTCH0RCVD(t3_read_reg(adap,\r\nA_TP_PIO_DATA)));\r\n} else {\r\ngoto out;\r\n}\r\n} else {\r\nmac->toggle_cnt = 0;\r\ngoto out;\r\n}\r\nif ((tx_tcnt != mac->tx_tcnt) && (mac->tx_xcnt == 0)) {\r\nif (mac->toggle_cnt > 4) {\r\nstatus = 2;\r\ngoto out;\r\n} else {\r\nstatus = 1;\r\ngoto out;\r\n}\r\n} else {\r\nmac->toggle_cnt = 0;\r\ngoto out;\r\n}\r\nout:\r\nmac->tx_tcnt = tx_tcnt;\r\nmac->tx_xcnt = tx_xcnt;\r\nmac->tx_mcnt = s->tx_frames;\r\nmac->rx_pause = s->rx_pause;\r\nif (status == 1) {\r\nt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, 0);\r\nt3_read_reg(adap, A_XGM_TX_CTRL + mac->offset);\r\nt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, mac->txen);\r\nt3_read_reg(adap, A_XGM_TX_CTRL + mac->offset);\r\nmac->toggle_cnt++;\r\n} else if (status == 2) {\r\nt3b2_mac_reset(mac);\r\nmac->toggle_cnt = 0;\r\n}\r\nreturn status;\r\n}\r\nconst struct mac_stats *t3_mac_update_stats(struct cmac *mac)\r\n{\r\n#define RMON_READ(mac, addr) t3_read_reg(mac->adapter, addr + mac->offset)\r\n#define RMON_UPDATE(mac, name, reg) \\r\n(mac)->stats.name += (u64)RMON_READ(mac, A_XGM_STAT_##reg)\r\n#define RMON_UPDATE64(mac, name, reg_lo, reg_hi) \\r\n(mac)->stats.name += RMON_READ(mac, A_XGM_STAT_##reg_lo) + \\r\n((u64)RMON_READ(mac, A_XGM_STAT_##reg_hi) << 32)\r\nu32 v, lo;\r\nRMON_UPDATE64(mac, rx_octets, RX_BYTES_LOW, RX_BYTES_HIGH);\r\nRMON_UPDATE64(mac, rx_frames, RX_FRAMES_LOW, RX_FRAMES_HIGH);\r\nRMON_UPDATE(mac, rx_mcast_frames, RX_MCAST_FRAMES);\r\nRMON_UPDATE(mac, rx_bcast_frames, RX_BCAST_FRAMES);\r\nRMON_UPDATE(mac, rx_fcs_errs, RX_CRC_ERR_FRAMES);\r\nRMON_UPDATE(mac, rx_pause, RX_PAUSE_FRAMES);\r\nRMON_UPDATE(mac, rx_jabber, RX_JABBER_FRAMES);\r\nRMON_UPDATE(mac, rx_short, RX_SHORT_FRAMES);\r\nRMON_UPDATE(mac, rx_symbol_errs, RX_SYM_CODE_ERR_FRAMES);\r\nRMON_UPDATE(mac, rx_too_long, RX_OVERSIZE_FRAMES);\r\nv = RMON_READ(mac, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT);\r\nif (mac->adapter->params.rev == T3_REV_B2)\r\nv &= 0x7fffffff;\r\nmac->stats.rx_too_long += v;\r\nRMON_UPDATE(mac, rx_frames_64, RX_64B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_65_127, RX_65_127B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_128_255, RX_128_255B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_256_511, RX_256_511B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_512_1023, RX_512_1023B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_1024_1518, RX_1024_1518B_FRAMES);\r\nRMON_UPDATE(mac, rx_frames_1519_max, RX_1519_MAXB_FRAMES);\r\nRMON_UPDATE64(mac, tx_octets, TX_BYTE_LOW, TX_BYTE_HIGH);\r\nRMON_UPDATE64(mac, tx_frames, TX_FRAME_LOW, TX_FRAME_HIGH);\r\nRMON_UPDATE(mac, tx_mcast_frames, TX_MCAST);\r\nRMON_UPDATE(mac, tx_bcast_frames, TX_BCAST);\r\nRMON_UPDATE(mac, tx_pause, TX_PAUSE);\r\nRMON_UPDATE(mac, tx_underrun, TX_ERR_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_64, TX_64B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_65_127, TX_65_127B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_128_255, TX_128_255B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_256_511, TX_256_511B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_512_1023, TX_512_1023B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_1024_1518, TX_1024_1518B_FRAMES);\r\nRMON_UPDATE(mac, tx_frames_1519_max, TX_1519_MAXB_FRAMES);\r\nt3_write_reg(mac->adapter, A_TP_MIB_INDEX, mac->offset ? 51 : 50);\r\nv = t3_read_reg(mac->adapter, A_TP_MIB_RDATA);\r\nlo = (u32) mac->stats.rx_cong_drops;\r\nmac->stats.rx_cong_drops += (u64) (v - lo);\r\nreturn &mac->stats;\r\n}
