static bool rt2800usb_hwcrypt_disabled(struct rt2x00_dev *rt2x00dev)\r\n{\r\nreturn modparam_nohwcrypt;\r\n}\r\nstatic void rt2800usb_start_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00usb_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);\r\nrt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00usb_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);\r\nrt2x00usb_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt2800usb_stop_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00usb_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);\r\nrt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00usb_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);\r\nrt2x00usb_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool rt2800usb_txstatus_pending(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nif (rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE) !=\r\nrt2x00queue_get_entry(queue, Q_INDEX_DONE))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline bool rt2800usb_entry_txstatus_timeout(struct queue_entry *entry)\r\n{\r\nbool tout;\r\nif (!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nreturn false;\r\ntout = time_after(jiffies, entry->last_action + msecs_to_jiffies(100));\r\nif (unlikely(tout))\r\nrt2x00_dbg(entry->queue->rt2x00dev,\r\n"TX status timeout for entry %d in queue %d\n",\r\nentry->entry_idx, entry->queue->qid);\r\nreturn tout;\r\n}\r\nstatic bool rt2800usb_txstatus_timeout(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nstruct queue_entry *entry;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nif (rt2800usb_entry_txstatus_timeout(entry))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,\r\nint urb_status, u32 tx_status)\r\n{\r\nbool valid;\r\nif (urb_status) {\r\nrt2x00_warn(rt2x00dev, "TX status read failed %d\n",\r\nurb_status);\r\ngoto stop_reading;\r\n}\r\nvalid = rt2x00_get_field32(tx_status, TX_STA_FIFO_VALID);\r\nif (valid) {\r\nif (!kfifo_put(&rt2x00dev->txstatus_fifo, tx_status))\r\nrt2x00_warn(rt2x00dev, "TX status FIFO overrun\n");\r\nqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\r\nreturn true;\r\n}\r\nif (rt2800usb_txstatus_timeout(rt2x00dev))\r\nqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\r\nif (rt2800usb_txstatus_pending(rt2x00dev)) {\r\nhrtimer_start(&rt2x00dev->txstatus_timer,\r\nktime_set(0, TXSTATUS_READ_INTERVAL),\r\nHRTIMER_MODE_REL);\r\nreturn false;\r\n}\r\nstop_reading:\r\nclear_bit(TX_STATUS_READING, &rt2x00dev->flags);\r\nif (rt2800usb_txstatus_pending(rt2x00dev) &&\r\n!test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void rt2800usb_async_read_tx_status(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))\r\nreturn;\r\nhrtimer_start(&rt2x00dev->txstatus_timer,\r\nktime_set(0, 2*TXSTATUS_READ_INTERVAL),\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic void rt2800usb_tx_dma_done(struct queue_entry *entry)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nrt2800usb_async_read_tx_status(rt2x00dev);\r\n}\r\nstatic enum hrtimer_restart rt2800usb_tx_sta_fifo_timeout(struct hrtimer *timer)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(timer, struct rt2x00_dev, txstatus_timer);\r\nrt2x00usb_register_read_async(rt2x00dev, TX_STA_FIFO,\r\nrt2800usb_tx_sta_fifo_read_completed);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int rt2800usb_autorun_detect(struct rt2x00_dev *rt2x00dev)\r\n{\r\n__le32 *reg;\r\nu32 fw_mode;\r\nreg = kmalloc(sizeof(*reg), GFP_KERNEL);\r\nif (reg == NULL)\r\nreturn -ENOMEM;\r\nrt2x00usb_vendor_request(rt2x00dev, USB_DEVICE_MODE,\r\nUSB_VENDOR_REQUEST_IN, 0, USB_MODE_AUTORUN,\r\nreg, sizeof(*reg), REGISTER_TIMEOUT_FIRMWARE);\r\nfw_mode = le32_to_cpu(*reg);\r\nkfree(reg);\r\nif ((fw_mode & 0x00000003) == 2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic char *rt2800usb_get_firmware_name(struct rt2x00_dev *rt2x00dev)\r\n{\r\nreturn FIRMWARE_RT2870;\r\n}\r\nstatic int rt2800usb_write_firmware(struct rt2x00_dev *rt2x00dev,\r\nconst u8 *data, const size_t len)\r\n{\r\nint status;\r\nu32 offset;\r\nu32 length;\r\nint retval;\r\nif (rt2x00_rt(rt2x00dev, RT2860) ||\r\nrt2x00_rt(rt2x00dev, RT2872) ||\r\nrt2x00_rt(rt2x00dev, RT3070)) {\r\noffset = 0;\r\nlength = 4096;\r\n} else {\r\noffset = 4096;\r\nlength = 4096;\r\n}\r\nretval = rt2800usb_autorun_detect(rt2x00dev);\r\nif (retval < 0)\r\nreturn retval;\r\nif (retval) {\r\nrt2x00_info(rt2x00dev,\r\n"Firmware loading not required - NIC in AutoRun mode\n");\r\n} else {\r\nrt2x00usb_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,\r\ndata + offset, length);\r\n}\r\nrt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);\r\nrt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);\r\nstatus = rt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE,\r\n0, USB_MODE_FIRMWARE,\r\nREGISTER_TIMEOUT_FIRMWARE);\r\nif (status < 0) {\r\nrt2x00_err(rt2x00dev, "Failed to write Firmware to device\n");\r\nreturn status;\r\n}\r\nmsleep(10);\r\nrt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);\r\nreturn 0;\r\n}\r\nstatic int rt2800usb_init_registers(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nif (rt2800_wait_csr_ready(rt2x00dev))\r\nreturn -EBUSY;\r\nrt2x00usb_register_read(rt2x00dev, PBF_SYS_CTRL, &reg);\r\nrt2x00usb_register_write(rt2x00dev, PBF_SYS_CTRL, reg & ~0x00002000);\r\nreg = 0;\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);\r\nrt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nrt2x00usb_register_write(rt2x00dev, USB_DMA_CFG, 0x00000000);\r\nrt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE, 0,\r\nUSB_MODE_RESET, REGISTER_TIMEOUT);\r\nrt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int rt2800usb_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nif (unlikely(rt2800_wait_wpdma_ready(rt2x00dev)))\r\nreturn -EIO;\r\nrt2x00usb_register_read(rt2x00dev, USB_DMA_CFG, &reg);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_PHY_CLEAR, 0);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_EN, 0);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_TIMEOUT, 128);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_LIMIT,\r\n((rt2x00dev->rx->limit * DATA_FRAME_SIZE)\r\n/ 1024) - 3);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_EN, 1);\r\nrt2x00_set_field32(&reg, USB_DMA_CFG_TX_BULK_EN, 1);\r\nrt2x00usb_register_write(rt2x00dev, USB_DMA_CFG, reg);\r\nreturn rt2800_enable_radio(rt2x00dev);\r\n}\r\nstatic void rt2800usb_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2800_disable_radio(rt2x00dev);\r\nrt2x00usb_disable_radio(rt2x00dev);\r\n}\r\nstatic int rt2800usb_set_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nif (state == STATE_AWAKE)\r\nrt2800_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0, 2);\r\nelse\r\nrt2800_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0xff, 2);\r\nreturn 0;\r\n}\r\nstatic int rt2800usb_set_device_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint retval = 0;\r\nswitch (state) {\r\ncase STATE_RADIO_ON:\r\nrt2800usb_set_state(rt2x00dev, STATE_AWAKE);\r\nmsleep(1);\r\nretval = rt2800usb_enable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_OFF:\r\nrt2800usb_disable_radio(rt2x00dev);\r\nrt2800usb_set_state(rt2x00dev, STATE_SLEEP);\r\nbreak;\r\ncase STATE_RADIO_IRQ_ON:\r\ncase STATE_RADIO_IRQ_OFF:\r\nbreak;\r\ncase STATE_DEEP_SLEEP:\r\ncase STATE_SLEEP:\r\ncase STATE_STANDBY:\r\ncase STATE_AWAKE:\r\nretval = rt2800usb_set_state(rt2x00dev, state);\r\nbreak;\r\ndefault:\r\nretval = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (unlikely(retval))\r\nrt2x00_err(rt2x00dev, "Device failed to enter state %d (%d)\n",\r\nstate, retval);\r\nreturn retval;\r\n}\r\nstatic void rt2800usb_watchdog(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu32 reg;\r\nrt2x00usb_register_read(rt2x00dev, TXRXQ_PCNT, &reg);\r\nif (rt2x00_get_field32(reg, TXRXQ_PCNT_TX0Q)) {\r\nrt2x00_warn(rt2x00dev, "TX HW queue 0 timed out, invoke forced kick\n");\r\nrt2x00usb_register_write(rt2x00dev, PBF_CFG, 0xf40012);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(10);\r\nif (!rt2x00_get_field32(reg, TXRXQ_PCNT_TX0Q))\r\nbreak;\r\n}\r\nrt2x00usb_register_write(rt2x00dev, PBF_CFG, 0xf40006);\r\n}\r\nrt2x00usb_register_read(rt2x00dev, TXRXQ_PCNT, &reg);\r\nif (rt2x00_get_field32(reg, TXRXQ_PCNT_TX1Q)) {\r\nrt2x00_warn(rt2x00dev, "TX HW queue 1 timed out, invoke forced kick\n");\r\nrt2x00usb_register_write(rt2x00dev, PBF_CFG, 0xf4000a);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(10);\r\nif (!rt2x00_get_field32(reg, TXRXQ_PCNT_TX1Q))\r\nbreak;\r\n}\r\nrt2x00usb_register_write(rt2x00dev, PBF_CFG, 0xf40006);\r\n}\r\nrt2x00usb_watchdog(rt2x00dev);\r\n}\r\nstatic __le32 *rt2800usb_get_txwi(struct queue_entry *entry)\r\n{\r\nif (entry->queue->qid == QID_BEACON)\r\nreturn (__le32 *) (entry->skb->data);\r\nelse\r\nreturn (__le32 *) (entry->skb->data + TXINFO_DESC_SIZE);\r\n}\r\nstatic void rt2800usb_write_tx_desc(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\n__le32 *txi = (__le32 *) entry->skb->data;\r\nu32 word;\r\nrt2x00_desc_read(txi, 0, &word);\r\nrt2x00_set_field32(&word, TXINFO_W0_USB_DMA_TX_PKT_LEN,\r\nroundup(entry->skb->len, 4) - TXINFO_DESC_SIZE);\r\nrt2x00_set_field32(&word, TXINFO_W0_WIV,\r\n!test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXINFO_W0_QSEL, 2);\r\nrt2x00_set_field32(&word, TXINFO_W0_SW_USE_LAST_ROUND, 0);\r\nrt2x00_set_field32(&word, TXINFO_W0_USB_DMA_NEXT_VALID, 0);\r\nrt2x00_set_field32(&word, TXINFO_W0_USB_DMA_TX_BURST,\r\ntest_bit(ENTRY_TXD_BURST, &txdesc->flags));\r\nrt2x00_desc_write(txi, 0, word);\r\nskbdesc->flags |= SKBDESC_DESC_IN_SKB;\r\nskbdesc->desc = txi;\r\nskbdesc->desc_len = TXINFO_DESC_SIZE + entry->queue->winfo_size;\r\n}\r\nstatic int rt2800usb_get_tx_data_len(struct queue_entry *entry)\r\n{\r\nreturn roundup(entry->skb->len, 4) + 4;\r\n}\r\nstatic enum txdone_entry_desc_flags\r\nrt2800usb_txdone_entry_check(struct queue_entry *entry, u32 reg)\r\n{\r\n__le32 *txwi;\r\nu32 word;\r\nint wcid, ack, pid;\r\nint tx_wcid, tx_ack, tx_pid, is_agg;\r\nif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\r\nreturn TXDONE_FAILURE;\r\nwcid = rt2x00_get_field32(reg, TX_STA_FIFO_WCID);\r\nack = rt2x00_get_field32(reg, TX_STA_FIFO_TX_ACK_REQUIRED);\r\npid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_TYPE);\r\nis_agg = rt2x00_get_field32(reg, TX_STA_FIFO_TX_AGGRE);\r\ntxwi = rt2800usb_get_txwi(entry);\r\nrt2x00_desc_read(txwi, 1, &word);\r\ntx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);\r\ntx_ack = rt2x00_get_field32(word, TXWI_W1_ACK);\r\ntx_pid = rt2x00_get_field32(word, TXWI_W1_PACKETID);\r\nif (wcid != tx_wcid || ack != tx_ack || (!is_agg && pid != tx_pid)) {\r\nrt2x00_dbg(entry->queue->rt2x00dev,\r\n"TX status report missed for queue %d entry %d\n",\r\nentry->queue->qid, entry->entry_idx);\r\nreturn TXDONE_UNKNOWN;\r\n}\r\nreturn TXDONE_SUCCESS;\r\n}\r\nstatic void rt2800usb_txdone(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nstruct queue_entry *entry;\r\nu32 reg;\r\nu8 qid;\r\nenum txdone_entry_desc_flags done_status;\r\nwhile (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {\r\nqid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_QUEUE);\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, qid);\r\nif (unlikely(rt2x00queue_empty(queue))) {\r\nrt2x00_dbg(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",\r\nqid);\r\nbreak;\r\n}\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nif (unlikely(test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\r\n!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))) {\r\nrt2x00_warn(rt2x00dev, "Data pending for entry %u in queue %u\n",\r\nentry->entry_idx, qid);\r\nbreak;\r\n}\r\ndone_status = rt2800usb_txdone_entry_check(entry, reg);\r\nif (likely(done_status == TXDONE_SUCCESS))\r\nrt2800_txdone_entry(entry, reg, rt2800usb_get_txwi(entry));\r\nelse\r\nrt2x00lib_txdone_noinfo(entry, done_status);\r\n}\r\n}\r\nstatic void rt2800usb_txdone_nostatus(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nstruct queue_entry *entry;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nwhile (!rt2x00queue_empty(queue)) {\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nif (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\r\n!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nbreak;\r\nif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\r\nrt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);\r\nelse if (rt2800usb_entry_txstatus_timeout(entry))\r\nrt2x00lib_txdone_noinfo(entry, TXDONE_UNKNOWN);\r\nelse\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rt2800usb_work_txdone(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, txdone_work);\r\nwhile (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||\r\nrt2800usb_txstatus_timeout(rt2x00dev)) {\r\nrt2800usb_txdone(rt2x00dev);\r\nrt2800usb_txdone_nostatus(rt2x00dev);\r\nif (rt2800usb_txstatus_pending(rt2x00dev))\r\nrt2800usb_async_read_tx_status(rt2x00dev);\r\n}\r\n}\r\nstatic void rt2800usb_fill_rxdone(struct queue_entry *entry,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\n__le32 *rxi = (__le32 *)entry->skb->data;\r\n__le32 *rxd;\r\nu32 word;\r\nint rx_pkt_len;\r\nmemcpy(skbdesc->desc, rxi, skbdesc->desc_len);\r\nrt2x00_desc_read(rxi, 0, &word);\r\nrx_pkt_len = rt2x00_get_field32(word, RXINFO_W0_USB_DMA_RX_PKT_LEN);\r\nskb_pull(entry->skb, RXINFO_DESC_SIZE);\r\nif (unlikely(rx_pkt_len == 0 ||\r\nrx_pkt_len > entry->queue->data_size)) {\r\nrt2x00_err(entry->queue->rt2x00dev,\r\n"Bad frame size %d, forcing to 0\n", rx_pkt_len);\r\nreturn;\r\n}\r\nrxd = (__le32 *)(entry->skb->data + rx_pkt_len);\r\nrt2x00_desc_read(rxd, 0, &word);\r\nif (rt2x00_get_field32(word, RXD_W0_CRC_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\r\nrxdesc->cipher_status = rt2x00_get_field32(word, RXD_W0_CIPHER_ERROR);\r\nif (rt2x00_get_field32(word, RXD_W0_DECRYPTED)) {\r\nrxdesc->flags |= RX_FLAG_IV_STRIPPED;\r\nrxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\r\nif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\r\nrxdesc->flags |= RX_FLAG_DECRYPTED;\r\nelse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\r\nrxdesc->flags |= RX_FLAG_MMIC_ERROR;\r\n}\r\nif (rt2x00_get_field32(word, RXD_W0_MY_BSS))\r\nrxdesc->dev_flags |= RXDONE_MY_BSS;\r\nif (rt2x00_get_field32(word, RXD_W0_L2PAD))\r\nrxdesc->dev_flags |= RXDONE_L2PAD;\r\nskb_trim(entry->skb, rx_pkt_len);\r\nrt2800_process_rxwi(entry, rxdesc);\r\n}\r\nstatic int rt2800usb_efuse_detect(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nretval = rt2800usb_autorun_detect(rt2x00dev);\r\nif (retval < 0)\r\nreturn retval;\r\nif (retval)\r\nreturn 1;\r\nreturn rt2800_efuse_detect(rt2x00dev);\r\n}\r\nstatic int rt2800usb_read_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nretval = rt2800usb_efuse_detect(rt2x00dev);\r\nif (retval < 0)\r\nreturn retval;\r\nif (retval)\r\nretval = rt2800_read_eeprom_efuse(rt2x00dev);\r\nelse\r\nretval = rt2x00usb_eeprom_read(rt2x00dev, rt2x00dev->eeprom,\r\nEEPROM_SIZE);\r\nreturn retval;\r\n}\r\nstatic int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nretval = rt2800_probe_hw(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nrt2x00dev->txstatus_timer.function = rt2800usb_tx_sta_fifo_timeout;\r\nINIT_WORK(&rt2x00dev->txdone_work, rt2800usb_work_txdone);\r\nreturn 0;\r\n}\r\nstatic void rt2800usb_queue_init(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nunsigned short txwi_size, rxwi_size;\r\nrt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nqueue->limit = 128;\r\nqueue->data_size = AGGREGATION_SIZE;\r\nqueue->desc_size = RXINFO_DESC_SIZE;\r\nqueue->winfo_size = rxwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_usb);\r\nbreak;\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nqueue->limit = 16;\r\nqueue->data_size = AGGREGATION_SIZE;\r\nqueue->desc_size = TXINFO_DESC_SIZE;\r\nqueue->winfo_size = txwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_usb);\r\nbreak;\r\ncase QID_BEACON:\r\nqueue->limit = 8;\r\nqueue->data_size = MGMT_FRAME_SIZE;\r\nqueue->desc_size = TXINFO_DESC_SIZE;\r\nqueue->winfo_size = txwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_usb);\r\nbreak;\r\ncase QID_ATIM:\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic int rt2800usb_probe(struct usb_interface *usb_intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn rt2x00usb_probe(usb_intf, &rt2800usb_ops);\r\n}
