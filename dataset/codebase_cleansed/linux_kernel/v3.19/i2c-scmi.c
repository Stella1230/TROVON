static int\r\nacpi_smbus_cmi_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,\r\nchar read_write, u8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nint result = 0;\r\nstruct acpi_smbus_cmi *smbus_cmi = adap->algo_data;\r\nunsigned char protocol;\r\nacpi_status status = 0;\r\nstruct acpi_object_list input;\r\nunion acpi_object mt_params[5];\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nunion acpi_object *pkg;\r\nchar *method;\r\nint len = 0;\r\ndev_dbg(&adap->dev, "access size: %d %s\n", size,\r\n(read_write) ? "READ" : "WRITE");\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nprotocol = ACPI_SMBUS_PRTCL_QUICK;\r\ncommand = 0;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nmt_params[3].type = ACPI_TYPE_INTEGER;\r\nmt_params[3].integer.value = 0;\r\nmt_params[4].type = ACPI_TYPE_INTEGER;\r\nmt_params[4].integer.value = 0;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nprotocol = ACPI_SMBUS_PRTCL_BYTE;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nmt_params[3].type = ACPI_TYPE_INTEGER;\r\nmt_params[3].integer.value = 0;\r\nmt_params[4].type = ACPI_TYPE_INTEGER;\r\nmt_params[4].integer.value = 0;\r\n} else {\r\ncommand = 0;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nprotocol = ACPI_SMBUS_PRTCL_BYTE_DATA;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nmt_params[3].type = ACPI_TYPE_INTEGER;\r\nmt_params[3].integer.value = 1;\r\nmt_params[4].type = ACPI_TYPE_INTEGER;\r\nmt_params[4].integer.value = data->byte;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nprotocol = ACPI_SMBUS_PRTCL_WORD_DATA;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nmt_params[3].type = ACPI_TYPE_INTEGER;\r\nmt_params[3].integer.value = 2;\r\nmt_params[4].type = ACPI_TYPE_INTEGER;\r\nmt_params[4].integer.value = data->word;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nprotocol = ACPI_SMBUS_PRTCL_BLOCK_DATA;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EINVAL;\r\nmt_params[3].type = ACPI_TYPE_INTEGER;\r\nmt_params[3].integer.value = len;\r\nmt_params[4].type = ACPI_TYPE_BUFFER;\r\nmt_params[4].buffer.pointer = data->block + 1;\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (read_write == I2C_SMBUS_READ) {\r\nprotocol |= ACPI_SMBUS_PRTCL_READ;\r\nmethod = smbus_cmi->methods->mt_sbr;\r\ninput.count = 3;\r\n} else {\r\nprotocol |= ACPI_SMBUS_PRTCL_WRITE;\r\nmethod = smbus_cmi->methods->mt_sbw;\r\ninput.count = 5;\r\n}\r\ninput.pointer = mt_params;\r\nmt_params[0].type = ACPI_TYPE_INTEGER;\r\nmt_params[0].integer.value = protocol;\r\nmt_params[1].type = ACPI_TYPE_INTEGER;\r\nmt_params[1].integer.value = addr;\r\nmt_params[2].type = ACPI_TYPE_INTEGER;\r\nmt_params[2].integer.value = command;\r\nstatus = acpi_evaluate_object(smbus_cmi->handle, method, &input,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Evaluating %s: %i", method, status));\r\nreturn -EIO;\r\n}\r\npkg = buffer.pointer;\r\nif (pkg && pkg->type == ACPI_TYPE_PACKAGE)\r\nobj = pkg->package.elements;\r\nelse {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nif (obj == NULL || obj->type != ACPI_TYPE_INTEGER) {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nresult = obj->integer.value;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s return status: %i\n",\r\nmethod, result));\r\nswitch (result) {\r\ncase ACPI_SMBUS_STATUS_OK:\r\nresult = 0;\r\nbreak;\r\ncase ACPI_SMBUS_STATUS_BUSY:\r\nresult = -EBUSY;\r\ngoto out;\r\ncase ACPI_SMBUS_STATUS_TIMEOUT:\r\nresult = -ETIMEDOUT;\r\ngoto out;\r\ncase ACPI_SMBUS_STATUS_DNAK:\r\nresult = -ENXIO;\r\ngoto out;\r\ndefault:\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nif (read_write == I2C_SMBUS_WRITE || size == I2C_SMBUS_QUICK)\r\ngoto out;\r\nobj = pkg->package.elements + 1;\r\nif (obj->type != ACPI_TYPE_INTEGER) {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nlen = obj->integer.value;\r\nobj = pkg->package.elements + 2;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (obj->type != ACPI_TYPE_INTEGER) {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nif (len == 2)\r\ndata->word = obj->integer.value;\r\nelse\r\ndata->byte = obj->integer.value;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (obj->type != ACPI_TYPE_BUFFER) {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\ndata->block[0] = len;\r\nmemcpy(data->block + 1, obj->buffer.pointer, len);\r\nbreak;\r\n}\r\nout:\r\nkfree(buffer.pointer);\r\ndev_dbg(&adap->dev, "Transaction status: %i\n", result);\r\nreturn result;\r\n}\r\nstatic u32 acpi_smbus_cmi_func(struct i2c_adapter *adapter)\r\n{\r\nstruct acpi_smbus_cmi *smbus_cmi = adapter->algo_data;\r\nu32 ret;\r\nret = smbus_cmi->cap_read | smbus_cmi->cap_write ?\r\nI2C_FUNC_SMBUS_QUICK : 0;\r\nret |= smbus_cmi->cap_read ?\r\n(I2C_FUNC_SMBUS_READ_BYTE |\r\nI2C_FUNC_SMBUS_READ_BYTE_DATA |\r\nI2C_FUNC_SMBUS_READ_WORD_DATA |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA) : 0;\r\nret |= smbus_cmi->cap_write ?\r\n(I2C_FUNC_SMBUS_WRITE_BYTE |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WRITE_WORD_DATA |\r\nI2C_FUNC_SMBUS_WRITE_BLOCK_DATA) : 0;\r\nreturn ret;\r\n}\r\nstatic int acpi_smbus_cmi_add_cap(struct acpi_smbus_cmi *smbus_cmi,\r\nconst char *name)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nif (!strcmp(name, smbus_cmi->methods->mt_info)) {\r\nstatus = acpi_evaluate_object(smbus_cmi->handle,\r\nsmbus_cmi->methods->mt_info,\r\nNULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Evaluating %s: %i",\r\nsmbus_cmi->methods->mt_info, status));\r\nreturn -EIO;\r\n}\r\nobj = buffer.pointer;\r\nif (obj && obj->type == ACPI_TYPE_PACKAGE)\r\nobj = obj->package.elements;\r\nelse {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nkfree(buffer.pointer);\r\nreturn -EIO;\r\n}\r\nif (obj->type != ACPI_TYPE_INTEGER) {\r\nACPI_ERROR((AE_INFO, "Invalid argument type"));\r\nkfree(buffer.pointer);\r\nreturn -EIO;\r\n} else\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "SMBus CMI Version %x"\r\n"\n", (int)obj->integer.value));\r\nkfree(buffer.pointer);\r\nsmbus_cmi->cap_info = 1;\r\n} else if (!strcmp(name, smbus_cmi->methods->mt_sbr))\r\nsmbus_cmi->cap_read = 1;\r\nelse if (!strcmp(name, smbus_cmi->methods->mt_sbw))\r\nsmbus_cmi->cap_write = 1;\r\nelse\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Unsupported CMI method: %s\n",\r\nname));\r\nreturn 0;\r\n}\r\nstatic acpi_status acpi_smbus_cmi_query_methods(acpi_handle handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nchar node_name[5];\r\nstruct acpi_buffer buffer = { sizeof(node_name), node_name };\r\nstruct acpi_smbus_cmi *smbus_cmi = context;\r\nacpi_status status;\r\nstatus = acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);\r\nif (ACPI_SUCCESS(status))\r\nacpi_smbus_cmi_add_cap(smbus_cmi, node_name);\r\nreturn AE_OK;\r\n}\r\nstatic int acpi_smbus_cmi_add(struct acpi_device *device)\r\n{\r\nstruct acpi_smbus_cmi *smbus_cmi;\r\nconst struct acpi_device_id *id;\r\nsmbus_cmi = kzalloc(sizeof(struct acpi_smbus_cmi), GFP_KERNEL);\r\nif (!smbus_cmi)\r\nreturn -ENOMEM;\r\nsmbus_cmi->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ACPI_SMBUS_HC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_SMBUS_HC_CLASS);\r\ndevice->driver_data = smbus_cmi;\r\nsmbus_cmi->cap_info = 0;\r\nsmbus_cmi->cap_read = 0;\r\nsmbus_cmi->cap_write = 0;\r\nfor (id = acpi_smbus_cmi_ids; id->id[0]; id++)\r\nif (!strcmp(id->id, acpi_device_hid(device)))\r\nsmbus_cmi->methods =\r\n(struct smbus_methods_t *) id->driver_data;\r\nacpi_walk_namespace(ACPI_TYPE_METHOD, smbus_cmi->handle, 1,\r\nacpi_smbus_cmi_query_methods, NULL, smbus_cmi, NULL);\r\nif (smbus_cmi->cap_info == 0)\r\ngoto err;\r\nsnprintf(smbus_cmi->adapter.name, sizeof(smbus_cmi->adapter.name),\r\n"SMBus CMI adapter %s",\r\nacpi_device_name(device));\r\nsmbus_cmi->adapter.owner = THIS_MODULE;\r\nsmbus_cmi->adapter.algo = &acpi_smbus_cmi_algorithm;\r\nsmbus_cmi->adapter.algo_data = smbus_cmi;\r\nsmbus_cmi->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nsmbus_cmi->adapter.dev.parent = &device->dev;\r\nif (i2c_add_adapter(&smbus_cmi->adapter)) {\r\ndev_err(&device->dev, "Couldn't register adapter!\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nkfree(smbus_cmi);\r\ndevice->driver_data = NULL;\r\nreturn -EIO;\r\n}\r\nstatic int acpi_smbus_cmi_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_smbus_cmi *smbus_cmi = acpi_driver_data(device);\r\ni2c_del_adapter(&smbus_cmi->adapter);\r\nkfree(smbus_cmi);\r\ndevice->driver_data = NULL;\r\nreturn 0;\r\n}
