static inline void esb_unlock_registers(void)\r\n{\r\nwritew(ESB_UNLOCK1, ESB_RELOAD_REG);\r\nwritew(ESB_UNLOCK2, ESB_RELOAD_REG);\r\n}\r\nstatic int esb_timer_start(void)\r\n{\r\nu8 val;\r\nspin_lock(&esb_lock);\r\nesb_unlock_registers();\r\nwritew(ESB_WDT_RELOAD, ESB_RELOAD_REG);\r\nval = ESB_WDT_ENABLE | (nowayout ? ESB_WDT_LOCK : 0x00);\r\npci_write_config_byte(esb_pci, ESB_LOCK_REG, val);\r\nspin_unlock(&esb_lock);\r\nreturn 0;\r\n}\r\nstatic int esb_timer_stop(void)\r\n{\r\nu8 val;\r\nspin_lock(&esb_lock);\r\nesb_unlock_registers();\r\nwritew(ESB_WDT_RELOAD, ESB_RELOAD_REG);\r\npci_write_config_byte(esb_pci, ESB_LOCK_REG, 0x0);\r\npci_read_config_byte(esb_pci, ESB_LOCK_REG, &val);\r\nspin_unlock(&esb_lock);\r\nreturn val & ESB_WDT_ENABLE;\r\n}\r\nstatic void esb_timer_keepalive(void)\r\n{\r\nspin_lock(&esb_lock);\r\nesb_unlock_registers();\r\nwritew(ESB_WDT_RELOAD, ESB_RELOAD_REG);\r\nspin_unlock(&esb_lock);\r\n}\r\nstatic int esb_timer_set_heartbeat(int time)\r\n{\r\nu32 val;\r\nif (time < 0x1 || time > (2 * 0x03ff))\r\nreturn -EINVAL;\r\nspin_lock(&esb_lock);\r\nval = time << 9;\r\nesb_unlock_registers();\r\nwritel(val, ESB_TIMER1_REG);\r\nesb_unlock_registers();\r\nwritel(val, ESB_TIMER2_REG);\r\nesb_unlock_registers();\r\nwritew(ESB_WDT_RELOAD, ESB_RELOAD_REG);\r\nheartbeat = time;\r\nspin_unlock(&esb_lock);\r\nreturn 0;\r\n}\r\nstatic int esb_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &timer_alive))\r\nreturn -EBUSY;\r\nesb_timer_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int esb_release(struct inode *inode, struct file *file)\r\n{\r\nif (esb_expect_close == 42)\r\nesb_timer_stop();\r\nelse {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nesb_timer_keepalive();\r\n}\r\nclear_bit(0, &timer_alive);\r\nesb_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t esb_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nesb_expect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nesb_expect_close = 42;\r\n}\r\n}\r\nesb_timer_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long esb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint new_options, retval = -EINVAL;\r\nint new_heartbeat;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT |\r\nWDIOF_KEEPALIVEPING |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 0,\r\n.identity = ESB_MODULE_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(triggered, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nesb_timer_stop();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nesb_timer_start();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nesb_timer_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\n{\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (esb_timer_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\nesb_timer_keepalive();\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic unsigned char esb_getdevice(struct pci_dev *pdev)\r\n{\r\nif (pci_enable_device(pdev)) {\r\npr_err("failed to enable device\n");\r\ngoto err_devput;\r\n}\r\nif (pci_request_region(pdev, 0, ESB_MODULE_NAME)) {\r\npr_err("failed to request region\n");\r\ngoto err_disable;\r\n}\r\nBASEADDR = pci_ioremap_bar(pdev, 0);\r\nif (BASEADDR == NULL) {\r\npr_err("failed to get BASEADDR\n");\r\ngoto err_release;\r\n}\r\nesb_pci = pdev;\r\nreturn 1;\r\nerr_release:\r\npci_release_region(pdev, 0);\r\nerr_disable:\r\npci_disable_device(pdev);\r\nerr_devput:\r\nreturn 0;\r\n}\r\nstatic void esb_initdevice(void)\r\n{\r\nu8 val1;\r\nu16 val2;\r\npci_write_config_word(esb_pci, ESB_CONFIG_REG, 0x0003);\r\npci_read_config_byte(esb_pci, ESB_LOCK_REG, &val1);\r\nif (val1 & ESB_WDT_LOCK)\r\npr_warn("nowayout already set\n");\r\npci_write_config_byte(esb_pci, ESB_LOCK_REG, 0x00);\r\nesb_unlock_registers();\r\nval2 = readw(ESB_RELOAD_REG);\r\nif (val2 & ESB_WDT_TIMEOUT)\r\ntriggered = WDIOF_CARDRESET;\r\nesb_unlock_registers();\r\nwritew((ESB_WDT_TIMEOUT | ESB_WDT_RELOAD), ESB_RELOAD_REG);\r\nesb_timer_set_heartbeat(heartbeat);\r\n}\r\nstatic int esb_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\ncards_found++;\r\nif (cards_found == 1)\r\npr_info("Intel 6300ESB WatchDog Timer Driver v%s\n",\r\nESB_VERSION);\r\nif (cards_found > 1) {\r\npr_err("This driver only supports 1 device\n");\r\nreturn -ENODEV;\r\n}\r\nif (!esb_getdevice(pdev) || esb_pci == NULL)\r\nreturn -ENODEV;\r\nif (heartbeat < 0x1 || heartbeat > 2 * 0x03ff) {\r\nheartbeat = WATCHDOG_HEARTBEAT;\r\npr_info("heartbeat value must be 1<heartbeat<2046, using %d\n",\r\nheartbeat);\r\n}\r\nesb_initdevice();\r\nret = misc_register(&esb_miscdev);\r\nif (ret != 0) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto err_unmap;\r\n}\r\npr_info("initialized (0x%p). heartbeat=%d sec (nowayout=%d)\n",\r\nBASEADDR, heartbeat, nowayout);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(BASEADDR);\r\npci_release_region(esb_pci, 0);\r\npci_disable_device(esb_pci);\r\nesb_pci = NULL;\r\nreturn ret;\r\n}\r\nstatic void esb_remove(struct pci_dev *pdev)\r\n{\r\nif (!nowayout)\r\nesb_timer_stop();\r\nmisc_deregister(&esb_miscdev);\r\niounmap(BASEADDR);\r\npci_release_region(esb_pci, 0);\r\npci_disable_device(esb_pci);\r\nesb_pci = NULL;\r\n}\r\nstatic void esb_shutdown(struct pci_dev *pdev)\r\n{\r\nesb_timer_stop();\r\n}
