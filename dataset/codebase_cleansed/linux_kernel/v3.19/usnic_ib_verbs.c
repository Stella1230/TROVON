static void usnic_ib_fw_string_to_u64(char *fw_ver_str, u64 *fw_ver)\r\n{\r\n*fw_ver = (u64) *fw_ver_str;\r\n}\r\nstatic int usnic_ib_fill_create_qp_resp(struct usnic_ib_qp_grp *qp_grp,\r\nstruct ib_udata *udata)\r\n{\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct usnic_ib_create_qp_resp resp;\r\nstruct pci_dev *pdev;\r\nstruct vnic_dev_bar *bar;\r\nstruct usnic_vnic_res_chunk *chunk;\r\nstruct usnic_ib_qp_grp_flow *default_flow;\r\nint i, err;\r\nmemset(&resp, 0, sizeof(resp));\r\nus_ibdev = qp_grp->vf->pf;\r\npdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);\r\nif (!pdev) {\r\nusnic_err("Failed to get pdev of qp_grp %d\n",\r\nqp_grp->grp_id);\r\nreturn -EFAULT;\r\n}\r\nbar = usnic_vnic_get_bar(qp_grp->vf->vnic, 0);\r\nif (!bar) {\r\nusnic_err("Failed to get bar0 of qp_grp %d vf %s",\r\nqp_grp->grp_id, pci_name(pdev));\r\nreturn -EFAULT;\r\n}\r\nresp.vfid = usnic_vnic_get_index(qp_grp->vf->vnic);\r\nresp.bar_bus_addr = bar->bus_addr;\r\nresp.bar_len = bar->len;\r\nchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\r\nif (IS_ERR_OR_NULL(chunk)) {\r\nusnic_err("Failed to get chunk %s for qp_grp %d with err %ld\n",\r\nusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),\r\nqp_grp->grp_id,\r\nPTR_ERR(chunk));\r\nreturn chunk ? PTR_ERR(chunk) : -ENOMEM;\r\n}\r\nWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_RQ);\r\nresp.rq_cnt = chunk->cnt;\r\nfor (i = 0; i < chunk->cnt; i++)\r\nresp.rq_idx[i] = chunk->res[i]->vnic_idx;\r\nchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_WQ);\r\nif (IS_ERR_OR_NULL(chunk)) {\r\nusnic_err("Failed to get chunk %s for qp_grp %d with err %ld\n",\r\nusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_WQ),\r\nqp_grp->grp_id,\r\nPTR_ERR(chunk));\r\nreturn chunk ? PTR_ERR(chunk) : -ENOMEM;\r\n}\r\nWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_WQ);\r\nresp.wq_cnt = chunk->cnt;\r\nfor (i = 0; i < chunk->cnt; i++)\r\nresp.wq_idx[i] = chunk->res[i]->vnic_idx;\r\nchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_CQ);\r\nif (IS_ERR_OR_NULL(chunk)) {\r\nusnic_err("Failed to get chunk %s for qp_grp %d with err %ld\n",\r\nusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_CQ),\r\nqp_grp->grp_id,\r\nPTR_ERR(chunk));\r\nreturn chunk ? PTR_ERR(chunk) : -ENOMEM;\r\n}\r\nWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_CQ);\r\nresp.cq_cnt = chunk->cnt;\r\nfor (i = 0; i < chunk->cnt; i++)\r\nresp.cq_idx[i] = chunk->res[i]->vnic_idx;\r\ndefault_flow = list_first_entry(&qp_grp->flows_lst,\r\nstruct usnic_ib_qp_grp_flow, link);\r\nresp.transport = default_flow->trans_type;\r\nerr = ib_copy_to_udata(udata, &resp, sizeof(resp));\r\nif (err) {\r\nusnic_err("Failed to copy udata for %s", us_ibdev->ib_dev.name);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct usnic_ib_qp_grp*\r\nfind_free_vf_and_create_qp_grp(struct usnic_ib_dev *us_ibdev,\r\nstruct usnic_ib_pd *pd,\r\nstruct usnic_transport_spec *trans_spec,\r\nstruct usnic_vnic_res_spec *res_spec)\r\n{\r\nstruct usnic_ib_vf *vf;\r\nstruct usnic_vnic *vnic;\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nstruct device *dev, **dev_list;\r\nint i, found = 0;\r\nBUG_ON(!mutex_is_locked(&us_ibdev->usdev_lock));\r\nif (list_empty(&us_ibdev->vf_dev_list)) {\r\nusnic_info("No vfs to allocate\n");\r\nreturn NULL;\r\n}\r\nif (usnic_ib_share_vf) {\r\ndev_list = usnic_uiom_get_dev_list(pd->umem_pd);\r\nfor (i = 0; dev_list[i]; i++) {\r\ndev = dev_list[i];\r\nvf = pci_get_drvdata(to_pci_dev(dev));\r\nspin_lock(&vf->lock);\r\nvnic = vf->vnic;\r\nif (!usnic_vnic_check_room(vnic, res_spec)) {\r\nusnic_dbg("Found used vnic %s from %s\n",\r\nus_ibdev->ib_dev.name,\r\npci_name(usnic_vnic_get_pdev(\r\nvnic)));\r\nfound = 1;\r\nbreak;\r\n}\r\nspin_unlock(&vf->lock);\r\n}\r\nusnic_uiom_free_dev_list(dev_list);\r\n}\r\nif (!found) {\r\nlist_for_each_entry(vf, &us_ibdev->vf_dev_list, link) {\r\nspin_lock(&vf->lock);\r\nvnic = vf->vnic;\r\nif (vf->qp_grp_ref_cnt == 0 &&\r\nusnic_vnic_check_room(vnic, res_spec) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\nspin_unlock(&vf->lock);\r\n}\r\n}\r\nif (!found) {\r\nusnic_info("No free qp grp found on %s\n",\r\nus_ibdev->ib_dev.name);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nqp_grp = usnic_ib_qp_grp_create(us_ibdev->ufdev, vf, pd, res_spec,\r\ntrans_spec);\r\nspin_unlock(&vf->lock);\r\nif (IS_ERR_OR_NULL(qp_grp)) {\r\nusnic_err("Failed to allocate qp_grp\n");\r\nreturn ERR_PTR(qp_grp ? PTR_ERR(qp_grp) : -ENOMEM);\r\n}\r\nreturn qp_grp;\r\n}\r\nstatic void qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nstruct usnic_ib_vf *vf = qp_grp->vf;\r\nWARN_ON(qp_grp->state != IB_QPS_RESET);\r\nspin_lock(&vf->lock);\r\nusnic_ib_qp_grp_destroy(qp_grp);\r\nspin_unlock(&vf->lock);\r\n}\r\nstatic void eth_speed_to_ib_speed(int speed, u8 *active_speed,\r\nu8 *active_width)\r\n{\r\nif (speed <= 10000) {\r\n*active_width = IB_WIDTH_1X;\r\n*active_speed = IB_SPEED_FDR10;\r\n} else if (speed <= 20000) {\r\n*active_width = IB_WIDTH_4X;\r\n*active_speed = IB_SPEED_DDR;\r\n} else if (speed <= 30000) {\r\n*active_width = IB_WIDTH_4X;\r\n*active_speed = IB_SPEED_QDR;\r\n} else if (speed <= 40000) {\r\n*active_width = IB_WIDTH_4X;\r\n*active_speed = IB_SPEED_FDR10;\r\n} else {\r\n*active_width = IB_WIDTH_4X;\r\n*active_speed = IB_SPEED_EDR;\r\n}\r\n}\r\nstatic int create_qp_validate_user_data(struct usnic_ib_create_qp_cmd cmd)\r\n{\r\nif (cmd.spec.trans_type <= USNIC_TRANSPORT_UNKNOWN ||\r\ncmd.spec.trans_type >= USNIC_TRANSPORT_MAX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nenum rdma_link_layer usnic_ib_port_link_layer(struct ib_device *device,\r\nu8 port_num)\r\n{\r\nreturn IB_LINK_LAYER_ETHERNET;\r\n}\r\nint usnic_ib_query_device(struct ib_device *ibdev,\r\nstruct ib_device_attr *props)\r\n{\r\nstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\r\nunion ib_gid gid;\r\nstruct ethtool_drvinfo info;\r\nstruct ethtool_cmd cmd;\r\nint qp_per_vf;\r\nusnic_dbg("\n");\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nus_ibdev->netdev->ethtool_ops->get_drvinfo(us_ibdev->netdev, &info);\r\nus_ibdev->netdev->ethtool_ops->get_settings(us_ibdev->netdev, &cmd);\r\nmemset(props, 0, sizeof(*props));\r\nusnic_mac_ip_to_gid(us_ibdev->ufdev->mac, us_ibdev->ufdev->inaddr,\r\n&gid.raw[0]);\r\nmemcpy(&props->sys_image_guid, &gid.global.interface_id,\r\nsizeof(gid.global.interface_id));\r\nusnic_ib_fw_string_to_u64(&info.fw_version[0], &props->fw_ver);\r\nprops->max_mr_size = USNIC_UIOM_MAX_MR_SIZE;\r\nprops->page_size_cap = USNIC_UIOM_PAGE_SIZE;\r\nprops->vendor_id = PCI_VENDOR_ID_CISCO;\r\nprops->vendor_part_id = PCI_DEVICE_ID_CISCO_VIC_USPACE_NIC;\r\nprops->hw_ver = us_ibdev->pdev->subsystem_device;\r\nqp_per_vf = max(us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_WQ],\r\nus_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_RQ]);\r\nprops->max_qp = qp_per_vf *\r\natomic_read(&us_ibdev->vf_cnt.refcount);\r\nprops->device_cap_flags = IB_DEVICE_PORT_ACTIVE_EVENT |\r\nIB_DEVICE_SYS_IMAGE_GUID | IB_DEVICE_BLOCK_MULTICAST_LOOPBACK;\r\nprops->max_cq = us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_CQ] *\r\natomic_read(&us_ibdev->vf_cnt.refcount);\r\nprops->max_pd = USNIC_UIOM_MAX_PD_CNT;\r\nprops->max_mr = USNIC_UIOM_MAX_MR_CNT;\r\nprops->local_ca_ack_delay = 0;\r\nprops->max_pkeys = 0;\r\nprops->atomic_cap = IB_ATOMIC_NONE;\r\nprops->masked_atomic_cap = props->atomic_cap;\r\nprops->max_qp_rd_atom = 0;\r\nprops->max_qp_init_rd_atom = 0;\r\nprops->max_res_rd_atom = 0;\r\nprops->max_srq = 0;\r\nprops->max_srq_wr = 0;\r\nprops->max_srq_sge = 0;\r\nprops->max_fast_reg_page_list_len = 0;\r\nprops->max_mcast_grp = 0;\r\nprops->max_mcast_qp_attach = 0;\r\nprops->max_total_mcast_qp_attach = 0;\r\nprops->max_map_per_fmr = 0;\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn 0;\r\n}\r\nint usnic_ib_query_port(struct ib_device *ibdev, u8 port,\r\nstruct ib_port_attr *props)\r\n{\r\nstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\r\nstruct ethtool_cmd cmd;\r\nusnic_dbg("\n");\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nus_ibdev->netdev->ethtool_ops->get_settings(us_ibdev->netdev, &cmd);\r\nmemset(props, 0, sizeof(*props));\r\nprops->lid = 0;\r\nprops->lmc = 1;\r\nprops->sm_lid = 0;\r\nprops->sm_sl = 0;\r\nif (!us_ibdev->ufdev->link_up) {\r\nprops->state = IB_PORT_DOWN;\r\nprops->phys_state = 3;\r\n} else if (!us_ibdev->ufdev->inaddr) {\r\nprops->state = IB_PORT_INIT;\r\nprops->phys_state = 4;\r\n} else {\r\nprops->state = IB_PORT_ACTIVE;\r\nprops->phys_state = 5;\r\n}\r\nprops->port_cap_flags = 0;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->bad_pkey_cntr = 0;\r\nprops->qkey_viol_cntr = 0;\r\neth_speed_to_ib_speed(cmd.speed, &props->active_speed,\r\n&props->active_width);\r\nprops->max_mtu = IB_MTU_4096;\r\nprops->active_mtu = iboe_get_mtu(us_ibdev->ufdev->mtu);\r\nprops->max_msg_sz = us_ibdev->ufdev->mtu;\r\nprops->max_vl_num = 1;\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn 0;\r\n}\r\nint usnic_ib_query_qp(struct ib_qp *qp, struct ib_qp_attr *qp_attr,\r\nint qp_attr_mask,\r\nstruct ib_qp_init_attr *qp_init_attr)\r\n{\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nstruct usnic_ib_vf *vf;\r\nint err;\r\nusnic_dbg("\n");\r\nmemset(qp_attr, 0, sizeof(*qp_attr));\r\nmemset(qp_init_attr, 0, sizeof(*qp_init_attr));\r\nqp_grp = to_uqp_grp(qp);\r\nvf = qp_grp->vf;\r\nmutex_lock(&vf->pf->usdev_lock);\r\nusnic_dbg("\n");\r\nqp_attr->qp_state = qp_grp->state;\r\nqp_attr->cur_qp_state = qp_grp->state;\r\nswitch (qp_grp->ibqp.qp_type) {\r\ncase IB_QPT_UD:\r\nqp_attr->qkey = 0;\r\nbreak;\r\ndefault:\r\nusnic_err("Unexpected qp_type %d\n", qp_grp->ibqp.qp_type);\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nmutex_unlock(&vf->pf->usdev_lock);\r\nreturn 0;\r\nerr_out:\r\nmutex_unlock(&vf->pf->usdev_lock);\r\nreturn err;\r\n}\r\nint usnic_ib_query_gid(struct ib_device *ibdev, u8 port, int index,\r\nunion ib_gid *gid)\r\n{\r\nstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\r\nusnic_dbg("\n");\r\nif (index > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\r\nusnic_mac_ip_to_gid(us_ibdev->ufdev->mac, us_ibdev->ufdev->inaddr,\r\n&gid->raw[0]);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn 0;\r\n}\r\nint usnic_ib_query_pkey(struct ib_device *ibdev, u8 port, u16 index,\r\nu16 *pkey)\r\n{\r\nif (index > 1)\r\nreturn -EINVAL;\r\n*pkey = 0xffff;\r\nreturn 0;\r\n}\r\nstruct ib_pd *usnic_ib_alloc_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct usnic_ib_pd *pd;\r\nvoid *umem_pd;\r\nusnic_dbg("\n");\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn ERR_PTR(-ENOMEM);\r\numem_pd = pd->umem_pd = usnic_uiom_alloc_pd();\r\nif (IS_ERR_OR_NULL(umem_pd)) {\r\nkfree(pd);\r\nreturn ERR_PTR(umem_pd ? PTR_ERR(umem_pd) : -ENOMEM);\r\n}\r\nusnic_info("domain 0x%p allocated for context 0x%p and device %s\n",\r\npd, context, ibdev->name);\r\nreturn &pd->ibpd;\r\n}\r\nint usnic_ib_dealloc_pd(struct ib_pd *pd)\r\n{\r\nusnic_info("freeing domain 0x%p\n", pd);\r\nusnic_uiom_dealloc_pd((to_upd(pd))->umem_pd);\r\nkfree(pd);\r\nreturn 0;\r\n}\r\nstruct ib_qp *usnic_ib_create_qp(struct ib_pd *pd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nint err;\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nstruct usnic_ib_ucontext *ucontext;\r\nint cq_cnt;\r\nstruct usnic_vnic_res_spec res_spec;\r\nstruct usnic_ib_create_qp_cmd cmd;\r\nstruct usnic_transport_spec trans_spec;\r\nusnic_dbg("\n");\r\nucontext = to_uucontext(pd->uobject->context);\r\nus_ibdev = to_usdev(pd->device);\r\nif (init_attr->create_flags)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = ib_copy_from_udata(&cmd, udata, sizeof(cmd));\r\nif (err) {\r\nusnic_err("%s: cannot copy udata for create_qp\n",\r\nus_ibdev->ib_dev.name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nerr = create_qp_validate_user_data(cmd);\r\nif (err) {\r\nusnic_err("%s: Failed to validate user data\n",\r\nus_ibdev->ib_dev.name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (init_attr->qp_type != IB_QPT_UD) {\r\nusnic_err("%s asked to make a non-UD QP: %d\n",\r\nus_ibdev->ib_dev.name, init_attr->qp_type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntrans_spec = cmd.spec;\r\nmutex_lock(&us_ibdev->usdev_lock);\r\ncq_cnt = (init_attr->send_cq == init_attr->recv_cq) ? 1 : 2;\r\nres_spec = min_transport_spec[trans_spec.trans_type];\r\nusnic_vnic_res_spec_update(&res_spec, USNIC_VNIC_RES_TYPE_CQ, cq_cnt);\r\nqp_grp = find_free_vf_and_create_qp_grp(us_ibdev, to_upd(pd),\r\n&trans_spec,\r\n&res_spec);\r\nif (IS_ERR_OR_NULL(qp_grp)) {\r\nerr = qp_grp ? PTR_ERR(qp_grp) : -ENOMEM;\r\ngoto out_release_mutex;\r\n}\r\nerr = usnic_ib_fill_create_qp_resp(qp_grp, udata);\r\nif (err) {\r\nerr = -EBUSY;\r\ngoto out_release_qp_grp;\r\n}\r\nqp_grp->ctx = ucontext;\r\nlist_add_tail(&qp_grp->link, &ucontext->qp_grp_list);\r\nusnic_ib_log_vf(qp_grp->vf);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn &qp_grp->ibqp;\r\nout_release_qp_grp:\r\nqp_grp_destroy(qp_grp);\r\nout_release_mutex:\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nint usnic_ib_destroy_qp(struct ib_qp *qp)\r\n{\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nstruct usnic_ib_vf *vf;\r\nusnic_dbg("\n");\r\nqp_grp = to_uqp_grp(qp);\r\nvf = qp_grp->vf;\r\nmutex_lock(&vf->pf->usdev_lock);\r\nif (usnic_ib_qp_grp_modify(qp_grp, IB_QPS_RESET, NULL)) {\r\nusnic_err("Failed to move qp grp %u to reset\n",\r\nqp_grp->grp_id);\r\n}\r\nlist_del(&qp_grp->link);\r\nqp_grp_destroy(qp_grp);\r\nmutex_unlock(&vf->pf->usdev_lock);\r\nreturn 0;\r\n}\r\nint usnic_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nint status;\r\nusnic_dbg("\n");\r\nqp_grp = to_uqp_grp(ibqp);\r\nmutex_lock(&qp_grp->vf->pf->usdev_lock);\r\nif ((attr_mask & IB_QP_STATE) && attr->qp_state == IB_QPS_INIT) {\r\nstatus = usnic_ib_qp_grp_modify(qp_grp, IB_QPS_INIT, NULL);\r\n} else if ((attr_mask & IB_QP_STATE) && attr->qp_state == IB_QPS_RTR) {\r\nstatus = usnic_ib_qp_grp_modify(qp_grp, IB_QPS_RTR, NULL);\r\n} else if ((attr_mask & IB_QP_STATE) && attr->qp_state == IB_QPS_RTS) {\r\nstatus = usnic_ib_qp_grp_modify(qp_grp, IB_QPS_RTS, NULL);\r\n} else {\r\nusnic_err("Unexpected combination mask: %u state: %u\n",\r\nattr_mask & IB_QP_STATE, attr->qp_state);\r\nstatus = -EINVAL;\r\n}\r\nmutex_unlock(&qp_grp->vf->pf->usdev_lock);\r\nreturn status;\r\n}\r\nstruct ib_cq *usnic_ib_create_cq(struct ib_device *ibdev, int entries,\r\nint vector, struct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct ib_cq *cq;\r\nusnic_dbg("\n");\r\ncq = kzalloc(sizeof(*cq), GFP_KERNEL);\r\nif (!cq)\r\nreturn ERR_PTR(-EBUSY);\r\nreturn cq;\r\n}\r\nint usnic_ib_destroy_cq(struct ib_cq *cq)\r\n{\r\nusnic_dbg("\n");\r\nkfree(cq);\r\nreturn 0;\r\n}\r\nstruct ib_mr *usnic_ib_reg_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt_addr, int access_flags,\r\nstruct ib_udata *udata)\r\n{\r\nstruct usnic_ib_mr *mr;\r\nint err;\r\nusnic_dbg("start 0x%llx va 0x%llx length 0x%llx\n", start,\r\nvirt_addr, length);\r\nmr = kzalloc(sizeof(*mr), GFP_KERNEL);\r\nif (IS_ERR_OR_NULL(mr))\r\nreturn ERR_PTR(mr ? PTR_ERR(mr) : -ENOMEM);\r\nmr->umem = usnic_uiom_reg_get(to_upd(pd)->umem_pd, start, length,\r\naccess_flags, 0);\r\nif (IS_ERR_OR_NULL(mr->umem)) {\r\nerr = mr->umem ? PTR_ERR(mr->umem) : -EFAULT;\r\ngoto err_free;\r\n}\r\nmr->ibmr.lkey = mr->ibmr.rkey = 0;\r\nreturn &mr->ibmr;\r\nerr_free:\r\nkfree(mr);\r\nreturn ERR_PTR(err);\r\n}\r\nint usnic_ib_dereg_mr(struct ib_mr *ibmr)\r\n{\r\nstruct usnic_ib_mr *mr = to_umr(ibmr);\r\nusnic_dbg("va 0x%lx length 0x%zx\n", mr->umem->va, mr->umem->length);\r\nusnic_uiom_reg_release(mr->umem, ibmr->pd->uobject->context->closing);\r\nkfree(mr);\r\nreturn 0;\r\n}\r\nstruct ib_ucontext *usnic_ib_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct usnic_ib_ucontext *context;\r\nstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\r\nusnic_dbg("\n");\r\ncontext = kmalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&context->qp_grp_list);\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nlist_add_tail(&context->link, &us_ibdev->ctx_list);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn &context->ibucontext;\r\n}\r\nint usnic_ib_dealloc_ucontext(struct ib_ucontext *ibcontext)\r\n{\r\nstruct usnic_ib_ucontext *context = to_uucontext(ibcontext);\r\nstruct usnic_ib_dev *us_ibdev = to_usdev(ibcontext->device);\r\nusnic_dbg("\n");\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nBUG_ON(!list_empty(&context->qp_grp_list));\r\nlist_del(&context->link);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nkfree(context);\r\nreturn 0;\r\n}\r\nint usnic_ib_mmap(struct ib_ucontext *context,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct usnic_ib_ucontext *uctx = to_ucontext(context);\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nstruct usnic_ib_vf *vf;\r\nstruct vnic_dev_bar *bar;\r\ndma_addr_t bus_addr;\r\nunsigned int len;\r\nunsigned int vfid;\r\nusnic_dbg("\n");\r\nus_ibdev = to_usdev(context->device);\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nvfid = vma->vm_pgoff;\r\nusnic_dbg("Page Offset %lu PAGE_SHIFT %u VFID %u\n",\r\nvma->vm_pgoff, PAGE_SHIFT, vfid);\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nlist_for_each_entry(qp_grp, &uctx->qp_grp_list, link) {\r\nvf = qp_grp->vf;\r\nif (usnic_vnic_get_index(vf->vnic) == vfid) {\r\nbar = usnic_vnic_get_bar(vf->vnic, 0);\r\nif ((vma->vm_end - vma->vm_start) != bar->len) {\r\nusnic_err("Bar0 Len %lu - Request map %lu\n",\r\nbar->len,\r\nvma->vm_end - vma->vm_start);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn -EINVAL;\r\n}\r\nbus_addr = bar->bus_addr;\r\nlen = bar->len;\r\nusnic_dbg("bus: %pa vaddr: %p size: %ld\n",\r\n&bus_addr, bar->vaddr, bar->len);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn remap_pfn_range(vma,\r\nvma->vm_start,\r\nbus_addr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n}\r\n}\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nusnic_err("No VF %u found\n", vfid);\r\nreturn -EINVAL;\r\n}\r\nstruct ib_ah *usnic_ib_create_ah(struct ib_pd *pd,\r\nstruct ib_ah_attr *ah_attr)\r\n{\r\nusnic_dbg("\n");\r\nreturn ERR_PTR(-EPERM);\r\n}\r\nint usnic_ib_destroy_ah(struct ib_ah *ah)\r\n{\r\nusnic_dbg("\n");\r\nreturn -EINVAL;\r\n}\r\nint usnic_ib_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,\r\nstruct ib_send_wr **bad_wr)\r\n{\r\nusnic_dbg("\n");\r\nreturn -EINVAL;\r\n}\r\nint usnic_ib_post_recv(struct ib_qp *ibqp, struct ib_recv_wr *wr,\r\nstruct ib_recv_wr **bad_wr)\r\n{\r\nusnic_dbg("\n");\r\nreturn -EINVAL;\r\n}\r\nint usnic_ib_poll_cq(struct ib_cq *ibcq, int num_entries,\r\nstruct ib_wc *wc)\r\n{\r\nusnic_dbg("\n");\r\nreturn -EINVAL;\r\n}\r\nint usnic_ib_req_notify_cq(struct ib_cq *cq,\r\nenum ib_cq_notify_flags flags)\r\n{\r\nusnic_dbg("\n");\r\nreturn -EINVAL;\r\n}\r\nstruct ib_mr *usnic_ib_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nusnic_dbg("\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}
