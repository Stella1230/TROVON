static bool esas2r_initmem_alloc(struct esas2r_adapter *a,\r\nstruct esas2r_mem_desc *mem_desc,\r\nu32 align)\r\n{\r\nmem_desc->esas2r_param = mem_desc->size + align;\r\nmem_desc->virt_addr = NULL;\r\nmem_desc->phys_addr = 0;\r\nmem_desc->esas2r_data = dma_alloc_coherent(&a->pcid->dev,\r\n(size_t)mem_desc->\r\nesas2r_param,\r\n(dma_addr_t *)&mem_desc->\r\nphys_addr,\r\nGFP_KERNEL);\r\nif (mem_desc->esas2r_data == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate %lu bytes of consistent memory!",\r\n(long\r\nunsigned\r\nint)mem_desc->esas2r_param);\r\nreturn false;\r\n}\r\nmem_desc->virt_addr = PTR_ALIGN(mem_desc->esas2r_data, align);\r\nmem_desc->phys_addr = ALIGN(mem_desc->phys_addr, align);\r\nmemset(mem_desc->virt_addr, 0, mem_desc->size);\r\nreturn true;\r\n}\r\nstatic void esas2r_initmem_free(struct esas2r_adapter *a,\r\nstruct esas2r_mem_desc *mem_desc)\r\n{\r\nif (mem_desc->virt_addr == NULL)\r\nreturn;\r\nif (mem_desc->phys_addr) {\r\nint unalign = ((u8 *)mem_desc->virt_addr) -\r\n((u8 *)mem_desc->esas2r_data);\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)mem_desc->esas2r_param,\r\nmem_desc->esas2r_data,\r\n(dma_addr_t)(mem_desc->phys_addr - unalign));\r\n} else {\r\nkfree(mem_desc->esas2r_data);\r\n}\r\nmem_desc->virt_addr = NULL;\r\n}\r\nstatic bool alloc_vda_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_mem_desc *memdesc = kzalloc(\r\nsizeof(struct esas2r_mem_desc), GFP_KERNEL);\r\nif (memdesc == NULL) {\r\nesas2r_hdebug("could not alloc mem for vda request memdesc\n");\r\nreturn false;\r\n}\r\nmemdesc->size = sizeof(union atto_vda_req) +\r\nESAS2R_DATA_BUF_LEN;\r\nif (!esas2r_initmem_alloc(a, memdesc, 256)) {\r\nesas2r_hdebug("could not alloc mem for vda request\n");\r\nkfree(memdesc);\r\nreturn false;\r\n}\r\na->num_vrqs++;\r\nlist_add(&memdesc->next_desc, &a->vrq_mds_head);\r\nrq->vrq_md = memdesc;\r\nrq->vrq = (union atto_vda_req *)memdesc->virt_addr;\r\nrq->vrq->scsi.handle = a->num_vrqs;\r\nreturn true;\r\n}\r\nstatic void esas2r_unmap_regions(struct esas2r_adapter *a)\r\n{\r\nif (a->regs)\r\niounmap((void __iomem *)a->regs);\r\na->regs = NULL;\r\npci_release_region(a->pcid, 2);\r\nif (a->data_window)\r\niounmap((void __iomem *)a->data_window);\r\na->data_window = NULL;\r\npci_release_region(a->pcid, 0);\r\n}\r\nstatic int esas2r_map_regions(struct esas2r_adapter *a)\r\n{\r\nint error;\r\na->regs = NULL;\r\na->data_window = NULL;\r\nerror = pci_request_region(a->pcid, 2, a->name);\r\nif (error != 0) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"pci_request_region(2) failed, error %d",\r\nerror);\r\nreturn error;\r\n}\r\na->regs = (void __force *)ioremap(pci_resource_start(a->pcid, 2),\r\npci_resource_len(a->pcid, 2));\r\nif (a->regs == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"ioremap failed for regs mem region\n");\r\npci_release_region(a->pcid, 2);\r\nreturn -EFAULT;\r\n}\r\nerror = pci_request_region(a->pcid, 0, a->name);\r\nif (error != 0) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"pci_request_region(2) failed, error %d",\r\nerror);\r\nesas2r_unmap_regions(a);\r\nreturn error;\r\n}\r\na->data_window = (void __force *)ioremap(pci_resource_start(a->pcid,\r\n0),\r\npci_resource_len(a->pcid, 0));\r\nif (a->data_window == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"ioremap failed for data_window mem region\n");\r\nesas2r_unmap_regions(a);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void esas2r_setup_interrupts(struct esas2r_adapter *a, int intr_mode)\r\n{\r\nint i;\r\nswitch (intr_mode) {\r\ncase INTR_MODE_LEGACY:\r\nuse_legacy_interrupts:\r\na->intr_mode = INTR_MODE_LEGACY;\r\nbreak;\r\ncase INTR_MODE_MSI:\r\ni = pci_enable_msi(a->pcid);\r\nif (i != 0) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"failed to enable MSI for adapter %d, "\r\n"falling back to legacy interrupts "\r\n"(err=%d)", a->index,\r\ni);\r\ngoto use_legacy_interrupts;\r\n}\r\na->intr_mode = INTR_MODE_MSI;\r\nset_bit(AF2_MSI_ENABLED, &a->flags2);\r\nbreak;\r\ndefault:\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"unknown interrupt_mode %d requested, "\r\n"falling back to legacy interrupt",\r\ninterrupt_mode);\r\ngoto use_legacy_interrupts;\r\n}\r\n}\r\nstatic void esas2r_claim_interrupts(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags = 0;\r\nif (a->intr_mode == INTR_MODE_LEGACY)\r\nflags |= IRQF_SHARED;\r\nesas2r_log(ESAS2R_LOG_INFO,\r\n"esas2r_claim_interrupts irq=%d (%p, %s, %x)",\r\na->pcid->irq, a, a->name, flags);\r\nif (request_irq(a->pcid->irq,\r\n(a->intr_mode ==\r\nINTR_MODE_LEGACY) ? esas2r_interrupt :\r\nesas2r_msi_interrupt,\r\nflags,\r\na->name,\r\na)) {\r\nesas2r_log(ESAS2R_LOG_CRIT, "unable to request IRQ %02X",\r\na->pcid->irq);\r\nreturn;\r\n}\r\nset_bit(AF2_IRQ_CLAIMED, &a->flags2);\r\nesas2r_log(ESAS2R_LOG_INFO,\r\n"claimed IRQ %d flags: 0x%lx",\r\na->pcid->irq, flags);\r\n}\r\nint esas2r_init_adapter(struct Scsi_Host *host, struct pci_dev *pcid,\r\nint index)\r\n{\r\nstruct esas2r_adapter *a;\r\nu64 bus_addr = 0;\r\nint i;\r\nvoid *next_uncached;\r\nstruct esas2r_request *first_request, *last_request;\r\nif (index >= MAX_ADAPTERS) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"tried to init invalid adapter index %u!",\r\nindex);\r\nreturn 0;\r\n}\r\nif (esas2r_adapters[index]) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"tried to init existing adapter index %u!",\r\nindex);\r\nreturn 0;\r\n}\r\na = (struct esas2r_adapter *)host->hostdata;\r\nmemset(a, 0, sizeof(struct esas2r_adapter));\r\na->pcid = pcid;\r\na->host = host;\r\nif (sizeof(dma_addr_t) > 4) {\r\nconst uint64_t required_mask = dma_get_required_mask\r\n(&pcid->dev);\r\nif (required_mask > DMA_BIT_MASK(32)\r\n&& !pci_set_dma_mask(pcid, DMA_BIT_MASK(64))\r\n&& !pci_set_consistent_dma_mask(pcid,\r\nDMA_BIT_MASK(64))) {\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"64-bit PCI addressing enabled\n");\r\n} else if (!pci_set_dma_mask(pcid, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pcid,\r\nDMA_BIT_MASK(32))) {\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"32-bit PCI addressing enabled\n");\r\n} else {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to set DMA mask");\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\n} else {\r\nif (!pci_set_dma_mask(pcid, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pcid,\r\nDMA_BIT_MASK(32))) {\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"32-bit PCI addressing enabled\n");\r\n} else {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to set DMA mask");\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\n}\r\nesas2r_adapters[index] = a;\r\nsprintf(a->name, ESAS2R_DRVR_NAME "_%02d", index);\r\nesas2r_debug("new adapter %p, name %s", a, a->name);\r\nspin_lock_init(&a->request_lock);\r\nspin_lock_init(&a->fw_event_lock);\r\nsema_init(&a->fm_api_semaphore, 1);\r\nsema_init(&a->fs_api_semaphore, 1);\r\nsema_init(&a->nvram_semaphore, 1);\r\nesas2r_fw_event_off(a);\r\nsnprintf(a->fw_event_q_name, ESAS2R_KOBJ_NAME_LEN, "esas2r/%d",\r\na->index);\r\na->fw_event_q = create_singlethread_workqueue(a->fw_event_q_name);\r\ninit_waitqueue_head(&a->buffered_ioctl_waiter);\r\ninit_waitqueue_head(&a->nvram_waiter);\r\ninit_waitqueue_head(&a->fm_api_waiter);\r\ninit_waitqueue_head(&a->fs_api_waiter);\r\ninit_waitqueue_head(&a->vda_waiter);\r\nINIT_LIST_HEAD(&a->general_req.req_list);\r\nINIT_LIST_HEAD(&a->active_list);\r\nINIT_LIST_HEAD(&a->defer_list);\r\nINIT_LIST_HEAD(&a->free_sg_list_head);\r\nINIT_LIST_HEAD(&a->avail_request);\r\nINIT_LIST_HEAD(&a->vrq_mds_head);\r\nINIT_LIST_HEAD(&a->fw_event_list);\r\nfirst_request = (struct esas2r_request *)((u8 *)(a + 1));\r\nfor (last_request = first_request, i = 1; i < num_requests;\r\nlast_request++, i++) {\r\nINIT_LIST_HEAD(&last_request->req_list);\r\nlist_add_tail(&last_request->comp_list, &a->avail_request);\r\nif (!alloc_vda_req(a, last_request)) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate a VDA request!");\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\n}\r\nesas2r_debug("requests: %p to %p (%d, %d)", first_request,\r\nlast_request,\r\nsizeof(*first_request),\r\nnum_requests);\r\nif (esas2r_map_regions(a) != 0) {\r\nesas2r_log(ESAS2R_LOG_CRIT, "could not map PCI regions!");\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\na->index = index;\r\natomic_inc(&a->dis_ints_cnt);\r\natomic_inc(&a->disable_cnt);\r\nset_bit(AF_CHPRST_PENDING, &a->flags);\r\nset_bit(AF_DISC_PENDING, &a->flags);\r\nset_bit(AF_FIRST_INIT, &a->flags);\r\nset_bit(AF_LEGACY_SGE_MODE, &a->flags);\r\na->init_msg = ESAS2R_INIT_MSG_START;\r\na->max_vdareq_size = 128;\r\na->build_sgl = esas2r_build_sg_list_sge;\r\nesas2r_setup_interrupts(a, interrupt_mode);\r\na->uncached_size = esas2r_get_uncached_size(a);\r\na->uncached = dma_alloc_coherent(&pcid->dev,\r\n(size_t)a->uncached_size,\r\n(dma_addr_t *)&bus_addr,\r\nGFP_KERNEL);\r\nif (a->uncached == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate %d bytes of consistent memory!",\r\na->uncached_size);\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\na->uncached_phys = bus_addr;\r\nesas2r_debug("%d bytes uncached memory allocated @ %p (%x:%x)",\r\na->uncached_size,\r\na->uncached,\r\nupper_32_bits(bus_addr),\r\nlower_32_bits(bus_addr));\r\nmemset(a->uncached, 0, a->uncached_size);\r\nnext_uncached = a->uncached;\r\nif (!esas2r_init_adapter_struct(a,\r\n&next_uncached)) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to initialize adapter structure (2)!");\r\nesas2r_kill_adapter(index);\r\nreturn 0;\r\n}\r\ntasklet_init(&a->tasklet,\r\nesas2r_adapter_tasklet,\r\n(unsigned long)a);\r\nesas2r_disable_chip_interrupts(a);\r\nesas2r_check_adapter(a);\r\nif (!esas2r_init_adapter_hw(a, true))\r\nesas2r_log(ESAS2R_LOG_CRIT, "failed to initialize hardware!");\r\nelse\r\nesas2r_debug("esas2r_init_adapter ok");\r\nesas2r_claim_interrupts(a);\r\nif (test_bit(AF2_IRQ_CLAIMED, &a->flags2))\r\nesas2r_enable_chip_interrupts(a);\r\nset_bit(AF2_INIT_DONE, &a->flags2);\r\nif (!test_bit(AF_DEGRADED_MODE, &a->flags))\r\nesas2r_kickoff_timer(a);\r\nesas2r_debug("esas2r_init_adapter done for %p (%d)",\r\na, a->disable_cnt);\r\nreturn 1;\r\n}\r\nstatic void esas2r_adapter_power_down(struct esas2r_adapter *a,\r\nint power_management)\r\n{\r\nstruct esas2r_mem_desc *memdesc, *next;\r\nif ((test_bit(AF2_INIT_DONE, &a->flags2))\r\n&& (!test_bit(AF_DEGRADED_MODE, &a->flags))) {\r\nif (!power_management) {\r\ndel_timer_sync(&a->timer);\r\ntasklet_kill(&a->tasklet);\r\n}\r\nesas2r_power_down(a);\r\nmdelay(500);\r\nesas2r_debug("chip halted");\r\n}\r\nif (a->sysfs_fw_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_fw);\r\na->sysfs_fw_created = 0;\r\n}\r\nif (a->sysfs_fs_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_fs);\r\na->sysfs_fs_created = 0;\r\n}\r\nif (a->sysfs_vda_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_vda);\r\na->sysfs_vda_created = 0;\r\n}\r\nif (a->sysfs_hw_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj, &bin_attr_hw);\r\na->sysfs_hw_created = 0;\r\n}\r\nif (a->sysfs_live_nvram_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj,\r\n&bin_attr_live_nvram);\r\na->sysfs_live_nvram_created = 0;\r\n}\r\nif (a->sysfs_default_nvram_created) {\r\nsysfs_remove_bin_file(&a->host->shost_dev.kobj,\r\n&bin_attr_default_nvram);\r\na->sysfs_default_nvram_created = 0;\r\n}\r\nif (test_bit(AF2_IRQ_CLAIMED, &a->flags2)) {\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"free_irq(%d) called", a->pcid->irq);\r\nfree_irq(a->pcid->irq, a);\r\nesas2r_debug("IRQ released");\r\nclear_bit(AF2_IRQ_CLAIMED, &a->flags2);\r\n}\r\nif (test_bit(AF2_MSI_ENABLED, &a->flags2)) {\r\npci_disable_msi(a->pcid);\r\nclear_bit(AF2_MSI_ENABLED, &a->flags2);\r\nesas2r_debug("MSI disabled");\r\n}\r\nif (a->inbound_list_md.virt_addr)\r\nesas2r_initmem_free(a, &a->inbound_list_md);\r\nif (a->outbound_list_md.virt_addr)\r\nesas2r_initmem_free(a, &a->outbound_list_md);\r\nlist_for_each_entry_safe(memdesc, next, &a->free_sg_list_head,\r\nnext_desc) {\r\nesas2r_initmem_free(a, memdesc);\r\n}\r\nlist_for_each_entry_safe(memdesc, next, &a->vrq_mds_head, next_desc) {\r\nesas2r_initmem_free(a, memdesc);\r\nlist_del(&memdesc->next_desc);\r\nkfree(memdesc);\r\n}\r\nkfree(a->first_ae_req);\r\na->first_ae_req = NULL;\r\nkfree(a->sg_list_mds);\r\na->sg_list_mds = NULL;\r\nkfree(a->req_table);\r\na->req_table = NULL;\r\nif (a->regs) {\r\nesas2r_unmap_regions(a);\r\na->regs = NULL;\r\na->data_window = NULL;\r\nesas2r_debug("regions unmapped");\r\n}\r\n}\r\nvoid esas2r_kill_adapter(int i)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapters[i];\r\nif (a) {\r\nunsigned long flags;\r\nstruct workqueue_struct *wq;\r\nesas2r_debug("killing adapter %p [%d] ", a, i);\r\nesas2r_fw_event_off(a);\r\nesas2r_adapter_power_down(a, 0);\r\nif (esas2r_buffered_ioctl &&\r\n(a->pcid == esas2r_buffered_ioctl_pcid)) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)esas2r_buffered_ioctl_size,\r\nesas2r_buffered_ioctl,\r\nesas2r_buffered_ioctl_addr);\r\nesas2r_buffered_ioctl = NULL;\r\n}\r\nif (a->vda_buffer) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)VDA_MAX_BUFFER_SIZE,\r\na->vda_buffer,\r\n(dma_addr_t)a->ppvda_buffer);\r\na->vda_buffer = NULL;\r\n}\r\nif (a->fs_api_buffer) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)a->fs_api_buffer_size,\r\na->fs_api_buffer,\r\n(dma_addr_t)a->ppfs_api_buffer);\r\na->fs_api_buffer = NULL;\r\n}\r\nkfree(a->local_atto_ioctl);\r\na->local_atto_ioctl = NULL;\r\nspin_lock_irqsave(&a->fw_event_lock, flags);\r\nwq = a->fw_event_q;\r\na->fw_event_q = NULL;\r\nspin_unlock_irqrestore(&a->fw_event_lock, flags);\r\nif (wq)\r\ndestroy_workqueue(wq);\r\nif (a->uncached) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)a->uncached_size,\r\na->uncached,\r\n(dma_addr_t)a->uncached_phys);\r\na->uncached = NULL;\r\nesas2r_debug("uncached area freed");\r\n}\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"pci_disable_device() called. msix_enabled: %d "\r\n"msi_enabled: %d irq: %d pin: %d",\r\na->pcid->msix_enabled,\r\na->pcid->msi_enabled,\r\na->pcid->irq,\r\na->pcid->pin);\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"before pci_disable_device() enable_cnt: %d",\r\na->pcid->enable_cnt.counter);\r\npci_disable_device(a->pcid);\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"after pci_disable_device() enable_cnt: %d",\r\na->pcid->enable_cnt.counter);\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->pcid->dev),\r\n"pci_set_drv_data(%p, NULL) called",\r\na->pcid);\r\npci_set_drvdata(a->pcid, NULL);\r\nesas2r_adapters[i] = NULL;\r\nif (test_bit(AF2_INIT_DONE, &a->flags2)) {\r\nclear_bit(AF2_INIT_DONE, &a->flags2);\r\nset_bit(AF_DEGRADED_MODE, &a->flags);\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->host->shost_gendev),\r\n"scsi_remove_host() called");\r\nscsi_remove_host(a->host);\r\nesas2r_log_dev(ESAS2R_LOG_INFO,\r\n&(a->host->shost_gendev),\r\n"scsi_host_put() called");\r\nscsi_host_put(a->host);\r\n}\r\n}\r\n}\r\nint esas2r_cleanup(struct Scsi_Host *host)\r\n{\r\nstruct esas2r_adapter *a;\r\nint index;\r\nif (host == NULL) {\r\nint i;\r\nesas2r_debug("esas2r_cleanup everything");\r\nfor (i = 0; i < MAX_ADAPTERS; i++)\r\nesas2r_kill_adapter(i);\r\nreturn -1;\r\n}\r\nesas2r_debug("esas2r_cleanup called for host %p", host);\r\na = (struct esas2r_adapter *)host->hostdata;\r\nindex = a->index;\r\nesas2r_kill_adapter(index);\r\nreturn index;\r\n}\r\nint esas2r_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nu32 device_state;\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)host->hostdata;\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev), "suspending adapter()");\r\nif (!a)\r\nreturn -ENODEV;\r\nesas2r_adapter_power_down(a, 1);\r\ndevice_state = pci_choose_state(pdev, state);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_save_state() called");\r\npci_save_state(pdev);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_disable_device() called");\r\npci_disable_device(pdev);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_set_power_state() called");\r\npci_set_power_state(pdev, device_state);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev), "esas2r_suspend(): 0");\r\nreturn 0;\r\n}\r\nint esas2r_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)host->hostdata;\r\nint rez;\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev), "resuming adapter()");\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_set_power_state(PCI_D0) "\r\n"called");\r\npci_set_power_state(pdev, PCI_D0);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_enable_wake(PCI_D0, 0) "\r\n"called");\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_restore_state() called");\r\npci_restore_state(pdev);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"pci_enable_device() called");\r\nrez = pci_enable_device(pdev);\r\npci_set_master(pdev);\r\nif (!a) {\r\nrez = -ENODEV;\r\ngoto error_exit;\r\n}\r\nif (esas2r_map_regions(a) != 0) {\r\nesas2r_log(ESAS2R_LOG_CRIT, "could not re-map PCI regions!");\r\nrez = -ENOMEM;\r\ngoto error_exit;\r\n}\r\nesas2r_setup_interrupts(a, a->intr_mode);\r\nesas2r_disable_chip_interrupts(a);\r\nif (!esas2r_power_up(a, true)) {\r\nesas2r_debug("yikes, esas2r_power_up failed");\r\nrez = -ENOMEM;\r\ngoto error_exit;\r\n}\r\nesas2r_claim_interrupts(a);\r\nif (test_bit(AF2_IRQ_CLAIMED, &a->flags2)) {\r\nesas2r_enable_chip_interrupts(a);\r\nesas2r_kickoff_timer(a);\r\n} else {\r\nesas2r_debug("yikes, unable to claim IRQ");\r\nesas2r_log(ESAS2R_LOG_CRIT, "could not re-claim IRQ!");\r\nrez = -ENOMEM;\r\ngoto error_exit;\r\n}\r\nerror_exit:\r\nesas2r_log_dev(ESAS2R_LOG_CRIT, &(pdev->dev), "esas2r_resume(): %d",\r\nrez);\r\nreturn rez;\r\n}\r\nbool esas2r_set_degraded_mode(struct esas2r_adapter *a, char *error_str)\r\n{\r\nset_bit(AF_DEGRADED_MODE, &a->flags);\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"setting adapter to degraded mode: %s\n", error_str);\r\nreturn false;\r\n}\r\nu32 esas2r_get_uncached_size(struct esas2r_adapter *a)\r\n{\r\nreturn sizeof(struct esas2r_sas_nvram)\r\n+ ALIGN(ESAS2R_DISC_BUF_LEN, 8)\r\n+ ALIGN(sizeof(u32), 8)\r\n+ 8\r\n+ (num_sg_lists * (u16)sgl_page_size)\r\n+ ALIGN((num_requests + num_ae_requests + 1 +\r\nESAS2R_LIST_EXTRA) *\r\nsizeof(struct esas2r_inbound_list_source_entry),\r\n8)\r\n+ ALIGN((num_requests + num_ae_requests + 1 +\r\nESAS2R_LIST_EXTRA) *\r\nsizeof(struct atto_vda_ob_rsp), 8)\r\n+ 256;\r\n}\r\nstatic void esas2r_init_pci_cfg_space(struct esas2r_adapter *a)\r\n{\r\nint pcie_cap_reg;\r\npcie_cap_reg = pci_find_capability(a->pcid, PCI_CAP_ID_EXP);\r\nif (pcie_cap_reg) {\r\nu16 devcontrol;\r\npci_read_config_word(a->pcid, pcie_cap_reg + PCI_EXP_DEVCTL,\r\n&devcontrol);\r\nif ((devcontrol & PCI_EXP_DEVCTL_READRQ) > 0x2000) {\r\nesas2r_log(ESAS2R_LOG_INFO,\r\n"max read request size > 512B");\r\ndevcontrol &= ~PCI_EXP_DEVCTL_READRQ;\r\ndevcontrol |= 0x2000;\r\npci_write_config_word(a->pcid,\r\npcie_cap_reg + PCI_EXP_DEVCTL,\r\ndevcontrol);\r\n}\r\n}\r\n}\r\nbool esas2r_init_adapter_struct(struct esas2r_adapter *a,\r\nvoid **uncached_area)\r\n{\r\nu32 i;\r\nu8 *high;\r\nstruct esas2r_inbound_list_source_entry *element;\r\nstruct esas2r_request *rq;\r\nstruct esas2r_mem_desc *sgl;\r\nspin_lock_init(&a->sg_list_lock);\r\nspin_lock_init(&a->mem_lock);\r\nspin_lock_init(&a->queue_lock);\r\na->targetdb_end = &a->targetdb[ESAS2R_MAX_TARGETS];\r\nif (!alloc_vda_req(a, &a->general_req)) {\r\nesas2r_hdebug(\r\n"failed to allocate a VDA request for the general req!");\r\nreturn false;\r\n}\r\na->first_ae_req =\r\nkzalloc(num_ae_requests * sizeof(struct esas2r_request),\r\nGFP_KERNEL);\r\nif (a->first_ae_req == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate memory for asynchronous events");\r\nreturn false;\r\n}\r\na->sg_list_mds = kzalloc(\r\nnum_sg_lists * sizeof(struct esas2r_mem_desc), GFP_KERNEL);\r\nif (a->sg_list_mds == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate memory for s/g list descriptors");\r\nreturn false;\r\n}\r\na->req_table =\r\nkzalloc((num_requests + num_ae_requests +\r\n1) * sizeof(struct esas2r_request *), GFP_KERNEL);\r\nif (a->req_table == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"failed to allocate memory for the request table");\r\nreturn false;\r\n}\r\nesas2r_init_pci_cfg_space(a);\r\nif ((a->pcid->subsystem_vendor == ATTO_VENDOR_ID)\r\n&& (a->pcid->subsystem_device & ATTO_SSDID_TBT))\r\na->flags2 |= AF2_THUNDERBOLT;\r\nif (test_bit(AF2_THUNDERBOLT, &a->flags2))\r\na->flags2 |= AF2_SERIAL_FLASH;\r\nif (a->pcid->subsystem_device == ATTO_TLSH_1068)\r\na->flags2 |= AF2_THUNDERLINK;\r\nhigh = (u8 *)*uncached_area;\r\nfor (i = 0, sgl = a->sg_list_mds; i < num_sg_lists; i++, sgl++) {\r\nsgl->size = sgl_page_size;\r\nlist_add_tail(&sgl->next_desc, &a->free_sg_list_head);\r\nif (!esas2r_initmem_alloc(a, sgl, ESAS2R_SGL_ALIGN)) {\r\nif (i < NUM_SGL_MIN)\r\nreturn false;\r\nbreak;\r\n}\r\n}\r\na->list_size = num_requests + ESAS2R_LIST_EXTRA;\r\na->inbound_list_md.size = a->list_size *\r\nsizeof(struct\r\nesas2r_inbound_list_source_entry);\r\nif (!esas2r_initmem_alloc(a, &a->inbound_list_md, ESAS2R_LIST_ALIGN)) {\r\nesas2r_hdebug("failed to allocate IB list");\r\nreturn false;\r\n}\r\na->outbound_list_md.size = a->list_size *\r\nsizeof(struct atto_vda_ob_rsp);\r\nif (!esas2r_initmem_alloc(a, &a->outbound_list_md,\r\nESAS2R_LIST_ALIGN)) {\r\nesas2r_hdebug("failed to allocate IB list");\r\nreturn false;\r\n}\r\na->nvram = (struct esas2r_sas_nvram *)high;\r\nhigh += sizeof(struct esas2r_sas_nvram);\r\na->disc_buffer = high;\r\nhigh += ESAS2R_DISC_BUF_LEN;\r\nhigh = PTR_ALIGN(high, 8);\r\na->outbound_copy = (u32 volatile *)high;\r\nhigh += sizeof(u32);\r\nif (!test_bit(AF_NVR_VALID, &a->flags))\r\nesas2r_nvram_set_defaults(a);\r\n*uncached_area = (void *)high;\r\nif (test_bit(AF_FIRST_INIT, &a->flags)) {\r\nmemset(a->req_table, 0,\r\n(num_requests + num_ae_requests +\r\n1) * sizeof(struct esas2r_request *));\r\nesas2r_targ_db_initialize(a);\r\nelement =\r\n(struct esas2r_inbound_list_source_entry *)a->\r\ninbound_list_md.\r\nvirt_addr;\r\nfor (i = 0; i < a->list_size; i++) {\r\nelement->address = 0;\r\nelement->reserved = 0;\r\nelement->length = cpu_to_le32(HWILSE_INTERFACE_F0\r\n| (sizeof(union\r\natto_vda_req)\r\n/\r\nsizeof(u32)));\r\nelement++;\r\n}\r\nfor (rq = a->first_ae_req, i = 0; i < num_ae_requests; rq++,\r\ni++) {\r\nINIT_LIST_HEAD(&rq->req_list);\r\nif (!alloc_vda_req(a, rq)) {\r\nesas2r_hdebug(\r\n"failed to allocate a VDA request!");\r\nreturn false;\r\n}\r\nesas2r_rq_init_request(rq, a);\r\nrq->comp_cb = esas2r_ae_complete;\r\n}\r\n}\r\nreturn true;\r\n}\r\nbool esas2r_check_adapter(struct esas2r_adapter *a)\r\n{\r\nu32 starttime;\r\nu32 doorbell;\r\nu64 ppaddr;\r\nu32 dw;\r\nif (test_bit(AF_CHPRST_DETECTED, &a->flags))\r\ngoto skip_chip_reset;\r\nesas2r_write_register_dword(a, MU_INT_MASK_OUT, ESAS2R_INT_DIS_MASK);\r\nesas2r_flush_register_dword(a, MU_INT_MASK_OUT);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nwhile (true) {\r\nesas2r_force_interrupt(a);\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell == 0xFFFFFFFF) {\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 2000)\r\nreturn esas2r_set_degraded_mode(a,\r\n"unable to access registers");\r\n} else if (doorbell & DRBL_FORCE_INT) {\r\nu32 ver = (doorbell & DRBL_FW_VER_MSK);\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nif (ver == DRBL_FW_VER_0) {\r\nset_bit(AF_LEGACY_SGE_MODE, &a->flags);\r\na->max_vdareq_size = 128;\r\na->build_sgl = esas2r_build_sg_list_sge;\r\n} else if (ver == DRBL_FW_VER_1) {\r\nclear_bit(AF_LEGACY_SGE_MODE, &a->flags);\r\na->max_vdareq_size = 1024;\r\na->build_sgl = esas2r_build_sg_list_prd;\r\n} else {\r\nreturn esas2r_set_degraded_mode(a,\r\n"unknown firmware version");\r\n}\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 180000) {\r\nesas2r_hdebug("FW ready TMO");\r\nesas2r_bugon();\r\nreturn esas2r_set_degraded_mode(a,\r\n"firmware start has timed out");\r\n}\r\n}\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_MSG_IFC_DOWN);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nwhile (true) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell & DRBL_MSG_IFC_DOWN) {\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(50));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\r\nesas2r_hdebug("timeout waiting for interface down");\r\nbreak;\r\n}\r\n}\r\nskip_chip_reset:\r\ndw = esas2r_read_register_dword(a, MU_IN_LIST_CONFIG);\r\ndw &= ~MU_ILC_ENABLE;\r\nesas2r_write_register_dword(a, MU_IN_LIST_CONFIG, dw);\r\ndw = esas2r_read_register_dword(a, MU_OUT_LIST_CONFIG);\r\ndw &= ~MU_OLC_ENABLE;\r\nesas2r_write_register_dword(a, MU_OUT_LIST_CONFIG, dw);\r\nppaddr = a->inbound_list_md.phys_addr;\r\nesas2r_write_register_dword(a, MU_IN_LIST_ADDR_LO,\r\nlower_32_bits(ppaddr));\r\nesas2r_write_register_dword(a, MU_IN_LIST_ADDR_HI,\r\nupper_32_bits(ppaddr));\r\nppaddr = a->outbound_list_md.phys_addr;\r\nesas2r_write_register_dword(a, MU_OUT_LIST_ADDR_LO,\r\nlower_32_bits(ppaddr));\r\nesas2r_write_register_dword(a, MU_OUT_LIST_ADDR_HI,\r\nupper_32_bits(ppaddr));\r\nppaddr = a->uncached_phys +\r\n((u8 *)a->outbound_copy - a->uncached);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_COPY_PTR_LO,\r\nlower_32_bits(ppaddr));\r\nesas2r_write_register_dword(a, MU_OUT_LIST_COPY_PTR_HI,\r\nupper_32_bits(ppaddr));\r\n*a->outbound_copy =\r\na->last_write =\r\na->last_read = a->list_size - 1;\r\nset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\r\nesas2r_write_register_dword(a, MU_IN_LIST_WRITE, MU_ILW_TOGGLE |\r\na->last_write);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_COPY, MU_OLC_TOGGLE |\r\na->last_write);\r\nesas2r_write_register_dword(a, MU_IN_LIST_READ, MU_ILR_TOGGLE |\r\na->last_write);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_WRITE,\r\nMU_OLW_TOGGLE | a->last_write);\r\ndw = esas2r_read_register_dword(a, MU_IN_LIST_IFC_CONFIG);\r\ndw &= ~(MU_ILIC_LIST | MU_ILIC_DEST);\r\nesas2r_write_register_dword(a, MU_IN_LIST_IFC_CONFIG,\r\n(dw | MU_ILIC_LIST_F0 | MU_ILIC_DEST_DDR));\r\ndw = esas2r_read_register_dword(a, MU_OUT_LIST_IFC_CONFIG);\r\ndw &= ~(MU_OLIC_LIST | MU_OLIC_SOURCE);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_IFC_CONFIG,\r\n(dw | MU_OLIC_LIST_F0 |\r\nMU_OLIC_SOURCE_DDR));\r\ndw = esas2r_read_register_dword(a, MU_IN_LIST_CONFIG);\r\ndw &= ~(MU_ILC_ENTRY_MASK | MU_ILC_NUMBER_MASK);\r\ndw |= MU_ILC_ENTRY_4_DW | MU_ILC_DYNAMIC_SRC\r\n| (a->list_size << MU_ILC_NUMBER_SHIFT);\r\nesas2r_write_register_dword(a, MU_IN_LIST_CONFIG, dw);\r\ndw = esas2r_read_register_dword(a, MU_OUT_LIST_CONFIG);\r\ndw &= ~(MU_OLC_ENTRY_MASK | MU_OLC_NUMBER_MASK);\r\ndw |= MU_OLC_ENTRY_4_DW | (a->list_size << MU_OLC_NUMBER_SHIFT);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_CONFIG, dw);\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_MSG_IFC_INIT);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nwhile (true) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell & DRBL_MSG_IFC_INIT) {\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\r\nesas2r_hdebug(\r\n"timeout waiting for communication list init");\r\nesas2r_bugon();\r\nreturn esas2r_set_degraded_mode(a,\r\n"timeout waiting for communication list init");\r\n}\r\n}\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_IN_ENB);\r\nif (doorbell & DRBL_POWER_DOWN)\r\nset_bit(AF2_VDA_POWER_DOWN, &a->flags2);\r\nelse\r\nclear_bit(AF2_VDA_POWER_DOWN, &a->flags2);\r\nesas2r_write_register_dword(a, MU_OUT_LIST_INT_MASK, MU_OLIS_MASK);\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT_ENB, DRBL_ENB_MASK);\r\nreturn true;\r\n}\r\nstatic bool esas2r_format_init_msg(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nu32 msg = a->init_msg;\r\nstruct atto_vda_cfg_init *ci;\r\na->init_msg = 0;\r\nswitch (msg) {\r\ncase ESAS2R_INIT_MSG_START:\r\ncase ESAS2R_INIT_MSG_REINIT:\r\n{\r\nstruct timeval now;\r\ndo_gettimeofday(&now);\r\nesas2r_hdebug("CFG init");\r\nesas2r_build_cfg_req(a,\r\nrq,\r\nVDA_CFG_INIT,\r\n0,\r\nNULL);\r\nci = (struct atto_vda_cfg_init *)&rq->vrq->cfg.data.init;\r\nci->sgl_page_size = cpu_to_le32(sgl_page_size);\r\nci->epoch_time = cpu_to_le32(now.tv_sec);\r\nrq->flags |= RF_FAILURE_OK;\r\na->init_msg = ESAS2R_INIT_MSG_INIT;\r\nbreak;\r\n}\r\ncase ESAS2R_INIT_MSG_INIT:\r\nif (rq->req_stat == RS_SUCCESS) {\r\nu32 major;\r\nu32 minor;\r\nu16 fw_release;\r\na->fw_version = le16_to_cpu(\r\nrq->func_rsp.cfg_rsp.vda_version);\r\na->fw_build = rq->func_rsp.cfg_rsp.fw_build;\r\nfw_release = le16_to_cpu(\r\nrq->func_rsp.cfg_rsp.fw_release);\r\nmajor = LOBYTE(fw_release);\r\nminor = HIBYTE(fw_release);\r\na->fw_version += (major << 16) + (minor << 24);\r\n} else {\r\nesas2r_hdebug("FAILED");\r\n}\r\nif ((test_bit(AF2_THUNDERBOLT, &a->flags2))\r\n|| (be32_to_cpu(a->fw_version) > 0x00524702)) {\r\nesas2r_hdebug("CFG get init");\r\nesas2r_build_cfg_req(a,\r\nrq,\r\nVDA_CFG_GET_INIT2,\r\nsizeof(struct atto_vda_cfg_init),\r\nNULL);\r\nrq->vrq->cfg.sg_list_offset = offsetof(\r\nstruct atto_vda_cfg_req,\r\ndata.sge);\r\nrq->vrq->cfg.data.prde.ctl_len =\r\ncpu_to_le32(sizeof(struct atto_vda_cfg_init));\r\nrq->vrq->cfg.data.prde.address = cpu_to_le64(\r\nrq->vrq_md->phys_addr +\r\nsizeof(union atto_vda_req));\r\nrq->flags |= RF_FAILURE_OK;\r\na->init_msg = ESAS2R_INIT_MSG_GET_INIT;\r\nbreak;\r\n}\r\ncase ESAS2R_INIT_MSG_GET_INIT:\r\nif (msg == ESAS2R_INIT_MSG_GET_INIT) {\r\nci = (struct atto_vda_cfg_init *)rq->data_buf;\r\nif (rq->req_stat == RS_SUCCESS) {\r\na->num_targets_backend =\r\nle32_to_cpu(ci->num_targets_backend);\r\na->ioctl_tunnel =\r\nle32_to_cpu(ci->ioctl_tunnel);\r\n} else {\r\nesas2r_hdebug("FAILED");\r\n}\r\n}\r\ndefault:\r\nrq->req_stat = RS_SUCCESS;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool esas2r_init_msgs(struct esas2r_adapter *a)\r\n{\r\nbool success = true;\r\nstruct esas2r_request *rq = &a->general_req;\r\nesas2r_rq_init_request(rq, a);\r\nrq->comp_cb = esas2r_dummy_complete;\r\nif (a->init_msg == 0)\r\na->init_msg = ESAS2R_INIT_MSG_REINIT;\r\nwhile (a->init_msg) {\r\nif (esas2r_format_init_msg(a, rq)) {\r\nunsigned long flags;\r\nwhile (true) {\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nesas2r_start_vda_request(a, rq);\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_wait_request(a, rq);\r\nif (rq->req_stat != RS_PENDING)\r\nbreak;\r\n}\r\n}\r\nif (rq->req_stat == RS_SUCCESS\r\n|| ((rq->flags & RF_FAILURE_OK)\r\n&& rq->req_stat != RS_TIMEOUT))\r\ncontinue;\r\nesas2r_log(ESAS2R_LOG_CRIT, "init message %x failed (%x, %x)",\r\na->init_msg, rq->req_stat, rq->flags);\r\na->init_msg = ESAS2R_INIT_MSG_START;\r\nsuccess = false;\r\nbreak;\r\n}\r\nesas2r_rq_destroy_request(rq, a);\r\nreturn success;\r\n}\r\nbool esas2r_init_adapter_hw(struct esas2r_adapter *a, bool init_poll)\r\n{\r\nbool rslt = false;\r\nstruct esas2r_request *rq;\r\nu32 i;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\ngoto exit;\r\nif (!test_bit(AF_NVR_VALID, &a->flags)) {\r\nif (!esas2r_nvram_read_direct(a))\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"invalid/missing NVRAM parameters");\r\n}\r\nif (!esas2r_init_msgs(a)) {\r\nesas2r_set_degraded_mode(a, "init messages failed");\r\ngoto exit;\r\n}\r\nclear_bit(AF_DEGRADED_MODE, &a->flags);\r\nclear_bit(AF_CHPRST_PENDING, &a->flags);\r\nfor (i = 0, rq = a->first_ae_req; i < num_ae_requests; i++, rq++)\r\nesas2r_start_ae_request(a, rq);\r\nif (!a->flash_rev[0])\r\nesas2r_read_flash_rev(a);\r\nif (!a->image_type[0])\r\nesas2r_read_image_type(a);\r\nif (a->fw_version == 0)\r\na->fw_rev[0] = 0;\r\nelse\r\nsprintf(a->fw_rev, "%1d.%02d",\r\n(int)LOBYTE(HIWORD(a->fw_version)),\r\n(int)HIBYTE(HIWORD(a->fw_version)));\r\nesas2r_hdebug("firmware revision: %s", a->fw_rev);\r\nif (test_bit(AF_CHPRST_DETECTED, &a->flags)\r\n&& (test_bit(AF_FIRST_INIT, &a->flags))) {\r\nesas2r_enable_chip_interrupts(a);\r\nreturn true;\r\n}\r\nesas2r_disc_initialize(a);\r\nif (init_poll) {\r\nu32 currtime = a->disc_start_time;\r\nu32 nexttick = 100;\r\nu32 deltatime;\r\nset_bit(AF_TASKLET_SCHEDULED, &a->flags);\r\nset_bit(AF_DISC_POLLED, &a->flags);\r\nif (test_bit(AF_FIRST_INIT, &a->flags))\r\natomic_dec(&a->disable_cnt);\r\nwhile (test_bit(AF_DISC_PENDING, &a->flags)) {\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\ndeltatime = jiffies_to_msecs(jiffies) - currtime;\r\ncurrtime += deltatime;\r\nif (!test_bit(AF_CHPRST_PENDING, &a->flags))\r\nesas2r_disc_check_for_work(a);\r\nif (nexttick <= deltatime) {\r\nnexttick += 100;\r\nesas2r_timer_tick(a);\r\n}\r\nif (nexttick > deltatime)\r\nnexttick -= deltatime;\r\nif (esas2r_is_tasklet_pending(a))\r\nesas2r_do_tasklet_tasks(a);\r\n}\r\nif (test_bit(AF_FIRST_INIT, &a->flags))\r\natomic_inc(&a->disable_cnt);\r\nclear_bit(AF_DISC_POLLED, &a->flags);\r\nclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\r\n}\r\nesas2r_targ_db_report_changes(a);\r\nesas2r_disc_start_waiting(a);\r\na->int_mask = ESAS2R_INT_STS_MASK;\r\nesas2r_enable_chip_interrupts(a);\r\nesas2r_enable_heartbeat(a);\r\nrslt = true;\r\nexit:\r\nif (test_bit(AF_CHPRST_DETECTED, &a->flags) &&\r\ntest_bit(AF_FIRST_INIT, &a->flags)) {\r\nif (!rslt)\r\nclear_bit(AF_CHPRST_PENDING, &a->flags);\r\n} else {\r\nif (!rslt) {\r\nclear_bit(AF_CHPRST_PENDING, &a->flags);\r\nclear_bit(AF_DISC_PENDING, &a->flags);\r\n}\r\nif (test_bit(AF_FIRST_INIT, &a->flags)) {\r\nclear_bit(AF_FIRST_INIT, &a->flags);\r\nif (atomic_dec_return(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\n}\r\n}\r\nreturn rslt;\r\n}\r\nvoid esas2r_reset_adapter(struct esas2r_adapter *a)\r\n{\r\nset_bit(AF_OS_RESET, &a->flags);\r\nesas2r_local_reset_adapter(a);\r\nesas2r_schedule_tasklet(a);\r\n}\r\nvoid esas2r_reset_chip(struct esas2r_adapter *a)\r\n{\r\nif (!esas2r_is_adapter_present(a))\r\nreturn;\r\nif (test_bit(AF2_COREDUMP_AVAIL, &a->flags2) &&\r\n!test_bit(AF2_COREDUMP_SAVED, &a->flags2)) {\r\nesas2r_read_mem_block(a,\r\na->fw_coredump_buff,\r\nMW_DATA_ADDR_SRAM + 0x80000,\r\nESAS2R_FWCOREDUMP_SZ);\r\nset_bit(AF2_COREDUMP_SAVED, &a->flags2);\r\n}\r\nclear_bit(AF2_COREDUMP_AVAIL, &a->flags2);\r\nif (a->pcid->revision == MVR_FREY_B2)\r\nesas2r_write_register_dword(a, MU_CTL_STATUS_IN_B2,\r\nMU_CTL_IN_FULL_RST2);\r\nelse\r\nesas2r_write_register_dword(a, MU_CTL_STATUS_IN,\r\nMU_CTL_IN_FULL_RST);\r\nmdelay(10);\r\n}\r\nstatic void esas2r_power_down_notify_firmware(struct esas2r_adapter *a)\r\n{\r\nu32 starttime;\r\nu32 doorbell;\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_POWER_DOWN);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nwhile (true) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell & DRBL_POWER_DOWN) {\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 30000) {\r\nesas2r_hdebug("Timeout waiting for power down");\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid esas2r_power_down(struct esas2r_adapter *a)\r\n{\r\nset_bit(AF_POWER_MGT, &a->flags);\r\nset_bit(AF_POWER_DOWN, &a->flags);\r\nif (!test_bit(AF_DEGRADED_MODE, &a->flags)) {\r\nu32 starttime;\r\nu32 doorbell;\r\nesas2r_disable_chip_interrupts(a);\r\nesas2r_disable_heartbeat(a);\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN,\r\nDRBL_MSG_IFC_DOWN);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nwhile (true) {\r\ndoorbell =\r\nesas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell & DRBL_MSG_IFC_DOWN) {\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > 3000) {\r\nesas2r_hdebug(\r\n"timeout waiting for interface down");\r\nbreak;\r\n}\r\n}\r\nif (test_bit(AF2_VDA_POWER_DOWN, &a->flags2))\r\nesas2r_power_down_notify_firmware(a);\r\n}\r\nset_bit(AF_OS_RESET, &a->flags);\r\nset_bit(AF_DISC_PENDING, &a->flags);\r\nset_bit(AF_CHPRST_PENDING, &a->flags);\r\nesas2r_process_adapter_reset(a);\r\na->prev_dev_cnt = esas2r_targ_db_get_tgt_cnt(a);\r\nesas2r_targ_db_remove_all(a, false);\r\n}\r\nbool esas2r_power_up(struct esas2r_adapter *a, bool init_poll)\r\n{\r\nbool ret;\r\nclear_bit(AF_POWER_DOWN, &a->flags);\r\nesas2r_init_pci_cfg_space(a);\r\nset_bit(AF_FIRST_INIT, &a->flags);\r\natomic_inc(&a->disable_cnt);\r\nret = esas2r_check_adapter(a);\r\nif (!esas2r_init_adapter_hw(a, init_poll))\r\nret = false;\r\nesas2r_send_reset_ae(a, true);\r\nclear_bit(AF_POWER_MGT, &a->flags);\r\nreturn ret;\r\n}\r\nbool esas2r_is_adapter_present(struct esas2r_adapter *a)\r\n{\r\nif (test_bit(AF_NOT_PRESENT, &a->flags))\r\nreturn false;\r\nif (esas2r_read_register_dword(a, MU_DOORBELL_OUT) == 0xFFFFFFFF) {\r\nset_bit(AF_NOT_PRESENT, &a->flags);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nconst char *esas2r_get_model_name(struct esas2r_adapter *a)\r\n{\r\nswitch (a->pcid->subsystem_device) {\r\ncase ATTO_ESAS_R680:\r\nreturn "ATTO ExpressSAS R680";\r\ncase ATTO_ESAS_R608:\r\nreturn "ATTO ExpressSAS R608";\r\ncase ATTO_ESAS_R60F:\r\nreturn "ATTO ExpressSAS R60F";\r\ncase ATTO_ESAS_R6F0:\r\nreturn "ATTO ExpressSAS R6F0";\r\ncase ATTO_ESAS_R644:\r\nreturn "ATTO ExpressSAS R644";\r\ncase ATTO_ESAS_R648:\r\nreturn "ATTO ExpressSAS R648";\r\ncase ATTO_TSSC_3808:\r\nreturn "ATTO ThunderStream SC 3808D";\r\ncase ATTO_TSSC_3808E:\r\nreturn "ATTO ThunderStream SC 3808E";\r\ncase ATTO_TLSH_1068:\r\nreturn "ATTO ThunderLink SH 1068";\r\n}\r\nreturn "ATTO SAS Controller";\r\n}\r\nconst char *esas2r_get_model_name_short(struct esas2r_adapter *a)\r\n{\r\nswitch (a->pcid->subsystem_device) {\r\ncase ATTO_ESAS_R680:\r\nreturn "R680";\r\ncase ATTO_ESAS_R608:\r\nreturn "R608";\r\ncase ATTO_ESAS_R60F:\r\nreturn "R60F";\r\ncase ATTO_ESAS_R6F0:\r\nreturn "R6F0";\r\ncase ATTO_ESAS_R644:\r\nreturn "R644";\r\ncase ATTO_ESAS_R648:\r\nreturn "R648";\r\ncase ATTO_TSSC_3808:\r\nreturn "SC 3808D";\r\ncase ATTO_TSSC_3808E:\r\nreturn "SC 3808E";\r\ncase ATTO_TLSH_1068:\r\nreturn "SH 1068";\r\n}\r\nreturn "unknown";\r\n}
