static int __init sclp_cmd_sync_early(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nint rc;\r\n__ctl_set_bit(0, 9);\r\nrc = sclp_service_call(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\n__load_psw_mask(PSW_DEFAULT_KEY | PSW_MASK_BASE | PSW_MASK_EA |\r\nPSW_MASK_BA | PSW_MASK_EXT | PSW_MASK_WAIT);\r\nlocal_irq_disable();\r\nout:\r\nbarrier();\r\n__ctl_clear_bit(0, 9);\r\nreturn rc;\r\n}\r\nstatic int __init sclp_read_info_early(struct read_info_sccb *sccb)\r\n{\r\nint rc, i;\r\nsclp_cmdw_t commands[] = {SCLP_CMDW_READ_SCP_INFO_FORCED,\r\nSCLP_CMDW_READ_SCP_INFO};\r\nfor (i = 0; i < ARRAY_SIZE(commands); i++) {\r\ndo {\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->header.length = sizeof(*sccb);\r\nsccb->header.function_code = 0x80;\r\nsccb->header.control_mask[2] = 0x80;\r\nrc = sclp_cmd_sync_early(commands[i], sccb);\r\n} while (rc == -EBUSY);\r\nif (rc)\r\nbreak;\r\nif (sccb->header.response_code == 0x10)\r\nreturn 0;\r\nif (sccb->header.response_code != 0x1f0)\r\nbreak;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void __init sclp_facilities_detect(struct read_info_sccb *sccb)\r\n{\r\nstruct sclp_cpu_entry *cpue;\r\nu16 boot_cpu_address, cpu;\r\nif (sclp_read_info_early(sccb))\r\nreturn;\r\nsclp_facilities = sccb->facilities;\r\nsclp_fac84 = sccb->fac84;\r\nif (sccb->fac85 & 0x02)\r\nS390_lowcore.machine_flags |= MACHINE_FLAG_ESOP;\r\nsclp_rnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;\r\nsclp_rzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;\r\nsclp_rzm <<= 20;\r\nsclp_ibc = sccb->ibc;\r\nif (!sccb->hcpua) {\r\nif (MACHINE_IS_VM)\r\nsclp_max_cpu = 64;\r\nelse\r\nsclp_max_cpu = sccb->ncpurl;\r\n} else {\r\nsclp_max_cpu = sccb->hcpua + 1;\r\n}\r\nboot_cpu_address = stap();\r\ncpue = (void *)sccb + sccb->cpuoff;\r\nfor (cpu = 0; cpu < sccb->ncpurl; cpue++, cpu++) {\r\nif (boot_cpu_address != cpue->address)\r\ncontinue;\r\nsclp_siif = cpue->siif;\r\nbreak;\r\n}\r\nsclp_ipl_info.is_valid = 1;\r\nif (sccb->flags & 0x2)\r\nsclp_ipl_info.has_dump = 1;\r\nmemcpy(&sclp_ipl_info.loadparm, &sccb->loadparm, LOADPARM_LEN);\r\n}\r\nbool __init sclp_has_linemode(void)\r\n{\r\nreturn !!sclp_con_has_linemode;\r\n}\r\nbool __init sclp_has_vt220(void)\r\n{\r\nreturn !!sclp_con_has_vt220;\r\n}\r\nunsigned long long sclp_get_rnmax(void)\r\n{\r\nreturn sclp_rnmax;\r\n}\r\nunsigned long long sclp_get_rzm(void)\r\n{\r\nreturn sclp_rzm;\r\n}\r\nunsigned int sclp_get_max_cpu(void)\r\n{\r\nreturn sclp_max_cpu;\r\n}\r\nint sclp_has_siif(void)\r\n{\r\nreturn sclp_siif;\r\n}\r\nunsigned int sclp_get_ibc(void)\r\n{\r\nreturn sclp_ibc;\r\n}\r\nvoid __init sclp_get_ipl_info(struct sclp_ipl_info *info)\r\n{\r\n*info = sclp_ipl_info;\r\n}\r\nstatic int __init sclp_cmd_early(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nint rc;\r\ndo {\r\nrc = sclp_cmd_sync_early(cmd, sccb);\r\n} while (rc == -EBUSY);\r\nif (rc)\r\nreturn -EIO;\r\nif (((struct sccb_header *) sccb)->response_code != 0x0020)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void __init sccb_init_eq_size(struct sdias_sccb *sccb)\r\n{\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->hdr.length = sizeof(*sccb);\r\nsccb->evbuf.hdr.length = sizeof(struct sdias_evbuf);\r\nsccb->evbuf.hdr.type = EVTYP_SDIAS;\r\nsccb->evbuf.event_qual = SDIAS_EQ_SIZE;\r\nsccb->evbuf.data_id = SDIAS_DI_FCP_DUMP;\r\nsccb->evbuf.event_id = 4712;\r\nsccb->evbuf.dbs = 1;\r\n}\r\nstatic int __init sclp_set_event_mask(struct init_sccb *sccb,\r\nunsigned long receive_mask,\r\nunsigned long send_mask)\r\n{\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->header.length = sizeof(*sccb);\r\nsccb->mask_length = sizeof(sccb_mask_t);\r\nsccb->receive_mask = receive_mask;\r\nsccb->send_mask = send_mask;\r\nreturn sclp_cmd_early(SCLP_CMDW_WRITE_EVENT_MASK, sccb);\r\n}\r\nstatic long __init sclp_hsa_size_init(struct sdias_sccb *sccb)\r\n{\r\nsccb_init_eq_size(sccb);\r\nif (sclp_cmd_early(SCLP_CMDW_WRITE_EVENT_DATA, sccb))\r\nreturn -EIO;\r\nif (sccb->evbuf.blk_cnt == 0)\r\nreturn 0;\r\nreturn (sccb->evbuf.blk_cnt - 1) * PAGE_SIZE;\r\n}\r\nstatic long __init sclp_hsa_copy_wait(struct sccb_header *sccb)\r\n{\r\nmemset(sccb, 0, PAGE_SIZE);\r\nsccb->length = PAGE_SIZE;\r\nif (sclp_cmd_early(SCLP_CMDW_READ_EVENT_DATA, sccb))\r\nreturn -EIO;\r\nif (((struct sdias_sccb *) sccb)->evbuf.blk_cnt == 0)\r\nreturn 0;\r\nreturn (((struct sdias_sccb *) sccb)->evbuf.blk_cnt - 1) * PAGE_SIZE;\r\n}\r\nunsigned long sclp_get_hsa_size(void)\r\n{\r\nreturn sclp_hsa_size;\r\n}\r\nstatic void __init sclp_hsa_size_detect(void *sccb)\r\n{\r\nlong size;\r\nif (sclp_set_event_mask(sccb, 0, 0x40000010))\r\nreturn;\r\nsize = sclp_hsa_size_init(sccb);\r\nif (size < 0)\r\nreturn;\r\nif (size != 0)\r\ngoto out;\r\nif (sclp_set_event_mask(sccb, 0x00000010, 0x40000010))\r\nreturn;\r\nsize = sclp_hsa_size_init(sccb);\r\nif (size < 0)\r\nreturn;\r\nsize = sclp_hsa_copy_wait(sccb);\r\nif (size < 0)\r\nreturn;\r\nout:\r\nsclp_hsa_size = size;\r\n}\r\nstatic unsigned int __init sclp_con_check_linemode(struct init_sccb *sccb)\r\n{\r\nif (!(sccb->sclp_send_mask & EVTYP_OPCMD_MASK))\r\nreturn 0;\r\nif (!(sccb->sclp_receive_mask & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void __init sclp_console_detect(struct init_sccb *sccb)\r\n{\r\nif (sccb->header.response_code != 0x20)\r\nreturn;\r\nif (sccb->sclp_send_mask & EVTYP_VT220MSG_MASK)\r\nsclp_con_has_vt220 = 1;\r\nif (sclp_con_check_linemode(sccb))\r\nsclp_con_has_linemode = 1;\r\n}\r\nvoid __init sclp_early_detect(void)\r\n{\r\nvoid *sccb = &sccb_early;\r\nsclp_facilities_detect(sccb);\r\nsclp_hsa_size_detect(sccb);\r\nsclp_set_event_mask(sccb, 0, 0);\r\nsclp_console_detect(sccb);\r\n}
