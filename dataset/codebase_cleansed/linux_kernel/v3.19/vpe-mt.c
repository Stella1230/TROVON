int vpe_run(struct vpe *v)\r\n{\r\nunsigned long flags, val, dmt_flag;\r\nstruct vpe_notifications *notifier;\r\nunsigned int vpeflags;\r\nstruct tc *t;\r\nlocal_irq_save(flags);\r\nval = read_c0_vpeconf0();\r\nif (!(val & VPECONF0_MVP)) {\r\npr_warn("VPE loader: only Master VPE's are able to config MT\n");\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\ndmt_flag = dmt();\r\nvpeflags = dvpe();\r\nif (list_empty(&v->tc)) {\r\nevpe(vpeflags);\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\npr_warn("VPE loader: No TC's associated with VPE %d\n",\r\nv->minor);\r\nreturn -ENOEXEC;\r\n}\r\nt = list_first_entry(&v->tc, struct tc, tc);\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(t->index);\r\nif ((read_tc_c0_tcstatus() & TCSTATUS_A) ||\r\n!(read_tc_c0_tchalt() & TCHALT_H)) {\r\nevpe(vpeflags);\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\npr_warn("VPE loader: TC %d is already active!\n",\r\nt->index);\r\nreturn -ENOEXEC;\r\n}\r\nwrite_tc_c0_tcrestart((unsigned long)v->__start);\r\nwrite_tc_c0_tccontext((unsigned long)0);\r\nval = read_tc_c0_tcstatus();\r\nval = (val & ~(TCSTATUS_DA | TCSTATUS_IXMT)) | TCSTATUS_A;\r\nwrite_tc_c0_tcstatus(val);\r\nwrite_tc_c0_tchalt(read_tc_c0_tchalt() & ~TCHALT_H);\r\nmttgpr(6, v->ntcs);\r\nmttgpr(7, physical_memsize);\r\nwrite_tc_c0_tcbind((read_tc_c0_tcbind() & ~TCBIND_CURVPE) | 1);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~(VPECONF0_VPA));\r\nback_to_back_c0_hazard();\r\nwrite_vpe_c0_vpeconf0((read_vpe_c0_vpeconf0() & ~(VPECONF0_XTC))\r\n| (t->index << VPECONF0_XTC_SHIFT));\r\nback_to_back_c0_hazard();\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | VPECONF0_VPA);\r\nwrite_vpe_c0_status(0);\r\nwrite_vpe_c0_cause(0);\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\n#ifdef CONFIG_SMP\r\nevpe(vpeflags);\r\n#else\r\nevpe(EVPE_ENABLE);\r\n#endif\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\nlist_for_each_entry(notifier, &v->notify, list)\r\nnotifier->start(VPE_MODULE_MINOR);\r\nreturn 0;\r\n}\r\nvoid cleanup_tc(struct tc *tc)\r\n{\r\nunsigned long flags;\r\nunsigned int mtflags, vpflags;\r\nint tmp;\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(tc->index);\r\ntmp = read_tc_c0_tcstatus();\r\ntmp &= ~(TCSTATUS_A | TCSTATUS_DA);\r\ntmp |= TCSTATUS_IXMT;\r\nwrite_tc_c0_tcstatus(tmp);\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid *vpe_alloc(void)\r\n{\r\nint i;\r\nstruct vpe *v;\r\nfor (i = 1; i < MAX_VPES; i++) {\r\nv = get_vpe(i);\r\nif (v != NULL) {\r\nv->state = VPE_STATE_INUSE;\r\nreturn v;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint vpe_start(void *vpe, unsigned long start)\r\n{\r\nstruct vpe *v = vpe;\r\nv->__start = start;\r\nreturn vpe_run(v);\r\n}\r\nint vpe_stop(void *vpe)\r\n{\r\nstruct vpe *v = vpe;\r\nstruct tc *t;\r\nunsigned int evpe_flags;\r\nevpe_flags = dvpe();\r\nt = list_entry(v->tc.next, struct tc, tc);\r\nif (t != NULL) {\r\nsettc(t->index);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);\r\n}\r\nevpe(evpe_flags);\r\nreturn 0;\r\n}\r\nint vpe_free(void *vpe)\r\n{\r\nstruct vpe *v = vpe;\r\nstruct tc *t;\r\nunsigned int evpe_flags;\r\nt = list_entry(v->tc.next, struct tc, tc);\r\nif (t == NULL)\r\nreturn -ENOEXEC;\r\nevpe_flags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(t->index);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\nwrite_tc_c0_tcstatus(read_tc_c0_tcstatus() & ~TCSTATUS_A);\r\nv->state = VPE_STATE_UNUSED;\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(evpe_flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t store_kill(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nstruct vpe_notifications *notifier;\r\nlist_for_each_entry(notifier, &vpe->notify, list)\r\nnotifier->stop(aprp_cpu_index());\r\nrelease_progmem(vpe->load_addr);\r\ncleanup_tc(get_tc(aprp_cpu_index()));\r\nvpe_stop(vpe);\r\nvpe_free(vpe);\r\nreturn len;\r\n}\r\nstatic ssize_t ntcs_show(struct device *cd, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nreturn sprintf(buf, "%d\n", vpe->ntcs);\r\n}\r\nstatic ssize_t ntcs_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nunsigned long new;\r\nint ret;\r\nret = kstrtoul(buf, 0, &new);\r\nif (ret < 0)\r\nreturn ret;\r\nif (new == 0 || new > (hw_tcs - aprp_cpu_index()))\r\nreturn -EINVAL;\r\nvpe->ntcs = new;\r\nreturn len;\r\n}\r\nstatic void vpe_device_release(struct device *cd)\r\n{\r\nkfree(cd);\r\n}\r\nint __init vpe_module_init(void)\r\n{\r\nunsigned int mtflags, vpflags;\r\nunsigned long flags, val;\r\nstruct vpe *v = NULL;\r\nstruct tc *t;\r\nint tc, err;\r\nif (!cpu_has_mipsmt) {\r\npr_warn("VPE loader: not a MIPS MT capable processor\n");\r\nreturn -ENODEV;\r\n}\r\nif (vpelimit == 0) {\r\npr_warn("No VPEs reserved for AP/SP, not initialize VPE loader\n"\r\n"Pass maxvpes=<n> argument as kernel argument\n");\r\nreturn -ENODEV;\r\n}\r\nif (aprp_cpu_index() == 0) {\r\npr_warn("No TCs reserved for AP/SP, not initialize VPE loader\n"\r\n"Pass maxtcs=<n> argument as kernel argument\n");\r\nreturn -ENODEV;\r\n}\r\nmajor = register_chrdev(0, VPE_MODULE_NAME, &vpe_fops);\r\nif (major < 0) {\r\npr_warn("VPE loader: unable to register character device\n");\r\nreturn major;\r\n}\r\nerr = class_register(&vpe_class);\r\nif (err) {\r\npr_err("vpe_class registration failed\n");\r\ngoto out_chrdev;\r\n}\r\ndevice_initialize(&vpe_device);\r\nvpe_device.class = &vpe_class,\r\nvpe_device.parent = NULL,\r\ndev_set_name(&vpe_device, "vpe1");\r\nvpe_device.devt = MKDEV(major, VPE_MODULE_MINOR);\r\nerr = device_add(&vpe_device);\r\nif (err) {\r\npr_err("Adding vpe_device failed\n");\r\ngoto out_class;\r\n}\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nval = read_c0_mvpconf0();\r\nhw_tcs = (val & MVPCONF0_PTC) + 1;\r\nhw_vpes = ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;\r\nfor (tc = aprp_cpu_index(); tc < hw_tcs; tc++) {\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nt = alloc_tc(tc);\r\nif (!t) {\r\nerr = -ENOMEM;\r\ngoto out_dev;\r\n}\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nif (tc < hw_tcs) {\r\nsettc(tc);\r\nv = alloc_vpe(tc);\r\nif (v == NULL) {\r\npr_warn("VPE: unable to allocate VPE\n");\r\ngoto out_reenable;\r\n}\r\nv->ntcs = hw_tcs - aprp_cpu_index();\r\nlist_add(&t->tc, &v->tc);\r\nif (tc >= aprp_cpu_index()) {\r\nunsigned long tmp = read_vpe_c0_vpeconf0();\r\ntmp &= ~VPECONF0_VPA;\r\ntmp |= VPECONF0_MVP;\r\nwrite_vpe_c0_vpeconf0(tmp);\r\n}\r\nwrite_vpe_c0_vpecontrol(read_vpe_c0_vpecontrol() &\r\n~VPECONTROL_TE);\r\nif (tc >= vpelimit) {\r\nwrite_vpe_c0_config(read_c0_config());\r\n}\r\n}\r\nt->pvpe = v;\r\nif (tc >= aprp_cpu_index()) {\r\nunsigned long tmp;\r\nsettc(tc);\r\ntmp = read_tc_c0_tcbind();\r\nif (tmp & TCBIND_CURVPE) {\r\nwrite_tc_c0_tcbind(tmp & ~TCBIND_CURVPE);\r\nt->pvpe = get_vpe(0);\r\n}\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\ntmp = read_tc_c0_tcstatus();\r\ntmp &= ~(TCSTATUS_A | TCSTATUS_DA);\r\ntmp |= TCSTATUS_IXMT;\r\nwrite_tc_c0_tcstatus(tmp);\r\n}\r\n}\r\nout_reenable:\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nout_dev:\r\ndevice_del(&vpe_device);\r\nout_class:\r\nclass_unregister(&vpe_class);\r\nout_chrdev:\r\nunregister_chrdev(major, VPE_MODULE_NAME);\r\nreturn err;\r\n}\r\nvoid __exit vpe_module_exit(void)\r\n{\r\nstruct vpe *v, *n;\r\ndevice_del(&vpe_device);\r\nclass_unregister(&vpe_class);\r\nunregister_chrdev(major, VPE_MODULE_NAME);\r\nlist_for_each_entry_safe(v, n, &vpecontrol.vpe_list, list) {\r\nif (v->state != VPE_STATE_UNUSED)\r\nrelease_vpe(v);\r\n}\r\n}
