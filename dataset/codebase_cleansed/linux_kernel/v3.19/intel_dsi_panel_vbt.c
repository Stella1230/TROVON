static u8 *mipi_exec_send_packet(struct intel_dsi *intel_dsi, u8 *data)\r\n{\r\nu8 type, byte, mode, vc, port;\r\nu16 len;\r\nbyte = *data++;\r\nmode = (byte >> MIPI_TRANSFER_MODE_SHIFT) & 0x1;\r\nvc = (byte >> MIPI_VIRTUAL_CHANNEL_SHIFT) & 0x3;\r\nport = (byte >> MIPI_PORT_SHIFT) & 0x3;\r\nintel_dsi->hs = mode;\r\ntype = *data++;\r\nlen = *((u16 *) data);\r\ndata += 2;\r\nswitch (type) {\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\ndsi_vc_generic_write_0(intel_dsi, vc);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\ndsi_vc_generic_write_1(intel_dsi, vc, *data);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\ndsi_vc_generic_write_2(intel_dsi, vc, *data, *(data + 1));\r\nbreak;\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\nDRM_DEBUG_DRIVER("Generic Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\ndsi_vc_generic_write(intel_dsi, vc, data, len);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ndsi_vc_dcs_write_0(intel_dsi, vc, *data);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ndsi_vc_dcs_write_1(intel_dsi, vc, *data, *(data + 1));\r\nbreak;\r\ncase MIPI_DSI_DCS_READ:\r\nDRM_DEBUG_DRIVER("DCS Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\ndsi_vc_dcs_write(intel_dsi, vc, data, len);\r\nbreak;\r\n}\r\ndata += len;\r\nreturn data;\r\n}\r\nstatic u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, u8 *data)\r\n{\r\nu32 delay = *((u32 *) data);\r\nusleep_range(delay, delay + 10);\r\ndata += 4;\r\nreturn data;\r\n}\r\nstatic u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, u8 *data)\r\n{\r\nu8 gpio, action;\r\nu16 function, pad;\r\nu32 val;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ngpio = *data++;\r\naction = *data++;\r\nfunction = gtable[gpio].function_reg;\r\npad = gtable[gpio].pad_reg;\r\nmutex_lock(&dev_priv->dpio_lock);\r\nif (!gtable[gpio].init) {\r\nvlv_gpio_nc_write(dev_priv, function, 0x2000CC00);\r\ngtable[gpio].init = 1;\r\n}\r\nval = 0x4 | action;\r\nvlv_gpio_nc_write(dev_priv, pad, val);\r\nmutex_unlock(&dev_priv->dpio_lock);\r\nreturn data;\r\n}\r\nstatic void generic_exec_sequence(struct intel_dsi *intel_dsi, char *sequence)\r\n{\r\nu8 *data = sequence;\r\nfn_mipi_elem_exec mipi_elem_exec;\r\nint index;\r\nif (!sequence)\r\nreturn;\r\nDRM_DEBUG_DRIVER("Starting MIPI sequence - %s\n", seq_name[*data]);\r\ndata++;\r\nwhile (1) {\r\nindex = *data;\r\nmipi_elem_exec = exec_elem[index];\r\nif (!mipi_elem_exec) {\r\nDRM_ERROR("Unsupported MIPI element, skipping sequence execution\n");\r\nreturn;\r\n}\r\ndata++;\r\ndata = mipi_elem_exec(intel_dsi, data);\r\nif (*data == 0x00)\r\nbreak;\r\n}\r\n}\r\nstatic bool generic_init(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct mipi_config *mipi_config = dev_priv->vbt.dsi.config;\r\nstruct mipi_pps_data *pps = dev_priv->vbt.dsi.pps;\r\nstruct drm_display_mode *mode = dev_priv->vbt.lfp_lvds_vbt_mode;\r\nu32 bits_per_pixel = 24;\r\nu32 tlpx_ns, extra_byte_count, bitrate, tlpx_ui;\r\nu32 ui_num, ui_den;\r\nu32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;\r\nu32 ths_prepare_ns, tclk_trail_ns;\r\nu32 tclk_prepare_clkzero, ths_prepare_hszero;\r\nu32 lp_to_hs_switch, hs_to_lp_switch;\r\nu32 pclk, computed_ddr;\r\nu16 burst_mode_ratio;\r\nDRM_DEBUG_KMS("\n");\r\nintel_dsi->eotp_pkt = mipi_config->eot_pkt_disabled ? 0 : 1;\r\nintel_dsi->clock_stop = mipi_config->enable_clk_stop ? 1 : 0;\r\nintel_dsi->lane_count = mipi_config->lane_cnt + 1;\r\nintel_dsi->pixel_format = mipi_config->videomode_color_format << 7;\r\nif (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB666)\r\nbits_per_pixel = 18;\r\nelse if (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB565)\r\nbits_per_pixel = 16;\r\nintel_dsi->operation_mode = mipi_config->is_cmd_mode;\r\nintel_dsi->video_mode_format = mipi_config->video_transfer_mode;\r\nintel_dsi->escape_clk_div = mipi_config->byte_clk_sel;\r\nintel_dsi->lp_rx_timeout = mipi_config->lp_rx_timeout;\r\nintel_dsi->turn_arnd_val = mipi_config->turn_around_timeout;\r\nintel_dsi->rst_timer_val = mipi_config->device_reset_timer;\r\nintel_dsi->init_count = mipi_config->master_init_timer;\r\nintel_dsi->bw_timer = mipi_config->dbi_bw_timer;\r\nintel_dsi->video_frmt_cfg_bits =\r\nmipi_config->bta_enabled ? DISABLE_VIDEO_BTA : 0;\r\npclk = mode->clock;\r\nif (intel_dsi->video_mode_format == VIDEO_MODE_BURST) {\r\nif (mipi_config->target_burst_mode_freq) {\r\ncomputed_ddr =\r\n(pclk * bits_per_pixel) / intel_dsi->lane_count;\r\nif (mipi_config->target_burst_mode_freq <\r\ncomputed_ddr) {\r\nDRM_ERROR("Burst mode freq is less than computed\n");\r\nreturn false;\r\n}\r\nburst_mode_ratio = DIV_ROUND_UP(\r\nmipi_config->target_burst_mode_freq * 100,\r\ncomputed_ddr);\r\npclk = DIV_ROUND_UP(pclk * burst_mode_ratio, 100);\r\n} else {\r\nDRM_ERROR("Burst mode target is not set\n");\r\nreturn false;\r\n}\r\n} else\r\nburst_mode_ratio = 100;\r\nintel_dsi->burst_mode_ratio = burst_mode_ratio;\r\nintel_dsi->pclk = pclk;\r\nbitrate = (pclk * bits_per_pixel) / intel_dsi->lane_count;\r\nswitch (intel_dsi->escape_clk_div) {\r\ncase 0:\r\ntlpx_ns = 50;\r\nbreak;\r\ncase 1:\r\ntlpx_ns = 100;\r\nbreak;\r\ncase 2:\r\ntlpx_ns = 200;\r\nbreak;\r\ndefault:\r\ntlpx_ns = 50;\r\nbreak;\r\n}\r\nswitch (intel_dsi->lane_count) {\r\ncase 1:\r\ncase 2:\r\nextra_byte_count = 2;\r\nbreak;\r\ncase 3:\r\nextra_byte_count = 4;\r\nbreak;\r\ncase 4:\r\ndefault:\r\nextra_byte_count = 3;\r\nbreak;\r\n}\r\nui_num = NS_KHZ_RATIO;\r\nui_den = bitrate;\r\ntclk_prepare_clkzero = mipi_config->tclk_prepare_clkzero;\r\nths_prepare_hszero = mipi_config->ths_prepare_hszero;\r\nintel_dsi->lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);\r\nths_prepare_ns = max(mipi_config->ths_prepare,\r\nmipi_config->tclk_prepare);\r\nprepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * 2);\r\nexit_zero_cnt = DIV_ROUND_UP(\r\n(ths_prepare_hszero - ths_prepare_ns) * ui_den,\r\nui_num * 2\r\n);\r\nif (exit_zero_cnt < (55 * ui_den / ui_num))\r\nif ((55 * ui_den) % ui_num)\r\nexit_zero_cnt += 1;\r\nclk_zero_cnt = DIV_ROUND_UP(\r\n(tclk_prepare_clkzero - ths_prepare_ns)\r\n* ui_den, 2 * ui_num);\r\ntclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);\r\ntrail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, 2 * ui_num);\r\nif (prepare_cnt > PREPARE_CNT_MAX ||\r\nexit_zero_cnt > EXIT_ZERO_CNT_MAX ||\r\nclk_zero_cnt > CLK_ZERO_CNT_MAX ||\r\ntrail_cnt > TRAIL_CNT_MAX)\r\nDRM_DEBUG_DRIVER("Values crossing maximum limits, restricting to max values\n");\r\nif (prepare_cnt > PREPARE_CNT_MAX)\r\nprepare_cnt = PREPARE_CNT_MAX;\r\nif (exit_zero_cnt > EXIT_ZERO_CNT_MAX)\r\nexit_zero_cnt = EXIT_ZERO_CNT_MAX;\r\nif (clk_zero_cnt > CLK_ZERO_CNT_MAX)\r\nclk_zero_cnt = CLK_ZERO_CNT_MAX;\r\nif (trail_cnt > TRAIL_CNT_MAX)\r\ntrail_cnt = TRAIL_CNT_MAX;\r\nintel_dsi->dphy_reg = exit_zero_cnt << 24 | trail_cnt << 16 |\r\nclk_zero_cnt << 8 | prepare_cnt;\r\ntlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);\r\nlp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * 2 +\r\nexit_zero_cnt * 2 + 10, 8);\r\nhs_to_lp_switch = DIV_ROUND_UP(mipi_config->ths_trail + 2 * tlpx_ui, 8);\r\nintel_dsi->hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);\r\nintel_dsi->hs_to_lp_count += extra_byte_count;\r\nintel_dsi->clk_lp_to_hs_count =\r\nDIV_ROUND_UP(\r\n4 * tlpx_ui + prepare_cnt * 2 +\r\nclk_zero_cnt * 2,\r\n8);\r\nintel_dsi->clk_lp_to_hs_count += extra_byte_count;\r\nintel_dsi->clk_hs_to_lp_count =\r\nDIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,\r\n8);\r\nintel_dsi->clk_hs_to_lp_count += extra_byte_count;\r\nDRM_DEBUG_KMS("Eot %s\n", intel_dsi->eotp_pkt ? "enabled" : "disabled");\r\nDRM_DEBUG_KMS("Clockstop %s\n", intel_dsi->clock_stop ?\r\n"disabled" : "enabled");\r\nDRM_DEBUG_KMS("Mode %s\n", intel_dsi->operation_mode ? "command" : "video");\r\nDRM_DEBUG_KMS("Pixel Format %d\n", intel_dsi->pixel_format);\r\nDRM_DEBUG_KMS("TLPX %d\n", intel_dsi->escape_clk_div);\r\nDRM_DEBUG_KMS("LP RX Timeout 0x%x\n", intel_dsi->lp_rx_timeout);\r\nDRM_DEBUG_KMS("Turnaround Timeout 0x%x\n", intel_dsi->turn_arnd_val);\r\nDRM_DEBUG_KMS("Init Count 0x%x\n", intel_dsi->init_count);\r\nDRM_DEBUG_KMS("HS to LP Count 0x%x\n", intel_dsi->hs_to_lp_count);\r\nDRM_DEBUG_KMS("LP Byte Clock %d\n", intel_dsi->lp_byte_clk);\r\nDRM_DEBUG_KMS("DBI BW Timer 0x%x\n", intel_dsi->bw_timer);\r\nDRM_DEBUG_KMS("LP to HS Clock Count 0x%x\n", intel_dsi->clk_lp_to_hs_count);\r\nDRM_DEBUG_KMS("HS to LP Clock Count 0x%x\n", intel_dsi->clk_hs_to_lp_count);\r\nDRM_DEBUG_KMS("BTA %s\n",\r\nintel_dsi->video_frmt_cfg_bits & DISABLE_VIDEO_BTA ?\r\n"disabled" : "enabled");\r\nintel_dsi->backlight_off_delay = pps->bl_disable_delay / 10;\r\nintel_dsi->backlight_on_delay = pps->bl_enable_delay / 10;\r\nintel_dsi->panel_on_delay = pps->panel_on_delay / 10;\r\nintel_dsi->panel_off_delay = pps->panel_off_delay / 10;\r\nintel_dsi->panel_pwr_cycle_delay = pps->panel_power_cycle_delay / 10;\r\nreturn true;\r\n}\r\nstatic int generic_mode_valid(struct intel_dsi_device *dsi,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic bool generic_mode_fixup(struct intel_dsi_device *dsi,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode) {\r\nreturn true;\r\n}\r\nstatic void generic_panel_reset(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nchar *sequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\n}\r\nstatic void generic_disable_panel_power(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nchar *sequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\n}\r\nstatic void generic_send_otp_cmds(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nchar *sequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\n}\r\nstatic void generic_enable(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nchar *sequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DISPLAY_ON];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\n}\r\nstatic void generic_disable(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nchar *sequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DISPLAY_OFF];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\n}\r\nstatic enum drm_connector_status generic_detect(struct intel_dsi_device *dsi)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic bool generic_get_hw_state(struct intel_dsi_device *dev)\r\n{\r\nreturn true;\r\n}\r\nstatic struct drm_display_mode *generic_get_modes(struct intel_dsi_device *dsi)\r\n{\r\nstruct intel_dsi *intel_dsi = container_of(dsi, struct intel_dsi, dev);\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ndev_priv->vbt.lfp_lvds_vbt_mode->type |= DRM_MODE_TYPE_PREFERRED;\r\nreturn dev_priv->vbt.lfp_lvds_vbt_mode;\r\n}\r\nstatic void generic_destroy(struct intel_dsi_device *dsi) { }
