void esas2r_polled_interrupt(struct esas2r_adapter *a)\r\n{\r\nu32 intstat;\r\nu32 doorbell;\r\nesas2r_disable_chip_interrupts(a);\r\nintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\r\nif (intstat & MU_INTSTAT_POST_OUT) {\r\nesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\r\nMU_OLIS_INT);\r\nesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\r\nesas2r_get_outbound_responses(a);\r\n}\r\nif (intstat & MU_INTSTAT_DRBL) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell != 0)\r\nesas2r_doorbell_interrupt(a, doorbell);\r\n}\r\nesas2r_enable_chip_interrupts(a);\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\n}\r\nirqreturn_t esas2r_interrupt(int irq, void *dev_id)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)dev_id;\r\nif (!esas2r_adapter_interrupt_pending(a))\r\nreturn IRQ_NONE;\r\nset_bit(AF2_INT_PENDING, &a->flags2);\r\nesas2r_schedule_tasklet(a);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid esas2r_adapter_interrupt(struct esas2r_adapter *a)\r\n{\r\nu32 doorbell;\r\nif (likely(a->int_stat & MU_INTSTAT_POST_OUT)) {\r\nesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\r\nMU_OLIS_INT);\r\nesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\r\nesas2r_get_outbound_responses(a);\r\n}\r\nif (unlikely(a->int_stat & MU_INTSTAT_DRBL)) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell != 0)\r\nesas2r_doorbell_interrupt(a, doorbell);\r\n}\r\na->int_mask = ESAS2R_INT_STS_MASK;\r\nesas2r_enable_chip_interrupts(a);\r\nif (likely(atomic_read(&a->disable_cnt) == 0))\r\nesas2r_do_deferred_processes(a);\r\n}\r\nirqreturn_t esas2r_msi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)dev_id;\r\nu32 intstat;\r\nu32 doorbell;\r\nintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\r\nif (likely(intstat & MU_INTSTAT_POST_OUT)) {\r\nesas2r_write_register_dword(a, MU_OUT_LIST_INT_STAT,\r\nMU_OLIS_INT);\r\nesas2r_flush_register_dword(a, MU_OUT_LIST_INT_STAT);\r\nesas2r_get_outbound_responses(a);\r\n}\r\nif (unlikely(intstat & MU_INTSTAT_DRBL)) {\r\ndoorbell = esas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nif (doorbell != 0)\r\nesas2r_doorbell_interrupt(a, doorbell);\r\n}\r\nesas2r_disable_chip_interrupts(a);\r\nesas2r_enable_chip_interrupts(a);\r\nif (likely(atomic_read(&a->disable_cnt) == 0))\r\nesas2r_do_deferred_processes(a);\r\nesas2r_do_tasklet_tasks(a);\r\nreturn 1;\r\n}\r\nstatic void esas2r_handle_outbound_rsp_err(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq,\r\nstruct atto_vda_ob_rsp *rsp)\r\n{\r\nif (unlikely(rq->req_stat != RS_SUCCESS)) {\r\nmemcpy(&rq->func_rsp, &rsp->func_rsp, sizeof(rsp->func_rsp));\r\nif (rq->req_stat == RS_ABORTED) {\r\nif (rq->timeout > RQ_MAX_TIMEOUT)\r\nrq->req_stat = RS_TIMEOUT;\r\n} else if (rq->req_stat == RS_SCSI_ERROR) {\r\nu8 scsistatus = rq->func_rsp.scsi_rsp.scsi_stat;\r\nesas2r_trace("scsistatus: %x", scsistatus);\r\nif (scsistatus == SAM_STAT_GOOD || scsistatus ==\r\nSAM_STAT_CONDITION_MET || scsistatus ==\r\nSAM_STAT_INTERMEDIATE || scsistatus ==\r\nSAM_STAT_INTERMEDIATE_CONDITION_MET) {\r\nrq->req_stat = RS_SUCCESS;\r\nrq->func_rsp.scsi_rsp.scsi_stat =\r\nSAM_STAT_GOOD;\r\n}\r\n}\r\n}\r\n}\r\nstatic void esas2r_get_outbound_responses(struct esas2r_adapter *a)\r\n{\r\nstruct atto_vda_ob_rsp *rsp;\r\nu32 rspput_ptr;\r\nu32 rspget_ptr;\r\nstruct esas2r_request *rq;\r\nu32 handle;\r\nunsigned long flags;\r\nLIST_HEAD(comp_list);\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nrspput_ptr = le32_to_cpu(*a->outbound_copy) & MU_OLC_WRT_PTR;\r\nrspget_ptr = a->last_read;\r\nesas2r_trace("rspput_ptr: %x, rspget_ptr: %x", rspput_ptr, rspget_ptr);\r\nif (unlikely(rspget_ptr == rspput_ptr)) {\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\nif (unlikely(rspput_ptr >= a->list_size)) {\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_bugon();\r\nesas2r_local_reset_adapter(a);\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\ndo {\r\nrspget_ptr++;\r\nif (rspget_ptr >= a->list_size)\r\nrspget_ptr = 0;\r\nrsp = (struct atto_vda_ob_rsp *)a->outbound_list_md.virt_addr\r\n+ rspget_ptr;\r\nhandle = rsp->handle;\r\nif (unlikely(LOWORD(handle) == 0\r\n|| LOWORD(handle) > num_requests +\r\nnum_ae_requests + 1)) {\r\nesas2r_bugon();\r\ncontinue;\r\n}\r\nrq = a->req_table[LOWORD(handle)];\r\nif (unlikely(rq == NULL || rq->vrq->scsi.handle != handle)) {\r\nesas2r_bugon();\r\ncontinue;\r\n}\r\nlist_del(&rq->req_list);\r\nrq->req_stat = rsp->req_stat;\r\nesas2r_trace("handle: %x", handle);\r\nesas2r_trace("rq: %p", rq);\r\nesas2r_trace("req_status: %x", rq->req_stat);\r\nif (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)) {\r\nesas2r_handle_outbound_rsp_err(a, rq, rsp);\r\n} else {\r\nmemcpy(&rq->func_rsp, &rsp->func_rsp,\r\nsizeof(rsp->func_rsp));\r\n}\r\nlist_add_tail(&rq->comp_list, &comp_list);\r\n} while (rspget_ptr != rspput_ptr);\r\na->last_read = rspget_ptr;\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_comp_list_drain(a, &comp_list);\r\nesas2r_trace_exit();\r\n}\r\nvoid esas2r_do_deferred_processes(struct esas2r_adapter *a)\r\n{\r\nint startreqs = 2;\r\nstruct esas2r_request *rq;\r\nunsigned long flags;\r\nif (test_bit(AF_CHPRST_PENDING, &a->flags) ||\r\ntest_bit(AF_FLASHING, &a->flags))\r\nstartreqs = 0;\r\nelse if (test_bit(AF_DISC_PENDING, &a->flags))\r\nstartreqs = 1;\r\natomic_inc(&a->disable_cnt);\r\nif (esas2r_is_tasklet_pending(a)) {\r\nesas2r_schedule_tasklet(a);\r\nstartreqs = 0;\r\n}\r\nif (startreqs && !list_empty(&a->defer_list)) {\r\nLIST_HEAD(comp_list);\r\nstruct list_head *element, *next;\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nlist_for_each_safe(element, next, &a->defer_list) {\r\nrq = list_entry(element, struct esas2r_request,\r\nreq_list);\r\nif (rq->req_stat != RS_PENDING) {\r\nlist_del(element);\r\nlist_add_tail(&rq->comp_list, &comp_list);\r\n}\r\nelse if (rq->req_type == RT_DISC_REQ) {\r\nlist_del(element);\r\nesas2r_disc_local_start_request(a, rq);\r\n} else if (startreqs == 2) {\r\nlist_del(element);\r\nesas2r_local_start_request(a, rq);\r\nif (test_bit(AF_FLASHING, &a->flags))\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_comp_list_drain(a, &comp_list);\r\n}\r\natomic_dec(&a->disable_cnt);\r\n}\r\nvoid esas2r_process_adapter_reset(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_request *rq = &a->general_req;\r\nunsigned long flags;\r\nstruct esas2r_disc_context *dc;\r\nLIST_HEAD(comp_list);\r\nstruct list_head *element;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nif (rq->interrupt_cx) {\r\ndc = (struct esas2r_disc_context *)rq->interrupt_cx;\r\ndc->disc_evt = 0;\r\nclear_bit(AF_DISC_IN_PROG, &a->flags);\r\n}\r\nrq->interrupt_cx = NULL;\r\nrq->interrupt_cb = NULL;\r\nrq->comp_cb = esas2r_dummy_complete;\r\n*a->outbound_copy =\r\na->last_write =\r\na->last_read = a->list_size - 1;\r\nset_bit(AF_COMM_LIST_TOGGLE, &a->flags);\r\nlist_for_each(element, &a->defer_list) {\r\nrq = list_entry(element, struct esas2r_request, req_list);\r\nif (rq->req_stat == RS_STARTED)\r\nif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\r\nlist_add_tail(&rq->comp_list, &comp_list);\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_comp_list_drain(a, &comp_list);\r\nesas2r_process_bus_reset(a);\r\nesas2r_trace_exit();\r\n}\r\nstatic void esas2r_process_bus_reset(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_request *rq;\r\nstruct list_head *element;\r\nunsigned long flags;\r\nLIST_HEAD(comp_list);\r\nesas2r_trace_enter();\r\nesas2r_hdebug("reset detected");\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nlist_for_each(element, &a->defer_list) {\r\nrq = list_entry(element, struct esas2r_request, req_list);\r\nif (esas2r_ioreq_aborted(a, rq, RS_ABORTED))\r\nlist_add_tail(&rq->comp_list, &comp_list);\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nesas2r_comp_list_drain(a, &comp_list);\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\nclear_bit(AF_OS_RESET, &a->flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic void esas2r_chip_rst_needed_during_tasklet(struct esas2r_adapter *a)\r\n{\r\nclear_bit(AF_CHPRST_NEEDED, &a->flags);\r\nclear_bit(AF_BUSRST_NEEDED, &a->flags);\r\nclear_bit(AF_BUSRST_DETECTED, &a->flags);\r\nclear_bit(AF_BUSRST_PENDING, &a->flags);\r\nif (!esas2r_is_adapter_present(a) || (a->chip_uptime >=\r\nESAS2R_CHP_UPTIME_MAX)) {\r\nesas2r_hdebug("*** adapter disabled ***");\r\nset_bit(AF_DEGRADED_MODE, &a->flags);\r\nset_bit(AF_DISABLED, &a->flags);\r\nclear_bit(AF_CHPRST_PENDING, &a->flags);\r\nclear_bit(AF_DISC_PENDING, &a->flags);\r\nesas2r_disable_chip_interrupts(a);\r\na->int_mask = 0;\r\nesas2r_process_adapter_reset(a);\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"Adapter disabled because of hardware failure");\r\n} else {\r\nbool alrdyrst = test_and_set_bit(AF_CHPRST_STARTED, &a->flags);\r\nif (!alrdyrst)\r\nesas2r_disable_chip_interrupts(a);\r\nif ((test_bit(AF_POWER_MGT, &a->flags)) &&\r\n!test_bit(AF_FIRST_INIT, &a->flags) && !alrdyrst) {\r\n} else {\r\nesas2r_hdebug("*** resetting chip ***");\r\nesas2r_reset_chip(a);\r\n}\r\na->chip_uptime += ESAS2R_CHP_UPTIME_CNT;\r\na->chip_init_time = jiffies_to_msecs(jiffies);\r\nif (!test_bit(AF_POWER_MGT, &a->flags)) {\r\nesas2r_process_adapter_reset(a);\r\nif (!alrdyrst) {\r\na->prev_dev_cnt =\r\nesas2r_targ_db_get_tgt_cnt(a);\r\nesas2r_targ_db_remove_all(a, false);\r\n}\r\n}\r\na->int_mask = 0;\r\n}\r\n}\r\nstatic void esas2r_handle_chip_rst_during_tasklet(struct esas2r_adapter *a)\r\n{\r\nwhile (test_bit(AF_CHPRST_DETECTED, &a->flags)) {\r\nif (!test_bit(AF_DEGRADED_MODE, &a->flags) &&\r\n!test_bit(AF_POWER_MGT, &a->flags))\r\nesas2r_disable_chip_interrupts(a);\r\nesas2r_check_adapter(a);\r\nesas2r_init_adapter_hw(a, 0);\r\nif (test_bit(AF_CHPRST_NEEDED, &a->flags))\r\nbreak;\r\nif (test_bit(AF_POWER_MGT, &a->flags)) {\r\nif (test_bit(AF_FIRST_INIT, &a->flags)) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"The firmware was reset during a normal power-up sequence");\r\n} else {\r\nclear_bit(AF_POWER_MGT, &a->flags);\r\nesas2r_send_reset_ae(a, true);\r\n}\r\n} else {\r\nif (test_bit(AF_FIRST_INIT, &a->flags)) {\r\n} else {\r\nesas2r_send_reset_ae(a, false);\r\n}\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"Recovering from a chip reset while the chip was online");\r\n}\r\nclear_bit(AF_CHPRST_STARTED, &a->flags);\r\nesas2r_enable_chip_interrupts(a);\r\nclear_bit(AF_CHPRST_DETECTED, &a->flags);\r\n}\r\n}\r\nvoid esas2r_do_tasklet_tasks(struct esas2r_adapter *a)\r\n{\r\nif (test_bit(AF_CHPRST_NEEDED, &a->flags) ||\r\ntest_bit(AF_CHPRST_DETECTED, &a->flags)) {\r\nif (test_bit(AF_CHPRST_NEEDED, &a->flags))\r\nesas2r_chip_rst_needed_during_tasklet(a);\r\nesas2r_handle_chip_rst_during_tasklet(a);\r\n}\r\nif (test_bit(AF_BUSRST_NEEDED, &a->flags)) {\r\nesas2r_hdebug("hard resetting bus");\r\nclear_bit(AF_BUSRST_NEEDED, &a->flags);\r\nif (test_bit(AF_FLASHING, &a->flags))\r\nset_bit(AF_BUSRST_DETECTED, &a->flags);\r\nelse\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN,\r\nDRBL_RESET_BUS);\r\n}\r\nif (test_bit(AF_BUSRST_DETECTED, &a->flags)) {\r\nesas2r_process_bus_reset(a);\r\nesas2r_log_dev(ESAS2R_LOG_WARN,\r\n&(a->host->shost_gendev),\r\n"scsi_report_bus_reset() called");\r\nscsi_report_bus_reset(a->host, 0);\r\nclear_bit(AF_BUSRST_DETECTED, &a->flags);\r\nclear_bit(AF_BUSRST_PENDING, &a->flags);\r\nesas2r_log(ESAS2R_LOG_WARN, "Bus reset complete");\r\n}\r\nif (test_bit(AF_PORT_CHANGE, &a->flags)) {\r\nclear_bit(AF_PORT_CHANGE, &a->flags);\r\nesas2r_targ_db_report_changes(a);\r\n}\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\n}\r\nstatic void esas2r_doorbell_interrupt(struct esas2r_adapter *a, u32 doorbell)\r\n{\r\nif (!(doorbell & DRBL_FORCE_INT)) {\r\nesas2r_trace_enter();\r\nesas2r_trace("doorbell: %x", doorbell);\r\n}\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT, doorbell);\r\nif (doorbell & DRBL_RESET_BUS)\r\nset_bit(AF_BUSRST_DETECTED, &a->flags);\r\nif (doorbell & DRBL_FORCE_INT)\r\nclear_bit(AF_HEARTBEAT, &a->flags);\r\nif (doorbell & DRBL_PANIC_REASON_MASK) {\r\nesas2r_hdebug("*** Firmware Panic ***");\r\nesas2r_log(ESAS2R_LOG_CRIT, "The firmware has panicked");\r\n}\r\nif (doorbell & DRBL_FW_RESET) {\r\nset_bit(AF2_COREDUMP_AVAIL, &a->flags2);\r\nesas2r_local_reset_adapter(a);\r\n}\r\nif (!(doorbell & DRBL_FORCE_INT))\r\nesas2r_trace_exit();\r\n}\r\nvoid esas2r_force_interrupt(struct esas2r_adapter *a)\r\n{\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN, DRBL_FORCE_INT |\r\nDRBL_DRV_VER);\r\n}\r\nstatic void esas2r_lun_event(struct esas2r_adapter *a, union atto_vda_ae *ae,\r\nu16 target, u32 length)\r\n{\r\nstruct esas2r_target *t = a->targetdb + target;\r\nu32 cplen = length;\r\nunsigned long flags;\r\nif (cplen > sizeof(t->lu_event))\r\ncplen = sizeof(t->lu_event);\r\nesas2r_trace("ae->lu.dwevent: %x", ae->lu.dwevent);\r\nesas2r_trace("ae->lu.bystate: %x", ae->lu.bystate);\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nt->new_target_state = TS_INVALID;\r\nif (ae->lu.dwevent & VDAAE_LU_LOST) {\r\nt->new_target_state = TS_NOT_PRESENT;\r\n} else {\r\nswitch (ae->lu.bystate) {\r\ncase VDAAE_LU_NOT_PRESENT:\r\ncase VDAAE_LU_OFFLINE:\r\ncase VDAAE_LU_DELETED:\r\ncase VDAAE_LU_FACTORY_DISABLED:\r\nt->new_target_state = TS_NOT_PRESENT;\r\nbreak;\r\ncase VDAAE_LU_ONLINE:\r\ncase VDAAE_LU_DEGRADED:\r\nt->new_target_state = TS_PRESENT;\r\nbreak;\r\n}\r\n}\r\nif (t->new_target_state != TS_INVALID) {\r\nmemcpy(&t->lu_event, &ae->lu, cplen);\r\nesas2r_disc_queue_event(a, DCDE_DEV_CHANGE);\r\n}\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\n}\r\nvoid esas2r_ae_complete(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{\r\nunion atto_vda_ae *ae =\r\n(union atto_vda_ae *)rq->vda_rsp_data->ae_data.event_data;\r\nu32 length = le32_to_cpu(rq->func_rsp.ae_rsp.length);\r\nunion atto_vda_ae *last =\r\n(union atto_vda_ae *)(rq->vda_rsp_data->ae_data.event_data\r\n+ length);\r\nesas2r_trace_enter();\r\nesas2r_trace("length: %d", length);\r\nif (length > sizeof(struct atto_vda_ae_data)\r\n|| (length & 3) != 0\r\n|| length == 0) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"The AE request response length (%p) is too long: %d",\r\nrq, length);\r\nesas2r_hdebug("aereq->length (0x%x) too long", length);\r\nesas2r_bugon();\r\nlast = ae;\r\n}\r\nwhile (ae < last) {\r\nu16 target;\r\nesas2r_trace("ae: %p", ae);\r\nesas2r_trace("ae->hdr: %p", &(ae->hdr));\r\nlength = ae->hdr.bylength;\r\nif (length > (u32)((u8 *)last - (u8 *)ae)\r\n|| (length & 3) != 0\r\n|| length == 0) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"the async event length is invalid (%p): %d",\r\nae, length);\r\nesas2r_hdebug("ae->hdr.length (0x%x) invalid", length);\r\nesas2r_bugon();\r\nbreak;\r\n}\r\nesas2r_nuxi_ae_data(ae);\r\nesas2r_queue_fw_event(a, fw_event_vda_ae, ae,\r\nsizeof(union atto_vda_ae));\r\nswitch (ae->hdr.bytype) {\r\ncase VDAAE_HDR_TYPE_RAID:\r\nif (ae->raid.dwflags & (VDAAE_GROUP_STATE\r\n| VDAAE_RBLD_STATE\r\n| VDAAE_MEMBER_CHG\r\n| VDAAE_PART_CHG)) {\r\nesas2r_log(ESAS2R_LOG_INFO,\r\n"RAID event received - name:%s rebuild_state:%d group_state:%d",\r\nae->raid.acname,\r\nae->raid.byrebuild_state,\r\nae->raid.bygroup_state);\r\n}\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LU:\r\nesas2r_log(ESAS2R_LOG_INFO,\r\n"LUN event received: event:%d target_id:%d LUN:%d state:%d",\r\nae->lu.dwevent,\r\nae->lu.id.tgtlun.wtarget_id,\r\nae->lu.id.tgtlun.bylun,\r\nae->lu.bystate);\r\ntarget = ae->lu.id.tgtlun.wtarget_id;\r\nif (target < ESAS2R_MAX_TARGETS)\r\nesas2r_lun_event(a, ae, target, length);\r\nbreak;\r\ncase VDAAE_HDR_TYPE_DISK:\r\nesas2r_log(ESAS2R_LOG_INFO, "Disk event received");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nae = (union atto_vda_ae *)((u8 *)ae + length);\r\n}\r\nesas2r_start_ae_request(a, rq);\r\nesas2r_trace_exit();\r\n}\r\nvoid esas2r_send_reset_ae(struct esas2r_adapter *a, bool pwr_mgt)\r\n{\r\nstruct atto_vda_ae_hdr ae;\r\nif (pwr_mgt)\r\nae.bytype = VDAAE_HDR_TYPE_PWRMGT;\r\nelse\r\nae.bytype = VDAAE_HDR_TYPE_RESET;\r\nae.byversion = VDAAE_HDR_VER_0;\r\nae.byflags = 0;\r\nae.bylength = (u8)sizeof(struct atto_vda_ae_hdr);\r\nif (pwr_mgt)\r\nesas2r_hdebug("*** sending power management AE ***");\r\nelse\r\nesas2r_hdebug("*** sending reset AE ***");\r\nesas2r_queue_fw_event(a, fw_event_vda_ae, &ae,\r\nsizeof(union atto_vda_ae));\r\n}\r\nvoid esas2r_dummy_complete(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{}\r\nstatic void esas2r_check_req_rsp_sense(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nu8 snslen, snslen2;\r\nsnslen = snslen2 = rq->func_rsp.scsi_rsp.sense_len;\r\nif (snslen > rq->sense_len)\r\nsnslen = rq->sense_len;\r\nif (snslen) {\r\nif (rq->sense_buf)\r\nmemcpy(rq->sense_buf, rq->data_buf, snslen);\r\nelse\r\nrq->sense_buf = (u8 *)rq->data_buf;\r\nif (snslen2 > 0x0c) {\r\nu8 *s = (u8 *)rq->data_buf;\r\nesas2r_trace_enter();\r\nif (s[0x0c] == 0x3f && s[0x0d] == 0x0E) {\r\nesas2r_trace("rq->target_id: %d",\r\nrq->target_id);\r\nesas2r_target_state_changed(a, rq->target_id,\r\nTS_LUN_CHANGE);\r\n}\r\nesas2r_trace("add_sense_key=%x", s[0x0c]);\r\nesas2r_trace("add_sense_qual=%x", s[0x0d]);\r\nesas2r_trace_exit();\r\n}\r\n}\r\nrq->sense_len = snslen;\r\n}\r\nvoid esas2r_complete_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nif (rq->vrq->scsi.function == VDA_FUNC_FLASH\r\n&& rq->vrq->flash.sub_func == VDA_FLASH_COMMIT)\r\nclear_bit(AF_FLASHING, &a->flags);\r\nif (rq->interrupt_cb) {\r\n(*rq->interrupt_cb)(a, rq);\r\nif (rq->req_stat == RS_PENDING) {\r\nesas2r_start_request(a, rq);\r\nreturn;\r\n}\r\n}\r\nif (likely(rq->vrq->scsi.function == VDA_FUNC_SCSI)\r\n&& unlikely(rq->req_stat != RS_SUCCESS)) {\r\nesas2r_check_req_rsp_sense(a, rq);\r\nesas2r_log_request_failure(a, rq);\r\n}\r\n(*rq->comp_cb)(a, rq);\r\n}
