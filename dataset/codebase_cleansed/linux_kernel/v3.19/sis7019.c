static void sis_update_sso(struct voice *voice, u16 period)\r\n{\r\nvoid __iomem *base = voice->ctrl_base;\r\nvoice->sso += period;\r\nif (voice->sso >= voice->buffer_size)\r\nvoice->sso -= voice->buffer_size;\r\nif (voice->sso < 8)\r\nvoice->sso = 8;\r\nwritew(voice->sso & 0xffff, base + SIS_PLAY_DMA_SSO_ESO + 2);\r\n}\r\nstatic void sis_update_voice(struct voice *voice)\r\n{\r\nif (voice->flags & VOICE_SSO_TIMING) {\r\nsis_update_sso(voice, voice->period_size);\r\n} else if (voice->flags & VOICE_SYNC_TIMING) {\r\nint sync;\r\nif (voice->vperiod > voice->period_size) {\r\nvoice->vperiod -= voice->period_size;\r\nif (voice->vperiod < voice->period_size)\r\nsis_update_sso(voice, voice->vperiod);\r\nelse\r\nsis_update_sso(voice, voice->period_size);\r\nreturn;\r\n}\r\nsync = voice->sync_cso;\r\nsync -= readw(voice->sync_base + SIS_CAPTURE_DMA_FORMAT_CSO);\r\nif (sync > (voice->sync_buffer_size / 2))\r\nsync -= voice->sync_buffer_size;\r\nif (sync > 0) {\r\nif (sync < 16)\r\nsync = 16;\r\nsis_update_sso(voice, sync);\r\nreturn;\r\n}\r\nif (sync > -9)\r\nvoice->vperiod = voice->sync_period_size + 1;\r\nelse\r\nvoice->vperiod = voice->sync_period_size + sync + 10;\r\nif (voice->vperiod < voice->buffer_size) {\r\nsis_update_sso(voice, voice->vperiod);\r\nvoice->vperiod = 0;\r\n} else\r\nsis_update_sso(voice, voice->period_size);\r\nsync = voice->sync_cso + voice->sync_period_size;\r\nif (sync >= voice->sync_buffer_size)\r\nsync -= voice->sync_buffer_size;\r\nvoice->sync_cso = sync;\r\n}\r\nsnd_pcm_period_elapsed(voice->substream);\r\n}\r\nstatic void sis_voice_irq(u32 status, struct voice *voice)\r\n{\r\nint bit;\r\nwhile (status) {\r\nbit = __ffs(status);\r\nstatus >>= bit + 1;\r\nvoice += bit;\r\nsis_update_voice(voice);\r\nvoice++;\r\n}\r\n}\r\nstatic irqreturn_t sis_interrupt(int irq, void *dev)\r\n{\r\nstruct sis7019 *sis = dev;\r\nunsigned long io = sis->ioport;\r\nstruct voice *voice;\r\nu32 intr, status;\r\nintr = inl(io + SIS_GISR);\r\nintr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |\r\nSIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;\r\nif (!intr)\r\nreturn IRQ_NONE;\r\ndo {\r\nstatus = inl(io + SIS_PISR_A);\r\nif (status) {\r\nsis_voice_irq(status, sis->voices);\r\noutl(status, io + SIS_PISR_A);\r\n}\r\nstatus = inl(io + SIS_PISR_B);\r\nif (status) {\r\nsis_voice_irq(status, &sis->voices[32]);\r\noutl(status, io + SIS_PISR_B);\r\n}\r\nstatus = inl(io + SIS_RISR);\r\nif (status) {\r\nvoice = &sis->capture_voice;\r\nif (!voice->timing)\r\nsnd_pcm_period_elapsed(voice->substream);\r\noutl(status, io + SIS_RISR);\r\n}\r\noutl(intr, io + SIS_GISR);\r\nintr = inl(io + SIS_GISR);\r\nintr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |\r\nSIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;\r\n} while (intr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 sis_rate_to_delta(unsigned int rate)\r\n{\r\nu32 delta;\r\nif (rate == 44100)\r\ndelta = 0xeb3;\r\nelse if (rate == 8000)\r\ndelta = 0x2ab;\r\nelse if (rate == 48000)\r\ndelta = 0x1000;\r\nelse\r\ndelta = (((rate << 12) + 24000) / 48000) & 0x0000ffff;\r\nreturn delta;\r\n}\r\nstatic void __sis_map_silence(struct sis7019 *sis)\r\n{\r\nif (!sis->silence_users)\r\nsis->silence_dma_addr = pci_map_single(sis->pci,\r\nsis->suspend_state[0],\r\n4096, PCI_DMA_TODEVICE);\r\nsis->silence_users++;\r\n}\r\nstatic void __sis_unmap_silence(struct sis7019 *sis)\r\n{\r\nsis->silence_users--;\r\nif (!sis->silence_users)\r\npci_unmap_single(sis->pci, sis->silence_dma_addr, 4096,\r\nPCI_DMA_TODEVICE);\r\n}\r\nstatic void sis_free_voice(struct sis7019 *sis, struct voice *voice)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sis->voice_lock, flags);\r\nif (voice->timing) {\r\n__sis_unmap_silence(sis);\r\nvoice->timing->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING |\r\nVOICE_SYNC_TIMING);\r\nvoice->timing = NULL;\r\n}\r\nvoice->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING | VOICE_SYNC_TIMING);\r\nspin_unlock_irqrestore(&sis->voice_lock, flags);\r\n}\r\nstatic struct voice *__sis_alloc_playback_voice(struct sis7019 *sis)\r\n{\r\nstruct voice *voice;\r\nint i;\r\nfor (i = 0; i < 64; i++) {\r\nvoice = &sis->voices[i];\r\nif (voice->flags & VOICE_IN_USE)\r\ncontinue;\r\nvoice->flags |= VOICE_IN_USE;\r\ngoto found_one;\r\n}\r\nvoice = NULL;\r\nfound_one:\r\nreturn voice;\r\n}\r\nstatic struct voice *sis_alloc_playback_voice(struct sis7019 *sis)\r\n{\r\nstruct voice *voice;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sis->voice_lock, flags);\r\nvoice = __sis_alloc_playback_voice(sis);\r\nspin_unlock_irqrestore(&sis->voice_lock, flags);\r\nreturn voice;\r\n}\r\nstatic int sis_alloc_timing_voice(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = runtime->private_data;\r\nunsigned int period_size, buffer_size;\r\nunsigned long flags;\r\nint needed;\r\nperiod_size = params_period_size(hw_params);\r\nbuffer_size = params_buffer_size(hw_params);\r\nneeded = (period_size != buffer_size &&\r\nperiod_size != (buffer_size / 2));\r\nif (needed && !voice->timing) {\r\nspin_lock_irqsave(&sis->voice_lock, flags);\r\nvoice->timing = __sis_alloc_playback_voice(sis);\r\nif (voice->timing)\r\n__sis_map_silence(sis);\r\nspin_unlock_irqrestore(&sis->voice_lock, flags);\r\nif (!voice->timing)\r\nreturn -ENOMEM;\r\nvoice->timing->substream = substream;\r\n} else if (!needed && voice->timing) {\r\nsis_free_voice(sis, voice);\r\nvoice->timing = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sis_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice;\r\nvoice = sis_alloc_playback_voice(sis);\r\nif (!voice)\r\nreturn -EAGAIN;\r\nvoice->substream = substream;\r\nruntime->private_data = voice;\r\nruntime->hw = sis_playback_hw_info;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n9, 0xfff9);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n9, 0xfff9);\r\nsnd_pcm_set_sync(substream);\r\nreturn 0;\r\n}\r\nstatic int sis_substream_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = runtime->private_data;\r\nsis_free_voice(sis, voice);\r\nreturn 0;\r\n}\r\nstatic int sis_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int sis_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int sis_pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = runtime->private_data;\r\nvoid __iomem *ctrl_base = voice->ctrl_base;\r\nvoid __iomem *wave_base = voice->wave_base;\r\nu32 format, dma_addr, control, sso_eso, delta, reg;\r\nu16 leo;\r\nformat = 0;\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nformat |= SIS_PLAY_DMA_FORMAT_8BIT;\r\nif (!snd_pcm_format_signed(runtime->format))\r\nformat |= SIS_PLAY_DMA_FORMAT_UNSIGNED;\r\nif (runtime->channels == 1)\r\nformat |= SIS_PLAY_DMA_FORMAT_MONO;\r\ndma_addr = runtime->dma_addr;\r\nleo = runtime->buffer_size - 1;\r\ncontrol = leo | SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_LEO;\r\nsso_eso = leo;\r\nif (runtime->period_size == (runtime->buffer_size / 2)) {\r\ncontrol |= SIS_PLAY_DMA_INTR_AT_MLP;\r\n} else if (runtime->period_size != runtime->buffer_size) {\r\nvoice->flags |= VOICE_SSO_TIMING;\r\nvoice->sso = runtime->period_size - 1;\r\nvoice->period_size = runtime->period_size;\r\nvoice->buffer_size = runtime->buffer_size;\r\ncontrol &= ~SIS_PLAY_DMA_INTR_AT_LEO;\r\ncontrol |= SIS_PLAY_DMA_INTR_AT_SSO;\r\nsso_eso |= (runtime->period_size - 1) << 16;\r\n}\r\ndelta = sis_rate_to_delta(runtime->rate);\r\nwritel(format, ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);\r\nwritel(dma_addr, ctrl_base + SIS_PLAY_DMA_BASE);\r\nwritel(control, ctrl_base + SIS_PLAY_DMA_CONTROL);\r\nwritel(sso_eso, ctrl_base + SIS_PLAY_DMA_SSO_ESO);\r\nfor (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)\r\nwritel(0, wave_base + reg);\r\nwritel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);\r\nwritel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);\r\nwritel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |\r\nSIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |\r\nSIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,\r\nwave_base + SIS_WAVE_CHANNEL_CONTROL);\r\nreadl(ctrl_base);\r\nreturn 0;\r\n}\r\nstatic int sis_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nunsigned long io = sis->ioport;\r\nstruct snd_pcm_substream *s;\r\nstruct voice *voice;\r\nvoid *chip;\r\nint starting;\r\nu32 record = 0;\r\nu32 play[2] = { 0, 0 };\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nstarting = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nstarting = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nchip = snd_pcm_substream_chip(s);\r\nif (chip != sis)\r\ncontinue;\r\nvoice = s->runtime->private_data;\r\nif (voice->flags & VOICE_CAPTURE) {\r\nrecord |= 1 << voice->num;\r\nvoice = voice->timing;\r\n}\r\nif (voice)\r\nplay[voice->num / 32] |= 1 << (voice->num & 0x1f);\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nif (starting) {\r\nif (record)\r\noutl(record, io + SIS_RECORD_START_REG);\r\nif (play[0])\r\noutl(play[0], io + SIS_PLAY_START_A_REG);\r\nif (play[1])\r\noutl(play[1], io + SIS_PLAY_START_B_REG);\r\n} else {\r\nif (record)\r\noutl(record, io + SIS_RECORD_STOP_REG);\r\nif (play[0])\r\noutl(play[0], io + SIS_PLAY_STOP_A_REG);\r\nif (play[1])\r\noutl(play[1], io + SIS_PLAY_STOP_B_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t sis_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = runtime->private_data;\r\nu32 cso;\r\ncso = readl(voice->ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);\r\ncso &= 0xffff;\r\nreturn cso;\r\n}\r\nstatic int sis_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = &sis->capture_voice;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sis->voice_lock, flags);\r\nif (voice->flags & VOICE_IN_USE)\r\nvoice = NULL;\r\nelse\r\nvoice->flags |= VOICE_IN_USE;\r\nspin_unlock_irqrestore(&sis->voice_lock, flags);\r\nif (!voice)\r\nreturn -EAGAIN;\r\nvoice->substream = substream;\r\nruntime->private_data = voice;\r\nruntime->hw = sis_capture_hw_info;\r\nruntime->hw.rates = sis->ac97[0]->rates[AC97_RATES_ADC];\r\nsnd_pcm_limit_hw_rates(runtime);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n9, 0xfff9);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n9, 0xfff9);\r\nsnd_pcm_set_sync(substream);\r\nreturn 0;\r\n}\r\nstatic int sis_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nint rc;\r\nrc = snd_ac97_set_rate(sis->ac97[0], AC97_PCM_LR_ADC_RATE,\r\nparams_rate(hw_params));\r\nif (rc)\r\ngoto out;\r\nrc = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (rc < 0)\r\ngoto out;\r\nrc = sis_alloc_timing_voice(substream, hw_params);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void sis_prepare_timing_voice(struct voice *voice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct sis7019 *sis = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *timing = voice->timing;\r\nvoid __iomem *play_base = timing->ctrl_base;\r\nvoid __iomem *wave_base = timing->wave_base;\r\nu16 buffer_size, period_size;\r\nu32 format, control, sso_eso, delta;\r\nu32 vperiod, sso, reg;\r\nbuffer_size = 4096 / runtime->channels;\r\nbuffer_size /= snd_pcm_format_size(runtime->format, 1);\r\nperiod_size = buffer_size;\r\nvperiod = runtime->period_size + 12;\r\nif (vperiod > period_size) {\r\nu16 tail = vperiod % period_size;\r\nu16 quarter_period = period_size / 4;\r\nif (tail && tail < quarter_period) {\r\nu16 loops = vperiod / period_size;\r\ntail = quarter_period - tail;\r\ntail += loops - 1;\r\ntail /= loops;\r\nperiod_size -= tail;\r\n}\r\nsso = period_size - 1;\r\n} else {\r\nperiod_size = runtime->period_size;\r\nsso = vperiod - 1;\r\nvperiod = 0;\r\n}\r\ntiming->flags |= VOICE_SYNC_TIMING;\r\ntiming->sync_base = voice->ctrl_base;\r\ntiming->sync_cso = runtime->period_size;\r\ntiming->sync_period_size = runtime->period_size;\r\ntiming->sync_buffer_size = runtime->buffer_size;\r\ntiming->period_size = period_size;\r\ntiming->buffer_size = buffer_size;\r\ntiming->sso = sso;\r\ntiming->vperiod = vperiod;\r\nformat = 0;\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nformat = SIS_CAPTURE_DMA_FORMAT_8BIT;\r\nif (runtime->channels == 1)\r\nformat |= SIS_CAPTURE_DMA_FORMAT_MONO;\r\ncontrol = timing->buffer_size - 1;\r\ncontrol |= SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_SSO;\r\nsso_eso = timing->buffer_size - 1;\r\nsso_eso |= timing->sso << 16;\r\ndelta = sis_rate_to_delta(runtime->rate);\r\nwritel(format, play_base + SIS_PLAY_DMA_FORMAT_CSO);\r\nwritel(sis->silence_dma_addr, play_base + SIS_PLAY_DMA_BASE);\r\nwritel(control, play_base + SIS_PLAY_DMA_CONTROL);\r\nwritel(sso_eso, play_base + SIS_PLAY_DMA_SSO_ESO);\r\nfor (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)\r\nwritel(0, wave_base + reg);\r\nwritel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);\r\nwritel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);\r\nwritel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |\r\nSIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |\r\nSIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,\r\nwave_base + SIS_WAVE_CHANNEL_CONTROL);\r\n}\r\nstatic int sis_pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct voice *voice = runtime->private_data;\r\nvoid __iomem *rec_base = voice->ctrl_base;\r\nu32 format, dma_addr, control;\r\nu16 leo;\r\nformat = 0;\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nformat = SIS_CAPTURE_DMA_FORMAT_8BIT;\r\nif (!snd_pcm_format_signed(runtime->format))\r\nformat |= SIS_CAPTURE_DMA_FORMAT_UNSIGNED;\r\nif (runtime->channels == 1)\r\nformat |= SIS_CAPTURE_DMA_FORMAT_MONO;\r\ndma_addr = runtime->dma_addr;\r\nleo = runtime->buffer_size - 1;\r\ncontrol = leo | SIS_CAPTURE_DMA_LOOP;\r\nif (voice->timing) {\r\nsis_prepare_timing_voice(voice, substream);\r\n} else {\r\ncontrol |= SIS_CAPTURE_DMA_INTR_AT_LEO;\r\nif (runtime->period_size != runtime->buffer_size)\r\ncontrol |= SIS_CAPTURE_DMA_INTR_AT_MLP;\r\n}\r\nwritel(format, rec_base + SIS_CAPTURE_DMA_FORMAT_CSO);\r\nwritel(dma_addr, rec_base + SIS_CAPTURE_DMA_BASE);\r\nwritel(control, rec_base + SIS_CAPTURE_DMA_CONTROL);\r\nreadl(rec_base);\r\nreturn 0;\r\n}\r\nstatic int sis_pcm_create(struct sis7019 *sis)\r\n{\r\nstruct snd_pcm *pcm;\r\nint rc;\r\nrc = snd_pcm_new(sis->card, "SiS7019", 0, 64, 1, &pcm);\r\nif (rc)\r\nreturn rc;\r\npcm->private_data = sis;\r\nstrcpy(pcm->name, "SiS7019");\r\nsis->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sis_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sis_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(sis->pci), 64*1024, 128*1024);\r\nreturn 0;\r\n}\r\nstatic unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)\r\n{\r\nunsigned long io = sis->ioport;\r\nunsigned short val = 0xffff;\r\nu16 status;\r\nu16 rdy;\r\nint count;\r\nstatic const u16 codec_ready[3] = {\r\nSIS_AC97_STATUS_CODEC_READY,\r\nSIS_AC97_STATUS_CODEC2_READY,\r\nSIS_AC97_STATUS_CODEC3_READY,\r\n};\r\nrdy = codec_ready[codec];\r\nmutex_lock(&sis->ac97_mutex);\r\ncount = 0xffff;\r\nwhile ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)\r\nudelay(1);\r\nif (!count)\r\ngoto timeout;\r\ncount = 0xffff;\r\ndo {\r\nstatus = inw(io + SIS_AC97_STATUS);\r\nif ((status & rdy) && !(status & SIS_AC97_STATUS_BUSY))\r\nbreak;\r\nudelay(1);\r\n} while (--count);\r\nif (!count)\r\ngoto timeout_sema;\r\noutl(cmd, io + SIS_AC97_CMD);\r\nudelay(10);\r\ncount = 0xffff;\r\nwhile ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)\r\nudelay(1);\r\nval = inl(io + SIS_AC97_CMD) >> 16;\r\ntimeout_sema:\r\noutl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);\r\ntimeout:\r\nmutex_unlock(&sis->ac97_mutex);\r\nif (!count) {\r\ndev_err(&sis->pci->dev, "ac97 codec %d timeout cmd 0x%08x\n",\r\ncodec, cmd);\r\n}\r\nreturn val;\r\n}\r\nstatic void sis_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstatic const u32 cmd[3] = {\r\nSIS_AC97_CMD_CODEC_WRITE,\r\nSIS_AC97_CMD_CODEC2_WRITE,\r\nSIS_AC97_CMD_CODEC3_WRITE,\r\n};\r\nsis_ac97_rw(ac97->private_data, ac97->num,\r\n(val << 16) | (reg << 8) | cmd[ac97->num]);\r\n}\r\nstatic unsigned short sis_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstatic const u32 cmd[3] = {\r\nSIS_AC97_CMD_CODEC_READ,\r\nSIS_AC97_CMD_CODEC2_READ,\r\nSIS_AC97_CMD_CODEC3_READ,\r\n};\r\nreturn sis_ac97_rw(ac97->private_data, ac97->num,\r\n(reg << 8) | cmd[ac97->num]);\r\n}\r\nstatic int sis_mixer_create(struct sis7019 *sis)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = sis_ac97_write,\r\n.read = sis_ac97_read,\r\n};\r\nint rc;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = sis;\r\nrc = snd_ac97_bus(sis->card, 0, &ops, NULL, &bus);\r\nif (!rc && sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\r\nrc = snd_ac97_mixer(bus, &ac97, &sis->ac97[0]);\r\nac97.num = 1;\r\nif (!rc && (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT))\r\nrc = snd_ac97_mixer(bus, &ac97, &sis->ac97[1]);\r\nac97.num = 2;\r\nif (!rc && (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT))\r\nrc = snd_ac97_mixer(bus, &ac97, &sis->ac97[2]);\r\nreturn rc;\r\n}\r\nstatic void sis_free_suspend(struct sis7019 *sis)\r\n{\r\nint i;\r\nfor (i = 0; i < SIS_SUSPEND_PAGES; i++)\r\nkfree(sis->suspend_state[i]);\r\n}\r\nstatic int sis_chip_free(struct sis7019 *sis)\r\n{\r\noutl(SIS_GCR_SOFTWARE_RESET, sis->ioport + SIS_GCR);\r\nudelay(25);\r\noutl(0, sis->ioport + SIS_GCR);\r\noutl(0, sis->ioport + SIS_GIER);\r\nif (sis->irq >= 0)\r\nfree_irq(sis->irq, sis);\r\nif (sis->ioaddr)\r\niounmap(sis->ioaddr);\r\npci_release_regions(sis->pci);\r\npci_disable_device(sis->pci);\r\nsis_free_suspend(sis);\r\nreturn 0;\r\n}\r\nstatic int sis_dev_free(struct snd_device *dev)\r\n{\r\nstruct sis7019 *sis = dev->device_data;\r\nreturn sis_chip_free(sis);\r\n}\r\nstatic int sis_chip_init(struct sis7019 *sis)\r\n{\r\nunsigned long io = sis->ioport;\r\nvoid __iomem *ioaddr = sis->ioaddr;\r\nunsigned long timeout;\r\nu16 status;\r\nint count;\r\nint i;\r\noutl(SIS_GCR_SOFTWARE_RESET, io + SIS_GCR);\r\nudelay(25);\r\noutl(0, io + SIS_GCR);\r\ncount = 0xffff;\r\nwhile ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)\r\nudelay(1);\r\nif (!count)\r\nreturn -EIO;\r\noutl(SIS_AC97_CMD_CODEC_COLD_RESET, io + SIS_AC97_CMD);\r\nudelay(250);\r\ncount = 0xffff;\r\nwhile ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)\r\nudelay(1);\r\noutl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);\r\nif (!count)\r\nreturn -EIO;\r\nsis->codecs_present = 0;\r\ntimeout = msecs_to_jiffies(500) + jiffies;\r\nwhile (time_before_eq(jiffies, timeout)) {\r\nstatus = inl(io + SIS_AC97_STATUS);\r\nif (status & SIS_AC97_STATUS_CODEC_READY)\r\nsis->codecs_present |= SIS_PRIMARY_CODEC_PRESENT;\r\nif (status & SIS_AC97_STATUS_CODEC2_READY)\r\nsis->codecs_present |= SIS_SECONDARY_CODEC_PRESENT;\r\nif (status & SIS_AC97_STATUS_CODEC3_READY)\r\nsis->codecs_present |= SIS_TERTIARY_CODEC_PRESENT;\r\nif (sis->codecs_present == codecs)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!sis->codecs_present) {\r\ndev_err(&sis->pci->dev, "could not find any codecs\n");\r\nreturn -EIO;\r\n}\r\nif (sis->codecs_present != codecs) {\r\ndev_warn(&sis->pci->dev, "missing codecs, found %0x, expected %0x\n",\r\nsis->codecs_present, codecs);\r\n}\r\noutl(SIS_AC97_CONF_AUDIO_ALIVE, io + SIS_AC97_CONF);\r\noutl(SIS_AC97_CONF_AUDIO_ALIVE | SIS_AC97_CONF_PCM_LR_ENABLE |\r\nSIS_AC97_CONF_PCM_CAP_MIC_ENABLE |\r\nSIS_AC97_CONF_PCM_CAP_LR_ENABLE |\r\nSIS_AC97_CONF_CODEC_VRA_ENABLE, io + SIS_AC97_CONF);\r\noutl(0, io + SIS_AC97_PSR);\r\noutl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);\r\noutl(0, io + SIS_PLAY_SYNC_GROUP_A);\r\noutl(0, io + SIS_PLAY_SYNC_GROUP_B);\r\noutl(0, io + SIS_PLAY_SYNC_GROUP_C);\r\noutl(0, io + SIS_PLAY_SYNC_GROUP_D);\r\noutl(0, io + SIS_MIXER_SYNC_GROUP);\r\nfor (i = 0; i < 64; i++) {\r\nwritel(i, SIS_MIXER_START_ADDR(ioaddr, i));\r\nwritel(SIS_MIXER_RIGHT_NO_ATTEN | SIS_MIXER_LEFT_NO_ATTEN |\r\nSIS_MIXER_DEST_0, SIS_MIXER_ADDR(ioaddr, i));\r\n}\r\noutl(0xffff0000, io + SIS_WEVCR);\r\noutl(0, io + SIS_WECCR);\r\noutl(SIS_GIER_AUDIO_PLAY_DMA_IRQ_ENABLE |\r\nSIS_GIER_AUDIO_RECORD_DMA_IRQ_ENABLE, io + SIS_GIER);\r\nreturn 0;\r\n}\r\nstatic int sis_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct sis7019 *sis = card->private_data;\r\nvoid __iomem *ioaddr = sis->ioaddr;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(sis->pcm);\r\nif (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\r\nsnd_ac97_suspend(sis->ac97[0]);\r\nif (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)\r\nsnd_ac97_suspend(sis->ac97[1]);\r\nif (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)\r\nsnd_ac97_suspend(sis->ac97[2]);\r\nif (sis->irq >= 0) {\r\nfree_irq(sis->irq, sis);\r\nsis->irq = -1;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmemcpy_fromio(sis->suspend_state[i], ioaddr, 4096);\r\nioaddr += 4096;\r\n}\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int sis_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct sis7019 *sis = card->private_data;\r\nvoid __iomem *ioaddr = sis->ioaddr;\r\nint i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(&pci->dev, "unable to re-enable device\n");\r\ngoto error;\r\n}\r\nif (sis_chip_init(sis)) {\r\ndev_err(&pci->dev, "unable to re-init controller\n");\r\ngoto error;\r\n}\r\nif (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, sis)) {\r\ndev_err(&pci->dev, "unable to regain IRQ %d\n", pci->irq);\r\ngoto error;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmemcpy_toio(ioaddr, sis->suspend_state[i], 4096);\r\nioaddr += 4096;\r\n}\r\nmemset(sis->suspend_state[0], 0, 4096);\r\nsis->irq = pci->irq;\r\npci_set_master(pci);\r\nif (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\r\nsnd_ac97_resume(sis->ac97[0]);\r\nif (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)\r\nsnd_ac97_resume(sis->ac97[1]);\r\nif (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)\r\nsnd_ac97_resume(sis->ac97[2]);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\nerror:\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nstatic int sis_alloc_suspend(struct sis7019 *sis)\r\n{\r\nint i;\r\nfor (i = 0; i < SIS_SUSPEND_PAGES; i++) {\r\nsis->suspend_state[i] = kmalloc(4096, GFP_KERNEL);\r\nif (!sis->suspend_state[i])\r\nreturn -ENOMEM;\r\n}\r\nmemset(sis->suspend_state[0], 0, 4096);\r\nreturn 0;\r\n}\r\nstatic int sis_chip_create(struct snd_card *card,\r\nstruct pci_dev *pci)\r\n{\r\nstruct sis7019 *sis = card->private_data;\r\nstruct voice *voice;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = sis_dev_free,\r\n};\r\nint rc;\r\nint i;\r\nrc = pci_enable_device(pci);\r\nif (rc)\r\ngoto error_out;\r\nrc = pci_set_dma_mask(pci, DMA_BIT_MASK(30));\r\nif (rc < 0) {\r\ndev_err(&pci->dev, "architecture does not support 30-bit PCI busmaster DMA");\r\ngoto error_out_enabled;\r\n}\r\nmemset(sis, 0, sizeof(*sis));\r\nmutex_init(&sis->ac97_mutex);\r\nspin_lock_init(&sis->voice_lock);\r\nsis->card = card;\r\nsis->pci = pci;\r\nsis->irq = -1;\r\nsis->ioport = pci_resource_start(pci, 0);\r\nrc = pci_request_regions(pci, "SiS7019");\r\nif (rc) {\r\ndev_err(&pci->dev, "unable request regions\n");\r\ngoto error_out_enabled;\r\n}\r\nrc = -EIO;\r\nsis->ioaddr = ioremap_nocache(pci_resource_start(pci, 1), 0x4000);\r\nif (!sis->ioaddr) {\r\ndev_err(&pci->dev, "unable to remap MMIO, aborting\n");\r\ngoto error_out_cleanup;\r\n}\r\nrc = sis_alloc_suspend(sis);\r\nif (rc < 0) {\r\ndev_err(&pci->dev, "unable to allocate state storage\n");\r\ngoto error_out_cleanup;\r\n}\r\nrc = sis_chip_init(sis);\r\nif (rc)\r\ngoto error_out_cleanup;\r\nrc = request_irq(pci->irq, sis_interrupt, IRQF_SHARED, KBUILD_MODNAME,\r\nsis);\r\nif (rc) {\r\ndev_err(&pci->dev, "unable to allocate irq %d\n", sis->irq);\r\ngoto error_out_cleanup;\r\n}\r\nsis->irq = pci->irq;\r\npci_set_master(pci);\r\nfor (i = 0; i < 64; i++) {\r\nvoice = &sis->voices[i];\r\nvoice->num = i;\r\nvoice->ctrl_base = SIS_PLAY_DMA_ADDR(sis->ioaddr, i);\r\nvoice->wave_base = SIS_WAVE_ADDR(sis->ioaddr, i);\r\n}\r\nvoice = &sis->capture_voice;\r\nvoice->flags = VOICE_CAPTURE;\r\nvoice->num = SIS_CAPTURE_CHAN_AC97_PCM_IN;\r\nvoice->ctrl_base = SIS_CAPTURE_DMA_ADDR(sis->ioaddr, voice->num);\r\nrc = snd_device_new(card, SNDRV_DEV_LOWLEVEL, sis, &ops);\r\nif (rc)\r\ngoto error_out_cleanup;\r\nreturn 0;\r\nerror_out_cleanup:\r\nsis_chip_free(sis);\r\nerror_out_enabled:\r\npci_disable_device(pci);\r\nerror_out:\r\nreturn rc;\r\n}\r\nstatic int snd_sis7019_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct sis7019 *sis;\r\nint rc;\r\nrc = -ENOENT;\r\nif (!enable)\r\ngoto error_out;\r\ncodecs &= SIS_PRIMARY_CODEC_PRESENT | SIS_SECONDARY_CODEC_PRESENT |\r\nSIS_TERTIARY_CODEC_PRESENT;\r\nif (!codecs)\r\ncodecs = SIS_PRIMARY_CODEC_PRESENT;\r\nrc = snd_card_new(&pci->dev, index, id, THIS_MODULE,\r\nsizeof(*sis), &card);\r\nif (rc < 0)\r\ngoto error_out;\r\nstrcpy(card->driver, "SiS7019");\r\nstrcpy(card->shortname, "SiS7019");\r\nrc = sis_chip_create(card, pci);\r\nif (rc)\r\ngoto card_error_out;\r\nsis = card->private_data;\r\nrc = sis_mixer_create(sis);\r\nif (rc)\r\ngoto card_error_out;\r\nrc = sis_pcm_create(sis);\r\nif (rc)\r\ngoto card_error_out;\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s Audio Accelerator with %s at 0x%lx, irq %d",\r\ncard->shortname, snd_ac97_get_short_name(sis->ac97[0]),\r\nsis->ioport, sis->irq);\r\nrc = snd_card_register(card);\r\nif (rc)\r\ngoto card_error_out;\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\ncard_error_out:\r\nsnd_card_free(card);\r\nerror_out:\r\nreturn rc;\r\n}\r\nstatic void snd_sis7019_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
