static int adp1653_update_hw(struct adp1653_flash *flash)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nu8 out_sel;\r\nu8 config = 0;\r\nint rval;\r\nout_sel = ADP1653_INDICATOR_INTENSITY_uA_TO_REG(\r\nflash->indicator_intensity->val)\r\n<< ADP1653_REG_OUT_SEL_ILED_SHIFT;\r\nswitch (flash->led_mode->val) {\r\ncase V4L2_FLASH_LED_MODE_NONE:\r\nbreak;\r\ncase V4L2_FLASH_LED_MODE_FLASH:\r\nconfig = ADP1653_REG_CONFIG_TMR_CFG;\r\nconfig |= TIMEOUT_US_TO_CODE(flash->flash_timeout->val)\r\n<< ADP1653_REG_CONFIG_TMR_SET_SHIFT;\r\nbreak;\r\ncase V4L2_FLASH_LED_MODE_TORCH:\r\nout_sel |= ADP1653_FLASH_INTENSITY_mA_TO_REG(\r\nflash->torch_intensity->val)\r\n<< ADP1653_REG_OUT_SEL_HPLED_SHIFT;\r\nbreak;\r\n}\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, out_sel);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_CONFIG, config);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn 0;\r\n}\r\nstatic int adp1653_get_fault(struct adp1653_flash *flash)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint fault;\r\nint rval;\r\nfault = i2c_smbus_read_byte_data(client, ADP1653_REG_FAULT);\r\nif (IS_ERR_VALUE(fault))\r\nreturn fault;\r\nflash->fault |= fault;\r\nif (!flash->fault)\r\nreturn 0;\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, 0);\r\nif (IS_ERR_VALUE(rval))\r\nreturn rval;\r\nflash->led_mode->val = V4L2_FLASH_LED_MODE_NONE;\r\nrval = adp1653_update_hw(flash);\r\nif (IS_ERR_VALUE(rval))\r\nreturn rval;\r\nreturn flash->fault;\r\n}\r\nstatic int adp1653_strobe(struct adp1653_flash *flash, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nu8 out_sel = ADP1653_INDICATOR_INTENSITY_uA_TO_REG(\r\nflash->indicator_intensity->val)\r\n<< ADP1653_REG_OUT_SEL_ILED_SHIFT;\r\nint rval;\r\nif (flash->led_mode->val != V4L2_FLASH_LED_MODE_FLASH)\r\nreturn -EBUSY;\r\nif (!enable)\r\nreturn i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL,\r\nout_sel);\r\nout_sel |= ADP1653_FLASH_INTENSITY_mA_TO_REG(\r\nflash->flash_intensity->val)\r\n<< ADP1653_REG_OUT_SEL_HPLED_SHIFT;\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, out_sel);\r\nif (rval)\r\nreturn rval;\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_SW_STROBE,\r\nADP1653_REG_SW_STROBE_SW_STROBE);\r\nif (rval)\r\nreturn rval;\r\nreturn i2c_smbus_write_byte_data(client, ADP1653_REG_SW_STROBE, 0);\r\n}\r\nstatic int adp1653_get_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct adp1653_flash *flash =\r\ncontainer_of(ctrl->handler, struct adp1653_flash, ctrls);\r\nint rval;\r\nrval = adp1653_get_fault(flash);\r\nif (IS_ERR_VALUE(rval))\r\nreturn rval;\r\nctrl->cur.val = 0;\r\nif (flash->fault & ADP1653_REG_FAULT_FLT_SCP)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\r\nif (flash->fault & ADP1653_REG_FAULT_FLT_OT)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\r\nif (flash->fault & ADP1653_REG_FAULT_FLT_TMR)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_TIMEOUT;\r\nif (flash->fault & ADP1653_REG_FAULT_FLT_OV)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_OVER_VOLTAGE;\r\nflash->fault = 0;\r\nreturn 0;\r\n}\r\nstatic int adp1653_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct adp1653_flash *flash =\r\ncontainer_of(ctrl->handler, struct adp1653_flash, ctrls);\r\nint rval;\r\nrval = adp1653_get_fault(flash);\r\nif (IS_ERR_VALUE(rval))\r\nreturn rval;\r\nif ((rval & (ADP1653_REG_FAULT_FLT_SCP |\r\nADP1653_REG_FAULT_FLT_OT |\r\nADP1653_REG_FAULT_FLT_OV)) &&\r\n(ctrl->id == V4L2_CID_FLASH_STROBE ||\r\nctrl->id == V4L2_CID_FLASH_TORCH_INTENSITY ||\r\nctrl->id == V4L2_CID_FLASH_LED_MODE))\r\nreturn -EBUSY;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_FLASH_STROBE:\r\nreturn adp1653_strobe(flash, 1);\r\ncase V4L2_CID_FLASH_STROBE_STOP:\r\nreturn adp1653_strobe(flash, 0);\r\n}\r\nreturn adp1653_update_hw(flash);\r\n}\r\nstatic int adp1653_init_controls(struct adp1653_flash *flash)\r\n{\r\nstruct v4l2_ctrl *fault;\r\nv4l2_ctrl_handler_init(&flash->ctrls, 9);\r\nflash->led_mode =\r\nv4l2_ctrl_new_std_menu(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_LED_MODE,\r\nV4L2_FLASH_LED_MODE_TORCH, ~0x7, 0);\r\nv4l2_ctrl_new_std_menu(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE_SOURCE,\r\nV4L2_FLASH_STROBE_SOURCE_SOFTWARE, ~0x1, 0);\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\r\nflash->flash_timeout =\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_TIMEOUT, TIMEOUT_MIN,\r\nflash->platform_data->max_flash_timeout,\r\nTIMEOUT_STEP,\r\nflash->platform_data->max_flash_timeout);\r\nflash->flash_intensity =\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_INTENSITY,\r\nADP1653_FLASH_INTENSITY_MIN,\r\nflash->platform_data->max_flash_intensity,\r\n1, flash->platform_data->max_flash_intensity);\r\nflash->torch_intensity =\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_TORCH_INTENSITY,\r\nADP1653_TORCH_INTENSITY_MIN,\r\nflash->platform_data->max_torch_intensity,\r\nADP1653_FLASH_INTENSITY_STEP,\r\nflash->platform_data->max_torch_intensity);\r\nflash->indicator_intensity =\r\nv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_INDICATOR_INTENSITY,\r\nADP1653_INDICATOR_INTENSITY_MIN,\r\nflash->platform_data->max_indicator_intensity,\r\nADP1653_INDICATOR_INTENSITY_STEP,\r\nADP1653_INDICATOR_INTENSITY_MIN);\r\nfault = v4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\r\nV4L2_CID_FLASH_FAULT, 0,\r\nV4L2_FLASH_FAULT_OVER_VOLTAGE\r\n| V4L2_FLASH_FAULT_OVER_TEMPERATURE\r\n| V4L2_FLASH_FAULT_SHORT_CIRCUIT, 0, 0);\r\nif (flash->ctrls.error)\r\nreturn flash->ctrls.error;\r\nfault->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nflash->subdev.ctrl_handler = &flash->ctrls;\r\nreturn 0;\r\n}\r\nstatic int\r\nadp1653_init_device(struct adp1653_flash *flash)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint rval;\r\nrval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, 0);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "failed writing fault register\n");\r\nreturn -EIO;\r\n}\r\nmutex_lock(flash->ctrls.lock);\r\nflash->fault = 0;\r\nrval = adp1653_get_fault(flash);\r\nmutex_unlock(flash->ctrls.lock);\r\nif (rval > 0) {\r\ndev_err(&client->dev, "faults detected: 0x%1.1x\n", rval);\r\nreturn -EIO;\r\n}\r\nmutex_lock(flash->ctrls.lock);\r\nrval = adp1653_update_hw(flash);\r\nmutex_unlock(flash->ctrls.lock);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"adp1653_update_hw failed at %s\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__adp1653_set_power(struct adp1653_flash *flash, int on)\r\n{\r\nint ret;\r\nret = flash->platform_data->power(&flash->subdev, on);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!on)\r\nreturn 0;\r\nret = adp1653_init_device(flash);\r\nif (ret < 0)\r\nflash->platform_data->power(&flash->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int\r\nadp1653_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct adp1653_flash *flash = to_adp1653_flash(subdev);\r\nint ret = 0;\r\nmutex_lock(&flash->power_lock);\r\nif (flash->power_count == !on) {\r\nret = __adp1653_set_power(flash, !!on);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nflash->power_count += on ? 1 : -1;\r\nWARN_ON(flash->power_count < 0);\r\ndone:\r\nmutex_unlock(&flash->power_lock);\r\nreturn ret;\r\n}\r\nstatic int adp1653_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn adp1653_set_power(sd, 1);\r\n}\r\nstatic int adp1653_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn adp1653_set_power(sd, 0);\r\n}\r\nstatic int adp1653_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct adp1653_flash *flash = to_adp1653_flash(subdev);\r\nif (!flash->power_count)\r\nreturn 0;\r\nreturn __adp1653_set_power(flash, 0);\r\n}\r\nstatic int adp1653_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct adp1653_flash *flash = to_adp1653_flash(subdev);\r\nif (!flash->power_count)\r\nreturn 0;\r\nreturn __adp1653_set_power(flash, 1);\r\n}\r\nstatic int adp1653_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct adp1653_flash *flash;\r\nint ret;\r\nif (client->dev.platform_data == NULL)\r\nreturn -ENODEV;\r\nflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\r\nif (flash == NULL)\r\nreturn -ENOMEM;\r\nflash->platform_data = client->dev.platform_data;\r\nmutex_init(&flash->power_lock);\r\nv4l2_i2c_subdev_init(&flash->subdev, client, &adp1653_ops);\r\nflash->subdev.internal_ops = &adp1653_internal_ops;\r\nflash->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nret = adp1653_init_controls(flash);\r\nif (ret)\r\ngoto free_and_quit;\r\nret = media_entity_init(&flash->subdev.entity, 0, NULL, 0);\r\nif (ret < 0)\r\ngoto free_and_quit;\r\nflash->subdev.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_FLASH;\r\nreturn 0;\r\nfree_and_quit:\r\nv4l2_ctrl_handler_free(&flash->ctrls);\r\nreturn ret;\r\n}\r\nstatic int adp1653_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct adp1653_flash *flash = to_adp1653_flash(subdev);\r\nv4l2_device_unregister_subdev(&flash->subdev);\r\nv4l2_ctrl_handler_free(&flash->ctrls);\r\nmedia_entity_cleanup(&flash->subdev.entity);\r\nreturn 0;\r\n}
