static unsigned long insn_type(unsigned long speinsn)\r\n{\r\nunsigned long ret = NOTYPE;\r\nswitch (speinsn & 0x7ff) {\r\ncase EFSABS: ret = XA; break;\r\ncase EFSADD: ret = AB; break;\r\ncase EFSCFD: ret = XB; break;\r\ncase EFSCMPEQ: ret = XCR; break;\r\ncase EFSCMPGT: ret = XCR; break;\r\ncase EFSCMPLT: ret = XCR; break;\r\ncase EFSCTSF: ret = XB; break;\r\ncase EFSCTSI: ret = XB; break;\r\ncase EFSCTSIZ: ret = XB; break;\r\ncase EFSCTUF: ret = XB; break;\r\ncase EFSCTUI: ret = XB; break;\r\ncase EFSCTUIZ: ret = XB; break;\r\ncase EFSDIV: ret = AB; break;\r\ncase EFSMUL: ret = AB; break;\r\ncase EFSNABS: ret = XA; break;\r\ncase EFSNEG: ret = XA; break;\r\ncase EFSSUB: ret = AB; break;\r\ncase EFSCFSI: ret = XB; break;\r\ncase EVFSABS: ret = XA; break;\r\ncase EVFSADD: ret = AB; break;\r\ncase EVFSCMPEQ: ret = XCR; break;\r\ncase EVFSCMPGT: ret = XCR; break;\r\ncase EVFSCMPLT: ret = XCR; break;\r\ncase EVFSCTSF: ret = XB; break;\r\ncase EVFSCTSI: ret = XB; break;\r\ncase EVFSCTSIZ: ret = XB; break;\r\ncase EVFSCTUF: ret = XB; break;\r\ncase EVFSCTUI: ret = XB; break;\r\ncase EVFSCTUIZ: ret = XB; break;\r\ncase EVFSDIV: ret = AB; break;\r\ncase EVFSMUL: ret = AB; break;\r\ncase EVFSNABS: ret = XA; break;\r\ncase EVFSNEG: ret = XA; break;\r\ncase EVFSSUB: ret = AB; break;\r\ncase EFDABS: ret = XA; break;\r\ncase EFDADD: ret = AB; break;\r\ncase EFDCFS: ret = XB; break;\r\ncase EFDCMPEQ: ret = XCR; break;\r\ncase EFDCMPGT: ret = XCR; break;\r\ncase EFDCMPLT: ret = XCR; break;\r\ncase EFDCTSF: ret = XB; break;\r\ncase EFDCTSI: ret = XB; break;\r\ncase EFDCTSIDZ: ret = XB; break;\r\ncase EFDCTSIZ: ret = XB; break;\r\ncase EFDCTUF: ret = XB; break;\r\ncase EFDCTUI: ret = XB; break;\r\ncase EFDCTUIDZ: ret = XB; break;\r\ncase EFDCTUIZ: ret = XB; break;\r\ncase EFDDIV: ret = AB; break;\r\ncase EFDMUL: ret = AB; break;\r\ncase EFDNABS: ret = XA; break;\r\ncase EFDNEG: ret = XA; break;\r\ncase EFDSUB: ret = AB; break;\r\n}\r\nreturn ret;\r\n}\r\nint do_spe_mathemu(struct pt_regs *regs)\r\n{\r\nFP_DECL_EX;\r\nint IR, cmp;\r\nunsigned long type, func, fc, fa, fb, src, speinsn;\r\nunion dw_union vc, va, vb;\r\nif (get_user(speinsn, (unsigned int __user *) regs->nip))\r\nreturn -EFAULT;\r\nif ((speinsn >> 26) != EFAPU)\r\nreturn -EINVAL;\r\ntype = insn_type(speinsn);\r\nif (type == NOTYPE)\r\ngoto illegal;\r\nfunc = speinsn & 0x7ff;\r\nfc = (speinsn >> 21) & 0x1f;\r\nfa = (speinsn >> 16) & 0x1f;\r\nfb = (speinsn >> 11) & 0x1f;\r\nsrc = (speinsn >> 5) & 0x7;\r\nvc.wp[0] = current->thread.evr[fc];\r\nvc.wp[1] = regs->gpr[fc];\r\nva.wp[0] = current->thread.evr[fa];\r\nva.wp[1] = regs->gpr[fa];\r\nvb.wp[0] = current->thread.evr[fb];\r\nvb.wp[1] = regs->gpr[fb];\r\n__FPU_FPSCR = mfspr(SPRN_SPEFSCR);\r\npr_debug("speinsn:%08lx spefscr:%08lx\n", speinsn, __FPU_FPSCR);\r\npr_debug("vc: %08x %08x\n", vc.wp[0], vc.wp[1]);\r\npr_debug("va: %08x %08x\n", va.wp[0], va.wp[1]);\r\npr_debug("vb: %08x %08x\n", vb.wp[0], vb.wp[1]);\r\nswitch (src) {\r\ncase SPFP: {\r\nFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\r\nswitch (type) {\r\ncase AB:\r\ncase XCR:\r\nFP_UNPACK_SP(SA, va.wp + 1);\r\ncase XB:\r\nFP_UNPACK_SP(SB, vb.wp + 1);\r\nbreak;\r\ncase XA:\r\nFP_UNPACK_SP(SA, va.wp + 1);\r\nbreak;\r\n}\r\npr_debug("SA: %ld %08lx %ld (%ld)\n", SA_s, SA_f, SA_e, SA_c);\r\npr_debug("SB: %ld %08lx %ld (%ld)\n", SB_s, SB_f, SB_e, SB_c);\r\nswitch (func) {\r\ncase EFSABS:\r\nvc.wp[1] = va.wp[1] & ~SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EFSNABS:\r\nvc.wp[1] = va.wp[1] | SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EFSNEG:\r\nvc.wp[1] = va.wp[1] ^ SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EFSADD:\r\nFP_ADD_S(SR, SA, SB);\r\ngoto pack_s;\r\ncase EFSSUB:\r\nFP_SUB_S(SR, SA, SB);\r\ngoto pack_s;\r\ncase EFSMUL:\r\nFP_MUL_S(SR, SA, SB);\r\ngoto pack_s;\r\ncase EFSDIV:\r\nFP_DIV_S(SR, SA, SB);\r\ngoto pack_s;\r\ncase EFSCMPEQ:\r\ncmp = 0;\r\ngoto cmp_s;\r\ncase EFSCMPGT:\r\ncmp = 1;\r\ngoto cmp_s;\r\ncase EFSCMPLT:\r\ncmp = -1;\r\ngoto cmp_s;\r\ncase EFSCTSF:\r\ncase EFSCTUF:\r\nif (SB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nSB_e += (func == EFSCTSF ? 31 : 32);\r\nFP_TO_INT_ROUND_S(vc.wp[1], SB, 32,\r\n(func == EFSCTSF));\r\n}\r\ngoto update_regs;\r\ncase EFSCFD: {\r\nFP_DECL_D(DB);\r\nFP_CLEAR_EXCEPTIONS;\r\nFP_UNPACK_DP(DB, vb.dp);\r\npr_debug("DB: %ld %08lx %08lx %ld (%ld)\n",\r\nDB_s, DB_f1, DB_f0, DB_e, DB_c);\r\nFP_CONV(S, D, 1, 2, SR, DB);\r\ngoto pack_s;\r\n}\r\ncase EFSCTSI:\r\ncase EFSCTUI:\r\nif (SB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_ROUND_S(vc.wp[1], SB, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ncase EFSCTSIZ:\r\ncase EFSCTUIZ:\r\nif (SB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_S(vc.wp[1], SB, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\npack_s:\r\npr_debug("SR: %ld %08lx %ld (%ld)\n", SR_s, SR_f, SR_e, SR_c);\r\nFP_PACK_SP(vc.wp + 1, SR);\r\ngoto update_regs;\r\ncmp_s:\r\nFP_CMP_S(IR, SA, SB, 3);\r\nif (IR == 3 && (FP_ISSIGNAN_S(SA) || FP_ISSIGNAN_S(SB)))\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\nif (IR == cmp) {\r\nIR = 0x4;\r\n} else {\r\nIR = 0;\r\n}\r\ngoto update_ccr;\r\n}\r\ncase DPFP: {\r\nFP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);\r\nswitch (type) {\r\ncase AB:\r\ncase XCR:\r\nFP_UNPACK_DP(DA, va.dp);\r\ncase XB:\r\nFP_UNPACK_DP(DB, vb.dp);\r\nbreak;\r\ncase XA:\r\nFP_UNPACK_DP(DA, va.dp);\r\nbreak;\r\n}\r\npr_debug("DA: %ld %08lx %08lx %ld (%ld)\n",\r\nDA_s, DA_f1, DA_f0, DA_e, DA_c);\r\npr_debug("DB: %ld %08lx %08lx %ld (%ld)\n",\r\nDB_s, DB_f1, DB_f0, DB_e, DB_c);\r\nswitch (func) {\r\ncase EFDABS:\r\nvc.dp[0] = va.dp[0] & ~SIGN_BIT_D;\r\ngoto update_regs;\r\ncase EFDNABS:\r\nvc.dp[0] = va.dp[0] | SIGN_BIT_D;\r\ngoto update_regs;\r\ncase EFDNEG:\r\nvc.dp[0] = va.dp[0] ^ SIGN_BIT_D;\r\ngoto update_regs;\r\ncase EFDADD:\r\nFP_ADD_D(DR, DA, DB);\r\ngoto pack_d;\r\ncase EFDSUB:\r\nFP_SUB_D(DR, DA, DB);\r\ngoto pack_d;\r\ncase EFDMUL:\r\nFP_MUL_D(DR, DA, DB);\r\ngoto pack_d;\r\ncase EFDDIV:\r\nFP_DIV_D(DR, DA, DB);\r\ngoto pack_d;\r\ncase EFDCMPEQ:\r\ncmp = 0;\r\ngoto cmp_d;\r\ncase EFDCMPGT:\r\ncmp = 1;\r\ngoto cmp_d;\r\ncase EFDCMPLT:\r\ncmp = -1;\r\ngoto cmp_d;\r\ncase EFDCTSF:\r\ncase EFDCTUF:\r\nif (DB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nDB_e += (func == EFDCTSF ? 31 : 32);\r\nFP_TO_INT_ROUND_D(vc.wp[1], DB, 32,\r\n(func == EFDCTSF));\r\n}\r\ngoto update_regs;\r\ncase EFDCFS: {\r\nFP_DECL_S(SB);\r\nFP_CLEAR_EXCEPTIONS;\r\nFP_UNPACK_SP(SB, vb.wp + 1);\r\npr_debug("SB: %ld %08lx %ld (%ld)\n",\r\nSB_s, SB_f, SB_e, SB_c);\r\nFP_CONV(D, S, 2, 1, DR, SB);\r\ngoto pack_d;\r\n}\r\ncase EFDCTUIDZ:\r\ncase EFDCTSIDZ:\r\nif (DB_c == FP_CLS_NAN) {\r\nvc.dp[0] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_D(vc.dp[0], DB, 64,\r\n((func & 0x1) == 0));\r\n}\r\ngoto update_regs;\r\ncase EFDCTUI:\r\ncase EFDCTSI:\r\nif (DB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_ROUND_D(vc.wp[1], DB, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ncase EFDCTUIZ:\r\ncase EFDCTSIZ:\r\nif (DB_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_D(vc.wp[1], DB, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\npack_d:\r\npr_debug("DR: %ld %08lx %08lx %ld (%ld)\n",\r\nDR_s, DR_f1, DR_f0, DR_e, DR_c);\r\nFP_PACK_DP(vc.dp, DR);\r\ngoto update_regs;\r\ncmp_d:\r\nFP_CMP_D(IR, DA, DB, 3);\r\nif (IR == 3 && (FP_ISSIGNAN_D(DA) || FP_ISSIGNAN_D(DB)))\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\nif (IR == cmp) {\r\nIR = 0x4;\r\n} else {\r\nIR = 0;\r\n}\r\ngoto update_ccr;\r\n}\r\ncase VCT: {\r\nFP_DECL_S(SA0); FP_DECL_S(SB0); FP_DECL_S(SR0);\r\nFP_DECL_S(SA1); FP_DECL_S(SB1); FP_DECL_S(SR1);\r\nint IR0, IR1;\r\nswitch (type) {\r\ncase AB:\r\ncase XCR:\r\nFP_UNPACK_SP(SA0, va.wp);\r\nFP_UNPACK_SP(SA1, va.wp + 1);\r\ncase XB:\r\nFP_UNPACK_SP(SB0, vb.wp);\r\nFP_UNPACK_SP(SB1, vb.wp + 1);\r\nbreak;\r\ncase XA:\r\nFP_UNPACK_SP(SA0, va.wp);\r\nFP_UNPACK_SP(SA1, va.wp + 1);\r\nbreak;\r\n}\r\npr_debug("SA0: %ld %08lx %ld (%ld)\n",\r\nSA0_s, SA0_f, SA0_e, SA0_c);\r\npr_debug("SA1: %ld %08lx %ld (%ld)\n",\r\nSA1_s, SA1_f, SA1_e, SA1_c);\r\npr_debug("SB0: %ld %08lx %ld (%ld)\n",\r\nSB0_s, SB0_f, SB0_e, SB0_c);\r\npr_debug("SB1: %ld %08lx %ld (%ld)\n",\r\nSB1_s, SB1_f, SB1_e, SB1_c);\r\nswitch (func) {\r\ncase EVFSABS:\r\nvc.wp[0] = va.wp[0] & ~SIGN_BIT_S;\r\nvc.wp[1] = va.wp[1] & ~SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EVFSNABS:\r\nvc.wp[0] = va.wp[0] | SIGN_BIT_S;\r\nvc.wp[1] = va.wp[1] | SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EVFSNEG:\r\nvc.wp[0] = va.wp[0] ^ SIGN_BIT_S;\r\nvc.wp[1] = va.wp[1] ^ SIGN_BIT_S;\r\ngoto update_regs;\r\ncase EVFSADD:\r\nFP_ADD_S(SR0, SA0, SB0);\r\nFP_ADD_S(SR1, SA1, SB1);\r\ngoto pack_vs;\r\ncase EVFSSUB:\r\nFP_SUB_S(SR0, SA0, SB0);\r\nFP_SUB_S(SR1, SA1, SB1);\r\ngoto pack_vs;\r\ncase EVFSMUL:\r\nFP_MUL_S(SR0, SA0, SB0);\r\nFP_MUL_S(SR1, SA1, SB1);\r\ngoto pack_vs;\r\ncase EVFSDIV:\r\nFP_DIV_S(SR0, SA0, SB0);\r\nFP_DIV_S(SR1, SA1, SB1);\r\ngoto pack_vs;\r\ncase EVFSCMPEQ:\r\ncmp = 0;\r\ngoto cmp_vs;\r\ncase EVFSCMPGT:\r\ncmp = 1;\r\ngoto cmp_vs;\r\ncase EVFSCMPLT:\r\ncmp = -1;\r\ngoto cmp_vs;\r\ncase EVFSCTUF:\r\ncase EVFSCTSF:\r\nif (SB0_c == FP_CLS_NAN) {\r\nvc.wp[0] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nSB0_e += (func == EVFSCTSF ? 31 : 32);\r\nFP_TO_INT_ROUND_S(vc.wp[0], SB0, 32,\r\n(func == EVFSCTSF));\r\n}\r\nif (SB1_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nSB1_e += (func == EVFSCTSF ? 31 : 32);\r\nFP_TO_INT_ROUND_S(vc.wp[1], SB1, 32,\r\n(func == EVFSCTSF));\r\n}\r\ngoto update_regs;\r\ncase EVFSCTUI:\r\ncase EVFSCTSI:\r\nif (SB0_c == FP_CLS_NAN) {\r\nvc.wp[0] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_ROUND_S(vc.wp[0], SB0, 32,\r\n((func & 0x3) != 0));\r\n}\r\nif (SB1_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_ROUND_S(vc.wp[1], SB1, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ncase EVFSCTUIZ:\r\ncase EVFSCTSIZ:\r\nif (SB0_c == FP_CLS_NAN) {\r\nvc.wp[0] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_S(vc.wp[0], SB0, 32,\r\n((func & 0x3) != 0));\r\n}\r\nif (SB1_c == FP_CLS_NAN) {\r\nvc.wp[1] = 0;\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\n} else {\r\nFP_TO_INT_S(vc.wp[1], SB1, 32,\r\n((func & 0x3) != 0));\r\n}\r\ngoto update_regs;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\npack_vs:\r\npr_debug("SR0: %ld %08lx %ld (%ld)\n",\r\nSR0_s, SR0_f, SR0_e, SR0_c);\r\npr_debug("SR1: %ld %08lx %ld (%ld)\n",\r\nSR1_s, SR1_f, SR1_e, SR1_c);\r\nFP_PACK_SP(vc.wp, SR0);\r\nFP_PACK_SP(vc.wp + 1, SR1);\r\ngoto update_regs;\r\ncmp_vs:\r\n{\r\nint ch, cl;\r\nFP_CMP_S(IR0, SA0, SB0, 3);\r\nFP_CMP_S(IR1, SA1, SB1, 3);\r\nif (IR0 == 3 && (FP_ISSIGNAN_S(SA0) || FP_ISSIGNAN_S(SB0)))\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\nif (IR1 == 3 && (FP_ISSIGNAN_S(SA1) || FP_ISSIGNAN_S(SB1)))\r\nFP_SET_EXCEPTION(FP_EX_INVALID);\r\nch = (IR0 == cmp) ? 1 : 0;\r\ncl = (IR1 == cmp) ? 1 : 0;\r\nIR = (ch << 3) | (cl << 2) | ((ch | cl) << 1) |\r\n((ch & cl) << 0);\r\ngoto update_ccr;\r\n}\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nupdate_ccr:\r\nregs->ccr &= ~(15 << ((7 - ((speinsn >> 23) & 0x7)) << 2));\r\nregs->ccr |= (IR << ((7 - ((speinsn >> 23) & 0x7)) << 2));\r\nupdate_regs:\r\n__FPU_FPSCR\r\n&= ~(FP_EX_INVALID | FP_EX_UNDERFLOW) | current->thread.spefscr_last;\r\n__FPU_FPSCR |= (FP_CUR_EXCEPTIONS & FP_EX_MASK);\r\nmtspr(SPRN_SPEFSCR, __FPU_FPSCR);\r\ncurrent->thread.spefscr_last = __FPU_FPSCR;\r\ncurrent->thread.evr[fc] = vc.wp[0];\r\nregs->gpr[fc] = vc.wp[1];\r\npr_debug("ccr = %08lx\n", regs->ccr);\r\npr_debug("cur exceptions = %08x spefscr = %08lx\n",\r\nFP_CUR_EXCEPTIONS, __FPU_FPSCR);\r\npr_debug("vc: %08x %08x\n", vc.wp[0], vc.wp[1]);\r\npr_debug("va: %08x %08x\n", va.wp[0], va.wp[1]);\r\npr_debug("vb: %08x %08x\n", vb.wp[0], vb.wp[1]);\r\nif (current->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE) {\r\nif ((FP_CUR_EXCEPTIONS & FP_EX_DIVZERO)\r\n&& (current->thread.fpexc_mode & PR_FP_EXC_DIV))\r\nreturn 1;\r\nif ((FP_CUR_EXCEPTIONS & FP_EX_OVERFLOW)\r\n&& (current->thread.fpexc_mode & PR_FP_EXC_OVF))\r\nreturn 1;\r\nif ((FP_CUR_EXCEPTIONS & FP_EX_UNDERFLOW)\r\n&& (current->thread.fpexc_mode & PR_FP_EXC_UND))\r\nreturn 1;\r\nif ((FP_CUR_EXCEPTIONS & FP_EX_INEXACT)\r\n&& (current->thread.fpexc_mode & PR_FP_EXC_RES))\r\nreturn 1;\r\nif ((FP_CUR_EXCEPTIONS & FP_EX_INVALID)\r\n&& (current->thread.fpexc_mode & PR_FP_EXC_INV))\r\nreturn 1;\r\n}\r\nreturn 0;\r\nillegal:\r\nif (have_e500_cpu_a005_erratum) {\r\nregs->nip -= 4;\r\npr_debug("re-issue efp inst: %08lx\n", speinsn);\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "\nOoops! IEEE-754 compliance handler encountered un-supported instruction.\ninst code: %08lx\n", speinsn);\r\nreturn -ENOSYS;\r\n}\r\nint speround_handler(struct pt_regs *regs)\r\n{\r\nunion dw_union fgpr;\r\nint s_lo, s_hi;\r\nint lo_inexact, hi_inexact;\r\nint fp_result;\r\nunsigned long speinsn, type, fb, fc, fptype, func;\r\nif (get_user(speinsn, (unsigned int __user *) regs->nip))\r\nreturn -EFAULT;\r\nif ((speinsn >> 26) != 4)\r\nreturn -EINVAL;\r\nfunc = speinsn & 0x7ff;\r\ntype = insn_type(func);\r\nif (type == XCR) return -ENOSYS;\r\n__FPU_FPSCR = mfspr(SPRN_SPEFSCR);\r\npr_debug("speinsn:%08lx spefscr:%08lx\n", speinsn, __FPU_FPSCR);\r\nfptype = (speinsn >> 5) & 0x7;\r\nlo_inexact = __FPU_FPSCR & (SPEFSCR_FG | SPEFSCR_FX);\r\nhi_inexact = __FPU_FPSCR & (SPEFSCR_FGH | SPEFSCR_FXH);\r\nif (!(lo_inexact || (hi_inexact && fptype == VCT)))\r\nreturn 0;\r\nfc = (speinsn >> 21) & 0x1f;\r\ns_lo = regs->gpr[fc] & SIGN_BIT_S;\r\ns_hi = current->thread.evr[fc] & SIGN_BIT_S;\r\nfgpr.wp[0] = current->thread.evr[fc];\r\nfgpr.wp[1] = regs->gpr[fc];\r\nfb = (speinsn >> 11) & 0x1f;\r\nswitch (func) {\r\ncase EFSCTUIZ:\r\ncase EFSCTSIZ:\r\ncase EVFSCTUIZ:\r\ncase EVFSCTSIZ:\r\ncase EFDCTUIDZ:\r\ncase EFDCTSIDZ:\r\ncase EFDCTUIZ:\r\ncase EFDCTSIZ:\r\nreturn 0;\r\ncase EFSCTUI:\r\ncase EFSCTUF:\r\ncase EVFSCTUI:\r\ncase EVFSCTUF:\r\ncase EFDCTUI:\r\ncase EFDCTUF:\r\nfp_result = 0;\r\ns_lo = 0;\r\ns_hi = 0;\r\nbreak;\r\ncase EFSCTSI:\r\ncase EFSCTSF:\r\nfp_result = 0;\r\nif (fgpr.wp[1] == 0)\r\ns_lo = regs->gpr[fb] & SIGN_BIT_S;\r\nbreak;\r\ncase EVFSCTSI:\r\ncase EVFSCTSF:\r\nfp_result = 0;\r\nif (fgpr.wp[1] == 0)\r\ns_lo = regs->gpr[fb] & SIGN_BIT_S;\r\nif (fgpr.wp[0] == 0)\r\ns_hi = current->thread.evr[fb] & SIGN_BIT_S;\r\nbreak;\r\ncase EFDCTSI:\r\ncase EFDCTSF:\r\nfp_result = 0;\r\ns_hi = s_lo;\r\nif (fgpr.wp[1] == 0)\r\ns_hi = current->thread.evr[fb] & SIGN_BIT_S;\r\nbreak;\r\ndefault:\r\nfp_result = 1;\r\nbreak;\r\n}\r\npr_debug("round fgpr: %08x %08x\n", fgpr.wp[0], fgpr.wp[1]);\r\nswitch (fptype) {\r\ncase SPFP:\r\nif ((FP_ROUNDMODE) == FP_RND_PINF) {\r\nif (!s_lo) fgpr.wp[1]++;\r\n} else {\r\nif (s_lo) {\r\nif (fp_result)\r\nfgpr.wp[1]++;\r\nelse\r\nfgpr.wp[1]--;\r\n}\r\n}\r\nbreak;\r\ncase DPFP:\r\nif (FP_ROUNDMODE == FP_RND_PINF) {\r\nif (!s_hi) {\r\nif (fp_result)\r\nfgpr.dp[0]++;\r\nelse\r\nfgpr.wp[1]++;\r\n}\r\n} else {\r\nif (s_hi) {\r\nif (fp_result)\r\nfgpr.dp[0]++;\r\nelse\r\nfgpr.wp[1]--;\r\n}\r\n}\r\nbreak;\r\ncase VCT:\r\nif (FP_ROUNDMODE == FP_RND_PINF) {\r\nif (lo_inexact && !s_lo)\r\nfgpr.wp[1]++;\r\nif (hi_inexact && !s_hi)\r\nfgpr.wp[0]++;\r\n} else {\r\nif (lo_inexact && s_lo) {\r\nif (fp_result)\r\nfgpr.wp[1]++;\r\nelse\r\nfgpr.wp[1]--;\r\n}\r\nif (hi_inexact && s_hi) {\r\nif (fp_result)\r\nfgpr.wp[0]++;\r\nelse\r\nfgpr.wp[0]--;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncurrent->thread.evr[fc] = fgpr.wp[0];\r\nregs->gpr[fc] = fgpr.wp[1];\r\npr_debug(" to fgpr: %08x %08x\n", fgpr.wp[0], fgpr.wp[1]);\r\nif (current->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE)\r\nreturn (current->thread.fpexc_mode & PR_FP_EXC_RES) ? 1 : 0;\r\nreturn 0;\r\n}\r\nint __init spe_mathemu_init(void)\r\n{\r\nu32 pvr, maj, min;\r\npvr = mfspr(SPRN_PVR);\r\nif ((PVR_VER(pvr) == PVR_VER_E500V1) ||\r\n(PVR_VER(pvr) == PVR_VER_E500V2)) {\r\nmaj = PVR_MAJ(pvr);\r\nmin = PVR_MIN(pvr);\r\nswitch (maj) {\r\ncase 1:\r\nif (min < 1)\r\nhave_e500_cpu_a005_erratum = 1;\r\nbreak;\r\ncase 2:\r\nif (min < 3)\r\nhave_e500_cpu_a005_erratum = 1;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\nif (min < 1)\r\nhave_e500_cpu_a005_erratum = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
