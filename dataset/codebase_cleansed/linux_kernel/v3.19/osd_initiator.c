static inline void build_test(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct osd_capability) != OSD_CAP_LEN);\r\nBUILD_BUG_ON(sizeof(struct osdv2_cdb) != OSD_TOTAL_CDB_LEN);\r\nBUILD_BUG_ON(sizeof(struct osdv1_cdb) != OSDv1_TOTAL_CDB_LEN);\r\n}\r\nstatic const char *_osd_ver_desc(struct osd_request *or)\r\n{\r\nreturn osd_req_is_ver1(or) ? "OSD1" : "OSD2";\r\n}\r\nstatic int _osd_get_print_system_info(struct osd_dev *od,\r\nvoid *caps, struct osd_dev_info *odi)\r\n{\r\nstruct osd_request *or;\r\nstruct osd_attr get_attrs[] = {\r\nATTR_DEF_RI(OSD_ATTR_RI_VENDOR_IDENTIFICATION, 8),\r\nATTR_DEF_RI(OSD_ATTR_RI_PRODUCT_IDENTIFICATION, 16),\r\nATTR_DEF_RI(OSD_ATTR_RI_PRODUCT_MODEL, 32),\r\nATTR_DEF_RI(OSD_ATTR_RI_PRODUCT_REVISION_LEVEL, 4),\r\nATTR_DEF_RI(OSD_ATTR_RI_PRODUCT_SERIAL_NUMBER, 64 ),\r\nATTR_DEF_RI(OSD_ATTR_RI_OSD_NAME, 64 ),\r\nATTR_DEF_RI(OSD_ATTR_RI_TOTAL_CAPACITY, 8),\r\nATTR_DEF_RI(OSD_ATTR_RI_USED_CAPACITY, 8),\r\nATTR_DEF_RI(OSD_ATTR_RI_NUMBER_OF_PARTITIONS, 8),\r\nATTR_DEF_RI(OSD_ATTR_RI_CLOCK, 6),\r\nATTR_DEF_RI(OSD_ATTR_RI_OSD_SYSTEM_ID, 20),\r\n};\r\nvoid *iter = NULL, *pFirst;\r\nint nelem = ARRAY_SIZE(get_attrs), a = 0;\r\nint ret;\r\nor = osd_start_request(od, GFP_KERNEL);\r\nif (!or)\r\nreturn -ENOMEM;\r\nosd_req_get_attributes(or, &osd_root_object);\r\nosd_req_add_get_attr_list(or, get_attrs, ARRAY_SIZE(get_attrs));\r\nret = osd_finalize_request(or, 0, caps, NULL);\r\nif (ret)\r\ngoto out;\r\nret = osd_execute_request(or);\r\nif (ret) {\r\nOSD_ERR("Failed to detect %s => %d\n", _osd_ver_desc(or), ret);\r\ngoto out;\r\n}\r\nosd_req_decode_get_attr_list(or, get_attrs, &nelem, &iter);\r\nOSD_INFO("Detected %s device\n",\r\n_osd_ver_desc(or));\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("VENDOR_IDENTIFICATION [%s]\n",\r\n(char *)pFirst);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("PRODUCT_IDENTIFICATION [%s]\n",\r\n(char *)pFirst);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("PRODUCT_MODEL [%s]\n",\r\n(char *)pFirst);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("PRODUCT_REVISION_LEVEL [%u]\n",\r\npFirst ? get_unaligned_be32(pFirst) : ~0U);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("PRODUCT_SERIAL_NUMBER [%s]\n",\r\n(char *)pFirst);\r\nodi->osdname_len = get_attrs[a].len;\r\nodi->osdname = kzalloc(odi->osdname_len + 1, GFP_KERNEL);\r\nif (!odi->osdname) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (odi->osdname_len)\r\nmemcpy(odi->osdname, get_attrs[a].val_ptr, odi->osdname_len);\r\nOSD_INFO("OSD_NAME [%s]\n", odi->osdname);\r\na++;\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("TOTAL_CAPACITY [0x%llx]\n",\r\npFirst ? _LLU(get_unaligned_be64(pFirst)) : ~0ULL);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("USED_CAPACITY [0x%llx]\n",\r\npFirst ? _LLU(get_unaligned_be64(pFirst)) : ~0ULL);\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("NUMBER_OF_PARTITIONS [%llu]\n",\r\npFirst ? _LLU(get_unaligned_be64(pFirst)) : ~0ULL);\r\nif (a >= nelem)\r\ngoto out;\r\npFirst = get_attrs[a++].val_ptr;\r\nOSD_INFO("CLOCK [0x%02x%02x%02x%02x%02x%02x]\n",\r\n((char *)pFirst)[0], ((char *)pFirst)[1],\r\n((char *)pFirst)[2], ((char *)pFirst)[3],\r\n((char *)pFirst)[4], ((char *)pFirst)[5]);\r\nif (a < nelem) {\r\nunsigned len = get_attrs[a].len;\r\nchar sid_dump[32*4 + 2];\r\nhex_dump_to_buffer(get_attrs[a].val_ptr, len, 32, 1,\r\nsid_dump, sizeof(sid_dump), true);\r\nOSD_INFO("OSD_SYSTEM_ID(%d)\n"\r\n" [%s]\n", len, sid_dump);\r\nif (unlikely(len > sizeof(odi->systemid))) {\r\nOSD_ERR("OSD Target error: OSD_SYSTEM_ID too long(%d). "\r\n"device idetification might not work\n", len);\r\nlen = sizeof(odi->systemid);\r\n}\r\nodi->systemid_len = len;\r\nmemcpy(odi->systemid, get_attrs[a].val_ptr, len);\r\na++;\r\n}\r\nout:\r\nosd_end_request(or);\r\nreturn ret;\r\n}\r\nint osd_auto_detect_ver(struct osd_dev *od,\r\nvoid *caps, struct osd_dev_info *odi)\r\n{\r\nint ret;\r\nret = _osd_get_print_system_info(od, caps, odi);\r\nif (ret) {\r\nosd_dev_set_ver(od, OSD_VER1);\r\nOSD_DEBUG("converting to OSD1\n");\r\nret = _osd_get_print_system_info(od, caps, odi);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned _osd_req_cdb_len(struct osd_request *or)\r\n{\r\nreturn osd_req_is_ver1(or) ? OSDv1_TOTAL_CDB_LEN : OSD_TOTAL_CDB_LEN;\r\n}\r\nstatic unsigned _osd_req_alist_elem_size(struct osd_request *or, unsigned len)\r\n{\r\nreturn osd_req_is_ver1(or) ?\r\nosdv1_attr_list_elem_size(len) :\r\nosdv2_attr_list_elem_size(len);\r\n}\r\nstatic void _osd_req_alist_elem_encode(struct osd_request *or,\r\nvoid *attr_last, const struct osd_attr *oa)\r\n{\r\nif (osd_req_is_ver1(or)) {\r\nstruct osdv1_attributes_list_element *attr = attr_last;\r\nattr->attr_page = cpu_to_be32(oa->attr_page);\r\nattr->attr_id = cpu_to_be32(oa->attr_id);\r\nattr->attr_bytes = cpu_to_be16(oa->len);\r\nmemcpy(attr->attr_val, oa->val_ptr, oa->len);\r\n} else {\r\nstruct osdv2_attributes_list_element *attr = attr_last;\r\nattr->attr_page = cpu_to_be32(oa->attr_page);\r\nattr->attr_id = cpu_to_be32(oa->attr_id);\r\nattr->attr_bytes = cpu_to_be16(oa->len);\r\nmemcpy(attr->attr_val, oa->val_ptr, oa->len);\r\n}\r\n}\r\nstatic int _osd_req_alist_elem_decode(struct osd_request *or,\r\nvoid *cur_p, struct osd_attr *oa, unsigned max_bytes)\r\n{\r\nunsigned inc;\r\nif (osd_req_is_ver1(or)) {\r\nstruct osdv1_attributes_list_element *attr = cur_p;\r\nif (max_bytes < sizeof(*attr))\r\nreturn -1;\r\noa->len = be16_to_cpu(attr->attr_bytes);\r\ninc = _osd_req_alist_elem_size(or, oa->len);\r\nif (inc > max_bytes)\r\nreturn -1;\r\noa->attr_page = be32_to_cpu(attr->attr_page);\r\noa->attr_id = be32_to_cpu(attr->attr_id);\r\noa->val_ptr = likely(oa->len) ? attr->attr_val :\r\n(u8 *)&attr->attr_bytes;\r\n} else {\r\nstruct osdv2_attributes_list_element *attr = cur_p;\r\nif (max_bytes < sizeof(*attr))\r\nreturn -1;\r\noa->len = be16_to_cpu(attr->attr_bytes);\r\ninc = _osd_req_alist_elem_size(or, oa->len);\r\nif (inc > max_bytes)\r\nreturn -1;\r\noa->attr_page = be32_to_cpu(attr->attr_page);\r\noa->attr_id = be32_to_cpu(attr->attr_id);\r\noa->val_ptr = likely(oa->len) ? attr->attr_val : attr->reserved;\r\n}\r\nreturn inc;\r\n}\r\nstatic unsigned _osd_req_alist_size(struct osd_request *or, void *list_head)\r\n{\r\nreturn osd_req_is_ver1(or) ?\r\nosdv1_list_size(list_head) :\r\nosdv2_list_size(list_head);\r\n}\r\nstatic unsigned _osd_req_sizeof_alist_header(struct osd_request *or)\r\n{\r\nreturn osd_req_is_ver1(or) ?\r\nsizeof(struct osdv1_attributes_list_header) :\r\nsizeof(struct osdv2_attributes_list_header);\r\n}\r\nstatic void _osd_req_set_alist_type(struct osd_request *or,\r\nvoid *list, int list_type)\r\n{\r\nif (osd_req_is_ver1(or)) {\r\nstruct osdv1_attributes_list_header *attr_list = list;\r\nmemset(attr_list, 0, sizeof(*attr_list));\r\nattr_list->type = list_type;\r\n} else {\r\nstruct osdv2_attributes_list_header *attr_list = list;\r\nmemset(attr_list, 0, sizeof(*attr_list));\r\nattr_list->type = list_type;\r\n}\r\n}\r\nstatic bool _osd_req_is_alist_type(struct osd_request *or,\r\nvoid *list, int list_type)\r\n{\r\nif (!list)\r\nreturn false;\r\nif (osd_req_is_ver1(or)) {\r\nstruct osdv1_attributes_list_header *attr_list = list;\r\nreturn attr_list->type == list_type;\r\n} else {\r\nstruct osdv2_attributes_list_header *attr_list = list;\r\nreturn attr_list->type == list_type;\r\n}\r\n}\r\nstatic void _osd_req_encode_olist(struct osd_request *or,\r\nstruct osd_obj_id_list *list)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nif (osd_req_is_ver1(or)) {\r\ncdbh->v1.list_identifier = list->list_identifier;\r\ncdbh->v1.start_address = list->continuation_id;\r\n} else {\r\ncdbh->v2.list_identifier = list->list_identifier;\r\ncdbh->v2.start_address = list->continuation_id;\r\n}\r\n}\r\nstatic osd_cdb_offset osd_req_encode_offset(struct osd_request *or,\r\nu64 offset, unsigned *padding)\r\n{\r\nreturn __osd_encode_offset(offset, padding,\r\nosd_req_is_ver1(or) ?\r\nOSDv1_OFFSET_MIN_SHIFT : OSD_OFFSET_MIN_SHIFT,\r\nOSD_OFFSET_MAX_SHIFT);\r\n}\r\nstatic struct osd_security_parameters *\r\n_osd_req_sec_params(struct osd_request *or)\r\n{\r\nstruct osd_cdb *ocdb = &or->cdb;\r\nif (osd_req_is_ver1(or))\r\nreturn (struct osd_security_parameters *)&ocdb->v1.sec_params;\r\nelse\r\nreturn (struct osd_security_parameters *)&ocdb->v2.sec_params;\r\n}\r\nvoid osd_dev_init(struct osd_dev *osdd, struct scsi_device *scsi_device)\r\n{\r\nmemset(osdd, 0, sizeof(*osdd));\r\nosdd->scsi_device = scsi_device;\r\nosdd->def_timeout = BLK_DEFAULT_SG_TIMEOUT;\r\n#ifdef OSD_VER1_SUPPORT\r\nosdd->version = OSD_VER2;\r\n#endif\r\n}\r\nvoid osd_dev_fini(struct osd_dev *osdd)\r\n{\r\nosdd->scsi_device = NULL;\r\n}\r\nstatic struct osd_request *_osd_request_alloc(gfp_t gfp)\r\n{\r\nstruct osd_request *or;\r\nor = kzalloc(sizeof(*or), gfp);\r\nreturn or;\r\n}\r\nstatic void _osd_request_free(struct osd_request *or)\r\n{\r\nkfree(or);\r\n}\r\nstruct osd_request *osd_start_request(struct osd_dev *dev, gfp_t gfp)\r\n{\r\nstruct osd_request *or;\r\nor = _osd_request_alloc(gfp);\r\nif (!or)\r\nreturn NULL;\r\nor->osd_dev = dev;\r\nor->alloc_flags = gfp;\r\nor->timeout = dev->def_timeout;\r\nor->retries = OSD_REQ_RETRIES;\r\nreturn or;\r\n}\r\nstatic void _osd_free_seg(struct osd_request *or __unused,\r\nstruct _osd_req_data_segment *seg)\r\n{\r\nif (!seg->buff || !seg->alloc_size)\r\nreturn;\r\nkfree(seg->buff);\r\nseg->buff = NULL;\r\nseg->alloc_size = 0;\r\n}\r\nstatic void _put_request(struct request *rq)\r\n{\r\nif (unlikely(rq->bio))\r\nblk_end_request(rq, -ENOMEM, blk_rq_bytes(rq));\r\nelse\r\nblk_put_request(rq);\r\n}\r\nvoid osd_end_request(struct osd_request *or)\r\n{\r\nstruct request *rq = or->request;\r\nif (rq) {\r\nif (rq->next_rq) {\r\n_put_request(rq->next_rq);\r\nrq->next_rq = NULL;\r\n}\r\n_put_request(rq);\r\n}\r\n_osd_free_seg(or, &or->get_attr);\r\n_osd_free_seg(or, &or->enc_get_attr);\r\n_osd_free_seg(or, &or->set_attr);\r\n_osd_free_seg(or, &or->cdb_cont);\r\n_osd_request_free(or);\r\n}\r\nstatic void _set_error_resid(struct osd_request *or, struct request *req,\r\nint error)\r\n{\r\nor->async_error = error;\r\nor->req_errors = req->errors ? : error;\r\nor->sense_len = req->sense_len;\r\nif (or->out.req)\r\nor->out.residual = or->out.req->resid_len;\r\nif (or->in.req)\r\nor->in.residual = or->in.req->resid_len;\r\n}\r\nint osd_execute_request(struct osd_request *or)\r\n{\r\nint error = blk_execute_rq(or->request->q, NULL, or->request, 0);\r\n_set_error_resid(or, or->request, error);\r\nreturn error;\r\n}\r\nstatic void osd_request_async_done(struct request *req, int error)\r\n{\r\nstruct osd_request *or = req->end_io_data;\r\n_set_error_resid(or, req, error);\r\nif (req->next_rq) {\r\n__blk_put_request(req->q, req->next_rq);\r\nreq->next_rq = NULL;\r\n}\r\n__blk_put_request(req->q, req);\r\nor->request = NULL;\r\nor->in.req = NULL;\r\nor->out.req = NULL;\r\nif (or->async_done)\r\nor->async_done(or, or->async_private);\r\nelse\r\nosd_end_request(or);\r\n}\r\nint osd_execute_request_async(struct osd_request *or,\r\nosd_req_done_fn *done, void *private)\r\n{\r\nor->request->end_io_data = or;\r\nor->async_private = private;\r\nor->async_done = done;\r\nblk_execute_rq_nowait(or->request->q, NULL, or->request, 0,\r\nosd_request_async_done);\r\nreturn 0;\r\n}\r\nstatic int _osd_realloc_seg(struct osd_request *or,\r\nstruct _osd_req_data_segment *seg, unsigned max_bytes)\r\n{\r\nvoid *buff;\r\nif (seg->alloc_size >= max_bytes)\r\nreturn 0;\r\nbuff = krealloc(seg->buff, max_bytes, or->alloc_flags);\r\nif (!buff) {\r\nOSD_ERR("Failed to Realloc %d-bytes was-%d\n", max_bytes,\r\nseg->alloc_size);\r\nreturn -ENOMEM;\r\n}\r\nmemset(buff + seg->alloc_size, 0, max_bytes - seg->alloc_size);\r\nseg->buff = buff;\r\nseg->alloc_size = max_bytes;\r\nreturn 0;\r\n}\r\nstatic int _alloc_cdb_cont(struct osd_request *or, unsigned total_bytes)\r\n{\r\nOSD_DEBUG("total_bytes=%d\n", total_bytes);\r\nreturn _osd_realloc_seg(or, &or->cdb_cont, total_bytes);\r\n}\r\nstatic int _alloc_set_attr_list(struct osd_request *or,\r\nconst struct osd_attr *oa, unsigned nelem, unsigned add_bytes)\r\n{\r\nunsigned total_bytes = add_bytes;\r\nfor (; nelem; --nelem, ++oa)\r\ntotal_bytes += _osd_req_alist_elem_size(or, oa->len);\r\nOSD_DEBUG("total_bytes=%d\n", total_bytes);\r\nreturn _osd_realloc_seg(or, &or->set_attr, total_bytes);\r\n}\r\nstatic int _alloc_get_attr_desc(struct osd_request *or, unsigned max_bytes)\r\n{\r\nOSD_DEBUG("total_bytes=%d\n", max_bytes);\r\nreturn _osd_realloc_seg(or, &or->enc_get_attr, max_bytes);\r\n}\r\nstatic int _alloc_get_attr_list(struct osd_request *or)\r\n{\r\nOSD_DEBUG("total_bytes=%d\n", or->get_attr.total_bytes);\r\nreturn _osd_realloc_seg(or, &or->get_attr, or->get_attr.total_bytes);\r\n}\r\nstatic void _osdv1_req_encode_common(struct osd_request *or,\r\n__be16 act, const struct osd_obj_id *obj, u64 offset, u64 len)\r\n{\r\nstruct osdv1_cdb *ocdb = &or->cdb.v1;\r\nact &= cpu_to_be16(~0x0080);\r\nOSD_DEBUG("OSDv1 execute opcode 0x%x\n", be16_to_cpu(act));\r\nocdb->h.varlen_cdb.opcode = VARIABLE_LENGTH_CMD;\r\nocdb->h.varlen_cdb.additional_cdb_length = OSD_ADDITIONAL_CDB_LENGTH;\r\nocdb->h.varlen_cdb.service_action = act;\r\nocdb->h.partition = cpu_to_be64(obj->partition);\r\nocdb->h.object = cpu_to_be64(obj->id);\r\nocdb->h.v1.length = cpu_to_be64(len);\r\nocdb->h.v1.start_address = cpu_to_be64(offset);\r\n}\r\nstatic void _osdv2_req_encode_common(struct osd_request *or,\r\n__be16 act, const struct osd_obj_id *obj, u64 offset, u64 len)\r\n{\r\nstruct osdv2_cdb *ocdb = &or->cdb.v2;\r\nOSD_DEBUG("OSDv2 execute opcode 0x%x\n", be16_to_cpu(act));\r\nocdb->h.varlen_cdb.opcode = VARIABLE_LENGTH_CMD;\r\nocdb->h.varlen_cdb.additional_cdb_length = OSD_ADDITIONAL_CDB_LENGTH;\r\nocdb->h.varlen_cdb.service_action = act;\r\nocdb->h.partition = cpu_to_be64(obj->partition);\r\nocdb->h.object = cpu_to_be64(obj->id);\r\nocdb->h.v2.length = cpu_to_be64(len);\r\nocdb->h.v2.start_address = cpu_to_be64(offset);\r\n}\r\nstatic void _osd_req_encode_common(struct osd_request *or,\r\n__be16 act, const struct osd_obj_id *obj, u64 offset, u64 len)\r\n{\r\nif (osd_req_is_ver1(or))\r\n_osdv1_req_encode_common(or, act, obj, offset, len);\r\nelse\r\n_osdv2_req_encode_common(or, act, obj, offset, len);\r\n}\r\nvoid osd_req_format(struct osd_request *or, u64 tot_capacity)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_FORMAT_OSD, &osd_root_object, 0,\r\ntot_capacity);\r\n}\r\nint osd_req_list_dev_partitions(struct osd_request *or,\r\nosd_id initial_id, struct osd_obj_id_list *list, unsigned nelem)\r\n{\r\nreturn osd_req_list_partition_objects(or, 0, initial_id, list, nelem);\r\n}\r\nstatic void _osd_req_encode_flush(struct osd_request *or,\r\nenum osd_options_flush_scope_values op)\r\n{\r\nstruct osd_cdb_head *ocdb = osd_cdb_head(&or->cdb);\r\nocdb->command_specific_options = op;\r\n}\r\nvoid osd_req_flush_obsd(struct osd_request *or,\r\nenum osd_options_flush_scope_values op)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_FLUSH_OSD, &osd_root_object, 0, 0);\r\n_osd_req_encode_flush(or, op);\r\n}\r\nstatic void _osd_req_encode_partition(struct osd_request *or,\r\n__be16 act, osd_id partition)\r\n{\r\nstruct osd_obj_id par = {\r\n.partition = partition,\r\n.id = 0,\r\n};\r\n_osd_req_encode_common(or, act, &par, 0, 0);\r\n}\r\nvoid osd_req_create_partition(struct osd_request *or, osd_id partition)\r\n{\r\n_osd_req_encode_partition(or, OSD_ACT_CREATE_PARTITION, partition);\r\n}\r\nvoid osd_req_remove_partition(struct osd_request *or, osd_id partition)\r\n{\r\n_osd_req_encode_partition(or, OSD_ACT_REMOVE_PARTITION, partition);\r\n}\r\nstatic int _osd_req_list_objects(struct osd_request *or,\r\n__be16 action, const struct osd_obj_id *obj, osd_id initial_id,\r\nstruct osd_obj_id_list *list, unsigned nelem)\r\n{\r\nstruct request_queue *q = osd_request_queue(or->osd_dev);\r\nu64 len = nelem * sizeof(osd_id) + sizeof(*list);\r\nstruct bio *bio;\r\n_osd_req_encode_common(or, action, obj, (u64)initial_id, len);\r\nif (list->list_identifier)\r\n_osd_req_encode_olist(or, list);\r\nWARN_ON(or->in.bio);\r\nbio = bio_map_kern(q, list, len, or->alloc_flags);\r\nif (IS_ERR(bio)) {\r\nOSD_ERR("!!! Failed to allocate list_objects BIO\n");\r\nreturn PTR_ERR(bio);\r\n}\r\nbio->bi_rw &= ~REQ_WRITE;\r\nor->in.bio = bio;\r\nor->in.total_bytes = bio->bi_iter.bi_size;\r\nreturn 0;\r\n}\r\nint osd_req_list_partition_collections(struct osd_request *or,\r\nosd_id partition, osd_id initial_id, struct osd_obj_id_list *list,\r\nunsigned nelem)\r\n{\r\nstruct osd_obj_id par = {\r\n.partition = partition,\r\n.id = 0,\r\n};\r\nreturn osd_req_list_collection_objects(or, &par, initial_id, list,\r\nnelem);\r\n}\r\nint osd_req_list_partition_objects(struct osd_request *or,\r\nosd_id partition, osd_id initial_id, struct osd_obj_id_list *list,\r\nunsigned nelem)\r\n{\r\nstruct osd_obj_id par = {\r\n.partition = partition,\r\n.id = 0,\r\n};\r\nreturn _osd_req_list_objects(or, OSD_ACT_LIST, &par, initial_id, list,\r\nnelem);\r\n}\r\nvoid osd_req_flush_partition(struct osd_request *or,\r\nosd_id partition, enum osd_options_flush_scope_values op)\r\n{\r\n_osd_req_encode_partition(or, OSD_ACT_FLUSH_PARTITION, partition);\r\n_osd_req_encode_flush(or, op);\r\n}\r\nint osd_req_list_collection_objects(struct osd_request *or,\r\nconst struct osd_obj_id *obj, osd_id initial_id,\r\nstruct osd_obj_id_list *list, unsigned nelem)\r\n{\r\nreturn _osd_req_list_objects(or, OSD_ACT_LIST_COLLECTION, obj,\r\ninitial_id, list, nelem);\r\n}\r\nvoid osd_req_flush_collection(struct osd_request *or,\r\nconst struct osd_obj_id *obj, enum osd_options_flush_scope_values op)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_FLUSH_PARTITION, obj, 0, 0);\r\n_osd_req_encode_flush(or, op);\r\n}\r\nvoid osd_req_create_object(struct osd_request *or, struct osd_obj_id *obj)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_CREATE, obj, 0, 0);\r\n}\r\nvoid osd_req_remove_object(struct osd_request *or, struct osd_obj_id *obj)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_REMOVE, obj, 0, 0);\r\n}\r\nvoid osd_req_write(struct osd_request *or,\r\nconst struct osd_obj_id *obj, u64 offset,\r\nstruct bio *bio, u64 len)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_WRITE, obj, offset, len);\r\nWARN_ON(or->out.bio || or->out.total_bytes);\r\nWARN_ON(0 == (bio->bi_rw & REQ_WRITE));\r\nor->out.bio = bio;\r\nor->out.total_bytes = len;\r\n}\r\nint osd_req_write_kern(struct osd_request *or,\r\nconst struct osd_obj_id *obj, u64 offset, void* buff, u64 len)\r\n{\r\nstruct request_queue *req_q = osd_request_queue(or->osd_dev);\r\nstruct bio *bio = bio_map_kern(req_q, buff, len, GFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_rw |= REQ_WRITE;\r\nosd_req_write(or, obj, offset, bio, len);\r\nreturn 0;\r\n}\r\nvoid osd_req_flush_object(struct osd_request *or,\r\nconst struct osd_obj_id *obj, enum osd_options_flush_scope_values op,\r\nu64 offset, u64 len)\r\n{\r\nif (unlikely(osd_req_is_ver1(or) && (offset || len))) {\r\nOSD_DEBUG("OSD Ver1 flush on specific range ignored\n");\r\noffset = 0;\r\nlen = 0;\r\n}\r\n_osd_req_encode_common(or, OSD_ACT_FLUSH, obj, offset, len);\r\n_osd_req_encode_flush(or, op);\r\n}\r\nvoid osd_req_read(struct osd_request *or,\r\nconst struct osd_obj_id *obj, u64 offset,\r\nstruct bio *bio, u64 len)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_READ, obj, offset, len);\r\nWARN_ON(or->in.bio || or->in.total_bytes);\r\nWARN_ON(bio->bi_rw & REQ_WRITE);\r\nor->in.bio = bio;\r\nor->in.total_bytes = len;\r\n}\r\nint osd_req_read_kern(struct osd_request *or,\r\nconst struct osd_obj_id *obj, u64 offset, void* buff, u64 len)\r\n{\r\nstruct request_queue *req_q = osd_request_queue(or->osd_dev);\r\nstruct bio *bio = bio_map_kern(req_q, buff, len, GFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nosd_req_read(or, obj, offset, bio, len);\r\nreturn 0;\r\n}\r\nstatic int _add_sg_continuation_descriptor(struct osd_request *or,\r\nconst struct osd_sg_entry *sglist, unsigned numentries, u64 *len)\r\n{\r\nstruct osd_sg_continuation_descriptor *oscd;\r\nu32 oscd_size;\r\nunsigned i;\r\nint ret;\r\noscd_size = sizeof(*oscd) + numentries * sizeof(oscd->entries[0]);\r\nif (!or->cdb_cont.total_bytes) {\r\nor->cdb_cont.total_bytes =\r\nsizeof(struct osd_continuation_segment_header);\r\n}\r\nret = _alloc_cdb_cont(or, or->cdb_cont.total_bytes + oscd_size);\r\nif (unlikely(ret))\r\nreturn ret;\r\noscd = or->cdb_cont.buff + or->cdb_cont.total_bytes;\r\noscd->hdr.type = cpu_to_be16(SCATTER_GATHER_LIST);\r\noscd->hdr.pad_length = 0;\r\noscd->hdr.length = cpu_to_be32(oscd_size - sizeof(*oscd));\r\n*len = 0;\r\nfor (i = 0; i < numentries; i++) {\r\noscd->entries[i].offset = cpu_to_be64(sglist[i].offset);\r\noscd->entries[i].len = cpu_to_be64(sglist[i].len);\r\n*len += sglist[i].len;\r\n}\r\nor->cdb_cont.total_bytes += oscd_size;\r\nOSD_DEBUG("total_bytes=%d oscd_size=%d numentries=%d\n",\r\nor->cdb_cont.total_bytes, oscd_size, numentries);\r\nreturn 0;\r\n}\r\nstatic int _osd_req_finalize_cdb_cont(struct osd_request *or, const u8 *cap_key)\r\n{\r\nstruct request_queue *req_q = osd_request_queue(or->osd_dev);\r\nstruct bio *bio;\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nstruct osd_continuation_segment_header *cont_seg_hdr;\r\nif (!or->cdb_cont.total_bytes)\r\nreturn 0;\r\ncont_seg_hdr = or->cdb_cont.buff;\r\ncont_seg_hdr->format = CDB_CONTINUATION_FORMAT_V2;\r\ncont_seg_hdr->service_action = cdbh->varlen_cdb.service_action;\r\nbio = bio_map_kern(req_q, or->cdb_cont.buff, or->cdb_cont.total_bytes,\r\nGFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_rw |= REQ_WRITE;\r\nosd_sec_sign_data(cont_seg_hdr->integrity_check, bio, cap_key);\r\ncdbh->v2.cdb_continuation_length = cpu_to_be32(or->cdb_cont.total_bytes);\r\nbio->bi_next = or->out.bio;\r\nor->out.bio = bio;\r\nor->out.total_bytes += or->cdb_cont.total_bytes;\r\nreturn 0;\r\n}\r\nint osd_req_write_sg(struct osd_request *or,\r\nconst struct osd_obj_id *obj, struct bio *bio,\r\nconst struct osd_sg_entry *sglist, unsigned numentries)\r\n{\r\nu64 len;\r\nint ret = _add_sg_continuation_descriptor(or, sglist, numentries, &len);\r\nif (ret)\r\nreturn ret;\r\nosd_req_write(or, obj, 0, bio, len);\r\nreturn 0;\r\n}\r\nint osd_req_read_sg(struct osd_request *or,\r\nconst struct osd_obj_id *obj, struct bio *bio,\r\nconst struct osd_sg_entry *sglist, unsigned numentries)\r\n{\r\nu64 len;\r\nu64 off;\r\nint ret;\r\nif (numentries > 1) {\r\noff = 0;\r\nret = _add_sg_continuation_descriptor(or, sglist, numentries,\r\n&len);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nlen = sglist->len;\r\noff = sglist->offset;\r\n}\r\nosd_req_read(or, obj, off, bio, len);\r\nreturn 0;\r\n}\r\nstatic struct bio *_create_sg_bios(struct osd_request *or,\r\nvoid **buff, const struct osd_sg_entry *sglist, unsigned numentries)\r\n{\r\nstruct request_queue *q = osd_request_queue(or->osd_dev);\r\nstruct bio *bio;\r\nunsigned i;\r\nbio = bio_kmalloc(GFP_KERNEL, numentries);\r\nif (unlikely(!bio)) {\r\nOSD_DEBUG("Failed to allocate BIO size=%u\n", numentries);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0; i < numentries; i++) {\r\nunsigned offset = offset_in_page(buff[i]);\r\nstruct page *page = virt_to_page(buff[i]);\r\nunsigned len = sglist[i].len;\r\nunsigned added_len;\r\nBUG_ON(offset + len > PAGE_SIZE);\r\nadded_len = bio_add_pc_page(q, bio, page, len, offset);\r\nif (unlikely(len != added_len)) {\r\nOSD_DEBUG("bio_add_pc_page len(%d) != added_len(%d)\n",\r\nlen, added_len);\r\nbio_put(bio);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nreturn bio;\r\n}\r\nint osd_req_write_sg_kern(struct osd_request *or,\r\nconst struct osd_obj_id *obj, void **buff,\r\nconst struct osd_sg_entry *sglist, unsigned numentries)\r\n{\r\nstruct bio *bio = _create_sg_bios(or, buff, sglist, numentries);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_rw |= REQ_WRITE;\r\nosd_req_write_sg(or, obj, bio, sglist, numentries);\r\nreturn 0;\r\n}\r\nint osd_req_read_sg_kern(struct osd_request *or,\r\nconst struct osd_obj_id *obj, void **buff,\r\nconst struct osd_sg_entry *sglist, unsigned numentries)\r\n{\r\nstruct bio *bio = _create_sg_bios(or, buff, sglist, numentries);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nosd_req_read_sg(or, obj, bio, sglist, numentries);\r\nreturn 0;\r\n}\r\nvoid osd_req_get_attributes(struct osd_request *or,\r\nconst struct osd_obj_id *obj)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_GET_ATTRIBUTES, obj, 0, 0);\r\n}\r\nvoid osd_req_set_attributes(struct osd_request *or,\r\nconst struct osd_obj_id *obj)\r\n{\r\n_osd_req_encode_common(or, OSD_ACT_SET_ATTRIBUTES, obj, 0, 0);\r\n}\r\nint osd_req_add_set_attr_list(struct osd_request *or,\r\nconst struct osd_attr *oa, unsigned nelem)\r\n{\r\nunsigned total_bytes = or->set_attr.total_bytes;\r\nvoid *attr_last;\r\nint ret;\r\nif (or->attributes_mode &&\r\nor->attributes_mode != OSD_CDB_GET_SET_ATTR_LISTS) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nor->attributes_mode = OSD_CDB_GET_SET_ATTR_LISTS;\r\nif (!total_bytes) {\r\ntotal_bytes = _osd_req_sizeof_alist_header(or);\r\nret = _alloc_set_attr_list(or, oa, nelem, total_bytes);\r\nif (ret)\r\nreturn ret;\r\n_osd_req_set_alist_type(or, or->set_attr.buff,\r\nOSD_ATTR_LIST_SET_RETRIEVE);\r\n}\r\nattr_last = or->set_attr.buff + total_bytes;\r\nfor (; nelem; --nelem) {\r\nunsigned elem_size = _osd_req_alist_elem_size(or, oa->len);\r\ntotal_bytes += elem_size;\r\nif (unlikely(or->set_attr.alloc_size < total_bytes)) {\r\nor->set_attr.total_bytes = total_bytes - elem_size;\r\nret = _alloc_set_attr_list(or, oa, nelem, total_bytes);\r\nif (ret)\r\nreturn ret;\r\nattr_last =\r\nor->set_attr.buff + or->set_attr.total_bytes;\r\n}\r\n_osd_req_alist_elem_encode(or, attr_last, oa);\r\nattr_last += elem_size;\r\n++oa;\r\n}\r\nor->set_attr.total_bytes = total_bytes;\r\nreturn 0;\r\n}\r\nstatic int _req_append_segment(struct osd_request *or,\r\nunsigned padding, struct _osd_req_data_segment *seg,\r\nstruct _osd_req_data_segment *last_seg, struct _osd_io_info *io)\r\n{\r\nvoid *pad_buff;\r\nint ret;\r\nif (padding) {\r\nif (last_seg &&\r\n(padding <= last_seg->alloc_size - last_seg->total_bytes))\r\npad_buff = last_seg->buff + last_seg->total_bytes;\r\nelse\r\npad_buff = io->pad_buff;\r\nret = blk_rq_map_kern(io->req->q, io->req, pad_buff, padding,\r\nor->alloc_flags);\r\nif (ret)\r\nreturn ret;\r\nio->total_bytes += padding;\r\n}\r\nret = blk_rq_map_kern(io->req->q, io->req, seg->buff, seg->total_bytes,\r\nor->alloc_flags);\r\nif (ret)\r\nreturn ret;\r\nio->total_bytes += seg->total_bytes;\r\nOSD_DEBUG("padding=%d buff=%p total_bytes=%d\n", padding, seg->buff,\r\nseg->total_bytes);\r\nreturn 0;\r\n}\r\nstatic int _osd_req_finalize_set_attr_list(struct osd_request *or)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nunsigned padding;\r\nint ret;\r\nif (!or->set_attr.total_bytes) {\r\ncdbh->attrs_list.set_attr_offset = OSD_OFFSET_UNUSED;\r\nreturn 0;\r\n}\r\ncdbh->attrs_list.set_attr_bytes = cpu_to_be32(or->set_attr.total_bytes);\r\ncdbh->attrs_list.set_attr_offset =\r\nosd_req_encode_offset(or, or->out.total_bytes, &padding);\r\nret = _req_append_segment(or, padding, &or->set_attr,\r\nor->out.last_seg, &or->out);\r\nif (ret)\r\nreturn ret;\r\nor->out.last_seg = &or->set_attr;\r\nreturn 0;\r\n}\r\nint osd_req_add_get_attr_list(struct osd_request *or,\r\nconst struct osd_attr *oa, unsigned nelem)\r\n{\r\nunsigned total_bytes = or->enc_get_attr.total_bytes;\r\nvoid *attr_last;\r\nint ret;\r\nif (or->attributes_mode &&\r\nor->attributes_mode != OSD_CDB_GET_SET_ATTR_LISTS) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nor->attributes_mode = OSD_CDB_GET_SET_ATTR_LISTS;\r\nif (!or->get_attr.total_bytes)\r\nor->get_attr.total_bytes = _osd_req_sizeof_alist_header(or);\r\nif (!total_bytes) {\r\nunsigned max_bytes;\r\ntotal_bytes = _osd_req_sizeof_alist_header(or);\r\nmax_bytes = total_bytes +\r\nnelem * sizeof(struct osd_attributes_list_attrid);\r\nret = _alloc_get_attr_desc(or, max_bytes);\r\nif (ret)\r\nreturn ret;\r\n_osd_req_set_alist_type(or, or->enc_get_attr.buff,\r\nOSD_ATTR_LIST_GET);\r\n}\r\nattr_last = or->enc_get_attr.buff + total_bytes;\r\nfor (; nelem; --nelem) {\r\nstruct osd_attributes_list_attrid *attrid;\r\nconst unsigned cur_size = sizeof(*attrid);\r\ntotal_bytes += cur_size;\r\nif (unlikely(or->enc_get_attr.alloc_size < total_bytes)) {\r\nor->enc_get_attr.total_bytes = total_bytes - cur_size;\r\nret = _alloc_get_attr_desc(or,\r\ntotal_bytes + nelem * sizeof(*attrid));\r\nif (ret)\r\nreturn ret;\r\nattr_last = or->enc_get_attr.buff +\r\nor->enc_get_attr.total_bytes;\r\n}\r\nattrid = attr_last;\r\nattrid->attr_page = cpu_to_be32(oa->attr_page);\r\nattrid->attr_id = cpu_to_be32(oa->attr_id);\r\nattr_last += cur_size;\r\nor->get_attr.total_bytes +=\r\n_osd_req_alist_elem_size(or, oa->len);\r\n++oa;\r\n}\r\nor->enc_get_attr.total_bytes = total_bytes;\r\nOSD_DEBUG(\r\n"get_attr.total_bytes=%u(%u) enc_get_attr.total_bytes=%u(%Zu)\n",\r\nor->get_attr.total_bytes,\r\nor->get_attr.total_bytes - _osd_req_sizeof_alist_header(or),\r\nor->enc_get_attr.total_bytes,\r\n(or->enc_get_attr.total_bytes - _osd_req_sizeof_alist_header(or))\r\n/ sizeof(struct osd_attributes_list_attrid));\r\nreturn 0;\r\n}\r\nstatic int _osd_req_finalize_get_attr_list(struct osd_request *or)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nunsigned out_padding;\r\nunsigned in_padding;\r\nint ret;\r\nif (!or->enc_get_attr.total_bytes) {\r\ncdbh->attrs_list.get_attr_desc_offset = OSD_OFFSET_UNUSED;\r\ncdbh->attrs_list.get_attr_offset = OSD_OFFSET_UNUSED;\r\nreturn 0;\r\n}\r\nret = _alloc_get_attr_list(or);\r\nif (ret)\r\nreturn ret;\r\nOSD_DEBUG("out-going\n");\r\ncdbh->attrs_list.get_attr_desc_bytes =\r\ncpu_to_be32(or->enc_get_attr.total_bytes);\r\ncdbh->attrs_list.get_attr_desc_offset =\r\nosd_req_encode_offset(or, or->out.total_bytes, &out_padding);\r\nret = _req_append_segment(or, out_padding, &or->enc_get_attr,\r\nor->out.last_seg, &or->out);\r\nif (ret)\r\nreturn ret;\r\nor->out.last_seg = &or->enc_get_attr;\r\nOSD_DEBUG("in-coming\n");\r\ncdbh->attrs_list.get_attr_alloc_length =\r\ncpu_to_be32(or->get_attr.total_bytes);\r\ncdbh->attrs_list.get_attr_offset =\r\nosd_req_encode_offset(or, or->in.total_bytes, &in_padding);\r\nret = _req_append_segment(or, in_padding, &or->get_attr, NULL,\r\n&or->in);\r\nif (ret)\r\nreturn ret;\r\nor->in.last_seg = &or->get_attr;\r\nreturn 0;\r\n}\r\nint osd_req_decode_get_attr_list(struct osd_request *or,\r\nstruct osd_attr *oa, int *nelem, void **iterator)\r\n{\r\nunsigned cur_bytes, returned_bytes;\r\nint n;\r\nconst unsigned sizeof_attr_list = _osd_req_sizeof_alist_header(or);\r\nvoid *cur_p;\r\nif (!_osd_req_is_alist_type(or, or->get_attr.buff,\r\nOSD_ATTR_LIST_SET_RETRIEVE)) {\r\noa->attr_page = 0;\r\noa->attr_id = 0;\r\noa->val_ptr = NULL;\r\noa->len = 0;\r\n*iterator = NULL;\r\nreturn 0;\r\n}\r\nif (*iterator) {\r\nBUG_ON((*iterator < or->get_attr.buff) ||\r\n(or->get_attr.buff + or->get_attr.alloc_size < *iterator));\r\ncur_p = *iterator;\r\ncur_bytes = (*iterator - or->get_attr.buff) - sizeof_attr_list;\r\nreturned_bytes = or->get_attr.total_bytes;\r\n} else {\r\ncur_bytes = sizeof_attr_list;\r\nreturned_bytes = _osd_req_alist_size(or, or->get_attr.buff) +\r\nsizeof_attr_list;\r\ncur_p = or->get_attr.buff + sizeof_attr_list;\r\nif (returned_bytes > or->get_attr.alloc_size) {\r\nOSD_DEBUG("target report: space was not big enough! "\r\n"Allocate=%u Needed=%u\n",\r\nor->get_attr.alloc_size,\r\nreturned_bytes + sizeof_attr_list);\r\nreturned_bytes =\r\nor->get_attr.alloc_size - sizeof_attr_list;\r\n}\r\nor->get_attr.total_bytes = returned_bytes;\r\n}\r\nfor (n = 0; (n < *nelem) && (cur_bytes < returned_bytes); ++n) {\r\nint inc = _osd_req_alist_elem_decode(or, cur_p, oa,\r\nreturned_bytes - cur_bytes);\r\nif (inc < 0) {\r\nOSD_ERR("BAD FOOD from target. list not valid!"\r\n"c=%d r=%d n=%d\n",\r\ncur_bytes, returned_bytes, n);\r\noa->val_ptr = NULL;\r\ncur_bytes = returned_bytes;\r\nbreak;\r\n}\r\ncur_bytes += inc;\r\ncur_p += inc;\r\n++oa;\r\n}\r\n*iterator = (returned_bytes - cur_bytes) ? cur_p : NULL;\r\n*nelem = n;\r\nreturn returned_bytes - cur_bytes;\r\n}\r\nint osd_req_add_get_attr_page(struct osd_request *or,\r\nu32 page_id, void *attar_page, unsigned max_page_len,\r\nconst struct osd_attr *set_one_attr)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nif (or->attributes_mode &&\r\nor->attributes_mode != OSD_CDB_GET_ATTR_PAGE_SET_ONE) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nor->attributes_mode = OSD_CDB_GET_ATTR_PAGE_SET_ONE;\r\nor->get_attr.buff = attar_page;\r\nor->get_attr.total_bytes = max_page_len;\r\ncdbh->attrs_page.get_attr_page = cpu_to_be32(page_id);\r\ncdbh->attrs_page.get_attr_alloc_length = cpu_to_be32(max_page_len);\r\nif (!set_one_attr || !set_one_attr->attr_page)\r\nreturn 0;\r\nor->set_attr.buff = set_one_attr->val_ptr;\r\nor->set_attr.total_bytes = set_one_attr->len;\r\ncdbh->attrs_page.set_attr_page = cpu_to_be32(set_one_attr->attr_page);\r\ncdbh->attrs_page.set_attr_id = cpu_to_be32(set_one_attr->attr_id);\r\ncdbh->attrs_page.set_attr_length = cpu_to_be32(set_one_attr->len);\r\nreturn 0;\r\n}\r\nstatic int _osd_req_finalize_attr_page(struct osd_request *or)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nunsigned in_padding, out_padding;\r\nint ret;\r\ncdbh->attrs_page.get_attr_offset =\r\nosd_req_encode_offset(or, or->in.total_bytes, &in_padding);\r\nret = _req_append_segment(or, in_padding, &or->get_attr, NULL,\r\n&or->in);\r\nif (ret)\r\nreturn ret;\r\nif (or->set_attr.total_bytes == 0)\r\nreturn 0;\r\ncdbh->attrs_page.set_attr_offset =\r\nosd_req_encode_offset(or, or->out.total_bytes, &out_padding);\r\nret = _req_append_segment(or, out_padding, &or->set_attr, NULL,\r\n&or->out);\r\nreturn ret;\r\n}\r\nstatic inline void osd_sec_parms_set_out_offset(bool is_v1,\r\nstruct osd_security_parameters *sec_parms, osd_cdb_offset offset)\r\n{\r\nif (is_v1)\r\nsec_parms->v1.data_out_integrity_check_offset = offset;\r\nelse\r\nsec_parms->v2.data_out_integrity_check_offset = offset;\r\n}\r\nstatic inline void osd_sec_parms_set_in_offset(bool is_v1,\r\nstruct osd_security_parameters *sec_parms, osd_cdb_offset offset)\r\n{\r\nif (is_v1)\r\nsec_parms->v1.data_in_integrity_check_offset = offset;\r\nelse\r\nsec_parms->v2.data_in_integrity_check_offset = offset;\r\n}\r\nstatic int _osd_req_finalize_data_integrity(struct osd_request *or,\r\nbool has_in, bool has_out, struct bio *out_data_bio, u64 out_data_bytes,\r\nconst u8 *cap_key)\r\n{\r\nstruct osd_security_parameters *sec_parms = _osd_req_sec_params(or);\r\nint ret;\r\nif (!osd_is_sec_alldata(sec_parms))\r\nreturn 0;\r\nif (has_out) {\r\nstruct _osd_req_data_segment seg = {\r\n.buff = &or->out_data_integ,\r\n.total_bytes = sizeof(or->out_data_integ),\r\n};\r\nunsigned pad;\r\nor->out_data_integ.data_bytes = cpu_to_be64(out_data_bytes);\r\nor->out_data_integ.set_attributes_bytes = cpu_to_be64(\r\nor->set_attr.total_bytes);\r\nor->out_data_integ.get_attributes_bytes = cpu_to_be64(\r\nor->enc_get_attr.total_bytes);\r\nosd_sec_parms_set_out_offset(osd_req_is_ver1(or), sec_parms,\r\nosd_req_encode_offset(or, or->out.total_bytes, &pad));\r\nret = _req_append_segment(or, pad, &seg, or->out.last_seg,\r\n&or->out);\r\nif (ret)\r\nreturn ret;\r\nor->out.last_seg = NULL;\r\nosd_sec_sign_data(&or->out_data_integ, out_data_bio,\r\ncap_key);\r\n}\r\nif (has_in) {\r\nstruct _osd_req_data_segment seg = {\r\n.buff = &or->in_data_integ,\r\n.total_bytes = sizeof(or->in_data_integ),\r\n};\r\nunsigned pad;\r\nosd_sec_parms_set_in_offset(osd_req_is_ver1(or), sec_parms,\r\nosd_req_encode_offset(or, or->in.total_bytes, &pad));\r\nret = _req_append_segment(or, pad, &seg, or->in.last_seg,\r\n&or->in);\r\nif (ret)\r\nreturn ret;\r\nor->in.last_seg = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct request *_make_request(struct request_queue *q, bool has_write,\r\nstruct _osd_io_info *oii, gfp_t flags)\r\n{\r\nif (oii->bio)\r\nreturn blk_make_request(q, oii->bio, flags);\r\nelse {\r\nstruct request *req;\r\nreq = blk_get_request(q, has_write ? WRITE : READ, flags);\r\nif (IS_ERR(req))\r\nreturn req;\r\nblk_rq_set_block_pc(req);\r\nreturn req;\r\n}\r\n}\r\nstatic int _init_blk_request(struct osd_request *or,\r\nbool has_in, bool has_out)\r\n{\r\ngfp_t flags = or->alloc_flags;\r\nstruct scsi_device *scsi_device = or->osd_dev->scsi_device;\r\nstruct request_queue *q = scsi_device->request_queue;\r\nstruct request *req;\r\nint ret;\r\nreq = _make_request(q, has_out, has_out ? &or->out : &or->in, flags);\r\nif (IS_ERR(req)) {\r\nret = PTR_ERR(req);\r\ngoto out;\r\n}\r\nor->request = req;\r\nreq->cmd_flags |= REQ_QUIET;\r\nreq->timeout = or->timeout;\r\nreq->retries = or->retries;\r\nreq->sense = or->sense;\r\nreq->sense_len = 0;\r\nif (has_out) {\r\nor->out.req = req;\r\nif (has_in) {\r\nreq = _make_request(q, false, &or->in, flags);\r\nif (IS_ERR(req)) {\r\nOSD_DEBUG("blk_get_request for bidi failed\n");\r\nret = PTR_ERR(req);\r\ngoto out;\r\n}\r\nblk_rq_set_block_pc(req);\r\nor->in.req = or->request->next_rq = req;\r\n}\r\n} else if (has_in)\r\nor->in.req = req;\r\nret = 0;\r\nout:\r\nOSD_DEBUG("or=%p has_in=%d has_out=%d => %d, %p\n",\r\nor, has_in, has_out, ret, or->request);\r\nreturn ret;\r\n}\r\nint osd_finalize_request(struct osd_request *or,\r\nu8 options, const void *cap, const u8 *cap_key)\r\n{\r\nstruct osd_cdb_head *cdbh = osd_cdb_head(&or->cdb);\r\nbool has_in, has_out;\r\nstruct bio *out_data_bio = or->out.bio;\r\nu64 out_data_bytes = or->out.total_bytes;\r\nint ret;\r\nif (options & OSD_REQ_FUA)\r\ncdbh->options |= OSD_CDB_FUA;\r\nif (options & OSD_REQ_DPO)\r\ncdbh->options |= OSD_CDB_DPO;\r\nif (options & OSD_REQ_BYPASS_TIMESTAMPS)\r\ncdbh->timestamp_control = OSD_CDB_BYPASS_TIMESTAMPS;\r\nosd_set_caps(&or->cdb, cap);\r\nhas_in = or->in.bio || or->get_attr.total_bytes;\r\nhas_out = or->out.bio || or->cdb_cont.total_bytes ||\r\nor->set_attr.total_bytes || or->enc_get_attr.total_bytes;\r\nret = _osd_req_finalize_cdb_cont(or, cap_key);\r\nif (ret) {\r\nOSD_DEBUG("_osd_req_finalize_cdb_cont failed\n");\r\nreturn ret;\r\n}\r\nret = _init_blk_request(or, has_in, has_out);\r\nif (ret) {\r\nOSD_DEBUG("_init_blk_request failed\n");\r\nreturn ret;\r\n}\r\nor->out.pad_buff = sg_out_pad_buffer;\r\nor->in.pad_buff = sg_in_pad_buffer;\r\nif (!or->attributes_mode)\r\nor->attributes_mode = OSD_CDB_GET_SET_ATTR_LISTS;\r\ncdbh->command_specific_options |= or->attributes_mode;\r\nif (or->attributes_mode == OSD_CDB_GET_ATTR_PAGE_SET_ONE) {\r\nret = _osd_req_finalize_attr_page(or);\r\nif (ret) {\r\nOSD_DEBUG("_osd_req_finalize_attr_page failed\n");\r\nreturn ret;\r\n}\r\n} else {\r\nret = _osd_req_finalize_set_attr_list(or);\r\nif (ret) {\r\nOSD_DEBUG("_osd_req_finalize_set_attr_list failed\n");\r\nreturn ret;\r\n}\r\nret = _osd_req_finalize_get_attr_list(or);\r\nif (ret) {\r\nOSD_DEBUG("_osd_req_finalize_get_attr_list failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = _osd_req_finalize_data_integrity(or, has_in, has_out,\r\nout_data_bio, out_data_bytes,\r\ncap_key);\r\nif (ret)\r\nreturn ret;\r\nosd_sec_sign_cdb(&or->cdb, cap_key);\r\nor->request->cmd = or->cdb.buff;\r\nor->request->cmd_len = _osd_req_cdb_len(or);\r\nreturn 0;\r\n}\r\nstatic bool _is_osd_security_code(int code)\r\n{\r\nreturn (code == osd_security_audit_value_frozen) ||\r\n(code == osd_security_working_key_frozen) ||\r\n(code == osd_nonce_not_unique) ||\r\n(code == osd_nonce_timestamp_out_of_range) ||\r\n(code == osd_invalid_dataout_buffer_integrity_check_value);\r\n}\r\nint osd_req_decode_sense_full(struct osd_request *or,\r\nstruct osd_sense_info *osi, bool silent,\r\nstruct osd_obj_id *bad_obj_list __unused, int max_obj __unused,\r\nstruct osd_attr *bad_attr_list, int max_attr)\r\n{\r\nint sense_len, original_sense_len;\r\nstruct osd_sense_info local_osi;\r\nstruct scsi_sense_descriptor_based *ssdb;\r\nvoid *cur_descriptor;\r\n#if (CONFIG_SCSI_OSD_DPRINT_SENSE == 0)\r\nconst bool __cur_sense_need_output = false;\r\n#else\r\nbool __cur_sense_need_output = !silent;\r\n#endif\r\nint ret;\r\nif (likely(!or->req_errors))\r\nreturn 0;\r\nosi = osi ? : &local_osi;\r\nmemset(osi, 0, sizeof(*osi));\r\nssdb = (typeof(ssdb))or->sense;\r\nsense_len = or->sense_len;\r\nif ((sense_len < (int)sizeof(*ssdb) || !ssdb->sense_key)) {\r\nOSD_ERR("Block-layer returned error(0x%x) but "\r\n"sense_len(%u) || key(%d) is empty\n",\r\nor->req_errors, sense_len, ssdb->sense_key);\r\ngoto analyze;\r\n}\r\nif ((ssdb->response_code != 0x72) && (ssdb->response_code != 0x73)) {\r\nOSD_ERR("Unrecognized scsi sense: rcode=%x length=%d\n",\r\nssdb->response_code, sense_len);\r\ngoto analyze;\r\n}\r\nosi->key = ssdb->sense_key;\r\nosi->additional_code = be16_to_cpu(ssdb->additional_sense_code);\r\noriginal_sense_len = ssdb->additional_sense_length + 8;\r\n#if (CONFIG_SCSI_OSD_DPRINT_SENSE == 1)\r\nif (__cur_sense_need_output)\r\n__cur_sense_need_output = (osi->key > scsi_sk_recovered_error);\r\n#endif\r\nOSD_SENSE_PRINT1("Main Sense information key=0x%x length(%d, %d) "\r\n"additional_code=0x%x async_error=%d errors=0x%x\n",\r\nosi->key, original_sense_len, sense_len,\r\nosi->additional_code, or->async_error,\r\nor->req_errors);\r\nif (original_sense_len < sense_len)\r\nsense_len = original_sense_len;\r\ncur_descriptor = ssdb->ssd;\r\nsense_len -= sizeof(*ssdb);\r\nwhile (sense_len > 0) {\r\nstruct scsi_sense_descriptor *ssd = cur_descriptor;\r\nint cur_len = ssd->additional_length + 2;\r\nsense_len -= cur_len;\r\nif (sense_len < 0)\r\nbreak;\r\nswitch (ssd->descriptor_type) {\r\ncase scsi_sense_information:\r\ncase scsi_sense_command_specific_information:\r\n{\r\nstruct scsi_sense_command_specific_data_descriptor\r\n*sscd = cur_descriptor;\r\nosi->command_info =\r\nget_unaligned_be64(&sscd->information) ;\r\nOSD_SENSE_PRINT2(\r\n"command_specific_information 0x%llx \n",\r\n_LLU(osi->command_info));\r\nbreak;\r\n}\r\ncase scsi_sense_key_specific:\r\n{\r\nstruct scsi_sense_key_specific_data_descriptor\r\n*ssks = cur_descriptor;\r\nosi->sense_info = get_unaligned_be16(&ssks->value);\r\nOSD_SENSE_PRINT2(\r\n"sense_key_specific_information %u"\r\n"sksv_cd_bpv_bp (0x%x)\n",\r\nosi->sense_info, ssks->sksv_cd_bpv_bp);\r\nbreak;\r\n}\r\ncase osd_sense_object_identification:\r\n{\r\nstruct osd_sense_identification_data_descriptor\r\n*osidd = cur_descriptor;\r\nosi->not_initiated_command_functions =\r\nle32_to_cpu(osidd->not_initiated_functions);\r\nosi->completed_command_functions =\r\nle32_to_cpu(osidd->completed_functions);\r\nosi->obj.partition = be64_to_cpu(osidd->partition_id);\r\nosi->obj.id = be64_to_cpu(osidd->object_id);\r\nOSD_SENSE_PRINT2(\r\n"object_identification pid=0x%llx oid=0x%llx\n",\r\n_LLU(osi->obj.partition), _LLU(osi->obj.id));\r\nOSD_SENSE_PRINT2(\r\n"not_initiated_bits(%x) "\r\n"completed_command_bits(%x)\n",\r\nosi->not_initiated_command_functions,\r\nosi->completed_command_functions);\r\nbreak;\r\n}\r\ncase osd_sense_response_integrity_check:\r\n{\r\nstruct osd_sense_response_integrity_check_descriptor\r\n*osricd = cur_descriptor;\r\nconst unsigned len =\r\nsizeof(osricd->integrity_check_value);\r\nchar key_dump[len*4 + 2];\r\nhex_dump_to_buffer(osricd->integrity_check_value, len,\r\n32, 1, key_dump, sizeof(key_dump), true);\r\nOSD_SENSE_PRINT2("response_integrity [%s]\n", key_dump);\r\n}\r\ncase osd_sense_attribute_identification:\r\n{\r\nstruct osd_sense_attributes_data_descriptor\r\n*osadd = cur_descriptor;\r\nunsigned len = min(cur_len, sense_len);\r\nstruct osd_sense_attr *pattr = osadd->sense_attrs;\r\nwhile (len >= sizeof(*pattr)) {\r\nu32 attr_page = be32_to_cpu(pattr->attr_page);\r\nu32 attr_id = be32_to_cpu(pattr->attr_id);\r\nif (!osi->attr.attr_page) {\r\nosi->attr.attr_page = attr_page;\r\nosi->attr.attr_id = attr_id;\r\n}\r\nif (bad_attr_list && max_attr) {\r\nbad_attr_list->attr_page = attr_page;\r\nbad_attr_list->attr_id = attr_id;\r\nbad_attr_list++;\r\nmax_attr--;\r\n}\r\nlen -= sizeof(*pattr);\r\nOSD_SENSE_PRINT2(\r\n"osd_sense_attribute_identification"\r\n"attr_page=0x%x attr_id=0x%x\n",\r\nattr_page, attr_id);\r\n}\r\n}\r\ncase scsi_sense_field_replaceable_unit:\r\nOSD_SENSE_PRINT2("scsi_sense_field_replaceable_unit\n");\r\nbreak;\r\ncase scsi_sense_stream_commands:\r\nOSD_SENSE_PRINT2("scsi_sense_stream_commands\n");\r\nbreak;\r\ncase scsi_sense_block_commands:\r\nOSD_SENSE_PRINT2("scsi_sense_block_commands\n");\r\nbreak;\r\ncase scsi_sense_ata_return:\r\nOSD_SENSE_PRINT2("scsi_sense_ata_return\n");\r\nbreak;\r\ndefault:\r\nif (ssd->descriptor_type <= scsi_sense_Reserved_last)\r\nOSD_SENSE_PRINT2(\r\n"scsi_sense Reserved descriptor (0x%x)",\r\nssd->descriptor_type);\r\nelse\r\nOSD_SENSE_PRINT2(\r\n"scsi_sense Vendor descriptor (0x%x)",\r\nssd->descriptor_type);\r\n}\r\ncur_descriptor += cur_len;\r\n}\r\nanalyze:\r\nif (!osi->key) {\r\nif (or->async_error == -ENOMEM)\r\nosi->osd_err_pri = OSD_ERR_PRI_RESOURCE;\r\nelse\r\nosi->osd_err_pri = OSD_ERR_PRI_UNREACHABLE;\r\nret = or->async_error;\r\n} else if (osi->key <= scsi_sk_recovered_error) {\r\nosi->osd_err_pri = 0;\r\nret = 0;\r\n} else if (osi->additional_code == scsi_invalid_field_in_cdb) {\r\nif (osi->cdb_field_offset == OSD_CFO_STARTING_BYTE) {\r\nosi->osd_err_pri = OSD_ERR_PRI_CLEAR_PAGES;\r\nret = -EFAULT;\r\n} else if (osi->cdb_field_offset == OSD_CFO_OBJECT_ID) {\r\nosi->osd_err_pri = OSD_ERR_PRI_NOT_FOUND;\r\nret = -ENOENT;\r\n} else if (osi->cdb_field_offset == OSD_CFO_PERMISSIONS) {\r\nosi->osd_err_pri = OSD_ERR_PRI_NO_ACCESS;\r\nret = -EACCES;\r\n} else {\r\nosi->osd_err_pri = OSD_ERR_PRI_BAD_CRED;\r\nret = -EINVAL;\r\n}\r\n} else if (osi->additional_code == osd_quota_error) {\r\nosi->osd_err_pri = OSD_ERR_PRI_NO_SPACE;\r\nret = -ENOSPC;\r\n} else if (_is_osd_security_code(osi->additional_code)) {\r\nosi->osd_err_pri = OSD_ERR_PRI_BAD_CRED;\r\nret = -EINVAL;\r\n} else {\r\nosi->osd_err_pri = OSD_ERR_PRI_EIO;\r\nret = -EIO;\r\n}\r\nif (!or->out.residual)\r\nor->out.residual = or->out.total_bytes;\r\nif (!or->in.residual)\r\nor->in.residual = or->in.total_bytes;\r\nreturn ret;\r\n}\r\nvoid osd_sec_init_nosec_doall_caps(void *caps,\r\nconst struct osd_obj_id *obj, bool is_collection, const bool is_v1)\r\n{\r\nstruct osd_capability *cap = caps;\r\nu8 type;\r\nu8 descriptor_type;\r\nif (likely(obj->id)) {\r\nif (unlikely(is_collection)) {\r\ntype = OSD_SEC_OBJ_COLLECTION;\r\ndescriptor_type = is_v1 ? OSD_SEC_OBJ_DESC_OBJ :\r\nOSD_SEC_OBJ_DESC_COL;\r\n} else {\r\ntype = OSD_SEC_OBJ_USER;\r\ndescriptor_type = OSD_SEC_OBJ_DESC_OBJ;\r\n}\r\nWARN_ON(!obj->partition);\r\n} else {\r\ntype = obj->partition ? OSD_SEC_OBJ_PARTITION :\r\nOSD_SEC_OBJ_ROOT;\r\ndescriptor_type = OSD_SEC_OBJ_DESC_PAR;\r\n}\r\nmemset(cap, 0, sizeof(*cap));\r\ncap->h.format = OSD_SEC_CAP_FORMAT_VER1;\r\ncap->h.integrity_algorithm__key_version = 0;\r\ncap->h.security_method = OSD_SEC_NOSEC;\r\ncap->h.object_type = type;\r\nosd_sec_set_caps(&cap->h, OSD_SEC_CAP_V1_ALL_CAPS);\r\ncap->h.object_descriptor_type = descriptor_type;\r\ncap->od.obj_desc.policy_access_tag = 0;\r\ncap->od.obj_desc.allowed_partition_id = cpu_to_be64(obj->partition);\r\ncap->od.obj_desc.allowed_object_id = cpu_to_be64(obj->id);\r\n}\r\nvoid osd_set_caps(struct osd_cdb *cdb, const void *caps)\r\n{\r\nbool is_ver1 = true;\r\nmemcpy(&cdb->v1.caps, caps, is_ver1 ? OSDv1_CAP_LEN : OSD_CAP_LEN);\r\n}\r\nbool osd_is_sec_alldata(struct osd_security_parameters *sec_parms __unused)\r\n{\r\nreturn false;\r\n}\r\nvoid osd_sec_sign_cdb(struct osd_cdb *ocdb __unused, const u8 *cap_key __unused)\r\n{\r\n}\r\nvoid osd_sec_sign_data(void *data_integ __unused,\r\nstruct bio *bio __unused, const u8 *cap_key __unused)\r\n{\r\n}\r\nosd_cdb_offset __osd_encode_offset(\r\nu64 offset, unsigned *padding, int min_shift, int max_shift)\r\n{\r\nu64 try_offset = -1, mod, align;\r\nosd_cdb_offset be32_offset;\r\nint shift;\r\n*padding = 0;\r\nif (!offset)\r\nreturn 0;\r\nfor (shift = min_shift; shift < max_shift; ++shift) {\r\ntry_offset = offset >> shift;\r\nif (try_offset < (1 << OSD_OFFSET_MAX_BITS))\r\nbreak;\r\n}\r\nBUG_ON(shift == max_shift);\r\nalign = 1 << shift;\r\nmod = offset & (align - 1);\r\nif (mod) {\r\n*padding = align - mod;\r\ntry_offset += 1;\r\n}\r\ntry_offset |= ((shift - 8) & 0xf) << 28;\r\nbe32_offset = cpu_to_be32((u32)try_offset);\r\nOSD_DEBUG("offset=%llu mantissa=%llu exp=%d encoded=%x pad=%d\n",\r\n_LLU(offset), _LLU(try_offset & 0x0FFFFFFF), shift,\r\nbe32_offset, *padding);\r\nreturn be32_offset;\r\n}
