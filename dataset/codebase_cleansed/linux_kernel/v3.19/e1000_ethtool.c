static int e1000_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (hw->media_type == e1000_media_type_copper) {\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full|\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP);\r\necmd->advertising = ADVERTISED_TP;\r\nif (hw->autoneg == 1) {\r\necmd->advertising |= ADVERTISED_Autoneg;\r\necmd->advertising |= hw->autoneg_advertised;\r\n}\r\necmd->port = PORT_TP;\r\necmd->phy_address = hw->phy_addr;\r\nif (hw->mac_type == e1000_82543)\r\necmd->transceiver = XCVR_EXTERNAL;\r\nelse\r\necmd->transceiver = XCVR_INTERNAL;\r\n} else {\r\necmd->supported = (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Autoneg);\r\necmd->advertising = (ADVERTISED_1000baseT_Full |\r\nADVERTISED_FIBRE |\r\nADVERTISED_Autoneg);\r\necmd->port = PORT_FIBRE;\r\nif (hw->mac_type >= e1000_82545)\r\necmd->transceiver = XCVR_INTERNAL;\r\nelse\r\necmd->transceiver = XCVR_EXTERNAL;\r\n}\r\nif (er32(STATUS) & E1000_STATUS_LU) {\r\ne1000_get_speed_and_duplex(hw, &adapter->link_speed,\r\n&adapter->link_duplex);\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\nif (adapter->link_duplex == FULL_DUPLEX)\r\necmd->duplex = DUPLEX_FULL;\r\nelse\r\necmd->duplex = DUPLEX_HALF;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\necmd->autoneg = ((hw->media_type == e1000_media_type_fiber) ||\r\nhw->autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\nif ((hw->media_type == e1000_media_type_copper) &&\r\nnetif_carrier_ok(netdev))\r\necmd->eth_tp_mdix = (!!adapter->phy_info.mdix_mode ?\r\nETH_TP_MDI_X : ETH_TP_MDI);\r\nelse\r\necmd->eth_tp_mdix = ETH_TP_MDI_INVALID;\r\nif (hw->mdix == AUTO_ALL_MODES)\r\necmd->eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\r\nelse\r\necmd->eth_tp_mdix_ctrl = hw->mdix;\r\nreturn 0;\r\n}\r\nstatic int e1000_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (ecmd->eth_tp_mdix_ctrl) {\r\nif (hw->media_type != e1000_media_type_copper)\r\nreturn -EOPNOTSUPP;\r\nif ((ecmd->eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&\r\n(ecmd->autoneg != AUTONEG_ENABLE)) {\r\ne_err(drv, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nwhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nhw->autoneg = 1;\r\nif (hw->media_type == e1000_media_type_fiber)\r\nhw->autoneg_advertised = ADVERTISED_1000baseT_Full |\r\nADVERTISED_FIBRE |\r\nADVERTISED_Autoneg;\r\nelse\r\nhw->autoneg_advertised = ecmd->advertising |\r\nADVERTISED_TP |\r\nADVERTISED_Autoneg;\r\necmd->advertising = hw->autoneg_advertised;\r\n} else {\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nif (e1000_set_spd_dplx(adapter, speed, ecmd->duplex)) {\r\nclear_bit(__E1000_RESETTING, &adapter->flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (ecmd->eth_tp_mdix_ctrl) {\r\nif (ecmd->eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\r\nhw->mdix = AUTO_ALL_MODES;\r\nelse\r\nhw->mdix = ecmd->eth_tp_mdix_ctrl;\r\n}\r\nif (netif_running(adapter->netdev)) {\r\ne1000_down(adapter);\r\ne1000_up(adapter);\r\n} else {\r\ne1000_reset(adapter);\r\n}\r\nclear_bit(__E1000_RESETTING, &adapter->flags);\r\nreturn 0;\r\n}\r\nstatic u32 e1000_get_link(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nif (!netif_carrier_ok(netdev))\r\nadapter->hw.get_link_status = 1;\r\nreturn e1000_has_link(adapter);\r\n}\r\nstatic void e1000_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\npause->autoneg =\r\n(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\r\nif (hw->fc == E1000_FC_RX_PAUSE) {\r\npause->rx_pause = 1;\r\n} else if (hw->fc == E1000_FC_TX_PAUSE) {\r\npause->tx_pause = 1;\r\n} else if (hw->fc == E1000_FC_FULL) {\r\npause->rx_pause = 1;\r\npause->tx_pause = 1;\r\n}\r\n}\r\nstatic int e1000_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint retval = 0;\r\nadapter->fc_autoneg = pause->autoneg;\r\nwhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nif (pause->rx_pause && pause->tx_pause)\r\nhw->fc = E1000_FC_FULL;\r\nelse if (pause->rx_pause && !pause->tx_pause)\r\nhw->fc = E1000_FC_RX_PAUSE;\r\nelse if (!pause->rx_pause && pause->tx_pause)\r\nhw->fc = E1000_FC_TX_PAUSE;\r\nelse if (!pause->rx_pause && !pause->tx_pause)\r\nhw->fc = E1000_FC_NONE;\r\nhw->original_fc = hw->fc;\r\nif (adapter->fc_autoneg == AUTONEG_ENABLE) {\r\nif (netif_running(adapter->netdev)) {\r\ne1000_down(adapter);\r\ne1000_up(adapter);\r\n} else {\r\ne1000_reset(adapter);\r\n}\r\n} else\r\nretval = ((hw->media_type == e1000_media_type_fiber) ?\r\ne1000_setup_link(hw) : e1000_force_mac_fc(hw));\r\nclear_bit(__E1000_RESETTING, &adapter->flags);\r\nreturn retval;\r\n}\r\nstatic u32 e1000_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void e1000_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = data;\r\n}\r\nstatic int e1000_get_regs_len(struct net_device *netdev)\r\n{\r\n#define E1000_REGS_LEN 32\r\nreturn E1000_REGS_LEN * sizeof(u32);\r\n}\r\nstatic void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,\r\nvoid *p)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 *regs_buff = p;\r\nu16 phy_data;\r\nmemset(p, 0, E1000_REGS_LEN * sizeof(u32));\r\nregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\r\nregs_buff[0] = er32(CTRL);\r\nregs_buff[1] = er32(STATUS);\r\nregs_buff[2] = er32(RCTL);\r\nregs_buff[3] = er32(RDLEN);\r\nregs_buff[4] = er32(RDH);\r\nregs_buff[5] = er32(RDT);\r\nregs_buff[6] = er32(RDTR);\r\nregs_buff[7] = er32(TCTL);\r\nregs_buff[8] = er32(TDLEN);\r\nregs_buff[9] = er32(TDH);\r\nregs_buff[10] = er32(TDT);\r\nregs_buff[11] = er32(TIDV);\r\nregs_buff[12] = hw->phy_type;\r\nif (hw->phy_type == e1000_phy_igp) {\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\r\nIGP01E1000_PHY_AGC_A);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[13] = (u32)phy_data;\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\r\nIGP01E1000_PHY_AGC_B);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_B &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[14] = (u32)phy_data;\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\r\nIGP01E1000_PHY_AGC_C);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_C &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[15] = (u32)phy_data;\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\r\nIGP01E1000_PHY_AGC_D);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[16] = (u32)phy_data;\r\nregs_buff[17] = 0;\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[18] = (u32)phy_data;\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,\r\nIGP01E1000_PHY_PCS_INIT_REG);\r\ne1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &\r\nIGP01E1000_PHY_PAGE_SELECT, &phy_data);\r\nregs_buff[19] = (u32)phy_data;\r\nregs_buff[20] = 0;\r\nregs_buff[22] = 0;\r\nregs_buff[23] = regs_buff[18];\r\ne1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);\r\n} else {\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\r\nregs_buff[13] = (u32)phy_data;\r\nregs_buff[14] = 0;\r\nregs_buff[15] = 0;\r\nregs_buff[16] = 0;\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nregs_buff[17] = (u32)phy_data;\r\nregs_buff[18] = regs_buff[13];\r\nregs_buff[19] = 0;\r\nregs_buff[20] = regs_buff[17];\r\nregs_buff[22] = adapter->phy_stats.receive_errors;\r\nregs_buff[23] = regs_buff[13];\r\n}\r\nregs_buff[21] = adapter->phy_stats.idle_errors;\r\ne1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);\r\nregs_buff[24] = (u32)phy_data;\r\nregs_buff[25] = regs_buff[24];\r\nif (hw->mac_type >= e1000_82540 &&\r\nhw->media_type == e1000_media_type_copper) {\r\nregs_buff[26] = er32(MANC);\r\n}\r\n}\r\nstatic int e1000_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nreturn hw->eeprom.word_size * 2;\r\n}\r\nstatic int e1000_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nint first_word, last_word;\r\nint ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = hw->vendor_id | (hw->device_id << 16);\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) *\r\n(last_word - first_word + 1), GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nif (hw->eeprom.type == e1000_eeprom_spi)\r\nret_val = e1000_read_eeprom(hw, first_word,\r\nlast_word - first_word + 1,\r\neeprom_buff);\r\nelse {\r\nfor (i = 0; i < last_word - first_word + 1; i++) {\r\nret_val = e1000_read_eeprom(hw, first_word + i, 1,\r\n&eeprom_buff[i]);\r\nif (ret_val)\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),\r\neeprom->len);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int e1000_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nvoid *ptr;\r\nint max_len, first_word, last_word, ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EOPNOTSUPP;\r\nif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\r\nreturn -EFAULT;\r\nmax_len = hw->eeprom.word_size * 2;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(max_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nptr = (void *)eeprom_buff;\r\nif (eeprom->offset & 1) {\r\nret_val = e1000_read_eeprom(hw, first_word, 1,\r\n&eeprom_buff[0]);\r\nptr++;\r\n}\r\nif (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {\r\nret_val = e1000_read_eeprom(hw, last_word, 1,\r\n&eeprom_buff[last_word - first_word]);\r\n}\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(ptr, bytes, eeprom->len);\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\neeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);\r\nret_val = e1000_write_eeprom(hw, first_word,\r\nlast_word - first_word + 1, eeprom_buff);\r\nif ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))\r\ne1000_update_eeprom_checksum(hw);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, e1000_driver_name,\r\nsizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, e1000_driver_version,\r\nsizeof(drvinfo->version));\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->regdump_len = e1000_get_regs_len(netdev);\r\ndrvinfo->eedump_len = e1000_get_eeprom_len(netdev);\r\n}\r\nstatic void e1000_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\ne1000_mac_type mac_type = hw->mac_type;\r\nstruct e1000_tx_ring *txdr = adapter->tx_ring;\r\nstruct e1000_rx_ring *rxdr = adapter->rx_ring;\r\nring->rx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_RXD :\r\nE1000_MAX_82544_RXD;\r\nring->tx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_TXD :\r\nE1000_MAX_82544_TXD;\r\nring->rx_pending = rxdr->count;\r\nring->tx_pending = txdr->count;\r\n}\r\nstatic int e1000_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\ne1000_mac_type mac_type = hw->mac_type;\r\nstruct e1000_tx_ring *txdr, *tx_old;\r\nstruct e1000_rx_ring *rxdr, *rx_old;\r\nint i, err;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nwhile (test_and_set_bit(__E1000_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nif (netif_running(adapter->netdev))\r\ne1000_down(adapter);\r\ntx_old = adapter->tx_ring;\r\nrx_old = adapter->rx_ring;\r\nerr = -ENOMEM;\r\ntxdr = kcalloc(adapter->num_tx_queues, sizeof(struct e1000_tx_ring),\r\nGFP_KERNEL);\r\nif (!txdr)\r\ngoto err_alloc_tx;\r\nrxdr = kcalloc(adapter->num_rx_queues, sizeof(struct e1000_rx_ring),\r\nGFP_KERNEL);\r\nif (!rxdr)\r\ngoto err_alloc_rx;\r\nadapter->tx_ring = txdr;\r\nadapter->rx_ring = rxdr;\r\nrxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);\r\nrxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?\r\nE1000_MAX_RXD : E1000_MAX_82544_RXD));\r\nrxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);\r\ntxdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);\r\ntxdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?\r\nE1000_MAX_TXD : E1000_MAX_82544_TXD));\r\ntxdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\ntxdr[i].count = txdr->count;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nrxdr[i].count = rxdr->count;\r\nif (netif_running(adapter->netdev)) {\r\nerr = e1000_setup_all_rx_resources(adapter);\r\nif (err)\r\ngoto err_setup_rx;\r\nerr = e1000_setup_all_tx_resources(adapter);\r\nif (err)\r\ngoto err_setup_tx;\r\nadapter->rx_ring = rx_old;\r\nadapter->tx_ring = tx_old;\r\ne1000_free_all_rx_resources(adapter);\r\ne1000_free_all_tx_resources(adapter);\r\nkfree(tx_old);\r\nkfree(rx_old);\r\nadapter->rx_ring = rxdr;\r\nadapter->tx_ring = txdr;\r\nerr = e1000_up(adapter);\r\nif (err)\r\ngoto err_setup;\r\n}\r\nclear_bit(__E1000_RESETTING, &adapter->flags);\r\nreturn 0;\r\nerr_setup_tx:\r\ne1000_free_all_rx_resources(adapter);\r\nerr_setup_rx:\r\nadapter->rx_ring = rx_old;\r\nadapter->tx_ring = tx_old;\r\nkfree(rxdr);\r\nerr_alloc_rx:\r\nkfree(txdr);\r\nerr_alloc_tx:\r\ne1000_up(adapter);\r\nerr_setup:\r\nclear_bit(__E1000_RESETTING, &adapter->flags);\r\nreturn err;\r\n}\r\nstatic bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data, int reg,\r\nu32 mask, u32 write)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstatic const u32 test[] = {\r\n0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF\r\n};\r\nu8 __iomem *address = hw->hw_addr + reg;\r\nu32 read;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(test); i++) {\r\nwritel(write & test[i], address);\r\nread = readl(address);\r\nif (read != (write & test[i] & mask)) {\r\ne_err(drv, "pattern test reg %04X failed: "\r\n"got 0x%08X expected 0x%08X\n",\r\nreg, read, (write & test[i] & mask));\r\n*data = reg;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg,\r\nu32 mask, u32 write)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu8 __iomem *address = hw->hw_addr + reg;\r\nu32 read;\r\nwritel(write & mask, address);\r\nread = readl(address);\r\nif ((read & mask) != (write & mask)) {\r\ne_err(drv, "set/check reg %04X test failed: "\r\n"got 0x%08X expected 0x%08X\n",\r\nreg, (read & mask), (write & mask));\r\n*data = reg;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int e1000_reg_test(struct e1000_adapter *adapter, u64 *data)\r\n{\r\nu32 value, before, after;\r\nu32 i, toggle;\r\nstruct e1000_hw *hw = &adapter->hw;\r\ntoggle = 0xFFFFF833;\r\nbefore = er32(STATUS);\r\nvalue = (er32(STATUS) & toggle);\r\new32(STATUS, toggle);\r\nafter = er32(STATUS) & toggle;\r\nif (value != after) {\r\ne_err(drv, "failed STATUS register test got: "\r\n"0x%08X expected: 0x%08X\n", after, value);\r\n*data = 1;\r\nreturn 1;\r\n}\r\new32(STATUS, before);\r\nREG_PATTERN_TEST(FCAL, 0xFFFFFFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(FCAH, 0x0000FFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(FCT, 0x0000FFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(VET, 0x0000FFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(RDTR, 0x0000FFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(RDBAH, 0xFFFFFFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(RDLEN, 0x000FFF80, 0x000FFFFF);\r\nREG_PATTERN_TEST(RDH, 0x0000FFFF, 0x0000FFFF);\r\nREG_PATTERN_TEST(RDT, 0x0000FFFF, 0x0000FFFF);\r\nREG_PATTERN_TEST(FCRTH, 0x0000FFF8, 0x0000FFF8);\r\nREG_PATTERN_TEST(FCTTV, 0x0000FFFF, 0x0000FFFF);\r\nREG_PATTERN_TEST(TIPG, 0x3FFFFFFF, 0x3FFFFFFF);\r\nREG_PATTERN_TEST(TDBAH, 0xFFFFFFFF, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(TDLEN, 0x000FFF80, 0x000FFFFF);\r\nREG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x00000000);\r\nbefore = 0x06DFB3FE;\r\nREG_SET_AND_CHECK(RCTL, before, 0x003FFFFB);\r\nREG_SET_AND_CHECK(TCTL, 0xFFFFFFFF, 0x00000000);\r\nif (hw->mac_type >= e1000_82543) {\r\nREG_SET_AND_CHECK(RCTL, before, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);\r\nREG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);\r\nvalue = E1000_RAR_ENTRIES;\r\nfor (i = 0; i < value; i++) {\r\nREG_PATTERN_TEST(RA + (((i << 1) + 1) << 2),\r\n0x8003FFFF, 0xFFFFFFFF);\r\n}\r\n} else {\r\nREG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x01FFFFFF);\r\nREG_PATTERN_TEST(RDBAL, 0xFFFFF000, 0xFFFFFFFF);\r\nREG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);\r\nREG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);\r\n}\r\nvalue = E1000_MC_TBL_SIZE;\r\nfor (i = 0; i < value; i++)\r\nREG_PATTERN_TEST(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);\r\n*data = 0;\r\nreturn 0;\r\n}\r\nstatic int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 temp;\r\nu16 checksum = 0;\r\nu16 i;\r\n*data = 0;\r\nfor (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {\r\nif ((e1000_read_eeprom(hw, i, 1, &temp)) < 0) {\r\n*data = 1;\r\nbreak;\r\n}\r\nchecksum += temp;\r\n}\r\nif ((checksum != (u16)EEPROM_SUM) && !(*data))\r\n*data = 2;\r\nreturn *data;\r\n}\r\nstatic irqreturn_t e1000_test_intr(int irq, void *data)\r\n{\r\nstruct net_device *netdev = (struct net_device *)data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nadapter->test_icr |= er32(ICR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 mask, i = 0;\r\nbool shared_int = true;\r\nu32 irq = adapter->pdev->irq;\r\nstruct e1000_hw *hw = &adapter->hw;\r\n*data = 0;\r\nif (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,\r\nnetdev))\r\nshared_int = false;\r\nelse if (request_irq(irq, e1000_test_intr, IRQF_SHARED,\r\nnetdev->name, netdev)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\ne_info(hw, "testing %s interrupt\n", (shared_int ?\r\n"shared" : "unshared"));\r\new32(IMC, 0xFFFFFFFF);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nfor (; i < 10; i++) {\r\nmask = 1 << i;\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\new32(IMC, mask);\r\new32(ICS, mask);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nif (adapter->test_icr & mask) {\r\n*data = 3;\r\nbreak;\r\n}\r\n}\r\nadapter->test_icr = 0;\r\new32(IMS, mask);\r\new32(ICS, mask);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nif (!(adapter->test_icr & mask)) {\r\n*data = 4;\r\nbreak;\r\n}\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\new32(IMC, ~mask & 0x00007FFF);\r\new32(ICS, ~mask & 0x00007FFF);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nif (adapter->test_icr) {\r\n*data = 5;\r\nbreak;\r\n}\r\n}\r\n}\r\new32(IMC, 0xFFFFFFFF);\r\nE1000_WRITE_FLUSH();\r\nmsleep(10);\r\nfree_irq(irq, netdev);\r\nreturn *data;\r\n}\r\nstatic void e1000_free_desc_rings(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\r\nstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint i;\r\nif (txdr->desc && txdr->buffer_info) {\r\nfor (i = 0; i < txdr->count; i++) {\r\nif (txdr->buffer_info[i].dma)\r\ndma_unmap_single(&pdev->dev,\r\ntxdr->buffer_info[i].dma,\r\ntxdr->buffer_info[i].length,\r\nDMA_TO_DEVICE);\r\nif (txdr->buffer_info[i].skb)\r\ndev_kfree_skb(txdr->buffer_info[i].skb);\r\n}\r\n}\r\nif (rxdr->desc && rxdr->buffer_info) {\r\nfor (i = 0; i < rxdr->count; i++) {\r\nif (rxdr->buffer_info[i].dma)\r\ndma_unmap_single(&pdev->dev,\r\nrxdr->buffer_info[i].dma,\r\nE1000_RXBUFFER_2048,\r\nDMA_FROM_DEVICE);\r\nkfree(rxdr->buffer_info[i].rxbuf.data);\r\n}\r\n}\r\nif (txdr->desc) {\r\ndma_free_coherent(&pdev->dev, txdr->size, txdr->desc,\r\ntxdr->dma);\r\ntxdr->desc = NULL;\r\n}\r\nif (rxdr->desc) {\r\ndma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,\r\nrxdr->dma);\r\nrxdr->desc = NULL;\r\n}\r\nkfree(txdr->buffer_info);\r\ntxdr->buffer_info = NULL;\r\nkfree(rxdr->buffer_info);\r\nrxdr->buffer_info = NULL;\r\n}\r\nstatic int e1000_setup_desc_rings(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\r\nstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 rctl;\r\nint i, ret_val;\r\nif (!txdr->count)\r\ntxdr->count = E1000_DEFAULT_TXD;\r\ntxdr->buffer_info = kcalloc(txdr->count, sizeof(struct e1000_tx_buffer),\r\nGFP_KERNEL);\r\nif (!txdr->buffer_info) {\r\nret_val = 1;\r\ngoto err_nomem;\r\n}\r\ntxdr->size = txdr->count * sizeof(struct e1000_tx_desc);\r\ntxdr->size = ALIGN(txdr->size, 4096);\r\ntxdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,\r\nGFP_KERNEL);\r\nif (!txdr->desc) {\r\nret_val = 2;\r\ngoto err_nomem;\r\n}\r\ntxdr->next_to_use = txdr->next_to_clean = 0;\r\new32(TDBAL, ((u64)txdr->dma & 0x00000000FFFFFFFF));\r\new32(TDBAH, ((u64)txdr->dma >> 32));\r\new32(TDLEN, txdr->count * sizeof(struct e1000_tx_desc));\r\new32(TDH, 0);\r\new32(TDT, 0);\r\new32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN |\r\nE1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |\r\nE1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);\r\nfor (i = 0; i < txdr->count; i++) {\r\nstruct e1000_tx_desc *tx_desc = E1000_TX_DESC(*txdr, i);\r\nstruct sk_buff *skb;\r\nunsigned int size = 1024;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (!skb) {\r\nret_val = 3;\r\ngoto err_nomem;\r\n}\r\nskb_put(skb, size);\r\ntxdr->buffer_info[i].skb = skb;\r\ntxdr->buffer_info[i].length = skb->len;\r\ntxdr->buffer_info[i].dma =\r\ndma_map_single(&pdev->dev, skb->data, skb->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {\r\nret_val = 4;\r\ngoto err_nomem;\r\n}\r\ntx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);\r\ntx_desc->lower.data = cpu_to_le32(skb->len);\r\ntx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP |\r\nE1000_TXD_CMD_IFCS |\r\nE1000_TXD_CMD_RPS);\r\ntx_desc->upper.data = 0;\r\n}\r\nif (!rxdr->count)\r\nrxdr->count = E1000_DEFAULT_RXD;\r\nrxdr->buffer_info = kcalloc(rxdr->count, sizeof(struct e1000_rx_buffer),\r\nGFP_KERNEL);\r\nif (!rxdr->buffer_info) {\r\nret_val = 5;\r\ngoto err_nomem;\r\n}\r\nrxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);\r\nrxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,\r\nGFP_KERNEL);\r\nif (!rxdr->desc) {\r\nret_val = 6;\r\ngoto err_nomem;\r\n}\r\nrxdr->next_to_use = rxdr->next_to_clean = 0;\r\nrctl = er32(RCTL);\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\new32(RDBAL, ((u64)rxdr->dma & 0xFFFFFFFF));\r\new32(RDBAH, ((u64)rxdr->dma >> 32));\r\new32(RDLEN, rxdr->size);\r\new32(RDH, 0);\r\new32(RDT, 0);\r\nrctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |\r\nE1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\r\n(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);\r\new32(RCTL, rctl);\r\nfor (i = 0; i < rxdr->count; i++) {\r\nstruct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rxdr, i);\r\nu8 *buf;\r\nbuf = kzalloc(E1000_RXBUFFER_2048 + NET_SKB_PAD + NET_IP_ALIGN,\r\nGFP_KERNEL);\r\nif (!buf) {\r\nret_val = 7;\r\ngoto err_nomem;\r\n}\r\nrxdr->buffer_info[i].rxbuf.data = buf;\r\nrxdr->buffer_info[i].dma =\r\ndma_map_single(&pdev->dev,\r\nbuf + NET_SKB_PAD + NET_IP_ALIGN,\r\nE1000_RXBUFFER_2048, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {\r\nret_val = 8;\r\ngoto err_nomem;\r\n}\r\nrx_desc->buffer_addr = cpu_to_le64(rxdr->buffer_info[i].dma);\r\n}\r\nreturn 0;\r\nerr_nomem:\r\ne1000_free_desc_rings(adapter);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_phy_disable_receiver(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\ne1000_write_phy_reg(hw, 29, 0x001F);\r\ne1000_write_phy_reg(hw, 30, 0x8FFC);\r\ne1000_write_phy_reg(hw, 29, 0x001A);\r\ne1000_write_phy_reg(hw, 30, 0x8FF0);\r\n}\r\nstatic void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 phy_reg;\r\ne1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);\r\nphy_reg |= M88E1000_EPSCR_TX_CLK_25;\r\ne1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_reg);\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);\r\nphy_reg |= M88E1000_PSCR_ASSERT_CRS_ON_TX;\r\ne1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);\r\n}\r\nstatic int e1000_nonintegrated_phy_loopback(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl_reg;\r\nu16 phy_reg;\r\nctrl_reg = er32(CTRL);\r\nctrl_reg |= (E1000_CTRL_ILOS |\r\nE1000_CTRL_FRCSPD |\r\nE1000_CTRL_FRCDPX |\r\nE1000_CTRL_SPD_1000 |\r\nE1000_CTRL_FD);\r\new32(CTRL, ctrl_reg);\r\ne1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);\r\nphy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;\r\ne1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);\r\ne1000_phy_reset(hw);\r\ne1000_phy_reset_clk_and_crs(adapter);\r\ne1000_write_phy_reg(hw, PHY_CTRL, 0x8100);\r\nudelay(500);\r\ne1000_phy_reset_clk_and_crs(adapter);\r\ne1000_phy_disable_receiver(adapter);\r\ne1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\r\nphy_reg |= MII_CR_LOOPBACK;\r\ne1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\r\ne1000_phy_reset_clk_and_crs(adapter);\r\ne1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\r\nif (phy_reg != 0x4100)\r\nreturn 9;\r\ne1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);\r\nif (phy_reg != 0x0070)\r\nreturn 10;\r\ne1000_read_phy_reg(hw, 29, &phy_reg);\r\nif (phy_reg != 0x001A)\r\nreturn 11;\r\nreturn 0;\r\n}\r\nstatic int e1000_integrated_phy_loopback(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl_reg = 0;\r\nu32 stat_reg = 0;\r\nhw->autoneg = false;\r\nif (hw->phy_type == e1000_phy_m88) {\r\ne1000_write_phy_reg(hw,\r\nM88E1000_PHY_SPEC_CTRL, 0x0808);\r\ne1000_write_phy_reg(hw, PHY_CTRL, 0x9140);\r\ne1000_write_phy_reg(hw, PHY_CTRL, 0x8140);\r\n}\r\nctrl_reg = er32(CTRL);\r\ne1000_write_phy_reg(hw, PHY_CTRL, 0x4140);\r\nctrl_reg = er32(CTRL);\r\nctrl_reg &= ~E1000_CTRL_SPD_SEL;\r\nctrl_reg |= (E1000_CTRL_FRCSPD |\r\nE1000_CTRL_FRCDPX |\r\nE1000_CTRL_SPD_1000 |\r\nE1000_CTRL_FD);\r\nif (hw->media_type == e1000_media_type_copper &&\r\nhw->phy_type == e1000_phy_m88)\r\nctrl_reg |= E1000_CTRL_ILOS;\r\nelse {\r\nstat_reg = er32(STATUS);\r\nif ((stat_reg & E1000_STATUS_FD) == 0)\r\nctrl_reg |= (E1000_CTRL_ILOS | E1000_CTRL_SLU);\r\n}\r\new32(CTRL, ctrl_reg);\r\nif (hw->phy_type == e1000_phy_m88)\r\ne1000_phy_disable_receiver(adapter);\r\nudelay(500);\r\nreturn 0;\r\n}\r\nstatic int e1000_set_phy_loopback(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 phy_reg = 0;\r\nu16 count = 0;\r\nswitch (hw->mac_type) {\r\ncase e1000_82543:\r\nif (hw->media_type == e1000_media_type_copper) {\r\nwhile (e1000_nonintegrated_phy_loopback(adapter) &&\r\ncount++ < 10);\r\nif (count < 11)\r\nreturn 0;\r\n}\r\nbreak;\r\ncase e1000_82544:\r\ncase e1000_82540:\r\ncase e1000_82545:\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546:\r\ncase e1000_82546_rev_3:\r\ncase e1000_82541:\r\ncase e1000_82541_rev_2:\r\ncase e1000_82547:\r\ncase e1000_82547_rev_2:\r\nreturn e1000_integrated_phy_loopback(adapter);\r\ndefault:\r\ne1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\r\nphy_reg |= MII_CR_LOOPBACK;\r\ne1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\r\nreturn 0;\r\n}\r\nreturn 8;\r\n}\r\nstatic int e1000_setup_loopback_test(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nif (hw->media_type == e1000_media_type_fiber ||\r\nhw->media_type == e1000_media_type_internal_serdes) {\r\nswitch (hw->mac_type) {\r\ncase e1000_82545:\r\ncase e1000_82546:\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\nreturn e1000_set_phy_loopback(adapter);\r\ndefault:\r\nrctl = er32(RCTL);\r\nrctl |= E1000_RCTL_LBM_TCVR;\r\new32(RCTL, rctl);\r\nreturn 0;\r\n}\r\n} else if (hw->media_type == e1000_media_type_copper) {\r\nreturn e1000_set_phy_loopback(adapter);\r\n}\r\nreturn 7;\r\n}\r\nstatic void e1000_loopback_cleanup(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nu16 phy_reg;\r\nrctl = er32(RCTL);\r\nrctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\r\new32(RCTL, rctl);\r\nswitch (hw->mac_type) {\r\ncase e1000_82545:\r\ncase e1000_82546:\r\ncase e1000_82545_rev_3:\r\ncase e1000_82546_rev_3:\r\ndefault:\r\nhw->autoneg = true;\r\ne1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);\r\nif (phy_reg & MII_CR_LOOPBACK) {\r\nphy_reg &= ~MII_CR_LOOPBACK;\r\ne1000_write_phy_reg(hw, PHY_CTRL, phy_reg);\r\ne1000_phy_reset(hw);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void e1000_create_lbtest_frame(struct sk_buff *skb,\r\nunsigned int frame_size)\r\n{\r\nmemset(skb->data, 0xFF, frame_size);\r\nframe_size &= ~1;\r\nmemset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);\r\nmemset(&skb->data[frame_size / 2 + 10], 0xBE, 1);\r\nmemset(&skb->data[frame_size / 2 + 12], 0xAF, 1);\r\n}\r\nstatic int e1000_check_lbtest_frame(const unsigned char *data,\r\nunsigned int frame_size)\r\n{\r\nframe_size &= ~1;\r\nif (*(data + 3) == 0xFF) {\r\nif ((*(data + frame_size / 2 + 10) == 0xBE) &&\r\n(*(data + frame_size / 2 + 12) == 0xAF)) {\r\nreturn 0;\r\n}\r\n}\r\nreturn 13;\r\n}\r\nstatic int e1000_run_loopback_test(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_tx_ring *txdr = &adapter->test_tx_ring;\r\nstruct e1000_rx_ring *rxdr = &adapter->test_rx_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint i, j, k, l, lc, good_cnt, ret_val = 0;\r\nunsigned long time;\r\new32(RDT, rxdr->count - 1);\r\nif (rxdr->count <= txdr->count)\r\nlc = ((txdr->count / 64) * 2) + 1;\r\nelse\r\nlc = ((rxdr->count / 64) * 2) + 1;\r\nk = l = 0;\r\nfor (j = 0; j <= lc; j++) {\r\nfor (i = 0; i < 64; i++) {\r\ne1000_create_lbtest_frame(txdr->buffer_info[i].skb,\r\n1024);\r\ndma_sync_single_for_device(&pdev->dev,\r\ntxdr->buffer_info[k].dma,\r\ntxdr->buffer_info[k].length,\r\nDMA_TO_DEVICE);\r\nif (unlikely(++k == txdr->count))\r\nk = 0;\r\n}\r\new32(TDT, k);\r\nE1000_WRITE_FLUSH();\r\nmsleep(200);\r\ntime = jiffies;\r\ngood_cnt = 0;\r\ndo {\r\ndma_sync_single_for_cpu(&pdev->dev,\r\nrxdr->buffer_info[l].dma,\r\nE1000_RXBUFFER_2048,\r\nDMA_FROM_DEVICE);\r\nret_val = e1000_check_lbtest_frame(\r\nrxdr->buffer_info[l].rxbuf.data +\r\nNET_SKB_PAD + NET_IP_ALIGN,\r\n1024);\r\nif (!ret_val)\r\ngood_cnt++;\r\nif (unlikely(++l == rxdr->count))\r\nl = 0;\r\n} while (good_cnt < 64 && time_after(time + 20, jiffies));\r\nif (good_cnt != 64) {\r\nret_val = 13;\r\nbreak;\r\n}\r\nif (jiffies >= (time + 2)) {\r\nret_val = 14;\r\nbreak;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)\r\n{\r\n*data = e1000_setup_desc_rings(adapter);\r\nif (*data)\r\ngoto out;\r\n*data = e1000_setup_loopback_test(adapter);\r\nif (*data)\r\ngoto err_loopback;\r\n*data = e1000_run_loopback_test(adapter);\r\ne1000_loopback_cleanup(adapter);\r\nerr_loopback:\r\ne1000_free_desc_rings(adapter);\r\nout:\r\nreturn *data;\r\n}\r\nstatic int e1000_link_test(struct e1000_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\n*data = 0;\r\nif (hw->media_type == e1000_media_type_internal_serdes) {\r\nint i = 0;\r\nhw->serdes_has_link = false;\r\ndo {\r\ne1000_check_for_link(hw);\r\nif (hw->serdes_has_link)\r\nreturn *data;\r\nmsleep(20);\r\n} while (i++ < 3750);\r\n*data = 1;\r\n} else {\r\ne1000_check_for_link(hw);\r\nif (hw->autoneg)\r\nmsleep(4000);\r\nif (!(er32(STATUS) & E1000_STATUS_LU))\r\n*data = 1;\r\n}\r\nreturn *data;\r\n}\r\nstatic int e1000_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn E1000_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nreturn E1000_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void e1000_diag_test(struct net_device *netdev,\r\nstruct ethtool_test *eth_test, u64 *data)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nbool if_running = netif_running(netdev);\r\nset_bit(__E1000_TESTING, &adapter->flags);\r\nif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\r\nu16 autoneg_advertised = hw->autoneg_advertised;\r\nu8 forced_speed_duplex = hw->forced_speed_duplex;\r\nu8 autoneg = hw->autoneg;\r\ne_info(hw, "offline testing starting\n");\r\nif (e1000_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (if_running)\r\ndev_close(netdev);\r\nelse\r\ne1000_reset(adapter);\r\nif (e1000_reg_test(adapter, &data[0]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ne1000_reset(adapter);\r\nif (e1000_eeprom_test(adapter, &data[1]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ne1000_reset(adapter);\r\nif (e1000_intr_test(adapter, &data[2]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ne1000_reset(adapter);\r\ne1000_power_up_phy(adapter);\r\nif (e1000_loopback_test(adapter, &data[3]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nhw->autoneg_advertised = autoneg_advertised;\r\nhw->forced_speed_duplex = forced_speed_duplex;\r\nhw->autoneg = autoneg;\r\ne1000_reset(adapter);\r\nclear_bit(__E1000_TESTING, &adapter->flags);\r\nif (if_running)\r\ndev_open(netdev);\r\n} else {\r\ne_info(hw, "online testing starting\n");\r\nif (e1000_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\nclear_bit(__E1000_TESTING, &adapter->flags);\r\n}\r\nmsleep_interruptible(4 * 1000);\r\n}\r\nstatic int e1000_wol_exclusion(struct e1000_adapter *adapter,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint retval = 1;\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82542:\r\ncase E1000_DEV_ID_82543GC_FIBER:\r\ncase E1000_DEV_ID_82543GC_COPPER:\r\ncase E1000_DEV_ID_82544EI_FIBER:\r\ncase E1000_DEV_ID_82546EB_QUAD_COPPER:\r\ncase E1000_DEV_ID_82545EM_FIBER:\r\ncase E1000_DEV_ID_82545EM_COPPER:\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER:\r\ncase E1000_DEV_ID_82546GB_PCIE:\r\nwol->supported = 0;\r\nbreak;\r\ncase E1000_DEV_ID_82546EB_FIBER:\r\ncase E1000_DEV_ID_82546GB_FIBER:\r\nif (er32(STATUS) & E1000_STATUS_FUNC_1) {\r\nwol->supported = 0;\r\nbreak;\r\n}\r\nretval = 0;\r\nbreak;\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\r\nif (!adapter->quad_port_a) {\r\nwol->supported = 0;\r\nbreak;\r\n}\r\nretval = 0;\r\nbreak;\r\ndefault:\r\nif (er32(STATUS) & E1000_STATUS_FUNC_1 &&\r\n!adapter->eeprom_wol) {\r\nwol->supported = 0;\r\nbreak;\r\n}\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic void e1000_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nwol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nif (e1000_wol_exclusion(adapter, wol) ||\r\n!device_can_wakeup(&adapter->pdev->dev))\r\nreturn;\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\r\nwol->supported &= ~WAKE_UCAST;\r\nif (adapter->wol & E1000_WUFC_EX)\r\ne_err(drv, "Interface does not support directed "\r\n"(unicast) frame wake-up packets\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (adapter->wol & E1000_WUFC_EX)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (adapter->wol & E1000_WUFC_MC)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (adapter->wol & E1000_WUFC_BC)\r\nwol->wolopts |= WAKE_BCAST;\r\nif (adapter->wol & E1000_WUFC_MAG)\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))\r\nreturn -EOPNOTSUPP;\r\nif (e1000_wol_exclusion(adapter, wol) ||\r\n!device_can_wakeup(&adapter->pdev->dev))\r\nreturn wol->wolopts ? -EOPNOTSUPP : 0;\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\r\nif (wol->wolopts & WAKE_UCAST) {\r\ne_err(drv, "Interface does not support directed "\r\n"(unicast) frame wake-up packets\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadapter->wol = 0;\r\nif (wol->wolopts & WAKE_UCAST)\r\nadapter->wol |= E1000_WUFC_EX;\r\nif (wol->wolopts & WAKE_MCAST)\r\nadapter->wol |= E1000_WUFC_MC;\r\nif (wol->wolopts & WAKE_BCAST)\r\nadapter->wol |= E1000_WUFC_BC;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol |= E1000_WUFC_MAG;\r\ndevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\r\nreturn 0;\r\n}\r\nstatic int e1000_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\ne1000_setup_led(hw);\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\ne1000_led_on(hw);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\ne1000_led_off(hw);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\ne1000_cleanup_led(hw);\r\n}\r\nreturn 0;\r\n}\r\nstatic int e1000_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->hw.mac_type < e1000_82545)\r\nreturn -EOPNOTSUPP;\r\nif (adapter->itr_setting <= 4)\r\nec->rx_coalesce_usecs = adapter->itr_setting;\r\nelse\r\nec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;\r\nreturn 0;\r\n}\r\nstatic int e1000_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (hw->mac_type < e1000_82545)\r\nreturn -EOPNOTSUPP;\r\nif ((ec->rx_coalesce_usecs > E1000_MAX_ITR_USECS) ||\r\n((ec->rx_coalesce_usecs > 4) &&\r\n(ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||\r\n(ec->rx_coalesce_usecs == 2))\r\nreturn -EINVAL;\r\nif (ec->rx_coalesce_usecs == 4) {\r\nadapter->itr = adapter->itr_setting = 4;\r\n} else if (ec->rx_coalesce_usecs <= 3) {\r\nadapter->itr = 20000;\r\nadapter->itr_setting = ec->rx_coalesce_usecs;\r\n} else {\r\nadapter->itr = (1000000 / ec->rx_coalesce_usecs);\r\nadapter->itr_setting = adapter->itr & ~3;\r\n}\r\nif (adapter->itr_setting != 0)\r\new32(ITR, 1000000000 / (adapter->itr * 256));\r\nelse\r\new32(ITR, 0);\r\nreturn 0;\r\n}\r\nstatic int e1000_nway_reset(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\ne1000_reinit_locked(adapter);\r\nreturn 0;\r\n}\r\nstatic void e1000_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nint i;\r\nchar *p = NULL;\r\nconst struct e1000_stats *stat = e1000_gstrings_stats;\r\ne1000_update_stats(adapter);\r\nfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {\r\nswitch (stat->type) {\r\ncase NETDEV_STATS:\r\np = (char *)netdev + stat->stat_offset;\r\nbreak;\r\ncase E1000_STATS:\r\np = (char *)adapter + stat->stat_offset;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Invalid E1000 stat type: %u index %d\n",\r\nstat->type, i);\r\nbreak;\r\n}\r\nif (stat->sizeof_stat == sizeof(u64))\r\ndata[i] = *(u64 *)p;\r\nelse\r\ndata[i] = *(u32 *)p;\r\nstat++;\r\n}\r\n}\r\nstatic void e1000_get_strings(struct net_device *netdev, u32 stringset,\r\nu8 *data)\r\n{\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, e1000_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid e1000_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &e1000_ethtool_ops;\r\n}
