static int\r\nmwifiex_cmd_802_11_rssi_info(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, u16 cmd_action)\r\n{\r\ncmd->command = cpu_to_le16(HostCmd_CMD_RSSI_INFO);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_rssi_info) +\r\nS_DS_GEN);\r\ncmd->params.rssi_info.action = cpu_to_le16(cmd_action);\r\ncmd->params.rssi_info.ndata = cpu_to_le16(priv->data_avg_factor);\r\ncmd->params.rssi_info.nbcn = cpu_to_le16(priv->bcn_avg_factor);\r\npriv->data_rssi_last = 0;\r\npriv->data_nf_last = 0;\r\npriv->data_rssi_avg = 0;\r\npriv->data_nf_avg = 0;\r\npriv->bcn_rssi_last = 0;\r\npriv->bcn_nf_last = 0;\r\npriv->bcn_rssi_avg = 0;\r\npriv->bcn_nf_avg = 0;\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_mac_control(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u16 *action)\r\n{\r\nstruct host_cmd_ds_mac_control *mac_ctrl = &cmd->params.mac_ctrl;\r\nif (cmd_action != HostCmd_ACT_GEN_SET) {\r\ndev_err(priv->adapter->dev,\r\n"mac_control: only support set cmd\n");\r\nreturn -1;\r\n}\r\ncmd->command = cpu_to_le16(HostCmd_CMD_MAC_CONTROL);\r\ncmd->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_mac_control) + S_DS_GEN);\r\nmac_ctrl->action = cpu_to_le16(*action);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_802_11_snmp_mib(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u32 cmd_oid,\r\nu16 *ul_temp)\r\n{\r\nstruct host_cmd_ds_802_11_snmp_mib *snmp_mib = &cmd->params.smib;\r\ndev_dbg(priv->adapter->dev, "cmd: SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_SNMP_MIB);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_snmp_mib)\r\n- 1 + S_DS_GEN);\r\nsnmp_mib->oid = cpu_to_le16((u16)cmd_oid);\r\nif (cmd_action == HostCmd_ACT_GEN_GET) {\r\nsnmp_mib->query_type = cpu_to_le16(HostCmd_ACT_GEN_GET);\r\nsnmp_mib->buf_size = cpu_to_le16(MAX_SNMP_BUF_SIZE);\r\nle16_add_cpu(&cmd->size, MAX_SNMP_BUF_SIZE);\r\n} else if (cmd_action == HostCmd_ACT_GEN_SET) {\r\nsnmp_mib->query_type = cpu_to_le16(HostCmd_ACT_GEN_SET);\r\nsnmp_mib->buf_size = cpu_to_le16(sizeof(u16));\r\n*((__le16 *) (snmp_mib->value)) = cpu_to_le16(*ul_temp);\r\nle16_add_cpu(&cmd->size, sizeof(u16));\r\n}\r\ndev_dbg(priv->adapter->dev,\r\n"cmd: SNMP_CMD: Action=0x%x, OID=0x%x, OIDSize=0x%x,"\r\n" Value=0x%x\n",\r\ncmd_action, cmd_oid, le16_to_cpu(snmp_mib->buf_size),\r\nle16_to_cpu(*(__le16 *) snmp_mib->value));\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_get_log(struct host_cmd_ds_command *cmd)\r\n{\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_GET_LOG);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_get_log) +\r\nS_DS_GEN);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_tx_rate_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u16 *pbitmap_rates)\r\n{\r\nstruct host_cmd_ds_tx_rate_cfg *rate_cfg = &cmd->params.tx_rate_cfg;\r\nstruct mwifiex_rate_scope *rate_scope;\r\nstruct mwifiex_rate_drop_pattern *rate_drop;\r\nu32 i;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_TX_RATE_CFG);\r\nrate_cfg->action = cpu_to_le16(cmd_action);\r\nrate_cfg->cfg_index = 0;\r\nrate_scope = (struct mwifiex_rate_scope *) ((u8 *) rate_cfg +\r\nsizeof(struct host_cmd_ds_tx_rate_cfg));\r\nrate_scope->type = cpu_to_le16(TLV_TYPE_RATE_SCOPE);\r\nrate_scope->length = cpu_to_le16\r\n(sizeof(*rate_scope) - sizeof(struct mwifiex_ie_types_header));\r\nif (pbitmap_rates != NULL) {\r\nrate_scope->hr_dsss_rate_bitmap = cpu_to_le16(pbitmap_rates[0]);\r\nrate_scope->ofdm_rate_bitmap = cpu_to_le16(pbitmap_rates[1]);\r\nfor (i = 0;\r\ni < sizeof(rate_scope->ht_mcs_rate_bitmap) / sizeof(u16);\r\ni++)\r\nrate_scope->ht_mcs_rate_bitmap[i] =\r\ncpu_to_le16(pbitmap_rates[2 + i]);\r\nif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\r\nfor (i = 0;\r\ni < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);\r\ni++)\r\nrate_scope->vht_mcs_rate_bitmap[i] =\r\ncpu_to_le16(pbitmap_rates[10 + i]);\r\n}\r\n} else {\r\nrate_scope->hr_dsss_rate_bitmap =\r\ncpu_to_le16(priv->bitmap_rates[0]);\r\nrate_scope->ofdm_rate_bitmap =\r\ncpu_to_le16(priv->bitmap_rates[1]);\r\nfor (i = 0;\r\ni < sizeof(rate_scope->ht_mcs_rate_bitmap) / sizeof(u16);\r\ni++)\r\nrate_scope->ht_mcs_rate_bitmap[i] =\r\ncpu_to_le16(priv->bitmap_rates[2 + i]);\r\nif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\r\nfor (i = 0;\r\ni < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);\r\ni++)\r\nrate_scope->vht_mcs_rate_bitmap[i] =\r\ncpu_to_le16(priv->bitmap_rates[10 + i]);\r\n}\r\n}\r\nrate_drop = (struct mwifiex_rate_drop_pattern *) ((u8 *) rate_scope +\r\nsizeof(struct mwifiex_rate_scope));\r\nrate_drop->type = cpu_to_le16(TLV_TYPE_RATE_DROP_CONTROL);\r\nrate_drop->length = cpu_to_le16(sizeof(rate_drop->rate_drop_mode));\r\nrate_drop->rate_drop_mode = 0;\r\ncmd->size =\r\ncpu_to_le16(S_DS_GEN + sizeof(struct host_cmd_ds_tx_rate_cfg) +\r\nsizeof(struct mwifiex_rate_scope) +\r\nsizeof(struct mwifiex_rate_drop_pattern));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_tx_power_cfg(struct host_cmd_ds_command *cmd,\r\nu16 cmd_action,\r\nstruct host_cmd_ds_txpwr_cfg *txp)\r\n{\r\nstruct mwifiex_types_power_group *pg_tlv;\r\nstruct host_cmd_ds_txpwr_cfg *cmd_txp_cfg = &cmd->params.txp_cfg;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_TXPWR_CFG);\r\ncmd->size =\r\ncpu_to_le16(S_DS_GEN + sizeof(struct host_cmd_ds_txpwr_cfg));\r\nswitch (cmd_action) {\r\ncase HostCmd_ACT_GEN_SET:\r\nif (txp->mode) {\r\npg_tlv = (struct mwifiex_types_power_group\r\n*) ((unsigned long) txp +\r\nsizeof(struct host_cmd_ds_txpwr_cfg));\r\nmemmove(cmd_txp_cfg, txp,\r\nsizeof(struct host_cmd_ds_txpwr_cfg) +\r\nsizeof(struct mwifiex_types_power_group) +\r\nle16_to_cpu(pg_tlv->length));\r\npg_tlv = (struct mwifiex_types_power_group *) ((u8 *)\r\ncmd_txp_cfg +\r\nsizeof(struct host_cmd_ds_txpwr_cfg));\r\ncmd->size = cpu_to_le16(le16_to_cpu(cmd->size) +\r\nsizeof(struct mwifiex_types_power_group) +\r\nle16_to_cpu(pg_tlv->length));\r\n} else {\r\nmemmove(cmd_txp_cfg, txp, sizeof(*txp));\r\n}\r\ncmd_txp_cfg->action = cpu_to_le16(cmd_action);\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\ncmd_txp_cfg->action = cpu_to_le16(cmd_action);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_rf_tx_power(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, void *data_buf)\r\n{\r\nstruct host_cmd_ds_rf_tx_pwr *txp = &cmd->params.txp;\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_rf_tx_pwr)\r\n+ S_DS_GEN);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_RF_TX_PWR);\r\ntxp->action = cpu_to_le16(cmd_action);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_rf_antenna(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action,\r\nstruct mwifiex_ds_ant_cfg *ant_cfg)\r\n{\r\nstruct host_cmd_ds_rf_ant_mimo *ant_mimo = &cmd->params.ant_mimo;\r\nstruct host_cmd_ds_rf_ant_siso *ant_siso = &cmd->params.ant_siso;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_RF_ANTENNA);\r\nif (cmd_action != HostCmd_ACT_GEN_SET)\r\nreturn 0;\r\nif (priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2) {\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_rf_ant_mimo) +\r\nS_DS_GEN);\r\nant_mimo->action_tx = cpu_to_le16(HostCmd_ACT_SET_TX);\r\nant_mimo->tx_ant_mode = cpu_to_le16((u16)ant_cfg->tx_ant);\r\nant_mimo->action_rx = cpu_to_le16(HostCmd_ACT_SET_RX);\r\nant_mimo->rx_ant_mode = cpu_to_le16((u16)ant_cfg->rx_ant);\r\n} else {\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_rf_ant_siso) +\r\nS_DS_GEN);\r\nant_siso->action = cpu_to_le16(HostCmd_ACT_SET_BOTH);\r\nant_siso->ant_mode = cpu_to_le16((u16)ant_cfg->tx_ant);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_hs_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action,\r\nstruct mwifiex_hs_config_param *hscfg_param)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_hs_cfg_enh *hs_cfg = &cmd->params.opt_hs_cfg;\r\nbool hs_activate = false;\r\nif (!hscfg_param)\r\nhs_activate = true;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH);\r\nif (!hs_activate &&\r\n(hscfg_param->conditions != cpu_to_le32(HS_CFG_CANCEL)) &&\r\n((adapter->arp_filter_size > 0) &&\r\n(adapter->arp_filter_size <= ARP_FILTER_MAX_BUF_SIZE))) {\r\ndev_dbg(adapter->dev,\r\n"cmd: Attach %d bytes ArpFilter to HSCfg cmd\n",\r\nadapter->arp_filter_size);\r\nmemcpy(((u8 *) hs_cfg) +\r\nsizeof(struct host_cmd_ds_802_11_hs_cfg_enh),\r\nadapter->arp_filter, adapter->arp_filter_size);\r\ncmd->size = cpu_to_le16\r\n(adapter->arp_filter_size +\r\nsizeof(struct host_cmd_ds_802_11_hs_cfg_enh)\r\n+ S_DS_GEN);\r\n} else {\r\ncmd->size = cpu_to_le16(S_DS_GEN + sizeof(struct\r\nhost_cmd_ds_802_11_hs_cfg_enh));\r\n}\r\nif (hs_activate) {\r\nhs_cfg->action = cpu_to_le16(HS_ACTIVATE);\r\nhs_cfg->params.hs_activate.resp_ctrl = cpu_to_le16(RESP_NEEDED);\r\n} else {\r\nhs_cfg->action = cpu_to_le16(HS_CONFIGURE);\r\nhs_cfg->params.hs_config.conditions = hscfg_param->conditions;\r\nhs_cfg->params.hs_config.gpio = hscfg_param->gpio;\r\nhs_cfg->params.hs_config.gap = hscfg_param->gap;\r\ndev_dbg(adapter->dev,\r\n"cmd: HS_CFG_CMD: condition:0x%x gpio:0x%x gap:0x%x\n",\r\nhs_cfg->params.hs_config.conditions,\r\nhs_cfg->params.hs_config.gpio,\r\nhs_cfg->params.hs_config.gap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_802_11_mac_address(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action)\r\n{\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_MAC_ADDRESS);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_mac_address) +\r\nS_DS_GEN);\r\ncmd->result = 0;\r\ncmd->params.mac_addr.action = cpu_to_le16(cmd_action);\r\nif (cmd_action == HostCmd_ACT_GEN_SET)\r\nmemcpy(cmd->params.mac_addr.mac_addr, priv->curr_addr,\r\nETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_mac_multicast_adr(struct host_cmd_ds_command *cmd,\r\nu16 cmd_action,\r\nstruct mwifiex_multicast_list *mcast_list)\r\n{\r\nstruct host_cmd_ds_mac_multicast_adr *mcast_addr = &cmd->params.mc_addr;\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_mac_multicast_adr) +\r\nS_DS_GEN);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_MAC_MULTICAST_ADR);\r\nmcast_addr->action = cpu_to_le16(cmd_action);\r\nmcast_addr->num_of_adrs =\r\ncpu_to_le16((u16) mcast_list->num_multicast_addr);\r\nmemcpy(mcast_addr->mac_list, mcast_list->mac_list,\r\nmcast_list->num_multicast_addr * ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_802_11_deauthenticate(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu8 *mac)\r\n{\r\nstruct host_cmd_ds_802_11_deauthenticate *deauth = &cmd->params.deauth;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_DEAUTHENTICATE);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_deauthenticate)\r\n+ S_DS_GEN);\r\nmemcpy(deauth->mac_addr, mac, ETH_ALEN);\r\ndev_dbg(priv->adapter->dev, "cmd: Deauth: %pM\n", deauth->mac_addr);\r\ndeauth->reason_code = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_802_11_ad_hoc_stop(struct host_cmd_ds_command *cmd)\r\n{\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_STOP);\r\ncmd->size = cpu_to_le16(S_DS_GEN);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_set_keyparamset_wep(struct mwifiex_private *priv,\r\nstruct mwifiex_ie_type_key_param_set *key_param_set,\r\nu16 *key_param_len)\r\n{\r\nint cur_key_param_len;\r\nu8 i;\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nif ((priv->wep_key[i].key_length == WLAN_KEY_LEN_WEP40) ||\r\n(priv->wep_key[i].key_length == WLAN_KEY_LEN_WEP104)) {\r\nkey_param_set->type =\r\ncpu_to_le16(TLV_TYPE_KEY_MATERIAL);\r\n#define KEYPARAMSET_WEP_FIXED_LEN 8\r\nkey_param_set->length = cpu_to_le16((u16)\r\n(priv->wep_key[i].\r\nkey_length +\r\nKEYPARAMSET_WEP_FIXED_LEN));\r\nkey_param_set->key_type_id =\r\ncpu_to_le16(KEY_TYPE_ID_WEP);\r\nkey_param_set->key_info =\r\ncpu_to_le16(KEY_ENABLED | KEY_UNICAST |\r\nKEY_MCAST);\r\nkey_param_set->key_len =\r\ncpu_to_le16(priv->wep_key[i].key_length);\r\nkey_param_set->key[0] = i;\r\nif (i ==\r\n(priv->\r\nwep_key_curr_index & HostCmd_WEP_KEY_INDEX_MASK))\r\nkey_param_set->key[1] = 1;\r\nelse\r\nkey_param_set->key[1] = 0;\r\nmemmove(&key_param_set->key[2],\r\npriv->wep_key[i].key_material,\r\npriv->wep_key[i].key_length);\r\ncur_key_param_len = priv->wep_key[i].key_length +\r\nKEYPARAMSET_WEP_FIXED_LEN +\r\nsizeof(struct mwifiex_ie_types_header);\r\n*key_param_len += (u16) cur_key_param_len;\r\nkey_param_set =\r\n(struct mwifiex_ie_type_key_param_set *)\r\n((u8 *)key_param_set +\r\ncur_key_param_len);\r\n} else if (!priv->wep_key[i].key_length) {\r\ncontinue;\r\n} else {\r\ndev_err(priv->adapter->dev,\r\n"key%d Length = %d is incorrect\n",\r\n(i + 1), priv->wep_key[i].key_length);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_set_aes_key_v2(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_ds_encrypt_key *enc_key,\r\nstruct host_cmd_ds_802_11_key_material_v2 *km)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu16 size, len = KEY_PARAMS_FIXED_LEN;\r\nif (enc_key->is_igtk_key) {\r\ndev_dbg(adapter->dev, "%s: Set CMAC AES Key\n", __func__);\r\nif (enc_key->is_rx_seq_valid)\r\nmemcpy(km->key_param_set.key_params.cmac_aes.ipn,\r\nenc_key->pn, enc_key->pn_len);\r\nkm->key_param_set.key_info &= cpu_to_le16(~KEY_MCAST);\r\nkm->key_param_set.key_info |= cpu_to_le16(KEY_IGTK);\r\nkm->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC;\r\nkm->key_param_set.key_params.cmac_aes.key_len =\r\ncpu_to_le16(enc_key->key_len);\r\nmemcpy(km->key_param_set.key_params.cmac_aes.key,\r\nenc_key->key_material, enc_key->key_len);\r\nlen += sizeof(struct mwifiex_cmac_aes_param);\r\n} else {\r\ndev_dbg(adapter->dev, "%s: Set AES Key\n", __func__);\r\nif (enc_key->is_rx_seq_valid)\r\nmemcpy(km->key_param_set.key_params.aes.pn,\r\nenc_key->pn, enc_key->pn_len);\r\nkm->key_param_set.key_type = KEY_TYPE_ID_AES;\r\nkm->key_param_set.key_params.aes.key_len =\r\ncpu_to_le16(enc_key->key_len);\r\nmemcpy(km->key_param_set.key_params.aes.key,\r\nenc_key->key_material, enc_key->key_len);\r\nlen += sizeof(struct mwifiex_aes_param);\r\n}\r\nkm->key_param_set.len = cpu_to_le16(len);\r\nsize = len + sizeof(struct mwifiex_ie_types_header) +\r\nsizeof(km->action) + S_DS_GEN;\r\ncmd->size = cpu_to_le16(size);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_key_material_v2(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u32 cmd_oid,\r\nstruct mwifiex_ds_encrypt_key *enc_key)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu8 *mac = enc_key->mac_addr;\r\nu16 key_info, len = KEY_PARAMS_FIXED_LEN;\r\nstruct host_cmd_ds_802_11_key_material_v2 *km =\r\n&cmd->params.key_material_v2;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);\r\nkm->action = cpu_to_le16(cmd_action);\r\nif (cmd_action == HostCmd_ACT_GEN_GET) {\r\ndev_dbg(adapter->dev, "%s: Get key\n", __func__);\r\nkm->key_param_set.key_idx =\r\nenc_key->key_index & KEY_INDEX_MASK;\r\nkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\r\nkm->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);\r\nmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\r\nif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\r\nkey_info = KEY_UNICAST;\r\nelse\r\nkey_info = KEY_MCAST;\r\nif (enc_key->is_igtk_key)\r\nkey_info |= KEY_IGTK;\r\nkm->key_param_set.key_info = cpu_to_le16(key_info);\r\ncmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\r\nS_DS_GEN + KEY_PARAMS_FIXED_LEN +\r\nsizeof(km->action));\r\nreturn 0;\r\n}\r\nmemset(&km->key_param_set, 0,\r\nsizeof(struct mwifiex_ie_type_key_param_set_v2));\r\nif (enc_key->key_disable) {\r\ndev_dbg(adapter->dev, "%s: Remove key\n", __func__);\r\nkm->action = cpu_to_le16(HostCmd_ACT_GEN_REMOVE);\r\nkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\r\nkm->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);\r\nkm->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;\r\nkey_info = KEY_MCAST | KEY_UNICAST;\r\nkm->key_param_set.key_info = cpu_to_le16(key_info);\r\nmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\r\ncmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\r\nS_DS_GEN + KEY_PARAMS_FIXED_LEN +\r\nsizeof(km->action));\r\nreturn 0;\r\n}\r\nkm->action = cpu_to_le16(HostCmd_ACT_GEN_SET);\r\nkm->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;\r\nkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\r\nkey_info = KEY_ENABLED;\r\nmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\r\nif (enc_key->key_len <= WLAN_KEY_LEN_WEP104) {\r\ndev_dbg(adapter->dev, "%s: Set WEP Key\n", __func__);\r\nlen += sizeof(struct mwifiex_wep_param);\r\nkm->key_param_set.len = cpu_to_le16(len);\r\nkm->key_param_set.key_type = KEY_TYPE_ID_WEP;\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\r\nkey_info |= KEY_MCAST | KEY_UNICAST;\r\n} else {\r\nif (enc_key->is_current_wep_key) {\r\nkey_info |= KEY_MCAST | KEY_UNICAST;\r\nif (km->key_param_set.key_idx ==\r\n(priv->wep_key_curr_index & KEY_INDEX_MASK))\r\nkey_info |= KEY_DEFAULT;\r\n} else {\r\nif (mac) {\r\nif (is_broadcast_ether_addr(mac))\r\nkey_info |= KEY_MCAST;\r\nelse\r\nkey_info |= KEY_UNICAST |\r\nKEY_DEFAULT;\r\n} else {\r\nkey_info |= KEY_MCAST;\r\n}\r\n}\r\n}\r\nkm->key_param_set.key_info = cpu_to_le16(key_info);\r\nkm->key_param_set.key_params.wep.key_len =\r\ncpu_to_le16(enc_key->key_len);\r\nmemcpy(km->key_param_set.key_params.wep.key,\r\nenc_key->key_material, enc_key->key_len);\r\ncmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\r\nlen + sizeof(km->action) + S_DS_GEN);\r\nreturn 0;\r\n}\r\nif (is_broadcast_ether_addr(mac))\r\nkey_info |= KEY_MCAST | KEY_RX_KEY;\r\nelse\r\nkey_info |= KEY_UNICAST | KEY_TX_KEY | KEY_RX_KEY;\r\nif (enc_key->is_wapi_key) {\r\ndev_dbg(adapter->dev, "%s: Set WAPI Key\n", __func__);\r\nkm->key_param_set.key_type = KEY_TYPE_ID_WAPI;\r\nmemcpy(km->key_param_set.key_params.wapi.pn, enc_key->pn,\r\nPN_LEN);\r\nkm->key_param_set.key_params.wapi.key_len =\r\ncpu_to_le16(enc_key->key_len);\r\nmemcpy(km->key_param_set.key_params.wapi.key,\r\nenc_key->key_material, enc_key->key_len);\r\nif (is_broadcast_ether_addr(mac))\r\npriv->sec_info.wapi_key_on = true;\r\nif (!priv->sec_info.wapi_key_on)\r\nkey_info |= KEY_DEFAULT;\r\nkm->key_param_set.key_info = cpu_to_le16(key_info);\r\nlen += sizeof(struct mwifiex_wapi_param);\r\nkm->key_param_set.len = cpu_to_le16(len);\r\ncmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\r\nlen + sizeof(km->action) + S_DS_GEN);\r\nreturn 0;\r\n}\r\nif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\r\nkey_info |= KEY_DEFAULT;\r\nif (!priv->sec_info.wpa2_enabled &&\r\n!is_broadcast_ether_addr(mac))\r\nkey_info |= KEY_UNICAST;\r\n} else {\r\nif (!priv->wpa_is_gtk_set)\r\nkey_info |= KEY_DEFAULT;\r\n}\r\nkm->key_param_set.key_info = cpu_to_le16(key_info);\r\nif (enc_key->key_len == WLAN_KEY_LEN_CCMP)\r\nreturn mwifiex_set_aes_key_v2(priv, cmd, enc_key, km);\r\nif (enc_key->key_len == WLAN_KEY_LEN_TKIP) {\r\ndev_dbg(adapter->dev, "%s: Set TKIP Key\n", __func__);\r\nif (enc_key->is_rx_seq_valid)\r\nmemcpy(km->key_param_set.key_params.tkip.pn,\r\nenc_key->pn, enc_key->pn_len);\r\nkm->key_param_set.key_type = KEY_TYPE_ID_TKIP;\r\nkm->key_param_set.key_params.tkip.key_len =\r\ncpu_to_le16(enc_key->key_len);\r\nmemcpy(km->key_param_set.key_params.tkip.key,\r\nenc_key->key_material, enc_key->key_len);\r\nlen += sizeof(struct mwifiex_tkip_param);\r\nkm->key_param_set.len = cpu_to_le16(len);\r\ncmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\r\nlen + sizeof(km->action) + S_DS_GEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_key_material_v1(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u32 cmd_oid,\r\nstruct mwifiex_ds_encrypt_key *enc_key)\r\n{\r\nstruct host_cmd_ds_802_11_key_material *key_material =\r\n&cmd->params.key_material;\r\nstruct host_cmd_tlv_mac_addr *tlv_mac;\r\nu16 key_param_len = 0, cmd_size;\r\nint ret = 0;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);\r\nkey_material->action = cpu_to_le16(cmd_action);\r\nif (cmd_action == HostCmd_ACT_GEN_GET) {\r\ncmd->size =\r\ncpu_to_le16(sizeof(key_material->action) + S_DS_GEN);\r\nreturn ret;\r\n}\r\nif (!enc_key) {\r\nmemset(&key_material->key_param_set, 0,\r\n(NUM_WEP_KEYS *\r\nsizeof(struct mwifiex_ie_type_key_param_set)));\r\nret = mwifiex_set_keyparamset_wep(priv,\r\n&key_material->key_param_set,\r\n&key_param_len);\r\ncmd->size = cpu_to_le16(key_param_len +\r\nsizeof(key_material->action) + S_DS_GEN);\r\nreturn ret;\r\n} else\r\nmemset(&key_material->key_param_set, 0,\r\nsizeof(struct mwifiex_ie_type_key_param_set));\r\nif (enc_key->is_wapi_key) {\r\ndev_dbg(priv->adapter->dev, "info: Set WAPI Key\n");\r\nkey_material->key_param_set.key_type_id =\r\ncpu_to_le16(KEY_TYPE_ID_WAPI);\r\nif (cmd_oid == KEY_INFO_ENABLED)\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(KEY_ENABLED);\r\nelse\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(!KEY_ENABLED);\r\nkey_material->key_param_set.key[0] = enc_key->key_index;\r\nif (!priv->sec_info.wapi_key_on)\r\nkey_material->key_param_set.key[1] = 1;\r\nelse\r\nkey_material->key_param_set.key[1] = 0;\r\nif (!is_broadcast_ether_addr(enc_key->mac_addr)) {\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_UNICAST);\r\n} else {\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_MCAST);\r\npriv->sec_info.wapi_key_on = true;\r\n}\r\nkey_material->key_param_set.type =\r\ncpu_to_le16(TLV_TYPE_KEY_MATERIAL);\r\nkey_material->key_param_set.key_len =\r\ncpu_to_le16(WAPI_KEY_LEN);\r\nmemcpy(&key_material->key_param_set.key[2],\r\nenc_key->key_material, enc_key->key_len);\r\nmemcpy(&key_material->key_param_set.key[2 + enc_key->key_len],\r\nenc_key->pn, PN_LEN);\r\nkey_material->key_param_set.length =\r\ncpu_to_le16(WAPI_KEY_LEN + KEYPARAMSET_FIXED_LEN);\r\nkey_param_len = (WAPI_KEY_LEN + KEYPARAMSET_FIXED_LEN) +\r\nsizeof(struct mwifiex_ie_types_header);\r\ncmd->size = cpu_to_le16(sizeof(key_material->action)\r\n+ S_DS_GEN + key_param_len);\r\nreturn ret;\r\n}\r\nif (enc_key->key_len == WLAN_KEY_LEN_CCMP) {\r\nif (enc_key->is_igtk_key) {\r\ndev_dbg(priv->adapter->dev, "cmd: CMAC_AES\n");\r\nkey_material->key_param_set.key_type_id =\r\ncpu_to_le16(KEY_TYPE_ID_AES_CMAC);\r\nif (cmd_oid == KEY_INFO_ENABLED)\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(KEY_ENABLED);\r\nelse\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(!KEY_ENABLED);\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_IGTK);\r\n} else {\r\ndev_dbg(priv->adapter->dev, "cmd: WPA_AES\n");\r\nkey_material->key_param_set.key_type_id =\r\ncpu_to_le16(KEY_TYPE_ID_AES);\r\nif (cmd_oid == KEY_INFO_ENABLED)\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(KEY_ENABLED);\r\nelse\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(!KEY_ENABLED);\r\nif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_UNICAST);\r\nelse\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_MCAST);\r\n}\r\n} else if (enc_key->key_len == WLAN_KEY_LEN_TKIP) {\r\ndev_dbg(priv->adapter->dev, "cmd: WPA_TKIP\n");\r\nkey_material->key_param_set.key_type_id =\r\ncpu_to_le16(KEY_TYPE_ID_TKIP);\r\nkey_material->key_param_set.key_info =\r\ncpu_to_le16(KEY_ENABLED);\r\nif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_UNICAST);\r\nelse\r\nkey_material->key_param_set.key_info |=\r\ncpu_to_le16(KEY_MCAST);\r\n}\r\nif (key_material->key_param_set.key_type_id) {\r\nkey_material->key_param_set.type =\r\ncpu_to_le16(TLV_TYPE_KEY_MATERIAL);\r\nkey_material->key_param_set.key_len =\r\ncpu_to_le16((u16) enc_key->key_len);\r\nmemcpy(key_material->key_param_set.key, enc_key->key_material,\r\nenc_key->key_len);\r\nkey_material->key_param_set.length =\r\ncpu_to_le16((u16) enc_key->key_len +\r\nKEYPARAMSET_FIXED_LEN);\r\nkey_param_len = (u16)(enc_key->key_len + KEYPARAMSET_FIXED_LEN)\r\n+ sizeof(struct mwifiex_ie_types_header);\r\nif (le16_to_cpu(key_material->key_param_set.key_type_id) ==\r\nKEY_TYPE_ID_AES_CMAC) {\r\nstruct mwifiex_cmac_param *param =\r\n(void *)key_material->key_param_set.key;\r\nmemcpy(param->ipn, enc_key->pn, IGTK_PN_LEN);\r\nmemcpy(param->key, enc_key->key_material,\r\nWLAN_KEY_LEN_AES_CMAC);\r\nkey_param_len = sizeof(struct mwifiex_cmac_param);\r\nkey_material->key_param_set.key_len =\r\ncpu_to_le16(key_param_len);\r\nkey_param_len += KEYPARAMSET_FIXED_LEN;\r\nkey_material->key_param_set.length =\r\ncpu_to_le16(key_param_len);\r\nkey_param_len += sizeof(struct mwifiex_ie_types_header);\r\n}\r\ncmd->size = cpu_to_le16(sizeof(key_material->action) + S_DS_GEN\r\n+ key_param_len);\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\r\ntlv_mac = (void *)((u8 *)&key_material->key_param_set +\r\nkey_param_len);\r\ntlv_mac->header.type =\r\ncpu_to_le16(TLV_TYPE_STA_MAC_ADDR);\r\ntlv_mac->header.len = cpu_to_le16(ETH_ALEN);\r\nmemcpy(tlv_mac->mac_addr, enc_key->mac_addr, ETH_ALEN);\r\ncmd_size = key_param_len + S_DS_GEN +\r\nsizeof(key_material->action) +\r\nsizeof(struct host_cmd_tlv_mac_addr);\r\n} else {\r\ncmd_size = key_param_len + S_DS_GEN +\r\nsizeof(key_material->action);\r\n}\r\ncmd->size = cpu_to_le16(cmd_size);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u32 cmd_oid,\r\nstruct mwifiex_ds_encrypt_key *enc_key)\r\n{\r\nif (priv->adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\r\nreturn mwifiex_cmd_802_11_key_material_v2(priv, cmd,\r\ncmd_action, cmd_oid,\r\nenc_key);\r\nelse\r\nreturn mwifiex_cmd_802_11_key_material_v1(priv, cmd,\r\ncmd_action, cmd_oid,\r\nenc_key);\r\n}\r\nstatic int mwifiex_cmd_802_11d_domain_info(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11d_domain_info *domain_info =\r\n&cmd->params.domain_info;\r\nstruct mwifiex_ietypes_domain_param_set *domain =\r\n&domain_info->domain;\r\nu8 no_of_triplet = adapter->domain_reg.no_of_triplet;\r\ndev_dbg(adapter->dev, "info: 11D: no_of_triplet=0x%x\n", no_of_triplet);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11D_DOMAIN_INFO);\r\ndomain_info->action = cpu_to_le16(cmd_action);\r\nif (cmd_action == HostCmd_ACT_GEN_GET) {\r\ncmd->size = cpu_to_le16(sizeof(domain_info->action) + S_DS_GEN);\r\nreturn 0;\r\n}\r\ndomain->header.type = cpu_to_le16(WLAN_EID_COUNTRY);\r\nmemcpy(domain->country_code, adapter->domain_reg.country_code,\r\nsizeof(domain->country_code));\r\ndomain->header.len =\r\ncpu_to_le16((no_of_triplet *\r\nsizeof(struct ieee80211_country_ie_triplet))\r\n+ sizeof(domain->country_code));\r\nif (no_of_triplet) {\r\nmemcpy(domain->triplet, adapter->domain_reg.triplet,\r\nno_of_triplet * sizeof(struct\r\nieee80211_country_ie_triplet));\r\ncmd->size = cpu_to_le16(sizeof(domain_info->action) +\r\nle16_to_cpu(domain->header.len) +\r\nsizeof(struct mwifiex_ie_types_header)\r\n+ S_DS_GEN);\r\n} else {\r\ncmd->size = cpu_to_le16(sizeof(domain_info->action) + S_DS_GEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_ibss_coalescing_status(struct host_cmd_ds_command *cmd,\r\nu16 cmd_action, u16 *enable)\r\n{\r\nstruct host_cmd_ds_802_11_ibss_status *ibss_coal =\r\n&(cmd->params.ibss_coalescing);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_IBSS_COALESCING_STATUS);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_ibss_status) +\r\nS_DS_GEN);\r\ncmd->result = 0;\r\nibss_coal->action = cpu_to_le16(cmd_action);\r\nswitch (cmd_action) {\r\ncase HostCmd_ACT_GEN_SET:\r\nif (enable)\r\nibss_coal->enable = cpu_to_le16(*enable);\r\nelse\r\nibss_coal->enable = 0;\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_reg_access(struct host_cmd_ds_command *cmd,\r\nu16 cmd_action, void *data_buf)\r\n{\r\nstruct mwifiex_ds_reg_rw *reg_rw = data_buf;\r\nswitch (le16_to_cpu(cmd->command)) {\r\ncase HostCmd_CMD_MAC_REG_ACCESS:\r\n{\r\nstruct host_cmd_ds_mac_reg_access *mac_reg;\r\ncmd->size = cpu_to_le16(sizeof(*mac_reg) + S_DS_GEN);\r\nmac_reg = &cmd->params.mac_reg;\r\nmac_reg->action = cpu_to_le16(cmd_action);\r\nmac_reg->offset =\r\ncpu_to_le16((u16) le32_to_cpu(reg_rw->offset));\r\nmac_reg->value = reg_rw->value;\r\nbreak;\r\n}\r\ncase HostCmd_CMD_BBP_REG_ACCESS:\r\n{\r\nstruct host_cmd_ds_bbp_reg_access *bbp_reg;\r\ncmd->size = cpu_to_le16(sizeof(*bbp_reg) + S_DS_GEN);\r\nbbp_reg = &cmd->params.bbp_reg;\r\nbbp_reg->action = cpu_to_le16(cmd_action);\r\nbbp_reg->offset =\r\ncpu_to_le16((u16) le32_to_cpu(reg_rw->offset));\r\nbbp_reg->value = (u8) le32_to_cpu(reg_rw->value);\r\nbreak;\r\n}\r\ncase HostCmd_CMD_RF_REG_ACCESS:\r\n{\r\nstruct host_cmd_ds_rf_reg_access *rf_reg;\r\ncmd->size = cpu_to_le16(sizeof(*rf_reg) + S_DS_GEN);\r\nrf_reg = &cmd->params.rf_reg;\r\nrf_reg->action = cpu_to_le16(cmd_action);\r\nrf_reg->offset = cpu_to_le16((u16) le32_to_cpu(reg_rw->offset));\r\nrf_reg->value = (u8) le32_to_cpu(reg_rw->value);\r\nbreak;\r\n}\r\ncase HostCmd_CMD_PMIC_REG_ACCESS:\r\n{\r\nstruct host_cmd_ds_pmic_reg_access *pmic_reg;\r\ncmd->size = cpu_to_le16(sizeof(*pmic_reg) + S_DS_GEN);\r\npmic_reg = &cmd->params.pmic_reg;\r\npmic_reg->action = cpu_to_le16(cmd_action);\r\npmic_reg->offset =\r\ncpu_to_le16((u16) le32_to_cpu(reg_rw->offset));\r\npmic_reg->value = (u8) le32_to_cpu(reg_rw->value);\r\nbreak;\r\n}\r\ncase HostCmd_CMD_CAU_REG_ACCESS:\r\n{\r\nstruct host_cmd_ds_rf_reg_access *cau_reg;\r\ncmd->size = cpu_to_le16(sizeof(*cau_reg) + S_DS_GEN);\r\ncau_reg = &cmd->params.rf_reg;\r\ncau_reg->action = cpu_to_le16(cmd_action);\r\ncau_reg->offset =\r\ncpu_to_le16((u16) le32_to_cpu(reg_rw->offset));\r\ncau_reg->value = (u8) le32_to_cpu(reg_rw->value);\r\nbreak;\r\n}\r\ncase HostCmd_CMD_802_11_EEPROM_ACCESS:\r\n{\r\nstruct mwifiex_ds_read_eeprom *rd_eeprom = data_buf;\r\nstruct host_cmd_ds_802_11_eeprom_access *cmd_eeprom =\r\n&cmd->params.eeprom;\r\ncmd->size = cpu_to_le16(sizeof(*cmd_eeprom) + S_DS_GEN);\r\ncmd_eeprom->action = cpu_to_le16(cmd_action);\r\ncmd_eeprom->offset = rd_eeprom->offset;\r\ncmd_eeprom->byte_count = rd_eeprom->byte_count;\r\ncmd_eeprom->value = 0;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_pcie_host_spec(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, u16 action)\r\n{\r\nstruct host_cmd_ds_pcie_details *host_spec =\r\n&cmd->params.pcie_host_spec;\r\nstruct pcie_service_card *card = priv->adapter->card;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_PCIE_DESC_DETAILS);\r\ncmd->size = cpu_to_le16(sizeof(struct\r\nhost_cmd_ds_pcie_details) + S_DS_GEN);\r\ncmd->result = 0;\r\nmemset(host_spec, 0, sizeof(struct host_cmd_ds_pcie_details));\r\nif (action != HostCmd_ACT_GEN_SET)\r\nreturn 0;\r\nhost_spec->txbd_addr_lo = (u32)(card->txbd_ring_pbase);\r\nhost_spec->txbd_addr_hi = (u32)(((u64)card->txbd_ring_pbase)>>32);\r\nhost_spec->txbd_count = MWIFIEX_MAX_TXRX_BD;\r\nhost_spec->rxbd_addr_lo = (u32)(card->rxbd_ring_pbase);\r\nhost_spec->rxbd_addr_hi = (u32)(((u64)card->rxbd_ring_pbase)>>32);\r\nhost_spec->rxbd_count = MWIFIEX_MAX_TXRX_BD;\r\nhost_spec->evtbd_addr_lo = (u32)(card->evtbd_ring_pbase);\r\nhost_spec->evtbd_addr_hi = (u32)(((u64)card->evtbd_ring_pbase)>>32);\r\nhost_spec->evtbd_count = MWIFIEX_MAX_EVT_BD;\r\nif (card->sleep_cookie_vbase) {\r\nhost_spec->sleep_cookie_addr_lo =\r\n(u32)(card->sleep_cookie_pbase);\r\nhost_spec->sleep_cookie_addr_hi =\r\n(u32)(((u64)(card->sleep_cookie_pbase)) >> 32);\r\ndev_dbg(priv->adapter->dev, "sleep_cook_lo phy addr: 0x%x\n",\r\nhost_spec->sleep_cookie_addr_lo);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_802_11_subsc_evt(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_ds_misc_subsc_evt *subsc_evt_cfg)\r\n{\r\nstruct host_cmd_ds_802_11_subsc_evt *subsc_evt = &cmd->params.subsc_evt;\r\nstruct mwifiex_ie_types_rssi_threshold *rssi_tlv;\r\nu16 event_bitmap;\r\nu8 *pos;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_SUBSCRIBE_EVENT);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_subsc_evt) +\r\nS_DS_GEN);\r\nsubsc_evt->action = cpu_to_le16(subsc_evt_cfg->action);\r\ndev_dbg(priv->adapter->dev, "cmd: action: %d\n", subsc_evt_cfg->action);\r\nif (subsc_evt_cfg->action == HostCmd_ACT_GEN_GET)\r\nreturn 0;\r\nsubsc_evt->events = cpu_to_le16(subsc_evt_cfg->events);\r\nevent_bitmap = subsc_evt_cfg->events;\r\ndev_dbg(priv->adapter->dev, "cmd: event bitmap : %16x\n",\r\nevent_bitmap);\r\nif (((subsc_evt_cfg->action == HostCmd_ACT_BITWISE_CLR) ||\r\n(subsc_evt_cfg->action == HostCmd_ACT_BITWISE_SET)) &&\r\n(event_bitmap == 0)) {\r\ndev_dbg(priv->adapter->dev, "Error: No event specified "\r\n"for bitwise action type\n");\r\nreturn -EINVAL;\r\n}\r\nif (subsc_evt_cfg->action == HostCmd_ACT_BITWISE_CLR)\r\nreturn 0;\r\npos = ((u8 *)subsc_evt) +\r\nsizeof(struct host_cmd_ds_802_11_subsc_evt);\r\nif (event_bitmap & BITMASK_BCN_RSSI_LOW) {\r\nrssi_tlv = (struct mwifiex_ie_types_rssi_threshold *) pos;\r\nrssi_tlv->header.type = cpu_to_le16(TLV_TYPE_RSSI_LOW);\r\nrssi_tlv->header.len =\r\ncpu_to_le16(sizeof(struct mwifiex_ie_types_rssi_threshold) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nrssi_tlv->abs_value = subsc_evt_cfg->bcn_l_rssi_cfg.abs_value;\r\nrssi_tlv->evt_freq = subsc_evt_cfg->bcn_l_rssi_cfg.evt_freq;\r\ndev_dbg(priv->adapter->dev, "Cfg Beacon Low Rssi event, "\r\n"RSSI:-%d dBm, Freq:%d\n",\r\nsubsc_evt_cfg->bcn_l_rssi_cfg.abs_value,\r\nsubsc_evt_cfg->bcn_l_rssi_cfg.evt_freq);\r\npos += sizeof(struct mwifiex_ie_types_rssi_threshold);\r\nle16_add_cpu(&cmd->size,\r\nsizeof(struct mwifiex_ie_types_rssi_threshold));\r\n}\r\nif (event_bitmap & BITMASK_BCN_RSSI_HIGH) {\r\nrssi_tlv = (struct mwifiex_ie_types_rssi_threshold *) pos;\r\nrssi_tlv->header.type = cpu_to_le16(TLV_TYPE_RSSI_HIGH);\r\nrssi_tlv->header.len =\r\ncpu_to_le16(sizeof(struct mwifiex_ie_types_rssi_threshold) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nrssi_tlv->abs_value = subsc_evt_cfg->bcn_h_rssi_cfg.abs_value;\r\nrssi_tlv->evt_freq = subsc_evt_cfg->bcn_h_rssi_cfg.evt_freq;\r\ndev_dbg(priv->adapter->dev, "Cfg Beacon High Rssi event, "\r\n"RSSI:-%d dBm, Freq:%d\n",\r\nsubsc_evt_cfg->bcn_h_rssi_cfg.abs_value,\r\nsubsc_evt_cfg->bcn_h_rssi_cfg.evt_freq);\r\npos += sizeof(struct mwifiex_ie_types_rssi_threshold);\r\nle16_add_cpu(&cmd->size,\r\nsizeof(struct mwifiex_ie_types_rssi_threshold));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_append_rpn_expression(struct mwifiex_private *priv,\r\nstruct mwifiex_mef_entry *mef_entry,\r\nu8 **buffer)\r\n{\r\nstruct mwifiex_mef_filter *filter = mef_entry->filter;\r\nint i, byte_len;\r\nu8 *stack_ptr = *buffer;\r\nfor (i = 0; i < MWIFIEX_MEF_MAX_FILTERS; i++) {\r\nfilter = &mef_entry->filter[i];\r\nif (!filter->filt_type)\r\nbreak;\r\n*(__le32 *)stack_ptr = cpu_to_le32((u32)filter->repeat);\r\nstack_ptr += 4;\r\n*stack_ptr = TYPE_DNUM;\r\nstack_ptr += 1;\r\nbyte_len = filter->byte_seq[MWIFIEX_MEF_MAX_BYTESEQ];\r\nmemcpy(stack_ptr, filter->byte_seq, byte_len);\r\nstack_ptr += byte_len;\r\n*stack_ptr = byte_len;\r\nstack_ptr += 1;\r\n*stack_ptr = TYPE_BYTESEQ;\r\nstack_ptr += 1;\r\n*(__le32 *)stack_ptr = cpu_to_le32((u32)filter->offset);\r\nstack_ptr += 4;\r\n*stack_ptr = TYPE_DNUM;\r\nstack_ptr += 1;\r\n*stack_ptr = filter->filt_type;\r\nstack_ptr += 1;\r\nif (filter->filt_action) {\r\n*stack_ptr = filter->filt_action;\r\nstack_ptr += 1;\r\n}\r\nif (stack_ptr - *buffer > STACK_NBYTES)\r\nreturn -1;\r\n}\r\n*buffer = stack_ptr;\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_mef_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct mwifiex_ds_mef_cfg *mef)\r\n{\r\nstruct host_cmd_ds_mef_cfg *mef_cfg = &cmd->params.mef_cfg;\r\nu8 *pos = (u8 *)mef_cfg;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_MEF_CFG);\r\nmef_cfg->criteria = cpu_to_le32(mef->criteria);\r\nmef_cfg->num_entries = cpu_to_le16(mef->num_entries);\r\npos += sizeof(*mef_cfg);\r\nmef_cfg->mef_entry->mode = mef->mef_entry->mode;\r\nmef_cfg->mef_entry->action = mef->mef_entry->action;\r\npos += sizeof(*(mef_cfg->mef_entry));\r\nif (mwifiex_cmd_append_rpn_expression(priv, mef->mef_entry, &pos))\r\nreturn -1;\r\nmef_cfg->mef_entry->exprsize =\r\ncpu_to_le16(pos - mef_cfg->mef_entry->expr);\r\ncmd->size = cpu_to_le16((u16) (pos - (u8 *)mef_cfg) + S_DS_GEN);\r\nreturn 0;\r\n}\r\nstatic u32 mwifiex_parse_cal_cfg(u8 *src, size_t len, u8 *dst)\r\n{\r\nu8 *s = src, *d = dst;\r\nwhile (s - src < len) {\r\nif (*s && (isspace(*s) || *s == '\t')) {\r\ns++;\r\ncontinue;\r\n}\r\nif (isxdigit(*s)) {\r\n*d++ = simple_strtol(s, NULL, 16);\r\ns += 2;\r\n} else {\r\ns++;\r\n}\r\n}\r\nreturn d - dst;\r\n}\r\nint mwifiex_dnld_dt_cfgdata(struct mwifiex_private *priv,\r\nstruct device_node *node, const char *prefix)\r\n{\r\n#ifdef CONFIG_OF\r\nstruct property *prop;\r\nsize_t len = strlen(prefix);\r\nint ret;\r\nfor_each_property_of_node(node, prop) {\r\nif (len > strlen(prop->name) ||\r\nstrncmp(prop->name, prefix, len))\r\ncontinue;\r\nif (prop && prop->value && prop->length > 6 &&\r\nprop->length <= MWIFIEX_SIZE_OF_CMD_BUFFER - S_DS_GEN) {\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,\r\nHostCmd_ACT_GEN_SET, 0,\r\nprop, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_cfg_data(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, void *data_buf)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct property *prop = data_buf;\r\nu32 len;\r\nu8 *data = (u8 *)cmd + S_DS_GEN;\r\nint ret;\r\nif (prop) {\r\nlen = prop->length;\r\nret = of_property_read_u8_array(adapter->dt_node, prop->name,\r\ndata, len);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(adapter->dev,\r\n"download cfg_data from device tree: %s\n", prop->name);\r\n} else if (adapter->cal_data->data && adapter->cal_data->size > 0) {\r\nlen = mwifiex_parse_cal_cfg((u8 *)adapter->cal_data->data,\r\nadapter->cal_data->size, data);\r\ndev_dbg(adapter->dev, "download cfg_data from config file\n");\r\n} else {\r\nreturn -1;\r\n}\r\ncmd->command = cpu_to_le16(HostCmd_CMD_CFG_DATA);\r\ncmd->size = cpu_to_le16(S_DS_GEN + len);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_coalesce_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nu16 cmd_action, void *data_buf)\r\n{\r\nstruct host_cmd_ds_coalesce_cfg *coalesce_cfg =\r\n&cmd->params.coalesce_cfg;\r\nstruct mwifiex_ds_coalesce_cfg *cfg = data_buf;\r\nstruct coalesce_filt_field_param *param;\r\nu16 cnt, idx, length;\r\nstruct coalesce_receive_filt_rule *rule;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_COALESCE_CFG);\r\ncmd->size = cpu_to_le16(S_DS_GEN);\r\ncoalesce_cfg->action = cpu_to_le16(cmd_action);\r\ncoalesce_cfg->num_of_rules = cpu_to_le16(cfg->num_of_rules);\r\nrule = coalesce_cfg->rule;\r\nfor (cnt = 0; cnt < cfg->num_of_rules; cnt++) {\r\nrule->header.type = cpu_to_le16(TLV_TYPE_COALESCE_RULE);\r\nrule->max_coalescing_delay =\r\ncpu_to_le16(cfg->rule[cnt].max_coalescing_delay);\r\nrule->pkt_type = cfg->rule[cnt].pkt_type;\r\nrule->num_of_fields = cfg->rule[cnt].num_of_fields;\r\nlength = 0;\r\nparam = rule->params;\r\nfor (idx = 0; idx < cfg->rule[cnt].num_of_fields; idx++) {\r\nparam->operation = cfg->rule[cnt].params[idx].operation;\r\nparam->operand_len =\r\ncfg->rule[cnt].params[idx].operand_len;\r\nparam->offset =\r\ncpu_to_le16(cfg->rule[cnt].params[idx].offset);\r\nmemcpy(param->operand_byte_stream,\r\ncfg->rule[cnt].params[idx].operand_byte_stream,\r\nparam->operand_len);\r\nlength += sizeof(struct coalesce_filt_field_param);\r\nparam++;\r\n}\r\nrule->header.len = cpu_to_le16(length + sizeof(u16) +\r\nsizeof(u8) + sizeof(u8));\r\nle16_add_cpu(&cmd->size, le16_to_cpu(rule->header.len) +\r\nsizeof(struct mwifiex_ie_types_header));\r\nrule = (void *)((u8 *)rule->params + length);\r\n}\r\nle16_add_cpu(&cmd->size, sizeof(u16) + sizeof(u16));\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_tdls_oper(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nvoid *data_buf)\r\n{\r\nstruct host_cmd_ds_tdls_oper *tdls_oper = &cmd->params.tdls_oper;\r\nstruct mwifiex_ds_tdls_oper *oper = data_buf;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct host_cmd_tlv_rates *tlv_rates;\r\nstruct mwifiex_ie_types_htcap *ht_capab;\r\nstruct mwifiex_ie_types_qos_info *wmm_qos_info;\r\nstruct mwifiex_ie_types_extcap *extcap;\r\nstruct mwifiex_ie_types_vhtcap *vht_capab;\r\nstruct mwifiex_ie_types_aid *aid;\r\nstruct mwifiex_ie_types_tdls_idle_timeout *timeout;\r\nu8 *pos, qos_info;\r\nu16 config_len = 0;\r\nstruct station_parameters *params = priv->sta_params;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_TDLS_OPER);\r\ncmd->size = cpu_to_le16(S_DS_GEN);\r\nle16_add_cpu(&cmd->size, sizeof(struct host_cmd_ds_tdls_oper));\r\ntdls_oper->reason = 0;\r\nmemcpy(tdls_oper->peer_mac, oper->peer_mac, ETH_ALEN);\r\nsta_ptr = mwifiex_get_sta_entry(priv, oper->peer_mac);\r\npos = (u8 *)tdls_oper + sizeof(struct host_cmd_ds_tdls_oper);\r\nswitch (oper->tdls_action) {\r\ncase MWIFIEX_TDLS_DISABLE_LINK:\r\ntdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_DELETE);\r\nbreak;\r\ncase MWIFIEX_TDLS_CREATE_LINK:\r\ntdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CREATE);\r\nbreak;\r\ncase MWIFIEX_TDLS_CONFIG_LINK:\r\ntdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CONFIG);\r\nif (!params) {\r\ndev_err(priv->adapter->dev,\r\n"TDLS config params not available for %pM\n",\r\noper->peer_mac);\r\nreturn -ENODATA;\r\n}\r\n*(__le16 *)pos = cpu_to_le16(params->capability);\r\nconfig_len += sizeof(params->capability);\r\nqos_info = params->uapsd_queues | (params->max_sp << 5);\r\nwmm_qos_info = (struct mwifiex_ie_types_qos_info *)(pos +\r\nconfig_len);\r\nwmm_qos_info->header.type = cpu_to_le16(WLAN_EID_QOS_CAPA);\r\nwmm_qos_info->header.len = cpu_to_le16(sizeof(qos_info));\r\nwmm_qos_info->qos_info = qos_info;\r\nconfig_len += sizeof(struct mwifiex_ie_types_qos_info);\r\nif (params->ht_capa) {\r\nht_capab = (struct mwifiex_ie_types_htcap *)(pos +\r\nconfig_len);\r\nht_capab->header.type =\r\ncpu_to_le16(WLAN_EID_HT_CAPABILITY);\r\nht_capab->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_cap));\r\nmemcpy(&ht_capab->ht_cap, params->ht_capa,\r\nsizeof(struct ieee80211_ht_cap));\r\nconfig_len += sizeof(struct mwifiex_ie_types_htcap);\r\n}\r\nif (params->supported_rates && params->supported_rates_len) {\r\ntlv_rates = (struct host_cmd_tlv_rates *)(pos +\r\nconfig_len);\r\ntlv_rates->header.type =\r\ncpu_to_le16(WLAN_EID_SUPP_RATES);\r\ntlv_rates->header.len =\r\ncpu_to_le16(params->supported_rates_len);\r\nmemcpy(tlv_rates->rates, params->supported_rates,\r\nparams->supported_rates_len);\r\nconfig_len += sizeof(struct host_cmd_tlv_rates) +\r\nparams->supported_rates_len;\r\n}\r\nif (params->ext_capab && params->ext_capab_len) {\r\nextcap = (struct mwifiex_ie_types_extcap *)(pos +\r\nconfig_len);\r\nextcap->header.type =\r\ncpu_to_le16(WLAN_EID_EXT_CAPABILITY);\r\nextcap->header.len = cpu_to_le16(params->ext_capab_len);\r\nmemcpy(extcap->ext_capab, params->ext_capab,\r\nparams->ext_capab_len);\r\nconfig_len += sizeof(struct mwifiex_ie_types_extcap) +\r\nparams->ext_capab_len;\r\n}\r\nif (params->vht_capa) {\r\nvht_capab = (struct mwifiex_ie_types_vhtcap *)(pos +\r\nconfig_len);\r\nvht_capab->header.type =\r\ncpu_to_le16(WLAN_EID_VHT_CAPABILITY);\r\nvht_capab->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_vht_cap));\r\nmemcpy(&vht_capab->vht_cap, params->vht_capa,\r\nsizeof(struct ieee80211_vht_cap));\r\nconfig_len += sizeof(struct mwifiex_ie_types_vhtcap);\r\n}\r\nif (params->aid) {\r\naid = (struct mwifiex_ie_types_aid *)(pos + config_len);\r\naid->header.type = cpu_to_le16(WLAN_EID_AID);\r\naid->header.len = cpu_to_le16(sizeof(params->aid));\r\naid->aid = cpu_to_le16(params->aid);\r\nconfig_len += sizeof(struct mwifiex_ie_types_aid);\r\n}\r\ntimeout = (void *)(pos + config_len);\r\ntimeout->header.type = cpu_to_le16(TLV_TYPE_TDLS_IDLE_TIMEOUT);\r\ntimeout->header.len = cpu_to_le16(sizeof(timeout->value));\r\ntimeout->value = cpu_to_le16(MWIFIEX_TDLS_IDLE_TIMEOUT_IN_SEC);\r\nconfig_len += sizeof(struct mwifiex_ie_types_tdls_idle_timeout);\r\nbreak;\r\ndefault:\r\ndev_err(priv->adapter->dev, "Unknown TDLS operation\n");\r\nreturn -ENOTSUPP;\r\n}\r\nle16_add_cpu(&cmd->size, config_len);\r\nreturn 0;\r\n}\r\nint mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\r\nu16 cmd_action, u32 cmd_oid,\r\nvoid *data_buf, void *cmd_buf)\r\n{\r\nstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\r\nint ret = 0;\r\nswitch (cmd_no) {\r\ncase HostCmd_CMD_GET_HW_SPEC:\r\nret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\r\nbreak;\r\ncase HostCmd_CMD_CFG_DATA:\r\nret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_MAC_CONTROL:\r\nret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_MAC_ADDRESS:\r\nret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\r\ncmd_action);\r\nbreak;\r\ncase HostCmd_CMD_MAC_MULTICAST_ADR:\r\nret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_TX_RATE_CFG:\r\nret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_TXPWR_CFG:\r\nret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_RF_TX_PWR:\r\nret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_RF_ANTENNA:\r\nret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_PS_MODE_ENH:\r\nret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\r\n(uint16_t)cmd_oid, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_HS_CFG_ENH:\r\nret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\r\n(struct mwifiex_hs_config_param *) data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SCAN:\r\nret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_BG_SCAN_QUERY:\r\nret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\r\nbreak;\r\ncase HostCmd_CMD_802_11_ASSOCIATE:\r\nret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_DEAUTHENTICATE:\r\nret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_AD_HOC_START:\r\nret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_GET_LOG:\r\nret = mwifiex_cmd_802_11_get_log(cmd_ptr);\r\nbreak;\r\ncase HostCmd_CMD_802_11_AD_HOC_JOIN:\r\nret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_AD_HOC_STOP:\r\nret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\r\nbreak;\r\ncase HostCmd_CMD_RSSI_INFO:\r\nret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SNMP_MIB:\r\nret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\r\ncmd_oid, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_TX_RATE_QUERY:\r\ncmd_ptr->command =\r\ncpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\r\nS_DS_GEN);\r\npriv->tx_rate = 0;\r\nret = 0;\r\nbreak;\r\ncase HostCmd_CMD_VERSION_EXT:\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->params.verext.version_str_sel =\r\n(u8) (*((u32 *) data_buf));\r\nmemcpy(&cmd_ptr->params, data_buf,\r\nsizeof(struct host_cmd_ds_version_ext));\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\r\nS_DS_GEN);\r\nret = 0;\r\nbreak;\r\ncase HostCmd_CMD_MGMT_FRAME_REG:\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\r\ncmd_ptr->params.reg_mask.mask = cpu_to_le32(*(u32 *)data_buf);\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\r\nS_DS_GEN);\r\nret = 0;\r\nbreak;\r\ncase HostCmd_CMD_REMAIN_ON_CHAN:\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\nmemcpy(&cmd_ptr->params, data_buf,\r\nsizeof(struct host_cmd_ds_remain_on_chan));\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\r\nS_DS_GEN);\r\nbreak;\r\ncase HostCmd_CMD_11AC_CFG:\r\nret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_P2P_MODE_CFG:\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\r\ncmd_ptr->params.mode_cfg.mode = cpu_to_le16(*(u16 *)data_buf);\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\r\nS_DS_GEN);\r\nbreak;\r\ncase HostCmd_CMD_FUNC_INIT:\r\nif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\r\npriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->size = cpu_to_le16(S_DS_GEN);\r\nbreak;\r\ncase HostCmd_CMD_FUNC_SHUTDOWN:\r\npriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\ncmd_ptr->size = cpu_to_le16(S_DS_GEN);\r\nbreak;\r\ncase HostCmd_CMD_11N_ADDBA_REQ:\r\nret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_11N_DELBA:\r\nret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_11N_ADDBA_RSP:\r\nret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_KEY_MATERIAL:\r\nret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\r\ncmd_action, cmd_oid,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11D_DOMAIN_INFO:\r\nret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\r\ncmd_action);\r\nbreak;\r\ncase HostCmd_CMD_RECONFIGURE_TX_BUFF:\r\nret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_AMSDU_AGGR_CTRL:\r\nret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_11N_CFG:\r\nret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_WMM_GET_STATUS:\r\ndev_dbg(priv->adapter->dev,\r\n"cmd: WMM: WMM_GET_STATUS cmd sent\n");\r\ncmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\r\ncmd_ptr->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\r\nS_DS_GEN);\r\nret = 0;\r\nbreak;\r\ncase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\r\nret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SCAN_EXT:\r\nret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_MAC_REG_ACCESS:\r\ncase HostCmd_CMD_BBP_REG_ACCESS:\r\ncase HostCmd_CMD_RF_REG_ACCESS:\r\ncase HostCmd_CMD_PMIC_REG_ACCESS:\r\ncase HostCmd_CMD_CAU_REG_ACCESS:\r\ncase HostCmd_CMD_802_11_EEPROM_ACCESS:\r\nret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_SET_BSS_MODE:\r\ncmd_ptr->command = cpu_to_le16(cmd_no);\r\nif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\r\ncmd_ptr->params.bss_mode.con_type =\r\nCONNECTION_TYPE_ADHOC;\r\nelse if (priv->bss_mode == NL80211_IFTYPE_STATION)\r\ncmd_ptr->params.bss_mode.con_type =\r\nCONNECTION_TYPE_INFRA;\r\nelse if (priv->bss_mode == NL80211_IFTYPE_AP)\r\ncmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\r\ncmd_ptr->size = cpu_to_le16(sizeof(struct\r\nhost_cmd_ds_set_bss_mode) + S_DS_GEN);\r\nret = 0;\r\nbreak;\r\ncase HostCmd_CMD_PCIE_DESC_DETAILS:\r\nret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\r\nret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_MEF_CFG:\r\nret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_COALESCE_CFG:\r\nret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\r\ndata_buf);\r\nbreak;\r\ncase HostCmd_CMD_TDLS_OPER:\r\nret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\r\nbreak;\r\ndefault:\r\ndev_err(priv->adapter->dev,\r\n"PREP_CMD: unknown cmd- %#x\n", cmd_no);\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nu16 enable = true;\r\nstruct mwifiex_ds_11n_amsdu_aggr_ctrl amsdu_aggr_ctrl;\r\nstruct mwifiex_ds_auto_ds auto_ds;\r\nenum state_11d_t state_11d;\r\nstruct mwifiex_ds_11n_tx_cfg tx_cfg;\r\nif (first_sta) {\r\nif (priv->adapter->iface_type == MWIFIEX_PCIE) {\r\nret = mwifiex_send_cmd(priv,\r\nHostCmd_CMD_PCIE_DESC_DETAILS,\r\nHostCmd_ACT_GEN_SET, 0, NULL,\r\ntrue);\r\nif (ret)\r\nreturn -1;\r\n}\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_FUNC_INIT,\r\nHostCmd_ACT_GEN_SET, 0, NULL, true);\r\nif (ret)\r\nreturn -1;\r\nadapter->dt_node =\r\nof_find_node_by_name(NULL, "marvell_cfgdata");\r\nif (adapter->dt_node) {\r\nret = mwifiex_dnld_dt_cfgdata(priv, adapter->dt_node,\r\n"marvell,caldata");\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (adapter->cal_data) {\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,\r\nHostCmd_ACT_GEN_SET, 0, NULL,\r\ntrue);\r\nif (ret)\r\nreturn -1;\r\n}\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_GET_HW_SPEC,\r\nHostCmd_ACT_GEN_GET, 0, NULL, true);\r\nif (ret)\r\nreturn -1;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_RECONFIGURE_TX_BUFF,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&priv->adapter->tx_buf_size, true);\r\nif (ret)\r\nreturn -1;\r\nif (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\r\npriv->adapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\r\nret = mwifiex_send_cmd(priv,\r\nHostCmd_CMD_802_11_PS_MODE_ENH,\r\nEN_AUTO_PS, BITMAP_STA_PS, NULL,\r\ntrue);\r\nif (ret)\r\nreturn -1;\r\n}\r\n}\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_TX_RATE_CFG,\r\nHostCmd_ACT_GEN_GET, 0, NULL, true);\r\nif (ret)\r\nreturn -1;\r\npriv->data_rate = 0;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\r\nHostCmd_ACT_GEN_GET, 0, NULL, true);\r\nif (ret)\r\nreturn -1;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_STA) {\r\nret = mwifiex_send_cmd(\r\npriv,\r\nHostCmd_CMD_802_11_IBSS_COALESCING_STATUS,\r\nHostCmd_ACT_GEN_SET, 0, &enable, true);\r\nif (ret)\r\nreturn -1;\r\n}\r\nmemset(&amsdu_aggr_ctrl, 0, sizeof(amsdu_aggr_ctrl));\r\namsdu_aggr_ctrl.enable = true;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_AMSDU_AGGR_CTRL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&amsdu_aggr_ctrl, true);\r\nif (ret)\r\nreturn -1;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&priv->curr_pkt_filter, true);\r\nif (ret)\r\nreturn -1;\r\nif (first_sta && priv->adapter->iface_type != MWIFIEX_USB &&\r\npriv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\r\nauto_ds.auto_ds = DEEP_SLEEP_ON;\r\nauto_ds.idle_time = DEEP_SLEEP_IDLE_TIME;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\r\nEN_AUTO_PS, BITMAP_AUTO_DS,\r\n&auto_ds, true);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\r\nstate_11d = ENABLE_11D;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\r\nHostCmd_ACT_GEN_SET, DOT11D_I,\r\n&state_11d, true);\r\nif (ret)\r\ndev_err(priv->adapter->dev,\r\n"11D: failed to enable 11D\n");\r\n}\r\npriv->adapter->last_init_cmd = HostCmd_CMD_11N_CFG;\r\ntx_cfg.tx_htcap = MWIFIEX_FW_DEF_HTTXCFG;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_CFG,\r\nHostCmd_ACT_GEN_SET, 0, &tx_cfg, true);\r\nret = -EINPROGRESS;\r\nreturn ret;\r\n}
