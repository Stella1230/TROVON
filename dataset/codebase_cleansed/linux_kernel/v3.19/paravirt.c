void _paravirt_nop(void)\r\n{\r\n}\r\nu32 _paravirt_ident_32(u32 x)\r\n{\r\nreturn x;\r\n}\r\nu64 _paravirt_ident_64(u64 x)\r\n{\r\nreturn x;\r\n}\r\nvoid __init default_banner(void)\r\n{\r\nprintk(KERN_INFO "Booting paravirtualized kernel on %s\n",\r\npv_info.name);\r\n}\r\nunsigned paravirt_patch_nop(void)\r\n{\r\nreturn 0;\r\n}\r\nunsigned paravirt_patch_ignore(unsigned len)\r\n{\r\nreturn len;\r\n}\r\nunsigned paravirt_patch_call(void *insnbuf,\r\nconst void *target, u16 tgt_clobbers,\r\nunsigned long addr, u16 site_clobbers,\r\nunsigned len)\r\n{\r\nstruct branch *b = insnbuf;\r\nunsigned long delta = (unsigned long)target - (addr+5);\r\nif (tgt_clobbers & ~site_clobbers)\r\nreturn len;\r\nif (len < 5)\r\nreturn len;\r\nb->opcode = 0xe8;\r\nb->delta = delta;\r\nBUILD_BUG_ON(sizeof(*b) != 5);\r\nreturn 5;\r\n}\r\nunsigned paravirt_patch_jmp(void *insnbuf, const void *target,\r\nunsigned long addr, unsigned len)\r\n{\r\nstruct branch *b = insnbuf;\r\nunsigned long delta = (unsigned long)target - (addr+5);\r\nif (len < 5)\r\nreturn len;\r\nb->opcode = 0xe9;\r\nb->delta = delta;\r\nreturn 5;\r\n}\r\nstatic void *get_call_destination(u8 type)\r\n{\r\nstruct paravirt_patch_template tmpl = {\r\n.pv_init_ops = pv_init_ops,\r\n.pv_time_ops = pv_time_ops,\r\n.pv_cpu_ops = pv_cpu_ops,\r\n.pv_irq_ops = pv_irq_ops,\r\n.pv_apic_ops = pv_apic_ops,\r\n.pv_mmu_ops = pv_mmu_ops,\r\n#ifdef CONFIG_PARAVIRT_SPINLOCKS\r\n.pv_lock_ops = pv_lock_ops,\r\n#endif\r\n};\r\nreturn *((void **)&tmpl + type);\r\n}\r\nunsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,\r\nunsigned long addr, unsigned len)\r\n{\r\nvoid *opfunc = get_call_destination(type);\r\nunsigned ret;\r\nif (opfunc == NULL)\r\nret = paravirt_patch_insns(insnbuf, len, ud2a, ud2a+sizeof(ud2a));\r\nelse if (opfunc == _paravirt_nop)\r\nret = paravirt_patch_nop();\r\nelse if (opfunc == _paravirt_ident_32)\r\nret = paravirt_patch_ident_32(insnbuf, len);\r\nelse if (opfunc == _paravirt_ident_64)\r\nret = paravirt_patch_ident_64(insnbuf, len);\r\nelse if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||\r\ntype == PARAVIRT_PATCH(pv_cpu_ops.irq_enable_sysexit) ||\r\ntype == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret32) ||\r\ntype == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret64))\r\nret = paravirt_patch_jmp(insnbuf, opfunc, addr, len);\r\nelse\r\nret = paravirt_patch_call(insnbuf, opfunc, CLBR_ANY,\r\naddr, clobbers, len);\r\nreturn ret;\r\n}\r\nunsigned paravirt_patch_insns(void *insnbuf, unsigned len,\r\nconst char *start, const char *end)\r\n{\r\nunsigned insn_len = end - start;\r\nif (insn_len > len || start == NULL)\r\ninsn_len = len;\r\nelse\r\nmemcpy(insnbuf, start, insn_len);\r\nreturn insn_len;\r\n}\r\nstatic void native_flush_tlb(void)\r\n{\r\n__native_flush_tlb();\r\n}\r\nstatic void native_flush_tlb_global(void)\r\n{\r\n__native_flush_tlb_global();\r\n}\r\nstatic void native_flush_tlb_single(unsigned long addr)\r\n{\r\n__native_flush_tlb_single(addr);\r\n}\r\nstatic u64 native_steal_clock(int cpu)\r\n{\r\nreturn 0;\r\n}\r\nint paravirt_disable_iospace(void)\r\n{\r\nreturn request_resource(&ioport_resource, &reserve_ioports);\r\n}\r\nstatic inline void enter_lazy(enum paravirt_lazy_mode mode)\r\n{\r\nBUG_ON(this_cpu_read(paravirt_lazy_mode) != PARAVIRT_LAZY_NONE);\r\nthis_cpu_write(paravirt_lazy_mode, mode);\r\n}\r\nstatic void leave_lazy(enum paravirt_lazy_mode mode)\r\n{\r\nBUG_ON(this_cpu_read(paravirt_lazy_mode) != mode);\r\nthis_cpu_write(paravirt_lazy_mode, PARAVIRT_LAZY_NONE);\r\n}\r\nvoid paravirt_enter_lazy_mmu(void)\r\n{\r\nenter_lazy(PARAVIRT_LAZY_MMU);\r\n}\r\nvoid paravirt_leave_lazy_mmu(void)\r\n{\r\nleave_lazy(PARAVIRT_LAZY_MMU);\r\n}\r\nvoid paravirt_flush_lazy_mmu(void)\r\n{\r\npreempt_disable();\r\nif (paravirt_get_lazy_mode() == PARAVIRT_LAZY_MMU) {\r\narch_leave_lazy_mmu_mode();\r\narch_enter_lazy_mmu_mode();\r\n}\r\npreempt_enable();\r\n}\r\nvoid paravirt_start_context_switch(struct task_struct *prev)\r\n{\r\nBUG_ON(preemptible());\r\nif (this_cpu_read(paravirt_lazy_mode) == PARAVIRT_LAZY_MMU) {\r\narch_leave_lazy_mmu_mode();\r\nset_ti_thread_flag(task_thread_info(prev), TIF_LAZY_MMU_UPDATES);\r\n}\r\nenter_lazy(PARAVIRT_LAZY_CPU);\r\n}\r\nvoid paravirt_end_context_switch(struct task_struct *next)\r\n{\r\nBUG_ON(preemptible());\r\nleave_lazy(PARAVIRT_LAZY_CPU);\r\nif (test_and_clear_ti_thread_flag(task_thread_info(next), TIF_LAZY_MMU_UPDATES))\r\narch_enter_lazy_mmu_mode();\r\n}\r\nenum paravirt_lazy_mode paravirt_get_lazy_mode(void)\r\n{\r\nif (in_interrupt())\r\nreturn PARAVIRT_LAZY_NONE;\r\nreturn this_cpu_read(paravirt_lazy_mode);\r\n}
