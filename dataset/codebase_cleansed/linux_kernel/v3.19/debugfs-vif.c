static void iwl_dbgfs_update_pm(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nenum iwl_dbgfs_pm_mask param, int val)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_dbgfs_pm *dbgfs_pm = &mvmvif->dbgfs_pm;\r\ndbgfs_pm->mask |= param;\r\nswitch (param) {\r\ncase MVM_DEBUGFS_PM_KEEP_ALIVE: {\r\nint dtimper = vif->bss_conf.dtim_period ?: 1;\r\nint dtimper_msec = dtimper * vif->bss_conf.beacon_int;\r\nIWL_DEBUG_POWER(mvm, "debugfs: set keep_alive= %d sec\n", val);\r\nif (val * MSEC_PER_SEC < 3 * dtimper_msec)\r\nIWL_WARN(mvm,\r\n"debugfs: keep alive period (%ld msec) is less than minimum required (%d msec)\n",\r\nval * MSEC_PER_SEC, 3 * dtimper_msec);\r\ndbgfs_pm->keep_alive_seconds = val;\r\nbreak;\r\n}\r\ncase MVM_DEBUGFS_PM_SKIP_OVER_DTIM:\r\nIWL_DEBUG_POWER(mvm, "skip_over_dtim %s\n",\r\nval ? "enabled" : "disabled");\r\ndbgfs_pm->skip_over_dtim = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS:\r\nIWL_DEBUG_POWER(mvm, "skip_dtim_periods=%d\n", val);\r\ndbgfs_pm->skip_dtim_periods = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_RX_DATA_TIMEOUT:\r\nIWL_DEBUG_POWER(mvm, "rx_data_timeout=%d\n", val);\r\ndbgfs_pm->rx_data_timeout = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_TX_DATA_TIMEOUT:\r\nIWL_DEBUG_POWER(mvm, "tx_data_timeout=%d\n", val);\r\ndbgfs_pm->tx_data_timeout = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_LPRX_ENA:\r\nIWL_DEBUG_POWER(mvm, "lprx %s\n", val ? "enabled" : "disabled");\r\ndbgfs_pm->lprx_ena = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD:\r\nIWL_DEBUG_POWER(mvm, "lprx_rssi_threshold=%d\n", val);\r\ndbgfs_pm->lprx_rssi_threshold = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_SNOOZE_ENABLE:\r\nIWL_DEBUG_POWER(mvm, "snooze_enable=%d\n", val);\r\ndbgfs_pm->snooze_ena = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_UAPSD_MISBEHAVING:\r\nIWL_DEBUG_POWER(mvm, "uapsd_misbehaving_enable=%d\n", val);\r\ndbgfs_pm->uapsd_misbehaving = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_USE_PS_POLL:\r\nIWL_DEBUG_POWER(mvm, "use_ps_poll=%d\n", val);\r\ndbgfs_pm->use_ps_poll = val;\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t iwl_dbgfs_pm_params_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nenum iwl_dbgfs_pm_mask param;\r\nint val, ret;\r\nif (!strncmp("keep_alive=", buf, 11)) {\r\nif (sscanf(buf + 11, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_KEEP_ALIVE;\r\n} else if (!strncmp("skip_over_dtim=", buf, 15)) {\r\nif (sscanf(buf + 15, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SKIP_OVER_DTIM;\r\n} else if (!strncmp("skip_dtim_periods=", buf, 18)) {\r\nif (sscanf(buf + 18, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS;\r\n} else if (!strncmp("rx_data_timeout=", buf, 16)) {\r\nif (sscanf(buf + 16, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_RX_DATA_TIMEOUT;\r\n} else if (!strncmp("tx_data_timeout=", buf, 16)) {\r\nif (sscanf(buf + 16, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_TX_DATA_TIMEOUT;\r\n} else if (!strncmp("lprx=", buf, 5)) {\r\nif (sscanf(buf + 5, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_LPRX_ENA;\r\n} else if (!strncmp("lprx_rssi_threshold=", buf, 20)) {\r\nif (sscanf(buf + 20, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nif (val > POWER_LPRX_RSSI_THRESHOLD_MAX || val <\r\nPOWER_LPRX_RSSI_THRESHOLD_MIN)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD;\r\n} else if (!strncmp("snooze_enable=", buf, 14)) {\r\nif (sscanf(buf + 14, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SNOOZE_ENABLE;\r\n} else if (!strncmp("uapsd_misbehaving=", buf, 18)) {\r\nif (sscanf(buf + 18, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_UAPSD_MISBEHAVING;\r\n} else if (!strncmp("use_ps_poll=", buf, 12)) {\r\nif (sscanf(buf + 12, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_USE_PS_POLL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mvm->mutex);\r\niwl_dbgfs_update_pm(mvm, vif, param, val);\r\nret = iwl_mvm_power_update_mac(mvm);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_pm_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[512];\r\nint bufsz = sizeof(buf);\r\nint pos;\r\npos = iwl_mvm_power_mac_dbgfs_read(mvm, vif, buf, bufsz);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_mac_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu8 ap_sta_id;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nchar buf[512];\r\nint bufsz = sizeof(buf);\r\nint pos = 0;\r\nint i;\r\nmutex_lock(&mvm->mutex);\r\nap_sta_id = mvmvif->ap_sta_id;\r\nswitch (ieee80211_vif_type_p2p(vif)) {\r\ncase NL80211_IFTYPE_ADHOC:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: ibss\n");\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: bss\n");\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: ap\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p client\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p go\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p dev\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npos += scnprintf(buf+pos, bufsz-pos, "mac id/color: %d / %d\n",\r\nmvmvif->id, mvmvif->color);\r\npos += scnprintf(buf+pos, bufsz-pos, "bssid: %pM\n",\r\nvif->bss_conf.bssid);\r\npos += scnprintf(buf+pos, bufsz-pos, "QoS:\n");\r\nfor (i = 0; i < ARRAY_SIZE(mvmvif->queue_params); i++)\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"\t%d: txop:%d - cw_min:%d - cw_max = %d - aifs = %d upasd = %d\n",\r\ni, mvmvif->queue_params[i].txop,\r\nmvmvif->queue_params[i].cw_min,\r\nmvmvif->queue_params[i].cw_max,\r\nmvmvif->queue_params[i].aifs,\r\nmvmvif->queue_params[i].uapsd);\r\nif (vif->type == NL80211_IFTYPE_STATION &&\r\nap_sta_id != IWL_MVM_STATION_COUNT) {\r\nstruct ieee80211_sta *sta;\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[ap_sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (!IS_ERR_OR_NULL(sta)) {\r\nstruct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"ap_sta_id %d - reduced Tx power %d\n",\r\nap_sta_id,\r\nmvm_sta->bt_reduced_txpower);\r\n}\r\n}\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(vif->chanctx_conf);\r\nif (chanctx_conf)\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"idle rx chains %d, active rx chains: %d\n",\r\nchanctx_conf->rx_chains_static,\r\nchanctx_conf->rx_chains_dynamic);\r\nrcu_read_unlock();\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic void iwl_dbgfs_update_bf(struct ieee80211_vif *vif,\r\nenum iwl_dbgfs_bf_mask param, int value)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;\r\ndbgfs_bf->mask |= param;\r\nswitch (param) {\r\ncase MVM_DEBUGFS_BF_ENERGY_DELTA:\r\ndbgfs_bf->bf_energy_delta = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA:\r\ndbgfs_bf->bf_roaming_energy_delta = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ROAMING_STATE:\r\ndbgfs_bf->bf_roaming_state = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_THRESHOLD:\r\ndbgfs_bf->bf_temp_threshold = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_FAST_FILTER:\r\ndbgfs_bf->bf_temp_fast_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_SLOW_FILTER:\r\ndbgfs_bf->bf_temp_slow_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER:\r\ndbgfs_bf->bf_enable_beacon_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_DEBUG_FLAG:\r\ndbgfs_bf->bf_debug_flag = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ESCAPE_TIMER:\r\ndbgfs_bf->bf_escape_timer = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT:\r\ndbgfs_bf->ba_enable_beacon_abort = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BA_ESCAPE_TIMER:\r\ndbgfs_bf->ba_escape_timer = value;\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t iwl_dbgfs_bf_params_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nenum iwl_dbgfs_bf_mask param;\r\nint value, ret = 0;\r\nif (!strncmp("bf_energy_delta=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ENERGY_DELTA_MIN ||\r\nvalue > IWL_BF_ENERGY_DELTA_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ENERGY_DELTA;\r\n} else if (!strncmp("bf_roaming_energy_delta=", buf, 24)) {\r\nif (sscanf(buf+24, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ROAMING_ENERGY_DELTA_MIN ||\r\nvalue > IWL_BF_ROAMING_ENERGY_DELTA_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA;\r\n} else if (!strncmp("bf_roaming_state=", buf, 17)) {\r\nif (sscanf(buf+17, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ROAMING_STATE_MIN ||\r\nvalue > IWL_BF_ROAMING_STATE_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ROAMING_STATE;\r\n} else if (!strncmp("bf_temp_threshold=", buf, 18)) {\r\nif (sscanf(buf+18, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_THRESHOLD_MIN ||\r\nvalue > IWL_BF_TEMP_THRESHOLD_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_THRESHOLD;\r\n} else if (!strncmp("bf_temp_fast_filter=", buf, 20)) {\r\nif (sscanf(buf+20, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_FAST_FILTER_MIN ||\r\nvalue > IWL_BF_TEMP_FAST_FILTER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_FAST_FILTER;\r\n} else if (!strncmp("bf_temp_slow_filter=", buf, 20)) {\r\nif (sscanf(buf+20, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_SLOW_FILTER_MIN ||\r\nvalue > IWL_BF_TEMP_SLOW_FILTER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_SLOW_FILTER;\r\n} else if (!strncmp("bf_enable_beacon_filter=", buf, 24)) {\r\nif (sscanf(buf+24, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER;\r\n} else if (!strncmp("bf_debug_flag=", buf, 14)) {\r\nif (sscanf(buf+14, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_DEBUG_FLAG;\r\n} else if (!strncmp("bf_escape_timer=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ESCAPE_TIMER_MIN ||\r\nvalue > IWL_BF_ESCAPE_TIMER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ESCAPE_TIMER;\r\n} else if (!strncmp("ba_escape_timer=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BA_ESCAPE_TIMER_MIN ||\r\nvalue > IWL_BA_ESCAPE_TIMER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BA_ESCAPE_TIMER;\r\n} else if (!strncmp("ba_enable_beacon_abort=", buf, 23)) {\r\nif (sscanf(buf+23, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mvm->mutex);\r\niwl_dbgfs_update_bf(vif, param, value);\r\nif (param == MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER && !value)\r\nret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\r\nelse\r\nret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_bf_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[256];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_beacon_filter_cmd cmd = {\r\nIWL_BF_CMD_CONFIG_DEFAULTS,\r\n.bf_enable_beacon_filter =\r\ncpu_to_le32(IWL_BF_ENABLE_BEACON_FILTER_DEFAULT),\r\n.ba_enable_beacon_abort =\r\ncpu_to_le32(IWL_BA_ENABLE_BEACON_ABORT_DEFAULT),\r\n};\r\niwl_mvm_beacon_filter_debugfs_parameters(vif, &cmd);\r\nif (mvmvif->bf_data.bf_enabled)\r\ncmd.bf_enable_beacon_filter = cpu_to_le32(1);\r\nelse\r\ncmd.bf_enable_beacon_filter = 0;\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_energy_delta = %d\n",\r\nle32_to_cpu(cmd.bf_energy_delta));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_energy_delta = %d\n",\r\nle32_to_cpu(cmd.bf_roaming_energy_delta));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_state = %d\n",\r\nle32_to_cpu(cmd.bf_roaming_state));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_threshold = %d\n",\r\nle32_to_cpu(cmd.bf_temp_threshold));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_fast_filter = %d\n",\r\nle32_to_cpu(cmd.bf_temp_fast_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_slow_filter = %d\n",\r\nle32_to_cpu(cmd.bf_temp_slow_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_enable_beacon_filter = %d\n",\r\nle32_to_cpu(cmd.bf_enable_beacon_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_debug_flag = %d\n",\r\nle32_to_cpu(cmd.bf_debug_flag));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_escape_timer = %d\n",\r\nle32_to_cpu(cmd.bf_escape_timer));\r\npos += scnprintf(buf+pos, bufsz-pos, "ba_escape_timer = %d\n",\r\nle32_to_cpu(cmd.ba_escape_timer));\r\npos += scnprintf(buf+pos, bufsz-pos, "ba_enable_beacon_abort = %d\n",\r\nle32_to_cpu(cmd.ba_enable_beacon_abort));\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_low_latency_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu8 value;\r\nint ret;\r\nret = kstrtou8(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mvm->mutex);\r\niwl_mvm_update_low_latency(mvm, vif, value);\r\nmutex_unlock(&mvm->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t iwl_dbgfs_low_latency_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[3];\r\nbuf[0] = mvmvif->low_latency ? '1' : '0';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, sizeof(buf));\r\n}\r\nvoid iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct dentry *dbgfs_dir = vif->debugfs_dir;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[100];\r\nif (!dbgfs_dir || mvmvif->dbgfs_dir)\r\nreturn;\r\nmvmvif->dbgfs_dir = debugfs_create_dir("iwlmvm", dbgfs_dir);\r\nmvmvif->mvm = mvm;\r\nif (!mvmvif->dbgfs_dir) {\r\nIWL_ERR(mvm, "Failed to create debugfs directory under %s\n",\r\ndbgfs_dir->d_name.name);\r\nreturn;\r\n}\r\nif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM &&\r\n((vif->type == NL80211_IFTYPE_STATION && !vif->p2p) ||\r\n(vif->type == NL80211_IFTYPE_STATION && vif->p2p &&\r\nmvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_DCM)))\r\nMVM_DEBUGFS_ADD_FILE_VIF(pm_params, mvmvif->dbgfs_dir, S_IWUSR |\r\nS_IRUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(mac_params, mvmvif->dbgfs_dir, S_IRUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(low_latency, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nif (vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&\r\nmvmvif == mvm->bf_allowed_vif)\r\nMVM_DEBUGFS_ADD_FILE_VIF(bf_params, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nsnprintf(buf, 100, "../../../%s/%s/%s/%s",\r\ndbgfs_dir->d_parent->d_parent->d_name.name,\r\ndbgfs_dir->d_parent->d_name.name,\r\ndbgfs_dir->d_name.name,\r\nmvmvif->dbgfs_dir->d_name.name);\r\nmvmvif->dbgfs_slink = debugfs_create_symlink(dbgfs_dir->d_name.name,\r\nmvm->debugfs_dir, buf);\r\nif (!mvmvif->dbgfs_slink)\r\nIWL_ERR(mvm, "Can't create debugfs symbolic link under %s\n",\r\ndbgfs_dir->d_name.name);\r\nreturn;\r\nerr:\r\nIWL_ERR(mvm, "Can't create debugfs entity\n");\r\n}\r\nvoid iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\ndebugfs_remove(mvmvif->dbgfs_slink);\r\nmvmvif->dbgfs_slink = NULL;\r\ndebugfs_remove_recursive(mvmvif->dbgfs_dir);\r\nmvmvif->dbgfs_dir = NULL;\r\n}
