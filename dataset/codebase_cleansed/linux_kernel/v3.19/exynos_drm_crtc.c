static void exynos_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nDRM_DEBUG_KMS("crtc[%d] mode[%d]\n", crtc->base.id, mode);\r\nif (exynos_crtc->dpms == mode) {\r\nDRM_DEBUG_KMS("desired dpms mode is same as previous one.\n");\r\nreturn;\r\n}\r\nif (mode > DRM_MODE_DPMS_ON) {\r\nif (!wait_event_timeout(exynos_crtc->pending_flip_queue,\r\n!atomic_read(&exynos_crtc->pending_flip),\r\nHZ/20))\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\ndrm_crtc_vblank_off(crtc);\r\n}\r\nif (manager->ops->dpms)\r\nmanager->ops->dpms(manager, mode);\r\nexynos_crtc->dpms = mode;\r\nif (mode == DRM_MODE_DPMS_ON)\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic void exynos_drm_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void exynos_drm_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nexynos_drm_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\nexynos_plane_commit(crtc->primary);\r\nif (manager->ops->commit)\r\nmanager->ops->commit(manager);\r\nexynos_plane_dpms(crtc->primary, DRM_MODE_DPMS_ON);\r\n}\r\nstatic bool\r\nexynos_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nif (manager->ops->mode_fixup)\r\nreturn manager->ops->mode_fixup(manager, mode, adjusted_mode);\r\nreturn true;\r\n}\r\nstatic int\r\nexynos_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nunsigned int crtc_w;\r\nunsigned int crtc_h;\r\nmemcpy(&crtc->mode, adjusted_mode, sizeof(*adjusted_mode));\r\ncrtc_w = fb->width - x;\r\ncrtc_h = fb->height - y;\r\nif (manager->ops->mode_set)\r\nmanager->ops->mode_set(manager, &crtc->mode);\r\nreturn exynos_plane_mode_set(crtc->primary, crtc, fb, 0, 0,\r\ncrtc_w, crtc_h, x, y, crtc_w, crtc_h);\r\n}\r\nstatic int exynos_drm_crtc_mode_set_commit(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nunsigned int crtc_w;\r\nunsigned int crtc_h;\r\nint ret;\r\nif (exynos_crtc->dpms > DRM_MODE_DPMS_ON) {\r\nDRM_ERROR("failed framebuffer changing request.\n");\r\nreturn -EPERM;\r\n}\r\ncrtc_w = fb->width - x;\r\ncrtc_h = fb->height - y;\r\nret = exynos_plane_mode_set(crtc->primary, crtc, fb, 0, 0,\r\ncrtc_w, crtc_h, x, y, crtc_w, crtc_h);\r\nif (ret)\r\nreturn ret;\r\nexynos_drm_crtc_commit(crtc);\r\nreturn 0;\r\n}\r\nstatic int exynos_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nreturn exynos_drm_crtc_mode_set_commit(crtc, x, y, old_fb);\r\n}\r\nstatic void exynos_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct drm_plane *plane;\r\nint ret;\r\nexynos_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\ndrm_for_each_legacy_plane(plane, &crtc->dev->mode_config.plane_list) {\r\nif (plane->crtc != crtc)\r\ncontinue;\r\nret = plane->funcs->disable_plane(plane);\r\nif (ret)\r\nDRM_ERROR("Failed to disable plane %d\n", ret);\r\n}\r\n}\r\nstatic int exynos_drm_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_framebuffer *old_fb = crtc->primary->fb;\r\nint ret = -EINVAL;\r\nif (exynos_crtc->dpms > DRM_MODE_DPMS_ON) {\r\nDRM_ERROR("failed page flip request.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (event) {\r\nevent->pipe = exynos_crtc->pipe;\r\nret = drm_vblank_get(dev, exynos_crtc->pipe);\r\nif (ret) {\r\nDRM_DEBUG("failed to acquire vblank counter\n");\r\ngoto out;\r\n}\r\nspin_lock_irq(&dev->event_lock);\r\nlist_add_tail(&event->base.link,\r\n&dev_priv->pageflip_event_list);\r\natomic_set(&exynos_crtc->pending_flip, 1);\r\nspin_unlock_irq(&dev->event_lock);\r\ncrtc->primary->fb = fb;\r\nret = exynos_drm_crtc_mode_set_commit(crtc, crtc->x, crtc->y,\r\nNULL);\r\nif (ret) {\r\ncrtc->primary->fb = old_fb;\r\nspin_lock_irq(&dev->event_lock);\r\ndrm_vblank_put(dev, exynos_crtc->pipe);\r\nlist_del(&event->base.link);\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\nspin_unlock_irq(&dev->event_lock);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic void exynos_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_private *private = crtc->dev->dev_private;\r\nprivate->crtc[exynos_crtc->pipe] = NULL;\r\ndrm_crtc_cleanup(crtc);\r\nkfree(exynos_crtc);\r\n}\r\nstatic int exynos_drm_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (property == dev_priv->crtc_mode_property) {\r\nenum exynos_crtc_mode mode = val;\r\nif (mode == exynos_crtc->mode)\r\nreturn 0;\r\nexynos_crtc->mode = mode;\r\nswitch (mode) {\r\ncase CRTC_MODE_NORMAL:\r\nexynos_drm_crtc_commit(crtc);\r\nbreak;\r\ncase CRTC_MODE_BLANK:\r\nexynos_plane_dpms(crtc->primary, DRM_MODE_DPMS_OFF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void exynos_drm_crtc_attach_mode_property(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nprop = dev_priv->crtc_mode_property;\r\nif (!prop) {\r\nprop = drm_property_create_enum(dev, 0, "mode", mode_names,\r\nARRAY_SIZE(mode_names));\r\nif (!prop)\r\nreturn;\r\ndev_priv->crtc_mode_property = prop;\r\n}\r\ndrm_object_attach_property(&crtc->base, prop, 0);\r\n}\r\nint exynos_drm_crtc_create(struct exynos_drm_manager *manager)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc;\r\nstruct drm_plane *plane;\r\nstruct exynos_drm_private *private = manager->drm_dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nint ret;\r\nexynos_crtc = kzalloc(sizeof(*exynos_crtc), GFP_KERNEL);\r\nif (!exynos_crtc)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&exynos_crtc->pending_flip_queue);\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\nexynos_crtc->dpms = DRM_MODE_DPMS_OFF;\r\nexynos_crtc->manager = manager;\r\nexynos_crtc->pipe = manager->pipe;\r\nplane = exynos_plane_init(manager->drm_dev, 1 << manager->pipe,\r\nDRM_PLANE_TYPE_PRIMARY);\r\nif (IS_ERR(plane)) {\r\nret = PTR_ERR(plane);\r\ngoto err_plane;\r\n}\r\nmanager->crtc = &exynos_crtc->drm_crtc;\r\ncrtc = &exynos_crtc->drm_crtc;\r\nprivate->crtc[manager->pipe] = crtc;\r\nret = drm_crtc_init_with_planes(manager->drm_dev, crtc, plane, NULL,\r\n&exynos_crtc_funcs);\r\nif (ret < 0)\r\ngoto err_crtc;\r\ndrm_crtc_helper_add(crtc, &exynos_crtc_helper_funcs);\r\nexynos_drm_crtc_attach_mode_property(crtc);\r\nreturn 0;\r\nerr_crtc:\r\nplane->funcs->destroy(plane);\r\nerr_plane:\r\nkfree(exynos_crtc);\r\nreturn ret;\r\n}\r\nint exynos_drm_crtc_enable_vblank(struct drm_device *dev, int pipe)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[pipe]);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nif (exynos_crtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn -EPERM;\r\nif (manager->ops->enable_vblank)\r\nmanager->ops->enable_vblank(manager);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_crtc_disable_vblank(struct drm_device *dev, int pipe)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[pipe]);\r\nstruct exynos_drm_manager *manager = exynos_crtc->manager;\r\nif (exynos_crtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nif (manager->ops->disable_vblank)\r\nmanager->ops->disable_vblank(manager);\r\n}\r\nvoid exynos_drm_crtc_finish_pageflip(struct drm_device *dev, int pipe)\r\n{\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct drm_crtc *drm_crtc = dev_priv->crtc[pipe];\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(drm_crtc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev_priv->pageflip_event_list,\r\nbase.link) {\r\nif (pipe != e->pipe)\r\ncontinue;\r\nlist_del(&e->base.link);\r\ndrm_send_vblank_event(dev, -1, e);\r\ndrm_vblank_put(dev, pipe);\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\nwake_up(&exynos_crtc->pending_flip_queue);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nvoid exynos_drm_crtc_plane_mode_set(struct drm_crtc *crtc,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct exynos_drm_manager *manager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->win_mode_set)\r\nmanager->ops->win_mode_set(manager, overlay);\r\n}\r\nvoid exynos_drm_crtc_plane_commit(struct drm_crtc *crtc, int zpos)\r\n{\r\nstruct exynos_drm_manager *manager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->win_commit)\r\nmanager->ops->win_commit(manager, zpos);\r\n}\r\nvoid exynos_drm_crtc_plane_enable(struct drm_crtc *crtc, int zpos)\r\n{\r\nstruct exynos_drm_manager *manager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->win_enable)\r\nmanager->ops->win_enable(manager, zpos);\r\n}\r\nvoid exynos_drm_crtc_plane_disable(struct drm_crtc *crtc, int zpos)\r\n{\r\nstruct exynos_drm_manager *manager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->win_disable)\r\nmanager->ops->win_disable(manager, zpos);\r\n}\r\nvoid exynos_drm_crtc_complete_scanout(struct drm_framebuffer *fb)\r\n{\r\nstruct exynos_drm_manager *manager;\r\nstruct drm_device *dev = fb->dev;\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nmanager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->wait_for_vblank)\r\nmanager->ops->wait_for_vblank(manager);\r\n}\r\n}\r\nint exynos_drm_crtc_get_pipe_from_type(struct drm_device *drm_dev,\r\nunsigned int out_type)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &drm_dev->mode_config.crtc_list, head) {\r\nstruct exynos_drm_crtc *exynos_crtc;\r\nexynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->manager->type == out_type)\r\nreturn exynos_crtc->manager->pipe;\r\n}\r\nreturn -EPERM;\r\n}\r\nvoid exynos_drm_crtc_te_handler(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_manager *manager = to_exynos_crtc(crtc)->manager;\r\nif (manager->ops->te_handler)\r\nmanager->ops->te_handler(manager);\r\n}
