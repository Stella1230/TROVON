static int drm_getunique(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_unique *u = data;\r\nstruct drm_master *master = file_priv->master;\r\nif (u->unique_len >= master->unique_len) {\r\nif (copy_to_user(u->unique, master->unique, master->unique_len))\r\nreturn -EFAULT;\r\n}\r\nu->unique_len = master->unique_len;\r\nreturn 0;\r\n}\r\nstatic void\r\ndrm_unset_busid(struct drm_device *dev,\r\nstruct drm_master *master)\r\n{\r\nkfree(master->unique);\r\nmaster->unique = NULL;\r\nmaster->unique_len = 0;\r\n}\r\nstatic int drm_setunique(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_unique *u = data;\r\nstruct drm_master *master = file_priv->master;\r\nint ret;\r\nif (master->unique_len || master->unique)\r\nreturn -EBUSY;\r\nif (!u->unique_len || u->unique_len > 1024)\r\nreturn -EINVAL;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\nif (WARN_ON(!dev->pdev))\r\nreturn -EINVAL;\r\nret = drm_pci_set_unique(dev, master, u);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndrm_unset_busid(dev, master);\r\nreturn ret;\r\n}\r\nstatic int drm_set_busid(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct drm_master *master = file_priv->master;\r\nint ret;\r\nif (master->unique != NULL)\r\ndrm_unset_busid(dev, master);\r\nif (dev->driver->set_busid) {\r\nret = dev->driver->set_busid(dev, master);\r\nif (ret) {\r\ndrm_unset_busid(dev, master);\r\nreturn ret;\r\n}\r\n} else {\r\nif (WARN(dev->unique == NULL,\r\n"No drm_driver.set_busid() implementation provided by "\r\n"%ps. Use drm_dev_set_unique() to set the unique "\r\n"name explicitly.", dev->driver))\r\nreturn -EINVAL;\r\nmaster->unique = kstrdup(dev->unique, GFP_KERNEL);\r\nif (master->unique)\r\nmaster->unique_len = strlen(dev->unique);\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_getmap(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_map *map = data;\r\nstruct drm_map_list *r_list = NULL;\r\nstruct list_head *list;\r\nint idx;\r\nint i;\r\nidx = map->offset;\r\nif (idx < 0)\r\nreturn -EINVAL;\r\ni = 0;\r\nmutex_lock(&dev->struct_mutex);\r\nlist_for_each(list, &dev->maplist) {\r\nif (i == idx) {\r\nr_list = list_entry(list, struct drm_map_list, head);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!r_list || !r_list->map) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nmap->offset = r_list->map->offset;\r\nmap->size = r_list->map->size;\r\nmap->type = r_list->map->type;\r\nmap->flags = r_list->map->flags;\r\nmap->handle = (void *)(unsigned long) r_list->user_token;\r\n#ifdef CONFIG_X86\r\nmap->mtrr = phys_wc_to_mtrr_index(r_list->map->mtrr);\r\n#else\r\nmap->mtrr = -1;\r\n#endif\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstatic int drm_getclient(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_client *client = data;\r\nif (client->idx == 0) {\r\nclient->auth = file_priv->authenticated;\r\nclient->pid = pid_vnr(file_priv->pid);\r\nclient->uid = from_kuid_munged(current_user_ns(),\r\nfile_priv->uid);\r\nclient->magic = 0;\r\nclient->iocs = 0;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int drm_getstats(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_stats *stats = data;\r\nmemset(stats, 0, sizeof(*stats));\r\nreturn 0;\r\n}\r\nstatic int drm_getcap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_get_cap *req = data;\r\nreq->value = 0;\r\nswitch (req->capability) {\r\ncase DRM_CAP_DUMB_BUFFER:\r\nif (dev->driver->dumb_create)\r\nreq->value = 1;\r\nbreak;\r\ncase DRM_CAP_VBLANK_HIGH_CRTC:\r\nreq->value = 1;\r\nbreak;\r\ncase DRM_CAP_DUMB_PREFERRED_DEPTH:\r\nreq->value = dev->mode_config.preferred_depth;\r\nbreak;\r\ncase DRM_CAP_DUMB_PREFER_SHADOW:\r\nreq->value = dev->mode_config.prefer_shadow;\r\nbreak;\r\ncase DRM_CAP_PRIME:\r\nreq->value |= dev->driver->prime_fd_to_handle ? DRM_PRIME_CAP_IMPORT : 0;\r\nreq->value |= dev->driver->prime_handle_to_fd ? DRM_PRIME_CAP_EXPORT : 0;\r\nbreak;\r\ncase DRM_CAP_TIMESTAMP_MONOTONIC:\r\nreq->value = drm_timestamp_monotonic;\r\nbreak;\r\ncase DRM_CAP_ASYNC_PAGE_FLIP:\r\nreq->value = dev->mode_config.async_page_flip;\r\nbreak;\r\ncase DRM_CAP_CURSOR_WIDTH:\r\nif (dev->mode_config.cursor_width)\r\nreq->value = dev->mode_config.cursor_width;\r\nelse\r\nreq->value = 64;\r\nbreak;\r\ncase DRM_CAP_CURSOR_HEIGHT:\r\nif (dev->mode_config.cursor_height)\r\nreq->value = dev->mode_config.cursor_height;\r\nelse\r\nreq->value = 64;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndrm_setclientcap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_set_client_cap *req = data;\r\nswitch (req->capability) {\r\ncase DRM_CLIENT_CAP_STEREO_3D:\r\nif (req->value > 1)\r\nreturn -EINVAL;\r\nfile_priv->stereo_allowed = req->value;\r\nbreak;\r\ncase DRM_CLIENT_CAP_UNIVERSAL_PLANES:\r\nif (req->value > 1)\r\nreturn -EINVAL;\r\nfile_priv->universal_planes = req->value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_setversion(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_set_version *sv = data;\r\nint if_version, retcode = 0;\r\nif (sv->drm_di_major != -1) {\r\nif (sv->drm_di_major != DRM_IF_MAJOR ||\r\nsv->drm_di_minor < 0 || sv->drm_di_minor > DRM_IF_MINOR) {\r\nretcode = -EINVAL;\r\ngoto done;\r\n}\r\nif_version = DRM_IF_VERSION(sv->drm_di_major,\r\nsv->drm_di_minor);\r\ndev->if_version = max(if_version, dev->if_version);\r\nif (sv->drm_di_minor >= 1) {\r\nretcode = drm_set_busid(dev, file_priv);\r\nif (retcode)\r\ngoto done;\r\n}\r\n}\r\nif (sv->drm_dd_major != -1) {\r\nif (sv->drm_dd_major != dev->driver->major ||\r\nsv->drm_dd_minor < 0 || sv->drm_dd_minor >\r\ndev->driver->minor) {\r\nretcode = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nsv->drm_di_major = DRM_IF_MAJOR;\r\nsv->drm_di_minor = DRM_IF_MINOR;\r\nsv->drm_dd_major = dev->driver->major;\r\nsv->drm_dd_minor = dev->driver->minor;\r\nreturn retcode;\r\n}\r\nint drm_noop(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nDRM_DEBUG("\n");\r\nreturn 0;\r\n}\r\nstatic int drm_copy_field(char __user *buf, size_t *buf_len, const char *value)\r\n{\r\nint len;\r\nlen = strlen(value);\r\nif (len > *buf_len)\r\nlen = *buf_len;\r\n*buf_len = strlen(value);\r\nif (len && buf)\r\nif (copy_to_user(buf, value, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int drm_version(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_version *version = data;\r\nint err;\r\nversion->version_major = dev->driver->major;\r\nversion->version_minor = dev->driver->minor;\r\nversion->version_patchlevel = dev->driver->patchlevel;\r\nerr = drm_copy_field(version->name, &version->name_len,\r\ndev->driver->name);\r\nif (!err)\r\nerr = drm_copy_field(version->date, &version->date_len,\r\ndev->driver->date);\r\nif (!err)\r\nerr = drm_copy_field(version->desc, &version->desc_len,\r\ndev->driver->desc);\r\nreturn err;\r\n}\r\nstatic int drm_ioctl_permit(u32 flags, struct drm_file *file_priv)\r\n{\r\nif (unlikely((flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)))\r\nreturn -EACCES;\r\nif (unlikely((flags & DRM_AUTH) && !drm_is_render_client(file_priv) &&\r\n!file_priv->authenticated))\r\nreturn -EACCES;\r\nif (unlikely((flags & DRM_MASTER) && !file_priv->is_master &&\r\n!drm_is_control_client(file_priv)))\r\nreturn -EACCES;\r\nif (unlikely(!(flags & DRM_CONTROL_ALLOW) &&\r\ndrm_is_control_client(file_priv)))\r\nreturn -EACCES;\r\nif (unlikely(!(flags & DRM_RENDER_ALLOW) &&\r\ndrm_is_render_client(file_priv)))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nlong drm_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev;\r\nconst struct drm_ioctl_desc *ioctl = NULL;\r\ndrm_ioctl_t *func;\r\nunsigned int nr = DRM_IOCTL_NR(cmd);\r\nint retcode = -EINVAL;\r\nchar stack_kdata[128];\r\nchar *kdata = NULL;\r\nunsigned int usize, asize;\r\ndev = file_priv->minor->dev;\r\nif (drm_device_is_unplugged(dev))\r\nreturn -ENODEV;\r\nif ((nr >= DRM_CORE_IOCTL_COUNT) &&\r\n((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))\r\ngoto err_i1;\r\nif ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&\r\n(nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {\r\nu32 drv_size;\r\nioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];\r\ndrv_size = _IOC_SIZE(ioctl->cmd_drv);\r\nusize = asize = _IOC_SIZE(cmd);\r\nif (drv_size > asize)\r\nasize = drv_size;\r\ncmd = ioctl->cmd_drv;\r\n}\r\nelse if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {\r\nu32 drv_size;\r\nioctl = &drm_ioctls[nr];\r\ndrv_size = _IOC_SIZE(ioctl->cmd);\r\nusize = asize = _IOC_SIZE(cmd);\r\nif (drv_size > asize)\r\nasize = drv_size;\r\ncmd = ioctl->cmd;\r\n} else\r\ngoto err_i1;\r\nDRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\n",\r\ntask_pid_nr(current),\r\n(long)old_encode_dev(file_priv->minor->kdev->devt),\r\nfile_priv->authenticated, ioctl->name);\r\nfunc = ioctl->func;\r\nif (unlikely(!func)) {\r\nDRM_DEBUG("no function\n");\r\nretcode = -EINVAL;\r\ngoto err_i1;\r\n}\r\nretcode = drm_ioctl_permit(ioctl->flags, file_priv);\r\nif (unlikely(retcode))\r\ngoto err_i1;\r\nif (cmd & (IOC_IN | IOC_OUT)) {\r\nif (asize <= sizeof(stack_kdata)) {\r\nkdata = stack_kdata;\r\n} else {\r\nkdata = kmalloc(asize, GFP_KERNEL);\r\nif (!kdata) {\r\nretcode = -ENOMEM;\r\ngoto err_i1;\r\n}\r\n}\r\nif (asize > usize)\r\nmemset(kdata + usize, 0, asize - usize);\r\n}\r\nif (cmd & IOC_IN) {\r\nif (copy_from_user(kdata, (void __user *)arg,\r\nusize) != 0) {\r\nretcode = -EFAULT;\r\ngoto err_i1;\r\n}\r\n} else if (cmd & IOC_OUT) {\r\nmemset(kdata, 0, usize);\r\n}\r\nif (ioctl->flags & DRM_UNLOCKED)\r\nretcode = func(dev, kdata, file_priv);\r\nelse {\r\nmutex_lock(&drm_global_mutex);\r\nretcode = func(dev, kdata, file_priv);\r\nmutex_unlock(&drm_global_mutex);\r\n}\r\nif (cmd & IOC_OUT) {\r\nif (copy_to_user((void __user *)arg, kdata,\r\nusize) != 0)\r\nretcode = -EFAULT;\r\n}\r\nerr_i1:\r\nif (!ioctl)\r\nDRM_DEBUG("invalid ioctl: pid=%d, dev=0x%lx, auth=%d, cmd=0x%02x, nr=0x%02x\n",\r\ntask_pid_nr(current),\r\n(long)old_encode_dev(file_priv->minor->kdev->devt),\r\nfile_priv->authenticated, cmd, nr);\r\nif (kdata != stack_kdata)\r\nkfree(kdata);\r\nif (retcode)\r\nDRM_DEBUG("ret = %d\n", retcode);\r\nreturn retcode;\r\n}\r\nbool drm_ioctl_flags(unsigned int nr, unsigned int *flags)\r\n{\r\nif ((nr >= DRM_COMMAND_END && nr < DRM_CORE_IOCTL_COUNT) ||\r\n(nr < DRM_COMMAND_BASE)) {\r\n*flags = drm_ioctls[nr].flags;\r\nreturn true;\r\n}\r\nreturn false;\r\n}
