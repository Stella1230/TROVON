static u32\r\nread_vco(struct nvc0_clock_priv *priv, u32 dsrc)\r\n{\r\nstruct nouveau_clock *clk = &priv->base;\r\nu32 ssrc = nv_rd32(priv, dsrc);\r\nif (!(ssrc & 0x00000100))\r\nreturn clk->read(clk, nv_clk_src_sppll0);\r\nreturn clk->read(clk, nv_clk_src_sppll1);\r\n}\r\nstatic u32\r\nread_pll(struct nvc0_clock_priv *priv, u32 pll)\r\n{\r\nstruct nouveau_clock *clk = &priv->base;\r\nu32 ctrl = nv_rd32(priv, pll + 0x00);\r\nu32 coef = nv_rd32(priv, pll + 0x04);\r\nu32 P = (coef & 0x003f0000) >> 16;\r\nu32 N = (coef & 0x0000ff00) >> 8;\r\nu32 M = (coef & 0x000000ff) >> 0;\r\nu32 sclk;\r\nif (!(ctrl & 0x00000001))\r\nreturn 0;\r\nswitch (pll) {\r\ncase 0x00e800:\r\ncase 0x00e820:\r\nsclk = nv_device(priv)->crystal;\r\nP = 1;\r\nbreak;\r\ncase 0x132000:\r\nsclk = clk->read(clk, nv_clk_src_mpllsrc);\r\nbreak;\r\ncase 0x132020:\r\nsclk = clk->read(clk, nv_clk_src_mpllsrcref);\r\nbreak;\r\ncase 0x137000:\r\ncase 0x137020:\r\ncase 0x137040:\r\ncase 0x1370e0:\r\nsclk = read_div(priv, (pll & 0xff) / 0x20, 0x137120, 0x137140);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn sclk * N / M / P;\r\n}\r\nstatic u32\r\nread_div(struct nvc0_clock_priv *priv, int doff, u32 dsrc, u32 dctl)\r\n{\r\nu32 ssrc = nv_rd32(priv, dsrc + (doff * 4));\r\nu32 sctl = nv_rd32(priv, dctl + (doff * 4));\r\nswitch (ssrc & 0x00000003) {\r\ncase 0:\r\nif ((ssrc & 0x00030000) != 0x00030000)\r\nreturn nv_device(priv)->crystal;\r\nreturn 108000;\r\ncase 2:\r\nreturn 100000;\r\ncase 3:\r\nif (sctl & 0x80000000) {\r\nu32 sclk = read_vco(priv, dsrc + (doff * 4));\r\nu32 sdiv = (sctl & 0x0000003f) + 2;\r\nreturn (sclk * 2) / sdiv;\r\n}\r\nreturn read_vco(priv, dsrc + (doff * 4));\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u32\r\nread_clk(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nu32 sctl = nv_rd32(priv, 0x137250 + (clk * 4));\r\nu32 ssel = nv_rd32(priv, 0x137100);\r\nu32 sclk, sdiv;\r\nif (ssel & (1 << clk)) {\r\nif (clk < 7)\r\nsclk = read_pll(priv, 0x137000 + (clk * 0x20));\r\nelse\r\nsclk = read_pll(priv, 0x1370e0);\r\nsdiv = ((sctl & 0x00003f00) >> 8) + 2;\r\n} else {\r\nsclk = read_div(priv, clk, 0x137160, 0x1371d0);\r\nsdiv = ((sctl & 0x0000003f) >> 0) + 2;\r\n}\r\nif (sctl & 0x80000000)\r\nreturn (sclk * 2) / sdiv;\r\nreturn sclk;\r\n}\r\nstatic int\r\nnvc0_clock_read(struct nouveau_clock *clk, enum nv_clk_src src)\r\n{\r\nstruct nouveau_device *device = nv_device(clk);\r\nstruct nvc0_clock_priv *priv = (void *)clk;\r\nswitch (src) {\r\ncase nv_clk_src_crystal:\r\nreturn device->crystal;\r\ncase nv_clk_src_href:\r\nreturn 100000;\r\ncase nv_clk_src_sppll0:\r\nreturn read_pll(priv, 0x00e800);\r\ncase nv_clk_src_sppll1:\r\nreturn read_pll(priv, 0x00e820);\r\ncase nv_clk_src_mpllsrcref:\r\nreturn read_div(priv, 0, 0x137320, 0x137330);\r\ncase nv_clk_src_mpllsrc:\r\nreturn read_pll(priv, 0x132020);\r\ncase nv_clk_src_mpll:\r\nreturn read_pll(priv, 0x132000);\r\ncase nv_clk_src_mdiv:\r\nreturn read_div(priv, 0, 0x137300, 0x137310);\r\ncase nv_clk_src_mem:\r\nif (nv_rd32(priv, 0x1373f0) & 0x00000002)\r\nreturn clk->read(clk, nv_clk_src_mpll);\r\nreturn clk->read(clk, nv_clk_src_mdiv);\r\ncase nv_clk_src_gpc:\r\nreturn read_clk(priv, 0x00);\r\ncase nv_clk_src_rop:\r\nreturn read_clk(priv, 0x01);\r\ncase nv_clk_src_hubk07:\r\nreturn read_clk(priv, 0x02);\r\ncase nv_clk_src_hubk06:\r\nreturn read_clk(priv, 0x07);\r\ncase nv_clk_src_hubk01:\r\nreturn read_clk(priv, 0x08);\r\ncase nv_clk_src_copy:\r\nreturn read_clk(priv, 0x09);\r\ncase nv_clk_src_daemon:\r\nreturn read_clk(priv, 0x0c);\r\ncase nv_clk_src_vdec:\r\nreturn read_clk(priv, 0x0e);\r\ndefault:\r\nnv_error(clk, "invalid clock source %d\n", src);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u32\r\ncalc_div(struct nvc0_clock_priv *priv, int clk, u32 ref, u32 freq, u32 *ddiv)\r\n{\r\nu32 div = min((ref * 2) / freq, (u32)65);\r\nif (div < 2)\r\ndiv = 2;\r\n*ddiv = div - 2;\r\nreturn (ref * 2) / div;\r\n}\r\nstatic u32\r\ncalc_src(struct nvc0_clock_priv *priv, int clk, u32 freq, u32 *dsrc, u32 *ddiv)\r\n{\r\nu32 sclk;\r\n*ddiv = 0x00000000;\r\nswitch (freq) {\r\ncase 27000:\r\ncase 108000:\r\n*dsrc = 0x00000000;\r\nif (freq == 108000)\r\n*dsrc |= 0x00030000;\r\nreturn freq;\r\ncase 100000:\r\n*dsrc = 0x00000002;\r\nreturn freq;\r\ndefault:\r\n*dsrc = 0x00000003;\r\nbreak;\r\n}\r\nsclk = read_vco(priv, 0x137160 + (clk * 4));\r\nif (clk < 7)\r\nsclk = calc_div(priv, clk, sclk, freq, ddiv);\r\nreturn sclk;\r\n}\r\nstatic u32\r\ncalc_pll(struct nvc0_clock_priv *priv, int clk, u32 freq, u32 *coef)\r\n{\r\nstruct nouveau_bios *bios = nouveau_bios(priv);\r\nstruct nvbios_pll limits;\r\nint N, M, P, ret;\r\nret = nvbios_pll_parse(bios, 0x137000 + (clk * 0x20), &limits);\r\nif (ret)\r\nreturn 0;\r\nlimits.refclk = read_div(priv, clk, 0x137120, 0x137140);\r\nif (!limits.refclk)\r\nreturn 0;\r\nret = nva3_pll_calc(nv_subdev(priv), &limits, freq, &N, NULL, &M, &P);\r\nif (ret <= 0)\r\nreturn 0;\r\n*coef = (P << 16) | (N << 8) | M;\r\nreturn ret;\r\n}\r\nstatic int\r\ncalc_clk(struct nvc0_clock_priv *priv,\r\nstruct nouveau_cstate *cstate, int clk, int dom)\r\n{\r\nstruct nvc0_clock_info *info = &priv->eng[clk];\r\nu32 freq = cstate->domain[dom];\r\nu32 src0, div0, div1D, div1P = 0;\r\nu32 clk0, clk1 = 0;\r\nif (!freq)\r\nreturn 0;\r\nclk0 = calc_src(priv, clk, freq, &src0, &div0);\r\nclk0 = calc_div(priv, clk, clk0, freq, &div1D);\r\nif (clk0 != freq && (0x00004387 & (1 << clk))) {\r\nif (clk <= 7)\r\nclk1 = calc_pll(priv, clk, freq, &info->coef);\r\nelse\r\nclk1 = cstate->domain[nv_clk_src_hubk06];\r\nclk1 = calc_div(priv, clk, clk1, freq, &div1P);\r\n}\r\nif (abs((int)freq - clk0) <= abs((int)freq - clk1)) {\r\ninfo->dsrc = src0;\r\nif (div0) {\r\ninfo->ddiv |= 0x80000000;\r\ninfo->ddiv |= div0 << 8;\r\ninfo->ddiv |= div0;\r\n}\r\nif (div1D) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1D;\r\n}\r\ninfo->ssel = info->coef = 0;\r\ninfo->freq = clk0;\r\n} else {\r\nif (div1P) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1P << 8;\r\n}\r\ninfo->ssel = (1 << clk);\r\ninfo->freq = clk1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_clock_calc(struct nouveau_clock *clk, struct nouveau_cstate *cstate)\r\n{\r\nstruct nvc0_clock_priv *priv = (void *)clk;\r\nint ret;\r\nif ((ret = calc_clk(priv, cstate, 0x00, nv_clk_src_gpc)) ||\r\n(ret = calc_clk(priv, cstate, 0x01, nv_clk_src_rop)) ||\r\n(ret = calc_clk(priv, cstate, 0x02, nv_clk_src_hubk07)) ||\r\n(ret = calc_clk(priv, cstate, 0x07, nv_clk_src_hubk06)) ||\r\n(ret = calc_clk(priv, cstate, 0x08, nv_clk_src_hubk01)) ||\r\n(ret = calc_clk(priv, cstate, 0x09, nv_clk_src_copy)) ||\r\n(ret = calc_clk(priv, cstate, 0x0c, nv_clk_src_daemon)) ||\r\n(ret = calc_clk(priv, cstate, 0x0e, nv_clk_src_vdec)))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_clock_prog_0(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nstruct nvc0_clock_info *info = &priv->eng[clk];\r\nif (clk < 7 && !info->ssel) {\r\nnv_mask(priv, 0x1371d0 + (clk * 0x04), 0x80003f3f, info->ddiv);\r\nnv_wr32(priv, 0x137160 + (clk * 0x04), info->dsrc);\r\n}\r\n}\r\nstatic void\r\nnvc0_clock_prog_1(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nnv_mask(priv, 0x137100, (1 << clk), 0x00000000);\r\nnv_wait(priv, 0x137100, (1 << clk), 0x00000000);\r\n}\r\nstatic void\r\nnvc0_clock_prog_2(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nstruct nvc0_clock_info *info = &priv->eng[clk];\r\nconst u32 addr = 0x137000 + (clk * 0x20);\r\nif (clk <= 7) {\r\nnv_mask(priv, addr + 0x00, 0x00000004, 0x00000000);\r\nnv_mask(priv, addr + 0x00, 0x00000001, 0x00000000);\r\nif (info->coef) {\r\nnv_wr32(priv, addr + 0x04, info->coef);\r\nnv_mask(priv, addr + 0x00, 0x00000001, 0x00000001);\r\nnv_wait(priv, addr + 0x00, 0x00020000, 0x00020000);\r\nnv_mask(priv, addr + 0x00, 0x00020004, 0x00000004);\r\n}\r\n}\r\n}\r\nstatic void\r\nnvc0_clock_prog_3(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nstruct nvc0_clock_info *info = &priv->eng[clk];\r\nif (info->ssel) {\r\nnv_mask(priv, 0x137100, (1 << clk), info->ssel);\r\nnv_wait(priv, 0x137100, (1 << clk), info->ssel);\r\n}\r\n}\r\nstatic void\r\nnvc0_clock_prog_4(struct nvc0_clock_priv *priv, int clk)\r\n{\r\nstruct nvc0_clock_info *info = &priv->eng[clk];\r\nnv_mask(priv, 0x137250 + (clk * 0x04), 0x00003f3f, info->mdiv);\r\n}\r\nstatic int\r\nnvc0_clock_prog(struct nouveau_clock *clk)\r\n{\r\nstruct nvc0_clock_priv *priv = (void *)clk;\r\nstruct {\r\nvoid (*exec)(struct nvc0_clock_priv *, int);\r\n} stage[] = {\r\n{ nvc0_clock_prog_0 },\r\n{ nvc0_clock_prog_1 },\r\n{ nvc0_clock_prog_2 },\r\n{ nvc0_clock_prog_3 },\r\n{ nvc0_clock_prog_4 },\r\n};\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(stage); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(priv->eng); j++) {\r\nif (!priv->eng[j].freq)\r\ncontinue;\r\nstage[i].exec(priv, j);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_clock_tidy(struct nouveau_clock *clk)\r\n{\r\nstruct nvc0_clock_priv *priv = (void *)clk;\r\nmemset(priv->eng, 0x00, sizeof(priv->eng));\r\n}\r\nstatic int\r\nnvc0_clock_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nvc0_clock_priv *priv;\r\nint ret;\r\nret = nouveau_clock_create(parent, engine, oclass, nvc0_domain, NULL, 0,\r\nfalse, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\npriv->base.read = nvc0_clock_read;\r\npriv->base.calc = nvc0_clock_calc;\r\npriv->base.prog = nvc0_clock_prog;\r\npriv->base.tidy = nvc0_clock_tidy;\r\nreturn 0;\r\n}
