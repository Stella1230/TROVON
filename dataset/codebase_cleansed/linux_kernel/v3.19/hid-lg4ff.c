static __s32 lg4ff_adjust_dfp_x_axis(__s32 value, __u16 range)\r\n{\r\n__u16 max_range;\r\n__s32 new_value;\r\nif (range == 900)\r\nreturn value;\r\nelse if (range == 200)\r\nreturn value;\r\nelse if (range < 200)\r\nmax_range = 200;\r\nelse\r\nmax_range = 900;\r\nnew_value = 8192 + mult_frac(value - 8192, max_range, range);\r\nif (new_value < 0)\r\nreturn 0;\r\nelse if (new_value > 16383)\r\nreturn 16383;\r\nelse\r\nreturn new_value;\r\n}\r\nint lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value, struct lg_drv_data *drv_data)\r\n{\r\nstruct lg4ff_device_entry *entry = drv_data->device_props;\r\n__s32 new_value = 0;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found");\r\nreturn 0;\r\n}\r\nswitch (entry->product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nswitch (usage->code) {\r\ncase ABS_X:\r\nnew_value = lg4ff_adjust_dfp_x_axis(value, entry->range);\r\ninput_event(field->hidinput->input, usage->type, usage->code, new_value);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int hid_lg4ff_play(struct input_dev *dev, void *data, struct ff_effect *effect)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\nint x;\r\n#define CLAMP(x) do { if (x < 0) x = 0; else if (x > 0xff) x = 0xff; } while (0)\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nx = effect->u.ramp.start_level + 0x80;\r\nCLAMP(x);\r\nif (x == 0x80) {\r\nvalue[0] = 0x13;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nreturn 0;\r\n}\r\nvalue[0] = 0x11;\r\nvalue[1] = 0x08;\r\nvalue[2] = x;\r\nvalue[3] = 0x80;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hid_lg4ff_set_autocenter_default(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\n__u32 expand_a, expand_b;\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nif (magnitude == 0) {\r\nvalue[0] = 0xf5;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nreturn;\r\n}\r\nif (magnitude <= 0xaaaa) {\r\nexpand_a = 0x0c * magnitude;\r\nexpand_b = 0x80 * magnitude;\r\n} else {\r\nexpand_a = (0x0c * 0xaaaa) + 0x06 * (magnitude - 0xaaaa);\r\nexpand_b = (0x80 * 0xaaaa) + 0xff * (magnitude - 0xaaaa);\r\n}\r\nswitch (entry->product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\r\ncase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\r\nbreak;\r\ndefault:\r\nexpand_a = expand_a >> 1;\r\nbreak;\r\n}\r\nvalue[0] = 0xfe;\r\nvalue[1] = 0x0d;\r\nvalue[2] = expand_a / 0xaaaa;\r\nvalue[3] = expand_a / 0xaaaa;\r\nvalue[4] = expand_b / 0xaaaa;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nvalue[0] = 0x14;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void hid_lg4ff_set_autocenter_ffex(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\nmagnitude = magnitude * 90 / 65535;\r\nvalue[0] = 0xfe;\r\nvalue[1] = 0x03;\r\nvalue[2] = magnitude >> 14;\r\nvalue[3] = magnitude >> 14;\r\nvalue[4] = magnitude;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void hid_lg4ff_set_range_g25(struct hid_device *hid, u16 range)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\ndbg_hid("G25/G27/DFGT: setting range to %u\n", range);\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x81;\r\nvalue[2] = range & 0x00ff;\r\nvalue[3] = (range & 0xff00) >> 8;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void hid_lg4ff_set_range_dfp(struct hid_device *hid, __u16 range)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nint start_left, start_right, full_range;\r\n__s32 *value = report->field[0]->value;\r\ndbg_hid("Driving Force Pro: setting range to %u\n", range);\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nif (range > 200) {\r\nreport->field[0]->value[1] = 0x03;\r\nfull_range = 900;\r\n} else {\r\nreport->field[0]->value[1] = 0x02;\r\nfull_range = 200;\r\n}\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nvalue[0] = 0x81;\r\nvalue[1] = 0x0b;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nif (range == 200 || range == 900) {\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\nreturn;\r\n}\r\nstart_left = (((full_range - range + 1) * 2047) / full_range);\r\nstart_right = 0xfff - start_left;\r\nvalue[2] = start_left >> 4;\r\nvalue[3] = start_right >> 4;\r\nvalue[4] = 0xff;\r\nvalue[5] = (start_right & 0xe) << 4 | (start_left & 0xe);\r\nvalue[6] = 0xff;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void hid_lg4ff_switch_native(struct hid_device *hid, const struct lg4ff_native_cmd *cmd)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__u8 i, j;\r\nj = 0;\r\nwhile (j < 7*cmd->cmd_num) {\r\nfor (i = 0; i < 7; i++)\r\nreport->field[0]->value[i] = cmd->cmd[j++];\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\n}\r\nstatic ssize_t lg4ff_range_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nsize_t count;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn 0;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn 0;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%u\n", entry->range);\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\n__u16 range = simple_strtoul(buf, NULL, 10);\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn -EINVAL;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn -EINVAL;\r\n}\r\nif (range == 0)\r\nrange = entry->max_range;\r\nif (entry->set_range != NULL && range >= entry->min_range && range <= entry->max_range) {\r\nentry->set_range(hid, range);\r\nentry->range = range;\r\n}\r\nreturn count;\r\n}\r\nstatic void lg4ff_set_leds(struct hid_device *hid, __u8 leds)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__s32 *value = report->field[0]->value;\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x12;\r\nvalue[2] = leds;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void lg4ff_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = container_of(dev, struct hid_device, dev);\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\r\nstruct lg4ff_device_entry *entry;\r\nint i, state = 0;\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn;\r\n}\r\nentry = (struct lg4ff_device_entry *)drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found.");\r\nreturn;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (led_cdev != entry->led[i])\r\ncontinue;\r\nstate = (entry->led_state >> i) & 1;\r\nif (value == LED_OFF && state) {\r\nentry->led_state &= ~(1 << i);\r\nlg4ff_set_leds(hid, entry->led_state);\r\n} else if (value != LED_OFF && !state) {\r\nentry->led_state |= 1 << i;\r\nlg4ff_set_leds(hid, entry->led_state);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic enum led_brightness lg4ff_led_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = container_of(dev, struct hid_device, dev);\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\r\nstruct lg4ff_device_entry *entry;\r\nint i, value = 0;\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn LED_OFF;\r\n}\r\nentry = (struct lg4ff_device_entry *)drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found.");\r\nreturn LED_OFF;\r\n}\r\nfor (i = 0; i < 5; i++)\r\nif (led_cdev == entry->led[i]) {\r\nvalue = (entry->led_state >> i) & 1;\r\nbreak;\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nint lg4ff_init(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *dev = hidinput->input;\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nstruct usb_device_descriptor *udesc;\r\nint error, i, j;\r\n__u16 bcdDevice, rev_maj, rev_min;\r\nif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\r\nreturn -1;\r\nfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\r\nif (hid->product == lg4ff_devices[i].product_id) {\r\ndbg_hid("Found compatible device, product ID %04X\n", lg4ff_devices[i].product_id);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(lg4ff_devices)) {\r\nhid_err(hid, "Device is not supported by lg4ff driver. If you think it should be, consider reporting a bug to"\r\n"LKML, Simon Wood <simon@mungewell.org> or Michal Maly <madcatxster@gmail.com>\n");\r\nreturn -1;\r\n}\r\nudesc = &(hid_to_usb_dev(hid)->descriptor);\r\nif (!udesc) {\r\nhid_err(hid, "NULL USB device descriptor\n");\r\nreturn -1;\r\n}\r\nbcdDevice = le16_to_cpu(udesc->bcdDevice);\r\nrev_maj = bcdDevice >> 8;\r\nrev_min = bcdDevice & 0xff;\r\nif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_WHEEL) {\r\ndbg_hid("Generic wheel detected, can it do native?\n");\r\ndbg_hid("USB revision: %2x.%02x\n", rev_maj, rev_min);\r\nfor (j = 0; j < ARRAY_SIZE(lg4ff_revs); j++) {\r\nif (lg4ff_revs[j].rev_maj == rev_maj && lg4ff_revs[j].rev_min == rev_min) {\r\nhid_lg4ff_switch_native(hid, lg4ff_revs[j].command);\r\nhid_info(hid, "Switched to native mode\n");\r\n}\r\n}\r\n}\r\nfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\r\nset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\r\nerror = input_ff_create_memless(dev, NULL, hid_lg4ff_play);\r\nif (error)\r\nreturn error;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Cannot add device, private driver data not allocated\n");\r\nreturn -1;\r\n}\r\nentry = kzalloc(sizeof(struct lg4ff_device_entry), GFP_KERNEL);\r\nif (!entry) {\r\nhid_err(hid, "Cannot add device, insufficient memory to allocate device properties.\n");\r\nreturn -ENOMEM;\r\n}\r\ndrv_data->device_props = entry;\r\nentry->product_id = lg4ff_devices[i].product_id;\r\nentry->min_range = lg4ff_devices[i].min_range;\r\nentry->max_range = lg4ff_devices[i].max_range;\r\nentry->set_range = lg4ff_devices[i].set_range;\r\nif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\r\nif (rev_maj == FFEX_REV_MAJ && rev_min == FFEX_REV_MIN)\r\ndev->ff->set_autocenter = hid_lg4ff_set_autocenter_ffex;\r\nelse\r\ndev->ff->set_autocenter = hid_lg4ff_set_autocenter_default;\r\ndev->ff->set_autocenter(dev, 0);\r\n}\r\nerror = device_create_file(&hid->dev, &dev_attr_range);\r\nif (error)\r\nreturn error;\r\ndbg_hid("sysfs interface created\n");\r\nentry->range = entry->max_range;\r\nif (entry->set_range != NULL)\r\nentry->set_range(hid, entry->range);\r\n#ifdef CONFIG_LEDS_CLASS\r\nentry->led_state = 0;\r\nfor (j = 0; j < 5; j++)\r\nentry->led[j] = NULL;\r\nif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL) {\r\nstruct led_classdev *led;\r\nsize_t name_sz;\r\nchar *name;\r\nlg4ff_set_leds(hid, 0);\r\nname_sz = strlen(dev_name(&hid->dev)) + 8;\r\nfor (j = 0; j < 5; j++) {\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hid, "can't allocate memory for LED %d\n", j);\r\ngoto err;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "%s::RPM%d", dev_name(&hid->dev), j+1);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = lg4ff_led_get_brightness;\r\nled->brightness_set = lg4ff_led_set_brightness;\r\nentry->led[j] = led;\r\nerror = led_classdev_register(&hid->dev, led);\r\nif (error) {\r\nhid_err(hid, "failed to register LED %d. Aborting.\n", j);\r\nerr:\r\nfor (j = 0; j < 5; j++) {\r\nled = entry->led[j];\r\nentry->led[j] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\n#endif\r\nhid_info(hid, "Force feedback support for Logitech Gaming Wheels\n");\r\nreturn 0;\r\n}\r\nint lg4ff_deinit(struct hid_device *hid)\r\n{\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\ndevice_remove_file(&hid->dev, &dev_attr_range);\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Error while deinitializing device, no private driver data.\n");\r\nreturn -1;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Error while deinitializing device, no device properties data.\n");\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_LEDS_CLASS\r\n{\r\nint j;\r\nstruct led_classdev *led;\r\nfor (j = 0; j < 5; j++) {\r\nled = entry->led[j];\r\nentry->led[j] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\n#endif\r\nkfree(entry);\r\ndbg_hid("Device successfully unregistered\n");\r\nreturn 0;\r\n}
