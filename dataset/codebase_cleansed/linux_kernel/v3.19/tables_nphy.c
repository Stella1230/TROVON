static inline void assert_ntab_array_sizes(void)\r\n{\r\n#undef check\r\n#define check(table, size) \\r\nBUILD_BUG_ON(ARRAY_SIZE(b43_ntab_##table) != B43_NTAB_##size##_SIZE)\r\ncheck(adjustpower0, C0_ADJPLT);\r\ncheck(adjustpower1, C1_ADJPLT);\r\ncheck(bdi, BDI);\r\ncheck(channelest, CHANEST);\r\ncheck(estimatepowerlt0, C0_ESTPLT);\r\ncheck(estimatepowerlt1, C1_ESTPLT);\r\ncheck(framelookup, FRAMELT);\r\ncheck(framestruct, FRAMESTRUCT);\r\ncheck(gainctl0, C0_GAINCTL);\r\ncheck(gainctl1, C1_GAINCTL);\r\ncheck(intlevel, INTLEVEL);\r\ncheck(iqlt0, C0_IQLT);\r\ncheck(iqlt1, C1_IQLT);\r\ncheck(loftlt0, C0_LOFEEDTH);\r\ncheck(loftlt1, C1_LOFEEDTH);\r\ncheck(mcs, MCS);\r\ncheck(noisevar10, NOISEVAR10);\r\ncheck(noisevar11, NOISEVAR11);\r\ncheck(pilot, PILOT);\r\ncheck(pilotlt, PILOTLT);\r\ncheck(tdi20a0, TDI20A0);\r\ncheck(tdi20a1, TDI20A1);\r\ncheck(tdi40a0, TDI40A0);\r\ncheck(tdi40a1, TDI40A1);\r\ncheck(tdtrn, TDTRN);\r\ncheck(tmap, TMAP);\r\n#undef check\r\n}\r\nu32 b43_ntab_read(struct b43_wldev *dev, u32 offset)\r\n{\r\nu32 type, value;\r\ntype = offset & B43_NTAB_TYPEMASK;\r\noffset &= ~B43_NTAB_TYPEMASK;\r\nB43_WARN_ON(offset > 0xFFFF);\r\nswitch (type) {\r\ncase B43_NTAB_8BIT:\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nvalue = b43_phy_read(dev, B43_NPHY_TABLE_DATALO) & 0xFF;\r\nbreak;\r\ncase B43_NTAB_16BIT:\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nvalue = b43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\nbreak;\r\ncase B43_NTAB_32BIT:\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nvalue = b43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\nvalue |= b43_phy_read(dev, B43_NPHY_TABLE_DATAHI) << 16;\r\nbreak;\r\ndefault:\r\nB43_WARN_ON(1);\r\nvalue = 0;\r\n}\r\nreturn value;\r\n}\r\nvoid b43_ntab_read_bulk(struct b43_wldev *dev, u32 offset,\r\nunsigned int nr_elements, void *_data)\r\n{\r\nu32 type;\r\nu8 *data = _data;\r\nunsigned int i;\r\ntype = offset & B43_NTAB_TYPEMASK;\r\noffset &= ~B43_NTAB_TYPEMASK;\r\nB43_WARN_ON(offset > 0xFFFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nfor (i = 0; i < nr_elements; i++) {\r\nif (dev->dev->chip_id == 43224 && dev->dev->chip_rev == 1) {\r\nb43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset + i);\r\n}\r\nswitch (type) {\r\ncase B43_NTAB_8BIT:\r\n*data = b43_phy_read(dev, B43_NPHY_TABLE_DATALO) & 0xFF;\r\ndata++;\r\nbreak;\r\ncase B43_NTAB_16BIT:\r\n*((u16 *)data) = b43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\ndata += 2;\r\nbreak;\r\ncase B43_NTAB_32BIT:\r\n*((u32 *)data) =\r\nb43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\n*((u32 *)data) |=\r\nb43_phy_read(dev, B43_NPHY_TABLE_DATAHI) << 16;\r\ndata += 4;\r\nbreak;\r\ndefault:\r\nB43_WARN_ON(1);\r\n}\r\n}\r\n}\r\nvoid b43_ntab_write(struct b43_wldev *dev, u32 offset, u32 value)\r\n{\r\nu32 type;\r\ntype = offset & B43_NTAB_TYPEMASK;\r\noffset &= 0xFFFF;\r\nswitch (type) {\r\ncase B43_NTAB_8BIT:\r\nB43_WARN_ON(value & ~0xFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);\r\nbreak;\r\ncase B43_NTAB_16BIT:\r\nB43_WARN_ON(value & ~0xFFFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);\r\nbreak;\r\ncase B43_NTAB_32BIT:\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATAHI, value >> 16);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO, value & 0xFFFF);\r\nbreak;\r\ndefault:\r\nB43_WARN_ON(1);\r\n}\r\nreturn;\r\nassert_ntab_array_sizes();\r\n}\r\nvoid b43_ntab_write_bulk(struct b43_wldev *dev, u32 offset,\r\nunsigned int nr_elements, const void *_data)\r\n{\r\nu32 type, value;\r\nconst u8 *data = _data;\r\nunsigned int i;\r\ntype = offset & B43_NTAB_TYPEMASK;\r\noffset &= ~B43_NTAB_TYPEMASK;\r\nB43_WARN_ON(offset > 0xFFFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);\r\nfor (i = 0; i < nr_elements; i++) {\r\nif ((offset >> 10) == 9 && dev->dev->chip_id == 43224 &&\r\ndev->dev->chip_rev == 1) {\r\nb43_phy_read(dev, B43_NPHY_TABLE_DATALO);\r\nb43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset + i);\r\n}\r\nswitch (type) {\r\ncase B43_NTAB_8BIT:\r\nvalue = *data;\r\ndata++;\r\nB43_WARN_ON(value & ~0xFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);\r\nbreak;\r\ncase B43_NTAB_16BIT:\r\nvalue = *((u16 *)data);\r\ndata += 2;\r\nB43_WARN_ON(value & ~0xFFFF);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);\r\nbreak;\r\ncase B43_NTAB_32BIT:\r\nvalue = *((u32 *)data);\r\ndata += 4;\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATAHI, value >> 16);\r\nb43_phy_write(dev, B43_NPHY_TABLE_DATALO,\r\nvalue & 0xFFFF);\r\nbreak;\r\ndefault:\r\nB43_WARN_ON(1);\r\n}\r\n}\r\n}\r\nstatic void b43_nphy_tables_init_shared_lut(struct b43_wldev *dev)\r\n{\r\nntab_upload(dev, B43_NTAB_C0_ESTPLT_R3, b43_ntab_estimatepowerlt0_r3);\r\nntab_upload(dev, B43_NTAB_C1_ESTPLT_R3, b43_ntab_estimatepowerlt1_r3);\r\nntab_upload(dev, B43_NTAB_C0_ADJPLT_R3, b43_ntab_adjustpower0_r3);\r\nntab_upload(dev, B43_NTAB_C1_ADJPLT_R3, b43_ntab_adjustpower1_r3);\r\nntab_upload(dev, B43_NTAB_C0_GAINCTL_R3, b43_ntab_gainctl0_r3);\r\nntab_upload(dev, B43_NTAB_C1_GAINCTL_R3, b43_ntab_gainctl1_r3);\r\nntab_upload(dev, B43_NTAB_C0_IQLT_R3, b43_ntab_iqlt0_r3);\r\nntab_upload(dev, B43_NTAB_C1_IQLT_R3, b43_ntab_iqlt1_r3);\r\nntab_upload(dev, B43_NTAB_C0_LOFEEDTH_R3, b43_ntab_loftlt0_r3);\r\nntab_upload(dev, B43_NTAB_C1_LOFEEDTH_R3, b43_ntab_loftlt1_r3);\r\n}\r\nstatic void b43_nphy_tables_init_rev7_volatile(struct b43_wldev *dev)\r\n{\r\nstruct ssb_sprom *sprom = dev->dev->bus_sprom;\r\nu8 antswlut;\r\nint core, offset, i;\r\nconst int antswlut0_offsets[] = { 0, 4, 8, };\r\nconst u8 antswlut0_values[][3] = {\r\n{ 0x2, 0x12, 0x8 },\r\n{ 0x2, 0x18, 0x2 },\r\n};\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)\r\nantswlut = sprom->fem.ghz5.antswlut;\r\nelse\r\nantswlut = sprom->fem.ghz2.antswlut;\r\nswitch (antswlut) {\r\ncase 0:\r\nfor (core = 0; core < 2; core++) {\r\nfor (i = 0; i < ARRAY_SIZE(antswlut0_values[0]); i++) {\r\noffset = core ? 0x20 : 0x00;\r\noffset += antswlut0_offsets[i];\r\nb43_ntab_write(dev, B43_NTAB8(9, offset),\r\nantswlut0_values[core][i]);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nb43err(dev->wl, "Unsupported antswlut: %d\n", antswlut);\r\nbreak;\r\n}\r\n}\r\nstatic void b43_nphy_tables_init_rev16(struct b43_wldev *dev)\r\n{\r\nif (dev->phy.do_full_init) {\r\nntab_upload(dev, B43_NTAB_NOISEVAR_R7, b43_ntab_noisevar_r7);\r\nb43_nphy_tables_init_shared_lut(dev);\r\n}\r\nb43_nphy_tables_init_rev7_volatile(dev);\r\n}\r\nstatic void b43_nphy_tables_init_rev7(struct b43_wldev *dev)\r\n{\r\nif (dev->phy.do_full_init) {\r\nntab_upload(dev, B43_NTAB_FRAMESTRUCT_R3, b43_ntab_framestruct_r3);\r\nntab_upload(dev, B43_NTAB_PILOT_R3, b43_ntab_pilot_r3);\r\nntab_upload(dev, B43_NTAB_TMAP_R7, b43_ntab_tmap_r7);\r\nntab_upload(dev, B43_NTAB_INTLEVEL_R3, b43_ntab_intlevel_r3);\r\nntab_upload(dev, B43_NTAB_TDTRN_R3, b43_ntab_tdtrn_r3);\r\nntab_upload(dev, B43_NTAB_NOISEVAR_R7, b43_ntab_noisevar_r7);\r\nntab_upload(dev, B43_NTAB_MCS_R3, b43_ntab_mcs_r3);\r\nntab_upload(dev, B43_NTAB_TDI20A0_R3, b43_ntab_tdi20a0_r3);\r\nntab_upload(dev, B43_NTAB_TDI20A1_R3, b43_ntab_tdi20a1_r3);\r\nntab_upload(dev, B43_NTAB_TDI40A0_R3, b43_ntab_tdi40a0_r3);\r\nntab_upload(dev, B43_NTAB_TDI40A1_R3, b43_ntab_tdi40a1_r3);\r\nntab_upload(dev, B43_NTAB_PILOTLT_R3, b43_ntab_pilotlt_r3);\r\nntab_upload(dev, B43_NTAB_CHANEST_R3, b43_ntab_channelest_r3);\r\nntab_upload(dev, B43_NTAB_FRAMELT_R3, b43_ntab_framelookup_r3);\r\nb43_nphy_tables_init_shared_lut(dev);\r\n}\r\nb43_nphy_tables_init_rev7_volatile(dev);\r\n}\r\nstatic void b43_nphy_tables_init_rev3(struct b43_wldev *dev)\r\n{\r\nstruct ssb_sprom *sprom = dev->dev->bus_sprom;\r\nu8 antswlut;\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)\r\nantswlut = sprom->fem.ghz5.antswlut;\r\nelse\r\nantswlut = sprom->fem.ghz2.antswlut;\r\nif (dev->phy.do_full_init) {\r\nntab_upload(dev, B43_NTAB_FRAMESTRUCT_R3, b43_ntab_framestruct_r3);\r\nntab_upload(dev, B43_NTAB_PILOT_R3, b43_ntab_pilot_r3);\r\nntab_upload(dev, B43_NTAB_TMAP_R3, b43_ntab_tmap_r3);\r\nntab_upload(dev, B43_NTAB_INTLEVEL_R3, b43_ntab_intlevel_r3);\r\nntab_upload(dev, B43_NTAB_TDTRN_R3, b43_ntab_tdtrn_r3);\r\nntab_upload(dev, B43_NTAB_NOISEVAR_R3, b43_ntab_noisevar_r3);\r\nntab_upload(dev, B43_NTAB_MCS_R3, b43_ntab_mcs_r3);\r\nntab_upload(dev, B43_NTAB_TDI20A0_R3, b43_ntab_tdi20a0_r3);\r\nntab_upload(dev, B43_NTAB_TDI20A1_R3, b43_ntab_tdi20a1_r3);\r\nntab_upload(dev, B43_NTAB_TDI40A0_R3, b43_ntab_tdi40a0_r3);\r\nntab_upload(dev, B43_NTAB_TDI40A1_R3, b43_ntab_tdi40a1_r3);\r\nntab_upload(dev, B43_NTAB_PILOTLT_R3, b43_ntab_pilotlt_r3);\r\nntab_upload(dev, B43_NTAB_CHANEST_R3, b43_ntab_channelest_r3);\r\nntab_upload(dev, B43_NTAB_FRAMELT_R3, b43_ntab_framelookup_r3);\r\nb43_nphy_tables_init_shared_lut(dev);\r\n}\r\nif (antswlut < ARRAY_SIZE(b43_ntab_antswctl_r3))\r\nntab_upload(dev, B43_NTAB_ANT_SW_CTL_R3,\r\nb43_ntab_antswctl_r3[antswlut]);\r\nelse\r\nB43_WARN_ON(1);\r\n}\r\nstatic void b43_nphy_tables_init_rev0(struct b43_wldev *dev)\r\n{\r\nif (dev->phy.do_full_init) {\r\nntab_upload(dev, B43_NTAB_FRAMESTRUCT, b43_ntab_framestruct);\r\nntab_upload(dev, B43_NTAB_FRAMELT, b43_ntab_framelookup);\r\nntab_upload(dev, B43_NTAB_TMAP, b43_ntab_tmap);\r\nntab_upload(dev, B43_NTAB_TDTRN, b43_ntab_tdtrn);\r\nntab_upload(dev, B43_NTAB_INTLEVEL, b43_ntab_intlevel);\r\nntab_upload(dev, B43_NTAB_PILOT, b43_ntab_pilot);\r\nntab_upload(dev, B43_NTAB_TDI20A0, b43_ntab_tdi20a0);\r\nntab_upload(dev, B43_NTAB_TDI20A1, b43_ntab_tdi20a1);\r\nntab_upload(dev, B43_NTAB_TDI40A0, b43_ntab_tdi40a0);\r\nntab_upload(dev, B43_NTAB_TDI40A1, b43_ntab_tdi40a1);\r\nntab_upload(dev, B43_NTAB_CHANEST, b43_ntab_channelest);\r\nntab_upload(dev, B43_NTAB_MCS, b43_ntab_mcs);\r\nntab_upload(dev, B43_NTAB_NOISEVAR10, b43_ntab_noisevar10);\r\nntab_upload(dev, B43_NTAB_NOISEVAR11, b43_ntab_noisevar11);\r\n}\r\nntab_upload(dev, B43_NTAB_BDI, b43_ntab_bdi);\r\nntab_upload(dev, B43_NTAB_PILOTLT, b43_ntab_pilotlt);\r\nntab_upload(dev, B43_NTAB_C0_GAINCTL, b43_ntab_gainctl0);\r\nntab_upload(dev, B43_NTAB_C1_GAINCTL, b43_ntab_gainctl1);\r\nntab_upload(dev, B43_NTAB_C0_ESTPLT, b43_ntab_estimatepowerlt0);\r\nntab_upload(dev, B43_NTAB_C1_ESTPLT, b43_ntab_estimatepowerlt1);\r\nntab_upload(dev, B43_NTAB_C0_ADJPLT, b43_ntab_adjustpower0);\r\nntab_upload(dev, B43_NTAB_C1_ADJPLT, b43_ntab_adjustpower1);\r\nntab_upload(dev, B43_NTAB_C0_IQLT, b43_ntab_iqlt0);\r\nntab_upload(dev, B43_NTAB_C1_IQLT, b43_ntab_iqlt1);\r\nntab_upload(dev, B43_NTAB_C0_LOFEEDTH, b43_ntab_loftlt0);\r\nntab_upload(dev, B43_NTAB_C1_LOFEEDTH, b43_ntab_loftlt1);\r\n}\r\nvoid b43_nphy_tables_init(struct b43_wldev *dev)\r\n{\r\nif (dev->phy.rev >= 16)\r\nb43_nphy_tables_init_rev16(dev);\r\nelse if (dev->phy.rev >= 7)\r\nb43_nphy_tables_init_rev7(dev);\r\nelse if (dev->phy.rev >= 3)\r\nb43_nphy_tables_init_rev3(dev);\r\nelse\r\nb43_nphy_tables_init_rev0(dev);\r\n}\r\nstatic const u32 *b43_nphy_get_ipa_gain_table(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {\r\nswitch (phy->rev) {\r\ncase 17:\r\nif (phy->radio_rev == 14)\r\nreturn b43_ntab_tx_gain_ipa_2057_rev14_2g;\r\nbreak;\r\ncase 16:\r\nif (phy->radio_rev == 9)\r\nreturn b43_ntab_tx_gain_ipa_2057_rev9_2g;\r\nbreak;\r\ncase 8:\r\nif (phy->radio_rev == 5)\r\nreturn b43_ntab_tx_gain_ipa_2057_rev5_2g;\r\nbreak;\r\ncase 6:\r\nif (dev->dev->chip_id == BCMA_CHIP_ID_BCM47162)\r\nreturn b43_ntab_tx_gain_ipa_rev5_2g;\r\nreturn b43_ntab_tx_gain_ipa_rev6_2g;\r\ncase 5:\r\nreturn b43_ntab_tx_gain_ipa_rev5_2g;\r\ncase 4:\r\ncase 3:\r\nreturn b43_ntab_tx_gain_ipa_rev3_2g;\r\n}\r\nb43err(dev->wl,\r\n"No 2GHz IPA gain table available for this device\n");\r\nreturn NULL;\r\n} else {\r\nswitch (phy->rev) {\r\ncase 16:\r\nif (phy->radio_rev == 9)\r\nreturn b43_ntab_tx_gain_ipa_2057_rev9_5g;\r\nbreak;\r\ncase 3 ... 6:\r\nreturn b43_ntab_tx_gain_ipa_rev3_5g;\r\n}\r\nb43err(dev->wl,\r\n"No 5GHz IPA gain table available for this device\n");\r\nreturn NULL;\r\n}\r\n}\r\nconst u32 *b43_nphy_get_tx_gain_table(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nenum ieee80211_band band = b43_current_band(dev->wl);\r\nstruct ssb_sprom *sprom = dev->dev->bus_sprom;\r\nif (dev->phy.rev < 3)\r\nreturn b43_ntab_tx_gain_rev0_1_2;\r\nif ((dev->phy.n->ipa2g_on && band == IEEE80211_BAND_2GHZ) ||\r\n(dev->phy.n->ipa5g_on && band == IEEE80211_BAND_5GHZ)) {\r\nreturn b43_nphy_get_ipa_gain_table(dev);\r\n} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) {\r\nswitch (phy->rev) {\r\ncase 6:\r\ncase 5:\r\nreturn b43_ntab_tx_gain_epa_rev5_5g;\r\ncase 4:\r\nreturn sprom->fem.ghz5.extpa_gain == 3 ?\r\nb43_ntab_tx_gain_epa_rev4_5g :\r\nb43_ntab_tx_gain_epa_rev4_hi_pwr_5g;\r\ncase 3:\r\nreturn b43_ntab_tx_gain_epa_rev3_5g;\r\ndefault:\r\nb43err(dev->wl,\r\n"No 5GHz EPA gain table available for this device\n");\r\nreturn NULL;\r\n}\r\n} else {\r\nswitch (phy->rev) {\r\ncase 6:\r\ncase 5:\r\nif (sprom->fem.ghz5.extpa_gain == 3)\r\nreturn b43_ntab_tx_gain_epa_rev3_hi_pwr_2g;\r\ncase 4:\r\ncase 3:\r\nreturn b43_ntab_tx_gain_epa_rev3_2g;\r\ndefault:\r\nb43err(dev->wl,\r\n"No 2GHz EPA gain table available for this device\n");\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nconst s16 *b43_ntab_get_rf_pwr_offset_table(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {\r\nswitch (phy->rev) {\r\ncase 17:\r\nif (phy->radio_rev == 14)\r\nreturn b43_ntab_rf_pwr_offset_2057_rev14_2g;\r\nbreak;\r\ncase 16:\r\nif (phy->radio_rev == 9)\r\nreturn b43_ntab_rf_pwr_offset_2057_rev9_2g;\r\nbreak;\r\n}\r\nb43err(dev->wl,\r\n"No 2GHz RF power table available for this device\n");\r\nreturn NULL;\r\n} else {\r\nswitch (phy->rev) {\r\ncase 16:\r\nif (phy->radio_rev == 9)\r\nreturn b43_ntab_rf_pwr_offset_2057_rev9_5g;\r\nbreak;\r\n}\r\nb43err(dev->wl,\r\n"No 5GHz RF power table available for this device\n");\r\nreturn NULL;\r\n}\r\n}\r\nstruct nphy_gain_ctl_workaround_entry *b43_nphy_get_gain_ctl_workaround_ent(\r\nstruct b43_wldev *dev, bool ghz5, bool ext_lna)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct nphy_gain_ctl_workaround_entry *e;\r\nu8 phy_idx;\r\nif (!ghz5 && dev->phy.rev >= 6 && dev->phy.radio_rev == 11)\r\nreturn &nphy_gain_ctl_wa_phy6_radio11_ghz2;\r\nB43_WARN_ON(dev->phy.rev < 3);\r\nif (dev->phy.rev >= 6)\r\nphy_idx = 3;\r\nelse if (dev->phy.rev == 5)\r\nphy_idx = 2;\r\nelse if (dev->phy.rev == 4)\r\nphy_idx = 1;\r\nelse\r\nphy_idx = 0;\r\ne = &nphy_gain_ctl_workaround[ghz5][phy_idx];\r\nif (!ghz5) {\r\nu8 tr_iso = dev->dev->bus_sprom->fem.ghz2.tr_iso;\r\nif (tr_iso > 7)\r\ntr_iso = 3;\r\nif (phy->rev >= 6) {\r\nstatic const int gain_data[] = { 0x106a, 0x106c, 0x1074,\r\n0x107c, 0x007e, 0x107e,\r\n0x207e, 0x307e, };\r\ne->cliplo_gain = gain_data[tr_iso];\r\n} else if (phy->rev == 5) {\r\nstatic const int gain_data[] = { 0x0062, 0x0064, 0x006a,\r\n0x106a, 0x106c, 0x1074,\r\n0x107c, 0x207c, };\r\ne->cliplo_gain = gain_data[tr_iso];\r\n}\r\nif (phy->rev >= 5 && ext_lna) {\r\ne->rfseq_init[0] &= ~0x4000;\r\ne->rfseq_init[1] &= ~0x4000;\r\ne->rfseq_init[2] &= ~0x4000;\r\ne->rfseq_init[3] &= ~0x4000;\r\ne->init_gain &= ~0x4000;\r\n}\r\n} else {\r\nif (phy->rev >= 6) {\r\nif (phy->radio_rev == 11 && !b43_is_40mhz(dev))\r\ne->crsminu = 0x2d;\r\n} else if (phy->rev == 4 && ext_lna) {\r\ne->rfseq_init[0] &= ~0x4000;\r\ne->rfseq_init[1] &= ~0x4000;\r\ne->rfseq_init[2] &= ~0x4000;\r\ne->rfseq_init[3] &= ~0x4000;\r\ne->init_gain &= ~0x4000;\r\ne->rfseq_init[0] |= 0x1000;\r\ne->rfseq_init[1] |= 0x1000;\r\ne->rfseq_init[2] |= 0x1000;\r\ne->rfseq_init[3] |= 0x1000;\r\ne->init_gain |= 0x1000;\r\n}\r\n}\r\nreturn e;\r\n}\r\nconst struct nphy_rf_control_override_rev7 *b43_nphy_get_rf_ctl_over_rev7(\r\nstruct b43_wldev *dev, u16 field, u8 override)\r\n{\r\nconst struct nphy_rf_control_override_rev7 *e;\r\nu8 size, i;\r\nswitch (override) {\r\ncase 0:\r\ne = tbl_rf_control_override_rev7_over0;\r\nsize = ARRAY_SIZE(tbl_rf_control_override_rev7_over0);\r\nbreak;\r\ncase 1:\r\ne = tbl_rf_control_override_rev7_over1;\r\nsize = ARRAY_SIZE(tbl_rf_control_override_rev7_over1);\r\nbreak;\r\ncase 2:\r\ne = tbl_rf_control_override_rev7_over2;\r\nsize = ARRAY_SIZE(tbl_rf_control_override_rev7_over2);\r\nbreak;\r\ndefault:\r\nb43err(dev->wl, "Invalid override value %d\n", override);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (e[i].field == field)\r\nreturn &e[i];\r\n}\r\nreturn NULL;\r\n}
