static void query_edid(struct via_aux_drv *drv)\r\n{\r\nstruct fb_monspecs *spec = drv->data;\r\nunsigned char edid[EDID_LENGTH];\r\nbool valid = false;\r\nif (spec) {\r\nfb_destroy_modedb(spec->modedb);\r\n} else {\r\nspec = kmalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn;\r\n}\r\nspec->version = spec->revision = 0;\r\nif (via_aux_read(drv, 0x00, edid, EDID_LENGTH)) {\r\nfb_edid_to_monspecs(edid, spec);\r\nvalid = spec->version || spec->revision;\r\n}\r\nif (!valid) {\r\nkfree(spec);\r\nspec = NULL;\r\n} else\r\nprintk(KERN_DEBUG "EDID: %s %s\n", spec->manufacturer, spec->monitor);\r\ndrv->data = spec;\r\n}\r\nstatic const struct fb_videomode *get_preferred_mode(struct via_aux_drv *drv)\r\n{\r\nstruct fb_monspecs *spec = drv->data;\r\nint i;\r\nif (!spec || !spec->modedb || !(spec->misc & FB_MISC_1ST_DETAIL))\r\nreturn NULL;\r\nfor (i = 0; i < spec->modedb_len; i++) {\r\nif (spec->modedb[i].flag & FB_MODE_IS_FIRST &&\r\nspec->modedb[i].flag & FB_MODE_IS_DETAILED)\r\nreturn &spec->modedb[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void cleanup(struct via_aux_drv *drv)\r\n{\r\nstruct fb_monspecs *spec = drv->data;\r\nif (spec)\r\nfb_destroy_modedb(spec->modedb);\r\n}\r\nvoid via_aux_edid_probe(struct via_aux_bus *bus)\r\n{\r\nstruct via_aux_drv drv = {\r\n.bus = bus,\r\n.addr = 0x50,\r\n.name = name,\r\n.cleanup = cleanup,\r\n.get_preferred_mode = get_preferred_mode};\r\nquery_edid(&drv);\r\nvia_aux_add(&drv);\r\n}
