static struct clk * __init\r\nrz_cpg_register_clock(struct device_node *np, struct rz_cpg *cpg, const char *name)\r\n{\r\nu32 val;\r\nunsigned mult;\r\nstatic const unsigned frqcr_tab[4] = { 3, 2, 0, 1 };\r\nif (strcmp(name, "pll") == 0) {\r\nunsigned cpg_mode = 0;\r\nconst char *parent_name = of_clk_get_parent_name(np, cpg_mode);\r\nmult = cpg_mode ? (32 / 4) : 30;\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, 0, mult, 1);\r\n}\r\nif (!cpg->reg)\r\nreturn ERR_PTR(-ENXIO);\r\nif (strcmp(name, "i") == 0)\r\nval = (clk_readl(cpg->reg + CPG_FRQCR) >> 8) & 3;\r\nelse if (strcmp(name, "g") == 0)\r\nval = clk_readl(cpg->reg + CPG_FRQCR2) & 3;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\nmult = frqcr_tab[val];\r\nreturn clk_register_fixed_factor(NULL, name, "pll", 0, mult, 3);\r\n}\r\nstatic void __init rz_cpg_clocks_init(struct device_node *np)\r\n{\r\nstruct rz_cpg *cpg;\r\nstruct clk **clks;\r\nunsigned i;\r\nint num_clks;\r\nnum_clks = of_property_count_strings(np, "clock-output-names");\r\nif (WARN(num_clks <= 0, "can't count CPG clocks\n"))\r\nreturn;\r\ncpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\r\nclks = kzalloc(num_clks * sizeof(*clks), GFP_KERNEL);\r\nBUG_ON(!cpg || !clks);\r\ncpg->data.clks = clks;\r\ncpg->data.clk_num = num_clks;\r\ncpg->reg = of_iomap(np, 0);\r\nfor (i = 0; i < num_clks; ++i) {\r\nconst char *name;\r\nstruct clk *clk;\r\nof_property_read_string_index(np, "clock-output-names", i, &name);\r\nclk = rz_cpg_register_clock(np, cpg, name);\r\nif (IS_ERR(clk))\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clk));\r\nelse\r\ncpg->data.clks[i] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\r\n}
