static const char *hname_tail(const char *hname)\r\n{\r\nchar *split;\r\nhname = strim((char *)hname);\r\nfor (split = strstr(hname, "//"); split; split = strstr(hname, "//"))\r\nhname = split + 2;\r\nreturn hname;\r\n}\r\nstatic bool policy_init(struct aa_policy *policy, const char *prefix,\r\nconst char *name)\r\n{\r\nif (prefix) {\r\npolicy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,\r\nGFP_KERNEL);\r\nif (policy->hname)\r\nsprintf(policy->hname, "%s//%s", prefix, name);\r\n} else\r\npolicy->hname = kstrdup(name, GFP_KERNEL);\r\nif (!policy->hname)\r\nreturn 0;\r\npolicy->name = (char *)hname_tail(policy->hname);\r\nINIT_LIST_HEAD(&policy->list);\r\nINIT_LIST_HEAD(&policy->profiles);\r\nreturn 1;\r\n}\r\nstatic void policy_destroy(struct aa_policy *policy)\r\n{\r\nif (on_list_rcu(&policy->profiles)) {\r\nAA_ERROR("%s: internal error, "\r\n"policy '%s' still contains profiles\n",\r\n__func__, policy->name);\r\nBUG();\r\n}\r\nif (on_list_rcu(&policy->list)) {\r\nAA_ERROR("%s: internal error, policy '%s' still on list\n",\r\n__func__, policy->name);\r\nBUG();\r\n}\r\nkzfree(policy->hname);\r\n}\r\nstatic struct aa_policy *__policy_find(struct list_head *head, const char *name)\r\n{\r\nstruct aa_policy *policy;\r\nlist_for_each_entry_rcu(policy, head, list) {\r\nif (!strcmp(policy->name, name))\r\nreturn policy;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct aa_policy *__policy_strn_find(struct list_head *head,\r\nconst char *str, int len)\r\n{\r\nstruct aa_policy *policy;\r\nlist_for_each_entry_rcu(policy, head, list) {\r\nif (aa_strneq(policy->name, str, len))\r\nreturn policy;\r\n}\r\nreturn NULL;\r\n}\r\nbool aa_ns_visible(struct aa_namespace *curr, struct aa_namespace *view)\r\n{\r\nif (curr == view)\r\nreturn true;\r\nfor ( ; view; view = view->parent) {\r\nif (view->parent == curr)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nconst char *aa_ns_name(struct aa_namespace *curr, struct aa_namespace *view)\r\n{\r\nif (curr == view)\r\nreturn "";\r\nif (aa_ns_visible(curr, view)) {\r\nreturn view->base.hname + strlen(curr->base.hname) + 2;\r\n} else\r\nreturn hidden_ns_name;\r\n}\r\nstatic struct aa_namespace *alloc_namespace(const char *prefix,\r\nconst char *name)\r\n{\r\nstruct aa_namespace *ns;\r\nns = kzalloc(sizeof(*ns), GFP_KERNEL);\r\nAA_DEBUG("%s(%p)\n", __func__, ns);\r\nif (!ns)\r\nreturn NULL;\r\nif (!policy_init(&ns->base, prefix, name))\r\ngoto fail_ns;\r\nINIT_LIST_HEAD(&ns->sub_ns);\r\nmutex_init(&ns->lock);\r\nns->unconfined = aa_alloc_profile("unconfined");\r\nif (!ns->unconfined)\r\ngoto fail_unconfined;\r\nns->unconfined->flags = PFLAG_IX_ON_NAME_ERROR |\r\nPFLAG_IMMUTABLE | PFLAG_NS_COUNT;\r\nns->unconfined->mode = APPARMOR_UNCONFINED;\r\nns->unconfined->ns = ns;\r\natomic_set(&ns->uniq_null, 0);\r\nreturn ns;\r\nfail_unconfined:\r\nkzfree(ns->base.hname);\r\nfail_ns:\r\nkzfree(ns);\r\nreturn NULL;\r\n}\r\nstatic void free_namespace(struct aa_namespace *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\npolicy_destroy(&ns->base);\r\naa_put_namespace(ns->parent);\r\nns->unconfined->ns = NULL;\r\naa_free_profile(ns->unconfined);\r\nkzfree(ns);\r\n}\r\nstatic struct aa_namespace *__aa_find_namespace(struct list_head *head,\r\nconst char *name)\r\n{\r\nreturn (struct aa_namespace *)__policy_find(head, name);\r\n}\r\nstruct aa_namespace *aa_find_namespace(struct aa_namespace *root,\r\nconst char *name)\r\n{\r\nstruct aa_namespace *ns = NULL;\r\nrcu_read_lock();\r\nns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));\r\nrcu_read_unlock();\r\nreturn ns;\r\n}\r\nstatic struct aa_namespace *aa_prepare_namespace(const char *name)\r\n{\r\nstruct aa_namespace *ns, *root;\r\nroot = aa_current_profile()->ns;\r\nmutex_lock(&root->lock);\r\nif (!name) {\r\nns = aa_get_namespace(root);\r\ngoto out;\r\n}\r\nns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));\r\nif (!ns) {\r\nns = alloc_namespace(root->base.hname, name);\r\nif (!ns)\r\ngoto out;\r\nif (__aa_fs_namespace_mkdir(ns, ns_subns_dir(root), name)) {\r\nAA_ERROR("Failed to create interface for ns %s\n",\r\nns->base.name);\r\nfree_namespace(ns);\r\nns = NULL;\r\ngoto out;\r\n}\r\nns->parent = aa_get_namespace(root);\r\nlist_add_rcu(&ns->base.list, &root->sub_ns);\r\naa_get_namespace(ns);\r\n}\r\nout:\r\nmutex_unlock(&root->lock);\r\nreturn ns;\r\n}\r\nstatic void __list_add_profile(struct list_head *list,\r\nstruct aa_profile *profile)\r\n{\r\nlist_add_rcu(&profile->base.list, list);\r\naa_get_profile(profile);\r\n}\r\nstatic void __list_remove_profile(struct aa_profile *profile)\r\n{\r\nlist_del_rcu(&profile->base.list);\r\naa_put_profile(profile);\r\n}\r\nstatic void __remove_profile(struct aa_profile *profile)\r\n{\r\n__profile_list_release(&profile->base.profiles);\r\n__aa_update_replacedby(profile, profile->ns->unconfined);\r\n__aa_fs_profile_rmdir(profile);\r\n__list_remove_profile(profile);\r\n}\r\nstatic void __profile_list_release(struct list_head *head)\r\n{\r\nstruct aa_profile *profile, *tmp;\r\nlist_for_each_entry_safe(profile, tmp, head, base.list)\r\n__remove_profile(profile);\r\n}\r\nstatic void destroy_namespace(struct aa_namespace *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\nmutex_lock(&ns->lock);\r\n__profile_list_release(&ns->base.profiles);\r\n__ns_list_release(&ns->sub_ns);\r\nif (ns->parent)\r\n__aa_update_replacedby(ns->unconfined, ns->parent->unconfined);\r\n__aa_fs_namespace_rmdir(ns);\r\nmutex_unlock(&ns->lock);\r\n}\r\nstatic void __remove_namespace(struct aa_namespace *ns)\r\n{\r\nlist_del_rcu(&ns->base.list);\r\ndestroy_namespace(ns);\r\naa_put_namespace(ns);\r\n}\r\nstatic void __ns_list_release(struct list_head *head)\r\n{\r\nstruct aa_namespace *ns, *tmp;\r\nlist_for_each_entry_safe(ns, tmp, head, base.list)\r\n__remove_namespace(ns);\r\n}\r\nint __init aa_alloc_root_ns(void)\r\n{\r\nroot_ns = alloc_namespace(NULL, "root");\r\nif (!root_ns)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid __init aa_free_root_ns(void)\r\n{\r\nstruct aa_namespace *ns = root_ns;\r\nroot_ns = NULL;\r\ndestroy_namespace(ns);\r\naa_put_namespace(ns);\r\n}\r\nstatic void free_replacedby(struct aa_replacedby *r)\r\n{\r\nif (r) {\r\naa_put_profile(rcu_dereference_protected(r->profile, true));\r\nkzfree(r);\r\n}\r\n}\r\nvoid aa_free_replacedby_kref(struct kref *kref)\r\n{\r\nstruct aa_replacedby *r = container_of(kref, struct aa_replacedby,\r\ncount);\r\nfree_replacedby(r);\r\n}\r\nvoid aa_free_profile(struct aa_profile *profile)\r\n{\r\nAA_DEBUG("%s(%p)\n", __func__, profile);\r\nif (!profile)\r\nreturn;\r\npolicy_destroy(&profile->base);\r\naa_put_profile(rcu_access_pointer(profile->parent));\r\naa_put_namespace(profile->ns);\r\nkzfree(profile->rename);\r\naa_free_file_rules(&profile->file);\r\naa_free_cap_rules(&profile->caps);\r\naa_free_rlimit_rules(&profile->rlimits);\r\nkzfree(profile->dirname);\r\naa_put_dfa(profile->xmatch);\r\naa_put_dfa(profile->policy.dfa);\r\naa_put_replacedby(profile->replacedby);\r\nkzfree(profile->hash);\r\nkzfree(profile);\r\n}\r\nstatic void aa_free_profile_rcu(struct rcu_head *head)\r\n{\r\nstruct aa_profile *p = container_of(head, struct aa_profile, rcu);\r\nif (p->flags & PFLAG_NS_COUNT)\r\nfree_namespace(p->ns);\r\nelse\r\naa_free_profile(p);\r\n}\r\nvoid aa_free_profile_kref(struct kref *kref)\r\n{\r\nstruct aa_profile *p = container_of(kref, struct aa_profile, count);\r\ncall_rcu(&p->rcu, aa_free_profile_rcu);\r\n}\r\nstruct aa_profile *aa_alloc_profile(const char *hname)\r\n{\r\nstruct aa_profile *profile;\r\nprofile = kzalloc(sizeof(*profile), GFP_KERNEL);\r\nif (!profile)\r\nreturn NULL;\r\nprofile->replacedby = kzalloc(sizeof(struct aa_replacedby), GFP_KERNEL);\r\nif (!profile->replacedby)\r\ngoto fail;\r\nkref_init(&profile->replacedby->count);\r\nif (!policy_init(&profile->base, NULL, hname))\r\ngoto fail;\r\nkref_init(&profile->count);\r\nreturn profile;\r\nfail:\r\nkzfree(profile->replacedby);\r\nkzfree(profile);\r\nreturn NULL;\r\n}\r\nstruct aa_profile *aa_new_null_profile(struct aa_profile *parent, int hat)\r\n{\r\nstruct aa_profile *profile = NULL;\r\nchar *name;\r\nint uniq = atomic_inc_return(&parent->ns->uniq_null);\r\nname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, GFP_KERNEL);\r\nif (!name)\r\ngoto fail;\r\nsprintf(name, "%s//null-%x", parent->base.hname, uniq);\r\nprofile = aa_alloc_profile(name);\r\nkfree(name);\r\nif (!profile)\r\ngoto fail;\r\nprofile->mode = APPARMOR_COMPLAIN;\r\nprofile->flags = PFLAG_NULL;\r\nif (hat)\r\nprofile->flags |= PFLAG_HAT;\r\nrcu_assign_pointer(profile->parent, aa_get_profile(parent));\r\nprofile->ns = aa_get_namespace(parent->ns);\r\nmutex_lock(&profile->ns->lock);\r\n__list_add_profile(&parent->base.profiles, profile);\r\nmutex_unlock(&profile->ns->lock);\r\nreturn profile;\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic struct aa_profile *__find_child(struct list_head *head, const char *name)\r\n{\r\nreturn (struct aa_profile *)__policy_find(head, name);\r\n}\r\nstatic struct aa_profile *__strn_find_child(struct list_head *head,\r\nconst char *name, int len)\r\n{\r\nreturn (struct aa_profile *)__policy_strn_find(head, name, len);\r\n}\r\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\r\n{\r\nstruct aa_profile *profile;\r\nrcu_read_lock();\r\nprofile = aa_get_profile(__find_child(&parent->base.profiles, name));\r\nrcu_read_unlock();\r\nreturn profile;\r\n}\r\nstatic struct aa_policy *__lookup_parent(struct aa_namespace *ns,\r\nconst char *hname)\r\n{\r\nstruct aa_policy *policy;\r\nstruct aa_profile *profile = NULL;\r\nchar *split;\r\npolicy = &ns->base;\r\nfor (split = strstr(hname, "//"); split;) {\r\nprofile = __strn_find_child(&policy->profiles, hname,\r\nsplit - hname);\r\nif (!profile)\r\nreturn NULL;\r\npolicy = &profile->base;\r\nhname = split + 2;\r\nsplit = strstr(hname, "//");\r\n}\r\nif (!profile)\r\nreturn &ns->base;\r\nreturn &profile->base;\r\n}\r\nstatic struct aa_profile *__lookup_profile(struct aa_policy *base,\r\nconst char *hname)\r\n{\r\nstruct aa_profile *profile = NULL;\r\nchar *split;\r\nfor (split = strstr(hname, "//"); split;) {\r\nprofile = __strn_find_child(&base->profiles, hname,\r\nsplit - hname);\r\nif (!profile)\r\nreturn NULL;\r\nbase = &profile->base;\r\nhname = split + 2;\r\nsplit = strstr(hname, "//");\r\n}\r\nprofile = __find_child(&base->profiles, hname);\r\nreturn profile;\r\n}\r\nstruct aa_profile *aa_lookup_profile(struct aa_namespace *ns, const char *hname)\r\n{\r\nstruct aa_profile *profile;\r\nrcu_read_lock();\r\ndo {\r\nprofile = __lookup_profile(&ns->base, hname);\r\n} while (profile && !aa_get_profile_not0(profile));\r\nrcu_read_unlock();\r\nif (!profile && strcmp(hname, "unconfined") == 0)\r\nprofile = aa_get_newest_profile(ns->unconfined);\r\nreturn profile;\r\n}\r\nstatic int replacement_allowed(struct aa_profile *profile, int noreplace,\r\nconst char **info)\r\n{\r\nif (profile) {\r\nif (profile->flags & PFLAG_IMMUTABLE) {\r\n*info = "cannot replace immutible profile";\r\nreturn -EPERM;\r\n} else if (noreplace) {\r\n*info = "profile already exists";\r\nreturn -EEXIST;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int audit_policy(int op, gfp_t gfp, const char *name, const char *info,\r\nint error)\r\n{\r\nstruct common_audit_data sa;\r\nstruct apparmor_audit_data aad = {0,};\r\nsa.type = LSM_AUDIT_DATA_NONE;\r\nsa.aad = &aad;\r\naad.op = op;\r\naad.name = name;\r\naad.info = info;\r\naad.error = error;\r\nreturn aa_audit(AUDIT_APPARMOR_STATUS, __aa_current_profile(), gfp,\r\n&sa, NULL);\r\n}\r\nbool aa_may_manage_policy(int op)\r\n{\r\nif (aa_g_lock_policy) {\r\naudit_policy(op, GFP_KERNEL, NULL, "policy_locked", -EACCES);\r\nreturn 0;\r\n}\r\nif (!capable(CAP_MAC_ADMIN)) {\r\naudit_policy(op, GFP_KERNEL, NULL, "not policy admin", -EACCES);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct aa_profile *__list_lookup_parent(struct list_head *lh,\r\nstruct aa_profile *profile)\r\n{\r\nconst char *base = hname_tail(profile->base.hname);\r\nlong len = base - profile->base.hname;\r\nstruct aa_load_ent *ent;\r\nif (len <= 2)\r\nreturn NULL;\r\nlen -= 2;\r\nlist_for_each_entry(ent, lh, list) {\r\nif (ent->new == profile)\r\ncontinue;\r\nif (strncmp(ent->new->base.hname, profile->base.hname, len) ==\r\n0 && ent->new->base.hname[len] == 0)\r\nreturn ent->new;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __replace_profile(struct aa_profile *old, struct aa_profile *new,\r\nbool share_replacedby)\r\n{\r\nstruct aa_profile *child, *tmp;\r\nif (!list_empty(&old->base.profiles)) {\r\nLIST_HEAD(lh);\r\nlist_splice_init_rcu(&old->base.profiles, &lh, synchronize_rcu);\r\nlist_for_each_entry_safe(child, tmp, &lh, base.list) {\r\nstruct aa_profile *p;\r\nlist_del_init(&child->base.list);\r\np = __find_child(&new->base.profiles, child->base.name);\r\nif (p) {\r\n__replace_profile(child, p, share_replacedby);\r\ncontinue;\r\n}\r\np = aa_deref_parent(child);\r\nrcu_assign_pointer(child->parent, aa_get_profile(new));\r\nlist_add_rcu(&child->base.list, &new->base.profiles);\r\naa_put_profile(p);\r\n}\r\n}\r\nif (!rcu_access_pointer(new->parent)) {\r\nstruct aa_profile *parent = aa_deref_parent(old);\r\nrcu_assign_pointer(new->parent, aa_get_profile(parent));\r\n}\r\n__aa_update_replacedby(old, new);\r\nif (share_replacedby) {\r\naa_put_replacedby(new->replacedby);\r\nnew->replacedby = aa_get_replacedby(old->replacedby);\r\n} else if (!rcu_access_pointer(new->replacedby->profile))\r\nrcu_assign_pointer(new->replacedby->profile,\r\naa_get_profile(new));\r\n__aa_fs_profile_migrate_dents(old, new);\r\nif (list_empty(&new->base.list)) {\r\nlist_replace_rcu(&old->base.list, &new->base.list);\r\naa_get_profile(new);\r\naa_put_profile(old);\r\n} else\r\n__list_remove_profile(old);\r\n}\r\nstatic int __lookup_replace(struct aa_namespace *ns, const char *hname,\r\nbool noreplace, struct aa_profile **p,\r\nconst char **info)\r\n{\r\n*p = aa_get_profile(__lookup_profile(&ns->base, hname));\r\nif (*p) {\r\nint error = replacement_allowed(*p, noreplace, info);\r\nif (error) {\r\n*info = "profile can not be replaced";\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nssize_t aa_replace_profiles(void *udata, size_t size, bool noreplace)\r\n{\r\nconst char *ns_name, *name = NULL, *info = NULL;\r\nstruct aa_namespace *ns = NULL;\r\nstruct aa_load_ent *ent, *tmp;\r\nint op = OP_PROF_REPL;\r\nssize_t error;\r\nLIST_HEAD(lh);\r\nerror = aa_unpack(udata, size, &lh, &ns_name);\r\nif (error)\r\ngoto out;\r\nns = aa_prepare_namespace(ns_name);\r\nif (!ns) {\r\ninfo = "failed to prepare namespace";\r\nerror = -ENOMEM;\r\nname = ns_name;\r\ngoto fail;\r\n}\r\nmutex_lock(&ns->lock);\r\nlist_for_each_entry(ent, &lh, list) {\r\nstruct aa_policy *policy;\r\nname = ent->new->base.hname;\r\nerror = __lookup_replace(ns, ent->new->base.hname, noreplace,\r\n&ent->old, &info);\r\nif (error)\r\ngoto fail_lock;\r\nif (ent->new->rename) {\r\nerror = __lookup_replace(ns, ent->new->rename,\r\nnoreplace, &ent->rename,\r\n&info);\r\nif (error)\r\ngoto fail_lock;\r\n}\r\nent->new->ns = aa_get_namespace(ns);\r\nif (ent->old || ent->rename)\r\ncontinue;\r\npolicy = __lookup_parent(ns, ent->new->base.hname);\r\nif (!policy) {\r\nstruct aa_profile *p;\r\np = __list_lookup_parent(&lh, ent->new);\r\nif (!p) {\r\nerror = -ENOENT;\r\ninfo = "parent does not exist";\r\nname = ent->new->base.hname;\r\ngoto fail_lock;\r\n}\r\nrcu_assign_pointer(ent->new->parent, aa_get_profile(p));\r\n} else if (policy != &ns->base) {\r\nstruct aa_profile *p = (struct aa_profile *) policy;\r\nrcu_assign_pointer(ent->new->parent, aa_get_profile(p));\r\n}\r\n}\r\nlist_for_each_entry(ent, &lh, list) {\r\nif (ent->old) {\r\n} else {\r\nstruct dentry *parent;\r\nif (rcu_access_pointer(ent->new->parent)) {\r\nstruct aa_profile *p;\r\np = aa_deref_parent(ent->new);\r\nparent = prof_child_dir(p);\r\n} else\r\nparent = ns_subprofs_dir(ent->new->ns);\r\nerror = __aa_fs_profile_mkdir(ent->new, parent);\r\n}\r\nif (error) {\r\ninfo = "failed to create ";\r\ngoto fail_lock;\r\n}\r\n}\r\nlist_for_each_entry_safe(ent, tmp, &lh, list) {\r\nlist_del_init(&ent->list);\r\nop = (!ent->old && !ent->rename) ? OP_PROF_LOAD : OP_PROF_REPL;\r\naudit_policy(op, GFP_ATOMIC, ent->new->base.name, NULL, error);\r\nif (ent->old) {\r\n__replace_profile(ent->old, ent->new, 1);\r\nif (ent->rename) {\r\nstruct aa_replacedby *r = ent->new->replacedby;\r\nrcu_assign_pointer(r->profile,\r\naa_get_profile(ent->new));\r\n__replace_profile(ent->rename, ent->new, 0);\r\n}\r\n} else if (ent->rename) {\r\nrcu_assign_pointer(ent->new->replacedby->profile,\r\naa_get_profile(ent->new));\r\n__replace_profile(ent->rename, ent->new, 0);\r\n} else if (ent->new->parent) {\r\nstruct aa_profile *parent, *newest;\r\nparent = aa_deref_parent(ent->new);\r\nnewest = aa_get_newest_profile(parent);\r\nif (newest != parent) {\r\naa_get_profile(newest);\r\naa_put_profile(parent);\r\nrcu_assign_pointer(ent->new->parent, newest);\r\n} else\r\naa_put_profile(newest);\r\nrcu_assign_pointer(ent->new->replacedby->profile,\r\naa_get_profile(ent->new));\r\n__list_add_profile(&parent->base.profiles, ent->new);\r\n} else {\r\nrcu_assign_pointer(ent->new->replacedby->profile,\r\naa_get_profile(ent->new));\r\n__list_add_profile(&ns->base.profiles, ent->new);\r\n}\r\naa_load_ent_free(ent);\r\n}\r\nmutex_unlock(&ns->lock);\r\nout:\r\naa_put_namespace(ns);\r\nif (error)\r\nreturn error;\r\nreturn size;\r\nfail_lock:\r\nmutex_unlock(&ns->lock);\r\nfail:\r\nerror = audit_policy(op, GFP_KERNEL, name, info, error);\r\nlist_for_each_entry_safe(ent, tmp, &lh, list) {\r\nlist_del_init(&ent->list);\r\naa_load_ent_free(ent);\r\n}\r\ngoto out;\r\n}\r\nssize_t aa_remove_profiles(char *fqname, size_t size)\r\n{\r\nstruct aa_namespace *root, *ns = NULL;\r\nstruct aa_profile *profile = NULL;\r\nconst char *name = fqname, *info = NULL;\r\nssize_t error = 0;\r\nif (*fqname == 0) {\r\ninfo = "no profile specified";\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\nroot = aa_current_profile()->ns;\r\nif (fqname[0] == ':') {\r\nchar *ns_name;\r\nname = aa_split_fqname(fqname, &ns_name);\r\nns = aa_find_namespace(root, ns_name);\r\nif (!ns) {\r\ninfo = "namespace does not exist";\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\n} else\r\nns = aa_get_namespace(root);\r\nif (!name) {\r\nmutex_lock(&ns->parent->lock);\r\n__remove_namespace(ns);\r\nmutex_unlock(&ns->parent->lock);\r\n} else {\r\nmutex_lock(&ns->lock);\r\nprofile = aa_get_profile(__lookup_profile(&ns->base, name));\r\nif (!profile) {\r\nerror = -ENOENT;\r\ninfo = "profile does not exist";\r\ngoto fail_ns_lock;\r\n}\r\nname = profile->base.hname;\r\n__remove_profile(profile);\r\nmutex_unlock(&ns->lock);\r\n}\r\n(void) audit_policy(OP_PROF_RM, GFP_KERNEL, name, info, error);\r\naa_put_namespace(ns);\r\naa_put_profile(profile);\r\nreturn size;\r\nfail_ns_lock:\r\nmutex_unlock(&ns->lock);\r\naa_put_namespace(ns);\r\nfail:\r\n(void) audit_policy(OP_PROF_RM, GFP_KERNEL, name, info, error);\r\nreturn error;\r\n}
