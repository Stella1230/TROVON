static __inline__ int NCR53c406a_dma_setup(unsigned char *ptr, unsigned int count, unsigned char mode)\r\n{\r\nunsigned limit;\r\nunsigned long flags = 0;\r\nVDEB(printk("dma: before count=%d ", count));\r\nif (dma_chan <= 3) {\r\nif (count > 65536)\r\ncount = 65536;\r\nlimit = 65536 - (((unsigned) ptr) & 0xFFFF);\r\n} else {\r\nif (count > (65536 << 1))\r\ncount = (65536 << 1);\r\nlimit = (65536 << 1) - (((unsigned) ptr) & 0x1FFFF);\r\n}\r\nif (count > limit)\r\ncount = limit;\r\nVDEB(printk("after count=%d\n", count));\r\nif ((count & 1) || (((unsigned) ptr) & 1))\r\npanic("NCR53c406a: attempted unaligned DMA transfer\n");\r\nflags = claim_dma_lock();\r\ndisable_dma(dma_chan);\r\nclear_dma_ff(dma_chan);\r\nset_dma_addr(dma_chan, (long) ptr);\r\nset_dma_count(dma_chan, count);\r\nset_dma_mode(dma_chan, mode);\r\nenable_dma(dma_chan);\r\nrelease_dma_lock(flags);\r\nreturn count;\r\n}\r\nstatic __inline__ int NCR53c406a_dma_write(unsigned char *src, unsigned int count)\r\n{\r\nreturn NCR53c406a_dma_setup(src, count, DMA_MODE_WRITE);\r\n}\r\nstatic __inline__ int NCR53c406a_dma_read(unsigned char *src, unsigned int count)\r\n{\r\nreturn NCR53c406a_dma_setup(src, count, DMA_MODE_READ);\r\n}\r\nstatic __inline__ int NCR53c406a_dma_residual(void)\r\n{\r\nregister int tmp;\r\nunsigned long flags;\r\nflags = claim_dma_lock();\r\nclear_dma_ff(dma_chan);\r\ntmp = get_dma_residue(dma_chan);\r\nrelease_dma_lock(flags);\r\nreturn tmp;\r\n}\r\nstatic __inline__ int NCR53c406a_pio_read(unsigned char *request, unsigned int reqlen)\r\n{\r\nint i;\r\nint len;\r\nREG1;\r\nwhile (reqlen) {\r\ni = inb(PIO_STATUS);\r\nif (i & 0x80)\r\nreturn 0;\r\nswitch (i & 0x1e) {\r\ndefault:\r\ncase 0x10:\r\nlen = 0;\r\nbreak;\r\ncase 0x0:\r\nlen = 1;\r\nbreak;\r\ncase 0x8:\r\nlen = 42;\r\nbreak;\r\ncase 0xc:\r\nlen = 84;\r\nbreak;\r\ncase 0xe:\r\nlen = 128;\r\nbreak;\r\n}\r\nif ((i & 0x40) && len == 0) {\r\nreturn 0;\r\n}\r\nif (len) {\r\nif (len > reqlen)\r\nlen = reqlen;\r\nif (fast_pio && len > 3) {\r\ninsl(PIO_FIFO, request, len >> 2);\r\nrequest += len & 0xfc;\r\nreqlen -= len & 0xfc;\r\n} else {\r\nwhile (len--) {\r\n*request++ = inb(PIO_FIFO);\r\nreqlen--;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ int NCR53c406a_pio_write(unsigned char *request, unsigned int reqlen)\r\n{\r\nint i = 0;\r\nint len;\r\nREG1;\r\nwhile (reqlen && !(i & 0x40)) {\r\ni = inb(PIO_STATUS);\r\nif (i & 0x80)\r\nreturn 0;\r\nswitch (i & 0x1e) {\r\ncase 0x10:\r\nlen = 128;\r\nbreak;\r\ncase 0x0:\r\nlen = 84;\r\nbreak;\r\ncase 0x8:\r\nlen = 42;\r\nbreak;\r\ncase 0xc:\r\nlen = 1;\r\nbreak;\r\ndefault:\r\ncase 0xe:\r\nlen = 0;\r\nbreak;\r\n}\r\nif (len) {\r\nif (len > reqlen)\r\nlen = reqlen;\r\nif (fast_pio && len > 3) {\r\noutsl(PIO_FIFO, request, len >> 2);\r\nrequest += len & 0xfc;\r\nreqlen -= len & 0xfc;\r\n} else {\r\nwhile (len--) {\r\noutb(*request++, PIO_FIFO);\r\nreqlen--;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init NCR53c406a_detect(struct scsi_host_template * tpnt)\r\n{\r\nint present = 0;\r\nstruct Scsi_Host *shpnt = NULL;\r\n#ifndef PORT_BASE\r\nint i;\r\n#endif\r\n#if USE_BIOS\r\nint ii, jj;\r\nbios_base = 0;\r\nfor (ii = 0; ii < ADDRESS_COUNT && !bios_base; ii++)\r\nfor (jj = 0; (jj < SIGNATURE_COUNT) && !bios_base; jj++)\r\nif (!memcmp((void *) addresses[ii] + signatures[jj].sig_offset, (void *) signatures[jj].signature, (int) signatures[jj].sig_length))\r\nbios_base = addresses[ii];\r\nif (!bios_base) {\r\nprintk("NCR53c406a: BIOS signature not found\n");\r\nreturn 0;\r\n}\r\nDEB(printk("NCR53c406a BIOS found at 0x%x\n", (unsigned int) bios_base);\r\n);\r\n#endif\r\n#ifdef PORT_BASE\r\nif (!request_region(port_base, 0x10, "NCR53c406a"))\r\nport_base = 0;\r\n#else\r\nif (port_base) {\r\nif (!request_region(port_base, 0x10, "NCR53c406a"))\r\nport_base = 0;\r\n} else {\r\nfor (i = 0; i < PORT_COUNT && !port_base; i++) {\r\nif (!request_region(ports[i], 0x10, "NCR53c406a")) {\r\nDEB(printk("NCR53c406a: port 0x%x in use\n", ports[i]));\r\n} else {\r\nVDEB(printk("NCR53c406a: port 0x%x available\n", ports[i]));\r\noutb(C5_IMG, ports[i] + 0x0d);\r\nif ((inb(ports[i] + 0x0e) ^ inb(ports[i] + 0x0e)) == 7 && (inb(ports[i] + 0x0e) ^ inb(ports[i] + 0x0e)) == 7 && (inb(ports[i] + 0x0e) & 0xf8) == 0x58) {\r\nport_base = ports[i];\r\nVDEB(printk("NCR53c406a: Sig register valid\n"));\r\nVDEB(printk("port_base=0x%x\n", port_base));\r\nbreak;\r\n}\r\nrelease_region(ports[i], 0x10);\r\n}\r\n}\r\n}\r\n#endif\r\nif (!port_base) {\r\nprintk("NCR53c406a: no available ports found\n");\r\nreturn 0;\r\n}\r\nDEB(printk("NCR53c406a detected\n"));\r\ncalc_port_addr();\r\nchip_init();\r\n#ifndef IRQ_LEV\r\nif (irq_level < 0) {\r\nirq_level = irq_probe();\r\nif (irq_level < 0) {\r\nprintk("NCR53c406a: IRQ problem, irq_level=%d, giving up\n", irq_level);\r\ngoto err_release;\r\n}\r\n}\r\n#endif\r\nDEB(printk("NCR53c406a: using port_base 0x%x\n", port_base));\r\npresent = 1;\r\ntpnt->proc_name = "NCR53c406a";\r\nshpnt = scsi_register(tpnt, 0);\r\nif (!shpnt) {\r\nprintk("NCR53c406a: Unable to register host, giving up.\n");\r\ngoto err_release;\r\n}\r\nif (irq_level > 0) {\r\nif (request_irq(irq_level, do_NCR53c406a_intr, 0, "NCR53c406a", shpnt)) {\r\nprintk("NCR53c406a: unable to allocate IRQ %d\n", irq_level);\r\ngoto err_free_scsi;\r\n}\r\ntpnt->can_queue = 1;\r\nDEB(printk("NCR53c406a: allocated IRQ %d\n", irq_level));\r\n} else if (irq_level == 0) {\r\ntpnt->can_queue = 0;\r\nDEB(printk("NCR53c406a: No interrupts detected\n"));\r\nprintk("NCR53c406a driver no longer supports polling interface\n");\r\nprintk("Please email linux-scsi@vger.kernel.org\n");\r\n#if USE_DMA\r\nprintk("NCR53c406a: No interrupts found and DMA mode defined. Giving up.\n");\r\n#endif\r\ngoto err_free_scsi;\r\n} else {\r\nDEB(printk("NCR53c406a: Shouldn't get here!\n"));\r\ngoto err_free_scsi;\r\n}\r\n#if USE_DMA\r\ndma_chan = DMA_CHAN;\r\nif (request_dma(dma_chan, "NCR53c406a") != 0) {\r\nprintk("NCR53c406a: unable to allocate DMA channel %d\n", dma_chan);\r\ngoto err_free_irq;\r\n}\r\nDEB(printk("Allocated DMA channel %d\n", dma_chan));\r\n#endif\r\nshpnt->irq = irq_level;\r\nshpnt->io_port = port_base;\r\nshpnt->n_io_port = 0x10;\r\n#if USE_DMA\r\nshpnt->dma = dma_chan;\r\n#endif\r\n#if USE_DMA\r\nsprintf(info_msg, "NCR53c406a at 0x%x, IRQ %d, DMA channel %d.", port_base, irq_level, dma_chan);\r\n#else\r\nsprintf(info_msg, "NCR53c406a at 0x%x, IRQ %d, %s PIO mode.", port_base, irq_level, fast_pio ? "fast" : "slow");\r\n#endif\r\nreturn (present);\r\n#if USE_DMA\r\nerr_free_irq:\r\nif (irq_level)\r\nfree_irq(irq_level, shpnt);\r\n#endif\r\nerr_free_scsi:\r\nscsi_unregister(shpnt);\r\nerr_release:\r\nrelease_region(port_base, 0x10);\r\nreturn 0;\r\n}\r\nstatic int NCR53c406a_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, NULL);\r\n#if USE_DMA\r\nif (shost->dma_channel != 0xff)\r\nfree_dma(shost->dma_channel);\r\n#endif\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}\r\nstatic int __init NCR53c406a_setup(char *str)\r\n{\r\nstatic size_t setup_idx = 0;\r\nsize_t i;\r\nint ints[4];\r\nDEB(printk("NCR53c406a: Setup called\n");\r\n);\r\nif (setup_idx >= PORT_COUNT - 1) {\r\nprintk("NCR53c406a: Setup called too many times. Bad LILO params?\n");\r\nreturn 0;\r\n}\r\nget_options(str, 4, ints);\r\nif (ints[0] < 1 || ints[0] > 3) {\r\nprintk("NCR53c406a: Malformed command line\n");\r\nprintk("NCR53c406a: Usage: ncr53c406a=<PORTBASE>[,<IRQ>[,<FASTPIO>]]\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < PORT_COUNT && !port_base; i++)\r\nif (ports[i] == ints[1]) {\r\nport_base = ints[1];\r\nDEB(printk("NCR53c406a: Specified port_base 0x%x\n", port_base);\r\n)\r\n}\r\nif (!port_base) {\r\nprintk("NCR53c406a: Invalid PORTBASE 0x%x specified\n", ints[1]);\r\nreturn 0;\r\n}\r\nif (ints[0] > 1) {\r\nif (ints[2] == 0) {\r\nirq_level = 0;\r\nDEB(printk("NCR53c406a: Specified irq %d\n", irq_level);\r\n)\r\n} else\r\nfor (i = 0; i < INTR_COUNT && irq_level < 0; i++)\r\nif (intrs[i] == ints[2]) {\r\nirq_level = ints[2];\r\nDEB(printk("NCR53c406a: Specified irq %d\n", port_base);\r\n)\r\n}\r\nif (irq_level < 0)\r\nprintk("NCR53c406a: Invalid IRQ %d specified\n", ints[2]);\r\n}\r\nif (ints[0] > 2)\r\nfast_pio = ints[3];\r\nDEB(printk("NCR53c406a: port_base=0x%x, irq=%d, fast_pio=%d\n", port_base, irq_level, fast_pio);)\r\nreturn 1;\r\n}\r\nstatic const char *NCR53c406a_info(struct Scsi_Host *SChost)\r\n{\r\nDEB(printk("NCR53c406a_info called\n"));\r\nreturn (info_msg);\r\n}\r\nstatic int NCR53c406a_queue_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))\r\n{\r\nint i;\r\nVDEB(printk("NCR53c406a_queue called\n"));\r\nDEB(printk("cmd=%02x, cmd_len=%02x, target=%02x, lun=%02x, bufflen=%d\n", SCpnt->cmnd[0], SCpnt->cmd_len, SCpnt->device->target, (u8)SCpnt->device->lun, scsi_bufflen(SCpnt)));\r\n#if 0\r\nVDEB(for (i = 0; i < SCpnt->cmd_len; i++)\r\nprintk("cmd[%d]=%02x ", i, SCpnt->cmnd[i]));\r\nVDEB(printk("\n"));\r\n#endif\r\ncurrent_SC = SCpnt;\r\ncurrent_SC->scsi_done = done;\r\ncurrent_SC->SCp.phase = command_ph;\r\ncurrent_SC->SCp.Status = 0;\r\ncurrent_SC->SCp.Message = 0;\r\nREG0;\r\noutb(scmd_id(SCpnt), DEST_ID);\r\noutb(FLUSH_FIFO, CMD_REG);\r\nfor (i = 0; i < SCpnt->cmd_len; i++) {\r\noutb(SCpnt->cmnd[i], SCSI_FIFO);\r\n}\r\noutb(SELECT_NO_ATN, CMD_REG);\r\nrtrc(1);\r\nreturn 0;\r\n}\r\nstatic int NCR53c406a_biosparm(struct scsi_device *disk,\r\nstruct block_device *dev,\r\nsector_t capacity, int *info_array)\r\n{\r\nint size;\r\nDEB(printk("NCR53c406a_biosparm called\n"));\r\nsize = capacity;\r\ninfo_array[0] = 64;\r\ninfo_array[1] = 32;\r\ninfo_array[2] = size >> 11;\r\nif (info_array[2] > 1024) {\r\ninfo_array[0] = 255;\r\ninfo_array[1] = 63;\r\ninfo_array[2] = size / (255 * 63);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t do_NCR53c406a_intr(int unused, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *dev = dev_id;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nNCR53c406a_intr(dev_id);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void NCR53c406a_intr(void *dev_id)\r\n{\r\nDEB(unsigned char fifo_size;\r\n)\r\nDEB(unsigned char seq_reg;\r\n)\r\nunsigned char status, int_reg;\r\n#if USE_PIO\r\nunsigned char pio_status;\r\nstruct scatterlist *sg;\r\nint i;\r\n#endif\r\nVDEB(printk("NCR53c406a_intr called\n"));\r\n#if USE_PIO\r\nREG1;\r\npio_status = inb(PIO_STATUS);\r\n#endif\r\nREG0;\r\nstatus = inb(STAT_REG);\r\nDEB(seq_reg = inb(SEQ_REG));\r\nint_reg = inb(INT_REG);\r\nDEB(fifo_size = inb(FIFO_FLAGS) & 0x1f);\r\n#if NCR53C406A_DEBUG\r\nprintk("status=%02x, seq_reg=%02x, int_reg=%02x, fifo_size=%02x", status, seq_reg, int_reg, fifo_size);\r\n#if (USE_DMA)\r\nprintk("\n");\r\n#else\r\nprintk(", pio=%02x\n", pio_status);\r\n#endif\r\n#endif\r\nif (int_reg & 0x80) {\r\nrtrc(3);\r\nDEB(printk("NCR53c406a: reset intr received\n"));\r\ncurrent_SC->SCp.phase = idle;\r\ncurrent_SC->result = DID_RESET << 16;\r\ncurrent_SC->scsi_done(current_SC);\r\nreturn;\r\n}\r\n#if USE_PIO\r\nif (pio_status & 0x80) {\r\nprintk("NCR53C406A: Warning: PIO error!\n");\r\ncurrent_SC->SCp.phase = idle;\r\ncurrent_SC->result = DID_ERROR << 16;\r\ncurrent_SC->scsi_done(current_SC);\r\nreturn;\r\n}\r\n#endif\r\nif (status & 0x20) {\r\nprintk("NCR53c406a: Warning: parity error!\n");\r\ncurrent_SC->SCp.phase = idle;\r\ncurrent_SC->result = DID_PARITY << 16;\r\ncurrent_SC->scsi_done(current_SC);\r\nreturn;\r\n}\r\nif (status & 0x40) {\r\nprintk("NCR53c406a: Warning: gross error!\n");\r\ncurrent_SC->SCp.phase = idle;\r\ncurrent_SC->result = DID_ERROR << 16;\r\ncurrent_SC->scsi_done(current_SC);\r\nreturn;\r\n}\r\nif (int_reg & 0x20) {\r\nDEB(printk("NCR53c406a: disconnect intr received\n"));\r\nif (current_SC->SCp.phase != message_in) {\r\ncurrent_SC->result = DID_NO_CONNECT << 16;\r\n} else {\r\ncurrent_SC->result = (current_SC->SCp.Status & 0xff)\r\n| ((current_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16);\r\n}\r\nrtrc(0);\r\ncurrent_SC->SCp.phase = idle;\r\ncurrent_SC->scsi_done(current_SC);\r\nreturn;\r\n}\r\nswitch (status & 0x07) {\r\ncase 0x00:\r\nif (int_reg & 0x10) {\r\nrtrc(5);\r\ncurrent_SC->SCp.phase = data_out;\r\nVDEB(printk("NCR53c406a: Data-Out phase\n"));\r\noutb(FLUSH_FIFO, CMD_REG);\r\nLOAD_DMA_COUNT(scsi_bufflen(current_SC));\r\n#if USE_DMA\r\nNCR53c406a_dma_write(scsi_sglist(current_SC),\r\nscsdi_bufflen(current_SC));\r\n#endif\r\noutb(TRANSFER_INFO | DMA_OP, CMD_REG);\r\n#if USE_PIO\r\nscsi_for_each_sg(current_SC, sg, scsi_sg_count(current_SC), i) {\r\nNCR53c406a_pio_write(sg_virt(sg), sg->length);\r\n}\r\nREG0;\r\n#endif\r\n}\r\nbreak;\r\ncase 0x01:\r\nif (int_reg & 0x10) {\r\nrtrc(6);\r\ncurrent_SC->SCp.phase = data_in;\r\nVDEB(printk("NCR53c406a: Data-In phase\n"));\r\noutb(FLUSH_FIFO, CMD_REG);\r\nLOAD_DMA_COUNT(scsi_bufflen(current_SC));\r\n#if USE_DMA\r\nNCR53c406a_dma_read(scsi_sglist(current_SC),\r\nscsdi_bufflen(current_SC));\r\n#endif\r\noutb(TRANSFER_INFO | DMA_OP, CMD_REG);\r\n#if USE_PIO\r\nscsi_for_each_sg(current_SC, sg, scsi_sg_count(current_SC), i) {\r\nNCR53c406a_pio_read(sg_virt(sg), sg->length);\r\n}\r\nREG0;\r\n#endif\r\n}\r\nbreak;\r\ncase 0x02:\r\ncurrent_SC->SCp.phase = command_ph;\r\nprintk("NCR53c406a: Warning: Unknown interrupt occurred in command phase!\n");\r\nbreak;\r\ncase 0x03:\r\nrtrc(7);\r\ncurrent_SC->SCp.phase = status_ph;\r\nVDEB(printk("NCR53c406a: Status phase\n"));\r\noutb(FLUSH_FIFO, CMD_REG);\r\noutb(INIT_CMD_COMPLETE, CMD_REG);\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\nprintk("NCR53c406a: WARNING: Reserved phase!!!\n");\r\nbreak;\r\ncase 0x06:\r\nDEB(printk("NCR53c406a: Message-Out phase\n"));\r\ncurrent_SC->SCp.phase = message_out;\r\noutb(SET_ATN, CMD_REG);\r\noutb(MSG_ACCEPT, CMD_REG);\r\nbreak;\r\ncase 0x07:\r\nrtrc(4);\r\nVDEB(printk("NCR53c406a: Message-In phase\n"));\r\ncurrent_SC->SCp.phase = message_in;\r\ncurrent_SC->SCp.Status = inb(SCSI_FIFO);\r\ncurrent_SC->SCp.Message = inb(SCSI_FIFO);\r\nVDEB(printk("SCSI FIFO size=%d\n", inb(FIFO_FLAGS) & 0x1f));\r\nDEB(printk("Status = %02x Message = %02x\n", current_SC->SCp.Status, current_SC->SCp.Message));\r\nif (current_SC->SCp.Message == SAVE_POINTERS || current_SC->SCp.Message == DISCONNECT) {\r\noutb(SET_ATN, CMD_REG);\r\nDEB(printk("Discarding SAVE_POINTERS message\n"));\r\n}\r\noutb(MSG_ACCEPT, CMD_REG);\r\nbreak;\r\n}\r\n}\r\nstatic int irq_probe(void)\r\n{\r\nint irqs, irq;\r\nunsigned long i;\r\ninb(INT_REG);\r\nirqs = probe_irq_on();\r\nREG0;\r\noutb(0xff, CMD_REG);\r\ni = jiffies + WATCHDOG;\r\nwhile (time_after(i, jiffies) && !(inb(STAT_REG) & 0x80))\r\nbarrier();\r\nif (time_before_eq(i, jiffies)) {\r\nprobe_irq_off(irqs);\r\nreturn -1;\r\n}\r\nirq = probe_irq_off(irqs);\r\noutb(CHIP_RESET, CMD_REG);\r\noutb(SCSI_NOP, CMD_REG);\r\nchip_init();\r\nreturn irq;\r\n}\r\nstatic void chip_init(void)\r\n{\r\nREG1;\r\n#if USE_DMA\r\noutb(0x00, PIO_STATUS);\r\n#else\r\noutb(0x01, PIO_STATUS);\r\n#endif\r\noutb(0x00, PIO_FLAG);\r\noutb(C4_IMG, CONFIG4);\r\noutb(C3_IMG, CONFIG3);\r\noutb(C2_IMG, CONFIG2);\r\noutb(C1_IMG, CONFIG1);\r\noutb(0x05, CLKCONV);\r\noutb(0x9C, SRTIMOUT);\r\noutb(0x05, SYNCPRD);\r\noutb(SYNC_MODE, SYNCOFF);\r\n}\r\nstatic void __init calc_port_addr(void)\r\n{\r\nTC_LSB = (port_base + 0x00);\r\nTC_MSB = (port_base + 0x01);\r\nSCSI_FIFO = (port_base + 0x02);\r\nCMD_REG = (port_base + 0x03);\r\nSTAT_REG = (port_base + 0x04);\r\nDEST_ID = (port_base + 0x04);\r\nINT_REG = (port_base + 0x05);\r\nSRTIMOUT = (port_base + 0x05);\r\nSEQ_REG = (port_base + 0x06);\r\nSYNCPRD = (port_base + 0x06);\r\nFIFO_FLAGS = (port_base + 0x07);\r\nSYNCOFF = (port_base + 0x07);\r\nCONFIG1 = (port_base + 0x08);\r\nCLKCONV = (port_base + 0x09);\r\nCONFIG2 = (port_base + 0x0B);\r\nCONFIG3 = (port_base + 0x0C);\r\nCONFIG4 = (port_base + 0x0D);\r\nTC_HIGH = (port_base + 0x0E);\r\nPIO_FIFO = (port_base + 0x04);\r\nPIO_STATUS = (port_base + 0x08);\r\nPIO_FLAG = (port_base + 0x0B);\r\nCONFIG5 = (port_base + 0x0D);\r\n}
