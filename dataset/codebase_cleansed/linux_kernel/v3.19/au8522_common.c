int au8522_writereg(struct au8522_state *state, u16 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { (reg >> 8) | 0x80, reg & 0xff, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = 0, .buf = buf, .len = 3 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk("%s: writereg error (reg == 0x%02x, val == 0x%04x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nu8 au8522_readreg(struct au8522_state *state, u16 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { (reg >> 8) | 0x40, reg & 0xff };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0,\r\n.buf = b0, .len = 2 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD,\r\n.buf = b1, .len = 1 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s: readreg error (ret == %i)\n",\r\n__func__, ret);\r\nreturn b1[0];\r\n}\r\nint au8522_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (state->operational_mode == AU8522_ANALOG_MODE) {\r\nreturn 0;\r\n}\r\nif (enable)\r\nreturn au8522_writereg(state, 0x106, 1);\r\nelse\r\nreturn au8522_writereg(state, 0x106, 0);\r\n}\r\nint au8522_analog_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (enable)\r\nreturn au8522_writereg(state, 0x106, 1);\r\nelse\r\nreturn au8522_writereg(state, 0x106, 0);\r\n}\r\nint au8522_get_state(struct au8522_state **state, struct i2c_adapter *i2c,\r\nu8 client_address)\r\n{\r\nint ret;\r\nmutex_lock(&au8522_list_mutex);\r\nret = hybrid_tuner_request_state(struct au8522_state, (*state),\r\nhybrid_tuner_instance_list,\r\ni2c, client_address, "au8522");\r\nmutex_unlock(&au8522_list_mutex);\r\nreturn ret;\r\n}\r\nvoid au8522_release_state(struct au8522_state *state)\r\n{\r\nmutex_lock(&au8522_list_mutex);\r\nif (state != NULL)\r\nhybrid_tuner_release_state(state);\r\nmutex_unlock(&au8522_list_mutex);\r\n}\r\nstatic int au8522_led_gpio_enable(struct au8522_state *state, int onoff)\r\n{\r\nstruct au8522_led_config *led_config = state->config->led_cfg;\r\nu8 val;\r\nif (!led_config || !led_config->gpio_output ||\r\n!led_config->gpio_output_enable || !led_config->gpio_output_disable)\r\nreturn 0;\r\nval = au8522_readreg(state, 0x4000 |\r\n(led_config->gpio_output & ~0xc000));\r\nif (onoff) {\r\nval &= ~((led_config->gpio_output_enable >> 8) & 0xff);\r\nval |= (led_config->gpio_output_enable & 0xff);\r\n} else {\r\nval &= ~((led_config->gpio_output_disable >> 8) & 0xff);\r\nval |= (led_config->gpio_output_disable & 0xff);\r\n}\r\nreturn au8522_writereg(state, 0x8000 |\r\n(led_config->gpio_output & ~0xc000), val);\r\n}\r\nint au8522_led_ctrl(struct au8522_state *state, int led)\r\n{\r\nstruct au8522_led_config *led_config = state->config->led_cfg;\r\nint i, ret = 0;\r\nif (!led_config || !led_config->gpio_leds ||\r\n!led_config->num_led_states || !led_config->led_states)\r\nreturn 0;\r\nif (led < 0) {\r\nif (state->led_state)\r\nreturn 0;\r\nelse\r\nled *= -1;\r\n}\r\nif (state->led_state != led) {\r\nu8 val;\r\ndprintk("%s: %d\n", __func__, led);\r\nau8522_led_gpio_enable(state, 1);\r\nval = au8522_readreg(state, 0x4000 |\r\n(led_config->gpio_leds & ~0xc000));\r\nfor (i = 0; i < led_config->num_led_states; i++)\r\nval &= ~led_config->led_states[i];\r\nif (led < led_config->num_led_states)\r\nval |= led_config->led_states[led];\r\nelse if (led_config->num_led_states)\r\nval |=\r\nled_config->led_states[led_config->num_led_states - 1];\r\nret = au8522_writereg(state, 0x8000 |\r\n(led_config->gpio_leds & ~0xc000), val);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->led_state = led;\r\nif (led == 0)\r\nau8522_led_gpio_enable(state, 0);\r\n}\r\nreturn 0;\r\n}\r\nint au8522_init(struct dvb_frontend *fe)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\nstate->operational_mode = AU8522_DIGITAL_MODE;\r\nstate->current_frequency = 0;\r\nau8522_writereg(state, 0xa4, 1 << 5);\r\nau8522_i2c_gate_ctrl(fe, 1);\r\nreturn 0;\r\n}\r\nint au8522_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\nif (state->operational_mode == AU8522_ANALOG_MODE) {\r\nreturn 0;\r\n}\r\nau8522_led_ctrl(state, 0);\r\nau8522_writereg(state, 0xa4, 1 << 5);\r\nstate->current_frequency = 0;\r\nreturn 0;\r\n}
