static int __net_init fib4_rules_init(struct net *net)\r\n{\r\nstruct fib_table *local_table, *main_table;\r\nlocal_table = fib_trie_table(RT_TABLE_LOCAL);\r\nif (local_table == NULL)\r\nreturn -ENOMEM;\r\nmain_table = fib_trie_table(RT_TABLE_MAIN);\r\nif (main_table == NULL)\r\ngoto fail;\r\nhlist_add_head_rcu(&local_table->tb_hlist,\r\n&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);\r\nhlist_add_head_rcu(&main_table->tb_hlist,\r\n&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);\r\nreturn 0;\r\nfail:\r\nkfree(local_table);\r\nreturn -ENOMEM;\r\n}\r\nstruct fib_table *fib_new_table(struct net *net, u32 id)\r\n{\r\nstruct fib_table *tb;\r\nunsigned int h;\r\nif (id == 0)\r\nid = RT_TABLE_MAIN;\r\ntb = fib_get_table(net, id);\r\nif (tb)\r\nreturn tb;\r\ntb = fib_trie_table(id);\r\nif (!tb)\r\nreturn NULL;\r\nswitch (id) {\r\ncase RT_TABLE_LOCAL:\r\nnet->ipv4.fib_local = tb;\r\nbreak;\r\ncase RT_TABLE_MAIN:\r\nnet->ipv4.fib_main = tb;\r\nbreak;\r\ncase RT_TABLE_DEFAULT:\r\nnet->ipv4.fib_default = tb;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nh = id & (FIB_TABLE_HASHSZ - 1);\r\nhlist_add_head_rcu(&tb->tb_hlist, &net->ipv4.fib_table_hash[h]);\r\nreturn tb;\r\n}\r\nstruct fib_table *fib_get_table(struct net *net, u32 id)\r\n{\r\nstruct fib_table *tb;\r\nstruct hlist_head *head;\r\nunsigned int h;\r\nif (id == 0)\r\nid = RT_TABLE_MAIN;\r\nh = id & (FIB_TABLE_HASHSZ - 1);\r\nrcu_read_lock();\r\nhead = &net->ipv4.fib_table_hash[h];\r\nhlist_for_each_entry_rcu(tb, head, tb_hlist) {\r\nif (tb->tb_id == id) {\r\nrcu_read_unlock();\r\nreturn tb;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void fib_flush(struct net *net)\r\n{\r\nint flushed = 0;\r\nstruct fib_table *tb;\r\nstruct hlist_head *head;\r\nunsigned int h;\r\nfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\r\nhead = &net->ipv4.fib_table_hash[h];\r\nhlist_for_each_entry(tb, head, tb_hlist)\r\nflushed += fib_table_flush(tb);\r\n}\r\nif (flushed)\r\nrt_cache_flush(net);\r\n}\r\nstatic inline unsigned int __inet_dev_addr_type(struct net *net,\r\nconst struct net_device *dev,\r\n__be32 addr)\r\n{\r\nstruct flowi4 fl4 = { .daddr = addr };\r\nstruct fib_result res;\r\nunsigned int ret = RTN_BROADCAST;\r\nstruct fib_table *local_table;\r\nif (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))\r\nreturn RTN_BROADCAST;\r\nif (ipv4_is_multicast(addr))\r\nreturn RTN_MULTICAST;\r\nlocal_table = fib_get_table(net, RT_TABLE_LOCAL);\r\nif (local_table) {\r\nret = RTN_UNICAST;\r\nrcu_read_lock();\r\nif (!fib_table_lookup(local_table, &fl4, &res, FIB_LOOKUP_NOREF)) {\r\nif (!dev || dev == res.fi->fib_dev)\r\nret = res.type;\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn ret;\r\n}\r\nunsigned int inet_addr_type(struct net *net, __be32 addr)\r\n{\r\nreturn __inet_dev_addr_type(net, NULL, addr);\r\n}\r\nunsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,\r\n__be32 addr)\r\n{\r\nreturn __inet_dev_addr_type(net, dev, addr);\r\n}\r\n__be32 fib_compute_spec_dst(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct in_device *in_dev;\r\nstruct fib_result res;\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nstruct net *net;\r\nint scope;\r\nrt = skb_rtable(skb);\r\nif ((rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST | RTCF_LOCAL)) ==\r\nRTCF_LOCAL)\r\nreturn ip_hdr(skb)->daddr;\r\nin_dev = __in_dev_get_rcu(dev);\r\nBUG_ON(!in_dev);\r\nnet = dev_net(dev);\r\nscope = RT_SCOPE_UNIVERSE;\r\nif (!ipv4_is_zeronet(ip_hdr(skb)->saddr)) {\r\nfl4.flowi4_oif = 0;\r\nfl4.flowi4_iif = LOOPBACK_IFINDEX;\r\nfl4.daddr = ip_hdr(skb)->saddr;\r\nfl4.saddr = 0;\r\nfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\r\nfl4.flowi4_scope = scope;\r\nfl4.flowi4_mark = IN_DEV_SRC_VMARK(in_dev) ? skb->mark : 0;\r\nif (!fib_lookup(net, &fl4, &res))\r\nreturn FIB_RES_PREFSRC(net, res);\r\n} else {\r\nscope = RT_SCOPE_LINK;\r\n}\r\nreturn inet_select_addr(dev, ip_hdr(skb)->saddr, scope);\r\n}\r\nstatic int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\r\nu8 tos, int oif, struct net_device *dev,\r\nint rpf, struct in_device *idev, u32 *itag)\r\n{\r\nint ret, no_addr;\r\nstruct fib_result res;\r\nstruct flowi4 fl4;\r\nstruct net *net;\r\nbool dev_match;\r\nfl4.flowi4_oif = 0;\r\nfl4.flowi4_iif = oif ? : LOOPBACK_IFINDEX;\r\nfl4.daddr = src;\r\nfl4.saddr = dst;\r\nfl4.flowi4_tos = tos;\r\nfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\r\nno_addr = idev->ifa_list == NULL;\r\nfl4.flowi4_mark = IN_DEV_SRC_VMARK(idev) ? skb->mark : 0;\r\nnet = dev_net(dev);\r\nif (fib_lookup(net, &fl4, &res))\r\ngoto last_resort;\r\nif (res.type != RTN_UNICAST &&\r\n(res.type != RTN_LOCAL || !IN_DEV_ACCEPT_LOCAL(idev)))\r\ngoto e_inval;\r\nif (!rpf && !fib_num_tclassid_users(dev_net(dev)) &&\r\n(dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev)))\r\ngoto last_resort;\r\nfib_combine_itag(itag, &res);\r\ndev_match = false;\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nfor (ret = 0; ret < res.fi->fib_nhs; ret++) {\r\nstruct fib_nh *nh = &res.fi->fib_nh[ret];\r\nif (nh->nh_dev == dev) {\r\ndev_match = true;\r\nbreak;\r\n}\r\n}\r\n#else\r\nif (FIB_RES_DEV(res) == dev)\r\ndev_match = true;\r\n#endif\r\nif (dev_match) {\r\nret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\r\nreturn ret;\r\n}\r\nif (no_addr)\r\ngoto last_resort;\r\nif (rpf == 1)\r\ngoto e_rpf;\r\nfl4.flowi4_oif = dev->ifindex;\r\nret = 0;\r\nif (fib_lookup(net, &fl4, &res) == 0) {\r\nif (res.type == RTN_UNICAST)\r\nret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\r\n}\r\nreturn ret;\r\nlast_resort:\r\nif (rpf)\r\ngoto e_rpf;\r\n*itag = 0;\r\nreturn 0;\r\ne_inval:\r\nreturn -EINVAL;\r\ne_rpf:\r\nreturn -EXDEV;\r\n}\r\nint fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\r\nu8 tos, int oif, struct net_device *dev,\r\nstruct in_device *idev, u32 *itag)\r\n{\r\nint r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);\r\nif (!r && !fib_num_tclassid_users(dev_net(dev)) &&\r\nIN_DEV_ACCEPT_LOCAL(idev) &&\r\n(dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) {\r\n*itag = 0;\r\nreturn 0;\r\n}\r\nreturn __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);\r\n}\r\nstatic inline __be32 sk_extract_addr(struct sockaddr *addr)\r\n{\r\nreturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\r\n}\r\nstatic int put_rtax(struct nlattr *mx, int len, int type, u32 value)\r\n{\r\nstruct nlattr *nla;\r\nnla = (struct nlattr *) ((char *) mx + len);\r\nnla->nla_type = type;\r\nnla->nla_len = nla_attr_size(4);\r\n*(u32 *) nla_data(nla) = value;\r\nreturn len + nla_total_size(4);\r\n}\r\nstatic int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,\r\nstruct fib_config *cfg)\r\n{\r\n__be32 addr;\r\nint plen;\r\nmemset(cfg, 0, sizeof(*cfg));\r\ncfg->fc_nlinfo.nl_net = net;\r\nif (rt->rt_dst.sa_family != AF_INET)\r\nreturn -EAFNOSUPPORT;\r\nplen = 32;\r\naddr = sk_extract_addr(&rt->rt_dst);\r\nif (!(rt->rt_flags & RTF_HOST)) {\r\n__be32 mask = sk_extract_addr(&rt->rt_genmask);\r\nif (rt->rt_genmask.sa_family != AF_INET) {\r\nif (mask || rt->rt_genmask.sa_family)\r\nreturn -EAFNOSUPPORT;\r\n}\r\nif (bad_mask(mask, addr))\r\nreturn -EINVAL;\r\nplen = inet_mask_len(mask);\r\n}\r\ncfg->fc_dst_len = plen;\r\ncfg->fc_dst = addr;\r\nif (cmd != SIOCDELRT) {\r\ncfg->fc_nlflags = NLM_F_CREATE;\r\ncfg->fc_protocol = RTPROT_BOOT;\r\n}\r\nif (rt->rt_metric)\r\ncfg->fc_priority = rt->rt_metric - 1;\r\nif (rt->rt_flags & RTF_REJECT) {\r\ncfg->fc_scope = RT_SCOPE_HOST;\r\ncfg->fc_type = RTN_UNREACHABLE;\r\nreturn 0;\r\n}\r\ncfg->fc_scope = RT_SCOPE_NOWHERE;\r\ncfg->fc_type = RTN_UNICAST;\r\nif (rt->rt_dev) {\r\nchar *colon;\r\nstruct net_device *dev;\r\nchar devname[IFNAMSIZ];\r\nif (copy_from_user(devname, rt->rt_dev, IFNAMSIZ-1))\r\nreturn -EFAULT;\r\ndevname[IFNAMSIZ-1] = 0;\r\ncolon = strchr(devname, ':');\r\nif (colon)\r\n*colon = 0;\r\ndev = __dev_get_by_name(net, devname);\r\nif (!dev)\r\nreturn -ENODEV;\r\ncfg->fc_oif = dev->ifindex;\r\nif (colon) {\r\nstruct in_ifaddr *ifa;\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nif (!in_dev)\r\nreturn -ENODEV;\r\n*colon = ':';\r\nfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)\r\nif (strcmp(ifa->ifa_label, devname) == 0)\r\nbreak;\r\nif (ifa == NULL)\r\nreturn -ENODEV;\r\ncfg->fc_prefsrc = ifa->ifa_local;\r\n}\r\n}\r\naddr = sk_extract_addr(&rt->rt_gateway);\r\nif (rt->rt_gateway.sa_family == AF_INET && addr) {\r\ncfg->fc_gw = addr;\r\nif (rt->rt_flags & RTF_GATEWAY &&\r\ninet_addr_type(net, addr) == RTN_UNICAST)\r\ncfg->fc_scope = RT_SCOPE_UNIVERSE;\r\n}\r\nif (cmd == SIOCDELRT)\r\nreturn 0;\r\nif (rt->rt_flags & RTF_GATEWAY && !cfg->fc_gw)\r\nreturn -EINVAL;\r\nif (cfg->fc_scope == RT_SCOPE_NOWHERE)\r\ncfg->fc_scope = RT_SCOPE_LINK;\r\nif (rt->rt_flags & (RTF_MTU | RTF_WINDOW | RTF_IRTT)) {\r\nstruct nlattr *mx;\r\nint len = 0;\r\nmx = kzalloc(3 * nla_total_size(4), GFP_KERNEL);\r\nif (mx == NULL)\r\nreturn -ENOMEM;\r\nif (rt->rt_flags & RTF_MTU)\r\nlen = put_rtax(mx, len, RTAX_ADVMSS, rt->rt_mtu - 40);\r\nif (rt->rt_flags & RTF_WINDOW)\r\nlen = put_rtax(mx, len, RTAX_WINDOW, rt->rt_window);\r\nif (rt->rt_flags & RTF_IRTT)\r\nlen = put_rtax(mx, len, RTAX_RTT, rt->rt_irtt << 3);\r\ncfg->fc_mx = mx;\r\ncfg->fc_mx_len = len;\r\n}\r\nreturn 0;\r\n}\r\nint ip_rt_ioctl(struct net *net, unsigned int cmd, void __user *arg)\r\n{\r\nstruct fib_config cfg;\r\nstruct rtentry rt;\r\nint err;\r\nswitch (cmd) {\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&rt, arg, sizeof(rt)))\r\nreturn -EFAULT;\r\nrtnl_lock();\r\nerr = rtentry_to_fib_config(net, cmd, &rt, &cfg);\r\nif (err == 0) {\r\nstruct fib_table *tb;\r\nif (cmd == SIOCDELRT) {\r\ntb = fib_get_table(net, cfg.fc_table);\r\nif (tb)\r\nerr = fib_table_delete(tb, &cfg);\r\nelse\r\nerr = -ESRCH;\r\n} else {\r\ntb = fib_new_table(net, cfg.fc_table);\r\nif (tb)\r\nerr = fib_table_insert(tb, &cfg);\r\nelse\r\nerr = -ENOBUFS;\r\n}\r\nkfree(cfg.fc_mx);\r\n}\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rtm_to_fib_config(struct net *net, struct sk_buff *skb,\r\nstruct nlmsghdr *nlh, struct fib_config *cfg)\r\n{\r\nstruct nlattr *attr;\r\nint err, remaining;\r\nstruct rtmsg *rtm;\r\nerr = nlmsg_validate(nlh, sizeof(*rtm), RTA_MAX, rtm_ipv4_policy);\r\nif (err < 0)\r\ngoto errout;\r\nmemset(cfg, 0, sizeof(*cfg));\r\nrtm = nlmsg_data(nlh);\r\ncfg->fc_dst_len = rtm->rtm_dst_len;\r\ncfg->fc_tos = rtm->rtm_tos;\r\ncfg->fc_table = rtm->rtm_table;\r\ncfg->fc_protocol = rtm->rtm_protocol;\r\ncfg->fc_scope = rtm->rtm_scope;\r\ncfg->fc_type = rtm->rtm_type;\r\ncfg->fc_flags = rtm->rtm_flags;\r\ncfg->fc_nlflags = nlh->nlmsg_flags;\r\ncfg->fc_nlinfo.portid = NETLINK_CB(skb).portid;\r\ncfg->fc_nlinfo.nlh = nlh;\r\ncfg->fc_nlinfo.nl_net = net;\r\nif (cfg->fc_type > RTN_MAX) {\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\nnlmsg_for_each_attr(attr, nlh, sizeof(struct rtmsg), remaining) {\r\nswitch (nla_type(attr)) {\r\ncase RTA_DST:\r\ncfg->fc_dst = nla_get_be32(attr);\r\nbreak;\r\ncase RTA_OIF:\r\ncfg->fc_oif = nla_get_u32(attr);\r\nbreak;\r\ncase RTA_GATEWAY:\r\ncfg->fc_gw = nla_get_be32(attr);\r\nbreak;\r\ncase RTA_PRIORITY:\r\ncfg->fc_priority = nla_get_u32(attr);\r\nbreak;\r\ncase RTA_PREFSRC:\r\ncfg->fc_prefsrc = nla_get_be32(attr);\r\nbreak;\r\ncase RTA_METRICS:\r\ncfg->fc_mx = nla_data(attr);\r\ncfg->fc_mx_len = nla_len(attr);\r\nbreak;\r\ncase RTA_MULTIPATH:\r\ncfg->fc_mp = nla_data(attr);\r\ncfg->fc_mp_len = nla_len(attr);\r\nbreak;\r\ncase RTA_FLOW:\r\ncfg->fc_flow = nla_get_u32(attr);\r\nbreak;\r\ncase RTA_TABLE:\r\ncfg->fc_table = nla_get_u32(attr);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int inet_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib_config cfg;\r\nstruct fib_table *tb;\r\nint err;\r\nerr = rtm_to_fib_config(net, skb, nlh, &cfg);\r\nif (err < 0)\r\ngoto errout;\r\ntb = fib_get_table(net, cfg.fc_table);\r\nif (tb == NULL) {\r\nerr = -ESRCH;\r\ngoto errout;\r\n}\r\nerr = fib_table_delete(tb, &cfg);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib_config cfg;\r\nstruct fib_table *tb;\r\nint err;\r\nerr = rtm_to_fib_config(net, skb, nlh, &cfg);\r\nif (err < 0)\r\ngoto errout;\r\ntb = fib_new_table(net, cfg.fc_table);\r\nif (tb == NULL) {\r\nerr = -ENOBUFS;\r\ngoto errout;\r\n}\r\nerr = fib_table_insert(tb, &cfg);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nunsigned int h, s_h;\r\nunsigned int e = 0, s_e;\r\nstruct fib_table *tb;\r\nstruct hlist_head *head;\r\nint dumped = 0;\r\nif (nlmsg_len(cb->nlh) >= sizeof(struct rtmsg) &&\r\n((struct rtmsg *) nlmsg_data(cb->nlh))->rtm_flags & RTM_F_CLONED)\r\nreturn skb->len;\r\ns_h = cb->args[0];\r\ns_e = cb->args[1];\r\nfor (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {\r\ne = 0;\r\nhead = &net->ipv4.fib_table_hash[h];\r\nhlist_for_each_entry(tb, head, tb_hlist) {\r\nif (e < s_e)\r\ngoto next;\r\nif (dumped)\r\nmemset(&cb->args[2], 0, sizeof(cb->args) -\r\n2 * sizeof(cb->args[0]));\r\nif (fib_table_dump(tb, skb, cb) < 0)\r\ngoto out;\r\ndumped = 1;\r\nnext:\r\ne++;\r\n}\r\n}\r\nout:\r\ncb->args[1] = e;\r\ncb->args[0] = h;\r\nreturn skb->len;\r\n}\r\nstatic void fib_magic(int cmd, int type, __be32 dst, int dst_len, struct in_ifaddr *ifa)\r\n{\r\nstruct net *net = dev_net(ifa->ifa_dev->dev);\r\nstruct fib_table *tb;\r\nstruct fib_config cfg = {\r\n.fc_protocol = RTPROT_KERNEL,\r\n.fc_type = type,\r\n.fc_dst = dst,\r\n.fc_dst_len = dst_len,\r\n.fc_prefsrc = ifa->ifa_local,\r\n.fc_oif = ifa->ifa_dev->dev->ifindex,\r\n.fc_nlflags = NLM_F_CREATE | NLM_F_APPEND,\r\n.fc_nlinfo = {\r\n.nl_net = net,\r\n},\r\n};\r\nif (type == RTN_UNICAST)\r\ntb = fib_new_table(net, RT_TABLE_MAIN);\r\nelse\r\ntb = fib_new_table(net, RT_TABLE_LOCAL);\r\nif (tb == NULL)\r\nreturn;\r\ncfg.fc_table = tb->tb_id;\r\nif (type != RTN_LOCAL)\r\ncfg.fc_scope = RT_SCOPE_LINK;\r\nelse\r\ncfg.fc_scope = RT_SCOPE_HOST;\r\nif (cmd == RTM_NEWROUTE)\r\nfib_table_insert(tb, &cfg);\r\nelse\r\nfib_table_delete(tb, &cfg);\r\n}\r\nvoid fib_add_ifaddr(struct in_ifaddr *ifa)\r\n{\r\nstruct in_device *in_dev = ifa->ifa_dev;\r\nstruct net_device *dev = in_dev->dev;\r\nstruct in_ifaddr *prim = ifa;\r\n__be32 mask = ifa->ifa_mask;\r\n__be32 addr = ifa->ifa_local;\r\n__be32 prefix = ifa->ifa_address & mask;\r\nif (ifa->ifa_flags & IFA_F_SECONDARY) {\r\nprim = inet_ifa_byprefix(in_dev, prefix, mask);\r\nif (prim == NULL) {\r\npr_warn("%s: bug: prim == NULL\n", __func__);\r\nreturn;\r\n}\r\n}\r\nfib_magic(RTM_NEWROUTE, RTN_LOCAL, addr, 32, prim);\r\nif (!(dev->flags & IFF_UP))\r\nreturn;\r\nif (ifa->ifa_broadcast && ifa->ifa_broadcast != htonl(0xFFFFFFFF))\r\nfib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\r\nif (!ipv4_is_zeronet(prefix) && !(ifa->ifa_flags & IFA_F_SECONDARY) &&\r\n(prefix != addr || ifa->ifa_prefixlen < 32)) {\r\nfib_magic(RTM_NEWROUTE,\r\ndev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\r\nprefix, ifa->ifa_prefixlen, prim);\r\nif (ifa->ifa_prefixlen < 31) {\r\nfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix, 32, prim);\r\nfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,\r\n32, prim);\r\n}\r\n}\r\n}\r\nvoid fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\r\n{\r\nstruct in_device *in_dev = ifa->ifa_dev;\r\nstruct net_device *dev = in_dev->dev;\r\nstruct in_ifaddr *ifa1;\r\nstruct in_ifaddr *prim = ifa, *prim1 = NULL;\r\n__be32 brd = ifa->ifa_address | ~ifa->ifa_mask;\r\n__be32 any = ifa->ifa_address & ifa->ifa_mask;\r\n#define LOCAL_OK 1\r\n#define BRD_OK 2\r\n#define BRD0_OK 4\r\n#define BRD1_OK 8\r\nunsigned int ok = 0;\r\nint subnet = 0;\r\nint gone = 1;\r\nint same_prefsrc = 0;\r\nif (ifa->ifa_flags & IFA_F_SECONDARY) {\r\nprim = inet_ifa_byprefix(in_dev, any, ifa->ifa_mask);\r\nif (prim == NULL) {\r\npr_warn("%s: bug: prim == NULL\n", __func__);\r\nreturn;\r\n}\r\nif (iprim && iprim != prim) {\r\npr_warn("%s: bug: iprim != prim\n", __func__);\r\nreturn;\r\n}\r\n} else if (!ipv4_is_zeronet(any) &&\r\n(any != ifa->ifa_local || ifa->ifa_prefixlen < 32)) {\r\nfib_magic(RTM_DELROUTE,\r\ndev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\r\nany, ifa->ifa_prefixlen, prim);\r\nsubnet = 1;\r\n}\r\nfor (ifa1 = in_dev->ifa_list; ifa1; ifa1 = ifa1->ifa_next) {\r\nif (ifa1 == ifa) {\r\ngone = 0;\r\ncontinue;\r\n}\r\nif (iprim && ifa1->ifa_mask == iprim->ifa_mask &&\r\ninet_ifa_match(ifa1->ifa_address, iprim))\r\ncontinue;\r\nif (ifa1->ifa_flags & IFA_F_SECONDARY) {\r\nif (ifa1->ifa_mask == prim->ifa_mask &&\r\ninet_ifa_match(ifa1->ifa_address, prim))\r\nprim1 = prim;\r\nelse {\r\nif (!same_prefsrc)\r\ncontinue;\r\nif (!prim1 ||\r\nifa1->ifa_mask != prim1->ifa_mask ||\r\n!inet_ifa_match(ifa1->ifa_address, prim1))\r\nprim1 = inet_ifa_byprefix(in_dev,\r\nifa1->ifa_address,\r\nifa1->ifa_mask);\r\nif (!prim1)\r\ncontinue;\r\nif (prim1->ifa_local != prim->ifa_local)\r\ncontinue;\r\n}\r\n} else {\r\nif (prim->ifa_local != ifa1->ifa_local)\r\ncontinue;\r\nprim1 = ifa1;\r\nif (prim != prim1)\r\nsame_prefsrc = 1;\r\n}\r\nif (ifa->ifa_local == ifa1->ifa_local)\r\nok |= LOCAL_OK;\r\nif (ifa->ifa_broadcast == ifa1->ifa_broadcast)\r\nok |= BRD_OK;\r\nif (brd == ifa1->ifa_broadcast)\r\nok |= BRD1_OK;\r\nif (any == ifa1->ifa_broadcast)\r\nok |= BRD0_OK;\r\nif (prim1 == ifa1 && ifa1->ifa_prefixlen < 31) {\r\n__be32 brd1 = ifa1->ifa_address | ~ifa1->ifa_mask;\r\n__be32 any1 = ifa1->ifa_address & ifa1->ifa_mask;\r\nif (!ipv4_is_zeronet(any1)) {\r\nif (ifa->ifa_broadcast == brd1 ||\r\nifa->ifa_broadcast == any1)\r\nok |= BRD_OK;\r\nif (brd == brd1 || brd == any1)\r\nok |= BRD1_OK;\r\nif (any == brd1 || any == any1)\r\nok |= BRD0_OK;\r\n}\r\n}\r\n}\r\nif (!(ok & BRD_OK))\r\nfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\r\nif (subnet && ifa->ifa_prefixlen < 31) {\r\nif (!(ok & BRD1_OK))\r\nfib_magic(RTM_DELROUTE, RTN_BROADCAST, brd, 32, prim);\r\nif (!(ok & BRD0_OK))\r\nfib_magic(RTM_DELROUTE, RTN_BROADCAST, any, 32, prim);\r\n}\r\nif (!(ok & LOCAL_OK)) {\r\nfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim);\r\nif (gone &&\r\ninet_addr_type(dev_net(dev), ifa->ifa_local) != RTN_LOCAL) {\r\nif (fib_sync_down_addr(dev_net(dev), ifa->ifa_local))\r\nfib_flush(dev_net(dev));\r\n}\r\n}\r\n#undef LOCAL_OK\r\n#undef BRD_OK\r\n#undef BRD0_OK\r\n#undef BRD1_OK\r\n}\r\nstatic void nl_fib_lookup(struct fib_result_nl *frn, struct fib_table *tb)\r\n{\r\nstruct fib_result res;\r\nstruct flowi4 fl4 = {\r\n.flowi4_mark = frn->fl_mark,\r\n.daddr = frn->fl_addr,\r\n.flowi4_tos = frn->fl_tos,\r\n.flowi4_scope = frn->fl_scope,\r\n};\r\nfrn->err = -ENOENT;\r\nif (tb) {\r\nlocal_bh_disable();\r\nfrn->tb_id = tb->tb_id;\r\nfrn->err = fib_table_lookup(tb, &fl4, &res, FIB_LOOKUP_NOREF);\r\nif (!frn->err) {\r\nfrn->prefixlen = res.prefixlen;\r\nfrn->nh_sel = res.nh_sel;\r\nfrn->type = res.type;\r\nfrn->scope = res.scope;\r\n}\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic void nl_fib_input(struct sk_buff *skb)\r\n{\r\nstruct net *net;\r\nstruct fib_result_nl *frn;\r\nstruct nlmsghdr *nlh;\r\nstruct fib_table *tb;\r\nu32 portid;\r\nnet = sock_net(skb->sk);\r\nnlh = nlmsg_hdr(skb);\r\nif (skb->len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len ||\r\nnlmsg_len(nlh) < sizeof(*frn))\r\nreturn;\r\nskb = netlink_skb_clone(skb, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn;\r\nnlh = nlmsg_hdr(skb);\r\nfrn = (struct fib_result_nl *) nlmsg_data(nlh);\r\ntb = fib_get_table(net, frn->tb_id_in);\r\nnl_fib_lookup(frn, tb);\r\nportid = NETLINK_CB(skb).portid;\r\nNETLINK_CB(skb).portid = 0;\r\nNETLINK_CB(skb).dst_group = 0;\r\nnetlink_unicast(net->ipv4.fibnl, skb, portid, MSG_DONTWAIT);\r\n}\r\nstatic int __net_init nl_fib_lookup_init(struct net *net)\r\n{\r\nstruct sock *sk;\r\nstruct netlink_kernel_cfg cfg = {\r\n.input = nl_fib_input,\r\n};\r\nsk = netlink_kernel_create(net, NETLINK_FIB_LOOKUP, &cfg);\r\nif (sk == NULL)\r\nreturn -EAFNOSUPPORT;\r\nnet->ipv4.fibnl = sk;\r\nreturn 0;\r\n}\r\nstatic void nl_fib_lookup_exit(struct net *net)\r\n{\r\nnetlink_kernel_release(net->ipv4.fibnl);\r\nnet->ipv4.fibnl = NULL;\r\n}\r\nstatic void fib_disable_ip(struct net_device *dev, int force)\r\n{\r\nif (fib_sync_down_dev(dev, force))\r\nfib_flush(dev_net(dev));\r\nrt_cache_flush(dev_net(dev));\r\narp_ifdown(dev);\r\n}\r\nstatic int fib_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\r\nstruct net_device *dev = ifa->ifa_dev->dev;\r\nstruct net *net = dev_net(dev);\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nfib_add_ifaddr(ifa);\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nfib_sync_up(dev);\r\n#endif\r\natomic_inc(&net->ipv4.dev_addr_genid);\r\nrt_cache_flush(dev_net(dev));\r\nbreak;\r\ncase NETDEV_DOWN:\r\nfib_del_ifaddr(ifa, NULL);\r\natomic_inc(&net->ipv4.dev_addr_genid);\r\nif (ifa->ifa_dev->ifa_list == NULL) {\r\nfib_disable_ip(dev, 1);\r\n} else {\r\nrt_cache_flush(dev_net(dev));\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct in_device *in_dev;\r\nstruct net *net = dev_net(dev);\r\nif (event == NETDEV_UNREGISTER) {\r\nfib_disable_ip(dev, 2);\r\nrt_flush_dev(dev);\r\nreturn NOTIFY_DONE;\r\n}\r\nin_dev = __in_dev_get_rtnl(dev);\r\nif (!in_dev)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nfor_ifa(in_dev) {\r\nfib_add_ifaddr(ifa);\r\n} endfor_ifa(in_dev);\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nfib_sync_up(dev);\r\n#endif\r\natomic_inc(&net->ipv4.dev_addr_genid);\r\nrt_cache_flush(net);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nfib_disable_ip(dev, 0);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\ncase NETDEV_CHANGE:\r\nrt_cache_flush(net);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __net_init ip_fib_net_init(struct net *net)\r\n{\r\nint err;\r\nsize_t size = sizeof(struct hlist_head) * FIB_TABLE_HASHSZ;\r\nsize = max_t(size_t, size, L1_CACHE_BYTES);\r\nnet->ipv4.fib_table_hash = kzalloc(size, GFP_KERNEL);\r\nif (net->ipv4.fib_table_hash == NULL)\r\nreturn -ENOMEM;\r\nerr = fib4_rules_init(net);\r\nif (err < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nkfree(net->ipv4.fib_table_hash);\r\nreturn err;\r\n}\r\nstatic void ip_fib_net_exit(struct net *net)\r\n{\r\nunsigned int i;\r\n#ifdef CONFIG_IP_MULTIPLE_TABLES\r\nfib4_rules_exit(net);\r\n#endif\r\nrtnl_lock();\r\nfor (i = 0; i < FIB_TABLE_HASHSZ; i++) {\r\nstruct fib_table *tb;\r\nstruct hlist_head *head;\r\nstruct hlist_node *tmp;\r\nhead = &net->ipv4.fib_table_hash[i];\r\nhlist_for_each_entry_safe(tb, tmp, head, tb_hlist) {\r\nhlist_del(&tb->tb_hlist);\r\nfib_table_flush(tb);\r\nfib_free_table(tb);\r\n}\r\n}\r\nrtnl_unlock();\r\nkfree(net->ipv4.fib_table_hash);\r\n}\r\nstatic int __net_init fib_net_init(struct net *net)\r\n{\r\nint error;\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\nnet->ipv4.fib_num_tclassid_users = 0;\r\n#endif\r\nerror = ip_fib_net_init(net);\r\nif (error < 0)\r\ngoto out;\r\nerror = nl_fib_lookup_init(net);\r\nif (error < 0)\r\ngoto out_nlfl;\r\nerror = fib_proc_init(net);\r\nif (error < 0)\r\ngoto out_proc;\r\nout:\r\nreturn error;\r\nout_proc:\r\nnl_fib_lookup_exit(net);\r\nout_nlfl:\r\nip_fib_net_exit(net);\r\ngoto out;\r\n}\r\nstatic void __net_exit fib_net_exit(struct net *net)\r\n{\r\nfib_proc_exit(net);\r\nnl_fib_lookup_exit(net);\r\nip_fib_net_exit(net);\r\n}\r\nvoid __init ip_fib_init(void)\r\n{\r\nrtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);\r\nrtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);\r\nrtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);\r\nregister_pernet_subsys(&fib_net_ops);\r\nregister_netdevice_notifier(&fib_netdev_notifier);\r\nregister_inetaddr_notifier(&fib_inetaddr_notifier);\r\nfib_trie_init();\r\n}
