static void\r\nnvc0_ram_train(struct nvc0_ramfuc *fuc, u32 magic)\r\n{\r\nstruct nvc0_ram *ram = container_of(fuc, typeof(*ram), fuc);\r\nstruct nouveau_fb *pfb = nouveau_fb(ram);\r\nu32 part = nv_rd32(pfb, 0x022438), i;\r\nu32 mask = nv_rd32(pfb, 0x022554);\r\nu32 addr = 0x110974;\r\nram_wr32(fuc, 0x10f910, magic);\r\nram_wr32(fuc, 0x10f914, magic);\r\nfor (i = 0; (magic & 0x80000000) && i < part; addr += 0x1000, i++) {\r\nif (mask & (1 << i))\r\ncontinue;\r\nram_wait(fuc, addr, 0x0000000f, 0x00000000, 500000);\r\n}\r\n}\r\nstatic int\r\nnvc0_ram_calc(struct nouveau_fb *pfb, u32 freq)\r\n{\r\nstruct nouveau_clock *clk = nouveau_clock(pfb);\r\nstruct nouveau_bios *bios = nouveau_bios(pfb);\r\nstruct nvc0_ram *ram = (void *)pfb->ram;\r\nstruct nvc0_ramfuc *fuc = &ram->fuc;\r\nstruct nvbios_ramcfg cfg;\r\nu8 ver, cnt, len, strap;\r\nstruct {\r\nu32 data;\r\nu8 size;\r\n} rammap, ramcfg, timing;\r\nint ref, div, out;\r\nint from, mode;\r\nint N1, M1, P;\r\nint ret;\r\nrammap.data = nvbios_rammapEm(bios, freq / 1000, &ver, &rammap.size,\r\n&cnt, &ramcfg.size, &cfg);\r\nif (!rammap.data || ver != 0x10 || rammap.size < 0x0e) {\r\nnv_error(pfb, "invalid/missing rammap entry\n");\r\nreturn -EINVAL;\r\n}\r\nstrap = nvbios_ramcfg_index(nv_subdev(pfb));\r\nif (strap >= cnt) {\r\nnv_error(pfb, "invalid ramcfg strap\n");\r\nreturn -EINVAL;\r\n}\r\nramcfg.data = rammap.data + rammap.size + (strap * ramcfg.size);\r\nif (!ramcfg.data || ver != 0x10 || ramcfg.size < 0x0e) {\r\nnv_error(pfb, "invalid/missing ramcfg entry\n");\r\nreturn -EINVAL;\r\n}\r\nstrap = nv_ro08(bios, ramcfg.data + 0x01);\r\nif (strap != 0xff) {\r\ntiming.data = nvbios_timingEe(bios, strap, &ver, &timing.size,\r\n&cnt, &len);\r\nif (!timing.data || ver != 0x10 || timing.size < 0x19) {\r\nnv_error(pfb, "invalid/missing timing entry\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ntiming.data = 0;\r\n}\r\nret = ram_init(fuc, pfb);\r\nif (ret)\r\nreturn ret;\r\nfrom = !!(ram_rd32(fuc, 0x1373f0) & 0x00000002);\r\nif (!(ram_rd32(fuc, 0x137300) & 0x00000100))\r\nref = clk->read(clk, nv_clk_src_sppll0);\r\nelse\r\nref = clk->read(clk, nv_clk_src_sppll1);\r\ndiv = max(min((ref * 2) / freq, (u32)65), (u32)2) - 2;\r\nout = (ref * 2) / (div + 2);\r\nmode = freq != out;\r\nram_mask(fuc, 0x137360, 0x00000002, 0x00000000);\r\nif ((ram_rd32(fuc, 0x132000) & 0x00000002) || 0 ) {\r\nram_nuke(fuc, 0x132000);\r\nram_mask(fuc, 0x132000, 0x00000002, 0x00000002);\r\nram_mask(fuc, 0x132000, 0x00000002, 0x00000000);\r\n}\r\nif (mode == 1) {\r\nram_nuke(fuc, 0x10fe20);\r\nram_mask(fuc, 0x10fe20, 0x00000002, 0x00000002);\r\nram_mask(fuc, 0x10fe20, 0x00000002, 0x00000000);\r\n}\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nif (mode == 1 && from == 0) {\r\nret = nva3_pll_calc(nv_subdev(pfb), &ram->refpll,\r\nram->mempll.refclk, &N1, NULL, &M1, &P);\r\nif (ret <= 0) {\r\nnv_error(pfb, "unable to calc refpll\n");\r\nreturn ret ? ret : -ERANGE;\r\n}\r\nram_wr32(fuc, 0x10fe20, 0x20010000);\r\nram_wr32(fuc, 0x137320, 0x00000003);\r\nram_wr32(fuc, 0x137330, 0x81200006);\r\nram_wr32(fuc, 0x10fe24, (P << 16) | (N1 << 8) | M1);\r\nram_wr32(fuc, 0x10fe20, 0x20010001);\r\nram_wait(fuc, 0x137390, 0x00020000, 0x00020000, 64000);\r\nret = nva3_pll_calc(nv_subdev(pfb), &ram->mempll, freq,\r\n&N1, NULL, &M1, &P);\r\nif (ret <= 0) {\r\nnv_error(pfb, "unable to calc refpll\n");\r\nreturn ret ? ret : -ERANGE;\r\n}\r\nram_wr32(fuc, 0x10fe20, 0x20010005);\r\nram_wr32(fuc, 0x132004, (P << 16) | (N1 << 8) | M1);\r\nram_wr32(fuc, 0x132000, 0x18010101);\r\nram_wait(fuc, 0x137390, 0x00000002, 0x00000002, 64000);\r\n} else\r\nif (mode == 0) {\r\nram_wr32(fuc, 0x137300, 0x00000003);\r\n}\r\nif (from == 0) {\r\nram_nuke(fuc, 0x10fb04);\r\nram_mask(fuc, 0x10fb04, 0x0000ffff, 0x00000000);\r\nram_nuke(fuc, 0x10fb08);\r\nram_mask(fuc, 0x10fb08, 0x0000ffff, 0x00000000);\r\nram_wr32(fuc, 0x10f988, 0x2004ff00);\r\nram_wr32(fuc, 0x10f98c, 0x003fc040);\r\nram_wr32(fuc, 0x10f990, 0x20012001);\r\nram_wr32(fuc, 0x10f998, 0x00011a00);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\n} else {\r\nram_wr32(fuc, 0x10f988, 0x20010000);\r\nram_wr32(fuc, 0x10f98c, 0x00000000);\r\nram_wr32(fuc, 0x10f990, 0x20012001);\r\nram_wr32(fuc, 0x10f998, 0x00010a00);\r\n}\r\nif (from == 0) {\r\n}\r\nram_wr32(fuc, 0x100b0c, 0x00080012);\r\nram_wr32(fuc, 0x611200, 0x00003300);\r\nram_mask(fuc, 0x10f200, 0x00000800, 0x00000000);\r\nram_wr32(fuc, 0x10f210, 0x00000000);\r\nram_nsec(fuc, 1000);\r\nif (mode == 0)\r\nnvc0_ram_train(fuc, 0x000c1001);\r\nram_wr32(fuc, 0x10f310, 0x00000001);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f090, 0x00000061);\r\nram_wr32(fuc, 0x10f090, 0xc000007f);\r\nram_nsec(fuc, 1000);\r\nif (from == 0) {\r\nram_wr32(fuc, 0x10f824, 0x00007fd4);\r\n} else {\r\nram_wr32(fuc, 0x1373ec, 0x00020404);\r\n}\r\nif (mode == 0) {\r\nram_mask(fuc, 0x10f808, 0x00080000, 0x00000000);\r\nram_mask(fuc, 0x10f200, 0x00008000, 0x00008000);\r\nram_wr32(fuc, 0x10f830, 0x41500010);\r\nram_mask(fuc, 0x10f830, 0x01000000, 0x00000000);\r\nram_mask(fuc, 0x132100, 0x00000100, 0x00000100);\r\nram_wr32(fuc, 0x10f050, 0xff000090);\r\nram_wr32(fuc, 0x1373ec, 0x00020f0f);\r\nram_wr32(fuc, 0x1373f0, 0x00000003);\r\nram_wr32(fuc, 0x137310, 0x81201616);\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\nram_wr32(fuc, 0x1373f0, 0x00000001);\r\nram_wr32(fuc, 0x10f824, 0x00007e77);\r\nram_wr32(fuc, 0x132000, 0x18030001);\r\nram_wr32(fuc, 0x10f090, 0x4000007e);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f314, 0x00000001);\r\nram_wr32(fuc, 0x10f210, 0x80000000);\r\nram_wr32(fuc, 0x10f338, 0x00300220);\r\nram_wr32(fuc, 0x10f300, 0x0000011d);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f290, 0x02060505);\r\nram_wr32(fuc, 0x10f294, 0x34208288);\r\nram_wr32(fuc, 0x10f298, 0x44050411);\r\nram_wr32(fuc, 0x10f29c, 0x0000114c);\r\nram_wr32(fuc, 0x10f2a0, 0x42e10069);\r\nram_wr32(fuc, 0x10f614, 0x40044f77);\r\nram_wr32(fuc, 0x10f610, 0x40044f77);\r\nram_wr32(fuc, 0x10f344, 0x00600009);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f348, 0x00700008);\r\nram_wr32(fuc, 0x61c140, 0x19240000);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\nnvc0_ram_train(fuc, 0x80021001);\r\nnvc0_ram_train(fuc, 0x80081001);\r\nram_wr32(fuc, 0x10f340, 0x00500004);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f830, 0x01300017);\r\nram_wr32(fuc, 0x10f830, 0x00300017);\r\nram_wr32(fuc, 0x100b0c, 0x00080028);\r\nram_wr32(fuc, 0x611200, 0x00003330);\r\n} else {\r\nram_wr32(fuc, 0x10f800, 0x00001800);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x1373ec, 0x00020404);\r\nram_wr32(fuc, 0x1373f0, 0x00000003);\r\nram_wr32(fuc, 0x10f830, 0x40700010);\r\nram_wr32(fuc, 0x10f830, 0x40500010);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x1373f8, 0x00000000);\r\nram_wr32(fuc, 0x132100, 0x00000101);\r\nram_wr32(fuc, 0x137310, 0x89201616);\r\nram_wr32(fuc, 0x10f050, 0xff000090);\r\nram_wr32(fuc, 0x1373ec, 0x00030404);\r\nram_wr32(fuc, 0x1373f0, 0x00000002);\r\nram_wr32(fuc, 0x132100, 0x00000001);\r\nram_wr32(fuc, 0x1373f8, 0x00002000);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f808, 0x7aaa0050);\r\nram_wr32(fuc, 0x10f830, 0x00500010);\r\nram_wr32(fuc, 0x10f200, 0x00ce1000);\r\nram_wr32(fuc, 0x10f090, 0x4000007e);\r\nram_nsec(fuc, 2000);\r\nram_wr32(fuc, 0x10f314, 0x00000001);\r\nram_wr32(fuc, 0x10f210, 0x80000000);\r\nram_wr32(fuc, 0x10f338, 0x00300200);\r\nram_wr32(fuc, 0x10f300, 0x0000084d);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f290, 0x0b343825);\r\nram_wr32(fuc, 0x10f294, 0x3483028e);\r\nram_wr32(fuc, 0x10f298, 0x440c0600);\r\nram_wr32(fuc, 0x10f29c, 0x0000214c);\r\nram_wr32(fuc, 0x10f2a0, 0x42e20069);\r\nram_wr32(fuc, 0x10f200, 0x00ce0000);\r\nram_wr32(fuc, 0x10f614, 0x60044e77);\r\nram_wr32(fuc, 0x10f610, 0x60044e77);\r\nram_wr32(fuc, 0x10f340, 0x00500000);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f344, 0x00600228);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f348, 0x00700000);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x61c140, 0x09a40000);\r\nnvc0_ram_train(fuc, 0x800e1008);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x10f800, 0x00001804);\r\nram_wr32(fuc, 0x13d8f4, 0x00000000);\r\nram_wr32(fuc, 0x100b0c, 0x00080028);\r\nram_wr32(fuc, 0x611200, 0x00003330);\r\nram_nsec(fuc, 100000);\r\nram_wr32(fuc, 0x10f9b0, 0x05313f41);\r\nram_wr32(fuc, 0x10f9b4, 0x00002f50);\r\nnvc0_ram_train(fuc, 0x010c1001);\r\n}\r\nram_mask(fuc, 0x10f200, 0x00000800, 0x00000800);\r\nif (mode == 0)\r\nram_mask(fuc, 0x132000, 0x00000001, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_ram_prog(struct nouveau_fb *pfb)\r\n{\r\nstruct nouveau_device *device = nv_device(pfb);\r\nstruct nvc0_ram *ram = (void *)pfb->ram;\r\nstruct nvc0_ramfuc *fuc = &ram->fuc;\r\nram_exec(fuc, nouveau_boolopt(device->cfgopt, "NvMemExec", true));\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_ram_tidy(struct nouveau_fb *pfb)\r\n{\r\nstruct nvc0_ram *ram = (void *)pfb->ram;\r\nstruct nvc0_ramfuc *fuc = &ram->fuc;\r\nram_exec(fuc, false);\r\n}\r\nvoid\r\nnvc0_ram_put(struct nouveau_fb *pfb, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_ltc *ltc = nouveau_ltc(pfb);\r\nstruct nouveau_mem *mem = *pmem;\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nmutex_lock(&pfb->base.mutex);\r\nif (mem->tag)\r\nltc->tags_free(ltc, &mem->tag);\r\n__nv50_ram_put(pfb, mem);\r\nmutex_unlock(&pfb->base.mutex);\r\nkfree(mem);\r\n}\r\nint\r\nnvc0_ram_get(struct nouveau_fb *pfb, u64 size, u32 align, u32 ncmin,\r\nu32 memtype, struct nouveau_mem **pmem)\r\n{\r\nstruct nouveau_mm *mm = &pfb->vram;\r\nstruct nouveau_mm_node *r;\r\nstruct nouveau_mem *mem;\r\nint type = (memtype & 0x0ff);\r\nint back = (memtype & 0x800);\r\nconst bool comp = nvc0_pte_storage_type_map[type] != type;\r\nint ret;\r\nsize >>= 12;\r\nalign >>= 12;\r\nncmin >>= 12;\r\nif (!ncmin)\r\nncmin = size;\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mem->regions);\r\nmem->size = size;\r\nmutex_lock(&pfb->base.mutex);\r\nif (comp) {\r\nstruct nouveau_ltc *ltc = nouveau_ltc(pfb);\r\nif (align == (1 << (17 - 12))) {\r\nint n = size >> 5;\r\nltc->tags_alloc(ltc, n, &mem->tag);\r\n}\r\nif (unlikely(!mem->tag))\r\ntype = nvc0_pte_storage_type_map[type];\r\n}\r\nmem->memtype = type;\r\ndo {\r\nif (back)\r\nret = nouveau_mm_tail(mm, 0, 1, size, ncmin, align, &r);\r\nelse\r\nret = nouveau_mm_head(mm, 0, 1, size, ncmin, align, &r);\r\nif (ret) {\r\nmutex_unlock(&pfb->base.mutex);\r\npfb->ram->put(pfb, &mem);\r\nreturn ret;\r\n}\r\nlist_add_tail(&r->rl_entry, &mem->regions);\r\nsize -= r->length;\r\n} while (size);\r\nmutex_unlock(&pfb->base.mutex);\r\nr = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);\r\nmem->offset = (u64)r->offset << 12;\r\n*pmem = mem;\r\nreturn 0;\r\n}\r\nint\r\nnvc0_ram_create_(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, u32 maskaddr, int size,\r\nvoid **pobject)\r\n{\r\nstruct nouveau_fb *pfb = nouveau_fb(parent);\r\nstruct nouveau_bios *bios = nouveau_bios(pfb);\r\nstruct nouveau_ram *ram;\r\nconst u32 rsvd_head = ( 256 * 1024) >> 12;\r\nconst u32 rsvd_tail = (1024 * 1024) >> 12;\r\nu32 parts = nv_rd32(pfb, 0x022438);\r\nu32 pmask = nv_rd32(pfb, maskaddr);\r\nu32 bsize = nv_rd32(pfb, 0x10f20c);\r\nu32 offset, length;\r\nbool uniform = true;\r\nint ret, part;\r\nret = nouveau_ram_create_(parent, engine, oclass, size, pobject);\r\nram = *pobject;\r\nif (ret)\r\nreturn ret;\r\nnv_debug(pfb, "0x100800: 0x%08x\n", nv_rd32(pfb, 0x100800));\r\nnv_debug(pfb, "parts 0x%08x mask 0x%08x\n", parts, pmask);\r\nram->type = nouveau_fb_bios_memtype(bios);\r\nram->ranks = (nv_rd32(pfb, 0x10f200) & 0x00000004) ? 2 : 1;\r\nfor (part = 0; part < parts; part++) {\r\nif (!(pmask & (1 << part))) {\r\nu32 psize = nv_rd32(pfb, 0x11020c + (part * 0x1000));\r\nif (psize != bsize) {\r\nif (psize < bsize)\r\nbsize = psize;\r\nuniform = false;\r\n}\r\nnv_debug(pfb, "%d: mem_amount 0x%08x\n", part, psize);\r\nram->size += (u64)psize << 20;\r\n}\r\n}\r\nif (uniform) {\r\noffset = rsvd_head;\r\nlength = (ram->size >> 12) - rsvd_head - rsvd_tail;\r\nret = nouveau_mm_init(&pfb->vram, offset, length, 1);\r\n} else {\r\nret = nouveau_mm_init(&pfb->vram, rsvd_head,\r\n(bsize << 8) * parts - rsvd_head, 1);\r\nif (ret)\r\nreturn ret;\r\noffset = (0x0200000000ULL >> 12) + (bsize << 8);\r\nlength = (ram->size >> 12) - ((bsize * parts) << 8) - rsvd_tail;\r\nret = nouveau_mm_init(&pfb->vram, offset, length, 1);\r\nif (ret)\r\nnouveau_mm_fini(&pfb->vram);\r\n}\r\nif (ret)\r\nreturn ret;\r\nram->get = nvc0_ram_get;\r\nram->put = nvc0_ram_put;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_ram_init(struct nouveau_object *object)\r\n{\r\nstruct nouveau_fb *pfb = (void *)object->parent;\r\nstruct nvc0_ram *ram = (void *)object;\r\nint ret, i;\r\nret = nouveau_ram_init(&ram->base);\r\nif (ret)\r\nreturn ret;\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_GDDR5: {\r\nstatic const u8 train0[] = {\r\n0x00, 0xff, 0x55, 0xaa, 0x33, 0xcc,\r\n0x00, 0xff, 0xff, 0x00, 0xff, 0x00,\r\n};\r\nstatic const u32 train1[] = {\r\n0x00000000, 0xffffffff,\r\n0x55555555, 0xaaaaaaaa,\r\n0x33333333, 0xcccccccc,\r\n0xf0f0f0f0, 0x0f0f0f0f,\r\n0x00ff00ff, 0xff00ff00,\r\n0x0000ffff, 0xffff0000,\r\n};\r\nfor (i = 0; i < 0x30; i++) {\r\nnv_wr32(pfb, 0x10f968, 0x00000000 | (i << 8));\r\nnv_wr32(pfb, 0x10f96c, 0x00000000 | (i << 8));\r\nnv_wr32(pfb, 0x10f920, 0x00000100 | train0[i % 12]);\r\nnv_wr32(pfb, 0x10f924, 0x00000100 | train0[i % 12]);\r\nnv_wr32(pfb, 0x10f918, train1[i % 12]);\r\nnv_wr32(pfb, 0x10f91c, train1[i % 12]);\r\nnv_wr32(pfb, 0x10f920, 0x00000000 | train0[i % 12]);\r\nnv_wr32(pfb, 0x10f924, 0x00000000 | train0[i % 12]);\r\nnv_wr32(pfb, 0x10f918, train1[i % 12]);\r\nnv_wr32(pfb, 0x10f91c, train1[i % 12]);\r\n}\r\n} break;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_ram_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_bios *bios = nouveau_bios(parent);\r\nstruct nvc0_ram *ram;\r\nint ret;\r\nret = nvc0_ram_create(parent, engine, oclass, 0x022554, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nret = nvbios_pll_parse(bios, 0x0c, &ram->refpll);\r\nif (ret) {\r\nnv_error(ram, "mclk refpll data not found\n");\r\nreturn ret;\r\n}\r\nret = nvbios_pll_parse(bios, 0x04, &ram->mempll);\r\nif (ret) {\r\nnv_error(ram, "mclk pll data not found\n");\r\nreturn ret;\r\n}\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_GDDR5:\r\nram->base.calc = nvc0_ram_calc;\r\nram->base.prog = nvc0_ram_prog;\r\nram->base.tidy = nvc0_ram_tidy;\r\nbreak;\r\ndefault:\r\nnv_warn(ram, "reclocking of this ram type unsupported\n");\r\nreturn 0;\r\n}\r\nram->fuc.r_0x10fe20 = ramfuc_reg(0x10fe20);\r\nram->fuc.r_0x10fe24 = ramfuc_reg(0x10fe24);\r\nram->fuc.r_0x137320 = ramfuc_reg(0x137320);\r\nram->fuc.r_0x137330 = ramfuc_reg(0x137330);\r\nram->fuc.r_0x132000 = ramfuc_reg(0x132000);\r\nram->fuc.r_0x132004 = ramfuc_reg(0x132004);\r\nram->fuc.r_0x132100 = ramfuc_reg(0x132100);\r\nram->fuc.r_0x137390 = ramfuc_reg(0x137390);\r\nram->fuc.r_0x10f290 = ramfuc_reg(0x10f290);\r\nram->fuc.r_0x10f294 = ramfuc_reg(0x10f294);\r\nram->fuc.r_0x10f298 = ramfuc_reg(0x10f298);\r\nram->fuc.r_0x10f29c = ramfuc_reg(0x10f29c);\r\nram->fuc.r_0x10f2a0 = ramfuc_reg(0x10f2a0);\r\nram->fuc.r_0x10f300 = ramfuc_reg(0x10f300);\r\nram->fuc.r_0x10f338 = ramfuc_reg(0x10f338);\r\nram->fuc.r_0x10f340 = ramfuc_reg(0x10f340);\r\nram->fuc.r_0x10f344 = ramfuc_reg(0x10f344);\r\nram->fuc.r_0x10f348 = ramfuc_reg(0x10f348);\r\nram->fuc.r_0x10f910 = ramfuc_reg(0x10f910);\r\nram->fuc.r_0x10f914 = ramfuc_reg(0x10f914);\r\nram->fuc.r_0x100b0c = ramfuc_reg(0x100b0c);\r\nram->fuc.r_0x10f050 = ramfuc_reg(0x10f050);\r\nram->fuc.r_0x10f090 = ramfuc_reg(0x10f090);\r\nram->fuc.r_0x10f200 = ramfuc_reg(0x10f200);\r\nram->fuc.r_0x10f210 = ramfuc_reg(0x10f210);\r\nram->fuc.r_0x10f310 = ramfuc_reg(0x10f310);\r\nram->fuc.r_0x10f314 = ramfuc_reg(0x10f314);\r\nram->fuc.r_0x10f610 = ramfuc_reg(0x10f610);\r\nram->fuc.r_0x10f614 = ramfuc_reg(0x10f614);\r\nram->fuc.r_0x10f800 = ramfuc_reg(0x10f800);\r\nram->fuc.r_0x10f808 = ramfuc_reg(0x10f808);\r\nram->fuc.r_0x10f824 = ramfuc_reg(0x10f824);\r\nram->fuc.r_0x10f830 = ramfuc_reg(0x10f830);\r\nram->fuc.r_0x10f988 = ramfuc_reg(0x10f988);\r\nram->fuc.r_0x10f98c = ramfuc_reg(0x10f98c);\r\nram->fuc.r_0x10f990 = ramfuc_reg(0x10f990);\r\nram->fuc.r_0x10f998 = ramfuc_reg(0x10f998);\r\nram->fuc.r_0x10f9b0 = ramfuc_reg(0x10f9b0);\r\nram->fuc.r_0x10f9b4 = ramfuc_reg(0x10f9b4);\r\nram->fuc.r_0x10fb04 = ramfuc_reg(0x10fb04);\r\nram->fuc.r_0x10fb08 = ramfuc_reg(0x10fb08);\r\nram->fuc.r_0x137310 = ramfuc_reg(0x137300);\r\nram->fuc.r_0x137310 = ramfuc_reg(0x137310);\r\nram->fuc.r_0x137360 = ramfuc_reg(0x137360);\r\nram->fuc.r_0x1373ec = ramfuc_reg(0x1373ec);\r\nram->fuc.r_0x1373f0 = ramfuc_reg(0x1373f0);\r\nram->fuc.r_0x1373f8 = ramfuc_reg(0x1373f8);\r\nram->fuc.r_0x61c140 = ramfuc_reg(0x61c140);\r\nram->fuc.r_0x611200 = ramfuc_reg(0x611200);\r\nram->fuc.r_0x13d8f4 = ramfuc_reg(0x13d8f4);\r\nreturn 0;\r\n}
