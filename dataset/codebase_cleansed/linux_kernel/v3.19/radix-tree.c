static inline void *ptr_to_indirect(void *ptr)\r\n{\r\nreturn (void *)((unsigned long)ptr | RADIX_TREE_INDIRECT_PTR);\r\n}\r\nstatic inline void *indirect_to_ptr(void *ptr)\r\n{\r\nreturn (void *)((unsigned long)ptr & ~RADIX_TREE_INDIRECT_PTR);\r\n}\r\nstatic inline gfp_t root_gfp_mask(struct radix_tree_root *root)\r\n{\r\nreturn root->gfp_mask & __GFP_BITS_MASK;\r\n}\r\nstatic inline void tag_set(struct radix_tree_node *node, unsigned int tag,\r\nint offset)\r\n{\r\n__set_bit(offset, node->tags[tag]);\r\n}\r\nstatic inline void tag_clear(struct radix_tree_node *node, unsigned int tag,\r\nint offset)\r\n{\r\n__clear_bit(offset, node->tags[tag]);\r\n}\r\nstatic inline int tag_get(struct radix_tree_node *node, unsigned int tag,\r\nint offset)\r\n{\r\nreturn test_bit(offset, node->tags[tag]);\r\n}\r\nstatic inline void root_tag_set(struct radix_tree_root *root, unsigned int tag)\r\n{\r\nroot->gfp_mask |= (__force gfp_t)(1 << (tag + __GFP_BITS_SHIFT));\r\n}\r\nstatic inline void root_tag_clear(struct radix_tree_root *root, unsigned int tag)\r\n{\r\nroot->gfp_mask &= (__force gfp_t)~(1 << (tag + __GFP_BITS_SHIFT));\r\n}\r\nstatic inline void root_tag_clear_all(struct radix_tree_root *root)\r\n{\r\nroot->gfp_mask &= __GFP_BITS_MASK;\r\n}\r\nstatic inline int root_tag_get(struct radix_tree_root *root, unsigned int tag)\r\n{\r\nreturn (__force unsigned)root->gfp_mask & (1 << (tag + __GFP_BITS_SHIFT));\r\n}\r\nstatic inline int any_tag_set(struct radix_tree_node *node, unsigned int tag)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < RADIX_TREE_TAG_LONGS; idx++) {\r\nif (node->tags[tag][idx])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic __always_inline unsigned long\r\nradix_tree_find_next_bit(const unsigned long *addr,\r\nunsigned long size, unsigned long offset)\r\n{\r\nif (!__builtin_constant_p(size))\r\nreturn find_next_bit(addr, size, offset);\r\nif (offset < size) {\r\nunsigned long tmp;\r\naddr += offset / BITS_PER_LONG;\r\ntmp = *addr >> (offset % BITS_PER_LONG);\r\nif (tmp)\r\nreturn __ffs(tmp) + offset;\r\noffset = (offset + BITS_PER_LONG) & ~(BITS_PER_LONG - 1);\r\nwhile (offset < size) {\r\ntmp = *++addr;\r\nif (tmp)\r\nreturn __ffs(tmp) + offset;\r\noffset += BITS_PER_LONG;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic struct radix_tree_node *\r\nradix_tree_node_alloc(struct radix_tree_root *root)\r\n{\r\nstruct radix_tree_node *ret = NULL;\r\ngfp_t gfp_mask = root_gfp_mask(root);\r\nif (!(gfp_mask & __GFP_WAIT) && !in_interrupt()) {\r\nstruct radix_tree_preload *rtp;\r\nrtp = this_cpu_ptr(&radix_tree_preloads);\r\nif (rtp->nr) {\r\nret = rtp->nodes[rtp->nr - 1];\r\nrtp->nodes[rtp->nr - 1] = NULL;\r\nrtp->nr--;\r\n}\r\nkmemleak_update_trace(ret);\r\n}\r\nif (ret == NULL)\r\nret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);\r\nBUG_ON(radix_tree_is_indirect_ptr(ret));\r\nreturn ret;\r\n}\r\nstatic void radix_tree_node_rcu_free(struct rcu_head *head)\r\n{\r\nstruct radix_tree_node *node =\r\ncontainer_of(head, struct radix_tree_node, rcu_head);\r\nint i;\r\nfor (i = 0; i < RADIX_TREE_MAX_TAGS; i++)\r\ntag_clear(node, i, 0);\r\nnode->slots[0] = NULL;\r\nnode->count = 0;\r\nkmem_cache_free(radix_tree_node_cachep, node);\r\n}\r\nstatic inline void\r\nradix_tree_node_free(struct radix_tree_node *node)\r\n{\r\ncall_rcu(&node->rcu_head, radix_tree_node_rcu_free);\r\n}\r\nstatic int __radix_tree_preload(gfp_t gfp_mask)\r\n{\r\nstruct radix_tree_preload *rtp;\r\nstruct radix_tree_node *node;\r\nint ret = -ENOMEM;\r\npreempt_disable();\r\nrtp = this_cpu_ptr(&radix_tree_preloads);\r\nwhile (rtp->nr < ARRAY_SIZE(rtp->nodes)) {\r\npreempt_enable();\r\nnode = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);\r\nif (node == NULL)\r\ngoto out;\r\npreempt_disable();\r\nrtp = this_cpu_ptr(&radix_tree_preloads);\r\nif (rtp->nr < ARRAY_SIZE(rtp->nodes))\r\nrtp->nodes[rtp->nr++] = node;\r\nelse\r\nkmem_cache_free(radix_tree_node_cachep, node);\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nint radix_tree_preload(gfp_t gfp_mask)\r\n{\r\nWARN_ON_ONCE(!(gfp_mask & __GFP_WAIT));\r\nreturn __radix_tree_preload(gfp_mask);\r\n}\r\nint radix_tree_maybe_preload(gfp_t gfp_mask)\r\n{\r\nif (gfp_mask & __GFP_WAIT)\r\nreturn __radix_tree_preload(gfp_mask);\r\npreempt_disable();\r\nreturn 0;\r\n}\r\nstatic inline unsigned long radix_tree_maxindex(unsigned int height)\r\n{\r\nreturn height_to_maxindex[height];\r\n}\r\nstatic int radix_tree_extend(struct radix_tree_root *root, unsigned long index)\r\n{\r\nstruct radix_tree_node *node;\r\nstruct radix_tree_node *slot;\r\nunsigned int height;\r\nint tag;\r\nheight = root->height + 1;\r\nwhile (index > radix_tree_maxindex(height))\r\nheight++;\r\nif (root->rnode == NULL) {\r\nroot->height = height;\r\ngoto out;\r\n}\r\ndo {\r\nunsigned int newheight;\r\nif (!(node = radix_tree_node_alloc(root)))\r\nreturn -ENOMEM;\r\nfor (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++) {\r\nif (root_tag_get(root, tag))\r\ntag_set(node, tag, 0);\r\n}\r\nnewheight = root->height+1;\r\nBUG_ON(newheight & ~RADIX_TREE_HEIGHT_MASK);\r\nnode->path = newheight;\r\nnode->count = 1;\r\nnode->parent = NULL;\r\nslot = root->rnode;\r\nif (newheight > 1) {\r\nslot = indirect_to_ptr(slot);\r\nslot->parent = node;\r\n}\r\nnode->slots[0] = slot;\r\nnode = ptr_to_indirect(node);\r\nrcu_assign_pointer(root->rnode, node);\r\nroot->height = newheight;\r\n} while (height > root->height);\r\nout:\r\nreturn 0;\r\n}\r\nint __radix_tree_create(struct radix_tree_root *root, unsigned long index,\r\nstruct radix_tree_node **nodep, void ***slotp)\r\n{\r\nstruct radix_tree_node *node = NULL, *slot;\r\nunsigned int height, shift, offset;\r\nint error;\r\nif (index > radix_tree_maxindex(root->height)) {\r\nerror = radix_tree_extend(root, index);\r\nif (error)\r\nreturn error;\r\n}\r\nslot = indirect_to_ptr(root->rnode);\r\nheight = root->height;\r\nshift = (height-1) * RADIX_TREE_MAP_SHIFT;\r\noffset = 0;\r\nwhile (height > 0) {\r\nif (slot == NULL) {\r\nif (!(slot = radix_tree_node_alloc(root)))\r\nreturn -ENOMEM;\r\nslot->path = height;\r\nslot->parent = node;\r\nif (node) {\r\nrcu_assign_pointer(node->slots[offset], slot);\r\nnode->count++;\r\nslot->path |= offset << RADIX_TREE_HEIGHT_SHIFT;\r\n} else\r\nrcu_assign_pointer(root->rnode, ptr_to_indirect(slot));\r\n}\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nnode = slot;\r\nslot = node->slots[offset];\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nheight--;\r\n}\r\nif (nodep)\r\n*nodep = node;\r\nif (slotp)\r\n*slotp = node ? node->slots + offset : (void **)&root->rnode;\r\nreturn 0;\r\n}\r\nint radix_tree_insert(struct radix_tree_root *root,\r\nunsigned long index, void *item)\r\n{\r\nstruct radix_tree_node *node;\r\nvoid **slot;\r\nint error;\r\nBUG_ON(radix_tree_is_indirect_ptr(item));\r\nerror = __radix_tree_create(root, index, &node, &slot);\r\nif (error)\r\nreturn error;\r\nif (*slot != NULL)\r\nreturn -EEXIST;\r\nrcu_assign_pointer(*slot, item);\r\nif (node) {\r\nnode->count++;\r\nBUG_ON(tag_get(node, 0, index & RADIX_TREE_MAP_MASK));\r\nBUG_ON(tag_get(node, 1, index & RADIX_TREE_MAP_MASK));\r\n} else {\r\nBUG_ON(root_tag_get(root, 0));\r\nBUG_ON(root_tag_get(root, 1));\r\n}\r\nreturn 0;\r\n}\r\nvoid *__radix_tree_lookup(struct radix_tree_root *root, unsigned long index,\r\nstruct radix_tree_node **nodep, void ***slotp)\r\n{\r\nstruct radix_tree_node *node, *parent;\r\nunsigned int height, shift;\r\nvoid **slot;\r\nnode = rcu_dereference_raw(root->rnode);\r\nif (node == NULL)\r\nreturn NULL;\r\nif (!radix_tree_is_indirect_ptr(node)) {\r\nif (index > 0)\r\nreturn NULL;\r\nif (nodep)\r\n*nodep = NULL;\r\nif (slotp)\r\n*slotp = (void **)&root->rnode;\r\nreturn node;\r\n}\r\nnode = indirect_to_ptr(node);\r\nheight = node->path & RADIX_TREE_HEIGHT_MASK;\r\nif (index > radix_tree_maxindex(height))\r\nreturn NULL;\r\nshift = (height-1) * RADIX_TREE_MAP_SHIFT;\r\ndo {\r\nparent = node;\r\nslot = node->slots + ((index >> shift) & RADIX_TREE_MAP_MASK);\r\nnode = rcu_dereference_raw(*slot);\r\nif (node == NULL)\r\nreturn NULL;\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nheight--;\r\n} while (height > 0);\r\nif (nodep)\r\n*nodep = parent;\r\nif (slotp)\r\n*slotp = slot;\r\nreturn node;\r\n}\r\nvoid **radix_tree_lookup_slot(struct radix_tree_root *root, unsigned long index)\r\n{\r\nvoid **slot;\r\nif (!__radix_tree_lookup(root, index, NULL, &slot))\r\nreturn NULL;\r\nreturn slot;\r\n}\r\nvoid *radix_tree_lookup(struct radix_tree_root *root, unsigned long index)\r\n{\r\nreturn __radix_tree_lookup(root, index, NULL, NULL);\r\n}\r\nvoid *radix_tree_tag_set(struct radix_tree_root *root,\r\nunsigned long index, unsigned int tag)\r\n{\r\nunsigned int height, shift;\r\nstruct radix_tree_node *slot;\r\nheight = root->height;\r\nBUG_ON(index > radix_tree_maxindex(height));\r\nslot = indirect_to_ptr(root->rnode);\r\nshift = (height - 1) * RADIX_TREE_MAP_SHIFT;\r\nwhile (height > 0) {\r\nint offset;\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nif (!tag_get(slot, tag, offset))\r\ntag_set(slot, tag, offset);\r\nslot = slot->slots[offset];\r\nBUG_ON(slot == NULL);\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nheight--;\r\n}\r\nif (slot && !root_tag_get(root, tag))\r\nroot_tag_set(root, tag);\r\nreturn slot;\r\n}\r\nvoid *radix_tree_tag_clear(struct radix_tree_root *root,\r\nunsigned long index, unsigned int tag)\r\n{\r\nstruct radix_tree_node *node = NULL;\r\nstruct radix_tree_node *slot = NULL;\r\nunsigned int height, shift;\r\nint uninitialized_var(offset);\r\nheight = root->height;\r\nif (index > radix_tree_maxindex(height))\r\ngoto out;\r\nshift = height * RADIX_TREE_MAP_SHIFT;\r\nslot = indirect_to_ptr(root->rnode);\r\nwhile (shift) {\r\nif (slot == NULL)\r\ngoto out;\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nnode = slot;\r\nslot = slot->slots[offset];\r\n}\r\nif (slot == NULL)\r\ngoto out;\r\nwhile (node) {\r\nif (!tag_get(node, tag, offset))\r\ngoto out;\r\ntag_clear(node, tag, offset);\r\nif (any_tag_set(node, tag))\r\ngoto out;\r\nindex >>= RADIX_TREE_MAP_SHIFT;\r\noffset = index & RADIX_TREE_MAP_MASK;\r\nnode = node->parent;\r\n}\r\nif (root_tag_get(root, tag))\r\nroot_tag_clear(root, tag);\r\nout:\r\nreturn slot;\r\n}\r\nint radix_tree_tag_get(struct radix_tree_root *root,\r\nunsigned long index, unsigned int tag)\r\n{\r\nunsigned int height, shift;\r\nstruct radix_tree_node *node;\r\nif (!root_tag_get(root, tag))\r\nreturn 0;\r\nnode = rcu_dereference_raw(root->rnode);\r\nif (node == NULL)\r\nreturn 0;\r\nif (!radix_tree_is_indirect_ptr(node))\r\nreturn (index == 0);\r\nnode = indirect_to_ptr(node);\r\nheight = node->path & RADIX_TREE_HEIGHT_MASK;\r\nif (index > radix_tree_maxindex(height))\r\nreturn 0;\r\nshift = (height - 1) * RADIX_TREE_MAP_SHIFT;\r\nfor ( ; ; ) {\r\nint offset;\r\nif (node == NULL)\r\nreturn 0;\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nif (!tag_get(node, tag, offset))\r\nreturn 0;\r\nif (height == 1)\r\nreturn 1;\r\nnode = rcu_dereference_raw(node->slots[offset]);\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nheight--;\r\n}\r\n}\r\nvoid **radix_tree_next_chunk(struct radix_tree_root *root,\r\nstruct radix_tree_iter *iter, unsigned flags)\r\n{\r\nunsigned shift, tag = flags & RADIX_TREE_ITER_TAG_MASK;\r\nstruct radix_tree_node *rnode, *node;\r\nunsigned long index, offset, height;\r\nif ((flags & RADIX_TREE_ITER_TAGGED) && !root_tag_get(root, tag))\r\nreturn NULL;\r\nindex = iter->next_index;\r\nif (!index && iter->index)\r\nreturn NULL;\r\nrnode = rcu_dereference_raw(root->rnode);\r\nif (radix_tree_is_indirect_ptr(rnode)) {\r\nrnode = indirect_to_ptr(rnode);\r\n} else if (rnode && !index) {\r\niter->index = 0;\r\niter->next_index = 1;\r\niter->tags = 1;\r\nreturn (void **)&root->rnode;\r\n} else\r\nreturn NULL;\r\nrestart:\r\nheight = rnode->path & RADIX_TREE_HEIGHT_MASK;\r\nshift = (height - 1) * RADIX_TREE_MAP_SHIFT;\r\noffset = index >> shift;\r\nif (offset >= RADIX_TREE_MAP_SIZE)\r\nreturn NULL;\r\nnode = rnode;\r\nwhile (1) {\r\nif ((flags & RADIX_TREE_ITER_TAGGED) ?\r\n!test_bit(offset, node->tags[tag]) :\r\n!node->slots[offset]) {\r\nif (flags & RADIX_TREE_ITER_CONTIG)\r\nreturn NULL;\r\nif (flags & RADIX_TREE_ITER_TAGGED)\r\noffset = radix_tree_find_next_bit(\r\nnode->tags[tag],\r\nRADIX_TREE_MAP_SIZE,\r\noffset + 1);\r\nelse\r\nwhile (++offset < RADIX_TREE_MAP_SIZE) {\r\nif (node->slots[offset])\r\nbreak;\r\n}\r\nindex &= ~((RADIX_TREE_MAP_SIZE << shift) - 1);\r\nindex += offset << shift;\r\nif (!index)\r\nreturn NULL;\r\nif (offset == RADIX_TREE_MAP_SIZE)\r\ngoto restart;\r\n}\r\nif (!shift)\r\nbreak;\r\nnode = rcu_dereference_raw(node->slots[offset]);\r\nif (node == NULL)\r\ngoto restart;\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\n}\r\niter->index = index;\r\niter->next_index = (index | RADIX_TREE_MAP_MASK) + 1;\r\nif (flags & RADIX_TREE_ITER_TAGGED) {\r\nunsigned tag_long, tag_bit;\r\ntag_long = offset / BITS_PER_LONG;\r\ntag_bit = offset % BITS_PER_LONG;\r\niter->tags = node->tags[tag][tag_long] >> tag_bit;\r\nif (tag_long < RADIX_TREE_TAG_LONGS - 1) {\r\nif (tag_bit)\r\niter->tags |= node->tags[tag][tag_long + 1] <<\r\n(BITS_PER_LONG - tag_bit);\r\niter->next_index = index + BITS_PER_LONG;\r\n}\r\n}\r\nreturn node->slots + offset;\r\n}\r\nunsigned long radix_tree_range_tag_if_tagged(struct radix_tree_root *root,\r\nunsigned long *first_indexp, unsigned long last_index,\r\nunsigned long nr_to_tag,\r\nunsigned int iftag, unsigned int settag)\r\n{\r\nunsigned int height = root->height;\r\nstruct radix_tree_node *node = NULL;\r\nstruct radix_tree_node *slot;\r\nunsigned int shift;\r\nunsigned long tagged = 0;\r\nunsigned long index = *first_indexp;\r\nlast_index = min(last_index, radix_tree_maxindex(height));\r\nif (index > last_index)\r\nreturn 0;\r\nif (!nr_to_tag)\r\nreturn 0;\r\nif (!root_tag_get(root, iftag)) {\r\n*first_indexp = last_index + 1;\r\nreturn 0;\r\n}\r\nif (height == 0) {\r\n*first_indexp = last_index + 1;\r\nroot_tag_set(root, settag);\r\nreturn 1;\r\n}\r\nshift = (height - 1) * RADIX_TREE_MAP_SHIFT;\r\nslot = indirect_to_ptr(root->rnode);\r\nfor (;;) {\r\nunsigned long upindex;\r\nint offset;\r\noffset = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nif (!slot->slots[offset])\r\ngoto next;\r\nif (!tag_get(slot, iftag, offset))\r\ngoto next;\r\nif (shift) {\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nnode = slot;\r\nslot = slot->slots[offset];\r\ncontinue;\r\n}\r\ntagged++;\r\ntag_set(slot, settag, offset);\r\nupindex = index;\r\nwhile (node) {\r\nupindex >>= RADIX_TREE_MAP_SHIFT;\r\noffset = upindex & RADIX_TREE_MAP_MASK;\r\nif (tag_get(node, settag, offset))\r\nbreak;\r\ntag_set(node, settag, offset);\r\nnode = node->parent;\r\n}\r\nnode = NULL;\r\nnext:\r\nindex = ((index >> shift) + 1) << shift;\r\nif (index > last_index || !index)\r\nbreak;\r\nif (tagged >= nr_to_tag)\r\nbreak;\r\nwhile (((index >> shift) & RADIX_TREE_MAP_MASK) == 0) {\r\nslot = slot->parent;\r\nshift += RADIX_TREE_MAP_SHIFT;\r\n}\r\n}\r\nif (tagged > 0)\r\nroot_tag_set(root, settag);\r\n*first_indexp = index;\r\nreturn tagged;\r\n}\r\nunsigned int\r\nradix_tree_gang_lookup(struct radix_tree_root *root, void **results,\r\nunsigned long first_index, unsigned int max_items)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid **slot;\r\nunsigned int ret = 0;\r\nif (unlikely(!max_items))\r\nreturn 0;\r\nradix_tree_for_each_slot(slot, root, &iter, first_index) {\r\nresults[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));\r\nif (!results[ret])\r\ncontinue;\r\nif (++ret == max_items)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nunsigned int\r\nradix_tree_gang_lookup_slot(struct radix_tree_root *root,\r\nvoid ***results, unsigned long *indices,\r\nunsigned long first_index, unsigned int max_items)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid **slot;\r\nunsigned int ret = 0;\r\nif (unlikely(!max_items))\r\nreturn 0;\r\nradix_tree_for_each_slot(slot, root, &iter, first_index) {\r\nresults[ret] = slot;\r\nif (indices)\r\nindices[ret] = iter.index;\r\nif (++ret == max_items)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nunsigned int\r\nradix_tree_gang_lookup_tag(struct radix_tree_root *root, void **results,\r\nunsigned long first_index, unsigned int max_items,\r\nunsigned int tag)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid **slot;\r\nunsigned int ret = 0;\r\nif (unlikely(!max_items))\r\nreturn 0;\r\nradix_tree_for_each_tagged(slot, root, &iter, first_index, tag) {\r\nresults[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));\r\nif (!results[ret])\r\ncontinue;\r\nif (++ret == max_items)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nunsigned int\r\nradix_tree_gang_lookup_tag_slot(struct radix_tree_root *root, void ***results,\r\nunsigned long first_index, unsigned int max_items,\r\nunsigned int tag)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid **slot;\r\nunsigned int ret = 0;\r\nif (unlikely(!max_items))\r\nreturn 0;\r\nradix_tree_for_each_tagged(slot, root, &iter, first_index, tag) {\r\nresults[ret] = slot;\r\nif (++ret == max_items)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long __locate(struct radix_tree_node *slot, void *item,\r\nunsigned long index, unsigned long *found_index)\r\n{\r\nunsigned int shift, height;\r\nunsigned long i;\r\nheight = slot->path & RADIX_TREE_HEIGHT_MASK;\r\nshift = (height-1) * RADIX_TREE_MAP_SHIFT;\r\nfor ( ; height > 1; height--) {\r\ni = (index >> shift) & RADIX_TREE_MAP_MASK;\r\nfor (;;) {\r\nif (slot->slots[i] != NULL)\r\nbreak;\r\nindex &= ~((1UL << shift) - 1);\r\nindex += 1UL << shift;\r\nif (index == 0)\r\ngoto out;\r\ni++;\r\nif (i == RADIX_TREE_MAP_SIZE)\r\ngoto out;\r\n}\r\nshift -= RADIX_TREE_MAP_SHIFT;\r\nslot = rcu_dereference_raw(slot->slots[i]);\r\nif (slot == NULL)\r\ngoto out;\r\n}\r\nfor (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {\r\nif (slot->slots[i] == item) {\r\n*found_index = index + i;\r\nindex = 0;\r\ngoto out;\r\n}\r\n}\r\nindex += RADIX_TREE_MAP_SIZE;\r\nout:\r\nreturn index;\r\n}\r\nunsigned long radix_tree_locate_item(struct radix_tree_root *root, void *item)\r\n{\r\nstruct radix_tree_node *node;\r\nunsigned long max_index;\r\nunsigned long cur_index = 0;\r\nunsigned long found_index = -1;\r\ndo {\r\nrcu_read_lock();\r\nnode = rcu_dereference_raw(root->rnode);\r\nif (!radix_tree_is_indirect_ptr(node)) {\r\nrcu_read_unlock();\r\nif (node == item)\r\nfound_index = 0;\r\nbreak;\r\n}\r\nnode = indirect_to_ptr(node);\r\nmax_index = radix_tree_maxindex(node->path &\r\nRADIX_TREE_HEIGHT_MASK);\r\nif (cur_index > max_index) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\ncur_index = __locate(node, item, cur_index, &found_index);\r\nrcu_read_unlock();\r\ncond_resched();\r\n} while (cur_index != 0 && cur_index <= max_index);\r\nreturn found_index;\r\n}\r\nunsigned long radix_tree_locate_item(struct radix_tree_root *root, void *item)\r\n{\r\nreturn -1;\r\n}\r\nstatic inline void radix_tree_shrink(struct radix_tree_root *root)\r\n{\r\nwhile (root->height > 0) {\r\nstruct radix_tree_node *to_free = root->rnode;\r\nstruct radix_tree_node *slot;\r\nBUG_ON(!radix_tree_is_indirect_ptr(to_free));\r\nto_free = indirect_to_ptr(to_free);\r\nif (to_free->count != 1)\r\nbreak;\r\nif (!to_free->slots[0])\r\nbreak;\r\nslot = to_free->slots[0];\r\nif (root->height > 1) {\r\nslot->parent = NULL;\r\nslot = ptr_to_indirect(slot);\r\n}\r\nroot->rnode = slot;\r\nroot->height--;\r\nif (root->height == 0)\r\n*((unsigned long *)&to_free->slots[0]) |=\r\nRADIX_TREE_INDIRECT_PTR;\r\nradix_tree_node_free(to_free);\r\n}\r\n}\r\nbool __radix_tree_delete_node(struct radix_tree_root *root,\r\nstruct radix_tree_node *node)\r\n{\r\nbool deleted = false;\r\ndo {\r\nstruct radix_tree_node *parent;\r\nif (node->count) {\r\nif (node == indirect_to_ptr(root->rnode)) {\r\nradix_tree_shrink(root);\r\nif (root->height == 0)\r\ndeleted = true;\r\n}\r\nreturn deleted;\r\n}\r\nparent = node->parent;\r\nif (parent) {\r\nunsigned int offset;\r\noffset = node->path >> RADIX_TREE_HEIGHT_SHIFT;\r\nparent->slots[offset] = NULL;\r\nparent->count--;\r\n} else {\r\nroot_tag_clear_all(root);\r\nroot->height = 0;\r\nroot->rnode = NULL;\r\n}\r\nradix_tree_node_free(node);\r\ndeleted = true;\r\nnode = parent;\r\n} while (node);\r\nreturn deleted;\r\n}\r\nvoid *radix_tree_delete_item(struct radix_tree_root *root,\r\nunsigned long index, void *item)\r\n{\r\nstruct radix_tree_node *node;\r\nunsigned int offset;\r\nvoid **slot;\r\nvoid *entry;\r\nint tag;\r\nentry = __radix_tree_lookup(root, index, &node, &slot);\r\nif (!entry)\r\nreturn NULL;\r\nif (item && entry != item)\r\nreturn NULL;\r\nif (!node) {\r\nroot_tag_clear_all(root);\r\nroot->rnode = NULL;\r\nreturn entry;\r\n}\r\noffset = index & RADIX_TREE_MAP_MASK;\r\nfor (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++) {\r\nif (tag_get(node, tag, offset))\r\nradix_tree_tag_clear(root, index, tag);\r\n}\r\nnode->slots[offset] = NULL;\r\nnode->count--;\r\n__radix_tree_delete_node(root, node);\r\nreturn entry;\r\n}\r\nvoid *radix_tree_delete(struct radix_tree_root *root, unsigned long index)\r\n{\r\nreturn radix_tree_delete_item(root, index, NULL);\r\n}\r\nint radix_tree_tagged(struct radix_tree_root *root, unsigned int tag)\r\n{\r\nreturn root_tag_get(root, tag);\r\n}\r\nstatic void\r\nradix_tree_node_ctor(void *arg)\r\n{\r\nstruct radix_tree_node *node = arg;\r\nmemset(node, 0, sizeof(*node));\r\nINIT_LIST_HEAD(&node->private_list);\r\n}\r\nstatic __init unsigned long __maxindex(unsigned int height)\r\n{\r\nunsigned int width = height * RADIX_TREE_MAP_SHIFT;\r\nint shift = RADIX_TREE_INDEX_BITS - width;\r\nif (shift < 0)\r\nreturn ~0UL;\r\nif (shift >= BITS_PER_LONG)\r\nreturn 0UL;\r\nreturn ~0UL >> shift;\r\n}\r\nstatic __init void radix_tree_init_maxindex(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(height_to_maxindex); i++)\r\nheight_to_maxindex[i] = __maxindex(i);\r\n}\r\nstatic int radix_tree_callback(struct notifier_block *nfb,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nint cpu = (long)hcpu;\r\nstruct radix_tree_preload *rtp;\r\nif (action == CPU_DEAD || action == CPU_DEAD_FROZEN) {\r\nrtp = &per_cpu(radix_tree_preloads, cpu);\r\nwhile (rtp->nr) {\r\nkmem_cache_free(radix_tree_node_cachep,\r\nrtp->nodes[rtp->nr-1]);\r\nrtp->nodes[rtp->nr-1] = NULL;\r\nrtp->nr--;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid __init radix_tree_init(void)\r\n{\r\nradix_tree_node_cachep = kmem_cache_create("radix_tree_node",\r\nsizeof(struct radix_tree_node), 0,\r\nSLAB_PANIC | SLAB_RECLAIM_ACCOUNT,\r\nradix_tree_node_ctor);\r\nradix_tree_init_maxindex();\r\nhotcpu_notifier(radix_tree_callback, 0);\r\n}
