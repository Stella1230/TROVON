int drm_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_minor *minor = node->minor;\r\nstruct drm_device *dev = minor->dev;\r\nstruct drm_master *master = minor->master;\r\nif (!master)\r\nreturn 0;\r\nif (master->unique) {\r\nseq_printf(m, "%s %s %s\n",\r\ndev->driver->name,\r\ndev_name(dev->dev), master->unique);\r\n} else {\r\nseq_printf(m, "%s %s\n",\r\ndev->driver->name, dev_name(dev->dev));\r\n}\r\nreturn 0;\r\n}\r\nint drm_vm_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_local_map *map;\r\nstruct drm_map_list *r_list;\r\nconst char *types[] = { "FB", "REG", "SHM", "AGP", "SG", "PCI" };\r\nconst char *type;\r\nint i;\r\nmutex_lock(&dev->struct_mutex);\r\nseq_printf(m, "slot offset size type flags address mtrr\n\n");\r\ni = 0;\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nmap = r_list->map;\r\nif (!map)\r\ncontinue;\r\nif (map->type < 0 || map->type > 5)\r\ntype = "??";\r\nelse\r\ntype = types[map->type];\r\nseq_printf(m, "%4d 0x%016llx 0x%08lx %4.4s 0x%02x 0x%08lx ",\r\ni,\r\n(unsigned long long)map->offset,\r\nmap->size, type, map->flags,\r\n(unsigned long) r_list->user_token);\r\nif (map->mtrr < 0)\r\nseq_printf(m, "none\n");\r\nelse\r\nseq_printf(m, "%4d\n", map->mtrr);\r\ni++;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_bufs_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_device_dma *dma;\r\nint i, seg_pages;\r\nmutex_lock(&dev->struct_mutex);\r\ndma = dev->dma;\r\nif (!dma) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nseq_printf(m, " o size count free segs pages kB\n\n");\r\nfor (i = 0; i <= DRM_MAX_ORDER; i++) {\r\nif (dma->bufs[i].buf_count) {\r\nseg_pages = dma->bufs[i].seg_count * (1 << dma->bufs[i].page_order);\r\nseq_printf(m, "%2d %8d %5d %5d %5d %5d %5ld\n",\r\ni,\r\ndma->bufs[i].buf_size,\r\ndma->bufs[i].buf_count,\r\n0,\r\ndma->bufs[i].seg_count,\r\nseg_pages,\r\nseg_pages * PAGE_SIZE / 1024);\r\n}\r\n}\r\nseq_printf(m, "\n");\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nif (i && !(i % 32))\r\nseq_printf(m, "\n");\r\nseq_printf(m, " %d", dma->buflist[i]->list);\r\n}\r\nseq_printf(m, "\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_vblank_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nint crtc;\r\nmutex_lock(&dev->struct_mutex);\r\nfor (crtc = 0; crtc < dev->num_crtcs; crtc++) {\r\nseq_printf(m, "CRTC %d enable: %d\n",\r\ncrtc, atomic_read(&dev->vblank[crtc].refcount));\r\nseq_printf(m, "CRTC %d counter: %d\n",\r\ncrtc, drm_vblank_count(dev, crtc));\r\nseq_printf(m, "CRTC %d last wait: %d\n",\r\ncrtc, dev->vblank[crtc].last_wait);\r\nseq_printf(m, "CRTC %d in modeset: %d\n",\r\ncrtc, dev->vblank[crtc].inmodeset);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_clients_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_file *priv;\r\nseq_printf(m,\r\n"%20s %5s %3s master a %5s %10s\n",\r\n"command",\r\n"pid",\r\n"dev",\r\n"uid",\r\n"magic");\r\nmutex_lock(&dev->struct_mutex);\r\nlist_for_each_entry_reverse(priv, &dev->filelist, lhead) {\r\nstruct task_struct *task;\r\nrcu_read_lock();\r\ntask = pid_task(priv->pid, PIDTYPE_PID);\r\nseq_printf(m, "%20s %5d %3d %c %c %5d %10u\n",\r\ntask ? task->comm : "<unknown>",\r\npid_vnr(priv->pid),\r\npriv->minor->index,\r\npriv->is_master ? 'y' : 'n',\r\npriv->authenticated ? 'y' : 'n',\r\nfrom_kuid_munged(seq_user_ns(m), priv->uid),\r\npriv->magic);\r\nrcu_read_unlock();\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstatic int drm_gem_one_name_info(int id, void *ptr, void *data)\r\n{\r\nstruct drm_gem_object *obj = ptr;\r\nstruct seq_file *m = data;\r\nseq_printf(m, "%6d %8zd %7d %8d\n",\r\nobj->name, obj->size,\r\nobj->handle_count,\r\natomic_read(&obj->refcount.refcount));\r\nreturn 0;\r\n}\r\nint drm_gem_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nseq_printf(m, " name size handles refcount\n");\r\nmutex_lock(&dev->object_name_lock);\r\nidr_for_each(&dev->object_name_idr, drm_gem_one_name_info, m);\r\nmutex_unlock(&dev->object_name_lock);\r\nreturn 0;\r\n}
