static int spi_xmit(struct spi_device *spi_dev, void *addr, const int len,\r\nenum spi_direction dir)\r\n{\r\nstruct spi_message msg;\r\nint r;\r\nstruct spi_transfer xfer = {\r\n.len = len,\r\n};\r\nif (dir == SPI_DIR_TX)\r\nxfer.tx_buf = addr;\r\nelse\r\nxfer.rx_buf = addr;\r\nif (spi_dev == NULL) {\r\ndev_err(&spi_dev->dev, "SPI device is uninitialized\n");\r\nreturn -ENODEV;\r\n}\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nr = spi_sync(spi_dev, &msg);\r\nif (r < 0)\r\ndev_err(&spi_dev->dev, "%s spi_sync failed %d\n", __func__, r);\r\nreturn r;\r\n}\r\nint s5c73m3_spi_write(struct s5c73m3 *state, const void *addr,\r\nconst unsigned int len, const unsigned int tx_size)\r\n{\r\nstruct spi_device *spi_dev = state->spi_dev;\r\nu32 count = len / tx_size;\r\nu32 extra = len % tx_size;\r\nunsigned int i, j = 0;\r\nu8 padding[32];\r\nint r = 0;\r\nmemset(padding, 0, sizeof(padding));\r\nfor (i = 0; i < count; i++) {\r\nr = spi_xmit(spi_dev, (void *)addr + j, tx_size, SPI_DIR_TX);\r\nif (r < 0)\r\nreturn r;\r\nj += tx_size;\r\n}\r\nif (extra > 0) {\r\nr = spi_xmit(spi_dev, (void *)addr + j, extra, SPI_DIR_TX);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nreturn spi_xmit(spi_dev, padding, sizeof(padding), SPI_DIR_TX);\r\n}\r\nint s5c73m3_spi_read(struct s5c73m3 *state, void *addr,\r\nconst unsigned int len, const unsigned int tx_size)\r\n{\r\nstruct spi_device *spi_dev = state->spi_dev;\r\nu32 count = len / tx_size;\r\nu32 extra = len % tx_size;\r\nunsigned int i, j = 0;\r\nint r = 0;\r\nfor (i = 0; i < count; i++) {\r\nr = spi_xmit(spi_dev, addr + j, tx_size, SPI_DIR_RX);\r\nif (r < 0)\r\nreturn r;\r\nj += tx_size;\r\n}\r\nif (extra > 0)\r\nreturn spi_xmit(spi_dev, addr + j, extra, SPI_DIR_RX);\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_spi_probe(struct spi_device *spi)\r\n{\r\nint r;\r\nstruct s5c73m3 *state = container_of(spi->dev.driver, struct s5c73m3,\r\nspidrv.driver);\r\nspi->bits_per_word = 32;\r\nr = spi_setup(spi);\r\nif (r < 0) {\r\ndev_err(&spi->dev, "spi_setup() failed\n");\r\nreturn r;\r\n}\r\nmutex_lock(&state->lock);\r\nstate->spi_dev = spi;\r\nmutex_unlock(&state->lock);\r\nv4l2_info(&state->sensor_sd, "S5C73M3 SPI probed successfully\n");\r\nreturn 0;\r\n}\r\nstatic int s5c73m3_spi_remove(struct spi_device *spi)\r\n{\r\nreturn 0;\r\n}\r\nint s5c73m3_register_spi_driver(struct s5c73m3 *state)\r\n{\r\nstruct spi_driver *spidrv = &state->spidrv;\r\nspidrv->remove = s5c73m3_spi_remove;\r\nspidrv->probe = s5c73m3_spi_probe;\r\nspidrv->driver.name = S5C73M3_SPI_DRV_NAME;\r\nspidrv->driver.bus = &spi_bus_type;\r\nspidrv->driver.owner = THIS_MODULE;\r\nspidrv->driver.of_match_table = s5c73m3_spi_ids;\r\nreturn spi_register_driver(spidrv);\r\n}\r\nvoid s5c73m3_unregister_spi_driver(struct s5c73m3 *state)\r\n{\r\nspi_unregister_driver(&state->spidrv);\r\n}
