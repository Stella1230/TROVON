static int\r\nqxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nif (pdev->revision < 4) {\r\nDRM_ERROR("qxl too old, doesn't support client_monitors_config,"\r\n" use xf86-video-qxl in user mode");\r\nreturn -EINVAL;\r\n}\r\nreturn drm_get_pci_dev(pdev, ent, &qxl_driver);\r\n}\r\nstatic void\r\nqxl_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\ndrm_put_dev(dev);\r\n}\r\nstatic int qxl_drm_freeze(struct drm_device *dev)\r\n{\r\nstruct pci_dev *pdev = dev->pdev;\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\ndrm_kms_helper_poll_disable(dev);\r\nconsole_lock();\r\nqxl_fbdev_set_suspend(qdev, 1);\r\nconsole_unlock();\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nif (crtc->enabled)\r\n(*crtc_funcs->disable)(crtc);\r\n}\r\nqxl_destroy_monitors_object(qdev);\r\nqxl_surf_evict(qdev);\r\nqxl_vram_evict(qdev);\r\nwhile (!qxl_check_idle(qdev->command_ring));\r\nwhile (!qxl_check_idle(qdev->release_ring))\r\nqxl_queue_garbage_collect(qdev, 1);\r\npci_save_state(pdev);\r\nreturn 0;\r\n}\r\nstatic int qxl_drm_resume(struct drm_device *dev, bool thaw)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nqdev->ram_header->int_mask = QXL_INTERRUPT_MASK;\r\nif (!thaw) {\r\nqxl_reinit_memslots(qdev);\r\nqxl_ring_init_hdr(qdev->release_ring);\r\n}\r\nqxl_create_monitors_object(qdev);\r\ndrm_helper_resume_force_mode(dev);\r\nconsole_lock();\r\nqxl_fbdev_set_suspend(qdev, 0);\r\nconsole_unlock();\r\ndrm_kms_helper_poll_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int qxl_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nint error;\r\nerror = qxl_drm_freeze(drm_dev);\r\nif (error)\r\nreturn error;\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int qxl_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (pci_enable_device(pdev)) {\r\nreturn -EIO;\r\n}\r\nreturn qxl_drm_resume(drm_dev, false);\r\n}\r\nstatic int qxl_pm_thaw(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn qxl_drm_resume(drm_dev, true);\r\n}\r\nstatic int qxl_pm_freeze(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn qxl_drm_freeze(drm_dev);\r\n}\r\nstatic int qxl_pm_restore(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nstruct qxl_device *qdev = drm_dev->dev_private;\r\nqxl_io_reset(qdev);\r\nreturn qxl_drm_resume(drm_dev, false);\r\n}\r\nstatic u32 qxl_noop_get_vblank_counter(struct drm_device *dev, int crtc)\r\n{\r\nreturn dev->vblank[crtc].count.counter;\r\n}\r\nstatic int qxl_noop_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nreturn 0;\r\n}\r\nstatic void qxl_noop_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\n}\r\nstatic int __init qxl_init(void)\r\n{\r\n#ifdef CONFIG_VGA_CONSOLE\r\nif (vgacon_text_force() && qxl_modeset == -1)\r\nreturn -EINVAL;\r\n#endif\r\nif (qxl_modeset == 0)\r\nreturn -EINVAL;\r\nqxl_driver.num_ioctls = qxl_max_ioctls;\r\nreturn drm_pci_init(&qxl_driver, &qxl_pci_driver);\r\n}\r\nstatic void __exit qxl_exit(void)\r\n{\r\ndrm_pci_exit(&qxl_driver, &qxl_pci_driver);\r\n}
