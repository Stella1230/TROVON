void dccp_time_wait(struct sock *sk, int state, int timeo)\r\n{\r\nstruct inet_timewait_sock *tw = NULL;\r\nif (dccp_death_row.tw_count < dccp_death_row.sysctl_max_tw_buckets)\r\ntw = inet_twsk_alloc(sk, state);\r\nif (tw != NULL) {\r\nconst struct inet_connection_sock *icsk = inet_csk(sk);\r\nconst int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tw->tw_family == PF_INET6) {\r\ntw->tw_v6_daddr = sk->sk_v6_daddr;\r\ntw->tw_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\r\ntw->tw_ipv6only = sk->sk_ipv6only;\r\n}\r\n#endif\r\n__inet_twsk_hashdance(tw, sk, &dccp_hashinfo);\r\nif (timeo < rto)\r\ntimeo = rto;\r\ntw->tw_timeout = DCCP_TIMEWAIT_LEN;\r\nif (state == DCCP_TIME_WAIT)\r\ntimeo = DCCP_TIMEWAIT_LEN;\r\ninet_twsk_schedule(tw, &dccp_death_row, timeo,\r\nDCCP_TIMEWAIT_LEN);\r\ninet_twsk_put(tw);\r\n} else {\r\nDCCP_WARN("time wait bucket table overflow\n");\r\n}\r\ndccp_done(sk);\r\n}\r\nstruct sock *dccp_create_openreq_child(struct sock *sk,\r\nconst struct request_sock *req,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);\r\nif (newsk != NULL) {\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\nstruct inet_connection_sock *newicsk = inet_csk(newsk);\r\nstruct dccp_sock *newdp = dccp_sk(newsk);\r\nnewdp->dccps_role = DCCP_ROLE_SERVER;\r\nnewdp->dccps_hc_rx_ackvec = NULL;\r\nnewdp->dccps_service_list = NULL;\r\nnewdp->dccps_service = dreq->dreq_service;\r\nnewdp->dccps_timestamp_echo = dreq->dreq_timestamp_echo;\r\nnewdp->dccps_timestamp_time = dreq->dreq_timestamp_time;\r\nnewicsk->icsk_rto = DCCP_TIMEOUT_INIT;\r\nINIT_LIST_HEAD(&newdp->dccps_featneg);\r\nnewdp->dccps_iss = dreq->dreq_iss;\r\nnewdp->dccps_gss = dreq->dreq_gss;\r\nnewdp->dccps_gar = newdp->dccps_iss;\r\nnewdp->dccps_isr = dreq->dreq_isr;\r\nnewdp->dccps_gsr = dreq->dreq_gsr;\r\nif (dccp_feat_activate_values(newsk, &dreq->dreq_featneg)) {\r\nnewsk->sk_destruct = NULL;\r\nsk_free(newsk);\r\nreturn NULL;\r\n}\r\ndccp_init_xmit_timers(newsk);\r\nDCCP_INC_STATS_BH(DCCP_MIB_PASSIVEOPENS);\r\n}\r\nreturn newsk;\r\n}\r\nstruct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct request_sock **prev)\r\n{\r\nstruct sock *child = NULL;\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\nif (dccp_hdr(skb)->dccph_type == DCCP_PKT_REQUEST) {\r\nif (after48(DCCP_SKB_CB(skb)->dccpd_seq, dreq->dreq_gsr)) {\r\ndccp_pr_debug("Retransmitted REQUEST\n");\r\ndreq->dreq_gsr = DCCP_SKB_CB(skb)->dccpd_seq;\r\ninet_rtx_syn_ack(sk, req);\r\n}\r\nreturn NULL;\r\n}\r\nDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\r\nif (dccp_hdr(skb)->dccph_type != DCCP_PKT_ACK &&\r\ndccp_hdr(skb)->dccph_type != DCCP_PKT_DATAACK)\r\ngoto drop;\r\nif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\r\ndreq->dreq_iss, dreq->dreq_gss)) {\r\ndccp_pr_debug("Invalid ACK number: ack_seq=%llu, "\r\n"dreq_iss=%llu, dreq_gss=%llu\n",\r\n(unsigned long long)\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq,\r\n(unsigned long long) dreq->dreq_iss,\r\n(unsigned long long) dreq->dreq_gss);\r\ngoto drop;\r\n}\r\nif (dccp_parse_options(sk, dreq, skb))\r\ngoto drop;\r\nchild = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);\r\nif (child == NULL)\r\ngoto listen_overflow;\r\ninet_csk_reqsk_queue_unlink(sk, req, prev);\r\ninet_csk_reqsk_queue_removed(sk, req);\r\ninet_csk_reqsk_queue_add(sk, req, child);\r\nout:\r\nreturn child;\r\nlisten_overflow:\r\ndccp_pr_debug("listen_overflow!\n");\r\nDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\r\ndrop:\r\nif (dccp_hdr(skb)->dccph_type != DCCP_PKT_RESET)\r\nreq->rsk_ops->send_reset(sk, skb);\r\ninet_csk_reqsk_queue_drop(sk, req, prev);\r\ngoto out;\r\n}\r\nint dccp_child_process(struct sock *parent, struct sock *child,\r\nstruct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nconst int state = child->sk_state;\r\nif (!sock_owned_by_user(child)) {\r\nret = dccp_rcv_state_process(child, skb, dccp_hdr(skb),\r\nskb->len);\r\nif (state == DCCP_RESPOND && child->sk_state != state)\r\nparent->sk_data_ready(parent);\r\n} else {\r\n__sk_add_backlog(child, skb);\r\n}\r\nbh_unlock_sock(child);\r\nsock_put(child);\r\nreturn ret;\r\n}\r\nvoid dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *rsk)\r\n{\r\nDCCP_BUG("DCCP-ACK packets are never sent in LISTEN/RESPOND state");\r\n}\r\nint dccp_reqsk_init(struct request_sock *req,\r\nstruct dccp_sock const *dp, struct sk_buff const *skb)\r\n{\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\ninet_rsk(req)->ir_rmt_port = dccp_hdr(skb)->dccph_sport;\r\ninet_rsk(req)->ir_num = ntohs(dccp_hdr(skb)->dccph_dport);\r\ninet_rsk(req)->acked = 0;\r\ndreq->dreq_timestamp_echo = 0;\r\nreturn dccp_feat_clone_list(&dp->dccps_featneg, &dreq->dreq_featneg);\r\n}
