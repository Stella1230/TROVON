static int setup_initrd(struct boot_params *params,\r\nunsigned long initrd_load_addr, unsigned long initrd_len)\r\n{\r\nparams->hdr.ramdisk_image = initrd_load_addr & 0xffffffffUL;\r\nparams->hdr.ramdisk_size = initrd_len & 0xffffffffUL;\r\nparams->ext_ramdisk_image = initrd_load_addr >> 32;\r\nparams->ext_ramdisk_size = initrd_len >> 32;\r\nreturn 0;\r\n}\r\nstatic int setup_cmdline(struct kimage *image, struct boot_params *params,\r\nunsigned long bootparams_load_addr,\r\nunsigned long cmdline_offset, char *cmdline,\r\nunsigned long cmdline_len)\r\n{\r\nchar *cmdline_ptr = ((char *)params) + cmdline_offset;\r\nunsigned long cmdline_ptr_phys, len;\r\nuint32_t cmdline_low_32, cmdline_ext_32;\r\nmemcpy(cmdline_ptr, cmdline, cmdline_len);\r\nif (image->type == KEXEC_TYPE_CRASH) {\r\nlen = sprintf(cmdline_ptr + cmdline_len - 1,\r\n" elfcorehdr=0x%lx", image->arch.elf_load_addr);\r\ncmdline_len += len;\r\n}\r\ncmdline_ptr[cmdline_len - 1] = '\0';\r\npr_debug("Final command line is: %s\n", cmdline_ptr);\r\ncmdline_ptr_phys = bootparams_load_addr + cmdline_offset;\r\ncmdline_low_32 = cmdline_ptr_phys & 0xffffffffUL;\r\ncmdline_ext_32 = cmdline_ptr_phys >> 32;\r\nparams->hdr.cmd_line_ptr = cmdline_low_32;\r\nif (cmdline_ext_32)\r\nparams->ext_cmd_line_ptr = cmdline_ext_32;\r\nreturn 0;\r\n}\r\nstatic int setup_e820_entries(struct boot_params *params)\r\n{\r\nunsigned int nr_e820_entries;\r\nnr_e820_entries = e820_saved.nr_map;\r\nif (nr_e820_entries > E820MAX)\r\nnr_e820_entries = E820MAX;\r\nparams->e820_entries = nr_e820_entries;\r\nmemcpy(&params->e820_map, &e820_saved.map,\r\nnr_e820_entries * sizeof(struct e820entry));\r\nreturn 0;\r\n}\r\nstatic int setup_efi_info_memmap(struct boot_params *params,\r\nunsigned long params_load_addr,\r\nunsigned int efi_map_offset,\r\nunsigned int efi_map_sz)\r\n{\r\nvoid *efi_map = (void *)params + efi_map_offset;\r\nunsigned long efi_map_phys_addr = params_load_addr + efi_map_offset;\r\nstruct efi_info *ei = &params->efi_info;\r\nif (!efi_map_sz)\r\nreturn 0;\r\nefi_runtime_map_copy(efi_map, efi_map_sz);\r\nei->efi_memmap = efi_map_phys_addr & 0xffffffff;\r\nei->efi_memmap_hi = efi_map_phys_addr >> 32;\r\nei->efi_memmap_size = efi_map_sz;\r\nreturn 0;\r\n}\r\nstatic int\r\nprepare_add_efi_setup_data(struct boot_params *params,\r\nunsigned long params_load_addr,\r\nunsigned int efi_setup_data_offset)\r\n{\r\nunsigned long setup_data_phys;\r\nstruct setup_data *sd = (void *)params + efi_setup_data_offset;\r\nstruct efi_setup_data *esd = (void *)sd + sizeof(struct setup_data);\r\nesd->fw_vendor = efi.fw_vendor;\r\nesd->runtime = efi.runtime;\r\nesd->tables = efi.config_table;\r\nesd->smbios = efi.smbios;\r\nsd->type = SETUP_EFI;\r\nsd->len = sizeof(struct efi_setup_data);\r\nsetup_data_phys = params_load_addr + efi_setup_data_offset;\r\nsd->next = params->hdr.setup_data;\r\nparams->hdr.setup_data = setup_data_phys;\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_efi_state(struct boot_params *params, unsigned long params_load_addr,\r\nunsigned int efi_map_offset, unsigned int efi_map_sz,\r\nunsigned int efi_setup_data_offset)\r\n{\r\nstruct efi_info *current_ei = &boot_params.efi_info;\r\nstruct efi_info *ei = &params->efi_info;\r\nif (!current_ei->efi_memmap_size)\r\nreturn 0;\r\nif (efi_enabled(EFI_OLD_MEMMAP))\r\nreturn 0;\r\nei->efi_loader_signature = current_ei->efi_loader_signature;\r\nei->efi_systab = current_ei->efi_systab;\r\nei->efi_systab_hi = current_ei->efi_systab_hi;\r\nei->efi_memdesc_version = current_ei->efi_memdesc_version;\r\nei->efi_memdesc_size = efi_get_runtime_map_desc_size();\r\nsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\r\nefi_map_sz);\r\nprepare_add_efi_setup_data(params, params_load_addr,\r\nefi_setup_data_offset);\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_boot_parameters(struct kimage *image, struct boot_params *params,\r\nunsigned long params_load_addr,\r\nunsigned int efi_map_offset, unsigned int efi_map_sz,\r\nunsigned int efi_setup_data_offset)\r\n{\r\nunsigned int nr_e820_entries;\r\nunsigned long long mem_k, start, end;\r\nint i, ret = 0;\r\nparams->hdr.hardware_subarch = boot_params.hdr.hardware_subarch;\r\nmemcpy(&params->screen_info, &boot_params.screen_info,\r\nsizeof(struct screen_info));\r\nparams->screen_info.ext_mem_k = 0;\r\nparams->alt_mem_k = 0;\r\nmemset(&params->apm_bios_info, 0, sizeof(params->apm_bios_info));\r\nmemset(&params->hd0_info, 0, sizeof(params->hd0_info));\r\nmemset(&params->hd1_info, 0, sizeof(params->hd1_info));\r\nparams->sys_desc_table.length = 0;\r\nif (image->type == KEXEC_TYPE_CRASH) {\r\nret = crash_setup_memmap_entries(image, params);\r\nif (ret)\r\nreturn ret;\r\n} else\r\nsetup_e820_entries(params);\r\nnr_e820_entries = params->e820_entries;\r\nfor (i = 0; i < nr_e820_entries; i++) {\r\nif (params->e820_map[i].type != E820_RAM)\r\ncontinue;\r\nstart = params->e820_map[i].addr;\r\nend = params->e820_map[i].addr + params->e820_map[i].size - 1;\r\nif ((start <= 0x100000) && end > 0x100000) {\r\nmem_k = (end >> 10) - (0x100000 >> 10);\r\nparams->screen_info.ext_mem_k = mem_k;\r\nparams->alt_mem_k = mem_k;\r\nif (mem_k > 0xfc00)\r\nparams->screen_info.ext_mem_k = 0xfc00;\r\nif (mem_k > 0xffffffff)\r\nparams->alt_mem_k = 0xffffffff;\r\n}\r\n}\r\n#ifdef CONFIG_EFI\r\nsetup_efi_state(params, params_load_addr, efi_map_offset, efi_map_sz,\r\nefi_setup_data_offset);\r\n#endif\r\nmemcpy(params->eddbuf, boot_params.eddbuf,\r\nEDDMAXNR * sizeof(struct edd_info));\r\nparams->eddbuf_entries = boot_params.eddbuf_entries;\r\nmemcpy(params->edd_mbr_sig_buffer, boot_params.edd_mbr_sig_buffer,\r\nEDD_MBR_SIG_MAX * sizeof(unsigned int));\r\nreturn ret;\r\n}\r\nstatic int bzImage64_probe(const char *buf, unsigned long len)\r\n{\r\nint ret = -ENOEXEC;\r\nstruct setup_header *header;\r\nif (len < 2 * 512) {\r\npr_err("File is too short to be a bzImage\n");\r\nreturn ret;\r\n}\r\nheader = (struct setup_header *)(buf + offsetof(struct boot_params, hdr));\r\nif (memcmp((char *)&header->header, "HdrS", 4) != 0) {\r\npr_err("Not a bzImage\n");\r\nreturn ret;\r\n}\r\nif (header->boot_flag != 0xAA55) {\r\npr_err("No x86 boot sector present\n");\r\nreturn ret;\r\n}\r\nif (header->version < 0x020C) {\r\npr_err("Must be at least protocol version 2.12\n");\r\nreturn ret;\r\n}\r\nif (!(header->loadflags & LOADED_HIGH)) {\r\npr_err("zImage not a bzImage\n");\r\nreturn ret;\r\n}\r\nif (!(header->xloadflags & XLF_KERNEL_64)) {\r\npr_err("Not a bzImage64. XLF_KERNEL_64 is not set.\n");\r\nreturn ret;\r\n}\r\nif (!(header->xloadflags & XLF_CAN_BE_LOADED_ABOVE_4G)) {\r\npr_err("XLF_CAN_BE_LOADED_ABOVE_4G is not set.\n");\r\nreturn ret;\r\n}\r\nif (efi_enabled(EFI_RUNTIME_SERVICES) && !efi_enabled(EFI_64BIT)) {\r\npr_debug("EFI is 32 bit. Can't load kernel above 4G.\n");\r\nreturn ret;\r\n}\r\npr_debug("It's a relocatable bzImage64\n");\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void *bzImage64_load(struct kimage *image, char *kernel,\r\nunsigned long kernel_len, char *initrd,\r\nunsigned long initrd_len, char *cmdline,\r\nunsigned long cmdline_len)\r\n{\r\nstruct setup_header *header;\r\nint setup_sects, kern16_size, ret = 0;\r\nunsigned long setup_header_size, params_cmdline_sz, params_misc_sz;\r\nstruct boot_params *params;\r\nunsigned long bootparam_load_addr, kernel_load_addr, initrd_load_addr;\r\nunsigned long purgatory_load_addr;\r\nunsigned long kernel_bufsz, kernel_memsz, kernel_align;\r\nchar *kernel_buf;\r\nstruct bzimage64_data *ldata;\r\nstruct kexec_entry64_regs regs64;\r\nvoid *stack;\r\nunsigned int setup_hdr_offset = offsetof(struct boot_params, hdr);\r\nunsigned int efi_map_offset, efi_map_sz, efi_setup_data_offset;\r\nheader = (struct setup_header *)(kernel + setup_hdr_offset);\r\nsetup_sects = header->setup_sects;\r\nif (setup_sects == 0)\r\nsetup_sects = 4;\r\nkern16_size = (setup_sects + 1) * 512;\r\nif (kernel_len < kern16_size) {\r\npr_err("bzImage truncated\n");\r\nreturn ERR_PTR(-ENOEXEC);\r\n}\r\nif (cmdline_len > header->cmdline_size) {\r\npr_err("Kernel command line too long\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (cmdline_len + MAX_ELFCOREHDR_STR_LEN > header->cmdline_size) {\r\npr_debug("Appending elfcorehdr=<addr> to command line exceeds maximum allowed length\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (image->type == KEXEC_TYPE_CRASH) {\r\nret = crash_load_segments(image);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\nret = kexec_load_purgatory(image, MIN_PURGATORY_ADDR, ULONG_MAX, 1,\r\n&purgatory_load_addr);\r\nif (ret) {\r\npr_err("Loading purgatory failed\n");\r\nreturn ERR_PTR(ret);\r\n}\r\npr_debug("Loaded purgatory at 0x%lx\n", purgatory_load_addr);\r\nefi_map_sz = efi_get_runtime_map_size();\r\nefi_map_sz = ALIGN(efi_map_sz, 16);\r\nparams_cmdline_sz = sizeof(struct boot_params) + cmdline_len +\r\nMAX_ELFCOREHDR_STR_LEN;\r\nparams_cmdline_sz = ALIGN(params_cmdline_sz, 16);\r\nparams_misc_sz = params_cmdline_sz + efi_map_sz +\r\nsizeof(struct setup_data) +\r\nsizeof(struct efi_setup_data);\r\nparams = kzalloc(params_misc_sz, GFP_KERNEL);\r\nif (!params)\r\nreturn ERR_PTR(-ENOMEM);\r\nefi_map_offset = params_cmdline_sz;\r\nefi_setup_data_offset = efi_map_offset + efi_map_sz;\r\nsetup_header_size = 0x0202 + kernel[0x0201] - setup_hdr_offset;\r\nmemcpy(&params->hdr, (kernel + setup_hdr_offset), setup_header_size);\r\nret = kexec_add_buffer(image, (char *)params, params_misc_sz,\r\nparams_misc_sz, 16, MIN_BOOTPARAM_ADDR,\r\nULONG_MAX, 1, &bootparam_load_addr);\r\nif (ret)\r\ngoto out_free_params;\r\npr_debug("Loaded boot_param, command line and misc at 0x%lx bufsz=0x%lx memsz=0x%lx\n",\r\nbootparam_load_addr, params_misc_sz, params_misc_sz);\r\nkernel_buf = kernel + kern16_size;\r\nkernel_bufsz = kernel_len - kern16_size;\r\nkernel_memsz = PAGE_ALIGN(header->init_size);\r\nkernel_align = header->kernel_alignment;\r\nret = kexec_add_buffer(image, kernel_buf,\r\nkernel_bufsz, kernel_memsz, kernel_align,\r\nMIN_KERNEL_LOAD_ADDR, ULONG_MAX, 1,\r\n&kernel_load_addr);\r\nif (ret)\r\ngoto out_free_params;\r\npr_debug("Loaded 64bit kernel at 0x%lx bufsz=0x%lx memsz=0x%lx\n",\r\nkernel_load_addr, kernel_memsz, kernel_memsz);\r\nif (initrd) {\r\nret = kexec_add_buffer(image, initrd, initrd_len, initrd_len,\r\nPAGE_SIZE, MIN_INITRD_LOAD_ADDR,\r\nULONG_MAX, 1, &initrd_load_addr);\r\nif (ret)\r\ngoto out_free_params;\r\npr_debug("Loaded initrd at 0x%lx bufsz=0x%lx memsz=0x%lx\n",\r\ninitrd_load_addr, initrd_len, initrd_len);\r\nsetup_initrd(params, initrd_load_addr, initrd_len);\r\n}\r\nsetup_cmdline(image, params, bootparam_load_addr,\r\nsizeof(struct boot_params), cmdline, cmdline_len);\r\nparams->hdr.type_of_loader = 0x0D << 4;\r\nparams->hdr.loadflags = 0;\r\nret = kexec_purgatory_get_set_symbol(image, "entry64_regs", &regs64,\r\nsizeof(regs64), 1);\r\nif (ret)\r\ngoto out_free_params;\r\nregs64.rbx = 0;\r\nregs64.rsi = bootparam_load_addr;\r\nregs64.rip = kernel_load_addr + 0x200;\r\nstack = kexec_purgatory_get_symbol_addr(image, "stack_end");\r\nif (IS_ERR(stack)) {\r\npr_err("Could not find address of symbol stack_end\n");\r\nret = -EINVAL;\r\ngoto out_free_params;\r\n}\r\nregs64.rsp = (unsigned long)stack;\r\nret = kexec_purgatory_get_set_symbol(image, "entry64_regs", &regs64,\r\nsizeof(regs64), 0);\r\nif (ret)\r\ngoto out_free_params;\r\nret = setup_boot_parameters(image, params, bootparam_load_addr,\r\nefi_map_offset, efi_map_sz,\r\nefi_setup_data_offset);\r\nif (ret)\r\ngoto out_free_params;\r\nldata = kzalloc(sizeof(struct bzimage64_data), GFP_KERNEL);\r\nif (!ldata) {\r\nret = -ENOMEM;\r\ngoto out_free_params;\r\n}\r\nldata->bootparams_buf = params;\r\nreturn ldata;\r\nout_free_params:\r\nkfree(params);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int bzImage64_cleanup(void *loader_data)\r\n{\r\nstruct bzimage64_data *ldata = loader_data;\r\nif (!ldata)\r\nreturn 0;\r\nkfree(ldata->bootparams_buf);\r\nldata->bootparams_buf = NULL;\r\nreturn 0;\r\n}\r\nstatic int bzImage64_verify_sig(const char *kernel, unsigned long kernel_len)\r\n{\r\nbool trusted;\r\nint ret;\r\nret = verify_pefile_signature(kernel, kernel_len,\r\nsystem_trusted_keyring, &trusted);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!trusted)\r\nreturn -EKEYREJECTED;\r\nreturn 0;\r\n}
