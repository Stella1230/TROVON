static int bma180_get_data_reg(struct bma180_data *data, enum bma180_chan chan)\r\n{\r\nint ret;\r\nif (data->sleep_state)\r\nreturn -EBUSY;\r\nswitch (chan) {\r\ncase TEMP:\r\nret = i2c_smbus_read_byte_data(data->client, BMA180_TEMP);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "failed to read temp register\n");\r\nbreak;\r\ndefault:\r\nret = i2c_smbus_read_word_data(data->client,\r\nBMA180_ACC_X_LSB + chan * 2);\r\nif (ret < 0)\r\ndev_err(&data->client->dev,\r\n"failed to read accel_%c register\n",\r\n'x' + chan);\r\n}\r\nreturn ret;\r\n}\r\nstatic int bma180_set_bits(struct bma180_data *data, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret = i2c_smbus_read_byte_data(data->client, reg);\r\nu8 reg_val = (ret & ~mask) | (val << (ffs(mask) - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_write_byte_data(data->client, reg, reg_val);\r\n}\r\nstatic int bma180_reset_intr(struct bma180_data *data)\r\n{\r\nint ret = bma180_set_bits(data, data->part_info->int_reset_reg,\r\ndata->part_info->int_reset_mask, 1);\r\nif (ret)\r\ndev_err(&data->client->dev, "failed to reset interrupt\n");\r\nreturn ret;\r\n}\r\nstatic int bma180_set_new_data_intr_state(struct bma180_data *data, bool state)\r\n{\r\nint ret = bma180_set_bits(data, data->part_info->int_enable_reg,\r\ndata->part_info->int_enable_mask, state);\r\nif (ret)\r\ngoto err;\r\nret = bma180_reset_intr(data);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_err(&data->client->dev,\r\n"failed to set new data interrupt state %d\n", state);\r\nreturn ret;\r\n}\r\nstatic int bma180_set_sleep_state(struct bma180_data *data, bool state)\r\n{\r\nint ret = bma180_set_bits(data, data->part_info->sleep_reg,\r\ndata->part_info->sleep_mask, state);\r\nif (ret) {\r\ndev_err(&data->client->dev,\r\n"failed to set sleep state %d\n", state);\r\nreturn ret;\r\n}\r\ndata->sleep_state = state;\r\nreturn 0;\r\n}\r\nstatic int bma180_set_ee_writing_state(struct bma180_data *data, bool state)\r\n{\r\nint ret = bma180_set_bits(data, BMA180_CTRL_REG0, BMA180_EE_W, state);\r\nif (ret)\r\ndev_err(&data->client->dev,\r\n"failed to set ee writing state %d\n", state);\r\nreturn ret;\r\n}\r\nstatic int bma180_set_bw(struct bma180_data *data, int val)\r\n{\r\nint ret, i;\r\nif (data->sleep_state)\r\nreturn -EBUSY;\r\nfor (i = 0; i < data->part_info->num_bw; ++i) {\r\nif (data->part_info->bw_table[i] == val) {\r\nret = bma180_set_bits(data, data->part_info->bw_reg,\r\ndata->part_info->bw_mask, i);\r\nif (ret) {\r\ndev_err(&data->client->dev,\r\n"failed to set bandwidth\n");\r\nreturn ret;\r\n}\r\ndata->bw = val;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bma180_set_scale(struct bma180_data *data, int val)\r\n{\r\nint ret, i;\r\nif (data->sleep_state)\r\nreturn -EBUSY;\r\nfor (i = 0; i < data->part_info->num_scales; ++i)\r\nif (data->part_info->scale_table[i] == val) {\r\nret = bma180_set_bits(data, data->part_info->scale_reg,\r\ndata->part_info->scale_mask, i);\r\nif (ret) {\r\ndev_err(&data->client->dev,\r\n"failed to set scale\n");\r\nreturn ret;\r\n}\r\ndata->scale = val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bma180_set_pmode(struct bma180_data *data, bool mode)\r\n{\r\nu8 reg_val = mode ? data->part_info->lowpower_val : 0;\r\nint ret = bma180_set_bits(data, data->part_info->power_reg,\r\ndata->part_info->power_mask, reg_val);\r\nif (ret) {\r\ndev_err(&data->client->dev, "failed to set power mode\n");\r\nreturn ret;\r\n}\r\ndata->pmode = mode;\r\nreturn 0;\r\n}\r\nstatic int bma180_soft_reset(struct bma180_data *data)\r\n{\r\nint ret = i2c_smbus_write_byte_data(data->client,\r\ndata->part_info->softreset_reg, BMA180_RESET_VAL);\r\nif (ret)\r\ndev_err(&data->client->dev, "failed to reset the chip\n");\r\nreturn ret;\r\n}\r\nstatic int bma180_chip_init(struct bma180_data *data)\r\n{\r\nint ret = i2c_smbus_read_byte_data(data->client, BMA180_CHIP_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != BMA180_ID_REG_VAL)\r\nreturn -ENODEV;\r\nret = bma180_soft_reset(data);\r\nif (ret)\r\nreturn ret;\r\nmsleep(20);\r\nret = bma180_set_new_data_intr_state(data, false);\r\nif (ret)\r\nreturn ret;\r\nreturn bma180_set_pmode(data, false);\r\n}\r\nstatic int bma180_chip_config(struct bma180_data *data)\r\n{\r\nint ret = bma180_chip_init(data);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_bits(data, BMA180_CTRL_REG0, BMA180_DIS_WAKE_UP, 1);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_ee_writing_state(data, true);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_bits(data, BMA180_OFFSET_LSB1, BMA180_SMP_SKIP, 1);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_bw(data, 20);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_scale(data, 2452);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_err(&data->client->dev, "failed to config the chip\n");\r\nreturn ret;\r\n}\r\nstatic int bma250_chip_config(struct bma180_data *data)\r\n{\r\nint ret = bma180_chip_init(data);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_bw(data, 16);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_scale(data, 38344);\r\nif (ret)\r\ngoto err;\r\nret = bma180_set_bits(data, BMA250_INT_MAP_REG,\r\nBMA250_INT1_DATA_MASK, 1);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_err(&data->client->dev, "failed to config the chip\n");\r\nreturn ret;\r\n}\r\nstatic void bma180_chip_disable(struct bma180_data *data)\r\n{\r\nif (bma180_set_new_data_intr_state(data, false))\r\ngoto err;\r\nif (bma180_set_ee_writing_state(data, false))\r\ngoto err;\r\nif (bma180_set_sleep_state(data, true))\r\ngoto err;\r\nreturn;\r\nerr:\r\ndev_err(&data->client->dev, "failed to disable the chip\n");\r\n}\r\nstatic void bma250_chip_disable(struct bma180_data *data)\r\n{\r\nif (bma180_set_new_data_intr_state(data, false))\r\ngoto err;\r\nif (bma180_set_sleep_state(data, true))\r\ngoto err;\r\nreturn;\r\nerr:\r\ndev_err(&data->client->dev, "failed to disable the chip\n");\r\n}\r\nstatic ssize_t bma180_show_avail(char *buf, const int *vals, unsigned n,\r\nbool micros)\r\n{\r\nsize_t len = 0;\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nif (!vals[i])\r\ncontinue;\r\nlen += scnprintf(buf + len, PAGE_SIZE - len,\r\nmicros ? "0.%06d " : "%d ", vals[i]);\r\n}\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t bma180_show_filter_freq_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bma180_data *data = iio_priv(dev_to_iio_dev(dev));\r\nreturn bma180_show_avail(buf, data->part_info->bw_table,\r\ndata->part_info->num_bw, false);\r\n}\r\nstatic ssize_t bma180_show_scale_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bma180_data *data = iio_priv(dev_to_iio_dev(dev));\r\nreturn bma180_show_avail(buf, data->part_info->scale_table,\r\ndata->part_info->num_scales, true);\r\n}\r\nstatic int bma180_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2,\r\nlong mask)\r\n{\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&data->mutex);\r\nif (iio_buffer_enabled(indio_dev)) {\r\nmutex_unlock(&data->mutex);\r\nreturn -EBUSY;\r\n}\r\nret = bma180_get_data_reg(data, chan->scan_index);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(ret >> chan->scan_type.shift,\r\nchan->scan_type.realbits - 1);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\n*val = data->bw;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\n*val = 0;\r\n*val2 = data->scale;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 500;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = 48;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bma180_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val)\r\nreturn -EINVAL;\r\nmutex_lock(&data->mutex);\r\nret = bma180_set_scale(data, val2);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nif (val2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->mutex);\r\nret = bma180_set_bw(data, val);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bma180_get_power_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nreturn data->pmode;\r\n}\r\nstatic int bma180_set_power_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, unsigned int mode)\r\n{\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = bma180_set_pmode(data, mode);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t bma180_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint64_t time_ns = iio_get_time_ns();\r\nint bit, ret, i = 0;\r\nmutex_lock(&data->mutex);\r\nfor_each_set_bit(bit, indio_dev->buffer->scan_mask,\r\nindio_dev->masklength) {\r\nret = bma180_get_data_reg(data, bit);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\ngoto err;\r\n}\r\n((s16 *)data->buff)[i++] = ret;\r\n}\r\nmutex_unlock(&data->mutex);\r\niio_push_to_buffers_with_timestamp(indio_dev, data->buff, time_ns);\r\nerr:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bma180_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nreturn bma180_set_new_data_intr_state(data, state);\r\n}\r\nstatic int bma180_trig_try_reen(struct iio_trigger *trig)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nreturn bma180_reset_intr(data);\r\n}\r\nstatic int bma180_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bma180_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->part_info = &bma180_part_info[id->driver_data];\r\nret = data->part_info->chip_config(data);\r\nif (ret < 0)\r\ngoto err_chip_disable;\r\nmutex_init(&data->mutex);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = data->part_info->channels;\r\nindio_dev->num_channels = data->part_info->num_channels;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &bma180_info;\r\nif (client->irq > 0) {\r\ndata->trig = iio_trigger_alloc("%s-dev%d", indio_dev->name,\r\nindio_dev->id);\r\nif (!data->trig) {\r\nret = -ENOMEM;\r\ngoto err_chip_disable;\r\n}\r\nret = devm_request_irq(&client->dev, client->irq,\r\niio_trigger_generic_data_rdy_poll, IRQF_TRIGGER_RISING,\r\n"bma180_event", data->trig);\r\nif (ret) {\r\ndev_err(&client->dev, "unable to request IRQ\n");\r\ngoto err_trigger_free;\r\n}\r\ndata->trig->dev.parent = &client->dev;\r\ndata->trig->ops = &bma180_trigger_ops;\r\niio_trigger_set_drvdata(data->trig, indio_dev);\r\nindio_dev->trig = iio_trigger_get(data->trig);\r\nret = iio_trigger_register(data->trig);\r\nif (ret)\r\ngoto err_trigger_free;\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nbma180_trigger_handler, NULL);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to setup iio triggered buffer\n");\r\ngoto err_trigger_unregister;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to register iio device\n");\r\ngoto err_buffer_cleanup;\r\n}\r\nreturn 0;\r\nerr_buffer_cleanup:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerr_trigger_unregister:\r\nif (data->trig)\r\niio_trigger_unregister(data->trig);\r\nerr_trigger_free:\r\niio_trigger_free(data->trig);\r\nerr_chip_disable:\r\ndata->part_info->chip_disable(data);\r\nreturn ret;\r\n}\r\nstatic int bma180_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nif (data->trig) {\r\niio_trigger_unregister(data->trig);\r\niio_trigger_free(data->trig);\r\n}\r\nmutex_lock(&data->mutex);\r\ndata->part_info->chip_disable(data);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bma180_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = bma180_set_sleep_state(data, true);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int bma180_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct bma180_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = bma180_set_sleep_state(data, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}
