static int s35390a_set_reg(struct s35390a *s35390a, int reg, char *buf, int len)\r\n{\r\nstruct i2c_client *client = s35390a->client[reg];\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.len = len,\r\n.buf = buf\r\n},\r\n};\r\nif ((i2c_transfer(client->adapter, msg, 1)) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int s35390a_get_reg(struct s35390a *s35390a, int reg, char *buf, int len)\r\n{\r\nstruct i2c_client *client = s35390a->client[reg];\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf\r\n},\r\n};\r\nif ((i2c_transfer(client->adapter, msg, 1)) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int s35390a_reset(struct s35390a *s35390a)\r\n{\r\nchar buf[1];\r\nif (s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf)) < 0)\r\nreturn -EIO;\r\nif (!(buf[0] & (S35390A_FLAG_POC | S35390A_FLAG_BLD)))\r\nreturn 0;\r\nbuf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);\r\nbuf[0] &= 0xf0;\r\nreturn s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));\r\n}\r\nstatic int s35390a_disable_test_mode(struct s35390a *s35390a)\r\n{\r\nchar buf[1];\r\nif (s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf)) < 0)\r\nreturn -EIO;\r\nif (!(buf[0] & S35390A_FLAG_TEST))\r\nreturn 0;\r\nbuf[0] &= ~S35390A_FLAG_TEST;\r\nreturn s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf));\r\n}\r\nstatic char s35390a_hr2reg(struct s35390a *s35390a, int hour)\r\n{\r\nif (s35390a->twentyfourhour)\r\nreturn bin2bcd(hour);\r\nif (hour < 12)\r\nreturn bin2bcd(hour);\r\nreturn 0x40 | bin2bcd(hour - 12);\r\n}\r\nstatic int s35390a_reg2hr(struct s35390a *s35390a, char reg)\r\n{\r\nunsigned hour;\r\nif (s35390a->twentyfourhour)\r\nreturn bcd2bin(reg & 0x3f);\r\nhour = bcd2bin(reg & 0x3f);\r\nif (reg & 0x40)\r\nhour += 12;\r\nreturn hour;\r\n}\r\nstatic int s35390a_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nint i, err;\r\nchar buf[7];\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d mday=%d, "\r\n"mon=%d, year=%d, wday=%d\n", __func__, tm->tm_sec,\r\ntm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\r\ntm->tm_wday);\r\nbuf[S35390A_BYTE_YEAR] = bin2bcd(tm->tm_year - 100);\r\nbuf[S35390A_BYTE_MONTH] = bin2bcd(tm->tm_mon + 1);\r\nbuf[S35390A_BYTE_DAY] = bin2bcd(tm->tm_mday);\r\nbuf[S35390A_BYTE_WDAY] = bin2bcd(tm->tm_wday);\r\nbuf[S35390A_BYTE_HOURS] = s35390a_hr2reg(s35390a, tm->tm_hour);\r\nbuf[S35390A_BYTE_MINS] = bin2bcd(tm->tm_min);\r\nbuf[S35390A_BYTE_SECS] = bin2bcd(tm->tm_sec);\r\nfor (i = 0; i < 7; ++i)\r\nbuf[i] = bitrev8(buf[i]);\r\nerr = s35390a_set_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\r\nreturn err;\r\n}\r\nstatic int s35390a_get_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nchar buf[7];\r\nint i, err;\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 7; ++i)\r\nbuf[i] = bitrev8(buf[i]);\r\ntm->tm_sec = bcd2bin(buf[S35390A_BYTE_SECS]);\r\ntm->tm_min = bcd2bin(buf[S35390A_BYTE_MINS]);\r\ntm->tm_hour = s35390a_reg2hr(s35390a, buf[S35390A_BYTE_HOURS]);\r\ntm->tm_wday = bcd2bin(buf[S35390A_BYTE_WDAY]);\r\ntm->tm_mday = bcd2bin(buf[S35390A_BYTE_DAY]);\r\ntm->tm_mon = bcd2bin(buf[S35390A_BYTE_MONTH]) - 1;\r\ntm->tm_year = bcd2bin(buf[S35390A_BYTE_YEAR]) + 100;\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d, mday=%d, "\r\n"mon=%d, year=%d, wday=%d\n", __func__, tm->tm_sec,\r\ntm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\r\ntm->tm_wday);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int s35390a_set_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nchar buf[3], sts = 0;\r\nint err, i;\r\ndev_dbg(&client->dev, "%s: alm is secs=%d, mins=%d, hours=%d mday=%d, "\\r\n"mon=%d, year=%d, wday=%d\n", __func__, alm->time.tm_sec,\r\nalm->time.tm_min, alm->time.tm_hour, alm->time.tm_mday,\r\nalm->time.tm_mon, alm->time.tm_year, alm->time.tm_wday);\r\nerr = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\r\nif (err < 0)\r\nreturn err;\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, &sts, sizeof(sts));\r\nif (err < 0)\r\nreturn err;\r\nif (alm->enabled)\r\nsts = S35390A_INT2_MODE_ALARM;\r\nelse\r\nsts = S35390A_INT2_MODE_NOINTR;\r\nsts = bitrev8(sts);\r\nerr = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\r\nif (err < 0)\r\nreturn err;\r\nif (alm->time.tm_wday != -1)\r\nbuf[S35390A_ALRM_BYTE_WDAY] = bin2bcd(alm->time.tm_wday) | 0x80;\r\nbuf[S35390A_ALRM_BYTE_HOURS] = s35390a_hr2reg(s35390a,\r\nalm->time.tm_hour) | 0x80;\r\nbuf[S35390A_ALRM_BYTE_MINS] = bin2bcd(alm->time.tm_min) | 0x80;\r\nif (alm->time.tm_hour >= 12)\r\nbuf[S35390A_ALRM_BYTE_HOURS] |= 0x40;\r\nfor (i = 0; i < 3; ++i)\r\nbuf[i] = bitrev8(buf[i]);\r\nerr = s35390a_set_reg(s35390a, S35390A_CMD_INT2_REG1, buf,\r\nsizeof(buf));\r\nreturn err;\r\n}\r\nstatic int s35390a_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nchar buf[3], sts;\r\nint i, err;\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\r\nif (err < 0)\r\nreturn err;\r\nif (bitrev8(sts) != S35390A_INT2_MODE_ALARM)\r\nreturn -EINVAL;\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_INT2_REG1, buf, sizeof(buf));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 3; ++i) {\r\nbuf[i] = bitrev8(buf[i]);\r\nbuf[i] &= ~0x80;\r\n}\r\nalm->time.tm_wday = bcd2bin(buf[S35390A_ALRM_BYTE_WDAY]);\r\nalm->time.tm_hour = s35390a_reg2hr(s35390a,\r\nbuf[S35390A_ALRM_BYTE_HOURS]);\r\nalm->time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS]);\r\ndev_dbg(&client->dev, "%s: alm is mins=%d, hours=%d, wday=%d\n",\r\n__func__, alm->time.tm_min, alm->time.tm_hour,\r\nalm->time.tm_wday);\r\nreturn 0;\r\n}\r\nstatic int s35390a_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nreturn s35390a_read_alarm(to_i2c_client(dev), alm);\r\n}\r\nstatic int s35390a_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nreturn s35390a_set_alarm(to_i2c_client(dev), alm);\r\n}\r\nstatic int s35390a_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn s35390a_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int s35390a_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn s35390a_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int s35390a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err;\r\nunsigned int i;\r\nstruct s35390a *s35390a;\r\nstruct rtc_time tm;\r\nchar buf[1];\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ns35390a = devm_kzalloc(&client->dev, sizeof(struct s35390a),\r\nGFP_KERNEL);\r\nif (!s35390a) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ns35390a->client[0] = client;\r\ni2c_set_clientdata(client, s35390a);\r\nfor (i = 1; i < 8; ++i) {\r\ns35390a->client[i] = i2c_new_dummy(client->adapter,\r\nclient->addr + i);\r\nif (!s35390a->client[i]) {\r\ndev_err(&client->dev, "Address %02x unavailable\n",\r\nclient->addr + i);\r\nerr = -EBUSY;\r\ngoto exit_dummy;\r\n}\r\n}\r\nerr = s35390a_reset(s35390a);\r\nif (err < 0) {\r\ndev_err(&client->dev, "error resetting chip\n");\r\ngoto exit_dummy;\r\n}\r\nerr = s35390a_disable_test_mode(s35390a);\r\nif (err < 0) {\r\ndev_err(&client->dev, "error disabling test mode\n");\r\ngoto exit_dummy;\r\n}\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));\r\nif (err < 0) {\r\ndev_err(&client->dev, "error checking 12/24 hour mode\n");\r\ngoto exit_dummy;\r\n}\r\nif (buf[0] & S35390A_FLAG_24H)\r\ns35390a->twentyfourhour = 1;\r\nelse\r\ns35390a->twentyfourhour = 0;\r\nif (s35390a_get_datetime(client, &tm) < 0)\r\ndev_warn(&client->dev, "clock needs to be set\n");\r\ndevice_set_wakeup_capable(&client->dev, 1);\r\ns35390a->rtc = devm_rtc_device_register(&client->dev,\r\ns35390a_driver.driver.name,\r\n&s35390a_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(s35390a->rtc)) {\r\nerr = PTR_ERR(s35390a->rtc);\r\ngoto exit_dummy;\r\n}\r\nreturn 0;\r\nexit_dummy:\r\nfor (i = 1; i < 8; ++i)\r\nif (s35390a->client[i])\r\ni2c_unregister_device(s35390a->client[i]);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int s35390a_remove(struct i2c_client *client)\r\n{\r\nunsigned int i;\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nfor (i = 1; i < 8; ++i)\r\nif (s35390a->client[i])\r\ni2c_unregister_device(s35390a->client[i]);\r\nreturn 0;\r\n}
