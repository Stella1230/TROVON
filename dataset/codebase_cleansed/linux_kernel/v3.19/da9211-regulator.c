static unsigned int da9211_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nint id = rdev_get_id(rdev);\r\nstruct da9211 *chip = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret, mode = 0;\r\nret = regmap_read(chip->regmap, DA9211_REG_BUCKA_CONF+id, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (data & 0x03) {\r\ncase DA9211_BUCK_MODE_SYNC:\r\nmode = REGULATOR_MODE_FAST;\r\nbreak;\r\ncase DA9211_BUCK_MODE_AUTO:\r\nmode = REGULATOR_MODE_NORMAL;\r\nbreak;\r\ncase DA9211_BUCK_MODE_SLEEP:\r\nmode = REGULATOR_MODE_STANDBY;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic int da9211_buck_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nint id = rdev_get_id(rdev);\r\nstruct da9211 *chip = rdev_get_drvdata(rdev);\r\nint val = 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = DA9211_BUCK_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = DA9211_BUCK_MODE_AUTO;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = DA9211_BUCK_MODE_SLEEP;\r\nbreak;\r\n}\r\nreturn regmap_update_bits(chip->regmap, DA9211_REG_BUCKA_CONF+id,\r\n0x03, val);\r\n}\r\nstatic int da9211_set_current_limit(struct regulator_dev *rdev, int min,\r\nint max)\r\n{\r\nint id = rdev_get_id(rdev);\r\nstruct da9211 *chip = rdev_get_drvdata(rdev);\r\nint i, max_size;\r\nconst int *current_limits;\r\nswitch (chip->chip_id) {\r\ncase DA9211:\r\ncurrent_limits = da9211_current_limits;\r\nmax_size = ARRAY_SIZE(da9211_current_limits)-1;\r\nbreak;\r\ncase DA9213:\r\ncurrent_limits = da9213_current_limits;\r\nmax_size = ARRAY_SIZE(da9213_current_limits)-1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = max_size; i >= 0; i--) {\r\nif (min <= current_limits[i] &&\r\nmax >= current_limits[i]) {\r\nreturn regmap_update_bits(chip->regmap,\r\nDA9211_REG_BUCK_ILIM,\r\n(0x0F << id*4), (i << id*4));\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int da9211_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nint id = rdev_get_id(rdev);\r\nstruct da9211 *chip = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret;\r\nconst int *current_limits;\r\nswitch (chip->chip_id) {\r\ncase DA9211:\r\ncurrent_limits = da9211_current_limits;\r\nbreak;\r\ncase DA9213:\r\ncurrent_limits = da9213_current_limits;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_read(chip->regmap, DA9211_REG_BUCK_ILIM, &data);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (data >> id*4) & 0x0F;\r\nreturn current_limits[data];\r\n}\r\nstatic struct da9211_pdata *da9211_parse_regulators_dt(\r\nstruct device *dev)\r\n{\r\nstruct da9211_pdata *pdata;\r\nstruct device_node *node;\r\nint i, num, n;\r\nnode = of_get_child_by_name(dev->of_node, "regulators");\r\nif (!node) {\r\ndev_err(dev, "regulators node not found\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nnum = of_regulator_match(dev, node, da9211_matches,\r\nARRAY_SIZE(da9211_matches));\r\nof_node_put(node);\r\nif (num < 0) {\r\ndev_err(dev, "Failed to match regulators\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->num_buck = num;\r\nn = 0;\r\nfor (i = 0; i < ARRAY_SIZE(da9211_matches); i++) {\r\nif (!da9211_matches[i].init_data)\r\ncontinue;\r\npdata->init_data[n] = da9211_matches[i].init_data;\r\nn++;\r\n}\r\nreturn pdata;\r\n}\r\nstatic struct da9211_pdata *da9211_parse_regulators_dt(\r\nstruct device *dev)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic irqreturn_t da9211_irq_handler(int irq, void *data)\r\n{\r\nstruct da9211 *chip = data;\r\nint reg_val, err, ret = IRQ_NONE;\r\nerr = regmap_read(chip->regmap, DA9211_REG_EVENT_B, &reg_val);\r\nif (err < 0)\r\ngoto error_i2c;\r\nif (reg_val & DA9211_E_OV_CURR_A) {\r\nregulator_notifier_call_chain(chip->rdev[0],\r\nREGULATOR_EVENT_OVER_CURRENT,\r\nrdev_get_drvdata(chip->rdev[0]));\r\nerr = regmap_write(chip->regmap, DA9211_REG_EVENT_B,\r\nDA9211_E_OV_CURR_A);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nif (reg_val & DA9211_E_OV_CURR_B) {\r\nregulator_notifier_call_chain(chip->rdev[1],\r\nREGULATOR_EVENT_OVER_CURRENT,\r\nrdev_get_drvdata(chip->rdev[1]));\r\nerr = regmap_write(chip->regmap, DA9211_REG_EVENT_B,\r\nDA9211_E_OV_CURR_B);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\nerror_i2c:\r\ndev_err(chip->dev, "I2C error : %d\n", err);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int da9211_regulator_init(struct da9211 *chip)\r\n{\r\nstruct regulator_config config = { };\r\nint i, ret;\r\nunsigned int data;\r\nret = regmap_read(chip->regmap, DA9211_REG_CONFIG_E, &data);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read CONTROL_E reg: %d\n", ret);\r\nreturn ret;\r\n}\r\ndata &= DA9211_SLAVE_SEL;\r\nif ((chip->pdata->num_buck == 2 && data == 0x40)\r\n|| (chip->pdata->num_buck == 1 && data == 0x00)) {\r\nif (data == 0)\r\nchip->num_regulator = 1;\r\nelse\r\nchip->num_regulator = 2;\r\n} else {\r\ndev_err(chip->dev, "Configuration is mismatched\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < chip->num_regulator; i++) {\r\nconfig.init_data = chip->pdata->init_data[i];\r\nconfig.dev = chip->dev;\r\nconfig.driver_data = chip;\r\nconfig.regmap = chip->regmap;\r\nconfig.of_node = chip->dev->of_node;\r\nchip->rdev[i] = devm_regulator_register(chip->dev,\r\n&da9211_regulators[i], &config);\r\nif (IS_ERR(chip->rdev[i])) {\r\ndev_err(chip->dev,\r\n"Failed to register DA9211 regulator\n");\r\nreturn PTR_ERR(chip->rdev[i]);\r\n}\r\nif (chip->chip_irq != 0) {\r\nret = regmap_update_bits(chip->regmap,\r\nDA9211_REG_MASK_B, DA9211_M_OV_CURR_A << i, 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to update mask reg: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9211_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da9211 *chip;\r\nint error, ret;\r\nunsigned int data;\r\nchip = devm_kzalloc(&i2c->dev, sizeof(struct da9211), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &i2c->dev;\r\nchip->regmap = devm_regmap_init_i2c(i2c, &da9211_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nerror = PTR_ERR(chip->regmap);\r\ndev_err(chip->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ni2c_set_clientdata(i2c, chip);\r\nchip->pdata = i2c->dev.platform_data;\r\nret = regmap_read(chip->regmap, DA9211_REG_DEVICE_ID, &data);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read DEVICE_ID reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (data) {\r\ncase DA9211_DEVICE_ID:\r\nchip->chip_id = DA9211;\r\nbreak;\r\ncase DA9213_DEVICE_ID:\r\nchip->chip_id = DA9213;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "Unsupported device id = 0x%x.\n", data);\r\nreturn -ENODEV;\r\n}\r\nif (!chip->pdata)\r\nchip->pdata = da9211_parse_regulators_dt(chip->dev);\r\nif (IS_ERR(chip->pdata)) {\r\ndev_err(chip->dev, "No regulators defined for the platform\n");\r\nreturn PTR_ERR(chip->pdata);\r\n}\r\nchip->chip_irq = i2c->irq;\r\nif (chip->chip_irq != 0) {\r\nret = devm_request_threaded_irq(chip->dev, chip->chip_irq, NULL,\r\nda9211_irq_handler,\r\nIRQF_TRIGGER_LOW|IRQF_ONESHOT,\r\n"da9211", chip);\r\nif (ret != 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: %d\n",\r\nchip->chip_irq);\r\nreturn ret;\r\n}\r\n} else {\r\ndev_warn(chip->dev, "No IRQ configured\n");\r\n}\r\nret = da9211_regulator_init(chip);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to initialize regulator: %d\n", ret);\r\nreturn ret;\r\n}
