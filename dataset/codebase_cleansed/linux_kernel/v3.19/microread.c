static int microread_open(struct nfc_hci_dev *hdev)\r\n{\r\nstruct microread_info *info = nfc_hci_get_clientdata(hdev);\r\nreturn info->phy_ops->enable(info->phy_id);\r\n}\r\nstatic void microread_close(struct nfc_hci_dev *hdev)\r\n{\r\nstruct microread_info *info = nfc_hci_get_clientdata(hdev);\r\ninfo->phy_ops->disable(info->phy_id);\r\n}\r\nstatic int microread_hci_ready(struct nfc_hci_dev *hdev)\r\n{\r\nint r;\r\nu8 param[4];\r\nparam[0] = 0x03;\r\nr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\r\nMICROREAD_CMD_MREAD_SUBSCRIBE, param, 1, NULL);\r\nif (r)\r\nreturn r;\r\nr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_A_3,\r\nMICROREAD_CMD_MREAD_SUBSCRIBE, NULL, 0, NULL);\r\nif (r)\r\nreturn r;\r\nparam[0] = 0x00;\r\nparam[1] = 0x03;\r\nparam[2] = 0x00;\r\nr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_B,\r\nMICROREAD_CMD_MREAD_SUBSCRIBE, param, 3, NULL);\r\nif (r)\r\nreturn r;\r\nr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_NFC_T1,\r\nMICROREAD_CMD_MREAD_SUBSCRIBE, NULL, 0, NULL);\r\nif (r)\r\nreturn r;\r\nparam[0] = 0xFF;\r\nparam[1] = 0xFF;\r\nparam[2] = 0x00;\r\nparam[3] = 0x00;\r\nr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_NFC_T3,\r\nMICROREAD_CMD_MREAD_SUBSCRIBE, param, 4, NULL);\r\nreturn r;\r\n}\r\nstatic int microread_xmit(struct nfc_hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct microread_info *info = nfc_hci_get_clientdata(hdev);\r\nreturn info->phy_ops->write(info->phy_id, skb);\r\n}\r\nstatic int microread_start_poll(struct nfc_hci_dev *hdev,\r\nu32 im_protocols, u32 tm_protocols)\r\n{\r\nint r;\r\nu8 param[2];\r\nu8 mode;\r\nparam[0] = 0x00;\r\nparam[1] = 0x00;\r\nif (im_protocols & NFC_PROTO_ISO14443_MASK)\r\nparam[0] |= (1 << 2);\r\nif (im_protocols & NFC_PROTO_ISO14443_B_MASK)\r\nparam[0] |= 1;\r\nif (im_protocols & NFC_PROTO_MIFARE_MASK)\r\nparam[1] |= 1;\r\nif (im_protocols & NFC_PROTO_JEWEL_MASK)\r\nparam[0] |= (1 << 1);\r\nif (im_protocols & NFC_PROTO_FELICA_MASK)\r\nparam[0] |= (1 << 5);\r\nif (im_protocols & NFC_PROTO_NFC_DEP_MASK)\r\nparam[1] |= (1 << 1);\r\nif ((im_protocols | tm_protocols) & NFC_PROTO_NFC_DEP_MASK) {\r\nhdev->gb = nfc_get_local_general_bytes(hdev->ndev,\r\n&hdev->gb_len);\r\nif (hdev->gb == NULL || hdev->gb_len == 0) {\r\nim_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\r\ntm_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\r\n}\r\n}\r\nr = nfc_hci_send_event(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\r\nMICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL, 0);\r\nif (r)\r\nreturn r;\r\nmode = 0xff;\r\nr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\r\nMICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\r\nif (r)\r\nreturn r;\r\nif (im_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_INITIATOR,\r\nMICROREAD_PAR_P2P_INITIATOR_GI,\r\nhdev->gb, hdev->gb_len);\r\nif (r)\r\nreturn r;\r\n}\r\nif (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\r\nMICROREAD_PAR_P2P_TARGET_GT,\r\nhdev->gb, hdev->gb_len);\r\nif (r)\r\nreturn r;\r\nmode = 0x02;\r\nr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\r\nMICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn nfc_hci_send_event(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\r\nMICROREAD_EVT_MREAD_DISCOVERY_START_SOME,\r\nparam, 2);\r\n}\r\nstatic int microread_dep_link_up(struct nfc_hci_dev *hdev,\r\nstruct nfc_target *target, u8 comm_mode,\r\nu8 *gb, size_t gb_len)\r\n{\r\nstruct sk_buff *rgb_skb = NULL;\r\nint r;\r\nr = nfc_hci_get_param(hdev, target->hci_reader_gate,\r\nMICROREAD_PAR_P2P_INITIATOR_GT, &rgb_skb);\r\nif (r < 0)\r\nreturn r;\r\nif (rgb_skb->len == 0 || rgb_skb->len > NFC_GB_MAXSIZE) {\r\nr = -EPROTO;\r\ngoto exit;\r\n}\r\nr = nfc_set_remote_general_bytes(hdev->ndev, rgb_skb->data,\r\nrgb_skb->len);\r\nif (r == 0)\r\nr = nfc_dep_link_is_up(hdev->ndev, target->idx, comm_mode,\r\nNFC_RF_INITIATOR);\r\nexit:\r\nkfree_skb(rgb_skb);\r\nreturn r;\r\n}\r\nstatic int microread_dep_link_down(struct nfc_hci_dev *hdev)\r\n{\r\nreturn nfc_hci_send_event(hdev, MICROREAD_GATE_ID_P2P_INITIATOR,\r\nMICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL, 0);\r\n}\r\nstatic int microread_target_from_gate(struct nfc_hci_dev *hdev, u8 gate,\r\nstruct nfc_target *target)\r\n{\r\nswitch (gate) {\r\ncase MICROREAD_GATE_ID_P2P_INITIATOR:\r\ntarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int microread_complete_target_discovered(struct nfc_hci_dev *hdev,\r\nu8 gate,\r\nstruct nfc_target *target)\r\n{\r\nreturn 0;\r\n}\r\nstatic void microread_im_transceive_cb(void *context, struct sk_buff *skb,\r\nint err)\r\n{\r\nstruct microread_info *info = context;\r\nswitch (info->async_cb_type) {\r\ncase MICROREAD_CB_TYPE_READER_ALL:\r\nif (err == 0) {\r\nif (skb->len == 0) {\r\nerr = -EPROTO;\r\nkfree_skb(skb);\r\ninfo->async_cb(info->async_cb_context, NULL,\r\n-EPROTO);\r\nreturn;\r\n}\r\nif (skb->data[skb->len - 1] != 0) {\r\nerr = nfc_hci_result_to_errno(\r\nskb->data[skb->len - 1]);\r\nkfree_skb(skb);\r\ninfo->async_cb(info->async_cb_context, NULL,\r\nerr);\r\nreturn;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\n}\r\ninfo->async_cb(info->async_cb_context, skb, err);\r\nbreak;\r\ndefault:\r\nif (err == 0)\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\nstatic int microread_im_transceive(struct nfc_hci_dev *hdev,\r\nstruct nfc_target *target,\r\nstruct sk_buff *skb, data_exchange_cb_t cb,\r\nvoid *cb_context)\r\n{\r\nstruct microread_info *info = nfc_hci_get_clientdata(hdev);\r\nu8 control_bits;\r\nu16 crc;\r\npr_info("data exchange to gate 0x%x\n", target->hci_reader_gate);\r\nif (target->hci_reader_gate == MICROREAD_GATE_ID_P2P_INITIATOR) {\r\n*skb_push(skb, 1) = 0;\r\nreturn nfc_hci_send_event(hdev, target->hci_reader_gate,\r\nMICROREAD_EVT_P2P_INITIATOR_EXCHANGE_TO_RF,\r\nskb->data, skb->len);\r\n}\r\nswitch (target->hci_reader_gate) {\r\ncase MICROREAD_GATE_ID_MREAD_ISO_A:\r\ncontrol_bits = 0xCB;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_ISO_A_3:\r\ncontrol_bits = 0xCB;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_ISO_B:\r\ncontrol_bits = 0xCB;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_NFC_T1:\r\ncontrol_bits = 0x1B;\r\ncrc = crc_ccitt(0xffff, skb->data, skb->len);\r\ncrc = ~crc;\r\n*skb_put(skb, 1) = crc & 0xff;\r\n*skb_put(skb, 1) = crc >> 8;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_NFC_T3:\r\ncontrol_bits = 0xDB;\r\nbreak;\r\ndefault:\r\npr_info("Abort im_transceive to invalid gate 0x%x\n",\r\ntarget->hci_reader_gate);\r\nreturn 1;\r\n}\r\n*skb_push(skb, 1) = control_bits;\r\ninfo->async_cb_type = MICROREAD_CB_TYPE_READER_ALL;\r\ninfo->async_cb = cb;\r\ninfo->async_cb_context = cb_context;\r\nreturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\r\nMICROREAD_CMD_MREAD_EXCHANGE,\r\nskb->data, skb->len,\r\nmicroread_im_transceive_cb, info);\r\n}\r\nstatic int microread_tm_send(struct nfc_hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nint r;\r\nr = nfc_hci_send_event(hdev, MICROREAD_GATE_ID_P2P_TARGET,\r\nMICROREAD_EVT_MCARD_EXCHANGE,\r\nskb->data, skb->len);\r\nkfree_skb(skb);\r\nreturn r;\r\n}\r\nstatic void microread_target_discovered(struct nfc_hci_dev *hdev, u8 gate,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nfc_target *targets;\r\nint r = 0;\r\npr_info("target discovered to gate 0x%x\n", gate);\r\ntargets = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\r\nif (targets == NULL) {\r\nr = -ENOMEM;\r\ngoto exit;\r\n}\r\ntargets->hci_reader_gate = gate;\r\nswitch (gate) {\r\ncase MICROREAD_GATE_ID_MREAD_ISO_A:\r\ntargets->supported_protocols =\r\nnfc_hci_sak_to_protocol(skb->data[MICROREAD_EMCF_A_SAK]);\r\ntargets->sens_res =\r\nbe16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_A_ATQA]);\r\ntargets->sel_res = skb->data[MICROREAD_EMCF_A_SAK];\r\ntargets->nfcid1_len = skb->data[MICROREAD_EMCF_A_LEN];\r\nif (targets->nfcid1_len > sizeof(targets->nfcid1)) {\r\nr = -EINVAL;\r\ngoto exit_free;\r\n}\r\nmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_A_UID],\r\ntargets->nfcid1_len);\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_ISO_A_3:\r\ntargets->supported_protocols =\r\nnfc_hci_sak_to_protocol(skb->data[MICROREAD_EMCF_A3_SAK]);\r\ntargets->sens_res =\r\nbe16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_A3_ATQA]);\r\ntargets->sel_res = skb->data[MICROREAD_EMCF_A3_SAK];\r\ntargets->nfcid1_len = skb->data[MICROREAD_EMCF_A3_LEN];\r\nif (targets->nfcid1_len > sizeof(targets->nfcid1)) {\r\nr = -EINVAL;\r\ngoto exit_free;\r\n}\r\nmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_A3_UID],\r\ntargets->nfcid1_len);\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_ISO_B:\r\ntargets->supported_protocols = NFC_PROTO_ISO14443_B_MASK;\r\nmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_B_UID], 4);\r\ntargets->nfcid1_len = 4;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_NFC_T1:\r\ntargets->supported_protocols = NFC_PROTO_JEWEL_MASK;\r\ntargets->sens_res =\r\nle16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_T1_ATQA]);\r\nmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_T1_UID], 4);\r\ntargets->nfcid1_len = 4;\r\nbreak;\r\ncase MICROREAD_GATE_ID_MREAD_NFC_T3:\r\ntargets->supported_protocols = NFC_PROTO_FELICA_MASK;\r\nmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_T3_UID], 8);\r\ntargets->nfcid1_len = 8;\r\nbreak;\r\ndefault:\r\npr_info("discard target discovered to gate 0x%x\n", gate);\r\ngoto exit_free;\r\n}\r\nr = nfc_targets_found(hdev->ndev, targets, 1);\r\nexit_free:\r\nkfree(targets);\r\nexit:\r\nkfree_skb(skb);\r\nif (r)\r\npr_err("Failed to handle discovered target err=%d\n", r);\r\n}\r\nstatic int microread_event_received(struct nfc_hci_dev *hdev, u8 gate,\r\nu8 event, struct sk_buff *skb)\r\n{\r\nint r;\r\nu8 mode;\r\npr_info("Microread received event 0x%x to gate 0x%x\n", event, gate);\r\nswitch (event) {\r\ncase MICROREAD_EVT_MREAD_CARD_FOUND:\r\nmicroread_target_discovered(hdev, gate, skb);\r\nreturn 0;\r\ncase MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_FROM_RF:\r\nif (skb->len < 1) {\r\nkfree_skb(skb);\r\nreturn -EPROTO;\r\n}\r\nif (skb->data[skb->len - 1]) {\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\nr = nfc_tm_data_received(hdev->ndev, skb);\r\nbreak;\r\ncase MICROREAD_EVT_MCARD_FIELD_ON:\r\ncase MICROREAD_EVT_MCARD_FIELD_OFF:\r\nkfree_skb(skb);\r\nreturn 0;\r\ncase MICROREAD_EVT_P2P_TARGET_ACTIVATED:\r\nr = nfc_tm_activated(hdev->ndev, NFC_PROTO_NFC_DEP_MASK,\r\nNFC_COMM_PASSIVE, skb->data,\r\nskb->len);\r\nkfree_skb(skb);\r\nbreak;\r\ncase MICROREAD_EVT_MCARD_EXCHANGE:\r\nif (skb->len < 1) {\r\nkfree_skb(skb);\r\nreturn -EPROTO;\r\n}\r\nif (skb->data[skb->len-1]) {\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\nr = nfc_tm_data_received(hdev->ndev, skb);\r\nbreak;\r\ncase MICROREAD_EVT_P2P_TARGET_DEACTIVATED:\r\nkfree_skb(skb);\r\nmode = 0xff;\r\nr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\r\nMICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\r\nif (r)\r\nbreak;\r\nr = nfc_hci_send_event(hdev, gate,\r\nMICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL,\r\n0);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn r;\r\n}\r\nint microread_probe(void *phy_id, struct nfc_phy_ops *phy_ops, char *llc_name,\r\nint phy_headroom, int phy_tailroom, int phy_payload,\r\nstruct nfc_hci_dev **hdev)\r\n{\r\nstruct microread_info *info;\r\nunsigned long quirks = 0;\r\nu32 protocols;\r\nstruct nfc_hci_init_data init_data;\r\nint r;\r\ninfo = kzalloc(sizeof(struct microread_info), GFP_KERNEL);\r\nif (!info) {\r\nr = -ENOMEM;\r\ngoto err_info_alloc;\r\n}\r\ninfo->phy_ops = phy_ops;\r\ninfo->phy_id = phy_id;\r\ninit_data.gate_count = ARRAY_SIZE(microread_gates);\r\nmemcpy(init_data.gates, microread_gates, sizeof(microread_gates));\r\nstrcpy(init_data.session_id, "MICROREA");\r\nset_bit(NFC_HCI_QUIRK_SHORT_CLEAR, &quirks);\r\nprotocols = NFC_PROTO_JEWEL_MASK |\r\nNFC_PROTO_MIFARE_MASK |\r\nNFC_PROTO_FELICA_MASK |\r\nNFC_PROTO_ISO14443_MASK |\r\nNFC_PROTO_ISO14443_B_MASK |\r\nNFC_PROTO_NFC_DEP_MASK;\r\ninfo->hdev = nfc_hci_allocate_device(&microread_hci_ops, &init_data,\r\nquirks, protocols, llc_name,\r\nphy_headroom +\r\nMICROREAD_CMDS_HEADROOM,\r\nphy_tailroom +\r\nMICROREAD_CMD_TAILROOM,\r\nphy_payload);\r\nif (!info->hdev) {\r\npr_err("Cannot allocate nfc hdev\n");\r\nr = -ENOMEM;\r\ngoto err_alloc_hdev;\r\n}\r\nnfc_hci_set_clientdata(info->hdev, info);\r\nr = nfc_hci_register_device(info->hdev);\r\nif (r)\r\ngoto err_regdev;\r\n*hdev = info->hdev;\r\nreturn 0;\r\nerr_regdev:\r\nnfc_hci_free_device(info->hdev);\r\nerr_alloc_hdev:\r\nkfree(info);\r\nerr_info_alloc:\r\nreturn r;\r\n}\r\nvoid microread_remove(struct nfc_hci_dev *hdev)\r\n{\r\nstruct microread_info *info = nfc_hci_get_clientdata(hdev);\r\nnfc_hci_unregister_device(hdev);\r\nnfc_hci_free_device(hdev);\r\nkfree(info);\r\n}
