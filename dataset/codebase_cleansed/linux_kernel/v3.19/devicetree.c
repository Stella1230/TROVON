void __init early_init_dt_scan_chosen_arch(unsigned long node)\r\n{\r\nBUG();\r\n}\r\nvoid __init early_init_dt_add_memory_arch(u64 base, u64 size)\r\n{\r\nBUG();\r\n}\r\nvoid * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)\r\n{\r\nreturn __alloc_bootmem(size, align, __pa(MAX_DMA_ADDRESS));\r\n}\r\nvoid __init add_dtb(u64 data)\r\n{\r\ninitial_dtb = data + offsetof(struct setup_data, data);\r\n}\r\nstatic int __init add_bus_probe(void)\r\n{\r\nif (!of_have_populated_dt())\r\nreturn 0;\r\nreturn of_platform_bus_probe(NULL, ce4100_ids, NULL);\r\n}\r\nstruct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)\r\n{\r\nstruct device_node *np;\r\nfor_each_node_by_type(np, "pci") {\r\nconst void *prop;\r\nunsigned int bus_min;\r\nprop = of_get_property(np, "bus-range", NULL);\r\nif (!prop)\r\ncontinue;\r\nbus_min = be32_to_cpup(prop);\r\nif (bus->number == bus_min)\r\nreturn np;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int x86_of_pci_irq_enable(struct pci_dev *dev)\r\n{\r\nu32 virq;\r\nint ret;\r\nu8 pin;\r\nret = pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\r\nif (ret)\r\nreturn ret;\r\nif (!pin)\r\nreturn 0;\r\nvirq = of_irq_parse_and_map_pci(dev, 0, 0);\r\nif (virq == 0)\r\nreturn -EINVAL;\r\ndev->irq = virq;\r\nreturn 0;\r\n}\r\nstatic void x86_of_pci_irq_disable(struct pci_dev *dev)\r\n{\r\n}\r\nvoid x86_of_pci_init(void)\r\n{\r\npcibios_enable_irq = x86_of_pci_irq_enable;\r\npcibios_disable_irq = x86_of_pci_irq_disable;\r\n}\r\nstatic void __init dtb_setup_hpet(void)\r\n{\r\n#ifdef CONFIG_HPET_TIMER\r\nstruct device_node *dn;\r\nstruct resource r;\r\nint ret;\r\ndn = of_find_compatible_node(NULL, NULL, "intel,ce4100-hpet");\r\nif (!dn)\r\nreturn;\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (ret) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nhpet_address = r.start;\r\n#endif\r\n}\r\nstatic void __init dtb_lapic_setup(void)\r\n{\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nstruct device_node *dn;\r\nstruct resource r;\r\nint ret;\r\ndn = of_find_compatible_node(NULL, NULL, "intel,ce4100-lapic");\r\nif (!dn)\r\nreturn;\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (WARN_ON(ret))\r\nreturn;\r\nif (!cpu_has_apic) {\r\nif (apic_force_enable(r.start))\r\nreturn;\r\n}\r\nsmp_found_config = 1;\r\npic_mode = 1;\r\nregister_lapic_address(r.start);\r\ngeneric_processor_info(boot_cpu_physical_apicid,\r\nGET_APIC_VERSION(apic_read(APIC_LVR)));\r\n#endif\r\n}\r\nstatic int ioapic_xlate(struct irq_domain *domain,\r\nstruct device_node *controller,\r\nconst u32 *intspec, u32 intsize,\r\nirq_hw_number_t *out_hwirq, u32 *out_type)\r\n{\r\nstruct of_ioapic_type *it;\r\nu32 line, idx, gsi;\r\nif (WARN_ON(intsize < 2))\r\nreturn -EINVAL;\r\nline = intspec[0];\r\nif (intspec[1] >= ARRAY_SIZE(of_ioapic_type))\r\nreturn -EINVAL;\r\nit = &of_ioapic_type[intspec[1]];\r\nidx = (u32)(long)domain->host_data;\r\ngsi = mp_pin_to_gsi(idx, line);\r\nif (mp_set_gsi_attr(gsi, it->trigger, it->polarity, cpu_to_node(0)))\r\nreturn -EBUSY;\r\n*out_hwirq = line;\r\n*out_type = it->out_type;\r\nreturn 0;\r\n}\r\nstatic void __init dtb_add_ioapic(struct device_node *dn)\r\n{\r\nstruct resource r;\r\nint ret;\r\nstruct ioapic_domain_cfg cfg = {\r\n.type = IOAPIC_DOMAIN_DYNAMIC,\r\n.ops = &ioapic_irq_domain_ops,\r\n.dev = dn,\r\n};\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (ret) {\r\nprintk(KERN_ERR "Can't obtain address from node %s.\n",\r\ndn->full_name);\r\nreturn;\r\n}\r\nmp_register_ioapic(++ioapic_id, r.start, gsi_top, &cfg);\r\n}\r\nstatic void __init dtb_ioapic_setup(void)\r\n{\r\nstruct device_node *dn;\r\nfor_each_compatible_node(dn, NULL, "intel,ce4100-ioapic")\r\ndtb_add_ioapic(dn);\r\nif (nr_ioapics) {\r\nof_ioapic = 1;\r\nreturn;\r\n}\r\nprintk(KERN_ERR "Error: No information about IO-APIC in OF.\n");\r\n}\r\nstatic void __init dtb_ioapic_setup(void) {}\r\nstatic void __init dtb_apic_setup(void)\r\n{\r\ndtb_lapic_setup();\r\ndtb_ioapic_setup();\r\n}\r\nstatic void __init x86_flattree_get_config(void)\r\n{\r\nu32 size, map_len;\r\nvoid *dt;\r\nif (!initial_dtb)\r\nreturn;\r\nmap_len = max(PAGE_SIZE - (initial_dtb & ~PAGE_MASK), (u64)128);\r\ninitial_boot_params = dt = early_memremap(initial_dtb, map_len);\r\nsize = of_get_flat_dt_size();\r\nif (map_len < size) {\r\nearly_iounmap(dt, map_len);\r\ninitial_boot_params = dt = early_memremap(initial_dtb, size);\r\nmap_len = size;\r\n}\r\nunflatten_and_copy_device_tree();\r\nearly_iounmap(dt, map_len);\r\n}\r\nstatic inline void x86_flattree_get_config(void) { }\r\nvoid __init x86_dtb_init(void)\r\n{\r\nx86_flattree_get_config();\r\nif (!of_have_populated_dt())\r\nreturn;\r\ndtb_setup_hpet();\r\ndtb_apic_setup();\r\n}
