static size_t logger_offset(struct logger_log *log, size_t n)\r\n{\r\nreturn n & (log->size - 1);\r\n}\r\nstatic inline struct logger_log *file_get_log(struct file *file)\r\n{\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader = file->private_data;\r\nreturn reader->log;\r\n}\r\nreturn file->private_data;\r\n}\r\nstatic struct logger_entry *get_entry_header(struct logger_log *log,\r\nsize_t off, struct logger_entry *scratch)\r\n{\r\nsize_t len = min(sizeof(struct logger_entry), log->size - off);\r\nif (len != sizeof(struct logger_entry)) {\r\nmemcpy(((void *) scratch), log->buffer + off, len);\r\nmemcpy(((void *) scratch) + len, log->buffer,\r\nsizeof(struct logger_entry) - len);\r\nreturn scratch;\r\n}\r\nreturn (struct logger_entry *) (log->buffer + off);\r\n}\r\nstatic __u32 get_entry_msg_len(struct logger_log *log, size_t off)\r\n{\r\nstruct logger_entry scratch;\r\nstruct logger_entry *entry;\r\nentry = get_entry_header(log, off, &scratch);\r\nreturn entry->len;\r\n}\r\nstatic size_t get_user_hdr_len(int ver)\r\n{\r\nif (ver < 2)\r\nreturn sizeof(struct user_logger_entry_compat);\r\nreturn sizeof(struct logger_entry);\r\n}\r\nstatic ssize_t copy_header_to_user(int ver, struct logger_entry *entry,\r\nchar __user *buf)\r\n{\r\nvoid *hdr;\r\nsize_t hdr_len;\r\nstruct user_logger_entry_compat v1;\r\nif (ver < 2) {\r\nv1.len = entry->len;\r\nv1.__pad = 0;\r\nv1.pid = entry->pid;\r\nv1.tid = entry->tid;\r\nv1.sec = entry->sec;\r\nv1.nsec = entry->nsec;\r\nhdr = &v1;\r\nhdr_len = sizeof(struct user_logger_entry_compat);\r\n} else {\r\nhdr = entry;\r\nhdr_len = sizeof(struct logger_entry);\r\n}\r\nreturn copy_to_user(buf, hdr, hdr_len);\r\n}\r\nstatic ssize_t do_read_log_to_user(struct logger_log *log,\r\nstruct logger_reader *reader,\r\nchar __user *buf,\r\nsize_t count)\r\n{\r\nstruct logger_entry scratch;\r\nstruct logger_entry *entry;\r\nsize_t len;\r\nsize_t msg_start;\r\nentry = get_entry_header(log, reader->r_off, &scratch);\r\nif (copy_header_to_user(reader->r_ver, entry, buf))\r\nreturn -EFAULT;\r\ncount -= get_user_hdr_len(reader->r_ver);\r\nbuf += get_user_hdr_len(reader->r_ver);\r\nmsg_start = logger_offset(log,\r\nreader->r_off + sizeof(struct logger_entry));\r\nlen = min(count, log->size - msg_start);\r\nif (copy_to_user(buf, log->buffer + msg_start, len))\r\nreturn -EFAULT;\r\nif (count != len)\r\nif (copy_to_user(buf + len, log->buffer, count - len))\r\nreturn -EFAULT;\r\nreader->r_off = logger_offset(log, reader->r_off +\r\nsizeof(struct logger_entry) + count);\r\nreturn count + get_user_hdr_len(reader->r_ver);\r\n}\r\nstatic size_t get_next_entry_by_uid(struct logger_log *log,\r\nsize_t off, kuid_t euid)\r\n{\r\nwhile (off != log->w_off) {\r\nstruct logger_entry *entry;\r\nstruct logger_entry scratch;\r\nsize_t next_len;\r\nentry = get_entry_header(log, off, &scratch);\r\nif (uid_eq(entry->euid, euid))\r\nreturn off;\r\nnext_len = sizeof(struct logger_entry) + entry->len;\r\noff = logger_offset(log, off + next_len);\r\n}\r\nreturn off;\r\n}\r\nstatic ssize_t logger_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct logger_reader *reader = file->private_data;\r\nstruct logger_log *log = reader->log;\r\nssize_t ret;\r\nDEFINE_WAIT(wait);\r\nstart:\r\nwhile (1) {\r\nmutex_lock(&log->mutex);\r\nprepare_to_wait(&log->wq, &wait, TASK_INTERRUPTIBLE);\r\nret = (log->w_off == reader->r_off);\r\nmutex_unlock(&log->mutex);\r\nif (!ret)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&log->wq, &wait);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&log->mutex);\r\nif (!reader->r_all)\r\nreader->r_off = get_next_entry_by_uid(log,\r\nreader->r_off, current_euid());\r\nif (unlikely(log->w_off == reader->r_off)) {\r\nmutex_unlock(&log->mutex);\r\ngoto start;\r\n}\r\nret = get_user_hdr_len(reader->r_ver) +\r\nget_entry_msg_len(log, reader->r_off);\r\nif (count < ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = do_read_log_to_user(log, reader, buf, ret);\r\nout:\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic size_t get_next_entry(struct logger_log *log, size_t off, size_t len)\r\n{\r\nsize_t count = 0;\r\ndo {\r\nsize_t nr = sizeof(struct logger_entry) +\r\nget_entry_msg_len(log, off);\r\noff = logger_offset(log, off + nr);\r\ncount += nr;\r\n} while (count < len);\r\nreturn off;\r\n}\r\nstatic inline int is_between(size_t a, size_t b, size_t c)\r\n{\r\nif (a < b) {\r\nif (a < c && c <= b)\r\nreturn 1;\r\n} else {\r\nif (c <= b || a < c)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fix_up_readers(struct logger_log *log, size_t len)\r\n{\r\nsize_t old = log->w_off;\r\nsize_t new = logger_offset(log, old + len);\r\nstruct logger_reader *reader;\r\nif (is_between(old, new, log->head))\r\nlog->head = get_next_entry(log, log->head, len);\r\nlist_for_each_entry(reader, &log->readers, list)\r\nif (is_between(old, new, reader->r_off))\r\nreader->r_off = get_next_entry(log, reader->r_off, len);\r\n}\r\nstatic ssize_t logger_write_iter(struct kiocb *iocb, struct iov_iter *from)\r\n{\r\nstruct logger_log *log = file_get_log(iocb->ki_filp);\r\nstruct logger_entry header;\r\nstruct timespec now;\r\nsize_t len, count, w_off;\r\ncount = min_t(size_t, iocb->ki_nbytes, LOGGER_ENTRY_MAX_PAYLOAD);\r\nnow = current_kernel_time();\r\nheader.pid = current->tgid;\r\nheader.tid = current->pid;\r\nheader.sec = now.tv_sec;\r\nheader.nsec = now.tv_nsec;\r\nheader.euid = current_euid();\r\nheader.len = count;\r\nheader.hdr_size = sizeof(struct logger_entry);\r\nif (unlikely(!header.len))\r\nreturn 0;\r\nmutex_lock(&log->mutex);\r\nfix_up_readers(log, sizeof(struct logger_entry) + header.len);\r\nlen = min(sizeof(header), log->size - log->w_off);\r\nmemcpy(log->buffer + log->w_off, &header, len);\r\nmemcpy(log->buffer, (char *)&header + len, sizeof(header) - len);\r\nw_off = logger_offset(log, log->w_off + sizeof(struct logger_entry));\r\nlen = min(count, log->size - w_off);\r\nif (copy_from_iter(log->buffer + w_off, len, from) != len) {\r\nmutex_unlock(&log->mutex);\r\nreturn -EFAULT;\r\n}\r\nif (copy_from_iter(log->buffer, count - len, from) != count - len) {\r\nmutex_unlock(&log->mutex);\r\nreturn -EFAULT;\r\n}\r\nlog->w_off = logger_offset(log, w_off + count);\r\nmutex_unlock(&log->mutex);\r\nwake_up_interruptible(&log->wq);\r\nreturn len;\r\n}\r\nstatic struct logger_log *get_log_from_minor(int minor)\r\n{\r\nstruct logger_log *log;\r\nlist_for_each_entry(log, &log_list, logs)\r\nif (log->misc.minor == minor)\r\nreturn log;\r\nreturn NULL;\r\n}\r\nstatic int logger_open(struct inode *inode, struct file *file)\r\n{\r\nstruct logger_log *log;\r\nint ret;\r\nret = nonseekable_open(inode, file);\r\nif (ret)\r\nreturn ret;\r\nlog = get_log_from_minor(MINOR(inode->i_rdev));\r\nif (!log)\r\nreturn -ENODEV;\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader;\r\nreader = kmalloc(sizeof(struct logger_reader), GFP_KERNEL);\r\nif (!reader)\r\nreturn -ENOMEM;\r\nreader->log = log;\r\nreader->r_ver = 1;\r\nreader->r_all = in_egroup_p(inode->i_gid) ||\r\ncapable(CAP_SYSLOG);\r\nINIT_LIST_HEAD(&reader->list);\r\nmutex_lock(&log->mutex);\r\nreader->r_off = log->head;\r\nlist_add_tail(&reader->list, &log->readers);\r\nmutex_unlock(&log->mutex);\r\nfile->private_data = reader;\r\n} else\r\nfile->private_data = log;\r\nreturn 0;\r\n}\r\nstatic int logger_release(struct inode *ignored, struct file *file)\r\n{\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader = file->private_data;\r\nstruct logger_log *log = reader->log;\r\nmutex_lock(&log->mutex);\r\nlist_del(&reader->list);\r\nmutex_unlock(&log->mutex);\r\nkfree(reader);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int logger_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct logger_reader *reader;\r\nstruct logger_log *log;\r\nunsigned int ret = POLLOUT | POLLWRNORM;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn ret;\r\nreader = file->private_data;\r\nlog = reader->log;\r\npoll_wait(file, &log->wq, wait);\r\nmutex_lock(&log->mutex);\r\nif (!reader->r_all)\r\nreader->r_off = get_next_entry_by_uid(log,\r\nreader->r_off, current_euid());\r\nif (log->w_off != reader->r_off)\r\nret |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic long logger_set_version(struct logger_reader *reader, void __user *arg)\r\n{\r\nint version;\r\nif (copy_from_user(&version, arg, sizeof(int)))\r\nreturn -EFAULT;\r\nif ((version < 1) || (version > 2))\r\nreturn -EINVAL;\r\nreader->r_ver = version;\r\nreturn 0;\r\n}\r\nstatic long logger_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct logger_log *log = file_get_log(file);\r\nstruct logger_reader *reader;\r\nlong ret = -EINVAL;\r\nvoid __user *argp = (void __user *) arg;\r\nmutex_lock(&log->mutex);\r\nswitch (cmd) {\r\ncase LOGGER_GET_LOG_BUF_SIZE:\r\nret = log->size;\r\nbreak;\r\ncase LOGGER_GET_LOG_LEN:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nif (log->w_off >= reader->r_off)\r\nret = log->w_off - reader->r_off;\r\nelse\r\nret = (log->size - reader->r_off) + log->w_off;\r\nbreak;\r\ncase LOGGER_GET_NEXT_ENTRY_LEN:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nif (!reader->r_all)\r\nreader->r_off = get_next_entry_by_uid(log,\r\nreader->r_off, current_euid());\r\nif (log->w_off != reader->r_off)\r\nret = get_user_hdr_len(reader->r_ver) +\r\nget_entry_msg_len(log, reader->r_off);\r\nelse\r\nret = 0;\r\nbreak;\r\ncase LOGGER_FLUSH_LOG:\r\nif (!(file->f_mode & FMODE_WRITE)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nif (!(in_egroup_p(file_inode(file)->i_gid) ||\r\ncapable(CAP_SYSLOG))) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nlist_for_each_entry(reader, &log->readers, list)\r\nreader->r_off = log->w_off;\r\nlog->head = log->w_off;\r\nret = 0;\r\nbreak;\r\ncase LOGGER_GET_VERSION:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nret = reader->r_ver;\r\nbreak;\r\ncase LOGGER_SET_VERSION:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nret = logger_set_version(reader, argp);\r\nbreak;\r\n}\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic int __init create_log(char *log_name, int size)\r\n{\r\nint ret = 0;\r\nstruct logger_log *log;\r\nunsigned char *buffer;\r\nbuffer = vmalloc(size);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\nlog = kzalloc(sizeof(struct logger_log), GFP_KERNEL);\r\nif (log == NULL) {\r\nret = -ENOMEM;\r\ngoto out_free_buffer;\r\n}\r\nlog->buffer = buffer;\r\nlog->misc.minor = MISC_DYNAMIC_MINOR;\r\nlog->misc.name = kstrdup(log_name, GFP_KERNEL);\r\nif (log->misc.name == NULL) {\r\nret = -ENOMEM;\r\ngoto out_free_log;\r\n}\r\nlog->misc.fops = &logger_fops;\r\nlog->misc.parent = NULL;\r\ninit_waitqueue_head(&log->wq);\r\nINIT_LIST_HEAD(&log->readers);\r\nmutex_init(&log->mutex);\r\nlog->w_off = 0;\r\nlog->head = 0;\r\nlog->size = size;\r\nINIT_LIST_HEAD(&log->logs);\r\nlist_add_tail(&log->logs, &log_list);\r\nret = misc_register(&log->misc);\r\nif (unlikely(ret)) {\r\npr_err("failed to register misc device for log '%s'!\n",\r\nlog->misc.name);\r\ngoto out_free_misc_name;\r\n}\r\npr_info("created %luK log '%s'\n",\r\n(unsigned long) log->size >> 10, log->misc.name);\r\nreturn 0;\r\nout_free_misc_name:\r\nkfree(log->misc.name);\r\nout_free_log:\r\nkfree(log);\r\nout_free_buffer:\r\nvfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int __init logger_init(void)\r\n{\r\nint ret;\r\nret = create_log(LOGGER_LOG_MAIN, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_EVENTS, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_RADIO, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_SYSTEM, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit logger_exit(void)\r\n{\r\nstruct logger_log *current_log, *next_log;\r\nlist_for_each_entry_safe(current_log, next_log, &log_list, logs) {\r\nmisc_deregister(&current_log->misc);\r\nvfree(current_log->buffer);\r\nkfree(current_log->misc.name);\r\nlist_del(&current_log->logs);\r\nkfree(current_log);\r\n}\r\n}
