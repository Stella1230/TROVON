static int em_text_match(struct sk_buff *skb, struct tcf_ematch *m,\r\nstruct tcf_pkt_info *info)\r\n{\r\nstruct text_match *tm = EM_TEXT_PRIV(m);\r\nint from, to;\r\nstruct ts_state state;\r\nfrom = tcf_get_base_ptr(skb, tm->from_layer) - skb->data;\r\nfrom += tm->from_offset;\r\nto = tcf_get_base_ptr(skb, tm->to_layer) - skb->data;\r\nto += tm->to_offset;\r\nreturn skb_find_text(skb, from, to, tm->config, &state) != UINT_MAX;\r\n}\r\nstatic int em_text_change(struct net *net, void *data, int len,\r\nstruct tcf_ematch *m)\r\n{\r\nstruct text_match *tm;\r\nstruct tcf_em_text *conf = data;\r\nstruct ts_config *ts_conf;\r\nint flags = 0;\r\nif (len < sizeof(*conf) || len < (sizeof(*conf) + conf->pattern_len))\r\nreturn -EINVAL;\r\nif (conf->from_layer > conf->to_layer)\r\nreturn -EINVAL;\r\nif (conf->from_layer == conf->to_layer &&\r\nconf->from_offset > conf->to_offset)\r\nreturn -EINVAL;\r\nretry:\r\nts_conf = textsearch_prepare(conf->algo, (u8 *) conf + sizeof(*conf),\r\nconf->pattern_len, GFP_KERNEL, flags);\r\nif (flags & TS_AUTOLOAD)\r\nrtnl_lock();\r\nif (IS_ERR(ts_conf)) {\r\nif (PTR_ERR(ts_conf) == -ENOENT && !(flags & TS_AUTOLOAD)) {\r\nrtnl_unlock();\r\nflags |= TS_AUTOLOAD;\r\ngoto retry;\r\n} else\r\nreturn PTR_ERR(ts_conf);\r\n} else if (flags & TS_AUTOLOAD) {\r\ntextsearch_destroy(ts_conf);\r\nreturn -EAGAIN;\r\n}\r\ntm = kmalloc(sizeof(*tm), GFP_KERNEL);\r\nif (tm == NULL) {\r\ntextsearch_destroy(ts_conf);\r\nreturn -ENOBUFS;\r\n}\r\ntm->from_offset = conf->from_offset;\r\ntm->to_offset = conf->to_offset;\r\ntm->from_layer = conf->from_layer;\r\ntm->to_layer = conf->to_layer;\r\ntm->config = ts_conf;\r\nm->datalen = sizeof(*tm);\r\nm->data = (unsigned long) tm;\r\nreturn 0;\r\n}\r\nstatic void em_text_destroy(struct tcf_ematch *m)\r\n{\r\nif (EM_TEXT_PRIV(m) && EM_TEXT_PRIV(m)->config)\r\ntextsearch_destroy(EM_TEXT_PRIV(m)->config);\r\n}\r\nstatic int em_text_dump(struct sk_buff *skb, struct tcf_ematch *m)\r\n{\r\nstruct text_match *tm = EM_TEXT_PRIV(m);\r\nstruct tcf_em_text conf;\r\nstrncpy(conf.algo, tm->config->ops->name, sizeof(conf.algo) - 1);\r\nconf.from_offset = tm->from_offset;\r\nconf.to_offset = tm->to_offset;\r\nconf.from_layer = tm->from_layer;\r\nconf.to_layer = tm->to_layer;\r\nconf.pattern_len = textsearch_get_pattern_len(tm->config);\r\nconf.pad = 0;\r\nif (nla_put_nohdr(skb, sizeof(conf), &conf) < 0)\r\ngoto nla_put_failure;\r\nif (nla_append(skb, conf.pattern_len,\r\ntextsearch_get_pattern(tm->config)) < 0)\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init init_em_text(void)\r\n{\r\nreturn tcf_em_register(&em_text_ops);\r\n}\r\nstatic void __exit exit_em_text(void)\r\n{\r\ntcf_em_unregister(&em_text_ops);\r\n}
