static unsigned long sil680_selreg(struct ata_port *ap, int r)\r\n{\r\nunsigned long base = 0xA0 + r;\r\nbase += (ap->port_no << 4);\r\nreturn base;\r\n}\r\nstatic unsigned long sil680_seldev(struct ata_port *ap, struct ata_device *adev, int r)\r\n{\r\nunsigned long base = 0xA0 + r;\r\nbase += (ap->port_no << 4);\r\nbase |= adev->devno ? 2 : 0;\r\nreturn base;\r\n}\r\nstatic int sil680_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long addr = sil680_selreg(ap, 0);\r\nu8 ata66;\r\npci_read_config_byte(pdev, addr, &ata66);\r\nif (ata66 & 1)\r\nreturn ATA_CBL_PATA80;\r\nelse\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic void sil680_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u16 speed_p[5] = {\r\n0x328A, 0x2283, 0x1104, 0x10C3, 0x10C1\r\n};\r\nstatic const u16 speed_t[5] = {\r\n0x328A, 0x2283, 0x1281, 0x10C3, 0x10C1\r\n};\r\nunsigned long tfaddr = sil680_selreg(ap, 0x02);\r\nunsigned long addr = sil680_seldev(ap, adev, 0x04);\r\nunsigned long addr_mask = 0x80 + 4 * ap->port_no;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint pio = adev->pio_mode - XFER_PIO_0;\r\nint lowest_pio = pio;\r\nint port_shift = 4 * adev->devno;\r\nu16 reg;\r\nu8 mode;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nif (pair != NULL && adev->pio_mode > pair->pio_mode)\r\nlowest_pio = pair->pio_mode - XFER_PIO_0;\r\npci_write_config_word(pdev, addr, speed_p[pio]);\r\npci_write_config_word(pdev, tfaddr, speed_t[lowest_pio]);\r\npci_read_config_word(pdev, tfaddr-2, &reg);\r\npci_read_config_byte(pdev, addr_mask, &mode);\r\nreg &= ~0x0200;\r\nmode &= ~(3 << port_shift);\r\nif (ata_pio_need_iordy(adev)) {\r\nreg |= 0x0200;\r\nmode |= 1 << port_shift;\r\n}\r\npci_write_config_word(pdev, tfaddr-2, reg);\r\npci_write_config_byte(pdev, addr_mask, mode);\r\n}\r\nstatic void sil680_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u8 ultra_table[2][7] = {\r\n{ 0x0C, 0x07, 0x05, 0x04, 0x02, 0x01, 0xFF },\r\n{ 0x0F, 0x0B, 0x07, 0x05, 0x03, 0x02, 0x01 },\r\n};\r\nstatic const u16 dma_table[3] = { 0x2208, 0x10C2, 0x10C1 };\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long ma = sil680_seldev(ap, adev, 0x08);\r\nunsigned long ua = sil680_seldev(ap, adev, 0x0C);\r\nunsigned long addr_mask = 0x80 + 4 * ap->port_no;\r\nint port_shift = adev->devno * 4;\r\nu8 scsc, mode;\r\nu16 multi, ultra;\r\npci_read_config_byte(pdev, 0x8A, &scsc);\r\npci_read_config_byte(pdev, addr_mask, &mode);\r\npci_read_config_word(pdev, ma, &multi);\r\npci_read_config_word(pdev, ua, &ultra);\r\nultra &= ~0x3F;\r\nmode &= ~(0x03 << port_shift);\r\nscsc = (scsc & 0x30) ? 1 : 0;\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nmulti = 0x10C1;\r\nultra |= ultra_table[scsc][adev->dma_mode - XFER_UDMA_0];\r\nmode |= (0x03 << port_shift);\r\n} else {\r\nmulti = dma_table[adev->dma_mode - XFER_MW_DMA_0];\r\nmode |= (0x02 << port_shift);\r\n}\r\npci_write_config_byte(pdev, addr_mask, mode);\r\npci_write_config_word(pdev, ma, multi);\r\npci_write_config_word(pdev, ua, ultra);\r\n}\r\nstatic void sil680_sff_exec_command(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nDPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);\r\niowrite8(tf->command, ap->ioaddr.command_addr);\r\nioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);\r\n}\r\nstatic bool sil680_sff_irq_check(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long addr = sil680_selreg(ap, 1);\r\nu8 val;\r\npci_read_config_byte(pdev, addr, &val);\r\nreturn val & 0x08;\r\n}\r\nstatic u8 sil680_init_chip(struct pci_dev *pdev, int *try_mmio)\r\n{\r\nu8 tmpbyte = 0;\r\npci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE,\r\npdev->revision ? 1 : 255);\r\npci_write_config_byte(pdev, 0x80, 0x00);\r\npci_write_config_byte(pdev, 0x84, 0x00);\r\npci_read_config_byte(pdev, 0x8A, &tmpbyte);\r\ndev_dbg(&pdev->dev, "sil680: BA5_EN = %d clock = %02X\n",\r\ntmpbyte & 1, tmpbyte & 0x30);\r\n*try_mmio = 0;\r\n#ifdef CONFIG_PPC\r\nif (machine_is(cell))\r\n*try_mmio = (tmpbyte & 1) || pci_resource_start(pdev, 5);\r\n#endif\r\nswitch (tmpbyte & 0x30) {\r\ncase 0x00:\r\npci_write_config_byte(pdev, 0x8A, tmpbyte|0x10);\r\nbreak;\r\ncase 0x30:\r\npci_write_config_byte(pdev, 0x8A, tmpbyte & ~0x20);\r\nbreak;\r\ncase 0x10:\r\nbreak;\r\ncase 0x20:\r\nbreak;\r\n}\r\npci_read_config_byte(pdev, 0x8A, &tmpbyte);\r\ndev_dbg(&pdev->dev, "sil680: BA5_EN = %d clock = %02X\n",\r\ntmpbyte & 1, tmpbyte & 0x30);\r\npci_write_config_byte(pdev, 0xA1, 0x72);\r\npci_write_config_word(pdev, 0xA2, 0x328A);\r\npci_write_config_dword(pdev, 0xA4, 0x62DD62DD);\r\npci_write_config_dword(pdev, 0xA8, 0x43924392);\r\npci_write_config_dword(pdev, 0xAC, 0x40094009);\r\npci_write_config_byte(pdev, 0xB1, 0x72);\r\npci_write_config_word(pdev, 0xB2, 0x328A);\r\npci_write_config_dword(pdev, 0xB4, 0x62DD62DD);\r\npci_write_config_dword(pdev, 0xB8, 0x43924392);\r\npci_write_config_dword(pdev, 0xBC, 0x40094009);\r\nswitch (tmpbyte & 0x30) {\r\ncase 0x00:\r\nprintk(KERN_INFO "sil680: 100MHz clock.\n");\r\nbreak;\r\ncase 0x10:\r\nprintk(KERN_INFO "sil680: 133MHz clock.\n");\r\nbreak;\r\ncase 0x20:\r\nprintk(KERN_INFO "sil680: Using PCI clock.\n");\r\nbreak;\r\ncase 0x30:\r\nprintk(KERN_ERR "sil680: Clock disabled ?\n");\r\n}\r\nreturn tmpbyte & 0x30;\r\n}\r\nstatic int sil680_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &sil680_port_ops\r\n};\r\nstatic const struct ata_port_info info_slow = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &sil680_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { &info, NULL };\r\nstruct ata_host *host;\r\nvoid __iomem *mmio_base;\r\nint rc, try_mmio;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nswitch (sil680_init_chip(pdev, &try_mmio)) {\r\ncase 0:\r\nppi[0] = &info_slow;\r\nbreak;\r\ncase 0x30:\r\nreturn -ENODEV;\r\n}\r\nif (!try_mmio)\r\ngoto use_ioports;\r\nrc = pcim_iomap_regions(pdev, 1 << SIL680_MMIO_BAR, DRV_NAME);\r\nif (rc)\r\ngoto use_ioports;\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\npci_set_master(pdev);\r\nmmio_base = host->iomap[SIL680_MMIO_BAR];\r\nhost->ports[0]->ioaddr.bmdma_addr = mmio_base + 0x00;\r\nhost->ports[0]->ioaddr.cmd_addr = mmio_base + 0x80;\r\nhost->ports[0]->ioaddr.ctl_addr = mmio_base + 0x8a;\r\nhost->ports[0]->ioaddr.altstatus_addr = mmio_base + 0x8a;\r\nata_sff_std_ports(&host->ports[0]->ioaddr);\r\nhost->ports[1]->ioaddr.bmdma_addr = mmio_base + 0x08;\r\nhost->ports[1]->ioaddr.cmd_addr = mmio_base + 0xc0;\r\nhost->ports[1]->ioaddr.ctl_addr = mmio_base + 0xca;\r\nhost->ports[1]->ioaddr.altstatus_addr = mmio_base + 0xca;\r\nata_sff_std_ports(&host->ports[1]->ioaddr);\r\nreturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &sil680_sht);\r\nuse_ioports:\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &sil680_sht, NULL, 0);\r\n}\r\nstatic int sil680_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint try_mmio, rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nsil680_init_chip(pdev, &try_mmio);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
