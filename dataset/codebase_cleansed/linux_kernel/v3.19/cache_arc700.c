char *arc_cache_mumbojumbo(int c, char *buf, int len)\r\n{\r\nint n = 0;\r\n#define PR_CACHE(p, cfg, str) \\r\nif (!(p)->ver) \\r\nn += scnprintf(buf + n, len - n, str"\t\t: N/A\n"); \\r\nelse \\r\nn += scnprintf(buf + n, len - n, \\r\nstr"\t\t: %uK, %dway/set, %uB Line, %s%s%s\n", \\r\n(p)->sz_k, (p)->assoc, (p)->line_len, \\r\n(p)->vipt ? "VIPT" : "PIPT", \\r\n(p)->alias ? " aliasing" : "", \\r\nIS_ENABLED(cfg) ? "" : " (not used)");\r\nPR_CACHE(&cpuinfo_arc700[c].icache, CONFIG_ARC_HAS_ICACHE, "I-Cache");\r\nPR_CACHE(&cpuinfo_arc700[c].dcache, CONFIG_ARC_HAS_DCACHE, "D-Cache");\r\nreturn buf;\r\n}\r\nvoid read_decode_cache_bcr(void)\r\n{\r\nstruct cpuinfo_arc_cache *p_ic, *p_dc;\r\nunsigned int cpu = smp_processor_id();\r\nstruct bcr_cache {\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nunsigned int pad:12, line_len:4, sz:4, config:4, ver:8;\r\n#else\r\nunsigned int ver:8, config:4, sz:4, line_len:4, pad:12;\r\n#endif\r\n} ibcr, dbcr;\r\np_ic = &cpuinfo_arc700[cpu].icache;\r\nREAD_BCR(ARC_REG_IC_BCR, ibcr);\r\nif (!ibcr.ver)\r\ngoto dc_chk;\r\nBUG_ON(ibcr.config != 3);\r\np_ic->assoc = 2;\r\np_ic->line_len = 8 << ibcr.line_len;\r\np_ic->sz_k = 1 << (ibcr.sz - 1);\r\np_ic->ver = ibcr.ver;\r\np_ic->vipt = 1;\r\np_ic->alias = p_ic->sz_k/p_ic->assoc/TO_KB(PAGE_SIZE) > 1;\r\ndc_chk:\r\np_dc = &cpuinfo_arc700[cpu].dcache;\r\nREAD_BCR(ARC_REG_DC_BCR, dbcr);\r\nif (!dbcr.ver)\r\nreturn;\r\nBUG_ON(dbcr.config != 2);\r\np_dc->assoc = 4;\r\np_dc->line_len = 16 << dbcr.line_len;\r\np_dc->sz_k = 1 << (dbcr.sz - 1);\r\np_dc->ver = dbcr.ver;\r\np_dc->vipt = 1;\r\np_dc->alias = p_dc->sz_k/p_dc->assoc/TO_KB(PAGE_SIZE) > 1;\r\n}\r\nvoid arc_cache_init(void)\r\n{\r\nunsigned int __maybe_unused cpu = smp_processor_id();\r\nchar str[256];\r\nprintk(arc_cache_mumbojumbo(0, str, sizeof(str)));\r\nif (IS_ENABLED(CONFIG_ARC_HAS_ICACHE)) {\r\nstruct cpuinfo_arc_cache *ic = &cpuinfo_arc700[cpu].icache;\r\nif (!ic->ver)\r\npanic("cache support enabled but non-existent cache\n");\r\nif (ic->line_len != L1_CACHE_BYTES)\r\npanic("ICache line [%d] != kernel Config [%d]",\r\nic->line_len, L1_CACHE_BYTES);\r\nif (ic->ver != CONFIG_ARC_MMU_VER)\r\npanic("Cache ver [%d] doesn't match MMU ver [%d]\n",\r\nic->ver, CONFIG_ARC_MMU_VER);\r\n}\r\nif (IS_ENABLED(CONFIG_ARC_HAS_DCACHE)) {\r\nstruct cpuinfo_arc_cache *dc = &cpuinfo_arc700[cpu].dcache;\r\nint handled;\r\nif (!dc->ver)\r\npanic("cache support enabled but non-existent cache\n");\r\nif (dc->line_len != L1_CACHE_BYTES)\r\npanic("DCache line [%d] != kernel Config [%d]",\r\ndc->line_len, L1_CACHE_BYTES);\r\nhandled = IS_ENABLED(CONFIG_ARC_CACHE_VIPT_ALIASING);\r\nif (dc->alias && !handled)\r\npanic("Enable CONFIG_ARC_CACHE_VIPT_ALIASING\n");\r\nelse if (!dc->alias && handled)\r\npanic("Don't need CONFIG_ARC_CACHE_VIPT_ALIASING\n");\r\n}\r\n}\r\nstatic inline void __cache_line_loop(unsigned long paddr, unsigned long vaddr,\r\nunsigned long sz, const int cacheop)\r\n{\r\nunsigned int aux_cmd, aux_tag;\r\nint num_lines;\r\nconst int full_page_op = __builtin_constant_p(sz) && sz == PAGE_SIZE;\r\nif (cacheop == OP_INV_IC) {\r\naux_cmd = ARC_REG_IC_IVIL;\r\n#if (CONFIG_ARC_MMU_VER > 2)\r\naux_tag = ARC_REG_IC_PTAG;\r\n#endif\r\n}\r\nelse {\r\naux_cmd = cacheop & OP_INV ? ARC_REG_DC_IVDL : ARC_REG_DC_FLDL;\r\n#if (CONFIG_ARC_MMU_VER > 2)\r\naux_tag = ARC_REG_DC_PTAG;\r\n#endif\r\n}\r\nif (!full_page_op) {\r\nsz += paddr & ~CACHE_LINE_MASK;\r\npaddr &= CACHE_LINE_MASK;\r\nvaddr &= CACHE_LINE_MASK;\r\n}\r\nnum_lines = DIV_ROUND_UP(sz, L1_CACHE_BYTES);\r\n#if (CONFIG_ARC_MMU_VER <= 2)\r\npaddr |= (vaddr >> PAGE_SHIFT) & 0x1F;\r\n#else\r\nif (full_page_op)\r\nwrite_aux_reg(aux_tag, paddr);\r\n#endif\r\nwhile (num_lines-- > 0) {\r\n#if (CONFIG_ARC_MMU_VER > 2)\r\nif (!full_page_op) {\r\nwrite_aux_reg(aux_tag, paddr);\r\npaddr += L1_CACHE_BYTES;\r\n}\r\nwrite_aux_reg(aux_cmd, vaddr);\r\nvaddr += L1_CACHE_BYTES;\r\n#else\r\nwrite_aux_reg(aux_cmd, paddr);\r\npaddr += L1_CACHE_BYTES;\r\n#endif\r\n}\r\n}\r\nstatic unsigned int __before_dc_op(const int op)\r\n{\r\nunsigned int reg = reg;\r\nif (op == OP_FLUSH_N_INV) {\r\nreg = read_aux_reg(ARC_REG_DC_CTRL);\r\nwrite_aux_reg(ARC_REG_DC_CTRL, reg | DC_CTRL_INV_MODE_FLUSH)\r\n;\r\n}\r\nreturn reg;\r\n}\r\nstatic void __after_dc_op(const int op, unsigned int reg)\r\n{\r\nif (op & OP_FLUSH)\r\nwhile (read_aux_reg(ARC_REG_DC_CTRL) & DC_CTRL_FLUSH_STATUS);\r\nif (op == OP_FLUSH_N_INV)\r\nwrite_aux_reg(ARC_REG_DC_CTRL, reg & ~DC_CTRL_INV_MODE_FLUSH);\r\n}\r\nstatic inline void __dc_entire_op(const int cacheop)\r\n{\r\nunsigned int ctrl_reg;\r\nint aux;\r\nctrl_reg = __before_dc_op(cacheop);\r\nif (cacheop & OP_INV)\r\naux = ARC_REG_DC_IVDC;\r\nelse\r\naux = ARC_REG_DC_FLSH;\r\nwrite_aux_reg(aux, 0x1);\r\n__after_dc_op(cacheop, ctrl_reg);\r\n}\r\nstatic inline void __dc_line_op(unsigned long paddr, unsigned long vaddr,\r\nunsigned long sz, const int cacheop)\r\n{\r\nunsigned long flags;\r\nunsigned int ctrl_reg;\r\nlocal_irq_save(flags);\r\nctrl_reg = __before_dc_op(cacheop);\r\n__cache_line_loop(paddr, vaddr, sz, cacheop);\r\n__after_dc_op(cacheop, ctrl_reg);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline void __ic_entire_inv(void)\r\n{\r\nwrite_aux_reg(ARC_REG_IC_IVIC, 1);\r\nread_aux_reg(ARC_REG_IC_CTRL);\r\n}\r\nstatic inline void\r\n__ic_line_inv_vaddr_local(unsigned long paddr, unsigned long vaddr,\r\nunsigned long sz)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n__cache_line_loop(paddr, vaddr, sz, OP_INV_IC);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void __ic_line_inv_vaddr_helper(void *info)\r\n{\r\nstruct ic_inv_args *ic_inv = info;\r\n__ic_line_inv_vaddr_local(ic_inv->paddr, ic_inv->vaddr, ic_inv->sz);\r\n}\r\nstatic void __ic_line_inv_vaddr(unsigned long paddr, unsigned long vaddr,\r\nunsigned long sz)\r\n{\r\nstruct ic_inv_args ic_inv = {\r\n.paddr = paddr,\r\n.vaddr = vaddr,\r\n.sz = sz\r\n};\r\non_each_cpu(__ic_line_inv_vaddr_helper, &ic_inv, 1);\r\n}\r\nvoid flush_dcache_page(struct page *page)\r\n{\r\nstruct address_space *mapping;\r\nif (!cache_is_vipt_aliasing()) {\r\nclear_bit(PG_dc_clean, &page->flags);\r\nreturn;\r\n}\r\nmapping = page_mapping(page);\r\nif (!mapping)\r\nreturn;\r\nif (!mapping_mapped(mapping)) {\r\nclear_bit(PG_dc_clean, &page->flags);\r\n} else if (page_mapped(page)) {\r\nvoid *paddr = page_address(page);\r\nunsigned long vaddr = page->index << PAGE_CACHE_SHIFT;\r\nif (addr_not_cache_congruent(paddr, vaddr))\r\n__flush_dcache_page(paddr, vaddr);\r\n}\r\n}\r\nvoid dma_cache_wback_inv(unsigned long start, unsigned long sz)\r\n{\r\n__dc_line_op_k(start, sz, OP_FLUSH_N_INV);\r\n}\r\nvoid dma_cache_inv(unsigned long start, unsigned long sz)\r\n{\r\n__dc_line_op_k(start, sz, OP_INV);\r\n}\r\nvoid dma_cache_wback(unsigned long start, unsigned long sz)\r\n{\r\n__dc_line_op_k(start, sz, OP_FLUSH);\r\n}\r\nvoid flush_icache_range(unsigned long kstart, unsigned long kend)\r\n{\r\nunsigned int tot_sz;\r\nWARN(kstart < TASK_SIZE, "%s() can't handle user vaddr", __func__);\r\ntot_sz = kend - kstart;\r\nif (tot_sz > PAGE_SIZE) {\r\nflush_cache_all();\r\nreturn;\r\n}\r\nif (likely(kstart > PAGE_OFFSET)) {\r\n__sync_icache_dcache(kstart, kstart, kend - kstart);\r\nreturn;\r\n}\r\nwhile (tot_sz > 0) {\r\nunsigned int off, sz;\r\nunsigned long phy, pfn;\r\noff = kstart % PAGE_SIZE;\r\npfn = vmalloc_to_pfn((void *)kstart);\r\nphy = (pfn << PAGE_SHIFT) + off;\r\nsz = min_t(unsigned int, tot_sz, PAGE_SIZE - off);\r\n__sync_icache_dcache(phy, kstart, sz);\r\nkstart += sz;\r\ntot_sz -= sz;\r\n}\r\n}\r\nvoid __sync_icache_dcache(unsigned long paddr, unsigned long vaddr, int len)\r\n{\r\n__dc_line_op(paddr, vaddr, len, OP_FLUSH_N_INV);\r\n__ic_line_inv_vaddr(paddr, vaddr, len);\r\n}\r\nvoid __inv_icache_page(unsigned long paddr, unsigned long vaddr)\r\n{\r\n__ic_line_inv_vaddr(paddr, vaddr, PAGE_SIZE);\r\n}\r\nvoid ___flush_dcache_page(unsigned long paddr, unsigned long vaddr)\r\n{\r\n__dc_line_op(paddr, vaddr & PAGE_MASK, PAGE_SIZE, OP_FLUSH_N_INV);\r\n}\r\nnoinline void flush_cache_all(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n__ic_entire_inv();\r\n__dc_entire_op(OP_FLUSH_N_INV);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid flush_cache_mm(struct mm_struct *mm)\r\n{\r\nflush_cache_all();\r\n}\r\nvoid flush_cache_page(struct vm_area_struct *vma, unsigned long u_vaddr,\r\nunsigned long pfn)\r\n{\r\nunsigned int paddr = pfn << PAGE_SHIFT;\r\nu_vaddr &= PAGE_MASK;\r\n___flush_dcache_page(paddr, u_vaddr);\r\nif (vma->vm_flags & VM_EXEC)\r\n__inv_icache_page(paddr, u_vaddr);\r\n}\r\nvoid flush_cache_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nflush_cache_all();\r\n}\r\nvoid flush_anon_page(struct vm_area_struct *vma, struct page *page,\r\nunsigned long u_vaddr)\r\n{\r\n__flush_dcache_page(page_address(page), u_vaddr);\r\n__flush_dcache_page(page_address(page), page_address(page));\r\n}\r\nvoid copy_user_highpage(struct page *to, struct page *from,\r\nunsigned long u_vaddr, struct vm_area_struct *vma)\r\n{\r\nvoid *kfrom = page_address(from);\r\nvoid *kto = page_address(to);\r\nint clean_src_k_mappings = 0;\r\nif (page_mapped(from) && addr_not_cache_congruent(kfrom, u_vaddr)) {\r\n__flush_dcache_page(kfrom, u_vaddr);\r\nclean_src_k_mappings = 1;\r\n}\r\ncopy_page(kto, kfrom);\r\nclear_bit(PG_dc_clean, &to->flags);\r\nif (clean_src_k_mappings) {\r\n__flush_dcache_page(kfrom, kfrom);\r\nset_bit(PG_dc_clean, &from->flags);\r\n} else {\r\nclear_bit(PG_dc_clean, &from->flags);\r\n}\r\n}\r\nvoid clear_user_page(void *to, unsigned long u_vaddr, struct page *page)\r\n{\r\nclear_page(to);\r\nclear_bit(PG_dc_clean, &page->flags);\r\n}
