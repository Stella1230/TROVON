static int __init\r\nparam_setup(char *string)\r\n{\r\nchar *pos = string, *next;\r\nint slot = -1, siop = -1;\r\nwhile(pos != NULL && (next = strchr(pos, ':')) != NULL) {\r\nint val = (int)simple_strtoul(++next, NULL, 0);\r\nif(!strncmp(pos, "slot:", 5))\r\nslot = val;\r\nelse if(!strncmp(pos, "siop:", 5))\r\nsiop = val;\r\nelse if(!strncmp(pos, "id:", 3)) {\r\nif(slot == -1) {\r\nprintk(KERN_WARNING "NCR D700: Must specify slot for id parameter\n");\r\n} else if(slot > MCA_MAX_SLOT_NR) {\r\nprintk(KERN_WARNING "NCR D700: Illegal slot %d for id %d\n", slot, val);\r\n} else {\r\nif(siop != 0 && siop != 1) {\r\nid_array[slot*2] = val;\r\nid_array[slot*2 + 1] =val;\r\n} else {\r\nid_array[slot*2 + siop] = val;\r\n}\r\n}\r\n}\r\nif((pos = strchr(pos, ARG_SEP)) != NULL)\r\npos++;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nNCR_D700_probe_one(struct NCR_D700_private *p, int siop, int irq,\r\nint slot, u32 region, int differential)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata;\r\nstruct Scsi_Host *host;\r\nint ret;\r\nhostdata = kzalloc(sizeof(*hostdata), GFP_KERNEL);\r\nif (!hostdata) {\r\nprintk(KERN_ERR "NCR D700: SIOP%d: Failed to allocate host"\r\n"data, detatching\n", siop);\r\nreturn -ENOMEM;\r\n}\r\nif (!request_region(region, 64, "NCR_D700")) {\r\nprintk(KERN_ERR "NCR D700: Failed to reserve IO region 0x%x\n",\r\nregion);\r\nret = -ENODEV;\r\ngoto region_failed;\r\n}\r\nhostdata->base = ioport_map(region, 64);\r\nhostdata->differential = (((1<<siop) & differential) != 0);\r\nhostdata->clock = NCR_D700_CLOCK_MHZ;\r\nhostdata->burst_length = 8;\r\nhost = NCR_700_detect(&NCR_D700_driver_template, hostdata, p->dev);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto detect_failed;\r\n}\r\np->hosts[siop] = host;\r\nhost->this_id = id_array[slot * 2 + siop];\r\nhost->irq = irq;\r\nhost->base = region;\r\nscsi_scan_host(host);\r\nreturn 0;\r\ndetect_failed:\r\nrelease_region(region, 64);\r\nregion_failed:\r\nkfree(hostdata);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nNCR_D700_intr(int irq, void *data)\r\n{\r\nstruct NCR_D700_private *p = (struct NCR_D700_private *)data;\r\nint i, found = 0;\r\nfor (i = 0; i < 2; i++)\r\nif (p->hosts[i] &&\r\nNCR_700_intr(irq, p->hosts[i]) == IRQ_HANDLED)\r\nfound++;\r\nreturn found ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int\r\nNCR_D700_probe(struct device *dev)\r\n{\r\nstruct NCR_D700_private *p;\r\nint differential;\r\nstatic int banner = 1;\r\nstruct mca_device *mca_dev = to_mca_device(dev);\r\nint slot = mca_dev->slot;\r\nint found = 0;\r\nint irq, i;\r\nint pos3j, pos3k, pos3a, pos3b, pos4;\r\n__u32 base_addr, offset_addr;\r\npos4 = mca_device_read_pos(mca_dev, 4);\r\npos4 |= 0x4;\r\nmca_device_write_pos(mca_dev, 4, pos4);\r\nmca_device_write_pos(mca_dev, 6, 9);\r\npos3j = mca_device_read_pos(mca_dev, 3);\r\nmca_device_write_pos(mca_dev, 6, 10);\r\npos3k = mca_device_read_pos(mca_dev, 3);\r\nmca_device_write_pos(mca_dev, 6, 0);\r\npos3a = mca_device_read_pos(mca_dev, 3);\r\nmca_device_write_pos(mca_dev, 6, 1);\r\npos3b = mca_device_read_pos(mca_dev, 3);\r\nbase_addr = ((pos3j << 8) | pos3k) & 0xfffffff0;\r\noffset_addr = ((pos3a << 8) | pos3b) & 0xffffff70;\r\nirq = (pos4 & 0x3) + 11;\r\nif(irq >= 13)\r\nirq++;\r\nif(banner) {\r\nprintk(KERN_NOTICE "NCR D700: Driver Version " NCR_D700_VERSION "\n"\r\n"NCR D700: Copyright (c) 2001 by James.Bottomley@HansenPartnership.com\n"\r\n"NCR D700:\n");\r\nbanner = 0;\r\n}\r\nirq = mca_device_transform_irq(mca_dev, irq);\r\nbase_addr = mca_device_transform_ioport(mca_dev, base_addr);\r\noffset_addr = mca_device_transform_ioport(mca_dev, offset_addr);\r\nprintk(KERN_NOTICE "NCR D700: found in slot %d irq = %d I/O base = 0x%x\n", slot, irq, offset_addr);\r\n(void)inb(base_addr + 0x08);\r\nswitch(differential = (inb(base_addr + 0x08) >> 6)) {\r\ncase 0x00:\r\ndifferential = 0x02;\r\nbreak;\r\ncase 0x01:\r\ndifferential = 0x03;\r\nbreak;\r\ncase 0x03:\r\ndifferential = 0x00;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "D700: UNEXPECTED DIFFERENTIAL RESULT 0x%02x\n",\r\ndifferential);\r\ndifferential = 0x00;\r\nbreak;\r\n}\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->dev = dev;\r\nsnprintf(p->name, sizeof(p->name), "D700(%s)", dev_name(dev));\r\nif (request_irq(irq, NCR_D700_intr, IRQF_SHARED, p->name, p)) {\r\nprintk(KERN_ERR "D700: request_irq failed\n");\r\nkfree(p);\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nint err;\r\nif ((err = NCR_D700_probe_one(p, i, irq, slot,\r\noffset_addr + (0x80 * i),\r\ndifferential)) != 0)\r\nprintk("D700: SIOP%d: probe failed, error = %d\n",\r\ni, err);\r\nelse\r\nfound++;\r\n}\r\nif (!found) {\r\nkfree(p);\r\nreturn -ENODEV;\r\n}\r\nmca_device_set_claim(mca_dev, 1);\r\nmca_device_set_name(mca_dev, "NCR_D700");\r\ndev_set_drvdata(dev, p);\r\nreturn 0;\r\n}\r\nstatic void\r\nNCR_D700_remove_one(struct Scsi_Host *host)\r\n{\r\nscsi_remove_host(host);\r\nNCR_700_release(host);\r\nkfree((struct NCR_700_Host_Parameters *)host->hostdata[0]);\r\nfree_irq(host->irq, host);\r\nrelease_region(host->base, 64);\r\n}\r\nstatic int\r\nNCR_D700_remove(struct device *dev)\r\n{\r\nstruct NCR_D700_private *p = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nNCR_D700_remove_one(p->hosts[i]);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nstatic int __init NCR_D700_init(void)\r\n{\r\n#ifdef MODULE\r\nif (NCR_D700)\r\nparam_setup(NCR_D700);\r\n#endif\r\nreturn mca_register_driver(&NCR_D700_driver);\r\n}\r\nstatic void __exit NCR_D700_exit(void)\r\n{\r\nmca_unregister_driver(&NCR_D700_driver);\r\n}
