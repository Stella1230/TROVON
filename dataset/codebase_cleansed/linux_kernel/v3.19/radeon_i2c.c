bool radeon_ddc_probe(struct radeon_connector *radeon_connector, bool use_aux)\r\n{\r\nu8 out = 0x0;\r\nu8 buf[8];\r\nint ret;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = DDC_ADDR,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &out,\r\n},\r\n{\r\n.addr = DDC_ADDR,\r\n.flags = I2C_M_RD,\r\n.len = 8,\r\n.buf = buf,\r\n}\r\n};\r\nif (radeon_connector->router.ddc_valid)\r\nradeon_router_select_ddc_port(radeon_connector);\r\nif (use_aux) {\r\nret = i2c_transfer(&radeon_connector->ddc_bus->aux.ddc, msgs, 2);\r\n} else {\r\nret = i2c_transfer(&radeon_connector->ddc_bus->adapter, msgs, 2);\r\n}\r\nif (ret != 2)\r\nreturn false;\r\nif (drm_edid_header_is_valid(buf) < 6) {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int pre_xfer(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t temp;\r\nmutex_lock(&i2c->mutex);\r\nif (rec->hw_capable) {\r\nif ((rdev->family >= CHIP_R200) && !ASIC_IS_AVIVO(rdev)) {\r\nu32 reg;\r\nif (rdev->family >= CHIP_RV350)\r\nreg = RADEON_GPIO_MONID;\r\nelse if ((rdev->family == CHIP_R300) ||\r\n(rdev->family == CHIP_R350))\r\nreg = RADEON_GPIO_DVI_DDC;\r\nelse\r\nreg = RADEON_GPIO_CRT2_DDC;\r\nmutex_lock(&rdev->dc_hw_i2c_mutex);\r\nif (rec->a_clk_reg == reg) {\r\nWREG32(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |\r\nR200_DVI_I2C_PIN_SEL(R200_SEL_DDC1)));\r\n} else {\r\nWREG32(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |\r\nR200_DVI_I2C_PIN_SEL(R200_SEL_DDC3)));\r\n}\r\nmutex_unlock(&rdev->dc_hw_i2c_mutex);\r\n}\r\n}\r\nif (ASIC_IS_DCE3(rdev) && rec->hw_capable) {\r\ntemp = RREG32(rec->mask_clk_reg);\r\ntemp &= ~(1 << 16);\r\nWREG32(rec->mask_clk_reg, temp);\r\n}\r\ntemp = RREG32(rec->a_clk_reg) & ~rec->a_clk_mask;\r\nWREG32(rec->a_clk_reg, temp);\r\ntemp = RREG32(rec->a_data_reg) & ~rec->a_data_mask;\r\nWREG32(rec->a_data_reg, temp);\r\ntemp = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\r\nWREG32(rec->en_clk_reg, temp);\r\ntemp = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\r\nWREG32(rec->en_data_reg, temp);\r\ntemp = RREG32(rec->mask_clk_reg) | rec->mask_clk_mask;\r\nWREG32(rec->mask_clk_reg, temp);\r\ntemp = RREG32(rec->mask_clk_reg);\r\ntemp = RREG32(rec->mask_data_reg) | rec->mask_data_mask;\r\nWREG32(rec->mask_data_reg, temp);\r\ntemp = RREG32(rec->mask_data_reg);\r\nreturn 0;\r\n}\r\nstatic void post_xfer(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t temp;\r\ntemp = RREG32(rec->mask_clk_reg) & ~rec->mask_clk_mask;\r\nWREG32(rec->mask_clk_reg, temp);\r\ntemp = RREG32(rec->mask_clk_reg);\r\ntemp = RREG32(rec->mask_data_reg) & ~rec->mask_data_mask;\r\nWREG32(rec->mask_data_reg, temp);\r\ntemp = RREG32(rec->mask_data_reg);\r\nmutex_unlock(&i2c->mutex);\r\n}\r\nstatic int get_clock(void *i2c_priv)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_priv;\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t val;\r\nval = RREG32(rec->y_clk_reg);\r\nval &= rec->y_clk_mask;\r\nreturn (val != 0);\r\n}\r\nstatic int get_data(void *i2c_priv)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_priv;\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t val;\r\nval = RREG32(rec->y_data_reg);\r\nval &= rec->y_data_mask;\r\nreturn (val != 0);\r\n}\r\nstatic void set_clock(void *i2c_priv, int clock)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_priv;\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t val;\r\nval = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\r\nval |= clock ? 0 : rec->en_clk_mask;\r\nWREG32(rec->en_clk_reg, val);\r\n}\r\nstatic void set_data(void *i2c_priv, int data)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_priv;\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nuint32_t val;\r\nval = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\r\nval |= data ? 0 : rec->en_data_mask;\r\nWREG32(rec->en_data_reg, val);\r\n}\r\nstatic u32 radeon_get_i2c_prescale(struct radeon_device *rdev)\r\n{\r\nu32 sclk = rdev->pm.current_sclk;\r\nu32 prescale = 0;\r\nu32 nm;\r\nu8 n, m, loop;\r\nint i2c_clock;\r\nswitch (rdev->family) {\r\ncase CHIP_R100:\r\ncase CHIP_RV100:\r\ncase CHIP_RS100:\r\ncase CHIP_RV200:\r\ncase CHIP_RS200:\r\ncase CHIP_R200:\r\ncase CHIP_RV250:\r\ncase CHIP_RS300:\r\ncase CHIP_RV280:\r\ncase CHIP_R300:\r\ncase CHIP_R350:\r\ncase CHIP_RV350:\r\ni2c_clock = 60;\r\nnm = (sclk * 10) / (i2c_clock * 4);\r\nfor (loop = 1; loop < 255; loop++) {\r\nif ((nm / loop) < loop)\r\nbreak;\r\n}\r\nn = loop - 1;\r\nm = loop - 2;\r\nprescale = m | (n << 8);\r\nbreak;\r\ncase CHIP_RV380:\r\ncase CHIP_RS400:\r\ncase CHIP_RS480:\r\ncase CHIP_R420:\r\ncase CHIP_R423:\r\ncase CHIP_RV410:\r\nprescale = (((sclk * 10)/(4 * 128 * 100) + 1) << 8) + 128;\r\nbreak;\r\ncase CHIP_RS600:\r\ncase CHIP_RS690:\r\ncase CHIP_RS740:\r\nbreak;\r\ncase CHIP_RV515:\r\ncase CHIP_R520:\r\ncase CHIP_RV530:\r\ncase CHIP_RV560:\r\ncase CHIP_RV570:\r\ncase CHIP_R580:\r\ni2c_clock = 50;\r\nif (rdev->family == CHIP_R520)\r\nprescale = (127 << 8) + ((sclk * 10) / (4 * 127 * i2c_clock));\r\nelse\r\nprescale = (((sclk * 10)/(4 * 128 * 100) + 1) << 8) + 128;\r\nbreak;\r\ncase CHIP_R600:\r\ncase CHIP_RV610:\r\ncase CHIP_RV630:\r\ncase CHIP_RV670:\r\nbreak;\r\ncase CHIP_RV620:\r\ncase CHIP_RV635:\r\ncase CHIP_RS780:\r\ncase CHIP_RS880:\r\ncase CHIP_RV770:\r\ncase CHIP_RV730:\r\ncase CHIP_RV710:\r\ncase CHIP_RV740:\r\nbreak;\r\ncase CHIP_CEDAR:\r\ncase CHIP_REDWOOD:\r\ncase CHIP_JUNIPER:\r\ncase CHIP_CYPRESS:\r\ncase CHIP_HEMLOCK:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("i2c: unhandled radeon chip\n");\r\nbreak;\r\n}\r\nreturn prescale;\r\n}\r\nstatic int r100_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nstruct i2c_msg *p;\r\nint i, j, k, ret = num;\r\nu32 prescale;\r\nu32 i2c_cntl_0, i2c_cntl_1, i2c_data;\r\nu32 tmp, reg;\r\nmutex_lock(&rdev->dc_hw_i2c_mutex);\r\nmutex_lock(&rdev->pm.mutex);\r\nprescale = radeon_get_i2c_prescale(rdev);\r\nreg = ((prescale << RADEON_I2C_PRESCALE_SHIFT) |\r\nRADEON_I2C_DRIVE_EN |\r\nRADEON_I2C_START |\r\nRADEON_I2C_STOP |\r\nRADEON_I2C_GO);\r\nif (rdev->is_atom_bios) {\r\ntmp = RREG32(RADEON_BIOS_6_SCRATCH);\r\nWREG32(RADEON_BIOS_6_SCRATCH, tmp | ATOM_S6_HW_I2C_BUSY_STATE);\r\n}\r\nif (rec->mm_i2c) {\r\ni2c_cntl_0 = RADEON_I2C_CNTL_0;\r\ni2c_cntl_1 = RADEON_I2C_CNTL_1;\r\ni2c_data = RADEON_I2C_DATA;\r\n} else {\r\ni2c_cntl_0 = RADEON_DVI_I2C_CNTL_0;\r\ni2c_cntl_1 = RADEON_DVI_I2C_CNTL_1;\r\ni2c_data = RADEON_DVI_I2C_DATA;\r\nswitch (rdev->family) {\r\ncase CHIP_R100:\r\ncase CHIP_RV100:\r\ncase CHIP_RS100:\r\ncase CHIP_RV200:\r\ncase CHIP_RS200:\r\ncase CHIP_RS300:\r\nswitch (rec->mask_clk_reg) {\r\ncase RADEON_GPIO_DVI_DDC:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\ncase CHIP_R200:\r\nswitch (rec->mask_clk_reg) {\r\ncase RADEON_GPIO_DVI_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\r\nbreak;\r\ncase RADEON_GPIO_MONID:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\ncase CHIP_RV250:\r\ncase CHIP_RV280:\r\nswitch (rec->mask_clk_reg) {\r\ncase RADEON_GPIO_DVI_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\r\nbreak;\r\ncase RADEON_GPIO_VGA_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC2);\r\nbreak;\r\ncase RADEON_GPIO_CRT2_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\ncase CHIP_R300:\r\ncase CHIP_R350:\r\nswitch (rec->mask_clk_reg) {\r\ncase RADEON_GPIO_VGA_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\r\nbreak;\r\ncase RADEON_GPIO_DVI_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\ncase CHIP_RV350:\r\ncase CHIP_RV380:\r\ncase CHIP_R420:\r\ncase CHIP_R423:\r\ncase CHIP_RV410:\r\ncase CHIP_RS400:\r\ncase CHIP_RS480:\r\nswitch (rec->mask_clk_reg) {\r\ncase RADEON_GPIO_VGA_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\r\nbreak;\r\ncase RADEON_GPIO_DVI_DDC:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC2);\r\nbreak;\r\ncase RADEON_GPIO_MONID:\r\nreg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported asic\n");\r\nret = -EINVAL;\r\ngoto done;\r\nbreak;\r\n}\r\n}\r\np = &msgs[0];\r\nif ((num == 1) && (p->len == 0)) {\r\nWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\r\nRADEON_I2C_NACK |\r\nRADEON_I2C_HALT |\r\nRADEON_I2C_SOFT_RST));\r\nWREG32(i2c_data, (p->addr << 1) & 0xff);\r\nWREG32(i2c_data, 0);\r\nWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\r\n(1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\r\nRADEON_I2C_EN |\r\n(48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\r\nWREG32(i2c_cntl_0, reg);\r\nfor (k = 0; k < 32; k++) {\r\nudelay(10);\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c write error 0x%08x\n", tmp);\r\nWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\ngoto done;\r\n}\r\nfor (i = 0; i < num; i++) {\r\np = &msgs[i];\r\nfor (j = 0; j < p->len; j++) {\r\nif (p->flags & I2C_M_RD) {\r\nWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\r\nRADEON_I2C_NACK |\r\nRADEON_I2C_HALT |\r\nRADEON_I2C_SOFT_RST));\r\nWREG32(i2c_data, ((p->addr << 1) & 0xff) | 0x1);\r\nWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\r\n(1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\r\nRADEON_I2C_EN |\r\n(48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\r\nWREG32(i2c_cntl_0, reg | RADEON_I2C_RECEIVE);\r\nfor (k = 0; k < 32; k++) {\r\nudelay(10);\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c read error 0x%08x\n", tmp);\r\nWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\np->buf[j] = RREG32(i2c_data) & 0xff;\r\n} else {\r\nWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\r\nRADEON_I2C_NACK |\r\nRADEON_I2C_HALT |\r\nRADEON_I2C_SOFT_RST));\r\nWREG32(i2c_data, (p->addr << 1) & 0xff);\r\nWREG32(i2c_data, p->buf[j]);\r\nWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\r\n(1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\r\nRADEON_I2C_EN |\r\n(48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\r\nWREG32(i2c_cntl_0, reg);\r\nfor (k = 0; k < 32; k++) {\r\nudelay(10);\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(i2c_cntl_0);\r\nif (tmp & RADEON_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c write error 0x%08x\n", tmp);\r\nWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\n}\r\n}\r\n}\r\ndone:\r\nWREG32(i2c_cntl_0, 0);\r\nWREG32(i2c_cntl_1, 0);\r\nWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\r\nRADEON_I2C_NACK |\r\nRADEON_I2C_HALT |\r\nRADEON_I2C_SOFT_RST));\r\nif (rdev->is_atom_bios) {\r\ntmp = RREG32(RADEON_BIOS_6_SCRATCH);\r\ntmp &= ~ATOM_S6_HW_I2C_BUSY_STATE;\r\nWREG32(RADEON_BIOS_6_SCRATCH, tmp);\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\nmutex_unlock(&rdev->dc_hw_i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int r500_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nstruct i2c_msg *p;\r\nint i, j, remaining, current_count, buffer_offset, ret = num;\r\nu32 prescale;\r\nu32 tmp, reg;\r\nu32 saved1, saved2;\r\nmutex_lock(&rdev->dc_hw_i2c_mutex);\r\nmutex_lock(&rdev->pm.mutex);\r\nprescale = radeon_get_i2c_prescale(rdev);\r\ntmp = RREG32(rec->mask_clk_reg);\r\ntmp &= ~rec->mask_clk_mask;\r\nWREG32(rec->mask_clk_reg, tmp);\r\ntmp = RREG32(rec->mask_clk_reg);\r\ntmp = RREG32(rec->mask_data_reg);\r\ntmp &= ~rec->mask_data_mask;\r\nWREG32(rec->mask_data_reg, tmp);\r\ntmp = RREG32(rec->mask_data_reg);\r\ntmp = RREG32(rec->a_clk_reg);\r\ntmp &= ~rec->a_clk_mask;\r\nWREG32(rec->a_clk_reg, tmp);\r\ntmp = RREG32(rec->a_clk_reg);\r\ntmp = RREG32(rec->a_data_reg);\r\ntmp &= ~rec->a_data_mask;\r\nWREG32(rec->a_data_reg, tmp);\r\ntmp = RREG32(rec->a_data_reg);\r\ntmp = RREG32(rec->en_clk_reg);\r\ntmp &= ~rec->en_clk_mask;\r\nWREG32(rec->en_clk_reg, tmp);\r\ntmp = RREG32(rec->en_clk_reg);\r\ntmp = RREG32(rec->en_data_reg);\r\ntmp &= ~rec->en_data_mask;\r\nWREG32(rec->en_data_reg, tmp);\r\ntmp = RREG32(rec->en_data_reg);\r\ntmp = RREG32(RADEON_BIOS_6_SCRATCH);\r\nWREG32(RADEON_BIOS_6_SCRATCH, tmp | ATOM_S6_HW_I2C_BUSY_STATE);\r\nsaved1 = RREG32(AVIVO_DC_I2C_CONTROL1);\r\nsaved2 = RREG32(0x494);\r\nWREG32(0x494, saved2 | 0x1);\r\nWREG32(AVIVO_DC_I2C_ARBITRATION, AVIVO_DC_I2C_SW_WANTS_TO_USE_I2C);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(1);\r\nif (RREG32(AVIVO_DC_I2C_ARBITRATION) & AVIVO_DC_I2C_SW_CAN_USE_I2C)\r\nbreak;\r\n}\r\nif (i == 50) {\r\nDRM_ERROR("failed to get i2c bus\n");\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nreg = AVIVO_DC_I2C_START | AVIVO_DC_I2C_STOP | AVIVO_DC_I2C_EN;\r\nswitch (rec->mask_clk_reg) {\r\ncase AVIVO_DC_GPIO_DDC1_MASK:\r\nreg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC1);\r\nbreak;\r\ncase AVIVO_DC_GPIO_DDC2_MASK:\r\nreg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC2);\r\nbreak;\r\ncase AVIVO_DC_GPIO_DDC3_MASK:\r\nreg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC3);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("gpio not supported with hw i2c\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\np = &msgs[0];\r\nif ((num == 1) && (p->len == 0)) {\r\nWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\r\nAVIVO_DC_I2C_NACK |\r\nAVIVO_DC_I2C_HALT));\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\r\nudelay(1);\r\nWREG32(AVIVO_DC_I2C_RESET, 0);\r\nWREG32(AVIVO_DC_I2C_DATA, (p->addr << 1) & 0xff);\r\nWREG32(AVIVO_DC_I2C_DATA, 0);\r\nWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\r\nWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\r\nAVIVO_DC_I2C_DATA_COUNT(1) |\r\n(prescale << 16)));\r\nWREG32(AVIVO_DC_I2C_CONTROL1, reg);\r\nWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\r\nfor (j = 0; j < 200; j++) {\r\nudelay(50);\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c write error 0x%08x\n", tmp);\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\ngoto done;\r\n}\r\nfor (i = 0; i < num; i++) {\r\np = &msgs[i];\r\nremaining = p->len;\r\nbuffer_offset = 0;\r\nif (p->flags & I2C_M_RD) {\r\nwhile (remaining) {\r\nif (remaining > 15)\r\ncurrent_count = 15;\r\nelse\r\ncurrent_count = remaining;\r\nWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\r\nAVIVO_DC_I2C_NACK |\r\nAVIVO_DC_I2C_HALT));\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\r\nudelay(1);\r\nWREG32(AVIVO_DC_I2C_RESET, 0);\r\nWREG32(AVIVO_DC_I2C_DATA, ((p->addr << 1) & 0xff) | 0x1);\r\nWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\r\nWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\r\nAVIVO_DC_I2C_DATA_COUNT(current_count) |\r\n(prescale << 16)));\r\nWREG32(AVIVO_DC_I2C_CONTROL1, reg | AVIVO_DC_I2C_RECEIVE);\r\nWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\r\nfor (j = 0; j < 200; j++) {\r\nudelay(50);\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c read error 0x%08x\n", tmp);\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\nfor (j = 0; j < current_count; j++)\r\np->buf[buffer_offset + j] = RREG32(AVIVO_DC_I2C_DATA) & 0xff;\r\nremaining -= current_count;\r\nbuffer_offset += current_count;\r\n}\r\n} else {\r\nwhile (remaining) {\r\nif (remaining > 15)\r\ncurrent_count = 15;\r\nelse\r\ncurrent_count = remaining;\r\nWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\r\nAVIVO_DC_I2C_NACK |\r\nAVIVO_DC_I2C_HALT));\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\r\nudelay(1);\r\nWREG32(AVIVO_DC_I2C_RESET, 0);\r\nWREG32(AVIVO_DC_I2C_DATA, (p->addr << 1) & 0xff);\r\nfor (j = 0; j < current_count; j++)\r\nWREG32(AVIVO_DC_I2C_DATA, p->buf[buffer_offset + j]);\r\nWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\r\nWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\r\nAVIVO_DC_I2C_DATA_COUNT(current_count) |\r\n(prescale << 16)));\r\nWREG32(AVIVO_DC_I2C_CONTROL1, reg);\r\nWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\r\nfor (j = 0; j < 200; j++) {\r\nudelay(50);\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_GO)\r\ncontinue;\r\ntmp = RREG32(AVIVO_DC_I2C_STATUS1);\r\nif (tmp & AVIVO_DC_I2C_DONE)\r\nbreak;\r\nelse {\r\nDRM_DEBUG("i2c write error 0x%08x\n", tmp);\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\nremaining -= current_count;\r\nbuffer_offset += current_count;\r\n}\r\n}\r\n}\r\ndone:\r\nWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\r\nAVIVO_DC_I2C_NACK |\r\nAVIVO_DC_I2C_HALT));\r\nWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\r\nudelay(1);\r\nWREG32(AVIVO_DC_I2C_RESET, 0);\r\nWREG32(AVIVO_DC_I2C_ARBITRATION, AVIVO_DC_I2C_SW_DONE_USING_I2C);\r\nWREG32(AVIVO_DC_I2C_CONTROL1, saved1);\r\nWREG32(0x494, saved2);\r\ntmp = RREG32(RADEON_BIOS_6_SCRATCH);\r\ntmp &= ~ATOM_S6_HW_I2C_BUSY_STATE;\r\nWREG32(RADEON_BIOS_6_SCRATCH, tmp);\r\nmutex_unlock(&rdev->pm.mutex);\r\nmutex_unlock(&rdev->dc_hw_i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int radeon_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\r\nstruct radeon_device *rdev = i2c->dev->dev_private;\r\nstruct radeon_i2c_bus_rec *rec = &i2c->rec;\r\nint ret = 0;\r\nmutex_lock(&i2c->mutex);\r\nswitch (rdev->family) {\r\ncase CHIP_R100:\r\ncase CHIP_RV100:\r\ncase CHIP_RS100:\r\ncase CHIP_RV200:\r\ncase CHIP_RS200:\r\ncase CHIP_R200:\r\ncase CHIP_RV250:\r\ncase CHIP_RS300:\r\ncase CHIP_RV280:\r\ncase CHIP_R300:\r\ncase CHIP_R350:\r\ncase CHIP_RV350:\r\ncase CHIP_RV380:\r\ncase CHIP_R420:\r\ncase CHIP_R423:\r\ncase CHIP_RV410:\r\ncase CHIP_RS400:\r\ncase CHIP_RS480:\r\nret = r100_hw_i2c_xfer(i2c_adap, msgs, num);\r\nbreak;\r\ncase CHIP_RS600:\r\ncase CHIP_RS690:\r\ncase CHIP_RS740:\r\nbreak;\r\ncase CHIP_RV515:\r\ncase CHIP_R520:\r\ncase CHIP_RV530:\r\ncase CHIP_RV560:\r\ncase CHIP_RV570:\r\ncase CHIP_R580:\r\nif (rec->mm_i2c)\r\nret = r100_hw_i2c_xfer(i2c_adap, msgs, num);\r\nelse\r\nret = r500_hw_i2c_xfer(i2c_adap, msgs, num);\r\nbreak;\r\ncase CHIP_R600:\r\ncase CHIP_RV610:\r\ncase CHIP_RV630:\r\ncase CHIP_RV670:\r\nbreak;\r\ncase CHIP_RV620:\r\ncase CHIP_RV635:\r\ncase CHIP_RS780:\r\ncase CHIP_RS880:\r\ncase CHIP_RV770:\r\ncase CHIP_RV730:\r\ncase CHIP_RV710:\r\ncase CHIP_RV740:\r\nbreak;\r\ncase CHIP_CEDAR:\r\ncase CHIP_REDWOOD:\r\ncase CHIP_JUNIPER:\r\ncase CHIP_CYPRESS:\r\ncase CHIP_HEMLOCK:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("i2c: unhandled radeon chip\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\nmutex_unlock(&i2c->mutex);\r\nreturn ret;\r\n}\r\nstatic u32 radeon_hw_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstruct radeon_i2c_chan *radeon_i2c_create(struct drm_device *dev,\r\nstruct radeon_i2c_bus_rec *rec,\r\nconst char *name)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_i2c_chan *i2c;\r\nint ret;\r\nif (rec->mm_i2c && (radeon_hw_i2c == 0))\r\nreturn NULL;\r\ni2c = kzalloc(sizeof(struct radeon_i2c_chan), GFP_KERNEL);\r\nif (i2c == NULL)\r\nreturn NULL;\r\ni2c->rec = *rec;\r\ni2c->adapter.owner = THIS_MODULE;\r\ni2c->adapter.class = I2C_CLASS_DDC;\r\ni2c->adapter.dev.parent = &dev->pdev->dev;\r\ni2c->dev = dev;\r\ni2c_set_adapdata(&i2c->adapter, i2c);\r\nmutex_init(&i2c->mutex);\r\nif (rec->mm_i2c ||\r\n(rec->hw_capable &&\r\nradeon_hw_i2c &&\r\n((rdev->family <= CHIP_RS480) ||\r\n((rdev->family >= CHIP_RV515) && (rdev->family <= CHIP_R580))))) {\r\nsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\r\n"Radeon i2c hw bus %s", name);\r\ni2c->adapter.algo = &radeon_i2c_algo;\r\nret = i2c_add_adapter(&i2c->adapter);\r\nif (ret) {\r\nDRM_ERROR("Failed to register hw i2c %s\n", name);\r\ngoto out_free;\r\n}\r\n} else if (rec->hw_capable &&\r\nradeon_hw_i2c &&\r\nASIC_IS_DCE3(rdev)) {\r\nsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\r\n"Radeon i2c hw bus %s", name);\r\ni2c->adapter.algo = &radeon_atom_i2c_algo;\r\nret = i2c_add_adapter(&i2c->adapter);\r\nif (ret) {\r\nDRM_ERROR("Failed to register hw i2c %s\n", name);\r\ngoto out_free;\r\n}\r\n} else {\r\nsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\r\n"Radeon i2c bit bus %s", name);\r\ni2c->adapter.algo_data = &i2c->bit;\r\ni2c->bit.pre_xfer = pre_xfer;\r\ni2c->bit.post_xfer = post_xfer;\r\ni2c->bit.setsda = set_data;\r\ni2c->bit.setscl = set_clock;\r\ni2c->bit.getsda = get_data;\r\ni2c->bit.getscl = get_clock;\r\ni2c->bit.udelay = 10;\r\ni2c->bit.timeout = usecs_to_jiffies(2200);\r\ni2c->bit.data = i2c;\r\nret = i2c_bit_add_bus(&i2c->adapter);\r\nif (ret) {\r\nDRM_ERROR("Failed to register bit i2c %s\n", name);\r\ngoto out_free;\r\n}\r\n}\r\nreturn i2c;\r\nout_free:\r\nkfree(i2c);\r\nreturn NULL;\r\n}\r\nvoid radeon_i2c_destroy(struct radeon_i2c_chan *i2c)\r\n{\r\nif (!i2c)\r\nreturn;\r\ni2c_del_adapter(&i2c->adapter);\r\nif (i2c->has_aux)\r\ndrm_dp_aux_unregister(&i2c->aux);\r\nkfree(i2c);\r\n}\r\nvoid radeon_i2c_init(struct radeon_device *rdev)\r\n{\r\nif (radeon_hw_i2c)\r\nDRM_INFO("hw_i2c forced on, you may experience display detection problems!\n");\r\nif (rdev->is_atom_bios)\r\nradeon_atombios_i2c_init(rdev);\r\nelse\r\nradeon_combios_i2c_init(rdev);\r\n}\r\nvoid radeon_i2c_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\r\nif (rdev->i2c_bus[i]) {\r\nradeon_i2c_destroy(rdev->i2c_bus[i]);\r\nrdev->i2c_bus[i] = NULL;\r\n}\r\n}\r\n}\r\nvoid radeon_i2c_add(struct radeon_device *rdev,\r\nstruct radeon_i2c_bus_rec *rec,\r\nconst char *name)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nint i;\r\nfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\r\nif (!rdev->i2c_bus[i]) {\r\nrdev->i2c_bus[i] = radeon_i2c_create(dev, rec, name);\r\nreturn;\r\n}\r\n}\r\n}\r\nstruct radeon_i2c_chan *radeon_i2c_lookup(struct radeon_device *rdev,\r\nstruct radeon_i2c_bus_rec *i2c_bus)\r\n{\r\nint i;\r\nfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\r\nif (rdev->i2c_bus[i] &&\r\n(rdev->i2c_bus[i]->rec.i2c_id == i2c_bus->i2c_id)) {\r\nreturn rdev->i2c_bus[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct drm_encoder *radeon_best_encoder(struct drm_connector *connector)\r\n{\r\nreturn NULL;\r\n}\r\nvoid radeon_i2c_get_byte(struct radeon_i2c_chan *i2c_bus,\r\nu8 slave_addr,\r\nu8 addr,\r\nu8 *val)\r\n{\r\nu8 out_buf[2];\r\nu8 in_buf[2];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = out_buf,\r\n},\r\n{\r\n.addr = slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = in_buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = 0;\r\nif (i2c_transfer(&i2c_bus->adapter, msgs, 2) == 2) {\r\n*val = in_buf[0];\r\nDRM_DEBUG("val = 0x%02x\n", *val);\r\n} else {\r\nDRM_DEBUG("i2c 0x%02x 0x%02x read failed\n",\r\naddr, *val);\r\n}\r\n}\r\nvoid radeon_i2c_put_byte(struct radeon_i2c_chan *i2c_bus,\r\nu8 slave_addr,\r\nu8 addr,\r\nu8 val)\r\n{\r\nuint8_t out_buf[2];\r\nstruct i2c_msg msg = {\r\n.addr = slave_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = out_buf,\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = val;\r\nif (i2c_transfer(&i2c_bus->adapter, &msg, 1) != 1)\r\nDRM_DEBUG("i2c 0x%02x 0x%02x write failed\n",\r\naddr, val);\r\n}\r\nvoid radeon_router_select_ddc_port(struct radeon_connector *radeon_connector)\r\n{\r\nu8 val;\r\nif (!radeon_connector->router.ddc_valid)\r\nreturn;\r\nif (!radeon_connector->router_bus)\r\nreturn;\r\nradeon_i2c_get_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x3, &val);\r\nval &= ~radeon_connector->router.ddc_mux_control_pin;\r\nradeon_i2c_put_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x3, val);\r\nradeon_i2c_get_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x1, &val);\r\nval &= ~radeon_connector->router.ddc_mux_control_pin;\r\nval |= radeon_connector->router.ddc_mux_state;\r\nradeon_i2c_put_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x1, val);\r\n}\r\nvoid radeon_router_select_cd_port(struct radeon_connector *radeon_connector)\r\n{\r\nu8 val;\r\nif (!radeon_connector->router.cd_valid)\r\nreturn;\r\nif (!radeon_connector->router_bus)\r\nreturn;\r\nradeon_i2c_get_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x3, &val);\r\nval &= ~radeon_connector->router.cd_mux_control_pin;\r\nradeon_i2c_put_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x3, val);\r\nradeon_i2c_get_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x1, &val);\r\nval &= ~radeon_connector->router.cd_mux_control_pin;\r\nval |= radeon_connector->router.cd_mux_state;\r\nradeon_i2c_put_byte(radeon_connector->router_bus,\r\nradeon_connector->router.i2c_addr,\r\n0x1, val);\r\n}
