static struct max6697_data *max6697_update_device(struct device *dev)\r\n{\r\nstruct max6697_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nstruct max6697_data *ret = data;\r\nint val;\r\nint i;\r\nu32 alarms;\r\nmutex_lock(&data->update_lock);\r\nif (data->valid &&\r\n!time_after(jiffies, data->last_updated\r\n+ msecs_to_jiffies(data->update_interval)))\r\ngoto abort;\r\nfor (i = 0; i < data->chip->channels; i++) {\r\nif (data->chip->have_ext & (1 << i)) {\r\nval = i2c_smbus_read_byte_data(client,\r\nMAX6697_REG_TEMP_EXT[i]);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->temp[i][MAX6697_TEMP_EXT] = val;\r\n}\r\nval = i2c_smbus_read_byte_data(client, MAX6697_REG_TEMP[i]);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->temp[i][MAX6697_TEMP_INPUT] = val;\r\nval = i2c_smbus_read_byte_data(client, MAX6697_REG_MAX[i]);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->temp[i][MAX6697_TEMP_MAX] = val;\r\nif (data->chip->have_crit & (1 << i)) {\r\nval = i2c_smbus_read_byte_data(client,\r\nMAX6697_REG_CRIT[i]);\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->temp[i][MAX6697_TEMP_CRIT] = val;\r\n}\r\n}\r\nalarms = 0;\r\nfor (i = 0; i < 3; i++) {\r\nval = i2c_smbus_read_byte_data(client, MAX6697_REG_STAT(i));\r\nif (unlikely(val < 0)) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\nalarms = (alarms << 8) | val;\r\n}\r\ndata->alarms = alarms;\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_temp_input(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct max6697_data *data = max6697_update_device(dev);\r\nint temp;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ntemp = (data->temp[index][MAX6697_TEMP_INPUT] - data->temp_offset) << 3;\r\ntemp |= data->temp[index][MAX6697_TEMP_EXT] >> 5;\r\nreturn sprintf(buf, "%d\n", temp * 125);\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nint index = to_sensor_dev_attr_2(devattr)->index;\r\nstruct max6697_data *data = max6697_update_device(dev);\r\nint temp;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ntemp = data->temp[nr][index];\r\ntemp -= data->temp_offset;\r\nreturn sprintf(buf, "%d\n", temp * 1000);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint index = to_sensor_dev_attr(attr)->index;\r\nstruct max6697_data *data = max6697_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (data->chip->alarm_map)\r\nindex = data->chip->alarm_map[index];\r\nreturn sprintf(buf, "%u\n", (data->alarms >> index) & 0x1);\r\n}\r\nstatic ssize_t set_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nint index = to_sensor_dev_attr_2(devattr)->index;\r\nstruct max6697_data *data = dev_get_drvdata(dev);\r\nlong temp;\r\nint ret;\r\nret = kstrtol(buf, 10, &temp);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000) + data->temp_offset;\r\ntemp = clamp_val(temp, 0, data->type == max6581 ? 255 : 127);\r\ndata->temp[nr][index] = temp;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nindex == 2 ? MAX6697_REG_MAX[nr]\r\n: MAX6697_REG_CRIT[nr],\r\ntemp);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic umode_t max6697_is_visible(struct kobject *kobj, struct attribute *attr,\r\nint index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct max6697_data *data = dev_get_drvdata(dev);\r\nconst struct max6697_chip_data *chip = data->chip;\r\nint channel = index / 6;\r\nint nr = index % 6;\r\nif (channel >= chip->channels)\r\nreturn 0;\r\nif ((nr == 3 || nr == 4) && !(chip->have_crit & (1 << channel)))\r\nreturn 0;\r\nif (nr == 5 && !(chip->have_fault & (1 << channel)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic void max6697_get_config_of(struct device_node *node,\r\nstruct max6697_platform_data *pdata)\r\n{\r\nint len;\r\nconst __be32 *prop;\r\npdata->smbus_timeout_disable =\r\nof_property_read_bool(node, "smbus-timeout-disable");\r\npdata->extended_range_enable =\r\nof_property_read_bool(node, "extended-range-enable");\r\npdata->beta_compensation =\r\nof_property_read_bool(node, "beta-compensation-enable");\r\nprop = of_get_property(node, "alert-mask", &len);\r\nif (prop && len == sizeof(u32))\r\npdata->alert_mask = be32_to_cpu(prop[0]);\r\nprop = of_get_property(node, "over-temperature-mask", &len);\r\nif (prop && len == sizeof(u32))\r\npdata->over_temperature_mask = be32_to_cpu(prop[0]);\r\nprop = of_get_property(node, "resistance-cancellation", &len);\r\nif (prop) {\r\nif (len == sizeof(u32))\r\npdata->resistance_cancellation = be32_to_cpu(prop[0]);\r\nelse\r\npdata->resistance_cancellation = 0xfe;\r\n}\r\nprop = of_get_property(node, "transistor-ideality", &len);\r\nif (prop && len == 2 * sizeof(u32)) {\r\npdata->ideality_mask = be32_to_cpu(prop[0]);\r\npdata->ideality_value = be32_to_cpu(prop[1]);\r\n}\r\n}\r\nstatic int max6697_init_chip(struct max6697_data *data,\r\nstruct i2c_client *client)\r\n{\r\nstruct max6697_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct max6697_platform_data p;\r\nconst struct max6697_chip_data *chip = data->chip;\r\nint factor = chip->channels;\r\nint ret, reg;\r\nif (!pdata && !client->dev.of_node) {\r\nreg = i2c_smbus_read_byte_data(client, MAX6697_REG_CONFIG);\r\nif (reg < 0)\r\nreturn reg;\r\nif (data->type == max6581) {\r\nif (reg & MAX6581_CONF_EXTENDED)\r\ndata->temp_offset = 64;\r\nreg = i2c_smbus_read_byte_data(client,\r\nMAX6581_REG_RESISTANCE);\r\nif (reg < 0)\r\nreturn reg;\r\nfactor += hweight8(reg);\r\n} else {\r\nif (reg & MAX6697_CONF_RESISTANCE)\r\nfactor++;\r\n}\r\ngoto done;\r\n}\r\nif (client->dev.of_node) {\r\nmemset(&p, 0, sizeof(p));\r\nmax6697_get_config_of(client->dev.of_node, &p);\r\npdata = &p;\r\n}\r\nreg = 0;\r\nif (pdata->smbus_timeout_disable &&\r\n(chip->valid_conf & MAX6697_CONF_TIMEOUT)) {\r\nreg |= MAX6697_CONF_TIMEOUT;\r\n}\r\nif (pdata->extended_range_enable &&\r\n(chip->valid_conf & MAX6581_CONF_EXTENDED)) {\r\nreg |= MAX6581_CONF_EXTENDED;\r\ndata->temp_offset = 64;\r\n}\r\nif (pdata->resistance_cancellation &&\r\n(chip->valid_conf & MAX6697_CONF_RESISTANCE)) {\r\nreg |= MAX6697_CONF_RESISTANCE;\r\nfactor++;\r\n}\r\nif (pdata->beta_compensation &&\r\n(chip->valid_conf & MAX6693_CONF_BETA)) {\r\nreg |= MAX6693_CONF_BETA;\r\n}\r\nret = i2c_smbus_write_byte_data(client, MAX6697_REG_CONFIG, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, MAX6697_REG_ALERT_MASK,\r\nMAX6697_MAP_BITS(pdata->alert_mask));\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, MAX6697_REG_OVERT_MASK,\r\nMAX6697_MAP_BITS(pdata->over_temperature_mask));\r\nif (ret < 0)\r\nreturn ret;\r\nif (data->type == max6581) {\r\nfactor += hweight8(pdata->resistance_cancellation >> 1);\r\nret = i2c_smbus_write_byte_data(client, MAX6581_REG_RESISTANCE,\r\npdata->resistance_cancellation >> 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, MAX6581_REG_IDEALITY,\r\npdata->ideality_value);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client,\r\nMAX6581_REG_IDEALITY_SELECT,\r\npdata->ideality_mask >> 1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndone:\r\ndata->update_interval = factor * MAX6697_CONV_TIME;\r\nreturn 0;\r\n}\r\nstatic int max6697_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct device *dev = &client->dev;\r\nstruct max6697_data *data;\r\nstruct device *hwmon_dev;\r\nint err;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(struct max6697_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->type = id->driver_data;\r\ndata->chip = &max6697_chip_data[data->type];\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nerr = max6697_init_chip(data, client);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\nmax6697_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
