void do_fpsimd_acc(unsigned int esr, struct pt_regs *regs)\r\n{\r\nWARN_ON(1);\r\n}\r\nvoid do_fpsimd_exc(unsigned int esr, struct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\nunsigned int si_code = 0;\r\nif (esr & FPEXC_IOF)\r\nsi_code = FPE_FLTINV;\r\nelse if (esr & FPEXC_DZF)\r\nsi_code = FPE_FLTDIV;\r\nelse if (esr & FPEXC_OFF)\r\nsi_code = FPE_FLTOVF;\r\nelse if (esr & FPEXC_UFF)\r\nsi_code = FPE_FLTUND;\r\nelse if (esr & FPEXC_IXF)\r\nsi_code = FPE_FLTRES;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.si_signo = SIGFPE;\r\ninfo.si_code = si_code;\r\ninfo.si_addr = (void __user *)instruction_pointer(regs);\r\nsend_sig_info(SIGFPE, &info, current);\r\n}\r\nvoid fpsimd_thread_switch(struct task_struct *next)\r\n{\r\nif (current->mm && !test_thread_flag(TIF_FOREIGN_FPSTATE))\r\nfpsimd_save_state(&current->thread.fpsimd_state);\r\nif (next->mm) {\r\nstruct fpsimd_state *st = &next->thread.fpsimd_state;\r\nif (__this_cpu_read(fpsimd_last_state) == st\r\n&& st->cpu == smp_processor_id())\r\nclear_ti_thread_flag(task_thread_info(next),\r\nTIF_FOREIGN_FPSTATE);\r\nelse\r\nset_ti_thread_flag(task_thread_info(next),\r\nTIF_FOREIGN_FPSTATE);\r\n}\r\n}\r\nvoid fpsimd_flush_thread(void)\r\n{\r\nmemset(&current->thread.fpsimd_state, 0, sizeof(struct fpsimd_state));\r\nset_thread_flag(TIF_FOREIGN_FPSTATE);\r\n}\r\nvoid fpsimd_preserve_current_state(void)\r\n{\r\npreempt_disable();\r\nif (!test_thread_flag(TIF_FOREIGN_FPSTATE))\r\nfpsimd_save_state(&current->thread.fpsimd_state);\r\npreempt_enable();\r\n}\r\nvoid fpsimd_restore_current_state(void)\r\n{\r\npreempt_disable();\r\nif (test_and_clear_thread_flag(TIF_FOREIGN_FPSTATE)) {\r\nstruct fpsimd_state *st = &current->thread.fpsimd_state;\r\nfpsimd_load_state(st);\r\nthis_cpu_write(fpsimd_last_state, st);\r\nst->cpu = smp_processor_id();\r\n}\r\npreempt_enable();\r\n}\r\nvoid fpsimd_update_current_state(struct fpsimd_state *state)\r\n{\r\npreempt_disable();\r\nfpsimd_load_state(state);\r\nif (test_and_clear_thread_flag(TIF_FOREIGN_FPSTATE)) {\r\nstruct fpsimd_state *st = &current->thread.fpsimd_state;\r\nthis_cpu_write(fpsimd_last_state, st);\r\nst->cpu = smp_processor_id();\r\n}\r\npreempt_enable();\r\n}\r\nvoid fpsimd_flush_task_state(struct task_struct *t)\r\n{\r\nt->thread.fpsimd_state.cpu = NR_CPUS;\r\n}\r\nvoid kernel_neon_begin_partial(u32 num_regs)\r\n{\r\nif (in_interrupt()) {\r\nstruct fpsimd_partial_state *s = this_cpu_ptr(\r\nin_irq() ? &hardirq_fpsimdstate : &softirq_fpsimdstate);\r\nBUG_ON(num_regs > 32);\r\nfpsimd_save_partial_state(s, roundup(num_regs, 2));\r\n} else {\r\npreempt_disable();\r\nif (current->mm &&\r\n!test_and_set_thread_flag(TIF_FOREIGN_FPSTATE))\r\nfpsimd_save_state(&current->thread.fpsimd_state);\r\nthis_cpu_write(fpsimd_last_state, NULL);\r\n}\r\n}\r\nvoid kernel_neon_end(void)\r\n{\r\nif (in_interrupt()) {\r\nstruct fpsimd_partial_state *s = this_cpu_ptr(\r\nin_irq() ? &hardirq_fpsimdstate : &softirq_fpsimdstate);\r\nfpsimd_load_partial_state(s);\r\n} else {\r\npreempt_enable();\r\n}\r\n}\r\nstatic int fpsimd_cpu_pm_notifier(struct notifier_block *self,\r\nunsigned long cmd, void *v)\r\n{\r\nswitch (cmd) {\r\ncase CPU_PM_ENTER:\r\nif (current->mm && !test_thread_flag(TIF_FOREIGN_FPSTATE))\r\nfpsimd_save_state(&current->thread.fpsimd_state);\r\nthis_cpu_write(fpsimd_last_state, NULL);\r\nbreak;\r\ncase CPU_PM_EXIT:\r\nif (current->mm)\r\nset_thread_flag(TIF_FOREIGN_FPSTATE);\r\nbreak;\r\ncase CPU_PM_ENTER_FAILED:\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void fpsimd_pm_init(void)\r\n{\r\ncpu_pm_register_notifier(&fpsimd_cpu_pm_notifier_block);\r\n}\r\nstatic inline void fpsimd_pm_init(void) { }\r\nstatic int __init fpsimd_init(void)\r\n{\r\nu64 pfr = read_cpuid(ID_AA64PFR0_EL1);\r\nif (pfr & (0xf << 16)) {\r\npr_notice("Floating-point is not implemented\n");\r\nreturn 0;\r\n}\r\nelf_hwcap |= HWCAP_FP;\r\nif (pfr & (0xf << 20))\r\npr_notice("Advanced SIMD is not implemented\n");\r\nelse\r\nelf_hwcap |= HWCAP_ASIMD;\r\nfpsimd_pm_init();\r\nreturn 0;\r\n}
