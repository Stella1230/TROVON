static inline u32 bnx2_tx_avail(struct bnx2 *bp, struct bnx2_tx_ring_info *txr)\r\n{\r\nu32 diff;\r\nbarrier();\r\ndiff = txr->tx_prod - txr->tx_cons;\r\nif (unlikely(diff >= BNX2_TX_DESC_CNT)) {\r\ndiff &= 0xffff;\r\nif (diff == BNX2_TX_DESC_CNT)\r\ndiff = BNX2_MAX_TX_DESC_CNT;\r\n}\r\nreturn bp->tx_ring_size - diff;\r\n}\r\nstatic u32\r\nbnx2_reg_rd_ind(struct bnx2 *bp, u32 offset)\r\n{\r\nu32 val;\r\nspin_lock_bh(&bp->indirect_lock);\r\nBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);\r\nval = BNX2_RD(bp, BNX2_PCICFG_REG_WINDOW);\r\nspin_unlock_bh(&bp->indirect_lock);\r\nreturn val;\r\n}\r\nstatic void\r\nbnx2_reg_wr_ind(struct bnx2 *bp, u32 offset, u32 val)\r\n{\r\nspin_lock_bh(&bp->indirect_lock);\r\nBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);\r\nBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW, val);\r\nspin_unlock_bh(&bp->indirect_lock);\r\n}\r\nstatic void\r\nbnx2_shmem_wr(struct bnx2 *bp, u32 offset, u32 val)\r\n{\r\nbnx2_reg_wr_ind(bp, bp->shmem_base + offset, val);\r\n}\r\nstatic u32\r\nbnx2_shmem_rd(struct bnx2 *bp, u32 offset)\r\n{\r\nreturn bnx2_reg_rd_ind(bp, bp->shmem_base + offset);\r\n}\r\nstatic void\r\nbnx2_ctx_wr(struct bnx2 *bp, u32 cid_addr, u32 offset, u32 val)\r\n{\r\noffset += cid_addr;\r\nspin_lock_bh(&bp->indirect_lock);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nint i;\r\nBNX2_WR(bp, BNX2_CTX_CTX_DATA, val);\r\nBNX2_WR(bp, BNX2_CTX_CTX_CTRL,\r\noffset | BNX2_CTX_CTX_CTRL_WRITE_REQ);\r\nfor (i = 0; i < 5; i++) {\r\nval = BNX2_RD(bp, BNX2_CTX_CTX_CTRL);\r\nif ((val & BNX2_CTX_CTX_CTRL_WRITE_REQ) == 0)\r\nbreak;\r\nudelay(5);\r\n}\r\n} else {\r\nBNX2_WR(bp, BNX2_CTX_DATA_ADR, offset);\r\nBNX2_WR(bp, BNX2_CTX_DATA, val);\r\n}\r\nspin_unlock_bh(&bp->indirect_lock);\r\n}\r\nstatic int\r\nbnx2_drv_ctl(struct net_device *dev, struct drv_ctl_info *info)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstruct drv_ctl_io *io = &info->data.io;\r\nswitch (info->cmd) {\r\ncase DRV_CTL_IO_WR_CMD:\r\nbnx2_reg_wr_ind(bp, io->offset, io->data);\r\nbreak;\r\ncase DRV_CTL_IO_RD_CMD:\r\nio->data = bnx2_reg_rd_ind(bp, io->offset);\r\nbreak;\r\ncase DRV_CTL_CTX_WR_CMD:\r\nbnx2_ctx_wr(bp, io->cid_addr, io->offset, io->data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2_setup_cnic_irq_info(struct bnx2 *bp)\r\n{\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\r\nint sb_id;\r\nif (bp->flags & BNX2_FLAG_USING_MSIX) {\r\ncp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\r\nbnapi->cnic_present = 0;\r\nsb_id = bp->irq_nvecs;\r\ncp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\r\n} else {\r\ncp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\r\nbnapi->cnic_tag = bnapi->last_status_idx;\r\nbnapi->cnic_present = 1;\r\nsb_id = 0;\r\ncp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\r\n}\r\ncp->irq_arr[0].vector = bp->irq_tbl[sb_id].vector;\r\ncp->irq_arr[0].status_blk = (void *)\r\n((unsigned long) bnapi->status_blk.msi +\r\n(BNX2_SBLK_MSIX_ALIGN_SIZE * sb_id));\r\ncp->irq_arr[0].status_blk_num = sb_id;\r\ncp->num_irq = 1;\r\n}\r\nstatic int bnx2_register_cnic(struct net_device *dev, struct cnic_ops *ops,\r\nvoid *data)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nif (ops == NULL)\r\nreturn -EINVAL;\r\nif (cp->drv_state & CNIC_DRV_STATE_REGD)\r\nreturn -EBUSY;\r\nif (!bnx2_reg_rd_ind(bp, BNX2_FW_MAX_ISCSI_CONN))\r\nreturn -ENODEV;\r\nbp->cnic_data = data;\r\nrcu_assign_pointer(bp->cnic_ops, ops);\r\ncp->num_irq = 0;\r\ncp->drv_state = CNIC_DRV_STATE_REGD;\r\nbnx2_setup_cnic_irq_info(bp);\r\nreturn 0;\r\n}\r\nstatic int bnx2_unregister_cnic(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nmutex_lock(&bp->cnic_lock);\r\ncp->drv_state = 0;\r\nbnapi->cnic_present = 0;\r\nRCU_INIT_POINTER(bp->cnic_ops, NULL);\r\nmutex_unlock(&bp->cnic_lock);\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic struct cnic_eth_dev *bnx2_cnic_probe(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nif (!cp->max_iscsi_conn)\r\nreturn NULL;\r\ncp->drv_owner = THIS_MODULE;\r\ncp->chip_id = bp->chip_id;\r\ncp->pdev = bp->pdev;\r\ncp->io_base = bp->regview;\r\ncp->drv_ctl = bnx2_drv_ctl;\r\ncp->drv_register_cnic = bnx2_register_cnic;\r\ncp->drv_unregister_cnic = bnx2_unregister_cnic;\r\nreturn cp;\r\n}\r\nstatic void\r\nbnx2_cnic_stop(struct bnx2 *bp)\r\n{\r\nstruct cnic_ops *c_ops;\r\nstruct cnic_ctl_info info;\r\nmutex_lock(&bp->cnic_lock);\r\nc_ops = rcu_dereference_protected(bp->cnic_ops,\r\nlockdep_is_held(&bp->cnic_lock));\r\nif (c_ops) {\r\ninfo.cmd = CNIC_CTL_STOP_CMD;\r\nc_ops->cnic_ctl(bp->cnic_data, &info);\r\n}\r\nmutex_unlock(&bp->cnic_lock);\r\n}\r\nstatic void\r\nbnx2_cnic_start(struct bnx2 *bp)\r\n{\r\nstruct cnic_ops *c_ops;\r\nstruct cnic_ctl_info info;\r\nmutex_lock(&bp->cnic_lock);\r\nc_ops = rcu_dereference_protected(bp->cnic_ops,\r\nlockdep_is_held(&bp->cnic_lock));\r\nif (c_ops) {\r\nif (!(bp->flags & BNX2_FLAG_USING_MSIX)) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\r\nbnapi->cnic_tag = bnapi->last_status_idx;\r\n}\r\ninfo.cmd = CNIC_CTL_START_CMD;\r\nc_ops->cnic_ctl(bp->cnic_data, &info);\r\n}\r\nmutex_unlock(&bp->cnic_lock);\r\n}\r\nstatic void\r\nbnx2_cnic_stop(struct bnx2 *bp)\r\n{\r\n}\r\nstatic void\r\nbnx2_cnic_start(struct bnx2 *bp)\r\n{\r\n}\r\nstatic int\r\nbnx2_read_phy(struct bnx2 *bp, u32 reg, u32 *val)\r\n{\r\nu32 val1;\r\nint i, ret;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nval1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\r\nBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nudelay(40);\r\n}\r\nval1 = (bp->phy_addr << 21) | (reg << 16) |\r\nBNX2_EMAC_MDIO_COMM_COMMAND_READ | BNX2_EMAC_MDIO_COMM_DISEXT |\r\nBNX2_EMAC_MDIO_COMM_START_BUSY;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_COMM, val1);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\r\nif (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\r\nval1 &= BNX2_EMAC_MDIO_COMM_DATA;\r\nbreak;\r\n}\r\n}\r\nif (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY) {\r\n*val = 0x0;\r\nret = -EBUSY;\r\n}\r\nelse {\r\n*val = val1;\r\nret = 0;\r\n}\r\nif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nval1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\r\nBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nudelay(40);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbnx2_write_phy(struct bnx2 *bp, u32 reg, u32 val)\r\n{\r\nu32 val1;\r\nint i, ret;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nval1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\r\nBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nudelay(40);\r\n}\r\nval1 = (bp->phy_addr << 21) | (reg << 16) | val |\r\nBNX2_EMAC_MDIO_COMM_COMMAND_WRITE |\r\nBNX2_EMAC_MDIO_COMM_START_BUSY | BNX2_EMAC_MDIO_COMM_DISEXT;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_COMM, val1);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\r\nif (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)\r\nret = -EBUSY;\r\nelse\r\nret = 0;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\r\nval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nval1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;\r\nBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\r\nBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\r\nudelay(40);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nbnx2_disable_int(struct bnx2 *bp)\r\n{\r\nint i;\r\nstruct bnx2_napi *bnapi;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nbnapi = &bp->bnx2_napi[i];\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\r\n}\r\nBNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD);\r\n}\r\nstatic void\r\nbnx2_enable_int(struct bnx2 *bp)\r\n{\r\nint i;\r\nstruct bnx2_napi *bnapi;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nbnapi = &bp->bnx2_napi[i];\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT |\r\nbnapi->last_status_idx);\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nbnapi->last_status_idx);\r\n}\r\nBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);\r\n}\r\nstatic void\r\nbnx2_disable_int_sync(struct bnx2 *bp)\r\n{\r\nint i;\r\natomic_inc(&bp->intr_sem);\r\nif (!netif_running(bp->dev))\r\nreturn;\r\nbnx2_disable_int(bp);\r\nfor (i = 0; i < bp->irq_nvecs; i++)\r\nsynchronize_irq(bp->irq_tbl[i].vector);\r\n}\r\nstatic void\r\nbnx2_napi_disable(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++)\r\nnapi_disable(&bp->bnx2_napi[i].napi);\r\n}\r\nstatic void\r\nbnx2_napi_enable(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++)\r\nnapi_enable(&bp->bnx2_napi[i].napi);\r\n}\r\nstatic void\r\nbnx2_netif_stop(struct bnx2 *bp, bool stop_cnic)\r\n{\r\nif (stop_cnic)\r\nbnx2_cnic_stop(bp);\r\nif (netif_running(bp->dev)) {\r\nbnx2_napi_disable(bp);\r\nnetif_tx_disable(bp->dev);\r\n}\r\nbnx2_disable_int_sync(bp);\r\nnetif_carrier_off(bp->dev);\r\n}\r\nstatic void\r\nbnx2_netif_start(struct bnx2 *bp, bool start_cnic)\r\n{\r\nif (atomic_dec_and_test(&bp->intr_sem)) {\r\nif (netif_running(bp->dev)) {\r\nnetif_tx_wake_all_queues(bp->dev);\r\nspin_lock_bh(&bp->phy_lock);\r\nif (bp->link_up)\r\nnetif_carrier_on(bp->dev);\r\nspin_unlock_bh(&bp->phy_lock);\r\nbnx2_napi_enable(bp);\r\nbnx2_enable_int(bp);\r\nif (start_cnic)\r\nbnx2_cnic_start(bp);\r\n}\r\n}\r\n}\r\nstatic void\r\nbnx2_free_tx_mem(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_tx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nif (txr->tx_desc_ring) {\r\ndma_free_coherent(&bp->pdev->dev, TXBD_RING_SIZE,\r\ntxr->tx_desc_ring,\r\ntxr->tx_desc_mapping);\r\ntxr->tx_desc_ring = NULL;\r\n}\r\nkfree(txr->tx_buf_ring);\r\ntxr->tx_buf_ring = NULL;\r\n}\r\n}\r\nstatic void\r\nbnx2_free_rx_mem(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_rx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nint j;\r\nfor (j = 0; j < bp->rx_max_ring; j++) {\r\nif (rxr->rx_desc_ring[j])\r\ndma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,\r\nrxr->rx_desc_ring[j],\r\nrxr->rx_desc_mapping[j]);\r\nrxr->rx_desc_ring[j] = NULL;\r\n}\r\nvfree(rxr->rx_buf_ring);\r\nrxr->rx_buf_ring = NULL;\r\nfor (j = 0; j < bp->rx_max_pg_ring; j++) {\r\nif (rxr->rx_pg_desc_ring[j])\r\ndma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,\r\nrxr->rx_pg_desc_ring[j],\r\nrxr->rx_pg_desc_mapping[j]);\r\nrxr->rx_pg_desc_ring[j] = NULL;\r\n}\r\nvfree(rxr->rx_pg_ring);\r\nrxr->rx_pg_ring = NULL;\r\n}\r\n}\r\nstatic int\r\nbnx2_alloc_tx_mem(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_tx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\ntxr->tx_buf_ring = kzalloc(SW_TXBD_RING_SIZE, GFP_KERNEL);\r\nif (txr->tx_buf_ring == NULL)\r\nreturn -ENOMEM;\r\ntxr->tx_desc_ring =\r\ndma_alloc_coherent(&bp->pdev->dev, TXBD_RING_SIZE,\r\n&txr->tx_desc_mapping, GFP_KERNEL);\r\nif (txr->tx_desc_ring == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_alloc_rx_mem(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_rx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nint j;\r\nrxr->rx_buf_ring =\r\nvzalloc(SW_RXBD_RING_SIZE * bp->rx_max_ring);\r\nif (rxr->rx_buf_ring == NULL)\r\nreturn -ENOMEM;\r\nfor (j = 0; j < bp->rx_max_ring; j++) {\r\nrxr->rx_desc_ring[j] =\r\ndma_alloc_coherent(&bp->pdev->dev,\r\nRXBD_RING_SIZE,\r\n&rxr->rx_desc_mapping[j],\r\nGFP_KERNEL);\r\nif (rxr->rx_desc_ring[j] == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (bp->rx_pg_ring_size) {\r\nrxr->rx_pg_ring = vzalloc(SW_RXPG_RING_SIZE *\r\nbp->rx_max_pg_ring);\r\nif (rxr->rx_pg_ring == NULL)\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < bp->rx_max_pg_ring; j++) {\r\nrxr->rx_pg_desc_ring[j] =\r\ndma_alloc_coherent(&bp->pdev->dev,\r\nRXBD_RING_SIZE,\r\n&rxr->rx_pg_desc_mapping[j],\r\nGFP_KERNEL);\r\nif (rxr->rx_pg_desc_ring[j] == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_free_mem(struct bnx2 *bp)\r\n{\r\nint i;\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\r\nbnx2_free_tx_mem(bp);\r\nbnx2_free_rx_mem(bp);\r\nfor (i = 0; i < bp->ctx_pages; i++) {\r\nif (bp->ctx_blk[i]) {\r\ndma_free_coherent(&bp->pdev->dev, BNX2_PAGE_SIZE,\r\nbp->ctx_blk[i],\r\nbp->ctx_blk_mapping[i]);\r\nbp->ctx_blk[i] = NULL;\r\n}\r\n}\r\nif (bnapi->status_blk.msi) {\r\ndma_free_coherent(&bp->pdev->dev, bp->status_stats_size,\r\nbnapi->status_blk.msi,\r\nbp->status_blk_mapping);\r\nbnapi->status_blk.msi = NULL;\r\nbp->stats_blk = NULL;\r\n}\r\n}\r\nstatic int\r\nbnx2_alloc_mem(struct bnx2 *bp)\r\n{\r\nint i, status_blk_size, err;\r\nstruct bnx2_napi *bnapi;\r\nvoid *status_blk;\r\nstatus_blk_size = L1_CACHE_ALIGN(sizeof(struct status_block));\r\nif (bp->flags & BNX2_FLAG_MSIX_CAP)\r\nstatus_blk_size = L1_CACHE_ALIGN(BNX2_MAX_MSIX_HW_VEC *\r\nBNX2_SBLK_MSIX_ALIGN_SIZE);\r\nbp->status_stats_size = status_blk_size +\r\nsizeof(struct statistics_block);\r\nstatus_blk = dma_zalloc_coherent(&bp->pdev->dev, bp->status_stats_size,\r\n&bp->status_blk_mapping, GFP_KERNEL);\r\nif (status_blk == NULL)\r\ngoto alloc_mem_err;\r\nbnapi = &bp->bnx2_napi[0];\r\nbnapi->status_blk.msi = status_blk;\r\nbnapi->hw_tx_cons_ptr =\r\n&bnapi->status_blk.msi->status_tx_quick_consumer_index0;\r\nbnapi->hw_rx_cons_ptr =\r\n&bnapi->status_blk.msi->status_rx_quick_consumer_index0;\r\nif (bp->flags & BNX2_FLAG_MSIX_CAP) {\r\nfor (i = 1; i < bp->irq_nvecs; i++) {\r\nstruct status_block_msix *sblk;\r\nbnapi = &bp->bnx2_napi[i];\r\nsblk = (status_blk + BNX2_SBLK_MSIX_ALIGN_SIZE * i);\r\nbnapi->status_blk.msix = sblk;\r\nbnapi->hw_tx_cons_ptr =\r\n&sblk->status_tx_quick_consumer_index;\r\nbnapi->hw_rx_cons_ptr =\r\n&sblk->status_rx_quick_consumer_index;\r\nbnapi->int_num = i << 24;\r\n}\r\n}\r\nbp->stats_blk = status_blk + status_blk_size;\r\nbp->stats_blk_mapping = bp->status_blk_mapping + status_blk_size;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nbp->ctx_pages = 0x2000 / BNX2_PAGE_SIZE;\r\nif (bp->ctx_pages == 0)\r\nbp->ctx_pages = 1;\r\nfor (i = 0; i < bp->ctx_pages; i++) {\r\nbp->ctx_blk[i] = dma_alloc_coherent(&bp->pdev->dev,\r\nBNX2_PAGE_SIZE,\r\n&bp->ctx_blk_mapping[i],\r\nGFP_KERNEL);\r\nif (bp->ctx_blk[i] == NULL)\r\ngoto alloc_mem_err;\r\n}\r\n}\r\nerr = bnx2_alloc_rx_mem(bp);\r\nif (err)\r\ngoto alloc_mem_err;\r\nerr = bnx2_alloc_tx_mem(bp);\r\nif (err)\r\ngoto alloc_mem_err;\r\nreturn 0;\r\nalloc_mem_err:\r\nbnx2_free_mem(bp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nbnx2_report_fw_link(struct bnx2 *bp)\r\n{\r\nu32 fw_link_status = 0;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn;\r\nif (bp->link_up) {\r\nu32 bmsr;\r\nswitch (bp->line_speed) {\r\ncase SPEED_10:\r\nif (bp->duplex == DUPLEX_HALF)\r\nfw_link_status = BNX2_LINK_STATUS_10HALF;\r\nelse\r\nfw_link_status = BNX2_LINK_STATUS_10FULL;\r\nbreak;\r\ncase SPEED_100:\r\nif (bp->duplex == DUPLEX_HALF)\r\nfw_link_status = BNX2_LINK_STATUS_100HALF;\r\nelse\r\nfw_link_status = BNX2_LINK_STATUS_100FULL;\r\nbreak;\r\ncase SPEED_1000:\r\nif (bp->duplex == DUPLEX_HALF)\r\nfw_link_status = BNX2_LINK_STATUS_1000HALF;\r\nelse\r\nfw_link_status = BNX2_LINK_STATUS_1000FULL;\r\nbreak;\r\ncase SPEED_2500:\r\nif (bp->duplex == DUPLEX_HALF)\r\nfw_link_status = BNX2_LINK_STATUS_2500HALF;\r\nelse\r\nfw_link_status = BNX2_LINK_STATUS_2500FULL;\r\nbreak;\r\n}\r\nfw_link_status |= BNX2_LINK_STATUS_LINK_UP;\r\nif (bp->autoneg) {\r\nfw_link_status |= BNX2_LINK_STATUS_AN_ENABLED;\r\nbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\r\nbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\r\nif (!(bmsr & BMSR_ANEGCOMPLETE) ||\r\nbp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)\r\nfw_link_status |= BNX2_LINK_STATUS_PARALLEL_DET;\r\nelse\r\nfw_link_status |= BNX2_LINK_STATUS_AN_COMPLETE;\r\n}\r\n}\r\nelse\r\nfw_link_status = BNX2_LINK_STATUS_LINK_DOWN;\r\nbnx2_shmem_wr(bp, BNX2_LINK_STATUS, fw_link_status);\r\n}\r\nstatic char *\r\nbnx2_xceiver_str(struct bnx2 *bp)\r\n{\r\nreturn (bp->phy_port == PORT_FIBRE) ? "SerDes" :\r\n((bp->phy_flags & BNX2_PHY_FLAG_SERDES) ? "Remote Copper" :\r\n"Copper");\r\n}\r\nstatic void\r\nbnx2_report_link(struct bnx2 *bp)\r\n{\r\nif (bp->link_up) {\r\nnetif_carrier_on(bp->dev);\r\nnetdev_info(bp->dev, "NIC %s Link is Up, %d Mbps %s duplex",\r\nbnx2_xceiver_str(bp),\r\nbp->line_speed,\r\nbp->duplex == DUPLEX_FULL ? "full" : "half");\r\nif (bp->flow_ctrl) {\r\nif (bp->flow_ctrl & FLOW_CTRL_RX) {\r\npr_cont(", receive ");\r\nif (bp->flow_ctrl & FLOW_CTRL_TX)\r\npr_cont("& transmit ");\r\n}\r\nelse {\r\npr_cont(", transmit ");\r\n}\r\npr_cont("flow control ON");\r\n}\r\npr_cont("\n");\r\n} else {\r\nnetif_carrier_off(bp->dev);\r\nnetdev_err(bp->dev, "NIC %s Link is Down\n",\r\nbnx2_xceiver_str(bp));\r\n}\r\nbnx2_report_fw_link(bp);\r\n}\r\nstatic void\r\nbnx2_resolve_flow_ctrl(struct bnx2 *bp)\r\n{\r\nu32 local_adv, remote_adv;\r\nbp->flow_ctrl = 0;\r\nif ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=\r\n(AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {\r\nif (bp->duplex == DUPLEX_FULL) {\r\nbp->flow_ctrl = bp->req_flow_ctrl;\r\n}\r\nreturn;\r\n}\r\nif (bp->duplex != DUPLEX_FULL) {\r\nreturn;\r\n}\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(BNX2_CHIP(bp) == BNX2_CHIP_5708)) {\r\nu32 val;\r\nbnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);\r\nif (val & BCM5708S_1000X_STAT1_TX_PAUSE)\r\nbp->flow_ctrl |= FLOW_CTRL_TX;\r\nif (val & BCM5708S_1000X_STAT1_RX_PAUSE)\r\nbp->flow_ctrl |= FLOW_CTRL_RX;\r\nreturn;\r\n}\r\nbnx2_read_phy(bp, bp->mii_adv, &local_adv);\r\nbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nu32 new_local_adv = 0;\r\nu32 new_remote_adv = 0;\r\nif (local_adv & ADVERTISE_1000XPAUSE)\r\nnew_local_adv |= ADVERTISE_PAUSE_CAP;\r\nif (local_adv & ADVERTISE_1000XPSE_ASYM)\r\nnew_local_adv |= ADVERTISE_PAUSE_ASYM;\r\nif (remote_adv & ADVERTISE_1000XPAUSE)\r\nnew_remote_adv |= ADVERTISE_PAUSE_CAP;\r\nif (remote_adv & ADVERTISE_1000XPSE_ASYM)\r\nnew_remote_adv |= ADVERTISE_PAUSE_ASYM;\r\nlocal_adv = new_local_adv;\r\nremote_adv = new_remote_adv;\r\n}\r\nif (local_adv & ADVERTISE_PAUSE_CAP) {\r\nif(local_adv & ADVERTISE_PAUSE_ASYM) {\r\nif (remote_adv & ADVERTISE_PAUSE_CAP) {\r\nbp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\r\n}\r\nelse if (remote_adv & ADVERTISE_PAUSE_ASYM) {\r\nbp->flow_ctrl = FLOW_CTRL_RX;\r\n}\r\n}\r\nelse {\r\nif (remote_adv & ADVERTISE_PAUSE_CAP) {\r\nbp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\r\n}\r\n}\r\n}\r\nelse if (local_adv & ADVERTISE_PAUSE_ASYM) {\r\nif ((remote_adv & ADVERTISE_PAUSE_CAP) &&\r\n(remote_adv & ADVERTISE_PAUSE_ASYM)) {\r\nbp->flow_ctrl = FLOW_CTRL_TX;\r\n}\r\n}\r\n}\r\nstatic int\r\nbnx2_5709s_linkup(struct bnx2 *bp)\r\n{\r\nu32 val, speed;\r\nbp->link_up = 1;\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_GP_STATUS);\r\nbnx2_read_phy(bp, MII_BNX2_GP_TOP_AN_STATUS1, &val);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nif ((bp->autoneg & AUTONEG_SPEED) == 0) {\r\nbp->line_speed = bp->req_line_speed;\r\nbp->duplex = bp->req_duplex;\r\nreturn 0;\r\n}\r\nspeed = val & MII_BNX2_GP_TOP_AN_SPEED_MSK;\r\nswitch (speed) {\r\ncase MII_BNX2_GP_TOP_AN_SPEED_10:\r\nbp->line_speed = SPEED_10;\r\nbreak;\r\ncase MII_BNX2_GP_TOP_AN_SPEED_100:\r\nbp->line_speed = SPEED_100;\r\nbreak;\r\ncase MII_BNX2_GP_TOP_AN_SPEED_1G:\r\ncase MII_BNX2_GP_TOP_AN_SPEED_1GKV:\r\nbp->line_speed = SPEED_1000;\r\nbreak;\r\ncase MII_BNX2_GP_TOP_AN_SPEED_2_5G:\r\nbp->line_speed = SPEED_2500;\r\nbreak;\r\n}\r\nif (val & MII_BNX2_GP_TOP_AN_FD)\r\nbp->duplex = DUPLEX_FULL;\r\nelse\r\nbp->duplex = DUPLEX_HALF;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_5708s_linkup(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nbp->link_up = 1;\r\nbnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);\r\nswitch (val & BCM5708S_1000X_STAT1_SPEED_MASK) {\r\ncase BCM5708S_1000X_STAT1_SPEED_10:\r\nbp->line_speed = SPEED_10;\r\nbreak;\r\ncase BCM5708S_1000X_STAT1_SPEED_100:\r\nbp->line_speed = SPEED_100;\r\nbreak;\r\ncase BCM5708S_1000X_STAT1_SPEED_1G:\r\nbp->line_speed = SPEED_1000;\r\nbreak;\r\ncase BCM5708S_1000X_STAT1_SPEED_2G5:\r\nbp->line_speed = SPEED_2500;\r\nbreak;\r\n}\r\nif (val & BCM5708S_1000X_STAT1_FD)\r\nbp->duplex = DUPLEX_FULL;\r\nelse\r\nbp->duplex = DUPLEX_HALF;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_5706s_linkup(struct bnx2 *bp)\r\n{\r\nu32 bmcr, local_adv, remote_adv, common;\r\nbp->link_up = 1;\r\nbp->line_speed = SPEED_1000;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (bmcr & BMCR_FULLDPLX) {\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse {\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\nif (!(bmcr & BMCR_ANENABLE)) {\r\nreturn 0;\r\n}\r\nbnx2_read_phy(bp, bp->mii_adv, &local_adv);\r\nbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\r\ncommon = local_adv & remote_adv;\r\nif (common & (ADVERTISE_1000XHALF | ADVERTISE_1000XFULL)) {\r\nif (common & ADVERTISE_1000XFULL) {\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse {\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_copper_linkup(struct bnx2 *bp)\r\n{\r\nu32 bmcr;\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_MDIX;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (bmcr & BMCR_ANENABLE) {\r\nu32 local_adv, remote_adv, common;\r\nbnx2_read_phy(bp, MII_CTRL1000, &local_adv);\r\nbnx2_read_phy(bp, MII_STAT1000, &remote_adv);\r\ncommon = local_adv & (remote_adv >> 2);\r\nif (common & ADVERTISE_1000FULL) {\r\nbp->line_speed = SPEED_1000;\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse if (common & ADVERTISE_1000HALF) {\r\nbp->line_speed = SPEED_1000;\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\nelse {\r\nbnx2_read_phy(bp, bp->mii_adv, &local_adv);\r\nbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\r\ncommon = local_adv & remote_adv;\r\nif (common & ADVERTISE_100FULL) {\r\nbp->line_speed = SPEED_100;\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse if (common & ADVERTISE_100HALF) {\r\nbp->line_speed = SPEED_100;\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\nelse if (common & ADVERTISE_10FULL) {\r\nbp->line_speed = SPEED_10;\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse if (common & ADVERTISE_10HALF) {\r\nbp->line_speed = SPEED_10;\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\nelse {\r\nbp->line_speed = 0;\r\nbp->link_up = 0;\r\n}\r\n}\r\n}\r\nelse {\r\nif (bmcr & BMCR_SPEED100) {\r\nbp->line_speed = SPEED_100;\r\n}\r\nelse {\r\nbp->line_speed = SPEED_10;\r\n}\r\nif (bmcr & BMCR_FULLDPLX) {\r\nbp->duplex = DUPLEX_FULL;\r\n}\r\nelse {\r\nbp->duplex = DUPLEX_HALF;\r\n}\r\n}\r\nif (bp->link_up) {\r\nu32 ext_status;\r\nbnx2_read_phy(bp, MII_BNX2_EXT_STATUS, &ext_status);\r\nif (ext_status & EXT_STATUS_MDIX)\r\nbp->phy_flags |= BNX2_PHY_FLAG_MDIX;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_init_rx_context(struct bnx2 *bp, u32 cid)\r\n{\r\nu32 val, rx_cid_addr = GET_CID_ADDR(cid);\r\nval = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE;\r\nval |= BNX2_L2CTX_CTX_TYPE_SIZE_L2;\r\nval |= 0x02 << 8;\r\nif (bp->flow_ctrl & FLOW_CTRL_TX)\r\nval |= BNX2_L2CTX_FLOW_CTRL_ENABLE;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_CTX_TYPE, val);\r\n}\r\nstatic void\r\nbnx2_init_all_rx_contexts(struct bnx2 *bp)\r\n{\r\nint i;\r\nu32 cid;\r\nfor (i = 0, cid = RX_CID; i < bp->num_rx_rings; i++, cid++) {\r\nif (i == 1)\r\ncid = RX_RSS_CID;\r\nbnx2_init_rx_context(bp, cid);\r\n}\r\n}\r\nstatic void\r\nbnx2_set_mac_link(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nBNX2_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x2620);\r\nif (bp->link_up && (bp->line_speed == SPEED_1000) &&\r\n(bp->duplex == DUPLEX_HALF)) {\r\nBNX2_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x26ff);\r\n}\r\nval = BNX2_RD(bp, BNX2_EMAC_MODE);\r\nval &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |\r\nBNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |\r\nBNX2_EMAC_MODE_25G_MODE);\r\nif (bp->link_up) {\r\nswitch (bp->line_speed) {\r\ncase SPEED_10:\r\nif (BNX2_CHIP(bp) != BNX2_CHIP_5706) {\r\nval |= BNX2_EMAC_MODE_PORT_MII_10M;\r\nbreak;\r\n}\r\ncase SPEED_100:\r\nval |= BNX2_EMAC_MODE_PORT_MII;\r\nbreak;\r\ncase SPEED_2500:\r\nval |= BNX2_EMAC_MODE_25G_MODE;\r\ncase SPEED_1000:\r\nval |= BNX2_EMAC_MODE_PORT_GMII;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nval |= BNX2_EMAC_MODE_PORT_GMII;\r\n}\r\nif (bp->duplex == DUPLEX_HALF)\r\nval |= BNX2_EMAC_MODE_HALF_DUPLEX;\r\nBNX2_WR(bp, BNX2_EMAC_MODE, val);\r\nbp->rx_mode &= ~BNX2_EMAC_RX_MODE_FLOW_EN;\r\nif (bp->flow_ctrl & FLOW_CTRL_RX)\r\nbp->rx_mode |= BNX2_EMAC_RX_MODE_FLOW_EN;\r\nBNX2_WR(bp, BNX2_EMAC_RX_MODE, bp->rx_mode);\r\nval = BNX2_RD(bp, BNX2_EMAC_TX_MODE);\r\nval &= ~BNX2_EMAC_TX_MODE_FLOW_EN;\r\nif (bp->flow_ctrl & FLOW_CTRL_TX)\r\nval |= BNX2_EMAC_TX_MODE_FLOW_EN;\r\nBNX2_WR(bp, BNX2_EMAC_TX_MODE, val);\r\nBNX2_WR(bp, BNX2_EMAC_STATUS, BNX2_EMAC_STATUS_LINK_CHANGE);\r\nbnx2_init_all_rx_contexts(bp);\r\n}\r\nstatic void\r\nbnx2_enable_bmsr1(struct bnx2 *bp)\r\n{\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(BNX2_CHIP(bp) == BNX2_CHIP_5709))\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_GP_STATUS);\r\n}\r\nstatic void\r\nbnx2_disable_bmsr1(struct bnx2 *bp)\r\n{\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(BNX2_CHIP(bp) == BNX2_CHIP_5709))\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\n}\r\nstatic int\r\nbnx2_test_and_enable_2g5(struct bnx2 *bp)\r\n{\r\nu32 up1;\r\nint ret = 1;\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\r\nreturn 0;\r\nif (bp->autoneg & AUTONEG_SPEED)\r\nbp->advertising |= ADVERTISED_2500baseX_Full;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\r\nbnx2_read_phy(bp, bp->mii_up1, &up1);\r\nif (!(up1 & BCM5708S_UP1_2G5)) {\r\nup1 |= BCM5708S_UP1_2G5;\r\nbnx2_write_phy(bp, bp->mii_up1, up1);\r\nret = 0;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nreturn ret;\r\n}\r\nstatic int\r\nbnx2_test_and_disable_2g5(struct bnx2 *bp)\r\n{\r\nu32 up1;\r\nint ret = 0;\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\r\nreturn 0;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\r\nbnx2_read_phy(bp, bp->mii_up1, &up1);\r\nif (up1 & BCM5708S_UP1_2G5) {\r\nup1 &= ~BCM5708S_UP1_2G5;\r\nbnx2_write_phy(bp, bp->mii_up1, up1);\r\nret = 1;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nreturn ret;\r\n}\r\nstatic void\r\nbnx2_enable_forced_2g5(struct bnx2 *bp)\r\n{\r\nu32 uninitialized_var(bmcr);\r\nint err;\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\r\nreturn;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nu32 val;\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_SERDES_DIG);\r\nif (!bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val)) {\r\nval &= ~MII_BNX2_SD_MISC1_FORCE_MSK;\r\nval |= MII_BNX2_SD_MISC1_FORCE |\r\nMII_BNX2_SD_MISC1_FORCE_2_5G;\r\nbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);\r\n}\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nerr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\n} else if (BNX2_CHIP(bp) == BNX2_CHIP_5708) {\r\nerr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (!err)\r\nbmcr |= BCM5708S_BMCR_FORCE_2500;\r\n} else {\r\nreturn;\r\n}\r\nif (err)\r\nreturn;\r\nif (bp->autoneg & AUTONEG_SPEED) {\r\nbmcr &= ~BMCR_ANENABLE;\r\nif (bp->req_duplex == DUPLEX_FULL)\r\nbmcr |= BMCR_FULLDPLX;\r\n}\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\r\n}\r\nstatic void\r\nbnx2_disable_forced_2g5(struct bnx2 *bp)\r\n{\r\nu32 uninitialized_var(bmcr);\r\nint err;\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\r\nreturn;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nu32 val;\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_SERDES_DIG);\r\nif (!bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val)) {\r\nval &= ~MII_BNX2_SD_MISC1_FORCE;\r\nbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);\r\n}\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\r\nMII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nerr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\n} else if (BNX2_CHIP(bp) == BNX2_CHIP_5708) {\r\nerr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (!err)\r\nbmcr &= ~BCM5708S_BMCR_FORCE_2500;\r\n} else {\r\nreturn;\r\n}\r\nif (err)\r\nreturn;\r\nif (bp->autoneg & AUTONEG_SPEED)\r\nbmcr |= BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_ANRESTART;\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\r\n}\r\nstatic void\r\nbnx2_5706s_force_link_dn(struct bnx2 *bp, int start)\r\n{\r\nu32 val;\r\nbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_SERDES_CTL);\r\nbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);\r\nif (start)\r\nbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val & 0xff0f);\r\nelse\r\nbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val | 0xc0);\r\n}\r\nstatic int\r\nbnx2_set_link(struct bnx2 *bp)\r\n{\r\nu32 bmsr;\r\nu8 link_up;\r\nif (bp->loopback == MAC_LOOPBACK || bp->loopback == PHY_LOOPBACK) {\r\nbp->link_up = 1;\r\nreturn 0;\r\n}\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn 0;\r\nlink_up = bp->link_up;\r\nbnx2_enable_bmsr1(bp);\r\nbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\r\nbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\r\nbnx2_disable_bmsr1(bp);\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(BNX2_CHIP(bp) == BNX2_CHIP_5706)) {\r\nu32 val, an_dbg;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN) {\r\nbnx2_5706s_force_link_dn(bp, 0);\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_FORCED_DOWN;\r\n}\r\nval = BNX2_RD(bp, BNX2_EMAC_STATUS);\r\nbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\r\nif ((val & BNX2_EMAC_STATUS_LINK) &&\r\n!(an_dbg & MISC_SHDW_AN_DBG_NOSYNC))\r\nbmsr |= BMSR_LSTATUS;\r\nelse\r\nbmsr &= ~BMSR_LSTATUS;\r\n}\r\nif (bmsr & BMSR_LSTATUS) {\r\nbp->link_up = 1;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\r\nbnx2_5706s_linkup(bp);\r\nelse if (BNX2_CHIP(bp) == BNX2_CHIP_5708)\r\nbnx2_5708s_linkup(bp);\r\nelse if (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_5709s_linkup(bp);\r\n}\r\nelse {\r\nbnx2_copper_linkup(bp);\r\n}\r\nbnx2_resolve_flow_ctrl(bp);\r\n}\r\nelse {\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(bp->autoneg & AUTONEG_SPEED))\r\nbnx2_disable_forced_2g5(bp);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT) {\r\nu32 bmcr;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nbmcr |= BMCR_ANENABLE;\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\r\n}\r\nbp->link_up = 0;\r\n}\r\nif (bp->link_up != link_up) {\r\nbnx2_report_link(bp);\r\n}\r\nbnx2_set_mac_link(bp);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_reset_phy(struct bnx2 *bp)\r\n{\r\nint i;\r\nu32 reg;\r\nbnx2_write_phy(bp, bp->mii_bmcr, BMCR_RESET);\r\n#define PHY_RESET_MAX_WAIT 100\r\nfor (i = 0; i < PHY_RESET_MAX_WAIT; i++) {\r\nudelay(10);\r\nbnx2_read_phy(bp, bp->mii_bmcr, &reg);\r\nif (!(reg & BMCR_RESET)) {\r\nudelay(20);\r\nbreak;\r\n}\r\n}\r\nif (i == PHY_RESET_MAX_WAIT) {\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32\r\nbnx2_phy_get_pause_adv(struct bnx2 *bp)\r\n{\r\nu32 adv = 0;\r\nif ((bp->req_flow_ctrl & (FLOW_CTRL_RX | FLOW_CTRL_TX)) ==\r\n(FLOW_CTRL_RX | FLOW_CTRL_TX)) {\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nadv = ADVERTISE_1000XPAUSE;\r\n}\r\nelse {\r\nadv = ADVERTISE_PAUSE_CAP;\r\n}\r\n}\r\nelse if (bp->req_flow_ctrl & FLOW_CTRL_TX) {\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nadv = ADVERTISE_1000XPSE_ASYM;\r\n}\r\nelse {\r\nadv = ADVERTISE_PAUSE_ASYM;\r\n}\r\n}\r\nelse if (bp->req_flow_ctrl & FLOW_CTRL_RX) {\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nadv = ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;\r\n}\r\nelse {\r\nadv = ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\n}\r\n}\r\nreturn adv;\r\n}\r\nstatic int\r\nbnx2_setup_remote_phy(struct bnx2 *bp, u8 port)\r\n__releases(&bp->phy_lock\r\nstatic int\r\nbnx2_setup_serdes_phy(struct bnx2 *bp, u8 port)\r\n__releases(&bp->phy_lock\r\nstatic void\r\nbnx2_set_default_remote_link(struct bnx2 *bp)\r\n{\r\nu32 link;\r\nif (bp->phy_port == PORT_TP)\r\nlink = bnx2_shmem_rd(bp, BNX2_RPHY_COPPER_LINK);\r\nelse\r\nlink = bnx2_shmem_rd(bp, BNX2_RPHY_SERDES_LINK);\r\nif (link & BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG) {\r\nbp->req_line_speed = 0;\r\nbp->autoneg |= AUTONEG_SPEED;\r\nbp->advertising = ADVERTISED_Autoneg;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)\r\nbp->advertising |= ADVERTISED_10baseT_Half;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_10FULL)\r\nbp->advertising |= ADVERTISED_10baseT_Full;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)\r\nbp->advertising |= ADVERTISED_100baseT_Half;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_100FULL)\r\nbp->advertising |= ADVERTISED_100baseT_Full;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)\r\nbp->advertising |= ADVERTISED_1000baseT_Full;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)\r\nbp->advertising |= ADVERTISED_2500baseX_Full;\r\n} else {\r\nbp->autoneg = 0;\r\nbp->advertising = 0;\r\nbp->req_duplex = DUPLEX_FULL;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_10) {\r\nbp->req_line_speed = SPEED_10;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)\r\nbp->req_duplex = DUPLEX_HALF;\r\n}\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_100) {\r\nbp->req_line_speed = SPEED_100;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)\r\nbp->req_duplex = DUPLEX_HALF;\r\n}\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)\r\nbp->req_line_speed = SPEED_1000;\r\nif (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)\r\nbp->req_line_speed = SPEED_2500;\r\n}\r\n}\r\nstatic void\r\nbnx2_set_default_link(struct bnx2 *bp)\r\n{\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\r\nbnx2_set_default_remote_link(bp);\r\nreturn;\r\n}\r\nbp->autoneg = AUTONEG_SPEED | AUTONEG_FLOW_CTRL;\r\nbp->req_line_speed = 0;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nu32 reg;\r\nbp->advertising = ETHTOOL_ALL_FIBRE_SPEED | ADVERTISED_Autoneg;\r\nreg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG);\r\nreg &= BNX2_PORT_HW_CFG_CFG_DFLT_LINK_MASK;\r\nif (reg == BNX2_PORT_HW_CFG_CFG_DFLT_LINK_1G) {\r\nbp->autoneg = 0;\r\nbp->req_line_speed = bp->line_speed = SPEED_1000;\r\nbp->req_duplex = DUPLEX_FULL;\r\n}\r\n} else\r\nbp->advertising = ETHTOOL_ALL_COPPER_SPEED | ADVERTISED_Autoneg;\r\n}\r\nstatic void\r\nbnx2_send_heart_beat(struct bnx2 *bp)\r\n{\r\nu32 msg;\r\nu32 addr;\r\nspin_lock(&bp->indirect_lock);\r\nmsg = (u32) (++bp->fw_drv_pulse_wr_seq & BNX2_DRV_PULSE_SEQ_MASK);\r\naddr = bp->shmem_base + BNX2_DRV_PULSE_MB;\r\nBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, addr);\r\nBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW, msg);\r\nspin_unlock(&bp->indirect_lock);\r\n}\r\nstatic void\r\nbnx2_remote_phy_event(struct bnx2 *bp)\r\n{\r\nu32 msg;\r\nu8 link_up = bp->link_up;\r\nu8 old_port;\r\nmsg = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);\r\nif (msg & BNX2_LINK_STATUS_HEART_BEAT_EXPIRED)\r\nbnx2_send_heart_beat(bp);\r\nmsg &= ~BNX2_LINK_STATUS_HEART_BEAT_EXPIRED;\r\nif ((msg & BNX2_LINK_STATUS_LINK_UP) == BNX2_LINK_STATUS_LINK_DOWN)\r\nbp->link_up = 0;\r\nelse {\r\nu32 speed;\r\nbp->link_up = 1;\r\nspeed = msg & BNX2_LINK_STATUS_SPEED_MASK;\r\nbp->duplex = DUPLEX_FULL;\r\nswitch (speed) {\r\ncase BNX2_LINK_STATUS_10HALF:\r\nbp->duplex = DUPLEX_HALF;\r\ncase BNX2_LINK_STATUS_10FULL:\r\nbp->line_speed = SPEED_10;\r\nbreak;\r\ncase BNX2_LINK_STATUS_100HALF:\r\nbp->duplex = DUPLEX_HALF;\r\ncase BNX2_LINK_STATUS_100BASE_T4:\r\ncase BNX2_LINK_STATUS_100FULL:\r\nbp->line_speed = SPEED_100;\r\nbreak;\r\ncase BNX2_LINK_STATUS_1000HALF:\r\nbp->duplex = DUPLEX_HALF;\r\ncase BNX2_LINK_STATUS_1000FULL:\r\nbp->line_speed = SPEED_1000;\r\nbreak;\r\ncase BNX2_LINK_STATUS_2500HALF:\r\nbp->duplex = DUPLEX_HALF;\r\ncase BNX2_LINK_STATUS_2500FULL:\r\nbp->line_speed = SPEED_2500;\r\nbreak;\r\ndefault:\r\nbp->line_speed = 0;\r\nbreak;\r\n}\r\nbp->flow_ctrl = 0;\r\nif ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=\r\n(AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {\r\nif (bp->duplex == DUPLEX_FULL)\r\nbp->flow_ctrl = bp->req_flow_ctrl;\r\n} else {\r\nif (msg & BNX2_LINK_STATUS_TX_FC_ENABLED)\r\nbp->flow_ctrl |= FLOW_CTRL_TX;\r\nif (msg & BNX2_LINK_STATUS_RX_FC_ENABLED)\r\nbp->flow_ctrl |= FLOW_CTRL_RX;\r\n}\r\nold_port = bp->phy_port;\r\nif (msg & BNX2_LINK_STATUS_SERDES_LINK)\r\nbp->phy_port = PORT_FIBRE;\r\nelse\r\nbp->phy_port = PORT_TP;\r\nif (old_port != bp->phy_port)\r\nbnx2_set_default_link(bp);\r\n}\r\nif (bp->link_up != link_up)\r\nbnx2_report_link(bp);\r\nbnx2_set_mac_link(bp);\r\n}\r\nstatic int\r\nbnx2_set_remote_link(struct bnx2 *bp)\r\n{\r\nu32 evt_code;\r\nevt_code = bnx2_shmem_rd(bp, BNX2_FW_EVT_CODE_MB);\r\nswitch (evt_code) {\r\ncase BNX2_FW_EVT_CODE_LINK_EVENT:\r\nbnx2_remote_phy_event(bp);\r\nbreak;\r\ncase BNX2_FW_EVT_CODE_SW_TIMER_EXPIRATION_EVENT:\r\ndefault:\r\nbnx2_send_heart_beat(bp);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_setup_copper_phy(struct bnx2 *bp)\r\n__releases(&bp->phy_lock\r\nstatic int\r\nbnx2_setup_phy(struct bnx2 *bp, u8 port)\r\n__releases(&bp->phy_lock\r\nstatic int\r\nbnx2_init_5709s_phy(struct bnx2 *bp, int reset_phy)\r\n{\r\nu32 val;\r\nbp->mii_bmcr = MII_BMCR + 0x10;\r\nbp->mii_bmsr = MII_BMSR + 0x10;\r\nbp->mii_bmsr1 = MII_BNX2_GP_TOP_AN_STATUS1;\r\nbp->mii_adv = MII_ADVERTISE + 0x10;\r\nbp->mii_lpa = MII_LPA + 0x10;\r\nbp->mii_up1 = MII_BNX2_OVER1G_UP1;\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_AER);\r\nbnx2_write_phy(bp, MII_BNX2_AER_AER, MII_BNX2_AER_AER_AN_MMD);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nif (reset_phy)\r\nbnx2_reset_phy(bp);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_SERDES_DIG);\r\nbnx2_read_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, &val);\r\nval &= ~MII_BNX2_SD_1000XCTL1_AUTODET;\r\nval |= MII_BNX2_SD_1000XCTL1_FIBER;\r\nbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, val);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\r\nbnx2_read_phy(bp, MII_BNX2_OVER1G_UP1, &val);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)\r\nval |= BCM5708S_UP1_2G5;\r\nelse\r\nval &= ~BCM5708S_UP1_2G5;\r\nbnx2_write_phy(bp, MII_BNX2_OVER1G_UP1, val);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_BAM_NXTPG);\r\nbnx2_read_phy(bp, MII_BNX2_BAM_NXTPG_CTL, &val);\r\nval |= MII_BNX2_NXTPG_CTL_T2 | MII_BNX2_NXTPG_CTL_BAM;\r\nbnx2_write_phy(bp, MII_BNX2_BAM_NXTPG_CTL, val);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_CL73_USERB0);\r\nval = MII_BNX2_CL73_BAM_EN | MII_BNX2_CL73_BAM_STA_MGR_EN |\r\nMII_BNX2_CL73_BAM_NP_AFT_BP_EN;\r\nbnx2_write_phy(bp, MII_BNX2_CL73_BAM_CTL1, val);\r\nbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_5708s_phy(struct bnx2 *bp, int reset_phy)\r\n{\r\nu32 val;\r\nif (reset_phy)\r\nbnx2_reset_phy(bp);\r\nbp->mii_up1 = BCM5708S_UP1;\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG3);\r\nbnx2_write_phy(bp, BCM5708S_DIG_3_0, BCM5708S_DIG_3_0_USE_IEEE);\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);\r\nbnx2_read_phy(bp, BCM5708S_1000X_CTL1, &val);\r\nval |= BCM5708S_1000X_CTL1_FIBER_MODE | BCM5708S_1000X_CTL1_AUTODET_EN;\r\nbnx2_write_phy(bp, BCM5708S_1000X_CTL1, val);\r\nbnx2_read_phy(bp, BCM5708S_1000X_CTL2, &val);\r\nval |= BCM5708S_1000X_CTL2_PLLEL_DET_EN;\r\nbnx2_write_phy(bp, BCM5708S_1000X_CTL2, val);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) {\r\nbnx2_read_phy(bp, BCM5708S_UP1, &val);\r\nval |= BCM5708S_UP1_2G5;\r\nbnx2_write_phy(bp, BCM5708S_UP1, val);\r\n}\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B1)) {\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\r\nBCM5708S_BLK_ADDR_TX_MISC);\r\nbnx2_read_phy(bp, BCM5708S_TX_ACTL1, &val);\r\nval &= ~BCM5708S_TX_ACTL1_DRIVER_VCM;\r\nbnx2_write_phy(bp, BCM5708S_TX_ACTL1, val);\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);\r\n}\r\nval = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG) &\r\nBNX2_PORT_HW_CFG_CFG_TXCTL3_MASK;\r\nif (val) {\r\nu32 is_backplane;\r\nis_backplane = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);\r\nif (is_backplane & BNX2_SHARED_HW_CFG_PHY_BACKPLANE) {\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\r\nBCM5708S_BLK_ADDR_TX_MISC);\r\nbnx2_write_phy(bp, BCM5708S_TX_ACTL3, val);\r\nbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\r\nBCM5708S_BLK_ADDR_DIG);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_5706s_phy(struct bnx2 *bp, int reset_phy)\r\n{\r\nif (reset_phy)\r\nbnx2_reset_phy(bp);\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\r\nBNX2_WR(bp, BNX2_MISC_GP_HW_CTL0, 0x300);\r\nif (bp->dev->mtu > 1500) {\r\nu32 val;\r\nbnx2_write_phy(bp, 0x18, 0x7);\r\nbnx2_read_phy(bp, 0x18, &val);\r\nbnx2_write_phy(bp, 0x18, (val & 0xfff8) | 0x4000);\r\nbnx2_write_phy(bp, 0x1c, 0x6c00);\r\nbnx2_read_phy(bp, 0x1c, &val);\r\nbnx2_write_phy(bp, 0x1c, (val & 0x3ff) | 0xec02);\r\n}\r\nelse {\r\nu32 val;\r\nbnx2_write_phy(bp, 0x18, 0x7);\r\nbnx2_read_phy(bp, 0x18, &val);\r\nbnx2_write_phy(bp, 0x18, val & ~0x4007);\r\nbnx2_write_phy(bp, 0x1c, 0x6c00);\r\nbnx2_read_phy(bp, 0x1c, &val);\r\nbnx2_write_phy(bp, 0x1c, (val & 0x3fd) | 0xec00);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_copper_phy(struct bnx2 *bp, int reset_phy)\r\n{\r\nu32 val;\r\nif (reset_phy)\r\nbnx2_reset_phy(bp);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_CRC_FIX) {\r\nbnx2_write_phy(bp, 0x18, 0x0c00);\r\nbnx2_write_phy(bp, 0x17, 0x000a);\r\nbnx2_write_phy(bp, 0x15, 0x310b);\r\nbnx2_write_phy(bp, 0x17, 0x201f);\r\nbnx2_write_phy(bp, 0x15, 0x9506);\r\nbnx2_write_phy(bp, 0x17, 0x401f);\r\nbnx2_write_phy(bp, 0x15, 0x14e2);\r\nbnx2_write_phy(bp, 0x18, 0x0400);\r\n}\r\nif (bp->phy_flags & BNX2_PHY_FLAG_DIS_EARLY_DAC) {\r\nbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS,\r\nMII_BNX2_DSP_EXPAND_REG | 0x8);\r\nbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);\r\nval &= ~(1 << 8);\r\nbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val);\r\n}\r\nif (bp->dev->mtu > 1500) {\r\nbnx2_write_phy(bp, 0x18, 0x7);\r\nbnx2_read_phy(bp, 0x18, &val);\r\nbnx2_write_phy(bp, 0x18, val | 0x4000);\r\nbnx2_read_phy(bp, 0x10, &val);\r\nbnx2_write_phy(bp, 0x10, val | 0x1);\r\n}\r\nelse {\r\nbnx2_write_phy(bp, 0x18, 0x7);\r\nbnx2_read_phy(bp, 0x18, &val);\r\nbnx2_write_phy(bp, 0x18, val & ~0x4007);\r\nbnx2_read_phy(bp, 0x10, &val);\r\nbnx2_write_phy(bp, 0x10, val & ~0x1);\r\n}\r\nbnx2_write_phy(bp, MII_BNX2_AUX_CTL, AUX_CTL_MISC_CTL);\r\nbnx2_read_phy(bp, MII_BNX2_AUX_CTL, &val);\r\nval |= AUX_CTL_MISC_CTL_WR | AUX_CTL_MISC_CTL_WIRESPEED;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nval |= AUX_CTL_MISC_CTL_AUTOMDIX;\r\nbnx2_write_phy(bp, MII_BNX2_AUX_CTL, val);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_phy(struct bnx2 *bp, int reset_phy)\r\n__releases(&bp->phy_lock\r\nstatic int\r\nbnx2_set_mac_loopback(struct bnx2 *bp)\r\n{\r\nu32 mac_mode;\r\nmac_mode = BNX2_RD(bp, BNX2_EMAC_MODE);\r\nmac_mode &= ~BNX2_EMAC_MODE_PORT;\r\nmac_mode |= BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK;\r\nBNX2_WR(bp, BNX2_EMAC_MODE, mac_mode);\r\nbp->link_up = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_set_phy_loopback(struct bnx2 *bp)\r\n{\r\nu32 mac_mode;\r\nint rc, i;\r\nspin_lock_bh(&bp->phy_lock);\r\nrc = bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK | BMCR_FULLDPLX |\r\nBMCR_SPEED1000);\r\nspin_unlock_bh(&bp->phy_lock);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < 10; i++) {\r\nif (bnx2_test_link(bp) == 0)\r\nbreak;\r\nmsleep(100);\r\n}\r\nmac_mode = BNX2_RD(bp, BNX2_EMAC_MODE);\r\nmac_mode &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |\r\nBNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |\r\nBNX2_EMAC_MODE_25G_MODE);\r\nmac_mode |= BNX2_EMAC_MODE_PORT_GMII;\r\nBNX2_WR(bp, BNX2_EMAC_MODE, mac_mode);\r\nbp->link_up = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_dump_mcp_state(struct bnx2 *bp)\r\n{\r\nstruct net_device *dev = bp->dev;\r\nu32 mcp_p0, mcp_p1;\r\nnetdev_err(dev, "<--- start MCP states dump --->\n");\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nmcp_p0 = BNX2_MCP_STATE_P0;\r\nmcp_p1 = BNX2_MCP_STATE_P1;\r\n} else {\r\nmcp_p0 = BNX2_MCP_STATE_P0_5708;\r\nmcp_p1 = BNX2_MCP_STATE_P1_5708;\r\n}\r\nnetdev_err(dev, "DEBUG: MCP_STATE_P0[%08x] MCP_STATE_P1[%08x]\n",\r\nbnx2_reg_rd_ind(bp, mcp_p0), bnx2_reg_rd_ind(bp, mcp_p1));\r\nnetdev_err(dev, "DEBUG: MCP mode[%08x] state[%08x] evt_mask[%08x]\n",\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_MODE),\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_STATE),\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_EVENT_MASK));\r\nnetdev_err(dev, "DEBUG: pc[%08x] pc[%08x] instr[%08x]\n",\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_PROGRAM_COUNTER),\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_PROGRAM_COUNTER),\r\nbnx2_reg_rd_ind(bp, BNX2_MCP_CPU_INSTRUCTION));\r\nnetdev_err(dev, "DEBUG: shmem states:\n");\r\nnetdev_err(dev, "DEBUG: drv_mb[%08x] fw_mb[%08x] link_status[%08x]",\r\nbnx2_shmem_rd(bp, BNX2_DRV_MB),\r\nbnx2_shmem_rd(bp, BNX2_FW_MB),\r\nbnx2_shmem_rd(bp, BNX2_LINK_STATUS));\r\npr_cont(" drv_pulse_mb[%08x]\n", bnx2_shmem_rd(bp, BNX2_DRV_PULSE_MB));\r\nnetdev_err(dev, "DEBUG: dev_info_signature[%08x] reset_type[%08x]",\r\nbnx2_shmem_rd(bp, BNX2_DEV_INFO_SIGNATURE),\r\nbnx2_shmem_rd(bp, BNX2_BC_STATE_RESET_TYPE));\r\npr_cont(" condition[%08x]\n",\r\nbnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION));\r\nDP_SHMEM_LINE(bp, BNX2_BC_RESET_TYPE);\r\nDP_SHMEM_LINE(bp, 0x3cc);\r\nDP_SHMEM_LINE(bp, 0x3dc);\r\nDP_SHMEM_LINE(bp, 0x3ec);\r\nnetdev_err(dev, "DEBUG: 0x3fc[%08x]\n", bnx2_shmem_rd(bp, 0x3fc));\r\nnetdev_err(dev, "<--- end MCP states dump --->\n");\r\n}\r\nstatic int\r\nbnx2_fw_sync(struct bnx2 *bp, u32 msg_data, int ack, int silent)\r\n{\r\nint i;\r\nu32 val;\r\nbp->fw_wr_seq++;\r\nmsg_data |= bp->fw_wr_seq;\r\nbp->fw_last_msg = msg_data;\r\nbnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);\r\nif (!ack)\r\nreturn 0;\r\nfor (i = 0; i < (BNX2_FW_ACK_TIME_OUT_MS / 10); i++) {\r\nmsleep(10);\r\nval = bnx2_shmem_rd(bp, BNX2_FW_MB);\r\nif ((val & BNX2_FW_MSG_ACK) == (msg_data & BNX2_DRV_MSG_SEQ))\r\nbreak;\r\n}\r\nif ((msg_data & BNX2_DRV_MSG_DATA) == BNX2_DRV_MSG_DATA_WAIT0)\r\nreturn 0;\r\nif ((val & BNX2_FW_MSG_ACK) != (msg_data & BNX2_DRV_MSG_SEQ)) {\r\nmsg_data &= ~BNX2_DRV_MSG_CODE;\r\nmsg_data |= BNX2_DRV_MSG_CODE_FW_TIMEOUT;\r\nbnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);\r\nif (!silent) {\r\npr_err("fw sync timeout, reset code = %x\n", msg_data);\r\nbnx2_dump_mcp_state(bp);\r\n}\r\nreturn -EBUSY;\r\n}\r\nif ((val & BNX2_FW_MSG_STATUS_MASK) != BNX2_FW_MSG_STATUS_OK)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_5709_context(struct bnx2 *bp)\r\n{\r\nint i, ret = 0;\r\nu32 val;\r\nval = BNX2_CTX_COMMAND_ENABLED | BNX2_CTX_COMMAND_MEM_INIT | (1 << 12);\r\nval |= (BNX2_PAGE_BITS - 8) << 16;\r\nBNX2_WR(bp, BNX2_CTX_COMMAND, val);\r\nfor (i = 0; i < 10; i++) {\r\nval = BNX2_RD(bp, BNX2_CTX_COMMAND);\r\nif (!(val & BNX2_CTX_COMMAND_MEM_INIT))\r\nbreak;\r\nudelay(2);\r\n}\r\nif (val & BNX2_CTX_COMMAND_MEM_INIT)\r\nreturn -EBUSY;\r\nfor (i = 0; i < bp->ctx_pages; i++) {\r\nint j;\r\nif (bp->ctx_blk[i])\r\nmemset(bp->ctx_blk[i], 0, BNX2_PAGE_SIZE);\r\nelse\r\nreturn -ENOMEM;\r\nBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA0,\r\n(bp->ctx_blk_mapping[i] & 0xffffffff) |\r\nBNX2_CTX_HOST_PAGE_TBL_DATA0_VALID);\r\nBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA1,\r\n(u64) bp->ctx_blk_mapping[i] >> 32);\r\nBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL, i |\r\nBNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);\r\nfor (j = 0; j < 10; j++) {\r\nval = BNX2_RD(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL);\r\nif (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nbnx2_init_context(struct bnx2 *bp)\r\n{\r\nu32 vcid;\r\nvcid = 96;\r\nwhile (vcid) {\r\nu32 vcid_addr, pcid_addr, offset;\r\nint i;\r\nvcid--;\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\r\nu32 new_vcid;\r\nvcid_addr = GET_PCID_ADDR(vcid);\r\nif (vcid & 0x8) {\r\nnew_vcid = 0x60 + (vcid & 0xf0) + (vcid & 0x7);\r\n}\r\nelse {\r\nnew_vcid = vcid;\r\n}\r\npcid_addr = GET_PCID_ADDR(new_vcid);\r\n}\r\nelse {\r\nvcid_addr = GET_CID_ADDR(vcid);\r\npcid_addr = vcid_addr;\r\n}\r\nfor (i = 0; i < (CTX_SIZE / PHY_CTX_SIZE); i++) {\r\nvcid_addr += (i << PHY_CTX_SHIFT);\r\npcid_addr += (i << PHY_CTX_SHIFT);\r\nBNX2_WR(bp, BNX2_CTX_VIRT_ADDR, vcid_addr);\r\nBNX2_WR(bp, BNX2_CTX_PAGE_TBL, pcid_addr);\r\nfor (offset = 0; offset < PHY_CTX_SIZE; offset += 4)\r\nbnx2_ctx_wr(bp, vcid_addr, offset, 0);\r\n}\r\n}\r\n}\r\nstatic int\r\nbnx2_alloc_bad_rbuf(struct bnx2 *bp)\r\n{\r\nu16 *good_mbuf;\r\nu32 good_mbuf_cnt;\r\nu32 val;\r\ngood_mbuf = kmalloc(512 * sizeof(u16), GFP_KERNEL);\r\nif (good_mbuf == NULL)\r\nreturn -ENOMEM;\r\nBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\r\nBNX2_MISC_ENABLE_SET_BITS_RX_MBUF_ENABLE);\r\ngood_mbuf_cnt = 0;\r\nval = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);\r\nwhile (val & BNX2_RBUF_STATUS1_FREE_COUNT) {\r\nbnx2_reg_wr_ind(bp, BNX2_RBUF_COMMAND,\r\nBNX2_RBUF_COMMAND_ALLOC_REQ);\r\nval = bnx2_reg_rd_ind(bp, BNX2_RBUF_FW_BUF_ALLOC);\r\nval &= BNX2_RBUF_FW_BUF_ALLOC_VALUE;\r\nif (!(val & (1 << 9))) {\r\ngood_mbuf[good_mbuf_cnt] = (u16) val;\r\ngood_mbuf_cnt++;\r\n}\r\nval = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);\r\n}\r\nwhile (good_mbuf_cnt) {\r\ngood_mbuf_cnt--;\r\nval = good_mbuf[good_mbuf_cnt];\r\nval = (val << 9) | val | 1;\r\nbnx2_reg_wr_ind(bp, BNX2_RBUF_FW_BUF_FREE, val);\r\n}\r\nkfree(good_mbuf);\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_set_mac_addr(struct bnx2 *bp, u8 *mac_addr, u32 pos)\r\n{\r\nu32 val;\r\nval = (mac_addr[0] << 8) | mac_addr[1];\r\nBNX2_WR(bp, BNX2_EMAC_MAC_MATCH0 + (pos * 8), val);\r\nval = (mac_addr[2] << 24) | (mac_addr[3] << 16) |\r\n(mac_addr[4] << 8) | mac_addr[5];\r\nBNX2_WR(bp, BNX2_EMAC_MAC_MATCH1 + (pos * 8), val);\r\n}\r\nstatic inline int\r\nbnx2_alloc_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index, gfp_t gfp)\r\n{\r\ndma_addr_t mapping;\r\nstruct bnx2_sw_pg *rx_pg = &rxr->rx_pg_ring[index];\r\nstruct bnx2_rx_bd *rxbd =\r\n&rxr->rx_pg_desc_ring[BNX2_RX_RING(index)][BNX2_RX_IDX(index)];\r\nstruct page *page = alloc_page(gfp);\r\nif (!page)\r\nreturn -ENOMEM;\r\nmapping = dma_map_page(&bp->pdev->dev, page, 0, PAGE_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&bp->pdev->dev, mapping)) {\r\n__free_page(page);\r\nreturn -EIO;\r\n}\r\nrx_pg->page = page;\r\ndma_unmap_addr_set(rx_pg, mapping, mapping);\r\nrxbd->rx_bd_haddr_hi = (u64) mapping >> 32;\r\nrxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_free_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index)\r\n{\r\nstruct bnx2_sw_pg *rx_pg = &rxr->rx_pg_ring[index];\r\nstruct page *page = rx_pg->page;\r\nif (!page)\r\nreturn;\r\ndma_unmap_page(&bp->pdev->dev, dma_unmap_addr(rx_pg, mapping),\r\nPAGE_SIZE, PCI_DMA_FROMDEVICE);\r\n__free_page(page);\r\nrx_pg->page = NULL;\r\n}\r\nstatic inline int\r\nbnx2_alloc_rx_data(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index, gfp_t gfp)\r\n{\r\nu8 *data;\r\nstruct bnx2_sw_bd *rx_buf = &rxr->rx_buf_ring[index];\r\ndma_addr_t mapping;\r\nstruct bnx2_rx_bd *rxbd =\r\n&rxr->rx_desc_ring[BNX2_RX_RING(index)][BNX2_RX_IDX(index)];\r\ndata = kmalloc(bp->rx_buf_size, gfp);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmapping = dma_map_single(&bp->pdev->dev,\r\nget_l2_fhdr(data),\r\nbp->rx_buf_use_size,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&bp->pdev->dev, mapping)) {\r\nkfree(data);\r\nreturn -EIO;\r\n}\r\nrx_buf->data = data;\r\ndma_unmap_addr_set(rx_buf, mapping, mapping);\r\nrxbd->rx_bd_haddr_hi = (u64) mapping >> 32;\r\nrxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;\r\nrxr->rx_prod_bseq += bp->rx_buf_use_size;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_phy_event_is_set(struct bnx2 *bp, struct bnx2_napi *bnapi, u32 event)\r\n{\r\nstruct status_block *sblk = bnapi->status_blk.msi;\r\nu32 new_link_state, old_link_state;\r\nint is_set = 1;\r\nnew_link_state = sblk->status_attn_bits & event;\r\nold_link_state = sblk->status_attn_bits_ack & event;\r\nif (new_link_state != old_link_state) {\r\nif (new_link_state)\r\nBNX2_WR(bp, BNX2_PCICFG_STATUS_BIT_SET_CMD, event);\r\nelse\r\nBNX2_WR(bp, BNX2_PCICFG_STATUS_BIT_CLEAR_CMD, event);\r\n} else\r\nis_set = 0;\r\nreturn is_set;\r\n}\r\nstatic void\r\nbnx2_phy_int(struct bnx2 *bp, struct bnx2_napi *bnapi)\r\n{\r\nspin_lock(&bp->phy_lock);\r\nif (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_LINK_STATE))\r\nbnx2_set_link(bp);\r\nif (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_TIMER_ABORT))\r\nbnx2_set_remote_link(bp);\r\nspin_unlock(&bp->phy_lock);\r\n}\r\nstatic inline u16\r\nbnx2_get_hw_tx_cons(struct bnx2_napi *bnapi)\r\n{\r\nu16 cons;\r\nbarrier();\r\ncons = *bnapi->hw_tx_cons_ptr;\r\nbarrier();\r\nif (unlikely((cons & BNX2_MAX_TX_DESC_CNT) == BNX2_MAX_TX_DESC_CNT))\r\ncons++;\r\nreturn cons;\r\n}\r\nstatic int\r\nbnx2_tx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)\r\n{\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nu16 hw_cons, sw_cons, sw_ring_cons;\r\nint tx_pkt = 0, index;\r\nunsigned int tx_bytes = 0;\r\nstruct netdev_queue *txq;\r\nindex = (bnapi - bp->bnx2_napi);\r\ntxq = netdev_get_tx_queue(bp->dev, index);\r\nhw_cons = bnx2_get_hw_tx_cons(bnapi);\r\nsw_cons = txr->tx_cons;\r\nwhile (sw_cons != hw_cons) {\r\nstruct bnx2_sw_tx_bd *tx_buf;\r\nstruct sk_buff *skb;\r\nint i, last;\r\nsw_ring_cons = BNX2_TX_RING_IDX(sw_cons);\r\ntx_buf = &txr->tx_buf_ring[sw_ring_cons];\r\nskb = tx_buf->skb;\r\nprefetch(&skb->end);\r\nif (tx_buf->is_gso) {\r\nu16 last_idx, last_ring_idx;\r\nlast_idx = sw_cons + tx_buf->nr_frags + 1;\r\nlast_ring_idx = sw_ring_cons + tx_buf->nr_frags + 1;\r\nif (unlikely(last_ring_idx >= BNX2_MAX_TX_DESC_CNT)) {\r\nlast_idx++;\r\n}\r\nif (((s16) ((s16) last_idx - (s16) hw_cons)) > 0) {\r\nbreak;\r\n}\r\n}\r\ndma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\r\nskb_headlen(skb), PCI_DMA_TODEVICE);\r\ntx_buf->skb = NULL;\r\nlast = tx_buf->nr_frags;\r\nfor (i = 0; i < last; i++) {\r\nstruct bnx2_sw_tx_bd *tx_buf;\r\nsw_cons = BNX2_NEXT_TX_BD(sw_cons);\r\ntx_buf = &txr->tx_buf_ring[BNX2_TX_RING_IDX(sw_cons)];\r\ndma_unmap_page(&bp->pdev->dev,\r\ndma_unmap_addr(tx_buf, mapping),\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nPCI_DMA_TODEVICE);\r\n}\r\nsw_cons = BNX2_NEXT_TX_BD(sw_cons);\r\ntx_bytes += skb->len;\r\ndev_kfree_skb_any(skb);\r\ntx_pkt++;\r\nif (tx_pkt == budget)\r\nbreak;\r\nif (hw_cons == sw_cons)\r\nhw_cons = bnx2_get_hw_tx_cons(bnapi);\r\n}\r\nnetdev_tx_completed_queue(txq, tx_pkt, tx_bytes);\r\ntxr->hw_tx_cons = hw_cons;\r\ntxr->tx_cons = sw_cons;\r\nsmp_mb();\r\nif (unlikely(netif_tx_queue_stopped(txq)) &&\r\n(bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)) {\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif ((netif_tx_queue_stopped(txq)) &&\r\n(bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh))\r\nnetif_tx_wake_queue(txq);\r\n__netif_tx_unlock(txq);\r\n}\r\nreturn tx_pkt;\r\n}\r\nstatic void\r\nbnx2_reuse_rx_skb_pages(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,\r\nstruct sk_buff *skb, int count)\r\n{\r\nstruct bnx2_sw_pg *cons_rx_pg, *prod_rx_pg;\r\nstruct bnx2_rx_bd *cons_bd, *prod_bd;\r\nint i;\r\nu16 hw_prod, prod;\r\nu16 cons = rxr->rx_pg_cons;\r\ncons_rx_pg = &rxr->rx_pg_ring[cons];\r\nif (skb) {\r\nstruct page *page;\r\nstruct skb_shared_info *shinfo;\r\nshinfo = skb_shinfo(skb);\r\nshinfo->nr_frags--;\r\npage = skb_frag_page(&shinfo->frags[shinfo->nr_frags]);\r\n__skb_frag_set_page(&shinfo->frags[shinfo->nr_frags], NULL);\r\ncons_rx_pg->page = page;\r\ndev_kfree_skb(skb);\r\n}\r\nhw_prod = rxr->rx_pg_prod;\r\nfor (i = 0; i < count; i++) {\r\nprod = BNX2_RX_PG_RING_IDX(hw_prod);\r\nprod_rx_pg = &rxr->rx_pg_ring[prod];\r\ncons_rx_pg = &rxr->rx_pg_ring[cons];\r\ncons_bd = &rxr->rx_pg_desc_ring[BNX2_RX_RING(cons)]\r\n[BNX2_RX_IDX(cons)];\r\nprod_bd = &rxr->rx_pg_desc_ring[BNX2_RX_RING(prod)]\r\n[BNX2_RX_IDX(prod)];\r\nif (prod != cons) {\r\nprod_rx_pg->page = cons_rx_pg->page;\r\ncons_rx_pg->page = NULL;\r\ndma_unmap_addr_set(prod_rx_pg, mapping,\r\ndma_unmap_addr(cons_rx_pg, mapping));\r\nprod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;\r\nprod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;\r\n}\r\ncons = BNX2_RX_PG_RING_IDX(BNX2_NEXT_RX_BD(cons));\r\nhw_prod = BNX2_NEXT_RX_BD(hw_prod);\r\n}\r\nrxr->rx_pg_prod = hw_prod;\r\nrxr->rx_pg_cons = cons;\r\n}\r\nstatic inline void\r\nbnx2_reuse_rx_data(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,\r\nu8 *data, u16 cons, u16 prod)\r\n{\r\nstruct bnx2_sw_bd *cons_rx_buf, *prod_rx_buf;\r\nstruct bnx2_rx_bd *cons_bd, *prod_bd;\r\ncons_rx_buf = &rxr->rx_buf_ring[cons];\r\nprod_rx_buf = &rxr->rx_buf_ring[prod];\r\ndma_sync_single_for_device(&bp->pdev->dev,\r\ndma_unmap_addr(cons_rx_buf, mapping),\r\nBNX2_RX_OFFSET + BNX2_RX_COPY_THRESH, PCI_DMA_FROMDEVICE);\r\nrxr->rx_prod_bseq += bp->rx_buf_use_size;\r\nprod_rx_buf->data = data;\r\nif (cons == prod)\r\nreturn;\r\ndma_unmap_addr_set(prod_rx_buf, mapping,\r\ndma_unmap_addr(cons_rx_buf, mapping));\r\ncons_bd = &rxr->rx_desc_ring[BNX2_RX_RING(cons)][BNX2_RX_IDX(cons)];\r\nprod_bd = &rxr->rx_desc_ring[BNX2_RX_RING(prod)][BNX2_RX_IDX(prod)];\r\nprod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;\r\nprod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;\r\n}\r\nstatic struct sk_buff *\r\nbnx2_rx_skb(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u8 *data,\r\nunsigned int len, unsigned int hdr_len, dma_addr_t dma_addr,\r\nu32 ring_idx)\r\n{\r\nint err;\r\nu16 prod = ring_idx & 0xffff;\r\nstruct sk_buff *skb;\r\nerr = bnx2_alloc_rx_data(bp, rxr, prod, GFP_ATOMIC);\r\nif (unlikely(err)) {\r\nbnx2_reuse_rx_data(bp, rxr, data, (u16) (ring_idx >> 16), prod);\r\nerror:\r\nif (hdr_len) {\r\nunsigned int raw_len = len + 4;\r\nint pages = PAGE_ALIGN(raw_len - hdr_len) >> PAGE_SHIFT;\r\nbnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);\r\n}\r\nreturn NULL;\r\n}\r\ndma_unmap_single(&bp->pdev->dev, dma_addr, bp->rx_buf_use_size,\r\nPCI_DMA_FROMDEVICE);\r\nskb = build_skb(data, 0);\r\nif (!skb) {\r\nkfree(data);\r\ngoto error;\r\n}\r\nskb_reserve(skb, ((u8 *)get_l2_fhdr(data) - data) + BNX2_RX_OFFSET);\r\nif (hdr_len == 0) {\r\nskb_put(skb, len);\r\nreturn skb;\r\n} else {\r\nunsigned int i, frag_len, frag_size, pages;\r\nstruct bnx2_sw_pg *rx_pg;\r\nu16 pg_cons = rxr->rx_pg_cons;\r\nu16 pg_prod = rxr->rx_pg_prod;\r\nfrag_size = len + 4 - hdr_len;\r\npages = PAGE_ALIGN(frag_size) >> PAGE_SHIFT;\r\nskb_put(skb, hdr_len);\r\nfor (i = 0; i < pages; i++) {\r\ndma_addr_t mapping_old;\r\nfrag_len = min(frag_size, (unsigned int) PAGE_SIZE);\r\nif (unlikely(frag_len <= 4)) {\r\nunsigned int tail = 4 - frag_len;\r\nrxr->rx_pg_cons = pg_cons;\r\nrxr->rx_pg_prod = pg_prod;\r\nbnx2_reuse_rx_skb_pages(bp, rxr, NULL,\r\npages - i);\r\nskb->len -= tail;\r\nif (i == 0) {\r\nskb->tail -= tail;\r\n} else {\r\nskb_frag_t *frag =\r\n&skb_shinfo(skb)->frags[i - 1];\r\nskb_frag_size_sub(frag, tail);\r\nskb->data_len -= tail;\r\n}\r\nreturn skb;\r\n}\r\nrx_pg = &rxr->rx_pg_ring[pg_cons];\r\nmapping_old = dma_unmap_addr(rx_pg, mapping);\r\nif (i == pages - 1)\r\nfrag_len -= 4;\r\nskb_fill_page_desc(skb, i, rx_pg->page, 0, frag_len);\r\nrx_pg->page = NULL;\r\nerr = bnx2_alloc_rx_page(bp, rxr,\r\nBNX2_RX_PG_RING_IDX(pg_prod),\r\nGFP_ATOMIC);\r\nif (unlikely(err)) {\r\nrxr->rx_pg_cons = pg_cons;\r\nrxr->rx_pg_prod = pg_prod;\r\nbnx2_reuse_rx_skb_pages(bp, rxr, skb,\r\npages - i);\r\nreturn NULL;\r\n}\r\ndma_unmap_page(&bp->pdev->dev, mapping_old,\r\nPAGE_SIZE, PCI_DMA_FROMDEVICE);\r\nfrag_size -= frag_len;\r\nskb->data_len += frag_len;\r\nskb->truesize += PAGE_SIZE;\r\nskb->len += frag_len;\r\npg_prod = BNX2_NEXT_RX_BD(pg_prod);\r\npg_cons = BNX2_RX_PG_RING_IDX(BNX2_NEXT_RX_BD(pg_cons));\r\n}\r\nrxr->rx_pg_prod = pg_prod;\r\nrxr->rx_pg_cons = pg_cons;\r\n}\r\nreturn skb;\r\n}\r\nstatic inline u16\r\nbnx2_get_hw_rx_cons(struct bnx2_napi *bnapi)\r\n{\r\nu16 cons;\r\nbarrier();\r\ncons = *bnapi->hw_rx_cons_ptr;\r\nbarrier();\r\nif (unlikely((cons & BNX2_MAX_RX_DESC_CNT) == BNX2_MAX_RX_DESC_CNT))\r\ncons++;\r\nreturn cons;\r\n}\r\nstatic int\r\nbnx2_rx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)\r\n{\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nu16 hw_cons, sw_cons, sw_ring_cons, sw_prod, sw_ring_prod;\r\nstruct l2_fhdr *rx_hdr;\r\nint rx_pkt = 0, pg_ring_used = 0;\r\nif (budget <= 0)\r\nreturn rx_pkt;\r\nhw_cons = bnx2_get_hw_rx_cons(bnapi);\r\nsw_cons = rxr->rx_cons;\r\nsw_prod = rxr->rx_prod;\r\nrmb();\r\nwhile (sw_cons != hw_cons) {\r\nunsigned int len, hdr_len;\r\nu32 status;\r\nstruct bnx2_sw_bd *rx_buf, *next_rx_buf;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\nu8 *data;\r\nu16 next_ring_idx;\r\nsw_ring_cons = BNX2_RX_RING_IDX(sw_cons);\r\nsw_ring_prod = BNX2_RX_RING_IDX(sw_prod);\r\nrx_buf = &rxr->rx_buf_ring[sw_ring_cons];\r\ndata = rx_buf->data;\r\nrx_buf->data = NULL;\r\nrx_hdr = get_l2_fhdr(data);\r\nprefetch(rx_hdr);\r\ndma_addr = dma_unmap_addr(rx_buf, mapping);\r\ndma_sync_single_for_cpu(&bp->pdev->dev, dma_addr,\r\nBNX2_RX_OFFSET + BNX2_RX_COPY_THRESH,\r\nPCI_DMA_FROMDEVICE);\r\nnext_ring_idx = BNX2_RX_RING_IDX(BNX2_NEXT_RX_BD(sw_cons));\r\nnext_rx_buf = &rxr->rx_buf_ring[next_ring_idx];\r\nprefetch(get_l2_fhdr(next_rx_buf->data));\r\nlen = rx_hdr->l2_fhdr_pkt_len;\r\nstatus = rx_hdr->l2_fhdr_status;\r\nhdr_len = 0;\r\nif (status & L2_FHDR_STATUS_SPLIT) {\r\nhdr_len = rx_hdr->l2_fhdr_ip_xsum;\r\npg_ring_used = 1;\r\n} else if (len > bp->rx_jumbo_thresh) {\r\nhdr_len = bp->rx_jumbo_thresh;\r\npg_ring_used = 1;\r\n}\r\nif (unlikely(status & (L2_FHDR_ERRORS_BAD_CRC |\r\nL2_FHDR_ERRORS_PHY_DECODE |\r\nL2_FHDR_ERRORS_ALIGNMENT |\r\nL2_FHDR_ERRORS_TOO_SHORT |\r\nL2_FHDR_ERRORS_GIANT_FRAME))) {\r\nbnx2_reuse_rx_data(bp, rxr, data, sw_ring_cons,\r\nsw_ring_prod);\r\nif (pg_ring_used) {\r\nint pages;\r\npages = PAGE_ALIGN(len - hdr_len) >> PAGE_SHIFT;\r\nbnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);\r\n}\r\ngoto next_rx;\r\n}\r\nlen -= 4;\r\nif (len <= bp->rx_copy_thresh) {\r\nskb = netdev_alloc_skb(bp->dev, len + 6);\r\nif (skb == NULL) {\r\nbnx2_reuse_rx_data(bp, rxr, data, sw_ring_cons,\r\nsw_ring_prod);\r\ngoto next_rx;\r\n}\r\nmemcpy(skb->data,\r\n(u8 *)rx_hdr + BNX2_RX_OFFSET - 6,\r\nlen + 6);\r\nskb_reserve(skb, 6);\r\nskb_put(skb, len);\r\nbnx2_reuse_rx_data(bp, rxr, data,\r\nsw_ring_cons, sw_ring_prod);\r\n} else {\r\nskb = bnx2_rx_skb(bp, rxr, data, len, hdr_len, dma_addr,\r\n(sw_ring_cons << 16) | sw_ring_prod);\r\nif (!skb)\r\ngoto next_rx;\r\n}\r\nif ((status & L2_FHDR_STATUS_L2_VLAN_TAG) &&\r\n!(bp->rx_mode & BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG))\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), rx_hdr->l2_fhdr_vlan_tag);\r\nskb->protocol = eth_type_trans(skb, bp->dev);\r\nif (len > (bp->dev->mtu + ETH_HLEN) &&\r\nskb->protocol != htons(0x8100) &&\r\nskb->protocol != htons(ETH_P_8021AD)) {\r\ndev_kfree_skb(skb);\r\ngoto next_rx;\r\n}\r\nskb_checksum_none_assert(skb);\r\nif ((bp->dev->features & NETIF_F_RXCSUM) &&\r\n(status & (L2_FHDR_STATUS_TCP_SEGMENT |\r\nL2_FHDR_STATUS_UDP_DATAGRAM))) {\r\nif (likely((status & (L2_FHDR_ERRORS_TCP_XSUM |\r\nL2_FHDR_ERRORS_UDP_XSUM)) == 0))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nif ((bp->dev->features & NETIF_F_RXHASH) &&\r\n((status & L2_FHDR_STATUS_USE_RXHASH) ==\r\nL2_FHDR_STATUS_USE_RXHASH))\r\nskb_set_hash(skb, rx_hdr->l2_fhdr_hash,\r\nPKT_HASH_TYPE_L3);\r\nskb_record_rx_queue(skb, bnapi - &bp->bnx2_napi[0]);\r\nnapi_gro_receive(&bnapi->napi, skb);\r\nrx_pkt++;\r\nnext_rx:\r\nsw_cons = BNX2_NEXT_RX_BD(sw_cons);\r\nsw_prod = BNX2_NEXT_RX_BD(sw_prod);\r\nif ((rx_pkt == budget))\r\nbreak;\r\nif (sw_cons == hw_cons) {\r\nhw_cons = bnx2_get_hw_rx_cons(bnapi);\r\nrmb();\r\n}\r\n}\r\nrxr->rx_cons = sw_cons;\r\nrxr->rx_prod = sw_prod;\r\nif (pg_ring_used)\r\nBNX2_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);\r\nBNX2_WR16(bp, rxr->rx_bidx_addr, sw_prod);\r\nBNX2_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);\r\nmmiowb();\r\nreturn rx_pkt;\r\n}\r\nstatic irqreturn_t\r\nbnx2_msi(int irq, void *dev_instance)\r\n{\r\nstruct bnx2_napi *bnapi = dev_instance;\r\nstruct bnx2 *bp = bnapi->bp;\r\nprefetch(bnapi->status_blk.msi);\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\r\nBNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\r\nif (unlikely(atomic_read(&bp->intr_sem) != 0))\r\nreturn IRQ_HANDLED;\r\nnapi_schedule(&bnapi->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nbnx2_msi_1shot(int irq, void *dev_instance)\r\n{\r\nstruct bnx2_napi *bnapi = dev_instance;\r\nstruct bnx2 *bp = bnapi->bp;\r\nprefetch(bnapi->status_blk.msi);\r\nif (unlikely(atomic_read(&bp->intr_sem) != 0))\r\nreturn IRQ_HANDLED;\r\nnapi_schedule(&bnapi->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nbnx2_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct bnx2_napi *bnapi = dev_instance;\r\nstruct bnx2 *bp = bnapi->bp;\r\nstruct status_block *sblk = bnapi->status_blk.msi;\r\nif ((sblk->status_idx == bnapi->last_status_idx) &&\r\n(BNX2_RD(bp, BNX2_PCICFG_MISC_STATUS) &\r\nBNX2_PCICFG_MISC_STATUS_INTA_VALUE))\r\nreturn IRQ_NONE;\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\r\nBNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\r\nBNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD);\r\nif (unlikely(atomic_read(&bp->intr_sem) != 0))\r\nreturn IRQ_HANDLED;\r\nif (napi_schedule_prep(&bnapi->napi)) {\r\nbnapi->last_status_idx = sblk->status_idx;\r\n__napi_schedule(&bnapi->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int\r\nbnx2_has_fast_work(struct bnx2_napi *bnapi)\r\n{\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nif ((bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons) ||\r\n(bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nbnx2_has_work(struct bnx2_napi *bnapi)\r\n{\r\nstruct status_block *sblk = bnapi->status_blk.msi;\r\nif (bnx2_has_fast_work(bnapi))\r\nreturn 1;\r\n#ifdef BCM_CNIC\r\nif (bnapi->cnic_present && (bnapi->cnic_tag != sblk->status_idx))\r\nreturn 1;\r\n#endif\r\nif ((sblk->status_attn_bits & STATUS_ATTN_EVENTS) !=\r\n(sblk->status_attn_bits_ack & STATUS_ATTN_EVENTS))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_chk_missed_msi(struct bnx2 *bp)\r\n{\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\r\nu32 msi_ctrl;\r\nif (bnx2_has_work(bnapi)) {\r\nmsi_ctrl = BNX2_RD(bp, BNX2_PCICFG_MSI_CONTROL);\r\nif (!(msi_ctrl & BNX2_PCICFG_MSI_CONTROL_ENABLE))\r\nreturn;\r\nif (bnapi->last_status_idx == bp->idle_chk_status_idx) {\r\nBNX2_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl &\r\n~BNX2_PCICFG_MSI_CONTROL_ENABLE);\r\nBNX2_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl);\r\nbnx2_msi(bp->irq_tbl[0].vector, bnapi);\r\n}\r\n}\r\nbp->idle_chk_status_idx = bnapi->last_status_idx;\r\n}\r\nstatic void bnx2_poll_cnic(struct bnx2 *bp, struct bnx2_napi *bnapi)\r\n{\r\nstruct cnic_ops *c_ops;\r\nif (!bnapi->cnic_present)\r\nreturn;\r\nrcu_read_lock();\r\nc_ops = rcu_dereference(bp->cnic_ops);\r\nif (c_ops)\r\nbnapi->cnic_tag = c_ops->cnic_handler(bp->cnic_data,\r\nbnapi->status_blk.msi);\r\nrcu_read_unlock();\r\n}\r\nstatic void bnx2_poll_link(struct bnx2 *bp, struct bnx2_napi *bnapi)\r\n{\r\nstruct status_block *sblk = bnapi->status_blk.msi;\r\nu32 status_attn_bits = sblk->status_attn_bits;\r\nu32 status_attn_bits_ack = sblk->status_attn_bits_ack;\r\nif ((status_attn_bits & STATUS_ATTN_EVENTS) !=\r\n(status_attn_bits_ack & STATUS_ATTN_EVENTS)) {\r\nbnx2_phy_int(bp, bnapi);\r\nBNX2_WR(bp, BNX2_HC_COMMAND,\r\nbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\r\nBNX2_RD(bp, BNX2_HC_COMMAND);\r\n}\r\n}\r\nstatic int bnx2_poll_work(struct bnx2 *bp, struct bnx2_napi *bnapi,\r\nint work_done, int budget)\r\n{\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nif (bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons)\r\nbnx2_tx_int(bp, bnapi, 0);\r\nif (bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons)\r\nwork_done += bnx2_rx_int(bp, bnapi, budget - work_done);\r\nreturn work_done;\r\n}\r\nstatic int bnx2_poll_msix(struct napi_struct *napi, int budget)\r\n{\r\nstruct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);\r\nstruct bnx2 *bp = bnapi->bp;\r\nint work_done = 0;\r\nstruct status_block_msix *sblk = bnapi->status_blk.msix;\r\nwhile (1) {\r\nwork_done = bnx2_poll_work(bp, bnapi, work_done, budget);\r\nif (unlikely(work_done >= budget))\r\nbreak;\r\nbnapi->last_status_idx = sblk->status_idx;\r\nrmb();\r\nif (likely(!bnx2_has_fast_work(bnapi))) {\r\nnapi_complete(napi);\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nbnapi->last_status_idx);\r\nbreak;\r\n}\r\n}\r\nreturn work_done;\r\n}\r\nstatic int bnx2_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);\r\nstruct bnx2 *bp = bnapi->bp;\r\nint work_done = 0;\r\nstruct status_block *sblk = bnapi->status_blk.msi;\r\nwhile (1) {\r\nbnx2_poll_link(bp, bnapi);\r\nwork_done = bnx2_poll_work(bp, bnapi, work_done, budget);\r\n#ifdef BCM_CNIC\r\nbnx2_poll_cnic(bp, bnapi);\r\n#endif\r\nbnapi->last_status_idx = sblk->status_idx;\r\nif (unlikely(work_done >= budget))\r\nbreak;\r\nrmb();\r\nif (likely(!bnx2_has_work(bnapi))) {\r\nnapi_complete(napi);\r\nif (likely(bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)) {\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nbnapi->last_status_idx);\r\nbreak;\r\n}\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT |\r\nbnapi->last_status_idx);\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\r\nbnapi->last_status_idx);\r\nbreak;\r\n}\r\n}\r\nreturn work_done;\r\n}\r\nstatic void\r\nbnx2_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nu32 rx_mode, sort_mode;\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nif (!netif_running(dev))\r\nreturn;\r\nspin_lock_bh(&bp->phy_lock);\r\nrx_mode = bp->rx_mode & ~(BNX2_EMAC_RX_MODE_PROMISCUOUS |\r\nBNX2_EMAC_RX_MODE_KEEP_VLAN_TAG);\r\nsort_mode = 1 | BNX2_RPM_SORT_USER0_BC_EN;\r\nif (!(dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\r\n(bp->flags & BNX2_FLAG_CAN_KEEP_VLAN))\r\nrx_mode |= BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;\r\nsort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |\r\nBNX2_RPM_SORT_USER0_PROM_VLAN;\r\n}\r\nelse if (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\r\nBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\r\n0xffffffff);\r\n}\r\nsort_mode |= BNX2_RPM_SORT_USER0_MC_EN;\r\n}\r\nelse {\r\nu32 mc_filter[NUM_MC_HASH_REGISTERS];\r\nu32 regidx;\r\nu32 bit;\r\nu32 crc;\r\nmemset(mc_filter, 0, 4 * NUM_MC_HASH_REGISTERS);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(ETH_ALEN, ha->addr);\r\nbit = crc & 0xff;\r\nregidx = (bit & 0xe0) >> 5;\r\nbit &= 0x1f;\r\nmc_filter[regidx] |= (1 << bit);\r\n}\r\nfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\r\nBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\r\nmc_filter[i]);\r\n}\r\nsort_mode |= BNX2_RPM_SORT_USER0_MC_HSH_EN;\r\n}\r\nif (netdev_uc_count(dev) > BNX2_MAX_UNICAST_ADDRESSES) {\r\nrx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;\r\nsort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |\r\nBNX2_RPM_SORT_USER0_PROM_VLAN;\r\n} else if (!(dev->flags & IFF_PROMISC)) {\r\ni = 0;\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nbnx2_set_mac_addr(bp, ha->addr,\r\ni + BNX2_START_UNICAST_ADDRESS_INDEX);\r\nsort_mode |= (1 <<\r\n(i + BNX2_START_UNICAST_ADDRESS_INDEX));\r\ni++;\r\n}\r\n}\r\nif (rx_mode != bp->rx_mode) {\r\nbp->rx_mode = rx_mode;\r\nBNX2_WR(bp, BNX2_EMAC_RX_MODE, rx_mode);\r\n}\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, 0x0);\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, sort_mode);\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, sort_mode | BNX2_RPM_SORT_USER0_ENA);\r\nspin_unlock_bh(&bp->phy_lock);\r\n}\r\nstatic int\r\ncheck_fw_section(const struct firmware *fw,\r\nconst struct bnx2_fw_file_section *section,\r\nu32 alignment, bool non_empty)\r\n{\r\nu32 offset = be32_to_cpu(section->offset);\r\nu32 len = be32_to_cpu(section->len);\r\nif ((offset == 0 && len != 0) || offset >= fw->size || offset & 3)\r\nreturn -EINVAL;\r\nif ((non_empty && len == 0) || len > fw->size - offset ||\r\nlen & (alignment - 1))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_mips_fw_entry(const struct firmware *fw,\r\nconst struct bnx2_mips_fw_file_entry *entry)\r\n{\r\nif (check_fw_section(fw, &entry->text, 4, true) ||\r\ncheck_fw_section(fw, &entry->data, 4, false) ||\r\ncheck_fw_section(fw, &entry->rodata, 4, false))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void bnx2_release_firmware(struct bnx2 *bp)\r\n{\r\nif (bp->rv2p_firmware) {\r\nrelease_firmware(bp->mips_firmware);\r\nrelease_firmware(bp->rv2p_firmware);\r\nbp->rv2p_firmware = NULL;\r\n}\r\n}\r\nstatic int bnx2_request_uncached_firmware(struct bnx2 *bp)\r\n{\r\nconst char *mips_fw_file, *rv2p_fw_file;\r\nconst struct bnx2_mips_fw_file *mips_fw;\r\nconst struct bnx2_rv2p_fw_file *rv2p_fw;\r\nint rc;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nmips_fw_file = FW_MIPS_FILE_09;\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5709_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5709_A1))\r\nrv2p_fw_file = FW_RV2P_FILE_09_Ax;\r\nelse\r\nrv2p_fw_file = FW_RV2P_FILE_09;\r\n} else {\r\nmips_fw_file = FW_MIPS_FILE_06;\r\nrv2p_fw_file = FW_RV2P_FILE_06;\r\n}\r\nrc = request_firmware(&bp->mips_firmware, mips_fw_file, &bp->pdev->dev);\r\nif (rc) {\r\npr_err("Can't load firmware file \"%s\"\n", mips_fw_file);\r\ngoto out;\r\n}\r\nrc = request_firmware(&bp->rv2p_firmware, rv2p_fw_file, &bp->pdev->dev);\r\nif (rc) {\r\npr_err("Can't load firmware file \"%s\"\n", rv2p_fw_file);\r\ngoto err_release_mips_firmware;\r\n}\r\nmips_fw = (const struct bnx2_mips_fw_file *) bp->mips_firmware->data;\r\nrv2p_fw = (const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;\r\nif (bp->mips_firmware->size < sizeof(*mips_fw) ||\r\ncheck_mips_fw_entry(bp->mips_firmware, &mips_fw->com) ||\r\ncheck_mips_fw_entry(bp->mips_firmware, &mips_fw->cp) ||\r\ncheck_mips_fw_entry(bp->mips_firmware, &mips_fw->rxp) ||\r\ncheck_mips_fw_entry(bp->mips_firmware, &mips_fw->tpat) ||\r\ncheck_mips_fw_entry(bp->mips_firmware, &mips_fw->txp)) {\r\npr_err("Firmware file \"%s\" is invalid\n", mips_fw_file);\r\nrc = -EINVAL;\r\ngoto err_release_firmware;\r\n}\r\nif (bp->rv2p_firmware->size < sizeof(*rv2p_fw) ||\r\ncheck_fw_section(bp->rv2p_firmware, &rv2p_fw->proc1.rv2p, 8, true) ||\r\ncheck_fw_section(bp->rv2p_firmware, &rv2p_fw->proc2.rv2p, 8, true)) {\r\npr_err("Firmware file \"%s\" is invalid\n", rv2p_fw_file);\r\nrc = -EINVAL;\r\ngoto err_release_firmware;\r\n}\r\nout:\r\nreturn rc;\r\nerr_release_firmware:\r\nrelease_firmware(bp->rv2p_firmware);\r\nbp->rv2p_firmware = NULL;\r\nerr_release_mips_firmware:\r\nrelease_firmware(bp->mips_firmware);\r\ngoto out;\r\n}\r\nstatic int bnx2_request_firmware(struct bnx2 *bp)\r\n{\r\nreturn bp->rv2p_firmware ? 0 : bnx2_request_uncached_firmware(bp);\r\n}\r\nstatic u32\r\nrv2p_fw_fixup(u32 rv2p_proc, int idx, u32 loc, u32 rv2p_code)\r\n{\r\nswitch (idx) {\r\ncase RV2P_P1_FIXUP_PAGE_SIZE_IDX:\r\nrv2p_code &= ~RV2P_BD_PAGE_SIZE_MSK;\r\nrv2p_code |= RV2P_BD_PAGE_SIZE;\r\nbreak;\r\n}\r\nreturn rv2p_code;\r\n}\r\nstatic int\r\nload_rv2p_fw(struct bnx2 *bp, u32 rv2p_proc,\r\nconst struct bnx2_rv2p_fw_file_entry *fw_entry)\r\n{\r\nu32 rv2p_code_len, file_offset;\r\n__be32 *rv2p_code;\r\nint i;\r\nu32 val, cmd, addr;\r\nrv2p_code_len = be32_to_cpu(fw_entry->rv2p.len);\r\nfile_offset = be32_to_cpu(fw_entry->rv2p.offset);\r\nrv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);\r\nif (rv2p_proc == RV2P_PROC1) {\r\ncmd = BNX2_RV2P_PROC1_ADDR_CMD_RDWR;\r\naddr = BNX2_RV2P_PROC1_ADDR_CMD;\r\n} else {\r\ncmd = BNX2_RV2P_PROC2_ADDR_CMD_RDWR;\r\naddr = BNX2_RV2P_PROC2_ADDR_CMD;\r\n}\r\nfor (i = 0; i < rv2p_code_len; i += 8) {\r\nBNX2_WR(bp, BNX2_RV2P_INSTR_HIGH, be32_to_cpu(*rv2p_code));\r\nrv2p_code++;\r\nBNX2_WR(bp, BNX2_RV2P_INSTR_LOW, be32_to_cpu(*rv2p_code));\r\nrv2p_code++;\r\nval = (i / 8) | cmd;\r\nBNX2_WR(bp, addr, val);\r\n}\r\nrv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);\r\nfor (i = 0; i < 8; i++) {\r\nu32 loc, code;\r\nloc = be32_to_cpu(fw_entry->fixup[i]);\r\nif (loc && ((loc * 4) < rv2p_code_len)) {\r\ncode = be32_to_cpu(*(rv2p_code + loc - 1));\r\nBNX2_WR(bp, BNX2_RV2P_INSTR_HIGH, code);\r\ncode = be32_to_cpu(*(rv2p_code + loc));\r\ncode = rv2p_fw_fixup(rv2p_proc, i, loc, code);\r\nBNX2_WR(bp, BNX2_RV2P_INSTR_LOW, code);\r\nval = (loc / 2) | cmd;\r\nBNX2_WR(bp, addr, val);\r\n}\r\n}\r\nif (rv2p_proc == RV2P_PROC1) {\r\nBNX2_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC1_RESET);\r\n}\r\nelse {\r\nBNX2_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC2_RESET);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nload_cpu_fw(struct bnx2 *bp, const struct cpu_reg *cpu_reg,\r\nconst struct bnx2_mips_fw_file_entry *fw_entry)\r\n{\r\nu32 addr, len, file_offset;\r\n__be32 *data;\r\nu32 offset;\r\nu32 val;\r\nval = bnx2_reg_rd_ind(bp, cpu_reg->mode);\r\nval |= cpu_reg->mode_value_halt;\r\nbnx2_reg_wr_ind(bp, cpu_reg->mode, val);\r\nbnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);\r\naddr = be32_to_cpu(fw_entry->text.addr);\r\nlen = be32_to_cpu(fw_entry->text.len);\r\nfile_offset = be32_to_cpu(fw_entry->text.offset);\r\ndata = (__be32 *)(bp->mips_firmware->data + file_offset);\r\noffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\r\nif (len) {\r\nint j;\r\nfor (j = 0; j < (len / 4); j++, offset += 4)\r\nbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\r\n}\r\naddr = be32_to_cpu(fw_entry->data.addr);\r\nlen = be32_to_cpu(fw_entry->data.len);\r\nfile_offset = be32_to_cpu(fw_entry->data.offset);\r\ndata = (__be32 *)(bp->mips_firmware->data + file_offset);\r\noffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\r\nif (len) {\r\nint j;\r\nfor (j = 0; j < (len / 4); j++, offset += 4)\r\nbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\r\n}\r\naddr = be32_to_cpu(fw_entry->rodata.addr);\r\nlen = be32_to_cpu(fw_entry->rodata.len);\r\nfile_offset = be32_to_cpu(fw_entry->rodata.offset);\r\ndata = (__be32 *)(bp->mips_firmware->data + file_offset);\r\noffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\r\nif (len) {\r\nint j;\r\nfor (j = 0; j < (len / 4); j++, offset += 4)\r\nbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\r\n}\r\nbnx2_reg_wr_ind(bp, cpu_reg->inst, 0);\r\nval = be32_to_cpu(fw_entry->start_addr);\r\nbnx2_reg_wr_ind(bp, cpu_reg->pc, val);\r\nval = bnx2_reg_rd_ind(bp, cpu_reg->mode);\r\nval &= ~cpu_reg->mode_value_halt;\r\nbnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);\r\nbnx2_reg_wr_ind(bp, cpu_reg->mode, val);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_cpus(struct bnx2 *bp)\r\n{\r\nconst struct bnx2_mips_fw_file *mips_fw =\r\n(const struct bnx2_mips_fw_file *) bp->mips_firmware->data;\r\nconst struct bnx2_rv2p_fw_file *rv2p_fw =\r\n(const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;\r\nint rc;\r\nload_rv2p_fw(bp, RV2P_PROC1, &rv2p_fw->proc1);\r\nload_rv2p_fw(bp, RV2P_PROC2, &rv2p_fw->proc2);\r\nrc = load_cpu_fw(bp, &cpu_reg_rxp, &mips_fw->rxp);\r\nif (rc)\r\ngoto init_cpu_err;\r\nrc = load_cpu_fw(bp, &cpu_reg_txp, &mips_fw->txp);\r\nif (rc)\r\ngoto init_cpu_err;\r\nrc = load_cpu_fw(bp, &cpu_reg_tpat, &mips_fw->tpat);\r\nif (rc)\r\ngoto init_cpu_err;\r\nrc = load_cpu_fw(bp, &cpu_reg_com, &mips_fw->com);\r\nif (rc)\r\ngoto init_cpu_err;\r\nrc = load_cpu_fw(bp, &cpu_reg_cp, &mips_fw->cp);\r\ninit_cpu_err:\r\nreturn rc;\r\n}\r\nstatic void\r\nbnx2_setup_wol(struct bnx2 *bp)\r\n{\r\nint i;\r\nu32 val, wol_msg;\r\nif (bp->wol) {\r\nu32 advertising;\r\nu8 autoneg;\r\nautoneg = bp->autoneg;\r\nadvertising = bp->advertising;\r\nif (bp->phy_port == PORT_TP) {\r\nbp->autoneg = AUTONEG_SPEED;\r\nbp->advertising = ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_Autoneg;\r\n}\r\nspin_lock_bh(&bp->phy_lock);\r\nbnx2_setup_phy(bp, bp->phy_port);\r\nspin_unlock_bh(&bp->phy_lock);\r\nbp->autoneg = autoneg;\r\nbp->advertising = advertising;\r\nbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\r\nval = BNX2_RD(bp, BNX2_EMAC_MODE);\r\nval &= ~BNX2_EMAC_MODE_PORT;\r\nval |= BNX2_EMAC_MODE_MPKT_RCVD |\r\nBNX2_EMAC_MODE_ACPI_RCVD |\r\nBNX2_EMAC_MODE_MPKT;\r\nif (bp->phy_port == PORT_TP) {\r\nval |= BNX2_EMAC_MODE_PORT_MII;\r\n} else {\r\nval |= BNX2_EMAC_MODE_PORT_GMII;\r\nif (bp->line_speed == SPEED_2500)\r\nval |= BNX2_EMAC_MODE_25G_MODE;\r\n}\r\nBNX2_WR(bp, BNX2_EMAC_MODE, val);\r\nfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\r\nBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\r\n0xffffffff);\r\n}\r\nBNX2_WR(bp, BNX2_EMAC_RX_MODE, BNX2_EMAC_RX_MODE_SORT_MODE);\r\nval = 1 | BNX2_RPM_SORT_USER0_BC_EN | BNX2_RPM_SORT_USER0_MC_EN;\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, 0x0);\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, val);\r\nBNX2_WR(bp, BNX2_RPM_SORT_USER0, val | BNX2_RPM_SORT_USER0_ENA);\r\nBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\r\nBNX2_MISC_ENABLE_SET_BITS_RX_PARSER_MAC_ENABLE |\r\nBNX2_MISC_ENABLE_SET_BITS_TX_HEADER_Q_ENABLE |\r\nBNX2_MISC_ENABLE_SET_BITS_EMAC_ENABLE);\r\nval = BNX2_RD(bp, BNX2_RPM_CONFIG);\r\nval &= ~BNX2_RPM_CONFIG_ACPI_ENA;\r\nBNX2_WR(bp, BNX2_RPM_CONFIG, val);\r\nwol_msg = BNX2_DRV_MSG_CODE_SUSPEND_WOL;\r\n} else {\r\nwol_msg = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;\r\n}\r\nif (!(bp->flags & BNX2_FLAG_NO_WOL)) {\r\nu32 val;\r\nwol_msg |= BNX2_DRV_MSG_DATA_WAIT3;\r\nif (bp->fw_last_msg || BNX2_CHIP(bp) != BNX2_CHIP_5709) {\r\nbnx2_fw_sync(bp, wol_msg, 1, 0);\r\nreturn;\r\n}\r\nval = bnx2_shmem_rd(bp, BNX2_PORT_FEATURE);\r\nbnx2_shmem_wr(bp, BNX2_PORT_FEATURE,\r\nval | BNX2_PORT_FEATURE_ASF_ENABLED);\r\nbnx2_fw_sync(bp, wol_msg, 1, 0);\r\nbnx2_shmem_wr(bp, BNX2_PORT_FEATURE, val);\r\n}\r\n}\r\nstatic int\r\nbnx2_set_power_state(struct bnx2 *bp, pci_power_t state)\r\n{\r\nswitch (state) {\r\ncase PCI_D0: {\r\nu32 val;\r\npci_enable_wake(bp->pdev, PCI_D0, false);\r\npci_set_power_state(bp->pdev, PCI_D0);\r\nval = BNX2_RD(bp, BNX2_EMAC_MODE);\r\nval |= BNX2_EMAC_MODE_MPKT_RCVD | BNX2_EMAC_MODE_ACPI_RCVD;\r\nval &= ~BNX2_EMAC_MODE_MPKT;\r\nBNX2_WR(bp, BNX2_EMAC_MODE, val);\r\nval = BNX2_RD(bp, BNX2_RPM_CONFIG);\r\nval &= ~BNX2_RPM_CONFIG_ACPI_ENA;\r\nBNX2_WR(bp, BNX2_RPM_CONFIG, val);\r\nbreak;\r\n}\r\ncase PCI_D3hot: {\r\nbnx2_setup_wol(bp);\r\npci_wake_from_d3(bp->pdev, bp->wol);\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1)) {\r\nif (bp->wol)\r\npci_set_power_state(bp->pdev, PCI_D3hot);\r\nbreak;\r\n}\r\nif (!bp->fw_last_msg && BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nu32 val;\r\nval = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\r\nval &= ~BNX2_CONDITION_PM_STATE_MASK;\r\nval |= BNX2_CONDITION_PM_STATE_UNPREP;\r\nbnx2_shmem_wr(bp, BNX2_BC_STATE_CONDITION, val);\r\n}\r\npci_set_power_state(bp->pdev, PCI_D3hot);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_acquire_nvram_lock(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nint j;\r\nBNX2_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_SET2);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nval = BNX2_RD(bp, BNX2_NVM_SW_ARB);\r\nif (val & BNX2_NVM_SW_ARB_ARB_ARB2)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_release_nvram_lock(struct bnx2 *bp)\r\n{\r\nint j;\r\nu32 val;\r\nBNX2_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_CLR2);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nval = BNX2_RD(bp, BNX2_NVM_SW_ARB);\r\nif (!(val & BNX2_NVM_SW_ARB_ARB_ARB2))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_enable_nvram_write(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nval = BNX2_RD(bp, BNX2_MISC_CFG);\r\nBNX2_WR(bp, BNX2_MISC_CFG, val | BNX2_MISC_CFG_NVM_WR_EN_PCI);\r\nif (bp->flash_info->flags & BNX2_NV_WREN) {\r\nint j;\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\r\nBNX2_WR(bp, BNX2_NVM_COMMAND,\r\nBNX2_NVM_COMMAND_WREN | BNX2_NVM_COMMAND_DOIT);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nudelay(5);\r\nval = BNX2_RD(bp, BNX2_NVM_COMMAND);\r\nif (val & BNX2_NVM_COMMAND_DONE)\r\nbreak;\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_disable_nvram_write(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nval = BNX2_RD(bp, BNX2_MISC_CFG);\r\nBNX2_WR(bp, BNX2_MISC_CFG, val & ~BNX2_MISC_CFG_NVM_WR_EN);\r\n}\r\nstatic void\r\nbnx2_enable_nvram_access(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nval = BNX2_RD(bp, BNX2_NVM_ACCESS_ENABLE);\r\nBNX2_WR(bp, BNX2_NVM_ACCESS_ENABLE,\r\nval | BNX2_NVM_ACCESS_ENABLE_EN | BNX2_NVM_ACCESS_ENABLE_WR_EN);\r\n}\r\nstatic void\r\nbnx2_disable_nvram_access(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nval = BNX2_RD(bp, BNX2_NVM_ACCESS_ENABLE);\r\nBNX2_WR(bp, BNX2_NVM_ACCESS_ENABLE,\r\nval & ~(BNX2_NVM_ACCESS_ENABLE_EN |\r\nBNX2_NVM_ACCESS_ENABLE_WR_EN));\r\n}\r\nstatic int\r\nbnx2_nvram_erase_page(struct bnx2 *bp, u32 offset)\r\n{\r\nu32 cmd;\r\nint j;\r\nif (bp->flash_info->flags & BNX2_NV_BUFFERED)\r\nreturn 0;\r\ncmd = BNX2_NVM_COMMAND_ERASE | BNX2_NVM_COMMAND_WR |\r\nBNX2_NVM_COMMAND_DOIT;\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\r\nBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nu32 val;\r\nudelay(5);\r\nval = BNX2_RD(bp, BNX2_NVM_COMMAND);\r\nif (val & BNX2_NVM_COMMAND_DONE)\r\nbreak;\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_nvram_read_dword(struct bnx2 *bp, u32 offset, u8 *ret_val, u32 cmd_flags)\r\n{\r\nu32 cmd;\r\nint j;\r\ncmd = BNX2_NVM_COMMAND_DOIT | cmd_flags;\r\nif (bp->flash_info->flags & BNX2_NV_TRANSLATE) {\r\noffset = ((offset / bp->flash_info->page_size) <<\r\nbp->flash_info->page_bits) +\r\n(offset % bp->flash_info->page_size);\r\n}\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\r\nBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nu32 val;\r\nudelay(5);\r\nval = BNX2_RD(bp, BNX2_NVM_COMMAND);\r\nif (val & BNX2_NVM_COMMAND_DONE) {\r\n__be32 v = cpu_to_be32(BNX2_RD(bp, BNX2_NVM_READ));\r\nmemcpy(ret_val, &v, 4);\r\nbreak;\r\n}\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_nvram_write_dword(struct bnx2 *bp, u32 offset, u8 *val, u32 cmd_flags)\r\n{\r\nu32 cmd;\r\n__be32 val32;\r\nint j;\r\ncmd = BNX2_NVM_COMMAND_DOIT | BNX2_NVM_COMMAND_WR | cmd_flags;\r\nif (bp->flash_info->flags & BNX2_NV_TRANSLATE) {\r\noffset = ((offset / bp->flash_info->page_size) <<\r\nbp->flash_info->page_bits) +\r\n(offset % bp->flash_info->page_size);\r\n}\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\r\nmemcpy(&val32, val, 4);\r\nBNX2_WR(bp, BNX2_NVM_WRITE, be32_to_cpu(val32));\r\nBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\r\nBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\r\nfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\r\nudelay(5);\r\nif (BNX2_RD(bp, BNX2_NVM_COMMAND) & BNX2_NVM_COMMAND_DONE)\r\nbreak;\r\n}\r\nif (j >= NVRAM_TIMEOUT_COUNT)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_nvram(struct bnx2 *bp)\r\n{\r\nu32 val;\r\nint j, entry_count, rc = 0;\r\nconst struct flash_spec *flash;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nbp->flash_info = &flash_5709;\r\ngoto get_flash_size;\r\n}\r\nval = BNX2_RD(bp, BNX2_NVM_CFG1);\r\nentry_count = ARRAY_SIZE(flash_table);\r\nif (val & 0x40000000) {\r\nfor (j = 0, flash = &flash_table[0]; j < entry_count;\r\nj++, flash++) {\r\nif ((val & FLASH_BACKUP_STRAP_MASK) ==\r\n(flash->config1 & FLASH_BACKUP_STRAP_MASK)) {\r\nbp->flash_info = flash;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse {\r\nu32 mask;\r\nif (val & (1 << 23))\r\nmask = FLASH_BACKUP_STRAP_MASK;\r\nelse\r\nmask = FLASH_STRAP_MASK;\r\nfor (j = 0, flash = &flash_table[0]; j < entry_count;\r\nj++, flash++) {\r\nif ((val & mask) == (flash->strapping & mask)) {\r\nbp->flash_info = flash;\r\nif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\r\nreturn rc;\r\nbnx2_enable_nvram_access(bp);\r\nBNX2_WR(bp, BNX2_NVM_CFG1, flash->config1);\r\nBNX2_WR(bp, BNX2_NVM_CFG2, flash->config2);\r\nBNX2_WR(bp, BNX2_NVM_CFG3, flash->config3);\r\nBNX2_WR(bp, BNX2_NVM_WRITE1, flash->write1);\r\nbnx2_disable_nvram_access(bp);\r\nbnx2_release_nvram_lock(bp);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (j == entry_count) {\r\nbp->flash_info = NULL;\r\npr_alert("Unknown flash/EEPROM type\n");\r\nreturn -ENODEV;\r\n}\r\nget_flash_size:\r\nval = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG2);\r\nval &= BNX2_SHARED_HW_CFG2_NVM_SIZE_MASK;\r\nif (val)\r\nbp->flash_size = val;\r\nelse\r\nbp->flash_size = bp->flash_info->total_size;\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_nvram_read(struct bnx2 *bp, u32 offset, u8 *ret_buf,\r\nint buf_size)\r\n{\r\nint rc = 0;\r\nu32 cmd_flags, offset32, len32, extra;\r\nif (buf_size == 0)\r\nreturn 0;\r\nif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\r\nreturn rc;\r\nbnx2_enable_nvram_access(bp);\r\nlen32 = buf_size;\r\noffset32 = offset;\r\nextra = 0;\r\ncmd_flags = 0;\r\nif (offset32 & 3) {\r\nu8 buf[4];\r\nu32 pre_len;\r\noffset32 &= ~3;\r\npre_len = 4 - (offset & 3);\r\nif (pre_len >= len32) {\r\npre_len = len32;\r\ncmd_flags = BNX2_NVM_COMMAND_FIRST |\r\nBNX2_NVM_COMMAND_LAST;\r\n}\r\nelse {\r\ncmd_flags = BNX2_NVM_COMMAND_FIRST;\r\n}\r\nrc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(ret_buf, buf + (offset & 3), pre_len);\r\noffset32 += 4;\r\nret_buf += pre_len;\r\nlen32 -= pre_len;\r\n}\r\nif (len32 & 3) {\r\nextra = 4 - (len32 & 3);\r\nlen32 = (len32 + 4) & ~3;\r\n}\r\nif (len32 == 4) {\r\nu8 buf[4];\r\nif (cmd_flags)\r\ncmd_flags = BNX2_NVM_COMMAND_LAST;\r\nelse\r\ncmd_flags = BNX2_NVM_COMMAND_FIRST |\r\nBNX2_NVM_COMMAND_LAST;\r\nrc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\r\nmemcpy(ret_buf, buf, 4 - extra);\r\n}\r\nelse if (len32 > 0) {\r\nu8 buf[4];\r\nif (cmd_flags)\r\ncmd_flags = 0;\r\nelse\r\ncmd_flags = BNX2_NVM_COMMAND_FIRST;\r\nrc = bnx2_nvram_read_dword(bp, offset32, ret_buf, cmd_flags);\r\noffset32 += 4;\r\nret_buf += 4;\r\nlen32 -= 4;\r\nwhile (len32 > 4 && rc == 0) {\r\nrc = bnx2_nvram_read_dword(bp, offset32, ret_buf, 0);\r\noffset32 += 4;\r\nret_buf += 4;\r\nlen32 -= 4;\r\n}\r\nif (rc)\r\nreturn rc;\r\ncmd_flags = BNX2_NVM_COMMAND_LAST;\r\nrc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\r\nmemcpy(ret_buf, buf, 4 - extra);\r\n}\r\nbnx2_disable_nvram_access(bp);\r\nbnx2_release_nvram_lock(bp);\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_nvram_write(struct bnx2 *bp, u32 offset, u8 *data_buf,\r\nint buf_size)\r\n{\r\nu32 written, offset32, len32;\r\nu8 *buf, start[4], end[4], *align_buf = NULL, *flash_buffer = NULL;\r\nint rc = 0;\r\nint align_start, align_end;\r\nbuf = data_buf;\r\noffset32 = offset;\r\nlen32 = buf_size;\r\nalign_start = align_end = 0;\r\nif ((align_start = (offset32 & 3))) {\r\noffset32 &= ~3;\r\nlen32 += align_start;\r\nif (len32 < 4)\r\nlen32 = 4;\r\nif ((rc = bnx2_nvram_read(bp, offset32, start, 4)))\r\nreturn rc;\r\n}\r\nif (len32 & 3) {\r\nalign_end = 4 - (len32 & 3);\r\nlen32 += align_end;\r\nif ((rc = bnx2_nvram_read(bp, offset32 + len32 - 4, end, 4)))\r\nreturn rc;\r\n}\r\nif (align_start || align_end) {\r\nalign_buf = kmalloc(len32, GFP_KERNEL);\r\nif (align_buf == NULL)\r\nreturn -ENOMEM;\r\nif (align_start) {\r\nmemcpy(align_buf, start, 4);\r\n}\r\nif (align_end) {\r\nmemcpy(align_buf + len32 - 4, end, 4);\r\n}\r\nmemcpy(align_buf + align_start, data_buf, buf_size);\r\nbuf = align_buf;\r\n}\r\nif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\r\nflash_buffer = kmalloc(264, GFP_KERNEL);\r\nif (flash_buffer == NULL) {\r\nrc = -ENOMEM;\r\ngoto nvram_write_end;\r\n}\r\n}\r\nwritten = 0;\r\nwhile ((written < len32) && (rc == 0)) {\r\nu32 page_start, page_end, data_start, data_end;\r\nu32 addr, cmd_flags;\r\nint i;\r\npage_start = offset32 + written;\r\npage_start -= (page_start % bp->flash_info->page_size);\r\npage_end = page_start + bp->flash_info->page_size;\r\ndata_start = (written == 0) ? offset32 : page_start;\r\ndata_end = (page_end > offset32 + len32) ?\r\n(offset32 + len32) : page_end;\r\nif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\r\ngoto nvram_write_end;\r\nbnx2_enable_nvram_access(bp);\r\ncmd_flags = BNX2_NVM_COMMAND_FIRST;\r\nif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\r\nint j;\r\nfor (j = 0; j < bp->flash_info->page_size; j += 4) {\r\nif (j == (bp->flash_info->page_size - 4)) {\r\ncmd_flags |= BNX2_NVM_COMMAND_LAST;\r\n}\r\nrc = bnx2_nvram_read_dword(bp,\r\npage_start + j,\r\n&flash_buffer[j],\r\ncmd_flags);\r\nif (rc)\r\ngoto nvram_write_end;\r\ncmd_flags = 0;\r\n}\r\n}\r\nif ((rc = bnx2_enable_nvram_write(bp)) != 0)\r\ngoto nvram_write_end;\r\ni = 0;\r\nif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\r\nif ((rc = bnx2_nvram_erase_page(bp, page_start)) != 0)\r\ngoto nvram_write_end;\r\nbnx2_enable_nvram_write(bp);\r\nfor (addr = page_start; addr < data_start;\r\naddr += 4, i += 4) {\r\nrc = bnx2_nvram_write_dword(bp, addr,\r\n&flash_buffer[i], cmd_flags);\r\nif (rc != 0)\r\ngoto nvram_write_end;\r\ncmd_flags = 0;\r\n}\r\n}\r\nfor (addr = data_start; addr < data_end; addr += 4, i += 4) {\r\nif ((addr == page_end - 4) ||\r\n((bp->flash_info->flags & BNX2_NV_BUFFERED) &&\r\n(addr == data_end - 4))) {\r\ncmd_flags |= BNX2_NVM_COMMAND_LAST;\r\n}\r\nrc = bnx2_nvram_write_dword(bp, addr, buf,\r\ncmd_flags);\r\nif (rc != 0)\r\ngoto nvram_write_end;\r\ncmd_flags = 0;\r\nbuf += 4;\r\n}\r\nif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\r\nfor (addr = data_end; addr < page_end;\r\naddr += 4, i += 4) {\r\nif (addr == page_end-4) {\r\ncmd_flags = BNX2_NVM_COMMAND_LAST;\r\n}\r\nrc = bnx2_nvram_write_dword(bp, addr,\r\n&flash_buffer[i], cmd_flags);\r\nif (rc != 0)\r\ngoto nvram_write_end;\r\ncmd_flags = 0;\r\n}\r\n}\r\nbnx2_disable_nvram_write(bp);\r\nbnx2_disable_nvram_access(bp);\r\nbnx2_release_nvram_lock(bp);\r\nwritten += data_end - data_start;\r\n}\r\nnvram_write_end:\r\nkfree(flash_buffer);\r\nkfree(align_buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nbnx2_init_fw_cap(struct bnx2 *bp)\r\n{\r\nu32 val, sig = 0;\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_REMOTE_PHY_CAP;\r\nbp->flags &= ~BNX2_FLAG_CAN_KEEP_VLAN;\r\nif (!(bp->flags & BNX2_FLAG_ASF_ENABLE))\r\nbp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;\r\nval = bnx2_shmem_rd(bp, BNX2_FW_CAP_MB);\r\nif ((val & BNX2_FW_CAP_SIGNATURE_MASK) != BNX2_FW_CAP_SIGNATURE)\r\nreturn;\r\nif ((val & BNX2_FW_CAP_CAN_KEEP_VLAN) == BNX2_FW_CAP_CAN_KEEP_VLAN) {\r\nbp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;\r\nsig |= BNX2_DRV_ACK_CAP_SIGNATURE | BNX2_FW_CAP_CAN_KEEP_VLAN;\r\n}\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\r\n(val & BNX2_FW_CAP_REMOTE_PHY_CAPABLE)) {\r\nu32 link;\r\nbp->phy_flags |= BNX2_PHY_FLAG_REMOTE_PHY_CAP;\r\nlink = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);\r\nif (link & BNX2_LINK_STATUS_SERDES_LINK)\r\nbp->phy_port = PORT_FIBRE;\r\nelse\r\nbp->phy_port = PORT_TP;\r\nsig |= BNX2_DRV_ACK_CAP_SIGNATURE |\r\nBNX2_FW_CAP_REMOTE_PHY_CAPABLE;\r\n}\r\nif (netif_running(bp->dev) && sig)\r\nbnx2_shmem_wr(bp, BNX2_DRV_ACK_CAP_MB, sig);\r\n}\r\nstatic void\r\nbnx2_setup_msix_tbl(struct bnx2 *bp)\r\n{\r\nBNX2_WR(bp, BNX2_PCI_GRC_WINDOW_ADDR, BNX2_PCI_GRC_WINDOW_ADDR_SEP_WIN);\r\nBNX2_WR(bp, BNX2_PCI_GRC_WINDOW2_ADDR, BNX2_MSIX_TABLE_ADDR);\r\nBNX2_WR(bp, BNX2_PCI_GRC_WINDOW3_ADDR, BNX2_MSIX_PBA_ADDR);\r\n}\r\nstatic int\r\nbnx2_reset_chip(struct bnx2 *bp, u32 reset_code)\r\n{\r\nu32 val;\r\nint i, rc = 0;\r\nu8 old_port;\r\nif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) ||\r\n(BNX2_CHIP(bp) == BNX2_CHIP_5708)) {\r\nBNX2_WR(bp, BNX2_MISC_ENABLE_CLR_BITS,\r\nBNX2_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE |\r\nBNX2_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE |\r\nBNX2_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE |\r\nBNX2_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE);\r\nval = BNX2_RD(bp, BNX2_MISC_ENABLE_CLR_BITS);\r\nudelay(5);\r\n} else {\r\nval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\r\nval &= ~BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE;\r\nBNX2_WR(bp, BNX2_MISC_NEW_CORE_CTL, val);\r\nval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\r\nfor (i = 0; i < 100; i++) {\r\nmsleep(1);\r\nval = BNX2_RD(bp, BNX2_PCICFG_DEVICE_CONTROL);\r\nif (!(val & BNX2_PCICFG_DEVICE_STATUS_NO_PEND))\r\nbreak;\r\n}\r\n}\r\nbnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT0 | reset_code, 1, 1);\r\nbnx2_shmem_wr(bp, BNX2_DRV_RESET_SIGNATURE,\r\nBNX2_DRV_RESET_SIGNATURE_MAGIC);\r\nval = BNX2_RD(bp, BNX2_MISC_ID);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nBNX2_WR(bp, BNX2_MISC_COMMAND, BNX2_MISC_COMMAND_SW_RESET);\r\nBNX2_RD(bp, BNX2_MISC_COMMAND);\r\nudelay(5);\r\nval = BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\r\nBNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;\r\nBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG, val);\r\n} else {\r\nval = BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\r\nBNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\r\nBNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;\r\nBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG, val);\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1))\r\nmsleep(20);\r\nfor (i = 0; i < 10; i++) {\r\nval = BNX2_RD(bp, BNX2_PCICFG_MISC_CONFIG);\r\nif ((val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\r\nBNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\r\nBNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) {\r\npr_err("Chip reset did not complete\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nval = BNX2_RD(bp, BNX2_PCI_SWAP_DIAG0);\r\nif (val != 0x01020304) {\r\npr_err("Chip not in correct endian mode\n");\r\nreturn -ENODEV;\r\n}\r\nrc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT1 | reset_code, 1, 0);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_bh(&bp->phy_lock);\r\nold_port = bp->phy_port;\r\nbnx2_init_fw_cap(bp);\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) &&\r\nold_port != bp->phy_port)\r\nbnx2_set_default_remote_link(bp);\r\nspin_unlock_bh(&bp->phy_lock);\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\r\nBNX2_WR(bp, BNX2_MISC_VREG_CONTROL, 0x000000fa);\r\nrc = bnx2_alloc_bad_rbuf(bp);\r\n}\r\nif (bp->flags & BNX2_FLAG_USING_MSIX) {\r\nbnx2_setup_msix_tbl(bp);\r\nBNX2_WR(bp, BNX2_MISC_ECO_HW_CTL,\r\nBNX2_MISC_ECO_HW_CTL_LARGE_GRC_TMOUT_EN);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_init_chip(struct bnx2 *bp)\r\n{\r\nu32 val, mtu;\r\nint rc, i;\r\nBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, BNX2_PCICFG_INT_ACK_CMD_MASK_INT);\r\nval = BNX2_DMA_CONFIG_DATA_BYTE_SWAP |\r\nBNX2_DMA_CONFIG_DATA_WORD_SWAP |\r\n#ifdef __BIG_ENDIAN\r\nBNX2_DMA_CONFIG_CNTL_BYTE_SWAP |\r\n#endif\r\nBNX2_DMA_CONFIG_CNTL_WORD_SWAP |\r\nDMA_READ_CHANS << 12 |\r\nDMA_WRITE_CHANS << 16;\r\nval |= (0x2 << 20) | (1 << 11);\r\nif ((bp->flags & BNX2_FLAG_PCIX) && (bp->bus_speed_mhz == 133))\r\nval |= (1 << 23);\r\nif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) &&\r\n(BNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A0) &&\r\n!(bp->flags & BNX2_FLAG_PCIX))\r\nval |= BNX2_DMA_CONFIG_CNTL_PING_PONG_DMA;\r\nBNX2_WR(bp, BNX2_DMA_CONFIG, val);\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\r\nval = BNX2_RD(bp, BNX2_TDMA_CONFIG);\r\nval |= BNX2_TDMA_CONFIG_ONE_DMA;\r\nBNX2_WR(bp, BNX2_TDMA_CONFIG, val);\r\n}\r\nif (bp->flags & BNX2_FLAG_PCIX) {\r\nu16 val16;\r\npci_read_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,\r\n&val16);\r\npci_write_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,\r\nval16 & ~PCI_X_CMD_ERO);\r\n}\r\nBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\r\nBNX2_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE |\r\nBNX2_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE |\r\nBNX2_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nrc = bnx2_init_5709_context(bp);\r\nif (rc)\r\nreturn rc;\r\n} else\r\nbnx2_init_context(bp);\r\nif ((rc = bnx2_init_cpus(bp)) != 0)\r\nreturn rc;\r\nbnx2_init_nvram(bp);\r\nbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\r\nval = BNX2_RD(bp, BNX2_MQ_CONFIG);\r\nval &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;\r\nval |= BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_256;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nval |= BNX2_MQ_CONFIG_BIN_MQ_MODE;\r\nif (BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax)\r\nval |= BNX2_MQ_CONFIG_HALT_DIS;\r\n}\r\nBNX2_WR(bp, BNX2_MQ_CONFIG, val);\r\nval = 0x10000 + (MAX_CID_CNT * MB_KERNEL_CTX_SIZE);\r\nBNX2_WR(bp, BNX2_MQ_KNL_BYP_WIND_START, val);\r\nBNX2_WR(bp, BNX2_MQ_KNL_WIND_END, val);\r\nval = (BNX2_PAGE_BITS - 8) << 24;\r\nBNX2_WR(bp, BNX2_RV2P_CONFIG, val);\r\nval = BNX2_RD(bp, BNX2_TBDR_CONFIG);\r\nval &= ~BNX2_TBDR_CONFIG_PAGE_SIZE;\r\nval |= (BNX2_PAGE_BITS - 8) << 24 | 0x40;\r\nBNX2_WR(bp, BNX2_TBDR_CONFIG, val);\r\nval = bp->mac_addr[0] +\r\n(bp->mac_addr[1] << 8) +\r\n(bp->mac_addr[2] << 16) +\r\nbp->mac_addr[3] +\r\n(bp->mac_addr[4] << 8) +\r\n(bp->mac_addr[5] << 16);\r\nBNX2_WR(bp, BNX2_EMAC_BACKOFF_SEED, val);\r\nmtu = bp->dev->mtu;\r\nval = mtu + ETH_HLEN + ETH_FCS_LEN;\r\nif (val > (MAX_ETHERNET_PACKET_SIZE + 4))\r\nval |= BNX2_EMAC_RX_MTU_SIZE_JUMBO_ENA;\r\nBNX2_WR(bp, BNX2_EMAC_RX_MTU_SIZE, val);\r\nif (mtu < 1500)\r\nmtu = 1500;\r\nbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG, BNX2_RBUF_CONFIG_VAL(mtu));\r\nbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG2, BNX2_RBUF_CONFIG2_VAL(mtu));\r\nbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG3, BNX2_RBUF_CONFIG3_VAL(mtu));\r\nmemset(bp->bnx2_napi[0].status_blk.msi, 0, bp->status_stats_size);\r\nfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++)\r\nbp->bnx2_napi[i].last_status_idx = 0;\r\nbp->idle_chk_status_idx = 0xffff;\r\nbp->rx_mode = BNX2_EMAC_RX_MODE_SORT_MODE;\r\nBNX2_WR(bp, BNX2_EMAC_ATTENTION_ENA, BNX2_EMAC_ATTENTION_ENA_LINK);\r\nBNX2_WR(bp, BNX2_HC_STATUS_ADDR_L,\r\n(u64) bp->status_blk_mapping & 0xffffffff);\r\nBNX2_WR(bp, BNX2_HC_STATUS_ADDR_H, (u64) bp->status_blk_mapping >> 32);\r\nBNX2_WR(bp, BNX2_HC_STATISTICS_ADDR_L,\r\n(u64) bp->stats_blk_mapping & 0xffffffff);\r\nBNX2_WR(bp, BNX2_HC_STATISTICS_ADDR_H,\r\n(u64) bp->stats_blk_mapping >> 32);\r\nBNX2_WR(bp, BNX2_HC_TX_QUICK_CONS_TRIP,\r\n(bp->tx_quick_cons_trip_int << 16) | bp->tx_quick_cons_trip);\r\nBNX2_WR(bp, BNX2_HC_RX_QUICK_CONS_TRIP,\r\n(bp->rx_quick_cons_trip_int << 16) | bp->rx_quick_cons_trip);\r\nBNX2_WR(bp, BNX2_HC_COMP_PROD_TRIP,\r\n(bp->comp_prod_trip_int << 16) | bp->comp_prod_trip);\r\nBNX2_WR(bp, BNX2_HC_TX_TICKS, (bp->tx_ticks_int << 16) | bp->tx_ticks);\r\nBNX2_WR(bp, BNX2_HC_RX_TICKS, (bp->rx_ticks_int << 16) | bp->rx_ticks);\r\nBNX2_WR(bp, BNX2_HC_COM_TICKS,\r\n(bp->com_ticks_int << 16) | bp->com_ticks);\r\nBNX2_WR(bp, BNX2_HC_CMD_TICKS,\r\n(bp->cmd_ticks_int << 16) | bp->cmd_ticks);\r\nif (bp->flags & BNX2_FLAG_BROKEN_STATS)\r\nBNX2_WR(bp, BNX2_HC_STATS_TICKS, 0);\r\nelse\r\nBNX2_WR(bp, BNX2_HC_STATS_TICKS, bp->stats_ticks);\r\nBNX2_WR(bp, BNX2_HC_STAT_COLLECT_TICKS, 0xbb8);\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1)\r\nval = BNX2_HC_CONFIG_COLLECT_STATS;\r\nelse {\r\nval = BNX2_HC_CONFIG_RX_TMR_MODE | BNX2_HC_CONFIG_TX_TMR_MODE |\r\nBNX2_HC_CONFIG_COLLECT_STATS;\r\n}\r\nif (bp->flags & BNX2_FLAG_USING_MSIX) {\r\nBNX2_WR(bp, BNX2_HC_MSIX_BIT_VECTOR,\r\nBNX2_HC_MSIX_BIT_VECTOR_VAL);\r\nval |= BNX2_HC_CONFIG_SB_ADDR_INC_128B;\r\n}\r\nif (bp->flags & BNX2_FLAG_ONE_SHOT_MSI)\r\nval |= BNX2_HC_CONFIG_ONE_SHOT | BNX2_HC_CONFIG_USE_INT_PARAM;\r\nBNX2_WR(bp, BNX2_HC_CONFIG, val);\r\nif (bp->rx_ticks < 25)\r\nbnx2_reg_wr_ind(bp, BNX2_FW_RX_LOW_LATENCY, 1);\r\nelse\r\nbnx2_reg_wr_ind(bp, BNX2_FW_RX_LOW_LATENCY, 0);\r\nfor (i = 1; i < bp->irq_nvecs; i++) {\r\nu32 base = ((i - 1) * BNX2_HC_SB_CONFIG_SIZE) +\r\nBNX2_HC_SB_CONFIG_1;\r\nBNX2_WR(bp, base,\r\nBNX2_HC_SB_CONFIG_1_TX_TMR_MODE |\r\nBNX2_HC_SB_CONFIG_1_RX_TMR_MODE |\r\nBNX2_HC_SB_CONFIG_1_ONE_SHOT);\r\nBNX2_WR(bp, base + BNX2_HC_TX_QUICK_CONS_TRIP_OFF,\r\n(bp->tx_quick_cons_trip_int << 16) |\r\nbp->tx_quick_cons_trip);\r\nBNX2_WR(bp, base + BNX2_HC_TX_TICKS_OFF,\r\n(bp->tx_ticks_int << 16) | bp->tx_ticks);\r\nBNX2_WR(bp, base + BNX2_HC_RX_QUICK_CONS_TRIP_OFF,\r\n(bp->rx_quick_cons_trip_int << 16) |\r\nbp->rx_quick_cons_trip);\r\nBNX2_WR(bp, base + BNX2_HC_RX_TICKS_OFF,\r\n(bp->rx_ticks_int << 16) | bp->rx_ticks);\r\n}\r\nBNX2_WR(bp, BNX2_HC_COMMAND, BNX2_HC_COMMAND_CLR_STAT_NOW);\r\nBNX2_WR(bp, BNX2_HC_ATTN_BITS_ENABLE, STATUS_ATTN_EVENTS);\r\nbnx2_set_rx_mode(bp->dev);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\r\nval |= BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE;\r\nBNX2_WR(bp, BNX2_MISC_NEW_CORE_CTL, val);\r\n}\r\nrc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT2 | BNX2_DRV_MSG_CODE_RESET,\r\n1, 0);\r\nBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS, BNX2_MISC_ENABLE_DEFAULT);\r\nBNX2_RD(bp, BNX2_MISC_ENABLE_SET_BITS);\r\nudelay(20);\r\nbp->hc_cmd = BNX2_RD(bp, BNX2_HC_COMMAND);\r\nreturn rc;\r\n}\r\nstatic void\r\nbnx2_clear_ring_states(struct bnx2 *bp)\r\n{\r\nstruct bnx2_napi *bnapi;\r\nstruct bnx2_tx_ring_info *txr;\r\nstruct bnx2_rx_ring_info *rxr;\r\nint i;\r\nfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {\r\nbnapi = &bp->bnx2_napi[i];\r\ntxr = &bnapi->tx_ring;\r\nrxr = &bnapi->rx_ring;\r\ntxr->tx_cons = 0;\r\ntxr->hw_tx_cons = 0;\r\nrxr->rx_prod_bseq = 0;\r\nrxr->rx_prod = 0;\r\nrxr->rx_cons = 0;\r\nrxr->rx_pg_prod = 0;\r\nrxr->rx_pg_cons = 0;\r\n}\r\n}\r\nstatic void\r\nbnx2_init_tx_context(struct bnx2 *bp, u32 cid, struct bnx2_tx_ring_info *txr)\r\n{\r\nu32 val, offset0, offset1, offset2, offset3;\r\nu32 cid_addr = GET_CID_ADDR(cid);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\noffset0 = BNX2_L2CTX_TYPE_XI;\r\noffset1 = BNX2_L2CTX_CMD_TYPE_XI;\r\noffset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;\r\noffset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;\r\n} else {\r\noffset0 = BNX2_L2CTX_TYPE;\r\noffset1 = BNX2_L2CTX_CMD_TYPE;\r\noffset2 = BNX2_L2CTX_TBDR_BHADDR_HI;\r\noffset3 = BNX2_L2CTX_TBDR_BHADDR_LO;\r\n}\r\nval = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;\r\nbnx2_ctx_wr(bp, cid_addr, offset0, val);\r\nval = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);\r\nbnx2_ctx_wr(bp, cid_addr, offset1, val);\r\nval = (u64) txr->tx_desc_mapping >> 32;\r\nbnx2_ctx_wr(bp, cid_addr, offset2, val);\r\nval = (u64) txr->tx_desc_mapping & 0xffffffff;\r\nbnx2_ctx_wr(bp, cid_addr, offset3, val);\r\n}\r\nstatic void\r\nbnx2_init_tx_ring(struct bnx2 *bp, int ring_num)\r\n{\r\nstruct bnx2_tx_bd *txbd;\r\nu32 cid = TX_CID;\r\nstruct bnx2_napi *bnapi;\r\nstruct bnx2_tx_ring_info *txr;\r\nbnapi = &bp->bnx2_napi[ring_num];\r\ntxr = &bnapi->tx_ring;\r\nif (ring_num == 0)\r\ncid = TX_CID;\r\nelse\r\ncid = TX_TSS_CID + ring_num - 1;\r\nbp->tx_wake_thresh = bp->tx_ring_size / 2;\r\ntxbd = &txr->tx_desc_ring[BNX2_MAX_TX_DESC_CNT];\r\ntxbd->tx_bd_haddr_hi = (u64) txr->tx_desc_mapping >> 32;\r\ntxbd->tx_bd_haddr_lo = (u64) txr->tx_desc_mapping & 0xffffffff;\r\ntxr->tx_prod = 0;\r\ntxr->tx_prod_bseq = 0;\r\ntxr->tx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BIDX;\r\ntxr->tx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BSEQ;\r\nbnx2_init_tx_context(bp, cid, txr);\r\n}\r\nstatic void\r\nbnx2_init_rxbd_rings(struct bnx2_rx_bd *rx_ring[], dma_addr_t dma[],\r\nu32 buf_size, int num_rings)\r\n{\r\nint i;\r\nstruct bnx2_rx_bd *rxbd;\r\nfor (i = 0; i < num_rings; i++) {\r\nint j;\r\nrxbd = &rx_ring[i][0];\r\nfor (j = 0; j < BNX2_MAX_RX_DESC_CNT; j++, rxbd++) {\r\nrxbd->rx_bd_len = buf_size;\r\nrxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;\r\n}\r\nif (i == (num_rings - 1))\r\nj = 0;\r\nelse\r\nj = i + 1;\r\nrxbd->rx_bd_haddr_hi = (u64) dma[j] >> 32;\r\nrxbd->rx_bd_haddr_lo = (u64) dma[j] & 0xffffffff;\r\n}\r\n}\r\nstatic void\r\nbnx2_init_rx_ring(struct bnx2 *bp, int ring_num)\r\n{\r\nint i;\r\nu16 prod, ring_prod;\r\nu32 cid, rx_cid_addr, val;\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[ring_num];\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nif (ring_num == 0)\r\ncid = RX_CID;\r\nelse\r\ncid = RX_RSS_CID + ring_num - 1;\r\nrx_cid_addr = GET_CID_ADDR(cid);\r\nbnx2_init_rxbd_rings(rxr->rx_desc_ring, rxr->rx_desc_mapping,\r\nbp->rx_buf_use_size, bp->rx_max_ring);\r\nbnx2_init_rx_context(bp, cid);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nval = BNX2_RD(bp, BNX2_MQ_MAP_L2_5);\r\nBNX2_WR(bp, BNX2_MQ_MAP_L2_5, val | BNX2_MQ_MAP_L2_5_ARM);\r\n}\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, 0);\r\nif (bp->rx_pg_ring_size) {\r\nbnx2_init_rxbd_rings(rxr->rx_pg_desc_ring,\r\nrxr->rx_pg_desc_mapping,\r\nPAGE_SIZE, bp->rx_max_pg_ring);\r\nval = (bp->rx_buf_use_size << 16) | PAGE_SIZE;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, val);\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_RBDC_KEY,\r\nBNX2_L2CTX_RBDC_JUMBO_KEY - ring_num);\r\nval = (u64) rxr->rx_pg_desc_mapping[0] >> 32;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_HI, val);\r\nval = (u64) rxr->rx_pg_desc_mapping[0] & 0xffffffff;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_LO, val);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nBNX2_WR(bp, BNX2_MQ_MAP_L2_3, BNX2_MQ_MAP_L2_3_DEFAULT);\r\n}\r\nval = (u64) rxr->rx_desc_mapping[0] >> 32;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);\r\nval = (u64) rxr->rx_desc_mapping[0] & 0xffffffff;\r\nbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);\r\nring_prod = prod = rxr->rx_pg_prod;\r\nfor (i = 0; i < bp->rx_pg_ring_size; i++) {\r\nif (bnx2_alloc_rx_page(bp, rxr, ring_prod, GFP_KERNEL) < 0) {\r\nnetdev_warn(bp->dev, "init'ed rx page ring %d with %d/%d pages only\n",\r\nring_num, i, bp->rx_pg_ring_size);\r\nbreak;\r\n}\r\nprod = BNX2_NEXT_RX_BD(prod);\r\nring_prod = BNX2_RX_PG_RING_IDX(prod);\r\n}\r\nrxr->rx_pg_prod = prod;\r\nring_prod = prod = rxr->rx_prod;\r\nfor (i = 0; i < bp->rx_ring_size; i++) {\r\nif (bnx2_alloc_rx_data(bp, rxr, ring_prod, GFP_KERNEL) < 0) {\r\nnetdev_warn(bp->dev, "init'ed rx ring %d with %d/%d skbs only\n",\r\nring_num, i, bp->rx_ring_size);\r\nbreak;\r\n}\r\nprod = BNX2_NEXT_RX_BD(prod);\r\nring_prod = BNX2_RX_RING_IDX(prod);\r\n}\r\nrxr->rx_prod = prod;\r\nrxr->rx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BDIDX;\r\nrxr->rx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BSEQ;\r\nrxr->rx_pg_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_PG_BDIDX;\r\nBNX2_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);\r\nBNX2_WR16(bp, rxr->rx_bidx_addr, prod);\r\nBNX2_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);\r\n}\r\nstatic void\r\nbnx2_init_all_rings(struct bnx2 *bp)\r\n{\r\nint i;\r\nu32 val;\r\nbnx2_clear_ring_states(bp);\r\nBNX2_WR(bp, BNX2_TSCH_TSS_CFG, 0);\r\nfor (i = 0; i < bp->num_tx_rings; i++)\r\nbnx2_init_tx_ring(bp, i);\r\nif (bp->num_tx_rings > 1)\r\nBNX2_WR(bp, BNX2_TSCH_TSS_CFG, ((bp->num_tx_rings - 1) << 24) |\r\n(TX_TSS_CID << 7));\r\nBNX2_WR(bp, BNX2_RLUP_RSS_CONFIG, 0);\r\nbnx2_reg_wr_ind(bp, BNX2_RXP_SCRATCH_RSS_TBL_SZ, 0);\r\nfor (i = 0; i < bp->num_rx_rings; i++)\r\nbnx2_init_rx_ring(bp, i);\r\nif (bp->num_rx_rings > 1) {\r\nu32 tbl_32 = 0;\r\nfor (i = 0; i < BNX2_RXP_SCRATCH_RSS_TBL_MAX_ENTRIES; i++) {\r\nint shift = (i % 8) << 2;\r\ntbl_32 |= (i % (bp->num_rx_rings - 1)) << shift;\r\nif ((i % 8) == 7) {\r\nBNX2_WR(bp, BNX2_RLUP_RSS_DATA, tbl_32);\r\nBNX2_WR(bp, BNX2_RLUP_RSS_COMMAND, (i >> 3) |\r\nBNX2_RLUP_RSS_COMMAND_RSS_WRITE_MASK |\r\nBNX2_RLUP_RSS_COMMAND_WRITE |\r\nBNX2_RLUP_RSS_COMMAND_HASH_MASK);\r\ntbl_32 = 0;\r\n}\r\n}\r\nval = BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_ALL_XI |\r\nBNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_ALL_XI;\r\nBNX2_WR(bp, BNX2_RLUP_RSS_CONFIG, val);\r\n}\r\n}\r\nstatic u32 bnx2_find_max_ring(u32 ring_size, u32 max_size)\r\n{\r\nu32 max, num_rings = 1;\r\nwhile (ring_size > BNX2_MAX_RX_DESC_CNT) {\r\nring_size -= BNX2_MAX_RX_DESC_CNT;\r\nnum_rings++;\r\n}\r\nmax = max_size;\r\nwhile ((max & num_rings) == 0)\r\nmax >>= 1;\r\nif (num_rings != max)\r\nmax <<= 1;\r\nreturn max;\r\n}\r\nstatic void\r\nbnx2_set_rx_ring_size(struct bnx2 *bp, u32 size)\r\n{\r\nu32 rx_size, rx_space, jumbo_size;\r\nrx_size = bp->dev->mtu + ETH_HLEN + BNX2_RX_OFFSET + 8;\r\nrx_space = SKB_DATA_ALIGN(rx_size + BNX2_RX_ALIGN) + NET_SKB_PAD +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nbp->rx_copy_thresh = BNX2_RX_COPY_THRESH;\r\nbp->rx_pg_ring_size = 0;\r\nbp->rx_max_pg_ring = 0;\r\nbp->rx_max_pg_ring_idx = 0;\r\nif ((rx_space > PAGE_SIZE) && !(bp->flags & BNX2_FLAG_JUMBO_BROKEN)) {\r\nint pages = PAGE_ALIGN(bp->dev->mtu - 40) >> PAGE_SHIFT;\r\njumbo_size = size * pages;\r\nif (jumbo_size > BNX2_MAX_TOTAL_RX_PG_DESC_CNT)\r\njumbo_size = BNX2_MAX_TOTAL_RX_PG_DESC_CNT;\r\nbp->rx_pg_ring_size = jumbo_size;\r\nbp->rx_max_pg_ring = bnx2_find_max_ring(jumbo_size,\r\nBNX2_MAX_RX_PG_RINGS);\r\nbp->rx_max_pg_ring_idx =\r\n(bp->rx_max_pg_ring * BNX2_RX_DESC_CNT) - 1;\r\nrx_size = BNX2_RX_COPY_THRESH + BNX2_RX_OFFSET;\r\nbp->rx_copy_thresh = 0;\r\n}\r\nbp->rx_buf_use_size = rx_size;\r\nbp->rx_buf_size = SKB_DATA_ALIGN(bp->rx_buf_use_size + BNX2_RX_ALIGN) +\r\nNET_SKB_PAD + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nbp->rx_jumbo_thresh = rx_size - BNX2_RX_OFFSET;\r\nbp->rx_ring_size = size;\r\nbp->rx_max_ring = bnx2_find_max_ring(size, BNX2_MAX_RX_RINGS);\r\nbp->rx_max_ring_idx = (bp->rx_max_ring * BNX2_RX_DESC_CNT) - 1;\r\n}\r\nstatic void\r\nbnx2_free_tx_skbs(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_tx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nint j;\r\nif (txr->tx_buf_ring == NULL)\r\ncontinue;\r\nfor (j = 0; j < BNX2_TX_DESC_CNT; ) {\r\nstruct bnx2_sw_tx_bd *tx_buf = &txr->tx_buf_ring[j];\r\nstruct sk_buff *skb = tx_buf->skb;\r\nint k, last;\r\nif (skb == NULL) {\r\nj = BNX2_NEXT_TX_BD(j);\r\ncontinue;\r\n}\r\ndma_unmap_single(&bp->pdev->dev,\r\ndma_unmap_addr(tx_buf, mapping),\r\nskb_headlen(skb),\r\nPCI_DMA_TODEVICE);\r\ntx_buf->skb = NULL;\r\nlast = tx_buf->nr_frags;\r\nj = BNX2_NEXT_TX_BD(j);\r\nfor (k = 0; k < last; k++, j = BNX2_NEXT_TX_BD(j)) {\r\ntx_buf = &txr->tx_buf_ring[BNX2_TX_RING_IDX(j)];\r\ndma_unmap_page(&bp->pdev->dev,\r\ndma_unmap_addr(tx_buf, mapping),\r\nskb_frag_size(&skb_shinfo(skb)->frags[k]),\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nnetdev_tx_reset_queue(netdev_get_tx_queue(bp->dev, i));\r\n}\r\n}\r\nstatic void\r\nbnx2_free_rx_skbs(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->num_rx_rings; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\nint j;\r\nif (rxr->rx_buf_ring == NULL)\r\nreturn;\r\nfor (j = 0; j < bp->rx_max_ring_idx; j++) {\r\nstruct bnx2_sw_bd *rx_buf = &rxr->rx_buf_ring[j];\r\nu8 *data = rx_buf->data;\r\nif (data == NULL)\r\ncontinue;\r\ndma_unmap_single(&bp->pdev->dev,\r\ndma_unmap_addr(rx_buf, mapping),\r\nbp->rx_buf_use_size,\r\nPCI_DMA_FROMDEVICE);\r\nrx_buf->data = NULL;\r\nkfree(data);\r\n}\r\nfor (j = 0; j < bp->rx_max_pg_ring_idx; j++)\r\nbnx2_free_rx_page(bp, rxr, j);\r\n}\r\n}\r\nstatic void\r\nbnx2_free_skbs(struct bnx2 *bp)\r\n{\r\nbnx2_free_tx_skbs(bp);\r\nbnx2_free_rx_skbs(bp);\r\n}\r\nstatic int\r\nbnx2_reset_nic(struct bnx2 *bp, u32 reset_code)\r\n{\r\nint rc;\r\nrc = bnx2_reset_chip(bp, reset_code);\r\nbnx2_free_skbs(bp);\r\nif (rc)\r\nreturn rc;\r\nif ((rc = bnx2_init_chip(bp)) != 0)\r\nreturn rc;\r\nbnx2_init_all_rings(bp);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_init_nic(struct bnx2 *bp, int reset_phy)\r\n{\r\nint rc;\r\nif ((rc = bnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET)) != 0)\r\nreturn rc;\r\nspin_lock_bh(&bp->phy_lock);\r\nbnx2_init_phy(bp, reset_phy);\r\nbnx2_set_link(bp);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nbnx2_remote_phy_event(bp);\r\nspin_unlock_bh(&bp->phy_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_shutdown_chip(struct bnx2 *bp)\r\n{\r\nu32 reset_code;\r\nif (bp->flags & BNX2_FLAG_NO_WOL)\r\nreset_code = BNX2_DRV_MSG_CODE_UNLOAD_LNK_DN;\r\nelse if (bp->wol)\r\nreset_code = BNX2_DRV_MSG_CODE_SUSPEND_WOL;\r\nelse\r\nreset_code = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;\r\nreturn bnx2_reset_chip(bp, reset_code);\r\n}\r\nstatic int\r\nbnx2_test_registers(struct bnx2 *bp)\r\n{\r\nint ret;\r\nint i, is_5709;\r\nstatic const struct {\r\nu16 offset;\r\nu16 flags;\r\n#define BNX2_FL_NOT_5709 1\r\nu32 rw_mask;\r\nu32 ro_mask;\r\n} reg_tbl[] = {\r\n{ 0x006c, 0, 0x00000000, 0x0000003f },\r\n{ 0x0090, 0, 0xffffffff, 0x00000000 },\r\n{ 0x0094, 0, 0x00000000, 0x00000000 },\r\n{ 0x0404, BNX2_FL_NOT_5709, 0x00003f00, 0x00000000 },\r\n{ 0x0418, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x041c, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x0420, BNX2_FL_NOT_5709, 0x00000000, 0x80ffffff },\r\n{ 0x0424, BNX2_FL_NOT_5709, 0x00000000, 0x00000000 },\r\n{ 0x0428, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },\r\n{ 0x0450, BNX2_FL_NOT_5709, 0x00000000, 0x0000ffff },\r\n{ 0x0454, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x0458, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x0808, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x0854, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\r\n{ 0x0868, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\r\n{ 0x086c, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\r\n{ 0x0870, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\r\n{ 0x0874, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\r\n{ 0x0c00, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },\r\n{ 0x0c04, BNX2_FL_NOT_5709, 0x00000000, 0x03ff0001 },\r\n{ 0x0c08, BNX2_FL_NOT_5709, 0x0f0ff073, 0x00000000 },\r\n{ 0x1000, 0, 0x00000000, 0x00000001 },\r\n{ 0x1004, BNX2_FL_NOT_5709, 0x00000000, 0x000f0001 },\r\n{ 0x1408, 0, 0x01c00800, 0x00000000 },\r\n{ 0x149c, 0, 0x8000ffff, 0x00000000 },\r\n{ 0x14a8, 0, 0x00000000, 0x000001ff },\r\n{ 0x14ac, 0, 0x0fffffff, 0x10000000 },\r\n{ 0x14b0, 0, 0x00000002, 0x00000001 },\r\n{ 0x14b8, 0, 0x00000000, 0x00000000 },\r\n{ 0x14c0, 0, 0x00000000, 0x00000009 },\r\n{ 0x14c4, 0, 0x00003fff, 0x00000000 },\r\n{ 0x14cc, 0, 0x00000000, 0x00000001 },\r\n{ 0x14d0, 0, 0xffffffff, 0x00000000 },\r\n{ 0x1800, 0, 0x00000000, 0x00000001 },\r\n{ 0x1804, 0, 0x00000000, 0x00000003 },\r\n{ 0x2800, 0, 0x00000000, 0x00000001 },\r\n{ 0x2804, 0, 0x00000000, 0x00003f01 },\r\n{ 0x2808, 0, 0x0f3f3f03, 0x00000000 },\r\n{ 0x2810, 0, 0xffff0000, 0x00000000 },\r\n{ 0x2814, 0, 0xffff0000, 0x00000000 },\r\n{ 0x2818, 0, 0xffff0000, 0x00000000 },\r\n{ 0x281c, 0, 0xffff0000, 0x00000000 },\r\n{ 0x2834, 0, 0xffffffff, 0x00000000 },\r\n{ 0x2840, 0, 0x00000000, 0xffffffff },\r\n{ 0x2844, 0, 0x00000000, 0xffffffff },\r\n{ 0x2848, 0, 0xffffffff, 0x00000000 },\r\n{ 0x284c, 0, 0xf800f800, 0x07ff07ff },\r\n{ 0x2c00, 0, 0x00000000, 0x00000011 },\r\n{ 0x2c04, 0, 0x00000000, 0x00030007 },\r\n{ 0x3c00, 0, 0x00000000, 0x00000001 },\r\n{ 0x3c04, 0, 0x00000000, 0x00070000 },\r\n{ 0x3c08, 0, 0x00007f71, 0x07f00000 },\r\n{ 0x3c0c, 0, 0x1f3ffffc, 0x00000000 },\r\n{ 0x3c10, 0, 0xffffffff, 0x00000000 },\r\n{ 0x3c14, 0, 0x00000000, 0xffffffff },\r\n{ 0x3c18, 0, 0x00000000, 0xffffffff },\r\n{ 0x3c1c, 0, 0xfffff000, 0x00000000 },\r\n{ 0x3c20, 0, 0xffffff00, 0x00000000 },\r\n{ 0x5004, 0, 0x00000000, 0x0000007f },\r\n{ 0x5008, 0, 0x0f0007ff, 0x00000000 },\r\n{ 0x5c00, 0, 0x00000000, 0x00000001 },\r\n{ 0x5c04, 0, 0x00000000, 0x0003000f },\r\n{ 0x5c08, 0, 0x00000003, 0x00000000 },\r\n{ 0x5c0c, 0, 0x0000fff8, 0x00000000 },\r\n{ 0x5c10, 0, 0x00000000, 0xffffffff },\r\n{ 0x5c80, 0, 0x00000000, 0x0f7113f1 },\r\n{ 0x5c84, 0, 0x00000000, 0x0000f333 },\r\n{ 0x5c88, 0, 0x00000000, 0x00077373 },\r\n{ 0x5c8c, 0, 0x00000000, 0x0007f737 },\r\n{ 0x6808, 0, 0x0000ff7f, 0x00000000 },\r\n{ 0x680c, 0, 0xffffffff, 0x00000000 },\r\n{ 0x6810, 0, 0xffffffff, 0x00000000 },\r\n{ 0x6814, 0, 0xffffffff, 0x00000000 },\r\n{ 0x6818, 0, 0xffffffff, 0x00000000 },\r\n{ 0x681c, 0, 0xffffffff, 0x00000000 },\r\n{ 0x6820, 0, 0x00ff00ff, 0x00000000 },\r\n{ 0x6824, 0, 0x00ff00ff, 0x00000000 },\r\n{ 0x6828, 0, 0x00ff00ff, 0x00000000 },\r\n{ 0x682c, 0, 0x03ff03ff, 0x00000000 },\r\n{ 0x6830, 0, 0x03ff03ff, 0x00000000 },\r\n{ 0x6834, 0, 0x03ff03ff, 0x00000000 },\r\n{ 0x6838, 0, 0x03ff03ff, 0x00000000 },\r\n{ 0x683c, 0, 0x0000ffff, 0x00000000 },\r\n{ 0x6840, 0, 0x00000ff0, 0x00000000 },\r\n{ 0x6844, 0, 0x00ffff00, 0x00000000 },\r\n{ 0x684c, 0, 0xffffffff, 0x00000000 },\r\n{ 0x6850, 0, 0x7f7f7f7f, 0x00000000 },\r\n{ 0x6854, 0, 0x7f7f7f7f, 0x00000000 },\r\n{ 0x6858, 0, 0x7f7f7f7f, 0x00000000 },\r\n{ 0x685c, 0, 0x7f7f7f7f, 0x00000000 },\r\n{ 0x6908, 0, 0x00000000, 0x0001ff0f },\r\n{ 0x690c, 0, 0x00000000, 0x0ffe00f0 },\r\n{ 0xffff, 0, 0x00000000, 0x00000000 },\r\n};\r\nret = 0;\r\nis_5709 = 0;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nis_5709 = 1;\r\nfor (i = 0; reg_tbl[i].offset != 0xffff; i++) {\r\nu32 offset, rw_mask, ro_mask, save_val, val;\r\nu16 flags = reg_tbl[i].flags;\r\nif (is_5709 && (flags & BNX2_FL_NOT_5709))\r\ncontinue;\r\noffset = (u32) reg_tbl[i].offset;\r\nrw_mask = reg_tbl[i].rw_mask;\r\nro_mask = reg_tbl[i].ro_mask;\r\nsave_val = readl(bp->regview + offset);\r\nwritel(0, bp->regview + offset);\r\nval = readl(bp->regview + offset);\r\nif ((val & rw_mask) != 0) {\r\ngoto reg_test_err;\r\n}\r\nif ((val & ro_mask) != (save_val & ro_mask)) {\r\ngoto reg_test_err;\r\n}\r\nwritel(0xffffffff, bp->regview + offset);\r\nval = readl(bp->regview + offset);\r\nif ((val & rw_mask) != rw_mask) {\r\ngoto reg_test_err;\r\n}\r\nif ((val & ro_mask) != (save_val & ro_mask)) {\r\ngoto reg_test_err;\r\n}\r\nwritel(save_val, bp->regview + offset);\r\ncontinue;\r\nreg_test_err:\r\nwritel(save_val, bp->regview + offset);\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbnx2_do_mem_test(struct bnx2 *bp, u32 start, u32 size)\r\n{\r\nstatic const u32 test_pattern[] = { 0x00000000, 0xffffffff, 0x55555555,\r\n0xaaaaaaaa , 0xaa55aa55, 0x55aa55aa };\r\nint i;\r\nfor (i = 0; i < sizeof(test_pattern) / 4; i++) {\r\nu32 offset;\r\nfor (offset = 0; offset < size; offset += 4) {\r\nbnx2_reg_wr_ind(bp, start + offset, test_pattern[i]);\r\nif (bnx2_reg_rd_ind(bp, start + offset) !=\r\ntest_pattern[i]) {\r\nreturn -ENODEV;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_test_memory(struct bnx2 *bp)\r\n{\r\nint ret = 0;\r\nint i;\r\nstatic struct mem_entry {\r\nu32 offset;\r\nu32 len;\r\n} mem_tbl_5706[] = {\r\n{ 0x60000, 0x4000 },\r\n{ 0xa0000, 0x3000 },\r\n{ 0xe0000, 0x4000 },\r\n{ 0x120000, 0x4000 },\r\n{ 0x1a0000, 0x4000 },\r\n{ 0x160000, 0x4000 },\r\n{ 0xffffffff, 0 },\r\n},\r\nmem_tbl_5709[] = {\r\n{ 0x60000, 0x4000 },\r\n{ 0xa0000, 0x3000 },\r\n{ 0xe0000, 0x4000 },\r\n{ 0x120000, 0x4000 },\r\n{ 0x1a0000, 0x4000 },\r\n{ 0xffffffff, 0 },\r\n};\r\nstruct mem_entry *mem_tbl;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nmem_tbl = mem_tbl_5709;\r\nelse\r\nmem_tbl = mem_tbl_5706;\r\nfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++) {\r\nif ((ret = bnx2_do_mem_test(bp, mem_tbl[i].offset,\r\nmem_tbl[i].len)) != 0) {\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbnx2_run_loopback(struct bnx2 *bp, int loopback_mode)\r\n{\r\nunsigned int pkt_size, num_pkts, i;\r\nstruct sk_buff *skb;\r\nu8 *data;\r\nunsigned char *packet;\r\nu16 rx_start_idx, rx_idx;\r\ndma_addr_t map;\r\nstruct bnx2_tx_bd *txbd;\r\nstruct bnx2_sw_bd *rx_buf;\r\nstruct l2_fhdr *rx_hdr;\r\nint ret = -ENODEV;\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[0], *tx_napi;\r\nstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\r\nstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\r\ntx_napi = bnapi;\r\ntxr = &tx_napi->tx_ring;\r\nrxr = &bnapi->rx_ring;\r\nif (loopback_mode == BNX2_MAC_LOOPBACK) {\r\nbp->loopback = MAC_LOOPBACK;\r\nbnx2_set_mac_loopback(bp);\r\n}\r\nelse if (loopback_mode == BNX2_PHY_LOOPBACK) {\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn 0;\r\nbp->loopback = PHY_LOOPBACK;\r\nbnx2_set_phy_loopback(bp);\r\n}\r\nelse\r\nreturn -EINVAL;\r\npkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_jumbo_thresh - 4);\r\nskb = netdev_alloc_skb(bp->dev, pkt_size);\r\nif (!skb)\r\nreturn -ENOMEM;\r\npacket = skb_put(skb, pkt_size);\r\nmemcpy(packet, bp->dev->dev_addr, ETH_ALEN);\r\nmemset(packet + ETH_ALEN, 0x0, 8);\r\nfor (i = 14; i < pkt_size; i++)\r\npacket[i] = (unsigned char) (i & 0xff);\r\nmap = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,\r\nPCI_DMA_TODEVICE);\r\nif (dma_mapping_error(&bp->pdev->dev, map)) {\r\ndev_kfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nBNX2_WR(bp, BNX2_HC_COMMAND,\r\nbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\r\nBNX2_RD(bp, BNX2_HC_COMMAND);\r\nudelay(5);\r\nrx_start_idx = bnx2_get_hw_rx_cons(bnapi);\r\nnum_pkts = 0;\r\ntxbd = &txr->tx_desc_ring[BNX2_TX_RING_IDX(txr->tx_prod)];\r\ntxbd->tx_bd_haddr_hi = (u64) map >> 32;\r\ntxbd->tx_bd_haddr_lo = (u64) map & 0xffffffff;\r\ntxbd->tx_bd_mss_nbytes = pkt_size;\r\ntxbd->tx_bd_vlan_tag_flags = TX_BD_FLAGS_START | TX_BD_FLAGS_END;\r\nnum_pkts++;\r\ntxr->tx_prod = BNX2_NEXT_TX_BD(txr->tx_prod);\r\ntxr->tx_prod_bseq += pkt_size;\r\nBNX2_WR16(bp, txr->tx_bidx_addr, txr->tx_prod);\r\nBNX2_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);\r\nudelay(100);\r\nBNX2_WR(bp, BNX2_HC_COMMAND,\r\nbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\r\nBNX2_RD(bp, BNX2_HC_COMMAND);\r\nudelay(5);\r\ndma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nif (bnx2_get_hw_tx_cons(tx_napi) != txr->tx_prod)\r\ngoto loopback_test_done;\r\nrx_idx = bnx2_get_hw_rx_cons(bnapi);\r\nif (rx_idx != rx_start_idx + num_pkts) {\r\ngoto loopback_test_done;\r\n}\r\nrx_buf = &rxr->rx_buf_ring[rx_start_idx];\r\ndata = rx_buf->data;\r\nrx_hdr = get_l2_fhdr(data);\r\ndata = (u8 *)rx_hdr + BNX2_RX_OFFSET;\r\ndma_sync_single_for_cpu(&bp->pdev->dev,\r\ndma_unmap_addr(rx_buf, mapping),\r\nbp->rx_buf_use_size, PCI_DMA_FROMDEVICE);\r\nif (rx_hdr->l2_fhdr_status &\r\n(L2_FHDR_ERRORS_BAD_CRC |\r\nL2_FHDR_ERRORS_PHY_DECODE |\r\nL2_FHDR_ERRORS_ALIGNMENT |\r\nL2_FHDR_ERRORS_TOO_SHORT |\r\nL2_FHDR_ERRORS_GIANT_FRAME)) {\r\ngoto loopback_test_done;\r\n}\r\nif ((rx_hdr->l2_fhdr_pkt_len - 4) != pkt_size) {\r\ngoto loopback_test_done;\r\n}\r\nfor (i = 14; i < pkt_size; i++) {\r\nif (*(data + i) != (unsigned char) (i & 0xff)) {\r\ngoto loopback_test_done;\r\n}\r\n}\r\nret = 0;\r\nloopback_test_done:\r\nbp->loopback = 0;\r\nreturn ret;\r\n}\r\nstatic int\r\nbnx2_test_loopback(struct bnx2 *bp)\r\n{\r\nint rc = 0;\r\nif (!netif_running(bp->dev))\r\nreturn BNX2_LOOPBACK_FAILED;\r\nbnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);\r\nspin_lock_bh(&bp->phy_lock);\r\nbnx2_init_phy(bp, 1);\r\nspin_unlock_bh(&bp->phy_lock);\r\nif (bnx2_run_loopback(bp, BNX2_MAC_LOOPBACK))\r\nrc |= BNX2_MAC_LOOPBACK_FAILED;\r\nif (bnx2_run_loopback(bp, BNX2_PHY_LOOPBACK))\r\nrc |= BNX2_PHY_LOOPBACK_FAILED;\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_test_nvram(struct bnx2 *bp)\r\n{\r\n__be32 buf[NVRAM_SIZE / 4];\r\nu8 *data = (u8 *) buf;\r\nint rc = 0;\r\nu32 magic, csum;\r\nif ((rc = bnx2_nvram_read(bp, 0, data, 4)) != 0)\r\ngoto test_nvram_done;\r\nmagic = be32_to_cpu(buf[0]);\r\nif (magic != 0x669955aa) {\r\nrc = -ENODEV;\r\ngoto test_nvram_done;\r\n}\r\nif ((rc = bnx2_nvram_read(bp, 0x100, data, NVRAM_SIZE)) != 0)\r\ngoto test_nvram_done;\r\ncsum = ether_crc_le(0x100, data);\r\nif (csum != CRC32_RESIDUAL) {\r\nrc = -ENODEV;\r\ngoto test_nvram_done;\r\n}\r\ncsum = ether_crc_le(0x100, data + 0x100);\r\nif (csum != CRC32_RESIDUAL) {\r\nrc = -ENODEV;\r\n}\r\ntest_nvram_done:\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_test_link(struct bnx2 *bp)\r\n{\r\nu32 bmsr;\r\nif (!netif_running(bp->dev))\r\nreturn -ENODEV;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\r\nif (bp->link_up)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nspin_lock_bh(&bp->phy_lock);\r\nbnx2_enable_bmsr1(bp);\r\nbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\r\nbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\r\nbnx2_disable_bmsr1(bp);\r\nspin_unlock_bh(&bp->phy_lock);\r\nif (bmsr & BMSR_LSTATUS) {\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nbnx2_test_intr(struct bnx2 *bp)\r\n{\r\nint i;\r\nu16 status_idx;\r\nif (!netif_running(bp->dev))\r\nreturn -ENODEV;\r\nstatus_idx = BNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff;\r\nBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);\r\nBNX2_RD(bp, BNX2_HC_COMMAND);\r\nfor (i = 0; i < 10; i++) {\r\nif ((BNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff) !=\r\nstatus_idx) {\r\nbreak;\r\n}\r\nmsleep_interruptible(10);\r\n}\r\nif (i < 10)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nbnx2_5706_serdes_has_link(struct bnx2 *bp)\r\n{\r\nu32 mode_ctl, an_dbg, exp;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_NO_PARALLEL)\r\nreturn 0;\r\nbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_MODE_CTL);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &mode_ctl);\r\nif (!(mode_ctl & MISC_SHDW_MODE_CTL_SIG_DET))\r\nreturn 0;\r\nbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\r\nif (an_dbg & (MISC_SHDW_AN_DBG_NOSYNC | MISC_SHDW_AN_DBG_RUDI_INVALID))\r\nreturn 0;\r\nbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_REG1);\r\nbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);\r\nbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);\r\nif (exp & MII_EXPAND_REG1_RUDI_C)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nbnx2_5706_serdes_timer(struct bnx2 *bp)\r\n{\r\nint check_link = 1;\r\nspin_lock(&bp->phy_lock);\r\nif (bp->serdes_an_pending) {\r\nbp->serdes_an_pending--;\r\ncheck_link = 0;\r\n} else if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {\r\nu32 bmcr;\r\nbp->current_interval = BNX2_TIMER_INTERVAL;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (bmcr & BMCR_ANENABLE) {\r\nif (bnx2_5706_serdes_has_link(bp)) {\r\nbmcr &= ~BMCR_ANENABLE;\r\nbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\r\nbp->phy_flags |= BNX2_PHY_FLAG_PARALLEL_DETECT;\r\n}\r\n}\r\n}\r\nelse if ((bp->link_up) && (bp->autoneg & AUTONEG_SPEED) &&\r\n(bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)) {\r\nu32 phy2;\r\nbnx2_write_phy(bp, 0x17, 0x0f01);\r\nbnx2_read_phy(bp, 0x15, &phy2);\r\nif (phy2 & 0x20) {\r\nu32 bmcr;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nbmcr |= BMCR_ANENABLE;\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\r\nbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\r\n}\r\n} else\r\nbp->current_interval = BNX2_TIMER_INTERVAL;\r\nif (check_link) {\r\nu32 val;\r\nbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);\r\nbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);\r\nif (bp->link_up && (val & MISC_SHDW_AN_DBG_NOSYNC)) {\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN)) {\r\nbnx2_5706s_force_link_dn(bp, 1);\r\nbp->phy_flags |= BNX2_PHY_FLAG_FORCED_DOWN;\r\n} else\r\nbnx2_set_link(bp);\r\n} else if (!bp->link_up && !(val & MISC_SHDW_AN_DBG_NOSYNC))\r\nbnx2_set_link(bp);\r\n}\r\nspin_unlock(&bp->phy_lock);\r\n}\r\nstatic void\r\nbnx2_5708_serdes_timer(struct bnx2 *bp)\r\n{\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn;\r\nif ((bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) == 0) {\r\nbp->serdes_an_pending = 0;\r\nreturn;\r\n}\r\nspin_lock(&bp->phy_lock);\r\nif (bp->serdes_an_pending)\r\nbp->serdes_an_pending--;\r\nelse if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {\r\nu32 bmcr;\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nif (bmcr & BMCR_ANENABLE) {\r\nbnx2_enable_forced_2g5(bp);\r\nbp->current_interval = BNX2_SERDES_FORCED_TIMEOUT;\r\n} else {\r\nbnx2_disable_forced_2g5(bp);\r\nbp->serdes_an_pending = 2;\r\nbp->current_interval = BNX2_TIMER_INTERVAL;\r\n}\r\n} else\r\nbp->current_interval = BNX2_TIMER_INTERVAL;\r\nspin_unlock(&bp->phy_lock);\r\n}\r\nstatic void\r\nbnx2_timer(unsigned long data)\r\n{\r\nstruct bnx2 *bp = (struct bnx2 *) data;\r\nif (!netif_running(bp->dev))\r\nreturn;\r\nif (atomic_read(&bp->intr_sem) != 0)\r\ngoto bnx2_restart_timer;\r\nif ((bp->flags & (BNX2_FLAG_USING_MSI | BNX2_FLAG_ONE_SHOT_MSI)) ==\r\nBNX2_FLAG_USING_MSI)\r\nbnx2_chk_missed_msi(bp);\r\nbnx2_send_heart_beat(bp);\r\nbp->stats_blk->stat_FwRxDrop =\r\nbnx2_reg_rd_ind(bp, BNX2_FW_RX_DROP_COUNT);\r\nif ((bp->flags & BNX2_FLAG_BROKEN_STATS) && bp->stats_ticks)\r\nBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd |\r\nBNX2_HC_COMMAND_STATS_NOW);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\r\nbnx2_5706_serdes_timer(bp);\r\nelse\r\nbnx2_5708_serdes_timer(bp);\r\n}\r\nbnx2_restart_timer:\r\nmod_timer(&bp->timer, jiffies + bp->current_interval);\r\n}\r\nstatic int\r\nbnx2_request_irq(struct bnx2 *bp)\r\n{\r\nunsigned long flags;\r\nstruct bnx2_irq *irq;\r\nint rc = 0, i;\r\nif (bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)\r\nflags = 0;\r\nelse\r\nflags = IRQF_SHARED;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nirq = &bp->irq_tbl[i];\r\nrc = request_irq(irq->vector, irq->handler, flags, irq->name,\r\n&bp->bnx2_napi[i]);\r\nif (rc)\r\nbreak;\r\nirq->requested = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\n__bnx2_free_irq(struct bnx2 *bp)\r\n{\r\nstruct bnx2_irq *irq;\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nirq = &bp->irq_tbl[i];\r\nif (irq->requested)\r\nfree_irq(irq->vector, &bp->bnx2_napi[i]);\r\nirq->requested = 0;\r\n}\r\n}\r\nstatic void\r\nbnx2_free_irq(struct bnx2 *bp)\r\n{\r\n__bnx2_free_irq(bp);\r\nif (bp->flags & BNX2_FLAG_USING_MSI)\r\npci_disable_msi(bp->pdev);\r\nelse if (bp->flags & BNX2_FLAG_USING_MSIX)\r\npci_disable_msix(bp->pdev);\r\nbp->flags &= ~(BNX2_FLAG_USING_MSI_OR_MSIX | BNX2_FLAG_ONE_SHOT_MSI);\r\n}\r\nstatic void\r\nbnx2_enable_msix(struct bnx2 *bp, int msix_vecs)\r\n{\r\nint i, total_vecs;\r\nstruct msix_entry msix_ent[BNX2_MAX_MSIX_VEC];\r\nstruct net_device *dev = bp->dev;\r\nconst int len = sizeof(bp->irq_tbl[0].name);\r\nbnx2_setup_msix_tbl(bp);\r\nBNX2_WR(bp, BNX2_PCI_MSIX_CONTROL, BNX2_MAX_MSIX_HW_VEC - 1);\r\nBNX2_WR(bp, BNX2_PCI_MSIX_TBL_OFF_BIR, BNX2_PCI_GRC_WINDOW2_BASE);\r\nBNX2_WR(bp, BNX2_PCI_MSIX_PBA_OFF_BIT, BNX2_PCI_GRC_WINDOW3_BASE);\r\nBNX2_RD(bp, BNX2_PCI_MSIX_CONTROL);\r\nfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {\r\nmsix_ent[i].entry = i;\r\nmsix_ent[i].vector = 0;\r\n}\r\ntotal_vecs = msix_vecs;\r\n#ifdef BCM_CNIC\r\ntotal_vecs++;\r\n#endif\r\ntotal_vecs = pci_enable_msix_range(bp->pdev, msix_ent,\r\nBNX2_MIN_MSIX_VEC, total_vecs);\r\nif (total_vecs < 0)\r\nreturn;\r\nmsix_vecs = total_vecs;\r\n#ifdef BCM_CNIC\r\nmsix_vecs--;\r\n#endif\r\nbp->irq_nvecs = msix_vecs;\r\nbp->flags |= BNX2_FLAG_USING_MSIX | BNX2_FLAG_ONE_SHOT_MSI;\r\nfor (i = 0; i < total_vecs; i++) {\r\nbp->irq_tbl[i].vector = msix_ent[i].vector;\r\nsnprintf(bp->irq_tbl[i].name, len, "%s-%d", dev->name, i);\r\nbp->irq_tbl[i].handler = bnx2_msi_1shot;\r\n}\r\n}\r\nstatic int\r\nbnx2_setup_int_mode(struct bnx2 *bp, int dis_msi)\r\n{\r\nint cpus = netif_get_num_default_rss_queues();\r\nint msix_vecs;\r\nif (!bp->num_req_rx_rings)\r\nmsix_vecs = max(cpus + 1, bp->num_req_tx_rings);\r\nelse if (!bp->num_req_tx_rings)\r\nmsix_vecs = max(cpus, bp->num_req_rx_rings);\r\nelse\r\nmsix_vecs = max(bp->num_req_rx_rings, bp->num_req_tx_rings);\r\nmsix_vecs = min(msix_vecs, RX_MAX_RINGS);\r\nbp->irq_tbl[0].handler = bnx2_interrupt;\r\nstrcpy(bp->irq_tbl[0].name, bp->dev->name);\r\nbp->irq_nvecs = 1;\r\nbp->irq_tbl[0].vector = bp->pdev->irq;\r\nif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !dis_msi)\r\nbnx2_enable_msix(bp, msix_vecs);\r\nif ((bp->flags & BNX2_FLAG_MSI_CAP) && !dis_msi &&\r\n!(bp->flags & BNX2_FLAG_USING_MSIX)) {\r\nif (pci_enable_msi(bp->pdev) == 0) {\r\nbp->flags |= BNX2_FLAG_USING_MSI;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nbp->flags |= BNX2_FLAG_ONE_SHOT_MSI;\r\nbp->irq_tbl[0].handler = bnx2_msi_1shot;\r\n} else\r\nbp->irq_tbl[0].handler = bnx2_msi;\r\nbp->irq_tbl[0].vector = bp->pdev->irq;\r\n}\r\n}\r\nif (!bp->num_req_tx_rings)\r\nbp->num_tx_rings = rounddown_pow_of_two(bp->irq_nvecs);\r\nelse\r\nbp->num_tx_rings = min(bp->irq_nvecs, bp->num_req_tx_rings);\r\nif (!bp->num_req_rx_rings)\r\nbp->num_rx_rings = bp->irq_nvecs;\r\nelse\r\nbp->num_rx_rings = min(bp->irq_nvecs, bp->num_req_rx_rings);\r\nnetif_set_real_num_tx_queues(bp->dev, bp->num_tx_rings);\r\nreturn netif_set_real_num_rx_queues(bp->dev, bp->num_rx_rings);\r\n}\r\nstatic int\r\nbnx2_open(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint rc;\r\nrc = bnx2_request_firmware(bp);\r\nif (rc < 0)\r\ngoto out;\r\nnetif_carrier_off(dev);\r\nbnx2_disable_int(bp);\r\nrc = bnx2_setup_int_mode(bp, disable_msi);\r\nif (rc)\r\ngoto open_err;\r\nbnx2_init_napi(bp);\r\nbnx2_napi_enable(bp);\r\nrc = bnx2_alloc_mem(bp);\r\nif (rc)\r\ngoto open_err;\r\nrc = bnx2_request_irq(bp);\r\nif (rc)\r\ngoto open_err;\r\nrc = bnx2_init_nic(bp, 1);\r\nif (rc)\r\ngoto open_err;\r\nmod_timer(&bp->timer, jiffies + bp->current_interval);\r\natomic_set(&bp->intr_sem, 0);\r\nmemset(bp->temp_stats_blk, 0, sizeof(struct statistics_block));\r\nbnx2_enable_int(bp);\r\nif (bp->flags & BNX2_FLAG_USING_MSI) {\r\nif (bnx2_test_intr(bp) != 0) {\r\nnetdev_warn(bp->dev, "No interrupt was generated using MSI, switching to INTx mode. Please report this failure to the PCI maintainer and include system chipset information.\n");\r\nbnx2_disable_int(bp);\r\nbnx2_free_irq(bp);\r\nbnx2_setup_int_mode(bp, 1);\r\nrc = bnx2_init_nic(bp, 0);\r\nif (!rc)\r\nrc = bnx2_request_irq(bp);\r\nif (rc) {\r\ndel_timer_sync(&bp->timer);\r\ngoto open_err;\r\n}\r\nbnx2_enable_int(bp);\r\n}\r\n}\r\nif (bp->flags & BNX2_FLAG_USING_MSI)\r\nnetdev_info(dev, "using MSI\n");\r\nelse if (bp->flags & BNX2_FLAG_USING_MSIX)\r\nnetdev_info(dev, "using MSIX\n");\r\nnetif_tx_start_all_queues(dev);\r\nout:\r\nreturn rc;\r\nopen_err:\r\nbnx2_napi_disable(bp);\r\nbnx2_free_skbs(bp);\r\nbnx2_free_irq(bp);\r\nbnx2_free_mem(bp);\r\nbnx2_del_napi(bp);\r\nbnx2_release_firmware(bp);\r\ngoto out;\r\n}\r\nstatic void\r\nbnx2_reset_task(struct work_struct *work)\r\n{\r\nstruct bnx2 *bp = container_of(work, struct bnx2, reset_task);\r\nint rc;\r\nu16 pcicmd;\r\nrtnl_lock();\r\nif (!netif_running(bp->dev)) {\r\nrtnl_unlock();\r\nreturn;\r\n}\r\nbnx2_netif_stop(bp, true);\r\npci_read_config_word(bp->pdev, PCI_COMMAND, &pcicmd);\r\nif (!(pcicmd & PCI_COMMAND_MEMORY)) {\r\npci_restore_state(bp->pdev);\r\npci_save_state(bp->pdev);\r\n}\r\nrc = bnx2_init_nic(bp, 1);\r\nif (rc) {\r\nnetdev_err(bp->dev, "failed to reset NIC, closing\n");\r\nbnx2_napi_enable(bp);\r\ndev_close(bp->dev);\r\nrtnl_unlock();\r\nreturn;\r\n}\r\natomic_set(&bp->intr_sem, 1);\r\nbnx2_netif_start(bp, true);\r\nrtnl_unlock();\r\n}\r\nstatic void\r\nbnx2_dump_ftq(struct bnx2 *bp)\r\n{\r\nint i;\r\nu32 reg, bdidx, cid, valid;\r\nstruct net_device *dev = bp->dev;\r\nstatic const struct ftq_reg {\r\nchar *name;\r\nu32 off;\r\n} ftq_arr[] = {\r\nBNX2_FTQ_ENTRY(RV2P_P),\r\nBNX2_FTQ_ENTRY(RV2P_T),\r\nBNX2_FTQ_ENTRY(RV2P_M),\r\nBNX2_FTQ_ENTRY(TBDR_),\r\nBNX2_FTQ_ENTRY(TDMA_),\r\nBNX2_FTQ_ENTRY(TXP_),\r\nBNX2_FTQ_ENTRY(TXP_),\r\nBNX2_FTQ_ENTRY(TPAT_),\r\nBNX2_FTQ_ENTRY(RXP_C),\r\nBNX2_FTQ_ENTRY(RXP_),\r\nBNX2_FTQ_ENTRY(COM_COMXQ_),\r\nBNX2_FTQ_ENTRY(COM_COMTQ_),\r\nBNX2_FTQ_ENTRY(COM_COMQ_),\r\nBNX2_FTQ_ENTRY(CP_CPQ_),\r\n};\r\nnetdev_err(dev, "<--- start FTQ dump --->\n");\r\nfor (i = 0; i < ARRAY_SIZE(ftq_arr); i++)\r\nnetdev_err(dev, "%s %08x\n", ftq_arr[i].name,\r\nbnx2_reg_rd_ind(bp, ftq_arr[i].off));\r\nnetdev_err(dev, "CPU states:\n");\r\nfor (reg = BNX2_TXP_CPU_MODE; reg <= BNX2_CP_CPU_MODE; reg += 0x40000)\r\nnetdev_err(dev, "%06x mode %x state %x evt_mask %x pc %x pc %x instr %x\n",\r\nreg, bnx2_reg_rd_ind(bp, reg),\r\nbnx2_reg_rd_ind(bp, reg + 4),\r\nbnx2_reg_rd_ind(bp, reg + 8),\r\nbnx2_reg_rd_ind(bp, reg + 0x1c),\r\nbnx2_reg_rd_ind(bp, reg + 0x1c),\r\nbnx2_reg_rd_ind(bp, reg + 0x20));\r\nnetdev_err(dev, "<--- end FTQ dump --->\n");\r\nnetdev_err(dev, "<--- start TBDC dump --->\n");\r\nnetdev_err(dev, "TBDC free cnt: %ld\n",\r\nBNX2_RD(bp, BNX2_TBDC_STATUS) & BNX2_TBDC_STATUS_FREE_CNT);\r\nnetdev_err(dev, "LINE CID BIDX CMD VALIDS\n");\r\nfor (i = 0; i < 0x20; i++) {\r\nint j = 0;\r\nBNX2_WR(bp, BNX2_TBDC_BD_ADDR, i);\r\nBNX2_WR(bp, BNX2_TBDC_CAM_OPCODE,\r\nBNX2_TBDC_CAM_OPCODE_OPCODE_CAM_READ);\r\nBNX2_WR(bp, BNX2_TBDC_COMMAND, BNX2_TBDC_COMMAND_CMD_REG_ARB);\r\nwhile ((BNX2_RD(bp, BNX2_TBDC_COMMAND) &\r\nBNX2_TBDC_COMMAND_CMD_REG_ARB) && j < 100)\r\nj++;\r\ncid = BNX2_RD(bp, BNX2_TBDC_CID);\r\nbdidx = BNX2_RD(bp, BNX2_TBDC_BIDX);\r\nvalid = BNX2_RD(bp, BNX2_TBDC_CAM_OPCODE);\r\nnetdev_err(dev, "%02x %06x %04lx %02x [%x]\n",\r\ni, cid, bdidx & BNX2_TBDC_BDIDX_BDIDX,\r\nbdidx >> 24, (valid >> 8) & 0x0ff);\r\n}\r\nnetdev_err(dev, "<--- end TBDC dump --->\n");\r\n}\r\nstatic void\r\nbnx2_dump_state(struct bnx2 *bp)\r\n{\r\nstruct net_device *dev = bp->dev;\r\nu32 val1, val2;\r\npci_read_config_dword(bp->pdev, PCI_COMMAND, &val1);\r\nnetdev_err(dev, "DEBUG: intr_sem[%x] PCI_CMD[%08x]\n",\r\natomic_read(&bp->intr_sem), val1);\r\npci_read_config_dword(bp->pdev, bp->pm_cap + PCI_PM_CTRL, &val1);\r\npci_read_config_dword(bp->pdev, BNX2_PCICFG_MISC_CONFIG, &val2);\r\nnetdev_err(dev, "DEBUG: PCI_PM[%08x] PCI_MISC_CFG[%08x]\n", val1, val2);\r\nnetdev_err(dev, "DEBUG: EMAC_TX_STATUS[%08x] EMAC_RX_STATUS[%08x]\n",\r\nBNX2_RD(bp, BNX2_EMAC_TX_STATUS),\r\nBNX2_RD(bp, BNX2_EMAC_RX_STATUS));\r\nnetdev_err(dev, "DEBUG: RPM_MGMT_PKT_CTRL[%08x]\n",\r\nBNX2_RD(bp, BNX2_RPM_MGMT_PKT_CTRL));\r\nnetdev_err(dev, "DEBUG: HC_STATS_INTERRUPT_STATUS[%08x]\n",\r\nBNX2_RD(bp, BNX2_HC_STATS_INTERRUPT_STATUS));\r\nif (bp->flags & BNX2_FLAG_USING_MSIX)\r\nnetdev_err(dev, "DEBUG: PBA[%08x]\n",\r\nBNX2_RD(bp, BNX2_PCI_GRC_WINDOW3_BASE));\r\n}\r\nstatic void\r\nbnx2_tx_timeout(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nbnx2_dump_ftq(bp);\r\nbnx2_dump_state(bp);\r\nbnx2_dump_mcp_state(bp);\r\nschedule_work(&bp->reset_task);\r\n}\r\nstatic netdev_tx_t\r\nbnx2_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\ndma_addr_t mapping;\r\nstruct bnx2_tx_bd *txbd;\r\nstruct bnx2_sw_tx_bd *tx_buf;\r\nu32 len, vlan_tag_flags, last_frag, mss;\r\nu16 prod, ring_prod;\r\nint i;\r\nstruct bnx2_napi *bnapi;\r\nstruct bnx2_tx_ring_info *txr;\r\nstruct netdev_queue *txq;\r\ni = skb_get_queue_mapping(skb);\r\nbnapi = &bp->bnx2_napi[i];\r\ntxr = &bnapi->tx_ring;\r\ntxq = netdev_get_tx_queue(dev, i);\r\nif (unlikely(bnx2_tx_avail(bp, txr) <\r\n(skb_shinfo(skb)->nr_frags + 1))) {\r\nnetif_tx_stop_queue(txq);\r\nnetdev_err(dev, "BUG! Tx ring full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nlen = skb_headlen(skb);\r\nprod = txr->tx_prod;\r\nring_prod = BNX2_TX_RING_IDX(prod);\r\nvlan_tag_flags = 0;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nvlan_tag_flags |= TX_BD_FLAGS_TCP_UDP_CKSUM;\r\n}\r\nif (vlan_tx_tag_present(skb)) {\r\nvlan_tag_flags |=\r\n(TX_BD_FLAGS_VLAN_TAG | (vlan_tx_tag_get(skb) << 16));\r\n}\r\nif ((mss = skb_shinfo(skb)->gso_size)) {\r\nu32 tcp_opt_len;\r\nstruct iphdr *iph;\r\nvlan_tag_flags |= TX_BD_FLAGS_SW_LSO;\r\ntcp_opt_len = tcp_optlen(skb);\r\nif (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) {\r\nu32 tcp_off = skb_transport_offset(skb) -\r\nsizeof(struct ipv6hdr) - ETH_HLEN;\r\nvlan_tag_flags |= ((tcp_opt_len >> 2) << 8) |\r\nTX_BD_FLAGS_SW_FLAGS;\r\nif (likely(tcp_off == 0))\r\nvlan_tag_flags &= ~TX_BD_FLAGS_TCP6_OFF0_MSK;\r\nelse {\r\ntcp_off >>= 3;\r\nvlan_tag_flags |= ((tcp_off & 0x3) <<\r\nTX_BD_FLAGS_TCP6_OFF0_SHL) |\r\n((tcp_off & 0x10) <<\r\nTX_BD_FLAGS_TCP6_OFF4_SHL);\r\nmss |= (tcp_off & 0xc) << TX_BD_TCP6_OFF2_SHL;\r\n}\r\n} else {\r\niph = ip_hdr(skb);\r\nif (tcp_opt_len || (iph->ihl > 5)) {\r\nvlan_tag_flags |= ((iph->ihl - 5) +\r\n(tcp_opt_len >> 2)) << 8;\r\n}\r\n}\r\n} else\r\nmss = 0;\r\nmapping = dma_map_single(&bp->pdev->dev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (dma_mapping_error(&bp->pdev->dev, mapping)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntx_buf = &txr->tx_buf_ring[ring_prod];\r\ntx_buf->skb = skb;\r\ndma_unmap_addr_set(tx_buf, mapping, mapping);\r\ntxbd = &txr->tx_desc_ring[ring_prod];\r\ntxbd->tx_bd_haddr_hi = (u64) mapping >> 32;\r\ntxbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;\r\ntxbd->tx_bd_mss_nbytes = len | (mss << 16);\r\ntxbd->tx_bd_vlan_tag_flags = vlan_tag_flags | TX_BD_FLAGS_START;\r\nlast_frag = skb_shinfo(skb)->nr_frags;\r\ntx_buf->nr_frags = last_frag;\r\ntx_buf->is_gso = skb_is_gso(skb);\r\nfor (i = 0; i < last_frag; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nprod = BNX2_NEXT_TX_BD(prod);\r\nring_prod = BNX2_TX_RING_IDX(prod);\r\ntxbd = &txr->tx_desc_ring[ring_prod];\r\nlen = skb_frag_size(frag);\r\nmapping = skb_frag_dma_map(&bp->pdev->dev, frag, 0, len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&bp->pdev->dev, mapping))\r\ngoto dma_error;\r\ndma_unmap_addr_set(&txr->tx_buf_ring[ring_prod], mapping,\r\nmapping);\r\ntxbd->tx_bd_haddr_hi = (u64) mapping >> 32;\r\ntxbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;\r\ntxbd->tx_bd_mss_nbytes = len | (mss << 16);\r\ntxbd->tx_bd_vlan_tag_flags = vlan_tag_flags;\r\n}\r\ntxbd->tx_bd_vlan_tag_flags |= TX_BD_FLAGS_END;\r\nwmb();\r\nnetdev_tx_sent_queue(txq, skb->len);\r\nprod = BNX2_NEXT_TX_BD(prod);\r\ntxr->tx_prod_bseq += skb->len;\r\nBNX2_WR16(bp, txr->tx_bidx_addr, prod);\r\nBNX2_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);\r\nmmiowb();\r\ntxr->tx_prod = prod;\r\nif (unlikely(bnx2_tx_avail(bp, txr) <= MAX_SKB_FRAGS)) {\r\nnetif_tx_stop_queue(txq);\r\nsmp_mb();\r\nif (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)\r\nnetif_tx_wake_queue(txq);\r\n}\r\nreturn NETDEV_TX_OK;\r\ndma_error:\r\nlast_frag = i;\r\nprod = txr->tx_prod;\r\nring_prod = BNX2_TX_RING_IDX(prod);\r\ntx_buf = &txr->tx_buf_ring[ring_prod];\r\ntx_buf->skb = NULL;\r\ndma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\r\nskb_headlen(skb), PCI_DMA_TODEVICE);\r\nfor (i = 0; i < last_frag; i++) {\r\nprod = BNX2_NEXT_TX_BD(prod);\r\nring_prod = BNX2_TX_RING_IDX(prod);\r\ntx_buf = &txr->tx_buf_ring[ring_prod];\r\ndma_unmap_page(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nbnx2_close(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nbnx2_disable_int_sync(bp);\r\nbnx2_napi_disable(bp);\r\nnetif_tx_disable(dev);\r\ndel_timer_sync(&bp->timer);\r\nbnx2_shutdown_chip(bp);\r\nbnx2_free_irq(bp);\r\nbnx2_free_skbs(bp);\r\nbnx2_free_mem(bp);\r\nbnx2_del_napi(bp);\r\nbp->link_up = 0;\r\nnetif_carrier_off(bp->dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_save_stats(struct bnx2 *bp)\r\n{\r\nu32 *hw_stats = (u32 *) bp->stats_blk;\r\nu32 *temp_stats = (u32 *) bp->temp_stats_blk;\r\nint i;\r\nfor (i = 0; i < 20; i += 2) {\r\nu32 hi;\r\nu64 lo;\r\nhi = temp_stats[i] + hw_stats[i];\r\nlo = (u64) temp_stats[i + 1] + (u64) hw_stats[i + 1];\r\nif (lo > 0xffffffff)\r\nhi++;\r\ntemp_stats[i] = hi;\r\ntemp_stats[i + 1] = lo & 0xffffffff;\r\n}\r\nfor ( ; i < sizeof(struct statistics_block) / 4; i++)\r\ntemp_stats[i] += hw_stats[i];\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nbnx2_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *net_stats)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (bp->stats_blk == NULL)\r\nreturn net_stats;\r\nnet_stats->rx_packets =\r\nGET_64BIT_NET_STATS(stat_IfHCInUcastPkts) +\r\nGET_64BIT_NET_STATS(stat_IfHCInMulticastPkts) +\r\nGET_64BIT_NET_STATS(stat_IfHCInBroadcastPkts);\r\nnet_stats->tx_packets =\r\nGET_64BIT_NET_STATS(stat_IfHCOutUcastPkts) +\r\nGET_64BIT_NET_STATS(stat_IfHCOutMulticastPkts) +\r\nGET_64BIT_NET_STATS(stat_IfHCOutBroadcastPkts);\r\nnet_stats->rx_bytes =\r\nGET_64BIT_NET_STATS(stat_IfHCInOctets);\r\nnet_stats->tx_bytes =\r\nGET_64BIT_NET_STATS(stat_IfHCOutOctets);\r\nnet_stats->multicast =\r\nGET_64BIT_NET_STATS(stat_IfHCInMulticastPkts);\r\nnet_stats->collisions =\r\nGET_32BIT_NET_STATS(stat_EtherStatsCollisions);\r\nnet_stats->rx_length_errors =\r\nGET_32BIT_NET_STATS(stat_EtherStatsUndersizePkts) +\r\nGET_32BIT_NET_STATS(stat_EtherStatsOverrsizePkts);\r\nnet_stats->rx_over_errors =\r\nGET_32BIT_NET_STATS(stat_IfInFTQDiscards) +\r\nGET_32BIT_NET_STATS(stat_IfInMBUFDiscards);\r\nnet_stats->rx_frame_errors =\r\nGET_32BIT_NET_STATS(stat_Dot3StatsAlignmentErrors);\r\nnet_stats->rx_crc_errors =\r\nGET_32BIT_NET_STATS(stat_Dot3StatsFCSErrors);\r\nnet_stats->rx_errors = net_stats->rx_length_errors +\r\nnet_stats->rx_over_errors + net_stats->rx_frame_errors +\r\nnet_stats->rx_crc_errors;\r\nnet_stats->tx_aborted_errors =\r\nGET_32BIT_NET_STATS(stat_Dot3StatsExcessiveCollisions) +\r\nGET_32BIT_NET_STATS(stat_Dot3StatsLateCollisions);\r\nif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0))\r\nnet_stats->tx_carrier_errors = 0;\r\nelse {\r\nnet_stats->tx_carrier_errors =\r\nGET_32BIT_NET_STATS(stat_Dot3StatsCarrierSenseErrors);\r\n}\r\nnet_stats->tx_errors =\r\nGET_32BIT_NET_STATS(stat_emac_tx_stat_dot3statsinternalmactransmiterrors) +\r\nnet_stats->tx_aborted_errors +\r\nnet_stats->tx_carrier_errors;\r\nnet_stats->rx_missed_errors =\r\nGET_32BIT_NET_STATS(stat_IfInFTQDiscards) +\r\nGET_32BIT_NET_STATS(stat_IfInMBUFDiscards) +\r\nGET_32BIT_NET_STATS(stat_FwRxDrop);\r\nreturn net_stats;\r\n}\r\nstatic int\r\nbnx2_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint support_serdes = 0, support_copper = 0;\r\ncmd->supported = SUPPORTED_Autoneg;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\r\nsupport_serdes = 1;\r\nsupport_copper = 1;\r\n} else if (bp->phy_port == PORT_FIBRE)\r\nsupport_serdes = 1;\r\nelse\r\nsupport_copper = 1;\r\nif (support_serdes) {\r\ncmd->supported |= SUPPORTED_1000baseT_Full |\r\nSUPPORTED_FIBRE;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)\r\ncmd->supported |= SUPPORTED_2500baseX_Full;\r\n}\r\nif (support_copper) {\r\ncmd->supported |= SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_TP;\r\n}\r\nspin_lock_bh(&bp->phy_lock);\r\ncmd->port = bp->phy_port;\r\ncmd->advertising = bp->advertising;\r\nif (bp->autoneg & AUTONEG_SPEED) {\r\ncmd->autoneg = AUTONEG_ENABLE;\r\n} else {\r\ncmd->autoneg = AUTONEG_DISABLE;\r\n}\r\nif (netif_carrier_ok(dev)) {\r\nethtool_cmd_speed_set(cmd, bp->line_speed);\r\ncmd->duplex = bp->duplex;\r\nif (!(bp->phy_flags & BNX2_PHY_FLAG_SERDES)) {\r\nif (bp->phy_flags & BNX2_PHY_FLAG_MDIX)\r\ncmd->eth_tp_mdix = ETH_TP_MDI_X;\r\nelse\r\ncmd->eth_tp_mdix = ETH_TP_MDI;\r\n}\r\n}\r\nelse {\r\nethtool_cmd_speed_set(cmd, SPEED_UNKNOWN);\r\ncmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\nspin_unlock_bh(&bp->phy_lock);\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->phy_address = bp->phy_addr;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nu8 autoneg = bp->autoneg;\r\nu8 req_duplex = bp->req_duplex;\r\nu16 req_line_speed = bp->req_line_speed;\r\nu32 advertising = bp->advertising;\r\nint err = -EINVAL;\r\nspin_lock_bh(&bp->phy_lock);\r\nif (cmd->port != PORT_TP && cmd->port != PORT_FIBRE)\r\ngoto err_out_unlock;\r\nif (cmd->port != bp->phy_port &&\r\n!(bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP))\r\ngoto err_out_unlock;\r\nif (!netif_running(dev) && cmd->port != bp->phy_port)\r\ngoto err_out_unlock;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nautoneg |= AUTONEG_SPEED;\r\nadvertising = cmd->advertising;\r\nif (cmd->port == PORT_TP) {\r\nadvertising &= ETHTOOL_ALL_COPPER_SPEED;\r\nif (!advertising)\r\nadvertising = ETHTOOL_ALL_COPPER_SPEED;\r\n} else {\r\nadvertising &= ETHTOOL_ALL_FIBRE_SPEED;\r\nif (!advertising)\r\nadvertising = ETHTOOL_ALL_FIBRE_SPEED;\r\n}\r\nadvertising |= ADVERTISED_Autoneg;\r\n}\r\nelse {\r\nu32 speed = ethtool_cmd_speed(cmd);\r\nif (cmd->port == PORT_FIBRE) {\r\nif ((speed != SPEED_1000 &&\r\nspeed != SPEED_2500) ||\r\n(cmd->duplex != DUPLEX_FULL))\r\ngoto err_out_unlock;\r\nif (speed == SPEED_2500 &&\r\n!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\r\ngoto err_out_unlock;\r\n} else if (speed == SPEED_1000 || speed == SPEED_2500)\r\ngoto err_out_unlock;\r\nautoneg &= ~AUTONEG_SPEED;\r\nreq_line_speed = speed;\r\nreq_duplex = cmd->duplex;\r\nadvertising = 0;\r\n}\r\nbp->autoneg = autoneg;\r\nbp->advertising = advertising;\r\nbp->req_line_speed = req_line_speed;\r\nbp->req_duplex = req_duplex;\r\nerr = 0;\r\nif (netif_running(dev))\r\nerr = bnx2_setup_phy(bp, cmd->port);\r\nerr_out_unlock:\r\nspin_unlock_bh(&bp->phy_lock);\r\nreturn err;\r\n}\r\nstatic void\r\nbnx2_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));\r\nstrlcpy(info->fw_version, bp->fw_version, sizeof(info->fw_version));\r\n}\r\nstatic int\r\nbnx2_get_regs_len(struct net_device *dev)\r\n{\r\nreturn BNX2_REGDUMP_LEN;\r\n}\r\nstatic void\r\nbnx2_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *_p)\r\n{\r\nu32 *p = _p, i, offset;\r\nu8 *orig_p = _p;\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstatic const u32 reg_boundaries[] = {\r\n0x0000, 0x0098, 0x0400, 0x045c,\r\n0x0800, 0x0880, 0x0c00, 0x0c10,\r\n0x0c30, 0x0d08, 0x1000, 0x101c,\r\n0x1040, 0x1048, 0x1080, 0x10a4,\r\n0x1400, 0x1490, 0x1498, 0x14f0,\r\n0x1500, 0x155c, 0x1580, 0x15dc,\r\n0x1600, 0x1658, 0x1680, 0x16d8,\r\n0x1800, 0x1820, 0x1840, 0x1854,\r\n0x1880, 0x1894, 0x1900, 0x1984,\r\n0x1c00, 0x1c0c, 0x1c40, 0x1c54,\r\n0x1c80, 0x1c94, 0x1d00, 0x1d84,\r\n0x2000, 0x2030, 0x23c0, 0x2400,\r\n0x2800, 0x2820, 0x2830, 0x2850,\r\n0x2b40, 0x2c10, 0x2fc0, 0x3058,\r\n0x3c00, 0x3c94, 0x4000, 0x4010,\r\n0x4080, 0x4090, 0x43c0, 0x4458,\r\n0x4c00, 0x4c18, 0x4c40, 0x4c54,\r\n0x4fc0, 0x5010, 0x53c0, 0x5444,\r\n0x5c00, 0x5c18, 0x5c80, 0x5c90,\r\n0x5fc0, 0x6000, 0x6400, 0x6428,\r\n0x6800, 0x6848, 0x684c, 0x6860,\r\n0x6888, 0x6910, 0x8000\r\n};\r\nregs->version = 0;\r\nmemset(p, 0, BNX2_REGDUMP_LEN);\r\nif (!netif_running(bp->dev))\r\nreturn;\r\ni = 0;\r\noffset = reg_boundaries[0];\r\np += offset;\r\nwhile (offset < BNX2_REGDUMP_LEN) {\r\n*p++ = BNX2_RD(bp, offset);\r\noffset += 4;\r\nif (offset == reg_boundaries[i + 1]) {\r\noffset = reg_boundaries[i + 2];\r\np = (u32 *) (orig_p + offset);\r\ni += 2;\r\n}\r\n}\r\n}\r\nstatic void\r\nbnx2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (bp->flags & BNX2_FLAG_NO_WOL) {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\n}\r\nelse {\r\nwol->supported = WAKE_MAGIC;\r\nif (bp->wol)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int\r\nbnx2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nif (bp->flags & BNX2_FLAG_NO_WOL)\r\nreturn -EINVAL;\r\nbp->wol = 1;\r\n}\r\nelse {\r\nbp->wol = 0;\r\n}\r\ndevice_set_wakeup_enable(&bp->pdev->dev, bp->wol);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_nway_reset(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nu32 bmcr;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nif (!(bp->autoneg & AUTONEG_SPEED)) {\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&bp->phy_lock);\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\r\nint rc;\r\nrc = bnx2_setup_remote_phy(bp, bp->phy_port);\r\nspin_unlock_bh(&bp->phy_lock);\r\nreturn rc;\r\n}\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nbnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);\r\nspin_unlock_bh(&bp->phy_lock);\r\nmsleep(20);\r\nspin_lock_bh(&bp->phy_lock);\r\nbp->current_interval = BNX2_SERDES_AN_TIMEOUT;\r\nbp->serdes_an_pending = 1;\r\nmod_timer(&bp->timer, jiffies + bp->current_interval);\r\n}\r\nbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\r\nbmcr &= ~BMCR_LOOPBACK;\r\nbnx2_write_phy(bp, bp->mii_bmcr, bmcr | BMCR_ANRESTART | BMCR_ANENABLE);\r\nspin_unlock_bh(&bp->phy_lock);\r\nreturn 0;\r\n}\r\nstatic u32\r\nbnx2_get_link(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nreturn bp->link_up;\r\n}\r\nstatic int\r\nbnx2_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (bp->flash_info == NULL)\r\nreturn 0;\r\nreturn (int) bp->flash_size;\r\n}\r\nstatic int\r\nbnx2_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *eebuf)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint rc;\r\nrc = bnx2_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *eebuf)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint rc;\r\nrc = bnx2_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_get_coalesce(struct net_device *dev, struct ethtool_coalesce *coal)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nmemset(coal, 0, sizeof(struct ethtool_coalesce));\r\ncoal->rx_coalesce_usecs = bp->rx_ticks;\r\ncoal->rx_max_coalesced_frames = bp->rx_quick_cons_trip;\r\ncoal->rx_coalesce_usecs_irq = bp->rx_ticks_int;\r\ncoal->rx_max_coalesced_frames_irq = bp->rx_quick_cons_trip_int;\r\ncoal->tx_coalesce_usecs = bp->tx_ticks;\r\ncoal->tx_max_coalesced_frames = bp->tx_quick_cons_trip;\r\ncoal->tx_coalesce_usecs_irq = bp->tx_ticks_int;\r\ncoal->tx_max_coalesced_frames_irq = bp->tx_quick_cons_trip_int;\r\ncoal->stats_block_coalesce_usecs = bp->stats_ticks;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_set_coalesce(struct net_device *dev, struct ethtool_coalesce *coal)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nbp->rx_ticks = (u16) coal->rx_coalesce_usecs;\r\nif (bp->rx_ticks > 0x3ff) bp->rx_ticks = 0x3ff;\r\nbp->rx_quick_cons_trip = (u16) coal->rx_max_coalesced_frames;\r\nif (bp->rx_quick_cons_trip > 0xff) bp->rx_quick_cons_trip = 0xff;\r\nbp->rx_ticks_int = (u16) coal->rx_coalesce_usecs_irq;\r\nif (bp->rx_ticks_int > 0x3ff) bp->rx_ticks_int = 0x3ff;\r\nbp->rx_quick_cons_trip_int = (u16) coal->rx_max_coalesced_frames_irq;\r\nif (bp->rx_quick_cons_trip_int > 0xff)\r\nbp->rx_quick_cons_trip_int = 0xff;\r\nbp->tx_ticks = (u16) coal->tx_coalesce_usecs;\r\nif (bp->tx_ticks > 0x3ff) bp->tx_ticks = 0x3ff;\r\nbp->tx_quick_cons_trip = (u16) coal->tx_max_coalesced_frames;\r\nif (bp->tx_quick_cons_trip > 0xff) bp->tx_quick_cons_trip = 0xff;\r\nbp->tx_ticks_int = (u16) coal->tx_coalesce_usecs_irq;\r\nif (bp->tx_ticks_int > 0x3ff) bp->tx_ticks_int = 0x3ff;\r\nbp->tx_quick_cons_trip_int = (u16) coal->tx_max_coalesced_frames_irq;\r\nif (bp->tx_quick_cons_trip_int > 0xff) bp->tx_quick_cons_trip_int =\r\n0xff;\r\nbp->stats_ticks = coal->stats_block_coalesce_usecs;\r\nif (bp->flags & BNX2_FLAG_BROKEN_STATS) {\r\nif (bp->stats_ticks != 0 && bp->stats_ticks != USEC_PER_SEC)\r\nbp->stats_ticks = USEC_PER_SEC;\r\n}\r\nif (bp->stats_ticks > BNX2_HC_STATS_TICKS_HC_STAT_TICKS)\r\nbp->stats_ticks = BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\r\nbp->stats_ticks &= BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\r\nif (netif_running(bp->dev)) {\r\nbnx2_netif_stop(bp, true);\r\nbnx2_init_nic(bp, 0);\r\nbnx2_netif_start(bp, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnx2_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nering->rx_max_pending = BNX2_MAX_TOTAL_RX_DESC_CNT;\r\nering->rx_jumbo_max_pending = BNX2_MAX_TOTAL_RX_PG_DESC_CNT;\r\nering->rx_pending = bp->rx_ring_size;\r\nering->rx_jumbo_pending = bp->rx_pg_ring_size;\r\nering->tx_max_pending = BNX2_MAX_TX_DESC_CNT;\r\nering->tx_pending = bp->tx_ring_size;\r\n}\r\nstatic int\r\nbnx2_change_ring_size(struct bnx2 *bp, u32 rx, u32 tx, bool reset_irq)\r\n{\r\nif (netif_running(bp->dev)) {\r\nbnx2_save_stats(bp);\r\nbnx2_netif_stop(bp, true);\r\nbnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_RESET);\r\nif (reset_irq) {\r\nbnx2_free_irq(bp);\r\nbnx2_del_napi(bp);\r\n} else {\r\n__bnx2_free_irq(bp);\r\n}\r\nbnx2_free_skbs(bp);\r\nbnx2_free_mem(bp);\r\n}\r\nbnx2_set_rx_ring_size(bp, rx);\r\nbp->tx_ring_size = tx;\r\nif (netif_running(bp->dev)) {\r\nint rc = 0;\r\nif (reset_irq) {\r\nrc = bnx2_setup_int_mode(bp, disable_msi);\r\nbnx2_init_napi(bp);\r\n}\r\nif (!rc)\r\nrc = bnx2_alloc_mem(bp);\r\nif (!rc)\r\nrc = bnx2_request_irq(bp);\r\nif (!rc)\r\nrc = bnx2_init_nic(bp, 0);\r\nif (rc) {\r\nbnx2_napi_enable(bp);\r\ndev_close(bp->dev);\r\nreturn rc;\r\n}\r\n#ifdef BCM_CNIC\r\nmutex_lock(&bp->cnic_lock);\r\nif (bp->cnic_eth_dev.drv_state & CNIC_DRV_STATE_REGD)\r\nbnx2_setup_cnic_irq_info(bp);\r\nmutex_unlock(&bp->cnic_lock);\r\n#endif\r\nbnx2_netif_start(bp, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint rc;\r\nif ((ering->rx_pending > BNX2_MAX_TOTAL_RX_DESC_CNT) ||\r\n(ering->tx_pending > BNX2_MAX_TX_DESC_CNT) ||\r\n(ering->tx_pending <= MAX_SKB_FRAGS)) {\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2_change_ring_size(bp, ering->rx_pending, ering->tx_pending,\r\nfalse);\r\nreturn rc;\r\n}\r\nstatic void\r\nbnx2_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nepause->autoneg = ((bp->autoneg & AUTONEG_FLOW_CTRL) != 0);\r\nepause->rx_pause = ((bp->flow_ctrl & FLOW_CTRL_RX) != 0);\r\nepause->tx_pause = ((bp->flow_ctrl & FLOW_CTRL_TX) != 0);\r\n}\r\nstatic int\r\nbnx2_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nbp->req_flow_ctrl = 0;\r\nif (epause->rx_pause)\r\nbp->req_flow_ctrl |= FLOW_CTRL_RX;\r\nif (epause->tx_pause)\r\nbp->req_flow_ctrl |= FLOW_CTRL_TX;\r\nif (epause->autoneg) {\r\nbp->autoneg |= AUTONEG_FLOW_CTRL;\r\n}\r\nelse {\r\nbp->autoneg &= ~AUTONEG_FLOW_CTRL;\r\n}\r\nif (netif_running(dev)) {\r\nspin_lock_bh(&bp->phy_lock);\r\nbnx2_setup_phy(bp, bp->phy_port);\r\nspin_unlock_bh(&bp->phy_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn BNX2_NUM_TESTS;\r\ncase ETH_SS_STATS:\r\nreturn BNX2_NUM_STATS;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void\r\nbnx2_self_test(struct net_device *dev, struct ethtool_test *etest, u64 *buf)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nmemset(buf, 0, sizeof(u64) * BNX2_NUM_TESTS);\r\nif (etest->flags & ETH_TEST_FL_OFFLINE) {\r\nint i;\r\nbnx2_netif_stop(bp, true);\r\nbnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_DIAG);\r\nbnx2_free_skbs(bp);\r\nif (bnx2_test_registers(bp) != 0) {\r\nbuf[0] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (bnx2_test_memory(bp) != 0) {\r\nbuf[1] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif ((buf[2] = bnx2_test_loopback(bp)) != 0)\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nif (!netif_running(bp->dev))\r\nbnx2_shutdown_chip(bp);\r\nelse {\r\nbnx2_init_nic(bp, 1);\r\nbnx2_netif_start(bp, true);\r\n}\r\nfor (i = 0; i < 7; i++) {\r\nif (bp->link_up)\r\nbreak;\r\nmsleep_interruptible(1000);\r\n}\r\n}\r\nif (bnx2_test_nvram(bp) != 0) {\r\nbuf[3] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (bnx2_test_intr(bp) != 0) {\r\nbuf[4] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (bnx2_test_link(bp) != 0) {\r\nbuf[5] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\n}\r\nstatic void\r\nbnx2_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(buf, bnx2_stats_str_arr,\r\nsizeof(bnx2_stats_str_arr));\r\nbreak;\r\ncase ETH_SS_TEST:\r\nmemcpy(buf, bnx2_tests_str_arr,\r\nsizeof(bnx2_tests_str_arr));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbnx2_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *buf)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint i;\r\nu32 *hw_stats = (u32 *) bp->stats_blk;\r\nu32 *temp_stats = (u32 *) bp->temp_stats_blk;\r\nu8 *stats_len_arr = NULL;\r\nif (hw_stats == NULL) {\r\nmemset(buf, 0, sizeof(u64) * BNX2_NUM_STATS);\r\nreturn;\r\n}\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A2) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0))\r\nstats_len_arr = bnx2_5706_stats_len_arr;\r\nelse\r\nstats_len_arr = bnx2_5708_stats_len_arr;\r\nfor (i = 0; i < BNX2_NUM_STATS; i++) {\r\nunsigned long offset;\r\nif (stats_len_arr[i] == 0) {\r\nbuf[i] = 0;\r\ncontinue;\r\n}\r\noffset = bnx2_stats_offset_arr[i];\r\nif (stats_len_arr[i] == 4) {\r\nbuf[i] = (u64) *(hw_stats + offset) +\r\n*(temp_stats + offset);\r\ncontinue;\r\n}\r\nbuf[i] = (((u64) *(hw_stats + offset)) << 32) +\r\n*(hw_stats + offset + 1) +\r\n(((u64) *(temp_stats + offset)) << 32) +\r\n*(temp_stats + offset + 1);\r\n}\r\n}\r\nstatic int\r\nbnx2_set_phys_id(struct net_device *dev, enum ethtool_phys_id_state state)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nbp->leds_save = BNX2_RD(bp, BNX2_MISC_CFG);\r\nBNX2_WR(bp, BNX2_MISC_CFG, BNX2_MISC_CFG_LEDMODE_MAC);\r\nreturn 1;\r\ncase ETHTOOL_ID_ON:\r\nBNX2_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE |\r\nBNX2_EMAC_LED_1000MB_OVERRIDE |\r\nBNX2_EMAC_LED_100MB_OVERRIDE |\r\nBNX2_EMAC_LED_10MB_OVERRIDE |\r\nBNX2_EMAC_LED_TRAFFIC_OVERRIDE |\r\nBNX2_EMAC_LED_TRAFFIC);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nBNX2_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nBNX2_WR(bp, BNX2_EMAC_LED, 0);\r\nBNX2_WR(bp, BNX2_MISC_CFG, bp->leds_save);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_features_t\r\nbnx2_fix_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (!(bp->flags & BNX2_FLAG_CAN_KEEP_VLAN))\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_RX;\r\nreturn features;\r\n}\r\nstatic int\r\nbnx2_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (features & NETIF_F_HW_VLAN_CTAG_TX)\r\ndev->vlan_features |= (dev->hw_features & NETIF_F_ALL_TSO);\r\nelse\r\ndev->vlan_features &= ~NETIF_F_ALL_TSO;\r\nif ((!!(features & NETIF_F_HW_VLAN_CTAG_RX) !=\r\n!!(bp->rx_mode & BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG)) &&\r\nnetif_running(dev)) {\r\nbnx2_netif_stop(bp, false);\r\ndev->features = features;\r\nbnx2_set_rx_mode(dev);\r\nbnx2_fw_sync(bp, BNX2_DRV_MSG_CODE_KEEP_VLAN_UPDATE, 0, 1);\r\nbnx2_netif_start(bp, false);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channels)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nu32 max_rx_rings = 1;\r\nu32 max_tx_rings = 1;\r\nif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !disable_msi) {\r\nmax_rx_rings = RX_MAX_RINGS;\r\nmax_tx_rings = TX_MAX_RINGS;\r\n}\r\nchannels->max_rx = max_rx_rings;\r\nchannels->max_tx = max_tx_rings;\r\nchannels->max_other = 0;\r\nchannels->max_combined = 0;\r\nchannels->rx_count = bp->num_rx_rings;\r\nchannels->tx_count = bp->num_tx_rings;\r\nchannels->other_count = 0;\r\nchannels->combined_count = 0;\r\n}\r\nstatic int bnx2_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channels)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nu32 max_rx_rings = 1;\r\nu32 max_tx_rings = 1;\r\nint rc = 0;\r\nif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !disable_msi) {\r\nmax_rx_rings = RX_MAX_RINGS;\r\nmax_tx_rings = TX_MAX_RINGS;\r\n}\r\nif (channels->rx_count > max_rx_rings ||\r\nchannels->tx_count > max_tx_rings)\r\nreturn -EINVAL;\r\nbp->num_req_rx_rings = channels->rx_count;\r\nbp->num_req_tx_rings = channels->tx_count;\r\nif (netif_running(dev))\r\nrc = bnx2_change_ring_size(bp, bp->rx_ring_size,\r\nbp->tx_ring_size, true);\r\nreturn rc;\r\n}\r\nstatic int\r\nbnx2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint err;\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = bp->phy_addr;\r\ncase SIOCGMIIREG: {\r\nu32 mii_regval;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn -EOPNOTSUPP;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nspin_lock_bh(&bp->phy_lock);\r\nerr = bnx2_read_phy(bp, data->reg_num & 0x1f, &mii_regval);\r\nspin_unlock_bh(&bp->phy_lock);\r\ndata->val_out = mii_regval;\r\nreturn err;\r\n}\r\ncase SIOCSMIIREG:\r\nif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\r\nreturn -EOPNOTSUPP;\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nspin_lock_bh(&bp->phy_lock);\r\nerr = bnx2_write_phy(bp, data->reg_num & 0x1f, data->val_in);\r\nspin_unlock_bh(&bp->phy_lock);\r\nreturn err;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nbnx2_change_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (netif_running(dev))\r\nbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (((new_mtu + ETH_HLEN) > MAX_ETHERNET_JUMBO_PACKET_SIZE) ||\r\n((new_mtu + ETH_HLEN) < MIN_ETHERNET_PACKET_SIZE))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn bnx2_change_ring_size(bp, bp->rx_ring_size, bp->tx_ring_size,\r\nfalse);\r\n}\r\nstatic void\r\npoll_bnx2(struct net_device *dev)\r\n{\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nstruct bnx2_irq *irq = &bp->irq_tbl[i];\r\ndisable_irq(irq->vector);\r\nirq->handler(irq->vector, &bp->bnx2_napi[i]);\r\nenable_irq(irq->vector);\r\n}\r\n}\r\nstatic void\r\nbnx2_get_5709_media(struct bnx2 *bp)\r\n{\r\nu32 val = BNX2_RD(bp, BNX2_MISC_DUAL_MEDIA_CTRL);\r\nu32 bond_id = val & BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID;\r\nu32 strap;\r\nif (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_C)\r\nreturn;\r\nelse if (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_S) {\r\nbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\r\nreturn;\r\n}\r\nif (val & BNX2_MISC_DUAL_MEDIA_CTRL_STRAP_OVERRIDE)\r\nstrap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL) >> 21;\r\nelse\r\nstrap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL_STRAP) >> 8;\r\nif (bp->func == 0) {\r\nswitch (strap) {\r\ncase 0x4:\r\ncase 0x5:\r\ncase 0x6:\r\nbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\r\nreturn;\r\n}\r\n} else {\r\nswitch (strap) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x4:\r\nbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\nbnx2_get_pci_speed(struct bnx2 *bp)\r\n{\r\nu32 reg;\r\nreg = BNX2_RD(bp, BNX2_PCICFG_MISC_STATUS);\r\nif (reg & BNX2_PCICFG_MISC_STATUS_PCIX_DET) {\r\nu32 clkreg;\r\nbp->flags |= BNX2_FLAG_PCIX;\r\nclkreg = BNX2_RD(bp, BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS);\r\nclkreg &= BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET;\r\nswitch (clkreg) {\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ:\r\nbp->bus_speed_mhz = 133;\r\nbreak;\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ:\r\nbp->bus_speed_mhz = 100;\r\nbreak;\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ:\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ:\r\nbp->bus_speed_mhz = 66;\r\nbreak;\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ:\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ:\r\nbp->bus_speed_mhz = 50;\r\nbreak;\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW:\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ:\r\ncase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ:\r\nbp->bus_speed_mhz = 33;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nif (reg & BNX2_PCICFG_MISC_STATUS_M66EN)\r\nbp->bus_speed_mhz = 66;\r\nelse\r\nbp->bus_speed_mhz = 33;\r\n}\r\nif (reg & BNX2_PCICFG_MISC_STATUS_32BIT_DET)\r\nbp->flags |= BNX2_FLAG_PCI_32BIT;\r\n}\r\nstatic void\r\nbnx2_read_vpd_fw_ver(struct bnx2 *bp)\r\n{\r\nint rc, i, j;\r\nu8 *data;\r\nunsigned int block_end, rosize, len;\r\n#define BNX2_VPD_NVRAM_OFFSET 0x300\r\n#define BNX2_VPD_LEN 128\r\n#define BNX2_MAX_VER_SLEN 30\r\ndata = kmalloc(256, GFP_KERNEL);\r\nif (!data)\r\nreturn;\r\nrc = bnx2_nvram_read(bp, BNX2_VPD_NVRAM_OFFSET, data + BNX2_VPD_LEN,\r\nBNX2_VPD_LEN);\r\nif (rc)\r\ngoto vpd_done;\r\nfor (i = 0; i < BNX2_VPD_LEN; i += 4) {\r\ndata[i] = data[i + BNX2_VPD_LEN + 3];\r\ndata[i + 1] = data[i + BNX2_VPD_LEN + 2];\r\ndata[i + 2] = data[i + BNX2_VPD_LEN + 1];\r\ndata[i + 3] = data[i + BNX2_VPD_LEN];\r\n}\r\ni = pci_vpd_find_tag(data, 0, BNX2_VPD_LEN, PCI_VPD_LRDT_RO_DATA);\r\nif (i < 0)\r\ngoto vpd_done;\r\nrosize = pci_vpd_lrdt_size(&data[i]);\r\ni += PCI_VPD_LRDT_TAG_SIZE;\r\nblock_end = i + rosize;\r\nif (block_end > BNX2_VPD_LEN)\r\ngoto vpd_done;\r\nj = pci_vpd_find_info_keyword(data, i, rosize,\r\nPCI_VPD_RO_KEYWORD_MFR_ID);\r\nif (j < 0)\r\ngoto vpd_done;\r\nlen = pci_vpd_info_field_size(&data[j]);\r\nj += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (j + len > block_end || len != 4 ||\r\nmemcmp(&data[j], "1028", 4))\r\ngoto vpd_done;\r\nj = pci_vpd_find_info_keyword(data, i, rosize,\r\nPCI_VPD_RO_KEYWORD_VENDOR0);\r\nif (j < 0)\r\ngoto vpd_done;\r\nlen = pci_vpd_info_field_size(&data[j]);\r\nj += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (j + len > block_end || len > BNX2_MAX_VER_SLEN)\r\ngoto vpd_done;\r\nmemcpy(bp->fw_version, &data[j], len);\r\nbp->fw_version[len] = ' ';\r\nvpd_done:\r\nkfree(data);\r\n}\r\nstatic int\r\nbnx2_init_board(struct pci_dev *pdev, struct net_device *dev)\r\n{\r\nstruct bnx2 *bp;\r\nint rc, i, j;\r\nu32 reg;\r\nu64 dma_mask, persist_dma_mask;\r\nint err;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nbp = netdev_priv(dev);\r\nbp->flags = 0;\r\nbp->phy_flags = 0;\r\nbp->temp_stats_blk =\r\nkzalloc(sizeof(struct statistics_block), GFP_KERNEL);\r\nif (bp->temp_stats_blk == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");\r\ngoto err_out;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev,\r\n"Cannot find PCI device base address, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nrc = pci_request_regions(pdev, DRV_MODULE_NAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_disable;\r\n}\r\npci_set_master(pdev);\r\nbp->pm_cap = pdev->pm_cap;\r\nif (bp->pm_cap == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot find power management capability, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_release;\r\n}\r\nbp->dev = dev;\r\nbp->pdev = pdev;\r\nspin_lock_init(&bp->phy_lock);\r\nspin_lock_init(&bp->indirect_lock);\r\n#ifdef BCM_CNIC\r\nmutex_init(&bp->cnic_lock);\r\n#endif\r\nINIT_WORK(&bp->reset_task, bnx2_reset_task);\r\nbp->regview = pci_iomap(pdev, 0, MB_GET_CID_ADDR(TX_TSS_CID +\r\nTX_MAX_TSS_RINGS + 1));\r\nif (!bp->regview) {\r\ndev_err(&pdev->dev, "Cannot map register space, aborting\n");\r\nrc = -ENOMEM;\r\ngoto err_out_release;\r\n}\r\nBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG,\r\nBNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\r\nBNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP);\r\nbp->chip_id = BNX2_RD(bp, BNX2_MISC_ID);\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\r\nif (!pci_is_pcie(pdev)) {\r\ndev_err(&pdev->dev, "Not PCIE, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_unmap;\r\n}\r\nbp->flags |= BNX2_FLAG_PCIE;\r\nif (BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax)\r\nbp->flags |= BNX2_FLAG_JUMBO_BROKEN;\r\nerr = pci_enable_pcie_error_reporting(pdev);\r\nif (!err)\r\nbp->flags |= BNX2_FLAG_AER_ENABLED;\r\n} else {\r\nbp->pcix_cap = pci_find_capability(pdev, PCI_CAP_ID_PCIX);\r\nif (bp->pcix_cap == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot find PCIX capability, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_unmap;\r\n}\r\nbp->flags |= BNX2_FLAG_BROKEN_STATS;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709 &&\r\nBNX2_CHIP_REV(bp) != BNX2_CHIP_REV_Ax) {\r\nif (pdev->msix_cap)\r\nbp->flags |= BNX2_FLAG_MSIX_CAP;\r\n}\r\nif (BNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A0 &&\r\nBNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A1) {\r\nif (pdev->msi_cap)\r\nbp->flags |= BNX2_FLAG_MSI_CAP;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5708)\r\npersist_dma_mask = dma_mask = DMA_BIT_MASK(40);\r\nelse\r\npersist_dma_mask = dma_mask = DMA_BIT_MASK(64);\r\nif (pci_set_dma_mask(pdev, dma_mask) == 0) {\r\ndev->features |= NETIF_F_HIGHDMA;\r\nrc = pci_set_consistent_dma_mask(pdev, persist_dma_mask);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"pci_set_consistent_dma_mask failed, aborting\n");\r\ngoto err_out_unmap;\r\n}\r\n} else if ((rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) != 0) {\r\ndev_err(&pdev->dev, "System does not support DMA, aborting\n");\r\ngoto err_out_unmap;\r\n}\r\nif (!(bp->flags & BNX2_FLAG_PCIE))\r\nbnx2_get_pci_speed(bp);\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\r\nreg = BNX2_RD(bp, PCI_COMMAND);\r\nreg &= ~(PCI_COMMAND_SERR | PCI_COMMAND_PARITY);\r\nBNX2_WR(bp, PCI_COMMAND, reg);\r\n} else if ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1) &&\r\n!(bp->flags & BNX2_FLAG_PCIX)) {\r\ndev_err(&pdev->dev,\r\n"5706 A1 can only be used in a PCIX bus, aborting\n");\r\ngoto err_out_unmap;\r\n}\r\nbnx2_init_nvram(bp);\r\nreg = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_SIGNATURE);\r\nif (bnx2_reg_rd_ind(bp, BNX2_MCP_TOE_ID) & BNX2_MCP_TOE_ID_FUNCTION_ID)\r\nbp->func = 1;\r\nif ((reg & BNX2_SHM_HDR_SIGNATURE_SIG_MASK) ==\r\nBNX2_SHM_HDR_SIGNATURE_SIG) {\r\nu32 off = bp->func << 2;\r\nbp->shmem_base = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_ADDR_0 + off);\r\n} else\r\nbp->shmem_base = HOST_VIEW_SHMEM_BASE;\r\nreg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_SIGNATURE);\r\nif ((reg & BNX2_DEV_INFO_SIGNATURE_MAGIC_MASK) !=\r\nBNX2_DEV_INFO_SIGNATURE_MAGIC) {\r\ndev_err(&pdev->dev, "Firmware not running, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out_unmap;\r\n}\r\nbnx2_read_vpd_fw_ver(bp);\r\nj = strlen(bp->fw_version);\r\nreg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_BC_REV);\r\nfor (i = 0; i < 3 && j < 24; i++) {\r\nu8 num, k, skip0;\r\nif (i == 0) {\r\nbp->fw_version[j++] = 'b';\r\nbp->fw_version[j++] = 'c';\r\nbp->fw_version[j++] = ' ';\r\n}\r\nnum = (u8) (reg >> (24 - (i * 8)));\r\nfor (k = 100, skip0 = 1; k >= 1; num %= k, k /= 10) {\r\nif (num >= k || !skip0 || k == 1) {\r\nbp->fw_version[j++] = (num / k) + '0';\r\nskip0 = 0;\r\n}\r\n}\r\nif (i != 2)\r\nbp->fw_version[j++] = '.';\r\n}\r\nreg = bnx2_shmem_rd(bp, BNX2_PORT_FEATURE);\r\nif (reg & BNX2_PORT_FEATURE_WOL_ENABLED)\r\nbp->wol = 1;\r\nif (reg & BNX2_PORT_FEATURE_ASF_ENABLED) {\r\nbp->flags |= BNX2_FLAG_ASF_ENABLE;\r\nfor (i = 0; i < 30; i++) {\r\nreg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\r\nif (reg & BNX2_CONDITION_MFW_RUN_MASK)\r\nbreak;\r\nmsleep(10);\r\n}\r\n}\r\nreg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\r\nreg &= BNX2_CONDITION_MFW_RUN_MASK;\r\nif (reg != BNX2_CONDITION_MFW_RUN_UNKNOWN &&\r\nreg != BNX2_CONDITION_MFW_RUN_NONE) {\r\nu32 addr = bnx2_shmem_rd(bp, BNX2_MFW_VER_PTR);\r\nif (j < 32)\r\nbp->fw_version[j++] = ' ';\r\nfor (i = 0; i < 3 && j < 28; i++) {\r\nreg = bnx2_reg_rd_ind(bp, addr + i * 4);\r\nreg = be32_to_cpu(reg);\r\nmemcpy(&bp->fw_version[j], &reg, 4);\r\nj += 4;\r\n}\r\n}\r\nreg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_UPPER);\r\nbp->mac_addr[0] = (u8) (reg >> 8);\r\nbp->mac_addr[1] = (u8) reg;\r\nreg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_LOWER);\r\nbp->mac_addr[2] = (u8) (reg >> 24);\r\nbp->mac_addr[3] = (u8) (reg >> 16);\r\nbp->mac_addr[4] = (u8) (reg >> 8);\r\nbp->mac_addr[5] = (u8) reg;\r\nbp->tx_ring_size = BNX2_MAX_TX_DESC_CNT;\r\nbnx2_set_rx_ring_size(bp, 255);\r\nbp->tx_quick_cons_trip_int = 2;\r\nbp->tx_quick_cons_trip = 20;\r\nbp->tx_ticks_int = 18;\r\nbp->tx_ticks = 80;\r\nbp->rx_quick_cons_trip_int = 2;\r\nbp->rx_quick_cons_trip = 12;\r\nbp->rx_ticks_int = 18;\r\nbp->rx_ticks = 18;\r\nbp->stats_ticks = USEC_PER_SEC & BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\r\nbp->current_interval = BNX2_TIMER_INTERVAL;\r\nbp->phy_addr = 1;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\nbnx2_get_5709_media(bp);\r\nelse if (BNX2_CHIP_BOND(bp) & BNX2_CHIP_BOND_SERDES_BIT)\r\nbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\r\nbp->phy_port = PORT_TP;\r\nif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\r\nbp->phy_port = PORT_FIBRE;\r\nreg = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);\r\nif (!(reg & BNX2_SHARED_HW_CFG_GIG_LINK_ON_VAUX)) {\r\nbp->flags |= BNX2_FLAG_NO_WOL;\r\nbp->wol = 0;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5706) {\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\r\npdev->subsystem_device == 0x310c)\r\nbp->phy_flags |= BNX2_PHY_FLAG_NO_PARALLEL;\r\n} else {\r\nbp->phy_addr = 2;\r\nif (reg & BNX2_SHARED_HW_CFG_PHY_2_5G)\r\nbp->phy_flags |= BNX2_PHY_FLAG_2_5G_CAPABLE;\r\n}\r\n} else if (BNX2_CHIP(bp) == BNX2_CHIP_5706 ||\r\nBNX2_CHIP(bp) == BNX2_CHIP_5708)\r\nbp->phy_flags |= BNX2_PHY_FLAG_CRC_FIX;\r\nelse if (BNX2_CHIP(bp) == BNX2_CHIP_5709 &&\r\n(BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax ||\r\nBNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Bx))\r\nbp->phy_flags |= BNX2_PHY_FLAG_DIS_EARLY_DAC;\r\nbnx2_init_fw_cap(bp);\r\nif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B0) ||\r\n(BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B1) ||\r\n!(BNX2_RD(bp, BNX2_PCI_CONFIG_3) & BNX2_PCI_CONFIG_3_VAUX_PRESET)) {\r\nbp->flags |= BNX2_FLAG_NO_WOL;\r\nbp->wol = 0;\r\n}\r\nif (bp->flags & BNX2_FLAG_NO_WOL)\r\ndevice_set_wakeup_capable(&bp->pdev->dev, false);\r\nelse\r\ndevice_set_wakeup_enable(&bp->pdev->dev, bp->wol);\r\nif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\r\nbp->tx_quick_cons_trip_int =\r\nbp->tx_quick_cons_trip;\r\nbp->tx_ticks_int = bp->tx_ticks;\r\nbp->rx_quick_cons_trip_int =\r\nbp->rx_quick_cons_trip;\r\nbp->rx_ticks_int = bp->rx_ticks;\r\nbp->comp_prod_trip_int = bp->comp_prod_trip;\r\nbp->com_ticks_int = bp->com_ticks;\r\nbp->cmd_ticks_int = bp->cmd_ticks;\r\n}\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5706 && disable_msi == 0) {\r\nstruct pci_dev *amd_8132 = NULL;\r\nwhile ((amd_8132 = pci_get_device(PCI_VENDOR_ID_AMD,\r\nPCI_DEVICE_ID_AMD_8132_BRIDGE,\r\namd_8132))) {\r\nif (amd_8132->revision >= 0x10 &&\r\namd_8132->revision <= 0x13) {\r\ndisable_msi = 1;\r\npci_dev_put(amd_8132);\r\nbreak;\r\n}\r\n}\r\n}\r\nbnx2_set_default_link(bp);\r\nbp->req_flow_ctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;\r\ninit_timer(&bp->timer);\r\nbp->timer.expires = RUN_AT(BNX2_TIMER_INTERVAL);\r\nbp->timer.data = (unsigned long) bp;\r\nbp->timer.function = bnx2_timer;\r\n#ifdef BCM_CNIC\r\nif (bnx2_shmem_rd(bp, BNX2_ISCSI_INITIATOR) & BNX2_ISCSI_INITIATOR_EN)\r\nbp->cnic_eth_dev.max_iscsi_conn =\r\n(bnx2_shmem_rd(bp, BNX2_ISCSI_MAX_CONN) &\r\nBNX2_ISCSI_MAX_CONN_MASK) >> BNX2_ISCSI_MAX_CONN_SHIFT;\r\nbp->cnic_probe = bnx2_cnic_probe;\r\n#endif\r\npci_save_state(pdev);\r\nreturn 0;\r\nerr_out_unmap:\r\nif (bp->flags & BNX2_FLAG_AER_ENABLED) {\r\npci_disable_pcie_error_reporting(pdev);\r\nbp->flags &= ~BNX2_FLAG_AER_ENABLED;\r\n}\r\npci_iounmap(pdev, bp->regview);\r\nbp->regview = NULL;\r\nerr_out_release:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic char *\r\nbnx2_bus_string(struct bnx2 *bp, char *str)\r\n{\r\nchar *s = str;\r\nif (bp->flags & BNX2_FLAG_PCIE) {\r\ns += sprintf(s, "PCI Express");\r\n} else {\r\ns += sprintf(s, "PCI");\r\nif (bp->flags & BNX2_FLAG_PCIX)\r\ns += sprintf(s, "-X");\r\nif (bp->flags & BNX2_FLAG_PCI_32BIT)\r\ns += sprintf(s, " 32-bit");\r\nelse\r\ns += sprintf(s, " 64-bit");\r\ns += sprintf(s, " %dMHz", bp->bus_speed_mhz);\r\n}\r\nreturn str;\r\n}\r\nstatic void\r\nbnx2_del_napi(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++)\r\nnetif_napi_del(&bp->bnx2_napi[i].napi);\r\n}\r\nstatic void\r\nbnx2_init_napi(struct bnx2 *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < bp->irq_nvecs; i++) {\r\nstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\r\nint (*poll)(struct napi_struct *, int);\r\nif (i == 0)\r\npoll = bnx2_poll;\r\nelse\r\npoll = bnx2_poll_msix;\r\nnetif_napi_add(bp->dev, &bp->bnx2_napi[i].napi, poll, 64);\r\nbnapi->bp = bp;\r\n}\r\n}\r\nstatic int\r\nbnx2_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic int version_printed = 0;\r\nstruct net_device *dev;\r\nstruct bnx2 *bp;\r\nint rc;\r\nchar str[40];\r\nif (version_printed++ == 0)\r\npr_info("%s", version);\r\ndev = alloc_etherdev_mq(sizeof(*bp), TX_MAX_RINGS);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nrc = bnx2_init_board(pdev, dev);\r\nif (rc < 0)\r\ngoto err_free;\r\ndev->netdev_ops = &bnx2_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &bnx2_ethtool_ops;\r\nbp = netdev_priv(dev);\r\npci_set_drvdata(pdev, dev);\r\nmemcpy(dev->dev_addr, bp->mac_addr, ETH_ALEN);\r\ndev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |\r\nNETIF_F_TSO | NETIF_F_TSO_ECN |\r\nNETIF_F_RXHASH | NETIF_F_RXCSUM;\r\nif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\r\ndev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;\r\ndev->vlan_features = dev->hw_features;\r\ndev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\r\ndev->features |= dev->hw_features;\r\ndev->priv_flags |= IFF_UNICAST_FLT;\r\nif ((rc = register_netdev(dev))) {\r\ndev_err(&pdev->dev, "Cannot register net device\n");\r\ngoto error;\r\n}\r\nnetdev_info(dev, "%s (%c%d) %s found at mem %lx, IRQ %d, "\r\n"node addr %pM\n", board_info[ent->driver_data].name,\r\n((BNX2_CHIP_ID(bp) & 0xf000) >> 12) + 'A',\r\n((BNX2_CHIP_ID(bp) & 0x0ff0) >> 4),\r\nbnx2_bus_string(bp, str), (long)pci_resource_start(pdev, 0),\r\npdev->irq, dev->dev_addr);\r\nreturn 0;\r\nerror:\r\npci_iounmap(pdev, bp->regview);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nerr_free:\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nstatic void\r\nbnx2_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ndel_timer_sync(&bp->timer);\r\ncancel_work_sync(&bp->reset_task);\r\npci_iounmap(bp->pdev, bp->regview);\r\nkfree(bp->temp_stats_blk);\r\nif (bp->flags & BNX2_FLAG_AER_ENABLED) {\r\npci_disable_pcie_error_reporting(pdev);\r\nbp->flags &= ~BNX2_FLAG_AER_ENABLED;\r\n}\r\nbnx2_release_firmware(bp);\r\nfree_netdev(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int\r\nbnx2_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\ncancel_work_sync(&bp->reset_task);\r\nbnx2_netif_stop(bp, true);\r\nnetif_device_detach(dev);\r\ndel_timer_sync(&bp->timer);\r\nbnx2_shutdown_chip(bp);\r\n__bnx2_free_irq(bp);\r\nbnx2_free_skbs(bp);\r\n}\r\nbnx2_setup_wol(bp);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnx2_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nbnx2_set_power_state(bp, PCI_D0);\r\nnetif_device_attach(dev);\r\nbnx2_request_irq(bp);\r\nbnx2_init_nic(bp, 1);\r\nbnx2_netif_start(bp, true);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t bnx2_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nrtnl_lock();\r\nnetif_device_detach(dev);\r\nif (state == pci_channel_io_perm_failure) {\r\nrtnl_unlock();\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nif (netif_running(dev)) {\r\nbnx2_netif_stop(bp, true);\r\ndel_timer_sync(&bp->timer);\r\nbnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);\r\n}\r\npci_disable_device(pdev);\r\nrtnl_unlock();\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t bnx2_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\npci_ers_result_t result = PCI_ERS_RESULT_DISCONNECT;\r\nint err = 0;\r\nrtnl_lock();\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset\n");\r\n} else {\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (netif_running(dev))\r\nerr = bnx2_init_nic(bp, 1);\r\nif (!err)\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\nif (result != PCI_ERS_RESULT_RECOVERED && netif_running(dev)) {\r\nbnx2_napi_enable(bp);\r\ndev_close(dev);\r\n}\r\nrtnl_unlock();\r\nif (!(bp->flags & BNX2_FLAG_AER_ENABLED))\r\nreturn result;\r\nerr = pci_cleanup_aer_uncorrect_error_status(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"pci_cleanup_aer_uncorrect_error_status failed 0x%0x\n",\r\nerr);\r\n}\r\nreturn result;\r\n}\r\nstatic void bnx2_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nrtnl_lock();\r\nif (netif_running(dev))\r\nbnx2_netif_start(bp, true);\r\nnetif_device_attach(dev);\r\nrtnl_unlock();\r\n}\r\nstatic void bnx2_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2 *bp;\r\nif (!dev)\r\nreturn;\r\nbp = netdev_priv(dev);\r\nif (!bp)\r\nreturn;\r\nrtnl_lock();\r\nif (netif_running(dev))\r\ndev_close(bp->dev);\r\nif (system_state == SYSTEM_POWER_OFF)\r\nbnx2_set_power_state(bp, PCI_D3hot);\r\nrtnl_unlock();\r\n}
