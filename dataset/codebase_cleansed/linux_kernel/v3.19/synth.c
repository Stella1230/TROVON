int spk_serial_synth_probe(struct spk_synth *synth)\r\n{\r\nconst struct old_serial_port *ser;\r\nint failed = 0;\r\nif ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {\r\nser = spk_serial_init(synth->ser);\r\nif (ser == NULL) {\r\nfailed = -1;\r\n} else {\r\noutb_p(0, ser->port);\r\nmdelay(1);\r\noutb_p('\r', ser->port);\r\n}\r\n} else {\r\nfailed = -1;\r\npr_warn("ttyS%i is an invalid port\n", synth->ser);\r\n}\r\nif (failed) {\r\npr_info("%s: not found\n", synth->long_name);\r\nreturn -ENODEV;\r\n}\r\npr_info("%s: ttyS%i, Driver Version %s\n",\r\nsynth->long_name, synth->ser, synth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nvoid spk_do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nstruct var_t *delay_time;\r\nstruct var_t *full_time;\r\nstruct var_t *jiffy_delta;\r\nint jiffy_delta_val;\r\nint delay_time_val;\r\nint full_time_val;\r\njiffy_delta = spk_get_var(JIFFY);\r\nfull_time = spk_get_var(FULL);\r\ndelay_time = spk_get_var(DELAY);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nbreak;\r\n}\r\nch = synth_buffer_peek();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfull_time_val = full_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ch == '\n')\r\nch = synth->procspeech;\r\nif (!spk_serial_out(ch)) {\r\nschedule_timeout(msecs_to_jiffies(full_time_val));\r\ncontinue;\r\n}\r\nif (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nfull_time_val = full_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (spk_serial_out(synth->procspeech))\r\nschedule_timeout(\r\nmsecs_to_jiffies(delay_time_val));\r\nelse\r\nschedule_timeout(\r\nmsecs_to_jiffies(full_time_val));\r\njiff_max = jiffies + jiffy_delta_val;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nsynth_buffer_getc();\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\n}\r\nspk_serial_out(synth->procspeech);\r\n}\r\nconst char *spk_synth_immediate(struct spk_synth *synth, const char *buff)\r\n{\r\nu_char ch;\r\nwhile ((ch = *buff)) {\r\nif (ch == '\n')\r\nch = synth->procspeech;\r\nif (spk_wait_for_xmitr())\r\noutb(ch, speakup_info.port_tts);\r\nelse\r\nreturn buff;\r\nbuff++;\r\n}\r\nreturn NULL;\r\n}\r\nvoid spk_synth_flush(struct spk_synth *synth)\r\n{\r\nspk_serial_out(synth->clear);\r\n}\r\nint spk_synth_is_alive_nop(struct spk_synth *synth)\r\n{\r\nsynth->alive = 1;\r\nreturn 1;\r\n}\r\nint spk_synth_is_alive_restart(struct spk_synth *synth)\r\n{\r\nif (synth->alive)\r\nreturn 1;\r\nif (!synth->alive && spk_wait_for_xmitr() > 0) {\r\nsynth->alive = 1;\r\nsynth_printf("%s", synth->init);\r\nreturn 2;\r\n}\r\npr_warn("%s: can't restart synth\n", synth->long_name);\r\nreturn 0;\r\n}\r\nstatic void thread_wake_up(u_long data)\r\n{\r\nwake_up_interruptible_all(&speakup_event);\r\n}\r\nvoid synth_start(void)\r\n{\r\nstruct var_t *trigger_time;\r\nif (!synth->alive) {\r\nsynth_buffer_clear();\r\nreturn;\r\n}\r\ntrigger_time = spk_get_var(TRIGGER);\r\nif (!timer_pending(&thread_timer))\r\nmod_timer(&thread_timer, jiffies +\r\nmsecs_to_jiffies(trigger_time->u.n.value));\r\n}\r\nvoid spk_do_flush(void)\r\n{\r\nif (!synth)\r\nreturn;\r\nspeakup_info.flushing = 1;\r\nsynth_buffer_clear();\r\nif (synth->alive) {\r\nif (spk_pitch_shift) {\r\nsynth_printf("%s", spk_pitch_buff);\r\nspk_pitch_shift = 0;\r\n}\r\n}\r\nwake_up_interruptible_all(&speakup_event);\r\nwake_up_process(speakup_task);\r\n}\r\nvoid synth_write(const char *buf, size_t count)\r\n{\r\nwhile (count--)\r\nsynth_buffer_add(*buf++);\r\nsynth_start();\r\n}\r\nvoid synth_printf(const char *fmt, ...)\r\n{\r\nva_list args;\r\nunsigned char buf[160], *p;\r\nint r;\r\nva_start(args, fmt);\r\nr = vsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nif (r > sizeof(buf) - 1)\r\nr = sizeof(buf) - 1;\r\np = buf;\r\nwhile (r--)\r\nsynth_buffer_add(*p++);\r\nsynth_start();\r\n}\r\nvoid spk_reset_index_count(int sc)\r\n{\r\nstatic int first = 1;\r\nif (first)\r\nfirst = 0;\r\nelse\r\nsynth->get_index();\r\nindex_count = 0;\r\nsentence_count = sc;\r\n}\r\nint synth_supports_indexing(void)\r\n{\r\nif (synth->get_index != NULL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid synth_insert_next_index(int sent_num)\r\n{\r\nint out;\r\nif (synth->alive) {\r\nif (sent_num == 0) {\r\nsynth->indexing.currindex++;\r\nindex_count++;\r\nif (synth->indexing.currindex >\r\nsynth->indexing.highindex)\r\nsynth->indexing.currindex =\r\nsynth->indexing.lowindex;\r\n}\r\nout = synth->indexing.currindex * 10 + sent_num;\r\nsynth_printf(synth->indexing.command, out, out);\r\n}\r\n}\r\nvoid spk_get_index_count(int *linecount, int *sentcount)\r\n{\r\nint ind = synth->get_index();\r\nif (ind) {\r\nsentence_count = ind % 10;\r\nif ((ind / 10) <= synth->indexing.currindex)\r\nindex_count = synth->indexing.currindex-(ind/10);\r\nelse\r\nindex_count = synth->indexing.currindex\r\n-synth->indexing.lowindex\r\n+ synth->indexing.highindex-(ind/10)+1;\r\n}\r\n*sentcount = sentence_count;\r\n*linecount = index_count;\r\n}\r\nint synth_request_region(unsigned long start, unsigned long n)\r\n{\r\nstruct resource *parent = &ioport_resource;\r\nmemset(&synth_res, 0, sizeof(synth_res));\r\nsynth_res.name = synth->name;\r\nsynth_res.start = start;\r\nsynth_res.end = start + n - 1;\r\nsynth_res.flags = IORESOURCE_BUSY;\r\nreturn request_resource(parent, &synth_res);\r\n}\r\nint synth_release_region(unsigned long start, unsigned long n)\r\n{\r\nreturn release_resource(&synth_res);\r\n}\r\nint synth_init(char *synth_name)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct spk_synth *synth = NULL;\r\nif (synth_name == NULL)\r\nreturn 0;\r\nif (strcmp(synth_name, "none") == 0) {\r\nmutex_lock(&spk_mutex);\r\nsynth_release();\r\nmutex_unlock(&spk_mutex);\r\nreturn 0;\r\n}\r\nmutex_lock(&spk_mutex);\r\nfor (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)\r\nif (strcmp(synths[i]->name, synth_name) == 0)\r\nsynth = synths[i];\r\nif (synth)\r\nret = do_synth_init(synth);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&spk_mutex);\r\nreturn ret;\r\n}\r\nstatic int do_synth_init(struct spk_synth *in_synth)\r\n{\r\nstruct var_t *var;\r\nsynth_release();\r\nif (in_synth->checkval != SYNTH_CHECK)\r\nreturn -EINVAL;\r\nsynth = in_synth;\r\nsynth->alive = 0;\r\npr_warn("synth probe\n");\r\nif (synth->probe(synth) < 0) {\r\npr_warn("%s: device probe failed\n", in_synth->name);\r\nsynth = NULL;\r\nreturn -ENODEV;\r\n}\r\nsynth_time_vars[0].u.n.value =\r\nsynth_time_vars[0].u.n.default_val = synth->delay;\r\nsynth_time_vars[1].u.n.value =\r\nsynth_time_vars[1].u.n.default_val = synth->trigger;\r\nsynth_time_vars[2].u.n.value =\r\nsynth_time_vars[2].u.n.default_val = synth->jiffies;\r\nsynth_time_vars[3].u.n.value =\r\nsynth_time_vars[3].u.n.default_val = synth->full;\r\nsynth_printf("%s", synth->init);\r\nfor (var = synth->vars;\r\n(var->var_id >= 0) && (var->var_id < MAXVARS); var++)\r\nspeakup_register_var(var);\r\nif (!spk_quiet_boot)\r\nsynth_printf("%s found\n", synth->long_name);\r\nif (synth->attributes.name\r\n&& sysfs_create_group(speakup_kobj, &(synth->attributes)) < 0)\r\nreturn -ENOMEM;\r\nsynth_flags = synth->flags;\r\nwake_up_interruptible_all(&speakup_event);\r\nif (speakup_task)\r\nwake_up_process(speakup_task);\r\nreturn 0;\r\n}\r\nvoid synth_release(void)\r\n{\r\nstruct var_t *var;\r\nunsigned long flags;\r\nif (synth == NULL)\r\nreturn;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\npr_info("releasing synth %s\n", synth->name);\r\nsynth->alive = 0;\r\ndel_timer(&thread_timer);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (synth->attributes.name)\r\nsysfs_remove_group(speakup_kobj, &(synth->attributes));\r\nfor (var = synth->vars; var->var_id != MAXVARS; var++)\r\nspeakup_unregister_var(var->var_id);\r\nspk_stop_serial_interrupt();\r\nsynth->release();\r\nsynth = NULL;\r\n}\r\nint synth_add(struct spk_synth *in_synth)\r\n{\r\nint i;\r\nint status = 0;\r\nmutex_lock(&spk_mutex);\r\nfor (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)\r\nif (in_synth == synths[i]) {\r\nmutex_unlock(&spk_mutex);\r\nreturn 0;\r\n}\r\nif (i == MAXSYNTHS) {\r\npr_warn("Error: attempting to add a synth past end of array\n");\r\nmutex_unlock(&spk_mutex);\r\nreturn -1;\r\n}\r\nsynths[i++] = in_synth;\r\nsynths[i] = NULL;\r\nif (in_synth->startup)\r\nstatus = do_synth_init(in_synth);\r\nmutex_unlock(&spk_mutex);\r\nreturn status;\r\n}\r\nvoid synth_remove(struct spk_synth *in_synth)\r\n{\r\nint i;\r\nmutex_lock(&spk_mutex);\r\nif (synth == in_synth)\r\nsynth_release();\r\nfor (i = 0; synths[i] != NULL; i++) {\r\nif (in_synth == synths[i])\r\nbreak;\r\n}\r\nfor ( ; synths[i] != NULL; i++)\r\nsynths[i] = synths[i+1];\r\nmodule_status = 0;\r\nmutex_unlock(&spk_mutex);\r\n}
