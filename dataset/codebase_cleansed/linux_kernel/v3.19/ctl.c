static u64 get_route(struct tb_cfg_header header)\r\n{\r\nreturn (u64) header.route_hi << 32 | header.route_lo;\r\n}\r\nstatic struct tb_cfg_header make_header(u64 route)\r\n{\r\nstruct tb_cfg_header header = {\r\n.route_hi = route >> 32,\r\n.route_lo = route,\r\n};\r\nWARN_ON(get_route(header) != route);\r\nreturn header;\r\n}\r\nstatic int check_header(struct ctl_pkg *pkg, u32 len, enum tb_cfg_pkg_type type,\r\nu64 route)\r\n{\r\nstruct tb_cfg_header *header = pkg->buffer;\r\nif (WARN(len != pkg->frame.size,\r\n"wrong framesize (expected %#x, got %#x)\n",\r\nlen, pkg->frame.size))\r\nreturn -EIO;\r\nif (WARN(type != pkg->frame.eof, "wrong eof (expected %#x, got %#x)\n",\r\ntype, pkg->frame.eof))\r\nreturn -EIO;\r\nif (WARN(pkg->frame.sof, "wrong sof (expected 0x0, got %#x)\n",\r\npkg->frame.sof))\r\nreturn -EIO;\r\nif (WARN(header->unknown != 1 << 9,\r\n"header->unknown is %#x\n", header->unknown))\r\nreturn -EIO;\r\nif (WARN(route != get_route(*header),\r\n"wrong route (expected %llx, got %llx)",\r\nroute, get_route(*header)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int check_config_address(struct tb_cfg_address addr,\r\nenum tb_cfg_space space, u32 offset,\r\nu32 length)\r\n{\r\nif (WARN(addr.zero, "addr.zero is %#x\n", addr.zero))\r\nreturn -EIO;\r\nif (WARN(space != addr.space, "wrong space (expected %x, got %x\n)",\r\nspace, addr.space))\r\nreturn -EIO;\r\nif (WARN(offset != addr.offset, "wrong offset (expected %x, got %x\n)",\r\noffset, addr.offset))\r\nreturn -EIO;\r\nif (WARN(length != addr.length, "wrong space (expected %x, got %x\n)",\r\nlength, addr.length))\r\nreturn -EIO;\r\nif (WARN(addr.seq, "addr.seq is %#x\n", addr.seq))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic struct tb_cfg_result decode_error(struct ctl_pkg *response)\r\n{\r\nstruct cfg_error_pkg *pkg = response->buffer;\r\nstruct tb_cfg_result res = { 0 };\r\nres.response_route = get_route(pkg->header);\r\nres.response_port = 0;\r\nres.err = check_header(response, sizeof(*pkg), TB_CFG_PKG_ERROR,\r\nget_route(pkg->header));\r\nif (res.err)\r\nreturn res;\r\nWARN(pkg->zero1, "pkg->zero1 is %#x\n", pkg->zero1);\r\nWARN(pkg->zero2, "pkg->zero1 is %#x\n", pkg->zero1);\r\nWARN(pkg->zero3, "pkg->zero1 is %#x\n", pkg->zero1);\r\nres.err = 1;\r\nres.tb_error = pkg->error;\r\nres.response_port = pkg->port;\r\nreturn res;\r\n}\r\nstatic struct tb_cfg_result parse_header(struct ctl_pkg *pkg, u32 len,\r\nenum tb_cfg_pkg_type type, u64 route)\r\n{\r\nstruct tb_cfg_header *header = pkg->buffer;\r\nstruct tb_cfg_result res = { 0 };\r\nif (pkg->frame.eof == TB_CFG_PKG_ERROR)\r\nreturn decode_error(pkg);\r\nres.response_port = 0;\r\nres.response_route = get_route(*header);\r\nres.err = check_header(pkg, len, type, route);\r\nreturn res;\r\n}\r\nstatic void tb_cfg_print_error(struct tb_ctl *ctl,\r\nconst struct tb_cfg_result *res)\r\n{\r\nWARN_ON(res->err != 1);\r\nswitch (res->tb_error) {\r\ncase TB_CFG_ERROR_PORT_NOT_CONNECTED:\r\nreturn;\r\ncase TB_CFG_ERROR_INVALID_CONFIG_SPACE:\r\ntb_ctl_WARN(ctl,\r\n"CFG_ERROR(%llx:%x): Invalid config space of offset\n",\r\nres->response_route, res->response_port);\r\nreturn;\r\ncase TB_CFG_ERROR_NO_SUCH_PORT:\r\ntb_ctl_WARN(ctl, "CFG_ERROR(%llx:%x): Invalid port\n",\r\nres->response_route, res->response_port);\r\nreturn;\r\ncase TB_CFG_ERROR_LOOP:\r\ntb_ctl_WARN(ctl, "CFG_ERROR(%llx:%x): Route contains a loop\n",\r\nres->response_route, res->response_port);\r\nreturn;\r\ndefault:\r\ntb_ctl_WARN(ctl, "CFG_ERROR(%llx:%x): Unknown error\n",\r\nres->response_route, res->response_port);\r\nreturn;\r\n}\r\n}\r\nstatic void cpu_to_be32_array(__be32 *dst, u32 *src, size_t len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\ndst[i] = cpu_to_be32(src[i]);\r\n}\r\nstatic void be32_to_cpu_array(u32 *dst, __be32 *src, size_t len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\ndst[i] = be32_to_cpu(src[i]);\r\n}\r\nstatic __be32 tb_crc(void *data, size_t len)\r\n{\r\nreturn cpu_to_be32(~__crc32c_le(~0, data, len));\r\n}\r\nstatic void tb_ctl_pkg_free(struct ctl_pkg *pkg)\r\n{\r\nif (pkg) {\r\ndma_pool_free(pkg->ctl->frame_pool,\r\npkg->buffer, pkg->frame.buffer_phy);\r\nkfree(pkg);\r\n}\r\n}\r\nstatic struct ctl_pkg *tb_ctl_pkg_alloc(struct tb_ctl *ctl)\r\n{\r\nstruct ctl_pkg *pkg = kzalloc(sizeof(*pkg), GFP_KERNEL);\r\nif (!pkg)\r\nreturn NULL;\r\npkg->ctl = ctl;\r\npkg->buffer = dma_pool_alloc(ctl->frame_pool, GFP_KERNEL,\r\n&pkg->frame.buffer_phy);\r\nif (!pkg->buffer) {\r\nkfree(pkg);\r\nreturn NULL;\r\n}\r\nreturn pkg;\r\n}\r\nstatic void tb_ctl_tx_callback(struct tb_ring *ring, struct ring_frame *frame,\r\nbool canceled)\r\n{\r\nstruct ctl_pkg *pkg = container_of(frame, typeof(*pkg), frame);\r\ntb_ctl_pkg_free(pkg);\r\n}\r\nstatic int tb_ctl_tx(struct tb_ctl *ctl, void *data, size_t len,\r\nenum tb_cfg_pkg_type type)\r\n{\r\nint res;\r\nstruct ctl_pkg *pkg;\r\nif (len % 4 != 0) {\r\ntb_ctl_WARN(ctl, "TX: invalid size: %zu\n", len);\r\nreturn -EINVAL;\r\n}\r\nif (len > TB_FRAME_SIZE - 4) {\r\ntb_ctl_WARN(ctl, "TX: packet too large: %zu/%d\n",\r\nlen, TB_FRAME_SIZE - 4);\r\nreturn -EINVAL;\r\n}\r\npkg = tb_ctl_pkg_alloc(ctl);\r\nif (!pkg)\r\nreturn -ENOMEM;\r\npkg->frame.callback = tb_ctl_tx_callback;\r\npkg->frame.size = len + 4;\r\npkg->frame.sof = type;\r\npkg->frame.eof = type;\r\ncpu_to_be32_array(pkg->buffer, data, len / 4);\r\n*(__be32 *) (pkg->buffer + len) = tb_crc(pkg->buffer, len);\r\nres = ring_tx(ctl->tx, &pkg->frame);\r\nif (res)\r\ntb_ctl_pkg_free(pkg);\r\nreturn res;\r\n}\r\nstatic void tb_ctl_handle_plug_event(struct tb_ctl *ctl,\r\nstruct ctl_pkg *response)\r\n{\r\nstruct cfg_event_pkg *pkg = response->buffer;\r\nu64 route = get_route(pkg->header);\r\nif (check_header(response, sizeof(*pkg), TB_CFG_PKG_EVENT, route)) {\r\ntb_ctl_warn(ctl, "malformed TB_CFG_PKG_EVENT\n");\r\nreturn;\r\n}\r\nif (tb_cfg_error(ctl, route, pkg->port, TB_CFG_ERROR_ACK_PLUG_EVENT))\r\ntb_ctl_warn(ctl, "could not ack plug event on %llx:%x\n",\r\nroute, pkg->port);\r\nWARN(pkg->zero, "pkg->zero is %#x\n", pkg->zero);\r\nctl->callback(ctl->callback_data, route, pkg->port, pkg->unplug);\r\n}\r\nstatic void tb_ctl_rx_submit(struct ctl_pkg *pkg)\r\n{\r\nring_rx(pkg->ctl->rx, &pkg->frame);\r\n}\r\nstatic void tb_ctl_rx_callback(struct tb_ring *ring, struct ring_frame *frame,\r\nbool canceled)\r\n{\r\nstruct ctl_pkg *pkg = container_of(frame, typeof(*pkg), frame);\r\nif (canceled)\r\nreturn;\r\nif (frame->size < 4 || frame->size % 4 != 0) {\r\ntb_ctl_err(pkg->ctl, "RX: invalid size %#x, dropping packet\n",\r\nframe->size);\r\ngoto rx;\r\n}\r\nframe->size -= 4;\r\nif (*(__be32 *) (pkg->buffer + frame->size)\r\n!= tb_crc(pkg->buffer, frame->size)) {\r\ntb_ctl_err(pkg->ctl,\r\n"RX: checksum mismatch, dropping packet\n");\r\ngoto rx;\r\n}\r\nbe32_to_cpu_array(pkg->buffer, pkg->buffer, frame->size / 4);\r\nif (frame->eof == TB_CFG_PKG_EVENT) {\r\ntb_ctl_handle_plug_event(pkg->ctl, pkg);\r\ngoto rx;\r\n}\r\nif (!kfifo_put(&pkg->ctl->response_fifo, pkg)) {\r\ntb_ctl_err(pkg->ctl, "RX: fifo is full\n");\r\ngoto rx;\r\n}\r\ncomplete(&pkg->ctl->response_ready);\r\nreturn;\r\nrx:\r\ntb_ctl_rx_submit(pkg);\r\n}\r\nstatic struct tb_cfg_result tb_ctl_rx(struct tb_ctl *ctl, void *buffer,\r\nsize_t length, int timeout_msec,\r\nu64 route, enum tb_cfg_pkg_type type)\r\n{\r\nstruct tb_cfg_result res;\r\nstruct ctl_pkg *pkg;\r\nif (!wait_for_completion_timeout(&ctl->response_ready,\r\nmsecs_to_jiffies(timeout_msec))) {\r\ntb_ctl_WARN(ctl, "RX: timeout\n");\r\nreturn (struct tb_cfg_result) { .err = -ETIMEDOUT };\r\n}\r\nif (!kfifo_get(&ctl->response_fifo, &pkg)) {\r\ntb_ctl_WARN(ctl, "empty kfifo\n");\r\nreturn (struct tb_cfg_result) { .err = -EIO };\r\n}\r\nres = parse_header(pkg, length, type, route);\r\nif (!res.err)\r\nmemcpy(buffer, pkg->buffer, length);\r\ntb_ctl_rx_submit(pkg);\r\nreturn res;\r\n}\r\nstruct tb_ctl *tb_ctl_alloc(struct tb_nhi *nhi, hotplug_cb cb, void *cb_data)\r\n{\r\nint i;\r\nstruct tb_ctl *ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\r\nif (!ctl)\r\nreturn NULL;\r\nctl->nhi = nhi;\r\nctl->callback = cb;\r\nctl->callback_data = cb_data;\r\ninit_completion(&ctl->response_ready);\r\nINIT_KFIFO(ctl->response_fifo);\r\nctl->frame_pool = dma_pool_create("thunderbolt_ctl", &nhi->pdev->dev,\r\nTB_FRAME_SIZE, 4, 0);\r\nif (!ctl->frame_pool)\r\ngoto err;\r\nctl->tx = ring_alloc_tx(nhi, 0, 10);\r\nif (!ctl->tx)\r\ngoto err;\r\nctl->rx = ring_alloc_rx(nhi, 0, 10);\r\nif (!ctl->rx)\r\ngoto err;\r\nfor (i = 0; i < TB_CTL_RX_PKG_COUNT; i++) {\r\nctl->rx_packets[i] = tb_ctl_pkg_alloc(ctl);\r\nif (!ctl->rx_packets[i])\r\ngoto err;\r\nctl->rx_packets[i]->frame.callback = tb_ctl_rx_callback;\r\n}\r\ntb_ctl_info(ctl, "control channel created\n");\r\nreturn ctl;\r\nerr:\r\ntb_ctl_free(ctl);\r\nreturn NULL;\r\n}\r\nvoid tb_ctl_free(struct tb_ctl *ctl)\r\n{\r\nint i;\r\nif (ctl->rx)\r\nring_free(ctl->rx);\r\nif (ctl->tx)\r\nring_free(ctl->tx);\r\nfor (i = 0; i < TB_CTL_RX_PKG_COUNT; i++)\r\ntb_ctl_pkg_free(ctl->rx_packets[i]);\r\nif (ctl->frame_pool)\r\ndma_pool_destroy(ctl->frame_pool);\r\nkfree(ctl);\r\n}\r\nvoid tb_ctl_start(struct tb_ctl *ctl)\r\n{\r\nint i;\r\ntb_ctl_info(ctl, "control channel starting...\n");\r\nring_start(ctl->tx);\r\nring_start(ctl->rx);\r\nfor (i = 0; i < TB_CTL_RX_PKG_COUNT; i++)\r\ntb_ctl_rx_submit(ctl->rx_packets[i]);\r\n}\r\nvoid tb_ctl_stop(struct tb_ctl *ctl)\r\n{\r\nring_stop(ctl->rx);\r\nring_stop(ctl->tx);\r\nif (!kfifo_is_empty(&ctl->response_fifo))\r\ntb_ctl_WARN(ctl, "dangling response in response_fifo\n");\r\nkfifo_reset(&ctl->response_fifo);\r\ntb_ctl_info(ctl, "control channel stopped\n");\r\n}\r\nint tb_cfg_error(struct tb_ctl *ctl, u64 route, u32 port,\r\nenum tb_cfg_error error)\r\n{\r\nstruct cfg_error_pkg pkg = {\r\n.header = make_header(route),\r\n.port = port,\r\n.error = error,\r\n};\r\ntb_ctl_info(ctl, "resetting error on %llx:%x.\n", route, port);\r\nreturn tb_ctl_tx(ctl, &pkg, sizeof(pkg), TB_CFG_PKG_ERROR);\r\n}\r\nstruct tb_cfg_result tb_cfg_reset(struct tb_ctl *ctl, u64 route,\r\nint timeout_msec)\r\n{\r\nint err;\r\nstruct cfg_reset_pkg request = { .header = make_header(route) };\r\nstruct tb_cfg_header reply;\r\nerr = tb_ctl_tx(ctl, &request, sizeof(request), TB_CFG_PKG_RESET);\r\nif (err)\r\nreturn (struct tb_cfg_result) { .err = err };\r\nreturn tb_ctl_rx(ctl, &reply, sizeof(reply), timeout_msec, route,\r\nTB_CFG_PKG_RESET);\r\n}\r\nstruct tb_cfg_result tb_cfg_read_raw(struct tb_ctl *ctl, void *buffer,\r\nu64 route, u32 port, enum tb_cfg_space space,\r\nu32 offset, u32 length, int timeout_msec)\r\n{\r\nstruct tb_cfg_result res = { 0 };\r\nstruct cfg_read_pkg request = {\r\n.header = make_header(route),\r\n.addr = {\r\n.port = port,\r\n.space = space,\r\n.offset = offset,\r\n.length = length,\r\n},\r\n};\r\nstruct cfg_write_pkg reply;\r\nres.err = tb_ctl_tx(ctl, &request, sizeof(request), TB_CFG_PKG_READ);\r\nif (res.err)\r\nreturn res;\r\nres = tb_ctl_rx(ctl, &reply, 12 + 4 * length, timeout_msec, route,\r\nTB_CFG_PKG_READ);\r\nif (res.err)\r\nreturn res;\r\nres.response_port = reply.addr.port;\r\nres.err = check_config_address(reply.addr, space, offset, length);\r\nif (!res.err)\r\nmemcpy(buffer, &reply.data, 4 * length);\r\nreturn res;\r\n}\r\nstruct tb_cfg_result tb_cfg_write_raw(struct tb_ctl *ctl, void *buffer,\r\nu64 route, u32 port, enum tb_cfg_space space,\r\nu32 offset, u32 length, int timeout_msec)\r\n{\r\nstruct tb_cfg_result res = { 0 };\r\nstruct cfg_write_pkg request = {\r\n.header = make_header(route),\r\n.addr = {\r\n.port = port,\r\n.space = space,\r\n.offset = offset,\r\n.length = length,\r\n},\r\n};\r\nstruct cfg_read_pkg reply;\r\nmemcpy(&request.data, buffer, length * 4);\r\nres.err = tb_ctl_tx(ctl, &request, 12 + 4 * length, TB_CFG_PKG_WRITE);\r\nif (res.err)\r\nreturn res;\r\nres = tb_ctl_rx(ctl, &reply, sizeof(reply), timeout_msec, route,\r\nTB_CFG_PKG_WRITE);\r\nif (res.err)\r\nreturn res;\r\nres.response_port = reply.addr.port;\r\nres.err = check_config_address(reply.addr, space, offset, length);\r\nreturn res;\r\n}\r\nint tb_cfg_read(struct tb_ctl *ctl, void *buffer, u64 route, u32 port,\r\nenum tb_cfg_space space, u32 offset, u32 length)\r\n{\r\nstruct tb_cfg_result res = tb_cfg_read_raw(ctl, buffer, route, port,\r\nspace, offset, length, TB_CFG_DEFAULT_TIMEOUT);\r\nif (res.err == 1) {\r\ntb_cfg_print_error(ctl, &res);\r\nreturn -EIO;\r\n}\r\nWARN(res.err, "tb_cfg_read: %d\n", res.err);\r\nreturn res.err;\r\n}\r\nint tb_cfg_write(struct tb_ctl *ctl, void *buffer, u64 route, u32 port,\r\nenum tb_cfg_space space, u32 offset, u32 length)\r\n{\r\nstruct tb_cfg_result res = tb_cfg_write_raw(ctl, buffer, route, port,\r\nspace, offset, length, TB_CFG_DEFAULT_TIMEOUT);\r\nif (res.err == 1) {\r\ntb_cfg_print_error(ctl, &res);\r\nreturn -EIO;\r\n}\r\nWARN(res.err, "tb_cfg_write: %d\n", res.err);\r\nreturn res.err;\r\n}\r\nint tb_cfg_get_upstream_port(struct tb_ctl *ctl, u64 route)\r\n{\r\nu32 dummy;\r\nstruct tb_cfg_result res = tb_cfg_read_raw(ctl, &dummy, route, 0,\r\nTB_CFG_SWITCH, 0, 1,\r\nTB_CFG_DEFAULT_TIMEOUT);\r\nif (res.err == 1)\r\nreturn -EIO;\r\nif (res.err)\r\nreturn res.err;\r\nreturn res.response_port;\r\n}
