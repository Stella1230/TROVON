static inline void print_max_stack(void)\r\n{\r\nlong i;\r\nint size;\r\npr_emerg(" Depth Size Location (%d entries)\n"\r\n" ----- ---- --------\n",\r\nmax_stack_trace.nr_entries - 1);\r\nfor (i = 0; i < max_stack_trace.nr_entries; i++) {\r\nif (stack_dump_trace[i] == ULONG_MAX)\r\nbreak;\r\nif (i+1 == max_stack_trace.nr_entries ||\r\nstack_dump_trace[i+1] == ULONG_MAX)\r\nsize = stack_dump_index[i];\r\nelse\r\nsize = stack_dump_index[i] - stack_dump_index[i+1];\r\npr_emerg("%3ld) %8d %5d %pS\n", i, stack_dump_index[i],\r\nsize, (void *)stack_dump_trace[i]);\r\n}\r\n}\r\nstatic inline void\r\ncheck_stack(unsigned long ip, unsigned long *stack)\r\n{\r\nunsigned long this_size, flags; unsigned long *p, *top, *start;\r\nstatic int tracer_frame;\r\nint frame_size = ACCESS_ONCE(tracer_frame);\r\nint i;\r\nthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\r\nthis_size = THREAD_SIZE - this_size;\r\nthis_size -= frame_size;\r\nif (this_size <= max_stack_size)\r\nreturn;\r\nif (!object_is_on_stack(stack))\r\nreturn;\r\nlocal_irq_save(flags);\r\narch_spin_lock(&max_stack_lock);\r\nif (unlikely(!frame_size))\r\nthis_size -= tracer_frame;\r\nif (this_size <= max_stack_size)\r\ngoto out;\r\nmax_stack_size = this_size;\r\nmax_stack_trace.nr_entries = 0;\r\nif (using_ftrace_ops_list_func())\r\nmax_stack_trace.skip = 4;\r\nelse\r\nmax_stack_trace.skip = 3;\r\nsave_stack_trace(&max_stack_trace);\r\nstack_dump_trace[0] = ip;\r\nmax_stack_trace.nr_entries++;\r\ni = 0;\r\nstart = stack;\r\ntop = (unsigned long *)\r\n(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\r\nwhile (i < max_stack_trace.nr_entries) {\r\nint found = 0;\r\nstack_dump_index[i] = this_size;\r\np = start;\r\nfor (; p < top && i < max_stack_trace.nr_entries; p++) {\r\nif (*p == stack_dump_trace[i]) {\r\nthis_size = stack_dump_index[i++] =\r\n(top - p) * sizeof(unsigned long);\r\nfound = 1;\r\nstart = p + 1;\r\nif (unlikely(!tracer_frame) && i == 1) {\r\ntracer_frame = (p - stack) *\r\nsizeof(unsigned long);\r\nmax_stack_size -= tracer_frame;\r\n}\r\n}\r\n}\r\nif (!found)\r\ni++;\r\n}\r\nif (task_stack_end_corrupted(current)) {\r\nprint_max_stack();\r\nBUG();\r\n}\r\nout:\r\narch_spin_unlock(&max_stack_lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\r\nstruct ftrace_ops *op, struct pt_regs *pt_regs)\r\n{\r\nunsigned long stack;\r\nint cpu;\r\npreempt_disable_notrace();\r\ncpu = raw_smp_processor_id();\r\nif (per_cpu(trace_active, cpu)++ != 0)\r\ngoto out;\r\nif (fentry)\r\nip = parent_ip;\r\nelse\r\nip += MCOUNT_INSN_SIZE;\r\ncheck_stack(ip, &stack);\r\nout:\r\nper_cpu(trace_active, cpu)--;\r\npreempt_enable_notrace();\r\n}\r\nstatic ssize_t\r\nstack_max_size_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long *ptr = filp->private_data;\r\nchar buf[64];\r\nint r;\r\nr = snprintf(buf, sizeof(buf), "%ld\n", *ptr);\r\nif (r > sizeof(buf))\r\nr = sizeof(buf);\r\nreturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\r\n}\r\nstatic ssize_t\r\nstack_max_size_write(struct file *filp, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nlong *ptr = filp->private_data;\r\nunsigned long val, flags;\r\nint ret;\r\nint cpu;\r\nret = kstrtoul_from_user(ubuf, count, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nlocal_irq_save(flags);\r\ncpu = smp_processor_id();\r\nper_cpu(trace_active, cpu)++;\r\narch_spin_lock(&max_stack_lock);\r\n*ptr = val;\r\narch_spin_unlock(&max_stack_lock);\r\nper_cpu(trace_active, cpu)--;\r\nlocal_irq_restore(flags);\r\nreturn count;\r\n}\r\nstatic void *\r\n__next(struct seq_file *m, loff_t *pos)\r\n{\r\nlong n = *pos - 1;\r\nif (n >= max_stack_trace.nr_entries || stack_dump_trace[n] == ULONG_MAX)\r\nreturn NULL;\r\nm->private = (void *)n;\r\nreturn &m->private;\r\n}\r\nstatic void *\r\nt_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn __next(m, pos);\r\n}\r\nstatic void *t_start(struct seq_file *m, loff_t *pos)\r\n{\r\nint cpu;\r\nlocal_irq_disable();\r\ncpu = smp_processor_id();\r\nper_cpu(trace_active, cpu)++;\r\narch_spin_lock(&max_stack_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nreturn __next(m, pos);\r\n}\r\nstatic void t_stop(struct seq_file *m, void *p)\r\n{\r\nint cpu;\r\narch_spin_unlock(&max_stack_lock);\r\ncpu = smp_processor_id();\r\nper_cpu(trace_active, cpu)--;\r\nlocal_irq_enable();\r\n}\r\nstatic int trace_lookup_stack(struct seq_file *m, long i)\r\n{\r\nunsigned long addr = stack_dump_trace[i];\r\nreturn seq_printf(m, "%pS\n", (void *)addr);\r\n}\r\nstatic void print_disabled(struct seq_file *m)\r\n{\r\nseq_puts(m, "#\n"\r\n"# Stack tracer disabled\n"\r\n"#\n"\r\n"# To enable the stack tracer, either add 'stacktrace' to the\n"\r\n"# kernel command line\n"\r\n"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\n"\r\n"#\n");\r\n}\r\nstatic int t_show(struct seq_file *m, void *v)\r\n{\r\nlong i;\r\nint size;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(m, " Depth Size Location"\r\n" (%d entries)\n"\r\n" ----- ---- --------\n",\r\nmax_stack_trace.nr_entries - 1);\r\nif (!stack_tracer_enabled && !max_stack_size)\r\nprint_disabled(m);\r\nreturn 0;\r\n}\r\ni = *(long *)v;\r\nif (i >= max_stack_trace.nr_entries ||\r\nstack_dump_trace[i] == ULONG_MAX)\r\nreturn 0;\r\nif (i+1 == max_stack_trace.nr_entries ||\r\nstack_dump_trace[i+1] == ULONG_MAX)\r\nsize = stack_dump_index[i];\r\nelse\r\nsize = stack_dump_index[i] - stack_dump_index[i+1];\r\nseq_printf(m, "%3ld) %8d %5d ", i, stack_dump_index[i], size);\r\ntrace_lookup_stack(m, i);\r\nreturn 0;\r\n}\r\nstatic int stack_trace_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &stack_trace_seq_ops);\r\n}\r\nstatic int\r\nstack_trace_filter_open(struct inode *inode, struct file *file)\r\n{\r\nreturn ftrace_regex_open(&trace_ops, FTRACE_ITER_FILTER,\r\ninode, file);\r\n}\r\nint\r\nstack_trace_sysctl(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nint ret;\r\nmutex_lock(&stack_sysctl_mutex);\r\nret = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (ret || !write ||\r\n(last_stack_tracer_enabled == !!stack_tracer_enabled))\r\ngoto out;\r\nlast_stack_tracer_enabled = !!stack_tracer_enabled;\r\nif (stack_tracer_enabled)\r\nregister_ftrace_function(&trace_ops);\r\nelse\r\nunregister_ftrace_function(&trace_ops);\r\nout:\r\nmutex_unlock(&stack_sysctl_mutex);\r\nreturn ret;\r\n}\r\nstatic __init int enable_stacktrace(char *str)\r\n{\r\nif (strncmp(str, "_filter=", 8) == 0)\r\nstrncpy(stack_trace_filter_buf, str+8, COMMAND_LINE_SIZE);\r\nstack_tracer_enabled = 1;\r\nlast_stack_tracer_enabled = 1;\r\nreturn 1;\r\n}\r\nstatic __init int stack_trace_init(void)\r\n{\r\nstruct dentry *d_tracer;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\ntrace_create_file("stack_max_size", 0644, d_tracer,\r\n&max_stack_size, &stack_max_size_fops);\r\ntrace_create_file("stack_trace", 0444, d_tracer,\r\nNULL, &stack_trace_fops);\r\ntrace_create_file("stack_trace_filter", 0444, d_tracer,\r\nNULL, &stack_trace_filter_fops);\r\nif (stack_trace_filter_buf[0])\r\nftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);\r\nif (stack_tracer_enabled)\r\nregister_ftrace_function(&trace_ops);\r\nreturn 0;\r\n}
