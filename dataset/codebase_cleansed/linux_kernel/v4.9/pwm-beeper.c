static void __pwm_beeper_set(struct pwm_beeper *beeper)\r\n{\r\nunsigned long period = beeper->period;\r\nif (period) {\r\npwm_config(beeper->pwm, period / 2, period);\r\npwm_enable(beeper->pwm);\r\n} else\r\npwm_disable(beeper->pwm);\r\n}\r\nstatic void pwm_beeper_work(struct work_struct *work)\r\n{\r\nstruct pwm_beeper *beeper =\r\ncontainer_of(work, struct pwm_beeper, work);\r\n__pwm_beeper_set(beeper);\r\n}\r\nstatic int pwm_beeper_event(struct input_dev *input,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct pwm_beeper *beeper = input_get_drvdata(input);\r\nif (type != EV_SND || value < 0)\r\nreturn -EINVAL;\r\nswitch (code) {\r\ncase SND_BELL:\r\nvalue = value ? 1000 : 0;\r\nbreak;\r\ncase SND_TONE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (value == 0)\r\nbeeper->period = 0;\r\nelse\r\nbeeper->period = HZ_TO_NANOSECONDS(value);\r\nschedule_work(&beeper->work);\r\nreturn 0;\r\n}\r\nstatic void pwm_beeper_stop(struct pwm_beeper *beeper)\r\n{\r\ncancel_work_sync(&beeper->work);\r\nif (beeper->period)\r\npwm_disable(beeper->pwm);\r\n}\r\nstatic void pwm_beeper_close(struct input_dev *input)\r\n{\r\nstruct pwm_beeper *beeper = input_get_drvdata(input);\r\npwm_beeper_stop(beeper);\r\n}\r\nstatic int pwm_beeper_probe(struct platform_device *pdev)\r\n{\r\nunsigned long pwm_id = (unsigned long)dev_get_platdata(&pdev->dev);\r\nstruct pwm_beeper *beeper;\r\nint error;\r\nbeeper = kzalloc(sizeof(*beeper), GFP_KERNEL);\r\nif (!beeper)\r\nreturn -ENOMEM;\r\nbeeper->pwm = pwm_get(&pdev->dev, NULL);\r\nif (IS_ERR(beeper->pwm)) {\r\ndev_dbg(&pdev->dev, "unable to request PWM, trying legacy API\n");\r\nbeeper->pwm = pwm_request(pwm_id, "pwm beeper");\r\n}\r\nif (IS_ERR(beeper->pwm)) {\r\nerror = PTR_ERR(beeper->pwm);\r\ndev_err(&pdev->dev, "Failed to request pwm device: %d\n", error);\r\ngoto err_free;\r\n}\r\npwm_apply_args(beeper->pwm);\r\nINIT_WORK(&beeper->work, pwm_beeper_work);\r\nbeeper->input = input_allocate_device();\r\nif (!beeper->input) {\r\ndev_err(&pdev->dev, "Failed to allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto err_pwm_free;\r\n}\r\nbeeper->input->dev.parent = &pdev->dev;\r\nbeeper->input->name = "pwm-beeper";\r\nbeeper->input->phys = "pwm/input0";\r\nbeeper->input->id.bustype = BUS_HOST;\r\nbeeper->input->id.vendor = 0x001f;\r\nbeeper->input->id.product = 0x0001;\r\nbeeper->input->id.version = 0x0100;\r\nbeeper->input->evbit[0] = BIT(EV_SND);\r\nbeeper->input->sndbit[0] = BIT(SND_TONE) | BIT(SND_BELL);\r\nbeeper->input->event = pwm_beeper_event;\r\nbeeper->input->close = pwm_beeper_close;\r\ninput_set_drvdata(beeper->input, beeper);\r\nerror = input_register_device(beeper->input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to register input device: %d\n", error);\r\ngoto err_input_free;\r\n}\r\nplatform_set_drvdata(pdev, beeper);\r\nreturn 0;\r\nerr_input_free:\r\ninput_free_device(beeper->input);\r\nerr_pwm_free:\r\npwm_free(beeper->pwm);\r\nerr_free:\r\nkfree(beeper);\r\nreturn error;\r\n}\r\nstatic int pwm_beeper_remove(struct platform_device *pdev)\r\n{\r\nstruct pwm_beeper *beeper = platform_get_drvdata(pdev);\r\ninput_unregister_device(beeper->input);\r\npwm_free(beeper->pwm);\r\nkfree(beeper);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused pwm_beeper_suspend(struct device *dev)\r\n{\r\nstruct pwm_beeper *beeper = dev_get_drvdata(dev);\r\npwm_beeper_stop(beeper);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused pwm_beeper_resume(struct device *dev)\r\n{\r\nstruct pwm_beeper *beeper = dev_get_drvdata(dev);\r\nif (beeper->period)\r\n__pwm_beeper_set(beeper);\r\nreturn 0;\r\n}
