static int gs_buf_alloc(struct gs_buf *gb, unsigned size)\r\n{\r\ngb->buf_buf = kmalloc(size, GFP_KERNEL);\r\nif (gb->buf_buf == NULL)\r\nreturn -ENOMEM;\r\ngb->buf_size = size;\r\ngb->buf_put = gb->buf_buf;\r\ngb->buf_get = gb->buf_buf;\r\nreturn 0;\r\n}\r\nstatic void gs_buf_free(struct gs_buf *gb)\r\n{\r\nkfree(gb->buf_buf);\r\ngb->buf_buf = NULL;\r\n}\r\nstatic void gs_buf_clear(struct gs_buf *gb)\r\n{\r\ngb->buf_get = gb->buf_put;\r\n}\r\nstatic unsigned gs_buf_data_avail(struct gs_buf *gb)\r\n{\r\nreturn (gb->buf_size + gb->buf_put - gb->buf_get) % gb->buf_size;\r\n}\r\nstatic unsigned gs_buf_space_avail(struct gs_buf *gb)\r\n{\r\nreturn (gb->buf_size + gb->buf_get - gb->buf_put - 1) % gb->buf_size;\r\n}\r\nstatic unsigned\r\ngs_buf_put(struct gs_buf *gb, const char *buf, unsigned count)\r\n{\r\nunsigned len;\r\nlen = gs_buf_space_avail(gb);\r\nif (count > len)\r\ncount = len;\r\nif (count == 0)\r\nreturn 0;\r\nlen = gb->buf_buf + gb->buf_size - gb->buf_put;\r\nif (count > len) {\r\nmemcpy(gb->buf_put, buf, len);\r\nmemcpy(gb->buf_buf, buf+len, count - len);\r\ngb->buf_put = gb->buf_buf + count - len;\r\n} else {\r\nmemcpy(gb->buf_put, buf, count);\r\nif (count < len)\r\ngb->buf_put += count;\r\nelse\r\ngb->buf_put = gb->buf_buf;\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned\r\ngs_buf_get(struct gs_buf *gb, char *buf, unsigned count)\r\n{\r\nunsigned len;\r\nlen = gs_buf_data_avail(gb);\r\nif (count > len)\r\ncount = len;\r\nif (count == 0)\r\nreturn 0;\r\nlen = gb->buf_buf + gb->buf_size - gb->buf_get;\r\nif (count > len) {\r\nmemcpy(buf, gb->buf_get, len);\r\nmemcpy(buf+len, gb->buf_buf, count - len);\r\ngb->buf_get = gb->buf_buf + count - len;\r\n} else {\r\nmemcpy(buf, gb->buf_get, count);\r\nif (count < len)\r\ngb->buf_get += count;\r\nelse\r\ngb->buf_get = gb->buf_buf;\r\n}\r\nreturn count;\r\n}\r\nstruct usb_request *\r\ngs_alloc_req(struct usb_ep *ep, unsigned len, gfp_t kmalloc_flags)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, kmalloc_flags);\r\nif (req != NULL) {\r\nreq->length = len;\r\nreq->buf = kmalloc(len, kmalloc_flags);\r\nif (req->buf == NULL) {\r\nusb_ep_free_request(ep, req);\r\nreturn NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nvoid gs_free_req(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic unsigned\r\ngs_send_packet(struct gs_port *port, char *packet, unsigned size)\r\n{\r\nunsigned len;\r\nlen = gs_buf_data_avail(&port->port_write_buf);\r\nif (len < size)\r\nsize = len;\r\nif (size != 0)\r\nsize = gs_buf_get(&port->port_write_buf, packet, size);\r\nreturn size;\r\n}\r\nstatic int gs_start_tx(struct gs_port *port)\r\n{\r\nstruct list_head *pool = &port->write_pool;\r\nstruct usb_ep *in;\r\nint status = 0;\r\nbool do_tty_wake = false;\r\nif (!port->port_usb)\r\nreturn status;\r\nin = port->port_usb->in;\r\nwhile (!port->write_busy && !list_empty(pool)) {\r\nstruct usb_request *req;\r\nint len;\r\nif (port->write_started >= QUEUE_SIZE)\r\nbreak;\r\nreq = list_entry(pool->next, struct usb_request, list);\r\nlen = gs_send_packet(port, req->buf, in->maxpacket);\r\nif (len == 0) {\r\nwake_up_interruptible(&port->drain_wait);\r\nbreak;\r\n}\r\ndo_tty_wake = true;\r\nreq->length = len;\r\nlist_del(&req->list);\r\nreq->zero = (gs_buf_data_avail(&port->port_write_buf) == 0);\r\npr_vdebug("ttyGS%d: tx len=%d, 0x%02x 0x%02x 0x%02x ...\n",\r\nport->port_num, len, *((u8 *)req->buf),\r\n*((u8 *)req->buf+1), *((u8 *)req->buf+2));\r\nport->write_busy = true;\r\nspin_unlock(&port->port_lock);\r\nstatus = usb_ep_queue(in, req, GFP_ATOMIC);\r\nspin_lock(&port->port_lock);\r\nport->write_busy = false;\r\nif (status) {\r\npr_debug("%s: %s %s err %d\n",\r\n__func__, "queue", in->name, status);\r\nlist_add(&req->list, pool);\r\nbreak;\r\n}\r\nport->write_started++;\r\nif (!port->port_usb)\r\nbreak;\r\n}\r\nif (do_tty_wake && port->port.tty)\r\ntty_wakeup(port->port.tty);\r\nreturn status;\r\n}\r\nstatic unsigned gs_start_rx(struct gs_port *port)\r\n{\r\nstruct list_head *pool = &port->read_pool;\r\nstruct usb_ep *out = port->port_usb->out;\r\nwhile (!list_empty(pool)) {\r\nstruct usb_request *req;\r\nint status;\r\nstruct tty_struct *tty;\r\ntty = port->port.tty;\r\nif (!tty)\r\nbreak;\r\nif (port->read_started >= QUEUE_SIZE)\r\nbreak;\r\nreq = list_entry(pool->next, struct usb_request, list);\r\nlist_del(&req->list);\r\nreq->length = out->maxpacket;\r\nspin_unlock(&port->port_lock);\r\nstatus = usb_ep_queue(out, req, GFP_ATOMIC);\r\nspin_lock(&port->port_lock);\r\nif (status) {\r\npr_debug("%s: %s %s err %d\n",\r\n__func__, "queue", out->name, status);\r\nlist_add(&req->list, pool);\r\nbreak;\r\n}\r\nport->read_started++;\r\nif (!port->port_usb)\r\nbreak;\r\n}\r\nreturn port->read_started;\r\n}\r\nstatic void gs_rx_push(unsigned long _port)\r\n{\r\nstruct gs_port *port = (void *)_port;\r\nstruct tty_struct *tty;\r\nstruct list_head *queue = &port->read_queue;\r\nbool disconnect = false;\r\nbool do_push = false;\r\nspin_lock_irq(&port->port_lock);\r\ntty = port->port.tty;\r\nwhile (!list_empty(queue)) {\r\nstruct usb_request *req;\r\nreq = list_first_entry(queue, struct usb_request, list);\r\nif (tty && tty_throttled(tty))\r\nbreak;\r\nswitch (req->status) {\r\ncase -ESHUTDOWN:\r\ndisconnect = true;\r\npr_vdebug("ttyGS%d: shutdown\n", port->port_num);\r\nbreak;\r\ndefault:\r\npr_warn("ttyGS%d: unexpected RX status %d\n",\r\nport->port_num, req->status);\r\ncase 0:\r\nbreak;\r\n}\r\nif (req->actual) {\r\nchar *packet = req->buf;\r\nunsigned size = req->actual;\r\nunsigned n;\r\nint count;\r\nn = port->n_read;\r\nif (n) {\r\npacket += n;\r\nsize -= n;\r\n}\r\ncount = tty_insert_flip_string(&port->port, packet,\r\nsize);\r\nif (count)\r\ndo_push = true;\r\nif (count != size) {\r\nport->n_read += count;\r\npr_vdebug("ttyGS%d: rx block %d/%d\n",\r\nport->port_num, count, req->actual);\r\nbreak;\r\n}\r\nport->n_read = 0;\r\n}\r\nlist_move(&req->list, &port->read_pool);\r\nport->read_started--;\r\n}\r\nif (do_push)\r\ntty_flip_buffer_push(&port->port);\r\nif (!list_empty(queue) && tty) {\r\nif (!tty_throttled(tty)) {\r\nif (do_push)\r\ntasklet_schedule(&port->push);\r\nelse\r\npr_warn("ttyGS%d: RX not scheduled?\n",\r\nport->port_num);\r\n}\r\n}\r\nif (!disconnect && port->port_usb)\r\ngs_start_rx(port);\r\nspin_unlock_irq(&port->port_lock);\r\n}\r\nstatic void gs_read_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct gs_port *port = ep->driver_data;\r\nspin_lock(&port->port_lock);\r\nlist_add_tail(&req->list, &port->read_queue);\r\ntasklet_schedule(&port->push);\r\nspin_unlock(&port->port_lock);\r\n}\r\nstatic void gs_write_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct gs_port *port = ep->driver_data;\r\nspin_lock(&port->port_lock);\r\nlist_add(&req->list, &port->write_pool);\r\nport->write_started--;\r\nswitch (req->status) {\r\ndefault:\r\npr_warning("%s: unexpected %s status %d\n",\r\n__func__, ep->name, req->status);\r\ncase 0:\r\ngs_start_tx(port);\r\nbreak;\r\ncase -ESHUTDOWN:\r\npr_vdebug("%s: %s shutdown\n", __func__, ep->name);\r\nbreak;\r\n}\r\nspin_unlock(&port->port_lock);\r\n}\r\nstatic void gs_free_requests(struct usb_ep *ep, struct list_head *head,\r\nint *allocated)\r\n{\r\nstruct usb_request *req;\r\nwhile (!list_empty(head)) {\r\nreq = list_entry(head->next, struct usb_request, list);\r\nlist_del(&req->list);\r\ngs_free_req(ep, req);\r\nif (allocated)\r\n(*allocated)--;\r\n}\r\n}\r\nstatic int gs_alloc_requests(struct usb_ep *ep, struct list_head *head,\r\nvoid (*fn)(struct usb_ep *, struct usb_request *),\r\nint *allocated)\r\n{\r\nint i;\r\nstruct usb_request *req;\r\nint n = allocated ? QUEUE_SIZE - *allocated : QUEUE_SIZE;\r\nfor (i = 0; i < n; i++) {\r\nreq = gs_alloc_req(ep, ep->maxpacket, GFP_ATOMIC);\r\nif (!req)\r\nreturn list_empty(head) ? -ENOMEM : 0;\r\nreq->complete = fn;\r\nlist_add_tail(&req->list, head);\r\nif (allocated)\r\n(*allocated)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gs_start_io(struct gs_port *port)\r\n{\r\nstruct list_head *head = &port->read_pool;\r\nstruct usb_ep *ep = port->port_usb->out;\r\nint status;\r\nunsigned started;\r\nstatus = gs_alloc_requests(ep, head, gs_read_complete,\r\n&port->read_allocated);\r\nif (status)\r\nreturn status;\r\nstatus = gs_alloc_requests(port->port_usb->in, &port->write_pool,\r\ngs_write_complete, &port->write_allocated);\r\nif (status) {\r\ngs_free_requests(ep, head, &port->read_allocated);\r\nreturn status;\r\n}\r\nport->n_read = 0;\r\nstarted = gs_start_rx(port);\r\nif (started) {\r\ntty_wakeup(port->port.tty);\r\n} else {\r\ngs_free_requests(ep, head, &port->read_allocated);\r\ngs_free_requests(port->port_usb->in, &port->write_pool,\r\n&port->write_allocated);\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int gs_open(struct tty_struct *tty, struct file *file)\r\n{\r\nint port_num = tty->index;\r\nstruct gs_port *port;\r\nint status;\r\ndo {\r\nmutex_lock(&ports[port_num].lock);\r\nport = ports[port_num].port;\r\nif (!port)\r\nstatus = -ENODEV;\r\nelse {\r\nspin_lock_irq(&port->port_lock);\r\nif (port->port.count) {\r\nstatus = 0;\r\nport->port.count++;\r\n} else if (port->openclose) {\r\nstatus = -EBUSY;\r\n} else {\r\nstatus = -EAGAIN;\r\nport->openclose = true;\r\n}\r\nspin_unlock_irq(&port->port_lock);\r\n}\r\nmutex_unlock(&ports[port_num].lock);\r\nswitch (status) {\r\ndefault:\r\nreturn status;\r\ncase -EAGAIN:\r\nbreak;\r\ncase -EBUSY:\r\nmsleep(1);\r\nbreak;\r\n}\r\n} while (status != -EAGAIN);\r\nspin_lock_irq(&port->port_lock);\r\nif (port->port_write_buf.buf_buf == NULL) {\r\nspin_unlock_irq(&port->port_lock);\r\nstatus = gs_buf_alloc(&port->port_write_buf, WRITE_BUF_SIZE);\r\nspin_lock_irq(&port->port_lock);\r\nif (status) {\r\npr_debug("gs_open: ttyGS%d (%p,%p) no buffer\n",\r\nport->port_num, tty, file);\r\nport->openclose = false;\r\ngoto exit_unlock_port;\r\n}\r\n}\r\ntty->driver_data = port;\r\nport->port.tty = tty;\r\nport->port.count = 1;\r\nport->openclose = false;\r\nif (port->port_usb) {\r\nstruct gserial *gser = port->port_usb;\r\npr_debug("gs_open: start ttyGS%d\n", port->port_num);\r\ngs_start_io(port);\r\nif (gser->connect)\r\ngser->connect(gser);\r\n}\r\npr_debug("gs_open: ttyGS%d (%p,%p)\n", port->port_num, tty, file);\r\nstatus = 0;\r\nexit_unlock_port:\r\nspin_unlock_irq(&port->port_lock);\r\nreturn status;\r\n}\r\nstatic int gs_writes_finished(struct gs_port *p)\r\n{\r\nint cond;\r\nspin_lock_irq(&p->port_lock);\r\ncond = (p->port_usb == NULL) || !gs_buf_data_avail(&p->port_write_buf);\r\nspin_unlock_irq(&p->port_lock);\r\nreturn cond;\r\n}\r\nstatic void gs_close(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nstruct gserial *gser;\r\nspin_lock_irq(&port->port_lock);\r\nif (port->port.count != 1) {\r\nif (port->port.count == 0)\r\nWARN_ON(1);\r\nelse\r\n--port->port.count;\r\ngoto exit;\r\n}\r\npr_debug("gs_close: ttyGS%d (%p,%p) ...\n", port->port_num, tty, file);\r\nport->openclose = true;\r\nport->port.count = 0;\r\ngser = port->port_usb;\r\nif (gser && gser->disconnect)\r\ngser->disconnect(gser);\r\nif (gs_buf_data_avail(&port->port_write_buf) > 0 && gser) {\r\nspin_unlock_irq(&port->port_lock);\r\nwait_event_interruptible_timeout(port->drain_wait,\r\ngs_writes_finished(port),\r\nGS_CLOSE_TIMEOUT * HZ);\r\nspin_lock_irq(&port->port_lock);\r\ngser = port->port_usb;\r\n}\r\nif (gser == NULL)\r\ngs_buf_free(&port->port_write_buf);\r\nelse\r\ngs_buf_clear(&port->port_write_buf);\r\nport->port.tty = NULL;\r\nport->openclose = false;\r\npr_debug("gs_close: ttyGS%d (%p,%p) done!\n",\r\nport->port_num, tty, file);\r\nwake_up(&port->close_wait);\r\nexit:\r\nspin_unlock_irq(&port->port_lock);\r\n}\r\nstatic int gs_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\npr_vdebug("gs_write: ttyGS%d (%p) writing %d bytes\n",\r\nport->port_num, tty, count);\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nif (count)\r\ncount = gs_buf_put(&port->port_write_buf, buf, count);\r\nif (port->port_usb)\r\ngs_start_tx(port);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\nreturn count;\r\n}\r\nstatic int gs_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\nint status;\r\npr_vdebug("gs_put_char: (%d,%p) char=0x%x, called from %ps\n",\r\nport->port_num, tty, ch, __builtin_return_address(0));\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nstatus = gs_buf_put(&port->port_write_buf, &ch, 1);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\nreturn status;\r\n}\r\nstatic void gs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\npr_vdebug("gs_flush_chars: (%d,%p)\n", port->port_num, tty);\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nif (port->port_usb)\r\ngs_start_tx(port);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\n}\r\nstatic int gs_write_room(struct tty_struct *tty)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\nint room = 0;\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nif (port->port_usb)\r\nroom = gs_buf_space_avail(&port->port_write_buf);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\npr_vdebug("gs_write_room: (%d,%p) room=%d\n",\r\nport->port_num, tty, room);\r\nreturn room;\r\n}\r\nstatic int gs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\nint chars = 0;\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nchars = gs_buf_data_avail(&port->port_write_buf);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\npr_vdebug("gs_chars_in_buffer: (%d,%p) chars=%d\n",\r\nport->port_num, tty, chars);\r\nreturn chars;\r\n}\r\nstatic void gs_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nif (port->port_usb) {\r\ntasklet_schedule(&port->push);\r\npr_vdebug("ttyGS%d: unthrottle\n", port->port_num);\r\n}\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\n}\r\nstatic int gs_break_ctl(struct tty_struct *tty, int duration)\r\n{\r\nstruct gs_port *port = tty->driver_data;\r\nint status = 0;\r\nstruct gserial *gser;\r\npr_vdebug("gs_break_ctl: ttyGS%d, send break (%d) \n",\r\nport->port_num, duration);\r\nspin_lock_irq(&port->port_lock);\r\ngser = port->port_usb;\r\nif (gser && gser->send_break)\r\nstatus = gser->send_break(gser, duration);\r\nspin_unlock_irq(&port->port_lock);\r\nreturn status;\r\n}\r\nstatic struct usb_request *gs_request_new(struct usb_ep *ep)\r\n{\r\nstruct usb_request *req = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (!req)\r\nreturn NULL;\r\nreq->buf = kmalloc(ep->maxpacket, GFP_ATOMIC);\r\nif (!req->buf) {\r\nusb_ep_free_request(ep, req);\r\nreturn NULL;\r\n}\r\nreturn req;\r\n}\r\nstatic void gs_request_free(struct usb_request *req, struct usb_ep *ep)\r\n{\r\nif (!req)\r\nreturn;\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic void gs_complete_out(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nswitch (req->status) {\r\ndefault:\r\npr_warn("%s: unexpected %s status %d\n",\r\n__func__, ep->name, req->status);\r\ncase 0:\r\nspin_lock(&info->con_lock);\r\ninfo->req_busy = 0;\r\nspin_unlock(&info->con_lock);\r\nwake_up_process(info->console_thread);\r\nbreak;\r\ncase -ESHUTDOWN:\r\npr_vdebug("%s: %s shutdown\n", __func__, ep->name);\r\nbreak;\r\n}\r\n}\r\nstatic int gs_console_connect(int port_num)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nstruct gs_port *port;\r\nstruct usb_ep *ep;\r\nif (port_num != gserial_cons.index) {\r\npr_err("%s: port num [%d] is not support console\n",\r\n__func__, port_num);\r\nreturn -ENXIO;\r\n}\r\nport = ports[port_num].port;\r\nep = port->port_usb->in;\r\nif (!info->console_req) {\r\ninfo->console_req = gs_request_new(ep);\r\nif (!info->console_req)\r\nreturn -ENOMEM;\r\ninfo->console_req->complete = gs_complete_out;\r\n}\r\ninfo->port = port;\r\nspin_lock(&info->con_lock);\r\ninfo->req_busy = 0;\r\nspin_unlock(&info->con_lock);\r\npr_vdebug("port[%d] console connect!\n", port_num);\r\nreturn 0;\r\n}\r\nstatic void gs_console_disconnect(struct usb_ep *ep)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nstruct usb_request *req = info->console_req;\r\ngs_request_free(req, ep);\r\ninfo->console_req = NULL;\r\n}\r\nstatic int gs_console_thread(void *data)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nstruct gs_port *port;\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\nint xfer, ret, count, size;\r\ndo {\r\nport = info->port;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!port || !port->port_usb\r\n|| !port->port_usb->in || !info->console_req)\r\ngoto sched;\r\nreq = info->console_req;\r\nep = port->port_usb->in;\r\nspin_lock_irq(&info->con_lock);\r\ncount = gs_buf_data_avail(&info->con_buf);\r\nsize = ep->maxpacket;\r\nif (count > 0 && !info->req_busy) {\r\nset_current_state(TASK_RUNNING);\r\nif (count < size)\r\nsize = count;\r\nxfer = gs_buf_get(&info->con_buf, req->buf, size);\r\nreq->length = xfer;\r\nspin_unlock(&info->con_lock);\r\nret = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nspin_lock(&info->con_lock);\r\nif (ret < 0)\r\ninfo->req_busy = 0;\r\nelse\r\ninfo->req_busy = 1;\r\nspin_unlock_irq(&info->con_lock);\r\n} else {\r\nspin_unlock_irq(&info->con_lock);\r\nsched:\r\nif (kthread_should_stop()) {\r\nset_current_state(TASK_RUNNING);\r\nbreak;\r\n}\r\nschedule();\r\n}\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int gs_console_setup(struct console *co, char *options)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nint status;\r\ninfo->port = NULL;\r\ninfo->console_req = NULL;\r\ninfo->req_busy = 0;\r\nspin_lock_init(&info->con_lock);\r\nstatus = gs_buf_alloc(&info->con_buf, GS_CONSOLE_BUF_SIZE);\r\nif (status) {\r\npr_err("%s: allocate console buffer failed\n", __func__);\r\nreturn status;\r\n}\r\ninfo->console_thread = kthread_create(gs_console_thread,\r\nco, "gs_console");\r\nif (IS_ERR(info->console_thread)) {\r\npr_err("%s: cannot create console thread\n", __func__);\r\ngs_buf_free(&info->con_buf);\r\nreturn PTR_ERR(info->console_thread);\r\n}\r\nwake_up_process(info->console_thread);\r\nreturn 0;\r\n}\r\nstatic void gs_console_write(struct console *co,\r\nconst char *buf, unsigned count)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->con_lock, flags);\r\ngs_buf_put(&info->con_buf, buf, count);\r\nspin_unlock_irqrestore(&info->con_lock, flags);\r\nwake_up_process(info->console_thread);\r\n}\r\nstatic struct tty_driver *gs_console_device(struct console *co, int *index)\r\n{\r\nstruct tty_driver **p = (struct tty_driver **)co->data;\r\nif (!*p)\r\nreturn NULL;\r\n*index = co->index;\r\nreturn *p;\r\n}\r\nstatic void gserial_console_init(void)\r\n{\r\nregister_console(&gserial_cons);\r\n}\r\nstatic void gserial_console_exit(void)\r\n{\r\nstruct gscons_info *info = &gscons_info;\r\nunregister_console(&gserial_cons);\r\nkthread_stop(info->console_thread);\r\ngs_buf_free(&info->con_buf);\r\n}\r\nstatic int gs_console_connect(int port_num)\r\n{\r\nreturn 0;\r\n}\r\nstatic void gs_console_disconnect(struct usb_ep *ep)\r\n{\r\n}\r\nstatic void gserial_console_init(void)\r\n{\r\n}\r\nstatic void gserial_console_exit(void)\r\n{\r\n}\r\nstatic int\r\ngs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)\r\n{\r\nstruct gs_port *port;\r\nint ret = 0;\r\nmutex_lock(&ports[port_num].lock);\r\nif (ports[port_num].port) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nport = kzalloc(sizeof(struct gs_port), GFP_KERNEL);\r\nif (port == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntty_port_init(&port->port);\r\nspin_lock_init(&port->port_lock);\r\ninit_waitqueue_head(&port->drain_wait);\r\ninit_waitqueue_head(&port->close_wait);\r\ntasklet_init(&port->push, gs_rx_push, (unsigned long) port);\r\nINIT_LIST_HEAD(&port->read_pool);\r\nINIT_LIST_HEAD(&port->read_queue);\r\nINIT_LIST_HEAD(&port->write_pool);\r\nport->port_num = port_num;\r\nport->port_line_coding = *coding;\r\nports[port_num].port = port;\r\nout:\r\nmutex_unlock(&ports[port_num].lock);\r\nreturn ret;\r\n}\r\nstatic int gs_closed(struct gs_port *port)\r\n{\r\nint cond;\r\nspin_lock_irq(&port->port_lock);\r\ncond = (port->port.count == 0) && !port->openclose;\r\nspin_unlock_irq(&port->port_lock);\r\nreturn cond;\r\n}\r\nstatic void gserial_free_port(struct gs_port *port)\r\n{\r\ntasklet_kill(&port->push);\r\nwait_event(port->close_wait, gs_closed(port));\r\nWARN_ON(port->port_usb != NULL);\r\ntty_port_destroy(&port->port);\r\nkfree(port);\r\n}\r\nvoid gserial_free_line(unsigned char port_num)\r\n{\r\nstruct gs_port *port;\r\nmutex_lock(&ports[port_num].lock);\r\nif (WARN_ON(!ports[port_num].port)) {\r\nmutex_unlock(&ports[port_num].lock);\r\nreturn;\r\n}\r\nport = ports[port_num].port;\r\nports[port_num].port = NULL;\r\nmutex_unlock(&ports[port_num].lock);\r\ngserial_free_port(port);\r\ntty_unregister_device(gs_tty_driver, port_num);\r\ngserial_console_exit();\r\n}\r\nint gserial_alloc_line(unsigned char *line_num)\r\n{\r\nstruct usb_cdc_line_coding coding;\r\nstruct device *tty_dev;\r\nint ret;\r\nint port_num;\r\ncoding.dwDTERate = cpu_to_le32(9600);\r\ncoding.bCharFormat = 8;\r\ncoding.bParityType = USB_CDC_NO_PARITY;\r\ncoding.bDataBits = USB_CDC_1_STOP_BITS;\r\nfor (port_num = 0; port_num < MAX_U_SERIAL_PORTS; port_num++) {\r\nret = gs_port_alloc(port_num, &coding);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\ntty_dev = tty_port_register_device(&ports[port_num].port->port,\r\ngs_tty_driver, port_num, NULL);\r\nif (IS_ERR(tty_dev)) {\r\nstruct gs_port *port;\r\npr_err("%s: failed to register tty for port %d, err %ld\n",\r\n__func__, port_num, PTR_ERR(tty_dev));\r\nret = PTR_ERR(tty_dev);\r\nport = ports[port_num].port;\r\nports[port_num].port = NULL;\r\ngserial_free_port(port);\r\ngoto err;\r\n}\r\n*line_num = port_num;\r\ngserial_console_init();\r\nerr:\r\nreturn ret;\r\n}\r\nint gserial_connect(struct gserial *gser, u8 port_num)\r\n{\r\nstruct gs_port *port;\r\nunsigned long flags;\r\nint status;\r\nif (port_num >= MAX_U_SERIAL_PORTS)\r\nreturn -ENXIO;\r\nport = ports[port_num].port;\r\nif (!port) {\r\npr_err("serial line %d not allocated.\n", port_num);\r\nreturn -EINVAL;\r\n}\r\nif (port->port_usb) {\r\npr_err("serial line %d is in use.\n", port_num);\r\nreturn -EBUSY;\r\n}\r\nstatus = usb_ep_enable(gser->in);\r\nif (status < 0)\r\nreturn status;\r\ngser->in->driver_data = port;\r\nstatus = usb_ep_enable(gser->out);\r\nif (status < 0)\r\ngoto fail_out;\r\ngser->out->driver_data = port;\r\nspin_lock_irqsave(&port->port_lock, flags);\r\ngser->ioport = port;\r\nport->port_usb = gser;\r\ngser->port_line_coding = port->port_line_coding;\r\nif (port->port.count) {\r\npr_debug("gserial_connect: start ttyGS%d\n", port->port_num);\r\ngs_start_io(port);\r\nif (gser->connect)\r\ngser->connect(gser);\r\n} else {\r\nif (gser->disconnect)\r\ngser->disconnect(gser);\r\n}\r\nstatus = gs_console_connect(port_num);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\nreturn status;\r\nfail_out:\r\nusb_ep_disable(gser->in);\r\nreturn status;\r\n}\r\nvoid gserial_disconnect(struct gserial *gser)\r\n{\r\nstruct gs_port *port = gser->ioport;\r\nunsigned long flags;\r\nif (!port)\r\nreturn;\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nport->port_line_coding = gser->port_line_coding;\r\nport->port_usb = NULL;\r\ngser->ioport = NULL;\r\nif (port->port.count > 0 || port->openclose) {\r\nwake_up_interruptible(&port->drain_wait);\r\nif (port->port.tty)\r\ntty_hangup(port->port.tty);\r\n}\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\nusb_ep_disable(gser->out);\r\nusb_ep_disable(gser->in);\r\nspin_lock_irqsave(&port->port_lock, flags);\r\nif (port->port.count == 0 && !port->openclose)\r\ngs_buf_free(&port->port_write_buf);\r\ngs_free_requests(gser->out, &port->read_pool, NULL);\r\ngs_free_requests(gser->out, &port->read_queue, NULL);\r\ngs_free_requests(gser->in, &port->write_pool, NULL);\r\nport->read_allocated = port->read_started =\r\nport->write_allocated = port->write_started = 0;\r\ngs_console_disconnect(gser->in);\r\nspin_unlock_irqrestore(&port->port_lock, flags);\r\n}\r\nstatic int userial_init(void)\r\n{\r\nunsigned i;\r\nint status;\r\ngs_tty_driver = alloc_tty_driver(MAX_U_SERIAL_PORTS);\r\nif (!gs_tty_driver)\r\nreturn -ENOMEM;\r\ngs_tty_driver->driver_name = "g_serial";\r\ngs_tty_driver->name = "ttyGS";\r\ngs_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\ngs_tty_driver->subtype = SERIAL_TYPE_NORMAL;\r\ngs_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ngs_tty_driver->init_termios = tty_std_termios;\r\ngs_tty_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\ngs_tty_driver->init_termios.c_ispeed = 9600;\r\ngs_tty_driver->init_termios.c_ospeed = 9600;\r\ntty_set_operations(gs_tty_driver, &gs_tty_ops);\r\nfor (i = 0; i < MAX_U_SERIAL_PORTS; i++)\r\nmutex_init(&ports[i].lock);\r\nstatus = tty_register_driver(gs_tty_driver);\r\nif (status) {\r\npr_err("%s: cannot register, err %d\n",\r\n__func__, status);\r\ngoto fail;\r\n}\r\npr_debug("%s: registered %d ttyGS* device%s\n", __func__,\r\nMAX_U_SERIAL_PORTS,\r\n(MAX_U_SERIAL_PORTS == 1) ? "" : "s");\r\nreturn status;\r\nfail:\r\nput_tty_driver(gs_tty_driver);\r\ngs_tty_driver = NULL;\r\nreturn status;\r\n}\r\nstatic void userial_cleanup(void)\r\n{\r\ntty_unregister_driver(gs_tty_driver);\r\nput_tty_driver(gs_tty_driver);\r\ngs_tty_driver = NULL;\r\n}
