static inline void set_x_reg(struct pt_regs *regs, int reg, u64 val)\r\n{\r\nif (reg < 31)\r\nregs->regs[reg] = val;\r\n}\r\nstatic inline void set_w_reg(struct pt_regs *regs, int reg, u64 val)\r\n{\r\nif (reg < 31)\r\nregs->regs[reg] = lower_32_bits(val);\r\n}\r\nstatic inline u64 get_x_reg(struct pt_regs *regs, int reg)\r\n{\r\nif (reg < 31)\r\nreturn regs->regs[reg];\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline u32 get_w_reg(struct pt_regs *regs, int reg)\r\n{\r\nif (reg < 31)\r\nreturn lower_32_bits(regs->regs[reg]);\r\nelse\r\nreturn 0;\r\n}\r\nstatic bool __kprobes check_cbz(u32 opcode, struct pt_regs *regs)\r\n{\r\nint xn = opcode & 0x1f;\r\nreturn (opcode & (1 << 31)) ?\r\n(get_x_reg(regs, xn) == 0) : (get_w_reg(regs, xn) == 0);\r\n}\r\nstatic bool __kprobes check_cbnz(u32 opcode, struct pt_regs *regs)\r\n{\r\nint xn = opcode & 0x1f;\r\nreturn (opcode & (1 << 31)) ?\r\n(get_x_reg(regs, xn) != 0) : (get_w_reg(regs, xn) != 0);\r\n}\r\nstatic bool __kprobes check_tbz(u32 opcode, struct pt_regs *regs)\r\n{\r\nint xn = opcode & 0x1f;\r\nint bit_pos = ((opcode & (1 << 31)) >> 26) | ((opcode >> 19) & 0x1f);\r\nreturn ((get_x_reg(regs, xn) >> bit_pos) & 0x1) == 0;\r\n}\r\nstatic bool __kprobes check_tbnz(u32 opcode, struct pt_regs *regs)\r\n{\r\nint xn = opcode & 0x1f;\r\nint bit_pos = ((opcode & (1 << 31)) >> 26) | ((opcode >> 19) & 0x1f);\r\nreturn ((get_x_reg(regs, xn) >> bit_pos) & 0x1) != 0;\r\n}\r\nvoid __kprobes\r\nsimulate_adr_adrp(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nlong imm, xn, val;\r\nxn = opcode & 0x1f;\r\nimm = ((opcode >> 3) & 0x1ffffc) | ((opcode >> 29) & 0x3);\r\nimm = sign_extend(imm, 20);\r\nif (opcode & 0x80000000)\r\nval = (imm<<12) + (addr & 0xfffffffffffff000);\r\nelse\r\nval = imm + addr;\r\nset_x_reg(regs, xn, val);\r\ninstruction_pointer_set(regs, instruction_pointer(regs) + 4);\r\n}\r\nvoid __kprobes\r\nsimulate_b_bl(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nint disp = bbl_displacement(opcode);\r\nif (opcode & (1 << 31))\r\nset_x_reg(regs, 30, addr + 4);\r\ninstruction_pointer_set(regs, addr + disp);\r\n}\r\nvoid __kprobes\r\nsimulate_b_cond(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nint disp = 4;\r\nif (aarch32_opcode_cond_checks[opcode & 0xf](regs->pstate & 0xffffffff))\r\ndisp = bcond_displacement(opcode);\r\ninstruction_pointer_set(regs, addr + disp);\r\n}\r\nvoid __kprobes\r\nsimulate_br_blr_ret(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nint xn = (opcode >> 5) & 0x1f;\r\ninstruction_pointer_set(regs, get_x_reg(regs, xn));\r\nif (((opcode >> 21) & 0x3) == 1)\r\nset_x_reg(regs, 30, addr + 4);\r\n}\r\nvoid __kprobes\r\nsimulate_cbz_cbnz(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nint disp = 4;\r\nif (opcode & (1 << 24)) {\r\nif (check_cbnz(opcode, regs))\r\ndisp = cbz_displacement(opcode);\r\n} else {\r\nif (check_cbz(opcode, regs))\r\ndisp = cbz_displacement(opcode);\r\n}\r\ninstruction_pointer_set(regs, addr + disp);\r\n}\r\nvoid __kprobes\r\nsimulate_tbz_tbnz(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nint disp = 4;\r\nif (opcode & (1 << 24)) {\r\nif (check_tbnz(opcode, regs))\r\ndisp = tbz_displacement(opcode);\r\n} else {\r\nif (check_tbz(opcode, regs))\r\ndisp = tbz_displacement(opcode);\r\n}\r\ninstruction_pointer_set(regs, addr + disp);\r\n}\r\nvoid __kprobes\r\nsimulate_ldr_literal(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\nu64 *load_addr;\r\nint xn = opcode & 0x1f;\r\nint disp;\r\ndisp = ldr_displacement(opcode);\r\nload_addr = (u64 *) (addr + disp);\r\nif (opcode & (1 << 30))\r\nset_x_reg(regs, xn, *load_addr);\r\nelse\r\nset_w_reg(regs, xn, *load_addr);\r\ninstruction_pointer_set(regs, instruction_pointer(regs) + 4);\r\n}\r\nvoid __kprobes\r\nsimulate_ldrsw_literal(u32 opcode, long addr, struct pt_regs *regs)\r\n{\r\ns32 *load_addr;\r\nint xn = opcode & 0x1f;\r\nint disp;\r\ndisp = ldr_displacement(opcode);\r\nload_addr = (s32 *) (addr + disp);\r\nset_x_reg(regs, xn, *load_addr);\r\ninstruction_pointer_set(regs, instruction_pointer(regs) + 4);\r\n}
