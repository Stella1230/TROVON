static u8 ns_exp_read(struct phy_device *phydev, u16 reg)\r\n{\r\nphy_write(phydev, NS_EXP_MEM_ADD, reg);\r\nreturn phy_read(phydev, NS_EXP_MEM_DATA);\r\n}\r\nstatic void ns_exp_write(struct phy_device *phydev, u16 reg, u8 data)\r\n{\r\nphy_write(phydev, NS_EXP_MEM_ADD, reg);\r\nphy_write(phydev, NS_EXP_MEM_DATA, data);\r\n}\r\nstatic int ns_config_intr(struct phy_device *phydev)\r\n{\r\nint err;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\r\nerr = phy_write(phydev, DP83865_INT_MASK,\r\nDP83865_INT_MASK_DEFAULT);\r\nelse\r\nerr = phy_write(phydev, DP83865_INT_MASK, 0);\r\nreturn err;\r\n}\r\nstatic int ns_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint ret = phy_read(phydev, DP83865_INT_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = phy_write(phydev, DP83865_INT_CLEAR, ret & ~0x7);\r\nreturn ret;\r\n}\r\nstatic void ns_giga_speed_fallback(struct phy_device *phydev, int mode)\r\n{\r\nint bmcr = phy_read(phydev, MII_BMCR);\r\nphy_write(phydev, MII_BMCR, (bmcr | BMCR_PDOWN));\r\nphy_write(phydev, NS_EXP_MEM_CTL, 0);\r\nphy_write(phydev, NS_EXP_MEM_ADD, 0x1C0);\r\nphy_write(phydev, NS_EXP_MEM_DATA, 0x0008);\r\nphy_write(phydev, MII_BMCR, (bmcr & ~BMCR_PDOWN));\r\nphy_write(phydev, LED_CTRL_REG, mode);\r\n}\r\nstatic void ns_10_base_t_hdx_loopack(struct phy_device *phydev, int disable)\r\n{\r\nif (disable)\r\nns_exp_write(phydev, 0x1c0, ns_exp_read(phydev, 0x1c0) | 1);\r\nelse\r\nns_exp_write(phydev, 0x1c0,\r\nns_exp_read(phydev, 0x1c0) & 0xfffe);\r\npr_debug("10BASE-T HDX loopback %s\n",\r\n(ns_exp_read(phydev, 0x1c0) & 0x0001) ? "off" : "on");\r\n}\r\nstatic int ns_config_init(struct phy_device *phydev)\r\n{\r\nns_giga_speed_fallback(phydev, ALL_FALLBACK_ON);\r\nns_10_base_t_hdx_loopack(phydev, hdx_loopback_off);\r\nreturn ns_ack_interrupt(phydev);\r\n}
