static int s3c64xx_clk_suspend(void)\r\n{\r\nsamsung_clk_save(reg_base, s3c64xx_save_common,\r\nARRAY_SIZE(s3c64xx_clk_regs));\r\nif (!is_s3c6400)\r\nsamsung_clk_save(reg_base, s3c64xx_save_soc,\r\nARRAY_SIZE(s3c6410_clk_regs));\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_clk_resume(void)\r\n{\r\nsamsung_clk_restore(reg_base, s3c64xx_save_common,\r\nARRAY_SIZE(s3c64xx_clk_regs));\r\nif (!is_s3c6400)\r\nsamsung_clk_restore(reg_base, s3c64xx_save_soc,\r\nARRAY_SIZE(s3c6410_clk_regs));\r\n}\r\nstatic void s3c64xx_clk_sleep_init(void)\r\n{\r\ns3c64xx_save_common = samsung_clk_alloc_reg_dump(s3c64xx_clk_regs,\r\nARRAY_SIZE(s3c64xx_clk_regs));\r\nif (!s3c64xx_save_common)\r\ngoto err_warn;\r\nif (!is_s3c6400) {\r\ns3c64xx_save_soc = samsung_clk_alloc_reg_dump(s3c6410_clk_regs,\r\nARRAY_SIZE(s3c6410_clk_regs));\r\nif (!s3c64xx_save_soc)\r\ngoto err_soc;\r\n}\r\nregister_syscore_ops(&s3c64xx_clk_syscore_ops);\r\nreturn;\r\nerr_soc:\r\nkfree(s3c64xx_save_common);\r\nerr_warn:\r\npr_warn("%s: failed to allocate sleep save data, no sleep support!\n",\r\n__func__);\r\n}\r\nstatic void s3c64xx_clk_sleep_init(void) {}\r\nstatic void __init s3c64xx_clk_register_fixed_ext(\r\nstruct samsung_clk_provider *ctx,\r\nunsigned long fin_pll_f,\r\nunsigned long xusbxti_f)\r\n{\r\ns3c64xx_fixed_rate_ext_clks[0].fixed_rate = fin_pll_f;\r\ns3c64xx_fixed_rate_ext_clks[1].fixed_rate = xusbxti_f;\r\nsamsung_clk_register_fixed_rate(ctx, s3c64xx_fixed_rate_ext_clks,\r\nARRAY_SIZE(s3c64xx_fixed_rate_ext_clks));\r\n}\r\nvoid __init s3c64xx_clk_init(struct device_node *np, unsigned long xtal_f,\r\nunsigned long xusbxti_f, bool s3c6400,\r\nvoid __iomem *base)\r\n{\r\nstruct samsung_clk_provider *ctx;\r\nreg_base = base;\r\nis_s3c6400 = s3c6400;\r\nif (np) {\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base)\r\npanic("%s: failed to map registers\n", __func__);\r\n}\r\nctx = samsung_clk_init(np, reg_base, NR_CLKS);\r\nif (!np)\r\ns3c64xx_clk_register_fixed_ext(ctx, xtal_f, xusbxti_f);\r\nsamsung_clk_register_pll(ctx, s3c64xx_pll_clks,\r\nARRAY_SIZE(s3c64xx_pll_clks), reg_base);\r\nsamsung_clk_register_fixed_rate(ctx, s3c64xx_fixed_rate_clks,\r\nARRAY_SIZE(s3c64xx_fixed_rate_clks));\r\nsamsung_clk_register_mux(ctx, s3c64xx_mux_clks,\r\nARRAY_SIZE(s3c64xx_mux_clks));\r\nsamsung_clk_register_div(ctx, s3c64xx_div_clks,\r\nARRAY_SIZE(s3c64xx_div_clks));\r\nsamsung_clk_register_gate(ctx, s3c64xx_gate_clks,\r\nARRAY_SIZE(s3c64xx_gate_clks));\r\nif (is_s3c6400) {\r\nsamsung_clk_register_mux(ctx, s3c6400_mux_clks,\r\nARRAY_SIZE(s3c6400_mux_clks));\r\nsamsung_clk_register_div(ctx, s3c6400_div_clks,\r\nARRAY_SIZE(s3c6400_div_clks));\r\nsamsung_clk_register_gate(ctx, s3c6400_gate_clks,\r\nARRAY_SIZE(s3c6400_gate_clks));\r\nsamsung_clk_register_alias(ctx, s3c6400_clock_aliases,\r\nARRAY_SIZE(s3c6400_clock_aliases));\r\n} else {\r\nsamsung_clk_register_mux(ctx, s3c6410_mux_clks,\r\nARRAY_SIZE(s3c6410_mux_clks));\r\nsamsung_clk_register_div(ctx, s3c6410_div_clks,\r\nARRAY_SIZE(s3c6410_div_clks));\r\nsamsung_clk_register_gate(ctx, s3c6410_gate_clks,\r\nARRAY_SIZE(s3c6410_gate_clks));\r\nsamsung_clk_register_alias(ctx, s3c6410_clock_aliases,\r\nARRAY_SIZE(s3c6410_clock_aliases));\r\n}\r\nsamsung_clk_register_alias(ctx, s3c64xx_clock_aliases,\r\nARRAY_SIZE(s3c64xx_clock_aliases));\r\ns3c64xx_clk_sleep_init();\r\nsamsung_clk_of_add_provider(np, ctx);\r\npr_info("%s clocks: apll = %lu, mpll = %lu\n"\r\n"\tepll = %lu, arm_clk = %lu\n",\r\nis_s3c6400 ? "S3C6400" : "S3C6410",\r\n_get_rate("fout_apll"), _get_rate("fout_mpll"),\r\n_get_rate("fout_epll"), _get_rate("armclk"));\r\n}\r\nstatic void __init s3c6400_clk_init(struct device_node *np)\r\n{\r\ns3c64xx_clk_init(np, 0, 0, true, NULL);\r\n}\r\nstatic void __init s3c6410_clk_init(struct device_node *np)\r\n{\r\ns3c64xx_clk_init(np, 0, 0, false, NULL);\r\n}
