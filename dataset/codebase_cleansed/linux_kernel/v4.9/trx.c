static u8 _rtl8723be_map_hwqueue_to_fwqueue(struct sk_buff *skb, u8 hw_queue)\r\n{\r\n__le16 fc = rtl_get_fc(skb);\r\nif (unlikely(ieee80211_is_beacon(fc)))\r\nreturn QSLT_BEACON;\r\nif (ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc))\r\nreturn QSLT_MGNT;\r\nreturn skb->priority;\r\n}\r\nstatic void _rtl8723be_query_rxphystatus(struct ieee80211_hw *hw,\r\nstruct rtl_stats *pstatus, u8 *pdesc,\r\nstruct rx_fwinfo_8723be *p_drvinfo,\r\nbool bpacket_match_bssid,\r\nbool bpacket_toself,\r\nbool packet_beacon)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct phy_status_rpt *p_phystrpt = (struct phy_status_rpt *)p_drvinfo;\r\ns8 rx_pwr_all = 0, rx_pwr[4];\r\nu8 rf_rx_num = 0, evm, pwdb_all, pwdb_all_bt = 0;\r\nu8 i, max_spatial_stream;\r\nu32 rssi, total_rssi = 0;\r\nbool is_cck = pstatus->is_cck;\r\nu8 lan_idx, vga_idx;\r\npstatus->packet_matchbssid = bpacket_match_bssid;\r\npstatus->packet_toself = bpacket_toself;\r\npstatus->packet_beacon = packet_beacon;\r\npstatus->rx_mimo_signalquality[0] = -1;\r\npstatus->rx_mimo_signalquality[1] = -1;\r\nif (is_cck) {\r\nu8 cck_highpwr;\r\nu8 cck_agc_rpt;\r\ncck_agc_rpt = p_phystrpt->cck_agc_rpt_ofdm_cfosho_a;\r\ncck_highpwr = (u8)rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2,\r\nBIT(9));\r\nlan_idx = ((cck_agc_rpt & 0xE0) >> 5);\r\nvga_idx = (cck_agc_rpt & 0x1f);\r\nswitch (lan_idx) {\r\ncase 6:\r\nrx_pwr_all = -34 - (2 * vga_idx);\r\nbreak;\r\ncase 4:\r\nrx_pwr_all = -14 - (2 * vga_idx);\r\nbreak;\r\ncase 1:\r\nrx_pwr_all = 6 - (2 * vga_idx);\r\nbreak;\r\ncase 0:\r\nrx_pwr_all = 16 - (2 * vga_idx);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\r\nif (pwdb_all > 100)\r\npwdb_all = 100;\r\npstatus->rx_pwdb_all = pwdb_all;\r\npstatus->bt_rx_rssi_percentage = pwdb_all;\r\npstatus->recvsignalpower = rx_pwr_all;\r\nif (bpacket_match_bssid) {\r\nu8 sq, sq_rpt;\r\nif (pstatus->rx_pwdb_all > 40) {\r\nsq = 100;\r\n} else {\r\nsq_rpt = p_phystrpt->cck_sig_qual_ofdm_pwdb_all;\r\nif (sq_rpt > 64)\r\nsq = 0;\r\nelse if (sq_rpt < 20)\r\nsq = 100;\r\nelse\r\nsq = ((64 - sq_rpt) * 100) / 44;\r\n}\r\npstatus->signalquality = sq;\r\npstatus->rx_mimo_signalquality[0] = sq;\r\npstatus->rx_mimo_signalquality[1] = -1;\r\n}\r\n} else {\r\nfor (i = RF90_PATH_A; i < RF6052_MAX_PATH; i++) {\r\nif (rtlpriv->dm.rfpath_rxenable[i])\r\nrf_rx_num++;\r\nrx_pwr[i] = ((p_phystrpt->path_agc[i].gain & 0x3f) * 2)\r\n- 110;\r\npstatus->rx_pwr[i] = rx_pwr[i];\r\nrssi = rtl_query_rxpwrpercentage(rx_pwr[i]);\r\ntotal_rssi += rssi;\r\npstatus->rx_mimo_signalstrength[i] = (u8)rssi;\r\n}\r\nrx_pwr_all = ((p_phystrpt->cck_sig_qual_ofdm_pwdb_all >> 1) &\r\n0x7f) - 110;\r\npwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\r\npwdb_all_bt = pwdb_all;\r\npstatus->rx_pwdb_all = pwdb_all;\r\npstatus->bt_rx_rssi_percentage = pwdb_all_bt;\r\npstatus->rxpower = rx_pwr_all;\r\npstatus->recvsignalpower = rx_pwr_all;\r\nif (pstatus->rate >= DESC92C_RATEMCS8 &&\r\npstatus->rate <= DESC92C_RATEMCS15)\r\nmax_spatial_stream = 2;\r\nelse\r\nmax_spatial_stream = 1;\r\nfor (i = 0; i < max_spatial_stream; i++) {\r\nevm = rtl_evm_db_to_percentage(\r\np_phystrpt->stream_rxevm[i]);\r\nif (bpacket_match_bssid) {\r\nif (i == 0)\r\npstatus->signalquality =\r\n(u8)(evm & 0xff);\r\npstatus->rx_mimo_signalquality[i] =\r\n(u8)(evm & 0xff);\r\n}\r\n}\r\nif (bpacket_match_bssid) {\r\nfor (i = RF90_PATH_A; i <= RF90_PATH_B; i++)\r\nrtl_priv(hw)->dm.cfo_tail[i] =\r\n(int)p_phystrpt->path_cfotail[i];\r\nif (rtl_priv(hw)->dm.packet_count == 0xffffffff)\r\nrtl_priv(hw)->dm.packet_count = 0;\r\nelse\r\nrtl_priv(hw)->dm.packet_count++;\r\n}\r\n}\r\nif (is_cck)\r\npstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,\r\npwdb_all));\r\nelse if (rf_rx_num != 0)\r\npstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,\r\ntotal_rssi /= rf_rx_num));\r\n}\r\nstatic void _rtl8723be_translate_rx_signal_stuff(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb,\r\nstruct rtl_stats *pstatus,\r\nu8 *pdesc,\r\nstruct rx_fwinfo_8723be *p_drvinfo)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct ieee80211_hdr *hdr;\r\nu8 *tmp_buf;\r\nu8 *praddr;\r\nu8 *psaddr;\r\nu16 fc, type;\r\nbool packet_matchbssid, packet_toself, packet_beacon;\r\ntmp_buf = skb->data + pstatus->rx_drvinfo_size + pstatus->rx_bufshift;\r\nhdr = (struct ieee80211_hdr *)tmp_buf;\r\nfc = le16_to_cpu(hdr->frame_control);\r\ntype = WLAN_FC_GET_TYPE(hdr->frame_control);\r\npraddr = hdr->addr1;\r\npsaddr = ieee80211_get_SA(hdr);\r\nmemcpy(pstatus->psaddr, psaddr, ETH_ALEN);\r\npacket_matchbssid = ((IEEE80211_FTYPE_CTL != type) &&\r\n(ether_addr_equal(mac->bssid, (fc & IEEE80211_FCTL_TODS) ?\r\nhdr->addr1 : (fc & IEEE80211_FCTL_FROMDS) ?\r\nhdr->addr2 : hdr->addr3)) &&\r\n(!pstatus->hwerror) &&\r\n(!pstatus->crc) && (!pstatus->icv));\r\npacket_toself = packet_matchbssid &&\r\n(ether_addr_equal(praddr, rtlefuse->dev_addr));\r\nif (ieee80211_is_beacon(hdr->frame_control))\r\npacket_beacon = true;\r\nelse\r\npacket_beacon = false;\r\nif (packet_beacon && packet_matchbssid)\r\nrtl_priv(hw)->dm.dbginfo.num_qry_beacon_pkt++;\r\n_rtl8723be_query_rxphystatus(hw, pstatus, pdesc, p_drvinfo,\r\npacket_matchbssid,\r\npacket_toself,\r\npacket_beacon);\r\nrtl_process_phyinfo(hw, tmp_buf, pstatus);\r\n}\r\nstatic void _rtl8723be_insert_emcontent(struct rtl_tcb_desc *ptcb_desc,\r\nu8 *virtualaddress)\r\n{\r\nu32 dwtmp = 0;\r\nmemset(virtualaddress, 0, 8);\r\nSET_EARLYMODE_PKTNUM(virtualaddress, ptcb_desc->empkt_num);\r\nif (ptcb_desc->empkt_num == 1) {\r\ndwtmp = ptcb_desc->empkt_len[0];\r\n} else {\r\ndwtmp = ptcb_desc->empkt_len[0];\r\ndwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\r\ndwtmp += ptcb_desc->empkt_len[1];\r\n}\r\nSET_EARLYMODE_LEN0(virtualaddress, dwtmp);\r\nif (ptcb_desc->empkt_num <= 3) {\r\ndwtmp = ptcb_desc->empkt_len[2];\r\n} else {\r\ndwtmp = ptcb_desc->empkt_len[2];\r\ndwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\r\ndwtmp += ptcb_desc->empkt_len[3];\r\n}\r\nSET_EARLYMODE_LEN1(virtualaddress, dwtmp);\r\nif (ptcb_desc->empkt_num <= 5) {\r\ndwtmp = ptcb_desc->empkt_len[4];\r\n} else {\r\ndwtmp = ptcb_desc->empkt_len[4];\r\ndwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\r\ndwtmp += ptcb_desc->empkt_len[5];\r\n}\r\nSET_EARLYMODE_LEN2_1(virtualaddress, dwtmp & 0xF);\r\nSET_EARLYMODE_LEN2_2(virtualaddress, dwtmp >> 4);\r\nif (ptcb_desc->empkt_num <= 7) {\r\ndwtmp = ptcb_desc->empkt_len[6];\r\n} else {\r\ndwtmp = ptcb_desc->empkt_len[6];\r\ndwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\r\ndwtmp += ptcb_desc->empkt_len[7];\r\n}\r\nSET_EARLYMODE_LEN3(virtualaddress, dwtmp);\r\nif (ptcb_desc->empkt_num <= 9) {\r\ndwtmp = ptcb_desc->empkt_len[8];\r\n} else {\r\ndwtmp = ptcb_desc->empkt_len[8];\r\ndwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\r\ndwtmp += ptcb_desc->empkt_len[9];\r\n}\r\nSET_EARLYMODE_LEN4(virtualaddress, dwtmp);\r\n}\r\nbool rtl8723be_rx_query_desc(struct ieee80211_hw *hw,\r\nstruct rtl_stats *status,\r\nstruct ieee80211_rx_status *rx_status,\r\nu8 *pdesc, struct sk_buff *skb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rx_fwinfo_8723be *p_drvinfo;\r\nstruct ieee80211_hdr *hdr;\r\nu32 phystatus = GET_RX_DESC_PHYST(pdesc);\r\nstatus->length = (u16)GET_RX_DESC_PKT_LEN(pdesc);\r\nstatus->rx_drvinfo_size = (u8)GET_RX_DESC_DRV_INFO_SIZE(pdesc) *\r\nRX_DRV_INFO_SIZE_UNIT;\r\nstatus->rx_bufshift = (u8)(GET_RX_DESC_SHIFT(pdesc) & 0x03);\r\nstatus->icv = (u16) GET_RX_DESC_ICV(pdesc);\r\nstatus->crc = (u16) GET_RX_DESC_CRC32(pdesc);\r\nstatus->hwerror = (status->crc | status->icv);\r\nstatus->decrypted = !GET_RX_DESC_SWDEC(pdesc);\r\nstatus->rate = (u8)GET_RX_DESC_RXMCS(pdesc);\r\nstatus->shortpreamble = (u16)GET_RX_DESC_SPLCP(pdesc);\r\nstatus->isampdu = (bool)(GET_RX_DESC_PAGGR(pdesc) == 1);\r\nstatus->isfirst_ampdu = (bool)(GET_RX_DESC_PAGGR(pdesc) == 1);\r\nstatus->timestamp_low = GET_RX_DESC_TSFL(pdesc);\r\nstatus->rx_is40Mhzpacket = (bool)GET_RX_DESC_BW(pdesc);\r\nstatus->bandwidth = (u8)GET_RX_DESC_BW(pdesc);\r\nstatus->macid = GET_RX_DESC_MACID(pdesc);\r\nstatus->is_ht = (bool)GET_RX_DESC_RXHT(pdesc);\r\nstatus->is_cck = RX_HAL_IS_CCK_RATE(status->rate);\r\nif (GET_RX_STATUS_DESC_RPT_SEL(pdesc))\r\nstatus->packet_report_type = C2H_PACKET;\r\nelse\r\nstatus->packet_report_type = NORMAL_RX;\r\nif (GET_RX_STATUS_DESC_MAGIC_MATCH(pdesc))\r\nstatus->wake_match = BIT(2);\r\nelse if (GET_RX_STATUS_DESC_MAGIC_MATCH(pdesc))\r\nstatus->wake_match = BIT(1);\r\nelse if (GET_RX_STATUS_DESC_UNICAST_MATCH(pdesc))\r\nstatus->wake_match = BIT(0);\r\nelse\r\nstatus->wake_match = 0;\r\nif (status->wake_match)\r\nRT_TRACE(rtlpriv, COMP_RXDESC, DBG_LOUD,\r\n"GGGGGGGGGGGGGet Wakeup Packet!! WakeMatch=%d\n",\r\nstatus->wake_match);\r\nrx_status->freq = hw->conf.chandef.chan->center_freq;\r\nrx_status->band = hw->conf.chandef.chan->band;\r\nhdr = (struct ieee80211_hdr *)(skb->data + status->rx_drvinfo_size +\r\nstatus->rx_bufshift);\r\nif (status->crc)\r\nrx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\r\nif (status->rx_is40Mhzpacket)\r\nrx_status->flag |= RX_FLAG_40MHZ;\r\nif (status->is_ht)\r\nrx_status->flag |= RX_FLAG_HT;\r\nrx_status->flag |= RX_FLAG_MACTIME_START;\r\nif (status->decrypted) {\r\nif ((!_ieee80211_is_robust_mgmt_frame(hdr)) &&\r\n(ieee80211_has_protected(hdr->frame_control)))\r\nrx_status->flag |= RX_FLAG_DECRYPTED;\r\nelse\r\nrx_status->flag &= ~RX_FLAG_DECRYPTED;\r\n}\r\nrx_status->rate_idx = rtlwifi_rate_mapping(hw, status->is_ht,\r\nfalse, status->rate);\r\nrx_status->mactime = status->timestamp_low;\r\nif (phystatus) {\r\np_drvinfo = (struct rx_fwinfo_8723be *)(skb->data +\r\nstatus->rx_bufshift);\r\n_rtl8723be_translate_rx_signal_stuff(hw, skb, status,\r\npdesc, p_drvinfo);\r\n}\r\nrx_status->signal = status->recvsignalpower + 10;\r\nif (status->packet_report_type == TX_REPORT2) {\r\nstatus->macid_valid_entry[0] =\r\nGET_RX_RPT2_DESC_MACID_VALID_1(pdesc);\r\nstatus->macid_valid_entry[1] =\r\nGET_RX_RPT2_DESC_MACID_VALID_2(pdesc);\r\n}\r\nreturn true;\r\n}\r\nvoid rtl8723be_tx_fill_desc(struct ieee80211_hw *hw,\r\nstruct ieee80211_hdr *hdr, u8 *pdesc_tx,\r\nu8 *txbd, struct ieee80211_tx_info *info,\r\nstruct ieee80211_sta *sta, struct sk_buff *skb,\r\nu8 hw_queue, struct rtl_tcb_desc *ptcb_desc)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 *pdesc = (u8 *)pdesc_tx;\r\nu16 seq_number;\r\n__le16 fc = hdr->frame_control;\r\nunsigned int buf_len = 0;\r\nunsigned int skb_len = skb->len;\r\nu8 fw_qsel = _rtl8723be_map_hwqueue_to_fwqueue(skb, hw_queue);\r\nbool firstseg = ((hdr->seq_ctrl &\r\ncpu_to_le16(IEEE80211_SCTL_FRAG)) == 0);\r\nbool lastseg = ((hdr->frame_control &\r\ncpu_to_le16(IEEE80211_FCTL_MOREFRAGS)) == 0);\r\ndma_addr_t mapping;\r\nu8 bw_40 = 0;\r\nu8 short_gi = 0;\r\nif (mac->opmode == NL80211_IFTYPE_STATION) {\r\nbw_40 = mac->bw_40;\r\n} else if (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC) {\r\nif (sta)\r\nbw_40 = sta->ht_cap.cap &\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\n}\r\nseq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\r\nrtl_get_tcb_desc(hw, info, sta, skb, ptcb_desc);\r\nif (rtlhal->earlymode_enable) {\r\nskb_push(skb, EM_HDR_LEN);\r\nmemset(skb->data, 0, EM_HDR_LEN);\r\n}\r\nbuf_len = skb->len;\r\nmapping = pci_map_single(rtlpci->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(rtlpci->pdev, mapping)) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE, "DMA mapping error\n");\r\nreturn;\r\n}\r\nCLEAR_PCI_TX_DESC_CONTENT(pdesc, sizeof(struct tx_desc_8723be));\r\nif (ieee80211_is_nullfunc(fc) || ieee80211_is_ctl(fc)) {\r\nfirstseg = true;\r\nlastseg = true;\r\n}\r\nif (firstseg) {\r\nif (rtlhal->earlymode_enable) {\r\nSET_TX_DESC_PKT_OFFSET(pdesc, 1);\r\nSET_TX_DESC_OFFSET(pdesc, USB_HWDESC_HEADER_LEN +\r\nEM_HDR_LEN);\r\nif (ptcb_desc->empkt_num) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"Insert 8 byte.pTcb->EMPktNum:%d\n",\r\nptcb_desc->empkt_num);\r\n_rtl8723be_insert_emcontent(ptcb_desc,\r\n(u8 *)(skb->data));\r\n}\r\n} else {\r\nSET_TX_DESC_OFFSET(pdesc, USB_HWDESC_HEADER_LEN);\r\n}\r\nSET_TX_DESC_TX_RATE(pdesc, ptcb_desc->hw_rate);\r\nif (ptcb_desc->hw_rate > DESC92C_RATEMCS0)\r\nshort_gi = (ptcb_desc->use_shortgi) ? 1 : 0;\r\nelse\r\nshort_gi = (ptcb_desc->use_shortpreamble) ? 1 : 0;\r\nSET_TX_DESC_DATA_SHORTGI(pdesc, short_gi);\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU) {\r\nSET_TX_DESC_AGG_ENABLE(pdesc, 1);\r\nSET_TX_DESC_MAX_AGG_NUM(pdesc, 0x14);\r\n}\r\nSET_TX_DESC_SEQ(pdesc, seq_number);\r\nSET_TX_DESC_RTS_ENABLE(pdesc, ((ptcb_desc->rts_enable &&\r\n!ptcb_desc->cts_enable) ?\r\n1 : 0));\r\nSET_TX_DESC_HW_RTS_ENABLE(pdesc, 0);\r\nSET_TX_DESC_CTS2SELF(pdesc, ((ptcb_desc->cts_enable) ?\r\n1 : 0));\r\nSET_TX_DESC_RTS_RATE(pdesc, ptcb_desc->rts_rate);\r\nSET_TX_DESC_RTS_SC(pdesc, ptcb_desc->rts_sc);\r\nSET_TX_DESC_RTS_SHORT(pdesc,\r\n((ptcb_desc->rts_rate <= DESC92C_RATE54M) ?\r\n(ptcb_desc->rts_use_shortpreamble ? 1 : 0) :\r\n(ptcb_desc->rts_use_shortgi ? 1 : 0)));\r\nif (ptcb_desc->tx_enable_sw_calc_duration)\r\nSET_TX_DESC_NAV_USE_HDR(pdesc, 1);\r\nif (bw_40) {\r\nif (ptcb_desc->packet_bw == HT_CHANNEL_WIDTH_20_40) {\r\nSET_TX_DESC_DATA_BW(pdesc, 1);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc, 3);\r\n} else {\r\nSET_TX_DESC_DATA_BW(pdesc, 0);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc, mac->cur_40_prime_sc);\r\n}\r\n} else {\r\nSET_TX_DESC_DATA_BW(pdesc, 0);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc, 0);\r\n}\r\nSET_TX_DESC_LINIP(pdesc, 0);\r\nSET_TX_DESC_PKT_SIZE(pdesc, (u16) skb_len);\r\nif (sta) {\r\nu8 ampdu_density = sta->ht_cap.ampdu_density;\r\nSET_TX_DESC_AMPDU_DENSITY(pdesc, ampdu_density);\r\n}\r\nif (info->control.hw_key) {\r\nstruct ieee80211_key_conf *keyconf =\r\ninfo->control.hw_key;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x1);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x3);\r\nbreak;\r\ndefault:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x0);\r\nbreak;\r\n}\r\n}\r\nSET_TX_DESC_QUEUE_SEL(pdesc, fw_qsel);\r\nSET_TX_DESC_DATA_RATE_FB_LIMIT(pdesc, 0x1F);\r\nSET_TX_DESC_RTS_RATE_FB_LIMIT(pdesc, 0xF);\r\nSET_TX_DESC_DISABLE_FB(pdesc, ptcb_desc->disable_ratefallback ?\r\n1 : 0);\r\nSET_TX_DESC_USE_RATE(pdesc, ptcb_desc->use_driver_rate ? 1 : 0);\r\nif (ieee80211_is_data_qos(fc)) {\r\nif (mac->rdg_en) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"Enable RDG function.\n");\r\nSET_TX_DESC_RDG_ENABLE(pdesc, 1);\r\nSET_TX_DESC_HTC(pdesc, 1);\r\n}\r\n}\r\n}\r\nSET_TX_DESC_FIRST_SEG(pdesc, (firstseg ? 1 : 0));\r\nSET_TX_DESC_LAST_SEG(pdesc, (lastseg ? 1 : 0));\r\nSET_TX_DESC_TX_BUFFER_SIZE(pdesc, (u16) buf_len);\r\nSET_TX_DESC_TX_BUFFER_ADDRESS(pdesc, mapping);\r\nif (1) {\r\nSET_TX_DESC_RATE_ID(pdesc, ptcb_desc->ratr_index);\r\nSET_TX_DESC_MACID(pdesc, ptcb_desc->mac_id);\r\n} else {\r\nSET_TX_DESC_RATE_ID(pdesc, 0xC + ptcb_desc->ratr_index);\r\nSET_TX_DESC_MACID(pdesc, ptcb_desc->mac_id);\r\n}\r\nif (!ieee80211_is_data_qos(fc)) {\r\nSET_TX_DESC_HWSEQ_EN(pdesc, 1);\r\nSET_TX_DESC_HWSEQ_SEL(pdesc, 0);\r\n}\r\nSET_TX_DESC_MORE_FRAG(pdesc, (lastseg ? 0 : 1));\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\r\nis_broadcast_ether_addr(ieee80211_get_DA(hdr))) {\r\nSET_TX_DESC_BMC(pdesc, 1);\r\n}\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE, "\n");\r\n}\r\nvoid rtl8723be_tx_fill_cmddesc(struct ieee80211_hw *hw, u8 *pdesc,\r\nbool firstseg, bool lastseg,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu8 fw_queue = QSLT_BEACON;\r\ndma_addr_t mapping = pci_map_single(rtlpci->pdev,\r\nskb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(rtlpci->pdev, mapping)) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"DMA mapping error\n");\r\nreturn;\r\n}\r\nCLEAR_PCI_TX_DESC_CONTENT(pdesc, TX_DESC_SIZE);\r\nSET_TX_DESC_OFFSET(pdesc, USB_HWDESC_HEADER_LEN);\r\nSET_TX_DESC_TX_RATE(pdesc, DESC92C_RATE1M);\r\nSET_TX_DESC_SEQ(pdesc, 0);\r\nSET_TX_DESC_LINIP(pdesc, 0);\r\nSET_TX_DESC_QUEUE_SEL(pdesc, fw_queue);\r\nSET_TX_DESC_FIRST_SEG(pdesc, 1);\r\nSET_TX_DESC_LAST_SEG(pdesc, 1);\r\nSET_TX_DESC_TX_BUFFER_SIZE(pdesc, (u16)(skb->len));\r\nSET_TX_DESC_TX_BUFFER_ADDRESS(pdesc, mapping);\r\nSET_TX_DESC_RATE_ID(pdesc, 0);\r\nSET_TX_DESC_MACID(pdesc, 0);\r\nSET_TX_DESC_OWN(pdesc, 1);\r\nSET_TX_DESC_PKT_SIZE((u8 *)pdesc, (u16)(skb->len));\r\nSET_TX_DESC_FIRST_SEG(pdesc, 1);\r\nSET_TX_DESC_LAST_SEG(pdesc, 1);\r\nSET_TX_DESC_USE_RATE(pdesc, 1);\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"H2C Tx Cmd Content\n", pdesc, TX_DESC_SIZE);\r\n}\r\nvoid rtl8723be_set_desc(struct ieee80211_hw *hw, u8 *pdesc,\r\nbool istx, u8 desc_name, u8 *val)\r\n{\r\nif (istx) {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nSET_TX_DESC_OWN(pdesc, 1);\r\nbreak;\r\ncase HW_DESC_TX_NEXTDESC_ADDR:\r\nSET_TX_DESC_NEXT_DESC_ADDRESS(pdesc, *(u32 *)val);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "ERR txdesc :%d not process\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n} else {\r\nswitch (desc_name) {\r\ncase HW_DESC_RXOWN:\r\nSET_RX_DESC_OWN(pdesc, 1);\r\nbreak;\r\ncase HW_DESC_RXBUFF_ADDR:\r\nSET_RX_DESC_BUFF_ADDR(pdesc, *(u32 *)val);\r\nbreak;\r\ncase HW_DESC_RXPKT_LEN:\r\nSET_RX_DESC_PKT_LEN(pdesc, *(u32 *)val);\r\nbreak;\r\ncase HW_DESC_RXERO:\r\nSET_RX_DESC_EOR(pdesc, 1);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "ERR rxdesc :%d not process\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n}\r\n}\r\nu32 rtl8723be_get_desc(u8 *pdesc, bool istx, u8 desc_name)\r\n{\r\nu32 ret = 0;\r\nif (istx) {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nret = GET_TX_DESC_OWN(pdesc);\r\nbreak;\r\ncase HW_DESC_TXBUFF_ADDR:\r\nret = GET_TX_DESC_TX_BUFFER_ADDRESS(pdesc);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "ERR txdesc :%d not process\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n} else {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nret = GET_RX_DESC_OWN(pdesc);\r\nbreak;\r\ncase HW_DESC_RXPKT_LEN:\r\nret = GET_RX_DESC_PKT_LEN(pdesc);\r\nbreak;\r\ncase HW_DESC_RXBUFF_ADDR:\r\nret = GET_RX_DESC_BUFF_ADDR(pdesc);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "ERR rxdesc :%d not process\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nbool rtl8723be_is_tx_desc_closed(struct ieee80211_hw *hw,\r\nu8 hw_queue, u16 index)\r\n{\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[hw_queue];\r\nu8 *entry = (u8 *)(&ring->desc[ring->idx]);\r\nu8 own = (u8)rtl8723be_get_desc(entry, true, HW_DESC_OWN);\r\nif (own)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid rtl8723be_tx_polling(struct ieee80211_hw *hw, u8 hw_queue)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (hw_queue == BEACON_QUEUE) {\r\nrtl_write_word(rtlpriv, REG_PCIE_CTRL_REG, BIT(4));\r\n} else {\r\nrtl_write_word(rtlpriv, REG_PCIE_CTRL_REG,\r\nBIT(0) << (hw_queue));\r\n}\r\n}\r\nu32 rtl8723be_rx_command_packet(struct ieee80211_hw *hw,\r\nconst struct rtl_stats *status,\r\nstruct sk_buff *skb)\r\n{\r\nu32 result = 0;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nswitch (status->packet_report_type) {\r\ncase NORMAL_RX:\r\nresult = 0;\r\nbreak;\r\ncase C2H_PACKET:\r\nrtl8723be_c2h_packet_handler(hw, skb->data,\r\n(u8)skb->len);\r\nresult = 1;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_RECV, DBG_TRACE,\r\n"No this packet type!!\n");\r\nbreak;\r\n}\r\nreturn result;\r\n}
