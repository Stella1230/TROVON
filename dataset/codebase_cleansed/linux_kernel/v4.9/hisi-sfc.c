static inline int wait_op_finish(struct hifmc_host *host)\r\n{\r\nu32 reg;\r\nreturn readl_poll_timeout(host->regbase + FMC_INT, reg,\r\n(reg & FMC_INT_OP_DONE), 0, FMC_WAIT_TIMEOUT);\r\n}\r\nstatic int get_if_type(enum read_mode flash_read)\r\n{\r\nenum hifmc_iftype if_type;\r\nswitch (flash_read) {\r\ncase SPI_NOR_DUAL:\r\nif_type = IF_TYPE_DUAL;\r\nbreak;\r\ncase SPI_NOR_QUAD:\r\nif_type = IF_TYPE_QUAD;\r\nbreak;\r\ncase SPI_NOR_NORMAL:\r\ncase SPI_NOR_FAST:\r\ndefault:\r\nif_type = IF_TYPE_STD;\r\nbreak;\r\n}\r\nreturn if_type;\r\n}\r\nstatic void hisi_spi_nor_init(struct hifmc_host *host)\r\n{\r\nu32 reg;\r\nreg = TIMING_CFG_TCSH(CS_HOLD_TIME)\r\n| TIMING_CFG_TCSS(CS_SETUP_TIME)\r\n| TIMING_CFG_TSHSL(CS_DESELECT_TIME);\r\nwritel(reg, host->regbase + FMC_SPI_TIMING_CFG);\r\n}\r\nstatic int hisi_spi_nor_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nint ret;\r\nmutex_lock(&host->lock);\r\nret = clk_set_rate(host->clk, priv->clkrate);\r\nif (ret)\r\ngoto out;\r\nret = clk_prepare_enable(host->clk);\r\nif (ret)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nmutex_unlock(&host->lock);\r\nreturn ret;\r\n}\r\nstatic void hisi_spi_nor_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nclk_disable_unprepare(host->clk);\r\nmutex_unlock(&host->lock);\r\n}\r\nstatic int hisi_spi_nor_op_reg(struct spi_nor *nor,\r\nu8 opcode, int len, u8 optype)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nu32 reg;\r\nreg = FMC_CMD_CMD1(opcode);\r\nwritel(reg, host->regbase + FMC_CMD);\r\nreg = FMC_DATA_NUM_CNT(len);\r\nwritel(reg, host->regbase + FMC_DATA_NUM);\r\nreg = OP_CFG_FM_CS(priv->chipselect);\r\nwritel(reg, host->regbase + FMC_OP_CFG);\r\nwritel(0xff, host->regbase + FMC_INT_CLR);\r\nreg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START | optype;\r\nwritel(reg, host->regbase + FMC_OP);\r\nreturn wait_op_finish(host);\r\n}\r\nstatic int hisi_spi_nor_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf,\r\nint len)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nint ret;\r\nret = hisi_spi_nor_op_reg(nor, opcode, len, FMC_OP_READ_DATA_EN);\r\nif (ret)\r\nreturn ret;\r\nmemcpy_fromio(buf, host->iobase, len);\r\nreturn 0;\r\n}\r\nstatic int hisi_spi_nor_write_reg(struct spi_nor *nor, u8 opcode,\r\nu8 *buf, int len)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nif (len)\r\nmemcpy_toio(host->iobase, buf, len);\r\nreturn hisi_spi_nor_op_reg(nor, opcode, len, FMC_OP_WRITE_DATA_EN);\r\n}\r\nstatic int hisi_spi_nor_dma_transfer(struct spi_nor *nor, loff_t start_off,\r\ndma_addr_t dma_buf, size_t len, u8 op_type)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nu8 if_type = 0;\r\nu32 reg;\r\nreg = readl(host->regbase + FMC_CFG);\r\nreg &= ~(FMC_CFG_OP_MODE_MASK | SPI_NOR_ADDR_MODE_MASK);\r\nreg |= FMC_CFG_OP_MODE_NORMAL;\r\nreg |= (nor->addr_width == 4) ? SPI_NOR_ADDR_MODE_4BYTES\r\n: SPI_NOR_ADDR_MODE_3BYTES;\r\nwritel(reg, host->regbase + FMC_CFG);\r\nwritel(start_off, host->regbase + FMC_ADDRL);\r\nwritel(dma_buf, host->regbase + FMC_DMA_SADDR_D0);\r\nwritel(FMC_DMA_LEN_SET(len), host->regbase + FMC_DMA_LEN);\r\nreg = OP_CFG_FM_CS(priv->chipselect);\r\nif_type = get_if_type(nor->flash_read);\r\nreg |= OP_CFG_MEM_IF_TYPE(if_type);\r\nif (op_type == FMC_OP_READ)\r\nreg |= OP_CFG_DUMMY_NUM(nor->read_dummy >> 3);\r\nwritel(reg, host->regbase + FMC_OP_CFG);\r\nwritel(0xff, host->regbase + FMC_INT_CLR);\r\nreg = OP_CTRL_RW_OP(op_type) | OP_CTRL_DMA_OP_READY;\r\nreg |= (op_type == FMC_OP_READ)\r\n? OP_CTRL_RD_OPCODE(nor->read_opcode)\r\n: OP_CTRL_WR_OPCODE(nor->program_opcode);\r\nwritel(reg, host->regbase + FMC_OP_DMA);\r\nreturn wait_op_finish(host);\r\n}\r\nstatic ssize_t hisi_spi_nor_read(struct spi_nor *nor, loff_t from, size_t len,\r\nu_char *read_buf)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nsize_t offset;\r\nint ret;\r\nfor (offset = 0; offset < len; offset += HIFMC_DMA_MAX_LEN) {\r\nsize_t trans = min_t(size_t, HIFMC_DMA_MAX_LEN, len - offset);\r\nret = hisi_spi_nor_dma_transfer(nor,\r\nfrom + offset, host->dma_buffer, trans, FMC_OP_READ);\r\nif (ret) {\r\ndev_warn(nor->dev, "DMA read timeout\n");\r\nreturn ret;\r\n}\r\nmemcpy(read_buf + offset, host->buffer, trans);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t hisi_spi_nor_write(struct spi_nor *nor, loff_t to,\r\nsize_t len, const u_char *write_buf)\r\n{\r\nstruct hifmc_priv *priv = nor->priv;\r\nstruct hifmc_host *host = priv->host;\r\nsize_t offset;\r\nint ret;\r\nfor (offset = 0; offset < len; offset += HIFMC_DMA_MAX_LEN) {\r\nsize_t trans = min_t(size_t, HIFMC_DMA_MAX_LEN, len - offset);\r\nmemcpy(host->buffer, write_buf + offset, trans);\r\nret = hisi_spi_nor_dma_transfer(nor,\r\nto + offset, host->dma_buffer, trans, FMC_OP_WRITE);\r\nif (ret) {\r\ndev_warn(nor->dev, "DMA write timeout\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int hisi_spi_nor_register(struct device_node *np,\r\nstruct hifmc_host *host)\r\n{\r\nstruct device *dev = host->dev;\r\nstruct spi_nor *nor;\r\nstruct hifmc_priv *priv;\r\nstruct mtd_info *mtd;\r\nint ret;\r\nnor = devm_kzalloc(dev, sizeof(*nor), GFP_KERNEL);\r\nif (!nor)\r\nreturn -ENOMEM;\r\nnor->dev = dev;\r\nspi_nor_set_flash_node(nor, np);\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32(np, "reg", &priv->chipselect);\r\nif (ret) {\r\ndev_err(dev, "There's no reg property for %s\n",\r\nnp->full_name);\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "spi-max-frequency",\r\n&priv->clkrate);\r\nif (ret) {\r\ndev_err(dev, "There's no spi-max-frequency property for %s\n",\r\nnp->full_name);\r\nreturn ret;\r\n}\r\npriv->host = host;\r\nnor->priv = priv;\r\nnor->prepare = hisi_spi_nor_prep;\r\nnor->unprepare = hisi_spi_nor_unprep;\r\nnor->read_reg = hisi_spi_nor_read_reg;\r\nnor->write_reg = hisi_spi_nor_write_reg;\r\nnor->read = hisi_spi_nor_read;\r\nnor->write = hisi_spi_nor_write;\r\nnor->erase = NULL;\r\nret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\r\nif (ret)\r\nreturn ret;\r\nmtd = &nor->mtd;\r\nmtd->name = np->name;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nhost->nor[host->num_chip] = nor;\r\nhost->num_chip++;\r\nreturn 0;\r\n}\r\nstatic void hisi_spi_nor_unregister_all(struct hifmc_host *host)\r\n{\r\nint i;\r\nfor (i = 0; i < host->num_chip; i++)\r\nmtd_device_unregister(&host->nor[i]->mtd);\r\n}\r\nstatic int hisi_spi_nor_register_all(struct hifmc_host *host)\r\n{\r\nstruct device *dev = host->dev;\r\nstruct device_node *np;\r\nint ret;\r\nfor_each_available_child_of_node(dev->of_node, np) {\r\nret = hisi_spi_nor_register(np, host);\r\nif (ret)\r\ngoto fail;\r\nif (host->num_chip == HIFMC_MAX_CHIP_NUM) {\r\ndev_warn(dev, "Flash device number exceeds the maximum chipselect number\n");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nhisi_spi_nor_unregister_all(host);\r\nreturn ret;\r\n}\r\nstatic int hisi_spi_nor_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct hifmc_host *host;\r\nint ret;\r\nhost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, host);\r\nhost->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "control");\r\nhost->regbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->regbase))\r\nreturn PTR_ERR(host->regbase);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "memory");\r\nhost->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->iobase))\r\nreturn PTR_ERR(host->iobase);\r\nhost->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(host->clk))\r\nreturn PTR_ERR(host->clk);\r\nret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_warn(dev, "Unable to set dma mask\n");\r\nreturn ret;\r\n}\r\nhost->buffer = dmam_alloc_coherent(dev, HIFMC_DMA_MAX_LEN,\r\n&host->dma_buffer, GFP_KERNEL);\r\nif (!host->buffer)\r\nreturn -ENOMEM;\r\nmutex_init(&host->lock);\r\nclk_prepare_enable(host->clk);\r\nhisi_spi_nor_init(host);\r\nret = hisi_spi_nor_register_all(host);\r\nif (ret)\r\nmutex_destroy(&host->lock);\r\nclk_disable_unprepare(host->clk);\r\nreturn ret;\r\n}\r\nstatic int hisi_spi_nor_remove(struct platform_device *pdev)\r\n{\r\nstruct hifmc_host *host = platform_get_drvdata(pdev);\r\nhisi_spi_nor_unregister_all(host);\r\nmutex_destroy(&host->lock);\r\nclk_disable_unprepare(host->clk);\r\nreturn 0;\r\n}
