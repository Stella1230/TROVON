static const struct virtio_transport *virtio_transport_get_ops(void)\r\n{\r\nconst struct vsock_transport *t = vsock_core_get_transport();\r\nreturn container_of(t, struct virtio_transport, transport);\r\n}\r\nstruct virtio_vsock_pkt *\r\nvirtio_transport_alloc_pkt(struct virtio_vsock_pkt_info *info,\r\nsize_t len,\r\nu32 src_cid,\r\nu32 src_port,\r\nu32 dst_cid,\r\nu32 dst_port)\r\n{\r\nstruct virtio_vsock_pkt *pkt;\r\nint err;\r\npkt = kzalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt)\r\nreturn NULL;\r\npkt->hdr.type = cpu_to_le16(info->type);\r\npkt->hdr.op = cpu_to_le16(info->op);\r\npkt->hdr.src_cid = cpu_to_le64(src_cid);\r\npkt->hdr.dst_cid = cpu_to_le64(dst_cid);\r\npkt->hdr.src_port = cpu_to_le32(src_port);\r\npkt->hdr.dst_port = cpu_to_le32(dst_port);\r\npkt->hdr.flags = cpu_to_le32(info->flags);\r\npkt->len = len;\r\npkt->hdr.len = cpu_to_le32(len);\r\npkt->reply = info->reply;\r\nif (info->msg && len > 0) {\r\npkt->buf = kmalloc(len, GFP_KERNEL);\r\nif (!pkt->buf)\r\ngoto out_pkt;\r\nerr = memcpy_from_msg(pkt->buf, info->msg, len);\r\nif (err)\r\ngoto out;\r\n}\r\ntrace_virtio_transport_alloc_pkt(src_cid, src_port,\r\ndst_cid, dst_port,\r\nlen,\r\ninfo->type,\r\ninfo->op,\r\ninfo->flags);\r\nreturn pkt;\r\nout:\r\nkfree(pkt->buf);\r\nout_pkt:\r\nkfree(pkt);\r\nreturn NULL;\r\n}\r\nstatic int virtio_transport_send_pkt_info(struct vsock_sock *vsk,\r\nstruct virtio_vsock_pkt_info *info)\r\n{\r\nu32 src_cid, src_port, dst_cid, dst_port;\r\nstruct virtio_vsock_sock *vvs;\r\nstruct virtio_vsock_pkt *pkt;\r\nu32 pkt_len = info->pkt_len;\r\nsrc_cid = vm_sockets_get_local_cid();\r\nsrc_port = vsk->local_addr.svm_port;\r\nif (!info->remote_cid) {\r\ndst_cid = vsk->remote_addr.svm_cid;\r\ndst_port = vsk->remote_addr.svm_port;\r\n} else {\r\ndst_cid = info->remote_cid;\r\ndst_port = info->remote_port;\r\n}\r\nvvs = vsk->trans;\r\nif (pkt_len > VIRTIO_VSOCK_DEFAULT_RX_BUF_SIZE)\r\npkt_len = VIRTIO_VSOCK_DEFAULT_RX_BUF_SIZE;\r\npkt_len = virtio_transport_get_credit(vvs, pkt_len);\r\nif (pkt_len == 0 && info->op == VIRTIO_VSOCK_OP_RW)\r\nreturn pkt_len;\r\npkt = virtio_transport_alloc_pkt(info, pkt_len,\r\nsrc_cid, src_port,\r\ndst_cid, dst_port);\r\nif (!pkt) {\r\nvirtio_transport_put_credit(vvs, pkt_len);\r\nreturn -ENOMEM;\r\n}\r\nvirtio_transport_inc_tx_pkt(vvs, pkt);\r\nreturn virtio_transport_get_ops()->send_pkt(pkt);\r\n}\r\nstatic void virtio_transport_inc_rx_pkt(struct virtio_vsock_sock *vvs,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nvvs->rx_bytes += pkt->len;\r\n}\r\nstatic void virtio_transport_dec_rx_pkt(struct virtio_vsock_sock *vvs,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nvvs->rx_bytes -= pkt->len;\r\nvvs->fwd_cnt += pkt->len;\r\n}\r\nvoid virtio_transport_inc_tx_pkt(struct virtio_vsock_sock *vvs, struct virtio_vsock_pkt *pkt)\r\n{\r\nspin_lock_bh(&vvs->tx_lock);\r\npkt->hdr.fwd_cnt = cpu_to_le32(vvs->fwd_cnt);\r\npkt->hdr.buf_alloc = cpu_to_le32(vvs->buf_alloc);\r\nspin_unlock_bh(&vvs->tx_lock);\r\n}\r\nu32 virtio_transport_get_credit(struct virtio_vsock_sock *vvs, u32 credit)\r\n{\r\nu32 ret;\r\nspin_lock_bh(&vvs->tx_lock);\r\nret = vvs->peer_buf_alloc - (vvs->tx_cnt - vvs->peer_fwd_cnt);\r\nif (ret > credit)\r\nret = credit;\r\nvvs->tx_cnt += ret;\r\nspin_unlock_bh(&vvs->tx_lock);\r\nreturn ret;\r\n}\r\nvoid virtio_transport_put_credit(struct virtio_vsock_sock *vvs, u32 credit)\r\n{\r\nspin_lock_bh(&vvs->tx_lock);\r\nvvs->tx_cnt -= credit;\r\nspin_unlock_bh(&vvs->tx_lock);\r\n}\r\nstatic int virtio_transport_send_credit_update(struct vsock_sock *vsk,\r\nint type,\r\nstruct virtio_vsock_hdr *hdr)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_CREDIT_UPDATE,\r\n.type = type,\r\n};\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nstatic ssize_t\r\nvirtio_transport_stream_do_dequeue(struct vsock_sock *vsk,\r\nstruct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nstruct virtio_vsock_pkt *pkt;\r\nsize_t bytes, total = 0;\r\nint err = -EFAULT;\r\nspin_lock_bh(&vvs->rx_lock);\r\nwhile (total < len && !list_empty(&vvs->rx_queue)) {\r\npkt = list_first_entry(&vvs->rx_queue,\r\nstruct virtio_vsock_pkt, list);\r\nbytes = len - total;\r\nif (bytes > pkt->len - pkt->off)\r\nbytes = pkt->len - pkt->off;\r\nspin_unlock_bh(&vvs->rx_lock);\r\nerr = memcpy_to_msg(msg, pkt->buf + pkt->off, bytes);\r\nif (err)\r\ngoto out;\r\nspin_lock_bh(&vvs->rx_lock);\r\ntotal += bytes;\r\npkt->off += bytes;\r\nif (pkt->off == pkt->len) {\r\nvirtio_transport_dec_rx_pkt(vvs, pkt);\r\nlist_del(&pkt->list);\r\nvirtio_transport_free_pkt(pkt);\r\n}\r\n}\r\nspin_unlock_bh(&vvs->rx_lock);\r\nvirtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM,\r\nNULL);\r\nreturn total;\r\nout:\r\nif (total)\r\nerr = total;\r\nreturn err;\r\n}\r\nssize_t\r\nvirtio_transport_stream_dequeue(struct vsock_sock *vsk,\r\nstruct msghdr *msg,\r\nsize_t len, int flags)\r\n{\r\nif (flags & MSG_PEEK)\r\nreturn -EOPNOTSUPP;\r\nreturn virtio_transport_stream_do_dequeue(vsk, msg, len);\r\n}\r\nint\r\nvirtio_transport_dgram_dequeue(struct vsock_sock *vsk,\r\nstruct msghdr *msg,\r\nsize_t len, int flags)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\ns64 virtio_transport_stream_has_data(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\ns64 bytes;\r\nspin_lock_bh(&vvs->rx_lock);\r\nbytes = vvs->rx_bytes;\r\nspin_unlock_bh(&vvs->rx_lock);\r\nreturn bytes;\r\n}\r\nstatic s64 virtio_transport_has_space(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\ns64 bytes;\r\nbytes = vvs->peer_buf_alloc - (vvs->tx_cnt - vvs->peer_fwd_cnt);\r\nif (bytes < 0)\r\nbytes = 0;\r\nreturn bytes;\r\n}\r\ns64 virtio_transport_stream_has_space(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\ns64 bytes;\r\nspin_lock_bh(&vvs->tx_lock);\r\nbytes = virtio_transport_has_space(vsk);\r\nspin_unlock_bh(&vvs->tx_lock);\r\nreturn bytes;\r\n}\r\nint virtio_transport_do_socket_init(struct vsock_sock *vsk,\r\nstruct vsock_sock *psk)\r\n{\r\nstruct virtio_vsock_sock *vvs;\r\nvvs = kzalloc(sizeof(*vvs), GFP_KERNEL);\r\nif (!vvs)\r\nreturn -ENOMEM;\r\nvsk->trans = vvs;\r\nvvs->vsk = vsk;\r\nif (psk) {\r\nstruct virtio_vsock_sock *ptrans = psk->trans;\r\nvvs->buf_size = ptrans->buf_size;\r\nvvs->buf_size_min = ptrans->buf_size_min;\r\nvvs->buf_size_max = ptrans->buf_size_max;\r\nvvs->peer_buf_alloc = ptrans->peer_buf_alloc;\r\n} else {\r\nvvs->buf_size = VIRTIO_VSOCK_DEFAULT_BUF_SIZE;\r\nvvs->buf_size_min = VIRTIO_VSOCK_DEFAULT_MIN_BUF_SIZE;\r\nvvs->buf_size_max = VIRTIO_VSOCK_DEFAULT_MAX_BUF_SIZE;\r\n}\r\nvvs->buf_alloc = vvs->buf_size;\r\nspin_lock_init(&vvs->rx_lock);\r\nspin_lock_init(&vvs->tx_lock);\r\nINIT_LIST_HEAD(&vvs->rx_queue);\r\nreturn 0;\r\n}\r\nu64 virtio_transport_get_buffer_size(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nreturn vvs->buf_size;\r\n}\r\nu64 virtio_transport_get_min_buffer_size(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nreturn vvs->buf_size_min;\r\n}\r\nu64 virtio_transport_get_max_buffer_size(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nreturn vvs->buf_size_max;\r\n}\r\nvoid virtio_transport_set_buffer_size(struct vsock_sock *vsk, u64 val)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nif (val > VIRTIO_VSOCK_MAX_BUF_SIZE)\r\nval = VIRTIO_VSOCK_MAX_BUF_SIZE;\r\nif (val < vvs->buf_size_min)\r\nvvs->buf_size_min = val;\r\nif (val > vvs->buf_size_max)\r\nvvs->buf_size_max = val;\r\nvvs->buf_size = val;\r\nvvs->buf_alloc = val;\r\n}\r\nvoid virtio_transport_set_min_buffer_size(struct vsock_sock *vsk, u64 val)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nif (val > VIRTIO_VSOCK_MAX_BUF_SIZE)\r\nval = VIRTIO_VSOCK_MAX_BUF_SIZE;\r\nif (val > vvs->buf_size)\r\nvvs->buf_size = val;\r\nvvs->buf_size_min = val;\r\n}\r\nvoid virtio_transport_set_max_buffer_size(struct vsock_sock *vsk, u64 val)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nif (val > VIRTIO_VSOCK_MAX_BUF_SIZE)\r\nval = VIRTIO_VSOCK_MAX_BUF_SIZE;\r\nif (val < vvs->buf_size)\r\nvvs->buf_size = val;\r\nvvs->buf_size_max = val;\r\n}\r\nint\r\nvirtio_transport_notify_poll_in(struct vsock_sock *vsk,\r\nsize_t target,\r\nbool *data_ready_now)\r\n{\r\nif (vsock_stream_has_data(vsk))\r\n*data_ready_now = true;\r\nelse\r\n*data_ready_now = false;\r\nreturn 0;\r\n}\r\nint\r\nvirtio_transport_notify_poll_out(struct vsock_sock *vsk,\r\nsize_t target,\r\nbool *space_avail_now)\r\n{\r\ns64 free_space;\r\nfree_space = vsock_stream_has_space(vsk);\r\nif (free_space > 0)\r\n*space_avail_now = true;\r\nelse if (free_space == 0)\r\n*space_avail_now = false;\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_recv_init(struct vsock_sock *vsk,\r\nsize_t target, struct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_recv_pre_block(struct vsock_sock *vsk,\r\nsize_t target, struct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_recv_pre_dequeue(struct vsock_sock *vsk,\r\nsize_t target, struct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_recv_post_dequeue(struct vsock_sock *vsk,\r\nsize_t target, ssize_t copied, bool data_read,\r\nstruct vsock_transport_recv_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_send_init(struct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_send_pre_block(struct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_send_pre_enqueue(struct vsock_sock *vsk,\r\nstruct vsock_transport_send_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nint virtio_transport_notify_send_post_enqueue(struct vsock_sock *vsk,\r\nssize_t written, struct vsock_transport_send_notify_data *data)\r\n{\r\nreturn 0;\r\n}\r\nu64 virtio_transport_stream_rcvhiwat(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nreturn vvs->buf_size;\r\n}\r\nbool virtio_transport_stream_is_active(struct vsock_sock *vsk)\r\n{\r\nreturn true;\r\n}\r\nbool virtio_transport_stream_allow(u32 cid, u32 port)\r\n{\r\nreturn true;\r\n}\r\nint virtio_transport_dgram_bind(struct vsock_sock *vsk,\r\nstruct sockaddr_vm *addr)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nbool virtio_transport_dgram_allow(u32 cid, u32 port)\r\n{\r\nreturn false;\r\n}\r\nint virtio_transport_connect(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_REQUEST,\r\n.type = VIRTIO_VSOCK_TYPE_STREAM,\r\n};\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nint virtio_transport_shutdown(struct vsock_sock *vsk, int mode)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_SHUTDOWN,\r\n.type = VIRTIO_VSOCK_TYPE_STREAM,\r\n.flags = (mode & RCV_SHUTDOWN ?\r\nVIRTIO_VSOCK_SHUTDOWN_RCV : 0) |\r\n(mode & SEND_SHUTDOWN ?\r\nVIRTIO_VSOCK_SHUTDOWN_SEND : 0),\r\n};\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nint\r\nvirtio_transport_dgram_enqueue(struct vsock_sock *vsk,\r\nstruct sockaddr_vm *remote_addr,\r\nstruct msghdr *msg,\r\nsize_t dgram_len)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nssize_t\r\nvirtio_transport_stream_enqueue(struct vsock_sock *vsk,\r\nstruct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_RW,\r\n.type = VIRTIO_VSOCK_TYPE_STREAM,\r\n.msg = msg,\r\n.pkt_len = len,\r\n};\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nvoid virtio_transport_destruct(struct vsock_sock *vsk)\r\n{\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nkfree(vvs);\r\n}\r\nstatic int virtio_transport_reset(struct vsock_sock *vsk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_RST,\r\n.type = VIRTIO_VSOCK_TYPE_STREAM,\r\n.reply = !!pkt,\r\n};\r\nif (pkt && le16_to_cpu(pkt->hdr.op) == VIRTIO_VSOCK_OP_RST)\r\nreturn 0;\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nstatic int virtio_transport_reset_no_sock(struct virtio_vsock_pkt *pkt)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_RST,\r\n.type = le16_to_cpu(pkt->hdr.type),\r\n.reply = true,\r\n};\r\nif (le16_to_cpu(pkt->hdr.op) == VIRTIO_VSOCK_OP_RST)\r\nreturn 0;\r\npkt = virtio_transport_alloc_pkt(&info, 0,\r\nle32_to_cpu(pkt->hdr.dst_cid),\r\nle32_to_cpu(pkt->hdr.dst_port),\r\nle32_to_cpu(pkt->hdr.src_cid),\r\nle32_to_cpu(pkt->hdr.src_port));\r\nif (!pkt)\r\nreturn -ENOMEM;\r\nreturn virtio_transport_get_ops()->send_pkt(pkt);\r\n}\r\nstatic void virtio_transport_wait_close(struct sock *sk, long timeout)\r\n{\r\nif (timeout) {\r\nDEFINE_WAIT(wait);\r\ndo {\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (sk_wait_event(sk, &timeout,\r\nsock_flag(sk, SOCK_DONE)))\r\nbreak;\r\n} while (!signal_pending(current) && timeout);\r\nfinish_wait(sk_sleep(sk), &wait);\r\n}\r\n}\r\nstatic void virtio_transport_do_close(struct vsock_sock *vsk,\r\nbool cancel_timeout)\r\n{\r\nstruct sock *sk = sk_vsock(vsk);\r\nsock_set_flag(sk, SOCK_DONE);\r\nvsk->peer_shutdown = SHUTDOWN_MASK;\r\nif (vsock_stream_has_data(vsk) <= 0)\r\nsk->sk_state = SS_DISCONNECTING;\r\nsk->sk_state_change(sk);\r\nif (vsk->close_work_scheduled &&\r\n(!cancel_timeout || cancel_delayed_work(&vsk->close_work))) {\r\nvsk->close_work_scheduled = false;\r\nvsock_remove_sock(vsk);\r\nsock_put(sk);\r\n}\r\n}\r\nstatic void virtio_transport_close_timeout(struct work_struct *work)\r\n{\r\nstruct vsock_sock *vsk =\r\ncontainer_of(work, struct vsock_sock, close_work.work);\r\nstruct sock *sk = sk_vsock(vsk);\r\nsock_hold(sk);\r\nlock_sock(sk);\r\nif (!sock_flag(sk, SOCK_DONE)) {\r\n(void)virtio_transport_reset(vsk, NULL);\r\nvirtio_transport_do_close(vsk, false);\r\n}\r\nvsk->close_work_scheduled = false;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic bool virtio_transport_close(struct vsock_sock *vsk)\r\n{\r\nstruct sock *sk = &vsk->sk;\r\nif (!(sk->sk_state == SS_CONNECTED ||\r\nsk->sk_state == SS_DISCONNECTING))\r\nreturn true;\r\nif ((vsk->peer_shutdown & SHUTDOWN_MASK) == SHUTDOWN_MASK) {\r\n(void)virtio_transport_reset(vsk, NULL);\r\nreturn true;\r\n}\r\nif ((sk->sk_shutdown & SHUTDOWN_MASK) != SHUTDOWN_MASK)\r\n(void)virtio_transport_shutdown(vsk, SHUTDOWN_MASK);\r\nif (sock_flag(sk, SOCK_LINGER) && !(current->flags & PF_EXITING))\r\nvirtio_transport_wait_close(sk, sk->sk_lingertime);\r\nif (sock_flag(sk, SOCK_DONE)) {\r\nreturn true;\r\n}\r\nsock_hold(sk);\r\nINIT_DELAYED_WORK(&vsk->close_work,\r\nvirtio_transport_close_timeout);\r\nvsk->close_work_scheduled = true;\r\nschedule_delayed_work(&vsk->close_work, VSOCK_CLOSE_TIMEOUT);\r\nreturn false;\r\n}\r\nvoid virtio_transport_release(struct vsock_sock *vsk)\r\n{\r\nstruct sock *sk = &vsk->sk;\r\nbool remove_sock = true;\r\nlock_sock(sk);\r\nif (sk->sk_type == SOCK_STREAM)\r\nremove_sock = virtio_transport_close(vsk);\r\nrelease_sock(sk);\r\nif (remove_sock)\r\nvsock_remove_sock(vsk);\r\n}\r\nstatic int\r\nvirtio_transport_recv_connecting(struct sock *sk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nint err;\r\nint skerr;\r\nswitch (le16_to_cpu(pkt->hdr.op)) {\r\ncase VIRTIO_VSOCK_OP_RESPONSE:\r\nsk->sk_state = SS_CONNECTED;\r\nsk->sk_socket->state = SS_CONNECTED;\r\nvsock_insert_connected(vsk);\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase VIRTIO_VSOCK_OP_INVALID:\r\nbreak;\r\ncase VIRTIO_VSOCK_OP_RST:\r\nskerr = ECONNRESET;\r\nerr = 0;\r\ngoto destroy;\r\ndefault:\r\nskerr = EPROTO;\r\nerr = -EINVAL;\r\ngoto destroy;\r\n}\r\nreturn 0;\r\ndestroy:\r\nvirtio_transport_reset(vsk, pkt);\r\nsk->sk_state = SS_UNCONNECTED;\r\nsk->sk_err = skerr;\r\nsk->sk_error_report(sk);\r\nreturn err;\r\n}\r\nstatic int\r\nvirtio_transport_recv_connected(struct sock *sk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nint err = 0;\r\nswitch (le16_to_cpu(pkt->hdr.op)) {\r\ncase VIRTIO_VSOCK_OP_RW:\r\npkt->len = le32_to_cpu(pkt->hdr.len);\r\npkt->off = 0;\r\nspin_lock_bh(&vvs->rx_lock);\r\nvirtio_transport_inc_rx_pkt(vvs, pkt);\r\nlist_add_tail(&pkt->list, &vvs->rx_queue);\r\nspin_unlock_bh(&vvs->rx_lock);\r\nsk->sk_data_ready(sk);\r\nreturn err;\r\ncase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\r\nsk->sk_write_space(sk);\r\nbreak;\r\ncase VIRTIO_VSOCK_OP_SHUTDOWN:\r\nif (le32_to_cpu(pkt->hdr.flags) & VIRTIO_VSOCK_SHUTDOWN_RCV)\r\nvsk->peer_shutdown |= RCV_SHUTDOWN;\r\nif (le32_to_cpu(pkt->hdr.flags) & VIRTIO_VSOCK_SHUTDOWN_SEND)\r\nvsk->peer_shutdown |= SEND_SHUTDOWN;\r\nif (vsk->peer_shutdown == SHUTDOWN_MASK &&\r\nvsock_stream_has_data(vsk) <= 0)\r\nsk->sk_state = SS_DISCONNECTING;\r\nif (le32_to_cpu(pkt->hdr.flags))\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase VIRTIO_VSOCK_OP_RST:\r\nvirtio_transport_do_close(vsk, true);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nvirtio_transport_free_pkt(pkt);\r\nreturn err;\r\n}\r\nstatic void\r\nvirtio_transport_recv_disconnecting(struct sock *sk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nif (le16_to_cpu(pkt->hdr.op) == VIRTIO_VSOCK_OP_RST)\r\nvirtio_transport_do_close(vsk, true);\r\n}\r\nstatic int\r\nvirtio_transport_send_response(struct vsock_sock *vsk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct virtio_vsock_pkt_info info = {\r\n.op = VIRTIO_VSOCK_OP_RESPONSE,\r\n.type = VIRTIO_VSOCK_TYPE_STREAM,\r\n.remote_cid = le32_to_cpu(pkt->hdr.src_cid),\r\n.remote_port = le32_to_cpu(pkt->hdr.src_port),\r\n.reply = true,\r\n};\r\nreturn virtio_transport_send_pkt_info(vsk, &info);\r\n}\r\nstatic int\r\nvirtio_transport_recv_listen(struct sock *sk, struct virtio_vsock_pkt *pkt)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nstruct vsock_sock *vchild;\r\nstruct sock *child;\r\nif (le16_to_cpu(pkt->hdr.op) != VIRTIO_VSOCK_OP_REQUEST) {\r\nvirtio_transport_reset(vsk, pkt);\r\nreturn -EINVAL;\r\n}\r\nif (sk_acceptq_is_full(sk)) {\r\nvirtio_transport_reset(vsk, pkt);\r\nreturn -ENOMEM;\r\n}\r\nchild = __vsock_create(sock_net(sk), NULL, sk, GFP_KERNEL,\r\nsk->sk_type, 0);\r\nif (!child) {\r\nvirtio_transport_reset(vsk, pkt);\r\nreturn -ENOMEM;\r\n}\r\nsk->sk_ack_backlog++;\r\nlock_sock_nested(child, SINGLE_DEPTH_NESTING);\r\nchild->sk_state = SS_CONNECTED;\r\nvchild = vsock_sk(child);\r\nvsock_addr_init(&vchild->local_addr, le32_to_cpu(pkt->hdr.dst_cid),\r\nle32_to_cpu(pkt->hdr.dst_port));\r\nvsock_addr_init(&vchild->remote_addr, le32_to_cpu(pkt->hdr.src_cid),\r\nle32_to_cpu(pkt->hdr.src_port));\r\nvsock_insert_connected(vchild);\r\nvsock_enqueue_accept(sk, child);\r\nvirtio_transport_send_response(vchild, pkt);\r\nrelease_sock(child);\r\nsk->sk_data_ready(sk);\r\nreturn 0;\r\n}\r\nstatic bool virtio_transport_space_update(struct sock *sk,\r\nstruct virtio_vsock_pkt *pkt)\r\n{\r\nstruct vsock_sock *vsk = vsock_sk(sk);\r\nstruct virtio_vsock_sock *vvs = vsk->trans;\r\nbool space_available;\r\nspin_lock_bh(&vvs->tx_lock);\r\nvvs->peer_buf_alloc = le32_to_cpu(pkt->hdr.buf_alloc);\r\nvvs->peer_fwd_cnt = le32_to_cpu(pkt->hdr.fwd_cnt);\r\nspace_available = virtio_transport_has_space(vsk);\r\nspin_unlock_bh(&vvs->tx_lock);\r\nreturn space_available;\r\n}\r\nvoid virtio_transport_recv_pkt(struct virtio_vsock_pkt *pkt)\r\n{\r\nstruct sockaddr_vm src, dst;\r\nstruct vsock_sock *vsk;\r\nstruct sock *sk;\r\nbool space_available;\r\nvsock_addr_init(&src, le32_to_cpu(pkt->hdr.src_cid),\r\nle32_to_cpu(pkt->hdr.src_port));\r\nvsock_addr_init(&dst, le32_to_cpu(pkt->hdr.dst_cid),\r\nle32_to_cpu(pkt->hdr.dst_port));\r\ntrace_virtio_transport_recv_pkt(src.svm_cid, src.svm_port,\r\ndst.svm_cid, dst.svm_port,\r\nle32_to_cpu(pkt->hdr.len),\r\nle16_to_cpu(pkt->hdr.type),\r\nle16_to_cpu(pkt->hdr.op),\r\nle32_to_cpu(pkt->hdr.flags),\r\nle32_to_cpu(pkt->hdr.buf_alloc),\r\nle32_to_cpu(pkt->hdr.fwd_cnt));\r\nif (le16_to_cpu(pkt->hdr.type) != VIRTIO_VSOCK_TYPE_STREAM) {\r\n(void)virtio_transport_reset_no_sock(pkt);\r\ngoto free_pkt;\r\n}\r\nsk = vsock_find_connected_socket(&src, &dst);\r\nif (!sk) {\r\nsk = vsock_find_bound_socket(&dst);\r\nif (!sk) {\r\n(void)virtio_transport_reset_no_sock(pkt);\r\ngoto free_pkt;\r\n}\r\n}\r\nvsk = vsock_sk(sk);\r\nspace_available = virtio_transport_space_update(sk, pkt);\r\nlock_sock(sk);\r\nvsk->local_addr.svm_cid = dst.svm_cid;\r\nif (space_available)\r\nsk->sk_write_space(sk);\r\nswitch (sk->sk_state) {\r\ncase VSOCK_SS_LISTEN:\r\nvirtio_transport_recv_listen(sk, pkt);\r\nvirtio_transport_free_pkt(pkt);\r\nbreak;\r\ncase SS_CONNECTING:\r\nvirtio_transport_recv_connecting(sk, pkt);\r\nvirtio_transport_free_pkt(pkt);\r\nbreak;\r\ncase SS_CONNECTED:\r\nvirtio_transport_recv_connected(sk, pkt);\r\nbreak;\r\ncase SS_DISCONNECTING:\r\nvirtio_transport_recv_disconnecting(sk, pkt);\r\nvirtio_transport_free_pkt(pkt);\r\nbreak;\r\ndefault:\r\nvirtio_transport_free_pkt(pkt);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn;\r\nfree_pkt:\r\nvirtio_transport_free_pkt(pkt);\r\n}\r\nvoid virtio_transport_free_pkt(struct virtio_vsock_pkt *pkt)\r\n{\r\nkfree(pkt->buf);\r\nkfree(pkt);\r\n}
