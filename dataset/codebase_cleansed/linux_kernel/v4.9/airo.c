static inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,\r\nint whichbap)\r\n{\r\nreturn ai->bap_read(ai, pu16Dst, bytelen, whichbap);\r\n}\r\nstatic void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len,\r\nstruct crypto_cipher *tfm)\r\n{\r\nif (cur->valid && (memcmp(cur->key, key, key_len) == 0))\r\nreturn;\r\nmemcpy(old, cur, sizeof(*cur));\r\nmemcpy(cur->key, key, key_len);\r\ncur->window = 33;\r\ncur->rx = 0;\r\ncur->tx = 0;\r\ncur->valid = 1;\r\nemmh32_setseed(&cur->seed, key, key_len, tfm);\r\n}\r\nstatic void micinit(struct airo_info *ai)\r\n{\r\nMICRid mic_rid;\r\nclear_bit(JOB_MIC, &ai->jobs);\r\nPC4500_readrid(ai, RID_MIC, &mic_rid, sizeof(mic_rid), 0);\r\nup(&ai->sem);\r\nai->micstats.enabled = (le16_to_cpu(mic_rid.state) & 0x00FF) ? 1 : 0;\r\nif (!ai->micstats.enabled) {\r\nai->mod[0].uCtx.valid = 0;\r\nai->mod[0].mCtx.valid = 0;\r\nreturn;\r\n}\r\nif (mic_rid.multicastValid) {\r\nage_mic_context(&ai->mod[0].mCtx, &ai->mod[1].mCtx,\r\nmic_rid.multicast, sizeof(mic_rid.multicast),\r\nai->tfm);\r\n}\r\nif (mic_rid.unicastValid) {\r\nage_mic_context(&ai->mod[0].uCtx, &ai->mod[1].uCtx,\r\nmic_rid.unicast, sizeof(mic_rid.unicast),\r\nai->tfm);\r\n}\r\n}\r\nstatic int micsetup(struct airo_info *ai) {\r\nint i;\r\nif (ai->tfm == NULL)\r\nai->tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ai->tfm)) {\r\nairo_print_err(ai->dev->name, "failed to load transform for AES");\r\nai->tfm = NULL;\r\nreturn ERROR;\r\n}\r\nfor (i=0; i < NUM_MODULES; i++) {\r\nmemset(&ai->mod[i].mCtx,0,sizeof(miccntx));\r\nmemset(&ai->mod[i].uCtx,0,sizeof(miccntx));\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int encapsulate(struct airo_info *ai ,etherHead *frame, MICBuffer *mic, int payLen)\r\n{\r\nmiccntx *context;\r\nif (test_bit(FLAG_ADHOC, &ai->flags) && (frame->da[0] & 0x1))\r\ncontext = &ai->mod[0].mCtx;\r\nelse\r\ncontext = &ai->mod[0].uCtx;\r\nif (!context->valid)\r\nreturn ERROR;\r\nmic->typelen = htons(payLen + 16);\r\nmemcpy(&mic->u.snap, micsnap, sizeof(micsnap));\r\nmic->seq = htonl(context->tx);\r\ncontext->tx += 2;\r\nemmh32_init(&context->seed);\r\nemmh32_update(&context->seed,frame->da,ETH_ALEN * 2);\r\nemmh32_update(&context->seed,(u8*)&mic->typelen,10);\r\nemmh32_update(&context->seed,(u8*)&mic->seq,sizeof(mic->seq));\r\nemmh32_update(&context->seed,(u8*)(frame + 1),payLen);\r\nemmh32_final(&context->seed, (u8*)&mic->mic);\r\nmic->typelen = 0;\r\nreturn SUCCESS;\r\n}\r\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen)\r\n{\r\nint i;\r\nu32 micSEQ;\r\nmiccntx *context;\r\nu8 digest[4];\r\nmic_error micError = NONE;\r\nif (!ai->micstats.enabled) {\r\nif (memcmp ((u8*)eth + 14, micsnap, sizeof(micsnap)) == 0) {\r\nai->micstats.rxMICPlummed++;\r\nreturn ERROR;\r\n}\r\nreturn SUCCESS;\r\n}\r\nif (ntohs(mic->typelen) == 0x888E)\r\nreturn SUCCESS;\r\nif (memcmp (mic->u.snap, micsnap, sizeof(micsnap)) != 0) {\r\nai->micstats.rxMICPlummed++;\r\nreturn ERROR;\r\n}\r\nmicSEQ = ntohl(mic->seq);\r\nif ( (micSEQ & 1) == 0 ) {\r\nai->micstats.rxWrongSequence++;\r\nreturn ERROR;\r\n}\r\nfor (i = 0; i < NUM_MODULES; i++) {\r\nint mcast = eth->da[0] & 1;\r\ncontext = mcast ? &ai->mod[i].mCtx : &ai->mod[i].uCtx;\r\nif (!context->valid) {\r\nif (i == 0)\r\nmicError = NOMICPLUMMED;\r\ncontinue;\r\n}\r\nif (!mic->typelen)\r\nmic->typelen = htons(payLen + sizeof(MICBuffer) - 2);\r\nemmh32_init(&context->seed);\r\nemmh32_update(&context->seed, eth->da, ETH_ALEN*2);\r\nemmh32_update(&context->seed, (u8 *)&mic->typelen, sizeof(mic->typelen)+sizeof(mic->u.snap));\r\nemmh32_update(&context->seed, (u8 *)&mic->seq,sizeof(mic->seq));\r\nemmh32_update(&context->seed, (u8 *)(eth + 1),payLen);\r\nemmh32_final(&context->seed, digest);\r\nif (memcmp(digest, &mic->mic, 4)) {\r\nif (i == 0)\r\nmicError = INCORRECTMIC;\r\ncontinue;\r\n}\r\nif (RxSeqValid(ai, context, mcast, micSEQ) == SUCCESS) {\r\nai->micstats.rxSuccess++;\r\nreturn SUCCESS;\r\n}\r\nif (i == 0)\r\nmicError = SEQUENCE;\r\n}\r\nswitch (micError) {\r\ncase NOMICPLUMMED: ai->micstats.rxMICPlummed++; break;\r\ncase SEQUENCE: ai->micstats.rxWrongSequence++; break;\r\ncase INCORRECTMIC: ai->micstats.rxIncorrectMIC++; break;\r\ncase NONE: break;\r\ncase NOMIC: break;\r\n}\r\nreturn ERROR;\r\n}\r\nstatic int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq)\r\n{\r\nu32 seq,index;\r\nif (mcast) {\r\nif (test_bit(FLAG_UPDATE_MULTI, &ai->flags)) {\r\nclear_bit (FLAG_UPDATE_MULTI, &ai->flags);\r\ncontext->window = (micSeq > 33) ? micSeq : 33;\r\ncontext->rx = 0;\r\n}\r\n} else if (test_bit(FLAG_UPDATE_UNI, &ai->flags)) {\r\nclear_bit (FLAG_UPDATE_UNI, &ai->flags);\r\ncontext->window = (micSeq > 33) ? micSeq : 33;\r\ncontext->rx = 0;\r\n}\r\nseq = micSeq - (context->window - 33);\r\nif ((s32)seq < 0)\r\nreturn ERROR;\r\nif ( seq > 64 ) {\r\nMoveWindow(context,micSeq);\r\nreturn SUCCESS;\r\n}\r\nseq >>= 1;\r\nindex = 1 << seq;\r\nif (!(context->rx & index)) {\r\ncontext->rx |= index;\r\nMoveWindow(context,micSeq);\r\nreturn SUCCESS;\r\n}\r\nreturn ERROR;\r\n}\r\nstatic void MoveWindow(miccntx *context, u32 micSeq)\r\n{\r\nu32 shift;\r\nif (micSeq > context->window) {\r\nshift = (micSeq - context->window) >> 1;\r\nif (shift < 32)\r\ncontext->rx >>= shift;\r\nelse\r\ncontext->rx = 0;\r\ncontext->window = micSeq;\r\n}\r\n}\r\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\r\nstruct crypto_cipher *tfm)\r\n{\r\nint i,j;\r\nu32 counter;\r\nu8 *cipher, plain[16];\r\ncrypto_cipher_setkey(tfm, pkey, 16);\r\ncounter = 0;\r\nfor (i = 0; i < ARRAY_SIZE(context->coeff); ) {\r\naes_counter[15] = (u8)(counter >> 0);\r\naes_counter[14] = (u8)(counter >> 8);\r\naes_counter[13] = (u8)(counter >> 16);\r\naes_counter[12] = (u8)(counter >> 24);\r\ncounter++;\r\nmemcpy (plain, aes_counter, 16);\r\ncrypto_cipher_encrypt_one(tfm, plain, plain);\r\ncipher = plain;\r\nfor (j = 0; (j < 16) && (i < ARRAY_SIZE(context->coeff)); ) {\r\ncontext->coeff[i++] = ntohl(*(__be32 *)&cipher[j]);\r\nj += 4;\r\n}\r\n}\r\n}\r\nstatic void emmh32_init(emmh32_context *context)\r\n{\r\ncontext->accum = 0;\r\ncontext->position = 0;\r\n}\r\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len)\r\n{\r\nint coeff_position, byte_position;\r\nif (len == 0) return;\r\ncoeff_position = context->position >> 2;\r\nbyte_position = context->position & 3;\r\nif (byte_position) {\r\ndo {\r\nif (len == 0) return;\r\ncontext->part.d8[byte_position++] = *pOctets++;\r\ncontext->position++;\r\nlen--;\r\n} while (byte_position < 4);\r\nMIC_ACCUM(ntohl(context->part.d32));\r\n}\r\nwhile (len >= 4) {\r\nMIC_ACCUM(ntohl(*(__be32 *)pOctets));\r\ncontext->position += 4;\r\npOctets += 4;\r\nlen -= 4;\r\n}\r\nbyte_position = 0;\r\nwhile (len > 0) {\r\ncontext->part.d8[byte_position++] = *pOctets++;\r\ncontext->position++;\r\nlen--;\r\n}\r\n}\r\nstatic void emmh32_final(emmh32_context *context, u8 digest[4])\r\n{\r\nint coeff_position, byte_position;\r\nu32 val;\r\nu64 sum, utmp;\r\ns64 stmp;\r\ncoeff_position = context->position >> 2;\r\nbyte_position = context->position & 3;\r\nif (byte_position) {\r\nval = ntohl(context->part.d32);\r\nMIC_ACCUM(val & mask32[byte_position]);\r\n}\r\nsum = context->accum;\r\nstmp = (sum & 0xffffffffLL) - ((sum >> 32) * 15);\r\nutmp = (stmp & 0xffffffffLL) - ((stmp >> 32) * 15);\r\nsum = utmp & 0xffffffffLL;\r\nif (utmp > 0x10000000fLL)\r\nsum -= 15;\r\nval = (u32)sum;\r\ndigest[0] = (val>>24) & 0xFF;\r\ndigest[1] = (val>>16) & 0xFF;\r\ndigest[2] = (val>>8) & 0xFF;\r\ndigest[3] = val & 0xFF;\r\n}\r\nstatic int readBSSListRid(struct airo_info *ai, int first,\r\nBSSListRid *list)\r\n{\r\nCmd cmd;\r\nResp rsp;\r\nif (first == 1) {\r\nif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd=CMD_LISTBSS;\r\nif (down_interruptible(&ai->sem))\r\nreturn -ERESTARTSYS;\r\nai->list_bss_task = current;\r\nissuecommand(ai, &cmd, &rsp);\r\nup(&ai->sem);\r\nschedule_timeout_uninterruptible(3 * HZ);\r\nai->list_bss_task = NULL;\r\n}\r\nreturn PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,\r\nlist, ai->bssListRidLen, 1);\r\n}\r\nstatic int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)\r\n{\r\nreturn PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,\r\nwkr, sizeof(*wkr), lock);\r\n}\r\nstatic int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\r\n{\r\nint rc;\r\nrc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\r\nif (rc!=SUCCESS)\r\nairo_print_err(ai->dev->name, "WEP_TEMP set %x", rc);\r\nif (perm) {\r\nrc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\r\nif (rc!=SUCCESS)\r\nairo_print_err(ai->dev->name, "WEP_PERM set %x", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int readSsidRid(struct airo_info*ai, SsidRid *ssidr)\r\n{\r\nreturn PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);\r\n}\r\nstatic int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)\r\n{\r\nreturn PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);\r\n}\r\nstatic int readConfigRid(struct airo_info *ai, int lock)\r\n{\r\nint rc;\r\nConfigRid cfg;\r\nif (ai->config.len)\r\nreturn SUCCESS;\r\nrc = PC4500_readrid(ai, RID_ACTUALCONFIG, &cfg, sizeof(cfg), lock);\r\nif (rc != SUCCESS)\r\nreturn rc;\r\nai->config = cfg;\r\nreturn SUCCESS;\r\n}\r\nstatic inline void checkThrottle(struct airo_info *ai)\r\n{\r\nint i;\r\nif (ai->config.authType != AUTH_OPEN && maxencrypt) {\r\nfor(i=0; i<8; i++) {\r\nif (ai->config.rates[i] > maxencrypt) {\r\nai->config.rates[i] = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int writeConfigRid(struct airo_info *ai, int lock)\r\n{\r\nConfigRid cfgr;\r\nif (!test_bit (FLAG_COMMIT, &ai->flags))\r\nreturn SUCCESS;\r\nclear_bit (FLAG_COMMIT, &ai->flags);\r\nclear_bit (FLAG_RESET, &ai->flags);\r\ncheckThrottle(ai);\r\ncfgr = ai->config;\r\nif ((cfgr.opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\r\nset_bit(FLAG_ADHOC, &ai->flags);\r\nelse\r\nclear_bit(FLAG_ADHOC, &ai->flags);\r\nreturn PC4500_writerid( ai, RID_CONFIG, &cfgr, sizeof(cfgr), lock);\r\n}\r\nstatic int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)\r\n{\r\nreturn PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);\r\n}\r\nstatic int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)\r\n{\r\nreturn PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);\r\n}\r\nstatic int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)\r\n{\r\nreturn PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);\r\n}\r\nstatic int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)\r\n{\r\nreturn PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);\r\n}\r\nstatic void try_auto_wep(struct airo_info *ai)\r\n{\r\nif (auto_wep && !test_bit(FLAG_RADIO_DOWN, &ai->flags)) {\r\nai->expires = RUN_AT(3*HZ);\r\nwake_up_interruptible(&ai->thr_wait);\r\n}\r\n}\r\nstatic int airo_open(struct net_device *dev) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nint rc = 0;\r\nif (test_bit(FLAG_FLASHING, &ai->flags))\r\nreturn -EIO;\r\nif (test_bit(FLAG_COMMIT, &ai->flags)) {\r\ndisable_MAC(ai, 1);\r\nwriteConfigRid(ai, 1);\r\n}\r\nif (ai->wifidev != dev) {\r\nclear_bit(JOB_DIE, &ai->jobs);\r\nai->airo_thread_task = kthread_run(airo_thread, dev, "%s",\r\ndev->name);\r\nif (IS_ERR(ai->airo_thread_task))\r\nreturn (int)PTR_ERR(ai->airo_thread_task);\r\nrc = request_irq(dev->irq, airo_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (rc) {\r\nairo_print_err(dev->name,\r\n"register interrupt %d failed, rc %d",\r\ndev->irq, rc);\r\nset_bit(JOB_DIE, &ai->jobs);\r\nkthread_stop(ai->airo_thread_task);\r\nreturn rc;\r\n}\r\nclear_bit(FLAG_RADIO_DOWN, &ai->flags);\r\nenable_interrupts(ai);\r\ntry_auto_wep(ai);\r\n}\r\nenable_MAC(ai, 1);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t mpi_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint npacks, pending;\r\nunsigned long flags;\r\nstruct airo_info *ai = dev->ml_priv;\r\nif (!skb) {\r\nairo_print_err(dev->name, "%s: skb == NULL!",__func__);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnpacks = skb_queue_len (&ai->txq);\r\nif (npacks >= MAXTXQ - 1) {\r\nnetif_stop_queue (dev);\r\nif (npacks > MAXTXQ) {\r\ndev->stats.tx_fifo_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nskb_queue_tail (&ai->txq, skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&ai->aux_lock, flags);\r\nskb_queue_tail (&ai->txq, skb);\r\npending = test_bit(FLAG_PENDING_XMIT, &ai->flags);\r\nspin_unlock_irqrestore(&ai->aux_lock,flags);\r\nnetif_wake_queue (dev);\r\nif (pending == 0) {\r\nset_bit(FLAG_PENDING_XMIT, &ai->flags);\r\nmpi_send_packet (dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int mpi_send_packet (struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *buffer;\r\ns16 len;\r\n__le16 *payloadLen;\r\nstruct airo_info *ai = dev->ml_priv;\r\nu8 *sendbuf;\r\nif ((skb = skb_dequeue(&ai->txq)) == NULL) {\r\nairo_print_err(dev->name,\r\n"%s: Dequeue'd zero in send_packet()",\r\n__func__);\r\nreturn 0;\r\n}\r\nlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nbuffer = skb->data;\r\nai->txfids[0].tx_desc.offset = 0;\r\nai->txfids[0].tx_desc.valid = 1;\r\nai->txfids[0].tx_desc.eoc = 1;\r\nai->txfids[0].tx_desc.len =len+sizeof(WifiHdr);\r\nmemcpy(ai->txfids[0].virtual_host_addr,\r\n(char *)&wifictlhdr8023, sizeof(wifictlhdr8023));\r\npayloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr +\r\nsizeof(wifictlhdr8023));\r\nsendbuf = ai->txfids[0].virtual_host_addr +\r\nsizeof(wifictlhdr8023) + 2 ;\r\nif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\r\n(ntohs(((__be16 *)buffer)[6]) != 0x888E)) {\r\nMICBuffer pMic;\r\nif (encapsulate(ai, (etherHead *)buffer, &pMic, len - sizeof(etherHead)) != SUCCESS)\r\nreturn ERROR;\r\n*payloadLen = cpu_to_le16(len-sizeof(etherHead)+sizeof(pMic));\r\nai->txfids[0].tx_desc.len += sizeof(pMic);\r\nmemcpy (sendbuf, buffer, sizeof(etherHead));\r\nbuffer += sizeof(etherHead);\r\nsendbuf += sizeof(etherHead);\r\nmemcpy (sendbuf, &pMic, sizeof(pMic));\r\nsendbuf += sizeof(pMic);\r\nmemcpy (sendbuf, buffer, len - sizeof(etherHead));\r\n} else {\r\n*payloadLen = cpu_to_le16(len - sizeof(etherHead));\r\nnetif_trans_update(dev);\r\nmemcpy(sendbuf, buffer, len);\r\n}\r\nmemcpy_toio(ai->txfids[0].card_ram_off,\r\n&ai->txfids[0].tx_desc, sizeof(TxFid));\r\nOUT4500(ai, EVACK, 8);\r\ndev_kfree_skb_any(skb);\r\nreturn 1;\r\n}\r\nstatic void get_tx_error(struct airo_info *ai, s32 fid)\r\n{\r\n__le16 status;\r\nif (fid < 0)\r\nstatus = ((WifiCtlHdr *)ai->txfids[0].virtual_host_addr)->ctlhdr.status;\r\nelse {\r\nif (bap_setup(ai, ai->fids[fid] & 0xffff, 4, BAP0) != SUCCESS)\r\nreturn;\r\nbap_read(ai, &status, 2, BAP0);\r\n}\r\nif (le16_to_cpu(status) & 2)\r\nai->dev->stats.tx_aborted_errors++;\r\nif (le16_to_cpu(status) & 4)\r\nai->dev->stats.tx_heartbeat_errors++;\r\nif (le16_to_cpu(status) & 8)\r\n{ }\r\nif (le16_to_cpu(status) & 0x10)\r\nai->dev->stats.tx_carrier_errors++;\r\nif (le16_to_cpu(status) & 0x20)\r\n{ }\r\nif ((le16_to_cpu(status) & 2) ||\r\n(le16_to_cpu(status) & 4)) {\r\nunion iwreq_data wrqu;\r\nchar junk[0x18];\r\nbap_read(ai, (__le16 *) junk, 0x18, BAP0);\r\nmemcpy(wrqu.addr.sa_data, junk + 0x12, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(ai->dev, IWEVTXDROP, &wrqu, NULL);\r\n}\r\n}\r\nstatic void airo_end_xmit(struct net_device *dev) {\r\nu16 status;\r\nint i;\r\nstruct airo_info *priv = dev->ml_priv;\r\nstruct sk_buff *skb = priv->xmit.skb;\r\nint fid = priv->xmit.fid;\r\nu32 *fids = priv->fids;\r\nclear_bit(JOB_XMIT, &priv->jobs);\r\nclear_bit(FLAG_PENDING_XMIT, &priv->flags);\r\nstatus = transmit_802_3_packet (priv, fids[fid], skb->data);\r\nup(&priv->sem);\r\ni = 0;\r\nif ( status == SUCCESS ) {\r\nnetif_trans_update(dev);\r\nfor (; i < MAX_FIDS / 2 && (priv->fids[i] & 0xffff0000); i++);\r\n} else {\r\npriv->fids[fid] &= 0xffff;\r\ndev->stats.tx_window_errors++;\r\n}\r\nif (i < MAX_FIDS / 2)\r\nnetif_wake_queue(dev);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic netdev_tx_t airo_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\ns16 len;\r\nint i, j;\r\nstruct airo_info *priv = dev->ml_priv;\r\nu32 *fids = priv->fids;\r\nif ( skb == NULL ) {\r\nairo_print_err(dev->name, "%s: skb == NULL!", __func__);\r\nreturn NETDEV_TX_OK;\r\n}\r\nfor( i = 0; i < MAX_FIDS / 2 && (fids[i] & 0xffff0000); i++ );\r\nfor( j = i + 1; j < MAX_FIDS / 2 && (fids[j] & 0xffff0000); j++ );\r\nif ( j >= MAX_FIDS / 2 ) {\r\nnetif_stop_queue(dev);\r\nif (i == MAX_FIDS / 2) {\r\ndev->stats.tx_fifo_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nfids[i] |= (len << 16);\r\npriv->xmit.skb = skb;\r\npriv->xmit.fid = i;\r\nif (down_trylock(&priv->sem) != 0) {\r\nset_bit(FLAG_PENDING_XMIT, &priv->flags);\r\nnetif_stop_queue(dev);\r\nset_bit(JOB_XMIT, &priv->jobs);\r\nwake_up_interruptible(&priv->thr_wait);\r\n} else\r\nairo_end_xmit(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void airo_end_xmit11(struct net_device *dev) {\r\nu16 status;\r\nint i;\r\nstruct airo_info *priv = dev->ml_priv;\r\nstruct sk_buff *skb = priv->xmit11.skb;\r\nint fid = priv->xmit11.fid;\r\nu32 *fids = priv->fids;\r\nclear_bit(JOB_XMIT11, &priv->jobs);\r\nclear_bit(FLAG_PENDING_XMIT11, &priv->flags);\r\nstatus = transmit_802_11_packet (priv, fids[fid], skb->data);\r\nup(&priv->sem);\r\ni = MAX_FIDS / 2;\r\nif ( status == SUCCESS ) {\r\nnetif_trans_update(dev);\r\nfor (; i < MAX_FIDS && (priv->fids[i] & 0xffff0000); i++);\r\n} else {\r\npriv->fids[fid] &= 0xffff;\r\ndev->stats.tx_window_errors++;\r\n}\r\nif (i < MAX_FIDS)\r\nnetif_wake_queue(dev);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic netdev_tx_t airo_start_xmit11(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\ns16 len;\r\nint i, j;\r\nstruct airo_info *priv = dev->ml_priv;\r\nu32 *fids = priv->fids;\r\nif (test_bit(FLAG_MPI, &priv->flags)) {\r\nnetif_stop_queue(dev);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif ( skb == NULL ) {\r\nairo_print_err(dev->name, "%s: skb == NULL!", __func__);\r\nreturn NETDEV_TX_OK;\r\n}\r\nfor( i = MAX_FIDS / 2; i < MAX_FIDS && (fids[i] & 0xffff0000); i++ );\r\nfor( j = i + 1; j < MAX_FIDS && (fids[j] & 0xffff0000); j++ );\r\nif ( j >= MAX_FIDS ) {\r\nnetif_stop_queue(dev);\r\nif (i == MAX_FIDS) {\r\ndev->stats.tx_fifo_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nfids[i] |= (len << 16);\r\npriv->xmit11.skb = skb;\r\npriv->xmit11.fid = i;\r\nif (down_trylock(&priv->sem) != 0) {\r\nset_bit(FLAG_PENDING_XMIT11, &priv->flags);\r\nnetif_stop_queue(dev);\r\nset_bit(JOB_XMIT11, &priv->jobs);\r\nwake_up_interruptible(&priv->thr_wait);\r\n} else\r\nairo_end_xmit11(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void airo_read_stats(struct net_device *dev)\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nStatsRid stats_rid;\r\n__le32 *vals = stats_rid.vals;\r\nclear_bit(JOB_STATS, &ai->jobs);\r\nif (ai->power.event) {\r\nup(&ai->sem);\r\nreturn;\r\n}\r\nreadStatsRid(ai, &stats_rid, RID_STATS, 0);\r\nup(&ai->sem);\r\ndev->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +\r\nle32_to_cpu(vals[45]);\r\ndev->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +\r\nle32_to_cpu(vals[41]);\r\ndev->stats.rx_bytes = le32_to_cpu(vals[92]);\r\ndev->stats.tx_bytes = le32_to_cpu(vals[91]);\r\ndev->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +\r\nle32_to_cpu(vals[3]) + le32_to_cpu(vals[4]);\r\ndev->stats.tx_errors = le32_to_cpu(vals[42]) +\r\ndev->stats.tx_fifo_errors;\r\ndev->stats.multicast = le32_to_cpu(vals[43]);\r\ndev->stats.collisions = le32_to_cpu(vals[89]);\r\ndev->stats.rx_length_errors = le32_to_cpu(vals[3]);\r\ndev->stats.rx_crc_errors = le32_to_cpu(vals[4]);\r\ndev->stats.rx_frame_errors = le32_to_cpu(vals[2]);\r\ndev->stats.rx_fifo_errors = le32_to_cpu(vals[0]);\r\n}\r\nstatic struct net_device_stats *airo_get_stats(struct net_device *dev)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nif (!test_bit(JOB_STATS, &local->jobs)) {\r\nif (down_trylock(&local->sem) != 0) {\r\nset_bit(JOB_STATS, &local->jobs);\r\nwake_up_interruptible(&local->thr_wait);\r\n} else\r\nairo_read_stats(dev);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void airo_set_promisc(struct airo_info *ai) {\r\nCmd cmd;\r\nResp rsp;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd=CMD_SETMODE;\r\nclear_bit(JOB_PROMISC, &ai->jobs);\r\ncmd.parm0=(ai->flags&IFF_PROMISC) ? PROMISC : NOPROMISC;\r\nissuecommand(ai, &cmd, &rsp);\r\nup(&ai->sem);\r\n}\r\nstatic void airo_set_multicast_list(struct net_device *dev) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nif ((dev->flags ^ ai->flags) & IFF_PROMISC) {\r\nchange_bit(FLAG_PROMISC, &ai->flags);\r\nif (down_trylock(&ai->sem) != 0) {\r\nset_bit(JOB_PROMISC, &ai->jobs);\r\nwake_up_interruptible(&ai->thr_wait);\r\n} else\r\nairo_set_promisc(ai);\r\n}\r\nif ((dev->flags&IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\r\n}\r\n}\r\nstatic int airo_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nstruct sockaddr *addr = p;\r\nreadConfigRid(ai, 1);\r\nmemcpy (ai->config.macAddr, addr->sa_data, dev->addr_len);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\ndisable_MAC(ai, 1);\r\nwriteConfigRid (ai, 1);\r\nenable_MAC(ai, 1);\r\nmemcpy (ai->dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (ai->wifidev)\r\nmemcpy (ai->wifidev->dev_addr, addr->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int airo_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > 2400))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void add_airo_dev(struct airo_info *ai)\r\n{\r\nif (!ai->pci)\r\nlist_add_tail(&ai->dev_list, &airo_devices);\r\n}\r\nstatic void del_airo_dev(struct airo_info *ai)\r\n{\r\nif (!ai->pci)\r\nlist_del(&ai->dev_list);\r\n}\r\nstatic int airo_close(struct net_device *dev) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nnetif_stop_queue(dev);\r\nif (ai->wifidev != dev) {\r\n#ifdef POWER_ON_DOWN\r\nset_bit(FLAG_RADIO_DOWN, &ai->flags);\r\ndisable_MAC(ai, 1);\r\n#endif\r\ndisable_interrupts( ai );\r\nfree_irq(dev->irq, dev);\r\nset_bit(JOB_DIE, &ai->jobs);\r\nkthread_stop(ai->airo_thread_task);\r\n}\r\nreturn 0;\r\n}\r\nvoid stop_airo_card( struct net_device *dev, int freeres )\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nset_bit(FLAG_RADIO_DOWN, &ai->flags);\r\ndisable_MAC(ai, 1);\r\ndisable_interrupts(ai);\r\ntakedown_proc_entry( dev, ai );\r\nif (test_bit(FLAG_REGISTERED, &ai->flags)) {\r\nunregister_netdev( dev );\r\nif (ai->wifidev) {\r\nunregister_netdev(ai->wifidev);\r\nfree_netdev(ai->wifidev);\r\nai->wifidev = NULL;\r\n}\r\nclear_bit(FLAG_REGISTERED, &ai->flags);\r\n}\r\nif (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq)) {\r\nstruct sk_buff *skb = NULL;\r\nfor (;(skb = skb_dequeue(&ai->txq));)\r\ndev_kfree_skb(skb);\r\n}\r\nairo_networks_free (ai);\r\nkfree(ai->flash);\r\nkfree(ai->rssi);\r\nkfree(ai->SSID);\r\nif (freeres) {\r\nrelease_region( dev->base_addr, 64 );\r\nif (test_bit(FLAG_MPI, &ai->flags)) {\r\nif (ai->pci)\r\nmpi_unmap_card(ai->pci);\r\nif (ai->pcimem)\r\niounmap(ai->pcimem);\r\nif (ai->pciaux)\r\niounmap(ai->pciaux);\r\npci_free_consistent(ai->pci, PCI_SHARED_LEN,\r\nai->shared, ai->shared_dma);\r\n}\r\n}\r\ncrypto_free_cipher(ai->tfm);\r\ndel_airo_dev(ai);\r\nfree_netdev( dev );\r\n}\r\nstatic int wll_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nstatic void mpi_unmap_card(struct pci_dev *pci)\r\n{\r\nunsigned long mem_start = pci_resource_start(pci, 1);\r\nunsigned long mem_len = pci_resource_len(pci, 1);\r\nunsigned long aux_start = pci_resource_start(pci, 2);\r\nunsigned long aux_len = AUXMEMSIZE;\r\nrelease_mem_region(aux_start, aux_len);\r\nrelease_mem_region(mem_start, mem_len);\r\n}\r\nstatic int mpi_init_descriptors (struct airo_info *ai)\r\n{\r\nCmd cmd;\r\nResp rsp;\r\nint i;\r\nint rc = SUCCESS;\r\nnetif_stop_queue(ai->dev);\r\nmemset(&rsp,0,sizeof(rsp));\r\nmemset(&cmd,0,sizeof(cmd));\r\ncmd.cmd = CMD_ALLOCATEAUX;\r\ncmd.parm0 = FID_RX;\r\ncmd.parm1 = (ai->rxfids[0].card_ram_off - ai->pciaux);\r\ncmd.parm2 = MPI_MAX_FIDS;\r\nrc=issuecommand(ai, &cmd, &rsp);\r\nif (rc != SUCCESS) {\r\nairo_print_err(ai->dev->name, "Couldn't allocate RX FID");\r\nreturn rc;\r\n}\r\nfor (i=0; i<MPI_MAX_FIDS; i++) {\r\nmemcpy_toio(ai->rxfids[i].card_ram_off,\r\n&ai->rxfids[i].rx_desc, sizeof(RxFid));\r\n}\r\nmemset(&rsp,0,sizeof(rsp));\r\nmemset(&cmd,0,sizeof(cmd));\r\ncmd.cmd = CMD_ALLOCATEAUX;\r\ncmd.parm0 = FID_TX;\r\ncmd.parm1 = (ai->txfids[0].card_ram_off - ai->pciaux);\r\ncmd.parm2 = MPI_MAX_FIDS;\r\nfor (i=0; i<MPI_MAX_FIDS; i++) {\r\nai->txfids[i].tx_desc.valid = 1;\r\nmemcpy_toio(ai->txfids[i].card_ram_off,\r\n&ai->txfids[i].tx_desc, sizeof(TxFid));\r\n}\r\nai->txfids[i-1].tx_desc.eoc = 1;\r\nrc=issuecommand(ai, &cmd, &rsp);\r\nif (rc != SUCCESS) {\r\nairo_print_err(ai->dev->name, "Couldn't allocate TX FID");\r\nreturn rc;\r\n}\r\nmemset(&rsp,0,sizeof(rsp));\r\nmemset(&cmd,0,sizeof(cmd));\r\ncmd.cmd = CMD_ALLOCATEAUX;\r\ncmd.parm0 = RID_RW;\r\ncmd.parm1 = (ai->config_desc.card_ram_off - ai->pciaux);\r\ncmd.parm2 = 1;\r\nrc=issuecommand(ai, &cmd, &rsp);\r\nif (rc != SUCCESS) {\r\nairo_print_err(ai->dev->name, "Couldn't allocate RID");\r\nreturn rc;\r\n}\r\nmemcpy_toio(ai->config_desc.card_ram_off,\r\n&ai->config_desc.rid_desc, sizeof(Rid));\r\nreturn rc;\r\n}\r\nstatic int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)\r\n{\r\nunsigned long mem_start, mem_len, aux_start, aux_len;\r\nint rc = -1;\r\nint i;\r\ndma_addr_t busaddroff;\r\nunsigned char *vpackoff;\r\nunsigned char __iomem *pciaddroff;\r\nmem_start = pci_resource_start(pci, 1);\r\nmem_len = pci_resource_len(pci, 1);\r\naux_start = pci_resource_start(pci, 2);\r\naux_len = AUXMEMSIZE;\r\nif (!request_mem_region(mem_start, mem_len, DRV_NAME)) {\r\nairo_print_err("", "Couldn't get region %x[%x]",\r\n(int)mem_start, (int)mem_len);\r\ngoto out;\r\n}\r\nif (!request_mem_region(aux_start, aux_len, DRV_NAME)) {\r\nairo_print_err("", "Couldn't get region %x[%x]",\r\n(int)aux_start, (int)aux_len);\r\ngoto free_region1;\r\n}\r\nai->pcimem = ioremap(mem_start, mem_len);\r\nif (!ai->pcimem) {\r\nairo_print_err("", "Couldn't map region %x[%x]",\r\n(int)mem_start, (int)mem_len);\r\ngoto free_region2;\r\n}\r\nai->pciaux = ioremap(aux_start, aux_len);\r\nif (!ai->pciaux) {\r\nairo_print_err("", "Couldn't map region %x[%x]",\r\n(int)aux_start, (int)aux_len);\r\ngoto free_memmap;\r\n}\r\nai->shared = pci_alloc_consistent(pci, PCI_SHARED_LEN, &ai->shared_dma);\r\nif (!ai->shared) {\r\nairo_print_err("", "Couldn't alloc_consistent %d",\r\nPCI_SHARED_LEN);\r\ngoto free_auxmap;\r\n}\r\nbusaddroff = ai->shared_dma;\r\npciaddroff = ai->pciaux + AUX_OFFSET;\r\nvpackoff = ai->shared;\r\nfor(i = 0; i < MPI_MAX_FIDS; i++) {\r\nai->rxfids[i].pending = 0;\r\nai->rxfids[i].card_ram_off = pciaddroff;\r\nai->rxfids[i].virtual_host_addr = vpackoff;\r\nai->rxfids[i].rx_desc.host_addr = busaddroff;\r\nai->rxfids[i].rx_desc.valid = 1;\r\nai->rxfids[i].rx_desc.len = PKTSIZE;\r\nai->rxfids[i].rx_desc.rdy = 0;\r\npciaddroff += sizeof(RxFid);\r\nbusaddroff += PKTSIZE;\r\nvpackoff += PKTSIZE;\r\n}\r\nfor(i = 0; i < MPI_MAX_FIDS; i++) {\r\nai->txfids[i].card_ram_off = pciaddroff;\r\nai->txfids[i].virtual_host_addr = vpackoff;\r\nai->txfids[i].tx_desc.valid = 1;\r\nai->txfids[i].tx_desc.host_addr = busaddroff;\r\nmemcpy(ai->txfids[i].virtual_host_addr,\r\n&wifictlhdr8023, sizeof(wifictlhdr8023));\r\npciaddroff += sizeof(TxFid);\r\nbusaddroff += PKTSIZE;\r\nvpackoff += PKTSIZE;\r\n}\r\nai->txfids[i-1].tx_desc.eoc = 1;\r\nai->config_desc.card_ram_off = pciaddroff;\r\nai->config_desc.virtual_host_addr = vpackoff;\r\nai->config_desc.rid_desc.host_addr = busaddroff;\r\nai->ridbus = busaddroff;\r\nai->config_desc.rid_desc.rid = 0;\r\nai->config_desc.rid_desc.len = RIDSIZE;\r\nai->config_desc.rid_desc.valid = 1;\r\npciaddroff += sizeof(Rid);\r\nbusaddroff += RIDSIZE;\r\nvpackoff += RIDSIZE;\r\nif (mpi_init_descriptors (ai) != SUCCESS)\r\ngoto free_shared;\r\nreturn 0;\r\nfree_shared:\r\npci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\r\nfree_auxmap:\r\niounmap(ai->pciaux);\r\nfree_memmap:\r\niounmap(ai->pcimem);\r\nfree_region2:\r\nrelease_mem_region(aux_start, aux_len);\r\nfree_region1:\r\nrelease_mem_region(mem_start, mem_len);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void wifi_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &airo11_netdev_ops;\r\ndev->header_ops = &airo_header_ops;\r\ndev->wireless_handlers = &airo_handler_def;\r\ndev->type = ARPHRD_IEEE80211;\r\ndev->hard_header_len = ETH_HLEN;\r\ndev->mtu = AIRO_DEF_MTU;\r\ndev->addr_len = ETH_ALEN;\r\ndev->tx_queue_len = 100;\r\neth_broadcast_addr(dev->broadcast);\r\ndev->flags = IFF_BROADCAST|IFF_MULTICAST;\r\n}\r\nstatic struct net_device *init_wifidev(struct airo_info *ai,\r\nstruct net_device *ethdev)\r\n{\r\nint err;\r\nstruct net_device *dev = alloc_netdev(0, "wifi%d", NET_NAME_UNKNOWN,\r\nwifi_setup);\r\nif (!dev)\r\nreturn NULL;\r\ndev->ml_priv = ethdev->ml_priv;\r\ndev->irq = ethdev->irq;\r\ndev->base_addr = ethdev->base_addr;\r\ndev->wireless_data = ethdev->wireless_data;\r\nSET_NETDEV_DEV(dev, ethdev->dev.parent);\r\neth_hw_addr_inherit(dev, ethdev);\r\nerr = register_netdev(dev);\r\nif (err<0) {\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic int reset_card( struct net_device *dev , int lock) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nif (lock && down_interruptible(&ai->sem))\r\nreturn -1;\r\nwaitbusy (ai);\r\nOUT4500(ai,COMMAND,CMD_SOFTRESET);\r\nmsleep(200);\r\nwaitbusy (ai);\r\nmsleep(200);\r\nif (lock)\r\nup(&ai->sem);\r\nreturn 0;\r\n}\r\nstatic int airo_networks_allocate(struct airo_info *ai)\r\n{\r\nif (ai->networks)\r\nreturn 0;\r\nai->networks = kcalloc(AIRO_MAX_NETWORK_COUNT, sizeof(BSSListElement),\r\nGFP_KERNEL);\r\nif (!ai->networks) {\r\nairo_print_warn("", "Out of memory allocating beacons");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void airo_networks_free(struct airo_info *ai)\r\n{\r\nkfree(ai->networks);\r\nai->networks = NULL;\r\n}\r\nstatic void airo_networks_initialize(struct airo_info *ai)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&ai->network_free_list);\r\nINIT_LIST_HEAD(&ai->network_list);\r\nfor (i = 0; i < AIRO_MAX_NETWORK_COUNT; i++)\r\nlist_add_tail(&ai->networks[i].list,\r\n&ai->network_free_list);\r\n}\r\nstatic struct net_device *_init_airo_card( unsigned short irq, int port,\r\nint is_pcmcia, struct pci_dev *pci,\r\nstruct device *dmdev )\r\n{\r\nstruct net_device *dev;\r\nstruct airo_info *ai;\r\nint i, rc;\r\nCapabilityRid cap_rid;\r\ndev = alloc_netdev(sizeof(*ai), "", NET_NAME_UNKNOWN, ether_setup);\r\nif (!dev) {\r\nairo_print_err("", "Couldn't alloc_etherdev");\r\nreturn NULL;\r\n}\r\nai = dev->ml_priv = netdev_priv(dev);\r\nai->wifidev = NULL;\r\nai->flags = 1 << FLAG_RADIO_DOWN;\r\nai->jobs = 0;\r\nai->dev = dev;\r\nif (pci && (pci->device == 0x5000 || pci->device == 0xa504)) {\r\nairo_print_dbg("", "Found an MPI350 card");\r\nset_bit(FLAG_MPI, &ai->flags);\r\n}\r\nspin_lock_init(&ai->aux_lock);\r\nsema_init(&ai->sem, 1);\r\nai->config.len = 0;\r\nai->pci = pci;\r\ninit_waitqueue_head (&ai->thr_wait);\r\nai->tfm = NULL;\r\nadd_airo_dev(ai);\r\nai->APList.len = cpu_to_le16(sizeof(struct APListRid));\r\nif (airo_networks_allocate (ai))\r\ngoto err_out_free;\r\nairo_networks_initialize (ai);\r\nskb_queue_head_init (&ai->txq);\r\nif (test_bit(FLAG_MPI,&ai->flags))\r\ndev->netdev_ops = &mpi_netdev_ops;\r\nelse\r\ndev->netdev_ops = &airo_netdev_ops;\r\ndev->wireless_handlers = &airo_handler_def;\r\nai->wireless_data.spy_data = &ai->spy_data;\r\ndev->wireless_data = &ai->wireless_data;\r\ndev->irq = irq;\r\ndev->base_addr = port;\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\nSET_NETDEV_DEV(dev, dmdev);\r\nreset_card (dev, 1);\r\nmsleep(400);\r\nif (!is_pcmcia) {\r\nif (!request_region(dev->base_addr, 64, DRV_NAME)) {\r\nrc = -EBUSY;\r\nairo_print_err(dev->name, "Couldn't request region");\r\ngoto err_out_nets;\r\n}\r\n}\r\nif (test_bit(FLAG_MPI,&ai->flags)) {\r\nif (mpi_map_card(ai, pci)) {\r\nairo_print_err("", "Could not map memory");\r\ngoto err_out_res;\r\n}\r\n}\r\nif (probe) {\r\nif (setup_card(ai, dev->dev_addr, 1) != SUCCESS) {\r\nairo_print_err(dev->name, "MAC could not be enabled" );\r\nrc = -EIO;\r\ngoto err_out_map;\r\n}\r\n} else if (!test_bit(FLAG_MPI,&ai->flags)) {\r\nai->bap_read = fast_bap_read;\r\nset_bit(FLAG_FLASHING, &ai->flags);\r\n}\r\nstrcpy(dev->name, "eth%d");\r\nrc = register_netdev(dev);\r\nif (rc) {\r\nairo_print_err(dev->name, "Couldn't register_netdev");\r\ngoto err_out_map;\r\n}\r\nai->wifidev = init_wifidev(ai, dev);\r\nif (!ai->wifidev)\r\ngoto err_out_reg;\r\nrc = readCapabilityRid(ai, &cap_rid, 1);\r\nif (rc != SUCCESS) {\r\nrc = -EIO;\r\ngoto err_out_wifi;\r\n}\r\nai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;\r\nai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;\r\nairo_print_info(dev->name, "Firmware version %x.%x.%02d",\r\n((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),\r\n(le16_to_cpu(cap_rid.softVer) & 0xFF),\r\nle16_to_cpu(cap_rid.softSubVer));\r\nif (le16_to_cpu(cap_rid.softVer) > 0x530\r\n|| (le16_to_cpu(cap_rid.softVer) == 0x530\r\n&& le16_to_cpu(cap_rid.softSubVer) >= 17)) {\r\nairo_print_info(ai->dev->name, "WPA supported.");\r\nset_bit(FLAG_WPA_CAPABLE, &ai->flags);\r\nai->bssListFirst = RID_WPA_BSSLISTFIRST;\r\nai->bssListNext = RID_WPA_BSSLISTNEXT;\r\nai->bssListRidLen = sizeof(BSSListRid);\r\n} else {\r\nairo_print_info(ai->dev->name, "WPA unsupported with firmware "\r\n"versions older than 5.30.17.");\r\nai->bssListFirst = RID_BSSLISTFIRST;\r\nai->bssListNext = RID_BSSLISTNEXT;\r\nai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);\r\n}\r\nset_bit(FLAG_REGISTERED,&ai->flags);\r\nairo_print_info(dev->name, "MAC enabled %pM", dev->dev_addr);\r\nif (probe && !test_bit(FLAG_MPI,&ai->flags))\r\nfor( i = 0; i < MAX_FIDS; i++ )\r\nai->fids[i] = transmit_allocate(ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\r\nif (setup_proc_entry(dev, dev->ml_priv) < 0)\r\ngoto err_out_wifi;\r\nreturn dev;\r\nerr_out_wifi:\r\nunregister_netdev(ai->wifidev);\r\nfree_netdev(ai->wifidev);\r\nerr_out_reg:\r\nunregister_netdev(dev);\r\nerr_out_map:\r\nif (test_bit(FLAG_MPI,&ai->flags) && pci) {\r\npci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\r\niounmap(ai->pciaux);\r\niounmap(ai->pcimem);\r\nmpi_unmap_card(ai->pci);\r\n}\r\nerr_out_res:\r\nif (!is_pcmcia)\r\nrelease_region( dev->base_addr, 64 );\r\nerr_out_nets:\r\nairo_networks_free(ai);\r\nerr_out_free:\r\ndel_airo_dev(ai);\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nstruct net_device *init_airo_card( unsigned short irq, int port, int is_pcmcia,\r\nstruct device *dmdev)\r\n{\r\nreturn _init_airo_card ( irq, port, is_pcmcia, NULL, dmdev);\r\n}\r\nstatic int waitbusy (struct airo_info *ai) {\r\nint delay = 0;\r\nwhile ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {\r\nudelay (10);\r\nif ((++delay % 20) == 0)\r\nOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\r\n}\r\nreturn delay < 10000;\r\n}\r\nint reset_airo_card( struct net_device *dev )\r\n{\r\nint i;\r\nstruct airo_info *ai = dev->ml_priv;\r\nif (reset_card (dev, 1))\r\nreturn -1;\r\nif ( setup_card(ai, dev->dev_addr, 1 ) != SUCCESS ) {\r\nairo_print_err(dev->name, "MAC could not be enabled");\r\nreturn -1;\r\n}\r\nairo_print_info(dev->name, "MAC enabled %pM", dev->dev_addr);\r\nif (!test_bit(FLAG_MPI,&ai->flags))\r\nfor( i = 0; i < MAX_FIDS; i++ )\r\nai->fids[i] = transmit_allocate (ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\r\nenable_interrupts( ai );\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void airo_send_event(struct net_device *dev) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nunion iwreq_data wrqu;\r\nStatusRid status_rid;\r\nclear_bit(JOB_EVENT, &ai->jobs);\r\nPC4500_readrid(ai, RID_STATUS, &status_rid, sizeof(status_rid), 0);\r\nup(&ai->sem);\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nmemcpy(wrqu.ap_addr.sa_data, status_rid.bssid[0], ETH_ALEN);\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nstatic void airo_process_scan_results (struct airo_info *ai) {\r\nunion iwreq_data wrqu;\r\nBSSListRid bss;\r\nint rc;\r\nBSSListElement * loop_net;\r\nBSSListElement * tmp_net;\r\nlist_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {\r\nlist_move_tail (&loop_net->list, &ai->network_free_list);\r\nmemset (loop_net, 0, sizeof (loop_net->bss));\r\n}\r\nrc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);\r\nif((rc) || (bss.index == cpu_to_le16(0xffff))) {\r\ngoto out;\r\n}\r\ntmp_net = NULL;\r\nwhile((!rc) && (bss.index != cpu_to_le16(0xffff))) {\r\nif (!list_empty(&ai->network_free_list)) {\r\ntmp_net = list_entry(ai->network_free_list.next,\r\nBSSListElement, list);\r\nlist_del(ai->network_free_list.next);\r\n}\r\nif (tmp_net != NULL) {\r\nmemcpy(tmp_net, &bss, sizeof(tmp_net->bss));\r\nlist_add_tail(&tmp_net->list, &ai->network_list);\r\ntmp_net = NULL;\r\n}\r\nrc = PC4500_readrid(ai, ai->bssListNext,\r\n&bss, ai->bssListRidLen, 0);\r\n}\r\nout:\r\ndisable_MAC(ai, 2);\r\nwriteAPListRid(ai, &ai->APList, 0);\r\nenable_MAC(ai, 0);\r\nai->scan_timeout = 0;\r\nclear_bit(JOB_SCAN_RESULTS, &ai->jobs);\r\nup(&ai->sem);\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(ai->dev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\nstatic int airo_thread(void *data) {\r\nstruct net_device *dev = data;\r\nstruct airo_info *ai = dev->ml_priv;\r\nint locked;\r\nset_freezable();\r\nwhile(1) {\r\ntry_to_freeze();\r\nif (test_bit(JOB_DIE, &ai->jobs))\r\nbreak;\r\nif (ai->jobs) {\r\nlocked = down_interruptible(&ai->sem);\r\n} else {\r\nwait_queue_t wait;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&ai->thr_wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (ai->jobs)\r\nbreak;\r\nif (ai->expires || ai->scan_timeout) {\r\nif (ai->scan_timeout &&\r\ntime_after_eq(jiffies,ai->scan_timeout)){\r\nset_bit(JOB_SCAN_RESULTS, &ai->jobs);\r\nbreak;\r\n} else if (ai->expires &&\r\ntime_after_eq(jiffies,ai->expires)){\r\nset_bit(JOB_AUTOWEP, &ai->jobs);\r\nbreak;\r\n}\r\nif (!kthread_should_stop() &&\r\n!freezing(current)) {\r\nunsigned long wake_at;\r\nif (!ai->expires || !ai->scan_timeout) {\r\nwake_at = max(ai->expires,\r\nai->scan_timeout);\r\n} else {\r\nwake_at = min(ai->expires,\r\nai->scan_timeout);\r\n}\r\nschedule_timeout(wake_at - jiffies);\r\ncontinue;\r\n}\r\n} else if (!kthread_should_stop() &&\r\n!freezing(current)) {\r\nschedule();\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&ai->thr_wait, &wait);\r\nlocked = 1;\r\n}\r\nif (locked)\r\ncontinue;\r\nif (test_bit(JOB_DIE, &ai->jobs)) {\r\nup(&ai->sem);\r\nbreak;\r\n}\r\nif (ai->power.event || test_bit(FLAG_FLASHING, &ai->flags)) {\r\nup(&ai->sem);\r\ncontinue;\r\n}\r\nif (test_bit(JOB_XMIT, &ai->jobs))\r\nairo_end_xmit(dev);\r\nelse if (test_bit(JOB_XMIT11, &ai->jobs))\r\nairo_end_xmit11(dev);\r\nelse if (test_bit(JOB_STATS, &ai->jobs))\r\nairo_read_stats(dev);\r\nelse if (test_bit(JOB_WSTATS, &ai->jobs))\r\nairo_read_wireless_stats(ai);\r\nelse if (test_bit(JOB_PROMISC, &ai->jobs))\r\nairo_set_promisc(ai);\r\nelse if (test_bit(JOB_MIC, &ai->jobs))\r\nmicinit(ai);\r\nelse if (test_bit(JOB_EVENT, &ai->jobs))\r\nairo_send_event(dev);\r\nelse if (test_bit(JOB_AUTOWEP, &ai->jobs))\r\ntimer_func(dev);\r\nelse if (test_bit(JOB_SCAN_RESULTS, &ai->jobs))\r\nairo_process_scan_results(ai);\r\nelse\r\nup(&ai->sem);\r\n}\r\nreturn 0;\r\n}\r\nstatic int header_len(__le16 ctl)\r\n{\r\nu16 fc = le16_to_cpu(ctl);\r\nswitch (fc & 0xc) {\r\ncase 4:\r\nif ((fc & 0xe0) == 0xc0)\r\nreturn 10;\r\nreturn 16;\r\ncase 8:\r\nif ((fc & 0x300) == 0x300)\r\nreturn 30;\r\n}\r\nreturn 24;\r\n}\r\nstatic void airo_handle_cisco_mic(struct airo_info *ai)\r\n{\r\nif (test_bit(FLAG_MIC_CAPABLE, &ai->flags)) {\r\nset_bit(JOB_MIC, &ai->jobs);\r\nwake_up_interruptible(&ai->thr_wait);\r\n}\r\n}\r\nstatic void airo_print_status(const char *devname, u16 status)\r\n{\r\nu8 reason = status & 0xFF;\r\nswitch (status & 0xFF00) {\r\ncase STAT_NOBEACON:\r\nswitch (status) {\r\ncase STAT_NOBEACON:\r\nairo_print_dbg(devname, "link lost (missed beacons)");\r\nbreak;\r\ncase STAT_MAXRETRIES:\r\ncase STAT_MAXARL:\r\nairo_print_dbg(devname, "link lost (max retries)");\r\nbreak;\r\ncase STAT_FORCELOSS:\r\nairo_print_dbg(devname, "link lost (local choice)");\r\nbreak;\r\ncase STAT_TSFSYNC:\r\nairo_print_dbg(devname, "link lost (TSF sync lost)");\r\nbreak;\r\ndefault:\r\nairo_print_dbg(devname, "unknown status %x\n", status);\r\nbreak;\r\n}\r\nbreak;\r\ncase STAT_DEAUTH:\r\nairo_print_dbg(devname, "deauthenticated (reason: %d)", reason);\r\nbreak;\r\ncase STAT_DISASSOC:\r\nairo_print_dbg(devname, "disassociated (reason: %d)", reason);\r\nbreak;\r\ncase STAT_ASSOC_FAIL:\r\nairo_print_dbg(devname, "association failed (reason: %d)",\r\nreason);\r\nbreak;\r\ncase STAT_AUTH_FAIL:\r\nairo_print_dbg(devname, "authentication failed (reason: %d)",\r\nreason);\r\nbreak;\r\ncase STAT_ASSOC:\r\ncase STAT_REASSOC:\r\nbreak;\r\ndefault:\r\nairo_print_dbg(devname, "unknown status %x\n", status);\r\nbreak;\r\n}\r\n}\r\nstatic void airo_handle_link(struct airo_info *ai)\r\n{\r\nunion iwreq_data wrqu;\r\nint scan_forceloss = 0;\r\nu16 status;\r\nstatus = le16_to_cpu(IN4500(ai, LINKSTAT));\r\nOUT4500(ai, EVACK, EV_LINK);\r\nif ((status == STAT_FORCELOSS) && (ai->scan_timeout > 0))\r\nscan_forceloss = 1;\r\nairo_print_status(ai->dev->name, status);\r\nif ((status == STAT_ASSOC) || (status == STAT_REASSOC)) {\r\nif (auto_wep)\r\nai->expires = 0;\r\nif (ai->list_bss_task)\r\nwake_up_process(ai->list_bss_task);\r\nset_bit(FLAG_UPDATE_UNI, &ai->flags);\r\nset_bit(FLAG_UPDATE_MULTI, &ai->flags);\r\nif (down_trylock(&ai->sem) != 0) {\r\nset_bit(JOB_EVENT, &ai->jobs);\r\nwake_up_interruptible(&ai->thr_wait);\r\n} else\r\nairo_send_event(ai->dev);\r\nnetif_carrier_on(ai->dev);\r\n} else if (!scan_forceloss) {\r\nif (auto_wep && !ai->expires) {\r\nai->expires = RUN_AT(3*HZ);\r\nwake_up_interruptible(&ai->thr_wait);\r\n}\r\neth_zero_addr(wrqu.ap_addr.sa_data);\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(ai->dev, SIOCGIWAP, &wrqu, NULL);\r\nnetif_carrier_off(ai->dev);\r\n} else {\r\nnetif_carrier_off(ai->dev);\r\n}\r\n}\r\nstatic void airo_handle_rx(struct airo_info *ai)\r\n{\r\nstruct sk_buff *skb = NULL;\r\n__le16 fc, v, *buffer, tmpbuf[4];\r\nu16 len, hdrlen = 0, gap, fid;\r\nstruct rx_hdr hdr;\r\nint success = 0;\r\nif (test_bit(FLAG_MPI, &ai->flags)) {\r\nif (test_bit(FLAG_802_11, &ai->flags))\r\nmpi_receive_802_11(ai);\r\nelse\r\nmpi_receive_802_3(ai);\r\nOUT4500(ai, EVACK, EV_RX);\r\nreturn;\r\n}\r\nfid = IN4500(ai, RXFID);\r\nif (test_bit(FLAG_802_11, &ai->flags)) {\r\nbap_setup (ai, fid, 4, BAP0);\r\nbap_read (ai, (__le16*)&hdr, sizeof(hdr), BAP0);\r\nif (le16_to_cpu(hdr.status) & 2)\r\nhdr.len = 0;\r\nif (ai->wifidev == NULL)\r\nhdr.len = 0;\r\n} else {\r\nbap_setup(ai, fid, 0x36, BAP0);\r\nbap_read(ai, &hdr.len, 2, BAP0);\r\n}\r\nlen = le16_to_cpu(hdr.len);\r\nif (len > AIRO_DEF_MTU) {\r\nairo_print_err(ai->dev->name, "Bad size %d", len);\r\ngoto done;\r\n}\r\nif (len == 0)\r\ngoto done;\r\nif (test_bit(FLAG_802_11, &ai->flags)) {\r\nbap_read(ai, &fc, sizeof (fc), BAP0);\r\nhdrlen = header_len(fc);\r\n} else\r\nhdrlen = ETH_ALEN * 2;\r\nskb = dev_alloc_skb(len + hdrlen + 2 + 2);\r\nif (!skb) {\r\nai->dev->stats.rx_dropped++;\r\ngoto done;\r\n}\r\nskb_reserve(skb, 2);\r\nbuffer = (__le16 *) skb_put(skb, len + hdrlen);\r\nif (test_bit(FLAG_802_11, &ai->flags)) {\r\nbuffer[0] = fc;\r\nbap_read(ai, buffer + 1, hdrlen - 2, BAP0);\r\nif (hdrlen == 24)\r\nbap_read(ai, tmpbuf, 6, BAP0);\r\nbap_read(ai, &v, sizeof(v), BAP0);\r\ngap = le16_to_cpu(v);\r\nif (gap) {\r\nif (gap <= 8) {\r\nbap_read(ai, tmpbuf, gap, BAP0);\r\n} else {\r\nairo_print_err(ai->dev->name, "gaplen too "\r\n"big. Problems will follow...");\r\n}\r\n}\r\nbap_read(ai, buffer + hdrlen/2, len, BAP0);\r\n} else {\r\nMICBuffer micbuf;\r\nbap_read(ai, buffer, ETH_ALEN * 2, BAP0);\r\nif (ai->micstats.enabled) {\r\nbap_read(ai, (__le16 *) &micbuf, sizeof (micbuf), BAP0);\r\nif (ntohs(micbuf.typelen) > 0x05DC)\r\nbap_setup(ai, fid, 0x44, BAP0);\r\nelse {\r\nif (len <= sizeof (micbuf)) {\r\ndev_kfree_skb_irq(skb);\r\ngoto done;\r\n}\r\nlen -= sizeof(micbuf);\r\nskb_trim(skb, len + hdrlen);\r\n}\r\n}\r\nbap_read(ai, buffer + ETH_ALEN, len, BAP0);\r\nif (decapsulate(ai, &micbuf, (etherHead*) buffer, len))\r\ndev_kfree_skb_irq (skb);\r\nelse\r\nsuccess = 1;\r\n}\r\n#ifdef WIRELESS_SPY\r\nif (success && (ai->spy_data.spy_number > 0)) {\r\nchar *sa;\r\nstruct iw_quality wstats;\r\nif (!test_bit(FLAG_802_11, &ai->flags)) {\r\nsa = (char *) buffer + 6;\r\nbap_setup(ai, fid, 8, BAP0);\r\nbap_read(ai, (__le16 *) hdr.rssi, 2, BAP0);\r\n} else\r\nsa = (char *) buffer + 10;\r\nwstats.qual = hdr.rssi[0];\r\nif (ai->rssi)\r\nwstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\r\nelse\r\nwstats.level = (hdr.rssi[1] + 321) / 2;\r\nwstats.noise = ai->wstats.qual.noise;\r\nwstats.updated = IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_QUAL_UPDATED\r\n| IW_QUAL_DBM;\r\nwireless_spy_update(ai->dev, sa, &wstats);\r\n}\r\n#endif\r\ndone:\r\nOUT4500(ai, EVACK, EV_RX);\r\nif (success) {\r\nif (test_bit(FLAG_802_11, &ai->flags)) {\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->dev = ai->wifidev;\r\nskb->protocol = htons(ETH_P_802_2);\r\n} else\r\nskb->protocol = eth_type_trans(skb, ai->dev);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void airo_handle_tx(struct airo_info *ai, u16 status)\r\n{\r\nint i, len = 0, index = -1;\r\nu16 fid;\r\nif (test_bit(FLAG_MPI, &ai->flags)) {\r\nunsigned long flags;\r\nif (status & EV_TXEXC)\r\nget_tx_error(ai, -1);\r\nspin_lock_irqsave(&ai->aux_lock, flags);\r\nif (!skb_queue_empty(&ai->txq)) {\r\nspin_unlock_irqrestore(&ai->aux_lock,flags);\r\nmpi_send_packet(ai->dev);\r\n} else {\r\nclear_bit(FLAG_PENDING_XMIT, &ai->flags);\r\nspin_unlock_irqrestore(&ai->aux_lock,flags);\r\nnetif_wake_queue(ai->dev);\r\n}\r\nOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\r\nreturn;\r\n}\r\nfid = IN4500(ai, TXCOMPLFID);\r\nfor(i = 0; i < MAX_FIDS; i++) {\r\nif ((ai->fids[i] & 0xffff) == fid) {\r\nlen = ai->fids[i] >> 16;\r\nindex = i;\r\n}\r\n}\r\nif (index != -1) {\r\nif (status & EV_TXEXC)\r\nget_tx_error(ai, index);\r\nOUT4500(ai, EVACK, status & (EV_TX | EV_TXEXC));\r\nai->fids[index] &= 0xffff;\r\nif (index < MAX_FIDS / 2) {\r\nif (!test_bit(FLAG_PENDING_XMIT, &ai->flags))\r\nnetif_wake_queue(ai->dev);\r\n} else {\r\nif (!test_bit(FLAG_PENDING_XMIT11, &ai->flags))\r\nnetif_wake_queue(ai->wifidev);\r\n}\r\n} else {\r\nOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\r\nairo_print_err(ai->dev->name, "Unallocated FID was used to xmit");\r\n}\r\n}\r\nstatic irqreturn_t airo_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nu16 status, savedInterrupts = 0;\r\nstruct airo_info *ai = dev->ml_priv;\r\nint handled = 0;\r\nif (!netif_device_present(dev))\r\nreturn IRQ_NONE;\r\nfor (;;) {\r\nstatus = IN4500(ai, EVSTAT);\r\nif (!(status & STATUS_INTS) || (status == 0xffff))\r\nbreak;\r\nhandled = 1;\r\nif (status & EV_AWAKE) {\r\nOUT4500(ai, EVACK, EV_AWAKE);\r\nOUT4500(ai, EVACK, EV_AWAKE);\r\n}\r\nif (!savedInterrupts) {\r\nsavedInterrupts = IN4500(ai, EVINTEN);\r\nOUT4500(ai, EVINTEN, 0);\r\n}\r\nif (status & EV_MIC) {\r\nOUT4500(ai, EVACK, EV_MIC);\r\nairo_handle_cisco_mic(ai);\r\n}\r\nif (status & EV_LINK) {\r\nairo_handle_link(ai);\r\n}\r\nif (status & EV_RX)\r\nairo_handle_rx(ai);\r\nif (status & (EV_TX | EV_TXCPY | EV_TXEXC))\r\nairo_handle_tx(ai, status);\r\nif ( status & ~STATUS_INTS & ~IGNORE_INTS ) {\r\nairo_print_warn(ai->dev->name, "Got weird status %x",\r\nstatus & ~STATUS_INTS & ~IGNORE_INTS );\r\n}\r\n}\r\nif (savedInterrupts)\r\nOUT4500(ai, EVINTEN, savedInterrupts);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void OUT4500( struct airo_info *ai, u16 reg, u16 val ) {\r\nif (test_bit(FLAG_MPI,&ai->flags))\r\nreg <<= 1;\r\nif ( !do8bitIO )\r\noutw( val, ai->dev->base_addr + reg );\r\nelse {\r\noutb( val & 0xff, ai->dev->base_addr + reg );\r\noutb( val >> 8, ai->dev->base_addr + reg + 1 );\r\n}\r\n}\r\nstatic u16 IN4500( struct airo_info *ai, u16 reg ) {\r\nunsigned short rc;\r\nif (test_bit(FLAG_MPI,&ai->flags))\r\nreg <<= 1;\r\nif ( !do8bitIO )\r\nrc = inw( ai->dev->base_addr + reg );\r\nelse {\r\nrc = inb( ai->dev->base_addr + reg );\r\nrc += ((int)inb( ai->dev->base_addr + reg + 1 )) << 8;\r\n}\r\nreturn rc;\r\n}\r\nstatic int enable_MAC(struct airo_info *ai, int lock)\r\n{\r\nint rc;\r\nCmd cmd;\r\nResp rsp;\r\nif (ai->flags & FLAG_RADIO_MASK) return SUCCESS;\r\nif (lock && down_interruptible(&ai->sem))\r\nreturn -ERESTARTSYS;\r\nif (!test_bit(FLAG_ENABLED, &ai->flags)) {\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd = MAC_ENABLE;\r\nrc = issuecommand(ai, &cmd, &rsp);\r\nif (rc == SUCCESS)\r\nset_bit(FLAG_ENABLED, &ai->flags);\r\n} else\r\nrc = SUCCESS;\r\nif (lock)\r\nup(&ai->sem);\r\nif (rc)\r\nairo_print_err(ai->dev->name, "Cannot enable MAC");\r\nelse if ((rsp.status & 0xFF00) != 0) {\r\nairo_print_err(ai->dev->name, "Bad MAC enable reason=%x, "\r\n"rid=%x, offset=%d", rsp.rsp0, rsp.rsp1, rsp.rsp2);\r\nrc = ERROR;\r\n}\r\nreturn rc;\r\n}\r\nstatic void disable_MAC( struct airo_info *ai, int lock ) {\r\nCmd cmd;\r\nResp rsp;\r\nif (lock == 1 && down_interruptible(&ai->sem))\r\nreturn;\r\nif (test_bit(FLAG_ENABLED, &ai->flags)) {\r\nif (lock != 2)\r\nnetif_carrier_off(ai->dev);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd = MAC_DISABLE;\r\nissuecommand(ai, &cmd, &rsp);\r\nclear_bit(FLAG_ENABLED, &ai->flags);\r\n}\r\nif (lock == 1)\r\nup(&ai->sem);\r\n}\r\nstatic void enable_interrupts( struct airo_info *ai ) {\r\nOUT4500( ai, EVINTEN, STATUS_INTS );\r\n}\r\nstatic void disable_interrupts( struct airo_info *ai ) {\r\nOUT4500( ai, EVINTEN, 0 );\r\n}\r\nstatic void mpi_receive_802_3(struct airo_info *ai)\r\n{\r\nRxFid rxd;\r\nint len = 0;\r\nstruct sk_buff *skb;\r\nchar *buffer;\r\nint off = 0;\r\nMICBuffer micbuf;\r\nmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\r\nif (rxd.rdy && rxd.valid == 0) {\r\nlen = rxd.len + 12;\r\nif (len < 12 || len > 2048)\r\ngoto badrx;\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nai->dev->stats.rx_dropped++;\r\ngoto badrx;\r\n}\r\nbuffer = skb_put(skb,len);\r\nmemcpy(buffer, ai->rxfids[0].virtual_host_addr, ETH_ALEN * 2);\r\nif (ai->micstats.enabled) {\r\nmemcpy(&micbuf,\r\nai->rxfids[0].virtual_host_addr + ETH_ALEN * 2,\r\nsizeof(micbuf));\r\nif (ntohs(micbuf.typelen) <= 0x05DC) {\r\nif (len <= sizeof(micbuf) + ETH_ALEN * 2)\r\ngoto badmic;\r\noff = sizeof(micbuf);\r\nskb_trim (skb, len - off);\r\n}\r\n}\r\nmemcpy(buffer + ETH_ALEN * 2,\r\nai->rxfids[0].virtual_host_addr + ETH_ALEN * 2 + off,\r\nlen - ETH_ALEN * 2 - off);\r\nif (decapsulate (ai, &micbuf, (etherHead*)buffer, len - off - ETH_ALEN * 2)) {\r\nbadmic:\r\ndev_kfree_skb_irq (skb);\r\ngoto badrx;\r\n}\r\n#ifdef WIRELESS_SPY\r\nif (ai->spy_data.spy_number > 0) {\r\nchar *sa;\r\nstruct iw_quality wstats;\r\nsa = buffer + ETH_ALEN;\r\nwstats.qual = 0;\r\nwstats.level = 0;\r\nwstats.updated = 0;\r\nwireless_spy_update(ai->dev, sa, &wstats);\r\n}\r\n#endif\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->protocol = eth_type_trans(skb, ai->dev);\r\nnetif_rx(skb);\r\n}\r\nbadrx:\r\nif (rxd.valid == 0) {\r\nrxd.valid = 1;\r\nrxd.rdy = 0;\r\nrxd.len = PKTSIZE;\r\nmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\r\n}\r\n}\r\nstatic void mpi_receive_802_11(struct airo_info *ai)\r\n{\r\nRxFid rxd;\r\nstruct sk_buff *skb = NULL;\r\nu16 len, hdrlen = 0;\r\n__le16 fc;\r\nstruct rx_hdr hdr;\r\nu16 gap;\r\nu16 *buffer;\r\nchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\r\nmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\r\nmemcpy ((char *)&hdr, ptr, sizeof(hdr));\r\nptr += sizeof(hdr);\r\nif (le16_to_cpu(hdr.status) & 2)\r\nhdr.len = 0;\r\nif (ai->wifidev == NULL)\r\nhdr.len = 0;\r\nlen = le16_to_cpu(hdr.len);\r\nif (len > AIRO_DEF_MTU) {\r\nairo_print_err(ai->dev->name, "Bad size %d", len);\r\ngoto badrx;\r\n}\r\nif (len == 0)\r\ngoto badrx;\r\nfc = get_unaligned((__le16 *)ptr);\r\nhdrlen = header_len(fc);\r\nskb = dev_alloc_skb( len + hdrlen + 2 );\r\nif ( !skb ) {\r\nai->dev->stats.rx_dropped++;\r\ngoto badrx;\r\n}\r\nbuffer = (u16*)skb_put (skb, len + hdrlen);\r\nmemcpy ((char *)buffer, ptr, hdrlen);\r\nptr += hdrlen;\r\nif (hdrlen == 24)\r\nptr += 6;\r\ngap = get_unaligned_le16(ptr);\r\nptr += sizeof(__le16);\r\nif (gap) {\r\nif (gap <= 8)\r\nptr += gap;\r\nelse\r\nairo_print_err(ai->dev->name,\r\n"gaplen too big. Problems will follow...");\r\n}\r\nmemcpy ((char *)buffer + hdrlen, ptr, len);\r\nptr += len;\r\n#ifdef IW_WIRELESS_SPY\r\nif (ai->spy_data.spy_number > 0) {\r\nchar *sa;\r\nstruct iw_quality wstats;\r\nsa = (char*)buffer + 10;\r\nwstats.qual = hdr.rssi[0];\r\nif (ai->rssi)\r\nwstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\r\nelse\r\nwstats.level = (hdr.rssi[1] + 321) / 2;\r\nwstats.noise = ai->wstats.qual.noise;\r\nwstats.updated = IW_QUAL_QUAL_UPDATED\r\n| IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_DBM;\r\nwireless_spy_update(ai->dev, sa, &wstats);\r\n}\r\n#endif\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->dev = ai->wifidev;\r\nskb->protocol = htons(ETH_P_802_2);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx( skb );\r\nbadrx:\r\nif (rxd.valid == 0) {\r\nrxd.valid = 1;\r\nrxd.rdy = 0;\r\nrxd.len = PKTSIZE;\r\nmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\r\n}\r\n}\r\nstatic inline void set_auth_type(struct airo_info *local, int auth_type)\r\n{\r\nlocal->config.authType = auth_type;\r\nif (auth_type == AUTH_OPEN || auth_type == AUTH_ENCRYPT)\r\nlocal->last_auth = auth_type;\r\n}\r\nstatic u16 setup_card(struct airo_info *ai, u8 *mac, int lock)\r\n{\r\nCmd cmd;\r\nResp rsp;\r\nint status;\r\nSsidRid mySsid;\r\n__le16 lastindex;\r\nWepKeyRid wkr;\r\nint rc;\r\nmemset( &mySsid, 0, sizeof( mySsid ) );\r\nkfree (ai->flash);\r\nai->flash = NULL;\r\ncmd.cmd = NOP;\r\ncmd.parm0 = cmd.parm1 = cmd.parm2 = 0;\r\nif (lock && down_interruptible(&ai->sem))\r\nreturn ERROR;\r\nif ( issuecommand( ai, &cmd, &rsp ) != SUCCESS ) {\r\nif (lock)\r\nup(&ai->sem);\r\nreturn ERROR;\r\n}\r\ndisable_MAC( ai, 0);\r\nif (!test_bit(FLAG_MPI,&ai->flags)) {\r\ncmd.cmd = CMD_ENABLEAUX;\r\nif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\r\nif (lock)\r\nup(&ai->sem);\r\nairo_print_err(ai->dev->name, "Error checking for AUX port");\r\nreturn ERROR;\r\n}\r\nif (!aux_bap || rsp.status & 0xff00) {\r\nai->bap_read = fast_bap_read;\r\nairo_print_dbg(ai->dev->name, "Doing fast bap_reads");\r\n} else {\r\nai->bap_read = aux_bap_read;\r\nairo_print_dbg(ai->dev->name, "Doing AUX bap_reads");\r\n}\r\n}\r\nif (lock)\r\nup(&ai->sem);\r\nif (ai->config.len == 0) {\r\nint i;\r\ntdsRssiRid rssi_rid;\r\nCapabilityRid cap_rid;\r\nkfree(ai->SSID);\r\nai->SSID = NULL;\r\nstatus = readConfigRid(ai, lock);\r\nif ( status != SUCCESS ) return ERROR;\r\nstatus = readCapabilityRid(ai, &cap_rid, lock);\r\nif ( status != SUCCESS ) return ERROR;\r\nstatus = PC4500_readrid(ai,RID_RSSI,&rssi_rid,sizeof(rssi_rid),lock);\r\nif ( status == SUCCESS ) {\r\nif (ai->rssi || (ai->rssi = kmalloc(512, GFP_KERNEL)) != NULL)\r\nmemcpy(ai->rssi, (u8*)&rssi_rid + 2, 512);\r\n}\r\nelse {\r\nkfree(ai->rssi);\r\nai->rssi = NULL;\r\nif (cap_rid.softCap & cpu_to_le16(8))\r\nai->config.rmode |= RXMODE_NORMALIZED_RSSI;\r\nelse\r\nairo_print_warn(ai->dev->name, "unknown received signal "\r\n"level scale");\r\n}\r\nai->config.opmode = adhoc ? MODE_STA_IBSS : MODE_STA_ESS;\r\nset_auth_type(ai, AUTH_OPEN);\r\nai->config.modulation = MOD_CCK;\r\nif (le16_to_cpu(cap_rid.len) >= sizeof(cap_rid) &&\r\n(cap_rid.extSoftCap & cpu_to_le16(1)) &&\r\nmicsetup(ai) == SUCCESS) {\r\nai->config.opmode |= MODE_MIC;\r\nset_bit(FLAG_MIC_CAPABLE, &ai->flags);\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nmac[i] = ai->config.macAddr[i];\r\n}\r\nif ( rates[0] ) {\r\nmemset(ai->config.rates,0,sizeof(ai->config.rates));\r\nfor( i = 0; i < 8 && rates[i]; i++ ) {\r\nai->config.rates[i] = rates[i];\r\n}\r\n}\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\nif ( ssids[0] ) {\r\nint i;\r\nfor( i = 0; i < 3 && ssids[i]; i++ ) {\r\nsize_t len = strlen(ssids[i]);\r\nif (len > 32)\r\nlen = 32;\r\nmySsid.ssids[i].len = cpu_to_le16(len);\r\nmemcpy(mySsid.ssids[i].ssid, ssids[i], len);\r\n}\r\nmySsid.len = cpu_to_le16(sizeof(mySsid));\r\n}\r\nstatus = writeConfigRid(ai, lock);\r\nif ( status != SUCCESS ) return ERROR;\r\nif ( ssids[0] ) {\r\nstatus = writeSsidRid(ai, &mySsid, lock);\r\nif ( status != SUCCESS ) return ERROR;\r\n}\r\nstatus = enable_MAC(ai, lock);\r\nif (status != SUCCESS)\r\nreturn ERROR;\r\nrc = readWepKeyRid(ai, &wkr, 1, lock);\r\nif (rc == SUCCESS) do {\r\nlastindex = wkr.kindex;\r\nif (wkr.kindex == cpu_to_le16(0xffff)) {\r\nai->defindex = wkr.mac[0];\r\n}\r\nrc = readWepKeyRid(ai, &wkr, 0, lock);\r\n} while(lastindex != wkr.kindex);\r\ntry_auto_wep(ai);\r\nreturn SUCCESS;\r\n}\r\nstatic u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp) {\r\nint max_tries = 600000;\r\nif (IN4500(ai, EVSTAT) & EV_CMD)\r\nOUT4500(ai, EVACK, EV_CMD);\r\nOUT4500(ai, PARAM0, pCmd->parm0);\r\nOUT4500(ai, PARAM1, pCmd->parm1);\r\nOUT4500(ai, PARAM2, pCmd->parm2);\r\nOUT4500(ai, COMMAND, pCmd->cmd);\r\nwhile (max_tries-- && (IN4500(ai, EVSTAT) & EV_CMD) == 0) {\r\nif ((IN4500(ai, COMMAND)) == pCmd->cmd)\r\nOUT4500(ai, COMMAND, pCmd->cmd);\r\nif (!in_atomic() && (max_tries & 255) == 0)\r\nschedule();\r\n}\r\nif ( max_tries == -1 ) {\r\nairo_print_err(ai->dev->name,\r\n"Max tries exceeded when issuing command");\r\nif (IN4500(ai, COMMAND) & COMMAND_BUSY)\r\nOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\r\nreturn ERROR;\r\n}\r\npRsp->status = IN4500(ai, STATUS);\r\npRsp->rsp0 = IN4500(ai, RESP0);\r\npRsp->rsp1 = IN4500(ai, RESP1);\r\npRsp->rsp2 = IN4500(ai, RESP2);\r\nif ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET)\r\nairo_print_err(ai->dev->name,\r\n"cmd:%x status:%x rsp0:%x rsp1:%x rsp2:%x",\r\npCmd->cmd, pRsp->status, pRsp->rsp0, pRsp->rsp1,\r\npRsp->rsp2);\r\nif (IN4500(ai, COMMAND) & COMMAND_BUSY) {\r\nOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\r\n}\r\nOUT4500(ai, EVACK, EV_CMD);\r\nreturn SUCCESS;\r\n}\r\nstatic int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap )\r\n{\r\nint timeout = 50;\r\nint max_tries = 3;\r\nOUT4500(ai, SELECT0+whichbap, rid);\r\nOUT4500(ai, OFFSET0+whichbap, offset);\r\nwhile (1) {\r\nint status = IN4500(ai, OFFSET0+whichbap);\r\nif (status & BAP_BUSY) {\r\nif (timeout--) {\r\ncontinue;\r\n}\r\n} else if ( status & BAP_ERR ) {\r\nairo_print_err(ai->dev->name, "BAP error %x %d",\r\nstatus, whichbap );\r\nreturn ERROR;\r\n} else if (status & BAP_DONE) {\r\nreturn SUCCESS;\r\n}\r\nif ( !(max_tries--) ) {\r\nairo_print_err(ai->dev->name,\r\n"BAP setup error too many retries\n");\r\nreturn ERROR;\r\n}\r\nOUT4500(ai, SELECT0+whichbap, rid);\r\nOUT4500(ai, OFFSET0+whichbap, offset);\r\ntimeout = 50;\r\n}\r\n}\r\nstatic u16 aux_setup(struct airo_info *ai, u16 page,\r\nu16 offset, u16 *len)\r\n{\r\nu16 next;\r\nOUT4500(ai, AUXPAGE, page);\r\nOUT4500(ai, AUXOFF, 0);\r\nnext = IN4500(ai, AUXDATA);\r\n*len = IN4500(ai, AUXDATA)&0xff;\r\nif (offset != 4) OUT4500(ai, AUXOFF, offset);\r\nreturn next;\r\n}\r\nstatic int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst,\r\nint bytelen, int whichbap)\r\n{\r\nu16 len;\r\nu16 page;\r\nu16 offset;\r\nu16 next;\r\nint words;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ai->aux_lock, flags);\r\npage = IN4500(ai, SWS0+whichbap);\r\noffset = IN4500(ai, SWS2+whichbap);\r\nnext = aux_setup(ai, page, offset, &len);\r\nwords = (bytelen+1)>>1;\r\nfor (i=0; i<words;) {\r\nint count;\r\ncount = (len>>1) < (words-i) ? (len>>1) : (words-i);\r\nif ( !do8bitIO )\r\ninsw( ai->dev->base_addr+DATA0+whichbap,\r\npu16Dst+i,count );\r\nelse\r\ninsb( ai->dev->base_addr+DATA0+whichbap,\r\npu16Dst+i, count << 1 );\r\ni += count;\r\nif (i<words) {\r\nnext = aux_setup(ai, next, 4, &len);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ai->aux_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst,\r\nint bytelen, int whichbap)\r\n{\r\nbytelen = (bytelen + 1) & (~1);\r\nif ( !do8bitIO )\r\ninsw( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen>>1 );\r\nelse\r\ninsb( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen );\r\nreturn SUCCESS;\r\n}\r\nstatic int bap_write(struct airo_info *ai, const __le16 *pu16Src,\r\nint bytelen, int whichbap)\r\n{\r\nbytelen = (bytelen + 1) & (~1);\r\nif ( !do8bitIO )\r\noutsw( ai->dev->base_addr+DATA0+whichbap,\r\npu16Src, bytelen>>1 );\r\nelse\r\noutsb( ai->dev->base_addr+DATA0+whichbap, pu16Src, bytelen );\r\nreturn SUCCESS;\r\n}\r\nstatic int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)\r\n{\r\nCmd cmd;\r\nResp rsp;\r\nu16 status;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd = accmd;\r\ncmd.parm0 = rid;\r\nstatus = issuecommand(ai, &cmd, &rsp);\r\nif (status != 0) return status;\r\nif ( (rsp.status & 0x7F00) != 0) {\r\nreturn (accmd << 8) + (rsp.rsp0 & 0xFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)\r\n{\r\nu16 status;\r\nint rc = SUCCESS;\r\nif (lock) {\r\nif (down_interruptible(&ai->sem))\r\nreturn ERROR;\r\n}\r\nif (test_bit(FLAG_MPI,&ai->flags)) {\r\nCmd cmd;\r\nResp rsp;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemset(&rsp, 0, sizeof(rsp));\r\nai->config_desc.rid_desc.valid = 1;\r\nai->config_desc.rid_desc.len = RIDSIZE;\r\nai->config_desc.rid_desc.rid = 0;\r\nai->config_desc.rid_desc.host_addr = ai->ridbus;\r\ncmd.cmd = CMD_ACCESS;\r\ncmd.parm0 = rid;\r\nmemcpy_toio(ai->config_desc.card_ram_off,\r\n&ai->config_desc.rid_desc, sizeof(Rid));\r\nrc = issuecommand(ai, &cmd, &rsp);\r\nif (rsp.status & 0x7f00)\r\nrc = rsp.rsp0;\r\nif (!rc)\r\nmemcpy(pBuf, ai->config_desc.virtual_host_addr, len);\r\ngoto done;\r\n} else {\r\nif ((status = PC4500_accessrid(ai, rid, CMD_ACCESS))!=SUCCESS) {\r\nrc = status;\r\ngoto done;\r\n}\r\nif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\r\nrc = ERROR;\r\ngoto done;\r\n}\r\nbap_read(ai, pBuf, 2, BAP1);\r\nlen = min(len, (int)le16_to_cpu(*(__le16*)pBuf)) - 2;\r\nif ( len <= 2 ) {\r\nairo_print_err(ai->dev->name,\r\n"Rid %x has a length of %d which is too short",\r\n(int)rid, (int)len );\r\nrc = ERROR;\r\ngoto done;\r\n}\r\nrc = bap_read(ai, ((__le16*)pBuf)+1, len, BAP1);\r\n}\r\ndone:\r\nif (lock)\r\nup(&ai->sem);\r\nreturn rc;\r\n}\r\nstatic int PC4500_writerid(struct airo_info *ai, u16 rid,\r\nconst void *pBuf, int len, int lock)\r\n{\r\nu16 status;\r\nint rc = SUCCESS;\r\n*(__le16*)pBuf = cpu_to_le16((u16)len);\r\nif (lock) {\r\nif (down_interruptible(&ai->sem))\r\nreturn ERROR;\r\n}\r\nif (test_bit(FLAG_MPI,&ai->flags)) {\r\nCmd cmd;\r\nResp rsp;\r\nif (test_bit(FLAG_ENABLED, &ai->flags) && (RID_WEP_TEMP != rid))\r\nairo_print_err(ai->dev->name,\r\n"%s: MAC should be disabled (rid=%04x)",\r\n__func__, rid);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemset(&rsp, 0, sizeof(rsp));\r\nai->config_desc.rid_desc.valid = 1;\r\nai->config_desc.rid_desc.len = *((u16 *)pBuf);\r\nai->config_desc.rid_desc.rid = 0;\r\ncmd.cmd = CMD_WRITERID;\r\ncmd.parm0 = rid;\r\nmemcpy_toio(ai->config_desc.card_ram_off,\r\n&ai->config_desc.rid_desc, sizeof(Rid));\r\nif (len < 4 || len > 2047) {\r\nairo_print_err(ai->dev->name, "%s: len=%d", __func__, len);\r\nrc = -1;\r\n} else {\r\nmemcpy(ai->config_desc.virtual_host_addr,\r\npBuf, len);\r\nrc = issuecommand(ai, &cmd, &rsp);\r\nif ((rc & 0xff00) != 0) {\r\nairo_print_err(ai->dev->name, "%s: Write rid Error %d",\r\n__func__, rc);\r\nairo_print_err(ai->dev->name, "%s: Cmd=%04x",\r\n__func__, cmd.cmd);\r\n}\r\nif ((rsp.status & 0x7f00))\r\nrc = rsp.rsp0;\r\n}\r\n} else {\r\nif ( (status = PC4500_accessrid(ai, rid, CMD_ACCESS)) != 0) {\r\nrc = status;\r\ngoto done;\r\n}\r\nif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\r\nrc = ERROR;\r\ngoto done;\r\n}\r\nbap_write(ai, pBuf, len, BAP1);\r\nrc = PC4500_accessrid(ai, rid, 0x100|CMD_ACCESS);\r\n}\r\ndone:\r\nif (lock)\r\nup(&ai->sem);\r\nreturn rc;\r\n}\r\nstatic u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw)\r\n{\r\nunsigned int loop = 3000;\r\nCmd cmd;\r\nResp rsp;\r\nu16 txFid;\r\n__le16 txControl;\r\ncmd.cmd = CMD_ALLOCATETX;\r\ncmd.parm0 = lenPayload;\r\nif (down_interruptible(&ai->sem))\r\nreturn ERROR;\r\nif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\r\ntxFid = ERROR;\r\ngoto done;\r\n}\r\nif ( (rsp.status & 0xFF00) != 0) {\r\ntxFid = ERROR;\r\ngoto done;\r\n}\r\nwhile (((IN4500(ai, EVSTAT) & EV_ALLOC) == 0) && --loop);\r\nif (!loop) {\r\ntxFid = ERROR;\r\ngoto done;\r\n}\r\ntxFid = IN4500(ai, TXALLOCFID);\r\nOUT4500(ai, EVACK, EV_ALLOC);\r\nif (raw)\r\ntxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_11\r\n| TXCTL_ETHERNET | TXCTL_NORELEASE);\r\nelse\r\ntxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_3\r\n| TXCTL_ETHERNET | TXCTL_NORELEASE);\r\nif (bap_setup(ai, txFid, 0x0008, BAP1) != SUCCESS)\r\ntxFid = ERROR;\r\nelse\r\nbap_write(ai, &txControl, sizeof(txControl), BAP1);\r\ndone:\r\nup(&ai->sem);\r\nreturn txFid;\r\n}\r\nstatic int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket)\r\n{\r\n__le16 payloadLen;\r\nCmd cmd;\r\nResp rsp;\r\nint miclen = 0;\r\nu16 txFid = len;\r\nMICBuffer pMic;\r\nlen >>= 16;\r\nif (len <= ETH_ALEN * 2) {\r\nairo_print_warn(ai->dev->name, "Short packet %d", len);\r\nreturn ERROR;\r\n}\r\nlen -= ETH_ALEN * 2;\r\nif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\r\n(ntohs(((__be16 *)pPacket)[6]) != 0x888E)) {\r\nif (encapsulate(ai,(etherHead *)pPacket,&pMic,len) != SUCCESS)\r\nreturn ERROR;\r\nmiclen = sizeof(pMic);\r\n}\r\nif (bap_setup(ai, txFid, 0x0036, BAP1) != SUCCESS) return ERROR;\r\npayloadLen = cpu_to_le16(len + miclen);\r\nbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\r\nbap_write(ai, (__le16*)pPacket, sizeof(etherHead), BAP1);\r\nif (miclen)\r\nbap_write(ai, (__le16*)&pMic, miclen, BAP1);\r\nbap_write(ai, (__le16*)(pPacket + sizeof(etherHead)), len, BAP1);\r\nmemset( &cmd, 0, sizeof( cmd ) );\r\ncmd.cmd = CMD_TRANSMIT;\r\ncmd.parm0 = txFid;\r\nif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\r\nif ( (rsp.status & 0xFF00) != 0) return ERROR;\r\nreturn SUCCESS;\r\n}\r\nstatic int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket)\r\n{\r\n__le16 fc, payloadLen;\r\nCmd cmd;\r\nResp rsp;\r\nint hdrlen;\r\nstatic u8 tail[(30-10) + 2 + 6] = {[30-10] = 6};\r\nu16 txFid = len;\r\nlen >>= 16;\r\nfc = *(__le16*)pPacket;\r\nhdrlen = header_len(fc);\r\nif (len < hdrlen) {\r\nairo_print_warn(ai->dev->name, "Short packet %d", len);\r\nreturn ERROR;\r\n}\r\nif (bap_setup(ai, txFid, 6, BAP1) != SUCCESS) return ERROR;\r\npayloadLen = cpu_to_le16(len-hdrlen);\r\nbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\r\nif (bap_setup(ai, txFid, 0x0014, BAP1) != SUCCESS) return ERROR;\r\nbap_write(ai, (__le16 *)pPacket, hdrlen, BAP1);\r\nbap_write(ai, (__le16 *)(tail + (hdrlen - 10)), 38 - hdrlen, BAP1);\r\nbap_write(ai, (__le16 *)(pPacket + hdrlen), len - hdrlen, BAP1);\r\nmemset( &cmd, 0, sizeof( cmd ) );\r\ncmd.cmd = CMD_TRANSMIT;\r\ncmd.parm0 = txFid;\r\nif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\r\nif ( (rsp.status & 0xFF00) != 0) return ERROR;\r\nreturn SUCCESS;\r\n}\r\nstatic int setup_proc_entry( struct net_device *dev,\r\nstruct airo_info *apriv ) {\r\nstruct proc_dir_entry *entry;\r\nstrcpy(apriv->proc_name,dev->name);\r\napriv->proc_entry = proc_mkdir_mode(apriv->proc_name, airo_perm,\r\nairo_entry);\r\nif (!apriv->proc_entry)\r\nreturn -ENOMEM;\r\nproc_set_user(apriv->proc_entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("StatsDelta", S_IRUGO & proc_perm,\r\napriv->proc_entry, &proc_statsdelta_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("Stats", S_IRUGO & proc_perm,\r\napriv->proc_entry, &proc_stats_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("Status", S_IRUGO & proc_perm,\r\napriv->proc_entry, &proc_status_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("Config", proc_perm,\r\napriv->proc_entry, &proc_config_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("SSID", proc_perm,\r\napriv->proc_entry, &proc_SSID_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("APList", proc_perm,\r\napriv->proc_entry, &proc_APList_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("BSSList", proc_perm,\r\napriv->proc_entry, &proc_BSSList_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nentry = proc_create_data("WepKey", proc_perm,\r\napriv->proc_entry, &proc_wepkey_ops, dev);\r\nif (!entry)\r\ngoto fail;\r\nproc_set_user(entry, proc_kuid, proc_kgid);\r\nreturn 0;\r\nfail:\r\nremove_proc_subtree(apriv->proc_name, airo_entry);\r\nreturn -ENOMEM;\r\n}\r\nstatic int takedown_proc_entry( struct net_device *dev,\r\nstruct airo_info *apriv )\r\n{\r\nremove_proc_subtree(apriv->proc_name, airo_entry);\r\nreturn 0;\r\n}\r\nstatic ssize_t proc_read( struct file *file,\r\nchar __user *buffer,\r\nsize_t len,\r\nloff_t *offset )\r\n{\r\nstruct proc_data *priv = file->private_data;\r\nif (!priv->rbuffer)\r\nreturn -EINVAL;\r\nreturn simple_read_from_buffer(buffer, len, offset, priv->rbuffer,\r\npriv->readlen);\r\n}\r\nstatic ssize_t proc_write( struct file *file,\r\nconst char __user *buffer,\r\nsize_t len,\r\nloff_t *offset )\r\n{\r\nssize_t ret;\r\nstruct proc_data *priv = file->private_data;\r\nif (!priv->wbuffer)\r\nreturn -EINVAL;\r\nret = simple_write_to_buffer(priv->wbuffer, priv->maxwritelen, offset,\r\nbuffer, len);\r\nif (ret > 0)\r\npriv->writelen = max_t(int, priv->writelen, *offset);\r\nreturn ret;\r\n}\r\nstatic int proc_status_open(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *apriv = dev->ml_priv;\r\nCapabilityRid cap_rid;\r\nStatusRid status_rid;\r\nu16 mode;\r\nint i;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\nreadStatusRid(apriv, &status_rid, 1);\r\nreadCapabilityRid(apriv, &cap_rid, 1);\r\nmode = le16_to_cpu(status_rid.mode);\r\ni = sprintf(data->rbuffer, "Status: %s%s%s%s%s%s%s%s%s\n",\r\nmode & 1 ? "CFG ": "",\r\nmode & 2 ? "ACT ": "",\r\nmode & 0x10 ? "SYN ": "",\r\nmode & 0x20 ? "LNK ": "",\r\nmode & 0x40 ? "LEAP ": "",\r\nmode & 0x80 ? "PRIV ": "",\r\nmode & 0x100 ? "KEY ": "",\r\nmode & 0x200 ? "WEP ": "",\r\nmode & 0x8000 ? "ERR ": "");\r\nsprintf( data->rbuffer+i, "Mode: %x\n"\r\n"Signal Strength: %d\n"\r\n"Signal Quality: %d\n"\r\n"SSID: %-.*s\n"\r\n"AP: %-.16s\n"\r\n"Freq: %d\n"\r\n"BitRate: %dmbs\n"\r\n"Driver Version: %s\n"\r\n"Device: %s\nManufacturer: %s\nFirmware Version: %s\n"\r\n"Radio type: %x\nCountry: %x\nHardware Version: %x\n"\r\n"Software Version: %x\nSoftware Subversion: %x\n"\r\n"Boot block version: %x\n",\r\nle16_to_cpu(status_rid.mode),\r\nle16_to_cpu(status_rid.normalizedSignalStrength),\r\nle16_to_cpu(status_rid.signalQuality),\r\nle16_to_cpu(status_rid.SSIDlen),\r\nstatus_rid.SSID,\r\nstatus_rid.apName,\r\nle16_to_cpu(status_rid.channel),\r\nle16_to_cpu(status_rid.currentXmitRate) / 2,\r\nversion,\r\ncap_rid.prodName,\r\ncap_rid.manName,\r\ncap_rid.prodVer,\r\nle16_to_cpu(cap_rid.radioType),\r\nle16_to_cpu(cap_rid.country),\r\nle16_to_cpu(cap_rid.hardVer),\r\nle16_to_cpu(cap_rid.softVer),\r\nle16_to_cpu(cap_rid.softSubVer),\r\nle16_to_cpu(cap_rid.bootBlockVer));\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic int proc_statsdelta_open( struct inode *inode,\r\nstruct file *file ) {\r\nif (file->f_mode&FMODE_WRITE) {\r\nreturn proc_stats_rid_open(inode, file, RID_STATSDELTACLEAR);\r\n}\r\nreturn proc_stats_rid_open(inode, file, RID_STATSDELTA);\r\n}\r\nstatic int proc_stats_open( struct inode *inode, struct file *file ) {\r\nreturn proc_stats_rid_open(inode, file, RID_STATS);\r\n}\r\nstatic int proc_stats_rid_open( struct inode *inode,\r\nstruct file *file,\r\nu16 rid )\r\n{\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *apriv = dev->ml_priv;\r\nStatsRid stats;\r\nint i, j;\r\n__le32 *vals = stats.vals;\r\nint len;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 4096, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\nreadStatsRid(apriv, &stats, rid, 1);\r\nlen = le16_to_cpu(stats.len);\r\nj = 0;\r\nfor(i=0; statsLabels[i]!=(char *)-1 && i*4<len; i++) {\r\nif (!statsLabels[i]) continue;\r\nif (j+strlen(statsLabels[i])+16>4096) {\r\nairo_print_warn(apriv->dev->name,\r\n"Potentially disastrous buffer overflow averted!");\r\nbreak;\r\n}\r\nj+=sprintf(data->rbuffer+j, "%s: %u\n", statsLabels[i],\r\nle32_to_cpu(vals[i]));\r\n}\r\nif (i*4 >= len) {\r\nairo_print_warn(apriv->dev->name, "Got a short rid");\r\n}\r\ndata->readlen = j;\r\nreturn 0;\r\n}\r\nstatic int get_dec_u16( char *buffer, int *start, int limit ) {\r\nu16 value;\r\nint valid = 0;\r\nfor (value = 0; *start < limit && buffer[*start] >= '0' &&\r\nbuffer[*start] <= '9'; (*start)++) {\r\nvalid = 1;\r\nvalue *= 10;\r\nvalue += buffer[*start] - '0';\r\n}\r\nif ( !valid ) return -1;\r\nreturn value;\r\n}\r\nstatic inline int sniffing_mode(struct airo_info *ai)\r\n{\r\nreturn (le16_to_cpu(ai->config.rmode) & le16_to_cpu(RXMODE_MASK)) >=\r\nle16_to_cpu(RXMODE_RFMON);\r\n}\r\nstatic void proc_config_on_close(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_data *data = file->private_data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nchar *line;\r\nif ( !data->writelen ) return;\r\nreadConfigRid(ai, 1);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\nline = data->wbuffer;\r\nwhile( line[0] ) {\r\nif ( !strncmp( line, "Mode: ", 6 ) ) {\r\nline += 6;\r\nif (sniffing_mode(ai))\r\nset_bit (FLAG_RESET, &ai->flags);\r\nai->config.rmode &= ~RXMODE_FULL_MASK;\r\nclear_bit (FLAG_802_11, &ai->flags);\r\nai->config.opmode &= ~MODE_CFG_MASK;\r\nai->config.scanMode = SCANMODE_ACTIVE;\r\nif ( line[0] == 'a' ) {\r\nai->config.opmode |= MODE_STA_IBSS;\r\n} else {\r\nai->config.opmode |= MODE_STA_ESS;\r\nif ( line[0] == 'r' ) {\r\nai->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\r\nai->config.scanMode = SCANMODE_PASSIVE;\r\nset_bit (FLAG_802_11, &ai->flags);\r\n} else if ( line[0] == 'y' ) {\r\nai->config.rmode |= RXMODE_RFMON_ANYBSS | RXMODE_DISABLE_802_3_HEADER;\r\nai->config.scanMode = SCANMODE_PASSIVE;\r\nset_bit (FLAG_802_11, &ai->flags);\r\n} else if ( line[0] == 'l' )\r\nai->config.rmode |= RXMODE_LANMON;\r\n}\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\nelse if (!strncmp(line,"Radio: ", 7)) {\r\nline += 7;\r\nif (!strncmp(line,"off",3)) {\r\nset_bit (FLAG_RADIO_OFF, &ai->flags);\r\n} else {\r\nclear_bit (FLAG_RADIO_OFF, &ai->flags);\r\n}\r\n}\r\nelse if ( !strncmp( line, "NodeName: ", 10 ) ) {\r\nint j;\r\nline += 10;\r\nmemset( ai->config.nodeName, 0, 16 );\r\nfor( j = 0; j < 16 && line[j] != '\n'; j++ ) {\r\nai->config.nodeName[j] = line[j];\r\n}\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\nelse if ( !strncmp( line, "PowerMode: ", 11 ) ) {\r\nline += 11;\r\nif ( !strncmp( line, "PSPCAM", 6 ) ) {\r\nai->config.powerSaveMode = POWERSAVE_PSPCAM;\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "PSP", 3 ) ) {\r\nai->config.powerSaveMode = POWERSAVE_PSP;\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else {\r\nai->config.powerSaveMode = POWERSAVE_CAM;\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\n} else if ( !strncmp( line, "DataRates: ", 11 ) ) {\r\nint v, i = 0, k = 0;\r\nline += 11;\r\nwhile((v = get_dec_u16(line, &i, 3))!=-1) {\r\nai->config.rates[k++] = (u8)v;\r\nline += i + 1;\r\ni = 0;\r\n}\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "Channel: ", 9 ) ) {\r\nint v, i = 0;\r\nline += 9;\r\nv = get_dec_u16(line, &i, i+3);\r\nif ( v != -1 ) {\r\nai->config.channelSet = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\n} else if ( !strncmp( line, "XmitPower: ", 11 ) ) {\r\nint v, i = 0;\r\nline += 11;\r\nv = get_dec_u16(line, &i, i+3);\r\nif ( v != -1 ) {\r\nai->config.txPower = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n}\r\n} else if ( !strncmp( line, "WEP: ", 5 ) ) {\r\nline += 5;\r\nswitch( line[0] ) {\r\ncase 's':\r\nset_auth_type(ai, AUTH_SHAREDKEY);\r\nbreak;\r\ncase 'e':\r\nset_auth_type(ai, AUTH_ENCRYPT);\r\nbreak;\r\ndefault:\r\nset_auth_type(ai, AUTH_OPEN);\r\nbreak;\r\n}\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "LongRetryLimit: ", 16 ) ) {\r\nint v, i = 0;\r\nline += 16;\r\nv = get_dec_u16(line, &i, 3);\r\nv = (v<0) ? 0 : ((v>255) ? 255 : v);\r\nai->config.longRetryLimit = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "ShortRetryLimit: ", 17 ) ) {\r\nint v, i = 0;\r\nline += 17;\r\nv = get_dec_u16(line, &i, 3);\r\nv = (v<0) ? 0 : ((v>255) ? 255 : v);\r\nai->config.shortRetryLimit = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "RTSThreshold: ", 14 ) ) {\r\nint v, i = 0;\r\nline += 14;\r\nv = get_dec_u16(line, &i, 4);\r\nv = (v<0) ? 0 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\r\nai->config.rtsThres = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "TXMSDULifetime: ", 16 ) ) {\r\nint v, i = 0;\r\nline += 16;\r\nv = get_dec_u16(line, &i, 5);\r\nv = (v<0) ? 0 : v;\r\nai->config.txLifetime = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "RXMSDULifetime: ", 16 ) ) {\r\nint v, i = 0;\r\nline += 16;\r\nv = get_dec_u16(line, &i, 5);\r\nv = (v<0) ? 0 : v;\r\nai->config.rxLifetime = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "TXDiversity: ", 13 ) ) {\r\nai->config.txDiversity =\r\n(line[13]=='l') ? 1 :\r\n((line[13]=='r')? 2: 3);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "RXDiversity: ", 13 ) ) {\r\nai->config.rxDiversity =\r\n(line[13]=='l') ? 1 :\r\n((line[13]=='r')? 2: 3);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if ( !strncmp( line, "FragThreshold: ", 15 ) ) {\r\nint v, i = 0;\r\nline += 15;\r\nv = get_dec_u16(line, &i, 4);\r\nv = (v<256) ? 256 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\r\nv = v & 0xfffe;\r\nai->config.fragThresh = cpu_to_le16(v);\r\nset_bit (FLAG_COMMIT, &ai->flags);\r\n} else if (!strncmp(line, "Modulation: ", 12)) {\r\nline += 12;\r\nswitch(*line) {\r\ncase 'd': ai->config.modulation=MOD_DEFAULT; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ncase 'c': ai->config.modulation=MOD_CCK; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ncase 'm': ai->config.modulation=MOD_MOK; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ndefault: airo_print_warn(ai->dev->name, "Unknown modulation");\r\n}\r\n} else if (!strncmp(line, "Preamble: ", 10)) {\r\nline += 10;\r\nswitch(*line) {\r\ncase 'a': ai->config.preamble=PREAMBLE_AUTO; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ncase 'l': ai->config.preamble=PREAMBLE_LONG; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ncase 's': ai->config.preamble=PREAMBLE_SHORT; set_bit(FLAG_COMMIT, &ai->flags); break;\r\ndefault: airo_print_warn(ai->dev->name, "Unknown preamble");\r\n}\r\n} else {\r\nairo_print_warn(ai->dev->name, "Couldn't figure out %s", line);\r\n}\r\nwhile( line[0] && line[0] != '\n' ) line++;\r\nif ( line[0] ) line++;\r\n}\r\nairo_config_commit(dev, NULL, NULL, NULL);\r\n}\r\nstatic const char *get_rmode(__le16 mode)\r\n{\r\nswitch(mode & RXMODE_MASK) {\r\ncase RXMODE_RFMON: return "rfmon";\r\ncase RXMODE_RFMON_ANYBSS: return "yna (any) bss rfmon";\r\ncase RXMODE_LANMON: return "lanmon";\r\n}\r\nreturn "ESS";\r\n}\r\nstatic int proc_config_open(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nint i;\r\n__le16 mode;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\nif ((data->wbuffer = kzalloc( 2048, GFP_KERNEL )) == NULL) {\r\nkfree (data->rbuffer);\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->maxwritelen = 2048;\r\ndata->on_close = proc_config_on_close;\r\nreadConfigRid(ai, 1);\r\nmode = ai->config.opmode & MODE_CFG_MASK;\r\ni = sprintf( data->rbuffer,\r\n"Mode: %s\n"\r\n"Radio: %s\n"\r\n"NodeName: %-16s\n"\r\n"PowerMode: %s\n"\r\n"DataRates: %d %d %d %d %d %d %d %d\n"\r\n"Channel: %d\n"\r\n"XmitPower: %d\n",\r\nmode == MODE_STA_IBSS ? "adhoc" :\r\nmode == MODE_STA_ESS ? get_rmode(ai->config.rmode):\r\nmode == MODE_AP ? "AP" :\r\nmode == MODE_AP_RPTR ? "AP RPTR" : "Error",\r\ntest_bit(FLAG_RADIO_OFF, &ai->flags) ? "off" : "on",\r\nai->config.nodeName,\r\nai->config.powerSaveMode == POWERSAVE_CAM ? "CAM" :\r\nai->config.powerSaveMode == POWERSAVE_PSP ? "PSP" :\r\nai->config.powerSaveMode == POWERSAVE_PSPCAM ? "PSPCAM" :\r\n"Error",\r\n(int)ai->config.rates[0],\r\n(int)ai->config.rates[1],\r\n(int)ai->config.rates[2],\r\n(int)ai->config.rates[3],\r\n(int)ai->config.rates[4],\r\n(int)ai->config.rates[5],\r\n(int)ai->config.rates[6],\r\n(int)ai->config.rates[7],\r\nle16_to_cpu(ai->config.channelSet),\r\nle16_to_cpu(ai->config.txPower)\r\n);\r\nsprintf( data->rbuffer + i,\r\n"LongRetryLimit: %d\n"\r\n"ShortRetryLimit: %d\n"\r\n"RTSThreshold: %d\n"\r\n"TXMSDULifetime: %d\n"\r\n"RXMSDULifetime: %d\n"\r\n"TXDiversity: %s\n"\r\n"RXDiversity: %s\n"\r\n"FragThreshold: %d\n"\r\n"WEP: %s\n"\r\n"Modulation: %s\n"\r\n"Preamble: %s\n",\r\nle16_to_cpu(ai->config.longRetryLimit),\r\nle16_to_cpu(ai->config.shortRetryLimit),\r\nle16_to_cpu(ai->config.rtsThres),\r\nle16_to_cpu(ai->config.txLifetime),\r\nle16_to_cpu(ai->config.rxLifetime),\r\nai->config.txDiversity == 1 ? "left" :\r\nai->config.txDiversity == 2 ? "right" : "both",\r\nai->config.rxDiversity == 1 ? "left" :\r\nai->config.rxDiversity == 2 ? "right" : "both",\r\nle16_to_cpu(ai->config.fragThresh),\r\nai->config.authType == AUTH_ENCRYPT ? "encrypt" :\r\nai->config.authType == AUTH_SHAREDKEY ? "shared" : "open",\r\nai->config.modulation == MOD_DEFAULT ? "default" :\r\nai->config.modulation == MOD_CCK ? "cck" :\r\nai->config.modulation == MOD_MOK ? "mok" : "error",\r\nai->config.preamble == PREAMBLE_AUTO ? "auto" :\r\nai->config.preamble == PREAMBLE_LONG ? "long" :\r\nai->config.preamble == PREAMBLE_SHORT ? "short" : "error"\r\n);\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic void proc_SSID_on_close(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_data *data = file->private_data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nSsidRid SSID_rid;\r\nint i;\r\nchar *p = data->wbuffer;\r\nchar *end = p + data->writelen;\r\nif (!data->writelen)\r\nreturn;\r\n*end = '\n';\r\nmemset(&SSID_rid, 0, sizeof(SSID_rid));\r\nfor (i = 0; i < 3 && p < end; i++) {\r\nint j = 0;\r\nwhile (*p != '\n' && j < 32)\r\nSSID_rid.ssids[i].ssid[j++] = *p++;\r\nif (j == 0)\r\nbreak;\r\nSSID_rid.ssids[i].len = cpu_to_le16(j);\r\nwhile (*p++ != '\n')\r\n;\r\n}\r\nif (i)\r\nSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\r\ndisable_MAC(ai, 1);\r\nwriteSsidRid(ai, &SSID_rid, 1);\r\nenable_MAC(ai, 1);\r\n}\r\nstatic void proc_APList_on_close( struct inode *inode, struct file *file ) {\r\nstruct proc_data *data = file->private_data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nAPListRid *APList_rid = &ai->APList;\r\nint i;\r\nif ( !data->writelen ) return;\r\nmemset(APList_rid, 0, sizeof(*APList_rid));\r\nAPList_rid->len = cpu_to_le16(sizeof(*APList_rid));\r\nfor (i = 0; i < 4 && data->writelen >= (i + 1) * 6 * 3; i++)\r\nmac_pton(data->wbuffer + i * 6 * 3, APList_rid->ap[i]);\r\ndisable_MAC(ai, 1);\r\nwriteAPListRid(ai, APList_rid, 1);\r\nenable_MAC(ai, 1);\r\n}\r\nstatic int do_writerid( struct airo_info *ai, u16 rid, const void *rid_data,\r\nint len, int dummy ) {\r\nint rc;\r\ndisable_MAC(ai, 1);\r\nrc = PC4500_writerid(ai, rid, rid_data, len, 1);\r\nenable_MAC(ai, 1);\r\nreturn rc;\r\n}\r\nstatic int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)\r\n{\r\nWepKeyRid wkr;\r\nint rc;\r\n__le16 lastindex;\r\nrc = readWepKeyRid(ai, &wkr, 1, 1);\r\nif (rc != SUCCESS)\r\nreturn -1;\r\ndo {\r\nlastindex = wkr.kindex;\r\nif (le16_to_cpu(wkr.kindex) == index) {\r\nint klen = min_t(int, buflen, le16_to_cpu(wkr.klen));\r\nmemcpy(buf, wkr.key, klen);\r\nreturn klen;\r\n}\r\nrc = readWepKeyRid(ai, &wkr, 0, 1);\r\nif (rc != SUCCESS)\r\nreturn -1;\r\n} while (lastindex != wkr.kindex);\r\nreturn -1;\r\n}\r\nstatic int get_wep_tx_idx(struct airo_info *ai)\r\n{\r\nWepKeyRid wkr;\r\nint rc;\r\n__le16 lastindex;\r\nrc = readWepKeyRid(ai, &wkr, 1, 1);\r\nif (rc != SUCCESS)\r\nreturn -1;\r\ndo {\r\nlastindex = wkr.kindex;\r\nif (wkr.kindex == cpu_to_le16(0xffff))\r\nreturn wkr.mac[0];\r\nrc = readWepKeyRid(ai, &wkr, 0, 1);\r\nif (rc != SUCCESS)\r\nreturn -1;\r\n} while (lastindex != wkr.kindex);\r\nreturn -1;\r\n}\r\nstatic int set_wep_key(struct airo_info *ai, u16 index, const char *key,\r\nu16 keylen, int perm, int lock)\r\n{\r\nstatic const unsigned char macaddr[ETH_ALEN] = { 0x01, 0, 0, 0, 0, 0 };\r\nWepKeyRid wkr;\r\nint rc;\r\nif (WARN_ON(keylen == 0))\r\nreturn -1;\r\nmemset(&wkr, 0, sizeof(wkr));\r\nwkr.len = cpu_to_le16(sizeof(wkr));\r\nwkr.kindex = cpu_to_le16(index);\r\nwkr.klen = cpu_to_le16(keylen);\r\nmemcpy(wkr.key, key, keylen);\r\nmemcpy(wkr.mac, macaddr, ETH_ALEN);\r\nif (perm) disable_MAC(ai, lock);\r\nrc = writeWepKeyRid(ai, &wkr, perm, lock);\r\nif (perm) enable_MAC(ai, lock);\r\nreturn rc;\r\n}\r\nstatic int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)\r\n{\r\nWepKeyRid wkr;\r\nint rc;\r\nmemset(&wkr, 0, sizeof(wkr));\r\nwkr.len = cpu_to_le16(sizeof(wkr));\r\nwkr.kindex = cpu_to_le16(0xffff);\r\nwkr.mac[0] = (char)index;\r\nif (perm) {\r\nai->defindex = (char)index;\r\ndisable_MAC(ai, lock);\r\n}\r\nrc = writeWepKeyRid(ai, &wkr, perm, lock);\r\nif (perm)\r\nenable_MAC(ai, lock);\r\nreturn rc;\r\n}\r\nstatic void proc_wepkey_on_close( struct inode *inode, struct file *file ) {\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nint i, rc;\r\nchar key[16];\r\nu16 index = 0;\r\nint j = 0;\r\nmemset(key, 0, sizeof(key));\r\ndata = file->private_data;\r\nif ( !data->writelen ) return;\r\nif (data->wbuffer[0] >= '0' && data->wbuffer[0] <= '3' &&\r\n(data->wbuffer[1] == ' ' || data->wbuffer[1] == '\n')) {\r\nindex = data->wbuffer[0] - '0';\r\nif (data->wbuffer[1] == '\n') {\r\nrc = set_wep_tx_idx(ai, index, 1, 1);\r\nif (rc < 0) {\r\nairo_print_err(ai->dev->name, "failed to set "\r\n"WEP transmit index to %d: %d.",\r\nindex, rc);\r\n}\r\nreturn;\r\n}\r\nj = 2;\r\n} else {\r\nairo_print_err(ai->dev->name, "WepKey passed invalid key index");\r\nreturn;\r\n}\r\nfor( i = 0; i < 16*3 && data->wbuffer[i+j]; i++ ) {\r\nswitch(i%3) {\r\ncase 0:\r\nkey[i/3] = hex_to_bin(data->wbuffer[i+j])<<4;\r\nbreak;\r\ncase 1:\r\nkey[i/3] |= hex_to_bin(data->wbuffer[i+j]);\r\nbreak;\r\n}\r\n}\r\nrc = set_wep_key(ai, index, key, i/3, 1, 1);\r\nif (rc < 0) {\r\nairo_print_err(ai->dev->name, "failed to set WEP key at index "\r\n"%d: %d.", index, rc);\r\n}\r\n}\r\nstatic int proc_wepkey_open( struct inode *inode, struct file *file )\r\n{\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nchar *ptr;\r\nWepKeyRid wkr;\r\n__le16 lastindex;\r\nint j=0;\r\nint rc;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nmemset(&wkr, 0, sizeof(wkr));\r\ndata = file->private_data;\r\nif ((data->rbuffer = kzalloc( 180, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->writelen = 0;\r\ndata->maxwritelen = 80;\r\nif ((data->wbuffer = kzalloc( 80, GFP_KERNEL )) == NULL) {\r\nkfree (data->rbuffer);\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->on_close = proc_wepkey_on_close;\r\nptr = data->rbuffer;\r\nstrcpy(ptr, "No wep keys\n");\r\nrc = readWepKeyRid(ai, &wkr, 1, 1);\r\nif (rc == SUCCESS) do {\r\nlastindex = wkr.kindex;\r\nif (wkr.kindex == cpu_to_le16(0xffff)) {\r\nj += sprintf(ptr+j, "Tx key = %d\n",\r\n(int)wkr.mac[0]);\r\n} else {\r\nj += sprintf(ptr+j, "Key %d set with length = %d\n",\r\nle16_to_cpu(wkr.kindex),\r\nle16_to_cpu(wkr.klen));\r\n}\r\nreadWepKeyRid(ai, &wkr, 0, 1);\r\n} while((lastindex != wkr.kindex) && (j < 180-30));\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic int proc_SSID_open(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nint i;\r\nchar *ptr;\r\nSsidRid SSID_rid;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->writelen = 0;\r\ndata->maxwritelen = 33*3;\r\nif ((data->wbuffer = kzalloc(33*3 + 1, GFP_KERNEL)) == NULL) {\r\nkfree (data->rbuffer);\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->on_close = proc_SSID_on_close;\r\nreadSsidRid(ai, &SSID_rid);\r\nptr = data->rbuffer;\r\nfor (i = 0; i < 3; i++) {\r\nint j;\r\nsize_t len = le16_to_cpu(SSID_rid.ssids[i].len);\r\nif (!len)\r\nbreak;\r\nif (len > 32)\r\nlen = 32;\r\nfor (j = 0; j < len && SSID_rid.ssids[i].ssid[j]; j++)\r\n*ptr++ = SSID_rid.ssids[i].ssid[j];\r\n*ptr++ = '\n';\r\n}\r\n*ptr = '\0';\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic int proc_APList_open( struct inode *inode, struct file *file ) {\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nint i;\r\nchar *ptr;\r\nAPListRid *APList_rid = &ai->APList;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->writelen = 0;\r\ndata->maxwritelen = 4*6*3;\r\nif ((data->wbuffer = kzalloc( data->maxwritelen, GFP_KERNEL )) == NULL) {\r\nkfree (data->rbuffer);\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->on_close = proc_APList_on_close;\r\nptr = data->rbuffer;\r\nfor( i = 0; i < 4; i++ ) {\r\nif ( !*(int*)APList_rid->ap[i] &&\r\n!*(int*)&APList_rid->ap[i][2]) break;\r\nptr += sprintf(ptr, "%pM\n", APList_rid->ap[i]);\r\n}\r\nif (i==0) ptr += sprintf(ptr, "Not using specific APs\n");\r\n*ptr = '\0';\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic int proc_BSSList_open( struct inode *inode, struct file *file ) {\r\nstruct proc_data *data;\r\nstruct net_device *dev = PDE_DATA(inode);\r\nstruct airo_info *ai = dev->ml_priv;\r\nchar *ptr;\r\nBSSListRid BSSList_rid;\r\nint rc;\r\nint doLoseSync = -1;\r\nif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndata = file->private_data;\r\nif ((data->rbuffer = kmalloc( 1024, GFP_KERNEL )) == NULL) {\r\nkfree (file->private_data);\r\nreturn -ENOMEM;\r\n}\r\ndata->writelen = 0;\r\ndata->maxwritelen = 0;\r\ndata->wbuffer = NULL;\r\ndata->on_close = NULL;\r\nif (file->f_mode & FMODE_WRITE) {\r\nif (!(file->f_mode & FMODE_READ)) {\r\nCmd cmd;\r\nResp rsp;\r\nif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd=CMD_LISTBSS;\r\nif (down_interruptible(&ai->sem))\r\nreturn -ERESTARTSYS;\r\nissuecommand(ai, &cmd, &rsp);\r\nup(&ai->sem);\r\ndata->readlen = 0;\r\nreturn 0;\r\n}\r\ndoLoseSync = 1;\r\n}\r\nptr = data->rbuffer;\r\nrc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\r\nwhile(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\r\nptr += sprintf(ptr, "%pM %*s rssi = %d",\r\nBSSList_rid.bssid,\r\n(int)BSSList_rid.ssidLen,\r\nBSSList_rid.ssid,\r\nle16_to_cpu(BSSList_rid.dBm));\r\nptr += sprintf(ptr, " channel = %d %s %s %s %s\n",\r\nle16_to_cpu(BSSList_rid.dsChannel),\r\nBSSList_rid.cap & CAP_ESS ? "ESS" : "",\r\nBSSList_rid.cap & CAP_IBSS ? "adhoc" : "",\r\nBSSList_rid.cap & CAP_PRIVACY ? "wep" : "",\r\nBSSList_rid.cap & CAP_SHORTHDR ? "shorthdr" : "");\r\nrc = readBSSListRid(ai, 0, &BSSList_rid);\r\n}\r\n*ptr = '\0';\r\ndata->readlen = strlen( data->rbuffer );\r\nreturn 0;\r\n}\r\nstatic int proc_close( struct inode *inode, struct file *file )\r\n{\r\nstruct proc_data *data = file->private_data;\r\nif (data->on_close != NULL)\r\ndata->on_close(inode, file);\r\nkfree(data->rbuffer);\r\nkfree(data->wbuffer);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void timer_func( struct net_device *dev ) {\r\nstruct airo_info *apriv = dev->ml_priv;\r\nreadConfigRid(apriv, 0);\r\ndisable_MAC(apriv, 0);\r\nswitch(apriv->config.authType) {\r\ncase AUTH_ENCRYPT:\r\napriv->config.authType = AUTH_OPEN;\r\nbreak;\r\ncase AUTH_SHAREDKEY:\r\nif (apriv->keyindex < auto_wep) {\r\nset_wep_tx_idx(apriv, apriv->keyindex, 0, 0);\r\napriv->config.authType = AUTH_SHAREDKEY;\r\napriv->keyindex++;\r\n} else {\r\napriv->keyindex = 0;\r\nset_wep_tx_idx(apriv, apriv->defindex, 0, 0);\r\napriv->config.authType = AUTH_ENCRYPT;\r\n}\r\nbreak;\r\ndefault:\r\napriv->config.authType = AUTH_SHAREDKEY;\r\n}\r\nset_bit (FLAG_COMMIT, &apriv->flags);\r\nwriteConfigRid(apriv, 0);\r\nenable_MAC(apriv, 0);\r\nup(&apriv->sem);\r\nclear_bit(JOB_AUTOWEP, &apriv->jobs);\r\napriv->expires = RUN_AT(HZ*3);\r\n}\r\nstatic int airo_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pent)\r\n{\r\nstruct net_device *dev;\r\nif (pci_enable_device(pdev))\r\nreturn -ENODEV;\r\npci_set_master(pdev);\r\nif (pdev->device == 0x5000 || pdev->device == 0xa504)\r\ndev = _init_airo_card(pdev->irq, pdev->resource[0].start, 0, pdev, &pdev->dev);\r\nelse\r\ndev = _init_airo_card(pdev->irq, pdev->resource[2].start, 0, pdev, &pdev->dev);\r\nif (!dev) {\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nreturn 0;\r\n}\r\nstatic void airo_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nairo_print_info(dev->name, "Unregistering...");\r\nstop_airo_card(dev, 1);\r\npci_disable_device(pdev);\r\n}\r\nstatic int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct airo_info *ai = dev->ml_priv;\r\nCmd cmd;\r\nResp rsp;\r\nif (!ai->SSID)\r\nai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);\r\nif (!ai->SSID)\r\nreturn -ENOMEM;\r\nreadSsidRid(ai, ai->SSID);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (down_interruptible(&ai->sem))\r\nreturn -EAGAIN;\r\ndisable_MAC(ai, 0);\r\nnetif_device_detach(dev);\r\nai->power = state;\r\ncmd.cmd = HOSTSLEEP;\r\nissuecommand(ai, &cmd, &rsp);\r\npci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int airo_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct airo_info *ai = dev->ml_priv;\r\npci_power_t prev_state = pdev->current_state;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nif (prev_state != PCI_D1) {\r\nreset_card(dev, 0);\r\nmpi_init_descriptors(ai);\r\nsetup_card(ai, dev->dev_addr, 0);\r\nclear_bit(FLAG_RADIO_OFF, &ai->flags);\r\nclear_bit(FLAG_PENDING_XMIT, &ai->flags);\r\n} else {\r\nOUT4500(ai, EVACK, EV_AWAKEN);\r\nOUT4500(ai, EVACK, EV_AWAKEN);\r\nmsleep(100);\r\n}\r\nset_bit(FLAG_COMMIT, &ai->flags);\r\ndisable_MAC(ai, 0);\r\nmsleep(200);\r\nif (ai->SSID) {\r\nwriteSsidRid(ai, ai->SSID, 0);\r\nkfree(ai->SSID);\r\nai->SSID = NULL;\r\n}\r\nwriteAPListRid(ai, &ai->APList, 0);\r\nwriteConfigRid(ai, 0);\r\nenable_MAC(ai, 0);\r\nai->power = PMSG_ON;\r\nnetif_device_attach(dev);\r\nnetif_wake_queue(dev);\r\nenable_interrupts(ai);\r\nup(&ai->sem);\r\nreturn 0;\r\n}\r\nstatic int __init airo_init_module( void )\r\n{\r\nint i;\r\nproc_kuid = make_kuid(&init_user_ns, proc_uid);\r\nproc_kgid = make_kgid(&init_user_ns, proc_gid);\r\nif (!uid_valid(proc_kuid) || !gid_valid(proc_kgid))\r\nreturn -EINVAL;\r\nairo_entry = proc_mkdir_mode("driver/aironet", airo_perm, NULL);\r\nif (airo_entry)\r\nproc_set_user(airo_entry, proc_kuid, proc_kgid);\r\nfor (i = 0; i < 4 && io[i] && irq[i]; i++) {\r\nairo_print_info("", "Trying to configure ISA adapter at irq=%d "\r\n"io=0x%x", irq[i], io[i] );\r\nif (init_airo_card( irq[i], io[i], 0, NULL ))\r\n;\r\n}\r\n#ifdef CONFIG_PCI\r\nairo_print_info("", "Probing for PCI adapters");\r\ni = pci_register_driver(&airo_driver);\r\nairo_print_info("", "Finished probing for PCI adapters");\r\nif (i) {\r\nremove_proc_entry("driver/aironet", NULL);\r\nreturn i;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit airo_cleanup_module( void )\r\n{\r\nstruct airo_info *ai;\r\nwhile(!list_empty(&airo_devices)) {\r\nai = list_entry(airo_devices.next, struct airo_info, dev_list);\r\nairo_print_info(ai->dev->name, "Unregistering...");\r\nstop_airo_card(ai->dev, 1);\r\n}\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&airo_driver);\r\n#endif\r\nremove_proc_entry("driver/aironet", NULL);\r\n}\r\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi)\r\n{\r\nif (!rssi_rid)\r\nreturn 0;\r\nreturn (0x100 - rssi_rid[rssi].rssidBm);\r\n}\r\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm)\r\n{\r\nint i;\r\nif (!rssi_rid)\r\nreturn 0;\r\nfor (i = 0; i < 256; i++)\r\nif (rssi_rid[i].rssidBm == dbm)\r\nreturn rssi_rid[i].rssipct;\r\nreturn 0;\r\n}\r\nstatic int airo_get_quality (StatusRid *status_rid, CapabilityRid *cap_rid)\r\n{\r\nint quality = 0;\r\nu16 sq;\r\nif ((status_rid->mode & cpu_to_le16(0x3f)) != cpu_to_le16(0x3f))\r\nreturn 0;\r\nif (!(cap_rid->hardCap & cpu_to_le16(8)))\r\nreturn 0;\r\nsq = le16_to_cpu(status_rid->signalQuality);\r\nif (memcmp(cap_rid->prodName, "350", 3))\r\nif (sq > 0x20)\r\nquality = 0;\r\nelse\r\nquality = 0x20 - sq;\r\nelse\r\nif (sq > 0xb0)\r\nquality = 0;\r\nelse if (sq < 0x10)\r\nquality = 0xa0;\r\nelse\r\nquality = 0xb0 - sq;\r\nreturn quality;\r\n}\r\nstatic int airo_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *cwrq,\r\nchar *extra)\r\n{\r\nstrcpy(cwrq, "IEEE 802.11-DS");\r\nreturn 0;\r\n}\r\nstatic int airo_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *fwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint rc = -EINPROGRESS;\r\nif(fwrq->e == 1) {\r\nint f = fwrq->m / 100000;\r\nfwrq->e = 0;\r\nfwrq->m = ieee80211_frequency_to_channel(f);\r\n}\r\nif (fwrq->m < 0 || fwrq->m > 1000 || fwrq->e > 0)\r\nrc = -EOPNOTSUPP;\r\nelse {\r\nint channel = fwrq->m;\r\nif((channel < 1) || (channel > 14)) {\r\nairo_print_dbg(dev->name, "New channel value of %d is invalid!",\r\nfwrq->m);\r\nrc = -EINVAL;\r\n} else {\r\nreadConfigRid(local, 1);\r\nlocal->config.channelSet = cpu_to_le16(channel);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int airo_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *fwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nStatusRid status_rid;\r\nint ch;\r\nreadConfigRid(local, 1);\r\nif ((local->config.opmode & MODE_CFG_MASK) == MODE_STA_ESS)\r\nstatus_rid.channel = local->config.channelSet;\r\nelse\r\nreadStatusRid(local, &status_rid, 1);\r\nch = le16_to_cpu(status_rid.channel);\r\nif((ch > 0) && (ch < 15)) {\r\nfwrq->m = 100000 *\r\nieee80211_channel_to_frequency(ch, NL80211_BAND_2GHZ);\r\nfwrq->e = 1;\r\n} else {\r\nfwrq->m = ch;\r\nfwrq->e = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nSsidRid SSID_rid;\r\nreadSsidRid(local, &SSID_rid);\r\nif (dwrq->flags == 0) {\r\nmemset(&SSID_rid, 0, sizeof(SSID_rid));\r\n} else {\r\nunsigned index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nif (dwrq->length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG ;\r\nif (index >= ARRAY_SIZE(SSID_rid.ssids))\r\nreturn -EINVAL;\r\nmemset(SSID_rid.ssids[index].ssid, 0,\r\nsizeof(SSID_rid.ssids[index].ssid));\r\nmemcpy(SSID_rid.ssids[index].ssid, extra, dwrq->length);\r\nSSID_rid.ssids[index].len = cpu_to_le16(dwrq->length);\r\n}\r\nSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\r\ndisable_MAC(local, 1);\r\nwriteSsidRid(local, &SSID_rid, 1);\r\nenable_MAC(local, 1);\r\nreturn 0;\r\n}\r\nstatic int airo_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nStatusRid status_rid;\r\nreadStatusRid(local, &status_rid, 1);\r\nmemcpy(extra, status_rid.SSID, le16_to_cpu(status_rid.SSIDlen));\r\ndwrq->length = le16_to_cpu(status_rid.SSIDlen);\r\ndwrq->flags = 1;\r\nreturn 0;\r\n}\r\nstatic int airo_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *awrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nCmd cmd;\r\nResp rsp;\r\nAPListRid *APList_rid = &local->APList;\r\nif (awrq->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nelse if (is_broadcast_ether_addr(awrq->sa_data) ||\r\nis_zero_ether_addr(awrq->sa_data)) {\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd=CMD_LOSE_SYNC;\r\nif (down_interruptible(&local->sem))\r\nreturn -ERESTARTSYS;\r\nissuecommand(local, &cmd, &rsp);\r\nup(&local->sem);\r\n} else {\r\nmemset(APList_rid, 0, sizeof(*APList_rid));\r\nAPList_rid->len = cpu_to_le16(sizeof(*APList_rid));\r\nmemcpy(APList_rid->ap[0], awrq->sa_data, ETH_ALEN);\r\ndisable_MAC(local, 1);\r\nwriteAPListRid(local, APList_rid, 1);\r\nenable_MAC(local, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *awrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nStatusRid status_rid;\r\nreadStatusRid(local, &status_rid, 1);\r\nmemcpy(awrq->sa_data, status_rid.bssid[0], ETH_ALEN);\r\nawrq->sa_family = ARPHRD_ETHER;\r\nreturn 0;\r\n}\r\nstatic int airo_set_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nif(dwrq->length > 16) {\r\nreturn -E2BIG;\r\n}\r\nreadConfigRid(local, 1);\r\nmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\r\nmemcpy(local->config.nodeName, extra, dwrq->length);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nstrncpy(extra, local->config.nodeName, 16);\r\nextra[16] = '\0';\r\ndwrq->length = strlen(extra);\r\nreturn 0;\r\n}\r\nstatic int airo_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nCapabilityRid cap_rid;\r\nu8 brate = 0;\r\nint i;\r\nreadCapabilityRid(local, &cap_rid, 1);\r\nif((vwrq->value < 8) && (vwrq->value >= 0)) {\r\nbrate = cap_rid.supportedRates[vwrq->value];\r\n} else {\r\nu8 normvalue = (u8) (vwrq->value/500000);\r\nfor(i = 0 ; i < 8 ; i++) {\r\nif(normvalue == cap_rid.supportedRates[i]) {\r\nbrate = normvalue;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(vwrq->value == -1) {\r\nfor(i = 0 ; i < 8 ; i++) {\r\nif(cap_rid.supportedRates[i] == 0)\r\nbreak;\r\n}\r\nif(i != 0)\r\nbrate = cap_rid.supportedRates[i - 1];\r\n}\r\nif(brate == 0) {\r\nreturn -EINVAL;\r\n}\r\nreadConfigRid(local, 1);\r\nif(vwrq->fixed == 0) {\r\nmemset(local->config.rates, 0, 8);\r\nfor(i = 0 ; i < 8 ; i++) {\r\nlocal->config.rates[i] = cap_rid.supportedRates[i];\r\nif(local->config.rates[i] == brate)\r\nbreak;\r\n}\r\n} else {\r\nmemset(local->config.rates, 0, 8);\r\nlocal->config.rates[0] = brate;\r\n}\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nStatusRid status_rid;\r\nreadStatusRid(local, &status_rid, 1);\r\nvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\r\nreadConfigRid(local, 1);\r\nvwrq->fixed = (local->config.rates[1] == 0);\r\nreturn 0;\r\n}\r\nstatic int airo_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint rthr = vwrq->value;\r\nif(vwrq->disabled)\r\nrthr = AIRO_DEF_MTU;\r\nif((rthr < 0) || (rthr > AIRO_DEF_MTU)) {\r\nreturn -EINVAL;\r\n}\r\nreadConfigRid(local, 1);\r\nlocal->config.rtsThres = cpu_to_le16(rthr);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nvwrq->value = le16_to_cpu(local->config.rtsThres);\r\nvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\r\nvwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int airo_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint fthr = vwrq->value;\r\nif(vwrq->disabled)\r\nfthr = AIRO_DEF_MTU;\r\nif((fthr < 256) || (fthr > AIRO_DEF_MTU)) {\r\nreturn -EINVAL;\r\n}\r\nfthr &= ~0x1;\r\nreadConfigRid(local, 1);\r\nlocal->config.fragThresh = cpu_to_le16(fthr);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nvwrq->value = le16_to_cpu(local->config.fragThresh);\r\nvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\r\nvwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int airo_set_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *uwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint reset = 0;\r\nreadConfigRid(local, 1);\r\nif (sniffing_mode(local))\r\nreset = 1;\r\nswitch(*uwrq) {\r\ncase IW_MODE_ADHOC:\r\nlocal->config.opmode &= ~MODE_CFG_MASK;\r\nlocal->config.opmode |= MODE_STA_IBSS;\r\nlocal->config.rmode &= ~RXMODE_FULL_MASK;\r\nlocal->config.scanMode = SCANMODE_ACTIVE;\r\nclear_bit (FLAG_802_11, &local->flags);\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nlocal->config.opmode &= ~MODE_CFG_MASK;\r\nlocal->config.opmode |= MODE_STA_ESS;\r\nlocal->config.rmode &= ~RXMODE_FULL_MASK;\r\nlocal->config.scanMode = SCANMODE_ACTIVE;\r\nclear_bit (FLAG_802_11, &local->flags);\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nlocal->config.opmode &= ~MODE_CFG_MASK;\r\nlocal->config.opmode |= MODE_AP;\r\nlocal->config.rmode &= ~RXMODE_FULL_MASK;\r\nlocal->config.scanMode = SCANMODE_ACTIVE;\r\nclear_bit (FLAG_802_11, &local->flags);\r\nbreak;\r\ncase IW_MODE_REPEAT:\r\nlocal->config.opmode &= ~MODE_CFG_MASK;\r\nlocal->config.opmode |= MODE_AP_RPTR;\r\nlocal->config.rmode &= ~RXMODE_FULL_MASK;\r\nlocal->config.scanMode = SCANMODE_ACTIVE;\r\nclear_bit (FLAG_802_11, &local->flags);\r\nbreak;\r\ncase IW_MODE_MONITOR:\r\nlocal->config.opmode &= ~MODE_CFG_MASK;\r\nlocal->config.opmode |= MODE_STA_ESS;\r\nlocal->config.rmode &= ~RXMODE_FULL_MASK;\r\nlocal->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\r\nlocal->config.scanMode = SCANMODE_PASSIVE;\r\nset_bit (FLAG_802_11, &local->flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (reset)\r\nset_bit (FLAG_RESET, &local->flags);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *uwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nswitch (local->config.opmode & MODE_CFG_MASK) {\r\ncase MODE_STA_ESS:\r\n*uwrq = IW_MODE_INFRA;\r\nbreak;\r\ncase MODE_AP:\r\n*uwrq = IW_MODE_MASTER;\r\nbreak;\r\ncase MODE_AP_RPTR:\r\n*uwrq = IW_MODE_REPEAT;\r\nbreak;\r\ndefault:\r\n*uwrq = IW_MODE_ADHOC;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int valid_index(struct airo_info *ai, int index)\r\n{\r\nreturn (index >= 0) && (index <= ai->max_wep_idx);\r\n}\r\nstatic int airo_set_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint perm = (dwrq->flags & IW_ENCODE_TEMP ? 0 : 1);\r\n__le16 currentAuthType = local->config.authType;\r\nint rc = 0;\r\nif (!local->wep_capable)\r\nreturn -EOPNOTSUPP;\r\nreadConfigRid(local, 1);\r\nif (dwrq->length > 0) {\r\nwep_key_t key;\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nint current_index;\r\nif (dwrq->length > MAX_KEY_SIZE) {\r\nreturn -EINVAL;\r\n}\r\ncurrent_index = get_wep_tx_idx(local);\r\nif (current_index < 0)\r\ncurrent_index = 0;\r\nif (!valid_index(local, index))\r\nindex = current_index;\r\nif (dwrq->length > MIN_KEY_SIZE)\r\nkey.len = MAX_KEY_SIZE;\r\nelse\r\nkey.len = MIN_KEY_SIZE;\r\nif(!(dwrq->flags & IW_ENCODE_NOKEY)) {\r\nmemset(key.key, 0, MAX_KEY_SIZE);\r\nmemcpy(key.key, extra, dwrq->length);\r\nrc = set_wep_key(local, index, key.key, key.len, perm, 1);\r\nif (rc < 0) {\r\nairo_print_err(local->dev->name, "failed to set"\r\n" WEP key at index %d: %d.",\r\nindex, rc);\r\nreturn rc;\r\n}\r\n}\r\nif((index == current_index) && (key.len > 0) &&\r\n(local->config.authType == AUTH_OPEN))\r\nset_auth_type(local, AUTH_ENCRYPT);\r\n} else {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nif (valid_index(local, index)) {\r\nrc = set_wep_tx_idx(local, index, perm, 1);\r\nif (rc < 0) {\r\nairo_print_err(local->dev->name, "failed to set"\r\n" WEP transmit index to %d: %d.",\r\nindex, rc);\r\nreturn rc;\r\n}\r\n} else {\r\nif (!(dwrq->flags & IW_ENCODE_MODE))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dwrq->flags & IW_ENCODE_DISABLED)\r\nset_auth_type(local, AUTH_OPEN);\r\nif(dwrq->flags & IW_ENCODE_RESTRICTED)\r\nset_auth_type(local, AUTH_SHAREDKEY);\r\nif (dwrq->flags & IW_ENCODE_OPEN)\r\nset_auth_type(local, AUTH_ENCRYPT);\r\nif (local->config.authType != currentAuthType)\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nint wep_key_len;\r\nu8 buf[16];\r\nif (!local->wep_capable)\r\nreturn -EOPNOTSUPP;\r\nreadConfigRid(local, 1);\r\nswitch(local->config.authType) {\r\ncase AUTH_ENCRYPT:\r\ndwrq->flags = IW_ENCODE_OPEN;\r\nbreak;\r\ncase AUTH_SHAREDKEY:\r\ndwrq->flags = IW_ENCODE_RESTRICTED;\r\nbreak;\r\ndefault:\r\ncase AUTH_OPEN:\r\ndwrq->flags = IW_ENCODE_DISABLED;\r\nbreak;\r\n}\r\ndwrq->flags |= IW_ENCODE_NOKEY;\r\nmemset(extra, 0, 16);\r\nif (!valid_index(local, index)) {\r\nindex = get_wep_tx_idx(local);\r\nif (index < 0)\r\nindex = 0;\r\n}\r\ndwrq->flags |= index + 1;\r\nwep_key_len = get_wep_key(local, index, &buf[0], sizeof(buf));\r\nif (wep_key_len < 0) {\r\ndwrq->length = 0;\r\n} else {\r\ndwrq->length = wep_key_len;\r\nmemcpy(extra, buf, dwrq->length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_set_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint perm = ( encoding->flags & IW_ENCODE_TEMP ? 0 : 1 );\r\n__le16 currentAuthType = local->config.authType;\r\nint idx, key_len, alg = ext->alg, set_key = 1, rc;\r\nwep_key_t key;\r\nif (!local->wep_capable)\r\nreturn -EOPNOTSUPP;\r\nreadConfigRid(local, 1);\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (!valid_index(local, idx - 1))\r\nreturn -EINVAL;\r\nidx--;\r\n} else {\r\nidx = get_wep_tx_idx(local);\r\nif (idx < 0)\r\nidx = 0;\r\n}\r\nif (encoding->flags & IW_ENCODE_DISABLED)\r\nalg = IW_ENCODE_ALG_NONE;\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nrc = set_wep_tx_idx(local, idx, perm, 1);\r\nif (rc < 0) {\r\nairo_print_err(local->dev->name, "failed to set "\r\n"WEP transmit index to %d: %d.",\r\nidx, rc);\r\nreturn rc;\r\n}\r\nset_key = ext->key_len > 0 ? 1 : 0;\r\n}\r\nif (set_key) {\r\nmemset(key.key, 0, MAX_KEY_SIZE);\r\nswitch (alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nkey.len = 0;\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nif (ext->key_len > MIN_KEY_SIZE) {\r\nkey.len = MAX_KEY_SIZE;\r\n} else if (ext->key_len > 0) {\r\nkey.len = MIN_KEY_SIZE;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nkey_len = min (ext->key_len, key.len);\r\nmemcpy(key.key, ext->key, key_len);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (key.len == 0) {\r\nrc = set_wep_tx_idx(local, idx, perm, 1);\r\nif (rc < 0) {\r\nairo_print_err(local->dev->name,\r\n"failed to set WEP transmit index to %d: %d.",\r\nidx, rc);\r\nreturn rc;\r\n}\r\n} else {\r\nrc = set_wep_key(local, idx, key.key, key.len, perm, 1);\r\nif (rc < 0) {\r\nairo_print_err(local->dev->name,\r\n"failed to set WEP key at index %d: %d.",\r\nidx, rc);\r\nreturn rc;\r\n}\r\n}\r\n}\r\nif (encoding->flags & IW_ENCODE_DISABLED)\r\nset_auth_type(local, AUTH_OPEN);\r\nif(encoding->flags & IW_ENCODE_RESTRICTED)\r\nset_auth_type(local, AUTH_SHAREDKEY);\r\nif (encoding->flags & IW_ENCODE_OPEN)\r\nset_auth_type(local, AUTH_ENCRYPT);\r\nif (local->config.authType != currentAuthType)\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, max_key_len, wep_key_len;\r\nu8 buf[16];\r\nif (!local->wep_capable)\r\nreturn -EOPNOTSUPP;\r\nreadConfigRid(local, 1);\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (!valid_index(local, idx - 1))\r\nreturn -EINVAL;\r\nidx--;\r\n} else {\r\nidx = get_wep_tx_idx(local);\r\nif (idx < 0)\r\nidx = 0;\r\n}\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nswitch(local->config.authType) {\r\ncase AUTH_ENCRYPT:\r\nencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\r\nbreak;\r\ncase AUTH_SHAREDKEY:\r\nencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\r\nbreak;\r\ndefault:\r\ncase AUTH_OPEN:\r\nencoding->flags = IW_ENCODE_ALG_NONE | IW_ENCODE_DISABLED;\r\nbreak;\r\n}\r\nencoding->flags |= IW_ENCODE_NOKEY;\r\nmemset(extra, 0, 16);\r\nwep_key_len = get_wep_key(local, idx, &buf[0], sizeof(buf));\r\nif (wep_key_len < 0) {\r\next->key_len = 0;\r\n} else {\r\next->key_len = wep_key_len;\r\nmemcpy(extra, buf, ext->key_len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct iw_param *param = &wrqu->param;\r\n__le16 currentAuthType = local->config.authType;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nif (param->value) {\r\nif (currentAuthType == AUTH_OPEN)\r\nset_auth_type(local, AUTH_ENCRYPT);\r\n} else {\r\nset_auth_type(local, AUTH_OPEN);\r\n}\r\nif (local->config.authType != currentAuthType)\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG: {\r\nif (param->value & IW_AUTH_ALG_SHARED_KEY) {\r\nset_auth_type(local, AUTH_SHAREDKEY);\r\n} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nset_auth_type(local, local->last_auth);\r\n} else\r\nreturn -EINVAL;\r\nif (local->config.authType != currentAuthType)\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nbreak;\r\n}\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (param->value > 0)\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct iw_param *param = &wrqu->param;\r\n__le16 currentAuthType = local->config.authType;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nswitch (currentAuthType) {\r\ncase AUTH_SHAREDKEY:\r\ncase AUTH_ENCRYPT:\r\nparam->value = 1;\r\nbreak;\r\ndefault:\r\nparam->value = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nswitch (currentAuthType) {\r\ncase AUTH_SHAREDKEY:\r\nparam->value = IW_AUTH_ALG_SHARED_KEY;\r\nbreak;\r\ncase AUTH_ENCRYPT:\r\ndefault:\r\nparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\r\nbreak;\r\n}\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = 0;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_set_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nCapabilityRid cap_rid;\r\nint i;\r\nint rc = -EINVAL;\r\n__le16 v = cpu_to_le16(vwrq->value);\r\nreadCapabilityRid(local, &cap_rid, 1);\r\nif (vwrq->disabled) {\r\nset_bit (FLAG_RADIO_OFF, &local->flags);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nif (vwrq->flags != IW_TXPOW_MWATT) {\r\nreturn -EINVAL;\r\n}\r\nclear_bit (FLAG_RADIO_OFF, &local->flags);\r\nfor (i = 0; i < 8 && cap_rid.txPowerLevels[i]; i++)\r\nif (v == cap_rid.txPowerLevels[i]) {\r\nreadConfigRid(local, 1);\r\nlocal->config.txPower = v;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nrc = -EINPROGRESS;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int airo_get_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nvwrq->value = le16_to_cpu(local->config.txPower);\r\nvwrq->fixed = 1;\r\nvwrq->disabled = test_bit(FLAG_RADIO_OFF, &local->flags);\r\nvwrq->flags = IW_TXPOW_MWATT;\r\nreturn 0;\r\n}\r\nstatic int airo_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nint rc = -EINVAL;\r\nif(vwrq->disabled) {\r\nreturn -EINVAL;\r\n}\r\nreadConfigRid(local, 1);\r\nif(vwrq->flags & IW_RETRY_LIMIT) {\r\n__le16 v = cpu_to_le16(vwrq->value);\r\nif(vwrq->flags & IW_RETRY_LONG)\r\nlocal->config.longRetryLimit = v;\r\nelse if (vwrq->flags & IW_RETRY_SHORT)\r\nlocal->config.shortRetryLimit = v;\r\nelse {\r\nlocal->config.longRetryLimit = v;\r\nlocal->config.shortRetryLimit = v;\r\n}\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nrc = -EINPROGRESS;\r\n}\r\nif(vwrq->flags & IW_RETRY_LIFETIME) {\r\nlocal->config.txLifetime = cpu_to_le16(vwrq->value / 1024);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nrc = -EINPROGRESS;\r\n}\r\nreturn rc;\r\n}\r\nstatic int airo_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nvwrq->disabled = 0;\r\nreadConfigRid(local, 1);\r\nif((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\r\nvwrq->flags = IW_RETRY_LIFETIME;\r\nvwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\r\n} else if((vwrq->flags & IW_RETRY_LONG)) {\r\nvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nvwrq->value = le16_to_cpu(local->config.longRetryLimit);\r\n} else {\r\nvwrq->flags = IW_RETRY_LIMIT;\r\nvwrq->value = le16_to_cpu(local->config.shortRetryLimit);\r\nif(local->config.shortRetryLimit != local->config.longRetryLimit)\r\nvwrq->flags |= IW_RETRY_SHORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int airo_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nCapabilityRid cap_rid;\r\nint i;\r\nint k;\r\nreadCapabilityRid(local, &cap_rid, 1);\r\ndwrq->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->min_nwid = 0x0000;\r\nrange->max_nwid = 0x0000;\r\nrange->num_channels = 14;\r\nk = 0;\r\nfor(i = 0; i < 14; i++) {\r\nrange->freq[k].i = i + 1;\r\nrange->freq[k].m = 100000 *\r\nieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ);\r\nrange->freq[k++].e = 1;\r\n}\r\nrange->num_frequency = k;\r\nrange->sensitivity = 65535;\r\nif (local->rssi)\r\nrange->max_qual.qual = 100;\r\nelse\r\nrange->max_qual.qual = airo_get_max_quality(&cap_rid);\r\nrange->max_qual.level = 0x100 - 120;\r\nrange->max_qual.noise = 0x100 - 120;\r\nif (local->rssi) {\r\nrange->avg_qual.qual = 50;\r\nrange->avg_qual.level = 0x100 - 70;\r\n} else {\r\nrange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\r\nrange->avg_qual.level = 0x100 - 80;\r\n}\r\nrange->avg_qual.noise = 0x100 - 85;\r\nfor(i = 0 ; i < 8 ; i++) {\r\nrange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\r\nif(range->bitrate[i] == 0)\r\nbreak;\r\n}\r\nrange->num_bitrates = i;\r\nif(i > 2)\r\nrange->throughput = 5000 * 1000;\r\nelse\r\nrange->throughput = 1500 * 1000;\r\nrange->min_rts = 0;\r\nrange->max_rts = AIRO_DEF_MTU;\r\nrange->min_frag = 256;\r\nrange->max_frag = AIRO_DEF_MTU;\r\nif(cap_rid.softCap & cpu_to_le16(2)) {\r\nrange->encoding_size[0] = 5;\r\nif (cap_rid.softCap & cpu_to_le16(0x100)) {\r\nrange->encoding_size[1] = 13;\r\nrange->num_encoding_sizes = 2;\r\n} else\r\nrange->num_encoding_sizes = 1;\r\nrange->max_encoding_tokens =\r\ncap_rid.softCap & cpu_to_le16(0x80) ? 4 : 1;\r\n} else {\r\nrange->num_encoding_sizes = 0;\r\nrange->max_encoding_tokens = 0;\r\n}\r\nrange->min_pmp = 0;\r\nrange->max_pmp = 5000000;\r\nrange->min_pmt = 0;\r\nrange->max_pmt = 65535 * 1024;\r\nrange->pmp_flags = IW_POWER_PERIOD;\r\nrange->pmt_flags = IW_POWER_TIMEOUT;\r\nrange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\r\nfor(i = 0 ; i < 8 ; i++) {\r\nrange->txpower[i] = le16_to_cpu(cap_rid.txPowerLevels[i]);\r\nif(range->txpower[i] == 0)\r\nbreak;\r\n}\r\nrange->num_txpower = i;\r\nrange->txpower_capa = IW_TXPOW_MWATT;\r\nrange->we_version_source = 19;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->r_time_flags = IW_RETRY_LIFETIME;\r\nrange->min_retry = 1;\r\nrange->max_retry = 65535;\r\nrange->min_r_time = 1024;\r\nrange->max_r_time = 65535 * 1024;\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->event_capa[4] = IW_EVENT_CAPA_MASK(IWEVTXDROP);\r\nreturn 0;\r\n}\r\nstatic int airo_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nif (vwrq->disabled) {\r\nif (sniffing_mode(local))\r\nreturn -EINVAL;\r\nlocal->config.powerSaveMode = POWERSAVE_CAM;\r\nlocal->config.rmode &= ~RXMODE_MASK;\r\nlocal->config.rmode |= RXMODE_BC_MC_ADDR;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\nlocal->config.fastListenDelay = cpu_to_le16((vwrq->value + 500) / 1024);\r\nlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\n} else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {\r\nlocal->config.fastListenInterval =\r\nlocal->config.listenInterval =\r\ncpu_to_le16((vwrq->value + 500) / 1024);\r\nlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\n}\r\nswitch (vwrq->flags & IW_POWER_MODE) {\r\ncase IW_POWER_UNICAST_R:\r\nif (sniffing_mode(local))\r\nreturn -EINVAL;\r\nlocal->config.rmode &= ~RXMODE_MASK;\r\nlocal->config.rmode |= RXMODE_ADDR;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nbreak;\r\ncase IW_POWER_ALL_R:\r\nif (sniffing_mode(local))\r\nreturn -EINVAL;\r\nlocal->config.rmode &= ~RXMODE_MASK;\r\nlocal->config.rmode |= RXMODE_BC_MC_ADDR;\r\nset_bit (FLAG_COMMIT, &local->flags);\r\ncase IW_POWER_ON:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\n__le16 mode;\r\nreadConfigRid(local, 1);\r\nmode = local->config.powerSaveMode;\r\nif ((vwrq->disabled = (mode == POWERSAVE_CAM)))\r\nreturn 0;\r\nif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\nvwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;\r\nvwrq->flags = IW_POWER_TIMEOUT;\r\n} else {\r\nvwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;\r\nvwrq->flags = IW_POWER_PERIOD;\r\n}\r\nif ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)\r\nvwrq->flags |= IW_POWER_UNICAST_R;\r\nelse\r\nvwrq->flags |= IW_POWER_ALL_R;\r\nreturn 0;\r\n}\r\nstatic int airo_set_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nlocal->config.rssiThreshold =\r\ncpu_to_le16(vwrq->disabled ? RSSI_DEFAULT : vwrq->value);\r\nset_bit (FLAG_COMMIT, &local->flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int airo_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nreadConfigRid(local, 1);\r\nvwrq->value = le16_to_cpu(local->config.rssiThreshold);\r\nvwrq->disabled = (vwrq->value == 0);\r\nvwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int airo_get_aplist(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nstruct sockaddr *address = (struct sockaddr *) extra;\r\nstruct iw_quality *qual;\r\nBSSListRid BSSList;\r\nint i;\r\nint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\r\nqual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);\r\nif (!qual)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IW_MAX_AP; i++) {\r\nu16 dBm;\r\nif (readBSSListRid(local, loseSync, &BSSList))\r\nbreak;\r\nloseSync = 0;\r\nmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\r\naddress[i].sa_family = ARPHRD_ETHER;\r\ndBm = le16_to_cpu(BSSList.dBm);\r\nif (local->rssi) {\r\nqual[i].level = 0x100 - dBm;\r\nqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\r\nqual[i].updated = IW_QUAL_QUAL_UPDATED\r\n| IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_DBM;\r\n} else {\r\nqual[i].level = (dBm + 321) / 2;\r\nqual[i].qual = 0;\r\nqual[i].updated = IW_QUAL_QUAL_INVALID\r\n| IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_DBM;\r\n}\r\nqual[i].noise = local->wstats.qual.noise;\r\nif (BSSList.index == cpu_to_le16(0xffff))\r\nbreak;\r\n}\r\nif (!i) {\r\nStatusRid status_rid;\r\nreadStatusRid(local, &status_rid, 1);\r\nfor (i = 0;\r\ni < min(IW_MAX_AP, 4) &&\r\n(status_rid.bssid[i][0]\r\n& status_rid.bssid[i][1]\r\n& status_rid.bssid[i][2]\r\n& status_rid.bssid[i][3]\r\n& status_rid.bssid[i][4]\r\n& status_rid.bssid[i][5])!=0xff &&\r\n(status_rid.bssid[i][0]\r\n| status_rid.bssid[i][1]\r\n| status_rid.bssid[i][2]\r\n| status_rid.bssid[i][3]\r\n| status_rid.bssid[i][4]\r\n| status_rid.bssid[i][5]);\r\ni++) {\r\nmemcpy(address[i].sa_data,\r\nstatus_rid.bssid[i], ETH_ALEN);\r\naddress[i].sa_family = ARPHRD_ETHER;\r\n}\r\n} else {\r\ndwrq->flags = 1;\r\nmemcpy(extra + sizeof(struct sockaddr) * i, qual,\r\nsizeof(struct iw_quality) * i);\r\n}\r\ndwrq->length = i;\r\nkfree(qual);\r\nreturn 0;\r\n}\r\nstatic int airo_set_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nCmd cmd;\r\nResp rsp;\r\nint wake = 0;\r\nAPListRid APList_rid_empty;\r\nif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\r\nif (down_interruptible(&ai->sem))\r\nreturn -ERESTARTSYS;\r\nif (ai->scan_timeout > 0)\r\ngoto out;\r\nmemset(&APList_rid_empty, 0, sizeof(APList_rid_empty));\r\nAPList_rid_empty.len = cpu_to_le16(sizeof(APList_rid_empty));\r\ndisable_MAC(ai, 2);\r\nwriteAPListRid(ai, &APList_rid_empty, 0);\r\nenable_MAC(ai, 0);\r\nai->scan_timeout = RUN_AT(3*HZ);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.cmd=CMD_LISTBSS;\r\nissuecommand(ai, &cmd, &rsp);\r\nwake = 1;\r\nout:\r\nup(&ai->sem);\r\nif (wake)\r\nwake_up_interruptible(&ai->thr_wait);\r\nreturn 0;\r\n}\r\nstatic inline char *airo_translate_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *current_ev,\r\nchar *end_buf,\r\nBSSListRid *bss)\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nstruct iw_event iwe;\r\n__le16 capabilities;\r\nchar * current_val;\r\nint i;\r\nchar * buf;\r\nu16 dBm;\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, bss->bssid, ETH_ALEN);\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.u.data.length = bss->ssidLen;\r\nif(iwe.u.data.length > 32)\r\niwe.u.data.length = 32;\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, bss->ssid);\r\niwe.cmd = SIOCGIWMODE;\r\ncapabilities = bss->cap;\r\nif(capabilities & (CAP_ESS | CAP_IBSS)) {\r\nif(capabilities & CAP_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_UINT_LEN);\r\n}\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = le16_to_cpu(bss->dsChannel);\r\niwe.u.freq.m = 100000 *\r\nieee80211_channel_to_frequency(iwe.u.freq.m, NL80211_BAND_2GHZ);\r\niwe.u.freq.e = 1;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_FREQ_LEN);\r\ndBm = le16_to_cpu(bss->dBm);\r\niwe.cmd = IWEVQUAL;\r\nif (ai->rssi) {\r\niwe.u.qual.level = 0x100 - dBm;\r\niwe.u.qual.qual = airo_dbm_to_pct(ai->rssi, dBm);\r\niwe.u.qual.updated = IW_QUAL_QUAL_UPDATED\r\n| IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_DBM;\r\n} else {\r\niwe.u.qual.level = (dBm + 321) / 2;\r\niwe.u.qual.qual = 0;\r\niwe.u.qual.updated = IW_QUAL_QUAL_INVALID\r\n| IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_DBM;\r\n}\r\niwe.u.qual.noise = ai->wstats.qual.noise;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_QUAL_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif(capabilities & CAP_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, bss->ssid);\r\ncurrent_val = current_ev + iwe_stream_lcp_len(info);\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\nfor(i = 0 ; i < 8 ; i++) {\r\nif(bss->rates[i] == 0)\r\nbreak;\r\niwe.u.bitrate.value = ((bss->rates[i] & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(info, current_ev,\r\ncurrent_val, end_buf,\r\n&iwe, IW_EV_PARAM_LEN);\r\n}\r\nif ((current_val - current_ev) > iwe_stream_lcp_len(info))\r\ncurrent_ev = current_val;\r\nbuf = kmalloc(30, GFP_KERNEL);\r\nif (buf) {\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "bcn_int=%d", bss->beaconInterval);\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, buf);\r\nkfree(buf);\r\n}\r\nif (test_bit(FLAG_WPA_CAPABLE, &ai->flags)) {\r\nunsigned int num_null_ies = 0;\r\nu16 length = sizeof (bss->extra.iep);\r\nu8 *ie = (void *)&bss->extra.iep;\r\nwhile ((length >= 2) && (num_null_ies < 2)) {\r\nif (2 + ie[1] > length) {\r\nbreak;\r\n}\r\nswitch (ie[0]) {\r\ncase WLAN_EID_SSID:\r\nif (!ie[1])\r\nnum_null_ies++;\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nif (ie[1] >= 4 &&\r\nie[2] == 0x00 &&\r\nie[3] == 0x50 &&\r\nie[4] == 0xf2 &&\r\nie[5] == 0x01) {\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = min(ie[1] + 2,\r\n64);\r\ncurrent_ev = iwe_stream_add_point(\r\ninfo, current_ev,\r\nend_buf, &iwe, ie);\r\n}\r\nbreak;\r\ncase WLAN_EID_RSN:\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = min(ie[1] + 2, 64);\r\ncurrent_ev = iwe_stream_add_point(\r\ninfo, current_ev, end_buf,\r\n&iwe, ie);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlength -= 2 + ie[1];\r\nie += 2 + ie[1];\r\n}\r\n}\r\nreturn current_ev;\r\n}\r\nstatic int airo_get_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *dwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *ai = dev->ml_priv;\r\nBSSListElement *net;\r\nint err = 0;\r\nchar *current_ev = extra;\r\nif (ai->scan_timeout > 0)\r\nreturn -EAGAIN;\r\nif (down_interruptible(&ai->sem))\r\nreturn -EAGAIN;\r\nlist_for_each_entry (net, &ai->network_list, list) {\r\ncurrent_ev = airo_translate_scan(dev, info, current_ev,\r\nextra + dwrq->length,\r\n&net->bss);\r\nif((extra + dwrq->length - current_ev) <= IW_EV_ADDR_LEN) {\r\nerr = -E2BIG;\r\ngoto out;\r\n}\r\n}\r\ndwrq->length = (current_ev - extra);\r\ndwrq->flags = 0;\r\nout:\r\nup(&ai->sem);\r\nreturn err;\r\n}\r\nstatic int airo_config_commit(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *zwrq,\r\nchar *extra)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nif (!test_bit (FLAG_COMMIT, &local->flags))\r\nreturn 0;\r\ndisable_MAC(local, 1);\r\nif (test_bit (FLAG_RESET, &local->flags)) {\r\nSsidRid SSID_rid;\r\nreadSsidRid(local, &SSID_rid);\r\nif (test_bit(FLAG_MPI,&local->flags))\r\nsetup_card(local, dev->dev_addr, 1 );\r\nelse\r\nreset_airo_card(dev);\r\ndisable_MAC(local, 1);\r\nwriteSsidRid(local, &SSID_rid, 1);\r\nwriteAPListRid(local, &local->APList, 1);\r\n}\r\nif (down_interruptible(&local->sem))\r\nreturn -ERESTARTSYS;\r\nwriteConfigRid(local, 0);\r\nenable_MAC(local, 0);\r\nif (test_bit (FLAG_RESET, &local->flags))\r\nairo_set_promisc(local);\r\nelse\r\nup(&local->sem);\r\nreturn 0;\r\n}\r\nstatic int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nint rc = 0;\r\nstruct airo_info *ai = dev->ml_priv;\r\nif (ai->power.event)\r\nreturn 0;\r\nswitch (cmd) {\r\n#ifdef CISCO_EXT\r\ncase AIROIDIFC:\r\n#ifdef AIROOLDIDIFC\r\ncase AIROOLDIDIFC:\r\n#endif\r\n{\r\nint val = AIROMAGIC;\r\naironet_ioctl com;\r\nif (copy_from_user(&com,rq->ifr_data,sizeof(com)))\r\nrc = -EFAULT;\r\nelse if (copy_to_user(com.data,(char *)&val,sizeof(val)))\r\nrc = -EFAULT;\r\n}\r\nbreak;\r\ncase AIROIOCTL:\r\n#ifdef AIROOLDIOCTL\r\ncase AIROOLDIOCTL:\r\n#endif\r\n{\r\naironet_ioctl com;\r\nif (copy_from_user(&com,rq->ifr_data,sizeof(com))) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nif ( com.command == AIRORSWVERSION ) {\r\nif (copy_to_user(com.data, swversion, sizeof(swversion)))\r\nrc = -EFAULT;\r\nelse\r\nrc = 0;\r\n}\r\nelse if ( com.command <= AIRORRID)\r\nrc = readrids(dev,&com);\r\nelse if ( com.command >= AIROPCAP && com.command <= (AIROPLEAPUSR+2) )\r\nrc = writerids(dev,&com);\r\nelse if ( com.command >= AIROFLSHRST && com.command <= AIRORESTART )\r\nrc = flashcard(dev,&com);\r\nelse\r\nrc = -EINVAL;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn rc;\r\n}\r\nstatic void airo_read_wireless_stats(struct airo_info *local)\r\n{\r\nStatusRid status_rid;\r\nStatsRid stats_rid;\r\nCapabilityRid cap_rid;\r\n__le32 *vals = stats_rid.vals;\r\nclear_bit(JOB_WSTATS, &local->jobs);\r\nif (local->power.event) {\r\nup(&local->sem);\r\nreturn;\r\n}\r\nreadCapabilityRid(local, &cap_rid, 0);\r\nreadStatusRid(local, &status_rid, 0);\r\nreadStatsRid(local, &stats_rid, RID_STATS, 0);\r\nup(&local->sem);\r\nlocal->wstats.status = le16_to_cpu(status_rid.mode);\r\nif (local->rssi) {\r\nlocal->wstats.qual.level =\r\nairo_rssi_to_dbm(local->rssi,\r\nle16_to_cpu(status_rid.sigQuality));\r\nlocal->wstats.qual.qual =\r\nle16_to_cpu(status_rid.normalizedSignalStrength);\r\n} else {\r\nlocal->wstats.qual.level =\r\n(le16_to_cpu(status_rid.normalizedSignalStrength) + 321) / 2;\r\nlocal->wstats.qual.qual = airo_get_quality(&status_rid, &cap_rid);\r\n}\r\nif (le16_to_cpu(status_rid.len) >= 124) {\r\nlocal->wstats.qual.noise = 0x100 - status_rid.noisedBm;\r\nlocal->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\n} else {\r\nlocal->wstats.qual.noise = 0;\r\nlocal->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;\r\n}\r\nlocal->wstats.discard.nwid = le32_to_cpu(vals[56]) +\r\nle32_to_cpu(vals[57]) +\r\nle32_to_cpu(vals[58]);\r\nlocal->wstats.discard.code = le32_to_cpu(vals[6]);\r\nlocal->wstats.discard.fragment = le32_to_cpu(vals[30]);\r\nlocal->wstats.discard.retries = le32_to_cpu(vals[10]);\r\nlocal->wstats.discard.misc = le32_to_cpu(vals[1]) +\r\nle32_to_cpu(vals[32]);\r\nlocal->wstats.miss.beacon = le32_to_cpu(vals[34]);\r\n}\r\nstatic struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct airo_info *local = dev->ml_priv;\r\nif (!test_bit(JOB_WSTATS, &local->jobs)) {\r\nif (down_trylock(&local->sem) != 0) {\r\nset_bit(JOB_WSTATS, &local->jobs);\r\nwake_up_interruptible(&local->thr_wait);\r\n} else\r\nairo_read_wireless_stats(local);\r\n}\r\nreturn &local->wstats;\r\n}\r\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp) {\r\nunsigned short ridcode;\r\nunsigned char *iobuf;\r\nint len;\r\nstruct airo_info *ai = dev->ml_priv;\r\nif (test_bit(FLAG_FLASHING, &ai->flags))\r\nreturn -EIO;\r\nswitch(comp->command)\r\n{\r\ncase AIROGCAP: ridcode = RID_CAPABILITIES; break;\r\ncase AIROGCFG: ridcode = RID_CONFIG;\r\nif (test_bit(FLAG_COMMIT, &ai->flags)) {\r\ndisable_MAC (ai, 1);\r\nwriteConfigRid (ai, 1);\r\nenable_MAC(ai, 1);\r\n}\r\nbreak;\r\ncase AIROGSLIST: ridcode = RID_SSID; break;\r\ncase AIROGVLIST: ridcode = RID_APLIST; break;\r\ncase AIROGDRVNAM: ridcode = RID_DRVNAME; break;\r\ncase AIROGEHTENC: ridcode = RID_ETHERENCAP; break;\r\ncase AIROGWEPKTMP: ridcode = RID_WEP_TEMP;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbreak;\r\ncase AIROGWEPKNV: ridcode = RID_WEP_PERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbreak;\r\ncase AIROGSTAT: ridcode = RID_STATUS; break;\r\ncase AIROGSTATSD32: ridcode = RID_STATSDELTA; break;\r\ncase AIROGSTATSC32: ridcode = RID_STATS; break;\r\ncase AIROGMICSTATS:\r\nif (copy_to_user(comp->data, &ai->micstats,\r\nmin((int)comp->len,(int)sizeof(ai->micstats))))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase AIRORRID: ridcode = comp->ridnum; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nPC4500_readrid(ai,ridcode,iobuf,RIDSIZE, 1);\r\nlen = comp->len;\r\nif (copy_to_user(comp->data, iobuf, min(len, (int)RIDSIZE))) {\r\nkfree (iobuf);\r\nreturn -EFAULT;\r\n}\r\nkfree (iobuf);\r\nreturn 0;\r\n}\r\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp) {\r\nstruct airo_info *ai = dev->ml_priv;\r\nint ridcode;\r\nint enabled;\r\nstatic int (* writer)(struct airo_info *, u16 rid, const void *, int, int);\r\nunsigned char *iobuf;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (test_bit(FLAG_FLASHING, &ai->flags))\r\nreturn -EIO;\r\nridcode = 0;\r\nwriter = do_writerid;\r\nswitch(comp->command)\r\n{\r\ncase AIROPSIDS: ridcode = RID_SSID; break;\r\ncase AIROPCAP: ridcode = RID_CAPABILITIES; break;\r\ncase AIROPAPLIST: ridcode = RID_APLIST; break;\r\ncase AIROPCFG: ai->config.len = 0;\r\nclear_bit(FLAG_COMMIT, &ai->flags);\r\nridcode = RID_CONFIG; break;\r\ncase AIROPWEPKEYNV: ridcode = RID_WEP_PERM; break;\r\ncase AIROPLEAPUSR: ridcode = RID_LEAPUSERNAME; break;\r\ncase AIROPLEAPPWD: ridcode = RID_LEAPPASSWORD; break;\r\ncase AIROPWEPKEY: ridcode = RID_WEP_TEMP; writer = PC4500_writerid;\r\nbreak;\r\ncase AIROPLEAPUSR+1: ridcode = 0xFF2A; break;\r\ncase AIROPLEAPUSR+2: ridcode = 0xFF2B; break;\r\ncase AIROPMACON:\r\nif (enable_MAC(ai, 1) != 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase AIROPMACOFF:\r\ndisable_MAC(ai, 1);\r\nreturn 0;\r\ncase AIROPSTCLR:\r\nif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nPC4500_readrid(ai,RID_STATSDELTACLEAR,iobuf,RIDSIZE, 1);\r\nenabled = ai->micstats.enabled;\r\nmemset(&ai->micstats,0,sizeof(ai->micstats));\r\nai->micstats.enabled = enabled;\r\nif (copy_to_user(comp->data, iobuf,\r\nmin((int)comp->len, (int)RIDSIZE))) {\r\nkfree (iobuf);\r\nreturn -EFAULT;\r\n}\r\nkfree (iobuf);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif(comp->len > RIDSIZE)\r\nreturn -EINVAL;\r\nif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(iobuf,comp->data,comp->len)) {\r\nkfree (iobuf);\r\nreturn -EFAULT;\r\n}\r\nif (comp->command == AIROPCFG) {\r\nConfigRid *cfg = (ConfigRid *)iobuf;\r\nif (test_bit(FLAG_MIC_CAPABLE, &ai->flags))\r\ncfg->opmode |= MODE_MIC;\r\nif ((cfg->opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\r\nset_bit (FLAG_ADHOC, &ai->flags);\r\nelse\r\nclear_bit (FLAG_ADHOC, &ai->flags);\r\n}\r\nif((*writer)(ai, ridcode, iobuf,comp->len,1)) {\r\nkfree (iobuf);\r\nreturn -EIO;\r\n}\r\nkfree (iobuf);\r\nreturn 0;\r\n}\r\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp) {\r\nint z;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch(comp->command)\r\n{\r\ncase AIROFLSHRST:\r\nreturn cmdreset((struct airo_info *)dev->ml_priv);\r\ncase AIROFLSHSTFL:\r\nif (!AIRO_FLASH(dev) &&\r\n(AIRO_FLASH(dev) = kmalloc(FLASHSIZE, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nreturn setflashmode((struct airo_info *)dev->ml_priv);\r\ncase AIROFLSHGCHR:\r\nif(comp->len != sizeof(int))\r\nreturn -EINVAL;\r\nif (copy_from_user(&z,comp->data,comp->len))\r\nreturn -EFAULT;\r\nreturn flashgchar((struct airo_info *)dev->ml_priv, z, 8000);\r\ncase AIROFLSHPCHR:\r\nif(comp->len != sizeof(int))\r\nreturn -EINVAL;\r\nif (copy_from_user(&z,comp->data,comp->len))\r\nreturn -EFAULT;\r\nreturn flashpchar((struct airo_info *)dev->ml_priv, z, 8000);\r\ncase AIROFLPUTBUF:\r\nif (!AIRO_FLASH(dev))\r\nreturn -ENOMEM;\r\nif(comp->len > FLASHSIZE)\r\nreturn -EINVAL;\r\nif (copy_from_user(AIRO_FLASH(dev), comp->data, comp->len))\r\nreturn -EFAULT;\r\nflashputbuf((struct airo_info *)dev->ml_priv);\r\nreturn 0;\r\ncase AIRORESTART:\r\nif (flashrestart((struct airo_info *)dev->ml_priv, dev))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cmdreset(struct airo_info *ai) {\r\ndisable_MAC(ai, 1);\r\nif(!waitbusy (ai)){\r\nairo_print_info(ai->dev->name, "Waitbusy hang before RESET");\r\nreturn -EBUSY;\r\n}\r\nOUT4500(ai,COMMAND,CMD_SOFTRESET);\r\nssleep(1);\r\nif(!waitbusy (ai)){\r\nairo_print_info(ai->dev->name, "Waitbusy hang AFTER RESET");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setflashmode (struct airo_info *ai) {\r\nset_bit (FLAG_FLASHING, &ai->flags);\r\nOUT4500(ai, SWS0, FLASH_COMMAND);\r\nOUT4500(ai, SWS1, FLASH_COMMAND);\r\nif (probe) {\r\nOUT4500(ai, SWS0, FLASH_COMMAND);\r\nOUT4500(ai, COMMAND,0x10);\r\n} else {\r\nOUT4500(ai, SWS2, FLASH_COMMAND);\r\nOUT4500(ai, SWS3, FLASH_COMMAND);\r\nOUT4500(ai, COMMAND,0);\r\n}\r\nmsleep(500);\r\nif(!waitbusy(ai)) {\r\nclear_bit (FLAG_FLASHING, &ai->flags);\r\nairo_print_info(ai->dev->name, "Waitbusy hang after setflash mode");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flashpchar(struct airo_info *ai,int byte,int dwelltime) {\r\nint echo;\r\nint waittime;\r\nbyte |= 0x8000;\r\nif(dwelltime == 0 )\r\ndwelltime = 200;\r\nwaittime=dwelltime;\r\nwhile ((IN4500 (ai, SWS0) & 0x8000) && waittime > 0) {\r\nudelay (50);\r\nwaittime -= 50;\r\n}\r\nif(waittime <= 0 ){\r\nairo_print_info(ai->dev->name, "flash putchar busywait timeout!");\r\nreturn -EBUSY;\r\n}\r\ndo {\r\nOUT4500(ai,SWS0,byte);\r\nudelay(50);\r\ndwelltime -= 50;\r\necho = IN4500(ai,SWS1);\r\n} while (dwelltime >= 0 && echo != byte);\r\nOUT4500(ai,SWS1,0);\r\nreturn (echo == byte) ? 0 : -EIO;\r\n}\r\nstatic int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime){\r\nint rchar;\r\nunsigned char rbyte=0;\r\ndo {\r\nrchar = IN4500(ai,SWS1);\r\nif(dwelltime && !(0x8000 & rchar)){\r\ndwelltime -= 10;\r\nmdelay(10);\r\ncontinue;\r\n}\r\nrbyte = 0xff & rchar;\r\nif( (rbyte == matchbyte) && (0x8000 & rchar) ){\r\nOUT4500(ai,SWS1,0);\r\nreturn 0;\r\n}\r\nif( rbyte == 0x81 || rbyte == 0x82 || rbyte == 0x83 || rbyte == 0x1a || 0xffff == rchar)\r\nbreak;\r\nOUT4500(ai,SWS1,0);\r\n}while(dwelltime > 0);\r\nreturn -EIO;\r\n}\r\nstatic int flashputbuf(struct airo_info *ai){\r\nint nwords;\r\nif (test_bit(FLAG_MPI,&ai->flags))\r\nmemcpy_toio(ai->pciaux + 0x8000, ai->flash, FLASHSIZE);\r\nelse {\r\nOUT4500(ai,AUXPAGE,0x100);\r\nOUT4500(ai,AUXOFF,0);\r\nfor(nwords=0;nwords != FLASHSIZE / 2;nwords++){\r\nOUT4500(ai,AUXDATA,ai->flash[nwords] & 0xffff);\r\n}\r\n}\r\nOUT4500(ai,SWS0,0x8000);\r\nreturn 0;\r\n}\r\nstatic int flashrestart(struct airo_info *ai,struct net_device *dev){\r\nint i,status;\r\nssleep(1);\r\nclear_bit (FLAG_FLASHING, &ai->flags);\r\nif (test_bit(FLAG_MPI, &ai->flags)) {\r\nstatus = mpi_init_descriptors(ai);\r\nif (status != SUCCESS)\r\nreturn status;\r\n}\r\nstatus = setup_card(ai, dev->dev_addr, 1);\r\nif (!test_bit(FLAG_MPI,&ai->flags))\r\nfor( i = 0; i < MAX_FIDS; i++ ) {\r\nai->fids[i] = transmit_allocate\r\n( ai, AIRO_DEF_MTU, i >= MAX_FIDS / 2 );\r\n}\r\nssleep(1);\r\nreturn status;\r\n}
