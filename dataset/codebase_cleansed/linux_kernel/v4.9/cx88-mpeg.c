static void request_module_async(struct work_struct *work)\r\n{\r\nstruct cx8802_dev *dev=container_of(work, struct cx8802_dev, request_module_wk);\r\nif (dev->core->board.mpeg & CX88_MPEG_DVB)\r\nrequest_module("cx88-dvb");\r\nif (dev->core->board.mpeg & CX88_MPEG_BLACKBIRD)\r\nrequest_module("cx88-blackbird");\r\n}\r\nstatic void request_modules(struct cx8802_dev *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct cx8802_dev *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nint cx8802_start_dma(struct cx8802_dev *dev,\r\nstruct cx88_dmaqueue *q,\r\nstruct cx88_buffer *buf)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ndprintk(1, "cx8802_start_dma w: %d, h: %d, f: %d\n",\r\ncore->width, core->height, core->field);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],\r\ndev->ts_packet_size, buf->risc.dma);\r\ncx_write(MO_TS_LNGTH, dev->ts_packet_size);\r\ndprintk( 1, "core->active_type_id = 0x%08x\n", core->active_type_id);\r\nif ( (core->active_type_id == CX88_MPEG_DVB) &&\r\n(core->board.mpeg & CX88_MPEG_DVB) ) {\r\ndprintk( 1, "cx8802_start_dma doing .dvb\n");\r\ncx_write(TS_GEN_CNTRL, 0x0040 | dev->ts_gen_cntrl);\r\nudelay(100);\r\ncx_write(MO_PINMUX_IO, 0x00);\r\ncx_write(TS_HW_SOP_CNTRL, 0x47<<16|188<<4|0x01);\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_Q:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_3_GOLD_T:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:\r\ncase CX88_BOARD_PCHDTV_HD5500:\r\ncx_write(TS_SOP_STAT, 1<<13);\r\nbreak;\r\ncase CX88_BOARD_SAMSUNG_SMT_7020:\r\ncx_write(TS_SOP_STAT, 0x00);\r\nbreak;\r\ncase CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:\r\ncase CX88_BOARD_HAUPPAUGE_NOVASE2_S1:\r\ncx_write(MO_PINMUX_IO, 0x88);\r\nudelay(100);\r\nbreak;\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\ncx_write(MO_PINMUX_IO, 0x88);\r\ncx_write(TS_SOP_STAT, 0);\r\ncx_write(TS_VALERR_CNTRL, 0);\r\nbreak;\r\ncase CX88_BOARD_PINNACLE_PCTV_HD_800i:\r\ncx_write(MO_PINMUX_IO, 0x88);\r\ncx_write(TS_HW_SOP_CNTRL, (0x47 << 16) | (188 << 4));\r\ndev->ts_gen_cntrl = 5;\r\ncx_write(TS_SOP_STAT, 0);\r\ncx_write(TS_VALERR_CNTRL, 0);\r\nudelay(100);\r\nbreak;\r\ndefault:\r\ncx_write(TS_SOP_STAT, 0x00);\r\nbreak;\r\n}\r\ncx_write(TS_GEN_CNTRL, dev->ts_gen_cntrl);\r\nudelay(100);\r\n} else if ( (core->active_type_id == CX88_MPEG_BLACKBIRD) &&\r\n(core->board.mpeg & CX88_MPEG_BLACKBIRD) ) {\r\ndprintk( 1, "cx8802_start_dma doing .blackbird\n");\r\ncx_write(MO_PINMUX_IO, 0x88);\r\ncx_write(TS_GEN_CNTRL, 0x46);\r\nudelay(100);\r\ncx_write(TS_HW_SOP_CNTRL, 0x408);\r\ncx_write(TS_VALERR_CNTRL, 0x2000);\r\ncx_write(TS_GEN_CNTRL, 0x06);\r\nudelay(100);\r\n} else {\r\nprintk( "%s() Failed. Unsupported value in .mpeg (0x%08x)\n", __func__,\r\ncore->board.mpeg );\r\nreturn -EINVAL;\r\n}\r\ncx_write(MO_TS_GPCNTRL, GP_COUNT_CONTROL_RESET);\r\nq->count = 0;\r\ndprintk( 1, "setting the interrupt mask\n" );\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_TSINT);\r\ncx_set(MO_TS_INTMSK, 0x1f0011);\r\ncx_set(MO_DEV_CNTRL2, (1<<5));\r\ncx_set(MO_TS_DMACNTRL, 0x11);\r\nreturn 0;\r\n}\r\nstatic int cx8802_stop_dma(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ndprintk( 1, "cx8802_stop_dma\n" );\r\ncx_clear(MO_TS_DMACNTRL, 0x11);\r\ncx_clear(MO_PCI_INTMSK, PCI_INT_TSINT);\r\ncx_clear(MO_TS_INTMSK, 0x1f0011);\r\ncx_write(TS_GEN_CNTRL, 0xcd);\r\nreturn 0;\r\n}\r\nstatic int cx8802_restart_queue(struct cx8802_dev *dev,\r\nstruct cx88_dmaqueue *q)\r\n{\r\nstruct cx88_buffer *buf;\r\ndprintk( 1, "cx8802_restart_queue\n" );\r\nif (list_empty(&q->active))\r\nreturn 0;\r\nbuf = list_entry(q->active.next, struct cx88_buffer, list);\r\ndprintk(2,"restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.vb2_buf.index);\r\ncx8802_start_dma(dev, q, buf);\r\nreturn 0;\r\n}\r\nint cx8802_buf_prepare(struct vb2_queue *q, struct cx8802_dev *dev,\r\nstruct cx88_buffer *buf)\r\n{\r\nint size = dev->ts_packet_size * dev->ts_packet_count;\r\nstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\r\nstruct cx88_riscmem *risc = &buf->risc;\r\nint rc;\r\nif (vb2_plane_size(&buf->vb.vb2_buf, 0) < size)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\r\nrc = cx88_risc_databuffer(dev->pci, risc, sgt->sgl,\r\ndev->ts_packet_size, dev->ts_packet_count, 0);\r\nif (rc) {\r\nif (risc->cpu)\r\npci_free_consistent(dev->pci, risc->size, risc->cpu, risc->dma);\r\nmemset(risc, 0, sizeof(*risc));\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)\r\n{\r\nstruct cx88_buffer *prev;\r\nstruct cx88_dmaqueue *cx88q = &dev->mpegq;\r\ndprintk( 1, "cx8802_buf_queue\n" );\r\nbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);\r\nif (list_empty(&cx88q->active)) {\r\ndprintk( 1, "queue is empty - first active\n" );\r\nlist_add_tail(&buf->list, &cx88q->active);\r\ndprintk(1,"[%p/%d] %s - first active\n",\r\nbuf, buf->vb.vb2_buf.index, __func__);\r\n} else {\r\nbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\r\ndprintk( 1, "queue is not empty - append to active\n" );\r\nprev = list_entry(cx88q->active.prev, struct cx88_buffer, list);\r\nlist_add_tail(&buf->list, &cx88q->active);\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\ndprintk( 1, "[%p/%d] %s - append to active\n",\r\nbuf, buf->vb.vb2_buf.index, __func__);\r\n}\r\n}\r\nstatic void do_cancel_buffers(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_dmaqueue *q = &dev->mpegq;\r\nstruct cx88_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock,flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx88_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\n}\r\nvoid cx8802_cancel_buffers(struct cx8802_dev *dev)\r\n{\r\ndprintk( 1, "cx8802_cancel_buffers" );\r\ncx8802_stop_dma(dev);\r\ndo_cancel_buffers(dev);\r\n}\r\nstatic void cx8802_mpeg_irq(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nu32 status, mask, count;\r\ndprintk( 1, "cx8802_mpeg_irq\n" );\r\nstatus = cx_read(MO_TS_INTSTAT);\r\nmask = cx_read(MO_TS_INTMSK);\r\nif (0 == (status & mask))\r\nreturn;\r\ncx_write(MO_TS_INTSTAT, status);\r\nif (debug || (status & mask & ~0xff))\r\ncx88_print_irqbits(core->name, "irq mpeg ",\r\ncx88_mpeg_irqs, ARRAY_SIZE(cx88_mpeg_irqs),\r\nstatus, mask);\r\nif (status & (1 << 16)) {\r\nprintk(KERN_WARNING "%s: mpeg risc op code error\n",core->name);\r\ncx_clear(MO_TS_DMACNTRL, 0x11);\r\ncx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH28]);\r\n}\r\nif (status & 0x01) {\r\ndprintk( 1, "wake up\n" );\r\nspin_lock(&dev->slock);\r\ncount = cx_read(MO_TS_GPCNT);\r\ncx88_wakeup(dev->core, &dev->mpegq, count);\r\nspin_unlock(&dev->slock);\r\n}\r\nif (status & 0x1f0100) {\r\ndprintk( 0, "general errors: 0x%08x\n", status & 0x1f0100 );\r\nspin_lock(&dev->slock);\r\ncx8802_stop_dma(dev);\r\nspin_unlock(&dev->slock);\r\n}\r\n}\r\nstatic irqreturn_t cx8802_irq(int irq, void *dev_id)\r\n{\r\nstruct cx8802_dev *dev = dev_id;\r\nstruct cx88_core *core = dev->core;\r\nu32 status;\r\nint loop, handled = 0;\r\nfor (loop = 0; loop < MAX_IRQ_LOOP; loop++) {\r\nstatus = cx_read(MO_PCI_INTSTAT) &\r\n(core->pci_irqmask | PCI_INT_TSINT);\r\nif (0 == status)\r\ngoto out;\r\ndprintk( 1, "cx8802_irq\n" );\r\ndprintk( 1, " loop: %d/%d\n", loop, MAX_IRQ_LOOP );\r\ndprintk( 1, " status: %d\n", status );\r\nhandled = 1;\r\ncx_write(MO_PCI_INTSTAT, status);\r\nif (status & core->pci_irqmask)\r\ncx88_core_irq(core,status);\r\nif (status & PCI_INT_TSINT)\r\ncx8802_mpeg_irq(dev);\r\n}\r\nif (MAX_IRQ_LOOP == loop) {\r\ndprintk( 0, "clearing mask\n" );\r\nprintk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",\r\ncore->name);\r\ncx_write(MO_PCI_INTMSK,0);\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int cx8802_init_common(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nint err;\r\nif (pci_enable_device(dev->pci))\r\nreturn -EIO;\r\npci_set_master(dev->pci);\r\nerr = pci_set_dma_mask(dev->pci,DMA_BIT_MASK(32));\r\nif (err) {\r\nprintk("%s/2: Oops: no 32bit PCI DMA ???\n",dev->core->name);\r\nreturn -EIO;\r\n}\r\ndev->pci_rev = dev->pci->revision;\r\npci_read_config_byte(dev->pci, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s/2: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", dev->core->name,\r\npci_name(dev->pci), dev->pci_rev, dev->pci->irq,\r\ndev->pci_lat,(unsigned long long)pci_resource_start(dev->pci,0));\r\nspin_lock_init(&dev->slock);\r\nINIT_LIST_HEAD(&dev->mpegq.active);\r\nerr = request_irq(dev->pci->irq, cx8802_irq,\r\nIRQF_SHARED, dev->core->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: can't get IRQ %d\n",\r\ndev->core->name, dev->pci->irq);\r\nreturn err;\r\n}\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask);\r\npci_set_drvdata(dev->pci,dev);\r\nreturn 0;\r\n}\r\nstatic void cx8802_fini_common(struct cx8802_dev *dev)\r\n{\r\ndprintk( 2, "cx8802_fini_common\n" );\r\ncx8802_stop_dma(dev);\r\npci_disable_device(dev->pci);\r\nfree_irq(dev->pci->irq, dev);\r\n}\r\nstatic int cx8802_suspend_common(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct cx8802_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (!list_empty(&dev->mpegq.active)) {\r\ndprintk( 2, "suspend\n" );\r\nprintk("%s: suspend mpeg\n", core->name);\r\ncx8802_stop_dma(dev);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ncx88_shutdown(dev->core);\r\npci_save_state(pci_dev);\r\nif (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx8802_resume_common(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8802_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nunsigned long flags;\r\nint err;\r\nif (dev->state.disabled) {\r\nerr=pci_enable_device(pci_dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: can't enable device\n",\r\ndev->core->name);\r\nreturn err;\r\n}\r\ndev->state.disabled = 0;\r\n}\r\nerr=pci_set_power_state(pci_dev, PCI_D0);\r\nif (err) {\r\nprintk(KERN_ERR "%s: can't enable device\n",\r\ndev->core->name);\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\nreturn err;\r\n}\r\npci_restore_state(pci_dev);\r\ncx88_reset(dev->core);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (!list_empty(&dev->mpegq.active)) {\r\nprintk("%s: resume mpeg\n", core->name);\r\ncx8802_restart_queue(dev,&dev->mpegq);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}\r\nstruct cx8802_driver * cx8802_get_driver(struct cx8802_dev *dev, enum cx88_board_type btype)\r\n{\r\nstruct cx8802_driver *d;\r\nlist_for_each_entry(d, &dev->drvlist, drvlist)\r\nif (d->type_id == btype)\r\nreturn d;\r\nreturn NULL;\r\n}\r\nstatic int cx8802_request_acquire(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nunsigned int i;\r\nif (core->active_type_id != CX88_BOARD_NONE &&\r\ncore->active_type_id != drv->type_id)\r\nreturn -EBUSY;\r\nif (drv->type_id == CX88_MPEG_DVB) {\r\ncore->last_analog_input = core->input;\r\ncore->input = 0;\r\nfor (i = 0;\r\ni < (sizeof(core->board.input) / sizeof(struct cx88_input));\r\ni++) {\r\nif (core->board.input[i].type == CX88_VMUX_DVB) {\r\ncore->input = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (drv->advise_acquire)\r\n{\r\ncore->active_ref++;\r\nif (core->active_type_id == CX88_BOARD_NONE) {\r\ncore->active_type_id = drv->type_id;\r\ndrv->advise_acquire(drv);\r\n}\r\nmpeg_dbg(1,"%s() Post acquire GPIO=%x\n", __func__, cx_read(MO_GP0_IO));\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx8802_request_release(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nif (drv->advise_release && --core->active_ref == 0)\r\n{\r\nif (drv->type_id == CX88_MPEG_DVB) {\r\ncore->input = core->last_analog_input;\r\n}\r\ndrv->advise_release(drv);\r\ncore->active_type_id = CX88_BOARD_NONE;\r\nmpeg_dbg(1,"%s() Post release GPIO=%x\n", __func__, cx_read(MO_GP0_IO));\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx8802_check_driver(struct cx8802_driver *drv)\r\n{\r\nif (drv == NULL)\r\nreturn -ENODEV;\r\nif ((drv->type_id != CX88_MPEG_DVB) &&\r\n(drv->type_id != CX88_MPEG_BLACKBIRD))\r\nreturn -EINVAL;\r\nif ((drv->hw_access != CX8802_DRVCTL_SHARED) &&\r\n(drv->hw_access != CX8802_DRVCTL_EXCLUSIVE))\r\nreturn -EINVAL;\r\nif ((drv->probe == NULL) ||\r\n(drv->remove == NULL) ||\r\n(drv->advise_acquire == NULL) ||\r\n(drv->advise_release == NULL))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint cx8802_register_driver(struct cx8802_driver *drv)\r\n{\r\nstruct cx8802_dev *dev;\r\nstruct cx8802_driver *driver;\r\nint err, i = 0;\r\nprintk(KERN_INFO\r\n"cx88/2: registering cx8802 driver, type: %s access: %s\n",\r\ndrv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",\r\ndrv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");\r\nif ((err = cx8802_check_driver(drv)) != 0) {\r\nprintk(KERN_ERR "cx88/2: cx8802_driver is invalid\n");\r\nreturn err;\r\n}\r\nmutex_lock(&cx8802_mutex);\r\nlist_for_each_entry(dev, &cx8802_devlist, devlist) {\r\nprintk(KERN_INFO\r\n"%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",\r\ndev->core->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device, dev->core->board.name,\r\ndev->core->boardnr);\r\ndriver = kzalloc(sizeof(*drv),GFP_KERNEL);\r\nif (driver == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ndrv->core = dev->core;\r\ndrv->suspend = cx8802_suspend_common;\r\ndrv->resume = cx8802_resume_common;\r\ndrv->request_acquire = cx8802_request_acquire;\r\ndrv->request_release = cx8802_request_release;\r\nmemcpy(driver, drv, sizeof(*driver));\r\nmutex_lock(&drv->core->lock);\r\nerr = drv->probe(driver);\r\nif (err == 0) {\r\ni++;\r\nlist_add_tail(&driver->drvlist, &dev->drvlist);\r\n} else {\r\nprintk(KERN_ERR\r\n"%s/2: cx8802 probe failed, err = %d\n",\r\ndev->core->name, err);\r\n}\r\nmutex_unlock(&drv->core->lock);\r\n}\r\nerr = i ? 0 : -ENODEV;\r\nout:\r\nmutex_unlock(&cx8802_mutex);\r\nreturn err;\r\n}\r\nint cx8802_unregister_driver(struct cx8802_driver *drv)\r\n{\r\nstruct cx8802_dev *dev;\r\nstruct cx8802_driver *d, *dtmp;\r\nint err = 0;\r\nprintk(KERN_INFO\r\n"cx88/2: unregistering cx8802 driver, type: %s access: %s\n",\r\ndrv->type_id == CX88_MPEG_DVB ? "dvb" : "blackbird",\r\ndrv->hw_access == CX8802_DRVCTL_SHARED ? "shared" : "exclusive");\r\nmutex_lock(&cx8802_mutex);\r\nlist_for_each_entry(dev, &cx8802_devlist, devlist) {\r\nprintk(KERN_INFO\r\n"%s/2: subsystem: %04x:%04x, board: %s [card=%d]\n",\r\ndev->core->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device, dev->core->board.name,\r\ndev->core->boardnr);\r\nmutex_lock(&dev->core->lock);\r\nlist_for_each_entry_safe(d, dtmp, &dev->drvlist, drvlist) {\r\nif (d->type_id != drv->type_id)\r\ncontinue;\r\nerr = d->remove(d);\r\nif (err == 0) {\r\nlist_del(&d->drvlist);\r\nkfree(d);\r\n} else\r\nprintk(KERN_ERR "%s/2: cx8802 driver remove "\r\n"failed (%d)\n", dev->core->name, err);\r\n}\r\nmutex_unlock(&dev->core->lock);\r\n}\r\nmutex_unlock(&cx8802_mutex);\r\nreturn err;\r\n}\r\nstatic int cx8802_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cx8802_dev *dev;\r\nstruct cx88_core *core;\r\nint err;\r\ncore = cx88_core_get(pci_dev);\r\nif (NULL == core)\r\nreturn -EINVAL;\r\nprintk("%s/2: cx2388x 8802 Driver Manager\n", core->name);\r\nerr = -ENODEV;\r\nif (!core->board.mpeg)\r\ngoto fail_core;\r\nerr = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev),GFP_KERNEL);\r\nif (NULL == dev)\r\ngoto fail_core;\r\ndev->pci = pci_dev;\r\ndev->core = core;\r\ncore->dvbdev = dev;\r\nerr = cx8802_init_common(dev);\r\nif (err != 0)\r\ngoto fail_dev;\r\nINIT_LIST_HEAD(&dev->drvlist);\r\nmutex_lock(&cx8802_mutex);\r\nlist_add_tail(&dev->devlist,&cx8802_devlist);\r\nmutex_unlock(&cx8802_mutex);\r\nrequest_modules(dev);\r\nreturn 0;\r\nfail_dev:\r\nkfree(dev);\r\nfail_core:\r\ncore->dvbdev = NULL;\r\ncx88_core_put(core,pci_dev);\r\nreturn err;\r\n}\r\nstatic void cx8802_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8802_dev *dev;\r\ndev = pci_get_drvdata(pci_dev);\r\ndprintk( 1, "%s\n", __func__);\r\nflush_request_modules(dev);\r\nmutex_lock(&dev->core->lock);\r\nif (!list_empty(&dev->drvlist)) {\r\nstruct cx8802_driver *drv, *tmp;\r\nint err;\r\nprintk(KERN_WARNING "%s/2: Trying to remove cx8802 driver "\r\n"while cx8802 sub-drivers still loaded?!\n",\r\ndev->core->name);\r\nlist_for_each_entry_safe(drv, tmp, &dev->drvlist, drvlist) {\r\nerr = drv->remove(drv);\r\nif (err == 0) {\r\nlist_del(&drv->drvlist);\r\n} else\r\nprintk(KERN_ERR "%s/2: cx8802 driver remove "\r\n"failed (%d)\n", dev->core->name, err);\r\nkfree(drv);\r\n}\r\n}\r\nmutex_unlock(&dev->core->lock);\r\ndev->core->dvbdev = NULL;\r\ncx8802_fini_common(dev);\r\ncx88_core_put(dev->core,dev->pci);\r\nkfree(dev);\r\n}
