static int stw481x_get_pctl_reg(struct stw481x *stw481x, u8 reg)\r\n{\r\nu8 msb = (reg >> 3) & 0x03;\r\nu8 lsb = (reg << 5) & 0xe0;\r\nunsigned int val;\r\nu8 vrfy;\r\nint ret;\r\nret = regmap_write(stw481x->map, STW_PCTL_REG_HI, msb);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(stw481x->map, STW_PCTL_REG_LO, lsb);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(stw481x->map, STW_PCTL_REG_HI, &val);\r\nif (ret)\r\nreturn ret;\r\nvrfy = (val & 0x03) << 3;\r\nret = regmap_read(stw481x->map, STW_PCTL_REG_LO, &val);\r\nif (ret)\r\nreturn ret;\r\nvrfy |= ((val >> 5) & 0x07);\r\nif (vrfy != reg)\r\nreturn -EIO;\r\nreturn (val >> 1) & 0x0f;\r\n}\r\nstatic int stw481x_startup(struct stw481x *stw481x)\r\n{\r\nu8 vcore_val[] = { 100, 105, 110, 115, 120, 122, 124, 126, 128,\r\n130, 132, 134, 136, 138, 140, 145 };\r\nu8 vpll_val[] = { 105, 120, 130, 180 };\r\nu8 vaux_val[] = { 15, 18, 25, 28 };\r\nu8 vcore;\r\nu8 vcore_slp;\r\nu8 vpll;\r\nu8 vaux;\r\nbool vaux_en;\r\nbool it_warn;\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(stw481x->map, STW_CONF1, &val);\r\nif (ret)\r\nreturn ret;\r\nvaux_en = !!(val & STW_CONF1_PDN_VAUX);\r\nit_warn = !!(val & STW_CONF1_IT_WARN);\r\ndev_info(&stw481x->client->dev, "voltages %s\n",\r\n(val & STW_CONF1_V_MONITORING) ? "OK" : "LOW");\r\ndev_info(&stw481x->client->dev, "MMC level shifter %s\n",\r\n(val & STW_CONF1_MMC_LS_STATUS) ? "high impedance" : "ON");\r\ndev_info(&stw481x->client->dev, "VMMC: %s\n",\r\n(val & STW_CONF1_PDN_VMMC) ? "ON" : "disabled");\r\ndev_info(&stw481x->client->dev, "STw481x power control registers:\n");\r\nret = stw481x_get_pctl_reg(stw481x, STW_PC_VCORE_SEL);\r\nif (ret < 0)\r\nreturn ret;\r\nvcore = ret & 0x0f;\r\nret = stw481x_get_pctl_reg(stw481x, STW_PC_VAUX_SEL);\r\nif (ret < 0)\r\nreturn ret;\r\nvaux = (ret >> 2) & 3;\r\nvpll = (ret >> 4) & 1;\r\nret = stw481x_get_pctl_reg(stw481x, STW_PC_VPLL_SEL);\r\nif (ret < 0)\r\nreturn ret;\r\nvpll |= (ret >> 1) & 2;\r\ndev_info(&stw481x->client->dev, "VCORE: %u.%uV %s\n",\r\nvcore_val[vcore] / 100, vcore_val[vcore] % 100,\r\n(ret & 4) ? "ON" : "OFF");\r\ndev_info(&stw481x->client->dev, "VPLL: %u.%uV %s\n",\r\nvpll_val[vpll] / 100, vpll_val[vpll] % 100,\r\n(ret & 0x10) ? "ON" : "OFF");\r\ndev_info(&stw481x->client->dev, "VAUX: %u.%uV %s\n",\r\nvaux_val[vaux] / 10, vaux_val[vaux] % 10,\r\nvaux_en ? "ON" : "OFF");\r\nret = regmap_read(stw481x->map, STW_CONF2, &val);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&stw481x->client->dev, "TWARN: %s threshold, %s\n",\r\nit_warn ? "below" : "above",\r\n(val & STW_CONF2_MASK_TWARN) ?\r\n"enabled" : "mask through VDDOK");\r\ndev_info(&stw481x->client->dev, "VMMC: %s\n",\r\n(val & STW_CONF2_VMMC_EXT) ? "internal" : "external");\r\ndev_info(&stw481x->client->dev, "IT WAKE UP: %s\n",\r\n(val & STW_CONF2_MASK_IT_WAKE_UP) ? "enabled" : "masked");\r\ndev_info(&stw481x->client->dev, "GPO1: %s\n",\r\n(val & STW_CONF2_GPO1) ? "low" : "high impedance");\r\ndev_info(&stw481x->client->dev, "GPO2: %s\n",\r\n(val & STW_CONF2_GPO2) ? "low" : "high impedance");\r\nret = regmap_read(stw481x->map, STW_VCORE_SLEEP, &val);\r\nif (ret)\r\nreturn ret;\r\nvcore_slp = val & 0x0f;\r\ndev_info(&stw481x->client->dev, "VCORE SLEEP: %u.%uV\n",\r\nvcore_val[vcore_slp] / 100, vcore_val[vcore_slp] % 100);\r\nreturn 0;\r\n}\r\nstatic int stw481x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct stw481x *stw481x;\r\nint ret;\r\nint i;\r\nstw481x = devm_kzalloc(&client->dev, sizeof(*stw481x), GFP_KERNEL);\r\nif (!stw481x)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, stw481x);\r\nstw481x->client = client;\r\nstw481x->map = devm_regmap_init_i2c(client, &stw481x_regmap_config);\r\nif (IS_ERR(stw481x->map)) {\r\nret = PTR_ERR(stw481x->map);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = stw481x_startup(stw481x);\r\nif (ret) {\r\ndev_err(&client->dev, "chip initialization failed\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(stw481x_cells); i++) {\r\nstw481x_cells[i].platform_data = stw481x;\r\nstw481x_cells[i].pdata_size = sizeof(*stw481x);\r\n}\r\nret = devm_mfd_add_devices(&client->dev, 0, stw481x_cells,\r\nARRAY_SIZE(stw481x_cells), NULL, 0, NULL);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&client->dev, "initialized STw481x device\n");\r\nreturn ret;\r\n}
