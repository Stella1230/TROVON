static inline struct oxnas_gpio_bank *pctl_to_bank(struct oxnas_pinctrl *pctl,\r\nunsigned int pin)\r\n{\r\nreturn &pctl->gpio_banks[pin / PINS_PER_BANK];\r\n}\r\nstatic int oxnas_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *oxnas_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int group)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int oxnas_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int oxnas_pinmux_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->nfunctions;\r\n}\r\nstatic const char *\r\noxnas_pinmux_get_function_name(struct pinctrl_dev *pctldev, unsigned int func)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[func].name;\r\n}\r\nstatic int oxnas_pinmux_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned int func,\r\nconst char * const **groups,\r\nunsigned int * const num_groups)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[func].groups;\r\n*num_groups = pctl->functions[func].ngroups;\r\nreturn 0;\r\n}\r\nstatic int oxnas_pinmux_enable(struct pinctrl_dev *pctldev,\r\nunsigned int func, unsigned int group)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct oxnas_pin_group *pg = &pctl->groups[group];\r\nconst struct oxnas_function *pf = &pctl->functions[func];\r\nconst char *fname = pf->name;\r\nstruct oxnas_desc_function *functions = pg->functions;\r\nu32 mask = BIT(pg->pin);\r\nwhile (functions->name) {\r\nif (!strcmp(functions->name, fname)) {\r\ndev_dbg(pctl->dev,\r\n"setting function %s bank %d pin %d fct %d mask %x\n",\r\nfname, pg->bank, pg->pin,\r\nfunctions->fct, mask);\r\nregmap_write_bits(pctl->regmap,\r\n(pg->bank ?\r\nPINMUX_PRIMARY_SEL1 :\r\nPINMUX_PRIMARY_SEL0),\r\nmask,\r\n(functions->fct == 1 ?\r\nmask : 0));\r\nregmap_write_bits(pctl->regmap,\r\n(pg->bank ?\r\nPINMUX_SECONDARY_SEL1 :\r\nPINMUX_SECONDARY_SEL0),\r\nmask,\r\n(functions->fct == 2 ?\r\nmask : 0));\r\nregmap_write_bits(pctl->regmap,\r\n(pg->bank ?\r\nPINMUX_TERTIARY_SEL1 :\r\nPINMUX_TERTIARY_SEL0),\r\nmask,\r\n(functions->fct == 3 ?\r\nmask : 0));\r\nreturn 0;\r\n}\r\nfunctions++;\r\n}\r\ndev_err(pctl->dev, "cannot mux pin %u to function %u\n", group, func);\r\nreturn -EINVAL;\r\n}\r\nstatic int oxnas_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int offset)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(range->gc);\r\nu32 mask = BIT(offset - bank->gpio_chip.base);\r\ndev_dbg(pctl->dev, "requesting gpio %d in bank %d (id %d) with mask 0x%x\n",\r\noffset, bank->gpio_chip.base, bank->id, mask);\r\nregmap_write_bits(pctl->regmap,\r\n(bank->id ?\r\nPINMUX_PRIMARY_SEL1 :\r\nPINMUX_PRIMARY_SEL0),\r\nmask, 0);\r\nregmap_write_bits(pctl->regmap,\r\n(bank->id ?\r\nPINMUX_SECONDARY_SEL1 :\r\nPINMUX_SECONDARY_SEL0),\r\nmask, 0);\r\nregmap_write_bits(pctl->regmap,\r\n(bank->id ?\r\nPINMUX_TERTIARY_SEL1 :\r\nPINMUX_TERTIARY_SEL0),\r\nmask, 0);\r\nreturn 0;\r\n}\r\nstatic int oxnas_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nreturn !(readl_relaxed(bank->reg_base + OUTPUT_EN) & mask);\r\n}\r\nstatic int oxnas_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nwritel_relaxed(mask, bank->reg_base + OUTPUT_EN_CLEAR);\r\nreturn 0;\r\n}\r\nstatic int oxnas_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nreturn (readl_relaxed(bank->reg_base + INPUT_VALUE) & mask) != 0;\r\n}\r\nstatic void oxnas_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\nif (value)\r\nwritel_relaxed(mask, bank->reg_base + OUTPUT_SET);\r\nelse\r\nwritel_relaxed(mask, bank->reg_base + OUTPUT_CLEAR);\r\n}\r\nstatic int oxnas_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(offset);\r\noxnas_gpio_set(chip, offset, value);\r\nwritel_relaxed(mask, bank->reg_base + OUTPUT_EN_SET);\r\nreturn 0;\r\n}\r\nstatic int oxnas_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int offset, bool input)\r\n{\r\nstruct gpio_chip *chip = range->gc;\r\nif (input)\r\noxnas_gpio_direction_input(chip, offset);\r\nelse\r\noxnas_gpio_direction_output(chip, offset, 0);\r\nreturn 0;\r\n}\r\nstatic int oxnas_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct oxnas_gpio_bank *bank = pctl_to_bank(pctl, pin);\r\nunsigned int param = pinconf_to_config_param(*config);\r\nu32 mask = BIT(pin - bank->gpio_chip.base);\r\nint ret;\r\nu32 arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = regmap_read(pctl->regmap,\r\n(bank->id ?\r\nPINMUX_PULLUP_CTRL1 :\r\nPINMUX_PULLUP_CTRL0),\r\n&arg);\r\nif (ret)\r\nreturn ret;\r\narg = !!(arg & mask);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int oxnas_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned int num_configs)\r\n{\r\nstruct oxnas_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct oxnas_gpio_bank *bank = pctl_to_bank(pctl, pin);\r\nunsigned int param;\r\nu32 arg;\r\nunsigned int i;\r\nu32 offset = pin - bank->gpio_chip.base;\r\nu32 mask = BIT(offset);\r\ndev_dbg(pctl->dev, "setting pin %d bank %d mask 0x%x\n",\r\npin, bank->gpio_chip.base, mask);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ndev_dbg(pctl->dev, " pullup\n");\r\nregmap_write_bits(pctl->regmap,\r\n(bank->id ?\r\nPINMUX_PULLUP_CTRL1 :\r\nPINMUX_PULLUP_CTRL0),\r\nmask, mask);\r\nbreak;\r\ndefault:\r\ndev_err(pctl->dev, "Property %u not supported\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void oxnas_gpio_irq_ack(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 mask = BIT(data->hwirq);\r\nwritel(mask, bank->reg_base + IRQ_PENDING);\r\n}\r\nstatic void oxnas_gpio_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nunsigned int type = irqd_get_trigger_type(data);\r\nu32 mask = BIT(data->hwirq);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nwritel(readl(bank->reg_base + RE_IRQ_ENABLE) & ~mask,\r\nbank->reg_base + RE_IRQ_ENABLE);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nwritel(readl(bank->reg_base + FE_IRQ_ENABLE) & ~mask,\r\nbank->reg_base + FE_IRQ_ENABLE);\r\n}\r\nstatic void oxnas_gpio_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(chip);\r\nunsigned int type = irqd_get_trigger_type(data);\r\nu32 mask = BIT(data->hwirq);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nwritel(readl(bank->reg_base + RE_IRQ_ENABLE) | mask,\r\nbank->reg_base + RE_IRQ_ENABLE);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nwritel(readl(bank->reg_base + FE_IRQ_ENABLE) | mask,\r\nbank->reg_base + FE_IRQ_ENABLE);\r\n}\r\nstatic unsigned int oxnas_gpio_irq_startup(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\noxnas_gpio_direction_input(chip, data->hwirq);\r\noxnas_gpio_irq_unmask(data);\r\nreturn 0;\r\n}\r\nstatic int oxnas_gpio_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nif ((type & (IRQ_TYPE_EDGE_RISING|IRQ_TYPE_EDGE_FALLING)) == 0)\r\nreturn -EINVAL;\r\nirq_set_handler_locked(data, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic void oxnas_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct oxnas_gpio_bank *bank = gpiochip_get_data(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long stat;\r\nunsigned int pin;\r\nchained_irq_enter(chip, desc);\r\nstat = readl(bank->reg_base + IRQ_PENDING);\r\nfor_each_set_bit(pin, &stat, BITS_PER_LONG)\r\ngeneric_handle_irq(irq_linear_revmap(gc->irqdomain, pin));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int oxnas_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct oxnas_pinctrl *pctl;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\npctl->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, pctl);\r\npctl->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"oxsemi,sys-ctrl");\r\nif (IS_ERR(pctl->regmap)) {\r\ndev_err(&pdev->dev, "failed to get sys ctrl regmap\n");\r\nreturn -ENODEV;\r\n}\r\npctl->pins = oxnas_pins;\r\npctl->npins = ARRAY_SIZE(oxnas_pins);\r\npctl->functions = oxnas_functions;\r\npctl->nfunctions = ARRAY_SIZE(oxnas_functions);\r\npctl->groups = oxnas_groups;\r\npctl->ngroups = ARRAY_SIZE(oxnas_groups);\r\npctl->gpio_banks = oxnas_gpio_banks;\r\npctl->nbanks = ARRAY_SIZE(oxnas_gpio_banks);\r\noxnas_pinctrl_desc.pins = pctl->pins;\r\noxnas_pinctrl_desc.npins = pctl->npins;\r\npctl->pctldev = pinctrl_register(&oxnas_pinctrl_desc,\r\n&pdev->dev, pctl);\r\nif (IS_ERR(pctl->pctldev)) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl device\n");\r\nreturn PTR_ERR(pctl->pctldev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int oxnas_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct of_phandle_args pinspec;\r\nstruct oxnas_gpio_bank *bank;\r\nunsigned int id, ngpios;\r\nint irq, ret;\r\nstruct resource *res;\r\nif (of_parse_phandle_with_fixed_args(np, "gpio-ranges",\r\n3, 0, &pinspec)) {\r\ndev_err(&pdev->dev, "gpio-ranges property not found\n");\r\nreturn -EINVAL;\r\n}\r\nid = pinspec.args[1] / PINS_PER_BANK;\r\nngpios = pinspec.args[2];\r\nif (id >= ARRAY_SIZE(oxnas_gpio_banks)) {\r\ndev_err(&pdev->dev, "invalid gpio-ranges base arg\n");\r\nreturn -EINVAL;\r\n}\r\nif (ngpios > PINS_PER_BANK) {\r\ndev_err(&pdev->dev, "invalid gpio-ranges count arg\n");\r\nreturn -EINVAL;\r\n}\r\nbank = &oxnas_gpio_banks[id];\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbank->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(bank->reg_base))\r\nreturn PTR_ERR(bank->reg_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "irq get failed\n");\r\nreturn irq;\r\n}\r\nbank->id = id;\r\nbank->gpio_chip.parent = &pdev->dev;\r\nbank->gpio_chip.of_node = np;\r\nbank->gpio_chip.ngpio = ngpios;\r\nret = gpiochip_add_data(&bank->gpio_chip, bank);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add GPIO chip %u: %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&bank->gpio_chip, &bank->irq_chip,\r\n0, handle_level_irq, IRQ_TYPE_NONE);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add IRQ chip %u: %d\n",\r\nid, ret);\r\ngpiochip_remove(&bank->gpio_chip);\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&bank->gpio_chip, &bank->irq_chip,\r\nirq, oxnas_gpio_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int __init oxnas_gpio_register(void)\r\n{\r\nreturn platform_driver_register(&oxnas_gpio_driver);\r\n}\r\nstatic int __init oxnas_pinctrl_register(void)\r\n{\r\nreturn platform_driver_register(&oxnas_pinctrl_driver);\r\n}
