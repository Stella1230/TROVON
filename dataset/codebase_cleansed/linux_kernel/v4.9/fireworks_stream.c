static int\r\ninit_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\nstruct cmp_connection *conn;\r\nenum cmp_direction c_dir;\r\nenum amdtp_stream_direction s_dir;\r\nint err;\r\nif (stream == &efw->tx_stream) {\r\nconn = &efw->out_conn;\r\nc_dir = CMP_OUTPUT;\r\ns_dir = AMDTP_IN_STREAM;\r\n} else {\r\nconn = &efw->in_conn;\r\nc_dir = CMP_INPUT;\r\ns_dir = AMDTP_OUT_STREAM;\r\n}\r\nerr = cmp_connection_init(conn, efw->unit, c_dir, 0);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_am824_init(stream, efw->unit, s_dir, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(stream);\r\ncmp_connection_destroy(conn);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\nstop_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\namdtp_stream_pcm_abort(stream);\r\namdtp_stream_stop(stream);\r\nif (stream == &efw->tx_stream)\r\ncmp_connection_break(&efw->out_conn);\r\nelse\r\ncmp_connection_break(&efw->in_conn);\r\n}\r\nstatic int\r\nstart_stream(struct snd_efw *efw, struct amdtp_stream *stream,\r\nunsigned int sampling_rate)\r\n{\r\nstruct cmp_connection *conn;\r\nunsigned int mode, pcm_channels, midi_ports;\r\nint err;\r\nerr = snd_efw_get_multiplier_mode(sampling_rate, &mode);\r\nif (err < 0)\r\ngoto end;\r\nif (stream == &efw->tx_stream) {\r\nconn = &efw->out_conn;\r\npcm_channels = efw->pcm_capture_channels[mode];\r\nmidi_ports = efw->midi_out_ports;\r\n} else {\r\nconn = &efw->in_conn;\r\npcm_channels = efw->pcm_playback_channels[mode];\r\nmidi_ports = efw->midi_in_ports;\r\n}\r\nerr = amdtp_am824_set_parameters(stream, sampling_rate,\r\npcm_channels, midi_ports, false);\r\nif (err < 0)\r\ngoto end;\r\nerr = cmp_connection_establish(conn,\r\namdtp_stream_get_max_payload(stream));\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_stream_start(stream,\r\nconn->resources.channel,\r\nconn->speed);\r\nif (err < 0) {\r\nstop_stream(efw, stream);\r\ngoto end;\r\n}\r\nif (!amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT)) {\r\nstop_stream(efw, stream);\r\nerr = -ETIMEDOUT;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\ndestroy_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\nstruct cmp_connection *conn;\r\nif (stream == &efw->tx_stream)\r\nconn = &efw->out_conn;\r\nelse\r\nconn = &efw->in_conn;\r\namdtp_stream_destroy(stream);\r\ncmp_connection_destroy(&efw->out_conn);\r\n}\r\nstatic int\r\ncheck_connection_used_by_others(struct snd_efw *efw, struct amdtp_stream *s)\r\n{\r\nstruct cmp_connection *conn;\r\nbool used;\r\nint err;\r\nif (s == &efw->tx_stream)\r\nconn = &efw->out_conn;\r\nelse\r\nconn = &efw->in_conn;\r\nerr = cmp_connection_check_used(conn, &used);\r\nif ((err >= 0) && used && !amdtp_stream_running(s)) {\r\ndev_err(&efw->unit->device,\r\n"Connection established by others: %cPCR[%d]\n",\r\n(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\r\nconn->pcr_index);\r\nerr = -EBUSY;\r\n}\r\nreturn err;\r\n}\r\nint snd_efw_stream_init_duplex(struct snd_efw *efw)\r\n{\r\nint err;\r\nerr = init_stream(efw, &efw->tx_stream);\r\nif (err < 0)\r\ngoto end;\r\nefw->tx_stream.flags |= CIP_EMPTY_WITH_TAG0;\r\nefw->tx_stream.flags |= CIP_DBC_IS_END_EVENT;\r\nefw->tx_stream.flags |= CIP_SKIP_DBC_ZERO_CHECK;\r\nif (efw->is_fireworks3 &&\r\n(efw->firmware_version == 0x5070000 ||\r\nefw->firmware_version == 0x5070300 ||\r\nefw->firmware_version == 0x5080000))\r\nefw->tx_stream.tx_first_dbc = 0x02;\r\nif (efw->is_af9)\r\nefw->tx_stream.flags |= CIP_WRONG_DBS;\r\nif (efw->firmware_version == 0x5050000)\r\nefw->tx_stream.tx_dbc_interval = 8;\r\nerr = init_stream(efw, &efw->rx_stream);\r\nif (err < 0) {\r\ndestroy_stream(efw, &efw->tx_stream);\r\ngoto end;\r\n}\r\nerr = snd_efw_command_set_tx_mode(efw, SND_EFW_TRANSPORT_MODE_IEC61883);\r\nif (err < 0) {\r\ndestroy_stream(efw, &efw->tx_stream);\r\ndestroy_stream(efw, &efw->rx_stream);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_efw_stream_start_duplex(struct snd_efw *efw, unsigned int rate)\r\n{\r\nunsigned int curr_rate;\r\nint err = 0;\r\nif (efw->playback_substreams == 0 && efw->capture_substreams == 0)\r\ngoto end;\r\nerr = check_connection_used_by_others(efw, &efw->rx_stream);\r\nif (err < 0)\r\ngoto end;\r\nif (amdtp_streaming_error(&efw->tx_stream))\r\nstop_stream(efw, &efw->tx_stream);\r\nif (amdtp_streaming_error(&efw->rx_stream))\r\nstop_stream(efw, &efw->rx_stream);\r\nerr = snd_efw_command_get_sampling_rate(efw, &curr_rate);\r\nif (err < 0)\r\ngoto end;\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (rate != curr_rate) {\r\nstop_stream(efw, &efw->tx_stream);\r\nstop_stream(efw, &efw->rx_stream);\r\n}\r\nif (!amdtp_stream_running(&efw->rx_stream)) {\r\nerr = snd_efw_command_set_sampling_rate(efw, rate);\r\nif (err < 0)\r\ngoto end;\r\nerr = start_stream(efw, &efw->rx_stream, rate);\r\nif (err < 0) {\r\ndev_err(&efw->unit->device,\r\n"fail to start AMDTP master stream:%d\n", err);\r\ngoto end;\r\n}\r\n}\r\nif (efw->capture_substreams > 0 &&\r\n!amdtp_stream_running(&efw->tx_stream)) {\r\nerr = start_stream(efw, &efw->tx_stream, rate);\r\nif (err < 0) {\r\ndev_err(&efw->unit->device,\r\n"fail to start AMDTP slave stream:%d\n", err);\r\nstop_stream(efw, &efw->rx_stream);\r\n}\r\n}\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_efw_stream_stop_duplex(struct snd_efw *efw)\r\n{\r\nif (efw->capture_substreams == 0) {\r\nstop_stream(efw, &efw->tx_stream);\r\nif (efw->playback_substreams == 0)\r\nstop_stream(efw, &efw->rx_stream);\r\n}\r\n}\r\nvoid snd_efw_stream_update_duplex(struct snd_efw *efw)\r\n{\r\nif (cmp_connection_update(&efw->out_conn) < 0 ||\r\ncmp_connection_update(&efw->in_conn) < 0) {\r\nstop_stream(efw, &efw->rx_stream);\r\nstop_stream(efw, &efw->tx_stream);\r\n} else {\r\namdtp_stream_update(&efw->rx_stream);\r\namdtp_stream_update(&efw->tx_stream);\r\n}\r\n}\r\nvoid snd_efw_stream_destroy_duplex(struct snd_efw *efw)\r\n{\r\ndestroy_stream(efw, &efw->rx_stream);\r\ndestroy_stream(efw, &efw->tx_stream);\r\n}\r\nvoid snd_efw_stream_lock_changed(struct snd_efw *efw)\r\n{\r\nefw->dev_lock_changed = true;\r\nwake_up(&efw->hwdep_wait);\r\n}\r\nint snd_efw_stream_lock_try(struct snd_efw *efw)\r\n{\r\nint err;\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (efw->dev_lock_count++ == 0)\r\nsnd_efw_stream_lock_changed(efw);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&efw->lock);\r\nreturn err;\r\n}\r\nvoid snd_efw_stream_lock_release(struct snd_efw *efw)\r\n{\r\nspin_lock_irq(&efw->lock);\r\nif (WARN_ON(efw->dev_lock_count <= 0))\r\ngoto end;\r\nif (--efw->dev_lock_count == 0)\r\nsnd_efw_stream_lock_changed(efw);\r\nend:\r\nspin_unlock_irq(&efw->lock);\r\n}
