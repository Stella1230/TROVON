static bool halbtc_is_bt_coexist_available(struct btc_coexist *btcoexist)\r\n{\r\nif (!btcoexist->binded || NULL == btcoexist->adapter)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool halbtc_is_wifi_busy(struct rtl_priv *rtlpriv)\r\n{\r\nif (rtlpriv->link_info.busytraffic)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void halbtc_dbg_init(void)\r\n{\r\nu8 i;\r\nfor (i = 0; i < BTC_MSG_MAX; i++)\r\nbtc_dbg_type[i] = 0;\r\nbtc_dbg_type[BTC_MSG_INTERFACE] =\r\n0;\r\nbtc_dbg_type[BTC_MSG_ALGORITHM] =\r\n0;\r\n}\r\nstatic bool halbtc_is_bt40(struct rtl_priv *adapter)\r\n{\r\nstruct rtl_priv *rtlpriv = adapter;\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nbool is_ht40 = true;\r\nenum ht_channel_width bw = rtlphy->current_chan_bw;\r\nif (bw == HT_CHANNEL_WIDTH_20)\r\nis_ht40 = false;\r\nelse if (bw == HT_CHANNEL_WIDTH_20_40)\r\nis_ht40 = true;\r\nreturn is_ht40;\r\n}\r\nstatic bool halbtc_legacy(struct rtl_priv *adapter)\r\n{\r\nstruct rtl_priv *rtlpriv = adapter;\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nbool is_legacy = false;\r\nif ((mac->mode == WIRELESS_MODE_B) || (mac->mode == WIRELESS_MODE_G))\r\nis_legacy = true;\r\nreturn is_legacy;\r\n}\r\nbool halbtc_is_wifi_uplink(struct rtl_priv *adapter)\r\n{\r\nstruct rtl_priv *rtlpriv = adapter;\r\nif (rtlpriv->link_info.tx_busy_traffic)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic u32 halbtc_get_wifi_bw(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv =\r\n(struct rtl_priv *)btcoexist->adapter;\r\nu32 wifi_bw = BTC_WIFI_BW_HT20;\r\nif (halbtc_is_bt40(rtlpriv)) {\r\nwifi_bw = BTC_WIFI_BW_HT40;\r\n} else {\r\nif (halbtc_legacy(rtlpriv))\r\nwifi_bw = BTC_WIFI_BW_LEGACY;\r\nelse\r\nwifi_bw = BTC_WIFI_BW_HT20;\r\n}\r\nreturn wifi_bw;\r\n}\r\nstatic u8 halbtc_get_wifi_central_chnl(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu8 chnl = 1;\r\nif (rtlphy->current_channel != 0)\r\nchnl = rtlphy->current_channel;\r\nbtc_alg_dbg(ALGO_TRACE,\r\n"static halbtc_get_wifi_central_chnl:%d\n", chnl);\r\nreturn chnl;\r\n}\r\nstatic void halbtc_leave_lps(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv;\r\nstruct rtl_ps_ctl *ppsc;\r\nbool ap_enable = false;\r\nrtlpriv = btcoexist->adapter;\r\nppsc = rtl_psc(rtlpriv);\r\nbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,\r\n&ap_enable);\r\nif (ap_enable) {\r\npr_info("halbtc_leave_lps()<--dont leave lps under AP mode\n");\r\nreturn;\r\n}\r\nbtcoexist->bt_info.bt_ctrl_lps = true;\r\nbtcoexist->bt_info.bt_lps_on = false;\r\n}\r\nstatic void halbtc_enter_lps(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv;\r\nstruct rtl_ps_ctl *ppsc;\r\nbool ap_enable = false;\r\nrtlpriv = btcoexist->adapter;\r\nppsc = rtl_psc(rtlpriv);\r\nbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,\r\n&ap_enable);\r\nif (ap_enable) {\r\npr_info("halbtc_enter_lps()<--dont enter lps under AP mode\n");\r\nreturn;\r\n}\r\nbtcoexist->bt_info.bt_ctrl_lps = true;\r\nbtcoexist->bt_info.bt_lps_on = false;\r\n}\r\nstatic void halbtc_normal_lps(struct btc_coexist *btcoexist)\r\n{\r\nif (btcoexist->bt_info.bt_ctrl_lps) {\r\nbtcoexist->bt_info.bt_lps_on = false;\r\nbtcoexist->bt_info.bt_ctrl_lps = false;\r\n}\r\n}\r\nstatic void halbtc_leave_low_power(void)\r\n{\r\n}\r\nstatic void halbtc_nomal_low_power(void)\r\n{\r\n}\r\nstatic void halbtc_disable_low_power(void)\r\n{\r\n}\r\nstatic void halbtc_aggregation_check(void)\r\n{\r\n}\r\nstatic u32 halbtc_get_bt_patch_version(struct btc_coexist *btcoexist)\r\n{\r\nreturn 0;\r\n}\r\nstatic s32 halbtc_get_wifi_rssi(struct rtl_priv *adapter)\r\n{\r\nstruct rtl_priv *rtlpriv = adapter;\r\ns32 undec_sm_pwdb = 0;\r\nif (rtlpriv->mac80211.link_state >= MAC80211_LINKED)\r\nundec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;\r\nelse\r\nundec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;\r\nreturn undec_sm_pwdb;\r\n}\r\nstatic bool halbtc_get(void *void_btcoexist, u8 get_type, void *out_buf)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)void_btcoexist;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nbool *bool_tmp = (bool *)out_buf;\r\nint *s32_tmp = (int *)out_buf;\r\nu32 *u32_tmp = (u32 *)out_buf;\r\nu8 *u8_tmp = (u8 *)out_buf;\r\nbool tmp = false;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn false;\r\nswitch (get_type) {\r\ncase BTC_GET_BL_HS_OPERATION:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_HS_CONNECTING:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_CONNECTED:\r\nif (rtlpriv->mac80211.link_state >= MAC80211_LINKED)\r\ntmp = true;\r\n*bool_tmp = tmp;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_BUSY:\r\nif (halbtc_is_wifi_busy(rtlpriv))\r\n*bool_tmp = true;\r\nelse\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_SCAN:\r\nif (mac->act_scanning)\r\n*bool_tmp = true;\r\nelse\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_LINK:\r\nif (mac->link_state == MAC80211_LINKING)\r\n*bool_tmp = true;\r\nelse\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_ROAM:\r\nif (mac->link_state == MAC80211_LINKING)\r\n*bool_tmp = true;\r\nelse\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_4_WAY_PROGRESS:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_UNDER_5G:\r\n*bool_tmp = false;\r\ncase BTC_GET_BL_WIFI_DHCP:\r\nbreak;\r\ncase BTC_GET_BL_WIFI_SOFTAP_IDLE:\r\n*bool_tmp = true;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_SOFTAP_LINKING:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_IN_EARLY_SUSPEND:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_AP_MODE_ENABLE:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_ENABLE_ENCRYPTION:\r\nif (NO_ENCRYPTION == rtlpriv->sec.pairwise_enc_algorithm)\r\n*bool_tmp = false;\r\nelse\r\n*bool_tmp = true;\r\nbreak;\r\ncase BTC_GET_BL_WIFI_UNDER_B_MODE:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_BL_EXT_SWITCH:\r\n*bool_tmp = false;\r\nbreak;\r\ncase BTC_GET_S4_WIFI_RSSI:\r\n*s32_tmp = halbtc_get_wifi_rssi(rtlpriv);\r\nbreak;\r\ncase BTC_GET_S4_HS_RSSI:\r\n*s32_tmp = halbtc_get_wifi_rssi(rtlpriv);\r\nbreak;\r\ncase BTC_GET_U4_WIFI_BW:\r\n*u32_tmp = halbtc_get_wifi_bw(btcoexist);\r\nbreak;\r\ncase BTC_GET_U4_WIFI_TRAFFIC_DIRECTION:\r\nif (halbtc_is_wifi_uplink(rtlpriv))\r\n*u32_tmp = BTC_WIFI_TRAFFIC_TX;\r\nelse\r\n*u32_tmp = BTC_WIFI_TRAFFIC_RX;\r\nbreak;\r\ncase BTC_GET_U4_WIFI_FW_VER:\r\n*u32_tmp = rtlhal->fw_version;\r\nbreak;\r\ncase BTC_GET_U4_BT_PATCH_VER:\r\n*u32_tmp = halbtc_get_bt_patch_version(btcoexist);\r\nbreak;\r\ncase BTC_GET_U1_WIFI_DOT11_CHNL:\r\n*u8_tmp = rtlphy->current_channel;\r\nbreak;\r\ncase BTC_GET_U1_WIFI_CENTRAL_CHNL:\r\n*u8_tmp = halbtc_get_wifi_central_chnl(btcoexist);\r\nbreak;\r\ncase BTC_GET_U1_WIFI_HS_CHNL:\r\n*u8_tmp = 1;\r\nbreak;\r\ncase BTC_GET_U1_MAC_PHY_MODE:\r\n*u8_tmp = BTC_MP_UNKNOWN;\r\nbreak;\r\ncase BTC_GET_U1_LPS_MODE:\r\n*u8_tmp = btcoexist->pwr_mode_val[0];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic bool halbtc_set(void *void_btcoexist, u8 set_type, void *in_buf)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)void_btcoexist;\r\nbool *bool_tmp = (bool *)in_buf;\r\nu8 *u8_tmp = (u8 *)in_buf;\r\nu32 *u32_tmp = (u32 *)in_buf;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn false;\r\nswitch (set_type) {\r\ncase BTC_SET_BL_BT_DISABLE:\r\nbtcoexist->bt_info.bt_disabled = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_BT_TRAFFIC_BUSY:\r\nbtcoexist->bt_info.bt_busy = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_BT_LIMITED_DIG:\r\nbtcoexist->bt_info.limited_dig = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_FORCE_TO_ROAM:\r\nbtcoexist->bt_info.force_to_roam = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_TO_REJ_AP_AGG_PKT:\r\nbtcoexist->bt_info.reject_agg_pkt = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_BT_CTRL_AGG_SIZE:\r\nbtcoexist->bt_info.bt_ctrl_buf_size = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_BL_INC_SCAN_DEV_NUM:\r\nbtcoexist->bt_info.increase_scan_dev_num = *bool_tmp;\r\nbreak;\r\ncase BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON:\r\nbtcoexist->bt_info.rssi_adjust_for_agc_table_on = *u8_tmp;\r\nbreak;\r\ncase BTC_SET_U1_AGG_BUF_SIZE:\r\nbtcoexist->bt_info.agg_buf_size = *u8_tmp;\r\nbreak;\r\ncase BTC_SET_ACT_GET_BT_RSSI:\r\nbreak;\r\ncase BTC_SET_ACT_AGGREGATE_CTRL:\r\nhalbtc_aggregation_check();\r\nbreak;\r\ncase BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE:\r\nbtcoexist->bt_info.rssi_adjust_for_1ant_coex_type = *u8_tmp;\r\nbreak;\r\ncase BTC_SET_UI_SCAN_SIG_COMPENSATION:\r\nbreak;\r\ncase BTC_SET_U1_1ANT_LPS:\r\nbtcoexist->bt_info.lps_val = *u8_tmp;\r\nbreak;\r\ncase BTC_SET_U1_1ANT_RPWM:\r\nbtcoexist->bt_info.rpwm_val = *u8_tmp;\r\nbreak;\r\ncase BTC_SET_ACT_LEAVE_LPS:\r\nhalbtc_leave_lps(btcoexist);\r\nbreak;\r\ncase BTC_SET_ACT_ENTER_LPS:\r\nhalbtc_enter_lps(btcoexist);\r\nbreak;\r\ncase BTC_SET_ACT_NORMAL_LPS:\r\nhalbtc_normal_lps(btcoexist);\r\nbreak;\r\ncase BTC_SET_ACT_DISABLE_LOW_POWER:\r\nhalbtc_disable_low_power();\r\nbreak;\r\ncase BTC_SET_ACT_UPDATE_ra_mask:\r\nbtcoexist->bt_info.ra_mask = *u32_tmp;\r\nbreak;\r\ncase BTC_SET_ACT_SEND_MIMO_PS:\r\nbreak;\r\ncase BTC_SET_ACT_INC_FORCE_EXEC_PWR_CMD_CNT:\r\nbtcoexist->bt_info.force_exec_pwr_cmd_cnt++;\r\nbreak;\r\ncase BTC_SET_ACT_CTRL_BT_INFO:\r\nbreak;\r\ncase BTC_SET_ACT_CTRL_BT_COEX:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic void halbtc_display_coex_statistics(struct btc_coexist *btcoexist)\r\n{\r\n}\r\nstatic void halbtc_display_bt_link_info(struct btc_coexist *btcoexist)\r\n{\r\n}\r\nstatic void halbtc_display_bt_fw_info(struct btc_coexist *btcoexist)\r\n{\r\n}\r\nstatic void halbtc_display_fw_pwr_mode_cmd(struct btc_coexist *btcoexist)\r\n{\r\n}\r\nstatic u8 halbtc_read_1byte(void *bt_context, u32 reg_addr)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nreturn rtl_read_byte(rtlpriv, reg_addr);\r\n}\r\nstatic u16 halbtc_read_2byte(void *bt_context, u32 reg_addr)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nreturn rtl_read_word(rtlpriv, reg_addr);\r\n}\r\nstatic u32 halbtc_read_4byte(void *bt_context, u32 reg_addr)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nreturn rtl_read_dword(rtlpriv, reg_addr);\r\n}\r\nstatic void halbtc_write_1byte(void *bt_context, u32 reg_addr, u32 data)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtl_write_byte(rtlpriv, reg_addr, data);\r\n}\r\nstatic void halbtc_bitmask_write_1byte(void *bt_context, u32 reg_addr,\r\nu32 bit_mask, u8 data)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nu8 original_value, bit_shift = 0;\r\nu8 i;\r\nif (bit_mask != MASKDWORD) {\r\noriginal_value = rtl_read_byte(rtlpriv, reg_addr);\r\nfor (i = 0; i <= 7; i++) {\r\nif ((bit_mask>>i) & 0x1)\r\nbreak;\r\n}\r\nbit_shift = i;\r\ndata = (original_value & (~bit_mask)) |\r\n((data << bit_shift) & bit_mask);\r\n}\r\nrtl_write_byte(rtlpriv, reg_addr, data);\r\n}\r\nstatic void halbtc_write_2byte(void *bt_context, u32 reg_addr, u16 data)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtl_write_word(rtlpriv, reg_addr, data);\r\n}\r\nstatic void halbtc_write_4byte(void *bt_context, u32 reg_addr, u32 data)\r\n{\r\nstruct btc_coexist *btcoexist =\r\n(struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtl_write_dword(rtlpriv, reg_addr, data);\r\n}\r\nstatic void halbtc_set_bbreg(void *bt_context, u32 reg_addr, u32 bit_mask,\r\nu32 data)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtl_set_bbreg(rtlpriv->mac80211.hw, reg_addr, bit_mask, data);\r\n}\r\nstatic u32 halbtc_get_bbreg(void *bt_context, u32 reg_addr, u32 bit_mask)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nreturn rtl_get_bbreg(rtlpriv->mac80211.hw, reg_addr, bit_mask);\r\n}\r\nstatic void halbtc_set_rfreg(void *bt_context, u8 rf_path, u32 reg_addr,\r\nu32 bit_mask, u32 data)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtl_set_rfreg(rtlpriv->mac80211.hw, rf_path, reg_addr, bit_mask, data);\r\n}\r\nstatic u32 halbtc_get_rfreg(void *bt_context, u8 rf_path, u32 reg_addr,\r\nu32 bit_mask)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nreturn rtl_get_rfreg(rtlpriv->mac80211.hw, rf_path, reg_addr, bit_mask);\r\n}\r\nstatic void halbtc_fill_h2c_cmd(void *bt_context, u8 element_id,\r\nu32 cmd_len, u8 *cmd_buf)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nrtlpriv->cfg->ops->fill_h2c_cmd(rtlpriv->mac80211.hw, element_id,\r\ncmd_len, cmd_buf);\r\n}\r\nstatic void halbtc_display_dbg_msg(void *bt_context, u8 disp_type)\r\n{\r\nstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\r\nswitch (disp_type) {\r\ncase BTC_DBG_DISP_COEX_STATISTICS:\r\nhalbtc_display_coex_statistics(btcoexist);\r\nbreak;\r\ncase BTC_DBG_DISP_BT_LINK_INFO:\r\nhalbtc_display_bt_link_info(btcoexist);\r\nbreak;\r\ncase BTC_DBG_DISP_BT_FW_VER:\r\nhalbtc_display_bt_fw_info(btcoexist);\r\nbreak;\r\ncase BTC_DBG_DISP_FW_PWR_MODE_CMD:\r\nhalbtc_display_fw_pwr_mode_cmd(btcoexist);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbool exhalbtc_initlize_variables(struct rtl_priv *adapter)\r\n{\r\nstruct btc_coexist *btcoexist = &gl_bt_coexist;\r\nbtcoexist->statistics.cnt_bind++;\r\nhalbtc_dbg_init();\r\nif (btcoexist->binded)\r\nreturn false;\r\nelse\r\nbtcoexist->binded = true;\r\nbtcoexist->chip_interface = BTC_INTF_UNKNOWN;\r\nif (NULL == btcoexist->adapter)\r\nbtcoexist->adapter = adapter;\r\nbtcoexist->stack_info.profile_notified = false;\r\nbtcoexist->btc_read_1byte = halbtc_read_1byte;\r\nbtcoexist->btc_write_1byte = halbtc_write_1byte;\r\nbtcoexist->btc_write_1byte_bitmask = halbtc_bitmask_write_1byte;\r\nbtcoexist->btc_read_2byte = halbtc_read_2byte;\r\nbtcoexist->btc_write_2byte = halbtc_write_2byte;\r\nbtcoexist->btc_read_4byte = halbtc_read_4byte;\r\nbtcoexist->btc_write_4byte = halbtc_write_4byte;\r\nbtcoexist->btc_set_bb_reg = halbtc_set_bbreg;\r\nbtcoexist->btc_get_bb_reg = halbtc_get_bbreg;\r\nbtcoexist->btc_set_rf_reg = halbtc_set_rfreg;\r\nbtcoexist->btc_get_rf_reg = halbtc_get_rfreg;\r\nbtcoexist->btc_fill_h2c = halbtc_fill_h2c_cmd;\r\nbtcoexist->btc_disp_dbg_msg = halbtc_display_dbg_msg;\r\nbtcoexist->btc_get = halbtc_get;\r\nbtcoexist->btc_set = halbtc_set;\r\nbtcoexist->bt_info.bt_ctrl_buf_size = false;\r\nbtcoexist->bt_info.agg_buf_size = 5;\r\nbtcoexist->bt_info.increase_scan_dev_num = false;\r\nreturn true;\r\n}\r\nvoid exhalbtc_init_hw_config(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_init_hw_config++;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_init_hwconfig(btcoexist);\r\n}\r\nvoid exhalbtc_init_coex_dm(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_init_coex_dm++;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_init_coex_dm(btcoexist);\r\nbtcoexist->initilized = true;\r\n}\r\nvoid exhalbtc_ips_notify(struct btc_coexist *btcoexist, u8 type)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 ips_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_ips_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nif (ERFOFF == type)\r\nips_type = BTC_IPS_ENTER;\r\nelse\r\nips_type = BTC_IPS_LEAVE;\r\nhalbtc_leave_low_power();\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_ips_notify(btcoexist, ips_type);\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_lps_notify(struct btc_coexist *btcoexist, u8 type)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 lps_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_lps_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nif (EACTIVE == type)\r\nlps_type = BTC_LPS_DISABLE;\r\nelse\r\nlps_type = BTC_LPS_ENABLE;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_lps_notify(btcoexist, lps_type);\r\n}\r\nvoid exhalbtc_scan_notify(struct btc_coexist *btcoexist, u8 type)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 scan_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_scan_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nif (type)\r\nscan_type = BTC_SCAN_START;\r\nelse\r\nscan_type = BTC_SCAN_FINISH;\r\nhalbtc_leave_low_power();\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_scan_notify(btcoexist, scan_type);\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_connect_notify(struct btc_coexist *btcoexist, u8 action)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 asso_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_connect_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nif (action)\r\nasso_type = BTC_ASSOCIATE_START;\r\nelse\r\nasso_type = BTC_ASSOCIATE_FINISH;\r\nhalbtc_leave_low_power();\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_connect_notify(btcoexist, asso_type);\r\n}\r\nvoid exhalbtc_mediastatus_notify(struct btc_coexist *btcoexist,\r\nenum rt_media_status media_status)\r\n{\r\nu8 status;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_media_status_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nif (RT_MEDIA_CONNECT == media_status)\r\nstatus = BTC_MEDIA_CONNECT;\r\nelse\r\nstatus = BTC_MEDIA_DISCONNECT;\r\nhalbtc_leave_low_power();\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_special_packet_notify(struct btc_coexist *btcoexist, u8 pkt_type)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 packet_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_special_packet_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\npacket_type = BTC_PACKET_DHCP;\r\nhalbtc_leave_low_power();\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_special_packet_notify(btcoexist,\r\npacket_type);\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_bt_info_notify(struct btc_coexist *btcoexist,\r\nu8 *tmp_buf, u8 length)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_bt_info_notify++;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_bt_info_notify(btcoexist, tmp_buf, length);\r\n}\r\nvoid exhalbtc_stack_operation_notify(struct btc_coexist *btcoexist, u8 type)\r\n{\r\nu8 stack_op_type;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_stack_operation_notify++;\r\nif (btcoexist->manual_control)\r\nreturn;\r\nstack_op_type = BTC_STACK_OP_NONE;\r\nhalbtc_leave_low_power();\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_halt_notify(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_halt_notify(btcoexist);\r\n}\r\nvoid exhalbtc_pnp_notify(struct btc_coexist *btcoexist, u8 pnp_state)\r\n{\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\n}\r\nvoid exhalbtc_periodical(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_periodical++;\r\nhalbtc_leave_low_power();\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_periodical(btcoexist);\r\nhalbtc_nomal_low_power();\r\n}\r\nvoid exhalbtc_dbg_control(struct btc_coexist *btcoexist,\r\nu8 code, u8 len, u8 *data)\r\n{\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->statistics.cnt_dbg_ctrl++;\r\n}\r\nvoid exhalbtc_stack_update_profile_info(void)\r\n{\r\n}\r\nvoid exhalbtc_update_min_bt_rssi(s8 bt_rssi)\r\n{\r\nstruct btc_coexist *btcoexist = &gl_bt_coexist;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->stack_info.min_bt_rssi = bt_rssi;\r\n}\r\nvoid exhalbtc_set_hci_version(u16 hci_version)\r\n{\r\nstruct btc_coexist *btcoexist = &gl_bt_coexist;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->stack_info.hci_version = hci_version;\r\n}\r\nvoid exhalbtc_set_bt_patch_version(u16 bt_hci_version, u16 bt_patch_version)\r\n{\r\nstruct btc_coexist *btcoexist = &gl_bt_coexist;\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nbtcoexist->bt_info.bt_real_fw_ver = bt_patch_version;\r\nbtcoexist->bt_info.bt_hci_ver = bt_hci_version;\r\n}\r\nvoid exhalbtc_set_bt_exist(bool bt_exist)\r\n{\r\ngl_bt_coexist.board_info.bt_exist = bt_exist;\r\n}\r\nvoid exhalbtc_set_chip_type(u8 chip_type)\r\n{\r\nswitch (chip_type) {\r\ndefault:\r\ncase BT_2WIRE:\r\ncase BT_ISSC_3WIRE:\r\ncase BT_ACCEL:\r\ncase BT_RTL8756:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_UNDEF;\r\nbreak;\r\ncase BT_CSR_BC4:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_CSR_BC4;\r\nbreak;\r\ncase BT_CSR_BC8:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_CSR_BC8;\r\nbreak;\r\ncase BT_RTL8723A:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_RTL8723A;\r\nbreak;\r\ncase BT_RTL8821A:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_RTL8821;\r\nbreak;\r\ncase BT_RTL8723B:\r\ngl_bt_coexist.board_info.bt_chip_type = BTC_CHIP_RTL8723B;\r\nbreak;\r\n}\r\n}\r\nvoid exhalbtc_set_ant_num(struct rtl_priv *rtlpriv, u8 type, u8 ant_num)\r\n{\r\nif (BT_COEX_ANT_TYPE_PG == type) {\r\ngl_bt_coexist.board_info.pg_ant_num = ant_num;\r\ngl_bt_coexist.board_info.btdm_ant_num = ant_num;\r\nif ((gl_bt_coexist.board_info.pg_ant_num == 2) &&\r\n(gl_bt_coexist.board_info.btdm_ant_num == 1))\r\ngl_bt_coexist.board_info.btdm_ant_pos =\r\nBTC_ANTENNA_AT_MAIN_PORT;\r\nelse\r\ngl_bt_coexist.board_info.btdm_ant_pos =\r\nBTC_ANTENNA_AT_MAIN_PORT;\r\n} else if (BT_COEX_ANT_TYPE_ANTDIV == type) {\r\ngl_bt_coexist.board_info.btdm_ant_num = ant_num;\r\ngl_bt_coexist.board_info.btdm_ant_pos =\r\nBTC_ANTENNA_AT_MAIN_PORT;\r\n} else if (type == BT_COEX_ANT_TYPE_DETECTED) {\r\ngl_bt_coexist.board_info.btdm_ant_num = ant_num;\r\nif (rtlpriv->cfg->mod_params->ant_sel == 1)\r\ngl_bt_coexist.board_info.btdm_ant_pos =\r\nBTC_ANTENNA_AT_AUX_PORT;\r\nelse\r\ngl_bt_coexist.board_info.btdm_ant_pos =\r\nBTC_ANTENNA_AT_MAIN_PORT;\r\n}\r\n}\r\nvoid exhalbtc_display_bt_coex_info(struct btc_coexist *btcoexist)\r\n{\r\nstruct rtl_priv *rtlpriv = btcoexist->adapter;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!halbtc_is_bt_coexist_available(btcoexist))\r\nreturn;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE)\r\nex_btc8723b2ant_display_coex_info(btcoexist);\r\n}
