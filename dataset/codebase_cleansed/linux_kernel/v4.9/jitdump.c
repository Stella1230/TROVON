static int\r\njit_emit_elf(char *filename,\r\nconst char *sym,\r\nuint64_t code_addr,\r\nconst void *code,\r\nint csize,\r\nvoid *debug,\r\nint nr_debug_entries)\r\n{\r\nint ret, fd;\r\nif (verbose > 0)\r\nfprintf(stderr, "write ELF image %s\n", filename);\r\nfd = open(filename, O_CREAT|O_TRUNC|O_WRONLY, 0644);\r\nif (fd == -1) {\r\npr_warning("cannot create jit ELF %s: %s\n", filename, strerror(errno));\r\nreturn -1;\r\n}\r\nret = jit_write_elf(fd, code_addr, sym, (const void *)code, csize, debug, nr_debug_entries);\r\nclose(fd);\r\nif (ret)\r\nunlink(filename);\r\nreturn ret;\r\n}\r\nstatic void\r\njit_close(struct jit_buf_desc *jd)\r\n{\r\nif (!(jd && jd->in))\r\nreturn;\r\nfunlockfile(jd->in);\r\nfclose(jd->in);\r\njd->in = NULL;\r\n}\r\nstatic int\r\njit_validate_events(struct perf_session *session)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(session->evlist, evsel) {\r\nif (evsel->attr.use_clockid == 0 || evsel->attr.clockid != CLOCK_MONOTONIC)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\njit_open(struct jit_buf_desc *jd, const char *name)\r\n{\r\nstruct jitheader header;\r\nstruct jr_prefix *prefix;\r\nssize_t bs, bsz = 0;\r\nvoid *n, *buf = NULL;\r\nint ret, retval = -1;\r\njd->in = fopen(name, "r");\r\nif (!jd->in)\r\nreturn -1;\r\nbsz = hmax(sizeof(header), sizeof(*prefix));\r\nbuf = malloc(bsz);\r\nif (!buf)\r\ngoto error;\r\nflockfile(jd->in);\r\nret = fread(buf, sizeof(header), 1, jd->in);\r\nif (ret != 1)\r\ngoto error;\r\nmemcpy(&header, buf, sizeof(header));\r\nif (header.magic != JITHEADER_MAGIC) {\r\nif (header.magic != JITHEADER_MAGIC_SW)\r\ngoto error;\r\njd->needs_bswap = true;\r\n}\r\nif (jd->needs_bswap) {\r\nheader.version = bswap_32(header.version);\r\nheader.total_size = bswap_32(header.total_size);\r\nheader.pid = bswap_32(header.pid);\r\nheader.elf_mach = bswap_32(header.elf_mach);\r\nheader.timestamp = bswap_64(header.timestamp);\r\nheader.flags = bswap_64(header.flags);\r\n}\r\njd->use_arch_timestamp = header.flags & JITDUMP_FLAGS_ARCH_TIMESTAMP;\r\nif (verbose > 2)\r\npr_debug("version=%u\nhdr.size=%u\nts=0x%llx\npid=%d\nelf_mach=%d\nuse_arch_timestamp=%d\n",\r\nheader.version,\r\nheader.total_size,\r\n(unsigned long long)header.timestamp,\r\nheader.pid,\r\nheader.elf_mach,\r\njd->use_arch_timestamp);\r\nif (header.flags & JITDUMP_FLAGS_RESERVED) {\r\npr_err("jitdump file contains invalid or unsupported flags 0x%llx\n",\r\n(unsigned long long)header.flags & JITDUMP_FLAGS_RESERVED);\r\ngoto error;\r\n}\r\nif (jd->use_arch_timestamp && !jd->session->time_conv.time_mult) {\r\npr_err("jitdump file uses arch timestamps but there is no timestamp conversion\n");\r\ngoto error;\r\n}\r\nif (!jd->use_arch_timestamp && jit_validate_events(jd->session)) {\r\npr_err("error, jitted code must be sampled with perf record -k 1\n");\r\ngoto error;\r\n}\r\nbs = header.total_size - sizeof(header);\r\nif (bs > bsz) {\r\nn = realloc(buf, bs);\r\nif (!n)\r\ngoto error;\r\nbsz = bs;\r\nbuf = n;\r\nret = fread(buf, bs - bsz, 1, jd->in);\r\nif (ret != 1)\r\ngoto error;\r\n}\r\nstrcpy(jd->dir, name);\r\ndirname(jd->dir);\r\nreturn 0;\r\nerror:\r\nfunlockfile(jd->in);\r\nfclose(jd->in);\r\nreturn retval;\r\n}\r\nstatic union jr_entry *\r\njit_get_next_entry(struct jit_buf_desc *jd)\r\n{\r\nstruct jr_prefix *prefix;\r\nunion jr_entry *jr;\r\nvoid *addr;\r\nsize_t bs, size;\r\nint id, ret;\r\nif (!(jd && jd->in))\r\nreturn NULL;\r\nif (jd->buf == NULL) {\r\nsize_t sz = getpagesize();\r\nif (sz < sizeof(*prefix))\r\nsz = sizeof(*prefix);\r\njd->buf = malloc(sz);\r\nif (jd->buf == NULL)\r\nreturn NULL;\r\njd->bufsize = sz;\r\n}\r\nprefix = jd->buf;\r\nret = fread(prefix, sizeof(*prefix), 1, jd->in);\r\nif (ret != 1)\r\nreturn NULL;\r\nif (jd->needs_bswap) {\r\nprefix->id = bswap_32(prefix->id);\r\nprefix->total_size = bswap_32(prefix->total_size);\r\nprefix->timestamp = bswap_64(prefix->timestamp);\r\n}\r\nid = prefix->id;\r\nsize = prefix->total_size;\r\nbs = (size_t)size;\r\nif (bs < sizeof(*prefix))\r\nreturn NULL;\r\nif (id >= JIT_CODE_MAX) {\r\npr_warning("next_entry: unknown prefix %d, skipping\n", id);\r\nreturn NULL;\r\n}\r\nif (bs > jd->bufsize) {\r\nvoid *n;\r\nn = realloc(jd->buf, bs);\r\nif (!n)\r\nreturn NULL;\r\njd->buf = n;\r\njd->bufsize = bs;\r\n}\r\naddr = ((void *)jd->buf) + sizeof(*prefix);\r\nret = fread(addr, bs - sizeof(*prefix), 1, jd->in);\r\nif (ret != 1)\r\nreturn NULL;\r\njr = (union jr_entry *)jd->buf;\r\nswitch(id) {\r\ncase JIT_CODE_DEBUG_INFO:\r\nif (jd->needs_bswap) {\r\nuint64_t n;\r\njr->info.code_addr = bswap_64(jr->info.code_addr);\r\njr->info.nr_entry = bswap_64(jr->info.nr_entry);\r\nfor (n = 0 ; n < jr->info.nr_entry; n++) {\r\njr->info.entries[n].addr = bswap_64(jr->info.entries[n].addr);\r\njr->info.entries[n].lineno = bswap_32(jr->info.entries[n].lineno);\r\njr->info.entries[n].discrim = bswap_32(jr->info.entries[n].discrim);\r\n}\r\n}\r\nbreak;\r\ncase JIT_CODE_CLOSE:\r\nbreak;\r\ncase JIT_CODE_LOAD:\r\nif (jd->needs_bswap) {\r\njr->load.pid = bswap_32(jr->load.pid);\r\njr->load.tid = bswap_32(jr->load.tid);\r\njr->load.vma = bswap_64(jr->load.vma);\r\njr->load.code_addr = bswap_64(jr->load.code_addr);\r\njr->load.code_size = bswap_64(jr->load.code_size);\r\njr->load.code_index= bswap_64(jr->load.code_index);\r\n}\r\njd->code_load_count++;\r\nbreak;\r\ncase JIT_CODE_MOVE:\r\nif (jd->needs_bswap) {\r\njr->move.pid = bswap_32(jr->move.pid);\r\njr->move.tid = bswap_32(jr->move.tid);\r\njr->move.vma = bswap_64(jr->move.vma);\r\njr->move.old_code_addr = bswap_64(jr->move.old_code_addr);\r\njr->move.new_code_addr = bswap_64(jr->move.new_code_addr);\r\njr->move.code_size = bswap_64(jr->move.code_size);\r\njr->move.code_index = bswap_64(jr->move.code_index);\r\n}\r\nbreak;\r\ncase JIT_CODE_MAX:\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn jr;\r\n}\r\nstatic int\r\njit_inject_event(struct jit_buf_desc *jd, union perf_event *event)\r\n{\r\nssize_t size;\r\nsize = perf_data_file__write(jd->output, event, event->header.size);\r\nif (size < 0)\r\nreturn -1;\r\njd->bytes_written += size;\r\nreturn 0;\r\n}\r\nstatic uint64_t convert_timestamp(struct jit_buf_desc *jd, uint64_t timestamp)\r\n{\r\nstruct perf_tsc_conversion tc;\r\nif (!jd->use_arch_timestamp)\r\nreturn timestamp;\r\ntc.time_shift = jd->session->time_conv.time_shift;\r\ntc.time_mult = jd->session->time_conv.time_mult;\r\ntc.time_zero = jd->session->time_conv.time_zero;\r\nif (!tc.time_mult)\r\nreturn 0;\r\nreturn tsc_to_perf_time(timestamp, &tc);\r\n}\r\nstatic int jit_repipe_code_load(struct jit_buf_desc *jd, union jr_entry *jr)\r\n{\r\nstruct perf_sample sample;\r\nunion perf_event *event;\r\nstruct perf_tool *tool = jd->session->tool;\r\nuint64_t code, addr;\r\nuintptr_t uaddr;\r\nchar *filename;\r\nstruct stat st;\r\nsize_t size;\r\nu16 idr_size;\r\nconst char *sym;\r\nuint32_t count;\r\nint ret, csize;\r\npid_t pid, tid;\r\nstruct {\r\nu32 pid, tid;\r\nu64 time;\r\n} *id;\r\npid = jr->load.pid;\r\ntid = jr->load.tid;\r\ncsize = jr->load.code_size;\r\naddr = jr->load.code_addr;\r\nsym = (void *)((unsigned long)jr + sizeof(jr->load));\r\ncode = (unsigned long)jr + jr->load.p.total_size - csize;\r\ncount = jr->load.code_index;\r\nidr_size = jd->machine->id_hdr_size;\r\nevent = calloc(1, sizeof(*event) + idr_size);\r\nif (!event)\r\nreturn -1;\r\nfilename = event->mmap2.filename;\r\nsize = snprintf(filename, PATH_MAX, "%s/jitted-%d-%u.so",\r\njd->dir,\r\npid,\r\ncount);\r\nsize++;\r\nsize = PERF_ALIGN(size, sizeof(u64));\r\nuaddr = (uintptr_t)code;\r\nret = jit_emit_elf(filename, sym, addr, (const void *)uaddr, csize, jd->debug_data, jd->nr_debug_entries);\r\nif (jd->debug_data && jd->nr_debug_entries) {\r\nfree(jd->debug_data);\r\njd->debug_data = NULL;\r\njd->nr_debug_entries = 0;\r\n}\r\nif (ret) {\r\nfree(event);\r\nreturn -1;\r\n}\r\nif (stat(filename, &st))\r\nmemset(&st, 0, sizeof(st));\r\nevent->mmap2.header.type = PERF_RECORD_MMAP2;\r\nevent->mmap2.header.misc = PERF_RECORD_MISC_USER;\r\nevent->mmap2.header.size = (sizeof(event->mmap2) -\r\n(sizeof(event->mmap2.filename) - size) + idr_size);\r\nevent->mmap2.pgoff = GEN_ELF_TEXT_OFFSET;\r\nevent->mmap2.start = addr;\r\nevent->mmap2.len = csize;\r\nevent->mmap2.pid = pid;\r\nevent->mmap2.tid = tid;\r\nevent->mmap2.ino = st.st_ino;\r\nevent->mmap2.maj = major(st.st_dev);\r\nevent->mmap2.min = minor(st.st_dev);\r\nevent->mmap2.prot = st.st_mode;\r\nevent->mmap2.flags = MAP_SHARED;\r\nevent->mmap2.ino_generation = 1;\r\nid = (void *)((unsigned long)event + event->mmap.header.size - idr_size);\r\nif (jd->sample_type & PERF_SAMPLE_TID) {\r\nid->pid = pid;\r\nid->tid = tid;\r\n}\r\nif (jd->sample_type & PERF_SAMPLE_TIME)\r\nid->time = convert_timestamp(jd, jr->load.p.timestamp);\r\nmemset(&sample, 0, sizeof(sample));\r\nsample.cpumode = PERF_RECORD_MISC_USER;\r\nsample.pid = pid;\r\nsample.tid = tid;\r\nsample.time = id->time;\r\nsample.ip = addr;\r\nret = perf_event__process_mmap2(tool, event, &sample, jd->machine);\r\nif (ret)\r\nreturn ret;\r\nret = jit_inject_event(jd, event);\r\nif (!ret)\r\nbuild_id__mark_dso_hit(tool, event, &sample, NULL, jd->machine);\r\nreturn ret;\r\n}\r\nstatic int jit_repipe_code_move(struct jit_buf_desc *jd, union jr_entry *jr)\r\n{\r\nstruct perf_sample sample;\r\nunion perf_event *event;\r\nstruct perf_tool *tool = jd->session->tool;\r\nchar *filename;\r\nsize_t size;\r\nstruct stat st;\r\nu16 idr_size;\r\nint ret;\r\npid_t pid, tid;\r\nstruct {\r\nu32 pid, tid;\r\nu64 time;\r\n} *id;\r\npid = jr->move.pid;\r\ntid = jr->move.tid;\r\nidr_size = jd->machine->id_hdr_size;\r\nevent = calloc(1, sizeof(*event) + 16);\r\nif (!event)\r\nreturn -1;\r\nfilename = event->mmap2.filename;\r\nsize = snprintf(filename, PATH_MAX, "%s/jitted-%d-%"PRIu64,\r\njd->dir,\r\npid,\r\njr->move.code_index);\r\nsize++;\r\nif (stat(filename, &st))\r\nmemset(&st, 0, sizeof(st));\r\nsize = PERF_ALIGN(size, sizeof(u64));\r\nevent->mmap2.header.type = PERF_RECORD_MMAP2;\r\nevent->mmap2.header.misc = PERF_RECORD_MISC_USER;\r\nevent->mmap2.header.size = (sizeof(event->mmap2) -\r\n(sizeof(event->mmap2.filename) - size) + idr_size);\r\nevent->mmap2.pgoff = GEN_ELF_TEXT_OFFSET;\r\nevent->mmap2.start = jr->move.new_code_addr;\r\nevent->mmap2.len = jr->move.code_size;\r\nevent->mmap2.pid = pid;\r\nevent->mmap2.tid = tid;\r\nevent->mmap2.ino = st.st_ino;\r\nevent->mmap2.maj = major(st.st_dev);\r\nevent->mmap2.min = minor(st.st_dev);\r\nevent->mmap2.prot = st.st_mode;\r\nevent->mmap2.flags = MAP_SHARED;\r\nevent->mmap2.ino_generation = 1;\r\nid = (void *)((unsigned long)event + event->mmap.header.size - idr_size);\r\nif (jd->sample_type & PERF_SAMPLE_TID) {\r\nid->pid = pid;\r\nid->tid = tid;\r\n}\r\nif (jd->sample_type & PERF_SAMPLE_TIME)\r\nid->time = convert_timestamp(jd, jr->load.p.timestamp);\r\nmemset(&sample, 0, sizeof(sample));\r\nsample.cpumode = PERF_RECORD_MISC_USER;\r\nsample.pid = pid;\r\nsample.tid = tid;\r\nsample.time = id->time;\r\nsample.ip = jr->move.new_code_addr;\r\nret = perf_event__process_mmap2(tool, event, &sample, jd->machine);\r\nif (ret)\r\nreturn ret;\r\nret = jit_inject_event(jd, event);\r\nif (!ret)\r\nbuild_id__mark_dso_hit(tool, event, &sample, NULL, jd->machine);\r\nreturn ret;\r\n}\r\nstatic int jit_repipe_debug_info(struct jit_buf_desc *jd, union jr_entry *jr)\r\n{\r\nvoid *data;\r\nsize_t sz;\r\nif (!(jd && jr))\r\nreturn -1;\r\nsz = jr->prefix.total_size - sizeof(jr->info);\r\ndata = malloc(sz);\r\nif (!data)\r\nreturn -1;\r\nmemcpy(data, &jr->info.entries, sz);\r\njd->debug_data = data;\r\njd->nr_debug_entries = jr->info.nr_entry;\r\nreturn 0;\r\n}\r\nstatic int\r\njit_process_dump(struct jit_buf_desc *jd)\r\n{\r\nunion jr_entry *jr;\r\nint ret;\r\nwhile ((jr = jit_get_next_entry(jd))) {\r\nswitch(jr->prefix.id) {\r\ncase JIT_CODE_LOAD:\r\nret = jit_repipe_code_load(jd, jr);\r\nbreak;\r\ncase JIT_CODE_MOVE:\r\nret = jit_repipe_code_move(jd, jr);\r\nbreak;\r\ncase JIT_CODE_DEBUG_INFO:\r\nret = jit_repipe_debug_info(jd, jr);\r\nbreak;\r\ndefault:\r\nret = 0;\r\ncontinue;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\njit_inject(struct jit_buf_desc *jd, char *path)\r\n{\r\nint ret;\r\nif (verbose > 0)\r\nfprintf(stderr, "injecting: %s\n", path);\r\nret = jit_open(jd, path);\r\nif (ret)\r\nreturn -1;\r\nret = jit_process_dump(jd);\r\njit_close(jd);\r\nif (verbose > 0)\r\nfprintf(stderr, "injected: %s (%d)\n", path, ret);\r\nreturn 0;\r\n}\r\nstatic int\r\njit_detect(char *mmap_name, pid_t pid)\r\n{\r\nchar *p;\r\nchar *end = NULL;\r\npid_t pid2;\r\nif (verbose > 2)\r\nfprintf(stderr, "jit marker trying : %s\n", mmap_name);\r\np = strrchr(mmap_name, '/');\r\nif (!p)\r\nreturn -1;\r\nif (strncmp(p, "/jit-", 5))\r\nreturn -1;\r\np += 5;\r\nif (!isdigit(*p))\r\nreturn -1;\r\npid2 = (int)strtol(p, &end, 10);\r\nif (!end)\r\nreturn -1;\r\nif (pid && pid2 != pid)\r\nreturn -1;\r\nif (strcmp(end, ".dump"))\r\nreturn -1;\r\nif (verbose > 0)\r\nfprintf(stderr, "jit marker found: %s\n", mmap_name);\r\nreturn 0;\r\n}\r\nint\r\njit_process(struct perf_session *session,\r\nstruct perf_data_file *output,\r\nstruct machine *machine,\r\nchar *filename,\r\npid_t pid,\r\nu64 *nbytes)\r\n{\r\nstruct perf_evsel *first;\r\nstruct jit_buf_desc jd;\r\nint ret;\r\nif (jit_detect(filename, pid))\r\nreturn 0;\r\nmemset(&jd, 0, sizeof(jd));\r\njd.session = session;\r\njd.output = output;\r\njd.machine = machine;\r\nfirst = perf_evlist__first(session->evlist);\r\njd.sample_type = first->attr.sample_type;\r\n*nbytes = 0;\r\nret = jit_inject(&jd, filename);\r\nif (!ret) {\r\n*nbytes = jd.bytes_written;\r\nret = 1;\r\n}\r\nreturn ret;\r\n}
