static u64 asus_wireless_method(acpi_handle handle, const char *method,\r\nint param)\r\n{\r\nstruct acpi_object_list p;\r\nunion acpi_object obj;\r\nacpi_status s;\r\nu64 ret;\r\nacpi_handle_debug(handle, "Evaluating method %s, parameter %#x\n",\r\nmethod, param);\r\nobj.type = ACPI_TYPE_INTEGER;\r\nobj.integer.value = param;\r\np.count = 1;\r\np.pointer = &obj;\r\ns = acpi_evaluate_integer(handle, (acpi_string) method, &p, &ret);\r\nif (ACPI_FAILURE(s))\r\nacpi_handle_err(handle,\r\n"Failed to eval method %s, param %#x (%d)\n",\r\nmethod, param, s);\r\nacpi_handle_debug(handle, "%s returned %#x\n", method, (uint) ret);\r\nreturn ret;\r\n}\r\nstatic enum led_brightness led_state_get(struct led_classdev *led)\r\n{\r\nstruct asus_wireless_data *data;\r\nint s;\r\ndata = container_of(led, struct asus_wireless_data, led);\r\ns = asus_wireless_method(acpi_device_handle(data->adev), "HSWC",\r\nASUS_WIRELESS_LED_STATUS);\r\nif (s == ASUS_WIRELESS_LED_ON)\r\nreturn LED_FULL;\r\nreturn LED_OFF;\r\n}\r\nstatic void led_state_update(struct work_struct *work)\r\n{\r\nstruct asus_wireless_data *data;\r\ndata = container_of(work, struct asus_wireless_data, led_work);\r\nasus_wireless_method(acpi_device_handle(data->adev), "HSWC",\r\ndata->led_state);\r\n}\r\nstatic void led_state_set(struct led_classdev *led,\r\nenum led_brightness value)\r\n{\r\nstruct asus_wireless_data *data;\r\ndata = container_of(led, struct asus_wireless_data, led);\r\ndata->led_state = value == LED_OFF ? ASUS_WIRELESS_LED_OFF :\r\nASUS_WIRELESS_LED_ON;\r\nqueue_work(data->wq, &data->led_work);\r\n}\r\nstatic void asus_wireless_notify(struct acpi_device *adev, u32 event)\r\n{\r\nstruct asus_wireless_data *data = acpi_driver_data(adev);\r\ndev_dbg(&adev->dev, "event=%#x\n", event);\r\nif (event != 0x88) {\r\ndev_notice(&adev->dev, "Unknown ASHS event: %#x\n", event);\r\nreturn;\r\n}\r\ninput_report_key(data->idev, KEY_RFKILL, 1);\r\ninput_report_key(data->idev, KEY_RFKILL, 0);\r\ninput_sync(data->idev);\r\n}\r\nstatic int asus_wireless_add(struct acpi_device *adev)\r\n{\r\nstruct asus_wireless_data *data;\r\nint err;\r\ndata = devm_kzalloc(&adev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nadev->driver_data = data;\r\ndata->idev = devm_input_allocate_device(&adev->dev);\r\nif (!data->idev)\r\nreturn -ENOMEM;\r\ndata->idev->name = "Asus Wireless Radio Control";\r\ndata->idev->phys = "asus-wireless/input0";\r\ndata->idev->id.bustype = BUS_HOST;\r\ndata->idev->id.vendor = PCI_VENDOR_ID_ASUSTEK;\r\nset_bit(EV_KEY, data->idev->evbit);\r\nset_bit(KEY_RFKILL, data->idev->keybit);\r\nerr = input_register_device(data->idev);\r\nif (err)\r\nreturn err;\r\ndata->adev = adev;\r\ndata->wq = create_singlethread_workqueue("asus_wireless_workqueue");\r\nif (!data->wq)\r\nreturn -ENOMEM;\r\nINIT_WORK(&data->led_work, led_state_update);\r\ndata->led.name = "asus-wireless::airplane";\r\ndata->led.brightness_set = led_state_set;\r\ndata->led.brightness_get = led_state_get;\r\ndata->led.flags = LED_CORE_SUSPENDRESUME;\r\ndata->led.max_brightness = 1;\r\nerr = devm_led_classdev_register(&adev->dev, &data->led);\r\nif (err)\r\ndestroy_workqueue(data->wq);\r\nreturn err;\r\n}\r\nstatic int asus_wireless_remove(struct acpi_device *adev)\r\n{\r\nstruct asus_wireless_data *data = acpi_driver_data(adev);\r\nif (data->wq)\r\ndestroy_workqueue(data->wq);\r\nreturn 0;\r\n}
