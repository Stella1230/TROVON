static int itd1000_write_regs(struct itd1000_state *state, u8 reg, u8 v[], u8 len)\r\n{\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg = {\r\n.addr = state->cfg->i2c_address, .flags = 0, .buf = buf, .len = len+1\r\n};\r\nif (1 + len > sizeof(buf)) {\r\nprintk(KERN_WARNING\r\n"itd1000: i2c wr reg=%04x: len=%d is too big!\n",\r\nreg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], v, len);\r\nif (i2c_transfer(state->i2c, &msg, 1) != 1) {\r\nprintk(KERN_WARNING "itd1000 I2C write failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int itd1000_read_reg(struct itd1000_state *state, u8 reg)\r\n{\r\nu8 val;\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = state->cfg->i2c_address, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = state->cfg->i2c_address, .flags = I2C_M_RD, .buf = &val, .len = 1 },\r\n};\r\nitd1000_write_regs(state, (reg - 1) & 0xff, &state->shadow[(reg - 1) & 0xff], 1);\r\nif (i2c_transfer(state->i2c, msg, 2) != 2) {\r\nitd_warn("itd1000 I2C read failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn val;\r\n}\r\nstatic inline int itd1000_write_reg(struct itd1000_state *state, u8 r, u8 v)\r\n{\r\nint ret = itd1000_write_regs(state, r, &v, 1);\r\nstate->shadow[r] = v;\r\nreturn ret;\r\n}\r\nstatic void itd1000_set_lpf_bw(struct itd1000_state *state, u32 symbol_rate)\r\n{\r\nu8 i;\r\nu8 con1 = itd1000_read_reg(state, CON1) & 0xfd;\r\nu8 pllfh = itd1000_read_reg(state, PLLFH) & 0x0f;\r\nu8 bbgvmin = itd1000_read_reg(state, BBGVMIN) & 0xf0;\r\nu8 bw = itd1000_read_reg(state, BW) & 0xf0;\r\nitd_dbg("symbol_rate = %d\n", symbol_rate);\r\nitd1000_write_reg(state, CON1, con1 | (1 << 1));\r\nfor (i = 0; i < ARRAY_SIZE(itd1000_lpf_pga); i++)\r\nif (symbol_rate < itd1000_lpf_pga[i].symbol_rate) {\r\nitd_dbg("symrate: index: %d pgaext: %x, bbgvmin: %x\n", i, itd1000_lpf_pga[i].pgaext, itd1000_lpf_pga[i].bbgvmin);\r\nitd1000_write_reg(state, PLLFH, pllfh | (itd1000_lpf_pga[i].pgaext << 4));\r\nitd1000_write_reg(state, BBGVMIN, bbgvmin | (itd1000_lpf_pga[i].bbgvmin));\r\nitd1000_write_reg(state, BW, bw | (i & 0x0f));\r\nbreak;\r\n}\r\nitd1000_write_reg(state, CON1, con1 | (0 << 1));\r\n}\r\nstatic void itd1000_set_vco(struct itd1000_state *state, u32 freq_khz)\r\n{\r\nu8 i;\r\nu8 gvbb_i2c = itd1000_read_reg(state, GVBB_I2C) & 0xbf;\r\nu8 vco_chp1_i2c = itd1000_read_reg(state, VCO_CHP1_I2C) & 0x0f;\r\nu8 adcout;\r\nitd1000_write_reg(state, GVBB_I2C, gvbb_i2c | (1 << 6));\r\nfor (i = 0; i < ARRAY_SIZE(itd1000_vcorg); i++) {\r\nif (freq_khz < itd1000_vcorg[i].fmax_rg) {\r\nitd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | (itd1000_vcorg[i].vcorg << 4));\r\nmsleep(1);\r\nadcout = itd1000_read_reg(state, PLLLOCK) & 0x0f;\r\nitd_dbg("VCO: %dkHz: %d -> ADCOUT: %d %02x\n", freq_khz, itd1000_vcorg[i].vcorg, adcout, vco_chp1_i2c);\r\nif (adcout > 13) {\r\nif (!(itd1000_vcorg[i].vcorg == 7 || itd1000_vcorg[i].vcorg == 15))\r\nitd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | ((itd1000_vcorg[i].vcorg + 1) << 4));\r\n} else if (adcout < 2) {\r\nif (!(itd1000_vcorg[i].vcorg == 1 || itd1000_vcorg[i].vcorg == 9))\r\nitd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | ((itd1000_vcorg[i].vcorg - 1) << 4));\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void itd1000_set_lo(struct itd1000_state *state, u32 freq_khz)\r\n{\r\nint i, j;\r\nu32 plln, pllf;\r\nu64 tmp;\r\nplln = (freq_khz * 1000) / 2 / FREF;\r\ntmp = plln % 1000000;\r\nplln /= 1000000;\r\ntmp *= 1048576;\r\ndo_div(tmp, 1000000);\r\npllf = (u32) tmp;\r\nstate->frequency = ((plln * 1000) + (pllf * 1000)/1048576) * 2*FREF;\r\nitd_dbg("frequency: %dkHz (wanted) %dkHz (set), PLLF = %d, PLLN = %d\n", freq_khz, state->frequency, pllf, plln);\r\nitd1000_write_reg(state, PLLNH, 0x80);\r\nitd1000_write_reg(state, PLLNL, plln & 0xff);\r\nitd1000_write_reg(state, PLLFH, (itd1000_read_reg(state, PLLFH) & 0xf0) | ((pllf >> 16) & 0x0f));\r\nitd1000_write_reg(state, PLLFM, (pllf >> 8) & 0xff);\r\nitd1000_write_reg(state, PLLFL, (pllf >> 0) & 0xff);\r\nfor (i = 0; i < ARRAY_SIZE(itd1000_fre_values); i++) {\r\nif (freq_khz <= itd1000_fre_values[i].freq) {\r\nitd_dbg("fre_values: %d\n", i);\r\nitd1000_write_reg(state, RFTR, itd1000_fre_values[i].values[0]);\r\nfor (j = 0; j < 9; j++)\r\nitd1000_write_reg(state, RFST1+j, itd1000_fre_values[i].values[j+1]);\r\nbreak;\r\n}\r\n}\r\nitd1000_set_vco(state, freq_khz);\r\n}\r\nstatic int itd1000_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct itd1000_state *state = fe->tuner_priv;\r\nu8 pllcon1;\r\nitd1000_set_lo(state, c->frequency);\r\nitd1000_set_lpf_bw(state, c->symbol_rate);\r\npllcon1 = itd1000_read_reg(state, PLLCON1) & 0x7f;\r\nitd1000_write_reg(state, PLLCON1, pllcon1 | (1 << 7));\r\nitd1000_write_reg(state, PLLCON1, pllcon1);\r\nreturn 0;\r\n}\r\nstatic int itd1000_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct itd1000_state *state = fe->tuner_priv;\r\n*frequency = state->frequency;\r\nreturn 0;\r\n}\r\nstatic int itd1000_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nreturn 0;\r\n}\r\nstatic int itd1000_init(struct dvb_frontend *fe)\r\n{\r\nstruct itd1000_state *state = fe->tuner_priv;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(itd1000_init_tab); i++)\r\nitd1000_write_reg(state, itd1000_init_tab[i][0], itd1000_init_tab[i][1]);\r\nfor (i = 0; i < ARRAY_SIZE(itd1000_reinit_tab); i++)\r\nitd1000_write_reg(state, itd1000_reinit_tab[i][0], itd1000_reinit_tab[i][1]);\r\nreturn 0;\r\n}\r\nstatic int itd1000_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int itd1000_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *itd1000_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct itd1000_config *cfg)\r\n{\r\nstruct itd1000_state *state = NULL;\r\nu8 i = 0;\r\nstate = kzalloc(sizeof(struct itd1000_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->cfg = cfg;\r\nstate->i2c = i2c;\r\ni = itd1000_read_reg(state, 0);\r\nif (i != 0) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nitd_info("successfully identified (ID: %d)\n", i);\r\nmemset(state->shadow, 0xff, sizeof(state->shadow));\r\nfor (i = 0x65; i < 0x9c; i++)\r\nstate->shadow[i] = itd1000_read_reg(state, i);\r\nmemcpy(&fe->ops.tuner_ops, &itd1000_tuner_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = state;\r\nreturn fe;\r\n}
