static void unwind__register_ops(struct thread *thread,\r\nstruct unwind_libunwind_ops *ops)\r\n{\r\nthread->unwind_libunwind_ops = ops;\r\n}\r\nint unwind__prepare_access(struct thread *thread, struct map *map,\r\nbool *initialized)\r\n{\r\nconst char *arch;\r\nenum dso_type dso_type;\r\nstruct unwind_libunwind_ops *ops = local_unwind_libunwind_ops;\r\nint err;\r\nif (thread->addr_space) {\r\npr_debug("unwind: thread map already set, dso=%s\n",\r\nmap->dso->name);\r\nif (initialized)\r\n*initialized = true;\r\nreturn 0;\r\n}\r\nif (!thread->mg->machine->env || !thread->mg->machine->env->arch)\r\ngoto out_register;\r\ndso_type = dso__type(map->dso, thread->mg->machine);\r\nif (dso_type == DSO__TYPE_UNKNOWN)\r\nreturn 0;\r\narch = normalize_arch(thread->mg->machine->env->arch);\r\nif (!strcmp(arch, "x86")) {\r\nif (dso_type != DSO__TYPE_64BIT)\r\nops = x86_32_unwind_libunwind_ops;\r\n} else if (!strcmp(arch, "arm64") || !strcmp(arch, "arm")) {\r\nif (dso_type == DSO__TYPE_64BIT)\r\nops = arm64_unwind_libunwind_ops;\r\n}\r\nif (!ops) {\r\npr_err("unwind: target platform=%s is not supported\n", arch);\r\nreturn -1;\r\n}\r\nout_register:\r\nunwind__register_ops(thread, ops);\r\nerr = thread->unwind_libunwind_ops->prepare_access(thread);\r\nif (initialized)\r\n*initialized = err ? false : true;\r\nreturn err;\r\n}\r\nvoid unwind__flush_access(struct thread *thread)\r\n{\r\nif (thread->unwind_libunwind_ops)\r\nthread->unwind_libunwind_ops->flush_access(thread);\r\n}\r\nvoid unwind__finish_access(struct thread *thread)\r\n{\r\nif (thread->unwind_libunwind_ops)\r\nthread->unwind_libunwind_ops->finish_access(thread);\r\n}\r\nint unwind__get_entries(unwind_entry_cb_t cb, void *arg,\r\nstruct thread *thread,\r\nstruct perf_sample *data, int max_stack)\r\n{\r\nif (thread->unwind_libunwind_ops)\r\nreturn thread->unwind_libunwind_ops->get_entries(cb, arg, thread, data, max_stack);\r\nreturn 0;\r\n}
