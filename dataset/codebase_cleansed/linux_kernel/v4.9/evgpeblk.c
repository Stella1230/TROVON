static acpi_status\r\nacpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,\r\nu32 interrupt_number)\r\n{\r\nstruct acpi_gpe_block_info *next_gpe_block;\r\nstruct acpi_gpe_xrupt_info *gpe_xrupt_block;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(ev_install_gpe_block);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_ev_get_gpe_xrupt_block(interrupt_number, &gpe_xrupt_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\nif (gpe_xrupt_block->gpe_block_list_head) {\r\nnext_gpe_block = gpe_xrupt_block->gpe_block_list_head;\r\nwhile (next_gpe_block->next) {\r\nnext_gpe_block = next_gpe_block->next;\r\n}\r\nnext_gpe_block->next = gpe_block;\r\ngpe_block->previous = next_gpe_block;\r\n} else {\r\ngpe_xrupt_block->gpe_block_list_head = gpe_block;\r\n}\r\ngpe_block->xrupt_block = gpe_xrupt_block;\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)\r\n{\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(ev_install_gpe_block);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_hw_disable_gpe_block(gpe_block->xrupt_block, gpe_block, NULL);\r\nif (!gpe_block->previous && !gpe_block->next) {\r\nstatus = acpi_ev_delete_gpe_xrupt(gpe_block->xrupt_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\n} else {\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\nif (gpe_block->previous) {\r\ngpe_block->previous->next = gpe_block->next;\r\n} else {\r\ngpe_block->xrupt_block->gpe_block_list_head =\r\ngpe_block->next;\r\n}\r\nif (gpe_block->next) {\r\ngpe_block->next->previous = gpe_block->previous;\r\n}\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\n}\r\nacpi_current_gpe_count -= gpe_block->gpe_count;\r\nACPI_FREE(gpe_block->register_info);\r\nACPI_FREE(gpe_block->event_info);\r\nACPI_FREE(gpe_block);\r\nunlock_and_exit:\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)\r\n{\r\nstruct acpi_gpe_register_info *gpe_register_info = NULL;\r\nstruct acpi_gpe_event_info *gpe_event_info = NULL;\r\nstruct acpi_gpe_event_info *this_event;\r\nstruct acpi_gpe_register_info *this_register;\r\nu32 i;\r\nu32 j;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_create_gpe_info_blocks);\r\ngpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->\r\nregister_count *\r\nsizeof(struct\r\nacpi_gpe_register_info));\r\nif (!gpe_register_info) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate the GpeRegisterInfo table"));\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ngpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size)gpe_block->gpe_count *\r\nsizeof(struct\r\nacpi_gpe_event_info));\r\nif (!gpe_event_info) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate the GpeEventInfo table"));\r\nstatus = AE_NO_MEMORY;\r\ngoto error_exit;\r\n}\r\ngpe_block->register_info = gpe_register_info;\r\ngpe_block->event_info = gpe_event_info;\r\nthis_register = gpe_register_info;\r\nthis_event = gpe_event_info;\r\nfor (i = 0; i < gpe_block->register_count; i++) {\r\nthis_register->base_gpe_number = (u16)\r\n(gpe_block->block_base_number +\r\n(i * ACPI_GPE_REGISTER_WIDTH));\r\nthis_register->status_address.address = gpe_block->address + i;\r\nthis_register->enable_address.address =\r\ngpe_block->address + i + gpe_block->register_count;\r\nthis_register->status_address.space_id = gpe_block->space_id;\r\nthis_register->enable_address.space_id = gpe_block->space_id;\r\nthis_register->status_address.bit_width =\r\nACPI_GPE_REGISTER_WIDTH;\r\nthis_register->enable_address.bit_width =\r\nACPI_GPE_REGISTER_WIDTH;\r\nthis_register->status_address.bit_offset = 0;\r\nthis_register->enable_address.bit_offset = 0;\r\nfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\r\nthis_event->gpe_number =\r\n(u8) (this_register->base_gpe_number + j);\r\nthis_event->register_info = this_register;\r\nthis_event++;\r\n}\r\nstatus = acpi_hw_write(0x00, &this_register->enable_address);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nstatus = acpi_hw_write(0xFF, &this_register->status_address);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nthis_register++;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\nerror_exit:\r\nif (gpe_register_info) {\r\nACPI_FREE(gpe_register_info);\r\n}\r\nif (gpe_event_info) {\r\nACPI_FREE(gpe_event_info);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,\r\nu64 address,\r\nu8 space_id,\r\nu32 register_count,\r\nu16 gpe_block_base_number,\r\nu32 interrupt_number,\r\nstruct acpi_gpe_block_info **return_gpe_block)\r\n{\r\nacpi_status status;\r\nstruct acpi_gpe_block_info *gpe_block;\r\nstruct acpi_gpe_walk_info walk_info;\r\nACPI_FUNCTION_TRACE(ev_create_gpe_block);\r\nif (!register_count) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\ngpe_block = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_block_info));\r\nif (!gpe_block) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ngpe_block->address = address;\r\ngpe_block->space_id = space_id;\r\ngpe_block->node = gpe_device;\r\ngpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);\r\ngpe_block->initialized = FALSE;\r\ngpe_block->register_count = register_count;\r\ngpe_block->block_base_number = gpe_block_base_number;\r\nstatus = acpi_ev_create_gpe_info_blocks(gpe_block);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(gpe_block);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ev_install_gpe_block(gpe_block, interrupt_number);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(gpe_block->register_info);\r\nACPI_FREE(gpe_block->event_info);\r\nACPI_FREE(gpe_block);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_all_gpes_initialized = FALSE;\r\nwalk_info.gpe_block = gpe_block;\r\nwalk_info.gpe_device = gpe_device;\r\nwalk_info.execute_by_owner_id = FALSE;\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,\r\nACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,\r\nacpi_ev_match_gpe_method, NULL,\r\n&walk_info, NULL);\r\nif (return_gpe_block) {\r\n(*return_gpe_block) = gpe_block;\r\n}\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n" Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X%s\n",\r\n(u32)gpe_block->block_base_number,\r\n(u32)(gpe_block->block_base_number +\r\n(gpe_block->gpe_count - 1)),\r\ngpe_device->name.ascii, gpe_block->register_count,\r\ninterrupt_number,\r\ninterrupt_number ==\r\nacpi_gbl_FADT.sci_interrupt ? " (SCI)" : ""));\r\nacpi_current_gpe_count += gpe_block->gpe_count;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,\r\nstruct acpi_gpe_block_info *gpe_block,\r\nvoid *ignored)\r\n{\r\nacpi_status status;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nu32 gpe_enabled_count;\r\nu32 gpe_index;\r\nu32 i;\r\nu32 j;\r\nACPI_FUNCTION_TRACE(ev_initialize_gpe_block);\r\nif (!gpe_block || gpe_block->initialized) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\ngpe_enabled_count = 0;\r\nfor (i = 0; i < gpe_block->register_count; i++) {\r\nfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\r\ngpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;\r\ngpe_event_info = &gpe_block->event_info[gpe_index];\r\nif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_NONE)\r\n|| (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_HANDLER)\r\n|| (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_RAW_HANDLER)\r\n|| (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {\r\ncontinue;\r\n}\r\nstatus = acpi_ev_add_gpe_reference(gpe_event_info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not enable GPE 0x%02X",\r\ngpe_index +\r\ngpe_block->block_base_number));\r\ncontinue;\r\n}\r\ngpe_enabled_count++;\r\n}\r\n}\r\nif (gpe_enabled_count) {\r\nACPI_INFO(("Enabled %u GPEs in block %02X to %02X",\r\ngpe_enabled_count, (u32)gpe_block->block_base_number,\r\n(u32)(gpe_block->block_base_number +\r\n(gpe_block->gpe_count - 1))));\r\n}\r\ngpe_block->initialized = TRUE;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
