static void irnet_ppp_disconnect(struct work_struct *work)\r\n{\r\nirnet_socket * self =\r\ncontainer_of(work, irnet_socket, disconnect_work);\r\nif (self == NULL)\r\nreturn;\r\nif (self->ppp_open && !self->ttp_open && !self->ttp_connect) {\r\nppp_unregister_channel(&self->chan);\r\nself->ppp_open = 0;\r\n}\r\n}\r\nstatic void\r\nirnet_post_event(irnet_socket * ap,\r\nirnet_event event,\r\n__u32 saddr,\r\n__u32 daddr,\r\nchar * name,\r\n__u16 hints)\r\n{\r\nint index;\r\nDENTER(CTRL_TRACE, "(ap=0x%p, event=%d, daddr=%08x, name=``%s'')\n",\r\nap, event, daddr, name);\r\nspin_lock_bh(&irnet_events.spinlock);\r\nindex = irnet_events.index;\r\nirnet_events.log[index].event = event;\r\nirnet_events.log[index].daddr = daddr;\r\nirnet_events.log[index].saddr = saddr;\r\nif(name)\r\nstrcpy(irnet_events.log[index].name, name);\r\nelse\r\nirnet_events.log[index].name[0] = '\0';\r\nirnet_events.log[index].hints.word = hints;\r\nif((ap != (irnet_socket *) NULL) && (ap->ppp_open))\r\nirnet_events.log[index].unit = ppp_unit_number(&ap->chan);\r\nelse\r\nirnet_events.log[index].unit = -1;\r\nirnet_events.index = (index + 1) % IRNET_MAX_EVENTS;\r\nDEBUG(CTRL_INFO, "New event index is %d\n", irnet_events.index);\r\nspin_unlock_bh(&irnet_events.spinlock);\r\nwake_up_interruptible_all(&irnet_events.rwait);\r\nDEXIT(CTRL_TRACE, "\n");\r\n}\r\nstatic inline int\r\nirnet_open_tsap(irnet_socket * self)\r\n{\r\nnotify_t notify;\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\nDABORT(self->tsap != NULL, -EBUSY, IRDA_SR_ERROR, "Already busy !\n");\r\nirda_notify_init(&notify);\r\nnotify.connect_confirm = irnet_connect_confirm;\r\nnotify.connect_indication = irnet_connect_indication;\r\nnotify.disconnect_indication = irnet_disconnect_indication;\r\nnotify.data_indication = irnet_data_indication;\r\nnotify.flow_indication = irnet_flow_indication;\r\nnotify.status_indication = irnet_status_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, IRNET_NOTIFY_NAME, sizeof(notify.name));\r\nself->tsap = irttp_open_tsap(LSAP_ANY, DEFAULT_INITIAL_CREDIT,\r\n&notify);\r\nDABORT(self->tsap == NULL, -ENOMEM,\r\nIRDA_SR_ERROR, "Unable to allocate TSAP !\n");\r\nself->stsap_sel = self->tsap->stsap_sel;\r\nDEXIT(IRDA_SR_TRACE, " - tsap=0x%p, sel=0x%X\n",\r\nself->tsap, self->stsap_sel);\r\nreturn 0;\r\n}\r\nstatic inline __u8\r\nirnet_ias_to_tsap(irnet_socket * self,\r\nint result,\r\nstruct ias_value * value)\r\n{\r\n__u8 dtsap_sel = 0;\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\nself->errno = 0;\r\nswitch(result)\r\n{\r\ncase IAS_CLASS_UNKNOWN:\r\ncase IAS_ATTRIB_UNKNOWN:\r\nDEBUG(IRDA_SR_INFO, "IAS object doesn't exist ! (%d)\n", result);\r\nself->errno = -EADDRNOTAVAIL;\r\nbreak;\r\ndefault :\r\nDEBUG(IRDA_SR_INFO, "IAS query failed ! (%d)\n", result);\r\nself->errno = -EHOSTUNREACH;\r\nbreak;\r\ncase IAS_SUCCESS:\r\nbreak;\r\n}\r\nif(value != NULL)\r\n{\r\nswitch(value->type)\r\n{\r\ncase IAS_INTEGER:\r\nDEBUG(IRDA_SR_INFO, "result=%d\n", value->t.integer);\r\nif(value->t.integer != -1)\r\ndtsap_sel = value->t.integer;\r\nelse\r\nself->errno = -EADDRNOTAVAIL;\r\nbreak;\r\ndefault:\r\nself->errno = -EADDRNOTAVAIL;\r\nDERROR(IRDA_SR_ERROR, "bad type ! (0x%X)\n", value->type);\r\nbreak;\r\n}\r\nirias_delete_value(value);\r\n}\r\nelse\r\n{\r\nif(!(self->errno))\r\n{\r\nDERROR(IRDA_SR_ERROR,\r\n"IrDA bug : result == SUCCESS && value == NULL\n");\r\nself->errno = -EHOSTUNREACH;\r\n}\r\n}\r\nDEXIT(IRDA_SR_TRACE, "\n");\r\nreturn dtsap_sel;\r\n}\r\nstatic inline int\r\nirnet_find_lsap_sel(irnet_socket * self)\r\n{\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\nDABORT(self->iriap, -EBUSY, IRDA_SR_ERROR, "busy with a previous query.\n");\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nirnet_getvalue_confirm);\r\nself->errno = -EHOSTUNREACH;\r\niriap_getvaluebyclass_request(self->iriap, self->rsaddr, self->daddr,\r\nIRNET_SERVICE_NAME, IRNET_IAS_VALUE);\r\nDEXIT(IRDA_SR_TRACE, "\n");\r\nreturn 0;\r\n}\r\nstatic inline int\r\nirnet_connect_tsap(irnet_socket * self)\r\n{\r\nint err;\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\nerr = irnet_open_tsap(self);\r\nif(err != 0)\r\n{\r\nclear_bit(0, &self->ttp_connect);\r\nDERROR(IRDA_SR_ERROR, "connect aborted!\n");\r\nreturn err;\r\n}\r\nerr = irttp_connect_request(self->tsap, self->dtsap_sel,\r\nself->rsaddr, self->daddr, NULL,\r\nself->max_sdu_size_rx, NULL);\r\nif(err != 0)\r\n{\r\nclear_bit(0, &self->ttp_connect);\r\nDERROR(IRDA_SR_ERROR, "connect aborted!\n");\r\nreturn err;\r\n}\r\nDEXIT(IRDA_SR_TRACE, "\n");\r\nreturn err;\r\n}\r\nstatic inline int\r\nirnet_discover_next_daddr(irnet_socket * self)\r\n{\r\nif(self->iriap)\r\n{\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nirnet_discovervalue_confirm);\r\nif(self->iriap == NULL)\r\nreturn -ENOMEM;\r\nself->disco_index++;\r\nif(self->disco_index < self->disco_number)\r\n{\r\niriap_getvaluebyclass_request(self->iriap,\r\nself->discoveries[self->disco_index].saddr,\r\nself->discoveries[self->disco_index].daddr,\r\nIRNET_SERVICE_NAME, IRNET_IAS_VALUE);\r\nreturn 0;\r\n}\r\nelse\r\nreturn 1;\r\n}\r\nstatic inline int\r\nirnet_discover_daddr_and_lsap_sel(irnet_socket * self)\r\n{\r\nint ret;\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\nself->discoveries = irlmp_get_discoveries(&self->disco_number, self->mask,\r\nDISCOVERY_DEFAULT_SLOTS);\r\nif(self->discoveries == NULL)\r\n{\r\nself->disco_number = -1;\r\nclear_bit(0, &self->ttp_connect);\r\nDRETURN(-ENETUNREACH, IRDA_SR_INFO, "No Cachelog...\n");\r\n}\r\nDEBUG(IRDA_SR_INFO, "Got the log (0x%p), size is %d\n",\r\nself->discoveries, self->disco_number);\r\nself->disco_index = -1;\r\nself->daddr = DEV_ADDR_ANY;\r\nret = irnet_discover_next_daddr(self);\r\nif(ret)\r\n{\r\nif(self->iriap)\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\nkfree(self->discoveries);\r\nself->discoveries = NULL;\r\nclear_bit(0, &self->ttp_connect);\r\nDRETURN(-ENETUNREACH, IRDA_SR_INFO, "Cachelog empty...\n");\r\n}\r\nDEXIT(IRDA_SR_TRACE, "\n");\r\nreturn 0;\r\n}\r\nstatic inline int\r\nirnet_dname_to_daddr(irnet_socket * self)\r\n{\r\nstruct irda_device_info *discoveries;\r\nint number;\r\nint i;\r\nDENTER(IRDA_SR_TRACE, "(self=0x%p)\n", self);\r\ndiscoveries = irlmp_get_discoveries(&number, 0xffff,\r\nDISCOVERY_DEFAULT_SLOTS);\r\nif(discoveries == NULL)\r\nDRETURN(-ENETUNREACH, IRDA_SR_INFO, "Cachelog empty...\n");\r\nfor(i = 0; i < number; i++)\r\n{\r\nif(!strncmp(discoveries[i].info, self->rname, NICKNAME_MAX_LEN))\r\n{\r\nself->daddr = discoveries[i].daddr;\r\nDEBUG(IRDA_SR_INFO, "discovered device ``%s'' at address 0x%08x.\n",\r\nself->rname, self->daddr);\r\nkfree(discoveries);\r\nDEXIT(IRDA_SR_TRACE, "\n");\r\nreturn 0;\r\n}\r\n}\r\nDEBUG(IRDA_SR_INFO, "cannot discover device ``%s'' !!!\n", self->rname);\r\nkfree(discoveries);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nint\r\nirda_irnet_create(irnet_socket * self)\r\n{\r\nDENTER(IRDA_SOCK_TRACE, "(self=0x%p)\n", self);\r\nself->magic = IRNET_MAGIC;\r\nself->ttp_open = 0;\r\nself->ttp_connect = 0;\r\nself->rname[0] = '\0';\r\nself->rdaddr = DEV_ADDR_ANY;\r\nself->rsaddr = DEV_ADDR_ANY;\r\nself->daddr = DEV_ADDR_ANY;\r\nself->saddr = DEV_ADDR_ANY;\r\nself->max_sdu_size_rx = TTP_SAR_UNBOUND;\r\nself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\r\n#ifdef DISCOVERY_NOMASK\r\nself->mask = 0xffff;\r\n#else\r\nself->mask = irlmp_service_to_hint(S_LAN);\r\n#endif\r\nself->tx_flow = FLOW_START;\r\nINIT_WORK(&self->disconnect_work, irnet_ppp_disconnect);\r\nDEXIT(IRDA_SOCK_TRACE, "\n");\r\nreturn 0;\r\n}\r\nint\r\nirda_irnet_connect(irnet_socket * self)\r\n{\r\nint err;\r\nDENTER(IRDA_SOCK_TRACE, "(self=0x%p)\n", self);\r\nif(test_and_set_bit(0, &self->ttp_connect))\r\nDRETURN(-EBUSY, IRDA_SOCK_INFO, "Already connecting...\n");\r\nif((self->iriap != NULL) || (self->tsap != NULL))\r\nDERROR(IRDA_SOCK_ERROR, "Socket not cleaned up...\n");\r\nif((irnet_server.running) && (self->q.q_next == NULL))\r\n{\r\nspin_lock_bh(&irnet_server.spinlock);\r\nhashbin_insert(irnet_server.list, (irda_queue_t *) self, 0, self->rname);\r\nspin_unlock_bh(&irnet_server.spinlock);\r\nDEBUG(IRDA_SOCK_INFO, "Inserted ``%s'' in hashbin...\n", self->rname);\r\n}\r\nif((self->rdaddr == DEV_ADDR_ANY) && (self->rname[0] == '\0'))\r\n{\r\nif((err = irnet_discover_daddr_and_lsap_sel(self)) != 0)\r\nDRETURN(err, IRDA_SOCK_INFO, "auto-connect failed!\n");\r\n}\r\nelse\r\n{\r\nif(self->rdaddr == DEV_ADDR_ANY)\r\n{\r\nif((err = irnet_dname_to_daddr(self)) != 0)\r\nDRETURN(err, IRDA_SOCK_INFO, "name connect failed!\n");\r\n}\r\nelse\r\nself->daddr = self->rdaddr;\r\nirnet_find_lsap_sel(self);\r\n}\r\nDEXIT(IRDA_SOCK_TRACE, "\n");\r\nreturn 0;\r\n}\r\nvoid\r\nirda_irnet_destroy(irnet_socket * self)\r\n{\r\nDENTER(IRDA_SOCK_TRACE, "(self=0x%p)\n", self);\r\nif(self == NULL)\r\nreturn;\r\nif((irnet_server.running) && (self->q.q_next != NULL))\r\n{\r\nstruct irnet_socket * entry;\r\nDEBUG(IRDA_SOCK_INFO, "Removing from hash..\n");\r\nspin_lock_bh(&irnet_server.spinlock);\r\nentry = hashbin_remove_this(irnet_server.list, (irda_queue_t *) self);\r\nself->q.q_next = NULL;\r\nspin_unlock_bh(&irnet_server.spinlock);\r\nDASSERT(entry == self, , IRDA_SOCK_ERROR, "Can't remove from hash.\n");\r\n}\r\nif(test_bit(0, &self->ttp_open))\r\n{\r\nirnet_post_event(NULL, IRNET_DISCONNECT_TO,\r\nself->saddr, self->daddr, self->rname, 0);\r\n}\r\nclear_bit(0, &self->ttp_connect);\r\nclear_bit(0, &self->ttp_open);\r\nirlmp_unregister_client(self->ckey);\r\nif(self->iriap)\r\n{\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\n}\r\nif(self->discoveries != NULL)\r\n{\r\nkfree(self->discoveries);\r\nself->discoveries = NULL;\r\n}\r\nif(self->tsap)\r\n{\r\nDEBUG(IRDA_SOCK_INFO, "Closing our TTP connection.\n");\r\nirttp_disconnect_request(self->tsap, NULL, P_NORMAL);\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\nself->stsap_sel = 0;\r\nDEXIT(IRDA_SOCK_TRACE, "\n");\r\n}\r\nstatic inline int\r\nirnet_daddr_to_dname(irnet_socket * self)\r\n{\r\nstruct irda_device_info *discoveries;\r\nint number;\r\nint i;\r\nDENTER(IRDA_SERV_TRACE, "(self=0x%p)\n", self);\r\ndiscoveries = irlmp_get_discoveries(&number, 0xffff,\r\nDISCOVERY_DEFAULT_SLOTS);\r\nif (discoveries == NULL)\r\nDRETURN(-ENETUNREACH, IRDA_SERV_INFO, "Cachelog empty...\n");\r\nfor(i = 0; i < number; i++)\r\n{\r\nif(discoveries[i].daddr == self->daddr)\r\n{\r\nstrlcpy(self->rname, discoveries[i].info, sizeof(self->rname));\r\nself->rname[sizeof(self->rname) - 1] = '\0';\r\nDEBUG(IRDA_SERV_INFO, "Device 0x%08x is in fact ``%s''.\n",\r\nself->daddr, self->rname);\r\nkfree(discoveries);\r\nDEXIT(IRDA_SERV_TRACE, "\n");\r\nreturn 0;\r\n}\r\n}\r\nDEXIT(IRDA_SERV_INFO, ": cannot discover device 0x%08x !!!\n", self->daddr);\r\nkfree(discoveries);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic inline irnet_socket *\r\nirnet_find_socket(irnet_socket * self)\r\n{\r\nirnet_socket * new = (irnet_socket *) NULL;\r\nint err;\r\nDENTER(IRDA_SERV_TRACE, "(self=0x%p)\n", self);\r\nself->daddr = irttp_get_daddr(self->tsap);\r\nself->saddr = irttp_get_saddr(self->tsap);\r\nerr = irnet_daddr_to_dname(self);\r\nspin_lock_bh(&irnet_server.spinlock);\r\nif(err == 0)\r\n{\r\nnew = (irnet_socket *) hashbin_find(irnet_server.list,\r\n0, self->rname);\r\nif(new)\r\nDEBUG(IRDA_SERV_INFO, "Socket 0x%p matches rname ``%s''.\n",\r\nnew, new->rname);\r\n}\r\nif(new == (irnet_socket *) NULL)\r\n{\r\nnew = (irnet_socket *) hashbin_get_first(irnet_server.list);\r\nwhile(new !=(irnet_socket *) NULL)\r\n{\r\nif((new->rdaddr == self->daddr) || (new->daddr == self->daddr))\r\n{\r\nDEBUG(IRDA_SERV_INFO, "Socket 0x%p matches daddr %#08x.\n",\r\nnew, self->daddr);\r\nbreak;\r\n}\r\nnew = (irnet_socket *) hashbin_get_next(irnet_server.list);\r\n}\r\n}\r\nif(new == (irnet_socket *) NULL)\r\n{\r\nnew = (irnet_socket *) hashbin_get_first(irnet_server.list);\r\nwhile(new !=(irnet_socket *) NULL)\r\n{\r\nif(!(test_bit(0, &new->ttp_open)) && (new->rdaddr == DEV_ADDR_ANY) &&\r\n(new->rname[0] == '\0') && (new->ppp_open))\r\n{\r\nDEBUG(IRDA_SERV_INFO, "Socket 0x%p is free.\n",\r\nnew);\r\nbreak;\r\n}\r\nnew = (irnet_socket *) hashbin_get_next(irnet_server.list);\r\n}\r\n}\r\nspin_unlock_bh(&irnet_server.spinlock);\r\nDEXIT(IRDA_SERV_TRACE, " - new = 0x%p\n", new);\r\nreturn new;\r\n}\r\nstatic inline int\r\nirnet_connect_socket(irnet_socket * server,\r\nirnet_socket * new,\r\nstruct qos_info * qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size)\r\n{\r\nDENTER(IRDA_SERV_TRACE, "(server=0x%p, new=0x%p)\n",\r\nserver, new);\r\nnew->tsap = irttp_dup(server->tsap, new);\r\nDABORT(new->tsap == NULL, -1, IRDA_SERV_ERROR, "dup failed!\n");\r\nnew->stsap_sel = new->tsap->stsap_sel;\r\nnew->dtsap_sel = new->tsap->dtsap_sel;\r\nnew->saddr = irttp_get_saddr(new->tsap);\r\nnew->daddr = irttp_get_daddr(new->tsap);\r\nnew->max_header_size = max_header_size;\r\nnew->max_sdu_size_tx = max_sdu_size;\r\nnew->max_data_size = max_sdu_size;\r\n#ifdef STREAM_COMPAT\r\nif(max_sdu_size == 0)\r\nnew->max_data_size = irttp_get_max_seg_size(new->tsap);\r\n#endif\r\nirttp_listen(server->tsap);\r\nirttp_connect_response(new->tsap, new->max_sdu_size_rx, NULL);\r\nset_bit(0, &new->ttp_open);\r\nclear_bit(0, &new->ttp_connect);\r\nif(new->iriap)\r\n{\r\niriap_close(new->iriap);\r\nnew->iriap = NULL;\r\n}\r\nif(new->discoveries != NULL)\r\n{\r\nkfree(new->discoveries);\r\nnew->discoveries = NULL;\r\n}\r\n#ifdef CONNECT_INDIC_KICK\r\nppp_output_wakeup(&new->chan);\r\n#endif\r\nirnet_post_event(new, IRNET_CONNECT_FROM,\r\nnew->saddr, new->daddr, server->rname, 0);\r\nDEXIT(IRDA_SERV_TRACE, "\n");\r\nreturn 0;\r\n}\r\nstatic inline void\r\nirnet_disconnect_server(irnet_socket * self,\r\nstruct sk_buff *skb)\r\n{\r\nDENTER(IRDA_SERV_TRACE, "(self=0x%p)\n", self);\r\nkfree_skb(skb);\r\n#ifdef FAIL_SEND_DISCONNECT\r\nirttp_disconnect_request(self->tsap, NULL, P_NORMAL);\r\n#endif\r\nirnet_post_event(NULL, IRNET_REQUEST_FROM,\r\nself->saddr, self->daddr, self->rname, 0);\r\nirttp_listen(self->tsap);\r\nDEXIT(IRDA_SERV_TRACE, "\n");\r\n}\r\nstatic inline int\r\nirnet_setup_server(void)\r\n{\r\n__u16 hints;\r\nDENTER(IRDA_SERV_TRACE, "()\n");\r\nirda_irnet_create(&irnet_server.s);\r\nirnet_open_tsap(&irnet_server.s);\r\nirnet_server.s.ppp_open = 0;\r\nirnet_server.s.chan.private = NULL;\r\nirnet_server.s.file = NULL;\r\nhints = irlmp_service_to_hint(S_LAN);\r\n#ifdef ADVERTISE_HINT\r\nirnet_server.skey = irlmp_register_service(hints);\r\n#endif\r\nirnet_server.ias_obj = irias_new_object(IRNET_SERVICE_NAME, jiffies);\r\nirias_add_integer_attrib(irnet_server.ias_obj, IRNET_IAS_VALUE,\r\nirnet_server.s.stsap_sel, IAS_KERNEL_ATTR);\r\nirias_insert_object(irnet_server.ias_obj);\r\n#ifdef DISCOVERY_EVENTS\r\nirlmp_update_client(irnet_server.s.ckey, hints,\r\nirnet_discovery_indication, irnet_expiry_indication,\r\n(void *) &irnet_server.s);\r\n#endif\r\nDEXIT(IRDA_SERV_TRACE, " - self=0x%p\n", &irnet_server.s);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nirnet_destroy_server(void)\r\n{\r\nDENTER(IRDA_SERV_TRACE, "()\n");\r\n#ifdef ADVERTISE_HINT\r\nirlmp_unregister_service(irnet_server.skey);\r\n#endif\r\nif(irnet_server.ias_obj)\r\nirias_delete_object(irnet_server.ias_obj);\r\nirda_irnet_destroy(&irnet_server.s);\r\nDEXIT(IRDA_SERV_TRACE, "\n");\r\n}\r\nstatic int\r\nirnet_data_indication(void * instance,\r\nvoid * sap,\r\nstruct sk_buff *skb)\r\n{\r\nirnet_socket * ap = (irnet_socket *) instance;\r\nunsigned char * p;\r\nint code = 0;\r\nDENTER(IRDA_TCB_TRACE, "(self/ap=0x%p, skb=0x%p)\n",\r\nap, skb);\r\nDASSERT(skb != NULL, 0, IRDA_CB_ERROR, "skb is NULL !!!\n");\r\nif(!ap->ppp_open)\r\n{\r\nDERROR(IRDA_CB_ERROR, "PPP not ready, dropping packet...\n");\r\nreturn -ENOMEM;\r\n}\r\np = skb->data;\r\nif((p[0] == PPP_ALLSTATIONS) && (p[1] == PPP_UI))\r\n{\r\nif(skb->len < 3)\r\ngoto err_exit;\r\np = skb_pull(skb, 2);\r\n}\r\nif(p[0] & 1)\r\n{\r\nskb_push(skb, 1)[0] = 0;\r\n}\r\nelse\r\nif(skb->len < 2)\r\ngoto err_exit;\r\nppp_input(&ap->chan, skb);\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\nreturn 0;\r\nerr_exit:\r\nDERROR(IRDA_CB_ERROR, "Packet too small, dropping...\n");\r\nkfree_skb(skb);\r\nppp_input_error(&ap->chan, code);\r\nreturn 0;\r\n}\r\nstatic void\r\nirnet_disconnect_indication(void * instance,\r\nvoid * sap,\r\nLM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nirnet_socket * self = (irnet_socket *) instance;\r\nint test_open;\r\nint test_connect;\r\nDENTER(IRDA_TCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(self != NULL, , IRDA_CB_ERROR, "Self is NULL !!!\n");\r\nif(skb)\r\ndev_kfree_skb(skb);\r\ntest_open = test_and_clear_bit(0, &self->ttp_open);\r\ntest_connect = test_and_clear_bit(0, &self->ttp_connect);\r\nif(!(test_open || test_connect))\r\n{\r\nDERROR(IRDA_CB_ERROR, "Race condition detected...\n");\r\nreturn;\r\n}\r\nif(test_open)\r\nirnet_post_event(self, IRNET_DISCONNECT_FROM,\r\nself->saddr, self->daddr, self->rname, 0);\r\nelse\r\nif((self->tsap) && (self != &irnet_server.s))\r\nirnet_post_event(self, IRNET_NOANSWER_FROM,\r\nself->saddr, self->daddr, self->rname, 0);\r\nif((self->tsap) && (self != &irnet_server.s))\r\n{\r\nDEBUG(IRDA_CB_INFO, "Closing our TTP connection.\n");\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\nself->stsap_sel = 0;\r\nself->daddr = DEV_ADDR_ANY;\r\nself->tx_flow = FLOW_START;\r\nif(self->ppp_open)\r\n{\r\nif(test_open)\r\n{\r\nschedule_work(&self->disconnect_work);\r\n}\r\nelse\r\n{\r\nppp_output_wakeup(&self->chan);\r\n}\r\n}\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_connect_confirm(void * instance,\r\nvoid * sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nirnet_socket * self = (irnet_socket *) instance;\r\nDENTER(IRDA_TCB_TRACE, "(self=0x%p)\n", self);\r\nif(! test_bit(0, &self->ttp_connect))\r\n{\r\nDERROR(IRDA_CB_ERROR, "Socket no longer connecting. Ouch !\n");\r\nreturn;\r\n}\r\nself->max_header_size = max_header_size;\r\nself->max_sdu_size_tx = max_sdu_size;\r\nself->max_data_size = max_sdu_size;\r\n#ifdef STREAM_COMPAT\r\nif(max_sdu_size == 0)\r\nself->max_data_size = irttp_get_max_seg_size(self->tsap);\r\n#endif\r\nself->saddr = irttp_get_saddr(self->tsap);\r\nset_bit(0, &self->ttp_open);\r\nclear_bit(0, &self->ttp_connect);\r\nppp_output_wakeup(&self->chan);\r\nif(skb->len > 0)\r\n{\r\n#ifdef PASS_CONNECT_PACKETS\r\nDEBUG(IRDA_CB_INFO, "Passing connect packet to PPP.\n");\r\nirnet_data_indication(instance, sap, skb);\r\n#else\r\nDERROR(IRDA_CB_ERROR, "Dropping non empty packet.\n");\r\nkfree_skb(skb);\r\n#endif\r\n}\r\nelse\r\nkfree_skb(skb);\r\nirnet_post_event(self, IRNET_CONNECT_TO,\r\nself->saddr, self->daddr, self->rname, 0);\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_flow_indication(void * instance,\r\nvoid * sap,\r\nLOCAL_FLOW flow)\r\n{\r\nirnet_socket * self = (irnet_socket *) instance;\r\nLOCAL_FLOW oldflow = self->tx_flow;\r\nDENTER(IRDA_TCB_TRACE, "(self=0x%p, flow=%d)\n", self, flow);\r\nself->tx_flow = flow;\r\nswitch(flow)\r\n{\r\ncase FLOW_START:\r\nDEBUG(IRDA_CB_INFO, "IrTTP wants us to start again\n");\r\nif(oldflow == FLOW_STOP)\r\nppp_output_wakeup(&self->chan);\r\nelse\r\nDEBUG(IRDA_CB_INFO, "But we were already transmitting !!!\n");\r\nbreak;\r\ncase FLOW_STOP:\r\nDEBUG(IRDA_CB_INFO, "IrTTP wants us to slow down\n");\r\nbreak;\r\ndefault:\r\nDEBUG(IRDA_CB_INFO, "Unknown flow command!\n");\r\nbreak;\r\n}\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_status_indication(void * instance,\r\nLINK_STATUS link,\r\nLOCK_STATUS lock)\r\n{\r\nirnet_socket * self = (irnet_socket *) instance;\r\nDENTER(IRDA_TCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(self != NULL, , IRDA_CB_ERROR, "Self is NULL !!!\n");\r\nswitch(link)\r\n{\r\ncase STATUS_NO_ACTIVITY:\r\nirnet_post_event(self, IRNET_BLOCKED_LINK,\r\nself->saddr, self->daddr, self->rname, 0);\r\nbreak;\r\ndefault:\r\nDEBUG(IRDA_CB_INFO, "Unknown status...\n");\r\n}\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_connect_indication(void * instance,\r\nvoid * sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nirnet_socket * server = &irnet_server.s;\r\nirnet_socket * new = (irnet_socket *) NULL;\r\nDENTER(IRDA_TCB_TRACE, "(server=0x%p)\n", server);\r\nDASSERT(instance == &irnet_server, , IRDA_CB_ERROR,\r\n"Invalid instance (0x%p) !!!\n", instance);\r\nDASSERT(sap == irnet_server.s.tsap, , IRDA_CB_ERROR, "Invalid sap !!!\n");\r\nnew = irnet_find_socket(server);\r\nif(new == (irnet_socket *) NULL)\r\n{\r\nDEXIT(IRDA_CB_INFO, ": No socket waiting for this connection.\n");\r\nirnet_disconnect_server(server, skb);\r\nreturn;\r\n}\r\nif(test_bit(0, &new->ttp_open))\r\n{\r\nDEXIT(IRDA_CB_INFO, ": Socket already connected.\n");\r\nirnet_disconnect_server(server, skb);\r\nreturn;\r\n}\r\nif(0\r\n#ifdef ALLOW_SIMULT_CONNECT\r\n|| ((irttp_is_primary(server->tsap) == 1) &&\r\n(test_and_clear_bit(0, &new->ttp_connect)))\r\n#endif\r\n)\r\n{\r\nDERROR(IRDA_CB_ERROR, "Socket already connecting, but going to reuse it !\n");\r\nif(new->tsap != NULL)\r\n{\r\nirttp_close_tsap(new->tsap);\r\nnew->tsap = NULL;\r\n}\r\n}\r\nelse\r\n{\r\nif((test_bit(0, &new->ttp_connect)) || (new->tsap != NULL))\r\n{\r\nDERROR(IRDA_CB_ERROR, "Race condition detected, socket in use, abort connect...\n");\r\nirnet_disconnect_server(server, skb);\r\nreturn;\r\n}\r\n}\r\nirnet_connect_socket(server, new, qos, max_sdu_size, max_header_size);\r\nif(skb->len > 0)\r\n{\r\n#ifdef PASS_CONNECT_PACKETS\r\nDEBUG(IRDA_CB_INFO, "Passing connect packet to PPP.\n");\r\nirnet_data_indication(new, new->tsap, skb);\r\n#else\r\nDERROR(IRDA_CB_ERROR, "Dropping non empty packet.\n");\r\nkfree_skb(skb);\r\n#endif\r\n}\r\nelse\r\nkfree_skb(skb);\r\nDEXIT(IRDA_TCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_getvalue_confirm(int result,\r\n__u16 obj_id,\r\nstruct ias_value *value,\r\nvoid * priv)\r\n{\r\nirnet_socket * self = (irnet_socket *) priv;\r\nDENTER(IRDA_OCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(self != NULL, , IRDA_OCB_ERROR, "Self is NULL !!!\n");\r\nif(! test_bit(0, &self->ttp_connect))\r\n{\r\nDERROR(IRDA_OCB_ERROR, "Socket no longer connecting. Ouch !\n");\r\nreturn;\r\n}\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\nself->dtsap_sel = irnet_ias_to_tsap(self, result, value);\r\nif(self->errno)\r\n{\r\nclear_bit(0, &self->ttp_connect);\r\nDERROR(IRDA_OCB_ERROR, "IAS connect failed ! (0x%X)\n", self->errno);\r\nreturn;\r\n}\r\nDEBUG(IRDA_OCB_INFO, "daddr = %08x, lsap = %d, starting IrTTP connection\n",\r\nself->daddr, self->dtsap_sel);\r\nirnet_connect_tsap(self);\r\nDEXIT(IRDA_OCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_discovervalue_confirm(int result,\r\n__u16 obj_id,\r\nstruct ias_value *value,\r\nvoid * priv)\r\n{\r\nirnet_socket * self = (irnet_socket *) priv;\r\n__u8 dtsap_sel;\r\nDENTER(IRDA_OCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(self != NULL, , IRDA_OCB_ERROR, "Self is NULL !!!\n");\r\nif(! test_bit(0, &self->ttp_connect))\r\n{\r\nDERROR(IRDA_OCB_ERROR, "Socket no longer connecting. Ouch !\n");\r\nreturn;\r\n}\r\ndtsap_sel = irnet_ias_to_tsap(self, result, value);\r\nif(self->errno == 0)\r\n{\r\nif(self->daddr != DEV_ADDR_ANY)\r\n{\r\nDERROR(IRDA_OCB_ERROR, "More than one device in range supports IrNET...\n");\r\n}\r\nelse\r\n{\r\nself->daddr = self->discoveries[self->disco_index].daddr;\r\nself->dtsap_sel = dtsap_sel;\r\n}\r\n}\r\nif((self->errno == -EADDRNOTAVAIL) || (self->errno == 0))\r\n{\r\nint ret;\r\nret = irnet_discover_next_daddr(self);\r\nif(!ret)\r\n{\r\nreturn;\r\n}\r\n}\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\nDEBUG(IRDA_OCB_INFO, "Cleaning up log (0x%p)\n",\r\nself->discoveries);\r\nif(self->discoveries != NULL)\r\n{\r\nkfree(self->discoveries);\r\nself->discoveries = NULL;\r\n}\r\nself->disco_number = -1;\r\nif(self->daddr == DEV_ADDR_ANY)\r\n{\r\nself->daddr = DEV_ADDR_ANY;\r\nclear_bit(0, &self->ttp_connect);\r\nDEXIT(IRDA_OCB_TRACE, ": cannot discover IrNET in any device !!!\n");\r\nreturn;\r\n}\r\nDEBUG(IRDA_OCB_INFO, "daddr = %08x, lsap = %d, starting IrTTP connection\n",\r\nself->daddr, self->dtsap_sel);\r\nirnet_connect_tsap(self);\r\nDEXIT(IRDA_OCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_discovery_indication(discinfo_t * discovery,\r\nDISCOVERY_MODE mode,\r\nvoid * priv)\r\n{\r\nirnet_socket * self = &irnet_server.s;\r\nDENTER(IRDA_OCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(priv == &irnet_server, , IRDA_OCB_ERROR,\r\n"Invalid instance (0x%p) !!!\n", priv);\r\nDEBUG(IRDA_OCB_INFO, "Discovered new IrNET/IrLAN node %s...\n",\r\ndiscovery->info);\r\nirnet_post_event(NULL, IRNET_DISCOVER,\r\ndiscovery->saddr, discovery->daddr, discovery->info,\r\nget_unaligned((__u16 *)discovery->hints));\r\nDEXIT(IRDA_OCB_TRACE, "\n");\r\n}\r\nstatic void\r\nirnet_expiry_indication(discinfo_t * expiry,\r\nDISCOVERY_MODE mode,\r\nvoid * priv)\r\n{\r\nirnet_socket * self = &irnet_server.s;\r\nDENTER(IRDA_OCB_TRACE, "(self=0x%p)\n", self);\r\nDASSERT(priv == &irnet_server, , IRDA_OCB_ERROR,\r\n"Invalid instance (0x%p) !!!\n", priv);\r\nDEBUG(IRDA_OCB_INFO, "IrNET/IrLAN node %s expired...\n",\r\nexpiry->info);\r\nirnet_post_event(NULL, IRNET_EXPIRE,\r\nexpiry->saddr, expiry->daddr, expiry->info,\r\nget_unaligned((__u16 *)expiry->hints));\r\nDEXIT(IRDA_OCB_TRACE, "\n");\r\n}\r\nstatic int\r\nirnet_proc_show(struct seq_file *m, void *v)\r\n{\r\nirnet_socket * self;\r\nchar * state;\r\nint i = 0;\r\nseq_printf(m, "IrNET server - ");\r\nseq_printf(m, "IrDA state: %s, ",\r\n(irnet_server.running ? "running" : "dead"));\r\nseq_printf(m, "stsap_sel: %02x, ", irnet_server.s.stsap_sel);\r\nseq_printf(m, "dtsap_sel: %02x\n", irnet_server.s.dtsap_sel);\r\nif(!irnet_server.running)\r\nreturn 0;\r\nspin_lock_bh(&irnet_server.spinlock);\r\nself = (irnet_socket *) hashbin_get_first(irnet_server.list);\r\nwhile(self != NULL)\r\n{\r\nseq_printf(m, "\nIrNET socket %d - ", i++);\r\nseq_printf(m, "Requested IrDA name: \"%s\", ", self->rname);\r\nseq_printf(m, "daddr: %08x, ", self->rdaddr);\r\nseq_printf(m, "saddr: %08x\n", self->rsaddr);\r\nseq_printf(m, " PPP state: %s",\r\n(self->ppp_open ? "registered" : "unregistered"));\r\nif(self->ppp_open)\r\n{\r\nseq_printf(m, ", unit: ppp%d",\r\nppp_unit_number(&self->chan));\r\nseq_printf(m, ", channel: %d",\r\nppp_channel_index(&self->chan));\r\nseq_printf(m, ", mru: %d",\r\nself->mru);\r\n}\r\nif(self->ttp_open)\r\nstate = "connected";\r\nelse\r\nif(self->tsap != NULL)\r\nstate = "connecting";\r\nelse\r\nif(self->iriap != NULL)\r\nstate = "searching";\r\nelse\r\nif(self->ttp_connect)\r\nstate = "weird";\r\nelse\r\nstate = "idle";\r\nseq_printf(m, "\n IrDA state: %s, ", state);\r\nseq_printf(m, "daddr: %08x, ", self->daddr);\r\nseq_printf(m, "stsap_sel: %02x, ", self->stsap_sel);\r\nseq_printf(m, "dtsap_sel: %02x\n", self->dtsap_sel);\r\nself = (irnet_socket *) hashbin_get_next(irnet_server.list);\r\n}\r\nspin_unlock_bh(&irnet_server.spinlock);\r\nreturn 0;\r\n}\r\nstatic int irnet_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, irnet_proc_show, NULL);\r\n}\r\nint __init\r\nirda_irnet_init(void)\r\n{\r\nint err = 0;\r\nDENTER(MODULE_TRACE, "()\n");\r\nmemset(&irnet_server, 0, sizeof(struct irnet_root));\r\nirnet_server.list = hashbin_new(HB_NOLOCK);\r\nDABORT(irnet_server.list == NULL, -ENOMEM,\r\nMODULE_ERROR, "Can't allocate hashbin!\n");\r\nspin_lock_init(&irnet_server.spinlock);\r\ninit_waitqueue_head(&irnet_events.rwait);\r\nirnet_events.index = 0;\r\nspin_lock_init(&irnet_events.spinlock);\r\n#ifdef CONFIG_PROC_FS\r\nproc_create("irnet", 0, proc_irda, &irnet_proc_fops);\r\n#endif\r\nerr = irnet_setup_server();\r\nif(!err)\r\nirnet_server.running = 1;\r\nDEXIT(MODULE_TRACE, "\n");\r\nreturn err;\r\n}\r\nvoid __exit\r\nirda_irnet_cleanup(void)\r\n{\r\nDENTER(MODULE_TRACE, "()\n");\r\nirnet_server.running = 0;\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("irnet", proc_irda);\r\n#endif\r\nirnet_destroy_server();\r\nhashbin_delete(irnet_server.list, (FREE_FUNC) irda_irnet_destroy);\r\nDEXIT(MODULE_TRACE, "\n");\r\n}
