static int tda10048_writereg(struct tda10048_state *state, u8 reg, u8 data)\r\n{\r\nstruct tda10048_config *config = &state->config;\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = config->demod_address,\r\n.flags = 0, .buf = buf, .len = 2 };\r\ndprintk(2, "%s(reg = 0x%02x, data = 0x%02x)\n", __func__, reg, data);\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk("%s: writereg error (ret == %i)\n", __func__, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic u8 tda10048_readreg(struct tda10048_state *state, u8 reg)\r\n{\r\nstruct tda10048_config *config = &state->config;\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = config->demod_address,\r\n.flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = config->demod_address,\r\n.flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\ndprintk(2, "%s(reg = 0x%02x)\n", __func__, reg);\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s: readreg error (ret == %i)\n",\r\n__func__, ret);\r\nreturn b1[0];\r\n}\r\nstatic int tda10048_writeregbulk(struct tda10048_state *state, u8 reg,\r\nconst u8 *data, u16 len)\r\n{\r\nstruct tda10048_config *config = &state->config;\r\nint ret = -EREMOTEIO;\r\nstruct i2c_msg msg;\r\nu8 *buf;\r\ndprintk(2, "%s(%d, ?, len = %d)\n", __func__, reg, len);\r\nbuf = kmalloc(len + 1, GFP_KERNEL);\r\nif (buf == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n*buf = reg;\r\nmemcpy(buf + 1, data, len);\r\nmsg.addr = config->demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = len + 1;\r\ndprintk(2, "%s(): write len = %d\n",\r\n__func__, msg.len);\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nprintk(KERN_ERR "%s(): writereg error err %i\n",\r\n__func__, ret);\r\nret = -EREMOTEIO;\r\n}\r\nerror:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int tda10048_set_phy2(struct dvb_frontend *fe, u32 sample_freq_hz,\r\nu32 if_hz)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu64 t;\r\ndprintk(1, "%s()\n", __func__);\r\nif (sample_freq_hz == 0)\r\nreturn -EINVAL;\r\nif (if_hz < (sample_freq_hz / 2)) {\r\nt = if_hz;\r\nt *= 10;\r\nt *= 32768;\r\ndo_div(t, sample_freq_hz);\r\nt += 5;\r\ndo_div(t, 10);\r\n} else {\r\nt = sample_freq_hz - if_hz;\r\nt *= 10;\r\nt *= 32768;\r\ndo_div(t, sample_freq_hz);\r\nt += 5;\r\ndo_div(t, 10);\r\nt = ~t + 1;\r\n}\r\ntda10048_writereg(state, TDA10048_FREQ_PHY2_LSB, (u8)t);\r\ntda10048_writereg(state, TDA10048_FREQ_PHY2_MSB, (u8)(t >> 8));\r\nreturn 0;\r\n}\r\nstatic int tda10048_set_wref(struct dvb_frontend *fe, u32 sample_freq_hz,\r\nu32 bw)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu64 t, z;\r\ndprintk(1, "%s()\n", __func__);\r\nif (sample_freq_hz == 0)\r\nreturn -EINVAL;\r\nt = bw * 10;\r\nt *= (2048 * 1024);\r\nt *= 1024;\r\nz = 7 * sample_freq_hz;\r\ndo_div(t, z);\r\nt += 5;\r\ndo_div(t, 10);\r\ntda10048_writereg(state, TDA10048_TIME_WREF_LSB, (u8)t);\r\ntda10048_writereg(state, TDA10048_TIME_WREF_MID1, (u8)(t >> 8));\r\ntda10048_writereg(state, TDA10048_TIME_WREF_MID2, (u8)(t >> 16));\r\ntda10048_writereg(state, TDA10048_TIME_WREF_MSB, (u8)(t >> 24));\r\nreturn 0;\r\n}\r\nstatic int tda10048_set_invwref(struct dvb_frontend *fe, u32 sample_freq_hz,\r\nu32 bw)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu64 t;\r\ndprintk(1, "%s()\n", __func__);\r\nif (sample_freq_hz == 0)\r\nreturn -EINVAL;\r\nt = sample_freq_hz;\r\nt *= 7;\r\nt *= 32;\r\nt *= 10;\r\ndo_div(t, bw);\r\nt += 5;\r\ndo_div(t, 10);\r\ntda10048_writereg(state, TDA10048_TIME_INVWREF_LSB, (u8)t);\r\ntda10048_writereg(state, TDA10048_TIME_INVWREF_MSB, (u8)(t >> 8));\r\nreturn 0;\r\n}\r\nstatic int tda10048_set_bandwidth(struct dvb_frontend *fe,\r\nu32 bw)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s(bw=%d)\n", __func__, bw);\r\nswitch (bw) {\r\ncase 6000000:\r\ncase 7000000:\r\ncase 8000000:\r\ntda10048_set_wref(fe, state->sample_freq, bw);\r\ntda10048_set_invwref(fe, state->sample_freq, bw);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s() invalid bandwidth\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstate->bandwidth = bw;\r\nreturn 0;\r\n}\r\nstatic int tda10048_set_if(struct dvb_frontend *fe, u32 bw)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstruct tda10048_config *config = &state->config;\r\nint i;\r\nu32 if_freq_khz;\r\ndprintk(1, "%s(bw = %d)\n", __func__, bw);\r\nswitch (bw) {\r\ncase 6000000:\r\nif_freq_khz = config->dtv6_if_freq_khz;\r\nbreak;\r\ncase 7000000:\r\nif_freq_khz = config->dtv7_if_freq_khz;\r\nbreak;\r\ncase 8000000:\r\nif_freq_khz = config->dtv8_if_freq_khz;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s() no default\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pll_tab); i++) {\r\nif ((pll_tab[i].clk_freq_khz == config->clk_freq_khz) &&\r\n(pll_tab[i].if_freq_khz == if_freq_khz)) {\r\nstate->freq_if_hz = pll_tab[i].if_freq_khz * 1000;\r\nstate->xtal_hz = pll_tab[i].clk_freq_khz * 1000;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(pll_tab)) {\r\nprintk(KERN_ERR "%s() Incorrect attach settings\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ndprintk(1, "- freq_if_hz = %d\n", state->freq_if_hz);\r\ndprintk(1, "- xtal_hz = %d\n", state->xtal_hz);\r\ndprintk(1, "- pll_mfactor = %d\n", state->pll_mfactor);\r\ndprintk(1, "- pll_nfactor = %d\n", state->pll_nfactor);\r\ndprintk(1, "- pll_pfactor = %d\n", state->pll_pfactor);\r\nstate->sample_freq = state->xtal_hz * (state->pll_mfactor + 45);\r\nstate->sample_freq /= (state->pll_nfactor + 1);\r\nstate->sample_freq /= (state->pll_pfactor + 4);\r\ndprintk(1, "- sample_freq = %d\n", state->sample_freq);\r\ntda10048_set_phy2(fe, state->sample_freq, state->freq_if_hz);\r\nreturn 0;\r\n}\r\nstatic int tda10048_firmware_upload(struct dvb_frontend *fe)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstruct tda10048_config *config = &state->config;\r\nconst struct firmware *fw;\r\nint ret;\r\nint pos = 0;\r\nint cnt;\r\nu8 wlen = config->fwbulkwritelen;\r\nif ((wlen != TDA10048_BULKWRITE_200) && (wlen != TDA10048_BULKWRITE_50))\r\nwlen = TDA10048_BULKWRITE_200;\r\nprintk(KERN_INFO "%s: waiting for firmware upload (%s)...\n",\r\n__func__,\r\nTDA10048_DEFAULT_FIRMWARE);\r\nret = request_firmware(&fw, TDA10048_DEFAULT_FIRMWARE,\r\nstate->i2c->dev.parent);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Upload failed. (file not found?)\n",\r\n__func__);\r\nreturn -EIO;\r\n} else {\r\nprintk(KERN_INFO "%s: firmware read %Zu bytes.\n",\r\n__func__,\r\nfw->size);\r\nret = 0;\r\n}\r\nif (fw->size != TDA10048_DEFAULT_FIRMWARE_SIZE) {\r\nprintk(KERN_ERR "%s: firmware incorrect size\n", __func__);\r\nret = -EIO;\r\n} else {\r\nprintk(KERN_INFO "%s: firmware uploading\n", __func__);\r\ntda10048_writereg(state, TDA10048_CONF_TRISTATE1,\r\ntda10048_readreg(state, TDA10048_CONF_TRISTATE1)\r\n& 0xfe);\r\ntda10048_writereg(state, TDA10048_CONF_TRISTATE1,\r\ntda10048_readreg(state, TDA10048_CONF_TRISTATE1)\r\n| 0x01);\r\ntda10048_writereg(state, TDA10048_CONF_C4_1,\r\ntda10048_readreg(state, TDA10048_CONF_C4_1) & 0xf9);\r\ntda10048_writereg(state, TDA10048_CONF_C4_1,\r\ntda10048_readreg(state, TDA10048_CONF_C4_1) | 0x08);\r\ntda10048_writereg(state, TDA10048_DSP_CODE_CPT, 0);\r\nwhile (pos < fw->size) {\r\nif ((fw->size - pos) > wlen)\r\ncnt = wlen;\r\nelse\r\ncnt = fw->size - pos;\r\ntda10048_writeregbulk(state, TDA10048_DSP_CODE_IN,\r\n&fw->data[pos], cnt);\r\npos += cnt;\r\n}\r\nret = -EIO;\r\nfor (cnt = 0; cnt < 250 ; cnt += 10) {\r\nmsleep(10);\r\nif (tda10048_readreg(state, TDA10048_SYNC_STATUS)\r\n& 0x40) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nrelease_firmware(fw);\r\nif (ret == 0) {\r\nprintk(KERN_INFO "%s: firmware uploaded\n", __func__);\r\nstate->fwloaded = 1;\r\n} else\r\nprintk(KERN_ERR "%s: firmware upload failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int tda10048_set_inversion(struct dvb_frontend *fe, int inversion)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s(%d)\n", __func__, inversion);\r\nif (inversion == TDA10048_INVERSION_ON)\r\ntda10048_writereg(state, TDA10048_CONF_C1_1,\r\ntda10048_readreg(state, TDA10048_CONF_C1_1) | 0x20);\r\nelse\r\ntda10048_writereg(state, TDA10048_CONF_C1_1,\r\ntda10048_readreg(state, TDA10048_CONF_C1_1) & 0xdf);\r\nreturn 0;\r\n}\r\nstatic int tda10048_get_tps(struct tda10048_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu8 val;\r\nif (!(tda10048_readreg(state, TDA10048_AUTO) & 0x01))\r\nreturn -EAGAIN;\r\nval = tda10048_readreg(state, TDA10048_OUT_CONF2);\r\nswitch ((val & 0x60) >> 5) {\r\ncase 0:\r\np->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\np->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\np->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((val & 0x18) >> 3) {\r\ncase 0:\r\np->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\np->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\np->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\np->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch (val & 0x07) {\r\ncase 0:\r\np->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nval = tda10048_readreg(state, TDA10048_OUT_CONF3);\r\nswitch (val & 0x07) {\r\ncase 0:\r\np->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nval = tda10048_readreg(state, TDA10048_OUT_CONF1);\r\nswitch ((val & 0x0c) >> 2) {\r\ncase 0:\r\np->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\np->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\np->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\np->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch (val & 0x03) {\r\ncase 0:\r\np->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\np->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10048_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstruct tda10048_config *config = &state->config;\r\ndprintk(1, "%s(%d)\n", __func__, enable);\r\nif (config->disable_gate_access)\r\nreturn 0;\r\nif (enable)\r\nreturn tda10048_writereg(state, TDA10048_CONF_C4_1,\r\ntda10048_readreg(state, TDA10048_CONF_C4_1) | 0x02);\r\nelse\r\nreturn tda10048_writereg(state, TDA10048_CONF_C4_1,\r\ntda10048_readreg(state, TDA10048_CONF_C4_1) & 0xfd);\r\n}\r\nstatic int tda10048_output_mode(struct dvb_frontend *fe, int serial)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s(%d)\n", __func__, serial);\r\ntda10048_writereg(state, TDA10048_CONF_TRISTATE1, 0x21);\r\ntda10048_writereg(state, TDA10048_CONF_TRISTATE2, 0x00);\r\nif (serial) {\r\ntda10048_writereg(state, TDA10048_IC_MODE, 0x80 | 0x20);\r\ntda10048_writereg(state, TDA10048_CONF_TS2, 0xc0);\r\n} else {\r\ntda10048_writereg(state, TDA10048_IC_MODE, 0x00);\r\ntda10048_writereg(state, TDA10048_CONF_TS2, 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10048_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s(frequency=%d)\n", __func__, p->frequency);\r\nif (p->bandwidth_hz != state->bandwidth) {\r\ntda10048_set_if(fe, p->bandwidth_hz);\r\ntda10048_set_bandwidth(fe, p->bandwidth_hz);\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ntda10048_writereg(state, TDA10048_AUTO, 0x57);\r\ntda10048_writereg(state, TDA10048_CVBER_CTRL, 0x3B);\r\nreturn 0;\r\n}\r\nstatic int tda10048_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstruct tda10048_config *config = &state->config;\r\nint ret = 0, i;\r\ndprintk(1, "%s()\n", __func__);\r\ninit_tab[4].data = (u8)(state->pll_mfactor);\r\ninit_tab[5].data = (u8)(state->pll_nfactor) | 0x40;\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\r\ntda10048_writereg(state, init_tab[i].reg, init_tab[i].data);\r\nif (state->fwloaded == 0)\r\nret = tda10048_firmware_upload(fe);\r\ntda10048_output_mode(fe, config->output_mode);\r\ntda10048_set_inversion(fe, config->inversion);\r\ntda10048_set_if(fe, 8000000);\r\ntda10048_set_bandwidth(fe, 8000000);\r\ntda10048_i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int tda10048_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu8 reg;\r\n*status = 0;\r\nreg = tda10048_readreg(state, TDA10048_SYNC_STATUS);\r\ndprintk(1, "%s() status =0x%02x\n", __func__, reg);\r\nif (reg & 0x02)\r\n*status |= FE_HAS_CARRIER;\r\nif (reg & 0x04)\r\n*status |= FE_HAS_SIGNAL;\r\nif (reg & 0x08) {\r\n*status |= FE_HAS_LOCK;\r\n*status |= FE_HAS_VITERBI;\r\n*status |= FE_HAS_SYNC;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10048_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstatic u32 cber_current;\r\nu32 cber_nmax;\r\nu64 cber_tmp;\r\ndprintk(1, "%s()\n", __func__);\r\nif (tda10048_readreg(state, TDA10048_SOFT_IT_C3) & 0x01) {\r\ncber_tmp = tda10048_readreg(state, TDA10048_CBER_MSB) << 8 |\r\ntda10048_readreg(state, TDA10048_CBER_LSB);\r\ncber_nmax = tda10048_readreg(state, TDA10048_CBER_NMAX_MSB) << 8 |\r\ntda10048_readreg(state, TDA10048_CBER_NMAX_LSB);\r\ncber_tmp *= 100000000;\r\ncber_tmp *= 2;\r\ncber_tmp = div_u64(cber_tmp, (cber_nmax * 32) + 1);\r\ncber_current = (u32)cber_tmp;\r\ntda10048_writereg(state, TDA10048_CVBER_CTRL, 0x39);\r\n}\r\n*ber = cber_current;\r\nreturn 0;\r\n}\r\nstatic int tda10048_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu8 v;\r\ndprintk(1, "%s()\n", __func__);\r\n*signal_strength = 65535;\r\nv = tda10048_readreg(state, TDA10048_NP_OUT);\r\nif (v > 0)\r\n*signal_strength -= (v << 8) | v;\r\nreturn 0;\r\n}\r\nstatic int tda10048_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nu8 v;\r\nint i, ret = -EINVAL;\r\ndprintk(1, "%s()\n", __func__);\r\nv = tda10048_readreg(state, TDA10048_NP_OUT);\r\nfor (i = 0; i < ARRAY_SIZE(snr_tab); i++) {\r\nif (v <= snr_tab[i].val) {\r\n*snr = snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda10048_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s()\n", __func__);\r\n*ucblocks = tda10048_readreg(state, TDA10048_UNCOR_CPT_MSB) << 8 |\r\ntda10048_readreg(state, TDA10048_UNCOR_CPT_LSB);\r\nif (*ucblocks == 0xFFFF)\r\ntda10048_writereg(state, TDA10048_UNCOR_CTRL, 0x80);\r\nreturn 0;\r\n}\r\nstatic int tda10048_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s()\n", __func__);\r\np->inversion = tda10048_readreg(state, TDA10048_CONF_C1_1)\r\n& 0x20 ? INVERSION_ON : INVERSION_OFF;\r\nreturn tda10048_get_tps(state, p);\r\n}\r\nstatic int tda10048_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void tda10048_release(struct dvb_frontend *fe)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\ndprintk(1, "%s()\n", __func__);\r\nkfree(state);\r\n}\r\nstatic void tda10048_establish_defaults(struct dvb_frontend *fe)\r\n{\r\nstruct tda10048_state *state = fe->demodulator_priv;\r\nstruct tda10048_config *config = &state->config;\r\nif (config->dtv6_if_freq_khz == 0) {\r\nconfig->dtv6_if_freq_khz = TDA10048_IF_4300;\r\nprintk(KERN_WARNING "%s() tda10048_config.dtv6_if_freq_khz "\r\n"is not set (defaulting to %d)\n",\r\n__func__,\r\nconfig->dtv6_if_freq_khz);\r\n}\r\nif (config->dtv7_if_freq_khz == 0) {\r\nconfig->dtv7_if_freq_khz = TDA10048_IF_4300;\r\nprintk(KERN_WARNING "%s() tda10048_config.dtv7_if_freq_khz "\r\n"is not set (defaulting to %d)\n",\r\n__func__,\r\nconfig->dtv7_if_freq_khz);\r\n}\r\nif (config->dtv8_if_freq_khz == 0) {\r\nconfig->dtv8_if_freq_khz = TDA10048_IF_4300;\r\nprintk(KERN_WARNING "%s() tda10048_config.dtv8_if_freq_khz "\r\n"is not set (defaulting to %d)\n",\r\n__func__,\r\nconfig->dtv8_if_freq_khz);\r\n}\r\nif (config->clk_freq_khz == 0) {\r\nconfig->clk_freq_khz = TDA10048_CLK_16000;\r\nprintk(KERN_WARNING "%s() tda10048_config.clk_freq_khz "\r\n"is not set (defaulting to %d)\n",\r\n__func__,\r\nconfig->clk_freq_khz);\r\n}\r\n}\r\nstruct dvb_frontend *tda10048_attach(const struct tda10048_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct tda10048_state *state = NULL;\r\ndprintk(1, "%s()\n", __func__);\r\nstate = kzalloc(sizeof(struct tda10048_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nmemcpy(&state->config, config, sizeof(*config));\r\nstate->i2c = i2c;\r\nstate->fwloaded = config->no_firmware;\r\nstate->bandwidth = 8000000;\r\nif (tda10048_readreg(state, TDA10048_IDENTITY) != 0x048)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &tda10048_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nif (config->set_pll) {\r\nstate->pll_mfactor = config->pll_m;\r\nstate->pll_nfactor = config->pll_n;\r\nstate->pll_pfactor = config->pll_p;\r\n} else {\r\nstate->pll_mfactor = 10;\r\nstate->pll_nfactor = 3;\r\nstate->pll_pfactor = 0;\r\n}\r\ntda10048_establish_defaults(&state->frontend);\r\nif (tda10048_set_if(&state->frontend, 8000000) != 0)\r\ngoto error;\r\nif (tda10048_set_bandwidth(&state->frontend, 8000000) != 0)\r\ngoto error;\r\ntda10048_i2c_gate_ctrl(&state->frontend, 0);\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
