static inline struct mcryptd_hash_request_ctx\r\n*cast_hash_to_mcryptd_ctx(struct sha256_hash_ctx *hash_ctx)\r\n{\r\nstruct ahash_request *areq;\r\nareq = container_of((void *) hash_ctx, struct ahash_request, __ctx);\r\nreturn container_of(areq, struct mcryptd_hash_request_ctx, areq);\r\n}\r\nstatic inline struct ahash_request\r\n*cast_mcryptd_ctx_to_req(struct mcryptd_hash_request_ctx *ctx)\r\n{\r\nreturn container_of((void *) ctx, struct ahash_request, __ctx);\r\n}\r\nstatic void req_ctx_init(struct mcryptd_hash_request_ctx *rctx,\r\nstruct ahash_request *areq)\r\n{\r\nrctx->flag = HASH_UPDATE;\r\n}\r\ninline void sha256_init_digest(uint32_t *digest)\r\n{\r\nstatic const uint32_t initial_digest[SHA256_DIGEST_LENGTH] = {\r\nSHA256_H0, SHA256_H1, SHA256_H2, SHA256_H3,\r\nSHA256_H4, SHA256_H5, SHA256_H6, SHA256_H7};\r\nmemcpy(digest, initial_digest, sizeof(initial_digest));\r\n}\r\ninline uint32_t sha256_pad(uint8_t padblock[SHA256_BLOCK_SIZE * 2],\r\nuint32_t total_len)\r\n{\r\nuint32_t i = total_len & (SHA256_BLOCK_SIZE - 1);\r\nmemset(&padblock[i], 0, SHA256_BLOCK_SIZE);\r\npadblock[i] = 0x80;\r\ni += ((SHA256_BLOCK_SIZE - 1) &\r\n(0 - (total_len + SHA256_PADLENGTHFIELD_SIZE + 1)))\r\n+ 1 + SHA256_PADLENGTHFIELD_SIZE;\r\n#if SHA256_PADLENGTHFIELD_SIZE == 16\r\n*((uint64_t *) &padblock[i - 16]) = 0;\r\n#endif\r\n*((uint64_t *) &padblock[i - 8]) = cpu_to_be64(total_len << 3);\r\nreturn i >> SHA256_LOG2_BLOCK_SIZE;\r\n}\r\nstatic struct sha256_hash_ctx\r\n*sha256_ctx_mgr_resubmit(struct sha256_ctx_mgr *mgr,\r\nstruct sha256_hash_ctx *ctx)\r\n{\r\nwhile (ctx) {\r\nif (ctx->status & HASH_CTX_STS_COMPLETE) {\r\nctx->status = HASH_CTX_STS_COMPLETE;\r\nreturn ctx;\r\n}\r\nif (ctx->partial_block_buffer_length == 0 &&\r\nctx->incoming_buffer_length) {\r\nconst void *buffer = ctx->incoming_buffer;\r\nuint32_t len = ctx->incoming_buffer_length;\r\nuint32_t copy_len;\r\ncopy_len = len & (SHA256_BLOCK_SIZE-1);\r\nif (copy_len) {\r\nlen -= copy_len;\r\nmemcpy(ctx->partial_block_buffer,\r\n((const char *) buffer + len),\r\ncopy_len);\r\nctx->partial_block_buffer_length = copy_len;\r\n}\r\nctx->incoming_buffer_length = 0;\r\nassert((len % SHA256_BLOCK_SIZE) == 0);\r\nlen >>= SHA256_LOG2_BLOCK_SIZE;\r\nif (len) {\r\nctx->job.buffer = (uint8_t *) buffer;\r\nctx->job.len = len;\r\nctx = (struct sha256_hash_ctx *)\r\nsha256_job_mgr_submit(&mgr->mgr, &ctx->job);\r\ncontinue;\r\n}\r\n}\r\nif (ctx->status & HASH_CTX_STS_LAST) {\r\nuint8_t *buf = ctx->partial_block_buffer;\r\nuint32_t n_extra_blocks =\r\nsha256_pad(buf, ctx->total_length);\r\nctx->status = (HASH_CTX_STS_PROCESSING |\r\nHASH_CTX_STS_COMPLETE);\r\nctx->job.buffer = buf;\r\nctx->job.len = (uint32_t) n_extra_blocks;\r\nctx = (struct sha256_hash_ctx *)\r\nsha256_job_mgr_submit(&mgr->mgr, &ctx->job);\r\ncontinue;\r\n}\r\nctx->status = HASH_CTX_STS_IDLE;\r\nreturn ctx;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sha256_hash_ctx\r\n*sha256_ctx_mgr_get_comp_ctx(struct sha256_ctx_mgr *mgr)\r\n{\r\nstruct sha256_hash_ctx *ctx;\r\nctx = (struct sha256_hash_ctx *) sha256_job_mgr_get_comp_job(&mgr->mgr);\r\nreturn sha256_ctx_mgr_resubmit(mgr, ctx);\r\n}\r\nstatic void sha256_ctx_mgr_init(struct sha256_ctx_mgr *mgr)\r\n{\r\nsha256_job_mgr_init(&mgr->mgr);\r\n}\r\nstatic struct sha256_hash_ctx *sha256_ctx_mgr_submit(struct sha256_ctx_mgr *mgr,\r\nstruct sha256_hash_ctx *ctx,\r\nconst void *buffer,\r\nuint32_t len,\r\nint flags)\r\n{\r\nif (flags & (~HASH_ENTIRE)) {\r\nctx->error = HASH_CTX_ERROR_INVALID_FLAGS;\r\nreturn ctx;\r\n}\r\nif (ctx->status & HASH_CTX_STS_PROCESSING) {\r\nctx->error = HASH_CTX_ERROR_ALREADY_PROCESSING;\r\nreturn ctx;\r\n}\r\nif ((ctx->status & HASH_CTX_STS_COMPLETE) && !(flags & HASH_FIRST)) {\r\nctx->error = HASH_CTX_ERROR_ALREADY_COMPLETED;\r\nreturn ctx;\r\n}\r\nif (flags & HASH_FIRST) {\r\nsha256_init_digest(ctx->job.result_digest);\r\nctx->total_length = 0;\r\nctx->partial_block_buffer_length = 0;\r\n}\r\nctx->error = HASH_CTX_ERROR_NONE;\r\nctx->incoming_buffer = buffer;\r\nctx->incoming_buffer_length = len;\r\nctx->status = (flags & HASH_LAST) ?\r\n(HASH_CTX_STS_PROCESSING | HASH_CTX_STS_LAST) :\r\nHASH_CTX_STS_PROCESSING;\r\nctx->total_length += len;\r\nif (ctx->partial_block_buffer_length || len < SHA256_BLOCK_SIZE) {\r\nuint32_t copy_len = SHA256_BLOCK_SIZE -\r\nctx->partial_block_buffer_length;\r\nif (len < copy_len)\r\ncopy_len = len;\r\nif (copy_len) {\r\nmemcpy(\r\n&ctx->partial_block_buffer[ctx->partial_block_buffer_length],\r\nbuffer, copy_len);\r\nctx->partial_block_buffer_length += copy_len;\r\nctx->incoming_buffer = (const void *)\r\n((const char *)buffer + copy_len);\r\nctx->incoming_buffer_length = len - copy_len;\r\n}\r\nassert(ctx->partial_block_buffer_length <= SHA256_BLOCK_SIZE);\r\nif (ctx->partial_block_buffer_length >= SHA256_BLOCK_SIZE) {\r\nctx->partial_block_buffer_length = 0;\r\nctx->job.buffer = ctx->partial_block_buffer;\r\nctx->job.len = 1;\r\nctx = (struct sha256_hash_ctx *)\r\nsha256_job_mgr_submit(&mgr->mgr, &ctx->job);\r\n}\r\n}\r\nreturn sha256_ctx_mgr_resubmit(mgr, ctx);\r\n}\r\nstatic struct sha256_hash_ctx *sha256_ctx_mgr_flush(struct sha256_ctx_mgr *mgr)\r\n{\r\nstruct sha256_hash_ctx *ctx;\r\nwhile (1) {\r\nctx = (struct sha256_hash_ctx *)\r\nsha256_job_mgr_flush(&mgr->mgr);\r\nif (!ctx)\r\nreturn NULL;\r\nctx = sha256_ctx_mgr_resubmit(mgr, ctx);\r\nif (ctx)\r\nreturn ctx;\r\n}\r\n}\r\nstatic int sha256_mb_init(struct ahash_request *areq)\r\n{\r\nstruct sha256_hash_ctx *sctx = ahash_request_ctx(areq);\r\nhash_ctx_init(sctx);\r\nsctx->job.result_digest[0] = SHA256_H0;\r\nsctx->job.result_digest[1] = SHA256_H1;\r\nsctx->job.result_digest[2] = SHA256_H2;\r\nsctx->job.result_digest[3] = SHA256_H3;\r\nsctx->job.result_digest[4] = SHA256_H4;\r\nsctx->job.result_digest[5] = SHA256_H5;\r\nsctx->job.result_digest[6] = SHA256_H6;\r\nsctx->job.result_digest[7] = SHA256_H7;\r\nsctx->total_length = 0;\r\nsctx->partial_block_buffer_length = 0;\r\nsctx->status = HASH_CTX_STS_IDLE;\r\nreturn 0;\r\n}\r\nstatic int sha256_mb_set_results(struct mcryptd_hash_request_ctx *rctx)\r\n{\r\nint i;\r\nstruct sha256_hash_ctx *sctx = ahash_request_ctx(&rctx->areq);\r\n__be32 *dst = (__be32 *) rctx->out;\r\nfor (i = 0; i < 8; ++i)\r\ndst[i] = cpu_to_be32(sctx->job.result_digest[i]);\r\nreturn 0;\r\n}\r\nstatic int sha_finish_walk(struct mcryptd_hash_request_ctx **ret_rctx,\r\nstruct mcryptd_alg_cstate *cstate, bool flush)\r\n{\r\nint flag = HASH_UPDATE;\r\nint nbytes, err = 0;\r\nstruct mcryptd_hash_request_ctx *rctx = *ret_rctx;\r\nstruct sha256_hash_ctx *sha_ctx;\r\nwhile (!(rctx->flag & HASH_DONE)) {\r\nnbytes = crypto_ahash_walk_done(&rctx->walk, 0);\r\nif (nbytes < 0) {\r\nerr = nbytes;\r\ngoto out;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk)) {\r\nrctx->flag |= HASH_DONE;\r\nif (rctx->flag & HASH_FINAL)\r\nflag |= HASH_LAST;\r\n}\r\nsha_ctx = (struct sha256_hash_ctx *)\r\nahash_request_ctx(&rctx->areq);\r\nkernel_fpu_begin();\r\nsha_ctx = sha256_ctx_mgr_submit(cstate->mgr, sha_ctx,\r\nrctx->walk.data, nbytes, flag);\r\nif (!sha_ctx) {\r\nif (flush)\r\nsha_ctx = sha256_ctx_mgr_flush(cstate->mgr);\r\n}\r\nkernel_fpu_end();\r\nif (sha_ctx)\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nelse {\r\nrctx = NULL;\r\ngoto out;\r\n}\r\n}\r\nif (rctx->flag & HASH_FINAL)\r\nsha256_mb_set_results(rctx);\r\nout:\r\n*ret_rctx = rctx;\r\nreturn err;\r\n}\r\nstatic int sha_complete_job(struct mcryptd_hash_request_ctx *rctx,\r\nstruct mcryptd_alg_cstate *cstate,\r\nint err)\r\n{\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha256_hash_ctx *sha_ctx;\r\nstruct mcryptd_hash_request_ctx *req_ctx;\r\nint ret;\r\nspin_lock(&cstate->work_lock);\r\nlist_del(&rctx->waiter);\r\nspin_unlock(&cstate->work_lock);\r\nif (irqs_disabled())\r\nrctx->complete(&req->base, err);\r\nelse {\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nsha_ctx = sha256_ctx_mgr_get_comp_ctx(cstate->mgr);\r\nwhile (sha_ctx) {\r\nreq_ctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&req_ctx, cstate, false);\r\nif (req_ctx) {\r\nspin_lock(&cstate->work_lock);\r\nlist_del(&req_ctx->waiter);\r\nspin_unlock(&cstate->work_lock);\r\nreq = cast_mcryptd_ctx_to_req(req_ctx);\r\nif (irqs_disabled())\r\nreq_ctx->complete(&req->base, ret);\r\nelse {\r\nlocal_bh_disable();\r\nreq_ctx->complete(&req->base, ret);\r\nlocal_bh_enable();\r\n}\r\n}\r\nsha_ctx = sha256_ctx_mgr_get_comp_ctx(cstate->mgr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sha256_mb_add_list(struct mcryptd_hash_request_ctx *rctx,\r\nstruct mcryptd_alg_cstate *cstate)\r\n{\r\nunsigned long next_flush;\r\nunsigned long delay = usecs_to_jiffies(FLUSH_INTERVAL);\r\nrctx->tag.arrival = jiffies;\r\nrctx->tag.seq_num = cstate->next_seq_num++;\r\nnext_flush = rctx->tag.arrival + delay;\r\nrctx->tag.expire = next_flush;\r\nspin_lock(&cstate->work_lock);\r\nlist_add_tail(&rctx->waiter, &cstate->work_list);\r\nspin_unlock(&cstate->work_lock);\r\nmcryptd_arm_flusher(cstate, delay);\r\n}\r\nstatic int sha256_mb_update(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx, areq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha256_mb_alg_state.alg_cstate);\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha256_hash_ctx *sha_ctx;\r\nint ret = 0, nbytes;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nnbytes = crypto_ahash_walk_first(req, &rctx->walk);\r\nif (nbytes < 0) {\r\nret = nbytes;\r\ngoto done;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk))\r\nrctx->flag |= HASH_DONE;\r\nsha_ctx = (struct sha256_hash_ctx *) ahash_request_ctx(areq);\r\nsha256_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha256_ctx_mgr_submit(cstate->mgr, sha_ctx, rctx->walk.data,\r\nnbytes, HASH_UPDATE);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha256_mb_finup(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx, areq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha256_mb_alg_state.alg_cstate);\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha256_hash_ctx *sha_ctx;\r\nint ret = 0, flag = HASH_UPDATE, nbytes;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nnbytes = crypto_ahash_walk_first(req, &rctx->walk);\r\nif (nbytes < 0) {\r\nret = nbytes;\r\ngoto done;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk)) {\r\nrctx->flag |= HASH_DONE;\r\nflag = HASH_LAST;\r\n}\r\nrctx->flag |= HASH_FINAL;\r\nsha_ctx = (struct sha256_hash_ctx *) ahash_request_ctx(areq);\r\nsha256_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha256_ctx_mgr_submit(cstate->mgr, sha_ctx, rctx->walk.data,\r\nnbytes, flag);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha256_mb_final(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx,\r\nareq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha256_mb_alg_state.alg_cstate);\r\nstruct sha256_hash_ctx *sha_ctx;\r\nint ret = 0;\r\nu8 data;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nrctx->flag |= HASH_DONE | HASH_FINAL;\r\nsha_ctx = (struct sha256_hash_ctx *) ahash_request_ctx(areq);\r\nsha256_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha256_ctx_mgr_submit(cstate->mgr, sha_ctx, &data, 0,\r\nHASH_LAST);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha256_mb_export(struct ahash_request *areq, void *out)\r\n{\r\nstruct sha256_hash_ctx *sctx = ahash_request_ctx(areq);\r\nmemcpy(out, sctx, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int sha256_mb_import(struct ahash_request *areq, const void *in)\r\n{\r\nstruct sha256_hash_ctx *sctx = ahash_request_ctx(areq);\r\nmemcpy(sctx, in, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int sha256_mb_async_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct mcryptd_ahash *mcryptd_tfm;\r\nstruct sha256_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct mcryptd_hash_ctx *mctx;\r\nmcryptd_tfm = mcryptd_alloc_ahash("__intel_sha256-mb",\r\nCRYPTO_ALG_INTERNAL,\r\nCRYPTO_ALG_INTERNAL);\r\nif (IS_ERR(mcryptd_tfm))\r\nreturn PTR_ERR(mcryptd_tfm);\r\nmctx = crypto_ahash_ctx(&mcryptd_tfm->base);\r\nmctx->alg_state = &sha256_mb_alg_state;\r\nctx->mcryptd_tfm = mcryptd_tfm;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(&mcryptd_tfm->base));\r\nreturn 0;\r\n}\r\nstatic void sha256_mb_async_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct sha256_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmcryptd_free_ahash(ctx->mcryptd_tfm);\r\n}\r\nstatic int sha256_mb_areq_init_tfm(struct crypto_tfm *tfm)\r\n{\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct ahash_request) +\r\nsizeof(struct sha256_hash_ctx));\r\nreturn 0;\r\n}\r\nstatic void sha256_mb_areq_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct sha256_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmcryptd_free_ahash(ctx->mcryptd_tfm);\r\n}\r\nstatic int sha256_mb_async_init(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_init(mcryptd_req);\r\n}\r\nstatic int sha256_mb_async_update(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_update(mcryptd_req);\r\n}\r\nstatic int sha256_mb_async_finup(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_finup(mcryptd_req);\r\n}\r\nstatic int sha256_mb_async_final(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_final(mcryptd_req);\r\n}\r\nstatic int sha256_mb_async_digest(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_digest(mcryptd_req);\r\n}\r\nstatic int sha256_mb_async_export(struct ahash_request *req, void *out)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_export(mcryptd_req, out);\r\n}\r\nstatic int sha256_mb_async_import(struct ahash_request *req, const void *in)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha256_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nstruct crypto_ahash *child = mcryptd_ahash_child(mcryptd_tfm);\r\nstruct mcryptd_hash_request_ctx *rctx;\r\nstruct ahash_request *areq;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nrctx = ahash_request_ctx(mcryptd_req);\r\nareq = &rctx->areq;\r\nahash_request_set_tfm(areq, child);\r\nahash_request_set_callback(areq, CRYPTO_TFM_REQ_MAY_SLEEP,\r\nrctx->complete, req);\r\nreturn crypto_ahash_import(mcryptd_req, in);\r\n}\r\nstatic unsigned long sha256_mb_flusher(struct mcryptd_alg_cstate *cstate)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx;\r\nunsigned long cur_time;\r\nunsigned long next_flush = 0;\r\nstruct sha256_hash_ctx *sha_ctx;\r\ncur_time = jiffies;\r\nwhile (!list_empty(&cstate->work_list)) {\r\nrctx = list_entry(cstate->work_list.next,\r\nstruct mcryptd_hash_request_ctx, waiter);\r\nif (time_before(cur_time, rctx->tag.expire))\r\nbreak;\r\nkernel_fpu_begin();\r\nsha_ctx = (struct sha256_hash_ctx *)\r\nsha256_ctx_mgr_flush(cstate->mgr);\r\nkernel_fpu_end();\r\nif (!sha_ctx) {\r\npr_err("sha256_mb error: nothing got"\r\n" flushed for non-empty list\n");\r\nbreak;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nsha_finish_walk(&rctx, cstate, true);\r\nsha_complete_job(rctx, cstate, 0);\r\n}\r\nif (!list_empty(&cstate->work_list)) {\r\nrctx = list_entry(cstate->work_list.next,\r\nstruct mcryptd_hash_request_ctx, waiter);\r\nnext_flush = rctx->tag.expire;\r\nmcryptd_arm_flusher(cstate, get_delay(next_flush));\r\n}\r\nreturn next_flush;\r\n}\r\nstatic int __init sha256_mb_mod_init(void)\r\n{\r\nint cpu;\r\nint err;\r\nstruct mcryptd_alg_cstate *cpu_state;\r\nif (!boot_cpu_has(X86_FEATURE_AVX2) ||\r\n!boot_cpu_has(X86_FEATURE_BMI2))\r\nreturn -ENODEV;\r\nsha256_mb_alg_state.alg_cstate = alloc_percpu\r\n(struct mcryptd_alg_cstate);\r\nsha256_job_mgr_init = sha256_mb_mgr_init_avx2;\r\nsha256_job_mgr_submit = sha256_mb_mgr_submit_avx2;\r\nsha256_job_mgr_flush = sha256_mb_mgr_flush_avx2;\r\nsha256_job_mgr_get_comp_job = sha256_mb_mgr_get_comp_job_avx2;\r\nif (!sha256_mb_alg_state.alg_cstate)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha256_mb_alg_state.alg_cstate, cpu);\r\ncpu_state->next_flush = 0;\r\ncpu_state->next_seq_num = 0;\r\ncpu_state->flusher_engaged = false;\r\nINIT_DELAYED_WORK(&cpu_state->flush, mcryptd_flusher);\r\ncpu_state->cpu = cpu;\r\ncpu_state->alg_state = &sha256_mb_alg_state;\r\ncpu_state->mgr = kzalloc(sizeof(struct sha256_ctx_mgr),\r\nGFP_KERNEL);\r\nif (!cpu_state->mgr)\r\ngoto err2;\r\nsha256_ctx_mgr_init(cpu_state->mgr);\r\nINIT_LIST_HEAD(&cpu_state->work_list);\r\nspin_lock_init(&cpu_state->work_lock);\r\n}\r\nsha256_mb_alg_state.flusher = &sha256_mb_flusher;\r\nerr = crypto_register_ahash(&sha256_mb_areq_alg);\r\nif (err)\r\ngoto err2;\r\nerr = crypto_register_ahash(&sha256_mb_async_alg);\r\nif (err)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\ncrypto_unregister_ahash(&sha256_mb_areq_alg);\r\nerr2:\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha256_mb_alg_state.alg_cstate, cpu);\r\nkfree(cpu_state->mgr);\r\n}\r\nfree_percpu(sha256_mb_alg_state.alg_cstate);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit sha256_mb_mod_fini(void)\r\n{\r\nint cpu;\r\nstruct mcryptd_alg_cstate *cpu_state;\r\ncrypto_unregister_ahash(&sha256_mb_async_alg);\r\ncrypto_unregister_ahash(&sha256_mb_areq_alg);\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha256_mb_alg_state.alg_cstate, cpu);\r\nkfree(cpu_state->mgr);\r\n}\r\nfree_percpu(sha256_mb_alg_state.alg_cstate);\r\n}
