static void rwdt_write(struct rwdt_priv *priv, u32 val, unsigned int reg)\r\n{\r\nif (reg == RWTCNT)\r\nval |= 0x5a5a0000;\r\nelse\r\nval |= 0xa5a5a500;\r\nwritel_relaxed(val, priv->base + reg);\r\n}\r\nstatic int rwdt_init_timeout(struct watchdog_device *wdev)\r\n{\r\nstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\r\nrwdt_write(priv, 65536 - wdev->timeout * priv->clks_per_sec, RWTCNT);\r\nreturn 0;\r\n}\r\nstatic int rwdt_start(struct watchdog_device *wdev)\r\n{\r\nstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\r\nclk_prepare_enable(priv->clk);\r\nrwdt_write(priv, priv->cks, RWTCSRA);\r\nrwdt_init_timeout(wdev);\r\nwhile (readb_relaxed(priv->base + RWTCSRA) & RWTCSRA_WRFLG)\r\ncpu_relax();\r\nrwdt_write(priv, priv->cks | RWTCSRA_TME, RWTCSRA);\r\nreturn 0;\r\n}\r\nstatic int rwdt_stop(struct watchdog_device *wdev)\r\n{\r\nstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\r\nrwdt_write(priv, priv->cks, RWTCSRA);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic unsigned int rwdt_get_timeleft(struct watchdog_device *wdev)\r\n{\r\nstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\r\nu16 val = readw_relaxed(priv->base + RWTCNT);\r\nreturn DIV_ROUND_CLOSEST(65536 - val, priv->clks_per_sec);\r\n}\r\nstatic int rwdt_probe(struct platform_device *pdev)\r\n{\r\nstruct rwdt_priv *priv;\r\nstruct resource *res;\r\nunsigned long rate;\r\nunsigned int clks_per_sec;\r\nint ret, i;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\nrate = clk_get_rate(priv->clk);\r\nif (!rate)\r\nreturn -ENOENT;\r\nfor (i = ARRAY_SIZE(clk_divs) - 1; i >= 0; i--) {\r\nclks_per_sec = DIV_ROUND_UP(rate, clk_divs[i]);\r\nif (clks_per_sec) {\r\npriv->clks_per_sec = clks_per_sec;\r\npriv->cks = i;\r\nbreak;\r\n}\r\n}\r\nif (!clks_per_sec) {\r\ndev_err(&pdev->dev, "Can't find suitable clock divider\n");\r\nreturn -ERANGE;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\npriv->wdev.info = &rwdt_ident,\r\npriv->wdev.ops = &rwdt_ops,\r\npriv->wdev.parent = &pdev->dev;\r\npriv->wdev.min_timeout = 1;\r\npriv->wdev.max_timeout = 65536 / clks_per_sec;\r\npriv->wdev.timeout = min(priv->wdev.max_timeout, RWDT_DEFAULT_TIMEOUT);\r\nplatform_set_drvdata(pdev, priv);\r\nwatchdog_set_drvdata(&priv->wdev, priv);\r\nwatchdog_set_nowayout(&priv->wdev, nowayout);\r\nret = watchdog_init_timeout(&priv->wdev, 0, &pdev->dev);\r\nif (ret)\r\ndev_warn(&pdev->dev, "Specified timeout value invalid, using default\n");\r\nret = watchdog_register_device(&priv->wdev);\r\nif (ret < 0) {\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rwdt_remove(struct platform_device *pdev)\r\n{\r\nstruct rwdt_priv *priv = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&priv->wdev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
