static int as3722_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn as_pci->num_pin_groups;\r\n}\r\nstatic const char *as3722_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn as_pci->pin_groups[group].name;\r\n}\r\nstatic int as3722_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group, const unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = as_pci->pin_groups[group].pins;\r\n*num_pins = as_pci->pin_groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic int as3722_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn as_pci->num_functions;\r\n}\r\nstatic const char *as3722_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nreturn as_pci->functions[function].name;\r\n}\r\nstatic int as3722_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = as_pci->functions[function].groups;\r\n*num_groups = as_pci->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int as3722_pinctrl_set(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nint gpio_cntr_reg = AS3722_GPIOn_CONTROL_REG(group);\r\nu8 val = AS3722_GPIO_IOSF_VAL(as_pci->functions[function].mux_option);\r\nint ret;\r\ndev_dbg(as_pci->dev, "%s(): GPIO %u pin to function %u and val %u\n",\r\n__func__, group, function, val);\r\nret = as3722_update_bits(as_pci->as3722, gpio_cntr_reg,\r\nAS3722_GPIO_IOSF_MASK, val);\r\nif (ret < 0) {\r\ndev_err(as_pci->dev, "GPIO%d_CTRL_REG update failed %d\n",\r\ngroup, ret);\r\nreturn ret;\r\n}\r\nas_pci->gpio_control[group].io_function = function;\r\nswitch (val) {\r\ncase AS3722_GPIO_IOSF_SD0_OUT:\r\ncase AS3722_GPIO_IOSF_PWR_GOOD_OUT:\r\ncase AS3722_GPIO_IOSF_Q32K_OUT:\r\ncase AS3722_GPIO_IOSF_PWM_OUT:\r\ncase AS3722_GPIO_IOSF_SD6_LOW_VOLT_LOW:\r\nret = as3722_update_bits(as_pci->as3722, gpio_cntr_reg,\r\nAS3722_GPIO_MODE_MASK, AS3722_GPIO_MODE_OUTPUT_VDDH);\r\nif (ret < 0) {\r\ndev_err(as_pci->dev, "GPIO%d_CTRL update failed %d\n",\r\ngroup, ret);\r\nreturn ret;\r\n}\r\nas_pci->gpio_control[group].mode_prop =\r\nAS3722_GPIO_MODE_OUTPUT_VDDH;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int as3722_pinctrl_gpio_get_mode(unsigned gpio_mode_prop, bool input)\r\n{\r\nif (gpio_mode_prop & AS3722_GPIO_MODE_HIGH_IMPED)\r\nreturn -EINVAL;\r\nif (gpio_mode_prop & AS3722_GPIO_MODE_OPEN_DRAIN) {\r\nif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_UP)\r\nreturn AS3722_GPIO_MODE_IO_OPEN_DRAIN_PULL_UP;\r\nreturn AS3722_GPIO_MODE_IO_OPEN_DRAIN;\r\n}\r\nif (input) {\r\nif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_UP)\r\nreturn AS3722_GPIO_MODE_INPUT_PULL_UP;\r\nelse if (gpio_mode_prop & AS3722_GPIO_MODE_PULL_DOWN)\r\nreturn AS3722_GPIO_MODE_INPUT_PULL_DOWN;\r\nreturn AS3722_GPIO_MODE_INPUT;\r\n}\r\nif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_DOWN)\r\nreturn AS3722_GPIO_MODE_OUTPUT_VDDL;\r\nreturn AS3722_GPIO_MODE_OUTPUT_VDDH;\r\n}\r\nstatic int as3722_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nif (as_pci->gpio_control[offset].io_function)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int as3722_pinctrl_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool input)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nstruct as3722 *as3722 = as_pci->as3722;\r\nint mode;\r\nmode = as3722_pinctrl_gpio_get_mode(\r\nas_pci->gpio_control[offset].mode_prop, input);\r\nif (mode < 0) {\r\ndev_err(as_pci->dev, "%s direction for GPIO %d not supported\n",\r\n(input) ? "Input" : "Output", offset);\r\nreturn mode;\r\n}\r\nreturn as3722_update_bits(as3722, AS3722_GPIOn_CONTROL_REG(offset),\r\nAS3722_GPIO_MODE_MASK, mode);\r\n}\r\nstatic int as3722_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nint arg = 0;\r\nu16 prop;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nprop = AS3722_GPIO_MODE_PULL_UP |\r\nAS3722_GPIO_MODE_PULL_DOWN;\r\nif (!(as_pci->gpio_control[pin].mode_prop & prop))\r\narg = 1;\r\nprop = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nprop = AS3722_GPIO_MODE_PULL_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nprop = AS3722_GPIO_MODE_PULL_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nprop = AS3722_GPIO_MODE_OPEN_DRAIN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\nprop = AS3722_GPIO_MODE_HIGH_IMPED;\r\nbreak;\r\ndefault:\r\ndev_err(as_pci->dev, "Properties not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (as_pci->gpio_control[pin].mode_prop & prop)\r\narg = 1;\r\n*config = pinconf_to_config_packed(param, (u16)arg);\r\nreturn 0;\r\n}\r\nstatic int as3722_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nint mode_prop;\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nmode_prop = as_pci->gpio_control[pin].mode_prop;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nmode_prop &= ~(AS3722_GPIO_MODE_PULL_UP |\r\nAS3722_GPIO_MODE_PULL_DOWN);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nmode_prop |= AS3722_GPIO_MODE_PULL_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nmode_prop |= AS3722_GPIO_MODE_PULL_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\nmode_prop |= AS3722_GPIO_MODE_HIGH_IMPED;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nmode_prop |= AS3722_GPIO_MODE_OPEN_DRAIN;\r\nbreak;\r\ndefault:\r\ndev_err(as_pci->dev, "Properties not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nas_pci->gpio_control[pin].mode_prop = mode_prop;\r\n}\r\nreturn 0;\r\n}\r\nstatic int as3722_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\r\nstruct as3722 *as3722 = as_pci->as3722;\r\nint ret;\r\nu32 reg;\r\nu32 control;\r\nu32 val;\r\nint mode;\r\nint invert_enable;\r\nret = as3722_read(as3722, AS3722_GPIOn_CONTROL_REG(offset), &control);\r\nif (ret < 0) {\r\ndev_err(as_pci->dev,\r\n"GPIO_CONTROL%d_REG read failed: %d\n", offset, ret);\r\nreturn ret;\r\n}\r\ninvert_enable = !!(control & AS3722_GPIO_INV);\r\nmode = control & AS3722_GPIO_MODE_MASK;\r\nswitch (mode) {\r\ncase AS3722_GPIO_MODE_INPUT:\r\ncase AS3722_GPIO_MODE_INPUT_PULL_UP:\r\ncase AS3722_GPIO_MODE_INPUT_PULL_DOWN:\r\ncase AS3722_GPIO_MODE_IO_OPEN_DRAIN:\r\ncase AS3722_GPIO_MODE_IO_OPEN_DRAIN_PULL_UP:\r\nreg = AS3722_GPIO_SIGNAL_IN_REG;\r\nbreak;\r\ncase AS3722_GPIO_MODE_OUTPUT_VDDH:\r\ncase AS3722_GPIO_MODE_OUTPUT_VDDL:\r\nreg = AS3722_GPIO_SIGNAL_OUT_REG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = as3722_read(as3722, reg, &val);\r\nif (ret < 0) {\r\ndev_err(as_pci->dev,\r\n"GPIO_SIGNAL_IN_REG read failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nval = !!(val & AS3722_GPIOn_SIGNAL(offset));\r\nreturn (invert_enable) ? !val : val;\r\n}\r\nstatic void as3722_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\r\nstruct as3722 *as3722 = as_pci->as3722;\r\nint en_invert;\r\nu32 val;\r\nint ret;\r\nret = as3722_read(as3722, AS3722_GPIOn_CONTROL_REG(offset), &val);\r\nif (ret < 0) {\r\ndev_err(as_pci->dev,\r\n"GPIO_CONTROL%d_REG read failed: %d\n", offset, ret);\r\nreturn;\r\n}\r\nen_invert = !!(val & AS3722_GPIO_INV);\r\nif (value)\r\nval = (en_invert) ? 0 : AS3722_GPIOn_SIGNAL(offset);\r\nelse\r\nval = (en_invert) ? AS3722_GPIOn_SIGNAL(offset) : 0;\r\nret = as3722_update_bits(as3722, AS3722_GPIO_SIGNAL_OUT_REG,\r\nAS3722_GPIOn_SIGNAL(offset), val);\r\nif (ret < 0)\r\ndev_err(as_pci->dev,\r\n"GPIO_SIGNAL_OUT_REG update failed: %d\n", ret);\r\n}\r\nstatic int as3722_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int as3722_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nas3722_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic int as3722_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\r\nreturn as3722_irq_get_virq(as_pci->as3722, offset);\r\n}\r\nstatic int as3722_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct as3722_pctrl_info *as_pci;\r\nint ret;\r\nas_pci = devm_kzalloc(&pdev->dev, sizeof(*as_pci), GFP_KERNEL);\r\nif (!as_pci)\r\nreturn -ENOMEM;\r\nas_pci->dev = &pdev->dev;\r\nas_pci->dev->of_node = pdev->dev.parent->of_node;\r\nas_pci->as3722 = dev_get_drvdata(pdev->dev.parent);\r\nplatform_set_drvdata(pdev, as_pci);\r\nas_pci->pins = as3722_pins_desc;\r\nas_pci->num_pins = ARRAY_SIZE(as3722_pins_desc);\r\nas_pci->functions = as3722_pin_function;\r\nas_pci->num_functions = ARRAY_SIZE(as3722_pin_function);\r\nas_pci->pin_groups = as3722_pingroups;\r\nas_pci->num_pin_groups = ARRAY_SIZE(as3722_pingroups);\r\nas3722_pinctrl_desc.name = dev_name(&pdev->dev);\r\nas3722_pinctrl_desc.pins = as3722_pins_desc;\r\nas3722_pinctrl_desc.npins = ARRAY_SIZE(as3722_pins_desc);\r\nas_pci->pctl = devm_pinctrl_register(&pdev->dev, &as3722_pinctrl_desc,\r\nas_pci);\r\nif (IS_ERR(as_pci->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(as_pci->pctl);\r\n}\r\nas_pci->gpio_chip = as3722_gpio_chip;\r\nas_pci->gpio_chip.parent = &pdev->dev;\r\nas_pci->gpio_chip.of_node = pdev->dev.parent->of_node;\r\nret = gpiochip_add_data(&as_pci->gpio_chip, as_pci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't register gpiochip, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&as_pci->gpio_chip, dev_name(&pdev->dev),\r\n0, 0, AS3722_PIN_NUM);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't add pin range, %d\n", ret);\r\ngoto fail_range_add;\r\n}\r\nreturn 0;\r\nfail_range_add:\r\ngpiochip_remove(&as_pci->gpio_chip);\r\nreturn ret;\r\n}\r\nstatic int as3722_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct as3722_pctrl_info *as_pci = platform_get_drvdata(pdev);\r\ngpiochip_remove(&as_pci->gpio_chip);\r\nreturn 0;\r\n}
