static u8 clk_composite_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\n__clk_hw_set_clk(mux_hw, hw);\r\nreturn mux_ops->get_parent(mux_hw);\r\n}\r\nstatic int clk_composite_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\n__clk_hw_set_clk(mux_hw, hw);\r\nreturn mux_ops->set_parent(mux_hw, index);\r\n}\r\nstatic unsigned long clk_composite_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\n__clk_hw_set_clk(rate_hw, hw);\r\nreturn rate_ops->recalc_rate(rate_hw, parent_rate);\r\n}\r\nstatic int clk_composite_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\nstruct clk_hw *parent;\r\nunsigned long parent_rate;\r\nlong tmp_rate, best_rate = 0;\r\nunsigned long rate_diff;\r\nunsigned long best_rate_diff = ULONG_MAX;\r\nlong rate;\r\nint i;\r\nif (rate_hw && rate_ops && rate_ops->determine_rate) {\r\n__clk_hw_set_clk(rate_hw, hw);\r\nreturn rate_ops->determine_rate(rate_hw, req);\r\n} else if (rate_hw && rate_ops && rate_ops->round_rate &&\r\nmux_hw && mux_ops && mux_ops->set_parent) {\r\nreq->best_parent_hw = NULL;\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT) {\r\nparent = clk_hw_get_parent(mux_hw);\r\nreq->best_parent_hw = parent;\r\nreq->best_parent_rate = clk_hw_get_rate(parent);\r\nrate = rate_ops->round_rate(rate_hw, req->rate,\r\n&req->best_parent_rate);\r\nif (rate < 0)\r\nreturn rate;\r\nreq->rate = rate;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < clk_hw_get_num_parents(mux_hw); i++) {\r\nparent = clk_hw_get_parent_by_index(mux_hw, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent);\r\ntmp_rate = rate_ops->round_rate(rate_hw, req->rate,\r\n&parent_rate);\r\nif (tmp_rate < 0)\r\ncontinue;\r\nrate_diff = abs(req->rate - tmp_rate);\r\nif (!rate_diff || !req->best_parent_hw\r\n|| best_rate_diff > rate_diff) {\r\nreq->best_parent_hw = parent;\r\nreq->best_parent_rate = parent_rate;\r\nbest_rate_diff = rate_diff;\r\nbest_rate = tmp_rate;\r\n}\r\nif (!rate_diff)\r\nreturn 0;\r\n}\r\nreq->rate = best_rate;\r\nreturn 0;\r\n} else if (mux_hw && mux_ops && mux_ops->determine_rate) {\r\n__clk_hw_set_clk(mux_hw, hw);\r\nreturn mux_ops->determine_rate(mux_hw, req);\r\n} else {\r\npr_err("clk: clk_composite_determine_rate function called, but no mux or rate callback set!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic long clk_composite_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\n__clk_hw_set_clk(rate_hw, hw);\r\nreturn rate_ops->round_rate(rate_hw, rate, prate);\r\n}\r\nstatic int clk_composite_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\n__clk_hw_set_clk(rate_hw, hw);\r\nreturn rate_ops->set_rate(rate_hw, rate, parent_rate);\r\n}\r\nstatic int clk_composite_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nu8 index)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *rate_ops = composite->rate_ops;\r\nconst struct clk_ops *mux_ops = composite->mux_ops;\r\nstruct clk_hw *rate_hw = composite->rate_hw;\r\nstruct clk_hw *mux_hw = composite->mux_hw;\r\nunsigned long temp_rate;\r\n__clk_hw_set_clk(rate_hw, hw);\r\n__clk_hw_set_clk(mux_hw, hw);\r\ntemp_rate = rate_ops->recalc_rate(rate_hw, parent_rate);\r\nif (temp_rate > rate) {\r\nrate_ops->set_rate(rate_hw, rate, parent_rate);\r\nmux_ops->set_parent(mux_hw, index);\r\n} else {\r\nmux_ops->set_parent(mux_hw, index);\r\nrate_ops->set_rate(rate_hw, rate, parent_rate);\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_composite_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\nreturn gate_ops->is_enabled(gate_hw);\r\n}\r\nstatic int clk_composite_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\nreturn gate_ops->enable(gate_hw);\r\n}\r\nstatic void clk_composite_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_composite *composite = to_clk_composite(hw);\r\nconst struct clk_ops *gate_ops = composite->gate_ops;\r\nstruct clk_hw *gate_hw = composite->gate_hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\ngate_ops->disable(gate_hw);\r\n}\r\nstruct clk_hw *clk_hw_register_composite(struct device *dev, const char *name,\r\nconst char * const *parent_names, int num_parents,\r\nstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\r\nstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\r\nstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\r\nunsigned long flags)\r\n{\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nstruct clk_composite *composite;\r\nstruct clk_ops *clk_composite_ops;\r\nint ret;\r\ncomposite = kzalloc(sizeof(*composite), GFP_KERNEL);\r\nif (!composite)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nhw = &composite->hw;\r\nclk_composite_ops = &composite->ops;\r\nif (mux_hw && mux_ops) {\r\nif (!mux_ops->get_parent) {\r\nhw = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\ncomposite->mux_hw = mux_hw;\r\ncomposite->mux_ops = mux_ops;\r\nclk_composite_ops->get_parent = clk_composite_get_parent;\r\nif (mux_ops->set_parent)\r\nclk_composite_ops->set_parent = clk_composite_set_parent;\r\nif (mux_ops->determine_rate)\r\nclk_composite_ops->determine_rate = clk_composite_determine_rate;\r\n}\r\nif (rate_hw && rate_ops) {\r\nif (!rate_ops->recalc_rate) {\r\nhw = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\nclk_composite_ops->recalc_rate = clk_composite_recalc_rate;\r\nif (rate_ops->determine_rate)\r\nclk_composite_ops->determine_rate =\r\nclk_composite_determine_rate;\r\nelse if (rate_ops->round_rate)\r\nclk_composite_ops->round_rate =\r\nclk_composite_round_rate;\r\nif (rate_ops->set_rate) {\r\nif (rate_ops->determine_rate || rate_ops->round_rate)\r\nclk_composite_ops->set_rate =\r\nclk_composite_set_rate;\r\nelse\r\nWARN(1, "%s: missing round_rate op is required\n",\r\n__func__);\r\n}\r\ncomposite->rate_hw = rate_hw;\r\ncomposite->rate_ops = rate_ops;\r\n}\r\nif (mux_hw && mux_ops && rate_hw && rate_ops) {\r\nif (mux_ops->set_parent && rate_ops->set_rate)\r\nclk_composite_ops->set_rate_and_parent =\r\nclk_composite_set_rate_and_parent;\r\n}\r\nif (gate_hw && gate_ops) {\r\nif (!gate_ops->is_enabled || !gate_ops->enable ||\r\n!gate_ops->disable) {\r\nhw = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\ncomposite->gate_hw = gate_hw;\r\ncomposite->gate_ops = gate_ops;\r\nclk_composite_ops->is_enabled = clk_composite_is_enabled;\r\nclk_composite_ops->enable = clk_composite_enable;\r\nclk_composite_ops->disable = clk_composite_disable;\r\n}\r\ninit.ops = clk_composite_ops;\r\ncomposite->hw.init = &init;\r\nret = clk_hw_register(dev, hw);\r\nif (ret) {\r\nhw = ERR_PTR(ret);\r\ngoto err;\r\n}\r\nif (composite->mux_hw)\r\ncomposite->mux_hw->clk = hw->clk;\r\nif (composite->rate_hw)\r\ncomposite->rate_hw->clk = hw->clk;\r\nif (composite->gate_hw)\r\ncomposite->gate_hw->clk = hw->clk;\r\nreturn hw;\r\nerr:\r\nkfree(composite);\r\nreturn hw;\r\n}\r\nstruct clk *clk_register_composite(struct device *dev, const char *name,\r\nconst char * const *parent_names, int num_parents,\r\nstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\r\nstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\r\nstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\r\nunsigned long flags)\r\n{\r\nstruct clk_hw *hw;\r\nhw = clk_hw_register_composite(dev, name, parent_names, num_parents,\r\nmux_hw, mux_ops, rate_hw, rate_ops, gate_hw, gate_ops,\r\nflags);\r\nif (IS_ERR(hw))\r\nreturn ERR_CAST(hw);\r\nreturn hw->clk;\r\n}\r\nvoid clk_unregister_composite(struct clk *clk)\r\n{\r\nstruct clk_composite *composite;\r\nstruct clk_hw *hw;\r\nhw = __clk_get_hw(clk);\r\nif (!hw)\r\nreturn;\r\ncomposite = to_clk_composite(hw);\r\nclk_unregister(clk);\r\nkfree(composite);\r\n}
