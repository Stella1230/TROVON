static int xenbus_backend_open(struct inode *inode, struct file *filp)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic long xenbus_alloc(domid_t domid)\r\n{\r\nstruct evtchn_alloc_unbound arg;\r\nint err = -EEXIST;\r\nxs_suspend();\r\nif (xenstored_ready)\r\ngoto out_err;\r\ngnttab_grant_foreign_access_ref(GNTTAB_RESERVED_XENSTORE, domid,\r\nvirt_to_gfn(xen_store_interface), 0 );\r\narg.dom = DOMID_SELF;\r\narg.remote_dom = domid;\r\nerr = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound, &arg);\r\nif (err)\r\ngoto out_err;\r\nif (xen_store_evtchn > 0)\r\nxb_deinit_comms();\r\nxen_store_evtchn = arg.port;\r\nxs_resume();\r\nreturn arg.port;\r\nout_err:\r\nxs_suspend_cancel();\r\nreturn err;\r\n}\r\nstatic long xenbus_backend_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long data)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase IOCTL_XENBUS_BACKEND_EVTCHN:\r\nif (xen_store_evtchn > 0)\r\nreturn xen_store_evtchn;\r\nreturn -ENODEV;\r\ncase IOCTL_XENBUS_BACKEND_SETUP:\r\nreturn xenbus_alloc(data);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int xenbus_backend_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nsize_t size = vma->vm_end - vma->vm_start;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ((size > PAGE_SIZE) || (vma->vm_pgoff != 0))\r\nreturn -EINVAL;\r\nif (remap_pfn_range(vma, vma->vm_start,\r\nvirt_to_pfn(xen_store_interface),\r\nsize, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int __init xenbus_backend_init(void)\r\n{\r\nint err;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nerr = misc_register(&xenbus_backend_dev);\r\nif (err)\r\npr_err("Could not register xenbus backend device\n");\r\nreturn err;\r\n}
