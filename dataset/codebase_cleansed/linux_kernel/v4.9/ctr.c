static int crypto_ctr_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err;\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic void crypto_ctr_crypt_final(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ncrypto_cipher_encrypt_one(tfm, keystream, ctrblk);\r\ncrypto_xor(keystream, src, nbytes);\r\nmemcpy(dst, keystream, nbytes);\r\ncrypto_inc(ctrblk, bsize);\r\n}\r\nstatic int crypto_ctr_crypt_segment(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), dst, ctrblk);\r\ncrypto_xor(dst, src, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\ndst += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt_inplace(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), keystream, ctrblk);\r\ncrypto_xor(src, keystream, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_ctr_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nunsigned int bsize = crypto_cipher_blocksize(child);\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, bsize);\r\nwhile (walk.nbytes >= bsize) {\r\nif (walk.src.virt.addr == walk.dst.virt.addr)\r\nnbytes = crypto_ctr_crypt_inplace(&walk, child);\r\nelse\r\nnbytes = crypto_ctr_crypt_segment(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nif (walk.nbytes) {\r\ncrypto_ctr_crypt_final(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_ctr_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_ctr_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_ctr_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_attr_alg(tb[1], CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\nerr = -EINVAL;\r\nif (alg->cra_blocksize < 4)\r\ngoto out_put_alg;\r\nif (alg->cra_blocksize % 4)\r\ngoto out_put_alg;\r\ninst = crypto_alloc_instance("ctr", alg);\r\nif (IS_ERR(inst))\r\ngoto out;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask | (__alignof__(u32) - 1);\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_blkcipher.ivsize = alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_ctr_ctx);\r\ninst->alg.cra_init = crypto_ctr_init_tfm;\r\ninst->alg.cra_exit = crypto_ctr_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_ctr_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.geniv = "chainiv";\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\nout_put_alg:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_ctr_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc3686_setkey(struct crypto_skcipher *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(parent);\r\nstruct crypto_skcipher *child = ctx->child;\r\nint err;\r\nif (keylen < CTR_RFC3686_NONCE_SIZE)\r\nreturn -EINVAL;\r\nmemcpy(ctx->nonce, key + (keylen - CTR_RFC3686_NONCE_SIZE),\r\nCTR_RFC3686_NONCE_SIZE);\r\nkeylen -= CTR_RFC3686_NONCE_SIZE;\r\ncrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_skcipher_setkey(child, key, keylen);\r\ncrypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc3686_crypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_skcipher *child = ctx->child;\r\nunsigned long align = crypto_skcipher_alignmask(tfm);\r\nstruct crypto_rfc3686_req_ctx *rctx =\r\n(void *)PTR_ALIGN((u8 *)skcipher_request_ctx(req), align + 1);\r\nstruct skcipher_request *subreq = &rctx->subreq;\r\nu8 *iv = rctx->iv;\r\nmemcpy(iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);\r\nmemcpy(iv + CTR_RFC3686_NONCE_SIZE, req->iv, CTR_RFC3686_IV_SIZE);\r\n*(__be32 *)(iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =\r\ncpu_to_be32(1);\r\nskcipher_request_set_tfm(subreq, child);\r\nskcipher_request_set_callback(subreq, req->base.flags,\r\nreq->base.complete, req->base.data);\r\nskcipher_request_set_crypt(subreq, req->src, req->dst,\r\nreq->cryptlen, iv);\r\nreturn crypto_skcipher_encrypt(subreq);\r\n}\r\nstatic int crypto_rfc3686_init_tfm(struct crypto_skcipher *tfm)\r\n{\r\nstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\r\nstruct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);\r\nstruct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_skcipher *cipher;\r\nunsigned long align;\r\nunsigned int reqsize;\r\ncipher = crypto_spawn_skcipher2(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nalign = crypto_skcipher_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\nreqsize = align + sizeof(struct crypto_rfc3686_req_ctx) +\r\ncrypto_skcipher_reqsize(cipher);\r\ncrypto_skcipher_set_reqsize(tfm, reqsize);\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc3686_exit_tfm(struct crypto_skcipher *tfm)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);\r\ncrypto_free_skcipher(ctx->child);\r\n}\r\nstatic void crypto_rfc3686_free(struct skcipher_instance *inst)\r\n{\r\nstruct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);\r\ncrypto_drop_skcipher(spawn);\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc3686_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct skcipher_instance *inst;\r\nstruct skcipher_alg *alg;\r\nstruct crypto_skcipher_spawn *spawn;\r\nconst char *cipher_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_SKCIPHER) & algt->mask)\r\nreturn -EINVAL;\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nspawn = skcipher_instance_ctx(inst);\r\ncrypto_set_skcipher_spawn(spawn, skcipher_crypto_instance(inst));\r\nerr = crypto_grab_skcipher2(spawn, cipher_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_free_inst;\r\nalg = crypto_spawn_skcipher_alg(spawn);\r\nerr = -EINVAL;\r\nif (crypto_skcipher_alg_ivsize(alg) != CTR_RFC3686_BLOCK_SIZE)\r\ngoto err_drop_spawn;\r\nif (alg->base.cra_blocksize != 1)\r\ngoto err_drop_spawn;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc3686(%s)", alg->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_spawn;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc3686(%s)", alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_spawn;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.ivsize = CTR_RFC3686_IV_SIZE;\r\ninst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);\r\ninst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) +\r\nCTR_RFC3686_NONCE_SIZE;\r\ninst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) +\r\nCTR_RFC3686_NONCE_SIZE;\r\ninst->alg.setkey = crypto_rfc3686_setkey;\r\ninst->alg.encrypt = crypto_rfc3686_crypt;\r\ninst->alg.decrypt = crypto_rfc3686_crypt;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc3686_ctx);\r\ninst->alg.init = crypto_rfc3686_init_tfm;\r\ninst->alg.exit = crypto_rfc3686_exit_tfm;\r\ninst->free = crypto_rfc3686_free;\r\nerr = skcipher_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_spawn;\r\nout:\r\nreturn err;\r\nerr_drop_spawn:\r\ncrypto_drop_skcipher(spawn);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int __init crypto_ctr_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_ctr_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_rfc3686_tmpl);\r\nif (err)\r\ngoto out_drop_ctr;\r\nout:\r\nreturn err;\r\nout_drop_ctr:\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ctr_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc3686_tmpl);\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\n}
