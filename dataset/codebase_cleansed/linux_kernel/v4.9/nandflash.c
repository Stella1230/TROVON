static void crisv32_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nunsigned long flags;\r\nreg_pio_rw_dout dout;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nlocal_irq_save(flags);\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\ndout = REG_RD(pio, regi_pio, rw_dout);\r\ndout.regf_NCE = (ctrl & NAND_NCE) ? 0 : 1;\r\n#if !MANUAL_ALE_CLE_CONTROL\r\nif (ctrl & NAND_ALE) {\r\nthis->IO_ADDR_W = (void __iomem *)REG_ADDR(pio,\r\nregi_pio, rw_io_access1);\r\n} else if (ctrl & NAND_CLE) {\r\nthis->IO_ADDR_W = (void __iomem *)REG_ADDR(pio,\r\nregi_pio, rw_io_access2);\r\n} else {\r\nthis->IO_ADDR_W = (void __iomem *)REG_ADDR(pio,\r\nregi_pio, rw_io_access0);\r\n}\r\n#else\r\ndout.regf_CLE = (ctrl & NAND_CLE) ? 1 : 0;\r\ndout.regf_ALE = (ctrl & NAND_ALE) ? 1 : 0;\r\n#endif\r\nREG_WR(pio, regi_pio, rw_dout, dout);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, this->IO_ADDR_W);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int crisv32_device_ready(struct mtd_info *mtd)\r\n{\r\nreg_pio_r_din din = REG_RD(pio, regi_pio, r_din);\r\nreturn din.rdy;\r\n}\r\nstruct mtd_info *__init crisv32_nand_flash_probe(void)\r\n{\r\nvoid __iomem *read_cs;\r\nvoid __iomem *write_cs;\r\nstruct mtd_info_wrapper *wrapper;\r\nstruct nand_chip *this;\r\nint err = 0;\r\nreg_pio_rw_man_ctrl man_ctrl = {\r\n.regf_NCE = regk_pio_yes,\r\n#if MANUAL_ALE_CLE_CONTROL\r\n.regf_ALE = regk_pio_yes,\r\n.regf_CLE = regk_pio_yes\r\n#endif\r\n};\r\nreg_pio_rw_oe oe = {\r\n.regf_NCE = regk_pio_yes,\r\n#if MANUAL_ALE_CLE_CONTROL\r\n.regf_ALE = regk_pio_yes,\r\n.regf_CLE = regk_pio_yes\r\n#endif\r\n};\r\nreg_pio_rw_dout dout = { .regf_NCE = 1 };\r\ncrisv32_pinmux_alloc_fixed(pinmux_pio);\r\nREG_WR(pio, regi_pio, rw_man_ctrl, man_ctrl);\r\nREG_WR(pio, regi_pio, rw_dout, dout);\r\nREG_WR(pio, regi_pio, rw_oe, oe);\r\nwrapper = kzalloc(sizeof(struct mtd_info_wrapper), GFP_KERNEL);\r\nif (!wrapper) {\r\nprintk(KERN_ERR "Unable to allocate CRISv32 NAND MTD "\r\n"device structure.\n");\r\nerr = -ENOMEM;\r\nreturn NULL;\r\n}\r\nread_cs = write_cs = (void __iomem *)REG_ADDR(pio, regi_pio,\r\nrw_io_access0);\r\nthis = &wrapper->chip;\r\ncrisv32_mtd = nand_to_mtd(this);\r\nthis->IO_ADDR_R = read_cs;\r\nthis->IO_ADDR_W = write_cs;\r\nthis->cmd_ctrl = crisv32_hwcontrol;\r\nthis->dev_ready = crisv32_device_ready;\r\nthis->chip_delay = 20;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nthis->ecc.algo = NAND_ECC_HAMMING;\r\nif (nand_scan(crisv32_mtd, 1)) {\r\nerr = -ENXIO;\r\ngoto out_mtd;\r\n}\r\nreturn crisv32_mtd;\r\nout_mtd:\r\nkfree(wrapper);\r\nreturn NULL;\r\n}
