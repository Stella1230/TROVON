static void response_callback(struct mbox_client *cl, void *msg)\r\n{\r\nstruct rpi_firmware *fw = container_of(cl, struct rpi_firmware, cl);\r\ncomplete(&fw->c);\r\n}\r\nstatic int\r\nrpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)\r\n{\r\nu32 message = MBOX_MSG(chan, data);\r\nint ret;\r\nWARN_ON(data & 0xf);\r\nmutex_lock(&transaction_lock);\r\nreinit_completion(&fw->c);\r\nret = mbox_send_message(fw->chan, &message);\r\nif (ret >= 0) {\r\nwait_for_completion(&fw->c);\r\nret = 0;\r\n} else {\r\ndev_err(fw->cl.dev, "mbox_send_message returned %d\n", ret);\r\n}\r\nmutex_unlock(&transaction_lock);\r\nreturn ret;\r\n}\r\nint rpi_firmware_property_list(struct rpi_firmware *fw,\r\nvoid *data, size_t tag_size)\r\n{\r\nsize_t size = tag_size + 12;\r\nu32 *buf;\r\ndma_addr_t bus_addr;\r\nint ret;\r\nif (size & 3)\r\nreturn -EINVAL;\r\nbuf = dma_alloc_coherent(fw->cl.dev, PAGE_ALIGN(size), &bus_addr,\r\nGFP_ATOMIC);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nWARN_ON(size >= 1024 * 1024);\r\nbuf[0] = size;\r\nbuf[1] = RPI_FIRMWARE_STATUS_REQUEST;\r\nmemcpy(&buf[2], data, tag_size);\r\nbuf[size / 4 - 1] = RPI_FIRMWARE_PROPERTY_END;\r\nwmb();\r\nret = rpi_firmware_transaction(fw, MBOX_CHAN_PROPERTY, bus_addr);\r\nrmb();\r\nmemcpy(data, &buf[2], tag_size);\r\nif (ret == 0 && buf[1] != RPI_FIRMWARE_STATUS_SUCCESS) {\r\ndev_err(fw->cl.dev, "Request 0x%08x returned status 0x%08x\n",\r\nbuf[2], buf[1]);\r\nret = -EINVAL;\r\n}\r\ndma_free_coherent(fw->cl.dev, PAGE_ALIGN(size), buf, bus_addr);\r\nreturn ret;\r\n}\r\nint rpi_firmware_property(struct rpi_firmware *fw,\r\nu32 tag, void *tag_data, size_t buf_size)\r\n{\r\nu8 data[buf_size + sizeof(struct rpi_firmware_property_tag_header)];\r\nstruct rpi_firmware_property_tag_header *header =\r\n(struct rpi_firmware_property_tag_header *)data;\r\nint ret;\r\nheader->tag = tag;\r\nheader->buf_size = buf_size;\r\nheader->req_resp_size = 0;\r\nmemcpy(data + sizeof(struct rpi_firmware_property_tag_header),\r\ntag_data, buf_size);\r\nret = rpi_firmware_property_list(fw, &data, sizeof(data));\r\nmemcpy(tag_data,\r\ndata + sizeof(struct rpi_firmware_property_tag_header),\r\nbuf_size);\r\nreturn ret;\r\n}\r\nstatic void\r\nrpi_firmware_print_firmware_revision(struct rpi_firmware *fw)\r\n{\r\nu32 packet;\r\nint ret = rpi_firmware_property(fw,\r\nRPI_FIRMWARE_GET_FIRMWARE_REVISION,\r\n&packet, sizeof(packet));\r\nif (ret == 0) {\r\nstruct tm tm;\r\ntime_to_tm(packet, 0, &tm);\r\ndev_info(fw->cl.dev,\r\n"Attached to firmware from %04ld-%02d-%02d %02d:%02d\n",\r\ntm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min);\r\n}\r\n}\r\nstatic int rpi_firmware_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rpi_firmware *fw;\r\nfw = devm_kzalloc(dev, sizeof(*fw), GFP_KERNEL);\r\nif (!fw)\r\nreturn -ENOMEM;\r\nfw->cl.dev = dev;\r\nfw->cl.rx_callback = response_callback;\r\nfw->cl.tx_block = true;\r\nfw->chan = mbox_request_channel(&fw->cl, 0);\r\nif (IS_ERR(fw->chan)) {\r\nint ret = PTR_ERR(fw->chan);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get mbox channel: %d\n", ret);\r\nreturn ret;\r\n}\r\ninit_completion(&fw->c);\r\nplatform_set_drvdata(pdev, fw);\r\nrpi_firmware_print_firmware_revision(fw);\r\nreturn 0;\r\n}\r\nstatic int rpi_firmware_remove(struct platform_device *pdev)\r\n{\r\nstruct rpi_firmware *fw = platform_get_drvdata(pdev);\r\nmbox_free_channel(fw->chan);\r\nreturn 0;\r\n}\r\nstruct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node)\r\n{\r\nstruct platform_device *pdev = of_find_device_by_node(firmware_node);\r\nif (!pdev)\r\nreturn NULL;\r\nreturn platform_get_drvdata(pdev);\r\n}
