efi_status_t check_platform_features(efi_system_table_t *sys_table_arg)\r\n{\r\nu64 tg;\r\nif (IS_ENABLED(CONFIG_ARM64_4K_PAGES))\r\nreturn EFI_SUCCESS;\r\ntg = (read_cpuid(ID_AA64MMFR0_EL1) >> ID_AA64MMFR0_TGRAN_SHIFT) & 0xf;\r\nif (tg != ID_AA64MMFR0_TGRAN_SUPPORTED) {\r\nif (IS_ENABLED(CONFIG_ARM64_64K_PAGES))\r\npr_efi_err(sys_table_arg, "This 64 KB granular kernel is not supported by your CPU\n");\r\nelse\r\npr_efi_err(sys_table_arg, "This 16 KB granular kernel is not supported by your CPU\n");\r\nreturn EFI_UNSUPPORTED;\r\n}\r\nreturn EFI_SUCCESS;\r\n}\r\nefi_status_t handle_kernel_image(efi_system_table_t *sys_table_arg,\r\nunsigned long *image_addr,\r\nunsigned long *image_size,\r\nunsigned long *reserve_addr,\r\nunsigned long *reserve_size,\r\nunsigned long dram_base,\r\nefi_loaded_image_t *image)\r\n{\r\nefi_status_t status;\r\nunsigned long kernel_size, kernel_memsize = 0;\r\nvoid *old_image_addr = (void *)*image_addr;\r\nunsigned long preferred_offset;\r\nu64 phys_seed = 0;\r\nif (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {\r\nif (!__nokaslr) {\r\nstatus = efi_get_random_bytes(sys_table_arg,\r\nsizeof(phys_seed),\r\n(u8 *)&phys_seed);\r\nif (status == EFI_NOT_FOUND) {\r\npr_efi(sys_table_arg, "EFI_RNG_PROTOCOL unavailable, no randomness supplied\n");\r\n} else if (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "efi_get_random_bytes() failed\n");\r\nreturn status;\r\n}\r\n} else {\r\npr_efi(sys_table_arg, "KASLR disabled on kernel command line\n");\r\n}\r\n}\r\npreferred_offset = round_down(dram_base, MIN_KIMG_ALIGN) + TEXT_OFFSET;\r\nif (preferred_offset < dram_base)\r\npreferred_offset += MIN_KIMG_ALIGN;\r\nkernel_size = _edata - _text;\r\nkernel_memsize = kernel_size + (_end - _edata);\r\nif (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && phys_seed != 0) {\r\nu32 mask = (MIN_KIMG_ALIGN - 1) & ~(SZ_64K - 1);\r\nu32 offset = !IS_ENABLED(CONFIG_DEBUG_ALIGN_RODATA) ?\r\n(phys_seed >> 32) & mask : TEXT_OFFSET;\r\n*reserve_size = kernel_memsize + offset;\r\nstatus = efi_random_alloc(sys_table_arg, *reserve_size,\r\nMIN_KIMG_ALIGN, reserve_addr,\r\n(u32)phys_seed);\r\n*image_addr = *reserve_addr + offset;\r\n} else {\r\nif (*image_addr == preferred_offset)\r\nreturn EFI_SUCCESS;\r\n*image_addr = *reserve_addr = preferred_offset;\r\n*reserve_size = round_up(kernel_memsize, EFI_ALLOC_ALIGN);\r\nstatus = efi_call_early(allocate_pages, EFI_ALLOCATE_ADDRESS,\r\nEFI_LOADER_DATA,\r\n*reserve_size / EFI_PAGE_SIZE,\r\n(efi_physical_addr_t *)reserve_addr);\r\n}\r\nif (status != EFI_SUCCESS) {\r\n*reserve_size = kernel_memsize + TEXT_OFFSET;\r\nstatus = efi_low_alloc(sys_table_arg, *reserve_size,\r\nMIN_KIMG_ALIGN, reserve_addr);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table_arg, "Failed to relocate kernel\n");\r\n*reserve_size = 0;\r\nreturn status;\r\n}\r\n*image_addr = *reserve_addr + TEXT_OFFSET;\r\n}\r\nmemcpy((void *)*image_addr, old_image_addr, kernel_size);\r\nreturn EFI_SUCCESS;\r\n}
