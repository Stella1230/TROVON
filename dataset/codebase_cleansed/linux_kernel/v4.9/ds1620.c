static inline void netwinder_ds1620_set_clk(int clk)\r\n{\r\nnw_gpio_modify_op(GPIO_DSCLK, clk ? GPIO_DSCLK : 0);\r\n}\r\nstatic inline void netwinder_ds1620_set_data(int dat)\r\n{\r\nnw_gpio_modify_op(GPIO_DATA, dat ? GPIO_DATA : 0);\r\n}\r\nstatic inline int netwinder_ds1620_get_data(void)\r\n{\r\nreturn nw_gpio_read() & GPIO_DATA;\r\n}\r\nstatic inline void netwinder_ds1620_set_data_dir(int dir)\r\n{\r\nnw_gpio_modify_io(GPIO_DATA, dir ? GPIO_DATA : 0);\r\n}\r\nstatic inline void netwinder_ds1620_reset(void)\r\n{\r\nnw_cpld_modify(CPLD_DS_ENABLE, 0);\r\nnw_cpld_modify(CPLD_DS_ENABLE, CPLD_DS_ENABLE);\r\n}\r\nstatic inline void netwinder_lock(unsigned long *flags)\r\n{\r\nraw_spin_lock_irqsave(&nw_gpio_lock, *flags);\r\n}\r\nstatic inline void netwinder_unlock(unsigned long *flags)\r\n{\r\nraw_spin_unlock_irqrestore(&nw_gpio_lock, *flags);\r\n}\r\nstatic inline void netwinder_set_fan(int i)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_gpio_modify_op(GPIO_FAN, i ? GPIO_FAN : 0);\r\nraw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\r\n}\r\nstatic inline int netwinder_get_fan(void)\r\n{\r\nif ((system_rev & 0xf000) == 0x4000)\r\nreturn FAN_ALWAYS_ON;\r\nreturn (nw_gpio_read() & GPIO_FAN) ? FAN_ON : FAN_OFF;\r\n}\r\nstatic void ds1620_send_bits(int nr, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < nr; i++) {\r\nnetwinder_ds1620_set_data(value & 1);\r\nnetwinder_ds1620_set_clk(0);\r\nudelay(1);\r\nnetwinder_ds1620_set_clk(1);\r\nudelay(1);\r\nvalue >>= 1;\r\n}\r\n}\r\nstatic unsigned int ds1620_recv_bits(int nr)\r\n{\r\nunsigned int value = 0, mask = 1;\r\nint i;\r\nnetwinder_ds1620_set_data(0);\r\nfor (i = 0; i < nr; i++) {\r\nnetwinder_ds1620_set_clk(0);\r\nudelay(1);\r\nif (netwinder_ds1620_get_data())\r\nvalue |= mask;\r\nmask <<= 1;\r\nnetwinder_ds1620_set_clk(1);\r\nudelay(1);\r\n}\r\nreturn value;\r\n}\r\nstatic void ds1620_out(int cmd, int bits, int value)\r\n{\r\nunsigned long flags;\r\nnetwinder_lock(&flags);\r\nnetwinder_ds1620_set_clk(1);\r\nnetwinder_ds1620_set_data_dir(0);\r\nnetwinder_ds1620_reset();\r\nudelay(1);\r\nds1620_send_bits(8, cmd);\r\nif (bits)\r\nds1620_send_bits(bits, value);\r\nudelay(1);\r\nnetwinder_ds1620_reset();\r\nnetwinder_unlock(&flags);\r\nmsleep(20);\r\n}\r\nstatic unsigned int ds1620_in(int cmd, int bits)\r\n{\r\nunsigned long flags;\r\nunsigned int value;\r\nnetwinder_lock(&flags);\r\nnetwinder_ds1620_set_clk(1);\r\nnetwinder_ds1620_set_data_dir(0);\r\nnetwinder_ds1620_reset();\r\nudelay(1);\r\nds1620_send_bits(8, cmd);\r\nnetwinder_ds1620_set_data_dir(1);\r\nvalue = ds1620_recv_bits(bits);\r\nnetwinder_ds1620_reset();\r\nnetwinder_unlock(&flags);\r\nreturn value;\r\n}\r\nstatic int cvt_9_to_int(unsigned int val)\r\n{\r\nif (val & 0x100)\r\nval |= 0xfffffe00;\r\nreturn val;\r\n}\r\nstatic void ds1620_write_state(struct therm *therm)\r\n{\r\nds1620_out(THERM_WRITE_CONFIG, 8, CFG_CPU);\r\nds1620_out(THERM_WRITE_TL, 9, therm->lo);\r\nds1620_out(THERM_WRITE_TH, 9, therm->hi);\r\nds1620_out(THERM_START_CONVERT, 0, 0);\r\n}\r\nstatic void ds1620_read_state(struct therm *therm)\r\n{\r\ntherm->lo = cvt_9_to_int(ds1620_in(THERM_READ_TL, 9));\r\ntherm->hi = cvt_9_to_int(ds1620_in(THERM_READ_TH, 9));\r\n}\r\nstatic int ds1620_open(struct inode *inode, struct file *file)\r\n{\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t\r\nds1620_read(struct file *file, char __user *buf, size_t count, loff_t *ptr)\r\n{\r\nsigned int cur_temp;\r\nsigned char cur_temp_degF;\r\ncur_temp = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9)) >> 1;\r\ncur_temp_degF = (cur_temp * 9) / 5 + 32;\r\nif (copy_to_user(buf, &cur_temp_degF, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int\r\nds1620_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct therm therm;\r\nunion {\r\nstruct therm __user *therm;\r\nint __user *i;\r\n} uarg;\r\nint i;\r\nuarg.i = (int __user *)arg;\r\nswitch(cmd) {\r\ncase CMD_SET_THERMOSTATE:\r\ncase CMD_SET_THERMOSTATE2:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (cmd == CMD_SET_THERMOSTATE) {\r\nif (get_user(therm.hi, uarg.i))\r\nreturn -EFAULT;\r\ntherm.lo = therm.hi - 3;\r\n} else {\r\nif (copy_from_user(&therm, uarg.therm, sizeof(therm)))\r\nreturn -EFAULT;\r\n}\r\ntherm.lo <<= 1;\r\ntherm.hi <<= 1;\r\nds1620_write_state(&therm);\r\nbreak;\r\ncase CMD_GET_THERMOSTATE:\r\ncase CMD_GET_THERMOSTATE2:\r\nds1620_read_state(&therm);\r\ntherm.lo >>= 1;\r\ntherm.hi >>= 1;\r\nif (cmd == CMD_GET_THERMOSTATE) {\r\nif (put_user(therm.hi, uarg.i))\r\nreturn -EFAULT;\r\n} else {\r\nif (copy_to_user(uarg.therm, &therm, sizeof(therm)))\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase CMD_GET_TEMPERATURE:\r\ncase CMD_GET_TEMPERATURE2:\r\ni = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\r\nif (cmd == CMD_GET_TEMPERATURE)\r\ni >>= 1;\r\nreturn put_user(i, uarg.i) ? -EFAULT : 0;\r\ncase CMD_GET_STATUS:\r\ni = ds1620_in(THERM_READ_CONFIG, 8) & 0xe3;\r\nreturn put_user(i, uarg.i) ? -EFAULT : 0;\r\ncase CMD_GET_FAN:\r\ni = netwinder_get_fan();\r\nreturn put_user(i, uarg.i) ? -EFAULT : 0;\r\ncase CMD_SET_FAN:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(i, uarg.i))\r\nreturn -EFAULT;\r\nnetwinder_set_fan(i);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\nds1620_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ds1620_mutex);\r\nret = ds1620_ioctl(file, cmd, arg);\r\nmutex_unlock(&ds1620_mutex);\r\nreturn ret;\r\n}\r\nstatic int ds1620_proc_therm_show(struct seq_file *m, void *v)\r\n{\r\nstruct therm th;\r\nint temp;\r\nds1620_read_state(&th);\r\ntemp = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\r\nseq_printf(m, "Thermostat: HI %i.%i, LOW %i.%i; temperature: %i.%i C, fan %s\n",\r\nth.hi >> 1, th.hi & 1 ? 5 : 0,\r\nth.lo >> 1, th.lo & 1 ? 5 : 0,\r\ntemp >> 1, temp & 1 ? 5 : 0,\r\nfan_state[netwinder_get_fan()]);\r\nreturn 0;\r\n}\r\nstatic int ds1620_proc_therm_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ds1620_proc_therm_show, NULL);\r\n}\r\nstatic int __init ds1620_init(void)\r\n{\r\nint ret;\r\nstruct therm th, th_start;\r\nif (!machine_is_netwinder())\r\nreturn -ENODEV;\r\nds1620_out(THERM_RESET, 0, 0);\r\nds1620_out(THERM_WRITE_CONFIG, 8, CFG_CPU);\r\nds1620_out(THERM_START_CONVERT, 0, 0);\r\nds1620_read_state(&th);\r\nth_start.lo = 0;\r\nth_start.hi = 1;\r\nds1620_write_state(&th_start);\r\nmsleep(2000);\r\nds1620_write_state(&th);\r\nret = misc_register(&ds1620_miscdev);\r\nif (ret < 0)\r\nreturn ret;\r\n#ifdef THERM_USE_PROC\r\nif (!proc_create("therm", 0, NULL, &ds1620_proc_therm_fops))\r\nprintk(KERN_ERR "therm: unable to register /proc/therm\n");\r\n#endif\r\nds1620_read_state(&th);\r\nret = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\r\nprintk(KERN_INFO "Thermostat: high %i.%i, low %i.%i, "\r\n"current %i.%i C, fan %s.\n",\r\nth.hi >> 1, th.hi & 1 ? 5 : 0,\r\nth.lo >> 1, th.lo & 1 ? 5 : 0,\r\nret >> 1, ret & 1 ? 5 : 0,\r\nfan_state[netwinder_get_fan()]);\r\nreturn 0;\r\n}\r\nstatic void __exit ds1620_exit(void)\r\n{\r\n#ifdef THERM_USE_PROC\r\nremove_proc_entry("therm", NULL);\r\n#endif\r\nmisc_deregister(&ds1620_miscdev);\r\n}
