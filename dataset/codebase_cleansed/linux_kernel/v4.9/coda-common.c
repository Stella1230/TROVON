void coda_write(struct coda_dev *dev, u32 data, u32 reg)\r\n{\r\nv4l2_dbg(2, coda_debug, &dev->v4l2_dev,\r\n"%s: data=0x%x, reg=0x%x\n", __func__, data, reg);\r\nwritel(data, dev->regs_base + reg);\r\n}\r\nunsigned int coda_read(struct coda_dev *dev, u32 reg)\r\n{\r\nu32 data;\r\ndata = readl(dev->regs_base + reg);\r\nv4l2_dbg(2, coda_debug, &dev->v4l2_dev,\r\n"%s: data=0x%x, reg=0x%x\n", __func__, data, reg);\r\nreturn data;\r\n}\r\nvoid coda_write_base(struct coda_ctx *ctx, struct coda_q_data *q_data,\r\nstruct vb2_v4l2_buffer *buf, unsigned int reg_y)\r\n{\r\nu32 base_y = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);\r\nu32 base_cb, base_cr;\r\nswitch (q_data->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_YUV420:\r\ndefault:\r\nbase_cb = base_y + q_data->bytesperline * q_data->height;\r\nbase_cr = base_cb + q_data->bytesperline * q_data->height / 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_YVU420:\r\nbase_cr = base_y + q_data->bytesperline * q_data->height;\r\nbase_cb = base_cr + q_data->bytesperline * q_data->height / 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nbase_cb = base_y + q_data->bytesperline * q_data->height;\r\nbase_cr = base_cb + q_data->bytesperline * q_data->height / 2;\r\n}\r\ncoda_write(ctx->dev, base_y, reg_y);\r\ncoda_write(ctx->dev, base_cb, reg_y + 4);\r\ncoda_write(ctx->dev, base_cr, reg_y + 8);\r\n}\r\nstatic u32 coda_format_normalize_yuv(u32 fourcc)\r\n{\r\nswitch (fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YUV422P:\r\nreturn V4L2_PIX_FMT_YUV420;\r\ndefault:\r\nreturn fourcc;\r\n}\r\n}\r\nstatic const struct coda_codec *coda_find_codec(struct coda_dev *dev,\r\nint src_fourcc, int dst_fourcc)\r\n{\r\nconst struct coda_codec *codecs = dev->devtype->codecs;\r\nint num_codecs = dev->devtype->num_codecs;\r\nint k;\r\nsrc_fourcc = coda_format_normalize_yuv(src_fourcc);\r\ndst_fourcc = coda_format_normalize_yuv(dst_fourcc);\r\nif (src_fourcc == dst_fourcc)\r\nreturn NULL;\r\nfor (k = 0; k < num_codecs; k++) {\r\nif (codecs[k].src_fourcc == src_fourcc &&\r\ncodecs[k].dst_fourcc == dst_fourcc)\r\nbreak;\r\n}\r\nif (k == num_codecs)\r\nreturn NULL;\r\nreturn &codecs[k];\r\n}\r\nstatic void coda_get_max_dimensions(struct coda_dev *dev,\r\nconst struct coda_codec *codec,\r\nint *max_w, int *max_h)\r\n{\r\nconst struct coda_codec *codecs = dev->devtype->codecs;\r\nint num_codecs = dev->devtype->num_codecs;\r\nunsigned int w, h;\r\nint k;\r\nif (codec) {\r\nw = codec->max_w;\r\nh = codec->max_h;\r\n} else {\r\nfor (k = 0, w = 0, h = 0; k < num_codecs; k++) {\r\nw = max(w, codecs[k].max_w);\r\nh = max(h, codecs[k].max_h);\r\n}\r\n}\r\nif (max_w)\r\n*max_w = w;\r\nif (max_h)\r\n*max_h = h;\r\n}\r\nstatic const struct coda_video_device *to_coda_video_device(struct video_device\r\n*vdev)\r\n{\r\nstruct coda_dev *dev = video_get_drvdata(vdev);\r\nunsigned int i = vdev - dev->vfd;\r\nif (i >= dev->devtype->num_vdevs)\r\nreturn NULL;\r\nreturn dev->devtype->vdevs[i];\r\n}\r\nconst char *coda_product_name(int product)\r\n{\r\nstatic char buf[9];\r\nswitch (product) {\r\ncase CODA_DX6:\r\nreturn "CodaDx6";\r\ncase CODA_7541:\r\nreturn "CODA7541";\r\ncase CODA_960:\r\nreturn "CODA960";\r\ndefault:\r\nsnprintf(buf, sizeof(buf), "(0x%04x)", product);\r\nreturn buf;\r\n}\r\n}\r\nstatic int coda_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstrlcpy(cap->driver, CODA_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, coda_product_name(ctx->dev->devtype->product),\r\nsizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform:" CODA_NAME, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int coda_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nconst struct coda_video_device *cvd = to_coda_video_device(vdev);\r\nconst u32 *formats;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nformats = cvd->src_formats;\r\nelse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nformats = cvd->dst_formats;\r\nelse\r\nreturn -EINVAL;\r\nif (f->index >= CODA_MAX_FORMATS || formats[f->index] == 0)\r\nreturn -EINVAL;\r\nf->pixelformat = formats[f->index];\r\nreturn 0;\r\n}\r\nstatic int coda_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_q_data *q_data;\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nq_data = get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.pixelformat = q_data->fourcc;\r\nf->fmt.pix.width = q_data->width;\r\nf->fmt.pix.height = q_data->height;\r\nf->fmt.pix.bytesperline = q_data->bytesperline;\r\nf->fmt.pix.sizeimage = q_data->sizeimage;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_JPEG)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\nelse\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nreturn 0;\r\n}\r\nstatic int coda_try_pixelformat(struct coda_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct coda_q_data *q_data;\r\nconst u32 *formats;\r\nint i;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nformats = ctx->cvd->src_formats;\r\nelse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nformats = ctx->cvd->dst_formats;\r\nelse\r\nreturn -EINVAL;\r\nfor (i = 0; i < CODA_MAX_FORMATS; i++) {\r\nif (formats[i] == f->fmt.pix.pixelformat) {\r\nf->fmt.pix.pixelformat = formats[i];\r\nreturn 0;\r\n}\r\n}\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix.pixelformat = q_data->fourcc;\r\nreturn 0;\r\n}\r\nstatic unsigned int coda_estimate_sizeimage(struct coda_ctx *ctx, u32 sizeimage,\r\nu32 width, u32 height)\r\n{\r\nreturn round_up(clamp(sizeimage, width * height / 8,\r\nwidth * height * 2), PAGE_SIZE);\r\n}\r\nstatic int coda_try_fmt(struct coda_ctx *ctx, const struct coda_codec *codec,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nunsigned int max_w, max_h;\r\nenum v4l2_field field;\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_NONE;\r\nelse if (V4L2_FIELD_NONE != field)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = field;\r\ncoda_get_max_dimensions(dev, codec, &max_w, &max_h);\r\nv4l_bound_align_image(&f->fmt.pix.width, MIN_W, max_w, W_ALIGN,\r\n&f->fmt.pix.height, MIN_H, max_h, H_ALIGN,\r\nS_ALIGN);\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height * 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\ncase V4L2_PIX_FMT_H264:\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncase V4L2_PIX_FMT_MPEG2:\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = coda_estimate_sizeimage(ctx,\r\nf->fmt.pix.sizeimage,\r\nf->fmt.pix.width,\r\nf->fmt.pix.height);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nconst struct coda_q_data *q_data_src;\r\nconst struct coda_codec *codec;\r\nstruct vb2_queue *src_vq;\r\nint ret;\r\nret = coda_try_pixelformat(ctx, f);\r\nif (ret < 0)\r\nreturn ret;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nsrc_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nif (vb2_is_streaming(src_vq)) {\r\nf->fmt.pix.width = q_data_src->width;\r\nf->fmt.pix.height = q_data_src->height;\r\n}\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\ncodec = coda_find_codec(ctx->dev, q_data_src->fourcc,\r\nf->fmt.pix.pixelformat);\r\nif (!codec)\r\nreturn -EINVAL;\r\nret = coda_try_fmt(ctx, codec, f);\r\nif (ret < 0)\r\nreturn ret;\r\nif (codec && codec->src_fourcc == V4L2_PIX_FMT_H264) {\r\nf->fmt.pix.width = f->fmt.pix.width;\r\nf->fmt.pix.height = round_up(f->fmt.pix.height, 16);\r\nf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height * 3 / 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct coda_dev *dev = ctx->dev;\r\nconst struct coda_q_data *q_data_dst;\r\nconst struct coda_codec *codec;\r\nint ret;\r\nret = coda_try_pixelformat(ctx, f);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (f->fmt.pix.colorspace) {\r\ncase V4L2_COLORSPACE_REC709:\r\ncase V4L2_COLORSPACE_JPEG:\r\nbreak;\r\ndefault:\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_JPEG)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\nelse\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\n}\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\ncodec = coda_find_codec(dev, f->fmt.pix.pixelformat, q_data_dst->fourcc);\r\nreturn coda_try_fmt(ctx, codec, f);\r\n}\r\nstatic int coda_s_fmt(struct coda_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct coda_q_data *q_data;\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nq_data->fourcc = f->fmt.pix.pixelformat;\r\nq_data->width = f->fmt.pix.width;\r\nq_data->height = f->fmt.pix.height;\r\nq_data->bytesperline = f->fmt.pix.bytesperline;\r\nq_data->sizeimage = f->fmt.pix.sizeimage;\r\nq_data->rect.left = 0;\r\nq_data->rect.top = 0;\r\nq_data->rect.width = f->fmt.pix.width;\r\nq_data->rect.height = f->fmt.pix.height;\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nctx->tiled_map_type = GDI_TILED_FRAME_MB_RASTER_MAP;\r\nif (!disable_tiling)\r\nbreak;\r\n}\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nctx->tiled_map_type = GDI_LINEAR_FRAME_MAP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %d\n",\r\nf->type, q_data->width, q_data->height, q_data->fourcc);\r\nreturn 0;\r\n}\r\nstatic int coda_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nret = coda_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn coda_s_fmt(ctx, f);\r\n}\r\nstatic int coda_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_format f_cap;\r\nint ret;\r\nret = coda_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nret = coda_s_fmt(ctx, f);\r\nif (ret)\r\nreturn ret;\r\nctx->colorspace = f->fmt.pix.colorspace;\r\nmemset(&f_cap, 0, sizeof(f_cap));\r\nf_cap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncoda_g_fmt(file, priv, &f_cap);\r\nf_cap.fmt.pix.width = f->fmt.pix.width;\r\nf_cap.fmt.pix.height = f->fmt.pix.height;\r\nret = coda_try_fmt_vid_cap(file, priv, &f_cap);\r\nif (ret)\r\nreturn ret;\r\nreturn coda_s_fmt(ctx, &f_cap);\r\n}\r\nstatic int coda_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nret = v4l2_m2m_reqbufs(file, ctx->fh.m2m_ctx, rb);\r\nif (ret)\r\nreturn ret;\r\nif (rb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT && ctx->ops->reqbufs)\r\nreturn ctx->ops->reqbufs(ctx, rb);\r\nreturn 0;\r\n}\r\nstatic int coda_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_qbuf(file, ctx->fh.m2m_ctx, buf);\r\n}\r\nstatic bool coda_buf_is_end_of_stream(struct coda_ctx *ctx,\r\nstruct vb2_v4l2_buffer *buf)\r\n{\r\nstruct vb2_queue *src_vq;\r\nsrc_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nreturn ((ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) &&\r\n(buf->sequence == (ctx->qsequence - 1)));\r\n}\r\nvoid coda_m2m_buf_done(struct coda_ctx *ctx, struct vb2_v4l2_buffer *buf,\r\nenum vb2_buffer_state state)\r\n{\r\nconst struct v4l2_event eos_event = {\r\n.type = V4L2_EVENT_EOS\r\n};\r\nif (coda_buf_is_end_of_stream(ctx, buf)) {\r\nbuf->flags |= V4L2_BUF_FLAG_LAST;\r\nv4l2_event_queue_fh(&ctx->fh, &eos_event);\r\n}\r\nv4l2_m2m_buf_done(buf, state);\r\n}\r\nstatic int coda_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(fh);\r\nstruct coda_q_data *q_data;\r\nstruct v4l2_rect r, *rsel;\r\nq_data = get_q_data(ctx, s->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nr.left = 0;\r\nr.top = 0;\r\nr.width = q_data->width;\r\nr.height = q_data->height;\r\nrsel = &q_data->rect;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nrsel = &r;\r\ncase V4L2_SEL_TGT_CROP:\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\nrsel = &r;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns->r = *rsel;\r\nreturn 0;\r\n}\r\nstatic int coda_try_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *dc)\r\n{\r\nif (dc->cmd != V4L2_DEC_CMD_STOP)\r\nreturn -EINVAL;\r\nif (dc->flags & V4L2_DEC_CMD_STOP_TO_BLACK)\r\nreturn -EINVAL;\r\nif (!(dc->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) && (dc->stop.pts != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int coda_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *dc)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(fh);\r\nint ret;\r\nret = coda_try_decoder_cmd(file, fh, dc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ctx->inst_type != CODA_INST_DECODER)\r\nreturn 0;\r\ncoda_bit_stream_end_flag(ctx);\r\nctx->hold = false;\r\nv4l2_m2m_try_schedule(ctx->fh.m2m_ctx);\r\nreturn 0;\r\n}\r\nstatic int coda_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_fract *tpf;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\na->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\ntpf = &a->parm.output.timeperframe;\r\ntpf->denominator = ctx->params.framerate & CODA_FRATE_RES_MASK;\r\ntpf->numerator = 1 + (ctx->params.framerate >>\r\nCODA_FRATE_DIV_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void coda_approximate_timeperframe(struct v4l2_fract *timeperframe)\r\n{\r\nstruct v4l2_fract s = *timeperframe;\r\nstruct v4l2_fract f0;\r\nstruct v4l2_fract f1 = { 1, 0 };\r\nstruct v4l2_fract f2 = { 0, 1 };\r\nunsigned int i, div, s_denominator;\r\nif (s.numerator == 0 || s.denominator / s.numerator > 65535) {\r\ntimeperframe->numerator = 1;\r\ntimeperframe->denominator = 65535;\r\nreturn;\r\n}\r\nif (s.denominator == 0 || s.numerator / s.denominator > 65536) {\r\ntimeperframe->numerator = 1;\r\ntimeperframe->denominator = 0;\r\nreturn;\r\n}\r\ndiv = gcd(s.numerator, s.denominator);\r\nif (div > 1) {\r\ns.numerator /= div;\r\ns.denominator /= div;\r\n}\r\nif (s.numerator <= 65536 && s.denominator < 65536) {\r\n*timeperframe = s;\r\nreturn;\r\n}\r\nwhile (f2.numerator <= 65536 && f2.denominator < 65536) {\r\nf0 = f1;\r\nf1 = f2;\r\nif (s.numerator == 0)\r\nbreak;\r\ni = s.denominator / s.numerator;\r\nf2.numerator = f0.numerator + i * f1.numerator;\r\nf2.denominator = f0.denominator + i * f2.denominator;\r\ns_denominator = s.numerator;\r\ns.numerator = s.denominator % s.numerator;\r\ns.denominator = s_denominator;\r\n}\r\n*timeperframe = f1;\r\n}\r\nstatic uint32_t coda_timeperframe_to_frate(struct v4l2_fract *timeperframe)\r\n{\r\nreturn ((timeperframe->numerator - 1) << CODA_FRATE_DIV_OFFSET) |\r\ntimeperframe->denominator;\r\n}\r\nstatic int coda_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_fract *tpf;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\ntpf = &a->parm.output.timeperframe;\r\ncoda_approximate_timeperframe(tpf);\r\nctx->params.framerate = coda_timeperframe_to_frate(tpf);\r\nreturn 0;\r\n}\r\nstatic int coda_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 0, NULL);\r\ndefault:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\n}\r\nstatic void coda_device_run(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *dev = ctx->dev;\r\nqueue_work(dev->workqueue, &ctx->pic_run_work);\r\n}\r\nstatic void coda_pic_run_work(struct work_struct *work)\r\n{\r\nstruct coda_ctx *ctx = container_of(work, struct coda_ctx, pic_run_work);\r\nstruct coda_dev *dev = ctx->dev;\r\nint ret;\r\nmutex_lock(&ctx->buffer_mutex);\r\nmutex_lock(&dev->coda_mutex);\r\nret = ctx->ops->prepare_run(ctx);\r\nif (ret < 0 && ctx->inst_type == CODA_INST_DECODER) {\r\nmutex_unlock(&dev->coda_mutex);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nreturn;\r\n}\r\nif (!wait_for_completion_timeout(&ctx->completion,\r\nmsecs_to_jiffies(1000))) {\r\ndev_err(&dev->plat_dev->dev, "CODA PIC_RUN timeout\n");\r\nctx->hold = true;\r\ncoda_hw_reset(ctx);\r\n} else if (!ctx->aborting) {\r\nctx->ops->finish_run(ctx);\r\n}\r\nif ((ctx->aborting || (!ctx->streamon_cap && !ctx->streamon_out)) &&\r\nctx->ops->seq_end_work)\r\nqueue_work(dev->workqueue, &ctx->seq_end_work);\r\nmutex_unlock(&dev->coda_mutex);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\r\n}\r\nstatic int coda_job_ready(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nint src_bufs = v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx);\r\nif (!src_bufs && ctx->inst_type != CODA_INST_DECODER) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: not enough video buffers.\n");\r\nreturn 0;\r\n}\r\nif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: not enough video capture buffers.\n");\r\nreturn 0;\r\n}\r\nif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit) {\r\nbool stream_end = ctx->bit_stream_param &\r\nCODA_BIT_STREAM_END_FLAG;\r\nint num_metas = ctx->num_metas;\r\nif (ctx->hold && !src_bufs) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"%d: not ready: on hold for more buffers.\n",\r\nctx->idx);\r\nreturn 0;\r\n}\r\nif (!stream_end && (num_metas + src_bufs) < 2) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"%d: not ready: need 2 buffers available (%d, %d)\n",\r\nctx->idx, num_metas, src_bufs);\r\nreturn 0;\r\n}\r\nif (!src_bufs && !stream_end &&\r\n(coda_get_bitstream_payload(ctx) < 512)) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"%d: not ready: not enough bitstream data (%d).\n",\r\nctx->idx, coda_get_bitstream_payload(ctx));\r\nreturn 0;\r\n}\r\n}\r\nif (ctx->aborting) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: aborting\n");\r\nreturn 0;\r\n}\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"job ready\n");\r\nreturn 1;\r\n}\r\nstatic void coda_job_abort(void *priv)\r\n{\r\nstruct coda_ctx *ctx = priv;\r\nctx->aborting = 1;\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Aborting task\n");\r\n}\r\nstatic void coda_lock(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *pcdev = ctx->dev;\r\nmutex_lock(&pcdev->dev_mutex);\r\n}\r\nstatic void coda_unlock(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *pcdev = ctx->dev;\r\nmutex_unlock(&pcdev->dev_mutex);\r\n}\r\nstatic void set_default_params(struct coda_ctx *ctx)\r\n{\r\nunsigned int max_w, max_h, usize, csize;\r\nctx->codec = coda_find_codec(ctx->dev, ctx->cvd->src_formats[0],\r\nctx->cvd->dst_formats[0]);\r\nmax_w = min(ctx->codec->max_w, 1920U);\r\nmax_h = min(ctx->codec->max_h, 1088U);\r\nusize = max_w * max_h * 3 / 2;\r\ncsize = coda_estimate_sizeimage(ctx, usize, max_w, max_h);\r\nctx->params.codec_mode = ctx->codec->mode;\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->params.framerate = 30;\r\nctx->q_data[V4L2_M2M_SRC].fourcc = ctx->cvd->src_formats[0];\r\nctx->q_data[V4L2_M2M_DST].fourcc = ctx->cvd->dst_formats[0];\r\nctx->q_data[V4L2_M2M_SRC].width = max_w;\r\nctx->q_data[V4L2_M2M_SRC].height = max_h;\r\nctx->q_data[V4L2_M2M_DST].width = max_w;\r\nctx->q_data[V4L2_M2M_DST].height = max_h;\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_YUV420) {\r\nctx->q_data[V4L2_M2M_SRC].bytesperline = max_w;\r\nctx->q_data[V4L2_M2M_SRC].sizeimage = usize;\r\nctx->q_data[V4L2_M2M_DST].bytesperline = 0;\r\nctx->q_data[V4L2_M2M_DST].sizeimage = csize;\r\n} else {\r\nctx->q_data[V4L2_M2M_SRC].bytesperline = 0;\r\nctx->q_data[V4L2_M2M_SRC].sizeimage = csize;\r\nctx->q_data[V4L2_M2M_DST].bytesperline = max_w;\r\nctx->q_data[V4L2_M2M_DST].sizeimage = usize;\r\n}\r\nctx->q_data[V4L2_M2M_SRC].rect.width = max_w;\r\nctx->q_data[V4L2_M2M_SRC].rect.height = max_h;\r\nctx->q_data[V4L2_M2M_DST].rect.width = max_w;\r\nctx->q_data[V4L2_M2M_DST].rect.height = max_h;\r\nctx->tiled_map_type = GDI_LINEAR_FRAME_MAP;\r\n}\r\nstatic int coda_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct coda_q_data *q_data;\r\nunsigned int size;\r\nq_data = get_q_data(ctx, vq->type);\r\nsize = q_data->sizeimage;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"get %d buffer(s) of size %d each.\n", *nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int coda_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct coda_q_data *q_data;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0),\r\n(long)q_data->sizeimage);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void coda_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct coda_q_data *q_data;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (ctx->bitstream.size && vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (vb2_get_plane_payload(vb, 0) == 0)\r\ncoda_bit_stream_end_flag(ctx);\r\nmutex_lock(&ctx->bitstream_mutex);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\nif (vb2_is_streaming(vb->vb2_queue))\r\ncoda_fill_bitstream(ctx, true);\r\nmutex_unlock(&ctx->bitstream_mutex);\r\n} else {\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\n}\r\nint coda_alloc_aux_buf(struct coda_dev *dev, struct coda_aux_buf *buf,\r\nsize_t size, const char *name, struct dentry *parent)\r\n{\r\nbuf->vaddr = dma_alloc_coherent(&dev->plat_dev->dev, size, &buf->paddr,\r\nGFP_KERNEL);\r\nif (!buf->vaddr) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"Failed to allocate %s buffer of size %u\n",\r\nname, size);\r\nreturn -ENOMEM;\r\n}\r\nbuf->size = size;\r\nif (name && parent) {\r\nbuf->blob.data = buf->vaddr;\r\nbuf->blob.size = size;\r\nbuf->dentry = debugfs_create_blob(name, 0644, parent,\r\n&buf->blob);\r\nif (!buf->dentry)\r\ndev_warn(&dev->plat_dev->dev,\r\n"failed to create debugfs entry %s\n", name);\r\n}\r\nreturn 0;\r\n}\r\nvoid coda_free_aux_buf(struct coda_dev *dev,\r\nstruct coda_aux_buf *buf)\r\n{\r\nif (buf->vaddr) {\r\ndma_free_coherent(&dev->plat_dev->dev, buf->size,\r\nbuf->vaddr, buf->paddr);\r\nbuf->vaddr = NULL;\r\nbuf->size = 0;\r\ndebugfs_remove(buf->dentry);\r\nbuf->dentry = NULL;\r\n}\r\n}\r\nstatic int coda_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nstruct vb2_v4l2_buffer *buf;\r\nint ret = 0;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit) {\r\nmutex_lock(&ctx->bitstream_mutex);\r\ncoda_fill_bitstream(ctx, false);\r\nmutex_unlock(&ctx->bitstream_mutex);\r\nif (coda_get_bitstream_payload(ctx) < 512) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nctx->streamon_out = 1;\r\n} else {\r\nctx->streamon_cap = 1;\r\n}\r\nif (!(ctx->streamon_out & ctx->streamon_cap))\r\nreturn 0;\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif ((q_data_src->width != q_data_dst->width &&\r\nround_up(q_data_src->width, 16) != q_data_dst->width) ||\r\n(q_data_src->height != q_data_dst->height &&\r\nround_up(q_data_src->height, 16) != q_data_dst->height)) {\r\nv4l2_err(v4l2_dev, "can't convert %dx%d to %dx%d\n",\r\nq_data_src->width, q_data_src->height,\r\nq_data_dst->width, q_data_dst->height);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit)\r\nv4l2_m2m_set_src_buffered(ctx->fh.m2m_ctx, true);\r\nctx->gopcounter = ctx->params.gop_size - 1;\r\nctx->codec = coda_find_codec(ctx->dev, q_data_src->fourcc,\r\nq_data_dst->fourcc);\r\nif (!ctx->codec) {\r\nv4l2_err(v4l2_dev, "couldn't tell instance type.\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (q_data_dst->fourcc == V4L2_PIX_FMT_JPEG)\r\nctx->params.gop_size = 1;\r\nctx->gopcounter = ctx->params.gop_size - 1;\r\nret = ctx->ops->start_streaming(ctx);\r\nif (ctx->inst_type == CODA_INST_DECODER) {\r\nif (ret == -EAGAIN)\r\nreturn 0;\r\nelse if (ret < 0)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nwhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\r\n} else {\r\nwhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void coda_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct vb2_v4l2_buffer *buf;\r\nunsigned long flags;\r\nbool stop;\r\nstop = ctx->streamon_out && ctx->streamon_cap;\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: output\n", __func__);\r\nctx->streamon_out = 0;\r\ncoda_bit_stream_end_flag(ctx);\r\nctx->qsequence = 0;\r\nwhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\r\n} else {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: capture\n", __func__);\r\nctx->streamon_cap = 0;\r\nctx->osequence = 0;\r\nctx->sequence_offset = 0;\r\nwhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\r\n}\r\nif (stop) {\r\nstruct coda_buffer_meta *meta;\r\nif (ctx->ops->seq_end_work) {\r\nqueue_work(dev->workqueue, &ctx->seq_end_work);\r\nflush_work(&ctx->seq_end_work);\r\n}\r\nspin_lock_irqsave(&ctx->buffer_meta_lock, flags);\r\nwhile (!list_empty(&ctx->buffer_meta_list)) {\r\nmeta = list_first_entry(&ctx->buffer_meta_list,\r\nstruct coda_buffer_meta, list);\r\nlist_del(&meta->list);\r\nkfree(meta);\r\n}\r\nctx->num_metas = 0;\r\nspin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\nctx->runcounter = 0;\r\nctx->aborting = 0;\r\n}\r\nif (!ctx->streamon_out && !ctx->streamon_cap)\r\nctx->bit_stream_param &= ~CODA_BIT_STREAM_END_FLAG;\r\n}\r\nstatic int coda_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct coda_ctx *ctx =\r\ncontainer_of(ctrl->handler, struct coda_ctx, ctrls);\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"s_ctrl: id = %d, val = %d\n", ctrl->id, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\nctx->params.rot_mode |= CODA_MIR_HOR;\r\nelse\r\nctx->params.rot_mode &= ~CODA_MIR_HOR;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\nctx->params.rot_mode |= CODA_MIR_VER;\r\nelse\r\nctx->params.rot_mode &= ~CODA_MIR_VER;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctx->params.bitrate = ctrl->val / 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctx->params.gop_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\r\nctx->params.h264_intra_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\r\nctx->params.h264_inter_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\r\nctx->params.h264_min_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\r\nctx->params.h264_max_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:\r\nctx->params.h264_deblk_alpha = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:\r\nctx->params.h264_deblk_beta = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\nctx->params.h264_deblk_enabled = (ctrl->val ==\r\nV4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED);\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:\r\nctx->params.mpeg4_intra_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:\r\nctx->params.mpeg4_inter_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\nctx->params.slice_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:\r\nctx->params.slice_max_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:\r\nctx->params.slice_max_bits = ctrl->val * 8;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:\r\nctx->params.intra_refresh = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\ncoda_set_jpeg_compression_quality(ctx, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_JPEG_RESTART_INTERVAL:\r\nctx->params.jpeg_restart_interval = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VBV_DELAY:\r\nctx->params.vbv_delay = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VBV_SIZE:\r\nctx->params.vbv_size = min(ctrl->val * 8192, 0x7fffffff);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Invalid control, id=%d, val=%d\n",\r\nctrl->id, ctrl->val);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void coda_encode_ctrls(struct coda_ctx *ctx)\r\n{\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE, 0, 32767000, 1000, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 60, 1, 16);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, 0, 51, 1, 25);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 0, 51, 1, 25);\r\nif (ctx->dev->devtype->product != CODA_960) {\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MIN_QP, 0, 51, 1, 12);\r\n}\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MAX_QP, 0, 51, 1, 51);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA, 0, 15, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA, 0, 15, 1, 0);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE,\r\nV4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED, 0x0,\r\nV4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP, 1, 31, 1, 2);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP, 1, 31, 1, 2);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,\r\nV4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES, 0x0,\r\nV4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB, 1, 0x3fffffff, 1, 1);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES, 1, 0x3fffffff, 1,\r\n500);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_HEADER_MODE,\r\nV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\r\n(1 << V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE),\r\nV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB, 0,\r\n1920 * 1088 / 256, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_VBV_DELAY, 0, 0x7fff, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_VBV_SIZE, 0, 262144, 1, 0);\r\n}\r\nstatic void coda_jpeg_encode_ctrls(struct coda_ctx *ctx)\r\n{\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY, 5, 100, 1, 50);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_JPEG_RESTART_INTERVAL, 0, 100, 1, 0);\r\n}\r\nstatic int coda_ctrls_setup(struct coda_ctx *ctx)\r\n{\r\nv4l2_ctrl_handler_init(&ctx->ctrls, 2);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (ctx->inst_type == CODA_INST_ENCODER) {\r\nif (ctx->cvd->dst_formats[0] == V4L2_PIX_FMT_JPEG)\r\ncoda_jpeg_encode_ctrls(ctx);\r\nelse\r\ncoda_encode_ctrls(ctx);\r\n}\r\nif (ctx->ctrls.error) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"control initialization error (%d)",\r\nctx->ctrls.error);\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_ctrl_handler_setup(&ctx->ctrls);\r\n}\r\nstatic int coda_queue_init(struct coda_ctx *ctx, struct vb2_queue *vq)\r\n{\r\nvq->drv_priv = ctx;\r\nvq->ops = &coda_qops;\r\nvq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nvq->lock = &ctx->dev->dev_mutex;\r\nvq->allow_zero_bytesused = 1;\r\nvq->dev = &ctx->dev->plat_dev->dev;\r\nreturn vb2_queue_init(vq);\r\n}\r\nint coda_encoder_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nret = coda_queue_init(priv, src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\nreturn coda_queue_init(priv, dst_vq);\r\n}\r\nint coda_decoder_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->mem_ops = &vb2_vmalloc_memops;\r\nret = coda_queue_init(priv, src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\nreturn coda_queue_init(priv, dst_vq);\r\n}\r\nstatic int coda_next_free_instance(struct coda_dev *dev)\r\n{\r\nint idx = ffz(dev->instance_mask);\r\nif ((idx < 0) ||\r\n(dev->devtype->product == CODA_DX6 && idx > CODADX6_MAX_INSTANCES))\r\nreturn -EBUSY;\r\nreturn idx;\r\n}\r\nstatic int coda_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct coda_dev *dev = video_get_drvdata(vdev);\r\nstruct coda_ctx *ctx = NULL;\r\nchar *name;\r\nint ret;\r\nint idx;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nidx = coda_next_free_instance(dev);\r\nif (idx < 0) {\r\nret = idx;\r\ngoto err_coda_max;\r\n}\r\nset_bit(idx, &dev->instance_mask);\r\nname = kasprintf(GFP_KERNEL, "context%d", idx);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err_coda_name_init;\r\n}\r\nctx->debugfs_entry = debugfs_create_dir(name, dev->debugfs_root);\r\nkfree(name);\r\nctx->cvd = to_coda_video_device(vdev);\r\nctx->inst_type = ctx->cvd->type;\r\nctx->ops = ctx->cvd->ops;\r\nctx->use_bit = !ctx->cvd->direct;\r\ninit_completion(&ctx->completion);\r\nINIT_WORK(&ctx->pic_run_work, coda_pic_run_work);\r\nif (ctx->ops->seq_end_work)\r\nINIT_WORK(&ctx->seq_end_work, ctx->ops->seq_end_work);\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->dev = dev;\r\nctx->idx = idx;\r\nswitch (dev->devtype->product) {\r\ncase CODA_960:\r\nctx->frame_mem_ctrl = 1 << 12;\r\ncase CODA_7541:\r\nctx->reg_idx = 0;\r\nbreak;\r\ndefault:\r\nctx->reg_idx = idx;\r\n}\r\nret = pm_runtime_get_sync(&dev->plat_dev->dev);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to power up: %d\n", ret);\r\ngoto err_pm_get;\r\n}\r\nret = clk_prepare_enable(dev->clk_per);\r\nif (ret)\r\ngoto err_clk_per;\r\nret = clk_prepare_enable(dev->clk_ahb);\r\nif (ret)\r\ngoto err_clk_ahb;\r\nset_default_params(ctx);\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\r\nctx->ops->queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\nv4l2_err(&dev->v4l2_dev, "%s return error (%d)\n",\r\n__func__, ret);\r\ngoto err_ctx_init;\r\n}\r\nret = coda_ctrls_setup(ctx);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "failed to setup coda controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrls;\r\nmutex_init(&ctx->bitstream_mutex);\r\nmutex_init(&ctx->buffer_mutex);\r\nINIT_LIST_HEAD(&ctx->buffer_meta_list);\r\nspin_lock_init(&ctx->buffer_meta_lock);\r\ncoda_lock(ctx);\r\nlist_add(&ctx->list, &dev->instances);\r\ncoda_unlock(ctx);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "Created instance %d (%p)\n",\r\nctx->idx, ctx);\r\nreturn 0;\r\nerr_ctrls_setup:\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nerr_ctx_init:\r\nclk_disable_unprepare(dev->clk_ahb);\r\nerr_clk_ahb:\r\nclk_disable_unprepare(dev->clk_per);\r\nerr_clk_per:\r\npm_runtime_put_sync(&dev->plat_dev->dev);\r\nerr_pm_get:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nclear_bit(ctx->idx, &dev->instance_mask);\r\nerr_coda_name_init:\r\nerr_coda_max:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int coda_release(struct file *file)\r\n{\r\nstruct coda_dev *dev = video_drvdata(file);\r\nstruct coda_ctx *ctx = fh_to_ctx(file->private_data);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "Releasing instance %p\n",\r\nctx);\r\nif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit)\r\ncoda_bit_stream_end_flag(ctx);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nif (ctx->ops->seq_end_work) {\r\nqueue_work(dev->workqueue, &ctx->seq_end_work);\r\nflush_work(&ctx->seq_end_work);\r\n}\r\ncoda_lock(ctx);\r\nlist_del(&ctx->list);\r\ncoda_unlock(ctx);\r\nif (ctx->dev->devtype->product == CODA_DX6)\r\ncoda_free_aux_buf(dev, &ctx->workbuf);\r\nv4l2_ctrl_handler_free(&ctx->ctrls);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nclk_disable_unprepare(dev->clk_per);\r\npm_runtime_put_sync(&dev->plat_dev->dev);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nclear_bit(ctx->idx, &dev->instance_mask);\r\nif (ctx->ops->release)\r\nctx->ops->release(ctx);\r\ndebugfs_remove_recursive(ctx->debugfs_entry);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic int coda_hw_init(struct coda_dev *dev)\r\n{\r\nu32 data;\r\nu16 *p;\r\nint i, ret;\r\nret = clk_prepare_enable(dev->clk_per);\r\nif (ret)\r\ngoto err_clk_per;\r\nret = clk_prepare_enable(dev->clk_ahb);\r\nif (ret)\r\ngoto err_clk_ahb;\r\nif (dev->rstc)\r\nreset_control_reset(dev->rstc);\r\np = (u16 *)dev->codebuf.vaddr;\r\nif (dev->devtype->product == CODA_DX6) {\r\nfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++) {\r\ndata = CODA_DOWN_ADDRESS_SET(i) |\r\nCODA_DOWN_DATA_SET(p[i ^ 1]);\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\r\n}\r\n} else {\r\nfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++) {\r\ndata = CODA_DOWN_ADDRESS_SET(i) |\r\nCODA_DOWN_DATA_SET(p[round_down(i, 4) +\r\n3 - (i % 4)]);\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\r\n}\r\n}\r\nfor (i = 0; i < 64; i++)\r\ncoda_write(dev, 0, CODA_REG_BIT_CODE_BUF_ADDR + i * 4);\r\nif (dev->devtype->product == CODA_960 ||\r\ndev->devtype->product == CODA_7541) {\r\ncoda_write(dev, dev->tempbuf.paddr,\r\nCODA_REG_BIT_TEMP_BUF_ADDR);\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\n} else {\r\ncoda_write(dev, dev->workbuf.paddr,\r\nCODA_REG_BIT_WORK_BUF_ADDR);\r\n}\r\ncoda_write(dev, dev->codebuf.paddr,\r\nCODA_REG_BIT_CODE_BUF_ADDR);\r\ncoda_write(dev, 0, CODA_REG_BIT_CODE_RUN);\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncoda_write(dev, CODADX6_STREAM_BUF_PIC_FLUSH,\r\nCODA_REG_BIT_STREAM_CTRL);\r\nbreak;\r\ndefault:\r\ncoda_write(dev, CODA7_STREAM_BUF_PIC_FLUSH,\r\nCODA_REG_BIT_STREAM_CTRL);\r\n}\r\nif (dev->devtype->product == CODA_960)\r\ncoda_write(dev, 1 << 12, CODA_REG_BIT_FRAME_MEM_CTRL);\r\nelse\r\ncoda_write(dev, 0, CODA_REG_BIT_FRAME_MEM_CTRL);\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_write(dev, 0, CODA7_REG_BIT_AXI_SRAM_USE);\r\ncoda_write(dev, CODA_INT_INTERRUPT_ENABLE,\r\nCODA_REG_BIT_INT_ENABLE);\r\ndata = coda_read(dev, CODA_REG_BIT_CODE_RESET);\r\ndata |= CODA_REG_RESET_ENABLE;\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\r\nudelay(10);\r\ndata &= ~CODA_REG_RESET_ENABLE;\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\r\ncoda_write(dev, CODA_REG_RUN_ENABLE, CODA_REG_BIT_CODE_RUN);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nclk_disable_unprepare(dev->clk_per);\r\nreturn 0;\r\nerr_clk_ahb:\r\nclk_disable_unprepare(dev->clk_per);\r\nerr_clk_per:\r\nreturn ret;\r\n}\r\nstatic int coda_register_device(struct coda_dev *dev, int i)\r\n{\r\nstruct video_device *vfd = &dev->vfd[i];\r\nif (i >= dev->devtype->num_vdevs)\r\nreturn -EINVAL;\r\nstrlcpy(vfd->name, dev->devtype->vdevs[i]->name, sizeof(vfd->name));\r\nvfd->fops = &coda_fops;\r\nvfd->ioctl_ops = &coda_ioctl_ops;\r\nvfd->release = video_device_release_empty,\r\nvfd->lock = &dev->dev_mutex;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->vfl_dir = VFL_DIR_M2M;\r\nvideo_set_drvdata(vfd, dev);\r\nv4l2_disable_ioctl(vfd, VIDIOC_CROPCAP);\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_CROP);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_CROP);\r\nreturn video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\n}\r\nstatic void coda_copy_firmware(struct coda_dev *dev, const u8 * const buf,\r\nsize_t size)\r\n{\r\nu32 *src = (u32 *)buf;\r\nif (buf[0] == 'M' && buf[1] == 'X')\r\nsrc += 4;\r\nif (__le16_to_cpup((__le16 *)src) == 0xe40e) {\r\nu32 *dst = dev->codebuf.vaddr;\r\nint i;\r\nif (dev->devtype->product == CODA_DX6) {\r\nfor (i = 0; i < (size - 16) / 4; i++)\r\ndst[i] = (src[i] << 16) | (src[i] >> 16);\r\n} else {\r\nfor (i = 0; i < (size - 16) / 4; i += 2) {\r\ndst[i] = (src[i + 1] << 16) | (src[i + 1] >> 16);\r\ndst[i + 1] = (src[i] << 16) | (src[i] >> 16);\r\n}\r\n}\r\n} else {\r\nmemcpy(dev->codebuf.vaddr, src, size);\r\n}\r\n}\r\nstatic int coda_firmware_request(struct coda_dev *dev)\r\n{\r\nchar *fw = dev->devtype->firmware[dev->firmware];\r\ndev_dbg(&dev->plat_dev->dev, "requesting firmware '%s' for %s\n", fw,\r\ncoda_product_name(dev->devtype->product));\r\nreturn request_firmware_nowait(THIS_MODULE, true, fw,\r\n&dev->plat_dev->dev, GFP_KERNEL, dev,\r\ncoda_fw_callback);\r\n}\r\nstatic void coda_fw_callback(const struct firmware *fw, void *context)\r\n{\r\nstruct coda_dev *dev = context;\r\nstruct platform_device *pdev = dev->plat_dev;\r\nint i, ret;\r\nif (!fw && dev->firmware == 1) {\r\nv4l2_err(&dev->v4l2_dev, "firmware request failed\n");\r\ngoto put_pm;\r\n}\r\nif (!fw) {\r\ndev->firmware = 1;\r\ncoda_firmware_request(dev);\r\nreturn;\r\n}\r\nif (dev->firmware == 1) {\r\ndev_info(&pdev->dev, "Using fallback firmware %s\n",\r\ndev->devtype->firmware[dev->firmware]);\r\n}\r\nret = coda_alloc_aux_buf(dev, &dev->codebuf, fw->size, "codebuf",\r\ndev->debugfs_root);\r\nif (ret < 0)\r\ngoto put_pm;\r\ncoda_copy_firmware(dev, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nret = coda_hw_init(dev);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "HW initialization failed\n");\r\ngoto put_pm;\r\n}\r\nret = coda_check_firmware(dev);\r\nif (ret < 0)\r\ngoto put_pm;\r\ndev->m2m_dev = v4l2_m2m_init(&coda_m2m_ops);\r\nif (IS_ERR(dev->m2m_dev)) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to init mem2mem device\n");\r\ngoto put_pm;\r\n}\r\nfor (i = 0; i < dev->devtype->num_vdevs; i++) {\r\nret = coda_register_device(dev, i);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"Failed to register %s video device: %d\n",\r\ndev->devtype->vdevs[i]->name, ret);\r\ngoto rel_vfd;\r\n}\r\n}\r\nv4l2_info(&dev->v4l2_dev, "codec registered as /dev/video[%d-%d]\n",\r\ndev->vfd[0].num, dev->vfd[i - 1].num);\r\npm_runtime_put_sync(&pdev->dev);\r\nreturn;\r\nrel_vfd:\r\nwhile (--i >= 0)\r\nvideo_unregister_device(&dev->vfd[i]);\r\nv4l2_m2m_release(dev->m2m_dev);\r\nput_pm:\r\npm_runtime_put_sync(&pdev->dev);\r\n}\r\nstatic int coda_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(of_match_ptr(coda_dt_ids), &pdev->dev);\r\nconst struct platform_device_id *pdev_id;\r\nstruct coda_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct gen_pool *pool;\r\nstruct coda_dev *dev;\r\nstruct resource *res;\r\nint ret, irq;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npdev_id = of_id ? of_id->data : platform_get_device_id(pdev);\r\nif (of_id)\r\ndev->devtype = of_id->data;\r\nelse if (pdev_id)\r\ndev->devtype = &coda_devdata[pdev_id->driver_data];\r\nelse\r\nreturn -EINVAL;\r\nspin_lock_init(&dev->irqlock);\r\nINIT_LIST_HEAD(&dev->instances);\r\ndev->plat_dev = pdev;\r\ndev->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(dev->clk_per)) {\r\ndev_err(&pdev->dev, "Could not get per clock\n");\r\nreturn PTR_ERR(dev->clk_per);\r\n}\r\ndev->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(dev->clk_ahb)) {\r\ndev_err(&pdev->dev, "Could not get ahb clock\n");\r\nreturn PTR_ERR(dev->clk_ahb);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->regs_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->regs_base))\r\nreturn PTR_ERR(dev->regs_base);\r\nirq = platform_get_irq_byname(pdev, "bit");\r\nif (irq < 0)\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq resource\n");\r\nreturn irq;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL, coda_irq_handler,\r\nIRQF_ONESHOT, dev_name(&pdev->dev), dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request irq: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev->rstc = devm_reset_control_get_optional(&pdev->dev, NULL);\r\nif (IS_ERR(dev->rstc)) {\r\nret = PTR_ERR(dev->rstc);\r\nif (ret == -ENOENT || ret == -ENOTSUPP) {\r\ndev->rstc = NULL;\r\n} else {\r\ndev_err(&pdev->dev, "failed get reset control: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\npool = of_gen_pool_get(np, "iram", 0);\r\nif (!pool && pdata)\r\npool = gen_pool_get(pdata->iram_dev, NULL);\r\nif (!pool) {\r\ndev_err(&pdev->dev, "iram pool not available\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->iram_pool = pool;\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&dev->dev_mutex);\r\nmutex_init(&dev->coda_mutex);\r\ndev->debugfs_root = debugfs_create_dir("coda", NULL);\r\nif (!dev->debugfs_root)\r\ndev_warn(&pdev->dev, "failed to create debugfs root\n");\r\nif (dev->devtype->product == CODA_DX6) {\r\nret = coda_alloc_aux_buf(dev, &dev->workbuf,\r\ndev->devtype->workbuf_size, "workbuf",\r\ndev->debugfs_root);\r\nif (ret < 0)\r\ngoto err_v4l2_register;\r\n}\r\nif (dev->devtype->tempbuf_size) {\r\nret = coda_alloc_aux_buf(dev, &dev->tempbuf,\r\ndev->devtype->tempbuf_size, "tempbuf",\r\ndev->debugfs_root);\r\nif (ret < 0)\r\ngoto err_v4l2_register;\r\n}\r\ndev->iram.size = dev->devtype->iram_size;\r\ndev->iram.vaddr = gen_pool_dma_alloc(dev->iram_pool, dev->iram.size,\r\n&dev->iram.paddr);\r\nif (!dev->iram.vaddr) {\r\ndev_warn(&pdev->dev, "unable to alloc iram\n");\r\n} else {\r\nmemset(dev->iram.vaddr, 0, dev->iram.size);\r\ndev->iram.blob.data = dev->iram.vaddr;\r\ndev->iram.blob.size = dev->iram.size;\r\ndev->iram.dentry = debugfs_create_blob("iram", 0644,\r\ndev->debugfs_root,\r\n&dev->iram.blob);\r\n}\r\ndev->workqueue = alloc_workqueue("coda", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!dev->workqueue) {\r\ndev_err(&pdev->dev, "unable to alloc workqueue\n");\r\nret = -ENOMEM;\r\ngoto err_v4l2_register;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\npm_runtime_get_noresume(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn coda_firmware_request(dev);\r\nerr_v4l2_register:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int coda_remove(struct platform_device *pdev)\r\n{\r\nstruct coda_dev *dev = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dev->vfd); i++) {\r\nif (video_get_drvdata(&dev->vfd[i]))\r\nvideo_unregister_device(&dev->vfd[i]);\r\n}\r\nif (dev->m2m_dev)\r\nv4l2_m2m_release(dev->m2m_dev);\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\ndestroy_workqueue(dev->workqueue);\r\nif (dev->iram.vaddr)\r\ngen_pool_free(dev->iram_pool, (unsigned long)dev->iram.vaddr,\r\ndev->iram.size);\r\ncoda_free_aux_buf(dev, &dev->codebuf);\r\ncoda_free_aux_buf(dev, &dev->tempbuf);\r\ncoda_free_aux_buf(dev, &dev->workbuf);\r\ndebugfs_remove_recursive(dev->debugfs_root);\r\nreturn 0;\r\n}\r\nstatic int coda_runtime_resume(struct device *dev)\r\n{\r\nstruct coda_dev *cdev = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (dev->pm_domain && cdev->codebuf.vaddr) {\r\nret = coda_hw_init(cdev);\r\nif (ret)\r\nv4l2_err(&cdev->v4l2_dev, "HW initialization failed\n");\r\n}\r\nreturn ret;\r\n}
