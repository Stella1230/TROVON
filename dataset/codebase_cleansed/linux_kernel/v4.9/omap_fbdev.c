static void pan_worker(struct work_struct *work)\r\n{\r\nstruct omap_fbdev *fbdev = container_of(work, struct omap_fbdev, work);\r\nstruct fb_info *fbi = fbdev->base.fbdev;\r\nint npages;\r\nnpages = fbi->fix.line_length >> PAGE_SHIFT;\r\nomap_gem_roll(fbdev->bo, fbi->var.yoffset * npages);\r\n}\r\nstatic int omap_fbdev_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct drm_fb_helper *helper = get_fb(fbi);\r\nstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\r\nif (!helper)\r\ngoto fallback;\r\nif (!fbdev->ywrap_enabled)\r\ngoto fallback;\r\nif (drm_can_sleep()) {\r\npan_worker(&fbdev->work);\r\n} else {\r\nstruct omap_drm_private *priv = helper->dev->dev_private;\r\nqueue_work(priv->wq, &fbdev->work);\r\n}\r\nreturn 0;\r\nfallback:\r\nreturn drm_fb_helper_pan_display(var, fbi);\r\n}\r\nstatic int omap_fbdev_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\r\nstruct drm_device *dev = helper->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_framebuffer *fb = NULL;\r\nunion omap_gem_size gsize;\r\nstruct fb_info *fbi = NULL;\r\nstruct drm_mode_fb_cmd2 mode_cmd = {0};\r\ndma_addr_t paddr;\r\nint ret;\r\nsizes->surface_bpp = 32;\r\nsizes->surface_depth = 24;\r\nDBG("create fbdev: %dx%d@%d (%dx%d)", sizes->surface_width,\r\nsizes->surface_height, sizes->surface_bpp,\r\nsizes->fb_width, sizes->fb_height);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] =\r\nDIV_ROUND_UP(mode_cmd.width * sizes->surface_bpp, 8);\r\nfbdev->ywrap_enabled = priv->has_dmm && ywrap_enabled;\r\nif (fbdev->ywrap_enabled) {\r\nmode_cmd.pitches[0] = PAGE_ALIGN(mode_cmd.pitches[0]);\r\n}\r\ngsize = (union omap_gem_size){\r\n.bytes = PAGE_ALIGN(mode_cmd.pitches[0] * mode_cmd.height),\r\n};\r\nDBG("allocating %d bytes for fb %d", gsize.bytes, dev->primary->index);\r\nfbdev->bo = omap_gem_new(dev, gsize, OMAP_BO_SCANOUT | OMAP_BO_WC);\r\nif (!fbdev->bo) {\r\ndev_err(dev->dev, "failed to allocate buffer object\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfb = omap_framebuffer_init(dev, &mode_cmd, &fbdev->bo);\r\nif (IS_ERR(fb)) {\r\ndev_err(dev->dev, "failed to allocate fb\n");\r\ndrm_gem_object_unreference_unlocked(fbdev->bo);\r\nret = PTR_ERR(fb);\r\ngoto fail;\r\n}\r\nret = omap_gem_get_paddr(fbdev->bo, &paddr, true);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"could not map (paddr)! Skipping framebuffer alloc\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nfbi = drm_fb_helper_alloc_fbi(helper);\r\nif (IS_ERR(fbi)) {\r\ndev_err(dev->dev, "failed to allocate fb info\n");\r\nret = PTR_ERR(fbi);\r\ngoto fail_unlock;\r\n}\r\nDBG("fbi=%p, dev=%p", fbi, dev);\r\nfbdev->fb = fb;\r\nhelper->fb = fb;\r\nfbi->par = helper;\r\nfbi->flags = FBINFO_DEFAULT;\r\nfbi->fbops = &omap_fb_ops;\r\nstrcpy(fbi->fix.id, MODULE_NAME);\r\ndrm_fb_helper_fill_fix(fbi, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(fbi, helper, sizes->fb_width, sizes->fb_height);\r\ndev->mode_config.fb_base = paddr;\r\nfbi->screen_base = omap_gem_vaddr(fbdev->bo);\r\nfbi->screen_size = fbdev->bo->size;\r\nfbi->fix.smem_start = paddr;\r\nfbi->fix.smem_len = fbdev->bo->size;\r\nif (fbdev->ywrap_enabled) {\r\nDRM_INFO("Enabling DMM ywrap scrolling\n");\r\nfbi->flags |= FBINFO_HWACCEL_YWRAP | FBINFO_READS_FAST;\r\nfbi->fix.ywrapstep = 1;\r\n}\r\nDBG("par=%p, %dx%d", fbi->par, fbi->var.xres, fbi->var.yres);\r\nDBG("allocated %dx%d fb", fbdev->fb->width, fbdev->fb->height);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\nfail_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nfail:\r\nif (ret) {\r\ndrm_fb_helper_release_fbi(helper);\r\nif (fb) {\r\ndrm_framebuffer_unregister_private(fb);\r\ndrm_framebuffer_remove(fb);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct drm_fb_helper *get_fb(struct fb_info *fbi)\r\n{\r\nif (!fbi || strcmp(fbi->fix.id, MODULE_NAME)) {\r\nreturn NULL;\r\n}\r\nreturn fbi->par;\r\n}\r\nstruct drm_fb_helper *omap_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_fbdev *fbdev = NULL;\r\nstruct drm_fb_helper *helper;\r\nint ret = 0;\r\nfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev)\r\ngoto fail;\r\nINIT_WORK(&fbdev->work, pan_worker);\r\nhelper = &fbdev->base;\r\ndrm_fb_helper_prepare(dev, helper, &omap_fb_helper_funcs);\r\nret = drm_fb_helper_init(dev, helper,\r\npriv->num_crtcs, priv->num_connectors);\r\nif (ret) {\r\ndev_err(dev->dev, "could not init fbdev: ret=%d\n", ret);\r\ngoto fail;\r\n}\r\nret = drm_fb_helper_single_add_all_connectors(helper);\r\nif (ret)\r\ngoto fini;\r\nret = drm_fb_helper_initial_config(helper, 32);\r\nif (ret)\r\ngoto fini;\r\npriv->fbdev = helper;\r\nreturn helper;\r\nfini:\r\ndrm_fb_helper_fini(helper);\r\nfail:\r\nkfree(fbdev);\r\ndev_warn(dev->dev, "omap_fbdev_init failed\n");\r\nreturn NULL;\r\n}\r\nvoid omap_fbdev_free(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_fb_helper *helper = priv->fbdev;\r\nstruct omap_fbdev *fbdev;\r\nDBG();\r\ndrm_fb_helper_unregister_fbi(helper);\r\ndrm_fb_helper_release_fbi(helper);\r\ndrm_fb_helper_fini(helper);\r\nfbdev = to_omap_fbdev(priv->fbdev);\r\nomap_gem_put_paddr(fbdev->bo);\r\nif (fbdev->fb) {\r\ndrm_framebuffer_unregister_private(fbdev->fb);\r\ndrm_framebuffer_remove(fbdev->fb);\r\n}\r\nkfree(fbdev);\r\npriv->fbdev = NULL;\r\n}
