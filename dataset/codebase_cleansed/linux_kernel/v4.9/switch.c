static const char *tb_port_type(struct tb_regs_port_header *port)\r\n{\r\nswitch (port->type >> 16) {\r\ncase 0:\r\nswitch ((u8) port->type) {\r\ncase 0:\r\nreturn "Inactive";\r\ncase 1:\r\nreturn "Port";\r\ncase 2:\r\nreturn "NHI";\r\ndefault:\r\nreturn "unknown";\r\n}\r\ncase 0x2:\r\nreturn "Ethernet";\r\ncase 0x8:\r\nreturn "SATA";\r\ncase 0xe:\r\nreturn "DP/HDMI";\r\ncase 0x10:\r\nreturn "PCIe";\r\ncase 0x20:\r\nreturn "USB";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic void tb_dump_port(struct tb *tb, struct tb_regs_port_header *port)\r\n{\r\ntb_info(tb,\r\n" Port %d: %x:%x (Revision: %d, TB Version: %d, Type: %s (%#x))\n",\r\nport->port_number, port->vendor_id, port->device_id,\r\nport->revision, port->thunderbolt_version, tb_port_type(port),\r\nport->type);\r\ntb_info(tb, " Max hop id (in/out): %d/%d\n",\r\nport->max_in_hop_id, port->max_out_hop_id);\r\ntb_info(tb, " Max counters: %d\n", port->max_counters);\r\ntb_info(tb, " NFC Credits: %#x\n", port->nfc_credits);\r\n}\r\nstatic int tb_port_state(struct tb_port *port)\r\n{\r\nstruct tb_cap_phy phy;\r\nint res;\r\nif (port->cap_phy == 0) {\r\ntb_port_WARN(port, "does not have a PHY\n");\r\nreturn -EINVAL;\r\n}\r\nres = tb_port_read(port, &phy, TB_CFG_PORT, port->cap_phy, 2);\r\nif (res)\r\nreturn res;\r\nreturn phy.state;\r\n}\r\nint tb_wait_for_port(struct tb_port *port, bool wait_if_unplugged)\r\n{\r\nint retries = 10;\r\nint state;\r\nif (!port->cap_phy) {\r\ntb_port_WARN(port, "does not have PHY\n");\r\nreturn -EINVAL;\r\n}\r\nif (tb_is_upstream_port(port)) {\r\ntb_port_WARN(port, "is the upstream port\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (retries--) {\r\nstate = tb_port_state(port);\r\nif (state < 0)\r\nreturn state;\r\nif (state == TB_PORT_DISABLED) {\r\ntb_port_info(port, "is disabled (state: 0)\n");\r\nreturn 0;\r\n}\r\nif (state == TB_PORT_UNPLUGGED) {\r\nif (wait_if_unplugged) {\r\ntb_port_info(port,\r\n"is unplugged (state: 7), retrying...\n");\r\nmsleep(100);\r\ncontinue;\r\n}\r\ntb_port_info(port, "is unplugged (state: 7)\n");\r\nreturn 0;\r\n}\r\nif (state == TB_PORT_UP) {\r\ntb_port_info(port,\r\n"is connected, link is up (state: 2)\n");\r\nreturn 1;\r\n}\r\ntb_port_info(port,\r\n"is connected, link is not up (state: %d), retrying...\n",\r\nstate);\r\nmsleep(100);\r\n}\r\ntb_port_warn(port,\r\n"failed to reach state TB_PORT_UP. Ignoring port...\n");\r\nreturn 0;\r\n}\r\nint tb_port_add_nfc_credits(struct tb_port *port, int credits)\r\n{\r\nif (credits == 0)\r\nreturn 0;\r\ntb_port_info(port,\r\n"adding %#x NFC credits (%#x -> %#x)",\r\ncredits,\r\nport->config.nfc_credits,\r\nport->config.nfc_credits + credits);\r\nport->config.nfc_credits += credits;\r\nreturn tb_port_write(port, &port->config.nfc_credits,\r\nTB_CFG_PORT, 4, 1);\r\n}\r\nint tb_port_clear_counter(struct tb_port *port, int counter)\r\n{\r\nu32 zero[3] = { 0, 0, 0 };\r\ntb_port_info(port, "clearing counter %d\n", counter);\r\nreturn tb_port_write(port, zero, TB_CFG_COUNTERS, 3 * counter, 3);\r\n}\r\nstatic int tb_init_port(struct tb_port *port)\r\n{\r\nint res;\r\nint cap;\r\nres = tb_port_read(port, &port->config, TB_CFG_PORT, 0, 8);\r\nif (res)\r\nreturn res;\r\nif (port->config.type == TB_TYPE_PORT && port->port != 0) {\r\ncap = tb_find_cap(port, TB_CFG_PORT, TB_CAP_PHY);\r\nif (cap > 0)\r\nport->cap_phy = cap;\r\nelse\r\ntb_port_WARN(port, "non switch port without a PHY\n");\r\n}\r\ntb_dump_port(port->sw->tb, &port->config);\r\nreturn 0;\r\n}\r\nstatic void tb_dump_switch(struct tb *tb, struct tb_regs_switch_header *sw)\r\n{\r\ntb_info(tb,\r\n" Switch: %x:%x (Revision: %d, TB Version: %d)\n",\r\nsw->vendor_id, sw->device_id, sw->revision,\r\nsw->thunderbolt_version);\r\ntb_info(tb, " Max Port Number: %d\n", sw->max_port_number);\r\ntb_info(tb, " Config:\n");\r\ntb_info(tb,\r\n" Upstream Port Number: %d Depth: %d Route String: %#llx Enabled: %d, PlugEventsDelay: %dms\n",\r\nsw->upstream_port_number, sw->depth,\r\n(((u64) sw->route_hi) << 32) | sw->route_lo,\r\nsw->enabled, sw->plug_events_delay);\r\ntb_info(tb,\r\n" unknown1: %#x unknown4: %#x\n",\r\nsw->__unknown1, sw->__unknown4);\r\n}\r\nint tb_switch_reset(struct tb *tb, u64 route)\r\n{\r\nstruct tb_cfg_result res;\r\nstruct tb_regs_switch_header header = {\r\nheader.route_hi = route >> 32,\r\nheader.route_lo = route,\r\nheader.enabled = true,\r\n};\r\ntb_info(tb, "resetting switch at %llx\n", route);\r\nres.err = tb_cfg_write(tb->ctl, ((u32 *) &header) + 2, route,\r\n0, 2, 2, 2);\r\nif (res.err)\r\nreturn res.err;\r\nres = tb_cfg_reset(tb->ctl, route, TB_CFG_DEFAULT_TIMEOUT);\r\nif (res.err > 0)\r\nreturn -EIO;\r\nreturn res.err;\r\n}\r\nstruct tb_switch *get_switch_at_route(struct tb_switch *sw, u64 route)\r\n{\r\nu8 next_port = route;\r\nif (route == 0)\r\nreturn sw;\r\nif (next_port > sw->config.max_port_number)\r\nreturn NULL;\r\nif (tb_is_upstream_port(&sw->ports[next_port]))\r\nreturn NULL;\r\nif (!sw->ports[next_port].remote)\r\nreturn NULL;\r\nreturn get_switch_at_route(sw->ports[next_port].remote->sw,\r\nroute >> TB_ROUTE_SHIFT);\r\n}\r\nstatic int tb_plug_events_active(struct tb_switch *sw, bool active)\r\n{\r\nu32 data;\r\nint res;\r\nsw->config.plug_events_delay = 0xff;\r\nres = tb_sw_write(sw, ((u32 *) &sw->config) + 4, TB_CFG_SWITCH, 4, 1);\r\nif (res)\r\nreturn res;\r\nres = tb_sw_read(sw, &data, TB_CFG_SWITCH, sw->cap_plug_events + 1, 1);\r\nif (res)\r\nreturn res;\r\nif (active) {\r\ndata = data & 0xFFFFFF83;\r\nswitch (sw->config.device_id) {\r\ncase PCI_DEVICE_ID_INTEL_LIGHT_RIDGE:\r\ncase PCI_DEVICE_ID_INTEL_EAGLE_RIDGE:\r\ncase PCI_DEVICE_ID_INTEL_PORT_RIDGE:\r\nbreak;\r\ndefault:\r\ndata |= 4;\r\n}\r\n} else {\r\ndata = data | 0x7c;\r\n}\r\nreturn tb_sw_write(sw, &data, TB_CFG_SWITCH,\r\nsw->cap_plug_events + 1, 1);\r\n}\r\nvoid tb_switch_free(struct tb_switch *sw)\r\n{\r\nint i;\r\nfor (i = 1; i <= sw->config.max_port_number; i++) {\r\nif (tb_is_upstream_port(&sw->ports[i]))\r\ncontinue;\r\nif (sw->ports[i].remote)\r\ntb_switch_free(sw->ports[i].remote->sw);\r\nsw->ports[i].remote = NULL;\r\n}\r\nif (!sw->is_unplugged)\r\ntb_plug_events_active(sw, false);\r\nkfree(sw->ports);\r\nkfree(sw->drom);\r\nkfree(sw);\r\n}\r\nstruct tb_switch *tb_switch_alloc(struct tb *tb, u64 route)\r\n{\r\nint i;\r\nint cap;\r\nstruct tb_switch *sw;\r\nint upstream_port = tb_cfg_get_upstream_port(tb->ctl, route);\r\nif (upstream_port < 0)\r\nreturn NULL;\r\nsw = kzalloc(sizeof(*sw), GFP_KERNEL);\r\nif (!sw)\r\nreturn NULL;\r\nsw->tb = tb;\r\nif (tb_cfg_read(tb->ctl, &sw->config, route, 0, TB_CFG_SWITCH, 0, 5))\r\ngoto err;\r\ntb_info(tb,\r\n"initializing Switch at %#llx (depth: %d, up port: %d)\n",\r\nroute, tb_route_length(route), upstream_port);\r\ntb_info(tb, "old switch config:\n");\r\ntb_dump_switch(tb, &sw->config);\r\nsw->config.upstream_port_number = upstream_port;\r\nsw->config.depth = tb_route_length(route);\r\nsw->config.route_lo = route;\r\nsw->config.route_hi = route >> 32;\r\nsw->config.enabled = 1;\r\nif (sw->config.vendor_id != 0x8086)\r\ntb_sw_warn(sw, "unknown switch vendor id %#x\n",\r\nsw->config.vendor_id);\r\nif (sw->config.device_id != PCI_DEVICE_ID_INTEL_LIGHT_RIDGE &&\r\nsw->config.device_id != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C &&\r\nsw->config.device_id != PCI_DEVICE_ID_INTEL_PORT_RIDGE &&\r\nsw->config.device_id != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_BRIDGE &&\r\nsw->config.device_id != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_BRIDGE)\r\ntb_sw_warn(sw, "unsupported switch device id %#x\n",\r\nsw->config.device_id);\r\nif (tb_sw_write(sw, 1 + (u32 *) &sw->config, TB_CFG_SWITCH, 1, 3))\r\ngoto err;\r\nsw->ports = kcalloc(sw->config.max_port_number + 1, sizeof(*sw->ports),\r\nGFP_KERNEL);\r\nif (!sw->ports)\r\ngoto err;\r\nfor (i = 0; i <= sw->config.max_port_number; i++) {\r\nsw->ports[i].sw = sw;\r\nsw->ports[i].port = i;\r\n}\r\ncap = tb_find_cap(&sw->ports[0], TB_CFG_SWITCH, TB_CAP_PLUG_EVENTS);\r\nif (cap < 0) {\r\ntb_sw_warn(sw, "cannot find TB_CAP_PLUG_EVENTS aborting\n");\r\ngoto err;\r\n}\r\nsw->cap_plug_events = cap;\r\nif (tb_drom_read(sw))\r\ntb_sw_warn(sw, "tb_eeprom_read_rom failed, continuing\n");\r\ntb_sw_info(sw, "uid: %#llx\n", sw->uid);\r\nfor (i = 0; i <= sw->config.max_port_number; i++) {\r\nif (sw->ports[i].disabled) {\r\ntb_port_info(&sw->ports[i], "disabled by eeprom\n");\r\ncontinue;\r\n}\r\nif (tb_init_port(&sw->ports[i]))\r\ngoto err;\r\n}\r\nif (tb_plug_events_active(sw, true))\r\ngoto err;\r\nreturn sw;\r\nerr:\r\nkfree(sw->ports);\r\nkfree(sw->drom);\r\nkfree(sw);\r\nreturn NULL;\r\n}\r\nvoid tb_sw_set_unplugged(struct tb_switch *sw)\r\n{\r\nint i;\r\nif (sw == sw->tb->root_switch) {\r\ntb_sw_WARN(sw, "cannot unplug root switch\n");\r\nreturn;\r\n}\r\nif (sw->is_unplugged) {\r\ntb_sw_WARN(sw, "is_unplugged already set\n");\r\nreturn;\r\n}\r\nsw->is_unplugged = true;\r\nfor (i = 0; i <= sw->config.max_port_number; i++) {\r\nif (!tb_is_upstream_port(&sw->ports[i]) && sw->ports[i].remote)\r\ntb_sw_set_unplugged(sw->ports[i].remote->sw);\r\n}\r\n}\r\nint tb_switch_resume(struct tb_switch *sw)\r\n{\r\nint i, err;\r\nu64 uid;\r\ntb_sw_info(sw, "resuming switch\n");\r\nerr = tb_drom_read_uid_only(sw, &uid);\r\nif (err) {\r\ntb_sw_warn(sw, "uid read failed\n");\r\nreturn err;\r\n}\r\nif (sw->uid != uid) {\r\ntb_sw_info(sw,\r\n"changed while suspended (uid %#llx -> %#llx)\n",\r\nsw->uid, uid);\r\nreturn -ENODEV;\r\n}\r\nerr = tb_sw_write(sw, 1 + (u32 *) &sw->config, TB_CFG_SWITCH, 1, 3);\r\nif (err)\r\nreturn err;\r\nerr = tb_plug_events_active(sw, true);\r\nif (err)\r\nreturn err;\r\nfor (i = 1; i <= sw->config.max_port_number; i++) {\r\nstruct tb_port *port = &sw->ports[i];\r\nif (tb_is_upstream_port(port))\r\ncontinue;\r\nif (!port->remote)\r\ncontinue;\r\nif (tb_wait_for_port(port, true) <= 0\r\n|| tb_switch_resume(port->remote->sw)) {\r\ntb_port_warn(port,\r\n"lost during suspend, disconnecting\n");\r\ntb_sw_set_unplugged(port->remote->sw);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid tb_switch_suspend(struct tb_switch *sw)\r\n{\r\nint i, err;\r\nerr = tb_plug_events_active(sw, false);\r\nif (err)\r\nreturn;\r\nfor (i = 1; i <= sw->config.max_port_number; i++) {\r\nif (!tb_is_upstream_port(&sw->ports[i]) && sw->ports[i].remote)\r\ntb_switch_suspend(sw->ports[i].remote->sw);\r\n}\r\n}
