static inline struct pwm_omap_dmtimer_chip *\r\nto_pwm_omap_dmtimer_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct pwm_omap_dmtimer_chip, chip);\r\n}\r\nstatic u32 pwm_omap_dmtimer_get_clock_cycles(unsigned long clk_rate, int ns)\r\n{\r\nreturn DIV_ROUND_CLOSEST_ULL((u64)clk_rate * ns, NSEC_PER_SEC);\r\n}\r\nstatic void pwm_omap_dmtimer_start(struct pwm_omap_dmtimer_chip *omap)\r\n{\r\nomap->pdata->enable(omap->dm_timer);\r\nomap->pdata->write_counter(omap->dm_timer, DM_TIMER_LOAD_MIN);\r\nomap->pdata->disable(omap->dm_timer);\r\nomap->pdata->start(omap->dm_timer);\r\n}\r\nstatic int pwm_omap_dmtimer_enable(struct pwm_chip *chip,\r\nstruct pwm_device *pwm)\r\n{\r\nstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\r\nmutex_lock(&omap->mutex);\r\npwm_omap_dmtimer_start(omap);\r\nmutex_unlock(&omap->mutex);\r\nreturn 0;\r\n}\r\nstatic void pwm_omap_dmtimer_disable(struct pwm_chip *chip,\r\nstruct pwm_device *pwm)\r\n{\r\nstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\r\nmutex_lock(&omap->mutex);\r\nomap->pdata->stop(omap->dm_timer);\r\nmutex_unlock(&omap->mutex);\r\n}\r\nstatic int pwm_omap_dmtimer_config(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\r\nu32 period_cycles, duty_cycles;\r\nu32 load_value, match_value;\r\nstruct clk *fclk;\r\nunsigned long clk_rate;\r\nbool timer_active;\r\ndev_dbg(chip->dev, "requested duty cycle: %d ns, period: %d ns\n",\r\nduty_ns, period_ns);\r\nmutex_lock(&omap->mutex);\r\nif (duty_ns == pwm_get_duty_cycle(pwm) &&\r\nperiod_ns == pwm_get_period(pwm)) {\r\nmutex_unlock(&omap->mutex);\r\nreturn 0;\r\n}\r\nfclk = omap->pdata->get_fclk(omap->dm_timer);\r\nif (!fclk) {\r\ndev_err(chip->dev, "invalid pmtimer fclk\n");\r\ngoto err_einval;\r\n}\r\nclk_rate = clk_get_rate(fclk);\r\nif (!clk_rate) {\r\ndev_err(chip->dev, "invalid pmtimer fclk rate\n");\r\ngoto err_einval;\r\n}\r\ndev_dbg(chip->dev, "clk rate: %luHz\n", clk_rate);\r\nperiod_cycles = pwm_omap_dmtimer_get_clock_cycles(clk_rate, period_ns);\r\nduty_cycles = pwm_omap_dmtimer_get_clock_cycles(clk_rate, duty_ns);\r\nif (period_cycles < 2) {\r\ndev_info(chip->dev,\r\n"period %d ns too short for clock rate %lu Hz\n",\r\nperiod_ns, clk_rate);\r\ngoto err_einval;\r\n}\r\nif (duty_cycles < 1) {\r\ndev_dbg(chip->dev,\r\n"duty cycle %d ns is too short for clock rate %lu Hz\n",\r\nduty_ns, clk_rate);\r\ndev_dbg(chip->dev, "using minimum of 1 clock cycle\n");\r\nduty_cycles = 1;\r\n} else if (duty_cycles >= period_cycles) {\r\ndev_dbg(chip->dev,\r\n"duty cycle %d ns is too long for period %d ns at clock rate %lu Hz\n",\r\nduty_ns, period_ns, clk_rate);\r\ndev_dbg(chip->dev, "using maximum of 1 clock cycle less than period\n");\r\nduty_cycles = period_cycles - 1;\r\n}\r\ndev_dbg(chip->dev, "effective duty cycle: %lld ns, period: %lld ns\n",\r\nDIV_ROUND_CLOSEST_ULL((u64)NSEC_PER_SEC * duty_cycles,\r\nclk_rate),\r\nDIV_ROUND_CLOSEST_ULL((u64)NSEC_PER_SEC * period_cycles,\r\nclk_rate));\r\nload_value = (DM_TIMER_MAX - period_cycles) + 1;\r\nmatch_value = load_value + duty_cycles - 1;\r\ntimer_active = pm_runtime_active(&omap->dm_timer_pdev->dev);\r\nif (timer_active)\r\nomap->pdata->stop(omap->dm_timer);\r\nomap->pdata->set_load(omap->dm_timer, true, load_value);\r\nomap->pdata->set_match(omap->dm_timer, true, match_value);\r\ndev_dbg(chip->dev, "load value: %#08x (%d), match value: %#08x (%d)\n",\r\nload_value, load_value, match_value, match_value);\r\nomap->pdata->set_pwm(omap->dm_timer,\r\npwm_get_polarity(pwm) == PWM_POLARITY_INVERSED,\r\ntrue,\r\nPWM_OMAP_DMTIMER_TRIGGER_OVERFLOW_AND_COMPARE);\r\nif (timer_active)\r\npwm_omap_dmtimer_start(omap);\r\nmutex_unlock(&omap->mutex);\r\nreturn 0;\r\nerr_einval:\r\nmutex_unlock(&omap->mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic int pwm_omap_dmtimer_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\r\nmutex_lock(&omap->mutex);\r\nomap->pdata->set_pwm(omap->dm_timer,\r\npolarity == PWM_POLARITY_INVERSED,\r\ntrue,\r\nPWM_OMAP_DMTIMER_TRIGGER_OVERFLOW_AND_COMPARE);\r\nmutex_unlock(&omap->mutex);\r\nreturn 0;\r\n}\r\nstatic int pwm_omap_dmtimer_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *timer;\r\nstruct pwm_omap_dmtimer_chip *omap;\r\nstruct pwm_omap_dmtimer_pdata *pdata;\r\npwm_omap_dmtimer *dm_timer;\r\nu32 v;\r\nint status;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Missing dmtimer platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->request_by_node ||\r\n!pdata->free ||\r\n!pdata->enable ||\r\n!pdata->disable ||\r\n!pdata->get_fclk ||\r\n!pdata->start ||\r\n!pdata->stop ||\r\n!pdata->set_load ||\r\n!pdata->set_match ||\r\n!pdata->set_pwm ||\r\n!pdata->set_prescaler ||\r\n!pdata->write_counter) {\r\ndev_err(&pdev->dev, "Incomplete dmtimer pdata structure\n");\r\nreturn -EINVAL;\r\n}\r\ntimer = of_parse_phandle(np, "ti,timers", 0);\r\nif (!timer)\r\nreturn -ENODEV;\r\nif (!of_get_property(timer, "ti,timer-pwm", NULL)) {\r\ndev_err(&pdev->dev, "Missing ti,timer-pwm capability\n");\r\nreturn -ENODEV;\r\n}\r\ndm_timer = pdata->request_by_node(timer);\r\nif (!dm_timer)\r\nreturn -EPROBE_DEFER;\r\nomap = devm_kzalloc(&pdev->dev, sizeof(*omap), GFP_KERNEL);\r\nif (!omap) {\r\npdata->free(dm_timer);\r\nreturn -ENOMEM;\r\n}\r\nomap->pdata = pdata;\r\nomap->dm_timer = dm_timer;\r\nomap->dm_timer_pdev = of_find_device_by_node(timer);\r\nif (!omap->dm_timer_pdev) {\r\ndev_err(&pdev->dev, "Unable to find timer pdev\n");\r\nomap->pdata->free(dm_timer);\r\nreturn -EINVAL;\r\n}\r\nif (pm_runtime_active(&omap->dm_timer_pdev->dev))\r\nomap->pdata->stop(omap->dm_timer);\r\nif (!of_property_read_u32(pdev->dev.of_node, "ti,prescaler", &v))\r\nomap->pdata->set_prescaler(omap->dm_timer, v);\r\nif (!of_property_read_u32(pdev->dev.of_node, "ti,clock-source", &v))\r\nomap->pdata->set_source(omap->dm_timer, v);\r\nomap->chip.dev = &pdev->dev;\r\nomap->chip.ops = &pwm_omap_dmtimer_ops;\r\nomap->chip.base = -1;\r\nomap->chip.npwm = 1;\r\nomap->chip.of_xlate = of_pwm_xlate_with_flags;\r\nomap->chip.of_pwm_n_cells = 3;\r\nmutex_init(&omap->mutex);\r\nstatus = pwmchip_add(&omap->chip);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "failed to register PWM\n");\r\nomap->pdata->free(omap->dm_timer);\r\nreturn status;\r\n}\r\nplatform_set_drvdata(pdev, omap);\r\nreturn 0;\r\n}\r\nstatic int pwm_omap_dmtimer_remove(struct platform_device *pdev)\r\n{\r\nstruct pwm_omap_dmtimer_chip *omap = platform_get_drvdata(pdev);\r\nif (pm_runtime_active(&omap->dm_timer_pdev->dev))\r\nomap->pdata->stop(omap->dm_timer);\r\nomap->pdata->free(omap->dm_timer);\r\nmutex_destroy(&omap->mutex);\r\nreturn pwmchip_remove(&omap->chip);\r\n}
