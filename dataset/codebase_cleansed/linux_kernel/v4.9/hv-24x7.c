static bool domain_is_valid(unsigned domain)\r\n{\r\nswitch (domain) {\r\n#define DOMAIN(n, v, x, c) \\r\ncase HV_PERF_DOMAIN_##n: \\r\n#include "hv-24x7-domains.h"\r\n#undef DOMAIN\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool is_physical_domain(unsigned domain)\r\n{\r\nswitch (domain) {\r\n#define DOMAIN(n, v, x, c) \\r\ncase HV_PERF_DOMAIN_##n: \\r\nreturn c;\r\n#include "hv-24x7-domains.h"\r\n#undef DOMAIN\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic const char *domain_name(unsigned domain)\r\n{\r\nif (!domain_is_valid(domain))\r\nreturn NULL;\r\nswitch (domain) {\r\ncase HV_PERF_DOMAIN_PHYS_CHIP: return "Physical Chip";\r\ncase HV_PERF_DOMAIN_PHYS_CORE: return "Physical Core";\r\ncase HV_PERF_DOMAIN_VCPU_HOME_CORE: return "VCPU Home Core";\r\ncase HV_PERF_DOMAIN_VCPU_HOME_CHIP: return "VCPU Home Chip";\r\ncase HV_PERF_DOMAIN_VCPU_HOME_NODE: return "VCPU Home Node";\r\ncase HV_PERF_DOMAIN_VCPU_REMOTE_NODE: return "VCPU Remote Node";\r\n}\r\nWARN_ON_ONCE(domain);\r\nreturn NULL;\r\n}\r\nstatic bool catalog_entry_domain_is_valid(unsigned domain)\r\n{\r\nreturn is_physical_domain(domain);\r\n}\r\nstatic char *event_name(struct hv_24x7_event_data *ev, int *len)\r\n{\r\n*len = be16_to_cpu(ev->event_name_len) - 2;\r\nreturn (char *)ev->remainder;\r\n}\r\nstatic char *event_desc(struct hv_24x7_event_data *ev, int *len)\r\n{\r\nunsigned nl = be16_to_cpu(ev->event_name_len);\r\n__be16 *desc_len = (__be16 *)(ev->remainder + nl - 2);\r\n*len = be16_to_cpu(*desc_len) - 2;\r\nreturn (char *)ev->remainder + nl;\r\n}\r\nstatic char *event_long_desc(struct hv_24x7_event_data *ev, int *len)\r\n{\r\nunsigned nl = be16_to_cpu(ev->event_name_len);\r\n__be16 *desc_len_ = (__be16 *)(ev->remainder + nl - 2);\r\nunsigned desc_len = be16_to_cpu(*desc_len_);\r\n__be16 *long_desc_len = (__be16 *)(ev->remainder + nl + desc_len - 2);\r\n*len = be16_to_cpu(*long_desc_len) - 2;\r\nreturn (char *)ev->remainder + nl + desc_len;\r\n}\r\nstatic bool event_fixed_portion_is_within(struct hv_24x7_event_data *ev,\r\nvoid *end)\r\n{\r\nvoid *start = ev;\r\nreturn (start + offsetof(struct hv_24x7_event_data, remainder)) < end;\r\n}\r\nstatic void *event_end(struct hv_24x7_event_data *ev, void *end)\r\n{\r\nvoid *start = ev;\r\n__be16 *dl_, *ldl_;\r\nunsigned dl, ldl;\r\nunsigned nl = be16_to_cpu(ev->event_name_len);\r\nif (nl < 2) {\r\npr_debug("%s: name length too short: %d", __func__, nl);\r\nreturn NULL;\r\n}\r\nif (start + nl > end) {\r\npr_debug("%s: start=%p + nl=%u > end=%p",\r\n__func__, start, nl, end);\r\nreturn NULL;\r\n}\r\ndl_ = (__be16 *)(ev->remainder + nl - 2);\r\nif (!IS_ALIGNED((uintptr_t)dl_, 2))\r\npr_warn("desc len not aligned %p", dl_);\r\ndl = be16_to_cpu(*dl_);\r\nif (dl < 2) {\r\npr_debug("%s: desc len too short: %d", __func__, dl);\r\nreturn NULL;\r\n}\r\nif (start + nl + dl > end) {\r\npr_debug("%s: (start=%p + nl=%u + dl=%u)=%p > end=%p",\r\n__func__, start, nl, dl, start + nl + dl, end);\r\nreturn NULL;\r\n}\r\nldl_ = (__be16 *)(ev->remainder + nl + dl - 2);\r\nif (!IS_ALIGNED((uintptr_t)ldl_, 2))\r\npr_warn("long desc len not aligned %p", ldl_);\r\nldl = be16_to_cpu(*ldl_);\r\nif (ldl < 2) {\r\npr_debug("%s: long desc len too short (ldl=%u)",\r\n__func__, ldl);\r\nreturn NULL;\r\n}\r\nif (start + nl + dl + ldl > end) {\r\npr_debug("%s: start=%p + nl=%u + dl=%u + ldl=%u > end=%p",\r\n__func__, start, nl, dl, ldl, end);\r\nreturn NULL;\r\n}\r\nreturn start + nl + dl + ldl;\r\n}\r\nstatic unsigned long h_get_24x7_catalog_page_(unsigned long phys_4096,\r\nunsigned long version,\r\nunsigned long index)\r\n{\r\npr_devel("h_get_24x7_catalog_page(0x%lx, %lu, %lu)",\r\nphys_4096, version, index);\r\nWARN_ON(!IS_ALIGNED(phys_4096, 4096));\r\nreturn plpar_hcall_norets(H_GET_24X7_CATALOG_PAGE,\r\nphys_4096, version, index);\r\n}\r\nstatic unsigned long h_get_24x7_catalog_page(char page[],\r\nu64 version, u32 index)\r\n{\r\nreturn h_get_24x7_catalog_page_(virt_to_phys(page),\r\nversion, index);\r\n}\r\nstatic char *event_fmt(struct hv_24x7_event_data *event, unsigned domain)\r\n{\r\nconst char *sindex;\r\nconst char *lpar;\r\nconst char *domain_str;\r\nchar buf[8];\r\nswitch (domain) {\r\ncase HV_PERF_DOMAIN_PHYS_CHIP:\r\nsnprintf(buf, sizeof(buf), "%d", domain);\r\ndomain_str = buf;\r\nlpar = "0x0";\r\nsindex = "chip";\r\nbreak;\r\ncase HV_PERF_DOMAIN_PHYS_CORE:\r\ndomain_str = "?";\r\nlpar = "0x0";\r\nsindex = "core";\r\nbreak;\r\ndefault:\r\ndomain_str = "?";\r\nlpar = "?";\r\nsindex = "vcpu";\r\n}\r\nreturn kasprintf(GFP_KERNEL,\r\n"domain=%s,offset=0x%x,%s=?,lpar=%s",\r\ndomain_str,\r\nbe16_to_cpu(event->event_counter_offs) +\r\nbe16_to_cpu(event->event_group_record_offs),\r\nsindex,\r\nlpar);\r\n}\r\nstatic char *memdup_to_str(char *maybe_str, int max_len, gfp_t gfp)\r\n{\r\nreturn kasprintf(gfp, "%.*s", max_len, maybe_str);\r\n}\r\nstatic ssize_t device_show_string(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dev_ext_attribute *d;\r\nd = container_of(attr, struct dev_ext_attribute, attr);\r\nreturn sprintf(buf, "%s\n", (char *)d->var);\r\n}\r\nstatic struct attribute *device_str_attr_create_(char *name, char *str)\r\n{\r\nstruct dev_ext_attribute *attr = kzalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr)\r\nreturn NULL;\r\nsysfs_attr_init(&attr->attr.attr);\r\nattr->var = str;\r\nattr->attr.attr.name = name;\r\nattr->attr.attr.mode = 0444;\r\nattr->attr.show = device_show_string;\r\nreturn &attr->attr.attr;\r\n}\r\nstatic struct attribute *device_str_attr_create(char *name, int name_max,\r\nint name_nonce,\r\nchar *str, size_t str_max)\r\n{\r\nchar *n;\r\nchar *s = memdup_to_str(str, str_max, GFP_KERNEL);\r\nstruct attribute *a;\r\nif (!s)\r\nreturn NULL;\r\nif (!name_nonce)\r\nn = kasprintf(GFP_KERNEL, "%.*s", name_max, name);\r\nelse\r\nn = kasprintf(GFP_KERNEL, "%.*s__%d", name_max, name,\r\nname_nonce);\r\nif (!n)\r\ngoto out_s;\r\na = device_str_attr_create_(n, s);\r\nif (!a)\r\ngoto out_n;\r\nreturn a;\r\nout_n:\r\nkfree(n);\r\nout_s:\r\nkfree(s);\r\nreturn NULL;\r\n}\r\nstatic struct attribute *event_to_attr(unsigned ix,\r\nstruct hv_24x7_event_data *event,\r\nunsigned domain,\r\nint nonce)\r\n{\r\nint event_name_len;\r\nchar *ev_name, *a_ev_name, *val;\r\nstruct attribute *attr;\r\nif (!domain_is_valid(domain)) {\r\npr_warn("catalog event %u has invalid domain %u\n",\r\nix, domain);\r\nreturn NULL;\r\n}\r\nval = event_fmt(event, domain);\r\nif (!val)\r\nreturn NULL;\r\nev_name = event_name(event, &event_name_len);\r\nif (!nonce)\r\na_ev_name = kasprintf(GFP_KERNEL, "%.*s",\r\n(int)event_name_len, ev_name);\r\nelse\r\na_ev_name = kasprintf(GFP_KERNEL, "%.*s__%d",\r\n(int)event_name_len, ev_name, nonce);\r\nif (!a_ev_name)\r\ngoto out_val;\r\nattr = device_str_attr_create_(a_ev_name, val);\r\nif (!attr)\r\ngoto out_name;\r\nreturn attr;\r\nout_name:\r\nkfree(a_ev_name);\r\nout_val:\r\nkfree(val);\r\nreturn NULL;\r\n}\r\nstatic struct attribute *event_to_desc_attr(struct hv_24x7_event_data *event,\r\nint nonce)\r\n{\r\nint nl, dl;\r\nchar *name = event_name(event, &nl);\r\nchar *desc = event_desc(event, &dl);\r\nif (!dl)\r\nreturn NULL;\r\nreturn device_str_attr_create(name, nl, nonce, desc, dl);\r\n}\r\nstatic struct attribute *\r\nevent_to_long_desc_attr(struct hv_24x7_event_data *event, int nonce)\r\n{\r\nint nl, dl;\r\nchar *name = event_name(event, &nl);\r\nchar *desc = event_long_desc(event, &dl);\r\nif (!dl)\r\nreturn NULL;\r\nreturn device_str_attr_create(name, nl, nonce, desc, dl);\r\n}\r\nstatic int event_data_to_attrs(unsigned ix, struct attribute **attrs,\r\nstruct hv_24x7_event_data *event, int nonce)\r\n{\r\n*attrs = event_to_attr(ix, event, event->domain, nonce);\r\nif (!*attrs)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int memord(const void *d1, size_t s1, const void *d2, size_t s2)\r\n{\r\nif (s1 < s2)\r\nreturn 1;\r\nif (s2 > s1)\r\nreturn -1;\r\nreturn memcmp(d1, d2, s1);\r\n}\r\nstatic int ev_uniq_ord(const void *v1, size_t s1, unsigned d1, const void *v2,\r\nsize_t s2, unsigned d2)\r\n{\r\nint r = memord(v1, s1, v2, s2);\r\nif (r)\r\nreturn r;\r\nif (d1 > d2)\r\nreturn 1;\r\nif (d2 > d1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int event_uniq_add(struct rb_root *root, const char *name, int nl,\r\nunsigned domain)\r\n{\r\nstruct rb_node **new = &(root->rb_node), *parent = NULL;\r\nstruct event_uniq *data;\r\nwhile (*new) {\r\nstruct event_uniq *it;\r\nint result;\r\nit = container_of(*new, struct event_uniq, node);\r\nresult = ev_uniq_ord(name, nl, domain, it->name, it->nl,\r\nit->domain);\r\nparent = *new;\r\nif (result < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (result > 0)\r\nnew = &((*new)->rb_right);\r\nelse {\r\nit->ct++;\r\npr_info("found a duplicate event %.*s, ct=%u\n", nl,\r\nname, it->ct);\r\nreturn it->ct;\r\n}\r\n}\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\n*data = (struct event_uniq) {\r\n.name = name,\r\n.nl = nl,\r\n.ct = 0,\r\n.domain = domain,\r\n};\r\nrb_link_node(&data->node, parent, new);\r\nrb_insert_color(&data->node, root);\r\nreturn 0;\r\n}\r\nstatic void event_uniq_destroy(struct rb_root *root)\r\n{\r\nstruct event_uniq *pos, *n;\r\nrbtree_postorder_for_each_entry_safe(pos, n, root, node)\r\nkfree(pos);\r\n}\r\nstatic ssize_t catalog_event_len_validate(struct hv_24x7_event_data *event,\r\nsize_t event_idx,\r\nsize_t event_data_bytes,\r\nsize_t event_entry_count,\r\nsize_t offset, void *end)\r\n{\r\nssize_t ev_len;\r\nvoid *ev_end, *calc_ev_end;\r\nif (offset >= event_data_bytes)\r\nreturn -1;\r\nif (event_idx >= event_entry_count) {\r\npr_devel("catalog event data has %zu bytes of padding after last event\n",\r\nevent_data_bytes - offset);\r\nreturn -1;\r\n}\r\nif (!event_fixed_portion_is_within(event, end)) {\r\npr_warn("event %zu fixed portion is not within range\n",\r\nevent_idx);\r\nreturn -1;\r\n}\r\nev_len = be16_to_cpu(event->length);\r\nif (ev_len % 16)\r\npr_info("event %zu has length %zu not divisible by 16: event=%pK\n",\r\nevent_idx, ev_len, event);\r\nev_end = (__u8 *)event + ev_len;\r\nif (ev_end > end) {\r\npr_warn("event %zu has .length=%zu, ends after buffer end: ev_end=%pK > end=%pK, offset=%zu\n",\r\nevent_idx, ev_len, ev_end, end,\r\noffset);\r\nreturn -1;\r\n}\r\ncalc_ev_end = event_end(event, end);\r\nif (!calc_ev_end) {\r\npr_warn("event %zu has a calculated length which exceeds buffer length %zu: event=%pK end=%pK, offset=%zu\n",\r\nevent_idx, event_data_bytes, event, end,\r\noffset);\r\nreturn -1;\r\n}\r\nif (calc_ev_end > ev_end) {\r\npr_warn("event %zu exceeds it's own length: event=%pK, end=%pK, offset=%zu, calc_ev_end=%pK\n",\r\nevent_idx, event, ev_end, offset, calc_ev_end);\r\nreturn -1;\r\n}\r\nreturn ev_len;\r\n}\r\nstatic int create_events_from_catalog(struct attribute ***events_,\r\nstruct attribute ***event_descs_,\r\nstruct attribute ***event_long_descs_)\r\n{\r\nunsigned long hret;\r\nsize_t catalog_len, catalog_page_len, event_entry_count,\r\nevent_data_len, event_data_offs,\r\nevent_data_bytes, junk_events, event_idx, event_attr_ct, i,\r\nattr_max, event_idx_last, desc_ct, long_desc_ct;\r\nssize_t ct, ev_len;\r\nuint32_t catalog_version_num;\r\nstruct attribute **events, **event_descs, **event_long_descs;\r\nstruct hv_24x7_catalog_page_0 *page_0 =\r\nkmem_cache_alloc(hv_page_cache, GFP_KERNEL);\r\nvoid *page = page_0;\r\nvoid *event_data, *end;\r\nstruct hv_24x7_event_data *event;\r\nstruct rb_root ev_uniq = RB_ROOT;\r\nint ret = 0;\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto e_out;\r\n}\r\nhret = h_get_24x7_catalog_page(page, 0, 0);\r\nif (hret) {\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\ncatalog_version_num = be64_to_cpu(page_0->version);\r\ncatalog_page_len = be32_to_cpu(page_0->length);\r\nif (MAX_4K < catalog_page_len) {\r\npr_err("invalid page count: %zu\n", catalog_page_len);\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\ncatalog_len = catalog_page_len * 4096;\r\nevent_entry_count = be16_to_cpu(page_0->event_entry_count);\r\nevent_data_offs = be16_to_cpu(page_0->event_data_offs);\r\nevent_data_len = be16_to_cpu(page_0->event_data_len);\r\npr_devel("cv %zu cl %zu eec %zu edo %zu edl %zu\n",\r\n(size_t)catalog_version_num, catalog_len,\r\nevent_entry_count, event_data_offs, event_data_len);\r\nif ((MAX_4K < event_data_len)\r\n|| (MAX_4K < event_data_offs)\r\n|| (MAX_4K - event_data_offs < event_data_len)) {\r\npr_err("invalid event data offs %zu and/or len %zu\n",\r\nevent_data_offs, event_data_len);\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\nif ((event_data_offs + event_data_len) > catalog_page_len) {\r\npr_err("event data %zu-%zu does not fit inside catalog 0-%zu\n",\r\nevent_data_offs,\r\nevent_data_offs + event_data_len,\r\ncatalog_page_len);\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\nif (SIZE_MAX - 1 < event_entry_count) {\r\npr_err("event_entry_count %zu is invalid\n", event_entry_count);\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\nevent_data_bytes = event_data_len * 4096;\r\nevent_data = vmalloc(event_data_bytes);\r\nif (!event_data) {\r\npr_err("could not allocate event data\n");\r\nret = -ENOMEM;\r\ngoto e_free;\r\n}\r\nend = event_data + event_data_bytes;\r\nBUILD_BUG_ON(PAGE_SIZE % 4096);\r\nfor (i = 0; i < event_data_len; i++) {\r\nhret = h_get_24x7_catalog_page_(\r\nvmalloc_to_phys(event_data + i * 4096),\r\ncatalog_version_num,\r\ni + event_data_offs);\r\nif (hret) {\r\npr_err("failed to get event data in page %zu\n",\r\ni + event_data_offs);\r\nret = -EIO;\r\ngoto e_event_data;\r\n}\r\n}\r\nfor (junk_events = 0, event = event_data, event_idx = 0, attr_max = 0;\r\n;\r\nevent_idx++, event = (void *)event + ev_len) {\r\nsize_t offset = (void *)event - (void *)event_data;\r\nchar *name;\r\nint nl;\r\nev_len = catalog_event_len_validate(event, event_idx,\r\nevent_data_bytes,\r\nevent_entry_count,\r\noffset, end);\r\nif (ev_len < 0)\r\nbreak;\r\nname = event_name(event, &nl);\r\nif (event->event_group_record_len == 0) {\r\npr_devel("invalid event %zu (%.*s): group_record_len == 0, skipping\n",\r\nevent_idx, nl, name);\r\njunk_events++;\r\ncontinue;\r\n}\r\nif (!catalog_entry_domain_is_valid(event->domain)) {\r\npr_info("event %zu (%.*s) has invalid domain %d\n",\r\nevent_idx, nl, name, event->domain);\r\njunk_events++;\r\ncontinue;\r\n}\r\nattr_max++;\r\n}\r\nevent_idx_last = event_idx;\r\nif (event_idx_last != event_entry_count)\r\npr_warn("event buffer ended before listed # of events were parsed (got %zu, wanted %zu, junk %zu)\n",\r\nevent_idx_last, event_entry_count, junk_events);\r\nevents = kmalloc_array(attr_max + 1, sizeof(*events), GFP_KERNEL);\r\nif (!events) {\r\nret = -ENOMEM;\r\ngoto e_event_data;\r\n}\r\nevent_descs = kmalloc_array(event_idx + 1, sizeof(*event_descs),\r\nGFP_KERNEL);\r\nif (!event_descs) {\r\nret = -ENOMEM;\r\ngoto e_event_attrs;\r\n}\r\nevent_long_descs = kmalloc_array(event_idx + 1,\r\nsizeof(*event_long_descs), GFP_KERNEL);\r\nif (!event_long_descs) {\r\nret = -ENOMEM;\r\ngoto e_event_descs;\r\n}\r\nfor (junk_events = 0, event_attr_ct = 0, desc_ct = 0, long_desc_ct = 0,\r\nevent = event_data, event_idx = 0;\r\nevent_idx < event_idx_last;\r\nevent_idx++, ev_len = be16_to_cpu(event->length),\r\nevent = (void *)event + ev_len) {\r\nchar *name;\r\nint nl;\r\nint nonce;\r\nif (event->event_group_record_len == 0)\r\ncontinue;\r\nif (!catalog_entry_domain_is_valid(event->domain))\r\ncontinue;\r\nname = event_name(event, &nl);\r\nnonce = event_uniq_add(&ev_uniq, name, nl, event->domain);\r\nct = event_data_to_attrs(event_idx, events + event_attr_ct,\r\nevent, nonce);\r\nif (ct < 0) {\r\npr_warn("event %zu (%.*s) creation failure, skipping\n",\r\nevent_idx, nl, name);\r\njunk_events++;\r\n} else {\r\nevent_attr_ct++;\r\nevent_descs[desc_ct] = event_to_desc_attr(event, nonce);\r\nif (event_descs[desc_ct])\r\ndesc_ct++;\r\nevent_long_descs[long_desc_ct] =\r\nevent_to_long_desc_attr(event, nonce);\r\nif (event_long_descs[long_desc_ct])\r\nlong_desc_ct++;\r\n}\r\n}\r\npr_info("read %zu catalog entries, created %zu event attrs (%zu failures), %zu descs\n",\r\nevent_idx, event_attr_ct, junk_events, desc_ct);\r\nevents[event_attr_ct] = NULL;\r\nevent_descs[desc_ct] = NULL;\r\nevent_long_descs[long_desc_ct] = NULL;\r\nevent_uniq_destroy(&ev_uniq);\r\nvfree(event_data);\r\nkmem_cache_free(hv_page_cache, page);\r\n*events_ = events;\r\n*event_descs_ = event_descs;\r\n*event_long_descs_ = event_long_descs;\r\nreturn 0;\r\ne_event_descs:\r\nkfree(event_descs);\r\ne_event_attrs:\r\nkfree(events);\r\ne_event_data:\r\nvfree(event_data);\r\ne_free:\r\nkmem_cache_free(hv_page_cache, page);\r\ne_out:\r\n*events_ = NULL;\r\n*event_descs_ = NULL;\r\n*event_long_descs_ = NULL;\r\nreturn ret;\r\n}\r\nstatic ssize_t catalog_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t offset, size_t count)\r\n{\r\nunsigned long hret;\r\nssize_t ret = 0;\r\nsize_t catalog_len = 0, catalog_page_len = 0;\r\nloff_t page_offset = 0;\r\nloff_t offset_in_page;\r\nsize_t copy_len;\r\nuint64_t catalog_version_num = 0;\r\nvoid *page = kmem_cache_alloc(hv_page_cache, GFP_USER);\r\nstruct hv_24x7_catalog_page_0 *page_0 = page;\r\nif (!page)\r\nreturn -ENOMEM;\r\nhret = h_get_24x7_catalog_page(page, 0, 0);\r\nif (hret) {\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\ncatalog_version_num = be64_to_cpu(page_0->version);\r\ncatalog_page_len = be32_to_cpu(page_0->length);\r\ncatalog_len = catalog_page_len * 4096;\r\npage_offset = offset / 4096;\r\noffset_in_page = offset % 4096;\r\nif (page_offset >= catalog_page_len)\r\ngoto e_free;\r\nif (page_offset != 0) {\r\nhret = h_get_24x7_catalog_page(page, catalog_version_num,\r\npage_offset);\r\nif (hret) {\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\n}\r\ncopy_len = 4096 - offset_in_page;\r\nif (copy_len > count)\r\ncopy_len = count;\r\nmemcpy(buf, page+offset_in_page, copy_len);\r\nret = copy_len;\r\ne_free:\r\nif (hret)\r\npr_err("h_get_24x7_catalog_page(ver=%lld, page=%lld) failed:"\r\n" rc=%ld\n",\r\ncatalog_version_num, page_offset, hret);\r\nkmem_cache_free(hv_page_cache, page);\r\npr_devel("catalog_read: offset=%lld(%lld) count=%zu "\r\n"catalog_len=%zu(%zu) => %zd\n", offset, page_offset,\r\ncount, catalog_len, catalog_page_len, ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t domains_show(struct device *dev, struct device_attribute *attr,\r\nchar *page)\r\n{\r\nint d, n, count = 0;\r\nconst char *str;\r\nfor (d = 0; d < HV_PERF_DOMAIN_MAX; d++) {\r\nstr = domain_name(d);\r\nif (!str)\r\ncontinue;\r\nn = sprintf(page, "%d: %s\n", d, str);\r\nif (n < 0)\r\nbreak;\r\ncount += n;\r\npage += n;\r\n}\r\nreturn count;\r\n}\r\nstatic void log_24x7_hcall(struct hv_24x7_request_buffer *request_buffer,\r\nstruct hv_24x7_data_result_buffer *result_buffer,\r\nunsigned long ret)\r\n{\r\nstruct hv_24x7_request *req;\r\nreq = &request_buffer->requests[0];\r\npr_notice_ratelimited("hcall failed: [%d %#x %#x %d] => "\r\n"ret 0x%lx (%ld) detail=0x%x failing ix=%x\n",\r\nreq->performance_domain, req->data_offset,\r\nreq->starting_ix, req->starting_lpar_ix, ret, ret,\r\nresult_buffer->detailed_rc,\r\nresult_buffer->failing_request_ix);\r\n}\r\nstatic void init_24x7_request(struct hv_24x7_request_buffer *request_buffer,\r\nstruct hv_24x7_data_result_buffer *result_buffer)\r\n{\r\nmemset(request_buffer, 0, 4096);\r\nmemset(result_buffer, 0, 4096);\r\nrequest_buffer->interface_version = HV_24X7_IF_VERSION_CURRENT;\r\n}\r\nstatic int make_24x7_request(struct hv_24x7_request_buffer *request_buffer,\r\nstruct hv_24x7_data_result_buffer *result_buffer)\r\n{\r\nunsigned long ret;\r\nret = plpar_hcall_norets(H_GET_24X7_DATA,\r\nvirt_to_phys(request_buffer), H24x7_DATA_BUFFER_SIZE,\r\nvirt_to_phys(result_buffer), H24x7_DATA_BUFFER_SIZE);\r\nif (ret)\r\nlog_24x7_hcall(request_buffer, result_buffer, ret);\r\nreturn ret;\r\n}\r\nstatic int add_event_to_24x7_request(struct perf_event *event,\r\nstruct hv_24x7_request_buffer *request_buffer)\r\n{\r\nu16 idx;\r\nint i;\r\nstruct hv_24x7_request *req;\r\nif (request_buffer->num_requests > 254) {\r\npr_devel("Too many requests for 24x7 HCALL %d\n",\r\nrequest_buffer->num_requests);\r\nreturn -EINVAL;\r\n}\r\nswitch (event_get_domain(event)) {\r\ncase HV_PERF_DOMAIN_PHYS_CHIP:\r\nidx = event_get_chip(event);\r\nbreak;\r\ncase HV_PERF_DOMAIN_PHYS_CORE:\r\nidx = event_get_core(event);\r\nbreak;\r\ndefault:\r\nidx = event_get_vcpu(event);\r\n}\r\ni = request_buffer->num_requests++;\r\nreq = &request_buffer->requests[i];\r\nreq->performance_domain = event_get_domain(event);\r\nreq->data_size = cpu_to_be16(8);\r\nreq->data_offset = cpu_to_be32(event_get_offset(event));\r\nreq->starting_lpar_ix = cpu_to_be16(event_get_lpar(event)),\r\nreq->max_num_lpars = cpu_to_be16(1);\r\nreq->starting_ix = cpu_to_be16(idx);\r\nreq->max_ix = cpu_to_be16(1);\r\nreturn 0;\r\n}\r\nstatic unsigned long single_24x7_request(struct perf_event *event, u64 *count)\r\n{\r\nunsigned long ret;\r\nstruct hv_24x7_request_buffer *request_buffer;\r\nstruct hv_24x7_data_result_buffer *result_buffer;\r\nBUILD_BUG_ON(sizeof(*request_buffer) > 4096);\r\nBUILD_BUG_ON(sizeof(*result_buffer) > 4096);\r\nrequest_buffer = (void *)get_cpu_var(hv_24x7_reqb);\r\nresult_buffer = (void *)get_cpu_var(hv_24x7_resb);\r\ninit_24x7_request(request_buffer, result_buffer);\r\nret = add_event_to_24x7_request(event, request_buffer);\r\nif (ret)\r\ngoto out;\r\nret = make_24x7_request(request_buffer, result_buffer);\r\nif (ret) {\r\nlog_24x7_hcall(request_buffer, result_buffer, ret);\r\ngoto out;\r\n}\r\n*count = be64_to_cpu(result_buffer->results[0].elements[0].element_data[0]);\r\nout:\r\nput_cpu_var(hv_24x7_reqb);\r\nput_cpu_var(hv_24x7_resb);\r\nreturn ret;\r\n}\r\nstatic int h_24x7_event_init(struct perf_event *event)\r\n{\r\nstruct hv_perf_caps caps;\r\nunsigned domain;\r\nunsigned long hret;\r\nu64 ct;\r\nif (event->attr.type != event->pmu->type)\r\nreturn -ENOENT;\r\nif (event_get_reserved1(event) ||\r\nevent_get_reserved2(event) ||\r\nevent_get_reserved3(event)) {\r\npr_devel("reserved set when forbidden 0x%llx(0x%llx) 0x%llx(0x%llx) 0x%llx(0x%llx)\n",\r\nevent->attr.config,\r\nevent_get_reserved1(event),\r\nevent->attr.config1,\r\nevent_get_reserved2(event),\r\nevent->attr.config2,\r\nevent_get_reserved3(event));\r\nreturn -EINVAL;\r\n}\r\nif (event->attr.exclude_user ||\r\nevent->attr.exclude_kernel ||\r\nevent->attr.exclude_hv ||\r\nevent->attr.exclude_idle ||\r\nevent->attr.exclude_host ||\r\nevent->attr.exclude_guest)\r\nreturn -EINVAL;\r\nif (has_branch_stack(event))\r\nreturn -EOPNOTSUPP;\r\nif (event_get_offset(event) % 8) {\r\npr_devel("bad alignment\n");\r\nreturn -EINVAL;\r\n}\r\ndomain = event_get_domain(event);\r\nif (domain > 6) {\r\npr_devel("invalid domain %d\n", domain);\r\nreturn -EINVAL;\r\n}\r\nhret = hv_perf_caps_get(&caps);\r\nif (hret) {\r\npr_devel("could not get capabilities: rc=%ld\n", hret);\r\nreturn -EIO;\r\n}\r\nif (!caps.collect_privileged && (is_physical_domain(domain) ||\r\n(event_get_lpar(event) != event_get_lpar_max()))) {\r\npr_devel("hv permissions disallow: is_physical_domain:%d, lpar=0x%llx\n",\r\nis_physical_domain(domain),\r\nevent_get_lpar(event));\r\nreturn -EACCES;\r\n}\r\nif (single_24x7_request(event, &ct)) {\r\npr_devel("test hcall failed\n");\r\nreturn -EIO;\r\n}\r\n(void)local64_xchg(&event->hw.prev_count, ct);\r\nreturn 0;\r\n}\r\nstatic u64 h_24x7_get_value(struct perf_event *event)\r\n{\r\nunsigned long ret;\r\nu64 ct;\r\nret = single_24x7_request(event, &ct);\r\nif (ret)\r\nreturn 0;\r\nreturn ct;\r\n}\r\nstatic void update_event_count(struct perf_event *event, u64 now)\r\n{\r\ns64 prev;\r\nprev = local64_xchg(&event->hw.prev_count, now);\r\nlocal64_add(now - prev, &event->count);\r\n}\r\nstatic void h_24x7_event_read(struct perf_event *event)\r\n{\r\nu64 now;\r\nstruct hv_24x7_request_buffer *request_buffer;\r\nstruct hv_24x7_hw *h24x7hw;\r\nint txn_flags;\r\ntxn_flags = __this_cpu_read(hv_24x7_txn_flags);\r\nif (txn_flags & PERF_PMU_TXN_READ) {\r\nint i;\r\nint ret;\r\nif (__this_cpu_read(hv_24x7_txn_err))\r\nreturn;\r\nrequest_buffer = (void *)get_cpu_var(hv_24x7_reqb);\r\nret = add_event_to_24x7_request(event, request_buffer);\r\nif (ret) {\r\n__this_cpu_write(hv_24x7_txn_err, ret);\r\n} else {\r\ni = request_buffer->num_requests - 1;\r\nh24x7hw = &get_cpu_var(hv_24x7_hw);\r\nh24x7hw->events[i] = event;\r\nput_cpu_var(h24x7hw);\r\nlocal64_set(&event->count, 0);\r\n}\r\nput_cpu_var(hv_24x7_reqb);\r\n} else {\r\nnow = h_24x7_get_value(event);\r\nupdate_event_count(event, now);\r\n}\r\n}\r\nstatic void h_24x7_event_start(struct perf_event *event, int flags)\r\n{\r\nif (flags & PERF_EF_RELOAD)\r\nlocal64_set(&event->hw.prev_count, h_24x7_get_value(event));\r\n}\r\nstatic void h_24x7_event_stop(struct perf_event *event, int flags)\r\n{\r\nh_24x7_event_read(event);\r\n}\r\nstatic int h_24x7_event_add(struct perf_event *event, int flags)\r\n{\r\nif (flags & PERF_EF_START)\r\nh_24x7_event_start(event, flags);\r\nreturn 0;\r\n}\r\nstatic void h_24x7_event_start_txn(struct pmu *pmu, unsigned int flags)\r\n{\r\nstruct hv_24x7_request_buffer *request_buffer;\r\nstruct hv_24x7_data_result_buffer *result_buffer;\r\nWARN_ON_ONCE(__this_cpu_read(hv_24x7_txn_flags));\r\n__this_cpu_write(hv_24x7_txn_flags, flags);\r\nif (flags & ~PERF_PMU_TXN_READ)\r\nreturn;\r\nrequest_buffer = (void *)get_cpu_var(hv_24x7_reqb);\r\nresult_buffer = (void *)get_cpu_var(hv_24x7_resb);\r\ninit_24x7_request(request_buffer, result_buffer);\r\nput_cpu_var(hv_24x7_resb);\r\nput_cpu_var(hv_24x7_reqb);\r\n}\r\nstatic void reset_txn(void)\r\n{\r\n__this_cpu_write(hv_24x7_txn_flags, 0);\r\n__this_cpu_write(hv_24x7_txn_err, 0);\r\n}\r\nstatic int h_24x7_event_commit_txn(struct pmu *pmu)\r\n{\r\nstruct hv_24x7_request_buffer *request_buffer;\r\nstruct hv_24x7_data_result_buffer *result_buffer;\r\nstruct hv_24x7_result *resb;\r\nstruct perf_event *event;\r\nu64 count;\r\nint i, ret, txn_flags;\r\nstruct hv_24x7_hw *h24x7hw;\r\ntxn_flags = __this_cpu_read(hv_24x7_txn_flags);\r\nWARN_ON_ONCE(!txn_flags);\r\nret = 0;\r\nif (txn_flags & ~PERF_PMU_TXN_READ)\r\ngoto out;\r\nret = __this_cpu_read(hv_24x7_txn_err);\r\nif (ret)\r\ngoto out;\r\nrequest_buffer = (void *)get_cpu_var(hv_24x7_reqb);\r\nresult_buffer = (void *)get_cpu_var(hv_24x7_resb);\r\nret = make_24x7_request(request_buffer, result_buffer);\r\nif (ret) {\r\nlog_24x7_hcall(request_buffer, result_buffer, ret);\r\ngoto put_reqb;\r\n}\r\nh24x7hw = &get_cpu_var(hv_24x7_hw);\r\nfor (i = 0; i < request_buffer->num_requests; i++) {\r\nresb = &result_buffer->results[i];\r\ncount = be64_to_cpu(resb->elements[0].element_data[0]);\r\nevent = h24x7hw->events[i];\r\nh24x7hw->events[i] = NULL;\r\nupdate_event_count(event, count);\r\n}\r\nput_cpu_var(hv_24x7_hw);\r\nput_reqb:\r\nput_cpu_var(hv_24x7_resb);\r\nput_cpu_var(hv_24x7_reqb);\r\nout:\r\nreset_txn();\r\nreturn ret;\r\n}\r\nstatic void h_24x7_event_cancel_txn(struct pmu *pmu)\r\n{\r\nWARN_ON_ONCE(!__this_cpu_read(hv_24x7_txn_flags));\r\nreset_txn();\r\n}\r\nstatic int hv_24x7_init(void)\r\n{\r\nint r;\r\nunsigned long hret;\r\nstruct hv_perf_caps caps;\r\nif (!firmware_has_feature(FW_FEATURE_LPAR)) {\r\npr_debug("not a virtualized system, not enabling\n");\r\nreturn -ENODEV;\r\n}\r\nhret = hv_perf_caps_get(&caps);\r\nif (hret) {\r\npr_debug("could not obtain capabilities, not enabling, rc=%ld\n",\r\nhret);\r\nreturn -ENODEV;\r\n}\r\nhv_page_cache = kmem_cache_create("hv-page-4096", 4096, 4096, 0, NULL);\r\nif (!hv_page_cache)\r\nreturn -ENOMEM;\r\nh_24x7_pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;\r\nr = create_events_from_catalog(&event_group.attrs,\r\n&event_desc_group.attrs,\r\n&event_long_desc_group.attrs);\r\nif (r)\r\nreturn r;\r\nr = perf_pmu_register(&h_24x7_pmu, h_24x7_pmu.name, -1);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}
