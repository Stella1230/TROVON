static int __init early_nosmt(char *s)\r\n{\r\nsmp_max_threads = 1;\r\nreturn 0;\r\n}\r\nstatic int __init early_smt(char *s)\r\n{\r\nget_option(&s, &smp_max_threads);\r\nreturn 0;\r\n}\r\nstatic inline int __pcpu_sigp_relax(u16 addr, u8 order, unsigned long parm)\r\n{\r\nint cc;\r\nwhile (1) {\r\ncc = __pcpu_sigp(addr, order, parm, NULL);\r\nif (cc != SIGP_CC_BUSY)\r\nreturn cc;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int pcpu_sigp_retry(struct pcpu *pcpu, u8 order, u32 parm)\r\n{\r\nint cc, retry;\r\nfor (retry = 0; ; retry++) {\r\ncc = __pcpu_sigp(pcpu->address, order, parm, NULL);\r\nif (cc != SIGP_CC_BUSY)\r\nbreak;\r\nif (retry >= 3)\r\nudelay(10);\r\n}\r\nreturn cc;\r\n}\r\nstatic inline int pcpu_stopped(struct pcpu *pcpu)\r\n{\r\nu32 uninitialized_var(status);\r\nif (__pcpu_sigp(pcpu->address, SIGP_SENSE,\r\n0, &status) != SIGP_CC_STATUS_STORED)\r\nreturn 0;\r\nreturn !!(status & (SIGP_STATUS_CHECK_STOP|SIGP_STATUS_STOPPED));\r\n}\r\nstatic inline int pcpu_running(struct pcpu *pcpu)\r\n{\r\nif (__pcpu_sigp(pcpu->address, SIGP_SENSE_RUNNING,\r\n0, NULL) != SIGP_CC_STATUS_STORED)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct pcpu *pcpu_find_address(const struct cpumask *mask, u16 address)\r\n{\r\nint cpu;\r\nfor_each_cpu(cpu, mask)\r\nif (pcpu_devices[cpu].address == address)\r\nreturn pcpu_devices + cpu;\r\nreturn NULL;\r\n}\r\nstatic void pcpu_ec_call(struct pcpu *pcpu, int ec_bit)\r\n{\r\nint order;\r\nif (test_and_set_bit(ec_bit, &pcpu->ec_mask))\r\nreturn;\r\norder = pcpu_running(pcpu) ? SIGP_EXTERNAL_CALL : SIGP_EMERGENCY_SIGNAL;\r\npcpu->ec_clk = get_tod_clock_fast();\r\npcpu_sigp_retry(pcpu, order, 0);\r\n}\r\nstatic int pcpu_alloc_lowcore(struct pcpu *pcpu, int cpu)\r\n{\r\nunsigned long async_stack, panic_stack;\r\nstruct lowcore *lc;\r\nif (pcpu != &pcpu_devices[0]) {\r\npcpu->lowcore = (struct lowcore *)\r\n__get_free_pages(GFP_KERNEL | GFP_DMA, LC_ORDER);\r\nasync_stack = __get_free_pages(GFP_KERNEL, ASYNC_ORDER);\r\npanic_stack = __get_free_page(GFP_KERNEL);\r\nif (!pcpu->lowcore || !panic_stack || !async_stack)\r\ngoto out;\r\n} else {\r\nasync_stack = pcpu->lowcore->async_stack - ASYNC_FRAME_OFFSET;\r\npanic_stack = pcpu->lowcore->panic_stack - PANIC_FRAME_OFFSET;\r\n}\r\nlc = pcpu->lowcore;\r\nmemcpy(lc, &S390_lowcore, 512);\r\nmemset((char *) lc + 512, 0, sizeof(*lc) - 512);\r\nlc->async_stack = async_stack + ASYNC_FRAME_OFFSET;\r\nlc->panic_stack = panic_stack + PANIC_FRAME_OFFSET;\r\nlc->cpu_nr = cpu;\r\nlc->spinlock_lockval = arch_spin_lockval(cpu);\r\nif (MACHINE_HAS_VX)\r\nlc->vector_save_area_addr =\r\n(unsigned long) &lc->vector_save_area;\r\nif (vdso_alloc_per_cpu(lc))\r\ngoto out;\r\nlowcore_ptr[cpu] = lc;\r\npcpu_sigp_retry(pcpu, SIGP_SET_PREFIX, (u32)(unsigned long) lc);\r\nreturn 0;\r\nout:\r\nif (pcpu != &pcpu_devices[0]) {\r\nfree_page(panic_stack);\r\nfree_pages(async_stack, ASYNC_ORDER);\r\nfree_pages((unsigned long) pcpu->lowcore, LC_ORDER);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void pcpu_free_lowcore(struct pcpu *pcpu)\r\n{\r\npcpu_sigp_retry(pcpu, SIGP_SET_PREFIX, 0);\r\nlowcore_ptr[pcpu - pcpu_devices] = NULL;\r\nvdso_free_per_cpu(pcpu->lowcore);\r\nif (pcpu == &pcpu_devices[0])\r\nreturn;\r\nfree_page(pcpu->lowcore->panic_stack-PANIC_FRAME_OFFSET);\r\nfree_pages(pcpu->lowcore->async_stack-ASYNC_FRAME_OFFSET, ASYNC_ORDER);\r\nfree_pages((unsigned long) pcpu->lowcore, LC_ORDER);\r\n}\r\nstatic void pcpu_prepare_secondary(struct pcpu *pcpu, int cpu)\r\n{\r\nstruct lowcore *lc = pcpu->lowcore;\r\ncpumask_set_cpu(cpu, &init_mm.context.cpu_attach_mask);\r\ncpumask_set_cpu(cpu, mm_cpumask(&init_mm));\r\nlc->cpu_nr = cpu;\r\nlc->spinlock_lockval = arch_spin_lockval(cpu);\r\nlc->percpu_offset = __per_cpu_offset[cpu];\r\nlc->kernel_asce = S390_lowcore.kernel_asce;\r\nlc->machine_flags = S390_lowcore.machine_flags;\r\nlc->user_timer = lc->system_timer = lc->steal_timer = 0;\r\n__ctl_store(lc->cregs_save_area, 0, 15);\r\nsave_access_regs((unsigned int *) lc->access_regs_save_area);\r\nmemcpy(lc->stfle_fac_list, S390_lowcore.stfle_fac_list,\r\nMAX_FACILITY_BIT/8);\r\n}\r\nstatic void pcpu_attach_task(struct pcpu *pcpu, struct task_struct *tsk)\r\n{\r\nstruct lowcore *lc = pcpu->lowcore;\r\nstruct thread_info *ti = task_thread_info(tsk);\r\nlc->kernel_stack = (unsigned long) task_stack_page(tsk)\r\n+ THREAD_SIZE - STACK_FRAME_OVERHEAD - sizeof(struct pt_regs);\r\nlc->thread_info = (unsigned long) task_thread_info(tsk);\r\nlc->current_task = (unsigned long) tsk;\r\nlc->lpp = LPP_MAGIC;\r\nlc->current_pid = tsk->pid;\r\nlc->user_timer = ti->user_timer;\r\nlc->system_timer = ti->system_timer;\r\nlc->steal_timer = 0;\r\n}\r\nstatic void pcpu_start_fn(struct pcpu *pcpu, void (*func)(void *), void *data)\r\n{\r\nstruct lowcore *lc = pcpu->lowcore;\r\nlc->restart_stack = lc->kernel_stack;\r\nlc->restart_fn = (unsigned long) func;\r\nlc->restart_data = (unsigned long) data;\r\nlc->restart_source = -1UL;\r\npcpu_sigp_retry(pcpu, SIGP_RESTART, 0);\r\n}\r\nstatic void pcpu_delegate(struct pcpu *pcpu, void (*func)(void *),\r\nvoid *data, unsigned long stack)\r\n{\r\nstruct lowcore *lc = lowcore_ptr[pcpu - pcpu_devices];\r\nunsigned long source_cpu = stap();\r\n__load_psw_mask(PSW_KERNEL_BITS);\r\nif (pcpu->address == source_cpu)\r\nfunc(data);\r\npcpu_sigp_retry(pcpu, SIGP_STOP, 0);\r\nmem_assign_absolute(lc->restart_stack, stack);\r\nmem_assign_absolute(lc->restart_fn, (unsigned long) func);\r\nmem_assign_absolute(lc->restart_data, (unsigned long) data);\r\nmem_assign_absolute(lc->restart_source, source_cpu);\r\nasm volatile(\r\n"0: sigp 0,%0,%2 # sigp restart to target cpu\n"\r\n" brc 2,0b # busy, try again\n"\r\n"1: sigp 0,%1,%3 # sigp stop to current cpu\n"\r\n" brc 2,1b # busy, try again\n"\r\n: : "d" (pcpu->address), "d" (source_cpu),\r\n"K" (SIGP_RESTART), "K" (SIGP_STOP)\r\n: "0", "1", "cc");\r\nfor (;;) ;\r\n}\r\nstatic int pcpu_set_smt(unsigned int mtid)\r\n{\r\nint cc;\r\nif (smp_cpu_mtid == mtid)\r\nreturn 0;\r\ncc = __pcpu_sigp(0, SIGP_SET_MULTI_THREADING, mtid, NULL);\r\nif (cc == 0) {\r\nsmp_cpu_mtid = mtid;\r\nsmp_cpu_mt_shift = 0;\r\nwhile (smp_cpu_mtid >= (1U << smp_cpu_mt_shift))\r\nsmp_cpu_mt_shift++;\r\npcpu_devices[0].address = stap();\r\n}\r\nreturn cc;\r\n}\r\nvoid smp_call_online_cpu(void (*func)(void *), void *data)\r\n{\r\nstruct pcpu *pcpu;\r\npcpu = pcpu_find_address(cpu_online_mask, stap());\r\nif (!pcpu)\r\npcpu = pcpu_devices + cpumask_first(cpu_online_mask);\r\npcpu_delegate(pcpu, func, data, (unsigned long) restart_stack);\r\n}\r\nvoid smp_call_ipl_cpu(void (*func)(void *), void *data)\r\n{\r\npcpu_delegate(&pcpu_devices[0], func, data,\r\npcpu_devices->lowcore->panic_stack -\r\nPANIC_FRAME_OFFSET + PAGE_SIZE);\r\n}\r\nint smp_find_processor_id(u16 address)\r\n{\r\nint cpu;\r\nfor_each_present_cpu(cpu)\r\nif (pcpu_devices[cpu].address == address)\r\nreturn cpu;\r\nreturn -1;\r\n}\r\nint smp_vcpu_scheduled(int cpu)\r\n{\r\nreturn pcpu_running(pcpu_devices + cpu);\r\n}\r\nvoid smp_yield_cpu(int cpu)\r\n{\r\nif (MACHINE_HAS_DIAG9C) {\r\ndiag_stat_inc_norecursion(DIAG_STAT_X09C);\r\nasm volatile("diag %0,0,0x9c"\r\n: : "d" (pcpu_devices[cpu].address));\r\n} else if (MACHINE_HAS_DIAG44) {\r\ndiag_stat_inc_norecursion(DIAG_STAT_X044);\r\nasm volatile("diag 0,0,0x44");\r\n}\r\n}\r\nstatic void smp_emergency_stop(cpumask_t *cpumask)\r\n{\r\nu64 end;\r\nint cpu;\r\nend = get_tod_clock() + (1000000UL << 12);\r\nfor_each_cpu(cpu, cpumask) {\r\nstruct pcpu *pcpu = pcpu_devices + cpu;\r\nset_bit(ec_stop_cpu, &pcpu->ec_mask);\r\nwhile (__pcpu_sigp(pcpu->address, SIGP_EMERGENCY_SIGNAL,\r\n0, NULL) == SIGP_CC_BUSY &&\r\nget_tod_clock() < end)\r\ncpu_relax();\r\n}\r\nwhile (get_tod_clock() < end) {\r\nfor_each_cpu(cpu, cpumask)\r\nif (pcpu_stopped(pcpu_devices + cpu))\r\ncpumask_clear_cpu(cpu, cpumask);\r\nif (cpumask_empty(cpumask))\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nvoid smp_send_stop(void)\r\n{\r\ncpumask_t cpumask;\r\nint cpu;\r\n__load_psw_mask(PSW_KERNEL_BITS | PSW_MASK_DAT);\r\ntrace_hardirqs_off();\r\ndebug_set_critical();\r\ncpumask_copy(&cpumask, cpu_online_mask);\r\ncpumask_clear_cpu(smp_processor_id(), &cpumask);\r\nif (oops_in_progress)\r\nsmp_emergency_stop(&cpumask);\r\nfor_each_cpu(cpu, &cpumask) {\r\nstruct pcpu *pcpu = pcpu_devices + cpu;\r\npcpu_sigp_retry(pcpu, SIGP_STOP, 0);\r\nwhile (!pcpu_stopped(pcpu))\r\ncpu_relax();\r\n}\r\n}\r\nstatic void smp_handle_ext_call(void)\r\n{\r\nunsigned long bits;\r\nbits = xchg(&pcpu_devices[smp_processor_id()].ec_mask, 0);\r\nif (test_bit(ec_stop_cpu, &bits))\r\nsmp_stop_cpu();\r\nif (test_bit(ec_schedule, &bits))\r\nscheduler_ipi();\r\nif (test_bit(ec_call_function_single, &bits))\r\ngeneric_smp_call_function_single_interrupt();\r\n}\r\nstatic void do_ext_call_interrupt(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\ninc_irq_stat(ext_code.code == 0x1202 ? IRQEXT_EXC : IRQEXT_EMS);\r\nsmp_handle_ext_call();\r\n}\r\nvoid arch_send_call_function_ipi_mask(const struct cpumask *mask)\r\n{\r\nint cpu;\r\nfor_each_cpu(cpu, mask)\r\npcpu_ec_call(pcpu_devices + cpu, ec_call_function_single);\r\n}\r\nvoid arch_send_call_function_single_ipi(int cpu)\r\n{\r\npcpu_ec_call(pcpu_devices + cpu, ec_call_function_single);\r\n}\r\nvoid smp_send_reschedule(int cpu)\r\n{\r\npcpu_ec_call(pcpu_devices + cpu, ec_schedule);\r\n}\r\nstatic void smp_ctl_bit_callback(void *info)\r\n{\r\nstruct ec_creg_mask_parms *pp = info;\r\nunsigned long cregs[16];\r\n__ctl_store(cregs, 0, 15);\r\ncregs[pp->cr] = (cregs[pp->cr] & pp->andval) | pp->orval;\r\n__ctl_load(cregs, 0, 15);\r\n}\r\nvoid smp_ctl_set_bit(int cr, int bit)\r\n{\r\nstruct ec_creg_mask_parms parms = { 1UL << bit, -1UL, cr };\r\non_each_cpu(smp_ctl_bit_callback, &parms, 1);\r\n}\r\nvoid smp_ctl_clear_bit(int cr, int bit)\r\n{\r\nstruct ec_creg_mask_parms parms = { 0, ~(1UL << bit), cr };\r\non_each_cpu(smp_ctl_bit_callback, &parms, 1);\r\n}\r\nint smp_store_status(int cpu)\r\n{\r\nstruct pcpu *pcpu = pcpu_devices + cpu;\r\nunsigned long pa;\r\npa = __pa(&pcpu->lowcore->floating_pt_save_area);\r\nif (__pcpu_sigp_relax(pcpu->address, SIGP_STORE_STATUS_AT_ADDRESS,\r\npa) != SIGP_CC_ORDER_CODE_ACCEPTED)\r\nreturn -EIO;\r\nif (!MACHINE_HAS_VX)\r\nreturn 0;\r\npa = __pa(pcpu->lowcore->vector_save_area_addr);\r\nif (__pcpu_sigp_relax(pcpu->address, SIGP_STORE_ADDITIONAL_STATUS,\r\npa) != SIGP_CC_ORDER_CODE_ACCEPTED)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic __init void smp_save_cpu_vxrs(struct save_area *sa, u16 addr,\r\nbool is_boot_cpu, unsigned long page)\r\n{\r\n__vector128 *vxrs = (__vector128 *) page;\r\nif (is_boot_cpu)\r\nvxrs = boot_cpu_vector_save_area;\r\nelse\r\n__pcpu_sigp_relax(addr, SIGP_STORE_ADDITIONAL_STATUS, page);\r\nsave_area_add_vxrs(sa, vxrs);\r\n}\r\nstatic __init void smp_save_cpu_regs(struct save_area *sa, u16 addr,\r\nbool is_boot_cpu, unsigned long page)\r\n{\r\nvoid *regs = (void *) page;\r\nif (is_boot_cpu)\r\ncopy_oldmem_kernel(regs, (void *) __LC_FPREGS_SAVE_AREA, 512);\r\nelse\r\n__pcpu_sigp_relax(addr, SIGP_STORE_STATUS_AT_ADDRESS, page);\r\nsave_area_add_regs(sa, regs);\r\n}\r\nvoid __init smp_save_dump_cpus(void)\r\n{\r\nint addr, boot_cpu_addr, max_cpu_addr;\r\nstruct save_area *sa;\r\nunsigned long page;\r\nbool is_boot_cpu;\r\nif (!(OLDMEM_BASE || ipl_info.type == IPL_TYPE_FCP_DUMP))\r\nreturn;\r\npage = memblock_alloc_base(PAGE_SIZE, PAGE_SIZE, 1UL << 31);\r\npcpu_set_smt(sclp.mtid_prev);\r\nboot_cpu_addr = stap();\r\nmax_cpu_addr = SCLP_MAX_CORES << sclp.mtid_prev;\r\nfor (addr = 0; addr <= max_cpu_addr; addr++) {\r\nif (__pcpu_sigp_relax(addr, SIGP_SENSE, 0) ==\r\nSIGP_CC_NOT_OPERATIONAL)\r\ncontinue;\r\nis_boot_cpu = (addr == boot_cpu_addr);\r\nsa = save_area_alloc(is_boot_cpu);\r\nif (!sa)\r\npanic("could not allocate memory for save area\n");\r\nif (MACHINE_HAS_VX)\r\nsmp_save_cpu_vxrs(sa, addr, is_boot_cpu, page);\r\nif (!is_boot_cpu || OLDMEM_BASE)\r\nsmp_save_cpu_regs(sa, addr, is_boot_cpu, page);\r\n}\r\nmemblock_free(page, PAGE_SIZE);\r\ndiag308_reset();\r\npcpu_set_smt(0);\r\n}\r\nvoid smp_cpu_set_polarization(int cpu, int val)\r\n{\r\npcpu_devices[cpu].polarization = val;\r\n}\r\nint smp_cpu_get_polarization(int cpu)\r\n{\r\nreturn pcpu_devices[cpu].polarization;\r\n}\r\nstatic struct sclp_core_info *smp_get_core_info(void)\r\n{\r\nstatic int use_sigp_detection;\r\nstruct sclp_core_info *info;\r\nint address;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info && (use_sigp_detection || sclp_get_core_info(info))) {\r\nuse_sigp_detection = 1;\r\nfor (address = 0;\r\naddress < (SCLP_MAX_CORES << smp_cpu_mt_shift);\r\naddress += (1U << smp_cpu_mt_shift)) {\r\nif (__pcpu_sigp_relax(address, SIGP_SENSE, 0) ==\r\nSIGP_CC_NOT_OPERATIONAL)\r\ncontinue;\r\ninfo->core[info->configured].core_id =\r\naddress >> smp_cpu_mt_shift;\r\ninfo->configured++;\r\n}\r\ninfo->combined = info->configured;\r\n}\r\nreturn info;\r\n}\r\nstatic int __smp_rescan_cpus(struct sclp_core_info *info, int sysfs_add)\r\n{\r\nstruct pcpu *pcpu;\r\ncpumask_t avail;\r\nint cpu, nr, i, j;\r\nu16 address;\r\nnr = 0;\r\ncpumask_xor(&avail, cpu_possible_mask, cpu_present_mask);\r\ncpu = cpumask_first(&avail);\r\nfor (i = 0; (i < info->combined) && (cpu < nr_cpu_ids); i++) {\r\nif (sclp.has_core_type && info->core[i].type != boot_core_type)\r\ncontinue;\r\naddress = info->core[i].core_id << smp_cpu_mt_shift;\r\nfor (j = 0; j <= smp_cpu_mtid; j++) {\r\nif (pcpu_find_address(cpu_present_mask, address + j))\r\ncontinue;\r\npcpu = pcpu_devices + cpu;\r\npcpu->address = address + j;\r\npcpu->state =\r\n(cpu >= info->configured*(smp_cpu_mtid + 1)) ?\r\nCPU_STATE_STANDBY : CPU_STATE_CONFIGURED;\r\nsmp_cpu_set_polarization(cpu, POLARIZATION_UNKNOWN);\r\nset_cpu_present(cpu, true);\r\nif (sysfs_add && smp_add_present_cpu(cpu) != 0)\r\nset_cpu_present(cpu, false);\r\nelse\r\nnr++;\r\ncpu = cpumask_next(cpu, &avail);\r\nif (cpu >= nr_cpu_ids)\r\nbreak;\r\n}\r\n}\r\nreturn nr;\r\n}\r\nstatic void __init smp_detect_cpus(void)\r\n{\r\nunsigned int cpu, mtid, c_cpus, s_cpus;\r\nstruct sclp_core_info *info;\r\nu16 address;\r\ninfo = smp_get_core_info();\r\nif (!info)\r\npanic("smp_detect_cpus failed to allocate memory\n");\r\nif (sclp.has_core_type) {\r\naddress = stap();\r\nfor (cpu = 0; cpu < info->combined; cpu++)\r\nif (info->core[cpu].core_id == address) {\r\nboot_core_type = info->core[cpu].type;\r\nbreak;\r\n}\r\nif (cpu >= info->combined)\r\npanic("Could not find boot CPU type");\r\n}\r\nmtid = boot_core_type ? sclp.mtid : sclp.mtid_cp;\r\nmtid = (mtid < smp_max_threads) ? mtid : smp_max_threads - 1;\r\npcpu_set_smt(mtid);\r\nc_cpus = s_cpus = 0;\r\nfor (cpu = 0; cpu < info->combined; cpu++) {\r\nif (sclp.has_core_type &&\r\ninfo->core[cpu].type != boot_core_type)\r\ncontinue;\r\nif (cpu < info->configured)\r\nc_cpus += smp_cpu_mtid + 1;\r\nelse\r\ns_cpus += smp_cpu_mtid + 1;\r\n}\r\npr_info("%d configured CPUs, %d standby CPUs\n", c_cpus, s_cpus);\r\nget_online_cpus();\r\n__smp_rescan_cpus(info, 0);\r\nput_online_cpus();\r\nkfree(info);\r\n}\r\nstatic void smp_start_secondary(void *cpuvoid)\r\n{\r\nS390_lowcore.last_update_clock = get_tod_clock();\r\nS390_lowcore.restart_stack = (unsigned long) restart_stack;\r\nS390_lowcore.restart_fn = (unsigned long) do_restart;\r\nS390_lowcore.restart_data = 0;\r\nS390_lowcore.restart_source = -1UL;\r\nrestore_access_regs(S390_lowcore.access_regs_save_area);\r\n__ctl_load(S390_lowcore.cregs_save_area, 0, 15);\r\n__load_psw_mask(PSW_KERNEL_BITS | PSW_MASK_DAT);\r\ncpu_init();\r\npreempt_disable();\r\ninit_cpu_timer();\r\nvtime_init();\r\npfault_init();\r\nnotify_cpu_starting(smp_processor_id());\r\nset_cpu_online(smp_processor_id(), true);\r\ninc_irq_stat(CPU_RST);\r\nlocal_irq_enable();\r\ncpu_startup_entry(CPUHP_AP_ONLINE_IDLE);\r\n}\r\nint __cpu_up(unsigned int cpu, struct task_struct *tidle)\r\n{\r\nstruct pcpu *pcpu;\r\nint base, i, rc;\r\npcpu = pcpu_devices + cpu;\r\nif (pcpu->state != CPU_STATE_CONFIGURED)\r\nreturn -EIO;\r\nbase = cpu - (cpu % (smp_cpu_mtid + 1));\r\nfor (i = 0; i <= smp_cpu_mtid; i++) {\r\nif (base + i < nr_cpu_ids)\r\nif (cpu_online(base + i))\r\nbreak;\r\n}\r\nif (i > smp_cpu_mtid &&\r\npcpu_sigp_retry(pcpu_devices + base, SIGP_INITIAL_CPU_RESET, 0) !=\r\nSIGP_CC_ORDER_CODE_ACCEPTED)\r\nreturn -EIO;\r\nrc = pcpu_alloc_lowcore(pcpu, cpu);\r\nif (rc)\r\nreturn rc;\r\npcpu_prepare_secondary(pcpu, cpu);\r\npcpu_attach_task(pcpu, tidle);\r\npcpu_start_fn(pcpu, smp_start_secondary, NULL);\r\nwhile (!cpu_online(cpu))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int __init _setup_possible_cpus(char *s)\r\n{\r\nget_option(&s, &setup_possible_cpus);\r\nreturn 0;\r\n}\r\nint __cpu_disable(void)\r\n{\r\nunsigned long cregs[16];\r\nsmp_handle_ext_call();\r\nset_cpu_online(smp_processor_id(), false);\r\npfault_fini();\r\n__ctl_store(cregs, 0, 15);\r\ncregs[0] &= ~0x0000ee70UL;\r\ncregs[6] &= ~0xff000000UL;\r\ncregs[14] &= ~0x1f000000UL;\r\n__ctl_load(cregs, 0, 15);\r\nclear_cpu_flag(CIF_NOHZ_DELAY);\r\nreturn 0;\r\n}\r\nvoid __cpu_die(unsigned int cpu)\r\n{\r\nstruct pcpu *pcpu;\r\npcpu = pcpu_devices + cpu;\r\nwhile (!pcpu_stopped(pcpu))\r\ncpu_relax();\r\npcpu_free_lowcore(pcpu);\r\ncpumask_clear_cpu(cpu, mm_cpumask(&init_mm));\r\ncpumask_clear_cpu(cpu, &init_mm.context.cpu_attach_mask);\r\n}\r\nvoid __noreturn cpu_die(void)\r\n{\r\nidle_task_exit();\r\npcpu_sigp_retry(pcpu_devices + smp_processor_id(), SIGP_STOP, 0);\r\nfor (;;) ;\r\n}\r\nvoid __init smp_fill_possible_mask(void)\r\n{\r\nunsigned int possible, sclp_max, cpu;\r\nsclp_max = max(sclp.mtid, sclp.mtid_cp) + 1;\r\nsclp_max = min(smp_max_threads, sclp_max);\r\nsclp_max = (sclp.max_cores * sclp_max) ?: nr_cpu_ids;\r\npossible = setup_possible_cpus ?: nr_cpu_ids;\r\npossible = min(possible, sclp_max);\r\nfor (cpu = 0; cpu < possible && cpu < nr_cpu_ids; cpu++)\r\nset_cpu_possible(cpu, true);\r\n}\r\nvoid __init smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nif (register_external_irq(EXT_IRQ_EMERGENCY_SIG, do_ext_call_interrupt))\r\npanic("Couldn't request external interrupt 0x1201");\r\nif (register_external_irq(EXT_IRQ_EXTERNAL_CALL, do_ext_call_interrupt))\r\npanic("Couldn't request external interrupt 0x1202");\r\nsmp_detect_cpus();\r\n}\r\nvoid __init smp_prepare_boot_cpu(void)\r\n{\r\nstruct pcpu *pcpu = pcpu_devices;\r\npcpu->state = CPU_STATE_CONFIGURED;\r\npcpu->address = stap();\r\npcpu->lowcore = (struct lowcore *)(unsigned long) store_prefix();\r\nS390_lowcore.percpu_offset = __per_cpu_offset[0];\r\nsmp_cpu_set_polarization(0, POLARIZATION_UNKNOWN);\r\nset_cpu_present(0, true);\r\nset_cpu_online(0, true);\r\n}\r\nvoid __init smp_cpus_done(unsigned int max_cpus)\r\n{\r\n}\r\nvoid __init smp_setup_processor_id(void)\r\n{\r\nS390_lowcore.cpu_nr = 0;\r\nS390_lowcore.spinlock_lockval = arch_spin_lockval(0);\r\n}\r\nint setup_profiling_timer(unsigned int multiplier)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t cpu_configure_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t count;\r\nmutex_lock(&smp_cpu_state_mutex);\r\ncount = sprintf(buf, "%d\n", pcpu_devices[dev->id].state);\r\nmutex_unlock(&smp_cpu_state_mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t cpu_configure_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcpu *pcpu;\r\nint cpu, val, rc, i;\r\nchar delim;\r\nif (sscanf(buf, "%d %c", &val, &delim) != 1)\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nget_online_cpus();\r\nmutex_lock(&smp_cpu_state_mutex);\r\nrc = -EBUSY;\r\ncpu = dev->id;\r\ncpu -= cpu % (smp_cpu_mtid + 1);\r\nif (cpu == 0)\r\ngoto out;\r\nfor (i = 0; i <= smp_cpu_mtid; i++)\r\nif (cpu_online(cpu + i))\r\ngoto out;\r\npcpu = pcpu_devices + cpu;\r\nrc = 0;\r\nswitch (val) {\r\ncase 0:\r\nif (pcpu->state != CPU_STATE_CONFIGURED)\r\nbreak;\r\nrc = sclp_core_deconfigure(pcpu->address >> smp_cpu_mt_shift);\r\nif (rc)\r\nbreak;\r\nfor (i = 0; i <= smp_cpu_mtid; i++) {\r\nif (cpu + i >= nr_cpu_ids || !cpu_present(cpu + i))\r\ncontinue;\r\npcpu[i].state = CPU_STATE_STANDBY;\r\nsmp_cpu_set_polarization(cpu + i,\r\nPOLARIZATION_UNKNOWN);\r\n}\r\ntopology_expect_change();\r\nbreak;\r\ncase 1:\r\nif (pcpu->state != CPU_STATE_STANDBY)\r\nbreak;\r\nrc = sclp_core_configure(pcpu->address >> smp_cpu_mt_shift);\r\nif (rc)\r\nbreak;\r\nfor (i = 0; i <= smp_cpu_mtid; i++) {\r\nif (cpu + i >= nr_cpu_ids || !cpu_present(cpu + i))\r\ncontinue;\r\npcpu[i].state = CPU_STATE_CONFIGURED;\r\nsmp_cpu_set_polarization(cpu + i,\r\nPOLARIZATION_UNKNOWN);\r\n}\r\ntopology_expect_change();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&smp_cpu_state_mutex);\r\nput_online_cpus();\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t show_cpu_address(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", pcpu_devices[dev->id].address);\r\n}\r\nstatic int smp_cpu_notify(struct notifier_block *self, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int cpu = (unsigned int)(long)hcpu;\r\nstruct device *s = &per_cpu(cpu_device, cpu)->dev;\r\nint err = 0;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\nerr = sysfs_create_group(&s->kobj, &cpu_online_attr_group);\r\nbreak;\r\ncase CPU_DEAD:\r\nsysfs_remove_group(&s->kobj, &cpu_online_attr_group);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int smp_add_present_cpu(int cpu)\r\n{\r\nstruct device *s;\r\nstruct cpu *c;\r\nint rc;\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\nper_cpu(cpu_device, cpu) = c;\r\ns = &c->dev;\r\nc->hotpluggable = 1;\r\nrc = register_cpu(c, cpu);\r\nif (rc)\r\ngoto out;\r\nrc = sysfs_create_group(&s->kobj, &cpu_common_attr_group);\r\nif (rc)\r\ngoto out_cpu;\r\nif (cpu_online(cpu)) {\r\nrc = sysfs_create_group(&s->kobj, &cpu_online_attr_group);\r\nif (rc)\r\ngoto out_online;\r\n}\r\nrc = topology_cpu_init(c);\r\nif (rc)\r\ngoto out_topology;\r\nreturn 0;\r\nout_topology:\r\nif (cpu_online(cpu))\r\nsysfs_remove_group(&s->kobj, &cpu_online_attr_group);\r\nout_online:\r\nsysfs_remove_group(&s->kobj, &cpu_common_attr_group);\r\nout_cpu:\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nunregister_cpu(c);\r\n#endif\r\nout:\r\nreturn rc;\r\n}\r\nint __ref smp_rescan_cpus(void)\r\n{\r\nstruct sclp_core_info *info;\r\nint nr;\r\ninfo = smp_get_core_info();\r\nif (!info)\r\nreturn -ENOMEM;\r\nget_online_cpus();\r\nmutex_lock(&smp_cpu_state_mutex);\r\nnr = __smp_rescan_cpus(info, 1);\r\nmutex_unlock(&smp_cpu_state_mutex);\r\nput_online_cpus();\r\nkfree(info);\r\nif (nr)\r\ntopology_schedule_update();\r\nreturn 0;\r\n}\r\nstatic ssize_t __ref rescan_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint rc;\r\nrc = smp_rescan_cpus();\r\nreturn rc ? rc : count;\r\n}\r\nstatic int __init s390_smp_init(void)\r\n{\r\nint cpu, rc = 0;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nrc = device_create_file(cpu_subsys.dev_root, &dev_attr_rescan);\r\nif (rc)\r\nreturn rc;\r\n#endif\r\ncpu_notifier_register_begin();\r\nfor_each_present_cpu(cpu) {\r\nrc = smp_add_present_cpu(cpu);\r\nif (rc)\r\ngoto out;\r\n}\r\n__hotcpu_notifier(smp_cpu_notify, 0);\r\nout:\r\ncpu_notifier_register_done();\r\nreturn rc;\r\n}
