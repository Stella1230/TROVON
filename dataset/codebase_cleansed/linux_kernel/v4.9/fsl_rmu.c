static irqreturn_t\r\nfsl_rio_tx_handler(int irq, void *dev_instance)\r\n{\r\nint osr;\r\nstruct rio_mport *port = (struct rio_mport *)dev_instance;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(port);\r\nosr = in_be32(&rmu->msg_regs->osr);\r\nif (osr & RIO_MSG_OSR_TE) {\r\npr_info("RIO: outbound message transmission error\n");\r\nout_be32(&rmu->msg_regs->osr, RIO_MSG_OSR_TE);\r\ngoto out;\r\n}\r\nif (osr & RIO_MSG_OSR_QOI) {\r\npr_info("RIO: outbound message queue overflow\n");\r\nout_be32(&rmu->msg_regs->osr, RIO_MSG_OSR_QOI);\r\ngoto out;\r\n}\r\nif (osr & RIO_MSG_OSR_EOMI) {\r\nu32 dqp = in_be32(&rmu->msg_regs->odqdpar);\r\nint slot = (dqp - rmu->msg_tx_ring.phys) >> 5;\r\nif (port->outb_msg[0].mcback != NULL) {\r\nport->outb_msg[0].mcback(port, rmu->msg_tx_ring.dev_id,\r\n-1,\r\nslot);\r\n}\r\nout_be32(&rmu->msg_regs->osr, RIO_MSG_OSR_EOMI);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nfsl_rio_rx_handler(int irq, void *dev_instance)\r\n{\r\nint isr;\r\nstruct rio_mport *port = (struct rio_mport *)dev_instance;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(port);\r\nisr = in_be32(&rmu->msg_regs->isr);\r\nif (isr & RIO_MSG_ISR_TE) {\r\npr_info("RIO: inbound message reception error\n");\r\nout_be32((void *)&rmu->msg_regs->isr, RIO_MSG_ISR_TE);\r\ngoto out;\r\n}\r\nif (isr & RIO_MSG_ISR_DIQI) {\r\nif (port->inb_msg[0].mcback != NULL)\r\nport->inb_msg[0].mcback(port, rmu->msg_rx_ring.dev_id,\r\n-1,\r\n-1);\r\nout_be32(&rmu->msg_regs->isr, RIO_MSG_ISR_DIQI);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nfsl_rio_dbell_handler(int irq, void *dev_instance)\r\n{\r\nint dsr;\r\nstruct fsl_rio_dbell *fsl_dbell = (struct fsl_rio_dbell *)dev_instance;\r\nint i;\r\ndsr = in_be32(&fsl_dbell->dbell_regs->dsr);\r\nif (dsr & DOORBELL_DSR_TE) {\r\npr_info("RIO: doorbell reception error\n");\r\nout_be32(&fsl_dbell->dbell_regs->dsr, DOORBELL_DSR_TE);\r\ngoto out;\r\n}\r\nif (dsr & DOORBELL_DSR_QFI) {\r\npr_info("RIO: doorbell queue full\n");\r\nout_be32(&fsl_dbell->dbell_regs->dsr, DOORBELL_DSR_QFI);\r\n}\r\nif (dsr & DOORBELL_DSR_DIQI) {\r\nstruct rio_dbell_msg *dmsg =\r\nfsl_dbell->dbell_ring.virt +\r\n(in_be32(&fsl_dbell->dbell_regs->dqdpar) & 0xfff);\r\nstruct rio_dbell *dbell;\r\nint found = 0;\r\npr_debug\r\n("RIO: processing doorbell,"\r\n" sid %2.2x tid %2.2x info %4.4x\n",\r\ndmsg->sid, dmsg->tid, dmsg->info);\r\nfor (i = 0; i < MAX_PORT_NUM; i++) {\r\nif (fsl_dbell->mport[i]) {\r\nlist_for_each_entry(dbell,\r\n&fsl_dbell->mport[i]->dbells, node) {\r\nif ((dbell->res->start\r\n<= dmsg->info)\r\n&& (dbell->res->end\r\n>= dmsg->info)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found && dbell->dinb) {\r\ndbell->dinb(fsl_dbell->mport[i],\r\ndbell->dev_id, dmsg->sid,\r\ndmsg->tid,\r\ndmsg->info);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!found) {\r\npr_debug\r\n("RIO: spurious doorbell,"\r\n" sid %2.2x tid %2.2x info %4.4x\n",\r\ndmsg->sid, dmsg->tid,\r\ndmsg->info);\r\n}\r\nsetbits32(&fsl_dbell->dbell_regs->dmr, DOORBELL_DMR_DI);\r\nout_be32(&fsl_dbell->dbell_regs->dsr, DOORBELL_DSR_DIQI);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid msg_unit_error_handler(void)\r\n{\r\nout_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR), 0);\r\nout_be32((u32 *)(rmu_regs_win + RIO_IM0SR), IMSR_CLEAR);\r\nout_be32((u32 *)(rmu_regs_win + RIO_IM1SR), IMSR_CLEAR);\r\nout_be32((u32 *)(rmu_regs_win + RIO_OM0SR), OMSR_CLEAR);\r\nout_be32((u32 *)(rmu_regs_win + RIO_OM1SR), OMSR_CLEAR);\r\nout_be32(&dbell->dbell_regs->odsr, ODSR_CLEAR);\r\nout_be32(&dbell->dbell_regs->dsr, IDSR_CLEAR);\r\nout_be32(&pw->pw_regs->pwsr, IPWSR_CLEAR);\r\n}\r\nstatic irqreturn_t\r\nfsl_rio_port_write_handler(int irq, void *dev_instance)\r\n{\r\nu32 ipwmr, ipwsr;\r\nstruct fsl_rio_pw *pw = (struct fsl_rio_pw *)dev_instance;\r\nu32 epwisr, tmp;\r\nepwisr = in_be32(rio_regs_win + RIO_EPWISR);\r\nif (!(epwisr & RIO_EPWISR_PW))\r\ngoto pw_done;\r\nipwmr = in_be32(&pw->pw_regs->pwmr);\r\nipwsr = in_be32(&pw->pw_regs->pwsr);\r\n#ifdef DEBUG_PW\r\npr_debug("PW Int->IPWMR: 0x%08x IPWSR: 0x%08x (", ipwmr, ipwsr);\r\nif (ipwsr & RIO_IPWSR_QF)\r\npr_debug(" QF");\r\nif (ipwsr & RIO_IPWSR_TE)\r\npr_debug(" TE");\r\nif (ipwsr & RIO_IPWSR_QFI)\r\npr_debug(" QFI");\r\nif (ipwsr & RIO_IPWSR_PWD)\r\npr_debug(" PWD");\r\nif (ipwsr & RIO_IPWSR_PWB)\r\npr_debug(" PWB");\r\npr_debug(" )\n");\r\n#endif\r\nif (ipwsr & RIO_IPWSR_QFI) {\r\nif (kfifo_avail(&pw->pw_fifo) >= RIO_PW_MSG_SIZE) {\r\npw->port_write_msg.msg_count++;\r\nkfifo_in(&pw->pw_fifo, pw->port_write_msg.virt,\r\nRIO_PW_MSG_SIZE);\r\n} else {\r\npw->port_write_msg.discard_count++;\r\npr_debug("RIO: ISR Discarded Port-Write Msg(s) (%d)\n",\r\npw->port_write_msg.discard_count);\r\n}\r\nout_be32(&pw->pw_regs->pwsr, RIO_IPWSR_QFI);\r\nout_be32(&pw->pw_regs->pwmr, ipwmr | RIO_IPWMR_CQ);\r\nschedule_work(&pw->pw_work);\r\n}\r\nif ((ipwmr & RIO_IPWMR_EIE) && (ipwsr & RIO_IPWSR_TE)) {\r\npw->port_write_msg.err_count++;\r\npr_debug("RIO: Port-Write Transaction Err (%d)\n",\r\npw->port_write_msg.err_count);\r\nout_be32(&pw->pw_regs->pwmr, ipwmr & ~RIO_IPWMR_PWE);\r\nout_be32(&pw->pw_regs->pwsr, RIO_IPWSR_TE);\r\nout_be32(&pw->pw_regs->pwmr, ipwmr);\r\n}\r\nif (ipwsr & RIO_IPWSR_PWD) {\r\npw->port_write_msg.discard_count++;\r\npr_debug("RIO: Port Discarded Port-Write Msg(s) (%d)\n",\r\npw->port_write_msg.discard_count);\r\nout_be32(&pw->pw_regs->pwsr, RIO_IPWSR_PWD);\r\n}\r\npw_done:\r\nif (epwisr & RIO_EPWISR_PINT1) {\r\ntmp = in_be32(rio_regs_win + RIO_LTLEDCSR);\r\npr_debug("RIO_LTLEDCSR = 0x%x\n", tmp);\r\nfsl_rio_port_error_handler(0);\r\n}\r\nif (epwisr & RIO_EPWISR_PINT2) {\r\ntmp = in_be32(rio_regs_win + RIO_LTLEDCSR);\r\npr_debug("RIO_LTLEDCSR = 0x%x\n", tmp);\r\nfsl_rio_port_error_handler(1);\r\n}\r\nif (epwisr & RIO_EPWISR_MU) {\r\ntmp = in_be32(rio_regs_win + RIO_LTLEDCSR);\r\npr_debug("RIO_LTLEDCSR = 0x%x\n", tmp);\r\nmsg_unit_error_handler();\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fsl_pw_dpc(struct work_struct *work)\r\n{\r\nstruct fsl_rio_pw *pw = container_of(work, struct fsl_rio_pw, pw_work);\r\nunion rio_pw_msg msg_buffer;\r\nint i;\r\nwhile (kfifo_out_spinlocked(&pw->pw_fifo, (unsigned char *)&msg_buffer,\r\nRIO_PW_MSG_SIZE, &pw->pw_fifo_lock)) {\r\n#ifdef DEBUG_PW\r\n{\r\nu32 i;\r\npr_debug("%s : Port-Write Message:", __func__);\r\nfor (i = 0; i < RIO_PW_MSG_SIZE/sizeof(u32); i++) {\r\nif ((i%4) == 0)\r\npr_debug("\n0x%02x: 0x%08x", i*4,\r\nmsg_buffer.raw[i]);\r\nelse\r\npr_debug(" 0x%08x", msg_buffer.raw[i]);\r\n}\r\npr_debug("\n");\r\n}\r\n#endif\r\nfor (i = 0; i < MAX_PORT_NUM; i++) {\r\nif (pw->mport[i])\r\nrio_inb_pwrite_handler(pw->mport[i],\r\n&msg_buffer);\r\n}\r\n}\r\n}\r\nint fsl_rio_pw_enable(struct rio_mport *mport, int enable)\r\n{\r\nu32 rval;\r\nrval = in_be32(&pw->pw_regs->pwmr);\r\nif (enable)\r\nrval |= RIO_IPWMR_PWE;\r\nelse\r\nrval &= ~RIO_IPWMR_PWE;\r\nout_be32(&pw->pw_regs->pwmr, rval);\r\nreturn 0;\r\n}\r\nint fsl_rio_port_write_init(struct fsl_rio_pw *pw)\r\n{\r\nint rc = 0;\r\nout_be32(&pw->pw_regs->pwmr,\r\nin_be32(&pw->pw_regs->pwmr) & ~RIO_IPWMR_PWE);\r\npw->port_write_msg.virt = dma_alloc_coherent(pw->dev,\r\nRIO_PW_MSG_SIZE,\r\n&pw->port_write_msg.phys, GFP_KERNEL);\r\nif (!pw->port_write_msg.virt) {\r\npr_err("RIO: unable allocate port write queue\n");\r\nreturn -ENOMEM;\r\n}\r\npw->port_write_msg.err_count = 0;\r\npw->port_write_msg.discard_count = 0;\r\nout_be32(&pw->pw_regs->epwqbar, 0);\r\nout_be32(&pw->pw_regs->pwqbar, (u32) pw->port_write_msg.phys);\r\npr_debug("EIPWQBAR: 0x%08x IPWQBAR: 0x%08x\n",\r\nin_be32(&pw->pw_regs->epwqbar),\r\nin_be32(&pw->pw_regs->pwqbar));\r\nout_be32(&pw->pw_regs->pwsr,\r\n(RIO_IPWSR_TE | RIO_IPWSR_QFI | RIO_IPWSR_PWD));\r\nout_be32(&pw->pw_regs->pwmr,\r\nRIO_IPWMR_SEN | RIO_IPWMR_QFIE | RIO_IPWMR_EIE | RIO_IPWMR_CQ);\r\nrc = request_irq(IRQ_RIO_PW(pw), fsl_rio_port_write_handler,\r\nIRQF_SHARED, "port-write", (void *)pw);\r\nif (rc < 0) {\r\npr_err("MPC85xx RIO: unable to request inbound doorbell irq");\r\ngoto err_out;\r\n}\r\nout_be32((u32 *)(rio_regs_win + RIO_LTLEECSR), LTLEECSR_ENABLE_ALL);\r\nINIT_WORK(&pw->pw_work, fsl_pw_dpc);\r\nspin_lock_init(&pw->pw_fifo_lock);\r\nif (kfifo_alloc(&pw->pw_fifo, RIO_PW_MSG_SIZE * 32, GFP_KERNEL)) {\r\npr_err("FIFO allocation failed\n");\r\nrc = -ENOMEM;\r\ngoto err_out_irq;\r\n}\r\npr_debug("IPWMR: 0x%08x IPWSR: 0x%08x\n",\r\nin_be32(&pw->pw_regs->pwmr),\r\nin_be32(&pw->pw_regs->pwsr));\r\nreturn rc;\r\nerr_out_irq:\r\nfree_irq(IRQ_RIO_PW(pw), (void *)pw);\r\nerr_out:\r\ndma_free_coherent(pw->dev, RIO_PW_MSG_SIZE,\r\npw->port_write_msg.virt,\r\npw->port_write_msg.phys);\r\nreturn rc;\r\n}\r\nint fsl_rio_doorbell_send(struct rio_mport *mport,\r\nint index, u16 destid, u16 data)\r\n{\r\npr_debug("fsl_doorbell_send: index %d destid %4.4x data %4.4x\n",\r\nindex, destid, data);\r\nout_be32(&dbell->dbell_regs->odmr, 0x00000000);\r\nout_be32(&dbell->dbell_regs->odretcr, 0x00000004);\r\nout_be32(&dbell->dbell_regs->oddpr, destid << 16);\r\nout_be32(&dbell->dbell_regs->oddatr, (index << 20) | data);\r\nout_be32(&dbell->dbell_regs->odmr, 0x00000001);\r\nreturn 0;\r\n}\r\nint\r\nfsl_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev, int mbox,\r\nvoid *buffer, size_t len)\r\n{\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nu32 omr;\r\nstruct rio_tx_desc *desc = (struct rio_tx_desc *)rmu->msg_tx_ring.virt\r\n+ rmu->msg_tx_ring.tx_slot;\r\nint ret = 0;\r\npr_debug("RIO: fsl_add_outb_message(): destid %4.4x mbox %d buffer " \\r\n"%p len %8.8zx\n", rdev->destid, mbox, buffer, len);\r\nif ((len < 8) || (len > RIO_MAX_MSG_SIZE)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(rmu->msg_tx_ring.virt_buffer[rmu->msg_tx_ring.tx_slot], buffer,\r\nlen);\r\nif (len < (RIO_MAX_MSG_SIZE - 4))\r\nmemset(rmu->msg_tx_ring.virt_buffer[rmu->msg_tx_ring.tx_slot]\r\n+ len, 0, RIO_MAX_MSG_SIZE - len);\r\ndesc->dport = (rdev->destid << 16) | (mbox & 0x3);\r\ndesc->dattr = 0x28000000 | ((mport->index) << 20);\r\ndesc->dwcnt = is_power_of_2(len) ? len : 1 << get_bitmask_order(len);\r\ndesc->saddr = 0x00000004\r\n| rmu->msg_tx_ring.phys_buffer[rmu->msg_tx_ring.tx_slot];\r\nomr = in_be32(&rmu->msg_regs->omr);\r\nout_be32(&rmu->msg_regs->omr, omr | RIO_MSG_OMR_MUI);\r\nif (++rmu->msg_tx_ring.tx_slot == rmu->msg_tx_ring.size)\r\nrmu->msg_tx_ring.tx_slot = 0;\r\nout:\r\nreturn ret;\r\n}\r\nint\r\nfsl_open_outb_mbox(struct rio_mport *mport, void *dev_id, int mbox, int entries)\r\n{\r\nint i, j, rc = 0;\r\nstruct rio_priv *priv = mport->priv;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nif ((entries < RIO_MIN_TX_RING_SIZE) ||\r\n(entries > RIO_MAX_TX_RING_SIZE) || (!is_power_of_2(entries))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrmu->msg_tx_ring.dev_id = dev_id;\r\nrmu->msg_tx_ring.size = entries;\r\nfor (i = 0; i < rmu->msg_tx_ring.size; i++) {\r\nrmu->msg_tx_ring.virt_buffer[i] =\r\ndma_alloc_coherent(priv->dev, RIO_MSG_BUFFER_SIZE,\r\n&rmu->msg_tx_ring.phys_buffer[i], GFP_KERNEL);\r\nif (!rmu->msg_tx_ring.virt_buffer[i]) {\r\nrc = -ENOMEM;\r\nfor (j = 0; j < rmu->msg_tx_ring.size; j++)\r\nif (rmu->msg_tx_ring.virt_buffer[j])\r\ndma_free_coherent(priv->dev,\r\nRIO_MSG_BUFFER_SIZE,\r\nrmu->msg_tx_ring.\r\nvirt_buffer[j],\r\nrmu->msg_tx_ring.\r\nphys_buffer[j]);\r\ngoto out;\r\n}\r\n}\r\nrmu->msg_tx_ring.virt = dma_alloc_coherent(priv->dev,\r\nrmu->msg_tx_ring.size * RIO_MSG_DESC_SIZE,\r\n&rmu->msg_tx_ring.phys, GFP_KERNEL);\r\nif (!rmu->msg_tx_ring.virt) {\r\nrc = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nmemset(rmu->msg_tx_ring.virt, 0,\r\nrmu->msg_tx_ring.size * RIO_MSG_DESC_SIZE);\r\nrmu->msg_tx_ring.tx_slot = 0;\r\nout_be32(&rmu->msg_regs->odqdpar, rmu->msg_tx_ring.phys);\r\nout_be32(&rmu->msg_regs->odqepar, rmu->msg_tx_ring.phys);\r\nout_be32(&rmu->msg_regs->osar, 0x00000004);\r\nout_be32(&rmu->msg_regs->osr, 0x000000b3);\r\nrc = request_irq(IRQ_RIO_TX(mport), fsl_rio_tx_handler, 0,\r\n"msg_tx", (void *)mport);\r\nif (rc < 0)\r\ngoto out_irq;\r\nout_be32(&rmu->msg_regs->omr, 0x00100220);\r\nout_be32(&rmu->msg_regs->omr,\r\nin_be32(&rmu->msg_regs->omr) |\r\n((get_bitmask_order(entries) - 2) << 12));\r\nout_be32(&rmu->msg_regs->omr, in_be32(&rmu->msg_regs->omr) | 0x1);\r\nout:\r\nreturn rc;\r\nout_irq:\r\ndma_free_coherent(priv->dev,\r\nrmu->msg_tx_ring.size * RIO_MSG_DESC_SIZE,\r\nrmu->msg_tx_ring.virt, rmu->msg_tx_ring.phys);\r\nout_dma:\r\nfor (i = 0; i < rmu->msg_tx_ring.size; i++)\r\ndma_free_coherent(priv->dev, RIO_MSG_BUFFER_SIZE,\r\nrmu->msg_tx_ring.virt_buffer[i],\r\nrmu->msg_tx_ring.phys_buffer[i]);\r\nreturn rc;\r\n}\r\nvoid fsl_close_outb_mbox(struct rio_mport *mport, int mbox)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nout_be32(&rmu->msg_regs->omr, 0);\r\ndma_free_coherent(priv->dev,\r\nrmu->msg_tx_ring.size * RIO_MSG_DESC_SIZE,\r\nrmu->msg_tx_ring.virt, rmu->msg_tx_ring.phys);\r\nfree_irq(IRQ_RIO_TX(mport), (void *)mport);\r\n}\r\nint\r\nfsl_open_inb_mbox(struct rio_mport *mport, void *dev_id, int mbox, int entries)\r\n{\r\nint i, rc = 0;\r\nstruct rio_priv *priv = mport->priv;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nif ((entries < RIO_MIN_RX_RING_SIZE) ||\r\n(entries > RIO_MAX_RX_RING_SIZE) || (!is_power_of_2(entries))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrmu->msg_rx_ring.dev_id = dev_id;\r\nrmu->msg_rx_ring.size = entries;\r\nrmu->msg_rx_ring.rx_slot = 0;\r\nfor (i = 0; i < rmu->msg_rx_ring.size; i++)\r\nrmu->msg_rx_ring.virt_buffer[i] = NULL;\r\nrmu->msg_rx_ring.virt = dma_alloc_coherent(priv->dev,\r\nrmu->msg_rx_ring.size * RIO_MAX_MSG_SIZE,\r\n&rmu->msg_rx_ring.phys, GFP_KERNEL);\r\nif (!rmu->msg_rx_ring.virt) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nout_be32(&rmu->msg_regs->ifqdpar, (u32) rmu->msg_rx_ring.phys);\r\nout_be32(&rmu->msg_regs->ifqepar, (u32) rmu->msg_rx_ring.phys);\r\nout_be32(&rmu->msg_regs->isr, 0x00000091);\r\nrc = request_irq(IRQ_RIO_RX(mport), fsl_rio_rx_handler, 0,\r\n"msg_rx", (void *)mport);\r\nif (rc < 0) {\r\ndma_free_coherent(priv->dev,\r\nrmu->msg_rx_ring.size * RIO_MAX_MSG_SIZE,\r\nrmu->msg_rx_ring.virt, rmu->msg_rx_ring.phys);\r\ngoto out;\r\n}\r\nout_be32(&rmu->msg_regs->imr, 0x001b0060);\r\nsetbits32(&rmu->msg_regs->imr, (get_bitmask_order(entries) - 2) << 12);\r\nsetbits32(&rmu->msg_regs->imr, 0x1);\r\nout:\r\nreturn rc;\r\n}\r\nvoid fsl_close_inb_mbox(struct rio_mport *mport, int mbox)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nout_be32(&rmu->msg_regs->imr, 0);\r\ndma_free_coherent(priv->dev, rmu->msg_rx_ring.size * RIO_MAX_MSG_SIZE,\r\nrmu->msg_rx_ring.virt, rmu->msg_rx_ring.phys);\r\nfree_irq(IRQ_RIO_RX(mport), (void *)mport);\r\n}\r\nint fsl_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)\r\n{\r\nint rc = 0;\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\npr_debug("RIO: fsl_add_inb_buffer(), msg_rx_ring.rx_slot %d\n",\r\nrmu->msg_rx_ring.rx_slot);\r\nif (rmu->msg_rx_ring.virt_buffer[rmu->msg_rx_ring.rx_slot]) {\r\nprintk(KERN_ERR\r\n"RIO: error adding inbound buffer %d, buffer exists\n",\r\nrmu->msg_rx_ring.rx_slot);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrmu->msg_rx_ring.virt_buffer[rmu->msg_rx_ring.rx_slot] = buf;\r\nif (++rmu->msg_rx_ring.rx_slot == rmu->msg_rx_ring.size)\r\nrmu->msg_rx_ring.rx_slot = 0;\r\nout:\r\nreturn rc;\r\n}\r\nvoid *fsl_get_inb_message(struct rio_mport *mport, int mbox)\r\n{\r\nstruct fsl_rmu *rmu = GET_RMM_HANDLE(mport);\r\nu32 phys_buf;\r\nvoid *virt_buf;\r\nvoid *buf = NULL;\r\nint buf_idx;\r\nphys_buf = in_be32(&rmu->msg_regs->ifqdpar);\r\nif (phys_buf == in_be32(&rmu->msg_regs->ifqepar))\r\ngoto out2;\r\nvirt_buf = rmu->msg_rx_ring.virt + (phys_buf\r\n- rmu->msg_rx_ring.phys);\r\nbuf_idx = (phys_buf - rmu->msg_rx_ring.phys) / RIO_MAX_MSG_SIZE;\r\nbuf = rmu->msg_rx_ring.virt_buffer[buf_idx];\r\nif (!buf) {\r\nprintk(KERN_ERR\r\n"RIO: inbound message copy failed, no buffers\n");\r\ngoto out1;\r\n}\r\nmemcpy(buf, virt_buf, RIO_MAX_MSG_SIZE);\r\nrmu->msg_rx_ring.virt_buffer[buf_idx] = NULL;\r\nout1:\r\nsetbits32(&rmu->msg_regs->imr, RIO_MSG_IMR_MI);\r\nout2:\r\nreturn buf;\r\n}\r\nint fsl_rio_doorbell_init(struct fsl_rio_dbell *dbell)\r\n{\r\nint rc = 0;\r\ndbell->dbell_ring.virt = dma_alloc_coherent(dbell->dev, 512 *\r\nDOORBELL_MESSAGE_SIZE, &dbell->dbell_ring.phys, GFP_KERNEL);\r\nif (!dbell->dbell_ring.virt) {\r\nprintk(KERN_ERR "RIO: unable allocate inbound doorbell ring\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nout_be32(&dbell->dbell_regs->dqdpar, (u32) dbell->dbell_ring.phys);\r\nout_be32(&dbell->dbell_regs->dqepar, (u32) dbell->dbell_ring.phys);\r\nout_be32(&dbell->dbell_regs->dsr, 0x00000091);\r\nrc = request_irq(IRQ_RIO_BELL(dbell), fsl_rio_dbell_handler, 0,\r\n"dbell_rx", (void *)dbell);\r\nif (rc < 0) {\r\ndma_free_coherent(dbell->dev, 512 * DOORBELL_MESSAGE_SIZE,\r\ndbell->dbell_ring.virt, dbell->dbell_ring.phys);\r\nprintk(KERN_ERR\r\n"MPC85xx RIO: unable to request inbound doorbell irq");\r\ngoto out;\r\n}\r\nout_be32(&dbell->dbell_regs->dmr, 0x00108161);\r\nout:\r\nreturn rc;\r\n}\r\nint fsl_rio_setup_rmu(struct rio_mport *mport, struct device_node *node)\r\n{\r\nstruct rio_priv *priv;\r\nstruct fsl_rmu *rmu;\r\nu64 msg_start;\r\nconst u32 *msg_addr;\r\nint mlen;\r\nint aw;\r\nif (!mport || !mport->priv)\r\nreturn -EINVAL;\r\npriv = mport->priv;\r\nif (!node) {\r\ndev_warn(priv->dev, "Can't get %s property 'fsl,rmu'\n",\r\npriv->dev->of_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nrmu = kzalloc(sizeof(struct fsl_rmu), GFP_KERNEL);\r\nif (!rmu)\r\nreturn -ENOMEM;\r\naw = of_n_addr_cells(node);\r\nmsg_addr = of_get_property(node, "reg", &mlen);\r\nif (!msg_addr) {\r\npr_err("%s: unable to find 'reg' property of message-unit\n",\r\nnode->full_name);\r\nkfree(rmu);\r\nreturn -ENOMEM;\r\n}\r\nmsg_start = of_read_number(msg_addr, aw);\r\nrmu->msg_regs = (struct rio_msg_regs *)\r\n(rmu_regs_win + (u32)msg_start);\r\nrmu->txirq = irq_of_parse_and_map(node, 0);\r\nrmu->rxirq = irq_of_parse_and_map(node, 1);\r\nprintk(KERN_INFO "%s: txirq: %d, rxirq %d\n",\r\nnode->full_name, rmu->txirq, rmu->rxirq);\r\npriv->rmm_handle = rmu;\r\nrio_init_dbell_res(&mport->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);\r\nrio_init_mbox_res(&mport->riores[RIO_INB_MBOX_RESOURCE], 0, 0);\r\nrio_init_mbox_res(&mport->riores[RIO_OUTB_MBOX_RESOURCE], 0, 0);\r\nreturn 0;\r\n}
