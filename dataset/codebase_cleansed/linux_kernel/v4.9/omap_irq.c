static void omap_irq_error_handler(struct omap_drm_irq *irq,\r\nuint32_t irqstatus)\r\n{\r\nDRM_ERROR("errors: %08x\n", irqstatus);\r\n}\r\nstatic void omap_irq_update(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_drm_irq *irq;\r\nuint32_t irqmask = priv->vblank_mask;\r\nassert_spin_locked(&list_lock);\r\nlist_for_each_entry(irq, &priv->irq_list, node)\r\nirqmask |= irq->irqmask;\r\nDBG("irqmask=%08x", irqmask);\r\ndispc_write_irqenable(irqmask);\r\ndispc_read_irqenable();\r\n}\r\nvoid __omap_irq_register(struct drm_device *dev, struct omap_drm_irq *irq)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nif (!WARN_ON(irq->registered)) {\r\nirq->registered = true;\r\nlist_add(&irq->node, &priv->irq_list);\r\nomap_irq_update(dev);\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\n}\r\nvoid omap_irq_register(struct drm_device *dev, struct omap_drm_irq *irq)\r\n{\r\ndispc_runtime_get();\r\n__omap_irq_register(dev, irq);\r\ndispc_runtime_put();\r\n}\r\nvoid __omap_irq_unregister(struct drm_device *dev, struct omap_drm_irq *irq)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nif (!WARN_ON(!irq->registered)) {\r\nirq->registered = false;\r\nlist_del(&irq->node);\r\nomap_irq_update(dev);\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\n}\r\nvoid omap_irq_unregister(struct drm_device *dev, struct omap_drm_irq *irq)\r\n{\r\ndispc_runtime_get();\r\n__omap_irq_unregister(dev, irq);\r\ndispc_runtime_put();\r\n}\r\nstatic void wait_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_irq_wait *wait =\r\ncontainer_of(irq, struct omap_irq_wait, irq);\r\nwait->count--;\r\nwake_up_all(&wait_event);\r\n}\r\nstruct omap_irq_wait * omap_irq_wait_init(struct drm_device *dev,\r\nuint32_t irqmask, int count)\r\n{\r\nstruct omap_irq_wait *wait = kzalloc(sizeof(*wait), GFP_KERNEL);\r\nwait->irq.irq = wait_irq;\r\nwait->irq.irqmask = irqmask;\r\nwait->count = count;\r\nomap_irq_register(dev, &wait->irq);\r\nreturn wait;\r\n}\r\nint omap_irq_wait(struct drm_device *dev, struct omap_irq_wait *wait,\r\nunsigned long timeout)\r\n{\r\nint ret = wait_event_timeout(wait_event, (wait->count <= 0), timeout);\r\nomap_irq_unregister(dev, &wait->irq);\r\nkfree(wait);\r\nif (ret == 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint omap_irq_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc = priv->crtcs[pipe];\r\nunsigned long flags;\r\nDBG("dev=%p, crtc=%u", dev, pipe);\r\nspin_lock_irqsave(&list_lock, flags);\r\npriv->vblank_mask |= pipe2vbl(crtc);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn 0;\r\n}\r\nvoid omap_irq_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc = priv->crtcs[pipe];\r\nunsigned long flags;\r\nDBG("dev=%p, crtc=%u", dev, pipe);\r\nspin_lock_irqsave(&list_lock, flags);\r\npriv->vblank_mask &= ~pipe2vbl(crtc);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\n}\r\nstatic irqreturn_t omap_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *) arg;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_drm_irq *handler, *n;\r\nunsigned long flags;\r\nunsigned int id;\r\nu32 irqstatus;\r\nirqstatus = dispc_read_irqstatus();\r\ndispc_clear_irqstatus(irqstatus);\r\ndispc_read_irqstatus();\r\nVERB("irqs: %08x", irqstatus);\r\nfor (id = 0; id < priv->num_crtcs; id++) {\r\nstruct drm_crtc *crtc = priv->crtcs[id];\r\nif (irqstatus & pipe2vbl(crtc))\r\ndrm_handle_vblank(dev, id);\r\n}\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_for_each_entry_safe(handler, n, &priv->irq_list, node) {\r\nif (handler->irqmask & irqstatus) {\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nhandler->irq(handler, handler->irqmask & irqstatus);\r\nspin_lock_irqsave(&list_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint omap_drm_irq_install(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_drm_irq *error_handler = &priv->error_handler;\r\nint ret;\r\nINIT_LIST_HEAD(&priv->irq_list);\r\ndispc_runtime_get();\r\ndispc_clear_irqstatus(0xffffffff);\r\ndispc_runtime_put();\r\nret = dispc_request_irq(omap_irq_handler, dev);\r\nif (ret < 0)\r\nreturn ret;\r\nerror_handler->irq = omap_irq_error_handler;\r\nerror_handler->irqmask = DISPC_IRQ_OCP_ERR;\r\nerror_handler->irqmask &= ~DISPC_IRQ_SYNC_LOST_DIGIT;\r\nomap_irq_register(dev, error_handler);\r\ndev->irq_enabled = true;\r\nreturn 0;\r\n}\r\nvoid omap_drm_irq_uninstall(struct drm_device *dev)\r\n{\r\nunsigned long irqflags;\r\nint i;\r\nif (!dev->irq_enabled)\r\nreturn;\r\ndev->irq_enabled = false;\r\nif (dev->num_crtcs) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nfor (i = 0; i < dev->num_crtcs; i++) {\r\nwake_up(&dev->vblank[i].queue);\r\ndev->vblank[i].enabled = false;\r\ndev->vblank[i].last =\r\ndev->driver->get_vblank_counter(dev, i);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\ndispc_free_irq(dev);\r\n}
