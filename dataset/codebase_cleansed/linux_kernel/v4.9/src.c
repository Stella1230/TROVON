static void rsnd_src_activation(struct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, SRC_SWRSR, 0);\r\nrsnd_mod_write(mod, SRC_SWRSR, 1);\r\n}\r\nstatic void rsnd_src_halt(struct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, SRC_SRCIR, 1);\r\nrsnd_mod_write(mod, SRC_SWRSR, 0);\r\n}\r\nstatic struct dma_chan *rsnd_src_dma_req(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nint is_play = rsnd_io_is_play(io);\r\nreturn rsnd_dma_request_channel(rsnd_src_of_node(priv),\r\nmod,\r\nis_play ? "rx" : "tx");\r\n}\r\nstatic u32 rsnd_src_convert_rate(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nu32 convert_rate;\r\nif (!runtime)\r\nreturn 0;\r\nif (!rsnd_src_sync_is_enabled(mod))\r\nreturn src->convert_rate;\r\nconvert_rate = src->sync.val;\r\nif (!convert_rate)\r\nconvert_rate = src->convert_rate;\r\nif (!convert_rate)\r\nconvert_rate = runtime->rate;\r\nreturn convert_rate;\r\n}\r\nunsigned int rsnd_src_get_rate(struct rsnd_priv *priv,\r\nstruct rsnd_dai_stream *io,\r\nint is_in)\r\n{\r\nstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nunsigned int rate = 0;\r\nint is_play = rsnd_io_is_play(io);\r\nif (is_play == is_in)\r\nreturn runtime->rate;\r\nif (src_mod)\r\nrate = rsnd_src_convert_rate(io, src_mod);\r\nif (!rate)\r\nrate = runtime->rate;\r\nreturn rate;\r\n}\r\nstatic int rsnd_src_hw_params(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *fe_params)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nif (fe->dai_link->dynamic) {\r\nint stream = substream->stream;\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_pcm_hw_params *be_params;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nbe_params = &dpcm->hw_params;\r\nif (params_rate(fe_params) != params_rate(be_params))\r\nsrc->convert_rate = params_rate(be_params);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rsnd_src_set_convert_rate(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nu32 fin, fout;\r\nu32 ifscr, fsrate, adinr;\r\nu32 cr, route;\r\nu32 bsdsr, bsisr;\r\nuint ratio;\r\nif (!runtime)\r\nreturn;\r\nfin = rsnd_src_get_in_rate(priv, io);\r\nfout = rsnd_src_get_out_rate(priv, io);\r\nif (fin == fout)\r\nratio = 0;\r\nelse if (fin > fout)\r\nratio = 100 * fin / fout;\r\nelse\r\nratio = 100 * fout / fin;\r\nif (ratio > 600) {\r\ndev_err(dev, "FSO/FSI ratio error\n");\r\nreturn;\r\n}\r\nadinr = rsnd_get_adinr_bit(mod, io) |\r\nrsnd_runtime_channel_original(io);\r\nifscr = 0;\r\nfsrate = 0;\r\nif (fin != fout) {\r\nu64 n;\r\nifscr = 1;\r\nn = (u64)0x0400000 * fin;\r\ndo_div(n, fout);\r\nfsrate = n;\r\n}\r\ncr = 0x00011110;\r\nroute = 0x0;\r\nif (fin != fout) {\r\nroute = 0x1;\r\nif (rsnd_src_sync_is_enabled(mod)) {\r\ncr |= 0x1;\r\nroute |= rsnd_io_is_play(io) ?\r\n(0x1 << 24) : (0x1 << 25);\r\n}\r\n}\r\nswitch (rsnd_mod_id(mod)) {\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\nbsdsr = 0x02400000;\r\nbsisr = 0x00100060;\r\nbreak;\r\ndefault:\r\nbsdsr = 0x01800000;\r\nbsisr = 0x00100060 ;\r\nbreak;\r\n}\r\nrsnd_mod_write(mod, SRC_ROUTE_MODE0, route);\r\nrsnd_mod_write(mod, SRC_SRCIR, 1);\r\nrsnd_mod_write(mod, SRC_ADINR, adinr);\r\nrsnd_mod_write(mod, SRC_IFSCR, ifscr);\r\nrsnd_mod_write(mod, SRC_IFSVR, fsrate);\r\nrsnd_mod_write(mod, SRC_SRCCR, cr);\r\nrsnd_mod_write(mod, SRC_BSDSR, bsdsr);\r\nrsnd_mod_write(mod, SRC_BSISR, bsisr);\r\nrsnd_mod_write(mod, SRC_SRCIR, 0);\r\nrsnd_mod_write(mod, SRC_I_BUSIF_MODE, 1);\r\nrsnd_mod_write(mod, SRC_O_BUSIF_MODE, 1);\r\nrsnd_mod_write(mod, SRC_BUSIF_DALIGN, rsnd_get_dalign(mod, io));\r\nrsnd_adg_set_src_timesel_gen2(mod, io, fin, fout);\r\n}\r\nstatic int rsnd_src_irq(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv,\r\nint enable)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nu32 sys_int_val, int_val, sys_int_mask;\r\nint irq = src->irq;\r\nint id = rsnd_mod_id(mod);\r\nsys_int_val =\r\nsys_int_mask = OUF_SRC(id);\r\nint_val = 0x3300;\r\nif ((irq <= 0) || !enable) {\r\nsys_int_val = 0;\r\nint_val = 0;\r\n}\r\nif (rsnd_src_sync_is_enabled(mod))\r\nsys_int_val = sys_int_val & 0xffff;\r\nrsnd_mod_write(mod, SRC_INT_ENABLE0, int_val);\r\nrsnd_mod_bset(mod, SCU_SYS_INT_EN0, sys_int_mask, sys_int_val);\r\nrsnd_mod_bset(mod, SCU_SYS_INT_EN1, sys_int_mask, sys_int_val);\r\nreturn 0;\r\n}\r\nstatic void rsnd_src_status_clear(struct rsnd_mod *mod)\r\n{\r\nu32 val = OUF_SRC(rsnd_mod_id(mod));\r\nrsnd_mod_bset(mod, SCU_SYS_STATUS0, val, val);\r\nrsnd_mod_bset(mod, SCU_SYS_STATUS1, val, val);\r\n}\r\nstatic bool rsnd_src_error_occurred(struct rsnd_mod *mod)\r\n{\r\nu32 val0, val1;\r\nbool ret = false;\r\nval0 = val1 = OUF_SRC(rsnd_mod_id(mod));\r\nif (rsnd_src_sync_is_enabled(mod))\r\nval0 = val0 & 0xffff;\r\nif ((rsnd_mod_read(mod, SCU_SYS_STATUS0) & val0) ||\r\n(rsnd_mod_read(mod, SCU_SYS_STATUS1) & val1))\r\nret = true;\r\nreturn ret;\r\n}\r\nstatic int rsnd_src_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nu32 val;\r\nval = (rsnd_io_to_mod_dvc(io) && !rsnd_src_sync_is_enabled(mod)) ?\r\n0x01 : 0x11;\r\nrsnd_mod_write(mod, SRC_CTRL, val);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nrsnd_mod_write(mod, SRC_CTRL, 0);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nrsnd_mod_power_on(mod);\r\nrsnd_src_activation(mod);\r\nrsnd_src_set_convert_rate(io, mod);\r\nrsnd_src_status_clear(mod);\r\nsrc->sync.val = 0;\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nrsnd_src_halt(mod);\r\nrsnd_mod_power_off(mod);\r\nsrc->convert_rate = 0;\r\nsrc->sync.val = 0;\r\nreturn 0;\r\n}\r\nstatic void __rsnd_src_interrupt(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nbool stop = false;\r\nspin_lock(&priv->lock);\r\nif (!rsnd_io_is_working(io))\r\ngoto rsnd_src_interrupt_out;\r\nif (rsnd_src_error_occurred(mod))\r\nstop = true;\r\nrsnd_src_status_clear(mod);\r\nrsnd_src_interrupt_out:\r\nspin_unlock(&priv->lock);\r\nif (stop)\r\nsnd_pcm_stop_xrun(io->substream);\r\n}\r\nstatic irqreturn_t rsnd_src_interrupt(int irq, void *data)\r\n{\r\nstruct rsnd_mod *mod = data;\r\nrsnd_mod_interrupt(mod, __rsnd_src_interrupt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rsnd_src_probe_(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint irq = src->irq;\r\nint ret;\r\nif (irq > 0) {\r\nret = devm_request_irq(dev, irq,\r\nrsnd_src_interrupt,\r\nIRQF_SHARED,\r\ndev_name(dev), mod);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = rsnd_dma_attach(io, mod, &src->dma, 0);\r\nreturn ret;\r\n}\r\nstatic int rsnd_src_pcm_new(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nint ret;\r\nif (rsnd_io_to_mod_cmd(io) && !rsnd_io_is_play(io))\r\nreturn 0;\r\nret = rsnd_kctrl_new_s(mod, io, rtd,\r\nrsnd_io_is_play(io) ?\r\n"SRC Out Rate Switch" :\r\n"SRC In Rate Switch",\r\nrsnd_src_set_convert_rate,\r\n&src->sen, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_kctrl_new_s(mod, io, rtd,\r\nrsnd_io_is_play(io) ?\r\n"SRC Out Rate" :\r\n"SRC In Rate",\r\nrsnd_src_set_convert_rate,\r\n&src->sync, 192000);\r\nreturn ret;\r\n}\r\nstruct rsnd_mod *rsnd_src_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_src_nr(priv)))\r\nid = 0;\r\nreturn rsnd_mod_get(rsnd_src_get(priv, id));\r\n}\r\nint rsnd_src_probe(struct rsnd_priv *priv)\r\n{\r\nstruct device_node *node;\r\nstruct device_node *np;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_src *src;\r\nstruct clk *clk;\r\nchar name[RSND_SRC_NAME_SIZE];\r\nint i, nr, ret;\r\nif (rsnd_is_gen1(priv))\r\nreturn 0;\r\nnode = rsnd_src_of_node(priv);\r\nif (!node)\r\nreturn 0;\r\nnr = of_get_child_count(node);\r\nif (!nr) {\r\nret = -EINVAL;\r\ngoto rsnd_src_probe_done;\r\n}\r\nsrc = devm_kzalloc(dev, sizeof(*src) * nr, GFP_KERNEL);\r\nif (!src) {\r\nret = -ENOMEM;\r\ngoto rsnd_src_probe_done;\r\n}\r\npriv->src_nr = nr;\r\npriv->src = src;\r\ni = 0;\r\nfor_each_child_of_node(node, np) {\r\nif (!of_device_is_available(np))\r\ngoto skip;\r\nsrc = rsnd_src_get(priv, i);\r\nsnprintf(name, RSND_SRC_NAME_SIZE, "%s.%d",\r\nSRC_NAME, i);\r\nsrc->irq = irq_of_parse_and_map(np, 0);\r\nif (!src->irq) {\r\nret = -EINVAL;\r\ngoto rsnd_src_probe_done;\r\n}\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto rsnd_src_probe_done;\r\n}\r\nret = rsnd_mod_init(priv, rsnd_mod_get(src),\r\n&rsnd_src_ops, clk, rsnd_mod_get_status,\r\nRSND_MOD_SRC, i);\r\nif (ret)\r\ngoto rsnd_src_probe_done;\r\nskip:\r\ni++;\r\n}\r\nret = 0;\r\nrsnd_src_probe_done:\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nvoid rsnd_src_remove(struct rsnd_priv *priv)\r\n{\r\nstruct rsnd_src *src;\r\nint i;\r\nfor_each_rsnd_src(src, priv, i) {\r\nrsnd_mod_quit(rsnd_mod_get(src));\r\n}\r\n}
