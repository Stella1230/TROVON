static int dvb_device_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev;\r\nmutex_lock(&dvbdev_mutex);\r\ndown_read(&minor_rwsem);\r\ndvbdev = dvb_minors[iminor(inode)];\r\nif (dvbdev && dvbdev->fops) {\r\nint err = 0;\r\nconst struct file_operations *new_fops;\r\nnew_fops = fops_get(dvbdev->fops);\r\nif (!new_fops)\r\ngoto fail;\r\nfile->private_data = dvbdev;\r\nreplace_fops(file, new_fops);\r\nif (file->f_op->open)\r\nerr = file->f_op->open(inode, file);\r\nup_read(&minor_rwsem);\r\nmutex_unlock(&dvbdev_mutex);\r\nreturn err;\r\n}\r\nfail:\r\nup_read(&minor_rwsem);\r\nmutex_unlock(&dvbdev_mutex);\r\nreturn -ENODEV;\r\n}\r\nint dvb_generic_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif (!dvbdev->users)\r\nreturn -EBUSY;\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\nif (!dvbdev->readers)\r\nreturn -EBUSY;\r\ndvbdev->readers--;\r\n} else {\r\nif (!dvbdev->writers)\r\nreturn -EBUSY;\r\ndvbdev->writers--;\r\n}\r\ndvbdev->users--;\r\nreturn 0;\r\n}\r\nint dvb_generic_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\ndvbdev->readers++;\r\n} else {\r\ndvbdev->writers++;\r\n}\r\ndvbdev->users++;\r\nreturn 0;\r\n}\r\nlong dvb_generic_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nif (!dvbdev)\r\nreturn -ENODEV;\r\nif (!dvbdev->kernel_ioctl)\r\nreturn -EINVAL;\r\nreturn dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);\r\n}\r\nstatic int dvbdev_get_free_id (struct dvb_adapter *adap, int type)\r\n{\r\nu32 id = 0;\r\nwhile (id < DVB_MAX_IDS) {\r\nstruct dvb_device *dev;\r\nlist_for_each_entry(dev, &adap->device_list, list_head)\r\nif (dev->type == type && dev->id == id)\r\ngoto skip;\r\nreturn id;\r\nskip:\r\nid++;\r\n}\r\nreturn -ENFILE;\r\n}\r\nstatic void dvb_media_device_free(struct dvb_device *dvbdev)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\r\nif (dvbdev->entity) {\r\nmedia_device_unregister_entity(dvbdev->entity);\r\nkfree(dvbdev->entity);\r\nkfree(dvbdev->pads);\r\ndvbdev->entity = NULL;\r\ndvbdev->pads = NULL;\r\n}\r\nif (dvbdev->tsout_entity) {\r\nint i;\r\nfor (i = 0; i < dvbdev->tsout_num_entities; i++) {\r\nmedia_device_unregister_entity(&dvbdev->tsout_entity[i]);\r\nkfree(dvbdev->tsout_entity[i].name);\r\n}\r\nkfree(dvbdev->tsout_entity);\r\nkfree(dvbdev->tsout_pads);\r\ndvbdev->tsout_entity = NULL;\r\ndvbdev->tsout_pads = NULL;\r\ndvbdev->tsout_num_entities = 0;\r\n}\r\nif (dvbdev->intf_devnode) {\r\nmedia_devnode_remove(dvbdev->intf_devnode);\r\ndvbdev->intf_devnode = NULL;\r\n}\r\nif (dvbdev->adapter->conn) {\r\nmedia_device_unregister_entity(dvbdev->adapter->conn);\r\ndvbdev->adapter->conn = NULL;\r\nkfree(dvbdev->adapter->conn_pads);\r\ndvbdev->adapter->conn_pads = NULL;\r\n}\r\n#endif\r\n}\r\nstatic int dvb_create_tsout_entity(struct dvb_device *dvbdev,\r\nconst char *name, int npads)\r\n{\r\nint i, ret = 0;\r\ndvbdev->tsout_pads = kcalloc(npads, sizeof(*dvbdev->tsout_pads),\r\nGFP_KERNEL);\r\nif (!dvbdev->tsout_pads)\r\nreturn -ENOMEM;\r\ndvbdev->tsout_entity = kcalloc(npads, sizeof(*dvbdev->tsout_entity),\r\nGFP_KERNEL);\r\nif (!dvbdev->tsout_entity)\r\nreturn -ENOMEM;\r\ndvbdev->tsout_num_entities = npads;\r\nfor (i = 0; i < npads; i++) {\r\nstruct media_pad *pads = &dvbdev->tsout_pads[i];\r\nstruct media_entity *entity = &dvbdev->tsout_entity[i];\r\nentity->name = kasprintf(GFP_KERNEL, "%s #%d", name, i);\r\nif (!entity->name)\r\nreturn -ENOMEM;\r\nentity->function = MEDIA_ENT_F_IO_DTV;\r\npads->flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(entity, 1, pads);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_device_register_entity(dvbdev->adapter->mdev,\r\nentity);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_create_media_entity(struct dvb_device *dvbdev,\r\nint type, int demux_sink_pads)\r\n{\r\nint i, ret, npads;\r\nswitch (type) {\r\ncase DVB_DEVICE_FRONTEND:\r\nnpads = 2;\r\nbreak;\r\ncase DVB_DEVICE_DVR:\r\nret = dvb_create_tsout_entity(dvbdev, DVR_TSOUT,\r\ndemux_sink_pads);\r\nreturn ret;\r\ncase DVB_DEVICE_DEMUX:\r\nnpads = 1 + demux_sink_pads;\r\nret = dvb_create_tsout_entity(dvbdev, DEMUX_TSOUT,\r\ndemux_sink_pads);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase DVB_DEVICE_CA:\r\nnpads = 2;\r\nbreak;\r\ncase DVB_DEVICE_NET:\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\ndvbdev->entity = kzalloc(sizeof(*dvbdev->entity), GFP_KERNEL);\r\nif (!dvbdev->entity)\r\nreturn -ENOMEM;\r\ndvbdev->entity->name = dvbdev->name;\r\nif (npads) {\r\ndvbdev->pads = kcalloc(npads, sizeof(*dvbdev->pads),\r\nGFP_KERNEL);\r\nif (!dvbdev->pads)\r\nreturn -ENOMEM;\r\n}\r\nswitch (type) {\r\ncase DVB_DEVICE_FRONTEND:\r\ndvbdev->entity->function = MEDIA_ENT_F_DTV_DEMOD;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\ndvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ncase DVB_DEVICE_DEMUX:\r\ndvbdev->entity->function = MEDIA_ENT_F_TS_DEMUX;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\nfor (i = 1; i < npads; i++)\r\ndvbdev->pads[i].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ncase DVB_DEVICE_CA:\r\ndvbdev->entity->function = MEDIA_ENT_F_DTV_CA;\r\ndvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\r\ndvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ndefault:\r\nkfree(dvbdev->entity);\r\nkfree(dvbdev->pads);\r\ndvbdev->entity = NULL;\r\ndvbdev->pads = NULL;\r\nreturn 0;\r\n}\r\nif (npads) {\r\nret = media_entity_pads_init(dvbdev->entity, npads, dvbdev->pads);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = media_device_register_entity(dvbdev->adapter->mdev,\r\ndvbdev->entity);\r\nif (ret)\r\nreturn ret;\r\nprintk(KERN_DEBUG "%s: media entity '%s' registered.\n",\r\n__func__, dvbdev->entity->name);\r\nreturn 0;\r\n}\r\nstatic int dvb_register_media_device(struct dvb_device *dvbdev,\r\nint type, int minor,\r\nunsigned demux_sink_pads)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\r\nstruct media_link *link;\r\nu32 intf_type;\r\nint ret;\r\nif (!dvbdev->adapter->mdev)\r\nreturn 0;\r\nret = dvb_create_media_entity(dvbdev, type, demux_sink_pads);\r\nif (ret)\r\nreturn ret;\r\nswitch (type) {\r\ncase DVB_DEVICE_FRONTEND:\r\nintf_type = MEDIA_INTF_T_DVB_FE;\r\nbreak;\r\ncase DVB_DEVICE_DEMUX:\r\nintf_type = MEDIA_INTF_T_DVB_DEMUX;\r\nbreak;\r\ncase DVB_DEVICE_DVR:\r\nintf_type = MEDIA_INTF_T_DVB_DVR;\r\nbreak;\r\ncase DVB_DEVICE_CA:\r\nintf_type = MEDIA_INTF_T_DVB_CA;\r\nbreak;\r\ncase DVB_DEVICE_NET:\r\nintf_type = MEDIA_INTF_T_DVB_NET;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ndvbdev->intf_devnode = media_devnode_create(dvbdev->adapter->mdev,\r\nintf_type, 0,\r\nDVB_MAJOR, minor);\r\nif (!dvbdev->intf_devnode)\r\nreturn -ENOMEM;\r\nif (!dvbdev->entity)\r\nreturn 0;\r\nlink = media_create_intf_link(dvbdev->entity, &dvbdev->intf_devnode->intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link)\r\nreturn -ENOMEM;\r\n#endif\r\nreturn 0;\r\n}\r\nint dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,\r\nconst struct dvb_device *template, void *priv, int type,\r\nint demux_sink_pads)\r\n{\r\nstruct dvb_device *dvbdev;\r\nstruct file_operations *dvbdevfops;\r\nstruct device *clsdev;\r\nint minor;\r\nint id, ret;\r\nmutex_lock(&dvbdev_register_lock);\r\nif ((id = dvbdev_get_free_id (adap, type)) < 0){\r\nmutex_unlock(&dvbdev_register_lock);\r\n*pdvbdev = NULL;\r\nprintk(KERN_ERR "%s: couldn't find free device id\n", __func__);\r\nreturn -ENFILE;\r\n}\r\n*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);\r\nif (!dvbdev){\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENOMEM;\r\n}\r\ndvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);\r\nif (!dvbdevfops){\r\nkfree (dvbdev);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dvbdev, template, sizeof(struct dvb_device));\r\ndvbdev->type = type;\r\ndvbdev->id = id;\r\ndvbdev->adapter = adap;\r\ndvbdev->priv = priv;\r\ndvbdev->fops = dvbdevfops;\r\ninit_waitqueue_head (&dvbdev->wait_queue);\r\nmemcpy(dvbdevfops, template->fops, sizeof(struct file_operations));\r\ndvbdevfops->owner = adap->module;\r\nlist_add_tail (&dvbdev->list_head, &adap->device_list);\r\ndown_write(&minor_rwsem);\r\n#ifdef CONFIG_DVB_DYNAMIC_MINORS\r\nfor (minor = 0; minor < MAX_DVB_MINORS; minor++)\r\nif (dvb_minors[minor] == NULL)\r\nbreak;\r\nif (minor == MAX_DVB_MINORS) {\r\nkfree(dvbdevfops);\r\nkfree(dvbdev);\r\nup_write(&minor_rwsem);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -EINVAL;\r\n}\r\n#else\r\nminor = nums2minor(adap->num, type, id);\r\n#endif\r\ndvbdev->minor = minor;\r\ndvb_minors[minor] = dvbdev;\r\nup_write(&minor_rwsem);\r\nret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"%s: dvb_register_media_device failed to create the mediagraph\n",\r\n__func__);\r\ndvb_media_device_free(dvbdev);\r\nkfree(dvbdevfops);\r\nkfree(dvbdev);\r\nup_write(&minor_rwsem);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn ret;\r\n}\r\nmutex_unlock(&dvbdev_register_lock);\r\nclsdev = device_create(dvb_class, adap->device,\r\nMKDEV(DVB_MAJOR, minor),\r\ndvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);\r\nif (IS_ERR(clsdev)) {\r\nprintk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",\r\n__func__, adap->num, dnames[type], id, PTR_ERR(clsdev));\r\nreturn PTR_ERR(clsdev);\r\n}\r\ndprintk(KERN_DEBUG "DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",\r\nadap->num, dnames[type], id, minor, minor);\r\nreturn 0;\r\n}\r\nvoid dvb_unregister_device(struct dvb_device *dvbdev)\r\n{\r\nif (!dvbdev)\r\nreturn;\r\ndown_write(&minor_rwsem);\r\ndvb_minors[dvbdev->minor] = NULL;\r\nup_write(&minor_rwsem);\r\ndvb_media_device_free(dvbdev);\r\ndevice_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));\r\nlist_del (&dvbdev->list_head);\r\nkfree (dvbdev->fops);\r\nkfree (dvbdev);\r\n}\r\nstatic int dvb_create_io_intf_links(struct dvb_adapter *adap,\r\nstruct media_interface *intf,\r\nchar *name)\r\n{\r\nstruct media_device *mdev = adap->mdev;\r\nstruct media_entity *entity;\r\nstruct media_link *link;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (entity->function == MEDIA_ENT_F_IO_DTV) {\r\nif (strncmp(entity->name, name, strlen(name)))\r\ncontinue;\r\nlink = media_create_intf_link(entity, intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dvb_create_media_graph(struct dvb_adapter *adap,\r\nbool create_rf_connector)\r\n{\r\nstruct media_device *mdev = adap->mdev;\r\nstruct media_entity *entity, *tuner = NULL, *demod = NULL, *conn;\r\nstruct media_entity *demux = NULL, *ca = NULL;\r\nstruct media_link *link;\r\nstruct media_interface *intf;\r\nunsigned demux_pad = 0;\r\nunsigned dvr_pad = 0;\r\nunsigned ntuner = 0, ndemod = 0;\r\nint ret;\r\nstatic const char *connector_name = "Television";\r\nif (!mdev)\r\nreturn 0;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nswitch (entity->function) {\r\ncase MEDIA_ENT_F_TUNER:\r\ntuner = entity;\r\nntuner++;\r\nbreak;\r\ncase MEDIA_ENT_F_DTV_DEMOD:\r\ndemod = entity;\r\nndemod++;\r\nbreak;\r\ncase MEDIA_ENT_F_TS_DEMUX:\r\ndemux = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_DTV_CA:\r\nca = entity;\r\nbreak;\r\n}\r\n}\r\nif (ntuner > 1)\r\ntuner = NULL;\r\nif (ndemod > 1)\r\ndemod = NULL;\r\nif (create_rf_connector) {\r\nconn = kzalloc(sizeof(*conn), GFP_KERNEL);\r\nif (!conn)\r\nreturn -ENOMEM;\r\nadap->conn = conn;\r\nadap->conn_pads = kzalloc(sizeof(*adap->conn_pads), GFP_KERNEL);\r\nif (!adap->conn_pads)\r\nreturn -ENOMEM;\r\nconn->flags = MEDIA_ENT_FL_CONNECTOR;\r\nconn->function = MEDIA_ENT_F_CONN_RF;\r\nconn->name = connector_name;\r\nadap->conn_pads->flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(conn, 1, adap->conn_pads);\r\nif (ret)\r\nreturn ret;\r\nret = media_device_register_entity(mdev, conn);\r\nif (ret)\r\nreturn ret;\r\nif (!ntuner)\r\nret = media_create_pad_links(mdev,\r\nMEDIA_ENT_F_CONN_RF,\r\nconn, 0,\r\nMEDIA_ENT_F_DTV_DEMOD,\r\ndemod, 0,\r\nMEDIA_LNK_FL_ENABLED,\r\nfalse);\r\nelse\r\nret = media_create_pad_links(mdev,\r\nMEDIA_ENT_F_CONN_RF,\r\nconn, 0,\r\nMEDIA_ENT_F_TUNER,\r\ntuner, TUNER_PAD_RF_INPUT,\r\nMEDIA_LNK_FL_ENABLED,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ntuner && ndemod) {\r\nret = media_create_pad_links(mdev,\r\nMEDIA_ENT_F_TUNER,\r\ntuner, TUNER_PAD_OUTPUT,\r\nMEDIA_ENT_F_DTV_DEMOD,\r\ndemod, 0, MEDIA_LNK_FL_ENABLED,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ndemod && demux) {\r\nret = media_create_pad_links(mdev,\r\nMEDIA_ENT_F_DTV_DEMOD,\r\ndemod, 1,\r\nMEDIA_ENT_F_TS_DEMUX,\r\ndemux, 0, MEDIA_LNK_FL_ENABLED,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (demux && ca) {\r\nret = media_create_pad_link(demux, 1, ca,\r\n0, MEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (demux) {\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (entity->function == MEDIA_ENT_F_IO_DTV) {\r\nif (!strncmp(entity->name, DVR_TSOUT,\r\nstrlen(DVR_TSOUT))) {\r\nret = media_create_pad_link(demux,\r\n++dvr_pad,\r\nentity, 0, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!strncmp(entity->name, DEMUX_TSOUT,\r\nstrlen(DEMUX_TSOUT))) {\r\nret = media_create_pad_link(demux,\r\n++demux_pad,\r\nentity, 0, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n}\r\n}\r\nmedia_device_for_each_intf(intf, mdev) {\r\nif (intf->type == MEDIA_INTF_T_DVB_CA && ca) {\r\nlink = media_create_intf_link(ca, intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link)\r\nreturn -ENOMEM;\r\n}\r\nif (intf->type == MEDIA_INTF_T_DVB_FE && tuner) {\r\nlink = media_create_intf_link(tuner, intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link)\r\nreturn -ENOMEM;\r\n}\r\n#if 0\r\nif (intf->type == MEDIA_INTF_T_DVB_DVR && demux) {\r\nlink = media_create_intf_link(demux, intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link)\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nif (intf->type == MEDIA_INTF_T_DVB_DVR) {\r\nret = dvb_create_io_intf_links(adap, intf, DVR_TSOUT);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (intf->type == MEDIA_INTF_T_DVB_DEMUX) {\r\nret = dvb_create_io_intf_links(adap, intf, DEMUX_TSOUT);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvbdev_check_free_adapter_num(int num)\r\n{\r\nstruct list_head *entry;\r\nlist_for_each(entry, &dvb_adapter_list) {\r\nstruct dvb_adapter *adap;\r\nadap = list_entry(entry, struct dvb_adapter, list_head);\r\nif (adap->num == num)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int dvbdev_get_free_adapter_num (void)\r\n{\r\nint num = 0;\r\nwhile (num < DVB_MAX_ADAPTERS) {\r\nif (dvbdev_check_free_adapter_num(num))\r\nreturn num;\r\nnum++;\r\n}\r\nreturn -ENFILE;\r\n}\r\nint dvb_register_adapter(struct dvb_adapter *adap, const char *name,\r\nstruct module *module, struct device *device,\r\nshort *adapter_nums)\r\n{\r\nint i, num;\r\nmutex_lock(&dvbdev_register_lock);\r\nfor (i = 0; i < DVB_MAX_ADAPTERS; ++i) {\r\nnum = adapter_nums[i];\r\nif (num >= 0 && num < DVB_MAX_ADAPTERS) {\r\nif (dvbdev_check_free_adapter_num(num))\r\nbreak;\r\n} else {\r\nnum = dvbdev_get_free_adapter_num();\r\nbreak;\r\n}\r\nnum = -1;\r\n}\r\nif (num < 0) {\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn -ENFILE;\r\n}\r\nmemset (adap, 0, sizeof(struct dvb_adapter));\r\nINIT_LIST_HEAD (&adap->device_list);\r\nprintk(KERN_INFO "DVB: registering new adapter (%s)\n", name);\r\nadap->num = num;\r\nadap->name = name;\r\nadap->module = module;\r\nadap->device = device;\r\nadap->mfe_shared = 0;\r\nadap->mfe_dvbdev = NULL;\r\nmutex_init (&adap->mfe_lock);\r\nlist_add_tail (&adap->list_head, &dvb_adapter_list);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn num;\r\n}\r\nint dvb_unregister_adapter(struct dvb_adapter *adap)\r\n{\r\nmutex_lock(&dvbdev_register_lock);\r\nlist_del (&adap->list_head);\r\nmutex_unlock(&dvbdev_register_lock);\r\nreturn 0;\r\n}\r\nint dvb_usercopy(struct file *file,\r\nunsigned int cmd, unsigned long arg,\r\nint (*func)(struct file *file,\r\nunsigned int cmd, void *arg))\r\n{\r\nchar sbuf[128];\r\nvoid *mbuf = NULL;\r\nvoid *parg = NULL;\r\nint err = -EINVAL;\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_NONE:\r\nparg = (void *) arg;\r\nbreak;\r\ncase _IOC_READ:\r\ncase _IOC_WRITE:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\r\nparg = sbuf;\r\n} else {\r\nmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\r\nif (NULL == mbuf)\r\nreturn -ENOMEM;\r\nparg = mbuf;\r\n}\r\nerr = -EFAULT;\r\nif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\r\ngoto out;\r\nbreak;\r\n}\r\nif ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)\r\nerr = -ENOTTY;\r\nif (err < 0)\r\ngoto out;\r\nswitch (_IOC_DIR(cmd))\r\n{\r\ncase _IOC_READ:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nout:\r\nkfree(mbuf);\r\nreturn err;\r\n}\r\nstatic int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct dvb_device *dvbdev = dev_get_drvdata(dev);\r\nadd_uevent_var(env, "DVB_ADAPTER_NUM=%d", dvbdev->adapter->num);\r\nadd_uevent_var(env, "DVB_DEVICE_TYPE=%s", dnames[dvbdev->type]);\r\nadd_uevent_var(env, "DVB_DEVICE_NUM=%d", dvbdev->id);\r\nreturn 0;\r\n}\r\nstatic char *dvb_devnode(struct device *dev, umode_t *mode)\r\n{\r\nstruct dvb_device *dvbdev = dev_get_drvdata(dev);\r\nreturn kasprintf(GFP_KERNEL, "dvb/adapter%d/%s%d",\r\ndvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);\r\n}\r\nstatic int __init init_dvbdev(void)\r\n{\r\nint retval;\r\ndev_t dev = MKDEV(DVB_MAJOR, 0);\r\nif ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {\r\nprintk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);\r\nreturn retval;\r\n}\r\ncdev_init(&dvb_device_cdev, &dvb_device_fops);\r\nif ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {\r\nprintk(KERN_ERR "dvb-core: unable register character device\n");\r\ngoto error;\r\n}\r\ndvb_class = class_create(THIS_MODULE, "dvb");\r\nif (IS_ERR(dvb_class)) {\r\nretval = PTR_ERR(dvb_class);\r\ngoto error;\r\n}\r\ndvb_class->dev_uevent = dvb_uevent;\r\ndvb_class->devnode = dvb_devnode;\r\nreturn 0;\r\nerror:\r\ncdev_del(&dvb_device_cdev);\r\nunregister_chrdev_region(dev, MAX_DVB_MINORS);\r\nreturn retval;\r\n}\r\nstatic void __exit exit_dvbdev(void)\r\n{\r\nclass_destroy(dvb_class);\r\ncdev_del(&dvb_device_cdev);\r\nunregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);\r\n}
