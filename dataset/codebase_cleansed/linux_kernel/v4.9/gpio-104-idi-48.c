static int idi_48_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn 1;\r\n}\r\nstatic int idi_48_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic int idi_48_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct idi_48_gpio *const idi48gpio = gpiochip_get_data(chip);\r\nunsigned i;\r\nconst unsigned register_offset[6] = { 0, 1, 2, 4, 5, 6 };\r\nunsigned base_offset;\r\nunsigned mask;\r\nfor (i = 0; i < 48; i += 8)\r\nif (offset < i + 8) {\r\nbase_offset = register_offset[i / 8];\r\nmask = BIT(offset - i);\r\nreturn !!(inb(idi48gpio->base + base_offset) & mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic void idi_48_irq_ack(struct irq_data *data)\r\n{\r\n}\r\nstatic void idi_48_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idi_48_gpio *const idi48gpio = gpiochip_get_data(chip);\r\nconst unsigned offset = irqd_to_hwirq(data);\r\nunsigned i;\r\nunsigned mask;\r\nunsigned boundary;\r\nunsigned long flags;\r\nfor (i = 0; i < 48; i += 8)\r\nif (offset < i + 8) {\r\nmask = BIT(offset - i);\r\nboundary = i / 8;\r\nidi48gpio->irq_mask[boundary] &= ~mask;\r\nif (!idi48gpio->irq_mask[boundary]) {\r\nidi48gpio->cos_enb &= ~BIT(boundary);\r\nspin_lock_irqsave(&idi48gpio->lock, flags);\r\noutb(idi48gpio->cos_enb, idi48gpio->base + 7);\r\nspin_unlock_irqrestore(&idi48gpio->lock, flags);\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic void idi_48_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idi_48_gpio *const idi48gpio = gpiochip_get_data(chip);\r\nconst unsigned offset = irqd_to_hwirq(data);\r\nunsigned i;\r\nunsigned mask;\r\nunsigned boundary;\r\nunsigned prev_irq_mask;\r\nunsigned long flags;\r\nfor (i = 0; i < 48; i += 8)\r\nif (offset < i + 8) {\r\nmask = BIT(offset - i);\r\nboundary = i / 8;\r\nprev_irq_mask = idi48gpio->irq_mask[boundary];\r\nidi48gpio->irq_mask[boundary] |= mask;\r\nif (!prev_irq_mask) {\r\nidi48gpio->cos_enb |= BIT(boundary);\r\nspin_lock_irqsave(&idi48gpio->lock, flags);\r\noutb(idi48gpio->cos_enb, idi48gpio->base + 7);\r\nspin_unlock_irqrestore(&idi48gpio->lock, flags);\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic int idi_48_irq_set_type(struct irq_data *data, unsigned flow_type)\r\n{\r\nif (flow_type != IRQ_TYPE_NONE &&\r\n(flow_type & IRQ_TYPE_EDGE_BOTH) != IRQ_TYPE_EDGE_BOTH)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t idi_48_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct idi_48_gpio *const idi48gpio = dev_id;\r\nunsigned long cos_status;\r\nunsigned long boundary;\r\nunsigned long irq_mask;\r\nunsigned long bit_num;\r\nunsigned long gpio;\r\nstruct gpio_chip *const chip = &idi48gpio->chip;\r\nspin_lock(&idi48gpio->ack_lock);\r\nspin_lock(&idi48gpio->lock);\r\ncos_status = inb(idi48gpio->base + 7);\r\nspin_unlock(&idi48gpio->lock);\r\nif (cos_status & BIT(6)) {\r\nspin_unlock(&idi48gpio->ack_lock);\r\nreturn IRQ_NONE;\r\n}\r\ncos_status &= 0x3F;\r\nfor_each_set_bit(boundary, &cos_status, 6) {\r\nirq_mask = idi48gpio->irq_mask[boundary];\r\nfor_each_set_bit(bit_num, &irq_mask, 8) {\r\ngpio = bit_num + boundary * 8;\r\ngeneric_handle_irq(irq_find_mapping(chip->irqdomain,\r\ngpio));\r\n}\r\n}\r\nspin_unlock(&idi48gpio->ack_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int idi_48_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct idi_48_gpio *idi48gpio;\r\nconst char *const name = dev_name(dev);\r\nint err;\r\nidi48gpio = devm_kzalloc(dev, sizeof(*idi48gpio), GFP_KERNEL);\r\nif (!idi48gpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], IDI_48_EXTENT, name)) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + IDI_48_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nidi48gpio->chip.label = name;\r\nidi48gpio->chip.parent = dev;\r\nidi48gpio->chip.owner = THIS_MODULE;\r\nidi48gpio->chip.base = -1;\r\nidi48gpio->chip.ngpio = 48;\r\nidi48gpio->chip.get_direction = idi_48_gpio_get_direction;\r\nidi48gpio->chip.direction_input = idi_48_gpio_direction_input;\r\nidi48gpio->chip.get = idi_48_gpio_get;\r\nidi48gpio->base = base[id];\r\nidi48gpio->irq = irq[id];\r\nspin_lock_init(&idi48gpio->lock);\r\nspin_lock_init(&idi48gpio->ack_lock);\r\ndev_set_drvdata(dev, idi48gpio);\r\nerr = gpiochip_add_data(&idi48gpio->chip, idi48gpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\noutb(0, base[id] + 7);\r\ninb(base[id] + 7);\r\nerr = gpiochip_irqchip_add(&idi48gpio->chip, &idi_48_irqchip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(dev, "Could not add irqchip (%d)\n", err);\r\ngoto err_gpiochip_remove;\r\n}\r\nerr = request_irq(irq[id], idi_48_irq_handler, IRQF_SHARED, name,\r\nidi48gpio);\r\nif (err) {\r\ndev_err(dev, "IRQ handler registering failed (%d)\n", err);\r\ngoto err_gpiochip_remove;\r\n}\r\nreturn 0;\r\nerr_gpiochip_remove:\r\ngpiochip_remove(&idi48gpio->chip);\r\nreturn err;\r\n}\r\nstatic int idi_48_remove(struct device *dev, unsigned int id)\r\n{\r\nstruct idi_48_gpio *const idi48gpio = dev_get_drvdata(dev);\r\nfree_irq(idi48gpio->irq, idi48gpio);\r\ngpiochip_remove(&idi48gpio->chip);\r\nreturn 0;\r\n}
