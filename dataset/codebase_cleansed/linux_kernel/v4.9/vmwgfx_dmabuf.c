int vmw_dmabuf_pin_in_placement(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nstruct ttm_placement *placement,\r\nbool interruptible)\r\n{\r\nstruct ttm_buffer_object *bo = &buf->base;\r\nint ret;\r\nuint32_t new_flags;\r\nret = ttm_write_lock(&dev_priv->reservation_sem, interruptible);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\nret = ttm_bo_reserve(bo, interruptible, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto err;\r\nif (buf->pin_count > 0)\r\nret = ttm_bo_mem_compat(placement, &bo->mem,\r\n&new_flags) == true ? 0 : -EINVAL;\r\nelse\r\nret = ttm_bo_validate(bo, placement, interruptible, false);\r\nif (!ret)\r\nvmw_bo_pin_reserved(buf, true);\r\nttm_bo_unreserve(bo);\r\nerr:\r\nttm_write_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nint vmw_dmabuf_pin_in_vram_or_gmr(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool interruptible)\r\n{\r\nstruct ttm_buffer_object *bo = &buf->base;\r\nint ret;\r\nuint32_t new_flags;\r\nret = ttm_write_lock(&dev_priv->reservation_sem, interruptible);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\nret = ttm_bo_reserve(bo, interruptible, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto err;\r\nif (buf->pin_count > 0) {\r\nret = ttm_bo_mem_compat(&vmw_vram_gmr_placement, &bo->mem,\r\n&new_flags) == true ? 0 : -EINVAL;\r\ngoto out_unreserve;\r\n}\r\nret = ttm_bo_validate(bo, &vmw_vram_gmr_placement, interruptible,\r\nfalse);\r\nif (likely(ret == 0) || ret == -ERESTARTSYS)\r\ngoto out_unreserve;\r\nret = ttm_bo_validate(bo, &vmw_vram_placement, interruptible, false);\r\nout_unreserve:\r\nif (!ret)\r\nvmw_bo_pin_reserved(buf, true);\r\nttm_bo_unreserve(bo);\r\nerr:\r\nttm_write_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nint vmw_dmabuf_pin_in_vram(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool interruptible)\r\n{\r\nreturn vmw_dmabuf_pin_in_placement(dev_priv, buf, &vmw_vram_placement,\r\ninterruptible);\r\n}\r\nint vmw_dmabuf_pin_in_start_of_vram(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool interruptible)\r\n{\r\nstruct ttm_buffer_object *bo = &buf->base;\r\nstruct ttm_placement placement;\r\nstruct ttm_place place;\r\nint ret = 0;\r\nuint32_t new_flags;\r\nplace = vmw_vram_placement.placement[0];\r\nplace.lpfn = bo->num_pages;\r\nplacement.num_placement = 1;\r\nplacement.placement = &place;\r\nplacement.num_busy_placement = 1;\r\nplacement.busy_placement = &place;\r\nret = ttm_write_lock(&dev_priv->reservation_sem, interruptible);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\nret = ttm_bo_reserve(bo, interruptible, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto err_unlock;\r\nif (bo->mem.mem_type == TTM_PL_VRAM &&\r\nbo->mem.start < bo->num_pages &&\r\nbo->mem.start > 0 &&\r\nbuf->pin_count == 0)\r\n(void) ttm_bo_validate(bo, &vmw_sys_placement, false, false);\r\nif (buf->pin_count > 0)\r\nret = ttm_bo_mem_compat(&placement, &bo->mem,\r\n&new_flags) == true ? 0 : -EINVAL;\r\nelse\r\nret = ttm_bo_validate(bo, &placement, interruptible, false);\r\nWARN_ON(ret == 0 && bo->offset != 0);\r\nif (!ret)\r\nvmw_bo_pin_reserved(buf, true);\r\nttm_bo_unreserve(bo);\r\nerr_unlock:\r\nttm_write_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nint vmw_dmabuf_unpin(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool interruptible)\r\n{\r\nstruct ttm_buffer_object *bo = &buf->base;\r\nint ret;\r\nret = ttm_read_lock(&dev_priv->reservation_sem, interruptible);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_bo_reserve(bo, interruptible, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto err;\r\nvmw_bo_pin_reserved(buf, false);\r\nttm_bo_unreserve(bo);\r\nerr:\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nvoid vmw_bo_get_guest_ptr(const struct ttm_buffer_object *bo,\r\nSVGAGuestPtr *ptr)\r\n{\r\nif (bo->mem.mem_type == TTM_PL_VRAM) {\r\nptr->gmrId = SVGA_GMR_FRAMEBUFFER;\r\nptr->offset = bo->offset;\r\n} else {\r\nptr->gmrId = bo->mem.start;\r\nptr->offset = 0;\r\n}\r\n}\r\nvoid vmw_bo_pin_reserved(struct vmw_dma_buffer *vbo, bool pin)\r\n{\r\nstruct ttm_place pl;\r\nstruct ttm_placement placement;\r\nstruct ttm_buffer_object *bo = &vbo->base;\r\nuint32_t old_mem_type = bo->mem.mem_type;\r\nint ret;\r\nlockdep_assert_held(&bo->resv->lock.base);\r\nif (pin) {\r\nif (vbo->pin_count++ > 0)\r\nreturn;\r\n} else {\r\nWARN_ON(vbo->pin_count <= 0);\r\nif (--vbo->pin_count > 0)\r\nreturn;\r\n}\r\npl.fpfn = 0;\r\npl.lpfn = 0;\r\npl.flags = TTM_PL_FLAG_VRAM | VMW_PL_FLAG_GMR | VMW_PL_FLAG_MOB\r\n| TTM_PL_FLAG_SYSTEM | TTM_PL_FLAG_CACHED;\r\nif (pin)\r\npl.flags |= TTM_PL_FLAG_NO_EVICT;\r\nmemset(&placement, 0, sizeof(placement));\r\nplacement.num_placement = 1;\r\nplacement.placement = &pl;\r\nret = ttm_bo_validate(bo, &placement, false, true);\r\nBUG_ON(ret != 0 || bo->mem.mem_type != old_mem_type);\r\n}
