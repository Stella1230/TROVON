static void sdhci_at91_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nu16 clk;\r\nunsigned long timeout;\r\nhost->mmc->actual_clock = 0;\r\nclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\r\nclk &= SDHCI_CLOCK_INT_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\nif (clock == 0)\r\nreturn;\r\nclk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);\r\nclk |= SDHCI_CLOCK_INT_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\ntimeout = 20;\r\nwhile (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))\r\n& SDHCI_CLOCK_INT_STABLE)) {\r\nif (timeout == 0) {\r\npr_err("%s: Internal clock never stabilised.\n",\r\nmmc_hostname(host->mmc));\r\nreturn;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nclk |= SDHCI_CLOCK_CARD_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\n}\r\nstatic int sdhci_at91_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\r\nint ret;\r\nret = sdhci_runtime_suspend_host(host);\r\nclk_disable_unprepare(priv->gck);\r\nclk_disable_unprepare(priv->hclock);\r\nclk_disable_unprepare(priv->mainck);\r\nreturn ret;\r\n}\r\nstatic int sdhci_at91_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\r\nint ret;\r\nret = clk_prepare_enable(priv->mainck);\r\nif (ret) {\r\ndev_err(dev, "can't enable mainck\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(priv->hclock);\r\nif (ret) {\r\ndev_err(dev, "can't enable hclock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(priv->gck);\r\nif (ret) {\r\ndev_err(dev, "can't enable gck\n");\r\nreturn ret;\r\n}\r\nreturn sdhci_runtime_resume_host(host);\r\n}\r\nstatic int sdhci_at91_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct sdhci_pltfm_data *soc_data;\r\nstruct sdhci_host *host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_at91_priv *priv;\r\nunsigned int caps0, caps1;\r\nunsigned int clk_base, clk_mul;\r\nunsigned int gck_rate, real_gck_rate;\r\nint ret;\r\nunsigned int preset_div;\r\nmatch = of_match_device(sdhci_at91_dt_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nsoc_data = match->data;\r\nhost = sdhci_pltfm_init(pdev, soc_data, sizeof(*priv));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\npriv = sdhci_pltfm_priv(pltfm_host);\r\npriv->mainck = devm_clk_get(&pdev->dev, "baseclk");\r\nif (IS_ERR(priv->mainck)) {\r\ndev_err(&pdev->dev, "failed to get baseclk\n");\r\nreturn PTR_ERR(priv->mainck);\r\n}\r\npriv->hclock = devm_clk_get(&pdev->dev, "hclock");\r\nif (IS_ERR(priv->hclock)) {\r\ndev_err(&pdev->dev, "failed to get hclock\n");\r\nreturn PTR_ERR(priv->hclock);\r\n}\r\npriv->gck = devm_clk_get(&pdev->dev, "multclk");\r\nif (IS_ERR(priv->gck)) {\r\ndev_err(&pdev->dev, "failed to get multclk\n");\r\nreturn PTR_ERR(priv->gck);\r\n}\r\nclk_prepare_enable(priv->hclock);\r\ncaps0 = readl(host->ioaddr + SDHCI_CAPABILITIES);\r\ncaps1 = readl(host->ioaddr + SDHCI_CAPABILITIES_1);\r\nclk_base = (caps0 & SDHCI_CLOCK_V3_BASE_MASK) >> SDHCI_CLOCK_BASE_SHIFT;\r\nclk_mul = (caps1 & SDHCI_CLOCK_MUL_MASK) >> SDHCI_CLOCK_MUL_SHIFT;\r\ngck_rate = clk_base * 1000000 * (clk_mul + 1);\r\nret = clk_set_rate(priv->gck, gck_rate);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set gck");\r\ngoto hclock_disable_unprepare;\r\n}\r\nreal_gck_rate = clk_get_rate(priv->gck);\r\nif (real_gck_rate != gck_rate) {\r\nclk_mul = real_gck_rate / (clk_base * 1000000) - 1;\r\ncaps1 &= (~SDHCI_CLOCK_MUL_MASK);\r\ncaps1 |= ((clk_mul << SDHCI_CLOCK_MUL_SHIFT) & SDHCI_CLOCK_MUL_MASK);\r\nwritel(SDMMC_CACR_KEY | SDMMC_CACR_CAPWREN, host->ioaddr + SDMMC_CACR);\r\nwritel(caps1, host->ioaddr + SDHCI_CAPABILITIES_1);\r\nwritel(0, host->ioaddr + SDMMC_CACR);\r\ndev_info(&pdev->dev, "update clk mul to %u as gck rate is %u Hz\n",\r\nclk_mul, real_gck_rate);\r\n}\r\npreset_div = DIV_ROUND_UP(real_gck_rate, 24000000) - 1;\r\nwritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\r\nhost->ioaddr + SDHCI_PRESET_FOR_SDR12);\r\npreset_div = DIV_ROUND_UP(real_gck_rate, 50000000) - 1;\r\nwritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\r\nhost->ioaddr + SDHCI_PRESET_FOR_SDR25);\r\npreset_div = DIV_ROUND_UP(real_gck_rate, 100000000) - 1;\r\nwritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\r\nhost->ioaddr + SDHCI_PRESET_FOR_SDR50);\r\npreset_div = DIV_ROUND_UP(real_gck_rate, 120000000) - 1;\r\nwritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\r\nhost->ioaddr + SDHCI_PRESET_FOR_SDR104);\r\npreset_div = DIV_ROUND_UP(real_gck_rate, 50000000) - 1;\r\nwritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\r\nhost->ioaddr + SDHCI_PRESET_FOR_DDR50);\r\nclk_prepare_enable(priv->mainck);\r\nclk_prepare_enable(priv->gck);\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto clocks_disable_unprepare;\r\nsdhci_get_of_property(pdev);\r\npm_runtime_get_noresume(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto pm_runtime_disable;\r\nif (mmc_card_is_removable(host->mmc) &&\r\nmmc_gpio_get_cd(host->mmc) < 0) {\r\nhost->mmc->caps |= MMC_CAP_NEEDS_POLL;\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\n}\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\npm_runtime_disable:\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nclocks_disable_unprepare:\r\nclk_disable_unprepare(priv->gck);\r\nclk_disable_unprepare(priv->mainck);\r\nhclock_disable_unprepare:\r\nclk_disable_unprepare(priv->hclock);\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_at91_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\r\nstruct clk *gck = priv->gck;\r\nstruct clk *hclock = priv->hclock;\r\nstruct clk *mainck = priv->mainck;\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nsdhci_pltfm_unregister(pdev);\r\nclk_disable_unprepare(gck);\r\nclk_disable_unprepare(hclock);\r\nclk_disable_unprepare(mainck);\r\nreturn 0;\r\n}
