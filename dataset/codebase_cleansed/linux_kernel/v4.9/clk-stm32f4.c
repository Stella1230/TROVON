static unsigned long clk_apb_mul_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_apb_mul *am = to_clk_apb_mul(hw);\r\nif (readl(base + STM32F4_RCC_CFGR) & BIT(am->bit_idx))\r\nreturn parent_rate * 2;\r\nreturn parent_rate;\r\n}\r\nstatic long clk_apb_mul_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_apb_mul *am = to_clk_apb_mul(hw);\r\nunsigned long mult = 1;\r\nif (readl(base + STM32F4_RCC_CFGR) & BIT(am->bit_idx))\r\nmult = 2;\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\r\nunsigned long best_parent = rate / mult;\r\n*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\r\n}\r\nreturn *prate * mult;\r\n}\r\nstatic int clk_apb_mul_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct clk *clk_register_apb_mul(struct device *dev, const char *name,\r\nconst char *parent_name,\r\nunsigned long flags, u8 bit_idx)\r\n{\r\nstruct clk_apb_mul *am;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nam = kzalloc(sizeof(*am), GFP_KERNEL);\r\nif (!am)\r\nreturn ERR_PTR(-ENOMEM);\r\nam->bit_idx = bit_idx;\r\nam->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = &clk_apb_mul_factor_ops;\r\ninit.flags = flags;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(dev, &am->hw);\r\nif (IS_ERR(clk))\r\nkfree(am);\r\nreturn clk;\r\n}\r\nstatic void stm32f4_rcc_register_pll(const char *hse_clk, const char *hsi_clk)\r\n{\r\nunsigned long pllcfgr = readl(base + STM32F4_RCC_PLLCFGR);\r\nunsigned long pllm = pllcfgr & 0x3f;\r\nunsigned long plln = (pllcfgr >> 6) & 0x1ff;\r\nunsigned long pllp = BIT(((pllcfgr >> 16) & 3) + 1);\r\nconst char *pllsrc = pllcfgr & BIT(22) ? hse_clk : hsi_clk;\r\nunsigned long pllq = (pllcfgr >> 24) & 0xf;\r\nclk_register_fixed_factor(NULL, "vco", pllsrc, 0, plln, pllm);\r\nclk_register_fixed_factor(NULL, "pll", "vco", 0, 1, pllp);\r\nclk_register_fixed_factor(NULL, "pll48", "vco", 0, 1, pllq);\r\n}\r\nstatic int stm32f4_rcc_lookup_clk_idx(u8 primary, u8 secondary)\r\n{\r\nu64 table[ARRAY_SIZE(stm32f42xx_gate_map)];\r\nif (primary == 1) {\r\nif (WARN_ON(secondary > FCLK))\r\nreturn -EINVAL;\r\nreturn secondary;\r\n}\r\nmemcpy(table, stm32f42xx_gate_map, sizeof(table));\r\nif (WARN_ON(secondary >= BITS_PER_BYTE * sizeof(table) ||\r\n0 == (table[BIT_ULL_WORD(secondary)] &\r\nBIT_ULL_MASK(secondary))))\r\nreturn -EINVAL;\r\ntable[BIT_ULL_WORD(secondary)] &=\r\nGENMASK_ULL(secondary % BITS_PER_LONG_LONG, 0);\r\nreturn FCLK + hweight64(table[0]) +\r\n(BIT_ULL_WORD(secondary) >= 1 ? hweight64(table[1]) : 0) +\r\n(BIT_ULL_WORD(secondary) >= 2 ? hweight64(table[2]) : 0);\r\n}\r\nstatic struct clk_hw *\r\nstm32f4_rcc_lookup_clk(struct of_phandle_args *clkspec, void *data)\r\n{\r\nint i = stm32f4_rcc_lookup_clk_idx(clkspec->args[0], clkspec->args[1]);\r\nif (i < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn clks[i];\r\n}\r\nstatic void __init stm32f4_rcc_init(struct device_node *np)\r\n{\r\nconst char *hse_clk;\r\nint n;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("%s: unable to map resource", np->name);\r\nreturn;\r\n}\r\nhse_clk = of_clk_get_parent_name(np, 0);\r\nclk_register_fixed_rate_with_accuracy(NULL, "hsi", NULL, 0,\r\n16000000, 160000);\r\nstm32f4_rcc_register_pll(hse_clk, "hsi");\r\nsys_parents[1] = hse_clk;\r\nclk_register_mux_table(\r\nNULL, "sys", sys_parents, ARRAY_SIZE(sys_parents), 0,\r\nbase + STM32F4_RCC_CFGR, 0, 3, 0, NULL, &stm32f4_clk_lock);\r\nclk_register_divider_table(NULL, "ahb_div", "sys",\r\nCLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\r\n4, 4, 0, ahb_div_table, &stm32f4_clk_lock);\r\nclk_register_divider_table(NULL, "apb1_div", "ahb_div",\r\nCLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\r\n10, 3, 0, apb_div_table, &stm32f4_clk_lock);\r\nclk_register_apb_mul(NULL, "apb1_mul", "apb1_div",\r\nCLK_SET_RATE_PARENT, 12);\r\nclk_register_divider_table(NULL, "apb2_div", "ahb_div",\r\nCLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\r\n13, 3, 0, apb_div_table, &stm32f4_clk_lock);\r\nclk_register_apb_mul(NULL, "apb2_mul", "apb2_div",\r\nCLK_SET_RATE_PARENT, 15);\r\nclks[SYSTICK] = clk_hw_register_fixed_factor(NULL, "systick", "ahb_div",\r\n0, 1, 8);\r\nclks[FCLK] = clk_hw_register_fixed_factor(NULL, "fclk", "ahb_div",\r\n0, 1, 1);\r\nfor (n = 0; n < ARRAY_SIZE(stm32f4_gates); n++) {\r\nconst struct stm32f4_gate_data *gd = &stm32f4_gates[n];\r\nunsigned int secondary =\r\n8 * (gd->offset - STM32F4_RCC_AHB1ENR) + gd->bit_idx;\r\nint idx = stm32f4_rcc_lookup_clk_idx(0, secondary);\r\nif (idx < 0)\r\ngoto fail;\r\nclks[idx] = clk_hw_register_gate(\r\nNULL, gd->name, gd->parent_name, gd->flags,\r\nbase + gd->offset, gd->bit_idx, 0, &stm32f4_clk_lock);\r\nif (IS_ERR(clks[idx])) {\r\npr_err("%s: Unable to register leaf clock %s\n",\r\nnp->full_name, gd->name);\r\ngoto fail;\r\n}\r\n}\r\nof_clk_add_hw_provider(np, stm32f4_rcc_lookup_clk, NULL);\r\nreturn;\r\nfail:\r\niounmap(base);\r\n}
