static int iucv_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int __iucv_call_b2f0(int command, union iucv_param *parm)\r\n{\r\nregister unsigned long reg0 asm ("0");\r\nregister unsigned long reg1 asm ("1");\r\nint ccode;\r\nreg0 = command;\r\nreg1 = (unsigned long)parm;\r\nasm volatile(\r\n" .long 0xb2f01000\n"\r\n" ipm %0\n"\r\n" srl %0,28\n"\r\n: "=d" (ccode), "=m" (*parm), "+d" (reg0), "+a" (reg1)\r\n: "m" (*parm) : "cc");\r\nreturn ccode;\r\n}\r\nstatic inline int iucv_call_b2f0(int command, union iucv_param *parm)\r\n{\r\nint ccode;\r\nccode = __iucv_call_b2f0(command, parm);\r\nreturn ccode == 1 ? parm->ctrl.iprcode : ccode;\r\n}\r\nstatic int __iucv_query_maxconn(void *param, unsigned long *max_pathid)\r\n{\r\nregister unsigned long reg0 asm ("0");\r\nregister unsigned long reg1 asm ("1");\r\nint ccode;\r\nreg0 = IUCV_QUERY;\r\nreg1 = (unsigned long) param;\r\nasm volatile (\r\n" .long 0xb2f01000\n"\r\n" ipm %0\n"\r\n" srl %0,28\n"\r\n: "=d" (ccode), "+d" (reg0), "+d" (reg1) : : "cc");\r\n*max_pathid = reg1;\r\nreturn ccode;\r\n}\r\nstatic int iucv_query_maxconn(void)\r\n{\r\nunsigned long max_pathid;\r\nvoid *param;\r\nint ccode;\r\nparam = kzalloc(sizeof(union iucv_param), GFP_KERNEL | GFP_DMA);\r\nif (!param)\r\nreturn -ENOMEM;\r\nccode = __iucv_query_maxconn(param, &max_pathid);\r\nif (ccode == 0)\r\niucv_max_pathid = max_pathid;\r\nkfree(param);\r\nreturn ccode ? -EPERM : 0;\r\n}\r\nstatic void iucv_allow_cpu(void *data)\r\n{\r\nint cpu = smp_processor_id();\r\nunion iucv_param *parm;\r\nparm = iucv_param_irq[cpu];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->set_mask.ipmask = 0xf8;\r\niucv_call_b2f0(IUCV_SETMASK, parm);\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->set_mask.ipmask = 0xf8;\r\niucv_call_b2f0(IUCV_SETCONTROLMASK, parm);\r\ncpumask_set_cpu(cpu, &iucv_irq_cpumask);\r\n}\r\nstatic void iucv_block_cpu(void *data)\r\n{\r\nint cpu = smp_processor_id();\r\nunion iucv_param *parm;\r\nparm = iucv_param_irq[cpu];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\niucv_call_b2f0(IUCV_SETMASK, parm);\r\ncpumask_clear_cpu(cpu, &iucv_irq_cpumask);\r\n}\r\nstatic void iucv_block_cpu_almost(void *data)\r\n{\r\nint cpu = smp_processor_id();\r\nunion iucv_param *parm;\r\nparm = iucv_param_irq[cpu];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->set_mask.ipmask = 0x08;\r\niucv_call_b2f0(IUCV_SETMASK, parm);\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->set_mask.ipmask = 0x20;\r\niucv_call_b2f0(IUCV_SETCONTROLMASK, parm);\r\ncpumask_clear_cpu(cpu, &iucv_irq_cpumask);\r\n}\r\nstatic void iucv_declare_cpu(void *data)\r\n{\r\nint cpu = smp_processor_id();\r\nunion iucv_param *parm;\r\nint rc;\r\nif (cpumask_test_cpu(cpu, &iucv_buffer_cpumask))\r\nreturn;\r\nparm = iucv_param_irq[cpu];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->db.ipbfadr1 = virt_to_phys(iucv_irq_data[cpu]);\r\nrc = iucv_call_b2f0(IUCV_DECLARE_BUFFER, parm);\r\nif (rc) {\r\nchar *err = "Unknown";\r\nswitch (rc) {\r\ncase 0x03:\r\nerr = "Directory error";\r\nbreak;\r\ncase 0x0a:\r\nerr = "Invalid length";\r\nbreak;\r\ncase 0x13:\r\nerr = "Buffer already exists";\r\nbreak;\r\ncase 0x3e:\r\nerr = "Buffer overlap";\r\nbreak;\r\ncase 0x5c:\r\nerr = "Paging or storage error";\r\nbreak;\r\n}\r\npr_warn("Defining an interrupt buffer on CPU %i failed with 0x%02x (%s)\n",\r\ncpu, rc, err);\r\nreturn;\r\n}\r\ncpumask_set_cpu(cpu, &iucv_buffer_cpumask);\r\nif (iucv_nonsmp_handler == 0 || cpumask_empty(&iucv_irq_cpumask))\r\niucv_allow_cpu(NULL);\r\nelse\r\niucv_block_cpu(NULL);\r\n}\r\nstatic void iucv_retrieve_cpu(void *data)\r\n{\r\nint cpu = smp_processor_id();\r\nunion iucv_param *parm;\r\nif (!cpumask_test_cpu(cpu, &iucv_buffer_cpumask))\r\nreturn;\r\niucv_block_cpu(NULL);\r\nparm = iucv_param_irq[cpu];\r\niucv_call_b2f0(IUCV_RETRIEVE_BUFFER, parm);\r\ncpumask_clear_cpu(cpu, &iucv_buffer_cpumask);\r\n}\r\nstatic void iucv_setmask_mp(void)\r\n{\r\nint cpu;\r\nget_online_cpus();\r\nfor_each_online_cpu(cpu)\r\nif (cpumask_test_cpu(cpu, &iucv_buffer_cpumask) &&\r\n!cpumask_test_cpu(cpu, &iucv_irq_cpumask))\r\nsmp_call_function_single(cpu, iucv_allow_cpu,\r\nNULL, 1);\r\nput_online_cpus();\r\n}\r\nstatic void iucv_setmask_up(void)\r\n{\r\ncpumask_t cpumask;\r\nint cpu;\r\ncpumask_copy(&cpumask, &iucv_irq_cpumask);\r\ncpumask_clear_cpu(cpumask_first(&iucv_irq_cpumask), &cpumask);\r\nfor_each_cpu(cpu, &cpumask)\r\nsmp_call_function_single(cpu, iucv_block_cpu, NULL, 1);\r\n}\r\nstatic int iucv_enable(void)\r\n{\r\nsize_t alloc_size;\r\nint cpu, rc;\r\nget_online_cpus();\r\nrc = -ENOMEM;\r\nalloc_size = iucv_max_pathid * sizeof(struct iucv_path);\r\niucv_path_table = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!iucv_path_table)\r\ngoto out;\r\nrc = -EIO;\r\nfor_each_online_cpu(cpu)\r\nsmp_call_function_single(cpu, iucv_declare_cpu, NULL, 1);\r\nif (cpumask_empty(&iucv_buffer_cpumask))\r\ngoto out;\r\nput_online_cpus();\r\nreturn 0;\r\nout:\r\nkfree(iucv_path_table);\r\niucv_path_table = NULL;\r\nput_online_cpus();\r\nreturn rc;\r\n}\r\nstatic void iucv_disable(void)\r\n{\r\nget_online_cpus();\r\non_each_cpu(iucv_retrieve_cpu, NULL, 1);\r\nkfree(iucv_path_table);\r\niucv_path_table = NULL;\r\nput_online_cpus();\r\n}\r\nstatic void free_iucv_data(int cpu)\r\n{\r\nkfree(iucv_param_irq[cpu]);\r\niucv_param_irq[cpu] = NULL;\r\nkfree(iucv_param[cpu]);\r\niucv_param[cpu] = NULL;\r\nkfree(iucv_irq_data[cpu]);\r\niucv_irq_data[cpu] = NULL;\r\n}\r\nstatic int alloc_iucv_data(int cpu)\r\n{\r\niucv_irq_data[cpu] = kmalloc_node(sizeof(struct iucv_irq_data),\r\nGFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\r\nif (!iucv_irq_data[cpu])\r\ngoto out_free;\r\niucv_param[cpu] = kmalloc_node(sizeof(union iucv_param),\r\nGFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\r\nif (!iucv_param[cpu])\r\ngoto out_free;\r\niucv_param_irq[cpu] = kmalloc_node(sizeof(union iucv_param),\r\nGFP_KERNEL|GFP_DMA, cpu_to_node(cpu));\r\nif (!iucv_param_irq[cpu])\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nfree_iucv_data(cpu);\r\nreturn -ENOMEM;\r\n}\r\nstatic int iucv_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\ncpumask_t cpumask;\r\nlong cpu = (long) hcpu;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\ncase CPU_UP_PREPARE_FROZEN:\r\nif (alloc_iucv_data(cpu))\r\nreturn notifier_from_errno(-ENOMEM);\r\nbreak;\r\ncase CPU_UP_CANCELED:\r\ncase CPU_UP_CANCELED_FROZEN:\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nfree_iucv_data(cpu);\r\nbreak;\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\ncase CPU_DOWN_FAILED:\r\ncase CPU_DOWN_FAILED_FROZEN:\r\nif (!iucv_path_table)\r\nbreak;\r\nsmp_call_function_single(cpu, iucv_declare_cpu, NULL, 1);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\ncase CPU_DOWN_PREPARE_FROZEN:\r\nif (!iucv_path_table)\r\nbreak;\r\ncpumask_copy(&cpumask, &iucv_buffer_cpumask);\r\ncpumask_clear_cpu(cpu, &cpumask);\r\nif (cpumask_empty(&cpumask))\r\nreturn notifier_from_errno(-EINVAL);\r\nsmp_call_function_single(cpu, iucv_retrieve_cpu, NULL, 1);\r\nif (cpumask_empty(&iucv_irq_cpumask))\r\nsmp_call_function_single(\r\ncpumask_first(&iucv_buffer_cpumask),\r\niucv_allow_cpu, NULL, 1);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int iucv_sever_pathid(u16 pathid, u8 *userdata)\r\n{\r\nunion iucv_param *parm;\r\nparm = iucv_param_irq[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (userdata)\r\nmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\r\nparm->ctrl.ippathid = pathid;\r\nreturn iucv_call_b2f0(IUCV_SEVER, parm);\r\n}\r\nstatic void __iucv_cleanup_queue(void *dummy)\r\n{\r\n}\r\nstatic void iucv_cleanup_queue(void)\r\n{\r\nstruct iucv_irq_list *p, *n;\r\nsmp_call_function(__iucv_cleanup_queue, NULL, 1);\r\nspin_lock_irq(&iucv_queue_lock);\r\nlist_for_each_entry_safe(p, n, &iucv_task_queue, list) {\r\nif (iucv_path_table[p->data.ippathid] == NULL) {\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\n}\r\nspin_unlock_irq(&iucv_queue_lock);\r\n}\r\nint iucv_register(struct iucv_handler *handler, int smp)\r\n{\r\nint rc;\r\nif (!iucv_available)\r\nreturn -ENOSYS;\r\nmutex_lock(&iucv_register_mutex);\r\nif (!smp)\r\niucv_nonsmp_handler++;\r\nif (list_empty(&iucv_handler_list)) {\r\nrc = iucv_enable();\r\nif (rc)\r\ngoto out_mutex;\r\n} else if (!smp && iucv_nonsmp_handler == 1)\r\niucv_setmask_up();\r\nINIT_LIST_HEAD(&handler->paths);\r\nspin_lock_bh(&iucv_table_lock);\r\nlist_add_tail(&handler->list, &iucv_handler_list);\r\nspin_unlock_bh(&iucv_table_lock);\r\nrc = 0;\r\nout_mutex:\r\nmutex_unlock(&iucv_register_mutex);\r\nreturn rc;\r\n}\r\nvoid iucv_unregister(struct iucv_handler *handler, int smp)\r\n{\r\nstruct iucv_path *p, *n;\r\nmutex_lock(&iucv_register_mutex);\r\nspin_lock_bh(&iucv_table_lock);\r\nlist_del_init(&handler->list);\r\nlist_for_each_entry_safe(p, n, &handler->paths, list) {\r\niucv_sever_pathid(p->pathid, NULL);\r\niucv_path_table[p->pathid] = NULL;\r\nlist_del(&p->list);\r\niucv_path_free(p);\r\n}\r\nspin_unlock_bh(&iucv_table_lock);\r\nif (!smp)\r\niucv_nonsmp_handler--;\r\nif (list_empty(&iucv_handler_list))\r\niucv_disable();\r\nelse if (!smp && iucv_nonsmp_handler == 0)\r\niucv_setmask_mp();\r\nmutex_unlock(&iucv_register_mutex);\r\n}\r\nstatic int iucv_reboot_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nint i;\r\nif (cpumask_empty(&iucv_irq_cpumask))\r\nreturn NOTIFY_DONE;\r\nget_online_cpus();\r\non_each_cpu_mask(&iucv_irq_cpumask, iucv_block_cpu, NULL, 1);\r\npreempt_disable();\r\nfor (i = 0; i < iucv_max_pathid; i++) {\r\nif (iucv_path_table[i])\r\niucv_sever_pathid(i, NULL);\r\n}\r\npreempt_enable();\r\nput_online_cpus();\r\niucv_disable();\r\nreturn NOTIFY_DONE;\r\n}\r\nint iucv_path_accept(struct iucv_path *path, struct iucv_handler *handler,\r\nu8 *userdata, void *private)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->ctrl.ippathid = path->pathid;\r\nparm->ctrl.ipmsglim = path->msglim;\r\nif (userdata)\r\nmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\r\nparm->ctrl.ipflags1 = path->flags;\r\nrc = iucv_call_b2f0(IUCV_ACCEPT, parm);\r\nif (!rc) {\r\npath->private = private;\r\npath->msglim = parm->ctrl.ipmsglim;\r\npath->flags = parm->ctrl.ipflags1;\r\n}\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_path_connect(struct iucv_path *path, struct iucv_handler *handler,\r\nu8 *userid, u8 *system, u8 *userdata,\r\nvoid *private)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nspin_lock_bh(&iucv_table_lock);\r\niucv_cleanup_queue();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->ctrl.ipmsglim = path->msglim;\r\nparm->ctrl.ipflags1 = path->flags;\r\nif (userid) {\r\nmemcpy(parm->ctrl.ipvmid, userid, sizeof(parm->ctrl.ipvmid));\r\nASCEBC(parm->ctrl.ipvmid, sizeof(parm->ctrl.ipvmid));\r\nEBC_TOUPPER(parm->ctrl.ipvmid, sizeof(parm->ctrl.ipvmid));\r\n}\r\nif (system) {\r\nmemcpy(parm->ctrl.iptarget, system,\r\nsizeof(parm->ctrl.iptarget));\r\nASCEBC(parm->ctrl.iptarget, sizeof(parm->ctrl.iptarget));\r\nEBC_TOUPPER(parm->ctrl.iptarget, sizeof(parm->ctrl.iptarget));\r\n}\r\nif (userdata)\r\nmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\r\nrc = iucv_call_b2f0(IUCV_CONNECT, parm);\r\nif (!rc) {\r\nif (parm->ctrl.ippathid < iucv_max_pathid) {\r\npath->pathid = parm->ctrl.ippathid;\r\npath->msglim = parm->ctrl.ipmsglim;\r\npath->flags = parm->ctrl.ipflags1;\r\npath->handler = handler;\r\npath->private = private;\r\nlist_add_tail(&path->list, &handler->paths);\r\niucv_path_table[path->pathid] = path;\r\n} else {\r\niucv_sever_pathid(parm->ctrl.ippathid,\r\niucv_error_pathid);\r\nrc = -EIO;\r\n}\r\n}\r\nout:\r\nspin_unlock_bh(&iucv_table_lock);\r\nreturn rc;\r\n}\r\nint iucv_path_quiesce(struct iucv_path *path, u8 *userdata)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (userdata)\r\nmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\r\nparm->ctrl.ippathid = path->pathid;\r\nrc = iucv_call_b2f0(IUCV_QUIESCE, parm);\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_path_resume(struct iucv_path *path, u8 *userdata)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (userdata)\r\nmemcpy(parm->ctrl.ipuser, userdata, sizeof(parm->ctrl.ipuser));\r\nparm->ctrl.ippathid = path->pathid;\r\nrc = iucv_call_b2f0(IUCV_RESUME, parm);\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_path_sever(struct iucv_path *path, u8 *userdata)\r\n{\r\nint rc;\r\npreempt_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (iucv_active_cpu != smp_processor_id())\r\nspin_lock_bh(&iucv_table_lock);\r\nrc = iucv_sever_pathid(path->pathid, userdata);\r\niucv_path_table[path->pathid] = NULL;\r\nlist_del_init(&path->list);\r\nif (iucv_active_cpu != smp_processor_id())\r\nspin_unlock_bh(&iucv_table_lock);\r\nout:\r\npreempt_enable();\r\nreturn rc;\r\n}\r\nint iucv_message_purge(struct iucv_path *path, struct iucv_message *msg,\r\nu32 srccls)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->purge.ippathid = path->pathid;\r\nparm->purge.ipmsgid = msg->id;\r\nparm->purge.ipsrccls = srccls;\r\nparm->purge.ipflags1 = IUCV_IPSRCCLS | IUCV_IPFGMID | IUCV_IPFGPID;\r\nrc = iucv_call_b2f0(IUCV_PURGE, parm);\r\nif (!rc) {\r\nmsg->audit = (*(u32 *) &parm->purge.ipaudit) >> 8;\r\nmsg->tag = parm->purge.ipmsgtag;\r\n}\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nstatic int iucv_message_receive_iprmdata(struct iucv_path *path,\r\nstruct iucv_message *msg,\r\nu8 flags, void *buffer,\r\nsize_t size, size_t *residual)\r\n{\r\nstruct iucv_array *array;\r\nu8 *rmmsg;\r\nsize_t copy;\r\nif (residual)\r\n*residual = abs(size - 8);\r\nrmmsg = msg->rmmsg;\r\nif (flags & IUCV_IPBUFLST) {\r\nsize = (size < 8) ? size : 8;\r\nfor (array = buffer; size > 0; array++) {\r\ncopy = min_t(size_t, size, array->length);\r\nmemcpy((u8 *)(addr_t) array->address,\r\nrmmsg, copy);\r\nrmmsg += copy;\r\nsize -= copy;\r\n}\r\n} else {\r\nmemcpy(buffer, rmmsg, min_t(size_t, size, 8));\r\n}\r\nreturn 0;\r\n}\r\nint __iucv_message_receive(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, void *buffer, size_t size, size_t *residual)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nif (msg->flags & IUCV_IPRMDATA)\r\nreturn iucv_message_receive_iprmdata(path, msg, flags,\r\nbuffer, size, residual);\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->db.ipbfadr1 = (u32)(addr_t) buffer;\r\nparm->db.ipbfln1f = (u32) size;\r\nparm->db.ipmsgid = msg->id;\r\nparm->db.ippathid = path->pathid;\r\nparm->db.iptrgcls = msg->class;\r\nparm->db.ipflags1 = (flags | IUCV_IPFGPID |\r\nIUCV_IPFGMID | IUCV_IPTRGCLS);\r\nrc = iucv_call_b2f0(IUCV_RECEIVE, parm);\r\nif (!rc || rc == 5) {\r\nmsg->flags = parm->db.ipflags1;\r\nif (residual)\r\n*residual = parm->db.ipbfln1f;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint iucv_message_receive(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, void *buffer, size_t size, size_t *residual)\r\n{\r\nint rc;\r\nif (msg->flags & IUCV_IPRMDATA)\r\nreturn iucv_message_receive_iprmdata(path, msg, flags,\r\nbuffer, size, residual);\r\nlocal_bh_disable();\r\nrc = __iucv_message_receive(path, msg, flags, buffer, size, residual);\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_message_reject(struct iucv_path *path, struct iucv_message *msg)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nparm->db.ippathid = path->pathid;\r\nparm->db.ipmsgid = msg->id;\r\nparm->db.iptrgcls = msg->class;\r\nparm->db.ipflags1 = (IUCV_IPTRGCLS | IUCV_IPFGMID | IUCV_IPFGPID);\r\nrc = iucv_call_b2f0(IUCV_REJECT, parm);\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_message_reply(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, void *reply, size_t size)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (flags & IUCV_IPRMDATA) {\r\nparm->dpl.ippathid = path->pathid;\r\nparm->dpl.ipflags1 = flags;\r\nparm->dpl.ipmsgid = msg->id;\r\nparm->dpl.iptrgcls = msg->class;\r\nmemcpy(parm->dpl.iprmmsg, reply, min_t(size_t, size, 8));\r\n} else {\r\nparm->db.ipbfadr1 = (u32)(addr_t) reply;\r\nparm->db.ipbfln1f = (u32) size;\r\nparm->db.ippathid = path->pathid;\r\nparm->db.ipflags1 = flags;\r\nparm->db.ipmsgid = msg->id;\r\nparm->db.iptrgcls = msg->class;\r\n}\r\nrc = iucv_call_b2f0(IUCV_REPLY, parm);\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint __iucv_message_send(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, u32 srccls, void *buffer, size_t size)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (flags & IUCV_IPRMDATA) {\r\nparm->dpl.ippathid = path->pathid;\r\nparm->dpl.ipflags1 = flags | IUCV_IPNORPY;\r\nparm->dpl.iptrgcls = msg->class;\r\nparm->dpl.ipsrccls = srccls;\r\nparm->dpl.ipmsgtag = msg->tag;\r\nmemcpy(parm->dpl.iprmmsg, buffer, 8);\r\n} else {\r\nparm->db.ipbfadr1 = (u32)(addr_t) buffer;\r\nparm->db.ipbfln1f = (u32) size;\r\nparm->db.ippathid = path->pathid;\r\nparm->db.ipflags1 = flags | IUCV_IPNORPY;\r\nparm->db.iptrgcls = msg->class;\r\nparm->db.ipsrccls = srccls;\r\nparm->db.ipmsgtag = msg->tag;\r\n}\r\nrc = iucv_call_b2f0(IUCV_SEND, parm);\r\nif (!rc)\r\nmsg->id = parm->db.ipmsgid;\r\nout:\r\nreturn rc;\r\n}\r\nint iucv_message_send(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, u32 srccls, void *buffer, size_t size)\r\n{\r\nint rc;\r\nlocal_bh_disable();\r\nrc = __iucv_message_send(path, msg, flags, srccls, buffer, size);\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nint iucv_message_send2way(struct iucv_path *path, struct iucv_message *msg,\r\nu8 flags, u32 srccls, void *buffer, size_t size,\r\nvoid *answer, size_t asize, size_t *residual)\r\n{\r\nunion iucv_param *parm;\r\nint rc;\r\nlocal_bh_disable();\r\nif (cpumask_empty(&iucv_buffer_cpumask)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nparm = iucv_param[smp_processor_id()];\r\nmemset(parm, 0, sizeof(union iucv_param));\r\nif (flags & IUCV_IPRMDATA) {\r\nparm->dpl.ippathid = path->pathid;\r\nparm->dpl.ipflags1 = path->flags;\r\nparm->dpl.iptrgcls = msg->class;\r\nparm->dpl.ipsrccls = srccls;\r\nparm->dpl.ipmsgtag = msg->tag;\r\nparm->dpl.ipbfadr2 = (u32)(addr_t) answer;\r\nparm->dpl.ipbfln2f = (u32) asize;\r\nmemcpy(parm->dpl.iprmmsg, buffer, 8);\r\n} else {\r\nparm->db.ippathid = path->pathid;\r\nparm->db.ipflags1 = path->flags;\r\nparm->db.iptrgcls = msg->class;\r\nparm->db.ipsrccls = srccls;\r\nparm->db.ipmsgtag = msg->tag;\r\nparm->db.ipbfadr1 = (u32)(addr_t) buffer;\r\nparm->db.ipbfln1f = (u32) size;\r\nparm->db.ipbfadr2 = (u32)(addr_t) answer;\r\nparm->db.ipbfln2f = (u32) asize;\r\n}\r\nrc = iucv_call_b2f0(IUCV_SEND, parm);\r\nif (!rc)\r\nmsg->id = parm->db.ipmsgid;\r\nout:\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nstatic void iucv_path_pending(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_path_pending *ipp = (void *) data;\r\nstruct iucv_handler *handler;\r\nstruct iucv_path *path;\r\nchar *error;\r\nBUG_ON(iucv_path_table[ipp->ippathid]);\r\nerror = iucv_error_no_memory;\r\npath = iucv_path_alloc(ipp->ipmsglim, ipp->ipflags1, GFP_ATOMIC);\r\nif (!path)\r\ngoto out_sever;\r\npath->pathid = ipp->ippathid;\r\niucv_path_table[path->pathid] = path;\r\nEBCASC(ipp->ipvmid, 8);\r\nlist_for_each_entry(handler, &iucv_handler_list, list) {\r\nif (!handler->path_pending)\r\ncontinue;\r\nlist_add(&path->list, &handler->paths);\r\npath->handler = handler;\r\nif (!handler->path_pending(path, ipp->ipvmid, ipp->ipuser))\r\nreturn;\r\nlist_del(&path->list);\r\npath->handler = NULL;\r\n}\r\niucv_path_table[path->pathid] = NULL;\r\niucv_path_free(path);\r\nerror = iucv_error_no_listener;\r\nout_sever:\r\niucv_sever_pathid(ipp->ippathid, error);\r\n}\r\nstatic void iucv_path_complete(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_path_complete *ipc = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[ipc->ippathid];\r\nif (path)\r\npath->flags = ipc->ipflags1;\r\nif (path && path->handler && path->handler->path_complete)\r\npath->handler->path_complete(path, ipc->ipuser);\r\n}\r\nstatic void iucv_path_severed(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_path_severed *ips = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[ips->ippathid];\r\nif (!path || !path->handler)\r\nreturn;\r\nif (path->handler->path_severed)\r\npath->handler->path_severed(path, ips->ipuser);\r\nelse {\r\niucv_sever_pathid(path->pathid, NULL);\r\niucv_path_table[path->pathid] = NULL;\r\nlist_del(&path->list);\r\niucv_path_free(path);\r\n}\r\n}\r\nstatic void iucv_path_quiesced(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_path_quiesced *ipq = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[ipq->ippathid];\r\nif (path && path->handler && path->handler->path_quiesced)\r\npath->handler->path_quiesced(path, ipq->ipuser);\r\n}\r\nstatic void iucv_path_resumed(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_path_resumed *ipr = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[ipr->ippathid];\r\nif (path && path->handler && path->handler->path_resumed)\r\npath->handler->path_resumed(path, ipr->ipuser);\r\n}\r\nstatic void iucv_message_complete(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_message_complete *imc = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[imc->ippathid];\r\nstruct iucv_message msg;\r\nif (path && path->handler && path->handler->message_complete) {\r\nmsg.flags = imc->ipflags1;\r\nmsg.id = imc->ipmsgid;\r\nmsg.audit = imc->ipaudit;\r\nmemcpy(msg.rmmsg, imc->iprmmsg, 8);\r\nmsg.class = imc->ipsrccls;\r\nmsg.tag = imc->ipmsgtag;\r\nmsg.length = imc->ipbfln2f;\r\npath->handler->message_complete(path, &msg);\r\n}\r\n}\r\nstatic void iucv_message_pending(struct iucv_irq_data *data)\r\n{\r\nstruct iucv_message_pending *imp = (void *) data;\r\nstruct iucv_path *path = iucv_path_table[imp->ippathid];\r\nstruct iucv_message msg;\r\nif (path && path->handler && path->handler->message_pending) {\r\nmsg.flags = imp->ipflags1;\r\nmsg.id = imp->ipmsgid;\r\nmsg.class = imp->iptrgcls;\r\nif (imp->ipflags1 & IUCV_IPRMDATA) {\r\nmemcpy(msg.rmmsg, imp->ln1msg1.iprmmsg1, 8);\r\nmsg.length = 8;\r\n} else\r\nmsg.length = imp->ln1msg2.ipbfln1f;\r\nmsg.reply_size = imp->ipbfln2f;\r\npath->handler->message_pending(path, &msg);\r\n}\r\n}\r\nstatic void iucv_tasklet_fn(unsigned long ignored)\r\n{\r\ntypedef void iucv_irq_fn(struct iucv_irq_data *);\r\nstatic iucv_irq_fn *irq_fn[] = {\r\n[0x02] = iucv_path_complete,\r\n[0x03] = iucv_path_severed,\r\n[0x04] = iucv_path_quiesced,\r\n[0x05] = iucv_path_resumed,\r\n[0x06] = iucv_message_complete,\r\n[0x07] = iucv_message_complete,\r\n[0x08] = iucv_message_pending,\r\n[0x09] = iucv_message_pending,\r\n};\r\nLIST_HEAD(task_queue);\r\nstruct iucv_irq_list *p, *n;\r\nif (!spin_trylock(&iucv_table_lock)) {\r\ntasklet_schedule(&iucv_tasklet);\r\nreturn;\r\n}\r\niucv_active_cpu = smp_processor_id();\r\nspin_lock_irq(&iucv_queue_lock);\r\nlist_splice_init(&iucv_task_queue, &task_queue);\r\nspin_unlock_irq(&iucv_queue_lock);\r\nlist_for_each_entry_safe(p, n, &task_queue, list) {\r\nlist_del_init(&p->list);\r\nirq_fn[p->data.iptype](&p->data);\r\nkfree(p);\r\n}\r\niucv_active_cpu = -1;\r\nspin_unlock(&iucv_table_lock);\r\n}\r\nstatic void iucv_work_fn(struct work_struct *work)\r\n{\r\nLIST_HEAD(work_queue);\r\nstruct iucv_irq_list *p, *n;\r\nspin_lock_bh(&iucv_table_lock);\r\niucv_active_cpu = smp_processor_id();\r\nspin_lock_irq(&iucv_queue_lock);\r\nlist_splice_init(&iucv_work_queue, &work_queue);\r\nspin_unlock_irq(&iucv_queue_lock);\r\niucv_cleanup_queue();\r\nlist_for_each_entry_safe(p, n, &work_queue, list) {\r\nlist_del_init(&p->list);\r\niucv_path_pending(&p->data);\r\nkfree(p);\r\n}\r\niucv_active_cpu = -1;\r\nspin_unlock_bh(&iucv_table_lock);\r\n}\r\nstatic void iucv_external_interrupt(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct iucv_irq_data *p;\r\nstruct iucv_irq_list *work;\r\ninc_irq_stat(IRQEXT_IUC);\r\np = iucv_irq_data[smp_processor_id()];\r\nif (p->ippathid >= iucv_max_pathid) {\r\nWARN_ON(p->ippathid >= iucv_max_pathid);\r\niucv_sever_pathid(p->ippathid, iucv_error_no_listener);\r\nreturn;\r\n}\r\nBUG_ON(p->iptype < 0x01 || p->iptype > 0x09);\r\nwork = kmalloc(sizeof(struct iucv_irq_list), GFP_ATOMIC);\r\nif (!work) {\r\npr_warn("iucv_external_interrupt: out of memory\n");\r\nreturn;\r\n}\r\nmemcpy(&work->data, p, sizeof(work->data));\r\nspin_lock(&iucv_queue_lock);\r\nif (p->iptype == 0x01) {\r\nlist_add_tail(&work->list, &iucv_work_queue);\r\nschedule_work(&iucv_work);\r\n} else {\r\nlist_add_tail(&work->list, &iucv_task_queue);\r\ntasklet_schedule(&iucv_tasklet);\r\n}\r\nspin_unlock(&iucv_queue_lock);\r\n}\r\nstatic int iucv_pm_prepare(struct device *dev)\r\n{\r\nint rc = 0;\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_INFO "iucv_pm_prepare\n");\r\n#endif\r\nif (dev->driver && dev->driver->pm && dev->driver->pm->prepare)\r\nrc = dev->driver->pm->prepare(dev);\r\nreturn rc;\r\n}\r\nstatic void iucv_pm_complete(struct device *dev)\r\n{\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_INFO "iucv_pm_complete\n");\r\n#endif\r\nif (dev->driver && dev->driver->pm && dev->driver->pm->complete)\r\ndev->driver->pm->complete(dev);\r\n}\r\nint iucv_path_table_empty(void)\r\n{\r\nint i;\r\nfor (i = 0; i < iucv_max_pathid; i++) {\r\nif (iucv_path_table[i])\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int iucv_pm_freeze(struct device *dev)\r\n{\r\nint cpu;\r\nstruct iucv_irq_list *p, *n;\r\nint rc = 0;\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_WARNING "iucv_pm_freeze\n");\r\n#endif\r\nif (iucv_pm_state != IUCV_PM_FREEZING) {\r\nfor_each_cpu(cpu, &iucv_irq_cpumask)\r\nsmp_call_function_single(cpu, iucv_block_cpu_almost,\r\nNULL, 1);\r\ncancel_work_sync(&iucv_work);\r\nlist_for_each_entry_safe(p, n, &iucv_work_queue, list) {\r\nlist_del_init(&p->list);\r\niucv_sever_pathid(p->data.ippathid,\r\niucv_error_no_listener);\r\nkfree(p);\r\n}\r\n}\r\niucv_pm_state = IUCV_PM_FREEZING;\r\nif (dev->driver && dev->driver->pm && dev->driver->pm->freeze)\r\nrc = dev->driver->pm->freeze(dev);\r\nif (iucv_path_table_empty())\r\niucv_disable();\r\nreturn rc;\r\n}\r\nstatic int iucv_pm_thaw(struct device *dev)\r\n{\r\nint rc = 0;\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_WARNING "iucv_pm_thaw\n");\r\n#endif\r\niucv_pm_state = IUCV_PM_THAWING;\r\nif (!iucv_path_table) {\r\nrc = iucv_enable();\r\nif (rc)\r\ngoto out;\r\n}\r\nif (cpumask_empty(&iucv_irq_cpumask)) {\r\nif (iucv_nonsmp_handler)\r\niucv_allow_cpu(NULL);\r\nelse\r\niucv_setmask_mp();\r\n}\r\nif (dev->driver && dev->driver->pm && dev->driver->pm->thaw)\r\nrc = dev->driver->pm->thaw(dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int iucv_pm_restore(struct device *dev)\r\n{\r\nint rc = 0;\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_WARNING "iucv_pm_restore %p\n", iucv_path_table);\r\n#endif\r\nif ((iucv_pm_state != IUCV_PM_RESTORING) && iucv_path_table)\r\npr_warn("Suspending Linux did not completely close all IUCV connections\n");\r\niucv_pm_state = IUCV_PM_RESTORING;\r\nif (cpumask_empty(&iucv_irq_cpumask)) {\r\nrc = iucv_query_maxconn();\r\nrc = iucv_enable();\r\nif (rc)\r\ngoto out;\r\n}\r\nif (dev->driver && dev->driver->pm && dev->driver->pm->restore)\r\nrc = dev->driver->pm->restore(dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init iucv_init(void)\r\n{\r\nint rc;\r\nint cpu;\r\nif (!MACHINE_IS_VM) {\r\nrc = -EPROTONOSUPPORT;\r\ngoto out;\r\n}\r\nctl_set_bit(0, 1);\r\nrc = iucv_query_maxconn();\r\nif (rc)\r\ngoto out_ctl;\r\nrc = register_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\r\nif (rc)\r\ngoto out_ctl;\r\niucv_root = root_device_register("iucv");\r\nif (IS_ERR(iucv_root)) {\r\nrc = PTR_ERR(iucv_root);\r\ngoto out_int;\r\n}\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu) {\r\nif (alloc_iucv_data(cpu)) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\n}\r\nrc = __register_hotcpu_notifier(&iucv_cpu_notifier);\r\nif (rc)\r\ngoto out_free;\r\ncpu_notifier_register_done();\r\nrc = register_reboot_notifier(&iucv_reboot_notifier);\r\nif (rc)\r\ngoto out_cpu;\r\nASCEBC(iucv_error_no_listener, 16);\r\nASCEBC(iucv_error_no_memory, 16);\r\nASCEBC(iucv_error_pathid, 16);\r\niucv_available = 1;\r\nrc = bus_register(&iucv_bus);\r\nif (rc)\r\ngoto out_reboot;\r\niucv_if.root = iucv_root;\r\niucv_if.bus = &iucv_bus;\r\nreturn 0;\r\nout_reboot:\r\nunregister_reboot_notifier(&iucv_reboot_notifier);\r\nout_cpu:\r\ncpu_notifier_register_begin();\r\n__unregister_hotcpu_notifier(&iucv_cpu_notifier);\r\nout_free:\r\nfor_each_possible_cpu(cpu)\r\nfree_iucv_data(cpu);\r\ncpu_notifier_register_done();\r\nroot_device_unregister(iucv_root);\r\nout_int:\r\nunregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\r\nout_ctl:\r\nctl_clear_bit(0, 1);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit iucv_exit(void)\r\n{\r\nstruct iucv_irq_list *p, *n;\r\nint cpu;\r\nspin_lock_irq(&iucv_queue_lock);\r\nlist_for_each_entry_safe(p, n, &iucv_task_queue, list)\r\nkfree(p);\r\nlist_for_each_entry_safe(p, n, &iucv_work_queue, list)\r\nkfree(p);\r\nspin_unlock_irq(&iucv_queue_lock);\r\nunregister_reboot_notifier(&iucv_reboot_notifier);\r\ncpu_notifier_register_begin();\r\n__unregister_hotcpu_notifier(&iucv_cpu_notifier);\r\nfor_each_possible_cpu(cpu)\r\nfree_iucv_data(cpu);\r\ncpu_notifier_register_done();\r\nroot_device_unregister(iucv_root);\r\nbus_unregister(&iucv_bus);\r\nunregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);\r\n}
