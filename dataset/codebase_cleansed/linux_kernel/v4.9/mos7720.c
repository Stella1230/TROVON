static inline __u16 get_reg_index(enum mos_regs reg)\r\n{\r\nstatic const __u16 mos7715_index_lookup_table[] = {\r\n0x00,\r\n0x00,\r\n0x01,\r\n0x02,\r\n0x02,\r\n0x03,\r\n0x04,\r\n0x05,\r\n0x06,\r\n0x07,\r\n0x00,\r\n0x01,\r\n0x00,\r\n0x01,\r\n0x02,\r\n0x0a,\r\n0x01,\r\n0x02,\r\n0x04,\r\n0x08,\r\n};\r\nreturn mos7715_index_lookup_table[reg];\r\n}\r\nstatic inline __u16 get_reg_value(enum mos_regs reg,\r\nunsigned int serial_portnum)\r\n{\r\nif (reg >= MOS7720_SP1_REG)\r\nreturn 0x0000;\r\nelse if (reg >= MOS7720_DPR)\r\nreturn 0x0100;\r\nelse\r\nreturn (serial_portnum + 2) << 8;\r\n}\r\nstatic int write_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\r\nenum mos_regs reg, __u8 data)\r\n{\r\nstruct usb_device *usbdev = serial->dev;\r\nunsigned int pipe = usb_sndctrlpipe(usbdev, 0);\r\n__u8 request = (__u8)0x0e;\r\n__u8 requesttype = (__u8)0x40;\r\n__u16 index = get_reg_index(reg);\r\n__u16 value = get_reg_value(reg, serial_portnum) + data;\r\nint status = usb_control_msg(usbdev, pipe, request, requesttype, value,\r\nindex, NULL, 0, MOS_WDR_TIMEOUT);\r\nif (status < 0)\r\ndev_err(&usbdev->dev,\r\n"mos7720: usb_control_msg() failed: %d\n", status);\r\nreturn status;\r\n}\r\nstatic int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\r\nenum mos_regs reg, __u8 *data)\r\n{\r\nstruct usb_device *usbdev = serial->dev;\r\nunsigned int pipe = usb_rcvctrlpipe(usbdev, 0);\r\n__u8 request = (__u8)0x0d;\r\n__u8 requesttype = (__u8)0xc0;\r\n__u16 index = get_reg_index(reg);\r\n__u16 value = get_reg_value(reg, serial_portnum);\r\nu8 *buf;\r\nint status;\r\nbuf = kmalloc(1, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nstatus = usb_control_msg(usbdev, pipe, request, requesttype, value,\r\nindex, buf, 1, MOS_WDR_TIMEOUT);\r\nif (status == 1)\r\n*data = *buf;\r\nelse if (status < 0)\r\ndev_err(&usbdev->dev,\r\n"mos7720: usb_control_msg() failed: %d\n", status);\r\nkfree(buf);\r\nreturn status;\r\n}\r\nstatic inline int mos7715_change_mode(struct mos7715_parport *mos_parport,\r\nenum mos7715_pp_modes mode)\r\n{\r\nmos_parport->shadowECR = mode;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_ECR,\r\nmos_parport->shadowECR);\r\nreturn 0;\r\n}\r\nstatic void destroy_mos_parport(struct kref *kref)\r\n{\r\nstruct mos7715_parport *mos_parport =\r\ncontainer_of(kref, struct mos7715_parport, ref_count);\r\nkfree(mos_parport);\r\n}\r\nstatic void destroy_urbtracker(struct kref *kref)\r\n{\r\nstruct urbtracker *urbtrack =\r\ncontainer_of(kref, struct urbtracker, ref_count);\r\nstruct mos7715_parport *mos_parport = urbtrack->mos_parport;\r\nusb_free_urb(urbtrack->urb);\r\nkfree(urbtrack->setup);\r\nkfree(urbtrack);\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\n}\r\nstatic void send_deferred_urbs(unsigned long _mos_parport)\r\n{\r\nint ret_val;\r\nunsigned long flags;\r\nstruct mos7715_parport *mos_parport = (void *)_mos_parport;\r\nstruct urbtracker *urbtrack, *tmp;\r\nstruct list_head *cursor, *next;\r\nstruct device *dev;\r\nif (unlikely(mos_parport->serial == NULL))\r\nreturn;\r\ndev = &mos_parport->serial->dev->dev;\r\nif (!mutex_trylock(&mos_parport->serial->disc_mutex)) {\r\ndev_dbg(dev, "%s: rescheduling tasklet\n", __func__);\r\ntasklet_schedule(&mos_parport->urb_tasklet);\r\nreturn;\r\n}\r\nif (unlikely(mos_parport->serial->disconnected)) {\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nif (list_empty(&mos_parport->deferred_urbs)) {\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\ndev_dbg(dev, "%s: deferred_urbs list empty\n", __func__);\r\nreturn;\r\n}\r\nlist_for_each_safe(cursor, next, &mos_parport->deferred_urbs)\r\nlist_move_tail(cursor, &mos_parport->active_urbs);\r\nlist_for_each_entry_safe(urbtrack, tmp, &mos_parport->active_urbs,\r\nurblist_entry) {\r\nret_val = usb_submit_urb(urbtrack->urb, GFP_ATOMIC);\r\ndev_dbg(dev, "%s: urb submitted\n", __func__);\r\nif (ret_val) {\r\ndev_err(dev, "usb_submit_urb() failed: %d\n", ret_val);\r\nlist_del(&urbtrack->urblist_entry);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\n}\r\n}\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\n}\r\nstatic void async_complete(struct urb *urb)\r\n{\r\nstruct urbtracker *urbtrack = urb->context;\r\nint status = urb->status;\r\nif (unlikely(status))\r\ndev_dbg(&urb->dev->dev, "%s - nonzero urb status received: %d\n", __func__, status);\r\nspin_lock(&urbtrack->mos_parport->listlock);\r\nlist_del(&urbtrack->urblist_entry);\r\nspin_unlock(&urbtrack->mos_parport->listlock);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\n}\r\nstatic int write_parport_reg_nonblock(struct mos7715_parport *mos_parport,\r\nenum mos_regs reg, __u8 data)\r\n{\r\nstruct urbtracker *urbtrack;\r\nint ret_val;\r\nunsigned long flags;\r\nstruct usb_serial *serial = mos_parport->serial;\r\nstruct usb_device *usbdev = serial->dev;\r\nurbtrack = kmalloc(sizeof(struct urbtracker), GFP_ATOMIC);\r\nif (!urbtrack)\r\nreturn -ENOMEM;\r\nkref_get(&mos_parport->ref_count);\r\nurbtrack->mos_parport = mos_parport;\r\nurbtrack->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urbtrack->urb) {\r\nkfree(urbtrack);\r\nreturn -ENOMEM;\r\n}\r\nurbtrack->setup = kmalloc(sizeof(*urbtrack->setup), GFP_ATOMIC);\r\nif (!urbtrack->setup) {\r\nusb_free_urb(urbtrack->urb);\r\nkfree(urbtrack);\r\nreturn -ENOMEM;\r\n}\r\nurbtrack->setup->bRequestType = (__u8)0x40;\r\nurbtrack->setup->bRequest = (__u8)0x0e;\r\nurbtrack->setup->wValue = cpu_to_le16(get_reg_value(reg, dummy));\r\nurbtrack->setup->wIndex = cpu_to_le16(get_reg_index(reg));\r\nurbtrack->setup->wLength = 0;\r\nusb_fill_control_urb(urbtrack->urb, usbdev,\r\nusb_sndctrlpipe(usbdev, 0),\r\n(unsigned char *)urbtrack->setup,\r\nNULL, 0, async_complete, urbtrack);\r\nkref_init(&urbtrack->ref_count);\r\nINIT_LIST_HEAD(&urbtrack->urblist_entry);\r\nif (!mutex_trylock(&serial->disc_mutex)) {\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_add_tail(&urbtrack->urblist_entry,\r\n&mos_parport->deferred_urbs);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\ntasklet_schedule(&mos_parport->urb_tasklet);\r\ndev_dbg(&usbdev->dev, "tasklet scheduled\n");\r\nreturn 0;\r\n}\r\nif (serial->disconnected) {\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\nmutex_unlock(&serial->disc_mutex);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_add_tail(&urbtrack->urblist_entry, &mos_parport->active_urbs);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nret_val = usb_submit_urb(urbtrack->urb, GFP_ATOMIC);\r\nmutex_unlock(&serial->disc_mutex);\r\nif (ret_val) {\r\ndev_err(&usbdev->dev,\r\n"%s: submit_urb() failed: %d\n", __func__, ret_val);\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_del(&urbtrack->urblist_entry);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\nreturn ret_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parport_prologue(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn -1;\r\n}\r\nmos_parport->msg_pending = true;\r\nreinit_completion(&mos_parport->syncmsg_compl);\r\nspin_unlock(&release_lock);\r\nmutex_lock(&mos_parport->serial->disc_mutex);\r\nif (mos_parport->serial->disconnected) {\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nmos_parport->msg_pending = false;\r\ncomplete(&mos_parport->syncmsg_compl);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void parport_epilogue(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nmos_parport->msg_pending = false;\r\ncomplete(&mos_parport->syncmsg_compl);\r\n}\r\nstatic void parport_mos7715_write_data(struct parport *pp, unsigned char d)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, SPP);\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DPR, (__u8)d);\r\nparport_epilogue(pp);\r\n}\r\nstatic unsigned char parport_mos7715_read_data(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nunsigned char d;\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nread_mos_reg(mos_parport->serial, dummy, MOS7720_DPR, &d);\r\nparport_epilogue(pp);\r\nreturn d;\r\n}\r\nstatic void parport_mos7715_write_control(struct parport *pp, unsigned char d)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 data;\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\ndata = ((__u8)d & 0x0f) | (mos_parport->shadowDCR & 0xf0);\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR, data);\r\nmos_parport->shadowDCR = data;\r\nparport_epilogue(pp);\r\n}\r\nstatic unsigned char parport_mos7715_read_control(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 dcr;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn 0;\r\n}\r\ndcr = mos_parport->shadowDCR & 0x0f;\r\nspin_unlock(&release_lock);\r\nreturn dcr;\r\n}\r\nstatic unsigned char parport_mos7715_frob_control(struct parport *pp,\r\nunsigned char mask,\r\nunsigned char val)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 dcr;\r\nmask &= 0x0f;\r\nval &= 0x0f;\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nmos_parport->shadowDCR = (mos_parport->shadowDCR & (~mask)) ^ val;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\r\nmos_parport->shadowDCR);\r\ndcr = mos_parport->shadowDCR & 0x0f;\r\nparport_epilogue(pp);\r\nreturn dcr;\r\n}\r\nstatic unsigned char parport_mos7715_read_status(struct parport *pp)\r\n{\r\nunsigned char status;\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn 0;\r\n}\r\nstatus = atomic_read(&mos_parport->shadowDSR) & 0xf8;\r\nspin_unlock(&release_lock);\r\nreturn status;\r\n}\r\nstatic void parport_mos7715_enable_irq(struct parport *pp)\r\n{\r\n}\r\nstatic void parport_mos7715_disable_irq(struct parport *pp)\r\n{\r\n}\r\nstatic void parport_mos7715_data_forward(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, PS2);\r\nmos_parport->shadowDCR &= ~0x20;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\r\nmos_parport->shadowDCR);\r\nparport_epilogue(pp);\r\n}\r\nstatic void parport_mos7715_data_reverse(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, PS2);\r\nmos_parport->shadowDCR |= 0x20;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\r\nmos_parport->shadowDCR);\r\nparport_epilogue(pp);\r\n}\r\nstatic void parport_mos7715_init_state(struct pardevice *dev,\r\nstruct parport_state *s)\r\n{\r\ns->u.pc.ctr = DCR_INIT_VAL;\r\ns->u.pc.ecr = ECR_INIT_VAL;\r\n}\r\nstatic void parport_mos7715_save_state(struct parport *pp,\r\nstruct parport_state *s)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn;\r\n}\r\ns->u.pc.ctr = mos_parport->shadowDCR;\r\ns->u.pc.ecr = mos_parport->shadowECR;\r\nspin_unlock(&release_lock);\r\n}\r\nstatic void parport_mos7715_restore_state(struct parport *pp,\r\nstruct parport_state *s)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn;\r\n}\r\nwrite_parport_reg_nonblock(mos_parport, MOS7720_DCR,\r\nmos_parport->shadowDCR);\r\nwrite_parport_reg_nonblock(mos_parport, MOS7720_ECR,\r\nmos_parport->shadowECR);\r\nspin_unlock(&release_lock);\r\n}\r\nstatic size_t parport_mos7715_write_compat(struct parport *pp,\r\nconst void *buffer,\r\nsize_t len, int flags)\r\n{\r\nint retval;\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nint actual_len;\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nmos7715_change_mode(mos_parport, PPF);\r\nretval = usb_bulk_msg(mos_parport->serial->dev,\r\nusb_sndbulkpipe(mos_parport->serial->dev, 2),\r\n(void *)buffer, len, &actual_len,\r\nMOS_WDR_TIMEOUT);\r\nparport_epilogue(pp);\r\nif (retval) {\r\ndev_err(&mos_parport->serial->dev->dev,\r\n"mos7720: usb_bulk_msg() failed: %d\n", retval);\r\nreturn 0;\r\n}\r\nreturn actual_len;\r\n}\r\nstatic int mos7715_parport_init(struct usb_serial *serial)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nmos_parport = kzalloc(sizeof(struct mos7715_parport), GFP_KERNEL);\r\nif (!mos_parport)\r\nreturn -ENOMEM;\r\nmos_parport->msg_pending = false;\r\nkref_init(&mos_parport->ref_count);\r\nspin_lock_init(&mos_parport->listlock);\r\nINIT_LIST_HEAD(&mos_parport->active_urbs);\r\nINIT_LIST_HEAD(&mos_parport->deferred_urbs);\r\nusb_set_serial_data(serial, mos_parport);\r\nmos_parport->serial = serial;\r\ntasklet_init(&mos_parport->urb_tasklet, send_deferred_urbs,\r\n(unsigned long) mos_parport);\r\ninit_completion(&mos_parport->syncmsg_compl);\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_PP_REG, (__u8)0x80);\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_PP_REG, (__u8)0x00);\r\nmos_parport->shadowDCR = DCR_INIT_VAL;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\r\nmos_parport->shadowDCR);\r\nmos_parport->shadowECR = ECR_INIT_VAL;\r\nwrite_mos_reg(mos_parport->serial, dummy, MOS7720_ECR,\r\nmos_parport->shadowECR);\r\nmos_parport->pp = parport_register_port(0, PARPORT_IRQ_NONE,\r\nPARPORT_DMA_NONE,\r\n&parport_mos7715_ops);\r\nif (mos_parport->pp == NULL) {\r\ndev_err(&serial->interface->dev,\r\n"Could not register parport\n");\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\nreturn -EIO;\r\n}\r\nmos_parport->pp->private_data = mos_parport;\r\nmos_parport->pp->modes = PARPORT_MODE_COMPAT | PARPORT_MODE_PCSPP;\r\nmos_parport->pp->dev = &serial->interface->dev;\r\nparport_announce_port(mos_parport->pp);\r\nreturn 0;\r\n}\r\nstatic void mos7720_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nint status = urb->status;\r\nstruct device *dev = &urb->dev->dev;\r\n__u8 *data;\r\n__u8 sp1;\r\n__u8 sp2;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n", __func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n", __func__, status);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nif (unlikely(length != 4)) {\r\ndev_dbg(dev, "Wrong data !!!\n");\r\nreturn;\r\n}\r\nsp1 = data[3];\r\nsp2 = data[2];\r\nif ((sp1 | sp2) & 0x01) {\r\ndev_dbg(dev, "No Interrupt !!!\n");\r\n} else {\r\nswitch (sp1 & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndev_dbg(dev, "Serial Port 1: Receiver status error or address bit detected in 9-bit mode\n");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndev_dbg(dev, "Serial Port 1: Receiver time out\n");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\nswitch (sp2 & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndev_dbg(dev, "Serial Port 2: Receiver status error or address bit detected in 9-bit mode\n");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndev_dbg(dev, "Serial Port 2: Receiver time out\n");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\n}\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(dev, "%s - Error %d submitting control urb\n", __func__, result);\r\n}\r\nstatic void mos7715_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nint status = urb->status;\r\nstruct device *dev = &urb->dev->dev;\r\n__u8 *data;\r\n__u8 iir;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ENODEV:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n", __func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n", __func__, status);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nif (unlikely(length != 4)) {\r\ndev_dbg(dev, "Wrong data !!!\n");\r\nreturn;\r\n}\r\niir = data[0];\r\nif (!(iir & 0x01)) {\r\nswitch (iir & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndev_dbg(dev, "Serial Port: Receiver status error or address bit detected in 9-bit mode\n");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndev_dbg(dev, "Serial Port: Receiver time out\n");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct mos7715_parport *mos_parport = port->serial->private;\r\nif (unlikely(mos_parport == NULL))\r\nreturn;\r\natomic_set(&mos_parport->shadowDSR, data[2]);\r\n}\r\n#endif\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(dev, "%s - Error %d submitting control urb\n", __func__, result);\r\n}\r\nstatic void mos7720_bulk_in_callback(struct urb *urb)\r\n{\r\nint retval;\r\nunsigned char *data ;\r\nstruct usb_serial_port *port;\r\nint status = urb->status;\r\nif (status) {\r\ndev_dbg(&urb->dev->dev, "nonzero read bulk status received: %d\n", status);\r\nreturn;\r\n}\r\nport = urb->context;\r\ndev_dbg(&port->dev, "Entering...%s\n", __func__);\r\ndata = urb->transfer_buffer;\r\nif (urb->actual_length) {\r\ntty_insert_flip_string(&port->port, data, urb->actual_length);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nretval = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, retval = %d\n", retval);\r\n}\r\n}\r\nstatic void mos7720_bulk_out_data_callback(struct urb *urb)\r\n{\r\nstruct moschip_port *mos7720_port;\r\nint status = urb->status;\r\nif (status) {\r\ndev_dbg(&urb->dev->dev, "nonzero write bulk status received:%d\n", status);\r\nreturn;\r\n}\r\nmos7720_port = urb->context;\r\nif (!mos7720_port) {\r\ndev_dbg(&urb->dev->dev, "NULL mos7720_port pointer\n");\r\nreturn ;\r\n}\r\nif (mos7720_port->open)\r\ntty_port_tty_wakeup(&mos7720_port->port->port);\r\n}\r\nstatic int mos77xx_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nif (id->idProduct == MOSCHIP_DEVICE_ID_7715)\r\nmoschip7720_2port_driver.read_int_callback =\r\nmos7715_interrupt_callback;\r\nelse\r\nmoschip7720_2port_driver.read_int_callback =\r\nmos7720_interrupt_callback;\r\nreturn 0;\r\n}\r\nstatic int mos77xx_calc_num_ports(struct usb_serial *serial)\r\n{\r\nu16 product = le16_to_cpu(serial->dev->descriptor.idProduct);\r\nif (product == MOSCHIP_DEVICE_ID_7715)\r\nreturn 1;\r\nreturn 2;\r\n}\r\nstatic int mos7720_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\nstruct moschip_port *mos7720_port;\r\nint response;\r\nint port_number;\r\n__u8 data;\r\nint allocated_urbs = 0;\r\nint j;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7720_port->write_urb_pool[j] = urb;\r\nif (!urb)\r\ncontinue;\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\nusb_free_urb(mos7720_port->write_urb_pool[j]);\r\nmos7720_port->write_urb_pool[j] = NULL;\r\ncontinue;\r\n}\r\nallocated_urbs++;\r\n}\r\nif (!allocated_urbs)\r\nreturn -ENOMEM;\r\nport_number = port->port_number;\r\nread_mos_reg(serial, port_number, MOS7720_LSR, &data);\r\ndev_dbg(&port->dev, "SS::%p LSR:%x\n", mos7720_port, data);\r\nwrite_mos_reg(serial, dummy, MOS7720_SP1_REG, 0x02);\r\nwrite_mos_reg(serial, dummy, MOS7720_SP2_REG, 0x02);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\r\nmos7720_port->shadowLCR = 0x03;\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nwrite_mos_reg(serial, port_number, MOS7720_SP_CONTROL_REG, 0x00);\r\nread_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, &data);\r\ndata = data | (port->port_number + 1);\r\nwrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, data);\r\nmos7720_port->shadowLCR = 0x83;\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, MOS7720_THR, 0x0c);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\r\nmos7720_port->shadowLCR = 0x03;\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\r\nresponse = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (response)\r\ndev_err(&port->dev, "%s - Error %d submitting read urb\n",\r\n__func__, response);\r\nmos7720_port->shadowMCR = UART_MCR_OUT2;\r\nmos7720_port->open = 1;\r\nreturn 0;\r\n}\r\nstatic int mos7720_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint chars = 0;\r\nstruct moschip_port *mos7720_port;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn 0;\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status == -EINPROGRESS)\r\nchars += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void mos7720_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\nint j;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nfor (j = 0; j < NUM_URBS; ++j)\r\nusb_kill_urb(mos7720_port->write_urb_pool[j]);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nif (mos7720_port->write_urb_pool[j]) {\r\nkfree(mos7720_port->write_urb_pool[j]->transfer_buffer);\r\nusb_free_urb(mos7720_port->write_urb_pool[j]);\r\n}\r\n}\r\nusb_kill_urb(port->write_urb);\r\nusb_kill_urb(port->read_urb);\r\nwrite_mos_reg(serial, port->port_number, MOS7720_MCR, 0x00);\r\nwrite_mos_reg(serial, port->port_number, MOS7720_IER, 0x00);\r\nmos7720_port->open = 0;\r\n}\r\nstatic void mos7720_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned char data;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (break_state == -1)\r\ndata = mos7720_port->shadowLCR | UART_LCR_SBC;\r\nelse\r\ndata = mos7720_port->shadowLCR & ~UART_LCR_SBC;\r\nmos7720_port->shadowLCR = data;\r\nwrite_mos_reg(serial, port->port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\n}\r\nstatic int mos7720_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nint room = 0;\r\nint i;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status != -EINPROGRESS)\r\nroom += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, room);\r\nreturn room;\r\n}\r\nstatic int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nint status;\r\nint i;\r\nint bytes_sent = 0;\r\nint transfer_size;\r\nstruct moschip_port *mos7720_port;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\nconst unsigned char *current_position = data;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\nurb = NULL;\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status != -EINPROGRESS) {\r\nurb = mos7720_port->write_urb_pool[i];\r\ndev_dbg(&port->dev, "URB:%d\n", i);\r\nbreak;\r\n}\r\n}\r\nif (urb == NULL) {\r\ndev_dbg(&port->dev, "%s - no more free urbs\n", __func__);\r\ngoto exit;\r\n}\r\nif (urb->transfer_buffer == NULL) {\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_ATOMIC);\r\nif (!urb->transfer_buffer)\r\ngoto exit;\r\n}\r\ntransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\r\nmemcpy(urb->transfer_buffer, current_position, transfer_size);\r\nusb_serial_debug_data(&port->dev, __func__, transfer_size,\r\nurb->transfer_buffer);\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nurb->transfer_buffer, transfer_size,\r\nmos7720_bulk_out_data_callback, mos7720_port);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err_console(port, "%s - usb_submit_urb(write bulk) failed "\r\n"with status = %d\n", __func__, status);\r\nbytes_sent = status;\r\ngoto exit;\r\n}\r\nbytes_sent = transfer_size;\r\nexit:\r\nreturn bytes_sent;\r\n}\r\nstatic void mos7720_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nint status;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = mos7720_write(tty, port, &stop_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nmos7720_port->shadowMCR &= ~UART_MCR_RTS;\r\nwrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\n}\r\n}\r\nstatic void mos7720_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nint status;\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = mos7720_write(tty, port, &start_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nmos7720_port->shadowMCR |= UART_MCR_RTS;\r\nwrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\n}\r\n}\r\nstatic int set_higher_rates(struct moschip_port *mos7720_port,\r\nunsigned int baud)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint port_number;\r\nenum mos_regs sp_reg;\r\nif (mos7720_port == NULL)\r\nreturn -EINVAL;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\ndev_dbg(&port->dev, "Sending Setting Commands ..........\n");\r\nport_number = port->port_number;\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nwrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, 0x00);\r\nif (port_number == 0)\r\nsp_reg = MOS7720_SP1_REG;\r\nelse\r\nsp_reg = MOS7720_SP2_REG;\r\nwrite_mos_reg(serial, dummy, sp_reg, baud * 0x10);\r\nwrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, 0x03);\r\nmos7720_port->shadowMCR = 0x2b;\r\nwrite_mos_reg(serial, port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, MOS7720_DLL, 0x01);\r\nwrite_mos_reg(serial, port_number, MOS7720_DLM, 0x00);\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nreturn 0;\r\n}\r\nstatic int calc_baud_rate_divisor(struct usb_serial_port *port, int baudrate, int *divisor)\r\n{\r\nint i;\r\n__u16 custom;\r\n__u16 round1;\r\n__u16 round;\r\ndev_dbg(&port->dev, "%s - %d\n", __func__, baudrate);\r\nfor (i = 0; i < ARRAY_SIZE(divisor_table); i++) {\r\nif (divisor_table[i].baudrate == baudrate) {\r\n*divisor = divisor_table[i].divisor;\r\nreturn 0;\r\n}\r\n}\r\nif (baudrate > 75 && baudrate < 230400) {\r\ncustom = (__u16)(230400L / baudrate);\r\nround1 = (__u16)(2304000L / baudrate);\r\nround = (__u16)(round1 - (custom * 10));\r\nif (round > 4)\r\ncustom++;\r\n*divisor = custom;\r\ndev_dbg(&port->dev, "Baud %d = %d\n", baudrate, custom);\r\nreturn 0;\r\n}\r\ndev_dbg(&port->dev, "Baud calculation Failed...\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int send_cmd_write_baud_rate(struct moschip_port *mos7720_port,\r\nint baudrate)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint divisor;\r\nint status;\r\nunsigned char number;\r\nif (mos7720_port == NULL)\r\nreturn -1;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\nnumber = port->port_number;\r\ndev_dbg(&port->dev, "%s - baud = %d\n", __func__, baudrate);\r\nstatus = calc_baud_rate_divisor(port, baudrate, &divisor);\r\nif (status) {\r\ndev_err(&port->dev, "%s - bad baud rate\n", __func__);\r\nreturn status;\r\n}\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\r\nwrite_mos_reg(serial, number, MOS7720_LCR, mos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, number, MOS7720_DLL, (__u8)(divisor & 0xff));\r\nwrite_mos_reg(serial, number, MOS7720_DLM,\r\n(__u8)((divisor & 0xff00) >> 8));\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\r\nwrite_mos_reg(serial, number, MOS7720_LCR, mos7720_port->shadowLCR);\r\nreturn status;\r\n}\r\nstatic void change_port_settings(struct tty_struct *tty,\r\nstruct moschip_port *mos7720_port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint baud;\r\nunsigned cflag;\r\nunsigned iflag;\r\n__u8 mask = 0xff;\r\n__u8 lData;\r\n__u8 lParity;\r\n__u8 lStop;\r\nint status;\r\nint port_number;\r\nif (mos7720_port == NULL)\r\nreturn ;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\nport_number = port->port_number;\r\nif (!mos7720_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\nlData = UART_LCR_WLEN8;\r\nlStop = 0x00;\r\nlParity = 0x00;\r\ncflag = tty->termios.c_cflag;\r\niflag = tty->termios.c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlData = UART_LCR_WLEN5;\r\nmask = 0x1f;\r\nbreak;\r\ncase CS6:\r\nlData = UART_LCR_WLEN6;\r\nmask = 0x3f;\r\nbreak;\r\ncase CS7:\r\nlData = UART_LCR_WLEN7;\r\nmask = 0x7f;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlData = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nlParity = UART_LCR_PARITY;\r\ndev_dbg(&port->dev, "%s - parity = odd\n", __func__);\r\n} else {\r\nlParity = (UART_LCR_EPAR | UART_LCR_PARITY);\r\ndev_dbg(&port->dev, "%s - parity = even\n", __func__);\r\n}\r\n} else {\r\ndev_dbg(&port->dev, "%s - parity = none\n", __func__);\r\n}\r\nif (cflag & CMSPAR)\r\nlParity = lParity | 0x20;\r\nif (cflag & CSTOPB) {\r\nlStop = UART_LCR_STOP;\r\ndev_dbg(&port->dev, "%s - stop bits = 2\n", __func__);\r\n} else {\r\nlStop = 0x00;\r\ndev_dbg(&port->dev, "%s - stop bits = 1\n", __func__);\r\n}\r\n#define LCR_BITS_MASK 0x03\r\n#define LCR_STOP_MASK 0x04\r\n#define LCR_PAR_MASK 0x38\r\nmos7720_port->shadowLCR &=\r\n~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\r\nmos7720_port->shadowLCR |= (lData | lParity | lStop);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\r\nwrite_mos_reg(serial, port_number, MOS7720_LCR,\r\nmos7720_port->shadowLCR);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nmos7720_port->shadowMCR = UART_MCR_OUT2;\r\nif (cflag & CBAUD)\r\nmos7720_port->shadowMCR |= (UART_MCR_DTR | UART_MCR_RTS);\r\nif (cflag & CRTSCTS) {\r\nmos7720_port->shadowMCR |= (UART_MCR_XONANY);\r\nif (port_number)\r\nwrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG,\r\n0x01);\r\nelse\r\nwrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG,\r\n0x02);\r\n} else\r\nmos7720_port->shadowMCR &= ~(UART_MCR_XONANY);\r\nwrite_mos_reg(serial, port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\ndev_dbg(&port->dev, "Picked default baud...\n");\r\nbaud = 9600;\r\n}\r\nif (baud >= 230400) {\r\nset_higher_rates(mos7720_port, baud);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\r\nreturn;\r\n}\r\ndev_dbg(&port->dev, "%s - baud rate = %d\n", __func__, baud);\r\nstatus = send_cmd_write_baud_rate(mos7720_port, baud);\r\nif (cflag & CBAUD)\r\ntty_encode_baud_rate(tty, baud, baud);\r\nwrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nstatus = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (status)\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, status = %d\n", status);\r\n}\r\n}\r\nstatic void mos7720_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nint status;\r\nunsigned int cflag;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\ndev_dbg(&port->dev, "setting termios - ASPIRE\n");\r\ncflag = tty->termios.c_cflag;\r\ndev_dbg(&port->dev, "%s - cflag %08x iflag %08x\n", __func__,\r\ntty->termios.c_cflag, RELEVANT_IFLAG(tty->termios.c_iflag));\r\ndev_dbg(&port->dev, "%s - old cflag %08x old iflag %08x\n", __func__,\r\nold_termios->c_cflag, RELEVANT_IFLAG(old_termios->c_iflag));\r\nchange_port_settings(tty, mos7720_port, old_termios);\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nstatus = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (status)\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, status = %d\n", status);\r\n}\r\n}\r\nstatic int get_lsr_info(struct tty_struct *tty,\r\nstruct moschip_port *mos7720_port, unsigned int __user *value)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int result = 0;\r\nunsigned char data = 0;\r\nint port_number = port->port_number;\r\nint count;\r\ncount = mos7720_chars_in_buffer(tty);\r\nif (count == 0) {\r\nread_mos_reg(port->serial, port_number, MOS7720_LSR, &data);\r\nif ((data & (UART_LSR_TEMT | UART_LSR_THRE))\r\n== (UART_LSR_TEMT | UART_LSR_THRE)) {\r\ndev_dbg(&port->dev, "%s -- Empty\n", __func__);\r\nresult = TIOCSER_TEMT;\r\n}\r\n}\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7720_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nunsigned int result = 0;\r\nunsigned int mcr ;\r\nunsigned int msr ;\r\nmcr = mos7720_port->shadowMCR;\r\nmsr = mos7720_port->shadowMSR;\r\nresult = ((mcr & UART_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & UART_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((msr & UART_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & UART_MSR_DCD) ? TIOCM_CAR : 0)\r\n| ((msr & UART_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & UART_MSR_DSR) ? TIOCM_DSR : 0);\r\nreturn result;\r\n}\r\nstatic int mos7720_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nunsigned int mcr ;\r\nmcr = mos7720_port->shadowMCR;\r\nif (set & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~UART_MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~UART_MCR_LOOP;\r\nmos7720_port->shadowMCR = mcr;\r\nwrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nreturn 0;\r\n}\r\nstatic int set_modem_info(struct moschip_port *mos7720_port, unsigned int cmd,\r\nunsigned int __user *value)\r\n{\r\nunsigned int mcr;\r\nunsigned int arg;\r\nstruct usb_serial_port *port;\r\nif (mos7720_port == NULL)\r\nreturn -1;\r\nport = (struct usb_serial_port *)mos7720_port->port;\r\nmcr = mos7720_port->shadowMCR;\r\nif (copy_from_user(&arg, value, sizeof(int)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase TIOCMBIS:\r\nif (arg & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (arg & TIOCM_DTR)\r\nmcr |= UART_MCR_RTS;\r\nif (arg & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nbreak;\r\ncase TIOCMBIC:\r\nif (arg & TIOCM_RTS)\r\nmcr &= ~UART_MCR_RTS;\r\nif (arg & TIOCM_DTR)\r\nmcr &= ~UART_MCR_RTS;\r\nif (arg & TIOCM_LOOP)\r\nmcr &= ~UART_MCR_LOOP;\r\nbreak;\r\n}\r\nmos7720_port->shadowMCR = mcr;\r\nwrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\r\nmos7720_port->shadowMCR);\r\nreturn 0;\r\n}\r\nstatic int get_serial_info(struct moschip_port *mos7720_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = mos7720_port->port->minor;\r\ntmp.port = mos7720_port->port->port_number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = NUM_URBS * URB_TRANSFER_BUFFER_SIZE;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7720_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\ndev_dbg(&port->dev, "%s TIOCSERGETLSR\n", __func__);\r\nreturn get_lsr_info(tty, mos7720_port,\r\n(unsigned int __user *)arg);\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ndev_dbg(&port->dev, "%s TIOCMSET/TIOCMBIC/TIOCMSET\n", __func__);\r\nreturn set_modem_info(mos7720_port, cmd,\r\n(unsigned int __user *)arg);\r\ncase TIOCGSERIAL:\r\ndev_dbg(&port->dev, "%s TIOCGSERIAL\n", __func__);\r\nreturn get_serial_info(mos7720_port,\r\n(struct serial_struct __user *)arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int mos7720_startup(struct usb_serial *serial)\r\n{\r\nstruct usb_device *dev;\r\nchar data;\r\nu16 product;\r\nint ret_val;\r\nproduct = le16_to_cpu(serial->dev->descriptor.idProduct);\r\ndev = serial->dev;\r\nif (product == MOSCHIP_DEVICE_ID_7715) {\r\nstruct usb_serial_port *tmp = serial->port[0];\r\nserial->port[0] = serial->port[1];\r\nserial->port[1] = tmp;\r\nserial->port[0]->interrupt_in_urb = tmp->interrupt_in_urb;\r\nserial->port[0]->interrupt_in_buffer = tmp->interrupt_in_buffer;\r\nserial->port[0]->interrupt_in_endpointAddress =\r\ntmp->interrupt_in_endpointAddress;\r\nserial->port[1]->interrupt_in_urb = NULL;\r\nserial->port[1]->interrupt_in_buffer = NULL;\r\n}\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n(__u8)0x03, 0x00, 0x01, 0x00, NULL, 0x00, 5000);\r\nret_val = usb_submit_urb(serial->port[0]->interrupt_in_urb, GFP_KERNEL);\r\nif (ret_val)\r\ndev_err(&dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, ret_val);\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\nif (product == MOSCHIP_DEVICE_ID_7715) {\r\nret_val = mos7715_parport_init(serial);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\n}\r\n#endif\r\nread_mos_reg(serial, 0, MOS7720_LSR, &data);\r\ndev_dbg(&dev->dev, "LSR:%x\n", data);\r\nreturn 0;\r\n}\r\nstatic void mos7720_release(struct usb_serial *serial)\r\n{\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\nif (le16_to_cpu(serial->dev->descriptor.idProduct)\r\n== MOSCHIP_DEVICE_ID_7715) {\r\nstruct urbtracker *urbtrack;\r\nunsigned long flags;\r\nstruct mos7715_parport *mos_parport =\r\nusb_get_serial_data(serial);\r\nspin_lock(&release_lock);\r\nmos_parport->pp->private_data = NULL;\r\nspin_unlock(&release_lock);\r\nif (mos_parport->msg_pending)\r\nwait_for_completion_timeout(&mos_parport->syncmsg_compl,\r\nmsecs_to_jiffies(MOS_WDR_TIMEOUT));\r\nparport_remove_port(mos_parport->pp);\r\nusb_set_serial_data(serial, NULL);\r\nmos_parport->serial = NULL;\r\ntasklet_kill(&mos_parport->urb_tasklet);\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_for_each_entry(urbtrack,\r\n&mos_parport->active_urbs,\r\nurblist_entry)\r\nusb_unlink_urb(urbtrack->urb);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nparport_del_port(mos_parport->pp);\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\n}\r\n#endif\r\n}\r\nstatic int mos7720_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct moschip_port *mos7720_port;\r\nmos7720_port = kzalloc(sizeof(*mos7720_port), GFP_KERNEL);\r\nif (!mos7720_port)\r\nreturn -ENOMEM;\r\nport->interrupt_in_endpointAddress =\r\nport->serial->port[0]->interrupt_in_endpointAddress;\r\nmos7720_port->port = port;\r\nusb_set_serial_port_data(port, mos7720_port);\r\nreturn 0;\r\n}\r\nstatic int mos7720_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct moschip_port *mos7720_port;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nkfree(mos7720_port);\r\nreturn 0;\r\n}
