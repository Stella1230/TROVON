static bool brcmf_p2p_is_pub_action(void *frame, u32 frame_len)\r\n{\r\nstruct brcmf_p2p_pub_act_frame *pact_frm;\r\nif (frame == NULL)\r\nreturn false;\r\npact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\r\nif (frame_len < sizeof(struct brcmf_p2p_pub_act_frame) - 1)\r\nreturn false;\r\nif (pact_frm->category == P2P_PUB_AF_CATEGORY &&\r\npact_frm->action == P2P_PUB_AF_ACTION &&\r\npact_frm->oui_type == P2P_VER &&\r\nmemcmp(pact_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool brcmf_p2p_is_p2p_action(void *frame, u32 frame_len)\r\n{\r\nstruct brcmf_p2p_action_frame *act_frm;\r\nif (frame == NULL)\r\nreturn false;\r\nact_frm = (struct brcmf_p2p_action_frame *)frame;\r\nif (frame_len < sizeof(struct brcmf_p2p_action_frame) - 1)\r\nreturn false;\r\nif (act_frm->category == P2P_AF_CATEGORY &&\r\nact_frm->type == P2P_VER &&\r\nmemcmp(act_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool brcmf_p2p_is_gas_action(void *frame, u32 frame_len)\r\n{\r\nstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\r\nif (frame == NULL)\r\nreturn false;\r\nsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\r\nif (frame_len < sizeof(struct brcmf_p2psd_gas_pub_act_frame) - 1)\r\nreturn false;\r\nif (sd_act_frm->category != P2PSD_ACTION_CATEGORY)\r\nreturn false;\r\nif (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||\r\nsd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP ||\r\nsd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ ||\r\nsd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void brcmf_p2p_print_actframe(bool tx, void *frame, u32 frame_len)\r\n{\r\nstruct brcmf_p2p_pub_act_frame *pact_frm;\r\nstruct brcmf_p2p_action_frame *act_frm;\r\nstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\r\nif (!frame || frame_len <= 2)\r\nreturn;\r\nif (brcmf_p2p_is_pub_action(frame, frame_len)) {\r\npact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\r\nswitch (pact_frm->subtype) {\r\ncase P2P_PAF_GON_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Group Owner Negotiation Req Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_GON_RSP:\r\nbrcmf_dbg(TRACE, "%s P2P Group Owner Negotiation Rsp Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_GON_CONF:\r\nbrcmf_dbg(TRACE, "%s P2P Group Owner Negotiation Confirm Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_INVITE_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Invitation Request Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_INVITE_RSP:\r\nbrcmf_dbg(TRACE, "%s P2P Invitation Response Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_DEVDIS_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Device Discoverability Request Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_DEVDIS_RSP:\r\nbrcmf_dbg(TRACE, "%s P2P Device Discoverability Response Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_PROVDIS_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Provision Discovery Request Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_PAF_PROVDIS_RSP:\r\nbrcmf_dbg(TRACE, "%s P2P Provision Discovery Response Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ndefault:\r\nbrcmf_dbg(TRACE, "%s Unknown P2P Public Action Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\n}\r\n} else if (brcmf_p2p_is_p2p_action(frame, frame_len)) {\r\nact_frm = (struct brcmf_p2p_action_frame *)frame;\r\nswitch (act_frm->subtype) {\r\ncase P2P_AF_NOTICE_OF_ABSENCE:\r\nbrcmf_dbg(TRACE, "%s P2P Notice of Absence Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_AF_PRESENCE_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Presence Request Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_AF_PRESENCE_RSP:\r\nbrcmf_dbg(TRACE, "%s P2P Presence Response Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2P_AF_GO_DISC_REQ:\r\nbrcmf_dbg(TRACE, "%s P2P Discoverability Request Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ndefault:\r\nbrcmf_dbg(TRACE, "%s Unknown P2P Action Frame\n",\r\n(tx) ? "TX" : "RX");\r\n}\r\n} else if (brcmf_p2p_is_gas_action(frame, frame_len)) {\r\nsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\r\nswitch (sd_act_frm->action) {\r\ncase P2PSD_ACTION_ID_GAS_IREQ:\r\nbrcmf_dbg(TRACE, "%s P2P GAS Initial Request\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2PSD_ACTION_ID_GAS_IRESP:\r\nbrcmf_dbg(TRACE, "%s P2P GAS Initial Response\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2PSD_ACTION_ID_GAS_CREQ:\r\nbrcmf_dbg(TRACE, "%s P2P GAS Comback Request\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ncase P2PSD_ACTION_ID_GAS_CRESP:\r\nbrcmf_dbg(TRACE, "%s P2P GAS Comback Response\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\ndefault:\r\nbrcmf_dbg(TRACE, "%s Unknown P2P GAS Frame\n",\r\n(tx) ? "TX" : "RX");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void brcmf_p2p_print_actframe(bool tx, void *frame, u32 frame_len)\r\n{\r\n}\r\nstatic int brcmf_p2p_set_firmware(struct brcmf_if *ifp, u8 *p2p_mac)\r\n{\r\ns32 ret = 0;\r\nbrcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\r\nbrcmf_fil_iovar_int_set(ifp, "apsta", 1);\r\nbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\r\nbrcmf_fil_iovar_int_set(ifp, "p2p_disc", 0);\r\nret = brcmf_fil_iovar_data_set(ifp, "p2p_da_override", p2p_mac,\r\nETH_ALEN);\r\nif (ret)\r\nbrcmf_err("failed to update device address ret %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void brcmf_p2p_generate_bss_mac(struct brcmf_p2p_info *p2p, u8 *dev_addr)\r\n{\r\nstruct brcmf_if *pri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\r\nbool local_admin = false;\r\nif (!dev_addr || is_zero_ether_addr(dev_addr)) {\r\ndev_addr = pri_ifp->mac_addr;\r\nlocal_admin = true;\r\n}\r\nmemcpy(p2p->dev_addr, dev_addr, ETH_ALEN);\r\nif (local_admin)\r\np2p->dev_addr[0] |= 0x02;\r\nmemcpy(p2p->int_addr, p2p->dev_addr, ETH_ALEN);\r\np2p->int_addr[0] |= 0x02;\r\np2p->int_addr[4] ^= 0x80;\r\n}\r\nstatic bool brcmf_p2p_scan_is_p2p_request(struct cfg80211_scan_request *request)\r\n{\r\nstruct cfg80211_ssid *ssids = request->ssids;\r\nint i;\r\nfor (i = 0; i < request->n_ssids; i++) {\r\nif (ssids[i].ssid_len != BRCMF_P2P_WILDCARD_SSID_LEN)\r\ncontinue;\r\nbrcmf_dbg(INFO, "comparing ssid \"%s\"", ssids[i].ssid);\r\nif (!memcmp(BRCMF_P2P_WILDCARD_SSID, ssids[i].ssid,\r\nBRCMF_P2P_WILDCARD_SSID_LEN))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic s32 brcmf_p2p_set_discover_state(struct brcmf_if *ifp, u8 state,\r\nu16 chanspec, u16 listen_ms)\r\n{\r\nstruct brcmf_p2p_disc_st_le discover_state;\r\ns32 ret = 0;\r\nbrcmf_dbg(TRACE, "enter\n");\r\ndiscover_state.state = state;\r\ndiscover_state.chspec = cpu_to_le16(chanspec);\r\ndiscover_state.dwell = cpu_to_le16(listen_ms);\r\nret = brcmf_fil_bsscfg_data_set(ifp, "p2p_state", &discover_state,\r\nsizeof(discover_state));\r\nreturn ret;\r\n}\r\nstatic s32 brcmf_p2p_deinit_discovery(struct brcmf_p2p_info *p2p)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nbrcmf_dbg(TRACE, "enter\n");\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\n(void)brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\r\n(void)brcmf_fil_iovar_int_set(vif->ifp, "p2p_disc", 0);\r\nreturn 0;\r\n}\r\nstatic int brcmf_p2p_enable_discovery(struct brcmf_p2p_info *p2p)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\ns32 ret = 0;\r\nbrcmf_dbg(TRACE, "enter\n");\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nif (!vif) {\r\nbrcmf_err("P2P config device not available\n");\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (test_bit(BRCMF_P2P_STATUS_ENABLED, &p2p->status)) {\r\nbrcmf_dbg(INFO, "P2P config device already configured\n");\r\ngoto exit;\r\n}\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\r\nret = brcmf_fil_iovar_int_set(vif->ifp, "p2p_disc", 1);\r\nif (ret < 0) {\r\nbrcmf_err("set p2p_disc error\n");\r\ngoto exit;\r\n}\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nret = brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\r\nif (ret < 0) {\r\nbrcmf_err("unable to set WL_P2P_DISC_ST_SCAN\n");\r\ngoto exit;\r\n}\r\nret = brcmf_fil_bsscfg_int_set(vif->ifp, "wsec", AES_ENABLED);\r\nif (ret < 0) {\r\nbrcmf_err("wsec error %d\n", ret);\r\ngoto exit;\r\n}\r\nset_bit(BRCMF_P2P_STATUS_ENABLED, &p2p->status);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic s32 brcmf_p2p_escan(struct brcmf_p2p_info *p2p, u32 num_chans,\r\nu16 chanspecs[], s32 search_state,\r\nenum p2p_bss_type bss_type)\r\n{\r\ns32 ret = 0;\r\ns32 memsize = offsetof(struct brcmf_p2p_scan_le,\r\neparams.params_le.channel_list);\r\ns32 nprobes;\r\ns32 active;\r\nu32 i;\r\nu8 *memblk;\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct brcmf_p2p_scan_le *p2p_params;\r\nstruct brcmf_scan_params_le *sparams;\r\nmemsize += num_chans * sizeof(__le16);\r\nmemblk = kzalloc(memsize, GFP_KERNEL);\r\nif (!memblk)\r\nreturn -ENOMEM;\r\nvif = p2p->bss_idx[bss_type].vif;\r\nif (vif == NULL) {\r\nbrcmf_err("no vif for bss type %d\n", bss_type);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\np2p_params = (struct brcmf_p2p_scan_le *)memblk;\r\nsparams = &p2p_params->eparams.params_le;\r\nswitch (search_state) {\r\ncase WL_P2P_DISC_ST_SEARCH:\r\nbreak;\r\ncase WL_P2P_DISC_ST_SCAN:\r\nsparams->ssid_le.SSID_len =\r\ncpu_to_le32(BRCMF_P2P_WILDCARD_SSID_LEN);\r\nmemcpy(sparams->ssid_le.SSID, BRCMF_P2P_WILDCARD_SSID,\r\nBRCMF_P2P_WILDCARD_SSID_LEN);\r\nbreak;\r\ndefault:\r\nbrcmf_err(" invalid search state %d\n", search_state);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nbrcmf_p2p_set_discover_state(vif->ifp, search_state, 0, 0);\r\np2p_params->type = 'E';\r\nsparams->bss_type = DOT11_BSSTYPE_ANY;\r\nif (p2p->cfg->active_scan)\r\nsparams->scan_type = 0;\r\nelse\r\nsparams->scan_type = 1;\r\neth_broadcast_addr(sparams->bssid);\r\nsparams->home_time = cpu_to_le32(P2PAPI_SCAN_HOME_TIME_MS);\r\nif (num_chans == SOCIAL_CHAN_CNT || num_chans == (SOCIAL_CHAN_CNT + 1))\r\nactive = P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS;\r\nelse if (num_chans == AF_PEER_SEARCH_CNT)\r\nactive = P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS;\r\nelse if (brcmf_get_vif_state_any(p2p->cfg, BRCMF_VIF_STATUS_CONNECTED))\r\nactive = -1;\r\nelse\r\nactive = P2PAPI_SCAN_DWELL_TIME_MS;\r\nif (num_chans == 1) {\r\nactive = WL_SCAN_CONNECT_DWELL_TIME_MS;\r\nnprobes = active / WL_SCAN_JOIN_PROBE_INTERVAL_MS;\r\n} else {\r\nnprobes = active / P2PAPI_SCAN_NPROBS_TIME_MS;\r\n}\r\nif (nprobes <= 0)\r\nnprobes = 1;\r\nbrcmf_dbg(INFO, "nprobes # %d, active_time %d\n", nprobes, active);\r\nsparams->active_time = cpu_to_le32(active);\r\nsparams->nprobes = cpu_to_le32(nprobes);\r\nsparams->passive_time = cpu_to_le32(-1);\r\nsparams->channel_num = cpu_to_le32(num_chans &\r\nBRCMF_SCAN_PARAMS_COUNT_MASK);\r\nfor (i = 0; i < num_chans; i++)\r\nsparams->channel_list[i] = cpu_to_le16(chanspecs[i]);\r\np2p_params->eparams.version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\r\np2p_params->eparams.action = cpu_to_le16(WL_ESCAN_ACTION_START);\r\np2p_params->eparams.sync_id = cpu_to_le16(0x1234);\r\nret = brcmf_fil_bsscfg_data_set(vif->ifp, "p2p_scan", memblk, memsize);\r\nif (!ret)\r\nset_bit(BRCMF_SCAN_STATUS_BUSY, &p2p->cfg->scan_status);\r\nexit:\r\nkfree(memblk);\r\nreturn ret;\r\n}\r\nstatic s32 brcmf_p2p_run_escan(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_if *ifp,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\ns32 err = 0;\r\ns32 search_state = WL_P2P_DISC_ST_SCAN;\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct net_device *dev = NULL;\r\nint i, num_nodfs = 0;\r\nu16 *chanspecs;\r\nbrcmf_dbg(TRACE, "enter\n");\r\nif (!request) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (request->n_channels) {\r\nchanspecs = kcalloc(request->n_channels, sizeof(*chanspecs),\r\nGFP_KERNEL);\r\nif (!chanspecs) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;\r\nif (vif)\r\ndev = vif->wdev.netdev;\r\nif (request->n_channels == 3 &&\r\nrequest->channels[0]->hw_value == SOCIAL_CHAN_1 &&\r\nrequest->channels[1]->hw_value == SOCIAL_CHAN_2 &&\r\nrequest->channels[2]->hw_value == SOCIAL_CHAN_3) {\r\nsearch_state = WL_P2P_DISC_ST_SEARCH;\r\nbrcmf_dbg(INFO, "P2P SEARCH PHASE START\n");\r\n} else if (dev != NULL &&\r\nvif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\r\nbrcmf_dbg(INFO, "Already a GO. Do SEARCH Only\n");\r\nsearch_state = WL_P2P_DISC_ST_SEARCH;\r\n} else {\r\nbrcmf_dbg(INFO, "P2P SCAN STATE START\n");\r\n}\r\nfor (i = 0; i < request->n_channels; i++) {\r\nstruct ieee80211_channel *chan = request->channels[i];\r\nif (chan->flags & (IEEE80211_CHAN_RADAR |\r\nIEEE80211_CHAN_NO_IR))\r\ncontinue;\r\nchanspecs[i] = channel_to_chanspec(&p2p->cfg->d11inf,\r\nchan);\r\nbrcmf_dbg(INFO, "%d: chan=%d, channel spec=%x\n",\r\nnum_nodfs, chan->hw_value, chanspecs[i]);\r\nnum_nodfs++;\r\n}\r\nerr = brcmf_p2p_escan(p2p, num_nodfs, chanspecs, search_state,\r\nP2PAPI_BSSCFG_DEVICE);\r\nkfree(chanspecs);\r\n}\r\nexit:\r\nif (err)\r\nbrcmf_err("error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_p2p_find_listen_channel(const u8 *ie, u32 ie_len)\r\n{\r\nu8 channel_ie[5];\r\ns32 listen_channel;\r\ns32 err;\r\nerr = cfg80211_get_p2p_attr(ie, ie_len,\r\nIEEE80211_P2P_ATTR_LISTEN_CHANNEL,\r\nchannel_ie, sizeof(channel_ie));\r\nif (err < 0)\r\nreturn err;\r\nlisten_channel = (s32)channel_ie[3 + 1];\r\nif (listen_channel == SOCIAL_CHAN_1 ||\r\nlisten_channel == SOCIAL_CHAN_2 ||\r\nlisten_channel == SOCIAL_CHAN_3) {\r\nbrcmf_dbg(INFO, "Found my Listen Channel %d\n", listen_channel);\r\nreturn listen_channel;\r\n}\r\nreturn -EPERM;\r\n}\r\nint brcmf_p2p_scan_prep(struct wiphy *wiphy,\r\nstruct cfg80211_scan_request *request,\r\nstruct brcmf_cfg80211_vif *vif)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nint err = 0;\r\nif (brcmf_p2p_scan_is_p2p_request(request)) {\r\nerr = brcmf_p2p_find_listen_channel(request->ie,\r\nrequest->ie_len);\r\nif (err < 0)\r\nreturn err;\r\np2p->afx_hdl.my_listen_chan = err;\r\nclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\nbrcmf_dbg(INFO, "P2P: GO_NEG_PHASE status cleared\n");\r\nerr = brcmf_p2p_enable_discovery(p2p);\r\nif (err)\r\nreturn err;\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\ncfg->escan_info.run = brcmf_p2p_run_escan;\r\n}\r\nerr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBREQ_FLAG,\r\nrequest->ie, request->ie_len);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_p2p_discover_listen(struct brcmf_p2p_info *p2p, u16 channel, u32 duration)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct brcmu_chan ch;\r\ns32 err = 0;\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nif (!vif) {\r\nbrcmf_err("Discovery is not set, so we have nothing to do\n");\r\nerr = -EPERM;\r\ngoto exit;\r\n}\r\nif (test_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status)) {\r\nbrcmf_err("Previous LISTEN is not completed yet\n");\r\ngoto exit;\r\n}\r\nch.chnum = channel;\r\nch.bw = BRCMU_CHAN_BW_20;\r\np2p->cfg->d11inf.encchspec(&ch);\r\nerr = brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_LISTEN,\r\nch.chspec, (u16)duration);\r\nif (!err) {\r\nset_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status);\r\np2p->remain_on_channel_cookie++;\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nint brcmf_p2p_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct ieee80211_channel *channel,\r\nunsigned int duration, u64 *cookie)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\ns32 err;\r\nu16 channel_nr;\r\nchannel_nr = ieee80211_frequency_to_channel(channel->center_freq);\r\nbrcmf_dbg(TRACE, "Enter, channel: %d, duration ms (%d)\n", channel_nr,\r\nduration);\r\nerr = brcmf_p2p_enable_discovery(p2p);\r\nif (err)\r\ngoto exit;\r\nerr = brcmf_p2p_discover_listen(p2p, channel_nr, duration);\r\nif (err)\r\ngoto exit;\r\nmemcpy(&p2p->remain_on_channel, channel, sizeof(*channel));\r\n*cookie = p2p->remain_on_channel_cookie;\r\ncfg80211_ready_on_channel(wdev, *cookie, channel, duration, GFP_KERNEL);\r\nexit:\r\nreturn err;\r\n}\r\nint brcmf_p2p_notify_listen_complete(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (test_and_clear_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN,\r\n&p2p->status)) {\r\nif (test_and_clear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\r\n&p2p->status)) {\r\nclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\r\n&p2p->status);\r\nbrcmf_dbg(INFO, "Listen DONE, wake up wait_next_af\n");\r\ncomplete(&p2p->wait_next_af);\r\n}\r\ncfg80211_remain_on_channel_expired(&ifp->vif->wdev,\r\np2p->remain_on_channel_cookie,\r\n&p2p->remain_on_channel,\r\nGFP_KERNEL);\r\n}\r\nreturn 0;\r\n}\r\nvoid brcmf_p2p_cancel_remain_on_channel(struct brcmf_if *ifp)\r\n{\r\nif (!ifp)\r\nreturn;\r\nbrcmf_p2p_set_discover_state(ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\r\nbrcmf_p2p_notify_listen_complete(ifp, NULL, NULL);\r\n}\r\nstatic s32 brcmf_p2p_act_frm_search(struct brcmf_p2p_info *p2p, u16 channel)\r\n{\r\ns32 err;\r\nu32 channel_cnt;\r\nu16 *default_chan_list;\r\nu32 i;\r\nstruct brcmu_chan ch;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (channel)\r\nchannel_cnt = AF_PEER_SEARCH_CNT;\r\nelse\r\nchannel_cnt = SOCIAL_CHAN_CNT;\r\ndefault_chan_list = kzalloc(channel_cnt * sizeof(*default_chan_list),\r\nGFP_KERNEL);\r\nif (default_chan_list == NULL) {\r\nbrcmf_err("channel list allocation failed\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nch.bw = BRCMU_CHAN_BW_20;\r\nif (channel) {\r\nch.chnum = channel;\r\np2p->cfg->d11inf.encchspec(&ch);\r\nfor (i = 0; i < channel_cnt; i++)\r\ndefault_chan_list[i] = ch.chspec;\r\n} else {\r\nch.chnum = SOCIAL_CHAN_1;\r\np2p->cfg->d11inf.encchspec(&ch);\r\ndefault_chan_list[0] = ch.chspec;\r\nch.chnum = SOCIAL_CHAN_2;\r\np2p->cfg->d11inf.encchspec(&ch);\r\ndefault_chan_list[1] = ch.chspec;\r\nch.chnum = SOCIAL_CHAN_3;\r\np2p->cfg->d11inf.encchspec(&ch);\r\ndefault_chan_list[2] = ch.chspec;\r\n}\r\nerr = brcmf_p2p_escan(p2p, channel_cnt, default_chan_list,\r\nWL_P2P_DISC_ST_SEARCH, P2PAPI_BSSCFG_DEVICE);\r\nkfree(default_chan_list);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void brcmf_p2p_afx_handler(struct work_struct *work)\r\n{\r\nstruct afx_hdl *afx_hdl = container_of(work, struct afx_hdl, afx_work);\r\nstruct brcmf_p2p_info *p2p = container_of(afx_hdl,\r\nstruct brcmf_p2p_info,\r\nafx_hdl);\r\ns32 err;\r\nif (!afx_hdl->is_active)\r\nreturn;\r\nif (afx_hdl->is_listen && afx_hdl->my_listen_chan)\r\nerr = brcmf_p2p_discover_listen(p2p, afx_hdl->my_listen_chan,\r\n100 * (1 + prandom_u32() % 3));\r\nelse\r\nerr = brcmf_p2p_act_frm_search(p2p, afx_hdl->peer_listen_chan);\r\nif (err) {\r\nbrcmf_err("ERROR occurred! value is (%d)\n", err);\r\nif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\r\n&p2p->status))\r\ncomplete(&afx_hdl->act_frm_scan);\r\n}\r\n}\r\nstatic s32 brcmf_p2p_af_searching_channel(struct brcmf_p2p_info *p2p)\r\n{\r\nstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\r\nstruct brcmf_cfg80211_vif *pri_vif;\r\nunsigned long duration;\r\ns32 retry;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\npri_vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\r\nreinit_completion(&afx_hdl->act_frm_scan);\r\nset_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);\r\nafx_hdl->is_active = true;\r\nafx_hdl->peer_chan = P2P_INVALID_CHANNEL;\r\nretry = 0;\r\nduration = msecs_to_jiffies(P2P_AF_FRM_SCAN_MAX_WAIT);\r\nwhile ((retry < P2P_CHANNEL_SYNC_RETRY) &&\r\n(afx_hdl->peer_chan == P2P_INVALID_CHANNEL)) {\r\nafx_hdl->is_listen = false;\r\nbrcmf_dbg(TRACE, "Scheduling action frame for sending.. (%d)\n",\r\nretry);\r\nschedule_work(&afx_hdl->afx_work);\r\nwait_for_completion_timeout(&afx_hdl->act_frm_scan, duration);\r\nif ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||\r\n(!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\r\n&p2p->status)))\r\nbreak;\r\nif (afx_hdl->my_listen_chan) {\r\nbrcmf_dbg(TRACE, "Scheduling listen peer, channel=%d\n",\r\nafx_hdl->my_listen_chan);\r\nafx_hdl->is_listen = true;\r\nschedule_work(&afx_hdl->afx_work);\r\nwait_for_completion_timeout(&afx_hdl->act_frm_scan,\r\nduration);\r\n}\r\nif ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||\r\n(!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\r\n&p2p->status)))\r\nbreak;\r\nretry++;\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &pri_vif->sme_state) ||\r\ntest_bit(BRCMF_VIF_STATUS_CONNECTING, &pri_vif->sme_state))\r\nmsleep(P2P_DEFAULT_SLEEP_TIME_VSDB);\r\n}\r\nbrcmf_dbg(TRACE, "Completed search/listen peer_chan=%d\n",\r\nafx_hdl->peer_chan);\r\nafx_hdl->is_active = false;\r\nclear_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);\r\nreturn afx_hdl->peer_chan;\r\n}\r\nbool brcmf_p2p_scan_finding_common_channel(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_bss_info_le *bi)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\r\nstruct brcmu_chan ch;\r\nu8 *ie;\r\ns32 err;\r\nu8 p2p_dev_addr[ETH_ALEN];\r\nif (!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status))\r\nreturn false;\r\nif (bi == NULL) {\r\nbrcmf_dbg(TRACE, "ACTION FRAME SCAN Done\n");\r\nif (afx_hdl->peer_chan == P2P_INVALID_CHANNEL)\r\ncomplete(&afx_hdl->act_frm_scan);\r\nreturn true;\r\n}\r\nie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\r\nmemset(p2p_dev_addr, 0, sizeof(p2p_dev_addr));\r\nerr = cfg80211_get_p2p_attr(ie, le32_to_cpu(bi->ie_length),\r\nIEEE80211_P2P_ATTR_DEVICE_INFO,\r\np2p_dev_addr, sizeof(p2p_dev_addr));\r\nif (err < 0)\r\nerr = cfg80211_get_p2p_attr(ie, le32_to_cpu(bi->ie_length),\r\nIEEE80211_P2P_ATTR_DEVICE_ID,\r\np2p_dev_addr, sizeof(p2p_dev_addr));\r\nif ((err >= 0) &&\r\n(ether_addr_equal(p2p_dev_addr, afx_hdl->tx_dst_addr))) {\r\nif (!bi->ctl_ch) {\r\nch.chspec = le16_to_cpu(bi->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nbi->ctl_ch = ch.control_ch_num;\r\n}\r\nafx_hdl->peer_chan = bi->ctl_ch;\r\nbrcmf_dbg(TRACE, "ACTION FRAME SCAN : Peer %pM found, channel : %d\n",\r\nafx_hdl->tx_dst_addr, afx_hdl->peer_chan);\r\ncomplete(&afx_hdl->act_frm_scan);\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nbrcmf_p2p_stop_wait_next_action_frame(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_if *ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\r\nif (test_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status) &&\r\n(test_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status) ||\r\ntest_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status))) {\r\nbrcmf_dbg(TRACE, "*** Wake UP ** abort actframe iovar\n");\r\nif (p2p->af_sent_channel)\r\nbrcmf_notify_escan_complete(cfg, ifp, true, true);\r\n} else if (test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\r\n&p2p->status)) {\r\nbrcmf_dbg(TRACE, "*** Wake UP ** abort listen for next af frame\n");\r\nbrcmf_notify_escan_complete(cfg, ifp, true, true);\r\n}\r\n}\r\nstatic bool\r\nbrcmf_p2p_gon_req_collision(struct brcmf_p2p_info *p2p, u8 *mac)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = p2p->cfg;\r\nstruct brcmf_if *ifp;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) ||\r\n!p2p->gon_req_action)\r\nreturn false;\r\nbrcmf_dbg(TRACE, "GO Negotiation Request COLLISION !!!\n");\r\nifp = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->ifp;\r\nif (memcmp(mac, ifp->mac_addr, ETH_ALEN) < 0) {\r\nbrcmf_dbg(INFO, "Block transmit gon req !!!\n");\r\np2p->block_gon_req_tx = true;\r\nif (test_and_clear_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\r\n&p2p->status))\r\ncomplete(&p2p->afx_hdl.act_frm_scan);\r\nif (test_and_clear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\r\n&p2p->status))\r\nbrcmf_p2p_stop_wait_next_action_frame(cfg);\r\nreturn false;\r\n}\r\nbrcmf_dbg(INFO, "Drop received gon req !!!\n");\r\nreturn true;\r\n}\r\nint brcmf_p2p_notify_action_frame_rx(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\r\nstruct wireless_dev *wdev;\r\nu32 mgmt_frame_len = e->datalen - sizeof(struct brcmf_rx_mgmt_data);\r\nstruct brcmf_rx_mgmt_data *rxframe = (struct brcmf_rx_mgmt_data *)data;\r\nu8 *frame = (u8 *)(rxframe + 1);\r\nstruct brcmf_p2p_pub_act_frame *act_frm;\r\nstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\r\nstruct brcmu_chan ch;\r\nstruct ieee80211_mgmt *mgmt_frame;\r\ns32 freq;\r\nu16 mgmt_type;\r\nu8 action;\r\nif (e->datalen < sizeof(*rxframe)) {\r\nbrcmf_dbg(SCAN, "Event data to small. Ignore\n");\r\nreturn 0;\r\n}\r\nch.chspec = be16_to_cpu(rxframe->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nbrcmf_dbg(INFO, "ifp->vif->mgmt_rx_reg %04x\n", ifp->vif->mgmt_rx_reg);\r\nmgmt_type = (IEEE80211_STYPE_ACTION & IEEE80211_FCTL_STYPE) >> 4;\r\nif ((ifp->vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)\r\nreturn 0;\r\nbrcmf_p2p_print_actframe(false, frame, mgmt_frame_len);\r\naction = P2P_PAF_SUBTYPE_INVALID;\r\nif (brcmf_p2p_is_pub_action(frame, mgmt_frame_len)) {\r\nact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\r\naction = act_frm->subtype;\r\nif ((action == P2P_PAF_GON_REQ) &&\r\n(brcmf_p2p_gon_req_collision(p2p, (u8 *)e->addr))) {\r\nif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\r\n&p2p->status) &&\r\n(ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {\r\nafx_hdl->peer_chan = ch.control_ch_num;\r\nbrcmf_dbg(INFO, "GON request: Peer found, channel=%d\n",\r\nafx_hdl->peer_chan);\r\ncomplete(&afx_hdl->act_frm_scan);\r\n}\r\nreturn 0;\r\n}\r\nif ((action == P2P_PAF_GON_CONF) ||\r\n(action == P2P_PAF_PROVDIS_RSP))\r\nbrcmf_set_mpc(ifp, 1);\r\nif (action == P2P_PAF_GON_CONF) {\r\nbrcmf_dbg(TRACE, "P2P: GO_NEG_PHASE status cleared\n");\r\nclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\n}\r\n} else if (brcmf_p2p_is_gas_action(frame, mgmt_frame_len)) {\r\nsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\r\naction = sd_act_frm->action;\r\n}\r\nif (test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) &&\r\n(p2p->next_af_subtype == action)) {\r\nbrcmf_dbg(TRACE, "We got a right next frame! (%d)\n", action);\r\nclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\r\n&p2p->status);\r\nbrcmf_p2p_stop_wait_next_action_frame(cfg);\r\n}\r\nmgmt_frame = kzalloc(offsetof(struct ieee80211_mgmt, u) +\r\nmgmt_frame_len, GFP_KERNEL);\r\nif (!mgmt_frame) {\r\nbrcmf_err("No memory available for action frame\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(mgmt_frame->da, ifp->mac_addr, ETH_ALEN);\r\nbrcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSSID, mgmt_frame->bssid,\r\nETH_ALEN);\r\nmemcpy(mgmt_frame->sa, e->addr, ETH_ALEN);\r\nmgmt_frame->frame_control = cpu_to_le16(IEEE80211_STYPE_ACTION);\r\nmemcpy(&mgmt_frame->u, frame, mgmt_frame_len);\r\nmgmt_frame_len += offsetof(struct ieee80211_mgmt, u);\r\nfreq = ieee80211_channel_to_frequency(ch.control_ch_num,\r\nch.band == BRCMU_CHAN_BAND_2G ?\r\nNL80211_BAND_2GHZ :\r\nNL80211_BAND_5GHZ);\r\nwdev = &ifp->vif->wdev;\r\ncfg80211_rx_mgmt(wdev, freq, 0, (u8 *)mgmt_frame, mgmt_frame_len, 0);\r\nkfree(mgmt_frame);\r\nreturn 0;\r\n}\r\nint brcmf_p2p_notify_action_tx_complete(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nbrcmf_dbg(INFO, "Enter: event %s, status=%d\n",\r\ne->event_code == BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE ?\r\n"ACTION_FRAME_OFF_CHAN_COMPLETE" : "ACTION_FRAME_COMPLETE",\r\ne->status);\r\nif (!test_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status))\r\nreturn 0;\r\nif (e->event_code == BRCMF_E_ACTION_FRAME_COMPLETE) {\r\nif (e->status == BRCMF_E_STATUS_SUCCESS)\r\nset_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED,\r\n&p2p->status);\r\nelse {\r\nset_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\r\nbrcmf_p2p_stop_wait_next_action_frame(cfg);\r\n}\r\n} else {\r\ncomplete(&p2p->send_af_done);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 brcmf_p2p_tx_action_frame(struct brcmf_p2p_info *p2p,\r\nstruct brcmf_fil_af_params_le *af_params)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\ns32 err = 0;\r\ns32 timeout = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nreinit_completion(&p2p->send_af_done);\r\nclear_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);\r\nclear_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nerr = brcmf_fil_bsscfg_data_set(vif->ifp, "actframe", af_params,\r\nsizeof(*af_params));\r\nif (err) {\r\nbrcmf_err(" sending action frame has failed\n");\r\ngoto exit;\r\n}\r\np2p->af_sent_channel = le32_to_cpu(af_params->channel);\r\np2p->af_tx_sent_jiffies = jiffies;\r\ntimeout = wait_for_completion_timeout(&p2p->send_af_done,\r\nP2P_AF_MAX_WAIT_TIME);\r\nif (test_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status)) {\r\nbrcmf_dbg(TRACE, "TX action frame operation is success\n");\r\n} else {\r\nerr = -EIO;\r\nbrcmf_dbg(TRACE, "TX action frame operation has failed\n");\r\n}\r\nclear_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);\r\nclear_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\r\nexit:\r\nreturn err;\r\n}\r\nstatic s32 brcmf_p2p_pub_af_tx(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_fil_af_params_le *af_params,\r\nstruct brcmf_config_af_params *config_af_params)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_fil_action_frame_le *action_frame;\r\nstruct brcmf_p2p_pub_act_frame *act_frm;\r\ns32 err = 0;\r\nu16 ie_len;\r\naction_frame = &af_params->action_frame;\r\nact_frm = (struct brcmf_p2p_pub_act_frame *)(action_frame->data);\r\nconfig_af_params->extra_listen = true;\r\nswitch (act_frm->subtype) {\r\ncase P2P_PAF_GON_REQ:\r\nbrcmf_dbg(TRACE, "P2P: GO_NEG_PHASE status set\n");\r\nset_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\nconfig_af_params->mpc_onoff = 0;\r\nconfig_af_params->search_channel = true;\r\np2p->next_af_subtype = act_frm->subtype + 1;\r\np2p->gon_req_action = true;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\nbreak;\r\ncase P2P_PAF_GON_RSP:\r\np2p->next_af_subtype = act_frm->subtype + 1;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\nbreak;\r\ncase P2P_PAF_GON_CONF:\r\nbrcmf_dbg(TRACE, "P2P: GO_NEG_PHASE status cleared\n");\r\nclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\nconfig_af_params->mpc_onoff = 1;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\r\nconfig_af_params->extra_listen = false;\r\nbreak;\r\ncase P2P_PAF_INVITE_REQ:\r\nconfig_af_params->search_channel = true;\r\np2p->next_af_subtype = act_frm->subtype + 1;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\nbreak;\r\ncase P2P_PAF_INVITE_RSP:\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\r\nconfig_af_params->extra_listen = false;\r\nbreak;\r\ncase P2P_PAF_DEVDIS_REQ:\r\nconfig_af_params->search_channel = true;\r\np2p->next_af_subtype = act_frm->subtype + 1;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_LONG_DWELL_TIME);\r\nbreak;\r\ncase P2P_PAF_DEVDIS_RSP:\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\r\nconfig_af_params->extra_listen = false;\r\nbreak;\r\ncase P2P_PAF_PROVDIS_REQ:\r\nie_len = le16_to_cpu(action_frame->len) -\r\noffsetof(struct brcmf_p2p_pub_act_frame, elts);\r\nif (cfg80211_get_p2p_attr(&act_frm->elts[0], ie_len,\r\nIEEE80211_P2P_ATTR_GROUP_ID,\r\nNULL, 0) < 0)\r\nconfig_af_params->search_channel = true;\r\nconfig_af_params->mpc_onoff = 0;\r\np2p->next_af_subtype = act_frm->subtype + 1;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\nbreak;\r\ncase P2P_PAF_PROVDIS_RSP:\r\np2p->next_af_subtype = P2P_PAF_GON_REQ;\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\nconfig_af_params->extra_listen = false;\r\nbreak;\r\ndefault:\r\nbrcmf_err("Unknown p2p pub act frame subtype: %d\n",\r\nact_frm->subtype);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nbool brcmf_p2p_send_action_frame(struct brcmf_cfg80211_info *cfg,\r\nstruct net_device *ndev,\r\nstruct brcmf_fil_af_params_le *af_params)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_fil_action_frame_le *action_frame;\r\nstruct brcmf_config_af_params config_af_params;\r\nstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\r\nu16 action_frame_len;\r\nbool ack = false;\r\nu8 category;\r\nu8 action;\r\ns32 tx_retry;\r\ns32 extra_listen_time;\r\nuint delta_ms;\r\naction_frame = &af_params->action_frame;\r\naction_frame_len = le16_to_cpu(action_frame->len);\r\nbrcmf_p2p_print_actframe(true, action_frame->data, action_frame_len);\r\naf_params->dwell_time = cpu_to_le32(P2P_AF_DWELL_TIME);\r\ncategory = action_frame->data[DOT11_ACTION_CAT_OFF];\r\naction = action_frame->data[DOT11_ACTION_ACT_OFF];\r\np2p->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;\r\np2p->gon_req_action = false;\r\nconfig_af_params.mpc_onoff = -1;\r\nconfig_af_params.search_channel = false;\r\nconfig_af_params.extra_listen = false;\r\nif (brcmf_p2p_is_pub_action(action_frame->data, action_frame_len)) {\r\nif (brcmf_p2p_pub_af_tx(cfg, af_params, &config_af_params)) {\r\nbrcmf_err("P2P Public action frame, unknown subtype.\n");\r\n}\r\n} else if (brcmf_p2p_is_gas_action(action_frame->data,\r\naction_frame_len)) {\r\nif (action == P2PSD_ACTION_ID_GAS_IREQ ||\r\naction == P2PSD_ACTION_ID_GAS_CREQ) {\r\nconfig_af_params.search_channel = true;\r\np2p->next_af_subtype = action + 1;\r\naf_params->dwell_time =\r\ncpu_to_le32(P2P_AF_MED_DWELL_TIME);\r\n} else if (action == P2PSD_ACTION_ID_GAS_IRESP ||\r\naction == P2PSD_ACTION_ID_GAS_CRESP) {\r\naf_params->dwell_time =\r\ncpu_to_le32(P2P_AF_MIN_DWELL_TIME);\r\n} else {\r\nbrcmf_err("Unknown action type: %d\n", action);\r\ngoto exit;\r\n}\r\n} else if (brcmf_p2p_is_p2p_action(action_frame->data,\r\naction_frame_len)) {\r\n} else {\r\nbrcmf_err("Unknown Frame: category 0x%x, action 0x%x\n",\r\ncategory, action);\r\nreturn false;\r\n}\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTING,\r\n&p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->sme_state))\r\nmsleep(50);\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\r\nbrcmf_abort_scanning(cfg);\r\nmemcpy(afx_hdl->tx_dst_addr, action_frame->da, ETH_ALEN);\r\nif (config_af_params.mpc_onoff == 0)\r\nbrcmf_set_mpc(ifp, 0);\r\nif (p2p->next_af_subtype != P2P_PAF_SUBTYPE_INVALID) {\r\nset_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);\r\n}\r\np2p->af_sent_channel = 0;\r\nset_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);\r\nif (config_af_params.search_channel &&\r\nIS_P2P_SOCIAL_CHANNEL(le32_to_cpu(af_params->channel)) &&\r\np2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->saved_ie.probe_req_ie_len) {\r\nafx_hdl = &p2p->afx_hdl;\r\nafx_hdl->peer_listen_chan = le32_to_cpu(af_params->channel);\r\nif (brcmf_p2p_af_searching_channel(p2p) ==\r\nP2P_INVALID_CHANNEL) {\r\nbrcmf_err("Couldn't find peer's channel.\n");\r\ngoto exit;\r\n}\r\nbrcmf_notify_escan_complete(cfg, ifp, true, true);\r\naf_params->channel = cpu_to_le32(afx_hdl->peer_chan);\r\n}\r\ntx_retry = 0;\r\nwhile (!p2p->block_gon_req_tx &&\r\n(ack == false) && (tx_retry < P2P_AF_TX_MAX_RETRY)) {\r\nack = !brcmf_p2p_tx_action_frame(p2p, af_params);\r\ntx_retry++;\r\n}\r\nif (ack == false) {\r\nbrcmf_err("Failed to send Action Frame(retry %d)\n", tx_retry);\r\nclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\n}\r\nexit:\r\nclear_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);\r\nif (ack && config_af_params.extra_listen && !p2p->block_gon_req_tx &&\r\ntest_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) &&\r\np2p->af_sent_channel == afx_hdl->my_listen_chan) {\r\ndelta_ms = jiffies_to_msecs(jiffies - p2p->af_tx_sent_jiffies);\r\nif (le32_to_cpu(af_params->dwell_time) > delta_ms)\r\nextra_listen_time = le32_to_cpu(af_params->dwell_time) -\r\ndelta_ms;\r\nelse\r\nextra_listen_time = 0;\r\nif (extra_listen_time > 50) {\r\nset_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\r\n&p2p->status);\r\nbrcmf_dbg(INFO, "Wait more time! actual af time:%d, calculated extra listen:%d\n",\r\nle32_to_cpu(af_params->dwell_time),\r\nextra_listen_time);\r\nextra_listen_time += 100;\r\nif (!brcmf_p2p_discover_listen(p2p,\r\np2p->af_sent_channel,\r\nextra_listen_time)) {\r\nunsigned long duration;\r\nextra_listen_time += 100;\r\nduration = msecs_to_jiffies(extra_listen_time);\r\nwait_for_completion_timeout(&p2p->wait_next_af,\r\nduration);\r\n}\r\nclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\r\n&p2p->status);\r\n}\r\n}\r\nif (p2p->block_gon_req_tx) {\r\np2p->block_gon_req_tx = false;\r\nack = true;\r\n}\r\nclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);\r\nif (config_af_params.mpc_onoff == 1)\r\nbrcmf_set_mpc(ifp, 1);\r\nreturn ack;\r\n}\r\ns32 brcmf_p2p_notify_rx_mgmt_p2p_probereq(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\r\nstruct brcmf_cfg80211_vif *vif = ifp->vif;\r\nstruct brcmf_rx_mgmt_data *rxframe = (struct brcmf_rx_mgmt_data *)data;\r\nu16 chanspec = be16_to_cpu(rxframe->chanspec);\r\nstruct brcmu_chan ch;\r\nu8 *mgmt_frame;\r\nu32 mgmt_frame_len;\r\ns32 freq;\r\nu16 mgmt_type;\r\nbrcmf_dbg(INFO, "Enter: event %d reason %d\n", e->event_code,\r\ne->reason);\r\nif (e->datalen < sizeof(*rxframe)) {\r\nbrcmf_dbg(SCAN, "Event data to small. Ignore\n");\r\nreturn 0;\r\n}\r\nch.chspec = be16_to_cpu(rxframe->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status) &&\r\n(ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {\r\nafx_hdl->peer_chan = ch.control_ch_num;\r\nbrcmf_dbg(INFO, "PROBE REQUEST: Peer found, channel=%d\n",\r\nafx_hdl->peer_chan);\r\ncomplete(&afx_hdl->act_frm_scan);\r\n}\r\nif (e->bsscfgidx == 0)\r\nreturn 0;\r\nif (test_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status)) {\r\nbrcmf_dbg(INFO, "Filtering P2P probe_req in GO-NEG phase\n");\r\nreturn 0;\r\n}\r\nbrcmf_dbg(INFO, "vif->mgmt_rx_reg %04x\n", vif->mgmt_rx_reg);\r\nmgmt_type = (IEEE80211_STYPE_PROBE_REQ & IEEE80211_FCTL_STYPE) >> 4;\r\nif ((vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)\r\nreturn 0;\r\nmgmt_frame = (u8 *)(rxframe + 1);\r\nmgmt_frame_len = e->datalen - sizeof(*rxframe);\r\nfreq = ieee80211_channel_to_frequency(ch.control_ch_num,\r\nch.band == BRCMU_CHAN_BAND_2G ?\r\nNL80211_BAND_2GHZ :\r\nNL80211_BAND_5GHZ);\r\ncfg80211_rx_mgmt(&vif->wdev, freq, 0, mgmt_frame, mgmt_frame_len, 0);\r\nbrcmf_dbg(INFO, "mgmt_frame_len (%d) , e->datalen (%d), chanspec (%04x), freq (%d)\n",\r\nmgmt_frame_len, e->datalen, chanspec, freq);\r\nreturn 0;\r\n}\r\nstatic void brcmf_p2p_get_current_chanspec(struct brcmf_p2p_info *p2p,\r\nu16 *chanspec)\r\n{\r\nstruct brcmf_if *ifp;\r\nu8 mac_addr[ETH_ALEN];\r\nstruct brcmu_chan ch;\r\nstruct brcmf_bss_info_le *bi;\r\nu8 *buf;\r\nifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\r\nif (brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSSID, mac_addr,\r\nETH_ALEN) == 0) {\r\nbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\r\nif (buf != NULL) {\r\n*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\r\nif (brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\r\nbuf, WL_BSS_INFO_MAX) == 0) {\r\nbi = (struct brcmf_bss_info_le *)(buf + 4);\r\n*chanspec = le16_to_cpu(bi->chanspec);\r\nkfree(buf);\r\nreturn;\r\n}\r\nkfree(buf);\r\n}\r\n}\r\nch.chnum = BRCMF_P2P_TEMP_CHAN;\r\nch.bw = BRCMU_CHAN_BW_20;\r\np2p->cfg->d11inf.encchspec(&ch);\r\n*chanspec = ch.chspec;\r\n}\r\nint brcmf_p2p_ifchange(struct brcmf_cfg80211_info *cfg,\r\nenum brcmf_fil_p2p_if_types if_type)\r\n{\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct brcmf_fil_p2p_if_le if_request;\r\ns32 err;\r\nu16 chanspec;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\r\nif (!vif) {\r\nbrcmf_err("vif for P2PAPI_BSSCFG_PRIMARY does not exist\n");\r\nreturn -EPERM;\r\n}\r\nbrcmf_notify_escan_complete(cfg, vif->ifp, true, true);\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;\r\nif (!vif) {\r\nbrcmf_err("vif for P2PAPI_BSSCFG_CONNECTION does not exist\n");\r\nreturn -EPERM;\r\n}\r\nbrcmf_set_mpc(vif->ifp, 0);\r\nbrcmf_p2p_get_current_chanspec(p2p, &chanspec);\r\nif_request.type = cpu_to_le16((u16)if_type);\r\nif_request.chspec = cpu_to_le16(chanspec);\r\nmemcpy(if_request.addr, p2p->int_addr, sizeof(if_request.addr));\r\nbrcmf_cfg80211_arm_vif_event(cfg, vif);\r\nerr = brcmf_fil_iovar_data_set(vif->ifp, "p2p_ifupd", &if_request,\r\nsizeof(if_request));\r\nif (err) {\r\nbrcmf_err("p2p_ifupd FAILED, err=%d\n", err);\r\nbrcmf_cfg80211_arm_vif_event(cfg, NULL);\r\nreturn err;\r\n}\r\nerr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_CHANGE,\r\nBRCMF_VIF_EVENT_TIMEOUT);\r\nbrcmf_cfg80211_arm_vif_event(cfg, NULL);\r\nif (!err) {\r\nbrcmf_err("No BRCMF_E_IF_CHANGE event received\n");\r\nreturn -EIO;\r\n}\r\nerr = brcmf_fil_cmd_int_set(vif->ifp, BRCMF_C_SET_SCB_TIMEOUT,\r\nBRCMF_SCB_TIMEOUT_VALUE);\r\nreturn err;\r\n}\r\nstatic int brcmf_p2p_request_p2p_if(struct brcmf_p2p_info *p2p,\r\nstruct brcmf_if *ifp, u8 ea[ETH_ALEN],\r\nenum brcmf_fil_p2p_if_types iftype)\r\n{\r\nstruct brcmf_fil_p2p_if_le if_request;\r\nint err;\r\nu16 chanspec;\r\nbrcmf_p2p_get_current_chanspec(p2p, &chanspec);\r\nmemcpy(if_request.addr, ea, ETH_ALEN);\r\nif_request.type = cpu_to_le16((u16)iftype);\r\nif_request.chspec = cpu_to_le16(chanspec);\r\nerr = brcmf_fil_iovar_data_set(ifp, "p2p_ifadd", &if_request,\r\nsizeof(if_request));\r\nreturn err;\r\n}\r\nstatic int brcmf_p2p_disable_p2p_if(struct brcmf_cfg80211_vif *vif)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);\r\nstruct net_device *pri_ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_if *ifp = netdev_priv(pri_ndev);\r\nu8 *addr = vif->wdev.netdev->dev_addr;\r\nreturn brcmf_fil_iovar_data_set(ifp, "p2p_ifdis", addr, ETH_ALEN);\r\n}\r\nstatic int brcmf_p2p_release_p2p_if(struct brcmf_cfg80211_vif *vif)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);\r\nstruct net_device *pri_ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_if *ifp = netdev_priv(pri_ndev);\r\nu8 *addr = vif->wdev.netdev->dev_addr;\r\nreturn brcmf_fil_iovar_data_set(ifp, "p2p_ifdel", addr, ETH_ALEN);\r\n}\r\nstatic struct wireless_dev *brcmf_p2p_create_p2pdev(struct brcmf_p2p_info *p2p,\r\nstruct wiphy *wiphy,\r\nu8 *addr)\r\n{\r\nstruct brcmf_cfg80211_vif *p2p_vif;\r\nstruct brcmf_if *p2p_ifp;\r\nstruct brcmf_if *pri_ifp;\r\nint err;\r\nu32 bsscfgidx;\r\nif (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\r\nreturn ERR_PTR(-ENOSPC);\r\np2p_vif = brcmf_alloc_vif(p2p->cfg, NL80211_IFTYPE_P2P_DEVICE);\r\nif (IS_ERR(p2p_vif)) {\r\nbrcmf_err("could not create discovery vif\n");\r\nreturn (struct wireless_dev *)p2p_vif;\r\n}\r\npri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\r\nbrcmf_p2p_generate_bss_mac(p2p, addr);\r\nbrcmf_p2p_set_firmware(pri_ifp, p2p->dev_addr);\r\nbrcmf_cfg80211_arm_vif_event(p2p->cfg, p2p_vif);\r\nbrcmf_fweh_p2pdev_setup(pri_ifp, true);\r\nerr = brcmf_fil_iovar_int_set(pri_ifp, "p2p_disc", 1);\r\nif (err < 0) {\r\nbrcmf_err("set p2p_disc error\n");\r\nbrcmf_fweh_p2pdev_setup(pri_ifp, false);\r\nbrcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);\r\ngoto fail;\r\n}\r\nerr = brcmf_cfg80211_wait_vif_event(p2p->cfg, BRCMF_E_IF_ADD,\r\nBRCMF_VIF_EVENT_TIMEOUT);\r\nbrcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);\r\nbrcmf_fweh_p2pdev_setup(pri_ifp, false);\r\nif (!err) {\r\nbrcmf_err("timeout occurred\n");\r\nerr = -EIO;\r\ngoto fail;\r\n}\r\np2p_ifp = p2p_vif->ifp;\r\np2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif = p2p_vif;\r\nmemcpy(p2p_ifp->mac_addr, p2p->dev_addr, ETH_ALEN);\r\nmemcpy(&p2p_vif->wdev.address, p2p->dev_addr, sizeof(p2p->dev_addr));\r\nerr = brcmf_fil_iovar_int_get(pri_ifp, "p2p_dev", &bsscfgidx);\r\nif (err < 0) {\r\nbrcmf_err("retrieving discover bsscfg index failed\n");\r\ngoto fail;\r\n}\r\nWARN_ON(p2p_ifp->bsscfgidx != bsscfgidx);\r\ninit_completion(&p2p->send_af_done);\r\nINIT_WORK(&p2p->afx_hdl.afx_work, brcmf_p2p_afx_handler);\r\ninit_completion(&p2p->afx_hdl.act_frm_scan);\r\ninit_completion(&p2p->wait_next_af);\r\nreturn &p2p_vif->wdev;\r\nfail:\r\nbrcmf_free_vif(p2p_vif);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct wireless_dev *brcmf_p2p_add_vif(struct wiphy *wiphy, const char *name,\r\nunsigned char name_assign_type,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\r\nstruct brcmf_cfg80211_vif *vif;\r\nenum brcmf_fil_p2p_if_types iftype;\r\nint err;\r\nif (brcmf_cfg80211_vif_event_armed(cfg))\r\nreturn ERR_PTR(-EBUSY);\r\nbrcmf_dbg(INFO, "adding vif \"%s\" (type=%d)\n", name, type);\r\nswitch (type) {\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\niftype = BRCMF_FIL_P2P_IF_CLIENT;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\niftype = BRCMF_FIL_P2P_IF_GO;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn brcmf_p2p_create_p2pdev(&cfg->p2p, wiphy,\r\nparams->macaddr);\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nvif = brcmf_alloc_vif(cfg, type);\r\nif (IS_ERR(vif))\r\nreturn (struct wireless_dev *)vif;\r\nbrcmf_cfg80211_arm_vif_event(cfg, vif);\r\nerr = brcmf_p2p_request_p2p_if(&cfg->p2p, ifp, cfg->p2p.int_addr,\r\niftype);\r\nif (err) {\r\nbrcmf_cfg80211_arm_vif_event(cfg, NULL);\r\ngoto fail;\r\n}\r\nerr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_ADD,\r\nBRCMF_VIF_EVENT_TIMEOUT);\r\nbrcmf_cfg80211_arm_vif_event(cfg, NULL);\r\nif (!err) {\r\nbrcmf_err("timeout occurred\n");\r\nerr = -EIO;\r\ngoto fail;\r\n}\r\nifp = vif->ifp;\r\nif (!ifp) {\r\nbrcmf_err("no if pointer provided\n");\r\nerr = -ENOENT;\r\ngoto fail;\r\n}\r\nstrncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);\r\nifp->ndev->name_assign_type = name_assign_type;\r\nerr = brcmf_net_attach(ifp, true);\r\nif (err) {\r\nbrcmf_err("Registering netdevice failed\n");\r\ngoto fail;\r\n}\r\ncfg->p2p.bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = vif;\r\nbrcmf_fil_iovar_int_set(ifp, "roam_off", 1);\r\nif (iftype == BRCMF_FIL_P2P_IF_GO) {\r\nbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCB_TIMEOUT,\r\nBRCMF_SCB_TIMEOUT_VALUE);\r\n}\r\nreturn &ifp->vif->wdev;\r\nfail:\r\nbrcmf_free_vif(vif);\r\nreturn ERR_PTR(err);\r\n}\r\nint brcmf_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_cfg80211_vif *vif;\r\nbool wait_for_disable = false;\r\nint err;\r\nbrcmf_dbg(TRACE, "delete P2P vif\n");\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nbrcmf_cfg80211_arm_vif_event(cfg, vif);\r\nswitch (vif->wdev.iftype) {\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nif (test_bit(BRCMF_VIF_STATUS_DISCONNECTING, &vif->sme_state))\r\nwait_for_disable = true;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\nif (!brcmf_p2p_disable_p2p_if(vif))\r\nwait_for_disable = true;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nif (!p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\r\nreturn 0;\r\nbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\r\nbrcmf_p2p_deinit_discovery(p2p);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\r\nbrcmf_dbg(INFO, "P2P: GO_NEG_PHASE status cleared\n");\r\nif (wait_for_disable)\r\nwait_for_completion_timeout(&cfg->vif_disabled,\r\nBRCMF_P2P_DISABLE_TIMEOUT);\r\nerr = 0;\r\nif (vif->wdev.iftype != NL80211_IFTYPE_P2P_DEVICE) {\r\nbrcmf_vif_clear_mgmt_ies(vif);\r\nerr = brcmf_p2p_release_p2p_if(vif);\r\n}\r\nif (!err) {\r\nerr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,\r\nBRCMF_VIF_EVENT_TIMEOUT);\r\nif (!err)\r\nerr = -EIO;\r\nelse\r\nerr = 0;\r\n}\r\nbrcmf_remove_interface(vif->ifp, true);\r\nbrcmf_cfg80211_arm_vif_event(cfg, NULL);\r\nif (vif->wdev.iftype != NL80211_IFTYPE_P2P_DEVICE)\r\np2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = NULL;\r\nreturn err;\r\n}\r\nvoid brcmf_p2p_ifp_removed(struct brcmf_if *ifp, bool rtnl_locked)\r\n{\r\nstruct brcmf_cfg80211_info *cfg;\r\nstruct brcmf_cfg80211_vif *vif;\r\nbrcmf_dbg(INFO, "P2P: device interface removed\n");\r\nvif = ifp->vif;\r\ncfg = wdev_to_cfg(&vif->wdev);\r\ncfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif = NULL;\r\nif (!rtnl_locked)\r\nrtnl_lock();\r\ncfg80211_unregister_wdev(&vif->wdev);\r\nif (!rtnl_locked)\r\nrtnl_unlock();\r\nbrcmf_free_vif(vif);\r\n}\r\nint brcmf_p2p_start_device(struct wiphy *wiphy, struct wireless_dev *wdev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_cfg80211_vif *vif;\r\nint err;\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nmutex_lock(&cfg->usr_sync);\r\nerr = brcmf_p2p_enable_discovery(p2p);\r\nif (!err)\r\nset_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state);\r\nmutex_unlock(&cfg->usr_sync);\r\nreturn err;\r\n}\r\nvoid brcmf_p2p_stop_device(struct wiphy *wiphy, struct wireless_dev *wdev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_p2p_info *p2p = &cfg->p2p;\r\nstruct brcmf_cfg80211_vif *vif;\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nif (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif == vif) {\r\nmutex_lock(&cfg->usr_sync);\r\n(void)brcmf_p2p_set_discover_state(vif->ifp,\r\nWL_P2P_DISC_ST_SCAN, 0, 0);\r\nbrcmf_abort_scanning(cfg);\r\nclear_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state);\r\nmutex_unlock(&cfg->usr_sync);\r\n}\r\n}\r\ns32 brcmf_p2p_attach(struct brcmf_cfg80211_info *cfg, bool p2pdev_forced)\r\n{\r\nstruct brcmf_p2p_info *p2p;\r\nstruct brcmf_if *pri_ifp;\r\ns32 err = 0;\r\nvoid *err_ptr;\r\np2p = &cfg->p2p;\r\np2p->cfg = cfg;\r\npri_ifp = brcmf_get_ifp(cfg->pub, 0);\r\np2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif = pri_ifp->vif;\r\nif (p2pdev_forced) {\r\nerr_ptr = brcmf_p2p_create_p2pdev(p2p, NULL, NULL);\r\nif (IS_ERR(err_ptr)) {\r\nbrcmf_err("P2P device creation failed.\n");\r\nerr = PTR_ERR(err_ptr);\r\n}\r\n} else {\r\np2p->p2pdev_dynamically = true;\r\n}\r\nreturn err;\r\n}\r\nvoid brcmf_p2p_detach(struct brcmf_p2p_info *p2p)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nif (vif != NULL) {\r\nbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\r\nbrcmf_p2p_deinit_discovery(p2p);\r\nbrcmf_remove_interface(vif->ifp, false);\r\n}\r\nmemset(p2p, 0, sizeof(*p2p));\r\n}
