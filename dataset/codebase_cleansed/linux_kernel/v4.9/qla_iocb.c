static inline uint16_t\r\nqla2x00_get_cmd_direction(srb_t *sp)\r\n{\r\nuint16_t cflags;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\ncflags = 0;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\ncflags = CF_WRITE;\r\nvha->qla_stats.output_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.output_requests++;\r\n} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\ncflags = CF_READ;\r\nvha->qla_stats.input_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.input_requests++;\r\n}\r\nreturn (cflags);\r\n}\r\nuint16_t\r\nqla2x00_calc_iocbs_32(uint16_t dsds)\r\n{\r\nuint16_t iocbs;\r\niocbs = 1;\r\nif (dsds > 3) {\r\niocbs += (dsds - 3) / 7;\r\nif ((dsds - 3) % 7)\r\niocbs++;\r\n}\r\nreturn (iocbs);\r\n}\r\nuint16_t\r\nqla2x00_calc_iocbs_64(uint16_t dsds)\r\n{\r\nuint16_t iocbs;\r\niocbs = 1;\r\nif (dsds > 2) {\r\niocbs += (dsds - 2) / 5;\r\nif ((dsds - 2) % 5)\r\niocbs++;\r\n}\r\nreturn (iocbs);\r\n}\r\nstatic inline cont_entry_t *\r\nqla2x00_prep_cont_type0_iocb(struct scsi_qla_host *vha)\r\n{\r\ncont_entry_t *cont_pkt;\r\nstruct req_que *req = vha->req;\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else {\r\nreq->ring_ptr++;\r\n}\r\ncont_pkt = (cont_entry_t *)req->ring_ptr;\r\n*((uint32_t *)(&cont_pkt->entry_type)) = cpu_to_le32(CONTINUE_TYPE);\r\nreturn (cont_pkt);\r\n}\r\nstatic inline cont_a64_entry_t *\r\nqla2x00_prep_cont_type1_iocb(scsi_qla_host_t *vha, struct req_que *req)\r\n{\r\ncont_a64_entry_t *cont_pkt;\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else {\r\nreq->ring_ptr++;\r\n}\r\ncont_pkt = (cont_a64_entry_t *)req->ring_ptr;\r\n*((uint32_t *)(&cont_pkt->entry_type)) = IS_QLAFX00(vha->hw) ?\r\ncpu_to_le32(CONTINUE_A64_TYPE_FX00) :\r\ncpu_to_le32(CONTINUE_A64_TYPE);\r\nreturn (cont_pkt);\r\n}\r\nstatic inline int\r\nqla24xx_configure_prot_mode(srb_t *sp, uint16_t *fw_prot_opts)\r\n{\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nuint8_t guard = scsi_host_get_guard(cmd->device->host);\r\n*fw_prot_opts = 0;\r\nswitch (scsi_get_prot_op(cmd)) {\r\ncase SCSI_PROT_READ_STRIP:\r\n*fw_prot_opts |= PO_MODE_DIF_REMOVE;\r\nbreak;\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*fw_prot_opts |= PO_MODE_DIF_INSERT;\r\nbreak;\r\ncase SCSI_PROT_READ_INSERT:\r\n*fw_prot_opts |= PO_MODE_DIF_INSERT;\r\nbreak;\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*fw_prot_opts |= PO_MODE_DIF_REMOVE;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\nif (guard & SHOST_DIX_GUARD_IP)\r\n*fw_prot_opts |= PO_MODE_DIF_TCP_CKSUM;\r\nelse\r\n*fw_prot_opts |= PO_MODE_DIF_PASS;\r\nbreak;\r\ndefault:\r\n*fw_prot_opts |= PO_MODE_DIF_PASS;\r\nbreak;\r\n}\r\nreturn scsi_prot_sg_count(cmd);\r\n}\r\nvoid qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,\r\nuint16_t tot_dsds)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *sg;\r\nint i;\r\ncmd = GET_CMD_SP(sp);\r\n*((uint32_t *)(&cmd_pkt->entry_type)) =\r\ncpu_to_le32(COMMAND_TYPE);\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn;\r\n}\r\nvha = sp->fcport->vha;\r\ncmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(sp));\r\navail_dsds = 3;\r\ncur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;\r\nscsi_for_each_sg(cmd, sg, tot_dsds, i) {\r\ncont_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type0_iocb(vha);\r\ncur_dsd = (uint32_t *)&cont_pkt->dseg_0_address;\r\navail_dsds = 7;\r\n}\r\n*cur_dsd++ = cpu_to_le32(sg_dma_address(sg));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\n}\r\nvoid qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,\r\nuint16_t tot_dsds)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *sg;\r\nint i;\r\ncmd = GET_CMD_SP(sp);\r\n*((uint32_t *)(&cmd_pkt->entry_type)) = cpu_to_le32(COMMAND_A64_TYPE);\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn;\r\n}\r\nvha = sp->fcport->vha;\r\ncmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(sp));\r\navail_dsds = 2;\r\ncur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;\r\nscsi_for_each_sg(cmd, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\r\ncur_dsd = (uint32_t *)cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\n}\r\nint\r\nqla2x00_start_scsi(srb_t *sp)\r\n{\r\nint nseg;\r\nunsigned long flags;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nuint32_t *clr_ptr;\r\nuint32_t index;\r\nuint32_t handle;\r\ncmd_entry_t *cmd_pkt;\r\nuint16_t cnt;\r\nuint16_t req_cnt;\r\nuint16_t tot_dsds;\r\nstruct device_reg_2xxx __iomem *reg;\r\nstruct qla_hw_data *ha;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nvha = sp->fcport->vha;\r\nha = vha->hw;\r\nreg = &ha->iobase->isp;\r\ncmd = GET_CMD_SP(sp);\r\nreq = ha->req_q_map[0];\r\nrsp = ha->rsp_q_map[0];\r\ntot_dsds = 0;\r\nif (vha->marker_needed != 0) {\r\nif (qla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL) !=\r\nQLA_SUCCESS) {\r\nreturn (QLA_FUNCTION_FAILED);\r\n}\r\nvha->marker_needed = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds)\r\ngoto queuing_error;\r\nif (scsi_sg_count(cmd)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\n} else\r\nnseg = 0;\r\ntot_dsds = nseg;\r\nreq_cnt = ha->isp_ops->calc_req_entries(tot_dsds);\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = RD_REG_WORD_RELAXED(ISP_REQ_Q_OUT(ha, reg));\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\n}\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\ncmd->host_scribble = (unsigned char *)(unsigned long)handle;\r\nreq->cnt -= req_cnt;\r\ncmd_pkt = (cmd_entry_t *)req->ring_ptr;\r\ncmd_pkt->handle = handle;\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\r\nSET_TARGET_ID(ha, cmd_pkt->target, sp->fcport->loop_id);\r\ncmd_pkt->lun = cpu_to_le16(cmd->device->lun);\r\ncmd_pkt->control_flags = cpu_to_le16(CF_SIMPLE_TAG);\r\nmemcpy(cmd_pkt->scsi_cdb, cmd->cmnd, cmd->cmd_len);\r\ncmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\r\nha->isp_ops->build_iocbs(sp, cmd_pkt, tot_dsds);\r\ncmd_pkt->entry_count = (uint8_t)req_cnt;\r\nwmb();\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nsp->flags |= SRB_DMA_VALID;\r\nWRT_REG_WORD(ISP_REQ_Q_IN(ha, reg), req->ring_index);\r\nRD_REG_WORD_RELAXED(ISP_REQ_Q_IN(ha, reg));\r\nif (vha->flags.process_response_queue &&\r\nrsp->ring_ptr->signature != RESPONSE_PROCESSED)\r\nqla2x00_process_response_queue(rsp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn (QLA_SUCCESS);\r\nqueuing_error:\r\nif (tot_dsds)\r\nscsi_dma_unmap(cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn (QLA_FUNCTION_FAILED);\r\n}\r\nvoid\r\nqla2x00_start_iocbs(struct scsi_qla_host *vha, struct req_que *req)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\ndevice_reg_t *reg = ISP_QUE_REG(ha, req->id);\r\nif (IS_P3P_TYPE(ha)) {\r\nqla82xx_start_iocbs(vha);\r\n} else {\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nWRT_REG_DWORD(req->req_q_in, req->ring_index);\r\nRD_REG_DWORD_RELAXED(&ha->iobase->isp24.hccr);\r\n} else if (IS_QLAFX00(ha)) {\r\nWRT_REG_DWORD(&reg->ispfx00.req_q_in, req->ring_index);\r\nRD_REG_DWORD_RELAXED(&reg->ispfx00.req_q_in);\r\nQLAFX00_SET_HST_INTR(ha, ha->rqstq_intr_code);\r\n} else if (IS_FWI2_CAPABLE(ha)) {\r\nWRT_REG_DWORD(&reg->isp24.req_q_in, req->ring_index);\r\nRD_REG_DWORD_RELAXED(&reg->isp24.req_q_in);\r\n} else {\r\nWRT_REG_WORD(ISP_REQ_Q_IN(ha, &reg->isp),\r\nreq->ring_index);\r\nRD_REG_WORD_RELAXED(ISP_REQ_Q_IN(ha, &reg->isp));\r\n}\r\n}\r\n}\r\nstatic int\r\n__qla2x00_marker(struct scsi_qla_host *vha, struct req_que *req,\r\nstruct rsp_que *rsp, uint16_t loop_id,\r\nuint64_t lun, uint8_t type)\r\n{\r\nmrk_entry_t *mrk;\r\nstruct mrk_entry_24xx *mrk24 = NULL;\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nreq = ha->req_q_map[0];\r\nmrk = (mrk_entry_t *)qla2x00_alloc_iocbs(vha, NULL);\r\nif (mrk == NULL) {\r\nql_log(ql_log_warn, base_vha, 0x3026,\r\n"Failed to allocate Marker IOCB.\n");\r\nreturn (QLA_FUNCTION_FAILED);\r\n}\r\nmrk->entry_type = MARKER_TYPE;\r\nmrk->modifier = type;\r\nif (type != MK_SYNC_ALL) {\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmrk24 = (struct mrk_entry_24xx *) mrk;\r\nmrk24->nport_handle = cpu_to_le16(loop_id);\r\nint_to_scsilun(lun, (struct scsi_lun *)&mrk24->lun);\r\nhost_to_fcp_swap(mrk24->lun, sizeof(mrk24->lun));\r\nmrk24->vp_index = vha->vp_idx;\r\nmrk24->handle = MAKE_HANDLE(req->id, mrk24->handle);\r\n} else {\r\nSET_TARGET_ID(ha, mrk->target, loop_id);\r\nmrk->lun = cpu_to_le16((uint16_t)lun);\r\n}\r\n}\r\nwmb();\r\nqla2x00_start_iocbs(vha, req);\r\nreturn (QLA_SUCCESS);\r\n}\r\nint\r\nqla2x00_marker(struct scsi_qla_host *vha, struct req_que *req,\r\nstruct rsp_que *rsp, uint16_t loop_id, uint64_t lun,\r\nuint8_t type)\r\n{\r\nint ret;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&vha->hw->hardware_lock, flags);\r\nret = __qla2x00_marker(vha, req, rsp, loop_id, lun, type);\r\nspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\r\nreturn (ret);\r\n}\r\nint qla2x00_issue_marker(scsi_qla_host_t *vha, int ha_locked)\r\n{\r\nif (ha_locked) {\r\nif (__qla2x00_marker(vha, vha->req, vha->req->rsp, 0, 0,\r\nMK_SYNC_ALL) != QLA_SUCCESS)\r\nreturn QLA_FUNCTION_FAILED;\r\n} else {\r\nif (qla2x00_marker(vha, vha->req, vha->req->rsp, 0, 0,\r\nMK_SYNC_ALL) != QLA_SUCCESS)\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nvha->marker_needed = 0;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic inline int\r\nqla24xx_build_scsi_type_6_iocbs(srb_t *sp, struct cmd_type_6 *cmd_pkt,\r\nuint16_t tot_dsds)\r\n{\r\nuint32_t *cur_dsd = NULL;\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *cur_seg;\r\nuint32_t *dsd_seg;\r\nvoid *next_dsd;\r\nuint8_t avail_dsds;\r\nuint8_t first_iocb = 1;\r\nuint32_t dsd_list_len;\r\nstruct dsd_dma *dsd_ptr;\r\nstruct ct6_dsd *ctx;\r\ncmd = GET_CMD_SP(sp);\r\n*((uint32_t *)(&cmd_pkt->entry_type)) = cpu_to_le32(COMMAND_TYPE_6);\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn 0;\r\n}\r\nvha = sp->fcport->vha;\r\nha = vha->hw;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\ncmd_pkt->control_flags = cpu_to_le16(CF_WRITE_DATA);\r\nvha->qla_stats.output_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.output_requests++;\r\n} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\ncmd_pkt->control_flags = cpu_to_le16(CF_READ_DATA);\r\nvha->qla_stats.input_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.input_requests++;\r\n}\r\ncur_seg = scsi_sglist(cmd);\r\nctx = GET_CMD_CTX_SP(sp);\r\nwhile (tot_dsds) {\r\navail_dsds = (tot_dsds > QLA_DSDS_PER_IOCB) ?\r\nQLA_DSDS_PER_IOCB : tot_dsds;\r\ntot_dsds -= avail_dsds;\r\ndsd_list_len = (avail_dsds + 1) * QLA_DSD_SIZE;\r\ndsd_ptr = list_first_entry(&ha->gbl_dsd_list,\r\nstruct dsd_dma, list);\r\nnext_dsd = dsd_ptr->dsd_addr;\r\nlist_del(&dsd_ptr->list);\r\nha->gbl_dsd_avail--;\r\nlist_add_tail(&dsd_ptr->list, &ctx->dsd_list);\r\nctx->dsd_use_cnt++;\r\nha->gbl_dsd_inuse++;\r\nif (first_iocb) {\r\nfirst_iocb = 0;\r\ndsd_seg = (uint32_t *)&cmd_pkt->fcp_data_dseg_address;\r\n*dsd_seg++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));\r\n*dsd_seg++ = cpu_to_le32(MSD(dsd_ptr->dsd_list_dma));\r\ncmd_pkt->fcp_data_dseg_len = cpu_to_le32(dsd_list_len);\r\n} else {\r\n*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = cpu_to_le32(dsd_list_len);\r\n}\r\ncur_dsd = (uint32_t *)next_dsd;\r\nwhile (avail_dsds) {\r\ndma_addr_t sle_dma;\r\nsle_dma = sg_dma_address(cur_seg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));\r\ncur_seg = sg_next(cur_seg);\r\navail_dsds--;\r\n}\r\n}\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\ncmd_pkt->control_flags |= CF_DATA_SEG_DESCR_ENABLE;\r\nreturn 0;\r\n}\r\nstatic inline uint16_t\r\nqla24xx_calc_dsd_lists(uint16_t dsds)\r\n{\r\nuint16_t dsd_lists = 0;\r\ndsd_lists = (dsds/QLA_DSDS_PER_IOCB);\r\nif (dsds % QLA_DSDS_PER_IOCB)\r\ndsd_lists++;\r\nreturn dsd_lists;\r\n}\r\nstatic inline void\r\nqla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,\r\nuint16_t tot_dsds)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *sg;\r\nint i;\r\ncmd = GET_CMD_SP(sp);\r\n*((uint32_t *)(&cmd_pkt->entry_type)) = cpu_to_le32(COMMAND_TYPE_7);\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn;\r\n}\r\nvha = sp->fcport->vha;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\ncmd_pkt->task_mgmt_flags = cpu_to_le16(TMF_WRITE_DATA);\r\nvha->qla_stats.output_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.output_requests++;\r\n} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\ncmd_pkt->task_mgmt_flags = cpu_to_le16(TMF_READ_DATA);\r\nvha->qla_stats.input_bytes += scsi_bufflen(cmd);\r\nvha->qla_stats.input_requests++;\r\n}\r\navail_dsds = 1;\r\ncur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;\r\nscsi_for_each_sg(cmd, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\r\ncur_dsd = (uint32_t *)cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\n}\r\nstatic inline void\r\nqla24xx_set_t10dif_tags(srb_t *sp, struct fw_dif_context *pkt,\r\nunsigned int protcnt)\r\n{\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nswitch (scsi_get_prot_type(cmd)) {\r\ncase SCSI_PROT_DIF_TYPE0:\r\npkt->ref_tag = cpu_to_le32((uint32_t)\r\n(0xffffffff & scsi_get_lba(cmd)));\r\nif (!qla2x00_hba_err_chk_enabled(sp))\r\nbreak;\r\npkt->ref_tag_mask[0] = 0xff;\r\npkt->ref_tag_mask[1] = 0xff;\r\npkt->ref_tag_mask[2] = 0xff;\r\npkt->ref_tag_mask[3] = 0xff;\r\nbreak;\r\ncase SCSI_PROT_DIF_TYPE2:\r\npkt->app_tag = cpu_to_le16(0);\r\npkt->app_tag_mask[0] = 0x0;\r\npkt->app_tag_mask[1] = 0x0;\r\npkt->ref_tag = cpu_to_le32((uint32_t)\r\n(0xffffffff & scsi_get_lba(cmd)));\r\nif (!qla2x00_hba_err_chk_enabled(sp))\r\nbreak;\r\npkt->ref_tag_mask[0] = 0xff;\r\npkt->ref_tag_mask[1] = 0xff;\r\npkt->ref_tag_mask[2] = 0xff;\r\npkt->ref_tag_mask[3] = 0xff;\r\nbreak;\r\ncase SCSI_PROT_DIF_TYPE3:\r\npkt->ref_tag_mask[0] = pkt->ref_tag_mask[1] =\r\npkt->ref_tag_mask[2] = pkt->ref_tag_mask[3] =\r\n0x00;\r\nbreak;\r\ncase SCSI_PROT_DIF_TYPE1:\r\npkt->ref_tag = cpu_to_le32((uint32_t)\r\n(0xffffffff & scsi_get_lba(cmd)));\r\npkt->app_tag = cpu_to_le16(0);\r\npkt->app_tag_mask[0] = 0x0;\r\npkt->app_tag_mask[1] = 0x0;\r\nif (!qla2x00_hba_err_chk_enabled(sp))\r\nbreak;\r\npkt->ref_tag_mask[0] = 0xff;\r\npkt->ref_tag_mask[1] = 0xff;\r\npkt->ref_tag_mask[2] = 0xff;\r\npkt->ref_tag_mask[3] = 0xff;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqla24xx_get_one_block_sg(uint32_t blk_sz, struct qla2_sgx *sgx,\r\nuint32_t *partial)\r\n{\r\nstruct scatterlist *sg;\r\nuint32_t cumulative_partial, sg_len;\r\ndma_addr_t sg_dma_addr;\r\nif (sgx->num_bytes == sgx->tot_bytes)\r\nreturn 0;\r\nsg = sgx->cur_sg;\r\ncumulative_partial = sgx->tot_partial;\r\nsg_dma_addr = sg_dma_address(sg);\r\nsg_len = sg_dma_len(sg);\r\nsgx->dma_addr = sg_dma_addr + sgx->bytes_consumed;\r\nif ((cumulative_partial + (sg_len - sgx->bytes_consumed)) >= blk_sz) {\r\nsgx->dma_len = (blk_sz - cumulative_partial);\r\nsgx->tot_partial = 0;\r\nsgx->num_bytes += blk_sz;\r\n*partial = 0;\r\n} else {\r\nsgx->dma_len = sg_len - sgx->bytes_consumed;\r\nsgx->tot_partial += sgx->dma_len;\r\n*partial = 1;\r\n}\r\nsgx->bytes_consumed += sgx->dma_len;\r\nif (sg_len == sgx->bytes_consumed) {\r\nsg = sg_next(sg);\r\nsgx->num_sg++;\r\nsgx->cur_sg = sg;\r\nsgx->bytes_consumed = 0;\r\n}\r\nreturn 1;\r\n}\r\nint\r\nqla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha, srb_t *sp,\r\nuint32_t *dsd, uint16_t tot_dsds, struct qla_tgt_cmd *tc)\r\n{\r\nvoid *next_dsd;\r\nuint8_t avail_dsds = 0;\r\nuint32_t dsd_list_len;\r\nstruct dsd_dma *dsd_ptr;\r\nstruct scatterlist *sg_prot;\r\nuint32_t *cur_dsd = dsd;\r\nuint16_t used_dsds = tot_dsds;\r\nuint32_t prot_int;\r\nuint32_t partial;\r\nstruct qla2_sgx sgx;\r\ndma_addr_t sle_dma;\r\nuint32_t sle_dma_len, tot_prot_dma_len = 0;\r\nstruct scsi_cmnd *cmd;\r\nmemset(&sgx, 0, sizeof(struct qla2_sgx));\r\nif (sp) {\r\ncmd = GET_CMD_SP(sp);\r\nprot_int = cmd->device->sector_size;\r\nsgx.tot_bytes = scsi_bufflen(cmd);\r\nsgx.cur_sg = scsi_sglist(cmd);\r\nsgx.sp = sp;\r\nsg_prot = scsi_prot_sglist(cmd);\r\n} else if (tc) {\r\nprot_int = tc->blk_sz;\r\nsgx.tot_bytes = tc->bufflen;\r\nsgx.cur_sg = tc->sg;\r\nsg_prot = tc->prot_sg;\r\n} else {\r\nBUG();\r\nreturn 1;\r\n}\r\nwhile (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {\r\nsle_dma = sgx.dma_addr;\r\nsle_dma_len = sgx.dma_len;\r\nalloc_and_fill:\r\nif (avail_dsds == 0) {\r\navail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\r\nQLA_DSDS_PER_IOCB : used_dsds;\r\ndsd_list_len = (avail_dsds + 1) * 12;\r\nused_dsds -= avail_dsds;\r\ndsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\r\nif (!dsd_ptr)\r\nreturn 1;\r\ndsd_ptr->dsd_addr = next_dsd =\r\ndma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\r\n&dsd_ptr->dsd_list_dma);\r\nif (!next_dsd) {\r\nkfree(dsd_ptr);\r\nreturn 1;\r\n}\r\nif (sp) {\r\nlist_add_tail(&dsd_ptr->list,\r\n&((struct crc_context *)\r\nsp->u.scmd.ctx)->dsd_list);\r\nsp->flags |= SRB_CRC_CTX_DSD_VALID;\r\n} else {\r\nlist_add_tail(&dsd_ptr->list,\r\n&(tc->ctx->dsd_list));\r\ntc->ctx_dsd_alloced = 1;\r\n}\r\n*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = dsd_list_len;\r\ncur_dsd = (uint32_t *)next_dsd;\r\n}\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sle_dma_len);\r\navail_dsds--;\r\nif (partial == 0) {\r\nsle_dma = sg_dma_address(sg_prot) + tot_prot_dma_len;\r\nsle_dma_len = 8;\r\ntot_prot_dma_len += sle_dma_len;\r\nif (tot_prot_dma_len == sg_dma_len(sg_prot)) {\r\ntot_prot_dma_len = 0;\r\nsg_prot = sg_next(sg_prot);\r\n}\r\npartial = 1;\r\ngoto alloc_and_fill;\r\n}\r\n}\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\nreturn 0;\r\n}\r\nint\r\nqla24xx_walk_and_build_sglist(struct qla_hw_data *ha, srb_t *sp, uint32_t *dsd,\r\nuint16_t tot_dsds, struct qla_tgt_cmd *tc)\r\n{\r\nvoid *next_dsd;\r\nuint8_t avail_dsds = 0;\r\nuint32_t dsd_list_len;\r\nstruct dsd_dma *dsd_ptr;\r\nstruct scatterlist *sg, *sgl;\r\nuint32_t *cur_dsd = dsd;\r\nint i;\r\nuint16_t used_dsds = tot_dsds;\r\nstruct scsi_cmnd *cmd;\r\nif (sp) {\r\ncmd = GET_CMD_SP(sp);\r\nsgl = scsi_sglist(cmd);\r\n} else if (tc) {\r\nsgl = tc->sg;\r\n} else {\r\nBUG();\r\nreturn 1;\r\n}\r\nfor_each_sg(sgl, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\navail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\r\nQLA_DSDS_PER_IOCB : used_dsds;\r\ndsd_list_len = (avail_dsds + 1) * 12;\r\nused_dsds -= avail_dsds;\r\ndsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\r\nif (!dsd_ptr)\r\nreturn 1;\r\ndsd_ptr->dsd_addr = next_dsd =\r\ndma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\r\n&dsd_ptr->dsd_list_dma);\r\nif (!next_dsd) {\r\nkfree(dsd_ptr);\r\nreturn 1;\r\n}\r\nif (sp) {\r\nlist_add_tail(&dsd_ptr->list,\r\n&((struct crc_context *)\r\nsp->u.scmd.ctx)->dsd_list);\r\nsp->flags |= SRB_CRC_CTX_DSD_VALID;\r\n} else {\r\nlist_add_tail(&dsd_ptr->list,\r\n&(tc->ctx->dsd_list));\r\ntc->ctx_dsd_alloced = 1;\r\n}\r\n*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = dsd_list_len;\r\ncur_dsd = (uint32_t *)next_dsd;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\nreturn 0;\r\n}\r\nint\r\nqla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha, srb_t *sp,\r\nuint32_t *dsd, uint16_t tot_dsds, struct qla_tgt_cmd *tc)\r\n{\r\nvoid *next_dsd;\r\nuint8_t avail_dsds = 0;\r\nuint32_t dsd_list_len;\r\nstruct dsd_dma *dsd_ptr;\r\nstruct scatterlist *sg, *sgl;\r\nint i;\r\nstruct scsi_cmnd *cmd;\r\nuint32_t *cur_dsd = dsd;\r\nuint16_t used_dsds = tot_dsds;\r\nstruct scsi_qla_host *vha;\r\nif (sp) {\r\ncmd = GET_CMD_SP(sp);\r\nsgl = scsi_prot_sglist(cmd);\r\nvha = sp->fcport->vha;\r\n} else if (tc) {\r\nvha = tc->vha;\r\nsgl = tc->prot_sg;\r\n} else {\r\nBUG();\r\nreturn 1;\r\n}\r\nql_dbg(ql_dbg_tgt, vha, 0xe021,\r\n"%s: enter\n", __func__);\r\nfor_each_sg(sgl, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\navail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\r\nQLA_DSDS_PER_IOCB : used_dsds;\r\ndsd_list_len = (avail_dsds + 1) * 12;\r\nused_dsds -= avail_dsds;\r\ndsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\r\nif (!dsd_ptr)\r\nreturn 1;\r\ndsd_ptr->dsd_addr = next_dsd =\r\ndma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\r\n&dsd_ptr->dsd_list_dma);\r\nif (!next_dsd) {\r\nkfree(dsd_ptr);\r\nreturn 1;\r\n}\r\nif (sp) {\r\nlist_add_tail(&dsd_ptr->list,\r\n&((struct crc_context *)\r\nsp->u.scmd.ctx)->dsd_list);\r\nsp->flags |= SRB_CRC_CTX_DSD_VALID;\r\n} else {\r\nlist_add_tail(&dsd_ptr->list,\r\n&(tc->ctx->dsd_list));\r\ntc->ctx_dsd_alloced = 1;\r\n}\r\n*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(dsd_ptr->dsd_list_dma));\r\n*cur_dsd++ = dsd_list_len;\r\ncur_dsd = (uint32_t *)next_dsd;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\n*cur_dsd++ = 0;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nqla24xx_build_scsi_crc_2_iocbs(srb_t *sp, struct cmd_type_crc_2 *cmd_pkt,\r\nuint16_t tot_dsds, uint16_t tot_prot_dsds, uint16_t fw_prot_opts)\r\n{\r\nuint32_t *cur_dsd, *fcp_dl;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nuint32_t total_bytes = 0;\r\nuint32_t data_bytes;\r\nuint32_t dif_bytes;\r\nuint8_t bundling = 1;\r\nuint16_t blk_size;\r\nuint8_t *clr_ptr;\r\nstruct crc_context *crc_ctx_pkt = NULL;\r\nstruct qla_hw_data *ha;\r\nuint8_t additional_fcpcdb_len;\r\nuint16_t fcp_cmnd_len;\r\nstruct fcp_cmnd *fcp_cmnd;\r\ndma_addr_t crc_ctx_dma;\r\ncmd = GET_CMD_SP(sp);\r\n*((uint32_t *)(&cmd_pkt->entry_type)) = cpu_to_le32(COMMAND_TYPE_CRC_2);\r\nvha = sp->fcport->vha;\r\nha = vha->hw;\r\ndata_bytes = scsi_bufflen(cmd);\r\nif (!data_bytes || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn QLA_SUCCESS;\r\n}\r\ncmd_pkt->vp_index = sp->fcport->vha->vp_idx;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\ncmd_pkt->control_flags =\r\ncpu_to_le16(CF_WRITE_DATA);\r\n} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\ncmd_pkt->control_flags =\r\ncpu_to_le16(CF_READ_DATA);\r\n}\r\nif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\r\n(scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP) ||\r\n(scsi_get_prot_op(cmd) == SCSI_PROT_READ_STRIP) ||\r\n(scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_INSERT))\r\nbundling = 0;\r\ncrc_ctx_pkt = sp->u.scmd.ctx =\r\ndma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);\r\nif (!crc_ctx_pkt)\r\ngoto crc_queuing_error;\r\nclr_ptr = (uint8_t *)crc_ctx_pkt;\r\nmemset(clr_ptr, 0, sizeof(*crc_ctx_pkt));\r\ncrc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;\r\nsp->flags |= SRB_CRC_CTX_DMA_VALID;\r\ncrc_ctx_pkt->handle = cmd_pkt->handle;\r\nINIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);\r\nqla24xx_set_t10dif_tags(sp, (struct fw_dif_context *)\r\n&crc_ctx_pkt->ref_tag, tot_prot_dsds);\r\ncmd_pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));\r\ncmd_pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));\r\ncmd_pkt->crc_context_len = CRC_CONTEXT_LEN_FW;\r\nif (cmd->cmd_len > 16) {\r\nadditional_fcpcdb_len = cmd->cmd_len - 16;\r\nif ((cmd->cmd_len % 4) != 0) {\r\ngoto crc_queuing_error;\r\n}\r\nfcp_cmnd_len = 12 + cmd->cmd_len + 4;\r\n} else {\r\nadditional_fcpcdb_len = 0;\r\nfcp_cmnd_len = 12 + 16 + 4;\r\n}\r\nfcp_cmnd = &crc_ctx_pkt->fcp_cmnd;\r\nfcp_cmnd->additional_cdb_len = additional_fcpcdb_len;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nfcp_cmnd->additional_cdb_len |= 1;\r\nelse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\nfcp_cmnd->additional_cdb_len |= 2;\r\nint_to_scsilun(cmd->device->lun, &fcp_cmnd->lun);\r\nmemcpy(fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\r\ncmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(fcp_cmnd_len);\r\ncmd_pkt->fcp_cmnd_dseg_address[0] = cpu_to_le32(\r\nLSD(crc_ctx_dma + CRC_CONTEXT_FCPCMND_OFF));\r\ncmd_pkt->fcp_cmnd_dseg_address[1] = cpu_to_le32(\r\nMSD(crc_ctx_dma + CRC_CONTEXT_FCPCMND_OFF));\r\nfcp_cmnd->task_management = 0;\r\nfcp_cmnd->task_attribute = TSK_SIMPLE;\r\ncmd_pkt->fcp_rsp_dseg_len = 0;\r\ndif_bytes = 0;\r\nblk_size = cmd->device->sector_size;\r\ndif_bytes = (data_bytes / blk_size) * 8;\r\nswitch (scsi_get_prot_op(GET_CMD_SP(sp))) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\ntotal_bytes = data_bytes;\r\ndata_bytes += dif_bytes;\r\nbreak;\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\ntotal_bytes = data_bytes + dif_bytes;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (!qla2x00_hba_err_chk_enabled(sp))\r\nfw_prot_opts |= 0x10;\r\nelse if (IS_PI_UNINIT_CAPABLE(ha)) {\r\nif ((scsi_get_prot_type(GET_CMD_SP(sp)) == SCSI_PROT_DIF_TYPE1)\r\n|| (scsi_get_prot_type(GET_CMD_SP(sp)) ==\r\nSCSI_PROT_DIF_TYPE2))\r\nfw_prot_opts |= BIT_10;\r\nelse if (scsi_get_prot_type(GET_CMD_SP(sp)) ==\r\nSCSI_PROT_DIF_TYPE3)\r\nfw_prot_opts |= BIT_11;\r\n}\r\nif (!bundling) {\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;\r\n} else {\r\nfw_prot_opts |= PO_ENABLE_DIF_BUNDLING;\r\ncrc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);\r\ncrc_ctx_pkt->u.bundling.dseg_count = cpu_to_le16(tot_dsds -\r\ntot_prot_dsds);\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;\r\n}\r\ncrc_ctx_pkt->blk_size = cpu_to_le16(blk_size);\r\ncrc_ctx_pkt->prot_opts = cpu_to_le16(fw_prot_opts);\r\ncrc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);\r\ncrc_ctx_pkt->guard_seed = cpu_to_le16(0);\r\ncmd_pkt->byte_count = cpu_to_le32(total_bytes);\r\nfcp_dl = (uint32_t *)(crc_ctx_pkt->fcp_cmnd.cdb + 16 +\r\nadditional_fcpcdb_len);\r\n*fcp_dl = htonl(total_bytes);\r\nif (!data_bytes || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_pkt->byte_count = cpu_to_le32(0);\r\nreturn QLA_SUCCESS;\r\n}\r\ncmd_pkt->control_flags |= cpu_to_le16(CF_DATA_SEG_DESCR_ENABLE);\r\nif (!bundling && tot_prot_dsds) {\r\nif (qla24xx_walk_and_build_sglist_no_difb(ha, sp,\r\ncur_dsd, tot_dsds, NULL))\r\ngoto crc_queuing_error;\r\n} else if (qla24xx_walk_and_build_sglist(ha, sp, cur_dsd,\r\n(tot_dsds - tot_prot_dsds), NULL))\r\ngoto crc_queuing_error;\r\nif (bundling && tot_prot_dsds) {\r\ncmd_pkt->control_flags |= cpu_to_le16(CF_DIF_SEG_DESCR_ENABLE);\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;\r\nif (qla24xx_walk_and_build_prot_sglist(ha, sp, cur_dsd,\r\ntot_prot_dsds, NULL))\r\ngoto crc_queuing_error;\r\n}\r\nreturn QLA_SUCCESS;\r\ncrc_queuing_error:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nint\r\nqla24xx_start_scsi(srb_t *sp)\r\n{\r\nint nseg;\r\nunsigned long flags;\r\nuint32_t *clr_ptr;\r\nuint32_t index;\r\nuint32_t handle;\r\nstruct cmd_type_7 *cmd_pkt;\r\nuint16_t cnt;\r\nuint16_t req_cnt;\r\nuint16_t tot_dsds;\r\nstruct req_que *req = NULL;\r\nstruct rsp_que *rsp = NULL;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla25xx_set_que(sp, &rsp);\r\nreq = vha->req;\r\ntot_dsds = 0;\r\nif (vha->marker_needed != 0) {\r\nif (qla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL) !=\r\nQLA_SUCCESS)\r\nreturn QLA_FUNCTION_FAILED;\r\nvha->marker_needed = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds)\r\ngoto queuing_error;\r\nif (scsi_sg_count(cmd)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\n} else\r\nnseg = 0;\r\ntot_dsds = nseg;\r\nreq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = IS_SHADOW_REG_CAPABLE(ha) ? *req->out_ptr :\r\nRD_REG_DWORD_RELAXED(req->req_q_out);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\n}\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\ncmd->host_scribble = (unsigned char *)(unsigned long)handle;\r\nreq->cnt -= req_cnt;\r\ncmd_pkt = (struct cmd_type_7 *)req->ring_ptr;\r\ncmd_pkt->handle = MAKE_HANDLE(req->id, handle);\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\r\ncmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\ncmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\r\ncmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\r\ncmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\r\ncmd_pkt->vp_index = sp->fcport->vha->vp_idx;\r\nint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\r\nhost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\r\ncmd_pkt->task = TSK_SIMPLE;\r\nmemcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);\r\nhost_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));\r\ncmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\r\nqla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds);\r\ncmd_pkt->entry_count = (uint8_t)req_cnt;\r\ncmd_pkt->entry_status = (uint8_t) rsp->id;\r\nwmb();\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nsp->flags |= SRB_DMA_VALID;\r\nWRT_REG_DWORD(req->req_q_in, req->ring_index);\r\nRD_REG_DWORD_RELAXED(&ha->iobase->isp24.hccr);\r\nif (vha->flags.process_response_queue &&\r\nrsp->ring_ptr->signature != RESPONSE_PROCESSED)\r\nqla24xx_process_response_queue(vha, rsp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\nqueuing_error:\r\nif (tot_dsds)\r\nscsi_dma_unmap(cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nint\r\nqla24xx_dif_start_scsi(srb_t *sp)\r\n{\r\nint nseg;\r\nunsigned long flags;\r\nuint32_t *clr_ptr;\r\nuint32_t index;\r\nuint32_t handle;\r\nuint16_t cnt;\r\nuint16_t req_cnt = 0;\r\nuint16_t tot_dsds;\r\nuint16_t tot_prot_dsds;\r\nuint16_t fw_prot_opts = 0;\r\nstruct req_que *req = NULL;\r\nstruct rsp_que *rsp = NULL;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct cmd_type_crc_2 *cmd_pkt;\r\nuint32_t status = 0;\r\n#define QDSS_GOT_Q_SPACE BIT_0\r\nif (scsi_get_prot_op(cmd) == SCSI_PROT_NORMAL) {\r\nif (cmd->cmd_len <= 16)\r\nreturn qla24xx_start_scsi(sp);\r\n}\r\nqla25xx_set_que(sp, &rsp);\r\nreq = vha->req;\r\ntot_dsds = 0;\r\nif (vha->marker_needed != 0) {\r\nif (qla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL) !=\r\nQLA_SUCCESS)\r\nreturn QLA_FUNCTION_FAILED;\r\nvha->marker_needed = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds)\r\ngoto queuing_error;\r\nif (scsi_sg_count(cmd)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\nelse\r\nsp->flags |= SRB_DMA_VALID;\r\nif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\r\n(scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\r\nstruct qla2_sgx sgx;\r\nuint32_t partial;\r\nmemset(&sgx, 0, sizeof(struct qla2_sgx));\r\nsgx.tot_bytes = scsi_bufflen(cmd);\r\nsgx.cur_sg = scsi_sglist(cmd);\r\nsgx.sp = sp;\r\nnseg = 0;\r\nwhile (qla24xx_get_one_block_sg(\r\ncmd->device->sector_size, &sgx, &partial))\r\nnseg++;\r\n}\r\n} else\r\nnseg = 0;\r\ntot_dsds = nseg;\r\nif (qla24xx_configure_prot_mode(sp, &fw_prot_opts)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),\r\nscsi_prot_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\nelse\r\nsp->flags |= SRB_CRC_PROT_DMA_VALID;\r\nif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\r\n(scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\r\nnseg = scsi_bufflen(cmd) / cmd->device->sector_size;\r\n}\r\n} else {\r\nnseg = 0;\r\n}\r\nreq_cnt = 1;\r\ntot_prot_dsds = nseg;\r\ntot_dsds += nseg;\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = IS_SHADOW_REG_CAPABLE(ha) ? *req->out_ptr :\r\nRD_REG_DWORD_RELAXED(req->req_q_out);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\n}\r\nstatus |= QDSS_GOT_Q_SPACE;\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\ncmd->host_scribble = (unsigned char *)(unsigned long)handle;\r\nreq->cnt -= req_cnt;\r\ncmd_pkt = (struct cmd_type_crc_2 *)req->ring_ptr;\r\ncmd_pkt->handle = MAKE_HANDLE(req->id, handle);\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\ncmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\r\ncmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\r\ncmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\r\nint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\r\nhost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\r\ncmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\r\nif (qla24xx_build_scsi_crc_2_iocbs(sp, (struct cmd_type_crc_2 *)\r\nreq->ring_ptr, tot_dsds, tot_prot_dsds, fw_prot_opts) !=\r\nQLA_SUCCESS)\r\ngoto queuing_error;\r\ncmd_pkt->entry_count = (uint8_t)req_cnt;\r\ncmd_pkt->entry_status = (uint8_t) rsp->id;\r\ncmd_pkt->timeout = cpu_to_le16(0);\r\nwmb();\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nWRT_REG_DWORD(req->req_q_in, req->ring_index);\r\nRD_REG_DWORD_RELAXED(&ha->iobase->isp24.hccr);\r\nif (vha->flags.process_response_queue &&\r\nrsp->ring_ptr->signature != RESPONSE_PROCESSED)\r\nqla24xx_process_response_queue(vha, rsp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\nqueuing_error:\r\nif (status & QDSS_GOT_Q_SPACE) {\r\nreq->outstanding_cmds[handle] = NULL;\r\nreq->cnt += req_cnt;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic void qla25xx_set_que(srb_t *sp, struct rsp_que **rsp)\r\n{\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nstruct qla_hw_data *ha = sp->fcport->vha->hw;\r\nint affinity = cmd->request->cpu;\r\nif (ha->flags.cpu_affinity_enabled && affinity >= 0 &&\r\naffinity < ha->max_rsp_queues - 1)\r\n*rsp = ha->rsp_q_map[affinity + 1];\r\nelse\r\n*rsp = ha->rsp_q_map[0];\r\n}\r\nvoid *\r\nqla2x00_alloc_iocbs_ready(scsi_qla_host_t *vha, srb_t *sp)\r\n{\r\nif (qla2x00_reset_active(vha))\r\nreturn NULL;\r\nreturn qla2x00_alloc_iocbs(vha, sp);\r\n}\r\nvoid *\r\nqla2x00_alloc_iocbs(scsi_qla_host_t *vha, srb_t *sp)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\ndevice_reg_t *reg = ISP_QUE_REG(ha, req->id);\r\nuint32_t index, handle;\r\nrequest_t *pkt;\r\nuint16_t cnt, req_cnt;\r\npkt = NULL;\r\nreq_cnt = 1;\r\nhandle = 0;\r\nif (!sp)\r\ngoto skip_cmd_array;\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds) {\r\nql_log(ql_log_warn, vha, 0x700b,\r\n"No room on outstanding cmd array.\n");\r\ngoto queuing_error;\r\n}\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\nif (sp->type != SRB_SCSI_CMD)\r\nreq_cnt = sp->iocbs;\r\nskip_cmd_array:\r\nif (req->cnt < req_cnt + 2) {\r\nif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\ncnt = RD_REG_DWORD(&reg->isp25mq.req_q_out);\r\nelse if (IS_P3P_TYPE(ha))\r\ncnt = RD_REG_DWORD(&reg->isp82.req_q_out);\r\nelse if (IS_FWI2_CAPABLE(ha))\r\ncnt = RD_REG_DWORD(&reg->isp24.req_q_out);\r\nelse if (IS_QLAFX00(ha))\r\ncnt = RD_REG_DWORD(&reg->ispfx00.req_q_out);\r\nelse\r\ncnt = qla2x00_debounce_register(\r\nISP_REQ_Q_OUT(ha, &reg->isp));\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\n}\r\nif (req->cnt < req_cnt + 2)\r\ngoto queuing_error;\r\nreq->cnt -= req_cnt;\r\npkt = req->ring_ptr;\r\nmemset(pkt, 0, REQUEST_ENTRY_SIZE);\r\nif (IS_QLAFX00(ha)) {\r\nWRT_REG_BYTE((void __iomem *)&pkt->entry_count, req_cnt);\r\nWRT_REG_WORD((void __iomem *)&pkt->handle, handle);\r\n} else {\r\npkt->entry_count = req_cnt;\r\npkt->handle = handle;\r\n}\r\nqueuing_error:\r\nvha->tgt_counters.num_alloc_iocb_failed++;\r\nreturn pkt;\r\n}\r\nstatic void\r\nqla24xx_login_iocb(srb_t *sp, struct logio_entry_24xx *logio)\r\n{\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\r\nlogio->control_flags = cpu_to_le16(LCF_COMMAND_PLOGI);\r\nif (lio->u.logio.flags & SRB_LOGIN_COND_PLOGI)\r\nlogio->control_flags |= cpu_to_le16(LCF_COND_PLOGI);\r\nif (lio->u.logio.flags & SRB_LOGIN_SKIP_PRLI)\r\nlogio->control_flags |= cpu_to_le16(LCF_SKIP_PRLI);\r\nlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\r\nlogio->port_id[1] = sp->fcport->d_id.b.area;\r\nlogio->port_id[2] = sp->fcport->d_id.b.domain;\r\nlogio->vp_index = sp->fcport->vha->vp_idx;\r\n}\r\nstatic void\r\nqla2x00_login_iocb(srb_t *sp, struct mbx_entry *mbx)\r\n{\r\nstruct qla_hw_data *ha = sp->fcport->vha->hw;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nuint16_t opts;\r\nmbx->entry_type = MBX_IOCB_TYPE;\r\nSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\r\nmbx->mb0 = cpu_to_le16(MBC_LOGIN_FABRIC_PORT);\r\nopts = lio->u.logio.flags & SRB_LOGIN_COND_PLOGI ? BIT_0 : 0;\r\nopts |= lio->u.logio.flags & SRB_LOGIN_SKIP_PRLI ? BIT_1 : 0;\r\nif (HAS_EXTENDED_IDS(ha)) {\r\nmbx->mb1 = cpu_to_le16(sp->fcport->loop_id);\r\nmbx->mb10 = cpu_to_le16(opts);\r\n} else {\r\nmbx->mb1 = cpu_to_le16((sp->fcport->loop_id << 8) | opts);\r\n}\r\nmbx->mb2 = cpu_to_le16(sp->fcport->d_id.b.domain);\r\nmbx->mb3 = cpu_to_le16(sp->fcport->d_id.b.area << 8 |\r\nsp->fcport->d_id.b.al_pa);\r\nmbx->mb9 = cpu_to_le16(sp->fcport->vha->vp_idx);\r\n}\r\nstatic void\r\nqla24xx_logout_iocb(srb_t *sp, struct logio_entry_24xx *logio)\r\n{\r\nlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\r\nlogio->control_flags =\r\ncpu_to_le16(LCF_COMMAND_LOGO|LCF_IMPL_LOGO);\r\nif (!sp->fcport->tgt_session ||\r\n!sp->fcport->tgt_session->keep_nport_handle)\r\nlogio->control_flags |= cpu_to_le16(LCF_FREE_NPORT);\r\nlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\r\nlogio->port_id[1] = sp->fcport->d_id.b.area;\r\nlogio->port_id[2] = sp->fcport->d_id.b.domain;\r\nlogio->vp_index = sp->fcport->vha->vp_idx;\r\n}\r\nstatic void\r\nqla2x00_logout_iocb(srb_t *sp, struct mbx_entry *mbx)\r\n{\r\nstruct qla_hw_data *ha = sp->fcport->vha->hw;\r\nmbx->entry_type = MBX_IOCB_TYPE;\r\nSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\r\nmbx->mb0 = cpu_to_le16(MBC_LOGOUT_FABRIC_PORT);\r\nmbx->mb1 = HAS_EXTENDED_IDS(ha) ?\r\ncpu_to_le16(sp->fcport->loop_id):\r\ncpu_to_le16(sp->fcport->loop_id << 8);\r\nmbx->mb2 = cpu_to_le16(sp->fcport->d_id.b.domain);\r\nmbx->mb3 = cpu_to_le16(sp->fcport->d_id.b.area << 8 |\r\nsp->fcport->d_id.b.al_pa);\r\nmbx->mb9 = cpu_to_le16(sp->fcport->vha->vp_idx);\r\n}\r\nstatic void\r\nqla24xx_adisc_iocb(srb_t *sp, struct logio_entry_24xx *logio)\r\n{\r\nlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\r\nlogio->control_flags = cpu_to_le16(LCF_COMMAND_ADISC);\r\nlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nlogio->vp_index = sp->fcport->vha->vp_idx;\r\n}\r\nstatic void\r\nqla2x00_adisc_iocb(srb_t *sp, struct mbx_entry *mbx)\r\n{\r\nstruct qla_hw_data *ha = sp->fcport->vha->hw;\r\nmbx->entry_type = MBX_IOCB_TYPE;\r\nSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\r\nmbx->mb0 = cpu_to_le16(MBC_GET_PORT_DATABASE);\r\nif (HAS_EXTENDED_IDS(ha)) {\r\nmbx->mb1 = cpu_to_le16(sp->fcport->loop_id);\r\nmbx->mb10 = cpu_to_le16(BIT_0);\r\n} else {\r\nmbx->mb1 = cpu_to_le16((sp->fcport->loop_id << 8) | BIT_0);\r\n}\r\nmbx->mb2 = cpu_to_le16(MSW(ha->async_pd_dma));\r\nmbx->mb3 = cpu_to_le16(LSW(ha->async_pd_dma));\r\nmbx->mb6 = cpu_to_le16(MSW(MSD(ha->async_pd_dma)));\r\nmbx->mb7 = cpu_to_le16(LSW(MSD(ha->async_pd_dma)));\r\nmbx->mb9 = cpu_to_le16(sp->fcport->vha->vp_idx);\r\n}\r\nstatic void\r\nqla24xx_tm_iocb(srb_t *sp, struct tsk_mgmt_entry *tsk)\r\n{\r\nuint32_t flags;\r\nuint64_t lun;\r\nstruct fc_port *fcport = sp->fcport;\r\nscsi_qla_host_t *vha = fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct srb_iocb *iocb = &sp->u.iocb_cmd;\r\nstruct req_que *req = vha->req;\r\nflags = iocb->u.tmf.flags;\r\nlun = iocb->u.tmf.lun;\r\ntsk->entry_type = TSK_MGMT_IOCB_TYPE;\r\ntsk->entry_count = 1;\r\ntsk->handle = MAKE_HANDLE(req->id, tsk->handle);\r\ntsk->nport_handle = cpu_to_le16(fcport->loop_id);\r\ntsk->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\ntsk->control_flags = cpu_to_le32(flags);\r\ntsk->port_id[0] = fcport->d_id.b.al_pa;\r\ntsk->port_id[1] = fcport->d_id.b.area;\r\ntsk->port_id[2] = fcport->d_id.b.domain;\r\ntsk->vp_index = fcport->vha->vp_idx;\r\nif (flags == TCF_LUN_RESET) {\r\nint_to_scsilun(lun, &tsk->lun);\r\nhost_to_fcp_swap((uint8_t *)&tsk->lun,\r\nsizeof(tsk->lun));\r\n}\r\n}\r\nstatic void\r\nqla2x00_els_dcmd_sp_free(void *ptr, void *data)\r\n{\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)ptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nsrb_t *sp = (srb_t *)data;\r\nstruct srb_iocb *elsio = &sp->u.iocb_cmd;\r\nkfree(sp->fcport);\r\nif (elsio->u.els_logo.els_logo_pyld)\r\ndma_free_coherent(&ha->pdev->dev, DMA_POOL_SIZE,\r\nelsio->u.els_logo.els_logo_pyld,\r\nelsio->u.els_logo.els_logo_pyld_dma);\r\ndel_timer(&elsio->timer);\r\nqla2x00_rel_sp(vha, sp);\r\n}\r\nstatic void\r\nqla2x00_els_dcmd_iocb_timeout(void *data)\r\n{\r\nsrb_t *sp = (srb_t *)data;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nfc_port_t *fcport = sp->fcport;\r\nstruct scsi_qla_host *vha = fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags = 0;\r\nql_dbg(ql_dbg_io, vha, 0x3069,\r\n"%s Timeout, hdl=%x, portid=%02x%02x%02x\n",\r\nsp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (ha->isp_ops->abort_command(sp)) {\r\nql_dbg(ql_dbg_io, vha, 0x3070,\r\n"mbx abort_command failed.\n");\r\n} else {\r\nql_dbg(ql_dbg_io, vha, 0x3071,\r\n"mbx abort_command success.\n");\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\ncomplete(&lio->u.els_logo.comp);\r\n}\r\nstatic void\r\nqla2x00_els_dcmd_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nfc_port_t *fcport = sp->fcport;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nstruct scsi_qla_host *vha = fcport->vha;\r\nql_dbg(ql_dbg_io, vha, 0x3072,\r\n"%s hdl=%x, portid=%02x%02x%02x done\n",\r\nsp->name, sp->handle, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\ncomplete(&lio->u.els_logo.comp);\r\n}\r\nint\r\nqla24xx_els_dcmd_iocb(scsi_qla_host_t *vha, int els_opcode,\r\nport_id_t remote_did)\r\n{\r\nsrb_t *sp;\r\nfc_port_t *fcport = NULL;\r\nstruct srb_iocb *elsio = NULL;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct els_logo_payload logo_pyld;\r\nint rval = QLA_SUCCESS;\r\nfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (!fcport) {\r\nql_log(ql_log_info, vha, 0x70e5, "fcport allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp) {\r\nkfree(fcport);\r\nql_log(ql_log_info, vha, 0x70e6,\r\n"SRB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nelsio = &sp->u.iocb_cmd;\r\nfcport->loop_id = 0xFFFF;\r\nfcport->d_id.b.domain = remote_did.b.domain;\r\nfcport->d_id.b.area = remote_did.b.area;\r\nfcport->d_id.b.al_pa = remote_did.b.al_pa;\r\nql_dbg(ql_dbg_io, vha, 0x3073, "portid=%02x%02x%02x done\n",\r\nfcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nsp->type = SRB_ELS_DCMD;\r\nsp->name = "ELS_DCMD";\r\nsp->fcport = fcport;\r\nqla2x00_init_timer(sp, ELS_DCMD_TIMEOUT);\r\nelsio->timeout = qla2x00_els_dcmd_iocb_timeout;\r\nsp->done = qla2x00_els_dcmd_sp_done;\r\nsp->free = qla2x00_els_dcmd_sp_free;\r\nelsio->u.els_logo.els_logo_pyld = dma_alloc_coherent(&ha->pdev->dev,\r\nDMA_POOL_SIZE, &elsio->u.els_logo.els_logo_pyld_dma,\r\nGFP_KERNEL);\r\nif (!elsio->u.els_logo.els_logo_pyld) {\r\nsp->free(vha, sp);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nmemset(&logo_pyld, 0, sizeof(struct els_logo_payload));\r\nelsio->u.els_logo.els_cmd = els_opcode;\r\nlogo_pyld.opcode = els_opcode;\r\nlogo_pyld.s_id[0] = vha->d_id.b.al_pa;\r\nlogo_pyld.s_id[1] = vha->d_id.b.area;\r\nlogo_pyld.s_id[2] = vha->d_id.b.domain;\r\nhost_to_fcp_swap(logo_pyld.s_id, sizeof(uint32_t));\r\nmemcpy(&logo_pyld.wwpn, vha->port_name, WWN_SIZE);\r\nmemcpy(elsio->u.els_logo.els_logo_pyld, &logo_pyld,\r\nsizeof(struct els_logo_payload));\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS) {\r\nsp->free(vha, sp);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_io, vha, 0x3074,\r\n"%s LOGO sent, hdl=%x, loopid=%x, portid=%02x%02x%02x.\n",\r\nsp->name, sp->handle, fcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nwait_for_completion(&elsio->u.els_logo.comp);\r\nsp->free(vha, sp);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)\r\n{\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct srb_iocb *elsio = &sp->u.iocb_cmd;\r\nels_iocb->entry_type = ELS_IOCB_TYPE;\r\nels_iocb->entry_count = 1;\r\nels_iocb->sys_define = 0;\r\nels_iocb->entry_status = 0;\r\nels_iocb->handle = sp->handle;\r\nels_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nels_iocb->tx_dsd_count = 1;\r\nels_iocb->vp_index = vha->vp_idx;\r\nels_iocb->sof_type = EST_SOFI3;\r\nels_iocb->rx_dsd_count = 0;\r\nels_iocb->opcode = elsio->u.els_logo.els_cmd;\r\nels_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\r\nels_iocb->port_id[1] = sp->fcport->d_id.b.area;\r\nels_iocb->port_id[2] = sp->fcport->d_id.b.domain;\r\nels_iocb->control_flags = 0;\r\nels_iocb->tx_byte_count = sizeof(struct els_logo_payload);\r\nels_iocb->tx_address[0] =\r\ncpu_to_le32(LSD(elsio->u.els_logo.els_logo_pyld_dma));\r\nels_iocb->tx_address[1] =\r\ncpu_to_le32(MSD(elsio->u.els_logo.els_logo_pyld_dma));\r\nels_iocb->tx_len = cpu_to_le32(sizeof(struct els_logo_payload));\r\nels_iocb->rx_byte_count = 0;\r\nels_iocb->rx_address[0] = 0;\r\nels_iocb->rx_address[1] = 0;\r\nels_iocb->rx_len = 0;\r\nsp->fcport->vha->qla_stats.control_requests++;\r\n}\r\nstatic void\r\nqla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)\r\n{\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\nels_iocb->entry_type = ELS_IOCB_TYPE;\r\nels_iocb->entry_count = 1;\r\nels_iocb->sys_define = 0;\r\nels_iocb->entry_status = 0;\r\nels_iocb->handle = sp->handle;\r\nels_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nels_iocb->tx_dsd_count = cpu_to_le16(bsg_job->request_payload.sg_cnt);\r\nels_iocb->vp_index = sp->fcport->vha->vp_idx;\r\nels_iocb->sof_type = EST_SOFI3;\r\nels_iocb->rx_dsd_count = cpu_to_le16(bsg_job->reply_payload.sg_cnt);\r\nels_iocb->opcode =\r\nsp->type == SRB_ELS_CMD_RPT ?\r\nbsg_job->request->rqst_data.r_els.els_code :\r\nbsg_job->request->rqst_data.h_els.command_code;\r\nels_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\r\nels_iocb->port_id[1] = sp->fcport->d_id.b.area;\r\nels_iocb->port_id[2] = sp->fcport->d_id.b.domain;\r\nels_iocb->control_flags = 0;\r\nels_iocb->rx_byte_count =\r\ncpu_to_le32(bsg_job->reply_payload.payload_len);\r\nels_iocb->tx_byte_count =\r\ncpu_to_le32(bsg_job->request_payload.payload_len);\r\nels_iocb->tx_address[0] = cpu_to_le32(LSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nels_iocb->tx_address[1] = cpu_to_le32(MSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nels_iocb->tx_len = cpu_to_le32(sg_dma_len\r\n(bsg_job->request_payload.sg_list));\r\nels_iocb->rx_address[0] = cpu_to_le32(LSD(sg_dma_address\r\n(bsg_job->reply_payload.sg_list)));\r\nels_iocb->rx_address[1] = cpu_to_le32(MSD(sg_dma_address\r\n(bsg_job->reply_payload.sg_list)));\r\nels_iocb->rx_len = cpu_to_le32(sg_dma_len\r\n(bsg_job->reply_payload.sg_list));\r\nsp->fcport->vha->qla_stats.control_requests++;\r\n}\r\nstatic void\r\nqla2x00_ct_iocb(srb_t *sp, ms_iocb_entry_t *ct_iocb)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nstruct scatterlist *sg;\r\nint index;\r\nuint16_t tot_dsds;\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\nint loop_iterartion = 0;\r\nint entry_count = 1;\r\nmemset(ct_iocb, 0, sizeof(ms_iocb_entry_t));\r\nct_iocb->entry_type = CT_IOCB_TYPE;\r\nct_iocb->entry_status = 0;\r\nct_iocb->handle1 = sp->handle;\r\nSET_TARGET_ID(ha, ct_iocb->loop_id, sp->fcport->loop_id);\r\nct_iocb->status = cpu_to_le16(0);\r\nct_iocb->control_flags = cpu_to_le16(0);\r\nct_iocb->timeout = 0;\r\nct_iocb->cmd_dsd_count =\r\ncpu_to_le16(bsg_job->request_payload.sg_cnt);\r\nct_iocb->total_dsd_count =\r\ncpu_to_le16(bsg_job->request_payload.sg_cnt + 1);\r\nct_iocb->req_bytecount =\r\ncpu_to_le32(bsg_job->request_payload.payload_len);\r\nct_iocb->rsp_bytecount =\r\ncpu_to_le32(bsg_job->reply_payload.payload_len);\r\nct_iocb->dseg_req_address[0] = cpu_to_le32(LSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nct_iocb->dseg_req_address[1] = cpu_to_le32(MSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nct_iocb->dseg_req_length = ct_iocb->req_bytecount;\r\nct_iocb->dseg_rsp_address[0] = cpu_to_le32(LSD(sg_dma_address\r\n(bsg_job->reply_payload.sg_list)));\r\nct_iocb->dseg_rsp_address[1] = cpu_to_le32(MSD(sg_dma_address\r\n(bsg_job->reply_payload.sg_list)));\r\nct_iocb->dseg_rsp_length = ct_iocb->rsp_bytecount;\r\navail_dsds = 1;\r\ncur_dsd = (uint32_t *)ct_iocb->dseg_rsp_address;\r\nindex = 0;\r\ntot_dsds = bsg_job->reply_payload.sg_cnt;\r\nfor_each_sg(bsg_job->reply_payload.sg_list, sg, tot_dsds, index) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha,\r\nvha->hw->req_q_map[0]);\r\ncur_dsd = (uint32_t *) cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\nentry_count++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\nloop_iterartion++;\r\navail_dsds--;\r\n}\r\nct_iocb->entry_count = entry_count;\r\nsp->fcport->vha->qla_stats.control_requests++;\r\n}\r\nstatic void\r\nqla24xx_ct_iocb(srb_t *sp, struct ct_entry_24xx *ct_iocb)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nstruct scatterlist *sg;\r\nint index;\r\nuint16_t tot_dsds;\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\nint loop_iterartion = 0;\r\nint entry_count = 1;\r\nct_iocb->entry_type = CT_IOCB_TYPE;\r\nct_iocb->entry_status = 0;\r\nct_iocb->sys_define = 0;\r\nct_iocb->handle = sp->handle;\r\nct_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nct_iocb->vp_index = sp->fcport->vha->vp_idx;\r\nct_iocb->comp_status = cpu_to_le16(0);\r\nct_iocb->cmd_dsd_count =\r\ncpu_to_le16(bsg_job->request_payload.sg_cnt);\r\nct_iocb->timeout = 0;\r\nct_iocb->rsp_dsd_count =\r\ncpu_to_le16(bsg_job->reply_payload.sg_cnt);\r\nct_iocb->rsp_byte_count =\r\ncpu_to_le32(bsg_job->reply_payload.payload_len);\r\nct_iocb->cmd_byte_count =\r\ncpu_to_le32(bsg_job->request_payload.payload_len);\r\nct_iocb->dseg_0_address[0] = cpu_to_le32(LSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nct_iocb->dseg_0_address[1] = cpu_to_le32(MSD(sg_dma_address\r\n(bsg_job->request_payload.sg_list)));\r\nct_iocb->dseg_0_len = cpu_to_le32(sg_dma_len\r\n(bsg_job->request_payload.sg_list));\r\navail_dsds = 1;\r\ncur_dsd = (uint32_t *)ct_iocb->dseg_1_address;\r\nindex = 0;\r\ntot_dsds = bsg_job->reply_payload.sg_cnt;\r\nfor_each_sg(bsg_job->reply_payload.sg_list, sg, tot_dsds, index) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha,\r\nha->req_q_map[0]);\r\ncur_dsd = (uint32_t *) cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\nentry_count++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\nloop_iterartion++;\r\navail_dsds--;\r\n}\r\nct_iocb->entry_count = entry_count;\r\n}\r\nint\r\nqla82xx_start_scsi(srb_t *sp)\r\n{\r\nint nseg;\r\nunsigned long flags;\r\nstruct scsi_cmnd *cmd;\r\nuint32_t *clr_ptr;\r\nuint32_t index;\r\nuint32_t handle;\r\nuint16_t cnt;\r\nuint16_t req_cnt;\r\nuint16_t tot_dsds;\r\nstruct device_reg_82xx __iomem *reg;\r\nuint32_t dbval;\r\nuint32_t *fcp_dl;\r\nuint8_t additional_cdb_len;\r\nstruct ct6_dsd *ctx;\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = NULL;\r\nstruct rsp_que *rsp = NULL;\r\nreg = &ha->iobase->isp82;\r\ncmd = GET_CMD_SP(sp);\r\nreq = vha->req;\r\nrsp = ha->rsp_q_map[0];\r\ntot_dsds = 0;\r\ndbval = 0x04 | (ha->portnum << 5);\r\nif (vha->marker_needed != 0) {\r\nif (qla2x00_marker(vha, req,\r\nrsp, 0, 0, MK_SYNC_ALL) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x300c,\r\n"qla2x00_marker failed for cmd=%p.\n", cmd);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nvha->marker_needed = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds)\r\ngoto queuing_error;\r\nif (scsi_sg_count(cmd)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\n} else\r\nnseg = 0;\r\ntot_dsds = nseg;\r\nif (tot_dsds > ql2xshiftctondsd) {\r\nstruct cmd_type_6 *cmd_pkt;\r\nuint16_t more_dsd_lists = 0;\r\nstruct dsd_dma *dsd_ptr;\r\nuint16_t i;\r\nmore_dsd_lists = qla24xx_calc_dsd_lists(tot_dsds);\r\nif ((more_dsd_lists + ha->gbl_dsd_inuse) >= NUM_DSD_CHAIN) {\r\nql_dbg(ql_dbg_io, vha, 0x300d,\r\n"Num of DSD list %d is than %d for cmd=%p.\n",\r\nmore_dsd_lists + ha->gbl_dsd_inuse, NUM_DSD_CHAIN,\r\ncmd);\r\ngoto queuing_error;\r\n}\r\nif (more_dsd_lists <= ha->gbl_dsd_avail)\r\ngoto sufficient_dsds;\r\nelse\r\nmore_dsd_lists -= ha->gbl_dsd_avail;\r\nfor (i = 0; i < more_dsd_lists; i++) {\r\ndsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\r\nif (!dsd_ptr) {\r\nql_log(ql_log_fatal, vha, 0x300e,\r\n"Failed to allocate memory for dsd_dma "\r\n"for cmd=%p.\n", cmd);\r\ngoto queuing_error;\r\n}\r\ndsd_ptr->dsd_addr = dma_pool_alloc(ha->dl_dma_pool,\r\nGFP_ATOMIC, &dsd_ptr->dsd_list_dma);\r\nif (!dsd_ptr->dsd_addr) {\r\nkfree(dsd_ptr);\r\nql_log(ql_log_fatal, vha, 0x300f,\r\n"Failed to allocate memory for dsd_addr "\r\n"for cmd=%p.\n", cmd);\r\ngoto queuing_error;\r\n}\r\nlist_add_tail(&dsd_ptr->list, &ha->gbl_dsd_list);\r\nha->gbl_dsd_avail++;\r\n}\r\nsufficient_dsds:\r\nreq_cnt = 1;\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = (uint16_t)RD_REG_DWORD_RELAXED(\r\n&reg->req_q_out[0]);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\n}\r\nctx = sp->u.scmd.ctx =\r\nmempool_alloc(ha->ctx_mempool, GFP_ATOMIC);\r\nif (!ctx) {\r\nql_log(ql_log_fatal, vha, 0x3010,\r\n"Failed to allocate ctx for cmd=%p.\n", cmd);\r\ngoto queuing_error;\r\n}\r\nmemset(ctx, 0, sizeof(struct ct6_dsd));\r\nctx->fcp_cmnd = dma_pool_alloc(ha->fcp_cmnd_dma_pool,\r\nGFP_ATOMIC, &ctx->fcp_cmnd_dma);\r\nif (!ctx->fcp_cmnd) {\r\nql_log(ql_log_fatal, vha, 0x3011,\r\n"Failed to allocate fcp_cmnd for cmd=%p.\n", cmd);\r\ngoto queuing_error;\r\n}\r\nINIT_LIST_HEAD(&ctx->dsd_list);\r\nctx->dsd_use_cnt = 0;\r\nif (cmd->cmd_len > 16) {\r\nadditional_cdb_len = cmd->cmd_len - 16;\r\nif ((cmd->cmd_len % 4) != 0) {\r\nql_log(ql_log_warn, vha, 0x3012,\r\n"scsi cmd len %d not multiple of 4 "\r\n"for cmd=%p.\n", cmd->cmd_len, cmd);\r\ngoto queuing_error_fcp_cmnd;\r\n}\r\nctx->fcp_cmnd_len = 12 + cmd->cmd_len + 4;\r\n} else {\r\nadditional_cdb_len = 0;\r\nctx->fcp_cmnd_len = 12 + 16 + 4;\r\n}\r\ncmd_pkt = (struct cmd_type_6 *)req->ring_ptr;\r\ncmd_pkt->handle = MAKE_HANDLE(req->id, handle);\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\r\ncmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\ncmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\r\ncmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\r\ncmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\r\ncmd_pkt->vp_index = sp->fcport->vha->vp_idx;\r\nif (qla24xx_build_scsi_type_6_iocbs(sp, cmd_pkt, tot_dsds))\r\ngoto queuing_error_fcp_cmnd;\r\nint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\r\nhost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\r\nmemset(ctx->fcp_cmnd, 0, sizeof(struct fcp_cmnd));\r\nint_to_scsilun(cmd->device->lun, &ctx->fcp_cmnd->lun);\r\nctx->fcp_cmnd->additional_cdb_len = additional_cdb_len;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nctx->fcp_cmnd->additional_cdb_len |= 1;\r\nelse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\nctx->fcp_cmnd->additional_cdb_len |= 2;\r\nif (ha->flags.fcp_prio_enabled)\r\nctx->fcp_cmnd->task_attribute |=\r\nsp->fcport->fcp_prio << 3;\r\nmemcpy(ctx->fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\r\nfcp_dl = (uint32_t *)(ctx->fcp_cmnd->cdb + 16 +\r\nadditional_cdb_len);\r\n*fcp_dl = htonl((uint32_t)scsi_bufflen(cmd));\r\ncmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(ctx->fcp_cmnd_len);\r\ncmd_pkt->fcp_cmnd_dseg_address[0] =\r\ncpu_to_le32(LSD(ctx->fcp_cmnd_dma));\r\ncmd_pkt->fcp_cmnd_dseg_address[1] =\r\ncpu_to_le32(MSD(ctx->fcp_cmnd_dma));\r\nsp->flags |= SRB_FCP_CMND_DMA_VALID;\r\ncmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\r\ncmd_pkt->entry_count = (uint8_t)req_cnt;\r\ncmd_pkt->entry_status = (uint8_t) rsp->id;\r\n} else {\r\nstruct cmd_type_7 *cmd_pkt;\r\nreq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = (uint16_t)RD_REG_DWORD_RELAXED(\r\n&reg->req_q_out[0]);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\n}\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\ncmd_pkt = (struct cmd_type_7 *)req->ring_ptr;\r\ncmd_pkt->handle = MAKE_HANDLE(req->id, handle);\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\r\ncmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\ncmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\r\ncmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\r\ncmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\r\ncmd_pkt->vp_index = sp->fcport->vha->vp_idx;\r\nint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\r\nhost_to_fcp_swap((uint8_t *)&cmd_pkt->lun,\r\nsizeof(cmd_pkt->lun));\r\nif (ha->flags.fcp_prio_enabled)\r\ncmd_pkt->task |= sp->fcport->fcp_prio << 3;\r\nmemcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);\r\nhost_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));\r\ncmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\r\nqla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds);\r\ncmd_pkt->entry_count = (uint8_t)req_cnt;\r\ncmd_pkt->entry_status = (uint8_t) rsp->id;\r\n}\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\ncmd->host_scribble = (unsigned char *)(unsigned long)handle;\r\nreq->cnt -= req_cnt;\r\nwmb();\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nsp->flags |= SRB_DMA_VALID;\r\ndbval = dbval | (req->id << 8) | (req->ring_index << 16);\r\nif (ql2xdbwr)\r\nqla82xx_wr_32(ha, (uintptr_t __force)ha->nxdb_wr_ptr, dbval);\r\nelse {\r\nWRT_REG_DWORD(ha->nxdb_wr_ptr, dbval);\r\nwmb();\r\nwhile (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {\r\nWRT_REG_DWORD(ha->nxdb_wr_ptr, dbval);\r\nwmb();\r\n}\r\n}\r\nif (vha->flags.process_response_queue &&\r\nrsp->ring_ptr->signature != RESPONSE_PROCESSED)\r\nqla24xx_process_response_queue(vha, rsp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\nqueuing_error_fcp_cmnd:\r\ndma_pool_free(ha->fcp_cmnd_dma_pool, ctx->fcp_cmnd, ctx->fcp_cmnd_dma);\r\nqueuing_error:\r\nif (tot_dsds)\r\nscsi_dma_unmap(cmd);\r\nif (sp->u.scmd.ctx) {\r\nmempool_free(sp->u.scmd.ctx, ha->ctx_mempool);\r\nsp->u.scmd.ctx = NULL;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic void\r\nqla24xx_abort_iocb(srb_t *sp, struct abort_entry_24xx *abt_iocb)\r\n{\r\nstruct srb_iocb *aio = &sp->u.iocb_cmd;\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct req_que *req = vha->req;\r\nmemset(abt_iocb, 0, sizeof(struct abort_entry_24xx));\r\nabt_iocb->entry_type = ABORT_IOCB_TYPE;\r\nabt_iocb->entry_count = 1;\r\nabt_iocb->handle = cpu_to_le32(MAKE_HANDLE(req->id, sp->handle));\r\nabt_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\r\nabt_iocb->handle_to_abort =\r\ncpu_to_le32(MAKE_HANDLE(req->id, aio->u.abt.cmd_hndl));\r\nabt_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\r\nabt_iocb->port_id[1] = sp->fcport->d_id.b.area;\r\nabt_iocb->port_id[2] = sp->fcport->d_id.b.domain;\r\nabt_iocb->vp_index = vha->vp_idx;\r\nabt_iocb->req_que_no = cpu_to_le16(req->id);\r\nwmb();\r\n}\r\nint\r\nqla2x00_start_sp(srb_t *sp)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = sp->fcport->vha->hw;\r\nvoid *pkt;\r\nunsigned long flags;\r\nrval = QLA_FUNCTION_FAILED;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\npkt = qla2x00_alloc_iocbs(sp->fcport->vha, sp);\r\nif (!pkt) {\r\nql_log(ql_log_warn, sp->fcport->vha, 0x700c,\r\n"qla2x00_alloc_iocbs failed.\n");\r\ngoto done;\r\n}\r\nrval = QLA_SUCCESS;\r\nswitch (sp->type) {\r\ncase SRB_LOGIN_CMD:\r\nIS_FWI2_CAPABLE(ha) ?\r\nqla24xx_login_iocb(sp, pkt) :\r\nqla2x00_login_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_LOGOUT_CMD:\r\nIS_FWI2_CAPABLE(ha) ?\r\nqla24xx_logout_iocb(sp, pkt) :\r\nqla2x00_logout_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_ELS_CMD_RPT:\r\ncase SRB_ELS_CMD_HST:\r\nqla24xx_els_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_CT_CMD:\r\nIS_FWI2_CAPABLE(ha) ?\r\nqla24xx_ct_iocb(sp, pkt) :\r\nqla2x00_ct_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_ADISC_CMD:\r\nIS_FWI2_CAPABLE(ha) ?\r\nqla24xx_adisc_iocb(sp, pkt) :\r\nqla2x00_adisc_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_TM_CMD:\r\nIS_QLAFX00(ha) ?\r\nqlafx00_tm_iocb(sp, pkt) :\r\nqla24xx_tm_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_FXIOCB_DCMD:\r\ncase SRB_FXIOCB_BCMD:\r\nqlafx00_fxdisc_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_ABT_CMD:\r\nIS_QLAFX00(ha) ?\r\nqlafx00_abort_iocb(sp, pkt) :\r\nqla24xx_abort_iocb(sp, pkt);\r\nbreak;\r\ncase SRB_ELS_DCMD:\r\nqla24xx_els_logo_iocb(sp, pkt);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwmb();\r\nqla2x00_start_iocbs(sp->fcport->vha, ha->req_q_map[0]);\r\ndone:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla25xx_build_bidir_iocb(srb_t *sp, struct scsi_qla_host *vha,\r\nstruct cmd_bidir *cmd_pkt, uint32_t tot_dsds)\r\n{\r\nuint16_t avail_dsds;\r\nuint32_t *cur_dsd;\r\nuint32_t req_data_len = 0;\r\nuint32_t rsp_data_len = 0;\r\nstruct scatterlist *sg;\r\nint index;\r\nint entry_count = 1;\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\n*((uint32_t *)(&cmd_pkt->entry_type)) =\r\ncpu_to_le32(COMMAND_BIDIRECTIONAL);\r\ncmd_pkt->wr_dseg_count = cpu_to_le16(bsg_job->request_payload.sg_cnt);\r\ncmd_pkt->rd_dseg_count = cpu_to_le16(bsg_job->reply_payload.sg_cnt);\r\ncmd_pkt->control_flags = cpu_to_le16(BD_WRITE_DATA | BD_READ_DATA |\r\nBD_WRAP_BACK);\r\nreq_data_len = rsp_data_len = bsg_job->request_payload.payload_len;\r\ncmd_pkt->wr_byte_count = cpu_to_le32(req_data_len);\r\ncmd_pkt->rd_byte_count = cpu_to_le32(rsp_data_len);\r\ncmd_pkt->timeout = cpu_to_le16(qla2x00_get_async_timeout(vha) + 2);\r\nvha->bidi_stats.transfer_bytes += req_data_len;\r\nvha->bidi_stats.io_count++;\r\nvha->qla_stats.output_bytes += req_data_len;\r\nvha->qla_stats.output_requests++;\r\navail_dsds = 1;\r\ncur_dsd = (uint32_t *)&cmd_pkt->fcp_data_dseg_address;\r\nindex = 0;\r\nfor_each_sg(bsg_job->request_payload.sg_list, sg,\r\nbsg_job->request_payload.sg_cnt, index) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\r\ncur_dsd = (uint32_t *) cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\nentry_count++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\nfor_each_sg(bsg_job->reply_payload.sg_list, sg,\r\nbsg_job->reply_payload.sg_cnt, index) {\r\ndma_addr_t sle_dma;\r\ncont_a64_entry_t *cont_pkt;\r\nif (avail_dsds == 0) {\r\ncont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\r\ncur_dsd = (uint32_t *) cont_pkt->dseg_0_address;\r\navail_dsds = 5;\r\nentry_count++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\n}\r\ncmd_pkt->entry_count = entry_count;\r\n}\r\nint\r\nqla2x00_start_bidir(srb_t *sp, struct scsi_qla_host *vha, uint32_t tot_dsds)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags;\r\nuint32_t handle;\r\nuint32_t index;\r\nuint16_t req_cnt;\r\nuint16_t cnt;\r\nuint32_t *clr_ptr;\r\nstruct cmd_bidir *cmd_pkt = NULL;\r\nstruct rsp_que *rsp;\r\nstruct req_que *req;\r\nint rval = EXT_STATUS_OK;\r\nrval = QLA_SUCCESS;\r\nrsp = ha->rsp_q_map[0];\r\nreq = vha->req;\r\nif (vha->marker_needed != 0) {\r\nif (qla2x00_marker(vha, req,\r\nrsp, 0, 0, MK_SYNC_ALL) != QLA_SUCCESS)\r\nreturn EXT_STATUS_MAILBOX;\r\nvha->marker_needed = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds) {\r\nrval = EXT_STATUS_BUSY;\r\ngoto queuing_error;\r\n}\r\nreq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\r\nif (req->cnt < req_cnt + 2) {\r\ncnt = IS_SHADOW_REG_CAPABLE(ha) ? *req->out_ptr :\r\nRD_REG_DWORD_RELAXED(req->req_q_out);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\n}\r\nif (req->cnt < req_cnt + 2) {\r\nrval = EXT_STATUS_BUSY;\r\ngoto queuing_error;\r\n}\r\ncmd_pkt = (struct cmd_bidir *)req->ring_ptr;\r\ncmd_pkt->handle = MAKE_HANDLE(req->id, handle);\r\nclr_ptr = (uint32_t *)cmd_pkt + 2;\r\nmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\r\ncmd_pkt->nport_handle = cpu_to_le16(vha->self_login_loop_id);\r\ncmd_pkt->port_id[0] = vha->d_id.b.al_pa;\r\ncmd_pkt->port_id[1] = vha->d_id.b.area;\r\ncmd_pkt->port_id[2] = vha->d_id.b.domain;\r\nqla25xx_build_bidir_iocb(sp, vha, cmd_pkt, tot_dsds);\r\ncmd_pkt->entry_status = (uint8_t) rsp->id;\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\nreq->cnt -= req_cnt;\r\nwmb();\r\nqla2x00_start_iocbs(vha, req);\r\nqueuing_error:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn rval;\r\n}
