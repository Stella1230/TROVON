static void armctrl_mask_irq(struct irq_data *d)\r\n{\r\nwritel_relaxed(HWIRQ_BIT(d->hwirq), intc.disable[HWIRQ_BANK(d->hwirq)]);\r\n}\r\nstatic void armctrl_unmask_irq(struct irq_data *d)\r\n{\r\nwritel_relaxed(HWIRQ_BIT(d->hwirq), intc.enable[HWIRQ_BANK(d->hwirq)]);\r\n}\r\nstatic int armctrl_xlate(struct irq_domain *d, struct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq, unsigned int *out_type)\r\n{\r\nif (WARN_ON(intsize != 2))\r\nreturn -EINVAL;\r\nif (WARN_ON(intspec[0] >= NR_BANKS))\r\nreturn -EINVAL;\r\nif (WARN_ON(intspec[1] >= IRQS_PER_BANK))\r\nreturn -EINVAL;\r\nif (WARN_ON(intspec[0] == 0 && intspec[1] >= NR_IRQS_BANK0))\r\nreturn -EINVAL;\r\n*out_hwirq = MAKE_HWIRQ(intspec[0], intspec[1]);\r\n*out_type = IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nstatic int __init armctrl_of_init(struct device_node *node,\r\nstruct device_node *parent,\r\nbool is_2836)\r\n{\r\nvoid __iomem *base;\r\nint irq, b, i;\r\nbase = of_iomap(node, 0);\r\nif (!base)\r\npanic("%s: unable to map IC registers\n",\r\nnode->full_name);\r\nintc.domain = irq_domain_add_linear(node, MAKE_HWIRQ(NR_BANKS, 0),\r\n&armctrl_ops, NULL);\r\nif (!intc.domain)\r\npanic("%s: unable to create IRQ domain\n", node->full_name);\r\nfor (b = 0; b < NR_BANKS; b++) {\r\nintc.pending[b] = base + reg_pending[b];\r\nintc.enable[b] = base + reg_enable[b];\r\nintc.disable[b] = base + reg_disable[b];\r\nfor (i = 0; i < bank_irqs[b]; i++) {\r\nirq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));\r\nBUG_ON(irq <= 0);\r\nirq_set_chip_and_handler(irq, &armctrl_chip,\r\nhandle_level_irq);\r\nirq_set_probe(irq);\r\n}\r\n}\r\nif (is_2836) {\r\nint parent_irq = irq_of_parse_and_map(node, 0);\r\nif (!parent_irq) {\r\npanic("%s: unable to get parent interrupt.\n",\r\nnode->full_name);\r\n}\r\nirq_set_chained_handler(parent_irq, bcm2836_chained_handle_irq);\r\n} else {\r\nset_handle_irq(bcm2835_handle_irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bcm2835_armctrl_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn armctrl_of_init(node, parent, false);\r\n}\r\nstatic int __init bcm2836_armctrl_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn armctrl_of_init(node, parent, true);\r\n}\r\nstatic u32 armctrl_translate_bank(int bank)\r\n{\r\nu32 stat = readl_relaxed(intc.pending[bank]);\r\nreturn MAKE_HWIRQ(bank, ffs(stat) - 1);\r\n}\r\nstatic u32 armctrl_translate_shortcut(int bank, u32 stat)\r\n{\r\nreturn MAKE_HWIRQ(bank, shortcuts[ffs(stat >> SHORTCUT_SHIFT) - 1]);\r\n}\r\nstatic u32 get_next_armctrl_hwirq(void)\r\n{\r\nu32 stat = readl_relaxed(intc.pending[0]) & BANK0_VALID_MASK;\r\nif (stat == 0)\r\nreturn ~0;\r\nelse if (stat & BANK0_HWIRQ_MASK)\r\nreturn MAKE_HWIRQ(0, ffs(stat & BANK0_HWIRQ_MASK) - 1);\r\nelse if (stat & SHORTCUT1_MASK)\r\nreturn armctrl_translate_shortcut(1, stat & SHORTCUT1_MASK);\r\nelse if (stat & SHORTCUT2_MASK)\r\nreturn armctrl_translate_shortcut(2, stat & SHORTCUT2_MASK);\r\nelse if (stat & BANK1_HWIRQ)\r\nreturn armctrl_translate_bank(1);\r\nelse if (stat & BANK2_HWIRQ)\r\nreturn armctrl_translate_bank(2);\r\nelse\r\nBUG();\r\n}\r\nstatic void __exception_irq_entry bcm2835_handle_irq(\r\nstruct pt_regs *regs)\r\n{\r\nu32 hwirq;\r\nwhile ((hwirq = get_next_armctrl_hwirq()) != ~0)\r\nhandle_domain_irq(intc.domain, hwirq, regs);\r\n}\r\nstatic void bcm2836_chained_handle_irq(struct irq_desc *desc)\r\n{\r\nu32 hwirq;\r\nwhile ((hwirq = get_next_armctrl_hwirq()) != ~0)\r\ngeneric_handle_irq(irq_linear_revmap(intc.domain, hwirq));\r\n}
