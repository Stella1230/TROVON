char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\r\n{\r\nif (regno >= DBG_MAX_REG_NUM || regno < 0)\r\nreturn NULL;\r\nif (dbg_reg_def[regno].offset != -1)\r\nmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\r\ndbg_reg_def[regno].size);\r\nelse\r\nmemset(mem, 0, dbg_reg_def[regno].size);\r\nreturn dbg_reg_def[regno].name;\r\n}\r\nint dbg_set_reg(int regno, void *mem, struct pt_regs *regs)\r\n{\r\nif (regno >= DBG_MAX_REG_NUM || regno < 0)\r\nreturn -EINVAL;\r\nif (dbg_reg_def[regno].offset != -1)\r\nmemcpy((void *)regs + dbg_reg_def[regno].offset, mem,\r\ndbg_reg_def[regno].size);\r\nreturn 0;\r\n}\r\nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\r\n{\r\nmemset((char *)gdb_regs, 0, NUMREGBYTES);\r\ngdb_regs[GDB_SP] = p->thread.kregs->sp;\r\ngdb_regs[GDB_PC] = p->thread.kregs->ea;\r\n}\r\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)\r\n{\r\nregs->ea = pc;\r\n}\r\nint kgdb_arch_handle_exception(int vector, int signo, int err_code,\r\nchar *remcom_in_buffer, char *remcom_out_buffer,\r\nstruct pt_regs *regs)\r\n{\r\nchar *ptr;\r\nunsigned long addr;\r\nswitch (remcom_in_buffer[0]) {\r\ncase 's':\r\ncase 'c':\r\nptr = &remcom_in_buffer[1];\r\nif (kgdb_hex2long(&ptr, &addr))\r\nregs->ea = addr;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nasmlinkage void kgdb_breakpoint_c(struct pt_regs *regs)\r\n{\r\nif (!wait_for_remote_debugger)\r\nregs->ea -= 4;\r\nelse\r\nwait_for_remote_debugger = 0;\r\nkgdb_handle_exception(30, SIGTRAP, 0, regs);\r\n}\r\nint kgdb_arch_init(void)\r\n{\r\nwait_for_remote_debugger = 1;\r\nreturn 0;\r\n}\r\nvoid kgdb_arch_exit(void)\r\n{\r\n}
