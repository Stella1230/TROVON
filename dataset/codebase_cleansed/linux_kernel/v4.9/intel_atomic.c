int\r\nintel_connector_atomic_get_property(struct drm_connector *connector,\r\nconst struct drm_connector_state *state,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nint i;\r\nfor (i = 0; i < connector->base.properties->count; i++) {\r\nif (connector->base.properties->properties[i] == property) {\r\n*val = connector->base.properties->values[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstruct drm_crtc_state *\r\nintel_crtc_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct intel_crtc_state *crtc_state;\r\ncrtc_state = kmemdup(crtc->state, sizeof(*crtc_state), GFP_KERNEL);\r\nif (!crtc_state)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &crtc_state->base);\r\ncrtc_state->update_pipe = false;\r\ncrtc_state->disable_lp_wm = false;\r\ncrtc_state->disable_cxsr = false;\r\ncrtc_state->update_wm_pre = false;\r\ncrtc_state->update_wm_post = false;\r\ncrtc_state->fb_changed = false;\r\ncrtc_state->wm.need_postvbl_update = false;\r\ncrtc_state->fb_bits = 0;\r\nreturn &crtc_state->base;\r\n}\r\nvoid\r\nintel_crtc_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\ndrm_atomic_helper_crtc_destroy_state(crtc, state);\r\n}\r\nint intel_atomic_setup_scalers(struct drm_device *dev,\r\nstruct intel_crtc *intel_crtc,\r\nstruct intel_crtc_state *crtc_state)\r\n{\r\nstruct drm_plane *plane = NULL;\r\nstruct intel_plane *intel_plane;\r\nstruct intel_plane_state *plane_state = NULL;\r\nstruct intel_crtc_scaler_state *scaler_state =\r\n&crtc_state->scaler_state;\r\nstruct drm_atomic_state *drm_state = crtc_state->base.state;\r\nint num_scalers_need;\r\nint i, j;\r\nnum_scalers_need = hweight32(scaler_state->scaler_users);\r\nif (num_scalers_need > intel_crtc->num_scalers){\r\nDRM_DEBUG_KMS("Too many scaling requests %d > %d\n",\r\nnum_scalers_need, intel_crtc->num_scalers);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < sizeof(scaler_state->scaler_users) * 8; i++) {\r\nint *scaler_id;\r\nconst char *name;\r\nint idx;\r\nif (!(scaler_state->scaler_users & (1 << i)))\r\ncontinue;\r\nif (i == SKL_CRTC_INDEX) {\r\nname = "CRTC";\r\nidx = intel_crtc->base.base.id;\r\nscaler_id = &scaler_state->scaler_id;\r\n} else {\r\nname = "PLANE";\r\nplane = drm_state->planes[i].ptr;\r\nif (!plane) {\r\nstruct drm_plane_state *state;\r\nplane = drm_plane_from_index(dev, i);\r\nstate = drm_atomic_get_plane_state(drm_state, plane);\r\nif (IS_ERR(state)) {\r\nDRM_DEBUG_KMS("Failed to add [PLANE:%d] to drm_state\n",\r\nplane->base.id);\r\nreturn PTR_ERR(state);\r\n}\r\ncrtc_state->base.planes_changed = true;\r\n}\r\nintel_plane = to_intel_plane(plane);\r\nidx = plane->base.id;\r\nif (WARN_ON(intel_plane->pipe != intel_crtc->pipe)) {\r\ncontinue;\r\n}\r\nplane_state = intel_atomic_get_existing_plane_state(drm_state,\r\nintel_plane);\r\nscaler_id = &plane_state->scaler_id;\r\n}\r\nif (*scaler_id < 0) {\r\nfor (j = 0; j < intel_crtc->num_scalers; j++) {\r\nif (!scaler_state->scalers[j].in_use) {\r\nscaler_state->scalers[j].in_use = 1;\r\n*scaler_id = j;\r\nDRM_DEBUG_KMS("Attached scaler id %u.%u to %s:%d\n",\r\nintel_crtc->pipe, *scaler_id, name, idx);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (WARN_ON(*scaler_id < 0)) {\r\nDRM_DEBUG_KMS("Cannot find scaler for %s:%d\n", name, idx);\r\ncontinue;\r\n}\r\nif (num_scalers_need == 1 && intel_crtc->pipe != PIPE_C) {\r\n*scaler_id = 0;\r\nscaler_state->scalers[0].in_use = 1;\r\nscaler_state->scalers[0].mode = PS_SCALER_MODE_HQ;\r\nscaler_state->scalers[1].in_use = 0;\r\n} else {\r\nscaler_state->scalers[*scaler_id].mode = PS_SCALER_MODE_DYN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nintel_atomic_duplicate_dpll_state(struct drm_i915_private *dev_priv,\r\nstruct intel_shared_dpll_config *shared_dpll)\r\n{\r\nenum intel_dpll_id i;\r\nfor (i = 0; i < dev_priv->num_shared_dpll; i++) {\r\nstruct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];\r\nshared_dpll[i] = pll->config;\r\n}\r\n}\r\nstruct intel_shared_dpll_config *\r\nintel_atomic_get_shared_dpll_state(struct drm_atomic_state *s)\r\n{\r\nstruct intel_atomic_state *state = to_intel_atomic_state(s);\r\nWARN_ON(!drm_modeset_is_locked(&s->dev->mode_config.connection_mutex));\r\nif (!state->dpll_set) {\r\nstate->dpll_set = true;\r\nintel_atomic_duplicate_dpll_state(to_i915(s->dev),\r\nstate->shared_dpll);\r\n}\r\nreturn state->shared_dpll;\r\n}\r\nstruct drm_atomic_state *\r\nintel_atomic_state_alloc(struct drm_device *dev)\r\n{\r\nstruct intel_atomic_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state || drm_atomic_state_init(dev, &state->base) < 0) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nreturn &state->base;\r\n}\r\nvoid intel_atomic_state_clear(struct drm_atomic_state *s)\r\n{\r\nstruct intel_atomic_state *state = to_intel_atomic_state(s);\r\ndrm_atomic_state_default_clear(&state->base);\r\nstate->dpll_set = state->modeset = false;\r\n}
