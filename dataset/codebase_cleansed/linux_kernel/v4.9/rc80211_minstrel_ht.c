static u16\r\nminstrel_get_valid_vht_rates(int bw, int nss, __le16 mcs_map)\r\n{\r\nu16 mask = 0;\r\nif (bw == BW_20) {\r\nif (nss != 3 && nss != 6)\r\nmask = BIT(9);\r\n} else if (bw == BW_80) {\r\nif (nss == 3 || nss == 7)\r\nmask = BIT(6);\r\nelse if (nss == 6)\r\nmask = BIT(9);\r\n} else {\r\nWARN_ON(bw != BW_40);\r\n}\r\nswitch ((le16_to_cpu(mcs_map) >> (2 * (nss - 1))) & 3) {\r\ncase IEEE80211_VHT_MCS_SUPPORT_0_7:\r\nmask |= 0x300;\r\nbreak;\r\ncase IEEE80211_VHT_MCS_SUPPORT_0_8:\r\nmask |= 0x200;\r\nbreak;\r\ncase IEEE80211_VHT_MCS_SUPPORT_0_9:\r\nbreak;\r\ndefault:\r\nmask = 0x3ff;\r\n}\r\nreturn 0x3ff & ~mask;\r\n}\r\nstatic int\r\nminstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)\r\n{\r\nreturn GROUP_IDX((rate->idx / 8) + 1,\r\n!!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\r\n!!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));\r\n}\r\nstatic int\r\nminstrel_vht_get_group_idx(struct ieee80211_tx_rate *rate)\r\n{\r\nreturn VHT_GROUP_IDX(ieee80211_rate_get_vht_nss(rate),\r\n!!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\r\n!!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) +\r\n2*!!(rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH));\r\n}\r\nstatic struct minstrel_rate_stats *\r\nminstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_tx_rate *rate)\r\n{\r\nint group, idx;\r\nif (rate->flags & IEEE80211_TX_RC_MCS) {\r\ngroup = minstrel_ht_get_group_idx(rate);\r\nidx = rate->idx % 8;\r\n} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\r\ngroup = minstrel_vht_get_group_idx(rate);\r\nidx = ieee80211_rate_get_vht_mcs(rate);\r\n} else {\r\ngroup = MINSTREL_CCK_GROUP;\r\nfor (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++)\r\nif (rate->idx == mp->cck_rates[idx])\r\nbreak;\r\nif (!(mi->groups[group].supported & BIT(idx)))\r\nidx += 4;\r\n}\r\nreturn &mi->groups[group].rates[idx];\r\n}\r\nstatic inline struct minstrel_rate_stats *\r\nminstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)\r\n{\r\nreturn &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];\r\n}\r\nint\r\nminstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,\r\nint prob_ewma)\r\n{\r\nunsigned int nsecs = 0;\r\nif (prob_ewma < MINSTREL_FRAC(10, 100))\r\nreturn 0;\r\nif (group != MINSTREL_CCK_GROUP)\r\nnsecs = 1000 * mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nnsecs += minstrel_mcs_groups[group].duration[rate];\r\nif (prob_ewma > MINSTREL_FRAC(90, 100))\r\nreturn MINSTREL_TRUNC(100000 * ((MINSTREL_FRAC(90, 100) * 1000)\r\n/ nsecs));\r\nelse\r\nreturn MINSTREL_TRUNC(100000 * ((prob_ewma * 1000) / nsecs));\r\n}\r\nstatic void\r\nminstrel_ht_sort_best_tp_rates(struct minstrel_ht_sta *mi, u16 index,\r\nu16 *tp_list)\r\n{\r\nint cur_group, cur_idx, cur_tp_avg, cur_prob;\r\nint tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;\r\nint j = MAX_THR_RATES;\r\ncur_group = index / MCS_GROUP_RATES;\r\ncur_idx = index % MCS_GROUP_RATES;\r\ncur_prob = mi->groups[cur_group].rates[cur_idx].prob_ewma;\r\ncur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx, cur_prob);\r\ndo {\r\ntmp_group = tp_list[j - 1] / MCS_GROUP_RATES;\r\ntmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;\r\ntmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;\r\ntmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx,\r\ntmp_prob);\r\nif (cur_tp_avg < tmp_tp_avg ||\r\n(cur_tp_avg == tmp_tp_avg && cur_prob <= tmp_prob))\r\nbreak;\r\nj--;\r\n} while (j > 0);\r\nif (j < MAX_THR_RATES - 1) {\r\nmemmove(&tp_list[j + 1], &tp_list[j], (sizeof(*tp_list) *\r\n(MAX_THR_RATES - (j + 1))));\r\n}\r\nif (j < MAX_THR_RATES)\r\ntp_list[j] = index;\r\n}\r\nstatic void\r\nminstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 index)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nstruct minstrel_rate_stats *mrs;\r\nint tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;\r\nint max_tp_group, cur_tp_avg, cur_group, cur_idx;\r\nint max_gpr_group, max_gpr_idx;\r\nint max_gpr_tp_avg, max_gpr_prob;\r\ncur_group = index / MCS_GROUP_RATES;\r\ncur_idx = index % MCS_GROUP_RATES;\r\nmg = &mi->groups[index / MCS_GROUP_RATES];\r\nmrs = &mg->rates[index % MCS_GROUP_RATES];\r\ntmp_group = mi->max_prob_rate / MCS_GROUP_RATES;\r\ntmp_idx = mi->max_prob_rate % MCS_GROUP_RATES;\r\ntmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;\r\ntmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\r\nmax_tp_group = mi->max_tp_rate[0] / MCS_GROUP_RATES;\r\nif((index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) &&\r\n(max_tp_group != MINSTREL_CCK_GROUP))\r\nreturn;\r\nmax_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;\r\nmax_gpr_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;\r\nmax_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_ewma;\r\nif (mrs->prob_ewma > MINSTREL_FRAC(75, 100)) {\r\ncur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx,\r\nmrs->prob_ewma);\r\nif (cur_tp_avg > tmp_tp_avg)\r\nmi->max_prob_rate = index;\r\nmax_gpr_tp_avg = minstrel_ht_get_tp_avg(mi, max_gpr_group,\r\nmax_gpr_idx,\r\nmax_gpr_prob);\r\nif (cur_tp_avg > max_gpr_tp_avg)\r\nmg->max_group_prob_rate = index;\r\n} else {\r\nif (mrs->prob_ewma > tmp_prob)\r\nmi->max_prob_rate = index;\r\nif (mrs->prob_ewma > max_gpr_prob)\r\nmg->max_group_prob_rate = index;\r\n}\r\n}\r\nstatic void\r\nminstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,\r\nu16 tmp_mcs_tp_rate[MAX_THR_RATES],\r\nu16 tmp_cck_tp_rate[MAX_THR_RATES])\r\n{\r\nunsigned int tmp_group, tmp_idx, tmp_cck_tp, tmp_mcs_tp, tmp_prob;\r\nint i;\r\ntmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;\r\ntmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;\r\ntmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;\r\ntmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\r\ntmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;\r\ntmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;\r\ntmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;\r\ntmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\r\nif (tmp_cck_tp > tmp_mcs_tp) {\r\nfor(i = 0; i < MAX_THR_RATES; i++) {\r\nminstrel_ht_sort_best_tp_rates(mi, tmp_cck_tp_rate[i],\r\ntmp_mcs_tp_rate);\r\n}\r\n}\r\n}\r\nstatic inline void\r\nminstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nint tmp_max_streams, group, tmp_idx, tmp_prob;\r\nint tmp_tp = 0;\r\ntmp_max_streams = minstrel_mcs_groups[mi->max_tp_rate[0] /\r\nMCS_GROUP_RATES].streams;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nmg = &mi->groups[group];\r\nif (!mg->supported || group == MINSTREL_CCK_GROUP)\r\ncontinue;\r\ntmp_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;\r\ntmp_prob = mi->groups[group].rates[tmp_idx].prob_ewma;\r\nif (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&\r\n(minstrel_mcs_groups[group].streams < tmp_max_streams)) {\r\nmi->max_prob_rate = mg->max_group_prob_rate;\r\ntmp_tp = minstrel_ht_get_tp_avg(mi, group,\r\ntmp_idx,\r\ntmp_prob);\r\n}\r\n}\r\n}\r\nstatic void\r\nminstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nstruct minstrel_rate_stats *mrs;\r\nint group, i, j, cur_prob;\r\nu16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];\r\nu16 tmp_cck_tp_rate[MAX_THR_RATES], index;\r\nif (mi->ampdu_packets > 0) {\r\nmi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,\r\nMINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);\r\nmi->ampdu_len = 0;\r\nmi->ampdu_packets = 0;\r\n}\r\nmi->sample_slow = 0;\r\nmi->sample_count = 0;\r\nfor(j = 0; j < MAX_THR_RATES; j++){\r\ntmp_mcs_tp_rate[j] = 0;\r\ntmp_cck_tp_rate[j] = 0;\r\n}\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmi->sample_count++;\r\nfor(j = 0; j < MAX_THR_RATES; j++)\r\ntmp_group_tp_rate[j] = group;\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nif (!(mg->supported & BIT(i)))\r\ncontinue;\r\nindex = MCS_GROUP_RATES * group + i;\r\nmrs = &mg->rates[i];\r\nmrs->retry_updated = false;\r\nminstrel_calc_rate_stats(mrs);\r\ncur_prob = mrs->prob_ewma;\r\nif (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)\r\ncontinue;\r\nif (group != MINSTREL_CCK_GROUP) {\r\nminstrel_ht_sort_best_tp_rates(mi, index,\r\ntmp_mcs_tp_rate);\r\n} else if (group == MINSTREL_CCK_GROUP) {\r\nminstrel_ht_sort_best_tp_rates(mi, index,\r\ntmp_cck_tp_rate);\r\n}\r\nminstrel_ht_sort_best_tp_rates(mi, index,\r\ntmp_group_tp_rate);\r\nminstrel_ht_set_best_prob_rate(mi, index);\r\n}\r\nmemcpy(mg->max_group_tp_rate, tmp_group_tp_rate,\r\nsizeof(mg->max_group_tp_rate));\r\n}\r\nminstrel_ht_assign_best_tp_rates(mi, tmp_mcs_tp_rate, tmp_cck_tp_rate);\r\nmemcpy(mi->max_tp_rate, tmp_mcs_tp_rate, sizeof(mi->max_tp_rate));\r\nminstrel_ht_prob_rate_reduce_streams(mi);\r\nmi->sample_count *= 8;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1) {\r\nfor (i = 0; i < 4; i++)\r\nmi->max_tp_rate[i] = mp->fixed_rate_idx;\r\nmi->max_prob_rate = mp->fixed_rate_idx;\r\n}\r\n#endif\r\nmi->last_stats_update = jiffies;\r\n}\r\nstatic bool\r\nminstrel_ht_txstat_valid(struct minstrel_priv *mp, struct ieee80211_tx_rate *rate)\r\n{\r\nif (rate->idx < 0)\r\nreturn false;\r\nif (!rate->count)\r\nreturn false;\r\nif (rate->flags & IEEE80211_TX_RC_MCS ||\r\nrate->flags & IEEE80211_TX_RC_VHT_MCS)\r\nreturn true;\r\nreturn rate->idx == mp->cck_rates[0] ||\r\nrate->idx == mp->cck_rates[1] ||\r\nrate->idx == mp->cck_rates[2] ||\r\nrate->idx == mp->cck_rates[3];\r\n}\r\nstatic void\r\nminstrel_set_next_sample_idx(struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nfor (;;) {\r\nmi->sample_group++;\r\nmi->sample_group %= ARRAY_SIZE(minstrel_mcs_groups);\r\nmg = &mi->groups[mi->sample_group];\r\nif (!mg->supported)\r\ncontinue;\r\nif (++mg->index >= MCS_GROUP_RATES) {\r\nmg->index = 0;\r\nif (++mg->column >= ARRAY_SIZE(sample_table))\r\nmg->column = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)\r\n{\r\nint group, orig_group;\r\norig_group = group = *idx / MCS_GROUP_RATES;\r\nwhile (group > 0) {\r\ngroup--;\r\nif (!mi->groups[group].supported)\r\ncontinue;\r\nif (minstrel_mcs_groups[group].streams >\r\nminstrel_mcs_groups[orig_group].streams)\r\ncontinue;\r\nif (primary)\r\n*idx = mi->groups[group].max_group_tp_rate[0];\r\nelse\r\n*idx = mi->groups[group].max_group_tp_rate[1];\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nu16 tid;\r\nif (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)\r\nreturn;\r\nif (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))\r\nreturn;\r\nif (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))\r\nreturn;\r\ntid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;\r\nif (likely(sta->ampdu_mlme.tid_tx[tid]))\r\nreturn;\r\nieee80211_start_tx_ba_session(pubsta, tid, 0);\r\n}\r\nstatic void\r\nminstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nstruct minstrel_rate_stats *rate, *rate2;\r\nstruct minstrel_priv *mp = priv;\r\nbool last, update = false;\r\nint i;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.tx_status_noskb(priv, sband, sta,\r\n&msp->legacy, info);\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\nif (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\r\ninfo->status.ampdu_ack_len =\r\n(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);\r\ninfo->status.ampdu_len = 1;\r\n}\r\nmi->ampdu_packets++;\r\nmi->ampdu_len += info->status.ampdu_len;\r\nif (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {\r\nmi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nmi->sample_tries = 1;\r\nmi->sample_count--;\r\n}\r\nif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\r\nmi->sample_packets += info->status.ampdu_len;\r\nlast = !minstrel_ht_txstat_valid(mp, &ar[0]);\r\nfor (i = 0; !last; i++) {\r\nlast = (i == IEEE80211_TX_MAX_RATES - 1) ||\r\n!minstrel_ht_txstat_valid(mp, &ar[i + 1]);\r\nrate = minstrel_ht_get_stats(mp, mi, &ar[i]);\r\nif (last)\r\nrate->success += info->status.ampdu_ack_len;\r\nrate->attempts += ar[i].count * info->status.ampdu_len;\r\n}\r\nrate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);\r\nif (rate->attempts > 30 &&\r\nMINSTREL_FRAC(rate->success, rate->attempts) <\r\nMINSTREL_FRAC(20, 100)) {\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);\r\nupdate = true;\r\n}\r\nrate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);\r\nif (rate2->attempts > 30 &&\r\nMINSTREL_FRAC(rate2->success, rate2->attempts) <\r\nMINSTREL_FRAC(20, 100)) {\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);\r\nupdate = true;\r\n}\r\nif (time_after(jiffies, mi->last_stats_update +\r\n(mp->update_interval / 2 * HZ) / 1000)) {\r\nupdate = true;\r\nminstrel_ht_update_stats(mp, mi);\r\n}\r\nif (update)\r\nminstrel_ht_update_rates(mp, mi);\r\n}\r\nstatic void\r\nminstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nint index)\r\n{\r\nstruct minstrel_rate_stats *mrs;\r\nconst struct mcs_group *group;\r\nunsigned int tx_time, tx_time_rtscts, tx_time_data;\r\nunsigned int cw = mp->cw_min;\r\nunsigned int ctime = 0;\r\nunsigned int t_slot = 9;\r\nunsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nunsigned int overhead = 0, overhead_rtscts = 0;\r\nmrs = minstrel_get_ratestats(mi, index);\r\nif (mrs->prob_ewma < MINSTREL_FRAC(1, 10)) {\r\nmrs->retry_count = 1;\r\nmrs->retry_count_rtscts = 1;\r\nreturn;\r\n}\r\nmrs->retry_count = 2;\r\nmrs->retry_count_rtscts = 2;\r\nmrs->retry_updated = true;\r\ngroup = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\ntx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len / 1000;\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\nctime += (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\nif (index / MCS_GROUP_RATES != MINSTREL_CCK_GROUP) {\r\noverhead = mi->overhead;\r\noverhead_rtscts = mi->overhead_rtscts;\r\n}\r\ntx_time = ctime + 2 * (overhead + tx_time_data);\r\ntx_time_rtscts = ctime + 2 * (overhead_rtscts + tx_time_data);\r\ndo {\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time += ctime + overhead + tx_time_data;\r\ntx_time_rtscts += ctime + overhead_rtscts + tx_time_data;\r\nif (tx_time_rtscts < mp->segment_size)\r\nmrs->retry_count_rtscts++;\r\n} while ((tx_time < mp->segment_size) &&\r\n(++mrs->retry_count < mp->max_retry));\r\n}\r\nstatic void\r\nminstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_sta_rates *ratetbl, int offset, int index)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nstruct minstrel_rate_stats *mrs;\r\nu8 idx;\r\nu16 flags = group->flags;\r\nmrs = minstrel_get_ratestats(mi, index);\r\nif (!mrs->retry_updated)\r\nminstrel_calc_retransmit(mp, mi, index);\r\nif (mrs->prob_ewma < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {\r\nratetbl->rate[offset].count = 2;\r\nratetbl->rate[offset].count_rts = 2;\r\nratetbl->rate[offset].count_cts = 2;\r\n} else {\r\nratetbl->rate[offset].count = mrs->retry_count;\r\nratetbl->rate[offset].count_cts = mrs->retry_count;\r\nratetbl->rate[offset].count_rts = mrs->retry_count_rtscts;\r\n}\r\nif (index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP)\r\nidx = mp->cck_rates[index % ARRAY_SIZE(mp->cck_rates)];\r\nelse if (flags & IEEE80211_TX_RC_VHT_MCS)\r\nidx = ((group->streams - 1) << 4) |\r\n((index % MCS_GROUP_RATES) & 0xF);\r\nelse\r\nidx = index % MCS_GROUP_RATES + (group->streams - 1) * 8;\r\nif (offset > 0 ||\r\n(mi->sta->smps_mode == IEEE80211_SMPS_DYNAMIC &&\r\ngroup->streams > 1)) {\r\nratetbl->rate[offset].count = ratetbl->rate[offset].count_rts;\r\nflags |= IEEE80211_TX_RC_USE_RTS_CTS;\r\n}\r\nratetbl->rate[offset].idx = idx;\r\nratetbl->rate[offset].flags = flags;\r\n}\r\nstatic inline int\r\nminstrel_ht_get_prob_ewma(struct minstrel_ht_sta *mi, int rate)\r\n{\r\nint group = rate / MCS_GROUP_RATES;\r\nrate %= MCS_GROUP_RATES;\r\nreturn mi->groups[group].rates[rate].prob_ewma;\r\n}\r\nstatic int\r\nminstrel_ht_get_max_amsdu_len(struct minstrel_ht_sta *mi)\r\n{\r\nint group = mi->max_prob_rate / MCS_GROUP_RATES;\r\nconst struct mcs_group *g = &minstrel_mcs_groups[group];\r\nint rate = mi->max_prob_rate % MCS_GROUP_RATES;\r\nif (mi->groups[group].rates[rate].prob_ewma < MINSTREL_FRAC(50, 100))\r\nreturn 1;\r\nif (g->duration[rate] > MCS_DURATION(1, 0, 52))\r\nreturn 500;\r\nif (g->duration[rate] > MCS_DURATION(1, 0, 104))\r\nreturn 1600;\r\nif (g->duration[rate] > MCS_DURATION(1, 0, 260) ||\r\n(minstrel_ht_get_prob_ewma(mi, mi->max_tp_rate[0]) <\r\nMINSTREL_FRAC(75, 100)))\r\nreturn 3200;\r\nif (!mi->sta->vht_cap.vht_supported)\r\nreturn IEEE80211_MAX_MPDU_LEN_HT_BA;\r\nreturn 0;\r\n}\r\nstatic void\r\nminstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct ieee80211_sta_rates *rates;\r\nint i = 0;\r\nrates = kzalloc(sizeof(*rates), GFP_ATOMIC);\r\nif (!rates)\r\nreturn;\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);\r\nif (mp->hw->max_rates >= 3) {\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[1]);\r\n}\r\nif (mp->hw->max_rates >= 2) {\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);\r\n}\r\nmi->sta->max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);\r\nrates->rate[i].idx = -1;\r\nrate_control_set_rates(mp->hw, mi->sta, rates);\r\n}\r\nstatic inline int\r\nminstrel_get_duration(int index)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nreturn group->duration[index % MCS_GROUP_RATES];\r\n}\r\nstatic int\r\nminstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_rate_stats *mrs;\r\nstruct minstrel_mcs_group_data *mg;\r\nunsigned int sample_dur, sample_group, cur_max_tp_streams;\r\nint tp_rate1, tp_rate2;\r\nint sample_idx = 0;\r\nif (mi->sample_wait > 0) {\r\nmi->sample_wait--;\r\nreturn -1;\r\n}\r\nif (!mi->sample_tries)\r\nreturn -1;\r\nsample_group = mi->sample_group;\r\nmg = &mi->groups[sample_group];\r\nsample_idx = sample_table[mg->column][mg->index];\r\nminstrel_set_next_sample_idx(mi);\r\nif (!(mg->supported & BIT(sample_idx)))\r\nreturn -1;\r\nmrs = &mg->rates[sample_idx];\r\nsample_idx += sample_group * MCS_GROUP_RATES;\r\nif (minstrel_get_duration(mi->max_tp_rate[0]) >\r\nminstrel_get_duration(mi->max_tp_rate[1])) {\r\ntp_rate1 = mi->max_tp_rate[1];\r\ntp_rate2 = mi->max_tp_rate[0];\r\n} else {\r\ntp_rate1 = mi->max_tp_rate[0];\r\ntp_rate2 = mi->max_tp_rate[1];\r\n}\r\nif (sample_idx == mi->max_tp_rate[0] || sample_idx == mi->max_prob_rate)\r\nreturn -1;\r\nif (mrs->prob_ewma > MINSTREL_FRAC(95, 100))\r\nreturn -1;\r\ncur_max_tp_streams = minstrel_mcs_groups[tp_rate1 /\r\nMCS_GROUP_RATES].streams;\r\nsample_dur = minstrel_get_duration(sample_idx);\r\nif (sample_dur >= minstrel_get_duration(tp_rate2) &&\r\n(cur_max_tp_streams - 1 <\r\nminstrel_mcs_groups[sample_group].streams ||\r\nsample_dur >= minstrel_get_duration(mi->max_prob_rate))) {\r\nif (mrs->sample_skipped < 20)\r\nreturn -1;\r\nif (mi->sample_slow++ > 2)\r\nreturn -1;\r\n}\r\nmi->sample_tries--;\r\nreturn sample_idx;\r\n}\r\nstatic void\r\nminstrel_ht_check_cck_shortpreamble(struct minstrel_priv *mp,\r\nstruct minstrel_ht_sta *mi, bool val)\r\n{\r\nu8 supported = mi->groups[MINSTREL_CCK_GROUP].supported;\r\nif (!supported || !mi->cck_supported_short)\r\nreturn;\r\nif (supported & (mi->cck_supported_short << (val * 4)))\r\nreturn;\r\nsupported ^= mi->cck_supported_short | (mi->cck_supported_short << 4);\r\nmi->groups[MINSTREL_CCK_GROUP].supported = supported;\r\n}\r\nstatic void\r\nminstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nconst struct mcs_group *sample_group;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\r\nstruct ieee80211_tx_rate *rate = &info->status.rates[0];\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct minstrel_priv *mp = priv;\r\nint sample_idx;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.get_rate(priv, sta, &msp->legacy, txrc);\r\nif (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\nmi->max_prob_rate / MCS_GROUP_RATES != MINSTREL_CCK_GROUP)\r\nminstrel_aggr_check(sta, txrc->skb);\r\ninfo->flags |= mi->tx_flags;\r\nminstrel_ht_check_cck_shortpreamble(mp, mi, txrc->short_preamble);\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1)\r\nreturn;\r\n#endif\r\nif (mp->hw->max_rates == 1 &&\r\n(info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))\r\nsample_idx = -1;\r\nelse\r\nsample_idx = minstrel_get_sample_rate(mp, mi);\r\nmi->total_packets++;\r\nif (mi->total_packets == ~0) {\r\nmi->total_packets = 0;\r\nmi->sample_packets = 0;\r\n}\r\nif (sample_idx < 0)\r\nreturn;\r\nsample_group = &minstrel_mcs_groups[sample_idx / MCS_GROUP_RATES];\r\ninfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\r\nrate->count = 1;\r\nif (sample_idx / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {\r\nint idx = sample_idx % ARRAY_SIZE(mp->cck_rates);\r\nrate->idx = mp->cck_rates[idx];\r\n} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {\r\nieee80211_rate_set_vht(rate, sample_idx % MCS_GROUP_RATES,\r\nsample_group->streams);\r\n} else {\r\nrate->idx = sample_idx % MCS_GROUP_RATES +\r\n(sample_group->streams - 1) * 8;\r\n}\r\nrate->flags = sample_group->flags;\r\n}\r\nstatic void\r\nminstrel_ht_update_cck(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta)\r\n{\r\nint i;\r\nif (sband->band != NL80211_BAND_2GHZ)\r\nreturn;\r\nif (!ieee80211_hw_check(mp->hw, SUPPORTS_HT_CCK_RATES))\r\nreturn;\r\nmi->cck_supported = 0;\r\nmi->cck_supported_short = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (!rate_supported(sta, sband->band, mp->cck_rates[i]))\r\ncontinue;\r\nmi->cck_supported |= BIT(i);\r\nif (sband->bitrates[i].flags & IEEE80211_RATE_SHORT_PREAMBLE)\r\nmi->cck_supported_short |= BIT(i);\r\n}\r\nmi->groups[MINSTREL_CCK_GROUP].supported = mi->cck_supported;\r\n}\r\nstatic void\r\nminstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_priv *mp = priv;\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;\r\nu16 sta_cap = sta->ht_cap.cap;\r\nstruct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;\r\nint use_vht;\r\nint n_supported = 0;\r\nint ack_dur;\r\nint stbc;\r\nint i;\r\nif (!sta->ht_cap.ht_supported)\r\ngoto use_legacy;\r\nBUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);\r\n#ifdef CONFIG_MAC80211_RC_MINSTREL_VHT\r\nif (vht_cap->vht_supported)\r\nuse_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);\r\nelse\r\n#endif\r\nuse_vht = 0;\r\nmsp->is_ht = true;\r\nmemset(mi, 0, sizeof(*mi));\r\nmi->sta = sta;\r\nmi->last_stats_update = jiffies;\r\nack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);\r\nmi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);\r\nmi->overhead += ack_dur;\r\nmi->overhead_rtscts = mi->overhead + 2 * ack_dur;\r\nmi->avg_ampdu_len = MINSTREL_FRAC(1, 1);\r\nif (mp->has_mrr) {\r\nmi->sample_count = 16;\r\nmi->sample_wait = 0;\r\n} else {\r\nmi->sample_count = 8;\r\nmi->sample_wait = 8;\r\n}\r\nmi->sample_tries = 4;\r\nif (!use_vht) {\r\nstbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>\r\nIEEE80211_HT_CAP_RX_STBC_SHIFT;\r\nmi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;\r\nif (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)\r\nmi->tx_flags |= IEEE80211_TX_CTL_LDPC;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mi->groups); i++) {\r\nu32 gflags = minstrel_mcs_groups[i].flags;\r\nint bw, nss;\r\nmi->groups[i].supported = 0;\r\nif (i == MINSTREL_CCK_GROUP) {\r\nminstrel_ht_update_cck(mp, mi, sband, sta);\r\ncontinue;\r\n}\r\nif (gflags & IEEE80211_TX_RC_SHORT_GI) {\r\nif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\r\nif (!(sta_cap & IEEE80211_HT_CAP_SGI_40))\r\ncontinue;\r\n} else {\r\nif (!(sta_cap & IEEE80211_HT_CAP_SGI_20))\r\ncontinue;\r\n}\r\n}\r\nif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH &&\r\nsta->bandwidth < IEEE80211_STA_RX_BW_40)\r\ncontinue;\r\nnss = minstrel_mcs_groups[i].streams;\r\nif (sta->smps_mode == IEEE80211_SMPS_STATIC && nss > 1)\r\ncontinue;\r\nif (gflags & IEEE80211_TX_RC_MCS) {\r\n#ifdef CONFIG_MAC80211_RC_MINSTREL_VHT\r\nif (use_vht && minstrel_vht_only)\r\ncontinue;\r\n#endif\r\nmi->groups[i].supported = mcs->rx_mask[nss - 1];\r\nif (mi->groups[i].supported)\r\nn_supported++;\r\ncontinue;\r\n}\r\nif (!vht_cap->vht_supported ||\r\nWARN_ON(!(gflags & IEEE80211_TX_RC_VHT_MCS)) ||\r\nWARN_ON(gflags & IEEE80211_TX_RC_160_MHZ_WIDTH))\r\ncontinue;\r\nif (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH) {\r\nif (sta->bandwidth < IEEE80211_STA_RX_BW_80 ||\r\n((gflags & IEEE80211_TX_RC_SHORT_GI) &&\r\n!(vht_cap->cap & IEEE80211_VHT_CAP_SHORT_GI_80))) {\r\ncontinue;\r\n}\r\n}\r\nif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\nbw = BW_40;\r\nelse if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)\r\nbw = BW_80;\r\nelse\r\nbw = BW_20;\r\nmi->groups[i].supported = minstrel_get_valid_vht_rates(bw, nss,\r\nvht_cap->vht_mcs.tx_mcs_map);\r\nif (mi->groups[i].supported)\r\nn_supported++;\r\n}\r\nif (!n_supported)\r\ngoto use_legacy;\r\nminstrel_ht_update_stats(mp, mi);\r\nminstrel_ht_update_rates(mp, mi);\r\nreturn;\r\nuse_legacy:\r\nmsp->is_ht = false;\r\nmemset(&msp->legacy, 0, sizeof(msp->legacy));\r\nmsp->legacy.r = msp->ratelist;\r\nmsp->legacy.sample_table = msp->sample_table;\r\nreturn mac80211_minstrel.rate_init(priv, sband, chandef, sta,\r\n&msp->legacy);\r\n}\r\nstatic void\r\nminstrel_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\r\n}\r\nstatic void\r\nminstrel_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nu32 changed)\r\n{\r\nminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct minstrel_ht_sta_priv *msp;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_hw *hw = mp->hw;\r\nint max_rates = 0;\r\nint i;\r\nfor (i = 0; i < NUM_NL80211_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nmsp = kzalloc(sizeof(*msp), gfp);\r\nif (!msp)\r\nreturn NULL;\r\nmsp->ratelist = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);\r\nif (!msp->ratelist)\r\ngoto error;\r\nmsp->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);\r\nif (!msp->sample_table)\r\ngoto error1;\r\nreturn msp;\r\nerror1:\r\nkfree(msp->ratelist);\r\nerror:\r\nkfree(msp);\r\nreturn NULL;\r\n}\r\nstatic void\r\nminstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nkfree(msp->sample_table);\r\nkfree(msp->ratelist);\r\nkfree(msp);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn mac80211_minstrel.alloc(hw, debugfsdir);\r\n}\r\nstatic void\r\nminstrel_ht_free(void *priv)\r\n{\r\nmac80211_minstrel.free(priv);\r\n}\r\nstatic u32 minstrel_ht_get_expected_throughput(void *priv_sta)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nint i, j, prob, tp_avg;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.get_expected_throughput(priv_sta);\r\ni = mi->max_tp_rate[0] / MCS_GROUP_RATES;\r\nj = mi->max_tp_rate[0] % MCS_GROUP_RATES;\r\nprob = mi->groups[i].rates[j].prob_ewma;\r\ntp_avg = minstrel_ht_get_tp_avg(mi, i, j, prob) * 10;\r\ntp_avg = tp_avg * AVG_PKT_SIZE * 8 / 1024;\r\nreturn tp_avg;\r\n}\r\nstatic void __init init_sample_table(void)\r\n{\r\nint col, i, new_idx;\r\nu8 rnd[MCS_GROUP_RATES];\r\nmemset(sample_table, 0xff, sizeof(sample_table));\r\nfor (col = 0; col < SAMPLE_COLUMNS; col++) {\r\nprandom_bytes(rnd, sizeof(rnd));\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nnew_idx = (i + rnd[i]) % MCS_GROUP_RATES;\r\nwhile (sample_table[col][new_idx] != 0xff)\r\nnew_idx = (new_idx + 1) % MCS_GROUP_RATES;\r\nsample_table[col][new_idx] = i;\r\n}\r\n}\r\n}\r\nint __init\r\nrc80211_minstrel_ht_init(void)\r\n{\r\ninit_sample_table();\r\nreturn ieee80211_rate_control_register(&mac80211_minstrel_ht);\r\n}\r\nvoid\r\nrc80211_minstrel_ht_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_minstrel_ht);\r\n}
