static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,\r\nint size)\r\n{\r\nif (likely((dst != src) && (size > 0)))\r\nmemmove(base + dst, base + src, size * sizeof(*base));\r\n}\r\nstatic inline void ntfs_rl_mc(runlist_element *dstbase, int dst,\r\nrunlist_element *srcbase, int src, int size)\r\n{\r\nif (likely(size > 0))\r\nmemcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));\r\n}\r\nstatic inline runlist_element *ntfs_rl_realloc(runlist_element *rl,\r\nint old_size, int new_size)\r\n{\r\nrunlist_element *new_rl;\r\nold_size = PAGE_ALIGN(old_size * sizeof(*rl));\r\nnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\r\nif (old_size == new_size)\r\nreturn rl;\r\nnew_rl = ntfs_malloc_nofs(new_size);\r\nif (unlikely(!new_rl))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (likely(rl != NULL)) {\r\nif (unlikely(old_size > new_size))\r\nold_size = new_size;\r\nmemcpy(new_rl, rl, old_size);\r\nntfs_free(rl);\r\n}\r\nreturn new_rl;\r\n}\r\nstatic inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,\r\nint old_size, int new_size)\r\n{\r\nrunlist_element *new_rl;\r\nold_size = PAGE_ALIGN(old_size * sizeof(*rl));\r\nnew_size = PAGE_ALIGN(new_size * sizeof(*rl));\r\nif (old_size == new_size)\r\nreturn rl;\r\nnew_rl = ntfs_malloc_nofs_nofail(new_size);\r\nBUG_ON(!new_rl);\r\nif (likely(rl != NULL)) {\r\nif (unlikely(old_size > new_size))\r\nold_size = new_size;\r\nmemcpy(new_rl, rl, old_size);\r\nntfs_free(rl);\r\n}\r\nreturn new_rl;\r\n}\r\nstatic inline bool ntfs_are_rl_mergeable(runlist_element *dst,\r\nrunlist_element *src)\r\n{\r\nBUG_ON(!dst);\r\nBUG_ON(!src);\r\nif ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))\r\nreturn true;\r\nif ((dst->vcn + dst->length) != src->vcn)\r\nreturn false;\r\nif ((dst->lcn >= 0) && (src->lcn >= 0) &&\r\n((dst->lcn + dst->length) == src->lcn))\r\nreturn true;\r\nif ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)\r\n{\r\ndst->length += src->length;\r\n}\r\nstatic inline runlist_element *ntfs_rl_append(runlist_element *dst,\r\nint dsize, runlist_element *src, int ssize, int loc)\r\n{\r\nbool right = false;\r\nint marker;\r\nBUG_ON(!dst);\r\nBUG_ON(!src);\r\nif ((loc + 1) < dsize)\r\nright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\r\ndst = ntfs_rl_realloc(dst, dsize, dsize + ssize - right);\r\nif (IS_ERR(dst))\r\nreturn dst;\r\nif (right)\r\n__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\r\nmarker = loc + ssize + 1;\r\nntfs_rl_mm(dst, marker, loc + 1 + right, dsize - (loc + 1 + right));\r\nntfs_rl_mc(dst, loc + 1, src, 0, ssize);\r\ndst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\r\nif (dst[marker].lcn == LCN_ENOENT)\r\ndst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\r\nreturn dst;\r\n}\r\nstatic inline runlist_element *ntfs_rl_insert(runlist_element *dst,\r\nint dsize, runlist_element *src, int ssize, int loc)\r\n{\r\nbool left = false;\r\nbool disc = false;\r\nint marker;\r\nBUG_ON(!dst);\r\nBUG_ON(!src);\r\nif (loc == 0)\r\ndisc = (src[0].vcn > 0);\r\nelse {\r\ns64 merged_length;\r\nleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\r\nmerged_length = dst[loc - 1].length;\r\nif (left)\r\nmerged_length += src->length;\r\ndisc = (src[0].vcn > dst[loc - 1].vcn + merged_length);\r\n}\r\ndst = ntfs_rl_realloc(dst, dsize, dsize + ssize - left + disc);\r\nif (IS_ERR(dst))\r\nreturn dst;\r\nif (left)\r\n__ntfs_rl_merge(dst + loc - 1, src);\r\nmarker = loc + ssize - left + disc;\r\nntfs_rl_mm(dst, marker, loc, dsize - loc);\r\nntfs_rl_mc(dst, loc + disc, src, left, ssize - left);\r\ndst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\r\nif (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)\r\ndst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;\r\nif (disc) {\r\nif (loc > 0) {\r\ndst[loc].vcn = dst[loc - 1].vcn + dst[loc - 1].length;\r\ndst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;\r\n} else {\r\ndst[loc].vcn = 0;\r\ndst[loc].length = dst[loc + 1].vcn;\r\n}\r\ndst[loc].lcn = LCN_RL_NOT_MAPPED;\r\n}\r\nreturn dst;\r\n}\r\nstatic inline runlist_element *ntfs_rl_replace(runlist_element *dst,\r\nint dsize, runlist_element *src, int ssize, int loc)\r\n{\r\nsigned delta;\r\nbool left = false;\r\nbool right = false;\r\nint tail;\r\nint marker;\r\nBUG_ON(!dst);\r\nBUG_ON(!src);\r\nif ((loc + 1) < dsize)\r\nright = ntfs_are_rl_mergeable(src + ssize - 1, dst + loc + 1);\r\nif (loc > 0)\r\nleft = ntfs_are_rl_mergeable(dst + loc - 1, src);\r\ndelta = ssize - 1 - left - right;\r\nif (delta > 0) {\r\ndst = ntfs_rl_realloc(dst, dsize, dsize + delta);\r\nif (IS_ERR(dst))\r\nreturn dst;\r\n}\r\nif (right)\r\n__ntfs_rl_merge(src + ssize - 1, dst + loc + 1);\r\nif (left)\r\n__ntfs_rl_merge(dst + loc - 1, src);\r\ntail = loc + right + 1;\r\nmarker = loc + ssize - left;\r\nntfs_rl_mm(dst, marker, tail, dsize - tail);\r\nntfs_rl_mc(dst, loc, src, left, ssize - left);\r\nif (dsize - tail > 0 && dst[marker].lcn == LCN_ENOENT)\r\ndst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;\r\nreturn dst;\r\n}\r\nstatic inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,\r\nrunlist_element *src, int ssize, int loc)\r\n{\r\nBUG_ON(!dst);\r\nBUG_ON(!src);\r\ndst = ntfs_rl_realloc(dst, dsize, dsize + ssize + 1);\r\nif (IS_ERR(dst))\r\nreturn dst;\r\nntfs_rl_mm(dst, loc + 1 + ssize, loc, dsize - loc);\r\nntfs_rl_mc(dst, loc + 1, src, 0, ssize);\r\ndst[loc].length = dst[loc+1].vcn - dst[loc].vcn;\r\ndst[loc+ssize+1].vcn = dst[loc+ssize].vcn + dst[loc+ssize].length;\r\ndst[loc+ssize+1].length = dst[loc+ssize+2].vcn - dst[loc+ssize+1].vcn;\r\nreturn dst;\r\n}\r\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\r\nrunlist_element *srl)\r\n{\r\nint di, si;\r\nint sstart;\r\nint dins;\r\nint dend, send;\r\nint dfinal, sfinal;\r\nint marker = 0;\r\nVCN marker_vcn = 0;\r\n#ifdef DEBUG\r\nntfs_debug("dst:");\r\nntfs_debug_dump_runlist(drl);\r\nntfs_debug("src:");\r\nntfs_debug_dump_runlist(srl);\r\n#endif\r\nif (unlikely(!srl))\r\nreturn drl;\r\nif (IS_ERR(srl) || IS_ERR(drl))\r\nreturn ERR_PTR(-EINVAL);\r\nif (unlikely(!drl)) {\r\ndrl = srl;\r\nif (unlikely(drl[0].vcn)) {\r\nfor (dend = 0; likely(drl[dend].length); dend++)\r\n;\r\ndend++;\r\ndrl = ntfs_rl_realloc(drl, dend, dend + 1);\r\nif (IS_ERR(drl))\r\nreturn drl;\r\nntfs_rl_mm(drl, 1, 0, dend);\r\ndrl[0].vcn = 0;\r\ndrl[0].lcn = LCN_RL_NOT_MAPPED;\r\ndrl[0].length = drl[1].vcn;\r\n}\r\ngoto finished;\r\n}\r\nsi = di = 0;\r\nwhile (srl[si].length && srl[si].lcn < LCN_HOLE)\r\nsi++;\r\nBUG_ON(!srl[si].length);\r\nsstart = si;\r\nfor (; drl[di].length; di++) {\r\nif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\r\nbreak;\r\n}\r\ndins = di;\r\nif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\r\n(srl[si].lcn >= 0)) {\r\nntfs_error(NULL, "Run lists overlap. Cannot merge!");\r\nreturn ERR_PTR(-ERANGE);\r\n}\r\nfor (send = si; srl[send].length; send++)\r\n;\r\nfor (dend = di; drl[dend].length; dend++)\r\n;\r\nif (srl[send].lcn == LCN_ENOENT)\r\nmarker_vcn = srl[marker = send].vcn;\r\nfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\r\n;\r\nfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\r\n;\r\n{\r\nbool start;\r\nbool finish;\r\nint ds = dend + 1;\r\nint ss = sfinal - sstart + 1;\r\nstart = ((drl[dins].lcn < LCN_RL_NOT_MAPPED) ||\r\n(drl[dins].vcn == srl[sstart].vcn));\r\nfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&\r\n((drl[dins].vcn + drl[dins].length) <=\r\n(srl[send - 1].vcn + srl[send - 1].length)));\r\nif (finish && !drl[dins].length)\r\nss++;\r\nif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\r\nfinish = false;\r\n#if 0\r\nntfs_debug("dfinal = %i, dend = %i", dfinal, dend);\r\nntfs_debug("sstart = %i, sfinal = %i, send = %i", sstart, sfinal, send);\r\nntfs_debug("start = %i, finish = %i", start, finish);\r\nntfs_debug("ds = %i, ss = %i, dins = %i", ds, ss, dins);\r\n#endif\r\nif (start) {\r\nif (finish)\r\ndrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\r\nelse\r\ndrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\r\n} else {\r\nif (finish)\r\ndrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\r\nelse\r\ndrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\r\n}\r\nif (IS_ERR(drl)) {\r\nntfs_error(NULL, "Merge failed.");\r\nreturn drl;\r\n}\r\nntfs_free(srl);\r\nif (marker) {\r\nntfs_debug("Triggering marker code.");\r\nfor (ds = dend; drl[ds].length; ds++)\r\n;\r\nif (drl[ds].vcn <= marker_vcn) {\r\nint slots = 0;\r\nif (drl[ds].vcn == marker_vcn) {\r\nntfs_debug("Old marker = 0x%llx, replacing "\r\n"with LCN_ENOENT.",\r\n(unsigned long long)\r\ndrl[ds].lcn);\r\ndrl[ds].lcn = LCN_ENOENT;\r\ngoto finished;\r\n}\r\nif (drl[ds].lcn == LCN_ENOENT) {\r\nds--;\r\nslots = 1;\r\n}\r\nif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\r\nif (!slots) {\r\ndrl = ntfs_rl_realloc_nofail(drl, ds,\r\nds + 2);\r\nslots = 2;\r\n}\r\nds++;\r\nif (slots != 1)\r\ndrl[ds].vcn = drl[ds - 1].vcn +\r\ndrl[ds - 1].length;\r\ndrl[ds].lcn = LCN_RL_NOT_MAPPED;\r\nslots--;\r\n}\r\ndrl[ds].length = marker_vcn - drl[ds].vcn;\r\nds++;\r\nif (!slots)\r\ndrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\r\ndrl[ds].vcn = marker_vcn;\r\ndrl[ds].lcn = LCN_ENOENT;\r\ndrl[ds].length = (s64)0;\r\n}\r\n}\r\n}\r\nfinished:\r\nntfs_debug("Merged runlist:");\r\nntfs_debug_dump_runlist(drl);\r\nreturn drl;\r\n}\r\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\r\nconst ATTR_RECORD *attr, runlist_element *old_rl)\r\n{\r\nVCN vcn;\r\nLCN lcn;\r\ns64 deltaxcn;\r\nrunlist_element *rl;\r\nu8 *buf;\r\nu8 *attr_end;\r\nint rlsize;\r\nu16 rlpos;\r\nu8 b;\r\n#ifdef DEBUG\r\nif (!attr || !attr->non_resident || sle64_to_cpu(\r\nattr->data.non_resident.lowest_vcn) < (VCN)0) {\r\nntfs_error(vol->sb, "Invalid arguments.");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n#endif\r\nvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\r\nlcn = 0;\r\nbuf = (u8*)attr + le16_to_cpu(\r\nattr->data.non_resident.mapping_pairs_offset);\r\nattr_end = (u8*)attr + le32_to_cpu(attr->length);\r\nif (unlikely(buf < (u8*)attr || buf > attr_end)) {\r\nntfs_error(vol->sb, "Corrupt attribute.");\r\nreturn ERR_PTR(-EIO);\r\n}\r\nif (!vcn && !*buf)\r\nreturn old_rl;\r\nrlpos = 0;\r\nrl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\r\nif (unlikely(!rl))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (vcn) {\r\nrl->vcn = 0;\r\nrl->lcn = LCN_RL_NOT_MAPPED;\r\nrl->length = vcn;\r\nrlpos++;\r\n}\r\nwhile (buf < attr_end && *buf) {\r\nif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\r\nrunlist_element *rl2;\r\nrl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\r\nif (unlikely(!rl2)) {\r\nntfs_free(rl);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(rl2, rl, rlsize);\r\nntfs_free(rl);\r\nrl = rl2;\r\nrlsize += PAGE_SIZE;\r\n}\r\nrl[rlpos].vcn = vcn;\r\nb = *buf & 0xf;\r\nif (b) {\r\nif (unlikely(buf + b > attr_end))\r\ngoto io_error;\r\nfor (deltaxcn = (s8)buf[b--]; b; b--)\r\ndeltaxcn = (deltaxcn << 8) + buf[b];\r\n} else {\r\nntfs_error(vol->sb, "Missing length entry in mapping "\r\n"pairs array.");\r\ndeltaxcn = (s64)-1;\r\n}\r\nif (unlikely(deltaxcn < 0)) {\r\nntfs_error(vol->sb, "Invalid length in mapping pairs "\r\n"array.");\r\ngoto err_out;\r\n}\r\nrl[rlpos].length = deltaxcn;\r\nvcn += deltaxcn;\r\nif (!(*buf & 0xf0))\r\nrl[rlpos].lcn = LCN_HOLE;\r\nelse {\r\nu8 b2 = *buf & 0xf;\r\nb = b2 + ((*buf >> 4) & 0xf);\r\nif (buf + b > attr_end)\r\ngoto io_error;\r\nfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\r\ndeltaxcn = (deltaxcn << 8) + buf[b];\r\nlcn += deltaxcn;\r\n#ifdef DEBUG\r\nif (vol->major_ver < 3) {\r\nif (unlikely(deltaxcn == (LCN)-1))\r\nntfs_error(vol->sb, "lcn delta == -1");\r\nif (unlikely(lcn == (LCN)-1))\r\nntfs_error(vol->sb, "lcn == -1");\r\n}\r\n#endif\r\nif (unlikely(lcn < (LCN)-1)) {\r\nntfs_error(vol->sb, "Invalid LCN < -1 in "\r\n"mapping pairs array.");\r\ngoto err_out;\r\n}\r\nrl[rlpos].lcn = lcn;\r\n}\r\nrlpos++;\r\nbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\r\n}\r\nif (unlikely(buf >= attr_end))\r\ngoto io_error;\r\ndeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\r\nif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\r\nmpa_err:\r\nntfs_error(vol->sb, "Corrupt mapping pairs array in "\r\n"non-resident attribute.");\r\ngoto err_out;\r\n}\r\nif (!attr->data.non_resident.lowest_vcn) {\r\nVCN max_cluster;\r\nmax_cluster = ((sle64_to_cpu(\r\nattr->data.non_resident.allocated_size) +\r\nvol->cluster_size - 1) >>\r\nvol->cluster_size_bits) - 1;\r\nif (deltaxcn) {\r\nif (deltaxcn < max_cluster) {\r\nntfs_debug("More extents to follow; deltaxcn "\r\n"= 0x%llx, max_cluster = "\r\n"0x%llx",\r\n(unsigned long long)deltaxcn,\r\n(unsigned long long)\r\nmax_cluster);\r\nrl[rlpos].vcn = vcn;\r\nvcn += rl[rlpos].length = max_cluster -\r\ndeltaxcn;\r\nrl[rlpos].lcn = LCN_RL_NOT_MAPPED;\r\nrlpos++;\r\n} else if (unlikely(deltaxcn > max_cluster)) {\r\nntfs_error(vol->sb, "Corrupt attribute. "\r\n"deltaxcn = 0x%llx, "\r\n"max_cluster = 0x%llx",\r\n(unsigned long long)deltaxcn,\r\n(unsigned long long)\r\nmax_cluster);\r\ngoto mpa_err;\r\n}\r\n}\r\nrl[rlpos].lcn = LCN_ENOENT;\r\n} else\r\nrl[rlpos].lcn = LCN_RL_NOT_MAPPED;\r\nrl[rlpos].vcn = vcn;\r\nrl[rlpos].length = (s64)0;\r\nif (!old_rl) {\r\nntfs_debug("Mapping pairs array successfully decompressed:");\r\nntfs_debug_dump_runlist(rl);\r\nreturn rl;\r\n}\r\nold_rl = ntfs_runlists_merge(old_rl, rl);\r\nif (likely(!IS_ERR(old_rl)))\r\nreturn old_rl;\r\nntfs_free(rl);\r\nntfs_error(vol->sb, "Failed to merge runlists.");\r\nreturn old_rl;\r\nio_error:\r\nntfs_error(vol->sb, "Corrupt attribute.");\r\nerr_out:\r\nntfs_free(rl);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\r\n{\r\nint i;\r\nBUG_ON(vcn < 0);\r\nif (unlikely(!rl))\r\nreturn LCN_RL_NOT_MAPPED;\r\nif (unlikely(vcn < rl[0].vcn))\r\nreturn LCN_ENOENT;\r\nfor (i = 0; likely(rl[i].length); i++) {\r\nif (unlikely(vcn < rl[i+1].vcn)) {\r\nif (likely(rl[i].lcn >= (LCN)0))\r\nreturn rl[i].lcn + (vcn - rl[i].vcn);\r\nreturn rl[i].lcn;\r\n}\r\n}\r\nif (likely(rl[i].lcn < (LCN)0))\r\nreturn rl[i].lcn;\r\nreturn LCN_ENOENT;\r\n}\r\nrunlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\r\n{\r\nBUG_ON(vcn < 0);\r\nif (unlikely(!rl || vcn < rl[0].vcn))\r\nreturn NULL;\r\nwhile (likely(rl->length)) {\r\nif (unlikely(vcn < rl[1].vcn)) {\r\nif (likely(rl->lcn >= LCN_HOLE))\r\nreturn rl;\r\nreturn NULL;\r\n}\r\nrl++;\r\n}\r\nif (likely(rl->lcn == LCN_ENOENT))\r\nreturn rl;\r\nreturn NULL;\r\n}\r\nstatic inline int ntfs_get_nr_significant_bytes(const s64 n)\r\n{\r\ns64 l = n;\r\nint i;\r\ns8 j;\r\ni = 0;\r\ndo {\r\nl >>= 8;\r\ni++;\r\n} while (l != 0 && l != -1);\r\nj = (n >> 8 * (i - 1)) & 0xff;\r\nif ((n < 0 && j >= 0) || (n > 0 && j < 0))\r\ni++;\r\nreturn i;\r\n}\r\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\r\nconst runlist_element *rl, const VCN first_vcn,\r\nconst VCN last_vcn)\r\n{\r\nLCN prev_lcn;\r\nint rls;\r\nbool the_end = false;\r\nBUG_ON(first_vcn < 0);\r\nBUG_ON(last_vcn < -1);\r\nBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\r\nif (!rl) {\r\nBUG_ON(first_vcn);\r\nBUG_ON(last_vcn > 0);\r\nreturn 1;\r\n}\r\nwhile (rl->length && first_vcn >= rl[1].vcn)\r\nrl++;\r\nif (unlikely((!rl->length && first_vcn > rl->vcn) ||\r\nfirst_vcn < rl->vcn))\r\nreturn -EINVAL;\r\nprev_lcn = 0;\r\nrls = 1;\r\nif (first_vcn > rl->vcn) {\r\ns64 delta, length = rl->length;\r\nif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\r\ngoto err_out;\r\nif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\r\ns64 s1 = last_vcn + 1;\r\nif (unlikely(rl[1].vcn > s1))\r\nlength = s1 - rl->vcn;\r\nthe_end = true;\r\n}\r\ndelta = first_vcn - rl->vcn;\r\nrls += 1 + ntfs_get_nr_significant_bytes(length - delta);\r\nif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\r\nprev_lcn = rl->lcn;\r\nif (likely(rl->lcn >= 0))\r\nprev_lcn += delta;\r\nrls += ntfs_get_nr_significant_bytes(prev_lcn);\r\n}\r\nrl++;\r\n}\r\nfor (; rl->length && !the_end; rl++) {\r\ns64 length = rl->length;\r\nif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\r\ngoto err_out;\r\nif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\r\ns64 s1 = last_vcn + 1;\r\nif (unlikely(rl[1].vcn > s1))\r\nlength = s1 - rl->vcn;\r\nthe_end = true;\r\n}\r\nrls += 1 + ntfs_get_nr_significant_bytes(length);\r\nif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\r\nrls += ntfs_get_nr_significant_bytes(rl->lcn -\r\nprev_lcn);\r\nprev_lcn = rl->lcn;\r\n}\r\n}\r\nreturn rls;\r\nerr_out:\r\nif (rl->lcn == LCN_RL_NOT_MAPPED)\r\nrls = -EINVAL;\r\nelse\r\nrls = -EIO;\r\nreturn rls;\r\n}\r\nstatic inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,\r\nconst s64 n)\r\n{\r\ns64 l = n;\r\nint i;\r\ns8 j;\r\ni = 0;\r\ndo {\r\nif (unlikely(dst > dst_max))\r\ngoto err_out;\r\n*dst++ = l & 0xffll;\r\nl >>= 8;\r\ni++;\r\n} while (l != 0 && l != -1);\r\nj = (n >> 8 * (i - 1)) & 0xff;\r\nif (n < 0 && j >= 0) {\r\nif (unlikely(dst > dst_max))\r\ngoto err_out;\r\ni++;\r\n*dst = (s8)-1;\r\n} else if (n > 0 && j < 0) {\r\nif (unlikely(dst > dst_max))\r\ngoto err_out;\r\ni++;\r\n*dst = (s8)0;\r\n}\r\nreturn i;\r\nerr_out:\r\nreturn -ENOSPC;\r\n}\r\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\r\nconst int dst_len, const runlist_element *rl,\r\nconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\r\n{\r\nLCN prev_lcn;\r\ns8 *dst_max, *dst_next;\r\nint err = -ENOSPC;\r\nbool the_end = false;\r\ns8 len_len, lcn_len;\r\nBUG_ON(first_vcn < 0);\r\nBUG_ON(last_vcn < -1);\r\nBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\r\nBUG_ON(dst_len < 1);\r\nif (!rl) {\r\nBUG_ON(first_vcn);\r\nBUG_ON(last_vcn > 0);\r\nif (stop_vcn)\r\n*stop_vcn = 0;\r\n*dst = 0;\r\nreturn 0;\r\n}\r\nwhile (rl->length && first_vcn >= rl[1].vcn)\r\nrl++;\r\nif (unlikely((!rl->length && first_vcn > rl->vcn) ||\r\nfirst_vcn < rl->vcn))\r\nreturn -EINVAL;\r\ndst_max = dst + dst_len - 1;\r\nprev_lcn = 0;\r\nif (first_vcn > rl->vcn) {\r\ns64 delta, length = rl->length;\r\nif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\r\ngoto err_out;\r\nif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\r\ns64 s1 = last_vcn + 1;\r\nif (unlikely(rl[1].vcn > s1))\r\nlength = s1 - rl->vcn;\r\nthe_end = true;\r\n}\r\ndelta = first_vcn - rl->vcn;\r\nlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\r\nlength - delta);\r\nif (unlikely(len_len < 0))\r\ngoto size_err;\r\nif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\r\nprev_lcn = rl->lcn;\r\nif (likely(rl->lcn >= 0))\r\nprev_lcn += delta;\r\nlcn_len = ntfs_write_significant_bytes(dst + 1 +\r\nlen_len, dst_max, prev_lcn);\r\nif (unlikely(lcn_len < 0))\r\ngoto size_err;\r\n} else\r\nlcn_len = 0;\r\ndst_next = dst + len_len + lcn_len + 1;\r\nif (unlikely(dst_next > dst_max))\r\ngoto size_err;\r\n*dst = lcn_len << 4 | len_len;\r\ndst = dst_next;\r\nrl++;\r\n}\r\nfor (; rl->length && !the_end; rl++) {\r\ns64 length = rl->length;\r\nif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\r\ngoto err_out;\r\nif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\r\ns64 s1 = last_vcn + 1;\r\nif (unlikely(rl[1].vcn > s1))\r\nlength = s1 - rl->vcn;\r\nthe_end = true;\r\n}\r\nlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\r\nlength);\r\nif (unlikely(len_len < 0))\r\ngoto size_err;\r\nif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\r\nlcn_len = ntfs_write_significant_bytes(dst + 1 +\r\nlen_len, dst_max, rl->lcn - prev_lcn);\r\nif (unlikely(lcn_len < 0))\r\ngoto size_err;\r\nprev_lcn = rl->lcn;\r\n} else\r\nlcn_len = 0;\r\ndst_next = dst + len_len + lcn_len + 1;\r\nif (unlikely(dst_next > dst_max))\r\ngoto size_err;\r\n*dst = lcn_len << 4 | len_len;\r\ndst = dst_next;\r\n}\r\nerr = 0;\r\nsize_err:\r\nif (stop_vcn)\r\n*stop_vcn = rl->vcn;\r\n*dst = 0;\r\nreturn err;\r\nerr_out:\r\nif (rl->lcn == LCN_RL_NOT_MAPPED)\r\nerr = -EINVAL;\r\nelse\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\r\nconst s64 new_length)\r\n{\r\nrunlist_element *rl;\r\nint old_size;\r\nntfs_debug("Entering for new_length 0x%llx.", (long long)new_length);\r\nBUG_ON(!runlist);\r\nBUG_ON(new_length < 0);\r\nrl = runlist->rl;\r\nif (!new_length) {\r\nntfs_debug("Freeing runlist.");\r\nrunlist->rl = NULL;\r\nif (rl)\r\nntfs_free(rl);\r\nreturn 0;\r\n}\r\nif (unlikely(!rl)) {\r\nrl = ntfs_malloc_nofs(PAGE_SIZE);\r\nif (unlikely(!rl)) {\r\nntfs_error(vol->sb, "Not enough memory to allocate "\r\n"runlist element buffer.");\r\nreturn -ENOMEM;\r\n}\r\nrunlist->rl = rl;\r\nrl[1].length = rl->vcn = 0;\r\nrl->lcn = LCN_HOLE;\r\nrl[1].vcn = rl->length = new_length;\r\nrl[1].lcn = LCN_ENOENT;\r\nreturn 0;\r\n}\r\nBUG_ON(new_length < rl->vcn);\r\nwhile (likely(rl->length && new_length >= rl[1].vcn))\r\nrl++;\r\nif (rl->length) {\r\nrunlist_element *trl;\r\nbool is_end;\r\nntfs_debug("Shrinking runlist.");\r\ntrl = rl + 1;\r\nwhile (likely(trl->length))\r\ntrl++;\r\nold_size = trl - runlist->rl + 1;\r\nrl->length = new_length - rl->vcn;\r\nis_end = false;\r\nif (rl->length) {\r\nrl++;\r\nif (!rl->length)\r\nis_end = true;\r\nrl->vcn = new_length;\r\nrl->length = 0;\r\n}\r\nrl->lcn = LCN_ENOENT;\r\nif (!is_end) {\r\nint new_size = rl - runlist->rl + 1;\r\nrl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\r\nif (IS_ERR(rl))\r\nntfs_warning(vol->sb, "Failed to shrink "\r\n"runlist buffer. This just "\r\n"wastes a bit of memory "\r\n"temporarily so we ignore it "\r\n"and return success.");\r\nelse\r\nrunlist->rl = rl;\r\n}\r\n} else if (likely( new_length > rl->vcn)) {\r\nntfs_debug("Expanding runlist.");\r\nif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\r\n(rl - 1)->length = new_length - (rl - 1)->vcn;\r\nelse {\r\nold_size = rl - runlist->rl + 1;\r\nrl = ntfs_rl_realloc(runlist->rl, old_size,\r\nold_size + 1);\r\nif (IS_ERR(rl)) {\r\nntfs_error(vol->sb, "Failed to expand runlist "\r\n"buffer, aborting.");\r\nreturn PTR_ERR(rl);\r\n}\r\nrunlist->rl = rl;\r\nrl += old_size - 1;\r\nrl->lcn = LCN_HOLE;\r\nrl->length = new_length - rl->vcn;\r\nrl++;\r\nrl->length = 0;\r\n}\r\nrl->vcn = new_length;\r\nrl->lcn = LCN_ENOENT;\r\n} else {\r\nrl->lcn = LCN_ENOENT;\r\n}\r\nntfs_debug("Done.");\r\nreturn 0;\r\n}\r\nint ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\r\nconst VCN start, const s64 length)\r\n{\r\nconst VCN end = start + length;\r\ns64 delta;\r\nrunlist_element *rl, *rl_end, *rl_real_end, *trl;\r\nint old_size;\r\nbool lcn_fixup = false;\r\nntfs_debug("Entering for start 0x%llx, length 0x%llx.",\r\n(long long)start, (long long)length);\r\nBUG_ON(!runlist);\r\nBUG_ON(start < 0);\r\nBUG_ON(length < 0);\r\nBUG_ON(end < 0);\r\nrl = runlist->rl;\r\nif (unlikely(!rl)) {\r\nif (likely(!start && !length))\r\nreturn 0;\r\nreturn -ENOENT;\r\n}\r\nwhile (likely(rl->length && start >= rl[1].vcn))\r\nrl++;\r\nrl_end = rl;\r\nwhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\r\nif (unlikely(rl_end->lcn < LCN_HOLE))\r\nreturn -EINVAL;\r\nrl_end++;\r\n}\r\nif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\r\nreturn -EINVAL;\r\nif (!rl_end->length && end > rl_end->vcn)\r\nreturn -ENOENT;\r\nif (!length)\r\nreturn 0;\r\nif (!rl->length)\r\nreturn -ENOENT;\r\nrl_real_end = rl_end;\r\nwhile (likely(rl_real_end->length))\r\nrl_real_end++;\r\nold_size = rl_real_end - runlist->rl + 1;\r\nif (rl->lcn == LCN_HOLE) {\r\nif (end <= rl[1].vcn) {\r\nntfs_debug("Done (requested hole is already sparse).");\r\nreturn 0;\r\n}\r\nextend_hole:\r\nrl->length = end - rl->vcn;\r\nif (rl_end->lcn == LCN_HOLE) {\r\nrl_end++;\r\nrl->length = rl_end->vcn - rl->vcn;\r\n}\r\nrl++;\r\nif (rl < rl_end)\r\nmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\r\nsizeof(*rl));\r\nif (end > rl->vcn) {\r\ndelta = end - rl->vcn;\r\nrl->vcn = end;\r\nrl->length -= delta;\r\nif (rl->lcn >= 0)\r\nrl->lcn += delta;\r\n}\r\nshrink_allocation:\r\nif (rl < rl_end) {\r\nrl = ntfs_rl_realloc(runlist->rl, old_size,\r\nold_size - (rl_end - rl));\r\nif (IS_ERR(rl))\r\nntfs_warning(vol->sb, "Failed to shrink "\r\n"runlist buffer. This just "\r\n"wastes a bit of memory "\r\n"temporarily so we ignore it "\r\n"and return success.");\r\nelse\r\nrunlist->rl = rl;\r\n}\r\nntfs_debug("Done (extend hole).");\r\nreturn 0;\r\n}\r\nif (start == rl->vcn) {\r\nif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\r\nrl--;\r\ngoto extend_hole;\r\n}\r\nif (end >= rl[1].vcn) {\r\nrl->lcn = LCN_HOLE;\r\ngoto extend_hole;\r\n}\r\ntrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\r\nif (IS_ERR(trl))\r\ngoto enomem_out;\r\nold_size++;\r\nif (runlist->rl != trl) {\r\nrl = trl + (rl - runlist->rl);\r\nrl_end = trl + (rl_end - runlist->rl);\r\nrl_real_end = trl + (rl_real_end - runlist->rl);\r\nrunlist->rl = trl;\r\n}\r\nsplit_end:\r\nmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\r\nrl->lcn = LCN_HOLE;\r\nrl->length = length;\r\nrl++;\r\nrl->vcn += length;\r\nif (rl->lcn >= 0 || lcn_fixup)\r\nrl->lcn += length;\r\nrl->length -= length;\r\nntfs_debug("Done (split one).");\r\nreturn 0;\r\n}\r\nif (rl_end->lcn == LCN_HOLE) {\r\nrl->length = start - rl->vcn;\r\nrl++;\r\nif (rl < rl_end)\r\nmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\r\nsizeof(*rl));\r\nrl->vcn = start;\r\nrl->length = rl[1].vcn - start;\r\ngoto shrink_allocation;\r\n}\r\nif (end >= rl[1].vcn) {\r\nif (rl[1].length && end >= rl[2].vcn) {\r\nrl->length = start - rl->vcn;\r\nrl++;\r\nrl->vcn = start;\r\nrl->lcn = LCN_HOLE;\r\ngoto extend_hole;\r\n}\r\ntrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\r\nif (IS_ERR(trl))\r\ngoto enomem_out;\r\nold_size++;\r\nif (runlist->rl != trl) {\r\nrl = trl + (rl - runlist->rl);\r\nrl_end = trl + (rl_end - runlist->rl);\r\nrl_real_end = trl + (rl_real_end - runlist->rl);\r\nrunlist->rl = trl;\r\n}\r\nrl->length = start - rl->vcn;\r\nrl++;\r\ndelta = rl->vcn - start;\r\nrl->vcn = start;\r\nif (rl->lcn >= 0) {\r\nrl->lcn -= delta;\r\nlcn_fixup = true;\r\n}\r\nrl->length += delta;\r\ngoto split_end;\r\n}\r\ntrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\r\nif (IS_ERR(trl))\r\ngoto enomem_out;\r\nold_size += 2;\r\nif (runlist->rl != trl) {\r\nrl = trl + (rl - runlist->rl);\r\nrl_end = trl + (rl_end - runlist->rl);\r\nrl_real_end = trl + (rl_real_end - runlist->rl);\r\nrunlist->rl = trl;\r\n}\r\nmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\r\nrl->length = start - rl->vcn;\r\nrl++;\r\nrl->vcn = start;\r\nrl->lcn = LCN_HOLE;\r\nrl->length = length;\r\nrl++;\r\ndelta = end - rl->vcn;\r\nrl->vcn = end;\r\nrl->lcn += delta;\r\nrl->length -= delta;\r\nntfs_debug("Done (split both).");\r\nreturn 0;\r\nenomem_out:\r\nntfs_error(vol->sb, "Not enough memory to extend runlist buffer.");\r\nreturn -ENOMEM;\r\n}
