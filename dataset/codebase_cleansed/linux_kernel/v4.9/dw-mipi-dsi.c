static int max_mbps_to_testdin(unsigned int max_mbps)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dptdin_map); i++)\r\nif (dptdin_map[i].max_mbps > max_mbps)\r\nreturn dptdin_map[i].testdin;\r\nreturn -EINVAL;\r\n}\r\nstatic void dw_mipi_dsi_wait_for_two_frames(struct dw_mipi_dsi *dsi)\r\n{\r\nint refresh, two_frames;\r\nrefresh = drm_mode_vrefresh(dsi->mode);\r\ntwo_frames = DIV_ROUND_UP(MSEC_PER_SEC, refresh) * 2;\r\nmsleep(two_frames);\r\n}\r\nstatic inline struct dw_mipi_dsi *host_to_dsi(struct mipi_dsi_host *host)\r\n{\r\nreturn container_of(host, struct dw_mipi_dsi, dsi_host);\r\n}\r\nstatic inline struct dw_mipi_dsi *con_to_dsi(struct drm_connector *con)\r\n{\r\nreturn container_of(con, struct dw_mipi_dsi, connector);\r\n}\r\nstatic inline struct dw_mipi_dsi *encoder_to_dsi(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct dw_mipi_dsi, encoder);\r\n}\r\nstatic inline void dsi_write(struct dw_mipi_dsi *dsi, u32 reg, u32 val)\r\n{\r\nwritel(val, dsi->base + reg);\r\n}\r\nstatic inline u32 dsi_read(struct dw_mipi_dsi *dsi, u32 reg)\r\n{\r\nreturn readl(dsi->base + reg);\r\n}\r\nstatic void dw_mipi_dsi_phy_write(struct dw_mipi_dsi *dsi, u8 test_code,\r\nu8 test_data)\r\n{\r\ndsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLK | PHY_UNTESTCLR);\r\ndsi_write(dsi, DSI_PHY_TST_CTRL1, PHY_TESTEN | PHY_TESTDOUT(0) |\r\nPHY_TESTDIN(test_code));\r\ndsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_UNTESTCLK | PHY_UNTESTCLR);\r\ndsi_write(dsi, DSI_PHY_TST_CTRL1, PHY_UNTESTEN | PHY_TESTDOUT(0) |\r\nPHY_TESTDIN(test_data));\r\ndsi_write(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLK | PHY_UNTESTCLR);\r\n}\r\nstatic int dw_mipi_dsi_phy_init(struct dw_mipi_dsi *dsi)\r\n{\r\nint ret, testdin, vco, val;\r\nvco = (dsi->lane_mbps < 200) ? 0 : (dsi->lane_mbps + 100) / 200;\r\ntestdin = max_mbps_to_testdin(dsi->lane_mbps);\r\nif (testdin < 0) {\r\ndev_err(dsi->dev,\r\n"failed to get testdin for %dmbps lane clock\n",\r\ndsi->lane_mbps);\r\nreturn testdin;\r\n}\r\ndsi_write(dsi, DSI_PWR_UP, POWERUP);\r\ndw_mipi_dsi_phy_write(dsi, 0x10, BYPASS_VCO_RANGE |\r\nVCO_RANGE_CON_SEL(vco) |\r\nVCO_IN_CAP_CON_LOW |\r\nREF_BIAS_CUR_SEL);\r\ndw_mipi_dsi_phy_write(dsi, 0x11, CP_CURRENT_3MA);\r\ndw_mipi_dsi_phy_write(dsi, 0x12, CP_PROGRAM_EN | LPF_PROGRAM_EN |\r\nLPF_RESISTORS_20_KOHM);\r\ndw_mipi_dsi_phy_write(dsi, 0x44, HSFREQRANGE_SEL(testdin));\r\ndw_mipi_dsi_phy_write(dsi, 0x19, PLL_LOOP_DIV_EN | PLL_INPUT_DIV_EN);\r\ndw_mipi_dsi_phy_write(dsi, 0x17, INPUT_DIVIDER(dsi->input_div));\r\ndw_mipi_dsi_phy_write(dsi, 0x18, LOOP_DIV_LOW_SEL(dsi->feedback_div) |\r\nLOW_PROGRAM_EN);\r\ndw_mipi_dsi_phy_write(dsi, 0x18, LOOP_DIV_HIGH_SEL(dsi->feedback_div) |\r\nHIGH_PROGRAM_EN);\r\ndw_mipi_dsi_phy_write(dsi, 0x20, POWER_CONTROL | INTERNAL_REG_CURRENT |\r\nBIAS_BLOCK_ON | BANDGAP_ON);\r\ndw_mipi_dsi_phy_write(dsi, 0x21, TER_RESISTOR_LOW | TER_CAL_DONE |\r\nSETRD_MAX | TER_RESISTORS_ON);\r\ndw_mipi_dsi_phy_write(dsi, 0x21, TER_RESISTOR_HIGH | LEVEL_SHIFTERS_ON |\r\nSETRD_MAX | POWER_MANAGE |\r\nTER_RESISTORS_ON);\r\ndw_mipi_dsi_phy_write(dsi, 0x22, LOW_PROGRAM_EN |\r\nBIASEXTR_SEL(BIASEXTR_127_7));\r\ndw_mipi_dsi_phy_write(dsi, 0x22, HIGH_PROGRAM_EN |\r\nBANDGAP_SEL(BANDGAP_96_10));\r\ndw_mipi_dsi_phy_write(dsi, 0x70, TLP_PROGRAM_EN | 0xf);\r\ndw_mipi_dsi_phy_write(dsi, 0x71, THS_PRE_PROGRAM_EN | 0x55);\r\ndw_mipi_dsi_phy_write(dsi, 0x72, THS_ZERO_PROGRAM_EN | 0xa);\r\ndsi_write(dsi, DSI_PHY_RSTZ, PHY_ENFORCEPLL | PHY_ENABLECLK |\r\nPHY_UNRSTZ | PHY_UNSHUTDOWNZ);\r\nret = readx_poll_timeout(readl, dsi->base + DSI_PHY_STATUS,\r\nval, val & LOCK, 1000, PHY_STATUS_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "failed to wait for phy lock state\n");\r\nreturn ret;\r\n}\r\nret = readx_poll_timeout(readl, dsi->base + DSI_PHY_STATUS,\r\nval, val & STOP_STATE_CLK_LANE, 1000,\r\nPHY_STATUS_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(dsi->dev,\r\n"failed to wait for phy clk lane stop state\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw_mipi_dsi_get_lane_bps(struct dw_mipi_dsi *dsi)\r\n{\r\nunsigned int i, pre;\r\nunsigned long mpclk, pllref, tmp;\r\nunsigned int m = 1, n = 1, target_mbps = 1000;\r\nunsigned int max_mbps = dptdin_map[ARRAY_SIZE(dptdin_map) - 1].max_mbps;\r\nint bpp;\r\nbpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\r\nif (bpp < 0) {\r\ndev_err(dsi->dev, "failed to get bpp for pixel format %d\n",\r\ndsi->format);\r\nreturn bpp;\r\n}\r\nmpclk = DIV_ROUND_UP(dsi->mode->clock, MSEC_PER_SEC);\r\nif (mpclk) {\r\ntmp = mpclk * (bpp / dsi->lanes) * 10 / 9;\r\nif (tmp < max_mbps)\r\ntarget_mbps = tmp;\r\nelse\r\ndev_err(dsi->dev, "DPHY clock frequency is out of range\n");\r\n}\r\npllref = DIV_ROUND_UP(clk_get_rate(dsi->pllref_clk), USEC_PER_SEC);\r\ntmp = pllref;\r\nfor (i = 1; i < 6; i++) {\r\npre = pllref / i;\r\nif ((tmp > (target_mbps % pre)) && (target_mbps / pre < 512)) {\r\ntmp = target_mbps % pre;\r\nn = i;\r\nm = target_mbps / pre;\r\n}\r\nif (tmp == 0)\r\nbreak;\r\n}\r\ndsi->lane_mbps = pllref / n * m;\r\ndsi->input_div = n;\r\ndsi->feedback_div = m;\r\nreturn 0;\r\n}\r\nstatic int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *device)\r\n{\r\nstruct dw_mipi_dsi *dsi = host_to_dsi(host);\r\nif (device->lanes > dsi->pdata->max_data_lanes) {\r\ndev_err(dsi->dev, "the number of data lanes(%u) is too many\n",\r\ndevice->lanes);\r\nreturn -EINVAL;\r\n}\r\nif (!(device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) ||\r\n!(device->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)) {\r\ndev_err(dsi->dev, "device mode is unsupported\n");\r\nreturn -EINVAL;\r\n}\r\ndsi->lanes = device->lanes;\r\ndsi->channel = device->channel;\r\ndsi->format = device->format;\r\ndsi->panel = of_drm_find_panel(device->dev.of_node);\r\nif (dsi->panel)\r\nreturn drm_panel_attach(dsi->panel, &dsi->connector);\r\nreturn -EINVAL;\r\n}\r\nstatic int dw_mipi_dsi_host_detach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *device)\r\n{\r\nstruct dw_mipi_dsi *dsi = host_to_dsi(host);\r\ndrm_panel_detach(dsi->panel);\r\nreturn 0;\r\n}\r\nstatic int dw_mipi_dsi_gen_pkt_hdr_write(struct dw_mipi_dsi *dsi, u32 val)\r\n{\r\nint ret;\r\nret = readx_poll_timeout(readl, dsi->base + DSI_CMD_PKT_STATUS,\r\nval, !(val & GEN_CMD_FULL), 1000,\r\nCMD_PKT_STATUS_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "failed to get available command FIFO\n");\r\nreturn ret;\r\n}\r\ndsi_write(dsi, DSI_GEN_HDR, val);\r\nret = readx_poll_timeout(readl, dsi->base + DSI_CMD_PKT_STATUS,\r\nval, val & (GEN_CMD_EMPTY | GEN_PLD_W_EMPTY),\r\n1000, CMD_PKT_STATUS_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "failed to write command FIFO\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_mipi_dsi_dcs_short_write(struct dw_mipi_dsi *dsi,\r\nconst struct mipi_dsi_msg *msg)\r\n{\r\nconst u16 *tx_buf = msg->tx_buf;\r\nu32 val = GEN_HDATA(*tx_buf) | GEN_HTYPE(msg->type);\r\nif (msg->tx_len > 2) {\r\ndev_err(dsi->dev, "too long tx buf length %zu for short write\n",\r\nmsg->tx_len);\r\nreturn -EINVAL;\r\n}\r\nreturn dw_mipi_dsi_gen_pkt_hdr_write(dsi, val);\r\n}\r\nstatic int dw_mipi_dsi_dcs_long_write(struct dw_mipi_dsi *dsi,\r\nconst struct mipi_dsi_msg *msg)\r\n{\r\nconst u32 *tx_buf = msg->tx_buf;\r\nint len = msg->tx_len, pld_data_bytes = sizeof(*tx_buf), ret;\r\nu32 val = GEN_HDATA(msg->tx_len) | GEN_HTYPE(msg->type);\r\nu32 remainder = 0;\r\nif (msg->tx_len < 3) {\r\ndev_err(dsi->dev, "wrong tx buf length %zu for long write\n",\r\nmsg->tx_len);\r\nreturn -EINVAL;\r\n}\r\nwhile (DIV_ROUND_UP(len, pld_data_bytes)) {\r\nif (len < pld_data_bytes) {\r\nmemcpy(&remainder, tx_buf, len);\r\ndsi_write(dsi, DSI_GEN_PLD_DATA, remainder);\r\nlen = 0;\r\n} else {\r\ndsi_write(dsi, DSI_GEN_PLD_DATA, *tx_buf);\r\ntx_buf++;\r\nlen -= pld_data_bytes;\r\n}\r\nret = readx_poll_timeout(readl, dsi->base + DSI_CMD_PKT_STATUS,\r\nval, !(val & GEN_PLD_W_FULL), 1000,\r\nCMD_PKT_STATUS_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(dsi->dev,\r\n"failed to get available write payload FIFO\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn dw_mipi_dsi_gen_pkt_hdr_write(dsi, val);\r\n}\r\nstatic ssize_t dw_mipi_dsi_host_transfer(struct mipi_dsi_host *host,\r\nconst struct mipi_dsi_msg *msg)\r\n{\r\nstruct dw_mipi_dsi *dsi = host_to_dsi(host);\r\nint ret;\r\nswitch (msg->type) {\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:\r\nret = dw_mipi_dsi_dcs_short_write(dsi, msg);\r\nbreak;\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\nret = dw_mipi_dsi_dcs_long_write(dsi, msg);\r\nbreak;\r\ndefault:\r\ndev_err(dsi->dev, "unsupported message type\n");\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dw_mipi_dsi_video_mode_config(struct dw_mipi_dsi *dsi)\r\n{\r\nu32 val;\r\nval = VID_MODE_TYPE_BURST_SYNC_PULSES | ENABLE_LOW_POWER;\r\ndsi_write(dsi, DSI_VID_MODE_CFG, val);\r\n}\r\nstatic void dw_mipi_dsi_set_mode(struct dw_mipi_dsi *dsi,\r\nenum dw_mipi_dsi_mode mode)\r\n{\r\nif (mode == DW_MIPI_DSI_CMD_MODE) {\r\ndsi_write(dsi, DSI_PWR_UP, RESET);\r\ndsi_write(dsi, DSI_MODE_CFG, ENABLE_CMD_MODE);\r\ndsi_write(dsi, DSI_PWR_UP, POWERUP);\r\n} else {\r\ndsi_write(dsi, DSI_PWR_UP, RESET);\r\ndsi_write(dsi, DSI_MODE_CFG, ENABLE_VIDEO_MODE);\r\ndw_mipi_dsi_video_mode_config(dsi);\r\ndsi_write(dsi, DSI_PWR_UP, POWERUP);\r\n}\r\n}\r\nstatic void dw_mipi_dsi_disable(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_PWR_UP, RESET);\r\ndsi_write(dsi, DSI_PHY_RSTZ, PHY_RSTZ);\r\n}\r\nstatic void dw_mipi_dsi_init(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_PWR_UP, RESET);\r\ndsi_write(dsi, DSI_PHY_RSTZ, PHY_DISFORCEPLL | PHY_DISABLECLK\r\n| PHY_RSTZ | PHY_SHUTDOWNZ);\r\ndsi_write(dsi, DSI_CLKMGR_CFG, TO_CLK_DIVIDSION(10) |\r\nTX_ESC_CLK_DIVIDSION(7));\r\ndsi_write(dsi, DSI_LPCLK_CTRL, PHY_TXREQUESTCLKHS);\r\n}\r\nstatic void dw_mipi_dsi_dpi_config(struct dw_mipi_dsi *dsi,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 val = 0, color = 0;\r\nswitch (dsi->format) {\r\ncase MIPI_DSI_FMT_RGB888:\r\ncolor = DPI_COLOR_CODING_24BIT;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB666:\r\ncolor = DPI_COLOR_CODING_18BIT_2 | EN18_LOOSELY;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB666_PACKED:\r\ncolor = DPI_COLOR_CODING_18BIT_1;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB565:\r\ncolor = DPI_COLOR_CODING_16BIT_1;\r\nbreak;\r\n}\r\nif (!(mode->flags & DRM_MODE_FLAG_PVSYNC))\r\nval |= VSYNC_ACTIVE_LOW;\r\nif (!(mode->flags & DRM_MODE_FLAG_PHSYNC))\r\nval |= HSYNC_ACTIVE_LOW;\r\ndsi_write(dsi, DSI_DPI_VCID, DPI_VID(dsi->channel));\r\ndsi_write(dsi, DSI_DPI_COLOR_CODING, color);\r\ndsi_write(dsi, DSI_DPI_CFG_POL, val);\r\ndsi_write(dsi, DSI_DPI_LP_CMD_TIM, OUTVACT_LPCMD_TIME(4)\r\n| INVACT_LPCMD_TIME(4));\r\n}\r\nstatic void dw_mipi_dsi_packet_handler_config(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_PCKHDL_CFG, EN_CRC_RX | EN_ECC_RX | EN_BTA);\r\n}\r\nstatic void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,\r\nstruct drm_display_mode *mode)\r\n{\r\ndsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(mode->hdisplay));\r\n}\r\nstatic void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));\r\ndsi_write(dsi, DSI_BTA_TO_CNT, 0xd00);\r\ndsi_write(dsi, DSI_CMD_MODE_CFG, CMD_MODE_ALL_LP);\r\ndsi_write(dsi, DSI_MODE_CFG, ENABLE_CMD_MODE);\r\n}\r\nstatic u32 dw_mipi_dsi_get_hcomponent_lbcc(struct dw_mipi_dsi *dsi,\r\nu32 hcomponent)\r\n{\r\nu32 frac, lbcc;\r\nlbcc = hcomponent * dsi->lane_mbps * MSEC_PER_SEC / 8;\r\nfrac = lbcc % dsi->mode->clock;\r\nlbcc = lbcc / dsi->mode->clock;\r\nif (frac)\r\nlbcc++;\r\nreturn lbcc;\r\n}\r\nstatic void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi)\r\n{\r\nu32 htotal, hsa, hbp, lbcc;\r\nstruct drm_display_mode *mode = dsi->mode;\r\nhtotal = mode->htotal;\r\nhsa = mode->hsync_end - mode->hsync_start;\r\nhbp = mode->htotal - mode->hsync_end;\r\nlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, htotal);\r\ndsi_write(dsi, DSI_VID_HLINE_TIME, lbcc);\r\nlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, hsa);\r\ndsi_write(dsi, DSI_VID_HSA_TIME, lbcc);\r\nlbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, hbp);\r\ndsi_write(dsi, DSI_VID_HBP_TIME, lbcc);\r\n}\r\nstatic void dw_mipi_dsi_vertical_timing_config(struct dw_mipi_dsi *dsi)\r\n{\r\nu32 vactive, vsa, vfp, vbp;\r\nstruct drm_display_mode *mode = dsi->mode;\r\nvactive = mode->vdisplay;\r\nvsa = mode->vsync_end - mode->vsync_start;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvbp = mode->vtotal - mode->vsync_end;\r\ndsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);\r\ndsi_write(dsi, DSI_VID_VSA_LINES, vsa);\r\ndsi_write(dsi, DSI_VID_VFP_LINES, vfp);\r\ndsi_write(dsi, DSI_VID_VBP_LINES, vbp);\r\n}\r\nstatic void dw_mipi_dsi_dphy_timing_config(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_PHY_TMR_CFG, PHY_HS2LP_TIME(0x40)\r\n| PHY_LP2HS_TIME(0x40) | MAX_RD_TIME(10000));\r\ndsi_write(dsi, DSI_PHY_TMR_LPCLK_CFG, PHY_CLKHS2LP_TIME(0x40)\r\n| PHY_CLKLP2HS_TIME(0x40));\r\n}\r\nstatic void dw_mipi_dsi_dphy_interface_config(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_write(dsi, DSI_PHY_IF_CFG, PHY_STOP_WAIT_TIME(0x20) |\r\nN_LANES(dsi->lanes));\r\n}\r\nstatic void dw_mipi_dsi_clear_err(struct dw_mipi_dsi *dsi)\r\n{\r\ndsi_read(dsi, DSI_INT_ST0);\r\ndsi_read(dsi, DSI_INT_ST1);\r\ndsi_write(dsi, DSI_INT_MSK0, 0);\r\ndsi_write(dsi, DSI_INT_MSK1, 0);\r\n}\r\nstatic void dw_mipi_dsi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct dw_mipi_dsi *dsi = encoder_to_dsi(encoder);\r\nint ret;\r\ndsi->mode = adjusted_mode;\r\nret = dw_mipi_dsi_get_lane_bps(dsi);\r\nif (ret < 0)\r\nreturn;\r\nif (clk_prepare_enable(dsi->pclk)) {\r\ndev_err(dsi->dev, "%s: Failed to enable pclk\n", __func__);\r\nreturn;\r\n}\r\ndw_mipi_dsi_init(dsi);\r\ndw_mipi_dsi_dpi_config(dsi, mode);\r\ndw_mipi_dsi_packet_handler_config(dsi);\r\ndw_mipi_dsi_video_mode_config(dsi);\r\ndw_mipi_dsi_video_packet_config(dsi, mode);\r\ndw_mipi_dsi_command_mode_config(dsi);\r\ndw_mipi_dsi_line_timer_config(dsi);\r\ndw_mipi_dsi_vertical_timing_config(dsi);\r\ndw_mipi_dsi_dphy_timing_config(dsi);\r\ndw_mipi_dsi_dphy_interface_config(dsi);\r\ndw_mipi_dsi_clear_err(dsi);\r\nif (drm_panel_prepare(dsi->panel))\r\ndev_err(dsi->dev, "failed to prepare panel\n");\r\nclk_disable_unprepare(dsi->pclk);\r\n}\r\nstatic void dw_mipi_dsi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct dw_mipi_dsi *dsi = encoder_to_dsi(encoder);\r\ndrm_panel_disable(dsi->panel);\r\nif (clk_prepare_enable(dsi->pclk)) {\r\ndev_err(dsi->dev, "%s: Failed to enable pclk\n", __func__);\r\nreturn;\r\n}\r\ndw_mipi_dsi_set_mode(dsi, DW_MIPI_DSI_CMD_MODE);\r\ndrm_panel_unprepare(dsi->panel);\r\ndw_mipi_dsi_set_mode(dsi, DW_MIPI_DSI_VID_MODE);\r\nmsleep(120);\r\ndw_mipi_dsi_set_mode(dsi, DW_MIPI_DSI_CMD_MODE);\r\ndw_mipi_dsi_disable(dsi);\r\nclk_disable_unprepare(dsi->pclk);\r\n}\r\nstatic void dw_mipi_dsi_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct dw_mipi_dsi *dsi = encoder_to_dsi(encoder);\r\nint mux = drm_of_encoder_active_endpoint_id(dsi->dev->of_node, encoder);\r\nu32 val;\r\nif (clk_prepare_enable(dsi->pclk)) {\r\ndev_err(dsi->dev, "%s: Failed to enable pclk\n", __func__);\r\nreturn;\r\n}\r\ndw_mipi_dsi_phy_init(dsi);\r\ndw_mipi_dsi_wait_for_two_frames(dsi);\r\ndw_mipi_dsi_set_mode(dsi, DW_MIPI_DSI_VID_MODE);\r\ndrm_panel_enable(dsi->panel);\r\nclk_disable_unprepare(dsi->pclk);\r\nif (mux)\r\nval = DSI0_SEL_VOP_LIT | (DSI0_SEL_VOP_LIT << 16);\r\nelse\r\nval = DSI0_SEL_VOP_LIT << 16;\r\nregmap_write(dsi->grf_regmap, GRF_SOC_CON6, val);\r\ndev_dbg(dsi->dev, "vop %s output to dsi0\n", (mux) ? "LIT" : "BIG");\r\n}\r\nstatic int\r\ndw_mipi_dsi_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\r\nstruct dw_mipi_dsi *dsi = encoder_to_dsi(encoder);\r\nswitch (dsi->format) {\r\ncase MIPI_DSI_FMT_RGB888:\r\ns->output_mode = ROCKCHIP_OUT_MODE_P888;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB666:\r\ns->output_mode = ROCKCHIP_OUT_MODE_P666;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB565:\r\ns->output_mode = ROCKCHIP_OUT_MODE_P565;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\ns->output_type = DRM_MODE_CONNECTOR_DSI;\r\nreturn 0;\r\n}\r\nstatic int dw_mipi_dsi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct dw_mipi_dsi *dsi = con_to_dsi(connector);\r\nreturn drm_panel_get_modes(dsi->panel);\r\n}\r\nstatic enum drm_mode_status dw_mipi_dsi_mode_valid(\r\nstruct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct dw_mipi_dsi *dsi = con_to_dsi(connector);\r\nenum drm_mode_status mode_status = MODE_OK;\r\nif (dsi->pdata->mode_valid)\r\nmode_status = dsi->pdata->mode_valid(connector, mode);\r\nreturn mode_status;\r\n}\r\nstatic enum drm_connector_status\r\ndw_mipi_dsi_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void dw_mipi_dsi_drm_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int dw_mipi_dsi_register(struct drm_device *drm,\r\nstruct dw_mipi_dsi *dsi)\r\n{\r\nstruct drm_encoder *encoder = &dsi->encoder;\r\nstruct drm_connector *connector = &dsi->connector;\r\nstruct device *dev = dsi->dev;\r\nint ret;\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm,\r\ndev->of_node);\r\nif (encoder->possible_crtcs == 0)\r\nreturn -EPROBE_DEFER;\r\ndrm_encoder_helper_add(&dsi->encoder,\r\n&dw_mipi_dsi_encoder_helper_funcs);\r\nret = drm_encoder_init(drm, &dsi->encoder, &dw_mipi_dsi_encoder_funcs,\r\nDRM_MODE_ENCODER_DSI, NULL);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize encoder with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector,\r\n&dw_mipi_dsi_connector_helper_funcs);\r\ndrm_connector_init(drm, &dsi->connector,\r\n&dw_mipi_dsi_atomic_connector_funcs,\r\nDRM_MODE_CONNECTOR_DSI);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic int rockchip_mipi_parse_dt(struct dw_mipi_dsi *dsi)\r\n{\r\nstruct device_node *np = dsi->dev->of_node;\r\ndsi->grf_regmap = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(dsi->grf_regmap)) {\r\ndev_err(dsi->dev, "Unable to get rockchip,grf\n");\r\nreturn PTR_ERR(dsi->grf_regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic enum drm_mode_status rk3288_mipi_dsi_mode_valid(\r\nstruct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->hdisplay > 0x7ff)\r\nreturn MODE_BAD_HVALUE;\r\nif (mode->vdisplay > 0x7ff)\r\nreturn MODE_BAD_VVALUE;\r\nreturn MODE_OK;\r\n}\r\nstatic int dw_mipi_dsi_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(dw_mipi_dsi_dt_ids, dev);\r\nconst struct dw_mipi_dsi_plat_data *pdata = of_id->data;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct dw_mipi_dsi *dsi;\r\nstruct resource *res;\r\nint ret;\r\ndsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\r\nif (!dsi)\r\nreturn -ENOMEM;\r\ndsi->dev = dev;\r\ndsi->pdata = pdata;\r\nret = rockchip_mipi_parse_dt(dsi);\r\nif (ret)\r\nreturn ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ndsi->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(dsi->base))\r\nreturn PTR_ERR(dsi->base);\r\ndsi->pllref_clk = devm_clk_get(dev, "ref");\r\nif (IS_ERR(dsi->pllref_clk)) {\r\nret = PTR_ERR(dsi->pllref_clk);\r\ndev_err(dev, "Unable to get pll reference clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndsi->pclk = devm_clk_get(dev, "pclk");\r\nif (IS_ERR(dsi->pclk)) {\r\nret = PTR_ERR(dsi->pclk);\r\ndev_err(dev, "Unable to get pclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(dsi->pllref_clk);\r\nif (ret) {\r\ndev_err(dev, "%s: Failed to enable pllref_clk\n", __func__);\r\nreturn ret;\r\n}\r\nret = dw_mipi_dsi_register(drm, dsi);\r\nif (ret) {\r\ndev_err(dev, "Failed to register mipi_dsi: %d\n", ret);\r\ngoto err_pllref;\r\n}\r\ndev_set_drvdata(dev, dsi);\r\ndsi->dsi_host.ops = &dw_mipi_dsi_host_ops;\r\ndsi->dsi_host.dev = dev;\r\nreturn mipi_dsi_host_register(&dsi->dsi_host);\r\nerr_pllref:\r\nclk_disable_unprepare(dsi->pllref_clk);\r\nreturn ret;\r\n}\r\nstatic void dw_mipi_dsi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct dw_mipi_dsi *dsi = dev_get_drvdata(dev);\r\nmipi_dsi_host_unregister(&dsi->dsi_host);\r\nclk_disable_unprepare(dsi->pllref_clk);\r\n}\r\nstatic int dw_mipi_dsi_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dw_mipi_dsi_ops);\r\n}\r\nstatic int dw_mipi_dsi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dw_mipi_dsi_ops);\r\nreturn 0;\r\n}
