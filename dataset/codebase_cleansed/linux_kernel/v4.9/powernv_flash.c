static int powernv_flash_async_op(struct mtd_info *mtd, enum flash_op op,\r\nloff_t offset, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct powernv_flash *info = (struct powernv_flash *)mtd->priv;\r\nstruct device *dev = &mtd->dev;\r\nint token;\r\nstruct opal_msg msg;\r\nint rc;\r\ndev_dbg(dev, "%s(op=%d, offset=0x%llx, len=%zu)\n",\r\n__func__, op, offset, len);\r\ntoken = opal_async_get_token_interruptible();\r\nif (token < 0) {\r\nif (token != -ERESTARTSYS)\r\ndev_err(dev, "Failed to get an async token\n");\r\nreturn token;\r\n}\r\nswitch (op) {\r\ncase FLASH_OP_READ:\r\nrc = opal_flash_read(info->id, offset, __pa(buf), len, token);\r\nbreak;\r\ncase FLASH_OP_WRITE:\r\nrc = opal_flash_write(info->id, offset, __pa(buf), len, token);\r\nbreak;\r\ncase FLASH_OP_ERASE:\r\nrc = opal_flash_erase(info->id, offset, len, token);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (rc != OPAL_ASYNC_COMPLETION) {\r\ndev_err(dev, "opal_flash_async_op(op=%d) failed (rc %d)\n",\r\nop, rc);\r\nopal_async_release_token(token);\r\nreturn -EIO;\r\n}\r\nrc = opal_async_wait_response(token, &msg);\r\nopal_async_release_token(token);\r\nif (rc) {\r\ndev_err(dev, "opal async wait failed (rc %d)\n", rc);\r\nreturn -EIO;\r\n}\r\nrc = opal_get_async_rc(msg);\r\nif (rc == OPAL_SUCCESS) {\r\nrc = 0;\r\nif (retlen)\r\n*retlen = len;\r\n} else {\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int powernv_flash_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nreturn powernv_flash_async_op(mtd, FLASH_OP_READ, from,\r\nlen, retlen, buf);\r\n}\r\nstatic int powernv_flash_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nreturn powernv_flash_async_op(mtd, FLASH_OP_WRITE, to,\r\nlen, retlen, (u_char *)buf);\r\n}\r\nstatic int powernv_flash_erase(struct mtd_info *mtd, struct erase_info *erase)\r\n{\r\nint rc;\r\nerase->state = MTD_ERASING;\r\nrc = powernv_flash_async_op(mtd, FLASH_OP_ERASE, erase->addr,\r\nerase->len, NULL, NULL);\r\nif (rc) {\r\nerase->fail_addr = erase->addr;\r\nerase->state = MTD_ERASE_FAILED;\r\n} else {\r\nerase->state = MTD_ERASE_DONE;\r\n}\r\nmtd_erase_callback(erase);\r\nreturn rc;\r\n}\r\nstatic int powernv_flash_set_driver_info(struct device *dev,\r\nstruct mtd_info *mtd)\r\n{\r\nu64 size;\r\nu32 erase_size;\r\nint rc;\r\nrc = of_property_read_u32(dev->of_node, "ibm,flash-block-size",\r\n&erase_size);\r\nif (rc) {\r\ndev_err(dev, "couldn't get resource block size information\n");\r\nreturn rc;\r\n}\r\nrc = of_property_read_u64(dev->of_node, "reg", &size);\r\nif (rc) {\r\ndev_err(dev, "couldn't get resource size information\n");\r\nreturn rc;\r\n}\r\nmtd->name = of_get_property(dev->of_node, "name", NULL);\r\nmtd->type = MTD_NORFLASH;\r\nmtd->flags = MTD_WRITEABLE;\r\nmtd->size = size;\r\nmtd->erasesize = erase_size;\r\nmtd->writebufsize = mtd->writesize = 1;\r\nmtd->owner = THIS_MODULE;\r\nmtd->_erase = powernv_flash_erase;\r\nmtd->_read = powernv_flash_read;\r\nmtd->_write = powernv_flash_write;\r\nmtd->dev.parent = dev;\r\nreturn 0;\r\n}\r\nstatic int powernv_flash_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct powernv_flash *data;\r\nint ret;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndata->mtd.priv = data;\r\nret = of_property_read_u32(dev->of_node, "ibm,opal-id", &(data->id));\r\nif (ret) {\r\ndev_err(dev, "no device property 'ibm,opal-id'\n");\r\ngoto out;\r\n}\r\nret = powernv_flash_set_driver_info(dev, &data->mtd);\r\nif (ret)\r\ngoto out;\r\ndev_set_drvdata(dev, data);\r\nret = mtd_device_register(&data->mtd, NULL, 0);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int powernv_flash_release(struct platform_device *pdev)\r\n{\r\nstruct powernv_flash *data = dev_get_drvdata(&(pdev->dev));\r\nreturn mtd_device_unregister(&(data->mtd));\r\n}
