static void lapb_state0_machine(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nswitch (frame->type) {\r\ncase LAPB_SABM:\r\nlapb_dbg(1, "(%p) S0 RX SABM(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S0 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n} else {\r\nlapb_dbg(1, "(%p) S0 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S0 -> S3\n", lapb->dev);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_3;\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_connect_indication(lapb, LAPB_OK);\r\n}\r\nbreak;\r\ncase LAPB_SABME:\r\nlapb_dbg(1, "(%p) S0 RX SABME(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S0 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S0 -> S3\n", lapb->dev);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_3;\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_connect_indication(lapb, LAPB_OK);\r\n} else {\r\nlapb_dbg(1, "(%p) S0 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n}\r\nbreak;\r\ncase LAPB_DISC:\r\nlapb_dbg(1, "(%p) S0 RX DISC(%d)\n", lapb->dev, frame->pf);\r\nlapb_dbg(1, "(%p) S0 TX UA(%d)\n", lapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void lapb_state1_machine(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nswitch (frame->type) {\r\ncase LAPB_SABM:\r\nlapb_dbg(1, "(%p) S1 RX SABM(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S1 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n} else {\r\nlapb_dbg(1, "(%p) S1 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\n}\r\nbreak;\r\ncase LAPB_SABME:\r\nlapb_dbg(1, "(%p) S1 RX SABME(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S1 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\n} else {\r\nlapb_dbg(1, "(%p) S1 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n}\r\nbreak;\r\ncase LAPB_DISC:\r\nlapb_dbg(1, "(%p) S1 RX DISC(%d)\n", lapb->dev, frame->pf);\r\nlapb_dbg(1, "(%p) S1 TX DM(%d)\n", lapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf, LAPB_RESPONSE);\r\nbreak;\r\ncase LAPB_UA:\r\nlapb_dbg(1, "(%p) S1 RX UA(%d)\n", lapb->dev, frame->pf);\r\nif (frame->pf) {\r\nlapb_dbg(0, "(%p) S1 -> S3\n", lapb->dev);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_3;\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_connect_confirmation(lapb, LAPB_OK);\r\n}\r\nbreak;\r\ncase LAPB_DM:\r\nlapb_dbg(1, "(%p) S1 RX DM(%d)\n", lapb->dev, frame->pf);\r\nif (frame->pf) {\r\nlapb_dbg(0, "(%p) S1 -> S0\n", lapb->dev);\r\nlapb_clear_queues(lapb);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb_disconnect_indication(lapb, LAPB_REFUSED);\r\n}\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void lapb_state2_machine(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nswitch (frame->type) {\r\ncase LAPB_SABM:\r\ncase LAPB_SABME:\r\nlapb_dbg(1, "(%p) S2 RX {SABM,SABME}(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(1, "(%p) S2 TX DM(%d)\n", lapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf, LAPB_RESPONSE);\r\nbreak;\r\ncase LAPB_DISC:\r\nlapb_dbg(1, "(%p) S2 RX DISC(%d)\n", lapb->dev, frame->pf);\r\nlapb_dbg(1, "(%p) S2 TX UA(%d)\n", lapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\r\nbreak;\r\ncase LAPB_UA:\r\nlapb_dbg(1, "(%p) S2 RX UA(%d)\n", lapb->dev, frame->pf);\r\nif (frame->pf) {\r\nlapb_dbg(0, "(%p) S2 -> S0\n", lapb->dev);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb_disconnect_confirmation(lapb, LAPB_OK);\r\n}\r\nbreak;\r\ncase LAPB_DM:\r\nlapb_dbg(1, "(%p) S2 RX DM(%d)\n", lapb->dev, frame->pf);\r\nif (frame->pf) {\r\nlapb_dbg(0, "(%p) S2 -> S0\n", lapb->dev);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb_disconnect_confirmation(lapb, LAPB_NOTCONNECTED);\r\n}\r\nbreak;\r\ncase LAPB_I:\r\ncase LAPB_REJ:\r\ncase LAPB_RNR:\r\ncase LAPB_RR:\r\nlapb_dbg(1, "(%p) S2 RX {I,REJ,RNR,RR}(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(1, "(%p) S2 RX DM(%d)\n", lapb->dev, frame->pf);\r\nif (frame->pf)\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void lapb_state3_machine(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nint queued = 0;\r\nint modulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS :\r\nLAPB_SMODULUS;\r\nswitch (frame->type) {\r\ncase LAPB_SABM:\r\nlapb_dbg(1, "(%p) S3 RX SABM(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S3 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n} else {\r\nlapb_dbg(1, "(%p) S3 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_requeue_frames(lapb);\r\n}\r\nbreak;\r\ncase LAPB_SABME:\r\nlapb_dbg(1, "(%p) S3 RX SABME(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S3 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_requeue_frames(lapb);\r\n} else {\r\nlapb_dbg(1, "(%p) S3 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n}\r\nbreak;\r\ncase LAPB_DISC:\r\nlapb_dbg(1, "(%p) S3 RX DISC(%d)\n", lapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S3 -> S0\n", lapb->dev);\r\nlapb_clear_queues(lapb);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_disconnect_indication(lapb, LAPB_OK);\r\nbreak;\r\ncase LAPB_DM:\r\nlapb_dbg(1, "(%p) S3 RX DM(%d)\n", lapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S3 -> S0\n", lapb->dev);\r\nlapb_clear_queues(lapb);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb_disconnect_indication(lapb, LAPB_NOTCONNECTED);\r\nbreak;\r\ncase LAPB_RNR:\r\nlapb_dbg(1, "(%p) S3 RX RNR(%d) R%d\n",\r\nlapb->dev, frame->pf, frame->nr);\r\nlapb->condition |= LAPB_PEER_RX_BUSY_CONDITION;\r\nlapb_check_need_response(lapb, frame->cr, frame->pf);\r\nif (lapb_validate_nr(lapb, frame->nr)) {\r\nlapb_check_iframes_acked(lapb, frame->nr);\r\n} else {\r\nlapb->frmr_data = *frame;\r\nlapb->frmr_type = LAPB_FRMR_Z;\r\nlapb_transmit_frmr(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S4\n", lapb->dev);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_4;\r\nlapb->n2count = 0;\r\n}\r\nbreak;\r\ncase LAPB_RR:\r\nlapb_dbg(1, "(%p) S3 RX RR(%d) R%d\n",\r\nlapb->dev, frame->pf, frame->nr);\r\nlapb->condition &= ~LAPB_PEER_RX_BUSY_CONDITION;\r\nlapb_check_need_response(lapb, frame->cr, frame->pf);\r\nif (lapb_validate_nr(lapb, frame->nr)) {\r\nlapb_check_iframes_acked(lapb, frame->nr);\r\n} else {\r\nlapb->frmr_data = *frame;\r\nlapb->frmr_type = LAPB_FRMR_Z;\r\nlapb_transmit_frmr(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S4\n", lapb->dev);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_4;\r\nlapb->n2count = 0;\r\n}\r\nbreak;\r\ncase LAPB_REJ:\r\nlapb_dbg(1, "(%p) S3 RX REJ(%d) R%d\n",\r\nlapb->dev, frame->pf, frame->nr);\r\nlapb->condition &= ~LAPB_PEER_RX_BUSY_CONDITION;\r\nlapb_check_need_response(lapb, frame->cr, frame->pf);\r\nif (lapb_validate_nr(lapb, frame->nr)) {\r\nlapb_frames_acked(lapb, frame->nr);\r\nlapb_stop_t1timer(lapb);\r\nlapb->n2count = 0;\r\nlapb_requeue_frames(lapb);\r\n} else {\r\nlapb->frmr_data = *frame;\r\nlapb->frmr_type = LAPB_FRMR_Z;\r\nlapb_transmit_frmr(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S4\n", lapb->dev);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_4;\r\nlapb->n2count = 0;\r\n}\r\nbreak;\r\ncase LAPB_I:\r\nlapb_dbg(1, "(%p) S3 RX I(%d) S%d R%d\n",\r\nlapb->dev, frame->pf, frame->ns, frame->nr);\r\nif (!lapb_validate_nr(lapb, frame->nr)) {\r\nlapb->frmr_data = *frame;\r\nlapb->frmr_type = LAPB_FRMR_Z;\r\nlapb_transmit_frmr(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S4\n", lapb->dev);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_4;\r\nlapb->n2count = 0;\r\nbreak;\r\n}\r\nif (lapb->condition & LAPB_PEER_RX_BUSY_CONDITION)\r\nlapb_frames_acked(lapb, frame->nr);\r\nelse\r\nlapb_check_iframes_acked(lapb, frame->nr);\r\nif (frame->ns == lapb->vr) {\r\nint cn;\r\ncn = lapb_data_indication(lapb, skb);\r\nqueued = 1;\r\nif (cn == NET_RX_DROP) {\r\npr_debug("rx congestion\n");\r\nbreak;\r\n}\r\nlapb->vr = (lapb->vr + 1) % modulus;\r\nlapb->condition &= ~LAPB_REJECT_CONDITION;\r\nif (frame->pf)\r\nlapb_enquiry_response(lapb);\r\nelse {\r\nif (!(lapb->condition &\r\nLAPB_ACK_PENDING_CONDITION)) {\r\nlapb->condition |= LAPB_ACK_PENDING_CONDITION;\r\nlapb_start_t2timer(lapb);\r\n}\r\n}\r\n} else {\r\nif (lapb->condition & LAPB_REJECT_CONDITION) {\r\nif (frame->pf)\r\nlapb_enquiry_response(lapb);\r\n} else {\r\nlapb_dbg(1, "(%p) S3 TX REJ(%d) R%d\n",\r\nlapb->dev, frame->pf, lapb->vr);\r\nlapb->condition |= LAPB_REJECT_CONDITION;\r\nlapb_send_control(lapb, LAPB_REJ, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\r\n}\r\n}\r\nbreak;\r\ncase LAPB_FRMR:\r\nlapb_dbg(1, "(%p) S3 RX FRMR(%d) %5ph\n",\r\nlapb->dev, frame->pf,\r\nskb->data);\r\nlapb_establish_data_link(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S1\n", lapb->dev);\r\nlapb_requeue_frames(lapb);\r\nlapb->state = LAPB_STATE_1;\r\nbreak;\r\ncase LAPB_ILLEGAL:\r\nlapb_dbg(1, "(%p) S3 RX ILLEGAL(%d)\n", lapb->dev, frame->pf);\r\nlapb->frmr_data = *frame;\r\nlapb->frmr_type = LAPB_FRMR_W;\r\nlapb_transmit_frmr(lapb);\r\nlapb_dbg(0, "(%p) S3 -> S4\n", lapb->dev);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_4;\r\nlapb->n2count = 0;\r\nbreak;\r\n}\r\nif (!queued)\r\nkfree_skb(skb);\r\n}\r\nstatic void lapb_state4_machine(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nswitch (frame->type) {\r\ncase LAPB_SABM:\r\nlapb_dbg(1, "(%p) S4 RX SABM(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S4 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n} else {\r\nlapb_dbg(1, "(%p) S4 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S4 -> S3\n", lapb->dev);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_3;\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_connect_indication(lapb, LAPB_OK);\r\n}\r\nbreak;\r\ncase LAPB_SABME:\r\nlapb_dbg(1, "(%p) S4 RX SABME(%d)\n", lapb->dev, frame->pf);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nlapb_dbg(1, "(%p) S4 TX UA(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_dbg(0, "(%p) S4 -> S3\n", lapb->dev);\r\nlapb_send_control(lapb, LAPB_UA, frame->pf,\r\nLAPB_RESPONSE);\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_3;\r\nlapb->condition = 0x00;\r\nlapb->n2count = 0;\r\nlapb->vs = 0;\r\nlapb->vr = 0;\r\nlapb->va = 0;\r\nlapb_connect_indication(lapb, LAPB_OK);\r\n} else {\r\nlapb_dbg(1, "(%p) S4 TX DM(%d)\n",\r\nlapb->dev, frame->pf);\r\nlapb_send_control(lapb, LAPB_DM, frame->pf,\r\nLAPB_RESPONSE);\r\n}\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n}\r\nvoid lapb_data_input(struct lapb_cb *lapb, struct sk_buff *skb)\r\n{\r\nstruct lapb_frame frame;\r\nif (lapb_decode(lapb, skb, &frame) < 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nswitch (lapb->state) {\r\ncase LAPB_STATE_0:\r\nlapb_state0_machine(lapb, skb, &frame); break;\r\ncase LAPB_STATE_1:\r\nlapb_state1_machine(lapb, skb, &frame); break;\r\ncase LAPB_STATE_2:\r\nlapb_state2_machine(lapb, skb, &frame); break;\r\ncase LAPB_STATE_3:\r\nlapb_state3_machine(lapb, skb, &frame); break;\r\ncase LAPB_STATE_4:\r\nlapb_state4_machine(lapb, skb, &frame); break;\r\n}\r\nlapb_kick(lapb);\r\n}
