static int convert_prio(int prio)\r\n{\r\nint cpupri;\r\nif (prio == CPUPRI_INVALID)\r\ncpupri = CPUPRI_INVALID;\r\nelse if (prio == MAX_PRIO)\r\ncpupri = CPUPRI_IDLE;\r\nelse if (prio >= MAX_RT_PRIO)\r\ncpupri = CPUPRI_NORMAL;\r\nelse\r\ncpupri = MAX_RT_PRIO - prio + 1;\r\nreturn cpupri;\r\n}\r\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\r\nstruct cpumask *lowest_mask)\r\n{\r\nint idx = 0;\r\nint task_pri = convert_prio(p->prio);\r\nBUG_ON(task_pri >= CPUPRI_NR_PRIORITIES);\r\nfor (idx = 0; idx < task_pri; idx++) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[idx];\r\nint skip = 0;\r\nif (!atomic_read(&(vec)->count))\r\nskip = 1;\r\nsmp_rmb();\r\nif (skip)\r\ncontinue;\r\nif (cpumask_any_and(tsk_cpus_allowed(p), vec->mask) >= nr_cpu_ids)\r\ncontinue;\r\nif (lowest_mask) {\r\ncpumask_and(lowest_mask, tsk_cpus_allowed(p), vec->mask);\r\nif (cpumask_any(lowest_mask) >= nr_cpu_ids)\r\ncontinue;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\r\n{\r\nint *currpri = &cp->cpu_to_pri[cpu];\r\nint oldpri = *currpri;\r\nint do_mb = 0;\r\nnewpri = convert_prio(newpri);\r\nBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\r\nif (newpri == oldpri)\r\nreturn;\r\nif (likely(newpri != CPUPRI_INVALID)) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\r\ncpumask_set_cpu(cpu, vec->mask);\r\nsmp_mb__before_atomic();\r\natomic_inc(&(vec)->count);\r\ndo_mb = 1;\r\n}\r\nif (likely(oldpri != CPUPRI_INVALID)) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[oldpri];\r\nif (do_mb)\r\nsmp_mb__after_atomic();\r\natomic_dec(&(vec)->count);\r\nsmp_mb__after_atomic();\r\ncpumask_clear_cpu(cpu, vec->mask);\r\n}\r\n*currpri = newpri;\r\n}\r\nint cpupri_init(struct cpupri *cp)\r\n{\r\nint i;\r\nmemset(cp, 0, sizeof(*cp));\r\nfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\r\natomic_set(&vec->count, 0);\r\nif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\r\ngoto cleanup;\r\n}\r\ncp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\r\nif (!cp->cpu_to_pri)\r\ngoto cleanup;\r\nfor_each_possible_cpu(i)\r\ncp->cpu_to_pri[i] = CPUPRI_INVALID;\r\nreturn 0;\r\ncleanup:\r\nfor (i--; i >= 0; i--)\r\nfree_cpumask_var(cp->pri_to_cpu[i].mask);\r\nreturn -ENOMEM;\r\n}\r\nvoid cpupri_cleanup(struct cpupri *cp)\r\n{\r\nint i;\r\nkfree(cp->cpu_to_pri);\r\nfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\r\nfree_cpumask_var(cp->pri_to_cpu[i].mask);\r\n}
