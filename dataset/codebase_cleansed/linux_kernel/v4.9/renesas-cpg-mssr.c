static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct cpg_mssr_priv *priv = clock->priv;\r\nunsigned int reg = clock->index / 32;\r\nunsigned int bit = clock->index % 32;\r\nstruct device *dev = priv->dev;\r\nu32 bitmask = BIT(bit);\r\nunsigned long flags;\r\nunsigned int i;\r\nu32 value;\r\ndev_dbg(dev, "MSTP %u%02u/%pC %s\n", reg, bit, hw->clk,\r\nenable ? "ON" : "OFF");\r\nspin_lock_irqsave(&priv->mstp_lock, flags);\r\nvalue = clk_readl(priv->base + SMSTPCR(reg));\r\nif (enable)\r\nvalue &= ~bitmask;\r\nelse\r\nvalue |= bitmask;\r\nclk_writel(value, priv->base + SMSTPCR(reg));\r\nspin_unlock_irqrestore(&priv->mstp_lock, flags);\r\nif (!enable)\r\nreturn 0;\r\nfor (i = 1000; i > 0; --i) {\r\nif (!(clk_readl(priv->base + MSTPSR(reg)) &\r\nbitmask))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!i) {\r\ndev_err(dev, "Failed to enable SMSTP %p[%d]\n",\r\npriv->base + SMSTPCR(reg), bit);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpg_mstp_clock_enable(struct clk_hw *hw)\r\n{\r\nreturn cpg_mstp_clock_endisable(hw, true);\r\n}\r\nstatic void cpg_mstp_clock_disable(struct clk_hw *hw)\r\n{\r\ncpg_mstp_clock_endisable(hw, false);\r\n}\r\nstatic int cpg_mstp_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct cpg_mssr_priv *priv = clock->priv;\r\nu32 value;\r\nvalue = clk_readl(priv->base + MSTPSR(clock->index / 32));\r\nreturn !(value & BIT(clock->index % 32));\r\n}\r\nstatic\r\nstruct clk *cpg_mssr_clk_src_twocell_get(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nunsigned int clkidx = clkspec->args[1];\r\nstruct cpg_mssr_priv *priv = data;\r\nstruct device *dev = priv->dev;\r\nunsigned int idx;\r\nconst char *type;\r\nstruct clk *clk;\r\nswitch (clkspec->args[0]) {\r\ncase CPG_CORE:\r\ntype = "core";\r\nif (clkidx > priv->last_dt_core_clk) {\r\ndev_err(dev, "Invalid %s clock index %u\n", type,\r\nclkidx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nclk = priv->clks[clkidx];\r\nbreak;\r\ncase CPG_MOD:\r\ntype = "module";\r\nidx = MOD_CLK_PACK(clkidx);\r\nif (clkidx % 100 > 31 || idx >= priv->num_mod_clks) {\r\ndev_err(dev, "Invalid %s clock index %u\n", type,\r\nclkidx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nclk = priv->clks[priv->num_core_clks + idx];\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid CPG clock type %u\n", clkspec->args[0]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (IS_ERR(clk))\r\ndev_err(dev, "Cannot get %s clock %u: %ld", type, clkidx,\r\nPTR_ERR(clk));\r\nelse\r\ndev_dbg(dev, "clock (%u, %u) is %pC at %pCr Hz\n",\r\nclkspec->args[0], clkspec->args[1], clk, clk);\r\nreturn clk;\r\n}\r\nstatic void __init cpg_mssr_register_core_clk(const struct cpg_core_clk *core,\r\nconst struct cpg_mssr_info *info,\r\nstruct cpg_mssr_priv *priv)\r\n{\r\nstruct clk *clk = NULL, *parent;\r\nstruct device *dev = priv->dev;\r\nunsigned int id = core->id, div = core->div;\r\nconst char *parent_name;\r\nWARN_DEBUG(id >= priv->num_core_clks);\r\nWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\r\nswitch (core->type) {\r\ncase CLK_TYPE_IN:\r\nclk = of_clk_get_by_name(priv->dev->of_node, core->name);\r\nbreak;\r\ncase CLK_TYPE_FF:\r\ncase CLK_TYPE_DIV6P1:\r\ncase CLK_TYPE_DIV6_RO:\r\nWARN_DEBUG(core->parent >= priv->num_core_clks);\r\nparent = priv->clks[core->parent];\r\nif (IS_ERR(parent)) {\r\nclk = parent;\r\ngoto fail;\r\n}\r\nparent_name = __clk_get_name(parent);\r\nif (core->type == CLK_TYPE_DIV6_RO)\r\ndiv *= (readl(priv->base + core->offset) & 0x3f) + 1;\r\nif (core->type == CLK_TYPE_DIV6P1) {\r\nclk = cpg_div6_register(core->name, 1, &parent_name,\r\npriv->base + core->offset);\r\n} else {\r\nclk = clk_register_fixed_factor(NULL, core->name,\r\nparent_name, 0,\r\ncore->mult, div);\r\n}\r\nbreak;\r\ndefault:\r\nif (info->cpg_clk_register)\r\nclk = info->cpg_clk_register(dev, core, info,\r\npriv->clks, priv->base);\r\nelse\r\ndev_err(dev, "%s has unsupported core clock type %u\n",\r\ncore->name, core->type);\r\nbreak;\r\n}\r\nif (IS_ERR_OR_NULL(clk))\r\ngoto fail;\r\ndev_dbg(dev, "Core clock %pC at %pCr Hz\n", clk, clk);\r\npriv->clks[id] = clk;\r\nreturn;\r\nfail:\r\ndev_err(dev, "Failed to register %s clock %s: %ld\n", "core,",\r\ncore->name, PTR_ERR(clk));\r\n}\r\nstatic void __init cpg_mssr_register_mod_clk(const struct mssr_mod_clk *mod,\r\nconst struct cpg_mssr_info *info,\r\nstruct cpg_mssr_priv *priv)\r\n{\r\nstruct mstp_clock *clock = NULL;\r\nstruct device *dev = priv->dev;\r\nunsigned int id = mod->id;\r\nstruct clk_init_data init;\r\nstruct clk *parent, *clk;\r\nconst char *parent_name;\r\nunsigned int i;\r\nWARN_DEBUG(id < priv->num_core_clks);\r\nWARN_DEBUG(id >= priv->num_core_clks + priv->num_mod_clks);\r\nWARN_DEBUG(mod->parent >= priv->num_core_clks + priv->num_mod_clks);\r\nWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\r\nparent = priv->clks[mod->parent];\r\nif (IS_ERR(parent)) {\r\nclk = parent;\r\ngoto fail;\r\n}\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock) {\r\nclk = ERR_PTR(-ENOMEM);\r\ngoto fail;\r\n}\r\ninit.name = mod->name;\r\ninit.ops = &cpg_mstp_clock_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;\r\nfor (i = 0; i < info->num_crit_mod_clks; i++)\r\nif (id == info->crit_mod_clks[i]) {\r\n#ifdef CLK_ENABLE_HAND_OFF\r\ndev_dbg(dev, "MSTP %s setting CLK_ENABLE_HAND_OFF\n",\r\nmod->name);\r\ninit.flags |= CLK_ENABLE_HAND_OFF;\r\nbreak;\r\n#else\r\ndev_dbg(dev, "Ignoring MSTP %s to prevent disabling\n",\r\nmod->name);\r\nkfree(clock);\r\nreturn;\r\n#endif\r\n}\r\nparent_name = __clk_get_name(parent);\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclock->index = id - priv->num_core_clks;\r\nclock->priv = priv;\r\nclock->hw.init = &init;\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk))\r\ngoto fail;\r\ndev_dbg(dev, "Module clock %pC at %pCr Hz\n", clk, clk);\r\npriv->clks[id] = clk;\r\nreturn;\r\nfail:\r\ndev_err(dev, "Failed to register %s clock %s: %ld\n", "module,",\r\nmod->name, PTR_ERR(clk));\r\nkfree(clock);\r\n}\r\nstatic bool cpg_mssr_is_pm_clk(const struct of_phandle_args *clkspec,\r\nstruct cpg_mssr_clk_domain *pd)\r\n{\r\nunsigned int i;\r\nif (clkspec->np != pd->np || clkspec->args_count != 2)\r\nreturn false;\r\nswitch (clkspec->args[0]) {\r\ncase CPG_CORE:\r\nfor (i = 0; i < pd->num_core_pm_clks; i++)\r\nif (clkspec->args[1] == pd->core_pm_clks[i])\r\nreturn true;\r\nreturn false;\r\ncase CPG_MOD:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev)\r\n{\r\nstruct cpg_mssr_clk_domain *pd = cpg_mssr_clk_domain;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_phandle_args clkspec;\r\nstruct clk *clk;\r\nint i = 0;\r\nint error;\r\nif (!pd) {\r\ndev_dbg(dev, "CPG/MSSR clock domain not yet available\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nwhile (!of_parse_phandle_with_args(np, "clocks", "#clock-cells", i,\r\n&clkspec)) {\r\nif (cpg_mssr_is_pm_clk(&clkspec, pd))\r\ngoto found;\r\nof_node_put(clkspec.np);\r\ni++;\r\n}\r\nreturn 0;\r\nfound:\r\nclk = of_clk_get_from_provider(&clkspec);\r\nof_node_put(clkspec.np);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nerror = pm_clk_create(dev);\r\nif (error) {\r\ndev_err(dev, "pm_clk_create failed %d\n", error);\r\ngoto fail_put;\r\n}\r\nerror = pm_clk_add_clk(dev, clk);\r\nif (error) {\r\ndev_err(dev, "pm_clk_add_clk %pC failed %d\n", clk, error);\r\ngoto fail_destroy;\r\n}\r\nreturn 0;\r\nfail_destroy:\r\npm_clk_destroy(dev);\r\nfail_put:\r\nclk_put(clk);\r\nreturn error;\r\n}\r\nvoid cpg_mssr_detach_dev(struct generic_pm_domain *unused, struct device *dev)\r\n{\r\nif (!list_empty(&dev->power.subsys_data->clock_list))\r\npm_clk_destroy(dev);\r\n}\r\nstatic int __init cpg_mssr_add_clk_domain(struct device *dev,\r\nconst unsigned int *core_pm_clks,\r\nunsigned int num_core_pm_clks)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct generic_pm_domain *genpd;\r\nstruct cpg_mssr_clk_domain *pd;\r\nsize_t pm_size = num_core_pm_clks * sizeof(core_pm_clks[0]);\r\npd = devm_kzalloc(dev, sizeof(*pd) + pm_size, GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->np = np;\r\npd->num_core_pm_clks = num_core_pm_clks;\r\nmemcpy(pd->core_pm_clks, core_pm_clks, pm_size);\r\ngenpd = &pd->genpd;\r\ngenpd->name = np->name;\r\ngenpd->flags = GENPD_FLAG_PM_CLK;\r\ngenpd->attach_dev = cpg_mssr_attach_dev;\r\ngenpd->detach_dev = cpg_mssr_detach_dev;\r\npm_genpd_init(genpd, &pm_domain_always_on_gov, false);\r\ncpg_mssr_clk_domain = pd;\r\nof_genpd_add_provider_simple(np, genpd);\r\nreturn 0;\r\n}\r\nstatic void cpg_mssr_del_clk_provider(void *data)\r\n{\r\nof_clk_del_provider(data);\r\n}\r\nstatic int __init cpg_mssr_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct cpg_mssr_info *info;\r\nstruct cpg_mssr_priv *priv;\r\nunsigned int nclks, i;\r\nstruct resource *res;\r\nstruct clk **clks;\r\nint error;\r\ninfo = of_match_node(cpg_mssr_match, np)->data;\r\nif (info->init) {\r\nerror = info->init(dev);\r\nif (error)\r\nreturn error;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\nspin_lock_init(&priv->mstp_lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\nnclks = info->num_total_core_clks + info->num_hw_mod_clks;\r\nclks = devm_kmalloc_array(dev, nclks, sizeof(*clks), GFP_KERNEL);\r\nif (!clks)\r\nreturn -ENOMEM;\r\npriv->clks = clks;\r\npriv->num_core_clks = info->num_total_core_clks;\r\npriv->num_mod_clks = info->num_hw_mod_clks;\r\npriv->last_dt_core_clk = info->last_dt_core_clk;\r\nfor (i = 0; i < nclks; i++)\r\nclks[i] = ERR_PTR(-ENOENT);\r\nfor (i = 0; i < info->num_core_clks; i++)\r\ncpg_mssr_register_core_clk(&info->core_clks[i], info, priv);\r\nfor (i = 0; i < info->num_mod_clks; i++)\r\ncpg_mssr_register_mod_clk(&info->mod_clks[i], info, priv);\r\nerror = of_clk_add_provider(np, cpg_mssr_clk_src_twocell_get, priv);\r\nif (error)\r\nreturn error;\r\nerror = devm_add_action_or_reset(dev,\r\ncpg_mssr_del_clk_provider,\r\nnp);\r\nif (error)\r\nreturn error;\r\nerror = cpg_mssr_add_clk_domain(dev, info->core_pm_clks,\r\ninfo->num_core_pm_clks);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __init cpg_mssr_init(void)\r\n{\r\nreturn platform_driver_probe(&cpg_mssr_driver, cpg_mssr_probe);\r\n}
