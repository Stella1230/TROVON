struct fimc_fmt *fimc_get_format(unsigned int index)\r\n{\r\nif (index >= ARRAY_SIZE(fimc_formats))\r\nreturn NULL;\r\nreturn &fimc_formats[index];\r\n}\r\nint fimc_check_scaler_ratio(struct fimc_ctx *ctx, int sw, int sh,\r\nint dw, int dh, int rotation)\r\n{\r\nif (rotation == 90 || rotation == 270)\r\nswap(dw, dh);\r\nif (!ctx->scaler.enabled)\r\nreturn (sw == dw && sh == dh) ? 0 : -EINVAL;\r\nif ((sw >= SCALER_MAX_HRATIO * dw) || (sh >= SCALER_MAX_VRATIO * dh))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int fimc_get_scaler_factor(u32 src, u32 tar, u32 *ratio, u32 *shift)\r\n{\r\nu32 sh = 6;\r\nif (src >= 64 * tar)\r\nreturn -EINVAL;\r\nwhile (sh--) {\r\nu32 tmp = 1 << sh;\r\nif (src >= tar * tmp) {\r\n*shift = sh, *ratio = tmp;\r\nreturn 0;\r\n}\r\n}\r\n*shift = 0, *ratio = 1;\r\nreturn 0;\r\n}\r\nint fimc_set_scaler_info(struct fimc_ctx *ctx)\r\n{\r\nconst struct fimc_variant *variant = ctx->fimc_dev->variant;\r\nstruct device *dev = &ctx->fimc_dev->pdev->dev;\r\nstruct fimc_scaler *sc = &ctx->scaler;\r\nstruct fimc_frame *s_frame = &ctx->s_frame;\r\nstruct fimc_frame *d_frame = &ctx->d_frame;\r\nint tx, ty, sx, sy;\r\nint ret;\r\nif (ctx->rotation == 90 || ctx->rotation == 270) {\r\nty = d_frame->width;\r\ntx = d_frame->height;\r\n} else {\r\ntx = d_frame->width;\r\nty = d_frame->height;\r\n}\r\nif (tx <= 0 || ty <= 0) {\r\ndev_err(dev, "Invalid target size: %dx%d\n", tx, ty);\r\nreturn -EINVAL;\r\n}\r\nsx = s_frame->width;\r\nsy = s_frame->height;\r\nif (sx <= 0 || sy <= 0) {\r\ndev_err(dev, "Invalid source size: %dx%d\n", sx, sy);\r\nreturn -EINVAL;\r\n}\r\nsc->real_width = sx;\r\nsc->real_height = sy;\r\nret = fimc_get_scaler_factor(sx, tx, &sc->pre_hratio, &sc->hfactor);\r\nif (ret)\r\nreturn ret;\r\nret = fimc_get_scaler_factor(sy, ty, &sc->pre_vratio, &sc->vfactor);\r\nif (ret)\r\nreturn ret;\r\nsc->pre_dst_width = sx / sc->pre_hratio;\r\nsc->pre_dst_height = sy / sc->pre_vratio;\r\nif (variant->has_mainscaler_ext) {\r\nsc->main_hratio = (sx << 14) / (tx << sc->hfactor);\r\nsc->main_vratio = (sy << 14) / (ty << sc->vfactor);\r\n} else {\r\nsc->main_hratio = (sx << 8) / (tx << sc->hfactor);\r\nsc->main_vratio = (sy << 8) / (ty << sc->vfactor);\r\n}\r\nsc->scaleup_h = (tx >= sx) ? 1 : 0;\r\nsc->scaleup_v = (ty >= sy) ? 1 : 0;\r\nif (s_frame->fmt->color == d_frame->fmt->color\r\n&& s_frame->width == d_frame->width\r\n&& s_frame->height == d_frame->height)\r\nsc->copy_mode = 1;\r\nelse\r\nsc->copy_mode = 0;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fimc_irq_handler(int irq, void *priv)\r\n{\r\nstruct fimc_dev *fimc = priv;\r\nstruct fimc_ctx *ctx;\r\nfimc_hw_clear_irq(fimc);\r\nspin_lock(&fimc->slock);\r\nif (test_and_clear_bit(ST_M2M_PEND, &fimc->state)) {\r\nif (test_and_clear_bit(ST_M2M_SUSPENDING, &fimc->state)) {\r\nset_bit(ST_M2M_SUSPENDED, &fimc->state);\r\nwake_up(&fimc->irq_queue);\r\ngoto out;\r\n}\r\nctx = v4l2_m2m_get_curr_priv(fimc->m2m.m2m_dev);\r\nif (ctx != NULL) {\r\nspin_unlock(&fimc->slock);\r\nfimc_m2m_job_finish(ctx, VB2_BUF_STATE_DONE);\r\nif (ctx->state & FIMC_CTX_SHUT) {\r\nctx->state &= ~FIMC_CTX_SHUT;\r\nwake_up(&fimc->irq_queue);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\n} else if (test_bit(ST_CAPT_PEND, &fimc->state)) {\r\nint last_buf = test_bit(ST_CAPT_JPEG, &fimc->state) &&\r\nfimc->vid_cap.reqbufs_count == 1;\r\nfimc_capture_irq_handler(fimc, !last_buf);\r\n}\r\nout:\r\nspin_unlock(&fimc->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nint fimc_prepare_addr(struct fimc_ctx *ctx, struct vb2_buffer *vb,\r\nstruct fimc_frame *frame, struct fimc_addr *paddr)\r\n{\r\nint ret = 0;\r\nu32 pix_size;\r\nif (vb == NULL || frame == NULL)\r\nreturn -EINVAL;\r\npix_size = frame->width * frame->height;\r\ndbg("memplanes= %d, colplanes= %d, pix_size= %d",\r\nframe->fmt->memplanes, frame->fmt->colplanes, pix_size);\r\npaddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (frame->fmt->memplanes == 1) {\r\nswitch (frame->fmt->colplanes) {\r\ncase 1:\r\npaddr->cb = 0;\r\npaddr->cr = 0;\r\nbreak;\r\ncase 2:\r\npaddr->cb = (u32)(paddr->y + pix_size);\r\npaddr->cr = 0;\r\nbreak;\r\ncase 3:\r\npaddr->cb = (u32)(paddr->y + pix_size);\r\nif (FIMC_FMT_YCBCR420 == frame->fmt->color)\r\npaddr->cr = (u32)(paddr->cb\r\n+ (pix_size >> 2));\r\nelse\r\npaddr->cr = (u32)(paddr->cb\r\n+ (pix_size >> 1));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else if (!frame->fmt->mdataplanes) {\r\nif (frame->fmt->memplanes >= 2)\r\npaddr->cb = vb2_dma_contig_plane_dma_addr(vb, 1);\r\nif (frame->fmt->memplanes == 3)\r\npaddr->cr = vb2_dma_contig_plane_dma_addr(vb, 2);\r\n}\r\ndbg("PHYS_ADDR: y= 0x%X cb= 0x%X cr= 0x%X ret= %d",\r\npaddr->y, paddr->cb, paddr->cr, ret);\r\nreturn ret;\r\n}\r\nvoid fimc_set_yuv_order(struct fimc_ctx *ctx)\r\n{\r\nctx->in_order_2p = FIMC_REG_CIOCTRL_ORDER422_2P_LSB_CRCB;\r\nctx->out_order_2p = FIMC_REG_CIOCTRL_ORDER422_2P_LSB_CRCB;\r\nswitch (ctx->s_frame.fmt->color) {\r\ncase FIMC_FMT_YCRYCB422:\r\nctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_YCRYCB;\r\nbreak;\r\ncase FIMC_FMT_CBYCRY422:\r\nctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_CBYCRY;\r\nbreak;\r\ncase FIMC_FMT_CRYCBY422:\r\nctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_CRYCBY;\r\nbreak;\r\ncase FIMC_FMT_YCBYCR422:\r\ndefault:\r\nctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_YCBYCR;\r\nbreak;\r\n}\r\ndbg("ctx->in_order_1p= %d", ctx->in_order_1p);\r\nswitch (ctx->d_frame.fmt->color) {\r\ncase FIMC_FMT_YCRYCB422:\r\nctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_YCRYCB;\r\nbreak;\r\ncase FIMC_FMT_CBYCRY422:\r\nctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_CBYCRY;\r\nbreak;\r\ncase FIMC_FMT_CRYCBY422:\r\nctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_CRYCBY;\r\nbreak;\r\ncase FIMC_FMT_YCBYCR422:\r\ndefault:\r\nctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_YCBYCR;\r\nbreak;\r\n}\r\ndbg("ctx->out_order_1p= %d", ctx->out_order_1p);\r\n}\r\nvoid fimc_prepare_dma_offset(struct fimc_ctx *ctx, struct fimc_frame *f)\r\n{\r\nbool pix_hoff = ctx->fimc_dev->drv_data->dma_pix_hoff;\r\nu32 i, depth = 0;\r\nfor (i = 0; i < f->fmt->memplanes; i++)\r\ndepth += f->fmt->depth[i];\r\nf->dma_offset.y_h = f->offs_h;\r\nif (!pix_hoff)\r\nf->dma_offset.y_h *= (depth >> 3);\r\nf->dma_offset.y_v = f->offs_v;\r\nf->dma_offset.cb_h = f->offs_h;\r\nf->dma_offset.cb_v = f->offs_v;\r\nf->dma_offset.cr_h = f->offs_h;\r\nf->dma_offset.cr_v = f->offs_v;\r\nif (!pix_hoff) {\r\nif (f->fmt->colplanes == 3) {\r\nf->dma_offset.cb_h >>= 1;\r\nf->dma_offset.cr_h >>= 1;\r\n}\r\nif (f->fmt->color == FIMC_FMT_YCBCR420) {\r\nf->dma_offset.cb_v >>= 1;\r\nf->dma_offset.cr_v >>= 1;\r\n}\r\n}\r\ndbg("in_offset: color= %d, y_h= %d, y_v= %d",\r\nf->fmt->color, f->dma_offset.y_h, f->dma_offset.y_v);\r\n}\r\nstatic int fimc_set_color_effect(struct fimc_ctx *ctx, enum v4l2_colorfx colorfx)\r\n{\r\nstruct fimc_effect *effect = &ctx->effect;\r\nswitch (colorfx) {\r\ncase V4L2_COLORFX_NONE:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\r\nbreak;\r\ncase V4L2_COLORFX_BW:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\r\neffect->pat_cb = 128;\r\neffect->pat_cr = 128;\r\nbreak;\r\ncase V4L2_COLORFX_SEPIA:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\r\neffect->pat_cb = 115;\r\neffect->pat_cr = 145;\r\nbreak;\r\ncase V4L2_COLORFX_NEGATIVE:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_NEGATIVE;\r\nbreak;\r\ncase V4L2_COLORFX_EMBOSS:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_EMBOSSING;\r\nbreak;\r\ncase V4L2_COLORFX_ART_FREEZE:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_ARTFREEZE;\r\nbreak;\r\ncase V4L2_COLORFX_SILHOUETTE:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_SILHOUETTE;\r\nbreak;\r\ncase V4L2_COLORFX_SET_CBCR:\r\neffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\r\neffect->pat_cb = ctx->ctrls.colorfx_cbcr->val >> 8;\r\neffect->pat_cr = ctx->ctrls.colorfx_cbcr->val & 0xff;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __fimc_s_ctrl(struct fimc_ctx *ctx, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nconst struct fimc_variant *variant = fimc->variant;\r\nint ret = 0;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nctx->hflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nctx->vflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ROTATE:\r\nif (fimc_capture_pending(fimc)) {\r\nret = fimc_check_scaler_ratio(ctx, ctx->s_frame.width,\r\nctx->s_frame.height, ctx->d_frame.width,\r\nctx->d_frame.height, ctrl->val);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nif ((ctrl->val == 90 || ctrl->val == 270) &&\r\n!variant->has_out_rot)\r\nreturn -EINVAL;\r\nctx->rotation = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ALPHA_COMPONENT:\r\nctx->d_frame.alpha = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_COLORFX:\r\nret = fimc_set_color_effect(ctx, ctrl->val);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\nctx->state |= FIMC_PARAMS;\r\nset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\r\nreturn 0;\r\n}\r\nstatic int fimc_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fimc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ctx->fimc_dev->slock, flags);\r\nret = __fimc_s_ctrl(ctx, ctrl);\r\nspin_unlock_irqrestore(&ctx->fimc_dev->slock, flags);\r\nreturn ret;\r\n}\r\nint fimc_ctrls_create(struct fimc_ctx *ctx)\r\n{\r\nunsigned int max_alpha = fimc_get_alpha_mask(ctx->d_frame.fmt);\r\nstruct fimc_ctrls *ctrls = &ctx->ctrls;\r\nstruct v4l2_ctrl_handler *handler = &ctrls->handler;\r\nif (ctx->ctrls.ready)\r\nreturn 0;\r\nv4l2_ctrl_handler_init(handler, 6);\r\nctrls->rotate = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\r\nV4L2_CID_ROTATE, 0, 270, 90, 0);\r\nctrls->hflip = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctrls->vflip = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (ctx->fimc_dev->drv_data->alpha_color)\r\nctrls->alpha = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\r\nV4L2_CID_ALPHA_COMPONENT,\r\n0, max_alpha, 1, 0);\r\nelse\r\nctrls->alpha = NULL;\r\nctrls->colorfx = v4l2_ctrl_new_std_menu(handler, &fimc_ctrl_ops,\r\nV4L2_CID_COLORFX, V4L2_COLORFX_SET_CBCR,\r\n~0x983f, V4L2_COLORFX_NONE);\r\nctrls->colorfx_cbcr = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\r\nV4L2_CID_COLORFX_CBCR, 0, 0xffff, 1, 0);\r\nctx->effect.type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\r\nif (!handler->error) {\r\nv4l2_ctrl_cluster(2, &ctrls->colorfx);\r\nctrls->ready = true;\r\n}\r\nreturn handler->error;\r\n}\r\nvoid fimc_ctrls_delete(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_ctrls *ctrls = &ctx->ctrls;\r\nif (ctrls->ready) {\r\nv4l2_ctrl_handler_free(&ctrls->handler);\r\nctrls->ready = false;\r\nctrls->alpha = NULL;\r\n}\r\n}\r\nvoid fimc_ctrls_activate(struct fimc_ctx *ctx, bool active)\r\n{\r\nunsigned int has_alpha = ctx->d_frame.fmt->flags & FMT_HAS_ALPHA;\r\nstruct fimc_ctrls *ctrls = &ctx->ctrls;\r\nif (!ctrls->ready)\r\nreturn;\r\nmutex_lock(ctrls->handler.lock);\r\nv4l2_ctrl_activate(ctrls->rotate, active);\r\nv4l2_ctrl_activate(ctrls->hflip, active);\r\nv4l2_ctrl_activate(ctrls->vflip, active);\r\nv4l2_ctrl_activate(ctrls->colorfx, active);\r\nif (ctrls->alpha)\r\nv4l2_ctrl_activate(ctrls->alpha, active && has_alpha);\r\nif (active) {\r\nfimc_set_color_effect(ctx, ctrls->colorfx->cur.val);\r\nctx->rotation = ctrls->rotate->val;\r\nctx->hflip = ctrls->hflip->val;\r\nctx->vflip = ctrls->vflip->val;\r\n} else {\r\nctx->effect.type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\r\nctx->rotation = 0;\r\nctx->hflip = 0;\r\nctx->vflip = 0;\r\n}\r\nmutex_unlock(ctrls->handler.lock);\r\n}\r\nvoid fimc_alpha_ctrl_update(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct v4l2_ctrl *ctrl = ctx->ctrls.alpha;\r\nif (ctrl == NULL || !fimc->drv_data->alpha_color)\r\nreturn;\r\nv4l2_ctrl_lock(ctrl);\r\nctrl->maximum = fimc_get_alpha_mask(ctx->d_frame.fmt);\r\nif (ctrl->cur.val > ctrl->maximum)\r\nctrl->cur.val = ctrl->maximum;\r\nv4l2_ctrl_unlock(ctrl);\r\n}\r\nvoid __fimc_get_format(struct fimc_frame *frame, struct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\r\nint i;\r\npixm->width = frame->o_width;\r\npixm->height = frame->o_height;\r\npixm->field = V4L2_FIELD_NONE;\r\npixm->pixelformat = frame->fmt->fourcc;\r\npixm->colorspace = V4L2_COLORSPACE_JPEG;\r\npixm->num_planes = frame->fmt->memplanes;\r\nfor (i = 0; i < pixm->num_planes; ++i) {\r\npixm->plane_fmt[i].bytesperline = frame->bytesperline[i];\r\npixm->plane_fmt[i].sizeimage = frame->payload[i];\r\n}\r\n}\r\nvoid fimc_adjust_mplane_format(struct fimc_fmt *fmt, u32 width, u32 height,\r\nstruct v4l2_pix_format_mplane *pix)\r\n{\r\nu32 bytesperline = 0;\r\nint i;\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\npix->field = V4L2_FIELD_NONE;\r\npix->num_planes = fmt->memplanes;\r\npix->pixelformat = fmt->fourcc;\r\npix->height = height;\r\npix->width = width;\r\nfor (i = 0; i < pix->num_planes; ++i) {\r\nstruct v4l2_plane_pix_format *plane_fmt = &pix->plane_fmt[i];\r\nu32 bpl = plane_fmt->bytesperline;\r\nif (fmt->colplanes > 1 && (bpl == 0 || bpl < pix->width))\r\nbpl = pix->width;\r\nif (fmt->colplanes == 1 &&\r\n(bpl == 0 || ((bpl * 8) / fmt->depth[i]) < pix->width))\r\nbpl = (pix->width * fmt->depth[0]) / 8;\r\nif (i == 0)\r\nbytesperline = bpl;\r\nelse if (i == 1 && fmt->memplanes == 3)\r\nbytesperline /= 2;\r\nplane_fmt->bytesperline = bytesperline;\r\nplane_fmt->sizeimage = max((pix->width * pix->height *\r\nfmt->depth[i]) / 8, plane_fmt->sizeimage);\r\n}\r\n}\r\nstruct fimc_fmt *fimc_find_format(const u32 *pixelformat, const u32 *mbus_code,\r\nunsigned int mask, int index)\r\n{\r\nstruct fimc_fmt *fmt, *def_fmt = NULL;\r\nunsigned int i;\r\nint id = 0;\r\nif (index >= (int)ARRAY_SIZE(fimc_formats))\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(fimc_formats); ++i) {\r\nfmt = &fimc_formats[i];\r\nif (!(fmt->flags & mask))\r\ncontinue;\r\nif (pixelformat && fmt->fourcc == *pixelformat)\r\nreturn fmt;\r\nif (mbus_code && fmt->mbus_code == *mbus_code)\r\nreturn fmt;\r\nif (index == id)\r\ndef_fmt = fmt;\r\nid++;\r\n}\r\nreturn def_fmt;\r\n}\r\nstatic void fimc_clk_put(struct fimc_dev *fimc)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_FIMC_CLOCKS; i++) {\r\nif (IS_ERR(fimc->clock[i]))\r\ncontinue;\r\nclk_unprepare(fimc->clock[i]);\r\nclk_put(fimc->clock[i]);\r\nfimc->clock[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int fimc_clk_get(struct fimc_dev *fimc)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < MAX_FIMC_CLOCKS; i++)\r\nfimc->clock[i] = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < MAX_FIMC_CLOCKS; i++) {\r\nfimc->clock[i] = clk_get(&fimc->pdev->dev, fimc_clocks[i]);\r\nif (IS_ERR(fimc->clock[i])) {\r\nret = PTR_ERR(fimc->clock[i]);\r\ngoto err;\r\n}\r\nret = clk_prepare(fimc->clock[i]);\r\nif (ret < 0) {\r\nclk_put(fimc->clock[i]);\r\nfimc->clock[i] = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfimc_clk_put(fimc);\r\ndev_err(&fimc->pdev->dev, "failed to get clock: %s\n",\r\nfimc_clocks[i]);\r\nreturn -ENXIO;\r\n}\r\nstatic int fimc_m2m_suspend(struct fimc_dev *fimc)\r\n{\r\nunsigned long flags;\r\nint timeout;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nif (!fimc_m2m_pending(fimc)) {\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn 0;\r\n}\r\nclear_bit(ST_M2M_SUSPENDED, &fimc->state);\r\nset_bit(ST_M2M_SUSPENDING, &fimc->state);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\ntimeout = wait_event_timeout(fimc->irq_queue,\r\ntest_bit(ST_M2M_SUSPENDED, &fimc->state),\r\nFIMC_SHUTDOWN_TIMEOUT);\r\nclear_bit(ST_M2M_SUSPENDING, &fimc->state);\r\nreturn timeout == 0 ? -EAGAIN : 0;\r\n}\r\nstatic int fimc_m2m_resume(struct fimc_dev *fimc)\r\n{\r\nstruct fimc_ctx *ctx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nctx = fimc->m2m.ctx;\r\nfimc->m2m.ctx = NULL;\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (test_and_clear_bit(ST_M2M_SUSPENDED, &fimc->state))\r\nfimc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\nreturn 0;\r\n}\r\nstatic int fimc_parse_dt(struct fimc_dev *fimc, u32 *clk_freq)\r\n{\r\nstruct device *dev = &fimc->pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *of_id;\r\nstruct fimc_variant *v;\r\nstruct fimc_pix_limit *lim;\r\nu32 args[FIMC_PIX_LIMITS_MAX];\r\nint ret;\r\nif (of_property_read_bool(node, "samsung,lcd-wb"))\r\nreturn -ENODEV;\r\nv = devm_kzalloc(dev, sizeof(*v) + sizeof(*lim), GFP_KERNEL);\r\nif (!v)\r\nreturn -ENOMEM;\r\nof_id = of_match_node(fimc_of_match, node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nfimc->drv_data = of_id->data;\r\nret = of_property_read_u32_array(node, "samsung,pix-limits",\r\nargs, FIMC_PIX_LIMITS_MAX);\r\nif (ret < 0)\r\nreturn ret;\r\nlim = (struct fimc_pix_limit *)&v[1];\r\nlim->scaler_en_w = args[0];\r\nlim->scaler_dis_w = args[1];\r\nlim->out_rot_en_w = args[2];\r\nlim->out_rot_dis_w = args[3];\r\nv->pix_limit = lim;\r\nret = of_property_read_u32_array(node, "samsung,min-pix-sizes",\r\nargs, 2);\r\nv->min_inp_pixsize = ret ? FIMC_DEF_MIN_SIZE : args[0];\r\nv->min_out_pixsize = ret ? FIMC_DEF_MIN_SIZE : args[1];\r\nret = of_property_read_u32_array(node, "samsung,min-pix-alignment",\r\nargs, 2);\r\nv->min_vsize_align = ret ? FIMC_DEF_HEIGHT_ALIGN : args[0];\r\nv->hor_offs_align = ret ? FIMC_DEF_HOR_OFFS_ALIGN : args[1];\r\nret = of_property_read_u32(node, "samsung,rotators", &args[1]);\r\nv->has_inp_rot = ret ? 1 : args[1] & 0x01;\r\nv->has_out_rot = ret ? 1 : args[1] & 0x10;\r\nv->has_mainscaler_ext = of_property_read_bool(node,\r\n"samsung,mainscaler-ext");\r\nv->has_isp_wb = of_property_read_bool(node, "samsung,isp-wb");\r\nv->has_cam_if = of_property_read_bool(node, "samsung,cam-if");\r\nof_property_read_u32(node, "clock-frequency", clk_freq);\r\nfimc->id = of_alias_get_id(node, "fimc");\r\nfimc->variant = v;\r\nreturn 0;\r\n}\r\nstatic int fimc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nu32 lclk_freq = 0;\r\nstruct fimc_dev *fimc;\r\nstruct resource *res;\r\nint ret = 0;\r\nfimc = devm_kzalloc(dev, sizeof(*fimc), GFP_KERNEL);\r\nif (!fimc)\r\nreturn -ENOMEM;\r\nfimc->pdev = pdev;\r\nif (dev->of_node) {\r\nret = fimc_parse_dt(fimc, &lclk_freq);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nfimc->drv_data = fimc_get_drvdata(pdev);\r\nfimc->id = pdev->id;\r\n}\r\nif (!fimc->drv_data || fimc->id >= fimc->drv_data->num_entities ||\r\nfimc->id < 0) {\r\ndev_err(dev, "Invalid driver data or device id (%d)\n",\r\nfimc->id);\r\nreturn -EINVAL;\r\n}\r\nif (!dev->of_node)\r\nfimc->variant = fimc->drv_data->variant[fimc->id];\r\ninit_waitqueue_head(&fimc->irq_queue);\r\nspin_lock_init(&fimc->slock);\r\nmutex_init(&fimc->lock);\r\nfimc->sysreg = fimc_get_sysreg_regmap(dev->of_node);\r\nif (IS_ERR(fimc->sysreg))\r\nreturn PTR_ERR(fimc->sysreg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfimc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(fimc->regs))\r\nreturn PTR_ERR(fimc->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "Failed to get IRQ resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = fimc_clk_get(fimc);\r\nif (ret)\r\nreturn ret;\r\nif (lclk_freq == 0)\r\nlclk_freq = fimc->drv_data->lclk_frequency;\r\nret = clk_set_rate(fimc->clock[CLK_BUS], lclk_freq);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_enable(fimc->clock[CLK_BUS]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = devm_request_irq(dev, res->start, fimc_irq_handler,\r\n0, dev_name(dev), fimc);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to install irq (%d)\n", ret);\r\ngoto err_sclk;\r\n}\r\nret = fimc_initialize_capture_subdev(fimc);\r\nif (ret < 0)\r\ngoto err_sclk;\r\nplatform_set_drvdata(pdev, fimc);\r\npm_runtime_enable(dev);\r\nif (!pm_runtime_enabled(dev)) {\r\nret = clk_enable(fimc->clock[CLK_GATE]);\r\nif (ret < 0)\r\ngoto err_sd;\r\n}\r\nvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\r\ndev_dbg(dev, "FIMC.%d registered successfully\n", fimc->id);\r\nreturn 0;\r\nerr_sd:\r\nfimc_unregister_capture_subdev(fimc);\r\nerr_sclk:\r\nclk_disable(fimc->clock[CLK_BUS]);\r\nfimc_clk_put(fimc);\r\nreturn ret;\r\n}\r\nstatic int fimc_runtime_resume(struct device *dev)\r\n{\r\nstruct fimc_dev *fimc = dev_get_drvdata(dev);\r\ndbg("fimc%d: state: 0x%lx", fimc->id, fimc->state);\r\nclk_enable(fimc->clock[CLK_GATE]);\r\nfimc_hw_reset(fimc);\r\nif (fimc_capture_busy(fimc))\r\nreturn fimc_capture_resume(fimc);\r\nreturn fimc_m2m_resume(fimc);\r\n}\r\nstatic int fimc_runtime_suspend(struct device *dev)\r\n{\r\nstruct fimc_dev *fimc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (fimc_capture_busy(fimc))\r\nret = fimc_capture_suspend(fimc);\r\nelse\r\nret = fimc_m2m_suspend(fimc);\r\nif (!ret)\r\nclk_disable(fimc->clock[CLK_GATE]);\r\ndbg("fimc%d: state: 0x%lx", fimc->id, fimc->state);\r\nreturn ret;\r\n}\r\nstatic int fimc_resume(struct device *dev)\r\n{\r\nstruct fimc_dev *fimc = dev_get_drvdata(dev);\r\nunsigned long flags;\r\ndbg("fimc%d: state: 0x%lx", fimc->id, fimc->state);\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nif (!test_and_clear_bit(ST_LPM, &fimc->state) ||\r\n(!fimc_m2m_active(fimc) && !fimc_capture_busy(fimc))) {\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn 0;\r\n}\r\nfimc_hw_reset(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (fimc_capture_busy(fimc))\r\nreturn fimc_capture_resume(fimc);\r\nreturn fimc_m2m_resume(fimc);\r\n}\r\nstatic int fimc_suspend(struct device *dev)\r\n{\r\nstruct fimc_dev *fimc = dev_get_drvdata(dev);\r\ndbg("fimc%d: state: 0x%lx", fimc->id, fimc->state);\r\nif (test_and_set_bit(ST_LPM, &fimc->state))\r\nreturn 0;\r\nif (fimc_capture_busy(fimc))\r\nreturn fimc_capture_suspend(fimc);\r\nreturn fimc_m2m_suspend(fimc);\r\n}\r\nstatic int fimc_remove(struct platform_device *pdev)\r\n{\r\nstruct fimc_dev *fimc = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nclk_disable(fimc->clock[CLK_GATE]);\r\npm_runtime_set_suspended(&pdev->dev);\r\nfimc_unregister_capture_subdev(fimc);\r\nvb2_dma_contig_clear_max_seg_size(&pdev->dev);\r\nclk_disable(fimc->clock[CLK_BUS]);\r\nfimc_clk_put(fimc);\r\ndev_info(&pdev->dev, "driver unloaded\n");\r\nreturn 0;\r\n}\r\nint __init fimc_register_driver(void)\r\n{\r\nreturn platform_driver_register(&fimc_driver);\r\n}\r\nvoid __exit fimc_unregister_driver(void)\r\n{\r\nplatform_driver_unregister(&fimc_driver);\r\n}
