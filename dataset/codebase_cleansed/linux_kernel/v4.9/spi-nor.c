static int read_sr(struct spi_nor *nor)\r\n{\r\nint ret;\r\nu8 val;\r\nret = nor->read_reg(nor, SPINOR_OP_RDSR, &val, 1);\r\nif (ret < 0) {\r\npr_err("error %d reading SR\n", (int) ret);\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic int read_fsr(struct spi_nor *nor)\r\n{\r\nint ret;\r\nu8 val;\r\nret = nor->read_reg(nor, SPINOR_OP_RDFSR, &val, 1);\r\nif (ret < 0) {\r\npr_err("error %d reading FSR\n", ret);\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic int read_cr(struct spi_nor *nor)\r\n{\r\nint ret;\r\nu8 val;\r\nret = nor->read_reg(nor, SPINOR_OP_RDCR, &val, 1);\r\nif (ret < 0) {\r\ndev_err(nor->dev, "error %d reading CR\n", ret);\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic inline int spi_nor_read_dummy_cycles(struct spi_nor *nor)\r\n{\r\nswitch (nor->flash_read) {\r\ncase SPI_NOR_FAST:\r\ncase SPI_NOR_DUAL:\r\ncase SPI_NOR_QUAD:\r\nreturn 8;\r\ncase SPI_NOR_NORMAL:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int write_sr(struct spi_nor *nor, u8 val)\r\n{\r\nnor->cmd_buf[0] = val;\r\nreturn nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1);\r\n}\r\nstatic inline int write_enable(struct spi_nor *nor)\r\n{\r\nreturn nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\r\n}\r\nstatic inline int write_disable(struct spi_nor *nor)\r\n{\r\nreturn nor->write_reg(nor, SPINOR_OP_WRDI, NULL, 0);\r\n}\r\nstatic inline struct spi_nor *mtd_to_spi_nor(struct mtd_info *mtd)\r\n{\r\nreturn mtd->priv;\r\n}\r\nstatic inline int set_4byte(struct spi_nor *nor, const struct flash_info *info,\r\nint enable)\r\n{\r\nint status;\r\nbool need_wren = false;\r\nu8 cmd;\r\nswitch (JEDEC_MFR(info)) {\r\ncase SNOR_MFR_MICRON:\r\nneed_wren = true;\r\ncase SNOR_MFR_MACRONIX:\r\ncase SNOR_MFR_WINBOND:\r\nif (need_wren)\r\nwrite_enable(nor);\r\ncmd = enable ? SPINOR_OP_EN4B : SPINOR_OP_EX4B;\r\nstatus = nor->write_reg(nor, cmd, NULL, 0);\r\nif (need_wren)\r\nwrite_disable(nor);\r\nreturn status;\r\ndefault:\r\nnor->cmd_buf[0] = enable << 7;\r\nreturn nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1);\r\n}\r\n}\r\nstatic inline int spi_nor_sr_ready(struct spi_nor *nor)\r\n{\r\nint sr = read_sr(nor);\r\nif (sr < 0)\r\nreturn sr;\r\nelse\r\nreturn !(sr & SR_WIP);\r\n}\r\nstatic inline int spi_nor_fsr_ready(struct spi_nor *nor)\r\n{\r\nint fsr = read_fsr(nor);\r\nif (fsr < 0)\r\nreturn fsr;\r\nelse\r\nreturn fsr & FSR_READY;\r\n}\r\nstatic int spi_nor_ready(struct spi_nor *nor)\r\n{\r\nint sr, fsr;\r\nsr = spi_nor_sr_ready(nor);\r\nif (sr < 0)\r\nreturn sr;\r\nfsr = nor->flags & SNOR_F_USE_FSR ? spi_nor_fsr_ready(nor) : 1;\r\nif (fsr < 0)\r\nreturn fsr;\r\nreturn sr && fsr;\r\n}\r\nstatic int spi_nor_wait_till_ready_with_timeout(struct spi_nor *nor,\r\nunsigned long timeout_jiffies)\r\n{\r\nunsigned long deadline;\r\nint timeout = 0, ret;\r\ndeadline = jiffies + timeout_jiffies;\r\nwhile (!timeout) {\r\nif (time_after_eq(jiffies, deadline))\r\ntimeout = 1;\r\nret = spi_nor_ready(nor);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret)\r\nreturn 0;\r\ncond_resched();\r\n}\r\ndev_err(nor->dev, "flash operation timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int spi_nor_wait_till_ready(struct spi_nor *nor)\r\n{\r\nreturn spi_nor_wait_till_ready_with_timeout(nor,\r\nDEFAULT_READY_WAIT_JIFFIES);\r\n}\r\nstatic int erase_chip(struct spi_nor *nor)\r\n{\r\ndev_dbg(nor->dev, " %lldKiB\n", (long long)(nor->mtd.size >> 10));\r\nreturn nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0);\r\n}\r\nstatic int spi_nor_lock_and_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nint ret = 0;\r\nmutex_lock(&nor->lock);\r\nif (nor->prepare) {\r\nret = nor->prepare(nor, ops);\r\nif (ret) {\r\ndev_err(nor->dev, "failed in the preparation.\n");\r\nmutex_unlock(&nor->lock);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void spi_nor_unlock_and_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nif (nor->unprepare)\r\nnor->unprepare(nor, ops);\r\nmutex_unlock(&nor->lock);\r\n}\r\nstatic int spi_nor_erase_sector(struct spi_nor *nor, u32 addr)\r\n{\r\nu8 buf[SPI_NOR_MAX_ADDR_WIDTH];\r\nint i;\r\nif (nor->erase)\r\nreturn nor->erase(nor, addr);\r\nfor (i = nor->addr_width - 1; i >= 0; i--) {\r\nbuf[i] = addr & 0xff;\r\naddr >>= 8;\r\n}\r\nreturn nor->write_reg(nor, nor->erase_opcode, buf, nor->addr_width);\r\n}\r\nstatic int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nu32 addr, len;\r\nuint32_t rem;\r\nint ret;\r\ndev_dbg(nor->dev, "at 0x%llx, len %lld\n", (long long)instr->addr,\r\n(long long)instr->len);\r\ndiv_u64_rem(instr->len, mtd->erasesize, &rem);\r\nif (rem)\r\nreturn -EINVAL;\r\naddr = instr->addr;\r\nlen = instr->len;\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_ERASE);\r\nif (ret)\r\nreturn ret;\r\nif (len == mtd->size) {\r\nunsigned long timeout;\r\nwrite_enable(nor);\r\nif (erase_chip(nor)) {\r\nret = -EIO;\r\ngoto erase_err;\r\n}\r\ntimeout = max(CHIP_ERASE_2MB_READY_WAIT_JIFFIES,\r\nCHIP_ERASE_2MB_READY_WAIT_JIFFIES *\r\n(unsigned long)(mtd->size / SZ_2M));\r\nret = spi_nor_wait_till_ready_with_timeout(nor, timeout);\r\nif (ret)\r\ngoto erase_err;\r\n} else {\r\nwhile (len) {\r\nwrite_enable(nor);\r\nret = spi_nor_erase_sector(nor, addr);\r\nif (ret)\r\ngoto erase_err;\r\naddr += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto erase_err;\r\n}\r\n}\r\nwrite_disable(nor);\r\nerase_err:\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_ERASE);\r\ninstr->state = ret ? MTD_ERASE_FAILED : MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn ret;\r\n}\r\nstatic void stm_get_locked_range(struct spi_nor *nor, u8 sr, loff_t *ofs,\r\nuint64_t *len)\r\n{\r\nstruct mtd_info *mtd = &nor->mtd;\r\nu8 mask = SR_BP2 | SR_BP1 | SR_BP0;\r\nint shift = ffs(mask) - 1;\r\nint pow;\r\nif (!(sr & mask)) {\r\n*ofs = 0;\r\n*len = 0;\r\n} else {\r\npow = ((sr & mask) ^ mask) >> shift;\r\n*len = mtd->size >> pow;\r\nif (nor->flags & SNOR_F_HAS_SR_TB && sr & SR_TB)\r\n*ofs = 0;\r\nelse\r\n*ofs = mtd->size - *len;\r\n}\r\n}\r\nstatic int stm_check_lock_status_sr(struct spi_nor *nor, loff_t ofs, uint64_t len,\r\nu8 sr, bool locked)\r\n{\r\nloff_t lock_offs;\r\nuint64_t lock_len;\r\nif (!len)\r\nreturn 1;\r\nstm_get_locked_range(nor, sr, &lock_offs, &lock_len);\r\nif (locked)\r\nreturn (ofs + len <= lock_offs + lock_len) && (ofs >= lock_offs);\r\nelse\r\nreturn (ofs >= lock_offs + lock_len) || (ofs + len <= lock_offs);\r\n}\r\nstatic int stm_is_locked_sr(struct spi_nor *nor, loff_t ofs, uint64_t len,\r\nu8 sr)\r\n{\r\nreturn stm_check_lock_status_sr(nor, ofs, len, sr, true);\r\n}\r\nstatic int stm_is_unlocked_sr(struct spi_nor *nor, loff_t ofs, uint64_t len,\r\nu8 sr)\r\n{\r\nreturn stm_check_lock_status_sr(nor, ofs, len, sr, false);\r\n}\r\nstatic int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_info *mtd = &nor->mtd;\r\nint status_old, status_new;\r\nu8 mask = SR_BP2 | SR_BP1 | SR_BP0;\r\nu8 shift = ffs(mask) - 1, pow, val;\r\nloff_t lock_len;\r\nbool can_be_top = true, can_be_bottom = nor->flags & SNOR_F_HAS_SR_TB;\r\nbool use_top;\r\nint ret;\r\nstatus_old = read_sr(nor);\r\nif (status_old < 0)\r\nreturn status_old;\r\nif (stm_is_locked_sr(nor, ofs, len, status_old))\r\nreturn 0;\r\nif (!stm_is_locked_sr(nor, 0, ofs, status_old))\r\ncan_be_bottom = false;\r\nif (!stm_is_locked_sr(nor, ofs + len, mtd->size - (ofs + len),\r\nstatus_old))\r\ncan_be_top = false;\r\nif (!can_be_bottom && !can_be_top)\r\nreturn -EINVAL;\r\nuse_top = can_be_top;\r\nif (use_top)\r\nlock_len = mtd->size - ofs;\r\nelse\r\nlock_len = ofs + len;\r\npow = ilog2(mtd->size) - ilog2(lock_len);\r\nval = mask - (pow << shift);\r\nif (val & ~mask)\r\nreturn -EINVAL;\r\nif (!(val & mask))\r\nreturn -EINVAL;\r\nstatus_new = (status_old & ~mask & ~SR_TB) | val;\r\nstatus_new |= SR_SRWD;\r\nif (!use_top)\r\nstatus_new |= SR_TB;\r\nif (status_new == status_old)\r\nreturn 0;\r\nif ((status_new & mask) < (status_old & mask))\r\nreturn -EINVAL;\r\nwrite_enable(nor);\r\nret = write_sr(nor, status_new);\r\nif (ret)\r\nreturn ret;\r\nreturn spi_nor_wait_till_ready(nor);\r\n}\r\nstatic int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_info *mtd = &nor->mtd;\r\nint status_old, status_new;\r\nu8 mask = SR_BP2 | SR_BP1 | SR_BP0;\r\nu8 shift = ffs(mask) - 1, pow, val;\r\nloff_t lock_len;\r\nbool can_be_top = true, can_be_bottom = nor->flags & SNOR_F_HAS_SR_TB;\r\nbool use_top;\r\nint ret;\r\nstatus_old = read_sr(nor);\r\nif (status_old < 0)\r\nreturn status_old;\r\nif (stm_is_unlocked_sr(nor, ofs, len, status_old))\r\nreturn 0;\r\nif (!stm_is_unlocked_sr(nor, 0, ofs, status_old))\r\ncan_be_top = false;\r\nif (!stm_is_unlocked_sr(nor, ofs + len, mtd->size - (ofs + len),\r\nstatus_old))\r\ncan_be_bottom = false;\r\nif (!can_be_bottom && !can_be_top)\r\nreturn -EINVAL;\r\nuse_top = can_be_top;\r\nif (use_top)\r\nlock_len = mtd->size - (ofs + len);\r\nelse\r\nlock_len = ofs;\r\npow = ilog2(mtd->size) - order_base_2(lock_len);\r\nif (lock_len == 0) {\r\nval = 0;\r\n} else {\r\nval = mask - (pow << shift);\r\nif (val & ~mask)\r\nreturn -EINVAL;\r\n}\r\nstatus_new = (status_old & ~mask & ~SR_TB) | val;\r\nif (lock_len == 0)\r\nstatus_new &= ~SR_SRWD;\r\nif (!use_top)\r\nstatus_new |= SR_TB;\r\nif (status_new == status_old)\r\nreturn 0;\r\nif ((status_new & mask) > (status_old & mask))\r\nreturn -EINVAL;\r\nwrite_enable(nor);\r\nret = write_sr(nor, status_new);\r\nif (ret)\r\nreturn ret;\r\nreturn spi_nor_wait_till_ready(nor);\r\n}\r\nstatic int stm_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)\r\n{\r\nint status;\r\nstatus = read_sr(nor);\r\nif (status < 0)\r\nreturn status;\r\nreturn stm_is_locked_sr(nor, ofs, len, status);\r\n}\r\nstatic int spi_nor_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nint ret;\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_LOCK);\r\nif (ret)\r\nreturn ret;\r\nret = nor->flash_lock(nor, ofs, len);\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_UNLOCK);\r\nreturn ret;\r\n}\r\nstatic int spi_nor_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nint ret;\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);\r\nif (ret)\r\nreturn ret;\r\nret = nor->flash_unlock(nor, ofs, len);\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);\r\nreturn ret;\r\n}\r\nstatic int spi_nor_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nint ret;\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);\r\nif (ret)\r\nreturn ret;\r\nret = nor->flash_is_locked(nor, ofs, len);\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);\r\nreturn ret;\r\n}\r\nstatic const struct flash_info *spi_nor_read_id(struct spi_nor *nor)\r\n{\r\nint tmp;\r\nu8 id[SPI_NOR_MAX_ID_LEN];\r\nconst struct flash_info *info;\r\ntmp = nor->read_reg(nor, SPINOR_OP_RDID, id, SPI_NOR_MAX_ID_LEN);\r\nif (tmp < 0) {\r\ndev_dbg(nor->dev, "error %d reading JEDEC ID\n", tmp);\r\nreturn ERR_PTR(tmp);\r\n}\r\nfor (tmp = 0; tmp < ARRAY_SIZE(spi_nor_ids) - 1; tmp++) {\r\ninfo = &spi_nor_ids[tmp];\r\nif (info->id_len) {\r\nif (!memcmp(info->id, id, info->id_len))\r\nreturn &spi_nor_ids[tmp];\r\n}\r\n}\r\ndev_err(nor->dev, "unrecognized JEDEC id bytes: %02x, %02x, %02x\n",\r\nid[0], id[1], id[2]);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int spi_nor_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nint ret;\r\ndev_dbg(nor->dev, "from 0x%08x, len %zd\n", (u32)from, len);\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_READ);\r\nif (ret)\r\nreturn ret;\r\nwhile (len) {\r\nret = nor->read(nor, from, len, buf);\r\nif (ret == 0) {\r\nret = -EIO;\r\ngoto read_err;\r\n}\r\nif (ret < 0)\r\ngoto read_err;\r\nWARN_ON(ret > len);\r\n*retlen += ret;\r\nbuf += ret;\r\nfrom += ret;\r\nlen -= ret;\r\n}\r\nret = 0;\r\nread_err:\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_READ);\r\nreturn ret;\r\n}\r\nstatic int sst_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nsize_t actual;\r\nint ret;\r\ndev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len);\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);\r\nif (ret)\r\nreturn ret;\r\nwrite_enable(nor);\r\nnor->sst_write_second = false;\r\nactual = to % 2;\r\nif (actual) {\r\nnor->program_opcode = SPINOR_OP_BP;\r\nret = nor->write(nor, to, 1, buf);\r\nif (ret < 0)\r\ngoto sst_write_err;\r\nWARN(ret != 1, "While writing 1 byte written %i bytes\n",\r\n(int)ret);\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto sst_write_err;\r\n}\r\nto += actual;\r\nfor (; actual < len - 1; actual += 2) {\r\nnor->program_opcode = SPINOR_OP_AAI_WP;\r\nret = nor->write(nor, to, 2, buf + actual);\r\nif (ret < 0)\r\ngoto sst_write_err;\r\nWARN(ret != 2, "While writing 2 bytes written %i bytes\n",\r\n(int)ret);\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto sst_write_err;\r\nto += 2;\r\nnor->sst_write_second = true;\r\n}\r\nnor->sst_write_second = false;\r\nwrite_disable(nor);\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto sst_write_err;\r\nif (actual != len) {\r\nwrite_enable(nor);\r\nnor->program_opcode = SPINOR_OP_BP;\r\nret = nor->write(nor, to, 1, buf + actual);\r\nif (ret < 0)\r\ngoto sst_write_err;\r\nWARN(ret != 1, "While writing 1 byte written %i bytes\n",\r\n(int)ret);\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto sst_write_err;\r\nwrite_disable(nor);\r\nactual += 1;\r\n}\r\nsst_write_err:\r\n*retlen += actual;\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);\r\nreturn ret;\r\n}\r\nstatic int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct spi_nor *nor = mtd_to_spi_nor(mtd);\r\nsize_t page_offset, page_remain, i;\r\nssize_t ret;\r\ndev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len);\r\nret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < len; ) {\r\nssize_t written;\r\npage_offset = (to + i) & (nor->page_size - 1);\r\nWARN_ONCE(page_offset,\r\n"Writing at offset %zu into a NOR page. Writing partial pages may decrease reliability and increase wear of NOR flash.",\r\npage_offset);\r\npage_remain = min_t(size_t,\r\nnor->page_size - page_offset, len - i);\r\nwrite_enable(nor);\r\nret = nor->write(nor, to + i, page_remain, buf + i);\r\nif (ret < 0)\r\ngoto write_err;\r\nwritten = ret;\r\nret = spi_nor_wait_till_ready(nor);\r\nif (ret)\r\ngoto write_err;\r\n*retlen += written;\r\ni += written;\r\nif (written != page_remain) {\r\ndev_err(nor->dev,\r\n"While writing %zu bytes written %zd bytes\n",\r\npage_remain, written);\r\nret = -EIO;\r\ngoto write_err;\r\n}\r\n}\r\nwrite_err:\r\nspi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);\r\nreturn ret;\r\n}\r\nstatic int macronix_quad_enable(struct spi_nor *nor)\r\n{\r\nint ret, val;\r\nval = read_sr(nor);\r\nif (val < 0)\r\nreturn val;\r\nwrite_enable(nor);\r\nwrite_sr(nor, val | SR_QUAD_EN_MX);\r\nif (spi_nor_wait_till_ready(nor))\r\nreturn 1;\r\nret = read_sr(nor);\r\nif (!(ret > 0 && (ret & SR_QUAD_EN_MX))) {\r\ndev_err(nor->dev, "Macronix Quad bit not set\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_sr_cr(struct spi_nor *nor, u16 val)\r\n{\r\nnor->cmd_buf[0] = val & 0xff;\r\nnor->cmd_buf[1] = (val >> 8);\r\nreturn nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 2);\r\n}\r\nstatic int spansion_quad_enable(struct spi_nor *nor)\r\n{\r\nint ret;\r\nint quad_en = CR_QUAD_EN_SPAN << 8;\r\nwrite_enable(nor);\r\nret = write_sr_cr(nor, quad_en);\r\nif (ret < 0) {\r\ndev_err(nor->dev,\r\n"error while writing configuration register\n");\r\nreturn -EINVAL;\r\n}\r\nret = read_cr(nor);\r\nif (!(ret > 0 && (ret & CR_QUAD_EN_SPAN))) {\r\ndev_err(nor->dev, "Spansion Quad bit not set\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)\r\n{\r\nint status;\r\nswitch (JEDEC_MFR(info)) {\r\ncase SNOR_MFR_MACRONIX:\r\nstatus = macronix_quad_enable(nor);\r\nif (status) {\r\ndev_err(nor->dev, "Macronix quad-read not enabled\n");\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\ncase SNOR_MFR_MICRON:\r\nreturn 0;\r\ndefault:\r\nstatus = spansion_quad_enable(nor);\r\nif (status) {\r\ndev_err(nor->dev, "Spansion quad-read not enabled\n");\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\n}\r\n}\r\nstatic int spi_nor_check(struct spi_nor *nor)\r\n{\r\nif (!nor->dev || !nor->read || !nor->write ||\r\n!nor->read_reg || !nor->write_reg) {\r\npr_err("spi-nor: please fill all the necessary fields!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)\r\n{\r\nconst struct flash_info *info = NULL;\r\nstruct device *dev = nor->dev;\r\nstruct mtd_info *mtd = &nor->mtd;\r\nstruct device_node *np = spi_nor_get_flash_node(nor);\r\nint ret;\r\nint i;\r\nret = spi_nor_check(nor);\r\nif (ret)\r\nreturn ret;\r\nif (name)\r\ninfo = spi_nor_match_id(name);\r\nif (!info)\r\ninfo = spi_nor_read_id(nor);\r\nif (IS_ERR_OR_NULL(info))\r\nreturn -ENOENT;\r\nif (name && info->id_len) {\r\nconst struct flash_info *jinfo;\r\njinfo = spi_nor_read_id(nor);\r\nif (IS_ERR(jinfo)) {\r\nreturn PTR_ERR(jinfo);\r\n} else if (jinfo != info) {\r\ndev_warn(dev, "found %s, expected %s\n",\r\njinfo->name, info->name);\r\ninfo = jinfo;\r\n}\r\n}\r\nmutex_init(&nor->lock);\r\nif (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||\r\nJEDEC_MFR(info) == SNOR_MFR_INTEL ||\r\nJEDEC_MFR(info) == SNOR_MFR_SST ||\r\ninfo->flags & SPI_NOR_HAS_LOCK) {\r\nwrite_enable(nor);\r\nwrite_sr(nor, 0);\r\nspi_nor_wait_till_ready(nor);\r\n}\r\nif (!mtd->name)\r\nmtd->name = dev_name(dev);\r\nmtd->priv = nor;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->writesize = 1;\r\nmtd->flags = MTD_CAP_NORFLASH;\r\nmtd->size = info->sector_size * info->n_sectors;\r\nmtd->_erase = spi_nor_erase;\r\nmtd->_read = spi_nor_read;\r\nif (JEDEC_MFR(info) == SNOR_MFR_MICRON ||\r\ninfo->flags & SPI_NOR_HAS_LOCK) {\r\nnor->flash_lock = stm_lock;\r\nnor->flash_unlock = stm_unlock;\r\nnor->flash_is_locked = stm_is_locked;\r\n}\r\nif (nor->flash_lock && nor->flash_unlock && nor->flash_is_locked) {\r\nmtd->_lock = spi_nor_lock;\r\nmtd->_unlock = spi_nor_unlock;\r\nmtd->_is_locked = spi_nor_is_locked;\r\n}\r\nif (info->flags & SST_WRITE)\r\nmtd->_write = sst_write;\r\nelse\r\nmtd->_write = spi_nor_write;\r\nif (info->flags & USE_FSR)\r\nnor->flags |= SNOR_F_USE_FSR;\r\nif (info->flags & SPI_NOR_HAS_TB)\r\nnor->flags |= SNOR_F_HAS_SR_TB;\r\n#ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS\r\nif (info->flags & SECT_4K) {\r\nnor->erase_opcode = SPINOR_OP_BE_4K;\r\nmtd->erasesize = 4096;\r\n} else if (info->flags & SECT_4K_PMC) {\r\nnor->erase_opcode = SPINOR_OP_BE_4K_PMC;\r\nmtd->erasesize = 4096;\r\n} else\r\n#endif\r\n{\r\nnor->erase_opcode = SPINOR_OP_SE;\r\nmtd->erasesize = info->sector_size;\r\n}\r\nif (info->flags & SPI_NOR_NO_ERASE)\r\nmtd->flags |= MTD_NO_ERASE;\r\nmtd->dev.parent = dev;\r\nnor->page_size = info->page_size;\r\nmtd->writebufsize = nor->page_size;\r\nif (np) {\r\nif (of_property_read_bool(np, "m25p,fast-read"))\r\nnor->flash_read = SPI_NOR_FAST;\r\nelse\r\nnor->flash_read = SPI_NOR_NORMAL;\r\n} else {\r\nnor->flash_read = SPI_NOR_FAST;\r\n}\r\nif (info->flags & SPI_NOR_NO_FR)\r\nnor->flash_read = SPI_NOR_NORMAL;\r\nif (mode == SPI_NOR_QUAD && info->flags & SPI_NOR_QUAD_READ) {\r\nret = set_quad_mode(nor, info);\r\nif (ret) {\r\ndev_err(dev, "quad mode not supported\n");\r\nreturn ret;\r\n}\r\nnor->flash_read = SPI_NOR_QUAD;\r\n} else if (mode == SPI_NOR_DUAL && info->flags & SPI_NOR_DUAL_READ) {\r\nnor->flash_read = SPI_NOR_DUAL;\r\n}\r\nswitch (nor->flash_read) {\r\ncase SPI_NOR_QUAD:\r\nnor->read_opcode = SPINOR_OP_READ_1_1_4;\r\nbreak;\r\ncase SPI_NOR_DUAL:\r\nnor->read_opcode = SPINOR_OP_READ_1_1_2;\r\nbreak;\r\ncase SPI_NOR_FAST:\r\nnor->read_opcode = SPINOR_OP_READ_FAST;\r\nbreak;\r\ncase SPI_NOR_NORMAL:\r\nnor->read_opcode = SPINOR_OP_READ;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "No Read opcode defined\n");\r\nreturn -EINVAL;\r\n}\r\nnor->program_opcode = SPINOR_OP_PP;\r\nif (info->addr_width)\r\nnor->addr_width = info->addr_width;\r\nelse if (mtd->size > 0x1000000) {\r\nnor->addr_width = 4;\r\nif (JEDEC_MFR(info) == SNOR_MFR_SPANSION) {\r\nswitch (nor->flash_read) {\r\ncase SPI_NOR_QUAD:\r\nnor->read_opcode = SPINOR_OP_READ4_1_1_4;\r\nbreak;\r\ncase SPI_NOR_DUAL:\r\nnor->read_opcode = SPINOR_OP_READ4_1_1_2;\r\nbreak;\r\ncase SPI_NOR_FAST:\r\nnor->read_opcode = SPINOR_OP_READ4_FAST;\r\nbreak;\r\ncase SPI_NOR_NORMAL:\r\nnor->read_opcode = SPINOR_OP_READ4;\r\nbreak;\r\n}\r\nnor->program_opcode = SPINOR_OP_PP_4B;\r\nnor->erase_opcode = SPINOR_OP_SE_4B;\r\nmtd->erasesize = info->sector_size;\r\n} else\r\nset_4byte(nor, info, 1);\r\n} else {\r\nnor->addr_width = 3;\r\n}\r\nif (nor->addr_width > SPI_NOR_MAX_ADDR_WIDTH) {\r\ndev_err(dev, "address width is too large: %u\n",\r\nnor->addr_width);\r\nreturn -EINVAL;\r\n}\r\nnor->read_dummy = spi_nor_read_dummy_cycles(nor);\r\ndev_info(dev, "%s (%lld Kbytes)\n", info->name,\r\n(long long)mtd->size >> 10);\r\ndev_dbg(dev,\r\n"mtd .name = %s, .size = 0x%llx (%lldMiB), "\r\n".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",\r\nmtd->name, (long long)mtd->size, (long long)(mtd->size >> 20),\r\nmtd->erasesize, mtd->erasesize / 1024, mtd->numeraseregions);\r\nif (mtd->numeraseregions)\r\nfor (i = 0; i < mtd->numeraseregions; i++)\r\ndev_dbg(dev,\r\n"mtd.eraseregions[%d] = { .offset = 0x%llx, "\r\n".erasesize = 0x%.8x (%uKiB), "\r\n".numblocks = %d }\n",\r\ni, (long long)mtd->eraseregions[i].offset,\r\nmtd->eraseregions[i].erasesize,\r\nmtd->eraseregions[i].erasesize / 1024,\r\nmtd->eraseregions[i].numblocks);\r\nreturn 0;\r\n}\r\nstatic const struct flash_info *spi_nor_match_id(const char *name)\r\n{\r\nconst struct flash_info *id = spi_nor_ids;\r\nwhile (id->name) {\r\nif (!strcmp(name, id->name))\r\nreturn id;\r\nid++;\r\n}\r\nreturn NULL;\r\n}
