static inline int nlm_link_msiirq(int link, int msivec)\r\n{\r\nreturn NLM_MSI_VEC_BASE + link * XLP_MSIVEC_PER_LINK + msivec;\r\n}\r\nstatic inline int nlm_irq_msivec(int irq)\r\n{\r\nreturn (irq - NLM_MSI_VEC_BASE) % XLP_MSIVEC_PER_LINK;\r\n}\r\nstatic inline int nlm_irq_msilink(int irq)\r\n{\r\nint total_msivec = XLP_MSIVEC_PER_LINK * PCIE_NLINKS;\r\nreturn ((irq - NLM_MSI_VEC_BASE) % total_msivec) /\r\nXLP_MSIVEC_PER_LINK;\r\n}\r\nstatic inline int nlm_link_msixirq(int link, int bit)\r\n{\r\nreturn NLM_MSIX_VEC_BASE + link * XLP_MSIXVEC_PER_LINK + bit;\r\n}\r\nstatic inline int nlm_irq_msixvec(int irq)\r\n{\r\nreturn (irq - NLM_MSIX_VEC_BASE) % XLP_MSIXVEC_TOTAL;\r\n}\r\nstatic inline int nlm_irq_msixlink(int msixvec)\r\n{\r\nreturn msixvec / XLP_MSIXVEC_PER_LINK;\r\n}\r\nstatic void xlp_msi_enable(struct irq_data *d)\r\n{\r\nstruct xlp_msi_data *md = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nint vec;\r\nvec = nlm_irq_msivec(d->irq);\r\nspin_lock_irqsave(&md->msi_lock, flags);\r\nmd->msi_enabled_mask |= 1u << vec;\r\nif (cpu_is_xlp9xx())\r\nnlm_write_reg(md->lnkbase, PCIE_9XX_MSI_EN,\r\nmd->msi_enabled_mask);\r\nelse\r\nnlm_write_reg(md->lnkbase, PCIE_MSI_EN, md->msi_enabled_mask);\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\n}\r\nstatic void xlp_msi_disable(struct irq_data *d)\r\n{\r\nstruct xlp_msi_data *md = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nint vec;\r\nvec = nlm_irq_msivec(d->irq);\r\nspin_lock_irqsave(&md->msi_lock, flags);\r\nmd->msi_enabled_mask &= ~(1u << vec);\r\nif (cpu_is_xlp9xx())\r\nnlm_write_reg(md->lnkbase, PCIE_9XX_MSI_EN,\r\nmd->msi_enabled_mask);\r\nelse\r\nnlm_write_reg(md->lnkbase, PCIE_MSI_EN, md->msi_enabled_mask);\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\n}\r\nstatic void xlp_msi_mask_ack(struct irq_data *d)\r\n{\r\nstruct xlp_msi_data *md = irq_data_get_irq_chip_data(d);\r\nint link, vec;\r\nlink = nlm_irq_msilink(d->irq);\r\nvec = nlm_irq_msivec(d->irq);\r\nxlp_msi_disable(d);\r\nif (cpu_is_xlp9xx())\r\nnlm_write_reg(md->lnkbase, PCIE_9XX_MSI_STATUS, 1u << vec);\r\nelse\r\nnlm_write_reg(md->lnkbase, PCIE_MSI_STATUS, 1u << vec);\r\n}\r\nstatic void xlp_msix_mask_ack(struct irq_data *d)\r\n{\r\nstruct xlp_msi_data *md;\r\nint link, msixvec;\r\nuint32_t status_reg, bit;\r\nmsixvec = nlm_irq_msixvec(d->irq);\r\nlink = nlm_irq_msixlink(msixvec);\r\npci_msi_mask_irq(d);\r\nmd = irq_data_get_irq_chip_data(d);\r\nif (cpu_is_xlp9xx()) {\r\nstatus_reg = PCIE_9XX_MSIX_STATUSX(link);\r\nbit = msixvec % XLP_MSIXVEC_PER_LINK;\r\n} else {\r\nstatus_reg = PCIE_MSIX_STATUS;\r\nbit = msixvec;\r\n}\r\nnlm_write_reg(md->lnkbase, status_reg, 1u << bit);\r\nif (!cpu_is_xlp9xx())\r\nnlm_pic_ack(md->node->picbase,\r\nPIC_IRT_PCIE_MSIX_INDEX(msixvec));\r\n}\r\nvoid arch_teardown_msi_irq(unsigned int irq)\r\n{\r\n}\r\nstatic void xlp_config_link_msi(uint64_t lnkbase, int lirq, uint64_t msiaddr)\r\n{\r\nu32 val;\r\nif (cpu_is_xlp9xx()) {\r\nval = nlm_read_reg(lnkbase, PCIE_9XX_INT_EN0);\r\nif ((val & 0x200) == 0) {\r\nval |= 0x200;\r\nnlm_write_reg(lnkbase, PCIE_9XX_INT_EN0, val);\r\n}\r\n} else {\r\nval = nlm_read_reg(lnkbase, PCIE_INT_EN0);\r\nif ((val & 0x200) == 0) {\r\nval |= 0x200;\r\nnlm_write_reg(lnkbase, PCIE_INT_EN0, val);\r\n}\r\n}\r\nval = nlm_read_reg(lnkbase, 0x1);\r\nif ((val & 0x0400) == 0) {\r\nval |= 0x0400;\r\nnlm_write_reg(lnkbase, 0x1, val);\r\n}\r\nval = nlm_read_pci_reg(lnkbase, 0xf);\r\nval &= ~0x1fu;\r\nval |= (1 << 8) | lirq;\r\nnlm_write_pci_reg(lnkbase, 0xf, val);\r\nnlm_write_reg(lnkbase, PCIE_BRIDGE_MSI_ADDRH, msiaddr >> 32);\r\nnlm_write_reg(lnkbase, PCIE_BRIDGE_MSI_ADDRL, msiaddr & 0xffffffff);\r\nval = nlm_read_reg(lnkbase, PCIE_BRIDGE_MSI_CAP);\r\nif ((val & (1 << 16)) == 0) {\r\nval |= 0xb << 16;\r\nnlm_write_reg(lnkbase, PCIE_BRIDGE_MSI_CAP, val);\r\n}\r\n}\r\nstatic int xlp_setup_msi(uint64_t lnkbase, int node, int link,\r\nstruct msi_desc *desc)\r\n{\r\nstruct xlp_msi_data *md;\r\nstruct msi_msg msg;\r\nunsigned long flags;\r\nint msivec, irt, lirq, xirq, ret;\r\nuint64_t msiaddr;\r\nlirq = PIC_PCIE_LINK_MSI_IRQ(link);\r\nxirq = nlm_irq_to_xirq(node, nlm_link_msiirq(link, 0));\r\nmd = irq_get_chip_data(xirq);\r\nmsiaddr = MSI_LINK_ADDR(node, link);\r\nspin_lock_irqsave(&md->msi_lock, flags);\r\nif (md->msi_alloc_mask == 0) {\r\nxlp_config_link_msi(lnkbase, lirq, msiaddr);\r\nif (cpu_is_xlp9xx())\r\nirt = PIC_9XX_IRT_PCIE_LINK_INDEX(link);\r\nelse\r\nirt = PIC_IRT_PCIE_LINK_INDEX(link);\r\nnlm_setup_pic_irq(node, lirq, lirq, irt);\r\nnlm_pic_init_irt(nlm_get_node(node)->picbase, irt, lirq,\r\nnode * nlm_threads_per_node(), 1 );\r\n}\r\nmsivec = fls(md->msi_alloc_mask);\r\nif (msivec == XLP_MSIVEC_PER_LINK) {\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nmd->msi_alloc_mask |= (1u << msivec);\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\nmsg.address_hi = msiaddr >> 32;\r\nmsg.address_lo = msiaddr & 0xffffffff;\r\nmsg.data = 0xc00 | msivec;\r\nxirq = xirq + msivec;\r\nret = irq_set_msi_desc(xirq, desc);\r\nif (ret < 0)\r\nreturn ret;\r\npci_write_msi_msg(xirq, &msg);\r\nreturn 0;\r\n}\r\nstatic void xlp_config_link_msix(uint64_t lnkbase, int lirq, uint64_t msixaddr)\r\n{\r\nu32 val;\r\nval = nlm_read_reg(lnkbase, 0x2C);\r\nif ((val & 0x80000000U) == 0) {\r\nval |= 0x80000000U;\r\nnlm_write_reg(lnkbase, 0x2C, val);\r\n}\r\nif (cpu_is_xlp9xx()) {\r\nval = nlm_read_reg(lnkbase, PCIE_9XX_INT_EN0);\r\nif ((val & 0x200) == 0) {\r\nval |= 0x200;\r\nnlm_write_reg(lnkbase, PCIE_9XX_INT_EN0, val);\r\n}\r\n} else {\r\nval = nlm_read_reg(lnkbase, PCIE_INT_EN0);\r\nif ((val & 0x200) == 0) {\r\nval |= 0x200;\r\nnlm_write_reg(lnkbase, PCIE_INT_EN0, val);\r\n}\r\n}\r\nval = nlm_read_reg(lnkbase, 0x1);\r\nif ((val & 0x0400) == 0) {\r\nval |= 0x0400;\r\nnlm_write_reg(lnkbase, 0x1, val);\r\n}\r\nval = nlm_read_pci_reg(lnkbase, 0xf);\r\nval &= ~0x1fu;\r\nval |= (1 << 8) | lirq;\r\nnlm_write_pci_reg(lnkbase, 0xf, val);\r\nif (cpu_is_xlp9xx()) {\r\nnlm_write_reg(lnkbase, PCIE_9XX_BRIDGE_MSIX_ADDR_BASE,\r\nmsixaddr >> 8);\r\nnlm_write_reg(lnkbase, PCIE_9XX_BRIDGE_MSIX_ADDR_LIMIT,\r\n(msixaddr + MSI_ADDR_SZ) >> 8);\r\n} else {\r\nnlm_write_reg(lnkbase, PCIE_BRIDGE_MSIX_ADDR_BASE,\r\nmsixaddr >> 8);\r\nnlm_write_reg(lnkbase, PCIE_BRIDGE_MSIX_ADDR_LIMIT,\r\n(msixaddr + MSI_ADDR_SZ) >> 8);\r\n}\r\n}\r\nstatic int xlp_setup_msix(uint64_t lnkbase, int node, int link,\r\nstruct msi_desc *desc)\r\n{\r\nstruct xlp_msi_data *md;\r\nstruct msi_msg msg;\r\nunsigned long flags;\r\nint t, msixvec, lirq, xirq, ret;\r\nuint64_t msixaddr;\r\nlirq = PIC_PCIE_MSIX_IRQ(link);\r\nxirq = nlm_irq_to_xirq(node, nlm_link_msixirq(link, 0));\r\nmd = irq_get_chip_data(xirq);\r\nmsixaddr = MSIX_LINK_ADDR(node, link);\r\nspin_lock_irqsave(&md->msi_lock, flags);\r\nif (md->msix_alloc_mask == 0)\r\nxlp_config_link_msix(lnkbase, lirq, msixaddr);\r\nt = fls(md->msix_alloc_mask);\r\nif (t == XLP_MSIXVEC_PER_LINK) {\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nmd->msix_alloc_mask |= (1u << t);\r\nspin_unlock_irqrestore(&md->msi_lock, flags);\r\nxirq += t;\r\nmsixvec = nlm_irq_msixvec(xirq);\r\nmsg.address_hi = msixaddr >> 32;\r\nmsg.address_lo = msixaddr & 0xffffffff;\r\nmsg.data = 0xc00 | msixvec;\r\nret = irq_set_msi_desc(xirq, desc);\r\nif (ret < 0)\r\nreturn ret;\r\npci_write_msi_msg(xirq, &msg);\r\nreturn 0;\r\n}\r\nint arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)\r\n{\r\nstruct pci_dev *lnkdev;\r\nuint64_t lnkbase;\r\nint node, link, slot;\r\nlnkdev = xlp_get_pcie_link(dev);\r\nif (lnkdev == NULL) {\r\ndev_err(&dev->dev, "Could not find bridge\n");\r\nreturn 1;\r\n}\r\nslot = PCI_SLOT(lnkdev->devfn);\r\nlink = PCI_FUNC(lnkdev->devfn);\r\nnode = slot / 8;\r\nlnkbase = nlm_get_pcie_base(node, link);\r\nif (desc->msi_attrib.is_msix)\r\nreturn xlp_setup_msix(lnkbase, node, link, desc);\r\nelse\r\nreturn xlp_setup_msi(lnkbase, node, link, desc);\r\n}\r\nvoid __init xlp_init_node_msi_irqs(int node, int link)\r\n{\r\nstruct nlm_soc_info *nodep;\r\nstruct xlp_msi_data *md;\r\nint irq, i, irt, msixvec, val;\r\npr_info("[%d %d] Init node PCI IRT\n", node, link);\r\nnodep = nlm_get_node(node);\r\nmd = kzalloc(sizeof(*md), GFP_KERNEL);\r\nspin_lock_init(&md->msi_lock);\r\nmd->msi_enabled_mask = 0;\r\nmd->msi_alloc_mask = 0;\r\nmd->msix_alloc_mask = 0;\r\nmd->node = nodep;\r\nmd->lnkbase = nlm_get_pcie_base(node, link);\r\nirq = nlm_irq_to_xirq(node, nlm_link_msiirq(link, 0));\r\nfor (i = irq; i < irq + XLP_MSIVEC_PER_LINK; i++) {\r\nirq_set_chip_and_handler(i, &xlp_msi_chip, handle_level_irq);\r\nirq_set_chip_data(i, md);\r\n}\r\nfor (i = 0; i < XLP_MSIXVEC_PER_LINK ; i++) {\r\nif (cpu_is_xlp9xx()) {\r\nval = ((node * nlm_threads_per_node()) << 7 |\r\nPIC_PCIE_MSIX_IRQ(link) << 1 | 0 << 0);\r\nnlm_write_pcie_reg(md->lnkbase, PCIE_9XX_MSIX_VECX(i +\r\n(link * XLP_MSIXVEC_PER_LINK)), val);\r\n} else {\r\nmsixvec = link * XLP_MSIXVEC_PER_LINK + i;\r\nirt = PIC_IRT_PCIE_MSIX_INDEX(msixvec);\r\nnlm_pic_init_irt(nodep->picbase, irt,\r\nPIC_PCIE_MSIX_IRQ(link),\r\nnode * nlm_threads_per_node(), 1);\r\n}\r\nirq = nlm_irq_to_xirq(node, nlm_link_msixirq(link, i));\r\nirq_set_chip_and_handler(irq, &xlp_msix_chip, handle_level_irq);\r\nirq_set_chip_data(irq, md);\r\n}\r\n}\r\nvoid nlm_dispatch_msi(int node, int lirq)\r\n{\r\nstruct xlp_msi_data *md;\r\nint link, i, irqbase;\r\nu32 status;\r\nlink = lirq - PIC_PCIE_LINK_MSI_IRQ_BASE;\r\nirqbase = nlm_irq_to_xirq(node, nlm_link_msiirq(link, 0));\r\nmd = irq_get_chip_data(irqbase);\r\nif (cpu_is_xlp9xx())\r\nstatus = nlm_read_reg(md->lnkbase, PCIE_9XX_MSI_STATUS) &\r\nmd->msi_enabled_mask;\r\nelse\r\nstatus = nlm_read_reg(md->lnkbase, PCIE_MSI_STATUS) &\r\nmd->msi_enabled_mask;\r\nwhile (status) {\r\ni = __ffs(status);\r\ndo_IRQ(irqbase + i);\r\nstatus &= status - 1;\r\n}\r\nack_c0_eirr(PIC_PCIE_LINK_MSI_IRQ(link));\r\nif (cpu_is_xlp9xx())\r\nnlm_pic_ack(md->node->picbase,\r\nPIC_9XX_IRT_PCIE_LINK_INDEX(link));\r\nelse\r\nnlm_pic_ack(md->node->picbase, PIC_IRT_PCIE_LINK_INDEX(link));\r\n}\r\nvoid nlm_dispatch_msix(int node, int lirq)\r\n{\r\nstruct xlp_msi_data *md;\r\nint link, i, irqbase;\r\nu32 status;\r\nlink = lirq - PIC_PCIE_MSIX_IRQ_BASE;\r\nirqbase = nlm_irq_to_xirq(node, nlm_link_msixirq(link, 0));\r\nmd = irq_get_chip_data(irqbase);\r\nif (cpu_is_xlp9xx())\r\nstatus = nlm_read_reg(md->lnkbase, PCIE_9XX_MSIX_STATUSX(link));\r\nelse\r\nstatus = nlm_read_reg(md->lnkbase, PCIE_MSIX_STATUS);\r\nif (!cpu_is_xlp9xx())\r\nstatus = (status >> (link * XLP_MSIXVEC_PER_LINK)) &\r\n((1 << XLP_MSIXVEC_PER_LINK) - 1);\r\nwhile (status) {\r\ni = __ffs(status);\r\ndo_IRQ(irqbase + i);\r\nstatus &= status - 1;\r\n}\r\nack_c0_eirr(PIC_PCIE_MSIX_IRQ(link));\r\n}
