static void\r\nstart_port(struct dbg_port* p)\r\n{\r\nunsigned long rec_ctrl = 0;\r\nunsigned long tr_ctrl = 0;\r\nif (!p)\r\nreturn;\r\nif (p->started)\r\nreturn;\r\np->started = 1;\r\nif (p->index == 0)\r\n{\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma6);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma6, unused);\r\n}\r\nelse if (p->index == 1)\r\n{\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma8);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma8, usb);\r\n}\r\nelse if (p->index == 2)\r\n{\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma2);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma2, par0);\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma3);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma3, par0);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, ser2, select);\r\n}\r\nelse\r\n{\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma4);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma4, par1);\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma5);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma5, par1);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, ser3, select);\r\n}\r\n*R_GEN_CONFIG = genconfig_shadow;\r\n*p->xoff =\r\nIO_STATE(R_SERIAL0_XOFF, tx_stop, enable) |\r\nIO_STATE(R_SERIAL0_XOFF, auto_xoff, disable) |\r\nIO_FIELD(R_SERIAL0_XOFF, xoff_char, 0);\r\nswitch (p->baudrate)\r\n{\r\ncase 0:\r\ncase 115200:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c115k2Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c115k2Hz);\r\nbreak;\r\ncase 1200:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c1200Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c1200Hz);\r\nbreak;\r\ncase 2400:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c2400Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c2400Hz);\r\nbreak;\r\ncase 4800:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c4800Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c4800Hz);\r\nbreak;\r\ncase 9600:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c9600Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c9600Hz);\r\nbreak;\r\ncase 19200:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c19k2Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c19k2Hz);\r\nbreak;\r\ncase 38400:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c38k4Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c38k4Hz);\r\nbreak;\r\ncase 57600:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c57k6Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c57k6Hz);\r\nbreak;\r\ndefault:\r\n*p->baud =\r\nIO_STATE(R_SERIAL0_BAUD, tr_baud, c115k2Hz) |\r\nIO_STATE(R_SERIAL0_BAUD, rec_baud, c115k2Hz);\r\nbreak;\r\n}\r\nif (p->parity == 'E') {\r\nrec_ctrl =\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par, even) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par_en, enable);\r\ntr_ctrl =\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par, even) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par_en, enable);\r\n} else if (p->parity == 'O') {\r\nrec_ctrl =\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par, odd) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par_en, enable);\r\ntr_ctrl =\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par, odd) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par_en, enable);\r\n} else {\r\nrec_ctrl =\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par, even) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_par_en, disable);\r\ntr_ctrl =\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par, even) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_par_en, disable);\r\n}\r\nif (p->bits == 7)\r\n{\r\nrec_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_bitnr, rec_7bit);\r\ntr_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_bitnr, tr_7bit);\r\n}\r\nelse\r\n{\r\nrec_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_bitnr, rec_8bit);\r\ntr_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_bitnr, tr_8bit);\r\n}\r\n*p->rec_ctrl =\r\nIO_STATE(R_SERIAL0_REC_CTRL, dma_err, stop) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_enable, enable) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rts_, active) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, sampling, middle) |\r\nIO_STATE(R_SERIAL0_REC_CTRL, rec_stick_par, normal) |\r\nrec_ctrl;\r\n*p->tr_ctrl =\r\nIO_FIELD(R_SERIAL0_TR_CTRL, txd, 0) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_enable, enable) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, auto_cts, disabled) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, stop_bits, one_bit) |\r\nIO_STATE(R_SERIAL0_TR_CTRL, tr_stick_par, normal) |\r\ntr_ctrl;\r\n}\r\nstatic void\r\nconsole_write_direct(struct console *co, const char *buf, unsigned int len)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (!port)\r\nreturn;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < len; i++) {\r\nif (buf[i] == '\n') {\r\nwhile (!(*port->read & IO_MASK(R_SERIAL0_READ, tr_ready)))\r\n;\r\n*port->write = '\r';\r\n}\r\nwhile (!(*port->read & IO_MASK(R_SERIAL0_READ, tr_ready)))\r\n;\r\n*port->write = buf[i];\r\n}\r\nreset_watchdog();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nconsole_write(struct console *co, const char *buf, unsigned int len)\r\n{\r\nif (!port)\r\nreturn;\r\nconsole_write_direct(co, buf, len);\r\n}\r\nvoid\r\nconsole_print_etrax(const char *buf)\r\n{\r\nconsole_write(NULL, buf, strlen(buf));\r\n}\r\nint\r\ngetDebugChar(void)\r\n{\r\nunsigned long readval;\r\nif (!kgdb_port)\r\nreturn 0;\r\ndo {\r\nreadval = *kgdb_port->read;\r\n} while (!(readval & IO_MASK(R_SERIAL0_READ, data_avail)));\r\nreturn (readval & IO_MASK(R_SERIAL0_READ, data_in));\r\n}\r\nvoid\r\nputDebugChar(int val)\r\n{\r\nif (!kgdb_port)\r\nreturn;\r\nwhile (!(*kgdb_port->read & IO_MASK(R_SERIAL0_READ, tr_ready)))\r\n;\r\n*kgdb_port->write = val;\r\n}\r\nvoid\r\nenableDebugIRQ(void)\r\n{\r\nif (!kgdb_port)\r\nreturn;\r\n*R_IRQ_MASK1_SET = kgdb_port->irq;\r\n*R_VECT_MASK_SET = IO_STATE(R_VECT_MASK_SET, serial, set);\r\n*kgdb_port->rec_ctrl = IO_STATE(R_SERIAL0_REC_CTRL, rec_enable, enable);\r\n}\r\nstatic int __init\r\nconsole_setup(struct console *co, char *options)\r\n{\r\nchar* s;\r\nif (options) {\r\nport = &ports[co->index];\r\nport->baudrate = 115200;\r\nport->parity = 'N';\r\nport->bits = 8;\r\nport->baudrate = simple_strtoul(options, NULL, 10);\r\ns = options;\r\nwhile(*s >= '0' && *s <= '9')\r\ns++;\r\nif (*s) port->parity = *s++;\r\nif (*s) port->bits = *s++ - '0';\r\nport->started = 0;\r\nstart_port(0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void dummy_close(struct tty_struct *tty, struct file * filp)\r\n{\r\n}\r\nstatic int dummy_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nreturn count;\r\n}\r\nstatic int dummy_write_room(struct tty_struct *tty)\r\n{\r\nreturn 8192;\r\n}\r\nvoid __init\r\ninit_dummy_console(void)\r\n{\r\nmemset(&dummy_driver, 0, sizeof(struct tty_driver));\r\ndummy_driver.driver_name = "serial";\r\ndummy_driver.name = "ttyS";\r\ndummy_driver.major = TTY_MAJOR;\r\ndummy_driver.minor_start = 68;\r\ndummy_driver.num = 1;\r\ndummy_driver.type = TTY_DRIVER_TYPE_SERIAL;\r\ndummy_driver.subtype = SERIAL_TYPE_NORMAL;\r\ndummy_driver.init_termios = tty_std_termios;\r\ndummy_driver.init_termios.c_cflag =\r\nB115200 | CS8 | CREAD | HUPCL | CLOCAL;\r\ndummy_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ndummy_driver.init_termios.c_ispeed = 115200;\r\ndummy_driver.init_termios.c_ospeed = 115200;\r\ndummy_driver.ops = &dummy_ops;\r\nif (tty_register_driver(&dummy_driver))\r\npanic("Couldn't register dummy serial driver\n");\r\n}\r\nstatic struct tty_driver*\r\netrax_console_device(struct console* co, int *index)\r\n{\r\nif (port)\r\n*index = port->index;\r\nelse\r\n*index = 0;\r\n#ifdef CONFIG_ETRAX_SERIAL\r\nreturn port ? serial_driver : &dummy_driver;\r\n#else\r\nreturn &dummy_driver;\r\n#endif\r\n}\r\nint __init\r\ninit_etrax_debug(void)\r\n{\r\nstatic int first = 1;\r\nif (!first) {\r\nunregister_console(&ser_console);\r\nregister_console(&ser0_console);\r\nregister_console(&ser1_console);\r\nregister_console(&ser2_console);\r\nregister_console(&ser3_console);\r\ninit_dummy_console();\r\nreturn 0;\r\n}\r\nfirst = 0;\r\nregister_console(&ser_console);\r\nstart_port(port);\r\n#ifdef CONFIG_ETRAX_KGDB\r\nstart_port(kgdb_port);\r\n#endif\r\nreturn 0;\r\n}
