static irqreturn_t rx8010_irq_1_handler(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct rx8010_data *rx8010 = i2c_get_clientdata(client);\r\nint flagreg;\r\nspin_lock(&rx8010->flags_lock);\r\nflagreg = i2c_smbus_read_byte_data(client, RX8010_FLAG);\r\nif (flagreg <= 0) {\r\nspin_unlock(&rx8010->flags_lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (flagreg & RX8010_FLAG_VLF)\r\ndev_warn(&client->dev, "Frequency stop detected\n");\r\nif (flagreg & RX8010_FLAG_TF) {\r\nflagreg &= ~RX8010_FLAG_TF;\r\nrtc_update_irq(rx8010->rtc, 1, RTC_PF | RTC_IRQF);\r\n}\r\nif (flagreg & RX8010_FLAG_AF) {\r\nflagreg &= ~RX8010_FLAG_AF;\r\nrtc_update_irq(rx8010->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nif (flagreg & RX8010_FLAG_UF) {\r\nflagreg &= ~RX8010_FLAG_UF;\r\nrtc_update_irq(rx8010->rtc, 1, RTC_UF | RTC_IRQF);\r\n}\r\ni2c_smbus_write_byte_data(client, RX8010_FLAG, flagreg);\r\nspin_unlock(&rx8010->flags_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rx8010_get_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint flagreg;\r\nint err;\r\nflagreg = i2c_smbus_read_byte_data(rx8010->client, RX8010_FLAG);\r\nif (flagreg < 0)\r\nreturn flagreg;\r\nif (flagreg & RX8010_FLAG_VLF) {\r\ndev_warn(dev, "Frequency stop detected\n");\r\nreturn -EINVAL;\r\n}\r\nerr = i2c_smbus_read_i2c_block_data(rx8010->client, RX8010_SEC,\r\n7, date);\r\nif (err != 7)\r\nreturn err < 0 ? err : -EIO;\r\ndt->tm_sec = bcd2bin(date[RX8010_SEC - RX8010_SEC] & 0x7f);\r\ndt->tm_min = bcd2bin(date[RX8010_MIN - RX8010_SEC] & 0x7f);\r\ndt->tm_hour = bcd2bin(date[RX8010_HOUR - RX8010_SEC] & 0x3f);\r\ndt->tm_mday = bcd2bin(date[RX8010_MDAY - RX8010_SEC] & 0x3f);\r\ndt->tm_mon = bcd2bin(date[RX8010_MONTH - RX8010_SEC] & 0x1f) - 1;\r\ndt->tm_year = bcd2bin(date[RX8010_YEAR - RX8010_SEC]) + 100;\r\ndt->tm_wday = ffs(date[RX8010_WDAY - RX8010_SEC] & 0x7f);\r\nreturn rtc_valid_tm(dt);\r\n}\r\nstatic int rx8010_set_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint ctrl, flagreg;\r\nint ret;\r\nunsigned long irqflags;\r\nif ((dt->tm_year < 100) || (dt->tm_year > 199))\r\nreturn -EINVAL;\r\nctrl = i2c_smbus_read_byte_data(rx8010->client, RX8010_CTRL);\r\nif (ctrl < 0)\r\nreturn ctrl;\r\nrx8010->ctrlreg = ctrl | RX8010_CTRL_STOP;\r\nret = i2c_smbus_write_byte_data(rx8010->client, RX8010_CTRL,\r\nrx8010->ctrlreg);\r\nif (ret < 0)\r\nreturn ret;\r\ndate[RX8010_SEC - RX8010_SEC] = bin2bcd(dt->tm_sec);\r\ndate[RX8010_MIN - RX8010_SEC] = bin2bcd(dt->tm_min);\r\ndate[RX8010_HOUR - RX8010_SEC] = bin2bcd(dt->tm_hour);\r\ndate[RX8010_MDAY - RX8010_SEC] = bin2bcd(dt->tm_mday);\r\ndate[RX8010_MONTH - RX8010_SEC] = bin2bcd(dt->tm_mon + 1);\r\ndate[RX8010_YEAR - RX8010_SEC] = bin2bcd(dt->tm_year - 100);\r\ndate[RX8010_WDAY - RX8010_SEC] = bin2bcd(1 << dt->tm_wday);\r\nret = i2c_smbus_write_i2c_block_data(rx8010->client,\r\nRX8010_SEC, 7, date);\r\nif (ret < 0)\r\nreturn ret;\r\nctrl = i2c_smbus_read_byte_data(rx8010->client, RX8010_CTRL);\r\nif (ctrl < 0)\r\nreturn ctrl;\r\nrx8010->ctrlreg = ctrl & ~RX8010_CTRL_STOP;\r\nret = i2c_smbus_write_byte_data(rx8010->client, RX8010_CTRL,\r\nrx8010->ctrlreg);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_irqsave(&rx8010->flags_lock, irqflags);\r\nflagreg = i2c_smbus_read_byte_data(rx8010->client, RX8010_FLAG);\r\nif (flagreg < 0) {\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nreturn flagreg;\r\n}\r\nif (flagreg & RX8010_FLAG_VLF)\r\nret = i2c_smbus_write_byte_data(rx8010->client, RX8010_FLAG,\r\nflagreg & ~RX8010_FLAG_VLF);\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nreturn 0;\r\n}\r\nstatic int rx8010_init_client(struct i2c_client *client)\r\n{\r\nstruct rx8010_data *rx8010 = i2c_get_clientdata(client);\r\nu8 ctrl[2];\r\nint need_clear = 0, err = 0;\r\nerr = i2c_smbus_write_byte_data(client, RX8010_RESV17, 0xD8);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(client, RX8010_RESV30, 0x00);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(client, RX8010_RESV31, 0x08);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(client, RX8010_IRQ, 0x00);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_read_i2c_block_data(rx8010->client, RX8010_FLAG,\r\n2, ctrl);\r\nif (err != 2)\r\nreturn err < 0 ? err : -EIO;\r\nif (ctrl[0] & RX8010_FLAG_VLF)\r\ndev_warn(&client->dev, "Frequency stop was detected\n");\r\nif (ctrl[0] & RX8010_FLAG_AF) {\r\ndev_warn(&client->dev, "Alarm was detected\n");\r\nneed_clear = 1;\r\n}\r\nif (ctrl[0] & RX8010_FLAG_TF)\r\nneed_clear = 1;\r\nif (ctrl[0] & RX8010_FLAG_UF)\r\nneed_clear = 1;\r\nif (need_clear) {\r\nctrl[0] &= ~(RX8010_FLAG_AF | RX8010_FLAG_TF | RX8010_FLAG_UF);\r\nerr = i2c_smbus_write_byte_data(client, RX8010_FLAG, ctrl[0]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nrx8010->ctrlreg = (ctrl[1] & ~RX8010_CTRL_TEST);\r\nreturn err;\r\n}\r\nstatic int rx8010_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = rx8010->client;\r\nu8 alarmvals[3];\r\nint flagreg;\r\nint err;\r\nerr = i2c_smbus_read_i2c_block_data(client, RX8010_ALMIN, 3, alarmvals);\r\nif (err != 3)\r\nreturn err < 0 ? err : -EIO;\r\nflagreg = i2c_smbus_read_byte_data(client, RX8010_FLAG);\r\nif (flagreg < 0)\r\nreturn flagreg;\r\nt->time.tm_sec = 0;\r\nt->time.tm_min = bcd2bin(alarmvals[0] & 0x7f);\r\nt->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\r\nif (!(alarmvals[2] & RX8010_ALARM_AE))\r\nt->time.tm_mday = bcd2bin(alarmvals[2] & 0x7f);\r\nt->enabled = !!(rx8010->ctrlreg & RX8010_CTRL_AIE);\r\nt->pending = (flagreg & RX8010_FLAG_AF) && t->enabled;\r\nreturn err;\r\n}\r\nstatic int rx8010_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nu8 alarmvals[3];\r\nint extreg, flagreg;\r\nint err;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&rx8010->flags_lock, irqflags);\r\nflagreg = i2c_smbus_read_byte_data(client, RX8010_FLAG);\r\nif (flagreg < 0) {\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nreturn flagreg;\r\n}\r\nif (rx8010->ctrlreg & (RX8010_CTRL_AIE | RX8010_CTRL_UIE)) {\r\nrx8010->ctrlreg &= ~(RX8010_CTRL_AIE | RX8010_CTRL_UIE);\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_CTRL,\r\nrx8010->ctrlreg);\r\nif (err < 0) {\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nreturn err;\r\n}\r\n}\r\nflagreg &= ~RX8010_FLAG_AF;\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_FLAG, flagreg);\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nif (err < 0)\r\nreturn err;\r\nalarmvals[0] = bin2bcd(t->time.tm_min);\r\nalarmvals[1] = bin2bcd(t->time.tm_hour);\r\nalarmvals[2] = bin2bcd(t->time.tm_mday);\r\nerr = i2c_smbus_write_i2c_block_data(rx8010->client, RX8010_ALMIN,\r\n2, alarmvals);\r\nif (err < 0)\r\nreturn err;\r\nextreg = i2c_smbus_read_byte_data(client, RX8010_EXT);\r\nif (extreg < 0)\r\nreturn extreg;\r\nextreg |= RX8010_EXT_WADA;\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_EXT, extreg);\r\nif (err < 0)\r\nreturn err;\r\nif (alarmvals[2] == 0)\r\nalarmvals[2] |= RX8010_ALARM_AE;\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_ALWDAY,\r\nalarmvals[2]);\r\nif (err < 0)\r\nreturn err;\r\nif (t->enabled) {\r\nif (rx8010->rtc->uie_rtctimer.enabled)\r\nrx8010->ctrlreg |= RX8010_CTRL_UIE;\r\nif (rx8010->rtc->aie_timer.enabled)\r\nrx8010->ctrlreg |=\r\n(RX8010_CTRL_AIE | RX8010_CTRL_UIE);\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_CTRL,\r\nrx8010->ctrlreg);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8010_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nint flagreg;\r\nu8 ctrl;\r\nint err;\r\nctrl = rx8010->ctrlreg;\r\nif (enabled) {\r\nif (rx8010->rtc->uie_rtctimer.enabled)\r\nctrl |= RX8010_CTRL_UIE;\r\nif (rx8010->rtc->aie_timer.enabled)\r\nctrl |= (RX8010_CTRL_AIE | RX8010_CTRL_UIE);\r\n} else {\r\nif (!rx8010->rtc->uie_rtctimer.enabled)\r\nctrl &= ~RX8010_CTRL_UIE;\r\nif (!rx8010->rtc->aie_timer.enabled)\r\nctrl &= ~RX8010_CTRL_AIE;\r\n}\r\nflagreg = i2c_smbus_read_byte_data(client, RX8010_FLAG);\r\nif (flagreg < 0)\r\nreturn flagreg;\r\nflagreg &= ~RX8010_FLAG_AF;\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_FLAG, flagreg);\r\nif (err < 0)\r\nreturn err;\r\nif (ctrl != rx8010->ctrlreg) {\r\nrx8010->ctrlreg = ctrl;\r\nerr = i2c_smbus_write_byte_data(rx8010->client, RX8010_CTRL,\r\nrx8010->ctrlreg);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8010_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\r\nint ret, tmp;\r\nint flagreg;\r\nunsigned long irqflags;\r\nswitch (cmd) {\r\ncase RTC_VL_READ:\r\nflagreg = i2c_smbus_read_byte_data(rx8010->client, RX8010_FLAG);\r\nif (flagreg < 0)\r\nreturn flagreg;\r\ntmp = !!(flagreg & RX8010_FLAG_VLF);\r\nif (copy_to_user((void __user *)arg, &tmp, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase RTC_VL_CLR:\r\nspin_lock_irqsave(&rx8010->flags_lock, irqflags);\r\nflagreg = i2c_smbus_read_byte_data(rx8010->client, RX8010_FLAG);\r\nif (flagreg < 0) {\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nreturn flagreg;\r\n}\r\nflagreg &= ~RX8010_FLAG_VLF;\r\nret = i2c_smbus_write_byte_data(client, RX8010_FLAG, flagreg);\r\nspin_unlock_irqrestore(&rx8010->flags_lock, irqflags);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int rx8010_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct rx8010_data *rx8010;\r\nint err = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(&adapter->dev, "doesn't support required functionality\n");\r\nreturn -EIO;\r\n}\r\nrx8010 = devm_kzalloc(&client->dev, sizeof(struct rx8010_data),\r\nGFP_KERNEL);\r\nif (!rx8010)\r\nreturn -ENOMEM;\r\nrx8010->client = client;\r\ni2c_set_clientdata(client, rx8010);\r\nspin_lock_init(&rx8010->flags_lock);\r\nerr = rx8010_init_client(client);\r\nif (err)\r\nreturn err;\r\nif (client->irq > 0) {\r\ndev_info(&client->dev, "IRQ %d supplied\n", client->irq);\r\nerr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nrx8010_irq_1_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"rx8010", client);\r\nif (err) {\r\ndev_err(&client->dev, "unable to request IRQ\n");\r\nclient->irq = 0;\r\n} else {\r\nrx8010_rtc_ops.read_alarm = rx8010_read_alarm;\r\nrx8010_rtc_ops.set_alarm = rx8010_set_alarm;\r\nrx8010_rtc_ops.alarm_irq_enable = rx8010_alarm_irq_enable;\r\n}\r\n}\r\nrx8010->rtc = devm_rtc_device_register(&client->dev, client->name,\r\n&rx8010_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rx8010->rtc)) {\r\ndev_err(&client->dev, "unable to register the class device\n");\r\nreturn PTR_ERR(rx8010->rtc);\r\n}\r\nrx8010->rtc->max_user_freq = 1;\r\nreturn err;\r\n}
