static int atmel_tdes_sg_copy(struct scatterlist **sg, size_t *offset,\r\nvoid *buf, size_t buflen, size_t total, int out)\r\n{\r\nunsigned int count, off = 0;\r\nwhile (buflen && total) {\r\ncount = min((*sg)->length - *offset, total);\r\ncount = min(count, buflen);\r\nif (!count)\r\nreturn off;\r\nscatterwalk_map_and_copy(buf + off, *sg, *offset, count, out);\r\noff += count;\r\nbuflen -= count;\r\n*offset += count;\r\ntotal -= count;\r\nif (*offset == (*sg)->length) {\r\n*sg = sg_next(*sg);\r\nif (*sg)\r\n*offset = 0;\r\nelse\r\ntotal = 0;\r\n}\r\n}\r\nreturn off;\r\n}\r\nstatic inline u32 atmel_tdes_read(struct atmel_tdes_dev *dd, u32 offset)\r\n{\r\nreturn readl_relaxed(dd->io_base + offset);\r\n}\r\nstatic inline void atmel_tdes_write(struct atmel_tdes_dev *dd,\r\nu32 offset, u32 value)\r\n{\r\nwritel_relaxed(value, dd->io_base + offset);\r\n}\r\nstatic void atmel_tdes_write_n(struct atmel_tdes_dev *dd, u32 offset,\r\nu32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\natmel_tdes_write(dd, offset, *value);\r\n}\r\nstatic struct atmel_tdes_dev *atmel_tdes_find_dev(struct atmel_tdes_ctx *ctx)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd = NULL;\r\nstruct atmel_tdes_dev *tmp;\r\nspin_lock_bh(&atmel_tdes.lock);\r\nif (!ctx->dd) {\r\nlist_for_each_entry(tmp, &atmel_tdes.dev_list, list) {\r\ntdes_dd = tmp;\r\nbreak;\r\n}\r\nctx->dd = tdes_dd;\r\n} else {\r\ntdes_dd = ctx->dd;\r\n}\r\nspin_unlock_bh(&atmel_tdes.lock);\r\nreturn tdes_dd;\r\n}\r\nstatic int atmel_tdes_hw_init(struct atmel_tdes_dev *dd)\r\n{\r\nint err;\r\nerr = clk_prepare_enable(dd->iclk);\r\nif (err)\r\nreturn err;\r\nif (!(dd->flags & TDES_FLAGS_INIT)) {\r\natmel_tdes_write(dd, TDES_CR, TDES_CR_SWRST);\r\ndd->flags |= TDES_FLAGS_INIT;\r\ndd->err = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int atmel_tdes_get_version(struct atmel_tdes_dev *dd)\r\n{\r\nreturn atmel_tdes_read(dd, TDES_HW_VERSION) & 0x00000fff;\r\n}\r\nstatic void atmel_tdes_hw_version_init(struct atmel_tdes_dev *dd)\r\n{\r\natmel_tdes_hw_init(dd);\r\ndd->hw_version = atmel_tdes_get_version(dd);\r\ndev_info(dd->dev,\r\n"version: 0x%x\n", dd->hw_version);\r\nclk_disable_unprepare(dd->iclk);\r\n}\r\nstatic void atmel_tdes_dma_callback(void *data)\r\n{\r\nstruct atmel_tdes_dev *dd = data;\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nstatic int atmel_tdes_write_ctrl(struct atmel_tdes_dev *dd)\r\n{\r\nint err;\r\nu32 valcr = 0, valmr = TDES_MR_SMOD_PDC;\r\nerr = atmel_tdes_hw_init(dd);\r\nif (err)\r\nreturn err;\r\nif (!dd->caps.has_dma)\r\natmel_tdes_write(dd, TDES_PTCR,\r\nTDES_PTCR_TXTDIS | TDES_PTCR_RXTDIS);\r\nif (dd->ctx->keylen > (DES_KEY_SIZE << 1)) {\r\nvalmr |= TDES_MR_KEYMOD_3KEY;\r\nvalmr |= TDES_MR_TDESMOD_TDES;\r\n} else if (dd->ctx->keylen > DES_KEY_SIZE) {\r\nvalmr |= TDES_MR_KEYMOD_2KEY;\r\nvalmr |= TDES_MR_TDESMOD_TDES;\r\n} else {\r\nvalmr |= TDES_MR_TDESMOD_DES;\r\n}\r\nif (dd->flags & TDES_FLAGS_CBC) {\r\nvalmr |= TDES_MR_OPMOD_CBC;\r\n} else if (dd->flags & TDES_FLAGS_CFB) {\r\nvalmr |= TDES_MR_OPMOD_CFB;\r\nif (dd->flags & TDES_FLAGS_CFB8)\r\nvalmr |= TDES_MR_CFBS_8b;\r\nelse if (dd->flags & TDES_FLAGS_CFB16)\r\nvalmr |= TDES_MR_CFBS_16b;\r\nelse if (dd->flags & TDES_FLAGS_CFB32)\r\nvalmr |= TDES_MR_CFBS_32b;\r\nelse if (dd->flags & TDES_FLAGS_CFB64)\r\nvalmr |= TDES_MR_CFBS_64b;\r\n} else if (dd->flags & TDES_FLAGS_OFB) {\r\nvalmr |= TDES_MR_OPMOD_OFB;\r\n}\r\nif ((dd->flags & TDES_FLAGS_ENCRYPT) || (dd->flags & TDES_FLAGS_OFB))\r\nvalmr |= TDES_MR_CYPHER_ENC;\r\natmel_tdes_write(dd, TDES_CR, valcr);\r\natmel_tdes_write(dd, TDES_MR, valmr);\r\natmel_tdes_write_n(dd, TDES_KEY1W1R, dd->ctx->key,\r\ndd->ctx->keylen >> 2);\r\nif (((dd->flags & TDES_FLAGS_CBC) || (dd->flags & TDES_FLAGS_CFB) ||\r\n(dd->flags & TDES_FLAGS_OFB)) && dd->req->info) {\r\natmel_tdes_write_n(dd, TDES_IV1R, dd->req->info, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_crypt_pdc_stop(struct atmel_tdes_dev *dd)\r\n{\r\nint err = 0;\r\nsize_t count;\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\r\nif (dd->flags & TDES_FLAGS_FAST) {\r\ndma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\n} else {\r\ndma_sync_single_for_device(dd->dev, dd->dma_addr_out,\r\ndd->dma_size, DMA_FROM_DEVICE);\r\ncount = atmel_tdes_sg_copy(&dd->out_sg, &dd->out_offset,\r\ndd->buf_out, dd->buflen, dd->dma_size, 1);\r\nif (count != dd->dma_size) {\r\nerr = -EINVAL;\r\npr_err("not all data converted: %u\n", count);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_buff_init(struct atmel_tdes_dev *dd)\r\n{\r\nint err = -ENOMEM;\r\ndd->buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);\r\ndd->buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);\r\ndd->buflen = PAGE_SIZE;\r\ndd->buflen &= ~(DES_BLOCK_SIZE - 1);\r\nif (!dd->buf_in || !dd->buf_out) {\r\ndev_err(dd->dev, "unable to alloc pages.\n");\r\ngoto err_alloc;\r\n}\r\ndd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in,\r\ndd->buflen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dd->dev, dd->dma_addr_in)) {\r\ndev_err(dd->dev, "dma %d bytes error\n", dd->buflen);\r\nerr = -EINVAL;\r\ngoto err_map_in;\r\n}\r\ndd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out,\r\ndd->buflen, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dd->dev, dd->dma_addr_out)) {\r\ndev_err(dd->dev, "dma %d bytes error\n", dd->buflen);\r\nerr = -EINVAL;\r\ngoto err_map_out;\r\n}\r\nreturn 0;\r\nerr_map_out:\r\ndma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\r\nDMA_TO_DEVICE);\r\nerr_map_in:\r\nerr_alloc:\r\nfree_page((unsigned long)dd->buf_out);\r\nfree_page((unsigned long)dd->buf_in);\r\nif (err)\r\npr_err("error: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_buff_cleanup(struct atmel_tdes_dev *dd)\r\n{\r\ndma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\r\nDMA_TO_DEVICE);\r\nfree_page((unsigned long)dd->buf_out);\r\nfree_page((unsigned long)dd->buf_in);\r\n}\r\nstatic int atmel_tdes_crypt_pdc(struct crypto_tfm *tfm, dma_addr_t dma_addr_in,\r\ndma_addr_t dma_addr_out, int length)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct atmel_tdes_dev *dd = ctx->dd;\r\nint len32;\r\ndd->dma_size = length;\r\nif (!(dd->flags & TDES_FLAGS_FAST)) {\r\ndma_sync_single_for_device(dd->dev, dma_addr_in, length,\r\nDMA_TO_DEVICE);\r\n}\r\nif ((dd->flags & TDES_FLAGS_CFB) && (dd->flags & TDES_FLAGS_CFB8))\r\nlen32 = DIV_ROUND_UP(length, sizeof(u8));\r\nelse if ((dd->flags & TDES_FLAGS_CFB) && (dd->flags & TDES_FLAGS_CFB16))\r\nlen32 = DIV_ROUND_UP(length, sizeof(u16));\r\nelse\r\nlen32 = DIV_ROUND_UP(length, sizeof(u32));\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\r\natmel_tdes_write(dd, TDES_TPR, dma_addr_in);\r\natmel_tdes_write(dd, TDES_TCR, len32);\r\natmel_tdes_write(dd, TDES_RPR, dma_addr_out);\r\natmel_tdes_write(dd, TDES_RCR, len32);\r\natmel_tdes_write(dd, TDES_IER, TDES_INT_ENDRX);\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTEN | TDES_PTCR_RXTEN);\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_crypt_dma(struct crypto_tfm *tfm, dma_addr_t dma_addr_in,\r\ndma_addr_t dma_addr_out, int length)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct atmel_tdes_dev *dd = ctx->dd;\r\nstruct scatterlist sg[2];\r\nstruct dma_async_tx_descriptor *in_desc, *out_desc;\r\ndd->dma_size = length;\r\nif (!(dd->flags & TDES_FLAGS_FAST)) {\r\ndma_sync_single_for_device(dd->dev, dma_addr_in, length,\r\nDMA_TO_DEVICE);\r\n}\r\nif (dd->flags & TDES_FLAGS_CFB8) {\r\ndd->dma_lch_in.dma_conf.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndd->dma_lch_out.dma_conf.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_1_BYTE;\r\n} else if (dd->flags & TDES_FLAGS_CFB16) {\r\ndd->dma_lch_in.dma_conf.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_2_BYTES;\r\ndd->dma_lch_out.dma_conf.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_2_BYTES;\r\n} else {\r\ndd->dma_lch_in.dma_conf.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndd->dma_lch_out.dma_conf.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\n}\r\ndmaengine_slave_config(dd->dma_lch_in.chan, &dd->dma_lch_in.dma_conf);\r\ndmaengine_slave_config(dd->dma_lch_out.chan, &dd->dma_lch_out.dma_conf);\r\ndd->flags |= TDES_FLAGS_DMA;\r\nsg_init_table(&sg[0], 1);\r\nsg_dma_address(&sg[0]) = dma_addr_in;\r\nsg_dma_len(&sg[0]) = length;\r\nsg_init_table(&sg[1], 1);\r\nsg_dma_address(&sg[1]) = dma_addr_out;\r\nsg_dma_len(&sg[1]) = length;\r\nin_desc = dmaengine_prep_slave_sg(dd->dma_lch_in.chan, &sg[0],\r\n1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!in_desc)\r\nreturn -EINVAL;\r\nout_desc = dmaengine_prep_slave_sg(dd->dma_lch_out.chan, &sg[1],\r\n1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!out_desc)\r\nreturn -EINVAL;\r\nout_desc->callback = atmel_tdes_dma_callback;\r\nout_desc->callback_param = dd;\r\ndmaengine_submit(out_desc);\r\ndma_async_issue_pending(dd->dma_lch_out.chan);\r\ndmaengine_submit(in_desc);\r\ndma_async_issue_pending(dd->dma_lch_in.chan);\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_crypt_start(struct atmel_tdes_dev *dd)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(\r\ncrypto_ablkcipher_reqtfm(dd->req));\r\nint err, fast = 0, in, out;\r\nsize_t count;\r\ndma_addr_t addr_in, addr_out;\r\nif ((!dd->in_offset) && (!dd->out_offset)) {\r\nin = IS_ALIGNED((u32)dd->in_sg->offset, sizeof(u32)) &&\r\nIS_ALIGNED(dd->in_sg->length, dd->ctx->block_size);\r\nout = IS_ALIGNED((u32)dd->out_sg->offset, sizeof(u32)) &&\r\nIS_ALIGNED(dd->out_sg->length, dd->ctx->block_size);\r\nfast = in && out;\r\nif (sg_dma_len(dd->in_sg) != sg_dma_len(dd->out_sg))\r\nfast = 0;\r\n}\r\nif (fast) {\r\ncount = min(dd->total, sg_dma_len(dd->in_sg));\r\ncount = min(count, sg_dma_len(dd->out_sg));\r\nerr = dma_map_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\nif (!err) {\r\ndev_err(dd->dev, "dma_map_sg() error\n");\r\nreturn -EINVAL;\r\n}\r\nerr = dma_map_sg(dd->dev, dd->out_sg, 1,\r\nDMA_FROM_DEVICE);\r\nif (!err) {\r\ndev_err(dd->dev, "dma_map_sg() error\n");\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1,\r\nDMA_TO_DEVICE);\r\nreturn -EINVAL;\r\n}\r\naddr_in = sg_dma_address(dd->in_sg);\r\naddr_out = sg_dma_address(dd->out_sg);\r\ndd->flags |= TDES_FLAGS_FAST;\r\n} else {\r\ncount = atmel_tdes_sg_copy(&dd->in_sg, &dd->in_offset,\r\ndd->buf_in, dd->buflen, dd->total, 0);\r\naddr_in = dd->dma_addr_in;\r\naddr_out = dd->dma_addr_out;\r\ndd->flags &= ~TDES_FLAGS_FAST;\r\n}\r\ndd->total -= count;\r\nif (dd->caps.has_dma)\r\nerr = atmel_tdes_crypt_dma(tfm, addr_in, addr_out, count);\r\nelse\r\nerr = atmel_tdes_crypt_pdc(tfm, addr_in, addr_out, count);\r\nif (err && (dd->flags & TDES_FLAGS_FAST)) {\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_TO_DEVICE);\r\n}\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_finish_req(struct atmel_tdes_dev *dd, int err)\r\n{\r\nstruct ablkcipher_request *req = dd->req;\r\nclk_disable_unprepare(dd->iclk);\r\ndd->flags &= ~TDES_FLAGS_BUSY;\r\nreq->base.complete(&req->base, err);\r\n}\r\nstatic int atmel_tdes_handle_queue(struct atmel_tdes_dev *dd,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct crypto_async_request *async_req, *backlog;\r\nstruct atmel_tdes_ctx *ctx;\r\nstruct atmel_tdes_reqctx *rctx;\r\nunsigned long flags;\r\nint err, ret = 0;\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (req)\r\nret = ablkcipher_enqueue_request(&dd->queue, req);\r\nif (dd->flags & TDES_FLAGS_BUSY) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = crypto_get_backlog(&dd->queue);\r\nasync_req = crypto_dequeue_request(&dd->queue);\r\nif (async_req)\r\ndd->flags |= TDES_FLAGS_BUSY;\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!async_req)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nreq = ablkcipher_request_cast(async_req);\r\ndd->req = req;\r\ndd->total = req->nbytes;\r\ndd->in_offset = 0;\r\ndd->in_sg = req->src;\r\ndd->out_offset = 0;\r\ndd->out_sg = req->dst;\r\nrctx = ablkcipher_request_ctx(req);\r\nctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));\r\nrctx->mode &= TDES_FLAGS_MODE_MASK;\r\ndd->flags = (dd->flags & ~TDES_FLAGS_MODE_MASK) | rctx->mode;\r\ndd->ctx = ctx;\r\nctx->dd = dd;\r\nerr = atmel_tdes_write_ctrl(dd);\r\nif (!err)\r\nerr = atmel_tdes_crypt_start(dd);\r\nif (err) {\r\natmel_tdes_finish_req(dd, err);\r\ntasklet_schedule(&dd->queue_task);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_tdes_crypt_dma_stop(struct atmel_tdes_dev *dd)\r\n{\r\nint err = -EINVAL;\r\nsize_t count;\r\nif (dd->flags & TDES_FLAGS_DMA) {\r\nerr = 0;\r\nif (dd->flags & TDES_FLAGS_FAST) {\r\ndma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\n} else {\r\ndma_sync_single_for_device(dd->dev, dd->dma_addr_out,\r\ndd->dma_size, DMA_FROM_DEVICE);\r\ncount = atmel_tdes_sg_copy(&dd->out_sg, &dd->out_offset,\r\ndd->buf_out, dd->buflen, dd->dma_size, 1);\r\nif (count != dd->dma_size) {\r\nerr = -EINVAL;\r\npr_err("not all data converted: %u\n", count);\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_crypt(struct ablkcipher_request *req, unsigned long mode)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(\r\ncrypto_ablkcipher_reqtfm(req));\r\nstruct atmel_tdes_reqctx *rctx = ablkcipher_request_ctx(req);\r\nif (mode & TDES_FLAGS_CFB8) {\r\nif (!IS_ALIGNED(req->nbytes, CFB8_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB8 blocks\n");\r\nreturn -EINVAL;\r\n}\r\nctx->block_size = CFB8_BLOCK_SIZE;\r\n} else if (mode & TDES_FLAGS_CFB16) {\r\nif (!IS_ALIGNED(req->nbytes, CFB16_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB16 blocks\n");\r\nreturn -EINVAL;\r\n}\r\nctx->block_size = CFB16_BLOCK_SIZE;\r\n} else if (mode & TDES_FLAGS_CFB32) {\r\nif (!IS_ALIGNED(req->nbytes, CFB32_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB32 blocks\n");\r\nreturn -EINVAL;\r\n}\r\nctx->block_size = CFB32_BLOCK_SIZE;\r\n} else {\r\nif (!IS_ALIGNED(req->nbytes, DES_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of DES blocks\n");\r\nreturn -EINVAL;\r\n}\r\nctx->block_size = DES_BLOCK_SIZE;\r\n}\r\nrctx->mode = mode;\r\nreturn atmel_tdes_handle_queue(ctx->dd, req);\r\n}\r\nstatic bool atmel_tdes_filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct at_dma_slave *sl = slave;\r\nif (sl && sl->dma_dev == chan->device->dev) {\r\nchan->private = sl;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic int atmel_tdes_dma_init(struct atmel_tdes_dev *dd,\r\nstruct crypto_platform_data *pdata)\r\n{\r\nint err = -ENOMEM;\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndd->dma_lch_in.chan = dma_request_slave_channel_compat(mask,\r\natmel_tdes_filter, &pdata->dma_slave->rxdata, dd->dev, "tx");\r\nif (!dd->dma_lch_in.chan)\r\ngoto err_dma_in;\r\ndd->dma_lch_in.dma_conf.direction = DMA_MEM_TO_DEV;\r\ndd->dma_lch_in.dma_conf.dst_addr = dd->phys_base +\r\nTDES_IDATA1R;\r\ndd->dma_lch_in.dma_conf.src_maxburst = 1;\r\ndd->dma_lch_in.dma_conf.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndd->dma_lch_in.dma_conf.dst_maxburst = 1;\r\ndd->dma_lch_in.dma_conf.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndd->dma_lch_in.dma_conf.device_fc = false;\r\ndd->dma_lch_out.chan = dma_request_slave_channel_compat(mask,\r\natmel_tdes_filter, &pdata->dma_slave->txdata, dd->dev, "rx");\r\nif (!dd->dma_lch_out.chan)\r\ngoto err_dma_out;\r\ndd->dma_lch_out.dma_conf.direction = DMA_DEV_TO_MEM;\r\ndd->dma_lch_out.dma_conf.src_addr = dd->phys_base +\r\nTDES_ODATA1R;\r\ndd->dma_lch_out.dma_conf.src_maxburst = 1;\r\ndd->dma_lch_out.dma_conf.src_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndd->dma_lch_out.dma_conf.dst_maxburst = 1;\r\ndd->dma_lch_out.dma_conf.dst_addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndd->dma_lch_out.dma_conf.device_fc = false;\r\nreturn 0;\r\nerr_dma_out:\r\ndma_release_channel(dd->dma_lch_in.chan);\r\nerr_dma_in:\r\ndev_warn(dd->dev, "no DMA channel available\n");\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_dma_cleanup(struct atmel_tdes_dev *dd)\r\n{\r\ndma_release_channel(dd->dma_lch_in.chan);\r\ndma_release_channel(dd->dma_lch_out.chan);\r\n}\r\nstatic int atmel_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nint err;\r\nstruct crypto_tfm *ctfm = crypto_ablkcipher_tfm(tfm);\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nif (keylen != DES_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nerr = des_ekey(tmp, key);\r\nif (err == 0 && (ctfm->crt_flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\nctfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nconst char *alg_name;\r\nalg_name = crypto_tfm_alg_name(crypto_ablkcipher_tfm(tfm));\r\nif (!ctx->dd->caps.has_cfb_3keys && strstr(alg_name, "cfb")\r\n&& (keylen != 2*DES_KEY_SIZE)) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n} else if ((keylen != 2*DES_KEY_SIZE) && (keylen != 3*DES_KEY_SIZE)) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_ecb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_tdes_ecb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, 0);\r\n}\r\nstatic int atmel_tdes_cbc_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CBC);\r\n}\r\nstatic int atmel_tdes_cbc_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CBC);\r\n}\r\nstatic int atmel_tdes_cfb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB);\r\n}\r\nstatic int atmel_tdes_cfb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB);\r\n}\r\nstatic int atmel_tdes_cfb8_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB8);\r\n}\r\nstatic int atmel_tdes_cfb8_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB8);\r\n}\r\nstatic int atmel_tdes_cfb16_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB16);\r\n}\r\nstatic int atmel_tdes_cfb16_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB16);\r\n}\r\nstatic int atmel_tdes_cfb32_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB32);\r\n}\r\nstatic int atmel_tdes_cfb32_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB32);\r\n}\r\nstatic int atmel_tdes_ofb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_OFB);\r\n}\r\nstatic int atmel_tdes_ofb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_OFB);\r\n}\r\nstatic int atmel_tdes_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct atmel_tdes_dev *dd;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct atmel_tdes_reqctx);\r\ndd = atmel_tdes_find_dev(ctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void atmel_tdes_cra_exit(struct crypto_tfm *tfm)\r\n{\r\n}\r\nstatic void atmel_tdes_queue_task(unsigned long data)\r\n{\r\nstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *)data;\r\natmel_tdes_handle_queue(dd, NULL);\r\n}\r\nstatic void atmel_tdes_done_task(unsigned long data)\r\n{\r\nstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *) data;\r\nint err;\r\nif (!(dd->flags & TDES_FLAGS_DMA))\r\nerr = atmel_tdes_crypt_pdc_stop(dd);\r\nelse\r\nerr = atmel_tdes_crypt_dma_stop(dd);\r\nerr = dd->err ? : err;\r\nif (dd->total && !err) {\r\nif (dd->flags & TDES_FLAGS_FAST) {\r\ndd->in_sg = sg_next(dd->in_sg);\r\ndd->out_sg = sg_next(dd->out_sg);\r\nif (!dd->in_sg || !dd->out_sg)\r\nerr = -EINVAL;\r\n}\r\nif (!err)\r\nerr = atmel_tdes_crypt_start(dd);\r\nif (!err)\r\nreturn;\r\n}\r\natmel_tdes_finish_req(dd, err);\r\natmel_tdes_handle_queue(dd, NULL);\r\n}\r\nstatic irqreturn_t atmel_tdes_irq(int irq, void *dev_id)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd = dev_id;\r\nu32 reg;\r\nreg = atmel_tdes_read(tdes_dd, TDES_ISR);\r\nif (reg & atmel_tdes_read(tdes_dd, TDES_IMR)) {\r\natmel_tdes_write(tdes_dd, TDES_IDR, reg);\r\nif (TDES_FLAGS_BUSY & tdes_dd->flags)\r\ntasklet_schedule(&tdes_dd->done_task);\r\nelse\r\ndev_warn(tdes_dd->dev, "TDES interrupt when no active requests.\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void atmel_tdes_unregister_algs(struct atmel_tdes_dev *dd)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++)\r\ncrypto_unregister_alg(&tdes_algs[i]);\r\n}\r\nstatic int atmel_tdes_register_algs(struct atmel_tdes_dev *dd)\r\n{\r\nint err, i, j;\r\nfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++) {\r\nerr = crypto_register_alg(&tdes_algs[i]);\r\nif (err)\r\ngoto err_tdes_algs;\r\n}\r\nreturn 0;\r\nerr_tdes_algs:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_alg(&tdes_algs[j]);\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_get_cap(struct atmel_tdes_dev *dd)\r\n{\r\ndd->caps.has_dma = 0;\r\ndd->caps.has_cfb_3keys = 0;\r\nswitch (dd->hw_version & 0xf00) {\r\ncase 0x700:\r\ndd->caps.has_dma = 1;\r\ndd->caps.has_cfb_3keys = 1;\r\nbreak;\r\ncase 0x600:\r\nbreak;\r\ndefault:\r\ndev_warn(dd->dev,\r\n"Unmanaged tdes version, set minimum capabilities\n");\r\nbreak;\r\n}\r\n}\r\nstatic struct crypto_platform_data *atmel_tdes_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct crypto_platform_data *pdata;\r\nif (!np) {\r\ndev_err(&pdev->dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "could not allocate memory for pdata\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npdata->dma_slave = devm_kzalloc(&pdev->dev,\r\nsizeof(*(pdata->dma_slave)),\r\nGFP_KERNEL);\r\nif (!pdata->dma_slave) {\r\ndev_err(&pdev->dev, "could not allocate memory for dma_slave\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn pdata;\r\n}\r\nstatic inline struct crypto_platform_data *atmel_tdes_of_init(struct platform_device *pdev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int atmel_tdes_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd;\r\nstruct crypto_platform_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *tdes_res;\r\nint err;\r\ntdes_dd = devm_kmalloc(&pdev->dev, sizeof(*tdes_dd), GFP_KERNEL);\r\nif (tdes_dd == NULL) {\r\ndev_err(dev, "unable to alloc data struct.\n");\r\nerr = -ENOMEM;\r\ngoto tdes_dd_err;\r\n}\r\ntdes_dd->dev = dev;\r\nplatform_set_drvdata(pdev, tdes_dd);\r\nINIT_LIST_HEAD(&tdes_dd->list);\r\nspin_lock_init(&tdes_dd->lock);\r\ntasklet_init(&tdes_dd->done_task, atmel_tdes_done_task,\r\n(unsigned long)tdes_dd);\r\ntasklet_init(&tdes_dd->queue_task, atmel_tdes_queue_task,\r\n(unsigned long)tdes_dd);\r\ncrypto_init_queue(&tdes_dd->queue, ATMEL_TDES_QUEUE_LENGTH);\r\ntdes_dd->irq = -1;\r\ntdes_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!tdes_res) {\r\ndev_err(dev, "no MEM resource info\n");\r\nerr = -ENODEV;\r\ngoto res_err;\r\n}\r\ntdes_dd->phys_base = tdes_res->start;\r\ntdes_dd->irq = platform_get_irq(pdev, 0);\r\nif (tdes_dd->irq < 0) {\r\ndev_err(dev, "no IRQ resource info\n");\r\nerr = tdes_dd->irq;\r\ngoto res_err;\r\n}\r\nerr = devm_request_irq(&pdev->dev, tdes_dd->irq, atmel_tdes_irq,\r\nIRQF_SHARED, "atmel-tdes", tdes_dd);\r\nif (err) {\r\ndev_err(dev, "unable to request tdes irq.\n");\r\ngoto res_err;\r\n}\r\ntdes_dd->iclk = devm_clk_get(&pdev->dev, "tdes_clk");\r\nif (IS_ERR(tdes_dd->iclk)) {\r\ndev_err(dev, "clock initialization failed.\n");\r\nerr = PTR_ERR(tdes_dd->iclk);\r\ngoto res_err;\r\n}\r\ntdes_dd->io_base = devm_ioremap_resource(&pdev->dev, tdes_res);\r\nif (IS_ERR(tdes_dd->io_base)) {\r\ndev_err(dev, "can't ioremap\n");\r\nerr = PTR_ERR(tdes_dd->io_base);\r\ngoto res_err;\r\n}\r\natmel_tdes_hw_version_init(tdes_dd);\r\natmel_tdes_get_cap(tdes_dd);\r\nerr = atmel_tdes_buff_init(tdes_dd);\r\nif (err)\r\ngoto err_tdes_buff;\r\nif (tdes_dd->caps.has_dma) {\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\npdata = atmel_tdes_of_init(pdev);\r\nif (IS_ERR(pdata)) {\r\ndev_err(&pdev->dev, "platform data not available\n");\r\nerr = PTR_ERR(pdata);\r\ngoto err_pdata;\r\n}\r\n}\r\nif (!pdata->dma_slave) {\r\nerr = -ENXIO;\r\ngoto err_pdata;\r\n}\r\nerr = atmel_tdes_dma_init(tdes_dd, pdata);\r\nif (err)\r\ngoto err_tdes_dma;\r\ndev_info(dev, "using %s, %s for DMA transfers\n",\r\ndma_chan_name(tdes_dd->dma_lch_in.chan),\r\ndma_chan_name(tdes_dd->dma_lch_out.chan));\r\n}\r\nspin_lock(&atmel_tdes.lock);\r\nlist_add_tail(&tdes_dd->list, &atmel_tdes.dev_list);\r\nspin_unlock(&atmel_tdes.lock);\r\nerr = atmel_tdes_register_algs(tdes_dd);\r\nif (err)\r\ngoto err_algs;\r\ndev_info(dev, "Atmel DES/TDES\n");\r\nreturn 0;\r\nerr_algs:\r\nspin_lock(&atmel_tdes.lock);\r\nlist_del(&tdes_dd->list);\r\nspin_unlock(&atmel_tdes.lock);\r\nif (tdes_dd->caps.has_dma)\r\natmel_tdes_dma_cleanup(tdes_dd);\r\nerr_tdes_dma:\r\nerr_pdata:\r\natmel_tdes_buff_cleanup(tdes_dd);\r\nerr_tdes_buff:\r\nres_err:\r\ntasklet_kill(&tdes_dd->done_task);\r\ntasklet_kill(&tdes_dd->queue_task);\r\ntdes_dd_err:\r\ndev_err(dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_remove(struct platform_device *pdev)\r\n{\r\nstatic struct atmel_tdes_dev *tdes_dd;\r\ntdes_dd = platform_get_drvdata(pdev);\r\nif (!tdes_dd)\r\nreturn -ENODEV;\r\nspin_lock(&atmel_tdes.lock);\r\nlist_del(&tdes_dd->list);\r\nspin_unlock(&atmel_tdes.lock);\r\natmel_tdes_unregister_algs(tdes_dd);\r\ntasklet_kill(&tdes_dd->done_task);\r\ntasklet_kill(&tdes_dd->queue_task);\r\nif (tdes_dd->caps.has_dma)\r\natmel_tdes_dma_cleanup(tdes_dd);\r\natmel_tdes_buff_cleanup(tdes_dd);\r\nreturn 0;\r\n}
