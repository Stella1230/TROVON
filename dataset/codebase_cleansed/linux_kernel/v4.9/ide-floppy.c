static int ide_floppy_callback(ide_drive_t *drive, int dsc)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nstruct ide_atapi_pc *pc = drive->pc;\r\nstruct request *rq = pc->rq;\r\nint uptodate = pc->error ? 0 : 1;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif (drive->failed_pc == pc)\r\ndrive->failed_pc = NULL;\r\nif (pc->c[0] == GPCMD_READ_10 || pc->c[0] == GPCMD_WRITE_10 ||\r\nrq->cmd_type == REQ_TYPE_BLOCK_PC)\r\nuptodate = 1;\r\nelse if (pc->c[0] == GPCMD_REQUEST_SENSE) {\r\nu8 *buf = bio_data(rq->bio);\r\nif (!pc->error) {\r\nfloppy->sense_key = buf[2] & 0x0F;\r\nfloppy->asc = buf[12];\r\nfloppy->ascq = buf[13];\r\nfloppy->progress_indication = buf[15] & 0x80 ?\r\n(u16)get_unaligned((u16 *)&buf[16]) : 0x10000;\r\nif (drive->failed_pc)\r\nide_debug_log(IDE_DBG_PC, "pc = %x",\r\ndrive->failed_pc->c[0]);\r\nide_debug_log(IDE_DBG_SENSE, "sense key = %x, asc = %x,"\r\n"ascq = %x", floppy->sense_key,\r\nfloppy->asc, floppy->ascq);\r\n} else\r\nprintk(KERN_ERR PFX "Error in REQUEST SENSE itself - "\r\n"Aborting request!\n");\r\n}\r\nif (rq->cmd_type == REQ_TYPE_DRV_PRIV)\r\nrq->errors = uptodate ? 0 : IDE_DRV_ERROR_GENERAL;\r\nreturn uptodate;\r\n}\r\nstatic void ide_floppy_report_error(struct ide_disk_obj *floppy,\r\nstruct ide_atapi_pc *pc)\r\n{\r\nif (floppy->sense_key == 0x02 &&\r\nfloppy->asc == 0x3a &&\r\nfloppy->ascq == 0x00)\r\nreturn;\r\nprintk(KERN_ERR PFX "%s: I/O error, pc = %2x, key = %2x, "\r\n"asc = %2x, ascq = %2x\n",\r\nfloppy->drive->name, pc->c[0], floppy->sense_key,\r\nfloppy->asc, floppy->ascq);\r\n}\r\nstatic ide_startstop_t ide_floppy_issue_pc(ide_drive_t *drive,\r\nstruct ide_cmd *cmd,\r\nstruct ide_atapi_pc *pc)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nif (drive->failed_pc == NULL &&\r\npc->c[0] != GPCMD_REQUEST_SENSE)\r\ndrive->failed_pc = pc;\r\ndrive->pc = pc;\r\nif (pc->retries > IDEFLOPPY_MAX_PC_RETRIES) {\r\nunsigned int done = blk_rq_bytes(drive->hwif->rq);\r\nif (!(pc->flags & PC_FLAG_SUPPRESS_ERROR))\r\nide_floppy_report_error(floppy, pc);\r\npc->error = IDE_DRV_ERROR_GENERAL;\r\ndrive->failed_pc = NULL;\r\ndrive->pc_callback(drive, 0);\r\nide_complete_rq(drive, -EIO, done);\r\nreturn ide_stopped;\r\n}\r\nide_debug_log(IDE_DBG_FUNC, "retry #%d", pc->retries);\r\npc->retries++;\r\nreturn ide_issue_pc(drive, cmd);\r\n}\r\nvoid ide_floppy_create_read_capacity_cmd(struct ide_atapi_pc *pc)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = GPCMD_READ_FORMAT_CAPACITIES;\r\npc->c[7] = 255;\r\npc->c[8] = 255;\r\npc->req_xfer = 255;\r\n}\r\nvoid ide_floppy_create_mode_sense_cmd(struct ide_atapi_pc *pc, u8 page_code)\r\n{\r\nu16 length = 8;\r\nide_init_pc(pc);\r\npc->c[0] = GPCMD_MODE_SENSE_10;\r\npc->c[1] = 0;\r\npc->c[2] = page_code;\r\nswitch (page_code) {\r\ncase IDEFLOPPY_CAPABILITIES_PAGE:\r\nlength += 12;\r\nbreak;\r\ncase IDEFLOPPY_FLEXIBLE_DISK_PAGE:\r\nlength += 32;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "unsupported page code in %s\n", __func__);\r\n}\r\nput_unaligned(cpu_to_be16(length), (u16 *) &pc->c[7]);\r\npc->req_xfer = length;\r\n}\r\nstatic void idefloppy_create_rw_cmd(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc, struct request *rq,\r\nunsigned long sector)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nint block = sector / floppy->bs_factor;\r\nint blocks = blk_rq_sectors(rq) / floppy->bs_factor;\r\nint cmd = rq_data_dir(rq);\r\nide_debug_log(IDE_DBG_FUNC, "block: %d, blocks: %d", block, blocks);\r\nide_init_pc(pc);\r\npc->c[0] = cmd == READ ? GPCMD_READ_10 : GPCMD_WRITE_10;\r\nput_unaligned(cpu_to_be16(blocks), (unsigned short *)&pc->c[7]);\r\nput_unaligned(cpu_to_be32(block), (unsigned int *) &pc->c[2]);\r\nmemcpy(rq->cmd, pc->c, 12);\r\npc->rq = rq;\r\nif (cmd == WRITE)\r\npc->flags |= PC_FLAG_WRITING;\r\npc->flags |= PC_FLAG_DMA_OK;\r\n}\r\nstatic void idefloppy_blockpc_cmd(struct ide_disk_obj *floppy,\r\nstruct ide_atapi_pc *pc, struct request *rq)\r\n{\r\nide_init_pc(pc);\r\nmemcpy(pc->c, rq->cmd, sizeof(pc->c));\r\npc->rq = rq;\r\nif (blk_rq_bytes(rq)) {\r\npc->flags |= PC_FLAG_DMA_OK;\r\nif (rq_data_dir(rq) == WRITE)\r\npc->flags |= PC_FLAG_WRITING;\r\n}\r\n}\r\nstatic ide_startstop_t ide_floppy_do_request(ide_drive_t *drive,\r\nstruct request *rq, sector_t block)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nstruct ide_cmd cmd;\r\nstruct ide_atapi_pc *pc;\r\nide_debug_log(IDE_DBG_FUNC, "enter, cmd: 0x%x\n", rq->cmd[0]);\r\nif (drive->debug_mask & IDE_DBG_RQ)\r\nblk_dump_rq_flags(rq, (rq->rq_disk\r\n? rq->rq_disk->disk_name\r\n: "dev?"));\r\nif (rq->errors >= ERROR_MAX) {\r\nif (drive->failed_pc) {\r\nide_floppy_report_error(floppy, drive->failed_pc);\r\ndrive->failed_pc = NULL;\r\n} else\r\nprintk(KERN_ERR PFX "%s: I/O error\n", drive->name);\r\nif (rq->cmd_type == REQ_TYPE_DRV_PRIV) {\r\nrq->errors = 0;\r\nide_complete_rq(drive, 0, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n} else\r\ngoto out_end;\r\n}\r\nswitch (rq->cmd_type) {\r\ncase REQ_TYPE_FS:\r\nif (((long)blk_rq_pos(rq) % floppy->bs_factor) ||\r\n(blk_rq_sectors(rq) % floppy->bs_factor)) {\r\nprintk(KERN_ERR PFX "%s: unsupported r/w rq size\n",\r\ndrive->name);\r\ngoto out_end;\r\n}\r\npc = &floppy->queued_pc;\r\nidefloppy_create_rw_cmd(drive, pc, rq, (unsigned long)block);\r\nbreak;\r\ncase REQ_TYPE_DRV_PRIV:\r\ncase REQ_TYPE_ATA_SENSE:\r\npc = (struct ide_atapi_pc *)rq->special;\r\nbreak;\r\ncase REQ_TYPE_BLOCK_PC:\r\npc = &floppy->queued_pc;\r\nidefloppy_blockpc_cmd(floppy, pc, rq);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nide_prep_sense(drive, rq);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (rq_data_dir(rq))\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\ncmd.rq = rq;\r\nif (rq->cmd_type == REQ_TYPE_FS || blk_rq_bytes(rq)) {\r\nide_init_sg_cmd(&cmd, blk_rq_bytes(rq));\r\nide_map_sg(drive, &cmd);\r\n}\r\npc->rq = rq;\r\nreturn ide_floppy_issue_pc(drive, &cmd, pc);\r\nout_end:\r\ndrive->failed_pc = NULL;\r\nif (rq->cmd_type != REQ_TYPE_FS && rq->errors == 0)\r\nrq->errors = -EIO;\r\nide_complete_rq(drive, -EIO, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}\r\nstatic int ide_floppy_get_flexible_disk_page(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nstruct gendisk *disk = floppy->disk;\r\nu8 *page, buf[40];\r\nint capacity, lba_capacity;\r\nu16 transfer_rate, sector_size, cyls, rpm;\r\nu8 heads, sectors;\r\nide_floppy_create_mode_sense_cmd(pc, IDEFLOPPY_FLEXIBLE_DISK_PAGE);\r\nif (ide_queue_pc_tail(drive, disk, pc, buf, pc->req_xfer)) {\r\nprintk(KERN_ERR PFX "Can't get flexible disk page params\n");\r\nreturn 1;\r\n}\r\nif (buf[3] & 0x80)\r\ndrive->dev_flags |= IDE_DFLAG_WP;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_WP;\r\nset_disk_ro(disk, !!(drive->dev_flags & IDE_DFLAG_WP));\r\npage = &buf[8];\r\ntransfer_rate = be16_to_cpup((__be16 *)&buf[8 + 2]);\r\nsector_size = be16_to_cpup((__be16 *)&buf[8 + 6]);\r\ncyls = be16_to_cpup((__be16 *)&buf[8 + 8]);\r\nrpm = be16_to_cpup((__be16 *)&buf[8 + 28]);\r\nheads = buf[8 + 4];\r\nsectors = buf[8 + 5];\r\ncapacity = cyls * heads * sectors * sector_size;\r\nif (memcmp(page, &floppy->flexible_disk_page, 32))\r\nprintk(KERN_INFO PFX "%s: %dkB, %d/%d/%d CHS, %d kBps, "\r\n"%d sector size, %d rpm\n",\r\ndrive->name, capacity / 1024, cyls, heads,\r\nsectors, transfer_rate / 8, sector_size, rpm);\r\nmemcpy(&floppy->flexible_disk_page, page, 32);\r\ndrive->bios_cyl = cyls;\r\ndrive->bios_head = heads;\r\ndrive->bios_sect = sectors;\r\nlba_capacity = floppy->blocks * floppy->block_size;\r\nif (capacity < lba_capacity) {\r\nprintk(KERN_NOTICE PFX "%s: The disk reports a capacity of %d "\r\n"bytes, but the drive only handles %d\n",\r\ndrive->name, lba_capacity, capacity);\r\nfloppy->blocks = floppy->block_size ?\r\ncapacity / floppy->block_size : 0;\r\ndrive->capacity64 = floppy->blocks * floppy->bs_factor;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ide_floppy_get_capacity(ide_drive_t *drive)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nstruct gendisk *disk = floppy->disk;\r\nstruct ide_atapi_pc pc;\r\nu8 *cap_desc;\r\nu8 pc_buf[256], header_len, desc_cnt;\r\nint i, rc = 1, blocks, length;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\ndrive->bios_cyl = 0;\r\ndrive->bios_head = drive->bios_sect = 0;\r\nfloppy->blocks = 0;\r\nfloppy->bs_factor = 1;\r\ndrive->capacity64 = 0;\r\nide_floppy_create_read_capacity_cmd(&pc);\r\nif (ide_queue_pc_tail(drive, disk, &pc, pc_buf, pc.req_xfer)) {\r\nprintk(KERN_ERR PFX "Can't get floppy parameters\n");\r\nreturn 1;\r\n}\r\nheader_len = pc_buf[3];\r\ncap_desc = &pc_buf[4];\r\ndesc_cnt = header_len / 8;\r\nfor (i = 0; i < desc_cnt; i++) {\r\nunsigned int desc_start = 4 + i*8;\r\nblocks = be32_to_cpup((__be32 *)&pc_buf[desc_start]);\r\nlength = be16_to_cpup((__be16 *)&pc_buf[desc_start + 6]);\r\nide_debug_log(IDE_DBG_PROBE, "Descriptor %d: %dkB, %d blocks, "\r\n"%d sector size",\r\ni, blocks * length / 1024,\r\nblocks, length);\r\nif (i)\r\ncontinue;\r\nswitch (pc_buf[desc_start + 4] & 0x03) {\r\ncase CAPACITY_UNFORMATTED:\r\nif (!(drive->atapi_flags & IDE_AFLAG_CLIK_DRIVE))\r\nbreak;\r\ncase CAPACITY_CURRENT:\r\nif (memcmp(cap_desc, &floppy->cap_desc, 8))\r\nprintk(KERN_INFO PFX "%s: %dkB, %d blocks, %d "\r\n"sector size\n",\r\ndrive->name, blocks * length / 1024,\r\nblocks, length);\r\nmemcpy(&floppy->cap_desc, cap_desc, 8);\r\nif (!length || length % 512) {\r\nprintk(KERN_NOTICE PFX "%s: %d bytes block size"\r\n" not supported\n", drive->name, length);\r\n} else {\r\nfloppy->blocks = blocks;\r\nfloppy->block_size = length;\r\nfloppy->bs_factor = length / 512;\r\nif (floppy->bs_factor != 1)\r\nprintk(KERN_NOTICE PFX "%s: Warning: "\r\n"non 512 bytes block size not "\r\n"fully supported\n",\r\ndrive->name);\r\ndrive->capacity64 =\r\nfloppy->blocks * floppy->bs_factor;\r\nrc = 0;\r\n}\r\nbreak;\r\ncase CAPACITY_NO_CARTRIDGE:\r\nprintk(KERN_ERR PFX "%s: No disk in drive\n",\r\ndrive->name);\r\nbreak;\r\ncase CAPACITY_INVALID:\r\nprintk(KERN_ERR PFX "%s: Invalid capacity for disk "\r\n"in drive\n", drive->name);\r\nbreak;\r\n}\r\nide_debug_log(IDE_DBG_PROBE, "Descriptor 0 Code: %d",\r\npc_buf[desc_start + 4] & 0x03);\r\n}\r\nif (!(drive->atapi_flags & IDE_AFLAG_CLIK_DRIVE))\r\n(void) ide_floppy_get_flexible_disk_page(drive, &pc);\r\nreturn rc;\r\n}\r\nstatic void ide_floppy_setup(ide_drive_t *drive)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nu16 *id = drive->id;\r\ndrive->pc_callback = ide_floppy_callback;\r\nif (strstarts((char *)&id[ATA_ID_PROD], "IOMEGA ZIP 100 ATAPI")) {\r\ndrive->atapi_flags |= IDE_AFLAG_ZIP_DRIVE;\r\ndrive->pc_delay = IDEFLOPPY_PC_DELAY;\r\nblk_queue_max_hw_sectors(drive->queue, 64);\r\n}\r\nif (strstarts((char *)&id[ATA_ID_PROD], "IOMEGA Clik!")) {\r\nblk_queue_max_hw_sectors(drive->queue, 64);\r\ndrive->atapi_flags |= IDE_AFLAG_CLIK_DRIVE;\r\ndrive->dev_flags &= ~IDE_DFLAG_DOORLOCKING;\r\n}\r\n(void) ide_floppy_get_capacity(drive);\r\nide_proc_register_driver(drive, floppy->driver);\r\ndrive->dev_flags |= IDE_DFLAG_ATTACH;\r\n}\r\nstatic void ide_floppy_flush(ide_drive_t *drive)\r\n{\r\n}\r\nstatic int ide_floppy_init_media(ide_drive_t *drive, struct gendisk *disk)\r\n{\r\nint ret = 0;\r\nif (ide_do_test_unit_ready(drive, disk))\r\nide_do_start_stop(drive, disk, 1);\r\nret = ide_floppy_get_capacity(drive);\r\nset_capacity(disk, ide_gd_capacity(drive));\r\nreturn ret;\r\n}
