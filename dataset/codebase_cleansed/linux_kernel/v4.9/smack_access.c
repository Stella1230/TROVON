int smk_access_entry(char *subject_label, char *object_label,\r\nstruct list_head *rule_list)\r\n{\r\nint may = -ENOENT;\r\nstruct smack_rule *srp;\r\nlist_for_each_entry_rcu(srp, rule_list, list) {\r\nif (srp->smk_object->smk_known == object_label &&\r\nsrp->smk_subject->smk_known == subject_label) {\r\nmay = srp->smk_access;\r\nbreak;\r\n}\r\n}\r\nif ((may & MAY_WRITE) == MAY_WRITE)\r\nmay |= MAY_LOCK;\r\nreturn may;\r\n}\r\nint smk_access(struct smack_known *subject, struct smack_known *object,\r\nint request, struct smk_audit_info *a)\r\n{\r\nint may = MAY_NOT;\r\nint rc = 0;\r\nif (subject == &smack_known_star) {\r\nrc = -EACCES;\r\ngoto out_audit;\r\n}\r\nif (object == &smack_known_web || subject == &smack_known_web)\r\ngoto out_audit;\r\nif (object == &smack_known_star)\r\ngoto out_audit;\r\nif (subject->smk_known == object->smk_known)\r\ngoto out_audit;\r\nif ((request & MAY_ANYREAD) == request ||\r\n(request & MAY_LOCK) == request) {\r\nif (object == &smack_known_floor)\r\ngoto out_audit;\r\nif (subject == &smack_known_hat)\r\ngoto out_audit;\r\n}\r\nrcu_read_lock();\r\nmay = smk_access_entry(subject->smk_known, object->smk_known,\r\n&subject->smk_rules);\r\nrcu_read_unlock();\r\nif (may <= 0 || (request & may) != request) {\r\nrc = -EACCES;\r\ngoto out_audit;\r\n}\r\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\r\nif (may & MAY_BRINGUP)\r\nrc = SMACK_BRINGUP_ALLOW;\r\n#endif\r\nout_audit:\r\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\r\nif (rc < 0) {\r\nif (object == smack_unconfined)\r\nrc = SMACK_UNCONFINED_OBJECT;\r\nif (subject == smack_unconfined)\r\nrc = SMACK_UNCONFINED_SUBJECT;\r\n}\r\n#endif\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(subject->smk_known, object->smk_known,\r\nrequest, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\r\nu32 mode, struct smk_audit_info *a)\r\n{\r\nstruct smack_known *sbj_known = smk_of_task(tsp);\r\nint may;\r\nint rc;\r\nrc = smk_access(sbj_known, obj_known, mode, NULL);\r\nif (rc >= 0) {\r\nmay = smk_access_entry(sbj_known->smk_known,\r\nobj_known->smk_known,\r\n&tsp->smk_rules);\r\nif (may < 0)\r\ngoto out_audit;\r\nif ((mode & may) == mode)\r\ngoto out_audit;\r\nrc = -EACCES;\r\n}\r\nif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\r\nrc = 0;\r\nout_audit:\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(sbj_known->smk_known, obj_known->smk_known,\r\nmode, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nint smk_curacc(struct smack_known *obj_known,\r\nu32 mode, struct smk_audit_info *a)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_tskacc(tsp, obj_known, mode, a);\r\n}\r\nstatic inline void smack_str_from_perm(char *string, int access)\r\n{\r\nint i = 0;\r\nif (access & MAY_READ)\r\nstring[i++] = 'r';\r\nif (access & MAY_WRITE)\r\nstring[i++] = 'w';\r\nif (access & MAY_EXEC)\r\nstring[i++] = 'x';\r\nif (access & MAY_APPEND)\r\nstring[i++] = 'a';\r\nif (access & MAY_TRANSMUTE)\r\nstring[i++] = 't';\r\nif (access & MAY_LOCK)\r\nstring[i++] = 'l';\r\nstring[i] = '\0';\r\n}\r\nstatic void smack_log_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\nstruct smack_audit_data *sad = ad->smack_audit_data;\r\naudit_log_format(ab, "lsm=SMACK fn=%s action=%s",\r\nad->smack_audit_data->function,\r\nsad->result ? "denied" : "granted");\r\naudit_log_format(ab, " subject=");\r\naudit_log_untrustedstring(ab, sad->subject);\r\naudit_log_format(ab, " object=");\r\naudit_log_untrustedstring(ab, sad->object);\r\nif (sad->request[0] == '\0')\r\naudit_log_format(ab, " labels_differ");\r\nelse\r\naudit_log_format(ab, " requested=%s", sad->request);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\r\nchar request_buffer[SMK_NUM_ACCESS_TYPE + 5];\r\n#else\r\nchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\r\n#endif\r\nstruct smack_audit_data *sad;\r\nstruct common_audit_data *a = &ad->a;\r\nif (result < 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\r\nreturn;\r\nif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\r\nreturn;\r\nsad = a->smack_audit_data;\r\nif (sad->function == NULL)\r\nsad->function = "unknown";\r\nsmack_str_from_perm(request_buffer, request);\r\nsad->subject = subject_label;\r\nsad->object = object_label;\r\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\r\nif (result == SMACK_UNCONFINED_SUBJECT)\r\nstrcat(request_buffer, "(US)");\r\nelse if (result == SMACK_UNCONFINED_OBJECT)\r\nstrcat(request_buffer, "(UO)");\r\nif (result > 0)\r\nresult = 0;\r\n#endif\r\nsad->request = request_buffer;\r\nsad->result = result;\r\ncommon_lsm_audit(a, smack_log_callback, NULL);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\n}\r\nvoid smk_insert_entry(struct smack_known *skp)\r\n{\r\nunsigned int hash;\r\nstruct hlist_head *head;\r\nhash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\r\nhead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\r\nhlist_add_head_rcu(&skp->smk_hashed, head);\r\nlist_add_rcu(&skp->list, &smack_known_list);\r\n}\r\nstruct smack_known *smk_find_entry(const char *string)\r\n{\r\nunsigned int hash;\r\nstruct hlist_head *head;\r\nstruct smack_known *skp;\r\nhash = full_name_hash(NULL, string, strlen(string));\r\nhead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\r\nhlist_for_each_entry_rcu(skp, head, smk_hashed)\r\nif (strcmp(skp->smk_known, string) == 0)\r\nreturn skp;\r\nreturn NULL;\r\n}\r\nchar *smk_parse_smack(const char *string, int len)\r\n{\r\nchar *smack;\r\nint i;\r\nif (len <= 0)\r\nlen = strlen(string) + 1;\r\nif (string[0] == '-')\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; i < len; i++)\r\nif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\r\nstring[i] == '"' || string[i] == '\\' || string[i] == '\'')\r\nbreak;\r\nif (i == 0 || i >= SMK_LONGLABEL)\r\nreturn ERR_PTR(-EINVAL);\r\nsmack = kzalloc(i + 1, GFP_KERNEL);\r\nif (smack == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrncpy(smack, string, i);\r\nreturn smack;\r\n}\r\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\r\nint len)\r\n{\r\nunsigned char *cp;\r\nunsigned char m;\r\nint cat;\r\nint rc;\r\nint byte;\r\nsap->flags |= NETLBL_SECATTR_MLS_CAT;\r\nsap->attr.mls.lvl = level;\r\nsap->attr.mls.cat = NULL;\r\nfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\r\nfor (m = 0x80; m != 0; m >>= 1, cat++) {\r\nif ((m & *cp) == 0)\r\ncontinue;\r\nrc = netlbl_catmap_setbit(&sap->attr.mls.cat,\r\ncat, GFP_ATOMIC);\r\nif (rc < 0) {\r\nnetlbl_catmap_free(sap->attr.mls.cat);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct smack_known *smk_import_entry(const char *string, int len)\r\n{\r\nstruct smack_known *skp;\r\nchar *smack;\r\nint slen;\r\nint rc;\r\nsmack = smk_parse_smack(string, len);\r\nif (IS_ERR(smack))\r\nreturn ERR_CAST(smack);\r\nmutex_lock(&smack_known_lock);\r\nskp = smk_find_entry(smack);\r\nif (skp != NULL)\r\ngoto freeout;\r\nskp = kzalloc(sizeof(*skp), GFP_KERNEL);\r\nif (skp == NULL) {\r\nskp = ERR_PTR(-ENOMEM);\r\ngoto freeout;\r\n}\r\nskp->smk_known = smack;\r\nskp->smk_secid = smack_next_secid++;\r\nskp->smk_netlabel.domain = skp->smk_known;\r\nskp->smk_netlabel.flags =\r\nNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\r\nslen = strlen(smack);\r\nif (slen < SMK_CIPSOLEN)\r\nrc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\r\n&skp->smk_netlabel, slen);\r\nelse\r\nrc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\r\n&skp->smk_netlabel, sizeof(skp->smk_secid));\r\nif (rc >= 0) {\r\nINIT_LIST_HEAD(&skp->smk_rules);\r\nmutex_init(&skp->smk_rules_lock);\r\nsmk_insert_entry(skp);\r\ngoto unlockout;\r\n}\r\nkfree(skp);\r\nskp = ERR_PTR(rc);\r\nfreeout:\r\nkfree(smack);\r\nunlockout:\r\nmutex_unlock(&smack_known_lock);\r\nreturn skp;\r\n}\r\nstruct smack_known *smack_from_secid(const u32 secid)\r\n{\r\nstruct smack_known *skp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (skp->smk_secid == secid) {\r\nrcu_read_unlock();\r\nreturn skp;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn &smack_known_invalid;\r\n}\r\nint smack_privileged(int cap)\r\n{\r\nstruct smack_known *skp = smk_of_current();\r\nstruct smack_known_list_elem *sklep;\r\nif (unlikely(current->flags & PF_KTHREAD))\r\nreturn 1;\r\nif (!capable(cap))\r\nreturn 0;\r\nrcu_read_lock();\r\nif (list_empty(&smack_onlycap_list)) {\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\nlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\r\nif (sklep->smk_label == skp) {\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}
