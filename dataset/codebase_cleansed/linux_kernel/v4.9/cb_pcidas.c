static int cb_pcidas_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int status;\r\nstatus = inw(devpriv->pcibar1 + PCIDAS_AI_REG);\r\nif (status & PCIDAS_AI_EOC)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int cb_pcidas_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned int bits;\r\nint ret;\r\nint n;\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\noutw(PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src),\r\ndevpriv->pcibar1 + PCIDAS_CALIB_REG);\r\nchan = 0;\r\n} else {\r\noutw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\n}\r\nbits = PCIDAS_AI_CHAN(chan) | PCIDAS_AI_GAIN(range);\r\nif (comedi_range_is_unipolar(s, range))\r\nbits |= PCIDAS_AI_UNIP;\r\nif (aref != AREF_DIFF)\r\nbits |= PCIDAS_AI_SE;\r\noutw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);\r\noutw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(0, devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\r\nret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[n] = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\r\n}\r\nreturn n;\r\n}\r\nstatic int cb_pcidas_ai_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nint id = data[0];\r\nunsigned int source = data[1];\r\nswitch (id) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nif (source >= 8) {\r\ndev_err(dev->class_dev,\r\n"invalid calibration source: %i\n",\r\nsource);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->calib_src = source;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ao_nofifo_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_ctrl &= ~(PCIDAS_AO_UPDATE_BOTH |\r\nPCIDAS_AO_RANGE_MASK(chan));\r\ndevpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range);\r\noutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutw(val, devpriv->pcibar4 + PCIDAS_AO_DATA_REG(chan));\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ao_fifo_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nunsigned long flags;\r\nint i;\r\noutw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_ctrl &= ~(PCIDAS_AO_CHAN_MASK | PCIDAS_AO_RANGE_MASK(chan) |\r\nPCIDAS_AO_PACER_MASK);\r\ndevpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range) |\r\nPCIDAS_AO_CHAN_EN(chan) | PCIDAS_AO_START;\r\noutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutw(val, devpriv->pcibar4 + PCIDAS_AO_FIFO_REG);\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_eeprom_ready(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int status;\r\nstatus = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\r\nif ((status & MCSR_NV_BUSY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);\r\nif (ret)\r\nreturn ret;\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,\r\ndevpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\r\noutb(chan & 0xff, devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,\r\ndevpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\r\noutb((chan >> 8) & 0xff,\r\ndevpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_READ,\r\ndevpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\r\nret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void cb_pcidas_calib_write(struct comedi_device *dev,\r\nunsigned int val, unsigned int len,\r\nbool trimpot)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int calib_bits;\r\nunsigned int bit;\r\ncalib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\r\nif (trimpot) {\r\ncalib_bits |= PCIDAS_CALIB_TRIM_SEL;\r\noutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\n}\r\nfor (bit = 1 << (len - 1); bit; bit >>= 1) {\r\nif (val & bit)\r\ncalib_bits |= PCIDAS_CALIB_DATA;\r\nelse\r\ncalib_bits &= ~PCIDAS_CALIB_DATA;\r\nudelay(1);\r\noutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\n}\r\nudelay(1);\r\ncalib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\r\nif (!trimpot) {\r\noutw(calib_bits | PCIDAS_CALIB_8800_SEL,\r\ndevpriv->pcibar1 + PCIDAS_CALIB_REG);\r\nudelay(1);\r\n}\r\noutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\n}\r\nstatic int cb_pcidas_caldac_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncb_pcidas_calib_write(dev, (chan << 8) | val, 11,\r\nfalse);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void cb_pcidas_dac08_write(struct comedi_device *dev, unsigned int val)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nval |= PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\r\noutw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\nudelay(1);\r\noutw(val | PCIDAS_CALIB_DAC08_SEL,\r\ndevpriv->pcibar1 + PCIDAS_CALIB_REG);\r\nudelay(1);\r\noutw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\nudelay(1);\r\n}\r\nstatic int cb_pcidas_dac08_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncb_pcidas_dac08_write(dev, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void cb_pcidas_trimpot_write(struct comedi_device *dev,\r\nunsigned int chan, unsigned int val)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nif (board->has_ad8402) {\r\ncb_pcidas_calib_write(dev, (chan << 8) | val, 10, true);\r\n} else {\r\ncb_pcidas_calib_write(dev, val, 7, true);\r\n}\r\n}\r\nstatic int cb_pcidas_trimpot_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncb_pcidas_trimpot_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int cb_pcidas_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (chan != (chan0 + i) % s->n_chan) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nreturn -EINVAL;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must all have the same gain\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (cmd->start_src == TRIG_EXT &&\r\n(cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->start_arg\r\n& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {\r\ncmd->start_arg &= ~(CR_FLAGS_MASK &\r\n~(CR_EDGE | CR_INVERT));\r\nerr |= -EINVAL;\r\n}\r\nif (!board->is_1602 && (cmd->start_arg & CR_INVERT)) {\r\ncmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);\r\nerr |= -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed *\r\ncmd->chanlist_len);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\narg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nunsigned int bits;\r\nunsigned long flags;\r\noutw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);\r\noutw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);\r\noutw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);\r\nbits = PCIDAS_AI_FIRST(CR_CHAN(cmd->chanlist[0])) |\r\nPCIDAS_AI_LAST(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |\r\nPCIDAS_AI_GAIN(range0);\r\nif (comedi_range_is_unipolar(s, range0))\r\nbits |= PCIDAS_AI_UNIP;\r\nif (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)\r\nbits |= PCIDAS_AI_SE;\r\nif (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)\r\nbits |= PCIDAS_AI_PACER_EXTP;\r\nelse\r\nbits |= PCIDAS_AI_PACER_INT;\r\noutw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);\r\nif (cmd->scan_begin_src == TRIG_TIMER ||\r\ncmd->convert_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ctrl |= PCIDAS_CTRL_INTE;\r\ndevpriv->ctrl &= ~PCIDAS_CTRL_INT_MASK;\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {\r\ndevpriv->ctrl |= PCIDAS_CTRL_INT_EOS;\r\n} else {\r\ndevpriv->ctrl |= PCIDAS_CTRL_INT_FNE;\r\n}\r\n} else {\r\ndevpriv->ctrl |= PCIDAS_CTRL_INT_FHF;\r\n}\r\noutw(devpriv->ctrl |\r\nPCIDAS_CTRL_EOAI | PCIDAS_CTRL_INT_CLR | PCIDAS_CTRL_LADFUL,\r\ndevpriv->pcibar1 + PCIDAS_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nbits = 0;\r\nif (cmd->start_src == TRIG_NOW) {\r\nbits |= PCIDAS_TRIG_SEL_SW;\r\n} else {\r\nbits |= PCIDAS_TRIG_SEL_EXT | PCIDAS_TRIG_EN | PCIDAS_TRIG_CLR;\r\nif (board->is_1602) {\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= PCIDAS_TRIG_POL;\r\nif (cmd->start_arg & CR_EDGE)\r\nbits |= PCIDAS_TRIG_MODE;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)\r\nbits |= PCIDAS_TRIG_BURSTE;\r\noutw(bits, devpriv->pcibar1 + PCIDAS_TRIG_REG);\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nif (cmd->chanlist_len > 1) {\r\nunsigned int chan1 = CR_CHAN(cmd->chanlist[1]);\r\nif (chan0 != 0 || chan1 != 1) {\r\ndev_dbg(dev->class_dev,\r\n"channels must be ordered channel 0, channel 1 in chanlist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ao_scan_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int arg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(devpriv->ao_pacer,\r\n&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas_ao_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ctrl &= ~(PCIDAS_CTRL_INTE | PCIDAS_CTRL_EOAIE);\r\noutw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);\r\noutw(PCIDAS_AI_PACER_SW, devpriv->pcibar1 + PCIDAS_AI_REG);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_ao_load_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int nsamples)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int nbytes;\r\nnsamples = comedi_nsamples_left(s, nsamples);\r\nnbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\noutsw(devpriv->pcibar4 + PCIDAS_AO_FIFO_REG,\r\ndevpriv->ao_buffer, nsamples);\r\n}\r\nstatic int cb_pcidas_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long flags;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ncb_pcidas_ao_load_fifo(dev, s, board->fifo_size);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ctrl |= PCIDAS_CTRL_DAEMIE | PCIDAS_CTRL_DAHFIE;\r\noutw(devpriv->ctrl | PCIDAS_CTRL_DAEMI | PCIDAS_CTRL_DAHFI,\r\ndevpriv->pcibar1 + PCIDAS_CTRL_REG);\r\ndevpriv->ao_ctrl |= PCIDAS_AO_START | PCIDAS_AO_DACEN | PCIDAS_AO_EMPTY;\r\noutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = NULL;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\ndevpriv->ao_ctrl |= PCIDAS_AO_CHAN_EN(chan);\r\ndevpriv->ao_ctrl |= PCIDAS_AO_RANGE(chan, range);\r\n}\r\noutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(devpriv->ao_pacer);\r\ncomedi_8254_pacer_enable(devpriv->ao_pacer, 1, 2, true);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->ao_ctrl |= PCIDAS_AO_PACER_INT;\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->ao_ctrl |= PCIDAS_AO_PACER_EXTP;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndev_err(dev->class_dev, "error setting dac pacer source\n");\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = cb_pcidas_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ctrl &= ~(PCIDAS_CTRL_DAHFIE | PCIDAS_CTRL_DAEMIE);\r\noutw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);\r\ndevpriv->ao_ctrl &= ~(PCIDAS_AO_DACEN | PCIDAS_AO_PACER_MASK);\r\noutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned int cb_pcidas_ao_interrupt(struct comedi_device *dev,\r\nunsigned int status)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int irq_clr = 0;\r\nif (status & PCIDAS_CTRL_DAEMI) {\r\nirq_clr |= PCIDAS_CTRL_DAEMI;\r\nif (inw(devpriv->pcibar4 + PCIDAS_AO_REG) & PCIDAS_AO_EMPTY) {\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\n} else {\r\ndev_err(dev->class_dev, "dac fifo underflow\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n} else if (status & PCIDAS_CTRL_DAHFI) {\r\nirq_clr |= PCIDAS_CTRL_DAHFI;\r\ncb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);\r\n}\r\ncomedi_handle_events(dev, s);\r\nreturn irq_clr;\r\n}\r\nstatic unsigned int cb_pcidas_ai_interrupt(struct comedi_device *dev,\r\nunsigned int status)\r\n{\r\nconst struct cb_pcidas_board *board = dev->board_ptr;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int irq_clr = 0;\r\nif (status & PCIDAS_CTRL_ADHFI) {\r\nunsigned int num_samples;\r\nirq_clr |= PCIDAS_CTRL_INT_CLR;\r\nnum_samples = comedi_nsamples_left(s, board->fifo_size / 2);\r\ninsw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,\r\ndevpriv->ai_buffer, num_samples);\r\ncomedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n} else if (status & (PCIDAS_CTRL_ADNEI | PCIDAS_CTRL_EOBI)) {\r\nunsigned int i;\r\nirq_clr |= PCIDAS_CTRL_INT_CLR;\r\nfor (i = 0; i < 10000; i++) {\r\nunsigned short val;\r\nif ((inw(devpriv->pcibar1 + PCIDAS_CTRL_REG) &\r\nPCIDAS_CTRL_ADNE) == 0)\r\nbreak;\r\nval = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\n} else if (status & PCIDAS_CTRL_EOAI) {\r\nirq_clr |= PCIDAS_CTRL_EOAI;\r\ndev_err(dev->class_dev,\r\n"bug! encountered end of acquisition interrupt?\n");\r\n}\r\nif (status & PCIDAS_CTRL_LADFUL) {\r\nirq_clr |= PCIDAS_CTRL_LADFUL;\r\ndev_err(dev->class_dev, "fifo overflow\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\ncomedi_handle_events(dev, s);\r\nreturn irq_clr;\r\n}\r\nstatic irqreturn_t cb_pcidas_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nunsigned int irq_clr = 0;\r\nunsigned int amcc_status;\r\nunsigned int status;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\namcc_status = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\r\nif ((INTCSR_INTR_ASSERTED & amcc_status) == 0)\r\nreturn IRQ_NONE;\r\ninl_p(devpriv->amcc + AMCC_OP_REG_IMB4);\r\noutl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\nstatus = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);\r\nif (status & PCIDAS_CTRL_AO_INT)\r\nirq_clr |= cb_pcidas_ao_interrupt(dev, status);\r\nif (status & PCIDAS_CTRL_AI_INT)\r\nirq_clr |= cb_pcidas_ai_interrupt(dev, status);\r\nif (irq_clr) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->ctrl | irq_clr,\r\ndevpriv->pcibar1 + PCIDAS_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cb_pcidas_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct cb_pcidas_board *board = NULL;\r\nstruct cb_pcidas_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint i;\r\nint ret;\r\nif (context < ARRAY_SIZE(cb_pcidas_boards))\r\nboard = &cb_pcidas_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->amcc = pci_resource_start(pcidev, 0);\r\ndevpriv->pcibar1 = pci_resource_start(pcidev, 1);\r\ndevpriv->pcibar2 = pci_resource_start(pcidev, 2);\r\ndev->iobase = pci_resource_start(pcidev, 3);\r\nif (board->has_ao)\r\ndevpriv->pcibar4 = pci_resource_start(pcidev, 4);\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\nret = request_irq(pcidev->irq, cb_pcidas_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret) {\r\ndev_dbg(dev->class_dev, "unable to allocate irq %d\n",\r\npcidev->irq);\r\nreturn ret;\r\n}\r\ndev->irq = pcidev->irq;\r\ndev->pacer = comedi_8254_init(dev->iobase + PCIDAS_AI_8254_BASE,\r\nI8254_OSC_BASE_10MHZ, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ndevpriv->ao_pacer = comedi_8254_init(dev->iobase + PCIDAS_AO_8254_BASE,\r\nI8254_OSC_BASE_10MHZ,\r\nI8254_IO8, 0);\r\nif (!devpriv->ao_pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 7);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = board->is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = board->use_alt_range ? &cb_pcidas_alt_ranges\r\n: &cb_pcidas_ranges;\r\ns->insn_read = cb_pcidas_ai_insn_read;\r\ns->insn_config = cb_pcidas_ai_insn_config;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmd = cb_pcidas_ai_cmd;\r\ns->do_cmdtest = cb_pcidas_ai_cmdtest;\r\ns->cancel = cb_pcidas_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = 2;\r\ns->maxdata = board->is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = &cb_pcidas_ao_ranges;\r\ns->insn_write = (board->has_ao_fifo)\r\n? cb_pcidas_ao_fifo_insn_write\r\n: cb_pcidas_ao_nofifo_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nif (dev->irq && board->has_ao_fifo) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->do_cmdtest = cb_pcidas_ao_cmdtest;\r\ns->do_cmd = cb_pcidas_ao_cmd;\r\ns->cancel = cb_pcidas_ao_cancel;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nret = subdev_8255_init(dev, s, NULL, PCIDAS_8255_BASE);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 256;\r\ns->maxdata = 0xff;\r\ns->insn_read = cb_pcidas_eeprom_insn_read;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 8;\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas_caldac_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nunsigned int val = s->maxdata / 2;\r\ncb_pcidas_calib_write(dev, (i << 8) | val, 11, false);\r\ns->readback[i] = val;\r\n}\r\ns = &dev->subdevices[5];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;\r\nif (board->has_ad8402) {\r\ns->n_chan = 2;\r\ns->maxdata = 0xff;\r\n} else {\r\ns->n_chan = 1;\r\ns->maxdata = 0x7f;\r\n}\r\ns->insn_write = cb_pcidas_trimpot_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ncb_pcidas_trimpot_write(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\ns = &dev->subdevices[6];\r\nif (board->has_dac08) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 1;\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas_dac08_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ncb_pcidas_dac08_write(dev, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ninl(devpriv->amcc + AMCC_OP_REG_IMB4);\r\ndevpriv->amcc_intcsr = INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |\r\nINTCSR_INBOX_FULL_INT;\r\noutl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_detach(struct comedi_device *dev)\r\n{\r\nstruct cb_pcidas_private *devpriv = dev->private;\r\nif (devpriv) {\r\nif (devpriv->amcc)\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\nkfree(devpriv->ao_pacer);\r\n}\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int cb_pcidas_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &cb_pcidas_driver,\r\nid->driver_data);\r\n}
