static irqreturn_t mcs5000_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mcs5000_ts_data *data = dev_id;\r\nstruct i2c_client *client = data->client;\r\nu8 buffer[READ_BLOCK_SIZE];\r\nint err;\r\nint x;\r\nint y;\r\nerr = i2c_smbus_read_i2c_block_data(client, MCS5000_TS_INPUT_INFO,\r\nREAD_BLOCK_SIZE, buffer);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s, err[%d]\n", __func__, err);\r\ngoto out;\r\n}\r\nswitch (buffer[READ_INPUT_INFO]) {\r\ncase INPUT_TYPE_NONTOUCH:\r\ninput_report_key(data->input_dev, BTN_TOUCH, 0);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase INPUT_TYPE_SINGLE:\r\nx = (buffer[READ_X_POS_UPPER] << 8) | buffer[READ_X_POS_LOWER];\r\ny = (buffer[READ_Y_POS_UPPER] << 8) | buffer[READ_Y_POS_LOWER];\r\ninput_report_key(data->input_dev, BTN_TOUCH, 1);\r\ninput_report_abs(data->input_dev, ABS_X, x);\r\ninput_report_abs(data->input_dev, ABS_Y, y);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase INPUT_TYPE_DUAL:\r\nbreak;\r\ncase INPUT_TYPE_PALM:\r\nbreak;\r\ncase INPUT_TYPE_PROXIMITY:\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Unknown ts input type %d\n",\r\nbuffer[READ_INPUT_INFO]);\r\nbreak;\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mcs5000_ts_phys_init(struct mcs5000_ts_data *data,\r\nconst struct mcs_platform_data *platform_data)\r\n{\r\nstruct i2c_client *client = data->client;\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE,\r\nRESET_EXT_SOFT | OP_MODE_SLEEP);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_UPPER,\r\nplatform_data->x_size >> 8);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_LOWER,\r\nplatform_data->x_size & 0xff);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_UPPER,\r\nplatform_data->y_size >> 8);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_LOWER,\r\nplatform_data->y_size & 0xff);\r\ni2c_smbus_write_byte_data(data->client, MCS5000_TS_OP_MODE,\r\nOP_MODE_ACTIVE | REPORT_RATE_80);\r\n}\r\nstatic int mcs5000_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mcs_platform_data *pdata;\r\nstruct mcs5000_ts_data *data;\r\nstruct input_dev *input_dev;\r\nint error;\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->client = client;\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->name = "MELFAS MCS-5000 Touchscreen";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MCS5000_MAX_XC, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MCS5000_MAX_YC, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\ndata->input_dev = input_dev;\r\nif (pdata->cfg_pin)\r\npdata->cfg_pin();\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, mcs5000_ts_interrupt,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"mcs5000_ts", data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(data->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register input device\n");\r\nreturn error;\r\n}\r\nmcs5000_ts_phys_init(data, pdata);\r\ni2c_set_clientdata(client, data);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mcs5000_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE, OP_MODE_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mcs5000_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mcs5000_ts_data *data = i2c_get_clientdata(client);\r\nconst struct mcs_platform_data *pdata = dev_get_platdata(dev);\r\nmcs5000_ts_phys_init(data, pdata);\r\nreturn 0;\r\n}
