static void __noreturn unhandled_fault(unsigned long address,\r\nstruct task_struct *tsk,\r\nstruct pt_regs *regs)\r\n{\r\nif ((unsigned long) address < PAGE_SIZE) {\r\nprintk(KERN_ALERT\r\n"Unable to handle kernel NULL pointer dereference\n");\r\n} else {\r\nprintk(KERN_ALERT "Unable to handle kernel paging request at virtual address %08lx\n",\r\naddress);\r\n}\r\nprintk(KERN_ALERT "tsk->{mm,active_mm}->context = %08lx\n",\r\n(tsk->mm ? tsk->mm->context : tsk->active_mm->context));\r\nprintk(KERN_ALERT "tsk->{mm,active_mm}->pgd = %08lx\n",\r\n(tsk->mm ? (unsigned long) tsk->mm->pgd :\r\n(unsigned long) tsk->active_mm->pgd));\r\ndie_if_kernel("Oops", regs);\r\n}\r\nasmlinkage int lookup_fault(unsigned long pc, unsigned long ret_pc,\r\nunsigned long address)\r\n{\r\nstruct pt_regs regs;\r\nunsigned long g2;\r\nunsigned int insn;\r\nint i;\r\ni = search_extables_range(ret_pc, &g2);\r\nswitch (i) {\r\ncase 3:\r\nreturn 3;\r\ncase 1:\r\ninsn = *((unsigned int *) pc);\r\nif ((insn >> 21) & 1)\r\nreturn 1;\r\nbreak;\r\ncase 2:\r\ninsn = *((unsigned int *) pc);\r\nif (!((insn >> 21) & 1) || ((insn>>19)&0x3f) == 15)\r\nreturn 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmemset(&regs, 0, sizeof(regs));\r\nregs.pc = pc;\r\nregs.npc = pc + 4;\r\n__asm__ __volatile__(\r\n"rd %%psr, %0\n\t"\r\n"nop\n\t"\r\n"nop\n\t"\r\n"nop\n" : "=r" (regs.psr));\r\nunhandled_fault(address, current, &regs);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nshow_signal_msg(struct pt_regs *regs, int sig, int code,\r\nunsigned long address, struct task_struct *tsk)\r\n{\r\nif (!unhandled_signal(tsk, sig))\r\nreturn;\r\nif (!printk_ratelimit())\r\nreturn;\r\nprintk("%s%s[%d]: segfault at %lx ip %p (rpc %p) sp %p error %x",\r\ntask_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,\r\ntsk->comm, task_pid_nr(tsk), address,\r\n(void *)regs->pc, (void *)regs->u_regs[UREG_I7],\r\n(void *)regs->u_regs[UREG_FP], code);\r\nprint_vma_addr(KERN_CONT " in ", regs->pc);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void __do_fault_siginfo(int code, int sig, struct pt_regs *regs,\r\nunsigned long addr)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = sig;\r\ninfo.si_code = code;\r\ninfo.si_errno = 0;\r\ninfo.si_addr = (void __user *) addr;\r\ninfo.si_trapno = 0;\r\nif (unlikely(show_unhandled_signals))\r\nshow_signal_msg(regs, sig, info.si_code,\r\naddr, current);\r\nforce_sig_info (sig, &info, current);\r\n}\r\nstatic unsigned long compute_si_addr(struct pt_regs *regs, int text_fault)\r\n{\r\nunsigned int insn;\r\nif (text_fault)\r\nreturn regs->pc;\r\nif (regs->psr & PSR_PS)\r\ninsn = *(unsigned int *) regs->pc;\r\nelse\r\n__get_user(insn, (unsigned int *) regs->pc);\r\nreturn safe_compute_effective_address(regs, insn);\r\n}\r\nstatic noinline void do_fault_siginfo(int code, int sig, struct pt_regs *regs,\r\nint text_fault)\r\n{\r\nunsigned long addr = compute_si_addr(regs, text_fault);\r\n__do_fault_siginfo(code, sig, regs, addr);\r\n}\r\nasmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\r\nunsigned long address)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct task_struct *tsk = current;\r\nstruct mm_struct *mm = tsk->mm;\r\nunsigned int fixup;\r\nunsigned long g2;\r\nint from_user = !(regs->psr & PSR_PS);\r\nint fault, code;\r\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\r\nif (text_fault)\r\naddress = regs->pc;\r\ncode = SEGV_MAPERR;\r\nif (address >= TASK_SIZE)\r\ngoto vmalloc_fault;\r\nif (pagefault_disabled() || !mm)\r\ngoto no_context;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\r\nretry:\r\ndown_read(&mm->mmap_sem);\r\nif (!from_user && address >= PAGE_OFFSET)\r\ngoto bad_area;\r\nvma = find_vma(mm, address);\r\nif (!vma)\r\ngoto bad_area;\r\nif (vma->vm_start <= address)\r\ngoto good_area;\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto bad_area;\r\nif (expand_stack(vma, address))\r\ngoto bad_area;\r\ngood_area:\r\ncode = SEGV_ACCERR;\r\nif (write) {\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto bad_area;\r\n} else {\r\nif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto bad_area;\r\n}\r\nif (from_user)\r\nflags |= FAULT_FLAG_USER;\r\nif (write)\r\nflags |= FAULT_FLAG_WRITE;\r\nfault = handle_mm_fault(vma, address, flags);\r\nif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\r\nreturn;\r\nif (unlikely(fault & VM_FAULT_ERROR)) {\r\nif (fault & VM_FAULT_OOM)\r\ngoto out_of_memory;\r\nelse if (fault & VM_FAULT_SIGSEGV)\r\ngoto bad_area;\r\nelse if (fault & VM_FAULT_SIGBUS)\r\ngoto do_sigbus;\r\nBUG();\r\n}\r\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\r\nif (fault & VM_FAULT_MAJOR) {\r\ncurrent->maj_flt++;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\r\n1, regs, address);\r\n} else {\r\ncurrent->min_flt++;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\r\n1, regs, address);\r\n}\r\nif (fault & VM_FAULT_RETRY) {\r\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\r\nflags |= FAULT_FLAG_TRIED;\r\ngoto retry;\r\n}\r\n}\r\nup_read(&mm->mmap_sem);\r\nreturn;\r\nbad_area:\r\nup_read(&mm->mmap_sem);\r\nbad_area_nosemaphore:\r\nif (from_user) {\r\ndo_fault_siginfo(code, SIGSEGV, regs, text_fault);\r\nreturn;\r\n}\r\nno_context:\r\ng2 = regs->u_regs[UREG_G2];\r\nif (!from_user) {\r\nfixup = search_extables_range(regs->pc, &g2);\r\nif (fixup > 10) {\r\nextern const unsigned int __memset_start[];\r\nextern const unsigned int __memset_end[];\r\nextern const unsigned int __csum_partial_copy_start[];\r\nextern const unsigned int __csum_partial_copy_end[];\r\n#ifdef DEBUG_EXCEPTIONS\r\nprintk("Exception: PC<%08lx> faddr<%08lx>\n",\r\nregs->pc, address);\r\nprintk("EX_TABLE: insn<%08lx> fixup<%08x> g2<%08lx>\n",\r\nregs->pc, fixup, g2);\r\n#endif\r\nif ((regs->pc >= (unsigned long)__memset_start &&\r\nregs->pc < (unsigned long)__memset_end) ||\r\n(regs->pc >= (unsigned long)__csum_partial_copy_start &&\r\nregs->pc < (unsigned long)__csum_partial_copy_end)) {\r\nregs->u_regs[UREG_I4] = address;\r\nregs->u_regs[UREG_I5] = regs->pc;\r\n}\r\nregs->u_regs[UREG_G2] = g2;\r\nregs->pc = fixup;\r\nregs->npc = regs->pc + 4;\r\nreturn;\r\n}\r\n}\r\nunhandled_fault(address, tsk, regs);\r\ndo_exit(SIGKILL);\r\nout_of_memory:\r\nup_read(&mm->mmap_sem);\r\nif (from_user) {\r\npagefault_out_of_memory();\r\nreturn;\r\n}\r\ngoto no_context;\r\ndo_sigbus:\r\nup_read(&mm->mmap_sem);\r\ndo_fault_siginfo(BUS_ADRERR, SIGBUS, regs, text_fault);\r\nif (!from_user)\r\ngoto no_context;\r\nvmalloc_fault:\r\n{\r\nint offset = pgd_index(address);\r\npgd_t *pgd, *pgd_k;\r\npmd_t *pmd, *pmd_k;\r\npgd = tsk->active_mm->pgd + offset;\r\npgd_k = init_mm.pgd + offset;\r\nif (!pgd_present(*pgd)) {\r\nif (!pgd_present(*pgd_k))\r\ngoto bad_area_nosemaphore;\r\npgd_val(*pgd) = pgd_val(*pgd_k);\r\nreturn;\r\n}\r\npmd = pmd_offset(pgd, address);\r\npmd_k = pmd_offset(pgd_k, address);\r\nif (pmd_present(*pmd) || !pmd_present(*pmd_k))\r\ngoto bad_area_nosemaphore;\r\n*pmd = *pmd_k;\r\nreturn;\r\n}\r\n}\r\nstatic void force_user_fault(unsigned long address, int write)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct task_struct *tsk = current;\r\nstruct mm_struct *mm = tsk->mm;\r\nunsigned int flags = FAULT_FLAG_USER;\r\nint code;\r\ncode = SEGV_MAPERR;\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, address);\r\nif (!vma)\r\ngoto bad_area;\r\nif (vma->vm_start <= address)\r\ngoto good_area;\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto bad_area;\r\nif (expand_stack(vma, address))\r\ngoto bad_area;\r\ngood_area:\r\ncode = SEGV_ACCERR;\r\nif (write) {\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto bad_area;\r\nflags |= FAULT_FLAG_WRITE;\r\n} else {\r\nif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto bad_area;\r\n}\r\nswitch (handle_mm_fault(vma, address, flags)) {\r\ncase VM_FAULT_SIGBUS:\r\ncase VM_FAULT_OOM:\r\ngoto do_sigbus;\r\n}\r\nup_read(&mm->mmap_sem);\r\nreturn;\r\nbad_area:\r\nup_read(&mm->mmap_sem);\r\n__do_fault_siginfo(code, SIGSEGV, tsk->thread.kregs, address);\r\nreturn;\r\ndo_sigbus:\r\nup_read(&mm->mmap_sem);\r\n__do_fault_siginfo(BUS_ADRERR, SIGBUS, tsk->thread.kregs, address);\r\n}\r\nstatic void check_stack_aligned(unsigned long sp)\r\n{\r\nif (sp & 0x7UL)\r\nforce_sig(SIGILL, current);\r\n}\r\nvoid window_overflow_fault(void)\r\n{\r\nunsigned long sp;\r\nsp = current_thread_info()->rwbuf_stkptrs[0];\r\nif (((sp + 0x38) & PAGE_MASK) != (sp & PAGE_MASK))\r\nforce_user_fault(sp + 0x38, 1);\r\nforce_user_fault(sp, 1);\r\ncheck_stack_aligned(sp);\r\n}\r\nvoid window_underflow_fault(unsigned long sp)\r\n{\r\nif (((sp + 0x38) & PAGE_MASK) != (sp & PAGE_MASK))\r\nforce_user_fault(sp + 0x38, 0);\r\nforce_user_fault(sp, 0);\r\ncheck_stack_aligned(sp);\r\n}\r\nvoid window_ret_fault(struct pt_regs *regs)\r\n{\r\nunsigned long sp;\r\nsp = regs->u_regs[UREG_FP];\r\nif (((sp + 0x38) & PAGE_MASK) != (sp & PAGE_MASK))\r\nforce_user_fault(sp + 0x38, 0);\r\nforce_user_fault(sp, 0);\r\ncheck_stack_aligned(sp);\r\n}
