static __le32 sctp_gso_make_checksum(struct sk_buff *skb)\r\n{\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn sctp_compute_cksum(skb, skb_transport_offset(skb));\r\n}\r\nstatic struct sk_buff *sctp_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nstruct sctphdr *sh;\r\nsh = sctp_hdr(skb);\r\nif (!pskb_may_pull(skb, sizeof(*sh)))\r\ngoto out;\r\n__skb_pull(skb, sizeof(*sh));\r\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\r\nstruct skb_shared_info *pinfo = skb_shinfo(skb);\r\nstruct sk_buff *frag_iter;\r\npinfo->gso_segs = 0;\r\nif (skb->len != skb->data_len) {\r\npinfo->gso_segs++;\r\n}\r\nskb_walk_frags(skb, frag_iter)\r\npinfo->gso_segs++;\r\nsegs = NULL;\r\ngoto out;\r\n}\r\nsegs = skb_segment(skb, features | NETIF_F_HW_CSUM);\r\nif (IS_ERR(segs))\r\ngoto out;\r\nif (!(features & NETIF_F_SCTP_CRC)) {\r\nfor (skb = segs; skb; skb = skb->next) {\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nsh = sctp_hdr(skb);\r\nsh->checksum = sctp_gso_make_checksum(skb);\r\n}\r\n}\r\n}\r\nout:\r\nreturn segs;\r\n}\r\nint __init sctp_offload_init(void)\r\n{\r\nint ret;\r\nret = inet_add_offload(&sctp_offload, IPPROTO_SCTP);\r\nif (ret)\r\ngoto out;\r\nret = inet6_add_offload(&sctp6_offload, IPPROTO_SCTP);\r\nif (ret)\r\ngoto ipv4;\r\nreturn ret;\r\nipv4:\r\ninet_del_offload(&sctp_offload, IPPROTO_SCTP);\r\nout:\r\nreturn ret;\r\n}
