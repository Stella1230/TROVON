static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nu16 per_data_width, mem_data_width;\r\nstruct stedma40_chan_cfg *dma_cfg;\r\nstruct ux500_msp_dma_params *dma_params;\r\ndma_params = snd_soc_dai_get_dma_data(dai, substream);\r\ndma_cfg = dma_params->dma_cfg;\r\nmem_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nswitch (dma_params->data_size) {\r\ncase 32:\r\nper_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\ncase 16:\r\nper_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase 8:\r\nper_data_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nbreak;\r\ndefault:\r\nper_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_cfg->src_info.data_width = mem_data_width;\r\ndma_cfg->dst_info.data_width = per_data_width;\r\n} else {\r\ndma_cfg->src_info.data_width = per_data_width;\r\ndma_cfg->dst_info.data_width = mem_data_width;\r\n}\r\nreturn snd_dmaengine_pcm_request_channel(stedma40_filter, dma_cfg);\r\n}\r\nstatic int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct msp_i2s_platform_data *pdata = rtd->cpu_dai->dev->platform_data;\r\nstruct snd_dmaengine_dai_dma_data *snd_dma_params;\r\nstruct ux500_msp_dma_params *ste_dma_params;\r\ndma_addr_t dma_addr;\r\nint ret;\r\nif (pdata) {\r\nste_dma_params =\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\ndma_addr = ste_dma_params->tx_rx_addr;\r\n} else {\r\nsnd_dma_params =\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\ndma_addr = snd_dma_params->addr;\r\n}\r\nret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\r\nif (ret)\r\nreturn ret;\r\nslave_config->dst_maxburst = 4;\r\nslave_config->src_maxburst = 4;\r\nslave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nslave_config->dst_addr = dma_addr;\r\nelse\r\nslave_config->src_addr = dma_addr;\r\nreturn 0;\r\n}\r\nint ux500_pcm_register_platform(struct platform_device *pdev)\r\n{\r\nconst struct snd_dmaengine_pcm_config *pcm_config;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (np)\r\npcm_config = &ux500_dmaengine_of_pcm_config;\r\nelse\r\npcm_config = &ux500_dmaengine_pcm_config;\r\nret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config,\r\nSND_DMAENGINE_PCM_FLAG_COMPAT);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"%s: ERROR: Failed to register platform '%s' (%d)!\n",\r\n__func__, pdev->name, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ux500_pcm_unregister_platform(struct platform_device *pdev)\r\n{\r\nsnd_dmaengine_pcm_unregister(&pdev->dev);\r\nreturn 0;\r\n}
