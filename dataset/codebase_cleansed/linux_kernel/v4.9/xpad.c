static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev = xpad->dev;\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_report_abs(dev, ABS_X,\r\n(__s16) le16_to_cpup((__le16 *)(data + 12)));\r\ninput_report_abs(dev, ABS_Y,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 14)));\r\ninput_report_abs(dev, ABS_RX,\r\n(__s16) le16_to_cpup((__le16 *)(data + 16)));\r\ninput_report_abs(dev, ABS_RY,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 18)));\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TL2, data[10]);\r\ninput_report_key(dev, BTN_TR2, data[11]);\r\n} else {\r\ninput_report_abs(dev, ABS_Z, data[10]);\r\ninput_report_abs(dev, ABS_RZ, data[11]);\r\n}\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);\r\n} else {\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!!(data[2] & 0x08) - !!(data[2] & 0x04));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!!(data[2] & 0x02) - !!(data[2] & 0x01));\r\n}\r\ninput_report_key(dev, BTN_START, data[2] & 0x10);\r\ninput_report_key(dev, BTN_SELECT, data[2] & 0x20);\r\ninput_report_key(dev, BTN_THUMBL, data[2] & 0x40);\r\ninput_report_key(dev, BTN_THUMBR, data[2] & 0x80);\r\ninput_report_key(dev, BTN_A, data[4]);\r\ninput_report_key(dev, BTN_B, data[5]);\r\ninput_report_key(dev, BTN_X, data[6]);\r\ninput_report_key(dev, BTN_Y, data[7]);\r\ninput_report_key(dev, BTN_C, data[8]);\r\ninput_report_key(dev, BTN_Z, data[9]);\r\ninput_sync(dev);\r\n}\r\nstatic void xpad360_process_packet(struct usb_xpad *xpad, struct input_dev *dev,\r\nu16 cmd, unsigned char *data)\r\n{\r\nif (data[0] != 0x00)\r\nreturn;\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);\r\n}\r\nif (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||\r\nxpad->xtype == XTYPE_XBOX360W) {\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!!(data[2] & 0x08) - !!(data[2] & 0x04));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!!(data[2] & 0x02) - !!(data[2] & 0x01));\r\n}\r\ninput_report_key(dev, BTN_START, data[2] & 0x10);\r\ninput_report_key(dev, BTN_SELECT, data[2] & 0x20);\r\ninput_report_key(dev, BTN_THUMBL, data[2] & 0x40);\r\ninput_report_key(dev, BTN_THUMBR, data[2] & 0x80);\r\ninput_report_key(dev, BTN_A, data[3] & 0x10);\r\ninput_report_key(dev, BTN_B, data[3] & 0x20);\r\ninput_report_key(dev, BTN_X, data[3] & 0x40);\r\ninput_report_key(dev, BTN_Y, data[3] & 0x80);\r\ninput_report_key(dev, BTN_TL, data[3] & 0x01);\r\ninput_report_key(dev, BTN_TR, data[3] & 0x02);\r\ninput_report_key(dev, BTN_MODE, data[3] & 0x04);\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_report_abs(dev, ABS_X,\r\n(__s16) le16_to_cpup((__le16 *)(data + 6)));\r\ninput_report_abs(dev, ABS_Y,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 8)));\r\ninput_report_abs(dev, ABS_RX,\r\n(__s16) le16_to_cpup((__le16 *)(data + 10)));\r\ninput_report_abs(dev, ABS_RY,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 12)));\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TL2, data[4]);\r\ninput_report_key(dev, BTN_TR2, data[5]);\r\n} else {\r\ninput_report_abs(dev, ABS_Z, data[4]);\r\ninput_report_abs(dev, ABS_RZ, data[5]);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void xpad_presence_work(struct work_struct *work)\r\n{\r\nstruct usb_xpad *xpad = container_of(work, struct usb_xpad, work);\r\nint error;\r\nif (xpad->pad_present) {\r\nerror = xpad_init_input(xpad);\r\nif (error) {\r\ndev_err(&xpad->dev->dev,\r\n"unable to init device: %d\n", error);\r\n} else {\r\nrcu_assign_pointer(xpad->x360w_dev, xpad->dev);\r\n}\r\n} else {\r\nRCU_INIT_POINTER(xpad->x360w_dev, NULL);\r\nsynchronize_rcu();\r\nxpad_deinit_input(xpad);\r\n}\r\n}\r\nstatic void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev;\r\nbool present;\r\nif (data[0] & 0x08) {\r\npresent = (data[1] & 0x80) != 0;\r\nif (xpad->pad_present != present) {\r\nxpad->pad_present = present;\r\nschedule_work(&xpad->work);\r\n}\r\n}\r\nif (data[1] != 0x1)\r\nreturn;\r\nrcu_read_lock();\r\ndev = rcu_dereference(xpad->x360w_dev);\r\nif (dev)\r\nxpad360_process_packet(xpad, dev, cmd, &data[4]);\r\nrcu_read_unlock();\r\n}\r\nstatic void xpadone_process_buttons(struct usb_xpad *xpad,\r\nstruct input_dev *dev,\r\nunsigned char *data)\r\n{\r\ninput_report_key(dev, BTN_START, data[4] & 0x04);\r\ninput_report_key(dev, BTN_SELECT, data[4] & 0x08);\r\ninput_report_key(dev, BTN_A, data[4] & 0x10);\r\ninput_report_key(dev, BTN_B, data[4] & 0x20);\r\ninput_report_key(dev, BTN_X, data[4] & 0x40);\r\ninput_report_key(dev, BTN_Y, data[4] & 0x80);\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY1, data[5] & 0x04);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY2, data[5] & 0x08);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY3, data[5] & 0x01);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY4, data[5] & 0x02);\r\n} else {\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!!(data[5] & 0x08) - !!(data[5] & 0x04));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!!(data[5] & 0x02) - !!(data[5] & 0x01));\r\n}\r\ninput_report_key(dev, BTN_TL, data[5] & 0x10);\r\ninput_report_key(dev, BTN_TR, data[5] & 0x20);\r\ninput_report_key(dev, BTN_THUMBL, data[5] & 0x40);\r\ninput_report_key(dev, BTN_THUMBR, data[5] & 0x80);\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_report_abs(dev, ABS_X,\r\n(__s16) le16_to_cpup((__le16 *)(data + 10)));\r\ninput_report_abs(dev, ABS_Y,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 12)));\r\ninput_report_abs(dev, ABS_RX,\r\n(__s16) le16_to_cpup((__le16 *)(data + 14)));\r\ninput_report_abs(dev, ABS_RY,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 16)));\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TL2,\r\n(__u16) le16_to_cpup((__le16 *)(data + 6)));\r\ninput_report_key(dev, BTN_TR2,\r\n(__u16) le16_to_cpup((__le16 *)(data + 8)));\r\n} else {\r\ninput_report_abs(dev, ABS_Z,\r\n(__u16) le16_to_cpup((__le16 *)(data + 6)));\r\ninput_report_abs(dev, ABS_RZ,\r\n(__u16) le16_to_cpup((__le16 *)(data + 8)));\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void xpadone_process_packet(struct usb_xpad *xpad,\r\nu16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev = xpad->dev;\r\nswitch (data[0]) {\r\ncase 0x20:\r\nxpadone_process_buttons(xpad, dev, data);\r\nbreak;\r\ncase 0x07:\r\ninput_report_key(dev, BTN_MODE, data[4] & 0x01);\r\ninput_sync(dev);\r\nbreak;\r\n}\r\n}\r\nstatic void xpad_irq_in(struct urb *urb)\r\n{\r\nstruct usb_xpad *xpad = urb->context;\r\nstruct device *dev = &xpad->intf->dev;\r\nint retval, status;\r\nstatus = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nswitch (xpad->xtype) {\r\ncase XTYPE_XBOX360:\r\nxpad360_process_packet(xpad, xpad->dev, 0, xpad->idata);\r\nbreak;\r\ncase XTYPE_XBOX360W:\r\nxpad360w_process_packet(xpad, 0, xpad->idata);\r\nbreak;\r\ncase XTYPE_XBOXONE:\r\nxpadone_process_packet(xpad, 0, xpad->idata);\r\nbreak;\r\ndefault:\r\nxpad_process_packet(xpad, 0, xpad->idata);\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic bool xpad_prepare_next_out_packet(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_output_packet *pkt, *packet = NULL;\r\nint i;\r\nfor (i = 0; i < XPAD_NUM_OUT_PACKETS; i++) {\r\nif (++xpad->last_out_packet >= XPAD_NUM_OUT_PACKETS)\r\nxpad->last_out_packet = 0;\r\npkt = &xpad->out_packets[xpad->last_out_packet];\r\nif (pkt->pending) {\r\ndev_dbg(&xpad->intf->dev,\r\n"%s - found pending output packet %d\n",\r\n__func__, xpad->last_out_packet);\r\npacket = pkt;\r\nbreak;\r\n}\r\n}\r\nif (packet) {\r\nmemcpy(xpad->odata, packet->data, packet->len);\r\nxpad->irq_out->transfer_buffer_length = packet->len;\r\npacket->pending = false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int xpad_try_sending_next_out_packet(struct usb_xpad *xpad)\r\n{\r\nint error;\r\nif (!xpad->irq_out_active && xpad_prepare_next_out_packet(xpad)) {\r\nusb_anchor_urb(xpad->irq_out, &xpad->irq_out_anchor);\r\nerror = usb_submit_urb(xpad->irq_out, GFP_ATOMIC);\r\nif (error) {\r\ndev_err(&xpad->intf->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, error);\r\nusb_unanchor_urb(xpad->irq_out);\r\nreturn -EIO;\r\n}\r\nxpad->irq_out_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xpad_irq_out(struct urb *urb)\r\n{\r\nstruct usb_xpad *xpad = urb->context;\r\nstruct device *dev = &xpad->intf->dev;\r\nint status = urb->status;\r\nint error;\r\nunsigned long flags;\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\nswitch (status) {\r\ncase 0:\r\nxpad->irq_out_active = xpad_prepare_next_out_packet(xpad);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nxpad->irq_out_active = false;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\nbreak;\r\n}\r\nif (xpad->irq_out_active) {\r\nusb_anchor_urb(urb, &xpad->irq_out_anchor);\r\nerror = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (error) {\r\ndev_err(dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, error);\r\nusb_unanchor_urb(urb);\r\nxpad->irq_out_active = false;\r\n}\r\n}\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\n}\r\nstatic int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)\r\n{\r\nstruct usb_endpoint_descriptor *ep_irq_out;\r\nint ep_irq_out_idx;\r\nint error;\r\nif (xpad->xtype == XTYPE_UNKNOWN)\r\nreturn 0;\r\ninit_usb_anchor(&xpad->irq_out_anchor);\r\nxpad->odata = usb_alloc_coherent(xpad->udev, XPAD_PKT_LEN,\r\nGFP_KERNEL, &xpad->odata_dma);\r\nif (!xpad->odata) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nspin_lock_init(&xpad->odata_lock);\r\nxpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!xpad->irq_out) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nep_irq_out_idx = xpad->xtype == XTYPE_XBOXONE ? 0 : 1;\r\nep_irq_out = &intf->cur_altsetting->endpoint[ep_irq_out_idx].desc;\r\nusb_fill_int_urb(xpad->irq_out, xpad->udev,\r\nusb_sndintpipe(xpad->udev, ep_irq_out->bEndpointAddress),\r\nxpad->odata, XPAD_PKT_LEN,\r\nxpad_irq_out, xpad, ep_irq_out->bInterval);\r\nxpad->irq_out->transfer_dma = xpad->odata_dma;\r\nxpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nreturn 0;\r\nfail2: usb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);\r\nfail1: return error;\r\n}\r\nstatic void xpad_stop_output(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype != XTYPE_UNKNOWN) {\r\nif (!usb_wait_anchor_empty_timeout(&xpad->irq_out_anchor,\r\n5000)) {\r\ndev_warn(&xpad->intf->dev,\r\n"timed out waiting for output URB to complete, killing\n");\r\nusb_kill_anchored_urbs(&xpad->irq_out_anchor);\r\n}\r\n}\r\n}\r\nstatic void xpad_deinit_output(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype != XTYPE_UNKNOWN) {\r\nusb_free_urb(xpad->irq_out);\r\nusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\r\nxpad->odata, xpad->odata_dma);\r\n}\r\n}\r\nstatic int xpad_inquiry_pad_presence(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_output_packet *packet =\r\n&xpad->out_packets[XPAD_OUT_CMD_IDX];\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\npacket->data[0] = 0x08;\r\npacket->data[1] = 0x00;\r\npacket->data[2] = 0x0F;\r\npacket->data[3] = 0xC0;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = 0x00;\r\npacket->data[6] = 0x00;\r\npacket->data[7] = 0x00;\r\npacket->data[8] = 0x00;\r\npacket->data[9] = 0x00;\r\npacket->data[10] = 0x00;\r\npacket->data[11] = 0x00;\r\npacket->len = 12;\r\npacket->pending = true;\r\nxpad->last_out_packet = -1;\r\nretval = xpad_try_sending_next_out_packet(xpad);\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int xpad_start_xbox_one(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_output_packet *packet =\r\n&xpad->out_packets[XPAD_OUT_CMD_IDX];\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\npacket->data[0] = 0x05;\r\npacket->data[1] = 0x20;\r\npacket->data[2] = xpad->odata_serial++;\r\npacket->data[3] = 0x01;\r\npacket->data[4] = 0x00;\r\npacket->len = 5;\r\npacket->pending = true;\r\nxpad->last_out_packet = -1;\r\nretval = xpad_try_sending_next_out_packet(xpad);\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nstruct xpad_output_packet *packet = &xpad->out_packets[XPAD_OUT_FF_IDX];\r\n__u16 strong;\r\n__u16 weak;\r\nint retval;\r\nunsigned long flags;\r\nif (effect->type != FF_RUMBLE)\r\nreturn 0;\r\nstrong = effect->u.rumble.strong_magnitude;\r\nweak = effect->u.rumble.weak_magnitude;\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\nswitch (xpad->xtype) {\r\ncase XTYPE_XBOX:\r\npacket->data[0] = 0x00;\r\npacket->data[1] = 0x06;\r\npacket->data[2] = 0x00;\r\npacket->data[3] = strong / 256;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = weak / 256;\r\npacket->len = 6;\r\npacket->pending = true;\r\nbreak;\r\ncase XTYPE_XBOX360:\r\npacket->data[0] = 0x00;\r\npacket->data[1] = 0x08;\r\npacket->data[2] = 0x00;\r\npacket->data[3] = strong / 256;\r\npacket->data[4] = weak / 256;\r\npacket->data[5] = 0x00;\r\npacket->data[6] = 0x00;\r\npacket->data[7] = 0x00;\r\npacket->len = 8;\r\npacket->pending = true;\r\nbreak;\r\ncase XTYPE_XBOX360W:\r\npacket->data[0] = 0x00;\r\npacket->data[1] = 0x01;\r\npacket->data[2] = 0x0F;\r\npacket->data[3] = 0xC0;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = strong / 256;\r\npacket->data[6] = weak / 256;\r\npacket->data[7] = 0x00;\r\npacket->data[8] = 0x00;\r\npacket->data[9] = 0x00;\r\npacket->data[10] = 0x00;\r\npacket->data[11] = 0x00;\r\npacket->len = 12;\r\npacket->pending = true;\r\nbreak;\r\ncase XTYPE_XBOXONE:\r\npacket->data[0] = 0x09;\r\npacket->data[1] = 0x00;\r\npacket->data[2] = xpad->odata_serial++;\r\npacket->data[3] = 0x09;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = 0x0F;\r\npacket->data[6] = 0x00;\r\npacket->data[7] = 0x00;\r\npacket->data[8] = strong / 512;\r\npacket->data[9] = weak / 512;\r\npacket->data[10] = 0xFF;\r\npacket->data[11] = 0x00;\r\npacket->data[12] = 0x00;\r\npacket->len = 13;\r\npacket->pending = true;\r\nbreak;\r\ndefault:\r\ndev_dbg(&xpad->dev->dev,\r\n"%s - rumble command sent to unsupported xpad type: %d\n",\r\n__func__, xpad->xtype);\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nretval = xpad_try_sending_next_out_packet(xpad);\r\nout:\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int xpad_init_ff(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype == XTYPE_UNKNOWN)\r\nreturn 0;\r\ninput_set_capability(xpad->dev, EV_FF, FF_RUMBLE);\r\nreturn input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);\r\n}\r\nstatic int xpad_init_ff(struct usb_xpad *xpad) { return 0; }\r\nstatic void xpad_send_led_command(struct usb_xpad *xpad, int command)\r\n{\r\nstruct xpad_output_packet *packet =\r\n&xpad->out_packets[XPAD_OUT_LED_IDX];\r\nunsigned long flags;\r\ncommand %= 16;\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\nswitch (xpad->xtype) {\r\ncase XTYPE_XBOX360:\r\npacket->data[0] = 0x01;\r\npacket->data[1] = 0x03;\r\npacket->data[2] = command;\r\npacket->len = 3;\r\npacket->pending = true;\r\nbreak;\r\ncase XTYPE_XBOX360W:\r\npacket->data[0] = 0x00;\r\npacket->data[1] = 0x00;\r\npacket->data[2] = 0x08;\r\npacket->data[3] = 0x40 + command;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = 0x00;\r\npacket->data[6] = 0x00;\r\npacket->data[7] = 0x00;\r\npacket->data[8] = 0x00;\r\npacket->data[9] = 0x00;\r\npacket->data[10] = 0x00;\r\npacket->data[11] = 0x00;\r\npacket->len = 12;\r\npacket->pending = true;\r\nbreak;\r\n}\r\nxpad_try_sending_next_out_packet(xpad);\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\n}\r\nstatic void xpad_identify_controller(struct usb_xpad *xpad)\r\n{\r\nled_set_brightness(&xpad->led->led_cdev, (xpad->pad_nr % 4) + 2);\r\n}\r\nstatic void xpad_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct xpad_led *xpad_led = container_of(led_cdev,\r\nstruct xpad_led, led_cdev);\r\nxpad_send_led_command(xpad_led->xpad, value);\r\n}\r\nstatic int xpad_led_probe(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_led *led;\r\nstruct led_classdev *led_cdev;\r\nint error;\r\nif (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX360W)\r\nreturn 0;\r\nxpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nxpad->pad_nr = ida_simple_get(&xpad_pad_seq, 0, 0, GFP_KERNEL);\r\nif (xpad->pad_nr < 0) {\r\nerror = xpad->pad_nr;\r\ngoto err_free_mem;\r\n}\r\nsnprintf(led->name, sizeof(led->name), "xpad%d", xpad->pad_nr);\r\nled->xpad = xpad;\r\nled_cdev = &led->led_cdev;\r\nled_cdev->name = led->name;\r\nled_cdev->brightness_set = xpad_led_set;\r\nerror = led_classdev_register(&xpad->udev->dev, led_cdev);\r\nif (error)\r\ngoto err_free_id;\r\nxpad_identify_controller(xpad);\r\nreturn 0;\r\nerr_free_id:\r\nida_simple_remove(&xpad_pad_seq, xpad->pad_nr);\r\nerr_free_mem:\r\nkfree(led);\r\nxpad->led = NULL;\r\nreturn error;\r\n}\r\nstatic void xpad_led_disconnect(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_led *xpad_led = xpad->led;\r\nif (xpad_led) {\r\nled_classdev_unregister(&xpad_led->led_cdev);\r\nida_simple_remove(&xpad_pad_seq, xpad->pad_nr);\r\nkfree(xpad_led);\r\n}\r\n}\r\nstatic int xpad_led_probe(struct usb_xpad *xpad) { return 0; }\r\nstatic void xpad_led_disconnect(struct usb_xpad *xpad) { }\r\nstatic int xpad_start_input(struct usb_xpad *xpad)\r\n{\r\nint error;\r\nif (usb_submit_urb(xpad->irq_in, GFP_KERNEL))\r\nreturn -EIO;\r\nif (xpad->xtype == XTYPE_XBOXONE) {\r\nerror = xpad_start_xbox_one(xpad);\r\nif (error) {\r\nusb_kill_urb(xpad->irq_in);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void xpad_stop_input(struct usb_xpad *xpad)\r\n{\r\nusb_kill_urb(xpad->irq_in);\r\n}\r\nstatic void xpad360w_poweroff_controller(struct usb_xpad *xpad)\r\n{\r\nunsigned long flags;\r\nstruct xpad_output_packet *packet =\r\n&xpad->out_packets[XPAD_OUT_CMD_IDX];\r\nspin_lock_irqsave(&xpad->odata_lock, flags);\r\npacket->data[0] = 0x00;\r\npacket->data[1] = 0x00;\r\npacket->data[2] = 0x08;\r\npacket->data[3] = 0xC0;\r\npacket->data[4] = 0x00;\r\npacket->data[5] = 0x00;\r\npacket->data[6] = 0x00;\r\npacket->data[7] = 0x00;\r\npacket->data[8] = 0x00;\r\npacket->data[9] = 0x00;\r\npacket->data[10] = 0x00;\r\npacket->data[11] = 0x00;\r\npacket->len = 12;\r\npacket->pending = true;\r\nxpad->last_out_packet = -1;\r\nxpad_try_sending_next_out_packet(xpad);\r\nspin_unlock_irqrestore(&xpad->odata_lock, flags);\r\n}\r\nstatic int xpad360w_start_input(struct usb_xpad *xpad)\r\n{\r\nint error;\r\nerror = usb_submit_urb(xpad->irq_in, GFP_KERNEL);\r\nif (error)\r\nreturn -EIO;\r\nerror = xpad_inquiry_pad_presence(xpad);\r\nif (error) {\r\nusb_kill_urb(xpad->irq_in);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xpad360w_stop_input(struct usb_xpad *xpad)\r\n{\r\nusb_kill_urb(xpad->irq_in);\r\nflush_work(&xpad->work);\r\n}\r\nstatic int xpad_open(struct input_dev *dev)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nreturn xpad_start_input(xpad);\r\n}\r\nstatic void xpad_close(struct input_dev *dev)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nxpad_stop_input(xpad);\r\n}\r\nstatic void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(input_dev);\r\nset_bit(abs, input_dev->absbit);\r\nswitch (abs) {\r\ncase ABS_X:\r\ncase ABS_Y:\r\ncase ABS_RX:\r\ncase ABS_RY:\r\ninput_set_abs_params(input_dev, abs, -32768, 32767, 16, 128);\r\nbreak;\r\ncase ABS_Z:\r\ncase ABS_RZ:\r\nif (xpad->xtype == XTYPE_XBOXONE)\r\ninput_set_abs_params(input_dev, abs, 0, 1023, 0, 0);\r\nelse\r\ninput_set_abs_params(input_dev, abs, 0, 255, 0, 0);\r\nbreak;\r\ncase ABS_HAT0X:\r\ncase ABS_HAT0Y:\r\ninput_set_abs_params(input_dev, abs, -1, 1, 0, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void xpad_deinit_input(struct usb_xpad *xpad)\r\n{\r\nif (xpad->input_created) {\r\nxpad->input_created = false;\r\nxpad_led_disconnect(xpad);\r\ninput_unregister_device(xpad->dev);\r\n}\r\n}\r\nstatic int xpad_init_input(struct usb_xpad *xpad)\r\n{\r\nstruct input_dev *input_dev;\r\nint i, error;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nxpad->dev = input_dev;\r\ninput_dev->name = xpad->name;\r\ninput_dev->phys = xpad->phys;\r\nusb_to_input_id(xpad->udev, &input_dev->id);\r\ninput_dev->dev.parent = &xpad->intf->dev;\r\ninput_set_drvdata(input_dev, xpad);\r\nif (xpad->xtype != XTYPE_XBOX360W) {\r\ninput_dev->open = xpad_open;\r\ninput_dev->close = xpad_close;\r\n}\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\n__set_bit(EV_ABS, input_dev->evbit);\r\nfor (i = 0; xpad_abs[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs[i]);\r\n}\r\nfor (i = 0; xpad_common_btn[i] >= 0; i++)\r\n__set_bit(xpad_common_btn[i], input_dev->keybit);\r\nif (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W ||\r\nxpad->xtype == XTYPE_XBOXONE) {\r\nfor (i = 0; xpad360_btn[i] >= 0; i++)\r\n__set_bit(xpad360_btn[i], input_dev->keybit);\r\n} else {\r\nfor (i = 0; xpad_btn[i] >= 0; i++)\r\n__set_bit(xpad_btn[i], input_dev->keybit);\r\n}\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\nfor (i = 0; xpad_btn_pad[i] >= 0; i++)\r\n__set_bit(xpad_btn_pad[i], input_dev->keybit);\r\n}\r\nif (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||\r\nxpad->xtype == XTYPE_XBOX360W) {\r\nfor (i = 0; xpad_abs_pad[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs_pad[i]);\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\nfor (i = 0; xpad_btn_triggers[i] >= 0; i++)\r\n__set_bit(xpad_btn_triggers[i], input_dev->keybit);\r\n} else {\r\nfor (i = 0; xpad_abs_triggers[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs_triggers[i]);\r\n}\r\nerror = xpad_init_ff(xpad);\r\nif (error)\r\ngoto err_free_input;\r\nerror = xpad_led_probe(xpad);\r\nif (error)\r\ngoto err_destroy_ff;\r\nerror = input_register_device(xpad->dev);\r\nif (error)\r\ngoto err_disconnect_led;\r\nxpad->input_created = true;\r\nreturn 0;\r\nerr_disconnect_led:\r\nxpad_led_disconnect(xpad);\r\nerr_destroy_ff:\r\ninput_ff_destroy(input_dev);\r\nerr_free_input:\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_xpad *xpad;\r\nstruct usb_endpoint_descriptor *ep_irq_in;\r\nint ep_irq_in_idx;\r\nint i, error;\r\nif (intf->cur_altsetting->desc.bNumEndpoints != 2)\r\nreturn -ENODEV;\r\nfor (i = 0; xpad_device[i].idVendor; i++) {\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&\r\n(le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))\r\nbreak;\r\n}\r\nxpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);\r\nif (!xpad)\r\nreturn -ENOMEM;\r\nusb_make_path(udev, xpad->phys, sizeof(xpad->phys));\r\nstrlcat(xpad->phys, "/input0", sizeof(xpad->phys));\r\nxpad->idata = usb_alloc_coherent(udev, XPAD_PKT_LEN,\r\nGFP_KERNEL, &xpad->idata_dma);\r\nif (!xpad->idata) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nxpad->irq_in = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!xpad->irq_in) {\r\nerror = -ENOMEM;\r\ngoto err_free_idata;\r\n}\r\nxpad->udev = udev;\r\nxpad->intf = intf;\r\nxpad->mapping = xpad_device[i].mapping;\r\nxpad->xtype = xpad_device[i].xtype;\r\nxpad->name = xpad_device[i].name;\r\nINIT_WORK(&xpad->work, xpad_presence_work);\r\nif (xpad->xtype == XTYPE_UNKNOWN) {\r\nif (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {\r\nif (intf->cur_altsetting->desc.bInterfaceProtocol == 129)\r\nxpad->xtype = XTYPE_XBOX360W;\r\nelse if (intf->cur_altsetting->desc.bInterfaceProtocol == 208)\r\nxpad->xtype = XTYPE_XBOXONE;\r\nelse\r\nxpad->xtype = XTYPE_XBOX360;\r\n} else {\r\nxpad->xtype = XTYPE_XBOX;\r\n}\r\nif (dpad_to_buttons)\r\nxpad->mapping |= MAP_DPAD_TO_BUTTONS;\r\nif (triggers_to_buttons)\r\nxpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;\r\nif (sticks_to_null)\r\nxpad->mapping |= MAP_STICKS_TO_NULL;\r\n}\r\nif (xpad->xtype == XTYPE_XBOXONE &&\r\nintf->cur_altsetting->desc.bInterfaceNumber != 0) {\r\nerror = -ENODEV;\r\ngoto err_free_in_urb;\r\n}\r\nerror = xpad_init_output(intf, xpad);\r\nif (error)\r\ngoto err_free_in_urb;\r\nep_irq_in_idx = xpad->xtype == XTYPE_XBOXONE ? 1 : 0;\r\nep_irq_in = &intf->cur_altsetting->endpoint[ep_irq_in_idx].desc;\r\nusb_fill_int_urb(xpad->irq_in, udev,\r\nusb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),\r\nxpad->idata, XPAD_PKT_LEN, xpad_irq_in,\r\nxpad, ep_irq_in->bInterval);\r\nxpad->irq_in->transfer_dma = xpad->idata_dma;\r\nxpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_set_intfdata(intf, xpad);\r\nif (xpad->xtype == XTYPE_XBOX360W) {\r\nerror = xpad360w_start_input(xpad);\r\nif (error)\r\ngoto err_deinit_output;\r\nudev->quirks |= USB_QUIRK_RESET_RESUME;\r\n} else {\r\nerror = xpad_init_input(xpad);\r\nif (error)\r\ngoto err_deinit_output;\r\n}\r\nreturn 0;\r\nerr_deinit_output:\r\nxpad_deinit_output(xpad);\r\nerr_free_in_urb:\r\nusb_free_urb(xpad->irq_in);\r\nerr_free_idata:\r\nusb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);\r\nerr_free_mem:\r\nkfree(xpad);\r\nreturn error;\r\n}\r\nstatic void xpad_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_xpad *xpad = usb_get_intfdata(intf);\r\nif (xpad->xtype == XTYPE_XBOX360W)\r\nxpad360w_stop_input(xpad);\r\nxpad_deinit_input(xpad);\r\nxpad_stop_output(xpad);\r\nxpad_deinit_output(xpad);\r\nusb_free_urb(xpad->irq_in);\r\nusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\r\nxpad->idata, xpad->idata_dma);\r\nkfree(xpad);\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic int xpad_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_xpad *xpad = usb_get_intfdata(intf);\r\nstruct input_dev *input = xpad->dev;\r\nif (xpad->xtype == XTYPE_XBOX360W) {\r\nxpad360w_stop_input(xpad);\r\nif (auto_poweroff && xpad->pad_present)\r\nxpad360w_poweroff_controller(xpad);\r\n} else {\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nxpad_stop_input(xpad);\r\nmutex_unlock(&input->mutex);\r\n}\r\nxpad_stop_output(xpad);\r\nreturn 0;\r\n}\r\nstatic int xpad_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_xpad *xpad = usb_get_intfdata(intf);\r\nstruct input_dev *input = xpad->dev;\r\nint retval = 0;\r\nif (xpad->xtype == XTYPE_XBOX360W) {\r\nretval = xpad360w_start_input(xpad);\r\n} else {\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nretval = xpad_start_input(xpad);\r\nmutex_unlock(&input->mutex);\r\n}\r\nreturn retval;\r\n}
