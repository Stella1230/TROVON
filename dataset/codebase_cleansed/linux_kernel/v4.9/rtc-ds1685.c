static u8\r\nds1685_read(struct ds1685_priv *rtc, int reg)\r\n{\r\nreturn readb((u8 __iomem *)rtc->regs +\r\n(reg * rtc->regstep));\r\n}\r\nstatic void\r\nds1685_write(struct ds1685_priv *rtc, int reg, u8 value)\r\n{\r\nwriteb(value, ((u8 __iomem *)rtc->regs +\r\n(reg * rtc->regstep)));\r\n}\r\nstatic inline u8\r\nds1685_rtc_bcd2bin(struct ds1685_priv *rtc, u8 val, u8 bcd_mask, u8 bin_mask)\r\n{\r\nif (rtc->bcd_mode)\r\nreturn (bcd2bin(val) & bcd_mask);\r\nreturn (val & bin_mask);\r\n}\r\nstatic inline u8\r\nds1685_rtc_bin2bcd(struct ds1685_priv *rtc, u8 val, u8 bin_mask, u8 bcd_mask)\r\n{\r\nif (rtc->bcd_mode)\r\nreturn (bin2bcd(val) & bcd_mask);\r\nreturn (val & bin_mask);\r\n}\r\nstatic inline int\r\nds1685_rtc_check_mday(struct ds1685_priv *rtc, u8 mday)\r\n{\r\nif (rtc->bcd_mode) {\r\nif (mday < 0x01 || mday > 0x31 || (mday & 0x0f) > 0x09)\r\nreturn -EDOM;\r\n} else {\r\nif (mday < 1 || mday > 31)\r\nreturn -EDOM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nds1685_rtc_switch_to_bank0(struct ds1685_priv *rtc)\r\n{\r\nrtc->write(rtc, RTC_CTRL_A,\r\n(rtc->read(rtc, RTC_CTRL_A) & ~(RTC_CTRL_A_DV0)));\r\n}\r\nstatic inline void\r\nds1685_rtc_switch_to_bank1(struct ds1685_priv *rtc)\r\n{\r\nrtc->write(rtc, RTC_CTRL_A,\r\n(rtc->read(rtc, RTC_CTRL_A) | RTC_CTRL_A_DV0));\r\n}\r\nstatic inline void\r\nds1685_rtc_begin_data_access(struct ds1685_priv *rtc)\r\n{\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) | RTC_CTRL_B_SET));\r\nwhile (rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_INCR)\r\ncpu_relax();\r\nds1685_rtc_switch_to_bank1(rtc);\r\n}\r\nstatic inline void\r\nds1685_rtc_end_data_access(struct ds1685_priv *rtc)\r\n{\r\nds1685_rtc_switch_to_bank1(rtc);\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_SET)));\r\n}\r\nstatic inline void\r\nds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long *flags)\r\n{\r\nspin_lock_irqsave(&rtc->lock, *flags);\r\nds1685_rtc_switch_to_bank1(rtc);\r\n}\r\nstatic inline void\r\nds1685_rtc_end_ctrl_access(struct ds1685_priv *rtc, unsigned long flags)\r\n{\r\nds1685_rtc_switch_to_bank0(rtc);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\n}\r\nstatic inline void\r\nds1685_rtc_get_ssn(struct ds1685_priv *rtc, u8 *ssn)\r\n{\r\nssn[0] = rtc->read(rtc, RTC_BANK1_SSN_MODEL);\r\nssn[1] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_1);\r\nssn[2] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_2);\r\nssn[3] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_3);\r\nssn[4] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_4);\r\nssn[5] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_5);\r\nssn[6] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_6);\r\nssn[7] = rtc->read(rtc, RTC_BANK1_SSN_CRC);\r\n}\r\nstatic int\r\nds1685_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrlb, century;\r\nu8 seconds, minutes, hours, wday, mday, month, years;\r\nds1685_rtc_begin_data_access(rtc);\r\nseconds = rtc->read(rtc, RTC_SECS);\r\nminutes = rtc->read(rtc, RTC_MINS);\r\nhours = rtc->read(rtc, RTC_HRS);\r\nwday = rtc->read(rtc, RTC_WDAY);\r\nmday = rtc->read(rtc, RTC_MDAY);\r\nmonth = rtc->read(rtc, RTC_MONTH);\r\nyears = rtc->read(rtc, RTC_YEAR);\r\ncentury = rtc->read(rtc, RTC_CENTURY);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nds1685_rtc_end_data_access(rtc);\r\nyears = ds1685_rtc_bcd2bin(rtc, years, RTC_YEAR_BCD_MASK,\r\nRTC_YEAR_BIN_MASK);\r\ncentury = ds1685_rtc_bcd2bin(rtc, century, RTC_CENTURY_MASK,\r\nRTC_CENTURY_MASK);\r\ntm->tm_sec = ds1685_rtc_bcd2bin(rtc, seconds, RTC_SECS_BCD_MASK,\r\nRTC_SECS_BIN_MASK);\r\ntm->tm_min = ds1685_rtc_bcd2bin(rtc, minutes, RTC_MINS_BCD_MASK,\r\nRTC_MINS_BIN_MASK);\r\ntm->tm_hour = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_24_BCD_MASK,\r\nRTC_HRS_24_BIN_MASK);\r\ntm->tm_wday = (ds1685_rtc_bcd2bin(rtc, wday, RTC_WDAY_MASK,\r\nRTC_WDAY_MASK) - 1);\r\ntm->tm_mday = ds1685_rtc_bcd2bin(rtc, mday, RTC_MDAY_BCD_MASK,\r\nRTC_MDAY_BIN_MASK);\r\ntm->tm_mon = (ds1685_rtc_bcd2bin(rtc, month, RTC_MONTH_BCD_MASK,\r\nRTC_MONTH_BIN_MASK) - 1);\r\ntm->tm_year = ((years + (century * 100)) - 1900);\r\ntm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\r\ntm->tm_isdst = 0;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int\r\nds1685_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrlb, seconds, minutes, hours, wday, mday, month, years, century;\r\nseconds = ds1685_rtc_bin2bcd(rtc, tm->tm_sec, RTC_SECS_BIN_MASK,\r\nRTC_SECS_BCD_MASK);\r\nminutes = ds1685_rtc_bin2bcd(rtc, tm->tm_min, RTC_MINS_BIN_MASK,\r\nRTC_MINS_BCD_MASK);\r\nhours = ds1685_rtc_bin2bcd(rtc, tm->tm_hour, RTC_HRS_24_BIN_MASK,\r\nRTC_HRS_24_BCD_MASK);\r\nwday = ds1685_rtc_bin2bcd(rtc, (tm->tm_wday + 1), RTC_WDAY_MASK,\r\nRTC_WDAY_MASK);\r\nmday = ds1685_rtc_bin2bcd(rtc, tm->tm_mday, RTC_MDAY_BIN_MASK,\r\nRTC_MDAY_BCD_MASK);\r\nmonth = ds1685_rtc_bin2bcd(rtc, (tm->tm_mon + 1), RTC_MONTH_BIN_MASK,\r\nRTC_MONTH_BCD_MASK);\r\nyears = ds1685_rtc_bin2bcd(rtc, (tm->tm_year % 100),\r\nRTC_YEAR_BIN_MASK, RTC_YEAR_BCD_MASK);\r\ncentury = ds1685_rtc_bin2bcd(rtc, ((tm->tm_year + 1900) / 100),\r\nRTC_CENTURY_MASK, RTC_CENTURY_MASK);\r\nif ((tm->tm_mon > 11) || (mday == 0))\r\nreturn -EDOM;\r\nif (tm->tm_mday > rtc_month_days(tm->tm_mon, tm->tm_year))\r\nreturn -EDOM;\r\nif ((tm->tm_hour >= 24) || (tm->tm_min >= 60) ||\r\n(tm->tm_sec >= 60) || (wday > 7))\r\nreturn -EDOM;\r\nds1685_rtc_begin_data_access(rtc);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nif (rtc->bcd_mode)\r\nctrlb &= ~(RTC_CTRL_B_DM);\r\nelse\r\nctrlb |= RTC_CTRL_B_DM;\r\nrtc->write(rtc, RTC_CTRL_B, ctrlb);\r\nrtc->write(rtc, RTC_SECS, seconds);\r\nrtc->write(rtc, RTC_MINS, minutes);\r\nrtc->write(rtc, RTC_HRS, hours);\r\nrtc->write(rtc, RTC_WDAY, wday);\r\nrtc->write(rtc, RTC_MDAY, mday);\r\nrtc->write(rtc, RTC_MONTH, month);\r\nrtc->write(rtc, RTC_YEAR, years);\r\nrtc->write(rtc, RTC_CENTURY, century);\r\nds1685_rtc_end_data_access(rtc);\r\nreturn 0;\r\n}\r\nstatic int\r\nds1685_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 seconds, minutes, hours, mday, ctrlb, ctrlc;\r\nint ret;\r\nds1685_rtc_begin_data_access(rtc);\r\nseconds = rtc->read(rtc, RTC_SECS_ALARM);\r\nminutes = rtc->read(rtc, RTC_MINS_ALARM);\r\nhours = rtc->read(rtc, RTC_HRS_ALARM);\r\nmday = rtc->read(rtc, RTC_MDAY_ALARM);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nctrlc = rtc->read(rtc, RTC_CTRL_C);\r\nds1685_rtc_end_data_access(rtc);\r\nret = ds1685_rtc_check_mday(rtc, mday);\r\nif (ret)\r\nreturn ret;\r\nif (likely(seconds < 0xc0))\r\nalrm->time.tm_sec = ds1685_rtc_bcd2bin(rtc, seconds,\r\nRTC_SECS_BCD_MASK,\r\nRTC_SECS_BIN_MASK);\r\nif (likely(minutes < 0xc0))\r\nalrm->time.tm_min = ds1685_rtc_bcd2bin(rtc, minutes,\r\nRTC_MINS_BCD_MASK,\r\nRTC_MINS_BIN_MASK);\r\nif (likely(hours < 0xc0))\r\nalrm->time.tm_hour = ds1685_rtc_bcd2bin(rtc, hours,\r\nRTC_HRS_24_BCD_MASK,\r\nRTC_HRS_24_BIN_MASK);\r\nalrm->time.tm_mday = ds1685_rtc_bcd2bin(rtc, mday, RTC_MDAY_BCD_MASK,\r\nRTC_MDAY_BIN_MASK);\r\nalrm->enabled = !!(ctrlb & RTC_CTRL_B_AIE);\r\nalrm->pending = !!(ctrlc & RTC_CTRL_C_AF);\r\nreturn 0;\r\n}\r\nstatic int\r\nds1685_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrlb, seconds, minutes, hours, mday;\r\nint ret;\r\nseconds = ds1685_rtc_bin2bcd(rtc, alrm->time.tm_sec,\r\nRTC_SECS_BIN_MASK,\r\nRTC_SECS_BCD_MASK);\r\nminutes = ds1685_rtc_bin2bcd(rtc, alrm->time.tm_min,\r\nRTC_MINS_BIN_MASK,\r\nRTC_MINS_BCD_MASK);\r\nhours = ds1685_rtc_bin2bcd(rtc, alrm->time.tm_hour,\r\nRTC_HRS_24_BIN_MASK,\r\nRTC_HRS_24_BCD_MASK);\r\nmday = ds1685_rtc_bin2bcd(rtc, alrm->time.tm_mday,\r\nRTC_MDAY_BIN_MASK,\r\nRTC_MDAY_BCD_MASK);\r\nret = ds1685_rtc_check_mday(rtc, mday);\r\nif (ret)\r\nreturn ret;\r\nif (unlikely(seconds >= 0xc0))\r\nseconds = 0xff;\r\nif (unlikely(minutes >= 0xc0))\r\nminutes = 0xff;\r\nif (unlikely(hours >= 0xc0))\r\nhours = 0xff;\r\nalrm->time.tm_mon = -1;\r\nalrm->time.tm_year = -1;\r\nalrm->time.tm_wday = -1;\r\nalrm->time.tm_yday = -1;\r\nalrm->time.tm_isdst = -1;\r\nds1685_rtc_begin_data_access(rtc);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nrtc->write(rtc, RTC_CTRL_B, (ctrlb & ~(RTC_CTRL_B_AIE)));\r\nrtc->read(rtc, RTC_CTRL_C);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nif (rtc->bcd_mode)\r\nctrlb &= ~(RTC_CTRL_B_DM);\r\nelse\r\nctrlb |= RTC_CTRL_B_DM;\r\nrtc->write(rtc, RTC_CTRL_B, ctrlb);\r\nrtc->write(rtc, RTC_SECS_ALARM, seconds);\r\nrtc->write(rtc, RTC_MINS_ALARM, minutes);\r\nrtc->write(rtc, RTC_HRS_ALARM, hours);\r\nrtc->write(rtc, RTC_MDAY_ALARM, mday);\r\nif (alrm->enabled) {\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nctrlb |= RTC_CTRL_B_AIE;\r\nrtc->write(rtc, RTC_CTRL_B, ctrlb);\r\n}\r\nds1685_rtc_end_data_access(rtc);\r\nreturn 0;\r\n}\r\nstatic int\r\nds1685_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct ds1685_priv *rtc = dev_get_drvdata(dev);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nif (enabled)\r\nrtc->write(rtc, RTC_CTRL_B, (rtc->read(rtc, RTC_CTRL_B) |\r\nRTC_CTRL_B_AIE));\r\nelse\r\nrtc->write(rtc, RTC_CTRL_B, (rtc->read(rtc, RTC_CTRL_B) &\r\n~(RTC_CTRL_B_AIE)));\r\nrtc->read(rtc, RTC_CTRL_C);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nds1685_rtc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrlb, ctrlc;\r\nunsigned long events = 0;\r\nu8 num_irqs = 0;\r\nif (unlikely(!rtc))\r\nreturn IRQ_HANDLED;\r\nspin_lock(&rtc->lock);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nctrlc = rtc->read(rtc, RTC_CTRL_C);\r\nif (likely(ctrlc & RTC_CTRL_C_IRQF)) {\r\nif (likely(ctrlc & RTC_CTRL_B_PAU_MASK)) {\r\nevents = RTC_IRQF;\r\nif ((ctrlb & RTC_CTRL_B_PIE) &&\r\n(ctrlc & RTC_CTRL_C_PF)) {\r\nevents |= RTC_PF;\r\nnum_irqs++;\r\n}\r\nif ((ctrlb & RTC_CTRL_B_AIE) &&\r\n(ctrlc & RTC_CTRL_C_AF)) {\r\nevents |= RTC_AF;\r\nnum_irqs++;\r\n}\r\nif ((ctrlb & RTC_CTRL_B_UIE) &&\r\n(ctrlc & RTC_CTRL_C_UF)) {\r\nevents |= RTC_UF;\r\nnum_irqs++;\r\n}\r\nrtc_update_irq(rtc->dev, num_irqs, events);\r\n} else {\r\nspin_unlock(&rtc->lock);\r\nschedule_work(&rtc->work);\r\nrtc_update_irq(rtc->dev, 0, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nspin_unlock(&rtc->lock);\r\nreturn events ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void\r\nds1685_rtc_work_queue(struct work_struct *work)\r\n{\r\nstruct ds1685_priv *rtc = container_of(work,\r\nstruct ds1685_priv, work);\r\nstruct platform_device *pdev = to_platform_device(&rtc->dev->dev);\r\nstruct mutex *rtc_mutex = &rtc->dev->ops_lock;\r\nu8 ctrl4a, ctrl4b;\r\nmutex_lock(rtc_mutex);\r\nds1685_rtc_switch_to_bank1(rtc);\r\nctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\r\nctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\r\nif ((ctrl4b & RTC_CTRL_4B_KSE) && (ctrl4a & RTC_CTRL_4A_KF)) {\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) &\r\n~(RTC_CTRL_4B_KSE)));\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(ctrl4a & ~(RTC_CTRL_4A_KF)));\r\nmsleep(500);\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) |\r\nRTC_CTRL_4B_KSE));\r\nif (rtc->prepare_poweroff != NULL)\r\nrtc->prepare_poweroff();\r\nelse\r\nds1685_rtc_poweroff(pdev);\r\n}\r\nif ((ctrl4b & RTC_CTRL_4B_WIE) && (ctrl4a & RTC_CTRL_4A_WF)) {\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(ctrl4a & ~(RTC_CTRL_4A_WF)));\r\nif (rtc->wake_alarm != NULL)\r\nrtc->wake_alarm();\r\nelse\r\ndev_warn(&pdev->dev,\r\n"Wake Alarm IRQ just occurred!\n");\r\n}\r\nif ((ctrl4b & RTC_CTRL_4B_RIE) && (ctrl4a & RTC_CTRL_4A_RF)) {\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(ctrl4a & ~(RTC_CTRL_4A_RF)));\r\nmsleep(150);\r\nif (rtc->post_ram_clear != NULL)\r\nrtc->post_ram_clear();\r\nelse\r\ndev_warn(&pdev->dev,\r\n"RAM-Clear IRQ just occurred!\n");\r\n}\r\nds1685_rtc_switch_to_bank0(rtc);\r\nmutex_unlock(rtc_mutex);\r\n}\r\nstatic char*\r\nds1685_rtc_print_regs(u8 hex, char *dest)\r\n{\r\nu32 i, j;\r\nchar *tmp = dest;\r\nfor (i = 0; i < NUM_BITS; i++) {\r\n*tmp++ = ((hex & 0x80) != 0 ? '1' : '0');\r\nfor (j = 0; j < NUM_SPACES; j++)\r\n*tmp++ = ' ';\r\nhex <<= 1;\r\n}\r\n*tmp++ = '\0';\r\nreturn dest;\r\n}\r\nstatic int\r\nds1685_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrla, ctrlb, ctrlc, ctrld, ctrl4a, ctrl4b, ssn[8];\r\nchar *model;\r\n#ifdef CONFIG_RTC_DS1685_PROC_REGS\r\nchar bits[NUM_REGS][(NUM_BITS * NUM_SPACES) + NUM_BITS + 1];\r\n#endif\r\nds1685_rtc_switch_to_bank1(rtc);\r\nds1685_rtc_get_ssn(rtc, ssn);\r\nctrla = rtc->read(rtc, RTC_CTRL_A);\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nctrlc = rtc->read(rtc, RTC_CTRL_C);\r\nctrld = rtc->read(rtc, RTC_CTRL_D);\r\nctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\r\nctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\r\nds1685_rtc_switch_to_bank0(rtc);\r\nswitch (ssn[0]) {\r\ncase RTC_MODEL_DS1685:\r\nmodel = "DS1685/DS1687\0";\r\nbreak;\r\ncase RTC_MODEL_DS1689:\r\nmodel = "DS1689/DS1693\0";\r\nbreak;\r\ncase RTC_MODEL_DS17285:\r\nmodel = "DS17285/DS17287\0";\r\nbreak;\r\ncase RTC_MODEL_DS17485:\r\nmodel = "DS17485/DS17487\0";\r\nbreak;\r\ncase RTC_MODEL_DS17885:\r\nmodel = "DS17885/DS17887\0";\r\nbreak;\r\ndefault:\r\nmodel = "Unknown\0";\r\nbreak;\r\n}\r\nseq_printf(seq,\r\n"Model\t\t: %s\n"\r\n"Oscillator\t: %s\n"\r\n"12/24hr\t\t: %s\n"\r\n"DST\t\t: %s\n"\r\n"Data mode\t: %s\n"\r\n"Battery\t\t: %s\n"\r\n"Aux batt\t: %s\n"\r\n"Update IRQ\t: %s\n"\r\n"Periodic IRQ\t: %s\n"\r\n"Periodic Rate\t: %s\n"\r\n"SQW Freq\t: %s\n"\r\n#ifdef CONFIG_RTC_DS1685_PROC_REGS\r\n"Serial #\t: %8phC\n"\r\n"Register Status\t:\n"\r\n" Ctrl A\t: UIP DV2 DV1 DV0 RS3 RS2 RS1 RS0\n"\r\n"\t\t: %s\n"\r\n" Ctrl B\t: SET PIE AIE UIE SQWE DM 2412 DSE\n"\r\n"\t\t: %s\n"\r\n" Ctrl C\t: IRQF PF AF UF --- --- --- ---\n"\r\n"\t\t: %s\n"\r\n" Ctrl D\t: VRT --- --- --- --- --- --- ---\n"\r\n"\t\t: %s\n"\r\n#if !defined(CONFIG_RTC_DRV_DS1685) && !defined(CONFIG_RTC_DRV_DS1689)\r\n" Ctrl 4A\t: VRT2 INCR BME --- PAB RF WF KF\n"\r\n#else\r\n" Ctrl 4A\t: VRT2 INCR --- --- PAB RF WF KF\n"\r\n#endif\r\n"\t\t: %s\n"\r\n" Ctrl 4B\t: ABE E32k CS RCE PRS RIE WIE KSE\n"\r\n"\t\t: %s\n",\r\n#else\r\n"Serial #\t: %8phC\n",\r\n#endif\r\nmodel,\r\n((ctrla & RTC_CTRL_A_DV1) ? "enabled" : "disabled"),\r\n((ctrlb & RTC_CTRL_B_2412) ? "24-hour" : "12-hour"),\r\n((ctrlb & RTC_CTRL_B_DSE) ? "enabled" : "disabled"),\r\n((ctrlb & RTC_CTRL_B_DM) ? "binary" : "BCD"),\r\n((ctrld & RTC_CTRL_D_VRT) ? "ok" : "exhausted or n/a"),\r\n((ctrl4a & RTC_CTRL_4A_VRT2) ? "ok" : "exhausted or n/a"),\r\n((ctrlb & RTC_CTRL_B_UIE) ? "yes" : "no"),\r\n((ctrlb & RTC_CTRL_B_PIE) ? "yes" : "no"),\r\n(!(ctrl4b & RTC_CTRL_4B_E32K) ?\r\nds1685_rtc_pirq_rate[(ctrla & RTC_CTRL_A_RS_MASK)] : "none"),\r\n(!((ctrl4b & RTC_CTRL_4B_E32K)) ?\r\nds1685_rtc_sqw_freq[(ctrla & RTC_CTRL_A_RS_MASK)] : "32768Hz"),\r\n#ifdef CONFIG_RTC_DS1685_PROC_REGS\r\nssn,\r\nds1685_rtc_print_regs(ctrla, bits[0]),\r\nds1685_rtc_print_regs(ctrlb, bits[1]),\r\nds1685_rtc_print_regs(ctrlc, bits[2]),\r\nds1685_rtc_print_regs(ctrld, bits[3]),\r\nds1685_rtc_print_regs(ctrl4a, bits[4]),\r\nds1685_rtc_print_regs(ctrl4b, bits[5]));\r\n#else\r\nssn);\r\nstatic ssize_t\r\nds1685_rtc_sysfs_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t pos, size_t size)\r\n{\r\nstruct platform_device *pdev =\r\nto_platform_device(container_of(kobj, struct device, kobj));\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nssize_t count;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nds1685_rtc_switch_to_bank0(rtc);\r\nfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ_BANK0;\r\ncount++, size--) {\r\nif (count < NVRAM_SZ_TIME)\r\n*buf++ = rtc->read(rtc, (NVRAM_TIME_BASE + pos++));\r\nelse\r\n*buf++ = rtc->read(rtc, (NVRAM_BANK0_BASE + pos++));\r\n}\r\n#ifndef CONFIG_RTC_DRV_DS1689\r\nif (size > 0) {\r\nds1685_rtc_switch_to_bank1(rtc);\r\n#ifndef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) |\r\nRTC_CTRL_4A_BME));\r\nrtc->write(rtc, RTC_BANK1_RAM_ADDR_LSB,\r\n(pos - NVRAM_TOTAL_SZ_BANK0));\r\n#endif\r\nfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ;\r\ncount++, size--) {\r\n#ifdef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_BANK1_RAM_ADDR,\r\n(pos - NVRAM_TOTAL_SZ_BANK0));\r\n#endif\r\n*buf++ = rtc->read(rtc, RTC_BANK1_RAM_DATA_PORT);\r\npos++;\r\n}\r\n#ifndef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) &\r\n~(RTC_CTRL_4A_BME)));\r\n#endif\r\nds1685_rtc_switch_to_bank0(rtc);\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t pos, size_t size)\r\n{\r\nstruct platform_device *pdev =\r\nto_platform_device(container_of(kobj, struct device, kobj));\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nssize_t count;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nds1685_rtc_switch_to_bank0(rtc);\r\nfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ_BANK0;\r\ncount++, size--)\r\nif (count < NVRAM_SZ_TIME)\r\nrtc->write(rtc, (NVRAM_TIME_BASE + pos++),\r\n*buf++);\r\nelse\r\nrtc->write(rtc, (NVRAM_BANK0_BASE), *buf++);\r\n#ifndef CONFIG_RTC_DRV_DS1689\r\nif (size > 0) {\r\nds1685_rtc_switch_to_bank1(rtc);\r\n#ifndef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) |\r\nRTC_CTRL_4A_BME));\r\nrtc->write(rtc, RTC_BANK1_RAM_ADDR_LSB,\r\n(pos - NVRAM_TOTAL_SZ_BANK0));\r\n#endif\r\nfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ;\r\ncount++, size--) {\r\n#ifdef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_BANK1_RAM_ADDR,\r\n(pos - NVRAM_TOTAL_SZ_BANK0));\r\n#endif\r\nrtc->write(rtc, RTC_BANK1_RAM_DATA_PORT, *buf++);\r\npos++;\r\n}\r\n#ifndef CONFIG_RTC_DRV_DS1685\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) &\r\n~(RTC_CTRL_4A_BME)));\r\n#endif\r\nds1685_rtc_switch_to_bank0(rtc);\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_battery_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrld;\r\nctrld = rtc->read(rtc, RTC_CTRL_D);\r\nreturn sprintf(buf, "%s\n",\r\n(ctrld & RTC_CTRL_D_VRT) ? "ok" : "not ok or N/A");\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_auxbatt_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ctrl4a;\r\nds1685_rtc_switch_to_bank1(rtc);\r\nctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\r\nds1685_rtc_switch_to_bank0(rtc);\r\nreturn sprintf(buf, "%s\n",\r\n(ctrl4a & RTC_CTRL_4A_VRT2) ? "ok" : "not ok or N/A");\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_serial_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\nu8 ssn[8];\r\nds1685_rtc_switch_to_bank1(rtc);\r\nds1685_rtc_get_ssn(rtc, ssn);\r\nds1685_rtc_switch_to_bank0(rtc);\r\nreturn sprintf(buf, "%8phC\n", ssn);\r\n}\r\nstatic const struct ds1685_rtc_ctrl_regs*\r\nds1685_rtc_sysfs_ctrl_regs_lookup(const char *name)\r\n{\r\nconst struct ds1685_rtc_ctrl_regs *p = ds1685_ctrl_regs_table;\r\nfor (; p->name != NULL; ++p)\r\nif (strcmp(p->name, name) == 0)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_ctrl_regs_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 tmp;\r\nstruct ds1685_priv *rtc = dev_get_drvdata(dev);\r\nconst struct ds1685_rtc_ctrl_regs *reg_info =\r\nds1685_rtc_sysfs_ctrl_regs_lookup(attr->attr.name);\r\nif (!reg_info)\r\nreturn -EINVAL;\r\nds1685_rtc_switch_to_bank1(rtc);\r\ntmp = rtc->read(rtc, reg_info->reg) & reg_info->bit;\r\nds1685_rtc_switch_to_bank0(rtc);\r\nreturn sprintf(buf, "%d\n", (tmp ? 1 : 0));\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_ctrl_regs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ds1685_priv *rtc = dev_get_drvdata(dev);\r\nu8 reg = 0, bit = 0, tmp;\r\nunsigned long flags;\r\nlong int val = 0;\r\nconst struct ds1685_rtc_ctrl_regs *reg_info =\r\nds1685_rtc_sysfs_ctrl_regs_lookup(attr->attr.name);\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val != 0) && (val != 1))\r\nreturn -ERANGE;\r\nif (!reg_info)\r\nreturn -EINVAL;\r\nreg = reg_info->reg;\r\nbit = reg_info->bit;\r\nds1685_rtc_begin_ctrl_access(rtc, &flags);\r\ntmp = rtc->read(rtc, reg);\r\nrtc->write(rtc, reg, (val ? (tmp | bit) : (tmp & ~(bit))));\r\nds1685_rtc_end_ctrl_access(rtc, flags);\r\nreturn count;\r\n}\r\nstatic const struct ds1685_rtc_time_regs*\r\nds1685_rtc_sysfs_time_regs_lookup(const char *name, bool bcd_mode)\r\n{\r\nconst struct ds1685_rtc_time_regs *p;\r\nif (bcd_mode)\r\np = ds1685_time_regs_bcd_table;\r\nelse\r\np = ds1685_time_regs_bin_table;\r\nfor (; p->name != NULL; ++p)\r\nif (strcmp(p->name, name) == 0)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_time_regs_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 tmp;\r\nstruct ds1685_priv *rtc = dev_get_drvdata(dev);\r\nconst struct ds1685_rtc_time_regs *bcd_reg_info =\r\nds1685_rtc_sysfs_time_regs_lookup(attr->attr.name, true);\r\nconst struct ds1685_rtc_time_regs *bin_reg_info =\r\nds1685_rtc_sysfs_time_regs_lookup(attr->attr.name, false);\r\nif (!bcd_reg_info || !bin_reg_info)\r\nreturn -EINVAL;\r\nds1685_rtc_begin_data_access(rtc);\r\ntmp = rtc->read(rtc, bcd_reg_info->reg);\r\nds1685_rtc_end_data_access(rtc);\r\ntmp = ds1685_rtc_bcd2bin(rtc, tmp, bcd_reg_info->mask,\r\nbin_reg_info->mask);\r\nreturn sprintf(buf, "%d\n", tmp);\r\n}\r\nstatic ssize_t\r\nds1685_rtc_sysfs_time_regs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nlong int val = 0;\r\nstruct ds1685_priv *rtc = dev_get_drvdata(dev);\r\nconst struct ds1685_rtc_time_regs *bcd_reg_info =\r\nds1685_rtc_sysfs_time_regs_lookup(attr->attr.name, true);\r\nconst struct ds1685_rtc_time_regs *bin_reg_info =\r\nds1685_rtc_sysfs_time_regs_lookup(attr->attr.name, false);\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (!bcd_reg_info || !bin_reg_info)\r\nreturn -EINVAL;\r\nif (rtc->bcd_mode) {\r\nif ((val < bcd_reg_info->min) || (val > bcd_reg_info->max))\r\nreturn -ERANGE;\r\n} else {\r\nif ((val < bin_reg_info->min) || (val > bin_reg_info->max))\r\nreturn -ERANGE;\r\n}\r\nval = ds1685_rtc_bin2bcd(rtc, val, bin_reg_info->mask,\r\nbcd_reg_info->mask);\r\nds1685_rtc_begin_data_access(rtc);\r\nrtc->write(rtc, bcd_reg_info->reg, val);\r\nds1685_rtc_end_data_access(rtc);\r\nreturn count;\r\n}\r\nstatic int\r\nds1685_rtc_sysfs_register(struct device *dev)\r\n{\r\nint ret = 0;\r\nsysfs_bin_attr_init(&ds1685_rtc_sysfs_nvram_attr);\r\nret = sysfs_create_bin_file(&dev->kobj, &ds1685_rtc_sysfs_nvram_attr);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_misc_grp);\r\nif (ret)\r\nreturn ret;\r\n#ifdef CONFIG_RTC_DS1685_SYSFS_REGS\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrla_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrlb_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrlc_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrld_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrl4a_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_ctrl4b_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_time_grp);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &ds1685_rtc_sysfs_alarm_grp);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nds1685_rtc_sysfs_unregister(struct device *dev)\r\n{\r\nsysfs_remove_bin_file(&dev->kobj, &ds1685_rtc_sysfs_nvram_attr);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_misc_grp);\r\n#ifdef CONFIG_RTC_DS1685_SYSFS_REGS\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrla_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrlb_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrlc_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrld_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrl4a_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_ctrl4b_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_time_grp);\r\nsysfs_remove_group(&dev->kobj, &ds1685_rtc_sysfs_alarm_grp);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nds1685_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc_dev;\r\nstruct resource *res;\r\nstruct ds1685_priv *rtc;\r\nstruct ds1685_rtc_platform_data *pdata;\r\nu8 ctrla, ctrlb, hours;\r\nunsigned char am_pm;\r\nint ret = 0;\r\npdata = (struct ds1685_rtc_platform_data *) pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nif (pdata->alloc_io_resources) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nrtc->size = resource_size(res);\r\nif (!devm_request_mem_region(&pdev->dev, res->start, rtc->size,\r\npdev->name))\r\nreturn -EBUSY;\r\nrtc->baseaddr = res->start;\r\nrtc->regs = devm_ioremap(&pdev->dev, res->start, rtc->size);\r\nif (!rtc->regs)\r\nreturn -ENOMEM;\r\n}\r\nrtc->alloc_io_resources = pdata->alloc_io_resources;\r\nif (pdata->regstep > 0)\r\nrtc->regstep = pdata->regstep;\r\nelse\r\nrtc->regstep = 1;\r\nif (pdata->plat_read)\r\nrtc->read = pdata->plat_read;\r\nelse\r\nif (pdata->alloc_io_resources)\r\nrtc->read = ds1685_read;\r\nelse\r\nreturn -ENXIO;\r\nif (pdata->plat_write)\r\nrtc->write = pdata->plat_write;\r\nelse\r\nif (pdata->alloc_io_resources)\r\nrtc->write = ds1685_write;\r\nelse\r\nreturn -ENXIO;\r\nif (pdata->plat_prepare_poweroff)\r\nrtc->prepare_poweroff = pdata->plat_prepare_poweroff;\r\nif (pdata->plat_wake_alarm)\r\nrtc->wake_alarm = pdata->plat_wake_alarm;\r\nif (pdata->plat_post_ram_clear)\r\nrtc->post_ram_clear = pdata->plat_post_ram_clear;\r\nspin_lock_init(&rtc->lock);\r\nINIT_WORK(&rtc->work, ds1685_rtc_work_queue);\r\nplatform_set_drvdata(pdev, rtc);\r\nctrla = rtc->read(rtc, RTC_CTRL_A);\r\nif (!(ctrla & RTC_CTRL_A_DV1))\r\nctrla |= RTC_CTRL_A_DV1;\r\nctrla &= ~(RTC_CTRL_A_DV2);\r\nctrla &= ~(RTC_CTRL_A_RS_MASK);\r\nctrla |= RTC_CTRL_A_DV0;\r\nrtc->write(rtc, RTC_CTRL_A, ctrla);\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) | RTC_CTRL_4B_E32K));\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) | RTC_CTRL_B_SET));\r\nwhile (rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_INCR)\r\ncpu_relax();\r\nctrlb = rtc->read(rtc, RTC_CTRL_B);\r\nif (pdata->bcd_mode)\r\nctrlb &= ~(RTC_CTRL_B_DM);\r\nelse\r\nctrlb |= RTC_CTRL_B_DM;\r\nrtc->bcd_mode = pdata->bcd_mode;\r\nif (ctrlb & RTC_CTRL_B_DSE)\r\nctrlb &= ~(RTC_CTRL_B_DSE);\r\nif (!(ctrlb & RTC_CTRL_B_2412)) {\r\nhours = rtc->read(rtc, RTC_HRS);\r\nam_pm = hours & RTC_HRS_AMPM_MASK;\r\nhours = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_12_BCD_MASK,\r\nRTC_HRS_12_BIN_MASK);\r\nhours = ((hours == 12) ? 0 : ((am_pm) ? hours + 12 : hours));\r\nctrlb |= RTC_CTRL_B_2412;\r\nrtc->write(rtc, RTC_CTRL_B, ctrlb);\r\nrtc->write(rtc, RTC_HRS,\r\nds1685_rtc_bin2bcd(rtc, hours,\r\nRTC_HRS_24_BIN_MASK,\r\nRTC_HRS_24_BCD_MASK));\r\nhours = rtc->read(rtc, RTC_HRS_ALARM);\r\nam_pm = hours & RTC_HRS_AMPM_MASK;\r\nhours = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_12_BCD_MASK,\r\nRTC_HRS_12_BIN_MASK);\r\nhours = ((hours == 12) ? 0 : ((am_pm) ? hours + 12 : hours));\r\nrtc->write(rtc, RTC_HRS_ALARM,\r\nds1685_rtc_bin2bcd(rtc, hours,\r\nRTC_HRS_24_BIN_MASK,\r\nRTC_HRS_24_BCD_MASK));\r\n} else {\r\nrtc->write(rtc, RTC_CTRL_B, ctrlb);\r\n}\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_SET)));\r\nif (!(rtc->read(rtc, RTC_CTRL_D) & RTC_CTRL_D_VRT))\r\ndev_warn(&pdev->dev,\r\n"Main battery is exhausted! RTC may be invalid!\n");\r\nif (!(rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_VRT2))\r\ndev_warn(&pdev->dev,\r\n"Aux battery is exhausted or not available.\n");\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_PAU_MASK)));\r\nrtc->read(rtc, RTC_CTRL_C);\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) & ~(RTC_CTRL_4B_RWK_MASK)));\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) & ~(RTC_CTRL_4A_RWK_MASK)));\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) | RTC_CTRL_4B_KSE));\r\nif (!pdata->no_irq) {\r\nret = platform_get_irq(pdev, 0);\r\nif (ret > 0) {\r\nrtc->irq_num = ret;\r\nret = devm_request_irq(&pdev->dev, rtc->irq_num,\r\nds1685_rtc_irq_handler,\r\nIRQF_SHARED, pdev->name, pdev);\r\nif (unlikely(ret)) {\r\ndev_warn(&pdev->dev,\r\n"RTC interrupt not available\n");\r\nrtc->irq_num = 0;\r\n}\r\n} else\r\nreturn ret;\r\n}\r\nrtc->no_irq = pdata->no_irq;\r\nds1685_rtc_switch_to_bank0(rtc);\r\nrtc_dev = rtc_device_register(pdev->name, &pdev->dev,\r\n&ds1685_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc_dev))\r\nreturn PTR_ERR(rtc_dev);\r\nrtc_dev->max_user_freq = RTC_MAX_USER_FREQ;\r\nif (pdata->uie_unsupported)\r\nrtc_dev->uie_unsupported = 1;\r\nrtc->uie_unsupported = pdata->uie_unsupported;\r\nrtc->dev = rtc_dev;\r\n#ifdef CONFIG_SYSFS\r\nret = ds1685_rtc_sysfs_register(&pdev->dev);\r\nif (ret)\r\nrtc_device_unregister(rtc->dev);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int\r\nds1685_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\r\n#ifdef CONFIG_SYSFS\r\nds1685_rtc_sysfs_unregister(&pdev->dev);\r\n#endif\r\nrtc_device_unregister(rtc->dev);\r\nrtc->write(rtc, RTC_CTRL_B,\r\n(rtc->read(rtc, RTC_CTRL_B) &\r\n~(RTC_CTRL_B_PAU_MASK)));\r\nrtc->read(rtc, RTC_CTRL_C);\r\nrtc->write(rtc, RTC_EXT_CTRL_4B,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4B) &\r\n~(RTC_CTRL_4B_RWK_MASK)));\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(rtc->read(rtc, RTC_EXT_CTRL_4A) &\r\n~(RTC_CTRL_4A_RWK_MASK)));\r\ncancel_work_sync(&rtc->work);\r\nreturn 0;\r\n}\r\nvoid __noreturn\r\nds1685_rtc_poweroff(struct platform_device *pdev)\r\n{\r\nu8 ctrla, ctrl4a, ctrl4b;\r\nstruct ds1685_priv *rtc;\r\nif (unlikely(!pdev)) {\r\npr_emerg("platform device data not available, spinning forever ...\n");\r\nwhile(1);\r\nunreachable();\r\n} else {\r\nrtc = platform_get_drvdata(pdev);\r\nif (!rtc->no_irq)\r\ndisable_irq_nosync(rtc->irq_num);\r\nctrla = rtc->read(rtc, RTC_CTRL_A);\r\nctrla |= RTC_CTRL_A_DV1;\r\nctrla &= ~(RTC_CTRL_A_DV2);\r\nrtc->write(rtc, RTC_CTRL_A, ctrla);\r\nds1685_rtc_switch_to_bank1(rtc);\r\nctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\r\nif (ctrl4a & RTC_CTRL_4A_VRT2) {\r\nctrl4a &= ~(RTC_CTRL_4A_RWK_MASK);\r\nrtc->write(rtc, RTC_EXT_CTRL_4A, ctrl4a);\r\nctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\r\nctrl4b |= (RTC_CTRL_4B_ABE | RTC_CTRL_4B_WIE |\r\nRTC_CTRL_4B_KSE);\r\nrtc->write(rtc, RTC_EXT_CTRL_4B, ctrl4b);\r\n}\r\ndev_warn(&pdev->dev, "Powerdown.\n");\r\nmsleep(20);\r\nrtc->write(rtc, RTC_EXT_CTRL_4A,\r\n(ctrl4a | RTC_CTRL_4A_PAB));\r\nwhile(1);\r\nunreachable();\r\n}\r\n}
