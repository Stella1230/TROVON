static inline struct tegra_fb *to_tegra_fb(struct drm_framebuffer *fb)\r\n{\r\nreturn container_of(fb, struct tegra_fb, base);\r\n}\r\nstatic inline struct tegra_fbdev *to_tegra_fbdev(struct drm_fb_helper *helper)\r\n{\r\nreturn container_of(helper, struct tegra_fbdev, base);\r\n}\r\nstruct tegra_bo *tegra_fb_get_plane(struct drm_framebuffer *framebuffer,\r\nunsigned int index)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nif (index >= drm_format_num_planes(framebuffer->pixel_format))\r\nreturn NULL;\r\nreturn fb->planes[index];\r\n}\r\nbool tegra_fb_is_bottom_up(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nif (fb->planes[0]->flags & TEGRA_BO_BOTTOM_UP)\r\nreturn true;\r\nreturn false;\r\n}\r\nint tegra_fb_get_tiling(struct drm_framebuffer *framebuffer,\r\nstruct tegra_bo_tiling *tiling)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\n*tiling = fb->planes[0]->tiling;\r\nreturn 0;\r\n}\r\nstatic void tegra_fb_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nunsigned int i;\r\nfor (i = 0; i < fb->num_planes; i++) {\r\nstruct tegra_bo *bo = fb->planes[i];\r\nif (bo) {\r\nif (bo->pages)\r\nvunmap(bo->vaddr);\r\ndrm_gem_object_unreference_unlocked(&bo->gem);\r\n}\r\n}\r\ndrm_framebuffer_cleanup(framebuffer);\r\nkfree(fb->planes);\r\nkfree(fb);\r\n}\r\nstatic int tegra_fb_create_handle(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file, unsigned int *handle)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nreturn drm_gem_handle_create(file, &fb->planes[0]->gem, handle);\r\n}\r\nstatic struct tegra_fb *tegra_fb_alloc(struct drm_device *drm,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct tegra_bo **planes,\r\nunsigned int num_planes)\r\n{\r\nstruct tegra_fb *fb;\r\nunsigned int i;\r\nint err;\r\nfb = kzalloc(sizeof(*fb), GFP_KERNEL);\r\nif (!fb)\r\nreturn ERR_PTR(-ENOMEM);\r\nfb->planes = kzalloc(num_planes * sizeof(*planes), GFP_KERNEL);\r\nif (!fb->planes) {\r\nkfree(fb);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfb->num_planes = num_planes;\r\ndrm_helper_mode_fill_fb_struct(&fb->base, mode_cmd);\r\nfor (i = 0; i < fb->num_planes; i++)\r\nfb->planes[i] = planes[i];\r\nerr = drm_framebuffer_init(drm, &fb->base, &tegra_fb_funcs);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to initialize framebuffer: %d\n",\r\nerr);\r\nkfree(fb->planes);\r\nkfree(fb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn fb;\r\n}\r\nstruct drm_framebuffer *tegra_fb_create(struct drm_device *drm,\r\nstruct drm_file *file,\r\nconst struct drm_mode_fb_cmd2 *cmd)\r\n{\r\nunsigned int hsub, vsub, i;\r\nstruct tegra_bo *planes[4];\r\nstruct drm_gem_object *gem;\r\nstruct tegra_fb *fb;\r\nint err;\r\nhsub = drm_format_horz_chroma_subsampling(cmd->pixel_format);\r\nvsub = drm_format_vert_chroma_subsampling(cmd->pixel_format);\r\nfor (i = 0; i < drm_format_num_planes(cmd->pixel_format); i++) {\r\nunsigned int width = cmd->width / (i ? hsub : 1);\r\nunsigned int height = cmd->height / (i ? vsub : 1);\r\nunsigned int size, bpp;\r\ngem = drm_gem_object_lookup(file, cmd->handles[i]);\r\nif (!gem) {\r\nerr = -ENXIO;\r\ngoto unreference;\r\n}\r\nbpp = drm_format_plane_cpp(cmd->pixel_format, i);\r\nsize = (height - 1) * cmd->pitches[i] +\r\nwidth * bpp + cmd->offsets[i];\r\nif (gem->size < size) {\r\nerr = -EINVAL;\r\ngoto unreference;\r\n}\r\nplanes[i] = to_tegra_bo(gem);\r\n}\r\nfb = tegra_fb_alloc(drm, cmd, planes, i);\r\nif (IS_ERR(fb)) {\r\nerr = PTR_ERR(fb);\r\ngoto unreference;\r\n}\r\nreturn &fb->base;\r\nunreference:\r\nwhile (i--)\r\ndrm_gem_object_unreference_unlocked(&planes[i]->gem);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int tegra_fbdev_probe(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct tegra_fbdev *fbdev = to_tegra_fbdev(helper);\r\nstruct tegra_drm *tegra = helper->dev->dev_private;\r\nstruct drm_device *drm = helper->dev;\r\nstruct drm_mode_fb_cmd2 cmd = { 0 };\r\nunsigned int bytes_per_pixel;\r\nstruct drm_framebuffer *fb;\r\nunsigned long offset;\r\nstruct fb_info *info;\r\nstruct tegra_bo *bo;\r\nsize_t size;\r\nint err;\r\nbytes_per_pixel = DIV_ROUND_UP(sizes->surface_bpp, 8);\r\ncmd.width = sizes->surface_width;\r\ncmd.height = sizes->surface_height;\r\ncmd.pitches[0] = round_up(sizes->surface_width * bytes_per_pixel,\r\ntegra->pitch_align);\r\ncmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = cmd.pitches[0] * cmd.height;\r\nbo = tegra_bo_create(drm, size, 0);\r\nif (IS_ERR(bo))\r\nreturn PTR_ERR(bo);\r\ninfo = drm_fb_helper_alloc_fbi(helper);\r\nif (IS_ERR(info)) {\r\ndev_err(drm->dev, "failed to allocate framebuffer info\n");\r\ndrm_gem_object_unreference_unlocked(&bo->gem);\r\nreturn PTR_ERR(info);\r\n}\r\nfbdev->fb = tegra_fb_alloc(drm, &cmd, &bo, 1);\r\nif (IS_ERR(fbdev->fb)) {\r\nerr = PTR_ERR(fbdev->fb);\r\ndev_err(drm->dev, "failed to allocate DRM framebuffer: %d\n",\r\nerr);\r\ndrm_gem_object_unreference_unlocked(&bo->gem);\r\ngoto release;\r\n}\r\nfb = &fbdev->fb->base;\r\nhelper->fb = fb;\r\nhelper->fbdev = info;\r\ninfo->par = helper;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &tegra_fb_ops;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, helper, fb->width, fb->height);\r\noffset = info->var.xoffset * bytes_per_pixel +\r\ninfo->var.yoffset * fb->pitches[0];\r\nif (bo->pages) {\r\nbo->vaddr = vmap(bo->pages, bo->num_pages, VM_MAP,\r\npgprot_writecombine(PAGE_KERNEL));\r\nif (!bo->vaddr) {\r\ndev_err(drm->dev, "failed to vmap() framebuffer\n");\r\nerr = -ENOMEM;\r\ngoto destroy;\r\n}\r\n}\r\ndrm->mode_config.fb_base = (resource_size_t)bo->paddr;\r\ninfo->screen_base = (void __iomem *)bo->vaddr + offset;\r\ninfo->screen_size = size;\r\ninfo->fix.smem_start = (unsigned long)(bo->paddr + offset);\r\ninfo->fix.smem_len = size;\r\nreturn 0;\r\ndestroy:\r\ndrm_framebuffer_unregister_private(fb);\r\ntegra_fb_destroy(fb);\r\nrelease:\r\ndrm_fb_helper_release_fbi(helper);\r\nreturn err;\r\n}\r\nstatic struct tegra_fbdev *tegra_fbdev_create(struct drm_device *drm)\r\n{\r\nstruct tegra_fbdev *fbdev;\r\nfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev) {\r\ndev_err(drm->dev, "failed to allocate DRM fbdev\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndrm_fb_helper_prepare(drm, &fbdev->base, &tegra_fb_helper_funcs);\r\nreturn fbdev;\r\n}\r\nstatic void tegra_fbdev_free(struct tegra_fbdev *fbdev)\r\n{\r\nkfree(fbdev);\r\n}\r\nstatic int tegra_fbdev_init(struct tegra_fbdev *fbdev,\r\nunsigned int preferred_bpp,\r\nunsigned int num_crtc,\r\nunsigned int max_connectors)\r\n{\r\nstruct drm_device *drm = fbdev->base.dev;\r\nint err;\r\nerr = drm_fb_helper_init(drm, &fbdev->base, num_crtc, max_connectors);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to initialize DRM FB helper: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = drm_fb_helper_single_add_all_connectors(&fbdev->base);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to add connectors: %d\n", err);\r\ngoto fini;\r\n}\r\nerr = drm_fb_helper_initial_config(&fbdev->base, preferred_bpp);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to set initial configuration: %d\n",\r\nerr);\r\ngoto fini;\r\n}\r\nreturn 0;\r\nfini:\r\ndrm_fb_helper_fini(&fbdev->base);\r\nreturn err;\r\n}\r\nstatic void tegra_fbdev_exit(struct tegra_fbdev *fbdev)\r\n{\r\ndrm_fb_helper_unregister_fbi(&fbdev->base);\r\ndrm_fb_helper_release_fbi(&fbdev->base);\r\nif (fbdev->fb) {\r\ndrm_framebuffer_unregister_private(&fbdev->fb->base);\r\ndrm_framebuffer_remove(&fbdev->fb->base);\r\n}\r\ndrm_fb_helper_fini(&fbdev->base);\r\ntegra_fbdev_free(fbdev);\r\n}\r\nvoid tegra_fbdev_restore_mode(struct tegra_fbdev *fbdev)\r\n{\r\nif (fbdev)\r\ndrm_fb_helper_restore_fbdev_mode_unlocked(&fbdev->base);\r\n}\r\nvoid tegra_fb_output_poll_changed(struct drm_device *drm)\r\n{\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nif (tegra->fbdev)\r\ndrm_fb_helper_hotplug_event(&tegra->fbdev->base);\r\n}\r\nint tegra_drm_fb_prepare(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\ntegra->fbdev = tegra_fbdev_create(drm);\r\nif (IS_ERR(tegra->fbdev))\r\nreturn PTR_ERR(tegra->fbdev);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid tegra_drm_fb_free(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\ntegra_fbdev_free(tegra->fbdev);\r\n#endif\r\n}\r\nint tegra_drm_fb_init(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nint err;\r\nerr = tegra_fbdev_init(tegra->fbdev, 32, drm->mode_config.num_crtc,\r\ndrm->mode_config.num_connector);\r\nif (err < 0)\r\nreturn err;\r\n#endif\r\nreturn 0;\r\n}\r\nvoid tegra_drm_fb_exit(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\ntegra_fbdev_exit(tegra->fbdev);\r\n#endif\r\n}\r\nvoid tegra_drm_fb_suspend(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nconsole_lock();\r\ndrm_fb_helper_set_suspend(&tegra->fbdev->base, 1);\r\nconsole_unlock();\r\n#endif\r\n}\r\nvoid tegra_drm_fb_resume(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_FBDEV_EMULATION\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nconsole_lock();\r\ndrm_fb_helper_set_suspend(&tegra->fbdev->base, 0);\r\nconsole_unlock();\r\n#endif\r\n}
