static long cond_wait_interruptible_timeout_irqrestore(\r\nwait_queue_head_t *q, long timeout,\r\nspinlock_t *lock, unsigned long flags)\r\n__releases(lock)\r\n{\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait(q, &wait, TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(lock, flags);\r\ntimeout = schedule_timeout(timeout);\r\nfinish_wait(q, &wait);\r\nreturn timeout;\r\n}\r\nstatic void digi_wakeup_write_lock(struct work_struct *work)\r\n{\r\nstruct digi_port *priv =\r\ncontainer_of(work, struct digi_port, dp_wakeup_work);\r\nstruct usb_serial_port *port = priv->dp_port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\ntty_port_tty_wakeup(&port->port);\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\n}\r\nstatic int digi_write_oob_command(struct usb_serial_port *port,\r\nunsigned char *buf, int count, int interruptible)\r\n{\r\nint ret = 0;\r\nint len;\r\nstruct usb_serial_port *oob_port = (struct usb_serial_port *)((struct digi_serial *)(usb_get_serial_data(port->serial)))->ds_oob_port;\r\nstruct digi_port *oob_priv = usb_get_serial_port_data(oob_port);\r\nunsigned long flags = 0;\r\ndev_dbg(&port->dev,\r\n"digi_write_oob_command: TOP: port=%d, count=%d\n",\r\noob_priv->dp_port_num, count);\r\nspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\r\nwhile (count > 0) {\r\nwhile (oob_priv->dp_write_urb_in_use) {\r\ncond_wait_interruptible_timeout_irqrestore(\r\n&oob_port->write_wait, DIGI_RETRY_TIMEOUT,\r\n&oob_priv->dp_port_lock, flags);\r\nif (interruptible && signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\r\n}\r\nlen = min(count, oob_port->bulk_out_size);\r\nif (len > 4)\r\nlen &= ~3;\r\nmemcpy(oob_port->write_urb->transfer_buffer, buf, len);\r\noob_port->write_urb->transfer_buffer_length = len;\r\nret = usb_submit_urb(oob_port->write_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\noob_priv->dp_write_urb_in_use = 1;\r\ncount -= len;\r\nbuf += len;\r\n}\r\n}\r\nspin_unlock_irqrestore(&oob_priv->dp_port_lock, flags);\r\nif (ret)\r\ndev_err(&port->dev, "%s: usb_submit_urb failed, ret=%d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int digi_write_inb_command(struct usb_serial_port *port,\r\nunsigned char *buf, int count, unsigned long timeout)\r\n{\r\nint ret = 0;\r\nint len;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = port->write_urb->transfer_buffer;\r\nunsigned long flags = 0;\r\ndev_dbg(&port->dev, "digi_write_inb_command: TOP: port=%d, count=%d\n",\r\npriv->dp_port_num, count);\r\nif (timeout)\r\ntimeout += jiffies;\r\nelse\r\ntimeout = ULONG_MAX;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nwhile (count > 0 && ret == 0) {\r\nwhile (priv->dp_write_urb_in_use &&\r\ntime_before(jiffies, timeout)) {\r\ncond_wait_interruptible_timeout_irqrestore(\r\n&port->write_wait, DIGI_RETRY_TIMEOUT,\r\n&priv->dp_port_lock, flags);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\n}\r\nlen = min(count, port->bulk_out_size-2-priv->dp_out_buf_len);\r\nif (len > 4)\r\nlen &= ~3;\r\nif (priv->dp_out_buf_len > 0) {\r\ndata[0] = DIGI_CMD_SEND_DATA;\r\ndata[1] = priv->dp_out_buf_len;\r\nmemcpy(data + 2, priv->dp_out_buf,\r\npriv->dp_out_buf_len);\r\nmemcpy(data + 2 + priv->dp_out_buf_len, buf, len);\r\nport->write_urb->transfer_buffer_length\r\n= priv->dp_out_buf_len + 2 + len;\r\n} else {\r\nmemcpy(data, buf, len);\r\nport->write_urb->transfer_buffer_length = len;\r\n}\r\nret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\npriv->dp_write_urb_in_use = 1;\r\npriv->dp_out_buf_len = 0;\r\ncount -= len;\r\nbuf += len;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nif (ret)\r\ndev_err(&port->dev,\r\n"%s: usb_submit_urb failed, ret=%d, port=%d\n",\r\n__func__, ret, priv->dp_port_num);\r\nreturn ret;\r\n}\r\nstatic int digi_set_modem_signals(struct usb_serial_port *port,\r\nunsigned int modem_signals, int interruptible)\r\n{\r\nint ret;\r\nstruct digi_port *port_priv = usb_get_serial_port_data(port);\r\nstruct usb_serial_port *oob_port = (struct usb_serial_port *) ((struct digi_serial *)(usb_get_serial_data(port->serial)))->ds_oob_port;\r\nstruct digi_port *oob_priv = usb_get_serial_port_data(oob_port);\r\nunsigned char *data = oob_port->write_urb->transfer_buffer;\r\nunsigned long flags = 0;\r\ndev_dbg(&port->dev,\r\n"digi_set_modem_signals: TOP: port=%d, modem_signals=0x%x\n",\r\nport_priv->dp_port_num, modem_signals);\r\nspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\r\nspin_lock(&port_priv->dp_port_lock);\r\nwhile (oob_priv->dp_write_urb_in_use) {\r\nspin_unlock(&port_priv->dp_port_lock);\r\ncond_wait_interruptible_timeout_irqrestore(\r\n&oob_port->write_wait, DIGI_RETRY_TIMEOUT,\r\n&oob_priv->dp_port_lock, flags);\r\nif (interruptible && signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\r\nspin_lock(&port_priv->dp_port_lock);\r\n}\r\ndata[0] = DIGI_CMD_SET_DTR_SIGNAL;\r\ndata[1] = port_priv->dp_port_num;\r\ndata[2] = (modem_signals & TIOCM_DTR) ?\r\nDIGI_DTR_ACTIVE : DIGI_DTR_INACTIVE;\r\ndata[3] = 0;\r\ndata[4] = DIGI_CMD_SET_RTS_SIGNAL;\r\ndata[5] = port_priv->dp_port_num;\r\ndata[6] = (modem_signals & TIOCM_RTS) ?\r\nDIGI_RTS_ACTIVE : DIGI_RTS_INACTIVE;\r\ndata[7] = 0;\r\noob_port->write_urb->transfer_buffer_length = 8;\r\nret = usb_submit_urb(oob_port->write_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\noob_priv->dp_write_urb_in_use = 1;\r\nport_priv->dp_modem_signals =\r\n(port_priv->dp_modem_signals&~(TIOCM_DTR|TIOCM_RTS))\r\n| (modem_signals&(TIOCM_DTR|TIOCM_RTS));\r\n}\r\nspin_unlock(&port_priv->dp_port_lock);\r\nspin_unlock_irqrestore(&oob_priv->dp_port_lock, flags);\r\nif (ret)\r\ndev_err(&port->dev, "%s: usb_submit_urb failed, ret=%d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int digi_transmit_idle(struct usb_serial_port *port,\r\nunsigned long timeout)\r\n{\r\nint ret;\r\nunsigned char buf[2];\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\npriv->dp_transmit_idle = 0;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nbuf[0] = DIGI_CMD_TRANSMIT_IDLE;\r\nbuf[1] = 0;\r\ntimeout += jiffies;\r\nret = digi_write_inb_command(port, buf, 2, timeout - jiffies);\r\nif (ret != 0)\r\nreturn ret;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nwhile (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {\r\ncond_wait_interruptible_timeout_irqrestore(\r\n&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,\r\n&priv->dp_port_lock, flags);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\n}\r\npriv->dp_transmit_idle = 0;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void digi_rx_throttle(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\npriv->dp_throttled = 1;\r\npriv->dp_throttle_restart = 0;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\n}\r\nstatic void digi_rx_unthrottle(struct tty_struct *tty)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nif (priv->dp_throttle_restart)\r\nret = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\npriv->dp_throttled = 0;\r\npriv->dp_throttle_restart = 0;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nif (ret)\r\ndev_err(&port->dev,\r\n"%s: usb_submit_urb failed, ret=%d, port=%d\n",\r\n__func__, ret, priv->dp_port_num);\r\n}\r\nstatic void digi_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nstruct device *dev = &port->dev;\r\nunsigned int iflag = tty->termios.c_iflag;\r\nunsigned int cflag = tty->termios.c_cflag;\r\nunsigned int old_iflag = old_termios->c_iflag;\r\nunsigned int old_cflag = old_termios->c_cflag;\r\nunsigned char buf[32];\r\nunsigned int modem_signals;\r\nint arg, ret;\r\nint i = 0;\r\nspeed_t baud;\r\ndev_dbg(dev,\r\n"digi_set_termios: TOP: port=%d, iflag=0x%x, old_iflag=0x%x, cflag=0x%x, old_cflag=0x%x\n",\r\npriv->dp_port_num, iflag, old_iflag, cflag, old_cflag);\r\nbaud = tty_get_baud_rate(tty);\r\nif (baud != tty_termios_baud_rate(old_termios)) {\r\narg = -1;\r\nif ((old_cflag & CBAUD) == B0) {\r\nmodem_signals = TIOCM_DTR;\r\nif (!C_CRTSCTS(tty) || !tty_throttled(tty))\r\nmodem_signals |= TIOCM_RTS;\r\ndigi_set_modem_signals(port, modem_signals, 1);\r\n}\r\nswitch (baud) {\r\ncase 0: digi_set_modem_signals(port, 0, 1); break;\r\ncase 50: arg = DIGI_BAUD_50; break;\r\ncase 75: arg = DIGI_BAUD_75; break;\r\ncase 110: arg = DIGI_BAUD_110; break;\r\ncase 150: arg = DIGI_BAUD_150; break;\r\ncase 200: arg = DIGI_BAUD_200; break;\r\ncase 300: arg = DIGI_BAUD_300; break;\r\ncase 600: arg = DIGI_BAUD_600; break;\r\ncase 1200: arg = DIGI_BAUD_1200; break;\r\ncase 1800: arg = DIGI_BAUD_1800; break;\r\ncase 2400: arg = DIGI_BAUD_2400; break;\r\ncase 4800: arg = DIGI_BAUD_4800; break;\r\ncase 9600: arg = DIGI_BAUD_9600; break;\r\ncase 19200: arg = DIGI_BAUD_19200; break;\r\ncase 38400: arg = DIGI_BAUD_38400; break;\r\ncase 57600: arg = DIGI_BAUD_57600; break;\r\ncase 115200: arg = DIGI_BAUD_115200; break;\r\ncase 230400: arg = DIGI_BAUD_230400; break;\r\ncase 460800: arg = DIGI_BAUD_460800; break;\r\ndefault:\r\narg = DIGI_BAUD_9600;\r\nbaud = 9600;\r\nbreak;\r\n}\r\nif (arg != -1) {\r\nbuf[i++] = DIGI_CMD_SET_BAUD_RATE;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\n}\r\ntty->termios.c_cflag &= ~CMSPAR;\r\nif ((cflag&(PARENB|PARODD)) != (old_cflag&(PARENB|PARODD))) {\r\nif (cflag&PARENB) {\r\nif (cflag&PARODD)\r\narg = DIGI_PARITY_ODD;\r\nelse\r\narg = DIGI_PARITY_EVEN;\r\n} else {\r\narg = DIGI_PARITY_NONE;\r\n}\r\nbuf[i++] = DIGI_CMD_SET_PARITY;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\nif ((cflag&CSIZE) != (old_cflag&CSIZE)) {\r\narg = -1;\r\nswitch (cflag&CSIZE) {\r\ncase CS5: arg = DIGI_WORD_SIZE_5; break;\r\ncase CS6: arg = DIGI_WORD_SIZE_6; break;\r\ncase CS7: arg = DIGI_WORD_SIZE_7; break;\r\ncase CS8: arg = DIGI_WORD_SIZE_8; break;\r\ndefault:\r\ndev_dbg(dev,\r\n"digi_set_termios: can't handle word size %d\n",\r\n(cflag&CSIZE));\r\nbreak;\r\n}\r\nif (arg != -1) {\r\nbuf[i++] = DIGI_CMD_SET_WORD_SIZE;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\n}\r\nif ((cflag&CSTOPB) != (old_cflag&CSTOPB)) {\r\nif ((cflag&CSTOPB))\r\narg = DIGI_STOP_BITS_2;\r\nelse\r\narg = DIGI_STOP_BITS_1;\r\nbuf[i++] = DIGI_CMD_SET_STOP_BITS;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\nif ((iflag&IXOFF) != (old_iflag&IXOFF)\r\n|| (cflag&CRTSCTS) != (old_cflag&CRTSCTS)) {\r\narg = 0;\r\nif (iflag&IXOFF)\r\narg |= DIGI_INPUT_FLOW_CONTROL_XON_XOFF;\r\nelse\r\narg &= ~DIGI_INPUT_FLOW_CONTROL_XON_XOFF;\r\nif (cflag&CRTSCTS) {\r\narg |= DIGI_INPUT_FLOW_CONTROL_RTS;\r\nbuf[i++] = DIGI_CMD_SET_RTS_SIGNAL;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = DIGI_RTS_ACTIVE;\r\nbuf[i++] = 0;\r\n} else {\r\narg &= ~DIGI_INPUT_FLOW_CONTROL_RTS;\r\n}\r\nbuf[i++] = DIGI_CMD_SET_INPUT_FLOW_CONTROL;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\nif ((iflag & IXON) != (old_iflag & IXON)\r\n|| (cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\r\narg = 0;\r\nif (iflag & IXON)\r\narg |= DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF;\r\nelse\r\narg &= ~DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF;\r\nif (cflag & CRTSCTS) {\r\narg |= DIGI_OUTPUT_FLOW_CONTROL_CTS;\r\n} else {\r\narg &= ~DIGI_OUTPUT_FLOW_CONTROL_CTS;\r\n}\r\nbuf[i++] = DIGI_CMD_SET_OUTPUT_FLOW_CONTROL;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\nif ((cflag & CREAD) != (old_cflag & CREAD)) {\r\nif (cflag & CREAD)\r\narg = DIGI_ENABLE;\r\nelse\r\narg = DIGI_DISABLE;\r\nbuf[i++] = DIGI_CMD_RECEIVE_ENABLE;\r\nbuf[i++] = priv->dp_port_num;\r\nbuf[i++] = arg;\r\nbuf[i++] = 0;\r\n}\r\nret = digi_write_oob_command(port, buf, i, 1);\r\nif (ret != 0)\r\ndev_dbg(dev, "digi_set_termios: write oob failed, ret=%d\n", ret);\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\nstatic void digi_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned char buf[4];\r\nbuf[0] = DIGI_CMD_BREAK_CONTROL;\r\nbuf[1] = 2;\r\nbuf[2] = break_state ? 1 : 0;\r\nbuf[3] = 0;\r\ndigi_write_inb_command(port, buf, 4, 0);\r\n}\r\nstatic int digi_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nval = priv->dp_modem_signals;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nreturn val;\r\n}\r\nstatic int digi_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nval = (priv->dp_modem_signals & ~clear) | set;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nreturn digi_set_modem_signals(port, val, 1);\r\n}\r\nstatic int digi_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nint ret, data_len, new_len;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = port->write_urb->transfer_buffer;\r\nunsigned long flags = 0;\r\ndev_dbg(&port->dev,\r\n"digi_write: TOP: port=%d, count=%d, in_interrupt=%ld\n",\r\npriv->dp_port_num, count, in_interrupt());\r\ncount = min(count, port->bulk_out_size-2);\r\ncount = min(64, count);\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nif (priv->dp_write_urb_in_use) {\r\nif (count == 1 && priv->dp_out_buf_len < DIGI_OUT_BUF_SIZE) {\r\npriv->dp_out_buf[priv->dp_out_buf_len++] = *buf;\r\nnew_len = 1;\r\n} else {\r\nnew_len = 0;\r\n}\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nreturn new_len;\r\n}\r\nnew_len = min(count, port->bulk_out_size-2-priv->dp_out_buf_len);\r\ndata_len = new_len + priv->dp_out_buf_len;\r\nif (data_len == 0) {\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nreturn 0;\r\n}\r\nport->write_urb->transfer_buffer_length = data_len+2;\r\n*data++ = DIGI_CMD_SEND_DATA;\r\n*data++ = data_len;\r\nmemcpy(data, priv->dp_out_buf, priv->dp_out_buf_len);\r\ndata += priv->dp_out_buf_len;\r\nmemcpy(data, buf, new_len);\r\nret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\npriv->dp_write_urb_in_use = 1;\r\nret = new_len;\r\npriv->dp_out_buf_len = 0;\r\n}\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\nif (ret < 0)\r\ndev_err_console(port,\r\n"%s: usb_submit_urb failed, ret=%d, port=%d\n",\r\n__func__, ret, priv->dp_port_num);\r\ndev_dbg(&port->dev, "digi_write: returning %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void digi_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial;\r\nstruct digi_port *priv;\r\nstruct digi_serial *serial_priv;\r\nint ret = 0;\r\nint status = urb->status;\r\nif (port == NULL || (priv = usb_get_serial_port_data(port)) == NULL) {\r\npr_err("%s: port or port->private is NULL, status=%d\n",\r\n__func__, status);\r\nreturn;\r\n}\r\nserial = port->serial;\r\nif (serial == NULL || (serial_priv = usb_get_serial_data(serial)) == NULL) {\r\ndev_err(&port->dev,\r\n"%s: serial or serial->private is NULL, status=%d\n",\r\n__func__, status);\r\nreturn;\r\n}\r\nif (priv->dp_port_num == serial_priv->ds_oob_port_num) {\r\ndev_dbg(&port->dev, "digi_write_bulk_callback: oob callback\n");\r\nspin_lock(&priv->dp_port_lock);\r\npriv->dp_write_urb_in_use = 0;\r\nwake_up_interruptible(&port->write_wait);\r\nspin_unlock(&priv->dp_port_lock);\r\nreturn;\r\n}\r\nspin_lock(&priv->dp_port_lock);\r\npriv->dp_write_urb_in_use = 0;\r\nif (priv->dp_out_buf_len > 0) {\r\n*((unsigned char *)(port->write_urb->transfer_buffer))\r\n= (unsigned char)DIGI_CMD_SEND_DATA;\r\n*((unsigned char *)(port->write_urb->transfer_buffer) + 1)\r\n= (unsigned char)priv->dp_out_buf_len;\r\nport->write_urb->transfer_buffer_length =\r\npriv->dp_out_buf_len + 2;\r\nmemcpy(port->write_urb->transfer_buffer + 2, priv->dp_out_buf,\r\npriv->dp_out_buf_len);\r\nret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\npriv->dp_write_urb_in_use = 1;\r\npriv->dp_out_buf_len = 0;\r\n}\r\n}\r\ntty_port_tty_wakeup(&port->port);\r\nschedule_work(&priv->dp_wakeup_work);\r\nspin_unlock(&priv->dp_port_lock);\r\nif (ret && ret != -EPERM)\r\ndev_err_console(port,\r\n"%s: usb_submit_urb failed, ret=%d, port=%d\n",\r\n__func__, ret, priv->dp_port_num);\r\n}\r\nstatic int digi_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nint room;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&priv->dp_port_lock, flags);\r\nif (priv->dp_write_urb_in_use)\r\nroom = 0;\r\nelse\r\nroom = port->bulk_out_size - 2 - priv->dp_out_buf_len;\r\nspin_unlock_irqrestore(&priv->dp_port_lock, flags);\r\ndev_dbg(&port->dev, "digi_write_room: port=%d, room=%d\n", priv->dp_port_num, room);\r\nreturn room;\r\n}\r\nstatic int digi_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nif (priv->dp_write_urb_in_use) {\r\ndev_dbg(&port->dev, "digi_chars_in_buffer: port=%d, chars=%d\n",\r\npriv->dp_port_num, port->bulk_out_size - 2);\r\nreturn 256;\r\n} else {\r\ndev_dbg(&port->dev, "digi_chars_in_buffer: port=%d, chars=%d\n",\r\npriv->dp_port_num, priv->dp_out_buf_len);\r\nreturn priv->dp_out_buf_len;\r\n}\r\n}\r\nstatic void digi_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\ndigi_set_modem_signals(port, on * (TIOCM_DTR|TIOCM_RTS), 1);\r\n}\r\nstatic int digi_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint ret;\r\nunsigned char buf[32];\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nstruct ktermios not_termios;\r\nif (digi_startup_device(port->serial) != 0)\r\nreturn -ENXIO;\r\nbuf[0] = DIGI_CMD_READ_INPUT_SIGNALS;\r\nbuf[1] = priv->dp_port_num;\r\nbuf[2] = DIGI_ENABLE;\r\nbuf[3] = 0;\r\nbuf[4] = DIGI_CMD_IFLUSH_FIFO;\r\nbuf[5] = priv->dp_port_num;\r\nbuf[6] = DIGI_FLUSH_TX | DIGI_FLUSH_RX;\r\nbuf[7] = 0;\r\nret = digi_write_oob_command(port, buf, 8, 1);\r\nif (ret != 0)\r\ndev_dbg(&port->dev, "digi_open: write oob failed, ret=%d\n", ret);\r\nif (tty) {\r\nnot_termios.c_cflag = ~tty->termios.c_cflag;\r\nnot_termios.c_iflag = ~tty->termios.c_iflag;\r\ndigi_set_termios(tty, port, &not_termios);\r\n}\r\nreturn 0;\r\n}\r\nstatic void digi_close(struct usb_serial_port *port)\r\n{\r\nDEFINE_WAIT(wait);\r\nint ret;\r\nunsigned char buf[32];\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nmutex_lock(&port->serial->disc_mutex);\r\nif (port->serial->disconnected)\r\ngoto exit;\r\ndigi_transmit_idle(port, DIGI_CLOSE_TIMEOUT);\r\nbuf[0] = DIGI_CMD_SET_INPUT_FLOW_CONTROL;\r\nbuf[1] = priv->dp_port_num;\r\nbuf[2] = DIGI_DISABLE;\r\nbuf[3] = 0;\r\nbuf[4] = DIGI_CMD_SET_OUTPUT_FLOW_CONTROL;\r\nbuf[5] = priv->dp_port_num;\r\nbuf[6] = DIGI_DISABLE;\r\nbuf[7] = 0;\r\nbuf[8] = DIGI_CMD_READ_INPUT_SIGNALS;\r\nbuf[9] = priv->dp_port_num;\r\nbuf[10] = DIGI_DISABLE;\r\nbuf[11] = 0;\r\nbuf[12] = DIGI_CMD_RECEIVE_ENABLE;\r\nbuf[13] = priv->dp_port_num;\r\nbuf[14] = DIGI_DISABLE;\r\nbuf[15] = 0;\r\nbuf[16] = DIGI_CMD_IFLUSH_FIFO;\r\nbuf[17] = priv->dp_port_num;\r\nbuf[18] = DIGI_FLUSH_TX | DIGI_FLUSH_RX;\r\nbuf[19] = 0;\r\nret = digi_write_oob_command(port, buf, 20, 0);\r\nif (ret != 0)\r\ndev_dbg(&port->dev, "digi_close: write oob failed, ret=%d\n",\r\nret);\r\nprepare_to_wait(&priv->dp_flush_wait, &wait,\r\nTASK_INTERRUPTIBLE);\r\nschedule_timeout(DIGI_CLOSE_TIMEOUT);\r\nfinish_wait(&priv->dp_flush_wait, &wait);\r\nusb_kill_urb(port->write_urb);\r\nexit:\r\nspin_lock_irq(&priv->dp_port_lock);\r\npriv->dp_write_urb_in_use = 0;\r\nwake_up_interruptible(&priv->dp_close_wait);\r\nspin_unlock_irq(&priv->dp_port_lock);\r\nmutex_unlock(&port->serial->disc_mutex);\r\n}\r\nstatic int digi_startup_device(struct usb_serial *serial)\r\n{\r\nint i, ret = 0;\r\nstruct digi_serial *serial_priv = usb_get_serial_data(serial);\r\nstruct usb_serial_port *port;\r\nspin_lock(&serial_priv->ds_serial_lock);\r\nif (serial_priv->ds_device_started) {\r\nspin_unlock(&serial_priv->ds_serial_lock);\r\nreturn 0;\r\n}\r\nserial_priv->ds_device_started = 1;\r\nspin_unlock(&serial_priv->ds_serial_lock);\r\nfor (i = 0; i < serial->type->num_ports + 1; i++) {\r\nport = serial->port[i];\r\nret = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (ret != 0) {\r\ndev_err(&port->dev,\r\n"%s: usb_submit_urb failed, ret=%d, port=%d\n",\r\n__func__, ret, i);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int digi_port_init(struct usb_serial_port *port, unsigned port_num)\r\n{\r\nstruct digi_port *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->dp_port_lock);\r\npriv->dp_port_num = port_num;\r\ninit_waitqueue_head(&priv->dp_transmit_idle_wait);\r\ninit_waitqueue_head(&priv->dp_flush_wait);\r\ninit_waitqueue_head(&priv->dp_close_wait);\r\nINIT_WORK(&priv->dp_wakeup_work, digi_wakeup_write_lock);\r\npriv->dp_port = port;\r\ninit_waitqueue_head(&port->write_wait);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int digi_startup(struct usb_serial *serial)\r\n{\r\nstruct device *dev = &serial->interface->dev;\r\nstruct digi_serial *serial_priv;\r\nint ret;\r\nint i;\r\nif (serial->num_port_pointers < serial->type->num_ports + 1) {\r\ndev_err(dev, "OOB endpoints missing\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\r\nif (!serial->port[i]->read_urb) {\r\ndev_err(dev, "bulk-in endpoint missing\n");\r\nreturn -ENODEV;\r\n}\r\nif (!serial->port[i]->write_urb) {\r\ndev_err(dev, "bulk-out endpoint missing\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\r\nif (!serial_priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&serial_priv->ds_serial_lock);\r\nserial_priv->ds_oob_port_num = serial->type->num_ports;\r\nserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\r\nret = digi_port_init(serial_priv->ds_oob_port,\r\nserial_priv->ds_oob_port_num);\r\nif (ret) {\r\nkfree(serial_priv);\r\nreturn ret;\r\n}\r\nusb_set_serial_data(serial, serial_priv);\r\nreturn 0;\r\n}\r\nstatic void digi_disconnect(struct usb_serial *serial)\r\n{\r\nint i;\r\nfor (i = 0; i < serial->type->num_ports + 1; i++) {\r\nusb_kill_urb(serial->port[i]->read_urb);\r\nusb_kill_urb(serial->port[i]->write_urb);\r\n}\r\n}\r\nstatic void digi_release(struct usb_serial *serial)\r\n{\r\nstruct digi_serial *serial_priv;\r\nstruct digi_port *priv;\r\nserial_priv = usb_get_serial_data(serial);\r\npriv = usb_get_serial_port_data(serial_priv->ds_oob_port);\r\nkfree(priv);\r\nkfree(serial_priv);\r\n}\r\nstatic int digi_port_probe(struct usb_serial_port *port)\r\n{\r\nreturn digi_port_init(port, port->port_number);\r\n}\r\nstatic int digi_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct digi_port *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void digi_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct digi_port *priv;\r\nstruct digi_serial *serial_priv;\r\nint ret;\r\nint status = urb->status;\r\nif (port == NULL)\r\nreturn;\r\npriv = usb_get_serial_port_data(port);\r\nif (priv == NULL) {\r\ndev_err(&port->dev, "%s: port->private is NULL, status=%d\n",\r\n__func__, status);\r\nreturn;\r\n}\r\nif (port->serial == NULL ||\r\n(serial_priv = usb_get_serial_data(port->serial)) == NULL) {\r\ndev_err(&port->dev, "%s: serial is bad or serial->private "\r\n"is NULL, status=%d\n", __func__, status);\r\nreturn;\r\n}\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s: nonzero read bulk status: status=%d, port=%d\n",\r\n__func__, status, priv->dp_port_num);\r\nreturn;\r\n}\r\nif (priv->dp_port_num == serial_priv->ds_oob_port_num) {\r\nif (digi_read_oob_callback(urb) != 0)\r\nreturn;\r\n} else {\r\nif (digi_read_inb_callback(urb) != 0)\r\nreturn;\r\n}\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret != 0 && ret != -EPERM) {\r\ndev_err(&port->dev,\r\n"%s: failed resubmitting urb, ret=%d, port=%d\n",\r\n__func__, ret, priv->dp_port_num);\r\n}\r\n}\r\nstatic int digi_read_inb_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nint opcode = ((unsigned char *)urb->transfer_buffer)[0];\r\nint len = ((unsigned char *)urb->transfer_buffer)[1];\r\nint port_status = ((unsigned char *)urb->transfer_buffer)[2];\r\nunsigned char *data = ((unsigned char *)urb->transfer_buffer) + 3;\r\nint flag, throttled;\r\nint status = urb->status;\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\nif (urb->actual_length != len + 2) {\r\ndev_err(&port->dev, "%s: INCOMPLETE OR MULTIPLE PACKET, "\r\n"status=%d, port=%d, opcode=%d, len=%d, "\r\n"actual_length=%d, status=%d\n", __func__, status,\r\npriv->dp_port_num, opcode, len, urb->actual_length,\r\nport_status);\r\nreturn -1;\r\n}\r\nspin_lock(&priv->dp_port_lock);\r\nthrottled = priv->dp_throttled;\r\nif (throttled)\r\npriv->dp_throttle_restart = 1;\r\nif (opcode == DIGI_CMD_RECEIVE_DATA) {\r\nflag = 0;\r\nif (port_status & DIGI_OVERRUN_ERROR)\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\nif (port_status & DIGI_BREAK_ERROR)\r\nflag = TTY_BREAK;\r\nelse if (port_status & DIGI_PARITY_ERROR)\r\nflag = TTY_PARITY;\r\nelse if (port_status & DIGI_FRAMING_ERROR)\r\nflag = TTY_FRAME;\r\n--len;\r\nif (len > 0) {\r\ntty_insert_flip_string_fixed_flag(&port->port, data,\r\nflag, len);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\n}\r\nspin_unlock(&priv->dp_port_lock);\r\nif (opcode == DIGI_CMD_RECEIVE_DISABLE)\r\ndev_dbg(&port->dev, "%s: got RECEIVE_DISABLE\n", __func__);\r\nelse if (opcode != DIGI_CMD_RECEIVE_DATA)\r\ndev_dbg(&port->dev, "%s: unknown opcode: %d\n", __func__, opcode);\r\nreturn throttled ? 1 : 0;\r\n}\r\nstatic int digi_read_oob_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = port->serial;\r\nstruct tty_struct *tty;\r\nstruct digi_port *priv = usb_get_serial_port_data(port);\r\nint opcode, line, status, val;\r\nint i;\r\nunsigned int rts;\r\nfor (i = 0; i < urb->actual_length - 3;) {\r\nopcode = ((unsigned char *)urb->transfer_buffer)[i++];\r\nline = ((unsigned char *)urb->transfer_buffer)[i++];\r\nstatus = ((unsigned char *)urb->transfer_buffer)[i++];\r\nval = ((unsigned char *)urb->transfer_buffer)[i++];\r\ndev_dbg(&port->dev, "digi_read_oob_callback: opcode=%d, line=%d, status=%d, val=%d\n",\r\nopcode, line, status, val);\r\nif (status != 0 || line >= serial->type->num_ports)\r\ncontinue;\r\nport = serial->port[line];\r\npriv = usb_get_serial_port_data(port);\r\nif (priv == NULL)\r\nreturn -1;\r\ntty = tty_port_tty_get(&port->port);\r\nrts = 0;\r\nif (tty)\r\nrts = C_CRTSCTS(tty);\r\nif (tty && opcode == DIGI_CMD_READ_INPUT_SIGNALS) {\r\nspin_lock(&priv->dp_port_lock);\r\nif (val & DIGI_READ_INPUT_SIGNALS_CTS) {\r\npriv->dp_modem_signals |= TIOCM_CTS;\r\nif (rts)\r\ntty_port_tty_wakeup(&port->port);\r\n} else {\r\npriv->dp_modem_signals &= ~TIOCM_CTS;\r\n}\r\nif (val & DIGI_READ_INPUT_SIGNALS_DSR)\r\npriv->dp_modem_signals |= TIOCM_DSR;\r\nelse\r\npriv->dp_modem_signals &= ~TIOCM_DSR;\r\nif (val & DIGI_READ_INPUT_SIGNALS_RI)\r\npriv->dp_modem_signals |= TIOCM_RI;\r\nelse\r\npriv->dp_modem_signals &= ~TIOCM_RI;\r\nif (val & DIGI_READ_INPUT_SIGNALS_DCD)\r\npriv->dp_modem_signals |= TIOCM_CD;\r\nelse\r\npriv->dp_modem_signals &= ~TIOCM_CD;\r\nspin_unlock(&priv->dp_port_lock);\r\n} else if (opcode == DIGI_CMD_TRANSMIT_IDLE) {\r\nspin_lock(&priv->dp_port_lock);\r\npriv->dp_transmit_idle = 1;\r\nwake_up_interruptible(&priv->dp_transmit_idle_wait);\r\nspin_unlock(&priv->dp_port_lock);\r\n} else if (opcode == DIGI_CMD_IFLUSH_FIFO) {\r\nwake_up_interruptible(&priv->dp_flush_wait);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nreturn 0;\r\n}
