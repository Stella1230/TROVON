static void zcomp_strm_free(struct zcomp_strm *zstrm)\r\n{\r\nif (!IS_ERR_OR_NULL(zstrm->tfm))\r\ncrypto_free_comp(zstrm->tfm);\r\nfree_pages((unsigned long)zstrm->buffer, 1);\r\nkfree(zstrm);\r\n}\r\nstatic struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);\r\nif (!zstrm)\r\nreturn NULL;\r\nzstrm->tfm = crypto_alloc_comp(comp->name, 0, 0);\r\nzstrm->buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);\r\nif (IS_ERR_OR_NULL(zstrm->tfm) || !zstrm->buffer) {\r\nzcomp_strm_free(zstrm);\r\nzstrm = NULL;\r\n}\r\nreturn zstrm;\r\n}\r\nbool zcomp_available_algorithm(const char *comp)\r\n{\r\nint i = 0;\r\nwhile (backends[i]) {\r\nif (sysfs_streq(comp, backends[i]))\r\nreturn true;\r\ni++;\r\n}\r\nreturn crypto_has_comp(comp, 0, 0) == 1;\r\n}\r\nssize_t zcomp_available_show(const char *comp, char *buf)\r\n{\r\nbool known_algorithm = false;\r\nssize_t sz = 0;\r\nint i = 0;\r\nfor (; backends[i]; i++) {\r\nif (!strcmp(comp, backends[i])) {\r\nknown_algorithm = true;\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"[%s] ", backends[i]);\r\n} else {\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"%s ", backends[i]);\r\n}\r\n}\r\nif (!known_algorithm && crypto_has_comp(comp, 0, 0) == 1)\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"[%s] ", comp);\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz, "\n");\r\nreturn sz;\r\n}\r\nstruct zcomp_strm *zcomp_stream_get(struct zcomp *comp)\r\n{\r\nreturn *get_cpu_ptr(comp->stream);\r\n}\r\nvoid zcomp_stream_put(struct zcomp *comp)\r\n{\r\nput_cpu_ptr(comp->stream);\r\n}\r\nint zcomp_compress(struct zcomp_strm *zstrm,\r\nconst void *src, unsigned int *dst_len)\r\n{\r\n*dst_len = PAGE_SIZE * 2;\r\nreturn crypto_comp_compress(zstrm->tfm,\r\nsrc, PAGE_SIZE,\r\nzstrm->buffer, dst_len);\r\n}\r\nint zcomp_decompress(struct zcomp_strm *zstrm,\r\nconst void *src, unsigned int src_len, void *dst)\r\n{\r\nunsigned int dst_len = PAGE_SIZE;\r\nreturn crypto_comp_decompress(zstrm->tfm,\r\nsrc, src_len,\r\ndst, &dst_len);\r\n}\r\nstatic int __zcomp_cpu_notifier(struct zcomp *comp,\r\nunsigned long action, unsigned long cpu)\r\n{\r\nstruct zcomp_strm *zstrm;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\nif (WARN_ON(*per_cpu_ptr(comp->stream, cpu)))\r\nbreak;\r\nzstrm = zcomp_strm_alloc(comp);\r\nif (IS_ERR_OR_NULL(zstrm)) {\r\npr_err("Can't allocate a compression stream\n");\r\nreturn NOTIFY_BAD;\r\n}\r\n*per_cpu_ptr(comp->stream, cpu) = zstrm;\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_UP_CANCELED:\r\nzstrm = *per_cpu_ptr(comp->stream, cpu);\r\nif (!IS_ERR_OR_NULL(zstrm))\r\nzcomp_strm_free(zstrm);\r\n*per_cpu_ptr(comp->stream, cpu) = NULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int zcomp_cpu_notifier(struct notifier_block *nb,\r\nunsigned long action, void *pcpu)\r\n{\r\nunsigned long cpu = (unsigned long)pcpu;\r\nstruct zcomp *comp = container_of(nb, typeof(*comp), notifier);\r\nreturn __zcomp_cpu_notifier(comp, action, cpu);\r\n}\r\nstatic int zcomp_init(struct zcomp *comp)\r\n{\r\nunsigned long cpu;\r\nint ret;\r\ncomp->notifier.notifier_call = zcomp_cpu_notifier;\r\ncomp->stream = alloc_percpu(struct zcomp_strm *);\r\nif (!comp->stream)\r\nreturn -ENOMEM;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu) {\r\nret = __zcomp_cpu_notifier(comp, CPU_UP_PREPARE, cpu);\r\nif (ret == NOTIFY_BAD)\r\ngoto cleanup;\r\n}\r\n__register_cpu_notifier(&comp->notifier);\r\ncpu_notifier_register_done();\r\nreturn 0;\r\ncleanup:\r\nfor_each_online_cpu(cpu)\r\n__zcomp_cpu_notifier(comp, CPU_UP_CANCELED, cpu);\r\ncpu_notifier_register_done();\r\nreturn -ENOMEM;\r\n}\r\nvoid zcomp_destroy(struct zcomp *comp)\r\n{\r\nunsigned long cpu;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu)\r\n__zcomp_cpu_notifier(comp, CPU_UP_CANCELED, cpu);\r\n__unregister_cpu_notifier(&comp->notifier);\r\ncpu_notifier_register_done();\r\nfree_percpu(comp->stream);\r\nkfree(comp);\r\n}\r\nstruct zcomp *zcomp_create(const char *compress)\r\n{\r\nstruct zcomp *comp;\r\nint error;\r\nif (!zcomp_available_algorithm(compress))\r\nreturn ERR_PTR(-EINVAL);\r\ncomp = kzalloc(sizeof(struct zcomp), GFP_KERNEL);\r\nif (!comp)\r\nreturn ERR_PTR(-ENOMEM);\r\ncomp->name = compress;\r\nerror = zcomp_init(comp);\r\nif (error) {\r\nkfree(comp);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn comp;\r\n}
