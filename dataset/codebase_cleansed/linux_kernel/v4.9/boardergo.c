static irqreturn_t\r\nergo_interrupt(int intno, void *dev_id)\r\n{\r\nhysdn_card *card = dev_id;\r\ntErgDpram *dpr;\r\nunsigned long flags;\r\nunsigned char volatile b;\r\nif (!card)\r\nreturn IRQ_NONE;\r\nif (!card->irq_enabled)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\nif (!(bytein(card->iobase + PCI9050_INTR_REG) & PCI9050_INTR_REG_STAT1)) {\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\ndpr = card->dpram;\r\nb = dpr->ToPcInt;\r\nb |= dpr->ToPcIntMetro;\r\nb |= dpr->ToHyInt;\r\nif (!card->hw_lock)\r\nschedule_work(&card->irq_queue);\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nergo_irq_bh(struct work_struct *ugli_api)\r\n{\r\nhysdn_card *card = container_of(ugli_api, hysdn_card, irq_queue);\r\ntErgDpram *dpr;\r\nint again;\r\nunsigned long flags;\r\nif (card->state != CARD_STATE_RUN)\r\nreturn;\r\ndpr = card->dpram;\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\nif (card->hw_lock) {\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nreturn;\r\n}\r\ncard->hw_lock = 1;\r\ndo {\r\nagain = 0;\r\nif (!dpr->ToHyFlag) {\r\nif (hysdn_sched_tx(card, dpr->ToHyBuf, &dpr->ToHySize, &dpr->ToHyChannel,\r\nERG_TO_HY_BUF_SIZE)) {\r\ndpr->ToHyFlag = 1;\r\nagain = 1;\r\n}\r\n}\r\nif (dpr->ToPcFlag) {\r\nif (hysdn_sched_rx(card, dpr->ToPcBuf, dpr->ToPcSize, dpr->ToPcChannel)) {\r\ndpr->ToPcFlag = 0;\r\nagain = 1;\r\n}\r\n}\r\nif (again) {\r\ndpr->ToHyInt = 1;\r\ndpr->ToPcInt = 1;\r\n} else\r\ncard->hw_lock = 0;\r\n} while (again);\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\n}\r\nstatic void\r\nergo_stopcard(hysdn_card *card)\r\n{\r\nunsigned long flags;\r\nunsigned char val;\r\nhysdn_net_release(card);\r\n#ifdef CONFIG_HYSDN_CAPI\r\nhycapi_capi_stop(card);\r\n#endif\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\nval = bytein(card->iobase + PCI9050_INTR_REG);\r\nval &= ~(PCI9050_INTR_REG_ENPCI | PCI9050_INTR_REG_EN1);\r\nbyteout(card->iobase + PCI9050_INTR_REG, val);\r\ncard->irq_enabled = 0;\r\nbyteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RESET);\r\ncard->state = CARD_STATE_UNUSED;\r\ncard->err_log_state = ERRLOG_STATE_OFF;\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\n}\r\nstatic void\r\nergo_set_errlog_state(hysdn_card *card, int on)\r\n{\r\nunsigned long flags;\r\nif (card->state != CARD_STATE_RUN) {\r\ncard->err_log_state = ERRLOG_STATE_OFF;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\nif (((card->err_log_state == ERRLOG_STATE_OFF) && !on) ||\r\n((card->err_log_state == ERRLOG_STATE_ON) && on)) {\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nreturn;\r\n}\r\nif (on)\r\ncard->err_log_state = ERRLOG_STATE_START;\r\nelse\r\ncard->err_log_state = ERRLOG_STATE_STOP;\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nschedule_work(&card->irq_queue);\r\n}\r\nstatic int\r\nergo_testram(hysdn_card *card)\r\n{\r\ntErgDpram *dpr = card->dpram;\r\nmemset(dpr->TrapTable, 0, sizeof(dpr->TrapTable));\r\ndpr->ToHyInt = 1;\r\nmemcpy(&dpr->ToHyBuf[ERG_TO_HY_BUF_SIZE - sizeof(TestText)], TestText,\r\nsizeof(TestText));\r\nif (memcmp(&dpr->ToHyBuf[ERG_TO_HY_BUF_SIZE - sizeof(TestText)], TestText,\r\nsizeof(TestText)))\r\nreturn (-1);\r\nmemcpy(&dpr->ToPcBuf[ERG_TO_PC_BUF_SIZE - sizeof(TestText)], TestText,\r\nsizeof(TestText));\r\nif (memcmp(&dpr->ToPcBuf[ERG_TO_PC_BUF_SIZE - sizeof(TestText)], TestText,\r\nsizeof(TestText)))\r\nreturn (-1);\r\nreturn (0);\r\n}\r\nstatic int\r\nergo_writebootimg(struct HYSDN_CARD *card, unsigned char *buf,\r\nunsigned long offs)\r\n{\r\nunsigned char *dst;\r\ntErgDpram *dpram;\r\nint cnt = (BOOT_IMG_SIZE >> 2);\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: write bootldr offs=0x%lx ", offs);\r\ndst = card->dpram;\r\ndst += (offs + ERG_DPRAM_FILL_SIZE);\r\nwhile (cnt--) {\r\n*dst++ = *(buf + 1);\r\n*dst++ = *buf;\r\ndst += 2;\r\nbuf += 2;\r\n}\r\nif (offs) {\r\nmemset(card->dpram, 0, ERG_DPRAM_FILL_SIZE);\r\ndpram = card->dpram;\r\ndpram->ToHyNoDpramErrLog = 0xFF;\r\nwhile (!dpram->ToHyNoDpramErrLog);\r\nbyteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RUN);\r\nmsleep_interruptible(20);\r\nif (((tDpramBootSpooler *) card->dpram)->Len != DPRAM_SPOOLER_DATA_SIZE) {\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: write bootldr no answer");\r\nreturn (-ERR_BOOTIMG_FAIL);\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nergo_writebootseq(struct HYSDN_CARD *card, unsigned char *buf, int len)\r\n{\r\ntDpramBootSpooler *sp = (tDpramBootSpooler *) card->dpram;\r\nunsigned char *dst;\r\nunsigned char buflen;\r\nint nr_write;\r\nunsigned char tmp_rdptr;\r\nunsigned char wr_mirror;\r\nint i;\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: write boot seq len=%d ", len);\r\ndst = sp->Data;\r\nbuflen = sp->Len;\r\nwr_mirror = sp->WrPtr;\r\ni = 0x1000;\r\nwhile (len) {\r\ndo {\r\ntmp_rdptr = sp->RdPtr;\r\ni--;\r\n} while (i && (tmp_rdptr != sp->RdPtr));\r\nif (!i) {\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: write boot seq timeout");\r\nreturn (-ERR_BOOTSEQ_FAIL);\r\n}\r\nif ((nr_write = tmp_rdptr - wr_mirror - 1) < 0)\r\nnr_write += buflen;\r\nif (!nr_write)\r\ncontinue;\r\nif (nr_write > len)\r\nnr_write = len;\r\ni = 0x1000;\r\nlen -= nr_write;\r\nwhile (nr_write--) {\r\n*(dst + wr_mirror) = *buf++;\r\nif (++wr_mirror >= buflen)\r\nwr_mirror = 0;\r\nsp->WrPtr = wr_mirror;\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nergo_waitpofready(struct HYSDN_CARD *card)\r\n{\r\ntErgDpram *dpr = card->dpram;\r\nint timecnt = 10000 / 50;\r\nunsigned long flags;\r\nint msg_size;\r\nint i;\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: waiting for pof ready");\r\nwhile (timecnt--) {\r\nif (dpr->ToPcFlag) {\r\nif ((dpr->ToPcChannel != CHAN_SYSTEM) ||\r\n(dpr->ToPcSize < MIN_RDY_MSG_SIZE) ||\r\n(dpr->ToPcSize > MAX_RDY_MSG_SIZE) ||\r\n((*(unsigned long *) dpr->ToPcBuf) != RDY_MAGIC))\r\nbreak;\r\nmsg_size = dpr->ToPcSize - RDY_MAGIC_SIZE;\r\nif (msg_size > 0)\r\nif (EvalSysrTokData(card, dpr->ToPcBuf + RDY_MAGIC_SIZE, msg_size))\r\nbreak;\r\nif (card->debug_flags & LOG_POF_RECORD)\r\nhysdn_addlog(card, "ERGO: pof boot success");\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\ncard->state = CARD_STATE_RUN;\r\nbyteout(card->iobase + PCI9050_INTR_REG,\r\nbytein(card->iobase + PCI9050_INTR_REG) |\r\n(PCI9050_INTR_REG_ENPCI | PCI9050_INTR_REG_EN1));\r\ncard->irq_enabled = 1;\r\ndpr->ToPcFlag = 0;\r\ndpr->ToHyInt = 1;\r\ndpr->ToPcInt = 1;\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nif ((hynet_enable & (1 << card->myid))\r\n&& (i = hysdn_net_create(card)))\r\n{\r\nergo_stopcard(card);\r\ncard->state = CARD_STATE_BOOTERR;\r\nreturn (i);\r\n}\r\n#ifdef CONFIG_HYSDN_CAPI\r\nif ((i = hycapi_capi_create(card))) {\r\nprintk(KERN_WARNING "HYSDN: failed to create capi-interface.\n");\r\n}\r\n#endif\r\nreturn (0);\r\n}\r\nmsleep_interruptible(50);\r\n}\r\nif (card->debug_flags & LOG_POF_CARD)\r\nhysdn_addlog(card, "ERGO: pof boot ready timeout");\r\nreturn (-ERR_POF_TIMEOUT);\r\n}\r\nstatic void\r\nergo_releasehardware(hysdn_card *card)\r\n{\r\nergo_stopcard(card);\r\nfree_irq(card->irq, card);\r\nrelease_region(card->iobase + PCI9050_INTR_REG, 1);\r\nrelease_region(card->iobase + PCI9050_USER_IO, 1);\r\niounmap(card->dpram);\r\ncard->dpram = NULL;\r\n}\r\nint\r\nergo_inithardware(hysdn_card *card)\r\n{\r\nif (!request_region(card->iobase + PCI9050_INTR_REG, 1, "HYSDN"))\r\nreturn (-1);\r\nif (!request_region(card->iobase + PCI9050_USER_IO, 1, "HYSDN")) {\r\nrelease_region(card->iobase + PCI9050_INTR_REG, 1);\r\nreturn (-1);\r\n}\r\ncard->memend = card->membase + ERG_DPRAM_PAGE_SIZE - 1;\r\nif (!(card->dpram = ioremap(card->membase, ERG_DPRAM_PAGE_SIZE))) {\r\nrelease_region(card->iobase + PCI9050_INTR_REG, 1);\r\nrelease_region(card->iobase + PCI9050_USER_IO, 1);\r\nreturn (-1);\r\n}\r\nergo_stopcard(card);\r\nif (request_irq(card->irq, ergo_interrupt, IRQF_SHARED, "HYSDN", card)) {\r\nergo_releasehardware(card);\r\nreturn (-1);\r\n}\r\ncard->stopcard = ergo_stopcard;\r\ncard->releasehardware = ergo_releasehardware;\r\ncard->testram = ergo_testram;\r\ncard->writebootimg = ergo_writebootimg;\r\ncard->writebootseq = ergo_writebootseq;\r\ncard->waitpofready = ergo_waitpofready;\r\ncard->set_errlog_state = ergo_set_errlog_state;\r\nINIT_WORK(&card->irq_queue, ergo_irq_bh);\r\nspin_lock_init(&card->hysdn_lock);\r\nreturn (0);\r\n}
