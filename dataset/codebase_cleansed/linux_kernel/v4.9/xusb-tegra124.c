static inline struct tegra124_xusb_padctl *\r\nto_tegra124_xusb_padctl(struct tegra_xusb_padctl *padctl)\r\n{\r\nreturn container_of(padctl, struct tegra124_xusb_padctl, base);\r\n}\r\nstatic int tegra124_xusb_padctl_enable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (padctl->enable++ > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra124_xusb_padctl_disable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(padctl->enable == 0))\r\ngoto out;\r\nif (--padctl->enable > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra124_usb3_save_context(struct tegra_xusb_padctl *padctl,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_usb3_port *port;\r\nstruct tegra_xusb_lane *lane;\r\nu32 value, offset;\r\nport = tegra_xusb_find_usb3_port(padctl, index);\r\nif (!port)\r\nreturn -ENODEV;\r\nport->context_saved = true;\r\nlane = port->base.lane;\r\nif (lane->pad == padctl->pcie)\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL6(lane->index);\r\nelse\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL6;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_TAP <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nvalue = padctl_readl(padctl, offset) >>\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\r\nport->tap1 = value & XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_TAP_MASK;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_AMP <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nvalue = padctl_readl(padctl, offset) >>\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\r\nport->amp = value & XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_AMP_MASK;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\r\nvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT));\r\nvalue |= (port->tap1 <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\r\n(port->amp <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_LATCH_G_Z <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_G_Z <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nvalue = padctl_readl(padctl, offset) >>\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\r\nport->ctle_g = value &\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_G_Z_MASK;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_CTLE_Z <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nvalue = padctl_readl(padctl, offset) >>\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\r\nport->ctle_z = value &\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_G_Z_MASK;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\r\nvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT));\r\nvalue |= (port->ctle_g <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\r\n(port->ctle_z <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\r\nreturn 0;\r\n}\r\nstatic int tegra124_hsic_set_idle(struct tegra_xusb_padctl *padctl,\r\nunsigned int index, bool idle)\r\n{\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nif (idle)\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE;\r\nelse\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_usb2_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_usb2_lane *usb2;\r\nint err;\r\nusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\r\nif (!usb2)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&usb2->base.list);\r\nusb2->base.soc = &pad->soc->lanes[index];\r\nusb2->base.index = index;\r\nusb2->base.pad = pad;\r\nusb2->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&usb2->base, np);\r\nif (err < 0) {\r\nkfree(usb2);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &usb2->base;\r\n}\r\nstatic void tegra124_usb2_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\r\nkfree(usb2);\r\n}\r\nstatic int tegra124_usb2_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_usb2_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_usb2_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\r\nstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nstruct tegra124_xusb_padctl *priv;\r\nstruct tegra_xusb_usb2_port *port;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nint err;\r\nport = tegra_xusb_find_usb2_port(padctl, index);\r\nif (!port) {\r\ndev_err(&phy->dev, "no port found for USB2 lane %u\n", index);\r\nreturn -ENODEV;\r\n}\r\npriv = to_tegra124_xusb_padctl(padctl);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT));\r\nvalue |= (priv->fuse.hs_squelch_level <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\r\nvalue &= ~(XUSB_PADCTL_USB2_PORT_CAP_PORT_CAP_MASK <<\r\nXUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_SHIFT(index));\r\nvalue |= XUSB_PADCTL_USB2_PORT_CAP_HOST <<\r\nXUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_SHIFT(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_PORT_CAP);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\r\nvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT) |\r\n(XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_SHIFT) |\r\n(XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_SHIFT) |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI);\r\nvalue |= (priv->fuse.hs_curr_level[index] +\r\nusb2->hs_curr_level_offset) <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT;\r\nvalue |= XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_VAL <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_SHIFT;\r\nvalue |= XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_VAL(index) <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\r\nvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\r\n(XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_SHIFT) |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_FORCE_POWERUP |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_FORCE_POWERUP);\r\nvalue |= (priv->fuse.hs_term_range_adj <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\r\n(priv->fuse.hs_iref_cap <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\r\nerr = regulator_enable(port->supply);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&pad->lock);\r\nif (pad->enable++ > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nout:\r\nmutex_unlock(&pad->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra124_usb2_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nstruct tegra_xusb_usb2_port *port;\r\nu32 value;\r\nport = tegra_xusb_find_usb2_port(padctl, lane->index);\r\nif (!port) {\r\ndev_err(&phy->dev, "no port found for USB2 lane %u\n",\r\nlane->index);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&pad->lock);\r\nif (WARN_ON(pad->enable == 0))\r\ngoto out;\r\nif (--pad->enable > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue |= XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nout:\r\nregulator_disable(port->supply);\r\nmutex_unlock(&pad->lock);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra124_usb2_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_usb2_pad *usb2;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\r\nif (!usb2)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&usb2->lock);\r\npad = &usb2->base;\r\npad->ops = &tegra124_usb2_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(usb2);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra124_usb2_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra124_usb2_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\r\nkfree(usb2);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_ulpi_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_ulpi_lane *ulpi;\r\nint err;\r\nulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\r\nif (!ulpi)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&ulpi->base.list);\r\nulpi->base.soc = &pad->soc->lanes[index];\r\nulpi->base.index = index;\r\nulpi->base.pad = pad;\r\nulpi->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&ulpi->base, np);\r\nif (err < 0) {\r\nkfree(ulpi);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &ulpi->base;\r\n}\r\nstatic void tegra124_ulpi_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_ulpi_lane *ulpi = to_ulpi_lane(lane);\r\nkfree(ulpi);\r\n}\r\nstatic int tegra124_ulpi_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_ulpi_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_ulpi_phy_power_on(struct phy *phy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tegra124_ulpi_phy_power_off(struct phy *phy)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra124_ulpi_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_ulpi_pad *ulpi;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\r\nif (!ulpi)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &ulpi->base;\r\npad->ops = &tegra124_ulpi_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(ulpi);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra124_ulpi_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra124_ulpi_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_ulpi_pad *ulpi = to_ulpi_pad(pad);\r\nkfree(ulpi);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_hsic_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_hsic_lane *hsic;\r\nint err;\r\nhsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\r\nif (!hsic)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&hsic->base.list);\r\nhsic->base.soc = &pad->soc->lanes[index];\r\nhsic->base.index = index;\r\nhsic->base.pad = pad;\r\nhsic->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&hsic->base, np);\r\nif (err < 0) {\r\nkfree(hsic);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &hsic->base;\r\n}\r\nstatic void tegra124_hsic_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\r\nkfree(hsic);\r\n}\r\nstatic int tegra124_hsic_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_hsic_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_hsic_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\r\nstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nint err;\r\nerr = regulator_enable(pad->supply);\r\nif (err)\r\nreturn err;\r\npadctl_writel(padctl, hsic->strobe_trim,\r\nXUSB_PADCTL_HSIC_STRB_TRIM_CONTROL);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nif (hsic->auto_term)\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_AUTO_TERM_EN;\r\nelse\r\nvalue &= ~XUSB_PADCTL_HSIC_PAD_CTL1_AUTO_TERM_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_SHIFT));\r\nvalue |= (hsic->tx_rtune_n <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_SHIFT) |\r\n(hsic->tx_rtune_p <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_SHIFT) |\r\n(hsic->tx_rslew_n <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_SHIFT) |\r\n(hsic->tx_rslew_p <<\r\nXUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL2(index));\r\nvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT));\r\nvalue |= (hsic->rx_strobe_trim <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\r\n(hsic->rx_data_trim <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL2(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_RPD_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_RPU_DATA |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_RX |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_ZI |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_TRX |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_TX);\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nreturn 0;\r\n}\r\nstatic int tegra124_hsic_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_PD_RX |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_ZI |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_TRX |\r\nXUSB_PADCTL_HSIC_PAD_CTL1_PD_TX;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nregulator_disable(pad->supply);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra124_hsic_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_hsic_pad *hsic;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nhsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\r\nif (!hsic)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &hsic->base;\r\npad->ops = &tegra124_hsic_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(hsic);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra124_hsic_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra124_hsic_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_hsic_pad *hsic = to_hsic_pad(pad);\r\nkfree(hsic);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_pcie_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_pcie_lane *pcie;\r\nint err;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&pcie->base.list);\r\npcie->base.soc = &pad->soc->lanes[index];\r\npcie->base.index = index;\r\npcie->base.pad = pad;\r\npcie->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&pcie->base, np);\r\nif (err < 0) {\r\nkfree(pcie);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &pcie->base;\r\n}\r\nstatic void tegra124_pcie_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_pcie_lane *pcie = to_pcie_lane(lane);\r\nkfree(pcie);\r\n}\r\nstatic int tegra124_pcie_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_pcie_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_pcie_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nunsigned long timeout;\r\nint err = -ETIMEDOUT;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN |\r\nXUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN |\r\nXUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nif (value & XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET) {\r\nerr = 0;\r\nbreak;\r\n}\r\nusleep_range(100, 200);\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue |= XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nreturn err;\r\n}\r\nstatic int tegra124_pcie_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra124_pcie_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &pcie->base;\r\npad->ops = &tegra124_pcie_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(pcie);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra124_pcie_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra124_pcie_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(pad);\r\nkfree(pcie);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_sata_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_sata_lane *sata;\r\nint err;\r\nsata = kzalloc(sizeof(*sata), GFP_KERNEL);\r\nif (!sata)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&sata->base.list);\r\nsata->base.soc = &pad->soc->lanes[index];\r\nsata->base.index = index;\r\nsata->base.pad = pad;\r\nsata->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&sata->base, np);\r\nif (err < 0) {\r\nkfree(sata);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &sata->base;\r\n}\r\nstatic void tegra124_sata_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_sata_lane *sata = to_sata_lane(lane);\r\nkfree(sata);\r\n}\r\nstatic int tegra124_sata_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_sata_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra124_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra124_sata_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nunsigned long timeout;\r\nint err = -ETIMEDOUT;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\r\nvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nif (value & XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET) {\r\nerr = 0;\r\nbreak;\r\n}\r\nusleep_range(100, 200);\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue |= XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nreturn err;\r\n}\r\nstatic int tegra124_sata_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\r\nvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\r\nvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra124_sata_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_sata_pad *sata;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nsata = kzalloc(sizeof(*sata), GFP_KERNEL);\r\nif (!sata)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &sata->base;\r\npad->ops = &tegra124_sata_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(sata);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra124_sata_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra124_sata_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_sata_pad *sata = to_sata_pad(pad);\r\nkfree(sata);\r\n}\r\nstatic int tegra124_usb2_port_enable(struct tegra_xusb_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra124_usb2_port_disable(struct tegra_xusb_port *port)\r\n{\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_usb2_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_find_lane(port->padctl, "usb2", port->index);\r\n}\r\nstatic int tegra124_ulpi_port_enable(struct tegra_xusb_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra124_ulpi_port_disable(struct tegra_xusb_port *port)\r\n{\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_ulpi_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_find_lane(port->padctl, "ulpi", port->index);\r\n}\r\nstatic int tegra124_hsic_port_enable(struct tegra_xusb_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra124_hsic_port_disable(struct tegra_xusb_port *port)\r\n{\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_hsic_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_find_lane(port->padctl, "hsic", port->index);\r\n}\r\nstatic int tegra124_usb3_port_enable(struct tegra_xusb_port *port)\r\n{\r\nstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\r\nstruct tegra_xusb_padctl *padctl = port->padctl;\r\nstruct tegra_xusb_lane *lane = usb3->base.lane;\r\nunsigned int index = port->index, offset;\r\nint ret = 0;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\r\nif (!usb3->internal)\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\r\nelse\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(index);\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(index, usb3->port);\r\npadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\r\nvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_SHIFT));\r\nvalue |= (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_VAL <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_VAL <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_VAL <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_SHIFT);\r\nif (usb3->context_saved) {\r\nvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT));\r\nvalue |= (usb3->ctle_g <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\r\n(usb3->ctle_z <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT);\r\n}\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\r\nvalue = XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_VAL;\r\nif (usb3->context_saved) {\r\nvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_MASK <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT));\r\nvalue |= (usb3->tap1 <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\r\n(usb3->amp <<\r\nXUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT);\r\n}\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\r\nif (lane->pad == padctl->pcie)\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL2(lane->index);\r\nelse\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL2;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_MASK <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_SHIFT);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_VAL <<\r\nXUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_SHIFT;\r\npadctl_writel(padctl, value, offset);\r\nif (lane->pad == padctl->pcie)\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL5(lane->index);\r\nelse\r\noffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL5;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL5_RX_QEYE_EN;\r\npadctl_writel(padctl, value, offset);\r\nif (lane->pad == padctl->sata) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue &= ~(XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_MASK <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_SHIFT);\r\nvalue |= 0x2 <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL2);\r\nvalue &= ~((XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_MASK <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_MASK <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_SHIFT) |\r\n(XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_MASK <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_SHIFT) |\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_TCLKOUT_EN);\r\nvalue |= (0x7 <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_SHIFT) |\r\n(0x8 <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_SHIFT) |\r\n(0x8 <<\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_SHIFT) |\r\nXUSB_PADCTL_IOPHY_PLL_S0_CTL2_TXCLKREF_SEL;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL3);\r\nvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL3_RCAL_BYPASS;\r\npadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL3);\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_VCORE_DOWN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN_EARLY(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nreturn ret;\r\n}\r\nstatic void tegra124_usb3_port_disable(struct tegra_xusb_port *port)\r\n{\r\nstruct tegra_xusb_padctl *padctl = port->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN_EARLY(port->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN(port->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nusleep_range(250, 350);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_VCORE_DOWN(port->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(port->index);\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(port->index, 0x7);\r\npadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra124_usb3_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_port_find_lane(port, tegra124_usb3_map, "usb3-ss");\r\n}\r\nstatic int\r\ntegra124_xusb_read_fuse_calibration(struct tegra124_xusb_fuse_calibration *fuse)\r\n{\r\nunsigned int i;\r\nint err;\r\nu32 value;\r\nerr = tegra_fuse_readl(TEGRA_FUSE_SKU_CALIB_0, &value);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(fuse->hs_curr_level); i++) {\r\nfuse->hs_curr_level[i] =\r\n(value >> FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(i)) &\r\nFUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK;\r\n}\r\nfuse->hs_iref_cap =\r\n(value >> FUSE_SKU_CALIB_HS_IREF_CAP_SHIFT) &\r\nFUSE_SKU_CALIB_HS_IREF_CAP_MASK;\r\nfuse->hs_term_range_adj =\r\n(value >> FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT) &\r\nFUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK;\r\nfuse->hs_squelch_level =\r\n(value >> FUSE_SKU_CALIB_HS_SQUELCH_LEVEL_SHIFT) &\r\nFUSE_SKU_CALIB_HS_SQUELCH_LEVEL_MASK;\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_padctl *\r\ntegra124_xusb_padctl_probe(struct device *dev,\r\nconst struct tegra_xusb_padctl_soc *soc)\r\n{\r\nstruct tegra124_xusb_padctl *padctl;\r\nint err;\r\npadctl = devm_kzalloc(dev, sizeof(*padctl), GFP_KERNEL);\r\nif (!padctl)\r\nreturn ERR_PTR(-ENOMEM);\r\npadctl->base.dev = dev;\r\npadctl->base.soc = soc;\r\nerr = tegra124_xusb_read_fuse_calibration(&padctl->fuse);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn &padctl->base;\r\n}\r\nstatic void tegra124_xusb_padctl_remove(struct tegra_xusb_padctl *padctl)\r\n{\r\n}
