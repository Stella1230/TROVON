static struct sk_buff *brcm_tag_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nu8 *brcm_tag;\r\nif (skb_cow_head(skb, BRCM_TAG_LEN) < 0)\r\ngoto out_free;\r\nskb_push(skb, BRCM_TAG_LEN);\r\nmemmove(skb->data, skb->data + BRCM_TAG_LEN, 2 * ETH_ALEN);\r\nbrcm_tag = skb->data + 2 * ETH_ALEN;\r\nbrcm_tag[0] = (1 << BRCM_OPCODE_SHIFT) |\r\n((skb->priority << BRCM_IG_TC_SHIFT) & BRCM_IG_TC_MASK);\r\nbrcm_tag[1] = 0;\r\nbrcm_tag[2] = 0;\r\nif (p->port == 8)\r\nbrcm_tag[2] = BRCM_IG_DSTMAP2_MASK;\r\nbrcm_tag[3] = (1 << p->port) & BRCM_IG_DSTMAP1_MASK;\r\nreturn skb;\r\nout_free:\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nstatic int brcm_tag_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct dsa_switch_tree *dst = dev->dsa_ptr;\r\nstruct dsa_switch *ds;\r\nint source_port;\r\nu8 *brcm_tag;\r\nif (unlikely(dst == NULL))\r\ngoto out_drop;\r\nds = dst->ds[0];\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto out;\r\nif (unlikely(!pskb_may_pull(skb, BRCM_TAG_LEN)))\r\ngoto out_drop;\r\nbrcm_tag = skb->data - 2;\r\nif (unlikely((brcm_tag[0] >> BRCM_OPCODE_SHIFT) & BRCM_OPCODE_MASK))\r\ngoto out_drop;\r\nWARN_ON(brcm_tag[2] & BRCM_EG_RC_RSVD);\r\nsource_port = brcm_tag[3] & BRCM_EG_PID_MASK;\r\nif (source_port >= DSA_MAX_PORTS || !ds->ports[source_port].netdev)\r\ngoto out_drop;\r\nskb_pull_rcsum(skb, BRCM_TAG_LEN);\r\nmemmove(skb->data - ETH_HLEN,\r\nskb->data - ETH_HLEN - BRCM_TAG_LEN,\r\n2 * ETH_ALEN);\r\nskb_push(skb, ETH_HLEN);\r\nskb->pkt_type = PACKET_HOST;\r\nskb->dev = ds->ports[source_port].netdev;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nskb->dev->stats.rx_packets++;\r\nskb->dev->stats.rx_bytes += skb->len;\r\nnetif_receive_skb(skb);\r\nreturn 0;\r\nout_drop:\r\nkfree_skb(skb);\r\nout:\r\nreturn 0;\r\n}
