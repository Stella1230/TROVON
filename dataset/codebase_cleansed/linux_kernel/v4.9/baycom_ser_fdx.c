static inline void baycom_int_freq(struct baycom_state *bc)\r\n{\r\n#ifdef BAYCOM_DEBUG\r\nunsigned long cur_jiffies = jiffies;\r\nbc->debug_vals.cur_intcnt++;\r\nif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\r\nbc->debug_vals.last_jiffies = cur_jiffies;\r\nbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\r\nbc->debug_vals.cur_intcnt = 0;\r\nbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\r\nbc->debug_vals.cur_pllcorr = 0;\r\n}\r\n#endif\r\n}\r\nstatic inline void ser12_set_divisor(struct net_device *dev,\r\nunsigned int divisor)\r\n{\r\noutb(0x81, LCR(dev->base_addr));\r\noutb(divisor, DLL(dev->base_addr));\r\noutb(divisor >> 8, DLM(dev->base_addr));\r\noutb(0x01, LCR(dev->base_addr));\r\noutb(0x00, THR(dev->base_addr));\r\n}\r\nstatic __inline__ void ser12_rx(struct net_device *dev, struct baycom_state *bc, struct timespec64 *ts, unsigned char curs)\r\n{\r\nint timediff;\r\nint bdus8 = bc->baud_us >> 3;\r\nint bdus4 = bc->baud_us >> 2;\r\nint bdus2 = bc->baud_us >> 1;\r\ntimediff = 1000000 + ts->tv_nsec / NSEC_PER_USEC -\r\nbc->modem.ser12.pll_time;\r\nwhile (timediff >= 500000)\r\ntimediff -= 1000000;\r\nwhile (timediff >= bdus2) {\r\ntimediff -= bc->baud_us;\r\nbc->modem.ser12.pll_time += bc->baud_us;\r\nbc->modem.ser12.dcd_time--;\r\nif (bc->modem.shreg & 1) {\r\nhdlcdrv_putbits(&bc->hdrv, (bc->modem.shreg >> 1) ^ 0xffff);\r\nbc->modem.shreg = 0x10000;\r\n}\r\nbc->modem.shreg >>= 1;\r\n}\r\nif (bc->modem.ser12.dcd_time <= 0) {\r\nif (!bc->opt_dcd)\r\nhdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 +\r\nbc->modem.ser12.dcd_sum1 +\r\nbc->modem.ser12.dcd_sum2) < 0);\r\nbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\r\nbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\r\nbc->modem.ser12.dcd_sum0 = 2;\r\nbc->modem.ser12.dcd_time += 120;\r\n}\r\nif (bc->modem.ser12.last_rxbit != curs) {\r\nbc->modem.ser12.last_rxbit = curs;\r\nbc->modem.shreg |= 0x10000;\r\nif (timediff > 0)\r\nbc->modem.ser12.pll_time += bdus8;\r\nelse\r\nbc->modem.ser12.pll_time += 1000000 - bdus8;\r\nif (abs(timediff) > bdus4)\r\nbc->modem.ser12.dcd_sum0 += 4;\r\nelse\r\nbc->modem.ser12.dcd_sum0--;\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.cur_pllcorr = timediff;\r\n#endif\r\n}\r\nwhile (bc->modem.ser12.pll_time >= 1000000)\r\nbc->modem.ser12.pll_time -= 1000000;\r\n}\r\nstatic irqreturn_t ser12_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct timespec64 ts;\r\nunsigned char iir, msr;\r\nunsigned int txcount = 0;\r\nif (!bc || bc->hdrv.magic != HDLCDRV_MAGIC)\r\nreturn IRQ_NONE;\r\nif ((iir = inb(IIR(dev->base_addr))) & 1)\r\nreturn IRQ_NONE;\r\nktime_get_ts64(&ts);\r\nmsr = inb(MSR(dev->base_addr));\r\nif ((msr & 8) && bc->opt_dcd)\r\nhdlcdrv_setdcd(&bc->hdrv, !((msr ^ bc->opt_dcd) & 0x80));\r\ndo {\r\nswitch (iir & 6) {\r\ncase 6:\r\ninb(LSR(dev->base_addr));\r\nbreak;\r\ncase 4:\r\ninb(RBR(dev->base_addr));\r\nbreak;\r\ncase 2:\r\noutb(0x00, THR(dev->base_addr));\r\nbaycom_int_freq(bc);\r\ntxcount++;\r\nif (bc->modem.ptt)\r\noutb(0x0e | (!!bc->modem.ser12.tx_bit), MCR(dev->base_addr));\r\nelse\r\noutb(0x0d, MCR(dev->base_addr));\r\nbreak;\r\ndefault:\r\nmsr = inb(MSR(dev->base_addr));\r\nif ((msr & 8) && bc->opt_dcd)\r\nhdlcdrv_setdcd(&bc->hdrv, !((msr ^ bc->opt_dcd) & 0x80));\r\nbreak;\r\n}\r\niir = inb(IIR(dev->base_addr));\r\n} while (!(iir & 1));\r\nser12_rx(dev, bc, &ts, msr & 0x10);\r\nif (bc->modem.ptt && txcount) {\r\nif (bc->modem.ser12.txshreg <= 1) {\r\nbc->modem.ser12.txshreg = 0x10000 | hdlcdrv_getbits(&bc->hdrv);\r\nif (!hdlcdrv_ptt(&bc->hdrv)) {\r\nser12_set_divisor(dev, 115200/100/8);\r\nbc->modem.ptt = 0;\r\ngoto end_transmit;\r\n}\r\n}\r\nbc->modem.ser12.tx_bit = !(bc->modem.ser12.tx_bit ^ (bc->modem.ser12.txshreg & 1));\r\nbc->modem.ser12.txshreg >>= 1;\r\n}\r\nend_transmit:\r\nlocal_irq_enable();\r\nif (!bc->modem.ptt && txcount) {\r\nhdlcdrv_arbitrate(dev, &bc->hdrv);\r\nif (hdlcdrv_ptt(&bc->hdrv)) {\r\nser12_set_divisor(dev, bc->baud_uartdiv);\r\nbc->modem.ser12.txshreg = 1;\r\nbc->modem.ptt = 1;\r\n}\r\n}\r\nhdlcdrv_transmitter(dev, &bc->hdrv);\r\nhdlcdrv_receiver(dev, &bc->hdrv);\r\nlocal_irq_disable();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum uart ser12_check_uart(unsigned int iobase)\r\n{\r\nunsigned char b1,b2,b3;\r\nenum uart u;\r\nenum uart uart_tab[] =\r\n{ c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A };\r\nb1 = inb(MCR(iobase));\r\noutb(b1 | 0x10, MCR(iobase));\r\nb2 = inb(MSR(iobase));\r\noutb(0x1a, MCR(iobase));\r\nb3 = inb(MSR(iobase)) & 0xf0;\r\noutb(b1, MCR(iobase));\r\noutb(b2, MSR(iobase));\r\nif (b3 != 0x90)\r\nreturn c_uart_unknown;\r\ninb(RBR(iobase));\r\ninb(RBR(iobase));\r\noutb(0x01, FCR(iobase));\r\nu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\r\nif (u == c_uart_16450) {\r\noutb(0x5a, SCR(iobase));\r\nb1 = inb(SCR(iobase));\r\noutb(0xa5, SCR(iobase));\r\nb2 = inb(SCR(iobase));\r\nif ((b1 != 0x5a) || (b2 != 0xa5))\r\nu = c_uart_8250;\r\n}\r\nreturn u;\r\n}\r\nstatic int ser12_open(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nenum uart u;\r\nif (!dev || !bc)\r\nreturn -ENXIO;\r\nif (!dev->base_addr || dev->base_addr > 0xffff-SER12_EXTENT ||\r\ndev->irq < 2 || dev->irq > nr_irqs) {\r\nprintk(KERN_INFO "baycom_ser_fdx: invalid portnumber (max %u) "\r\n"or irq (2 <= irq <= %d)\n",\r\n0xffff-SER12_EXTENT, nr_irqs);\r\nreturn -ENXIO;\r\n}\r\nif (bc->baud < 300 || bc->baud > 4800) {\r\nprintk(KERN_INFO "baycom_ser_fdx: invalid baudrate "\r\n"(300...4800)\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(dev->base_addr, SER12_EXTENT, "baycom_ser_fdx")) {\r\nprintk(KERN_WARNING "BAYCOM_SER_FSX: I/O port 0x%04lx busy\n",\r\ndev->base_addr);\r\nreturn -EACCES;\r\n}\r\nmemset(&bc->modem, 0, sizeof(bc->modem));\r\nbc->hdrv.par.bitrate = bc->baud;\r\nbc->baud_us = 1000000/bc->baud;\r\nbc->baud_uartdiv = (115200/8)/bc->baud;\r\nif ((u = ser12_check_uart(dev->base_addr)) == c_uart_unknown){\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nreturn -EIO;\r\n}\r\noutb(0, FCR(dev->base_addr));\r\noutb(0x0d, MCR(dev->base_addr));\r\noutb(0, IER(dev->base_addr));\r\nif (request_irq(dev->irq, ser12_interrupt, IRQF_SHARED,\r\n"baycom_ser_fdx", dev)) {\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nser12_set_divisor(dev, 115200/100/8);\r\noutb(0x0a, IER(dev->base_addr));\r\noutb(0x00, THR(dev->base_addr));\r\nhdlcdrv_setdcd(&bc->hdrv, 0);\r\nprintk(KERN_INFO "%s: ser_fdx at iobase 0x%lx irq %u baud %u uart %s\n",\r\nbc_drvname, dev->base_addr, dev->irq, bc->baud, uart_str[u]);\r\nreturn 0;\r\n}\r\nstatic int ser12_close(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nif (!dev || !bc)\r\nreturn -EINVAL;\r\noutb(0, IER(dev->base_addr));\r\noutb(1, MCR(dev->base_addr));\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nprintk(KERN_INFO "%s: close ser_fdx at iobase 0x%lx irq %u\n",\r\nbc_drvname, dev->base_addr, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\r\n{\r\nunsigned int baud;\r\nif (!strncmp(modestr, "ser", 3)) {\r\nbaud = simple_strtoul(modestr+3, NULL, 10);\r\nif (baud >= 3 && baud <= 48)\r\nbc->baud = baud*100;\r\n}\r\nif (strchr(modestr, '*'))\r\nbc->opt_dcd = 0;\r\nelse if (strchr(modestr, '+'))\r\nbc->opt_dcd = -1;\r\nelse\r\nbc->opt_dcd = 1;\r\nreturn 0;\r\n}\r\nstatic int baycom_ioctl(struct net_device *dev, struct ifreq *ifr,\r\nstruct hdlcdrv_ioctl *hi, int cmd)\r\n{\r\nstruct baycom_state *bc;\r\nstruct baycom_ioctl bi;\r\nif (!dev)\r\nreturn -EINVAL;\r\nbc = netdev_priv(dev);\r\nBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\r\nif (cmd != SIOCDEVPRIVATE)\r\nreturn -ENOIOCTLCMD;\r\nswitch (hi->cmd) {\r\ndefault:\r\nbreak;\r\ncase HDLCDRVCTL_GETMODE:\r\nsprintf(hi->data.modename, "ser%u", bc->baud / 100);\r\nif (bc->opt_dcd <= 0)\r\nstrcat(hi->data.modename, (!bc->opt_dcd) ? "*" : "+");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_SETMODE:\r\nif (netif_running(dev) || !capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nhi->data.modename[sizeof(hi->data.modename)-1] = '\0';\r\nreturn baycom_setmode(bc, hi->data.modename);\r\ncase HDLCDRVCTL_MODELIST:\r\nstrcpy(hi->data.modename, "ser12,ser3,ser24");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_MODEMPARMASK:\r\nreturn HDLCDRV_PARMASK_IOBASE | HDLCDRV_PARMASK_IRQ;\r\n}\r\nif (copy_from_user(&bi, ifr->ifr_data, sizeof(bi)))\r\nreturn -EFAULT;\r\nswitch (bi.cmd) {\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n#ifdef BAYCOM_DEBUG\r\ncase BAYCOMCTL_GETDEBUG:\r\nbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\r\nbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\r\nbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\r\nbreak;\r\n#endif\r\n}\r\nif (copy_to_user(ifr->ifr_data, &bi, sizeof(bi)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int __init init_baycomserfdx(void)\r\n{\r\nint i, found = 0;\r\nchar set_hw = 1;\r\nprintk(bc_drvinfo);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev;\r\nstruct baycom_state *bc;\r\nchar ifname[IFNAMSIZ];\r\nsprintf(ifname, "bcsf%d", i);\r\nif (!mode[i])\r\nset_hw = 0;\r\nif (!set_hw)\r\niobase[i] = irq[i] = 0;\r\ndev = hdlcdrv_register(&ser12_ops,\r\nsizeof(struct baycom_state),\r\nifname, iobase[i], irq[i], 0);\r\nif (IS_ERR(dev))\r\nbreak;\r\nbc = netdev_priv(dev);\r\nif (set_hw && baycom_setmode(bc, mode[i]))\r\nset_hw = 0;\r\nbc->baud = baud[i];\r\nfound++;\r\nbaycom_device[i] = dev;\r\n}\r\nif (!found)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_baycomserfdx(void)\r\n{\r\nint i;\r\nfor(i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = baycom_device[i];\r\nif (dev)\r\nhdlcdrv_unregister(dev);\r\n}\r\n}\r\nstatic int __init baycom_ser_fdx_setup(char *str)\r\n{\r\nstatic unsigned nr_dev;\r\nint ints[4];\r\nif (nr_dev >= NR_PORTS)\r\nreturn 0;\r\nstr = get_options(str, 4, ints);\r\nif (ints[0] < 2)\r\nreturn 0;\r\nmode[nr_dev] = str;\r\niobase[nr_dev] = ints[1];\r\nirq[nr_dev] = ints[2];\r\nif (ints[0] >= 3)\r\nbaud[nr_dev] = ints[3];\r\nnr_dev++;\r\nreturn 1;\r\n}
