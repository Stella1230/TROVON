static inline int __is_running(const struct exynos_mipi_phy_desc *data,\r\nstruct exynos_mipi_video_phy *state)\r\n{\r\nu32 val;\r\nint ret;\r\nret = regmap_read(state->regmaps[data->resetn_map], data->resetn_reg, &val);\r\nif (ret)\r\nreturn 0;\r\nreturn val & data->resetn_val;\r\n}\r\nstatic int __set_phy_state(const struct exynos_mipi_phy_desc *data,\r\nstruct exynos_mipi_video_phy *state, unsigned int on)\r\n{\r\nu32 val;\r\nspin_lock(&state->slock);\r\nif (!on && data->coupled_phy_id >= 0 &&\r\n!__is_running(state->phys[data->coupled_phy_id].data, state)) {\r\nregmap_read(state->regmaps[data->enable_map], data->enable_reg,\r\n&val);\r\nval &= ~data->enable_val;\r\nregmap_write(state->regmaps[data->enable_map], data->enable_reg,\r\nval);\r\n}\r\nregmap_read(state->regmaps[data->resetn_map], data->resetn_reg, &val);\r\nval = on ? (val | data->resetn_val) : (val & ~data->resetn_val);\r\nregmap_write(state->regmaps[data->resetn_map], data->resetn_reg, val);\r\nif (on) {\r\nregmap_read(state->regmaps[data->enable_map], data->enable_reg,\r\n&val);\r\nval |= data->enable_val;\r\nregmap_write(state->regmaps[data->enable_map], data->enable_reg,\r\nval);\r\n}\r\nspin_unlock(&state->slock);\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_video_phy_power_on(struct phy *phy)\r\n{\r\nstruct video_phy_desc *phy_desc = phy_get_drvdata(phy);\r\nstruct exynos_mipi_video_phy *state = to_mipi_video_phy(phy_desc);\r\nreturn __set_phy_state(phy_desc->data, state, 1);\r\n}\r\nstatic int exynos_mipi_video_phy_power_off(struct phy *phy)\r\n{\r\nstruct video_phy_desc *phy_desc = phy_get_drvdata(phy);\r\nstruct exynos_mipi_video_phy *state = to_mipi_video_phy(phy_desc);\r\nreturn __set_phy_state(phy_desc->data, state, 0);\r\n}\r\nstatic struct phy *exynos_mipi_video_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct exynos_mipi_video_phy *state = dev_get_drvdata(dev);\r\nif (WARN_ON(args->args[0] >= state->num_phys))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn state->phys[args->args[0]].phy;\r\n}\r\nstatic int exynos_mipi_video_phy_probe(struct platform_device *pdev)\r\n{\r\nconst struct mipi_phy_device_desc *phy_dev;\r\nstruct exynos_mipi_video_phy *state;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct phy_provider *phy_provider;\r\nunsigned int i;\r\nphy_dev = of_device_get_match_data(dev);\r\nif (!phy_dev)\r\nreturn -ENODEV;\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < phy_dev->num_regmaps; i++) {\r\nstate->regmaps[i] = syscon_regmap_lookup_by_phandle(np,\r\nphy_dev->regmap_names[i]);\r\nif (IS_ERR(state->regmaps[i]))\r\nreturn PTR_ERR(state->regmaps[i]);\r\n}\r\nstate->num_phys = phy_dev->num_phys;\r\nspin_lock_init(&state->slock);\r\ndev_set_drvdata(dev, state);\r\nfor (i = 0; i < state->num_phys; i++) {\r\nstruct phy *phy = devm_phy_create(dev, NULL,\r\n&exynos_mipi_video_phy_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create PHY %d\n", i);\r\nreturn PTR_ERR(phy);\r\n}\r\nstate->phys[i].phy = phy;\r\nstate->phys[i].index = i;\r\nstate->phys[i].data = &phy_dev->phys[i];\r\nphy_set_drvdata(phy, &state->phys[i]);\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nexynos_mipi_video_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
