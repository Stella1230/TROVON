static int calc_freq(struct spu_gov_info_struct *info)\r\n{\r\nint cpu;\r\nint busy_spus;\r\ncpu = info->policy->cpu;\r\nbusy_spus = atomic_read(&cbe_spu_info[cpu_to_node(cpu)].busy_spus);\r\nCALC_LOAD(info->busy_spus, EXP, busy_spus * FIXED_1);\r\npr_debug("cpu %d: busy_spus=%d, info->busy_spus=%ld\n",\r\ncpu, busy_spus, info->busy_spus);\r\nreturn info->policy->max * info->busy_spus / FIXED_1;\r\n}\r\nstatic void spu_gov_work(struct work_struct *work)\r\n{\r\nstruct spu_gov_info_struct *info;\r\nint delay;\r\nunsigned long target_freq;\r\ninfo = container_of(work, struct spu_gov_info_struct, work.work);\r\nBUG_ON(info->policy == NULL);\r\ntarget_freq = calc_freq(info);\r\n__cpufreq_driver_target(info->policy, target_freq, CPUFREQ_RELATION_H);\r\ndelay = usecs_to_jiffies(info->poll_int);\r\nschedule_delayed_work_on(info->policy->cpu, &info->work, delay);\r\n}\r\nstatic void spu_gov_init_work(struct spu_gov_info_struct *info)\r\n{\r\nint delay = usecs_to_jiffies(info->poll_int);\r\nINIT_DEFERRABLE_WORK(&info->work, spu_gov_work);\r\nschedule_delayed_work_on(info->policy->cpu, &info->work, delay);\r\n}\r\nstatic void spu_gov_cancel_work(struct spu_gov_info_struct *info)\r\n{\r\ncancel_delayed_work_sync(&info->work);\r\n}\r\nstatic int spu_gov_start(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct spu_gov_info_struct *info = &per_cpu(spu_gov_info, cpu);\r\nstruct spu_gov_info_struct *affected_info;\r\nint i;\r\nif (!cpu_online(cpu)) {\r\nprintk(KERN_ERR "cpu %d is not online\n", cpu);\r\nreturn -EINVAL;\r\n}\r\nif (!policy->cur) {\r\nprintk(KERN_ERR "no cpu specified in policy\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_cpu(i, policy->cpus) {\r\naffected_info = &per_cpu(spu_gov_info, i);\r\naffected_info->policy = policy;\r\n}\r\ninfo->poll_int = POLL_TIME;\r\nspu_gov_init_work(info);\r\nreturn 0;\r\n}\r\nstatic void spu_gov_stop(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct spu_gov_info_struct *info = &per_cpu(spu_gov_info, cpu);\r\nint i;\r\nspu_gov_cancel_work(info);\r\nfor_each_cpu (i, policy->cpus) {\r\ninfo = &per_cpu(spu_gov_info, i);\r\ninfo->policy = NULL;\r\n}\r\n}\r\nstatic int __init spu_gov_init(void)\r\n{\r\nint ret;\r\nret = cpufreq_register_governor(&spu_governor);\r\nif (ret)\r\nprintk(KERN_ERR "registration of governor failed\n");\r\nreturn ret;\r\n}\r\nstatic void __exit spu_gov_exit(void)\r\n{\r\ncpufreq_unregister_governor(&spu_governor);\r\n}
