static void sata_clear_glue_reg(u64 regbase, u32 off, u32 bit)\r\n{\r\nu32 reg_val;\r\nreg_val = nlm_read_sata_reg(regbase, off);\r\nnlm_write_sata_reg(regbase, off, (reg_val & ~bit));\r\n}\r\nstatic void sata_set_glue_reg(u64 regbase, u32 off, u32 bit)\r\n{\r\nu32 reg_val;\r\nreg_val = nlm_read_sata_reg(regbase, off);\r\nnlm_write_sata_reg(regbase, off, (reg_val | bit));\r\n}\r\nstatic void write_phy_reg(u64 regbase, u32 addr, u32 physel, u8 data)\r\n{\r\nnlm_write_sata_reg(regbase, PHY_MEM_ACCESS,\r\n(1u << 31) | (physel << 24) | (data << 16) | addr);\r\nudelay(850);\r\n}\r\nstatic u8 read_phy_reg(u64 regbase, u32 addr, u32 physel)\r\n{\r\nu32 val;\r\nnlm_write_sata_reg(regbase, PHY_MEM_ACCESS,\r\n(0 << 31) | (physel << 24) | (0 << 16) | addr);\r\nudelay(850);\r\nval = nlm_read_sata_reg(regbase, PHY_MEM_ACCESS);\r\nreturn (val >> 16) & 0xff;\r\n}\r\nstatic void config_sata_phy(u64 regbase)\r\n{\r\nu32 port, i, reg;\r\nu8 val;\r\nfor (port = 0; port < 2; port++) {\r\nfor (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)\r\nwrite_phy_reg(regbase, reg, port, sata_phy_config1[i]);\r\nfor (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)\r\nwrite_phy_reg(regbase, reg, port, sata_phy_config2[i]);\r\nwrite_phy_reg(regbase, 0x800F, port, 0x1f);\r\nval = read_phy_reg(regbase, 0x0029, port);\r\nwrite_phy_reg(regbase, 0x0029, port, val | (0x7 << 1));\r\nval = read_phy_reg(regbase, 0x0056, port);\r\nwrite_phy_reg(regbase, 0x0056, port, val & ~(1 << 3));\r\nval = read_phy_reg(regbase, 0x0018, port);\r\nwrite_phy_reg(regbase, 0x0018, port, val & ~(0x7 << 0));\r\n}\r\n}\r\nstatic void check_phy_register(u64 regbase, u32 addr, u32 physel, u8 xdata)\r\n{\r\nu8 data;\r\ndata = read_phy_reg(regbase, addr, physel);\r\npr_info("PHY read addr = 0x%x physel = %d data = 0x%x %s\n",\r\naddr, physel, data, data == xdata ? "TRUE" : "FALSE");\r\n}\r\nstatic void verify_sata_phy_config(u64 regbase)\r\n{\r\nu32 port, i, reg;\r\nfor (port = 0; port < 2; port++) {\r\nfor (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)\r\ncheck_phy_register(regbase, reg, port,\r\nsata_phy_config1[i]);\r\nfor (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)\r\ncheck_phy_register(regbase, reg, port,\r\nsata_phy_config2[i]);\r\n}\r\n}\r\nstatic void nlm_sata_firmware_init(int node)\r\n{\r\nu32 reg_val;\r\nu64 regbase;\r\nint n;\r\npr_info("Initializing XLP9XX On-chip AHCI...\n");\r\nregbase = nlm_get_sata_regbase(node);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_POR);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_TXRX);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_SYNTH);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IPDTXL);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IPDRXL);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P0_IPDIPDMSYNTH);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_POR);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_TXRX);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_SYNTH);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IPDTXL);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IPDRXL);\r\nsata_clear_glue_reg(regbase, SATA_CTL, P1_IPDIPDMSYNTH);\r\nudelay(300);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IPDTXL);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IPDRXL);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IPDIPDMSYNTH);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IPDTXL);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IPDRXL);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IPDIPDMSYNTH);\r\nudelay(1000);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IRST_POR);\r\nudelay(1000);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IRST_POR);\r\nudelay(1000);\r\nconfig_sata_phy(regbase);\r\nif (sata_phy_debug)\r\nverify_sata_phy_config(regbase);\r\nudelay(1000);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_TXRX);\r\nsata_set_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_SYNTH);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_TXRX);\r\nsata_set_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_SYNTH);\r\nudelay(300);\r\nsata_set_glue_reg(regbase, CR_REG_TIMER, CR_TIME_SCALE);\r\nsata_set_glue_reg(regbase, SATA_CTL, SATA_RST_N);\r\nsata_set_glue_reg(regbase, SATA_CTL, M_CSYSREQ);\r\nsata_set_glue_reg(regbase, SATA_CTL, S_CSYSREQ);\r\npr_debug("Waiting for PHYs to come up.\n");\r\nn = 10000;\r\ndo {\r\nreg_val = nlm_read_sata_reg(regbase, SATA_STATUS);\r\nif ((reg_val & P1_PHY_READY) && (reg_val & P0_PHY_READY))\r\nbreak;\r\nudelay(10);\r\n} while (--n > 0);\r\nif (reg_val & P0_PHY_READY)\r\npr_info("PHY0 is up.\n");\r\nelse\r\npr_info("PHY0 is down.\n");\r\nif (reg_val & P1_PHY_READY)\r\npr_info("PHY1 is up.\n");\r\nelse\r\npr_info("PHY1 is down.\n");\r\npr_info("XLP AHCI Init Done.\n");\r\n}\r\nstatic int __init nlm_ahci_init(void)\r\n{\r\nint node;\r\nif (!cpu_is_xlp9xx())\r\nreturn 0;\r\nfor (node = 0; node < NLM_NR_NODES; node++)\r\nif (nlm_node_present(node))\r\nnlm_sata_firmware_init(node);\r\nreturn 0;\r\n}\r\nstatic void nlm_sata_intr_ack(struct irq_data *data)\r\n{\r\nu64 regbase;\r\nu32 val;\r\nint node;\r\nnode = data->irq / NLM_IRQS_PER_NODE;\r\nregbase = nlm_get_sata_regbase(node);\r\nval = nlm_read_sata_reg(regbase, SATA_INT);\r\nsata_set_glue_reg(regbase, SATA_INT, val);\r\n}\r\nstatic void nlm_sata_fixup_bar(struct pci_dev *dev)\r\n{\r\ndev->resource[5] = dev->resource[0];\r\nmemset(&dev->resource[0], 0, sizeof(dev->resource[0]));\r\n}\r\nstatic void nlm_sata_fixup_final(struct pci_dev *dev)\r\n{\r\nu32 val;\r\nu64 regbase;\r\nint node;\r\nnode = xlp_socdev_to_node(dev);\r\nregbase = nlm_get_sata_regbase(node);\r\nval = nlm_read_sata_reg(regbase, SATA_INT);\r\nsata_set_glue_reg(regbase, SATA_INT, val);\r\nsata_set_glue_reg(regbase, SATA_INT_MASK, 0x1);\r\ndev->irq = nlm_irq_to_xirq(node, PIC_SATA_IRQ);\r\nnlm_set_pic_extra_ack(node, PIC_SATA_IRQ, nlm_sata_intr_ack);\r\n}
