static int sun3_82586_close(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nsun3_reset586();\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sun3_82586_open(struct net_device *dev)\r\n{\r\nint ret;\r\nsun3_disint();\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\nsun3_enaint();\r\nret = request_irq(dev->irq, sun3_82586_interrupt,0,dev->name,dev);\r\nif (ret)\r\n{\r\nsun3_reset586();\r\nreturn ret;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int check586(struct net_device *dev,char *where,unsigned size)\r\n{\r\nstruct priv pb;\r\nstruct priv *p = &pb;\r\nchar *iscp_addr;\r\nint i;\r\np->base = (unsigned long) dvma_btov(0);\r\np->memtop = (char *)dvma_btov((unsigned long)where);\r\np->scp = (struct scp_struct *)(p->base + SCP_DEFAULT_ADDRESS);\r\nmemset((char *)p->scp,0, sizeof(struct scp_struct));\r\nfor(i=0;i<sizeof(struct scp_struct);i++)\r\nif(((char *)p->scp)[i])\r\nreturn 0;\r\np->scp->sysbus = SYSBUSVAL;\r\nif(p->scp->sysbus != SYSBUSVAL)\r\nreturn 0;\r\niscp_addr = (char *)dvma_btov((unsigned long)where);\r\np->iscp = (struct iscp_struct *) iscp_addr;\r\nmemset((char *)p->iscp,0, sizeof(struct iscp_struct));\r\np->scp->iscp = make24(p->iscp);\r\np->iscp->busy = 1;\r\nsun3_reset586();\r\nsun3_attn586();\r\nDELAY(1);\r\nif(p->iscp->busy)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void alloc586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nsun3_reset586();\r\nDELAY(1);\r\np->scp = (struct scp_struct *) (p->base + SCP_DEFAULT_ADDRESS);\r\np->iscp = (struct iscp_struct *) dvma_btov(dev->mem_start);\r\np->scb = (struct scb_struct *) ((char *)p->iscp + sizeof(struct iscp_struct));\r\nmemset((char *) p->iscp,0,sizeof(struct iscp_struct));\r\nmemset((char *) p->scp ,0,sizeof(struct scp_struct));\r\np->scp->iscp = make24(p->iscp);\r\np->scp->sysbus = SYSBUSVAL;\r\np->iscp->scb_offset = make16(p->scb);\r\np->iscp->scb_base = make24(dvma_btov(dev->mem_start));\r\np->iscp->busy = 1;\r\nsun3_reset586();\r\nsun3_attn586();\r\nDELAY(1);\r\nif(p->iscp->busy)\r\nprintk("%s: Init-Problems (alloc).\n",dev->name);\r\np->reseted = 0;\r\nmemset((char *)p->scb,0,sizeof(struct scb_struct));\r\n}\r\nstruct net_device * __init sun3_82586_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nunsigned long ioaddr;\r\nstatic int found = 0;\r\nint err = -ENOMEM;\r\nswitch(idprom->id_machtype) {\r\ncase SM_SUN3|SM_3_160:\r\ncase SM_SUN3|SM_3_260:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (found)\r\nreturn ERR_PTR(-ENODEV);\r\nioaddr = (unsigned long)ioremap(IE_OBIO, SUN3_82586_TOTAL_SIZE);\r\nif (!ioaddr)\r\nreturn ERR_PTR(-ENOMEM);\r\nfound = 1;\r\ndev = alloc_etherdev(sizeof(struct priv));\r\nif (!dev)\r\ngoto out;\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\ndev->irq = IE_IRQ;\r\ndev->base_addr = ioaddr;\r\nerr = sun3_82586_probe1(dev, ioaddr);\r\nif (err)\r\ngoto out1;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out2;\r\nreturn dev;\r\nout2:\r\nrelease_region(ioaddr, SUN3_82586_TOTAL_SIZE);\r\nout1:\r\nfree_netdev(dev);\r\nout:\r\niounmap((void __iomem *)ioaddr);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init sun3_82586_probe1(struct net_device *dev,int ioaddr)\r\n{\r\nint i, size, retval;\r\nif (!request_region(ioaddr, SUN3_82586_TOTAL_SIZE, DRV_NAME))\r\nreturn -EBUSY;\r\nfor(i = 0; i < 6 ; i++)\r\ndev->dev_addr[i] = idprom->id_ethaddr[i];\r\nprintk("%s: SUN3 Intel 82586 found at %lx, ",dev->name,dev->base_addr);\r\nsize = 0x8000;\r\ndev->mem_start = (unsigned long)dvma_malloc_align(0x8000, 0x1000);\r\ndev->mem_end = dev->mem_start + size;\r\nif(size != 0x2000 && size != 0x4000 && size != 0x8000) {\r\nprintk("\n%s: Illegal memory size %d. Allowed is 0x2000 or 0x4000 or 0x8000 bytes.\n",dev->name,size);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif(!check586(dev,(char *) dev->mem_start,size)) {\r\nprintk("?memcheck, Can't find memory at 0x%lx with size %d!\n",dev->mem_start,size);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\n((struct priv *)netdev_priv(dev))->memtop =\r\n(char *)dvma_btov(dev->mem_start);\r\n((struct priv *)netdev_priv(dev))->base = (unsigned long) dvma_btov(0);\r\nalloc586(dev);\r\nif(size == 0x2000)\r\n((struct priv *)netdev_priv(dev))->num_recv_buffs =\r\nNUM_RECV_BUFFS_8;\r\nelse if(size == 0x4000)\r\n((struct priv *)netdev_priv(dev))->num_recv_buffs =\r\nNUM_RECV_BUFFS_16;\r\nelse\r\n((struct priv *)netdev_priv(dev))->num_recv_buffs =\r\nNUM_RECV_BUFFS_32;\r\nprintk("Memaddr: 0x%lx, Memsize: %d, IRQ %d\n",dev->mem_start,size, dev->irq);\r\ndev->netdev_ops = &sun3_82586_netdev_ops;\r\ndev->watchdog_timeo = HZ/20;\r\ndev->if_port = 0;\r\nreturn 0;\r\nout:\r\nrelease_region(ioaddr, SUN3_82586_TOTAL_SIZE);\r\nreturn retval;\r\n}\r\nstatic int init586(struct net_device *dev)\r\n{\r\nvoid *ptr;\r\nint i,result=0;\r\nstruct priv *p = netdev_priv(dev);\r\nvolatile struct configure_cmd_struct *cfg_cmd;\r\nvolatile struct iasetup_cmd_struct *ias_cmd;\r\nvolatile struct tdr_cmd_struct *tdr_cmd;\r\nvolatile struct mcsetup_cmd_struct *mc_cmd;\r\nstruct netdev_hw_addr *ha;\r\nint num_addrs=netdev_mc_count(dev);\r\nptr = (void *) ((char *)p->scb + sizeof(struct scb_struct));\r\ncfg_cmd = (struct configure_cmd_struct *)ptr;\r\ncfg_cmd->cmd_status = 0;\r\ncfg_cmd->cmd_cmd = swab16(CMD_CONFIGURE | CMD_LAST);\r\ncfg_cmd->cmd_link = 0xffff;\r\ncfg_cmd->byte_cnt = 0x0a;\r\ncfg_cmd->fifo = fifo;\r\ncfg_cmd->sav_bf = 0x40;\r\ncfg_cmd->adr_len = 0x2e;\r\ncfg_cmd->priority = 0x00;\r\ncfg_cmd->ifs = 0x60;\r\ncfg_cmd->time_low = 0x00;\r\ncfg_cmd->time_high = 0xf2;\r\ncfg_cmd->promisc = 0;\r\nif(dev->flags & IFF_ALLMULTI) {\r\nint len = ((char *) p->iscp - (char *) ptr - 8) / 6;\r\nif(num_addrs > len) {\r\nprintk("%s: switching to promisc. mode\n",dev->name);\r\ncfg_cmd->promisc = 1;\r\n}\r\n}\r\nif(dev->flags&IFF_PROMISC)\r\ncfg_cmd->promisc = 1;\r\ncfg_cmd->carr_coll = 0x00;\r\np->scb->cbl_offset = make16(cfg_cmd);\r\np->scb->cmd_ruc = 0;\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_STAT_COMPL(cfg_cmd);\r\nif((swab16(cfg_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) != (STAT_COMPL|STAT_OK))\r\n{\r\nprintk("%s: configure command failed: %x\n",dev->name,swab16(cfg_cmd->cmd_status));\r\nreturn 1;\r\n}\r\nias_cmd = (struct iasetup_cmd_struct *)ptr;\r\nias_cmd->cmd_status = 0;\r\nias_cmd->cmd_cmd = swab16(CMD_IASETUP | CMD_LAST);\r\nias_cmd->cmd_link = 0xffff;\r\nmemcpy((char *)&ias_cmd->iaddr,(char *) dev->dev_addr,ETH_ALEN);\r\np->scb->cbl_offset = make16(ias_cmd);\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_STAT_COMPL(ias_cmd);\r\nif((swab16(ias_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) != (STAT_OK|STAT_COMPL)) {\r\nprintk("%s (82586): individual address setup command failed: %04x\n",dev->name,swab16(ias_cmd->cmd_status));\r\nreturn 1;\r\n}\r\ntdr_cmd = (struct tdr_cmd_struct *)ptr;\r\ntdr_cmd->cmd_status = 0;\r\ntdr_cmd->cmd_cmd = swab16(CMD_TDR | CMD_LAST);\r\ntdr_cmd->cmd_link = 0xffff;\r\ntdr_cmd->status = 0;\r\np->scb->cbl_offset = make16(tdr_cmd);\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_STAT_COMPL(tdr_cmd);\r\nif(!(swab16(tdr_cmd->cmd_status) & STAT_COMPL))\r\n{\r\nprintk("%s: Problems while running the TDR.\n",dev->name);\r\n}\r\nelse\r\n{\r\nDELAY_16();\r\nresult = swab16(tdr_cmd->status);\r\np->scb->cmd_cuc = p->scb->cus & STAT_MASK;\r\nsun3_attn586();\r\nif(result & TDR_LNK_OK)\r\n;\r\nelse if(result & TDR_XCVR_PRB)\r\nprintk("%s: TDR: Transceiver problem. Check the cable(s)!\n",dev->name);\r\nelse if(result & TDR_ET_OPN)\r\nprintk("%s: TDR: No correct termination %d clocks away.\n",dev->name,result & TDR_TIMEMASK);\r\nelse if(result & TDR_ET_SRT)\r\n{\r\nif (result & TDR_TIMEMASK)\r\nprintk("%s: TDR: Detected a short circuit %d clocks away.\n",dev->name,result & TDR_TIMEMASK);\r\n}\r\nelse\r\nprintk("%s: TDR: Unknown status %04x\n",dev->name,result);\r\n}\r\nif(num_addrs && !(dev->flags & IFF_PROMISC) )\r\n{\r\nmc_cmd = (struct mcsetup_cmd_struct *) ptr;\r\nmc_cmd->cmd_status = 0;\r\nmc_cmd->cmd_cmd = swab16(CMD_MCSETUP | CMD_LAST);\r\nmc_cmd->cmd_link = 0xffff;\r\nmc_cmd->mc_cnt = swab16(num_addrs * 6);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy((char *) mc_cmd->mc_list[i++],\r\nha->addr, ETH_ALEN);\r\np->scb->cbl_offset = make16(mc_cmd);\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_STAT_COMPL(mc_cmd);\r\nif( (swab16(mc_cmd->cmd_status) & (STAT_COMPL|STAT_OK)) != (STAT_COMPL|STAT_OK) )\r\nprintk("%s: Can't apply multicast-address-list.\n",dev->name);\r\n}\r\n#if (NUM_XMIT_BUFFS == 1)\r\nfor(i=0;i<2;i++)\r\n{\r\np->nop_cmds[i] = (struct nop_cmd_struct *)ptr;\r\np->nop_cmds[i]->cmd_cmd = swab16(CMD_NOP);\r\np->nop_cmds[i]->cmd_status = 0;\r\np->nop_cmds[i]->cmd_link = make16((p->nop_cmds[i]));\r\nptr = (char *) ptr + sizeof(struct nop_cmd_struct);\r\n}\r\n#else\r\nfor(i=0;i<NUM_XMIT_BUFFS;i++)\r\n{\r\np->nop_cmds[i] = (struct nop_cmd_struct *)ptr;\r\np->nop_cmds[i]->cmd_cmd = swab16(CMD_NOP);\r\np->nop_cmds[i]->cmd_status = 0;\r\np->nop_cmds[i]->cmd_link = make16((p->nop_cmds[i]));\r\nptr = (char *) ptr + sizeof(struct nop_cmd_struct);\r\n}\r\n#endif\r\nptr = alloc_rfa(dev,ptr);\r\nfor(i=0;i<NUM_XMIT_BUFFS;i++)\r\n{\r\np->xmit_cmds[i] = (struct transmit_cmd_struct *)ptr;\r\nptr = (char *) ptr + sizeof(struct transmit_cmd_struct);\r\np->xmit_cbuffs[i] = (char *)ptr;\r\nptr = (char *) ptr + XMIT_BUFF_SIZE;\r\np->xmit_buffs[i] = (struct tbd_struct *)ptr;\r\nptr = (char *) ptr + sizeof(struct tbd_struct);\r\nif(ptr > (void *)dev->mem_end)\r\n{\r\nprintk("%s: not enough shared-mem for your configuration!\n",dev->name);\r\nreturn 1;\r\n}\r\nmemset((char *)(p->xmit_cmds[i]) ,0, sizeof(struct transmit_cmd_struct));\r\nmemset((char *)(p->xmit_buffs[i]),0, sizeof(struct tbd_struct));\r\np->xmit_cmds[i]->cmd_link = make16(p->nop_cmds[(i+1)%NUM_XMIT_BUFFS]);\r\np->xmit_cmds[i]->cmd_status = swab16(STAT_COMPL);\r\np->xmit_cmds[i]->cmd_cmd = swab16(CMD_XMIT | CMD_INT);\r\np->xmit_cmds[i]->tbd_offset = make16((p->xmit_buffs[i]));\r\np->xmit_buffs[i]->next = 0xffff;\r\np->xmit_buffs[i]->buffer = make24((p->xmit_cbuffs[i]));\r\n}\r\np->xmit_count = 0;\r\np->xmit_last = 0;\r\n#ifndef NO_NOPCOMMANDS\r\np->nop_point = 0;\r\n#endif\r\n#ifndef NO_NOPCOMMANDS\r\np->scb->cbl_offset = make16(p->nop_cmds[0]);\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD();\r\n#else\r\np->xmit_cmds[0]->cmd_link = make16(p->xmit_cmds[0]);\r\np->xmit_cmds[0]->cmd_cmd = swab16(CMD_XMIT | CMD_SUSPEND | CMD_INT);\r\n#endif\r\np->scb->cmd_cuc = p->scb->cus & STAT_MASK;\r\nsun3_attn586();\r\nDELAY_16();\r\nsun3_enaint();\r\nsun3_active();\r\nreturn 0;\r\n}\r\nstatic void *alloc_rfa(struct net_device *dev,void *ptr)\r\n{\r\nvolatile struct rfd_struct *rfd = (struct rfd_struct *)ptr;\r\nvolatile struct rbd_struct *rbd;\r\nint i;\r\nstruct priv *p = netdev_priv(dev);\r\nmemset((char *) rfd,0,sizeof(struct rfd_struct)*(p->num_recv_buffs+rfdadd));\r\np->rfd_first = rfd;\r\nfor(i = 0; i < (p->num_recv_buffs+rfdadd); i++) {\r\nrfd[i].next = make16(rfd + (i+1) % (p->num_recv_buffs+rfdadd) );\r\nrfd[i].rbd_offset = 0xffff;\r\n}\r\nrfd[p->num_recv_buffs-1+rfdadd].last = RFD_SUSP;\r\nptr = (void *) (rfd + (p->num_recv_buffs + rfdadd) );\r\nrbd = (struct rbd_struct *) ptr;\r\nptr = (void *) (rbd + p->num_recv_buffs);\r\nmemset((char *) rbd,0,sizeof(struct rbd_struct)*(p->num_recv_buffs));\r\nfor(i=0;i<p->num_recv_buffs;i++)\r\n{\r\nrbd[i].next = make16((rbd + (i+1) % p->num_recv_buffs));\r\nrbd[i].size = swab16(RECV_BUFF_SIZE);\r\nrbd[i].buffer = make24(ptr);\r\nptr = (char *) ptr + RECV_BUFF_SIZE;\r\n}\r\np->rfd_top = p->rfd_first;\r\np->rfd_last = p->rfd_first + (p->num_recv_buffs - 1 + rfdadd);\r\np->scb->rfa_offset = make16(p->rfd_first);\r\np->rfd_first->rbd_offset = make16(rbd);\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t sun3_82586_interrupt(int irq,void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nunsigned short stat;\r\nint cnt=0;\r\nstruct priv *p;\r\nif (!dev) {\r\nprintk ("sun3_82586-interrupt: irq %d for unknown device.\n",irq);\r\nreturn IRQ_NONE;\r\n}\r\np = netdev_priv(dev);\r\nif(debuglevel > 1)\r\nprintk("I");\r\nWAIT_4_SCB_CMD();\r\nwhile((stat=p->scb->cus & STAT_MASK))\r\n{\r\np->scb->cmd_cuc = stat;\r\nsun3_attn586();\r\nif(stat & STAT_FR)\r\nsun3_82586_rcv_int(dev);\r\nif(stat & STAT_RNR)\r\n{\r\nprintk("(R)");\r\nif(p->scb->rus & RU_SUSPEND)\r\n{\r\nWAIT_4_SCB_CMD();\r\np->scb->cmd_ruc = RUC_RESUME;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD_RUC();\r\n}\r\nelse\r\n{\r\nprintk("%s: Receiver-Unit went 'NOT READY': %04x/%02x.\n",dev->name,(int) stat,(int) p->scb->rus);\r\nsun3_82586_rnr_int(dev);\r\n}\r\n}\r\nif(stat & STAT_CX)\r\nsun3_82586_xmt_int(dev);\r\n#ifndef NO_NOPCOMMANDS\r\nif(stat & STAT_CNA)\r\n{\r\nif(netif_running(dev))\r\nprintk("%s: oops! CU has left active state. stat: %04x/%02x.\n",dev->name,(int) stat,(int) p->scb->cus);\r\n}\r\n#endif\r\nif(debuglevel > 1)\r\nprintk("%d",cnt++);\r\nWAIT_4_SCB_CMD();\r\nif(p->scb->cmd_cuc)\r\n{\r\nprintk("%s: Acknowledge timed out.\n",dev->name);\r\nsun3_disint();\r\nbreak;\r\n}\r\n}\r\nif(debuglevel > 1)\r\nprintk("i");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sun3_82586_rcv_int(struct net_device *dev)\r\n{\r\nint status,cnt=0;\r\nunsigned short totlen;\r\nstruct sk_buff *skb;\r\nstruct rbd_struct *rbd;\r\nstruct priv *p = netdev_priv(dev);\r\nif(debuglevel > 0)\r\nprintk("R");\r\nfor(;(status = p->rfd_top->stat_high) & RFD_COMPL;)\r\n{\r\nrbd = (struct rbd_struct *) make32(p->rfd_top->rbd_offset);\r\nif(status & RFD_OK)\r\n{\r\nif( (totlen = swab16(rbd->status)) & RBD_LAST)\r\n{\r\ntotlen &= RBD_MASK;\r\nrbd->status = 0;\r\nskb = netdev_alloc_skb(dev, totlen + 2);\r\nif(skb != NULL)\r\n{\r\nskb_reserve(skb,2);\r\nskb_put(skb,totlen);\r\nskb_copy_to_linear_data(skb,(char *) p->base+swab32((unsigned long) rbd->buffer),totlen);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nelse\r\ndev->stats.rx_dropped++;\r\n}\r\nelse\r\n{\r\nint rstat;\r\ntotlen = 0;\r\nwhile(!((rstat=swab16(rbd->status)) & RBD_LAST))\r\n{\r\ntotlen += rstat & RBD_MASK;\r\nif(!rstat)\r\n{\r\nprintk("%s: Whoops .. no end mark in RBD list\n",dev->name);\r\nbreak;\r\n}\r\nrbd->status = 0;\r\nrbd = (struct rbd_struct *) make32(rbd->next);\r\n}\r\ntotlen += rstat & RBD_MASK;\r\nrbd->status = 0;\r\nprintk("%s: received oversized frame! length: %d\n",dev->name,totlen);\r\ndev->stats.rx_dropped++;\r\n}\r\n}\r\nelse\r\n{\r\nprintk("%s: oops! rfd-error-status: %04x\n",dev->name,status);\r\ndev->stats.rx_errors++;\r\n}\r\np->rfd_top->stat_high = 0;\r\np->rfd_top->last = RFD_SUSP;\r\np->rfd_top->rbd_offset = 0xffff;\r\np->rfd_last->last = 0;\r\np->rfd_last = p->rfd_top;\r\np->rfd_top = (struct rfd_struct *) make32(p->rfd_top->next);\r\np->scb->rfa_offset = make16(p->rfd_top);\r\nif(debuglevel > 0)\r\nprintk("%d",cnt++);\r\n}\r\nif(automatic_resume)\r\n{\r\nWAIT_4_SCB_CMD();\r\np->scb->cmd_ruc = RUC_RESUME;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD_RUC();\r\n}\r\n#ifdef WAIT_4_BUSY\r\n{\r\nint i;\r\nfor(i=0;i<1024;i++)\r\n{\r\nif(p->rfd_top->status)\r\nbreak;\r\nDELAY_16();\r\nif(i == 1023)\r\nprintk("%s: RU hasn't fetched next RFD (not busy/complete)\n",dev->name);\r\n}\r\n}\r\n#endif\r\n#if 0\r\nif(!at_least_one)\r\n{\r\nint i;\r\nvolatile struct rfd_struct *rfds=p->rfd_top;\r\nvolatile struct rbd_struct *rbds;\r\nprintk("%s: received a FC intr. without having a frame: %04x %d\n",dev->name,status,old_at_least);\r\nfor(i=0;i< (p->num_recv_buffs+4);i++)\r\n{\r\nrbds = (struct rbd_struct *) make32(rfds->rbd_offset);\r\nprintk("%04x:%04x ",rfds->status,rbds->status);\r\nrfds = (struct rfd_struct *) make32(rfds->next);\r\n}\r\nprintk("\nerrs: %04x %04x stat: %04x\n",(int)p->scb->rsc_errs,(int)p->scb->ovrn_errs,(int)p->scb->status);\r\nprintk("\nerrs: %04x %04x rus: %02x, cus: %02x\n",(int)p->scb->rsc_errs,(int)p->scb->ovrn_errs,(int)p->scb->rus,(int)p->scb->cus);\r\n}\r\nold_at_least = at_least_one;\r\n#endif\r\nif(debuglevel > 0)\r\nprintk("r");\r\n}\r\nstatic void sun3_82586_rnr_int(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\ndev->stats.rx_errors++;\r\nWAIT_4_SCB_CMD();\r\np->scb->cmd_ruc = RUC_ABORT;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD_RUC();\r\nalloc_rfa(dev,(char *)p->rfd_first);\r\nstartrecv586(dev);\r\nprintk("%s: Receive-Unit restarted. Status: %04x\n",dev->name,p->scb->rus);\r\n}\r\nstatic void sun3_82586_xmt_int(struct net_device *dev)\r\n{\r\nint status;\r\nstruct priv *p = netdev_priv(dev);\r\nif(debuglevel > 0)\r\nprintk("X");\r\nstatus = swab16(p->xmit_cmds[p->xmit_last]->cmd_status);\r\nif(!(status & STAT_COMPL))\r\nprintk("%s: strange .. xmit-int without a 'COMPLETE'\n",dev->name);\r\nif(status & STAT_OK)\r\n{\r\ndev->stats.tx_packets++;\r\ndev->stats.collisions += (status & TCMD_MAXCOLLMASK);\r\n}\r\nelse\r\n{\r\ndev->stats.tx_errors++;\r\nif(status & TCMD_LATECOLL) {\r\nprintk("%s: late collision detected.\n",dev->name);\r\ndev->stats.collisions++;\r\n}\r\nelse if(status & TCMD_NOCARRIER) {\r\ndev->stats.tx_carrier_errors++;\r\nprintk("%s: no carrier detected.\n",dev->name);\r\n}\r\nelse if(status & TCMD_LOSTCTS)\r\nprintk("%s: loss of CTS detected.\n",dev->name);\r\nelse if(status & TCMD_UNDERRUN) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk("%s: DMA underrun detected.\n",dev->name);\r\n}\r\nelse if(status & TCMD_MAXCOLL) {\r\nprintk("%s: Max. collisions exceeded.\n",dev->name);\r\ndev->stats.collisions += 16;\r\n}\r\n}\r\n#if (NUM_XMIT_BUFFS > 1)\r\nif( (++p->xmit_last) == NUM_XMIT_BUFFS)\r\np->xmit_last = 0;\r\n#endif\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void startrecv586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nWAIT_4_SCB_CMD();\r\nWAIT_4_SCB_CMD_RUC();\r\np->scb->rfa_offset = make16(p->rfd_first);\r\np->scb->cmd_ruc = RUC_START;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD_RUC();\r\n}\r\nstatic void sun3_82586_timeout(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\n#ifndef NO_NOPCOMMANDS\r\nif(p->scb->cus & CU_ACTIVE)\r\n{\r\nnetif_wake_queue(dev);\r\n#ifdef DEBUG\r\nprintk("%s: strange ... timeout with CU active?!?\n",dev->name);\r\nprintk("%s: X0: %04x N0: %04x N1: %04x %d\n",dev->name,(int)swab16(p->xmit_cmds[0]->cmd_status),(int)swab16(p->nop_cmds[0]->cmd_status),(int)swab16(p->nop_cmds[1]->cmd_status),(int)p->nop_point);\r\n#endif\r\np->scb->cmd_cuc = CUC_ABORT;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD();\r\np->scb->cbl_offset = make16(p->nop_cmds[p->nop_point]);\r\np->scb->cmd_cuc = CUC_START;\r\nsun3_attn586();\r\nWAIT_4_SCB_CMD();\r\nnetif_trans_update(dev);\r\nreturn 0;\r\n}\r\n#endif\r\n{\r\n#ifdef DEBUG\r\nprintk("%s: xmitter timed out, try to restart! stat: %02x\n",dev->name,p->scb->cus);\r\nprintk("%s: command-stats: %04x %04x\n",dev->name,swab16(p->xmit_cmds[0]->cmd_status),swab16(p->xmit_cmds[1]->cmd_status));\r\nprintk("%s: check, whether you set the right interrupt number!\n",dev->name);\r\n#endif\r\nsun3_82586_close(dev);\r\nsun3_82586_open(dev);\r\n}\r\nnetif_trans_update(dev);\r\n}\r\nstatic int sun3_82586_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint len,i;\r\n#ifndef NO_NOPCOMMANDS\r\nint next_nop;\r\n#endif\r\nstruct priv *p = netdev_priv(dev);\r\nif(skb->len > XMIT_BUFF_SIZE)\r\n{\r\nprintk("%s: Sorry, max. framelength is %d bytes. The length of your frame is %d bytes.\n",dev->name,XMIT_BUFF_SIZE,skb->len);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\n#if(NUM_XMIT_BUFFS > 1)\r\nif(test_and_set_bit(0,(void *) &p->lock)) {\r\nprintk("%s: Queue was locked\n",dev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nelse\r\n#endif\r\n{\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nmemset((void *)p->xmit_cbuffs[p->xmit_count], 0,\r\nETH_ZLEN);\r\nlen = ETH_ZLEN;\r\n}\r\nskb_copy_from_linear_data(skb, (void *)p->xmit_cbuffs[p->xmit_count], skb->len);\r\n#if (NUM_XMIT_BUFFS == 1)\r\n# ifdef NO_NOPCOMMANDS\r\n#ifdef DEBUG\r\nif(p->scb->cus & CU_ACTIVE)\r\n{\r\nprintk("%s: Hmmm .. CU is still running and we wanna send a new packet.\n",dev->name);\r\nprintk("%s: stat: %04x %04x\n",dev->name,p->scb->cus,swab16(p->xmit_cmds[0]->cmd_status));\r\n}\r\n#endif\r\np->xmit_buffs[0]->size = swab16(TBD_LAST | len);\r\nfor(i=0;i<16;i++)\r\n{\r\np->xmit_cmds[0]->cmd_status = 0;\r\nWAIT_4_SCB_CMD();\r\nif( (p->scb->cus & CU_STATUS) == CU_SUSPEND)\r\np->scb->cmd_cuc = CUC_RESUME;\r\nelse\r\n{\r\np->scb->cbl_offset = make16(p->xmit_cmds[0]);\r\np->scb->cmd_cuc = CUC_START;\r\n}\r\nsun3_attn586();\r\nif(!i)\r\ndev_kfree_skb(skb);\r\nWAIT_4_SCB_CMD();\r\nif( (p->scb->cus & CU_ACTIVE))\r\nbreak;\r\nif(p->xmit_cmds[0]->cmd_status)\r\nbreak;\r\nif(i==15)\r\nprintk("%s: Can't start transmit-command.\n",dev->name);\r\n}\r\n# else\r\nnext_nop = (p->nop_point + 1) & 0x1;\r\np->xmit_buffs[0]->size = swab16(TBD_LAST | len);\r\np->xmit_cmds[0]->cmd_link = p->nop_cmds[next_nop]->cmd_link\r\n= make16((p->nop_cmds[next_nop]));\r\np->xmit_cmds[0]->cmd_status = p->nop_cmds[next_nop]->cmd_status = 0;\r\np->nop_cmds[p->nop_point]->cmd_link = make16((p->xmit_cmds[0]));\r\np->nop_point = next_nop;\r\ndev_kfree_skb(skb);\r\n# endif\r\n#else\r\np->xmit_buffs[p->xmit_count]->size = swab16(TBD_LAST | len);\r\nif( (next_nop = p->xmit_count + 1) == NUM_XMIT_BUFFS )\r\nnext_nop = 0;\r\np->xmit_cmds[p->xmit_count]->cmd_status = 0;\r\np->nop_cmds[next_nop]->cmd_link = make16((p->nop_cmds[next_nop]));\r\np->nop_cmds[next_nop]->cmd_status = 0;\r\np->nop_cmds[p->xmit_count]->cmd_link = make16((p->xmit_cmds[p->xmit_count]));\r\np->xmit_count = next_nop;\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif(p->xmit_count != p->xmit_last)\r\nnetif_wake_queue(dev);\r\np->lock = 0;\r\nlocal_irq_restore(flags);\r\n}\r\ndev_kfree_skb(skb);\r\n#endif\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *sun3_82586_get_stats(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nunsigned short crc,aln,rsc,ovrn;\r\ncrc = swab16(p->scb->crc_errs);\r\np->scb->crc_errs = 0;\r\naln = swab16(p->scb->aln_errs);\r\np->scb->aln_errs = 0;\r\nrsc = swab16(p->scb->rsc_errs);\r\np->scb->rsc_errs = 0;\r\novrn = swab16(p->scb->ovrn_errs);\r\np->scb->ovrn_errs = 0;\r\ndev->stats.rx_crc_errors += crc;\r\ndev->stats.rx_fifo_errors += ovrn;\r\ndev->stats.rx_frame_errors += aln;\r\ndev->stats.rx_dropped += rsc;\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nsun3_disint();\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\nsun3_enaint();\r\nnetif_wake_queue(dev);\r\n}
