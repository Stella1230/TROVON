static void keystone_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrncpy(info->driver, NETCP_DRIVER_NAME, sizeof(info->driver));\r\nstrncpy(info->version, NETCP_DRIVER_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 keystone_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nreturn netcp->msg_enable;\r\n}\r\nstatic void keystone_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nnetcp->msg_enable = value;\r\n}\r\nstatic void keystone_get_stat_strings(struct net_device *ndev,\r\nuint32_t stringset, uint8_t *data)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_intf *gbe_intf;\r\nstruct gbe_priv *gbe_dev;\r\nint i;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn;\r\ngbe_dev = gbe_intf->gbe_dev;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < gbe_dev->num_et_stats; i++) {\r\nmemcpy(data, gbe_dev->et_stats[i].desc,\r\nETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ncase ETH_SS_TEST:\r\nbreak;\r\n}\r\n}\r\nstatic int keystone_get_sset_count(struct net_device *ndev, int stringset)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_intf *gbe_intf;\r\nstruct gbe_priv *gbe_dev;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn -EINVAL;\r\ngbe_dev = gbe_intf->gbe_dev;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nreturn 0;\r\ncase ETH_SS_STATS:\r\nreturn gbe_dev->num_et_stats;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void gbe_reset_mod_stats(struct gbe_priv *gbe_dev, int stats_mod)\r\n{\r\nvoid __iomem *base = gbe_dev->hw_stats_regs[stats_mod];\r\nu32 __iomem *p_stats_entry;\r\nint i;\r\nfor (i = 0; i < gbe_dev->num_et_stats; i++) {\r\nif (gbe_dev->et_stats[i].type == stats_mod) {\r\np_stats_entry = base + gbe_dev->et_stats[i].offset;\r\ngbe_dev->hw_stats[i] = 0;\r\ngbe_dev->hw_stats_prev[i] = readl(p_stats_entry);\r\n}\r\n}\r\n}\r\nstatic inline void gbe_update_hw_stats_entry(struct gbe_priv *gbe_dev,\r\nint et_stats_entry)\r\n{\r\nvoid __iomem *base = NULL;\r\nu32 __iomem *p_stats_entry;\r\nu32 curr, delta;\r\nbase = gbe_dev->hw_stats_regs[gbe_dev->et_stats[et_stats_entry].type];\r\np_stats_entry = base + gbe_dev->et_stats[et_stats_entry].offset;\r\ncurr = readl(p_stats_entry);\r\ndelta = curr - gbe_dev->hw_stats_prev[et_stats_entry];\r\ngbe_dev->hw_stats_prev[et_stats_entry] = curr;\r\ngbe_dev->hw_stats[et_stats_entry] += delta;\r\n}\r\nstatic void gbe_update_stats(struct gbe_priv *gbe_dev, uint64_t *data)\r\n{\r\nint i;\r\nfor (i = 0; i < gbe_dev->num_et_stats; i++) {\r\ngbe_update_hw_stats_entry(gbe_dev, i);\r\nif (data)\r\ndata[i] = gbe_dev->hw_stats[i];\r\n}\r\n}\r\nstatic inline void gbe_stats_mod_visible_ver14(struct gbe_priv *gbe_dev,\r\nint stats_mod)\r\n{\r\nu32 val;\r\nval = readl(GBE_REG_ADDR(gbe_dev, switch_regs, stat_port_en));\r\nswitch (stats_mod) {\r\ncase GBE_STATSA_MODULE:\r\ncase GBE_STATSB_MODULE:\r\nval &= ~GBE_STATS_CD_SEL;\r\nbreak;\r\ncase GBE_STATSC_MODULE:\r\ncase GBE_STATSD_MODULE:\r\nval |= GBE_STATS_CD_SEL;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(val, GBE_REG_ADDR(gbe_dev, switch_regs, stat_port_en));\r\n}\r\nstatic void gbe_reset_mod_stats_ver14(struct gbe_priv *gbe_dev, int stats_mod)\r\n{\r\ngbe_stats_mod_visible_ver14(gbe_dev, stats_mod);\r\ngbe_reset_mod_stats(gbe_dev, stats_mod);\r\n}\r\nstatic void gbe_update_stats_ver14(struct gbe_priv *gbe_dev, uint64_t *data)\r\n{\r\nu32 half_num_et_stats = (gbe_dev->num_et_stats / 2);\r\nint et_entry, j, pair;\r\nfor (pair = 0; pair < 2; pair++) {\r\ngbe_stats_mod_visible_ver14(gbe_dev, (pair ?\r\nGBE_STATSC_MODULE :\r\nGBE_STATSA_MODULE));\r\nfor (j = 0; j < half_num_et_stats; j++) {\r\net_entry = pair * half_num_et_stats + j;\r\ngbe_update_hw_stats_entry(gbe_dev, et_entry);\r\nif (data)\r\ndata[et_entry] = gbe_dev->hw_stats[et_entry];\r\n}\r\n}\r\n}\r\nstatic void keystone_get_ethtool_stats(struct net_device *ndev,\r\nstruct ethtool_stats *stats,\r\nuint64_t *data)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_intf *gbe_intf;\r\nstruct gbe_priv *gbe_dev;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn;\r\ngbe_dev = gbe_intf->gbe_dev;\r\nspin_lock_bh(&gbe_dev->hw_stats_lock);\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14)\r\ngbe_update_stats_ver14(gbe_dev, data);\r\nelse\r\ngbe_update_stats(gbe_dev, data);\r\nspin_unlock_bh(&gbe_dev->hw_stats_lock);\r\n}\r\nstatic int keystone_get_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct phy_device *phy = ndev->phydev;\r\nstruct gbe_intf *gbe_intf;\r\nint ret;\r\nif (!phy)\r\nreturn -EINVAL;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn -EINVAL;\r\nif (!gbe_intf->slave)\r\nreturn -EINVAL;\r\nret = phy_ethtool_gset(phy, cmd);\r\nif (!ret)\r\ncmd->port = gbe_intf->slave->phy_port_t;\r\nreturn ret;\r\n}\r\nstatic int keystone_set_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct phy_device *phy = ndev->phydev;\r\nstruct gbe_intf *gbe_intf;\r\nu32 features = cmd->advertising & cmd->supported;\r\nif (!phy)\r\nreturn -EINVAL;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn -EINVAL;\r\nif (!gbe_intf->slave)\r\nreturn -EINVAL;\r\nif (cmd->port != gbe_intf->slave->phy_port_t) {\r\nif ((cmd->port == PORT_TP) && !(features & ADVERTISED_TP))\r\nreturn -EINVAL;\r\nif ((cmd->port == PORT_AUI) && !(features & ADVERTISED_AUI))\r\nreturn -EINVAL;\r\nif ((cmd->port == PORT_BNC) && !(features & ADVERTISED_BNC))\r\nreturn -EINVAL;\r\nif ((cmd->port == PORT_MII) && !(features & ADVERTISED_MII))\r\nreturn -EINVAL;\r\nif ((cmd->port == PORT_FIBRE) && !(features & ADVERTISED_FIBRE))\r\nreturn -EINVAL;\r\n}\r\ngbe_intf->slave->phy_port_t = cmd->port;\r\nreturn phy_ethtool_sset(phy, cmd);\r\n}\r\nstatic void gbe_set_slave_mac(struct gbe_slave *slave,\r\nstruct gbe_intf *gbe_intf)\r\n{\r\nstruct net_device *ndev = gbe_intf->ndev;\r\nwritel(mac_hi(ndev->dev_addr), GBE_REG_ADDR(slave, port_regs, sa_hi));\r\nwritel(mac_lo(ndev->dev_addr), GBE_REG_ADDR(slave, port_regs, sa_lo));\r\n}\r\nstatic int gbe_get_slave_port(struct gbe_priv *priv, u32 slave_num)\r\n{\r\nif (priv->host_port == 0)\r\nreturn slave_num + 1;\r\nreturn slave_num;\r\n}\r\nstatic void netcp_ethss_link_state_action(struct gbe_priv *gbe_dev,\r\nstruct net_device *ndev,\r\nstruct gbe_slave *slave,\r\nint up)\r\n{\r\nstruct phy_device *phy = slave->phy;\r\nu32 mac_control = 0;\r\nif (up) {\r\nmac_control = slave->mac_control;\r\nif (phy && (phy->speed == SPEED_1000)) {\r\nmac_control |= MACSL_GIG_MODE;\r\nmac_control &= ~MACSL_XGIG_MODE;\r\n} else if (phy && (phy->speed == SPEED_10000)) {\r\nmac_control |= MACSL_XGIG_MODE;\r\nmac_control &= ~MACSL_GIG_MODE;\r\n}\r\nwritel(mac_control, GBE_REG_ADDR(slave, emac_regs,\r\nmac_control));\r\ncpsw_ale_control_set(gbe_dev->ale, slave->port_num,\r\nALE_PORT_STATE,\r\nALE_PORT_STATE_FORWARD);\r\nif (ndev && slave->open &&\r\nslave->link_interface != SGMII_LINK_MAC_PHY &&\r\nslave->link_interface != XGMII_LINK_MAC_PHY)\r\nnetif_carrier_on(ndev);\r\n} else {\r\nwritel(mac_control, GBE_REG_ADDR(slave, emac_regs,\r\nmac_control));\r\ncpsw_ale_control_set(gbe_dev->ale, slave->port_num,\r\nALE_PORT_STATE,\r\nALE_PORT_STATE_DISABLE);\r\nif (ndev &&\r\nslave->link_interface != SGMII_LINK_MAC_PHY &&\r\nslave->link_interface != XGMII_LINK_MAC_PHY)\r\nnetif_carrier_off(ndev);\r\n}\r\nif (phy)\r\nphy_print_status(phy);\r\n}\r\nstatic bool gbe_phy_link_status(struct gbe_slave *slave)\r\n{\r\nreturn !slave->phy || slave->phy->link;\r\n}\r\nstatic void netcp_ethss_update_link_state(struct gbe_priv *gbe_dev,\r\nstruct gbe_slave *slave,\r\nstruct net_device *ndev)\r\n{\r\nint sp = slave->slave_num;\r\nint phy_link_state, sgmii_link_state = 1, link_state;\r\nif (!slave->open)\r\nreturn;\r\nif (!SLAVE_LINK_IS_XGMII(slave)) {\r\nsgmii_link_state =\r\nnetcp_sgmii_get_port_link(SGMII_BASE(gbe_dev, sp), sp);\r\n}\r\nphy_link_state = gbe_phy_link_status(slave);\r\nlink_state = phy_link_state & sgmii_link_state;\r\nif (atomic_xchg(&slave->link_state, link_state) != link_state)\r\nnetcp_ethss_link_state_action(gbe_dev, ndev, slave,\r\nlink_state);\r\n}\r\nstatic void xgbe_adjust_link(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_intf *gbe_intf;\r\ngbe_intf = netcp_module_get_intf_data(&xgbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn;\r\nnetcp_ethss_update_link_state(gbe_intf->gbe_dev, gbe_intf->slave,\r\nndev);\r\n}\r\nstatic void gbe_adjust_link(struct net_device *ndev)\r\n{\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_intf *gbe_intf;\r\ngbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\r\nif (!gbe_intf)\r\nreturn;\r\nnetcp_ethss_update_link_state(gbe_intf->gbe_dev, gbe_intf->slave,\r\nndev);\r\n}\r\nstatic void gbe_adjust_link_sec_slaves(struct net_device *ndev)\r\n{\r\nstruct gbe_priv *gbe_dev = netdev_priv(ndev);\r\nstruct gbe_slave *slave;\r\nfor_each_sec_slave(slave, gbe_dev)\r\nnetcp_ethss_update_link_state(gbe_dev, slave, NULL);\r\n}\r\nstatic int gbe_port_reset(struct gbe_slave *slave)\r\n{\r\nu32 i, v;\r\nwritel(SOFT_RESET, GBE_REG_ADDR(slave, emac_regs, soft_reset));\r\nfor (i = 0; i < DEVICE_EMACSL_RESET_POLL_COUNT; i++) {\r\nv = readl(GBE_REG_ADDR(slave, emac_regs, soft_reset));\r\nif ((v & SOFT_RESET_MASK) != SOFT_RESET)\r\nreturn 0;\r\n}\r\nreturn GMACSL_RET_WARN_RESET_INCOMPLETE;\r\n}\r\nstatic void gbe_port_config(struct gbe_priv *gbe_dev, struct gbe_slave *slave,\r\nint max_rx_len)\r\n{\r\nvoid __iomem *rx_maxlen_reg;\r\nu32 xgmii_mode;\r\nif (max_rx_len > NETCP_MAX_FRAME_SIZE)\r\nmax_rx_len = NETCP_MAX_FRAME_SIZE;\r\nif ((gbe_dev->ss_version == XGBE_SS_VERSION_10) &&\r\n(slave->link_interface >= XGMII_LINK_MAC_PHY)) {\r\nxgmii_mode = readl(GBE_REG_ADDR(gbe_dev, ss_regs, control));\r\nxgmii_mode |= (1 << slave->slave_num);\r\nwritel(xgmii_mode, GBE_REG_ADDR(gbe_dev, ss_regs, control));\r\n}\r\nif (IS_SS_ID_MU(gbe_dev))\r\nrx_maxlen_reg = GBE_REG_ADDR(slave, port_regs, rx_maxlen);\r\nelse\r\nrx_maxlen_reg = GBE_REG_ADDR(slave, emac_regs, rx_maxlen);\r\nwritel(max_rx_len, rx_maxlen_reg);\r\nwritel(slave->mac_control, GBE_REG_ADDR(slave, emac_regs, mac_control));\r\n}\r\nstatic void gbe_sgmii_rtreset(struct gbe_priv *priv,\r\nstruct gbe_slave *slave, bool set)\r\n{\r\nif (SLAVE_LINK_IS_XGMII(slave))\r\nreturn;\r\nnetcp_sgmii_rtreset(SGMII_BASE(priv, slave->slave_num),\r\nslave->slave_num, set);\r\n}\r\nstatic void gbe_slave_stop(struct gbe_intf *intf)\r\n{\r\nstruct gbe_priv *gbe_dev = intf->gbe_dev;\r\nstruct gbe_slave *slave = intf->slave;\r\ngbe_sgmii_rtreset(gbe_dev, slave, true);\r\ngbe_port_reset(slave);\r\ncpsw_ale_control_set(gbe_dev->ale, slave->port_num,\r\nALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\r\ncpsw_ale_del_mcast(gbe_dev->ale, intf->ndev->broadcast,\r\n1 << slave->port_num, 0, 0);\r\nif (!slave->phy)\r\nreturn;\r\nphy_stop(slave->phy);\r\nphy_disconnect(slave->phy);\r\nslave->phy = NULL;\r\n}\r\nstatic void gbe_sgmii_config(struct gbe_priv *priv, struct gbe_slave *slave)\r\n{\r\nif (SLAVE_LINK_IS_XGMII(slave))\r\nreturn;\r\nnetcp_sgmii_reset(SGMII_BASE(priv, slave->slave_num), slave->slave_num);\r\nnetcp_sgmii_config(SGMII_BASE(priv, slave->slave_num), slave->slave_num,\r\nslave->link_interface);\r\n}\r\nstatic int gbe_slave_open(struct gbe_intf *gbe_intf)\r\n{\r\nstruct gbe_priv *priv = gbe_intf->gbe_dev;\r\nstruct gbe_slave *slave = gbe_intf->slave;\r\nphy_interface_t phy_mode;\r\nbool has_phy = false;\r\nvoid (*hndlr)(struct net_device *) = gbe_adjust_link;\r\ngbe_sgmii_config(priv, slave);\r\ngbe_port_reset(slave);\r\ngbe_sgmii_rtreset(priv, slave, false);\r\ngbe_port_config(priv, slave, priv->rx_packet_max);\r\ngbe_set_slave_mac(slave, gbe_intf);\r\ncpsw_ale_control_set(priv->ale, slave->port_num,\r\nALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\r\ncpsw_ale_add_mcast(priv->ale, gbe_intf->ndev->broadcast,\r\n1 << slave->port_num, 0, 0, ALE_MCAST_FWD_2);\r\nif (slave->link_interface == SGMII_LINK_MAC_PHY) {\r\nhas_phy = true;\r\nphy_mode = PHY_INTERFACE_MODE_SGMII;\r\nslave->phy_port_t = PORT_MII;\r\n} else if (slave->link_interface == XGMII_LINK_MAC_PHY) {\r\nhas_phy = true;\r\nphy_mode = PHY_INTERFACE_MODE_NA;\r\nslave->phy_port_t = PORT_FIBRE;\r\n}\r\nif (has_phy) {\r\nif (priv->ss_version == XGBE_SS_VERSION_10)\r\nhndlr = xgbe_adjust_link;\r\nslave->phy = of_phy_connect(gbe_intf->ndev,\r\nslave->phy_node,\r\nhndlr, 0,\r\nphy_mode);\r\nif (!slave->phy) {\r\ndev_err(priv->dev, "phy not found on slave %d\n",\r\nslave->slave_num);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(priv->dev, "phy found: id is: 0x%s\n",\r\nphydev_name(slave->phy));\r\nphy_start(slave->phy);\r\nphy_read_status(slave->phy);\r\n}\r\nreturn 0;\r\n}\r\nstatic void gbe_init_host_port(struct gbe_priv *priv)\r\n{\r\nint bypass_en = 1;\r\nif (IS_SS_ID_NU(priv))\r\nwritel(HOST_TX_PRI_MAP_DEFAULT,\r\nGBE_REG_ADDR(priv, host_port_regs, tx_pri_map));\r\nwritel(NETCP_MAX_FRAME_SIZE, GBE_REG_ADDR(priv, host_port_regs,\r\nrx_maxlen));\r\ncpsw_ale_start(priv->ale);\r\nif (priv->enable_ale)\r\nbypass_en = 0;\r\ncpsw_ale_control_set(priv->ale, 0, ALE_BYPASS, bypass_en);\r\ncpsw_ale_control_set(priv->ale, 0, ALE_NO_PORT_VLAN, 1);\r\ncpsw_ale_control_set(priv->ale, priv->host_port,\r\nALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\r\ncpsw_ale_control_set(priv->ale, 0,\r\nALE_PORT_UNKNOWN_VLAN_MEMBER,\r\nGBE_PORT_MASK(priv->ale_ports));\r\ncpsw_ale_control_set(priv->ale, 0,\r\nALE_PORT_UNKNOWN_MCAST_FLOOD,\r\nGBE_PORT_MASK(priv->ale_ports - 1));\r\ncpsw_ale_control_set(priv->ale, 0,\r\nALE_PORT_UNKNOWN_REG_MCAST_FLOOD,\r\nGBE_PORT_MASK(priv->ale_ports));\r\ncpsw_ale_control_set(priv->ale, 0,\r\nALE_PORT_UNTAGGED_EGRESS,\r\nGBE_PORT_MASK(priv->ale_ports));\r\n}\r\nstatic void gbe_add_mcast_addr(struct gbe_intf *gbe_intf, u8 *addr)\r\n{\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nu16 vlan_id;\r\ncpsw_ale_add_mcast(gbe_dev->ale, addr,\r\nGBE_PORT_MASK(gbe_dev->ale_ports), 0, 0,\r\nALE_MCAST_FWD_2);\r\nfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\r\ncpsw_ale_add_mcast(gbe_dev->ale, addr,\r\nGBE_PORT_MASK(gbe_dev->ale_ports),\r\nALE_VLAN, vlan_id, ALE_MCAST_FWD_2);\r\n}\r\n}\r\nstatic void gbe_add_ucast_addr(struct gbe_intf *gbe_intf, u8 *addr)\r\n{\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nu16 vlan_id;\r\ncpsw_ale_add_ucast(gbe_dev->ale, addr, gbe_dev->host_port, 0, 0);\r\nfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID)\r\ncpsw_ale_add_ucast(gbe_dev->ale, addr, gbe_dev->host_port,\r\nALE_VLAN, vlan_id);\r\n}\r\nstatic void gbe_del_mcast_addr(struct gbe_intf *gbe_intf, u8 *addr)\r\n{\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nu16 vlan_id;\r\ncpsw_ale_del_mcast(gbe_dev->ale, addr, 0, 0, 0);\r\nfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\r\ncpsw_ale_del_mcast(gbe_dev->ale, addr, 0, ALE_VLAN, vlan_id);\r\n}\r\n}\r\nstatic void gbe_del_ucast_addr(struct gbe_intf *gbe_intf, u8 *addr)\r\n{\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nu16 vlan_id;\r\ncpsw_ale_del_ucast(gbe_dev->ale, addr, gbe_dev->host_port, 0, 0);\r\nfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\r\ncpsw_ale_del_ucast(gbe_dev->ale, addr, gbe_dev->host_port,\r\nALE_VLAN, vlan_id);\r\n}\r\n}\r\nstatic int gbe_add_addr(void *intf_priv, struct netcp_addr *naddr)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\ndev_dbg(gbe_dev->dev, "ethss adding address %pM, type %d\n",\r\nnaddr->addr, naddr->type);\r\nswitch (naddr->type) {\r\ncase ADDR_MCAST:\r\ncase ADDR_BCAST:\r\ngbe_add_mcast_addr(gbe_intf, naddr->addr);\r\nbreak;\r\ncase ADDR_UCAST:\r\ncase ADDR_DEV:\r\ngbe_add_ucast_addr(gbe_intf, naddr->addr);\r\nbreak;\r\ncase ADDR_ANY:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbe_del_addr(void *intf_priv, struct netcp_addr *naddr)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\ndev_dbg(gbe_dev->dev, "ethss deleting address %pM, type %d\n",\r\nnaddr->addr, naddr->type);\r\nswitch (naddr->type) {\r\ncase ADDR_MCAST:\r\ncase ADDR_BCAST:\r\ngbe_del_mcast_addr(gbe_intf, naddr->addr);\r\nbreak;\r\ncase ADDR_UCAST:\r\ncase ADDR_DEV:\r\ngbe_del_ucast_addr(gbe_intf, naddr->addr);\r\nbreak;\r\ncase ADDR_ANY:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbe_add_vid(void *intf_priv, int vid)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nset_bit(vid, gbe_intf->active_vlans);\r\ncpsw_ale_add_vlan(gbe_dev->ale, vid,\r\nGBE_PORT_MASK(gbe_dev->ale_ports),\r\nGBE_MASK_NO_PORTS,\r\nGBE_PORT_MASK(gbe_dev->ale_ports),\r\nGBE_PORT_MASK(gbe_dev->ale_ports - 1));\r\nreturn 0;\r\n}\r\nstatic int gbe_del_vid(void *intf_priv, int vid)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\ncpsw_ale_del_vlan(gbe_dev->ale, vid, 0);\r\nclear_bit(vid, gbe_intf->active_vlans);\r\nreturn 0;\r\n}\r\nstatic int gbe_ioctl(void *intf_priv, struct ifreq *req, int cmd)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct phy_device *phy = gbe_intf->slave->phy;\r\nint ret = -EOPNOTSUPP;\r\nif (phy)\r\nret = phy_mii_ioctl(phy, req, cmd);\r\nreturn ret;\r\n}\r\nstatic void netcp_ethss_timer(unsigned long arg)\r\n{\r\nstruct gbe_priv *gbe_dev = (struct gbe_priv *)arg;\r\nstruct gbe_intf *gbe_intf;\r\nstruct gbe_slave *slave;\r\nfor_each_intf(gbe_intf, gbe_dev) {\r\nif (!gbe_intf->slave->open)\r\ncontinue;\r\nnetcp_ethss_update_link_state(gbe_dev, gbe_intf->slave,\r\ngbe_intf->ndev);\r\n}\r\nfor_each_sec_slave(slave, gbe_dev) {\r\nnetcp_ethss_update_link_state(gbe_dev, slave, NULL);\r\n}\r\nspin_lock(&gbe_dev->hw_stats_lock);\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14)\r\ngbe_update_stats_ver14(gbe_dev, NULL);\r\nelse\r\ngbe_update_stats(gbe_dev, NULL);\r\nspin_unlock(&gbe_dev->hw_stats_lock);\r\ngbe_dev->timer.expires = jiffies + GBE_TIMER_INTERVAL;\r\nadd_timer(&gbe_dev->timer);\r\n}\r\nstatic int gbe_tx_hook(int order, void *data, struct netcp_packet *p_info)\r\n{\r\nstruct gbe_intf *gbe_intf = data;\r\np_info->tx_pipe = &gbe_intf->tx_pipe;\r\nreturn 0;\r\n}\r\nstatic int gbe_open(void *intf_priv, struct net_device *ndev)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\nstruct gbe_slave *slave = gbe_intf->slave;\r\nint port_num = slave->port_num;\r\nu32 reg;\r\nint ret;\r\nreg = readl(GBE_REG_ADDR(gbe_dev, switch_regs, id_ver));\r\ndev_dbg(gbe_dev->dev, "initializing gbe version %d.%d (%d) GBE identification value 0x%x\n",\r\nGBE_MAJOR_VERSION(reg), GBE_MINOR_VERSION(reg),\r\nGBE_RTL_VERSION(reg), GBE_IDENT(reg));\r\nif ((gbe_dev->ss_version == XGBE_SS_VERSION_10) || IS_SS_ID_MU(gbe_dev))\r\ngbe_intf->tx_pipe.flags = SWITCH_TO_PORT_IN_TAGINFO;\r\nif (gbe_dev->enable_ale)\r\ngbe_intf->tx_pipe.switch_to_port = 0;\r\nelse\r\ngbe_intf->tx_pipe.switch_to_port = port_num;\r\ndev_dbg(gbe_dev->dev,\r\n"opened TX channel %s: %p with to port %d, flags %d\n",\r\ngbe_intf->tx_pipe.dma_chan_name,\r\ngbe_intf->tx_pipe.dma_channel,\r\ngbe_intf->tx_pipe.switch_to_port,\r\ngbe_intf->tx_pipe.flags);\r\ngbe_slave_stop(gbe_intf);\r\nwritel(0, GBE_REG_ADDR(gbe_dev, switch_regs, ptype));\r\nwritel(GBE_CTL_P0_ENABLE, GBE_REG_ADDR(gbe_dev, switch_regs, control));\r\nwritel(gbe_dev->stats_en_mask, GBE_REG_ADDR(gbe_dev, switch_regs,\r\nstat_port_en));\r\nret = gbe_slave_open(gbe_intf);\r\nif (ret)\r\ngoto fail;\r\nnetcp_register_txhook(netcp, GBE_TXHOOK_ORDER, gbe_tx_hook,\r\ngbe_intf);\r\nslave->open = true;\r\nnetcp_ethss_update_link_state(gbe_dev, slave, ndev);\r\nreturn 0;\r\nfail:\r\ngbe_slave_stop(gbe_intf);\r\nreturn ret;\r\n}\r\nstatic int gbe_close(void *intf_priv, struct net_device *ndev)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\nstruct netcp_intf *netcp = netdev_priv(ndev);\r\ngbe_slave_stop(gbe_intf);\r\nnetcp_unregister_txhook(netcp, GBE_TXHOOK_ORDER, gbe_tx_hook,\r\ngbe_intf);\r\ngbe_intf->slave->open = false;\r\natomic_set(&gbe_intf->slave->link_state, NETCP_LINK_STATE_INVALID);\r\nreturn 0;\r\n}\r\nstatic int init_slave(struct gbe_priv *gbe_dev, struct gbe_slave *slave,\r\nstruct device_node *node)\r\n{\r\nint port_reg_num;\r\nu32 port_reg_ofs, emac_reg_ofs;\r\nu32 port_reg_blk_sz, emac_reg_blk_sz;\r\nif (of_property_read_u32(node, "slave-port", &slave->slave_num)) {\r\ndev_err(gbe_dev->dev, "missing slave-port parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(node, "link-interface",\r\n&slave->link_interface)) {\r\ndev_warn(gbe_dev->dev,\r\n"missing link-interface value defaulting to 1G mac-phy link\n");\r\nslave->link_interface = SGMII_LINK_MAC_PHY;\r\n}\r\nslave->open = false;\r\nslave->phy_node = of_parse_phandle(node, "phy-handle", 0);\r\nslave->port_num = gbe_get_slave_port(gbe_dev, slave->slave_num);\r\nif (slave->link_interface >= XGMII_LINK_MAC_PHY)\r\nslave->mac_control = GBE_DEF_10G_MAC_CONTROL;\r\nelse\r\nslave->mac_control = GBE_DEF_1G_MAC_CONTROL;\r\nport_reg_num = slave->slave_num;\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14) {\r\nif (slave->slave_num > 1) {\r\nport_reg_ofs = GBE13_SLAVE_PORT2_OFFSET;\r\nport_reg_num -= 2;\r\n} else {\r\nport_reg_ofs = GBE13_SLAVE_PORT_OFFSET;\r\n}\r\nemac_reg_ofs = GBE13_EMAC_OFFSET;\r\nport_reg_blk_sz = 0x30;\r\nemac_reg_blk_sz = 0x40;\r\n} else if (IS_SS_ID_MU(gbe_dev)) {\r\nport_reg_ofs = GBENU_SLAVE_PORT_OFFSET;\r\nemac_reg_ofs = GBENU_EMAC_OFFSET;\r\nport_reg_blk_sz = 0x1000;\r\nemac_reg_blk_sz = 0x1000;\r\n} else if (gbe_dev->ss_version == XGBE_SS_VERSION_10) {\r\nport_reg_ofs = XGBE10_SLAVE_PORT_OFFSET;\r\nemac_reg_ofs = XGBE10_EMAC_OFFSET;\r\nport_reg_blk_sz = 0x30;\r\nemac_reg_blk_sz = 0x40;\r\n} else {\r\ndev_err(gbe_dev->dev, "unknown ethss(0x%x)\n",\r\ngbe_dev->ss_version);\r\nreturn -EINVAL;\r\n}\r\nslave->port_regs = gbe_dev->switch_regs + port_reg_ofs +\r\n(port_reg_blk_sz * port_reg_num);\r\nslave->emac_regs = gbe_dev->switch_regs + emac_reg_ofs +\r\n(emac_reg_blk_sz * slave->slave_num);\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14) {\r\nGBE_SET_REG_OFS(slave, port_regs, port_vlan);\r\nGBE_SET_REG_OFS(slave, port_regs, tx_pri_map);\r\nGBE_SET_REG_OFS(slave, port_regs, sa_lo);\r\nGBE_SET_REG_OFS(slave, port_regs, sa_hi);\r\nGBE_SET_REG_OFS(slave, port_regs, ts_ctl);\r\nGBE_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\r\nGBE_SET_REG_OFS(slave, port_regs, ts_vlan);\r\nGBE_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\r\nGBE_SET_REG_OFS(slave, port_regs, ts_ctl2);\r\nGBE_SET_REG_OFS(slave, emac_regs, mac_control);\r\nGBE_SET_REG_OFS(slave, emac_regs, soft_reset);\r\nGBE_SET_REG_OFS(slave, emac_regs, rx_maxlen);\r\n} else if (IS_SS_ID_MU(gbe_dev)) {\r\nGBENU_SET_REG_OFS(slave, port_regs, port_vlan);\r\nGBENU_SET_REG_OFS(slave, port_regs, tx_pri_map);\r\nGBENU_SET_REG_OFS(slave, port_regs, sa_lo);\r\nGBENU_SET_REG_OFS(slave, port_regs, sa_hi);\r\nGBENU_SET_REG_OFS(slave, port_regs, ts_ctl);\r\nGBENU_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\r\nGBENU_SET_REG_OFS(slave, port_regs, ts_vlan);\r\nGBENU_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\r\nGBENU_SET_REG_OFS(slave, port_regs, ts_ctl2);\r\nGBENU_SET_REG_OFS(slave, port_regs, rx_maxlen);\r\nGBENU_SET_REG_OFS(slave, emac_regs, mac_control);\r\nGBENU_SET_REG_OFS(slave, emac_regs, soft_reset);\r\n} else if (gbe_dev->ss_version == XGBE_SS_VERSION_10) {\r\nXGBE_SET_REG_OFS(slave, port_regs, port_vlan);\r\nXGBE_SET_REG_OFS(slave, port_regs, tx_pri_map);\r\nXGBE_SET_REG_OFS(slave, port_regs, sa_lo);\r\nXGBE_SET_REG_OFS(slave, port_regs, sa_hi);\r\nXGBE_SET_REG_OFS(slave, port_regs, ts_ctl);\r\nXGBE_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\r\nXGBE_SET_REG_OFS(slave, port_regs, ts_vlan);\r\nXGBE_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\r\nXGBE_SET_REG_OFS(slave, port_regs, ts_ctl2);\r\nXGBE_SET_REG_OFS(slave, emac_regs, mac_control);\r\nXGBE_SET_REG_OFS(slave, emac_regs, soft_reset);\r\nXGBE_SET_REG_OFS(slave, emac_regs, rx_maxlen);\r\n}\r\natomic_set(&slave->link_state, NETCP_LINK_STATE_INVALID);\r\nreturn 0;\r\n}\r\nstatic void init_secondary_ports(struct gbe_priv *gbe_dev,\r\nstruct device_node *node)\r\n{\r\nstruct device *dev = gbe_dev->dev;\r\nphy_interface_t phy_mode;\r\nstruct gbe_priv **priv;\r\nstruct device_node *port;\r\nstruct gbe_slave *slave;\r\nbool mac_phy_link = false;\r\nfor_each_child_of_node(node, port) {\r\nslave = devm_kzalloc(dev, sizeof(*slave), GFP_KERNEL);\r\nif (!slave) {\r\ndev_err(dev,\r\n"memomry alloc failed for secondary port(%s), skipping...\n",\r\nport->name);\r\ncontinue;\r\n}\r\nif (init_slave(gbe_dev, slave, port)) {\r\ndev_err(dev,\r\n"Failed to initialize secondary port(%s), skipping...\n",\r\nport->name);\r\ndevm_kfree(dev, slave);\r\ncontinue;\r\n}\r\ngbe_sgmii_config(gbe_dev, slave);\r\ngbe_port_reset(slave);\r\ngbe_port_config(gbe_dev, slave, gbe_dev->rx_packet_max);\r\nlist_add_tail(&slave->slave_list, &gbe_dev->secondary_slaves);\r\ngbe_dev->num_slaves++;\r\nif ((slave->link_interface == SGMII_LINK_MAC_PHY) ||\r\n(slave->link_interface == XGMII_LINK_MAC_PHY))\r\nmac_phy_link = true;\r\nslave->open = true;\r\nif (gbe_dev->num_slaves >= gbe_dev->max_num_slaves) {\r\nof_node_put(port);\r\nbreak;\r\n}\r\n}\r\nif (!mac_phy_link)\r\nreturn;\r\ngbe_dev->dummy_ndev = alloc_netdev(sizeof(gbe_dev), "dummy",\r\nNET_NAME_UNKNOWN, ether_setup);\r\nif (!gbe_dev->dummy_ndev) {\r\ndev_err(dev,\r\n"Failed to allocate dummy netdev for secondary ports, skipping phy_connect()...\n");\r\nreturn;\r\n}\r\npriv = netdev_priv(gbe_dev->dummy_ndev);\r\n*priv = gbe_dev;\r\nif (slave->link_interface == SGMII_LINK_MAC_PHY) {\r\nphy_mode = PHY_INTERFACE_MODE_SGMII;\r\nslave->phy_port_t = PORT_MII;\r\n} else {\r\nphy_mode = PHY_INTERFACE_MODE_NA;\r\nslave->phy_port_t = PORT_FIBRE;\r\n}\r\nfor_each_sec_slave(slave, gbe_dev) {\r\nif ((slave->link_interface != SGMII_LINK_MAC_PHY) &&\r\n(slave->link_interface != XGMII_LINK_MAC_PHY))\r\ncontinue;\r\nslave->phy =\r\nof_phy_connect(gbe_dev->dummy_ndev,\r\nslave->phy_node,\r\ngbe_adjust_link_sec_slaves,\r\n0, phy_mode);\r\nif (!slave->phy) {\r\ndev_err(dev, "phy not found for slave %d\n",\r\nslave->slave_num);\r\nslave->phy = NULL;\r\n} else {\r\ndev_dbg(dev, "phy found: id is: 0x%s\n",\r\nphydev_name(slave->phy));\r\nphy_start(slave->phy);\r\nphy_read_status(slave->phy);\r\n}\r\n}\r\n}\r\nstatic void free_secondary_ports(struct gbe_priv *gbe_dev)\r\n{\r\nstruct gbe_slave *slave;\r\nwhile (!list_empty(&gbe_dev->secondary_slaves)) {\r\nslave = first_sec_slave(gbe_dev);\r\nif (slave->phy)\r\nphy_disconnect(slave->phy);\r\nlist_del(&slave->slave_list);\r\n}\r\nif (gbe_dev->dummy_ndev)\r\nfree_netdev(gbe_dev->dummy_ndev);\r\n}\r\nstatic int set_xgbe_ethss10_priv(struct gbe_priv *gbe_dev,\r\nstruct device_node *node)\r\n{\r\nstruct resource res;\r\nvoid __iomem *regs;\r\nint ret, i;\r\nret = of_address_to_resource(node, XGBE_SS_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't xlate xgbe of node(%s) ss address at %d\n",\r\nnode->name, XGBE_SS_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev, "Failed to map xgbe ss register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->ss_regs = regs;\r\nret = of_address_to_resource(node, XGBE_SM_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't xlate xgbe of node(%s) sm address at %d\n",\r\nnode->name, XGBE_SM_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev, "Failed to map xgbe sm register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->switch_regs = regs;\r\nret = of_address_to_resource(node, XGBE_SERDES_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't xlate xgbe serdes of node(%s) address at %d\n",\r\nnode->name, XGBE_SERDES_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev, "Failed to map xgbe serdes register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->xgbe_serdes_regs = regs;\r\ngbe_dev->num_stats_mods = gbe_dev->max_num_ports;\r\ngbe_dev->et_stats = xgbe10_et_stats;\r\ngbe_dev->num_et_stats = ARRAY_SIZE(xgbe10_et_stats);\r\ngbe_dev->hw_stats = devm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u64),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats) {\r\ndev_err(gbe_dev->dev, "hw_stats memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngbe_dev->hw_stats_prev =\r\ndevm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats_prev) {\r\ndev_err(gbe_dev->dev,\r\n"hw_stats_prev memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngbe_dev->ss_version = XGBE_SS_VERSION_10;\r\ngbe_dev->sgmii_port_regs = gbe_dev->ss_regs +\r\nXGBE10_SGMII_MODULE_OFFSET;\r\ngbe_dev->host_port_regs = gbe_dev->ss_regs + XGBE10_HOST_PORT_OFFSET;\r\nfor (i = 0; i < gbe_dev->max_num_ports; i++)\r\ngbe_dev->hw_stats_regs[i] = gbe_dev->switch_regs +\r\nXGBE10_HW_STATS_OFFSET + (GBE_HW_STATS_REG_MAP_SZ * i);\r\ngbe_dev->ale_reg = gbe_dev->switch_regs + XGBE10_ALE_OFFSET;\r\ngbe_dev->ale_ports = gbe_dev->max_num_ports;\r\ngbe_dev->host_port = XGBE10_HOST_PORT_NUM;\r\ngbe_dev->ale_entries = XGBE10_NUM_ALE_ENTRIES;\r\ngbe_dev->stats_en_mask = (1 << (gbe_dev->max_num_ports)) - 1;\r\nXGBE_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\r\nXGBE_SET_REG_OFS(gbe_dev, ss_regs, control);\r\nXGBE_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\r\nXGBE_SET_REG_OFS(gbe_dev, switch_regs, control);\r\nXGBE_SET_REG_OFS(gbe_dev, switch_regs, ptype);\r\nXGBE_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\r\nXGBE_SET_REG_OFS(gbe_dev, switch_regs, flow_control);\r\nXGBE_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\r\nXGBE_SET_REG_OFS(gbe_dev, host_port_regs, tx_pri_map);\r\nXGBE_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\r\nreturn 0;\r\n}\r\nstatic int get_gbe_resource_version(struct gbe_priv *gbe_dev,\r\nstruct device_node *node)\r\n{\r\nstruct resource res;\r\nvoid __iomem *regs;\r\nint ret;\r\nret = of_address_to_resource(node, GBE_SS_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't translate of node(%s) of gbe ss address at %d\n",\r\nnode->name, GBE_SS_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev, "Failed to map gbe register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->ss_regs = regs;\r\ngbe_dev->ss_version = readl(gbe_dev->ss_regs);\r\nreturn 0;\r\n}\r\nstatic int set_gbe_ethss14_priv(struct gbe_priv *gbe_dev,\r\nstruct device_node *node)\r\n{\r\nstruct resource res;\r\nvoid __iomem *regs;\r\nint i, ret;\r\nret = of_address_to_resource(node, GBE_SGMII34_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't translate of gbe node(%s) address at index %d\n",\r\nnode->name, GBE_SGMII34_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev,\r\n"Failed to map gbe sgmii port34 register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->sgmii_port34_regs = regs;\r\nret = of_address_to_resource(node, GBE_SM_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't translate of gbe node(%s) address at index %d\n",\r\nnode->name, GBE_SM_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev,\r\n"Failed to map gbe switch module register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->switch_regs = regs;\r\ngbe_dev->num_stats_mods = gbe_dev->max_num_slaves;\r\ngbe_dev->et_stats = gbe13_et_stats;\r\ngbe_dev->num_et_stats = ARRAY_SIZE(gbe13_et_stats);\r\ngbe_dev->hw_stats = devm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u64),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats) {\r\ndev_err(gbe_dev->dev, "hw_stats memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngbe_dev->hw_stats_prev =\r\ndevm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats_prev) {\r\ndev_err(gbe_dev->dev,\r\n"hw_stats_prev memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngbe_dev->sgmii_port_regs = gbe_dev->ss_regs + GBE13_SGMII_MODULE_OFFSET;\r\ngbe_dev->host_port_regs = gbe_dev->switch_regs + GBE13_HOST_PORT_OFFSET;\r\nfor (i = 0; i < gbe_dev->max_num_slaves; i++) {\r\ngbe_dev->hw_stats_regs[i] =\r\ngbe_dev->switch_regs + GBE13_HW_STATS_OFFSET +\r\n(GBE_HW_STATS_REG_MAP_SZ * (i & 0x1));\r\n}\r\ngbe_dev->ale_reg = gbe_dev->switch_regs + GBE13_ALE_OFFSET;\r\ngbe_dev->ale_ports = gbe_dev->max_num_ports;\r\ngbe_dev->host_port = GBE13_HOST_PORT_NUM;\r\ngbe_dev->ale_entries = GBE13_NUM_ALE_ENTRIES;\r\ngbe_dev->stats_en_mask = GBE13_REG_VAL_STAT_ENABLE_ALL;\r\nGBE_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, control);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, soft_reset);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, ptype);\r\nGBE_SET_REG_OFS(gbe_dev, switch_regs, flow_control);\r\nGBE_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\r\nGBE_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\r\nreturn 0;\r\n}\r\nstatic int set_gbenu_ethss_priv(struct gbe_priv *gbe_dev,\r\nstruct device_node *node)\r\n{\r\nstruct resource res;\r\nvoid __iomem *regs;\r\nint i, ret;\r\ngbe_dev->num_stats_mods = gbe_dev->max_num_ports;\r\ngbe_dev->et_stats = gbenu_et_stats;\r\nif (IS_SS_ID_NU(gbe_dev))\r\ngbe_dev->num_et_stats = GBENU_ET_STATS_HOST_SIZE +\r\n(gbe_dev->max_num_slaves * GBENU_ET_STATS_PORT_SIZE);\r\nelse\r\ngbe_dev->num_et_stats = GBENU_ET_STATS_HOST_SIZE +\r\nGBENU_ET_STATS_PORT_SIZE;\r\ngbe_dev->hw_stats = devm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u64),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats) {\r\ndev_err(gbe_dev->dev, "hw_stats memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngbe_dev->hw_stats_prev =\r\ndevm_kzalloc(gbe_dev->dev,\r\ngbe_dev->num_et_stats * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!gbe_dev->hw_stats_prev) {\r\ndev_err(gbe_dev->dev,\r\n"hw_stats_prev memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_address_to_resource(node, GBENU_SM_REG_INDEX, &res);\r\nif (ret) {\r\ndev_err(gbe_dev->dev,\r\n"Can't translate of gbenu node(%s) addr at index %d\n",\r\nnode->name, GBENU_SM_REG_INDEX);\r\nreturn ret;\r\n}\r\nregs = devm_ioremap_resource(gbe_dev->dev, &res);\r\nif (IS_ERR(regs)) {\r\ndev_err(gbe_dev->dev,\r\n"Failed to map gbenu switch module register base\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ngbe_dev->switch_regs = regs;\r\ngbe_dev->sgmii_port_regs = gbe_dev->ss_regs + GBENU_SGMII_MODULE_OFFSET;\r\ngbe_dev->sgmii_port34_regs = gbe_dev->sgmii_port_regs +\r\n(2 * GBENU_SGMII_MODULE_SIZE);\r\ngbe_dev->host_port_regs = gbe_dev->switch_regs + GBENU_HOST_PORT_OFFSET;\r\nfor (i = 0; i < (gbe_dev->max_num_ports); i++)\r\ngbe_dev->hw_stats_regs[i] = gbe_dev->switch_regs +\r\nGBENU_HW_STATS_OFFSET + (GBENU_HW_STATS_REG_MAP_SZ * i);\r\ngbe_dev->ale_reg = gbe_dev->switch_regs + GBENU_ALE_OFFSET;\r\ngbe_dev->ale_ports = gbe_dev->max_num_ports;\r\ngbe_dev->host_port = GBENU_HOST_PORT_NUM;\r\ngbe_dev->ale_entries = GBE13_NUM_ALE_ENTRIES;\r\ngbe_dev->stats_en_mask = (1 << (gbe_dev->max_num_ports)) - 1;\r\nGBENU_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\r\nGBENU_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\r\nGBENU_SET_REG_OFS(gbe_dev, switch_regs, control);\r\nGBENU_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\r\nGBENU_SET_REG_OFS(gbe_dev, switch_regs, ptype);\r\nGBENU_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\r\nGBENU_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\r\nGBENU_SET_REG_OFS(gbe_dev, host_port_regs, tx_pri_map);\r\nreturn 0;\r\n}\r\nstatic int gbe_probe(struct netcp_device *netcp_device, struct device *dev,\r\nstruct device_node *node, void **inst_priv)\r\n{\r\nstruct device_node *interfaces, *interface;\r\nstruct device_node *secondary_ports;\r\nstruct cpsw_ale_params ale_params;\r\nstruct gbe_priv *gbe_dev;\r\nu32 slave_num;\r\nint i, ret = 0;\r\nif (!node) {\r\ndev_err(dev, "device tree info unavailable\n");\r\nreturn -ENODEV;\r\n}\r\ngbe_dev = devm_kzalloc(dev, sizeof(struct gbe_priv), GFP_KERNEL);\r\nif (!gbe_dev)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(node, "ti,netcp-gbe-5") ||\r\nof_device_is_compatible(node, "ti,netcp-gbe")) {\r\ngbe_dev->max_num_slaves = 4;\r\n} else if (of_device_is_compatible(node, "ti,netcp-gbe-9")) {\r\ngbe_dev->max_num_slaves = 8;\r\n} else if (of_device_is_compatible(node, "ti,netcp-gbe-2")) {\r\ngbe_dev->max_num_slaves = 1;\r\n} else if (of_device_is_compatible(node, "ti,netcp-xgbe")) {\r\ngbe_dev->max_num_slaves = 2;\r\n} else {\r\ndev_err(dev, "device tree node for unknown device\n");\r\nreturn -EINVAL;\r\n}\r\ngbe_dev->max_num_ports = gbe_dev->max_num_slaves + 1;\r\ngbe_dev->dev = dev;\r\ngbe_dev->netcp_device = netcp_device;\r\ngbe_dev->rx_packet_max = NETCP_MAX_FRAME_SIZE;\r\nspin_lock_init(&gbe_dev->hw_stats_lock);\r\nif (of_find_property(node, "enable-ale", NULL)) {\r\ngbe_dev->enable_ale = true;\r\ndev_info(dev, "ALE enabled\n");\r\n} else {\r\ngbe_dev->enable_ale = false;\r\ndev_dbg(dev, "ALE bypass enabled*\n");\r\n}\r\nret = of_property_read_u32(node, "tx-queue",\r\n&gbe_dev->tx_queue_id);\r\nif (ret < 0) {\r\ndev_err(dev, "missing tx_queue parameter\n");\r\ngbe_dev->tx_queue_id = GBE_TX_QUEUE;\r\n}\r\nret = of_property_read_string(node, "tx-channel",\r\n&gbe_dev->dma_chan_name);\r\nif (ret < 0) {\r\ndev_err(dev, "missing \"tx-channel\" parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (!strcmp(node->name, "gbe")) {\r\nret = get_gbe_resource_version(gbe_dev, node);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(dev, "ss_version: 0x%08x\n", gbe_dev->ss_version);\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14)\r\nret = set_gbe_ethss14_priv(gbe_dev, node);\r\nelse if (IS_SS_ID_MU(gbe_dev))\r\nret = set_gbenu_ethss_priv(gbe_dev, node);\r\nelse\r\nret = -ENODEV;\r\n} else if (!strcmp(node->name, "xgbe")) {\r\nret = set_xgbe_ethss10_priv(gbe_dev, node);\r\nif (ret)\r\nreturn ret;\r\nret = netcp_xgbe_serdes_init(gbe_dev->xgbe_serdes_regs,\r\ngbe_dev->ss_regs);\r\n} else {\r\ndev_err(dev, "unknown GBE node(%s)\n", node->name);\r\nret = -ENODEV;\r\n}\r\nif (ret)\r\nreturn ret;\r\ninterfaces = of_get_child_by_name(node, "interfaces");\r\nif (!interfaces)\r\ndev_err(dev, "could not find interfaces\n");\r\nret = netcp_txpipe_init(&gbe_dev->tx_pipe, netcp_device,\r\ngbe_dev->dma_chan_name, gbe_dev->tx_queue_id);\r\nif (ret)\r\nreturn ret;\r\nret = netcp_txpipe_open(&gbe_dev->tx_pipe);\r\nif (ret)\r\nreturn ret;\r\nINIT_LIST_HEAD(&gbe_dev->gbe_intf_head);\r\nfor_each_child_of_node(interfaces, interface) {\r\nret = of_property_read_u32(interface, "slave-port", &slave_num);\r\nif (ret) {\r\ndev_err(dev, "missing slave-port parameter, skipping interface configuration for %s\n",\r\ninterface->name);\r\ncontinue;\r\n}\r\ngbe_dev->num_slaves++;\r\nif (gbe_dev->num_slaves >= gbe_dev->max_num_slaves) {\r\nof_node_put(interface);\r\nbreak;\r\n}\r\n}\r\nof_node_put(interfaces);\r\nif (!gbe_dev->num_slaves)\r\ndev_warn(dev, "No network interface configured\n");\r\nsecondary_ports = of_get_child_by_name(node, "secondary-slave-ports");\r\nINIT_LIST_HEAD(&gbe_dev->secondary_slaves);\r\nif (secondary_ports && (gbe_dev->num_slaves < gbe_dev->max_num_slaves))\r\ninit_secondary_ports(gbe_dev, secondary_ports);\r\nof_node_put(secondary_ports);\r\nif (!gbe_dev->num_slaves) {\r\ndev_err(dev,\r\n"No network interface or secondary ports configured\n");\r\nret = -ENODEV;\r\ngoto free_sec_ports;\r\n}\r\nmemset(&ale_params, 0, sizeof(ale_params));\r\nale_params.dev = gbe_dev->dev;\r\nale_params.ale_regs = gbe_dev->ale_reg;\r\nale_params.ale_ageout = GBE_DEFAULT_ALE_AGEOUT;\r\nale_params.ale_entries = gbe_dev->ale_entries;\r\nale_params.ale_ports = gbe_dev->ale_ports;\r\ngbe_dev->ale = cpsw_ale_create(&ale_params);\r\nif (!gbe_dev->ale) {\r\ndev_err(gbe_dev->dev, "error initializing ale engine\n");\r\nret = -ENODEV;\r\ngoto free_sec_ports;\r\n} else {\r\ndev_dbg(gbe_dev->dev, "Created a gbe ale engine\n");\r\n}\r\ngbe_init_host_port(gbe_dev);\r\nspin_lock_bh(&gbe_dev->hw_stats_lock);\r\nfor (i = 0; i < gbe_dev->num_stats_mods; i++) {\r\nif (gbe_dev->ss_version == GBE_SS_VERSION_14)\r\ngbe_reset_mod_stats_ver14(gbe_dev, i);\r\nelse\r\ngbe_reset_mod_stats(gbe_dev, i);\r\n}\r\nspin_unlock_bh(&gbe_dev->hw_stats_lock);\r\ninit_timer(&gbe_dev->timer);\r\ngbe_dev->timer.data = (unsigned long)gbe_dev;\r\ngbe_dev->timer.function = netcp_ethss_timer;\r\ngbe_dev->timer.expires = jiffies + GBE_TIMER_INTERVAL;\r\nadd_timer(&gbe_dev->timer);\r\n*inst_priv = gbe_dev;\r\nreturn 0;\r\nfree_sec_ports:\r\nfree_secondary_ports(gbe_dev);\r\nreturn ret;\r\n}\r\nstatic int gbe_attach(void *inst_priv, struct net_device *ndev,\r\nstruct device_node *node, void **intf_priv)\r\n{\r\nstruct gbe_priv *gbe_dev = inst_priv;\r\nstruct gbe_intf *gbe_intf;\r\nint ret;\r\nif (!node) {\r\ndev_err(gbe_dev->dev, "interface node not available\n");\r\nreturn -ENODEV;\r\n}\r\ngbe_intf = devm_kzalloc(gbe_dev->dev, sizeof(*gbe_intf), GFP_KERNEL);\r\nif (!gbe_intf)\r\nreturn -ENOMEM;\r\ngbe_intf->ndev = ndev;\r\ngbe_intf->dev = gbe_dev->dev;\r\ngbe_intf->gbe_dev = gbe_dev;\r\ngbe_intf->slave = devm_kzalloc(gbe_dev->dev,\r\nsizeof(*gbe_intf->slave),\r\nGFP_KERNEL);\r\nif (!gbe_intf->slave) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (init_slave(gbe_dev, gbe_intf->slave, node)) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\ngbe_intf->tx_pipe = gbe_dev->tx_pipe;\r\nndev->ethtool_ops = &keystone_ethtool_ops;\r\nlist_add_tail(&gbe_intf->gbe_intf_list, &gbe_dev->gbe_intf_head);\r\n*intf_priv = gbe_intf;\r\nreturn 0;\r\nfail:\r\nif (gbe_intf->slave)\r\ndevm_kfree(gbe_dev->dev, gbe_intf->slave);\r\nif (gbe_intf)\r\ndevm_kfree(gbe_dev->dev, gbe_intf);\r\nreturn ret;\r\n}\r\nstatic int gbe_release(void *intf_priv)\r\n{\r\nstruct gbe_intf *gbe_intf = intf_priv;\r\ngbe_intf->ndev->ethtool_ops = NULL;\r\nlist_del(&gbe_intf->gbe_intf_list);\r\ndevm_kfree(gbe_intf->dev, gbe_intf->slave);\r\ndevm_kfree(gbe_intf->dev, gbe_intf);\r\nreturn 0;\r\n}\r\nstatic int gbe_remove(struct netcp_device *netcp_device, void *inst_priv)\r\n{\r\nstruct gbe_priv *gbe_dev = inst_priv;\r\ndel_timer_sync(&gbe_dev->timer);\r\ncpsw_ale_stop(gbe_dev->ale);\r\ncpsw_ale_destroy(gbe_dev->ale);\r\nnetcp_txpipe_close(&gbe_dev->tx_pipe);\r\nfree_secondary_ports(gbe_dev);\r\nif (!list_empty(&gbe_dev->gbe_intf_head))\r\ndev_alert(gbe_dev->dev,\r\n"unreleased ethss interfaces present\n");\r\nreturn 0;\r\n}\r\nstatic int __init keystone_gbe_init(void)\r\n{\r\nint ret;\r\nret = netcp_register_module(&gbe_module);\r\nif (ret)\r\nreturn ret;\r\nret = netcp_register_module(&xgbe_module);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit keystone_gbe_exit(void)\r\n{\r\nnetcp_unregister_module(&gbe_module);\r\nnetcp_unregister_module(&xgbe_module);\r\n}
