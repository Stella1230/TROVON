static void hix5hd2_ir_enable(struct hix5hd2_ir_priv *dev, bool on)\r\n{\r\nu32 val;\r\nregmap_read(dev->regmap, IR_CLK, &val);\r\nif (on) {\r\nval &= ~IR_CLK_RESET;\r\nval |= IR_CLK_ENABLE;\r\n} else {\r\nval &= ~IR_CLK_ENABLE;\r\nval |= IR_CLK_RESET;\r\n}\r\nregmap_write(dev->regmap, IR_CLK, val);\r\n}\r\nstatic int hix5hd2_ir_config(struct hix5hd2_ir_priv *priv)\r\n{\r\nint timeout = 10000;\r\nu32 val, rate;\r\nwritel_relaxed(0x01, priv->base + IR_ENABLE);\r\nwhile (readl_relaxed(priv->base + IR_BUSY)) {\r\nif (timeout--) {\r\nudelay(1);\r\n} else {\r\ndev_err(priv->dev, "IR_BUSY timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nrate = DIV_ROUND_CLOSEST(priv->rate, 1000000);\r\nval = IR_CFG_SYMBOL_MAXWIDTH & IR_CFG_WIDTH_MASK << IR_CFG_WIDTH_SHIFT;\r\nval |= IR_CFG_SYMBOL_FMT & IR_CFG_FORMAT_MASK << IR_CFG_FORMAT_SHIFT;\r\nval |= (IR_CFG_INT_THRESHOLD - 1) & IR_CFG_INT_LEVEL_MASK\r\n<< IR_CFG_INT_LEVEL_SHIFT;\r\nval |= IR_CFG_MODE_RAW;\r\nval |= (rate - 1) & IR_CFG_FREQ_MASK << IR_CFG_FREQ_SHIFT;\r\nwritel_relaxed(val, priv->base + IR_CONFIG);\r\nwritel_relaxed(0x00, priv->base + IR_INTM);\r\nwritel_relaxed(0x01, priv->base + IR_START);\r\nreturn 0;\r\n}\r\nstatic int hix5hd2_ir_open(struct rc_dev *rdev)\r\n{\r\nstruct hix5hd2_ir_priv *priv = rdev->priv;\r\nhix5hd2_ir_enable(priv, true);\r\nreturn hix5hd2_ir_config(priv);\r\n}\r\nstatic void hix5hd2_ir_close(struct rc_dev *rdev)\r\n{\r\nstruct hix5hd2_ir_priv *priv = rdev->priv;\r\nhix5hd2_ir_enable(priv, false);\r\n}\r\nstatic irqreturn_t hix5hd2_ir_rx_interrupt(int irq, void *data)\r\n{\r\nu32 symb_num, symb_val, symb_time;\r\nu32 data_l, data_h;\r\nu32 irq_sr, i;\r\nstruct hix5hd2_ir_priv *priv = data;\r\nirq_sr = readl_relaxed(priv->base + IR_INTS);\r\nif (irq_sr & INTMS_OVERFLOW) {\r\nir_raw_event_reset(priv->rdev);\r\nsymb_num = readl_relaxed(priv->base + IR_DATAH);\r\nfor (i = 0; i < symb_num; i++)\r\nreadl_relaxed(priv->base + IR_DATAL);\r\nwritel_relaxed(INT_CLR_OVERFLOW, priv->base + IR_INTC);\r\ndev_info(priv->dev, "overflow, level=%d\n",\r\nIR_CFG_INT_THRESHOLD);\r\n}\r\nif ((irq_sr & INTMS_SYMBRCV) || (irq_sr & INTMS_TIMEOUT)) {\r\nDEFINE_IR_RAW_EVENT(ev);\r\nsymb_num = readl_relaxed(priv->base + IR_DATAH);\r\nfor (i = 0; i < symb_num; i++) {\r\nsymb_val = readl_relaxed(priv->base + IR_DATAL);\r\ndata_l = ((symb_val & 0xffff) * 10);\r\ndata_h = ((symb_val >> 16) & 0xffff) * 10;\r\nsymb_time = (data_l + data_h) / 10;\r\nev.duration = US_TO_NS(data_l);\r\nev.pulse = true;\r\nir_raw_event_store(priv->rdev, &ev);\r\nif (symb_time < IR_CFG_SYMBOL_MAXWIDTH) {\r\nev.duration = US_TO_NS(data_h);\r\nev.pulse = false;\r\nir_raw_event_store(priv->rdev, &ev);\r\n} else {\r\nir_raw_event_set_idle(priv->rdev, true);\r\n}\r\n}\r\nif (irq_sr & INTMS_SYMBRCV)\r\nwritel_relaxed(INT_CLR_RCV, priv->base + IR_INTC);\r\nif (irq_sr & INTMS_TIMEOUT)\r\nwritel_relaxed(INT_CLR_TIMEOUT, priv->base + IR_INTC);\r\n}\r\nir_raw_event_handle(priv->rdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hix5hd2_ir_probe(struct platform_device *pdev)\r\n{\r\nstruct rc_dev *rdev;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct hix5hd2_ir_priv *priv;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst char *map_name;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = syscon_regmap_lookup_by_phandle(node,\r\n"hisilicon,power-syscon");\r\nif (IS_ERR(priv->regmap)) {\r\ndev_err(dev, "no power-reg\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq < 0) {\r\ndev_err(dev, "irq can not get\n");\r\nreturn priv->irq;\r\n}\r\nrdev = rc_allocate_device();\r\nif (!rdev)\r\nreturn -ENOMEM;\r\npriv->clock = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clock)) {\r\ndev_err(dev, "clock not found\n");\r\nret = PTR_ERR(priv->clock);\r\ngoto err;\r\n}\r\nclk_prepare_enable(priv->clock);\r\npriv->rate = clk_get_rate(priv->clock);\r\nrdev->driver_type = RC_DRIVER_IR_RAW;\r\nrdev->allowed_protocols = RC_BIT_ALL;\r\nrdev->priv = priv;\r\nrdev->open = hix5hd2_ir_open;\r\nrdev->close = hix5hd2_ir_close;\r\nrdev->driver_name = IR_HIX5HD2_NAME;\r\nmap_name = of_get_property(node, "linux,rc-map-name", NULL);\r\nrdev->map_name = map_name ?: RC_MAP_EMPTY;\r\nrdev->input_name = IR_HIX5HD2_NAME;\r\nrdev->input_phys = IR_HIX5HD2_NAME "/input0";\r\nrdev->input_id.bustype = BUS_HOST;\r\nrdev->input_id.vendor = 0x0001;\r\nrdev->input_id.product = 0x0001;\r\nrdev->input_id.version = 0x0100;\r\nrdev->rx_resolution = US_TO_NS(10);\r\nrdev->timeout = US_TO_NS(IR_CFG_SYMBOL_MAXWIDTH * 10);\r\nret = rc_register_device(rdev);\r\nif (ret < 0)\r\ngoto clkerr;\r\nif (devm_request_irq(dev, priv->irq, hix5hd2_ir_rx_interrupt,\r\n0, pdev->name, priv) < 0) {\r\ndev_err(dev, "IRQ %d register failed\n", priv->irq);\r\nret = -EINVAL;\r\ngoto regerr;\r\n}\r\npriv->rdev = rdev;\r\npriv->dev = dev;\r\nplatform_set_drvdata(pdev, priv);\r\nreturn ret;\r\nregerr:\r\nrc_unregister_device(rdev);\r\nrdev = NULL;\r\nclkerr:\r\nclk_disable_unprepare(priv->clock);\r\nerr:\r\nrc_free_device(rdev);\r\ndev_err(dev, "Unable to register device (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hix5hd2_ir_remove(struct platform_device *pdev)\r\n{\r\nstruct hix5hd2_ir_priv *priv = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(priv->clock);\r\nrc_unregister_device(priv->rdev);\r\nreturn 0;\r\n}\r\nstatic int hix5hd2_ir_suspend(struct device *dev)\r\n{\r\nstruct hix5hd2_ir_priv *priv = dev_get_drvdata(dev);\r\nclk_disable_unprepare(priv->clock);\r\nhix5hd2_ir_enable(priv, false);\r\nreturn 0;\r\n}\r\nstatic int hix5hd2_ir_resume(struct device *dev)\r\n{\r\nstruct hix5hd2_ir_priv *priv = dev_get_drvdata(dev);\r\nhix5hd2_ir_enable(priv, true);\r\nclk_prepare_enable(priv->clock);\r\nwritel_relaxed(0x01, priv->base + IR_ENABLE);\r\nwritel_relaxed(0x00, priv->base + IR_INTM);\r\nwritel_relaxed(0xff, priv->base + IR_INTC);\r\nwritel_relaxed(0x01, priv->base + IR_START);\r\nreturn 0;\r\n}
