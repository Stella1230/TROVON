static void dbg_hcs_params(struct ehci_hcd *ehci, char *label)\r\n{\r\nu32 params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nehci_dbg(ehci,\r\n"%s hcs_params 0x%x dbg=%d%s cc=%d pcc=%d%s%s ports=%d\n",\r\nlabel, params,\r\nHCS_DEBUG_PORT(params),\r\nHCS_INDICATOR(params) ? " ind" : "",\r\nHCS_N_CC(params),\r\nHCS_N_PCC(params),\r\nHCS_PORTROUTED(params) ? "" : " ordered",\r\nHCS_PPC(params) ? "" : " !ppc",\r\nHCS_N_PORTS(params));\r\nif (HCS_PORTROUTED(params)) {\r\nint i;\r\nchar buf[46], tmp[7], byte;\r\nbuf[0] = 0;\r\nfor (i = 0; i < HCS_N_PORTS(params); i++) {\r\nbyte = readb(&ehci->caps->portroute[(i >> 1)]);\r\nsprintf(tmp, "%d ",\r\n(i & 0x1) ? byte & 0xf : (byte >> 4) & 0xf);\r\nstrcat(buf, tmp);\r\n}\r\nehci_dbg(ehci, "%s portroute %s\n", label, buf);\r\n}\r\n}\r\nstatic void dbg_hcc_params(struct ehci_hcd *ehci, char *label)\r\n{\r\nu32 params = ehci_readl(ehci, &ehci->caps->hcc_params);\r\nif (HCC_ISOC_CACHE(params)) {\r\nehci_dbg(ehci,\r\n"%s hcc_params %04x caching frame %s%s%s\n",\r\nlabel, params,\r\nHCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",\r\nHCC_CANPARK(params) ? " park" : "",\r\nHCC_64BIT_ADDR(params) ? " 64 bit addr" : "");\r\n} else {\r\nehci_dbg(ehci,\r\n"%s hcc_params %04x thresh %d uframes %s%s%s%s%s%s%s\n",\r\nlabel,\r\nparams,\r\nHCC_ISOC_THRES(params),\r\nHCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",\r\nHCC_CANPARK(params) ? " park" : "",\r\nHCC_64BIT_ADDR(params) ? " 64 bit addr" : "",\r\nHCC_LPM(params) ? " LPM" : "",\r\nHCC_PER_PORT_CHANGE_EVENT(params) ? " ppce" : "",\r\nHCC_HW_PREFETCH(params) ? " hw prefetch" : "",\r\nHCC_32FRAME_PERIODIC_LIST(params) ?\r\n" 32 periodic list" : "");\r\n}\r\n}\r\nstatic void __maybe_unused\r\ndbg_qtd(const char *label, struct ehci_hcd *ehci, struct ehci_qtd *qtd)\r\n{\r\nehci_dbg(ehci, "%s td %p n%08x %08x t%08x p0=%08x\n", label, qtd,\r\nhc32_to_cpup(ehci, &qtd->hw_next),\r\nhc32_to_cpup(ehci, &qtd->hw_alt_next),\r\nhc32_to_cpup(ehci, &qtd->hw_token),\r\nhc32_to_cpup(ehci, &qtd->hw_buf[0]));\r\nif (qtd->hw_buf[1])\r\nehci_dbg(ehci, " p1=%08x p2=%08x p3=%08x p4=%08x\n",\r\nhc32_to_cpup(ehci, &qtd->hw_buf[1]),\r\nhc32_to_cpup(ehci, &qtd->hw_buf[2]),\r\nhc32_to_cpup(ehci, &qtd->hw_buf[3]),\r\nhc32_to_cpup(ehci, &qtd->hw_buf[4]));\r\n}\r\nstatic void __maybe_unused\r\ndbg_qh(const char *label, struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nehci_dbg(ehci, "%s qh %p n%08x info %x %x qtd %x\n", label,\r\nqh, hw->hw_next, hw->hw_info1, hw->hw_info2, hw->hw_current);\r\ndbg_qtd("overlay", ehci, (struct ehci_qtd *) &hw->hw_qtd_next);\r\n}\r\nstatic void __maybe_unused\r\ndbg_itd(const char *label, struct ehci_hcd *ehci, struct ehci_itd *itd)\r\n{\r\nehci_dbg(ehci, "%s [%d] itd %p, next %08x, urb %p\n",\r\nlabel, itd->frame, itd, hc32_to_cpu(ehci, itd->hw_next),\r\nitd->urb);\r\nehci_dbg(ehci,\r\n" trans: %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(ehci, itd->hw_transaction[0]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[1]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[2]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[3]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[4]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[5]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[6]),\r\nhc32_to_cpu(ehci, itd->hw_transaction[7]));\r\nehci_dbg(ehci,\r\n" buf: %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(ehci, itd->hw_bufp[0]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[1]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[2]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[3]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[4]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[5]),\r\nhc32_to_cpu(ehci, itd->hw_bufp[6]));\r\nehci_dbg(ehci, " index: %d %d %d %d %d %d %d %d\n",\r\nitd->index[0], itd->index[1], itd->index[2],\r\nitd->index[3], itd->index[4], itd->index[5],\r\nitd->index[6], itd->index[7]);\r\n}\r\nstatic void __maybe_unused\r\ndbg_sitd(const char *label, struct ehci_hcd *ehci, struct ehci_sitd *sitd)\r\n{\r\nehci_dbg(ehci, "%s [%d] sitd %p, next %08x, urb %p\n",\r\nlabel, sitd->frame, sitd, hc32_to_cpu(ehci, sitd->hw_next),\r\nsitd->urb);\r\nehci_dbg(ehci,\r\n" addr %08x sched %04x result %08x buf %08x %08x\n",\r\nhc32_to_cpu(ehci, sitd->hw_fullspeed_ep),\r\nhc32_to_cpu(ehci, sitd->hw_uframe),\r\nhc32_to_cpu(ehci, sitd->hw_results),\r\nhc32_to_cpu(ehci, sitd->hw_buf[0]),\r\nhc32_to_cpu(ehci, sitd->hw_buf[1]));\r\n}\r\nstatic int __maybe_unused\r\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\r\n{\r\nreturn scnprintf(buf, len,\r\n"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", status,\r\n(status & STS_PPCE_MASK) ? " PPCE" : "",\r\n(status & STS_ASS) ? " Async" : "",\r\n(status & STS_PSS) ? " Periodic" : "",\r\n(status & STS_RECL) ? " Recl" : "",\r\n(status & STS_HALT) ? " Halt" : "",\r\n(status & STS_IAA) ? " IAA" : "",\r\n(status & STS_FATAL) ? " FATAL" : "",\r\n(status & STS_FLR) ? " FLR" : "",\r\n(status & STS_PCD) ? " PCD" : "",\r\n(status & STS_ERR) ? " ERR" : "",\r\n(status & STS_INT) ? " INT" : "");\r\n}\r\nstatic int __maybe_unused\r\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\r\n{\r\nreturn scnprintf(buf, len,\r\n"%s%sintrenable %02x%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", enable,\r\n(enable & STS_PPCE_MASK) ? " PPCE" : "",\r\n(enable & STS_IAA) ? " IAA" : "",\r\n(enable & STS_FATAL) ? " FATAL" : "",\r\n(enable & STS_FLR) ? " FLR" : "",\r\n(enable & STS_PCD) ? " PCD" : "",\r\n(enable & STS_ERR) ? " ERR" : "",\r\n(enable & STS_INT) ? " INT" : "");\r\n}\r\nstatic int\r\ndbg_command_buf(char *buf, unsigned len, const char *label, u32 command)\r\n{\r\nreturn scnprintf(buf, len,\r\n"%s%scommand %07x %s%s%s%s%s%s=%d ithresh=%d%s%s%s%s "\r\n"period=%s%s %s",\r\nlabel, label[0] ? " " : "", command,\r\n(command & CMD_HIRD) ? " HIRD" : "",\r\n(command & CMD_PPCEE) ? " PPCEE" : "",\r\n(command & CMD_FSP) ? " FSP" : "",\r\n(command & CMD_ASPE) ? " ASPE" : "",\r\n(command & CMD_PSPE) ? " PSPE" : "",\r\n(command & CMD_PARK) ? " park" : "(park)",\r\nCMD_PARK_CNT(command),\r\n(command >> 16) & 0x3f,\r\n(command & CMD_LRESET) ? " LReset" : "",\r\n(command & CMD_IAAD) ? " IAAD" : "",\r\n(command & CMD_ASE) ? " Async" : "",\r\n(command & CMD_PSE) ? " Periodic" : "",\r\nfls_strings[(command >> 2) & 0x3],\r\n(command & CMD_RESET) ? " Reset" : "",\r\n(command & CMD_RUN) ? "RUN" : "HALT");\r\n}\r\nstatic int\r\ndbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)\r\n{\r\nchar *sig;\r\nswitch (status & (3 << 10)) {\r\ncase 0 << 10:\r\nsig = "se0";\r\nbreak;\r\ncase 1 << 10:\r\nsig = "k";\r\nbreak;\r\ncase 2 << 10:\r\nsig = "j";\r\nbreak;\r\ndefault:\r\nsig = "?";\r\nbreak;\r\n}\r\nreturn scnprintf(buf, len,\r\n"%s%sport:%d status %06x %d %s%s%s%s%s%s "\r\n"sig=%s%s%s%s%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", port, status,\r\nstatus >> 25,\r\n(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_ACK ?\r\n" ACK" : "",\r\n(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_NYET ?\r\n" NYET" : "",\r\n(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_STALL ?\r\n" STALL" : "",\r\n(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_ERR ?\r\n" ERR" : "",\r\n(status & PORT_POWER) ? " POWER" : "",\r\n(status & PORT_OWNER) ? " OWNER" : "",\r\nsig,\r\n(status & PORT_LPM) ? " LPM" : "",\r\n(status & PORT_RESET) ? " RESET" : "",\r\n(status & PORT_SUSPEND) ? " SUSPEND" : "",\r\n(status & PORT_RESUME) ? " RESUME" : "",\r\n(status & PORT_OCC) ? " OCC" : "",\r\n(status & PORT_OC) ? " OC" : "",\r\n(status & PORT_PEC) ? " PEC" : "",\r\n(status & PORT_PE) ? " PE" : "",\r\n(status & PORT_CSC) ? " CSC" : "",\r\n(status & PORT_CONNECT) ? " CONNECT" : "");\r\n}\r\nstatic inline void\r\ndbg_status(struct ehci_hcd *ehci, const char *label, u32 status)\r\n{\r\nchar buf[80];\r\ndbg_status_buf(buf, sizeof(buf), label, status);\r\nehci_dbg(ehci, "%s\n", buf);\r\n}\r\nstatic inline void\r\ndbg_cmd(struct ehci_hcd *ehci, const char *label, u32 command)\r\n{\r\nchar buf[80];\r\ndbg_command_buf(buf, sizeof(buf), label, command);\r\nehci_dbg(ehci, "%s\n", buf);\r\n}\r\nstatic inline void\r\ndbg_port(struct ehci_hcd *ehci, const char *label, int port, u32 status)\r\n{\r\nchar buf[80];\r\ndbg_port_buf(buf, sizeof(buf), label, port, status);\r\nehci_dbg(ehci, "%s\n", buf);\r\n}\r\nstatic inline char speed_char(u32 info1)\r\n{\r\nswitch (info1 & (3 << 12)) {\r\ncase QH_FULL_SPEED:\r\nreturn 'f';\r\ncase QH_LOW_SPEED:\r\nreturn 'l';\r\ncase QH_HIGH_SPEED:\r\nreturn 'h';\r\ndefault:\r\nreturn '?';\r\n}\r\n}\r\nstatic inline char token_mark(struct ehci_hcd *ehci, __hc32 token)\r\n{\r\n__u32 v = hc32_to_cpu(ehci, token);\r\nif (v & QTD_STS_ACTIVE)\r\nreturn '*';\r\nif (v & QTD_STS_HALT)\r\nreturn '-';\r\nif (!IS_SHORT_READ(v))\r\nreturn ' ';\r\nreturn '/';\r\n}\r\nstatic void qh_lines(struct ehci_hcd *ehci, struct ehci_qh *qh,\r\nchar **nextp, unsigned *sizep)\r\n{\r\nu32 scratch;\r\nu32 hw_curr;\r\nstruct list_head *entry;\r\nstruct ehci_qtd *td;\r\nunsigned temp;\r\nunsigned size = *sizep;\r\nchar *next = *nextp;\r\nchar mark;\r\n__le32 list_end = EHCI_LIST_END(ehci);\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nif (hw->hw_qtd_next == list_end)\r\nmark = '@';\r\nelse\r\nmark = token_mark(ehci, hw->hw_token);\r\nif (mark == '/') {\r\nif ((hw->hw_alt_next & QTD_MASK(ehci))\r\n== ehci->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (hw->hw_alt_next == list_end)\r\nmark = '.';\r\n}\r\nscratch = hc32_to_cpup(ehci, &hw->hw_info1);\r\nhw_curr = (mark == '*') ? hc32_to_cpup(ehci, &hw->hw_current) : 0;\r\ntemp = scnprintf(next, size,\r\n"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)"\r\n" [cur %08x next %08x buf[0] %08x]",\r\nqh, scratch & 0x007f,\r\nspeed_char (scratch),\r\n(scratch >> 8) & 0x000f,\r\nscratch, hc32_to_cpup(ehci, &hw->hw_info2),\r\nhc32_to_cpup(ehci, &hw->hw_token), mark,\r\n(cpu_to_hc32(ehci, QTD_TOGGLE) & hw->hw_token)\r\n? "data1" : "data0",\r\n(hc32_to_cpup(ehci, &hw->hw_alt_next) >> 1) & 0x0f,\r\nhc32_to_cpup(ehci, &hw->hw_current),\r\nhc32_to_cpup(ehci, &hw->hw_qtd_next),\r\nhc32_to_cpup(ehci, &hw->hw_buf[0]));\r\nsize -= temp;\r\nnext += temp;\r\nlist_for_each(entry, &qh->qtd_list) {\r\nchar *type;\r\ntd = list_entry(entry, struct ehci_qtd, qtd_list);\r\nscratch = hc32_to_cpup(ehci, &td->hw_token);\r\nmark = ' ';\r\nif (hw_curr == td->qtd_dma) {\r\nmark = '*';\r\n} else if (hw->hw_qtd_next == cpu_to_hc32(ehci, td->qtd_dma)) {\r\nmark = '+';\r\n} else if (QTD_LENGTH(scratch)) {\r\nif (td->hw_alt_next == ehci->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (td->hw_alt_next != list_end)\r\nmark = '/';\r\n}\r\nswitch ((scratch >> 8) & 0x03) {\r\ncase 0:\r\ntype = "out";\r\nbreak;\r\ncase 1:\r\ntype = "in";\r\nbreak;\r\ncase 2:\r\ntype = "setup";\r\nbreak;\r\ndefault:\r\ntype = "?";\r\nbreak;\r\n}\r\ntemp = scnprintf(next, size,\r\n"\n\t%p%c%s len=%d %08x urb %p"\r\n" [td %08x buf[0] %08x]",\r\ntd, mark, type,\r\n(scratch >> 16) & 0x7fff,\r\nscratch,\r\ntd->urb,\r\n(u32) td->qtd_dma,\r\nhc32_to_cpup(ehci, &td->hw_buf[0]));\r\nsize -= temp;\r\nnext += temp;\r\nif (temp == size)\r\ngoto done;\r\n}\r\ntemp = scnprintf(next, size, "\n");\r\nsize -= temp;\r\nnext += temp;\r\ndone:\r\n*sizep = size;\r\n*nextp = next;\r\n}\r\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nunsigned long flags;\r\nunsigned temp, size;\r\nchar *next;\r\nstruct ehci_qh *qh;\r\nhcd = bus_to_hcd(buf->bus);\r\nehci = hcd_to_ehci(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\n*next = 0;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nfor (qh = ehci->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh)\r\nqh_lines(ehci, qh, &next, &size);\r\nif (!list_empty(&ehci->async_unlink) && size > 0) {\r\ntemp = scnprintf(next, size, "\nunlink =\n");\r\nsize -= temp;\r\nnext += temp;\r\nlist_for_each_entry(qh, &ehci->async_unlink, unlink_node) {\r\nif (size <= 0)\r\nbreak;\r\nqh_lines(ehci, qh, &next, &size);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn strlen(buf->output_buf);\r\n}\r\nstatic ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)\r\n{\r\nstruct ehci_hcd *ehci;\r\nstruct ehci_tt *tt;\r\nstruct ehci_per_sched *ps;\r\nunsigned temp, size;\r\nchar *next;\r\nunsigned i;\r\nu8 *bw;\r\nu16 *bf;\r\nu8 budget[EHCI_BANDWIDTH_SIZE];\r\nehci = hcd_to_ehci(bus_to_hcd(buf->bus));\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\n*next = 0;\r\nspin_lock_irq(&ehci->lock);\r\ntemp = scnprintf(next, size,\r\n"HS bandwidth allocation (us per microframe)\n");\r\nsize -= temp;\r\nnext += temp;\r\nfor (i = 0; i < EHCI_BANDWIDTH_SIZE; i += 8) {\r\nbw = &ehci->bandwidth[i];\r\ntemp = scnprintf(next, size,\r\n"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",\r\ni, bw[0], bw[1], bw[2], bw[3],\r\nbw[4], bw[5], bw[6], bw[7]);\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nlist_for_each_entry(tt, &ehci->tt_list, tt_list) {\r\ntemp = scnprintf(next, size,\r\n"\nTT %s port %d FS/LS bandwidth allocation (us per frame)\n",\r\ndev_name(&tt->usb_tt->hub->dev),\r\ntt->tt_port + !!tt->usb_tt->multi);\r\nsize -= temp;\r\nnext += temp;\r\nbf = tt->bandwidth;\r\ntemp = scnprintf(next, size,\r\n" %5u%5u%5u%5u%5u%5u%5u%5u\n",\r\nbf[0], bf[1], bf[2], bf[3],\r\nbf[4], bf[5], bf[6], bf[7]);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf(next, size,\r\n"FS/LS budget (us per microframe)\n");\r\nsize -= temp;\r\nnext += temp;\r\ncompute_tt_budget(budget, tt);\r\nfor (i = 0; i < EHCI_BANDWIDTH_SIZE; i += 8) {\r\nbw = &budget[i];\r\ntemp = scnprintf(next, size,\r\n"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",\r\ni, bw[0], bw[1], bw[2], bw[3],\r\nbw[4], bw[5], bw[6], bw[7]);\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nlist_for_each_entry(ps, &tt->ps_list, ps_list) {\r\ntemp = scnprintf(next, size,\r\n"%s ep %02x: %4u @ %2u.%u+%u mask %04x\n",\r\ndev_name(&ps->udev->dev),\r\nps->ep->desc.bEndpointAddress,\r\nps->tt_usecs,\r\nps->bw_phase, ps->phase_uf,\r\nps->bw_period, ps->cs_mask);\r\nsize -= temp;\r\nnext += temp;\r\n}\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nreturn next - buf->output_buf;\r\n}\r\nstatic unsigned output_buf_tds_dir(char *buf, struct ehci_hcd *ehci,\r\nstruct ehci_qh_hw *hw, struct ehci_qh *qh, unsigned size)\r\n{\r\nu32 scratch = hc32_to_cpup(ehci, &hw->hw_info1);\r\nstruct ehci_qtd *qtd;\r\nchar *type = "";\r\nunsigned temp = 0;\r\nlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\r\ntemp++;\r\nswitch ((hc32_to_cpu(ehci, qtd->hw_token) >> 8) & 0x03) {\r\ncase 0:\r\ntype = "out";\r\ncontinue;\r\ncase 1:\r\ntype = "in";\r\ncontinue;\r\n}\r\n}\r\nreturn scnprintf(buf, size, " (%c%d ep%d%s [%d/%d] q%d p%d)",\r\nspeed_char(scratch), scratch & 0x007f,\r\n(scratch >> 8) & 0x000f, type, qh->ps.usecs,\r\nqh->ps.c_usecs, temp, 0x7ff & (scratch >> 16));\r\n}\r\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nunsigned long flags;\r\nunion ehci_shadow p, *seen;\r\nunsigned temp, size, seen_count;\r\nchar *next;\r\nunsigned i;\r\n__hc32 tag;\r\nseen = kmalloc_array(DBG_SCHED_LIMIT, sizeof(*seen), GFP_ATOMIC);\r\nif (!seen)\r\nreturn 0;\r\nseen_count = 0;\r\nhcd = bus_to_hcd(buf->bus);\r\nehci = hcd_to_ehci(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\ntemp = scnprintf(next, size, "size = %d\n", ehci->periodic_size);\r\nsize -= temp;\r\nnext += temp;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nfor (i = 0; i < ehci->periodic_size; i++) {\r\np = ehci->pshadow[i];\r\nif (likely(!p.ptr))\r\ncontinue;\r\ntag = Q_NEXT_TYPE(ehci, ehci->periodic[i]);\r\ntemp = scnprintf(next, size, "%4d: ", i);\r\nsize -= temp;\r\nnext += temp;\r\ndo {\r\nstruct ehci_qh_hw *hw;\r\nswitch (hc32_to_cpu(ehci, tag)) {\r\ncase Q_TYPE_QH:\r\nhw = p.qh->hw;\r\ntemp = scnprintf(next, size, " qh%d-%04x/%p",\r\np.qh->ps.period,\r\nhc32_to_cpup(ehci,\r\n&hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\np.qh);\r\nsize -= temp;\r\nnext += temp;\r\nfor (temp = 0; temp < seen_count; temp++) {\r\nif (seen[temp].ptr != p.ptr)\r\ncontinue;\r\nif (p.qh->qh_next.ptr) {\r\ntemp = scnprintf(next, size,\r\n" ...");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nbreak;\r\n}\r\nif (temp == seen_count) {\r\ntemp = output_buf_tds_dir(next, ehci,\r\nhw, p.qh, size);\r\nif (seen_count < DBG_SCHED_LIMIT)\r\nseen[seen_count++].qh = p.qh;\r\n} else {\r\ntemp = 0;\r\n}\r\ntag = Q_NEXT_TYPE(ehci, hw->hw_next);\r\np = p.qh->qh_next;\r\nbreak;\r\ncase Q_TYPE_FSTN:\r\ntemp = scnprintf(next, size,\r\n" fstn-%8x/%p", p.fstn->hw_prev,\r\np.fstn);\r\ntag = Q_NEXT_TYPE(ehci, p.fstn->hw_next);\r\np = p.fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\ntemp = scnprintf(next, size,\r\n" itd/%p", p.itd);\r\ntag = Q_NEXT_TYPE(ehci, p.itd->hw_next);\r\np = p.itd->itd_next;\r\nbreak;\r\ncase Q_TYPE_SITD:\r\ntemp = scnprintf(next, size,\r\n" sitd%d-%04x/%p",\r\np.sitd->stream->ps.period,\r\nhc32_to_cpup(ehci, &p.sitd->hw_uframe)\r\n& 0x0000ffff,\r\np.sitd);\r\ntag = Q_NEXT_TYPE(ehci, p.sitd->hw_next);\r\np = p.sitd->sitd_next;\r\nbreak;\r\n}\r\nsize -= temp;\r\nnext += temp;\r\n} while (p.ptr);\r\ntemp = scnprintf(next, size, "\n");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nkfree(seen);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic const char *rh_state_string(struct ehci_hcd *ehci)\r\n{\r\nswitch (ehci->rh_state) {\r\ncase EHCI_RH_HALTED:\r\nreturn "halted";\r\ncase EHCI_RH_SUSPENDED:\r\nreturn "suspended";\r\ncase EHCI_RH_RUNNING:\r\nreturn "running";\r\ncase EHCI_RH_STOPPING:\r\nreturn "stopping";\r\n}\r\nreturn "?";\r\n}\r\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nunsigned long flags;\r\nunsigned temp, size, i;\r\nchar *next, scratch[80];\r\nstatic char fmt[] = "%*s\n";\r\nstatic char label[] = "";\r\nhcd = bus_to_hcd(buf->bus);\r\nehci = hcd_to_ehci(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nsize = scnprintf(next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"SUSPENDED (no register access)\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc);\r\ngoto done;\r\n}\r\ni = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\ntemp = scnprintf(next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"EHCI %x.%02x, rh state %s\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc,\r\ni >> 8, i & 0x0ff, rh_state_string(ehci));\r\nsize -= temp;\r\nnext += temp;\r\n#ifdef CONFIG_PCI\r\nif (dev_is_pci(hcd->self.controller)) {\r\nstruct pci_dev *pdev;\r\nu32 offset, cap, cap2;\r\nunsigned count = 256 / 4;\r\npdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);\r\noffset = HCC_EXT_CAPS(ehci_readl(ehci,\r\n&ehci->caps->hcc_params));\r\nwhile (offset && count--) {\r\npci_read_config_dword(pdev, offset, &cap);\r\nswitch (cap & 0xff) {\r\ncase 1:\r\ntemp = scnprintf(next, size,\r\n"ownership %08x%s%s\n", cap,\r\n(cap & (1 << 24)) ? " linux" : "",\r\n(cap & (1 << 16)) ? " firmware" : "");\r\nsize -= temp;\r\nnext += temp;\r\noffset += 4;\r\npci_read_config_dword(pdev, offset, &cap2);\r\ntemp = scnprintf(next, size,\r\n"SMI sts/enable 0x%08x\n", cap2);\r\nsize -= temp;\r\nnext += temp;\r\nbreak;\r\ncase 0:\r\ncap = 0;\r\ndefault:\r\nbreak;\r\n}\r\ntemp = (cap >> 8) & 0xff;\r\n}\r\n}\r\n#endif\r\ni = ehci_readl(ehci, &ehci->caps->hcs_params);\r\ntemp = scnprintf(next, size, "structural params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ni = ehci_readl(ehci, &ehci->caps->hcc_params);\r\ntemp = scnprintf(next, size, "capability params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_status_buf(scratch, sizeof(scratch), label,\r\nehci_readl(ehci, &ehci->regs->status));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_command_buf(scratch, sizeof(scratch), label,\r\nehci_readl(ehci, &ehci->regs->command));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_intr_buf(scratch, sizeof(scratch), label,\r\nehci_readl(ehci, &ehci->regs->intr_enable));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf(next, size, "uframe %04x\n",\r\nehci_read_frame_index(ehci));\r\nsize -= temp;\r\nnext += temp;\r\nfor (i = 1; i <= HCS_N_PORTS(ehci->hcs_params); i++) {\r\ntemp = dbg_port_buf(scratch, sizeof(scratch), label, i,\r\nehci_readl(ehci,\r\n&ehci->regs->port_status[i - 1]));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\nif (i == HCS_DEBUG_PORT(ehci->hcs_params) && ehci->debug) {\r\ntemp = scnprintf(next, size,\r\n" debug control %08x\n",\r\nehci_readl(ehci,\r\n&ehci->debug->control));\r\nsize -= temp;\r\nnext += temp;\r\n}\r\n}\r\nif (!list_empty(&ehci->async_unlink)) {\r\ntemp = scnprintf(next, size, "async unlink qh %p\n",\r\nlist_first_entry(&ehci->async_unlink,\r\nstruct ehci_qh, unlink_node));\r\nsize -= temp;\r\nnext += temp;\r\n}\r\n#ifdef EHCI_STATS\r\ntemp = scnprintf(next, size,\r\n"irq normal %ld err %ld iaa %ld (lost %ld)\n",\r\nehci->stats.normal, ehci->stats.error, ehci->stats.iaa,\r\nehci->stats.lost_iaa);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf(next, size, "complete %ld unlink %ld\n",\r\nehci->stats.complete, ehci->stats.unlink);\r\nsize -= temp;\r\nnext += temp;\r\n#endif\r\ndone:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic struct debug_buffer *alloc_buffer(struct usb_bus *bus,\r\nssize_t (*fill_func)(struct debug_buffer *))\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (buf) {\r\nbuf->bus = bus;\r\nbuf->fill_func = fill_func;\r\nmutex_init(&buf->mutex);\r\nbuf->alloc_size = PAGE_SIZE;\r\n}\r\nreturn buf;\r\n}\r\nstatic int fill_buffer(struct debug_buffer *buf)\r\n{\r\nint ret = 0;\r\nif (!buf->output_buf)\r\nbuf->output_buf = vmalloc(buf->alloc_size);\r\nif (!buf->output_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = buf->fill_func(buf);\r\nif (ret >= 0) {\r\nbuf->count = ret;\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nint ret = 0;\r\nmutex_lock(&buf->mutex);\r\nif (buf->count == 0) {\r\nret = fill_buffer(buf);\r\nif (ret != 0) {\r\nmutex_unlock(&buf->mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&buf->mutex);\r\nret = simple_read_from_buffer(user_buf, len, offset,\r\nbuf->output_buf, buf->count);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int debug_close(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nif (buf) {\r\nvfree(buf->output_buf);\r\nkfree(buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int debug_async_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_bandwidth_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_bandwidth_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = alloc_buffer(inode->i_private, fill_periodic_buffer);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf->alloc_size = (sizeof(void *) == 4 ? 6 : 8) * PAGE_SIZE;\r\nfile->private_data = buf;\r\nreturn 0;\r\n}\r\nstatic int debug_registers_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_registers_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void create_debug_files(struct ehci_hcd *ehci)\r\n{\r\nstruct usb_bus *bus = &ehci_to_hcd(ehci)->self;\r\nehci->debug_dir = debugfs_create_dir(bus->bus_name, ehci_debug_root);\r\nif (!ehci->debug_dir)\r\nreturn;\r\nif (!debugfs_create_file("async", S_IRUGO, ehci->debug_dir, bus,\r\n&debug_async_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("bandwidth", S_IRUGO, ehci->debug_dir, bus,\r\n&debug_bandwidth_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("periodic", S_IRUGO, ehci->debug_dir, bus,\r\n&debug_periodic_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("registers", S_IRUGO, ehci->debug_dir, bus,\r\n&debug_registers_fops))\r\ngoto file_error;\r\nreturn;\r\nfile_error:\r\ndebugfs_remove_recursive(ehci->debug_dir);\r\n}\r\nstatic inline void remove_debug_files(struct ehci_hcd *ehci)\r\n{\r\ndebugfs_remove_recursive(ehci->debug_dir);\r\n}\r\nstatic inline void dbg_hcs_params(struct ehci_hcd *ehci, char *label) { }\r\nstatic inline void dbg_hcc_params(struct ehci_hcd *ehci, char *label) { }\r\nstatic inline void __maybe_unused dbg_qh(const char *label,\r\nstruct ehci_hcd *ehci, struct ehci_qh *qh) { }\r\nstatic inline int __maybe_unused dbg_status_buf(const char *buf,\r\nunsigned int len, const char *label, u32 status)\r\n{ return 0; }\r\nstatic inline int __maybe_unused dbg_command_buf(const char *buf,\r\nunsigned int len, const char *label, u32 command)\r\n{ return 0; }\r\nstatic inline int __maybe_unused dbg_intr_buf(const char *buf,\r\nunsigned int len, const char *label, u32 enable)\r\n{ return 0; }\r\nstatic inline int __maybe_unused dbg_port_buf(char *buf,\r\nunsigned int len, const char *label, int port, u32 status)\r\n{ return 0; }\r\nstatic inline void dbg_status(struct ehci_hcd *ehci, const char *label,\r\nu32 status) { }\r\nstatic inline void dbg_cmd(struct ehci_hcd *ehci, const char *label,\r\nu32 command) { }\r\nstatic inline void dbg_port(struct ehci_hcd *ehci, const char *label,\r\nint port, u32 status) { }\r\nstatic inline void create_debug_files(struct ehci_hcd *bus) { }\r\nstatic inline void remove_debug_files(struct ehci_hcd *bus) { }
