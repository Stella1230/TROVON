static int show_config(struct perf_config_set *set)\r\n{\r\nstruct perf_config_section *section;\r\nstruct perf_config_item *item;\r\nif (set == NULL)\r\nreturn -1;\r\nperf_config_set__for_each_entry(set, section, item) {\r\nchar *value = item->value;\r\nif (value)\r\nprintf("%s.%s=%s\n", section->name,\r\nitem->name, value);\r\n}\r\nreturn 0;\r\n}\r\nint cmd_config(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nint ret = 0;\r\nstruct perf_config_set *set;\r\nchar *user_config = mkpath("%s/.perfconfig", getenv("HOME"));\r\nargc = parse_options(argc, argv, config_options, config_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (use_system_config && use_user_config) {\r\npr_err("Error: only one config file at a time\n");\r\nparse_options_usage(config_usage, config_options, "user", 0);\r\nparse_options_usage(NULL, config_options, "system", 0);\r\nreturn -1;\r\n}\r\nif (use_system_config)\r\nconfig_exclusive_filename = perf_etc_perfconfig();\r\nelse if (use_user_config)\r\nconfig_exclusive_filename = user_config;\r\nset = perf_config_set__new();\r\nif (!set) {\r\nret = -1;\r\ngoto out_err;\r\n}\r\nswitch (actions) {\r\ncase ACTION_LIST:\r\nif (argc) {\r\npr_err("Error: takes no arguments\n");\r\nparse_options_usage(config_usage, config_options, "l", 1);\r\n} else {\r\nret = show_config(set);\r\nif (ret < 0) {\r\nconst char * config_filename = config_exclusive_filename;\r\nif (!config_exclusive_filename)\r\nconfig_filename = user_config;\r\npr_err("Nothing configured, "\r\n"please check your %s \n", config_filename);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nusage_with_options(config_usage, config_options);\r\n}\r\nperf_config_set__delete(set);\r\nout_err:\r\nreturn ret;\r\n}
