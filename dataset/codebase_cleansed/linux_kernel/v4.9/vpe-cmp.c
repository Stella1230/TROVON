void cleanup_tc(struct tc *tc)\r\n{\r\n}\r\nstatic ssize_t store_kill(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nstruct vpe_notifications *notifier;\r\nlist_for_each_entry(notifier, &vpe->notify, list)\r\nnotifier->stop(aprp_cpu_index());\r\nrelease_progmem(vpe->load_addr);\r\nvpe->state = VPE_STATE_UNUSED;\r\nreturn len;\r\n}\r\nstatic ssize_t ntcs_show(struct device *cd, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nreturn sprintf(buf, "%d\n", vpe->ntcs);\r\n}\r\nstatic ssize_t ntcs_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(aprp_cpu_index());\r\nunsigned long new;\r\nint ret;\r\nret = kstrtoul(buf, 0, &new);\r\nif (ret < 0)\r\nreturn ret;\r\nif (new != 1)\r\nreturn -EINVAL;\r\nvpe->ntcs = new;\r\nreturn len;\r\n}\r\nstatic void vpe_device_release(struct device *cd)\r\n{\r\nkfree(cd);\r\n}\r\nint __init vpe_module_init(void)\r\n{\r\nstruct vpe *v = NULL;\r\nstruct tc *t;\r\nint err;\r\nif (!cpu_has_mipsmt) {\r\npr_warn("VPE loader: not a MIPS MT capable processor\n");\r\nreturn -ENODEV;\r\n}\r\nif (num_possible_cpus() - aprp_cpu_index() < 1) {\r\npr_warn("No VPEs reserved for AP/SP, not initialize VPE loader\n"\r\n"Pass maxcpus=<n> argument as kernel argument\n");\r\nreturn -ENODEV;\r\n}\r\nmajor = register_chrdev(0, VPE_MODULE_NAME, &vpe_fops);\r\nif (major < 0) {\r\npr_warn("VPE loader: unable to register character device\n");\r\nreturn major;\r\n}\r\nerr = class_register(&vpe_class);\r\nif (err) {\r\npr_err("vpe_class registration failed\n");\r\ngoto out_chrdev;\r\n}\r\ndevice_initialize(&vpe_device);\r\nvpe_device.class = &vpe_class,\r\nvpe_device.parent = NULL,\r\ndev_set_name(&vpe_device, "vpe_sp");\r\nvpe_device.devt = MKDEV(major, VPE_MODULE_MINOR);\r\nerr = device_add(&vpe_device);\r\nif (err) {\r\npr_err("Adding vpe_device failed\n");\r\ngoto out_class;\r\n}\r\nt = alloc_tc(aprp_cpu_index());\r\nif (!t) {\r\npr_warn("VPE: unable to allocate TC\n");\r\nerr = -ENOMEM;\r\ngoto out_dev;\r\n}\r\nv = alloc_vpe(aprp_cpu_index());\r\nif (v == NULL) {\r\npr_warn("VPE: unable to allocate VPE\n");\r\nkfree(t);\r\nerr = -ENOMEM;\r\ngoto out_dev;\r\n}\r\nv->ntcs = 1;\r\nlist_add(&t->tc, &v->tc);\r\nt->pvpe = v;\r\nreturn 0;\r\nout_dev:\r\ndevice_del(&vpe_device);\r\nout_class:\r\nclass_unregister(&vpe_class);\r\nout_chrdev:\r\nunregister_chrdev(major, VPE_MODULE_NAME);\r\nreturn err;\r\n}\r\nvoid __exit vpe_module_exit(void)\r\n{\r\nstruct vpe *v, *n;\r\ndevice_del(&vpe_device);\r\nclass_unregister(&vpe_class);\r\nunregister_chrdev(major, VPE_MODULE_NAME);\r\nlist_for_each_entry_safe(v, n, &vpecontrol.vpe_list, list)\r\nif (v->state != VPE_STATE_UNUSED)\r\nrelease_vpe(v);\r\n}
