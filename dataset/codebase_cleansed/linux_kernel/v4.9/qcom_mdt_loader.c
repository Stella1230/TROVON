struct resource_table *qcom_mdt_find_rsc_table(struct rproc *rproc,\r\nconst struct firmware *fw,\r\nint *tablesz)\r\n{\r\nstatic struct resource_table table = { .ver = 1, };\r\n*tablesz = sizeof(table);\r\nreturn &table;\r\n}\r\nint qcom_mdt_parse(const struct firmware *fw, phys_addr_t *fw_addr,\r\nsize_t *fw_size, bool *fw_relocate)\r\n{\r\nconst struct elf32_phdr *phdrs;\r\nconst struct elf32_phdr *phdr;\r\nconst struct elf32_hdr *ehdr;\r\nphys_addr_t min_addr = (phys_addr_t)ULLONG_MAX;\r\nphys_addr_t max_addr = 0;\r\nbool relocate = false;\r\nint i;\r\nehdr = (struct elf32_hdr *)fw->data;\r\nphdrs = (struct elf32_phdr *)(ehdr + 1);\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\r\ncontinue;\r\nif (!phdr->p_memsz)\r\ncontinue;\r\nif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\r\nrelocate = true;\r\nif (phdr->p_paddr < min_addr)\r\nmin_addr = phdr->p_paddr;\r\nif (phdr->p_paddr + phdr->p_memsz > max_addr)\r\nmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\r\n}\r\nif (fw_addr)\r\n*fw_addr = min_addr;\r\nif (fw_size)\r\n*fw_size = max_addr - min_addr;\r\nif (fw_relocate)\r\n*fw_relocate = relocate;\r\nreturn 0;\r\n}\r\nint qcom_mdt_load(struct rproc *rproc,\r\nconst struct firmware *fw,\r\nconst char *firmware)\r\n{\r\nconst struct elf32_phdr *phdrs;\r\nconst struct elf32_phdr *phdr;\r\nconst struct elf32_hdr *ehdr;\r\nsize_t fw_name_len;\r\nchar *fw_name;\r\nvoid *ptr;\r\nint ret;\r\nint i;\r\nehdr = (struct elf32_hdr *)fw->data;\r\nphdrs = (struct elf32_phdr *)(ehdr + 1);\r\nfw_name_len = strlen(firmware);\r\nif (fw_name_len <= 4)\r\nreturn -EINVAL;\r\nfw_name = kstrdup(firmware, GFP_KERNEL);\r\nif (!fw_name)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\r\ncontinue;\r\nif (!phdr->p_memsz)\r\ncontinue;\r\nptr = rproc_da_to_va(rproc, phdr->p_paddr, phdr->p_memsz);\r\nif (!ptr) {\r\ndev_err(&rproc->dev, "segment outside memory range\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (phdr->p_filesz) {\r\nsprintf(fw_name + fw_name_len - 3, "b%02d", i);\r\nret = request_firmware(&fw, fw_name, &rproc->dev);\r\nif (ret) {\r\ndev_err(&rproc->dev, "failed to load %s\n",\r\nfw_name);\r\nbreak;\r\n}\r\nmemcpy(ptr, fw->data, fw->size);\r\nrelease_firmware(fw);\r\n}\r\nif (phdr->p_memsz > phdr->p_filesz)\r\nmemset(ptr + phdr->p_filesz, 0, phdr->p_memsz - phdr->p_filesz);\r\n}\r\nkfree(fw_name);\r\nreturn ret;\r\n}
