struct page *balloon_page_enqueue(struct balloon_dev_info *b_dev_info)\r\n{\r\nunsigned long flags;\r\nstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\r\n__GFP_NOMEMALLOC | __GFP_NORETRY);\r\nif (!page)\r\nreturn NULL;\r\nBUG_ON(!trylock_page(page));\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nballoon_page_insert(b_dev_info, page);\r\n__count_vm_event(BALLOON_INFLATE);\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nunlock_page(page);\r\nreturn page;\r\n}\r\nstruct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\r\n{\r\nstruct page *page, *tmp;\r\nunsigned long flags;\r\nbool dequeued_page;\r\ndequeued_page = false;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\r\nif (trylock_page(page)) {\r\n#ifdef CONFIG_BALLOON_COMPACTION\r\nif (PageIsolated(page)) {\r\nunlock_page(page);\r\ncontinue;\r\n}\r\n#endif\r\nballoon_page_delete(page);\r\n__count_vm_event(BALLOON_DEFLATE);\r\nunlock_page(page);\r\ndequeued_page = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nif (!dequeued_page) {\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nif (unlikely(list_empty(&b_dev_info->pages) &&\r\n!b_dev_info->isolated_pages))\r\nBUG();\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\npage = NULL;\r\n}\r\nreturn page;\r\n}\r\nbool balloon_page_isolate(struct page *page, isolate_mode_t mode)\r\n{\r\nstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nlist_del(&page->lru);\r\nb_dev_info->isolated_pages++;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nreturn true;\r\n}\r\nvoid balloon_page_putback(struct page *page)\r\n{\r\nstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nlist_add(&page->lru, &b_dev_info->pages);\r\nb_dev_info->isolated_pages--;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\n}\r\nint balloon_page_migrate(struct address_space *mapping,\r\nstruct page *newpage, struct page *page,\r\nenum migrate_mode mode)\r\n{\r\nstruct balloon_dev_info *balloon = balloon_page_device(page);\r\nVM_BUG_ON_PAGE(!PageLocked(page), page);\r\nVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\r\nreturn balloon->migratepage(balloon, newpage, page, mode);\r\n}
