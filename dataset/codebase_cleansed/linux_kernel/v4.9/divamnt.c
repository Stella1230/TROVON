static char *getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "1.0";\r\nreturn rev;\r\n}\r\nint diva_os_copy_to_user(void *os_handle, void __user *dst, const void *src,\r\nint length)\r\n{\r\nreturn (copy_to_user(dst, src, length));\r\n}\r\nint diva_os_copy_from_user(void *os_handle, void *dst, const void __user *src,\r\nint length)\r\n{\r\nreturn (copy_from_user(dst, src, length));\r\n}\r\nvoid diva_os_get_time(dword *sec, dword *usec)\r\n{\r\nstruct timespec64 time;\r\nktime_get_ts64(&time);\r\n*sec = (dword) time.tv_sec;\r\n*usec = (dword) (time.tv_nsec / NSEC_PER_USEC);\r\n}\r\nstatic unsigned int maint_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &msgwaitq, wait);\r\nmask = POLLOUT | POLLWRNORM;\r\nif (file->private_data || diva_dbg_q_length()) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn (mask);\r\n}\r\nstatic int maint_open(struct inode *ino, struct file *filep)\r\n{\r\nint ret;\r\nmutex_lock(&maint_mutex);\r\nif (test_and_set_bit(0, &opened))\r\nret = -EBUSY;\r\nelse {\r\nfilep->private_data = NULL;\r\nret = nonseekable_open(ino, filep);\r\n}\r\nmutex_unlock(&maint_mutex);\r\nreturn ret;\r\n}\r\nstatic int maint_close(struct inode *ino, struct file *filep)\r\n{\r\nif (filep->private_data) {\r\ndiva_os_free(0, filep->private_data);\r\nfilep->private_data = NULL;\r\n}\r\nclear_bit(0, &opened);\r\nreturn (0);\r\n}\r\nstatic ssize_t divas_maint_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn (maint_read_write((char __user *) buf, (int) count));\r\n}\r\nstatic ssize_t divas_maint_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn (maint_read_write(buf, (int) count));\r\n}\r\nstatic void divas_maint_unregister_chrdev(void)\r\n{\r\nunregister_chrdev(major, DEVNAME);\r\n}\r\nstatic int __init divas_maint_register_chrdev(void)\r\n{\r\nif ((major = register_chrdev(0, DEVNAME, &divas_maint_fops)) < 0)\r\n{\r\nprintk(KERN_ERR "%s: failed to create /dev entry.\n",\r\nDRIVERLNAME);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nvoid diva_maint_wakeup_read(void)\r\n{\r\nwake_up_interruptible(&msgwaitq);\r\n}\r\nstatic int __init maint_init(void)\r\n{\r\nchar tmprev[50];\r\nint ret = 0;\r\nvoid *buffer = NULL;\r\ninit_waitqueue_head(&msgwaitq);\r\nprintk(KERN_INFO "%s\n", DRIVERNAME);\r\nprintk(KERN_INFO "%s: Rel:%s Rev:", DRIVERLNAME, DRIVERRELEASE_MNT);\r\nstrcpy(tmprev, main_revision);\r\nprintk("%s Build: %s \n", getrev(tmprev), DIVA_BUILD);\r\nif (!divas_maint_register_chrdev()) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!(mntfunc_init(&buffer_length, &buffer, diva_dbg_mem))) {\r\nprintk(KERN_ERR "%s: failed to connect to DIDD.\n",\r\nDRIVERLNAME);\r\ndivas_maint_unregister_chrdev();\r\nret = -EIO;\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: trace buffer = %p - %d kBytes, %s (Major: %d)\n",\r\nDRIVERLNAME, buffer, (buffer_length / 1024),\r\n(diva_dbg_mem == 0) ? "internal" : "external", major);\r\nout:\r\nreturn (ret);\r\n}\r\nstatic void __exit maint_exit(void)\r\n{\r\ndivas_maint_unregister_chrdev();\r\nmntfunc_finit();\r\nprintk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);\r\n}
