static inline bool is_percpu_irq(irq_hw_number_t irq)\r\n{\r\nif (irq <= ARMADA_370_XP_MAX_PER_CPU_IRQS)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void armada_370_xp_irq_mask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (!is_percpu_irq(hwirq))\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_SET_MASK_OFFS);\r\n}\r\nstatic void armada_370_xp_irq_unmask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (!is_percpu_irq(hwirq))\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic void armada_370_xp_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\r\n{\r\nmsg->address_lo = lower_32_bits(msi_doorbell_addr);\r\nmsg->address_hi = upper_32_bits(msi_doorbell_addr);\r\nmsg->data = 0xf00 | (data->hwirq + PCI_MSI_DOORBELL_START);\r\n}\r\nstatic int armada_370_xp_msi_set_affinity(struct irq_data *irq_data,\r\nconst struct cpumask *mask, bool force)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int armada_370_xp_msi_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nint hwirq, i;\r\nmutex_lock(&msi_used_lock);\r\nhwirq = bitmap_find_next_zero_area(msi_used, PCI_MSI_DOORBELL_NR,\r\n0, nr_irqs, 0);\r\nif (hwirq >= PCI_MSI_DOORBELL_NR) {\r\nmutex_unlock(&msi_used_lock);\r\nreturn -ENOSPC;\r\n}\r\nbitmap_set(msi_used, hwirq, nr_irqs);\r\nmutex_unlock(&msi_used_lock);\r\nfor (i = 0; i < nr_irqs; i++) {\r\nirq_domain_set_info(domain, virq + i, hwirq + i,\r\n&armada_370_xp_msi_bottom_irq_chip,\r\ndomain->host_data, handle_simple_irq,\r\nNULL, NULL);\r\n}\r\nreturn hwirq;\r\n}\r\nstatic void armada_370_xp_msi_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nmutex_lock(&msi_used_lock);\r\nbitmap_clear(msi_used, d->hwirq, nr_irqs);\r\nmutex_unlock(&msi_used_lock);\r\n}\r\nstatic int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nu32 reg;\r\nmsi_doorbell_addr = main_int_phys_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS;\r\narmada_370_xp_msi_inner_domain =\r\nirq_domain_add_linear(NULL, PCI_MSI_DOORBELL_NR,\r\n&armada_370_xp_msi_domain_ops, NULL);\r\nif (!armada_370_xp_msi_inner_domain)\r\nreturn -ENOMEM;\r\narmada_370_xp_msi_domain =\r\npci_msi_create_irq_domain(of_node_to_fwnode(node),\r\n&armada_370_xp_msi_domain_info,\r\narmada_370_xp_msi_inner_domain);\r\nif (!armada_370_xp_msi_domain) {\r\nirq_domain_remove(armada_370_xp_msi_inner_domain);\r\nreturn -ENOMEM;\r\n}\r\nreg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS)\r\n| PCI_MSI_DOORBELL_MASK;\r\nwritel(reg, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nreturn 0;\r\n}\r\nstatic inline int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nreturn 0;\r\n}\r\nstatic int armada_xp_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask_val, bool force)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nunsigned long reg, mask;\r\nint cpu;\r\ncpu = cpumask_any_and(mask_val, cpu_online_mask);\r\nmask = 1UL << cpu_logical_map(cpu);\r\nraw_spin_lock(&irq_controller_lock);\r\nreg = readl(main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nreg = (reg & (~ARMADA_370_XP_INT_SOURCE_CPU_MASK)) | mask;\r\nwritel(reg, main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nraw_spin_unlock(&irq_controller_lock);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic int armada_370_xp_mpic_irq_map(struct irq_domain *h,\r\nunsigned int virq, irq_hw_number_t hw)\r\n{\r\narmada_370_xp_irq_mask(irq_get_irq_data(virq));\r\nif (!is_percpu_irq(hw))\r\nwritel(hw, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nelse\r\nwritel(hw, main_int_base + ARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nif (is_percpu_irq(hw)) {\r\nirq_set_percpu_devid(virq);\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_percpu_devid_irq);\r\n} else {\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_level_irq);\r\n}\r\nirq_set_probe(virq);\r\nirq_clear_status_flags(virq, IRQ_NOAUTOEN);\r\nreturn 0;\r\n}\r\nstatic void armada_xp_mpic_smp_cpu_init(void)\r\n{\r\nu32 control;\r\nint nr_irqs, i;\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, per_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nwritel(IPI_DOORBELL_MASK, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic void armada_xp_mpic_perf_init(void)\r\n{\r\nunsigned long cpuid = cpu_logical_map(smp_processor_id());\r\nwritel(ARMADA_370_XP_INT_CAUSE_PERF(cpuid),\r\nper_cpu_int_base + ARMADA_370_XP_INT_FABRIC_MASK_OFFS);\r\n}\r\nstatic void armada_mpic_send_doorbell(const struct cpumask *mask,\r\nunsigned int irq)\r\n{\r\nint cpu;\r\nunsigned long map = 0;\r\nfor_each_cpu(cpu, mask)\r\nmap |= 1 << cpu_logical_map(cpu);\r\ndsb();\r\nwritel((map << 8) | irq, main_int_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS);\r\n}\r\nstatic int armada_xp_mpic_starting_cpu(unsigned int cpu)\r\n{\r\narmada_xp_mpic_perf_init();\r\narmada_xp_mpic_smp_cpu_init();\r\nreturn 0;\r\n}\r\nstatic int mpic_cascaded_starting_cpu(unsigned int cpu)\r\n{\r\narmada_xp_mpic_perf_init();\r\nenable_percpu_irq(parent_irq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)\r\n{\r\nu32 msimask, msinr;\r\nmsimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& PCI_MSI_DOORBELL_MASK;\r\nwritel(~msimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (msinr = PCI_MSI_DOORBELL_START;\r\nmsinr < PCI_MSI_DOORBELL_END; msinr++) {\r\nint irq;\r\nif (!(msimask & BIT(msinr)))\r\ncontinue;\r\nif (is_chained) {\r\nirq = irq_find_mapping(armada_370_xp_msi_inner_domain,\r\nmsinr - PCI_MSI_DOORBELL_START);\r\ngeneric_handle_irq(irq);\r\n} else {\r\nirq = msinr - PCI_MSI_DOORBELL_START;\r\nhandle_domain_irq(armada_370_xp_msi_inner_domain,\r\nirq, regs);\r\n}\r\n}\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}\r\nstatic void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long irqmap, irqn, irqsrc, cpuid;\r\nunsigned int cascade_irq;\r\nchained_irq_enter(chip, desc);\r\nirqmap = readl_relaxed(per_cpu_int_base + ARMADA_375_PPI_CAUSE);\r\ncpuid = cpu_logical_map(smp_processor_id());\r\nfor_each_set_bit(irqn, &irqmap, BITS_PER_LONG) {\r\nirqsrc = readl_relaxed(main_int_base +\r\nARMADA_370_XP_INT_SOURCE_CTL(irqn));\r\nif (!(irqsrc & ARMADA_370_XP_INT_IRQ_FIQ_MASK(cpuid)))\r\ncontinue;\r\nif (irqn == 1) {\r\narmada_370_xp_handle_msi_irq(NULL, true);\r\ncontinue;\r\n}\r\ncascade_irq = irq_find_mapping(armada_370_xp_mpic_domain, irqn);\r\ngeneric_handle_irq(cascade_irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void __exception_irq_entry\r\narmada_370_xp_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqstat, irqnr;\r\ndo {\r\nirqstat = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_CPU_INTACK_OFFS);\r\nirqnr = irqstat & 0x3FF;\r\nif (irqnr > 1022)\r\nbreak;\r\nif (irqnr > 1) {\r\nhandle_domain_irq(armada_370_xp_mpic_domain,\r\nirqnr, regs);\r\ncontinue;\r\n}\r\nif (irqnr == 1)\r\narmada_370_xp_handle_msi_irq(regs, false);\r\n#ifdef CONFIG_SMP\r\nif (irqnr == 0) {\r\nu32 ipimask, ipinr;\r\nipimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& IPI_DOORBELL_MASK;\r\nwritel(~ipimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (ipinr = IPI_DOORBELL_START;\r\nipinr < IPI_DOORBELL_END; ipinr++) {\r\nif (ipimask & (0x1 << ipinr))\r\nhandle_IPI(ipinr, regs);\r\n}\r\ncontinue;\r\n}\r\n#endif\r\n} while (1);\r\n}\r\nstatic int armada_370_xp_mpic_suspend(void)\r\n{\r\ndoorbell_mask_reg = readl(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_mpic_resume(void)\r\n{\r\nint nirqs;\r\nirq_hw_number_t irq;\r\nnirqs = (readl(main_int_base + ARMADA_370_XP_INT_CONTROL) >> 2) & 0x3ff;\r\nfor (irq = 0; irq < nirqs; irq++) {\r\nstruct irq_data *data;\r\nint virq;\r\nvirq = irq_linear_revmap(armada_370_xp_mpic_domain, irq);\r\nif (virq == 0)\r\ncontinue;\r\nif (!is_percpu_irq(irq))\r\nwritel(irq, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nelse\r\nwritel(irq, main_int_base +\r\nARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\ndata = irq_get_irq_data(virq);\r\nif (!irqd_irq_disabled(data))\r\narmada_370_xp_irq_unmask(data);\r\n}\r\nwritel(doorbell_mask_reg,\r\nper_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nif (doorbell_mask_reg & IPI_DOORBELL_MASK)\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nif (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)\r\nwritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int __init armada_370_xp_mpic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct resource main_int_res, per_cpu_int_res;\r\nint nr_irqs, i;\r\nu32 control;\r\nBUG_ON(of_address_to_resource(node, 0, &main_int_res));\r\nBUG_ON(of_address_to_resource(node, 1, &per_cpu_int_res));\r\nBUG_ON(!request_mem_region(main_int_res.start,\r\nresource_size(&main_int_res),\r\nnode->full_name));\r\nBUG_ON(!request_mem_region(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res),\r\nnode->full_name));\r\nmain_int_base = ioremap(main_int_res.start,\r\nresource_size(&main_int_res));\r\nBUG_ON(!main_int_base);\r\nper_cpu_int_base = ioremap(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res));\r\nBUG_ON(!per_cpu_int_base);\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, main_int_base + ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\narmada_370_xp_mpic_domain =\r\nirq_domain_add_linear(node, nr_irqs,\r\n&armada_370_xp_mpic_irq_ops, NULL);\r\nBUG_ON(!armada_370_xp_mpic_domain);\r\narmada_370_xp_mpic_domain->bus_token = DOMAIN_BUS_WIRED;\r\narmada_xp_mpic_perf_init();\r\narmada_xp_mpic_smp_cpu_init();\r\narmada_370_xp_msi_init(node, main_int_res.start);\r\nparent_irq = irq_of_parse_and_map(node, 0);\r\nif (parent_irq <= 0) {\r\nirq_set_default_host(armada_370_xp_mpic_domain);\r\nset_handle_irq(armada_370_xp_handle_irq);\r\n#ifdef CONFIG_SMP\r\nset_smp_cross_call(armada_mpic_send_doorbell);\r\ncpuhp_setup_state_nocalls(CPUHP_AP_IRQ_ARMADA_XP_STARTING,\r\n"AP_IRQ_ARMADA_XP_STARTING",\r\narmada_xp_mpic_starting_cpu, NULL);\r\n#endif\r\n} else {\r\n#ifdef CONFIG_SMP\r\ncpuhp_setup_state_nocalls(CPUHP_AP_IRQ_ARMADA_CASC_STARTING,\r\n"AP_IRQ_ARMADA_CASC_STARTING",\r\nmpic_cascaded_starting_cpu, NULL);\r\n#endif\r\nirq_set_chained_handler(parent_irq,\r\narmada_370_xp_mpic_handle_cascade_irq);\r\n}\r\nregister_syscore_ops(&armada_370_xp_mpic_syscore_ops);\r\nreturn 0;\r\n}
