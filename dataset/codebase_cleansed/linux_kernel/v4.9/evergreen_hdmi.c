void dce4_audio_enable(struct radeon_device *rdev,\r\nstruct r600_audio_pin *pin,\r\nu8 enable_mask)\r\n{\r\nu32 tmp = RREG32(AZ_HOT_PLUG_CONTROL);\r\nif (!pin)\r\nreturn;\r\nif (enable_mask) {\r\ntmp |= AUDIO_ENABLED;\r\nif (enable_mask & 1)\r\ntmp |= PIN0_AUDIO_ENABLED;\r\nif (enable_mask & 2)\r\ntmp |= PIN1_AUDIO_ENABLED;\r\nif (enable_mask & 4)\r\ntmp |= PIN2_AUDIO_ENABLED;\r\nif (enable_mask & 8)\r\ntmp |= PIN3_AUDIO_ENABLED;\r\n} else {\r\ntmp &= ~(AUDIO_ENABLED |\r\nPIN0_AUDIO_ENABLED |\r\nPIN1_AUDIO_ENABLED |\r\nPIN2_AUDIO_ENABLED |\r\nPIN3_AUDIO_ENABLED);\r\n}\r\nWREG32(AZ_HOT_PLUG_CONTROL, tmp);\r\n}\r\nvoid evergreen_hdmi_update_acr(struct drm_encoder *encoder, long offset,\r\nconst struct radeon_hdmi_acr *acr)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint bpc = 8;\r\nif (encoder->crtc) {\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nbpc = radeon_crtc->bpc;\r\n}\r\nif (bpc > 8)\r\nWREG32(HDMI_ACR_PACKET_CONTROL + offset,\r\nHDMI_ACR_AUTO_SEND);\r\nelse\r\nWREG32(HDMI_ACR_PACKET_CONTROL + offset,\r\nHDMI_ACR_SOURCE |\r\nHDMI_ACR_AUTO_SEND);\r\nWREG32(HDMI_ACR_32_0 + offset, HDMI_ACR_CTS_32(acr->cts_32khz));\r\nWREG32(HDMI_ACR_32_1 + offset, acr->n_32khz);\r\nWREG32(HDMI_ACR_44_0 + offset, HDMI_ACR_CTS_44(acr->cts_44_1khz));\r\nWREG32(HDMI_ACR_44_1 + offset, acr->n_44_1khz);\r\nWREG32(HDMI_ACR_48_0 + offset, HDMI_ACR_CTS_48(acr->cts_48khz));\r\nWREG32(HDMI_ACR_48_1 + offset, acr->n_48khz);\r\n}\r\nvoid dce4_afmt_write_latency_fields(struct drm_encoder *encoder,\r\nstruct drm_connector *connector, struct drm_display_mode *mode)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nu32 tmp = 0;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nif (connector->latency_present[1])\r\ntmp = VIDEO_LIPSYNC(connector->video_latency[1]) |\r\nAUDIO_LIPSYNC(connector->audio_latency[1]);\r\nelse\r\ntmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\r\n} else {\r\nif (connector->latency_present[0])\r\ntmp = VIDEO_LIPSYNC(connector->video_latency[0]) |\r\nAUDIO_LIPSYNC(connector->audio_latency[0]);\r\nelse\r\ntmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\r\n}\r\nWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_RESPONSE_LIPSYNC, tmp);\r\n}\r\nvoid dce4_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,\r\nu8 *sadb, int sad_count)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nu32 tmp;\r\ntmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\r\ntmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\r\ntmp |= HDMI_CONNECTION;\r\nif (sad_count)\r\ntmp |= SPEAKER_ALLOCATION(sadb[0]);\r\nelse\r\ntmp |= SPEAKER_ALLOCATION(5);\r\nWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\r\n}\r\nvoid dce4_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,\r\nu8 *sadb, int sad_count)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nu32 tmp;\r\ntmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\r\ntmp &= ~(HDMI_CONNECTION | SPEAKER_ALLOCATION_MASK);\r\ntmp |= DP_CONNECTION;\r\nif (sad_count)\r\ntmp |= SPEAKER_ALLOCATION(sadb[0]);\r\nelse\r\ntmp |= SPEAKER_ALLOCATION(5);\r\nWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\r\n}\r\nvoid evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder,\r\nstruct cea_sad *sads, int sad_count)\r\n{\r\nint i;\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstatic const u16 eld_reg_to_type[][2] = {\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\r\nu32 value = 0;\r\nu8 stereo_freqs = 0;\r\nint max_channels = -1;\r\nint j;\r\nfor (j = 0; j < sad_count; j++) {\r\nstruct cea_sad *sad = &sads[j];\r\nif (sad->format == eld_reg_to_type[i][1]) {\r\nif (sad->channels > max_channels) {\r\nvalue = MAX_CHANNELS(sad->channels) |\r\nDESCRIPTOR_BYTE_2(sad->byte2) |\r\nSUPPORTED_FREQUENCIES(sad->freq);\r\nmax_channels = sad->channels;\r\n}\r\nif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\r\nstereo_freqs |= sad->freq;\r\nelse\r\nbreak;\r\n}\r\n}\r\nvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\r\nWREG32_ENDPOINT(0, eld_reg_to_type[i][0], value);\r\n}\r\n}\r\nvoid evergreen_set_avi_packet(struct radeon_device *rdev, u32 offset,\r\nunsigned char *buffer, size_t size)\r\n{\r\nuint8_t *frame = buffer + 3;\r\nWREG32(AFMT_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(AFMT_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(AFMT_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(AFMT_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8) | (buffer[1] << 24));\r\nWREG32_P(HDMI_INFOFRAME_CONTROL1 + offset,\r\nHDMI_AVI_INFO_LINE(2),\r\n~HDMI_AVI_INFO_LINE_MASK);\r\n}\r\nvoid dce4_hdmi_audio_set_dto(struct radeon_device *rdev,\r\nstruct radeon_crtc *crtc, unsigned int clock)\r\n{\r\nunsigned int max_ratio = clock / 24000;\r\nu32 dto_phase;\r\nu32 wallclock_ratio;\r\nu32 value;\r\nif (max_ratio >= 8) {\r\ndto_phase = 192 * 1000;\r\nwallclock_ratio = 3;\r\n} else if (max_ratio >= 4) {\r\ndto_phase = 96 * 1000;\r\nwallclock_ratio = 2;\r\n} else if (max_ratio >= 2) {\r\ndto_phase = 48 * 1000;\r\nwallclock_ratio = 1;\r\n} else {\r\ndto_phase = 24 * 1000;\r\nwallclock_ratio = 0;\r\n}\r\nvalue = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\nvalue |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nvalue &= ~DCCG_AUDIO_DTO1_USE_512FBR_DTO;\r\nWREG32(DCCG_AUDIO_DTO0_CNTL, value);\r\nvalue = 0;\r\nif (crtc)\r\nvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\r\nWREG32(DCCG_AUDIO_DTO_SOURCE, value);\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, clock);\r\n}\r\nvoid dce4_dp_audio_set_dto(struct radeon_device *rdev,\r\nstruct radeon_crtc *crtc, unsigned int clock)\r\n{\r\nu32 value;\r\nvalue = RREG32(DCCG_AUDIO_DTO1_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\nvalue |= DCCG_AUDIO_DTO1_USE_512FBR_DTO;\r\nWREG32(DCCG_AUDIO_DTO1_CNTL, value);\r\nvalue = 0;\r\nvalue |= DCCG_AUDIO_DTO_SEL;\r\nif (crtc)\r\nvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\r\nWREG32(DCCG_AUDIO_DTO_SOURCE, value);\r\nif (ASIC_IS_DCE41(rdev)) {\r\nunsigned int div = (RREG32(DCE41_DENTIST_DISPCLK_CNTL) &\r\nDENTIST_DPREFCLK_WDIVIDER_MASK) >>\r\nDENTIST_DPREFCLK_WDIVIDER_SHIFT;\r\ndiv = radeon_audio_decode_dfs_div(div);\r\nif (div)\r\nclock = 100 * clock / div;\r\n}\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, 24000);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, clock);\r\n}\r\nvoid dce4_set_vbi_packet(struct drm_encoder *encoder, u32 offset)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nWREG32(HDMI_VBI_PACKET_CONTROL + offset,\r\nHDMI_NULL_SEND |\r\nHDMI_GC_SEND |\r\nHDMI_GC_CONT);\r\n}\r\nvoid dce4_hdmi_set_color_depth(struct drm_encoder *encoder, u32 offset, int bpc)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nuint32_t val;\r\nval = RREG32(HDMI_CONTROL + offset);\r\nval &= ~HDMI_DEEP_COLOR_ENABLE;\r\nval &= ~HDMI_DEEP_COLOR_DEPTH_MASK;\r\nswitch (bpc) {\r\ncase 0:\r\ncase 6:\r\ncase 8:\r\ncase 16:\r\ndefault:\r\nDRM_DEBUG("%s: Disabling hdmi deep color for %d bpc.\n",\r\nconnector->name, bpc);\r\nbreak;\r\ncase 10:\r\nval |= HDMI_DEEP_COLOR_ENABLE;\r\nval |= HDMI_DEEP_COLOR_DEPTH(HDMI_30BIT_DEEP_COLOR);\r\nDRM_DEBUG("%s: Enabling hdmi deep color 30 for 10 bpc.\n",\r\nconnector->name);\r\nbreak;\r\ncase 12:\r\nval |= HDMI_DEEP_COLOR_ENABLE;\r\nval |= HDMI_DEEP_COLOR_DEPTH(HDMI_36BIT_DEEP_COLOR);\r\nDRM_DEBUG("%s: Enabling hdmi deep color 36 for 12 bpc.\n",\r\nconnector->name);\r\nbreak;\r\n}\r\nWREG32(HDMI_CONTROL + offset, val);\r\n}\r\nvoid dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nWREG32(AFMT_INFOFRAME_CONTROL0 + offset,\r\nAFMT_AUDIO_INFO_UPDATE);\r\nWREG32(AFMT_60958_0 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_L(1));\r\nWREG32(AFMT_60958_1 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_R(2));\r\nWREG32(AFMT_60958_2 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_2(3) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_3(4) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_4(5) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_5(6) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_6(7) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_7(8));\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL2 + offset,\r\nAFMT_AUDIO_CHANNEL_ENABLE(0xff));\r\nWREG32(HDMI_AUDIO_PACKET_CONTROL + offset,\r\nHDMI_AUDIO_DELAY_EN(1) |\r\nHDMI_AUDIO_PACKETS_PER_LINE(3));\r\nWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_RESET_FIFO_WHEN_AUDIO_DIS | AFMT_60958_CS_UPDATE);\r\n}\r\nvoid dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (mute)\r\nWREG32_OR(HDMI_GC + offset, HDMI_GC_AVMUTE);\r\nelse\r\nWREG32_AND(HDMI_GC + offset, ~HDMI_GC_AVMUTE);\r\n}\r\nvoid evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (enable) {\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nif (connector && drm_detect_monitor_audio(radeon_connector_edid(connector))) {\r\nWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset,\r\nHDMI_AVI_INFO_SEND |\r\nHDMI_AVI_INFO_CONT |\r\nHDMI_AUDIO_INFO_SEND |\r\nHDMI_AUDIO_INFO_CONT);\r\nWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\r\nAFMT_AUDIO_SAMPLE_SEND);\r\n} else {\r\nWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset,\r\nHDMI_AVI_INFO_SEND |\r\nHDMI_AVI_INFO_CONT);\r\nWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\r\n~AFMT_AUDIO_SAMPLE_SEND);\r\n}\r\n} else {\r\nWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\r\n~AFMT_AUDIO_SAMPLE_SEND);\r\nWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset, 0);\r\n}\r\ndig->afmt->enabled = enable;\r\nDRM_DEBUG("%sabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nenable ? "En" : "Dis", dig->afmt->offset, radeon_encoder->encoder_id);\r\n}\r\nvoid evergreen_dp_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (enable && connector &&\r\ndrm_detect_monitor_audio(radeon_connector_edid(connector))) {\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nuint32_t val;\r\nWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\r\nAFMT_AUDIO_SAMPLE_SEND);\r\nWREG32(EVERGREEN_DP_SEC_TIMESTAMP + dig->afmt->offset,\r\nEVERGREEN_DP_SEC_TIMESTAMP_MODE(1));\r\nif (!ASIC_IS_DCE6(rdev) && radeon_connector->con_priv) {\r\ndig_connector = radeon_connector->con_priv;\r\nval = RREG32(EVERGREEN_DP_SEC_AUD_N + dig->afmt->offset);\r\nval &= ~EVERGREEN_DP_SEC_N_BASE_MULTIPLE(0xf);\r\nif (dig_connector->dp_clock == 162000)\r\nval |= EVERGREEN_DP_SEC_N_BASE_MULTIPLE(3);\r\nelse\r\nval |= EVERGREEN_DP_SEC_N_BASE_MULTIPLE(5);\r\nWREG32(EVERGREEN_DP_SEC_AUD_N + dig->afmt->offset, val);\r\n}\r\nWREG32(EVERGREEN_DP_SEC_CNTL + dig->afmt->offset,\r\nEVERGREEN_DP_SEC_ASP_ENABLE |\r\nEVERGREEN_DP_SEC_ATP_ENABLE |\r\nEVERGREEN_DP_SEC_AIP_ENABLE |\r\nEVERGREEN_DP_SEC_STREAM_ENABLE);\r\n} else {\r\nWREG32(EVERGREEN_DP_SEC_CNTL + dig->afmt->offset, 0);\r\nWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\r\n~AFMT_AUDIO_SAMPLE_SEND);\r\n}\r\ndig->afmt->enabled = enable;\r\n}
