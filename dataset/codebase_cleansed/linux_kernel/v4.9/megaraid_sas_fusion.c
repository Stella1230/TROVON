void\r\nmegasas_enable_intr_fusion(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\ninstance->mask_interrupts = 0;\r\nwritel(~0, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nwritel(~MFI_FUSION_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nvoid\r\nmegasas_disable_intr_fusion(struct megasas_instance *instance)\r\n{\r\nu32 mask = 0xFFFFFFFF;\r\nu32 status;\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\ninstance->mask_interrupts = 1;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nstatus = readl(&regs->outbound_intr_mask);\r\n}\r\nint\r\nmegasas_clear_intr_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & 1) {\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn 1;\r\n}\r\nif (!(status & MFI_FUSION_ENABLE_INTERRUPT_MASK))\r\nreturn 0;\r\nreturn 1;\r\n}\r\ninline struct megasas_cmd_fusion *megasas_get_cmd_fusion(struct megasas_instance\r\n*instance, u32 blk_tag)\r\n{\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nreturn fusion->cmd_list[blk_tag];\r\n}\r\ninline void megasas_return_cmd_fusion(struct megasas_instance *instance,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\ncmd->scmd = NULL;\r\nmemset(cmd->io_request, 0, sizeof(struct MPI2_RAID_SCSI_IO_REQUEST));\r\n}\r\nstatic void\r\nmegasas_fire_cmd_fusion(struct megasas_instance *instance,\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc)\r\n{\r\n#if defined(writeq) && defined(CONFIG_64BIT)\r\nu64 req_data = (((u64)le32_to_cpu(req_desc->u.high) << 32) |\r\nle32_to_cpu(req_desc->u.low));\r\nwriteq(req_data, &instance->reg_set->inbound_low_queue_port);\r\n#else\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel(le32_to_cpu(req_desc->u.low),\r\n&instance->reg_set->inbound_low_queue_port);\r\nwritel(le32_to_cpu(req_desc->u.high),\r\n&instance->reg_set->inbound_high_queue_port);\r\nmmiowb();\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n#endif\r\n}\r\nstatic void\r\nmegasas_fusion_update_can_queue(struct megasas_instance *instance, int fw_boot_context)\r\n{\r\nu16 cur_max_fw_cmds = 0;\r\nu16 ldio_threshold = 0;\r\nstruct megasas_register_set __iomem *reg_set;\r\nreg_set = instance->reg_set;\r\ncur_max_fw_cmds = readl(&instance->reg_set->outbound_scratch_pad_3) & 0x00FFFF;\r\nif (dual_qdepth_disable || !cur_max_fw_cmds)\r\ncur_max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;\r\nelse\r\nldio_threshold =\r\n(instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF) - MEGASAS_FUSION_IOCTL_CMDS;\r\ndev_info(&instance->pdev->dev,\r\n"Current firmware maximum commands: %d\t LDIO threshold: %d\n",\r\ncur_max_fw_cmds, ldio_threshold);\r\nif (fw_boot_context == OCR_CONTEXT) {\r\ncur_max_fw_cmds = cur_max_fw_cmds - 1;\r\nif (cur_max_fw_cmds <= instance->max_fw_cmds) {\r\ninstance->cur_can_queue =\r\ncur_max_fw_cmds - (MEGASAS_FUSION_INTERNAL_CMDS +\r\nMEGASAS_FUSION_IOCTL_CMDS);\r\ninstance->host->can_queue = instance->cur_can_queue;\r\ninstance->ldio_threshold = ldio_threshold;\r\n}\r\n} else {\r\ninstance->max_fw_cmds = cur_max_fw_cmds;\r\ninstance->ldio_threshold = ldio_threshold;\r\nif (!instance->is_rdpq)\r\ninstance->max_fw_cmds = min_t(u16, instance->max_fw_cmds, 1024);\r\nif (reset_devices)\r\ninstance->max_fw_cmds = min(instance->max_fw_cmds,\r\n(u16)MEGASAS_KDUMP_QUEUE_DEPTH);\r\ninstance->max_fw_cmds = instance->max_fw_cmds-1;\r\ninstance->max_scsi_cmds = instance->max_fw_cmds -\r\n(MEGASAS_FUSION_INTERNAL_CMDS +\r\nMEGASAS_FUSION_IOCTL_CMDS);\r\ninstance->cur_can_queue = instance->max_scsi_cmds;\r\n}\r\n}\r\nvoid\r\nmegasas_free_cmds_fusion(struct megasas_instance *instance)\r\n{\r\nint i;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nstruct megasas_cmd_fusion *cmd;\r\nfor (i = 0; i < instance->max_fw_cmds; i++) {\r\ncmd = fusion->cmd_list[i];\r\nif (cmd) {\r\nif (cmd->sg_frame)\r\npci_pool_free(fusion->sg_dma_pool, cmd->sg_frame,\r\ncmd->sg_frame_phys_addr);\r\nif (cmd->sense)\r\npci_pool_free(fusion->sense_dma_pool, cmd->sense,\r\ncmd->sense_phys_addr);\r\n}\r\n}\r\nif (fusion->sg_dma_pool) {\r\npci_pool_destroy(fusion->sg_dma_pool);\r\nfusion->sg_dma_pool = NULL;\r\n}\r\nif (fusion->sense_dma_pool) {\r\npci_pool_destroy(fusion->sense_dma_pool);\r\nfusion->sense_dma_pool = NULL;\r\n}\r\nif (instance->is_rdpq)\r\nmegasas_free_rdpq_fusion(instance);\r\nelse\r\nmegasas_free_reply_fusion(instance);\r\nif (fusion->req_frames_desc)\r\ndma_free_coherent(&instance->pdev->dev,\r\nfusion->request_alloc_sz, fusion->req_frames_desc,\r\nfusion->req_frames_desc_phys);\r\nif (fusion->io_request_frames)\r\npci_pool_free(fusion->io_request_frames_pool,\r\nfusion->io_request_frames,\r\nfusion->io_request_frames_phys);\r\nif (fusion->io_request_frames_pool) {\r\npci_pool_destroy(fusion->io_request_frames_pool);\r\nfusion->io_request_frames_pool = NULL;\r\n}\r\nfor (i = 0; i < instance->max_fw_cmds; i++)\r\nkfree(fusion->cmd_list[i]);\r\nkfree(fusion->cmd_list);\r\n}\r\nstatic int megasas_create_sg_sense_fusion(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd_fusion *cmd;\r\nfusion = instance->ctrl_context;\r\nmax_cmd = instance->max_fw_cmds;\r\nfusion->sg_dma_pool =\r\npci_pool_create("mr_sg", instance->pdev,\r\ninstance->max_chain_frame_sz, 4, 0);\r\nfusion->sense_dma_pool =\r\npci_pool_create("mr_sense", instance->pdev,\r\nSCSI_SENSE_BUFFERSIZE, 64, 0);\r\nif (!fusion->sense_dma_pool || !fusion->sg_dma_pool) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = fusion->cmd_list[i];\r\ncmd->sg_frame = pci_pool_alloc(fusion->sg_dma_pool,\r\nGFP_KERNEL, &cmd->sg_frame_phys_addr);\r\ncmd->sense = pci_pool_alloc(fusion->sense_dma_pool,\r\nGFP_KERNEL, &cmd->sense_phys_addr);\r\nif (!cmd->sg_frame || !cmd->sense) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_alloc_cmdlist_fusion(struct megasas_instance *instance)\r\n{\r\nu32 max_cmd, i;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nmax_cmd = instance->max_fw_cmds;\r\nfusion->cmd_list = kzalloc(sizeof(struct megasas_cmd_fusion *) * max_cmd,\r\nGFP_KERNEL);\r\nif (!fusion->cmd_list) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\nfusion->cmd_list[i] = kzalloc(sizeof(struct megasas_cmd_fusion),\r\nGFP_KERNEL);\r\nif (!fusion->cmd_list[i]) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_alloc_request_fusion(struct megasas_instance *instance)\r\n{\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nfusion->req_frames_desc =\r\ndma_alloc_coherent(&instance->pdev->dev,\r\nfusion->request_alloc_sz,\r\n&fusion->req_frames_desc_phys, GFP_KERNEL);\r\nif (!fusion->req_frames_desc) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfusion->io_request_frames_pool =\r\npci_pool_create("mr_ioreq", instance->pdev,\r\nfusion->io_frames_alloc_sz, 16, 0);\r\nif (!fusion->io_request_frames_pool) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfusion->io_request_frames =\r\npci_pool_alloc(fusion->io_request_frames_pool,\r\nGFP_KERNEL, &fusion->io_request_frames_phys);\r\nif (!fusion->io_request_frames) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_alloc_reply_fusion(struct megasas_instance *instance)\r\n{\r\nint i, count;\r\nstruct fusion_context *fusion;\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\r\nfusion = instance->ctrl_context;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfusion->reply_frames_desc_pool =\r\npci_pool_create("mr_reply", instance->pdev,\r\nfusion->reply_alloc_sz * count, 16, 0);\r\nif (!fusion->reply_frames_desc_pool) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfusion->reply_frames_desc[0] =\r\npci_pool_alloc(fusion->reply_frames_desc_pool,\r\nGFP_KERNEL, &fusion->reply_frames_desc_phys[0]);\r\nif (!fusion->reply_frames_desc[0]) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nreply_desc = fusion->reply_frames_desc[0];\r\nfor (i = 0; i < fusion->reply_q_depth * count; i++, reply_desc++)\r\nreply_desc->Words = cpu_to_le64(ULLONG_MAX);\r\nfor (i = 0; i < (count - 1); i++)\r\nfusion->reply_frames_desc[i + 1] =\r\nfusion->reply_frames_desc[i] +\r\n(fusion->reply_alloc_sz)/sizeof(union MPI2_REPLY_DESCRIPTORS_UNION);\r\nreturn 0;\r\n}\r\nint\r\nmegasas_alloc_rdpq_fusion(struct megasas_instance *instance)\r\n{\r\nint i, j, count;\r\nstruct fusion_context *fusion;\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\r\nfusion = instance->ctrl_context;\r\nfusion->rdpq_virt = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY) * MAX_MSIX_QUEUES_FUSION,\r\n&fusion->rdpq_phys);\r\nif (!fusion->rdpq_virt) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(fusion->rdpq_virt, 0,\r\nsizeof(struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY) * MAX_MSIX_QUEUES_FUSION);\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfusion->reply_frames_desc_pool = pci_pool_create("mr_rdpq",\r\ninstance->pdev, fusion->reply_alloc_sz, 16, 0);\r\nif (!fusion->reply_frames_desc_pool) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nfusion->reply_frames_desc[i] =\r\npci_pool_alloc(fusion->reply_frames_desc_pool,\r\nGFP_KERNEL, &fusion->reply_frames_desc_phys[i]);\r\nif (!fusion->reply_frames_desc[i]) {\r\ndev_err(&instance->pdev->dev,\r\n"Failed from %s %d\n", __func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nfusion->rdpq_virt[i].RDPQBaseAddress =\r\nfusion->reply_frames_desc_phys[i];\r\nreply_desc = fusion->reply_frames_desc[i];\r\nfor (j = 0; j < fusion->reply_q_depth; j++, reply_desc++)\r\nreply_desc->Words = cpu_to_le64(ULLONG_MAX);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nmegasas_free_rdpq_fusion(struct megasas_instance *instance) {\r\nint i;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nfor (i = 0; i < MAX_MSIX_QUEUES_FUSION; i++) {\r\nif (fusion->reply_frames_desc[i])\r\npci_pool_free(fusion->reply_frames_desc_pool,\r\nfusion->reply_frames_desc[i],\r\nfusion->reply_frames_desc_phys[i]);\r\n}\r\nif (fusion->reply_frames_desc_pool)\r\npci_pool_destroy(fusion->reply_frames_desc_pool);\r\nif (fusion->rdpq_virt)\r\npci_free_consistent(instance->pdev,\r\nsizeof(struct MPI2_IOC_INIT_RDPQ_ARRAY_ENTRY) * MAX_MSIX_QUEUES_FUSION,\r\nfusion->rdpq_virt, fusion->rdpq_phys);\r\n}\r\nstatic void\r\nmegasas_free_reply_fusion(struct megasas_instance *instance) {\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nif (fusion->reply_frames_desc[0])\r\npci_pool_free(fusion->reply_frames_desc_pool,\r\nfusion->reply_frames_desc[0],\r\nfusion->reply_frames_desc_phys[0]);\r\nif (fusion->reply_frames_desc_pool)\r\npci_pool_destroy(fusion->reply_frames_desc_pool);\r\n}\r\nint\r\nmegasas_alloc_cmds_fusion(struct megasas_instance *instance)\r\n{\r\nint i;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd_fusion *cmd;\r\nu32 offset;\r\ndma_addr_t io_req_base_phys;\r\nu8 *io_req_base;\r\nfusion = instance->ctrl_context;\r\nif (megasas_alloc_cmdlist_fusion(instance))\r\ngoto fail_exit;\r\nif (megasas_alloc_request_fusion(instance))\r\ngoto fail_exit;\r\nif (instance->is_rdpq) {\r\nif (megasas_alloc_rdpq_fusion(instance))\r\ngoto fail_exit;\r\n} else\r\nif (megasas_alloc_reply_fusion(instance))\r\ngoto fail_exit;\r\nio_req_base = fusion->io_request_frames + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\r\nio_req_base_phys = fusion->io_request_frames_phys + MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\r\nfor (i = 0; i < instance->max_fw_cmds; i++) {\r\ncmd = fusion->cmd_list[i];\r\noffset = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE * i;\r\nmemset(cmd, 0, sizeof(struct megasas_cmd_fusion));\r\ncmd->index = i + 1;\r\ncmd->scmd = NULL;\r\ncmd->sync_cmd_idx = (i >= instance->max_scsi_cmds) ?\r\n(i - instance->max_scsi_cmds) :\r\n(u32)ULONG_MAX;\r\ncmd->instance = instance;\r\ncmd->io_request =\r\n(struct MPI2_RAID_SCSI_IO_REQUEST *)\r\n(io_req_base + offset);\r\nmemset(cmd->io_request, 0,\r\nsizeof(struct MPI2_RAID_SCSI_IO_REQUEST));\r\ncmd->io_request_phys_addr = io_req_base_phys + offset;\r\n}\r\nif (megasas_create_sg_sense_fusion(instance))\r\ngoto fail_exit;\r\nreturn 0;\r\nfail_exit:\r\nmegasas_free_cmds_fusion(instance);\r\nreturn -ENOMEM;\r\n}\r\nint\r\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\r\nint seconds)\r\n{\r\nint i;\r\nstruct megasas_header *frame_hdr = &cmd->frame->hdr;\r\nstruct fusion_context *fusion;\r\nu32 msecs = seconds * 1000;\r\nfusion = instance->ctrl_context;\r\nfor (i = 0; (i < msecs) && (frame_hdr->cmd_status == 0xff); i += 20) {\r\nrmb();\r\nmsleep(20);\r\n}\r\nif (frame_hdr->cmd_status == MFI_STAT_INVALID_STATUS)\r\nreturn DCMD_TIMEOUT;\r\nelse if (frame_hdr->cmd_status == MFI_STAT_OK)\r\nreturn DCMD_SUCCESS;\r\nelse\r\nreturn DCMD_FAILED;\r\n}\r\nint\r\nmegasas_ioc_init_fusion(struct megasas_instance *instance)\r\n{\r\nstruct megasas_init_frame *init_frame;\r\nstruct MPI2_IOC_INIT_REQUEST *IOCInitMessage = NULL;\r\ndma_addr_t ioc_init_handle;\r\nstruct megasas_cmd *cmd;\r\nu8 ret, cur_rdpq_mode;\r\nstruct fusion_context *fusion;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION req_desc;\r\nint i;\r\nstruct megasas_header *frame_hdr;\r\nconst char *sys_info;\r\nMFI_CAPABILITIES *drv_ops;\r\nu32 scratch_pad_2;\r\nfusion = instance->ctrl_context;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\ndev_err(&instance->pdev->dev, "Could not allocate cmd for INIT Frame\n");\r\nret = 1;\r\ngoto fail_get_cmd;\r\n}\r\nscratch_pad_2 = readl\r\n(&instance->reg_set->outbound_scratch_pad_2);\r\ncur_rdpq_mode = (scratch_pad_2 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;\r\nif (instance->is_rdpq && !cur_rdpq_mode) {\r\ndev_err(&instance->pdev->dev, "Firmware downgrade *NOT SUPPORTED*"\r\n" from RDPQ mode to non RDPQ mode\n");\r\nret = 1;\r\ngoto fail_fw_init;\r\n}\r\nIOCInitMessage =\r\ndma_alloc_coherent(&instance->pdev->dev,\r\nsizeof(struct MPI2_IOC_INIT_REQUEST),\r\n&ioc_init_handle, GFP_KERNEL);\r\nif (!IOCInitMessage) {\r\ndev_err(&instance->pdev->dev, "Could not allocate memory for "\r\n"IOCInitMessage\n");\r\nret = 1;\r\ngoto fail_fw_init;\r\n}\r\nmemset(IOCInitMessage, 0, sizeof(struct MPI2_IOC_INIT_REQUEST));\r\nIOCInitMessage->Function = MPI2_FUNCTION_IOC_INIT;\r\nIOCInitMessage->WhoInit = MPI2_WHOINIT_HOST_DRIVER;\r\nIOCInitMessage->MsgVersion = cpu_to_le16(MPI2_VERSION);\r\nIOCInitMessage->HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);\r\nIOCInitMessage->SystemRequestFrameSize = cpu_to_le16(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE / 4);\r\nIOCInitMessage->ReplyDescriptorPostQueueDepth = cpu_to_le16(fusion->reply_q_depth);\r\nIOCInitMessage->ReplyDescriptorPostQueueAddress = instance->is_rdpq ?\r\ncpu_to_le64(fusion->rdpq_phys) :\r\ncpu_to_le64(fusion->reply_frames_desc_phys[0]);\r\nIOCInitMessage->MsgFlags = instance->is_rdpq ?\r\nMPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE : 0;\r\nIOCInitMessage->SystemRequestFrameBaseAddress = cpu_to_le64(fusion->io_request_frames_phys);\r\nIOCInitMessage->HostMSIxVectors = instance->msix_vectors;\r\ninit_frame = (struct megasas_init_frame *)cmd->frame;\r\nmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\r\nframe_hdr = &cmd->frame->hdr;\r\nframe_hdr->cmd_status = 0xFF;\r\nframe_hdr->flags = cpu_to_le16(\r\nle16_to_cpu(frame_hdr->flags) |\r\nMFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\r\ninit_frame->cmd = MFI_CMD_INIT;\r\ninit_frame->cmd_status = 0xFF;\r\ndrv_ops = (MFI_CAPABILITIES *) &(init_frame->driver_operations);\r\nif (fusion->adapter_type == INVADER_SERIES)\r\ndrv_ops->mfi_capabilities.support_additional_msix = 1;\r\ndrv_ops->mfi_capabilities.support_fp_remote_lun = 1;\r\ndrv_ops->mfi_capabilities.support_max_255lds = 1;\r\ndrv_ops->mfi_capabilities.support_ndrive_r1_lb = 1;\r\ndrv_ops->mfi_capabilities.security_protocol_cmds_fw = 1;\r\nif (instance->max_chain_frame_sz > MEGASAS_CHAIN_FRAME_SZ_MIN)\r\ndrv_ops->mfi_capabilities.support_ext_io_size = 1;\r\ndrv_ops->mfi_capabilities.support_fp_rlbypass = 1;\r\nif (!dual_qdepth_disable)\r\ndrv_ops->mfi_capabilities.support_ext_queue_depth = 1;\r\ndrv_ops->mfi_capabilities.support_qd_throttling = 1;\r\ncpu_to_le32s((u32 *)&init_frame->driver_operations.mfi_capabilities);\r\nsys_info = dmi_get_system_info(DMI_PRODUCT_UUID);\r\nif (instance->system_info_buf && sys_info) {\r\nmemcpy(instance->system_info_buf->systemId, sys_info,\r\nstrlen(sys_info) > 64 ? 64 : strlen(sys_info));\r\ninstance->system_info_buf->systemIdLength =\r\nstrlen(sys_info) > 64 ? 64 : strlen(sys_info);\r\ninit_frame->system_info_lo = instance->system_info_h;\r\ninit_frame->system_info_hi = 0;\r\n}\r\ninit_frame->queue_info_new_phys_addr_hi =\r\ncpu_to_le32(upper_32_bits(ioc_init_handle));\r\ninit_frame->queue_info_new_phys_addr_lo =\r\ncpu_to_le32(lower_32_bits(ioc_init_handle));\r\ninit_frame->data_xfer_len = cpu_to_le32(sizeof(struct MPI2_IOC_INIT_REQUEST));\r\nreq_desc.u.low = cpu_to_le32(lower_32_bits(cmd->frame_phys_addr));\r\nreq_desc.u.high = cpu_to_le32(upper_32_bits(cmd->frame_phys_addr));\r\nreq_desc.MFAIo.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_MFA <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\ninstance->instancet->disable_intr(instance);\r\nfor (i = 0; i < (10 * 1000); i += 20) {\r\nif (readl(&instance->reg_set->doorbell) & 1)\r\nmsleep(20);\r\nelse\r\nbreak;\r\n}\r\nmegasas_fire_cmd_fusion(instance, &req_desc);\r\nwait_and_poll(instance, cmd, MFI_POLL_TIMEOUT_SECS);\r\nframe_hdr = &cmd->frame->hdr;\r\nif (frame_hdr->cmd_status != 0) {\r\nret = 1;\r\ngoto fail_fw_init;\r\n}\r\ndev_info(&instance->pdev->dev, "Init cmd success\n");\r\nret = 0;\r\nfail_fw_init:\r\nmegasas_return_cmd(instance, cmd);\r\nif (IOCInitMessage)\r\ndma_free_coherent(&instance->pdev->dev,\r\nsizeof(struct MPI2_IOC_INIT_REQUEST),\r\nIOCInitMessage, ioc_init_handle);\r\nfail_get_cmd:\r\nreturn ret;\r\n}\r\nint\r\nmegasas_sync_pd_seq_num(struct megasas_instance *instance, bool pend) {\r\nint ret = 0;\r\nu32 pd_seq_map_sz;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\r\ndma_addr_t pd_seq_h;\r\npd_sync = (void *)fusion->pd_seq_sync[(instance->pd_seq_map_id & 1)];\r\npd_seq_h = fusion->pd_seq_phys[(instance->pd_seq_map_id & 1)];\r\npd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\r\n(sizeof(struct MR_PD_CFG_SEQ) *\r\n(MAX_PHYSICAL_DEVICES - 1));\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\ndev_err(&instance->pdev->dev,\r\n"Could not get mfi cmd. Fail from %s %d\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(pd_sync, 0, pd_seq_map_sz);\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(pd_seq_map_sz);\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_SYSTEM_PD_MAP_GET_INFO);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(pd_seq_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(pd_seq_map_sz);\r\nif (pend) {\r\ndcmd->mbox.b[0] = MEGASAS_DCMD_MBOX_PEND_FLAG;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_WRITE);\r\ninstance->jbod_seq_cmd = cmd;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn 0;\r\n}\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMFI_IO_TIMEOUT_SECS);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\nif (le32_to_cpu(pd_sync->count) > MAX_PHYSICAL_DEVICES) {\r\ndev_warn(&instance->pdev->dev,\r\n"driver supports max %d JBOD, but FW reports %d\n",\r\nMAX_PHYSICAL_DEVICES, le32_to_cpu(pd_sync->count));\r\nret = -EINVAL;\r\n}\r\nif (ret == DCMD_TIMEOUT && instance->ctrl_context)\r\nmegaraid_sas_kill_hba(instance);\r\nif (ret == DCMD_SUCCESS)\r\ninstance->pd_seq_map_id++;\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_get_ld_map_info(struct megasas_instance *instance)\r\n{\r\nint ret = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nvoid *ci;\r\ndma_addr_t ci_h = 0;\r\nu32 size_map_info;\r\nstruct fusion_context *fusion;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\ndev_printk(KERN_DEBUG, &instance->pdev->dev, "Failed to get cmd for map info\n");\r\nreturn -ENOMEM;\r\n}\r\nfusion = instance->ctrl_context;\r\nif (!fusion) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENXIO;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nsize_map_info = fusion->current_map_sz;\r\nci = (void *) fusion->ld_map[(instance->map_id & 1)];\r\nci_h = fusion->ld_map_phys[(instance->map_id & 1)];\r\nif (!ci) {\r\ndev_printk(KERN_DEBUG, &instance->pdev->dev, "Failed to alloc mem for ld_map_info\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, fusion->max_map_sz);\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\n#if VD_EXT_DEBUG\r\ndev_dbg(&instance->pdev->dev,\r\n"%s sending MR_DCMD_LD_MAP_GET_INFO with size %d\n",\r\n__func__, cpu_to_le32(size_map_info));\r\n#endif\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(size_map_info);\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_LD_MAP_GET_INFO);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(size_map_info);\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMFI_IO_TIMEOUT_SECS);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\nif (ret == DCMD_TIMEOUT && instance->ctrl_context)\r\nmegaraid_sas_kill_hba(instance);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nu8\r\nmegasas_get_map_info(struct megasas_instance *instance)\r\n{\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nfusion->fast_path_io = 0;\r\nif (!megasas_get_ld_map_info(instance)) {\r\nif (MR_ValidateMapInfo(instance)) {\r\nfusion->fast_path_io = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\nmegasas_sync_map_info(struct megasas_instance *instance)\r\n{\r\nint ret = 0, i;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nu32 size_sync_info, num_lds;\r\nstruct fusion_context *fusion;\r\nstruct MR_LD_TARGET_SYNC *ci = NULL;\r\nstruct MR_DRV_RAID_MAP_ALL *map;\r\nstruct MR_LD_RAID *raid;\r\nstruct MR_LD_TARGET_SYNC *ld_sync;\r\ndma_addr_t ci_h = 0;\r\nu32 size_map_info;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\ndev_printk(KERN_DEBUG, &instance->pdev->dev, "Failed to get cmd for sync info\n");\r\nreturn -ENOMEM;\r\n}\r\nfusion = instance->ctrl_context;\r\nif (!fusion) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 1;\r\n}\r\nmap = fusion->ld_drv_map[instance->map_id & 1];\r\nnum_lds = le16_to_cpu(map->raidMap.ldCount);\r\ndcmd = &cmd->frame->dcmd;\r\nsize_sync_info = sizeof(struct MR_LD_TARGET_SYNC) *num_lds;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\nci = (struct MR_LD_TARGET_SYNC *)\r\nfusion->ld_map[(instance->map_id - 1) & 1];\r\nmemset(ci, 0, fusion->max_map_sz);\r\nci_h = fusion->ld_map_phys[(instance->map_id - 1) & 1];\r\nld_sync = (struct MR_LD_TARGET_SYNC *)ci;\r\nfor (i = 0; i < num_lds; i++, ld_sync++) {\r\nraid = MR_LdRaidGet(i, map);\r\nld_sync->targetId = MR_GetLDTgtId(i, map);\r\nld_sync->seqNum = raid->seqNum;\r\n}\r\nsize_map_info = fusion->current_map_sz;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_WRITE);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(size_map_info);\r\ndcmd->mbox.b[0] = num_lds;\r\ndcmd->mbox.b[1] = MEGASAS_DCMD_MBOX_PEND_FLAG;\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_LD_MAP_GET_INFO);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(size_map_info);\r\ninstance->map_update_cmd = cmd;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic void\r\nmegasas_display_intel_branding(struct megasas_instance *instance)\r\n{\r\nif (instance->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)\r\nreturn;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\nswitch (instance->pdev->subsystem_device) {\r\ncase MEGARAID_INTEL_RS3DC080_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3DC080_BRANDING);\r\nbreak;\r\ncase MEGARAID_INTEL_RS3DC040_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3DC040_BRANDING);\r\nbreak;\r\ncase MEGARAID_INTEL_RS3SC008_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3SC008_BRANDING);\r\nbreak;\r\ncase MEGARAID_INTEL_RS3MC044_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3MC044_BRANDING);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_FURY:\r\nswitch (instance->pdev->subsystem_device) {\r\ncase MEGARAID_INTEL_RS3WC080_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3WC080_BRANDING);\r\nbreak;\r\ncase MEGARAID_INTEL_RS3WC040_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RS3WC040_BRANDING);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_CUTLASS_52:\r\ncase PCI_DEVICE_ID_LSI_CUTLASS_53:\r\nswitch (instance->pdev->subsystem_device) {\r\ncase MEGARAID_INTEL_RMS3BC160_SSDID:\r\ndev_info(&instance->pdev->dev, "scsi host %d: %s\n",\r\ninstance->host->host_no,\r\nMEGARAID_INTEL_RMS3BC160_BRANDING);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nu32\r\nmegasas_init_adapter_fusion(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *reg_set;\r\nstruct fusion_context *fusion;\r\nu32 max_cmd, scratch_pad_2;\r\nint i = 0, count;\r\nfusion = instance->ctrl_context;\r\nreg_set = instance->reg_set;\r\nmegasas_fusion_update_can_queue(instance, PROBE_CONTEXT);\r\ninstance->max_fw_cmds = instance->max_fw_cmds-1;\r\ninstance->max_mfi_cmds =\r\nMEGASAS_FUSION_INTERNAL_CMDS + MEGASAS_FUSION_IOCTL_CMDS;\r\nmax_cmd = instance->max_fw_cmds;\r\nfusion->reply_q_depth = 2 * (((max_cmd + 1 + 15)/16)*16);\r\nfusion->request_alloc_sz =\r\nsizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) *max_cmd;\r\nfusion->reply_alloc_sz = sizeof(union MPI2_REPLY_DESCRIPTORS_UNION)\r\n*(fusion->reply_q_depth);\r\nfusion->io_frames_alloc_sz = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE +\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE *\r\n(max_cmd + 1));\r\nscratch_pad_2 = readl(&instance->reg_set->outbound_scratch_pad_2);\r\nif (scratch_pad_2 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK)\r\ninstance->max_chain_frame_sz =\r\n((scratch_pad_2 & MEGASAS_MAX_CHAIN_SIZE_MASK) >>\r\nMEGASAS_MAX_CHAIN_SHIFT) * MEGASAS_1MB_IO;\r\nelse\r\ninstance->max_chain_frame_sz =\r\n((scratch_pad_2 & MEGASAS_MAX_CHAIN_SIZE_MASK) >>\r\nMEGASAS_MAX_CHAIN_SHIFT) * MEGASAS_256K_IO;\r\nif (instance->max_chain_frame_sz < MEGASAS_CHAIN_FRAME_SZ_MIN) {\r\ndev_warn(&instance->pdev->dev, "frame size %d invalid, fall back to legacy max frame size %d\n",\r\ninstance->max_chain_frame_sz,\r\nMEGASAS_CHAIN_FRAME_SZ_MIN);\r\ninstance->max_chain_frame_sz = MEGASAS_CHAIN_FRAME_SZ_MIN;\r\n}\r\nfusion->max_sge_in_main_msg =\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE\r\n- offsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL))/16;\r\nfusion->max_sge_in_chain =\r\ninstance->max_chain_frame_sz\r\n/ sizeof(union MPI2_SGE_IO_UNION);\r\ninstance->max_num_sge =\r\nrounddown_pow_of_two(fusion->max_sge_in_main_msg\r\n+ fusion->max_sge_in_chain - 2);\r\nfusion->chain_offset_mfi_pthru =\r\noffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL)/16;\r\nfusion->chain_offset_io_request =\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE -\r\nsizeof(union MPI2_SGE_IO_UNION))/16;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfor (i = 0 ; i < count; i++)\r\nfusion->last_reply_idx[i] = 0;\r\ninstance->max_scsi_cmds = instance->max_fw_cmds -\r\n(MEGASAS_FUSION_INTERNAL_CMDS +\r\nMEGASAS_FUSION_IOCTL_CMDS);\r\nsema_init(&instance->ioctl_sem, MEGASAS_FUSION_IOCTL_CMDS);\r\nif (megasas_alloc_cmds(instance))\r\ngoto fail_alloc_mfi_cmds;\r\nif (megasas_alloc_cmds_fusion(instance))\r\ngoto fail_alloc_cmds;\r\nif (megasas_ioc_init_fusion(instance))\r\ngoto fail_ioc_init;\r\nmegasas_display_intel_branding(instance);\r\nif (megasas_get_ctrl_info(instance)) {\r\ndev_err(&instance->pdev->dev,\r\n"Could not get controller info. Fail from %s %d\n",\r\n__func__, __LINE__);\r\ngoto fail_ioc_init;\r\n}\r\ninstance->flag_ieee = 1;\r\nfusion->fast_path_io = 0;\r\nfusion->drv_map_pages = get_order(fusion->drv_map_sz);\r\nfor (i = 0; i < 2; i++) {\r\nfusion->ld_map[i] = NULL;\r\nfusion->ld_drv_map[i] = (void *)__get_free_pages(GFP_KERNEL,\r\nfusion->drv_map_pages);\r\nif (!fusion->ld_drv_map[i]) {\r\ndev_err(&instance->pdev->dev, "Could not allocate "\r\n"memory for local map info for %d pages\n",\r\nfusion->drv_map_pages);\r\nif (i == 1)\r\nfree_pages((ulong)fusion->ld_drv_map[0],\r\nfusion->drv_map_pages);\r\ngoto fail_ioc_init;\r\n}\r\nmemset(fusion->ld_drv_map[i], 0,\r\n((1 << PAGE_SHIFT) << fusion->drv_map_pages));\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfusion->ld_map[i] = dma_alloc_coherent(&instance->pdev->dev,\r\nfusion->max_map_sz,\r\n&fusion->ld_map_phys[i],\r\nGFP_KERNEL);\r\nif (!fusion->ld_map[i]) {\r\ndev_err(&instance->pdev->dev, "Could not allocate memory "\r\n"for map info\n");\r\ngoto fail_map_info;\r\n}\r\n}\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\nreturn 0;\r\nfail_map_info:\r\nif (i == 1)\r\ndma_free_coherent(&instance->pdev->dev, fusion->max_map_sz,\r\nfusion->ld_map[0], fusion->ld_map_phys[0]);\r\nfail_ioc_init:\r\nmegasas_free_cmds_fusion(instance);\r\nfail_alloc_cmds:\r\nmegasas_free_cmds(instance);\r\nfail_alloc_mfi_cmds:\r\nreturn 1;\r\n}\r\nvoid\r\nmap_cmd_status(struct megasas_cmd_fusion *cmd, u8 status, u8 ext_status)\r\n{\r\nswitch (status) {\r\ncase MFI_STAT_OK:\r\ncmd->scmd->result = DID_OK << 16;\r\nbreak;\r\ncase MFI_STAT_SCSI_IO_FAILED:\r\ncase MFI_STAT_LD_INIT_IN_PROGRESS:\r\ncmd->scmd->result = (DID_ERROR << 16) | ext_status;\r\nbreak;\r\ncase MFI_STAT_SCSI_DONE_WITH_ERROR:\r\ncmd->scmd->result = (DID_OK << 16) | ext_status;\r\nif (ext_status == SAM_STAT_CHECK_CONDITION) {\r\nmemset(cmd->scmd->sense_buffer, 0,\r\nSCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->scmd->sense_buffer, cmd->sense,\r\nSCSI_SENSE_BUFFERSIZE);\r\ncmd->scmd->result |= DRIVER_SENSE << 24;\r\n}\r\nbreak;\r\ncase MFI_STAT_LD_OFFLINE:\r\ncase MFI_STAT_DEVICE_NOT_FOUND:\r\ncmd->scmd->result = DID_BAD_TARGET << 16;\r\nbreak;\r\ncase MFI_STAT_CONFIG_SEQ_MISMATCH:\r\ncmd->scmd->result = DID_IMM_RETRY << 16;\r\nbreak;\r\ndefault:\r\ndev_printk(KERN_DEBUG, &cmd->instance->pdev->dev, "FW status %#x\n", status);\r\ncmd->scmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nmegasas_make_sgl_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nint i, sg_processed, sge_count;\r\nstruct scatterlist *os_sgl;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end = sgl_ptr;\r\nsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\r\nsgl_ptr_end->Flags = 0;\r\n}\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count > instance->max_num_sge || !sge_count)\r\nreturn sge_count;\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nsgl_ptr->Length = cpu_to_le32(sg_dma_len(os_sgl));\r\nsgl_ptr->Address = cpu_to_le64(sg_dma_address(os_sgl));\r\nsgl_ptr->Flags = 0;\r\nif (fusion->adapter_type == INVADER_SERIES)\r\nif (i == sge_count - 1)\r\nsgl_ptr->Flags = IEEE_SGE_FLAGS_END_OF_LIST;\r\nsgl_ptr++;\r\nsg_processed = i + 1;\r\nif ((sg_processed == (fusion->max_sge_in_main_msg - 1)) &&\r\n(sge_count > fusion->max_sge_in_main_msg)) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sg_chain;\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\nif ((le16_to_cpu(cmd->io_request->IoFlags) &\r\nMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH) !=\r\nMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH)\r\ncmd->io_request->ChainOffset =\r\nfusion->\r\nchain_offset_io_request;\r\nelse\r\ncmd->io_request->ChainOffset = 0;\r\n} else\r\ncmd->io_request->ChainOffset =\r\nfusion->chain_offset_io_request;\r\nsg_chain = sgl_ptr;\r\nsg_chain->NextChainOffset = 0;\r\nif (fusion->adapter_type == INVADER_SERIES)\r\nsg_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT;\r\nelse\r\nsg_chain->Flags =\r\n(IEEE_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR);\r\nsg_chain->Length = cpu_to_le32((sizeof(union MPI2_SGE_IO_UNION) * (sge_count - sg_processed)));\r\nsg_chain->Address = cpu_to_le64(cmd->sg_frame_phys_addr);\r\nsgl_ptr =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)cmd->sg_frame;\r\nmemset(sgl_ptr, 0, instance->max_chain_frame_sz);\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nvoid\r\nmegasas_set_pd_lba(struct MPI2_RAID_SCSI_IO_REQUEST *io_request, u8 cdb_len,\r\nstruct IO_REQUEST_INFO *io_info, struct scsi_cmnd *scp,\r\nstruct MR_DRV_RAID_MAP_ALL *local_map_ptr, u32 ref_tag)\r\n{\r\nstruct MR_LD_RAID *raid;\r\nu32 ld;\r\nu64 start_blk = io_info->pdBlock;\r\nu8 *cdb = io_request->CDB.CDB32;\r\nu32 num_blocks = io_info->numBlocks;\r\nu8 opcode = 0, flagvals = 0, groupnum = 0, control = 0;\r\nld = MR_TargetIdToLdGet(io_info->ldTgtId, local_map_ptr);\r\nraid = MR_LdRaidGet(ld, local_map_ptr);\r\nif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER) {\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = MEGASAS_SCSI_VARIABLE_LENGTH_CMD;\r\ncdb[7] = MEGASAS_SCSI_ADDL_CDB_LEN;\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\ncdb[9] = MEGASAS_SCSI_SERVICE_ACTION_READ32;\r\nelse\r\ncdb[9] = MEGASAS_SCSI_SERVICE_ACTION_WRITE32;\r\ncdb[10] = MEGASAS_RD_WR_PROTECT_CHECK_ALL;\r\ncdb[12] = (u8)((start_blk >> 56) & 0xff);\r\ncdb[13] = (u8)((start_blk >> 48) & 0xff);\r\ncdb[14] = (u8)((start_blk >> 40) & 0xff);\r\ncdb[15] = (u8)((start_blk >> 32) & 0xff);\r\ncdb[16] = (u8)((start_blk >> 24) & 0xff);\r\ncdb[17] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[18] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[19] = (u8)(start_blk & 0xff);\r\nio_request->CDB.EEDP32.PrimaryReferenceTag =\r\ncpu_to_be32(ref_tag);\r\nio_request->CDB.EEDP32.PrimaryApplicationTagMask = cpu_to_be16(0xffff);\r\nio_request->IoFlags = cpu_to_le16(32);\r\ncdb[28] = (u8)((num_blocks >> 24) & 0xff);\r\ncdb[29] = (u8)((num_blocks >> 16) & 0xff);\r\ncdb[30] = (u8)((num_blocks >> 8) & 0xff);\r\ncdb[31] = (u8)(num_blocks & 0xff);\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE) {\r\nio_request->EEDPFlags = cpu_to_le16(\r\nMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_APPTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD);\r\n} else {\r\nio_request->EEDPFlags = cpu_to_le16(\r\nMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_INSERT_OP);\r\n}\r\nio_request->Control |= cpu_to_le32((0x4 << 26));\r\nio_request->EEDPBlockSize = cpu_to_le32(scp->device->sector_size);\r\n} else {\r\nif (((cdb_len == 12) || (cdb_len == 16)) &&\r\n(start_blk <= 0xffffffff)) {\r\nif (cdb_len == 16) {\r\nopcode = cdb[0] == READ_16 ? READ_10 : WRITE_10;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[14];\r\ncontrol = cdb[15];\r\n} else {\r\nopcode = cdb[0] == READ_12 ? READ_10 : WRITE_10;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[10];\r\ncontrol = cdb[11];\r\n}\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = opcode;\r\ncdb[1] = flagvals;\r\ncdb[6] = groupnum;\r\ncdb[9] = control;\r\ncdb[8] = (u8)(num_blocks & 0xff);\r\ncdb[7] = (u8)((num_blocks >> 8) & 0xff);\r\nio_request->IoFlags = cpu_to_le16(10);\r\ncdb_len = 10;\r\n} else if ((cdb_len < 16) && (start_blk > 0xffffffff)) {\r\nswitch (cdb_len) {\r\ncase 6:\r\nopcode = cdb[0] == READ_6 ? READ_16 : WRITE_16;\r\ncontrol = cdb[5];\r\nbreak;\r\ncase 10:\r\nopcode =\r\ncdb[0] == READ_10 ? READ_16 : WRITE_16;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[6];\r\ncontrol = cdb[9];\r\nbreak;\r\ncase 12:\r\nopcode =\r\ncdb[0] == READ_12 ? READ_16 : WRITE_16;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[10];\r\ncontrol = cdb[11];\r\nbreak;\r\n}\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = opcode;\r\ncdb[1] = flagvals;\r\ncdb[14] = groupnum;\r\ncdb[15] = control;\r\ncdb[13] = (u8)(num_blocks & 0xff);\r\ncdb[12] = (u8)((num_blocks >> 8) & 0xff);\r\ncdb[11] = (u8)((num_blocks >> 16) & 0xff);\r\ncdb[10] = (u8)((num_blocks >> 24) & 0xff);\r\nio_request->IoFlags = cpu_to_le16(16);\r\ncdb_len = 16;\r\n}\r\nswitch (cdb_len) {\r\ncase 6:\r\n{\r\nu8 val = cdb[1] & 0xE0;\r\ncdb[3] = (u8)(start_blk & 0xff);\r\ncdb[2] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[1] = val | ((u8)(start_blk >> 16) & 0x1f);\r\nbreak;\r\n}\r\ncase 10:\r\ncdb[5] = (u8)(start_blk & 0xff);\r\ncdb[4] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 24) & 0xff);\r\nbreak;\r\ncase 12:\r\ncdb[5] = (u8)(start_blk & 0xff);\r\ncdb[4] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 24) & 0xff);\r\nbreak;\r\ncase 16:\r\ncdb[9] = (u8)(start_blk & 0xff);\r\ncdb[8] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[7] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[6] = (u8)((start_blk >> 24) & 0xff);\r\ncdb[5] = (u8)((start_blk >> 32) & 0xff);\r\ncdb[4] = (u8)((start_blk >> 40) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 48) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 56) & 0xff);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid\r\nmegasas_build_ldio_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nu8 fp_possible;\r\nu32 start_lba_lo, start_lba_hi, device_id, datalength = 0;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nstruct IO_REQUEST_INFO io_info;\r\nstruct fusion_context *fusion;\r\nstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\r\nu8 *raidLUN;\r\ndevice_id = MEGASAS_DEV_INDEX(scp);\r\nfusion = instance->ctrl_context;\r\nio_request = cmd->io_request;\r\nio_request->RaidContext.VirtualDiskTgtId = cpu_to_le16(device_id);\r\nio_request->RaidContext.status = 0;\r\nio_request->RaidContext.exStatus = 0;\r\nreq_desc = (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)cmd->request_desc;\r\nstart_lba_lo = 0;\r\nstart_lba_hi = 0;\r\nfp_possible = 0;\r\nif (scp->cmd_len == 6) {\r\ndatalength = (u32) scp->cmnd[4];\r\nstart_lba_lo = ((u32) scp->cmnd[1] << 16) |\r\n((u32) scp->cmnd[2] << 8) | (u32) scp->cmnd[3];\r\nstart_lba_lo &= 0x1FFFFF;\r\n}\r\nelse if (scp->cmd_len == 10) {\r\ndatalength = (u32) scp->cmnd[8] |\r\n((u32) scp->cmnd[7] << 8);\r\nstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 12) {\r\ndatalength = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 16) {\r\ndatalength = ((u32) scp->cmnd[10] << 24) |\r\n((u32) scp->cmnd[11] << 16) |\r\n((u32) scp->cmnd[12] << 8) | (u32) scp->cmnd[13];\r\nstart_lba_lo = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nstart_lba_hi = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nmemset(&io_info, 0, sizeof(struct IO_REQUEST_INFO));\r\nio_info.ldStartBlock = ((u64)start_lba_hi << 32) | start_lba_lo;\r\nio_info.numBlocks = datalength;\r\nio_info.ldTgtId = device_id;\r\nio_request->DataLength = cpu_to_le32(scsi_bufflen(scp));\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nio_info.isRead = 1;\r\nlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\r\nif ((MR_TargetIdToLdGet(device_id, local_map_ptr) >=\r\ninstance->fw_supported_vd_count) || (!fusion->fast_path_io)) {\r\nio_request->RaidContext.regLockFlags = 0;\r\nfp_possible = 0;\r\n} else {\r\nif (MR_BuildRaidContext(instance, &io_info,\r\n&io_request->RaidContext,\r\nlocal_map_ptr, &raidLUN))\r\nfp_possible = io_info.fpOkForIo;\r\n}\r\ncmd->request_desc->SCSIIO.MSIxIndex = instance->msix_vectors ?\r\nraw_smp_processor_id() % instance->msix_vectors : 0;\r\nif (fp_possible) {\r\nmegasas_set_pd_lba(io_request, scp->cmd_len, &io_info, scp,\r\nlocal_map_ptr, start_lba_lo);\r\nio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_FP_IO\r\n<< MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\nif (io_request->RaidContext.regLockFlags ==\r\nREGION_TYPE_UNUSED)\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nio_request->RaidContext.Type = MPI2_TYPE_CUDA;\r\nio_request->RaidContext.nseg = 0x1;\r\nio_request->IoFlags |= cpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);\r\nio_request->RaidContext.regLockFlags |=\r\n(MR_RL_FLAGS_GRANT_DESTINATION_CUDA |\r\nMR_RL_FLAGS_SEQ_NUM_ENABLE);\r\n}\r\nif ((fusion->load_balance_info[device_id].loadBalanceFlag) &&\r\n(io_info.isRead)) {\r\nio_info.devHandle =\r\nget_updated_dev_handle(instance,\r\n&fusion->load_balance_info[device_id],\r\n&io_info);\r\nscp->SCp.Status |= MEGASAS_LOAD_BALANCE_FLAG;\r\ncmd->pd_r1_lb = io_info.pd_after_lb;\r\n} else\r\nscp->SCp.Status &= ~MEGASAS_LOAD_BALANCE_FLAG;\r\nif ((raidLUN[0] == 1) &&\r\n(local_map_ptr->raidMap.devHndlInfo[io_info.pd_after_lb].validHandles > 1)) {\r\ninstance->dev_handle = !(instance->dev_handle);\r\nio_info.devHandle =\r\nlocal_map_ptr->raidMap.devHndlInfo[io_info.pd_after_lb].devHandle[instance->dev_handle];\r\n}\r\ncmd->request_desc->SCSIIO.DevHandle = io_info.devHandle;\r\nio_request->DevHandle = io_info.devHandle;\r\nmemcpy(io_request->LUN, raidLUN, 8);\r\n} else {\r\nio_request->RaidContext.timeoutValue =\r\ncpu_to_le16(local_map_ptr->raidMap.fpPdIoTimeoutSec);\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_LD_IO\r\n<< MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\nif (io_info.do_fp_rlbypass ||\r\n(io_request->RaidContext.regLockFlags == REGION_TYPE_UNUSED))\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nio_request->RaidContext.Type = MPI2_TYPE_CUDA;\r\nio_request->RaidContext.regLockFlags |=\r\n(MR_RL_FLAGS_GRANT_DESTINATION_CPU0 |\r\nMR_RL_FLAGS_SEQ_NUM_ENABLE);\r\nio_request->RaidContext.nseg = 0x1;\r\n}\r\nio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\r\nio_request->DevHandle = cpu_to_le16(device_id);\r\n}\r\n}\r\nstatic void megasas_build_ld_nonrw_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd, struct megasas_cmd_fusion *cmd)\r\n{\r\nu32 device_id;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\r\nu16 pd_index = 0;\r\nstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nu8 span, physArm;\r\n__le16 devHandle;\r\nu32 ld, arRef, pd;\r\nstruct MR_LD_RAID *raid;\r\nstruct RAID_CONTEXT *pRAID_Context;\r\nu8 fp_possible = 1;\r\nio_request = cmd->io_request;\r\ndevice_id = MEGASAS_DEV_INDEX(scmd);\r\npd_index = MEGASAS_PD_INDEX(scmd);\r\nlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\r\nio_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\r\npRAID_Context = &io_request->RaidContext;\r\npRAID_Context->VirtualDiskTgtId = cpu_to_le16(device_id);\r\npRAID_Context->regLockRowLBA = 0;\r\npRAID_Context->regLockLength = 0;\r\nif (fusion->fast_path_io && (\r\ndevice_id < instance->fw_supported_vd_count)) {\r\nld = MR_TargetIdToLdGet(device_id, local_map_ptr);\r\nif (ld >= instance->fw_supported_vd_count)\r\nfp_possible = 0;\r\nraid = MR_LdRaidGet(ld, local_map_ptr);\r\nif (!(raid->capability.fpNonRWCapable))\r\nfp_possible = 0;\r\n} else\r\nfp_possible = 0;\r\nif (!fp_possible) {\r\nio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\r\nio_request->DevHandle = cpu_to_le16(device_id);\r\nio_request->LUN[1] = scmd->device->lun;\r\npRAID_Context->timeoutValue =\r\ncpu_to_le16 (scmd->request->timeout / HZ);\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\n} else {\r\npRAID_Context->configSeqNum = raid->seqNum;\r\npRAID_Context->regLockFlags = REGION_TYPE_SHARED_READ;\r\npRAID_Context->timeoutValue = cpu_to_le16(raid->fpIoTimeoutForLd);\r\nspan = physArm = 0;\r\narRef = MR_LdSpanArrayGet(ld, span, local_map_ptr);\r\npd = MR_ArPdGet(arRef, physArm, local_map_ptr);\r\ndevHandle = MR_PdDevHandleGet(pd, local_map_ptr);\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_FP_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\ncmd->request_desc->SCSIIO.DevHandle = devHandle;\r\nmemcpy(io_request->LUN, raid->LUN, 8);\r\nio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\nio_request->DevHandle = devHandle;\r\n}\r\n}\r\nstatic void\r\nmegasas_build_syspd_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd, struct megasas_cmd_fusion *cmd, u8 fp_possible)\r\n{\r\nu32 device_id;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\r\nu16 pd_index = 0;\r\nu16 os_timeout_value;\r\nu16 timeout_limit;\r\nstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\r\nstruct RAID_CONTEXT *pRAID_Context;\r\nstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\npd_sync = (void *)fusion->pd_seq_sync[(instance->pd_seq_map_id - 1) & 1];\r\ndevice_id = MEGASAS_DEV_INDEX(scmd);\r\npd_index = MEGASAS_PD_INDEX(scmd);\r\nos_timeout_value = scmd->request->timeout / HZ;\r\nio_request = cmd->io_request;\r\npRAID_Context = &io_request->RaidContext;\r\npRAID_Context->regLockFlags = 0;\r\npRAID_Context->regLockRowLBA = 0;\r\npRAID_Context->regLockLength = 0;\r\nio_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\r\nio_request->LUN[1] = scmd->device->lun;\r\npRAID_Context->RAIDFlags = MR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD\r\n<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT;\r\nif (instance->use_seqnum_jbod_fp &&\r\ninstance->pd_list[pd_index].driveType == TYPE_DISK) {\r\npRAID_Context->VirtualDiskTgtId =\r\ncpu_to_le16(device_id + (MAX_PHYSICAL_DEVICES - 1));\r\npRAID_Context->configSeqNum = pd_sync->seq[pd_index].seqNum;\r\nio_request->DevHandle = pd_sync->seq[pd_index].devHandle;\r\npRAID_Context->regLockFlags |=\r\n(MR_RL_FLAGS_SEQ_NUM_ENABLE|MR_RL_FLAGS_GRANT_DESTINATION_CUDA);\r\n} else if (fusion->fast_path_io) {\r\npRAID_Context->VirtualDiskTgtId = cpu_to_le16(device_id);\r\npRAID_Context->configSeqNum = 0;\r\nlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\r\nio_request->DevHandle =\r\nlocal_map_ptr->raidMap.devHndlInfo[device_id].curDevHdl;\r\n} else {\r\npRAID_Context->VirtualDiskTgtId = cpu_to_le16(device_id);\r\npRAID_Context->configSeqNum = 0;\r\nio_request->DevHandle = cpu_to_le16(0xFFFF);\r\n}\r\ncmd->request_desc->SCSIIO.DevHandle = io_request->DevHandle;\r\ncmd->request_desc->SCSIIO.MSIxIndex =\r\ninstance->msix_vectors ?\r\n(raw_smp_processor_id() % instance->msix_vectors) : 0;\r\nif (!fp_possible) {\r\nio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\npRAID_Context->timeoutValue = cpu_to_le16(os_timeout_value);\r\npRAID_Context->VirtualDiskTgtId = cpu_to_le16(device_id);\r\n} else {\r\nio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\ntimeout_limit = (scmd->device->type == TYPE_DISK) ?\r\n255 : 0xFFFF;\r\npRAID_Context->timeoutValue =\r\ncpu_to_le16((os_timeout_value > timeout_limit) ?\r\ntimeout_limit : os_timeout_value);\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\npRAID_Context->Type = MPI2_TYPE_CUDA;\r\npRAID_Context->nseg = 0x1;\r\nio_request->IoFlags |=\r\ncpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);\r\n}\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_FP_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\n}\r\n}\r\nint\r\nmegasas_build_io_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nu16 sge_count;\r\nu8 cmd_type;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request = cmd->io_request;\r\nmemset(io_request->LUN, 0x0, 8);\r\nio_request->CDB.EEDP32.PrimaryReferenceTag = 0;\r\nio_request->CDB.EEDP32.PrimaryApplicationTagMask = 0;\r\nio_request->EEDPFlags = 0;\r\nio_request->Control = 0;\r\nio_request->EEDPBlockSize = 0;\r\nio_request->ChainOffset = 0;\r\nio_request->RaidContext.RAIDFlags = 0;\r\nio_request->RaidContext.Type = 0;\r\nio_request->RaidContext.nseg = 0;\r\nmemcpy(io_request->CDB.CDB32, scp->cmnd, scp->cmd_len);\r\nio_request->IoFlags = cpu_to_le16(scp->cmd_len);\r\nswitch (cmd_type = megasas_cmd_type(scp)) {\r\ncase READ_WRITE_LDIO:\r\nmegasas_build_ldio_fusion(instance, scp, cmd);\r\nbreak;\r\ncase NON_READ_WRITE_LDIO:\r\nmegasas_build_ld_nonrw_fusion(instance, scp, cmd);\r\nbreak;\r\ncase READ_WRITE_SYSPDIO:\r\ncase NON_READ_WRITE_SYSPDIO:\r\nif (instance->secure_jbod_support &&\r\n(cmd_type == NON_READ_WRITE_SYSPDIO))\r\nmegasas_build_syspd_fusion(instance, scp, cmd, 0);\r\nelse\r\nmegasas_build_syspd_fusion(instance, scp, cmd, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsge_count =\r\nmegasas_make_sgl_fusion(instance, scp,\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)\r\n&io_request->SGL, cmd);\r\nif (sge_count > instance->max_num_sge) {\r\ndev_err(&instance->pdev->dev, "Error. sge_count (0x%x) exceeds "\r\n"max (0x%x) allowed\n", sge_count,\r\ninstance->max_num_sge);\r\nreturn 1;\r\n}\r\nio_request->RaidContext.numSGE = sge_count;\r\nio_request->RaidContext.numSGEExt = (u8)(sge_count >> 8);\r\nio_request->SGLFlags = cpu_to_le16(MPI2_SGE_FLAGS_64_BIT_ADDRESSING);\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nio_request->Control |= cpu_to_le32(MPI2_SCSIIO_CONTROL_WRITE);\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nio_request->Control |= cpu_to_le32(MPI2_SCSIIO_CONTROL_READ);\r\nio_request->SGLOffset0 =\r\noffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL) / 4;\r\nio_request->SenseBufferLowAddress = cpu_to_le32(cmd->sense_phys_addr);\r\nio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\r\ncmd->scmd = scp;\r\nscp->SCp.ptr = (char *)cmd;\r\nreturn 0;\r\n}\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *\r\nmegasas_get_request_descriptor(struct megasas_instance *instance, u16 index)\r\n{\r\nu8 *p;\r\nstruct fusion_context *fusion;\r\nif (index >= instance->max_fw_cmds) {\r\ndev_err(&instance->pdev->dev, "Invalid SMID (0x%x)request for "\r\n"descriptor for scsi%d\n", index,\r\ninstance->host->host_no);\r\nreturn NULL;\r\n}\r\nfusion = instance->ctrl_context;\r\np = fusion->req_frames_desc\r\n+sizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) *index;\r\nreturn (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)p;\r\n}\r\nstatic u32\r\nmegasas_build_and_issue_cmd_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_cmd_fusion *cmd;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu32 index;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nif ((megasas_cmd_type(scmd) == READ_WRITE_LDIO) &&\r\ninstance->ldio_threshold &&\r\n(atomic_inc_return(&instance->ldio_outstanding) >\r\ninstance->ldio_threshold)) {\r\natomic_dec(&instance->ldio_outstanding);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmd = megasas_get_cmd_fusion(instance, scmd->request->tag);\r\nindex = cmd->index;\r\nreq_desc = megasas_get_request_descriptor(instance, index-1);\r\nif (!req_desc)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nreq_desc->Words = 0;\r\ncmd->request_desc = req_desc;\r\nif (megasas_build_io_fusion(instance, scmd, cmd)) {\r\nmegasas_return_cmd_fusion(instance, cmd);\r\ndev_err(&instance->pdev->dev, "Error building command\n");\r\ncmd->request_desc = NULL;\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nreq_desc = cmd->request_desc;\r\nreq_desc->SCSIIO.SMID = cpu_to_le16(index);\r\nif (cmd->io_request->ChainOffset != 0 &&\r\ncmd->io_request->ChainOffset != 0xF)\r\ndev_err(&instance->pdev->dev, "The chain offset value is not "\r\n"correct : %x\n", cmd->io_request->ChainOffset);\r\natomic_inc(&instance->fw_outstanding);\r\nmegasas_fire_cmd_fusion(instance, req_desc);\r\nreturn 0;\r\n}\r\nint\r\ncomplete_cmd_fusion(struct megasas_instance *instance, u32 MSIxIndex)\r\n{\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *desc;\r\nstruct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *reply_desc;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *scsi_io_req;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd *cmd_mfi;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nu16 smid, num_completed;\r\nu8 reply_descript_type;\r\nu32 status, extStatus, device_id;\r\nunion desc_value d_val;\r\nstruct LD_LOAD_BALANCE_INFO *lbinfo;\r\nint threshold_reply_count = 0;\r\nstruct scsi_cmnd *scmd_local = NULL;\r\nstruct MR_TASK_MANAGE_REQUEST *mr_tm_req;\r\nstruct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_tm_req;\r\nfusion = instance->ctrl_context;\r\nif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn IRQ_HANDLED;\r\ndesc = fusion->reply_frames_desc[MSIxIndex] +\r\nfusion->last_reply_idx[MSIxIndex];\r\nreply_desc = (struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\r\nd_val.word = desc->Words;\r\nreply_descript_type = reply_desc->ReplyFlags &\r\nMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\nif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\r\nreturn IRQ_NONE;\r\nnum_completed = 0;\r\nwhile (d_val.u.low != cpu_to_le32(UINT_MAX) &&\r\nd_val.u.high != cpu_to_le32(UINT_MAX)) {\r\nsmid = le16_to_cpu(reply_desc->SMID);\r\ncmd_fusion = fusion->cmd_list[smid - 1];\r\nscsi_io_req =\r\n(struct MPI2_RAID_SCSI_IO_REQUEST *)\r\ncmd_fusion->io_request;\r\nif (cmd_fusion->scmd)\r\ncmd_fusion->scmd->SCp.ptr = NULL;\r\nscmd_local = cmd_fusion->scmd;\r\nstatus = scsi_io_req->RaidContext.status;\r\nextStatus = scsi_io_req->RaidContext.exStatus;\r\nswitch (scsi_io_req->Function) {\r\ncase MPI2_FUNCTION_SCSI_TASK_MGMT:\r\nmr_tm_req = (struct MR_TASK_MANAGE_REQUEST *)\r\ncmd_fusion->io_request;\r\nmpi_tm_req = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *)\r\n&mr_tm_req->TmRequest;\r\ndev_dbg(&instance->pdev->dev, "TM completion:"\r\n"type: 0x%x TaskMID: 0x%x\n",\r\nmpi_tm_req->TaskType, mpi_tm_req->TaskMID);\r\ncomplete(&cmd_fusion->done);\r\nbreak;\r\ncase MPI2_FUNCTION_SCSI_IO_REQUEST:\r\ndevice_id = MEGASAS_DEV_INDEX(scmd_local);\r\nlbinfo = &fusion->load_balance_info[device_id];\r\nif (cmd_fusion->scmd->SCp.Status &\r\nMEGASAS_LOAD_BALANCE_FLAG) {\r\natomic_dec(&lbinfo->scsi_pending_cmds[cmd_fusion->pd_r1_lb]);\r\ncmd_fusion->scmd->SCp.Status &=\r\n~MEGASAS_LOAD_BALANCE_FLAG;\r\n}\r\nif (reply_descript_type ==\r\nMPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS) {\r\nif (megasas_dbg_lvl == 5)\r\ndev_err(&instance->pdev->dev, "\nFAST Path "\r\n"IO Success\n");\r\n}\r\ncase MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST:\r\nmap_cmd_status(cmd_fusion, status, extStatus);\r\nscsi_io_req->RaidContext.status = 0;\r\nscsi_io_req->RaidContext.exStatus = 0;\r\nif (megasas_cmd_type(scmd_local) == READ_WRITE_LDIO)\r\natomic_dec(&instance->ldio_outstanding);\r\nmegasas_return_cmd_fusion(instance, cmd_fusion);\r\nscsi_dma_unmap(scmd_local);\r\nscmd_local->scsi_done(scmd_local);\r\natomic_dec(&instance->fw_outstanding);\r\nbreak;\r\ncase MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST:\r\ncmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\r\nif (cmd_mfi->flags & DRV_DCMD_POLLED_MODE) {\r\ncmd_mfi->flags &= ~DRV_DCMD_POLLED_MODE;\r\nmegasas_return_cmd(instance, cmd_mfi);\r\n} else\r\nmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\r\nbreak;\r\n}\r\nfusion->last_reply_idx[MSIxIndex]++;\r\nif (fusion->last_reply_idx[MSIxIndex] >=\r\nfusion->reply_q_depth)\r\nfusion->last_reply_idx[MSIxIndex] = 0;\r\ndesc->Words = cpu_to_le64(ULLONG_MAX);\r\nnum_completed++;\r\nthreshold_reply_count++;\r\nif (!fusion->last_reply_idx[MSIxIndex])\r\ndesc = fusion->reply_frames_desc[MSIxIndex];\r\nelse\r\ndesc++;\r\nreply_desc =\r\n(struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\r\nd_val.word = desc->Words;\r\nreply_descript_type = reply_desc->ReplyFlags &\r\nMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\nif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\r\nbreak;\r\nif (threshold_reply_count >= THRESHOLD_REPLY_COUNT) {\r\nif (fusion->adapter_type == INVADER_SERIES)\r\nwritel(((MSIxIndex & 0x7) << 24) |\r\nfusion->last_reply_idx[MSIxIndex],\r\ninstance->reply_post_host_index_addr[MSIxIndex/8]);\r\nelse\r\nwritel((MSIxIndex << 24) |\r\nfusion->last_reply_idx[MSIxIndex],\r\ninstance->reply_post_host_index_addr[0]);\r\nthreshold_reply_count = 0;\r\n}\r\n}\r\nif (!num_completed)\r\nreturn IRQ_NONE;\r\nwmb();\r\nif (fusion->adapter_type == INVADER_SERIES)\r\nwritel(((MSIxIndex & 0x7) << 24) |\r\nfusion->last_reply_idx[MSIxIndex],\r\ninstance->reply_post_host_index_addr[MSIxIndex/8]);\r\nelse\r\nwritel((MSIxIndex << 24) |\r\nfusion->last_reply_idx[MSIxIndex],\r\ninstance->reply_post_host_index_addr[0]);\r\nmegasas_check_and_restore_queue_depth(instance);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid\r\nmegasas_complete_cmd_dpc_fusion(unsigned long instance_addr)\r\n{\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *)instance_addr;\r\nunsigned long flags;\r\nu32 count, MSIxIndex;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nfor (MSIxIndex = 0 ; MSIxIndex < count; MSIxIndex++)\r\ncomplete_cmd_fusion(instance, MSIxIndex);\r\n}\r\nirqreturn_t megasas_isr_fusion(int irq, void *devp)\r\n{\r\nstruct megasas_irq_context *irq_context = devp;\r\nstruct megasas_instance *instance = irq_context->instance;\r\nu32 mfiStatus, fw_state, dma_state;\r\nif (instance->mask_interrupts)\r\nreturn IRQ_NONE;\r\nif (!instance->msix_vectors) {\r\nmfiStatus = instance->instancet->clear_intr(instance->reg_set);\r\nif (!mfiStatus)\r\nreturn IRQ_NONE;\r\n}\r\nif (test_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags)) {\r\ninstance->instancet->clear_intr(instance->reg_set);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!complete_cmd_fusion(instance, irq_context->MSIxIndex)) {\r\ninstance->instancet->clear_intr(instance->reg_set);\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\ndma_state = instance->instancet->read_fw_status_reg\r\n(instance->reg_set) & MFI_STATE_DMADONE;\r\nif (instance->crash_dump_drv_support &&\r\ninstance->crash_dump_app_support) {\r\nif ((fw_state == MFI_STATE_FAULT) && dma_state)\r\nschedule_work(&instance->crash_init);\r\nelse if (fw_state == MFI_STATE_FAULT)\r\nschedule_work(&instance->work_init);\r\n} else if (fw_state == MFI_STATE_FAULT) {\r\ndev_warn(&instance->pdev->dev, "Iop2SysDoorbellInt"\r\n"for scsi%d\n", instance->host->host_no);\r\nschedule_work(&instance->work_init);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nu8\r\nbuild_mpt_mfi_pass_thru(struct megasas_instance *instance,\r\nstruct megasas_cmd *mfi_cmd)\r\n{\r\nstruct MPI25_IEEE_SGE_CHAIN64 *mpi25_ieee_chain;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_req;\r\nstruct megasas_cmd_fusion *cmd;\r\nstruct fusion_context *fusion;\r\nstruct megasas_header *frame_hdr = &mfi_cmd->frame->hdr;\r\nfusion = instance->ctrl_context;\r\ncmd = megasas_get_cmd_fusion(instance,\r\ninstance->max_scsi_cmds + mfi_cmd->index);\r\nmfi_cmd->context.smid = cmd->index;\r\nif (frame_hdr->flags & cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE))\r\nmfi_cmd->flags |= DRV_DCMD_POLLED_MODE;\r\nio_req = cmd->io_request;\r\nif (fusion->adapter_type == INVADER_SERIES) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL;\r\nsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\r\nsgl_ptr_end->Flags = 0;\r\n}\r\nmpi25_ieee_chain =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL.IeeeChain;\r\nio_req->Function = MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST;\r\nio_req->SGLOffset0 = offsetof(struct MPI2_RAID_SCSI_IO_REQUEST,\r\nSGL) / 4;\r\nio_req->ChainOffset = fusion->chain_offset_mfi_pthru;\r\nmpi25_ieee_chain->Address = cpu_to_le64(mfi_cmd->frame_phys_addr);\r\nmpi25_ieee_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR;\r\nmpi25_ieee_chain->Length = cpu_to_le32(instance->max_chain_frame_sz);\r\nreturn 0;\r\n}\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *\r\nbuild_mpt_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu16 index;\r\nif (build_mpt_mfi_pass_thru(instance, cmd)) {\r\ndev_err(&instance->pdev->dev, "Couldn't build MFI pass thru cmd\n");\r\nreturn NULL;\r\n}\r\nindex = cmd->context.smid;\r\nreq_desc = megasas_get_request_descriptor(instance, index - 1);\r\nif (!req_desc)\r\nreturn NULL;\r\nreq_desc->Words = 0;\r\nreq_desc->SCSIIO.RequestFlags = (MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nreq_desc->SCSIIO.SMID = cpu_to_le16(index);\r\nreturn req_desc;\r\n}\r\nint\r\nmegasas_issue_dcmd_fusion(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nreq_desc = build_mpt_cmd(instance, cmd);\r\nif (!req_desc) {\r\ndev_info(&instance->pdev->dev, "Failed from %s %d\n",\r\n__func__, __LINE__);\r\nreturn DCMD_NOT_FIRED;\r\n}\r\nmegasas_fire_cmd_fusion(instance, req_desc);\r\nreturn DCMD_SUCCESS;\r\n}\r\nvoid\r\nmegasas_release_fusion(struct megasas_instance *instance)\r\n{\r\nmegasas_free_cmds(instance);\r\nmegasas_free_cmds_fusion(instance);\r\niounmap(instance->reg_set);\r\npci_release_selected_regions(instance->pdev, 1<<instance->bar);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic void\r\nmegasas_alloc_host_crash_buffer(struct megasas_instance *instance)\r\n{\r\nunsigned int i;\r\ninstance->crash_buf_pages = get_order(CRASH_DMA_BUF_SIZE);\r\nfor (i = 0; i < MAX_CRASH_DUMP_SIZE; i++) {\r\ninstance->crash_buf[i] = (void *)__get_free_pages(GFP_KERNEL,\r\ninstance->crash_buf_pages);\r\nif (!instance->crash_buf[i]) {\r\ndev_info(&instance->pdev->dev, "Firmware crash dump "\r\n"memory allocation failed at index %d\n", i);\r\nbreak;\r\n}\r\nmemset(instance->crash_buf[i], 0,\r\n((1 << PAGE_SHIFT) << instance->crash_buf_pages));\r\n}\r\ninstance->drv_buf_alloc = i;\r\n}\r\nvoid\r\nmegasas_free_host_crash_buffer(struct megasas_instance *instance)\r\n{\r\nunsigned int i\r\n;\r\nfor (i = 0; i < instance->drv_buf_alloc; i++) {\r\nif (instance->crash_buf[i])\r\nfree_pages((ulong)instance->crash_buf[i],\r\ninstance->crash_buf_pages);\r\n}\r\ninstance->drv_buf_index = 0;\r\ninstance->drv_buf_alloc = 0;\r\ninstance->fw_crash_state = UNAVAILABLE;\r\ninstance->fw_crash_buffer_size = 0;\r\n}\r\nstatic int\r\nmegasas_adp_reset_fusion(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nu32 host_diag, abs_state, retry;\r\nwritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_1ST_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_2ND_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_3RD_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_4TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_5TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_6TH_KEY_VALUE, &instance->reg_set->fusion_seq_offset);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nretry = 0;\r\nwhile (!(host_diag & HOST_DIAG_WRITE_ENABLE)) {\r\nmsleep(100);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nif (retry++ == 100) {\r\ndev_warn(&instance->pdev->dev,\r\n"Host diag unlock failed from %s %d\n",\r\n__func__, __LINE__);\r\nbreak;\r\n}\r\n}\r\nif (!(host_diag & HOST_DIAG_WRITE_ENABLE))\r\nreturn -1;\r\nwritel(host_diag | HOST_DIAG_RESET_ADAPTER,\r\n&instance->reg_set->fusion_host_diag);\r\nmsleep(3000);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nretry = 0;\r\nwhile (host_diag & HOST_DIAG_RESET_ADAPTER) {\r\nmsleep(100);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nif (retry++ == 1000) {\r\ndev_warn(&instance->pdev->dev,\r\n"Diag reset adapter never cleared %s %d\n",\r\n__func__, __LINE__);\r\nbreak;\r\n}\r\n}\r\nif (host_diag & HOST_DIAG_RESET_ADAPTER)\r\nreturn -1;\r\nabs_state = instance->instancet->read_fw_status_reg(instance->reg_set)\r\n& MFI_STATE_MASK;\r\nretry = 0;\r\nwhile ((abs_state <= MFI_STATE_FW_INIT) && (retry++ < 1000)) {\r\nmsleep(100);\r\nabs_state = instance->instancet->\r\nread_fw_status_reg(instance->reg_set) & MFI_STATE_MASK;\r\n}\r\nif (abs_state <= MFI_STATE_FW_INIT) {\r\ndev_warn(&instance->pdev->dev,\r\n"fw state < MFI_STATE_FW_INIT, state = 0x%x %s %d\n",\r\nabs_state, __func__, __LINE__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_fusion(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nreturn 0;\r\n}\r\nint megasas_wait_for_outstanding_fusion(struct megasas_instance *instance,\r\nint reason, int *convert)\r\n{\r\nint i, outstanding, retval = 0, hb_seconds_missed = 0;\r\nu32 fw_state;\r\nfor (i = 0; i < resetwaittime; i++) {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state == MFI_STATE_FAULT) {\r\ndev_warn(&instance->pdev->dev, "Found FW in FAULT state,"\r\n" will reset adapter scsi%d.\n",\r\ninstance->host->host_no);\r\nmegasas_complete_cmd_dpc_fusion((unsigned long)instance);\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (reason == MFI_IO_TIMEOUT_OCR) {\r\ndev_info(&instance->pdev->dev,\r\n"MFI IO is timed out, initiating OCR\n");\r\nmegasas_complete_cmd_dpc_fusion((unsigned long)instance);\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (instance->requestorId && !reason) {\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (instance->requestorId && reason) {\r\nif (instance->hb_host_mem->HB.fwCounter !=\r\ninstance->hb_host_mem->HB.driverCounter) {\r\ninstance->hb_host_mem->HB.driverCounter =\r\ninstance->hb_host_mem->HB.fwCounter;\r\nhb_seconds_missed = 0;\r\n} else {\r\nhb_seconds_missed++;\r\nif (hb_seconds_missed ==\r\n(MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {\r\ndev_warn(&instance->pdev->dev, "SR-IOV:"\r\n" Heartbeat never completed "\r\n" while polling during I/O "\r\n" timeout handling for "\r\n"scsi%d.\n",\r\ninstance->host->host_no);\r\n*convert = 1;\r\nretval = 1;\r\ngoto out;\r\n}\r\n}\r\n}\r\noutstanding = atomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\ngoto out;\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\ndev_notice(&instance->pdev->dev, "[%2d]waiting for %d "\r\n"commands to complete for scsi%d\n", i,\r\noutstanding, instance->host->host_no);\r\nmegasas_complete_cmd_dpc_fusion(\r\n(unsigned long)instance);\r\n}\r\nmsleep(1000);\r\n}\r\nif (atomic_read(&instance->fw_outstanding)) {\r\ndev_err(&instance->pdev->dev, "pending commands remain after waiting, "\r\n"will reset adapter scsi%d.\n",\r\ninstance->host->host_no);\r\nretval = 1;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nvoid megasas_reset_reply_desc(struct megasas_instance *instance)\r\n{\r\nint i, j, count;\r\nstruct fusion_context *fusion;\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\r\nfusion = instance->ctrl_context;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfor (i = 0 ; i < count ; i++) {\r\nfusion->last_reply_idx[i] = 0;\r\nreply_desc = fusion->reply_frames_desc[i];\r\nfor (j = 0 ; j < fusion->reply_q_depth; j++, reply_desc++)\r\nreply_desc->Words = cpu_to_le64(ULLONG_MAX);\r\n}\r\n}\r\nvoid megasas_refire_mgmt_cmd(struct megasas_instance *instance)\r\n{\r\nint j;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd *cmd_mfi;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu16 smid;\r\nbool refire_cmd = 0;\r\nfusion = instance->ctrl_context;\r\nfor (j = instance->max_scsi_cmds ; j < instance->max_fw_cmds; j++) {\r\ncmd_fusion = fusion->cmd_list[j];\r\ncmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\r\nsmid = le16_to_cpu(cmd_mfi->context.smid);\r\nif (!smid)\r\ncontinue;\r\nreq_desc = megasas_get_request_descriptor\r\n(instance, smid - 1);\r\nrefire_cmd = req_desc && ((cmd_mfi->frame->dcmd.opcode !=\r\ncpu_to_le32(MR_DCMD_LD_MAP_GET_INFO)) &&\r\n(cmd_mfi->frame->dcmd.opcode !=\r\ncpu_to_le32(MR_DCMD_SYSTEM_PD_MAP_GET_INFO)))\r\n&& !(cmd_mfi->flags & DRV_DCMD_SKIP_REFIRE);\r\nif (refire_cmd)\r\nmegasas_fire_cmd_fusion(instance, req_desc);\r\nelse\r\nmegasas_return_cmd(instance, cmd_mfi);\r\n}\r\n}\r\nstatic int megasas_track_scsiio(struct megasas_instance *instance,\r\nint id, int channel)\r\n{\r\nint i, found = 0;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nfor (i = 0 ; i < instance->max_scsi_cmds; i++) {\r\ncmd_fusion = fusion->cmd_list[i];\r\nif (cmd_fusion->scmd &&\r\n(cmd_fusion->scmd->device->id == id &&\r\ncmd_fusion->scmd->device->channel == channel)) {\r\ndev_info(&instance->pdev->dev,\r\n"SCSI commands pending to target"\r\n"channel %d id %d \tSMID: 0x%x\n",\r\nchannel, id, cmd_fusion->index);\r\nscsi_print_command(cmd_fusion->scmd);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nreturn found ? FAILED : SUCCESS;\r\n}\r\nstatic void\r\nmegasas_tm_response_code(struct megasas_instance *instance,\r\nstruct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply)\r\n{\r\nchar *desc;\r\nswitch (mpi_reply->ResponseCode) {\r\ncase MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:\r\ndesc = "task management request completed";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:\r\ndesc = "invalid frame";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\r\ndesc = "task management request not supported";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_FAILED:\r\ndesc = "task management request failed";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:\r\ndesc = "task management request succeeded";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:\r\ndesc = "invalid lun";\r\nbreak;\r\ncase 0xA:\r\ndesc = "overlapped tag attempted";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\r\ndesc = "task queued, however not sent to target";\r\nbreak;\r\ndefault:\r\ndesc = "unknown";\r\nbreak;\r\n}\r\ndev_dbg(&instance->pdev->dev, "response_code(%01x): %s\n",\r\nmpi_reply->ResponseCode, desc);\r\ndev_dbg(&instance->pdev->dev,\r\n"TerminationCount/DevHandle/Function/TaskType/IOCStat/IOCLoginfo"\r\n" 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n",\r\nmpi_reply->TerminationCount, mpi_reply->DevHandle,\r\nmpi_reply->Function, mpi_reply->TaskType,\r\nmpi_reply->IOCStatus, mpi_reply->IOCLogInfo);\r\n}\r\nstatic int\r\nmegasas_issue_tm(struct megasas_instance *instance, u16 device_handle,\r\nuint channel, uint id, u16 smid_task, u8 type)\r\n{\r\nstruct MR_TASK_MANAGE_REQUEST *mr_request;\r\nstruct MPI2_SCSI_TASK_MANAGE_REQUEST *mpi_request;\r\nunsigned long timeleft;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct megasas_cmd *cmd_mfi;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd_fusion *scsi_lookup;\r\nint rc;\r\nstruct MPI2_SCSI_TASK_MANAGE_REPLY *mpi_reply;\r\nfusion = instance->ctrl_context;\r\ncmd_mfi = megasas_get_cmd(instance);\r\nif (!cmd_mfi) {\r\ndev_err(&instance->pdev->dev, "Failed from %s %d\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\ncmd_fusion = megasas_get_cmd_fusion(instance,\r\ninstance->max_scsi_cmds + cmd_mfi->index);\r\ncmd_mfi->context.smid = cmd_fusion->index;\r\nreq_desc = megasas_get_request_descriptor(instance,\r\n(cmd_fusion->index - 1));\r\nif (!req_desc) {\r\ndev_err(&instance->pdev->dev, "Failed from %s %d\n",\r\n__func__, __LINE__);\r\nmegasas_return_cmd(instance, cmd_mfi);\r\nreturn -ENOMEM;\r\n}\r\ncmd_fusion->request_desc = req_desc;\r\nreq_desc->Words = 0;\r\nscsi_lookup = fusion->cmd_list[smid_task - 1];\r\nmr_request = (struct MR_TASK_MANAGE_REQUEST *) cmd_fusion->io_request;\r\nmemset(mr_request, 0, sizeof(struct MR_TASK_MANAGE_REQUEST));\r\nmpi_request = (struct MPI2_SCSI_TASK_MANAGE_REQUEST *) &mr_request->TmRequest;\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\r\nmpi_request->DevHandle = cpu_to_le16(device_handle);\r\nmpi_request->TaskType = type;\r\nmpi_request->TaskMID = cpu_to_le16(smid_task);\r\nmpi_request->LUN[1] = 0;\r\nreq_desc = cmd_fusion->request_desc;\r\nreq_desc->HighPriority.SMID = cpu_to_le16(cmd_fusion->index);\r\nreq_desc->HighPriority.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nreq_desc->HighPriority.MSIxIndex = 0;\r\nreq_desc->HighPriority.LMID = 0;\r\nreq_desc->HighPriority.Reserved1 = 0;\r\nif (channel < MEGASAS_MAX_PD_CHANNELS)\r\nmr_request->tmReqFlags.isTMForPD = 1;\r\nelse\r\nmr_request->tmReqFlags.isTMForLD = 1;\r\ninit_completion(&cmd_fusion->done);\r\nmegasas_fire_cmd_fusion(instance, req_desc);\r\ntimeleft = wait_for_completion_timeout(&cmd_fusion->done, 50 * HZ);\r\nif (!timeleft) {\r\ndev_err(&instance->pdev->dev,\r\n"task mgmt type 0x%x timed out\n", type);\r\ncmd_mfi->flags |= DRV_DCMD_SKIP_REFIRE;\r\nmutex_unlock(&instance->reset_mutex);\r\nrc = megasas_reset_fusion(instance->host, MFI_IO_TIMEOUT_OCR);\r\nmutex_lock(&instance->reset_mutex);\r\nreturn rc;\r\n}\r\nmpi_reply = (struct MPI2_SCSI_TASK_MANAGE_REPLY *) &mr_request->TMReply;\r\nmegasas_tm_response_code(instance, mpi_reply);\r\nmegasas_return_cmd(instance, cmd_mfi);\r\nrc = SUCCESS;\r\nswitch (type) {\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\r\nif (scsi_lookup->scmd == NULL)\r\nbreak;\r\nelse {\r\ninstance->instancet->disable_intr(instance);\r\nmsleep(1000);\r\nmegasas_complete_cmd_dpc_fusion\r\n((unsigned long)instance);\r\ninstance->instancet->enable_intr(instance);\r\nif (scsi_lookup->scmd == NULL)\r\nbreak;\r\n}\r\nrc = FAILED;\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\r\nif ((channel == 0xFFFFFFFF) && (id == 0xFFFFFFFF))\r\nbreak;\r\ninstance->instancet->disable_intr(instance);\r\nmsleep(1000);\r\nmegasas_complete_cmd_dpc_fusion\r\n((unsigned long)instance);\r\nrc = megasas_track_scsiio(instance, id, channel);\r\ninstance->instancet->enable_intr(instance);\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\r\nbreak;\r\ndefault:\r\nrc = FAILED;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic u16 megasas_fusion_smid_lookup(struct scsi_cmnd *scmd)\r\n{\r\nint i, ret = 0;\r\nstruct megasas_instance *instance;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nfusion = instance->ctrl_context;\r\nfor (i = 0; i < instance->max_scsi_cmds; i++) {\r\ncmd_fusion = fusion->cmd_list[i];\r\nif (cmd_fusion->scmd && (cmd_fusion->scmd == scmd)) {\r\nscmd_printk(KERN_NOTICE, scmd, "Abort request is for"\r\n" SMID: %d\n", cmd_fusion->index);\r\nret = cmd_fusion->index;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 megasas_get_tm_devhandle(struct scsi_device *sdev)\r\n{\r\nu16 pd_index = 0;\r\nu32 device_id;\r\nstruct megasas_instance *instance;\r\nstruct fusion_context *fusion;\r\nstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\r\nu16 devhandle = (u16)ULONG_MAX;\r\ninstance = (struct megasas_instance *)sdev->host->hostdata;\r\nfusion = instance->ctrl_context;\r\nif (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {\r\nif (instance->use_seqnum_jbod_fp) {\r\npd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\r\nsdev->id;\r\npd_sync = (void *)fusion->pd_seq_sync\r\n[(instance->pd_seq_map_id - 1) & 1];\r\ndevhandle = pd_sync->seq[pd_index].devHandle;\r\n} else\r\nsdev_printk(KERN_ERR, sdev, "Firmware expose tmCapable"\r\n" without JBOD MAP support from %s %d\n", __func__, __LINE__);\r\n} else {\r\ndevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\r\n+ sdev->id;\r\ndevhandle = device_id;\r\n}\r\nreturn devhandle;\r\n}\r\nint megasas_task_abort_fusion(struct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *instance;\r\nu16 smid, devhandle;\r\nstruct fusion_context *fusion;\r\nint ret;\r\nstruct MR_PRIV_DEVICE *mr_device_priv_data;\r\nmr_device_priv_data = scmd->device->hostdata;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nfusion = instance->ctrl_context;\r\nif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\r\ndev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"\r\n"SCSI host:%d\n", instance->host->host_no);\r\nret = FAILED;\r\nreturn ret;\r\n}\r\nif (!mr_device_priv_data) {\r\nsdev_printk(KERN_INFO, scmd->device, "device been deleted! "\r\n"scmd(%p)\n", scmd);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nret = SUCCESS;\r\ngoto out;\r\n}\r\nif (!mr_device_priv_data->is_tm_capable) {\r\nret = FAILED;\r\ngoto out;\r\n}\r\nmutex_lock(&instance->reset_mutex);\r\nsmid = megasas_fusion_smid_lookup(scmd);\r\nif (!smid) {\r\nret = SUCCESS;\r\nscmd_printk(KERN_NOTICE, scmd, "Command for which abort is"\r\n" issued is not found in oustanding commands\n");\r\nmutex_unlock(&instance->reset_mutex);\r\ngoto out;\r\n}\r\ndevhandle = megasas_get_tm_devhandle(scmd->device);\r\nif (devhandle == (u16)ULONG_MAX) {\r\nret = SUCCESS;\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"task abort issued for invalid devhandle\n");\r\nmutex_unlock(&instance->reset_mutex);\r\ngoto out;\r\n}\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"attempting task abort! scmd(%p) tm_dev_handle 0x%x\n",\r\nscmd, devhandle);\r\nmr_device_priv_data->tm_busy = 1;\r\nret = megasas_issue_tm(instance, devhandle,\r\nscmd->device->channel, scmd->device->id, smid,\r\nMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK);\r\nmr_device_priv_data->tm_busy = 0;\r\nmutex_unlock(&instance->reset_mutex);\r\nout:\r\nsdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",\r\n((ret == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);\r\nreturn ret;\r\n}\r\nint megasas_reset_target_fusion(struct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *instance;\r\nint ret = FAILED;\r\nu16 devhandle;\r\nstruct fusion_context *fusion;\r\nstruct MR_PRIV_DEVICE *mr_device_priv_data;\r\nmr_device_priv_data = scmd->device->hostdata;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nfusion = instance->ctrl_context;\r\nif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\r\ndev_err(&instance->pdev->dev, "Controller is not OPERATIONAL,"\r\n"SCSI host:%d\n", instance->host->host_no);\r\nret = FAILED;\r\nreturn ret;\r\n}\r\nif (!mr_device_priv_data) {\r\nsdev_printk(KERN_INFO, scmd->device, "device been deleted! "\r\n"scmd(%p)\n", scmd);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nret = SUCCESS;\r\ngoto out;\r\n}\r\nif (!mr_device_priv_data->is_tm_capable) {\r\nret = FAILED;\r\ngoto out;\r\n}\r\nmutex_lock(&instance->reset_mutex);\r\ndevhandle = megasas_get_tm_devhandle(scmd->device);\r\nif (devhandle == (u16)ULONG_MAX) {\r\nret = SUCCESS;\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"target reset issued for invalid devhandle\n");\r\nmutex_unlock(&instance->reset_mutex);\r\ngoto out;\r\n}\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"attempting target reset! scmd(%p) tm_dev_handle 0x%x\n",\r\nscmd, devhandle);\r\nmr_device_priv_data->tm_busy = 1;\r\nret = megasas_issue_tm(instance, devhandle,\r\nscmd->device->channel, scmd->device->id, 0,\r\nMPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET);\r\nmr_device_priv_data->tm_busy = 0;\r\nmutex_unlock(&instance->reset_mutex);\r\nout:\r\nscmd_printk(KERN_NOTICE, scmd, "megasas: target reset %s!!\n",\r\n(ret == SUCCESS) ? "SUCCESS" : "FAILED");\r\nreturn ret;\r\n}\r\nstruct megasas_instance *megasas_get_peer_instance(struct megasas_instance *instance)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_MGMT_ADAPTERS; i++) {\r\nif (megasas_mgmt_info.instance[i] &&\r\n(megasas_mgmt_info.instance[i] != instance) &&\r\nmegasas_mgmt_info.instance[i]->requestorId &&\r\nmegasas_mgmt_info.instance[i]->peerIsPresent &&\r\n(memcmp((megasas_mgmt_info.instance[i]->clusterId),\r\ninstance->clusterId, MEGASAS_CLUSTER_ID_SIZE) == 0))\r\nreturn megasas_mgmt_info.instance[i];\r\n}\r\nreturn NULL;\r\n}\r\nint megasas_check_mpio_paths(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *peer_instance = NULL;\r\nint retval = (DID_RESET << 16);\r\nif (instance->peerIsPresent) {\r\npeer_instance = megasas_get_peer_instance(instance);\r\nif ((peer_instance) &&\r\n(atomic_read(&peer_instance->adprecovery) ==\r\nMEGASAS_HBA_OPERATIONAL))\r\nretval = (DID_NO_CONNECT << 16);\r\n}\r\nreturn retval;\r\n}\r\nint megasas_reset_fusion(struct Scsi_Host *shost, int reason)\r\n{\r\nint retval = SUCCESS, i, convert = 0;\r\nstruct megasas_instance *instance;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion;\r\nu32 abs_state, status_reg, reset_adapter;\r\nu32 io_timeout_in_crash_mode = 0;\r\nstruct scsi_cmnd *scmd_local = NULL;\r\nstruct scsi_device *sdev;\r\ninstance = (struct megasas_instance *)shost->hostdata;\r\nfusion = instance->ctrl_context;\r\nmutex_lock(&instance->reset_mutex);\r\nif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\r\ndev_warn(&instance->pdev->dev, "Hardware critical error, "\r\n"returning FAILED for scsi%d.\n",\r\ninstance->host->host_no);\r\nmutex_unlock(&instance->reset_mutex);\r\nreturn FAILED;\r\n}\r\nstatus_reg = instance->instancet->read_fw_status_reg(instance->reg_set);\r\nabs_state = status_reg & MFI_STATE_MASK;\r\nif (abs_state != MFI_STATE_FAULT && instance->crash_dump_buf &&\r\ninstance->crash_dump_app_support && reason) {\r\ndev_info(&instance->pdev->dev, "IO/DCMD timeout is detected, "\r\n"forcibly FAULT Firmware\n");\r\natomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\r\nstatus_reg = readl(&instance->reg_set->doorbell);\r\nwritel(status_reg | MFI_STATE_FORCE_OCR,\r\n&instance->reg_set->doorbell);\r\nreadl(&instance->reg_set->doorbell);\r\nmutex_unlock(&instance->reset_mutex);\r\ndo {\r\nssleep(3);\r\nio_timeout_in_crash_mode++;\r\ndev_dbg(&instance->pdev->dev, "waiting for [%d] "\r\n"seconds for crash dump collection and OCR "\r\n"to be done\n", (io_timeout_in_crash_mode * 3));\r\n} while ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\r\n(io_timeout_in_crash_mode < 80));\r\nif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL) {\r\ndev_info(&instance->pdev->dev, "OCR done for IO "\r\n"timeout case\n");\r\nretval = SUCCESS;\r\n} else {\r\ndev_info(&instance->pdev->dev, "Controller is not "\r\n"operational after 240 seconds wait for IO "\r\n"timeout case in FW crash dump mode\n do "\r\n"OCR/kill adapter\n");\r\nretval = megasas_reset_fusion(shost, 0);\r\n}\r\nreturn retval;\r\n}\r\nif (instance->requestorId && !instance->skip_heartbeat_timer_del)\r\ndel_timer_sync(&instance->sriov_heartbeat_timer);\r\nset_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\natomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_POLLING);\r\ninstance->instancet->disable_intr(instance);\r\nmsleep(1000);\r\nif (megasas_wait_for_outstanding_fusion(instance, reason,\r\n&convert)) {\r\natomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\r\ndev_warn(&instance->pdev->dev, "resetting fusion "\r\n"adapter scsi%d.\n", instance->host->host_no);\r\nif (convert)\r\nreason = 0;\r\nfor (i = 0 ; i < instance->max_scsi_cmds; i++) {\r\ncmd_fusion = fusion->cmd_list[i];\r\nscmd_local = cmd_fusion->scmd;\r\nif (cmd_fusion->scmd) {\r\nscmd_local->result =\r\nmegasas_check_mpio_paths(instance,\r\nscmd_local);\r\nif (megasas_cmd_type(scmd_local) == READ_WRITE_LDIO)\r\natomic_dec(&instance->ldio_outstanding);\r\nmegasas_return_cmd_fusion(instance, cmd_fusion);\r\nscsi_dma_unmap(scmd_local);\r\nscmd_local->scsi_done(scmd_local);\r\natomic_dec(&instance->fw_outstanding);\r\n}\r\n}\r\nstatus_reg = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set);\r\nabs_state = status_reg & MFI_STATE_MASK;\r\nreset_adapter = status_reg & MFI_RESET_ADAPTER;\r\nif (instance->disableOnlineCtrlReset ||\r\n(abs_state == MFI_STATE_FAULT && !reset_adapter)) {\r\ndev_warn(&instance->pdev->dev, "Reset not supported"\r\n", killing adapter scsi%d.\n",\r\ninstance->host->host_no);\r\nmegaraid_sas_kill_hba(instance);\r\ninstance->skip_heartbeat_timer_del = 1;\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nif (instance->requestorId && !reason) {\r\nmsleep(MEGASAS_OCR_SETTLE_TIME_VF);\r\ngoto transition_to_ready;\r\n}\r\nfor (i = 0; i < MEGASAS_FUSION_MAX_RESET_TRIES; i++) {\r\nif (instance->instancet->adp_reset\r\n(instance, instance->reg_set))\r\ncontinue;\r\ntransition_to_ready:\r\nif (megasas_transition_to_ready(instance, 1)) {\r\ndev_warn(&instance->pdev->dev,\r\n"Failed to transition controller to ready for "\r\n"scsi%d.\n", instance->host->host_no);\r\nif (instance->requestorId && !reason)\r\ngoto fail_kill_adapter;\r\nelse\r\ncontinue;\r\n}\r\nmegasas_reset_reply_desc(instance);\r\nmegasas_fusion_update_can_queue(instance, OCR_CONTEXT);\r\nif (megasas_ioc_init_fusion(instance)) {\r\ndev_warn(&instance->pdev->dev,\r\n"megasas_ioc_init_fusion() failed! for "\r\n"scsi%d\n", instance->host->host_no);\r\nif (instance->requestorId && !reason)\r\ngoto fail_kill_adapter;\r\nelse\r\ncontinue;\r\n}\r\nmegasas_refire_mgmt_cmd(instance);\r\nif (megasas_get_ctrl_info(instance)) {\r\ndev_info(&instance->pdev->dev,\r\n"Failed from %s %d\n",\r\n__func__, __LINE__);\r\nmegaraid_sas_kill_hba(instance);\r\nretval = FAILED;\r\n}\r\nmemset(fusion->load_balance_info, 0,\r\nsizeof(struct LD_LOAD_BALANCE_INFO)\r\n*MAX_LOGICAL_DRIVES_EXT);\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\nmegasas_setup_jbod_map(instance);\r\nshost_for_each_device(sdev, shost)\r\nmegasas_update_sdev_properties(sdev);\r\nclear_bit(MEGASAS_FUSION_IN_RESET,\r\n&instance->reset_flags);\r\ninstance->instancet->enable_intr(instance);\r\natomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\r\nif (instance->requestorId) {\r\nif (!megasas_sriov_start_heartbeat(instance, 0))\r\nmegasas_start_timer(instance,\r\n&instance->sriov_heartbeat_timer,\r\nmegasas_sriov_heartbeat_handler,\r\nMEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\r\nelse\r\ninstance->skip_heartbeat_timer_del = 1;\r\n}\r\ndev_warn(&instance->pdev->dev, "Reset "\r\n"successful for scsi%d.\n",\r\ninstance->host->host_no);\r\nif (instance->crash_dump_drv_support &&\r\ninstance->crash_dump_app_support)\r\nmegasas_set_crash_dump_params(instance,\r\nMR_CRASH_BUF_TURN_ON);\r\nelse\r\nmegasas_set_crash_dump_params(instance,\r\nMR_CRASH_BUF_TURN_OFF);\r\nretval = SUCCESS;\r\ngoto out;\r\n}\r\nfail_kill_adapter:\r\ndev_warn(&instance->pdev->dev, "Reset failed, killing "\r\n"adapter scsi%d.\n", instance->host->host_no);\r\nmegaraid_sas_kill_hba(instance);\r\ninstance->skip_heartbeat_timer_del = 1;\r\nretval = FAILED;\r\n} else {\r\nif (instance->requestorId) {\r\nmegasas_start_timer(instance,\r\n&instance->sriov_heartbeat_timer,\r\nmegasas_sriov_heartbeat_handler,\r\nMEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\r\n}\r\nclear_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\ninstance->instancet->enable_intr(instance);\r\natomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\r\n}\r\nout:\r\nclear_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\nmutex_unlock(&instance->reset_mutex);\r\nreturn retval;\r\n}\r\nvoid megasas_fusion_crash_dump_wq(struct work_struct *work)\r\n{\r\nstruct megasas_instance *instance =\r\ncontainer_of(work, struct megasas_instance, crash_init);\r\nu32 status_reg;\r\nu8 partial_copy = 0;\r\nstatus_reg = instance->instancet->read_fw_status_reg(instance->reg_set);\r\nif (instance->drv_buf_index == 0) {\r\nif (instance->drv_buf_alloc) {\r\ndev_info(&instance->pdev->dev, "earlier crash dump is "\r\n"not yet copied by application, ignoring this "\r\n"crash dump and initiating OCR\n");\r\nstatus_reg |= MFI_STATE_CRASH_DUMP_DONE;\r\nwritel(status_reg,\r\n&instance->reg_set->outbound_scratch_pad);\r\nreadl(&instance->reg_set->outbound_scratch_pad);\r\nreturn;\r\n}\r\nmegasas_alloc_host_crash_buffer(instance);\r\ndev_info(&instance->pdev->dev, "Number of host crash buffers "\r\n"allocated: %d\n", instance->drv_buf_alloc);\r\n}\r\nif (instance->drv_buf_index >= (instance->drv_buf_alloc)) {\r\ndev_info(&instance->pdev->dev, "Driver is done copying "\r\n"the buffer: %d\n", instance->drv_buf_alloc);\r\nstatus_reg |= MFI_STATE_CRASH_DUMP_DONE;\r\npartial_copy = 1;\r\n} else {\r\nmemcpy(instance->crash_buf[instance->drv_buf_index],\r\ninstance->crash_dump_buf, CRASH_DMA_BUF_SIZE);\r\ninstance->drv_buf_index++;\r\nstatus_reg &= ~MFI_STATE_DMADONE;\r\n}\r\nif (status_reg & MFI_STATE_CRASH_DUMP_DONE) {\r\ndev_info(&instance->pdev->dev, "Crash Dump is available,number "\r\n"of copied buffers: %d\n", instance->drv_buf_index);\r\ninstance->fw_crash_buffer_size = instance->drv_buf_index;\r\ninstance->fw_crash_state = AVAILABLE;\r\ninstance->drv_buf_index = 0;\r\nwritel(status_reg, &instance->reg_set->outbound_scratch_pad);\r\nreadl(&instance->reg_set->outbound_scratch_pad);\r\nif (!partial_copy)\r\nmegasas_reset_fusion(instance->host, 0);\r\n} else {\r\nwritel(status_reg, &instance->reg_set->outbound_scratch_pad);\r\nreadl(&instance->reg_set->outbound_scratch_pad);\r\n}\r\n}\r\nvoid megasas_fusion_ocr_wq(struct work_struct *work)\r\n{\r\nstruct megasas_instance *instance =\r\ncontainer_of(work, struct megasas_instance, work_init);\r\nmegasas_reset_fusion(instance->host, 0);\r\n}
