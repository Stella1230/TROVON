static int mxs_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nreturn d->soc->ngroups;\r\n}\r\nstatic const char *mxs_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nreturn d->soc->groups[group].name;\r\n}\r\nstatic int mxs_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = d->soc->groups[group].pins;\r\n*num_pins = d->soc->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void mxs_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int mxs_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct pinctrl_map *new_map;\r\nchar *group = NULL;\r\nunsigned new_num = 1;\r\nunsigned long config = 0;\r\nunsigned long *pconfig;\r\nint length = strlen(np->name) + SUFFIX_LEN;\r\nbool purecfg = false;\r\nu32 val, reg;\r\nint ret, i = 0;\r\nif (of_property_read_u32(np, "reg", &reg))\r\npurecfg = true;\r\nret = of_property_read_u32(np, "fsl,drive-strength", &val);\r\nif (!ret)\r\nconfig = val | MA_PRESENT;\r\nret = of_property_read_u32(np, "fsl,voltage", &val);\r\nif (!ret)\r\nconfig |= val << VOL_SHIFT | VOL_PRESENT;\r\nret = of_property_read_u32(np, "fsl,pull-up", &val);\r\nif (!ret)\r\nconfig |= val << PULL_SHIFT | PULL_PRESENT;\r\nif (!purecfg && config)\r\nnew_num = 2;\r\nnew_map = kzalloc(sizeof(*new_map) * new_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\nif (!purecfg) {\r\nnew_map[i].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[i].data.mux.function = np->name;\r\ngroup = kzalloc(length, GFP_KERNEL);\r\nif (!group) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nsnprintf(group, length, "%s.%d", np->name, reg);\r\nnew_map[i].data.mux.group = group;\r\ni++;\r\n}\r\nif (config) {\r\npconfig = kmemdup(&config, sizeof(config), GFP_KERNEL);\r\nif (!pconfig) {\r\nret = -ENOMEM;\r\ngoto free_group;\r\n}\r\nnew_map[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\nnew_map[i].data.configs.group_or_pin = purecfg ? np->name :\r\ngroup;\r\nnew_map[i].data.configs.configs = pconfig;\r\nnew_map[i].data.configs.num_configs = 1;\r\n}\r\n*map = new_map;\r\n*num_maps = new_num;\r\nreturn 0;\r\nfree_group:\r\nif (!purecfg)\r\nkfree(group);\r\nfree:\r\nkfree(new_map);\r\nreturn ret;\r\n}\r\nstatic void mxs_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nu32 i;\r\nfor (i = 0; i < num_maps; i++) {\r\nif (map[i].type == PIN_MAP_TYPE_MUX_GROUP)\r\nkfree(map[i].data.mux.group);\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\n}\r\nkfree(map);\r\n}\r\nstatic int mxs_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nreturn d->soc->nfunctions;\r\n}\r\nstatic const char *mxs_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nreturn d->soc->functions[function].name;\r\n}\r\nstatic int mxs_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = d->soc->functions[group].groups;\r\n*num_groups = d->soc->functions[group].ngroups;\r\nreturn 0;\r\n}\r\nstatic int mxs_pinctrl_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mxs_group *g = &d->soc->groups[group];\r\nvoid __iomem *reg;\r\nu8 bank, shift;\r\nu16 pin;\r\nu32 i;\r\nfor (i = 0; i < g->npins; i++) {\r\nbank = PINID_TO_BANK(g->pins[i]);\r\npin = PINID_TO_PIN(g->pins[i]);\r\nreg = d->base + d->soc->regs->muxsel;\r\nreg += bank * 0x20 + pin / 16 * 0x10;\r\nshift = pin % 16 * 2;\r\nwritel(0x3 << shift, reg + CLR);\r\nwritel(g->muxsel[i] << shift, reg + SET);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int mxs_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int mxs_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\n*config = d->soc->groups[group].config;\r\nreturn 0;\r\n}\r\nstatic int mxs_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mxs_group *g = &d->soc->groups[group];\r\nvoid __iomem *reg;\r\nu8 ma, vol, pull, bank, shift;\r\nu16 pin;\r\nu32 i;\r\nint n;\r\nunsigned long config;\r\nfor (n = 0; n < num_configs; n++) {\r\nconfig = configs[n];\r\nma = CONFIG_TO_MA(config);\r\nvol = CONFIG_TO_VOL(config);\r\npull = CONFIG_TO_PULL(config);\r\nfor (i = 0; i < g->npins; i++) {\r\nbank = PINID_TO_BANK(g->pins[i]);\r\npin = PINID_TO_PIN(g->pins[i]);\r\nreg = d->base + d->soc->regs->drive;\r\nreg += bank * 0x40 + pin / 8 * 0x10;\r\nif (config & MA_PRESENT) {\r\nshift = pin % 8 * 4;\r\nwritel(0x3 << shift, reg + CLR);\r\nwritel(ma << shift, reg + SET);\r\n}\r\nif (config & VOL_PRESENT) {\r\nshift = pin % 8 * 4 + 2;\r\nif (vol)\r\nwritel(1 << shift, reg + SET);\r\nelse\r\nwritel(1 << shift, reg + CLR);\r\n}\r\nif (config & PULL_PRESENT) {\r\nreg = d->base + d->soc->regs->pull;\r\nreg += bank * 0x10;\r\nshift = pin;\r\nif (pull)\r\nwritel(1 << shift, reg + SET);\r\nelse\r\nwritel(1 << shift, reg + CLR);\r\n}\r\n}\r\ng->config = config;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\n}\r\nstatic void mxs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nunsigned long config;\r\nif (!mxs_pinconf_group_get(pctldev, group, &config))\r\nseq_printf(s, "0x%lx", config);\r\n}\r\nstatic int mxs_pinctrl_parse_group(struct platform_device *pdev,\r\nstruct device_node *np, int idx,\r\nconst char **out_name)\r\n{\r\nstruct mxs_pinctrl_data *d = platform_get_drvdata(pdev);\r\nstruct mxs_group *g = &d->soc->groups[idx];\r\nstruct property *prop;\r\nconst char *propname = "fsl,pinmux-ids";\r\nchar *group;\r\nint length = strlen(np->name) + SUFFIX_LEN;\r\nu32 val, i;\r\ngroup = devm_kzalloc(&pdev->dev, length, GFP_KERNEL);\r\nif (!group)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(np, "reg", &val))\r\nsnprintf(group, length, "%s", np->name);\r\nelse\r\nsnprintf(group, length, "%s.%d", np->name, val);\r\ng->name = group;\r\nprop = of_find_property(np, propname, &length);\r\nif (!prop)\r\nreturn -EINVAL;\r\ng->npins = length / sizeof(u32);\r\ng->pins = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->pins),\r\nGFP_KERNEL);\r\nif (!g->pins)\r\nreturn -ENOMEM;\r\ng->muxsel = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->muxsel),\r\nGFP_KERNEL);\r\nif (!g->muxsel)\r\nreturn -ENOMEM;\r\nof_property_read_u32_array(np, propname, g->pins, g->npins);\r\nfor (i = 0; i < g->npins; i++) {\r\ng->muxsel[i] = MUXID_TO_MUXSEL(g->pins[i]);\r\ng->pins[i] = MUXID_TO_PINID(g->pins[i]);\r\n}\r\nif (out_name)\r\n*out_name = g->name;\r\nreturn 0;\r\n}\r\nstatic int mxs_pinctrl_probe_dt(struct platform_device *pdev,\r\nstruct mxs_pinctrl_data *d)\r\n{\r\nstruct mxs_pinctrl_soc_data *soc = d->soc;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct mxs_function *f;\r\nconst char *gpio_compat = "fsl,mxs-gpio";\r\nconst char *fn, *fnull = "";\r\nint i = 0, idxf = 0, idxg = 0;\r\nint ret;\r\nu32 val;\r\nchild = of_get_next_child(np, NULL);\r\nif (!child) {\r\ndev_err(&pdev->dev, "no group is defined\n");\r\nreturn -ENOENT;\r\n}\r\nfn = fnull;\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, gpio_compat))\r\ncontinue;\r\nsoc->ngroups++;\r\nif (of_property_read_u32(child, "reg", &val))\r\ncontinue;\r\nif (strcmp(fn, child->name)) {\r\nfn = child->name;\r\nsoc->nfunctions++;\r\n}\r\n}\r\nsoc->functions = devm_kzalloc(&pdev->dev, soc->nfunctions *\r\nsizeof(*soc->functions), GFP_KERNEL);\r\nif (!soc->functions)\r\nreturn -ENOMEM;\r\nsoc->groups = devm_kzalloc(&pdev->dev, soc->ngroups *\r\nsizeof(*soc->groups), GFP_KERNEL);\r\nif (!soc->groups)\r\nreturn -ENOMEM;\r\nfn = fnull;\r\nf = &soc->functions[idxf];\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, gpio_compat))\r\ncontinue;\r\nif (of_property_read_u32(child, "reg", &val))\r\ncontinue;\r\nif (strcmp(fn, child->name)) {\r\nstruct device_node *child2;\r\nof_node_get(child);\r\nfor (child2 = of_get_next_child(np, child);\r\nchild2 != NULL;\r\nchild2 = of_get_next_child(np, child2)) {\r\nif (!strcmp(child2->name, fn))\r\ndev_warn(&pdev->dev,\r\n"function nodes must be grouped by name (failed for: %s)",\r\nfn);\r\n}\r\nf = &soc->functions[idxf++];\r\nf->name = fn = child->name;\r\n}\r\nf->ngroups++;\r\n}\r\nidxf = 0;\r\nfn = fnull;\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, gpio_compat))\r\ncontinue;\r\nif (of_property_read_u32(child, "reg", &val)) {\r\nret = mxs_pinctrl_parse_group(pdev, child,\r\nidxg++, NULL);\r\nif (ret)\r\nreturn ret;\r\ncontinue;\r\n}\r\nif (strcmp(fn, child->name)) {\r\nf = &soc->functions[idxf++];\r\nf->groups = devm_kzalloc(&pdev->dev, f->ngroups *\r\nsizeof(*f->groups),\r\nGFP_KERNEL);\r\nif (!f->groups)\r\nreturn -ENOMEM;\r\nfn = child->name;\r\ni = 0;\r\n}\r\nret = mxs_pinctrl_parse_group(pdev, child, idxg++,\r\n&f->groups[i++]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint mxs_pinctrl_probe(struct platform_device *pdev,\r\nstruct mxs_pinctrl_soc_data *soc)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mxs_pinctrl_data *d;\r\nint ret;\r\nd = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nd->dev = &pdev->dev;\r\nd->soc = soc;\r\nd->base = of_iomap(np, 0);\r\nif (!d->base)\r\nreturn -EADDRNOTAVAIL;\r\nmxs_pinctrl_desc.pins = d->soc->pins;\r\nmxs_pinctrl_desc.npins = d->soc->npins;\r\nmxs_pinctrl_desc.name = dev_name(&pdev->dev);\r\nplatform_set_drvdata(pdev, d);\r\nret = mxs_pinctrl_probe_dt(pdev, d);\r\nif (ret) {\r\ndev_err(&pdev->dev, "dt probe failed: %d\n", ret);\r\ngoto err;\r\n}\r\nd->pctl = pinctrl_register(&mxs_pinctrl_desc, &pdev->dev, d);\r\nif (IS_ERR(d->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register MXS pinctrl driver\n");\r\nret = PTR_ERR(d->pctl);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\niounmap(d->base);\r\nreturn ret;\r\n}
