int input_mapper_add(struct list_head *mappers, struct imapper *entry,\r\nint (*map_op)(void *, struct imapper *), void *data)\r\n{\r\nstruct list_head *pos, *pre, *head;\r\nstruct imapper *pre_ent, *pos_ent;\r\nhead = mappers;\r\nif (list_empty(head)) {\r\nentry->next = entry->addr;\r\nmap_op(data, entry);\r\nlist_add(&entry->list, head);\r\nreturn 0;\r\n}\r\nlist_for_each(pos, head) {\r\npos_ent = list_entry(pos, struct imapper, list);\r\nif (pos_ent->slot > entry->slot) {\r\nbreak;\r\n}\r\n}\r\nif (pos != head) {\r\npre = pos->prev;\r\nif (pre == head)\r\npre = head->prev;\r\n__list_add(&entry->list, pos->prev, pos);\r\n} else {\r\npre = head->prev;\r\npos = head->next;\r\nlist_add_tail(&entry->list, head);\r\n}\r\npre_ent = list_entry(pre, struct imapper, list);\r\npos_ent = list_entry(pos, struct imapper, list);\r\nentry->next = pos_ent->addr;\r\nmap_op(data, entry);\r\npre_ent->next = entry->addr;\r\nmap_op(data, pre_ent);\r\nreturn 0;\r\n}\r\nint input_mapper_delete(struct list_head *mappers, struct imapper *entry,\r\nint (*map_op)(void *, struct imapper *), void *data)\r\n{\r\nstruct list_head *next, *pre, *head;\r\nstruct imapper *pre_ent, *next_ent;\r\nhead = mappers;\r\nif (list_empty(head))\r\nreturn 0;\r\npre = (entry->list.prev == head) ? head->prev : entry->list.prev;\r\nnext = (entry->list.next == head) ? head->next : entry->list.next;\r\nif (pre == &entry->list) {\r\nentry->next = entry->addr = entry->user = entry->slot = 0;\r\nmap_op(data, entry);\r\nlist_del(&entry->list);\r\nreturn 0;\r\n}\r\npre_ent = list_entry(pre, struct imapper, list);\r\nnext_ent = list_entry(next, struct imapper, list);\r\npre_ent->next = next_ent->addr;\r\nmap_op(data, pre_ent);\r\nlist_del(&entry->list);\r\nreturn 0;\r\n}\r\nvoid free_input_mapper_list(struct list_head *head)\r\n{\r\nstruct imapper *entry;\r\nstruct list_head *pos;\r\nwhile (!list_empty(head)) {\r\npos = head->next;\r\nlist_del(pos);\r\nentry = list_entry(pos, struct imapper, list);\r\nkfree(entry);\r\n}\r\n}
