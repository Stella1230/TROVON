static void warrior_process_packet(struct warrior *warrior)\r\n{\r\nstruct input_dev *dev = warrior->dev;\r\nunsigned char *data = warrior->data;\r\nif (!warrior->idx) return;\r\nswitch ((data[0] >> 4) & 7) {\r\ncase 1:\r\ninput_report_key(dev, BTN_TRIGGER, data[3] & 1);\r\ninput_report_key(dev, BTN_THUMB, (data[3] >> 1) & 1);\r\ninput_report_key(dev, BTN_TOP, (data[3] >> 2) & 1);\r\ninput_report_key(dev, BTN_TOP2, (data[3] >> 3) & 1);\r\nbreak;\r\ncase 3:\r\ninput_report_abs(dev, ABS_X, ((data[0] & 8) << 5) - (data[2] | ((data[0] & 4) << 5)));\r\ninput_report_abs(dev, ABS_Y, (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7));\r\nbreak;\r\ncase 5:\r\ninput_report_abs(dev, ABS_THROTTLE, (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7));\r\ninput_report_abs(dev, ABS_HAT0X, (data[3] & 2 ? 1 : 0) - (data[3] & 1 ? 1 : 0));\r\ninput_report_abs(dev, ABS_HAT0Y, (data[3] & 8 ? 1 : 0) - (data[3] & 4 ? 1 : 0));\r\ninput_report_rel(dev, REL_DIAL, (data[2] | ((data[0] & 4) << 5)) - ((data[0] & 8) << 5));\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic irqreturn_t warrior_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct warrior *warrior = serio_get_drvdata(serio);\r\nif (data & 0x80) {\r\nif (warrior->idx) warrior_process_packet(warrior);\r\nwarrior->idx = 0;\r\nwarrior->len = warrior_lengths[(data >> 4) & 7];\r\n}\r\nif (warrior->idx < warrior->len)\r\nwarrior->data[warrior->idx++] = data;\r\nif (warrior->idx == warrior->len) {\r\nif (warrior->idx) warrior_process_packet(warrior);\r\nwarrior->idx = 0;\r\nwarrior->len = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void warrior_disconnect(struct serio *serio)\r\n{\r\nstruct warrior *warrior = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(warrior->dev);\r\nkfree(warrior);\r\n}\r\nstatic int warrior_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct warrior *warrior;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nwarrior = kzalloc(sizeof(struct warrior), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!warrior || !input_dev)\r\ngoto fail1;\r\nwarrior->dev = input_dev;\r\nsnprintf(warrior->phys, sizeof(warrior->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "Logitech WingMan Warrior";\r\ninput_dev->phys = warrior->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_WARRIOR;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\r\nBIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TRIGGER)] = BIT_MASK(BTN_TRIGGER) |\r\nBIT_MASK(BTN_THUMB) | BIT_MASK(BTN_TOP) | BIT_MASK(BTN_TOP2);\r\ninput_dev->relbit[0] = BIT_MASK(REL_DIAL);\r\ninput_set_abs_params(input_dev, ABS_X, -64, 64, 0, 8);\r\ninput_set_abs_params(input_dev, ABS_Y, -64, 64, 0, 8);\r\ninput_set_abs_params(input_dev, ABS_THROTTLE, -112, 112, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_HAT0X, -1, 1, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_HAT0Y, -1, 1, 0, 0);\r\nserio_set_drvdata(serio, warrior);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(warrior->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(warrior);\r\nreturn err;\r\n}
