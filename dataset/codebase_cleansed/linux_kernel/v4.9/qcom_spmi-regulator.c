static inline int spmi_vreg_read(struct spmi_regulator *vreg, u16 addr, u8 *buf,\r\nint len)\r\n{\r\nreturn regmap_bulk_read(vreg->regmap, vreg->base + addr, buf, len);\r\n}\r\nstatic inline int spmi_vreg_write(struct spmi_regulator *vreg, u16 addr,\r\nu8 *buf, int len)\r\n{\r\nreturn regmap_bulk_write(vreg->regmap, vreg->base + addr, buf, len);\r\n}\r\nstatic int spmi_vreg_update_bits(struct spmi_regulator *vreg, u16 addr, u8 val,\r\nu8 mask)\r\n{\r\nreturn regmap_update_bits(vreg->regmap, vreg->base + addr, mask, val);\r\n}\r\nstatic int spmi_regulator_common_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 reg;\r\nspmi_vreg_read(vreg, SPMI_COMMON_REG_ENABLE, &reg, 1);\r\nreturn (reg & SPMI_COMMON_ENABLE_MASK) == SPMI_COMMON_ENABLE;\r\n}\r\nstatic int spmi_regulator_common_enable(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\r\nSPMI_COMMON_ENABLE, SPMI_COMMON_ENABLE_MASK);\r\n}\r\nstatic int spmi_regulator_vs_enable(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nif (vreg->ocp_irq) {\r\nvreg->ocp_count = 0;\r\nvreg->vs_enable_time = ktime_get();\r\n}\r\nreturn spmi_regulator_common_enable(rdev);\r\n}\r\nstatic int spmi_regulator_vs_ocp(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 reg = SPMI_VS_OCP_OVERRIDE;\r\nreturn spmi_vreg_write(vreg, SPMI_VS_REG_OCP, &reg, 1);\r\n}\r\nstatic int spmi_regulator_common_disable(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\r\nSPMI_COMMON_DISABLE, SPMI_COMMON_ENABLE_MASK);\r\n}\r\nstatic int spmi_regulator_select_voltage(struct spmi_regulator *vreg,\r\nint min_uV, int max_uV)\r\n{\r\nconst struct spmi_voltage_range *range;\r\nint uV = min_uV;\r\nint lim_min_uV, lim_max_uV, i, range_id, range_max_uV;\r\nint selector, voltage_sel;\r\nlim_min_uV = vreg->set_points->range[0].set_point_min_uV;\r\nlim_max_uV =\r\nvreg->set_points->range[vreg->set_points->count - 1].set_point_max_uV;\r\nif (uV < lim_min_uV && max_uV >= lim_min_uV)\r\nuV = lim_min_uV;\r\nif (uV < lim_min_uV || uV > lim_max_uV) {\r\ndev_err(vreg->dev,\r\n"request v=[%d, %d] is outside possible v=[%d, %d]\n",\r\nmin_uV, max_uV, lim_min_uV, lim_max_uV);\r\nreturn -EINVAL;\r\n}\r\nfor (i = vreg->set_points->count - 1; i > 0; i--) {\r\nrange_max_uV = vreg->set_points->range[i - 1].set_point_max_uV;\r\nif (uV > range_max_uV && range_max_uV > 0)\r\nbreak;\r\n}\r\nrange_id = i;\r\nrange = &vreg->set_points->range[range_id];\r\nvoltage_sel = DIV_ROUND_UP(uV - range->min_uV, range->step_uV);\r\nuV = voltage_sel * range->step_uV + range->min_uV;\r\nif (uV > max_uV) {\r\ndev_err(vreg->dev,\r\n"request v=[%d, %d] cannot be met by any set point; "\r\n"next set point: %d\n",\r\nmin_uV, max_uV, uV);\r\nreturn -EINVAL;\r\n}\r\nselector = 0;\r\nfor (i = 0; i < range_id; i++)\r\nselector += vreg->set_points->range[i].n_voltages;\r\nselector += (uV - range->set_point_min_uV) / range->step_uV;\r\nreturn selector;\r\n}\r\nstatic int spmi_sw_selector_to_hw(struct spmi_regulator *vreg,\r\nunsigned selector, u8 *range_sel,\r\nu8 *voltage_sel)\r\n{\r\nconst struct spmi_voltage_range *range, *end;\r\nrange = vreg->set_points->range;\r\nend = range + vreg->set_points->count;\r\nfor (; range < end; range++) {\r\nif (selector < range->n_voltages) {\r\n*voltage_sel = selector;\r\n*range_sel = range->range_sel;\r\nreturn 0;\r\n}\r\nselector -= range->n_voltages;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int spmi_hw_selector_to_sw(struct spmi_regulator *vreg, u8 hw_sel,\r\nconst struct spmi_voltage_range *range)\r\n{\r\nint sw_sel = hw_sel;\r\nconst struct spmi_voltage_range *r = vreg->set_points->range;\r\nwhile (r != range) {\r\nsw_sel += r->n_voltages;\r\nr++;\r\n}\r\nreturn sw_sel;\r\n}\r\nstatic const struct spmi_voltage_range *\r\nspmi_regulator_find_range(struct spmi_regulator *vreg)\r\n{\r\nu8 range_sel;\r\nconst struct spmi_voltage_range *range, *end;\r\nrange = vreg->set_points->range;\r\nend = range + vreg->set_points->count;\r\nspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, &range_sel, 1);\r\nfor (; range < end; range++)\r\nif (range->range_sel == range_sel)\r\nreturn range;\r\nreturn NULL;\r\n}\r\nstatic int spmi_regulator_select_voltage_same_range(struct spmi_regulator *vreg,\r\nint min_uV, int max_uV)\r\n{\r\nconst struct spmi_voltage_range *range;\r\nint uV = min_uV;\r\nint i, selector;\r\nrange = spmi_regulator_find_range(vreg);\r\nif (!range)\r\ngoto different_range;\r\nif (uV < range->min_uV && max_uV >= range->min_uV)\r\nuV = range->min_uV;\r\nif (uV < range->min_uV || uV > range->max_uV) {\r\ngoto different_range;\r\n}\r\nuV = DIV_ROUND_UP(uV - range->min_uV, range->step_uV);\r\nuV = uV * range->step_uV + range->min_uV;\r\nif (uV > max_uV) {\r\ngoto different_range;\r\n}\r\nselector = 0;\r\nfor (i = 0; i < vreg->set_points->count; i++) {\r\nif (uV >= vreg->set_points->range[i].set_point_min_uV\r\n&& uV <= vreg->set_points->range[i].set_point_max_uV) {\r\nselector +=\r\n(uV - vreg->set_points->range[i].set_point_min_uV)\r\n/ vreg->set_points->range[i].step_uV;\r\nbreak;\r\n}\r\nselector += vreg->set_points->range[i].n_voltages;\r\n}\r\nif (selector >= vreg->set_points->n_voltages)\r\ngoto different_range;\r\nreturn selector;\r\ndifferent_range:\r\nreturn spmi_regulator_select_voltage(vreg, min_uV, max_uV);\r\n}\r\nstatic int spmi_regulator_common_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nreturn spmi_regulator_select_voltage_same_range(vreg, min_uV, max_uV);\r\n}\r\nstatic int\r\nspmi_regulator_common_set_voltage(struct regulator_dev *rdev, unsigned selector)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nint ret;\r\nu8 buf[2];\r\nu8 range_sel, voltage_sel;\r\nret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);\r\nif (ret)\r\nreturn ret;\r\nbuf[0] = range_sel;\r\nbuf[1] = voltage_sel;\r\nreturn spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, buf, 2);\r\n}\r\nstatic int spmi_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_selector, unsigned int new_selector)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nconst struct spmi_voltage_range *range;\r\nint diff_uV;\r\nrange = spmi_regulator_find_range(vreg);\r\nif (!range)\r\nreturn -EINVAL;\r\ndiff_uV = abs(new_selector - old_selector) * range->step_uV;\r\nreturn DIV_ROUND_UP(diff_uV, vreg->slew_rate);\r\n}\r\nstatic int spmi_regulator_common_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nconst struct spmi_voltage_range *range;\r\nu8 voltage_sel;\r\nspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &voltage_sel, 1);\r\nrange = spmi_regulator_find_range(vreg);\r\nif (!range)\r\nreturn -EINVAL;\r\nreturn spmi_hw_selector_to_sw(vreg, voltage_sel, range);\r\n}\r\nstatic int spmi_regulator_single_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nreturn spmi_regulator_select_voltage(vreg, min_uV, max_uV);\r\n}\r\nstatic int spmi_regulator_single_range_set_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 sel = selector;\r\nreturn spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &sel, 1);\r\n}\r\nstatic int spmi_regulator_single_range_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 selector;\r\nint ret;\r\nret = spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &selector, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn selector;\r\n}\r\nstatic int spmi_regulator_ult_lo_smps_set_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nint ret;\r\nu8 range_sel, voltage_sel;\r\nret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);\r\nif (ret)\r\nreturn ret;\r\nif (range_sel == 1)\r\nvoltage_sel |= ULT_SMPS_RANGE_SPLIT;\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_VOLTAGE_SET,\r\nvoltage_sel, 0xff);\r\n}\r\nstatic int spmi_regulator_ult_lo_smps_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nconst struct spmi_voltage_range *range;\r\nu8 voltage_sel;\r\nspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &voltage_sel, 1);\r\nrange = spmi_regulator_find_range(vreg);\r\nif (!range)\r\nreturn -EINVAL;\r\nif (range->range_sel == 1)\r\nvoltage_sel &= ~ULT_SMPS_RANGE_SPLIT;\r\nreturn spmi_hw_selector_to_sw(vreg, voltage_sel, range);\r\n}\r\nstatic int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nint uV = 0;\r\nint i;\r\nif (selector >= vreg->set_points->n_voltages)\r\nreturn 0;\r\nfor (i = 0; i < vreg->set_points->count; i++) {\r\nif (selector < vreg->set_points->range[i].n_voltages) {\r\nuV = selector * vreg->set_points->range[i].step_uV\r\n+ vreg->set_points->range[i].set_point_min_uV;\r\nbreak;\r\n}\r\nselector -= vreg->set_points->range[i].n_voltages;\r\n}\r\nreturn uV;\r\n}\r\nstatic int\r\nspmi_regulator_common_set_bypass(struct regulator_dev *rdev, bool enable)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 mask = SPMI_COMMON_MODE_BYPASS_MASK;\r\nu8 val = 0;\r\nif (enable)\r\nval = mask;\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\r\n}\r\nstatic int\r\nspmi_regulator_common_get_bypass(struct regulator_dev *rdev, bool *enable)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 val;\r\nint ret;\r\nret = spmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &val, 1);\r\n*enable = val & SPMI_COMMON_MODE_BYPASS_MASK;\r\nreturn ret;\r\n}\r\nstatic unsigned int spmi_regulator_common_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 reg;\r\nspmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);\r\nif (reg & SPMI_COMMON_MODE_HPM_MASK)\r\nreturn REGULATOR_MODE_NORMAL;\r\nif (reg & SPMI_COMMON_MODE_AUTO_MASK)\r\nreturn REGULATOR_MODE_FAST;\r\nreturn REGULATOR_MODE_IDLE;\r\n}\r\nstatic int\r\nspmi_regulator_common_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nu8 mask = SPMI_COMMON_MODE_HPM_MASK | SPMI_COMMON_MODE_AUTO_MASK;\r\nu8 val = 0;\r\nif (mode == REGULATOR_MODE_NORMAL)\r\nval = SPMI_COMMON_MODE_HPM_MASK;\r\nelse if (mode == REGULATOR_MODE_FAST)\r\nval = SPMI_COMMON_MODE_AUTO_MASK;\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\r\n}\r\nstatic int\r\nspmi_regulator_common_set_load(struct regulator_dev *rdev, int load_uA)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nunsigned int mode;\r\nif (load_uA >= vreg->hpm_min_load)\r\nmode = REGULATOR_MODE_NORMAL;\r\nelse\r\nmode = REGULATOR_MODE_IDLE;\r\nreturn spmi_regulator_common_set_mode(rdev, mode);\r\n}\r\nstatic int spmi_regulator_common_set_pull_down(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nunsigned int mask = SPMI_COMMON_PULL_DOWN_ENABLE_MASK;\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_PULL_DOWN,\r\nmask, mask);\r\n}\r\nstatic int spmi_regulator_common_set_soft_start(struct regulator_dev *rdev)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nunsigned int mask = SPMI_LDO_SOFT_START_ENABLE_MASK;\r\nreturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_SOFT_START,\r\nmask, mask);\r\n}\r\nstatic int spmi_regulator_set_ilim(struct regulator_dev *rdev, int ilim_uA)\r\n{\r\nstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\r\nenum spmi_regulator_logical_type type = vreg->logical_type;\r\nunsigned int current_reg;\r\nu8 reg;\r\nu8 mask = SPMI_BOOST_CURRENT_LIMIT_MASK |\r\nSPMI_BOOST_CURRENT_LIMIT_ENABLE_MASK;\r\nint max = (SPMI_BOOST_CURRENT_LIMIT_MASK + 1) * 500;\r\nif (type == SPMI_REGULATOR_LOGICAL_TYPE_BOOST)\r\ncurrent_reg = SPMI_BOOST_REG_CURRENT_LIMIT;\r\nelse\r\ncurrent_reg = SPMI_BOOST_BYP_REG_CURRENT_LIMIT;\r\nif (ilim_uA > max || ilim_uA <= 0)\r\nreturn -EINVAL;\r\nreg = (ilim_uA - 1) / 500;\r\nreg |= SPMI_BOOST_CURRENT_LIMIT_ENABLE_MASK;\r\nreturn spmi_vreg_update_bits(vreg, current_reg, reg, mask);\r\n}\r\nstatic int spmi_regulator_vs_clear_ocp(struct spmi_regulator *vreg)\r\n{\r\nint ret;\r\nret = spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\r\nSPMI_COMMON_DISABLE, SPMI_COMMON_ENABLE_MASK);\r\nvreg->vs_enable_time = ktime_get();\r\nret = spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\r\nSPMI_COMMON_ENABLE, SPMI_COMMON_ENABLE_MASK);\r\nreturn ret;\r\n}\r\nstatic void spmi_regulator_vs_ocp_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct spmi_regulator *vreg\r\n= container_of(dwork, struct spmi_regulator, ocp_work);\r\nspmi_regulator_vs_clear_ocp(vreg);\r\n}\r\nstatic irqreturn_t spmi_regulator_vs_ocp_isr(int irq, void *data)\r\n{\r\nstruct spmi_regulator *vreg = data;\r\nktime_t ocp_irq_time;\r\ns64 ocp_trigger_delay_us;\r\nocp_irq_time = ktime_get();\r\nocp_trigger_delay_us = ktime_us_delta(ocp_irq_time,\r\nvreg->vs_enable_time);\r\nif (ocp_trigger_delay_us > SPMI_VS_OCP_FAULT_DELAY_US)\r\nvreg->ocp_count = 0;\r\nudelay(SPMI_VS_OCP_FALL_DELAY_US);\r\nvreg->ocp_count++;\r\nif (vreg->ocp_count == 1) {\r\nspmi_regulator_vs_clear_ocp(vreg);\r\n} else if (vreg->ocp_count <= vreg->ocp_max_retries) {\r\nschedule_delayed_work(&vreg->ocp_work,\r\nmsecs_to_jiffies(vreg->ocp_retry_delay_ms) + 1);\r\n} else {\r\ndev_err(vreg->dev,\r\n"OCP triggered %d times; no further retries\n",\r\nvreg->ocp_count);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spmi_calculate_num_voltages(struct spmi_voltage_set_points *points)\r\n{\r\nunsigned int n;\r\nstruct spmi_voltage_range *range = points->range;\r\nfor (; range < points->range + points->count; range++) {\r\nn = 0;\r\nif (range->set_point_max_uV) {\r\nn = range->set_point_max_uV - range->set_point_min_uV;\r\nn = (n / range->step_uV) + 1;\r\n}\r\nrange->n_voltages = n;\r\npoints->n_voltages += n;\r\n}\r\n}\r\nstatic int spmi_regulator_match(struct spmi_regulator *vreg, u16 force_type)\r\n{\r\nconst struct spmi_regulator_mapping *mapping;\r\nint ret, i;\r\nu32 dig_major_rev;\r\nu8 version[SPMI_COMMON_REG_SUBTYPE - SPMI_COMMON_REG_DIG_MAJOR_REV + 1];\r\nu8 type, subtype;\r\nret = spmi_vreg_read(vreg, SPMI_COMMON_REG_DIG_MAJOR_REV, version,\r\nARRAY_SIZE(version));\r\nif (ret) {\r\ndev_dbg(vreg->dev, "could not read version registers\n");\r\nreturn ret;\r\n}\r\ndig_major_rev = version[SPMI_COMMON_REG_DIG_MAJOR_REV\r\n- SPMI_COMMON_REG_DIG_MAJOR_REV];\r\nif (!force_type) {\r\ntype = version[SPMI_COMMON_REG_TYPE -\r\nSPMI_COMMON_REG_DIG_MAJOR_REV];\r\nsubtype = version[SPMI_COMMON_REG_SUBTYPE -\r\nSPMI_COMMON_REG_DIG_MAJOR_REV];\r\n} else {\r\ntype = force_type >> 8;\r\nsubtype = force_type;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(supported_regulators); i++) {\r\nmapping = &supported_regulators[i];\r\nif (mapping->type == type && mapping->subtype == subtype\r\n&& mapping->revision_min <= dig_major_rev\r\n&& mapping->revision_max >= dig_major_rev)\r\ngoto found;\r\n}\r\ndev_err(vreg->dev,\r\n"unsupported regulator: name=%s type=0x%02X, subtype=0x%02X, dig major rev=0x%02X\n",\r\nvreg->desc.name, type, subtype, dig_major_rev);\r\nreturn -ENODEV;\r\nfound:\r\nvreg->logical_type = mapping->logical_type;\r\nvreg->set_points = mapping->set_points;\r\nvreg->hpm_min_load = mapping->hpm_min_load;\r\nvreg->desc.ops = mapping->ops;\r\nif (mapping->set_points) {\r\nif (!mapping->set_points->n_voltages)\r\nspmi_calculate_num_voltages(mapping->set_points);\r\nvreg->desc.n_voltages = mapping->set_points->n_voltages;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spmi_regulator_init_slew_rate(struct spmi_regulator *vreg)\r\n{\r\nint ret;\r\nu8 reg = 0;\r\nint step, delay, slew_rate, step_delay;\r\nconst struct spmi_voltage_range *range;\r\nret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);\r\nif (ret) {\r\ndev_err(vreg->dev, "spmi read failed, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nrange = spmi_regulator_find_range(vreg);\r\nif (!range)\r\nreturn -EINVAL;\r\nswitch (vreg->logical_type) {\r\ncase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS:\r\nstep_delay = SPMI_FTSMPS_STEP_DELAY;\r\nbreak;\r\ndefault:\r\nstep_delay = SPMI_DEFAULT_STEP_DELAY;\r\nbreak;\r\n}\r\nstep = reg & SPMI_FTSMPS_STEP_CTRL_STEP_MASK;\r\nstep >>= SPMI_FTSMPS_STEP_CTRL_STEP_SHIFT;\r\ndelay = reg & SPMI_FTSMPS_STEP_CTRL_DELAY_MASK;\r\ndelay >>= SPMI_FTSMPS_STEP_CTRL_DELAY_SHIFT;\r\nslew_rate = SPMI_FTSMPS_CLOCK_RATE * range->step_uV * (1 << step);\r\nslew_rate /= 1000 * (step_delay << delay);\r\nslew_rate *= SPMI_FTSMPS_STEP_MARGIN_NUM;\r\nslew_rate /= SPMI_FTSMPS_STEP_MARGIN_DEN;\r\nvreg->slew_rate = max(slew_rate, 1);\r\nreturn ret;\r\n}\r\nstatic int spmi_regulator_init_registers(struct spmi_regulator *vreg,\r\nconst struct spmi_regulator_init_data *data)\r\n{\r\nint ret;\r\nenum spmi_regulator_logical_type type;\r\nu8 ctrl_reg[8], reg, mask;\r\ntype = vreg->logical_type;\r\nret = spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, ctrl_reg, 8);\r\nif (ret)\r\nreturn ret;\r\nif ((type == SPMI_REGULATOR_LOGICAL_TYPE_SMPS\r\n|| type == SPMI_REGULATOR_LOGICAL_TYPE_LDO\r\n|| type == SPMI_REGULATOR_LOGICAL_TYPE_VS)\r\n&& !(data->pin_ctrl_enable\r\n& SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT)) {\r\nctrl_reg[SPMI_COMMON_IDX_ENABLE] &=\r\n~SPMI_COMMON_ENABLE_FOLLOW_ALL_MASK;\r\nctrl_reg[SPMI_COMMON_IDX_ENABLE] |=\r\ndata->pin_ctrl_enable & SPMI_COMMON_ENABLE_FOLLOW_ALL_MASK;\r\n}\r\nif ((type == SPMI_REGULATOR_LOGICAL_TYPE_SMPS\r\n|| type == SPMI_REGULATOR_LOGICAL_TYPE_LDO)\r\n&& !(data->pin_ctrl_hpm\r\n& SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT)) {\r\nctrl_reg[SPMI_COMMON_IDX_MODE] &=\r\n~SPMI_COMMON_MODE_FOLLOW_ALL_MASK;\r\nctrl_reg[SPMI_COMMON_IDX_MODE] |=\r\ndata->pin_ctrl_hpm & SPMI_COMMON_MODE_FOLLOW_ALL_MASK;\r\n}\r\nif (type == SPMI_REGULATOR_LOGICAL_TYPE_VS\r\n&& !(data->pin_ctrl_hpm & SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT)) {\r\nctrl_reg[SPMI_COMMON_IDX_MODE] &=\r\n~SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\r\nctrl_reg[SPMI_COMMON_IDX_MODE] |=\r\ndata->pin_ctrl_hpm & SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\r\n}\r\nif ((type == SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS\r\n|| type == SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS\r\n|| type == SPMI_REGULATOR_LOGICAL_TYPE_ULT_LDO)\r\n&& !(data->pin_ctrl_hpm\r\n& SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT)) {\r\nctrl_reg[SPMI_COMMON_IDX_MODE] &=\r\n~SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\r\nctrl_reg[SPMI_COMMON_IDX_MODE] |=\r\ndata->pin_ctrl_hpm & SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\r\n}\r\nret = spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, ctrl_reg, 8);\r\nif (ret)\r\nreturn ret;\r\nif (type == SPMI_REGULATOR_LOGICAL_TYPE_VS) {\r\nif (data->vs_soft_start_strength\r\n!= SPMI_VS_SOFT_START_STR_HW_DEFAULT) {\r\nreg = data->vs_soft_start_strength\r\n& SPMI_VS_SOFT_START_SEL_MASK;\r\nmask = SPMI_VS_SOFT_START_SEL_MASK;\r\nreturn spmi_vreg_update_bits(vreg,\r\nSPMI_VS_REG_SOFT_START,\r\nreg, mask);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void spmi_regulator_get_dt_config(struct spmi_regulator *vreg,\r\nstruct device_node *node, struct spmi_regulator_init_data *data)\r\n{\r\ndata->pin_ctrl_enable = SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT;\r\ndata->pin_ctrl_hpm = SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT;\r\ndata->vs_soft_start_strength = SPMI_VS_SOFT_START_STR_HW_DEFAULT;\r\nof_property_read_u32(node, "qcom,ocp-max-retries",\r\n&vreg->ocp_max_retries);\r\nof_property_read_u32(node, "qcom,ocp-retry-delay",\r\n&vreg->ocp_retry_delay_ms);\r\nof_property_read_u32(node, "qcom,pin-ctrl-enable",\r\n&data->pin_ctrl_enable);\r\nof_property_read_u32(node, "qcom,pin-ctrl-hpm", &data->pin_ctrl_hpm);\r\nof_property_read_u32(node, "qcom,vs-soft-start-strength",\r\n&data->vs_soft_start_strength);\r\n}\r\nstatic unsigned int spmi_regulator_of_map_mode(unsigned int mode)\r\n{\r\nif (mode == 1)\r\nreturn REGULATOR_MODE_NORMAL;\r\nif (mode == 2)\r\nreturn REGULATOR_MODE_FAST;\r\nreturn REGULATOR_MODE_IDLE;\r\n}\r\nstatic int spmi_regulator_of_parse(struct device_node *node,\r\nconst struct regulator_desc *desc,\r\nstruct regulator_config *config)\r\n{\r\nstruct spmi_regulator_init_data data = { };\r\nstruct spmi_regulator *vreg = config->driver_data;\r\nstruct device *dev = config->dev;\r\nint ret;\r\nspmi_regulator_get_dt_config(vreg, node, &data);\r\nif (!vreg->ocp_max_retries)\r\nvreg->ocp_max_retries = SPMI_VS_OCP_DEFAULT_MAX_RETRIES;\r\nif (!vreg->ocp_retry_delay_ms)\r\nvreg->ocp_retry_delay_ms = SPMI_VS_OCP_DEFAULT_RETRY_DELAY_MS;\r\nret = spmi_regulator_init_registers(vreg, &data);\r\nif (ret) {\r\ndev_err(dev, "common initialization failed, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (vreg->logical_type) {\r\ncase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS:\r\ncase SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS:\r\ncase SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS:\r\ncase SPMI_REGULATOR_LOGICAL_TYPE_SMPS:\r\nret = spmi_regulator_init_slew_rate(vreg);\r\nif (ret)\r\nreturn ret;\r\ndefault:\r\nbreak;\r\n}\r\nif (vreg->logical_type != SPMI_REGULATOR_LOGICAL_TYPE_VS)\r\nvreg->ocp_irq = 0;\r\nif (vreg->ocp_irq) {\r\nret = devm_request_irq(dev, vreg->ocp_irq,\r\nspmi_regulator_vs_ocp_isr, IRQF_TRIGGER_RISING, "ocp",\r\nvreg);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request irq %d, ret=%d\n",\r\nvreg->ocp_irq, ret);\r\nreturn ret;\r\n}\r\nINIT_DELAYED_WORK(&vreg->ocp_work, spmi_regulator_vs_ocp_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_spmi_regulator_probe(struct platform_device *pdev)\r\n{\r\nconst struct spmi_regulator_data *reg;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nstruct spmi_regulator *vreg;\r\nstruct regmap *regmap;\r\nconst char *name;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nstruct list_head *vreg_list;\r\nvreg_list = devm_kzalloc(dev, sizeof(*vreg_list), GFP_KERNEL);\r\nif (!vreg_list)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(vreg_list);\r\nplatform_set_drvdata(pdev, vreg_list);\r\nregmap = dev_get_regmap(dev->parent, NULL);\r\nif (!regmap)\r\nreturn -ENODEV;\r\nmatch = of_match_device(qcom_spmi_regulator_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nfor (reg = match->data; reg->name; reg++) {\r\nvreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);\r\nif (!vreg)\r\nreturn -ENOMEM;\r\nvreg->dev = dev;\r\nvreg->base = reg->base;\r\nvreg->regmap = regmap;\r\nif (reg->ocp) {\r\nvreg->ocp_irq = platform_get_irq_byname(pdev, reg->ocp);\r\nif (vreg->ocp_irq < 0) {\r\nret = vreg->ocp_irq;\r\ngoto err;\r\n}\r\n}\r\nvreg->desc.id = -1;\r\nvreg->desc.owner = THIS_MODULE;\r\nvreg->desc.type = REGULATOR_VOLTAGE;\r\nvreg->desc.name = name = reg->name;\r\nvreg->desc.supply_name = reg->supply;\r\nvreg->desc.of_match = reg->name;\r\nvreg->desc.of_parse_cb = spmi_regulator_of_parse;\r\nvreg->desc.of_map_mode = spmi_regulator_of_map_mode;\r\nret = spmi_regulator_match(vreg, reg->force_type);\r\nif (ret)\r\ncontinue;\r\nconfig.dev = dev;\r\nconfig.driver_data = vreg;\r\nrdev = devm_regulator_register(dev, &vreg->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(dev, "failed to register %s\n", name);\r\nret = PTR_ERR(rdev);\r\ngoto err;\r\n}\r\nINIT_LIST_HEAD(&vreg->node);\r\nlist_add(&vreg->node, vreg_list);\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry(vreg, vreg_list, node)\r\nif (vreg->ocp_irq)\r\ncancel_delayed_work_sync(&vreg->ocp_work);\r\nreturn ret;\r\n}\r\nstatic int qcom_spmi_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct spmi_regulator *vreg;\r\nstruct list_head *vreg_list = platform_get_drvdata(pdev);\r\nlist_for_each_entry(vreg, vreg_list, node)\r\nif (vreg->ocp_irq)\r\ncancel_delayed_work_sync(&vreg->ocp_work);\r\nreturn 0;\r\n}
