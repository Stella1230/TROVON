static int jdvbt90502_reg_read(struct jdvbt90502_state *state,\r\nconst u16 reg, u8 *buf, const size_t count)\r\n{\r\nint ret;\r\nu8 wbuf[3];\r\nstruct i2c_msg msg[2];\r\nwbuf[0] = reg & 0xFF;\r\nwbuf[1] = 0;\r\nwbuf[2] = reg >> 8;\r\nmsg[0].addr = state->config.demod_address;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = wbuf;\r\nmsg[0].len = sizeof(wbuf);\r\nmsg[1].addr = msg[0].addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\ndeb_fe(" reg read failed.\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jdvbt90502_single_reg_write(struct jdvbt90502_state *state,\r\nconst u8 reg, const u8 val)\r\n{\r\nstruct i2c_msg msg;\r\nu8 wbuf[2];\r\nwbuf[0] = reg;\r\nwbuf[1] = val;\r\nmsg.addr = state->config.demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = wbuf;\r\nmsg.len = sizeof(wbuf);\r\nif (i2c_transfer(state->i2c, &msg, 1) != 1) {\r\ndeb_fe(" reg write failed.");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _jdvbt90502_write(struct dvb_frontend *fe, const u8 buf[], int len)\r\n{\r\nstruct jdvbt90502_state *state = fe->demodulator_priv;\r\nint err, i;\r\nfor (i = 0; i < len - 1; i++) {\r\nerr = jdvbt90502_single_reg_write(state,\r\nbuf[0] + i, buf[i + 1]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jdvbt90502_pll_read(struct jdvbt90502_state *state, u8 *result)\r\n{\r\nint ret;\r\nu8 pll_addr_byte = (state->config.pll_address << 1) + 1;\r\n*result = 0;\r\nret = jdvbt90502_single_reg_write(state, JDVBT90502_2ND_I2C_REG,\r\npll_addr_byte);\r\nif (ret)\r\ngoto error;\r\nret = jdvbt90502_reg_read(state, 0x0100, result, 1);\r\nif (ret)\r\ngoto error;\r\ndeb_fe("PLL read val:%02x\n", *result);\r\nreturn 0;\r\nerror:\r\ndeb_fe("%s:ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int jdvbt90502_pll_set_freq(struct jdvbt90502_state *state, u32 freq)\r\n{\r\nint ret;\r\nint retry;\r\nu8 res1;\r\nu8 res2[9];\r\nu8 pll_freq_cmd[PLL_CMD_LEN];\r\nu8 pll_agc_cmd[PLL_CMD_LEN];\r\nstruct i2c_msg msg[2];\r\nu32 f;\r\ndeb_fe("%s: freq=%d, step=%d\n", __func__, freq,\r\nstate->frontend.ops.info.frequency_stepsize);\r\nf = freq / state->frontend.ops.info.frequency_stepsize;\r\nf += 399;\r\nif (f % 7 == 0)\r\nf++;\r\npll_freq_cmd[DEMOD_REDIRECT_REG] = JDVBT90502_2ND_I2C_REG;\r\npll_freq_cmd[ADDRESS_BYTE] = state->config.pll_address << 1;\r\npll_freq_cmd[DIVIDER_BYTE1] = (f >> 8) & 0x7F;\r\npll_freq_cmd[DIVIDER_BYTE2] = f & 0xFF;\r\npll_freq_cmd[CONTROL_BYTE] = 0xB2;\r\npll_freq_cmd[BANDSWITCH_BYTE] = 0x08;\r\nmsg[0].addr = state->config.demod_address;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = pll_freq_cmd;\r\nmsg[0].len = sizeof(pll_freq_cmd);\r\nret = i2c_transfer(state->i2c, &msg[0], 1);\r\nif (ret != 1)\r\ngoto error;\r\nudelay(50);\r\npll_agc_cmd[DEMOD_REDIRECT_REG] = pll_freq_cmd[DEMOD_REDIRECT_REG];\r\npll_agc_cmd[ADDRESS_BYTE] = pll_freq_cmd[ADDRESS_BYTE];\r\npll_agc_cmd[DIVIDER_BYTE1] = pll_freq_cmd[DIVIDER_BYTE1];\r\npll_agc_cmd[DIVIDER_BYTE2] = pll_freq_cmd[DIVIDER_BYTE2];\r\npll_agc_cmd[CONTROL_BYTE] = 0x9A;\r\npll_agc_cmd[AGC_CTRL_BYTE] = 0x50;\r\nmsg[1].addr = msg[0].addr;\r\nmsg[1].flags = 0;\r\nmsg[1].buf = pll_agc_cmd;\r\nmsg[1].len = sizeof(pll_agc_cmd);\r\nret = i2c_transfer(state->i2c, &msg[1], 1);\r\nif (ret != 1)\r\ngoto error;\r\nret = jdvbt90502_single_reg_write(state, 0x01, 0x40);\r\nret |= jdvbt90502_single_reg_write(state, 0x01, 0x00);\r\nif (ret)\r\ngoto error;\r\nudelay(100);\r\n#define RETRY_COUNT 5\r\nfor (retry = 0; retry < RETRY_COUNT; retry++) {\r\nret = jdvbt90502_reg_read(state, 0x0096, &res1, 1);\r\nif (ret)\r\ngoto error;\r\nret = jdvbt90502_reg_read(state, 0x00B0, res2, sizeof(res2));\r\nif (ret)\r\ngoto error;\r\nif (res2[0] >= 0xA7)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (retry >= RETRY_COUNT) {\r\ndeb_fe("%s: FE does not get ready after freq setting.\n",\r\n__func__);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\nerror:\r\ndeb_fe("%s:ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int jdvbt90502_read_status(struct dvb_frontend *fe,\r\nenum fe_status *state)\r\n{\r\nu8 result;\r\nint ret;\r\n*state = FE_HAS_SIGNAL;\r\nret = jdvbt90502_pll_read(fe->demodulator_priv, &result);\r\nif (ret) {\r\ndeb_fe("%s:ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\n*state = FE_HAS_SIGNAL\r\n| FE_HAS_CARRIER\r\n| FE_HAS_VITERBI\r\n| FE_HAS_SYNC;\r\nif (result & PLL_STATUS_LOCKED)\r\n*state |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int jdvbt90502_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nint ret;\r\nu8 rbuf[37];\r\n*strength = 0;\r\nret = jdvbt90502_reg_read(fe->demodulator_priv, 0x0089,\r\nrbuf, sizeof(rbuf));\r\nif (ret) {\r\ndeb_fe("%s:ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\n*strength = (rbuf[3] << 8) + rbuf[4];\r\nif (rbuf[2])\r\n*strength = 0xffff;\r\nreturn 0;\r\n}\r\nstatic int jdvbt90502_set_property(struct dvb_frontend *fe,\r\nstruct dtv_property *tvp)\r\n{\r\nint r = 0;\r\nswitch (tvp->cmd) {\r\ncase DTV_DELIVERY_SYSTEM:\r\nif (tvp->u.data != SYS_ISDBT)\r\nr = -EINVAL;\r\nbreak;\r\ncase DTV_CLEAR:\r\ncase DTV_TUNE:\r\ncase DTV_FREQUENCY:\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nstatic int jdvbt90502_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct jdvbt90502_state *state = fe->demodulator_priv;\r\nint ret;\r\ndeb_fe("%s: Freq:%d\n", __func__, p->frequency);\r\np->inversion = INVERSION_AUTO;\r\np->bandwidth_hz = 6000000;\r\np->code_rate_HP = FEC_AUTO;\r\np->code_rate_LP = FEC_AUTO;\r\np->modulation = QAM_64;\r\np->transmission_mode = TRANSMISSION_MODE_AUTO;\r\np->guard_interval = GUARD_INTERVAL_AUTO;\r\np->hierarchy = HIERARCHY_AUTO;\r\np->delivery_system = SYS_ISDBT;\r\nret = jdvbt90502_pll_set_freq(state, p->frequency);\r\nif (ret) {\r\ndeb_fe("%s:ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jdvbt90502_init(struct dvb_frontend *fe)\r\n{\r\nint i = -1;\r\nint ret;\r\nstruct i2c_msg msg;\r\nstruct jdvbt90502_state *state = fe->demodulator_priv;\r\ndeb_fe("%s called.\n", __func__);\r\nmsg.addr = state->config.demod_address;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nfor (i = 0; i < init_code_len; i++) {\r\nmsg.buf = init_code[i];\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ngoto error;\r\n}\r\nfe->dtv_property_cache.delivery_system = SYS_ISDBT;\r\nmsleep(100);\r\nreturn 0;\r\nerror:\r\ndeb_fe("%s: init_code[%d] failed. ret==%d\n", __func__, i, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic void jdvbt90502_release(struct dvb_frontend *fe)\r\n{\r\nstruct jdvbt90502_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *jdvbt90502_attach(struct dvb_usb_device *d)\r\n{\r\nstruct jdvbt90502_state *state = NULL;\r\ndeb_info("%s called.\n", __func__);\r\nstate = kzalloc(sizeof(struct jdvbt90502_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = &d->i2c_adap;\r\nstate->config = friio_fe_config;\r\nstate->frontend.ops = jdvbt90502_ops;\r\nstate->frontend.demodulator_priv = state;\r\nif (jdvbt90502_init(&state->frontend) < 0)\r\ngoto error;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
