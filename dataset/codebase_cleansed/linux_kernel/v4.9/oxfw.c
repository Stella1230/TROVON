static bool detect_loud_models(struct fw_unit *unit)\r\n{\r\nconst char *const models[] = {\r\n"Onyxi",\r\n"Onyx-i",\r\n"d.Pro",\r\n"Mackie Onyx Satellite",\r\n"Tapco LINK.firewire 4x6",\r\n"U.420"};\r\nchar model[32];\r\nunsigned int i;\r\nint err;\r\nerr = fw_csr_string(unit->directory, CSR_MODEL,\r\nmodel, sizeof(model));\r\nif (err < 0)\r\nreturn false;\r\nfor (i = 0; i < ARRAY_SIZE(models); i++) {\r\nif (strcmp(models[i], model) == 0)\r\nbreak;\r\n}\r\nreturn (i < ARRAY_SIZE(models));\r\n}\r\nstatic int name_card(struct snd_oxfw *oxfw)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(oxfw->unit);\r\nconst struct compat_info *info;\r\nchar vendor[24];\r\nchar model[32];\r\nconst char *d, *v, *m;\r\nu32 firmware;\r\nint err;\r\nerr = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,\r\nvendor, sizeof(vendor));\r\nif (err < 0)\r\ngoto end;\r\nerr = fw_csr_string(oxfw->unit->directory, CSR_MODEL,\r\nmodel, sizeof(model));\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_fw_transaction(oxfw->unit, TCODE_READ_QUADLET_REQUEST,\r\nOXFORD_FIRMWARE_ID_ADDRESS, &firmware, 4, 0);\r\nif (err < 0)\r\ngoto end;\r\nbe32_to_cpus(&firmware);\r\nif (oxfw->entry->vendor_id == VENDOR_GRIFFIN ||\r\noxfw->entry->vendor_id == VENDOR_LACIE) {\r\ninfo = (const struct compat_info *)oxfw->entry->driver_data;\r\nd = info->driver_name;\r\nv = info->vendor_name;\r\nm = info->model_name;\r\n} else {\r\nd = "OXFW";\r\nv = vendor;\r\nm = model;\r\n}\r\nstrcpy(oxfw->card->driver, d);\r\nstrcpy(oxfw->card->mixername, m);\r\nstrcpy(oxfw->card->shortname, m);\r\nsnprintf(oxfw->card->longname, sizeof(oxfw->card->longname),\r\n"%s %s (OXFW%x %04x), GUID %08x%08x at %s, S%d",\r\nv, m, firmware >> 20, firmware & 0xffff,\r\nfw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&oxfw->unit->device), 100 << fw_dev->max_speed);\r\nend:\r\nreturn err;\r\n}\r\nstatic void oxfw_free(struct snd_oxfw *oxfw)\r\n{\r\nunsigned int i;\r\nsnd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);\r\nif (oxfw->has_output)\r\nsnd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);\r\nfw_unit_put(oxfw->unit);\r\nfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\r\nkfree(oxfw->tx_stream_formats[i]);\r\nkfree(oxfw->rx_stream_formats[i]);\r\n}\r\nkfree(oxfw->spec);\r\nmutex_destroy(&oxfw->mutex);\r\n}\r\nstatic void oxfw_card_free(struct snd_card *card)\r\n{\r\noxfw_free(card->private_data);\r\n}\r\nstatic int detect_quirks(struct snd_oxfw *oxfw)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(oxfw->unit);\r\nstruct fw_csr_iterator it;\r\nint key, val;\r\nint vendor, model;\r\nif (oxfw->entry->vendor_id == VENDOR_GRIFFIN)\r\nreturn snd_oxfw_add_spkr(oxfw, false);\r\nif (oxfw->entry->vendor_id == VENDOR_LACIE)\r\nreturn snd_oxfw_add_spkr(oxfw, true);\r\nif (oxfw->entry->vendor_id == OUI_STANTON) {\r\noxfw->midi_input_ports = 0;\r\noxfw->midi_output_ports = 0;\r\noxfw->has_output = false;\r\nreturn snd_oxfw_scs1x_add(oxfw);\r\n}\r\nif (oxfw->entry->vendor_id == VENDOR_TASCAM) {\r\noxfw->midi_input_ports++;\r\noxfw->midi_output_ports++;\r\nreturn 0;\r\n}\r\nvendor = model = 0;\r\nfw_csr_iterator_init(&it, fw_dev->config_rom + 5);\r\nwhile (fw_csr_iterator_next(&it, &key, &val)) {\r\nif (key == CSR_VENDOR)\r\nvendor = val;\r\nelse if (key == CSR_MODEL)\r\nmodel = val;\r\n}\r\nif (vendor == VENDOR_LOUD && model == MODEL_SATELLITE)\r\noxfw->wrong_dbs = true;\r\nreturn 0;\r\n}\r\nstatic void do_registration(struct work_struct *work)\r\n{\r\nstruct snd_oxfw *oxfw = container_of(work, struct snd_oxfw, dwork.work);\r\nint err;\r\nif (oxfw->registered)\r\nreturn;\r\nerr = snd_card_new(&oxfw->unit->device, -1, NULL, THIS_MODULE, 0,\r\n&oxfw->card);\r\nif (err < 0)\r\nreturn;\r\nerr = name_card(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nerr = detect_quirks(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_oxfw_stream_discover(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);\r\nif (err < 0)\r\ngoto error;\r\nif (oxfw->has_output) {\r\nerr = snd_oxfw_stream_init_simplex(oxfw, &oxfw->tx_stream);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nerr = snd_oxfw_create_pcm(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nsnd_oxfw_proc_init(oxfw);\r\nerr = snd_oxfw_create_midi(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_oxfw_create_hwdep(oxfw);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(oxfw->card);\r\nif (err < 0)\r\ngoto error;\r\noxfw->card->private_free = oxfw_card_free;\r\noxfw->card->private_data = oxfw;\r\noxfw->registered = true;\r\nreturn;\r\nerror:\r\nsnd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);\r\nif (oxfw->has_output)\r\nsnd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);\r\nsnd_card_free(oxfw->card);\r\ndev_info(&oxfw->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int oxfw_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_oxfw *oxfw;\r\nif (entry->vendor_id == VENDOR_LOUD && !detect_loud_models(unit))\r\nreturn -ENODEV;\r\noxfw = kzalloc(sizeof(struct snd_oxfw), GFP_KERNEL);\r\nif (oxfw == NULL)\r\nreturn -ENOMEM;\r\noxfw->entry = entry;\r\noxfw->unit = fw_unit_get(unit);\r\ndev_set_drvdata(&unit->device, oxfw);\r\nmutex_init(&oxfw->mutex);\r\nspin_lock_init(&oxfw->lock);\r\ninit_waitqueue_head(&oxfw->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&oxfw->dwork, do_registration);\r\nsnd_fw_schedule_registration(unit, &oxfw->dwork);\r\nreturn 0;\r\n}\r\nstatic void oxfw_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);\r\nif (!oxfw->registered)\r\nsnd_fw_schedule_registration(unit, &oxfw->dwork);\r\nfcp_bus_reset(oxfw->unit);\r\nif (oxfw->registered) {\r\nmutex_lock(&oxfw->mutex);\r\nsnd_oxfw_stream_update_simplex(oxfw, &oxfw->rx_stream);\r\nif (oxfw->has_output)\r\nsnd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);\r\nmutex_unlock(&oxfw->mutex);\r\nif (oxfw->entry->vendor_id == OUI_STANTON)\r\nsnd_oxfw_scs1x_update(oxfw);\r\n}\r\n}\r\nstatic void oxfw_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);\r\ncancel_delayed_work_sync(&oxfw->dwork);\r\nif (oxfw->registered) {\r\nsnd_card_free_when_closed(oxfw->card);\r\n} else {\r\noxfw_free(oxfw);\r\n}\r\n}\r\nstatic int __init snd_oxfw_init(void)\r\n{\r\nreturn driver_register(&oxfw_driver.driver);\r\n}\r\nstatic void __exit snd_oxfw_exit(void)\r\n{\r\ndriver_unregister(&oxfw_driver.driver);\r\n}
