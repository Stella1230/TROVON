static bool igp_read_bios_from_vram(struct amdgpu_device *adev)\r\n{\r\nuint8_t __iomem *bios;\r\nresource_size_t vram_base;\r\nresource_size_t size = 256 * 1024;\r\nif (!(adev->flags & AMD_IS_APU))\r\nif (!amdgpu_card_posted(adev))\r\nreturn false;\r\nadev->bios = NULL;\r\nvram_base = pci_resource_start(adev->pdev, 0);\r\nbios = ioremap(vram_base, size);\r\nif (!bios) {\r\nreturn false;\r\n}\r\nif (size == 0 || !AMD_IS_VALID_VBIOS(bios)) {\r\niounmap(bios);\r\nreturn false;\r\n}\r\nadev->bios = kmalloc(size, GFP_KERNEL);\r\nif (adev->bios == NULL) {\r\niounmap(bios);\r\nreturn false;\r\n}\r\nmemcpy_fromio(adev->bios, bios, size);\r\niounmap(bios);\r\nreturn true;\r\n}\r\nbool amdgpu_read_bios(struct amdgpu_device *adev)\r\n{\r\nuint8_t __iomem *bios, val[2];\r\nsize_t size;\r\nadev->bios = NULL;\r\nbios = pci_map_rom(adev->pdev, &size);\r\nif (!bios) {\r\nreturn false;\r\n}\r\nval[0] = readb(&bios[0]);\r\nval[1] = readb(&bios[1]);\r\nif (size == 0 || !AMD_IS_VALID_VBIOS(val)) {\r\npci_unmap_rom(adev->pdev, bios);\r\nreturn false;\r\n}\r\nadev->bios = kzalloc(size, GFP_KERNEL);\r\nif (adev->bios == NULL) {\r\npci_unmap_rom(adev->pdev, bios);\r\nreturn false;\r\n}\r\nmemcpy_fromio(adev->bios, bios, size);\r\npci_unmap_rom(adev->pdev, bios);\r\nreturn true;\r\n}\r\nstatic bool amdgpu_read_bios_from_rom(struct amdgpu_device *adev)\r\n{\r\nu8 header[AMD_VBIOS_SIGNATURE_END+1] = {0};\r\nint len;\r\nif (!adev->asic_funcs->read_bios_from_rom)\r\nreturn false;\r\nif (amdgpu_asic_read_bios_from_rom(adev, &header[0], sizeof(header)) == false)\r\nreturn false;\r\nheader[AMD_VBIOS_SIGNATURE_END] = 0;\r\nif ((!AMD_IS_VALID_VBIOS(header)) ||\r\n0 != memcmp((char *)&header[AMD_VBIOS_SIGNATURE_OFFSET],\r\nAMD_VBIOS_SIGNATURE,\r\nstrlen(AMD_VBIOS_SIGNATURE)))\r\nreturn false;\r\nlen = AMD_VBIOS_LENGTH(header);\r\nlen = ALIGN(len, 4);\r\nadev->bios = kmalloc(len, GFP_KERNEL);\r\nif (!adev->bios) {\r\nDRM_ERROR("no memory to allocate for BIOS\n");\r\nreturn false;\r\n}\r\nreturn amdgpu_asic_read_bios_from_rom(adev, adev->bios, len);\r\n}\r\nstatic bool amdgpu_read_platform_bios(struct amdgpu_device *adev)\r\n{\r\nuint8_t __iomem *bios;\r\nsize_t size;\r\nadev->bios = NULL;\r\nbios = pci_platform_rom(adev->pdev, &size);\r\nif (!bios) {\r\nreturn false;\r\n}\r\nif (size == 0 || !AMD_IS_VALID_VBIOS(bios)) {\r\nreturn false;\r\n}\r\nadev->bios = kmemdup(bios, size, GFP_KERNEL);\r\nif (adev->bios == NULL) {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int amdgpu_atrm_call(acpi_handle atrm_handle, uint8_t *bios,\r\nint offset, int len)\r\n{\r\nacpi_status status;\r\nunion acpi_object atrm_arg_elements[2], *obj;\r\nstruct acpi_object_list atrm_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\r\natrm_arg.count = 2;\r\natrm_arg.pointer = &atrm_arg_elements[0];\r\natrm_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\natrm_arg_elements[0].integer.value = offset;\r\natrm_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\natrm_arg_elements[1].integer.value = len;\r\nstatus = acpi_evaluate_object(atrm_handle, NULL, &atrm_arg, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nprintk("failed to evaluate ATRM got %s\n", acpi_format_exception(status));\r\nreturn -ENODEV;\r\n}\r\nobj = (union acpi_object *)buffer.pointer;\r\nmemcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);\r\nlen = obj->buffer.length;\r\nkfree(buffer.pointer);\r\nreturn len;\r\n}\r\nstatic bool amdgpu_atrm_get_bios(struct amdgpu_device *adev)\r\n{\r\nint ret;\r\nint size = 256 * 1024;\r\nint i;\r\nstruct pci_dev *pdev = NULL;\r\nacpi_handle dhandle, atrm_handle;\r\nacpi_status status;\r\nbool found = false;\r\nif (adev->flags & AMD_IS_APU)\r\nreturn false;\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\r\ndhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\ncontinue;\r\nstatus = acpi_get_handle(dhandle, "ATRM", &atrm_handle);\r\nif (!ACPI_FAILURE(status)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\r\ndhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\ncontinue;\r\nstatus = acpi_get_handle(dhandle, "ATRM", &atrm_handle);\r\nif (!ACPI_FAILURE(status)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!found)\r\nreturn false;\r\nadev->bios = kmalloc(size, GFP_KERNEL);\r\nif (!adev->bios) {\r\nDRM_ERROR("Unable to allocate bios\n");\r\nreturn false;\r\n}\r\nfor (i = 0; i < size / ATRM_BIOS_PAGE; i++) {\r\nret = amdgpu_atrm_call(atrm_handle,\r\nadev->bios,\r\n(i * ATRM_BIOS_PAGE),\r\nATRM_BIOS_PAGE);\r\nif (ret < ATRM_BIOS_PAGE)\r\nbreak;\r\n}\r\nif (i == 0 || !AMD_IS_VALID_VBIOS(adev->bios)) {\r\nkfree(adev->bios);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic inline bool amdgpu_atrm_get_bios(struct amdgpu_device *adev)\r\n{\r\nreturn false;\r\n}\r\nstatic bool amdgpu_read_disabled_bios(struct amdgpu_device *adev)\r\n{\r\nif (adev->flags & AMD_IS_APU)\r\nreturn igp_read_bios_from_vram(adev);\r\nelse\r\nreturn amdgpu_asic_read_disabled_bios(adev);\r\n}\r\nstatic bool amdgpu_acpi_vfct_bios(struct amdgpu_device *adev)\r\n{\r\nbool ret = false;\r\nstruct acpi_table_header *hdr;\r\nacpi_size tbl_size;\r\nUEFI_ACPI_VFCT *vfct;\r\nGOP_VBIOS_CONTENT *vbios;\r\nVFCT_IMAGE_HEADER *vhdr;\r\nif (!ACPI_SUCCESS(acpi_get_table_with_size("VFCT", 1, &hdr, &tbl_size)))\r\nreturn false;\r\nif (tbl_size < sizeof(UEFI_ACPI_VFCT)) {\r\nDRM_ERROR("ACPI VFCT table present but broken (too short #1)\n");\r\ngoto out_unmap;\r\n}\r\nvfct = (UEFI_ACPI_VFCT *)hdr;\r\nif (vfct->VBIOSImageOffset + sizeof(VFCT_IMAGE_HEADER) > tbl_size) {\r\nDRM_ERROR("ACPI VFCT table present but broken (too short #2)\n");\r\ngoto out_unmap;\r\n}\r\nvbios = (GOP_VBIOS_CONTENT *)((char *)hdr + vfct->VBIOSImageOffset);\r\nvhdr = &vbios->VbiosHeader;\r\nDRM_INFO("ACPI VFCT contains a BIOS for %02x:%02x.%d %04x:%04x, size %d\n",\r\nvhdr->PCIBus, vhdr->PCIDevice, vhdr->PCIFunction,\r\nvhdr->VendorID, vhdr->DeviceID, vhdr->ImageLength);\r\nif (vhdr->PCIBus != adev->pdev->bus->number ||\r\nvhdr->PCIDevice != PCI_SLOT(adev->pdev->devfn) ||\r\nvhdr->PCIFunction != PCI_FUNC(adev->pdev->devfn) ||\r\nvhdr->VendorID != adev->pdev->vendor ||\r\nvhdr->DeviceID != adev->pdev->device) {\r\nDRM_INFO("ACPI VFCT table is not for this card\n");\r\ngoto out_unmap;\r\n}\r\nif (vfct->VBIOSImageOffset + sizeof(VFCT_IMAGE_HEADER) + vhdr->ImageLength > tbl_size) {\r\nDRM_ERROR("ACPI VFCT image truncated\n");\r\ngoto out_unmap;\r\n}\r\nadev->bios = kmemdup(&vbios->VbiosContent, vhdr->ImageLength, GFP_KERNEL);\r\nret = !!adev->bios;\r\nout_unmap:\r\nreturn ret;\r\n}\r\nstatic inline bool amdgpu_acpi_vfct_bios(struct amdgpu_device *adev)\r\n{\r\nreturn false;\r\n}\r\nbool amdgpu_get_bios(struct amdgpu_device *adev)\r\n{\r\nbool r;\r\nuint16_t tmp, bios_header_start;\r\nr = amdgpu_atrm_get_bios(adev);\r\nif (!r)\r\nr = amdgpu_acpi_vfct_bios(adev);\r\nif (!r)\r\nr = igp_read_bios_from_vram(adev);\r\nif (!r)\r\nr = amdgpu_read_bios(adev);\r\nif (!r) {\r\nr = amdgpu_read_bios_from_rom(adev);\r\n}\r\nif (!r) {\r\nr = amdgpu_read_disabled_bios(adev);\r\n}\r\nif (!r) {\r\nr = amdgpu_read_platform_bios(adev);\r\n}\r\nif (!r || adev->bios == NULL) {\r\nDRM_ERROR("Unable to locate a BIOS ROM\n");\r\nadev->bios = NULL;\r\nreturn false;\r\n}\r\nif (!AMD_IS_VALID_VBIOS(adev->bios)) {\r\nprintk("BIOS signature incorrect %x %x\n", adev->bios[0], adev->bios[1]);\r\ngoto free_bios;\r\n}\r\ntmp = RBIOS16(0x18);\r\nif (RBIOS8(tmp + 0x14) != 0x0) {\r\nDRM_INFO("Not an x86 BIOS ROM, not using.\n");\r\ngoto free_bios;\r\n}\r\nbios_header_start = RBIOS16(0x48);\r\nif (!bios_header_start) {\r\ngoto free_bios;\r\n}\r\ntmp = bios_header_start + 4;\r\nif (!memcmp(adev->bios + tmp, "ATOM", 4) ||\r\n!memcmp(adev->bios + tmp, "MOTA", 4)) {\r\nadev->is_atom_bios = true;\r\n} else {\r\nadev->is_atom_bios = false;\r\n}\r\nDRM_DEBUG("%sBIOS detected\n", adev->is_atom_bios ? "ATOM" : "COM");\r\nreturn true;\r\nfree_bios:\r\nkfree(adev->bios);\r\nadev->bios = NULL;\r\nreturn false;\r\n}
