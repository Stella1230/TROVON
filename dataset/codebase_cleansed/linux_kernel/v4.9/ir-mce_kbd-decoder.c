static void mce_kbd_rx_timeout(unsigned long data)\r\n{\r\nstruct mce_kbd_dec *mce_kbd = (struct mce_kbd_dec *)data;\r\nint i;\r\nunsigned char maskcode;\r\nIR_dprintk(2, "timer callback clearing all keys\n");\r\nfor (i = 0; i < 7; i++) {\r\nmaskcode = kbd_keycodes[MCIR2_MASK_KEYS_START + i];\r\ninput_report_key(mce_kbd->idev, maskcode, 0);\r\n}\r\nfor (i = 0; i < MCIR2_MASK_KEYS_START; i++)\r\ninput_report_key(mce_kbd->idev, kbd_keycodes[i], 0);\r\n}\r\nstatic enum mce_kbd_mode mce_kbd_mode(struct mce_kbd_dec *data)\r\n{\r\nswitch (data->header & MCIR2_MODE_MASK) {\r\ncase MCIR2_KEYBOARD_HEADER:\r\nreturn MCIR2_MODE_KEYBOARD;\r\ncase MCIR2_MOUSE_HEADER:\r\nreturn MCIR2_MODE_MOUSE;\r\ndefault:\r\nreturn MCIR2_MODE_UNKNOWN;\r\n}\r\n}\r\nstatic void ir_mce_kbd_process_keyboard_data(struct input_dev *idev,\r\nu32 scancode)\r\n{\r\nu8 keydata = (scancode >> 8) & 0xff;\r\nu8 shiftmask = scancode & 0xff;\r\nunsigned char keycode, maskcode;\r\nint i, keystate;\r\nIR_dprintk(1, "keyboard: keydata = 0x%02x, shiftmask = 0x%02x\n",\r\nkeydata, shiftmask);\r\nfor (i = 0; i < 7; i++) {\r\nmaskcode = kbd_keycodes[MCIR2_MASK_KEYS_START + i];\r\nif (shiftmask & (1 << i))\r\nkeystate = 1;\r\nelse\r\nkeystate = 0;\r\ninput_report_key(idev, maskcode, keystate);\r\n}\r\nif (keydata) {\r\nkeycode = kbd_keycodes[keydata];\r\ninput_report_key(idev, keycode, 1);\r\n} else {\r\nfor (i = 0; i < MCIR2_MASK_KEYS_START; i++)\r\ninput_report_key(idev, kbd_keycodes[i], 0);\r\n}\r\n}\r\nstatic void ir_mce_kbd_process_mouse_data(struct input_dev *idev, u32 scancode)\r\n{\r\nu8 xdata = (scancode >> 7) & 0x7f;\r\nu8 ydata = (scancode >> 14) & 0x7f;\r\nint x, y;\r\nbool right = scancode & 0x40;\r\nbool left = scancode & 0x20;\r\nif (xdata & 0x40)\r\nx = -((~xdata & 0x7f) + 1);\r\nelse\r\nx = xdata;\r\nif (ydata & 0x40)\r\ny = -((~ydata & 0x7f) + 1);\r\nelse\r\ny = ydata;\r\nIR_dprintk(1, "mouse: x = %d, y = %d, btns = %s%s\n",\r\nx, y, left ? "L" : "", right ? "R" : "");\r\ninput_report_rel(idev, REL_X, x);\r\ninput_report_rel(idev, REL_Y, y);\r\ninput_report_key(idev, BTN_LEFT, left);\r\ninput_report_key(idev, BTN_RIGHT, right);\r\n}\r\nstatic int ir_mce_kbd_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct mce_kbd_dec *data = &dev->raw->mce_kbd;\r\nu32 scancode;\r\nunsigned long delay;\r\nif (!is_timing_event(ev)) {\r\nif (ev.reset)\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nif (!geq_margin(ev.duration, MCIR2_UNIT, MCIR2_UNIT / 2))\r\ngoto out;\r\nagain:\r\nIR_dprintk(2, "started at state %i (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\nif (!geq_margin(ev.duration, MCIR2_UNIT, MCIR2_UNIT / 2))\r\nreturn 0;\r\nswitch (data->state) {\r\ncase STATE_INACTIVE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, MCIR2_PREFIX_PULSE, MCIR2_UNIT))\r\nbreak;\r\ndata->state = STATE_HEADER_BIT_START;\r\ndata->count = 0;\r\ndata->header = 0;\r\nreturn 0;\r\ncase STATE_HEADER_BIT_START:\r\nif (geq_margin(ev.duration, MCIR2_MAX_LEN, MCIR2_UNIT / 2))\r\nbreak;\r\ndata->header <<= 1;\r\nif (ev.pulse)\r\ndata->header |= 1;\r\ndata->count++;\r\ndata->state = STATE_HEADER_BIT_END;\r\nreturn 0;\r\ncase STATE_HEADER_BIT_END:\r\nif (!is_transition(&ev, &dev->raw->prev_ev))\r\nbreak;\r\ndecrease_duration(&ev, MCIR2_BIT_END);\r\nif (data->count != MCIR2_HEADER_NBITS) {\r\ndata->state = STATE_HEADER_BIT_START;\r\ngoto again;\r\n}\r\nswitch (mce_kbd_mode(data)) {\r\ncase MCIR2_MODE_KEYBOARD:\r\ndata->wanted_bits = MCIR2_KEYBOARD_NBITS;\r\nbreak;\r\ncase MCIR2_MODE_MOUSE:\r\ndata->wanted_bits = MCIR2_MOUSE_NBITS;\r\nbreak;\r\ndefault:\r\nIR_dprintk(1, "not keyboard or mouse data\n");\r\ngoto out;\r\n}\r\ndata->count = 0;\r\ndata->body = 0;\r\ndata->state = STATE_BODY_BIT_START;\r\ngoto again;\r\ncase STATE_BODY_BIT_START:\r\nif (geq_margin(ev.duration, MCIR2_MAX_LEN, MCIR2_UNIT / 2))\r\nbreak;\r\ndata->body <<= 1;\r\nif (ev.pulse)\r\ndata->body |= 1;\r\ndata->count++;\r\ndata->state = STATE_BODY_BIT_END;\r\nreturn 0;\r\ncase STATE_BODY_BIT_END:\r\nif (!is_transition(&ev, &dev->raw->prev_ev))\r\nbreak;\r\nif (data->count == data->wanted_bits)\r\ndata->state = STATE_FINISHED;\r\nelse\r\ndata->state = STATE_BODY_BIT_START;\r\ndecrease_duration(&ev, MCIR2_BIT_END);\r\ngoto again;\r\ncase STATE_FINISHED:\r\nif (ev.pulse)\r\nbreak;\r\nswitch (data->wanted_bits) {\r\ncase MCIR2_KEYBOARD_NBITS:\r\nscancode = data->body & 0xffff;\r\nIR_dprintk(1, "keyboard data 0x%08x\n", data->body);\r\nif (dev->timeout)\r\ndelay = usecs_to_jiffies(dev->timeout / 1000);\r\nelse\r\ndelay = msecs_to_jiffies(100);\r\nmod_timer(&data->rx_timeout, jiffies + delay);\r\nir_mce_kbd_process_keyboard_data(data->idev, scancode);\r\nbreak;\r\ncase MCIR2_MOUSE_NBITS:\r\nscancode = data->body & 0x1fffff;\r\nIR_dprintk(1, "mouse data 0x%06x\n", scancode);\r\nir_mce_kbd_process_mouse_data(data->idev, scancode);\r\nbreak;\r\ndefault:\r\nIR_dprintk(1, "not keyboard or mouse data\n");\r\ngoto out;\r\n}\r\ndata->state = STATE_INACTIVE;\r\ninput_sync(data->idev);\r\nreturn 0;\r\n}\r\nout:\r\nIR_dprintk(1, "failed at state %i (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\ndata->state = STATE_INACTIVE;\r\ninput_sync(data->idev);\r\nreturn -EINVAL;\r\n}\r\nstatic int ir_mce_kbd_register(struct rc_dev *dev)\r\n{\r\nstruct mce_kbd_dec *mce_kbd = &dev->raw->mce_kbd;\r\nstruct input_dev *idev;\r\nint i, ret;\r\nidev = input_allocate_device();\r\nif (!idev)\r\nreturn -ENOMEM;\r\nsnprintf(mce_kbd->name, sizeof(mce_kbd->name),\r\n"MCE IR Keyboard/Mouse (%s)", dev->driver_name);\r\nstrlcat(mce_kbd->phys, "/input0", sizeof(mce_kbd->phys));\r\nidev->name = mce_kbd->name;\r\nidev->phys = mce_kbd->phys;\r\nset_bit(EV_KEY, idev->evbit);\r\nset_bit(EV_REP, idev->evbit);\r\nfor (i = 0; i < sizeof(kbd_keycodes); i++)\r\nset_bit(kbd_keycodes[i], idev->keybit);\r\nset_bit(EV_REL, idev->evbit);\r\nset_bit(REL_X, idev->relbit);\r\nset_bit(REL_Y, idev->relbit);\r\nset_bit(BTN_LEFT, idev->keybit);\r\nset_bit(BTN_RIGHT, idev->keybit);\r\nset_bit(EV_MSC, idev->evbit);\r\nset_bit(MSC_SCAN, idev->mscbit);\r\nsetup_timer(&mce_kbd->rx_timeout, mce_kbd_rx_timeout,\r\n(unsigned long)mce_kbd);\r\ninput_set_drvdata(idev, mce_kbd);\r\n#if 0\r\nidev->dev.parent = &dev->dev;\r\n#endif\r\nret = input_register_device(idev);\r\nif (ret < 0) {\r\ninput_free_device(idev);\r\nreturn -EIO;\r\n}\r\nmce_kbd->idev = idev;\r\nreturn 0;\r\n}\r\nstatic int ir_mce_kbd_unregister(struct rc_dev *dev)\r\n{\r\nstruct mce_kbd_dec *mce_kbd = &dev->raw->mce_kbd;\r\nstruct input_dev *idev = mce_kbd->idev;\r\ndel_timer_sync(&mce_kbd->rx_timeout);\r\ninput_unregister_device(idev);\r\nreturn 0;\r\n}\r\nstatic int __init ir_mce_kbd_decode_init(void)\r\n{\r\nir_raw_handler_register(&mce_kbd_handler);\r\nprintk(KERN_INFO "IR MCE Keyboard/mouse protocol handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_mce_kbd_decode_exit(void)\r\n{\r\nir_raw_handler_unregister(&mce_kbd_handler);\r\n}
