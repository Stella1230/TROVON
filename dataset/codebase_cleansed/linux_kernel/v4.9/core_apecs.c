static int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,\r\nunsigned long *pci_addr, unsigned char *type1)\r\n{\r\nunsigned long addr;\r\nu8 bus = pbus->number;\r\nDBGC(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x,"\r\n" pci_addr=0x%p, type1=0x%p)\n",\r\nbus, device_fn, where, pci_addr, type1));\r\nif (bus == 0) {\r\nint device = device_fn >> 3;\r\nif (device > 20) {\r\nDBGC(("mk_conf_addr: device (%d) > 20, returning -1\n",\r\ndevice));\r\nreturn -1;\r\n}\r\n*type1 = 0;\r\naddr = (device_fn << 8) | (where);\r\n} else {\r\n*type1 = 1;\r\naddr = (bus << 16) | (device_fn << 8) | (where);\r\n}\r\n*pci_addr = addr;\r\nDBGC(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nconf_read(unsigned long addr, unsigned char type1)\r\n{\r\nunsigned long flags;\r\nunsigned int stat0, value;\r\nunsigned int haxr2 = 0;\r\nlocal_irq_save(flags);\r\nDBGC(("conf_read(addr=0x%lx, type1=%d)\n", addr, type1));\r\nstat0 = *(vuip)APECS_IOC_DCSR;\r\n*(vuip)APECS_IOC_DCSR = stat0;\r\nmb();\r\nDBGC(("conf_read: APECS DCSR was 0x%x\n", stat0));\r\nif (type1) {\r\nhaxr2 = *(vuip)APECS_IOC_HAXR2;\r\nmb();\r\n*(vuip)APECS_IOC_HAXR2 = haxr2 | 1;\r\nDBGC(("conf_read: TYPE1 access\n"));\r\n}\r\ndraina();\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\nasm volatile("ldl %0,%1; mb; mb" : "=r"(value) : "m"(*(vuip)addr)\r\n: "$9", "$10", "$11", "$12", "$13", "$14", "memory");\r\nif (mcheck_taken(0)) {\r\nmcheck_taken(0) = 0;\r\nvalue = 0xffffffffU;\r\nmb();\r\n}\r\nmcheck_expected(0) = 0;\r\nmb();\r\n#if 1\r\ndraina();\r\nstat0 = *(vuip)APECS_IOC_DCSR;\r\nDBGC(("conf_read: APECS DCSR after read 0x%x\n", stat0));\r\nif (stat0 & 0xffe0U) {\r\nif (!(stat0 & 0x0800)) {\r\nprintk("apecs.c:conf_read: got stat0=%x\n", stat0);\r\n}\r\n*(vuip)APECS_IOC_DCSR = stat0;\r\nmb();\r\nwrmces(0x7);\r\nvalue = 0xffffffff;\r\n}\r\n#endif\r\nif (type1) {\r\n*(vuip)APECS_IOC_HAXR2 = haxr2 & ~1;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\nreturn value;\r\n}\r\nstatic void\r\nconf_write(unsigned long addr, unsigned int value, unsigned char type1)\r\n{\r\nunsigned long flags;\r\nunsigned int stat0;\r\nunsigned int haxr2 = 0;\r\nlocal_irq_save(flags);\r\nstat0 = *(vuip)APECS_IOC_DCSR;\r\n*(vuip)APECS_IOC_DCSR = stat0;\r\nmb();\r\nif (type1) {\r\nhaxr2 = *(vuip)APECS_IOC_HAXR2;\r\nmb();\r\n*(vuip)APECS_IOC_HAXR2 = haxr2 | 1;\r\n}\r\ndraina();\r\nmcheck_expected(0) = 1;\r\nmb();\r\n*(vuip)addr = value;\r\nmb();\r\nmb();\r\nmcheck_expected(0) = 0;\r\nmb();\r\n#if 1\r\ndraina();\r\nstat0 = *(vuip)APECS_IOC_DCSR;\r\nif (stat0 & 0xffe0U) {\r\nif (!(stat0 & 0x0800)) {\r\nprintk("apecs.c:conf_write: got stat0=%x\n", stat0);\r\n}\r\n*(vuip)APECS_IOC_DCSR = stat0;\r\nmb();\r\nwrmces(0x7);\r\n}\r\n#endif\r\nif (type1) {\r\n*(vuip)APECS_IOC_HAXR2 = haxr2 & ~1;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\napecs_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr, pci_addr;\r\nunsigned char type1;\r\nlong mask;\r\nint shift;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nmask = (size - 1) * 8;\r\nshift = (where & 3) * 8;\r\naddr = (pci_addr << 5) + mask + APECS_CONF;\r\n*value = conf_read(addr, type1) >> (shift);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\napecs_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr, pci_addr;\r\nunsigned char type1;\r\nlong mask;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nmask = (size - 1) * 8;\r\naddr = (pci_addr << 5) + mask + APECS_CONF;\r\nconf_write(addr, value << ((where & 3) * 8), type1);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\napecs_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\nwmb();\r\n*(vip)APECS_IOC_TBIA = 0;\r\nmb();\r\n}\r\nvoid __init\r\napecs_init_arch(void)\r\n{\r\nstruct pci_controller *hose;\r\npci_isa_hose = hose = alloc_pci_controller();\r\nhose->io_space = &ioport_resource;\r\nhose->mem_space = &iomem_resource;\r\nhose->index = 0;\r\nhose->sparse_mem_base = APECS_SPARSE_MEM - IDENT_ADDR;\r\nhose->dense_mem_base = APECS_DENSE_MEM - IDENT_ADDR;\r\nhose->sparse_io_base = APECS_IO - IDENT_ADDR;\r\nhose->dense_io_base = 0;\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 0);\r\nhose->sg_pci = NULL;\r\n__direct_map_base = 0x40000000;\r\n__direct_map_size = 0x40000000;\r\n*(vuip)APECS_IOC_PB1R = __direct_map_base | 0x00080000;\r\n*(vuip)APECS_IOC_PM1R = (__direct_map_size - 1) & 0xfff00000U;\r\n*(vuip)APECS_IOC_TB1R = 0;\r\n*(vuip)APECS_IOC_PB2R = hose->sg_isa->dma_base | 0x000c0000;\r\n*(vuip)APECS_IOC_PM2R = (hose->sg_isa->size - 1) & 0xfff00000;\r\n*(vuip)APECS_IOC_TB2R = virt_to_phys(hose->sg_isa->ptes) >> 1;\r\napecs_pci_tbi(hose, 0, -1);\r\n*(vuip)APECS_IOC_HAXR2 = 0;\r\nmb();\r\n}\r\nvoid\r\napecs_pci_clr_err(void)\r\n{\r\nunsigned int jd;\r\njd = *(vuip)APECS_IOC_DCSR;\r\nif (jd & 0xffe0L) {\r\n*(vuip)APECS_IOC_SEAR;\r\n*(vuip)APECS_IOC_DCSR = jd | 0xffe1L;\r\nmb();\r\n*(vuip)APECS_IOC_DCSR;\r\n}\r\n*(vuip)APECS_IOC_TBIA = (unsigned int)APECS_IOC_TBIA;\r\nmb();\r\n*(vuip)APECS_IOC_TBIA;\r\n}\r\nvoid\r\napecs_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nstruct el_common *mchk_header;\r\nstruct el_apecs_procdata *mchk_procdata;\r\nstruct el_apecs_sysdata_mcheck *mchk_sysdata;\r\nmchk_header = (struct el_common *)la_ptr;\r\nmchk_procdata = (struct el_apecs_procdata *)\r\n(la_ptr + mchk_header->proc_offset\r\n- sizeof(mchk_procdata->paltemp));\r\nmchk_sysdata = (struct el_apecs_sysdata_mcheck *)\r\n(la_ptr + mchk_header->sys_offset);\r\nmb();\r\nmb();\r\ndraina();\r\napecs_pci_clr_err();\r\nwrmces(0x7);\r\nmb();\r\nprocess_mcheck_info(vector, la_ptr, "APECS",\r\n(mcheck_expected(0)\r\n&& (mchk_sysdata->epic_dcsr & 0x0c00UL)));\r\n}
