static bool bcm63138_nand_intc_ack(struct brcmnand_soc *soc)\r\n{\r\nstruct bcm63138_nand_soc *priv =\r\ncontainer_of(soc, struct bcm63138_nand_soc, soc);\r\nvoid __iomem *mmio = priv->base + BCM63138_NAND_INT_STATUS;\r\nu32 val = brcmnand_readl(mmio);\r\nif (val & BCM63138_CTLRDY) {\r\nbrcmnand_writel(val & ~BCM63138_CTLRDY, mmio);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void bcm63138_nand_intc_set(struct brcmnand_soc *soc, bool en)\r\n{\r\nstruct bcm63138_nand_soc *priv =\r\ncontainer_of(soc, struct bcm63138_nand_soc, soc);\r\nvoid __iomem *mmio = priv->base + BCM63138_NAND_INT_EN;\r\nu32 val = brcmnand_readl(mmio);\r\nif (en)\r\nval |= BCM63138_CTLRDY;\r\nelse\r\nval &= ~BCM63138_CTLRDY;\r\nbrcmnand_writel(val, mmio);\r\n}\r\nstatic int bcm63138_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm63138_nand_soc *priv;\r\nstruct brcmnand_soc *soc;\r\nstruct resource *res;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nsoc = &priv->soc;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand-int-base");\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\nsoc->ctlrdy_ack = bcm63138_nand_intc_ack;\r\nsoc->ctlrdy_set_enabled = bcm63138_nand_intc_set;\r\nreturn brcmnand_probe(pdev, soc);\r\n}
