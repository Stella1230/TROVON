static inline bool isalarm(struct timerfd_ctx *ctx)\r\n{\r\nreturn ctx->clockid == CLOCK_REALTIME_ALARM ||\r\nctx->clockid == CLOCK_BOOTTIME_ALARM;\r\n}\r\nstatic void timerfd_triggered(struct timerfd_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nctx->expired = 1;\r\nctx->ticks++;\r\nwake_up_locked(&ctx->wqh);\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\n}\r\nstatic enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)\r\n{\r\nstruct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx,\r\nt.tmr);\r\ntimerfd_triggered(ctx);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic enum alarmtimer_restart timerfd_alarmproc(struct alarm *alarm,\r\nktime_t now)\r\n{\r\nstruct timerfd_ctx *ctx = container_of(alarm, struct timerfd_ctx,\r\nt.alarm);\r\ntimerfd_triggered(ctx);\r\nreturn ALARMTIMER_NORESTART;\r\n}\r\nvoid timerfd_clock_was_set(void)\r\n{\r\nktime_t moffs = ktime_mono_to_real((ktime_t){ .tv64 = 0 });\r\nstruct timerfd_ctx *ctx;\r\nunsigned long flags;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ctx, &cancel_list, clist) {\r\nif (!ctx->might_cancel)\r\ncontinue;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ctx->moffs.tv64 != moffs.tv64) {\r\nctx->moffs.tv64 = KTIME_MAX;\r\nctx->ticks++;\r\nwake_up_locked(&ctx->wqh);\r\n}\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void timerfd_remove_cancel(struct timerfd_ctx *ctx)\r\n{\r\nif (ctx->might_cancel) {\r\nctx->might_cancel = false;\r\nspin_lock(&cancel_lock);\r\nlist_del_rcu(&ctx->clist);\r\nspin_unlock(&cancel_lock);\r\n}\r\n}\r\nstatic bool timerfd_canceled(struct timerfd_ctx *ctx)\r\n{\r\nif (!ctx->might_cancel || ctx->moffs.tv64 != KTIME_MAX)\r\nreturn false;\r\nctx->moffs = ktime_mono_to_real((ktime_t){ .tv64 = 0 });\r\nreturn true;\r\n}\r\nstatic void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\r\n{\r\nif ((ctx->clockid == CLOCK_REALTIME ||\r\nctx->clockid == CLOCK_REALTIME_ALARM) &&\r\n(flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\r\nif (!ctx->might_cancel) {\r\nctx->might_cancel = true;\r\nspin_lock(&cancel_lock);\r\nlist_add_rcu(&ctx->clist, &cancel_list);\r\nspin_unlock(&cancel_lock);\r\n}\r\n} else if (ctx->might_cancel) {\r\ntimerfd_remove_cancel(ctx);\r\n}\r\n}\r\nstatic ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)\r\n{\r\nktime_t remaining;\r\nif (isalarm(ctx))\r\nremaining = alarm_expires_remaining(&ctx->t.alarm);\r\nelse\r\nremaining = hrtimer_expires_remaining_adjusted(&ctx->t.tmr);\r\nreturn remaining.tv64 < 0 ? ktime_set(0, 0): remaining;\r\n}\r\nstatic int timerfd_setup(struct timerfd_ctx *ctx, int flags,\r\nconst struct itimerspec *ktmr)\r\n{\r\nenum hrtimer_mode htmode;\r\nktime_t texp;\r\nint clockid = ctx->clockid;\r\nhtmode = (flags & TFD_TIMER_ABSTIME) ?\r\nHRTIMER_MODE_ABS: HRTIMER_MODE_REL;\r\ntexp = timespec_to_ktime(ktmr->it_value);\r\nctx->expired = 0;\r\nctx->ticks = 0;\r\nctx->tintv = timespec_to_ktime(ktmr->it_interval);\r\nif (isalarm(ctx)) {\r\nalarm_init(&ctx->t.alarm,\r\nctx->clockid == CLOCK_REALTIME_ALARM ?\r\nALARM_REALTIME : ALARM_BOOTTIME,\r\ntimerfd_alarmproc);\r\n} else {\r\nhrtimer_init(&ctx->t.tmr, clockid, htmode);\r\nhrtimer_set_expires(&ctx->t.tmr, texp);\r\nctx->t.tmr.function = timerfd_tmrproc;\r\n}\r\nif (texp.tv64 != 0) {\r\nif (isalarm(ctx)) {\r\nif (flags & TFD_TIMER_ABSTIME)\r\nalarm_start(&ctx->t.alarm, texp);\r\nelse\r\nalarm_start_relative(&ctx->t.alarm, texp);\r\n} else {\r\nhrtimer_start(&ctx->t.tmr, texp, htmode);\r\n}\r\nif (timerfd_canceled(ctx))\r\nreturn -ECANCELED;\r\n}\r\nctx->settime_flags = flags & TFD_SETTIME_FLAGS;\r\nreturn 0;\r\n}\r\nstatic int timerfd_release(struct inode *inode, struct file *file)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\ntimerfd_remove_cancel(ctx);\r\nif (isalarm(ctx))\r\nalarm_cancel(&ctx->t.alarm);\r\nelse\r\nhrtimer_cancel(&ctx->t.tmr);\r\nkfree_rcu(ctx, rcu);\r\nreturn 0;\r\n}\r\nstatic unsigned int timerfd_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nunsigned int events = 0;\r\nunsigned long flags;\r\npoll_wait(file, &ctx->wqh, wait);\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ctx->ticks)\r\nevents |= POLLIN;\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn events;\r\n}\r\nstatic ssize_t timerfd_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nssize_t res;\r\nu64 ticks = 0;\r\nif (count < sizeof(ticks))\r\nreturn -EINVAL;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nif (file->f_flags & O_NONBLOCK)\r\nres = -EAGAIN;\r\nelse\r\nres = wait_event_interruptible_locked_irq(ctx->wqh, ctx->ticks);\r\nif (timerfd_canceled(ctx)) {\r\nctx->ticks = 0;\r\nctx->expired = 0;\r\nres = -ECANCELED;\r\n}\r\nif (ctx->ticks) {\r\nticks = ctx->ticks;\r\nif (ctx->expired && ctx->tintv.tv64) {\r\nif (isalarm(ctx)) {\r\nticks += alarm_forward_now(\r\n&ctx->t.alarm, ctx->tintv) - 1;\r\nalarm_restart(&ctx->t.alarm);\r\n} else {\r\nticks += hrtimer_forward_now(&ctx->t.tmr,\r\nctx->tintv) - 1;\r\nhrtimer_restart(&ctx->t.tmr);\r\n}\r\n}\r\nctx->expired = 0;\r\nctx->ticks = 0;\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nif (ticks)\r\nres = put_user(ticks, (u64 __user *) buf) ? -EFAULT: sizeof(ticks);\r\nreturn res;\r\n}\r\nstatic void timerfd_show(struct seq_file *m, struct file *file)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nstruct itimerspec t;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nt.it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\r\nt.it_interval = ktime_to_timespec(ctx->tintv);\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nseq_printf(m,\r\n"clockid: %d\n"\r\n"ticks: %llu\n"\r\n"settime flags: 0%o\n"\r\n"it_value: (%llu, %llu)\n"\r\n"it_interval: (%llu, %llu)\n",\r\nctx->clockid,\r\n(unsigned long long)ctx->ticks,\r\nctx->settime_flags,\r\n(unsigned long long)t.it_value.tv_sec,\r\n(unsigned long long)t.it_value.tv_nsec,\r\n(unsigned long long)t.it_interval.tv_sec,\r\n(unsigned long long)t.it_interval.tv_nsec);\r\n}\r\nstatic long timerfd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase TFD_IOC_SET_TICKS: {\r\nu64 ticks;\r\nif (copy_from_user(&ticks, (u64 __user *)arg, sizeof(ticks)))\r\nreturn -EFAULT;\r\nif (!ticks)\r\nreturn -EINVAL;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nif (!timerfd_canceled(ctx)) {\r\nctx->ticks = ticks;\r\nwake_up_locked(&ctx->wqh);\r\n} else\r\nret = -ECANCELED;\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nbreak;\r\n}\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int timerfd_fget(int fd, struct fd *p)\r\n{\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn -EBADF;\r\nif (f.file->f_op != &timerfd_fops) {\r\nfdput(f);\r\nreturn -EINVAL;\r\n}\r\n*p = f;\r\nreturn 0;\r\n}\r\nstatic int do_timerfd_settime(int ufd, int flags,\r\nconst struct itimerspec *new,\r\nstruct itimerspec *old)\r\n{\r\nstruct fd f;\r\nstruct timerfd_ctx *ctx;\r\nint ret;\r\nif ((flags & ~TFD_SETTIME_FLAGS) ||\r\n!timespec_valid(&new->it_value) ||\r\n!timespec_valid(&new->it_interval))\r\nreturn -EINVAL;\r\nret = timerfd_fget(ufd, &f);\r\nif (ret)\r\nreturn ret;\r\nctx = f.file->private_data;\r\nif (!capable(CAP_WAKE_ALARM) && isalarm(ctx)) {\r\nfdput(f);\r\nreturn -EPERM;\r\n}\r\ntimerfd_setup_cancel(ctx, flags);\r\nfor (;;) {\r\nspin_lock_irq(&ctx->wqh.lock);\r\nif (isalarm(ctx)) {\r\nif (alarm_try_to_cancel(&ctx->t.alarm) >= 0)\r\nbreak;\r\n} else {\r\nif (hrtimer_try_to_cancel(&ctx->t.tmr) >= 0)\r\nbreak;\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\ncpu_relax();\r\n}\r\nif (ctx->expired && ctx->tintv.tv64) {\r\nif (isalarm(ctx))\r\nalarm_forward_now(&ctx->t.alarm, ctx->tintv);\r\nelse\r\nhrtimer_forward_now(&ctx->t.tmr, ctx->tintv);\r\n}\r\nold->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\r\nold->it_interval = ktime_to_timespec(ctx->tintv);\r\nret = timerfd_setup(ctx, flags, new);\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nfdput(f);\r\nreturn ret;\r\n}\r\nstatic int do_timerfd_gettime(int ufd, struct itimerspec *t)\r\n{\r\nstruct fd f;\r\nstruct timerfd_ctx *ctx;\r\nint ret = timerfd_fget(ufd, &f);\r\nif (ret)\r\nreturn ret;\r\nctx = f.file->private_data;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nif (ctx->expired && ctx->tintv.tv64) {\r\nctx->expired = 0;\r\nif (isalarm(ctx)) {\r\nctx->ticks +=\r\nalarm_forward_now(\r\n&ctx->t.alarm, ctx->tintv) - 1;\r\nalarm_restart(&ctx->t.alarm);\r\n} else {\r\nctx->ticks +=\r\nhrtimer_forward_now(&ctx->t.tmr, ctx->tintv)\r\n- 1;\r\nhrtimer_restart(&ctx->t.tmr);\r\n}\r\n}\r\nt->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\r\nt->it_interval = ktime_to_timespec(ctx->tintv);\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nfdput(f);\r\nreturn 0;\r\n}
