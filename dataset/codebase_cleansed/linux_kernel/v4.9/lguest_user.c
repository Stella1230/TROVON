static int getreg_setup(struct lg_cpu *cpu, const unsigned long __user *input)\r\n{\r\nunsigned long which;\r\nif (get_user(which, input) != 0)\r\nreturn -EFAULT;\r\ncpu->reg_read = lguest_arch_regptr(cpu, which, true);\r\nif (!cpu->reg_read)\r\nreturn -ENOENT;\r\nreturn sizeof(unsigned long) * 2;\r\n}\r\nstatic int setreg(struct lg_cpu *cpu, const unsigned long __user *input)\r\n{\r\nunsigned long which, value, *reg;\r\nif (get_user(which, input) != 0)\r\nreturn -EFAULT;\r\ninput++;\r\nif (get_user(value, input) != 0)\r\nreturn -EFAULT;\r\nreg = lguest_arch_regptr(cpu, which, false);\r\nif (!reg)\r\nreturn -ENOENT;\r\n*reg = value;\r\nreturn sizeof(unsigned long) * 3;\r\n}\r\nstatic int user_send_irq(struct lg_cpu *cpu, const unsigned long __user *input)\r\n{\r\nunsigned long irq;\r\nif (get_user(irq, input) != 0)\r\nreturn -EFAULT;\r\nif (irq >= LGUEST_IRQS)\r\nreturn -EINVAL;\r\nset_interrupt(cpu, irq);\r\nreturn 0;\r\n}\r\nstatic int trap(struct lg_cpu *cpu, const unsigned long __user *input)\r\n{\r\nunsigned long trapnum;\r\nif (get_user(trapnum, input) != 0)\r\nreturn -EFAULT;\r\nif (!deliver_trap(cpu, trapnum))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t read(struct file *file, char __user *user, size_t size,loff_t*o)\r\n{\r\nstruct lguest *lg = file->private_data;\r\nstruct lg_cpu *cpu;\r\nunsigned int cpu_id = *o;\r\nif (!lg)\r\nreturn -EINVAL;\r\nif (cpu_id >= lg->nr_cpus)\r\nreturn -EINVAL;\r\ncpu = &lg->cpus[cpu_id];\r\nif (current != cpu->tsk)\r\nreturn -EPERM;\r\nif (lg->dead) {\r\nsize_t len;\r\nif (IS_ERR(lg->dead))\r\nreturn PTR_ERR(lg->dead);\r\nlen = min(size, strlen(lg->dead)+1);\r\nif (copy_to_user(user, lg->dead, len) != 0)\r\nreturn -EFAULT;\r\nreturn len;\r\n}\r\nif (cpu->pending.trap)\r\ncpu->pending.trap = 0;\r\nreturn run_guest(cpu, (unsigned long __user *)user);\r\n}\r\nstatic int lg_cpu_start(struct lg_cpu *cpu, unsigned id, unsigned long start_ip)\r\n{\r\nif (id >= ARRAY_SIZE(cpu->lg->cpus))\r\nreturn -EINVAL;\r\ncpu->id = id;\r\ncpu->lg = container_of(cpu, struct lguest, cpus[id]);\r\ncpu->lg->nr_cpus++;\r\ninit_clockdev(cpu);\r\ncpu->regs_page = get_zeroed_page(GFP_KERNEL);\r\nif (!cpu->regs_page)\r\nreturn -ENOMEM;\r\ncpu->regs = (void *)cpu->regs_page + PAGE_SIZE - sizeof(*cpu->regs);\r\nlguest_arch_setup_regs(cpu, start_ip);\r\ncpu->tsk = current;\r\ncpu->mm = get_task_mm(cpu->tsk);\r\ncpu->last_pages = NULL;\r\nreturn 0;\r\n}\r\nstatic int initialize(struct file *file, const unsigned long __user *input)\r\n{\r\nstruct lguest *lg;\r\nint err;\r\nunsigned long args[4];\r\nmutex_lock(&lguest_lock);\r\nif (file->private_data) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (copy_from_user(args, input, sizeof(args)) != 0) {\r\nerr = -EFAULT;\r\ngoto unlock;\r\n}\r\nlg = kzalloc(sizeof(*lg), GFP_KERNEL);\r\nif (!lg) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nlg->mem_base = (void __user *)args[0];\r\nlg->pfn_limit = args[1];\r\nlg->device_limit = args[3];\r\nerr = lg_cpu_start(&lg->cpus[0], 0, args[2]);\r\nif (err)\r\ngoto free_lg;\r\nerr = init_guest_pagetable(lg);\r\nif (err)\r\ngoto free_regs;\r\nfile->private_data = lg;\r\nmutex_unlock(&lguest_lock);\r\nreturn sizeof(args);\r\nfree_regs:\r\nfree_page(lg->cpus[0].regs_page);\r\nfree_lg:\r\nkfree(lg);\r\nunlock:\r\nmutex_unlock(&lguest_lock);\r\nreturn err;\r\n}\r\nstatic ssize_t write(struct file *file, const char __user *in,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct lguest *lg = file->private_data;\r\nconst unsigned long __user *input = (const unsigned long __user *)in;\r\nunsigned long req;\r\nstruct lg_cpu *uninitialized_var(cpu);\r\nunsigned int cpu_id = *off;\r\nif (get_user(req, input) != 0)\r\nreturn -EFAULT;\r\ninput++;\r\nif (req != LHREQ_INITIALIZE) {\r\nif (!lg || (cpu_id >= lg->nr_cpus))\r\nreturn -EINVAL;\r\ncpu = &lg->cpus[cpu_id];\r\nif (lg->dead)\r\nreturn -ENOENT;\r\n}\r\nswitch (req) {\r\ncase LHREQ_INITIALIZE:\r\nreturn initialize(file, input);\r\ncase LHREQ_IRQ:\r\nreturn user_send_irq(cpu, input);\r\ncase LHREQ_GETREG:\r\nreturn getreg_setup(cpu, input);\r\ncase LHREQ_SETREG:\r\nreturn setreg(cpu, input);\r\ncase LHREQ_TRAP:\r\nreturn trap(cpu, input);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int close(struct inode *inode, struct file *file)\r\n{\r\nstruct lguest *lg = file->private_data;\r\nunsigned int i;\r\nif (!lg)\r\nreturn 0;\r\nmutex_lock(&lguest_lock);\r\nfree_guest_pagetable(lg);\r\nfor (i = 0; i < lg->nr_cpus; i++) {\r\nhrtimer_cancel(&lg->cpus[i].hrt);\r\nfree_page(lg->cpus[i].regs_page);\r\nmmput(lg->cpus[i].mm);\r\n}\r\nif (!IS_ERR(lg->dead))\r\nkfree(lg->dead);\r\nkfree(lg);\r\nmutex_unlock(&lguest_lock);\r\nreturn 0;\r\n}\r\nint __init lguest_device_init(void)\r\n{\r\nreturn misc_register(&lguest_dev);\r\n}\r\nvoid __exit lguest_device_remove(void)\r\n{\r\nmisc_deregister(&lguest_dev);\r\n}
