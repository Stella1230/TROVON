static void *schizo_pci_config_mkaddr(struct pci_pbm_info *pbm,\r\nunsigned char bus,\r\nunsigned int devfn,\r\nint where)\r\n{\r\nif (!pbm)\r\nreturn NULL;\r\nbus -= pbm->pci_first_busno;\r\nreturn (void *)\r\n(SCHIZO_CONFIG_BASE(pbm) |\r\nSCHIZO_CONFIG_ENCODE(bus, devfn, where));\r\n}\r\nstatic void __schizo_check_stc_error_pbm(struct pci_pbm_info *pbm,\r\nenum schizo_error_type type)\r\n{\r\nstruct strbuf *strbuf = &pbm->stc;\r\nunsigned long regbase = pbm->pbm_regs;\r\nunsigned long err_base, tag_base, line_base;\r\nu64 control;\r\nint i;\r\nerr_base = regbase + SCHIZO_STC_ERR;\r\ntag_base = regbase + SCHIZO_STC_TAG;\r\nline_base = regbase + SCHIZO_STC_LINE;\r\nspin_lock(&stc_buf_lock);\r\ncontrol = upa_readq(strbuf->strbuf_control);\r\nupa_writeq((control | SCHIZO_STRBUF_CTRL_DENAB),\r\nstrbuf->strbuf_control);\r\nfor (i = 0; i < 128; i++) {\r\nunsigned long val;\r\nval = upa_readq(err_base + (i * 8UL));\r\nupa_writeq(0UL, err_base + (i * 8UL));\r\nstc_error_buf[i] = val;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nstc_tag_buf[i] = upa_readq(tag_base + (i * 8UL));\r\nstc_line_buf[i] = upa_readq(line_base + (i * 8UL));\r\nupa_writeq(0UL, tag_base + (i * 8UL));\r\nupa_writeq(0UL, line_base + (i * 8UL));\r\n}\r\nupa_writeq(control, strbuf->strbuf_control);\r\nfor (i = 0; i < 16; i++) {\r\nint j, saw_error, first, last;\r\nsaw_error = 0;\r\nfirst = i * 8;\r\nlast = first + 8;\r\nfor (j = first; j < last; j++) {\r\nunsigned long errval = stc_error_buf[j];\r\nif (errval != 0) {\r\nsaw_error++;\r\nprintk("%s: STC_ERR(%d)[wr(%d)rd(%d)]\n",\r\npbm->name,\r\nj,\r\n(errval & SCHIZO_STCERR_WRITE) ? 1 : 0,\r\n(errval & SCHIZO_STCERR_READ) ? 1 : 0);\r\n}\r\n}\r\nif (saw_error != 0) {\r\nunsigned long tagval = stc_tag_buf[i];\r\nunsigned long lineval = stc_line_buf[i];\r\nprintk("%s: STC_TAG(%d)[PA(%016lx)VA(%08lx)V(%d)R(%d)]\n",\r\npbm->name,\r\ni,\r\n((tagval & SCHIZO_STCTAG_PPN) >> 19UL),\r\n(tagval & SCHIZO_STCTAG_VPN),\r\n((tagval & SCHIZO_STCTAG_VALID) ? 1 : 0),\r\n((tagval & SCHIZO_STCTAG_READ) ? 1 : 0));\r\nprintk("%s: STC_LINE(%d)[LIDX(%lx)SP(%lx)LADDR(%lx)EP(%lx)"\r\n"V(%d)FOFN(%d)]\n",\r\npbm->name,\r\ni,\r\n((lineval & SCHIZO_STCLINE_LINDX) >> 23UL),\r\n((lineval & SCHIZO_STCLINE_SPTR) >> 13UL),\r\n((lineval & SCHIZO_STCLINE_LADDR) >> 6UL),\r\n((lineval & SCHIZO_STCLINE_EPTR) >> 0UL),\r\n((lineval & SCHIZO_STCLINE_VALID) ? 1 : 0),\r\n((lineval & SCHIZO_STCLINE_FOFN) ? 1 : 0));\r\n}\r\n}\r\nspin_unlock(&stc_buf_lock);\r\n}\r\nstatic void schizo_check_iommu_error_pbm(struct pci_pbm_info *pbm,\r\nenum schizo_error_type type)\r\n{\r\nstruct iommu *iommu = pbm->iommu;\r\nunsigned long iommu_tag[16];\r\nunsigned long iommu_data[16];\r\nunsigned long flags;\r\nu64 control;\r\nint i;\r\nspin_lock_irqsave(&iommu->lock, flags);\r\ncontrol = upa_readq(iommu->iommu_control);\r\nif (control & SCHIZO_IOMMU_CTRL_XLTEERR) {\r\nunsigned long base;\r\nchar *type_string;\r\ncontrol &= ~SCHIZO_IOMMU_CTRL_XLTEERR;\r\nupa_writeq(control, iommu->iommu_control);\r\nswitch((control & SCHIZO_IOMMU_CTRL_XLTESTAT) >> 25UL) {\r\ncase 0:\r\ntype_string = "Protection Error";\r\nbreak;\r\ncase 1:\r\ntype_string = "Invalid Error";\r\nbreak;\r\ncase 2:\r\ntype_string = "TimeOut Error";\r\nbreak;\r\ncase 3:\r\ndefault:\r\ntype_string = "ECC Error";\r\nbreak;\r\n}\r\nprintk("%s: IOMMU Error, type[%s]\n",\r\npbm->name, type_string);\r\nupa_writeq(control | SCHIZO_IOMMU_CTRL_DENAB,\r\niommu->iommu_control);\r\nbase = pbm->pbm_regs;\r\nfor (i = 0; i < 16; i++) {\r\niommu_tag[i] =\r\nupa_readq(base + SCHIZO_IOMMU_TAG + (i * 8UL));\r\niommu_data[i] =\r\nupa_readq(base + SCHIZO_IOMMU_DATA + (i * 8UL));\r\nupa_writeq(0, base + SCHIZO_IOMMU_TAG + (i * 8UL));\r\nupa_writeq(0, base + SCHIZO_IOMMU_DATA + (i * 8UL));\r\n}\r\nupa_writeq(control, iommu->iommu_control);\r\nfor (i = 0; i < 16; i++) {\r\nunsigned long tag, data;\r\ntag = iommu_tag[i];\r\nif (!(tag & SCHIZO_IOMMU_TAG_ERR))\r\ncontinue;\r\ndata = iommu_data[i];\r\nswitch((tag & SCHIZO_IOMMU_TAG_ERRSTS) >> 23UL) {\r\ncase 0:\r\ntype_string = "Protection Error";\r\nbreak;\r\ncase 1:\r\ntype_string = "Invalid Error";\r\nbreak;\r\ncase 2:\r\ntype_string = "TimeOut Error";\r\nbreak;\r\ncase 3:\r\ndefault:\r\ntype_string = "ECC Error";\r\nbreak;\r\n}\r\nprintk("%s: IOMMU TAG(%d)[error(%s) ctx(%x) wr(%d) str(%d) "\r\n"sz(%dK) vpg(%08lx)]\n",\r\npbm->name, i, type_string,\r\n(int)((tag & SCHIZO_IOMMU_TAG_CTXT) >> 25UL),\r\n((tag & SCHIZO_IOMMU_TAG_WRITE) ? 1 : 0),\r\n((tag & SCHIZO_IOMMU_TAG_STREAM) ? 1 : 0),\r\n((tag & SCHIZO_IOMMU_TAG_SIZE) ? 64 : 8),\r\n(tag & SCHIZO_IOMMU_TAG_VPAGE) << IOMMU_PAGE_SHIFT);\r\nprintk("%s: IOMMU DATA(%d)[valid(%d) cache(%d) ppg(%016lx)]\n",\r\npbm->name, i,\r\n((data & SCHIZO_IOMMU_DATA_VALID) ? 1 : 0),\r\n((data & SCHIZO_IOMMU_DATA_CACHE) ? 1 : 0),\r\n(data & SCHIZO_IOMMU_DATA_PPAGE) << IOMMU_PAGE_SHIFT);\r\n}\r\n}\r\nif (pbm->stc.strbuf_enabled)\r\n__schizo_check_stc_error_pbm(pbm, type);\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\n}\r\nstatic void schizo_check_iommu_error(struct pci_pbm_info *pbm,\r\nenum schizo_error_type type)\r\n{\r\nschizo_check_iommu_error_pbm(pbm, type);\r\nif (pbm->sibling)\r\nschizo_check_iommu_error_pbm(pbm->sibling, type);\r\n}\r\nstatic irqreturn_t schizo_ue_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nunsigned long afsr_reg = pbm->controller_regs + SCHIZO_UE_AFSR;\r\nunsigned long afar_reg = pbm->controller_regs + SCHIZO_UE_AFAR;\r\nunsigned long afsr, afar, error_bits;\r\nint reported, limit;\r\nafar = upa_readq(afar_reg);\r\nlimit = 1000;\r\ndo {\r\nafsr = upa_readq(afsr_reg);\r\n} while ((afsr & SCHIZO_UEAFSR_ERRPNDG) != 0 && --limit);\r\nerror_bits = afsr &\r\n(SCHIZO_UEAFSR_PPIO | SCHIZO_UEAFSR_PDRD | SCHIZO_UEAFSR_PDWR |\r\nSCHIZO_UEAFSR_SPIO | SCHIZO_UEAFSR_SDMA);\r\nif (!error_bits)\r\nreturn IRQ_NONE;\r\nupa_writeq(error_bits, afsr_reg);\r\nprintk("%s: Uncorrectable Error, primary error type[%s]\n",\r\npbm->name,\r\n(((error_bits & SCHIZO_UEAFSR_PPIO) ?\r\n"PIO" :\r\n((error_bits & SCHIZO_UEAFSR_PDRD) ?\r\n"DMA Read" :\r\n((error_bits & SCHIZO_UEAFSR_PDWR) ?\r\n"DMA Write" : "???")))));\r\nprintk("%s: bytemask[%04lx] qword_offset[%lx] SAFARI_AID[%02lx]\n",\r\npbm->name,\r\n(afsr & SCHIZO_UEAFSR_BMSK) >> 32UL,\r\n(afsr & SCHIZO_UEAFSR_QOFF) >> 30UL,\r\n(afsr & SCHIZO_UEAFSR_AID) >> 24UL);\r\nprintk("%s: partial[%d] owned_in[%d] mtag[%lx] mtag_synd[%lx] ecc_sync[%lx]\n",\r\npbm->name,\r\n(afsr & SCHIZO_UEAFSR_PARTIAL) ? 1 : 0,\r\n(afsr & SCHIZO_UEAFSR_OWNEDIN) ? 1 : 0,\r\n(afsr & SCHIZO_UEAFSR_MTAG) >> 13UL,\r\n(afsr & SCHIZO_UEAFSR_MTAGSYND) >> 16UL,\r\n(afsr & SCHIZO_UEAFSR_ECCSYND) >> 0UL);\r\nprintk("%s: UE AFAR [%016lx]\n", pbm->name, afar);\r\nprintk("%s: UE Secondary errors [", pbm->name);\r\nreported = 0;\r\nif (afsr & SCHIZO_UEAFSR_SPIO) {\r\nreported++;\r\nprintk("(PIO)");\r\n}\r\nif (afsr & SCHIZO_UEAFSR_SDMA) {\r\nreported++;\r\nprintk("(DMA)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nschizo_check_iommu_error(pbm, UE_ERR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t schizo_ce_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nunsigned long afsr_reg = pbm->controller_regs + SCHIZO_CE_AFSR;\r\nunsigned long afar_reg = pbm->controller_regs + SCHIZO_CE_AFAR;\r\nunsigned long afsr, afar, error_bits;\r\nint reported, limit;\r\nafar = upa_readq(afar_reg);\r\nlimit = 1000;\r\ndo {\r\nafsr = upa_readq(afsr_reg);\r\n} while ((afsr & SCHIZO_UEAFSR_ERRPNDG) != 0 && --limit);\r\nerror_bits = afsr &\r\n(SCHIZO_CEAFSR_PPIO | SCHIZO_CEAFSR_PDRD | SCHIZO_CEAFSR_PDWR |\r\nSCHIZO_CEAFSR_SPIO | SCHIZO_CEAFSR_SDMA);\r\nif (!error_bits)\r\nreturn IRQ_NONE;\r\nupa_writeq(error_bits, afsr_reg);\r\nprintk("%s: Correctable Error, primary error type[%s]\n",\r\npbm->name,\r\n(((error_bits & SCHIZO_CEAFSR_PPIO) ?\r\n"PIO" :\r\n((error_bits & SCHIZO_CEAFSR_PDRD) ?\r\n"DMA Read" :\r\n((error_bits & SCHIZO_CEAFSR_PDWR) ?\r\n"DMA Write" : "???")))));\r\nprintk("%s: bytemask[%04lx] qword_offset[%lx] SAFARI_AID[%02lx]\n",\r\npbm->name,\r\n(afsr & SCHIZO_UEAFSR_BMSK) >> 32UL,\r\n(afsr & SCHIZO_UEAFSR_QOFF) >> 30UL,\r\n(afsr & SCHIZO_UEAFSR_AID) >> 24UL);\r\nprintk("%s: partial[%d] owned_in[%d] mtag[%lx] mtag_synd[%lx] ecc_sync[%lx]\n",\r\npbm->name,\r\n(afsr & SCHIZO_UEAFSR_PARTIAL) ? 1 : 0,\r\n(afsr & SCHIZO_UEAFSR_OWNEDIN) ? 1 : 0,\r\n(afsr & SCHIZO_UEAFSR_MTAG) >> 13UL,\r\n(afsr & SCHIZO_UEAFSR_MTAGSYND) >> 16UL,\r\n(afsr & SCHIZO_UEAFSR_ECCSYND) >> 0UL);\r\nprintk("%s: CE AFAR [%016lx]\n", pbm->name, afar);\r\nprintk("%s: CE Secondary errors [", pbm->name);\r\nreported = 0;\r\nif (afsr & SCHIZO_CEAFSR_SPIO) {\r\nreported++;\r\nprintk("(PIO)");\r\n}\r\nif (afsr & SCHIZO_CEAFSR_SDMA) {\r\nreported++;\r\nprintk("(DMA)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t schizo_pcierr_intr_other(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long csr_reg, csr, csr_error_bits;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 stat;\r\ncsr_reg = pbm->pbm_regs + SCHIZO_PCI_CTRL;\r\ncsr = upa_readq(csr_reg);\r\ncsr_error_bits =\r\ncsr & (SCHIZO_PCICTRL_BUS_UNUS |\r\nSCHIZO_PCICTRL_TTO_ERR |\r\nSCHIZO_PCICTRL_RTRY_ERR |\r\nSCHIZO_PCICTRL_DTO_ERR |\r\nSCHIZO_PCICTRL_SBH_ERR |\r\nSCHIZO_PCICTRL_SERR);\r\nif (csr_error_bits) {\r\nupa_writeq(csr, csr_reg);\r\nif (csr_error_bits & SCHIZO_PCICTRL_BUS_UNUS)\r\nprintk("%s: Bus unusable error asserted.\n",\r\npbm->name);\r\nif (csr_error_bits & SCHIZO_PCICTRL_TTO_ERR)\r\nprintk("%s: PCI TRDY# timeout error asserted.\n",\r\npbm->name);\r\nif (csr_error_bits & SCHIZO_PCICTRL_RTRY_ERR)\r\nprintk("%s: PCI excessive retry error asserted.\n",\r\npbm->name);\r\nif (csr_error_bits & SCHIZO_PCICTRL_DTO_ERR)\r\nprintk("%s: PCI discard timeout error asserted.\n",\r\npbm->name);\r\nif (csr_error_bits & SCHIZO_PCICTRL_SBH_ERR)\r\nprintk("%s: PCI streaming byte hole error asserted.\n",\r\npbm->name);\r\nif (csr_error_bits & SCHIZO_PCICTRL_SERR)\r\nprintk("%s: PCI SERR signal asserted.\n",\r\npbm->name);\r\nret = IRQ_HANDLED;\r\n}\r\npbm->pci_ops->read(pbm->pci_bus, 0, PCI_STATUS, 2, &stat);\r\nif (stat & (PCI_STATUS_PARITY |\r\nPCI_STATUS_SIG_TARGET_ABORT |\r\nPCI_STATUS_REC_TARGET_ABORT |\r\nPCI_STATUS_REC_MASTER_ABORT |\r\nPCI_STATUS_SIG_SYSTEM_ERROR)) {\r\nprintk("%s: PCI bus error, PCI_STATUS[%04x]\n",\r\npbm->name, stat);\r\npbm->pci_ops->write(pbm->pci_bus, 0, PCI_STATUS, 2, 0xffff);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t schizo_pcierr_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nunsigned long afsr_reg, afar_reg, base;\r\nunsigned long afsr, afar, error_bits;\r\nint reported;\r\nbase = pbm->pbm_regs;\r\nafsr_reg = base + SCHIZO_PCI_AFSR;\r\nafar_reg = base + SCHIZO_PCI_AFAR;\r\nafar = upa_readq(afar_reg);\r\nafsr = upa_readq(afsr_reg);\r\nerror_bits = afsr &\r\n(SCHIZO_PCIAFSR_PMA | SCHIZO_PCIAFSR_PTA |\r\nSCHIZO_PCIAFSR_PRTRY | SCHIZO_PCIAFSR_PPERR |\r\nSCHIZO_PCIAFSR_PTTO | SCHIZO_PCIAFSR_PUNUS |\r\nSCHIZO_PCIAFSR_SMA | SCHIZO_PCIAFSR_STA |\r\nSCHIZO_PCIAFSR_SRTRY | SCHIZO_PCIAFSR_SPERR |\r\nSCHIZO_PCIAFSR_STTO | SCHIZO_PCIAFSR_SUNUS);\r\nif (!error_bits)\r\nreturn schizo_pcierr_intr_other(pbm);\r\nupa_writeq(error_bits, afsr_reg);\r\nprintk("%s: PCI Error, primary error type[%s]\n",\r\npbm->name,\r\n(((error_bits & SCHIZO_PCIAFSR_PMA) ?\r\n"Master Abort" :\r\n((error_bits & SCHIZO_PCIAFSR_PTA) ?\r\n"Target Abort" :\r\n((error_bits & SCHIZO_PCIAFSR_PRTRY) ?\r\n"Excessive Retries" :\r\n((error_bits & SCHIZO_PCIAFSR_PPERR) ?\r\n"Parity Error" :\r\n((error_bits & SCHIZO_PCIAFSR_PTTO) ?\r\n"Timeout" :\r\n((error_bits & SCHIZO_PCIAFSR_PUNUS) ?\r\n"Bus Unusable" : "???"))))))));\r\nprintk("%s: bytemask[%04lx] was_block(%d) space(%s)\n",\r\npbm->name,\r\n(afsr & SCHIZO_PCIAFSR_BMSK) >> 32UL,\r\n(afsr & SCHIZO_PCIAFSR_BLK) ? 1 : 0,\r\n((afsr & SCHIZO_PCIAFSR_CFG) ?\r\n"Config" :\r\n((afsr & SCHIZO_PCIAFSR_MEM) ?\r\n"Memory" :\r\n((afsr & SCHIZO_PCIAFSR_IO) ?\r\n"I/O" : "???"))));\r\nprintk("%s: PCI AFAR [%016lx]\n",\r\npbm->name, afar);\r\nprintk("%s: PCI Secondary errors [",\r\npbm->name);\r\nreported = 0;\r\nif (afsr & SCHIZO_PCIAFSR_SMA) {\r\nreported++;\r\nprintk("(Master Abort)");\r\n}\r\nif (afsr & SCHIZO_PCIAFSR_STA) {\r\nreported++;\r\nprintk("(Target Abort)");\r\n}\r\nif (afsr & SCHIZO_PCIAFSR_SRTRY) {\r\nreported++;\r\nprintk("(Excessive Retries)");\r\n}\r\nif (afsr & SCHIZO_PCIAFSR_SPERR) {\r\nreported++;\r\nprintk("(Parity Error)");\r\n}\r\nif (afsr & SCHIZO_PCIAFSR_STTO) {\r\nreported++;\r\nprintk("(Timeout)");\r\n}\r\nif (afsr & SCHIZO_PCIAFSR_SUNUS) {\r\nreported++;\r\nprintk("(Bus Unusable)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nif (error_bits & (SCHIZO_PCIAFSR_PTA | SCHIZO_PCIAFSR_STA)) {\r\nschizo_check_iommu_error(pbm, PCI_ERR);\r\npci_scan_for_target_abort(pbm, pbm->pci_bus);\r\n}\r\nif (error_bits & (SCHIZO_PCIAFSR_PMA | SCHIZO_PCIAFSR_SMA))\r\npci_scan_for_master_abort(pbm, pbm->pci_bus);\r\nif (error_bits & (SCHIZO_PCIAFSR_PPERR | SCHIZO_PCIAFSR_SPERR))\r\npci_scan_for_parity_error(pbm, pbm->pci_bus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t schizo_safarierr_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nu64 errlog;\r\nerrlog = upa_readq(pbm->controller_regs + SCHIZO_SAFARI_ERRLOG);\r\nupa_writeq(errlog & ~(SAFARI_ERRLOG_ERROUT),\r\npbm->controller_regs + SCHIZO_SAFARI_ERRLOG);\r\nif (!(errlog & BUS_ERROR_UNMAP)) {\r\nprintk("%s: Unexpected Safari/JBUS error interrupt, errlog[%016llx]\n",\r\npbm->name, errlog);\r\nreturn IRQ_HANDLED;\r\n}\r\nprintk("%s: Safari/JBUS interrupt, UNMAPPED error, interrogating IOMMUs.\n",\r\npbm->name);\r\nschizo_check_iommu_error(pbm, SAFARI_ERR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pbm_routes_this_ino(struct pci_pbm_info *pbm, u32 ino)\r\n{\r\nino &= IMAP_INO;\r\nif (pbm->ino_bitmap & (1UL << ino))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void tomatillo_register_error_handlers(struct pci_pbm_info *pbm)\r\n{\r\nstruct platform_device *op = of_find_device_by_node(pbm->op->dev.of_node);\r\nu64 tmp, err_mask, err_no_mask;\r\nint err;\r\nif (pbm_routes_this_ino(pbm, SCHIZO_UE_INO)) {\r\nerr = request_irq(op->archdata.irqs[1], schizo_ue_intr, 0,\r\n"TOMATILLO_UE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register UE, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nif (pbm_routes_this_ino(pbm, SCHIZO_CE_INO)) {\r\nerr = request_irq(op->archdata.irqs[2], schizo_ce_intr, 0,\r\n"TOMATILLO_CE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register CE, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nerr = 0;\r\nif (pbm_routes_this_ino(pbm, SCHIZO_PCIERR_A_INO)) {\r\nerr = request_irq(op->archdata.irqs[0], schizo_pcierr_intr, 0,\r\n"TOMATILLO_PCIERR", pbm);\r\n} else if (pbm_routes_this_ino(pbm, SCHIZO_PCIERR_B_INO)) {\r\nerr = request_irq(op->archdata.irqs[0], schizo_pcierr_intr, 0,\r\n"TOMATILLO_PCIERR", pbm);\r\n}\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register PCIERR, "\r\n"err=%d\n", pbm->name, err);\r\nif (pbm_routes_this_ino(pbm, SCHIZO_SERR_INO)) {\r\nerr = request_irq(op->archdata.irqs[3], schizo_safarierr_intr, 0,\r\n"TOMATILLO_SERR", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register SERR, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nupa_writeq((SCHIZO_ECCCTRL_EE |\r\nSCHIZO_ECCCTRL_UE |\r\nSCHIZO_ECCCTRL_CE), pbm->controller_regs + SCHIZO_ECC_CTRL);\r\nerr_mask = (SCHIZO_PCICTRL_BUS_UNUS |\r\nSCHIZO_PCICTRL_TTO_ERR |\r\nSCHIZO_PCICTRL_RTRY_ERR |\r\nSCHIZO_PCICTRL_SERR |\r\nSCHIZO_PCICTRL_EEN);\r\nerr_no_mask = SCHIZO_PCICTRL_DTO_ERR;\r\ntmp = upa_readq(pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\ntmp |= err_mask;\r\ntmp &= ~err_no_mask;\r\nupa_writeq(tmp, pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\nerr_mask = (SCHIZO_PCIAFSR_PMA | SCHIZO_PCIAFSR_PTA |\r\nSCHIZO_PCIAFSR_PRTRY | SCHIZO_PCIAFSR_PPERR |\r\nSCHIZO_PCIAFSR_PTTO |\r\nSCHIZO_PCIAFSR_SMA | SCHIZO_PCIAFSR_STA |\r\nSCHIZO_PCIAFSR_SRTRY | SCHIZO_PCIAFSR_SPERR |\r\nSCHIZO_PCIAFSR_STTO);\r\nupa_writeq(err_mask, pbm->pbm_regs + SCHIZO_PCI_AFSR);\r\nerr_mask = (BUS_ERROR_BADCMD | BUS_ERROR_SNOOP_GR |\r\nBUS_ERROR_SNOOP_PCI | BUS_ERROR_SNOOP_RD |\r\nBUS_ERROR_SNOOP_RDS | BUS_ERROR_SNOOP_RDSA |\r\nBUS_ERROR_SNOOP_OWN | BUS_ERROR_SNOOP_RDO |\r\nBUS_ERROR_WDATA_PERR | BUS_ERROR_CTRL_PERR |\r\nBUS_ERROR_SNOOP_ERR | BUS_ERROR_JBUS_ILL_B |\r\nBUS_ERROR_JBUS_ILL_C | BUS_ERROR_RD_PERR |\r\nBUS_ERROR_APERR | BUS_ERROR_UNMAP |\r\nBUS_ERROR_BUSERR | BUS_ERROR_TIMEOUT);\r\nupa_writeq((SCHIZO_SAFERRCTRL_EN | err_mask),\r\npbm->controller_regs + SCHIZO_SAFARI_ERRCTRL);\r\nupa_writeq((SCHIZO_SAFIRQCTRL_EN | (BUS_ERROR_UNMAP)),\r\npbm->controller_regs + SCHIZO_SAFARI_IRQCTRL);\r\n}\r\nstatic void schizo_register_error_handlers(struct pci_pbm_info *pbm)\r\n{\r\nstruct platform_device *op = of_find_device_by_node(pbm->op->dev.of_node);\r\nu64 tmp, err_mask, err_no_mask;\r\nint err;\r\nif (pbm_routes_this_ino(pbm, SCHIZO_UE_INO)) {\r\nerr = request_irq(op->archdata.irqs[1], schizo_ue_intr, 0,\r\n"SCHIZO_UE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register UE, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nif (pbm_routes_this_ino(pbm, SCHIZO_CE_INO)) {\r\nerr = request_irq(op->archdata.irqs[2], schizo_ce_intr, 0,\r\n"SCHIZO_CE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register CE, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nerr = 0;\r\nif (pbm_routes_this_ino(pbm, SCHIZO_PCIERR_A_INO)) {\r\nerr = request_irq(op->archdata.irqs[0], schizo_pcierr_intr, 0,\r\n"SCHIZO_PCIERR", pbm);\r\n} else if (pbm_routes_this_ino(pbm, SCHIZO_PCIERR_B_INO)) {\r\nerr = request_irq(op->archdata.irqs[0], schizo_pcierr_intr, 0,\r\n"SCHIZO_PCIERR", pbm);\r\n}\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register PCIERR, "\r\n"err=%d\n", pbm->name, err);\r\nif (pbm_routes_this_ino(pbm, SCHIZO_SERR_INO)) {\r\nerr = request_irq(op->archdata.irqs[3], schizo_safarierr_intr, 0,\r\n"SCHIZO_SERR", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Could not register SERR, "\r\n"err=%d\n", pbm->name, err);\r\n}\r\nupa_writeq((SCHIZO_ECCCTRL_EE |\r\nSCHIZO_ECCCTRL_UE |\r\nSCHIZO_ECCCTRL_CE), pbm->controller_regs + SCHIZO_ECC_CTRL);\r\nerr_mask = (SCHIZO_PCICTRL_BUS_UNUS |\r\nSCHIZO_PCICTRL_ESLCK |\r\nSCHIZO_PCICTRL_TTO_ERR |\r\nSCHIZO_PCICTRL_RTRY_ERR |\r\nSCHIZO_PCICTRL_SBH_ERR |\r\nSCHIZO_PCICTRL_SERR |\r\nSCHIZO_PCICTRL_EEN);\r\nerr_no_mask = (SCHIZO_PCICTRL_DTO_ERR |\r\nSCHIZO_PCICTRL_SBH_INT);\r\ntmp = upa_readq(pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\ntmp |= err_mask;\r\ntmp &= ~err_no_mask;\r\nupa_writeq(tmp, pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\nupa_writeq((SCHIZO_PCIAFSR_PMA | SCHIZO_PCIAFSR_PTA |\r\nSCHIZO_PCIAFSR_PRTRY | SCHIZO_PCIAFSR_PPERR |\r\nSCHIZO_PCIAFSR_PTTO | SCHIZO_PCIAFSR_PUNUS |\r\nSCHIZO_PCIAFSR_SMA | SCHIZO_PCIAFSR_STA |\r\nSCHIZO_PCIAFSR_SRTRY | SCHIZO_PCIAFSR_SPERR |\r\nSCHIZO_PCIAFSR_STTO | SCHIZO_PCIAFSR_SUNUS),\r\npbm->pbm_regs + SCHIZO_PCI_AFSR);\r\nerr_mask = (BUS_ERROR_BADCMD | BUS_ERROR_SSMDIS |\r\nBUS_ERROR_BADMA | BUS_ERROR_BADMB |\r\nBUS_ERROR_BADMC |\r\nBUS_ERROR_CPU1PS | BUS_ERROR_CPU1PB |\r\nBUS_ERROR_CPU0PS | BUS_ERROR_CPU0PB |\r\nBUS_ERROR_CIQTO |\r\nBUS_ERROR_LPQTO | BUS_ERROR_SFPQTO |\r\nBUS_ERROR_UFPQTO | BUS_ERROR_APERR |\r\nBUS_ERROR_BUSERR | BUS_ERROR_TIMEOUT |\r\nBUS_ERROR_ILL);\r\n#if 1\r\nerr_mask &= ~(BUS_ERROR_CPU1PS | BUS_ERROR_CPU1PB |\r\nBUS_ERROR_CPU0PS | BUS_ERROR_CPU0PB);\r\n#endif\r\nupa_writeq((SCHIZO_SAFERRCTRL_EN | err_mask),\r\npbm->controller_regs + SCHIZO_SAFARI_ERRCTRL);\r\n}\r\nstatic void pbm_config_busmastering(struct pci_pbm_info *pbm)\r\n{\r\nu8 *addr;\r\naddr = schizo_pci_config_mkaddr(pbm, pbm->pci_first_busno,\r\n0, PCI_CACHE_LINE_SIZE);\r\npci_config_write8(addr, 64 / sizeof(u32));\r\naddr = schizo_pci_config_mkaddr(pbm, pbm->pci_first_busno,\r\n0, PCI_LATENCY_TIMER);\r\npci_config_write8(addr, 64);\r\n}\r\nstatic void schizo_scan_bus(struct pci_pbm_info *pbm, struct device *parent)\r\n{\r\npbm_config_busmastering(pbm);\r\npbm->is_66mhz_capable =\r\n(of_find_property(pbm->op->dev.of_node, "66mhz-capable", NULL)\r\n!= NULL);\r\npbm->pci_bus = pci_scan_one_pbm(pbm, parent);\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO)\r\ntomatillo_register_error_handlers(pbm);\r\nelse\r\nschizo_register_error_handlers(pbm);\r\n}\r\nstatic void schizo_pbm_strbuf_init(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long base = pbm->pbm_regs;\r\nu64 control;\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO) {\r\nreturn;\r\n}\r\npbm->stc.strbuf_control = base + SCHIZO_STRBUF_CONTROL;\r\npbm->stc.strbuf_pflush = base + SCHIZO_STRBUF_FLUSH;\r\npbm->stc.strbuf_fsync = base + SCHIZO_STRBUF_FSYNC;\r\npbm->stc.strbuf_ctxflush = base + SCHIZO_STRBUF_CTXFLUSH;\r\npbm->stc.strbuf_ctxmatch_base = base + SCHIZO_STRBUF_CTXMATCH;\r\npbm->stc.strbuf_flushflag = (volatile unsigned long *)\r\n((((unsigned long)&pbm->stc.__flushflag_buf[0])\r\n+ 63UL)\r\n& ~63UL);\r\npbm->stc.strbuf_flushflag_pa = (unsigned long)\r\n__pa(pbm->stc.strbuf_flushflag);\r\ncontrol = upa_readq(pbm->stc.strbuf_control);\r\ncontrol &= ~(SCHIZO_STRBUF_CTRL_LPTR |\r\nSCHIZO_STRBUF_CTRL_LENAB |\r\nSCHIZO_STRBUF_CTRL_DENAB);\r\ncontrol |= SCHIZO_STRBUF_CTRL_ENAB;\r\nupa_writeq(control, pbm->stc.strbuf_control);\r\npbm->stc.strbuf_enabled = 1;\r\n}\r\nstatic int schizo_pbm_iommu_init(struct pci_pbm_info *pbm)\r\n{\r\nstatic const u32 vdma_default[] = { 0xc0000000, 0x40000000 };\r\nunsigned long i, tagbase, database;\r\nstruct iommu *iommu = pbm->iommu;\r\nint tsbsize, err;\r\nconst u32 *vdma;\r\nu32 dma_mask;\r\nu64 control;\r\nvdma = of_get_property(pbm->op->dev.of_node, "virtual-dma", NULL);\r\nif (!vdma)\r\nvdma = vdma_default;\r\ndma_mask = vdma[0];\r\nswitch (vdma[1]) {\r\ncase 0x20000000:\r\ndma_mask |= 0x1fffffff;\r\ntsbsize = 64;\r\nbreak;\r\ncase 0x40000000:\r\ndma_mask |= 0x3fffffff;\r\ntsbsize = 128;\r\nbreak;\r\ncase 0x80000000:\r\ndma_mask |= 0x7fffffff;\r\ntsbsize = 128;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "Strange virtual-dma size.\n");\r\nreturn -EINVAL;\r\n}\r\niommu->iommu_control = pbm->pbm_regs + SCHIZO_IOMMU_CONTROL;\r\niommu->iommu_tsbbase = pbm->pbm_regs + SCHIZO_IOMMU_TSBBASE;\r\niommu->iommu_flush = pbm->pbm_regs + SCHIZO_IOMMU_FLUSH;\r\niommu->iommu_tags = iommu->iommu_flush + (0xa580UL - 0x0210UL);\r\niommu->iommu_ctxflush = pbm->pbm_regs + SCHIZO_IOMMU_CTXFLUSH;\r\niommu->write_complete_reg = pbm->controller_regs + 0x10000UL;\r\ncontrol = upa_readq(iommu->iommu_control);\r\ncontrol |= SCHIZO_IOMMU_CTRL_DENAB;\r\nupa_writeq(control, iommu->iommu_control);\r\ntagbase = SCHIZO_IOMMU_TAG, database = SCHIZO_IOMMU_DATA;\r\nfor (i = 0; i < 16; i++) {\r\nupa_writeq(0, pbm->pbm_regs + tagbase + (i * 8UL));\r\nupa_writeq(0, pbm->pbm_regs + database + (i * 8UL));\r\n}\r\nerr = iommu_table_init(iommu, tsbsize * 8 * 1024, vdma[0], dma_mask,\r\npbm->numa_node);\r\nif (err) {\r\nprintk(KERN_ERR PFX "iommu_table_init() fails with %d\n", err);\r\nreturn err;\r\n}\r\nupa_writeq(__pa(iommu->page_table), iommu->iommu_tsbbase);\r\ncontrol = upa_readq(iommu->iommu_control);\r\ncontrol &= ~(SCHIZO_IOMMU_CTRL_TSBSZ | SCHIZO_IOMMU_CTRL_TBWSZ);\r\nswitch (tsbsize) {\r\ncase 64:\r\ncontrol |= SCHIZO_IOMMU_TSBSZ_64K;\r\nbreak;\r\ncase 128:\r\ncontrol |= SCHIZO_IOMMU_TSBSZ_128K;\r\nbreak;\r\n}\r\ncontrol |= SCHIZO_IOMMU_CTRL_ENAB;\r\nupa_writeq(control, iommu->iommu_control);\r\nreturn 0;\r\n}\r\nstatic void schizo_pbm_hw_init(struct pci_pbm_info *pbm)\r\n{\r\nu64 tmp;\r\nupa_writeq(5, pbm->pbm_regs + SCHIZO_PCI_IRQ_RETRY);\r\ntmp = upa_readq(pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\ntmp |= 0xff;\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO &&\r\npbm->chip_version >= 0x2)\r\ntmp |= 0x3UL << SCHIZO_PCICTRL_PTO_SHIFT;\r\nif (!of_find_property(pbm->op->dev.of_node, "no-bus-parking", NULL))\r\ntmp |= SCHIZO_PCICTRL_PARK;\r\nelse\r\ntmp &= ~SCHIZO_PCICTRL_PARK;\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO &&\r\npbm->chip_version <= 0x1)\r\ntmp |= SCHIZO_PCICTRL_DTO_INT;\r\nelse\r\ntmp &= ~SCHIZO_PCICTRL_DTO_INT;\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO)\r\ntmp |= (SCHIZO_PCICTRL_MRM_PREF |\r\nSCHIZO_PCICTRL_RDO_PREF |\r\nSCHIZO_PCICTRL_RDL_PREF);\r\nupa_writeq(tmp, pbm->pbm_regs + SCHIZO_PCI_CTRL);\r\ntmp = upa_readq(pbm->pbm_regs + SCHIZO_PCI_DIAG);\r\ntmp &= ~(SCHIZO_PCIDIAG_D_RTRYARB |\r\nSCHIZO_PCIDIAG_D_RETRY |\r\nSCHIZO_PCIDIAG_D_INTSYNC);\r\nupa_writeq(tmp, pbm->pbm_regs + SCHIZO_PCI_DIAG);\r\nif (pbm->chip_type == PBM_CHIP_TYPE_TOMATILLO) {\r\ntmp = (TOMATILLO_IOC_PART_WPENAB |\r\n(1 << TOMATILLO_IOC_PREF_OFF_SHIFT) |\r\nTOMATILLO_IOC_RDMULT_CPENAB |\r\nTOMATILLO_IOC_RDONE_CPENAB |\r\nTOMATILLO_IOC_RDLINE_CPENAB);\r\nupa_writeq(tmp, pbm->pbm_regs + TOMATILLO_PCI_IOC_CSR);\r\n}\r\n}\r\nstatic int schizo_pbm_init(struct pci_pbm_info *pbm,\r\nstruct platform_device *op, u32 portid,\r\nint chip_type)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstruct device_node *dp = op->dev.of_node;\r\nconst char *chipset_name;\r\nint err;\r\nswitch (chip_type) {\r\ncase PBM_CHIP_TYPE_TOMATILLO:\r\nchipset_name = "TOMATILLO";\r\nbreak;\r\ncase PBM_CHIP_TYPE_SCHIZO_PLUS:\r\nchipset_name = "SCHIZO+";\r\nbreak;\r\ncase PBM_CHIP_TYPE_SCHIZO:\r\ndefault:\r\nchipset_name = "SCHIZO";\r\nbreak;\r\n}\r\nregs = of_get_property(dp, "reg", NULL);\r\npbm->next = pci_pbm_root;\r\npci_pbm_root = pbm;\r\npbm->numa_node = -1;\r\npbm->pci_ops = &sun4u_pci_ops;\r\npbm->config_space_reg_bits = 8;\r\npbm->index = pci_num_pbms++;\r\npbm->portid = portid;\r\npbm->op = op;\r\npbm->chip_type = chip_type;\r\npbm->chip_version = of_getintprop_default(dp, "version#", 0);\r\npbm->chip_revision = of_getintprop_default(dp, "module-version#", 0);\r\npbm->pbm_regs = regs[0].phys_addr;\r\npbm->controller_regs = regs[1].phys_addr - 0x10000UL;\r\nif (chip_type == PBM_CHIP_TYPE_TOMATILLO)\r\npbm->sync_reg = regs[3].phys_addr + 0x1a18UL;\r\npbm->name = dp->full_name;\r\nprintk("%s: %s PCI Bus Module ver[%x:%x]\n",\r\npbm->name, chipset_name,\r\npbm->chip_version, pbm->chip_revision);\r\nschizo_pbm_hw_init(pbm);\r\npci_determine_mem_io_space(pbm);\r\npci_get_pbm_props(pbm);\r\nerr = schizo_pbm_iommu_init(pbm);\r\nif (err)\r\nreturn err;\r\nschizo_pbm_strbuf_init(pbm);\r\nschizo_scan_bus(pbm, &op->dev);\r\nreturn 0;\r\n}\r\nstatic inline int portid_compare(u32 x, u32 y, int chip_type)\r\n{\r\nif (chip_type == PBM_CHIP_TYPE_TOMATILLO) {\r\nif (x == (y ^ 1))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nreturn (x == y);\r\n}\r\nstatic struct pci_pbm_info *schizo_find_sibling(u32 portid, int chip_type)\r\n{\r\nstruct pci_pbm_info *pbm;\r\nfor (pbm = pci_pbm_root; pbm; pbm = pbm->next) {\r\nif (portid_compare(pbm->portid, portid, chip_type))\r\nreturn pbm;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __schizo_init(struct platform_device *op, unsigned long chip_type)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct pci_pbm_info *pbm;\r\nstruct iommu *iommu;\r\nu32 portid;\r\nint err;\r\nportid = of_getintprop_default(dp, "portid", 0xff);\r\nerr = -ENOMEM;\r\npbm = kzalloc(sizeof(*pbm), GFP_KERNEL);\r\nif (!pbm) {\r\nprintk(KERN_ERR PFX "Cannot allocate pci_pbm_info.\n");\r\ngoto out_err;\r\n}\r\npbm->sibling = schizo_find_sibling(portid, chip_type);\r\niommu = kzalloc(sizeof(struct iommu), GFP_KERNEL);\r\nif (!iommu) {\r\nprintk(KERN_ERR PFX "Cannot allocate PBM A iommu.\n");\r\ngoto out_free_pbm;\r\n}\r\npbm->iommu = iommu;\r\nif (schizo_pbm_init(pbm, op, portid, chip_type))\r\ngoto out_free_iommu;\r\nif (pbm->sibling)\r\npbm->sibling->sibling = pbm;\r\ndev_set_drvdata(&op->dev, pbm);\r\nreturn 0;\r\nout_free_iommu:\r\nkfree(pbm->iommu);\r\nout_free_pbm:\r\nkfree(pbm);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int schizo_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(schizo_match, &op->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nreturn __schizo_init(op, (unsigned long)match->data);\r\n}\r\nstatic int __init schizo_init(void)\r\n{\r\nreturn platform_driver_register(&schizo_driver);\r\n}
