static inline unsigned int vpe_shift(void)\r\n{\r\nif (num_possible_cpus() > 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int vpe_shift(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned int counters_total_to_per_cpu(unsigned int counters)\r\n{\r\nreturn counters >> vpe_shift();\r\n}\r\nstatic inline unsigned int counters_per_cpu_to_total(unsigned int counters)\r\n{\r\nreturn counters << vpe_shift();\r\n}\r\nstatic void mipsxx_reg_setup(struct op_counter_config *ctr)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nint i;\r\nfor (i = 0; i < counters; i++) {\r\nreg.control[i] = 0;\r\nreg.counter[i] = 0;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nreg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |\r\nM_PERFCTL_INTERRUPT_ENABLE;\r\nif (ctr[i].kernel)\r\nreg.control[i] |= M_PERFCTL_KERNEL;\r\nif (ctr[i].user)\r\nreg.control[i] |= M_PERFCTL_USER;\r\nif (ctr[i].exl)\r\nreg.control[i] |= M_PERFCTL_EXL;\r\nif (boot_cpu_type() == CPU_XLR)\r\nreg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;\r\nreg.counter[i] = 0x80000000 - ctr[i].count;\r\n}\r\n}\r\nstatic void mipsxx_cpu_setup(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nif (oprofile_skip_cpu(smp_processor_id()))\r\nreturn;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\nw_c0_perfcntr3(reg.counter[3]);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\nw_c0_perfcntr2(reg.counter[2]);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\nw_c0_perfcntr1(reg.counter[1]);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\nw_c0_perfcntr0(reg.counter[0]);\r\n}\r\n}\r\nstatic void mipsxx_cpu_start(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nif (oprofile_skip_cpu(smp_processor_id()))\r\nreturn;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(WHAT | reg.control[3]);\r\ncase 3:\r\nw_c0_perfctrl2(WHAT | reg.control[2]);\r\ncase 2:\r\nw_c0_perfctrl1(WHAT | reg.control[1]);\r\ncase 1:\r\nw_c0_perfctrl0(WHAT | reg.control[0]);\r\n}\r\n}\r\nstatic void mipsxx_cpu_stop(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nif (oprofile_skip_cpu(smp_processor_id()))\r\nreturn;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\n}\r\n}\r\nstatic int mipsxx_perfcount_handler(void)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nunsigned int control;\r\nunsigned int counter;\r\nint handled = IRQ_NONE;\r\nif (cpu_has_mips_r2 && !(read_c0_cause() & CAUSEF_PCI))\r\nreturn handled;\r\nswitch (counters) {\r\n#define HANDLE_COUNTER(n) \\r\ncase n + 1: \\r\ncontrol = r_c0_perfctrl ## n(); \\r\ncounter = r_c0_perfcntr ## n(); \\r\nif ((control & M_PERFCTL_INTERRUPT_ENABLE) && \\r\n(counter & M_COUNTER_OVERFLOW)) { \\r\noprofile_add_sample(get_irq_regs(), n); \\r\nw_c0_perfcntr ## n(reg.counter[n]); \\r\nhandled = IRQ_HANDLED; \\r\n}\r\nHANDLE_COUNTER(3)\r\nHANDLE_COUNTER(2)\r\nHANDLE_COUNTER(1)\r\nHANDLE_COUNTER(0)\r\n}\r\nreturn handled;\r\n}\r\nstatic inline int __n_counters(void)\r\n{\r\nif (!cpu_has_perf)\r\nreturn 0;\r\nif (!(read_c0_perfctrl0() & M_PERFCTL_MORE))\r\nreturn 1;\r\nif (!(read_c0_perfctrl1() & M_PERFCTL_MORE))\r\nreturn 2;\r\nif (!(read_c0_perfctrl2() & M_PERFCTL_MORE))\r\nreturn 3;\r\nreturn 4;\r\n}\r\nstatic inline int n_counters(void)\r\n{\r\nint counters;\r\nswitch (current_cpu_type()) {\r\ncase CPU_R10000:\r\ncounters = 2;\r\nbreak;\r\ncase CPU_R12000:\r\ncase CPU_R14000:\r\ncase CPU_R16000:\r\ncounters = 4;\r\nbreak;\r\ndefault:\r\ncounters = __n_counters();\r\n}\r\nreturn counters;\r\n}\r\nstatic void reset_counters(void *arg)\r\n{\r\nint counters = (int)(long)arg;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\nw_c0_perfcntr3(0);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\nw_c0_perfcntr2(0);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\nw_c0_perfcntr1(0);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\nw_c0_perfcntr0(0);\r\n}\r\n}\r\nstatic irqreturn_t mipsxx_perfcount_int(int irq, void *dev_id)\r\n{\r\nreturn mipsxx_perfcount_handler();\r\n}\r\nstatic int __init mipsxx_init(void)\r\n{\r\nint counters;\r\ncounters = n_counters();\r\nif (counters == 0) {\r\nprintk(KERN_ERR "Oprofile: CPU has no performance counters\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_MIPS_MT_SMP\r\ncpu_has_mipsmt_pertccounters = read_c0_config7() & (1<<19);\r\nif (!cpu_has_mipsmt_pertccounters)\r\ncounters = counters_total_to_per_cpu(counters);\r\n#endif\r\non_each_cpu(reset_counters, (void *)(long)counters, 1);\r\nop_model_mipsxx_ops.num_counters = counters;\r\nswitch (current_cpu_type()) {\r\ncase CPU_M14KC:\r\nop_model_mipsxx_ops.cpu_type = "mips/M14Kc";\r\nbreak;\r\ncase CPU_M14KEC:\r\nop_model_mipsxx_ops.cpu_type = "mips/M14KEc";\r\nbreak;\r\ncase CPU_20KC:\r\nop_model_mipsxx_ops.cpu_type = "mips/20K";\r\nbreak;\r\ncase CPU_24K:\r\nop_model_mipsxx_ops.cpu_type = "mips/24K";\r\nbreak;\r\ncase CPU_25KF:\r\nop_model_mipsxx_ops.cpu_type = "mips/25K";\r\nbreak;\r\ncase CPU_1004K:\r\ncase CPU_34K:\r\nop_model_mipsxx_ops.cpu_type = "mips/34K";\r\nbreak;\r\ncase CPU_1074K:\r\ncase CPU_74K:\r\nop_model_mipsxx_ops.cpu_type = "mips/74K";\r\nbreak;\r\ncase CPU_INTERAPTIV:\r\nop_model_mipsxx_ops.cpu_type = "mips/interAptiv";\r\nbreak;\r\ncase CPU_PROAPTIV:\r\nop_model_mipsxx_ops.cpu_type = "mips/proAptiv";\r\nbreak;\r\ncase CPU_P5600:\r\nop_model_mipsxx_ops.cpu_type = "mips/P5600";\r\nbreak;\r\ncase CPU_I6400:\r\nop_model_mipsxx_ops.cpu_type = "mips/I6400";\r\nbreak;\r\ncase CPU_M5150:\r\nop_model_mipsxx_ops.cpu_type = "mips/M5150";\r\nbreak;\r\ncase CPU_5KC:\r\nop_model_mipsxx_ops.cpu_type = "mips/5K";\r\nbreak;\r\ncase CPU_R10000:\r\nif ((current_cpu_data.processor_id & 0xff) == 0x20)\r\nop_model_mipsxx_ops.cpu_type = "mips/r10000-v2.x";\r\nelse\r\nop_model_mipsxx_ops.cpu_type = "mips/r10000";\r\nbreak;\r\ncase CPU_R12000:\r\ncase CPU_R14000:\r\nop_model_mipsxx_ops.cpu_type = "mips/r12000";\r\nbreak;\r\ncase CPU_R16000:\r\nop_model_mipsxx_ops.cpu_type = "mips/r16000";\r\nbreak;\r\ncase CPU_SB1:\r\ncase CPU_SB1A:\r\nop_model_mipsxx_ops.cpu_type = "mips/sb1";\r\nbreak;\r\ncase CPU_LOONGSON1:\r\nop_model_mipsxx_ops.cpu_type = "mips/loongson1";\r\nbreak;\r\ncase CPU_XLR:\r\nop_model_mipsxx_ops.cpu_type = "mips/xlr";\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Profiling unsupported for this CPU\n");\r\nreturn -ENODEV;\r\n}\r\nsave_perf_irq = perf_irq;\r\nperf_irq = mipsxx_perfcount_handler;\r\nif (get_c0_perfcount_int)\r\nperfcount_irq = get_c0_perfcount_int();\r\nelse if (cp0_perfcount_irq >= 0)\r\nperfcount_irq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;\r\nelse\r\nperfcount_irq = -1;\r\nif (perfcount_irq >= 0)\r\nreturn request_irq(perfcount_irq, mipsxx_perfcount_int,\r\nIRQF_PERCPU | IRQF_NOBALANCING |\r\nIRQF_NO_THREAD | IRQF_NO_SUSPEND |\r\nIRQF_SHARED,\r\n"Perfcounter", save_perf_irq);\r\nreturn 0;\r\n}\r\nstatic void mipsxx_exit(void)\r\n{\r\nint counters = op_model_mipsxx_ops.num_counters;\r\nif (perfcount_irq >= 0)\r\nfree_irq(perfcount_irq, save_perf_irq);\r\ncounters = counters_per_cpu_to_total(counters);\r\non_each_cpu(reset_counters, (void *)(long)counters, 1);\r\nperf_irq = save_perf_irq;\r\n}
