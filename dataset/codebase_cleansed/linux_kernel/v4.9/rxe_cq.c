int rxe_cq_chk_attr(struct rxe_dev *rxe, struct rxe_cq *cq,\r\nint cqe, int comp_vector, struct ib_udata *udata)\r\n{\r\nint count;\r\nif (cqe <= 0) {\r\npr_warn("cqe(%d) <= 0\n", cqe);\r\ngoto err1;\r\n}\r\nif (cqe > rxe->attr.max_cqe) {\r\npr_warn("cqe(%d) > max_cqe(%d)\n",\r\ncqe, rxe->attr.max_cqe);\r\ngoto err1;\r\n}\r\nif (cq) {\r\ncount = queue_count(cq->queue);\r\nif (cqe < count) {\r\npr_warn("cqe(%d) < current # elements in queue (%d)",\r\ncqe, count);\r\ngoto err1;\r\n}\r\n}\r\nreturn 0;\r\nerr1:\r\nreturn -EINVAL;\r\n}\r\nstatic void rxe_send_complete(unsigned long data)\r\n{\r\nstruct rxe_cq *cq = (struct rxe_cq *)data;\r\ncq->ibcq.comp_handler(&cq->ibcq, cq->ibcq.cq_context);\r\n}\r\nint rxe_cq_from_init(struct rxe_dev *rxe, struct rxe_cq *cq, int cqe,\r\nint comp_vector, struct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nint err;\r\ncq->queue = rxe_queue_init(rxe, &cqe,\r\nsizeof(struct rxe_cqe));\r\nif (!cq->queue) {\r\npr_warn("unable to create cq\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = do_mmap_info(rxe, udata, false, context, cq->queue->buf,\r\ncq->queue->buf_size, &cq->queue->ip);\r\nif (err) {\r\nkvfree(cq->queue->buf);\r\nkfree(cq->queue);\r\nreturn err;\r\n}\r\nif (udata)\r\ncq->is_user = 1;\r\ntasklet_init(&cq->comp_task, rxe_send_complete, (unsigned long)cq);\r\nspin_lock_init(&cq->cq_lock);\r\ncq->ibcq.cqe = cqe;\r\nreturn 0;\r\n}\r\nint rxe_cq_resize_queue(struct rxe_cq *cq, int cqe, struct ib_udata *udata)\r\n{\r\nint err;\r\nerr = rxe_queue_resize(cq->queue, (unsigned int *)&cqe,\r\nsizeof(struct rxe_cqe),\r\ncq->queue->ip ? cq->queue->ip->context : NULL,\r\nudata, NULL, &cq->cq_lock);\r\nif (!err)\r\ncq->ibcq.cqe = cqe;\r\nreturn err;\r\n}\r\nint rxe_cq_post(struct rxe_cq *cq, struct rxe_cqe *cqe, int solicited)\r\n{\r\nstruct ib_event ev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cq->cq_lock, flags);\r\nif (unlikely(queue_full(cq->queue))) {\r\nspin_unlock_irqrestore(&cq->cq_lock, flags);\r\nif (cq->ibcq.event_handler) {\r\nev.device = cq->ibcq.device;\r\nev.element.cq = &cq->ibcq;\r\nev.event = IB_EVENT_CQ_ERR;\r\ncq->ibcq.event_handler(&ev, cq->ibcq.cq_context);\r\n}\r\nreturn -EBUSY;\r\n}\r\nmemcpy(producer_addr(cq->queue), cqe, sizeof(*cqe));\r\nsmp_wmb();\r\nadvance_producer(cq->queue);\r\nspin_unlock_irqrestore(&cq->cq_lock, flags);\r\nif ((cq->notify == IB_CQ_NEXT_COMP) ||\r\n(cq->notify == IB_CQ_SOLICITED && solicited)) {\r\ncq->notify = 0;\r\ntasklet_schedule(&cq->comp_task);\r\n}\r\nreturn 0;\r\n}\r\nvoid rxe_cq_cleanup(void *arg)\r\n{\r\nstruct rxe_cq *cq = arg;\r\nif (cq->queue)\r\nrxe_queue_cleanup(cq->queue);\r\n}
