static inline int PAR_EQUAL(struct fb_par_control *x, struct fb_par_control *y)\r\n{\r\nint i, results;\r\nresults = 1;\r\nfor (i = 0; i < 3; i++)\r\nresults &= !DIRTY(regvals.clock_params[i]);\r\nif (!results)\r\nreturn 0;\r\nfor (i = 0; i < 16; i++)\r\nresults &= !DIRTY(regvals.regs[i]);\r\nif (!results)\r\nreturn 0;\r\nreturn (!DIRTY(cmode) && !DIRTY(xres) && !DIRTY(yres)\r\n&& !DIRTY(vxres) && !DIRTY(vyres));\r\n}\r\nstatic inline int VAR_MATCH(struct fb_var_screeninfo *x, struct fb_var_screeninfo *y)\r\n{\r\nreturn (!DIRTY(bits_per_pixel) && !DIRTY(xres)\r\n&& !DIRTY(yres) && !DIRTY(xres_virtual)\r\n&& !DIRTY(yres_virtual)\r\n&& !DIRTY_CMAP(red) && !DIRTY_CMAP(green) && !DIRTY_CMAP(blue));\r\n}\r\nint init_module(void)\r\n{\r\nstruct device_node *dp;\r\nint ret = -ENXIO;\r\ndp = of_find_node_by_name(NULL, "control");\r\nif (dp != 0 && !control_of_init(dp))\r\nret = 0;\r\nof_node_put(dp);\r\nreturn ret;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\ncontrol_cleanup();\r\n}\r\nstatic int controlfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct fb_par_control par;\r\nint err;\r\nerr = control_var_to_par(var, &par, info);\r\nif (err)\r\nreturn err;\r\ncontrol_par_to_var(&par, var);\r\nreturn 0;\r\n}\r\nstatic int controlfb_set_par (struct fb_info *info)\r\n{\r\nstruct fb_info_control *p =\r\ncontainer_of(info, struct fb_info_control, info);\r\nstruct fb_par_control par;\r\nint err;\r\nif((err = control_var_to_par(&info->var, &par, info))) {\r\nprintk (KERN_ERR "controlfb_set_par: error calling"\r\n" control_var_to_par: %d.\n", err);\r\nreturn err;\r\n}\r\ncontrol_set_hardware(p, &par);\r\ninfo->fix.visual = (p->par.cmode == CMODE_8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\ninfo->fix.line_length = p->par.pitch;\r\ninfo->fix.xpanstep = 32 >> p->par.cmode;\r\ninfo->fix.ypanstep = 1;\r\nreturn 0;\r\n}\r\nstatic inline void set_screen_start(int xoffset, int yoffset,\r\nstruct fb_info_control *p)\r\n{\r\nstruct fb_par_control *par = &p->par;\r\npar->xoffset = xoffset;\r\npar->yoffset = yoffset;\r\nout_le32(CNTRL_REG(p,start_addr),\r\npar->yoffset * par->pitch + (par->xoffset << par->cmode));\r\n}\r\nstatic int controlfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nunsigned int xoffset, hstep;\r\nstruct fb_info_control *p =\r\ncontainer_of(info, struct fb_info_control, info);\r\nstruct fb_par_control *par = &p->par;\r\nhstep = 0x1f >> par->cmode;\r\nxoffset = (var->xoffset + hstep) & ~hstep;\r\nif (xoffset+par->xres > par->vxres ||\r\nvar->yoffset+par->yres > par->vyres)\r\nreturn -EINVAL;\r\nset_screen_start(xoffset, var->yoffset, p);\r\nreturn 0;\r\n}\r\nstatic int controlfb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nunsigned long mmio_pgoff;\r\nunsigned long start;\r\nu32 len;\r\nstart = info->fix.smem_start;\r\nlen = info->fix.smem_len;\r\nmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\r\nif (vma->vm_pgoff >= mmio_pgoff) {\r\nif (info->var.accel_flags)\r\nreturn -EINVAL;\r\nvma->vm_pgoff -= mmio_pgoff;\r\nstart = info->fix.mmio_start;\r\nlen = info->fix.mmio_len;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\n} else {\r\nvma->vm_page_prot = pgprot_cached_wthru(vma->vm_page_prot);\r\n}\r\nreturn vm_iomap_memory(vma, start, len);\r\n}\r\nstatic int controlfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct fb_info_control *p =\r\ncontainer_of(info, struct fb_info_control, info);\r\nunsigned ctrl;\r\nctrl = le32_to_cpup(CNTRL_REG(p,ctrl));\r\nif (blank_mode > 0)\r\nswitch (blank_mode) {\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nctrl &= ~3;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nctrl &= ~0x30;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nctrl &= ~0x33;\r\ncase FB_BLANK_NORMAL:\r\nctrl |= 0x400;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nelse {\r\nctrl &= ~0x400;\r\nctrl |= 0x33;\r\n}\r\nout_le32(CNTRL_REG(p,ctrl), ctrl);\r\nreturn 0;\r\n}\r\nstatic int controlfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct fb_info_control *p =\r\ncontainer_of(info, struct fb_info_control, info);\r\n__u8 r, g, b;\r\nif (regno > 255)\r\nreturn 1;\r\nr = red >> 8;\r\ng = green >> 8;\r\nb = blue >> 8;\r\nout_8(&p->cmap_regs->addr, regno);\r\nout_8(&p->cmap_regs->lut, r);\r\nout_8(&p->cmap_regs->lut, g);\r\nout_8(&p->cmap_regs->lut, b);\r\nif (regno < 16) {\r\nint i;\r\nswitch (p->par.cmode) {\r\ncase CMODE_16:\r\np->pseudo_palette[regno] =\r\n(regno << 10) | (regno << 5) | regno;\r\nbreak;\r\ncase CMODE_32:\r\ni = (regno << 8) | regno;\r\np->pseudo_palette[regno] = (i << 16) | i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_control_clock(unsigned char *params)\r\n{\r\n#ifdef CONFIG_ADB_CUDA\r\nstruct adb_request req;\r\nint i;\r\nfor (i = 0; i < 3; ++i) {\r\ncuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,\r\n0x50, i + 1, params[i]);\r\nwhile (!req.complete)\r\ncuda_poll();\r\n}\r\n#endif\r\n}\r\nstatic int __init init_control(struct fb_info_control *p)\r\n{\r\nint full, sense, vmode, cmode, vyres;\r\nstruct fb_var_screeninfo var;\r\nint rc;\r\nprintk(KERN_INFO "controlfb: ");\r\nfull = p->total_vram == 0x400000;\r\n#ifdef CONFIG_NVRAM\r\nif (default_cmode == CMODE_NVRAM) {\r\ncmode = nvram_read_byte(NV_CMODE);\r\nif(cmode < CMODE_8 || cmode > CMODE_32)\r\ncmode = CMODE_8;\r\n} else\r\n#endif\r\ncmode=default_cmode;\r\n#ifdef CONFIG_NVRAM\r\nif (default_vmode == VMODE_NVRAM) {\r\nvmode = nvram_read_byte(NV_VMODE);\r\nif (vmode < 1 || vmode > VMODE_MAX ||\r\ncontrol_mac_modes[vmode - 1].m[full] < cmode) {\r\nsense = read_control_sense(p);\r\nprintk("Monitor sense value = 0x%x, ", sense);\r\nvmode = mac_map_monitor_sense(sense);\r\nif (control_mac_modes[vmode - 1].m[full] < cmode)\r\nvmode = VMODE_640_480_60;\r\n}\r\n} else\r\n#endif\r\n{\r\nvmode=default_vmode;\r\nif (control_mac_modes[vmode - 1].m[full] < cmode) {\r\nif (cmode > CMODE_8)\r\ncmode--;\r\nelse\r\nvmode = VMODE_640_480_60;\r\n}\r\n}\r\ncontrol_init_info(&p->info, p);\r\nif (mac_vmode_to_var(vmode, cmode, &var) < 0) {\r\nprintk("mac_vmode_to_var(%d, %d,) failed\n", vmode, cmode);\r\ntry_again:\r\nvmode = VMODE_640_480_60;\r\ncmode = CMODE_8;\r\nif (mac_vmode_to_var(vmode, cmode, &var) < 0) {\r\nprintk(KERN_ERR "controlfb: mac_vmode_to_var() failed\n");\r\nreturn -ENXIO;\r\n}\r\nprintk(KERN_INFO "controlfb: ");\r\n}\r\nprintk("using video mode %d and color mode %d.\n", vmode, cmode);\r\nvyres = (p->total_vram - CTRLFB_OFF) / (var.xres << cmode);\r\nif (vyres > var.yres)\r\nvar.yres_virtual = vyres;\r\nvar.activate = FB_ACTIVATE_NOW;\r\nrc = fb_set_var(&p->info, &var);\r\nif (rc && (vmode != VMODE_640_480_60 || cmode != CMODE_8))\r\ngoto try_again;\r\nif (register_framebuffer(&p->info) < 0)\r\nreturn -ENXIO;\r\nfb_info(&p->info, "control display adapter\n");\r\nreturn 0;\r\n}\r\nstatic void control_set_hardware(struct fb_info_control *p, struct fb_par_control *par)\r\n{\r\nstruct control_regvals *r;\r\nvolatile struct preg __iomem *rp;\r\nint i, cmode;\r\nif (PAR_EQUAL(&p->par, par)) {\r\nif (p->par.xoffset != par->xoffset ||\r\np->par.yoffset != par->yoffset)\r\nset_screen_start(par->xoffset, par->yoffset, p);\r\nreturn;\r\n}\r\np->par = *par;\r\ncmode = p->par.cmode;\r\nr = &par->regvals;\r\nout_le32(CNTRL_REG(p,ctrl), 0x400 | par->ctrl);\r\nset_control_clock(r->clock_params);\r\nRADACAL_WRITE(0x20, r->radacal_ctrl);\r\nRADACAL_WRITE(0x21, p->control_use_bank2 ? 0 : 1);\r\nRADACAL_WRITE(0x10, 0);\r\nRADACAL_WRITE(0x11, 0);\r\nrp = &p->control_regs->vswin;\r\nfor (i = 0; i < 16; ++i, ++rp)\r\nout_le32(&rp->r, r->regs[i]);\r\nout_le32(CNTRL_REG(p,pitch), par->pitch);\r\nout_le32(CNTRL_REG(p,mode), r->mode);\r\nout_le32(CNTRL_REG(p,vram_attr), p->vram_attr);\r\nout_le32(CNTRL_REG(p,start_addr), par->yoffset * par->pitch\r\n+ (par->xoffset << cmode));\r\nout_le32(CNTRL_REG(p,rfrcnt), 0x1e5);\r\nout_le32(CNTRL_REG(p,intr_ena), 0);\r\nout_le32(CNTRL_REG(p,ctrl), par->ctrl);\r\n#ifdef CONFIG_BOOTX_TEXT\r\nbtext_update_display(p->frame_buffer_phys + CTRLFB_OFF,\r\np->par.xres, p->par.yres,\r\n(cmode == CMODE_32? 32: cmode == CMODE_16? 16: 8),\r\np->par.pitch);\r\n#endif\r\n}\r\nstatic void __init control_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "vmode:", 6)) {\r\nint vmode = simple_strtoul(this_opt+6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX &&\r\ncontrol_mac_modes[vmode - 1].m[1] >= 0)\r\ndefault_vmode = vmode;\r\n} else if (!strncmp(this_opt, "cmode:", 6)) {\r\nint depth = simple_strtoul(this_opt+6, NULL, 0);\r\nswitch (depth) {\r\ncase CMODE_8:\r\ncase CMODE_16:\r\ncase CMODE_32:\r\ndefault_cmode = depth;\r\nbreak;\r\ncase 8:\r\ndefault_cmode = CMODE_8;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndefault_cmode = CMODE_16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault_cmode = CMODE_32;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init control_init(void)\r\n{\r\nstruct device_node *dp;\r\nchar *option = NULL;\r\nint ret = -ENXIO;\r\nif (fb_get_options("controlfb", &option))\r\nreturn -ENODEV;\r\ncontrol_setup(option);\r\ndp = of_find_node_by_name(NULL, "control");\r\nif (dp != 0 && !control_of_init(dp))\r\nret = 0;\r\nof_node_put(dp);\r\nreturn ret;\r\n}\r\nstatic void __init find_vram_size(struct fb_info_control *p)\r\n{\r\nint bank1, bank2;\r\nout_le32(CNTRL_REG(p,vram_attr), 0x31);\r\nout_8(&p->frame_buffer[0x600000], 0xb3);\r\nout_8(&p->frame_buffer[0x600001], 0x71);\r\nasm volatile("eieio; dcbf 0,%0" : : "r" (&p->frame_buffer[0x600000])\r\n: "memory" );\r\nmb();\r\nasm volatile("eieio; dcbi 0,%0" : : "r" (&p->frame_buffer[0x600000])\r\n: "memory" );\r\nmb();\r\nbank2 = (in_8(&p->frame_buffer[0x600000]) == 0xb3)\r\n&& (in_8(&p->frame_buffer[0x600001]) == 0x71);\r\nout_le32(CNTRL_REG(p,vram_attr), 0x39);\r\nout_8(&p->frame_buffer[0], 0x5a);\r\nout_8(&p->frame_buffer[1], 0xc7);\r\nasm volatile("eieio; dcbf 0,%0" : : "r" (&p->frame_buffer[0])\r\n: "memory" );\r\nmb();\r\nasm volatile("eieio; dcbi 0,%0" : : "r" (&p->frame_buffer[0])\r\n: "memory" );\r\nmb();\r\nbank1 = (in_8(&p->frame_buffer[0]) == 0x5a)\r\n&& (in_8(&p->frame_buffer[1]) == 0xc7);\r\nif (bank2) {\r\nif (!bank1) {\r\np->control_use_bank2 = 1;\r\np->vram_attr = 0x39;\r\np->frame_buffer += 0x600000;\r\np->frame_buffer_phys += 0x600000;\r\n} else {\r\np->vram_attr = 0x51;\r\n}\r\n} else {\r\np->vram_attr = 0x31;\r\n}\r\np->total_vram = (bank1 + bank2) * 0x200000;\r\nprintk(KERN_INFO "controlfb: VRAM Total = %dMB "\r\n"(%dMB @ bank 1, %dMB @ bank 2)\n",\r\n(bank1 + bank2) << 1, bank1 << 1, bank2 << 1);\r\n}\r\nstatic int __init control_of_init(struct device_node *dp)\r\n{\r\nstruct fb_info_control *p;\r\nstruct resource fb_res, reg_res;\r\nif (control_fb) {\r\nprintk(KERN_ERR "controlfb: only one control is supported\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_pci_address_to_resource(dp, 2, &fb_res) ||\r\nof_pci_address_to_resource(dp, 1, &reg_res)) {\r\nprintk(KERN_ERR "can't get 2 addresses for control\n");\r\nreturn -ENXIO;\r\n}\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == 0)\r\nreturn -ENXIO;\r\ncontrol_fb = p;\r\np->fb_orig_base = fb_res.start;\r\np->fb_orig_size = resource_size(&fb_res);\r\np->frame_buffer_phys = fb_res.start + 0x800000;\r\np->control_regs_phys = reg_res.start;\r\np->control_regs_size = resource_size(&reg_res);\r\nif (!p->fb_orig_base ||\r\n!request_mem_region(p->fb_orig_base,p->fb_orig_size,"controlfb")) {\r\np->fb_orig_base = 0;\r\ngoto error_out;\r\n}\r\np->frame_buffer = __ioremap(p->frame_buffer_phys, 0x800000,\r\n_PAGE_WRITETHRU);\r\nif (!p->control_regs_phys ||\r\n!request_mem_region(p->control_regs_phys, p->control_regs_size,\r\n"controlfb regs")) {\r\np->control_regs_phys = 0;\r\ngoto error_out;\r\n}\r\np->control_regs = ioremap(p->control_regs_phys, p->control_regs_size);\r\np->cmap_regs_phys = 0xf301b000;\r\nif (!request_mem_region(p->cmap_regs_phys, 0x1000, "controlfb cmap")) {\r\np->cmap_regs_phys = 0;\r\ngoto error_out;\r\n}\r\np->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);\r\nif (!p->cmap_regs || !p->control_regs || !p->frame_buffer)\r\ngoto error_out;\r\nfind_vram_size(p);\r\nif (!p->total_vram)\r\ngoto error_out;\r\nif (init_control(p) < 0)\r\ngoto error_out;\r\nreturn 0;\r\nerror_out:\r\ncontrol_cleanup();\r\nreturn -ENXIO;\r\n}\r\nstatic int read_control_sense(struct fb_info_control *p)\r\n{\r\nint sense;\r\nout_le32(CNTRL_REG(p,mon_sense), 7);\r\n__delay(200);\r\nout_le32(CNTRL_REG(p,mon_sense), 077);\r\n__delay(2000);\r\nsense = (in_le32(CNTRL_REG(p,mon_sense)) & 0x1c0) << 2;\r\nout_le32(CNTRL_REG(p,mon_sense), 033);\r\n__delay(2000);\r\nsense |= (in_le32(CNTRL_REG(p,mon_sense)) & 0xc0) >> 2;\r\nout_le32(CNTRL_REG(p,mon_sense), 055);\r\n__delay(2000);\r\nsense |= ((in_le32(CNTRL_REG(p,mon_sense)) & 0x100) >> 5)\r\n| ((in_le32(CNTRL_REG(p,mon_sense)) & 0x40) >> 4);\r\nout_le32(CNTRL_REG(p,mon_sense), 066);\r\n__delay(2000);\r\nsense |= (in_le32(CNTRL_REG(p,mon_sense)) & 0x180) >> 7;\r\nout_le32(CNTRL_REG(p,mon_sense), 077);\r\nreturn sense;\r\n}\r\nstatic int calc_clock_params(unsigned long clk, unsigned char *param)\r\n{\r\nunsigned long p0, p1, p2, k, l, m, n, min;\r\nif (clk > (CONTROL_PIXCLOCK_BASE << 3))\r\nreturn 1;\r\np2 = ((clk << 4) < CONTROL_PIXCLOCK_BASE)? 3: 2;\r\nl = clk << p2;\r\np0 = 0;\r\np1 = 0;\r\nfor (k = 1, min = l; k < 32; k++) {\r\nunsigned long rem;\r\nm = CONTROL_PIXCLOCK_BASE * k;\r\nn = m / l;\r\nrem = m % l;\r\nif (n && (n < 128) && rem < min) {\r\np0 = k;\r\np1 = n;\r\nmin = rem;\r\n}\r\n}\r\nif (!p0 || !p1)\r\nreturn 1;\r\nparam[0] = p0;\r\nparam[1] = p1;\r\nparam[2] = p2;\r\nreturn 0;\r\n}\r\nstatic int control_var_to_par(struct fb_var_screeninfo *var,\r\nstruct fb_par_control *par, const struct fb_info *fb_info)\r\n{\r\nint cmode, piped_diff, hstep;\r\nunsigned hperiod, hssync, hsblank, hesync, heblank, piped, heq, hlfln,\r\nhserr, vperiod, vssync, vesync, veblank, vsblank, vswin, vewin;\r\nunsigned long pixclock;\r\nstruct fb_info_control *p =\r\ncontainer_of(fb_info, struct fb_info_control, info);\r\nstruct control_regvals *r = &par->regvals;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\npar->cmode = CMODE_8;\r\nif (p->total_vram > 0x200000) {\r\nr->mode = 3;\r\nr->radacal_ctrl = 0x20;\r\npiped_diff = 13;\r\n} else {\r\nr->mode = 2;\r\nr->radacal_ctrl = 0x10;\r\npiped_diff = 9;\r\n}\r\nbreak;\r\ncase 15:\r\ncase 16:\r\npar->cmode = CMODE_16;\r\nif (p->total_vram > 0x200000) {\r\nr->mode = 2;\r\nr->radacal_ctrl = 0x24;\r\npiped_diff = 5;\r\n} else {\r\nr->mode = 1;\r\nr->radacal_ctrl = 0x14;\r\npiped_diff = 3;\r\n}\r\nbreak;\r\ncase 32:\r\npar->cmode = CMODE_32;\r\nif (p->total_vram > 0x200000) {\r\nr->mode = 1;\r\nr->radacal_ctrl = 0x28;\r\n} else {\r\nr->mode = 0;\r\nr->radacal_ctrl = 0x18;\r\n}\r\npiped_diff = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhstep = 31 >> par->cmode;\r\npar->xres = (var->xres + hstep) & ~hstep;\r\npar->vxres = (var->xres_virtual + hstep) & ~hstep;\r\npar->xoffset = (var->xoffset + hstep) & ~hstep;\r\nif (par->vxres < par->xres)\r\npar->vxres = par->xres;\r\npar->pitch = par->vxres << par->cmode;\r\npar->yres = var->yres;\r\npar->vyres = var->yres_virtual;\r\npar->yoffset = var->yoffset;\r\nif (par->vyres < par->yres)\r\npar->vyres = par->yres;\r\npar->sync = var->sync;\r\nif (par->pitch * par->vyres + CTRLFB_OFF > p->total_vram)\r\nreturn -EINVAL;\r\nif (par->xoffset + par->xres > par->vxres)\r\npar->xoffset = par->vxres - par->xres;\r\nif (par->yoffset + par->yres > par->vyres)\r\npar->yoffset = par->vyres - par->yres;\r\npixclock = (var->pixclock < CONTROL_PIXCLOCK_MIN)? CONTROL_PIXCLOCK_MIN:\r\nvar->pixclock;\r\nif (calc_clock_params(pixclock, r->clock_params))\r\nreturn -EINVAL;\r\nhperiod = ((var->left_margin + par->xres + var->right_margin\r\n+ var->hsync_len) >> 1) - 2;\r\nhssync = hperiod + 1;\r\nhsblank = hssync - (var->right_margin >> 1);\r\nhesync = (var->hsync_len >> 1) - 1;\r\nheblank = (var->left_margin >> 1) + hesync;\r\npiped = heblank - piped_diff;\r\nheq = var->hsync_len >> 2;\r\nhlfln = (hperiod+2) >> 1;\r\nhserr = hssync-hesync;\r\nvperiod = (var->vsync_len + var->lower_margin + par->yres\r\n+ var->upper_margin) << 1;\r\nvssync = vperiod - 2;\r\nvesync = (var->vsync_len << 1) - vperiod + vssync;\r\nveblank = (var->upper_margin << 1) + vesync;\r\nvsblank = vssync - (var->lower_margin << 1);\r\nvswin = (vsblank+vssync) >> 1;\r\nvewin = (vesync+veblank) >> 1;\r\nr->regs[0] = vswin;\r\nr->regs[1] = vsblank;\r\nr->regs[2] = veblank;\r\nr->regs[3] = vewin;\r\nr->regs[4] = vesync;\r\nr->regs[5] = vssync;\r\nr->regs[6] = vperiod;\r\nr->regs[7] = piped;\r\nr->regs[8] = hperiod;\r\nr->regs[9] = hsblank;\r\nr->regs[10] = heblank;\r\nr->regs[11] = hesync;\r\nr->regs[12] = hssync;\r\nr->regs[13] = heq;\r\nr->regs[14] = hlfln;\r\nr->regs[15] = hserr;\r\nif (par->xres >= 1280 && par->cmode >= CMODE_16)\r\npar->ctrl = 0x7f;\r\nelse\r\npar->ctrl = 0x3b;\r\nif (mac_var_to_vmode(var, &par->vmode, &cmode))\r\npar->vmode = 0;\r\nreturn 0;\r\n}\r\nstatic void control_par_to_var(struct fb_par_control *par, struct fb_var_screeninfo *var)\r\n{\r\nstruct control_regints *rv;\r\nrv = (struct control_regints *) par->regvals.regs;\r\nmemset(var, 0, sizeof(*var));\r\nvar->xres = par->xres;\r\nvar->yres = par->yres;\r\nvar->xres_virtual = par->vxres;\r\nvar->yres_virtual = par->vyres;\r\nvar->xoffset = par->xoffset;\r\nvar->yoffset = par->yoffset;\r\nswitch(par->cmode) {\r\ndefault:\r\ncase CMODE_8:\r\nvar->bits_per_pixel = 8;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase CMODE_16:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase CMODE_32:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->left_margin = (rv->heblank - rv->hesync) << 1;\r\nvar->right_margin = (rv->hssync - rv->hsblank) << 1;\r\nvar->hsync_len = (rv->hperiod + 2 - rv->hssync + rv->hesync) << 1;\r\nvar->upper_margin = (rv->veblank - rv->vesync) >> 1;\r\nvar->lower_margin = (rv->vssync - rv->vsblank) >> 1;\r\nvar->vsync_len = (rv->vperiod - rv->vssync + rv->vesync) >> 1;\r\nvar->sync = par->sync;\r\nvar->pixclock = CONTROL_PIXCLOCK_BASE * par->regvals.clock_params[0];\r\nvar->pixclock /= par->regvals.clock_params[1];\r\nvar->pixclock >>= par->regvals.clock_params[2];\r\n}\r\nstatic void __init control_init_info(struct fb_info *info, struct fb_info_control *p)\r\n{\r\ninfo->par = &p->par;\r\ninfo->fbops = &controlfb_ops;\r\ninfo->pseudo_palette = p->pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\ninfo->screen_base = p->frame_buffer + CTRLFB_OFF;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\nstrcpy(info->fix.id, "control");\r\ninfo->fix.mmio_start = p->control_regs_phys;\r\ninfo->fix.mmio_len = sizeof(struct control_regs);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.smem_start = p->frame_buffer_phys + CTRLFB_OFF;\r\ninfo->fix.smem_len = p->total_vram - CTRLFB_OFF;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\n}\r\nstatic void control_cleanup(void)\r\n{\r\nstruct fb_info_control *p = control_fb;\r\nif (!p)\r\nreturn;\r\nif (p->cmap_regs)\r\niounmap(p->cmap_regs);\r\nif (p->control_regs)\r\niounmap(p->control_regs);\r\nif (p->frame_buffer) {\r\nif (p->control_use_bank2)\r\np->frame_buffer -= 0x600000;\r\niounmap(p->frame_buffer);\r\n}\r\nif (p->cmap_regs_phys)\r\nrelease_mem_region(p->cmap_regs_phys, 0x1000);\r\nif (p->control_regs_phys)\r\nrelease_mem_region(p->control_regs_phys, p->control_regs_size);\r\nif (p->fb_orig_base)\r\nrelease_mem_region(p->fb_orig_base, p->fb_orig_size);\r\nkfree(p);\r\n}
