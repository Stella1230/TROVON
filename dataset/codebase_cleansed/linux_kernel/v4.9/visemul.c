static inline void maybe_flush_windows(unsigned int rs1, unsigned int rs2,\r\nunsigned int rd, int from_kernel)\r\n{\r\nif (rs2 >= 16 || rs1 >= 16 || rd >= 16) {\r\nif (from_kernel != 0)\r\n__asm__ __volatile__("flushw");\r\nelse\r\nflushw_user();\r\n}\r\n}\r\nstatic unsigned long fetch_reg(unsigned int reg, struct pt_regs *regs)\r\n{\r\nunsigned long value, fp;\r\nif (reg < 16)\r\nreturn (!reg ? 0 : regs->u_regs[reg]);\r\nfp = regs->u_regs[UREG_FP];\r\nif (regs->tstate & TSTATE_PRIV) {\r\nstruct reg_window *win;\r\nwin = (struct reg_window *)(fp + STACK_BIAS);\r\nvalue = win->locals[reg - 16];\r\n} else if (!test_thread_64bit_stack(fp)) {\r\nstruct reg_window32 __user *win32;\r\nwin32 = (struct reg_window32 __user *)((unsigned long)((u32)fp));\r\nget_user(value, &win32->locals[reg - 16]);\r\n} else {\r\nstruct reg_window __user *win;\r\nwin = (struct reg_window __user *)(fp + STACK_BIAS);\r\nget_user(value, &win->locals[reg - 16]);\r\n}\r\nreturn value;\r\n}\r\nstatic inline unsigned long __user *__fetch_reg_addr_user(unsigned int reg,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long fp = regs->u_regs[UREG_FP];\r\nBUG_ON(reg < 16);\r\nBUG_ON(regs->tstate & TSTATE_PRIV);\r\nif (!test_thread_64bit_stack(fp)) {\r\nstruct reg_window32 __user *win32;\r\nwin32 = (struct reg_window32 __user *)((unsigned long)((u32)fp));\r\nreturn (unsigned long __user *)&win32->locals[reg - 16];\r\n} else {\r\nstruct reg_window __user *win;\r\nwin = (struct reg_window __user *)(fp + STACK_BIAS);\r\nreturn &win->locals[reg - 16];\r\n}\r\n}\r\nstatic inline unsigned long *__fetch_reg_addr_kern(unsigned int reg,\r\nstruct pt_regs *regs)\r\n{\r\nBUG_ON(reg >= 16);\r\nBUG_ON(regs->tstate & TSTATE_PRIV);\r\nreturn &regs->u_regs[reg];\r\n}\r\nstatic void store_reg(struct pt_regs *regs, unsigned long val, unsigned long rd)\r\n{\r\nif (rd < 16) {\r\nunsigned long *rd_kern = __fetch_reg_addr_kern(rd, regs);\r\n*rd_kern = val;\r\n} else {\r\nunsigned long __user *rd_user = __fetch_reg_addr_user(rd, regs);\r\nif (!test_thread_64bit_stack(regs->u_regs[UREG_FP]))\r\n__put_user((u32)val, (u32 __user *)rd_user);\r\nelse\r\n__put_user(val, rd_user);\r\n}\r\n}\r\nstatic inline unsigned long fpd_regval(struct fpustate *f,\r\nunsigned int insn_regnum)\r\n{\r\ninsn_regnum = (((insn_regnum & 1) << 5) |\r\n(insn_regnum & 0x1e));\r\nreturn *(unsigned long *) &f->regs[insn_regnum];\r\n}\r\nstatic inline unsigned long *fpd_regaddr(struct fpustate *f,\r\nunsigned int insn_regnum)\r\n{\r\ninsn_regnum = (((insn_regnum & 1) << 5) |\r\n(insn_regnum & 0x1e));\r\nreturn (unsigned long *) &f->regs[insn_regnum];\r\n}\r\nstatic inline unsigned int fps_regval(struct fpustate *f,\r\nunsigned int insn_regnum)\r\n{\r\nreturn f->regs[insn_regnum];\r\n}\r\nstatic inline unsigned int *fps_regaddr(struct fpustate *f,\r\nunsigned int insn_regnum)\r\n{\r\nreturn &f->regs[insn_regnum];\r\n}\r\nstatic void edge(struct pt_regs *regs, unsigned int insn, unsigned int opf)\r\n{\r\nunsigned long orig_rs1, rs1, orig_rs2, rs2, rd_val;\r\nu16 left, right;\r\nmaybe_flush_windows(RS1(insn), RS2(insn), RD(insn), 0);\r\norig_rs1 = rs1 = fetch_reg(RS1(insn), regs);\r\norig_rs2 = rs2 = fetch_reg(RS2(insn), regs);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nrs1 = rs1 & 0xffffffff;\r\nrs2 = rs2 & 0xffffffff;\r\n}\r\nswitch (opf) {\r\ndefault:\r\ncase EDGE8_OPF:\r\ncase EDGE8N_OPF:\r\nleft = edge8_tab[rs1 & 0x7].left;\r\nright = edge8_tab[rs2 & 0x7].right;\r\nbreak;\r\ncase EDGE8L_OPF:\r\ncase EDGE8LN_OPF:\r\nleft = edge8_tab_l[rs1 & 0x7].left;\r\nright = edge8_tab_l[rs2 & 0x7].right;\r\nbreak;\r\ncase EDGE16_OPF:\r\ncase EDGE16N_OPF:\r\nleft = edge16_tab[(rs1 >> 1) & 0x3].left;\r\nright = edge16_tab[(rs2 >> 1) & 0x3].right;\r\nbreak;\r\ncase EDGE16L_OPF:\r\ncase EDGE16LN_OPF:\r\nleft = edge16_tab_l[(rs1 >> 1) & 0x3].left;\r\nright = edge16_tab_l[(rs2 >> 1) & 0x3].right;\r\nbreak;\r\ncase EDGE32_OPF:\r\ncase EDGE32N_OPF:\r\nleft = edge32_tab[(rs1 >> 2) & 0x1].left;\r\nright = edge32_tab[(rs2 >> 2) & 0x1].right;\r\nbreak;\r\ncase EDGE32L_OPF:\r\ncase EDGE32LN_OPF:\r\nleft = edge32_tab_l[(rs1 >> 2) & 0x1].left;\r\nright = edge32_tab_l[(rs2 >> 2) & 0x1].right;\r\nbreak;\r\n}\r\nif ((rs1 & ~0x7UL) == (rs2 & ~0x7UL))\r\nrd_val = right & left;\r\nelse\r\nrd_val = left;\r\nstore_reg(regs, rd_val, RD(insn));\r\nswitch (opf) {\r\ncase EDGE8_OPF:\r\ncase EDGE8L_OPF:\r\ncase EDGE16_OPF:\r\ncase EDGE16L_OPF:\r\ncase EDGE32_OPF:\r\ncase EDGE32L_OPF: {\r\nunsigned long ccr, tstate;\r\n__asm__ __volatile__("subcc %1, %2, %%g0\n\t"\r\n"rd %%ccr, %0"\r\n: "=r" (ccr)\r\n: "r" (orig_rs1), "r" (orig_rs2)\r\n: "cc");\r\ntstate = regs->tstate & ~(TSTATE_XCC | TSTATE_ICC);\r\nregs->tstate = tstate | (ccr << 32UL);\r\n}\r\n}\r\n}\r\nstatic void array(struct pt_regs *regs, unsigned int insn, unsigned int opf)\r\n{\r\nunsigned long rs1, rs2, rd_val;\r\nunsigned int bits, bits_mask;\r\nmaybe_flush_windows(RS1(insn), RS2(insn), RD(insn), 0);\r\nrs1 = fetch_reg(RS1(insn), regs);\r\nrs2 = fetch_reg(RS2(insn), regs);\r\nbits = (rs2 > 5 ? 5 : rs2);\r\nbits_mask = (1UL << bits) - 1UL;\r\nrd_val = ((((rs1 >> 11) & 0x3) << 0) |\r\n(((rs1 >> 33) & 0x3) << 2) |\r\n(((rs1 >> 55) & 0x1) << 4) |\r\n(((rs1 >> 13) & 0xf) << 5) |\r\n(((rs1 >> 35) & 0xf) << 9) |\r\n(((rs1 >> 56) & 0xf) << 13) |\r\n(((rs1 >> 17) & bits_mask) << 17) |\r\n(((rs1 >> 39) & bits_mask) << (17 + bits)) |\r\n(((rs1 >> 60) & 0xf) << (17 + (2*bits))));\r\nswitch (opf) {\r\ncase ARRAY16_OPF:\r\nrd_val <<= 1;\r\nbreak;\r\ncase ARRAY32_OPF:\r\nrd_val <<= 2;\r\n}\r\nstore_reg(regs, rd_val, RD(insn));\r\n}\r\nstatic void bmask(struct pt_regs *regs, unsigned int insn)\r\n{\r\nunsigned long rs1, rs2, rd_val, gsr;\r\nmaybe_flush_windows(RS1(insn), RS2(insn), RD(insn), 0);\r\nrs1 = fetch_reg(RS1(insn), regs);\r\nrs2 = fetch_reg(RS2(insn), regs);\r\nrd_val = rs1 + rs2;\r\nstore_reg(regs, rd_val, RD(insn));\r\ngsr = current_thread_info()->gsr[0] & 0xffffffff;\r\ngsr |= rd_val << 32UL;\r\ncurrent_thread_info()->gsr[0] = gsr;\r\n}\r\nstatic void bshuffle(struct pt_regs *regs, unsigned int insn)\r\n{\r\nstruct fpustate *f = FPUSTATE;\r\nunsigned long rs1, rs2, rd_val;\r\nunsigned long bmask, i;\r\nbmask = current_thread_info()->gsr[0] >> 32UL;\r\nrs1 = fpd_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0UL;\r\nfor (i = 0; i < 8; i++) {\r\nunsigned long which = (bmask >> (i * 4)) & 0xf;\r\nunsigned long byte;\r\nif (which < 8)\r\nbyte = (rs1 >> (which * 8)) & 0xff;\r\nelse\r\nbyte = (rs2 >> ((which-8)*8)) & 0xff;\r\nrd_val |= (byte << (i * 8));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\n}\r\nstatic void pdist(struct pt_regs *regs, unsigned int insn)\r\n{\r\nstruct fpustate *f = FPUSTATE;\r\nunsigned long rs1, rs2, *rd, rd_val;\r\nunsigned long i;\r\nrs1 = fpd_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd = fpd_regaddr(f, RD(insn));\r\nrd_val = *rd;\r\nfor (i = 0; i < 8; i++) {\r\ns16 s1, s2;\r\ns1 = (rs1 >> (56 - (i * 8))) & 0xff;\r\ns2 = (rs2 >> (56 - (i * 8))) & 0xff;\r\ns1 -= s2;\r\nif (s1 < 0)\r\ns1 = ~s1 + 1;\r\nrd_val += s1;\r\n}\r\n*rd = rd_val;\r\n}\r\nstatic void pformat(struct pt_regs *regs, unsigned int insn, unsigned int opf)\r\n{\r\nstruct fpustate *f = FPUSTATE;\r\nunsigned long rs1, rs2, gsr, scale, rd_val;\r\ngsr = current_thread_info()->gsr[0];\r\nscale = (gsr >> 3) & (opf == FPACK16_OPF ? 0xf : 0x1f);\r\nswitch (opf) {\r\ncase FPACK16_OPF: {\r\nunsigned long byte;\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0;\r\nfor (byte = 0; byte < 4; byte++) {\r\nunsigned int val;\r\ns16 src = (rs2 >> (byte * 16UL)) & 0xffffUL;\r\nint scaled = src << scale;\r\nint from_fixed = scaled >> 7;\r\nval = ((from_fixed < 0) ?\r\n0 :\r\n(from_fixed > 255) ?\r\n255 : from_fixed);\r\nrd_val |= (val << (8 * byte));\r\n}\r\n*fps_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FPACK32_OPF: {\r\nunsigned long word;\r\nrs1 = fpd_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = (rs1 << 8) & ~(0x000000ff000000ffUL);\r\nfor (word = 0; word < 2; word++) {\r\nunsigned long val;\r\ns32 src = (rs2 >> (word * 32UL));\r\ns64 scaled = src << scale;\r\ns64 from_fixed = scaled >> 23;\r\nval = ((from_fixed < 0) ?\r\n0 :\r\n(from_fixed > 255) ?\r\n255 : from_fixed);\r\nrd_val |= (val << (32 * word));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FPACKFIX_OPF: {\r\nunsigned long word;\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0;\r\nfor (word = 0; word < 2; word++) {\r\nlong val;\r\ns32 src = (rs2 >> (word * 32UL));\r\ns64 scaled = src << scale;\r\ns64 from_fixed = scaled >> 16;\r\nval = ((from_fixed < -32768) ?\r\n-32768 :\r\n(from_fixed > 32767) ?\r\n32767 : from_fixed);\r\nrd_val |= ((val & 0xffff) << (word * 16));\r\n}\r\n*fps_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FEXPAND_OPF: {\r\nunsigned long byte;\r\nrs2 = fps_regval(f, RS2(insn));\r\nrd_val = 0;\r\nfor (byte = 0; byte < 4; byte++) {\r\nunsigned long val;\r\nu8 src = (rs2 >> (byte * 8)) & 0xff;\r\nval = src << 4;\r\nrd_val |= (val << (byte * 16));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FPMERGE_OPF: {\r\nrs1 = fps_regval(f, RS1(insn));\r\nrs2 = fps_regval(f, RS2(insn));\r\nrd_val = (((rs2 & 0x000000ff) << 0) |\r\n((rs1 & 0x000000ff) << 8) |\r\n((rs2 & 0x0000ff00) << 8) |\r\n((rs1 & 0x0000ff00) << 16) |\r\n((rs2 & 0x00ff0000) << 16) |\r\n((rs1 & 0x00ff0000) << 24) |\r\n((rs2 & 0xff000000) << 24) |\r\n((rs1 & 0xff000000) << 32));\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pmul(struct pt_regs *regs, unsigned int insn, unsigned int opf)\r\n{\r\nstruct fpustate *f = FPUSTATE;\r\nunsigned long rs1, rs2, rd_val;\r\nswitch (opf) {\r\ncase FMUL8x16_OPF: {\r\nunsigned long byte;\r\nrs1 = fps_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0;\r\nfor (byte = 0; byte < 4; byte++) {\r\nu16 src1 = (rs1 >> (byte * 8)) & 0x00ff;\r\ns16 src2 = (rs2 >> (byte * 16)) & 0xffff;\r\nu32 prod = src1 * src2;\r\nu16 scaled = ((prod & 0x00ffff00) >> 8);\r\nif (prod & 0x80)\r\nscaled++;\r\nrd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FMUL8x16AU_OPF:\r\ncase FMUL8x16AL_OPF: {\r\nunsigned long byte;\r\ns16 src2;\r\nrs1 = fps_regval(f, RS1(insn));\r\nrs2 = fps_regval(f, RS2(insn));\r\nrd_val = 0;\r\nsrc2 = rs2 >> (opf == FMUL8x16AU_OPF ? 16 : 0);\r\nfor (byte = 0; byte < 4; byte++) {\r\nu16 src1 = (rs1 >> (byte * 8)) & 0x00ff;\r\nu32 prod = src1 * src2;\r\nu16 scaled = ((prod & 0x00ffff00) >> 8);\r\nif (prod & 0x80)\r\nscaled++;\r\nrd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FMUL8SUx16_OPF:\r\ncase FMUL8ULx16_OPF: {\r\nunsigned long byte, ushift;\r\nrs1 = fpd_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0;\r\nushift = (opf == FMUL8SUx16_OPF) ? 8 : 0;\r\nfor (byte = 0; byte < 4; byte++) {\r\nu16 src1;\r\ns16 src2;\r\nu32 prod;\r\nu16 scaled;\r\nsrc1 = ((rs1 >> ((16 * byte) + ushift)) & 0x00ff);\r\nsrc2 = ((rs2 >> (16 * byte)) & 0xffff);\r\nprod = src1 * src2;\r\nscaled = ((prod & 0x00ffff00) >> 8);\r\nif (prod & 0x80)\r\nscaled++;\r\nrd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\ncase FMULD8SUx16_OPF:\r\ncase FMULD8ULx16_OPF: {\r\nunsigned long byte, ushift;\r\nrs1 = fps_regval(f, RS1(insn));\r\nrs2 = fps_regval(f, RS2(insn));\r\nrd_val = 0;\r\nushift = (opf == FMULD8SUx16_OPF) ? 8 : 0;\r\nfor (byte = 0; byte < 2; byte++) {\r\nu16 src1;\r\ns16 src2;\r\nu32 prod;\r\nu16 scaled;\r\nsrc1 = ((rs1 >> ((16 * byte) + ushift)) & 0x00ff);\r\nsrc2 = ((rs2 >> (16 * byte)) & 0xffff);\r\nprod = src1 * src2;\r\nscaled = ((prod & 0x00ffff00) >> 8);\r\nif (prod & 0x80)\r\nscaled++;\r\nrd_val |= ((scaled & 0xffffUL) <<\r\n((byte * 32UL) + 7UL));\r\n}\r\n*fpd_regaddr(f, RD(insn)) = rd_val;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pcmp(struct pt_regs *regs, unsigned int insn, unsigned int opf)\r\n{\r\nstruct fpustate *f = FPUSTATE;\r\nunsigned long rs1, rs2, rd_val, i;\r\nrs1 = fpd_regval(f, RS1(insn));\r\nrs2 = fpd_regval(f, RS2(insn));\r\nrd_val = 0;\r\nswitch (opf) {\r\ncase FCMPGT16_OPF:\r\nfor (i = 0; i < 4; i++) {\r\ns16 a = (rs1 >> (i * 16)) & 0xffff;\r\ns16 b = (rs2 >> (i * 16)) & 0xffff;\r\nif (a > b)\r\nrd_val |= 8 >> i;\r\n}\r\nbreak;\r\ncase FCMPGT32_OPF:\r\nfor (i = 0; i < 2; i++) {\r\ns32 a = (rs1 >> (i * 32)) & 0xffffffff;\r\ns32 b = (rs2 >> (i * 32)) & 0xffffffff;\r\nif (a > b)\r\nrd_val |= 2 >> i;\r\n}\r\nbreak;\r\ncase FCMPLE16_OPF:\r\nfor (i = 0; i < 4; i++) {\r\ns16 a = (rs1 >> (i * 16)) & 0xffff;\r\ns16 b = (rs2 >> (i * 16)) & 0xffff;\r\nif (a <= b)\r\nrd_val |= 8 >> i;\r\n}\r\nbreak;\r\ncase FCMPLE32_OPF:\r\nfor (i = 0; i < 2; i++) {\r\ns32 a = (rs1 >> (i * 32)) & 0xffffffff;\r\ns32 b = (rs2 >> (i * 32)) & 0xffffffff;\r\nif (a <= b)\r\nrd_val |= 2 >> i;\r\n}\r\nbreak;\r\ncase FCMPNE16_OPF:\r\nfor (i = 0; i < 4; i++) {\r\ns16 a = (rs1 >> (i * 16)) & 0xffff;\r\ns16 b = (rs2 >> (i * 16)) & 0xffff;\r\nif (a != b)\r\nrd_val |= 8 >> i;\r\n}\r\nbreak;\r\ncase FCMPNE32_OPF:\r\nfor (i = 0; i < 2; i++) {\r\ns32 a = (rs1 >> (i * 32)) & 0xffffffff;\r\ns32 b = (rs2 >> (i * 32)) & 0xffffffff;\r\nif (a != b)\r\nrd_val |= 2 >> i;\r\n}\r\nbreak;\r\ncase FCMPEQ16_OPF:\r\nfor (i = 0; i < 4; i++) {\r\ns16 a = (rs1 >> (i * 16)) & 0xffff;\r\ns16 b = (rs2 >> (i * 16)) & 0xffff;\r\nif (a == b)\r\nrd_val |= 8 >> i;\r\n}\r\nbreak;\r\ncase FCMPEQ32_OPF:\r\nfor (i = 0; i < 2; i++) {\r\ns32 a = (rs1 >> (i * 32)) & 0xffffffff;\r\ns32 b = (rs2 >> (i * 32)) & 0xffffffff;\r\nif (a == b)\r\nrd_val |= 2 >> i;\r\n}\r\nbreak;\r\n}\r\nmaybe_flush_windows(0, 0, RD(insn), 0);\r\nstore_reg(regs, rd_val, RD(insn));\r\n}\r\nint vis_emul(struct pt_regs *regs, unsigned int insn)\r\n{\r\nunsigned long pc = regs->tpc;\r\nunsigned int opf;\r\nBUG_ON(regs->tstate & TSTATE_PRIV);\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\r\nif (test_thread_flag(TIF_32BIT))\r\npc = (u32)pc;\r\nif (get_user(insn, (u32 __user *) pc))\r\nreturn -EFAULT;\r\nsave_and_clear_fpu();\r\nopf = (insn & VIS_OPF_MASK) >> VIS_OPF_SHIFT;\r\nswitch (opf) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase FPACK16_OPF:\r\ncase FPACK32_OPF:\r\ncase FPACKFIX_OPF:\r\ncase FEXPAND_OPF:\r\ncase FPMERGE_OPF:\r\npformat(regs, insn, opf);\r\nbreak;\r\ncase FMUL8x16_OPF:\r\ncase FMUL8x16AU_OPF:\r\ncase FMUL8x16AL_OPF:\r\ncase FMUL8SUx16_OPF:\r\ncase FMUL8ULx16_OPF:\r\ncase FMULD8SUx16_OPF:\r\ncase FMULD8ULx16_OPF:\r\npmul(regs, insn, opf);\r\nbreak;\r\ncase FCMPGT16_OPF:\r\ncase FCMPGT32_OPF:\r\ncase FCMPLE16_OPF:\r\ncase FCMPLE32_OPF:\r\ncase FCMPNE16_OPF:\r\ncase FCMPNE32_OPF:\r\ncase FCMPEQ16_OPF:\r\ncase FCMPEQ32_OPF:\r\npcmp(regs, insn, opf);\r\nbreak;\r\ncase EDGE8_OPF:\r\ncase EDGE8N_OPF:\r\ncase EDGE8L_OPF:\r\ncase EDGE8LN_OPF:\r\ncase EDGE16_OPF:\r\ncase EDGE16N_OPF:\r\ncase EDGE16L_OPF:\r\ncase EDGE16LN_OPF:\r\ncase EDGE32_OPF:\r\ncase EDGE32N_OPF:\r\ncase EDGE32L_OPF:\r\ncase EDGE32LN_OPF:\r\nedge(regs, insn, opf);\r\nbreak;\r\ncase PDIST_OPF:\r\npdist(regs, insn);\r\nbreak;\r\ncase ARRAY8_OPF:\r\ncase ARRAY16_OPF:\r\ncase ARRAY32_OPF:\r\narray(regs, insn, opf);\r\nbreak;\r\ncase BMASK_OPF:\r\nbmask(regs, insn);\r\nbreak;\r\ncase BSHUFFLE_OPF:\r\nbshuffle(regs, insn);\r\nbreak;\r\n}\r\nregs->tpc = regs->tnpc;\r\nregs->tnpc += 4;\r\nreturn 0;\r\n}
