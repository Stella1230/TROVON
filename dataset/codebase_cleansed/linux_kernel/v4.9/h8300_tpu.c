static inline unsigned long read_tcnt32(struct tpu_priv *p)\r\n{\r\nunsigned long tcnt;\r\ntcnt = ioread16be(p->mapbase1 + TCNT) << 16;\r\ntcnt |= ioread16be(p->mapbase2 + TCNT);\r\nreturn tcnt;\r\n}\r\nstatic int tpu_get_counter(struct tpu_priv *p, unsigned long long *val)\r\n{\r\nunsigned long v1, v2, v3;\r\nint o1, o2;\r\no1 = ioread8(p->mapbase1 + TSR) & TCFV;\r\ndo {\r\no2 = o1;\r\nv1 = read_tcnt32(p);\r\nv2 = read_tcnt32(p);\r\nv3 = read_tcnt32(p);\r\no1 = ioread8(p->mapbase1 + TSR) & TCFV;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\n*val = v2;\r\nreturn o1;\r\n}\r\nstatic inline struct tpu_priv *cs_to_priv(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct tpu_priv, cs);\r\n}\r\nstatic cycle_t tpu_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nunsigned long flags;\r\nunsigned long long value;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nif (tpu_get_counter(p, &value))\r\nvalue += 0x100000000;\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn value;\r\n}\r\nstatic int tpu_clocksource_enable(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nWARN_ON(p->cs_enabled);\r\niowrite16be(0, p->mapbase1 + TCNT);\r\niowrite16be(0, p->mapbase2 + TCNT);\r\niowrite8(0x0f, p->mapbase1 + TCR);\r\niowrite8(0x03, p->mapbase2 + TCR);\r\np->cs_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void tpu_clocksource_disable(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nWARN_ON(!p->cs_enabled);\r\niowrite8(0, p->mapbase1 + TCR);\r\niowrite8(0, p->mapbase2 + TCR);\r\np->cs_enabled = false;\r\n}\r\nstatic int __init h8300_tpu_init(struct device_node *node)\r\n{\r\nvoid __iomem *base[2];\r\nstruct clk *clk;\r\nint ret = -ENXIO;\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("failed to get clock for clocksource\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nbase[CH_L] = of_iomap(node, CH_L);\r\nif (!base[CH_L]) {\r\npr_err("failed to map registers for clocksource\n");\r\ngoto free_clk;\r\n}\r\nbase[CH_H] = of_iomap(node, CH_H);\r\nif (!base[CH_H]) {\r\npr_err("failed to map registers for clocksource\n");\r\ngoto unmap_L;\r\n}\r\ntpu_priv.mapbase1 = base[CH_L];\r\ntpu_priv.mapbase2 = base[CH_H];\r\nreturn clocksource_register_hz(&tpu_priv.cs, clk_get_rate(clk) / 64);\r\nunmap_L:\r\niounmap(base[CH_H]);\r\nfree_clk:\r\nclk_put(clk);\r\nreturn ret;\r\n}
