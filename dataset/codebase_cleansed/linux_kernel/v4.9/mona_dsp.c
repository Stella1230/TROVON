static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\r\n{\r\nint err;\r\nif (snd_BUG_ON((subdevice_id & 0xfff0) != MONA))\r\nreturn -ENODEV;\r\nif ((err = init_dsp_comm_page(chip))) {\r\ndev_err(chip->card->dev,\r\n"init_hw - could not initialize DSP comm page\n");\r\nreturn err;\r\n}\r\nchip->device_id = device_id;\r\nchip->subdevice_id = subdevice_id;\r\nchip->bad_board = true;\r\nchip->input_clock_types =\r\nECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\r\nECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_ADAT;\r\nchip->digital_modes =\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL |\r\nECHOCAPS_HAS_DIGITAL_MODE_ADAT;\r\nif (chip->device_id == DEVICE_ID_56361)\r\nchip->dsp_code_to_load = FW_MONA_361_DSP;\r\nelse\r\nchip->dsp_code_to_load = FW_MONA_301_DSP;\r\nif ((err = load_firmware(chip)) < 0)\r\nreturn err;\r\nchip->bad_board = false;\r\nreturn err;\r\n}\r\nstatic int set_mixer_defaults(struct echoaudio *chip)\r\n{\r\nchip->digital_mode = DIGITAL_MODE_SPDIF_RCA;\r\nchip->professional_spdif = false;\r\nchip->digital_in_automute = true;\r\nreturn init_line_levels(chip);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_ADAT)\r\nclock_bits |= ECHO_CLOCK_BIT_ADAT;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD)\r\nclock_bits |= ECHO_CLOCK_BIT_WORD;\r\nreturn clock_bits;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nu32 control_reg;\r\nint err;\r\nshort asic;\r\nif (chip->asic_loaded)\r\nreturn 0;\r\nmdelay(10);\r\nif (chip->device_id == DEVICE_ID_56361)\r\nasic = FW_MONA_361_1_ASIC48;\r\nelse\r\nasic = FW_MONA_301_1_ASIC48;\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC, asic);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = asic;\r\nmdelay(10);\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_EXTERNAL_ASIC,\r\nFW_MONA_2_ASIC);\r\nif (err < 0)\r\nreturn err;\r\nmdelay(10);\r\nerr = check_asic_status(chip);\r\nif (!err) {\r\ncontrol_reg = GML_CONVERTER_ENABLE | GML_48KHZ;\r\nerr = write_control_reg(chip, control_reg, true);\r\n}\r\nreturn err;\r\n}\r\nstatic int switch_asic(struct echoaudio *chip, char double_speed)\r\n{\r\nint err;\r\nshort asic;\r\nif (chip->device_id == DEVICE_ID_56361) {\r\nif (double_speed)\r\nasic = FW_MONA_361_1_ASIC96;\r\nelse\r\nasic = FW_MONA_361_1_ASIC48;\r\n} else {\r\nif (double_speed)\r\nasic = FW_MONA_301_1_ASIC96;\r\nelse\r\nasic = FW_MONA_301_1_ASIC48;\r\n}\r\nif (asic != chip->asic_code) {\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC,\r\nasic);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = asic;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nu32 control_reg, clock;\r\nshort asic;\r\nchar force_write;\r\nif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\r\ndev_dbg(chip->card->dev,\r\n"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\n");\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nreturn 0;\r\n}\r\nif (rate >= 88200) {\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nreturn -EINVAL;\r\nif (chip->device_id == DEVICE_ID_56361)\r\nasic = FW_MONA_361_1_ASIC96;\r\nelse\r\nasic = FW_MONA_301_1_ASIC96;\r\n} else {\r\nif (chip->device_id == DEVICE_ID_56361)\r\nasic = FW_MONA_361_1_ASIC48;\r\nelse\r\nasic = FW_MONA_301_1_ASIC48;\r\n}\r\nforce_write = 0;\r\nif (asic != chip->asic_code) {\r\nint err;\r\nspin_unlock_irq(&chip->lock);\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC,\r\nasic);\r\nspin_lock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = asic;\r\nforce_write = 1;\r\n}\r\nclock = 0;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_CLOCK_CLEAR_MASK;\r\ncontrol_reg &= GML_SPDIF_RATE_CLEAR_MASK;\r\nswitch (rate) {\r\ncase 96000:\r\nclock = GML_96KHZ;\r\nbreak;\r\ncase 88200:\r\nclock = GML_88KHZ;\r\nbreak;\r\ncase 48000:\r\nclock = GML_48KHZ | GML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 44100:\r\nclock = GML_44KHZ;\r\nif (control_reg & GML_SPDIF_PRO_MODE)\r\nclock |= GML_SPDIF_SAMPLE_RATE0;\r\nbreak;\r\ncase 32000:\r\nclock = GML_32KHZ | GML_SPDIF_SAMPLE_RATE0 |\r\nGML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 22050:\r\nclock = GML_22KHZ;\r\nbreak;\r\ncase 16000:\r\nclock = GML_16KHZ;\r\nbreak;\r\ncase 11025:\r\nclock = GML_11KHZ;\r\nbreak;\r\ncase 8000:\r\nclock = GML_8KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"set_sample_rate: %d invalid!\n", rate);\r\nreturn -EINVAL;\r\n}\r\ncontrol_reg |= clock;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\ndev_dbg(chip->card->dev,\r\n"set_sample_rate: %d clock %d\n", rate, clock);\r\nreturn write_control_reg(chip, control_reg, force_write);\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\r\n{\r\nu32 control_reg, clocks_from_dsp;\r\nint err;\r\nif (atomic_read(&chip->opencount))\r\nreturn -EAGAIN;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\r\nGML_CLOCK_CLEAR_MASK;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nswitch (clock) {\r\ncase ECHO_CLOCK_INTERNAL:\r\nchip->input_clock = ECHO_CLOCK_INTERNAL;\r\nreturn set_sample_rate(chip, chip->sample_rate);\r\ncase ECHO_CLOCK_SPDIF:\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\nspin_unlock_irq(&chip->lock);\r\nerr = switch_asic(chip, clocks_from_dsp &\r\nGML_CLOCK_DETECT_BIT_SPDIF96);\r\nspin_lock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\ncontrol_reg |= GML_SPDIF_CLOCK;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF96)\r\ncontrol_reg |= GML_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_WORD:\r\nspin_unlock_irq(&chip->lock);\r\nerr = switch_asic(chip, clocks_from_dsp &\r\nGML_CLOCK_DETECT_BIT_WORD96);\r\nspin_lock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\ncontrol_reg |= GML_WORD_CLOCK;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD96)\r\ncontrol_reg |= GML_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ADAT:\r\ndev_dbg(chip->card->dev, "Set Mona clock to ADAT\n");\r\nif (chip->digital_mode != DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\ncontrol_reg |= GML_ADAT_CLOCK;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Input clock 0x%x not supported for Mona\n", clock);\r\nreturn -EINVAL;\r\n}\r\nchip->input_clock = clock;\r\nreturn write_control_reg(chip, control_reg, true);\r\n}\r\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu32 control_reg;\r\nint err, incompatible_clock;\r\nincompatible_clock = false;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nif (chip->input_clock == ECHO_CLOCK_ADAT)\r\nincompatible_clock = true;\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (chip->input_clock == ECHO_CLOCK_SPDIF)\r\nincompatible_clock = true;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Digital mode not supported: %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&chip->lock);\r\nif (incompatible_clock) {\r\nchip->sample_rate = 48000;\r\nset_input_clock(chip, ECHO_CLOCK_INTERNAL);\r\n}\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_DIGITAL_MODE_CLEAR_MASK;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncontrol_reg |= GML_SPDIF_OPTICAL_MODE;\r\nbreak;\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (chip->asic_code == FW_MONA_361_1_ASIC96 ||\r\nchip->asic_code == FW_MONA_301_1_ASIC96) {\r\nset_sample_rate(chip, 48000);\r\n}\r\ncontrol_reg |= GML_ADAT_MODE;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\n}\r\nerr = write_control_reg(chip, control_reg, false);\r\nspin_unlock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\nchip->digital_mode = mode;\r\ndev_dbg(chip->card->dev, "set_digital_mode to %d\n", mode);\r\nreturn incompatible_clock;\r\n}
