static inline unsigned int leon_eirq_get(int cpu)\r\n{\r\nreturn LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->intid[cpu]) & 0x1f;\r\n}\r\nstatic void leon_handle_ext_irq(struct irq_desc *desc)\r\n{\r\nunsigned int eirq;\r\nstruct irq_bucket *p;\r\nint cpu = sparc_leon3_cpuid();\r\neirq = leon_eirq_get(cpu);\r\np = irq_map[eirq];\r\nif ((eirq & 0x10) && p && p->irq)\r\ngeneric_handle_irq(p->irq);\r\n}\r\nstatic void leon_eirq_setup(unsigned int eirq)\r\n{\r\nunsigned long mask, oldmask;\r\nunsigned int veirq;\r\nif (eirq < 1 || eirq > 0xf) {\r\nprintk(KERN_ERR "LEON EXT IRQ NUMBER BAD: %d\n", eirq);\r\nreturn;\r\n}\r\nveirq = leon_build_device_irq(eirq, leon_handle_ext_irq, "extirq", 0);\r\nirq_link(veirq);\r\nmask = 1 << eirq;\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(boot_cpu_id));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(boot_cpu_id), (oldmask | mask));\r\nsparc_leon_eirq = eirq;\r\n}\r\nunsigned long leon_get_irqmask(unsigned int irq)\r\n{\r\nunsigned long mask;\r\nif (!irq || ((irq > 0xf) && !sparc_leon_eirq)\r\n|| ((irq > 0x1f) && sparc_leon_eirq)) {\r\nprintk(KERN_ERR\r\n"leon_get_irqmask: false irq number: %d\n", irq);\r\nmask = 0;\r\n} else {\r\nmask = LEON_HARD_INT(irq);\r\n}\r\nreturn mask;\r\n}\r\nstatic int irq_choose_cpu(const struct cpumask *affinity)\r\n{\r\ncpumask_t mask;\r\ncpumask_and(&mask, cpu_online_mask, affinity);\r\nif (cpumask_equal(&mask, cpu_online_mask) || cpumask_empty(&mask))\r\nreturn boot_cpu_id;\r\nelse\r\nreturn cpumask_first(&mask);\r\n}\r\nstatic int leon_set_affinity(struct irq_data *data, const struct cpumask *dest,\r\nbool force)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint oldcpu, newcpu;\r\nmask = (unsigned long)data->chip_data;\r\noldcpu = irq_choose_cpu(irq_data_get_affinity_mask(data));\r\nnewcpu = irq_choose_cpu(dest);\r\nif (oldcpu == newcpu)\r\ngoto out;\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(oldcpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(oldcpu), (oldmask & ~mask));\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(newcpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(newcpu), (oldmask | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\nout:\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void leon_unmask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint cpu;\r\nmask = (unsigned long)data->chip_data;\r\ncpu = irq_choose_cpu(irq_data_get_affinity_mask(data));\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(cpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(cpu), (oldmask | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nstatic void leon_mask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint cpu;\r\nmask = (unsigned long)data->chip_data;\r\ncpu = irq_choose_cpu(irq_data_get_affinity_mask(data));\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(cpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(cpu), (oldmask & ~mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nstatic unsigned int leon_startup_irq(struct irq_data *data)\r\n{\r\nirq_link(data->irq);\r\nleon_unmask_irq(data);\r\nreturn 0;\r\n}\r\nstatic void leon_shutdown_irq(struct irq_data *data)\r\n{\r\nleon_mask_irq(data);\r\nirq_unlink(data->irq);\r\n}\r\nstatic void leon_eoi_irq(struct irq_data *data)\r\n{\r\nunsigned long mask = (unsigned long)data->chip_data;\r\nif (mask & LEON_DO_ACK_HW)\r\nLEON3_BYPASS_STORE_PA(LEON_IACK, mask & ~LEON_DO_ACK_HW);\r\n}\r\nunsigned int leon_build_device_irq(unsigned int real_irq,\r\nirq_flow_handler_t flow_handler,\r\nconst char *name, int do_ack)\r\n{\r\nunsigned int irq;\r\nunsigned long mask;\r\nstruct irq_desc *desc;\r\nirq = 0;\r\nmask = leon_get_irqmask(real_irq);\r\nif (mask == 0)\r\ngoto out;\r\nirq = irq_alloc(real_irq, real_irq);\r\nif (irq == 0)\r\ngoto out;\r\nif (do_ack)\r\nmask |= LEON_DO_ACK_HW;\r\ndesc = irq_to_desc(irq);\r\nif (!desc || !desc->handle_irq || desc->handle_irq == handle_bad_irq) {\r\nirq_set_chip_and_handler_name(irq, &leon_irq,\r\nflow_handler, name);\r\nirq_set_chip_data(irq, (void *)mask);\r\n}\r\nout:\r\nreturn irq;\r\n}\r\nstatic unsigned int _leon_build_device_irq(struct platform_device *op,\r\nunsigned int real_irq)\r\n{\r\nreturn leon_build_device_irq(real_irq, handle_simple_irq, "edge", 0);\r\n}\r\nvoid leon_update_virq_handling(unsigned int virq,\r\nirq_flow_handler_t flow_handler,\r\nconst char *name, int do_ack)\r\n{\r\nunsigned long mask = (unsigned long)irq_get_chip_data(virq);\r\nmask &= ~LEON_DO_ACK_HW;\r\nif (do_ack)\r\nmask |= LEON_DO_ACK_HW;\r\nirq_set_chip_and_handler_name(virq, &leon_irq,\r\nflow_handler, name);\r\nirq_set_chip_data(virq, (void *)mask);\r\n}\r\nstatic u32 leon_cycles_offset(void)\r\n{\r\nu32 rld, val, ctrl, off;\r\nrld = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].rld);\r\nval = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].val);\r\nctrl = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl);\r\nif (LEON3_GPTIMER_CTRL_ISPENDING(ctrl)) {\r\nval = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].val);\r\noff = 2 * rld - val;\r\n} else {\r\noff = rld - val;\r\n}\r\nreturn off;\r\n}\r\nstatic irqreturn_t leon_percpu_timer_ce_interrupt(int irq, void *unused)\r\n{\r\nstruct clock_event_device *ce;\r\nint cpu = smp_processor_id();\r\nleon_clear_profile_irq(cpu);\r\nif (cpu == boot_cpu_id)\r\ntimer_interrupt(irq, NULL);\r\nce = &per_cpu(sparc32_clockevent, cpu);\r\nirq_enter();\r\nif (ce->event_handler)\r\nce->event_handler(ce);\r\nirq_exit();\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init leon_init_timers(void)\r\n{\r\nint irq, eirq;\r\nstruct device_node *rootnp, *np, *nnp;\r\nstruct property *pp;\r\nint len;\r\nint icsel;\r\nint ampopts;\r\nint err;\r\nu32 config;\r\nu32 ctrl;\r\nsparc_config.get_cycles_offset = leon_cycles_offset;\r\nsparc_config.cs_period = 1000000 / HZ;\r\nsparc_config.features |= FEAT_L10_CLOCKSOURCE;\r\n#ifndef CONFIG_SMP\r\nsparc_config.features |= FEAT_L10_CLOCKEVENT;\r\n#endif\r\nleondebug_irq_disable = 0;\r\nleon_debug_irqout = 0;\r\nmaster_l10_counter = (u32 __iomem *)&dummy_master_l10_counter;\r\ndummy_master_l10_counter = 0;\r\nrootnp = of_find_node_by_path("/ambapp0");\r\nif (!rootnp)\r\ngoto bad;\r\npp = of_find_property(rootnp, "systemid", &len);\r\nif (pp)\r\namba_system_id = *(unsigned long *)pp->value;\r\nnp = of_find_node_by_name(rootnp, "GAISLER_IRQMP");\r\nif (!np) {\r\nnp = of_find_node_by_name(rootnp, "01_00d");\r\nif (!np)\r\ngoto bad;\r\n}\r\npp = of_find_property(np, "reg", &len);\r\nif (!pp)\r\ngoto bad;\r\nleon3_irqctrl_regs = *(struct leon3_irqctrl_regs_map **)pp->value;\r\nnnp = rootnp;\r\ndo {\r\nnp = of_find_node_by_name(nnp, "GAISLER_GPTIMER");\r\nif (!np) {\r\nnp = of_find_node_by_name(nnp, "01_011");\r\nif (!np)\r\ngoto bad;\r\n}\r\nampopts = 0;\r\npp = of_find_property(np, "ampopts", &len);\r\nif (pp) {\r\nampopts = *(int *)pp->value;\r\nif (ampopts == 0) {\r\nnnp = np;\r\ncontinue;\r\n}\r\n}\r\nleon3_gptimer_idx = ampopts & 0x7;\r\npp = of_find_property(np, "reg", &len);\r\nif (pp)\r\nleon3_gptimer_regs = *(struct leon3_gptimer_regs_map **)\r\npp->value;\r\npp = of_find_property(np, "interrupts", &len);\r\nif (pp)\r\nleon3_gptimer_irq = *(unsigned int *)pp->value;\r\n} while (0);\r\nif (!(leon3_gptimer_regs && leon3_irqctrl_regs && leon3_gptimer_irq))\r\ngoto bad;\r\nctrl = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl);\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl,\r\nctrl | LEON3_GPTIMER_CTRL_PENDING);\r\nctrl = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl);\r\nif ((ctrl & LEON3_GPTIMER_CTRL_PENDING) != 0)\r\nleon3_gptimer_ackmask = ~LEON3_GPTIMER_CTRL_PENDING;\r\nelse\r\nleon3_gptimer_ackmask = ~0;\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].val, 0);\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].rld,\r\n(((1000000 / HZ) - 1)));\r\nLEON3_BYPASS_STORE_PA(\r\n&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl, 0);\r\nicsel = LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->icsel[boot_cpu_id/8]);\r\nicsel = (icsel >> ((7 - (boot_cpu_id&0x7)) * 4)) & 0xf;\r\nleon3_irqctrl_regs += icsel;\r\nLEON3_BYPASS_STORE_PA(&leon3_irqctrl_regs->mask[boot_cpu_id], 0);\r\neirq = (LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->mpstatus)\r\n>> 16) & 0xf;\r\nif (eirq != 0)\r\nleon_eirq_setup(eirq);\r\n#ifdef CONFIG_SMP\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\npatchme_maybe_smp_msg[0] = 0x01000000;\r\nlocal_ops->cache_all();\r\nlocal_irq_restore(flags);\r\n}\r\n#endif\r\nconfig = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->config);\r\nif (config & (1 << LEON3_GPTIMER_SEPIRQ))\r\nleon3_gptimer_irq += leon3_gptimer_idx;\r\nelse if ((config & LEON3_GPTIMER_TIMERS) > 1)\r\npr_warn("GPTIMER uses shared irqs, using other timers of the same core will fail.\n");\r\n#ifdef CONFIG_SMP\r\nirq = leon_build_device_irq(leon3_gptimer_irq, handle_percpu_irq,\r\n"per-cpu", 0);\r\nerr = request_irq(irq, leon_percpu_timer_ce_interrupt,\r\nIRQF_PERCPU | IRQF_TIMER, "timer", NULL);\r\n#else\r\nirq = _leon_build_device_irq(NULL, leon3_gptimer_irq);\r\nerr = request_irq(irq, timer_interrupt, IRQF_TIMER, "timer", NULL);\r\n#endif\r\nif (err) {\r\npr_err("Unable to attach timer IRQ%d\n", irq);\r\nprom_halt();\r\n}\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl,\r\nLEON3_GPTIMER_EN |\r\nLEON3_GPTIMER_RL |\r\nLEON3_GPTIMER_LD |\r\nLEON3_GPTIMER_IRQEN);\r\nreturn;\r\nbad:\r\nprintk(KERN_ERR "No Timer/irqctrl found\n");\r\nBUG();\r\nreturn;\r\n}\r\nstatic void leon_clear_clock_irq(void)\r\n{\r\nu32 ctrl;\r\nctrl = LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl);\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl,\r\nctrl & leon3_gptimer_ackmask);\r\n}\r\nstatic void leon_load_profile_irq(int cpu, unsigned int limit)\r\n{\r\n}\r\nvoid __init leon_trans_init(struct device_node *dp)\r\n{\r\nif (strcmp(dp->type, "cpu") == 0 && strcmp(dp->name, "<NULL>") == 0) {\r\nstruct property *p;\r\np = of_find_property(dp, "mid", (void *)0);\r\nif (p) {\r\nint mid;\r\ndp->name = prom_early_alloc(5 + 1);\r\nmemcpy(&mid, p->value, p->length);\r\nsprintf((char *)dp->name, "cpu%.2d", mid);\r\n}\r\n}\r\n}\r\nvoid leon_clear_profile_irq(int cpu)\r\n{\r\n}\r\nvoid leon_enable_irq_cpu(unsigned int irq_nr, unsigned int cpu)\r\n{\r\nunsigned long mask, flags, *addr;\r\nmask = leon_get_irqmask(irq_nr);\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\naddr = (unsigned long *)LEON_IMASK(cpu);\r\nLEON3_BYPASS_STORE_PA(addr, (LEON3_BYPASS_LOAD_PA(addr) | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nvoid __init leon_init_IRQ(void)\r\n{\r\nsparc_config.init_timers = leon_init_timers;\r\nsparc_config.build_device_irq = _leon_build_device_irq;\r\nsparc_config.clock_rate = 1000000;\r\nsparc_config.clear_clock_irq = leon_clear_clock_irq;\r\nsparc_config.load_profile_irq = leon_load_profile_irq;\r\n}
