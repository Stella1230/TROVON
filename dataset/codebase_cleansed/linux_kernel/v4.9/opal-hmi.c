static void print_core_checkstop_reason(const char *level,\r\nstruct OpalHMIEvent *hmi_evt)\r\n{\r\nint i;\r\nstatic const struct xstop_reason xstop_reason[] = {\r\n{ CORE_CHECKSTOP_IFU_REGFILE, "IFU",\r\n"RegFile core check stop" },\r\n{ CORE_CHECKSTOP_IFU_LOGIC, "IFU", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_PC_DURING_RECOV, "PC",\r\n"Core checkstop during recovery" },\r\n{ CORE_CHECKSTOP_ISU_REGFILE, "ISU",\r\n"RegFile core check stop (mapper error)" },\r\n{ CORE_CHECKSTOP_ISU_LOGIC, "ISU", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_FXU_LOGIC, "FXU", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_VSU_LOGIC, "VSU", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_PC_RECOV_IN_MAINT_MODE, "PC",\r\n"Recovery in maintenance mode" },\r\n{ CORE_CHECKSTOP_LSU_REGFILE, "LSU",\r\n"RegFile core check stop" },\r\n{ CORE_CHECKSTOP_PC_FWD_PROGRESS, "PC",\r\n"Forward Progress Error" },\r\n{ CORE_CHECKSTOP_LSU_LOGIC, "LSU", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_PC_LOGIC, "PC", "Logic core check stop" },\r\n{ CORE_CHECKSTOP_PC_HYP_RESOURCE, "PC",\r\n"Hypervisor Resource error - core check stop" },\r\n{ CORE_CHECKSTOP_PC_HANG_RECOV_FAILED, "PC",\r\n"Hang Recovery Failed (core check stop)" },\r\n{ CORE_CHECKSTOP_PC_AMBI_HANG_DETECTED, "PC",\r\n"Ambiguous Hang Detected (unknown source)" },\r\n{ CORE_CHECKSTOP_PC_DEBUG_TRIG_ERR_INJ, "PC",\r\n"Debug Trigger Error inject" },\r\n{ CORE_CHECKSTOP_PC_SPRD_HYP_ERR_INJ, "PC",\r\n"Hypervisor check stop via SPRC/SPRD" },\r\n};\r\nif (!hmi_evt->u.xstop_error.xstop_reason) {\r\nprintk("%s Unknown Core check stop.\n", level);\r\nreturn;\r\n}\r\nprintk("%s CPU PIR: %08x\n", level,\r\nbe32_to_cpu(hmi_evt->u.xstop_error.u.pir));\r\nfor (i = 0; i < ARRAY_SIZE(xstop_reason); i++)\r\nif (be32_to_cpu(hmi_evt->u.xstop_error.xstop_reason) &\r\nxstop_reason[i].xstop_reason)\r\nprintk("%s [Unit: %-3s] %s\n", level,\r\nxstop_reason[i].unit_failed,\r\nxstop_reason[i].description);\r\n}\r\nstatic void print_nx_checkstop_reason(const char *level,\r\nstruct OpalHMIEvent *hmi_evt)\r\n{\r\nint i;\r\nstatic const struct xstop_reason xstop_reason[] = {\r\n{ NX_CHECKSTOP_SHM_INVAL_STATE_ERR, "DMA & Engine",\r\n"SHM invalid state error" },\r\n{ NX_CHECKSTOP_DMA_INVAL_STATE_ERR_1, "DMA & Engine",\r\n"DMA invalid state error bit 15" },\r\n{ NX_CHECKSTOP_DMA_INVAL_STATE_ERR_2, "DMA & Engine",\r\n"DMA invalid state error bit 16" },\r\n{ NX_CHECKSTOP_DMA_CH0_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 0 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH1_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 1 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH2_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 2 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH3_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 3 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH4_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 4 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH5_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 5 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH6_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 6 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CH7_INVAL_STATE_ERR, "DMA & Engine",\r\n"Channel 7 invalid state error" },\r\n{ NX_CHECKSTOP_DMA_CRB_UE, "DMA & Engine",\r\n"UE error on CRB(CSB address, CCB)" },\r\n{ NX_CHECKSTOP_DMA_CRB_SUE, "DMA & Engine",\r\n"SUE error on CRB(CSB address, CCB)" },\r\n{ NX_CHECKSTOP_PBI_ISN_UE, "PowerBus Interface",\r\n"CRB Kill ISN received while holding ISN with UE error" },\r\n};\r\nif (!hmi_evt->u.xstop_error.xstop_reason) {\r\nprintk("%s Unknown NX check stop.\n", level);\r\nreturn;\r\n}\r\nprintk("%s NX checkstop on CHIP ID: %x\n", level,\r\nbe32_to_cpu(hmi_evt->u.xstop_error.u.chip_id));\r\nfor (i = 0; i < ARRAY_SIZE(xstop_reason); i++)\r\nif (be32_to_cpu(hmi_evt->u.xstop_error.xstop_reason) &\r\nxstop_reason[i].xstop_reason)\r\nprintk("%s [Unit: %-3s] %s\n", level,\r\nxstop_reason[i].unit_failed,\r\nxstop_reason[i].description);\r\n}\r\nstatic void print_checkstop_reason(const char *level,\r\nstruct OpalHMIEvent *hmi_evt)\r\n{\r\nuint8_t type = hmi_evt->u.xstop_error.xstop_type;\r\nswitch (type) {\r\ncase CHECKSTOP_TYPE_CORE:\r\nprint_core_checkstop_reason(level, hmi_evt);\r\nbreak;\r\ncase CHECKSTOP_TYPE_NX:\r\nprint_nx_checkstop_reason(level, hmi_evt);\r\nbreak;\r\ndefault:\r\nprintk("%s Unknown Malfunction Alert of type %d\n",\r\nlevel, type);\r\nbreak;\r\n}\r\n}\r\nstatic void print_hmi_event_info(struct OpalHMIEvent *hmi_evt)\r\n{\r\nconst char *level, *sevstr, *error_info;\r\nstatic const char *hmi_error_types[] = {\r\n"Malfunction Alert",\r\n"Processor Recovery done",\r\n"Processor recovery occurred again",\r\n"Processor recovery occurred for masked error",\r\n"Timer facility experienced an error",\r\n"TFMR SPR is corrupted",\r\n"UPS (Uniterrupted Power System) Overflow indication",\r\n"An XSCOM operation failure",\r\n"An XSCOM operation completed",\r\n"SCOM has set a reserved FIR bit to cause recovery",\r\n"Debug trigger has set a reserved FIR bit to cause recovery",\r\n"A hypervisor resource error occurred"\r\n};\r\nif (hmi_evt->version < OpalHMIEvt_V1) {\r\npr_err("HMI Interrupt, Unknown event version %d !\n",\r\nhmi_evt->version);\r\nreturn;\r\n}\r\nswitch (hmi_evt->severity) {\r\ncase OpalHMI_SEV_NO_ERROR:\r\nlevel = KERN_INFO;\r\nsevstr = "Harmless";\r\nbreak;\r\ncase OpalHMI_SEV_WARNING:\r\nlevel = KERN_WARNING;\r\nsevstr = "";\r\nbreak;\r\ncase OpalHMI_SEV_ERROR_SYNC:\r\nlevel = KERN_ERR;\r\nsevstr = "Severe";\r\nbreak;\r\ncase OpalHMI_SEV_FATAL:\r\ndefault:\r\nlevel = KERN_ERR;\r\nsevstr = "Fatal";\r\nbreak;\r\n}\r\nprintk("%s%s Hypervisor Maintenance interrupt [%s]\n",\r\nlevel, sevstr,\r\nhmi_evt->disposition == OpalHMI_DISPOSITION_RECOVERED ?\r\n"Recovered" : "Not recovered");\r\nerror_info = hmi_evt->type < ARRAY_SIZE(hmi_error_types) ?\r\nhmi_error_types[hmi_evt->type]\r\n: "Unknown";\r\nprintk("%s Error detail: %s\n", level, error_info);\r\nprintk("%s HMER: %016llx\n", level, be64_to_cpu(hmi_evt->hmer));\r\nif ((hmi_evt->type == OpalHMI_ERROR_TFAC) ||\r\n(hmi_evt->type == OpalHMI_ERROR_TFMR_PARITY))\r\nprintk("%s TFMR: %016llx\n", level,\r\nbe64_to_cpu(hmi_evt->tfmr));\r\nif (hmi_evt->version < OpalHMIEvt_V2)\r\nreturn;\r\nif (hmi_evt->type == OpalHMI_ERROR_MALFUNC_ALERT)\r\nprint_checkstop_reason(level, hmi_evt);\r\n}\r\nstatic void hmi_event_handler(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct OpalHMIEvent *hmi_evt;\r\nstruct OpalHmiEvtNode *msg_node;\r\nuint8_t disposition;\r\nstruct opal_msg msg;\r\nint unrecoverable = 0;\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\nwhile (!list_empty(&opal_hmi_evt_list)) {\r\nmsg_node = list_entry(opal_hmi_evt_list.next,\r\nstruct OpalHmiEvtNode, list);\r\nlist_del(&msg_node->list);\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\nhmi_evt = (struct OpalHMIEvent *) &msg_node->hmi_evt;\r\nprint_hmi_event_info(hmi_evt);\r\ndisposition = hmi_evt->disposition;\r\nkfree(msg_node);\r\nif (disposition != OpalHMI_DISPOSITION_RECOVERED)\r\nunrecoverable = 1;\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\nif (unrecoverable) {\r\nint ret;\r\nwhile (opal_get_msg(__pa(&msg), sizeof(msg)) == OPAL_SUCCESS) {\r\nu32 type;\r\ntype = be32_to_cpu(msg.msg_type);\r\nif (type != OPAL_MSG_HMI_EVT)\r\ncontinue;\r\nhmi_evt = (struct OpalHMIEvent *)&msg.params[0];\r\nprint_hmi_event_info(hmi_evt);\r\n}\r\nret = opal_cec_reboot2(OPAL_REBOOT_PLATFORM_ERROR,\r\n"Unrecoverable HMI exception");\r\nif (ret == OPAL_UNSUPPORTED) {\r\npr_emerg("Reboot type %d not supported\n",\r\nOPAL_REBOOT_PLATFORM_ERROR);\r\n}\r\npanic("Unrecoverable HMI exception");\r\n}\r\n}\r\nstatic int opal_handle_hmi_event(struct notifier_block *nb,\r\nunsigned long msg_type, void *msg)\r\n{\r\nunsigned long flags;\r\nstruct OpalHMIEvent *hmi_evt;\r\nstruct opal_msg *hmi_msg = msg;\r\nstruct OpalHmiEvtNode *msg_node;\r\nif (msg_type != OPAL_MSG_HMI_EVT)\r\nreturn 0;\r\nhmi_evt = (struct OpalHMIEvent *)&hmi_msg->params[0];\r\nmsg_node = kzalloc(sizeof(*msg_node), GFP_ATOMIC);\r\nif (!msg_node) {\r\npr_err("HMI: out of memory, Opal message event not handled\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&msg_node->hmi_evt, hmi_evt, sizeof(struct OpalHMIEvent));\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\nlist_add(&msg_node->list, &opal_hmi_evt_list);\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\nschedule_work(&hmi_event_work);\r\nreturn 0;\r\n}\r\nint __init opal_hmi_handler_init(void)\r\n{\r\nint ret;\r\nif (!opal_hmi_handler_nb_init) {\r\nret = opal_message_notifier_register(\r\nOPAL_MSG_HMI_EVT, &opal_hmi_handler_nb);\r\nif (ret) {\r\npr_err("%s: Can't register OPAL event notifier (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nopal_hmi_handler_nb_init = 1;\r\n}\r\nreturn 0;\r\n}
