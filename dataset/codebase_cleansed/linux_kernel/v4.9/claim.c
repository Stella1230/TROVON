void __nd_detach_ndns(struct device *dev, struct nd_namespace_common **_ndns)\r\n{\r\nstruct nd_namespace_common *ndns = *_ndns;\r\ndev_WARN_ONCE(dev, !mutex_is_locked(&ndns->dev.mutex)\r\n|| ndns->claim != dev,\r\n"%s: invalid claim\n", __func__);\r\nndns->claim = NULL;\r\n*_ndns = NULL;\r\nput_device(&ndns->dev);\r\n}\r\nvoid nd_detach_ndns(struct device *dev,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nstruct nd_namespace_common *ndns = *_ndns;\r\nif (!ndns)\r\nreturn;\r\nget_device(&ndns->dev);\r\ndevice_lock(&ndns->dev);\r\n__nd_detach_ndns(dev, _ndns);\r\ndevice_unlock(&ndns->dev);\r\nput_device(&ndns->dev);\r\n}\r\nbool __nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nif (attach->claim)\r\nreturn false;\r\ndev_WARN_ONCE(dev, !mutex_is_locked(&attach->dev.mutex)\r\n|| *_ndns,\r\n"%s: invalid claim\n", __func__);\r\nattach->claim = dev;\r\n*_ndns = attach;\r\nget_device(&attach->dev);\r\nreturn true;\r\n}\r\nbool nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nbool claimed;\r\ndevice_lock(&attach->dev);\r\nclaimed = __nd_attach_ndns(dev, attach, _ndns);\r\ndevice_unlock(&attach->dev);\r\nreturn claimed;\r\n}\r\nstatic int namespace_match(struct device *dev, void *data)\r\n{\r\nchar *name = data;\r\nreturn strcmp(name, dev_name(dev)) == 0;\r\n}\r\nstatic bool is_idle(struct device *dev, struct nd_namespace_common *ndns)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev->parent);\r\nstruct device *seed = NULL;\r\nif (is_nd_btt(dev))\r\nseed = nd_region->btt_seed;\r\nelse if (is_nd_pfn(dev))\r\nseed = nd_region->pfn_seed;\r\nelse if (is_nd_dax(dev))\r\nseed = nd_region->dax_seed;\r\nif (seed == dev || ndns || dev->driver)\r\nreturn false;\r\nreturn true;\r\n}\r\nstruct nd_pfn *to_nd_pfn_safe(struct device *dev)\r\n{\r\nif (is_nd_pfn(dev))\r\nreturn to_nd_pfn(dev);\r\nif (is_nd_dax(dev)) {\r\nstruct nd_dax *nd_dax = to_nd_dax(dev);\r\nreturn &nd_dax->nd_pfn;\r\n}\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nstatic void nd_detach_and_reset(struct device *dev,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nnd_detach_ndns(dev, _ndns);\r\nif (is_idle(dev, *_ndns)) {\r\nnd_device_unregister(dev, ND_ASYNC);\r\n} else if (is_nd_btt(dev)) {\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nnd_btt->lbasize = 0;\r\nkfree(nd_btt->uuid);\r\nnd_btt->uuid = NULL;\r\n} else if (is_nd_pfn(dev) || is_nd_dax(dev)) {\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nkfree(nd_pfn->uuid);\r\nnd_pfn->uuid = NULL;\r\nnd_pfn->mode = PFN_MODE_NONE;\r\n}\r\n}\r\nssize_t nd_namespace_store(struct device *dev,\r\nstruct nd_namespace_common **_ndns, const char *buf,\r\nsize_t len)\r\n{\r\nstruct nd_namespace_common *ndns;\r\nstruct device *found;\r\nchar *name;\r\nif (dev->driver) {\r\ndev_dbg(dev, "%s: -EBUSY\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nname = kstrndup(buf, len, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nstrim(name);\r\nif (strncmp(name, "namespace", 9) == 0 || strcmp(name, "") == 0)\r\n;\r\nelse {\r\nlen = -EINVAL;\r\ngoto out;\r\n}\r\nndns = *_ndns;\r\nif (strcmp(name, "") == 0) {\r\nnd_detach_and_reset(dev, _ndns);\r\ngoto out;\r\n} else if (ndns) {\r\ndev_dbg(dev, "namespace already set to: %s\n",\r\ndev_name(&ndns->dev));\r\nlen = -EBUSY;\r\ngoto out;\r\n}\r\nfound = device_find_child(dev->parent, name, namespace_match);\r\nif (!found) {\r\ndev_dbg(dev, "'%s' not found under %s\n", name,\r\ndev_name(dev->parent));\r\nlen = -ENODEV;\r\ngoto out;\r\n}\r\nndns = to_ndns(found);\r\nif (__nvdimm_namespace_capacity(ndns) < SZ_16M) {\r\ndev_dbg(dev, "%s too small to host\n", name);\r\nlen = -ENXIO;\r\ngoto out_attach;\r\n}\r\nWARN_ON_ONCE(!is_nvdimm_bus_locked(dev));\r\nif (!nd_attach_ndns(dev, ndns, _ndns)) {\r\ndev_dbg(dev, "%s already claimed\n",\r\ndev_name(&ndns->dev));\r\nlen = -EBUSY;\r\n}\r\nout_attach:\r\nput_device(&ndns->dev);\r\nout:\r\nkfree(name);\r\nreturn len;\r\n}\r\nu64 nd_sb_checksum(struct nd_gen_sb *nd_gen_sb)\r\n{\r\nu64 sum;\r\n__le64 sum_save;\r\nBUILD_BUG_ON(sizeof(struct btt_sb) != SZ_4K);\r\nBUILD_BUG_ON(sizeof(struct nd_pfn_sb) != SZ_4K);\r\nBUILD_BUG_ON(sizeof(struct nd_gen_sb) != SZ_4K);\r\nsum_save = nd_gen_sb->checksum;\r\nnd_gen_sb->checksum = 0;\r\nsum = nd_fletcher64(nd_gen_sb, sizeof(*nd_gen_sb), 1);\r\nnd_gen_sb->checksum = sum_save;\r\nreturn sum;\r\n}\r\nstatic int nsio_rw_bytes(struct nd_namespace_common *ndns,\r\nresource_size_t offset, void *buf, size_t size, int rw)\r\n{\r\nstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\r\nif (unlikely(offset + size > nsio->size)) {\r\ndev_WARN_ONCE(&ndns->dev, 1, "request out of range\n");\r\nreturn -EFAULT;\r\n}\r\nif (rw == READ) {\r\nunsigned int sz_align = ALIGN(size + (offset & (512 - 1)), 512);\r\nif (unlikely(is_bad_pmem(&nsio->bb, offset / 512, sz_align)))\r\nreturn -EIO;\r\nreturn memcpy_from_pmem(buf, nsio->addr + offset, size);\r\n} else {\r\nmemcpy_to_pmem(nsio->addr + offset, buf, size);\r\nnvdimm_flush(to_nd_region(ndns->dev.parent));\r\n}\r\nreturn 0;\r\n}\r\nint devm_nsio_enable(struct device *dev, struct nd_namespace_io *nsio)\r\n{\r\nstruct resource *res = &nsio->res;\r\nstruct nd_namespace_common *ndns = &nsio->common;\r\nnsio->size = resource_size(res);\r\nif (!devm_request_mem_region(dev, res->start, resource_size(res),\r\ndev_name(dev))) {\r\ndev_warn(dev, "could not reserve region %pR\n", res);\r\nreturn -EBUSY;\r\n}\r\nndns->rw_bytes = nsio_rw_bytes;\r\nif (devm_init_badblocks(dev, &nsio->bb))\r\nreturn -ENOMEM;\r\nnvdimm_badblocks_populate(to_nd_region(ndns->dev.parent), &nsio->bb,\r\n&nsio->res);\r\nnsio->addr = devm_memremap(dev, res->start, resource_size(res),\r\nARCH_MEMREMAP_PMEM);\r\nreturn PTR_ERR_OR_ZERO(nsio->addr);\r\n}\r\nvoid devm_nsio_disable(struct device *dev, struct nd_namespace_io *nsio)\r\n{\r\nstruct resource *res = &nsio->res;\r\ndevm_memunmap(dev, nsio->addr);\r\ndevm_exit_badblocks(dev, &nsio->bb);\r\ndevm_release_mem_region(dev, res->start, resource_size(res));\r\n}
