void\r\nbfa_cb_ioim_done(void *drv, struct bfad_ioim_s *dio,\r\nenum bfi_ioim_status io_status, u8 scsi_status,\r\nint sns_len, u8 *sns_info, s32 residue)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\r\nstruct bfad_s *bfad = drv;\r\nstruct bfad_itnim_data_s *itnim_data;\r\nstruct bfad_itnim_s *itnim;\r\nu8 host_status = DID_OK;\r\nswitch (io_status) {\r\ncase BFI_IOIM_STS_OK:\r\nbfa_trc(bfad, scsi_status);\r\nscsi_set_resid(cmnd, 0);\r\nif (sns_len > 0) {\r\nbfa_trc(bfad, sns_len);\r\nif (sns_len > SCSI_SENSE_BUFFERSIZE)\r\nsns_len = SCSI_SENSE_BUFFERSIZE;\r\nmemcpy(cmnd->sense_buffer, sns_info, sns_len);\r\n}\r\nif (residue > 0) {\r\nbfa_trc(bfad, residue);\r\nscsi_set_resid(cmnd, residue);\r\nif (!sns_len && (scsi_status == SAM_STAT_GOOD) &&\r\n(scsi_bufflen(cmnd) - residue) <\r\ncmnd->underflow) {\r\nbfa_trc(bfad, 0);\r\nhost_status = DID_ERROR;\r\n}\r\n}\r\ncmnd->result = ScsiResult(host_status, scsi_status);\r\nbreak;\r\ncase BFI_IOIM_STS_TIMEDOUT:\r\nhost_status = DID_TIME_OUT;\r\ncmnd->result = ScsiResult(host_status, 0);\r\nbreak;\r\ncase BFI_IOIM_STS_PATHTOV:\r\nhost_status = DID_TRANSPORT_DISRUPTED;\r\ncmnd->result = ScsiResult(host_status, 0);\r\nbreak;\r\ndefault:\r\nhost_status = DID_ERROR;\r\ncmnd->result = ScsiResult(host_status, 0);\r\n}\r\nif (cmnd->device->host != NULL)\r\nscsi_dma_unmap(cmnd);\r\ncmnd->host_scribble = NULL;\r\nbfa_trc(bfad, cmnd->result);\r\nitnim_data = cmnd->device->hostdata;\r\nif (itnim_data) {\r\nitnim = itnim_data->itnim;\r\nif (!cmnd->result && itnim &&\r\n(bfa_lun_queue_depth > cmnd->device->queue_depth)) {\r\nbfad_ramp_up_qdepth(itnim, cmnd->device);\r\n} else if (cmnd->result == SAM_STAT_TASK_SET_FULL && itnim) {\r\nbfad_handle_qfull(itnim, cmnd->device);\r\n}\r\n}\r\ncmnd->scsi_done(cmnd);\r\n}\r\nvoid\r\nbfa_cb_ioim_good_comp(void *drv, struct bfad_ioim_s *dio)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\r\nstruct bfad_itnim_data_s *itnim_data;\r\nstruct bfad_itnim_s *itnim;\r\ncmnd->result = ScsiResult(DID_OK, SCSI_STATUS_GOOD);\r\nif (cmnd->device->host != NULL)\r\nscsi_dma_unmap(cmnd);\r\ncmnd->host_scribble = NULL;\r\nif (bfa_lun_queue_depth > cmnd->device->queue_depth) {\r\nitnim_data = cmnd->device->hostdata;\r\nif (itnim_data) {\r\nitnim = itnim_data->itnim;\r\nif (itnim)\r\nbfad_ramp_up_qdepth(itnim, cmnd->device);\r\n}\r\n}\r\ncmnd->scsi_done(cmnd);\r\n}\r\nvoid\r\nbfa_cb_ioim_abort(void *drv, struct bfad_ioim_s *dio)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\r\nstruct bfad_s *bfad = drv;\r\ncmnd->result = ScsiResult(DID_ERROR, 0);\r\nif (cmnd->device->host != NULL)\r\nscsi_dma_unmap(cmnd);\r\nbfa_trc(bfad, cmnd->result);\r\ncmnd->host_scribble = NULL;\r\n}\r\nvoid\r\nbfa_cb_tskim_done(void *bfad, struct bfad_tskim_s *dtsk,\r\nenum bfi_tskim_status tsk_status)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dtsk;\r\nwait_queue_head_t *wq;\r\ncmnd->SCp.Status |= tsk_status << 1;\r\nset_bit(IO_DONE_BIT, (unsigned long *)&cmnd->SCp.Status);\r\nwq = (wait_queue_head_t *) cmnd->SCp.ptr;\r\ncmnd->SCp.ptr = NULL;\r\nif (wq)\r\nwake_up(wq);\r\n}\r\nstatic const char *\r\nbfad_im_info(struct Scsi_Host *shost)\r\n{\r\nstatic char bfa_buf[256];\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nmemset(bfa_buf, 0, sizeof(bfa_buf));\r\nsnprintf(bfa_buf, sizeof(bfa_buf),\r\n"QLogic BR-series FC/FCOE Adapter, hwpath: %s driver: %s",\r\nbfad->pci_name, BFAD_DRIVER_VERSION);\r\nreturn bfa_buf;\r\n}\r\nstatic int\r\nbfad_im_abort_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_ioim_s *hal_io;\r\nunsigned long flags;\r\nu32 timeout;\r\nint rc = FAILED;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nhal_io = (struct bfa_ioim_s *) cmnd->host_scribble;\r\nif (!hal_io) {\r\nrc = SUCCESS;\r\ngoto out;\r\n}\r\nif (hal_io->dio != (struct bfad_ioim_s *) cmnd) {\r\nrc = FAILED;\r\ngoto out;\r\n}\r\nbfa_trc(bfad, hal_io->iotag);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"scsi%d: abort cmnd %p iotag %x\n",\r\nim_port->shost->host_no, cmnd, hal_io->iotag);\r\n(void) bfa_ioim_abort(hal_io);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\ntimeout = 10;\r\nwhile ((struct bfa_ioim_s *) cmnd->host_scribble == hal_io) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(timeout);\r\nif (timeout < 4 * HZ)\r\ntimeout *= 2;\r\n}\r\ncmnd->scsi_done(cmnd);\r\nbfa_trc(bfad, hal_io->iotag);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"scsi%d: complete abort 0x%p iotag 0x%x\n",\r\nim_port->shost->host_no, cmnd, hal_io->iotag);\r\nreturn SUCCESS;\r\nout:\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nreturn rc;\r\n}\r\nstatic bfa_status_t\r\nbfad_im_target_reset_send(struct bfad_s *bfad, struct scsi_cmnd *cmnd,\r\nstruct bfad_itnim_s *itnim)\r\n{\r\nstruct bfa_tskim_s *tskim;\r\nstruct bfa_itnim_s *bfa_itnim;\r\nbfa_status_t rc = BFA_STATUS_OK;\r\nstruct scsi_lun scsilun;\r\ntskim = bfa_tskim_alloc(&bfad->bfa, (struct bfad_tskim_s *) cmnd);\r\nif (!tskim) {\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"target reset, fail to allocate tskim\n");\r\nrc = BFA_STATUS_FAILED;\r\ngoto out;\r\n}\r\ncmnd->host_scribble = NULL;\r\ncmnd->SCp.Status = 0;\r\nbfa_itnim = bfa_fcs_itnim_get_halitn(&itnim->fcs_itnim);\r\nif (bfa_itnim == NULL) {\r\nbfa_tskim_free(tskim);\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"target reset, bfa_itnim is NULL\n");\r\nrc = BFA_STATUS_FAILED;\r\ngoto out;\r\n}\r\nmemset(&scsilun, 0, sizeof(scsilun));\r\nbfa_tskim_start(tskim, bfa_itnim, scsilun,\r\nFCP_TM_TARGET_RESET, BFAD_TARGET_RESET_TMO);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nbfad_im_reset_lun_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_itnim_data_s *itnim_data = cmnd->device->hostdata;\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_tskim_s *tskim;\r\nstruct bfad_itnim_s *itnim;\r\nstruct bfa_itnim_s *bfa_itnim;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\r\nint rc = SUCCESS;\r\nunsigned long flags;\r\nenum bfi_tskim_status task_status;\r\nstruct scsi_lun scsilun;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nitnim = itnim_data->itnim;\r\nif (!itnim) {\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nrc = FAILED;\r\ngoto out;\r\n}\r\ntskim = bfa_tskim_alloc(&bfad->bfa, (struct bfad_tskim_s *) cmnd);\r\nif (!tskim) {\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"LUN reset, fail to allocate tskim");\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nrc = FAILED;\r\ngoto out;\r\n}\r\ncmnd->host_scribble = NULL;\r\ncmnd->SCp.ptr = (char *)&wq;\r\ncmnd->SCp.Status = 0;\r\nbfa_itnim = bfa_fcs_itnim_get_halitn(&itnim->fcs_itnim);\r\nif (bfa_itnim == NULL) {\r\nbfa_tskim_free(tskim);\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"lun reset, bfa_itnim is NULL\n");\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nrc = FAILED;\r\ngoto out;\r\n}\r\nint_to_scsilun(cmnd->device->lun, &scsilun);\r\nbfa_tskim_start(tskim, bfa_itnim, scsilun,\r\nFCP_TM_LUN_RESET, BFAD_LUN_RESET_TMO);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nwait_event(wq, test_bit(IO_DONE_BIT,\r\n(unsigned long *)&cmnd->SCp.Status));\r\ntask_status = cmnd->SCp.Status >> 1;\r\nif (task_status != BFI_TSKIM_STS_OK) {\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"LUN reset failure, status: %d\n", task_status);\r\nrc = FAILED;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nbfad_im_reset_bus_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_itnim_s *itnim;\r\nunsigned long flags;\r\nu32 i, rc, err_cnt = 0;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\r\nenum bfi_tskim_status task_status;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nfor (i = 0; i < MAX_FCP_TARGET; i++) {\r\nitnim = bfad_get_itnim(im_port, i);\r\nif (itnim) {\r\ncmnd->SCp.ptr = (char *)&wq;\r\nrc = bfad_im_target_reset_send(bfad, cmnd, itnim);\r\nif (rc != BFA_STATUS_OK) {\r\nerr_cnt++;\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nwait_event(wq, test_bit(IO_DONE_BIT,\r\n(unsigned long *)&cmnd->SCp.Status));\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\ntask_status = cmnd->SCp.Status >> 1;\r\nif (task_status != BFI_TSKIM_STS_OK) {\r\nBFA_LOG(KERN_ERR, bfad, bfa_log_level,\r\n"target reset failure,"\r\n" status: %d\n", task_status);\r\nerr_cnt++;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (err_cnt)\r\nreturn FAILED;\r\nreturn SUCCESS;\r\n}\r\nstatic void\r\nbfad_im_slave_destroy(struct scsi_device *sdev)\r\n{\r\nsdev->hostdata = NULL;\r\nreturn;\r\n}\r\nint\r\nbfa_fcb_itnim_alloc(struct bfad_s *bfad, struct bfa_fcs_itnim_s **itnim,\r\nstruct bfad_itnim_s **itnim_drv)\r\n{\r\n*itnim_drv = kzalloc(sizeof(struct bfad_itnim_s), GFP_ATOMIC);\r\nif (*itnim_drv == NULL)\r\nreturn -ENOMEM;\r\n(*itnim_drv)->im = bfad->im;\r\n*itnim = &(*itnim_drv)->fcs_itnim;\r\n(*itnim_drv)->state = ITNIM_STATE_NONE;\r\nINIT_WORK(&(*itnim_drv)->itnim_work, bfad_im_itnim_work_handler);\r\nbfad->bfad_flags |= BFAD_RPORT_ONLINE;\r\nreturn 0;\r\n}\r\nvoid\r\nbfa_fcb_itnim_free(struct bfad_s *bfad, struct bfad_itnim_s *itnim_drv)\r\n{\r\nstruct bfad_port_s *port;\r\nwwn_t wwpn;\r\nu32 fcid;\r\nchar wwpn_str[32], fcid_str[16];\r\nstruct bfad_im_s *im = itnim_drv->im;\r\nWARN_ON(itnim_drv->state == ITNIM_STATE_ONLINE);\r\nitnim_drv->queue_work = 1;\r\nif (itnim_drv->state == ITNIM_STATE_OFFLINE_PENDING)\r\nitnim_drv->queue_work = 0;\r\nitnim_drv->state = ITNIM_STATE_FREE;\r\nport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\r\nitnim_drv->im_port = port->im_port;\r\nwwpn = bfa_fcs_itnim_get_pwwn(&itnim_drv->fcs_itnim);\r\nfcid = bfa_fcs_itnim_get_fcid(&itnim_drv->fcs_itnim);\r\nwwn2str(wwpn_str, wwpn);\r\nfcid2str(fcid_str, fcid);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"ITNIM FREE scsi%d: FCID: %s WWPN: %s\n",\r\nport->im_port->shost->host_no,\r\nfcid_str, wwpn_str);\r\nif (itnim_drv->queue_work)\r\nqueue_work(im->drv_workq, &itnim_drv->itnim_work);\r\n}\r\nvoid\r\nbfa_fcb_itnim_online(struct bfad_itnim_s *itnim_drv)\r\n{\r\nstruct bfad_port_s *port;\r\nstruct bfad_im_s *im = itnim_drv->im;\r\nitnim_drv->bfa_itnim = bfa_fcs_itnim_get_halitn(&itnim_drv->fcs_itnim);\r\nport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\r\nitnim_drv->state = ITNIM_STATE_ONLINE;\r\nitnim_drv->queue_work = 1;\r\nitnim_drv->im_port = port->im_port;\r\nif (itnim_drv->queue_work)\r\nqueue_work(im->drv_workq, &itnim_drv->itnim_work);\r\n}\r\nvoid\r\nbfa_fcb_itnim_offline(struct bfad_itnim_s *itnim_drv)\r\n{\r\nstruct bfad_port_s *port;\r\nstruct bfad_s *bfad;\r\nstruct bfad_im_s *im = itnim_drv->im;\r\nport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\r\nbfad = port->bfad;\r\nif ((bfad->pport.flags & BFAD_PORT_DELETE) ||\r\n(port->flags & BFAD_PORT_DELETE)) {\r\nitnim_drv->state = ITNIM_STATE_OFFLINE;\r\nreturn;\r\n}\r\nitnim_drv->im_port = port->im_port;\r\nitnim_drv->state = ITNIM_STATE_OFFLINE_PENDING;\r\nitnim_drv->queue_work = 1;\r\nif (itnim_drv->queue_work)\r\nqueue_work(im->drv_workq, &itnim_drv->itnim_work);\r\n}\r\nint\r\nbfad_im_scsi_host_alloc(struct bfad_s *bfad, struct bfad_im_port_s *im_port,\r\nstruct device *dev)\r\n{\r\nint error = 1;\r\nmutex_lock(&bfad_mutex);\r\nerror = idr_alloc(&bfad_im_port_index, im_port, 0, 0, GFP_KERNEL);\r\nif (error < 0) {\r\nmutex_unlock(&bfad_mutex);\r\nprintk(KERN_WARNING "idr_alloc failure\n");\r\ngoto out;\r\n}\r\nim_port->idr_id = error;\r\nmutex_unlock(&bfad_mutex);\r\nim_port->shost = bfad_scsi_host_alloc(im_port, bfad);\r\nif (!im_port->shost) {\r\nerror = 1;\r\ngoto out_free_idr;\r\n}\r\nim_port->shost->hostdata[0] = (unsigned long)im_port;\r\nim_port->shost->unique_id = im_port->idr_id;\r\nim_port->shost->this_id = -1;\r\nim_port->shost->max_id = MAX_FCP_TARGET;\r\nim_port->shost->max_lun = MAX_FCP_LUN;\r\nim_port->shost->max_cmd_len = 16;\r\nim_port->shost->can_queue = bfad->cfg_data.ioc_queue_depth;\r\nif (im_port->port->pvb_type == BFAD_PORT_PHYS_BASE)\r\nim_port->shost->transportt = bfad_im_scsi_transport_template;\r\nelse\r\nim_port->shost->transportt =\r\nbfad_im_scsi_vport_transport_template;\r\nerror = scsi_add_host_with_dma(im_port->shost, dev, &bfad->pcidev->dev);\r\nif (error) {\r\nprintk(KERN_WARNING "scsi_add_host failure %d\n", error);\r\ngoto out_fc_rel;\r\n}\r\nreturn 0;\r\nout_fc_rel:\r\nscsi_host_put(im_port->shost);\r\nim_port->shost = NULL;\r\nout_free_idr:\r\nmutex_lock(&bfad_mutex);\r\nidr_remove(&bfad_im_port_index, im_port->idr_id);\r\nmutex_unlock(&bfad_mutex);\r\nout:\r\nreturn error;\r\n}\r\nvoid\r\nbfad_im_scsi_host_free(struct bfad_s *bfad, struct bfad_im_port_s *im_port)\r\n{\r\nbfa_trc(bfad, bfad->inst_no);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level, "Free scsi%d\n",\r\nim_port->shost->host_no);\r\nfc_remove_host(im_port->shost);\r\nscsi_remove_host(im_port->shost);\r\nscsi_host_put(im_port->shost);\r\nmutex_lock(&bfad_mutex);\r\nidr_remove(&bfad_im_port_index, im_port->idr_id);\r\nmutex_unlock(&bfad_mutex);\r\n}\r\nstatic void\r\nbfad_im_port_delete_handler(struct work_struct *work)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\ncontainer_of(work, struct bfad_im_port_s, port_delete_work);\r\nif (im_port->port->pvb_type != BFAD_PORT_PHYS_BASE) {\r\nim_port->flags |= BFAD_PORT_DELETE;\r\nfc_vport_terminate(im_port->fc_vport);\r\n}\r\n}\r\nbfa_status_t\r\nbfad_im_port_new(struct bfad_s *bfad, struct bfad_port_s *port)\r\n{\r\nint rc = BFA_STATUS_OK;\r\nstruct bfad_im_port_s *im_port;\r\nim_port = kzalloc(sizeof(struct bfad_im_port_s), GFP_ATOMIC);\r\nif (im_port == NULL) {\r\nrc = BFA_STATUS_ENOMEM;\r\ngoto ext;\r\n}\r\nport->im_port = im_port;\r\nim_port->port = port;\r\nim_port->bfad = bfad;\r\nINIT_WORK(&im_port->port_delete_work, bfad_im_port_delete_handler);\r\nINIT_LIST_HEAD(&im_port->itnim_mapped_list);\r\nINIT_LIST_HEAD(&im_port->binding_list);\r\next:\r\nreturn rc;\r\n}\r\nvoid\r\nbfad_im_port_delete(struct bfad_s *bfad, struct bfad_port_s *port)\r\n{\r\nstruct bfad_im_port_s *im_port = port->im_port;\r\nqueue_work(bfad->im->drv_workq,\r\n&im_port->port_delete_work);\r\n}\r\nvoid\r\nbfad_im_port_clean(struct bfad_im_port_s *im_port)\r\n{\r\nstruct bfad_fcp_binding *bp, *bp_new;\r\nunsigned long flags;\r\nstruct bfad_s *bfad = im_port->bfad;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nlist_for_each_entry_safe(bp, bp_new, &im_port->binding_list,\r\nlist_entry) {\r\nlist_del(&bp->list_entry);\r\nkfree(bp);\r\n}\r\nWARN_ON(!list_empty(&im_port->itnim_mapped_list));\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic void bfad_aen_im_notify_handler(struct work_struct *work)\r\n{\r\nstruct bfad_im_s *im =\r\ncontainer_of(work, struct bfad_im_s, aen_im_notify_work);\r\nstruct bfa_aen_entry_s *aen_entry;\r\nstruct bfad_s *bfad = im->bfad;\r\nstruct Scsi_Host *shost = bfad->pport.im_port->shost;\r\nvoid *event_data;\r\nunsigned long flags;\r\nwhile (!list_empty(&bfad->active_aen_q)) {\r\nspin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);\r\nbfa_q_deq(&bfad->active_aen_q, &aen_entry);\r\nspin_unlock_irqrestore(&bfad->bfad_aen_spinlock, flags);\r\nevent_data = (char *)aen_entry + sizeof(struct list_head);\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(struct bfa_aen_entry_s) -\r\nsizeof(struct list_head),\r\n(char *)event_data, BFAD_NL_VENDOR_ID);\r\nspin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);\r\nlist_add_tail(&aen_entry->qe, &bfad->free_aen_q);\r\nspin_unlock_irqrestore(&bfad->bfad_aen_spinlock, flags);\r\n}\r\n}\r\nbfa_status_t\r\nbfad_im_probe(struct bfad_s *bfad)\r\n{\r\nstruct bfad_im_s *im;\r\nim = kzalloc(sizeof(struct bfad_im_s), GFP_KERNEL);\r\nif (im == NULL)\r\nreturn BFA_STATUS_ENOMEM;\r\nbfad->im = im;\r\nim->bfad = bfad;\r\nif (bfad_thread_workq(bfad) != BFA_STATUS_OK) {\r\nkfree(im);\r\nreturn BFA_STATUS_FAILED;\r\n}\r\nINIT_WORK(&im->aen_im_notify_work, bfad_aen_im_notify_handler);\r\nreturn BFA_STATUS_OK;\r\n}\r\nvoid\r\nbfad_im_probe_undo(struct bfad_s *bfad)\r\n{\r\nif (bfad->im) {\r\nbfad_destroy_workq(bfad->im);\r\nkfree(bfad->im);\r\nbfad->im = NULL;\r\n}\r\n}\r\nstruct Scsi_Host *\r\nbfad_scsi_host_alloc(struct bfad_im_port_s *im_port, struct bfad_s *bfad)\r\n{\r\nstruct scsi_host_template *sht;\r\nif (im_port->port->pvb_type == BFAD_PORT_PHYS_BASE)\r\nsht = &bfad_im_scsi_host_template;\r\nelse\r\nsht = &bfad_im_vport_template;\r\nif (max_xfer_size != BFAD_MAX_SECTORS >> 1)\r\nsht->max_sectors = max_xfer_size << 1;\r\nsht->sg_tablesize = bfad->cfg_data.io_max_sge;\r\nreturn scsi_host_alloc(sht, sizeof(unsigned long));\r\n}\r\nvoid\r\nbfad_scsi_host_free(struct bfad_s *bfad, struct bfad_im_port_s *im_port)\r\n{\r\nif (!(im_port->flags & BFAD_PORT_DELETE))\r\nflush_workqueue(bfad->im->drv_workq);\r\nbfad_im_scsi_host_free(im_port->bfad, im_port);\r\nbfad_im_port_clean(im_port);\r\nkfree(im_port);\r\n}\r\nvoid\r\nbfad_destroy_workq(struct bfad_im_s *im)\r\n{\r\nif (im && im->drv_workq) {\r\nflush_workqueue(im->drv_workq);\r\ndestroy_workqueue(im->drv_workq);\r\nim->drv_workq = NULL;\r\n}\r\n}\r\nbfa_status_t\r\nbfad_thread_workq(struct bfad_s *bfad)\r\n{\r\nstruct bfad_im_s *im = bfad->im;\r\nbfa_trc(bfad, 0);\r\nsnprintf(im->drv_workq_name, KOBJ_NAME_LEN, "bfad_wq_%d",\r\nbfad->inst_no);\r\nim->drv_workq = create_singlethread_workqueue(im->drv_workq_name);\r\nif (!im->drv_workq)\r\nreturn BFA_STATUS_FAILED;\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic int\r\nbfad_im_slave_configure(struct scsi_device *sdev)\r\n{\r\nscsi_change_queue_depth(sdev, bfa_lun_queue_depth);\r\nreturn 0;\r\n}\r\nbfa_status_t\r\nbfad_im_module_init(void)\r\n{\r\nbfad_im_scsi_transport_template =\r\nfc_attach_transport(&bfad_im_fc_function_template);\r\nif (!bfad_im_scsi_transport_template)\r\nreturn BFA_STATUS_ENOMEM;\r\nbfad_im_scsi_vport_transport_template =\r\nfc_attach_transport(&bfad_im_vport_fc_function_template);\r\nif (!bfad_im_scsi_vport_transport_template) {\r\nfc_release_transport(bfad_im_scsi_transport_template);\r\nreturn BFA_STATUS_ENOMEM;\r\n}\r\nreturn BFA_STATUS_OK;\r\n}\r\nvoid\r\nbfad_im_module_exit(void)\r\n{\r\nif (bfad_im_scsi_transport_template)\r\nfc_release_transport(bfad_im_scsi_transport_template);\r\nif (bfad_im_scsi_vport_transport_template)\r\nfc_release_transport(bfad_im_scsi_vport_transport_template);\r\nidr_destroy(&bfad_im_port_index);\r\n}\r\nvoid\r\nbfad_ramp_up_qdepth(struct bfad_itnim_s *itnim, struct scsi_device *sdev)\r\n{\r\nstruct scsi_device *tmp_sdev;\r\nif (((jiffies - itnim->last_ramp_up_time) >\r\nBFA_QUEUE_FULL_RAMP_UP_TIME * HZ) &&\r\n((jiffies - itnim->last_queue_full_time) >\r\nBFA_QUEUE_FULL_RAMP_UP_TIME * HZ)) {\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (bfa_lun_queue_depth > tmp_sdev->queue_depth) {\r\nif (tmp_sdev->id != sdev->id)\r\ncontinue;\r\nscsi_change_queue_depth(tmp_sdev,\r\ntmp_sdev->queue_depth + 1);\r\nitnim->last_ramp_up_time = jiffies;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nbfad_handle_qfull(struct bfad_itnim_s *itnim, struct scsi_device *sdev)\r\n{\r\nstruct scsi_device *tmp_sdev;\r\nitnim->last_queue_full_time = jiffies;\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->id != sdev->id)\r\ncontinue;\r\nscsi_track_queue_full(tmp_sdev, tmp_sdev->queue_depth - 1);\r\n}\r\n}\r\nstruct bfad_itnim_s *\r\nbfad_get_itnim(struct bfad_im_port_s *im_port, int id)\r\n{\r\nstruct bfad_itnim_s *itnim = NULL;\r\nlist_for_each_entry(itnim, &im_port->itnim_mapped_list, list_entry) {\r\nif (id == itnim->scsi_tgt_id)\r\nreturn itnim;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nbfad_im_check_if_make_lun_visible(struct scsi_device *sdev,\r\nstruct fc_rport *rport)\r\n{\r\nstruct bfad_itnim_data_s *itnim_data =\r\n(struct bfad_itnim_data_s *) rport->dd_data;\r\nstruct bfa_s *bfa = itnim_data->itnim->bfa_itnim->bfa;\r\nstruct bfa_rport_s *bfa_rport = itnim_data->itnim->bfa_itnim->rport;\r\nstruct bfa_lun_mask_s *lun_list = bfa_get_lun_mask_list(bfa);\r\nint i = 0, ret = -ENXIO;\r\nfor (i = 0; i < MAX_LUN_MASK_CFG; i++) {\r\nif (lun_list[i].state == BFA_IOIM_LUN_MASK_ACTIVE &&\r\nscsilun_to_int(&lun_list[i].lun) == sdev->lun &&\r\nlun_list[i].rp_tag == bfa_rport->rport_tag &&\r\nlun_list[i].lp_tag == (u8)bfa_rport->rport_info.lp_tag) {\r\nret = BFA_STATUS_OK;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbfad_im_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct bfad_itnim_data_s *itnim_data;\r\nstruct bfa_s *bfa;\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nitnim_data = (struct bfad_itnim_data_s *) rport->dd_data;\r\nbfa = itnim_data->itnim->bfa_itnim->bfa;\r\nif (bfa_get_lun_mask_status(bfa) == BFA_LUNMASK_ENABLED) {\r\nif (sdev->lun == 0) {\r\nsdev->sdev_bflags |= BLIST_NOREPORTLUN |\r\nBLIST_SPARSELUN;\r\ngoto done;\r\n}\r\nif (bfad_im_check_if_make_lun_visible(sdev, rport) !=\r\nBFA_STATUS_OK)\r\nreturn -ENXIO;\r\n}\r\ndone:\r\nsdev->hostdata = rport->dd_data;\r\nreturn 0;\r\n}\r\nu32\r\nbfad_im_supported_speeds(struct bfa_s *bfa)\r\n{\r\nstruct bfa_ioc_attr_s *ioc_attr;\r\nu32 supported_speed = 0;\r\nioc_attr = kzalloc(sizeof(struct bfa_ioc_attr_s), GFP_KERNEL);\r\nif (!ioc_attr)\r\nreturn 0;\r\nbfa_ioc_get_attr(&bfa->ioc, ioc_attr);\r\nif (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_16GBPS)\r\nsupported_speed |= FC_PORTSPEED_16GBIT | FC_PORTSPEED_8GBIT |\r\nFC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT;\r\nelse if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_8GBPS) {\r\nif (ioc_attr->adapter_attr.is_mezz) {\r\nsupported_speed |= FC_PORTSPEED_8GBIT |\r\nFC_PORTSPEED_4GBIT |\r\nFC_PORTSPEED_2GBIT | FC_PORTSPEED_1GBIT;\r\n} else {\r\nsupported_speed |= FC_PORTSPEED_8GBIT |\r\nFC_PORTSPEED_4GBIT |\r\nFC_PORTSPEED_2GBIT;\r\n}\r\n} else if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_4GBPS) {\r\nsupported_speed |= FC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT |\r\nFC_PORTSPEED_1GBIT;\r\n} else if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_10GBPS) {\r\nsupported_speed |= FC_PORTSPEED_10GBIT;\r\n}\r\nkfree(ioc_attr);\r\nreturn supported_speed;\r\n}\r\nvoid\r\nbfad_fc_host_init(struct bfad_im_port_s *im_port)\r\n{\r\nstruct Scsi_Host *host = im_port->shost;\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_port_s *port = im_port->port;\r\nchar symname[BFA_SYMNAME_MAXLEN];\r\nstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);\r\nfc_host_node_name(host) =\r\ncpu_to_be64((bfa_fcs_lport_get_nwwn(port->fcs_port)));\r\nfc_host_port_name(host) =\r\ncpu_to_be64((bfa_fcs_lport_get_pwwn(port->fcs_port)));\r\nfc_host_max_npiv_vports(host) = bfa_lps_get_max_vport(&bfad->bfa);\r\nfc_host_supported_classes(host) = FC_COS_CLASS3;\r\nmemset(fc_host_supported_fc4s(host), 0,\r\nsizeof(fc_host_supported_fc4s(host)));\r\nif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\r\nfc_host_supported_fc4s(host)[2] = 1;\r\nfc_host_supported_fc4s(host)[7] = 1;\r\nstrlcpy(symname, bfad->bfa_fcs.fabric.bport.port_cfg.sym_name.symname,\r\nBFA_SYMNAME_MAXLEN);\r\nsprintf(fc_host_symbolic_name(host), "%s", symname);\r\nfc_host_supported_speeds(host) = bfad_im_supported_speeds(&bfad->bfa);\r\nfc_host_maxframe_size(host) = fcport->cfg.maxfrsize;\r\n}\r\nstatic void\r\nbfad_im_fc_rport_add(struct bfad_im_port_s *im_port, struct bfad_itnim_s *itnim)\r\n{\r\nstruct fc_rport_identifiers rport_ids;\r\nstruct fc_rport *fc_rport;\r\nstruct bfad_itnim_data_s *itnim_data;\r\nrport_ids.node_name =\r\ncpu_to_be64(bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim));\r\nrport_ids.port_name =\r\ncpu_to_be64(bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim));\r\nrport_ids.port_id =\r\nbfa_hton3b(bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim));\r\nrport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nitnim->fc_rport = fc_rport =\r\nfc_remote_port_add(im_port->shost, 0, &rport_ids);\r\nif (!fc_rport)\r\nreturn;\r\nfc_rport->maxframe_size =\r\nbfa_fcs_itnim_get_maxfrsize(&itnim->fcs_itnim);\r\nfc_rport->supported_classes = bfa_fcs_itnim_get_cos(&itnim->fcs_itnim);\r\nitnim_data = fc_rport->dd_data;\r\nitnim_data->itnim = itnim;\r\nrport_ids.roles |= FC_RPORT_ROLE_FCP_TARGET;\r\nif (rport_ids.roles != FC_RPORT_ROLE_UNKNOWN)\r\nfc_remote_port_rolechg(fc_rport, rport_ids.roles);\r\nif ((fc_rport->scsi_target_id != -1)\r\n&& (fc_rport->scsi_target_id < MAX_FCP_TARGET))\r\nitnim->scsi_tgt_id = fc_rport->scsi_target_id;\r\nitnim->channel = fc_rport->channel;\r\nreturn;\r\n}\r\nstatic void\r\nbfad_im_itnim_work_handler(struct work_struct *work)\r\n{\r\nstruct bfad_itnim_s *itnim = container_of(work, struct bfad_itnim_s,\r\nitnim_work);\r\nstruct bfad_im_s *im = itnim->im;\r\nstruct bfad_s *bfad = im->bfad;\r\nstruct bfad_im_port_s *im_port;\r\nunsigned long flags;\r\nstruct fc_rport *fc_rport;\r\nwwn_t wwpn;\r\nu32 fcid;\r\nchar wwpn_str[32], fcid_str[16];\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nim_port = itnim->im_port;\r\nbfa_trc(bfad, itnim->state);\r\nswitch (itnim->state) {\r\ncase ITNIM_STATE_ONLINE:\r\nif (!itnim->fc_rport) {\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nbfad_im_fc_rport_add(im_port, itnim);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nwwpn = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\r\nfcid = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\r\nwwn2str(wwpn_str, wwpn);\r\nfcid2str(fcid_str, fcid);\r\nlist_add_tail(&itnim->list_entry,\r\n&im_port->itnim_mapped_list);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"ITNIM ONLINE Target: %d:0:%d "\r\n"FCID: %s WWPN: %s\n",\r\nim_port->shost->host_no,\r\nitnim->scsi_tgt_id,\r\nfcid_str, wwpn_str);\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s: itnim %llx is already in online state\n",\r\n__func__,\r\nbfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim));\r\n}\r\nbreak;\r\ncase ITNIM_STATE_OFFLINE_PENDING:\r\nitnim->state = ITNIM_STATE_OFFLINE;\r\nif (itnim->fc_rport) {\r\nfc_rport = itnim->fc_rport;\r\n((struct bfad_itnim_data_s *)\r\nfc_rport->dd_data)->itnim = NULL;\r\nitnim->fc_rport = NULL;\r\nif (!(im_port->port->flags & BFAD_PORT_DELETE)) {\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nfc_rport->dev_loss_tmo =\r\nbfa_fcpim_path_tov_get(&bfad->bfa) + 1;\r\nfc_remote_port_delete(fc_rport);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\n}\r\nwwpn = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\r\nfcid = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\r\nwwn2str(wwpn_str, wwpn);\r\nfcid2str(fcid_str, fcid);\r\nlist_del(&itnim->list_entry);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level,\r\n"ITNIM OFFLINE Target: %d:0:%d "\r\n"FCID: %s WWPN: %s\n",\r\nim_port->shost->host_no,\r\nitnim->scsi_tgt_id,\r\nfcid_str, wwpn_str);\r\n}\r\nbreak;\r\ncase ITNIM_STATE_FREE:\r\nif (itnim->fc_rport) {\r\nfc_rport = itnim->fc_rport;\r\n((struct bfad_itnim_data_s *)\r\nfc_rport->dd_data)->itnim = NULL;\r\nitnim->fc_rport = NULL;\r\nif (!(im_port->port->flags & BFAD_PORT_DELETE)) {\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nfc_rport->dev_loss_tmo =\r\nbfa_fcpim_path_tov_get(&bfad->bfa) + 1;\r\nfc_remote_port_delete(fc_rport);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\n}\r\nlist_del(&itnim->list_entry);\r\n}\r\nkfree(itnim);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic int\r\nbfad_im_queuecommand_lck(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) cmnd->device->host->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_itnim_data_s *itnim_data = cmnd->device->hostdata;\r\nstruct bfad_itnim_s *itnim;\r\nstruct bfa_ioim_s *hal_io;\r\nunsigned long flags;\r\nint rc;\r\nint sg_cnt = 0;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\r\nrc = fc_remote_port_chkready(rport);\r\nif (rc) {\r\ncmnd->result = rc;\r\ndone(cmnd);\r\nreturn 0;\r\n}\r\nif (bfad->bfad_flags & BFAD_EEH_BUSY) {\r\nif (bfad->bfad_flags & BFAD_EEH_PCI_CHANNEL_IO_PERM_FAILURE)\r\ncmnd->result = DID_NO_CONNECT << 16;\r\nelse\r\ncmnd->result = DID_REQUEUE << 16;\r\ndone(cmnd);\r\nreturn 0;\r\n}\r\nsg_cnt = scsi_dma_map(cmnd);\r\nif (sg_cnt < 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ncmnd->scsi_done = done;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nif (!(bfad->bfad_flags & BFAD_HAL_START_DONE)) {\r\nprintk(KERN_WARNING\r\n"bfad%d, queuecommand %p %x failed, BFA stopped\n",\r\nbfad->inst_no, cmnd, cmnd->cmnd[0]);\r\ncmnd->result = ScsiResult(DID_NO_CONNECT, 0);\r\ngoto out_fail_cmd;\r\n}\r\nitnim = itnim_data->itnim;\r\nif (!itnim) {\r\ncmnd->result = ScsiResult(DID_IMM_RETRY, 0);\r\ngoto out_fail_cmd;\r\n}\r\nhal_io = bfa_ioim_alloc(&bfad->bfa, (struct bfad_ioim_s *) cmnd,\r\nitnim->bfa_itnim, sg_cnt);\r\nif (!hal_io) {\r\nprintk(KERN_WARNING "hal_io failure\n");\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nscsi_dma_unmap(cmnd);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\ncmnd->host_scribble = (char *)hal_io;\r\nbfa_ioim_start(hal_io);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nreturn 0;\r\nout_fail_cmd:\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nscsi_dma_unmap(cmnd);\r\nif (done)\r\ndone(cmnd);\r\nreturn 0;\r\n}
