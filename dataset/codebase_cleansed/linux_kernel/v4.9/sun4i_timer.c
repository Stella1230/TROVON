static void sun4i_clkevt_sync(void)\r\n{\r\nu32 old = readl(timer_base + TIMER_CNTVAL_REG(1));\r\nwhile ((old - readl(timer_base + TIMER_CNTVAL_REG(1))) < TIMER_SYNC_TICKS)\r\ncpu_relax();\r\n}\r\nstatic void sun4i_clkevt_time_stop(u8 timer)\r\n{\r\nu32 val = readl(timer_base + TIMER_CTL_REG(timer));\r\nwritel(val & ~TIMER_CTL_ENABLE, timer_base + TIMER_CTL_REG(timer));\r\nsun4i_clkevt_sync();\r\n}\r\nstatic void sun4i_clkevt_time_setup(u8 timer, unsigned long delay)\r\n{\r\nwritel(delay, timer_base + TIMER_INTVAL_REG(timer));\r\n}\r\nstatic void sun4i_clkevt_time_start(u8 timer, bool periodic)\r\n{\r\nu32 val = readl(timer_base + TIMER_CTL_REG(timer));\r\nif (periodic)\r\nval &= ~TIMER_CTL_ONESHOT;\r\nelse\r\nval |= TIMER_CTL_ONESHOT;\r\nwritel(val | TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\r\ntimer_base + TIMER_CTL_REG(timer));\r\n}\r\nstatic int sun4i_clkevt_shutdown(struct clock_event_device *evt)\r\n{\r\nsun4i_clkevt_time_stop(0);\r\nreturn 0;\r\n}\r\nstatic int sun4i_clkevt_set_oneshot(struct clock_event_device *evt)\r\n{\r\nsun4i_clkevt_time_stop(0);\r\nsun4i_clkevt_time_start(0, false);\r\nreturn 0;\r\n}\r\nstatic int sun4i_clkevt_set_periodic(struct clock_event_device *evt)\r\n{\r\nsun4i_clkevt_time_stop(0);\r\nsun4i_clkevt_time_setup(0, ticks_per_jiffy);\r\nsun4i_clkevt_time_start(0, true);\r\nreturn 0;\r\n}\r\nstatic int sun4i_clkevt_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nsun4i_clkevt_time_stop(0);\r\nsun4i_clkevt_time_setup(0, evt - TIMER_SYNC_TICKS);\r\nsun4i_clkevt_time_start(0, false);\r\nreturn 0;\r\n}\r\nstatic void sun4i_timer_clear_interrupt(void)\r\n{\r\nwritel(TIMER_IRQ_EN(0), timer_base + TIMER_IRQ_ST_REG);\r\n}\r\nstatic irqreturn_t sun4i_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = (struct clock_event_device *)dev_id;\r\nsun4i_timer_clear_interrupt();\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u64 notrace sun4i_timer_sched_read(void)\r\n{\r\nreturn ~readl(timer_base + TIMER_CNTVAL_REG(1));\r\n}\r\nstatic int __init sun4i_timer_init(struct device_node *node)\r\n{\r\nunsigned long rate = 0;\r\nstruct clk *clk;\r\nint ret, irq;\r\nu32 val;\r\ntimer_base = of_iomap(node, 0);\r\nif (!timer_base) {\r\npr_crit("Can't map registers");\r\nreturn -ENXIO;\r\n}\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0) {\r\npr_crit("Can't parse IRQ");\r\nreturn -EINVAL;\r\n}\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_crit("Can't get timer clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("Failed to prepare clock");\r\nreturn ret;\r\n}\r\nrate = clk_get_rate(clk);\r\nwritel(~0, timer_base + TIMER_INTVAL_REG(1));\r\nwritel(TIMER_CTL_ENABLE | TIMER_CTL_RELOAD |\r\nTIMER_CTL_CLK_SRC(TIMER_CTL_CLK_SRC_OSC24M),\r\ntimer_base + TIMER_CTL_REG(1));\r\nif (of_machine_is_compatible("allwinner,sun4i-a10") ||\r\nof_machine_is_compatible("allwinner,sun5i-a13") ||\r\nof_machine_is_compatible("allwinner,sun5i-a10s"))\r\nsched_clock_register(sun4i_timer_sched_read, 32, rate);\r\nret = clocksource_mmio_init(timer_base + TIMER_CNTVAL_REG(1), node->name,\r\nrate, 350, 32, clocksource_mmio_readl_down);\r\nif (ret) {\r\npr_err("Failed to register clocksource");\r\nreturn ret;\r\n}\r\nticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\r\nwritel(TIMER_CTL_CLK_SRC(TIMER_CTL_CLK_SRC_OSC24M),\r\ntimer_base + TIMER_CTL_REG(0));\r\nsun4i_clkevt_time_stop(0);\r\nsun4i_timer_clear_interrupt();\r\nsun4i_clockevent.cpumask = cpu_possible_mask;\r\nsun4i_clockevent.irq = irq;\r\nclockevents_config_and_register(&sun4i_clockevent, rate,\r\nTIMER_SYNC_TICKS, 0xffffffff);\r\nret = setup_irq(irq, &sun4i_timer_irq);\r\nif (ret) {\r\npr_err("failed to setup irq %d\n", irq);\r\nreturn ret;\r\n}\r\nval = readl(timer_base + TIMER_IRQ_EN_REG);\r\nwritel(val | TIMER_IRQ_EN(0), timer_base + TIMER_IRQ_EN_REG);\r\nreturn ret;\r\n}
