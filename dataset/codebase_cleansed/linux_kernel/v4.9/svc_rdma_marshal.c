static __be32 *decode_read_list(__be32 *va, __be32 *vaend)\r\n{\r\nstruct rpcrdma_read_chunk *ch = (struct rpcrdma_read_chunk *)va;\r\nwhile (ch->rc_discrim != xdr_zero) {\r\nif (((unsigned long)ch + sizeof(struct rpcrdma_read_chunk)) >\r\n(unsigned long)vaend) {\r\ndprintk("svcrdma: vaend=%p, ch=%p\n", vaend, ch);\r\nreturn NULL;\r\n}\r\nch++;\r\n}\r\nreturn &ch->rc_position;\r\n}\r\nstatic __be32 *decode_write_list(__be32 *va, __be32 *vaend)\r\n{\r\nunsigned long start, end;\r\nint nchunks;\r\nstruct rpcrdma_write_array *ary =\r\n(struct rpcrdma_write_array *)va;\r\nif (ary->wc_discrim == xdr_zero)\r\nreturn &ary->wc_nchunks;\r\nif ((unsigned long)ary + sizeof(struct rpcrdma_write_array) >\r\n(unsigned long)vaend) {\r\ndprintk("svcrdma: ary=%p, vaend=%p\n", ary, vaend);\r\nreturn NULL;\r\n}\r\nnchunks = be32_to_cpu(ary->wc_nchunks);\r\nstart = (unsigned long)&ary->wc_array[0];\r\nend = (unsigned long)vaend;\r\nif (nchunks < 0 ||\r\nnchunks > (SIZE_MAX - start) / sizeof(struct rpcrdma_write_chunk) ||\r\n(start + (sizeof(struct rpcrdma_write_chunk) * nchunks)) > end) {\r\ndprintk("svcrdma: ary=%p, wc_nchunks=%d, vaend=%p\n",\r\nary, nchunks, vaend);\r\nreturn NULL;\r\n}\r\nreturn &ary->wc_array[nchunks].wc_target.rs_length;\r\n}\r\nstatic __be32 *decode_reply_array(__be32 *va, __be32 *vaend)\r\n{\r\nunsigned long start, end;\r\nint nchunks;\r\nstruct rpcrdma_write_array *ary =\r\n(struct rpcrdma_write_array *)va;\r\nif (ary->wc_discrim == xdr_zero)\r\nreturn &ary->wc_nchunks;\r\nif ((unsigned long)ary + sizeof(struct rpcrdma_write_array) >\r\n(unsigned long)vaend) {\r\ndprintk("svcrdma: ary=%p, vaend=%p\n", ary, vaend);\r\nreturn NULL;\r\n}\r\nnchunks = be32_to_cpu(ary->wc_nchunks);\r\nstart = (unsigned long)&ary->wc_array[0];\r\nend = (unsigned long)vaend;\r\nif (nchunks < 0 ||\r\nnchunks > (SIZE_MAX - start) / sizeof(struct rpcrdma_write_chunk) ||\r\n(start + (sizeof(struct rpcrdma_write_chunk) * nchunks)) > end) {\r\ndprintk("svcrdma: ary=%p, wc_nchunks=%d, vaend=%p\n",\r\nary, nchunks, vaend);\r\nreturn NULL;\r\n}\r\nreturn (__be32 *)&ary->wc_array[nchunks];\r\n}\r\nint svc_rdma_xdr_decode_req(struct xdr_buf *rq_arg)\r\n{\r\nstruct rpcrdma_msg *rmsgp;\r\n__be32 *va, *vaend;\r\nunsigned int len;\r\nu32 hdr_len;\r\nif (rq_arg->len <= RPCRDMA_HDRLEN_ERR) {\r\ndprintk("svcrdma: header too short = %d\n",\r\nrq_arg->len);\r\nreturn -EINVAL;\r\n}\r\nrmsgp = (struct rpcrdma_msg *)rq_arg->head[0].iov_base;\r\nif (rmsgp->rm_vers != rpcrdma_version) {\r\ndprintk("%s: bad version %u\n", __func__,\r\nbe32_to_cpu(rmsgp->rm_vers));\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nswitch (be32_to_cpu(rmsgp->rm_type)) {\r\ncase RDMA_MSG:\r\ncase RDMA_NOMSG:\r\nbreak;\r\ncase RDMA_DONE:\r\ndprintk("svcrdma: dropping RDMA_DONE message\n");\r\nreturn 0;\r\ncase RDMA_ERROR:\r\ndprintk("svcrdma: dropping RDMA_ERROR message\n");\r\nreturn 0;\r\ncase RDMA_MSGP:\r\nrmsgp->rm_body.rm_padded.rm_align =\r\nbe32_to_cpu(rmsgp->rm_body.rm_padded.rm_align);\r\nrmsgp->rm_body.rm_padded.rm_thresh =\r\nbe32_to_cpu(rmsgp->rm_body.rm_padded.rm_thresh);\r\nva = &rmsgp->rm_body.rm_padded.rm_pempty[4];\r\nrq_arg->head[0].iov_base = va;\r\nlen = (u32)((unsigned long)va - (unsigned long)rmsgp);\r\nrq_arg->head[0].iov_len -= len;\r\nif (len > rq_arg->len)\r\nreturn -EINVAL;\r\nreturn len;\r\ndefault:\r\ndprintk("svcrdma: bad rdma procedure (%u)\n",\r\nbe32_to_cpu(rmsgp->rm_type));\r\nreturn -EINVAL;\r\n}\r\nva = &rmsgp->rm_body.rm_chunks[0];\r\nvaend = (__be32 *)((unsigned long)rmsgp + rq_arg->len);\r\nva = decode_read_list(va, vaend);\r\nif (!va) {\r\ndprintk("svcrdma: failed to decode read list\n");\r\nreturn -EINVAL;\r\n}\r\nva = decode_write_list(va, vaend);\r\nif (!va) {\r\ndprintk("svcrdma: failed to decode write list\n");\r\nreturn -EINVAL;\r\n}\r\nva = decode_reply_array(va, vaend);\r\nif (!va) {\r\ndprintk("svcrdma: failed to decode reply chunk\n");\r\nreturn -EINVAL;\r\n}\r\nrq_arg->head[0].iov_base = va;\r\nhdr_len = (unsigned long)va - (unsigned long)rmsgp;\r\nrq_arg->head[0].iov_len -= hdr_len;\r\nreturn hdr_len;\r\n}\r\nint svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,\r\nstruct rpcrdma_msg *rmsgp,\r\nenum rpcrdma_errcode err, __be32 *va)\r\n{\r\n__be32 *startp = va;\r\n*va++ = rmsgp->rm_xid;\r\n*va++ = rmsgp->rm_vers;\r\n*va++ = cpu_to_be32(xprt->sc_max_requests);\r\n*va++ = rdma_error;\r\n*va++ = cpu_to_be32(err);\r\nif (err == ERR_VERS) {\r\n*va++ = rpcrdma_version;\r\n*va++ = rpcrdma_version;\r\n}\r\nreturn (int)((unsigned long)va - (unsigned long)startp);\r\n}\r\nint svc_rdma_xdr_get_reply_hdr_len(struct rpcrdma_msg *rmsgp)\r\n{\r\nstruct rpcrdma_write_array *wr_ary;\r\nwr_ary = (struct rpcrdma_write_array *)\r\n&rmsgp->rm_body.rm_chunks[1];\r\nif (wr_ary->wc_discrim)\r\nwr_ary = (struct rpcrdma_write_array *)\r\n&wr_ary->wc_array[be32_to_cpu(wr_ary->wc_nchunks)].\r\nwc_target.rs_length;\r\nelse\r\nwr_ary = (struct rpcrdma_write_array *)\r\n&wr_ary->wc_nchunks;\r\nif (wr_ary->wc_discrim)\r\nwr_ary = (struct rpcrdma_write_array *)\r\n&wr_ary->wc_array[be32_to_cpu(wr_ary->wc_nchunks)];\r\nelse\r\nwr_ary = (struct rpcrdma_write_array *)\r\n&wr_ary->wc_nchunks;\r\nreturn (unsigned long) wr_ary - (unsigned long) rmsgp;\r\n}\r\nvoid svc_rdma_xdr_encode_write_list(struct rpcrdma_msg *rmsgp, int chunks)\r\n{\r\nstruct rpcrdma_write_array *ary;\r\nrmsgp->rm_body.rm_chunks[0] = xdr_zero;\r\nary = (struct rpcrdma_write_array *)\r\n&rmsgp->rm_body.rm_chunks[1];\r\nary->wc_discrim = xdr_one;\r\nary->wc_nchunks = cpu_to_be32(chunks);\r\nary->wc_array[chunks].wc_target.rs_handle = xdr_zero;\r\nary->wc_array[chunks].wc_target.rs_length = xdr_zero;\r\n}\r\nvoid svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\r\nint chunks)\r\n{\r\nary->wc_discrim = xdr_one;\r\nary->wc_nchunks = cpu_to_be32(chunks);\r\n}\r\nvoid svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *ary,\r\nint chunk_no,\r\n__be32 rs_handle,\r\n__be64 rs_offset,\r\nu32 write_len)\r\n{\r\nstruct rpcrdma_segment *seg = &ary->wc_array[chunk_no].wc_target;\r\nseg->rs_handle = rs_handle;\r\nseg->rs_offset = rs_offset;\r\nseg->rs_length = cpu_to_be32(write_len);\r\n}\r\nvoid svc_rdma_xdr_encode_reply_header(struct svcxprt_rdma *xprt,\r\nstruct rpcrdma_msg *rdma_argp,\r\nstruct rpcrdma_msg *rdma_resp,\r\nenum rpcrdma_proc rdma_type)\r\n{\r\nrdma_resp->rm_xid = rdma_argp->rm_xid;\r\nrdma_resp->rm_vers = rdma_argp->rm_vers;\r\nrdma_resp->rm_credit = cpu_to_be32(xprt->sc_max_requests);\r\nrdma_resp->rm_type = cpu_to_be32(rdma_type);\r\nrdma_resp->rm_body.rm_chunks[0] = xdr_zero;\r\nrdma_resp->rm_body.rm_chunks[1] = xdr_zero;\r\nrdma_resp->rm_body.rm_chunks[2] = xdr_zero;\r\n}
