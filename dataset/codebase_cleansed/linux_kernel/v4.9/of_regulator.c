static void of_get_regulation_constraints(struct device_node *np,\r\nstruct regulator_init_data **init_data,\r\nconst struct regulator_desc *desc)\r\n{\r\nstruct regulation_constraints *constraints = &(*init_data)->constraints;\r\nstruct regulator_state *suspend_state;\r\nstruct device_node *suspend_np;\r\nint ret, i;\r\nu32 pval;\r\nconstraints->name = of_get_property(np, "regulator-name", NULL);\r\nif (!of_property_read_u32(np, "regulator-min-microvolt", &pval))\r\nconstraints->min_uV = pval;\r\nif (!of_property_read_u32(np, "regulator-max-microvolt", &pval))\r\nconstraints->max_uV = pval;\r\nif (constraints->min_uV != constraints->max_uV)\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;\r\nif (constraints->min_uV && constraints->max_uV)\r\nconstraints->apply_uV = true;\r\nif (!of_property_read_u32(np, "regulator-microvolt-offset", &pval))\r\nconstraints->uV_offset = pval;\r\nif (!of_property_read_u32(np, "regulator-min-microamp", &pval))\r\nconstraints->min_uA = pval;\r\nif (!of_property_read_u32(np, "regulator-max-microamp", &pval))\r\nconstraints->max_uA = pval;\r\nif (!of_property_read_u32(np, "regulator-input-current-limit-microamp",\r\n&pval))\r\nconstraints->ilim_uA = pval;\r\nif (constraints->min_uA != constraints->max_uA)\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;\r\nconstraints->boot_on = of_property_read_bool(np, "regulator-boot-on");\r\nconstraints->always_on = of_property_read_bool(np, "regulator-always-on");\r\nif (!constraints->always_on)\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;\r\nconstraints->pull_down = of_property_read_bool(np, "regulator-pull-down");\r\nif (of_property_read_bool(np, "regulator-allow-bypass"))\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;\r\nif (of_property_read_bool(np, "regulator-allow-set-load"))\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_DRMS;\r\nret = of_property_read_u32(np, "regulator-ramp-delay", &pval);\r\nif (!ret) {\r\nif (pval)\r\nconstraints->ramp_delay = pval;\r\nelse\r\nconstraints->ramp_disable = true;\r\n}\r\nret = of_property_read_u32(np, "regulator-enable-ramp-delay", &pval);\r\nif (!ret)\r\nconstraints->enable_time = pval;\r\nconstraints->soft_start = of_property_read_bool(np,\r\n"regulator-soft-start");\r\nret = of_property_read_u32(np, "regulator-active-discharge", &pval);\r\nif (!ret) {\r\nconstraints->active_discharge =\r\n(pval) ? REGULATOR_ACTIVE_DISCHARGE_ENABLE :\r\nREGULATOR_ACTIVE_DISCHARGE_DISABLE;\r\n}\r\nif (!of_property_read_u32(np, "regulator-initial-mode", &pval)) {\r\nif (desc && desc->of_map_mode) {\r\nret = desc->of_map_mode(pval);\r\nif (ret == -EINVAL)\r\npr_err("%s: invalid mode %u\n", np->name, pval);\r\nelse\r\nconstraints->initial_mode = ret;\r\n} else {\r\npr_warn("%s: mapping for mode %d not defined\n",\r\nnp->name, pval);\r\n}\r\n}\r\nif (!of_property_read_u32(np, "regulator-system-load", &pval))\r\nconstraints->system_load = pval;\r\nconstraints->over_current_protection = of_property_read_bool(np,\r\n"regulator-over-current-protection");\r\nfor (i = 0; i < ARRAY_SIZE(regulator_states); i++) {\r\nswitch (i) {\r\ncase PM_SUSPEND_MEM:\r\nsuspend_state = &constraints->state_mem;\r\nbreak;\r\ncase PM_SUSPEND_MAX:\r\nsuspend_state = &constraints->state_disk;\r\nbreak;\r\ncase PM_SUSPEND_ON:\r\ncase PM_SUSPEND_FREEZE:\r\ncase PM_SUSPEND_STANDBY:\r\ndefault:\r\ncontinue;\r\n}\r\nsuspend_np = of_get_child_by_name(np, regulator_states[i]);\r\nif (!suspend_np || !suspend_state)\r\ncontinue;\r\nif (!of_property_read_u32(suspend_np, "regulator-mode",\r\n&pval)) {\r\nif (desc && desc->of_map_mode) {\r\nret = desc->of_map_mode(pval);\r\nif (ret == -EINVAL)\r\npr_err("%s: invalid mode %u\n",\r\nnp->name, pval);\r\nelse\r\nsuspend_state->mode = ret;\r\n} else {\r\npr_warn("%s: mapping for mode %d not defined\n",\r\nnp->name, pval);\r\n}\r\n}\r\nif (of_property_read_bool(suspend_np,\r\n"regulator-on-in-suspend"))\r\nsuspend_state->enabled = true;\r\nelse if (of_property_read_bool(suspend_np,\r\n"regulator-off-in-suspend"))\r\nsuspend_state->disabled = true;\r\nif (!of_property_read_u32(suspend_np,\r\n"regulator-suspend-microvolt", &pval))\r\nsuspend_state->uV = pval;\r\nif (i == PM_SUSPEND_MEM)\r\nconstraints->initial_state = PM_SUSPEND_MEM;\r\nof_node_put(suspend_np);\r\nsuspend_state = NULL;\r\nsuspend_np = NULL;\r\n}\r\n}\r\nstruct regulator_init_data *of_get_regulator_init_data(struct device *dev,\r\nstruct device_node *node,\r\nconst struct regulator_desc *desc)\r\n{\r\nstruct regulator_init_data *init_data;\r\nif (!node)\r\nreturn NULL;\r\ninit_data = devm_kzalloc(dev, sizeof(*init_data), GFP_KERNEL);\r\nif (!init_data)\r\nreturn NULL;\r\nof_get_regulation_constraints(node, &init_data, desc);\r\nreturn init_data;\r\n}\r\nstatic void devm_of_regulator_put_matches(struct device *dev, void *res)\r\n{\r\nstruct devm_of_regulator_matches *devm_matches = res;\r\nint i;\r\nfor (i = 0; i < devm_matches->num_matches; i++)\r\nof_node_put(devm_matches->matches[i].of_node);\r\n}\r\nint of_regulator_match(struct device *dev, struct device_node *node,\r\nstruct of_regulator_match *matches,\r\nunsigned int num_matches)\r\n{\r\nunsigned int count = 0;\r\nunsigned int i;\r\nconst char *name;\r\nstruct device_node *child;\r\nstruct devm_of_regulator_matches *devm_matches;\r\nif (!dev || !node)\r\nreturn -EINVAL;\r\ndevm_matches = devres_alloc(devm_of_regulator_put_matches,\r\nsizeof(struct devm_of_regulator_matches),\r\nGFP_KERNEL);\r\nif (!devm_matches)\r\nreturn -ENOMEM;\r\ndevm_matches->matches = matches;\r\ndevm_matches->num_matches = num_matches;\r\ndevres_add(dev, devm_matches);\r\nfor (i = 0; i < num_matches; i++) {\r\nstruct of_regulator_match *match = &matches[i];\r\nmatch->init_data = NULL;\r\nmatch->of_node = NULL;\r\n}\r\nfor_each_child_of_node(node, child) {\r\nname = of_get_property(child,\r\n"regulator-compatible", NULL);\r\nif (!name)\r\nname = child->name;\r\nfor (i = 0; i < num_matches; i++) {\r\nstruct of_regulator_match *match = &matches[i];\r\nif (match->of_node)\r\ncontinue;\r\nif (strcmp(match->name, name))\r\ncontinue;\r\nmatch->init_data =\r\nof_get_regulator_init_data(dev, child,\r\nmatch->desc);\r\nif (!match->init_data) {\r\ndev_err(dev,\r\n"failed to parse DT for regulator %s\n",\r\nchild->name);\r\nreturn -EINVAL;\r\n}\r\nmatch->of_node = of_node_get(child);\r\ncount++;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstruct regulator_init_data *regulator_of_get_init_data(struct device *dev,\r\nconst struct regulator_desc *desc,\r\nstruct regulator_config *config,\r\nstruct device_node **node)\r\n{\r\nstruct device_node *search, *child;\r\nstruct regulator_init_data *init_data = NULL;\r\nconst char *name;\r\nif (!dev->of_node || !desc->of_match)\r\nreturn NULL;\r\nif (desc->regulators_node)\r\nsearch = of_get_child_by_name(dev->of_node,\r\ndesc->regulators_node);\r\nelse\r\nsearch = dev->of_node;\r\nif (!search) {\r\ndev_dbg(dev, "Failed to find regulator container node '%s'\n",\r\ndesc->regulators_node);\r\nreturn NULL;\r\n}\r\nfor_each_available_child_of_node(search, child) {\r\nname = of_get_property(child, "regulator-compatible", NULL);\r\nif (!name)\r\nname = child->name;\r\nif (strcmp(desc->of_match, name))\r\ncontinue;\r\ninit_data = of_get_regulator_init_data(dev, child, desc);\r\nif (!init_data) {\r\ndev_err(dev,\r\n"failed to parse DT for regulator %s\n",\r\nchild->name);\r\nbreak;\r\n}\r\nif (desc->of_parse_cb) {\r\nif (desc->of_parse_cb(child, desc, config)) {\r\ndev_err(dev,\r\n"driver callback failed to parse DT for regulator %s\n",\r\nchild->name);\r\ninit_data = NULL;\r\nbreak;\r\n}\r\n}\r\nof_node_get(child);\r\n*node = child;\r\nbreak;\r\n}\r\nof_node_put(search);\r\nreturn init_data;\r\n}
