static void z_comp_free(void *arg)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nif (state) {\r\nzlib_deflateEnd(&state->strm);\r\nvfree(state->strm.workspace);\r\nkfree(state);\r\n}\r\n}\r\nstatic void *z_comp_alloc(unsigned char *options, int opt_len)\r\n{\r\nstruct ppp_deflate_state *state;\r\nint w_size;\r\nif (opt_len != CILEN_DEFLATE ||\r\n(options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\r\noptions[1] != CILEN_DEFLATE ||\r\nDEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\r\noptions[3] != DEFLATE_CHK_SEQUENCE)\r\nreturn NULL;\r\nw_size = DEFLATE_SIZE(options[2]);\r\nif (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)\r\nreturn NULL;\r\nstate = kzalloc(sizeof(*state),\r\nGFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->strm.next_in = NULL;\r\nstate->w_size = w_size;\r\nstate->strm.workspace = vmalloc(zlib_deflate_workspacesize(-w_size, 8));\r\nif (state->strm.workspace == NULL)\r\ngoto out_free;\r\nif (zlib_deflateInit2(&state->strm, Z_DEFAULT_COMPRESSION,\r\nDEFLATE_METHOD_VAL, -w_size, 8, Z_DEFAULT_STRATEGY)\r\n!= Z_OK)\r\ngoto out_free;\r\nreturn (void *) state;\r\nout_free:\r\nz_comp_free(state);\r\nreturn NULL;\r\n}\r\nstatic int z_comp_init(void *arg, unsigned char *options, int opt_len,\r\nint unit, int hdrlen, int debug)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nif (opt_len < CILEN_DEFLATE ||\r\n(options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\r\noptions[1] != CILEN_DEFLATE ||\r\nDEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\r\nDEFLATE_SIZE(options[2]) != state->w_size ||\r\noptions[3] != DEFLATE_CHK_SEQUENCE)\r\nreturn 0;\r\nstate->seqno = 0;\r\nstate->unit = unit;\r\nstate->debug = debug;\r\nzlib_deflateReset(&state->strm);\r\nreturn 1;\r\n}\r\nstatic void z_comp_reset(void *arg)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nstate->seqno = 0;\r\nzlib_deflateReset(&state->strm);\r\n}\r\nstatic int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,\r\nint isize, int osize)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nint r, proto, off, olen, oavail;\r\nunsigned char *wptr;\r\nproto = PPP_PROTOCOL(rptr);\r\nif (proto > 0x3fff || proto == 0xfd || proto == 0xfb)\r\nreturn 0;\r\nif (osize > isize)\r\nosize = isize;\r\nwptr = obuf;\r\nwptr[0] = PPP_ADDRESS(rptr);\r\nwptr[1] = PPP_CONTROL(rptr);\r\nput_unaligned_be16(PPP_COMP, wptr + 2);\r\nwptr += PPP_HDRLEN;\r\nput_unaligned_be16(state->seqno, wptr);\r\nwptr += DEFLATE_OVHD;\r\nolen = PPP_HDRLEN + DEFLATE_OVHD;\r\nstate->strm.next_out = wptr;\r\nstate->strm.avail_out = oavail = osize - olen;\r\n++state->seqno;\r\noff = (proto > 0xff) ? 2 : 3;\r\nrptr += off;\r\nstate->strm.next_in = rptr;\r\nstate->strm.avail_in = (isize - off);\r\nfor (;;) {\r\nr = zlib_deflate(&state->strm, Z_PACKET_FLUSH);\r\nif (r != Z_OK) {\r\nif (state->debug)\r\nprintk(KERN_ERR\r\n"z_compress: deflate returned %d\n", r);\r\nbreak;\r\n}\r\nif (state->strm.avail_out == 0) {\r\nolen += oavail;\r\nstate->strm.next_out = NULL;\r\nstate->strm.avail_out = oavail = 1000000;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nolen += oavail - state->strm.avail_out;\r\nif (olen < isize && olen <= osize) {\r\nstate->stats.comp_bytes += olen;\r\nstate->stats.comp_packets++;\r\n} else {\r\nstate->stats.inc_bytes += isize;\r\nstate->stats.inc_packets++;\r\nolen = 0;\r\n}\r\nstate->stats.unc_bytes += isize;\r\nstate->stats.unc_packets++;\r\nreturn olen;\r\n}\r\nstatic void z_comp_stats(void *arg, struct compstat *stats)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\n*stats = state->stats;\r\n}\r\nstatic void z_decomp_free(void *arg)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nif (state) {\r\nzlib_inflateEnd(&state->strm);\r\nvfree(state->strm.workspace);\r\nkfree(state);\r\n}\r\n}\r\nstatic void *z_decomp_alloc(unsigned char *options, int opt_len)\r\n{\r\nstruct ppp_deflate_state *state;\r\nint w_size;\r\nif (opt_len != CILEN_DEFLATE ||\r\n(options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\r\noptions[1] != CILEN_DEFLATE ||\r\nDEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\r\noptions[3] != DEFLATE_CHK_SEQUENCE)\r\nreturn NULL;\r\nw_size = DEFLATE_SIZE(options[2]);\r\nif (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)\r\nreturn NULL;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->w_size = w_size;\r\nstate->strm.next_out = NULL;\r\nstate->strm.workspace = vmalloc(zlib_inflate_workspacesize());\r\nif (state->strm.workspace == NULL)\r\ngoto out_free;\r\nif (zlib_inflateInit2(&state->strm, -w_size) != Z_OK)\r\ngoto out_free;\r\nreturn (void *) state;\r\nout_free:\r\nz_decomp_free(state);\r\nreturn NULL;\r\n}\r\nstatic int z_decomp_init(void *arg, unsigned char *options, int opt_len,\r\nint unit, int hdrlen, int mru, int debug)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nif (opt_len < CILEN_DEFLATE ||\r\n(options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\r\noptions[1] != CILEN_DEFLATE ||\r\nDEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\r\nDEFLATE_SIZE(options[2]) != state->w_size ||\r\noptions[3] != DEFLATE_CHK_SEQUENCE)\r\nreturn 0;\r\nstate->seqno = 0;\r\nstate->unit = unit;\r\nstate->debug = debug;\r\nstate->mru = mru;\r\nzlib_inflateReset(&state->strm);\r\nreturn 1;\r\n}\r\nstatic void z_decomp_reset(void *arg)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nstate->seqno = 0;\r\nzlib_inflateReset(&state->strm);\r\n}\r\nstatic int z_decompress(void *arg, unsigned char *ibuf, int isize,\r\nunsigned char *obuf, int osize)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nint olen, seq, r;\r\nint decode_proto, overflow;\r\nunsigned char overflow_buf[1];\r\nif (isize <= PPP_HDRLEN + DEFLATE_OVHD) {\r\nif (state->debug)\r\nprintk(KERN_DEBUG "z_decompress%d: short pkt (%d)\n",\r\nstate->unit, isize);\r\nreturn DECOMP_ERROR;\r\n}\r\nseq = get_unaligned_be16(ibuf + PPP_HDRLEN);\r\nif (seq != (state->seqno & 0xffff)) {\r\nif (state->debug)\r\nprintk(KERN_DEBUG "z_decompress%d: bad seq # %d, expected %d\n",\r\nstate->unit, seq, state->seqno & 0xffff);\r\nreturn DECOMP_ERROR;\r\n}\r\n++state->seqno;\r\nobuf[0] = PPP_ADDRESS(ibuf);\r\nobuf[1] = PPP_CONTROL(ibuf);\r\nobuf[2] = 0;\r\nstate->strm.next_in = ibuf + PPP_HDRLEN + DEFLATE_OVHD;\r\nstate->strm.avail_in = isize - (PPP_HDRLEN + DEFLATE_OVHD);\r\nstate->strm.next_out = obuf + 3;\r\nstate->strm.avail_out = 1;\r\ndecode_proto = 1;\r\noverflow = 0;\r\nfor (;;) {\r\nr = zlib_inflate(&state->strm, Z_PACKET_FLUSH);\r\nif (r != Z_OK) {\r\nif (state->debug)\r\nprintk(KERN_DEBUG "z_decompress%d: inflate returned %d (%s)\n",\r\nstate->unit, r, (state->strm.msg? state->strm.msg: ""));\r\nreturn DECOMP_FATALERROR;\r\n}\r\nif (state->strm.avail_out != 0)\r\nbreak;\r\nif (decode_proto) {\r\nstate->strm.avail_out = osize - PPP_HDRLEN;\r\nif ((obuf[3] & 1) == 0) {\r\nobuf[2] = obuf[3];\r\n--state->strm.next_out;\r\n++state->strm.avail_out;\r\n}\r\ndecode_proto = 0;\r\n} else if (!overflow) {\r\nstate->strm.next_out = overflow_buf;\r\nstate->strm.avail_out = 1;\r\noverflow = 1;\r\n} else {\r\nif (state->debug)\r\nprintk(KERN_DEBUG "z_decompress%d: ran out of mru\n",\r\nstate->unit);\r\nreturn DECOMP_FATALERROR;\r\n}\r\n}\r\nif (decode_proto) {\r\nif (state->debug)\r\nprintk(KERN_DEBUG "z_decompress%d: didn't get proto\n",\r\nstate->unit);\r\nreturn DECOMP_ERROR;\r\n}\r\nolen = osize + overflow - state->strm.avail_out;\r\nstate->stats.unc_bytes += olen;\r\nstate->stats.unc_packets++;\r\nstate->stats.comp_bytes += isize;\r\nstate->stats.comp_packets++;\r\nreturn olen;\r\n}\r\nstatic void z_incomp(void *arg, unsigned char *ibuf, int icnt)\r\n{\r\nstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\r\nint proto, r;\r\nproto = PPP_PROTOCOL(ibuf);\r\nif (proto > 0x3fff || proto == 0xfd || proto == 0xfb)\r\nreturn;\r\n++state->seqno;\r\nstate->strm.next_in = ibuf + 3;\r\nstate->strm.avail_in = icnt - 3;\r\nif (proto > 0xff) {\r\n--state->strm.next_in;\r\n++state->strm.avail_in;\r\n}\r\nr = zlib_inflateIncomp(&state->strm);\r\nif (r != Z_OK) {\r\nif (state->debug) {\r\nprintk(KERN_DEBUG "z_incomp%d: inflateIncomp returned %d (%s)\n",\r\nstate->unit, r, (state->strm.msg? state->strm.msg: ""));\r\n}\r\nreturn;\r\n}\r\nstate->stats.inc_bytes += icnt;\r\nstate->stats.inc_packets++;\r\nstate->stats.unc_bytes += icnt;\r\nstate->stats.unc_packets++;\r\n}\r\nstatic int __init deflate_init(void)\r\n{\r\nint answer = ppp_register_compressor(&ppp_deflate);\r\nif (answer == 0)\r\nprintk(KERN_INFO\r\n"PPP Deflate Compression module registered\n");\r\nppp_register_compressor(&ppp_deflate_draft);\r\nreturn answer;\r\n}\r\nstatic void __exit deflate_cleanup(void)\r\n{\r\nppp_unregister_compressor(&ppp_deflate);\r\nppp_unregister_compressor(&ppp_deflate_draft);\r\n}
