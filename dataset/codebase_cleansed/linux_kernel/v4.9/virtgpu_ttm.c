static struct\r\nvirtio_gpu_device *virtio_gpu_get_vgdev(struct ttm_bo_device *bdev)\r\n{\r\nstruct virtio_gpu_mman *mman;\r\nstruct virtio_gpu_device *vgdev;\r\nmman = container_of(bdev, struct virtio_gpu_mman, bdev);\r\nvgdev = container_of(mman, struct virtio_gpu_device, mman);\r\nreturn vgdev;\r\n}\r\nstatic int virtio_gpu_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void virtio_gpu_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nstatic int virtio_gpu_ttm_global_init(struct virtio_gpu_device *vgdev)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint r;\r\nvgdev->mman.mem_global_referenced = false;\r\nglobal_ref = &vgdev->mman.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &virtio_gpu_ttm_mem_global_init;\r\nglobal_ref->release = &virtio_gpu_ttm_mem_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM memory accounting "\r\n"subsystem.\n");\r\nreturn r;\r\n}\r\nvgdev->mman.bo_global_ref.mem_glob =\r\nvgdev->mman.mem_global_ref.object;\r\nglobal_ref = &vgdev->mman.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem.\n");\r\ndrm_global_item_unref(&vgdev->mman.mem_global_ref);\r\nreturn r;\r\n}\r\nvgdev->mman.mem_global_referenced = true;\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_ttm_global_fini(struct virtio_gpu_device *vgdev)\r\n{\r\nif (vgdev->mman.mem_global_referenced) {\r\ndrm_global_item_unref(&vgdev->mman.bo_global_ref.ref);\r\ndrm_global_item_unref(&vgdev->mman.mem_global_ref);\r\nvgdev->mman.mem_global_referenced = false;\r\n}\r\n}\r\nint virtio_gpu_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct virtio_gpu_device *vgdev;\r\nint r;\r\nfile_priv = filp->private_data;\r\nvgdev = file_priv->minor->dev->dev_private;\r\nif (vgdev == NULL) {\r\nDRM_ERROR(\r\n"filp->private_data->minor->dev->dev_private == NULL\n");\r\nreturn -EINVAL;\r\n}\r\nr = ttm_bo_mmap(filp, vma, &vgdev->mman.bdev);\r\n#if 0\r\nif (unlikely(r != 0))\r\nreturn r;\r\nif (unlikely(ttm_vm_ops == NULL)) {\r\nttm_vm_ops = vma->vm_ops;\r\nvirtio_gpu_ttm_vm_ops = *ttm_vm_ops;\r\nvirtio_gpu_ttm_vm_ops.fault = &virtio_gpu_ttm_fault;\r\n}\r\nvma->vm_ops = &virtio_gpu_ttm_vm_ops;\r\nreturn 0;\r\n#else\r\nreturn r;\r\n#endif\r\n}\r\nstatic int virtio_gpu_invalidate_caches(struct ttm_bo_device *bdev,\r\nuint32_t flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ttm_bo_man_get_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nconst struct ttm_place *place,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nmem->mm_node = (void *)1;\r\nreturn 0;\r\n}\r\nstatic void ttm_bo_man_put_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nmem->mm_node = (void *)NULL;\r\nreturn;\r\n}\r\nstatic int ttm_bo_man_init(struct ttm_mem_type_manager *man,\r\nunsigned long p_size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ttm_bo_man_takedown(struct ttm_mem_type_manager *man)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ttm_bo_man_debug(struct ttm_mem_type_manager *man,\r\nconst char *prefix)\r\n{\r\n}\r\nstatic int virtio_gpu_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,\r\nstruct ttm_mem_type_manager *man)\r\n{\r\nstruct virtio_gpu_device *vgdev;\r\nvgdev = virtio_gpu_get_vgdev(bdev);\r\nswitch (type) {\r\ncase TTM_PL_SYSTEM:\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ncase TTM_PL_TT:\r\nman->func = &virtio_gpu_bo_manager_func;\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported memory type %u\n", (unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_evict_flags(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement)\r\n{\r\nstatic struct ttm_place placements = {\r\n.fpfn = 0,\r\n.lpfn = 0,\r\n.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM,\r\n};\r\nplacement->placement = &placements;\r\nplacement->busy_placement = &placements;\r\nplacement->num_placement = 1;\r\nplacement->num_busy_placement = 1;\r\nreturn;\r\n}\r\nstatic int virtio_gpu_verify_access(struct ttm_buffer_object *bo,\r\nstruct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int virtio_gpu_ttm_io_mem_reserve(struct ttm_bo_device *bdev,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nmem->bus.addr = NULL;\r\nmem->bus.offset = 0;\r\nmem->bus.size = mem->num_pages << PAGE_SHIFT;\r\nmem->bus.base = 0;\r\nmem->bus.is_iomem = false;\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))\r\nreturn -EINVAL;\r\nswitch (mem->mem_type) {\r\ncase TTM_PL_SYSTEM:\r\ncase TTM_PL_TT:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_ttm_io_mem_free(struct ttm_bo_device *bdev,\r\nstruct ttm_mem_reg *mem)\r\n{\r\n}\r\nstatic int virtio_gpu_ttm_backend_bind(struct ttm_tt *ttm,\r\nstruct ttm_mem_reg *bo_mem)\r\n{\r\nstruct virtio_gpu_ttm_tt *gtt = (void *)ttm;\r\ngtt->offset = (unsigned long)(bo_mem->start << PAGE_SHIFT);\r\nif (!ttm->num_pages)\r\nWARN(1, "nothing to bind %lu pages for mreg %p back %p!\n",\r\nttm->num_pages, bo_mem, ttm);\r\nreturn 0;\r\n}\r\nstatic int virtio_gpu_ttm_backend_unbind(struct ttm_tt *ttm)\r\n{\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_ttm_backend_destroy(struct ttm_tt *ttm)\r\n{\r\nstruct virtio_gpu_ttm_tt *gtt = (void *)ttm;\r\nttm_dma_tt_fini(&gtt->ttm);\r\nkfree(gtt);\r\n}\r\nstatic int virtio_gpu_ttm_tt_populate(struct ttm_tt *ttm)\r\n{\r\nif (ttm->state != tt_unpopulated)\r\nreturn 0;\r\nreturn ttm_pool_populate(ttm);\r\n}\r\nstatic void virtio_gpu_ttm_tt_unpopulate(struct ttm_tt *ttm)\r\n{\r\nttm_pool_unpopulate(ttm);\r\n}\r\nstatic struct ttm_tt *virtio_gpu_ttm_tt_create(struct ttm_bo_device *bdev,\r\nunsigned long size,\r\nuint32_t page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nstruct virtio_gpu_device *vgdev;\r\nstruct virtio_gpu_ttm_tt *gtt;\r\nvgdev = virtio_gpu_get_vgdev(bdev);\r\ngtt = kzalloc(sizeof(struct virtio_gpu_ttm_tt), GFP_KERNEL);\r\nif (gtt == NULL)\r\nreturn NULL;\r\ngtt->ttm.ttm.func = &virtio_gpu_backend_func;\r\ngtt->vgdev = vgdev;\r\nif (ttm_dma_tt_init(&gtt->ttm, bdev, size, page_flags,\r\ndummy_read_page)) {\r\nkfree(gtt);\r\nreturn NULL;\r\n}\r\nreturn &gtt->ttm.ttm;\r\n}\r\nstatic void virtio_gpu_move_null(struct ttm_buffer_object *bo,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nBUG_ON(old_mem->mm_node != NULL);\r\n*old_mem = *new_mem;\r\nnew_mem->mm_node = NULL;\r\n}\r\nstatic int virtio_gpu_bo_move(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nint ret;\r\nret = ttm_bo_wait(bo, interruptible, no_wait_gpu);\r\nif (ret)\r\nreturn ret;\r\nvirtio_gpu_move_null(bo, new_mem);\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_bo_move_notify(struct ttm_buffer_object *tbo,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct virtio_gpu_object *bo;\r\nstruct virtio_gpu_device *vgdev;\r\nbo = container_of(tbo, struct virtio_gpu_object, tbo);\r\nvgdev = (struct virtio_gpu_device *)bo->gem_base.dev->dev_private;\r\nif (!new_mem || (new_mem->placement & TTM_PL_FLAG_SYSTEM)) {\r\nif (bo->hw_res_handle)\r\nvirtio_gpu_cmd_resource_inval_backing(vgdev,\r\nbo->hw_res_handle);\r\n} else if (new_mem->placement & TTM_PL_FLAG_TT) {\r\nif (bo->hw_res_handle) {\r\nvirtio_gpu_object_attach(vgdev, bo, bo->hw_res_handle,\r\nNULL);\r\n}\r\n}\r\n}\r\nstatic void virtio_gpu_bo_swap_notify(struct ttm_buffer_object *tbo)\r\n{\r\nstruct virtio_gpu_object *bo;\r\nstruct virtio_gpu_device *vgdev;\r\nbo = container_of(tbo, struct virtio_gpu_object, tbo);\r\nvgdev = (struct virtio_gpu_device *)bo->gem_base.dev->dev_private;\r\nif (bo->pages)\r\nvirtio_gpu_object_free_sg_table(bo);\r\n}\r\nint virtio_gpu_ttm_init(struct virtio_gpu_device *vgdev)\r\n{\r\nint r;\r\nr = virtio_gpu_ttm_global_init(vgdev);\r\nif (r)\r\nreturn r;\r\nr = ttm_bo_device_init(&vgdev->mman.bdev,\r\nvgdev->mman.bo_global_ref.ref.object,\r\n&virtio_gpu_bo_driver,\r\nvgdev->ddev->anon_inode->i_mapping,\r\nDRM_FILE_PAGE_OFFSET, 0);\r\nif (r) {\r\nDRM_ERROR("failed initializing buffer object driver(%d).\n", r);\r\ngoto err_dev_init;\r\n}\r\nr = ttm_bo_init_mm(&vgdev->mman.bdev, TTM_PL_TT, 0);\r\nif (r) {\r\nDRM_ERROR("Failed initializing GTT heap.\n");\r\ngoto err_mm_init;\r\n}\r\nreturn 0;\r\nerr_mm_init:\r\nttm_bo_device_release(&vgdev->mman.bdev);\r\nerr_dev_init:\r\nvirtio_gpu_ttm_global_fini(vgdev);\r\nreturn r;\r\n}\r\nvoid virtio_gpu_ttm_fini(struct virtio_gpu_device *vgdev)\r\n{\r\nttm_bo_device_release(&vgdev->mman.bdev);\r\nvirtio_gpu_ttm_global_fini(vgdev);\r\nDRM_INFO("virtio_gpu: ttm finalized\n");\r\n}
