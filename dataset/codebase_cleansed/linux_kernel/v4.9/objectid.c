static void check_objectid_map(struct super_block *s, __le32 * map)\r\n{\r\nif (le32_to_cpu(map[0]) != 1)\r\nreiserfs_panic(s, "vs-15010", "map corrupted: %lx",\r\n(long unsigned int)le32_to_cpu(map[0]));\r\n}\r\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\r\n{;\r\n}\r\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\r\n{\r\nstruct super_block *s = th->t_super;\r\nstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\r\n__le32 *map = objectid_map(s, rs);\r\n__u32 unused_objectid;\r\nBUG_ON(!th->t_trans_id);\r\ncheck_objectid_map(s, map);\r\nreiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\r\nunused_objectid = le32_to_cpu(map[1]);\r\nif (unused_objectid == U32_MAX) {\r\nreiserfs_warning(s, "reiserfs-15100", "no more object ids");\r\nreiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\r\nreturn 0;\r\n}\r\nmap[1] = cpu_to_le32(unused_objectid + 1);\r\nif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\r\nmemmove(map + 1, map + 3,\r\n(sb_oid_cursize(rs) - 3) * sizeof(__u32));\r\nset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\r\n}\r\njournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\r\nreturn unused_objectid;\r\n}\r\nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\r\n__u32 objectid_to_release)\r\n{\r\nstruct super_block *s = th->t_super;\r\nstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\r\n__le32 *map = objectid_map(s, rs);\r\nint i = 0;\r\nBUG_ON(!th->t_trans_id);\r\ncheck_objectid_map(s, map);\r\nreiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\r\njournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\r\nwhile (i < sb_oid_cursize(rs)) {\r\nif (objectid_to_release == le32_to_cpu(map[i])) {\r\nle32_add_cpu(&map[i], 1);\r\nif (map[i] == map[i + 1]) {\r\nmemmove(map + i, map + i + 2,\r\n(sb_oid_cursize(rs) - i -\r\n2) * sizeof(__u32));\r\nset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\r\nRFALSE(sb_oid_cursize(rs) < 2 ||\r\nsb_oid_cursize(rs) > sb_oid_maxsize(rs),\r\n"vs-15005: objectid map corrupted cur_size == %d (max == %d)",\r\nsb_oid_cursize(rs), sb_oid_maxsize(rs));\r\n}\r\nreturn;\r\n}\r\nif (objectid_to_release > le32_to_cpu(map[i]) &&\r\nobjectid_to_release < le32_to_cpu(map[i + 1])) {\r\nif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\r\nle32_add_cpu(&map[i + 1], -1);\r\nreturn;\r\n}\r\nif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\r\nPROC_INFO_INC(s, leaked_oid);\r\nreturn;\r\n}\r\nmemmove(map + i + 3, map + i + 1,\r\n(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\r\nmap[i + 1] = cpu_to_le32(objectid_to_release);\r\nmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\r\nset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\r\nreturn;\r\n}\r\ni += 2;\r\n}\r\nreiserfs_error(s, "vs-15011", "tried to free free object id (%lu)",\r\n(long unsigned)objectid_to_release);\r\n}\r\nint reiserfs_convert_objectid_map_v1(struct super_block *s)\r\n{\r\nstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\r\nint cur_size = sb_oid_cursize(disk_sb);\r\nint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\r\nint old_max = sb_oid_maxsize(disk_sb);\r\nstruct reiserfs_super_block_v1 *disk_sb_v1;\r\n__le32 *objectid_map, *new_objectid_map;\r\nint i;\r\ndisk_sb_v1 =\r\n(struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\r\nobjectid_map = (__le32 *) (disk_sb_v1 + 1);\r\nnew_objectid_map = (__le32 *) (disk_sb + 1);\r\nif (cur_size > new_size) {\r\nobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\r\nset_sb_oid_cursize(disk_sb, new_size);\r\n}\r\nfor (i = new_size - 1; i >= 0; i--) {\r\nobjectid_map[i + (old_max - new_size)] = objectid_map[i];\r\n}\r\nset_sb_oid_maxsize(disk_sb, new_size);\r\nmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\r\ngenerate_random_uuid(disk_sb->s_uuid);\r\nmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\r\nreturn 0;\r\n}
