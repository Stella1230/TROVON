static u8\r\nacpi_hw_get_access_bit_width(struct acpi_generic_address *reg, u8 max_bit_width)\r\n{\r\nif (!reg->access_width) {\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\r\nmax_bit_width = 32;\r\n}\r\nif (reg->bit_width < max_bit_width &&\r\n!reg->bit_offset && reg->bit_width &&\r\nACPI_IS_POWER_OF_TWO(reg->bit_width) &&\r\nACPI_IS_ALIGNED(reg->bit_width, 8)) {\r\nreturn (reg->bit_width);\r\n}\r\nreturn (max_bit_width);\r\n} else {\r\nreturn (1 << (reg->access_width + 2));\r\n}\r\n}\r\nacpi_status\r\nacpi_hw_validate_register(struct acpi_generic_address *reg,\r\nu8 max_bit_width, u64 *address)\r\n{\r\nu8 bit_width;\r\nu8 access_width;\r\nif (!reg) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nACPI_MOVE_64_TO_64(address, &reg->address);\r\nif (!(*address)) {\r\nreturn (AE_BAD_ADDRESS);\r\n}\r\nif ((reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&\r\n(reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {\r\nACPI_ERROR((AE_INFO,\r\n"Unsupported address space: 0x%X", reg->space_id));\r\nreturn (AE_SUPPORT);\r\n}\r\nif (reg->access_width > 4) {\r\nACPI_ERROR((AE_INFO,\r\n"Unsupported register access width: 0x%X",\r\nreg->access_width));\r\nreturn (AE_SUPPORT);\r\n}\r\naccess_width = acpi_hw_get_access_bit_width(reg, max_bit_width);\r\nbit_width =\r\nACPI_ROUND_UP(reg->bit_offset + reg->bit_width, access_width);\r\nif (max_bit_width < bit_width) {\r\nACPI_WARNING((AE_INFO,\r\n"Requested bit width 0x%X is smaller than register bit width 0x%X",\r\nmax_bit_width, bit_width));\r\nreturn (AE_SUPPORT);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_hw_read(u32 *value, struct acpi_generic_address *reg)\r\n{\r\nu64 address;\r\nu8 access_width;\r\nu32 bit_width;\r\nu8 bit_offset;\r\nu64 value64;\r\nu32 value32;\r\nu8 index;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(hw_read);\r\nstatus = acpi_hw_validate_register(reg, 32, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*value = 0;\r\naccess_width = acpi_hw_get_access_bit_width(reg, 32);\r\nbit_width = reg->bit_offset + reg->bit_width;\r\nbit_offset = reg->bit_offset;\r\nindex = 0;\r\nwhile (bit_width) {\r\nif (bit_offset >= access_width) {\r\nvalue32 = 0;\r\nbit_offset -= access_width;\r\n} else {\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus =\r\nacpi_os_read_memory((acpi_physical_address)\r\naddress +\r\nindex *\r\nACPI_DIV_8\r\n(access_width),\r\n&value64, access_width);\r\nvalue32 = (u32)value64;\r\n} else {\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\naddress +\r\nindex *\r\nACPI_DIV_8\r\n(access_width),\r\n&value32,\r\naccess_width);\r\n}\r\nif (bit_offset) {\r\nvalue32 &= ACPI_MASK_BITS_BELOW(bit_offset);\r\nbit_offset = 0;\r\n}\r\nif (bit_width < access_width) {\r\nvalue32 &= ACPI_MASK_BITS_ABOVE(bit_width);\r\n}\r\n}\r\nACPI_SET_BITS(value, index * access_width,\r\nACPI_MASK_BITS_ABOVE_32(access_width), value32);\r\nbit_width -=\r\nbit_width > access_width ? access_width : bit_width;\r\nindex++;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Read: %8.8X width %2d from %8.8X%8.8X (%s)\n",\r\n*value, access_width, ACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_hw_write(u32 value, struct acpi_generic_address *reg)\r\n{\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(hw_write);\r\nstatus = acpi_hw_validate_register(reg, 32, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_write_memory((acpi_physical_address)\r\naddress, (u64)value,\r\nreg->bit_width);\r\n} else {\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\naddress, value, reg->bit_width);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Wrote: %8.8X width %2d to %8.8X%8.8X (%s)\n",\r\nvalue, reg->bit_width, ACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_hw_clear_acpi_status(void)\r\n{\r\nacpi_status status;\r\nacpi_cpu_flags lock_flags = 0;\r\nACPI_FUNCTION_TRACE(hw_clear_acpi_status);\r\nACPI_DEBUG_PRINT((ACPI_DB_IO, "About to write %04X to %8.8X%8.8X\n",\r\nACPI_BITMASK_ALL_FIXED_STATUS,\r\nACPI_FORMAT_UINT64(acpi_gbl_xpm1a_status.address)));\r\nlock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);\r\nstatus = acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\r\nACPI_BITMASK_ALL_FIXED_STATUS);\r\nacpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nstatus = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);\r\nexit:\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstruct acpi_bit_register_info *acpi_hw_get_bit_register_info(u32 register_id)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif (register_id > ACPI_BITREG_MAX) {\r\nACPI_ERROR((AE_INFO, "Invalid BitRegister ID: 0x%X",\r\nregister_id));\r\nreturn (NULL);\r\n}\r\nreturn (&acpi_gbl_bit_register_info[register_id]);\r\n}\r\nacpi_status acpi_hw_write_pm1_control(u32 pm1a_control, u32 pm1b_control)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(hw_write_pm1_control);\r\nstatus =\r\nacpi_hw_write(pm1a_control, &acpi_gbl_FADT.xpm1a_control_block);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_FADT.xpm1b_control_block.address) {\r\nstatus =\r\nacpi_hw_write(pm1b_control,\r\n&acpi_gbl_FADT.xpm1b_control_block);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_hw_register_read(u32 register_id, u32 *return_value)\r\n{\r\nu32 value = 0;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(hw_register_read);\r\nswitch (register_id) {\r\ncase ACPI_REGISTER_PM1_STATUS:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_xpm1a_status,\r\n&acpi_gbl_xpm1b_status);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_ENABLE:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_xpm1a_enable,\r\n&acpi_gbl_xpm1b_enable);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_CONTROL:\r\nstatus = acpi_hw_read_multiple(&value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nvalue &= ~ACPI_PM1_CONTROL_WRITEONLY_BITS;\r\nbreak;\r\ncase ACPI_REGISTER_PM2_CONTROL:\r\nstatus =\r\nacpi_hw_read(&value, &acpi_gbl_FADT.xpm2_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM_TIMER:\r\nstatus = acpi_hw_read(&value, &acpi_gbl_FADT.xpm_timer_block);\r\nbreak;\r\ncase ACPI_REGISTER_SMI_COMMAND_BLOCK:\r\nstatus =\r\nacpi_hw_read_port(acpi_gbl_FADT.smi_command, &value, 8);\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nif (ACPI_SUCCESS(status)) {\r\n*return_value = value;\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_hw_register_write(u32 register_id, u32 value)\r\n{\r\nacpi_status status;\r\nu32 read_value;\r\nACPI_FUNCTION_TRACE(hw_register_write);\r\nswitch (register_id) {\r\ncase ACPI_REGISTER_PM1_STATUS:\r\nvalue &= ~ACPI_PM1_STATUS_PRESERVED_BITS;\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_xpm1a_status,\r\n&acpi_gbl_xpm1b_status);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_ENABLE:\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_xpm1a_enable,\r\n&acpi_gbl_xpm1b_enable);\r\nbreak;\r\ncase ACPI_REGISTER_PM1_CONTROL:\r\nstatus = acpi_hw_read_multiple(&read_value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nACPI_INSERT_BITS(value, ACPI_PM1_CONTROL_PRESERVED_BITS,\r\nread_value);\r\nstatus = acpi_hw_write_multiple(value,\r\n&acpi_gbl_FADT.\r\nxpm1a_control_block,\r\n&acpi_gbl_FADT.\r\nxpm1b_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM2_CONTROL:\r\nstatus =\r\nacpi_hw_read(&read_value,\r\n&acpi_gbl_FADT.xpm2_control_block);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nACPI_INSERT_BITS(value, ACPI_PM2_CONTROL_PRESERVED_BITS,\r\nread_value);\r\nstatus =\r\nacpi_hw_write(value, &acpi_gbl_FADT.xpm2_control_block);\r\nbreak;\r\ncase ACPI_REGISTER_PM_TIMER:\r\nstatus = acpi_hw_write(value, &acpi_gbl_FADT.xpm_timer_block);\r\nbreak;\r\ncase ACPI_REGISTER_SMI_COMMAND_BLOCK:\r\nstatus =\r\nacpi_hw_write_port(acpi_gbl_FADT.smi_command, value, 8);\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));\r\nstatus = AE_BAD_PARAMETER;\r\nbreak;\r\n}\r\nexit:\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_hw_read_multiple(u32 *value,\r\nstruct acpi_generic_address *register_a,\r\nstruct acpi_generic_address *register_b)\r\n{\r\nu32 value_a = 0;\r\nu32 value_b = 0;\r\nacpi_status status;\r\nstatus = acpi_hw_read(&value_a, register_a);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (register_b->address) {\r\nstatus = acpi_hw_read(&value_b, register_b);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n*value = (value_a | value_b);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_hw_write_multiple(u32 value,\r\nstruct acpi_generic_address *register_a,\r\nstruct acpi_generic_address *register_b)\r\n{\r\nacpi_status status;\r\nstatus = acpi_hw_write(value, register_a);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (register_b->address) {\r\nstatus = acpi_hw_write(value, register_b);\r\n}\r\nreturn (status);\r\n}
