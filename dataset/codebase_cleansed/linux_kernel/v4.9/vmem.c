static void __ref *vmem_alloc_pages(unsigned int order)\r\n{\r\nunsigned long size = PAGE_SIZE << order;\r\nif (slab_is_available())\r\nreturn (void *)__get_free_pages(GFP_KERNEL, order);\r\nreturn alloc_bootmem_align(size, size);\r\n}\r\nstatic inline pud_t *vmem_pud_alloc(void)\r\n{\r\npud_t *pud = NULL;\r\npud = vmem_alloc_pages(2);\r\nif (!pud)\r\nreturn NULL;\r\nclear_table((unsigned long *) pud, _REGION3_ENTRY_EMPTY, PAGE_SIZE * 4);\r\nreturn pud;\r\n}\r\npmd_t *vmem_pmd_alloc(void)\r\n{\r\npmd_t *pmd = NULL;\r\npmd = vmem_alloc_pages(2);\r\nif (!pmd)\r\nreturn NULL;\r\nclear_table((unsigned long *) pmd, _SEGMENT_ENTRY_EMPTY, PAGE_SIZE * 4);\r\nreturn pmd;\r\n}\r\npte_t __ref *vmem_pte_alloc(void)\r\n{\r\npte_t *pte;\r\nif (slab_is_available())\r\npte = (pte_t *) page_table_alloc(&init_mm);\r\nelse\r\npte = alloc_bootmem_align(PTRS_PER_PTE * sizeof(pte_t),\r\nPTRS_PER_PTE * sizeof(pte_t));\r\nif (!pte)\r\nreturn NULL;\r\nclear_table((unsigned long *) pte, _PAGE_INVALID,\r\nPTRS_PER_PTE * sizeof(pte_t));\r\nreturn pte;\r\n}\r\nstatic int vmem_add_mem(unsigned long start, unsigned long size)\r\n{\r\nunsigned long pages4k, pages1m, pages2g;\r\nunsigned long end = start + size;\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\nint ret = -ENOMEM;\r\npages4k = pages1m = pages2g = 0;\r\nwhile (address < end) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&\r\n!(address & ~PUD_MASK) && (address + PUD_SIZE <= end) &&\r\n!debug_pagealloc_enabled()) {\r\npud_val(*pu_dir) = address | pgprot_val(REGION3_KERNEL);\r\naddress += PUD_SIZE;\r\npages2g++;\r\ncontinue;\r\n}\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&\r\n!(address & ~PMD_MASK) && (address + PMD_SIZE <= end) &&\r\n!debug_pagealloc_enabled()) {\r\npmd_val(*pm_dir) = address | pgprot_val(SEGMENT_KERNEL);\r\naddress += PMD_SIZE;\r\npages1m++;\r\ncontinue;\r\n}\r\nif (pmd_none(*pm_dir)) {\r\npt_dir = vmem_pte_alloc();\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\npte_val(*pt_dir) = address | pgprot_val(PAGE_KERNEL);\r\naddress += PAGE_SIZE;\r\npages4k++;\r\n}\r\nret = 0;\r\nout:\r\nupdate_page_count(PG_DIRECT_MAP_4K, pages4k);\r\nupdate_page_count(PG_DIRECT_MAP_1M, pages1m);\r\nupdate_page_count(PG_DIRECT_MAP_2G, pages2g);\r\nreturn ret;\r\n}\r\nstatic void vmem_remove_range(unsigned long start, unsigned long size)\r\n{\r\nunsigned long pages4k, pages1m, pages2g;\r\nunsigned long end = start + size;\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\npages4k = pages1m = pages2g = 0;\r\nwhile (address < end) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\naddress += PGDIR_SIZE;\r\ncontinue;\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\naddress += PUD_SIZE;\r\ncontinue;\r\n}\r\nif (pud_large(*pu_dir)) {\r\npud_clear(pu_dir);\r\naddress += PUD_SIZE;\r\npages2g++;\r\ncontinue;\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir)) {\r\naddress += PMD_SIZE;\r\ncontinue;\r\n}\r\nif (pmd_large(*pm_dir)) {\r\npmd_clear(pm_dir);\r\naddress += PMD_SIZE;\r\npages1m++;\r\ncontinue;\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\npte_clear(&init_mm, address, pt_dir);\r\naddress += PAGE_SIZE;\r\npages4k++;\r\n}\r\nflush_tlb_kernel_range(start, end);\r\nupdate_page_count(PG_DIRECT_MAP_4K, -pages4k);\r\nupdate_page_count(PG_DIRECT_MAP_1M, -pages1m);\r\nupdate_page_count(PG_DIRECT_MAP_2G, -pages2g);\r\n}\r\nint __meminit vmemmap_populate(unsigned long start, unsigned long end, int node)\r\n{\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\nint ret = -ENOMEM;\r\nfor (address = start; address < end;) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir)) {\r\nif (MACHINE_HAS_EDAT1) {\r\nvoid *new_page;\r\nnew_page = vmemmap_alloc_block(PMD_SIZE, node);\r\nif (!new_page)\r\ngoto out;\r\npmd_val(*pm_dir) = __pa(new_page) |\r\n_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE;\r\naddress = (address + PMD_SIZE) & PMD_MASK;\r\ncontinue;\r\n}\r\npt_dir = vmem_pte_alloc();\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n} else if (pmd_large(*pm_dir)) {\r\naddress = (address + PMD_SIZE) & PMD_MASK;\r\ncontinue;\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\nif (pte_none(*pt_dir)) {\r\nvoid *new_page;\r\nnew_page = vmemmap_alloc_block(PAGE_SIZE, node);\r\nif (!new_page)\r\ngoto out;\r\npte_val(*pt_dir) =\r\n__pa(new_page) | pgprot_val(PAGE_KERNEL);\r\n}\r\naddress += PAGE_SIZE;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nvoid vmemmap_free(unsigned long start, unsigned long end)\r\n{\r\n}\r\nstatic int insert_memory_segment(struct memory_segment *seg)\r\n{\r\nstruct memory_segment *tmp;\r\nif (seg->start + seg->size > VMEM_MAX_PHYS ||\r\nseg->start + seg->size < seg->start)\r\nreturn -ERANGE;\r\nlist_for_each_entry(tmp, &mem_segs, list) {\r\nif (seg->start >= tmp->start + tmp->size)\r\ncontinue;\r\nif (seg->start + seg->size <= tmp->start)\r\ncontinue;\r\nreturn -ENOSPC;\r\n}\r\nlist_add(&seg->list, &mem_segs);\r\nreturn 0;\r\n}\r\nstatic void remove_memory_segment(struct memory_segment *seg)\r\n{\r\nlist_del(&seg->list);\r\n}\r\nstatic void __remove_shared_memory(struct memory_segment *seg)\r\n{\r\nremove_memory_segment(seg);\r\nvmem_remove_range(seg->start, seg->size);\r\n}\r\nint vmem_remove_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOENT;\r\nlist_for_each_entry(seg, &mem_segs, list) {\r\nif (seg->start == start && seg->size == size)\r\nbreak;\r\n}\r\nif (seg->start != start || seg->size != size)\r\ngoto out;\r\nret = 0;\r\n__remove_shared_memory(seg);\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nint vmem_add_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOMEM;\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\ngoto out;\r\nseg->start = start;\r\nseg->size = size;\r\nret = insert_memory_segment(seg);\r\nif (ret)\r\ngoto out_free;\r\nret = vmem_add_mem(start, size);\r\nif (ret)\r\ngoto out_remove;\r\ngoto out;\r\nout_remove:\r\n__remove_shared_memory(seg);\r\nout_free:\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nvoid __init vmem_map_init(void)\r\n{\r\nunsigned long size = _eshared - _stext;\r\nstruct memblock_region *reg;\r\nfor_each_memblock(memory, reg)\r\nvmem_add_mem(reg->base, reg->size);\r\nset_memory_ro((unsigned long)_stext, size >> PAGE_SHIFT);\r\npr_info("Write protected kernel read-only data: %luk\n", size >> 10);\r\n}\r\nstatic int __init vmem_convert_memory_chunk(void)\r\n{\r\nstruct memblock_region *reg;\r\nstruct memory_segment *seg;\r\nmutex_lock(&vmem_mutex);\r\nfor_each_memblock(memory, reg) {\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\npanic("Out of memory...\n");\r\nseg->start = reg->base;\r\nseg->size = reg->size;\r\ninsert_memory_segment(seg);\r\n}\r\nmutex_unlock(&vmem_mutex);\r\nreturn 0;\r\n}
