void __iomem *omap4_get_scu_base(void)\r\n{\r\nreturn cfg.scu_base;\r\n}\r\nvoid omap5_erratum_workaround_801819(void)\r\n{\r\nu32 acr, revidr;\r\nu32 acr_mask;\r\nasm volatile ("mrc p15, 0, %0, c0, c0, 6" : "=r" (revidr));\r\nif (revidr & (0x1 << 3))\r\nreturn;\r\nasm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r" (acr));\r\nacr_mask = (0x3 << 25) | (0x3 << 27);\r\nif ((acr & acr_mask) == acr_mask)\r\nreturn;\r\nacr |= acr_mask;\r\nomap_smc1(OMAP5_DRA7_MON_SET_ACR_INDEX, acr);\r\npr_debug("%s: ARM erratum workaround 801819 applied on CPU%d\n",\r\n__func__, smp_processor_id());\r\n}\r\nstatic inline void omap5_erratum_workaround_801819(void) { }\r\nstatic void omap4_secondary_init(unsigned int cpu)\r\n{\r\nif (soc_is_omap443x() && (omap_type() != OMAP2_DEVICE_TYPE_GP))\r\nomap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,\r\n4, 0, 0, 0, 0, 0);\r\nif (soc_is_omap54xx() || soc_is_dra7xx()) {\r\nset_cntfreq();\r\nomap5_erratum_workaround_801819();\r\n}\r\nspin_lock(&boot_lock);\r\nspin_unlock(&boot_lock);\r\n}\r\nstatic int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)\r\n{\r\nstatic struct clockdomain *cpu1_clkdm;\r\nstatic bool booted;\r\nstatic struct powerdomain *cpu1_pwrdm;\r\nvoid __iomem *base = omap_get_wakeupgen_base();\r\nspin_lock(&boot_lock);\r\nif (omap_secure_apis_support())\r\nomap_modify_auxcoreboot0(0x200, 0xfffffdff);\r\nelse\r\nwritel_relaxed(0x20, base + OMAP_AUX_CORE_BOOT_0);\r\nif (!cpu1_clkdm && !cpu1_pwrdm) {\r\ncpu1_clkdm = clkdm_lookup("mpu1_clkdm");\r\ncpu1_pwrdm = pwrdm_lookup("cpu1_pwrdm");\r\n}\r\nif (booted && cpu1_pwrdm && cpu1_clkdm) {\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {\r\nlocal_irq_disable();\r\ngic_dist_disable();\r\n}\r\nclkdm_deny_idle_nolock(cpu1_clkdm);\r\npwrdm_set_next_pwrst(cpu1_pwrdm, PWRDM_POWER_ON);\r\nclkdm_allow_idle_nolock(cpu1_clkdm);\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {\r\nwhile (gic_dist_disabled()) {\r\nudelay(1);\r\ncpu_relax();\r\n}\r\ngic_timer_retrigger();\r\nlocal_irq_enable();\r\n}\r\n} else {\r\ndsb_sev();\r\nbooted = true;\r\n}\r\narch_send_wakeup_ipi_mask(cpumask_of(cpu));\r\nspin_unlock(&boot_lock);\r\nreturn 0;\r\n}\r\nstatic void __init omap4_smp_init_cpus(void)\r\n{\r\nunsigned int i = 0, ncores = 1, cpu_id;\r\ncpu_id = read_cpuid_id() & CPU_MASK;\r\nif (cpu_id == CPU_CORTEX_A9) {\r\ncfg.scu_base = OMAP2_L4_IO_ADDRESS(scu_a9_get_base());\r\nBUG_ON(!cfg.scu_base);\r\nncores = scu_get_core_count(cfg.scu_base);\r\n} else if (cpu_id == CPU_CORTEX_A15) {\r\nncores = OMAP5_CORE_COUNT;\r\n}\r\nif (ncores > nr_cpu_ids) {\r\npr_warn("SMP: %u cores greater than maximum (%u), clipping\n",\r\nncores, nr_cpu_ids);\r\nncores = nr_cpu_ids;\r\n}\r\nfor (i = 0; i < ncores; i++)\r\nset_cpu_possible(i, true);\r\n}\r\nstatic void __init omap4_smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nvoid __iomem *base = omap_get_wakeupgen_base();\r\nconst struct omap_smp_config *c = NULL;\r\nif (soc_is_omap443x())\r\nc = &omap443x_cfg;\r\nelse if (soc_is_omap446x())\r\nc = &omap446x_cfg;\r\nelse if (soc_is_dra74x() || soc_is_omap54xx())\r\nc = &omap5_cfg;\r\nif (!c) {\r\npr_err("%s Unknown SMP SoC?\n", __func__);\r\nreturn;\r\n}\r\ncfg.cpu1_rstctrl_pa = c->cpu1_rstctrl_pa;\r\ncfg.startup_addr = c->startup_addr;\r\nif (soc_is_dra74x() || soc_is_omap54xx()) {\r\nif ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)\r\ncfg.startup_addr = omap5_secondary_hyp_startup;\r\nomap5_erratum_workaround_801819();\r\n}\r\ncfg.cpu1_rstctrl_va = ioremap(cfg.cpu1_rstctrl_pa, 4);\r\nif (!cfg.cpu1_rstctrl_va)\r\nreturn;\r\nif (cfg.scu_base)\r\nscu_enable(cfg.scu_base);\r\nif (cfg.cpu1_rstctrl_va) {\r\nwritel_relaxed(1, cfg.cpu1_rstctrl_va);\r\nreadl_relaxed(cfg.cpu1_rstctrl_va);\r\nwritel_relaxed(0, cfg.cpu1_rstctrl_va);\r\n}\r\nif (omap_secure_apis_support())\r\nomap_auxcoreboot_addr(virt_to_phys(cfg.startup_addr));\r\nelse\r\nwritel_relaxed(virt_to_phys(cfg.startup_addr),\r\nbase + OMAP_AUX_CORE_BOOT_1);\r\n}
