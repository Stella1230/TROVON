static void rsnd_mix_activation(struct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, MIX_SWRSR, 0);\r\nrsnd_mod_write(mod, MIX_SWRSR, 1);\r\n}\r\nstatic void rsnd_mix_halt(struct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, MIX_MIXIR, 1);\r\nrsnd_mod_write(mod, MIX_SWRSR, 0);\r\n}\r\nstatic void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, MIX_MDBAR, 0);\r\nrsnd_mod_write(mod, MIX_MDBBR, 0);\r\nrsnd_mod_write(mod, MIX_MDBCR, 0);\r\nrsnd_mod_write(mod, MIX_MDBDR, 0);\r\n}\r\nstatic void rsnd_mix_volume_init(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, MIX_MIXIR, 1);\r\nrsnd_mod_write(mod, MIX_ADINR, rsnd_runtime_channel_after_ctu(io));\r\nrsnd_mod_write(mod, MIX_MIXMR, 0);\r\nrsnd_mod_write(mod, MIX_MVPDR, 0);\r\nrsnd_mix_volume_parameter(io, mod);\r\nrsnd_mod_write(mod, MIX_MIXIR, 0);\r\n}\r\nstatic void rsnd_mix_volume_update(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, MIX_MDBER, 0);\r\nrsnd_mix_volume_parameter(io, mod);\r\nrsnd_mod_write(mod, MIX_MDBER, 1);\r\n}\r\nstatic int rsnd_mix_probe_(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nreturn rsnd_cmd_attach(io, rsnd_mod_id(mod));\r\n}\r\nstatic int rsnd_mix_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nrsnd_mod_power_on(mod);\r\nrsnd_mix_activation(mod);\r\nrsnd_mix_volume_init(io, mod);\r\nrsnd_mix_volume_update(io, mod);\r\nreturn 0;\r\n}\r\nstatic int rsnd_mix_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nrsnd_mix_halt(mod);\r\nrsnd_mod_power_off(mod);\r\nreturn 0;\r\n}\r\nstruct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_mix_nr(priv)))\r\nid = 0;\r\nreturn rsnd_mod_get(rsnd_mix_get(priv, id));\r\n}\r\nint rsnd_mix_probe(struct rsnd_priv *priv)\r\n{\r\nstruct device_node *node;\r\nstruct device_node *np;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_mix *mix;\r\nstruct clk *clk;\r\nchar name[MIX_NAME_SIZE];\r\nint i, nr, ret;\r\nif (rsnd_is_gen1(priv))\r\nreturn 0;\r\nnode = rsnd_mix_of_node(priv);\r\nif (!node)\r\nreturn 0;\r\nnr = of_get_child_count(node);\r\nif (!nr) {\r\nret = -EINVAL;\r\ngoto rsnd_mix_probe_done;\r\n}\r\nmix = devm_kzalloc(dev, sizeof(*mix) * nr, GFP_KERNEL);\r\nif (!mix) {\r\nret = -ENOMEM;\r\ngoto rsnd_mix_probe_done;\r\n}\r\npriv->mix_nr = nr;\r\npriv->mix = mix;\r\ni = 0;\r\nret = 0;\r\nfor_each_child_of_node(node, np) {\r\nmix = rsnd_mix_get(priv, i);\r\nsnprintf(name, MIX_NAME_SIZE, "%s.%d",\r\nMIX_NAME, i);\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto rsnd_mix_probe_done;\r\n}\r\nret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,\r\nclk, rsnd_mod_get_status, RSND_MOD_MIX, i);\r\nif (ret)\r\ngoto rsnd_mix_probe_done;\r\ni++;\r\n}\r\nrsnd_mix_probe_done:\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nvoid rsnd_mix_remove(struct rsnd_priv *priv)\r\n{\r\nstruct rsnd_mix *mix;\r\nint i;\r\nfor_each_rsnd_mix(mix, priv, i) {\r\nrsnd_mod_quit(rsnd_mod_get(mix));\r\n}\r\n}
