u32 __pure crc32_le(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_le_generic(crc, p, len, NULL, CRCPOLY_LE);\r\n}\r\nu32 __pure __crc32c_le(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_le_generic(crc, p, len, NULL, CRC32C_POLY_LE);\r\n}\r\nu32 __pure crc32_le(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_le_generic(crc, p, len,\r\n(const u32 (*)[256])crc32table_le, CRCPOLY_LE);\r\n}\r\nu32 __pure __crc32c_le(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_le_generic(crc, p, len,\r\n(const u32 (*)[256])crc32ctable_le, CRC32C_POLY_LE);\r\n}\r\nstatic u32 __attribute_const__ gf2_multiply(u32 x, u32 y, u32 modulus)\r\n{\r\nu32 product = x & 1 ? y : 0;\r\nint i;\r\nfor (i = 0; i < 31; i++) {\r\nproduct = (product >> 1) ^ (product & 1 ? modulus : 0);\r\nx >>= 1;\r\nproduct ^= x & 1 ? y : 0;\r\n}\r\nreturn product;\r\n}\r\nstatic u32 __attribute_const__ crc32_generic_shift(u32 crc, size_t len,\r\nu32 polynomial)\r\n{\r\nu32 power = polynomial;\r\nint i;\r\nfor (i = 0; i < 8 * (int)(len & 3); i++)\r\ncrc = (crc >> 1) ^ (crc & 1 ? polynomial : 0);\r\nlen >>= 2;\r\nif (!len)\r\nreturn crc;\r\nfor (;;) {\r\nif (len & 1)\r\ncrc = gf2_multiply(crc, power, polynomial);\r\nlen >>= 1;\r\nif (!len)\r\nbreak;\r\npower = gf2_multiply(power, power, polynomial);\r\n}\r\nreturn crc;\r\n}\r\nu32 __attribute_const__ crc32_le_shift(u32 crc, size_t len)\r\n{\r\nreturn crc32_generic_shift(crc, len, CRCPOLY_LE);\r\n}\r\nu32 __attribute_const__ __crc32c_le_shift(u32 crc, size_t len)\r\n{\r\nreturn crc32_generic_shift(crc, len, CRC32C_POLY_LE);\r\n}\r\nu32 __pure crc32_be(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_be_generic(crc, p, len, NULL, CRCPOLY_BE);\r\n}\r\nu32 __pure crc32_be(u32 crc, unsigned char const *p, size_t len)\r\n{\r\nreturn crc32_be_generic(crc, p, len,\r\n(const u32 (*)[256])crc32table_be, CRCPOLY_BE);\r\n}\r\nstatic int __init crc32c_test(void)\r\n{\r\nint i;\r\nint errors = 0;\r\nint bytes = 0;\r\nu64 nsec;\r\nunsigned long flags;\r\nstatic u32 crc;\r\nfor (i = 0; i < 100; i++) {\r\nbytes += 2*test[i].length;\r\ncrc ^= __crc32c_le(test[i].crc, test_buf +\r\ntest[i].start, test[i].length);\r\n}\r\nlocal_irq_save(flags);\r\nlocal_irq_disable();\r\nnsec = ktime_get_ns();\r\nfor (i = 0; i < 100; i++) {\r\nif (test[i].crc32c_le != __crc32c_le(test[i].crc, test_buf +\r\ntest[i].start, test[i].length))\r\nerrors++;\r\n}\r\nnsec = ktime_get_ns() - nsec;\r\nlocal_irq_restore(flags);\r\nlocal_irq_enable();\r\npr_info("crc32c: CRC_LE_BITS = %d\n", CRC_LE_BITS);\r\nif (errors)\r\npr_warn("crc32c: %d self tests failed\n", errors);\r\nelse {\r\npr_info("crc32c: self tests passed, processed %d bytes in %lld nsec\n",\r\nbytes, nsec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init crc32c_combine_test(void)\r\n{\r\nint i, j;\r\nint errors = 0, runs = 0;\r\nfor (i = 0; i < 10; i++) {\r\nu32 crc_full;\r\ncrc_full = __crc32c_le(test[i].crc, test_buf + test[i].start,\r\ntest[i].length);\r\nfor (j = 0; j <= test[i].length; ++j) {\r\nu32 crc1, crc2;\r\nu32 len1 = j, len2 = test[i].length - j;\r\ncrc1 = __crc32c_le(test[i].crc, test_buf +\r\ntest[i].start, len1);\r\ncrc2 = __crc32c_le(0, test_buf + test[i].start +\r\nlen1, len2);\r\nif (!(crc_full == __crc32c_le_combine(crc1, crc2, len2) &&\r\ncrc_full == test[i].crc32c_le))\r\nerrors++;\r\nruns++;\r\ncond_resched();\r\n}\r\n}\r\nif (errors)\r\npr_warn("crc32c_combine: %d/%d self tests failed\n", errors, runs);\r\nelse\r\npr_info("crc32c_combine: %d self tests passed\n", runs);\r\nreturn 0;\r\n}\r\nstatic int __init crc32_test(void)\r\n{\r\nint i;\r\nint errors = 0;\r\nint bytes = 0;\r\nu64 nsec;\r\nunsigned long flags;\r\nstatic u32 crc;\r\nfor (i = 0; i < 100; i++) {\r\nbytes += 2*test[i].length;\r\ncrc ^= crc32_le(test[i].crc, test_buf +\r\ntest[i].start, test[i].length);\r\ncrc ^= crc32_be(test[i].crc, test_buf +\r\ntest[i].start, test[i].length);\r\n}\r\nlocal_irq_save(flags);\r\nlocal_irq_disable();\r\nnsec = ktime_get_ns();\r\nfor (i = 0; i < 100; i++) {\r\nif (test[i].crc_le != crc32_le(test[i].crc, test_buf +\r\ntest[i].start, test[i].length))\r\nerrors++;\r\nif (test[i].crc_be != crc32_be(test[i].crc, test_buf +\r\ntest[i].start, test[i].length))\r\nerrors++;\r\n}\r\nnsec = ktime_get_ns() - nsec;\r\nlocal_irq_restore(flags);\r\nlocal_irq_enable();\r\npr_info("crc32: CRC_LE_BITS = %d, CRC_BE BITS = %d\n",\r\nCRC_LE_BITS, CRC_BE_BITS);\r\nif (errors)\r\npr_warn("crc32: %d self tests failed\n", errors);\r\nelse {\r\npr_info("crc32: self tests passed, processed %d bytes in %lld nsec\n",\r\nbytes, nsec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init crc32_combine_test(void)\r\n{\r\nint i, j;\r\nint errors = 0, runs = 0;\r\nfor (i = 0; i < 10; i++) {\r\nu32 crc_full;\r\ncrc_full = crc32_le(test[i].crc, test_buf + test[i].start,\r\ntest[i].length);\r\nfor (j = 0; j <= test[i].length; ++j) {\r\nu32 crc1, crc2;\r\nu32 len1 = j, len2 = test[i].length - j;\r\ncrc1 = crc32_le(test[i].crc, test_buf +\r\ntest[i].start, len1);\r\ncrc2 = crc32_le(0, test_buf + test[i].start +\r\nlen1, len2);\r\nif (!(crc_full == crc32_le_combine(crc1, crc2, len2) &&\r\ncrc_full == test[i].crc_le))\r\nerrors++;\r\nruns++;\r\ncond_resched();\r\n}\r\n}\r\nif (errors)\r\npr_warn("crc32_combine: %d/%d self tests failed\n", errors, runs);\r\nelse\r\npr_info("crc32_combine: %d self tests passed\n", runs);\r\nreturn 0;\r\n}\r\nstatic int __init crc32test_init(void)\r\n{\r\ncrc32_test();\r\ncrc32c_test();\r\ncrc32_combine_test();\r\ncrc32c_combine_test();\r\nreturn 0;\r\n}\r\nstatic void __exit crc32_exit(void)\r\n{\r\n}
