static inline u16 case_fold(u16 c)\r\n{\r\nu16 tmp;\r\ntmp = hfsplus_case_fold_table[c >> 8];\r\nif (tmp)\r\ntmp = hfsplus_case_fold_table[tmp + (c & 0xff)];\r\nelse\r\ntmp = c;\r\nreturn tmp;\r\n}\r\nint hfsplus_strcasecmp(const struct hfsplus_unistr *s1,\r\nconst struct hfsplus_unistr *s2)\r\n{\r\nu16 len1, len2, c1, c2;\r\nconst hfsplus_unichr *p1, *p2;\r\nlen1 = be16_to_cpu(s1->length);\r\nlen2 = be16_to_cpu(s2->length);\r\np1 = s1->unicode;\r\np2 = s2->unicode;\r\nwhile (1) {\r\nc1 = c2 = 0;\r\nwhile (len1 && !c1) {\r\nc1 = case_fold(be16_to_cpu(*p1));\r\np1++;\r\nlen1--;\r\n}\r\nwhile (len2 && !c2) {\r\nc2 = case_fold(be16_to_cpu(*p2));\r\np2++;\r\nlen2--;\r\n}\r\nif (c1 != c2)\r\nreturn (c1 < c2) ? -1 : 1;\r\nif (!c1 && !c2)\r\nreturn 0;\r\n}\r\n}\r\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\r\nconst struct hfsplus_unistr *s2)\r\n{\r\nu16 len1, len2, c1, c2;\r\nconst hfsplus_unichr *p1, *p2;\r\nint len;\r\nlen1 = be16_to_cpu(s1->length);\r\nlen2 = be16_to_cpu(s2->length);\r\np1 = s1->unicode;\r\np2 = s2->unicode;\r\nfor (len = min(len1, len2); len > 0; len--) {\r\nc1 = be16_to_cpu(*p1);\r\nc2 = be16_to_cpu(*p2);\r\nif (c1 != c2)\r\nreturn c1 < c2 ? -1 : 1;\r\np1++;\r\np2++;\r\n}\r\nreturn len1 < len2 ? -1 :\r\nlen1 > len2 ? 1 : 0;\r\n}\r\nstatic u16 *hfsplus_compose_lookup(u16 *p, u16 cc)\r\n{\r\nint i, s, e;\r\ns = 1;\r\ne = p[1];\r\nif (!e || cc < p[s * 2] || cc > p[e * 2])\r\nreturn NULL;\r\ndo {\r\ni = (s + e) / 2;\r\nif (cc > p[i * 2])\r\ns = i + 1;\r\nelse if (cc < p[i * 2])\r\ne = i - 1;\r\nelse\r\nreturn hfsplus_compose_table + p[i * 2 + 1];\r\n} while (s <= e);\r\nreturn NULL;\r\n}\r\nint hfsplus_uni2asc(struct super_block *sb,\r\nconst struct hfsplus_unistr *ustr,\r\nchar *astr, int *len_p)\r\n{\r\nconst hfsplus_unichr *ip;\r\nstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\r\nu8 *op;\r\nu16 cc, c0, c1;\r\nu16 *ce1, *ce2;\r\nint i, len, ustrlen, res, compose;\r\nop = astr;\r\nip = ustr->unicode;\r\nustrlen = be16_to_cpu(ustr->length);\r\nlen = *len_p;\r\nce1 = NULL;\r\ncompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\r\nwhile (ustrlen > 0) {\r\nc0 = be16_to_cpu(*ip++);\r\nustrlen--;\r\nif (likely(compose))\r\nce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\r\nif (ce1)\r\ncc = ce1[0];\r\nelse\r\ncc = 0;\r\nif (cc) {\r\nif (cc != 0xffff)\r\ngoto done;\r\nif (!ustrlen)\r\ngoto same;\r\nc1 = be16_to_cpu(*ip) - Hangul_VBase;\r\nif (c1 < Hangul_VCount) {\r\ncc = (c0 - Hangul_LBase) * Hangul_VCount;\r\ncc = (cc + c1) * Hangul_TCount;\r\ncc += Hangul_SBase;\r\nip++;\r\nustrlen--;\r\nif (!ustrlen)\r\ngoto done;\r\nc1 = be16_to_cpu(*ip) - Hangul_TBase;\r\nif (c1 > 0 && c1 < Hangul_TCount) {\r\ncc += c1;\r\nip++;\r\nustrlen--;\r\n}\r\ngoto done;\r\n}\r\n}\r\nwhile (1) {\r\nif (!ustrlen)\r\ngoto same;\r\nc1 = be16_to_cpu(*ip);\r\nif (likely(compose))\r\nce1 = hfsplus_compose_lookup(\r\nhfsplus_compose_table, c1);\r\nif (ce1)\r\nbreak;\r\nswitch (c0) {\r\ncase 0:\r\nc0 = 0x2400;\r\nbreak;\r\ncase '/':\r\nc0 = ':';\r\nbreak;\r\n}\r\nres = nls->uni2char(c0, op, len);\r\nif (res < 0) {\r\nif (res == -ENAMETOOLONG)\r\ngoto out;\r\n*op = '?';\r\nres = 1;\r\n}\r\nop += res;\r\nlen -= res;\r\nc0 = c1;\r\nip++;\r\nustrlen--;\r\n}\r\nce2 = hfsplus_compose_lookup(ce1, c0);\r\nif (ce2) {\r\ni = 1;\r\nwhile (i < ustrlen) {\r\nce1 = hfsplus_compose_lookup(ce2,\r\nbe16_to_cpu(ip[i]));\r\nif (!ce1)\r\nbreak;\r\ni++;\r\nce2 = ce1;\r\n}\r\ncc = ce2[0];\r\nif (cc) {\r\nip += i;\r\nustrlen -= i;\r\ngoto done;\r\n}\r\n}\r\nsame:\r\nswitch (c0) {\r\ncase 0:\r\ncc = 0x2400;\r\nbreak;\r\ncase '/':\r\ncc = ':';\r\nbreak;\r\ndefault:\r\ncc = c0;\r\n}\r\ndone:\r\nres = nls->uni2char(cc, op, len);\r\nif (res < 0) {\r\nif (res == -ENAMETOOLONG)\r\ngoto out;\r\n*op = '?';\r\nres = 1;\r\n}\r\nop += res;\r\nlen -= res;\r\n}\r\nres = 0;\r\nout:\r\n*len_p = (char *)op - astr;\r\nreturn res;\r\n}\r\nstatic inline int asc2unichar(struct super_block *sb, const char *astr, int len,\r\nwchar_t *uc)\r\n{\r\nint size = HFSPLUS_SB(sb)->nls->char2uni(astr, len, uc);\r\nif (size <= 0) {\r\n*uc = '?';\r\nsize = 1;\r\n}\r\nswitch (*uc) {\r\ncase 0x2400:\r\n*uc = 0;\r\nbreak;\r\ncase ':':\r\n*uc = '/';\r\nbreak;\r\n}\r\nreturn size;\r\n}\r\nstatic inline u16 *decompose_unichar(wchar_t uc, int *size)\r\n{\r\nint off;\r\noff = hfsplus_decompose_table[(uc >> 12) & 0xf];\r\nif (off == 0 || off == 0xffff)\r\nreturn NULL;\r\noff = hfsplus_decompose_table[off + ((uc >> 8) & 0xf)];\r\nif (!off)\r\nreturn NULL;\r\noff = hfsplus_decompose_table[off + ((uc >> 4) & 0xf)];\r\nif (!off)\r\nreturn NULL;\r\noff = hfsplus_decompose_table[off + (uc & 0xf)];\r\n*size = off & 3;\r\nif (*size == 0)\r\nreturn NULL;\r\nreturn hfsplus_decompose_table + (off / 4);\r\n}\r\nint hfsplus_asc2uni(struct super_block *sb,\r\nstruct hfsplus_unistr *ustr, int max_unistr_len,\r\nconst char *astr, int len)\r\n{\r\nint size, dsize, decompose;\r\nu16 *dstr, outlen = 0;\r\nwchar_t c;\r\ndecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\r\nwhile (outlen < max_unistr_len && len > 0) {\r\nsize = asc2unichar(sb, astr, len, &c);\r\nif (decompose)\r\ndstr = decompose_unichar(c, &dsize);\r\nelse\r\ndstr = NULL;\r\nif (dstr) {\r\nif (outlen + dsize > max_unistr_len)\r\nbreak;\r\ndo {\r\nustr->unicode[outlen++] = cpu_to_be16(*dstr++);\r\n} while (--dsize > 0);\r\n} else\r\nustr->unicode[outlen++] = cpu_to_be16(c);\r\nastr += size;\r\nlen -= size;\r\n}\r\nustr->length = cpu_to_be16(outlen);\r\nif (len > 0)\r\nreturn -ENAMETOOLONG;\r\nreturn 0;\r\n}\r\nint hfsplus_hash_dentry(const struct dentry *dentry, struct qstr *str)\r\n{\r\nstruct super_block *sb = dentry->d_sb;\r\nconst char *astr;\r\nconst u16 *dstr;\r\nint casefold, decompose, size, len;\r\nunsigned long hash;\r\nwchar_t c;\r\nu16 c2;\r\ncasefold = test_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\r\ndecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\r\nhash = init_name_hash(dentry);\r\nastr = str->name;\r\nlen = str->len;\r\nwhile (len > 0) {\r\nint uninitialized_var(dsize);\r\nsize = asc2unichar(sb, astr, len, &c);\r\nastr += size;\r\nlen -= size;\r\nif (decompose)\r\ndstr = decompose_unichar(c, &dsize);\r\nelse\r\ndstr = NULL;\r\nif (dstr) {\r\ndo {\r\nc2 = *dstr++;\r\nif (casefold)\r\nc2 = case_fold(c2);\r\nif (!casefold || c2)\r\nhash = partial_name_hash(c2, hash);\r\n} while (--dsize > 0);\r\n} else {\r\nc2 = c;\r\nif (casefold)\r\nc2 = case_fold(c2);\r\nif (!casefold || c2)\r\nhash = partial_name_hash(c2, hash);\r\n}\r\n}\r\nstr->hash = end_name_hash(hash);\r\nreturn 0;\r\n}\r\nint hfsplus_compare_dentry(const struct dentry *dentry,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nstruct super_block *sb = dentry->d_sb;\r\nint casefold, decompose, size;\r\nint dsize1, dsize2, len1, len2;\r\nconst u16 *dstr1, *dstr2;\r\nconst char *astr1, *astr2;\r\nu16 c1, c2;\r\nwchar_t c;\r\ncasefold = test_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\r\ndecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\r\nastr1 = str;\r\nlen1 = len;\r\nastr2 = name->name;\r\nlen2 = name->len;\r\ndsize1 = dsize2 = 0;\r\ndstr1 = dstr2 = NULL;\r\nwhile (len1 > 0 && len2 > 0) {\r\nif (!dsize1) {\r\nsize = asc2unichar(sb, astr1, len1, &c);\r\nastr1 += size;\r\nlen1 -= size;\r\nif (decompose)\r\ndstr1 = decompose_unichar(c, &dsize1);\r\nif (!decompose || !dstr1) {\r\nc1 = c;\r\ndstr1 = &c1;\r\ndsize1 = 1;\r\n}\r\n}\r\nif (!dsize2) {\r\nsize = asc2unichar(sb, astr2, len2, &c);\r\nastr2 += size;\r\nlen2 -= size;\r\nif (decompose)\r\ndstr2 = decompose_unichar(c, &dsize2);\r\nif (!decompose || !dstr2) {\r\nc2 = c;\r\ndstr2 = &c2;\r\ndsize2 = 1;\r\n}\r\n}\r\nc1 = *dstr1;\r\nc2 = *dstr2;\r\nif (casefold) {\r\nc1 = case_fold(c1);\r\nif (!c1) {\r\ndstr1++;\r\ndsize1--;\r\ncontinue;\r\n}\r\nc2 = case_fold(c2);\r\nif (!c2) {\r\ndstr2++;\r\ndsize2--;\r\ncontinue;\r\n}\r\n}\r\nif (c1 < c2)\r\nreturn -1;\r\nelse if (c1 > c2)\r\nreturn 1;\r\ndstr1++;\r\ndsize1--;\r\ndstr2++;\r\ndsize2--;\r\n}\r\nif (len1 < len2)\r\nreturn -1;\r\nif (len1 > len2)\r\nreturn 1;\r\nreturn 0;\r\n}
