static char * __init\r\nmk_resource_name(int pe, int port, char *str)\r\n{\r\nchar tmp[80];\r\nchar *name;\r\nsprintf(tmp, "PCI %s PE %d PORT %d", str, pe, port);\r\nname = alloc_bootmem(strlen(tmp) + 1);\r\nstrcpy(name, tmp);\r\nreturn name;\r\n}\r\ninline struct io7 *\r\nmarvel_next_io7(struct io7 *prev)\r\n{\r\nreturn (prev ? prev->next : io7_head);\r\n}\r\nstruct io7 *\r\nmarvel_find_io7(int pe)\r\n{\r\nstruct io7 *io7;\r\nfor (io7 = io7_head; io7 && io7->pe != pe; io7 = io7->next)\r\ncontinue;\r\nreturn io7;\r\n}\r\nstatic struct io7 * __init\r\nalloc_io7(unsigned int pe)\r\n{\r\nstruct io7 *io7;\r\nstruct io7 *insp;\r\nint h;\r\nif (marvel_find_io7(pe)) {\r\nprintk(KERN_WARNING "IO7 at PE %d already allocated!\n", pe);\r\nreturn NULL;\r\n}\r\nio7 = alloc_bootmem(sizeof(*io7));\r\nio7->pe = pe;\r\nspin_lock_init(&io7->irq_lock);\r\nfor (h = 0; h < 4; h++) {\r\nio7->ports[h].io7 = io7;\r\nio7->ports[h].port = h;\r\nio7->ports[h].enabled = 0;\r\n}\r\nif (NULL == io7_head)\r\nio7_head = io7;\r\nelse if (io7_head->pe > io7->pe) {\r\nio7->next = io7_head;\r\nio7_head = io7;\r\n} else {\r\nfor (insp = io7_head; insp; insp = insp->next) {\r\nif (insp->pe == io7->pe) {\r\nprintk(KERN_ERR "Too many IO7s at PE %d\n",\r\nio7->pe);\r\nreturn NULL;\r\n}\r\nif (NULL == insp->next ||\r\ninsp->next->pe > io7->pe) {\r\nio7->next = insp->next;\r\ninsp->next = io7;\r\nbreak;\r\n}\r\n}\r\nif (NULL == insp) {\r\nprintk(KERN_WARNING "Failed to insert IO7 at PE %d "\r\n" - adding at head of list\n", io7->pe);\r\nio7->next = io7_head;\r\nio7_head = io7;\r\n}\r\n}\r\nreturn io7;\r\n}\r\nvoid\r\nio7_clear_errors(struct io7 *io7)\r\n{\r\nio7_port7_csrs *p7csrs;\r\nio7_ioport_csrs *csrs;\r\nint port;\r\nfor (port = 0; port < 4; port++) {\r\ncsrs = IO7_CSRS_KERN(io7->pe, port);\r\ncsrs->POx_ERR_SUM.csr = -1UL;\r\ncsrs->POx_TLB_ERR.csr = -1UL;\r\ncsrs->POx_SPL_COMPLT.csr = -1UL;\r\ncsrs->POx_TRANS_SUM.csr = -1UL;\r\n}\r\np7csrs = IO7_PORT7_CSRS_KERN(io7->pe);\r\np7csrs->PO7_ERROR_SUM.csr = -1UL;\r\np7csrs->PO7_UNCRR_SYM.csr = -1UL;\r\np7csrs->PO7_CRRCT_SYM.csr = -1UL;\r\n}\r\nstatic void __init\r\nio7_init_hose(struct io7 *io7, int port)\r\n{\r\nstatic int hose_index = 0;\r\nstruct pci_controller *hose = alloc_pci_controller();\r\nstruct io7_port *io7_port = &io7->ports[port];\r\nio7_ioport_csrs *csrs = IO7_CSRS_KERN(io7->pe, port);\r\nint i;\r\nhose->index = hose_index++;\r\nif (hose->index == 0)\r\npci_isa_hose = hose;\r\nio7_port->csrs = csrs;\r\nio7_port->hose = hose;\r\nhose->sysdata = io7_port;\r\nhose->io_space = alloc_resource();\r\nhose->mem_space = alloc_resource();\r\nhose->sparse_mem_base = hose->sparse_io_base = 0;\r\nhose->dense_mem_base = IO7_MEM_PHYS(io7->pe, port);\r\nhose->dense_io_base = IO7_IO_PHYS(io7->pe, port);\r\nhose->config_space_base = (unsigned long)IO7_CONF_KERN(io7->pe, port);\r\nhose->io_space->start = (unsigned long)IO7_IO_KERN(io7->pe, port);\r\nhose->io_space->end = hose->io_space->start + IO7_IO_SPACE - 1;\r\nhose->io_space->name = mk_resource_name(io7->pe, port, "IO");\r\nhose->io_space->flags = IORESOURCE_IO;\r\nhose->mem_space->start = (unsigned long)IO7_MEM_KERN(io7->pe, port);\r\nhose->mem_space->end = hose->mem_space->start + IO7_MEM_SPACE - 1;\r\nhose->mem_space->name = mk_resource_name(io7->pe, port, "MEM");\r\nhose->mem_space->flags = IORESOURCE_MEM;\r\nif (request_resource(&ioport_resource, hose->io_space) < 0)\r\nprintk(KERN_ERR "Failed to request IO on hose %d\n",\r\nhose->index);\r\nif (request_resource(&iomem_resource, hose->mem_space) < 0)\r\nprintk(KERN_ERR "Failed to request MEM on hose %d\n",\r\nhose->index);\r\nfor (i = 0; i < 4; i++) {\r\nio7_port->saved_wbase[i] = csrs->POx_WBASE[i].csr;\r\nio7_port->saved_wmask[i] = csrs->POx_WMASK[i].csr;\r\nio7_port->saved_tbase[i] = csrs->POx_TBASE[i].csr;\r\n}\r\nmarvel_pci_tbi(hose, 0, -1);\r\nhose->sg_isa = iommu_arena_new_node(marvel_cpuid_to_nid(io7->pe),\r\nhose, 0x00800000, 0x00800000, 0);\r\nhose->sg_isa->align_entry = 8;\r\ncsrs->POx_WBASE[0].csr =\r\nhose->sg_isa->dma_base | wbase_m_ena | wbase_m_sg;\r\ncsrs->POx_WMASK[0].csr = (hose->sg_isa->size - 1) & wbase_m_addr;\r\ncsrs->POx_TBASE[0].csr = virt_to_phys(hose->sg_isa->ptes);\r\ncsrs->POx_WBASE[1].csr = __direct_map_base | wbase_m_ena;\r\ncsrs->POx_WMASK[1].csr = (__direct_map_size - 1) & wbase_m_addr;\r\ncsrs->POx_TBASE[1].csr = 0;\r\nhose->sg_pci = iommu_arena_new_node(marvel_cpuid_to_nid(io7->pe),\r\nhose, 0xc0000000, 0x40000000, 0);\r\nhose->sg_pci->align_entry = 8;\r\ncsrs->POx_WBASE[2].csr =\r\nhose->sg_pci->dma_base | wbase_m_ena | wbase_m_sg;\r\ncsrs->POx_WMASK[2].csr = (hose->sg_pci->size - 1) & wbase_m_addr;\r\ncsrs->POx_TBASE[2].csr = virt_to_phys(hose->sg_pci->ptes);\r\ncsrs->POx_WBASE[3].csr = 0;\r\ncsrs->POx_CTRL.csr &= ~(1UL << 61);\r\n#if 1\r\nprintk("FIXME: disabling master aborts\n");\r\ncsrs->POx_MSK_HEI.csr &= ~(3UL << 14);\r\n#endif\r\nmarvel_pci_tbi(hose, 0, -1);\r\n}\r\nstatic void __init\r\nmarvel_init_io7(struct io7 *io7)\r\n{\r\nint i;\r\nprintk("Initializing IO7 at PID %d\n", io7->pe);\r\nio7->csrs = IO7_PORT7_CSRS_KERN(io7->pe);\r\nfor (i = 0; i < IO7_NUM_PORTS; i++) {\r\nio7_ioport_csrs *csrs = IO7_CSRS_KERN(io7->pe, i);\r\nif (csrs->POx_CACHE_CTL.csr == 8) {\r\nio7->ports[i].enabled = 1;\r\nio7_init_hose(io7, i);\r\n}\r\n}\r\n}\r\nvoid\r\nmarvel_io7_present(gct6_node *node)\r\n{\r\nint pe;\r\nif (node->type != GCT_TYPE_HOSE ||\r\nnode->subtype != GCT_SUBTYPE_IO_PORT_MODULE)\r\nreturn;\r\npe = (node->id >> 8) & 0xff;\r\nprintk("Found an IO7 at PID %d\n", pe);\r\nalloc_io7(pe);\r\n}\r\nstatic void __init\r\nmarvel_find_console_vga_hose(void)\r\n{\r\nu64 *pu64 = (u64 *)((u64)hwrpb + hwrpb->ctbt_offset);\r\nif (pu64[7] == 3) {\r\nstruct pci_controller *hose = NULL;\r\nint h = (pu64[30] >> 24) & 0xff;\r\nstruct io7 *io7;\r\nint pid, port;\r\nprintk("console graphics is on hose %d (console)\n", h);\r\npid = h >> 2;\r\nport = h & 3;\r\nif ((io7 = marvel_find_io7(pid)))\r\nhose = io7->ports[port].hose;\r\nif (hose) {\r\nprintk("Console graphics on hose %d\n", hose->index);\r\npci_vga_hose = hose;\r\n}\r\n}\r\n}\r\nstatic int __init\r\nmarvel_specify_io7(char *str)\r\n{\r\nunsigned long pid;\r\nstruct io7 *io7;\r\nchar *pchar;\r\ndo {\r\npid = simple_strtoul(str, &pchar, 0);\r\nif (pchar != str) {\r\nprintk("User-specified IO7 at PID %lu\n", pid);\r\nio7 = alloc_io7(pid);\r\nif (io7) marvel_init_io7(io7);\r\n}\r\nif (pchar == str) pchar++;\r\nstr = pchar;\r\n} while(*str);\r\nreturn 1;\r\n}\r\nvoid __init\r\nmarvel_init_arch(void)\r\n{\r\nstruct io7 *io7;\r\nioport_resource.end = ~0UL;\r\n__direct_map_base = 0x80000000;\r\n__direct_map_size = 0x40000000;\r\ngct6_find_nodes(GCT_NODE_PTR(0), gct_wanted_node_list);\r\nfor (io7 = NULL; NULL != (io7 = marvel_next_io7(io7)); )\r\nmarvel_init_io7(io7);\r\nmarvel_find_console_vga_hose();\r\n}\r\nvoid\r\nmarvel_kill_arch(int mode)\r\n{\r\n}\r\nstatic inline unsigned long\r\nbuild_conf_addr(struct pci_controller *hose, u8 bus,\r\nunsigned int devfn, int where)\r\n{\r\nreturn (hose->config_space_base | (bus << 16) | (devfn << 8) | where);\r\n}\r\nstatic unsigned long\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int devfn, int where)\r\n{\r\nstruct pci_controller *hose = pbus->sysdata;\r\nstruct io7_port *io7_port;\r\nunsigned long addr = 0;\r\nu8 bus = pbus->number;\r\nif (!hose)\r\nreturn addr;\r\nio7_port = hose->sysdata;\r\nif (!io7_port->enabled)\r\nreturn addr;\r\nif (!pbus->parent) {\r\nif (devfn >= PCI_DEVFN(21, 0))\r\nreturn addr;\r\nbus = 0;\r\n}\r\naddr = build_conf_addr(hose, bus, devfn, where);\r\nDBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn addr;\r\n}\r\nstatic int\r\nmarvel_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr;\r\nif (0 == (addr = mk_conf_addr(bus, devfn, where)))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch(size) {\r\ncase 1:\r\n*value = __kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n*value = __kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*value = *(vuip)addr;\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmarvel_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr;\r\nif (0 == (addr = mk_conf_addr(bus, devfn, where)))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n__kernel_stb(value, *(vucp)addr);\r\nmb();\r\n__kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n__kernel_stw(value, *(vusp)addr);\r\nmb();\r\n__kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*(vuip)addr = value;\r\nmb();\r\n*(vuip)addr;\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\nmarvel_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\nio7_ioport_csrs *csrs = ((struct io7_port *)hose->sysdata)->csrs;\r\nwmb();\r\ncsrs->POx_SG_TBIA.csr = 0;\r\nmb();\r\ncsrs->POx_SG_TBIA.csr;\r\n}\r\nstatic void\r\n__marvel_access_rtc(void *info)\r\n{\r\nstruct marvel_rtc_access_info *rtc_access = info;\r\nregister unsigned long __r0 __asm__("$0");\r\nregister unsigned long __r16 __asm__("$16") = rtc_access->function;\r\nregister unsigned long __r17 __asm__("$17") = rtc_access->index;\r\nregister unsigned long __r18 __asm__("$18") = rtc_access->data;\r\n__asm__ __volatile__(\r\n"call_pal %4 # cserve rtc"\r\n: "=r"(__r16), "=r"(__r17), "=r"(__r18), "=r"(__r0)\r\n: "i"(PAL_cserve), "0"(__r16), "1"(__r17), "2"(__r18)\r\n: "$1", "$22", "$23", "$24", "$25");\r\nrtc_access->data = __r0;\r\n}\r\nstatic u8\r\n__marvel_rtc_io(u8 b, unsigned long addr, int write)\r\n{\r\nstatic u8 index = 0;\r\nstruct marvel_rtc_access_info rtc_access;\r\nu8 ret = 0;\r\nswitch(addr) {\r\ncase 0x70:\r\nif (write) index = b;\r\nret = index;\r\nbreak;\r\ncase 0x71:\r\nrtc_access.index = index;\r\nrtc_access.data = bcd2bin(b);\r\nrtc_access.function = 0x48 + !write;\r\n__marvel_access_rtc(&rtc_access);\r\nret = bin2bcd(rtc_access.data);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Illegal RTC port %lx\n", addr);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid __iomem *\r\nmarvel_ioremap(unsigned long addr, unsigned long size)\r\n{\r\nstruct pci_controller *hose;\r\nunsigned long baddr, last;\r\nstruct vm_struct *area;\r\nunsigned long vaddr;\r\nunsigned long *ptes;\r\nunsigned long pfn;\r\nFIXUP_MEMADDR_VGA(addr);\r\nfor (hose = hose_head; hose; hose = hose->next) {\r\nif ((addr >> 32) == (hose->mem_space->start >> 32))\r\nbreak;\r\n}\r\nif (!hose)\r\nreturn NULL;\r\nbaddr = addr - hose->mem_space->start;\r\nlast = baddr + size - 1;\r\nif ((baddr >= __direct_map_base) &&\r\n((baddr + size - 1) < __direct_map_base + __direct_map_size)) {\r\naddr = IDENT_ADDR | (baddr - __direct_map_base);\r\nreturn (void __iomem *) addr;\r\n}\r\nif (hose->sg_pci &&\r\nbaddr >= (unsigned long)hose->sg_pci->dma_base &&\r\nlast < (unsigned long)hose->sg_pci->dma_base + hose->sg_pci->size) {\r\nbaddr -= hose->sg_pci->dma_base;\r\nlast -= hose->sg_pci->dma_base;\r\nbaddr &= PAGE_MASK;\r\nsize = PAGE_ALIGN(last) - baddr;\r\narea = get_vm_area(size, VM_IOREMAP);\r\nif (!area)\r\nreturn NULL;\r\nptes = hose->sg_pci->ptes;\r\nfor (vaddr = (unsigned long)area->addr;\r\nbaddr <= last;\r\nbaddr += PAGE_SIZE, vaddr += PAGE_SIZE) {\r\npfn = ptes[baddr >> PAGE_SHIFT];\r\nif (!(pfn & 1)) {\r\nprintk("ioremap failed... pte not valid...\n");\r\nvfree(area->addr);\r\nreturn NULL;\r\n}\r\npfn >>= 1;\r\nif (__alpha_remap_area_pages(vaddr,\r\npfn << PAGE_SHIFT,\r\nPAGE_SIZE, 0)) {\r\nprintk("FAILED to map...\n");\r\nvfree(area->addr);\r\nreturn NULL;\r\n}\r\n}\r\nflush_tlb_all();\r\nvaddr = (unsigned long)area->addr + (addr & ~PAGE_MASK);\r\nreturn (void __iomem *) vaddr;\r\n}\r\nvaddr = baddr + hose->mem_space->start;\r\nreturn (void __iomem *) vaddr;\r\n}\r\nvoid\r\nmarvel_iounmap(volatile void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (addr >= VMALLOC_START)\r\nvfree((void *)(PAGE_MASK & addr));\r\n}\r\nint\r\nmarvel_is_mmio(const volatile void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (addr >= VMALLOC_START)\r\nreturn 1;\r\nelse\r\nreturn (addr & 0xFF000000UL) == 0;\r\n}\r\nvoid __iomem *marvel_ioportmap (unsigned long addr)\r\n{\r\nFIXUP_IOADDR_VGA(addr);\r\nreturn (void __iomem *)addr;\r\n}\r\nunsigned int\r\nmarvel_ioread8(void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (__marvel_is_port_kbd(addr))\r\nreturn 0;\r\nelse if (__marvel_is_port_rtc(addr))\r\nreturn __marvel_rtc_io(0, addr, 0);\r\nelse if (marvel_is_ioaddr(addr))\r\nreturn __kernel_ldbu(*(vucp)addr);\r\nelse\r\nreturn ~0;\r\n}\r\nvoid\r\nmarvel_iowrite8(u8 b, void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (__marvel_is_port_kbd(addr))\r\nreturn;\r\nelse if (__marvel_is_port_rtc(addr))\r\n__marvel_rtc_io(b, addr, 1);\r\nelse if (marvel_is_ioaddr(addr))\r\n__kernel_stb(b, *(vucp)addr);\r\n}\r\nint\r\nmarvel_pa_to_nid(unsigned long pa)\r\n{\r\nint cpuid;\r\nif ((pa >> 43) & 1)\r\ncpuid = (~(pa >> 35) & 0xff);\r\nelse\r\ncpuid = ((pa >> 34) & 0x3) | ((pa >> (37 - 2)) & (0x1f << 2));\r\nreturn marvel_cpuid_to_nid(cpuid);\r\n}\r\nint\r\nmarvel_cpuid_to_nid(int cpuid)\r\n{\r\nreturn cpuid;\r\n}\r\nunsigned long\r\nmarvel_node_mem_start(int nid)\r\n{\r\nunsigned long pa;\r\npa = (nid & 0x3) | ((nid & (0x1f << 2)) << 1);\r\npa <<= 34;\r\nreturn pa;\r\n}\r\nunsigned long\r\nmarvel_node_mem_size(int nid)\r\n{\r\nreturn 16UL * 1024 * 1024 * 1024;\r\n}\r\nstatic int\r\nmarvel_agp_setup(alpha_agp_info *agp)\r\n{\r\nstruct marvel_agp_aperture *aper;\r\nif (!alpha_agpgart_size)\r\nreturn -ENOMEM;\r\naper = kmalloc(sizeof(*aper), GFP_KERNEL);\r\nif (aper == NULL) return -ENOMEM;\r\naper->arena = agp->hose->sg_pci;\r\naper->pg_count = alpha_agpgart_size / PAGE_SIZE;\r\naper->pg_start = iommu_reserve(aper->arena, aper->pg_count,\r\naper->pg_count - 1);\r\nif (aper->pg_start < 0) {\r\nprintk(KERN_ERR "Failed to reserve AGP memory\n");\r\nkfree(aper);\r\nreturn -ENOMEM;\r\n}\r\nagp->aperture.bus_base =\r\naper->arena->dma_base + aper->pg_start * PAGE_SIZE;\r\nagp->aperture.size = aper->pg_count * PAGE_SIZE;\r\nagp->aperture.sysdata = aper;\r\nreturn 0;\r\n}\r\nstatic void\r\nmarvel_agp_cleanup(alpha_agp_info *agp)\r\n{\r\nstruct marvel_agp_aperture *aper = agp->aperture.sysdata;\r\nint status;\r\nstatus = iommu_release(aper->arena, aper->pg_start, aper->pg_count);\r\nif (status == -EBUSY) {\r\nprintk(KERN_WARNING\r\n"Attempted to release bound AGP memory - unbinding\n");\r\niommu_unbind(aper->arena, aper->pg_start, aper->pg_count);\r\nstatus = iommu_release(aper->arena, aper->pg_start,\r\naper->pg_count);\r\n}\r\nif (status < 0)\r\nprintk(KERN_ERR "Failed to release AGP memory\n");\r\nkfree(aper);\r\nkfree(agp);\r\n}\r\nstatic int\r\nmarvel_agp_configure(alpha_agp_info *agp)\r\n{\r\nio7_ioport_csrs *csrs = ((struct io7_port *)agp->hose->sysdata)->csrs;\r\nstruct io7 *io7 = ((struct io7_port *)agp->hose->sysdata)->io7;\r\nunsigned int new_rate = 0;\r\nunsigned long agp_pll;\r\nagp_pll = io7->csrs->POx_RST[IO7_AGP_PORT].csr;\r\nswitch(IO7_PLL_RNGB(agp_pll)) {\r\ncase 0x4:\r\nif (agp->mode.bits.rate != 2)\r\nnew_rate = 2;\r\nbreak;\r\ncase 0x6:\r\nif (agp->mode.bits.rate == 2)\r\nnew_rate = 1;\r\nbreak;\r\ndefault:\r\nprintk("%s: unknown PLL setting RNGB=%lx (PLL6_CTL=%016lx)\n",\r\n__func__, IO7_PLL_RNGB(agp_pll), agp_pll);\r\nbreak;\r\n}\r\nif (new_rate) {\r\nprintk("Requested AGP Rate %dX not compatible "\r\n"with PLL setting - using %dX\n",\r\nagp->mode.bits.rate,\r\nnew_rate);\r\nagp->mode.bits.rate = new_rate;\r\n}\r\nprintk("Enabling AGP on hose %d: %dX%s RQ %d\n",\r\nagp->hose->index, agp->mode.bits.rate,\r\nagp->mode.bits.sba ? " - SBA" : "", agp->mode.bits.rq);\r\ncsrs->AGP_CMD.csr = agp->mode.lw;\r\nreturn 0;\r\n}\r\nstatic int\r\nmarvel_agp_bind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)\r\n{\r\nstruct marvel_agp_aperture *aper = agp->aperture.sysdata;\r\nreturn iommu_bind(aper->arena, aper->pg_start + pg_start,\r\nmem->page_count, mem->pages);\r\n}\r\nstatic int\r\nmarvel_agp_unbind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)\r\n{\r\nstruct marvel_agp_aperture *aper = agp->aperture.sysdata;\r\nreturn iommu_unbind(aper->arena, aper->pg_start + pg_start,\r\nmem->page_count);\r\n}\r\nstatic unsigned long\r\nmarvel_agp_translate(alpha_agp_info *agp, dma_addr_t addr)\r\n{\r\nstruct marvel_agp_aperture *aper = agp->aperture.sysdata;\r\nunsigned long baddr = addr - aper->arena->dma_base;\r\nunsigned long pte;\r\nif (addr < agp->aperture.bus_base ||\r\naddr >= agp->aperture.bus_base + agp->aperture.size) {\r\nprintk("%s: addr out of range\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npte = aper->arena->ptes[baddr >> PAGE_SHIFT];\r\nif (!(pte & 1)) {\r\nprintk("%s: pte not valid\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn (pte >> 1) << PAGE_SHIFT;\r\n}\r\nalpha_agp_info *\r\nmarvel_agp_info(void)\r\n{\r\nstruct pci_controller *hose;\r\nio7_ioport_csrs *csrs;\r\nalpha_agp_info *agp;\r\nstruct io7 *io7;\r\nhose = NULL;\r\nfor (io7 = NULL; (io7 = marvel_next_io7(io7)) != NULL; ) {\r\nstruct pci_controller *h;\r\nvuip addr;\r\nif (!io7->ports[IO7_AGP_PORT].enabled)\r\ncontinue;\r\nh = io7->ports[IO7_AGP_PORT].hose;\r\naddr = (vuip)build_conf_addr(h, 0, PCI_DEVFN(5, 0), 0);\r\nif (*addr != 0xffffffffu) {\r\nhose = h;\r\nbreak;\r\n}\r\n}\r\nif (!hose || !hose->sg_pci)\r\nreturn NULL;\r\nprintk("MARVEL - using hose %d as AGP\n", hose->index);\r\ncsrs = ((struct io7_port *)hose->sysdata)->csrs;\r\nagp = kmalloc(sizeof(*agp), GFP_KERNEL);\r\nif (!agp)\r\nreturn NULL;\r\nagp->hose = hose;\r\nagp->private = NULL;\r\nagp->ops = &marvel_agp_ops;\r\nagp->aperture.bus_base = 0;\r\nagp->aperture.size = 0;\r\nagp->aperture.sysdata = NULL;\r\nagp->capability.lw = csrs->AGP_STAT.csr;\r\nagp->capability.bits.rq = 0xf;\r\nagp->mode.lw = csrs->AGP_CMD.csr;\r\nreturn agp;\r\n}
