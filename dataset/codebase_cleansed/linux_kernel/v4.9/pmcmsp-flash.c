static int __init init_msp_flash(void)\r\n{\r\nint i, j, ret = -ENOMEM;\r\nint offset, coff;\r\nchar *env;\r\nint pcnt;\r\nchar flash_name[] = "flash0";\r\nchar part_name[] = "flash0_0";\r\nunsigned addr, size;\r\nif ((*DEV_ID_REG & DEV_ID_SINGLE_PC) &&\r\n(*ELB_1PC_EN_REG & SINGLE_PCCARD)) {\r\nprintk(KERN_NOTICE "Single PC Card mode: no flash access\n");\r\nreturn -ENXIO;\r\n}\r\nfor (fcnt = 0; (env = prom_getenv(flash_name)); fcnt++)\r\nflash_name[5] = '0' + fcnt + 1;\r\nif (fcnt < 1)\r\nreturn -ENXIO;\r\nprintk(KERN_NOTICE "Found %d PMC flash devices\n", fcnt);\r\nmsp_flash = kcalloc(fcnt, sizeof(*msp_flash), GFP_KERNEL);\r\nif (!msp_flash)\r\nreturn -ENOMEM;\r\nmsp_parts = kcalloc(fcnt, sizeof(*msp_parts), GFP_KERNEL);\r\nif (!msp_parts)\r\ngoto free_msp_flash;\r\nmsp_maps = kcalloc(fcnt, sizeof(*msp_maps), GFP_KERNEL);\r\nif (!msp_maps)\r\ngoto free_msp_parts;\r\nfor (i = 0; i < fcnt; i++) {\r\npart_name[5] = '0' + i;\r\npart_name[7] = '0';\r\nfor (pcnt = 0; (env = prom_getenv(part_name)); pcnt++)\r\npart_name[7] = '0' + pcnt + 1;\r\nif (pcnt == 0) {\r\nprintk(KERN_NOTICE "Skipping flash device %d "\r\n"(no partitions defined)\n", i);\r\ncontinue;\r\n}\r\nmsp_parts[i] = kcalloc(pcnt, sizeof(struct mtd_partition),\r\nGFP_KERNEL);\r\nif (!msp_parts[i])\r\ngoto cleanup_loop;\r\nflash_name[5] = '0' + i;\r\nenv = prom_getenv(flash_name);\r\nif (sscanf(env, "%x:%x", &addr, &size) < 2) {\r\nret = -ENXIO;\r\nkfree(msp_parts[i]);\r\ngoto cleanup_loop;\r\n}\r\naddr = CPHYSADDR(addr);\r\nprintk(KERN_NOTICE\r\n"MSP flash device \"%s\": 0x%08x at 0x%08x\n",\r\nflash_name, size, addr);\r\nmsp_maps[i].size = size;\r\nmsp_maps[i].phys = addr;\r\nif (size > CONFIG_MSP_FLASH_MAP_LIMIT)\r\nsize = CONFIG_MSP_FLASH_MAP_LIMIT;\r\nmsp_maps[i].virt = ioremap(addr, size);\r\nif (msp_maps[i].virt == NULL) {\r\nret = -ENXIO;\r\nkfree(msp_parts[i]);\r\ngoto cleanup_loop;\r\n}\r\nmsp_maps[i].bankwidth = 1;\r\nmsp_maps[i].name = kmalloc(7, GFP_KERNEL);\r\nif (!msp_maps[i].name) {\r\niounmap(msp_maps[i].virt);\r\nkfree(msp_parts[i]);\r\ngoto cleanup_loop;\r\n}\r\nmsp_maps[i].name = strncpy(msp_maps[i].name, flash_name, 7);\r\nfor (j = 0; j < pcnt; j++) {\r\npart_name[5] = '0' + i;\r\npart_name[7] = '0' + j;\r\nenv = prom_getenv(part_name);\r\nif (sscanf(env, "%x:%x:%n", &offset, &size,\r\n&coff) < 2) {\r\nret = -ENXIO;\r\nkfree(msp_maps[i].name);\r\niounmap(msp_maps[i].virt);\r\nkfree(msp_parts[i]);\r\ngoto cleanup_loop;\r\n}\r\nmsp_parts[i][j].size = size;\r\nmsp_parts[i][j].offset = offset;\r\nmsp_parts[i][j].name = env + coff;\r\n}\r\nsimple_map_init(&msp_maps[i]);\r\nmsp_flash[i] = do_map_probe("cfi_probe", &msp_maps[i]);\r\nif (msp_flash[i]) {\r\nmsp_flash[i]->owner = THIS_MODULE;\r\nmtd_device_register(msp_flash[i], msp_parts[i], pcnt);\r\n} else {\r\nprintk(KERN_ERR "map probe failed for flash\n");\r\nret = -ENXIO;\r\nkfree(msp_maps[i].name);\r\niounmap(msp_maps[i].virt);\r\nkfree(msp_parts[i]);\r\ngoto cleanup_loop;\r\n}\r\n}\r\nreturn 0;\r\ncleanup_loop:\r\nwhile (i--) {\r\nmtd_device_unregister(msp_flash[i]);\r\nmap_destroy(msp_flash[i]);\r\nkfree(msp_maps[i].name);\r\niounmap(msp_maps[i].virt);\r\nkfree(msp_parts[i]);\r\n}\r\nkfree(msp_maps);\r\nfree_msp_parts:\r\nkfree(msp_parts);\r\nfree_msp_flash:\r\nkfree(msp_flash);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_msp_flash(void)\r\n{\r\nint i;\r\nfor (i = 0; i < fcnt; i++) {\r\nmtd_device_unregister(msp_flash[i]);\r\nmap_destroy(msp_flash[i]);\r\niounmap((void *)msp_maps[i].virt);\r\nkfree(msp_maps[i].name);\r\nkfree(msp_parts[i]);\r\n}\r\nkfree(msp_flash);\r\nkfree(msp_parts);\r\nkfree(msp_maps);\r\n}
