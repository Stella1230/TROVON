static void flush_fifo(struct s3c64xx_spi_driver_data *sdd)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long loops;\r\nu32 val;\r\nwritel(0, regs + S3C64XX_SPI_PACKET_CNT);\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~(S3C64XX_SPI_CH_RXCH_ON | S3C64XX_SPI_CH_TXCH_ON);\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval |= S3C64XX_SPI_CH_SW_RST;\r\nval &= ~S3C64XX_SPI_CH_HS_EN;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nloops = msecs_to_loops(1);\r\ndo {\r\nval = readl(regs + S3C64XX_SPI_STATUS);\r\n} while (TX_FIFO_LVL(val, sdd) && loops--);\r\nif (loops == 0)\r\ndev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");\r\nloops = msecs_to_loops(1);\r\ndo {\r\nval = readl(regs + S3C64XX_SPI_STATUS);\r\nif (RX_FIFO_LVL(val, sdd))\r\nreadl(regs + S3C64XX_SPI_RX_DATA);\r\nelse\r\nbreak;\r\n} while (loops--);\r\nif (loops == 0)\r\ndev_warn(&sdd->pdev->dev, "Timed out flushing RX FIFO\n");\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~S3C64XX_SPI_CH_SW_RST;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\n}\r\nstatic void s3c64xx_spi_dmacb(void *data)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_dma_data *dma = data;\r\nunsigned long flags;\r\nif (dma->direction == DMA_DEV_TO_MEM)\r\nsdd = container_of(data,\r\nstruct s3c64xx_spi_driver_data, rx_dma);\r\nelse\r\nsdd = container_of(data,\r\nstruct s3c64xx_spi_driver_data, tx_dma);\r\nspin_lock_irqsave(&sdd->lock, flags);\r\nif (dma->direction == DMA_DEV_TO_MEM) {\r\nsdd->state &= ~RXBUSY;\r\nif (!(sdd->state & TXBUSY))\r\ncomplete(&sdd->xfer_completion);\r\n} else {\r\nsdd->state &= ~TXBUSY;\r\nif (!(sdd->state & RXBUSY))\r\ncomplete(&sdd->xfer_completion);\r\n}\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\n}\r\nstatic void prepare_dma(struct s3c64xx_spi_dma_data *dma,\r\nstruct sg_table *sgt)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct dma_slave_config config;\r\nstruct dma_async_tx_descriptor *desc;\r\nmemset(&config, 0, sizeof(config));\r\nif (dma->direction == DMA_DEV_TO_MEM) {\r\nsdd = container_of((void *)dma,\r\nstruct s3c64xx_spi_driver_data, rx_dma);\r\nconfig.direction = dma->direction;\r\nconfig.src_addr = sdd->sfr_start + S3C64XX_SPI_RX_DATA;\r\nconfig.src_addr_width = sdd->cur_bpw / 8;\r\nconfig.src_maxburst = 1;\r\ndmaengine_slave_config(dma->ch, &config);\r\n} else {\r\nsdd = container_of((void *)dma,\r\nstruct s3c64xx_spi_driver_data, tx_dma);\r\nconfig.direction = dma->direction;\r\nconfig.dst_addr = sdd->sfr_start + S3C64XX_SPI_TX_DATA;\r\nconfig.dst_addr_width = sdd->cur_bpw / 8;\r\nconfig.dst_maxburst = 1;\r\ndmaengine_slave_config(dma->ch, &config);\r\n}\r\ndesc = dmaengine_prep_slave_sg(dma->ch, sgt->sgl, sgt->nents,\r\ndma->direction, DMA_PREP_INTERRUPT);\r\ndesc->callback = s3c64xx_spi_dmacb;\r\ndesc->callback_param = dma;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(dma->ch);\r\n}\r\nstatic void s3c64xx_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd =\r\nspi_master_get_devdata(spi->master);\r\nif (sdd->cntrlr_info->no_cs)\r\nreturn;\r\nif (enable) {\r\nif (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO)) {\r\nwritel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\n} else {\r\nu32 ssel = readl(sdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\nssel |= (S3C64XX_SPI_SLAVE_AUTO |\r\nS3C64XX_SPI_SLAVE_NSC_CNT_2);\r\nwritel(ssel, sdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\n}\r\n} else {\r\nif (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))\r\nwritel(S3C64XX_SPI_SLAVE_SIG_INACT,\r\nsdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\n}\r\n}\r\nstatic int s3c64xx_spi_prepare_transfer(struct spi_master *spi)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(spi);\r\ndma_filter_fn filter = sdd->cntrlr_info->filter;\r\nstruct device *dev = &sdd->pdev->dev;\r\ndma_cap_mask_t mask;\r\nif (is_polling(sdd))\r\nreturn 0;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nsdd->rx_dma.ch = dma_request_slave_channel_compat(mask, filter,\r\nsdd->cntrlr_info->dma_rx, dev, "rx");\r\nif (!sdd->rx_dma.ch) {\r\ndev_err(dev, "Failed to get RX DMA channel\n");\r\nreturn -EBUSY;\r\n}\r\nspi->dma_rx = sdd->rx_dma.ch;\r\nsdd->tx_dma.ch = dma_request_slave_channel_compat(mask, filter,\r\nsdd->cntrlr_info->dma_tx, dev, "tx");\r\nif (!sdd->tx_dma.ch) {\r\ndev_err(dev, "Failed to get TX DMA channel\n");\r\ndma_release_channel(sdd->rx_dma.ch);\r\nreturn -EBUSY;\r\n}\r\nspi->dma_tx = sdd->tx_dma.ch;\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_unprepare_transfer(struct spi_master *spi)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(spi);\r\nif (!is_polling(sdd)) {\r\ndma_release_channel(sdd->rx_dma.ch);\r\ndma_release_channel(sdd->tx_dma.ch);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool s3c64xx_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nreturn xfer->len > (FIFO_LVL_MASK(sdd) >> 1) + 1;\r\n}\r\nstatic void enable_datapath(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer, int dma_mode)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nu32 modecfg, chcfg;\r\nmodecfg = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nmodecfg &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\r\nchcfg = readl(regs + S3C64XX_SPI_CH_CFG);\r\nchcfg &= ~S3C64XX_SPI_CH_TXCH_ON;\r\nif (dma_mode) {\r\nchcfg &= ~S3C64XX_SPI_CH_RXCH_ON;\r\n} else {\r\nchcfg |= S3C64XX_SPI_CH_RXCH_ON;\r\nwritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\r\n| S3C64XX_SPI_PACKET_CNT_EN,\r\nregs + S3C64XX_SPI_PACKET_CNT);\r\n}\r\nif (xfer->tx_buf != NULL) {\r\nsdd->state |= TXBUSY;\r\nchcfg |= S3C64XX_SPI_CH_TXCH_ON;\r\nif (dma_mode) {\r\nmodecfg |= S3C64XX_SPI_MODE_TXDMA_ON;\r\nprepare_dma(&sdd->tx_dma, &xfer->tx_sg);\r\n} else {\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\niowrite32_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len / 4);\r\nbreak;\r\ncase 16:\r\niowrite16_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len / 2);\r\nbreak;\r\ndefault:\r\niowrite8_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (xfer->rx_buf != NULL) {\r\nsdd->state |= RXBUSY;\r\nif (sdd->port_conf->high_speed && sdd->cur_speed >= 30000000UL\r\n&& !(sdd->cur_mode & SPI_CPHA))\r\nchcfg |= S3C64XX_SPI_CH_HS_EN;\r\nif (dma_mode) {\r\nmodecfg |= S3C64XX_SPI_MODE_RXDMA_ON;\r\nchcfg |= S3C64XX_SPI_CH_RXCH_ON;\r\nwritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\r\n| S3C64XX_SPI_PACKET_CNT_EN,\r\nregs + S3C64XX_SPI_PACKET_CNT);\r\nprepare_dma(&sdd->rx_dma, &xfer->rx_sg);\r\n}\r\n}\r\nwritel(modecfg, regs + S3C64XX_SPI_MODE_CFG);\r\nwritel(chcfg, regs + S3C64XX_SPI_CH_CFG);\r\n}\r\nstatic u32 s3c64xx_spi_wait_for_timeout(struct s3c64xx_spi_driver_data *sdd,\r\nint timeout_ms)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long val = 1;\r\nu32 status;\r\nu32 max_fifo = (FIFO_LVL_MASK(sdd) >> 1) + 1;\r\nif (timeout_ms)\r\nval = msecs_to_loops(timeout_ms);\r\ndo {\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\n} while (RX_FIFO_LVL(status, sdd) < max_fifo && --val);\r\nreturn RX_FIFO_LVL(status, sdd);\r\n}\r\nstatic int wait_for_dma(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_transfer *xfer)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long val;\r\nu32 status;\r\nint ms;\r\nms = xfer->len * 8 * 1000 / sdd->cur_speed;\r\nms += 10;\r\nval = msecs_to_jiffies(ms) + 10;\r\nval = wait_for_completion_timeout(&sdd->xfer_completion, val);\r\nif (val && !xfer->rx_buf) {\r\nval = msecs_to_loops(10);\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\nwhile ((TX_FIFO_LVL(status, sdd)\r\n|| !S3C64XX_SPI_ST_TX_DONE(status, sdd))\r\n&& --val) {\r\ncpu_relax();\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\n}\r\n}\r\nif (!val)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int wait_for_pio(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_transfer *xfer)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long val;\r\nu32 status;\r\nint loops;\r\nu32 cpy_len;\r\nu8 *buf;\r\nint ms;\r\nms = xfer->len * 8 * 1000 / sdd->cur_speed;\r\nms += 10;\r\nval = msecs_to_loops(ms);\r\ndo {\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\n} while (RX_FIFO_LVL(status, sdd) < xfer->len && --val);\r\nif (!xfer->rx_buf) {\r\nsdd->state &= ~TXBUSY;\r\nreturn 0;\r\n}\r\nloops = xfer->len / ((FIFO_LVL_MASK(sdd) >> 1) + 1);\r\nbuf = xfer->rx_buf;\r\ndo {\r\ncpy_len = s3c64xx_spi_wait_for_timeout(sdd,\r\n(loops ? ms : 0));\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\nioread32_rep(regs + S3C64XX_SPI_RX_DATA,\r\nbuf, cpy_len / 4);\r\nbreak;\r\ncase 16:\r\nioread16_rep(regs + S3C64XX_SPI_RX_DATA,\r\nbuf, cpy_len / 2);\r\nbreak;\r\ndefault:\r\nioread8_rep(regs + S3C64XX_SPI_RX_DATA,\r\nbuf, cpy_len);\r\nbreak;\r\n}\r\nbuf = buf + cpy_len;\r\n} while (loops--);\r\nsdd->state &= ~RXBUSY;\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_spi_config(struct s3c64xx_spi_driver_data *sdd)\r\n{\r\nvoid __iomem *regs = sdd->regs;\r\nu32 val;\r\nif (!sdd->port_conf->clk_from_cmu) {\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval &= ~S3C64XX_SPI_ENCLK_ENABLE;\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\n}\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~(S3C64XX_SPI_CH_SLAVE |\r\nS3C64XX_SPI_CPOL_L |\r\nS3C64XX_SPI_CPHA_B);\r\nif (sdd->cur_mode & SPI_CPOL)\r\nval |= S3C64XX_SPI_CPOL_L;\r\nif (sdd->cur_mode & SPI_CPHA)\r\nval |= S3C64XX_SPI_CPHA_B;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~(S3C64XX_SPI_MODE_BUS_TSZ_MASK\r\n| S3C64XX_SPI_MODE_CH_TSZ_MASK);\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_WORD;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_WORD;\r\nbreak;\r\ncase 16:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_HALFWORD;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_HALFWORD;\r\nbreak;\r\ndefault:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_BYTE;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_BYTE;\r\nbreak;\r\n}\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\nif (sdd->port_conf->clk_from_cmu) {\r\nclk_set_rate(sdd->src_clk, sdd->cur_speed * 2);\r\n} else {\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval &= ~S3C64XX_SPI_PSR_MASK;\r\nval |= ((clk_get_rate(sdd->src_clk) / sdd->cur_speed / 2 - 1)\r\n& S3C64XX_SPI_PSR_MASK);\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval |= S3C64XX_SPI_ENCLK_ENABLE;\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\n}\r\n}\r\nstatic int s3c64xx_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\nstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\r\nwritel(cs->fb_delay & 0x3, sdd->regs + S3C64XX_SPI_FB_CLK);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nint status;\r\nu32 speed;\r\nu8 bpw;\r\nunsigned long flags;\r\nint use_dma;\r\nreinit_completion(&sdd->xfer_completion);\r\nbpw = xfer->bits_per_word;\r\nspeed = xfer->speed_hz;\r\nif (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {\r\nsdd->cur_bpw = bpw;\r\nsdd->cur_speed = speed;\r\nsdd->cur_mode = spi->mode;\r\ns3c64xx_spi_config(sdd);\r\n}\r\nuse_dma = 0;\r\nif (!is_polling(sdd) &&\r\n(sdd->rx_dma.ch && sdd->tx_dma.ch &&\r\n(xfer->len > ((FIFO_LVL_MASK(sdd) >> 1) + 1))))\r\nuse_dma = 1;\r\nspin_lock_irqsave(&sdd->lock, flags);\r\nsdd->state &= ~RXBUSY;\r\nsdd->state &= ~TXBUSY;\r\nenable_datapath(sdd, spi, xfer, use_dma);\r\ns3c64xx_spi_set_cs(spi, true);\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\nif (use_dma)\r\nstatus = wait_for_dma(sdd, xfer);\r\nelse\r\nstatus = wait_for_pio(sdd, xfer);\r\nif (status) {\r\ndev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",\r\nxfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,\r\n(sdd->state & RXBUSY) ? 'f' : 'p',\r\n(sdd->state & TXBUSY) ? 'f' : 'p',\r\nxfer->len);\r\nif (use_dma) {\r\nif (xfer->tx_buf != NULL\r\n&& (sdd->state & TXBUSY))\r\ndmaengine_terminate_all(sdd->tx_dma.ch);\r\nif (xfer->rx_buf != NULL\r\n&& (sdd->state & RXBUSY))\r\ndmaengine_terminate_all(sdd->rx_dma.ch);\r\n}\r\n} else {\r\nflush_fifo(sdd);\r\n}\r\nreturn status;\r\n}\r\nstatic struct s3c64xx_spi_csinfo *s3c64xx_get_slave_ctrldata(\r\nstruct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs;\r\nstruct device_node *slave_np, *data_np = NULL;\r\nu32 fb_delay = 0;\r\nslave_np = spi->dev.of_node;\r\nif (!slave_np) {\r\ndev_err(&spi->dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndata_np = of_get_child_by_name(slave_np, "controller-data");\r\nif (!data_np) {\r\ndev_err(&spi->dev, "child node 'controller-data' not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs) {\r\nof_node_put(data_np);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nof_property_read_u32(data_np, "samsung,spi-feedback-delay", &fb_delay);\r\ncs->fb_delay = fb_delay;\r\nof_node_put(data_np);\r\nreturn cs;\r\n}\r\nstatic int s3c64xx_spi_setup(struct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_info *sci;\r\nint err;\r\nsdd = spi_master_get_devdata(spi->master);\r\nif (spi->dev.of_node) {\r\ncs = s3c64xx_get_slave_ctrldata(spi);\r\nspi->controller_data = cs;\r\n} else if (cs) {\r\nspi->cs_gpio = cs->line;\r\n}\r\nif (IS_ERR_OR_NULL(cs)) {\r\ndev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);\r\nreturn -ENODEV;\r\n}\r\nif (!spi_get_ctldata(spi)) {\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nerr = gpio_request_one(spi->cs_gpio, GPIOF_OUT_INIT_HIGH,\r\ndev_name(&spi->dev));\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"Failed to get /CS gpio [%d]: %d\n",\r\nspi->cs_gpio, err);\r\ngoto err_gpio_req;\r\n}\r\n}\r\nspi_set_ctldata(spi, cs);\r\n}\r\nsci = sdd->cntrlr_info;\r\npm_runtime_get_sync(&sdd->pdev->dev);\r\nif (!sdd->port_conf->clk_from_cmu) {\r\nu32 psr, speed;\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (0 + 1);\r\nif (spi->max_speed_hz > speed)\r\nspi->max_speed_hz = speed;\r\npsr = clk_get_rate(sdd->src_clk) / 2 / spi->max_speed_hz - 1;\r\npsr &= S3C64XX_SPI_PSR_MASK;\r\nif (psr == S3C64XX_SPI_PSR_MASK)\r\npsr--;\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);\r\nif (spi->max_speed_hz < speed) {\r\nif (psr+1 < S3C64XX_SPI_PSR_MASK) {\r\npsr++;\r\n} else {\r\nerr = -EINVAL;\r\ngoto setup_exit;\r\n}\r\n}\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);\r\nif (spi->max_speed_hz >= speed) {\r\nspi->max_speed_hz = speed;\r\n} else {\r\ndev_err(&spi->dev, "Can't set %dHz transfer speed\n",\r\nspi->max_speed_hz);\r\nerr = -EINVAL;\r\ngoto setup_exit;\r\n}\r\n}\r\npm_runtime_mark_last_busy(&sdd->pdev->dev);\r\npm_runtime_put_autosuspend(&sdd->pdev->dev);\r\ns3c64xx_spi_set_cs(spi, false);\r\nreturn 0;\r\nsetup_exit:\r\npm_runtime_mark_last_busy(&sdd->pdev->dev);\r\npm_runtime_put_autosuspend(&sdd->pdev->dev);\r\ns3c64xx_spi_set_cs(spi, false);\r\nif (gpio_is_valid(spi->cs_gpio))\r\ngpio_free(spi->cs_gpio);\r\nspi_set_ctldata(spi, NULL);\r\nerr_gpio_req:\r\nif (spi->dev.of_node)\r\nkfree(cs);\r\nreturn err;\r\n}\r\nstatic void s3c64xx_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs = spi_get_ctldata(spi);\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\ngpio_free(spi->cs_gpio);\r\nif (spi->dev.of_node)\r\nkfree(cs);\r\nelse {\r\nspi->cs_gpio = -ENOENT;\r\n}\r\n}\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nstatic irqreturn_t s3c64xx_spi_irq(int irq, void *data)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = data;\r\nstruct spi_master *spi = sdd->master;\r\nunsigned int val, clr = 0;\r\nval = readl(sdd->regs + S3C64XX_SPI_STATUS);\r\nif (val & S3C64XX_SPI_ST_RX_OVERRUN_ERR) {\r\nclr = S3C64XX_SPI_PND_RX_OVERRUN_CLR;\r\ndev_err(&spi->dev, "RX overrun\n");\r\n}\r\nif (val & S3C64XX_SPI_ST_RX_UNDERRUN_ERR) {\r\nclr |= S3C64XX_SPI_PND_RX_UNDERRUN_CLR;\r\ndev_err(&spi->dev, "RX underrun\n");\r\n}\r\nif (val & S3C64XX_SPI_ST_TX_OVERRUN_ERR) {\r\nclr |= S3C64XX_SPI_PND_TX_OVERRUN_CLR;\r\ndev_err(&spi->dev, "TX overrun\n");\r\n}\r\nif (val & S3C64XX_SPI_ST_TX_UNDERRUN_ERR) {\r\nclr |= S3C64XX_SPI_PND_TX_UNDERRUN_CLR;\r\ndev_err(&spi->dev, "TX underrun\n");\r\n}\r\nwritel(clr, sdd->regs + S3C64XX_SPI_PENDING_CLR);\r\nwritel(0, sdd->regs + S3C64XX_SPI_PENDING_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s3c64xx_spi_hwinit(struct s3c64xx_spi_driver_data *sdd, int channel)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned int val;\r\nsdd->cur_speed = 0;\r\nif (sci->no_cs)\r\nwritel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\nelse if (!(sdd->port_conf->quirks & S3C64XX_SPI_QUIRK_CS_AUTO))\r\nwritel(S3C64XX_SPI_SLAVE_SIG_INACT, sdd->regs + S3C64XX_SPI_SLAVE_SEL);\r\nwritel(0, regs + S3C64XX_SPI_INT_EN);\r\nif (!sdd->port_conf->clk_from_cmu)\r\nwritel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,\r\nregs + S3C64XX_SPI_CLK_CFG);\r\nwritel(0, regs + S3C64XX_SPI_MODE_CFG);\r\nwritel(0, regs + S3C64XX_SPI_PACKET_CNT);\r\nval = S3C64XX_SPI_PND_RX_OVERRUN_CLR |\r\nS3C64XX_SPI_PND_RX_UNDERRUN_CLR |\r\nS3C64XX_SPI_PND_TX_OVERRUN_CLR |\r\nS3C64XX_SPI_PND_TX_UNDERRUN_CLR;\r\nwritel(val, regs + S3C64XX_SPI_PENDING_CLR);\r\nwritel(0, regs + S3C64XX_SPI_PENDING_CLR);\r\nwritel(0, regs + S3C64XX_SPI_SWAP_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~S3C64XX_SPI_MODE_4BURST;\r\nval &= ~(S3C64XX_SPI_MAX_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\r\nval |= (S3C64XX_SPI_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\nflush_fifo(sdd);\r\n}\r\nstatic struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)\r\n{\r\nstruct s3c64xx_spi_info *sci;\r\nu32 temp;\r\nsci = devm_kzalloc(dev, sizeof(*sci), GFP_KERNEL);\r\nif (!sci)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (of_property_read_u32(dev->of_node, "samsung,spi-src-clk", &temp)) {\r\ndev_warn(dev, "spi bus clock parent not specified, using clock at index 0 as parent\n");\r\nsci->src_clk_nr = 0;\r\n} else {\r\nsci->src_clk_nr = temp;\r\n}\r\nif (of_property_read_u32(dev->of_node, "num-cs", &temp)) {\r\ndev_warn(dev, "number of chip select lines not specified, assuming 1 chip select line\n");\r\nsci->num_cs = 1;\r\n} else {\r\nsci->num_cs = temp;\r\n}\r\nsci->no_cs = of_property_read_bool(dev->of_node, "broken-cs");\r\nreturn sci;\r\n}\r\nstatic struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)\r\n{\r\nreturn dev_get_platdata(dev);\r\n}\r\nstatic inline struct s3c64xx_spi_port_config *s3c64xx_spi_get_port_config(\r\nstruct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_OF\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(s3c64xx_spi_dt_match, pdev->dev.of_node);\r\nreturn (struct s3c64xx_spi_port_config *)match->data;\r\n}\r\n#endif\r\nreturn (struct s3c64xx_spi_port_config *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int s3c64xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_res;\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_info *sci = dev_get_platdata(&pdev->dev);\r\nstruct spi_master *master;\r\nint ret, irq;\r\nchar clk_name[16];\r\nif (!sci && pdev->dev.of_node) {\r\nsci = s3c64xx_spi_parse_dt(&pdev->dev);\r\nif (IS_ERR(sci))\r\nreturn PTR_ERR(sci);\r\n}\r\nif (!sci) {\r\ndev_err(&pdev->dev, "platform_data missing!\n");\r\nreturn -ENODEV;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem_res == NULL) {\r\ndev_err(&pdev->dev, "Unable to get SPI MEM resource\n");\r\nreturn -ENXIO;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "Failed to get IRQ: %d\n", irq);\r\nreturn irq;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev,\r\nsizeof(struct s3c64xx_spi_driver_data));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate SPI Master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nsdd = spi_master_get_devdata(master);\r\nsdd->port_conf = s3c64xx_spi_get_port_config(pdev);\r\nsdd->master = master;\r\nsdd->cntrlr_info = sci;\r\nsdd->pdev = pdev;\r\nsdd->sfr_start = mem_res->start;\r\nif (pdev->dev.of_node) {\r\nret = of_alias_get_id(pdev->dev.of_node, "spi");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n",\r\nret);\r\ngoto err_deref_master;\r\n}\r\nsdd->port_id = ret;\r\n} else {\r\nsdd->port_id = pdev->id;\r\n}\r\nsdd->cur_bpw = 8;\r\nif (!sdd->pdev->dev.of_node && (!sci->dma_tx || !sci->dma_rx)) {\r\ndev_warn(&pdev->dev, "Unable to get SPI tx/rx DMA data. Switching to poll mode\n");\r\nsdd->port_conf->quirks = S3C64XX_SPI_QUIRK_POLL;\r\n}\r\nsdd->tx_dma.direction = DMA_MEM_TO_DEV;\r\nsdd->rx_dma.direction = DMA_DEV_TO_MEM;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bus_num = sdd->port_id;\r\nmaster->setup = s3c64xx_spi_setup;\r\nmaster->cleanup = s3c64xx_spi_cleanup;\r\nmaster->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;\r\nmaster->prepare_message = s3c64xx_spi_prepare_message;\r\nmaster->transfer_one = s3c64xx_spi_transfer_one;\r\nmaster->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;\r\nmaster->num_chipselect = sci->num_cs;\r\nmaster->dma_alignment = 8;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |\r\nSPI_BPW_MASK(8);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->auto_runtime_pm = true;\r\nif (!is_polling(sdd))\r\nmaster->can_dma = s3c64xx_spi_can_dma;\r\nsdd->regs = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(sdd->regs)) {\r\nret = PTR_ERR(sdd->regs);\r\ngoto err_deref_master;\r\n}\r\nif (sci->cfg_gpio && sci->cfg_gpio()) {\r\ndev_err(&pdev->dev, "Unable to config gpio\n");\r\nret = -EBUSY;\r\ngoto err_deref_master;\r\n}\r\nsdd->clk = devm_clk_get(&pdev->dev, "spi");\r\nif (IS_ERR(sdd->clk)) {\r\ndev_err(&pdev->dev, "Unable to acquire clock 'spi'\n");\r\nret = PTR_ERR(sdd->clk);\r\ngoto err_deref_master;\r\n}\r\nret = clk_prepare_enable(sdd->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't enable clock 'spi'\n");\r\ngoto err_deref_master;\r\n}\r\nsprintf(clk_name, "spi_busclk%d", sci->src_clk_nr);\r\nsdd->src_clk = devm_clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(sdd->src_clk)) {\r\ndev_err(&pdev->dev,\r\n"Unable to acquire clock '%s'\n", clk_name);\r\nret = PTR_ERR(sdd->src_clk);\r\ngoto err_disable_clk;\r\n}\r\nret = clk_prepare_enable(sdd->src_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't enable clock '%s'\n", clk_name);\r\ngoto err_disable_clk;\r\n}\r\nif (sdd->port_conf->clk_ioclk) {\r\nsdd->ioclk = devm_clk_get(&pdev->dev, "spi_ioclk");\r\nif (IS_ERR(sdd->ioclk)) {\r\ndev_err(&pdev->dev, "Unable to acquire 'ioclk'\n");\r\nret = PTR_ERR(sdd->ioclk);\r\ngoto err_disable_src_clk;\r\n}\r\nret = clk_prepare_enable(sdd->ioclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't enable clock 'ioclk'\n");\r\ngoto err_disable_src_clk;\r\n}\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\ns3c64xx_spi_hwinit(sdd, sdd->port_id);\r\nspin_lock_init(&sdd->lock);\r\ninit_completion(&sdd->xfer_completion);\r\nret = devm_request_irq(&pdev->dev, irq, s3c64xx_spi_irq, 0,\r\n"spi-s3c64xx", sdd);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err_pm_put;\r\n}\r\nwritel(S3C64XX_SPI_INT_RX_OVERRUN_EN | S3C64XX_SPI_INT_RX_UNDERRUN_EN |\r\nS3C64XX_SPI_INT_TX_OVERRUN_EN | S3C64XX_SPI_INT_TX_UNDERRUN_EN,\r\nsdd->regs + S3C64XX_SPI_INT_EN);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot register SPI master: %d\n", ret);\r\ngoto err_pm_put;\r\n}\r\ndev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d with %d Slaves attached\n",\r\nsdd->port_id, master->num_chipselect);\r\ndev_dbg(&pdev->dev, "\tIOmem=[%pR]\tFIFO %dbytes\tDMA=[Rx-%p, Tx-%p]\n",\r\nmem_res, (FIFO_LVL_MASK(sdd) >> 1) + 1,\r\nsci->dma_rx, sci->dma_tx);\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nerr_pm_put:\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\nclk_disable_unprepare(sdd->ioclk);\r\nerr_disable_src_clk:\r\nclk_disable_unprepare(sdd->src_clk);\r\nerr_disable_clk:\r\nclk_disable_unprepare(sdd->clk);\r\nerr_deref_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int s3c64xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\npm_runtime_get_sync(&pdev->dev);\r\nwritel(0, sdd->regs + S3C64XX_SPI_INT_EN);\r\nclk_disable_unprepare(sdd->ioclk);\r\nclk_disable_unprepare(sdd->src_clk);\r\nclk_disable_unprepare(sdd->clk);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nint ret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nret = pm_runtime_force_suspend(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nsdd->cur_speed = 0;\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nint ret;\r\nif (sci->cfg_gpio)\r\nsci->cfg_gpio();\r\nret = pm_runtime_force_resume(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ns3c64xx_spi_hwinit(sdd, sdd->port_id);\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int s3c64xx_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nclk_disable_unprepare(sdd->clk);\r\nclk_disable_unprepare(sdd->src_clk);\r\nclk_disable_unprepare(sdd->ioclk);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nint ret;\r\nif (sdd->port_conf->clk_ioclk) {\r\nret = clk_prepare_enable(sdd->ioclk);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(sdd->src_clk);\r\nif (ret != 0)\r\ngoto err_disable_ioclk;\r\nret = clk_prepare_enable(sdd->clk);\r\nif (ret != 0)\r\ngoto err_disable_src_clk;\r\nreturn 0;\r\nerr_disable_src_clk:\r\nclk_disable_unprepare(sdd->src_clk);\r\nerr_disable_ioclk:\r\nclk_disable_unprepare(sdd->ioclk);\r\nreturn ret;\r\n}
