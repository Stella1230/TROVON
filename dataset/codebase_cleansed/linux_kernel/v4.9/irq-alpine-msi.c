static void alpine_msix_mask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_mask_irq(d);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void alpine_msix_unmask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_unmask_irq(d);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic int alpine_msix_allocate_sgi(struct alpine_msix_data *priv, int num_req)\r\n{\r\nint first;\r\nspin_lock(&priv->msi_map_lock);\r\nfirst = bitmap_find_next_zero_area(priv->msi_map, priv->num_spis, 0,\r\nnum_req, 0);\r\nif (first >= priv->num_spis) {\r\nspin_unlock(&priv->msi_map_lock);\r\nreturn -ENOSPC;\r\n}\r\nbitmap_set(priv->msi_map, first, num_req);\r\nspin_unlock(&priv->msi_map_lock);\r\nreturn priv->spi_first + first;\r\n}\r\nstatic void alpine_msix_free_sgi(struct alpine_msix_data *priv, unsigned sgi,\r\nint num_req)\r\n{\r\nint first = sgi - priv->spi_first;\r\nspin_lock(&priv->msi_map_lock);\r\nbitmap_clear(priv->msi_map, first, num_req);\r\nspin_unlock(&priv->msi_map_lock);\r\n}\r\nstatic void alpine_msix_compose_msi_msg(struct irq_data *data,\r\nstruct msi_msg *msg)\r\n{\r\nstruct alpine_msix_data *priv = irq_data_get_irq_chip_data(data);\r\nphys_addr_t msg_addr = priv->addr;\r\nmsg_addr |= (data->hwirq << 3);\r\nmsg->address_hi = upper_32_bits(msg_addr);\r\nmsg->address_lo = lower_32_bits(msg_addr);\r\nmsg->data = 0;\r\n}\r\nstatic int alpine_msix_gic_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq, int sgi)\r\n{\r\nstruct irq_fwspec fwspec;\r\nstruct irq_data *d;\r\nint ret;\r\nif (!is_of_node(domain->parent->fwnode))\r\nreturn -EINVAL;\r\nfwspec.fwnode = domain->parent->fwnode;\r\nfwspec.param_count = 3;\r\nfwspec.param[0] = 0;\r\nfwspec.param[1] = sgi;\r\nfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\r\nret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\r\nif (ret)\r\nreturn ret;\r\nd = irq_domain_get_irq_data(domain->parent, virq);\r\nd->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\r\nreturn 0;\r\n}\r\nstatic int alpine_msix_middle_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nstruct alpine_msix_data *priv = domain->host_data;\r\nint sgi, err, i;\r\nsgi = alpine_msix_allocate_sgi(priv, nr_irqs);\r\nif (sgi < 0)\r\nreturn sgi;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nerr = alpine_msix_gic_domain_alloc(domain, virq + i, sgi + i);\r\nif (err)\r\ngoto err_sgi;\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, sgi + i,\r\n&middle_irq_chip, priv);\r\n}\r\nreturn 0;\r\nerr_sgi:\r\nwhile (--i >= 0)\r\nirq_domain_free_irqs_parent(domain, virq, i);\r\nalpine_msix_free_sgi(priv, sgi, nr_irqs);\r\nreturn err;\r\n}\r\nstatic void alpine_msix_middle_domain_free(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nstruct alpine_msix_data *priv = irq_data_get_irq_chip_data(d);\r\nirq_domain_free_irqs_parent(domain, virq, nr_irqs);\r\nalpine_msix_free_sgi(priv, d->hwirq, nr_irqs);\r\n}\r\nstatic int alpine_msix_init_domains(struct alpine_msix_data *priv,\r\nstruct device_node *node)\r\n{\r\nstruct irq_domain *middle_domain, *msi_domain, *gic_domain;\r\nstruct device_node *gic_node;\r\ngic_node = of_irq_find_parent(node);\r\nif (!gic_node) {\r\npr_err("Failed to find the GIC node\n");\r\nreturn -ENODEV;\r\n}\r\ngic_domain = irq_find_host(gic_node);\r\nif (!gic_domain) {\r\npr_err("Failed to find the GIC domain\n");\r\nreturn -ENXIO;\r\n}\r\nmiddle_domain = irq_domain_add_tree(NULL,\r\n&alpine_msix_middle_domain_ops,\r\npriv);\r\nif (!middle_domain) {\r\npr_err("Failed to create the MSIX middle domain\n");\r\nreturn -ENOMEM;\r\n}\r\nmiddle_domain->parent = gic_domain;\r\nmsi_domain = pci_msi_create_irq_domain(of_node_to_fwnode(node),\r\n&alpine_msix_domain_info,\r\nmiddle_domain);\r\nif (!msi_domain) {\r\npr_err("Failed to create MSI domain\n");\r\nirq_domain_remove(middle_domain);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alpine_msix_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct alpine_msix_data *priv;\r\nstruct resource res;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->msi_map_lock);\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret) {\r\npr_err("Failed to allocate resource\n");\r\ngoto err_priv;\r\n}\r\npriv->addr = res.start & GENMASK_ULL(63,20);\r\npriv->addr |= ALPINE_MSIX_SPI_TARGET_CLUSTER0;\r\nif (of_property_read_u32(node, "al,msi-base-spi", &priv->spi_first)) {\r\npr_err("Unable to parse MSI base\n");\r\nret = -EINVAL;\r\ngoto err_priv;\r\n}\r\nif (of_property_read_u32(node, "al,msi-num-spis", &priv->num_spis)) {\r\npr_err("Unable to parse MSI numbers\n");\r\nret = -EINVAL;\r\ngoto err_priv;\r\n}\r\npriv->msi_map = kzalloc(sizeof(*priv->msi_map) * BITS_TO_LONGS(priv->num_spis),\r\nGFP_KERNEL);\r\nif (!priv->msi_map) {\r\nret = -ENOMEM;\r\ngoto err_priv;\r\n}\r\npr_debug("Registering %d msixs, starting at %d\n",\r\npriv->num_spis, priv->spi_first);\r\nret = alpine_msix_init_domains(priv, node);\r\nif (ret)\r\ngoto err_map;\r\nreturn 0;\r\nerr_map:\r\nkfree(priv->msi_map);\r\nerr_priv:\r\nkfree(priv);\r\nreturn ret;\r\n}
