static unsigned char sel_pos(int n)\r\n{\r\nreturn inverse_translate(spk_sel_cons,\r\nscreen_glyph(spk_sel_cons, n), 0);\r\n}\r\nvoid speakup_clear_selection(void)\r\n{\r\nsel_start = -1;\r\n}\r\nstatic int atedge(const int p, int size_row)\r\n{\r\nreturn !(p % size_row) || !((p + 2) % size_row);\r\n}\r\nstatic unsigned short limit(const unsigned short v, const unsigned short u)\r\n{\r\nreturn (v > u) ? u : v;\r\n}\r\nint speakup_set_selection(struct tty_struct *tty)\r\n{\r\nint new_sel_start, new_sel_end;\r\nchar *bp, *obp;\r\nint i, ps, pe;\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nspk_xs = limit(spk_xs, vc->vc_cols - 1);\r\nspk_ys = limit(spk_ys, vc->vc_rows - 1);\r\nspk_xe = limit(spk_xe, vc->vc_cols - 1);\r\nspk_ye = limit(spk_ye, vc->vc_rows - 1);\r\nps = spk_ys * vc->vc_size_row + (spk_xs << 1);\r\npe = spk_ye * vc->vc_size_row + (spk_xe << 1);\r\nif (ps > pe) {\r\nint tmp = ps;\r\nps = pe;\r\npe = tmp;\r\n}\r\nif (spk_sel_cons != vc_cons[fg_console].d) {\r\nspeakup_clear_selection();\r\nspk_sel_cons = vc_cons[fg_console].d;\r\ndev_warn(tty->dev,\r\n"Selection: mark console not the same as cut\n");\r\nreturn -EINVAL;\r\n}\r\nnew_sel_start = ps;\r\nnew_sel_end = pe;\r\nif (new_sel_end > new_sel_start &&\r\n!atedge(new_sel_end, vc->vc_size_row) &&\r\nishardspace(sel_pos(new_sel_end))) {\r\nfor (pe = new_sel_end + 2; ; pe += 2)\r\nif (!ishardspace(sel_pos(pe)) ||\r\natedge(pe, vc->vc_size_row))\r\nbreak;\r\nif (ishardspace(sel_pos(pe)))\r\nnew_sel_end = pe;\r\n}\r\nif ((new_sel_start == sel_start) && (new_sel_end == sel_end))\r\nreturn 0;\r\nsel_start = new_sel_start;\r\nsel_end = new_sel_end;\r\nbp = kmalloc((sel_end-sel_start)/2+1, GFP_ATOMIC);\r\nif (!bp) {\r\nspeakup_clear_selection();\r\nreturn -ENOMEM;\r\n}\r\nkfree(sel_buffer);\r\nsel_buffer = bp;\r\nobp = bp;\r\nfor (i = sel_start; i <= sel_end; i += 2) {\r\n*bp = sel_pos(i);\r\nif (!ishardspace(*bp++))\r\nobp = bp;\r\nif (!((i + 2) % vc->vc_size_row)) {\r\nif (obp != bp) {\r\nbp = obp;\r\n*bp++ = '\r';\r\n}\r\nobp = bp;\r\n}\r\n}\r\nsel_buffer_lth = bp - sel_buffer;\r\nreturn 0;\r\n}\r\nstatic void __speakup_paste_selection(struct work_struct *work)\r\n{\r\nstruct speakup_paste_work *spw =\r\ncontainer_of(work, struct speakup_paste_work, work);\r\nstruct tty_struct *tty = xchg(&spw->tty, NULL);\r\nstruct vc_data *vc = (struct vc_data *) tty->driver_data;\r\nint pasted = 0, count;\r\nstruct tty_ldisc *ld;\r\nDECLARE_WAITQUEUE(wait, current);\r\nld = tty_ldisc_ref(tty);\r\nif (!ld)\r\ngoto tty_unref;\r\ntty_buffer_lock_exclusive(&vc->port);\r\nadd_wait_queue(&vc->paste_wait, &wait);\r\nwhile (sel_buffer && sel_buffer_lth > pasted) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_throttled(tty)) {\r\nschedule();\r\ncontinue;\r\n}\r\ncount = sel_buffer_lth - pasted;\r\ncount = tty_ldisc_receive_buf(ld, sel_buffer + pasted, NULL,\r\ncount);\r\npasted += count;\r\n}\r\nremove_wait_queue(&vc->paste_wait, &wait);\r\n__set_current_state(TASK_RUNNING);\r\ntty_buffer_unlock_exclusive(&vc->port);\r\ntty_ldisc_deref(ld);\r\ntty_unref:\r\ntty_kref_put(tty);\r\n}\r\nint speakup_paste_selection(struct tty_struct *tty)\r\n{\r\nif (cmpxchg(&speakup_paste_work.tty, NULL, tty) != NULL)\r\nreturn -EBUSY;\r\ntty_kref_get(tty);\r\nschedule_work_on(WORK_CPU_UNBOUND, &speakup_paste_work.work);\r\nreturn 0;\r\n}\r\nvoid speakup_cancel_paste(void)\r\n{\r\ncancel_work_sync(&speakup_paste_work.work);\r\ntty_kref_put(speakup_paste_work.tty);\r\n}
